// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitGlobalVariables ;
  11: CALL 78934 0 0
// InitVariables ;
  15: CALL 214 0 0
// if debug then
  19: LD_EXP 1
  23: IFFALSE 42
// begin FogOff ( 1 ) ;
  25: LD_INT 1
  27: PPUSH
  28: CALL_OW 344
// Difficulty := 2 ;
  32: LD_ADDR_OWVAR 67
  36: PUSH
  37: LD_INT 2
  39: ST_TO_ADDR
// end else
  40: GO 55
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  42: LD_ADDR_OWVAR 67
  46: PUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL_OW 426
  54: ST_TO_ADDR
// ChangeSideFog ( 4 , 1 ) ;
  55: LD_INT 4
  57: PPUSH
  58: LD_INT 1
  60: PPUSH
  61: CALL_OW 343
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , gensher_ape , 0 ) ;
  65: LD_INT 0
  67: PPUSH
  68: LD_INT 0
  70: PPUSH
  71: LD_INT 5
  73: PPUSH
  74: LD_INT 0
  76: PPUSH
  77: LD_INT 0
  79: PPUSH
  80: LD_INT 0
  82: PPUSH
  83: LD_INT 0
  85: PPUSH
  86: LD_INT 7
  88: PPUSH
  89: LD_INT 0
  91: PPUSH
  92: CALL 43293 0 9
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , powell_ape , 0 ) ;
  96: LD_INT 0
  98: PPUSH
  99: LD_INT 0
 101: PPUSH
 102: LD_INT 3
 104: PPUSH
 105: LD_INT 0
 107: PPUSH
 108: LD_INT 0
 110: PPUSH
 111: LD_INT 0
 113: PPUSH
 114: LD_INT 0
 116: PPUSH
 117: LD_INT 4
 119: PPUSH
 120: LD_INT 0
 122: PPUSH
 123: CALL 43293 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , popov_ape , 0 ) ;
 127: LD_INT 0
 129: PPUSH
 130: LD_INT 0
 132: PPUSH
 133: LD_INT 5
 135: PPUSH
 136: LD_INT 0
 138: PPUSH
 139: LD_INT 0
 141: PPUSH
 142: LD_INT 0
 144: PPUSH
 145: LD_INT 0
 147: PPUSH
 148: LD_INT 11
 150: PPUSH
 151: LD_INT 0
 153: PPUSH
 154: CALL 43293 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , sikorski_ape , 0 ) ;
 158: LD_INT 0
 160: PPUSH
 161: LD_INT 0
 163: PPUSH
 164: LD_INT 5
 166: PPUSH
 167: LD_INT 0
 169: PPUSH
 170: LD_INT 0
 172: PPUSH
 173: LD_INT 0
 175: PPUSH
 176: LD_INT 0
 178: PPUSH
 179: LD_INT 14
 181: PPUSH
 182: LD_INT 0
 184: PPUSH
 185: CALL 43293 0 9
// PrepareGensher ;
 189: CALL 2779 0 0
// PreparePopov ;
 193: CALL 5602 0 0
// PreparePowell ;
 197: CALL 593 0 0
// PrepareSikorski ;
 201: CALL 7984 0 0
// MC_Start ( ) ;
 205: CALL 50689 0 0
// Action ;
 209: CALL 8391 0 0
// end ;
 213: END
// export debug , game , staticMines , arDestroyed , ruDestroyed , loseCounter , powellLoseCounter , powellInTrouble , sikorskiInTrouble ; function InitVariables ; begin
 214: LD_INT 0
 216: PPUSH
// debug := false ;
 217: LD_ADDR_EXP 1
 221: PUSH
 222: LD_INT 0
 224: ST_TO_ADDR
// game := true ;
 225: LD_ADDR_EXP 2
 229: PUSH
 230: LD_INT 1
 232: ST_TO_ADDR
// staticMines := [ ] ;
 233: LD_ADDR_EXP 3
 237: PUSH
 238: EMPTY
 239: ST_TO_ADDR
// arDestroyed := false ;
 240: LD_ADDR_EXP 4
 244: PUSH
 245: LD_INT 0
 247: ST_TO_ADDR
// ruDestroyed := false ;
 248: LD_ADDR_EXP 5
 252: PUSH
 253: LD_INT 0
 255: ST_TO_ADDR
// powellInTrouble := false ;
 256: LD_ADDR_EXP 8
 260: PUSH
 261: LD_INT 0
 263: ST_TO_ADDR
// sikorskiInTrouble := false ;
 264: LD_ADDR_EXP 9
 268: PUSH
 269: LD_INT 0
 271: ST_TO_ADDR
// end ;
 272: LD_VAR 0 1
 276: RET
// export function CustomInitMacro ; begin
 277: LD_INT 0
 279: PPUSH
// InitMC_Gensher ( ) ;
 280: CALL 3324 0 0
// InitMC_Powell ( ) ;
 284: CALL 815 0 0
// InitMC_Popov ( ) ;
 288: CALL 5935 0 0
// end ;
 292: LD_VAR 0 1
 296: RET
// every 0 0$10 do var cr , time , i ;
 297: GO 299
 299: DISABLE
 300: LD_INT 0
 302: PPUSH
 303: PPUSH
 304: PPUSH
// begin time := 0 0$20 ;
 305: LD_ADDR_VAR 0 2
 309: PUSH
 310: LD_INT 700
 312: ST_TO_ADDR
// repeat wait ( time ) ;
 313: LD_VAR 0 2
 317: PPUSH
 318: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
 322: LD_ADDR_VAR 0 1
 326: PUSH
 327: LD_INT 1
 329: PPUSH
 330: LD_INT 5
 332: PPUSH
 333: CALL_OW 12
 337: ST_TO_ADDR
// for i in [ powell_crates , gensher_crates , popov_crates , sikorski_crates ] do
 338: LD_ADDR_VAR 0 3
 342: PUSH
 343: LD_INT 5
 345: PUSH
 346: LD_INT 8
 348: PUSH
 349: LD_INT 12
 351: PUSH
 352: LD_INT 13
 354: PUSH
 355: EMPTY
 356: LIST
 357: LIST
 358: LIST
 359: LIST
 360: PUSH
 361: FOR_IN
 362: IFFALSE 416
// begin if GetResourceArea ( i , mat_cans ) < 40 then
 364: LD_VAR 0 3
 368: PPUSH
 369: LD_INT 1
 371: PPUSH
 372: CALL_OW 287
 376: PUSH
 377: LD_INT 40
 379: LESS
 380: IFFALSE 399
// CreateCratesArea ( cr , i , true ) ;
 382: LD_VAR 0 1
 386: PPUSH
 387: LD_VAR 0 3
 391: PPUSH
 392: LD_INT 1
 394: PPUSH
 395: CALL_OW 55
// wait ( rand ( 0 0$5 , 0 0$15 ) ) ;
 399: LD_INT 175
 401: PPUSH
 402: LD_INT 525
 404: PPUSH
 405: CALL_OW 12
 409: PPUSH
 410: CALL_OW 67
// end ;
 414: GO 361
 416: POP
 417: POP
// time := time + 0 0$2 ;
 418: LD_ADDR_VAR 0 2
 422: PUSH
 423: LD_VAR 0 2
 427: PUSH
 428: LD_INT 70
 430: PLUS
 431: ST_TO_ADDR
// if time > 0 0$35 then
 432: LD_VAR 0 2
 436: PUSH
 437: LD_INT 1225
 439: GREATER
 440: IFFALSE 450
// time := 0 0$25 ;
 442: LD_ADDR_VAR 0 2
 446: PUSH
 447: LD_INT 875
 449: ST_TO_ADDR
// until not game ;
 450: LD_EXP 2
 454: NOT
 455: IFFALSE 313
// end ;
 457: PPOPN 3
 459: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
 460: LD_INT 3
 462: PUSH
 463: LD_INT 22
 465: PUSH
 466: LD_INT 1
 468: PUSH
 469: EMPTY
 470: LIST
 471: LIST
 472: PUSH
 473: EMPTY
 474: LIST
 475: LIST
 476: PUSH
 477: LD_INT 32
 479: PUSH
 480: LD_INT 1
 482: PUSH
 483: EMPTY
 484: LIST
 485: LIST
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: PPUSH
 491: CALL_OW 69
 495: IFFALSE 590
 497: GO 499
 499: DISABLE
 500: LD_INT 0
 502: PPUSH
 503: PPUSH
// begin enable ;
 504: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
 505: LD_ADDR_VAR 0 2
 509: PUSH
 510: LD_INT 3
 512: PUSH
 513: LD_INT 22
 515: PUSH
 516: LD_INT 1
 518: PUSH
 519: EMPTY
 520: LIST
 521: LIST
 522: PUSH
 523: EMPTY
 524: LIST
 525: LIST
 526: PUSH
 527: LD_INT 32
 529: PUSH
 530: LD_INT 1
 532: PUSH
 533: EMPTY
 534: LIST
 535: LIST
 536: PUSH
 537: EMPTY
 538: LIST
 539: LIST
 540: PPUSH
 541: CALL_OW 69
 545: ST_TO_ADDR
// for i in tmp do
 546: LD_ADDR_VAR 0 1
 550: PUSH
 551: LD_VAR 0 2
 555: PUSH
 556: FOR_IN
 557: IFFALSE 588
// if GetFuel ( i ) < 5 then
 559: LD_VAR 0 1
 563: PPUSH
 564: CALL_OW 261
 568: PUSH
 569: LD_INT 5
 571: LESS
 572: IFFALSE 586
// SetFuel ( i , 5 ) ;
 574: LD_VAR 0 1
 578: PPUSH
 579: LD_INT 5
 581: PPUSH
 582: CALL_OW 240
 586: GO 556
 588: POP
 589: POP
// end ; end_of_file
 590: PPOPN 2
 592: END
// export Powell , powell_side , powellAttackGroup ; export function PreparePowell ; var i , tmp ; begin
 593: LD_INT 0
 595: PPUSH
 596: PPUSH
 597: PPUSH
// powell_side := 4 ;
 598: LD_ADDR_EXP 11
 602: PUSH
 603: LD_INT 4
 605: ST_TO_ADDR
// uc_side := powell_side ;
 606: LD_ADDR_OWVAR 20
 610: PUSH
 611: LD_EXP 11
 615: ST_TO_ADDR
// uc_nation := 1 ;
 616: LD_ADDR_OWVAR 21
 620: PUSH
 621: LD_INT 1
 623: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
 624: LD_ADDR_EXP 10
 628: PUSH
 629: LD_STRING Powell
 631: PPUSH
 632: CALL_OW 25
 636: ST_TO_ADDR
// SetSkill ( Powell , 1 , 7 ) ;
 637: LD_EXP 10
 641: PPUSH
 642: LD_INT 1
 644: PPUSH
 645: LD_INT 7
 647: PPUSH
 648: CALL_OW 237
// SetSkill ( Powell , 2 , 5 ) ;
 652: LD_EXP 10
 656: PPUSH
 657: LD_INT 2
 659: PPUSH
 660: LD_INT 5
 662: PPUSH
 663: CALL_OW 237
// SetSkill ( Powell , 3 , 6 ) ;
 667: LD_EXP 10
 671: PPUSH
 672: LD_INT 3
 674: PPUSH
 675: LD_INT 6
 677: PPUSH
 678: CALL_OW 237
// SetSkill ( Powell , 4 , 4 ) ;
 682: LD_EXP 10
 686: PPUSH
 687: LD_INT 4
 689: PPUSH
 690: LD_INT 4
 692: PPUSH
 693: CALL_OW 237
// PlaceHumanInUnit ( Powell , us_depot ) ;
 697: LD_EXP 10
 701: PPUSH
 702: LD_INT 4
 704: PPUSH
 705: CALL_OW 52
// tmp := PrepareBase ( us_depot , powell_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 5500 , 500 , 0 ] , [ 6 , 6 , 6 , 6 ] ) ;
 709: LD_ADDR_VAR 0 3
 713: PUSH
 714: LD_INT 4
 716: PPUSH
 717: LD_INT 1
 719: PPUSH
 720: LD_STRING 
 722: PPUSH
 723: LD_INT 8
 725: PUSH
 726: LD_INT 7
 728: PUSH
 729: LD_INT 6
 731: PUSH
 732: EMPTY
 733: LIST
 734: LIST
 735: LIST
 736: PUSH
 737: LD_OWVAR 67
 741: ARRAY
 742: PPUSH
 743: LD_INT 5500
 745: PUSH
 746: LD_INT 500
 748: PUSH
 749: LD_INT 0
 751: PUSH
 752: EMPTY
 753: LIST
 754: LIST
 755: LIST
 756: PPUSH
 757: LD_INT 6
 759: PUSH
 760: LD_INT 6
 762: PUSH
 763: LD_INT 6
 765: PUSH
 766: LD_INT 6
 768: PUSH
 769: EMPTY
 770: LIST
 771: LIST
 772: LIST
 773: LIST
 774: PPUSH
 775: CALL 18240 0 6
 779: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , tmp ) ;
 780: LD_ADDR_EXP 23
 784: PUSH
 785: LD_EXP 23
 789: PPUSH
 790: LD_INT 1
 792: PPUSH
 793: LD_VAR 0 3
 797: PPUSH
 798: CALL_OW 1
 802: ST_TO_ADDR
// powellAttackGroup := [ ] ;
 803: LD_ADDR_EXP 12
 807: PUSH
 808: EMPTY
 809: ST_TO_ADDR
// end ;
 810: LD_VAR 0 1
 814: RET
// export function InitMC_Powell ( ) ; begin
 815: LD_INT 0
 817: PPUSH
// MC_SetScanArea ( 1 , powell_base ) ;
 818: LD_INT 1
 820: PPUSH
 821: LD_INT 1
 823: PPUSH
 824: CALL 73801 0 2
// MC_SetParkingArea ( 1 , powell_parking ) ;
 828: LD_INT 1
 830: PPUSH
 831: LD_INT 6
 833: PPUSH
 834: CALL 73745 0 2
// MC_SetDepositsXY ( 1 , [ [ 167 , 102 , 0 ] , [ 173 , 83 , 1 ] , [ 171 , 141 , 0 ] , [ 178 , 148 , 1 ] ] ) ;
 838: LD_INT 1
 840: PPUSH
 841: LD_INT 167
 843: PUSH
 844: LD_INT 102
 846: PUSH
 847: LD_INT 0
 849: PUSH
 850: EMPTY
 851: LIST
 852: LIST
 853: LIST
 854: PUSH
 855: LD_INT 173
 857: PUSH
 858: LD_INT 83
 860: PUSH
 861: LD_INT 1
 863: PUSH
 864: EMPTY
 865: LIST
 866: LIST
 867: LIST
 868: PUSH
 869: LD_INT 171
 871: PUSH
 872: LD_INT 141
 874: PUSH
 875: LD_INT 0
 877: PUSH
 878: EMPTY
 879: LIST
 880: LIST
 881: LIST
 882: PUSH
 883: LD_INT 178
 885: PUSH
 886: LD_INT 148
 888: PUSH
 889: LD_INT 1
 891: PUSH
 892: EMPTY
 893: LIST
 894: LIST
 895: LIST
 896: PUSH
 897: EMPTY
 898: LIST
 899: LIST
 900: LIST
 901: LIST
 902: PPUSH
 903: CALL 72804 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ us_radar , us_heavy_gun , us_rocket_launcher ] ) ;
 907: LD_INT 1
 909: PPUSH
 910: LD_INT 11
 912: PUSH
 913: LD_INT 6
 915: PUSH
 916: LD_INT 7
 918: PUSH
 919: EMPTY
 920: LIST
 921: LIST
 922: LIST
 923: PPUSH
 924: CALL 73633 0 2
// MC_SetCratesArea ( 1 , powell_crates ) ;
 928: LD_INT 1
 930: PPUSH
 931: LD_INT 5
 933: PPUSH
 934: CALL 73315 0 2
// MC_SetTame ( 1 , powell_ape ) ;
 938: LD_INT 1
 940: PPUSH
 941: LD_INT 4
 943: PPUSH
 944: CALL 73046 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 948: LD_INT 1
 950: PPUSH
 951: LD_INT 4
 953: PPUSH
 954: CALL 72665 0 2
// MC_SetProduceList ( 1 , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ] ) ;
 958: LD_INT 1
 960: PPUSH
 961: LD_INT 3
 963: PUSH
 964: LD_INT 1
 966: PUSH
 967: LD_INT 2
 969: PUSH
 970: LD_INT 5
 972: PUSH
 973: EMPTY
 974: LIST
 975: LIST
 976: LIST
 977: LIST
 978: PUSH
 979: LD_INT 4
 981: PUSH
 982: LD_INT 1
 984: PUSH
 985: LD_INT 2
 987: PUSH
 988: LD_INT 6
 990: PUSH
 991: EMPTY
 992: LIST
 993: LIST
 994: LIST
 995: LIST
 996: PUSH
 997: LD_INT 4
 999: PUSH
1000: LD_INT 1
1002: PUSH
1003: LD_INT 2
1005: PUSH
1006: LD_INT 7
1008: PUSH
1009: EMPTY
1010: LIST
1011: LIST
1012: LIST
1013: LIST
1014: PUSH
1015: LD_INT 4
1017: PUSH
1018: LD_INT 1
1020: PUSH
1021: LD_INT 2
1023: PUSH
1024: LD_INT 6
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: LIST
1031: LIST
1032: PUSH
1033: EMPTY
1034: LIST
1035: LIST
1036: LIST
1037: LIST
1038: PPUSH
1039: CALL 72480 0 2
// MC_SetBuildingList ( 1 , [ [ b_oil_mine , 167 , 102 , 0 ] , [ b_armoury , 178 , 117 , 2 ] , [ b_lab , 200 , 111 , 4 ] , [ b_workshop , 201 , 140 , 4 ] , [ b_solar_power , 206 , 124 , 3 ] , [ b_solar_power , 209 , 128 , 3 ] , [ b_solar_power , 211 , 132 , 3 ] , [ b_siberite_mine , 173 , 83 , 3 ] , [ b_lab , 186 , 103 , 2 ] , [ b_turret , 173 , 99 , 2 ] , [ b_bunker , 174 , 102 , 2 ] , [ b_bunker , 178 , 100 , 2 ] , [ b_turret , 174 , 108 , 1 ] , [ b_turret , 182 , 122 , 1 ] , [ b_control_tower , 194 , 124 , 5 ] , [ b_turret , 184 , 141 , 1 ] , [ b_turret , 183 , 131 , 2 ] , [ b_turret , 194 , 146 , 4 ] , [ b_turret , 190 , 142 , 4 ] , [ b_siberite_power , 204 , 133 , 3 ] , [ b_solar_power , 201 , 133 , 3 ] , [ b_siberite_power , 199 , 119 , 5 ] ] ) ;
1043: LD_INT 1
1045: PPUSH
1046: LD_INT 29
1048: PUSH
1049: LD_INT 167
1051: PUSH
1052: LD_INT 102
1054: PUSH
1055: LD_INT 0
1057: PUSH
1058: EMPTY
1059: LIST
1060: LIST
1061: LIST
1062: LIST
1063: PUSH
1064: LD_INT 4
1066: PUSH
1067: LD_INT 178
1069: PUSH
1070: LD_INT 117
1072: PUSH
1073: LD_INT 2
1075: PUSH
1076: EMPTY
1077: LIST
1078: LIST
1079: LIST
1080: LIST
1081: PUSH
1082: LD_INT 6
1084: PUSH
1085: LD_INT 200
1087: PUSH
1088: LD_INT 111
1090: PUSH
1091: LD_INT 4
1093: PUSH
1094: EMPTY
1095: LIST
1096: LIST
1097: LIST
1098: LIST
1099: PUSH
1100: LD_INT 2
1102: PUSH
1103: LD_INT 201
1105: PUSH
1106: LD_INT 140
1108: PUSH
1109: LD_INT 4
1111: PUSH
1112: EMPTY
1113: LIST
1114: LIST
1115: LIST
1116: LIST
1117: PUSH
1118: LD_INT 27
1120: PUSH
1121: LD_INT 206
1123: PUSH
1124: LD_INT 124
1126: PUSH
1127: LD_INT 3
1129: PUSH
1130: EMPTY
1131: LIST
1132: LIST
1133: LIST
1134: LIST
1135: PUSH
1136: LD_INT 27
1138: PUSH
1139: LD_INT 209
1141: PUSH
1142: LD_INT 128
1144: PUSH
1145: LD_INT 3
1147: PUSH
1148: EMPTY
1149: LIST
1150: LIST
1151: LIST
1152: LIST
1153: PUSH
1154: LD_INT 27
1156: PUSH
1157: LD_INT 211
1159: PUSH
1160: LD_INT 132
1162: PUSH
1163: LD_INT 3
1165: PUSH
1166: EMPTY
1167: LIST
1168: LIST
1169: LIST
1170: LIST
1171: PUSH
1172: LD_INT 30
1174: PUSH
1175: LD_INT 173
1177: PUSH
1178: LD_INT 83
1180: PUSH
1181: LD_INT 3
1183: PUSH
1184: EMPTY
1185: LIST
1186: LIST
1187: LIST
1188: LIST
1189: PUSH
1190: LD_INT 6
1192: PUSH
1193: LD_INT 186
1195: PUSH
1196: LD_INT 103
1198: PUSH
1199: LD_INT 2
1201: PUSH
1202: EMPTY
1203: LIST
1204: LIST
1205: LIST
1206: LIST
1207: PUSH
1208: LD_INT 33
1210: PUSH
1211: LD_INT 173
1213: PUSH
1214: LD_INT 99
1216: PUSH
1217: LD_INT 2
1219: PUSH
1220: EMPTY
1221: LIST
1222: LIST
1223: LIST
1224: LIST
1225: PUSH
1226: LD_INT 32
1228: PUSH
1229: LD_INT 174
1231: PUSH
1232: LD_INT 102
1234: PUSH
1235: LD_INT 2
1237: PUSH
1238: EMPTY
1239: LIST
1240: LIST
1241: LIST
1242: LIST
1243: PUSH
1244: LD_INT 32
1246: PUSH
1247: LD_INT 178
1249: PUSH
1250: LD_INT 100
1252: PUSH
1253: LD_INT 2
1255: PUSH
1256: EMPTY
1257: LIST
1258: LIST
1259: LIST
1260: LIST
1261: PUSH
1262: LD_INT 33
1264: PUSH
1265: LD_INT 174
1267: PUSH
1268: LD_INT 108
1270: PUSH
1271: LD_INT 1
1273: PUSH
1274: EMPTY
1275: LIST
1276: LIST
1277: LIST
1278: LIST
1279: PUSH
1280: LD_INT 33
1282: PUSH
1283: LD_INT 182
1285: PUSH
1286: LD_INT 122
1288: PUSH
1289: LD_INT 1
1291: PUSH
1292: EMPTY
1293: LIST
1294: LIST
1295: LIST
1296: LIST
1297: PUSH
1298: LD_INT 36
1300: PUSH
1301: LD_INT 194
1303: PUSH
1304: LD_INT 124
1306: PUSH
1307: LD_INT 5
1309: PUSH
1310: EMPTY
1311: LIST
1312: LIST
1313: LIST
1314: LIST
1315: PUSH
1316: LD_INT 33
1318: PUSH
1319: LD_INT 184
1321: PUSH
1322: LD_INT 141
1324: PUSH
1325: LD_INT 1
1327: PUSH
1328: EMPTY
1329: LIST
1330: LIST
1331: LIST
1332: LIST
1333: PUSH
1334: LD_INT 33
1336: PUSH
1337: LD_INT 183
1339: PUSH
1340: LD_INT 131
1342: PUSH
1343: LD_INT 2
1345: PUSH
1346: EMPTY
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: PUSH
1352: LD_INT 33
1354: PUSH
1355: LD_INT 194
1357: PUSH
1358: LD_INT 146
1360: PUSH
1361: LD_INT 4
1363: PUSH
1364: EMPTY
1365: LIST
1366: LIST
1367: LIST
1368: LIST
1369: PUSH
1370: LD_INT 33
1372: PUSH
1373: LD_INT 190
1375: PUSH
1376: LD_INT 142
1378: PUSH
1379: LD_INT 4
1381: PUSH
1382: EMPTY
1383: LIST
1384: LIST
1385: LIST
1386: LIST
1387: PUSH
1388: LD_INT 28
1390: PUSH
1391: LD_INT 204
1393: PUSH
1394: LD_INT 133
1396: PUSH
1397: LD_INT 3
1399: PUSH
1400: EMPTY
1401: LIST
1402: LIST
1403: LIST
1404: LIST
1405: PUSH
1406: LD_INT 27
1408: PUSH
1409: LD_INT 201
1411: PUSH
1412: LD_INT 133
1414: PUSH
1415: LD_INT 3
1417: PUSH
1418: EMPTY
1419: LIST
1420: LIST
1421: LIST
1422: LIST
1423: PUSH
1424: LD_INT 28
1426: PUSH
1427: LD_INT 199
1429: PUSH
1430: LD_INT 119
1432: PUSH
1433: LD_INT 5
1435: PUSH
1436: EMPTY
1437: LIST
1438: LIST
1439: LIST
1440: LIST
1441: PUSH
1442: EMPTY
1443: LIST
1444: LIST
1445: LIST
1446: LIST
1447: LIST
1448: LIST
1449: LIST
1450: LIST
1451: LIST
1452: LIST
1453: LIST
1454: LIST
1455: LIST
1456: LIST
1457: LIST
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: LIST
1463: LIST
1464: LIST
1465: PPUSH
1466: CALL 72372 0 2
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_opto , b_lab_computer , b_lab_siberium ] ) ;
1470: LD_INT 1
1472: PPUSH
1473: LD_INT 10
1475: PUSH
1476: LD_INT 15
1478: PUSH
1479: LD_INT 12
1481: PUSH
1482: LD_INT 11
1484: PUSH
1485: EMPTY
1486: LIST
1487: LIST
1488: LIST
1489: LIST
1490: PPUSH
1491: CALL 73222 0 2
// MC_SetFactoryExtension ( 1 , 201 , 140 , 4 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1495: LD_INT 1
1497: PPUSH
1498: LD_INT 201
1500: PPUSH
1501: LD_INT 140
1503: PPUSH
1504: LD_INT 4
1506: PPUSH
1507: LD_INT 19
1509: PUSH
1510: LD_INT 16
1512: PUSH
1513: LD_INT 17
1515: PUSH
1516: LD_INT 18
1518: PUSH
1519: LD_INT 22
1521: PUSH
1522: EMPTY
1523: LIST
1524: LIST
1525: LIST
1526: LIST
1527: LIST
1528: PPUSH
1529: CALL 73427 0 5
// MC_SetUpgradeBuilding ( 1 , b_depot ) ;
1533: LD_INT 1
1535: PPUSH
1536: LD_INT 0
1538: PPUSH
1539: CALL 73095 0 2
// end ;
1543: LD_VAR 0 1
1547: RET
// every 8 8$00 + 2 2$00 trigger IsOk ( us_depot ) do var i , base , tmp , attackers , amount ;
1548: LD_INT 4
1550: PPUSH
1551: CALL_OW 302
1555: IFFALSE 2215
1557: GO 1559
1559: DISABLE
1560: LD_INT 0
1562: PPUSH
1563: PPUSH
1564: PPUSH
1565: PPUSH
1566: PPUSH
// begin enable ;
1567: ENABLE
// base := 1 ;
1568: LD_ADDR_VAR 0 2
1572: PUSH
1573: LD_INT 1
1575: ST_TO_ADDR
// tmp := [ [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ] ;
1576: LD_ADDR_VAR 0 3
1580: PUSH
1581: LD_INT 4
1583: PUSH
1584: LD_INT 1
1586: PUSH
1587: LD_INT 2
1589: PUSH
1590: LD_INT 6
1592: PUSH
1593: EMPTY
1594: LIST
1595: LIST
1596: LIST
1597: LIST
1598: PUSH
1599: LD_INT 4
1601: PUSH
1602: LD_INT 1
1604: PUSH
1605: LD_INT 2
1607: PUSH
1608: LD_INT 6
1610: PUSH
1611: EMPTY
1612: LIST
1613: LIST
1614: LIST
1615: LIST
1616: PUSH
1617: LD_INT 3
1619: PUSH
1620: LD_INT 1
1622: PUSH
1623: LD_INT 2
1625: PUSH
1626: LD_INT 7
1628: PUSH
1629: EMPTY
1630: LIST
1631: LIST
1632: LIST
1633: LIST
1634: PUSH
1635: LD_INT 3
1637: PUSH
1638: LD_INT 1
1640: PUSH
1641: LD_INT 2
1643: PUSH
1644: LD_INT 7
1646: PUSH
1647: EMPTY
1648: LIST
1649: LIST
1650: LIST
1651: LIST
1652: PUSH
1653: EMPTY
1654: LIST
1655: LIST
1656: LIST
1657: LIST
1658: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
1659: LD_ADDR_VAR 0 5
1663: PUSH
1664: LD_VAR 0 5
1668: PUSH
1669: LD_OWVAR 1
1673: PUSH
1674: LD_INT 21000
1676: DIV
1677: PLUS
1678: ST_TO_ADDR
// if amount > 8 then
1679: LD_VAR 0 5
1683: PUSH
1684: LD_INT 8
1686: GREATER
1687: IFFALSE 1697
// amount := 8 ;
1689: LD_ADDR_VAR 0 5
1693: PUSH
1694: LD_INT 8
1696: ST_TO_ADDR
// for i = 1 to amount do
1697: LD_ADDR_VAR 0 1
1701: PUSH
1702: DOUBLE
1703: LD_INT 1
1705: DEC
1706: ST_TO_ADDR
1707: LD_VAR 0 5
1711: PUSH
1712: FOR_TO
1713: IFFALSE 1797
// tmp := Insert ( tmp , tmp + 1 , [ [ us_medium_tracked , us_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ us_rocket_launcher , us_double_gun ] [ rand ( 1 , 2 ) ] ] ) ;
1715: LD_ADDR_VAR 0 3
1719: PUSH
1720: LD_VAR 0 3
1724: PPUSH
1725: LD_VAR 0 3
1729: PUSH
1730: LD_INT 1
1732: PLUS
1733: PPUSH
1734: LD_INT 3
1736: PUSH
1737: LD_INT 4
1739: PUSH
1740: EMPTY
1741: LIST
1742: LIST
1743: PUSH
1744: LD_INT 1
1746: PPUSH
1747: LD_INT 2
1749: PPUSH
1750: CALL_OW 12
1754: ARRAY
1755: PUSH
1756: LD_INT 1
1758: PUSH
1759: LD_INT 2
1761: PUSH
1762: LD_INT 7
1764: PUSH
1765: LD_INT 5
1767: PUSH
1768: EMPTY
1769: LIST
1770: LIST
1771: PUSH
1772: LD_INT 1
1774: PPUSH
1775: LD_INT 2
1777: PPUSH
1778: CALL_OW 12
1782: ARRAY
1783: PUSH
1784: EMPTY
1785: LIST
1786: LIST
1787: LIST
1788: LIST
1789: PPUSH
1790: CALL_OW 2
1794: ST_TO_ADDR
1795: GO 1712
1797: POP
1798: POP
// MC_InsertProduceList ( base , tmp ) ;
1799: LD_VAR 0 2
1803: PPUSH
1804: LD_VAR 0 3
1808: PPUSH
1809: CALL 72528 0 2
// repeat wait ( 0 0$1 ) ;
1813: LD_INT 35
1815: PPUSH
1816: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
1820: LD_VAR 0 2
1824: PPUSH
1825: LD_INT 1
1827: PPUSH
1828: CALL 73946 0 2
1832: PUSH
1833: LD_VAR 0 5
1837: GREATEREQUAL
1838: IFFALSE 1813
// wait ( 0 0$30 ) ;
1840: LD_INT 1050
1842: PPUSH
1843: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , us_bulldozer ] ] ) ;
1847: LD_ADDR_VAR 0 4
1851: PUSH
1852: LD_EXP 42
1856: PUSH
1857: LD_VAR 0 2
1861: ARRAY
1862: PUSH
1863: LD_EXP 42
1867: PUSH
1868: LD_VAR 0 2
1872: ARRAY
1873: PPUSH
1874: LD_INT 2
1876: PUSH
1877: LD_INT 34
1879: PUSH
1880: LD_INT 12
1882: PUSH
1883: EMPTY
1884: LIST
1885: LIST
1886: PUSH
1887: LD_INT 34
1889: PUSH
1890: LD_INT 13
1892: PUSH
1893: EMPTY
1894: LIST
1895: LIST
1896: PUSH
1897: LD_INT 34
1899: PUSH
1900: LD_INT 14
1902: PUSH
1903: EMPTY
1904: LIST
1905: LIST
1906: PUSH
1907: EMPTY
1908: LIST
1909: LIST
1910: LIST
1911: LIST
1912: PPUSH
1913: CALL_OW 72
1917: DIFF
1918: ST_TO_ADDR
// if not attackers then
1919: LD_VAR 0 4
1923: NOT
1924: IFFALSE 1928
// exit ;
1926: GO 2215
// DialogPowellsAttack ;
1928: CALL 8522 0 0
// powellAttackGroup := attackers ;
1932: LD_ADDR_EXP 12
1936: PUSH
1937: LD_VAR 0 4
1941: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
1942: LD_ADDR_EXP 42
1946: PUSH
1947: LD_EXP 42
1951: PPUSH
1952: LD_VAR 0 2
1956: PPUSH
1957: LD_EXP 42
1961: PUSH
1962: LD_VAR 0 2
1966: ARRAY
1967: PUSH
1968: LD_VAR 0 4
1972: DIFF
1973: PPUSH
1974: CALL_OW 1
1978: ST_TO_ADDR
// if sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 4 ] ) then
1979: LD_EXP 9
1983: PUSH
1984: LD_INT 16
1986: PPUSH
1987: LD_INT 81
1989: PUSH
1990: LD_INT 4
1992: PUSH
1993: EMPTY
1994: LIST
1995: LIST
1996: PPUSH
1997: CALL_OW 70
2001: AND
2002: IFFALSE 2021
// ComAgressiveMove ( attackers , 135 , 21 ) else
2004: LD_VAR 0 4
2008: PPUSH
2009: LD_INT 135
2011: PPUSH
2012: LD_INT 21
2014: PPUSH
2015: CALL_OW 114
2019: GO 2036
// ComAgressiveMove ( attackers , 146 , 103 ) ;
2021: LD_VAR 0 4
2025: PPUSH
2026: LD_INT 146
2028: PPUSH
2029: LD_INT 103
2031: PPUSH
2032: CALL_OW 114
// wait ( 0 0$5 ) ;
2036: LD_INT 175
2038: PPUSH
2039: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
2043: LD_INT 35
2045: PPUSH
2046: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
2050: LD_VAR 0 4
2054: PPUSH
2055: LD_INT 60
2057: PUSH
2058: EMPTY
2059: LIST
2060: PPUSH
2061: CALL_OW 72
2065: NOT
2066: IFFALSE 2043
// if FilterAllUnits ( [ f_side , 3 ] ) then
2068: LD_INT 22
2070: PUSH
2071: LD_INT 3
2073: PUSH
2074: EMPTY
2075: LIST
2076: LIST
2077: PPUSH
2078: CALL_OW 69
2082: IFFALSE 2101
// ComAgressiveMove ( attackers , 102 , 116 ) else
2084: LD_VAR 0 4
2088: PPUSH
2089: LD_INT 102
2091: PPUSH
2092: LD_INT 116
2094: PPUSH
2095: CALL_OW 114
2099: GO 2116
// ComAgressiveMove ( attackers , 66 , 41 ) ;
2101: LD_VAR 0 4
2105: PPUSH
2106: LD_INT 66
2108: PPUSH
2109: LD_INT 41
2111: PPUSH
2112: CALL_OW 114
// wait ( 0 0$10 ) ;
2116: LD_INT 350
2118: PPUSH
2119: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
2123: LD_INT 35
2125: PPUSH
2126: CALL_OW 67
// for i in attackers do
2130: LD_ADDR_VAR 0 1
2134: PUSH
2135: LD_VAR 0 4
2139: PUSH
2140: FOR_IN
2141: IFFALSE 2191
// if not HasTask ( i ) then
2143: LD_VAR 0 1
2147: PPUSH
2148: CALL_OW 314
2152: NOT
2153: IFFALSE 2189
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) ;
2155: LD_VAR 0 1
2159: PPUSH
2160: LD_INT 81
2162: PUSH
2163: LD_INT 4
2165: PUSH
2166: EMPTY
2167: LIST
2168: LIST
2169: PPUSH
2170: CALL_OW 69
2174: PPUSH
2175: LD_VAR 0 1
2179: PPUSH
2180: CALL_OW 74
2184: PPUSH
2185: CALL_OW 115
2189: GO 2140
2191: POP
2192: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
2193: LD_VAR 0 4
2197: PPUSH
2198: LD_INT 50
2200: PUSH
2201: EMPTY
2202: LIST
2203: PPUSH
2204: CALL_OW 72
2208: NOT
2209: IFFALSE 2123
// DialogPowellsAttackFailed ;
2211: CALL 8787 0 0
// end ;
2215: PPOPN 5
2217: END
// every 0 0$2 do var vehicles , mechs , i ;
2218: GO 2220
2220: DISABLE
2221: LD_INT 0
2223: PPUSH
2224: PPUSH
2225: PPUSH
// begin enable ;
2226: ENABLE
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] , [ f_distxy , 191 , 140 , 10 ] ] ) ;
2227: LD_ADDR_VAR 0 1
2231: PUSH
2232: LD_INT 22
2234: PUSH
2235: LD_INT 1
2237: PUSH
2238: EMPTY
2239: LIST
2240: LIST
2241: PUSH
2242: LD_INT 21
2244: PUSH
2245: LD_INT 2
2247: PUSH
2248: EMPTY
2249: LIST
2250: LIST
2251: PUSH
2252: LD_INT 3
2254: PUSH
2255: LD_INT 24
2257: PUSH
2258: LD_INT 1000
2260: PUSH
2261: EMPTY
2262: LIST
2263: LIST
2264: PUSH
2265: EMPTY
2266: LIST
2267: LIST
2268: PUSH
2269: LD_INT 92
2271: PUSH
2272: LD_INT 191
2274: PUSH
2275: LD_INT 140
2277: PUSH
2278: LD_INT 10
2280: PUSH
2281: EMPTY
2282: LIST
2283: LIST
2284: LIST
2285: LIST
2286: PUSH
2287: EMPTY
2288: LIST
2289: LIST
2290: LIST
2291: LIST
2292: PPUSH
2293: CALL_OW 69
2297: ST_TO_ADDR
// mechs := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 3 ] ] ) ;
2298: LD_ADDR_VAR 0 2
2302: PUSH
2303: LD_INT 22
2305: PUSH
2306: LD_INT 4
2308: PUSH
2309: EMPTY
2310: LIST
2311: LIST
2312: PUSH
2313: LD_INT 25
2315: PUSH
2316: LD_INT 3
2318: PUSH
2319: EMPTY
2320: LIST
2321: LIST
2322: PUSH
2323: EMPTY
2324: LIST
2325: LIST
2326: PPUSH
2327: CALL_OW 69
2331: ST_TO_ADDR
// if not mechs then
2332: LD_VAR 0 2
2336: NOT
2337: IFFALSE 2341
// exit ;
2339: GO 2515
// if mc_remote_driver [ 1 ] then
2341: LD_EXP 63
2345: PUSH
2346: LD_INT 1
2348: ARRAY
2349: IFFALSE 2371
// mechs := mechs diff mc_remote_driver [ 1 ] ;
2351: LD_ADDR_VAR 0 2
2355: PUSH
2356: LD_VAR 0 2
2360: PUSH
2361: LD_EXP 63
2365: PUSH
2366: LD_INT 1
2368: ARRAY
2369: DIFF
2370: ST_TO_ADDR
// if not mechs then
2371: LD_VAR 0 2
2375: NOT
2376: IFFALSE 2380
// exit ;
2378: GO 2515
// if vehicles then
2380: LD_VAR 0 1
2384: IFFALSE 2472
// begin for i in mechs do
2386: LD_ADDR_VAR 0 3
2390: PUSH
2391: LD_VAR 0 2
2395: PUSH
2396: FOR_IN
2397: IFFALSE 2468
// begin if GetTag ( i ) <> 120 then
2399: LD_VAR 0 3
2403: PPUSH
2404: CALL_OW 110
2408: PUSH
2409: LD_INT 120
2411: NONEQUAL
2412: IFFALSE 2426
// SetTag ( i , 120 ) ;
2414: LD_VAR 0 3
2418: PPUSH
2419: LD_INT 120
2421: PPUSH
2422: CALL_OW 109
// if IsInUnit ( i ) then
2426: LD_VAR 0 3
2430: PPUSH
2431: CALL_OW 310
2435: IFFALSE 2448
// ComExitBuilding ( i ) else
2437: LD_VAR 0 3
2441: PPUSH
2442: CALL_OW 122
2446: GO 2466
// ComRepairVehicle ( i , vehicles [ 1 ] ) ;
2448: LD_VAR 0 3
2452: PPUSH
2453: LD_VAR 0 1
2457: PUSH
2458: LD_INT 1
2460: ARRAY
2461: PPUSH
2462: CALL_OW 129
// end ;
2466: GO 2396
2468: POP
2469: POP
// end else
2470: GO 2515
// if FilterByTag ( mechs , 120 ) then
2472: LD_VAR 0 2
2476: PPUSH
2477: LD_INT 120
2479: PPUSH
2480: CALL 44185 0 2
2484: IFFALSE 2515
// begin for i in mechs do
2486: LD_ADDR_VAR 0 3
2490: PUSH
2491: LD_VAR 0 2
2495: PUSH
2496: FOR_IN
2497: IFFALSE 2513
// begin SetTag ( i , 0 ) ;
2499: LD_VAR 0 3
2503: PPUSH
2504: LD_INT 0
2506: PPUSH
2507: CALL_OW 109
// end ;
2511: GO 2496
2513: POP
2514: POP
// end ; end ;
2515: PPOPN 3
2517: END
// every 0 0$2 do var people , sci , i ;
2518: GO 2520
2520: DISABLE
2521: LD_INT 0
2523: PPUSH
2524: PPUSH
2525: PPUSH
// begin enable ;
2526: ENABLE
// people := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] , [ f_distxy , 188 , 112 , 10 ] ] ) ;
2527: LD_ADDR_VAR 0 1
2531: PUSH
2532: LD_INT 22
2534: PUSH
2535: LD_INT 1
2537: PUSH
2538: EMPTY
2539: LIST
2540: LIST
2541: PUSH
2542: LD_INT 21
2544: PUSH
2545: LD_INT 1
2547: PUSH
2548: EMPTY
2549: LIST
2550: LIST
2551: PUSH
2552: LD_INT 3
2554: PUSH
2555: LD_INT 24
2557: PUSH
2558: LD_INT 1000
2560: PUSH
2561: EMPTY
2562: LIST
2563: LIST
2564: PUSH
2565: EMPTY
2566: LIST
2567: LIST
2568: PUSH
2569: LD_INT 92
2571: PUSH
2572: LD_INT 188
2574: PUSH
2575: LD_INT 112
2577: PUSH
2578: LD_INT 10
2580: PUSH
2581: EMPTY
2582: LIST
2583: LIST
2584: LIST
2585: LIST
2586: PUSH
2587: EMPTY
2588: LIST
2589: LIST
2590: LIST
2591: LIST
2592: PPUSH
2593: CALL_OW 69
2597: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 4 ] ] ) ;
2598: LD_ADDR_VAR 0 2
2602: PUSH
2603: LD_INT 22
2605: PUSH
2606: LD_INT 4
2608: PUSH
2609: EMPTY
2610: LIST
2611: LIST
2612: PUSH
2613: LD_INT 25
2615: PUSH
2616: LD_INT 4
2618: PUSH
2619: EMPTY
2620: LIST
2621: LIST
2622: PUSH
2623: EMPTY
2624: LIST
2625: LIST
2626: PPUSH
2627: CALL_OW 69
2631: ST_TO_ADDR
// if not sci then
2632: LD_VAR 0 2
2636: NOT
2637: IFFALSE 2641
// exit ;
2639: GO 2776
// if people then
2641: LD_VAR 0 1
2645: IFFALSE 2733
// begin for i in sci do
2647: LD_ADDR_VAR 0 3
2651: PUSH
2652: LD_VAR 0 2
2656: PUSH
2657: FOR_IN
2658: IFFALSE 2729
// begin if GetTag ( i ) <> 102 then
2660: LD_VAR 0 3
2664: PPUSH
2665: CALL_OW 110
2669: PUSH
2670: LD_INT 102
2672: NONEQUAL
2673: IFFALSE 2687
// SetTag ( i , 102 ) ;
2675: LD_VAR 0 3
2679: PPUSH
2680: LD_INT 102
2682: PPUSH
2683: CALL_OW 109
// if IsInUnit ( i ) then
2687: LD_VAR 0 3
2691: PPUSH
2692: CALL_OW 310
2696: IFFALSE 2709
// ComExitBuilding ( i ) else
2698: LD_VAR 0 3
2702: PPUSH
2703: CALL_OW 122
2707: GO 2727
// ComHeal ( i , people [ 1 ] ) ;
2709: LD_VAR 0 3
2713: PPUSH
2714: LD_VAR 0 1
2718: PUSH
2719: LD_INT 1
2721: ARRAY
2722: PPUSH
2723: CALL_OW 128
// end ;
2727: GO 2657
2729: POP
2730: POP
// end else
2731: GO 2776
// if FilterByTag ( sci , 102 ) then
2733: LD_VAR 0 2
2737: PPUSH
2738: LD_INT 102
2740: PPUSH
2741: CALL 44185 0 2
2745: IFFALSE 2776
// begin for i in sci do
2747: LD_ADDR_VAR 0 3
2751: PUSH
2752: LD_VAR 0 2
2756: PUSH
2757: FOR_IN
2758: IFFALSE 2774
// begin SetTag ( i , 0 ) ;
2760: LD_VAR 0 3
2764: PPUSH
2765: LD_INT 0
2767: PPUSH
2768: CALL_OW 109
// end ;
2772: GO 2757
2774: POP
2775: POP
// end ; end ; end_of_file
2776: PPOPN 3
2778: END
// export Gensher , gensher_side , gensherAttackGroup ; export function PrepareGensher ; var i , tmp , un ; begin
2779: LD_INT 0
2781: PPUSH
2782: PPUSH
2783: PPUSH
2784: PPUSH
// gensher_side := 2 ;
2785: LD_ADDR_EXP 14
2789: PUSH
2790: LD_INT 2
2792: ST_TO_ADDR
// uc_side := gensher_side ;
2793: LD_ADDR_OWVAR 20
2797: PUSH
2798: LD_EXP 14
2802: ST_TO_ADDR
// uc_nation := 2 ;
2803: LD_ADDR_OWVAR 21
2807: PUSH
2808: LD_INT 2
2810: ST_TO_ADDR
// tmp := PrepareBase ( ar_depot , gensher_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 11500 , 1100 , 60 ] , [ 6 , 6 , 6 , 6 ] ) ;
2811: LD_ADDR_VAR 0 3
2815: PUSH
2816: LD_INT 7
2818: PPUSH
2819: LD_INT 2
2821: PPUSH
2822: LD_STRING 
2824: PPUSH
2825: LD_INT 8
2827: PUSH
2828: LD_INT 7
2830: PUSH
2831: LD_INT 6
2833: PUSH
2834: EMPTY
2835: LIST
2836: LIST
2837: LIST
2838: PUSH
2839: LD_OWVAR 67
2843: ARRAY
2844: PPUSH
2845: LD_INT 11500
2847: PUSH
2848: LD_INT 1100
2850: PUSH
2851: LD_INT 60
2853: PUSH
2854: EMPTY
2855: LIST
2856: LIST
2857: LIST
2858: PPUSH
2859: LD_INT 6
2861: PUSH
2862: LD_INT 6
2864: PUSH
2865: LD_INT 6
2867: PUSH
2868: LD_INT 6
2870: PUSH
2871: EMPTY
2872: LIST
2873: LIST
2874: LIST
2875: LIST
2876: PPUSH
2877: CALL 18240 0 6
2881: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp ) ;
2882: LD_ADDR_EXP 23
2886: PUSH
2887: LD_EXP 23
2891: PPUSH
2892: LD_INT 2
2894: PPUSH
2895: LD_VAR 0 3
2899: PPUSH
2900: CALL_OW 1
2904: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] ] ) ;
2905: LD_ADDR_VAR 0 3
2909: PUSH
2910: LD_INT 22
2912: PUSH
2913: LD_INT 2
2915: PUSH
2916: EMPTY
2917: LIST
2918: LIST
2919: PUSH
2920: LD_INT 30
2922: PUSH
2923: LD_INT 31
2925: PUSH
2926: EMPTY
2927: LIST
2928: LIST
2929: PUSH
2930: EMPTY
2931: LIST
2932: LIST
2933: PPUSH
2934: CALL_OW 69
2938: ST_TO_ADDR
// for i in tmp do
2939: LD_ADDR_VAR 0 2
2943: PUSH
2944: LD_VAR 0 3
2948: PUSH
2949: FOR_IN
2950: IFFALSE 3020
// begin PrepareHuman ( false , 1 , [ 4 , 3 , 3 ] [ Difficulty ] ) ;
2952: LD_INT 0
2954: PPUSH
2955: LD_INT 1
2957: PPUSH
2958: LD_INT 4
2960: PUSH
2961: LD_INT 3
2963: PUSH
2964: LD_INT 3
2966: PUSH
2967: EMPTY
2968: LIST
2969: LIST
2970: LIST
2971: PUSH
2972: LD_OWVAR 67
2976: ARRAY
2977: PPUSH
2978: CALL_OW 380
// un := CreateHuman ;
2982: LD_ADDR_VAR 0 4
2986: PUSH
2987: CALL_OW 44
2991: ST_TO_ADDR
// SetDir ( un , 1 ) ;
2992: LD_VAR 0 4
2996: PPUSH
2997: LD_INT 1
2999: PPUSH
3000: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3004: LD_VAR 0 4
3008: PPUSH
3009: LD_VAR 0 2
3013: PPUSH
3014: CALL_OW 52
// end ;
3018: GO 2949
3020: POP
3021: POP
// tmp := AreaToList ( gensher_mines , 0 ) ;
3022: LD_ADDR_VAR 0 3
3026: PUSH
3027: LD_INT 15
3029: PPUSH
3030: LD_INT 0
3032: PPUSH
3033: CALL_OW 517
3037: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
3038: LD_ADDR_VAR 0 2
3042: PUSH
3043: DOUBLE
3044: LD_INT 1
3046: DEC
3047: ST_TO_ADDR
3048: LD_VAR 0 3
3052: PUSH
3053: LD_INT 1
3055: ARRAY
3056: PUSH
3057: FOR_TO
3058: IFFALSE 3160
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
3060: LD_VAR 0 3
3064: PUSH
3065: LD_INT 1
3067: ARRAY
3068: PUSH
3069: LD_VAR 0 2
3073: ARRAY
3074: PPUSH
3075: LD_VAR 0 3
3079: PUSH
3080: LD_INT 2
3082: ARRAY
3083: PUSH
3084: LD_VAR 0 2
3088: ARRAY
3089: PPUSH
3090: LD_INT 2
3092: PPUSH
3093: LD_INT 0
3095: PPUSH
3096: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
3100: LD_ADDR_EXP 3
3104: PUSH
3105: LD_EXP 3
3109: PPUSH
3110: LD_EXP 3
3114: PUSH
3115: LD_INT 1
3117: PLUS
3118: PPUSH
3119: LD_VAR 0 3
3123: PUSH
3124: LD_INT 1
3126: ARRAY
3127: PUSH
3128: LD_VAR 0 2
3132: ARRAY
3133: PUSH
3134: LD_VAR 0 3
3138: PUSH
3139: LD_INT 2
3141: ARRAY
3142: PUSH
3143: LD_VAR 0 2
3147: ARRAY
3148: PUSH
3149: EMPTY
3150: LIST
3151: LIST
3152: PPUSH
3153: CALL_OW 2
3157: ST_TO_ADDR
// end ;
3158: GO 3057
3160: POP
3161: POP
// if Difficulty > 1 then
3162: LD_OWVAR 67
3166: PUSH
3167: LD_INT 1
3169: GREATER
3170: IFFALSE 3312
// begin tmp := AreaToList ( gensher_mines2 , 0 ) ;
3172: LD_ADDR_VAR 0 3
3176: PUSH
3177: LD_INT 19
3179: PPUSH
3180: LD_INT 0
3182: PPUSH
3183: CALL_OW 517
3187: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
3188: LD_ADDR_VAR 0 2
3192: PUSH
3193: DOUBLE
3194: LD_INT 1
3196: DEC
3197: ST_TO_ADDR
3198: LD_VAR 0 3
3202: PUSH
3203: LD_INT 1
3205: ARRAY
3206: PUSH
3207: FOR_TO
3208: IFFALSE 3310
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
3210: LD_VAR 0 3
3214: PUSH
3215: LD_INT 1
3217: ARRAY
3218: PUSH
3219: LD_VAR 0 2
3223: ARRAY
3224: PPUSH
3225: LD_VAR 0 3
3229: PUSH
3230: LD_INT 2
3232: ARRAY
3233: PUSH
3234: LD_VAR 0 2
3238: ARRAY
3239: PPUSH
3240: LD_INT 2
3242: PPUSH
3243: LD_INT 0
3245: PPUSH
3246: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
3250: LD_ADDR_EXP 3
3254: PUSH
3255: LD_EXP 3
3259: PPUSH
3260: LD_EXP 3
3264: PUSH
3265: LD_INT 1
3267: PLUS
3268: PPUSH
3269: LD_VAR 0 3
3273: PUSH
3274: LD_INT 1
3276: ARRAY
3277: PUSH
3278: LD_VAR 0 2
3282: ARRAY
3283: PUSH
3284: LD_VAR 0 3
3288: PUSH
3289: LD_INT 2
3291: ARRAY
3292: PUSH
3293: LD_VAR 0 2
3297: ARRAY
3298: PUSH
3299: EMPTY
3300: LIST
3301: LIST
3302: PPUSH
3303: CALL_OW 2
3307: ST_TO_ADDR
// end ;
3308: GO 3207
3310: POP
3311: POP
// end ; gensherAttackGroup := [ ] ;
3312: LD_ADDR_EXP 15
3316: PUSH
3317: EMPTY
3318: ST_TO_ADDR
// end ;
3319: LD_VAR 0 1
3323: RET
// export function InitMC_Gensher ( ) ; begin
3324: LD_INT 0
3326: PPUSH
// MC_SetScanArea ( 2 , gensher_base ) ;
3327: LD_INT 2
3329: PPUSH
3330: LD_INT 2
3332: PPUSH
3333: CALL 73801 0 2
// MC_SetParkingArea ( 2 , gensher_parking ) ;
3337: LD_INT 2
3339: PPUSH
3340: LD_INT 9
3342: PPUSH
3343: CALL 73745 0 2
// MC_SetDepositsXY ( 2 , [ [ 56 , 23 , 0 ] , [ 52 , 40 , 1 ] ] ) ;
3347: LD_INT 2
3349: PPUSH
3350: LD_INT 56
3352: PUSH
3353: LD_INT 23
3355: PUSH
3356: LD_INT 0
3358: PUSH
3359: EMPTY
3360: LIST
3361: LIST
3362: LIST
3363: PUSH
3364: LD_INT 52
3366: PUSH
3367: LD_INT 40
3369: PUSH
3370: LD_INT 1
3372: PUSH
3373: EMPTY
3374: LIST
3375: LIST
3376: LIST
3377: PUSH
3378: EMPTY
3379: LIST
3380: LIST
3381: PPUSH
3382: CALL 72804 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ar_gun , ar_rocket_launcher ] ) ;
3386: LD_INT 2
3388: PPUSH
3389: LD_INT 27
3391: PUSH
3392: LD_INT 28
3394: PUSH
3395: EMPTY
3396: LIST
3397: LIST
3398: PPUSH
3399: CALL 73633 0 2
// MC_SetCratesArea ( 2 , gensher_crates ) ;
3403: LD_INT 2
3405: PPUSH
3406: LD_INT 8
3408: PPUSH
3409: CALL 73315 0 2
// MC_SetTame ( 2 , gensher_ape ) ;
3413: LD_INT 2
3415: PPUSH
3416: LD_INT 7
3418: PPUSH
3419: CALL 73046 0 2
// MC_SetDefenderLimit ( 2 , 4 ) ;
3423: LD_INT 2
3425: PPUSH
3426: LD_INT 4
3428: PPUSH
3429: CALL 72665 0 2
// MC_SetProduceList ( 2 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ) ;
3433: LD_INT 2
3435: PPUSH
3436: LD_INT 13
3438: PUSH
3439: LD_INT 2
3441: PUSH
3442: LD_INT 1
3444: PUSH
3445: LD_INT 31
3447: PUSH
3448: EMPTY
3449: LIST
3450: LIST
3451: LIST
3452: LIST
3453: PUSH
3454: LD_INT 13
3456: PUSH
3457: LD_INT 2
3459: PUSH
3460: LD_INT 1
3462: PUSH
3463: LD_INT 31
3465: PUSH
3466: EMPTY
3467: LIST
3468: LIST
3469: LIST
3470: LIST
3471: PUSH
3472: LD_INT 14
3474: PUSH
3475: LD_INT 1
3477: PUSH
3478: LD_INT 2
3480: PUSH
3481: LD_INT 27
3483: PUSH
3484: EMPTY
3485: LIST
3486: LIST
3487: LIST
3488: LIST
3489: PUSH
3490: LD_INT 14
3492: PUSH
3493: LD_INT 1
3495: PUSH
3496: LD_INT 2
3498: PUSH
3499: LD_INT 27
3501: PUSH
3502: EMPTY
3503: LIST
3504: LIST
3505: LIST
3506: LIST
3507: PUSH
3508: LD_INT 14
3510: PUSH
3511: LD_INT 1
3513: PUSH
3514: LD_INT 2
3516: PUSH
3517: LD_INT 28
3519: PUSH
3520: EMPTY
3521: LIST
3522: LIST
3523: LIST
3524: LIST
3525: PUSH
3526: LD_INT 14
3528: PUSH
3529: LD_INT 1
3531: PUSH
3532: LD_INT 2
3534: PUSH
3535: LD_INT 26
3537: PUSH
3538: EMPTY
3539: LIST
3540: LIST
3541: LIST
3542: LIST
3543: PUSH
3544: EMPTY
3545: LIST
3546: LIST
3547: LIST
3548: LIST
3549: LIST
3550: LIST
3551: PPUSH
3552: CALL 72480 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 13 , 18 , 1 ] , [ b_solar_power , 17 , 3 , 0 ] , [ b_oil_mine , 56 , 23 , 0 ] , [ b_armoury , 42 , 29 , 5 ] , [ b_workshop , 11 , 7 , 2 ] , [ b_solar_power , 20 , 3 , 0 ] , [ b_solar_power , 23 , 3 , 0 ] , [ b_solar_power , 26 , 3 , 0 ] , [ b_lab , 17 , 27 , 1 ] , [ b_bunker , 27 , 44 , 5 ] , [ b_bunker , 41 , 41 , 5 ] , [ b_bunker , 45 , 24 , 5 ] , [ b_bunker , 48 , 19 , 5 ] , [ b_bunker , 41 , 3 , 4 ] , [ b_armoury , 44 , 9 , 4 ] , [ b_siberite_mine , 52 , 40 , 3 ] ] ) ;
3556: LD_INT 2
3558: PPUSH
3559: LD_INT 6
3561: PUSH
3562: LD_INT 13
3564: PUSH
3565: LD_INT 18
3567: PUSH
3568: LD_INT 1
3570: PUSH
3571: EMPTY
3572: LIST
3573: LIST
3574: LIST
3575: LIST
3576: PUSH
3577: LD_INT 27
3579: PUSH
3580: LD_INT 17
3582: PUSH
3583: LD_INT 3
3585: PUSH
3586: LD_INT 0
3588: PUSH
3589: EMPTY
3590: LIST
3591: LIST
3592: LIST
3593: LIST
3594: PUSH
3595: LD_INT 29
3597: PUSH
3598: LD_INT 56
3600: PUSH
3601: LD_INT 23
3603: PUSH
3604: LD_INT 0
3606: PUSH
3607: EMPTY
3608: LIST
3609: LIST
3610: LIST
3611: LIST
3612: PUSH
3613: LD_INT 4
3615: PUSH
3616: LD_INT 42
3618: PUSH
3619: LD_INT 29
3621: PUSH
3622: LD_INT 5
3624: PUSH
3625: EMPTY
3626: LIST
3627: LIST
3628: LIST
3629: LIST
3630: PUSH
3631: LD_INT 2
3633: PUSH
3634: LD_INT 11
3636: PUSH
3637: LD_INT 7
3639: PUSH
3640: LD_INT 2
3642: PUSH
3643: EMPTY
3644: LIST
3645: LIST
3646: LIST
3647: LIST
3648: PUSH
3649: LD_INT 27
3651: PUSH
3652: LD_INT 20
3654: PUSH
3655: LD_INT 3
3657: PUSH
3658: LD_INT 0
3660: PUSH
3661: EMPTY
3662: LIST
3663: LIST
3664: LIST
3665: LIST
3666: PUSH
3667: LD_INT 27
3669: PUSH
3670: LD_INT 23
3672: PUSH
3673: LD_INT 3
3675: PUSH
3676: LD_INT 0
3678: PUSH
3679: EMPTY
3680: LIST
3681: LIST
3682: LIST
3683: LIST
3684: PUSH
3685: LD_INT 27
3687: PUSH
3688: LD_INT 26
3690: PUSH
3691: LD_INT 3
3693: PUSH
3694: LD_INT 0
3696: PUSH
3697: EMPTY
3698: LIST
3699: LIST
3700: LIST
3701: LIST
3702: PUSH
3703: LD_INT 6
3705: PUSH
3706: LD_INT 17
3708: PUSH
3709: LD_INT 27
3711: PUSH
3712: LD_INT 1
3714: PUSH
3715: EMPTY
3716: LIST
3717: LIST
3718: LIST
3719: LIST
3720: PUSH
3721: LD_INT 32
3723: PUSH
3724: LD_INT 27
3726: PUSH
3727: LD_INT 44
3729: PUSH
3730: LD_INT 5
3732: PUSH
3733: EMPTY
3734: LIST
3735: LIST
3736: LIST
3737: LIST
3738: PUSH
3739: LD_INT 32
3741: PUSH
3742: LD_INT 41
3744: PUSH
3745: LD_INT 41
3747: PUSH
3748: LD_INT 5
3750: PUSH
3751: EMPTY
3752: LIST
3753: LIST
3754: LIST
3755: LIST
3756: PUSH
3757: LD_INT 32
3759: PUSH
3760: LD_INT 45
3762: PUSH
3763: LD_INT 24
3765: PUSH
3766: LD_INT 5
3768: PUSH
3769: EMPTY
3770: LIST
3771: LIST
3772: LIST
3773: LIST
3774: PUSH
3775: LD_INT 32
3777: PUSH
3778: LD_INT 48
3780: PUSH
3781: LD_INT 19
3783: PUSH
3784: LD_INT 5
3786: PUSH
3787: EMPTY
3788: LIST
3789: LIST
3790: LIST
3791: LIST
3792: PUSH
3793: LD_INT 32
3795: PUSH
3796: LD_INT 41
3798: PUSH
3799: LD_INT 3
3801: PUSH
3802: LD_INT 4
3804: PUSH
3805: EMPTY
3806: LIST
3807: LIST
3808: LIST
3809: LIST
3810: PUSH
3811: LD_INT 4
3813: PUSH
3814: LD_INT 44
3816: PUSH
3817: LD_INT 9
3819: PUSH
3820: LD_INT 4
3822: PUSH
3823: EMPTY
3824: LIST
3825: LIST
3826: LIST
3827: LIST
3828: PUSH
3829: LD_INT 30
3831: PUSH
3832: LD_INT 52
3834: PUSH
3835: LD_INT 40
3837: PUSH
3838: LD_INT 3
3840: PUSH
3841: EMPTY
3842: LIST
3843: LIST
3844: LIST
3845: LIST
3846: PUSH
3847: EMPTY
3848: LIST
3849: LIST
3850: LIST
3851: LIST
3852: LIST
3853: LIST
3854: LIST
3855: LIST
3856: LIST
3857: LIST
3858: LIST
3859: LIST
3860: LIST
3861: LIST
3862: LIST
3863: LIST
3864: PPUSH
3865: CALL 72372 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_opto , b_lab_biological , b_lab_siberium ] ) ;
3869: LD_INT 2
3871: PPUSH
3872: LD_INT 10
3874: PUSH
3875: LD_INT 15
3877: PUSH
3878: LD_INT 13
3880: PUSH
3881: LD_INT 11
3883: PUSH
3884: EMPTY
3885: LIST
3886: LIST
3887: LIST
3888: LIST
3889: PPUSH
3890: CALL 73222 0 2
// MC_SetFactoryExtension ( 2 , 11 , 7 , 2 , [ b_ext_stitch , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
3894: LD_INT 2
3896: PPUSH
3897: LD_INT 11
3899: PPUSH
3900: LD_INT 7
3902: PPUSH
3903: LD_INT 2
3905: PPUSH
3906: LD_INT 23
3908: PUSH
3909: LD_INT 16
3911: PUSH
3912: LD_INT 17
3914: PUSH
3915: LD_INT 18
3917: PUSH
3918: LD_INT 22
3920: PUSH
3921: EMPTY
3922: LIST
3923: LIST
3924: LIST
3925: LIST
3926: LIST
3927: PPUSH
3928: CALL 73427 0 5
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
3932: LD_INT 2
3934: PPUSH
3935: LD_INT 0
3937: PPUSH
3938: CALL 73095 0 2
// end ;
3942: LD_VAR 0 1
3946: RET
// every 3 trigger staticMines and FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) do var i , j , tmp , x , y ;
3947: LD_EXP 3
3951: PUSH
3952: LD_INT 15
3954: PPUSH
3955: LD_INT 81
3957: PUSH
3958: LD_INT 2
3960: PUSH
3961: EMPTY
3962: LIST
3963: LIST
3964: PPUSH
3965: CALL_OW 70
3969: AND
3970: IFFALSE 4183
3972: GO 3974
3974: DISABLE
3975: LD_INT 0
3977: PPUSH
3978: PPUSH
3979: PPUSH
3980: PPUSH
3981: PPUSH
// begin enable ;
3982: ENABLE
// tmp := FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) ;
3983: LD_ADDR_VAR 0 3
3987: PUSH
3988: LD_INT 15
3990: PPUSH
3991: LD_INT 81
3993: PUSH
3994: LD_INT 2
3996: PUSH
3997: EMPTY
3998: LIST
3999: LIST
4000: PPUSH
4001: CALL_OW 70
4005: ST_TO_ADDR
// if not tmp then
4006: LD_VAR 0 3
4010: NOT
4011: IFFALSE 4015
// exit ;
4013: GO 4183
// for i in tmp do
4015: LD_ADDR_VAR 0 1
4019: PUSH
4020: LD_VAR 0 3
4024: PUSH
4025: FOR_IN
4026: IFFALSE 4181
// begin x := GetX ( i ) ;
4028: LD_ADDR_VAR 0 4
4032: PUSH
4033: LD_VAR 0 1
4037: PPUSH
4038: CALL_OW 250
4042: ST_TO_ADDR
// y := GetY ( i ) ;
4043: LD_ADDR_VAR 0 5
4047: PUSH
4048: LD_VAR 0 1
4052: PPUSH
4053: CALL_OW 251
4057: ST_TO_ADDR
// if MineAtPos ( x , y ) then
4058: LD_VAR 0 4
4062: PPUSH
4063: LD_VAR 0 5
4067: PPUSH
4068: CALL_OW 458
4072: IFFALSE 4179
// begin LaunchMineAtPos ( x , y , 2 ) ;
4074: LD_VAR 0 4
4078: PPUSH
4079: LD_VAR 0 5
4083: PPUSH
4084: LD_INT 2
4086: PPUSH
4087: CALL_OW 456
// for j = 1 to staticMines do
4091: LD_ADDR_VAR 0 2
4095: PUSH
4096: DOUBLE
4097: LD_INT 1
4099: DEC
4100: ST_TO_ADDR
4101: LD_EXP 3
4105: PUSH
4106: FOR_TO
4107: IFFALSE 4177
// if staticMines [ j ] [ 1 ] = x and staticMines [ j ] [ 2 ] = y then
4109: LD_EXP 3
4113: PUSH
4114: LD_VAR 0 2
4118: ARRAY
4119: PUSH
4120: LD_INT 1
4122: ARRAY
4123: PUSH
4124: LD_VAR 0 4
4128: EQUAL
4129: PUSH
4130: LD_EXP 3
4134: PUSH
4135: LD_VAR 0 2
4139: ARRAY
4140: PUSH
4141: LD_INT 2
4143: ARRAY
4144: PUSH
4145: LD_VAR 0 5
4149: EQUAL
4150: AND
4151: IFFALSE 4175
// begin staticMines := Delete ( staticMines , j ) ;
4153: LD_ADDR_EXP 3
4157: PUSH
4158: LD_EXP 3
4162: PPUSH
4163: LD_VAR 0 2
4167: PPUSH
4168: CALL_OW 3
4172: ST_TO_ADDR
// break ;
4173: GO 4177
// end ;
4175: GO 4106
4177: POP
4178: POP
// end ; end ;
4179: GO 4025
4181: POP
4182: POP
// end ;
4183: PPOPN 5
4185: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ar_depot ) and not arDestroyed do var i , base , tmp , attackers , amount ;
4186: LD_INT 7
4188: PPUSH
4189: CALL_OW 302
4193: PUSH
4194: LD_EXP 4
4198: NOT
4199: AND
4200: IFFALSE 4804
4202: GO 4204
4204: DISABLE
4205: LD_INT 0
4207: PPUSH
4208: PPUSH
4209: PPUSH
4210: PPUSH
4211: PPUSH
// begin enable ;
4212: ENABLE
// base := 2 ;
4213: LD_ADDR_VAR 0 2
4217: PUSH
4218: LD_INT 2
4220: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_mortar ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ;
4221: LD_ADDR_VAR 0 3
4225: PUSH
4226: LD_INT 14
4228: PUSH
4229: LD_INT 1
4231: PUSH
4232: LD_INT 2
4234: PUSH
4235: LD_INT 27
4237: PUSH
4238: EMPTY
4239: LIST
4240: LIST
4241: LIST
4242: LIST
4243: PUSH
4244: LD_INT 14
4246: PUSH
4247: LD_INT 1
4249: PUSH
4250: LD_INT 2
4252: PUSH
4253: LD_INT 27
4255: PUSH
4256: EMPTY
4257: LIST
4258: LIST
4259: LIST
4260: LIST
4261: PUSH
4262: LD_INT 14
4264: PUSH
4265: LD_INT 1
4267: PUSH
4268: LD_INT 2
4270: PUSH
4271: LD_EXP 72
4275: PUSH
4276: EMPTY
4277: LIST
4278: LIST
4279: LIST
4280: LIST
4281: PUSH
4282: LD_INT 14
4284: PUSH
4285: LD_INT 1
4287: PUSH
4288: LD_INT 2
4290: PUSH
4291: LD_INT 26
4293: PUSH
4294: EMPTY
4295: LIST
4296: LIST
4297: LIST
4298: LIST
4299: PUSH
4300: EMPTY
4301: LIST
4302: LIST
4303: LIST
4304: LIST
4305: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
4306: LD_ADDR_VAR 0 5
4310: PUSH
4311: LD_VAR 0 5
4315: PUSH
4316: LD_OWVAR 1
4320: PUSH
4321: LD_INT 21000
4323: DIV
4324: PLUS
4325: ST_TO_ADDR
// if amount > 8 then
4326: LD_VAR 0 5
4330: PUSH
4331: LD_INT 8
4333: GREATER
4334: IFFALSE 4344
// amount := 8 ;
4336: LD_ADDR_VAR 0 5
4340: PUSH
4341: LD_INT 8
4343: ST_TO_ADDR
// for i = 1 to amount do
4344: LD_ADDR_VAR 0 1
4348: PUSH
4349: DOUBLE
4350: LD_INT 1
4352: DEC
4353: ST_TO_ADDR
4354: LD_VAR 0 5
4358: PUSH
4359: FOR_TO
4360: IFFALSE 4448
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_half_tracked , ar_medium_trike ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gatling_gun , ar_gun ] [ rand ( 1 , 3 ) ] ] ) ;
4362: LD_ADDR_VAR 0 3
4366: PUSH
4367: LD_VAR 0 3
4371: PPUSH
4372: LD_VAR 0 3
4376: PUSH
4377: LD_INT 1
4379: PLUS
4380: PPUSH
4381: LD_INT 14
4383: PUSH
4384: LD_INT 13
4386: PUSH
4387: EMPTY
4388: LIST
4389: LIST
4390: PUSH
4391: LD_INT 1
4393: PPUSH
4394: LD_INT 2
4396: PPUSH
4397: CALL_OW 12
4401: ARRAY
4402: PUSH
4403: LD_INT 1
4405: PUSH
4406: LD_INT 2
4408: PUSH
4409: LD_INT 28
4411: PUSH
4412: LD_INT 25
4414: PUSH
4415: LD_INT 27
4417: PUSH
4418: EMPTY
4419: LIST
4420: LIST
4421: LIST
4422: PUSH
4423: LD_INT 1
4425: PPUSH
4426: LD_INT 3
4428: PPUSH
4429: CALL_OW 12
4433: ARRAY
4434: PUSH
4435: EMPTY
4436: LIST
4437: LIST
4438: LIST
4439: LIST
4440: PPUSH
4441: CALL_OW 2
4445: ST_TO_ADDR
4446: GO 4359
4448: POP
4449: POP
// MC_InsertProduceList ( base , tmp ) ;
4450: LD_VAR 0 2
4454: PPUSH
4455: LD_VAR 0 3
4459: PPUSH
4460: CALL 72528 0 2
// repeat wait ( 0 0$1 ) ;
4464: LD_INT 35
4466: PPUSH
4467: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
4471: LD_VAR 0 2
4475: PPUSH
4476: LD_INT 1
4478: PPUSH
4479: CALL 73946 0 2
4483: PUSH
4484: LD_VAR 0 5
4488: GREATEREQUAL
4489: IFFALSE 4464
// wait ( 0 0$30 ) ;
4491: LD_INT 1050
4493: PPUSH
4494: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_control_tower ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
4498: LD_ADDR_VAR 0 4
4502: PUSH
4503: LD_EXP 42
4507: PUSH
4508: LD_VAR 0 2
4512: ARRAY
4513: PUSH
4514: LD_EXP 42
4518: PUSH
4519: LD_VAR 0 2
4523: ARRAY
4524: PPUSH
4525: LD_INT 2
4527: PUSH
4528: LD_INT 34
4530: PUSH
4531: LD_INT 31
4533: PUSH
4534: EMPTY
4535: LIST
4536: LIST
4537: PUSH
4538: LD_INT 34
4540: PUSH
4541: LD_INT 32
4543: PUSH
4544: EMPTY
4545: LIST
4546: LIST
4547: PUSH
4548: LD_INT 34
4550: PUSH
4551: LD_EXP 73
4555: PUSH
4556: EMPTY
4557: LIST
4558: LIST
4559: PUSH
4560: EMPTY
4561: LIST
4562: LIST
4563: LIST
4564: LIST
4565: PPUSH
4566: CALL_OW 72
4570: DIFF
4571: ST_TO_ADDR
// if not attackers then
4572: LD_VAR 0 4
4576: NOT
4577: IFFALSE 4581
// exit ;
4579: GO 4804
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
4581: LD_ADDR_EXP 42
4585: PUSH
4586: LD_EXP 42
4590: PPUSH
4591: LD_VAR 0 2
4595: PPUSH
4596: LD_EXP 42
4600: PUSH
4601: LD_VAR 0 2
4605: ARRAY
4606: PUSH
4607: LD_VAR 0 4
4611: DIFF
4612: PPUSH
4613: CALL_OW 1
4617: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
4618: LD_VAR 0 4
4622: PPUSH
4623: LD_INT 107
4625: PPUSH
4626: LD_INT 74
4628: PPUSH
4629: CALL_OW 114
// wait ( 0 0$5 ) ;
4633: LD_INT 175
4635: PPUSH
4636: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
4640: LD_INT 35
4642: PPUSH
4643: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
4647: LD_VAR 0 4
4651: PPUSH
4652: LD_INT 60
4654: PUSH
4655: EMPTY
4656: LIST
4657: PPUSH
4658: CALL_OW 72
4662: NOT
4663: IFFALSE 4640
// if rand ( 0 , 1 ) then
4665: LD_INT 0
4667: PPUSH
4668: LD_INT 1
4670: PPUSH
4671: CALL_OW 12
4675: IFFALSE 4694
// ComAgressiveMove ( attackers , 155 , 108 ) else
4677: LD_VAR 0 4
4681: PPUSH
4682: LD_INT 155
4684: PPUSH
4685: LD_INT 108
4687: PPUSH
4688: CALL_OW 114
4692: GO 4709
// ComAgressiveMove ( attackers , 149 , 55 ) ;
4694: LD_VAR 0 4
4698: PPUSH
4699: LD_INT 149
4701: PPUSH
4702: LD_INT 55
4704: PPUSH
4705: CALL_OW 114
// wait ( 0 0$10 ) ;
4709: LD_INT 350
4711: PPUSH
4712: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
4716: LD_INT 35
4718: PPUSH
4719: CALL_OW 67
// for i in attackers do
4723: LD_ADDR_VAR 0 1
4727: PUSH
4728: LD_VAR 0 4
4732: PUSH
4733: FOR_IN
4734: IFFALSE 4784
// if not HasTask ( i ) then
4736: LD_VAR 0 1
4740: PPUSH
4741: CALL_OW 314
4745: NOT
4746: IFFALSE 4782
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4748: LD_VAR 0 1
4752: PPUSH
4753: LD_INT 81
4755: PUSH
4756: LD_INT 2
4758: PUSH
4759: EMPTY
4760: LIST
4761: LIST
4762: PPUSH
4763: CALL_OW 69
4767: PPUSH
4768: LD_VAR 0 1
4772: PPUSH
4773: CALL_OW 74
4777: PPUSH
4778: CALL_OW 115
4782: GO 4733
4784: POP
4785: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
4786: LD_VAR 0 4
4790: PPUSH
4791: LD_INT 50
4793: PUSH
4794: EMPTY
4795: LIST
4796: PPUSH
4797: CALL_OW 72
4801: NOT
4802: IFFALSE 4716
// end ;
4804: PPOPN 5
4806: END
// every 15 15$00 + 8 8$00 trigger not arDestroyed and tick < 81 81$00 do var i , un , tmp ;
4807: LD_EXP 4
4811: NOT
4812: PUSH
4813: LD_OWVAR 1
4817: PUSH
4818: LD_INT 170100
4820: LESS
4821: AND
4822: IFFALSE 5490
4824: GO 4826
4826: DISABLE
4827: LD_INT 0
4829: PPUSH
4830: PPUSH
4831: PPUSH
// begin enable ;
4832: ENABLE
// tmp := [ ] ;
4833: LD_ADDR_VAR 0 3
4837: PUSH
4838: EMPTY
4839: ST_TO_ADDR
// if tick < 35 35$00 then
4840: LD_OWVAR 1
4844: PUSH
4845: LD_INT 73500
4847: LESS
4848: IFFALSE 5046
// begin for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
4850: LD_ADDR_VAR 0 1
4854: PUSH
4855: DOUBLE
4856: LD_INT 1
4858: DEC
4859: ST_TO_ADDR
4860: LD_INT 4
4862: PUSH
4863: LD_INT 5
4865: PUSH
4866: LD_INT 5
4868: PUSH
4869: EMPTY
4870: LIST
4871: LIST
4872: LIST
4873: PUSH
4874: LD_OWVAR 67
4878: ARRAY
4879: PUSH
4880: FOR_TO
4881: IFFALSE 5042
// begin uc_side := 2 ;
4883: LD_ADDR_OWVAR 20
4887: PUSH
4888: LD_INT 2
4890: ST_TO_ADDR
// uc_nation := 2 ;
4891: LD_ADDR_OWVAR 21
4895: PUSH
4896: LD_INT 2
4898: ST_TO_ADDR
// InitHC_All ( ) ;
4899: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
4903: LD_INT 0
4905: PPUSH
4906: LD_INT 1
4908: PPUSH
4909: LD_INT 5
4911: PUSH
4912: LD_INT 6
4914: PUSH
4915: LD_INT 7
4917: PUSH
4918: EMPTY
4919: LIST
4920: LIST
4921: LIST
4922: PUSH
4923: LD_OWVAR 67
4927: ARRAY
4928: PPUSH
4929: CALL_OW 380
// un := CreateHuman ;
4933: LD_ADDR_VAR 0 2
4937: PUSH
4938: CALL_OW 44
4942: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
4943: LD_VAR 0 2
4947: PPUSH
4948: LD_INT 17
4950: PPUSH
4951: LD_INT 0
4953: PPUSH
4954: CALL_OW 49
// SetClass ( un , [ class_soldier , class_mortar ] [ rand ( 1 , 2 ) ] ) ;
4958: LD_VAR 0 2
4962: PPUSH
4963: LD_INT 1
4965: PUSH
4966: LD_INT 8
4968: PUSH
4969: EMPTY
4970: LIST
4971: LIST
4972: PUSH
4973: LD_INT 1
4975: PPUSH
4976: LD_INT 2
4978: PPUSH
4979: CALL_OW 12
4983: ARRAY
4984: PPUSH
4985: CALL_OW 336
// ComAgressiveMove ( un , 111 , 34 ) ;
4989: LD_VAR 0 2
4993: PPUSH
4994: LD_INT 111
4996: PPUSH
4997: LD_INT 34
4999: PPUSH
5000: CALL_OW 114
// wait ( 0 0$2 ) ;
5004: LD_INT 70
5006: PPUSH
5007: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5011: LD_ADDR_VAR 0 3
5015: PUSH
5016: LD_VAR 0 3
5020: PPUSH
5021: LD_VAR 0 3
5025: PUSH
5026: LD_INT 1
5028: PLUS
5029: PPUSH
5030: LD_VAR 0 2
5034: PPUSH
5035: CALL_OW 1
5039: ST_TO_ADDR
// end ;
5040: GO 4880
5042: POP
5043: POP
// end else
5044: GO 5187
// begin for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
5046: LD_ADDR_VAR 0 1
5050: PUSH
5051: DOUBLE
5052: LD_INT 1
5054: DEC
5055: ST_TO_ADDR
5056: LD_INT 4
5058: PUSH
5059: LD_INT 5
5061: PUSH
5062: LD_INT 5
5064: PUSH
5065: EMPTY
5066: LIST
5067: LIST
5068: LIST
5069: PUSH
5070: LD_OWVAR 67
5074: ARRAY
5075: PUSH
5076: FOR_TO
5077: IFFALSE 5185
// begin uc_side := 2 ;
5079: LD_ADDR_OWVAR 20
5083: PUSH
5084: LD_INT 2
5086: ST_TO_ADDR
// uc_nation := 0 ;
5087: LD_ADDR_OWVAR 21
5091: PUSH
5092: LD_INT 0
5094: ST_TO_ADDR
// InitHC_All ( ) ;
5095: CALL_OW 584
// hc_class := class_apeman_kamikaze ;
5099: LD_ADDR_OWVAR 28
5103: PUSH
5104: LD_INT 17
5106: ST_TO_ADDR
// un := CreateHuman ;
5107: LD_ADDR_VAR 0 2
5111: PUSH
5112: CALL_OW 44
5116: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5117: LD_VAR 0 2
5121: PPUSH
5122: LD_INT 17
5124: PPUSH
5125: LD_INT 0
5127: PPUSH
5128: CALL_OW 49
// ComAgressiveMove ( un , 110 , 33 ) ;
5132: LD_VAR 0 2
5136: PPUSH
5137: LD_INT 110
5139: PPUSH
5140: LD_INT 33
5142: PPUSH
5143: CALL_OW 114
// wait ( 0 0$2 ) ;
5147: LD_INT 70
5149: PPUSH
5150: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5154: LD_ADDR_VAR 0 3
5158: PUSH
5159: LD_VAR 0 3
5163: PPUSH
5164: LD_VAR 0 3
5168: PUSH
5169: LD_INT 1
5171: PLUS
5172: PPUSH
5173: LD_VAR 0 2
5177: PPUSH
5178: CALL_OW 1
5182: ST_TO_ADDR
// end ;
5183: GO 5076
5185: POP
5186: POP
// end ; for i := 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
5187: LD_ADDR_VAR 0 1
5191: PUSH
5192: DOUBLE
5193: LD_INT 1
5195: DEC
5196: ST_TO_ADDR
5197: LD_INT 3
5199: PUSH
5200: LD_INT 4
5202: PUSH
5203: LD_INT 5
5205: PUSH
5206: EMPTY
5207: LIST
5208: LIST
5209: LIST
5210: PUSH
5211: LD_OWVAR 67
5215: ARRAY
5216: PUSH
5217: FOR_TO
5218: IFFALSE 5368
// begin uc_side := 2 ;
5220: LD_ADDR_OWVAR 20
5224: PUSH
5225: LD_INT 2
5227: ST_TO_ADDR
// uc_nation := 2 ;
5228: LD_ADDR_OWVAR 21
5232: PUSH
5233: LD_INT 2
5235: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_selfpropelled_bomb , ar_rocket_launcher , ar_gun ] [ rand ( 1 , 3 ) ] , 90 ) ;
5236: LD_INT 14
5238: PPUSH
5239: LD_INT 3
5241: PPUSH
5242: LD_INT 5
5244: PPUSH
5245: LD_INT 29
5247: PUSH
5248: LD_INT 28
5250: PUSH
5251: LD_INT 27
5253: PUSH
5254: EMPTY
5255: LIST
5256: LIST
5257: LIST
5258: PUSH
5259: LD_INT 1
5261: PPUSH
5262: LD_INT 3
5264: PPUSH
5265: CALL_OW 12
5269: ARRAY
5270: PPUSH
5271: LD_INT 90
5273: PPUSH
5274: CALL 14793 0 5
// un := CreateVehicle ;
5278: LD_ADDR_VAR 0 2
5282: PUSH
5283: CALL_OW 45
5287: ST_TO_ADDR
// SetDir ( un , 2 ) ;
5288: LD_VAR 0 2
5292: PPUSH
5293: LD_INT 2
5295: PPUSH
5296: CALL_OW 233
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5300: LD_VAR 0 2
5304: PPUSH
5305: LD_INT 17
5307: PPUSH
5308: LD_INT 0
5310: PPUSH
5311: CALL_OW 49
// ComMoveXY ( un , 66 , 23 ) ;
5315: LD_VAR 0 2
5319: PPUSH
5320: LD_INT 66
5322: PPUSH
5323: LD_INT 23
5325: PPUSH
5326: CALL_OW 111
// wait ( 0 0$3 ) ;
5330: LD_INT 105
5332: PPUSH
5333: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5337: LD_ADDR_VAR 0 3
5341: PUSH
5342: LD_VAR 0 3
5346: PPUSH
5347: LD_VAR 0 3
5351: PUSH
5352: LD_INT 1
5354: PLUS
5355: PPUSH
5356: LD_VAR 0 2
5360: PPUSH
5361: CALL_OW 1
5365: ST_TO_ADDR
// end ;
5366: GO 5217
5368: POP
5369: POP
// if not tmp then
5370: LD_VAR 0 3
5374: NOT
5375: IFFALSE 5379
// exit ;
5377: GO 5490
// wait ( 0 0$5 ) ;
5379: LD_INT 175
5381: PPUSH
5382: CALL_OW 67
// repeat wait ( 0 0$3 ) ;
5386: LD_INT 105
5388: PPUSH
5389: CALL_OW 67
// for i in tmp do
5393: LD_ADDR_VAR 0 1
5397: PUSH
5398: LD_VAR 0 3
5402: PUSH
5403: FOR_IN
5404: IFFALSE 5481
// begin if not IsOk ( i ) or IsDead ( i ) then
5406: LD_VAR 0 1
5410: PPUSH
5411: CALL_OW 302
5415: NOT
5416: PUSH
5417: LD_VAR 0 1
5421: PPUSH
5422: CALL_OW 301
5426: OR
5427: IFFALSE 5445
// tmp := tmp diff i ;
5429: LD_ADDR_VAR 0 3
5433: PUSH
5434: LD_VAR 0 3
5438: PUSH
5439: LD_VAR 0 1
5443: DIFF
5444: ST_TO_ADDR
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
5445: LD_VAR 0 1
5449: PPUSH
5450: LD_INT 81
5452: PUSH
5453: LD_INT 3
5455: PUSH
5456: EMPTY
5457: LIST
5458: LIST
5459: PPUSH
5460: CALL_OW 69
5464: PPUSH
5465: LD_VAR 0 1
5469: PPUSH
5470: CALL_OW 74
5474: PPUSH
5475: CALL_OW 115
// end ;
5479: GO 5403
5481: POP
5482: POP
// until not tmp ;
5483: LD_VAR 0 3
5487: NOT
5488: IFFALSE 5386
// end ;
5490: PPOPN 3
5492: END
// every 9 9$00 trigger Difficulty > 1 do var un ;
5493: LD_OWVAR 67
5497: PUSH
5498: LD_INT 1
5500: GREATER
5501: IFFALSE 5599
5503: GO 5505
5505: DISABLE
5506: LD_INT 0
5508: PPUSH
// begin uc_side := 2 ;
5509: LD_ADDR_OWVAR 20
5513: PUSH
5514: LD_INT 2
5516: ST_TO_ADDR
// uc_nation := 2 ;
5517: LD_ADDR_OWVAR 21
5521: PUSH
5522: LD_INT 2
5524: ST_TO_ADDR
// PrepareHuman ( false , 4 , 6 ) ;
5525: LD_INT 0
5527: PPUSH
5528: LD_INT 4
5530: PPUSH
5531: LD_INT 6
5533: PPUSH
5534: CALL_OW 380
// un := CreateHuman ;
5538: LD_ADDR_VAR 0 1
5542: PUSH
5543: CALL_OW 44
5547: ST_TO_ADDR
// PlaceUnitXYD ( un , 88 , 1 , 2 , false ) ;
5548: LD_VAR 0 1
5552: PPUSH
5553: LD_INT 88
5555: PPUSH
5556: LD_INT 1
5558: PPUSH
5559: LD_INT 2
5561: PPUSH
5562: LD_INT 0
5564: PPUSH
5565: CALL 48478 0 5
// ComMoveXY ( un , 130 , 35 ) ;
5569: LD_VAR 0 1
5573: PPUSH
5574: LD_INT 130
5576: PPUSH
5577: LD_INT 35
5579: PPUSH
5580: CALL_OW 111
// AddComContaminate ( un , 132 , 39 ) ;
5584: LD_VAR 0 1
5588: PPUSH
5589: LD_INT 132
5591: PPUSH
5592: LD_INT 39
5594: PPUSH
5595: CALL_OW 218
// end ; end_of_file
5599: PPOPN 1
5601: END
// export Popov , popov_side , extraPopovForces , popovAttackGroup ; export function PreparePopov ; var i , un , tmp ; begin
5602: LD_INT 0
5604: PPUSH
5605: PPUSH
5606: PPUSH
5607: PPUSH
// popov_side := 3 ;
5608: LD_ADDR_EXP 17
5612: PUSH
5613: LD_INT 3
5615: ST_TO_ADDR
// uc_side := popov_side ;
5616: LD_ADDR_OWVAR 20
5620: PUSH
5621: LD_EXP 17
5625: ST_TO_ADDR
// uc_nation := 3 ;
5626: LD_ADDR_OWVAR 21
5630: PUSH
5631: LD_INT 3
5633: ST_TO_ADDR
// tmp := PrepareBase ( ru_depot , popov_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 11500 , 1100 , 60 ] , [ 6 , 6 , 6 , 6 ] ) ;
5634: LD_ADDR_VAR 0 4
5638: PUSH
5639: LD_INT 9
5641: PPUSH
5642: LD_INT 3
5644: PPUSH
5645: LD_STRING 
5647: PPUSH
5648: LD_INT 8
5650: PUSH
5651: LD_INT 7
5653: PUSH
5654: LD_INT 6
5656: PUSH
5657: EMPTY
5658: LIST
5659: LIST
5660: LIST
5661: PUSH
5662: LD_OWVAR 67
5666: ARRAY
5667: PPUSH
5668: LD_INT 11500
5670: PUSH
5671: LD_INT 1100
5673: PUSH
5674: LD_INT 60
5676: PUSH
5677: EMPTY
5678: LIST
5679: LIST
5680: LIST
5681: PPUSH
5682: LD_INT 6
5684: PUSH
5685: LD_INT 6
5687: PUSH
5688: LD_INT 6
5690: PUSH
5691: LD_INT 6
5693: PUSH
5694: EMPTY
5695: LIST
5696: LIST
5697: LIST
5698: LIST
5699: PPUSH
5700: CALL 18240 0 6
5704: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 3 , tmp ) ;
5705: LD_ADDR_EXP 23
5709: PUSH
5710: LD_EXP 23
5714: PPUSH
5715: LD_INT 3
5717: PPUSH
5718: LD_VAR 0 4
5722: PPUSH
5723: CALL_OW 1
5727: ST_TO_ADDR
// extraPopovForces := [ ] ;
5728: LD_ADDR_EXP 18
5732: PUSH
5733: EMPTY
5734: ST_TO_ADDR
// for i := 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
5735: LD_ADDR_VAR 0 2
5739: PUSH
5740: DOUBLE
5741: LD_INT 1
5743: DEC
5744: ST_TO_ADDR
5745: LD_INT 5
5747: PUSH
5748: LD_INT 6
5750: PUSH
5751: LD_INT 7
5753: PUSH
5754: EMPTY
5755: LIST
5756: LIST
5757: LIST
5758: PUSH
5759: LD_OWVAR 67
5763: ARRAY
5764: PUSH
5765: FOR_TO
5766: IFFALSE 5869
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
5768: LD_INT 0
5770: PPUSH
5771: LD_INT 1
5773: PPUSH
5774: LD_INT 4
5776: PUSH
5777: LD_INT 5
5779: PUSH
5780: LD_INT 6
5782: PUSH
5783: EMPTY
5784: LIST
5785: LIST
5786: LIST
5787: PUSH
5788: LD_OWVAR 67
5792: ARRAY
5793: PPUSH
5794: CALL_OW 380
// un := CreateHuman ;
5798: LD_ADDR_VAR 0 3
5802: PUSH
5803: CALL_OW 44
5807: ST_TO_ADDR
// PlaceUnitXYR ( un , 131 , 110 , 8 , false ) ;
5808: LD_VAR 0 3
5812: PPUSH
5813: LD_INT 131
5815: PPUSH
5816: LD_INT 110
5818: PPUSH
5819: LD_INT 8
5821: PPUSH
5822: LD_INT 0
5824: PPUSH
5825: CALL_OW 50
// ComHold ( un ) ;
5829: LD_VAR 0 3
5833: PPUSH
5834: CALL_OW 140
// extraPopovForces := Replace ( extraPopovForces , extraPopovForces + 1 , un ) ;
5838: LD_ADDR_EXP 18
5842: PUSH
5843: LD_EXP 18
5847: PPUSH
5848: LD_EXP 18
5852: PUSH
5853: LD_INT 1
5855: PLUS
5856: PPUSH
5857: LD_VAR 0 3
5861: PPUSH
5862: CALL_OW 1
5866: ST_TO_ADDR
// end ;
5867: GO 5765
5869: POP
5870: POP
// PrepareSoldier ( false , 6 ) ;
5871: LD_INT 0
5873: PPUSH
5874: LD_INT 6
5876: PPUSH
5877: CALL_OW 381
// un := CreateHuman ;
5881: LD_ADDR_VAR 0 3
5885: PUSH
5886: CALL_OW 44
5890: ST_TO_ADDR
// SetDir ( un , 1 ) ;
5891: LD_VAR 0 3
5895: PPUSH
5896: LD_INT 1
5898: PPUSH
5899: CALL_OW 233
// PlaceHumanInUnit ( un , HexInfo ( 150 , 158 ) ) ;
5903: LD_VAR 0 3
5907: PPUSH
5908: LD_INT 150
5910: PPUSH
5911: LD_INT 158
5913: PPUSH
5914: CALL_OW 428
5918: PPUSH
5919: CALL_OW 52
// popovAttackGroup := [ ] ;
5923: LD_ADDR_EXP 19
5927: PUSH
5928: EMPTY
5929: ST_TO_ADDR
// end ;
5930: LD_VAR 0 1
5934: RET
// export function InitMC_Popov ( ) ; begin
5935: LD_INT 0
5937: PPUSH
// MC_SetScanArea ( 3 , popov_base ) ;
5938: LD_INT 3
5940: PPUSH
5941: LD_INT 3
5943: PPUSH
5944: CALL 73801 0 2
// MC_SetParkingArea ( 3 , popov_parking ) ;
5948: LD_INT 3
5950: PPUSH
5951: LD_INT 10
5953: PPUSH
5954: CALL 73745 0 2
// MC_SetDepositsXY ( 3 , [ [ 86 , 118 , 0 ] , [ 123 , 151 , 1 ] , [ 98 , 121 , 0 ] ] ) ;
5958: LD_INT 3
5960: PPUSH
5961: LD_INT 86
5963: PUSH
5964: LD_INT 118
5966: PUSH
5967: LD_INT 0
5969: PUSH
5970: EMPTY
5971: LIST
5972: LIST
5973: LIST
5974: PUSH
5975: LD_INT 123
5977: PUSH
5978: LD_INT 151
5980: PUSH
5981: LD_INT 1
5983: PUSH
5984: EMPTY
5985: LIST
5986: LIST
5987: LIST
5988: PUSH
5989: LD_INT 98
5991: PUSH
5992: LD_INT 121
5994: PUSH
5995: LD_INT 0
5997: PUSH
5998: EMPTY
5999: LIST
6000: LIST
6001: LIST
6002: PUSH
6003: EMPTY
6004: LIST
6005: LIST
6006: LIST
6007: PPUSH
6008: CALL 72804 0 2
// MC_SetAllowedTurretWeapons ( 3 , [ ru_heavy_gun , ru_rocket_launcher ] ) ;
6012: LD_INT 3
6014: PPUSH
6015: LD_INT 46
6017: PUSH
6018: LD_INT 45
6020: PUSH
6021: EMPTY
6022: LIST
6023: LIST
6024: PPUSH
6025: CALL 73633 0 2
// MC_SetCratesArea ( 3 , popov_crates ) ;
6029: LD_INT 3
6031: PPUSH
6032: LD_INT 12
6034: PPUSH
6035: CALL 73315 0 2
// MC_SetTame ( 3 , popov_ape ) ;
6039: LD_INT 3
6041: PPUSH
6042: LD_INT 11
6044: PPUSH
6045: CALL 73046 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
6049: LD_INT 3
6051: PPUSH
6052: LD_INT 4
6054: PPUSH
6055: CALL 72665 0 2
// MC_SetProduceList ( 3 , [ [ ru_heavy_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] ] ) ;
6059: LD_INT 3
6061: PPUSH
6062: LD_INT 23
6064: PUSH
6065: LD_INT 1
6067: PUSH
6068: LD_INT 3
6070: PUSH
6071: LD_INT 44
6073: PUSH
6074: EMPTY
6075: LIST
6076: LIST
6077: LIST
6078: LIST
6079: PUSH
6080: LD_INT 23
6082: PUSH
6083: LD_INT 1
6085: PUSH
6086: LD_INT 3
6088: PUSH
6089: LD_INT 45
6091: PUSH
6092: EMPTY
6093: LIST
6094: LIST
6095: LIST
6096: LIST
6097: PUSH
6098: LD_INT 21
6100: PUSH
6101: LD_INT 1
6103: PUSH
6104: LD_INT 3
6106: PUSH
6107: LD_INT 44
6109: PUSH
6110: EMPTY
6111: LIST
6112: LIST
6113: LIST
6114: LIST
6115: PUSH
6116: LD_INT 21
6118: PUSH
6119: LD_INT 1
6121: PUSH
6122: LD_INT 3
6124: PUSH
6125: LD_INT 45
6127: PUSH
6128: EMPTY
6129: LIST
6130: LIST
6131: LIST
6132: LIST
6133: PUSH
6134: EMPTY
6135: LIST
6136: LIST
6137: LIST
6138: LIST
6139: PPUSH
6140: CALL 72480 0 2
// MC_SetBuildingList ( 3 , [ [ b_lab , 76 , 145 , 1 ] , [ b_oil_power , 87 , 144 , 0 ] , [ b_oil_mine , 86 , 118 , 0 ] , [ b_oil_mine , 98 , 121 , 0 ] , [ b_oil_power , 87 , 147 , 1 ] , [ b_workshop , 94 , 161 , 0 ] , [ b_lab , 81 , 155 , 1 ] , [ b_armoury , 103 , 147 , 3 ] , [ b_oil_power , 96 , 152 , 0 ] , [ b_oil_power , 96 , 149 , 3 ] , [ b_bunker , 109 , 142 , 3 ] , [ b_bunker , 112 , 148 , 3 ] , [ b_turret , 120 , 159 , 4 ] , [ b_turret , 122 , 163 , 4 ] , [ b_turret , 123 , 167 , 4 ] , [ b_turret , 59 , 111 , 3 ] , [ b_turret , 65 , 111 , 3 ] , [ b_turret , 76 , 117 , 3 ] , [ b_turret , 80 , 119 , 3 ] , [ b_turret , 87 , 125 , 3 ] , [ b_armoury , 92 , 129 , 3 ] , [ b_siberite_power , 85 , 165 , 0 ] , [ b_siberite_power , 83 , 161 , 4 ] , [ b_siberite_power , 91 , 166 , 3 ] , [ b_siberite_power , 102 , 166 , 2 ] ] ) ;
6144: LD_INT 3
6146: PPUSH
6147: LD_INT 6
6149: PUSH
6150: LD_INT 76
6152: PUSH
6153: LD_INT 145
6155: PUSH
6156: LD_INT 1
6158: PUSH
6159: EMPTY
6160: LIST
6161: LIST
6162: LIST
6163: LIST
6164: PUSH
6165: LD_INT 26
6167: PUSH
6168: LD_INT 87
6170: PUSH
6171: LD_INT 144
6173: PUSH
6174: LD_INT 0
6176: PUSH
6177: EMPTY
6178: LIST
6179: LIST
6180: LIST
6181: LIST
6182: PUSH
6183: LD_INT 29
6185: PUSH
6186: LD_INT 86
6188: PUSH
6189: LD_INT 118
6191: PUSH
6192: LD_INT 0
6194: PUSH
6195: EMPTY
6196: LIST
6197: LIST
6198: LIST
6199: LIST
6200: PUSH
6201: LD_INT 29
6203: PUSH
6204: LD_INT 98
6206: PUSH
6207: LD_INT 121
6209: PUSH
6210: LD_INT 0
6212: PUSH
6213: EMPTY
6214: LIST
6215: LIST
6216: LIST
6217: LIST
6218: PUSH
6219: LD_INT 26
6221: PUSH
6222: LD_INT 87
6224: PUSH
6225: LD_INT 147
6227: PUSH
6228: LD_INT 1
6230: PUSH
6231: EMPTY
6232: LIST
6233: LIST
6234: LIST
6235: LIST
6236: PUSH
6237: LD_INT 2
6239: PUSH
6240: LD_INT 94
6242: PUSH
6243: LD_INT 161
6245: PUSH
6246: LD_INT 0
6248: PUSH
6249: EMPTY
6250: LIST
6251: LIST
6252: LIST
6253: LIST
6254: PUSH
6255: LD_INT 6
6257: PUSH
6258: LD_INT 81
6260: PUSH
6261: LD_INT 155
6263: PUSH
6264: LD_INT 1
6266: PUSH
6267: EMPTY
6268: LIST
6269: LIST
6270: LIST
6271: LIST
6272: PUSH
6273: LD_INT 4
6275: PUSH
6276: LD_INT 103
6278: PUSH
6279: LD_INT 147
6281: PUSH
6282: LD_INT 3
6284: PUSH
6285: EMPTY
6286: LIST
6287: LIST
6288: LIST
6289: LIST
6290: PUSH
6291: LD_INT 26
6293: PUSH
6294: LD_INT 96
6296: PUSH
6297: LD_INT 152
6299: PUSH
6300: LD_INT 0
6302: PUSH
6303: EMPTY
6304: LIST
6305: LIST
6306: LIST
6307: LIST
6308: PUSH
6309: LD_INT 26
6311: PUSH
6312: LD_INT 96
6314: PUSH
6315: LD_INT 149
6317: PUSH
6318: LD_INT 3
6320: PUSH
6321: EMPTY
6322: LIST
6323: LIST
6324: LIST
6325: LIST
6326: PUSH
6327: LD_INT 32
6329: PUSH
6330: LD_INT 109
6332: PUSH
6333: LD_INT 142
6335: PUSH
6336: LD_INT 3
6338: PUSH
6339: EMPTY
6340: LIST
6341: LIST
6342: LIST
6343: LIST
6344: PUSH
6345: LD_INT 32
6347: PUSH
6348: LD_INT 112
6350: PUSH
6351: LD_INT 148
6353: PUSH
6354: LD_INT 3
6356: PUSH
6357: EMPTY
6358: LIST
6359: LIST
6360: LIST
6361: LIST
6362: PUSH
6363: LD_INT 33
6365: PUSH
6366: LD_INT 120
6368: PUSH
6369: LD_INT 159
6371: PUSH
6372: LD_INT 4
6374: PUSH
6375: EMPTY
6376: LIST
6377: LIST
6378: LIST
6379: LIST
6380: PUSH
6381: LD_INT 33
6383: PUSH
6384: LD_INT 122
6386: PUSH
6387: LD_INT 163
6389: PUSH
6390: LD_INT 4
6392: PUSH
6393: EMPTY
6394: LIST
6395: LIST
6396: LIST
6397: LIST
6398: PUSH
6399: LD_INT 33
6401: PUSH
6402: LD_INT 123
6404: PUSH
6405: LD_INT 167
6407: PUSH
6408: LD_INT 4
6410: PUSH
6411: EMPTY
6412: LIST
6413: LIST
6414: LIST
6415: LIST
6416: PUSH
6417: LD_INT 33
6419: PUSH
6420: LD_INT 59
6422: PUSH
6423: LD_INT 111
6425: PUSH
6426: LD_INT 3
6428: PUSH
6429: EMPTY
6430: LIST
6431: LIST
6432: LIST
6433: LIST
6434: PUSH
6435: LD_INT 33
6437: PUSH
6438: LD_INT 65
6440: PUSH
6441: LD_INT 111
6443: PUSH
6444: LD_INT 3
6446: PUSH
6447: EMPTY
6448: LIST
6449: LIST
6450: LIST
6451: LIST
6452: PUSH
6453: LD_INT 33
6455: PUSH
6456: LD_INT 76
6458: PUSH
6459: LD_INT 117
6461: PUSH
6462: LD_INT 3
6464: PUSH
6465: EMPTY
6466: LIST
6467: LIST
6468: LIST
6469: LIST
6470: PUSH
6471: LD_INT 33
6473: PUSH
6474: LD_INT 80
6476: PUSH
6477: LD_INT 119
6479: PUSH
6480: LD_INT 3
6482: PUSH
6483: EMPTY
6484: LIST
6485: LIST
6486: LIST
6487: LIST
6488: PUSH
6489: LD_INT 33
6491: PUSH
6492: LD_INT 87
6494: PUSH
6495: LD_INT 125
6497: PUSH
6498: LD_INT 3
6500: PUSH
6501: EMPTY
6502: LIST
6503: LIST
6504: LIST
6505: LIST
6506: PUSH
6507: LD_INT 4
6509: PUSH
6510: LD_INT 92
6512: PUSH
6513: LD_INT 129
6515: PUSH
6516: LD_INT 3
6518: PUSH
6519: EMPTY
6520: LIST
6521: LIST
6522: LIST
6523: LIST
6524: PUSH
6525: LD_INT 28
6527: PUSH
6528: LD_INT 85
6530: PUSH
6531: LD_INT 165
6533: PUSH
6534: LD_INT 0
6536: PUSH
6537: EMPTY
6538: LIST
6539: LIST
6540: LIST
6541: LIST
6542: PUSH
6543: LD_INT 28
6545: PUSH
6546: LD_INT 83
6548: PUSH
6549: LD_INT 161
6551: PUSH
6552: LD_INT 4
6554: PUSH
6555: EMPTY
6556: LIST
6557: LIST
6558: LIST
6559: LIST
6560: PUSH
6561: LD_INT 28
6563: PUSH
6564: LD_INT 91
6566: PUSH
6567: LD_INT 166
6569: PUSH
6570: LD_INT 3
6572: PUSH
6573: EMPTY
6574: LIST
6575: LIST
6576: LIST
6577: LIST
6578: PUSH
6579: LD_INT 28
6581: PUSH
6582: LD_INT 102
6584: PUSH
6585: LD_INT 166
6587: PUSH
6588: LD_INT 2
6590: PUSH
6591: EMPTY
6592: LIST
6593: LIST
6594: LIST
6595: LIST
6596: PUSH
6597: EMPTY
6598: LIST
6599: LIST
6600: LIST
6601: LIST
6602: LIST
6603: LIST
6604: LIST
6605: LIST
6606: LIST
6607: LIST
6608: LIST
6609: LIST
6610: LIST
6611: LIST
6612: LIST
6613: LIST
6614: LIST
6615: LIST
6616: LIST
6617: LIST
6618: LIST
6619: LIST
6620: LIST
6621: LIST
6622: LIST
6623: PPUSH
6624: CALL 72372 0 2
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_siberium ] ) ;
6628: LD_INT 3
6630: PPUSH
6631: LD_INT 10
6633: PUSH
6634: LD_INT 12
6636: PUSH
6637: LD_INT 14
6639: PUSH
6640: LD_INT 11
6642: PUSH
6643: EMPTY
6644: LIST
6645: LIST
6646: LIST
6647: LIST
6648: PPUSH
6649: CALL 73222 0 2
// MC_SetFactoryExtension ( 3 , 94 , 161 , 0 , [ b_ext_noncombat , b_ext_gun , b_ext_rocket , b_ext_computer , b_ext_siberium ] ) ;
6653: LD_INT 3
6655: PPUSH
6656: LD_INT 94
6658: PPUSH
6659: LD_INT 161
6661: PPUSH
6662: LD_INT 0
6664: PPUSH
6665: LD_INT 19
6667: PUSH
6668: LD_INT 17
6670: PUSH
6671: LD_INT 18
6673: PUSH
6674: LD_INT 24
6676: PUSH
6677: LD_INT 21
6679: PUSH
6680: EMPTY
6681: LIST
6682: LIST
6683: LIST
6684: LIST
6685: LIST
6686: PPUSH
6687: CALL 73427 0 5
// MC_SetUpgradeBuilding ( 3 , b_depot ) ;
6691: LD_INT 3
6693: PPUSH
6694: LD_INT 0
6696: PPUSH
6697: CALL 73095 0 2
// MC_InsertProduceList ( 3 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] ] ) ;
6701: LD_INT 3
6703: PPUSH
6704: LD_INT 21
6706: PUSH
6707: LD_INT 1
6709: PUSH
6710: LD_INT 3
6712: PUSH
6713: LD_INT 51
6715: PUSH
6716: EMPTY
6717: LIST
6718: LIST
6719: LIST
6720: LIST
6721: PUSH
6722: EMPTY
6723: LIST
6724: PPUSH
6725: CALL 72528 0 2
// end ;
6729: LD_VAR 0 1
6733: RET
// every 6 6$00 trigger extraPopovForces and not ruDestroyed do
6734: LD_EXP 18
6738: PUSH
6739: LD_EXP 5
6743: NOT
6744: AND
6745: IFFALSE 6805
6747: GO 6749
6749: DISABLE
// begin ComMoveXY ( extraPopovForces , 106 , 137 ) ;
6750: LD_EXP 18
6754: PPUSH
6755: LD_INT 106
6757: PPUSH
6758: LD_INT 137
6760: PPUSH
6761: CALL_OW 111
// mc_bases := Replace ( mc_bases , 3 , mc_bases [ 3 ] union extraPopovForces ) ;
6765: LD_ADDR_EXP 23
6769: PUSH
6770: LD_EXP 23
6774: PPUSH
6775: LD_INT 3
6777: PPUSH
6778: LD_EXP 23
6782: PUSH
6783: LD_INT 3
6785: ARRAY
6786: PUSH
6787: LD_EXP 18
6791: UNION
6792: PPUSH
6793: CALL_OW 1
6797: ST_TO_ADDR
// extraPopovForces := [ ] ;
6798: LD_ADDR_EXP 18
6802: PUSH
6803: EMPTY
6804: ST_TO_ADDR
// end ;
6805: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ru_depot ) and not ruDestroyed do var i , base , tmp , attackers , amount ;
6806: LD_INT 9
6808: PPUSH
6809: CALL_OW 302
6813: PUSH
6814: LD_EXP 5
6818: NOT
6819: AND
6820: IFFALSE 7386
6822: GO 6824
6824: DISABLE
6825: LD_INT 0
6827: PPUSH
6828: PPUSH
6829: PPUSH
6830: PPUSH
6831: PPUSH
// begin enable ;
6832: ENABLE
// base := 3 ;
6833: LD_ADDR_VAR 0 2
6837: PUSH
6838: LD_INT 3
6840: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] ] ;
6841: LD_ADDR_VAR 0 3
6845: PUSH
6846: LD_INT 22
6848: PUSH
6849: LD_INT 1
6851: PUSH
6852: LD_INT 3
6854: PUSH
6855: LD_INT 44
6857: PUSH
6858: EMPTY
6859: LIST
6860: LIST
6861: LIST
6862: LIST
6863: PUSH
6864: LD_INT 24
6866: PUSH
6867: LD_INT 1
6869: PUSH
6870: LD_INT 3
6872: PUSH
6873: LD_INT 46
6875: PUSH
6876: EMPTY
6877: LIST
6878: LIST
6879: LIST
6880: LIST
6881: PUSH
6882: LD_INT 24
6884: PUSH
6885: LD_INT 1
6887: PUSH
6888: LD_INT 3
6890: PUSH
6891: LD_INT 46
6893: PUSH
6894: EMPTY
6895: LIST
6896: LIST
6897: LIST
6898: LIST
6899: PUSH
6900: LD_INT 24
6902: PUSH
6903: LD_INT 1
6905: PUSH
6906: LD_INT 3
6908: PUSH
6909: LD_INT 46
6911: PUSH
6912: EMPTY
6913: LIST
6914: LIST
6915: LIST
6916: LIST
6917: PUSH
6918: EMPTY
6919: LIST
6920: LIST
6921: LIST
6922: LIST
6923: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
6924: LD_ADDR_VAR 0 5
6928: PUSH
6929: LD_VAR 0 5
6933: PUSH
6934: LD_OWVAR 1
6938: PUSH
6939: LD_INT 21000
6941: DIV
6942: PLUS
6943: ST_TO_ADDR
// if amount > 8 then
6944: LD_VAR 0 5
6948: PUSH
6949: LD_INT 8
6951: GREATER
6952: IFFALSE 6962
// amount := 8 ;
6954: LD_ADDR_VAR 0 5
6958: PUSH
6959: LD_INT 8
6961: ST_TO_ADDR
// for i = 1 to amount do
6962: LD_ADDR_VAR 0 1
6966: PUSH
6967: DOUBLE
6968: LD_INT 1
6970: DEC
6971: ST_TO_ADDR
6972: LD_VAR 0 5
6976: PUSH
6977: FOR_TO
6978: IFFALSE 7043
// tmp := Insert ( tmp , tmp + 1 , [ ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
6980: LD_ADDR_VAR 0 3
6984: PUSH
6985: LD_VAR 0 3
6989: PPUSH
6990: LD_VAR 0 3
6994: PUSH
6995: LD_INT 1
6997: PLUS
6998: PPUSH
6999: LD_INT 24
7001: PUSH
7002: LD_INT 1
7004: PUSH
7005: LD_INT 3
7007: PUSH
7008: LD_INT 46
7010: PUSH
7011: LD_INT 45
7013: PUSH
7014: EMPTY
7015: LIST
7016: LIST
7017: PUSH
7018: LD_INT 1
7020: PPUSH
7021: LD_INT 2
7023: PPUSH
7024: CALL_OW 12
7028: ARRAY
7029: PUSH
7030: EMPTY
7031: LIST
7032: LIST
7033: LIST
7034: LIST
7035: PPUSH
7036: CALL_OW 2
7040: ST_TO_ADDR
7041: GO 6977
7043: POP
7044: POP
// MC_InsertProduceList ( base , tmp ) ;
7045: LD_VAR 0 2
7049: PPUSH
7050: LD_VAR 0 3
7054: PPUSH
7055: CALL 72528 0 2
// repeat wait ( 0 0$1 ) ;
7059: LD_INT 35
7061: PPUSH
7062: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
7066: LD_VAR 0 2
7070: PPUSH
7071: LD_INT 1
7073: PPUSH
7074: CALL 73946 0 2
7078: PUSH
7079: LD_VAR 0 5
7083: GREATEREQUAL
7084: IFFALSE 7059
// wait ( 0 0$30 ) ;
7086: LD_INT 1050
7088: PPUSH
7089: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
7093: LD_ADDR_VAR 0 4
7097: PUSH
7098: LD_EXP 42
7102: PUSH
7103: LD_VAR 0 2
7107: ARRAY
7108: PUSH
7109: LD_EXP 42
7113: PUSH
7114: LD_VAR 0 2
7118: ARRAY
7119: PPUSH
7120: LD_INT 2
7122: PUSH
7123: LD_INT 34
7125: PUSH
7126: LD_INT 51
7128: PUSH
7129: EMPTY
7130: LIST
7131: LIST
7132: PUSH
7133: LD_INT 34
7135: PUSH
7136: LD_INT 52
7138: PUSH
7139: EMPTY
7140: LIST
7141: LIST
7142: PUSH
7143: EMPTY
7144: LIST
7145: LIST
7146: LIST
7147: PPUSH
7148: CALL_OW 72
7152: DIFF
7153: ST_TO_ADDR
// if not attackers then
7154: LD_VAR 0 4
7158: NOT
7159: IFFALSE 7163
// exit ;
7161: GO 7386
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
7163: LD_ADDR_EXP 42
7167: PUSH
7168: LD_EXP 42
7172: PPUSH
7173: LD_VAR 0 2
7177: PPUSH
7178: LD_EXP 42
7182: PUSH
7183: LD_VAR 0 2
7187: ARRAY
7188: PUSH
7189: LD_VAR 0 4
7193: DIFF
7194: PPUSH
7195: CALL_OW 1
7199: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
7200: LD_VAR 0 4
7204: PPUSH
7205: LD_INT 107
7207: PPUSH
7208: LD_INT 74
7210: PPUSH
7211: CALL_OW 114
// wait ( 0 0$5 ) ;
7215: LD_INT 175
7217: PPUSH
7218: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
7222: LD_INT 35
7224: PPUSH
7225: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
7229: LD_VAR 0 4
7233: PPUSH
7234: LD_INT 60
7236: PUSH
7237: EMPTY
7238: LIST
7239: PPUSH
7240: CALL_OW 72
7244: NOT
7245: IFFALSE 7222
// if rand ( 0 , 1 ) then
7247: LD_INT 0
7249: PPUSH
7250: LD_INT 1
7252: PPUSH
7253: CALL_OW 12
7257: IFFALSE 7276
// ComAgressiveMove ( attackers , 155 , 108 ) else
7259: LD_VAR 0 4
7263: PPUSH
7264: LD_INT 155
7266: PPUSH
7267: LD_INT 108
7269: PPUSH
7270: CALL_OW 114
7274: GO 7291
// ComAgressiveMove ( attackers , 149 , 55 ) ;
7276: LD_VAR 0 4
7280: PPUSH
7281: LD_INT 149
7283: PPUSH
7284: LD_INT 55
7286: PPUSH
7287: CALL_OW 114
// wait ( 0 0$10 ) ;
7291: LD_INT 350
7293: PPUSH
7294: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
7298: LD_INT 35
7300: PPUSH
7301: CALL_OW 67
// for i in attackers do
7305: LD_ADDR_VAR 0 1
7309: PUSH
7310: LD_VAR 0 4
7314: PUSH
7315: FOR_IN
7316: IFFALSE 7366
// if not HasTask ( i ) then
7318: LD_VAR 0 1
7322: PPUSH
7323: CALL_OW 314
7327: NOT
7328: IFFALSE 7364
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
7330: LD_VAR 0 1
7334: PPUSH
7335: LD_INT 81
7337: PUSH
7338: LD_INT 3
7340: PUSH
7341: EMPTY
7342: LIST
7343: LIST
7344: PPUSH
7345: CALL_OW 69
7349: PPUSH
7350: LD_VAR 0 1
7354: PPUSH
7355: CALL_OW 74
7359: PPUSH
7360: CALL_OW 115
7364: GO 7315
7366: POP
7367: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
7368: LD_VAR 0 4
7372: PPUSH
7373: LD_INT 50
7375: PUSH
7376: EMPTY
7377: LIST
7378: PPUSH
7379: CALL_OW 72
7383: NOT
7384: IFFALSE 7298
// end ;
7386: PPOPN 5
7388: END
// every 12 12$00 + 10 10$00 trigger not ruDestroyed do var i , un , tmp , amount ;
7389: LD_EXP 5
7393: NOT
7394: IFFALSE 7981
7396: GO 7398
7398: DISABLE
7399: LD_INT 0
7401: PPUSH
7402: PPUSH
7403: PPUSH
7404: PPUSH
// begin enable ;
7405: ENABLE
// if Difficulty = 1 and tick < 30 30$00 then
7406: LD_OWVAR 67
7410: PUSH
7411: LD_INT 1
7413: EQUAL
7414: PUSH
7415: LD_OWVAR 1
7419: PUSH
7420: LD_INT 63000
7422: LESS
7423: AND
7424: IFFALSE 7428
// exit ;
7426: GO 7981
// tmp := [ ] ;
7428: LD_ADDR_VAR 0 3
7432: PUSH
7433: EMPTY
7434: ST_TO_ADDR
// if tick < 45 45$00 then
7435: LD_OWVAR 1
7439: PUSH
7440: LD_INT 94500
7442: LESS
7443: IFFALSE 7620
// begin for i := 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
7445: LD_ADDR_VAR 0 1
7449: PUSH
7450: DOUBLE
7451: LD_INT 1
7453: DEC
7454: ST_TO_ADDR
7455: LD_INT 2
7457: PUSH
7458: LD_INT 3
7460: PUSH
7461: LD_INT 4
7463: PUSH
7464: EMPTY
7465: LIST
7466: LIST
7467: LIST
7468: PUSH
7469: LD_OWVAR 67
7473: ARRAY
7474: PUSH
7475: FOR_TO
7476: IFFALSE 7618
// begin uc_side := 3 ;
7478: LD_ADDR_OWVAR 20
7482: PUSH
7483: LD_INT 3
7485: ST_TO_ADDR
// uc_nation := 3 ;
7486: LD_ADDR_OWVAR 21
7490: PUSH
7491: LD_INT 3
7493: ST_TO_ADDR
// InitHC_All ( ) ;
7494: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
7498: LD_INT 0
7500: PPUSH
7501: LD_INT 1
7503: PPUSH
7504: LD_INT 5
7506: PUSH
7507: LD_INT 6
7509: PUSH
7510: LD_INT 7
7512: PUSH
7513: EMPTY
7514: LIST
7515: LIST
7516: LIST
7517: PUSH
7518: LD_OWVAR 67
7522: ARRAY
7523: PPUSH
7524: CALL_OW 380
// un := CreateHuman ;
7528: LD_ADDR_VAR 0 2
7532: PUSH
7533: CALL_OW 44
7537: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
7538: LD_VAR 0 2
7542: PPUSH
7543: LD_INT 18
7545: PPUSH
7546: LD_INT 0
7548: PPUSH
7549: CALL_OW 49
// SetClass ( un , class_bazooker ) ;
7553: LD_VAR 0 2
7557: PPUSH
7558: LD_INT 9
7560: PPUSH
7561: CALL_OW 336
// ComMoveXY ( un , 147 , 161 ) ;
7565: LD_VAR 0 2
7569: PPUSH
7570: LD_INT 147
7572: PPUSH
7573: LD_INT 161
7575: PPUSH
7576: CALL_OW 111
// wait ( 0 0$2 ) ;
7580: LD_INT 70
7582: PPUSH
7583: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
7587: LD_ADDR_VAR 0 3
7591: PUSH
7592: LD_VAR 0 3
7596: PPUSH
7597: LD_VAR 0 3
7601: PUSH
7602: LD_INT 1
7604: PLUS
7605: PPUSH
7606: LD_VAR 0 2
7610: PPUSH
7611: CALL_OW 1
7615: ST_TO_ADDR
// end ;
7616: GO 7475
7618: POP
7619: POP
// end ; amount := [ 3 , 4 , 5 ] [ Difficulty ] + tick div 10 10$00 ;
7620: LD_ADDR_VAR 0 4
7624: PUSH
7625: LD_INT 3
7627: PUSH
7628: LD_INT 4
7630: PUSH
7631: LD_INT 5
7633: PUSH
7634: EMPTY
7635: LIST
7636: LIST
7637: LIST
7638: PUSH
7639: LD_OWVAR 67
7643: ARRAY
7644: PUSH
7645: LD_OWVAR 1
7649: PUSH
7650: LD_INT 21000
7652: DIV
7653: PLUS
7654: ST_TO_ADDR
// if amount > 15 then
7655: LD_VAR 0 4
7659: PUSH
7660: LD_INT 15
7662: GREATER
7663: IFFALSE 7673
// amount := 15 ;
7665: LD_ADDR_VAR 0 4
7669: PUSH
7670: LD_INT 15
7672: ST_TO_ADDR
// for i := 1 to amount do
7673: LD_ADDR_VAR 0 1
7677: PUSH
7678: DOUBLE
7679: LD_INT 1
7681: DEC
7682: ST_TO_ADDR
7683: LD_VAR 0 4
7687: PUSH
7688: FOR_TO
7689: IFFALSE 7835
// begin uc_side := 3 ;
7691: LD_ADDR_OWVAR 20
7695: PUSH
7696: LD_INT 3
7698: ST_TO_ADDR
// uc_nation := 3 ;
7699: LD_ADDR_OWVAR 21
7703: PUSH
7704: LD_INT 3
7706: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 5 ) ] , 90 ) ;
7707: LD_INT 24
7709: PPUSH
7710: LD_INT 1
7712: PPUSH
7713: LD_INT 3
7715: PPUSH
7716: LD_INT 46
7718: PUSH
7719: LD_INT 45
7721: PUSH
7722: LD_INT 44
7724: PUSH
7725: LD_INT 43
7727: PUSH
7728: LD_INT 42
7730: PUSH
7731: EMPTY
7732: LIST
7733: LIST
7734: LIST
7735: LIST
7736: LIST
7737: PUSH
7738: LD_INT 1
7740: PPUSH
7741: LD_INT 5
7743: PPUSH
7744: CALL_OW 12
7748: ARRAY
7749: PPUSH
7750: LD_INT 90
7752: PPUSH
7753: CALL 14793 0 5
// un := CreateVehicle ;
7757: LD_ADDR_VAR 0 2
7761: PUSH
7762: CALL_OW 45
7766: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
7767: LD_VAR 0 2
7771: PPUSH
7772: LD_INT 18
7774: PPUSH
7775: LD_INT 0
7777: PPUSH
7778: CALL_OW 49
// ComMoveXY ( un , 147 , 161 ) ;
7782: LD_VAR 0 2
7786: PPUSH
7787: LD_INT 147
7789: PPUSH
7790: LD_INT 161
7792: PPUSH
7793: CALL_OW 111
// wait ( 0 0$3 ) ;
7797: LD_INT 105
7799: PPUSH
7800: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
7804: LD_ADDR_VAR 0 3
7808: PUSH
7809: LD_VAR 0 3
7813: PPUSH
7814: LD_VAR 0 3
7818: PUSH
7819: LD_INT 1
7821: PLUS
7822: PPUSH
7823: LD_VAR 0 2
7827: PPUSH
7828: CALL_OW 1
7832: ST_TO_ADDR
// end ;
7833: GO 7688
7835: POP
7836: POP
// if not tmp then
7837: LD_VAR 0 3
7841: NOT
7842: IFFALSE 7846
// exit ;
7844: GO 7981
// wait ( 0 0$5 ) ;
7846: LD_INT 175
7848: PPUSH
7849: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
7853: LD_INT 70
7855: PPUSH
7856: CALL_OW 67
// for i in tmp do
7860: LD_ADDR_VAR 0 1
7864: PUSH
7865: LD_VAR 0 3
7869: PUSH
7870: FOR_IN
7871: IFFALSE 7972
// begin if not IsOk ( i ) or IsDead ( i ) then
7873: LD_VAR 0 1
7877: PPUSH
7878: CALL_OW 302
7882: NOT
7883: PUSH
7884: LD_VAR 0 1
7888: PPUSH
7889: CALL_OW 301
7893: OR
7894: IFFALSE 7912
// tmp := tmp diff i ;
7896: LD_ADDR_VAR 0 3
7900: PUSH
7901: LD_VAR 0 3
7905: PUSH
7906: LD_VAR 0 1
7910: DIFF
7911: ST_TO_ADDR
// if GetClass ( i ) = class_bazooker then
7912: LD_VAR 0 1
7916: PPUSH
7917: CALL_OW 257
7921: PUSH
7922: LD_INT 9
7924: EQUAL
7925: IFFALSE 7936
// ComSpaceTimeShoot ( i ) ;
7927: LD_VAR 0 1
7931: PPUSH
7932: CALL 10876 0 1
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
7936: LD_VAR 0 1
7940: PPUSH
7941: LD_INT 81
7943: PUSH
7944: LD_INT 3
7946: PUSH
7947: EMPTY
7948: LIST
7949: LIST
7950: PPUSH
7951: CALL_OW 69
7955: PPUSH
7956: LD_VAR 0 1
7960: PPUSH
7961: CALL_OW 74
7965: PPUSH
7966: CALL_OW 115
// end ;
7970: GO 7870
7972: POP
7973: POP
// until not tmp ;
7974: LD_VAR 0 3
7978: NOT
7979: IFFALSE 7853
// end ; end_of_file
7981: PPOPN 4
7983: END
// export Sikorski ; export function PrepareSikorski ; var i , j , un ; begin
7984: LD_INT 0
7986: PPUSH
7987: PPUSH
7988: PPUSH
7989: PPUSH
// uc_side := 1 ;
7990: LD_ADDR_OWVAR 20
7994: PUSH
7995: LD_INT 1
7997: ST_TO_ADDR
// uc_nation := 1 ;
7998: LD_ADDR_OWVAR 21
8002: PUSH
8003: LD_INT 1
8005: ST_TO_ADDR
// hc_importance := 100 ;
8006: LD_ADDR_OWVAR 32
8010: PUSH
8011: LD_INT 100
8013: ST_TO_ADDR
// hc_name := Jeremy Sikorski ;
8014: LD_ADDR_OWVAR 26
8018: PUSH
8019: LD_STRING Jeremy Sikorski
8021: ST_TO_ADDR
// hc_gallery := us ;
8022: LD_ADDR_OWVAR 33
8026: PUSH
8027: LD_STRING us
8029: ST_TO_ADDR
// hc_face_number := 19 ;
8030: LD_ADDR_OWVAR 34
8034: PUSH
8035: LD_INT 19
8037: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , [ 4 , 4 , 3 ] [ Difficulty ] ) ;
8038: LD_INT 1
8040: PPUSH
8041: LD_INT 1
8043: PPUSH
8044: LD_INT 4
8046: PUSH
8047: LD_INT 4
8049: PUSH
8050: LD_INT 3
8052: PUSH
8053: EMPTY
8054: LIST
8055: LIST
8056: LIST
8057: PUSH
8058: LD_OWVAR 67
8062: ARRAY
8063: PPUSH
8064: CALL_OW 380
// hc_attr := [ 10 , 12 ] ;
8068: LD_ADDR_OWVAR 29
8072: PUSH
8073: LD_INT 10
8075: PUSH
8076: LD_INT 12
8078: PUSH
8079: EMPTY
8080: LIST
8081: LIST
8082: ST_TO_ADDR
// Sikorski := CreateHuman ;
8083: LD_ADDR_EXP 20
8087: PUSH
8088: CALL_OW 44
8092: ST_TO_ADDR
// PlaceUnitXYR ( Sikorski , 133 , 19 , 2 , false ) ;
8093: LD_EXP 20
8097: PPUSH
8098: LD_INT 133
8100: PPUSH
8101: LD_INT 19
8103: PPUSH
8104: LD_INT 2
8106: PPUSH
8107: LD_INT 0
8109: PPUSH
8110: CALL_OW 50
// InitHc_All ( ) ;
8114: CALL_OW 584
// for i := 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
8118: LD_ADDR_VAR 0 2
8122: PUSH
8123: DOUBLE
8124: LD_INT 1
8126: DEC
8127: ST_TO_ADDR
8128: LD_INT 4
8130: PUSH
8131: LD_INT 3
8133: PUSH
8134: LD_INT 3
8136: PUSH
8137: EMPTY
8138: LIST
8139: LIST
8140: LIST
8141: PUSH
8142: LD_OWVAR 67
8146: ARRAY
8147: PUSH
8148: FOR_TO
8149: IFFALSE 8265
// for j := 1 to 4 do
8151: LD_ADDR_VAR 0 3
8155: PUSH
8156: DOUBLE
8157: LD_INT 1
8159: DEC
8160: ST_TO_ADDR
8161: LD_INT 4
8163: PUSH
8164: FOR_TO
8165: IFFALSE 8261
// begin PrepareHuman ( false , j , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
8167: LD_INT 0
8169: PPUSH
8170: LD_VAR 0 3
8174: PPUSH
8175: LD_INT 5
8177: PUSH
8178: LD_INT 4
8180: PUSH
8181: LD_INT 3
8183: PUSH
8184: EMPTY
8185: LIST
8186: LIST
8187: LIST
8188: PUSH
8189: LD_OWVAR 67
8193: ARRAY
8194: PPUSH
8195: CALL_OW 380
// un := CreateHuman ;
8199: LD_ADDR_VAR 0 4
8203: PUSH
8204: CALL_OW 44
8208: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
8209: LD_VAR 0 4
8213: PPUSH
8214: LD_INT 0
8216: PPUSH
8217: LD_INT 5
8219: PPUSH
8220: CALL_OW 12
8224: PPUSH
8225: CALL_OW 233
// PlaceUnitXYR ( un , 133 , 19 , 6 , false ) ;
8229: LD_VAR 0 4
8233: PPUSH
8234: LD_INT 133
8236: PPUSH
8237: LD_INT 19
8239: PPUSH
8240: LD_INT 6
8242: PPUSH
8243: LD_INT 0
8245: PPUSH
8246: CALL_OW 50
// ComHold ( un ) ;
8250: LD_VAR 0 4
8254: PPUSH
8255: CALL_OW 140
// end ;
8259: GO 8164
8261: POP
8262: POP
8263: GO 8148
8265: POP
8266: POP
// vc_chassis := us_heavy_tracked ;
8267: LD_ADDR_OWVAR 37
8271: PUSH
8272: LD_INT 4
8274: ST_TO_ADDR
// vc_engine := engine_combustion ;
8275: LD_ADDR_OWVAR 39
8279: PUSH
8280: LD_INT 1
8282: ST_TO_ADDR
// vc_control := control_manual ;
8283: LD_ADDR_OWVAR 38
8287: PUSH
8288: LD_INT 1
8290: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
8291: LD_ADDR_OWVAR 40
8295: PUSH
8296: LD_INT 14
8298: ST_TO_ADDR
// vc_fuel_battery := 60 ;
8299: LD_ADDR_OWVAR 41
8303: PUSH
8304: LD_INT 60
8306: ST_TO_ADDR
// un := CreateVehicle ;
8307: LD_ADDR_VAR 0 4
8311: PUSH
8312: CALL_OW 45
8316: ST_TO_ADDR
// SetDir ( un , 2 ) ;
8317: LD_VAR 0 4
8321: PPUSH
8322: LD_INT 2
8324: PPUSH
8325: CALL_OW 233
// PlaceUnitXY ( un , 128 , 12 , false ) ;
8329: LD_VAR 0 4
8333: PPUSH
8334: LD_INT 128
8336: PPUSH
8337: LD_INT 12
8339: PPUSH
8340: LD_INT 0
8342: PPUSH
8343: CALL_OW 48
// for i := 1 to 3 do
8347: LD_ADDR_VAR 0 2
8351: PUSH
8352: DOUBLE
8353: LD_INT 1
8355: DEC
8356: ST_TO_ADDR
8357: LD_INT 3
8359: PUSH
8360: FOR_TO
8361: IFFALSE 8384
// CreateCratesXYR ( 5 , 133 , 19 , 3 , false ) ;
8363: LD_INT 5
8365: PPUSH
8366: LD_INT 133
8368: PPUSH
8369: LD_INT 19
8371: PPUSH
8372: LD_INT 3
8374: PPUSH
8375: LD_INT 0
8377: PPUSH
8378: CALL_OW 56
8382: GO 8360
8384: POP
8385: POP
// end ; end_of_file
8386: LD_VAR 0 1
8390: RET
// export function Action ; begin
8391: LD_INT 0
8393: PPUSH
// InGameOn ;
8394: CALL_OW 8
// CenterNowOnXY ( 133 , 19 ) ;
8398: LD_INT 133
8400: PPUSH
8401: LD_INT 19
8403: PPUSH
8404: CALL_OW 86
// Say ( Sikorski , WT-DS-1 ) ;
8408: LD_EXP 20
8412: PPUSH
8413: LD_STRING WT-DS-1
8415: PPUSH
8416: CALL_OW 88
// InGameOff ;
8420: CALL_OW 9
// ChangeMissionObjectives ( DestroyEnemy ) ;
8424: LD_STRING DestroyEnemy
8426: PPUSH
8427: CALL_OW 337
// wait ( 0 0$20 ) ;
8431: LD_INT 700
8433: PPUSH
8434: CALL_OW 67
// DialogueOn ;
8438: CALL_OW 6
// PlaceSeeing ( 100 , 37 , 1 , - 30 ) ;
8442: LD_INT 100
8444: PPUSH
8445: LD_INT 37
8447: PPUSH
8448: LD_INT 1
8450: PPUSH
8451: LD_INT 30
8453: NEG
8454: PPUSH
8455: CALL_OW 330
// CenterNowOnXY ( 100 , 37 ) ;
8459: LD_INT 100
8461: PPUSH
8462: LD_INT 37
8464: PPUSH
8465: CALL_OW 86
// SayRadio ( Powell , WT-PL-1 ) ;
8469: LD_EXP 10
8473: PPUSH
8474: LD_STRING WT-PL-1
8476: PPUSH
8477: CALL_OW 94
// Say ( Sikorski , WT-DS-2 ) ;
8481: LD_EXP 20
8485: PPUSH
8486: LD_STRING WT-DS-2
8488: PPUSH
8489: CALL_OW 88
// DialogueOff ;
8493: CALL_OW 7
// wait ( 0 0$2 ) ;
8497: LD_INT 70
8499: PPUSH
8500: CALL_OW 67
// RemoveSeeing ( 100 , 37 , 1 ) ;
8504: LD_INT 100
8506: PPUSH
8507: LD_INT 37
8509: PPUSH
8510: LD_INT 1
8512: PPUSH
8513: CALL_OW 331
// end ;
8517: LD_VAR 0 1
8521: RET
// export function DialogPowellsAttack ; begin
8522: LD_INT 0
8524: PPUSH
// SayRadio ( Powell , WT-PL-8 ) ;
8525: LD_EXP 10
8529: PPUSH
8530: LD_STRING WT-PL-8
8532: PPUSH
8533: CALL_OW 94
// end ;
8537: LD_VAR 0 1
8541: RET
// export function DialogContaminateSib ( x , y ) ; begin
8542: LD_INT 0
8544: PPUSH
// DialogueOn ;
8545: CALL_OW 6
// CenterNowOnXY ( x , y ) ;
8549: LD_VAR 0 1
8553: PPUSH
8554: LD_VAR 0 2
8558: PPUSH
8559: CALL_OW 86
// Say ( Sikorski , WT-DS-3 ) ;
8563: LD_EXP 20
8567: PPUSH
8568: LD_STRING WT-DS-3
8570: PPUSH
8571: CALL_OW 88
// DialogueOff ;
8575: CALL_OW 7
// end ;
8579: LD_VAR 0 3
8583: RET
// every 0 0$3 trigger not powellInTrouble and FilterUnitsInArea ( powell_base , [ f_enemy , 4 ] ) > 3 do
8584: LD_EXP 8
8588: NOT
8589: PUSH
8590: LD_INT 1
8592: PPUSH
8593: LD_INT 81
8595: PUSH
8596: LD_INT 4
8598: PUSH
8599: EMPTY
8600: LIST
8601: LIST
8602: PPUSH
8603: CALL_OW 70
8607: PUSH
8608: LD_INT 3
8610: GREATER
8611: AND
8612: IFFALSE 8684
8614: GO 8616
8616: DISABLE
// begin powellInTrouble := true ;
8617: LD_ADDR_EXP 8
8621: PUSH
8622: LD_INT 1
8624: ST_TO_ADDR
// Say ( Sikorski , WT-DS-6 ) ;
8625: LD_EXP 20
8629: PPUSH
8630: LD_STRING WT-DS-6
8632: PPUSH
8633: CALL_OW 88
// if not FilterUnitsInArea ( powell_base , [ f_side , 1 ] ) then
8637: LD_INT 1
8639: PPUSH
8640: LD_INT 22
8642: PUSH
8643: LD_INT 1
8645: PUSH
8646: EMPTY
8647: LIST
8648: LIST
8649: PPUSH
8650: CALL_OW 70
8654: NOT
8655: IFFALSE 8669
// SayRadio ( Powell , WT-PL-6 ) ;
8657: LD_EXP 10
8661: PPUSH
8662: LD_STRING WT-PL-6
8664: PPUSH
8665: CALL_OW 94
// wait ( 1 1$30 ) ;
8669: LD_INT 3150
8671: PPUSH
8672: CALL_OW 67
// powellInTrouble := false ;
8676: LD_ADDR_EXP 8
8680: PUSH
8681: LD_INT 0
8683: ST_TO_ADDR
// end ;
8684: END
// every 0 0$3 trigger not sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 1 ] ) > 6 do
8685: LD_EXP 9
8689: NOT
8690: PUSH
8691: LD_INT 16
8693: PPUSH
8694: LD_INT 81
8696: PUSH
8697: LD_INT 1
8699: PUSH
8700: EMPTY
8701: LIST
8702: LIST
8703: PPUSH
8704: CALL_OW 70
8708: PUSH
8709: LD_INT 6
8711: GREATER
8712: AND
8713: IFFALSE 8786
8715: GO 8717
8717: DISABLE
// begin sikorskiInTrouble := true ;
8718: LD_ADDR_EXP 9
8722: PUSH
8723: LD_INT 1
8725: ST_TO_ADDR
// Say ( Sikorski , WT-DS-7 ) ;
8726: LD_EXP 20
8730: PPUSH
8731: LD_STRING WT-DS-7
8733: PPUSH
8734: CALL_OW 88
// if not powellAttackGroup then
8738: LD_EXP 12
8742: NOT
8743: IFFALSE 8759
// SayRadio ( Powell , WT-PL-7n ) else
8745: LD_EXP 10
8749: PPUSH
8750: LD_STRING WT-PL-7n
8752: PPUSH
8753: CALL_OW 94
8757: GO 8771
// SayRadio ( Powell , WT-PL-7y ) ;
8759: LD_EXP 10
8763: PPUSH
8764: LD_STRING WT-PL-7y
8766: PPUSH
8767: CALL_OW 94
// wait ( 1 1$30 ) ;
8771: LD_INT 3150
8773: PPUSH
8774: CALL_OW 67
// sikorskiInTrouble := false ;
8778: LD_ADDR_EXP 9
8782: PUSH
8783: LD_INT 0
8785: ST_TO_ADDR
// end ;
8786: END
// export function DialogPowellsAttackFailed ; begin
8787: LD_INT 0
8789: PPUSH
// if not ruDestroyed then
8790: LD_EXP 5
8794: NOT
8795: IFFALSE 8811
// SayRadio ( Powell , WT-PL-9 ) else
8797: LD_EXP 10
8801: PPUSH
8802: LD_STRING WT-PL-9
8804: PPUSH
8805: CALL_OW 94
8809: GO 8823
// SayRadio ( Powell , WT-PL-10 ) ;
8811: LD_EXP 10
8815: PPUSH
8816: LD_STRING WT-PL-10
8818: PPUSH
8819: CALL_OW 94
// end ;
8823: LD_VAR 0 1
8827: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
8828: LD_INT 22
8830: PUSH
8831: LD_INT 2
8833: PUSH
8834: EMPTY
8835: LIST
8836: LIST
8837: PUSH
8838: LD_INT 21
8840: PUSH
8841: LD_INT 1
8843: PUSH
8844: EMPTY
8845: LIST
8846: LIST
8847: PUSH
8848: EMPTY
8849: LIST
8850: LIST
8851: PPUSH
8852: CALL_OW 69
8856: PUSH
8857: LD_INT 0
8859: EQUAL
8860: IFFALSE 8904
8862: GO 8864
8864: DISABLE
// begin arDestroyed := true ;
8865: LD_ADDR_EXP 4
8869: PUSH
8870: LD_INT 1
8872: ST_TO_ADDR
// MC_Kill ( 2 ) ;
8873: LD_INT 2
8875: PPUSH
8876: CALL 48766 0 1
// Say ( Sikorski , WT-DS-4 ) ;
8880: LD_EXP 20
8884: PPUSH
8885: LD_STRING WT-DS-4
8887: PPUSH
8888: CALL_OW 88
// SayRadio ( Powell , WT-PL-4 ) ;
8892: LD_EXP 10
8896: PPUSH
8897: LD_STRING WT-PL-4
8899: PPUSH
8900: CALL_OW 94
// end ;
8904: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
8905: LD_INT 22
8907: PUSH
8908: LD_INT 3
8910: PUSH
8911: EMPTY
8912: LIST
8913: LIST
8914: PUSH
8915: LD_INT 21
8917: PUSH
8918: LD_INT 1
8920: PUSH
8921: EMPTY
8922: LIST
8923: LIST
8924: PUSH
8925: EMPTY
8926: LIST
8927: LIST
8928: PPUSH
8929: CALL_OW 69
8933: PUSH
8934: LD_INT 0
8936: EQUAL
8937: IFFALSE 8981
8939: GO 8941
8941: DISABLE
// begin ruDestroyed := true ;
8942: LD_ADDR_EXP 5
8946: PUSH
8947: LD_INT 1
8949: ST_TO_ADDR
// MC_Kill ( 3 ) ;
8950: LD_INT 3
8952: PPUSH
8953: CALL 48766 0 1
// Say ( Sikorski , WT-DS-5 ) ;
8957: LD_EXP 20
8961: PPUSH
8962: LD_STRING WT-DS-5
8964: PPUSH
8965: CALL_OW 88
// SayRadio ( Powell , WT-PL-5 ) ;
8969: LD_EXP 10
8973: PPUSH
8974: LD_STRING WT-PL-5
8976: PPUSH
8977: CALL_OW 94
// end ;
8981: END
// every 0 0$1 trigger ruDestroyed and arDestroyed do
8982: LD_EXP 5
8986: PUSH
8987: LD_EXP 4
8991: AND
8992: IFFALSE 9165
8994: GO 8996
8996: DISABLE
// begin wait ( 0 0$3 ) ;
8997: LD_INT 105
8999: PPUSH
9000: CALL_OW 67
// if tick >= [ 60 60$00 , 50 50$00 , 45 45$00 ] [ Difficulty ] then
9004: LD_OWVAR 1
9008: PUSH
9009: LD_INT 126000
9011: PUSH
9012: LD_INT 105000
9014: PUSH
9015: LD_INT 94500
9017: PUSH
9018: EMPTY
9019: LIST
9020: LIST
9021: LIST
9022: PUSH
9023: LD_OWVAR 67
9027: ARRAY
9028: GREATEREQUAL
9029: IFFALSE 9044
// AddMedal ( WoT-med-1 , - 1 ) else
9031: LD_STRING WoT-med-1
9033: PPUSH
9034: LD_INT 1
9036: NEG
9037: PPUSH
9038: CALL_OW 101
9042: GO 9054
// AddMedal ( WoT-med-1 , 1 ) ;
9044: LD_STRING WoT-med-1
9046: PPUSH
9047: LD_INT 1
9049: PPUSH
9050: CALL_OW 101
// if loseCounter >= [ 4 , 3 , 2 ] [ Difficulty ] then
9054: LD_EXP 6
9058: PUSH
9059: LD_INT 4
9061: PUSH
9062: LD_INT 3
9064: PUSH
9065: LD_INT 2
9067: PUSH
9068: EMPTY
9069: LIST
9070: LIST
9071: LIST
9072: PUSH
9073: LD_OWVAR 67
9077: ARRAY
9078: GREATEREQUAL
9079: IFFALSE 9094
// AddMedal ( WoT-med-2 , - 1 ) else
9081: LD_STRING WoT-med-2
9083: PPUSH
9084: LD_INT 1
9086: NEG
9087: PPUSH
9088: CALL_OW 101
9092: GO 9104
// AddMedal ( WoT-med-2 , 1 ) ;
9094: LD_STRING WoT-med-2
9096: PPUSH
9097: LD_INT 1
9099: PPUSH
9100: CALL_OW 101
// if powellLoseCounter >= [ 8 , 6 , 5 ] [ Difficulty ] then
9104: LD_EXP 7
9108: PUSH
9109: LD_INT 8
9111: PUSH
9112: LD_INT 6
9114: PUSH
9115: LD_INT 5
9117: PUSH
9118: EMPTY
9119: LIST
9120: LIST
9121: LIST
9122: PUSH
9123: LD_OWVAR 67
9127: ARRAY
9128: GREATEREQUAL
9129: IFFALSE 9144
// AddMedal ( WoT-med-3 , - 1 ) else
9131: LD_STRING WoT-med-3
9133: PPUSH
9134: LD_INT 1
9136: NEG
9137: PPUSH
9138: CALL_OW 101
9142: GO 9154
// AddMedal ( WoT-med-3 , 1 ) ;
9144: LD_STRING WoT-med-3
9146: PPUSH
9147: LD_INT 1
9149: PPUSH
9150: CALL_OW 101
// GiveMedals ( MAIN ) ;
9154: LD_STRING MAIN
9156: PPUSH
9157: CALL_OW 102
// YouWin ;
9161: CALL_OW 103
// end ; end_of_file
9165: END
// export function CustomEvent ( event ) ; begin
9166: LD_INT 0
9168: PPUSH
// end ;
9169: LD_VAR 0 2
9173: RET
// on Command ( com ) do var i , j , temp ;
9174: LD_INT 0
9176: PPUSH
9177: PPUSH
9178: PPUSH
// begin if com = 60 then
9179: LD_VAR 0 1
9183: PUSH
9184: LD_INT 60
9186: EQUAL
9187: IFFALSE 9366
// begin for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_weapon , us_cargo_bay ] ] ] ) do
9189: LD_ADDR_VAR 0 2
9193: PUSH
9194: LD_INT 22
9196: PUSH
9197: LD_INT 1
9199: PUSH
9200: EMPTY
9201: LIST
9202: LIST
9203: PUSH
9204: LD_INT 2
9206: PUSH
9207: LD_INT 21
9209: PUSH
9210: LD_INT 1
9212: PUSH
9213: EMPTY
9214: LIST
9215: LIST
9216: PUSH
9217: LD_INT 34
9219: PUSH
9220: LD_INT 12
9222: PUSH
9223: EMPTY
9224: LIST
9225: LIST
9226: PUSH
9227: EMPTY
9228: LIST
9229: LIST
9230: LIST
9231: PUSH
9232: EMPTY
9233: LIST
9234: LIST
9235: PPUSH
9236: CALL_OW 69
9240: PUSH
9241: FOR_IN
9242: IFFALSE 9364
// begin if GetTaskList ( i ) > 0 then
9244: LD_VAR 0 2
9248: PPUSH
9249: CALL_OW 437
9253: PUSH
9254: LD_INT 0
9256: GREATER
9257: IFFALSE 9362
// for j = 1 to GetTaskList ( i ) do
9259: LD_ADDR_VAR 0 3
9263: PUSH
9264: DOUBLE
9265: LD_INT 1
9267: DEC
9268: ST_TO_ADDR
9269: LD_VAR 0 2
9273: PPUSH
9274: CALL_OW 437
9278: PUSH
9279: FOR_TO
9280: IFFALSE 9360
// begin temp = GetTaskList ( i ) [ j ] [ 4 ] ;
9282: LD_ADDR_VAR 0 4
9286: PUSH
9287: LD_VAR 0 2
9291: PPUSH
9292: CALL_OW 437
9296: PUSH
9297: LD_VAR 0 3
9301: ARRAY
9302: PUSH
9303: LD_INT 4
9305: ARRAY
9306: ST_TO_ADDR
// if GetSide ( temp ) = 4 and GetTaskList ( i ) [ j ] [ 1 ] = < then
9307: LD_VAR 0 4
9311: PPUSH
9312: CALL_OW 255
9316: PUSH
9317: LD_INT 4
9319: EQUAL
9320: PUSH
9321: LD_VAR 0 2
9325: PPUSH
9326: CALL_OW 437
9330: PUSH
9331: LD_VAR 0 3
9335: ARRAY
9336: PUSH
9337: LD_INT 1
9339: ARRAY
9340: PUSH
9341: LD_STRING <
9343: EQUAL
9344: AND
9345: IFFALSE 9358
// SetTaskList ( i , [ ] ) ;
9347: LD_VAR 0 2
9351: PPUSH
9352: EMPTY
9353: PPUSH
9354: CALL_OW 446
// end ;
9358: GO 9279
9360: POP
9361: POP
// end ;
9362: GO 9241
9364: POP
9365: POP
// end ; end ;
9366: PPOPN 4
9368: END
// on SibDepositContaminated ( sci , x , y ) do begin if GetSide ( HexInfo ( x , y ) ) = 1 or ( x = 132 and y = 39 ) then
9369: LD_VAR 0 2
9373: PPUSH
9374: LD_VAR 0 3
9378: PPUSH
9379: CALL_OW 428
9383: PPUSH
9384: CALL_OW 255
9388: PUSH
9389: LD_INT 1
9391: EQUAL
9392: PUSH
9393: LD_VAR 0 2
9397: PUSH
9398: LD_INT 132
9400: EQUAL
9401: PUSH
9402: LD_VAR 0 3
9406: PUSH
9407: LD_INT 39
9409: EQUAL
9410: AND
9411: OR
9412: IFFALSE 9428
// DialogContaminateSib ( x , y ) ;
9414: LD_VAR 0 2
9418: PPUSH
9419: LD_VAR 0 3
9423: PPUSH
9424: CALL 8542 0 2
// end ;
9428: PPOPN 3
9430: END
// on UnitDestroyed ( un ) do begin MCE_UnitDestroyed ( un ) ;
9431: LD_VAR 0 1
9435: PPUSH
9436: CALL 75948 0 1
// if un = Powell then
9440: LD_VAR 0 1
9444: PUSH
9445: LD_EXP 10
9449: EQUAL
9450: IFFALSE 9459
// YouLost ( Powell ) ;
9452: LD_STRING Powell
9454: PPUSH
9455: CALL_OW 104
// if un = Sikorski then
9459: LD_VAR 0 1
9463: PUSH
9464: LD_EXP 20
9468: EQUAL
9469: IFFALSE 9478
// YouLost ( Sikorski ) ;
9471: LD_STRING Sikorski
9473: PPUSH
9474: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) then
9478: LD_VAR 0 1
9482: PUSH
9483: LD_INT 22
9485: PUSH
9486: LD_INT 1
9488: PUSH
9489: EMPTY
9490: LIST
9491: LIST
9492: PUSH
9493: LD_INT 21
9495: PUSH
9496: LD_INT 1
9498: PUSH
9499: EMPTY
9500: LIST
9501: LIST
9502: PUSH
9503: EMPTY
9504: LIST
9505: LIST
9506: PPUSH
9507: CALL_OW 69
9511: IN
9512: IFFALSE 9528
// loseCounter := loseCounter + 1 ;
9514: LD_ADDR_EXP 6
9518: PUSH
9519: LD_EXP 6
9523: PUSH
9524: LD_INT 1
9526: PLUS
9527: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) then
9528: LD_VAR 0 1
9532: PUSH
9533: LD_INT 22
9535: PUSH
9536: LD_INT 4
9538: PUSH
9539: EMPTY
9540: LIST
9541: LIST
9542: PUSH
9543: LD_INT 21
9545: PUSH
9546: LD_INT 1
9548: PUSH
9549: EMPTY
9550: LIST
9551: LIST
9552: PUSH
9553: EMPTY
9554: LIST
9555: LIST
9556: PPUSH
9557: CALL_OW 69
9561: IN
9562: IFFALSE 9578
// powellLoseCounter := powellLoseCounter + 1 ;
9564: LD_ADDR_EXP 7
9568: PUSH
9569: LD_EXP 7
9573: PUSH
9574: LD_INT 1
9576: PLUS
9577: ST_TO_ADDR
// if un in powellAttackGroup then
9578: LD_VAR 0 1
9582: PUSH
9583: LD_EXP 12
9587: IN
9588: IFFALSE 9606
// powellAttackGroup := powellAttackGroup diff un ;
9590: LD_ADDR_EXP 12
9594: PUSH
9595: LD_EXP 12
9599: PUSH
9600: LD_VAR 0 1
9604: DIFF
9605: ST_TO_ADDR
// if un in gensherAttackGroup then
9606: LD_VAR 0 1
9610: PUSH
9611: LD_EXP 15
9615: IN
9616: IFFALSE 9634
// gensherAttackGroup := gensherAttackGroup diff un ;
9618: LD_ADDR_EXP 15
9622: PUSH
9623: LD_EXP 15
9627: PUSH
9628: LD_VAR 0 1
9632: DIFF
9633: ST_TO_ADDR
// if un in popovAttackGroup then
9634: LD_VAR 0 1
9638: PUSH
9639: LD_EXP 19
9643: IN
9644: IFFALSE 9662
// popovAttackGroup := popovAttackGroup diff un ;
9646: LD_ADDR_EXP 19
9650: PUSH
9651: LD_EXP 19
9655: PUSH
9656: LD_VAR 0 1
9660: DIFF
9661: ST_TO_ADDR
// end ;
9662: PPOPN 1
9664: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
9665: LD_VAR 0 1
9669: PPUSH
9670: LD_VAR 0 2
9674: PPUSH
9675: CALL 78282 0 2
// end ;
9679: PPOPN 2
9681: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
9682: LD_VAR 0 1
9686: PPUSH
9687: CALL 77350 0 1
// end ;
9691: PPOPN 1
9693: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
9694: LD_VAR 0 1
9698: PPUSH
9699: CALL 77591 0 1
// end ;
9703: PPOPN 1
9705: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
9706: LD_VAR 0 1
9710: PPUSH
9711: LD_VAR 0 2
9715: PPUSH
9716: CALL 75644 0 2
// end ;
9720: PPOPN 2
9722: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
9723: LD_VAR 0 1
9727: PPUSH
9728: LD_VAR 0 2
9732: PPUSH
9733: LD_VAR 0 3
9737: PPUSH
9738: LD_VAR 0 4
9742: PPUSH
9743: LD_VAR 0 5
9747: PPUSH
9748: CALL 75264 0 5
// end ;
9752: PPOPN 5
9754: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
9755: LD_VAR 0 1
9759: PPUSH
9760: LD_VAR 0 2
9764: PPUSH
9765: CALL 74845 0 2
// end ;
9769: PPOPN 2
9771: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
9772: LD_VAR 0 1
9776: PPUSH
9777: LD_VAR 0 2
9781: PPUSH
9782: LD_VAR 0 3
9786: PPUSH
9787: LD_VAR 0 4
9791: PPUSH
9792: CALL 74683 0 4
// end ;
9796: PPOPN 4
9798: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
9799: LD_VAR 0 1
9803: PPUSH
9804: LD_VAR 0 2
9808: PPUSH
9809: LD_VAR 0 3
9813: PPUSH
9814: CALL 74458 0 3
// end ;
9818: PPOPN 3
9820: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
9821: LD_VAR 0 1
9825: PPUSH
9826: LD_VAR 0 2
9830: PPUSH
9831: CALL 74343 0 2
// end ;
9835: PPOPN 2
9837: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
9838: LD_VAR 0 1
9842: PPUSH
9843: LD_VAR 0 2
9847: PPUSH
9848: CALL 78577 0 2
// end ;
9852: PPOPN 2
9854: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
9855: LD_VAR 0 1
9859: PPUSH
9860: LD_VAR 0 2
9864: PPUSH
9865: LD_VAR 0 3
9869: PPUSH
9870: LD_VAR 0 4
9874: PPUSH
9875: CALL 78793 0 4
// end ;
9879: PPOPN 4
9881: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
9882: LD_VAR 0 1
9886: PPUSH
9887: LD_VAR 0 2
9891: PPUSH
9892: CALL 74152 0 2
// end ;
9896: PPOPN 2
9898: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 then
9899: LD_VAR 0 1
9903: PUSH
9904: LD_INT 1
9906: EQUAL
9907: PUSH
9908: LD_VAR 0 2
9912: PUSH
9913: LD_INT 4
9915: EQUAL
9916: AND
9917: IFFALSE 9926
// YouLost ( FriendlyFire ) ;
9919: LD_STRING FriendlyFire
9921: PPUSH
9922: CALL_OW 104
// end ; end_of_file
9926: PPOPN 2
9928: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
9929: LD_INT 0
9931: PPUSH
9932: PPUSH
// if exist_mode then
9933: LD_VAR 0 2
9937: IFFALSE 9962
// unit := CreateCharacter ( prefix & ident ) else
9939: LD_ADDR_VAR 0 5
9943: PUSH
9944: LD_VAR 0 3
9948: PUSH
9949: LD_VAR 0 1
9953: STR
9954: PPUSH
9955: CALL_OW 34
9959: ST_TO_ADDR
9960: GO 9977
// unit := NewCharacter ( ident ) ;
9962: LD_ADDR_VAR 0 5
9966: PUSH
9967: LD_VAR 0 1
9971: PPUSH
9972: CALL_OW 25
9976: ST_TO_ADDR
// result := unit ;
9977: LD_ADDR_VAR 0 4
9981: PUSH
9982: LD_VAR 0 5
9986: ST_TO_ADDR
// end ;
9987: LD_VAR 0 4
9991: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
9992: LD_INT 0
9994: PPUSH
9995: PPUSH
// if not side or not nation then
9996: LD_VAR 0 1
10000: NOT
10001: PUSH
10002: LD_VAR 0 2
10006: NOT
10007: OR
10008: IFFALSE 10012
// exit ;
10010: GO 10780
// case nation of nation_american :
10012: LD_VAR 0 2
10016: PUSH
10017: LD_INT 1
10019: DOUBLE
10020: EQUAL
10021: IFTRUE 10025
10023: GO 10239
10025: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
10026: LD_ADDR_VAR 0 4
10030: PUSH
10031: LD_INT 35
10033: PUSH
10034: LD_INT 45
10036: PUSH
10037: LD_INT 46
10039: PUSH
10040: LD_INT 47
10042: PUSH
10043: LD_INT 82
10045: PUSH
10046: LD_INT 83
10048: PUSH
10049: LD_INT 84
10051: PUSH
10052: LD_INT 85
10054: PUSH
10055: LD_INT 86
10057: PUSH
10058: LD_INT 1
10060: PUSH
10061: LD_INT 2
10063: PUSH
10064: LD_INT 6
10066: PUSH
10067: LD_INT 15
10069: PUSH
10070: LD_INT 16
10072: PUSH
10073: LD_INT 7
10075: PUSH
10076: LD_INT 12
10078: PUSH
10079: LD_INT 13
10081: PUSH
10082: LD_INT 10
10084: PUSH
10085: LD_INT 14
10087: PUSH
10088: LD_INT 20
10090: PUSH
10091: LD_INT 21
10093: PUSH
10094: LD_INT 22
10096: PUSH
10097: LD_INT 25
10099: PUSH
10100: LD_INT 32
10102: PUSH
10103: LD_INT 27
10105: PUSH
10106: LD_INT 36
10108: PUSH
10109: LD_INT 69
10111: PUSH
10112: LD_INT 39
10114: PUSH
10115: LD_INT 34
10117: PUSH
10118: LD_INT 40
10120: PUSH
10121: LD_INT 48
10123: PUSH
10124: LD_INT 49
10126: PUSH
10127: LD_INT 50
10129: PUSH
10130: LD_INT 51
10132: PUSH
10133: LD_INT 52
10135: PUSH
10136: LD_INT 53
10138: PUSH
10139: LD_INT 54
10141: PUSH
10142: LD_INT 55
10144: PUSH
10145: LD_INT 56
10147: PUSH
10148: LD_INT 57
10150: PUSH
10151: LD_INT 58
10153: PUSH
10154: LD_INT 59
10156: PUSH
10157: LD_INT 60
10159: PUSH
10160: LD_INT 61
10162: PUSH
10163: LD_INT 62
10165: PUSH
10166: LD_INT 80
10168: PUSH
10169: LD_INT 82
10171: PUSH
10172: LD_INT 83
10174: PUSH
10175: LD_INT 84
10177: PUSH
10178: LD_INT 85
10180: PUSH
10181: LD_INT 86
10183: PUSH
10184: EMPTY
10185: LIST
10186: LIST
10187: LIST
10188: LIST
10189: LIST
10190: LIST
10191: LIST
10192: LIST
10193: LIST
10194: LIST
10195: LIST
10196: LIST
10197: LIST
10198: LIST
10199: LIST
10200: LIST
10201: LIST
10202: LIST
10203: LIST
10204: LIST
10205: LIST
10206: LIST
10207: LIST
10208: LIST
10209: LIST
10210: LIST
10211: LIST
10212: LIST
10213: LIST
10214: LIST
10215: LIST
10216: LIST
10217: LIST
10218: LIST
10219: LIST
10220: LIST
10221: LIST
10222: LIST
10223: LIST
10224: LIST
10225: LIST
10226: LIST
10227: LIST
10228: LIST
10229: LIST
10230: LIST
10231: LIST
10232: LIST
10233: LIST
10234: LIST
10235: LIST
10236: ST_TO_ADDR
10237: GO 10704
10239: LD_INT 2
10241: DOUBLE
10242: EQUAL
10243: IFTRUE 10247
10245: GO 10473
10247: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
10248: LD_ADDR_VAR 0 4
10252: PUSH
10253: LD_INT 35
10255: PUSH
10256: LD_INT 45
10258: PUSH
10259: LD_INT 46
10261: PUSH
10262: LD_INT 47
10264: PUSH
10265: LD_INT 82
10267: PUSH
10268: LD_INT 83
10270: PUSH
10271: LD_INT 84
10273: PUSH
10274: LD_INT 85
10276: PUSH
10277: LD_INT 87
10279: PUSH
10280: LD_INT 70
10282: PUSH
10283: LD_INT 1
10285: PUSH
10286: LD_INT 11
10288: PUSH
10289: LD_INT 3
10291: PUSH
10292: LD_INT 4
10294: PUSH
10295: LD_INT 5
10297: PUSH
10298: LD_INT 6
10300: PUSH
10301: LD_INT 15
10303: PUSH
10304: LD_INT 18
10306: PUSH
10307: LD_INT 7
10309: PUSH
10310: LD_INT 17
10312: PUSH
10313: LD_INT 8
10315: PUSH
10316: LD_INT 20
10318: PUSH
10319: LD_INT 21
10321: PUSH
10322: LD_INT 22
10324: PUSH
10325: LD_INT 72
10327: PUSH
10328: LD_INT 26
10330: PUSH
10331: LD_INT 69
10333: PUSH
10334: LD_INT 39
10336: PUSH
10337: LD_INT 40
10339: PUSH
10340: LD_INT 41
10342: PUSH
10343: LD_INT 42
10345: PUSH
10346: LD_INT 43
10348: PUSH
10349: LD_INT 48
10351: PUSH
10352: LD_INT 49
10354: PUSH
10355: LD_INT 50
10357: PUSH
10358: LD_INT 51
10360: PUSH
10361: LD_INT 52
10363: PUSH
10364: LD_INT 53
10366: PUSH
10367: LD_INT 54
10369: PUSH
10370: LD_INT 55
10372: PUSH
10373: LD_INT 56
10375: PUSH
10376: LD_INT 60
10378: PUSH
10379: LD_INT 61
10381: PUSH
10382: LD_INT 62
10384: PUSH
10385: LD_INT 66
10387: PUSH
10388: LD_INT 67
10390: PUSH
10391: LD_INT 68
10393: PUSH
10394: LD_INT 81
10396: PUSH
10397: LD_INT 82
10399: PUSH
10400: LD_INT 83
10402: PUSH
10403: LD_INT 84
10405: PUSH
10406: LD_INT 85
10408: PUSH
10409: LD_INT 87
10411: PUSH
10412: LD_INT 88
10414: PUSH
10415: EMPTY
10416: LIST
10417: LIST
10418: LIST
10419: LIST
10420: LIST
10421: LIST
10422: LIST
10423: LIST
10424: LIST
10425: LIST
10426: LIST
10427: LIST
10428: LIST
10429: LIST
10430: LIST
10431: LIST
10432: LIST
10433: LIST
10434: LIST
10435: LIST
10436: LIST
10437: LIST
10438: LIST
10439: LIST
10440: LIST
10441: LIST
10442: LIST
10443: LIST
10444: LIST
10445: LIST
10446: LIST
10447: LIST
10448: LIST
10449: LIST
10450: LIST
10451: LIST
10452: LIST
10453: LIST
10454: LIST
10455: LIST
10456: LIST
10457: LIST
10458: LIST
10459: LIST
10460: LIST
10461: LIST
10462: LIST
10463: LIST
10464: LIST
10465: LIST
10466: LIST
10467: LIST
10468: LIST
10469: LIST
10470: ST_TO_ADDR
10471: GO 10704
10473: LD_INT 3
10475: DOUBLE
10476: EQUAL
10477: IFTRUE 10481
10479: GO 10703
10481: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
10482: LD_ADDR_VAR 0 4
10486: PUSH
10487: LD_INT 46
10489: PUSH
10490: LD_INT 47
10492: PUSH
10493: LD_INT 1
10495: PUSH
10496: LD_INT 2
10498: PUSH
10499: LD_INT 82
10501: PUSH
10502: LD_INT 83
10504: PUSH
10505: LD_INT 84
10507: PUSH
10508: LD_INT 85
10510: PUSH
10511: LD_INT 86
10513: PUSH
10514: LD_INT 11
10516: PUSH
10517: LD_INT 9
10519: PUSH
10520: LD_INT 20
10522: PUSH
10523: LD_INT 19
10525: PUSH
10526: LD_INT 21
10528: PUSH
10529: LD_INT 24
10531: PUSH
10532: LD_INT 22
10534: PUSH
10535: LD_INT 25
10537: PUSH
10538: LD_INT 28
10540: PUSH
10541: LD_INT 29
10543: PUSH
10544: LD_INT 30
10546: PUSH
10547: LD_INT 31
10549: PUSH
10550: LD_INT 37
10552: PUSH
10553: LD_INT 38
10555: PUSH
10556: LD_INT 32
10558: PUSH
10559: LD_INT 27
10561: PUSH
10562: LD_INT 33
10564: PUSH
10565: LD_INT 69
10567: PUSH
10568: LD_INT 39
10570: PUSH
10571: LD_INT 34
10573: PUSH
10574: LD_INT 40
10576: PUSH
10577: LD_INT 71
10579: PUSH
10580: LD_INT 23
10582: PUSH
10583: LD_INT 44
10585: PUSH
10586: LD_INT 48
10588: PUSH
10589: LD_INT 49
10591: PUSH
10592: LD_INT 50
10594: PUSH
10595: LD_INT 51
10597: PUSH
10598: LD_INT 52
10600: PUSH
10601: LD_INT 53
10603: PUSH
10604: LD_INT 54
10606: PUSH
10607: LD_INT 55
10609: PUSH
10610: LD_INT 56
10612: PUSH
10613: LD_INT 57
10615: PUSH
10616: LD_INT 58
10618: PUSH
10619: LD_INT 59
10621: PUSH
10622: LD_INT 63
10624: PUSH
10625: LD_INT 64
10627: PUSH
10628: LD_INT 65
10630: PUSH
10631: LD_INT 82
10633: PUSH
10634: LD_INT 83
10636: PUSH
10637: LD_INT 84
10639: PUSH
10640: LD_INT 85
10642: PUSH
10643: LD_INT 86
10645: PUSH
10646: EMPTY
10647: LIST
10648: LIST
10649: LIST
10650: LIST
10651: LIST
10652: LIST
10653: LIST
10654: LIST
10655: LIST
10656: LIST
10657: LIST
10658: LIST
10659: LIST
10660: LIST
10661: LIST
10662: LIST
10663: LIST
10664: LIST
10665: LIST
10666: LIST
10667: LIST
10668: LIST
10669: LIST
10670: LIST
10671: LIST
10672: LIST
10673: LIST
10674: LIST
10675: LIST
10676: LIST
10677: LIST
10678: LIST
10679: LIST
10680: LIST
10681: LIST
10682: LIST
10683: LIST
10684: LIST
10685: LIST
10686: LIST
10687: LIST
10688: LIST
10689: LIST
10690: LIST
10691: LIST
10692: LIST
10693: LIST
10694: LIST
10695: LIST
10696: LIST
10697: LIST
10698: LIST
10699: LIST
10700: ST_TO_ADDR
10701: GO 10704
10703: POP
// if state > - 1 and state < 3 then
10704: LD_VAR 0 3
10708: PUSH
10709: LD_INT 1
10711: NEG
10712: GREATER
10713: PUSH
10714: LD_VAR 0 3
10718: PUSH
10719: LD_INT 3
10721: LESS
10722: AND
10723: IFFALSE 10780
// for i in result do
10725: LD_ADDR_VAR 0 5
10729: PUSH
10730: LD_VAR 0 4
10734: PUSH
10735: FOR_IN
10736: IFFALSE 10778
// if GetTech ( i , side ) <> state then
10738: LD_VAR 0 5
10742: PPUSH
10743: LD_VAR 0 1
10747: PPUSH
10748: CALL_OW 321
10752: PUSH
10753: LD_VAR 0 3
10757: NONEQUAL
10758: IFFALSE 10776
// result := result diff i ;
10760: LD_ADDR_VAR 0 4
10764: PUSH
10765: LD_VAR 0 4
10769: PUSH
10770: LD_VAR 0 5
10774: DIFF
10775: ST_TO_ADDR
10776: GO 10735
10778: POP
10779: POP
// end ;
10780: LD_VAR 0 4
10784: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
10785: LD_INT 0
10787: PPUSH
10788: PPUSH
10789: PPUSH
// result := true ;
10790: LD_ADDR_VAR 0 3
10794: PUSH
10795: LD_INT 1
10797: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
10798: LD_ADDR_VAR 0 5
10802: PUSH
10803: LD_VAR 0 2
10807: PPUSH
10808: CALL_OW 480
10812: ST_TO_ADDR
// if not tmp then
10813: LD_VAR 0 5
10817: NOT
10818: IFFALSE 10822
// exit ;
10820: GO 10871
// for i in tmp do
10822: LD_ADDR_VAR 0 4
10826: PUSH
10827: LD_VAR 0 5
10831: PUSH
10832: FOR_IN
10833: IFFALSE 10869
// if GetTech ( i , side ) <> state_researched then
10835: LD_VAR 0 4
10839: PPUSH
10840: LD_VAR 0 1
10844: PPUSH
10845: CALL_OW 321
10849: PUSH
10850: LD_INT 2
10852: NONEQUAL
10853: IFFALSE 10867
// begin result := false ;
10855: LD_ADDR_VAR 0 3
10859: PUSH
10860: LD_INT 0
10862: ST_TO_ADDR
// exit ;
10863: POP
10864: POP
10865: GO 10871
// end ;
10867: GO 10832
10869: POP
10870: POP
// end ;
10871: LD_VAR 0 3
10875: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
10876: LD_INT 0
10878: PPUSH
10879: PPUSH
10880: PPUSH
10881: PPUSH
10882: PPUSH
10883: PPUSH
10884: PPUSH
10885: PPUSH
10886: PPUSH
10887: PPUSH
10888: PPUSH
10889: PPUSH
10890: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
10891: LD_VAR 0 1
10895: NOT
10896: PUSH
10897: LD_VAR 0 1
10901: PPUSH
10902: CALL_OW 257
10906: PUSH
10907: LD_INT 9
10909: NONEQUAL
10910: OR
10911: IFFALSE 10915
// exit ;
10913: GO 11488
// side := GetSide ( unit ) ;
10915: LD_ADDR_VAR 0 9
10919: PUSH
10920: LD_VAR 0 1
10924: PPUSH
10925: CALL_OW 255
10929: ST_TO_ADDR
// tech_space := tech_spacanom ;
10930: LD_ADDR_VAR 0 12
10934: PUSH
10935: LD_INT 29
10937: ST_TO_ADDR
// tech_time := tech_taurad ;
10938: LD_ADDR_VAR 0 13
10942: PUSH
10943: LD_INT 28
10945: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
10946: LD_ADDR_VAR 0 11
10950: PUSH
10951: LD_VAR 0 1
10955: PPUSH
10956: CALL_OW 310
10960: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
10961: LD_VAR 0 11
10965: PPUSH
10966: CALL_OW 247
10970: PUSH
10971: LD_INT 2
10973: EQUAL
10974: IFFALSE 10978
// exit ;
10976: GO 11488
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
10978: LD_ADDR_VAR 0 8
10982: PUSH
10983: LD_INT 81
10985: PUSH
10986: LD_VAR 0 9
10990: PUSH
10991: EMPTY
10992: LIST
10993: LIST
10994: PUSH
10995: LD_INT 3
10997: PUSH
10998: LD_INT 21
11000: PUSH
11001: LD_INT 3
11003: PUSH
11004: EMPTY
11005: LIST
11006: LIST
11007: PUSH
11008: EMPTY
11009: LIST
11010: LIST
11011: PUSH
11012: EMPTY
11013: LIST
11014: LIST
11015: PPUSH
11016: CALL_OW 69
11020: ST_TO_ADDR
// if not tmp then
11021: LD_VAR 0 8
11025: NOT
11026: IFFALSE 11030
// exit ;
11028: GO 11488
// if in_unit then
11030: LD_VAR 0 11
11034: IFFALSE 11058
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
11036: LD_ADDR_VAR 0 10
11040: PUSH
11041: LD_VAR 0 8
11045: PPUSH
11046: LD_VAR 0 11
11050: PPUSH
11051: CALL_OW 74
11055: ST_TO_ADDR
11056: GO 11078
// enemy := NearestUnitToUnit ( tmp , unit ) ;
11058: LD_ADDR_VAR 0 10
11062: PUSH
11063: LD_VAR 0 8
11067: PPUSH
11068: LD_VAR 0 1
11072: PPUSH
11073: CALL_OW 74
11077: ST_TO_ADDR
// if not enemy then
11078: LD_VAR 0 10
11082: NOT
11083: IFFALSE 11087
// exit ;
11085: GO 11488
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
11087: LD_VAR 0 11
11091: PUSH
11092: LD_VAR 0 11
11096: PPUSH
11097: LD_VAR 0 10
11101: PPUSH
11102: CALL_OW 296
11106: PUSH
11107: LD_INT 13
11109: GREATER
11110: AND
11111: PUSH
11112: LD_VAR 0 1
11116: PPUSH
11117: LD_VAR 0 10
11121: PPUSH
11122: CALL_OW 296
11126: PUSH
11127: LD_INT 12
11129: GREATER
11130: OR
11131: IFFALSE 11135
// exit ;
11133: GO 11488
// missile := [ 1 ] ;
11135: LD_ADDR_VAR 0 14
11139: PUSH
11140: LD_INT 1
11142: PUSH
11143: EMPTY
11144: LIST
11145: ST_TO_ADDR
// if Researched ( side , tech_space ) then
11146: LD_VAR 0 9
11150: PPUSH
11151: LD_VAR 0 12
11155: PPUSH
11156: CALL_OW 325
11160: IFFALSE 11189
// missile := Insert ( missile , missile + 1 , 2 ) ;
11162: LD_ADDR_VAR 0 14
11166: PUSH
11167: LD_VAR 0 14
11171: PPUSH
11172: LD_VAR 0 14
11176: PUSH
11177: LD_INT 1
11179: PLUS
11180: PPUSH
11181: LD_INT 2
11183: PPUSH
11184: CALL_OW 2
11188: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
11189: LD_VAR 0 9
11193: PPUSH
11194: LD_VAR 0 13
11198: PPUSH
11199: CALL_OW 325
11203: PUSH
11204: LD_VAR 0 10
11208: PPUSH
11209: CALL_OW 255
11213: PPUSH
11214: LD_VAR 0 13
11218: PPUSH
11219: CALL_OW 325
11223: NOT
11224: AND
11225: IFFALSE 11254
// missile := Insert ( missile , missile + 1 , 3 ) ;
11227: LD_ADDR_VAR 0 14
11231: PUSH
11232: LD_VAR 0 14
11236: PPUSH
11237: LD_VAR 0 14
11241: PUSH
11242: LD_INT 1
11244: PLUS
11245: PPUSH
11246: LD_INT 3
11248: PPUSH
11249: CALL_OW 2
11253: ST_TO_ADDR
// if missile < 2 then
11254: LD_VAR 0 14
11258: PUSH
11259: LD_INT 2
11261: LESS
11262: IFFALSE 11266
// exit ;
11264: GO 11488
// x := GetX ( enemy ) ;
11266: LD_ADDR_VAR 0 4
11270: PUSH
11271: LD_VAR 0 10
11275: PPUSH
11276: CALL_OW 250
11280: ST_TO_ADDR
// y := GetY ( enemy ) ;
11281: LD_ADDR_VAR 0 5
11285: PUSH
11286: LD_VAR 0 10
11290: PPUSH
11291: CALL_OW 251
11295: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
11296: LD_ADDR_VAR 0 6
11300: PUSH
11301: LD_VAR 0 4
11305: PUSH
11306: LD_INT 1
11308: NEG
11309: PPUSH
11310: LD_INT 1
11312: PPUSH
11313: CALL_OW 12
11317: PLUS
11318: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
11319: LD_ADDR_VAR 0 7
11323: PUSH
11324: LD_VAR 0 5
11328: PUSH
11329: LD_INT 1
11331: NEG
11332: PPUSH
11333: LD_INT 1
11335: PPUSH
11336: CALL_OW 12
11340: PLUS
11341: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
11342: LD_VAR 0 6
11346: PPUSH
11347: LD_VAR 0 7
11351: PPUSH
11352: CALL_OW 488
11356: NOT
11357: IFFALSE 11379
// begin _x := x ;
11359: LD_ADDR_VAR 0 6
11363: PUSH
11364: LD_VAR 0 4
11368: ST_TO_ADDR
// _y := y ;
11369: LD_ADDR_VAR 0 7
11373: PUSH
11374: LD_VAR 0 5
11378: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
11379: LD_ADDR_VAR 0 3
11383: PUSH
11384: LD_INT 1
11386: PPUSH
11387: LD_VAR 0 14
11391: PPUSH
11392: CALL_OW 12
11396: ST_TO_ADDR
// case i of 1 :
11397: LD_VAR 0 3
11401: PUSH
11402: LD_INT 1
11404: DOUBLE
11405: EQUAL
11406: IFTRUE 11410
11408: GO 11427
11410: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
11411: LD_VAR 0 1
11415: PPUSH
11416: LD_VAR 0 10
11420: PPUSH
11421: CALL_OW 115
11425: GO 11488
11427: LD_INT 2
11429: DOUBLE
11430: EQUAL
11431: IFTRUE 11435
11433: GO 11457
11435: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
11436: LD_VAR 0 1
11440: PPUSH
11441: LD_VAR 0 6
11445: PPUSH
11446: LD_VAR 0 7
11450: PPUSH
11451: CALL_OW 153
11455: GO 11488
11457: LD_INT 3
11459: DOUBLE
11460: EQUAL
11461: IFTRUE 11465
11463: GO 11487
11465: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
11466: LD_VAR 0 1
11470: PPUSH
11471: LD_VAR 0 6
11475: PPUSH
11476: LD_VAR 0 7
11480: PPUSH
11481: CALL_OW 154
11485: GO 11488
11487: POP
// end ;
11488: LD_VAR 0 2
11492: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
11493: LD_INT 0
11495: PPUSH
11496: PPUSH
11497: PPUSH
11498: PPUSH
11499: PPUSH
11500: PPUSH
// if not unit or not building then
11501: LD_VAR 0 1
11505: NOT
11506: PUSH
11507: LD_VAR 0 2
11511: NOT
11512: OR
11513: IFFALSE 11517
// exit ;
11515: GO 11675
// x := GetX ( building ) ;
11517: LD_ADDR_VAR 0 5
11521: PUSH
11522: LD_VAR 0 2
11526: PPUSH
11527: CALL_OW 250
11531: ST_TO_ADDR
// y := GetY ( building ) ;
11532: LD_ADDR_VAR 0 6
11536: PUSH
11537: LD_VAR 0 2
11541: PPUSH
11542: CALL_OW 251
11546: ST_TO_ADDR
// for i = 0 to 5 do
11547: LD_ADDR_VAR 0 4
11551: PUSH
11552: DOUBLE
11553: LD_INT 0
11555: DEC
11556: ST_TO_ADDR
11557: LD_INT 5
11559: PUSH
11560: FOR_TO
11561: IFFALSE 11673
// begin _x := ShiftX ( x , i , 3 ) ;
11563: LD_ADDR_VAR 0 7
11567: PUSH
11568: LD_VAR 0 5
11572: PPUSH
11573: LD_VAR 0 4
11577: PPUSH
11578: LD_INT 3
11580: PPUSH
11581: CALL_OW 272
11585: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
11586: LD_ADDR_VAR 0 8
11590: PUSH
11591: LD_VAR 0 6
11595: PPUSH
11596: LD_VAR 0 4
11600: PPUSH
11601: LD_INT 3
11603: PPUSH
11604: CALL_OW 273
11608: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
11609: LD_VAR 0 7
11613: PPUSH
11614: LD_VAR 0 8
11618: PPUSH
11619: CALL_OW 488
11623: NOT
11624: IFFALSE 11628
// continue ;
11626: GO 11560
// if HexInfo ( _x , _y ) = 0 then
11628: LD_VAR 0 7
11632: PPUSH
11633: LD_VAR 0 8
11637: PPUSH
11638: CALL_OW 428
11642: PUSH
11643: LD_INT 0
11645: EQUAL
11646: IFFALSE 11671
// begin ComMoveXY ( unit , _x , _y ) ;
11648: LD_VAR 0 1
11652: PPUSH
11653: LD_VAR 0 7
11657: PPUSH
11658: LD_VAR 0 8
11662: PPUSH
11663: CALL_OW 111
// exit ;
11667: POP
11668: POP
11669: GO 11675
// end ; end ;
11671: GO 11560
11673: POP
11674: POP
// end ;
11675: LD_VAR 0 3
11679: RET
// export function ScanBase ( side , base_area ) ; begin
11680: LD_INT 0
11682: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
11683: LD_ADDR_VAR 0 3
11687: PUSH
11688: LD_VAR 0 2
11692: PPUSH
11693: LD_INT 81
11695: PUSH
11696: LD_VAR 0 1
11700: PUSH
11701: EMPTY
11702: LIST
11703: LIST
11704: PPUSH
11705: CALL_OW 70
11709: ST_TO_ADDR
// end ;
11710: LD_VAR 0 3
11714: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
11715: LD_INT 0
11717: PPUSH
11718: PPUSH
11719: PPUSH
11720: PPUSH
// result := false ;
11721: LD_ADDR_VAR 0 2
11725: PUSH
11726: LD_INT 0
11728: ST_TO_ADDR
// side := GetSide ( unit ) ;
11729: LD_ADDR_VAR 0 3
11733: PUSH
11734: LD_VAR 0 1
11738: PPUSH
11739: CALL_OW 255
11743: ST_TO_ADDR
// nat := GetNation ( unit ) ;
11744: LD_ADDR_VAR 0 4
11748: PUSH
11749: LD_VAR 0 1
11753: PPUSH
11754: CALL_OW 248
11758: ST_TO_ADDR
// case nat of 1 :
11759: LD_VAR 0 4
11763: PUSH
11764: LD_INT 1
11766: DOUBLE
11767: EQUAL
11768: IFTRUE 11772
11770: GO 11783
11772: POP
// tech := tech_lassight ; 2 :
11773: LD_ADDR_VAR 0 5
11777: PUSH
11778: LD_INT 12
11780: ST_TO_ADDR
11781: GO 11822
11783: LD_INT 2
11785: DOUBLE
11786: EQUAL
11787: IFTRUE 11791
11789: GO 11802
11791: POP
// tech := tech_mortar ; 3 :
11792: LD_ADDR_VAR 0 5
11796: PUSH
11797: LD_INT 41
11799: ST_TO_ADDR
11800: GO 11822
11802: LD_INT 3
11804: DOUBLE
11805: EQUAL
11806: IFTRUE 11810
11808: GO 11821
11810: POP
// tech := tech_bazooka ; end ;
11811: LD_ADDR_VAR 0 5
11815: PUSH
11816: LD_INT 44
11818: ST_TO_ADDR
11819: GO 11822
11821: POP
// if Researched ( side , tech ) then
11822: LD_VAR 0 3
11826: PPUSH
11827: LD_VAR 0 5
11831: PPUSH
11832: CALL_OW 325
11836: IFFALSE 11863
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
11838: LD_ADDR_VAR 0 2
11842: PUSH
11843: LD_INT 5
11845: PUSH
11846: LD_INT 8
11848: PUSH
11849: LD_INT 9
11851: PUSH
11852: EMPTY
11853: LIST
11854: LIST
11855: LIST
11856: PUSH
11857: LD_VAR 0 4
11861: ARRAY
11862: ST_TO_ADDR
// end ;
11863: LD_VAR 0 2
11867: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
11868: LD_INT 0
11870: PPUSH
11871: PPUSH
11872: PPUSH
// if not mines then
11873: LD_VAR 0 2
11877: NOT
11878: IFFALSE 11882
// exit ;
11880: GO 12026
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
11882: LD_ADDR_VAR 0 5
11886: PUSH
11887: LD_INT 81
11889: PUSH
11890: LD_VAR 0 1
11894: PUSH
11895: EMPTY
11896: LIST
11897: LIST
11898: PUSH
11899: LD_INT 3
11901: PUSH
11902: LD_INT 21
11904: PUSH
11905: LD_INT 3
11907: PUSH
11908: EMPTY
11909: LIST
11910: LIST
11911: PUSH
11912: EMPTY
11913: LIST
11914: LIST
11915: PUSH
11916: EMPTY
11917: LIST
11918: LIST
11919: PPUSH
11920: CALL_OW 69
11924: ST_TO_ADDR
// for i in mines do
11925: LD_ADDR_VAR 0 4
11929: PUSH
11930: LD_VAR 0 2
11934: PUSH
11935: FOR_IN
11936: IFFALSE 12024
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
11938: LD_VAR 0 4
11942: PUSH
11943: LD_INT 1
11945: ARRAY
11946: PPUSH
11947: LD_VAR 0 4
11951: PUSH
11952: LD_INT 2
11954: ARRAY
11955: PPUSH
11956: CALL_OW 458
11960: NOT
11961: IFFALSE 11965
// continue ;
11963: GO 11935
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
11965: LD_VAR 0 4
11969: PUSH
11970: LD_INT 1
11972: ARRAY
11973: PPUSH
11974: LD_VAR 0 4
11978: PUSH
11979: LD_INT 2
11981: ARRAY
11982: PPUSH
11983: CALL_OW 428
11987: PUSH
11988: LD_VAR 0 5
11992: IN
11993: IFFALSE 12022
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
11995: LD_VAR 0 4
11999: PUSH
12000: LD_INT 1
12002: ARRAY
12003: PPUSH
12004: LD_VAR 0 4
12008: PUSH
12009: LD_INT 2
12011: ARRAY
12012: PPUSH
12013: LD_VAR 0 1
12017: PPUSH
12018: CALL_OW 456
// end ;
12022: GO 11935
12024: POP
12025: POP
// end ;
12026: LD_VAR 0 3
12030: RET
// export function Count ( array ) ; var i ; begin
12031: LD_INT 0
12033: PPUSH
12034: PPUSH
// result := 0 ;
12035: LD_ADDR_VAR 0 2
12039: PUSH
12040: LD_INT 0
12042: ST_TO_ADDR
// for i in array do
12043: LD_ADDR_VAR 0 3
12047: PUSH
12048: LD_VAR 0 1
12052: PUSH
12053: FOR_IN
12054: IFFALSE 12078
// if i then
12056: LD_VAR 0 3
12060: IFFALSE 12076
// result := result + 1 ;
12062: LD_ADDR_VAR 0 2
12066: PUSH
12067: LD_VAR 0 2
12071: PUSH
12072: LD_INT 1
12074: PLUS
12075: ST_TO_ADDR
12076: GO 12053
12078: POP
12079: POP
// end ;
12080: LD_VAR 0 2
12084: RET
// export function IsEmpty ( building ) ; begin
12085: LD_INT 0
12087: PPUSH
// if not building then
12088: LD_VAR 0 1
12092: NOT
12093: IFFALSE 12097
// exit ;
12095: GO 12140
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
12097: LD_ADDR_VAR 0 2
12101: PUSH
12102: LD_VAR 0 1
12106: PUSH
12107: LD_INT 22
12109: PUSH
12110: LD_VAR 0 1
12114: PPUSH
12115: CALL_OW 255
12119: PUSH
12120: EMPTY
12121: LIST
12122: LIST
12123: PUSH
12124: LD_INT 58
12126: PUSH
12127: EMPTY
12128: LIST
12129: PUSH
12130: EMPTY
12131: LIST
12132: LIST
12133: PPUSH
12134: CALL_OW 69
12138: IN
12139: ST_TO_ADDR
// end ;
12140: LD_VAR 0 2
12144: RET
// export function IsNotFull ( building ) ; begin
12145: LD_INT 0
12147: PPUSH
// if not building then
12148: LD_VAR 0 1
12152: NOT
12153: IFFALSE 12157
// exit ;
12155: GO 12176
// result := UnitsInside ( building ) < 6 ;
12157: LD_ADDR_VAR 0 2
12161: PUSH
12162: LD_VAR 0 1
12166: PPUSH
12167: CALL_OW 313
12171: PUSH
12172: LD_INT 6
12174: LESS
12175: ST_TO_ADDR
// end ;
12176: LD_VAR 0 2
12180: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
12181: LD_INT 0
12183: PPUSH
12184: PPUSH
12185: PPUSH
12186: PPUSH
// tmp := [ ] ;
12187: LD_ADDR_VAR 0 3
12191: PUSH
12192: EMPTY
12193: ST_TO_ADDR
// list := [ ] ;
12194: LD_ADDR_VAR 0 5
12198: PUSH
12199: EMPTY
12200: ST_TO_ADDR
// for i = 16 to 25 do
12201: LD_ADDR_VAR 0 4
12205: PUSH
12206: DOUBLE
12207: LD_INT 16
12209: DEC
12210: ST_TO_ADDR
12211: LD_INT 25
12213: PUSH
12214: FOR_TO
12215: IFFALSE 12288
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
12217: LD_ADDR_VAR 0 3
12221: PUSH
12222: LD_VAR 0 3
12226: PUSH
12227: LD_INT 22
12229: PUSH
12230: LD_VAR 0 1
12234: PPUSH
12235: CALL_OW 255
12239: PUSH
12240: EMPTY
12241: LIST
12242: LIST
12243: PUSH
12244: LD_INT 91
12246: PUSH
12247: LD_VAR 0 1
12251: PUSH
12252: LD_INT 6
12254: PUSH
12255: EMPTY
12256: LIST
12257: LIST
12258: LIST
12259: PUSH
12260: LD_INT 30
12262: PUSH
12263: LD_VAR 0 4
12267: PUSH
12268: EMPTY
12269: LIST
12270: LIST
12271: PUSH
12272: EMPTY
12273: LIST
12274: LIST
12275: LIST
12276: PUSH
12277: EMPTY
12278: LIST
12279: PPUSH
12280: CALL_OW 69
12284: ADD
12285: ST_TO_ADDR
12286: GO 12214
12288: POP
12289: POP
// for i = 1 to tmp do
12290: LD_ADDR_VAR 0 4
12294: PUSH
12295: DOUBLE
12296: LD_INT 1
12298: DEC
12299: ST_TO_ADDR
12300: LD_VAR 0 3
12304: PUSH
12305: FOR_TO
12306: IFFALSE 12394
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
12308: LD_ADDR_VAR 0 5
12312: PUSH
12313: LD_VAR 0 5
12317: PUSH
12318: LD_VAR 0 3
12322: PUSH
12323: LD_VAR 0 4
12327: ARRAY
12328: PPUSH
12329: CALL_OW 266
12333: PUSH
12334: LD_VAR 0 3
12338: PUSH
12339: LD_VAR 0 4
12343: ARRAY
12344: PPUSH
12345: CALL_OW 250
12349: PUSH
12350: LD_VAR 0 3
12354: PUSH
12355: LD_VAR 0 4
12359: ARRAY
12360: PPUSH
12361: CALL_OW 251
12365: PUSH
12366: LD_VAR 0 3
12370: PUSH
12371: LD_VAR 0 4
12375: ARRAY
12376: PPUSH
12377: CALL_OW 254
12381: PUSH
12382: EMPTY
12383: LIST
12384: LIST
12385: LIST
12386: LIST
12387: PUSH
12388: EMPTY
12389: LIST
12390: ADD
12391: ST_TO_ADDR
12392: GO 12305
12394: POP
12395: POP
// result := list ;
12396: LD_ADDR_VAR 0 2
12400: PUSH
12401: LD_VAR 0 5
12405: ST_TO_ADDR
// end ;
12406: LD_VAR 0 2
12410: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
12411: LD_INT 0
12413: PPUSH
12414: PPUSH
12415: PPUSH
12416: PPUSH
12417: PPUSH
12418: PPUSH
12419: PPUSH
// if not factory then
12420: LD_VAR 0 1
12424: NOT
12425: IFFALSE 12429
// exit ;
12427: GO 13022
// if control = control_apeman then
12429: LD_VAR 0 4
12433: PUSH
12434: LD_INT 5
12436: EQUAL
12437: IFFALSE 12546
// begin tmp := UnitsInside ( factory ) ;
12439: LD_ADDR_VAR 0 8
12443: PUSH
12444: LD_VAR 0 1
12448: PPUSH
12449: CALL_OW 313
12453: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
12454: LD_VAR 0 8
12458: PPUSH
12459: LD_INT 25
12461: PUSH
12462: LD_INT 12
12464: PUSH
12465: EMPTY
12466: LIST
12467: LIST
12468: PPUSH
12469: CALL_OW 72
12473: NOT
12474: IFFALSE 12484
// control := control_manual ;
12476: LD_ADDR_VAR 0 4
12480: PUSH
12481: LD_INT 1
12483: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
12484: LD_ADDR_VAR 0 8
12488: PUSH
12489: LD_VAR 0 1
12493: PPUSH
12494: CALL 12181 0 1
12498: ST_TO_ADDR
// if tmp then
12499: LD_VAR 0 8
12503: IFFALSE 12546
// begin for i in tmp do
12505: LD_ADDR_VAR 0 7
12509: PUSH
12510: LD_VAR 0 8
12514: PUSH
12515: FOR_IN
12516: IFFALSE 12544
// if i [ 1 ] = b_ext_radio then
12518: LD_VAR 0 7
12522: PUSH
12523: LD_INT 1
12525: ARRAY
12526: PUSH
12527: LD_INT 22
12529: EQUAL
12530: IFFALSE 12542
// begin control := control_remote ;
12532: LD_ADDR_VAR 0 4
12536: PUSH
12537: LD_INT 2
12539: ST_TO_ADDR
// break ;
12540: GO 12544
// end ;
12542: GO 12515
12544: POP
12545: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
12546: LD_VAR 0 1
12550: PPUSH
12551: LD_VAR 0 2
12555: PPUSH
12556: LD_VAR 0 3
12560: PPUSH
12561: LD_VAR 0 4
12565: PPUSH
12566: LD_VAR 0 5
12570: PPUSH
12571: CALL_OW 448
12575: IFFALSE 12610
// begin result := [ chassis , engine , control , weapon ] ;
12577: LD_ADDR_VAR 0 6
12581: PUSH
12582: LD_VAR 0 2
12586: PUSH
12587: LD_VAR 0 3
12591: PUSH
12592: LD_VAR 0 4
12596: PUSH
12597: LD_VAR 0 5
12601: PUSH
12602: EMPTY
12603: LIST
12604: LIST
12605: LIST
12606: LIST
12607: ST_TO_ADDR
// exit ;
12608: GO 13022
// end ; _chassis := AvailableChassisList ( factory ) ;
12610: LD_ADDR_VAR 0 9
12614: PUSH
12615: LD_VAR 0 1
12619: PPUSH
12620: CALL_OW 475
12624: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
12625: LD_ADDR_VAR 0 11
12629: PUSH
12630: LD_VAR 0 1
12634: PPUSH
12635: CALL_OW 476
12639: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
12640: LD_ADDR_VAR 0 12
12644: PUSH
12645: LD_VAR 0 1
12649: PPUSH
12650: CALL_OW 477
12654: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
12655: LD_ADDR_VAR 0 10
12659: PUSH
12660: LD_VAR 0 1
12664: PPUSH
12665: CALL_OW 478
12669: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
12670: LD_VAR 0 9
12674: NOT
12675: PUSH
12676: LD_VAR 0 11
12680: NOT
12681: OR
12682: PUSH
12683: LD_VAR 0 12
12687: NOT
12688: OR
12689: PUSH
12690: LD_VAR 0 10
12694: NOT
12695: OR
12696: IFFALSE 12731
// begin result := [ chassis , engine , control , weapon ] ;
12698: LD_ADDR_VAR 0 6
12702: PUSH
12703: LD_VAR 0 2
12707: PUSH
12708: LD_VAR 0 3
12712: PUSH
12713: LD_VAR 0 4
12717: PUSH
12718: LD_VAR 0 5
12722: PUSH
12723: EMPTY
12724: LIST
12725: LIST
12726: LIST
12727: LIST
12728: ST_TO_ADDR
// exit ;
12729: GO 13022
// end ; if not chassis in _chassis then
12731: LD_VAR 0 2
12735: PUSH
12736: LD_VAR 0 9
12740: IN
12741: NOT
12742: IFFALSE 12768
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
12744: LD_ADDR_VAR 0 2
12748: PUSH
12749: LD_VAR 0 9
12753: PUSH
12754: LD_INT 1
12756: PPUSH
12757: LD_VAR 0 9
12761: PPUSH
12762: CALL_OW 12
12766: ARRAY
12767: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
12768: LD_VAR 0 2
12772: PPUSH
12773: LD_VAR 0 3
12777: PPUSH
12778: CALL 13027 0 2
12782: NOT
12783: IFFALSE 12842
// repeat engine := _engine [ 1 ] ;
12785: LD_ADDR_VAR 0 3
12789: PUSH
12790: LD_VAR 0 11
12794: PUSH
12795: LD_INT 1
12797: ARRAY
12798: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
12799: LD_ADDR_VAR 0 11
12803: PUSH
12804: LD_VAR 0 11
12808: PPUSH
12809: LD_INT 1
12811: PPUSH
12812: CALL_OW 3
12816: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
12817: LD_VAR 0 2
12821: PPUSH
12822: LD_VAR 0 3
12826: PPUSH
12827: CALL 13027 0 2
12831: PUSH
12832: LD_VAR 0 11
12836: PUSH
12837: EMPTY
12838: EQUAL
12839: OR
12840: IFFALSE 12785
// if not control in _control then
12842: LD_VAR 0 4
12846: PUSH
12847: LD_VAR 0 12
12851: IN
12852: NOT
12853: IFFALSE 12879
// control := _control [ rand ( 1 , _control ) ] ;
12855: LD_ADDR_VAR 0 4
12859: PUSH
12860: LD_VAR 0 12
12864: PUSH
12865: LD_INT 1
12867: PPUSH
12868: LD_VAR 0 12
12872: PPUSH
12873: CALL_OW 12
12877: ARRAY
12878: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
12879: LD_VAR 0 2
12883: PPUSH
12884: LD_VAR 0 5
12888: PPUSH
12889: CALL 13247 0 2
12893: NOT
12894: IFFALSE 12953
// repeat weapon := _weapon [ 1 ] ;
12896: LD_ADDR_VAR 0 5
12900: PUSH
12901: LD_VAR 0 10
12905: PUSH
12906: LD_INT 1
12908: ARRAY
12909: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
12910: LD_ADDR_VAR 0 10
12914: PUSH
12915: LD_VAR 0 10
12919: PPUSH
12920: LD_INT 1
12922: PPUSH
12923: CALL_OW 3
12927: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
12928: LD_VAR 0 2
12932: PPUSH
12933: LD_VAR 0 5
12937: PPUSH
12938: CALL 13247 0 2
12942: PUSH
12943: LD_VAR 0 10
12947: PUSH
12948: EMPTY
12949: EQUAL
12950: OR
12951: IFFALSE 12896
// result := [ ] ;
12953: LD_ADDR_VAR 0 6
12957: PUSH
12958: EMPTY
12959: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
12960: LD_VAR 0 1
12964: PPUSH
12965: LD_VAR 0 2
12969: PPUSH
12970: LD_VAR 0 3
12974: PPUSH
12975: LD_VAR 0 4
12979: PPUSH
12980: LD_VAR 0 5
12984: PPUSH
12985: CALL_OW 448
12989: IFFALSE 13022
// result := [ chassis , engine , control , weapon ] ;
12991: LD_ADDR_VAR 0 6
12995: PUSH
12996: LD_VAR 0 2
13000: PUSH
13001: LD_VAR 0 3
13005: PUSH
13006: LD_VAR 0 4
13010: PUSH
13011: LD_VAR 0 5
13015: PUSH
13016: EMPTY
13017: LIST
13018: LIST
13019: LIST
13020: LIST
13021: ST_TO_ADDR
// end ;
13022: LD_VAR 0 6
13026: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
13027: LD_INT 0
13029: PPUSH
// if not chassis or not engine then
13030: LD_VAR 0 1
13034: NOT
13035: PUSH
13036: LD_VAR 0 2
13040: NOT
13041: OR
13042: IFFALSE 13046
// exit ;
13044: GO 13242
// case engine of engine_solar :
13046: LD_VAR 0 2
13050: PUSH
13051: LD_INT 2
13053: DOUBLE
13054: EQUAL
13055: IFTRUE 13059
13057: GO 13097
13059: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
13060: LD_ADDR_VAR 0 3
13064: PUSH
13065: LD_INT 11
13067: PUSH
13068: LD_INT 12
13070: PUSH
13071: LD_INT 13
13073: PUSH
13074: LD_INT 14
13076: PUSH
13077: LD_INT 1
13079: PUSH
13080: LD_INT 2
13082: PUSH
13083: LD_INT 3
13085: PUSH
13086: EMPTY
13087: LIST
13088: LIST
13089: LIST
13090: LIST
13091: LIST
13092: LIST
13093: LIST
13094: ST_TO_ADDR
13095: GO 13226
13097: LD_INT 1
13099: DOUBLE
13100: EQUAL
13101: IFTRUE 13105
13103: GO 13167
13105: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
13106: LD_ADDR_VAR 0 3
13110: PUSH
13111: LD_INT 11
13113: PUSH
13114: LD_INT 12
13116: PUSH
13117: LD_INT 13
13119: PUSH
13120: LD_INT 14
13122: PUSH
13123: LD_INT 1
13125: PUSH
13126: LD_INT 2
13128: PUSH
13129: LD_INT 3
13131: PUSH
13132: LD_INT 4
13134: PUSH
13135: LD_INT 5
13137: PUSH
13138: LD_INT 21
13140: PUSH
13141: LD_INT 23
13143: PUSH
13144: LD_INT 22
13146: PUSH
13147: LD_INT 24
13149: PUSH
13150: EMPTY
13151: LIST
13152: LIST
13153: LIST
13154: LIST
13155: LIST
13156: LIST
13157: LIST
13158: LIST
13159: LIST
13160: LIST
13161: LIST
13162: LIST
13163: LIST
13164: ST_TO_ADDR
13165: GO 13226
13167: LD_INT 3
13169: DOUBLE
13170: EQUAL
13171: IFTRUE 13175
13173: GO 13225
13175: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
13176: LD_ADDR_VAR 0 3
13180: PUSH
13181: LD_INT 13
13183: PUSH
13184: LD_INT 14
13186: PUSH
13187: LD_INT 2
13189: PUSH
13190: LD_INT 3
13192: PUSH
13193: LD_INT 4
13195: PUSH
13196: LD_INT 5
13198: PUSH
13199: LD_INT 21
13201: PUSH
13202: LD_INT 22
13204: PUSH
13205: LD_INT 23
13207: PUSH
13208: LD_INT 24
13210: PUSH
13211: EMPTY
13212: LIST
13213: LIST
13214: LIST
13215: LIST
13216: LIST
13217: LIST
13218: LIST
13219: LIST
13220: LIST
13221: LIST
13222: ST_TO_ADDR
13223: GO 13226
13225: POP
// result := ( chassis in result ) ;
13226: LD_ADDR_VAR 0 3
13230: PUSH
13231: LD_VAR 0 1
13235: PUSH
13236: LD_VAR 0 3
13240: IN
13241: ST_TO_ADDR
// end ;
13242: LD_VAR 0 3
13246: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
13247: LD_INT 0
13249: PPUSH
// if not chassis or not weapon then
13250: LD_VAR 0 1
13254: NOT
13255: PUSH
13256: LD_VAR 0 2
13260: NOT
13261: OR
13262: IFFALSE 13266
// exit ;
13264: GO 14328
// case weapon of us_machine_gun :
13266: LD_VAR 0 2
13270: PUSH
13271: LD_INT 2
13273: DOUBLE
13274: EQUAL
13275: IFTRUE 13279
13277: GO 13309
13279: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
13280: LD_ADDR_VAR 0 3
13284: PUSH
13285: LD_INT 1
13287: PUSH
13288: LD_INT 2
13290: PUSH
13291: LD_INT 3
13293: PUSH
13294: LD_INT 4
13296: PUSH
13297: LD_INT 5
13299: PUSH
13300: EMPTY
13301: LIST
13302: LIST
13303: LIST
13304: LIST
13305: LIST
13306: ST_TO_ADDR
13307: GO 14312
13309: LD_INT 3
13311: DOUBLE
13312: EQUAL
13313: IFTRUE 13317
13315: GO 13347
13317: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
13318: LD_ADDR_VAR 0 3
13322: PUSH
13323: LD_INT 1
13325: PUSH
13326: LD_INT 2
13328: PUSH
13329: LD_INT 3
13331: PUSH
13332: LD_INT 4
13334: PUSH
13335: LD_INT 5
13337: PUSH
13338: EMPTY
13339: LIST
13340: LIST
13341: LIST
13342: LIST
13343: LIST
13344: ST_TO_ADDR
13345: GO 14312
13347: LD_INT 11
13349: DOUBLE
13350: EQUAL
13351: IFTRUE 13355
13353: GO 13385
13355: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
13356: LD_ADDR_VAR 0 3
13360: PUSH
13361: LD_INT 1
13363: PUSH
13364: LD_INT 2
13366: PUSH
13367: LD_INT 3
13369: PUSH
13370: LD_INT 4
13372: PUSH
13373: LD_INT 5
13375: PUSH
13376: EMPTY
13377: LIST
13378: LIST
13379: LIST
13380: LIST
13381: LIST
13382: ST_TO_ADDR
13383: GO 14312
13385: LD_INT 4
13387: DOUBLE
13388: EQUAL
13389: IFTRUE 13393
13391: GO 13419
13393: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
13394: LD_ADDR_VAR 0 3
13398: PUSH
13399: LD_INT 2
13401: PUSH
13402: LD_INT 3
13404: PUSH
13405: LD_INT 4
13407: PUSH
13408: LD_INT 5
13410: PUSH
13411: EMPTY
13412: LIST
13413: LIST
13414: LIST
13415: LIST
13416: ST_TO_ADDR
13417: GO 14312
13419: LD_INT 5
13421: DOUBLE
13422: EQUAL
13423: IFTRUE 13427
13425: GO 13453
13427: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
13428: LD_ADDR_VAR 0 3
13432: PUSH
13433: LD_INT 2
13435: PUSH
13436: LD_INT 3
13438: PUSH
13439: LD_INT 4
13441: PUSH
13442: LD_INT 5
13444: PUSH
13445: EMPTY
13446: LIST
13447: LIST
13448: LIST
13449: LIST
13450: ST_TO_ADDR
13451: GO 14312
13453: LD_INT 9
13455: DOUBLE
13456: EQUAL
13457: IFTRUE 13461
13459: GO 13487
13461: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
13462: LD_ADDR_VAR 0 3
13466: PUSH
13467: LD_INT 2
13469: PUSH
13470: LD_INT 3
13472: PUSH
13473: LD_INT 4
13475: PUSH
13476: LD_INT 5
13478: PUSH
13479: EMPTY
13480: LIST
13481: LIST
13482: LIST
13483: LIST
13484: ST_TO_ADDR
13485: GO 14312
13487: LD_INT 7
13489: DOUBLE
13490: EQUAL
13491: IFTRUE 13495
13493: GO 13521
13495: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
13496: LD_ADDR_VAR 0 3
13500: PUSH
13501: LD_INT 2
13503: PUSH
13504: LD_INT 3
13506: PUSH
13507: LD_INT 4
13509: PUSH
13510: LD_INT 5
13512: PUSH
13513: EMPTY
13514: LIST
13515: LIST
13516: LIST
13517: LIST
13518: ST_TO_ADDR
13519: GO 14312
13521: LD_INT 12
13523: DOUBLE
13524: EQUAL
13525: IFTRUE 13529
13527: GO 13555
13529: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
13530: LD_ADDR_VAR 0 3
13534: PUSH
13535: LD_INT 2
13537: PUSH
13538: LD_INT 3
13540: PUSH
13541: LD_INT 4
13543: PUSH
13544: LD_INT 5
13546: PUSH
13547: EMPTY
13548: LIST
13549: LIST
13550: LIST
13551: LIST
13552: ST_TO_ADDR
13553: GO 14312
13555: LD_INT 13
13557: DOUBLE
13558: EQUAL
13559: IFTRUE 13563
13561: GO 13589
13563: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
13564: LD_ADDR_VAR 0 3
13568: PUSH
13569: LD_INT 2
13571: PUSH
13572: LD_INT 3
13574: PUSH
13575: LD_INT 4
13577: PUSH
13578: LD_INT 5
13580: PUSH
13581: EMPTY
13582: LIST
13583: LIST
13584: LIST
13585: LIST
13586: ST_TO_ADDR
13587: GO 14312
13589: LD_INT 14
13591: DOUBLE
13592: EQUAL
13593: IFTRUE 13597
13595: GO 13615
13597: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
13598: LD_ADDR_VAR 0 3
13602: PUSH
13603: LD_INT 4
13605: PUSH
13606: LD_INT 5
13608: PUSH
13609: EMPTY
13610: LIST
13611: LIST
13612: ST_TO_ADDR
13613: GO 14312
13615: LD_INT 6
13617: DOUBLE
13618: EQUAL
13619: IFTRUE 13623
13621: GO 13641
13623: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
13624: LD_ADDR_VAR 0 3
13628: PUSH
13629: LD_INT 4
13631: PUSH
13632: LD_INT 5
13634: PUSH
13635: EMPTY
13636: LIST
13637: LIST
13638: ST_TO_ADDR
13639: GO 14312
13641: LD_INT 10
13643: DOUBLE
13644: EQUAL
13645: IFTRUE 13649
13647: GO 13667
13649: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
13650: LD_ADDR_VAR 0 3
13654: PUSH
13655: LD_INT 4
13657: PUSH
13658: LD_INT 5
13660: PUSH
13661: EMPTY
13662: LIST
13663: LIST
13664: ST_TO_ADDR
13665: GO 14312
13667: LD_INT 22
13669: DOUBLE
13670: EQUAL
13671: IFTRUE 13675
13673: GO 13701
13675: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
13676: LD_ADDR_VAR 0 3
13680: PUSH
13681: LD_INT 11
13683: PUSH
13684: LD_INT 12
13686: PUSH
13687: LD_INT 13
13689: PUSH
13690: LD_INT 14
13692: PUSH
13693: EMPTY
13694: LIST
13695: LIST
13696: LIST
13697: LIST
13698: ST_TO_ADDR
13699: GO 14312
13701: LD_INT 23
13703: DOUBLE
13704: EQUAL
13705: IFTRUE 13709
13707: GO 13735
13709: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
13710: LD_ADDR_VAR 0 3
13714: PUSH
13715: LD_INT 11
13717: PUSH
13718: LD_INT 12
13720: PUSH
13721: LD_INT 13
13723: PUSH
13724: LD_INT 14
13726: PUSH
13727: EMPTY
13728: LIST
13729: LIST
13730: LIST
13731: LIST
13732: ST_TO_ADDR
13733: GO 14312
13735: LD_INT 24
13737: DOUBLE
13738: EQUAL
13739: IFTRUE 13743
13741: GO 13769
13743: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
13744: LD_ADDR_VAR 0 3
13748: PUSH
13749: LD_INT 11
13751: PUSH
13752: LD_INT 12
13754: PUSH
13755: LD_INT 13
13757: PUSH
13758: LD_INT 14
13760: PUSH
13761: EMPTY
13762: LIST
13763: LIST
13764: LIST
13765: LIST
13766: ST_TO_ADDR
13767: GO 14312
13769: LD_INT 30
13771: DOUBLE
13772: EQUAL
13773: IFTRUE 13777
13775: GO 13803
13777: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
13778: LD_ADDR_VAR 0 3
13782: PUSH
13783: LD_INT 11
13785: PUSH
13786: LD_INT 12
13788: PUSH
13789: LD_INT 13
13791: PUSH
13792: LD_INT 14
13794: PUSH
13795: EMPTY
13796: LIST
13797: LIST
13798: LIST
13799: LIST
13800: ST_TO_ADDR
13801: GO 14312
13803: LD_INT 25
13805: DOUBLE
13806: EQUAL
13807: IFTRUE 13811
13809: GO 13829
13811: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
13812: LD_ADDR_VAR 0 3
13816: PUSH
13817: LD_INT 13
13819: PUSH
13820: LD_INT 14
13822: PUSH
13823: EMPTY
13824: LIST
13825: LIST
13826: ST_TO_ADDR
13827: GO 14312
13829: LD_INT 27
13831: DOUBLE
13832: EQUAL
13833: IFTRUE 13837
13835: GO 13855
13837: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
13838: LD_ADDR_VAR 0 3
13842: PUSH
13843: LD_INT 13
13845: PUSH
13846: LD_INT 14
13848: PUSH
13849: EMPTY
13850: LIST
13851: LIST
13852: ST_TO_ADDR
13853: GO 14312
13855: LD_EXP 72
13859: DOUBLE
13860: EQUAL
13861: IFTRUE 13865
13863: GO 13891
13865: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
13866: LD_ADDR_VAR 0 3
13870: PUSH
13871: LD_INT 11
13873: PUSH
13874: LD_INT 12
13876: PUSH
13877: LD_INT 13
13879: PUSH
13880: LD_INT 14
13882: PUSH
13883: EMPTY
13884: LIST
13885: LIST
13886: LIST
13887: LIST
13888: ST_TO_ADDR
13889: GO 14312
13891: LD_INT 28
13893: DOUBLE
13894: EQUAL
13895: IFTRUE 13899
13897: GO 13917
13899: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
13900: LD_ADDR_VAR 0 3
13904: PUSH
13905: LD_INT 13
13907: PUSH
13908: LD_INT 14
13910: PUSH
13911: EMPTY
13912: LIST
13913: LIST
13914: ST_TO_ADDR
13915: GO 14312
13917: LD_INT 29
13919: DOUBLE
13920: EQUAL
13921: IFTRUE 13925
13923: GO 13943
13925: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
13926: LD_ADDR_VAR 0 3
13930: PUSH
13931: LD_INT 13
13933: PUSH
13934: LD_INT 14
13936: PUSH
13937: EMPTY
13938: LIST
13939: LIST
13940: ST_TO_ADDR
13941: GO 14312
13943: LD_INT 31
13945: DOUBLE
13946: EQUAL
13947: IFTRUE 13951
13949: GO 13969
13951: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
13952: LD_ADDR_VAR 0 3
13956: PUSH
13957: LD_INT 13
13959: PUSH
13960: LD_INT 14
13962: PUSH
13963: EMPTY
13964: LIST
13965: LIST
13966: ST_TO_ADDR
13967: GO 14312
13969: LD_INT 26
13971: DOUBLE
13972: EQUAL
13973: IFTRUE 13977
13975: GO 13995
13977: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
13978: LD_ADDR_VAR 0 3
13982: PUSH
13983: LD_INT 13
13985: PUSH
13986: LD_INT 14
13988: PUSH
13989: EMPTY
13990: LIST
13991: LIST
13992: ST_TO_ADDR
13993: GO 14312
13995: LD_INT 42
13997: DOUBLE
13998: EQUAL
13999: IFTRUE 14003
14001: GO 14029
14003: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
14004: LD_ADDR_VAR 0 3
14008: PUSH
14009: LD_INT 21
14011: PUSH
14012: LD_INT 22
14014: PUSH
14015: LD_INT 23
14017: PUSH
14018: LD_INT 24
14020: PUSH
14021: EMPTY
14022: LIST
14023: LIST
14024: LIST
14025: LIST
14026: ST_TO_ADDR
14027: GO 14312
14029: LD_INT 43
14031: DOUBLE
14032: EQUAL
14033: IFTRUE 14037
14035: GO 14063
14037: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
14038: LD_ADDR_VAR 0 3
14042: PUSH
14043: LD_INT 21
14045: PUSH
14046: LD_INT 22
14048: PUSH
14049: LD_INT 23
14051: PUSH
14052: LD_INT 24
14054: PUSH
14055: EMPTY
14056: LIST
14057: LIST
14058: LIST
14059: LIST
14060: ST_TO_ADDR
14061: GO 14312
14063: LD_INT 44
14065: DOUBLE
14066: EQUAL
14067: IFTRUE 14071
14069: GO 14097
14071: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
14072: LD_ADDR_VAR 0 3
14076: PUSH
14077: LD_INT 21
14079: PUSH
14080: LD_INT 22
14082: PUSH
14083: LD_INT 23
14085: PUSH
14086: LD_INT 24
14088: PUSH
14089: EMPTY
14090: LIST
14091: LIST
14092: LIST
14093: LIST
14094: ST_TO_ADDR
14095: GO 14312
14097: LD_INT 45
14099: DOUBLE
14100: EQUAL
14101: IFTRUE 14105
14103: GO 14131
14105: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
14106: LD_ADDR_VAR 0 3
14110: PUSH
14111: LD_INT 21
14113: PUSH
14114: LD_INT 22
14116: PUSH
14117: LD_INT 23
14119: PUSH
14120: LD_INT 24
14122: PUSH
14123: EMPTY
14124: LIST
14125: LIST
14126: LIST
14127: LIST
14128: ST_TO_ADDR
14129: GO 14312
14131: LD_INT 49
14133: DOUBLE
14134: EQUAL
14135: IFTRUE 14139
14137: GO 14165
14139: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
14140: LD_ADDR_VAR 0 3
14144: PUSH
14145: LD_INT 21
14147: PUSH
14148: LD_INT 22
14150: PUSH
14151: LD_INT 23
14153: PUSH
14154: LD_INT 24
14156: PUSH
14157: EMPTY
14158: LIST
14159: LIST
14160: LIST
14161: LIST
14162: ST_TO_ADDR
14163: GO 14312
14165: LD_INT 51
14167: DOUBLE
14168: EQUAL
14169: IFTRUE 14173
14171: GO 14199
14173: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
14174: LD_ADDR_VAR 0 3
14178: PUSH
14179: LD_INT 21
14181: PUSH
14182: LD_INT 22
14184: PUSH
14185: LD_INT 23
14187: PUSH
14188: LD_INT 24
14190: PUSH
14191: EMPTY
14192: LIST
14193: LIST
14194: LIST
14195: LIST
14196: ST_TO_ADDR
14197: GO 14312
14199: LD_INT 52
14201: DOUBLE
14202: EQUAL
14203: IFTRUE 14207
14205: GO 14233
14207: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
14208: LD_ADDR_VAR 0 3
14212: PUSH
14213: LD_INT 21
14215: PUSH
14216: LD_INT 22
14218: PUSH
14219: LD_INT 23
14221: PUSH
14222: LD_INT 24
14224: PUSH
14225: EMPTY
14226: LIST
14227: LIST
14228: LIST
14229: LIST
14230: ST_TO_ADDR
14231: GO 14312
14233: LD_INT 53
14235: DOUBLE
14236: EQUAL
14237: IFTRUE 14241
14239: GO 14259
14241: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
14242: LD_ADDR_VAR 0 3
14246: PUSH
14247: LD_INT 23
14249: PUSH
14250: LD_INT 24
14252: PUSH
14253: EMPTY
14254: LIST
14255: LIST
14256: ST_TO_ADDR
14257: GO 14312
14259: LD_INT 46
14261: DOUBLE
14262: EQUAL
14263: IFTRUE 14267
14265: GO 14285
14267: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
14268: LD_ADDR_VAR 0 3
14272: PUSH
14273: LD_INT 23
14275: PUSH
14276: LD_INT 24
14278: PUSH
14279: EMPTY
14280: LIST
14281: LIST
14282: ST_TO_ADDR
14283: GO 14312
14285: LD_INT 47
14287: DOUBLE
14288: EQUAL
14289: IFTRUE 14293
14291: GO 14311
14293: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
14294: LD_ADDR_VAR 0 3
14298: PUSH
14299: LD_INT 23
14301: PUSH
14302: LD_INT 24
14304: PUSH
14305: EMPTY
14306: LIST
14307: LIST
14308: ST_TO_ADDR
14309: GO 14312
14311: POP
// result := ( chassis in result ) ;
14312: LD_ADDR_VAR 0 3
14316: PUSH
14317: LD_VAR 0 1
14321: PUSH
14322: LD_VAR 0 3
14326: IN
14327: ST_TO_ADDR
// end ;
14328: LD_VAR 0 3
14332: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
14333: LD_INT 0
14335: PPUSH
14336: PPUSH
14337: PPUSH
14338: PPUSH
14339: PPUSH
14340: PPUSH
14341: PPUSH
// result := array ;
14342: LD_ADDR_VAR 0 5
14346: PUSH
14347: LD_VAR 0 1
14351: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
14352: LD_VAR 0 1
14356: NOT
14357: PUSH
14358: LD_VAR 0 2
14362: NOT
14363: OR
14364: PUSH
14365: LD_VAR 0 3
14369: NOT
14370: OR
14371: PUSH
14372: LD_VAR 0 2
14376: PUSH
14377: LD_VAR 0 1
14381: GREATER
14382: OR
14383: PUSH
14384: LD_VAR 0 3
14388: PUSH
14389: LD_VAR 0 1
14393: GREATER
14394: OR
14395: IFFALSE 14399
// exit ;
14397: GO 14695
// if direction then
14399: LD_VAR 0 4
14403: IFFALSE 14467
// begin d := 1 ;
14405: LD_ADDR_VAR 0 9
14409: PUSH
14410: LD_INT 1
14412: ST_TO_ADDR
// if i_from > i_to then
14413: LD_VAR 0 2
14417: PUSH
14418: LD_VAR 0 3
14422: GREATER
14423: IFFALSE 14449
// length := ( array - i_from ) + i_to else
14425: LD_ADDR_VAR 0 11
14429: PUSH
14430: LD_VAR 0 1
14434: PUSH
14435: LD_VAR 0 2
14439: MINUS
14440: PUSH
14441: LD_VAR 0 3
14445: PLUS
14446: ST_TO_ADDR
14447: GO 14465
// length := i_to - i_from ;
14449: LD_ADDR_VAR 0 11
14453: PUSH
14454: LD_VAR 0 3
14458: PUSH
14459: LD_VAR 0 2
14463: MINUS
14464: ST_TO_ADDR
// end else
14465: GO 14528
// begin d := - 1 ;
14467: LD_ADDR_VAR 0 9
14471: PUSH
14472: LD_INT 1
14474: NEG
14475: ST_TO_ADDR
// if i_from > i_to then
14476: LD_VAR 0 2
14480: PUSH
14481: LD_VAR 0 3
14485: GREATER
14486: IFFALSE 14506
// length := i_from - i_to else
14488: LD_ADDR_VAR 0 11
14492: PUSH
14493: LD_VAR 0 2
14497: PUSH
14498: LD_VAR 0 3
14502: MINUS
14503: ST_TO_ADDR
14504: GO 14528
// length := ( array - i_to ) + i_from ;
14506: LD_ADDR_VAR 0 11
14510: PUSH
14511: LD_VAR 0 1
14515: PUSH
14516: LD_VAR 0 3
14520: MINUS
14521: PUSH
14522: LD_VAR 0 2
14526: PLUS
14527: ST_TO_ADDR
// end ; if not length then
14528: LD_VAR 0 11
14532: NOT
14533: IFFALSE 14537
// exit ;
14535: GO 14695
// tmp := array ;
14537: LD_ADDR_VAR 0 10
14541: PUSH
14542: LD_VAR 0 1
14546: ST_TO_ADDR
// for i = 1 to length do
14547: LD_ADDR_VAR 0 6
14551: PUSH
14552: DOUBLE
14553: LD_INT 1
14555: DEC
14556: ST_TO_ADDR
14557: LD_VAR 0 11
14561: PUSH
14562: FOR_TO
14563: IFFALSE 14683
// begin for j = 1 to array do
14565: LD_ADDR_VAR 0 7
14569: PUSH
14570: DOUBLE
14571: LD_INT 1
14573: DEC
14574: ST_TO_ADDR
14575: LD_VAR 0 1
14579: PUSH
14580: FOR_TO
14581: IFFALSE 14669
// begin k := j + d ;
14583: LD_ADDR_VAR 0 8
14587: PUSH
14588: LD_VAR 0 7
14592: PUSH
14593: LD_VAR 0 9
14597: PLUS
14598: ST_TO_ADDR
// if k > array then
14599: LD_VAR 0 8
14603: PUSH
14604: LD_VAR 0 1
14608: GREATER
14609: IFFALSE 14619
// k := 1 ;
14611: LD_ADDR_VAR 0 8
14615: PUSH
14616: LD_INT 1
14618: ST_TO_ADDR
// if not k then
14619: LD_VAR 0 8
14623: NOT
14624: IFFALSE 14636
// k := array ;
14626: LD_ADDR_VAR 0 8
14630: PUSH
14631: LD_VAR 0 1
14635: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
14636: LD_ADDR_VAR 0 10
14640: PUSH
14641: LD_VAR 0 10
14645: PPUSH
14646: LD_VAR 0 8
14650: PPUSH
14651: LD_VAR 0 1
14655: PUSH
14656: LD_VAR 0 7
14660: ARRAY
14661: PPUSH
14662: CALL_OW 1
14666: ST_TO_ADDR
// end ;
14667: GO 14580
14669: POP
14670: POP
// array := tmp ;
14671: LD_ADDR_VAR 0 1
14675: PUSH
14676: LD_VAR 0 10
14680: ST_TO_ADDR
// end ;
14681: GO 14562
14683: POP
14684: POP
// result := array ;
14685: LD_ADDR_VAR 0 5
14689: PUSH
14690: LD_VAR 0 1
14694: ST_TO_ADDR
// end ;
14695: LD_VAR 0 5
14699: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
14700: LD_INT 0
14702: PPUSH
14703: PPUSH
// result := 0 ;
14704: LD_ADDR_VAR 0 3
14708: PUSH
14709: LD_INT 0
14711: ST_TO_ADDR
// if not array or not value in array then
14712: LD_VAR 0 1
14716: NOT
14717: PUSH
14718: LD_VAR 0 2
14722: PUSH
14723: LD_VAR 0 1
14727: IN
14728: NOT
14729: OR
14730: IFFALSE 14734
// exit ;
14732: GO 14788
// for i = 1 to array do
14734: LD_ADDR_VAR 0 4
14738: PUSH
14739: DOUBLE
14740: LD_INT 1
14742: DEC
14743: ST_TO_ADDR
14744: LD_VAR 0 1
14748: PUSH
14749: FOR_TO
14750: IFFALSE 14786
// if value = array [ i ] then
14752: LD_VAR 0 2
14756: PUSH
14757: LD_VAR 0 1
14761: PUSH
14762: LD_VAR 0 4
14766: ARRAY
14767: EQUAL
14768: IFFALSE 14784
// begin result := i ;
14770: LD_ADDR_VAR 0 3
14774: PUSH
14775: LD_VAR 0 4
14779: ST_TO_ADDR
// exit ;
14780: POP
14781: POP
14782: GO 14788
// end ;
14784: GO 14749
14786: POP
14787: POP
// end ;
14788: LD_VAR 0 3
14792: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
14793: LD_INT 0
14795: PPUSH
// vc_chassis := chassis ;
14796: LD_ADDR_OWVAR 37
14800: PUSH
14801: LD_VAR 0 1
14805: ST_TO_ADDR
// vc_engine := engine ;
14806: LD_ADDR_OWVAR 39
14810: PUSH
14811: LD_VAR 0 2
14815: ST_TO_ADDR
// vc_control := control ;
14816: LD_ADDR_OWVAR 38
14820: PUSH
14821: LD_VAR 0 3
14825: ST_TO_ADDR
// vc_weapon := weapon ;
14826: LD_ADDR_OWVAR 40
14830: PUSH
14831: LD_VAR 0 4
14835: ST_TO_ADDR
// vc_fuel_battery := fuel ;
14836: LD_ADDR_OWVAR 41
14840: PUSH
14841: LD_VAR 0 5
14845: ST_TO_ADDR
// end ;
14846: LD_VAR 0 6
14850: RET
// export function WantPlant ( unit ) ; var task ; begin
14851: LD_INT 0
14853: PPUSH
14854: PPUSH
// result := false ;
14855: LD_ADDR_VAR 0 2
14859: PUSH
14860: LD_INT 0
14862: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
14863: LD_ADDR_VAR 0 3
14867: PUSH
14868: LD_VAR 0 1
14872: PPUSH
14873: CALL_OW 437
14877: ST_TO_ADDR
// if task then
14878: LD_VAR 0 3
14882: IFFALSE 14910
// if task [ 1 ] [ 1 ] = p then
14884: LD_VAR 0 3
14888: PUSH
14889: LD_INT 1
14891: ARRAY
14892: PUSH
14893: LD_INT 1
14895: ARRAY
14896: PUSH
14897: LD_STRING p
14899: EQUAL
14900: IFFALSE 14910
// result := true ;
14902: LD_ADDR_VAR 0 2
14906: PUSH
14907: LD_INT 1
14909: ST_TO_ADDR
// end ;
14910: LD_VAR 0 2
14914: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
14915: LD_INT 0
14917: PPUSH
14918: PPUSH
14919: PPUSH
14920: PPUSH
// if pos < 1 then
14921: LD_VAR 0 2
14925: PUSH
14926: LD_INT 1
14928: LESS
14929: IFFALSE 14933
// exit ;
14931: GO 15236
// if pos = 1 then
14933: LD_VAR 0 2
14937: PUSH
14938: LD_INT 1
14940: EQUAL
14941: IFFALSE 14974
// result := Replace ( arr , pos [ 1 ] , value ) else
14943: LD_ADDR_VAR 0 4
14947: PUSH
14948: LD_VAR 0 1
14952: PPUSH
14953: LD_VAR 0 2
14957: PUSH
14958: LD_INT 1
14960: ARRAY
14961: PPUSH
14962: LD_VAR 0 3
14966: PPUSH
14967: CALL_OW 1
14971: ST_TO_ADDR
14972: GO 15236
// begin tmp := arr ;
14974: LD_ADDR_VAR 0 6
14978: PUSH
14979: LD_VAR 0 1
14983: ST_TO_ADDR
// s_arr := [ tmp ] ;
14984: LD_ADDR_VAR 0 7
14988: PUSH
14989: LD_VAR 0 6
14993: PUSH
14994: EMPTY
14995: LIST
14996: ST_TO_ADDR
// for i = 1 to pos - 1 do
14997: LD_ADDR_VAR 0 5
15001: PUSH
15002: DOUBLE
15003: LD_INT 1
15005: DEC
15006: ST_TO_ADDR
15007: LD_VAR 0 2
15011: PUSH
15012: LD_INT 1
15014: MINUS
15015: PUSH
15016: FOR_TO
15017: IFFALSE 15062
// begin tmp := tmp [ pos [ i ] ] ;
15019: LD_ADDR_VAR 0 6
15023: PUSH
15024: LD_VAR 0 6
15028: PUSH
15029: LD_VAR 0 2
15033: PUSH
15034: LD_VAR 0 5
15038: ARRAY
15039: ARRAY
15040: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
15041: LD_ADDR_VAR 0 7
15045: PUSH
15046: LD_VAR 0 7
15050: PUSH
15051: LD_VAR 0 6
15055: PUSH
15056: EMPTY
15057: LIST
15058: ADD
15059: ST_TO_ADDR
// end ;
15060: GO 15016
15062: POP
15063: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
15064: LD_ADDR_VAR 0 6
15068: PUSH
15069: LD_VAR 0 6
15073: PPUSH
15074: LD_VAR 0 2
15078: PUSH
15079: LD_VAR 0 2
15083: ARRAY
15084: PPUSH
15085: LD_VAR 0 3
15089: PPUSH
15090: CALL_OW 1
15094: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
15095: LD_ADDR_VAR 0 7
15099: PUSH
15100: LD_VAR 0 7
15104: PPUSH
15105: LD_VAR 0 7
15109: PPUSH
15110: LD_VAR 0 6
15114: PPUSH
15115: CALL_OW 1
15119: ST_TO_ADDR
// for i = s_arr downto 2 do
15120: LD_ADDR_VAR 0 5
15124: PUSH
15125: DOUBLE
15126: LD_VAR 0 7
15130: INC
15131: ST_TO_ADDR
15132: LD_INT 2
15134: PUSH
15135: FOR_DOWNTO
15136: IFFALSE 15220
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
15138: LD_ADDR_VAR 0 6
15142: PUSH
15143: LD_VAR 0 7
15147: PUSH
15148: LD_VAR 0 5
15152: PUSH
15153: LD_INT 1
15155: MINUS
15156: ARRAY
15157: PPUSH
15158: LD_VAR 0 2
15162: PUSH
15163: LD_VAR 0 5
15167: PUSH
15168: LD_INT 1
15170: MINUS
15171: ARRAY
15172: PPUSH
15173: LD_VAR 0 7
15177: PUSH
15178: LD_VAR 0 5
15182: ARRAY
15183: PPUSH
15184: CALL_OW 1
15188: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
15189: LD_ADDR_VAR 0 7
15193: PUSH
15194: LD_VAR 0 7
15198: PPUSH
15199: LD_VAR 0 5
15203: PUSH
15204: LD_INT 1
15206: MINUS
15207: PPUSH
15208: LD_VAR 0 6
15212: PPUSH
15213: CALL_OW 1
15217: ST_TO_ADDR
// end ;
15218: GO 15135
15220: POP
15221: POP
// result := s_arr [ 1 ] ;
15222: LD_ADDR_VAR 0 4
15226: PUSH
15227: LD_VAR 0 7
15231: PUSH
15232: LD_INT 1
15234: ARRAY
15235: ST_TO_ADDR
// end ; end ;
15236: LD_VAR 0 4
15240: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
15241: LD_INT 0
15243: PPUSH
15244: PPUSH
// if not list then
15245: LD_VAR 0 1
15249: NOT
15250: IFFALSE 15254
// exit ;
15252: GO 15345
// i := list [ pos1 ] ;
15254: LD_ADDR_VAR 0 5
15258: PUSH
15259: LD_VAR 0 1
15263: PUSH
15264: LD_VAR 0 2
15268: ARRAY
15269: ST_TO_ADDR
// if not i then
15270: LD_VAR 0 5
15274: NOT
15275: IFFALSE 15279
// exit ;
15277: GO 15345
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
15279: LD_ADDR_VAR 0 1
15283: PUSH
15284: LD_VAR 0 1
15288: PPUSH
15289: LD_VAR 0 2
15293: PPUSH
15294: LD_VAR 0 1
15298: PUSH
15299: LD_VAR 0 3
15303: ARRAY
15304: PPUSH
15305: CALL_OW 1
15309: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
15310: LD_ADDR_VAR 0 1
15314: PUSH
15315: LD_VAR 0 1
15319: PPUSH
15320: LD_VAR 0 3
15324: PPUSH
15325: LD_VAR 0 5
15329: PPUSH
15330: CALL_OW 1
15334: ST_TO_ADDR
// result := list ;
15335: LD_ADDR_VAR 0 4
15339: PUSH
15340: LD_VAR 0 1
15344: ST_TO_ADDR
// end ;
15345: LD_VAR 0 4
15349: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
15350: LD_INT 0
15352: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
15353: LD_ADDR_VAR 0 5
15357: PUSH
15358: LD_VAR 0 1
15362: PPUSH
15363: CALL_OW 250
15367: PPUSH
15368: LD_VAR 0 1
15372: PPUSH
15373: CALL_OW 251
15377: PPUSH
15378: LD_VAR 0 2
15382: PPUSH
15383: LD_VAR 0 3
15387: PPUSH
15388: LD_VAR 0 4
15392: PPUSH
15393: CALL 15403 0 5
15397: ST_TO_ADDR
// end ;
15398: LD_VAR 0 5
15402: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
15403: LD_INT 0
15405: PPUSH
15406: PPUSH
15407: PPUSH
15408: PPUSH
// if not list then
15409: LD_VAR 0 3
15413: NOT
15414: IFFALSE 15418
// exit ;
15416: GO 15806
// result := [ ] ;
15418: LD_ADDR_VAR 0 6
15422: PUSH
15423: EMPTY
15424: ST_TO_ADDR
// for i in list do
15425: LD_ADDR_VAR 0 7
15429: PUSH
15430: LD_VAR 0 3
15434: PUSH
15435: FOR_IN
15436: IFFALSE 15638
// begin tmp := GetDistUnitXY ( i , x , y ) ;
15438: LD_ADDR_VAR 0 9
15442: PUSH
15443: LD_VAR 0 7
15447: PPUSH
15448: LD_VAR 0 1
15452: PPUSH
15453: LD_VAR 0 2
15457: PPUSH
15458: CALL_OW 297
15462: ST_TO_ADDR
// if not result then
15463: LD_VAR 0 6
15467: NOT
15468: IFFALSE 15494
// result := [ [ i , tmp ] ] else
15470: LD_ADDR_VAR 0 6
15474: PUSH
15475: LD_VAR 0 7
15479: PUSH
15480: LD_VAR 0 9
15484: PUSH
15485: EMPTY
15486: LIST
15487: LIST
15488: PUSH
15489: EMPTY
15490: LIST
15491: ST_TO_ADDR
15492: GO 15636
// begin if result [ result ] [ 2 ] < tmp then
15494: LD_VAR 0 6
15498: PUSH
15499: LD_VAR 0 6
15503: ARRAY
15504: PUSH
15505: LD_INT 2
15507: ARRAY
15508: PUSH
15509: LD_VAR 0 9
15513: LESS
15514: IFFALSE 15556
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
15516: LD_ADDR_VAR 0 6
15520: PUSH
15521: LD_VAR 0 6
15525: PPUSH
15526: LD_VAR 0 6
15530: PUSH
15531: LD_INT 1
15533: PLUS
15534: PPUSH
15535: LD_VAR 0 7
15539: PUSH
15540: LD_VAR 0 9
15544: PUSH
15545: EMPTY
15546: LIST
15547: LIST
15548: PPUSH
15549: CALL_OW 2
15553: ST_TO_ADDR
15554: GO 15636
// for j = 1 to result do
15556: LD_ADDR_VAR 0 8
15560: PUSH
15561: DOUBLE
15562: LD_INT 1
15564: DEC
15565: ST_TO_ADDR
15566: LD_VAR 0 6
15570: PUSH
15571: FOR_TO
15572: IFFALSE 15634
// begin if tmp < result [ j ] [ 2 ] then
15574: LD_VAR 0 9
15578: PUSH
15579: LD_VAR 0 6
15583: PUSH
15584: LD_VAR 0 8
15588: ARRAY
15589: PUSH
15590: LD_INT 2
15592: ARRAY
15593: LESS
15594: IFFALSE 15632
// begin result := Insert ( result , j , [ i , tmp ] ) ;
15596: LD_ADDR_VAR 0 6
15600: PUSH
15601: LD_VAR 0 6
15605: PPUSH
15606: LD_VAR 0 8
15610: PPUSH
15611: LD_VAR 0 7
15615: PUSH
15616: LD_VAR 0 9
15620: PUSH
15621: EMPTY
15622: LIST
15623: LIST
15624: PPUSH
15625: CALL_OW 2
15629: ST_TO_ADDR
// break ;
15630: GO 15634
// end ; end ;
15632: GO 15571
15634: POP
15635: POP
// end ; end ;
15636: GO 15435
15638: POP
15639: POP
// if result and not asc then
15640: LD_VAR 0 6
15644: PUSH
15645: LD_VAR 0 4
15649: NOT
15650: AND
15651: IFFALSE 15726
// begin tmp := result ;
15653: LD_ADDR_VAR 0 9
15657: PUSH
15658: LD_VAR 0 6
15662: ST_TO_ADDR
// for i = tmp downto 1 do
15663: LD_ADDR_VAR 0 7
15667: PUSH
15668: DOUBLE
15669: LD_VAR 0 9
15673: INC
15674: ST_TO_ADDR
15675: LD_INT 1
15677: PUSH
15678: FOR_DOWNTO
15679: IFFALSE 15724
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
15681: LD_ADDR_VAR 0 6
15685: PUSH
15686: LD_VAR 0 6
15690: PPUSH
15691: LD_VAR 0 9
15695: PUSH
15696: LD_VAR 0 7
15700: MINUS
15701: PUSH
15702: LD_INT 1
15704: PLUS
15705: PPUSH
15706: LD_VAR 0 9
15710: PUSH
15711: LD_VAR 0 7
15715: ARRAY
15716: PPUSH
15717: CALL_OW 1
15721: ST_TO_ADDR
15722: GO 15678
15724: POP
15725: POP
// end ; tmp := [ ] ;
15726: LD_ADDR_VAR 0 9
15730: PUSH
15731: EMPTY
15732: ST_TO_ADDR
// if mode then
15733: LD_VAR 0 5
15737: IFFALSE 15806
// begin for i = 1 to result do
15739: LD_ADDR_VAR 0 7
15743: PUSH
15744: DOUBLE
15745: LD_INT 1
15747: DEC
15748: ST_TO_ADDR
15749: LD_VAR 0 6
15753: PUSH
15754: FOR_TO
15755: IFFALSE 15794
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
15757: LD_ADDR_VAR 0 9
15761: PUSH
15762: LD_VAR 0 9
15766: PPUSH
15767: LD_VAR 0 7
15771: PPUSH
15772: LD_VAR 0 6
15776: PUSH
15777: LD_VAR 0 7
15781: ARRAY
15782: PUSH
15783: LD_INT 1
15785: ARRAY
15786: PPUSH
15787: CALL_OW 1
15791: ST_TO_ADDR
15792: GO 15754
15794: POP
15795: POP
// result := tmp ;
15796: LD_ADDR_VAR 0 6
15800: PUSH
15801: LD_VAR 0 9
15805: ST_TO_ADDR
// end ; end ;
15806: LD_VAR 0 6
15810: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
15811: LD_INT 0
15813: PPUSH
15814: PPUSH
15815: PPUSH
15816: PPUSH
15817: PPUSH
15818: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
15819: LD_ADDR_VAR 0 5
15823: PUSH
15824: LD_INT 0
15826: PUSH
15827: LD_INT 0
15829: PUSH
15830: LD_INT 0
15832: PUSH
15833: EMPTY
15834: PUSH
15835: EMPTY
15836: LIST
15837: LIST
15838: LIST
15839: LIST
15840: ST_TO_ADDR
// if not x or not y then
15841: LD_VAR 0 2
15845: NOT
15846: PUSH
15847: LD_VAR 0 3
15851: NOT
15852: OR
15853: IFFALSE 15857
// exit ;
15855: GO 17509
// if not range then
15857: LD_VAR 0 4
15861: NOT
15862: IFFALSE 15872
// range := 10 ;
15864: LD_ADDR_VAR 0 4
15868: PUSH
15869: LD_INT 10
15871: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15872: LD_ADDR_VAR 0 8
15876: PUSH
15877: LD_INT 81
15879: PUSH
15880: LD_VAR 0 1
15884: PUSH
15885: EMPTY
15886: LIST
15887: LIST
15888: PUSH
15889: LD_INT 92
15891: PUSH
15892: LD_VAR 0 2
15896: PUSH
15897: LD_VAR 0 3
15901: PUSH
15902: LD_VAR 0 4
15906: PUSH
15907: EMPTY
15908: LIST
15909: LIST
15910: LIST
15911: LIST
15912: PUSH
15913: LD_INT 3
15915: PUSH
15916: LD_INT 21
15918: PUSH
15919: LD_INT 3
15921: PUSH
15922: EMPTY
15923: LIST
15924: LIST
15925: PUSH
15926: EMPTY
15927: LIST
15928: LIST
15929: PUSH
15930: EMPTY
15931: LIST
15932: LIST
15933: LIST
15934: PPUSH
15935: CALL_OW 69
15939: ST_TO_ADDR
// if not tmp then
15940: LD_VAR 0 8
15944: NOT
15945: IFFALSE 15949
// exit ;
15947: GO 17509
// for i in tmp do
15949: LD_ADDR_VAR 0 6
15953: PUSH
15954: LD_VAR 0 8
15958: PUSH
15959: FOR_IN
15960: IFFALSE 17484
// begin points := [ 0 , 0 , 0 ] ;
15962: LD_ADDR_VAR 0 9
15966: PUSH
15967: LD_INT 0
15969: PUSH
15970: LD_INT 0
15972: PUSH
15973: LD_INT 0
15975: PUSH
15976: EMPTY
15977: LIST
15978: LIST
15979: LIST
15980: ST_TO_ADDR
// bpoints := 1 ;
15981: LD_ADDR_VAR 0 10
15985: PUSH
15986: LD_INT 1
15988: ST_TO_ADDR
// case GetType ( i ) of unit_human :
15989: LD_VAR 0 6
15993: PPUSH
15994: CALL_OW 247
15998: PUSH
15999: LD_INT 1
16001: DOUBLE
16002: EQUAL
16003: IFTRUE 16007
16005: GO 16585
16007: POP
// begin if GetClass ( i ) = 1 then
16008: LD_VAR 0 6
16012: PPUSH
16013: CALL_OW 257
16017: PUSH
16018: LD_INT 1
16020: EQUAL
16021: IFFALSE 16042
// points := [ 10 , 5 , 3 ] ;
16023: LD_ADDR_VAR 0 9
16027: PUSH
16028: LD_INT 10
16030: PUSH
16031: LD_INT 5
16033: PUSH
16034: LD_INT 3
16036: PUSH
16037: EMPTY
16038: LIST
16039: LIST
16040: LIST
16041: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
16042: LD_VAR 0 6
16046: PPUSH
16047: CALL_OW 257
16051: PUSH
16052: LD_INT 2
16054: PUSH
16055: LD_INT 3
16057: PUSH
16058: LD_INT 4
16060: PUSH
16061: EMPTY
16062: LIST
16063: LIST
16064: LIST
16065: IN
16066: IFFALSE 16087
// points := [ 3 , 2 , 1 ] ;
16068: LD_ADDR_VAR 0 9
16072: PUSH
16073: LD_INT 3
16075: PUSH
16076: LD_INT 2
16078: PUSH
16079: LD_INT 1
16081: PUSH
16082: EMPTY
16083: LIST
16084: LIST
16085: LIST
16086: ST_TO_ADDR
// if GetClass ( i ) = 5 then
16087: LD_VAR 0 6
16091: PPUSH
16092: CALL_OW 257
16096: PUSH
16097: LD_INT 5
16099: EQUAL
16100: IFFALSE 16121
// points := [ 130 , 5 , 2 ] ;
16102: LD_ADDR_VAR 0 9
16106: PUSH
16107: LD_INT 130
16109: PUSH
16110: LD_INT 5
16112: PUSH
16113: LD_INT 2
16115: PUSH
16116: EMPTY
16117: LIST
16118: LIST
16119: LIST
16120: ST_TO_ADDR
// if GetClass ( i ) = 8 then
16121: LD_VAR 0 6
16125: PPUSH
16126: CALL_OW 257
16130: PUSH
16131: LD_INT 8
16133: EQUAL
16134: IFFALSE 16155
// points := [ 35 , 35 , 30 ] ;
16136: LD_ADDR_VAR 0 9
16140: PUSH
16141: LD_INT 35
16143: PUSH
16144: LD_INT 35
16146: PUSH
16147: LD_INT 30
16149: PUSH
16150: EMPTY
16151: LIST
16152: LIST
16153: LIST
16154: ST_TO_ADDR
// if GetClass ( i ) = 9 then
16155: LD_VAR 0 6
16159: PPUSH
16160: CALL_OW 257
16164: PUSH
16165: LD_INT 9
16167: EQUAL
16168: IFFALSE 16189
// points := [ 20 , 55 , 40 ] ;
16170: LD_ADDR_VAR 0 9
16174: PUSH
16175: LD_INT 20
16177: PUSH
16178: LD_INT 55
16180: PUSH
16181: LD_INT 40
16183: PUSH
16184: EMPTY
16185: LIST
16186: LIST
16187: LIST
16188: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
16189: LD_VAR 0 6
16193: PPUSH
16194: CALL_OW 257
16198: PUSH
16199: LD_INT 12
16201: PUSH
16202: LD_INT 16
16204: PUSH
16205: EMPTY
16206: LIST
16207: LIST
16208: IN
16209: IFFALSE 16230
// points := [ 5 , 3 , 2 ] ;
16211: LD_ADDR_VAR 0 9
16215: PUSH
16216: LD_INT 5
16218: PUSH
16219: LD_INT 3
16221: PUSH
16222: LD_INT 2
16224: PUSH
16225: EMPTY
16226: LIST
16227: LIST
16228: LIST
16229: ST_TO_ADDR
// if GetClass ( i ) = 17 then
16230: LD_VAR 0 6
16234: PPUSH
16235: CALL_OW 257
16239: PUSH
16240: LD_INT 17
16242: EQUAL
16243: IFFALSE 16264
// points := [ 100 , 50 , 75 ] ;
16245: LD_ADDR_VAR 0 9
16249: PUSH
16250: LD_INT 100
16252: PUSH
16253: LD_INT 50
16255: PUSH
16256: LD_INT 75
16258: PUSH
16259: EMPTY
16260: LIST
16261: LIST
16262: LIST
16263: ST_TO_ADDR
// if GetClass ( i ) = 15 then
16264: LD_VAR 0 6
16268: PPUSH
16269: CALL_OW 257
16273: PUSH
16274: LD_INT 15
16276: EQUAL
16277: IFFALSE 16298
// points := [ 10 , 5 , 3 ] ;
16279: LD_ADDR_VAR 0 9
16283: PUSH
16284: LD_INT 10
16286: PUSH
16287: LD_INT 5
16289: PUSH
16290: LD_INT 3
16292: PUSH
16293: EMPTY
16294: LIST
16295: LIST
16296: LIST
16297: ST_TO_ADDR
// if GetClass ( i ) = 14 then
16298: LD_VAR 0 6
16302: PPUSH
16303: CALL_OW 257
16307: PUSH
16308: LD_INT 14
16310: EQUAL
16311: IFFALSE 16332
// points := [ 10 , 0 , 0 ] ;
16313: LD_ADDR_VAR 0 9
16317: PUSH
16318: LD_INT 10
16320: PUSH
16321: LD_INT 0
16323: PUSH
16324: LD_INT 0
16326: PUSH
16327: EMPTY
16328: LIST
16329: LIST
16330: LIST
16331: ST_TO_ADDR
// if GetClass ( i ) = 11 then
16332: LD_VAR 0 6
16336: PPUSH
16337: CALL_OW 257
16341: PUSH
16342: LD_INT 11
16344: EQUAL
16345: IFFALSE 16366
// points := [ 30 , 10 , 5 ] ;
16347: LD_ADDR_VAR 0 9
16351: PUSH
16352: LD_INT 30
16354: PUSH
16355: LD_INT 10
16357: PUSH
16358: LD_INT 5
16360: PUSH
16361: EMPTY
16362: LIST
16363: LIST
16364: LIST
16365: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
16366: LD_VAR 0 1
16370: PPUSH
16371: LD_INT 5
16373: PPUSH
16374: CALL_OW 321
16378: PUSH
16379: LD_INT 2
16381: EQUAL
16382: IFFALSE 16399
// bpoints := bpoints * 1.8 ;
16384: LD_ADDR_VAR 0 10
16388: PUSH
16389: LD_VAR 0 10
16393: PUSH
16394: LD_REAL  1.80000000000000E+0000
16397: MUL
16398: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
16399: LD_VAR 0 6
16403: PPUSH
16404: CALL_OW 257
16408: PUSH
16409: LD_INT 1
16411: PUSH
16412: LD_INT 2
16414: PUSH
16415: LD_INT 3
16417: PUSH
16418: LD_INT 4
16420: PUSH
16421: EMPTY
16422: LIST
16423: LIST
16424: LIST
16425: LIST
16426: IN
16427: PUSH
16428: LD_VAR 0 1
16432: PPUSH
16433: LD_INT 51
16435: PPUSH
16436: CALL_OW 321
16440: PUSH
16441: LD_INT 2
16443: EQUAL
16444: AND
16445: IFFALSE 16462
// bpoints := bpoints * 1.2 ;
16447: LD_ADDR_VAR 0 10
16451: PUSH
16452: LD_VAR 0 10
16456: PUSH
16457: LD_REAL  1.20000000000000E+0000
16460: MUL
16461: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
16462: LD_VAR 0 6
16466: PPUSH
16467: CALL_OW 257
16471: PUSH
16472: LD_INT 5
16474: PUSH
16475: LD_INT 7
16477: PUSH
16478: LD_INT 9
16480: PUSH
16481: EMPTY
16482: LIST
16483: LIST
16484: LIST
16485: IN
16486: PUSH
16487: LD_VAR 0 1
16491: PPUSH
16492: LD_INT 52
16494: PPUSH
16495: CALL_OW 321
16499: PUSH
16500: LD_INT 2
16502: EQUAL
16503: AND
16504: IFFALSE 16521
// bpoints := bpoints * 1.5 ;
16506: LD_ADDR_VAR 0 10
16510: PUSH
16511: LD_VAR 0 10
16515: PUSH
16516: LD_REAL  1.50000000000000E+0000
16519: MUL
16520: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
16521: LD_VAR 0 1
16525: PPUSH
16526: LD_INT 66
16528: PPUSH
16529: CALL_OW 321
16533: PUSH
16534: LD_INT 2
16536: EQUAL
16537: IFFALSE 16554
// bpoints := bpoints * 1.1 ;
16539: LD_ADDR_VAR 0 10
16543: PUSH
16544: LD_VAR 0 10
16548: PUSH
16549: LD_REAL  1.10000000000000E+0000
16552: MUL
16553: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
16554: LD_ADDR_VAR 0 10
16558: PUSH
16559: LD_VAR 0 10
16563: PUSH
16564: LD_VAR 0 6
16568: PPUSH
16569: LD_INT 1
16571: PPUSH
16572: CALL_OW 259
16576: PUSH
16577: LD_REAL  1.15000000000000E+0000
16580: MUL
16581: MUL
16582: ST_TO_ADDR
// end ; unit_vehicle :
16583: GO 17413
16585: LD_INT 2
16587: DOUBLE
16588: EQUAL
16589: IFTRUE 16593
16591: GO 17401
16593: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
16594: LD_VAR 0 6
16598: PPUSH
16599: CALL_OW 264
16603: PUSH
16604: LD_INT 2
16606: PUSH
16607: LD_INT 42
16609: PUSH
16610: LD_INT 24
16612: PUSH
16613: EMPTY
16614: LIST
16615: LIST
16616: LIST
16617: IN
16618: IFFALSE 16639
// points := [ 25 , 5 , 3 ] ;
16620: LD_ADDR_VAR 0 9
16624: PUSH
16625: LD_INT 25
16627: PUSH
16628: LD_INT 5
16630: PUSH
16631: LD_INT 3
16633: PUSH
16634: EMPTY
16635: LIST
16636: LIST
16637: LIST
16638: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
16639: LD_VAR 0 6
16643: PPUSH
16644: CALL_OW 264
16648: PUSH
16649: LD_INT 4
16651: PUSH
16652: LD_INT 43
16654: PUSH
16655: LD_INT 25
16657: PUSH
16658: EMPTY
16659: LIST
16660: LIST
16661: LIST
16662: IN
16663: IFFALSE 16684
// points := [ 40 , 15 , 5 ] ;
16665: LD_ADDR_VAR 0 9
16669: PUSH
16670: LD_INT 40
16672: PUSH
16673: LD_INT 15
16675: PUSH
16676: LD_INT 5
16678: PUSH
16679: EMPTY
16680: LIST
16681: LIST
16682: LIST
16683: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
16684: LD_VAR 0 6
16688: PPUSH
16689: CALL_OW 264
16693: PUSH
16694: LD_INT 3
16696: PUSH
16697: LD_INT 23
16699: PUSH
16700: EMPTY
16701: LIST
16702: LIST
16703: IN
16704: IFFALSE 16725
// points := [ 7 , 25 , 8 ] ;
16706: LD_ADDR_VAR 0 9
16710: PUSH
16711: LD_INT 7
16713: PUSH
16714: LD_INT 25
16716: PUSH
16717: LD_INT 8
16719: PUSH
16720: EMPTY
16721: LIST
16722: LIST
16723: LIST
16724: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
16725: LD_VAR 0 6
16729: PPUSH
16730: CALL_OW 264
16734: PUSH
16735: LD_INT 5
16737: PUSH
16738: LD_INT 27
16740: PUSH
16741: LD_INT 44
16743: PUSH
16744: EMPTY
16745: LIST
16746: LIST
16747: LIST
16748: IN
16749: IFFALSE 16770
// points := [ 14 , 50 , 16 ] ;
16751: LD_ADDR_VAR 0 9
16755: PUSH
16756: LD_INT 14
16758: PUSH
16759: LD_INT 50
16761: PUSH
16762: LD_INT 16
16764: PUSH
16765: EMPTY
16766: LIST
16767: LIST
16768: LIST
16769: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
16770: LD_VAR 0 6
16774: PPUSH
16775: CALL_OW 264
16779: PUSH
16780: LD_INT 6
16782: PUSH
16783: LD_INT 46
16785: PUSH
16786: EMPTY
16787: LIST
16788: LIST
16789: IN
16790: IFFALSE 16811
// points := [ 32 , 120 , 70 ] ;
16792: LD_ADDR_VAR 0 9
16796: PUSH
16797: LD_INT 32
16799: PUSH
16800: LD_INT 120
16802: PUSH
16803: LD_INT 70
16805: PUSH
16806: EMPTY
16807: LIST
16808: LIST
16809: LIST
16810: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
16811: LD_VAR 0 6
16815: PPUSH
16816: CALL_OW 264
16820: PUSH
16821: LD_INT 7
16823: PUSH
16824: LD_INT 28
16826: PUSH
16827: LD_INT 45
16829: PUSH
16830: LD_EXP 72
16834: PUSH
16835: EMPTY
16836: LIST
16837: LIST
16838: LIST
16839: LIST
16840: IN
16841: IFFALSE 16862
// points := [ 35 , 20 , 45 ] ;
16843: LD_ADDR_VAR 0 9
16847: PUSH
16848: LD_INT 35
16850: PUSH
16851: LD_INT 20
16853: PUSH
16854: LD_INT 45
16856: PUSH
16857: EMPTY
16858: LIST
16859: LIST
16860: LIST
16861: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
16862: LD_VAR 0 6
16866: PPUSH
16867: CALL_OW 264
16871: PUSH
16872: LD_INT 47
16874: PUSH
16875: EMPTY
16876: LIST
16877: IN
16878: IFFALSE 16899
// points := [ 67 , 45 , 75 ] ;
16880: LD_ADDR_VAR 0 9
16884: PUSH
16885: LD_INT 67
16887: PUSH
16888: LD_INT 45
16890: PUSH
16891: LD_INT 75
16893: PUSH
16894: EMPTY
16895: LIST
16896: LIST
16897: LIST
16898: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
16899: LD_VAR 0 6
16903: PPUSH
16904: CALL_OW 264
16908: PUSH
16909: LD_INT 26
16911: PUSH
16912: EMPTY
16913: LIST
16914: IN
16915: IFFALSE 16936
// points := [ 120 , 30 , 80 ] ;
16917: LD_ADDR_VAR 0 9
16921: PUSH
16922: LD_INT 120
16924: PUSH
16925: LD_INT 30
16927: PUSH
16928: LD_INT 80
16930: PUSH
16931: EMPTY
16932: LIST
16933: LIST
16934: LIST
16935: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
16936: LD_VAR 0 6
16940: PPUSH
16941: CALL_OW 264
16945: PUSH
16946: LD_INT 22
16948: PUSH
16949: EMPTY
16950: LIST
16951: IN
16952: IFFALSE 16973
// points := [ 40 , 1 , 1 ] ;
16954: LD_ADDR_VAR 0 9
16958: PUSH
16959: LD_INT 40
16961: PUSH
16962: LD_INT 1
16964: PUSH
16965: LD_INT 1
16967: PUSH
16968: EMPTY
16969: LIST
16970: LIST
16971: LIST
16972: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
16973: LD_VAR 0 6
16977: PPUSH
16978: CALL_OW 264
16982: PUSH
16983: LD_INT 29
16985: PUSH
16986: EMPTY
16987: LIST
16988: IN
16989: IFFALSE 17010
// points := [ 70 , 200 , 400 ] ;
16991: LD_ADDR_VAR 0 9
16995: PUSH
16996: LD_INT 70
16998: PUSH
16999: LD_INT 200
17001: PUSH
17002: LD_INT 400
17004: PUSH
17005: EMPTY
17006: LIST
17007: LIST
17008: LIST
17009: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
17010: LD_VAR 0 6
17014: PPUSH
17015: CALL_OW 264
17019: PUSH
17020: LD_INT 14
17022: PUSH
17023: LD_INT 53
17025: PUSH
17026: EMPTY
17027: LIST
17028: LIST
17029: IN
17030: IFFALSE 17051
// points := [ 40 , 10 , 20 ] ;
17032: LD_ADDR_VAR 0 9
17036: PUSH
17037: LD_INT 40
17039: PUSH
17040: LD_INT 10
17042: PUSH
17043: LD_INT 20
17045: PUSH
17046: EMPTY
17047: LIST
17048: LIST
17049: LIST
17050: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
17051: LD_VAR 0 6
17055: PPUSH
17056: CALL_OW 264
17060: PUSH
17061: LD_INT 9
17063: PUSH
17064: EMPTY
17065: LIST
17066: IN
17067: IFFALSE 17088
// points := [ 5 , 70 , 20 ] ;
17069: LD_ADDR_VAR 0 9
17073: PUSH
17074: LD_INT 5
17076: PUSH
17077: LD_INT 70
17079: PUSH
17080: LD_INT 20
17082: PUSH
17083: EMPTY
17084: LIST
17085: LIST
17086: LIST
17087: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
17088: LD_VAR 0 6
17092: PPUSH
17093: CALL_OW 264
17097: PUSH
17098: LD_INT 10
17100: PUSH
17101: EMPTY
17102: LIST
17103: IN
17104: IFFALSE 17125
// points := [ 35 , 110 , 70 ] ;
17106: LD_ADDR_VAR 0 9
17110: PUSH
17111: LD_INT 35
17113: PUSH
17114: LD_INT 110
17116: PUSH
17117: LD_INT 70
17119: PUSH
17120: EMPTY
17121: LIST
17122: LIST
17123: LIST
17124: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
17125: LD_VAR 0 6
17129: PPUSH
17130: CALL_OW 265
17134: PUSH
17135: LD_INT 25
17137: EQUAL
17138: IFFALSE 17159
// points := [ 80 , 65 , 100 ] ;
17140: LD_ADDR_VAR 0 9
17144: PUSH
17145: LD_INT 80
17147: PUSH
17148: LD_INT 65
17150: PUSH
17151: LD_INT 100
17153: PUSH
17154: EMPTY
17155: LIST
17156: LIST
17157: LIST
17158: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
17159: LD_VAR 0 6
17163: PPUSH
17164: CALL_OW 263
17168: PUSH
17169: LD_INT 1
17171: EQUAL
17172: IFFALSE 17207
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
17174: LD_ADDR_VAR 0 10
17178: PUSH
17179: LD_VAR 0 10
17183: PUSH
17184: LD_VAR 0 6
17188: PPUSH
17189: CALL_OW 311
17193: PPUSH
17194: LD_INT 3
17196: PPUSH
17197: CALL_OW 259
17201: PUSH
17202: LD_INT 4
17204: MUL
17205: MUL
17206: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
17207: LD_VAR 0 6
17211: PPUSH
17212: CALL_OW 263
17216: PUSH
17217: LD_INT 2
17219: EQUAL
17220: IFFALSE 17271
// begin j := IsControledBy ( i ) ;
17222: LD_ADDR_VAR 0 7
17226: PUSH
17227: LD_VAR 0 6
17231: PPUSH
17232: CALL_OW 312
17236: ST_TO_ADDR
// if j then
17237: LD_VAR 0 7
17241: IFFALSE 17271
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
17243: LD_ADDR_VAR 0 10
17247: PUSH
17248: LD_VAR 0 10
17252: PUSH
17253: LD_VAR 0 7
17257: PPUSH
17258: LD_INT 3
17260: PPUSH
17261: CALL_OW 259
17265: PUSH
17266: LD_INT 3
17268: MUL
17269: MUL
17270: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
17271: LD_VAR 0 6
17275: PPUSH
17276: CALL_OW 264
17280: PUSH
17281: LD_INT 5
17283: PUSH
17284: LD_INT 6
17286: PUSH
17287: LD_INT 46
17289: PUSH
17290: LD_INT 44
17292: PUSH
17293: LD_INT 47
17295: PUSH
17296: LD_INT 45
17298: PUSH
17299: LD_INT 28
17301: PUSH
17302: LD_INT 7
17304: PUSH
17305: LD_INT 27
17307: PUSH
17308: LD_INT 29
17310: PUSH
17311: EMPTY
17312: LIST
17313: LIST
17314: LIST
17315: LIST
17316: LIST
17317: LIST
17318: LIST
17319: LIST
17320: LIST
17321: LIST
17322: IN
17323: PUSH
17324: LD_VAR 0 1
17328: PPUSH
17329: LD_INT 52
17331: PPUSH
17332: CALL_OW 321
17336: PUSH
17337: LD_INT 2
17339: EQUAL
17340: AND
17341: IFFALSE 17358
// bpoints := bpoints * 1.2 ;
17343: LD_ADDR_VAR 0 10
17347: PUSH
17348: LD_VAR 0 10
17352: PUSH
17353: LD_REAL  1.20000000000000E+0000
17356: MUL
17357: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
17358: LD_VAR 0 6
17362: PPUSH
17363: CALL_OW 264
17367: PUSH
17368: LD_INT 6
17370: PUSH
17371: LD_INT 46
17373: PUSH
17374: LD_INT 47
17376: PUSH
17377: EMPTY
17378: LIST
17379: LIST
17380: LIST
17381: IN
17382: IFFALSE 17399
// bpoints := bpoints * 1.2 ;
17384: LD_ADDR_VAR 0 10
17388: PUSH
17389: LD_VAR 0 10
17393: PUSH
17394: LD_REAL  1.20000000000000E+0000
17397: MUL
17398: ST_TO_ADDR
// end ; unit_building :
17399: GO 17413
17401: LD_INT 3
17403: DOUBLE
17404: EQUAL
17405: IFTRUE 17409
17407: GO 17412
17409: POP
// ; end ;
17410: GO 17413
17412: POP
// for j = 1 to 3 do
17413: LD_ADDR_VAR 0 7
17417: PUSH
17418: DOUBLE
17419: LD_INT 1
17421: DEC
17422: ST_TO_ADDR
17423: LD_INT 3
17425: PUSH
17426: FOR_TO
17427: IFFALSE 17480
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
17429: LD_ADDR_VAR 0 5
17433: PUSH
17434: LD_VAR 0 5
17438: PPUSH
17439: LD_VAR 0 7
17443: PPUSH
17444: LD_VAR 0 5
17448: PUSH
17449: LD_VAR 0 7
17453: ARRAY
17454: PUSH
17455: LD_VAR 0 9
17459: PUSH
17460: LD_VAR 0 7
17464: ARRAY
17465: PUSH
17466: LD_VAR 0 10
17470: MUL
17471: PLUS
17472: PPUSH
17473: CALL_OW 1
17477: ST_TO_ADDR
17478: GO 17426
17480: POP
17481: POP
// end ;
17482: GO 15959
17484: POP
17485: POP
// result := Replace ( result , 4 , tmp ) ;
17486: LD_ADDR_VAR 0 5
17490: PUSH
17491: LD_VAR 0 5
17495: PPUSH
17496: LD_INT 4
17498: PPUSH
17499: LD_VAR 0 8
17503: PPUSH
17504: CALL_OW 1
17508: ST_TO_ADDR
// end ;
17509: LD_VAR 0 5
17513: RET
// export function DangerAtRange ( unit , range ) ; begin
17514: LD_INT 0
17516: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
17517: LD_ADDR_VAR 0 3
17521: PUSH
17522: LD_VAR 0 1
17526: PPUSH
17527: CALL_OW 255
17531: PPUSH
17532: LD_VAR 0 1
17536: PPUSH
17537: CALL_OW 250
17541: PPUSH
17542: LD_VAR 0 1
17546: PPUSH
17547: CALL_OW 251
17551: PPUSH
17552: LD_VAR 0 2
17556: PPUSH
17557: CALL 15811 0 4
17561: ST_TO_ADDR
// end ;
17562: LD_VAR 0 3
17566: RET
// export function DangerInArea ( side , area ) ; begin
17567: LD_INT 0
17569: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
17570: LD_ADDR_VAR 0 3
17574: PUSH
17575: LD_VAR 0 2
17579: PPUSH
17580: LD_INT 81
17582: PUSH
17583: LD_VAR 0 1
17587: PUSH
17588: EMPTY
17589: LIST
17590: LIST
17591: PPUSH
17592: CALL_OW 70
17596: ST_TO_ADDR
// end ;
17597: LD_VAR 0 3
17601: RET
// export function IsExtension ( b ) ; begin
17602: LD_INT 0
17604: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
17605: LD_ADDR_VAR 0 2
17609: PUSH
17610: LD_VAR 0 1
17614: PUSH
17615: LD_INT 23
17617: PUSH
17618: LD_INT 20
17620: PUSH
17621: LD_INT 22
17623: PUSH
17624: LD_INT 17
17626: PUSH
17627: LD_INT 24
17629: PUSH
17630: LD_INT 21
17632: PUSH
17633: LD_INT 19
17635: PUSH
17636: LD_INT 16
17638: PUSH
17639: LD_INT 25
17641: PUSH
17642: LD_INT 18
17644: PUSH
17645: EMPTY
17646: LIST
17647: LIST
17648: LIST
17649: LIST
17650: LIST
17651: LIST
17652: LIST
17653: LIST
17654: LIST
17655: LIST
17656: IN
17657: ST_TO_ADDR
// end ;
17658: LD_VAR 0 2
17662: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
17663: LD_INT 0
17665: PPUSH
17666: PPUSH
17667: PPUSH
// result := [ ] ;
17668: LD_ADDR_VAR 0 4
17672: PUSH
17673: EMPTY
17674: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
17675: LD_ADDR_VAR 0 5
17679: PUSH
17680: LD_VAR 0 2
17684: PPUSH
17685: LD_INT 21
17687: PUSH
17688: LD_INT 3
17690: PUSH
17691: EMPTY
17692: LIST
17693: LIST
17694: PPUSH
17695: CALL_OW 70
17699: ST_TO_ADDR
// if not tmp then
17700: LD_VAR 0 5
17704: NOT
17705: IFFALSE 17709
// exit ;
17707: GO 17773
// if checkLink then
17709: LD_VAR 0 3
17713: IFFALSE 17763
// begin for i in tmp do
17715: LD_ADDR_VAR 0 6
17719: PUSH
17720: LD_VAR 0 5
17724: PUSH
17725: FOR_IN
17726: IFFALSE 17761
// if GetBase ( i ) <> base then
17728: LD_VAR 0 6
17732: PPUSH
17733: CALL_OW 274
17737: PUSH
17738: LD_VAR 0 1
17742: NONEQUAL
17743: IFFALSE 17759
// ComLinkToBase ( base , i ) ;
17745: LD_VAR 0 1
17749: PPUSH
17750: LD_VAR 0 6
17754: PPUSH
17755: CALL_OW 169
17759: GO 17725
17761: POP
17762: POP
// end ; result := tmp ;
17763: LD_ADDR_VAR 0 4
17767: PUSH
17768: LD_VAR 0 5
17772: ST_TO_ADDR
// end ;
17773: LD_VAR 0 4
17777: RET
// export function ComComplete ( units , b ) ; var i ; begin
17778: LD_INT 0
17780: PPUSH
17781: PPUSH
// if not units then
17782: LD_VAR 0 1
17786: NOT
17787: IFFALSE 17791
// exit ;
17789: GO 17881
// for i in units do
17791: LD_ADDR_VAR 0 4
17795: PUSH
17796: LD_VAR 0 1
17800: PUSH
17801: FOR_IN
17802: IFFALSE 17879
// if BuildingStatus ( b ) = bs_build then
17804: LD_VAR 0 2
17808: PPUSH
17809: CALL_OW 461
17813: PUSH
17814: LD_INT 1
17816: EQUAL
17817: IFFALSE 17877
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
17819: LD_VAR 0 4
17823: PPUSH
17824: LD_STRING h
17826: PUSH
17827: LD_VAR 0 2
17831: PPUSH
17832: CALL_OW 250
17836: PUSH
17837: LD_VAR 0 2
17841: PPUSH
17842: CALL_OW 251
17846: PUSH
17847: LD_VAR 0 2
17851: PUSH
17852: LD_INT 0
17854: PUSH
17855: LD_INT 0
17857: PUSH
17858: LD_INT 0
17860: PUSH
17861: EMPTY
17862: LIST
17863: LIST
17864: LIST
17865: LIST
17866: LIST
17867: LIST
17868: LIST
17869: PUSH
17870: EMPTY
17871: LIST
17872: PPUSH
17873: CALL_OW 446
17877: GO 17801
17879: POP
17880: POP
// end ;
17881: LD_VAR 0 3
17885: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
17886: LD_INT 0
17888: PPUSH
17889: PPUSH
17890: PPUSH
17891: PPUSH
17892: PPUSH
17893: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
17894: LD_VAR 0 1
17898: NOT
17899: PUSH
17900: LD_VAR 0 1
17904: PPUSH
17905: CALL_OW 263
17909: PUSH
17910: LD_INT 2
17912: EQUAL
17913: NOT
17914: OR
17915: IFFALSE 17919
// exit ;
17917: GO 18235
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
17919: LD_ADDR_VAR 0 6
17923: PUSH
17924: LD_INT 22
17926: PUSH
17927: LD_VAR 0 1
17931: PPUSH
17932: CALL_OW 255
17936: PUSH
17937: EMPTY
17938: LIST
17939: LIST
17940: PUSH
17941: LD_INT 2
17943: PUSH
17944: LD_INT 30
17946: PUSH
17947: LD_INT 36
17949: PUSH
17950: EMPTY
17951: LIST
17952: LIST
17953: PUSH
17954: LD_INT 34
17956: PUSH
17957: LD_INT 31
17959: PUSH
17960: EMPTY
17961: LIST
17962: LIST
17963: PUSH
17964: EMPTY
17965: LIST
17966: LIST
17967: LIST
17968: PUSH
17969: EMPTY
17970: LIST
17971: LIST
17972: PPUSH
17973: CALL_OW 69
17977: ST_TO_ADDR
// if not tmp then
17978: LD_VAR 0 6
17982: NOT
17983: IFFALSE 17987
// exit ;
17985: GO 18235
// result := [ ] ;
17987: LD_ADDR_VAR 0 2
17991: PUSH
17992: EMPTY
17993: ST_TO_ADDR
// for i in tmp do
17994: LD_ADDR_VAR 0 3
17998: PUSH
17999: LD_VAR 0 6
18003: PUSH
18004: FOR_IN
18005: IFFALSE 18076
// begin t := UnitsInside ( i ) ;
18007: LD_ADDR_VAR 0 4
18011: PUSH
18012: LD_VAR 0 3
18016: PPUSH
18017: CALL_OW 313
18021: ST_TO_ADDR
// if t then
18022: LD_VAR 0 4
18026: IFFALSE 18074
// for j in t do
18028: LD_ADDR_VAR 0 7
18032: PUSH
18033: LD_VAR 0 4
18037: PUSH
18038: FOR_IN
18039: IFFALSE 18072
// result := Insert ( result , result + 1 , j ) ;
18041: LD_ADDR_VAR 0 2
18045: PUSH
18046: LD_VAR 0 2
18050: PPUSH
18051: LD_VAR 0 2
18055: PUSH
18056: LD_INT 1
18058: PLUS
18059: PPUSH
18060: LD_VAR 0 7
18064: PPUSH
18065: CALL_OW 2
18069: ST_TO_ADDR
18070: GO 18038
18072: POP
18073: POP
// end ;
18074: GO 18004
18076: POP
18077: POP
// if not result then
18078: LD_VAR 0 2
18082: NOT
18083: IFFALSE 18087
// exit ;
18085: GO 18235
// mech := result [ 1 ] ;
18087: LD_ADDR_VAR 0 5
18091: PUSH
18092: LD_VAR 0 2
18096: PUSH
18097: LD_INT 1
18099: ARRAY
18100: ST_TO_ADDR
// if result > 1 then
18101: LD_VAR 0 2
18105: PUSH
18106: LD_INT 1
18108: GREATER
18109: IFFALSE 18221
// for i = 2 to result do
18111: LD_ADDR_VAR 0 3
18115: PUSH
18116: DOUBLE
18117: LD_INT 2
18119: DEC
18120: ST_TO_ADDR
18121: LD_VAR 0 2
18125: PUSH
18126: FOR_TO
18127: IFFALSE 18219
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
18129: LD_ADDR_VAR 0 4
18133: PUSH
18134: LD_VAR 0 2
18138: PUSH
18139: LD_VAR 0 3
18143: ARRAY
18144: PPUSH
18145: LD_INT 3
18147: PPUSH
18148: CALL_OW 259
18152: PUSH
18153: LD_VAR 0 2
18157: PUSH
18158: LD_VAR 0 3
18162: ARRAY
18163: PPUSH
18164: CALL_OW 432
18168: MINUS
18169: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
18170: LD_VAR 0 4
18174: PUSH
18175: LD_VAR 0 5
18179: PPUSH
18180: LD_INT 3
18182: PPUSH
18183: CALL_OW 259
18187: PUSH
18188: LD_VAR 0 5
18192: PPUSH
18193: CALL_OW 432
18197: MINUS
18198: GREATEREQUAL
18199: IFFALSE 18217
// mech := result [ i ] ;
18201: LD_ADDR_VAR 0 5
18205: PUSH
18206: LD_VAR 0 2
18210: PUSH
18211: LD_VAR 0 3
18215: ARRAY
18216: ST_TO_ADDR
// end ;
18217: GO 18126
18219: POP
18220: POP
// ComLinkTo ( vehicle , mech ) ;
18221: LD_VAR 0 1
18225: PPUSH
18226: LD_VAR 0 5
18230: PPUSH
18231: CALL_OW 135
// end ;
18235: LD_VAR 0 2
18239: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
18240: LD_INT 0
18242: PPUSH
18243: PPUSH
18244: PPUSH
18245: PPUSH
18246: PPUSH
18247: PPUSH
18248: PPUSH
18249: PPUSH
18250: PPUSH
18251: PPUSH
18252: PPUSH
18253: PPUSH
18254: PPUSH
// result := [ ] ;
18255: LD_ADDR_VAR 0 7
18259: PUSH
18260: EMPTY
18261: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
18262: LD_VAR 0 1
18266: PPUSH
18267: CALL_OW 266
18271: PUSH
18272: LD_INT 0
18274: PUSH
18275: LD_INT 1
18277: PUSH
18278: EMPTY
18279: LIST
18280: LIST
18281: IN
18282: NOT
18283: IFFALSE 18287
// exit ;
18285: GO 19921
// if name then
18287: LD_VAR 0 3
18291: IFFALSE 18307
// SetBName ( base_dep , name ) ;
18293: LD_VAR 0 1
18297: PPUSH
18298: LD_VAR 0 3
18302: PPUSH
18303: CALL_OW 500
// base := GetBase ( base_dep ) ;
18307: LD_ADDR_VAR 0 15
18311: PUSH
18312: LD_VAR 0 1
18316: PPUSH
18317: CALL_OW 274
18321: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
18322: LD_ADDR_VAR 0 16
18326: PUSH
18327: LD_VAR 0 1
18331: PPUSH
18332: CALL_OW 255
18336: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
18337: LD_ADDR_VAR 0 17
18341: PUSH
18342: LD_VAR 0 1
18346: PPUSH
18347: CALL_OW 248
18351: ST_TO_ADDR
// if sources then
18352: LD_VAR 0 5
18356: IFFALSE 18403
// for i = 1 to 3 do
18358: LD_ADDR_VAR 0 8
18362: PUSH
18363: DOUBLE
18364: LD_INT 1
18366: DEC
18367: ST_TO_ADDR
18368: LD_INT 3
18370: PUSH
18371: FOR_TO
18372: IFFALSE 18401
// AddResourceType ( base , i , sources [ i ] ) ;
18374: LD_VAR 0 15
18378: PPUSH
18379: LD_VAR 0 8
18383: PPUSH
18384: LD_VAR 0 5
18388: PUSH
18389: LD_VAR 0 8
18393: ARRAY
18394: PPUSH
18395: CALL_OW 276
18399: GO 18371
18401: POP
18402: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
18403: LD_ADDR_VAR 0 18
18407: PUSH
18408: LD_VAR 0 15
18412: PPUSH
18413: LD_VAR 0 2
18417: PPUSH
18418: LD_INT 1
18420: PPUSH
18421: CALL 17663 0 3
18425: ST_TO_ADDR
// InitHc ;
18426: CALL_OW 19
// InitUc ;
18430: CALL_OW 18
// uc_side := side ;
18434: LD_ADDR_OWVAR 20
18438: PUSH
18439: LD_VAR 0 16
18443: ST_TO_ADDR
// uc_nation := nation ;
18444: LD_ADDR_OWVAR 21
18448: PUSH
18449: LD_VAR 0 17
18453: ST_TO_ADDR
// if buildings then
18454: LD_VAR 0 18
18458: IFFALSE 19780
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
18460: LD_ADDR_VAR 0 19
18464: PUSH
18465: LD_VAR 0 18
18469: PPUSH
18470: LD_INT 2
18472: PUSH
18473: LD_INT 30
18475: PUSH
18476: LD_INT 29
18478: PUSH
18479: EMPTY
18480: LIST
18481: LIST
18482: PUSH
18483: LD_INT 30
18485: PUSH
18486: LD_INT 30
18488: PUSH
18489: EMPTY
18490: LIST
18491: LIST
18492: PUSH
18493: EMPTY
18494: LIST
18495: LIST
18496: LIST
18497: PPUSH
18498: CALL_OW 72
18502: ST_TO_ADDR
// if tmp then
18503: LD_VAR 0 19
18507: IFFALSE 18555
// for i in tmp do
18509: LD_ADDR_VAR 0 8
18513: PUSH
18514: LD_VAR 0 19
18518: PUSH
18519: FOR_IN
18520: IFFALSE 18553
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
18522: LD_VAR 0 8
18526: PPUSH
18527: CALL_OW 250
18531: PPUSH
18532: LD_VAR 0 8
18536: PPUSH
18537: CALL_OW 251
18541: PPUSH
18542: LD_VAR 0 16
18546: PPUSH
18547: CALL_OW 441
18551: GO 18519
18553: POP
18554: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
18555: LD_VAR 0 18
18559: PPUSH
18560: LD_INT 2
18562: PUSH
18563: LD_INT 30
18565: PUSH
18566: LD_INT 32
18568: PUSH
18569: EMPTY
18570: LIST
18571: LIST
18572: PUSH
18573: LD_INT 30
18575: PUSH
18576: LD_INT 33
18578: PUSH
18579: EMPTY
18580: LIST
18581: LIST
18582: PUSH
18583: EMPTY
18584: LIST
18585: LIST
18586: LIST
18587: PPUSH
18588: CALL_OW 72
18592: IFFALSE 18680
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
18594: LD_ADDR_VAR 0 8
18598: PUSH
18599: LD_VAR 0 18
18603: PPUSH
18604: LD_INT 2
18606: PUSH
18607: LD_INT 30
18609: PUSH
18610: LD_INT 32
18612: PUSH
18613: EMPTY
18614: LIST
18615: LIST
18616: PUSH
18617: LD_INT 30
18619: PUSH
18620: LD_INT 33
18622: PUSH
18623: EMPTY
18624: LIST
18625: LIST
18626: PUSH
18627: EMPTY
18628: LIST
18629: LIST
18630: LIST
18631: PPUSH
18632: CALL_OW 72
18636: PUSH
18637: FOR_IN
18638: IFFALSE 18678
// begin if not GetBWeapon ( i ) then
18640: LD_VAR 0 8
18644: PPUSH
18645: CALL_OW 269
18649: NOT
18650: IFFALSE 18676
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
18652: LD_VAR 0 8
18656: PPUSH
18657: LD_VAR 0 8
18661: PPUSH
18662: LD_VAR 0 2
18666: PPUSH
18667: CALL 19926 0 2
18671: PPUSH
18672: CALL_OW 431
// end ;
18676: GO 18637
18678: POP
18679: POP
// end ; for i = 1 to personel do
18680: LD_ADDR_VAR 0 8
18684: PUSH
18685: DOUBLE
18686: LD_INT 1
18688: DEC
18689: ST_TO_ADDR
18690: LD_VAR 0 6
18694: PUSH
18695: FOR_TO
18696: IFFALSE 19760
// begin if i > 4 then
18698: LD_VAR 0 8
18702: PUSH
18703: LD_INT 4
18705: GREATER
18706: IFFALSE 18710
// break ;
18708: GO 19760
// case i of 1 :
18710: LD_VAR 0 8
18714: PUSH
18715: LD_INT 1
18717: DOUBLE
18718: EQUAL
18719: IFTRUE 18723
18721: GO 18803
18723: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
18724: LD_ADDR_VAR 0 12
18728: PUSH
18729: LD_VAR 0 18
18733: PPUSH
18734: LD_INT 22
18736: PUSH
18737: LD_VAR 0 16
18741: PUSH
18742: EMPTY
18743: LIST
18744: LIST
18745: PUSH
18746: LD_INT 58
18748: PUSH
18749: EMPTY
18750: LIST
18751: PUSH
18752: LD_INT 2
18754: PUSH
18755: LD_INT 30
18757: PUSH
18758: LD_INT 32
18760: PUSH
18761: EMPTY
18762: LIST
18763: LIST
18764: PUSH
18765: LD_INT 30
18767: PUSH
18768: LD_INT 4
18770: PUSH
18771: EMPTY
18772: LIST
18773: LIST
18774: PUSH
18775: LD_INT 30
18777: PUSH
18778: LD_INT 5
18780: PUSH
18781: EMPTY
18782: LIST
18783: LIST
18784: PUSH
18785: EMPTY
18786: LIST
18787: LIST
18788: LIST
18789: LIST
18790: PUSH
18791: EMPTY
18792: LIST
18793: LIST
18794: LIST
18795: PPUSH
18796: CALL_OW 72
18800: ST_TO_ADDR
18801: GO 19025
18803: LD_INT 2
18805: DOUBLE
18806: EQUAL
18807: IFTRUE 18811
18809: GO 18873
18811: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
18812: LD_ADDR_VAR 0 12
18816: PUSH
18817: LD_VAR 0 18
18821: PPUSH
18822: LD_INT 22
18824: PUSH
18825: LD_VAR 0 16
18829: PUSH
18830: EMPTY
18831: LIST
18832: LIST
18833: PUSH
18834: LD_INT 2
18836: PUSH
18837: LD_INT 30
18839: PUSH
18840: LD_INT 0
18842: PUSH
18843: EMPTY
18844: LIST
18845: LIST
18846: PUSH
18847: LD_INT 30
18849: PUSH
18850: LD_INT 1
18852: PUSH
18853: EMPTY
18854: LIST
18855: LIST
18856: PUSH
18857: EMPTY
18858: LIST
18859: LIST
18860: LIST
18861: PUSH
18862: EMPTY
18863: LIST
18864: LIST
18865: PPUSH
18866: CALL_OW 72
18870: ST_TO_ADDR
18871: GO 19025
18873: LD_INT 3
18875: DOUBLE
18876: EQUAL
18877: IFTRUE 18881
18879: GO 18943
18881: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
18882: LD_ADDR_VAR 0 12
18886: PUSH
18887: LD_VAR 0 18
18891: PPUSH
18892: LD_INT 22
18894: PUSH
18895: LD_VAR 0 16
18899: PUSH
18900: EMPTY
18901: LIST
18902: LIST
18903: PUSH
18904: LD_INT 2
18906: PUSH
18907: LD_INT 30
18909: PUSH
18910: LD_INT 2
18912: PUSH
18913: EMPTY
18914: LIST
18915: LIST
18916: PUSH
18917: LD_INT 30
18919: PUSH
18920: LD_INT 3
18922: PUSH
18923: EMPTY
18924: LIST
18925: LIST
18926: PUSH
18927: EMPTY
18928: LIST
18929: LIST
18930: LIST
18931: PUSH
18932: EMPTY
18933: LIST
18934: LIST
18935: PPUSH
18936: CALL_OW 72
18940: ST_TO_ADDR
18941: GO 19025
18943: LD_INT 4
18945: DOUBLE
18946: EQUAL
18947: IFTRUE 18951
18949: GO 19024
18951: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
18952: LD_ADDR_VAR 0 12
18956: PUSH
18957: LD_VAR 0 18
18961: PPUSH
18962: LD_INT 22
18964: PUSH
18965: LD_VAR 0 16
18969: PUSH
18970: EMPTY
18971: LIST
18972: LIST
18973: PUSH
18974: LD_INT 2
18976: PUSH
18977: LD_INT 30
18979: PUSH
18980: LD_INT 6
18982: PUSH
18983: EMPTY
18984: LIST
18985: LIST
18986: PUSH
18987: LD_INT 30
18989: PUSH
18990: LD_INT 7
18992: PUSH
18993: EMPTY
18994: LIST
18995: LIST
18996: PUSH
18997: LD_INT 30
18999: PUSH
19000: LD_INT 8
19002: PUSH
19003: EMPTY
19004: LIST
19005: LIST
19006: PUSH
19007: EMPTY
19008: LIST
19009: LIST
19010: LIST
19011: LIST
19012: PUSH
19013: EMPTY
19014: LIST
19015: LIST
19016: PPUSH
19017: CALL_OW 72
19021: ST_TO_ADDR
19022: GO 19025
19024: POP
// if i = 1 then
19025: LD_VAR 0 8
19029: PUSH
19030: LD_INT 1
19032: EQUAL
19033: IFFALSE 19144
// begin tmp := [ ] ;
19035: LD_ADDR_VAR 0 19
19039: PUSH
19040: EMPTY
19041: ST_TO_ADDR
// for j in f do
19042: LD_ADDR_VAR 0 9
19046: PUSH
19047: LD_VAR 0 12
19051: PUSH
19052: FOR_IN
19053: IFFALSE 19126
// if GetBType ( j ) = b_bunker then
19055: LD_VAR 0 9
19059: PPUSH
19060: CALL_OW 266
19064: PUSH
19065: LD_INT 32
19067: EQUAL
19068: IFFALSE 19095
// tmp := Insert ( tmp , 1 , j ) else
19070: LD_ADDR_VAR 0 19
19074: PUSH
19075: LD_VAR 0 19
19079: PPUSH
19080: LD_INT 1
19082: PPUSH
19083: LD_VAR 0 9
19087: PPUSH
19088: CALL_OW 2
19092: ST_TO_ADDR
19093: GO 19124
// tmp := Insert ( tmp , tmp + 1 , j ) ;
19095: LD_ADDR_VAR 0 19
19099: PUSH
19100: LD_VAR 0 19
19104: PPUSH
19105: LD_VAR 0 19
19109: PUSH
19110: LD_INT 1
19112: PLUS
19113: PPUSH
19114: LD_VAR 0 9
19118: PPUSH
19119: CALL_OW 2
19123: ST_TO_ADDR
19124: GO 19052
19126: POP
19127: POP
// if tmp then
19128: LD_VAR 0 19
19132: IFFALSE 19144
// f := tmp ;
19134: LD_ADDR_VAR 0 12
19138: PUSH
19139: LD_VAR 0 19
19143: ST_TO_ADDR
// end ; x := personel [ i ] ;
19144: LD_ADDR_VAR 0 13
19148: PUSH
19149: LD_VAR 0 6
19153: PUSH
19154: LD_VAR 0 8
19158: ARRAY
19159: ST_TO_ADDR
// if x = - 1 then
19160: LD_VAR 0 13
19164: PUSH
19165: LD_INT 1
19167: NEG
19168: EQUAL
19169: IFFALSE 19378
// begin for j in f do
19171: LD_ADDR_VAR 0 9
19175: PUSH
19176: LD_VAR 0 12
19180: PUSH
19181: FOR_IN
19182: IFFALSE 19374
// repeat InitHc ;
19184: CALL_OW 19
// if GetBType ( j ) = b_barracks then
19188: LD_VAR 0 9
19192: PPUSH
19193: CALL_OW 266
19197: PUSH
19198: LD_INT 5
19200: EQUAL
19201: IFFALSE 19271
// begin if UnitsInside ( j ) < 3 then
19203: LD_VAR 0 9
19207: PPUSH
19208: CALL_OW 313
19212: PUSH
19213: LD_INT 3
19215: LESS
19216: IFFALSE 19252
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
19218: LD_INT 0
19220: PPUSH
19221: LD_INT 5
19223: PUSH
19224: LD_INT 8
19226: PUSH
19227: LD_INT 9
19229: PUSH
19230: EMPTY
19231: LIST
19232: LIST
19233: LIST
19234: PUSH
19235: LD_VAR 0 17
19239: ARRAY
19240: PPUSH
19241: LD_VAR 0 4
19245: PPUSH
19246: CALL_OW 380
19250: GO 19269
// PrepareHuman ( false , i , skill ) ;
19252: LD_INT 0
19254: PPUSH
19255: LD_VAR 0 8
19259: PPUSH
19260: LD_VAR 0 4
19264: PPUSH
19265: CALL_OW 380
// end else
19269: GO 19288
// PrepareHuman ( false , i , skill ) ;
19271: LD_INT 0
19273: PPUSH
19274: LD_VAR 0 8
19278: PPUSH
19279: LD_VAR 0 4
19283: PPUSH
19284: CALL_OW 380
// un := CreateHuman ;
19288: LD_ADDR_VAR 0 14
19292: PUSH
19293: CALL_OW 44
19297: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19298: LD_ADDR_VAR 0 7
19302: PUSH
19303: LD_VAR 0 7
19307: PPUSH
19308: LD_INT 1
19310: PPUSH
19311: LD_VAR 0 14
19315: PPUSH
19316: CALL_OW 2
19320: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
19321: LD_VAR 0 14
19325: PPUSH
19326: LD_VAR 0 9
19330: PPUSH
19331: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
19335: LD_VAR 0 9
19339: PPUSH
19340: CALL_OW 313
19344: PUSH
19345: LD_INT 6
19347: EQUAL
19348: PUSH
19349: LD_VAR 0 9
19353: PPUSH
19354: CALL_OW 266
19358: PUSH
19359: LD_INT 32
19361: PUSH
19362: LD_INT 31
19364: PUSH
19365: EMPTY
19366: LIST
19367: LIST
19368: IN
19369: OR
19370: IFFALSE 19184
19372: GO 19181
19374: POP
19375: POP
// end else
19376: GO 19758
// for j = 1 to x do
19378: LD_ADDR_VAR 0 9
19382: PUSH
19383: DOUBLE
19384: LD_INT 1
19386: DEC
19387: ST_TO_ADDR
19388: LD_VAR 0 13
19392: PUSH
19393: FOR_TO
19394: IFFALSE 19756
// begin InitHc ;
19396: CALL_OW 19
// if not f then
19400: LD_VAR 0 12
19404: NOT
19405: IFFALSE 19494
// begin PrepareHuman ( false , i , skill ) ;
19407: LD_INT 0
19409: PPUSH
19410: LD_VAR 0 8
19414: PPUSH
19415: LD_VAR 0 4
19419: PPUSH
19420: CALL_OW 380
// un := CreateHuman ;
19424: LD_ADDR_VAR 0 14
19428: PUSH
19429: CALL_OW 44
19433: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19434: LD_ADDR_VAR 0 7
19438: PUSH
19439: LD_VAR 0 7
19443: PPUSH
19444: LD_INT 1
19446: PPUSH
19447: LD_VAR 0 14
19451: PPUSH
19452: CALL_OW 2
19456: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
19457: LD_VAR 0 14
19461: PPUSH
19462: LD_VAR 0 1
19466: PPUSH
19467: CALL_OW 250
19471: PPUSH
19472: LD_VAR 0 1
19476: PPUSH
19477: CALL_OW 251
19481: PPUSH
19482: LD_INT 10
19484: PPUSH
19485: LD_INT 0
19487: PPUSH
19488: CALL_OW 50
// continue ;
19492: GO 19393
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
19494: LD_VAR 0 12
19498: PUSH
19499: LD_INT 1
19501: ARRAY
19502: PPUSH
19503: CALL_OW 313
19507: PUSH
19508: LD_VAR 0 12
19512: PUSH
19513: LD_INT 1
19515: ARRAY
19516: PPUSH
19517: CALL_OW 266
19521: PUSH
19522: LD_INT 32
19524: PUSH
19525: LD_INT 31
19527: PUSH
19528: EMPTY
19529: LIST
19530: LIST
19531: IN
19532: AND
19533: PUSH
19534: LD_VAR 0 12
19538: PUSH
19539: LD_INT 1
19541: ARRAY
19542: PPUSH
19543: CALL_OW 313
19547: PUSH
19548: LD_INT 6
19550: EQUAL
19551: OR
19552: IFFALSE 19572
// f := Delete ( f , 1 ) ;
19554: LD_ADDR_VAR 0 12
19558: PUSH
19559: LD_VAR 0 12
19563: PPUSH
19564: LD_INT 1
19566: PPUSH
19567: CALL_OW 3
19571: ST_TO_ADDR
// if not f then
19572: LD_VAR 0 12
19576: NOT
19577: IFFALSE 19595
// begin x := x + 2 ;
19579: LD_ADDR_VAR 0 13
19583: PUSH
19584: LD_VAR 0 13
19588: PUSH
19589: LD_INT 2
19591: PLUS
19592: ST_TO_ADDR
// continue ;
19593: GO 19393
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
19595: LD_VAR 0 12
19599: PUSH
19600: LD_INT 1
19602: ARRAY
19603: PPUSH
19604: CALL_OW 266
19608: PUSH
19609: LD_INT 5
19611: EQUAL
19612: IFFALSE 19686
// begin if UnitsInside ( f [ 1 ] ) < 3 then
19614: LD_VAR 0 12
19618: PUSH
19619: LD_INT 1
19621: ARRAY
19622: PPUSH
19623: CALL_OW 313
19627: PUSH
19628: LD_INT 3
19630: LESS
19631: IFFALSE 19667
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
19633: LD_INT 0
19635: PPUSH
19636: LD_INT 5
19638: PUSH
19639: LD_INT 8
19641: PUSH
19642: LD_INT 9
19644: PUSH
19645: EMPTY
19646: LIST
19647: LIST
19648: LIST
19649: PUSH
19650: LD_VAR 0 17
19654: ARRAY
19655: PPUSH
19656: LD_VAR 0 4
19660: PPUSH
19661: CALL_OW 380
19665: GO 19684
// PrepareHuman ( false , i , skill ) ;
19667: LD_INT 0
19669: PPUSH
19670: LD_VAR 0 8
19674: PPUSH
19675: LD_VAR 0 4
19679: PPUSH
19680: CALL_OW 380
// end else
19684: GO 19703
// PrepareHuman ( false , i , skill ) ;
19686: LD_INT 0
19688: PPUSH
19689: LD_VAR 0 8
19693: PPUSH
19694: LD_VAR 0 4
19698: PPUSH
19699: CALL_OW 380
// un := CreateHuman ;
19703: LD_ADDR_VAR 0 14
19707: PUSH
19708: CALL_OW 44
19712: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19713: LD_ADDR_VAR 0 7
19717: PUSH
19718: LD_VAR 0 7
19722: PPUSH
19723: LD_INT 1
19725: PPUSH
19726: LD_VAR 0 14
19730: PPUSH
19731: CALL_OW 2
19735: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
19736: LD_VAR 0 14
19740: PPUSH
19741: LD_VAR 0 12
19745: PUSH
19746: LD_INT 1
19748: ARRAY
19749: PPUSH
19750: CALL_OW 52
// end ;
19754: GO 19393
19756: POP
19757: POP
// end ;
19758: GO 18695
19760: POP
19761: POP
// result := result ^ buildings ;
19762: LD_ADDR_VAR 0 7
19766: PUSH
19767: LD_VAR 0 7
19771: PUSH
19772: LD_VAR 0 18
19776: ADD
19777: ST_TO_ADDR
// end else
19778: GO 19921
// begin for i = 1 to personel do
19780: LD_ADDR_VAR 0 8
19784: PUSH
19785: DOUBLE
19786: LD_INT 1
19788: DEC
19789: ST_TO_ADDR
19790: LD_VAR 0 6
19794: PUSH
19795: FOR_TO
19796: IFFALSE 19919
// begin if i > 4 then
19798: LD_VAR 0 8
19802: PUSH
19803: LD_INT 4
19805: GREATER
19806: IFFALSE 19810
// break ;
19808: GO 19919
// x := personel [ i ] ;
19810: LD_ADDR_VAR 0 13
19814: PUSH
19815: LD_VAR 0 6
19819: PUSH
19820: LD_VAR 0 8
19824: ARRAY
19825: ST_TO_ADDR
// if x = - 1 then
19826: LD_VAR 0 13
19830: PUSH
19831: LD_INT 1
19833: NEG
19834: EQUAL
19835: IFFALSE 19839
// continue ;
19837: GO 19795
// PrepareHuman ( false , i , skill ) ;
19839: LD_INT 0
19841: PPUSH
19842: LD_VAR 0 8
19846: PPUSH
19847: LD_VAR 0 4
19851: PPUSH
19852: CALL_OW 380
// un := CreateHuman ;
19856: LD_ADDR_VAR 0 14
19860: PUSH
19861: CALL_OW 44
19865: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
19866: LD_VAR 0 14
19870: PPUSH
19871: LD_VAR 0 1
19875: PPUSH
19876: CALL_OW 250
19880: PPUSH
19881: LD_VAR 0 1
19885: PPUSH
19886: CALL_OW 251
19890: PPUSH
19891: LD_INT 10
19893: PPUSH
19894: LD_INT 0
19896: PPUSH
19897: CALL_OW 50
// result := result ^ un ;
19901: LD_ADDR_VAR 0 7
19905: PUSH
19906: LD_VAR 0 7
19910: PUSH
19911: LD_VAR 0 14
19915: ADD
19916: ST_TO_ADDR
// end ;
19917: GO 19795
19919: POP
19920: POP
// end ; end ;
19921: LD_VAR 0 7
19925: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
19926: LD_INT 0
19928: PPUSH
19929: PPUSH
19930: PPUSH
19931: PPUSH
19932: PPUSH
19933: PPUSH
19934: PPUSH
19935: PPUSH
19936: PPUSH
19937: PPUSH
19938: PPUSH
19939: PPUSH
19940: PPUSH
19941: PPUSH
19942: PPUSH
19943: PPUSH
// result := false ;
19944: LD_ADDR_VAR 0 3
19948: PUSH
19949: LD_INT 0
19951: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
19952: LD_VAR 0 1
19956: NOT
19957: PUSH
19958: LD_VAR 0 1
19962: PPUSH
19963: CALL_OW 266
19967: PUSH
19968: LD_INT 32
19970: PUSH
19971: LD_INT 33
19973: PUSH
19974: EMPTY
19975: LIST
19976: LIST
19977: IN
19978: NOT
19979: OR
19980: IFFALSE 19984
// exit ;
19982: GO 21093
// nat := GetNation ( tower ) ;
19984: LD_ADDR_VAR 0 12
19988: PUSH
19989: LD_VAR 0 1
19993: PPUSH
19994: CALL_OW 248
19998: ST_TO_ADDR
// side := GetSide ( tower ) ;
19999: LD_ADDR_VAR 0 16
20003: PUSH
20004: LD_VAR 0 1
20008: PPUSH
20009: CALL_OW 255
20013: ST_TO_ADDR
// x := GetX ( tower ) ;
20014: LD_ADDR_VAR 0 10
20018: PUSH
20019: LD_VAR 0 1
20023: PPUSH
20024: CALL_OW 250
20028: ST_TO_ADDR
// y := GetY ( tower ) ;
20029: LD_ADDR_VAR 0 11
20033: PUSH
20034: LD_VAR 0 1
20038: PPUSH
20039: CALL_OW 251
20043: ST_TO_ADDR
// if not x or not y then
20044: LD_VAR 0 10
20048: NOT
20049: PUSH
20050: LD_VAR 0 11
20054: NOT
20055: OR
20056: IFFALSE 20060
// exit ;
20058: GO 21093
// weapon := 0 ;
20060: LD_ADDR_VAR 0 18
20064: PUSH
20065: LD_INT 0
20067: ST_TO_ADDR
// fac_list := [ ] ;
20068: LD_ADDR_VAR 0 17
20072: PUSH
20073: EMPTY
20074: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
20075: LD_ADDR_VAR 0 6
20079: PUSH
20080: LD_VAR 0 1
20084: PPUSH
20085: CALL_OW 274
20089: PPUSH
20090: LD_VAR 0 2
20094: PPUSH
20095: LD_INT 0
20097: PPUSH
20098: CALL 17663 0 3
20102: PPUSH
20103: LD_INT 30
20105: PUSH
20106: LD_INT 3
20108: PUSH
20109: EMPTY
20110: LIST
20111: LIST
20112: PPUSH
20113: CALL_OW 72
20117: ST_TO_ADDR
// if not factories then
20118: LD_VAR 0 6
20122: NOT
20123: IFFALSE 20127
// exit ;
20125: GO 21093
// for i in factories do
20127: LD_ADDR_VAR 0 8
20131: PUSH
20132: LD_VAR 0 6
20136: PUSH
20137: FOR_IN
20138: IFFALSE 20163
// fac_list := fac_list union AvailableWeaponList ( i ) ;
20140: LD_ADDR_VAR 0 17
20144: PUSH
20145: LD_VAR 0 17
20149: PUSH
20150: LD_VAR 0 8
20154: PPUSH
20155: CALL_OW 478
20159: UNION
20160: ST_TO_ADDR
20161: GO 20137
20163: POP
20164: POP
// if not fac_list then
20165: LD_VAR 0 17
20169: NOT
20170: IFFALSE 20174
// exit ;
20172: GO 21093
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
20174: LD_ADDR_VAR 0 5
20178: PUSH
20179: LD_INT 4
20181: PUSH
20182: LD_INT 5
20184: PUSH
20185: LD_INT 9
20187: PUSH
20188: LD_INT 10
20190: PUSH
20191: LD_INT 6
20193: PUSH
20194: LD_INT 7
20196: PUSH
20197: LD_INT 11
20199: PUSH
20200: EMPTY
20201: LIST
20202: LIST
20203: LIST
20204: LIST
20205: LIST
20206: LIST
20207: LIST
20208: PUSH
20209: LD_INT 27
20211: PUSH
20212: LD_INT 28
20214: PUSH
20215: LD_INT 26
20217: PUSH
20218: LD_INT 30
20220: PUSH
20221: EMPTY
20222: LIST
20223: LIST
20224: LIST
20225: LIST
20226: PUSH
20227: LD_INT 43
20229: PUSH
20230: LD_INT 44
20232: PUSH
20233: LD_INT 46
20235: PUSH
20236: LD_INT 45
20238: PUSH
20239: LD_INT 47
20241: PUSH
20242: LD_INT 49
20244: PUSH
20245: EMPTY
20246: LIST
20247: LIST
20248: LIST
20249: LIST
20250: LIST
20251: LIST
20252: PUSH
20253: EMPTY
20254: LIST
20255: LIST
20256: LIST
20257: PUSH
20258: LD_VAR 0 12
20262: ARRAY
20263: ST_TO_ADDR
// list := list isect fac_list ;
20264: LD_ADDR_VAR 0 5
20268: PUSH
20269: LD_VAR 0 5
20273: PUSH
20274: LD_VAR 0 17
20278: ISECT
20279: ST_TO_ADDR
// if not list then
20280: LD_VAR 0 5
20284: NOT
20285: IFFALSE 20289
// exit ;
20287: GO 21093
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
20289: LD_VAR 0 12
20293: PUSH
20294: LD_INT 3
20296: EQUAL
20297: PUSH
20298: LD_INT 49
20300: PUSH
20301: LD_VAR 0 5
20305: IN
20306: AND
20307: PUSH
20308: LD_INT 31
20310: PPUSH
20311: LD_VAR 0 16
20315: PPUSH
20316: CALL_OW 321
20320: PUSH
20321: LD_INT 2
20323: EQUAL
20324: AND
20325: IFFALSE 20385
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
20327: LD_INT 22
20329: PUSH
20330: LD_VAR 0 16
20334: PUSH
20335: EMPTY
20336: LIST
20337: LIST
20338: PUSH
20339: LD_INT 35
20341: PUSH
20342: LD_INT 49
20344: PUSH
20345: EMPTY
20346: LIST
20347: LIST
20348: PUSH
20349: LD_INT 91
20351: PUSH
20352: LD_VAR 0 1
20356: PUSH
20357: LD_INT 10
20359: PUSH
20360: EMPTY
20361: LIST
20362: LIST
20363: LIST
20364: PUSH
20365: EMPTY
20366: LIST
20367: LIST
20368: LIST
20369: PPUSH
20370: CALL_OW 69
20374: NOT
20375: IFFALSE 20385
// weapon := ru_time_lapser ;
20377: LD_ADDR_VAR 0 18
20381: PUSH
20382: LD_INT 49
20384: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
20385: LD_VAR 0 12
20389: PUSH
20390: LD_INT 1
20392: PUSH
20393: LD_INT 2
20395: PUSH
20396: EMPTY
20397: LIST
20398: LIST
20399: IN
20400: PUSH
20401: LD_INT 11
20403: PUSH
20404: LD_VAR 0 5
20408: IN
20409: PUSH
20410: LD_INT 30
20412: PUSH
20413: LD_VAR 0 5
20417: IN
20418: OR
20419: AND
20420: PUSH
20421: LD_INT 6
20423: PPUSH
20424: LD_VAR 0 16
20428: PPUSH
20429: CALL_OW 321
20433: PUSH
20434: LD_INT 2
20436: EQUAL
20437: AND
20438: IFFALSE 20603
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
20440: LD_INT 22
20442: PUSH
20443: LD_VAR 0 16
20447: PUSH
20448: EMPTY
20449: LIST
20450: LIST
20451: PUSH
20452: LD_INT 2
20454: PUSH
20455: LD_INT 35
20457: PUSH
20458: LD_INT 11
20460: PUSH
20461: EMPTY
20462: LIST
20463: LIST
20464: PUSH
20465: LD_INT 35
20467: PUSH
20468: LD_INT 30
20470: PUSH
20471: EMPTY
20472: LIST
20473: LIST
20474: PUSH
20475: EMPTY
20476: LIST
20477: LIST
20478: LIST
20479: PUSH
20480: LD_INT 91
20482: PUSH
20483: LD_VAR 0 1
20487: PUSH
20488: LD_INT 18
20490: PUSH
20491: EMPTY
20492: LIST
20493: LIST
20494: LIST
20495: PUSH
20496: EMPTY
20497: LIST
20498: LIST
20499: LIST
20500: PPUSH
20501: CALL_OW 69
20505: NOT
20506: PUSH
20507: LD_INT 22
20509: PUSH
20510: LD_VAR 0 16
20514: PUSH
20515: EMPTY
20516: LIST
20517: LIST
20518: PUSH
20519: LD_INT 2
20521: PUSH
20522: LD_INT 30
20524: PUSH
20525: LD_INT 32
20527: PUSH
20528: EMPTY
20529: LIST
20530: LIST
20531: PUSH
20532: LD_INT 30
20534: PUSH
20535: LD_INT 33
20537: PUSH
20538: EMPTY
20539: LIST
20540: LIST
20541: PUSH
20542: EMPTY
20543: LIST
20544: LIST
20545: LIST
20546: PUSH
20547: LD_INT 91
20549: PUSH
20550: LD_VAR 0 1
20554: PUSH
20555: LD_INT 12
20557: PUSH
20558: EMPTY
20559: LIST
20560: LIST
20561: LIST
20562: PUSH
20563: EMPTY
20564: LIST
20565: LIST
20566: LIST
20567: PUSH
20568: EMPTY
20569: LIST
20570: PPUSH
20571: CALL_OW 69
20575: PUSH
20576: LD_INT 2
20578: GREATER
20579: AND
20580: IFFALSE 20603
// weapon := [ us_radar , ar_radar ] [ nat ] ;
20582: LD_ADDR_VAR 0 18
20586: PUSH
20587: LD_INT 11
20589: PUSH
20590: LD_INT 30
20592: PUSH
20593: EMPTY
20594: LIST
20595: LIST
20596: PUSH
20597: LD_VAR 0 12
20601: ARRAY
20602: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
20603: LD_VAR 0 18
20607: NOT
20608: PUSH
20609: LD_INT 40
20611: PPUSH
20612: LD_VAR 0 16
20616: PPUSH
20617: CALL_OW 321
20621: PUSH
20622: LD_INT 2
20624: EQUAL
20625: AND
20626: PUSH
20627: LD_INT 7
20629: PUSH
20630: LD_VAR 0 5
20634: IN
20635: PUSH
20636: LD_INT 28
20638: PUSH
20639: LD_VAR 0 5
20643: IN
20644: OR
20645: PUSH
20646: LD_INT 45
20648: PUSH
20649: LD_VAR 0 5
20653: IN
20654: OR
20655: AND
20656: IFFALSE 20910
// begin hex := GetHexInfo ( x , y ) ;
20658: LD_ADDR_VAR 0 4
20662: PUSH
20663: LD_VAR 0 10
20667: PPUSH
20668: LD_VAR 0 11
20672: PPUSH
20673: CALL_OW 546
20677: ST_TO_ADDR
// if hex [ 1 ] then
20678: LD_VAR 0 4
20682: PUSH
20683: LD_INT 1
20685: ARRAY
20686: IFFALSE 20690
// exit ;
20688: GO 21093
// height := hex [ 2 ] ;
20690: LD_ADDR_VAR 0 15
20694: PUSH
20695: LD_VAR 0 4
20699: PUSH
20700: LD_INT 2
20702: ARRAY
20703: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
20704: LD_ADDR_VAR 0 14
20708: PUSH
20709: LD_INT 0
20711: PUSH
20712: LD_INT 2
20714: PUSH
20715: LD_INT 3
20717: PUSH
20718: LD_INT 5
20720: PUSH
20721: EMPTY
20722: LIST
20723: LIST
20724: LIST
20725: LIST
20726: ST_TO_ADDR
// for i in tmp do
20727: LD_ADDR_VAR 0 8
20731: PUSH
20732: LD_VAR 0 14
20736: PUSH
20737: FOR_IN
20738: IFFALSE 20908
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
20740: LD_ADDR_VAR 0 9
20744: PUSH
20745: LD_VAR 0 10
20749: PPUSH
20750: LD_VAR 0 8
20754: PPUSH
20755: LD_INT 5
20757: PPUSH
20758: CALL_OW 272
20762: PUSH
20763: LD_VAR 0 11
20767: PPUSH
20768: LD_VAR 0 8
20772: PPUSH
20773: LD_INT 5
20775: PPUSH
20776: CALL_OW 273
20780: PUSH
20781: EMPTY
20782: LIST
20783: LIST
20784: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
20785: LD_VAR 0 9
20789: PUSH
20790: LD_INT 1
20792: ARRAY
20793: PPUSH
20794: LD_VAR 0 9
20798: PUSH
20799: LD_INT 2
20801: ARRAY
20802: PPUSH
20803: CALL_OW 488
20807: IFFALSE 20906
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
20809: LD_ADDR_VAR 0 4
20813: PUSH
20814: LD_VAR 0 9
20818: PUSH
20819: LD_INT 1
20821: ARRAY
20822: PPUSH
20823: LD_VAR 0 9
20827: PUSH
20828: LD_INT 2
20830: ARRAY
20831: PPUSH
20832: CALL_OW 546
20836: ST_TO_ADDR
// if hex [ 1 ] then
20837: LD_VAR 0 4
20841: PUSH
20842: LD_INT 1
20844: ARRAY
20845: IFFALSE 20849
// continue ;
20847: GO 20737
// h := hex [ 2 ] ;
20849: LD_ADDR_VAR 0 13
20853: PUSH
20854: LD_VAR 0 4
20858: PUSH
20859: LD_INT 2
20861: ARRAY
20862: ST_TO_ADDR
// if h + 7 < height then
20863: LD_VAR 0 13
20867: PUSH
20868: LD_INT 7
20870: PLUS
20871: PUSH
20872: LD_VAR 0 15
20876: LESS
20877: IFFALSE 20906
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
20879: LD_ADDR_VAR 0 18
20883: PUSH
20884: LD_INT 7
20886: PUSH
20887: LD_INT 28
20889: PUSH
20890: LD_INT 45
20892: PUSH
20893: EMPTY
20894: LIST
20895: LIST
20896: LIST
20897: PUSH
20898: LD_VAR 0 12
20902: ARRAY
20903: ST_TO_ADDR
// break ;
20904: GO 20908
// end ; end ; end ;
20906: GO 20737
20908: POP
20909: POP
// end ; if not weapon then
20910: LD_VAR 0 18
20914: NOT
20915: IFFALSE 20975
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
20917: LD_ADDR_VAR 0 5
20921: PUSH
20922: LD_VAR 0 5
20926: PUSH
20927: LD_INT 11
20929: PUSH
20930: LD_INT 30
20932: PUSH
20933: LD_INT 49
20935: PUSH
20936: EMPTY
20937: LIST
20938: LIST
20939: LIST
20940: DIFF
20941: ST_TO_ADDR
// if not list then
20942: LD_VAR 0 5
20946: NOT
20947: IFFALSE 20951
// exit ;
20949: GO 21093
// weapon := list [ rand ( 1 , list ) ] ;
20951: LD_ADDR_VAR 0 18
20955: PUSH
20956: LD_VAR 0 5
20960: PUSH
20961: LD_INT 1
20963: PPUSH
20964: LD_VAR 0 5
20968: PPUSH
20969: CALL_OW 12
20973: ARRAY
20974: ST_TO_ADDR
// end ; if weapon then
20975: LD_VAR 0 18
20979: IFFALSE 21093
// begin tmp := CostOfWeapon ( weapon ) ;
20981: LD_ADDR_VAR 0 14
20985: PUSH
20986: LD_VAR 0 18
20990: PPUSH
20991: CALL_OW 451
20995: ST_TO_ADDR
// j := GetBase ( tower ) ;
20996: LD_ADDR_VAR 0 9
21000: PUSH
21001: LD_VAR 0 1
21005: PPUSH
21006: CALL_OW 274
21010: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
21011: LD_VAR 0 9
21015: PPUSH
21016: LD_INT 1
21018: PPUSH
21019: CALL_OW 275
21023: PUSH
21024: LD_VAR 0 14
21028: PUSH
21029: LD_INT 1
21031: ARRAY
21032: GREATEREQUAL
21033: PUSH
21034: LD_VAR 0 9
21038: PPUSH
21039: LD_INT 2
21041: PPUSH
21042: CALL_OW 275
21046: PUSH
21047: LD_VAR 0 14
21051: PUSH
21052: LD_INT 2
21054: ARRAY
21055: GREATEREQUAL
21056: AND
21057: PUSH
21058: LD_VAR 0 9
21062: PPUSH
21063: LD_INT 3
21065: PPUSH
21066: CALL_OW 275
21070: PUSH
21071: LD_VAR 0 14
21075: PUSH
21076: LD_INT 3
21078: ARRAY
21079: GREATEREQUAL
21080: AND
21081: IFFALSE 21093
// result := weapon ;
21083: LD_ADDR_VAR 0 3
21087: PUSH
21088: LD_VAR 0 18
21092: ST_TO_ADDR
// end ; end ;
21093: LD_VAR 0 3
21097: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
21098: LD_INT 0
21100: PPUSH
21101: PPUSH
// result := true ;
21102: LD_ADDR_VAR 0 3
21106: PUSH
21107: LD_INT 1
21109: ST_TO_ADDR
// if array1 = array2 then
21110: LD_VAR 0 1
21114: PUSH
21115: LD_VAR 0 2
21119: EQUAL
21120: IFFALSE 21180
// begin for i = 1 to array1 do
21122: LD_ADDR_VAR 0 4
21126: PUSH
21127: DOUBLE
21128: LD_INT 1
21130: DEC
21131: ST_TO_ADDR
21132: LD_VAR 0 1
21136: PUSH
21137: FOR_TO
21138: IFFALSE 21176
// if array1 [ i ] <> array2 [ i ] then
21140: LD_VAR 0 1
21144: PUSH
21145: LD_VAR 0 4
21149: ARRAY
21150: PUSH
21151: LD_VAR 0 2
21155: PUSH
21156: LD_VAR 0 4
21160: ARRAY
21161: NONEQUAL
21162: IFFALSE 21174
// begin result := false ;
21164: LD_ADDR_VAR 0 3
21168: PUSH
21169: LD_INT 0
21171: ST_TO_ADDR
// break ;
21172: GO 21176
// end ;
21174: GO 21137
21176: POP
21177: POP
// end else
21178: GO 21188
// result := false ;
21180: LD_ADDR_VAR 0 3
21184: PUSH
21185: LD_INT 0
21187: ST_TO_ADDR
// end ;
21188: LD_VAR 0 3
21192: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
21193: LD_INT 0
21195: PPUSH
21196: PPUSH
// if not array1 or not array2 then
21197: LD_VAR 0 1
21201: NOT
21202: PUSH
21203: LD_VAR 0 2
21207: NOT
21208: OR
21209: IFFALSE 21213
// exit ;
21211: GO 21277
// result := true ;
21213: LD_ADDR_VAR 0 3
21217: PUSH
21218: LD_INT 1
21220: ST_TO_ADDR
// for i = 1 to array1 do
21221: LD_ADDR_VAR 0 4
21225: PUSH
21226: DOUBLE
21227: LD_INT 1
21229: DEC
21230: ST_TO_ADDR
21231: LD_VAR 0 1
21235: PUSH
21236: FOR_TO
21237: IFFALSE 21275
// if array1 [ i ] <> array2 [ i ] then
21239: LD_VAR 0 1
21243: PUSH
21244: LD_VAR 0 4
21248: ARRAY
21249: PUSH
21250: LD_VAR 0 2
21254: PUSH
21255: LD_VAR 0 4
21259: ARRAY
21260: NONEQUAL
21261: IFFALSE 21273
// begin result := false ;
21263: LD_ADDR_VAR 0 3
21267: PUSH
21268: LD_INT 0
21270: ST_TO_ADDR
// break ;
21271: GO 21275
// end ;
21273: GO 21236
21275: POP
21276: POP
// end ;
21277: LD_VAR 0 3
21281: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
21282: LD_INT 0
21284: PPUSH
21285: PPUSH
21286: PPUSH
// pom := GetBase ( fac ) ;
21287: LD_ADDR_VAR 0 5
21291: PUSH
21292: LD_VAR 0 1
21296: PPUSH
21297: CALL_OW 274
21301: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
21302: LD_ADDR_VAR 0 4
21306: PUSH
21307: LD_VAR 0 2
21311: PUSH
21312: LD_INT 1
21314: ARRAY
21315: PPUSH
21316: LD_VAR 0 2
21320: PUSH
21321: LD_INT 2
21323: ARRAY
21324: PPUSH
21325: LD_VAR 0 2
21329: PUSH
21330: LD_INT 3
21332: ARRAY
21333: PPUSH
21334: LD_VAR 0 2
21338: PUSH
21339: LD_INT 4
21341: ARRAY
21342: PPUSH
21343: CALL_OW 449
21347: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21348: LD_ADDR_VAR 0 3
21352: PUSH
21353: LD_VAR 0 5
21357: PPUSH
21358: LD_INT 1
21360: PPUSH
21361: CALL_OW 275
21365: PUSH
21366: LD_VAR 0 4
21370: PUSH
21371: LD_INT 1
21373: ARRAY
21374: GREATEREQUAL
21375: PUSH
21376: LD_VAR 0 5
21380: PPUSH
21381: LD_INT 2
21383: PPUSH
21384: CALL_OW 275
21388: PUSH
21389: LD_VAR 0 4
21393: PUSH
21394: LD_INT 2
21396: ARRAY
21397: GREATEREQUAL
21398: AND
21399: PUSH
21400: LD_VAR 0 5
21404: PPUSH
21405: LD_INT 3
21407: PPUSH
21408: CALL_OW 275
21412: PUSH
21413: LD_VAR 0 4
21417: PUSH
21418: LD_INT 3
21420: ARRAY
21421: GREATEREQUAL
21422: AND
21423: ST_TO_ADDR
// end ;
21424: LD_VAR 0 3
21428: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
21429: LD_INT 0
21431: PPUSH
21432: PPUSH
21433: PPUSH
21434: PPUSH
// pom := GetBase ( building ) ;
21435: LD_ADDR_VAR 0 3
21439: PUSH
21440: LD_VAR 0 1
21444: PPUSH
21445: CALL_OW 274
21449: ST_TO_ADDR
// if not pom then
21450: LD_VAR 0 3
21454: NOT
21455: IFFALSE 21459
// exit ;
21457: GO 21629
// btype := GetBType ( building ) ;
21459: LD_ADDR_VAR 0 5
21463: PUSH
21464: LD_VAR 0 1
21468: PPUSH
21469: CALL_OW 266
21473: ST_TO_ADDR
// if btype = b_armoury then
21474: LD_VAR 0 5
21478: PUSH
21479: LD_INT 4
21481: EQUAL
21482: IFFALSE 21492
// btype := b_barracks ;
21484: LD_ADDR_VAR 0 5
21488: PUSH
21489: LD_INT 5
21491: ST_TO_ADDR
// if btype = b_depot then
21492: LD_VAR 0 5
21496: PUSH
21497: LD_INT 0
21499: EQUAL
21500: IFFALSE 21510
// btype := b_warehouse ;
21502: LD_ADDR_VAR 0 5
21506: PUSH
21507: LD_INT 1
21509: ST_TO_ADDR
// if btype = b_workshop then
21510: LD_VAR 0 5
21514: PUSH
21515: LD_INT 2
21517: EQUAL
21518: IFFALSE 21528
// btype := b_factory ;
21520: LD_ADDR_VAR 0 5
21524: PUSH
21525: LD_INT 3
21527: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
21528: LD_ADDR_VAR 0 4
21532: PUSH
21533: LD_VAR 0 5
21537: PPUSH
21538: LD_VAR 0 1
21542: PPUSH
21543: CALL_OW 248
21547: PPUSH
21548: CALL_OW 450
21552: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21553: LD_ADDR_VAR 0 2
21557: PUSH
21558: LD_VAR 0 3
21562: PPUSH
21563: LD_INT 1
21565: PPUSH
21566: CALL_OW 275
21570: PUSH
21571: LD_VAR 0 4
21575: PUSH
21576: LD_INT 1
21578: ARRAY
21579: GREATEREQUAL
21580: PUSH
21581: LD_VAR 0 3
21585: PPUSH
21586: LD_INT 2
21588: PPUSH
21589: CALL_OW 275
21593: PUSH
21594: LD_VAR 0 4
21598: PUSH
21599: LD_INT 2
21601: ARRAY
21602: GREATEREQUAL
21603: AND
21604: PUSH
21605: LD_VAR 0 3
21609: PPUSH
21610: LD_INT 3
21612: PPUSH
21613: CALL_OW 275
21617: PUSH
21618: LD_VAR 0 4
21622: PUSH
21623: LD_INT 3
21625: ARRAY
21626: GREATEREQUAL
21627: AND
21628: ST_TO_ADDR
// end ;
21629: LD_VAR 0 2
21633: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
21634: LD_INT 0
21636: PPUSH
21637: PPUSH
21638: PPUSH
// pom := GetBase ( building ) ;
21639: LD_ADDR_VAR 0 4
21643: PUSH
21644: LD_VAR 0 1
21648: PPUSH
21649: CALL_OW 274
21653: ST_TO_ADDR
// if not pom then
21654: LD_VAR 0 4
21658: NOT
21659: IFFALSE 21663
// exit ;
21661: GO 21764
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
21663: LD_ADDR_VAR 0 5
21667: PUSH
21668: LD_VAR 0 2
21672: PPUSH
21673: LD_VAR 0 1
21677: PPUSH
21678: CALL_OW 248
21682: PPUSH
21683: CALL_OW 450
21687: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21688: LD_ADDR_VAR 0 3
21692: PUSH
21693: LD_VAR 0 4
21697: PPUSH
21698: LD_INT 1
21700: PPUSH
21701: CALL_OW 275
21705: PUSH
21706: LD_VAR 0 5
21710: PUSH
21711: LD_INT 1
21713: ARRAY
21714: GREATEREQUAL
21715: PUSH
21716: LD_VAR 0 4
21720: PPUSH
21721: LD_INT 2
21723: PPUSH
21724: CALL_OW 275
21728: PUSH
21729: LD_VAR 0 5
21733: PUSH
21734: LD_INT 2
21736: ARRAY
21737: GREATEREQUAL
21738: AND
21739: PUSH
21740: LD_VAR 0 4
21744: PPUSH
21745: LD_INT 3
21747: PPUSH
21748: CALL_OW 275
21752: PUSH
21753: LD_VAR 0 5
21757: PUSH
21758: LD_INT 3
21760: ARRAY
21761: GREATEREQUAL
21762: AND
21763: ST_TO_ADDR
// end ;
21764: LD_VAR 0 3
21768: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
21769: LD_INT 0
21771: PPUSH
21772: PPUSH
21773: PPUSH
21774: PPUSH
21775: PPUSH
21776: PPUSH
21777: PPUSH
21778: PPUSH
21779: PPUSH
21780: PPUSH
21781: PPUSH
// result := false ;
21782: LD_ADDR_VAR 0 8
21786: PUSH
21787: LD_INT 0
21789: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
21790: LD_VAR 0 5
21794: NOT
21795: PUSH
21796: LD_VAR 0 1
21800: NOT
21801: OR
21802: PUSH
21803: LD_VAR 0 2
21807: NOT
21808: OR
21809: PUSH
21810: LD_VAR 0 3
21814: NOT
21815: OR
21816: IFFALSE 21820
// exit ;
21818: GO 22634
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
21820: LD_ADDR_VAR 0 14
21824: PUSH
21825: LD_VAR 0 1
21829: PPUSH
21830: LD_VAR 0 2
21834: PPUSH
21835: LD_VAR 0 3
21839: PPUSH
21840: LD_VAR 0 4
21844: PPUSH
21845: LD_VAR 0 5
21849: PUSH
21850: LD_INT 1
21852: ARRAY
21853: PPUSH
21854: CALL_OW 248
21858: PPUSH
21859: LD_INT 0
21861: PPUSH
21862: CALL 23871 0 6
21866: ST_TO_ADDR
// if not hexes then
21867: LD_VAR 0 14
21871: NOT
21872: IFFALSE 21876
// exit ;
21874: GO 22634
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
21876: LD_ADDR_VAR 0 17
21880: PUSH
21881: LD_VAR 0 5
21885: PPUSH
21886: LD_INT 22
21888: PUSH
21889: LD_VAR 0 13
21893: PPUSH
21894: CALL_OW 255
21898: PUSH
21899: EMPTY
21900: LIST
21901: LIST
21902: PUSH
21903: LD_INT 2
21905: PUSH
21906: LD_INT 30
21908: PUSH
21909: LD_INT 0
21911: PUSH
21912: EMPTY
21913: LIST
21914: LIST
21915: PUSH
21916: LD_INT 30
21918: PUSH
21919: LD_INT 1
21921: PUSH
21922: EMPTY
21923: LIST
21924: LIST
21925: PUSH
21926: EMPTY
21927: LIST
21928: LIST
21929: LIST
21930: PUSH
21931: EMPTY
21932: LIST
21933: LIST
21934: PPUSH
21935: CALL_OW 72
21939: ST_TO_ADDR
// for i = 1 to hexes do
21940: LD_ADDR_VAR 0 9
21944: PUSH
21945: DOUBLE
21946: LD_INT 1
21948: DEC
21949: ST_TO_ADDR
21950: LD_VAR 0 14
21954: PUSH
21955: FOR_TO
21956: IFFALSE 22632
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
21958: LD_ADDR_VAR 0 13
21962: PUSH
21963: LD_VAR 0 14
21967: PUSH
21968: LD_VAR 0 9
21972: ARRAY
21973: PUSH
21974: LD_INT 1
21976: ARRAY
21977: PPUSH
21978: LD_VAR 0 14
21982: PUSH
21983: LD_VAR 0 9
21987: ARRAY
21988: PUSH
21989: LD_INT 2
21991: ARRAY
21992: PPUSH
21993: CALL_OW 428
21997: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
21998: LD_VAR 0 14
22002: PUSH
22003: LD_VAR 0 9
22007: ARRAY
22008: PUSH
22009: LD_INT 1
22011: ARRAY
22012: PPUSH
22013: LD_VAR 0 14
22017: PUSH
22018: LD_VAR 0 9
22022: ARRAY
22023: PUSH
22024: LD_INT 2
22026: ARRAY
22027: PPUSH
22028: CALL_OW 351
22032: PUSH
22033: LD_VAR 0 14
22037: PUSH
22038: LD_VAR 0 9
22042: ARRAY
22043: PUSH
22044: LD_INT 1
22046: ARRAY
22047: PPUSH
22048: LD_VAR 0 14
22052: PUSH
22053: LD_VAR 0 9
22057: ARRAY
22058: PUSH
22059: LD_INT 2
22061: ARRAY
22062: PPUSH
22063: CALL_OW 488
22067: NOT
22068: OR
22069: PUSH
22070: LD_VAR 0 13
22074: PPUSH
22075: CALL_OW 247
22079: PUSH
22080: LD_INT 3
22082: EQUAL
22083: OR
22084: IFFALSE 22090
// exit ;
22086: POP
22087: POP
22088: GO 22634
// if not tmp then
22090: LD_VAR 0 13
22094: NOT
22095: IFFALSE 22099
// continue ;
22097: GO 21955
// result := true ;
22099: LD_ADDR_VAR 0 8
22103: PUSH
22104: LD_INT 1
22106: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
22107: LD_VAR 0 6
22111: PUSH
22112: LD_VAR 0 13
22116: PPUSH
22117: CALL_OW 247
22121: PUSH
22122: LD_INT 2
22124: EQUAL
22125: AND
22126: PUSH
22127: LD_VAR 0 13
22131: PPUSH
22132: CALL_OW 263
22136: PUSH
22137: LD_INT 1
22139: EQUAL
22140: AND
22141: IFFALSE 22305
// begin if IsDrivenBy ( tmp ) then
22143: LD_VAR 0 13
22147: PPUSH
22148: CALL_OW 311
22152: IFFALSE 22156
// continue ;
22154: GO 21955
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
22156: LD_VAR 0 6
22160: PPUSH
22161: LD_INT 3
22163: PUSH
22164: LD_INT 60
22166: PUSH
22167: EMPTY
22168: LIST
22169: PUSH
22170: EMPTY
22171: LIST
22172: LIST
22173: PUSH
22174: LD_INT 3
22176: PUSH
22177: LD_INT 55
22179: PUSH
22180: EMPTY
22181: LIST
22182: PUSH
22183: EMPTY
22184: LIST
22185: LIST
22186: PUSH
22187: EMPTY
22188: LIST
22189: LIST
22190: PPUSH
22191: CALL_OW 72
22195: IFFALSE 22303
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
22197: LD_ADDR_VAR 0 18
22201: PUSH
22202: LD_VAR 0 6
22206: PPUSH
22207: LD_INT 3
22209: PUSH
22210: LD_INT 60
22212: PUSH
22213: EMPTY
22214: LIST
22215: PUSH
22216: EMPTY
22217: LIST
22218: LIST
22219: PUSH
22220: LD_INT 3
22222: PUSH
22223: LD_INT 55
22225: PUSH
22226: EMPTY
22227: LIST
22228: PUSH
22229: EMPTY
22230: LIST
22231: LIST
22232: PUSH
22233: EMPTY
22234: LIST
22235: LIST
22236: PPUSH
22237: CALL_OW 72
22241: PUSH
22242: LD_INT 1
22244: ARRAY
22245: ST_TO_ADDR
// if IsInUnit ( driver ) then
22246: LD_VAR 0 18
22250: PPUSH
22251: CALL_OW 310
22255: IFFALSE 22266
// ComExit ( driver ) ;
22257: LD_VAR 0 18
22261: PPUSH
22262: CALL 47055 0 1
// AddComEnterUnit ( driver , tmp ) ;
22266: LD_VAR 0 18
22270: PPUSH
22271: LD_VAR 0 13
22275: PPUSH
22276: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
22280: LD_VAR 0 18
22284: PPUSH
22285: LD_VAR 0 7
22289: PPUSH
22290: CALL_OW 173
// AddComExitVehicle ( driver ) ;
22294: LD_VAR 0 18
22298: PPUSH
22299: CALL_OW 181
// end ; continue ;
22303: GO 21955
// end ; if not cleaners or not tmp in cleaners then
22305: LD_VAR 0 6
22309: NOT
22310: PUSH
22311: LD_VAR 0 13
22315: PUSH
22316: LD_VAR 0 6
22320: IN
22321: NOT
22322: OR
22323: IFFALSE 22630
// begin if dep then
22325: LD_VAR 0 17
22329: IFFALSE 22465
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
22331: LD_ADDR_VAR 0 16
22335: PUSH
22336: LD_VAR 0 17
22340: PUSH
22341: LD_INT 1
22343: ARRAY
22344: PPUSH
22345: CALL_OW 250
22349: PPUSH
22350: LD_VAR 0 17
22354: PUSH
22355: LD_INT 1
22357: ARRAY
22358: PPUSH
22359: CALL_OW 254
22363: PPUSH
22364: LD_INT 5
22366: PPUSH
22367: CALL_OW 272
22371: PUSH
22372: LD_VAR 0 17
22376: PUSH
22377: LD_INT 1
22379: ARRAY
22380: PPUSH
22381: CALL_OW 251
22385: PPUSH
22386: LD_VAR 0 17
22390: PUSH
22391: LD_INT 1
22393: ARRAY
22394: PPUSH
22395: CALL_OW 254
22399: PPUSH
22400: LD_INT 5
22402: PPUSH
22403: CALL_OW 273
22407: PUSH
22408: EMPTY
22409: LIST
22410: LIST
22411: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
22412: LD_VAR 0 16
22416: PUSH
22417: LD_INT 1
22419: ARRAY
22420: PPUSH
22421: LD_VAR 0 16
22425: PUSH
22426: LD_INT 2
22428: ARRAY
22429: PPUSH
22430: CALL_OW 488
22434: IFFALSE 22465
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
22436: LD_VAR 0 13
22440: PPUSH
22441: LD_VAR 0 16
22445: PUSH
22446: LD_INT 1
22448: ARRAY
22449: PPUSH
22450: LD_VAR 0 16
22454: PUSH
22455: LD_INT 2
22457: ARRAY
22458: PPUSH
22459: CALL_OW 111
// continue ;
22463: GO 21955
// end ; end ; r := GetDir ( tmp ) ;
22465: LD_ADDR_VAR 0 15
22469: PUSH
22470: LD_VAR 0 13
22474: PPUSH
22475: CALL_OW 254
22479: ST_TO_ADDR
// if r = 5 then
22480: LD_VAR 0 15
22484: PUSH
22485: LD_INT 5
22487: EQUAL
22488: IFFALSE 22498
// r := 0 ;
22490: LD_ADDR_VAR 0 15
22494: PUSH
22495: LD_INT 0
22497: ST_TO_ADDR
// for j = r to 5 do
22498: LD_ADDR_VAR 0 10
22502: PUSH
22503: DOUBLE
22504: LD_VAR 0 15
22508: DEC
22509: ST_TO_ADDR
22510: LD_INT 5
22512: PUSH
22513: FOR_TO
22514: IFFALSE 22628
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
22516: LD_ADDR_VAR 0 11
22520: PUSH
22521: LD_VAR 0 13
22525: PPUSH
22526: CALL_OW 250
22530: PPUSH
22531: LD_VAR 0 10
22535: PPUSH
22536: LD_INT 2
22538: PPUSH
22539: CALL_OW 272
22543: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
22544: LD_ADDR_VAR 0 12
22548: PUSH
22549: LD_VAR 0 13
22553: PPUSH
22554: CALL_OW 251
22558: PPUSH
22559: LD_VAR 0 10
22563: PPUSH
22564: LD_INT 2
22566: PPUSH
22567: CALL_OW 273
22571: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
22572: LD_VAR 0 11
22576: PPUSH
22577: LD_VAR 0 12
22581: PPUSH
22582: CALL_OW 488
22586: PUSH
22587: LD_VAR 0 11
22591: PPUSH
22592: LD_VAR 0 12
22596: PPUSH
22597: CALL_OW 428
22601: NOT
22602: AND
22603: IFFALSE 22626
// begin ComMoveXY ( tmp , _x , _y ) ;
22605: LD_VAR 0 13
22609: PPUSH
22610: LD_VAR 0 11
22614: PPUSH
22615: LD_VAR 0 12
22619: PPUSH
22620: CALL_OW 111
// break ;
22624: GO 22628
// end ; end ;
22626: GO 22513
22628: POP
22629: POP
// end ; end ;
22630: GO 21955
22632: POP
22633: POP
// end ;
22634: LD_VAR 0 8
22638: RET
// export function BuildingTechInvented ( side , btype ) ; begin
22639: LD_INT 0
22641: PPUSH
// result := true ;
22642: LD_ADDR_VAR 0 3
22646: PUSH
22647: LD_INT 1
22649: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
22650: LD_VAR 0 2
22654: PUSH
22655: LD_INT 24
22657: DOUBLE
22658: EQUAL
22659: IFTRUE 22669
22661: LD_INT 33
22663: DOUBLE
22664: EQUAL
22665: IFTRUE 22669
22667: GO 22694
22669: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
22670: LD_ADDR_VAR 0 3
22674: PUSH
22675: LD_INT 32
22677: PPUSH
22678: LD_VAR 0 1
22682: PPUSH
22683: CALL_OW 321
22687: PUSH
22688: LD_INT 2
22690: EQUAL
22691: ST_TO_ADDR
22692: GO 23014
22694: LD_INT 20
22696: DOUBLE
22697: EQUAL
22698: IFTRUE 22702
22700: GO 22727
22702: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
22703: LD_ADDR_VAR 0 3
22707: PUSH
22708: LD_INT 6
22710: PPUSH
22711: LD_VAR 0 1
22715: PPUSH
22716: CALL_OW 321
22720: PUSH
22721: LD_INT 2
22723: EQUAL
22724: ST_TO_ADDR
22725: GO 23014
22727: LD_INT 22
22729: DOUBLE
22730: EQUAL
22731: IFTRUE 22741
22733: LD_INT 36
22735: DOUBLE
22736: EQUAL
22737: IFTRUE 22741
22739: GO 22766
22741: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
22742: LD_ADDR_VAR 0 3
22746: PUSH
22747: LD_INT 15
22749: PPUSH
22750: LD_VAR 0 1
22754: PPUSH
22755: CALL_OW 321
22759: PUSH
22760: LD_INT 2
22762: EQUAL
22763: ST_TO_ADDR
22764: GO 23014
22766: LD_INT 30
22768: DOUBLE
22769: EQUAL
22770: IFTRUE 22774
22772: GO 22799
22774: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
22775: LD_ADDR_VAR 0 3
22779: PUSH
22780: LD_INT 20
22782: PPUSH
22783: LD_VAR 0 1
22787: PPUSH
22788: CALL_OW 321
22792: PUSH
22793: LD_INT 2
22795: EQUAL
22796: ST_TO_ADDR
22797: GO 23014
22799: LD_INT 28
22801: DOUBLE
22802: EQUAL
22803: IFTRUE 22813
22805: LD_INT 21
22807: DOUBLE
22808: EQUAL
22809: IFTRUE 22813
22811: GO 22838
22813: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
22814: LD_ADDR_VAR 0 3
22818: PUSH
22819: LD_INT 21
22821: PPUSH
22822: LD_VAR 0 1
22826: PPUSH
22827: CALL_OW 321
22831: PUSH
22832: LD_INT 2
22834: EQUAL
22835: ST_TO_ADDR
22836: GO 23014
22838: LD_INT 16
22840: DOUBLE
22841: EQUAL
22842: IFTRUE 22846
22844: GO 22873
22846: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
22847: LD_ADDR_VAR 0 3
22851: PUSH
22852: LD_EXP 79
22856: PPUSH
22857: LD_VAR 0 1
22861: PPUSH
22862: CALL_OW 321
22866: PUSH
22867: LD_INT 2
22869: EQUAL
22870: ST_TO_ADDR
22871: GO 23014
22873: LD_INT 19
22875: DOUBLE
22876: EQUAL
22877: IFTRUE 22887
22879: LD_INT 23
22881: DOUBLE
22882: EQUAL
22883: IFTRUE 22887
22885: GO 22914
22887: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
22888: LD_ADDR_VAR 0 3
22892: PUSH
22893: LD_EXP 78
22897: PPUSH
22898: LD_VAR 0 1
22902: PPUSH
22903: CALL_OW 321
22907: PUSH
22908: LD_INT 2
22910: EQUAL
22911: ST_TO_ADDR
22912: GO 23014
22914: LD_INT 17
22916: DOUBLE
22917: EQUAL
22918: IFTRUE 22922
22920: GO 22947
22922: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
22923: LD_ADDR_VAR 0 3
22927: PUSH
22928: LD_INT 39
22930: PPUSH
22931: LD_VAR 0 1
22935: PPUSH
22936: CALL_OW 321
22940: PUSH
22941: LD_INT 2
22943: EQUAL
22944: ST_TO_ADDR
22945: GO 23014
22947: LD_INT 18
22949: DOUBLE
22950: EQUAL
22951: IFTRUE 22955
22953: GO 22980
22955: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
22956: LD_ADDR_VAR 0 3
22960: PUSH
22961: LD_INT 40
22963: PPUSH
22964: LD_VAR 0 1
22968: PPUSH
22969: CALL_OW 321
22973: PUSH
22974: LD_INT 2
22976: EQUAL
22977: ST_TO_ADDR
22978: GO 23014
22980: LD_INT 27
22982: DOUBLE
22983: EQUAL
22984: IFTRUE 22988
22986: GO 23013
22988: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
22989: LD_ADDR_VAR 0 3
22993: PUSH
22994: LD_INT 35
22996: PPUSH
22997: LD_VAR 0 1
23001: PPUSH
23002: CALL_OW 321
23006: PUSH
23007: LD_INT 2
23009: EQUAL
23010: ST_TO_ADDR
23011: GO 23014
23013: POP
// end ;
23014: LD_VAR 0 3
23018: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
23019: LD_INT 0
23021: PPUSH
23022: PPUSH
23023: PPUSH
23024: PPUSH
23025: PPUSH
23026: PPUSH
23027: PPUSH
23028: PPUSH
23029: PPUSH
23030: PPUSH
23031: PPUSH
// result := false ;
23032: LD_ADDR_VAR 0 6
23036: PUSH
23037: LD_INT 0
23039: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
23040: LD_VAR 0 1
23044: NOT
23045: PUSH
23046: LD_VAR 0 1
23050: PPUSH
23051: CALL_OW 266
23055: PUSH
23056: LD_INT 0
23058: PUSH
23059: LD_INT 1
23061: PUSH
23062: EMPTY
23063: LIST
23064: LIST
23065: IN
23066: NOT
23067: OR
23068: PUSH
23069: LD_VAR 0 2
23073: NOT
23074: OR
23075: PUSH
23076: LD_VAR 0 5
23080: PUSH
23081: LD_INT 0
23083: PUSH
23084: LD_INT 1
23086: PUSH
23087: LD_INT 2
23089: PUSH
23090: LD_INT 3
23092: PUSH
23093: LD_INT 4
23095: PUSH
23096: LD_INT 5
23098: PUSH
23099: EMPTY
23100: LIST
23101: LIST
23102: LIST
23103: LIST
23104: LIST
23105: LIST
23106: IN
23107: NOT
23108: OR
23109: PUSH
23110: LD_VAR 0 3
23114: PPUSH
23115: LD_VAR 0 4
23119: PPUSH
23120: CALL_OW 488
23124: NOT
23125: OR
23126: IFFALSE 23130
// exit ;
23128: GO 23866
// side := GetSide ( depot ) ;
23130: LD_ADDR_VAR 0 9
23134: PUSH
23135: LD_VAR 0 1
23139: PPUSH
23140: CALL_OW 255
23144: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
23145: LD_VAR 0 9
23149: PPUSH
23150: LD_VAR 0 2
23154: PPUSH
23155: CALL 22639 0 2
23159: NOT
23160: IFFALSE 23164
// exit ;
23162: GO 23866
// pom := GetBase ( depot ) ;
23164: LD_ADDR_VAR 0 10
23168: PUSH
23169: LD_VAR 0 1
23173: PPUSH
23174: CALL_OW 274
23178: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
23179: LD_ADDR_VAR 0 11
23183: PUSH
23184: LD_VAR 0 2
23188: PPUSH
23189: LD_VAR 0 1
23193: PPUSH
23194: CALL_OW 248
23198: PPUSH
23199: CALL_OW 450
23203: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
23204: LD_VAR 0 10
23208: PPUSH
23209: LD_INT 1
23211: PPUSH
23212: CALL_OW 275
23216: PUSH
23217: LD_VAR 0 11
23221: PUSH
23222: LD_INT 1
23224: ARRAY
23225: GREATEREQUAL
23226: PUSH
23227: LD_VAR 0 10
23231: PPUSH
23232: LD_INT 2
23234: PPUSH
23235: CALL_OW 275
23239: PUSH
23240: LD_VAR 0 11
23244: PUSH
23245: LD_INT 2
23247: ARRAY
23248: GREATEREQUAL
23249: AND
23250: PUSH
23251: LD_VAR 0 10
23255: PPUSH
23256: LD_INT 3
23258: PPUSH
23259: CALL_OW 275
23263: PUSH
23264: LD_VAR 0 11
23268: PUSH
23269: LD_INT 3
23271: ARRAY
23272: GREATEREQUAL
23273: AND
23274: NOT
23275: IFFALSE 23279
// exit ;
23277: GO 23866
// if GetBType ( depot ) = b_depot then
23279: LD_VAR 0 1
23283: PPUSH
23284: CALL_OW 266
23288: PUSH
23289: LD_INT 0
23291: EQUAL
23292: IFFALSE 23304
// dist := 28 else
23294: LD_ADDR_VAR 0 14
23298: PUSH
23299: LD_INT 28
23301: ST_TO_ADDR
23302: GO 23312
// dist := 36 ;
23304: LD_ADDR_VAR 0 14
23308: PUSH
23309: LD_INT 36
23311: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
23312: LD_VAR 0 1
23316: PPUSH
23317: LD_VAR 0 3
23321: PPUSH
23322: LD_VAR 0 4
23326: PPUSH
23327: CALL_OW 297
23331: PUSH
23332: LD_VAR 0 14
23336: GREATER
23337: IFFALSE 23341
// exit ;
23339: GO 23866
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
23341: LD_ADDR_VAR 0 12
23345: PUSH
23346: LD_VAR 0 2
23350: PPUSH
23351: LD_VAR 0 3
23355: PPUSH
23356: LD_VAR 0 4
23360: PPUSH
23361: LD_VAR 0 5
23365: PPUSH
23366: LD_VAR 0 1
23370: PPUSH
23371: CALL_OW 248
23375: PPUSH
23376: LD_INT 0
23378: PPUSH
23379: CALL 23871 0 6
23383: ST_TO_ADDR
// if not hexes then
23384: LD_VAR 0 12
23388: NOT
23389: IFFALSE 23393
// exit ;
23391: GO 23866
// hex := GetHexInfo ( x , y ) ;
23393: LD_ADDR_VAR 0 15
23397: PUSH
23398: LD_VAR 0 3
23402: PPUSH
23403: LD_VAR 0 4
23407: PPUSH
23408: CALL_OW 546
23412: ST_TO_ADDR
// if hex [ 1 ] then
23413: LD_VAR 0 15
23417: PUSH
23418: LD_INT 1
23420: ARRAY
23421: IFFALSE 23425
// exit ;
23423: GO 23866
// height := hex [ 2 ] ;
23425: LD_ADDR_VAR 0 13
23429: PUSH
23430: LD_VAR 0 15
23434: PUSH
23435: LD_INT 2
23437: ARRAY
23438: ST_TO_ADDR
// for i = 1 to hexes do
23439: LD_ADDR_VAR 0 7
23443: PUSH
23444: DOUBLE
23445: LD_INT 1
23447: DEC
23448: ST_TO_ADDR
23449: LD_VAR 0 12
23453: PUSH
23454: FOR_TO
23455: IFFALSE 23785
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
23457: LD_VAR 0 12
23461: PUSH
23462: LD_VAR 0 7
23466: ARRAY
23467: PUSH
23468: LD_INT 1
23470: ARRAY
23471: PPUSH
23472: LD_VAR 0 12
23476: PUSH
23477: LD_VAR 0 7
23481: ARRAY
23482: PUSH
23483: LD_INT 2
23485: ARRAY
23486: PPUSH
23487: CALL_OW 488
23491: NOT
23492: PUSH
23493: LD_VAR 0 12
23497: PUSH
23498: LD_VAR 0 7
23502: ARRAY
23503: PUSH
23504: LD_INT 1
23506: ARRAY
23507: PPUSH
23508: LD_VAR 0 12
23512: PUSH
23513: LD_VAR 0 7
23517: ARRAY
23518: PUSH
23519: LD_INT 2
23521: ARRAY
23522: PPUSH
23523: CALL_OW 428
23527: PUSH
23528: LD_INT 0
23530: GREATER
23531: OR
23532: PUSH
23533: LD_VAR 0 12
23537: PUSH
23538: LD_VAR 0 7
23542: ARRAY
23543: PUSH
23544: LD_INT 1
23546: ARRAY
23547: PPUSH
23548: LD_VAR 0 12
23552: PUSH
23553: LD_VAR 0 7
23557: ARRAY
23558: PUSH
23559: LD_INT 2
23561: ARRAY
23562: PPUSH
23563: CALL_OW 351
23567: OR
23568: IFFALSE 23574
// exit ;
23570: POP
23571: POP
23572: GO 23866
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
23574: LD_ADDR_VAR 0 8
23578: PUSH
23579: LD_VAR 0 12
23583: PUSH
23584: LD_VAR 0 7
23588: ARRAY
23589: PUSH
23590: LD_INT 1
23592: ARRAY
23593: PPUSH
23594: LD_VAR 0 12
23598: PUSH
23599: LD_VAR 0 7
23603: ARRAY
23604: PUSH
23605: LD_INT 2
23607: ARRAY
23608: PPUSH
23609: CALL_OW 546
23613: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
23614: LD_VAR 0 8
23618: PUSH
23619: LD_INT 1
23621: ARRAY
23622: PUSH
23623: LD_VAR 0 8
23627: PUSH
23628: LD_INT 2
23630: ARRAY
23631: PUSH
23632: LD_VAR 0 13
23636: PUSH
23637: LD_INT 2
23639: PLUS
23640: GREATER
23641: OR
23642: PUSH
23643: LD_VAR 0 8
23647: PUSH
23648: LD_INT 2
23650: ARRAY
23651: PUSH
23652: LD_VAR 0 13
23656: PUSH
23657: LD_INT 2
23659: MINUS
23660: LESS
23661: OR
23662: PUSH
23663: LD_VAR 0 8
23667: PUSH
23668: LD_INT 3
23670: ARRAY
23671: PUSH
23672: LD_INT 0
23674: PUSH
23675: LD_INT 8
23677: PUSH
23678: LD_INT 9
23680: PUSH
23681: LD_INT 10
23683: PUSH
23684: LD_INT 11
23686: PUSH
23687: LD_INT 12
23689: PUSH
23690: LD_INT 13
23692: PUSH
23693: LD_INT 16
23695: PUSH
23696: LD_INT 17
23698: PUSH
23699: LD_INT 18
23701: PUSH
23702: LD_INT 19
23704: PUSH
23705: LD_INT 20
23707: PUSH
23708: LD_INT 21
23710: PUSH
23711: EMPTY
23712: LIST
23713: LIST
23714: LIST
23715: LIST
23716: LIST
23717: LIST
23718: LIST
23719: LIST
23720: LIST
23721: LIST
23722: LIST
23723: LIST
23724: LIST
23725: IN
23726: NOT
23727: OR
23728: PUSH
23729: LD_VAR 0 8
23733: PUSH
23734: LD_INT 5
23736: ARRAY
23737: NOT
23738: OR
23739: PUSH
23740: LD_VAR 0 8
23744: PUSH
23745: LD_INT 6
23747: ARRAY
23748: PUSH
23749: LD_INT 1
23751: PUSH
23752: LD_INT 2
23754: PUSH
23755: LD_INT 7
23757: PUSH
23758: LD_INT 9
23760: PUSH
23761: LD_INT 10
23763: PUSH
23764: LD_INT 11
23766: PUSH
23767: EMPTY
23768: LIST
23769: LIST
23770: LIST
23771: LIST
23772: LIST
23773: LIST
23774: IN
23775: NOT
23776: OR
23777: IFFALSE 23783
// exit ;
23779: POP
23780: POP
23781: GO 23866
// end ;
23783: GO 23454
23785: POP
23786: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
23787: LD_VAR 0 9
23791: PPUSH
23792: LD_VAR 0 3
23796: PPUSH
23797: LD_VAR 0 4
23801: PPUSH
23802: LD_INT 20
23804: PPUSH
23805: CALL 15811 0 4
23809: PUSH
23810: LD_INT 4
23812: ARRAY
23813: IFFALSE 23817
// exit ;
23815: GO 23866
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
23817: LD_VAR 0 2
23821: PUSH
23822: LD_INT 29
23824: PUSH
23825: LD_INT 30
23827: PUSH
23828: EMPTY
23829: LIST
23830: LIST
23831: IN
23832: PUSH
23833: LD_VAR 0 3
23837: PPUSH
23838: LD_VAR 0 4
23842: PPUSH
23843: LD_VAR 0 9
23847: PPUSH
23848: CALL_OW 440
23852: NOT
23853: AND
23854: IFFALSE 23858
// exit ;
23856: GO 23866
// result := true ;
23858: LD_ADDR_VAR 0 6
23862: PUSH
23863: LD_INT 1
23865: ST_TO_ADDR
// end ;
23866: LD_VAR 0 6
23870: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
23871: LD_INT 0
23873: PPUSH
23874: PPUSH
23875: PPUSH
23876: PPUSH
23877: PPUSH
23878: PPUSH
23879: PPUSH
23880: PPUSH
23881: PPUSH
23882: PPUSH
23883: PPUSH
23884: PPUSH
23885: PPUSH
23886: PPUSH
23887: PPUSH
23888: PPUSH
23889: PPUSH
23890: PPUSH
23891: PPUSH
23892: PPUSH
23893: PPUSH
23894: PPUSH
23895: PPUSH
23896: PPUSH
23897: PPUSH
23898: PPUSH
23899: PPUSH
23900: PPUSH
23901: PPUSH
23902: PPUSH
23903: PPUSH
23904: PPUSH
23905: PPUSH
23906: PPUSH
23907: PPUSH
23908: PPUSH
23909: PPUSH
23910: PPUSH
23911: PPUSH
23912: PPUSH
23913: PPUSH
23914: PPUSH
23915: PPUSH
23916: PPUSH
23917: PPUSH
23918: PPUSH
23919: PPUSH
23920: PPUSH
23921: PPUSH
23922: PPUSH
23923: PPUSH
23924: PPUSH
23925: PPUSH
23926: PPUSH
23927: PPUSH
23928: PPUSH
23929: PPUSH
23930: PPUSH
// result = [ ] ;
23931: LD_ADDR_VAR 0 7
23935: PUSH
23936: EMPTY
23937: ST_TO_ADDR
// temp_list = [ ] ;
23938: LD_ADDR_VAR 0 9
23942: PUSH
23943: EMPTY
23944: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
23945: LD_VAR 0 4
23949: PUSH
23950: LD_INT 0
23952: PUSH
23953: LD_INT 1
23955: PUSH
23956: LD_INT 2
23958: PUSH
23959: LD_INT 3
23961: PUSH
23962: LD_INT 4
23964: PUSH
23965: LD_INT 5
23967: PUSH
23968: EMPTY
23969: LIST
23970: LIST
23971: LIST
23972: LIST
23973: LIST
23974: LIST
23975: IN
23976: NOT
23977: PUSH
23978: LD_VAR 0 1
23982: PUSH
23983: LD_INT 0
23985: PUSH
23986: LD_INT 1
23988: PUSH
23989: EMPTY
23990: LIST
23991: LIST
23992: IN
23993: PUSH
23994: LD_VAR 0 5
23998: PUSH
23999: LD_INT 1
24001: PUSH
24002: LD_INT 2
24004: PUSH
24005: LD_INT 3
24007: PUSH
24008: EMPTY
24009: LIST
24010: LIST
24011: LIST
24012: IN
24013: NOT
24014: AND
24015: OR
24016: IFFALSE 24020
// exit ;
24018: GO 42411
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
24020: LD_VAR 0 1
24024: PUSH
24025: LD_INT 6
24027: PUSH
24028: LD_INT 7
24030: PUSH
24031: LD_INT 8
24033: PUSH
24034: LD_INT 13
24036: PUSH
24037: LD_INT 12
24039: PUSH
24040: LD_INT 15
24042: PUSH
24043: LD_INT 11
24045: PUSH
24046: LD_INT 14
24048: PUSH
24049: LD_INT 10
24051: PUSH
24052: EMPTY
24053: LIST
24054: LIST
24055: LIST
24056: LIST
24057: LIST
24058: LIST
24059: LIST
24060: LIST
24061: LIST
24062: IN
24063: IFFALSE 24073
// btype = b_lab ;
24065: LD_ADDR_VAR 0 1
24069: PUSH
24070: LD_INT 6
24072: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
24073: LD_VAR 0 6
24077: PUSH
24078: LD_INT 0
24080: PUSH
24081: LD_INT 1
24083: PUSH
24084: LD_INT 2
24086: PUSH
24087: EMPTY
24088: LIST
24089: LIST
24090: LIST
24091: IN
24092: NOT
24093: PUSH
24094: LD_VAR 0 1
24098: PUSH
24099: LD_INT 0
24101: PUSH
24102: LD_INT 1
24104: PUSH
24105: LD_INT 2
24107: PUSH
24108: LD_INT 3
24110: PUSH
24111: LD_INT 6
24113: PUSH
24114: LD_INT 36
24116: PUSH
24117: LD_INT 4
24119: PUSH
24120: LD_INT 5
24122: PUSH
24123: LD_INT 31
24125: PUSH
24126: LD_INT 32
24128: PUSH
24129: LD_INT 33
24131: PUSH
24132: EMPTY
24133: LIST
24134: LIST
24135: LIST
24136: LIST
24137: LIST
24138: LIST
24139: LIST
24140: LIST
24141: LIST
24142: LIST
24143: LIST
24144: IN
24145: NOT
24146: PUSH
24147: LD_VAR 0 6
24151: PUSH
24152: LD_INT 1
24154: EQUAL
24155: AND
24156: OR
24157: PUSH
24158: LD_VAR 0 1
24162: PUSH
24163: LD_INT 2
24165: PUSH
24166: LD_INT 3
24168: PUSH
24169: EMPTY
24170: LIST
24171: LIST
24172: IN
24173: NOT
24174: PUSH
24175: LD_VAR 0 6
24179: PUSH
24180: LD_INT 2
24182: EQUAL
24183: AND
24184: OR
24185: IFFALSE 24195
// mode = 0 ;
24187: LD_ADDR_VAR 0 6
24191: PUSH
24192: LD_INT 0
24194: ST_TO_ADDR
// case mode of 0 :
24195: LD_VAR 0 6
24199: PUSH
24200: LD_INT 0
24202: DOUBLE
24203: EQUAL
24204: IFTRUE 24208
24206: GO 35661
24208: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
24209: LD_ADDR_VAR 0 11
24213: PUSH
24214: LD_INT 0
24216: PUSH
24217: LD_INT 0
24219: PUSH
24220: EMPTY
24221: LIST
24222: LIST
24223: PUSH
24224: LD_INT 0
24226: PUSH
24227: LD_INT 1
24229: NEG
24230: PUSH
24231: EMPTY
24232: LIST
24233: LIST
24234: PUSH
24235: LD_INT 1
24237: PUSH
24238: LD_INT 0
24240: PUSH
24241: EMPTY
24242: LIST
24243: LIST
24244: PUSH
24245: LD_INT 1
24247: PUSH
24248: LD_INT 1
24250: PUSH
24251: EMPTY
24252: LIST
24253: LIST
24254: PUSH
24255: LD_INT 0
24257: PUSH
24258: LD_INT 1
24260: PUSH
24261: EMPTY
24262: LIST
24263: LIST
24264: PUSH
24265: LD_INT 1
24267: NEG
24268: PUSH
24269: LD_INT 0
24271: PUSH
24272: EMPTY
24273: LIST
24274: LIST
24275: PUSH
24276: LD_INT 1
24278: NEG
24279: PUSH
24280: LD_INT 1
24282: NEG
24283: PUSH
24284: EMPTY
24285: LIST
24286: LIST
24287: PUSH
24288: LD_INT 1
24290: NEG
24291: PUSH
24292: LD_INT 2
24294: NEG
24295: PUSH
24296: EMPTY
24297: LIST
24298: LIST
24299: PUSH
24300: LD_INT 0
24302: PUSH
24303: LD_INT 2
24305: NEG
24306: PUSH
24307: EMPTY
24308: LIST
24309: LIST
24310: PUSH
24311: LD_INT 1
24313: PUSH
24314: LD_INT 1
24316: NEG
24317: PUSH
24318: EMPTY
24319: LIST
24320: LIST
24321: PUSH
24322: LD_INT 1
24324: PUSH
24325: LD_INT 2
24327: PUSH
24328: EMPTY
24329: LIST
24330: LIST
24331: PUSH
24332: LD_INT 0
24334: PUSH
24335: LD_INT 2
24337: PUSH
24338: EMPTY
24339: LIST
24340: LIST
24341: PUSH
24342: LD_INT 1
24344: NEG
24345: PUSH
24346: LD_INT 1
24348: PUSH
24349: EMPTY
24350: LIST
24351: LIST
24352: PUSH
24353: LD_INT 1
24355: PUSH
24356: LD_INT 3
24358: PUSH
24359: EMPTY
24360: LIST
24361: LIST
24362: PUSH
24363: LD_INT 0
24365: PUSH
24366: LD_INT 3
24368: PUSH
24369: EMPTY
24370: LIST
24371: LIST
24372: PUSH
24373: LD_INT 1
24375: NEG
24376: PUSH
24377: LD_INT 2
24379: PUSH
24380: EMPTY
24381: LIST
24382: LIST
24383: PUSH
24384: EMPTY
24385: LIST
24386: LIST
24387: LIST
24388: LIST
24389: LIST
24390: LIST
24391: LIST
24392: LIST
24393: LIST
24394: LIST
24395: LIST
24396: LIST
24397: LIST
24398: LIST
24399: LIST
24400: LIST
24401: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
24402: LD_ADDR_VAR 0 12
24406: PUSH
24407: LD_INT 0
24409: PUSH
24410: LD_INT 0
24412: PUSH
24413: EMPTY
24414: LIST
24415: LIST
24416: PUSH
24417: LD_INT 0
24419: PUSH
24420: LD_INT 1
24422: NEG
24423: PUSH
24424: EMPTY
24425: LIST
24426: LIST
24427: PUSH
24428: LD_INT 1
24430: PUSH
24431: LD_INT 0
24433: PUSH
24434: EMPTY
24435: LIST
24436: LIST
24437: PUSH
24438: LD_INT 1
24440: PUSH
24441: LD_INT 1
24443: PUSH
24444: EMPTY
24445: LIST
24446: LIST
24447: PUSH
24448: LD_INT 0
24450: PUSH
24451: LD_INT 1
24453: PUSH
24454: EMPTY
24455: LIST
24456: LIST
24457: PUSH
24458: LD_INT 1
24460: NEG
24461: PUSH
24462: LD_INT 0
24464: PUSH
24465: EMPTY
24466: LIST
24467: LIST
24468: PUSH
24469: LD_INT 1
24471: NEG
24472: PUSH
24473: LD_INT 1
24475: NEG
24476: PUSH
24477: EMPTY
24478: LIST
24479: LIST
24480: PUSH
24481: LD_INT 1
24483: PUSH
24484: LD_INT 1
24486: NEG
24487: PUSH
24488: EMPTY
24489: LIST
24490: LIST
24491: PUSH
24492: LD_INT 2
24494: PUSH
24495: LD_INT 0
24497: PUSH
24498: EMPTY
24499: LIST
24500: LIST
24501: PUSH
24502: LD_INT 2
24504: PUSH
24505: LD_INT 1
24507: PUSH
24508: EMPTY
24509: LIST
24510: LIST
24511: PUSH
24512: LD_INT 1
24514: NEG
24515: PUSH
24516: LD_INT 1
24518: PUSH
24519: EMPTY
24520: LIST
24521: LIST
24522: PUSH
24523: LD_INT 2
24525: NEG
24526: PUSH
24527: LD_INT 0
24529: PUSH
24530: EMPTY
24531: LIST
24532: LIST
24533: PUSH
24534: LD_INT 2
24536: NEG
24537: PUSH
24538: LD_INT 1
24540: NEG
24541: PUSH
24542: EMPTY
24543: LIST
24544: LIST
24545: PUSH
24546: LD_INT 2
24548: NEG
24549: PUSH
24550: LD_INT 1
24552: PUSH
24553: EMPTY
24554: LIST
24555: LIST
24556: PUSH
24557: LD_INT 3
24559: NEG
24560: PUSH
24561: LD_INT 0
24563: PUSH
24564: EMPTY
24565: LIST
24566: LIST
24567: PUSH
24568: LD_INT 3
24570: NEG
24571: PUSH
24572: LD_INT 1
24574: NEG
24575: PUSH
24576: EMPTY
24577: LIST
24578: LIST
24579: PUSH
24580: EMPTY
24581: LIST
24582: LIST
24583: LIST
24584: LIST
24585: LIST
24586: LIST
24587: LIST
24588: LIST
24589: LIST
24590: LIST
24591: LIST
24592: LIST
24593: LIST
24594: LIST
24595: LIST
24596: LIST
24597: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
24598: LD_ADDR_VAR 0 13
24602: PUSH
24603: LD_INT 0
24605: PUSH
24606: LD_INT 0
24608: PUSH
24609: EMPTY
24610: LIST
24611: LIST
24612: PUSH
24613: LD_INT 0
24615: PUSH
24616: LD_INT 1
24618: NEG
24619: PUSH
24620: EMPTY
24621: LIST
24622: LIST
24623: PUSH
24624: LD_INT 1
24626: PUSH
24627: LD_INT 0
24629: PUSH
24630: EMPTY
24631: LIST
24632: LIST
24633: PUSH
24634: LD_INT 1
24636: PUSH
24637: LD_INT 1
24639: PUSH
24640: EMPTY
24641: LIST
24642: LIST
24643: PUSH
24644: LD_INT 0
24646: PUSH
24647: LD_INT 1
24649: PUSH
24650: EMPTY
24651: LIST
24652: LIST
24653: PUSH
24654: LD_INT 1
24656: NEG
24657: PUSH
24658: LD_INT 0
24660: PUSH
24661: EMPTY
24662: LIST
24663: LIST
24664: PUSH
24665: LD_INT 1
24667: NEG
24668: PUSH
24669: LD_INT 1
24671: NEG
24672: PUSH
24673: EMPTY
24674: LIST
24675: LIST
24676: PUSH
24677: LD_INT 1
24679: NEG
24680: PUSH
24681: LD_INT 2
24683: NEG
24684: PUSH
24685: EMPTY
24686: LIST
24687: LIST
24688: PUSH
24689: LD_INT 2
24691: PUSH
24692: LD_INT 1
24694: PUSH
24695: EMPTY
24696: LIST
24697: LIST
24698: PUSH
24699: LD_INT 2
24701: PUSH
24702: LD_INT 2
24704: PUSH
24705: EMPTY
24706: LIST
24707: LIST
24708: PUSH
24709: LD_INT 1
24711: PUSH
24712: LD_INT 2
24714: PUSH
24715: EMPTY
24716: LIST
24717: LIST
24718: PUSH
24719: LD_INT 2
24721: NEG
24722: PUSH
24723: LD_INT 1
24725: NEG
24726: PUSH
24727: EMPTY
24728: LIST
24729: LIST
24730: PUSH
24731: LD_INT 2
24733: NEG
24734: PUSH
24735: LD_INT 2
24737: NEG
24738: PUSH
24739: EMPTY
24740: LIST
24741: LIST
24742: PUSH
24743: LD_INT 2
24745: NEG
24746: PUSH
24747: LD_INT 3
24749: NEG
24750: PUSH
24751: EMPTY
24752: LIST
24753: LIST
24754: PUSH
24755: LD_INT 3
24757: NEG
24758: PUSH
24759: LD_INT 2
24761: NEG
24762: PUSH
24763: EMPTY
24764: LIST
24765: LIST
24766: PUSH
24767: LD_INT 3
24769: NEG
24770: PUSH
24771: LD_INT 3
24773: NEG
24774: PUSH
24775: EMPTY
24776: LIST
24777: LIST
24778: PUSH
24779: EMPTY
24780: LIST
24781: LIST
24782: LIST
24783: LIST
24784: LIST
24785: LIST
24786: LIST
24787: LIST
24788: LIST
24789: LIST
24790: LIST
24791: LIST
24792: LIST
24793: LIST
24794: LIST
24795: LIST
24796: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
24797: LD_ADDR_VAR 0 14
24801: PUSH
24802: LD_INT 0
24804: PUSH
24805: LD_INT 0
24807: PUSH
24808: EMPTY
24809: LIST
24810: LIST
24811: PUSH
24812: LD_INT 0
24814: PUSH
24815: LD_INT 1
24817: NEG
24818: PUSH
24819: EMPTY
24820: LIST
24821: LIST
24822: PUSH
24823: LD_INT 1
24825: PUSH
24826: LD_INT 0
24828: PUSH
24829: EMPTY
24830: LIST
24831: LIST
24832: PUSH
24833: LD_INT 1
24835: PUSH
24836: LD_INT 1
24838: PUSH
24839: EMPTY
24840: LIST
24841: LIST
24842: PUSH
24843: LD_INT 0
24845: PUSH
24846: LD_INT 1
24848: PUSH
24849: EMPTY
24850: LIST
24851: LIST
24852: PUSH
24853: LD_INT 1
24855: NEG
24856: PUSH
24857: LD_INT 0
24859: PUSH
24860: EMPTY
24861: LIST
24862: LIST
24863: PUSH
24864: LD_INT 1
24866: NEG
24867: PUSH
24868: LD_INT 1
24870: NEG
24871: PUSH
24872: EMPTY
24873: LIST
24874: LIST
24875: PUSH
24876: LD_INT 1
24878: NEG
24879: PUSH
24880: LD_INT 2
24882: NEG
24883: PUSH
24884: EMPTY
24885: LIST
24886: LIST
24887: PUSH
24888: LD_INT 0
24890: PUSH
24891: LD_INT 2
24893: NEG
24894: PUSH
24895: EMPTY
24896: LIST
24897: LIST
24898: PUSH
24899: LD_INT 1
24901: PUSH
24902: LD_INT 1
24904: NEG
24905: PUSH
24906: EMPTY
24907: LIST
24908: LIST
24909: PUSH
24910: LD_INT 1
24912: PUSH
24913: LD_INT 2
24915: PUSH
24916: EMPTY
24917: LIST
24918: LIST
24919: PUSH
24920: LD_INT 0
24922: PUSH
24923: LD_INT 2
24925: PUSH
24926: EMPTY
24927: LIST
24928: LIST
24929: PUSH
24930: LD_INT 1
24932: NEG
24933: PUSH
24934: LD_INT 1
24936: PUSH
24937: EMPTY
24938: LIST
24939: LIST
24940: PUSH
24941: LD_INT 1
24943: NEG
24944: PUSH
24945: LD_INT 3
24947: NEG
24948: PUSH
24949: EMPTY
24950: LIST
24951: LIST
24952: PUSH
24953: LD_INT 0
24955: PUSH
24956: LD_INT 3
24958: NEG
24959: PUSH
24960: EMPTY
24961: LIST
24962: LIST
24963: PUSH
24964: LD_INT 1
24966: PUSH
24967: LD_INT 2
24969: NEG
24970: PUSH
24971: EMPTY
24972: LIST
24973: LIST
24974: PUSH
24975: EMPTY
24976: LIST
24977: LIST
24978: LIST
24979: LIST
24980: LIST
24981: LIST
24982: LIST
24983: LIST
24984: LIST
24985: LIST
24986: LIST
24987: LIST
24988: LIST
24989: LIST
24990: LIST
24991: LIST
24992: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
24993: LD_ADDR_VAR 0 15
24997: PUSH
24998: LD_INT 0
25000: PUSH
25001: LD_INT 0
25003: PUSH
25004: EMPTY
25005: LIST
25006: LIST
25007: PUSH
25008: LD_INT 0
25010: PUSH
25011: LD_INT 1
25013: NEG
25014: PUSH
25015: EMPTY
25016: LIST
25017: LIST
25018: PUSH
25019: LD_INT 1
25021: PUSH
25022: LD_INT 0
25024: PUSH
25025: EMPTY
25026: LIST
25027: LIST
25028: PUSH
25029: LD_INT 1
25031: PUSH
25032: LD_INT 1
25034: PUSH
25035: EMPTY
25036: LIST
25037: LIST
25038: PUSH
25039: LD_INT 0
25041: PUSH
25042: LD_INT 1
25044: PUSH
25045: EMPTY
25046: LIST
25047: LIST
25048: PUSH
25049: LD_INT 1
25051: NEG
25052: PUSH
25053: LD_INT 0
25055: PUSH
25056: EMPTY
25057: LIST
25058: LIST
25059: PUSH
25060: LD_INT 1
25062: NEG
25063: PUSH
25064: LD_INT 1
25066: NEG
25067: PUSH
25068: EMPTY
25069: LIST
25070: LIST
25071: PUSH
25072: LD_INT 1
25074: PUSH
25075: LD_INT 1
25077: NEG
25078: PUSH
25079: EMPTY
25080: LIST
25081: LIST
25082: PUSH
25083: LD_INT 2
25085: PUSH
25086: LD_INT 0
25088: PUSH
25089: EMPTY
25090: LIST
25091: LIST
25092: PUSH
25093: LD_INT 2
25095: PUSH
25096: LD_INT 1
25098: PUSH
25099: EMPTY
25100: LIST
25101: LIST
25102: PUSH
25103: LD_INT 1
25105: NEG
25106: PUSH
25107: LD_INT 1
25109: PUSH
25110: EMPTY
25111: LIST
25112: LIST
25113: PUSH
25114: LD_INT 2
25116: NEG
25117: PUSH
25118: LD_INT 0
25120: PUSH
25121: EMPTY
25122: LIST
25123: LIST
25124: PUSH
25125: LD_INT 2
25127: NEG
25128: PUSH
25129: LD_INT 1
25131: NEG
25132: PUSH
25133: EMPTY
25134: LIST
25135: LIST
25136: PUSH
25137: LD_INT 2
25139: PUSH
25140: LD_INT 1
25142: NEG
25143: PUSH
25144: EMPTY
25145: LIST
25146: LIST
25147: PUSH
25148: LD_INT 3
25150: PUSH
25151: LD_INT 0
25153: PUSH
25154: EMPTY
25155: LIST
25156: LIST
25157: PUSH
25158: LD_INT 3
25160: PUSH
25161: LD_INT 1
25163: PUSH
25164: EMPTY
25165: LIST
25166: LIST
25167: PUSH
25168: EMPTY
25169: LIST
25170: LIST
25171: LIST
25172: LIST
25173: LIST
25174: LIST
25175: LIST
25176: LIST
25177: LIST
25178: LIST
25179: LIST
25180: LIST
25181: LIST
25182: LIST
25183: LIST
25184: LIST
25185: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
25186: LD_ADDR_VAR 0 16
25190: PUSH
25191: LD_INT 0
25193: PUSH
25194: LD_INT 0
25196: PUSH
25197: EMPTY
25198: LIST
25199: LIST
25200: PUSH
25201: LD_INT 0
25203: PUSH
25204: LD_INT 1
25206: NEG
25207: PUSH
25208: EMPTY
25209: LIST
25210: LIST
25211: PUSH
25212: LD_INT 1
25214: PUSH
25215: LD_INT 0
25217: PUSH
25218: EMPTY
25219: LIST
25220: LIST
25221: PUSH
25222: LD_INT 1
25224: PUSH
25225: LD_INT 1
25227: PUSH
25228: EMPTY
25229: LIST
25230: LIST
25231: PUSH
25232: LD_INT 0
25234: PUSH
25235: LD_INT 1
25237: PUSH
25238: EMPTY
25239: LIST
25240: LIST
25241: PUSH
25242: LD_INT 1
25244: NEG
25245: PUSH
25246: LD_INT 0
25248: PUSH
25249: EMPTY
25250: LIST
25251: LIST
25252: PUSH
25253: LD_INT 1
25255: NEG
25256: PUSH
25257: LD_INT 1
25259: NEG
25260: PUSH
25261: EMPTY
25262: LIST
25263: LIST
25264: PUSH
25265: LD_INT 1
25267: NEG
25268: PUSH
25269: LD_INT 2
25271: NEG
25272: PUSH
25273: EMPTY
25274: LIST
25275: LIST
25276: PUSH
25277: LD_INT 2
25279: PUSH
25280: LD_INT 1
25282: PUSH
25283: EMPTY
25284: LIST
25285: LIST
25286: PUSH
25287: LD_INT 2
25289: PUSH
25290: LD_INT 2
25292: PUSH
25293: EMPTY
25294: LIST
25295: LIST
25296: PUSH
25297: LD_INT 1
25299: PUSH
25300: LD_INT 2
25302: PUSH
25303: EMPTY
25304: LIST
25305: LIST
25306: PUSH
25307: LD_INT 2
25309: NEG
25310: PUSH
25311: LD_INT 1
25313: NEG
25314: PUSH
25315: EMPTY
25316: LIST
25317: LIST
25318: PUSH
25319: LD_INT 2
25321: NEG
25322: PUSH
25323: LD_INT 2
25325: NEG
25326: PUSH
25327: EMPTY
25328: LIST
25329: LIST
25330: PUSH
25331: LD_INT 3
25333: PUSH
25334: LD_INT 2
25336: PUSH
25337: EMPTY
25338: LIST
25339: LIST
25340: PUSH
25341: LD_INT 3
25343: PUSH
25344: LD_INT 3
25346: PUSH
25347: EMPTY
25348: LIST
25349: LIST
25350: PUSH
25351: LD_INT 2
25353: PUSH
25354: LD_INT 3
25356: PUSH
25357: EMPTY
25358: LIST
25359: LIST
25360: PUSH
25361: EMPTY
25362: LIST
25363: LIST
25364: LIST
25365: LIST
25366: LIST
25367: LIST
25368: LIST
25369: LIST
25370: LIST
25371: LIST
25372: LIST
25373: LIST
25374: LIST
25375: LIST
25376: LIST
25377: LIST
25378: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25379: LD_ADDR_VAR 0 17
25383: PUSH
25384: LD_INT 0
25386: PUSH
25387: LD_INT 0
25389: PUSH
25390: EMPTY
25391: LIST
25392: LIST
25393: PUSH
25394: LD_INT 0
25396: PUSH
25397: LD_INT 1
25399: NEG
25400: PUSH
25401: EMPTY
25402: LIST
25403: LIST
25404: PUSH
25405: LD_INT 1
25407: PUSH
25408: LD_INT 0
25410: PUSH
25411: EMPTY
25412: LIST
25413: LIST
25414: PUSH
25415: LD_INT 1
25417: PUSH
25418: LD_INT 1
25420: PUSH
25421: EMPTY
25422: LIST
25423: LIST
25424: PUSH
25425: LD_INT 0
25427: PUSH
25428: LD_INT 1
25430: PUSH
25431: EMPTY
25432: LIST
25433: LIST
25434: PUSH
25435: LD_INT 1
25437: NEG
25438: PUSH
25439: LD_INT 0
25441: PUSH
25442: EMPTY
25443: LIST
25444: LIST
25445: PUSH
25446: LD_INT 1
25448: NEG
25449: PUSH
25450: LD_INT 1
25452: NEG
25453: PUSH
25454: EMPTY
25455: LIST
25456: LIST
25457: PUSH
25458: LD_INT 1
25460: NEG
25461: PUSH
25462: LD_INT 2
25464: NEG
25465: PUSH
25466: EMPTY
25467: LIST
25468: LIST
25469: PUSH
25470: LD_INT 0
25472: PUSH
25473: LD_INT 2
25475: NEG
25476: PUSH
25477: EMPTY
25478: LIST
25479: LIST
25480: PUSH
25481: LD_INT 1
25483: PUSH
25484: LD_INT 1
25486: NEG
25487: PUSH
25488: EMPTY
25489: LIST
25490: LIST
25491: PUSH
25492: LD_INT 2
25494: PUSH
25495: LD_INT 0
25497: PUSH
25498: EMPTY
25499: LIST
25500: LIST
25501: PUSH
25502: LD_INT 2
25504: PUSH
25505: LD_INT 1
25507: PUSH
25508: EMPTY
25509: LIST
25510: LIST
25511: PUSH
25512: LD_INT 2
25514: PUSH
25515: LD_INT 2
25517: PUSH
25518: EMPTY
25519: LIST
25520: LIST
25521: PUSH
25522: LD_INT 1
25524: PUSH
25525: LD_INT 2
25527: PUSH
25528: EMPTY
25529: LIST
25530: LIST
25531: PUSH
25532: LD_INT 0
25534: PUSH
25535: LD_INT 2
25537: PUSH
25538: EMPTY
25539: LIST
25540: LIST
25541: PUSH
25542: LD_INT 1
25544: NEG
25545: PUSH
25546: LD_INT 1
25548: PUSH
25549: EMPTY
25550: LIST
25551: LIST
25552: PUSH
25553: LD_INT 2
25555: NEG
25556: PUSH
25557: LD_INT 0
25559: PUSH
25560: EMPTY
25561: LIST
25562: LIST
25563: PUSH
25564: LD_INT 2
25566: NEG
25567: PUSH
25568: LD_INT 1
25570: NEG
25571: PUSH
25572: EMPTY
25573: LIST
25574: LIST
25575: PUSH
25576: LD_INT 2
25578: NEG
25579: PUSH
25580: LD_INT 2
25582: NEG
25583: PUSH
25584: EMPTY
25585: LIST
25586: LIST
25587: PUSH
25588: EMPTY
25589: LIST
25590: LIST
25591: LIST
25592: LIST
25593: LIST
25594: LIST
25595: LIST
25596: LIST
25597: LIST
25598: LIST
25599: LIST
25600: LIST
25601: LIST
25602: LIST
25603: LIST
25604: LIST
25605: LIST
25606: LIST
25607: LIST
25608: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25609: LD_ADDR_VAR 0 18
25613: PUSH
25614: LD_INT 0
25616: PUSH
25617: LD_INT 0
25619: PUSH
25620: EMPTY
25621: LIST
25622: LIST
25623: PUSH
25624: LD_INT 0
25626: PUSH
25627: LD_INT 1
25629: NEG
25630: PUSH
25631: EMPTY
25632: LIST
25633: LIST
25634: PUSH
25635: LD_INT 1
25637: PUSH
25638: LD_INT 0
25640: PUSH
25641: EMPTY
25642: LIST
25643: LIST
25644: PUSH
25645: LD_INT 1
25647: PUSH
25648: LD_INT 1
25650: PUSH
25651: EMPTY
25652: LIST
25653: LIST
25654: PUSH
25655: LD_INT 0
25657: PUSH
25658: LD_INT 1
25660: PUSH
25661: EMPTY
25662: LIST
25663: LIST
25664: PUSH
25665: LD_INT 1
25667: NEG
25668: PUSH
25669: LD_INT 0
25671: PUSH
25672: EMPTY
25673: LIST
25674: LIST
25675: PUSH
25676: LD_INT 1
25678: NEG
25679: PUSH
25680: LD_INT 1
25682: NEG
25683: PUSH
25684: EMPTY
25685: LIST
25686: LIST
25687: PUSH
25688: LD_INT 1
25690: NEG
25691: PUSH
25692: LD_INT 2
25694: NEG
25695: PUSH
25696: EMPTY
25697: LIST
25698: LIST
25699: PUSH
25700: LD_INT 0
25702: PUSH
25703: LD_INT 2
25705: NEG
25706: PUSH
25707: EMPTY
25708: LIST
25709: LIST
25710: PUSH
25711: LD_INT 1
25713: PUSH
25714: LD_INT 1
25716: NEG
25717: PUSH
25718: EMPTY
25719: LIST
25720: LIST
25721: PUSH
25722: LD_INT 2
25724: PUSH
25725: LD_INT 0
25727: PUSH
25728: EMPTY
25729: LIST
25730: LIST
25731: PUSH
25732: LD_INT 2
25734: PUSH
25735: LD_INT 1
25737: PUSH
25738: EMPTY
25739: LIST
25740: LIST
25741: PUSH
25742: LD_INT 2
25744: PUSH
25745: LD_INT 2
25747: PUSH
25748: EMPTY
25749: LIST
25750: LIST
25751: PUSH
25752: LD_INT 1
25754: PUSH
25755: LD_INT 2
25757: PUSH
25758: EMPTY
25759: LIST
25760: LIST
25761: PUSH
25762: LD_INT 0
25764: PUSH
25765: LD_INT 2
25767: PUSH
25768: EMPTY
25769: LIST
25770: LIST
25771: PUSH
25772: LD_INT 1
25774: NEG
25775: PUSH
25776: LD_INT 1
25778: PUSH
25779: EMPTY
25780: LIST
25781: LIST
25782: PUSH
25783: LD_INT 2
25785: NEG
25786: PUSH
25787: LD_INT 0
25789: PUSH
25790: EMPTY
25791: LIST
25792: LIST
25793: PUSH
25794: LD_INT 2
25796: NEG
25797: PUSH
25798: LD_INT 1
25800: NEG
25801: PUSH
25802: EMPTY
25803: LIST
25804: LIST
25805: PUSH
25806: LD_INT 2
25808: NEG
25809: PUSH
25810: LD_INT 2
25812: NEG
25813: PUSH
25814: EMPTY
25815: LIST
25816: LIST
25817: PUSH
25818: EMPTY
25819: LIST
25820: LIST
25821: LIST
25822: LIST
25823: LIST
25824: LIST
25825: LIST
25826: LIST
25827: LIST
25828: LIST
25829: LIST
25830: LIST
25831: LIST
25832: LIST
25833: LIST
25834: LIST
25835: LIST
25836: LIST
25837: LIST
25838: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25839: LD_ADDR_VAR 0 19
25843: PUSH
25844: LD_INT 0
25846: PUSH
25847: LD_INT 0
25849: PUSH
25850: EMPTY
25851: LIST
25852: LIST
25853: PUSH
25854: LD_INT 0
25856: PUSH
25857: LD_INT 1
25859: NEG
25860: PUSH
25861: EMPTY
25862: LIST
25863: LIST
25864: PUSH
25865: LD_INT 1
25867: PUSH
25868: LD_INT 0
25870: PUSH
25871: EMPTY
25872: LIST
25873: LIST
25874: PUSH
25875: LD_INT 1
25877: PUSH
25878: LD_INT 1
25880: PUSH
25881: EMPTY
25882: LIST
25883: LIST
25884: PUSH
25885: LD_INT 0
25887: PUSH
25888: LD_INT 1
25890: PUSH
25891: EMPTY
25892: LIST
25893: LIST
25894: PUSH
25895: LD_INT 1
25897: NEG
25898: PUSH
25899: LD_INT 0
25901: PUSH
25902: EMPTY
25903: LIST
25904: LIST
25905: PUSH
25906: LD_INT 1
25908: NEG
25909: PUSH
25910: LD_INT 1
25912: NEG
25913: PUSH
25914: EMPTY
25915: LIST
25916: LIST
25917: PUSH
25918: LD_INT 1
25920: NEG
25921: PUSH
25922: LD_INT 2
25924: NEG
25925: PUSH
25926: EMPTY
25927: LIST
25928: LIST
25929: PUSH
25930: LD_INT 0
25932: PUSH
25933: LD_INT 2
25935: NEG
25936: PUSH
25937: EMPTY
25938: LIST
25939: LIST
25940: PUSH
25941: LD_INT 1
25943: PUSH
25944: LD_INT 1
25946: NEG
25947: PUSH
25948: EMPTY
25949: LIST
25950: LIST
25951: PUSH
25952: LD_INT 2
25954: PUSH
25955: LD_INT 0
25957: PUSH
25958: EMPTY
25959: LIST
25960: LIST
25961: PUSH
25962: LD_INT 2
25964: PUSH
25965: LD_INT 1
25967: PUSH
25968: EMPTY
25969: LIST
25970: LIST
25971: PUSH
25972: LD_INT 2
25974: PUSH
25975: LD_INT 2
25977: PUSH
25978: EMPTY
25979: LIST
25980: LIST
25981: PUSH
25982: LD_INT 1
25984: PUSH
25985: LD_INT 2
25987: PUSH
25988: EMPTY
25989: LIST
25990: LIST
25991: PUSH
25992: LD_INT 0
25994: PUSH
25995: LD_INT 2
25997: PUSH
25998: EMPTY
25999: LIST
26000: LIST
26001: PUSH
26002: LD_INT 1
26004: NEG
26005: PUSH
26006: LD_INT 1
26008: PUSH
26009: EMPTY
26010: LIST
26011: LIST
26012: PUSH
26013: LD_INT 2
26015: NEG
26016: PUSH
26017: LD_INT 0
26019: PUSH
26020: EMPTY
26021: LIST
26022: LIST
26023: PUSH
26024: LD_INT 2
26026: NEG
26027: PUSH
26028: LD_INT 1
26030: NEG
26031: PUSH
26032: EMPTY
26033: LIST
26034: LIST
26035: PUSH
26036: LD_INT 2
26038: NEG
26039: PUSH
26040: LD_INT 2
26042: NEG
26043: PUSH
26044: EMPTY
26045: LIST
26046: LIST
26047: PUSH
26048: EMPTY
26049: LIST
26050: LIST
26051: LIST
26052: LIST
26053: LIST
26054: LIST
26055: LIST
26056: LIST
26057: LIST
26058: LIST
26059: LIST
26060: LIST
26061: LIST
26062: LIST
26063: LIST
26064: LIST
26065: LIST
26066: LIST
26067: LIST
26068: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26069: LD_ADDR_VAR 0 20
26073: PUSH
26074: LD_INT 0
26076: PUSH
26077: LD_INT 0
26079: PUSH
26080: EMPTY
26081: LIST
26082: LIST
26083: PUSH
26084: LD_INT 0
26086: PUSH
26087: LD_INT 1
26089: NEG
26090: PUSH
26091: EMPTY
26092: LIST
26093: LIST
26094: PUSH
26095: LD_INT 1
26097: PUSH
26098: LD_INT 0
26100: PUSH
26101: EMPTY
26102: LIST
26103: LIST
26104: PUSH
26105: LD_INT 1
26107: PUSH
26108: LD_INT 1
26110: PUSH
26111: EMPTY
26112: LIST
26113: LIST
26114: PUSH
26115: LD_INT 0
26117: PUSH
26118: LD_INT 1
26120: PUSH
26121: EMPTY
26122: LIST
26123: LIST
26124: PUSH
26125: LD_INT 1
26127: NEG
26128: PUSH
26129: LD_INT 0
26131: PUSH
26132: EMPTY
26133: LIST
26134: LIST
26135: PUSH
26136: LD_INT 1
26138: NEG
26139: PUSH
26140: LD_INT 1
26142: NEG
26143: PUSH
26144: EMPTY
26145: LIST
26146: LIST
26147: PUSH
26148: LD_INT 1
26150: NEG
26151: PUSH
26152: LD_INT 2
26154: NEG
26155: PUSH
26156: EMPTY
26157: LIST
26158: LIST
26159: PUSH
26160: LD_INT 0
26162: PUSH
26163: LD_INT 2
26165: NEG
26166: PUSH
26167: EMPTY
26168: LIST
26169: LIST
26170: PUSH
26171: LD_INT 1
26173: PUSH
26174: LD_INT 1
26176: NEG
26177: PUSH
26178: EMPTY
26179: LIST
26180: LIST
26181: PUSH
26182: LD_INT 2
26184: PUSH
26185: LD_INT 0
26187: PUSH
26188: EMPTY
26189: LIST
26190: LIST
26191: PUSH
26192: LD_INT 2
26194: PUSH
26195: LD_INT 1
26197: PUSH
26198: EMPTY
26199: LIST
26200: LIST
26201: PUSH
26202: LD_INT 2
26204: PUSH
26205: LD_INT 2
26207: PUSH
26208: EMPTY
26209: LIST
26210: LIST
26211: PUSH
26212: LD_INT 1
26214: PUSH
26215: LD_INT 2
26217: PUSH
26218: EMPTY
26219: LIST
26220: LIST
26221: PUSH
26222: LD_INT 0
26224: PUSH
26225: LD_INT 2
26227: PUSH
26228: EMPTY
26229: LIST
26230: LIST
26231: PUSH
26232: LD_INT 1
26234: NEG
26235: PUSH
26236: LD_INT 1
26238: PUSH
26239: EMPTY
26240: LIST
26241: LIST
26242: PUSH
26243: LD_INT 2
26245: NEG
26246: PUSH
26247: LD_INT 0
26249: PUSH
26250: EMPTY
26251: LIST
26252: LIST
26253: PUSH
26254: LD_INT 2
26256: NEG
26257: PUSH
26258: LD_INT 1
26260: NEG
26261: PUSH
26262: EMPTY
26263: LIST
26264: LIST
26265: PUSH
26266: LD_INT 2
26268: NEG
26269: PUSH
26270: LD_INT 2
26272: NEG
26273: PUSH
26274: EMPTY
26275: LIST
26276: LIST
26277: PUSH
26278: EMPTY
26279: LIST
26280: LIST
26281: LIST
26282: LIST
26283: LIST
26284: LIST
26285: LIST
26286: LIST
26287: LIST
26288: LIST
26289: LIST
26290: LIST
26291: LIST
26292: LIST
26293: LIST
26294: LIST
26295: LIST
26296: LIST
26297: LIST
26298: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26299: LD_ADDR_VAR 0 21
26303: PUSH
26304: LD_INT 0
26306: PUSH
26307: LD_INT 0
26309: PUSH
26310: EMPTY
26311: LIST
26312: LIST
26313: PUSH
26314: LD_INT 0
26316: PUSH
26317: LD_INT 1
26319: NEG
26320: PUSH
26321: EMPTY
26322: LIST
26323: LIST
26324: PUSH
26325: LD_INT 1
26327: PUSH
26328: LD_INT 0
26330: PUSH
26331: EMPTY
26332: LIST
26333: LIST
26334: PUSH
26335: LD_INT 1
26337: PUSH
26338: LD_INT 1
26340: PUSH
26341: EMPTY
26342: LIST
26343: LIST
26344: PUSH
26345: LD_INT 0
26347: PUSH
26348: LD_INT 1
26350: PUSH
26351: EMPTY
26352: LIST
26353: LIST
26354: PUSH
26355: LD_INT 1
26357: NEG
26358: PUSH
26359: LD_INT 0
26361: PUSH
26362: EMPTY
26363: LIST
26364: LIST
26365: PUSH
26366: LD_INT 1
26368: NEG
26369: PUSH
26370: LD_INT 1
26372: NEG
26373: PUSH
26374: EMPTY
26375: LIST
26376: LIST
26377: PUSH
26378: LD_INT 1
26380: NEG
26381: PUSH
26382: LD_INT 2
26384: NEG
26385: PUSH
26386: EMPTY
26387: LIST
26388: LIST
26389: PUSH
26390: LD_INT 0
26392: PUSH
26393: LD_INT 2
26395: NEG
26396: PUSH
26397: EMPTY
26398: LIST
26399: LIST
26400: PUSH
26401: LD_INT 1
26403: PUSH
26404: LD_INT 1
26406: NEG
26407: PUSH
26408: EMPTY
26409: LIST
26410: LIST
26411: PUSH
26412: LD_INT 2
26414: PUSH
26415: LD_INT 0
26417: PUSH
26418: EMPTY
26419: LIST
26420: LIST
26421: PUSH
26422: LD_INT 2
26424: PUSH
26425: LD_INT 1
26427: PUSH
26428: EMPTY
26429: LIST
26430: LIST
26431: PUSH
26432: LD_INT 2
26434: PUSH
26435: LD_INT 2
26437: PUSH
26438: EMPTY
26439: LIST
26440: LIST
26441: PUSH
26442: LD_INT 1
26444: PUSH
26445: LD_INT 2
26447: PUSH
26448: EMPTY
26449: LIST
26450: LIST
26451: PUSH
26452: LD_INT 0
26454: PUSH
26455: LD_INT 2
26457: PUSH
26458: EMPTY
26459: LIST
26460: LIST
26461: PUSH
26462: LD_INT 1
26464: NEG
26465: PUSH
26466: LD_INT 1
26468: PUSH
26469: EMPTY
26470: LIST
26471: LIST
26472: PUSH
26473: LD_INT 2
26475: NEG
26476: PUSH
26477: LD_INT 0
26479: PUSH
26480: EMPTY
26481: LIST
26482: LIST
26483: PUSH
26484: LD_INT 2
26486: NEG
26487: PUSH
26488: LD_INT 1
26490: NEG
26491: PUSH
26492: EMPTY
26493: LIST
26494: LIST
26495: PUSH
26496: LD_INT 2
26498: NEG
26499: PUSH
26500: LD_INT 2
26502: NEG
26503: PUSH
26504: EMPTY
26505: LIST
26506: LIST
26507: PUSH
26508: EMPTY
26509: LIST
26510: LIST
26511: LIST
26512: LIST
26513: LIST
26514: LIST
26515: LIST
26516: LIST
26517: LIST
26518: LIST
26519: LIST
26520: LIST
26521: LIST
26522: LIST
26523: LIST
26524: LIST
26525: LIST
26526: LIST
26527: LIST
26528: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26529: LD_ADDR_VAR 0 22
26533: PUSH
26534: LD_INT 0
26536: PUSH
26537: LD_INT 0
26539: PUSH
26540: EMPTY
26541: LIST
26542: LIST
26543: PUSH
26544: LD_INT 0
26546: PUSH
26547: LD_INT 1
26549: NEG
26550: PUSH
26551: EMPTY
26552: LIST
26553: LIST
26554: PUSH
26555: LD_INT 1
26557: PUSH
26558: LD_INT 0
26560: PUSH
26561: EMPTY
26562: LIST
26563: LIST
26564: PUSH
26565: LD_INT 1
26567: PUSH
26568: LD_INT 1
26570: PUSH
26571: EMPTY
26572: LIST
26573: LIST
26574: PUSH
26575: LD_INT 0
26577: PUSH
26578: LD_INT 1
26580: PUSH
26581: EMPTY
26582: LIST
26583: LIST
26584: PUSH
26585: LD_INT 1
26587: NEG
26588: PUSH
26589: LD_INT 0
26591: PUSH
26592: EMPTY
26593: LIST
26594: LIST
26595: PUSH
26596: LD_INT 1
26598: NEG
26599: PUSH
26600: LD_INT 1
26602: NEG
26603: PUSH
26604: EMPTY
26605: LIST
26606: LIST
26607: PUSH
26608: LD_INT 1
26610: NEG
26611: PUSH
26612: LD_INT 2
26614: NEG
26615: PUSH
26616: EMPTY
26617: LIST
26618: LIST
26619: PUSH
26620: LD_INT 0
26622: PUSH
26623: LD_INT 2
26625: NEG
26626: PUSH
26627: EMPTY
26628: LIST
26629: LIST
26630: PUSH
26631: LD_INT 1
26633: PUSH
26634: LD_INT 1
26636: NEG
26637: PUSH
26638: EMPTY
26639: LIST
26640: LIST
26641: PUSH
26642: LD_INT 2
26644: PUSH
26645: LD_INT 0
26647: PUSH
26648: EMPTY
26649: LIST
26650: LIST
26651: PUSH
26652: LD_INT 2
26654: PUSH
26655: LD_INT 1
26657: PUSH
26658: EMPTY
26659: LIST
26660: LIST
26661: PUSH
26662: LD_INT 2
26664: PUSH
26665: LD_INT 2
26667: PUSH
26668: EMPTY
26669: LIST
26670: LIST
26671: PUSH
26672: LD_INT 1
26674: PUSH
26675: LD_INT 2
26677: PUSH
26678: EMPTY
26679: LIST
26680: LIST
26681: PUSH
26682: LD_INT 0
26684: PUSH
26685: LD_INT 2
26687: PUSH
26688: EMPTY
26689: LIST
26690: LIST
26691: PUSH
26692: LD_INT 1
26694: NEG
26695: PUSH
26696: LD_INT 1
26698: PUSH
26699: EMPTY
26700: LIST
26701: LIST
26702: PUSH
26703: LD_INT 2
26705: NEG
26706: PUSH
26707: LD_INT 0
26709: PUSH
26710: EMPTY
26711: LIST
26712: LIST
26713: PUSH
26714: LD_INT 2
26716: NEG
26717: PUSH
26718: LD_INT 1
26720: NEG
26721: PUSH
26722: EMPTY
26723: LIST
26724: LIST
26725: PUSH
26726: LD_INT 2
26728: NEG
26729: PUSH
26730: LD_INT 2
26732: NEG
26733: PUSH
26734: EMPTY
26735: LIST
26736: LIST
26737: PUSH
26738: EMPTY
26739: LIST
26740: LIST
26741: LIST
26742: LIST
26743: LIST
26744: LIST
26745: LIST
26746: LIST
26747: LIST
26748: LIST
26749: LIST
26750: LIST
26751: LIST
26752: LIST
26753: LIST
26754: LIST
26755: LIST
26756: LIST
26757: LIST
26758: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
26759: LD_ADDR_VAR 0 23
26763: PUSH
26764: LD_INT 0
26766: PUSH
26767: LD_INT 0
26769: PUSH
26770: EMPTY
26771: LIST
26772: LIST
26773: PUSH
26774: LD_INT 0
26776: PUSH
26777: LD_INT 1
26779: NEG
26780: PUSH
26781: EMPTY
26782: LIST
26783: LIST
26784: PUSH
26785: LD_INT 1
26787: PUSH
26788: LD_INT 0
26790: PUSH
26791: EMPTY
26792: LIST
26793: LIST
26794: PUSH
26795: LD_INT 1
26797: PUSH
26798: LD_INT 1
26800: PUSH
26801: EMPTY
26802: LIST
26803: LIST
26804: PUSH
26805: LD_INT 0
26807: PUSH
26808: LD_INT 1
26810: PUSH
26811: EMPTY
26812: LIST
26813: LIST
26814: PUSH
26815: LD_INT 1
26817: NEG
26818: PUSH
26819: LD_INT 0
26821: PUSH
26822: EMPTY
26823: LIST
26824: LIST
26825: PUSH
26826: LD_INT 1
26828: NEG
26829: PUSH
26830: LD_INT 1
26832: NEG
26833: PUSH
26834: EMPTY
26835: LIST
26836: LIST
26837: PUSH
26838: LD_INT 1
26840: NEG
26841: PUSH
26842: LD_INT 2
26844: NEG
26845: PUSH
26846: EMPTY
26847: LIST
26848: LIST
26849: PUSH
26850: LD_INT 0
26852: PUSH
26853: LD_INT 2
26855: NEG
26856: PUSH
26857: EMPTY
26858: LIST
26859: LIST
26860: PUSH
26861: LD_INT 1
26863: PUSH
26864: LD_INT 1
26866: NEG
26867: PUSH
26868: EMPTY
26869: LIST
26870: LIST
26871: PUSH
26872: LD_INT 2
26874: PUSH
26875: LD_INT 0
26877: PUSH
26878: EMPTY
26879: LIST
26880: LIST
26881: PUSH
26882: LD_INT 2
26884: PUSH
26885: LD_INT 1
26887: PUSH
26888: EMPTY
26889: LIST
26890: LIST
26891: PUSH
26892: LD_INT 2
26894: PUSH
26895: LD_INT 2
26897: PUSH
26898: EMPTY
26899: LIST
26900: LIST
26901: PUSH
26902: LD_INT 1
26904: PUSH
26905: LD_INT 2
26907: PUSH
26908: EMPTY
26909: LIST
26910: LIST
26911: PUSH
26912: LD_INT 0
26914: PUSH
26915: LD_INT 2
26917: PUSH
26918: EMPTY
26919: LIST
26920: LIST
26921: PUSH
26922: LD_INT 1
26924: NEG
26925: PUSH
26926: LD_INT 1
26928: PUSH
26929: EMPTY
26930: LIST
26931: LIST
26932: PUSH
26933: LD_INT 2
26935: NEG
26936: PUSH
26937: LD_INT 0
26939: PUSH
26940: EMPTY
26941: LIST
26942: LIST
26943: PUSH
26944: LD_INT 2
26946: NEG
26947: PUSH
26948: LD_INT 1
26950: NEG
26951: PUSH
26952: EMPTY
26953: LIST
26954: LIST
26955: PUSH
26956: LD_INT 2
26958: NEG
26959: PUSH
26960: LD_INT 2
26962: NEG
26963: PUSH
26964: EMPTY
26965: LIST
26966: LIST
26967: PUSH
26968: LD_INT 2
26970: NEG
26971: PUSH
26972: LD_INT 3
26974: NEG
26975: PUSH
26976: EMPTY
26977: LIST
26978: LIST
26979: PUSH
26980: LD_INT 1
26982: NEG
26983: PUSH
26984: LD_INT 3
26986: NEG
26987: PUSH
26988: EMPTY
26989: LIST
26990: LIST
26991: PUSH
26992: LD_INT 1
26994: PUSH
26995: LD_INT 2
26997: NEG
26998: PUSH
26999: EMPTY
27000: LIST
27001: LIST
27002: PUSH
27003: LD_INT 2
27005: PUSH
27006: LD_INT 1
27008: NEG
27009: PUSH
27010: EMPTY
27011: LIST
27012: LIST
27013: PUSH
27014: EMPTY
27015: LIST
27016: LIST
27017: LIST
27018: LIST
27019: LIST
27020: LIST
27021: LIST
27022: LIST
27023: LIST
27024: LIST
27025: LIST
27026: LIST
27027: LIST
27028: LIST
27029: LIST
27030: LIST
27031: LIST
27032: LIST
27033: LIST
27034: LIST
27035: LIST
27036: LIST
27037: LIST
27038: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
27039: LD_ADDR_VAR 0 24
27043: PUSH
27044: LD_INT 0
27046: PUSH
27047: LD_INT 0
27049: PUSH
27050: EMPTY
27051: LIST
27052: LIST
27053: PUSH
27054: LD_INT 0
27056: PUSH
27057: LD_INT 1
27059: NEG
27060: PUSH
27061: EMPTY
27062: LIST
27063: LIST
27064: PUSH
27065: LD_INT 1
27067: PUSH
27068: LD_INT 0
27070: PUSH
27071: EMPTY
27072: LIST
27073: LIST
27074: PUSH
27075: LD_INT 1
27077: PUSH
27078: LD_INT 1
27080: PUSH
27081: EMPTY
27082: LIST
27083: LIST
27084: PUSH
27085: LD_INT 0
27087: PUSH
27088: LD_INT 1
27090: PUSH
27091: EMPTY
27092: LIST
27093: LIST
27094: PUSH
27095: LD_INT 1
27097: NEG
27098: PUSH
27099: LD_INT 0
27101: PUSH
27102: EMPTY
27103: LIST
27104: LIST
27105: PUSH
27106: LD_INT 1
27108: NEG
27109: PUSH
27110: LD_INT 1
27112: NEG
27113: PUSH
27114: EMPTY
27115: LIST
27116: LIST
27117: PUSH
27118: LD_INT 1
27120: NEG
27121: PUSH
27122: LD_INT 2
27124: NEG
27125: PUSH
27126: EMPTY
27127: LIST
27128: LIST
27129: PUSH
27130: LD_INT 0
27132: PUSH
27133: LD_INT 2
27135: NEG
27136: PUSH
27137: EMPTY
27138: LIST
27139: LIST
27140: PUSH
27141: LD_INT 1
27143: PUSH
27144: LD_INT 1
27146: NEG
27147: PUSH
27148: EMPTY
27149: LIST
27150: LIST
27151: PUSH
27152: LD_INT 2
27154: PUSH
27155: LD_INT 0
27157: PUSH
27158: EMPTY
27159: LIST
27160: LIST
27161: PUSH
27162: LD_INT 2
27164: PUSH
27165: LD_INT 1
27167: PUSH
27168: EMPTY
27169: LIST
27170: LIST
27171: PUSH
27172: LD_INT 2
27174: PUSH
27175: LD_INT 2
27177: PUSH
27178: EMPTY
27179: LIST
27180: LIST
27181: PUSH
27182: LD_INT 1
27184: PUSH
27185: LD_INT 2
27187: PUSH
27188: EMPTY
27189: LIST
27190: LIST
27191: PUSH
27192: LD_INT 0
27194: PUSH
27195: LD_INT 2
27197: PUSH
27198: EMPTY
27199: LIST
27200: LIST
27201: PUSH
27202: LD_INT 1
27204: NEG
27205: PUSH
27206: LD_INT 1
27208: PUSH
27209: EMPTY
27210: LIST
27211: LIST
27212: PUSH
27213: LD_INT 2
27215: NEG
27216: PUSH
27217: LD_INT 0
27219: PUSH
27220: EMPTY
27221: LIST
27222: LIST
27223: PUSH
27224: LD_INT 2
27226: NEG
27227: PUSH
27228: LD_INT 1
27230: NEG
27231: PUSH
27232: EMPTY
27233: LIST
27234: LIST
27235: PUSH
27236: LD_INT 2
27238: NEG
27239: PUSH
27240: LD_INT 2
27242: NEG
27243: PUSH
27244: EMPTY
27245: LIST
27246: LIST
27247: PUSH
27248: LD_INT 1
27250: PUSH
27251: LD_INT 2
27253: NEG
27254: PUSH
27255: EMPTY
27256: LIST
27257: LIST
27258: PUSH
27259: LD_INT 2
27261: PUSH
27262: LD_INT 1
27264: NEG
27265: PUSH
27266: EMPTY
27267: LIST
27268: LIST
27269: PUSH
27270: LD_INT 3
27272: PUSH
27273: LD_INT 1
27275: PUSH
27276: EMPTY
27277: LIST
27278: LIST
27279: PUSH
27280: LD_INT 3
27282: PUSH
27283: LD_INT 2
27285: PUSH
27286: EMPTY
27287: LIST
27288: LIST
27289: PUSH
27290: EMPTY
27291: LIST
27292: LIST
27293: LIST
27294: LIST
27295: LIST
27296: LIST
27297: LIST
27298: LIST
27299: LIST
27300: LIST
27301: LIST
27302: LIST
27303: LIST
27304: LIST
27305: LIST
27306: LIST
27307: LIST
27308: LIST
27309: LIST
27310: LIST
27311: LIST
27312: LIST
27313: LIST
27314: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
27315: LD_ADDR_VAR 0 25
27319: PUSH
27320: LD_INT 0
27322: PUSH
27323: LD_INT 0
27325: PUSH
27326: EMPTY
27327: LIST
27328: LIST
27329: PUSH
27330: LD_INT 0
27332: PUSH
27333: LD_INT 1
27335: NEG
27336: PUSH
27337: EMPTY
27338: LIST
27339: LIST
27340: PUSH
27341: LD_INT 1
27343: PUSH
27344: LD_INT 0
27346: PUSH
27347: EMPTY
27348: LIST
27349: LIST
27350: PUSH
27351: LD_INT 1
27353: PUSH
27354: LD_INT 1
27356: PUSH
27357: EMPTY
27358: LIST
27359: LIST
27360: PUSH
27361: LD_INT 0
27363: PUSH
27364: LD_INT 1
27366: PUSH
27367: EMPTY
27368: LIST
27369: LIST
27370: PUSH
27371: LD_INT 1
27373: NEG
27374: PUSH
27375: LD_INT 0
27377: PUSH
27378: EMPTY
27379: LIST
27380: LIST
27381: PUSH
27382: LD_INT 1
27384: NEG
27385: PUSH
27386: LD_INT 1
27388: NEG
27389: PUSH
27390: EMPTY
27391: LIST
27392: LIST
27393: PUSH
27394: LD_INT 1
27396: NEG
27397: PUSH
27398: LD_INT 2
27400: NEG
27401: PUSH
27402: EMPTY
27403: LIST
27404: LIST
27405: PUSH
27406: LD_INT 0
27408: PUSH
27409: LD_INT 2
27411: NEG
27412: PUSH
27413: EMPTY
27414: LIST
27415: LIST
27416: PUSH
27417: LD_INT 1
27419: PUSH
27420: LD_INT 1
27422: NEG
27423: PUSH
27424: EMPTY
27425: LIST
27426: LIST
27427: PUSH
27428: LD_INT 2
27430: PUSH
27431: LD_INT 0
27433: PUSH
27434: EMPTY
27435: LIST
27436: LIST
27437: PUSH
27438: LD_INT 2
27440: PUSH
27441: LD_INT 1
27443: PUSH
27444: EMPTY
27445: LIST
27446: LIST
27447: PUSH
27448: LD_INT 2
27450: PUSH
27451: LD_INT 2
27453: PUSH
27454: EMPTY
27455: LIST
27456: LIST
27457: PUSH
27458: LD_INT 1
27460: PUSH
27461: LD_INT 2
27463: PUSH
27464: EMPTY
27465: LIST
27466: LIST
27467: PUSH
27468: LD_INT 0
27470: PUSH
27471: LD_INT 2
27473: PUSH
27474: EMPTY
27475: LIST
27476: LIST
27477: PUSH
27478: LD_INT 1
27480: NEG
27481: PUSH
27482: LD_INT 1
27484: PUSH
27485: EMPTY
27486: LIST
27487: LIST
27488: PUSH
27489: LD_INT 2
27491: NEG
27492: PUSH
27493: LD_INT 0
27495: PUSH
27496: EMPTY
27497: LIST
27498: LIST
27499: PUSH
27500: LD_INT 2
27502: NEG
27503: PUSH
27504: LD_INT 1
27506: NEG
27507: PUSH
27508: EMPTY
27509: LIST
27510: LIST
27511: PUSH
27512: LD_INT 2
27514: NEG
27515: PUSH
27516: LD_INT 2
27518: NEG
27519: PUSH
27520: EMPTY
27521: LIST
27522: LIST
27523: PUSH
27524: LD_INT 3
27526: PUSH
27527: LD_INT 1
27529: PUSH
27530: EMPTY
27531: LIST
27532: LIST
27533: PUSH
27534: LD_INT 3
27536: PUSH
27537: LD_INT 2
27539: PUSH
27540: EMPTY
27541: LIST
27542: LIST
27543: PUSH
27544: LD_INT 2
27546: PUSH
27547: LD_INT 3
27549: PUSH
27550: EMPTY
27551: LIST
27552: LIST
27553: PUSH
27554: LD_INT 1
27556: PUSH
27557: LD_INT 3
27559: PUSH
27560: EMPTY
27561: LIST
27562: LIST
27563: PUSH
27564: EMPTY
27565: LIST
27566: LIST
27567: LIST
27568: LIST
27569: LIST
27570: LIST
27571: LIST
27572: LIST
27573: LIST
27574: LIST
27575: LIST
27576: LIST
27577: LIST
27578: LIST
27579: LIST
27580: LIST
27581: LIST
27582: LIST
27583: LIST
27584: LIST
27585: LIST
27586: LIST
27587: LIST
27588: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
27589: LD_ADDR_VAR 0 26
27593: PUSH
27594: LD_INT 0
27596: PUSH
27597: LD_INT 0
27599: PUSH
27600: EMPTY
27601: LIST
27602: LIST
27603: PUSH
27604: LD_INT 0
27606: PUSH
27607: LD_INT 1
27609: NEG
27610: PUSH
27611: EMPTY
27612: LIST
27613: LIST
27614: PUSH
27615: LD_INT 1
27617: PUSH
27618: LD_INT 0
27620: PUSH
27621: EMPTY
27622: LIST
27623: LIST
27624: PUSH
27625: LD_INT 1
27627: PUSH
27628: LD_INT 1
27630: PUSH
27631: EMPTY
27632: LIST
27633: LIST
27634: PUSH
27635: LD_INT 0
27637: PUSH
27638: LD_INT 1
27640: PUSH
27641: EMPTY
27642: LIST
27643: LIST
27644: PUSH
27645: LD_INT 1
27647: NEG
27648: PUSH
27649: LD_INT 0
27651: PUSH
27652: EMPTY
27653: LIST
27654: LIST
27655: PUSH
27656: LD_INT 1
27658: NEG
27659: PUSH
27660: LD_INT 1
27662: NEG
27663: PUSH
27664: EMPTY
27665: LIST
27666: LIST
27667: PUSH
27668: LD_INT 1
27670: NEG
27671: PUSH
27672: LD_INT 2
27674: NEG
27675: PUSH
27676: EMPTY
27677: LIST
27678: LIST
27679: PUSH
27680: LD_INT 0
27682: PUSH
27683: LD_INT 2
27685: NEG
27686: PUSH
27687: EMPTY
27688: LIST
27689: LIST
27690: PUSH
27691: LD_INT 1
27693: PUSH
27694: LD_INT 1
27696: NEG
27697: PUSH
27698: EMPTY
27699: LIST
27700: LIST
27701: PUSH
27702: LD_INT 2
27704: PUSH
27705: LD_INT 0
27707: PUSH
27708: EMPTY
27709: LIST
27710: LIST
27711: PUSH
27712: LD_INT 2
27714: PUSH
27715: LD_INT 1
27717: PUSH
27718: EMPTY
27719: LIST
27720: LIST
27721: PUSH
27722: LD_INT 2
27724: PUSH
27725: LD_INT 2
27727: PUSH
27728: EMPTY
27729: LIST
27730: LIST
27731: PUSH
27732: LD_INT 1
27734: PUSH
27735: LD_INT 2
27737: PUSH
27738: EMPTY
27739: LIST
27740: LIST
27741: PUSH
27742: LD_INT 0
27744: PUSH
27745: LD_INT 2
27747: PUSH
27748: EMPTY
27749: LIST
27750: LIST
27751: PUSH
27752: LD_INT 1
27754: NEG
27755: PUSH
27756: LD_INT 1
27758: PUSH
27759: EMPTY
27760: LIST
27761: LIST
27762: PUSH
27763: LD_INT 2
27765: NEG
27766: PUSH
27767: LD_INT 0
27769: PUSH
27770: EMPTY
27771: LIST
27772: LIST
27773: PUSH
27774: LD_INT 2
27776: NEG
27777: PUSH
27778: LD_INT 1
27780: NEG
27781: PUSH
27782: EMPTY
27783: LIST
27784: LIST
27785: PUSH
27786: LD_INT 2
27788: NEG
27789: PUSH
27790: LD_INT 2
27792: NEG
27793: PUSH
27794: EMPTY
27795: LIST
27796: LIST
27797: PUSH
27798: LD_INT 2
27800: PUSH
27801: LD_INT 3
27803: PUSH
27804: EMPTY
27805: LIST
27806: LIST
27807: PUSH
27808: LD_INT 1
27810: PUSH
27811: LD_INT 3
27813: PUSH
27814: EMPTY
27815: LIST
27816: LIST
27817: PUSH
27818: LD_INT 1
27820: NEG
27821: PUSH
27822: LD_INT 2
27824: PUSH
27825: EMPTY
27826: LIST
27827: LIST
27828: PUSH
27829: LD_INT 2
27831: NEG
27832: PUSH
27833: LD_INT 1
27835: PUSH
27836: EMPTY
27837: LIST
27838: LIST
27839: PUSH
27840: EMPTY
27841: LIST
27842: LIST
27843: LIST
27844: LIST
27845: LIST
27846: LIST
27847: LIST
27848: LIST
27849: LIST
27850: LIST
27851: LIST
27852: LIST
27853: LIST
27854: LIST
27855: LIST
27856: LIST
27857: LIST
27858: LIST
27859: LIST
27860: LIST
27861: LIST
27862: LIST
27863: LIST
27864: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
27865: LD_ADDR_VAR 0 27
27869: PUSH
27870: LD_INT 0
27872: PUSH
27873: LD_INT 0
27875: PUSH
27876: EMPTY
27877: LIST
27878: LIST
27879: PUSH
27880: LD_INT 0
27882: PUSH
27883: LD_INT 1
27885: NEG
27886: PUSH
27887: EMPTY
27888: LIST
27889: LIST
27890: PUSH
27891: LD_INT 1
27893: PUSH
27894: LD_INT 0
27896: PUSH
27897: EMPTY
27898: LIST
27899: LIST
27900: PUSH
27901: LD_INT 1
27903: PUSH
27904: LD_INT 1
27906: PUSH
27907: EMPTY
27908: LIST
27909: LIST
27910: PUSH
27911: LD_INT 0
27913: PUSH
27914: LD_INT 1
27916: PUSH
27917: EMPTY
27918: LIST
27919: LIST
27920: PUSH
27921: LD_INT 1
27923: NEG
27924: PUSH
27925: LD_INT 0
27927: PUSH
27928: EMPTY
27929: LIST
27930: LIST
27931: PUSH
27932: LD_INT 1
27934: NEG
27935: PUSH
27936: LD_INT 1
27938: NEG
27939: PUSH
27940: EMPTY
27941: LIST
27942: LIST
27943: PUSH
27944: LD_INT 1
27946: NEG
27947: PUSH
27948: LD_INT 2
27950: NEG
27951: PUSH
27952: EMPTY
27953: LIST
27954: LIST
27955: PUSH
27956: LD_INT 0
27958: PUSH
27959: LD_INT 2
27961: NEG
27962: PUSH
27963: EMPTY
27964: LIST
27965: LIST
27966: PUSH
27967: LD_INT 1
27969: PUSH
27970: LD_INT 1
27972: NEG
27973: PUSH
27974: EMPTY
27975: LIST
27976: LIST
27977: PUSH
27978: LD_INT 2
27980: PUSH
27981: LD_INT 0
27983: PUSH
27984: EMPTY
27985: LIST
27986: LIST
27987: PUSH
27988: LD_INT 2
27990: PUSH
27991: LD_INT 1
27993: PUSH
27994: EMPTY
27995: LIST
27996: LIST
27997: PUSH
27998: LD_INT 2
28000: PUSH
28001: LD_INT 2
28003: PUSH
28004: EMPTY
28005: LIST
28006: LIST
28007: PUSH
28008: LD_INT 1
28010: PUSH
28011: LD_INT 2
28013: PUSH
28014: EMPTY
28015: LIST
28016: LIST
28017: PUSH
28018: LD_INT 0
28020: PUSH
28021: LD_INT 2
28023: PUSH
28024: EMPTY
28025: LIST
28026: LIST
28027: PUSH
28028: LD_INT 1
28030: NEG
28031: PUSH
28032: LD_INT 1
28034: PUSH
28035: EMPTY
28036: LIST
28037: LIST
28038: PUSH
28039: LD_INT 2
28041: NEG
28042: PUSH
28043: LD_INT 0
28045: PUSH
28046: EMPTY
28047: LIST
28048: LIST
28049: PUSH
28050: LD_INT 2
28052: NEG
28053: PUSH
28054: LD_INT 1
28056: NEG
28057: PUSH
28058: EMPTY
28059: LIST
28060: LIST
28061: PUSH
28062: LD_INT 2
28064: NEG
28065: PUSH
28066: LD_INT 2
28068: NEG
28069: PUSH
28070: EMPTY
28071: LIST
28072: LIST
28073: PUSH
28074: LD_INT 1
28076: NEG
28077: PUSH
28078: LD_INT 2
28080: PUSH
28081: EMPTY
28082: LIST
28083: LIST
28084: PUSH
28085: LD_INT 2
28087: NEG
28088: PUSH
28089: LD_INT 1
28091: PUSH
28092: EMPTY
28093: LIST
28094: LIST
28095: PUSH
28096: LD_INT 3
28098: NEG
28099: PUSH
28100: LD_INT 1
28102: NEG
28103: PUSH
28104: EMPTY
28105: LIST
28106: LIST
28107: PUSH
28108: LD_INT 3
28110: NEG
28111: PUSH
28112: LD_INT 2
28114: NEG
28115: PUSH
28116: EMPTY
28117: LIST
28118: LIST
28119: PUSH
28120: EMPTY
28121: LIST
28122: LIST
28123: LIST
28124: LIST
28125: LIST
28126: LIST
28127: LIST
28128: LIST
28129: LIST
28130: LIST
28131: LIST
28132: LIST
28133: LIST
28134: LIST
28135: LIST
28136: LIST
28137: LIST
28138: LIST
28139: LIST
28140: LIST
28141: LIST
28142: LIST
28143: LIST
28144: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
28145: LD_ADDR_VAR 0 28
28149: PUSH
28150: LD_INT 0
28152: PUSH
28153: LD_INT 0
28155: PUSH
28156: EMPTY
28157: LIST
28158: LIST
28159: PUSH
28160: LD_INT 0
28162: PUSH
28163: LD_INT 1
28165: NEG
28166: PUSH
28167: EMPTY
28168: LIST
28169: LIST
28170: PUSH
28171: LD_INT 1
28173: PUSH
28174: LD_INT 0
28176: PUSH
28177: EMPTY
28178: LIST
28179: LIST
28180: PUSH
28181: LD_INT 1
28183: PUSH
28184: LD_INT 1
28186: PUSH
28187: EMPTY
28188: LIST
28189: LIST
28190: PUSH
28191: LD_INT 0
28193: PUSH
28194: LD_INT 1
28196: PUSH
28197: EMPTY
28198: LIST
28199: LIST
28200: PUSH
28201: LD_INT 1
28203: NEG
28204: PUSH
28205: LD_INT 0
28207: PUSH
28208: EMPTY
28209: LIST
28210: LIST
28211: PUSH
28212: LD_INT 1
28214: NEG
28215: PUSH
28216: LD_INT 1
28218: NEG
28219: PUSH
28220: EMPTY
28221: LIST
28222: LIST
28223: PUSH
28224: LD_INT 1
28226: NEG
28227: PUSH
28228: LD_INT 2
28230: NEG
28231: PUSH
28232: EMPTY
28233: LIST
28234: LIST
28235: PUSH
28236: LD_INT 0
28238: PUSH
28239: LD_INT 2
28241: NEG
28242: PUSH
28243: EMPTY
28244: LIST
28245: LIST
28246: PUSH
28247: LD_INT 1
28249: PUSH
28250: LD_INT 1
28252: NEG
28253: PUSH
28254: EMPTY
28255: LIST
28256: LIST
28257: PUSH
28258: LD_INT 2
28260: PUSH
28261: LD_INT 0
28263: PUSH
28264: EMPTY
28265: LIST
28266: LIST
28267: PUSH
28268: LD_INT 2
28270: PUSH
28271: LD_INT 1
28273: PUSH
28274: EMPTY
28275: LIST
28276: LIST
28277: PUSH
28278: LD_INT 2
28280: PUSH
28281: LD_INT 2
28283: PUSH
28284: EMPTY
28285: LIST
28286: LIST
28287: PUSH
28288: LD_INT 1
28290: PUSH
28291: LD_INT 2
28293: PUSH
28294: EMPTY
28295: LIST
28296: LIST
28297: PUSH
28298: LD_INT 0
28300: PUSH
28301: LD_INT 2
28303: PUSH
28304: EMPTY
28305: LIST
28306: LIST
28307: PUSH
28308: LD_INT 1
28310: NEG
28311: PUSH
28312: LD_INT 1
28314: PUSH
28315: EMPTY
28316: LIST
28317: LIST
28318: PUSH
28319: LD_INT 2
28321: NEG
28322: PUSH
28323: LD_INT 0
28325: PUSH
28326: EMPTY
28327: LIST
28328: LIST
28329: PUSH
28330: LD_INT 2
28332: NEG
28333: PUSH
28334: LD_INT 1
28336: NEG
28337: PUSH
28338: EMPTY
28339: LIST
28340: LIST
28341: PUSH
28342: LD_INT 2
28344: NEG
28345: PUSH
28346: LD_INT 2
28348: NEG
28349: PUSH
28350: EMPTY
28351: LIST
28352: LIST
28353: PUSH
28354: LD_INT 2
28356: NEG
28357: PUSH
28358: LD_INT 3
28360: NEG
28361: PUSH
28362: EMPTY
28363: LIST
28364: LIST
28365: PUSH
28366: LD_INT 1
28368: NEG
28369: PUSH
28370: LD_INT 3
28372: NEG
28373: PUSH
28374: EMPTY
28375: LIST
28376: LIST
28377: PUSH
28378: LD_INT 3
28380: NEG
28381: PUSH
28382: LD_INT 1
28384: NEG
28385: PUSH
28386: EMPTY
28387: LIST
28388: LIST
28389: PUSH
28390: LD_INT 3
28392: NEG
28393: PUSH
28394: LD_INT 2
28396: NEG
28397: PUSH
28398: EMPTY
28399: LIST
28400: LIST
28401: PUSH
28402: EMPTY
28403: LIST
28404: LIST
28405: LIST
28406: LIST
28407: LIST
28408: LIST
28409: LIST
28410: LIST
28411: LIST
28412: LIST
28413: LIST
28414: LIST
28415: LIST
28416: LIST
28417: LIST
28418: LIST
28419: LIST
28420: LIST
28421: LIST
28422: LIST
28423: LIST
28424: LIST
28425: LIST
28426: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
28427: LD_ADDR_VAR 0 29
28431: PUSH
28432: LD_INT 0
28434: PUSH
28435: LD_INT 0
28437: PUSH
28438: EMPTY
28439: LIST
28440: LIST
28441: PUSH
28442: LD_INT 0
28444: PUSH
28445: LD_INT 1
28447: NEG
28448: PUSH
28449: EMPTY
28450: LIST
28451: LIST
28452: PUSH
28453: LD_INT 1
28455: PUSH
28456: LD_INT 0
28458: PUSH
28459: EMPTY
28460: LIST
28461: LIST
28462: PUSH
28463: LD_INT 1
28465: PUSH
28466: LD_INT 1
28468: PUSH
28469: EMPTY
28470: LIST
28471: LIST
28472: PUSH
28473: LD_INT 0
28475: PUSH
28476: LD_INT 1
28478: PUSH
28479: EMPTY
28480: LIST
28481: LIST
28482: PUSH
28483: LD_INT 1
28485: NEG
28486: PUSH
28487: LD_INT 0
28489: PUSH
28490: EMPTY
28491: LIST
28492: LIST
28493: PUSH
28494: LD_INT 1
28496: NEG
28497: PUSH
28498: LD_INT 1
28500: NEG
28501: PUSH
28502: EMPTY
28503: LIST
28504: LIST
28505: PUSH
28506: LD_INT 1
28508: NEG
28509: PUSH
28510: LD_INT 2
28512: NEG
28513: PUSH
28514: EMPTY
28515: LIST
28516: LIST
28517: PUSH
28518: LD_INT 0
28520: PUSH
28521: LD_INT 2
28523: NEG
28524: PUSH
28525: EMPTY
28526: LIST
28527: LIST
28528: PUSH
28529: LD_INT 1
28531: PUSH
28532: LD_INT 1
28534: NEG
28535: PUSH
28536: EMPTY
28537: LIST
28538: LIST
28539: PUSH
28540: LD_INT 2
28542: PUSH
28543: LD_INT 0
28545: PUSH
28546: EMPTY
28547: LIST
28548: LIST
28549: PUSH
28550: LD_INT 2
28552: PUSH
28553: LD_INT 1
28555: PUSH
28556: EMPTY
28557: LIST
28558: LIST
28559: PUSH
28560: LD_INT 1
28562: PUSH
28563: LD_INT 2
28565: PUSH
28566: EMPTY
28567: LIST
28568: LIST
28569: PUSH
28570: LD_INT 0
28572: PUSH
28573: LD_INT 2
28575: PUSH
28576: EMPTY
28577: LIST
28578: LIST
28579: PUSH
28580: LD_INT 1
28582: NEG
28583: PUSH
28584: LD_INT 1
28586: PUSH
28587: EMPTY
28588: LIST
28589: LIST
28590: PUSH
28591: LD_INT 2
28593: NEG
28594: PUSH
28595: LD_INT 1
28597: NEG
28598: PUSH
28599: EMPTY
28600: LIST
28601: LIST
28602: PUSH
28603: LD_INT 2
28605: NEG
28606: PUSH
28607: LD_INT 2
28609: NEG
28610: PUSH
28611: EMPTY
28612: LIST
28613: LIST
28614: PUSH
28615: LD_INT 2
28617: NEG
28618: PUSH
28619: LD_INT 3
28621: NEG
28622: PUSH
28623: EMPTY
28624: LIST
28625: LIST
28626: PUSH
28627: LD_INT 2
28629: PUSH
28630: LD_INT 1
28632: NEG
28633: PUSH
28634: EMPTY
28635: LIST
28636: LIST
28637: PUSH
28638: LD_INT 3
28640: PUSH
28641: LD_INT 1
28643: PUSH
28644: EMPTY
28645: LIST
28646: LIST
28647: PUSH
28648: LD_INT 1
28650: PUSH
28651: LD_INT 3
28653: PUSH
28654: EMPTY
28655: LIST
28656: LIST
28657: PUSH
28658: LD_INT 1
28660: NEG
28661: PUSH
28662: LD_INT 2
28664: PUSH
28665: EMPTY
28666: LIST
28667: LIST
28668: PUSH
28669: LD_INT 3
28671: NEG
28672: PUSH
28673: LD_INT 2
28675: NEG
28676: PUSH
28677: EMPTY
28678: LIST
28679: LIST
28680: PUSH
28681: EMPTY
28682: LIST
28683: LIST
28684: LIST
28685: LIST
28686: LIST
28687: LIST
28688: LIST
28689: LIST
28690: LIST
28691: LIST
28692: LIST
28693: LIST
28694: LIST
28695: LIST
28696: LIST
28697: LIST
28698: LIST
28699: LIST
28700: LIST
28701: LIST
28702: LIST
28703: LIST
28704: LIST
28705: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
28706: LD_ADDR_VAR 0 30
28710: PUSH
28711: LD_INT 0
28713: PUSH
28714: LD_INT 0
28716: PUSH
28717: EMPTY
28718: LIST
28719: LIST
28720: PUSH
28721: LD_INT 0
28723: PUSH
28724: LD_INT 1
28726: NEG
28727: PUSH
28728: EMPTY
28729: LIST
28730: LIST
28731: PUSH
28732: LD_INT 1
28734: PUSH
28735: LD_INT 0
28737: PUSH
28738: EMPTY
28739: LIST
28740: LIST
28741: PUSH
28742: LD_INT 1
28744: PUSH
28745: LD_INT 1
28747: PUSH
28748: EMPTY
28749: LIST
28750: LIST
28751: PUSH
28752: LD_INT 0
28754: PUSH
28755: LD_INT 1
28757: PUSH
28758: EMPTY
28759: LIST
28760: LIST
28761: PUSH
28762: LD_INT 1
28764: NEG
28765: PUSH
28766: LD_INT 0
28768: PUSH
28769: EMPTY
28770: LIST
28771: LIST
28772: PUSH
28773: LD_INT 1
28775: NEG
28776: PUSH
28777: LD_INT 1
28779: NEG
28780: PUSH
28781: EMPTY
28782: LIST
28783: LIST
28784: PUSH
28785: LD_INT 1
28787: NEG
28788: PUSH
28789: LD_INT 2
28791: NEG
28792: PUSH
28793: EMPTY
28794: LIST
28795: LIST
28796: PUSH
28797: LD_INT 0
28799: PUSH
28800: LD_INT 2
28802: NEG
28803: PUSH
28804: EMPTY
28805: LIST
28806: LIST
28807: PUSH
28808: LD_INT 1
28810: PUSH
28811: LD_INT 1
28813: NEG
28814: PUSH
28815: EMPTY
28816: LIST
28817: LIST
28818: PUSH
28819: LD_INT 2
28821: PUSH
28822: LD_INT 0
28824: PUSH
28825: EMPTY
28826: LIST
28827: LIST
28828: PUSH
28829: LD_INT 2
28831: PUSH
28832: LD_INT 1
28834: PUSH
28835: EMPTY
28836: LIST
28837: LIST
28838: PUSH
28839: LD_INT 2
28841: PUSH
28842: LD_INT 2
28844: PUSH
28845: EMPTY
28846: LIST
28847: LIST
28848: PUSH
28849: LD_INT 1
28851: PUSH
28852: LD_INT 2
28854: PUSH
28855: EMPTY
28856: LIST
28857: LIST
28858: PUSH
28859: LD_INT 1
28861: NEG
28862: PUSH
28863: LD_INT 1
28865: PUSH
28866: EMPTY
28867: LIST
28868: LIST
28869: PUSH
28870: LD_INT 2
28872: NEG
28873: PUSH
28874: LD_INT 0
28876: PUSH
28877: EMPTY
28878: LIST
28879: LIST
28880: PUSH
28881: LD_INT 2
28883: NEG
28884: PUSH
28885: LD_INT 1
28887: NEG
28888: PUSH
28889: EMPTY
28890: LIST
28891: LIST
28892: PUSH
28893: LD_INT 1
28895: NEG
28896: PUSH
28897: LD_INT 3
28899: NEG
28900: PUSH
28901: EMPTY
28902: LIST
28903: LIST
28904: PUSH
28905: LD_INT 1
28907: PUSH
28908: LD_INT 2
28910: NEG
28911: PUSH
28912: EMPTY
28913: LIST
28914: LIST
28915: PUSH
28916: LD_INT 3
28918: PUSH
28919: LD_INT 2
28921: PUSH
28922: EMPTY
28923: LIST
28924: LIST
28925: PUSH
28926: LD_INT 2
28928: PUSH
28929: LD_INT 3
28931: PUSH
28932: EMPTY
28933: LIST
28934: LIST
28935: PUSH
28936: LD_INT 2
28938: NEG
28939: PUSH
28940: LD_INT 1
28942: PUSH
28943: EMPTY
28944: LIST
28945: LIST
28946: PUSH
28947: LD_INT 3
28949: NEG
28950: PUSH
28951: LD_INT 1
28953: NEG
28954: PUSH
28955: EMPTY
28956: LIST
28957: LIST
28958: PUSH
28959: EMPTY
28960: LIST
28961: LIST
28962: LIST
28963: LIST
28964: LIST
28965: LIST
28966: LIST
28967: LIST
28968: LIST
28969: LIST
28970: LIST
28971: LIST
28972: LIST
28973: LIST
28974: LIST
28975: LIST
28976: LIST
28977: LIST
28978: LIST
28979: LIST
28980: LIST
28981: LIST
28982: LIST
28983: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
28984: LD_ADDR_VAR 0 31
28988: PUSH
28989: LD_INT 0
28991: PUSH
28992: LD_INT 0
28994: PUSH
28995: EMPTY
28996: LIST
28997: LIST
28998: PUSH
28999: LD_INT 0
29001: PUSH
29002: LD_INT 1
29004: NEG
29005: PUSH
29006: EMPTY
29007: LIST
29008: LIST
29009: PUSH
29010: LD_INT 1
29012: PUSH
29013: LD_INT 0
29015: PUSH
29016: EMPTY
29017: LIST
29018: LIST
29019: PUSH
29020: LD_INT 1
29022: PUSH
29023: LD_INT 1
29025: PUSH
29026: EMPTY
29027: LIST
29028: LIST
29029: PUSH
29030: LD_INT 0
29032: PUSH
29033: LD_INT 1
29035: PUSH
29036: EMPTY
29037: LIST
29038: LIST
29039: PUSH
29040: LD_INT 1
29042: NEG
29043: PUSH
29044: LD_INT 0
29046: PUSH
29047: EMPTY
29048: LIST
29049: LIST
29050: PUSH
29051: LD_INT 1
29053: NEG
29054: PUSH
29055: LD_INT 1
29057: NEG
29058: PUSH
29059: EMPTY
29060: LIST
29061: LIST
29062: PUSH
29063: LD_INT 1
29065: NEG
29066: PUSH
29067: LD_INT 2
29069: NEG
29070: PUSH
29071: EMPTY
29072: LIST
29073: LIST
29074: PUSH
29075: LD_INT 1
29077: PUSH
29078: LD_INT 1
29080: NEG
29081: PUSH
29082: EMPTY
29083: LIST
29084: LIST
29085: PUSH
29086: LD_INT 2
29088: PUSH
29089: LD_INT 0
29091: PUSH
29092: EMPTY
29093: LIST
29094: LIST
29095: PUSH
29096: LD_INT 2
29098: PUSH
29099: LD_INT 1
29101: PUSH
29102: EMPTY
29103: LIST
29104: LIST
29105: PUSH
29106: LD_INT 2
29108: PUSH
29109: LD_INT 2
29111: PUSH
29112: EMPTY
29113: LIST
29114: LIST
29115: PUSH
29116: LD_INT 1
29118: PUSH
29119: LD_INT 2
29121: PUSH
29122: EMPTY
29123: LIST
29124: LIST
29125: PUSH
29126: LD_INT 0
29128: PUSH
29129: LD_INT 2
29131: PUSH
29132: EMPTY
29133: LIST
29134: LIST
29135: PUSH
29136: LD_INT 1
29138: NEG
29139: PUSH
29140: LD_INT 1
29142: PUSH
29143: EMPTY
29144: LIST
29145: LIST
29146: PUSH
29147: LD_INT 2
29149: NEG
29150: PUSH
29151: LD_INT 1
29153: NEG
29154: PUSH
29155: EMPTY
29156: LIST
29157: LIST
29158: PUSH
29159: LD_INT 2
29161: NEG
29162: PUSH
29163: LD_INT 2
29165: NEG
29166: PUSH
29167: EMPTY
29168: LIST
29169: LIST
29170: PUSH
29171: LD_INT 2
29173: NEG
29174: PUSH
29175: LD_INT 3
29177: NEG
29178: PUSH
29179: EMPTY
29180: LIST
29181: LIST
29182: PUSH
29183: LD_INT 2
29185: PUSH
29186: LD_INT 1
29188: NEG
29189: PUSH
29190: EMPTY
29191: LIST
29192: LIST
29193: PUSH
29194: LD_INT 3
29196: PUSH
29197: LD_INT 1
29199: PUSH
29200: EMPTY
29201: LIST
29202: LIST
29203: PUSH
29204: LD_INT 1
29206: PUSH
29207: LD_INT 3
29209: PUSH
29210: EMPTY
29211: LIST
29212: LIST
29213: PUSH
29214: LD_INT 1
29216: NEG
29217: PUSH
29218: LD_INT 2
29220: PUSH
29221: EMPTY
29222: LIST
29223: LIST
29224: PUSH
29225: LD_INT 3
29227: NEG
29228: PUSH
29229: LD_INT 2
29231: NEG
29232: PUSH
29233: EMPTY
29234: LIST
29235: LIST
29236: PUSH
29237: EMPTY
29238: LIST
29239: LIST
29240: LIST
29241: LIST
29242: LIST
29243: LIST
29244: LIST
29245: LIST
29246: LIST
29247: LIST
29248: LIST
29249: LIST
29250: LIST
29251: LIST
29252: LIST
29253: LIST
29254: LIST
29255: LIST
29256: LIST
29257: LIST
29258: LIST
29259: LIST
29260: LIST
29261: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
29262: LD_ADDR_VAR 0 32
29266: PUSH
29267: LD_INT 0
29269: PUSH
29270: LD_INT 0
29272: PUSH
29273: EMPTY
29274: LIST
29275: LIST
29276: PUSH
29277: LD_INT 0
29279: PUSH
29280: LD_INT 1
29282: NEG
29283: PUSH
29284: EMPTY
29285: LIST
29286: LIST
29287: PUSH
29288: LD_INT 1
29290: PUSH
29291: LD_INT 0
29293: PUSH
29294: EMPTY
29295: LIST
29296: LIST
29297: PUSH
29298: LD_INT 1
29300: PUSH
29301: LD_INT 1
29303: PUSH
29304: EMPTY
29305: LIST
29306: LIST
29307: PUSH
29308: LD_INT 0
29310: PUSH
29311: LD_INT 1
29313: PUSH
29314: EMPTY
29315: LIST
29316: LIST
29317: PUSH
29318: LD_INT 1
29320: NEG
29321: PUSH
29322: LD_INT 0
29324: PUSH
29325: EMPTY
29326: LIST
29327: LIST
29328: PUSH
29329: LD_INT 1
29331: NEG
29332: PUSH
29333: LD_INT 1
29335: NEG
29336: PUSH
29337: EMPTY
29338: LIST
29339: LIST
29340: PUSH
29341: LD_INT 1
29343: NEG
29344: PUSH
29345: LD_INT 2
29347: NEG
29348: PUSH
29349: EMPTY
29350: LIST
29351: LIST
29352: PUSH
29353: LD_INT 0
29355: PUSH
29356: LD_INT 2
29358: NEG
29359: PUSH
29360: EMPTY
29361: LIST
29362: LIST
29363: PUSH
29364: LD_INT 1
29366: PUSH
29367: LD_INT 1
29369: NEG
29370: PUSH
29371: EMPTY
29372: LIST
29373: LIST
29374: PUSH
29375: LD_INT 2
29377: PUSH
29378: LD_INT 1
29380: PUSH
29381: EMPTY
29382: LIST
29383: LIST
29384: PUSH
29385: LD_INT 2
29387: PUSH
29388: LD_INT 2
29390: PUSH
29391: EMPTY
29392: LIST
29393: LIST
29394: PUSH
29395: LD_INT 1
29397: PUSH
29398: LD_INT 2
29400: PUSH
29401: EMPTY
29402: LIST
29403: LIST
29404: PUSH
29405: LD_INT 0
29407: PUSH
29408: LD_INT 2
29410: PUSH
29411: EMPTY
29412: LIST
29413: LIST
29414: PUSH
29415: LD_INT 1
29417: NEG
29418: PUSH
29419: LD_INT 1
29421: PUSH
29422: EMPTY
29423: LIST
29424: LIST
29425: PUSH
29426: LD_INT 2
29428: NEG
29429: PUSH
29430: LD_INT 0
29432: PUSH
29433: EMPTY
29434: LIST
29435: LIST
29436: PUSH
29437: LD_INT 2
29439: NEG
29440: PUSH
29441: LD_INT 1
29443: NEG
29444: PUSH
29445: EMPTY
29446: LIST
29447: LIST
29448: PUSH
29449: LD_INT 1
29451: NEG
29452: PUSH
29453: LD_INT 3
29455: NEG
29456: PUSH
29457: EMPTY
29458: LIST
29459: LIST
29460: PUSH
29461: LD_INT 1
29463: PUSH
29464: LD_INT 2
29466: NEG
29467: PUSH
29468: EMPTY
29469: LIST
29470: LIST
29471: PUSH
29472: LD_INT 3
29474: PUSH
29475: LD_INT 2
29477: PUSH
29478: EMPTY
29479: LIST
29480: LIST
29481: PUSH
29482: LD_INT 2
29484: PUSH
29485: LD_INT 3
29487: PUSH
29488: EMPTY
29489: LIST
29490: LIST
29491: PUSH
29492: LD_INT 2
29494: NEG
29495: PUSH
29496: LD_INT 1
29498: PUSH
29499: EMPTY
29500: LIST
29501: LIST
29502: PUSH
29503: LD_INT 3
29505: NEG
29506: PUSH
29507: LD_INT 1
29509: NEG
29510: PUSH
29511: EMPTY
29512: LIST
29513: LIST
29514: PUSH
29515: EMPTY
29516: LIST
29517: LIST
29518: LIST
29519: LIST
29520: LIST
29521: LIST
29522: LIST
29523: LIST
29524: LIST
29525: LIST
29526: LIST
29527: LIST
29528: LIST
29529: LIST
29530: LIST
29531: LIST
29532: LIST
29533: LIST
29534: LIST
29535: LIST
29536: LIST
29537: LIST
29538: LIST
29539: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
29540: LD_ADDR_VAR 0 33
29544: PUSH
29545: LD_INT 0
29547: PUSH
29548: LD_INT 0
29550: PUSH
29551: EMPTY
29552: LIST
29553: LIST
29554: PUSH
29555: LD_INT 0
29557: PUSH
29558: LD_INT 1
29560: NEG
29561: PUSH
29562: EMPTY
29563: LIST
29564: LIST
29565: PUSH
29566: LD_INT 1
29568: PUSH
29569: LD_INT 0
29571: PUSH
29572: EMPTY
29573: LIST
29574: LIST
29575: PUSH
29576: LD_INT 1
29578: PUSH
29579: LD_INT 1
29581: PUSH
29582: EMPTY
29583: LIST
29584: LIST
29585: PUSH
29586: LD_INT 0
29588: PUSH
29589: LD_INT 1
29591: PUSH
29592: EMPTY
29593: LIST
29594: LIST
29595: PUSH
29596: LD_INT 1
29598: NEG
29599: PUSH
29600: LD_INT 0
29602: PUSH
29603: EMPTY
29604: LIST
29605: LIST
29606: PUSH
29607: LD_INT 1
29609: NEG
29610: PUSH
29611: LD_INT 1
29613: NEG
29614: PUSH
29615: EMPTY
29616: LIST
29617: LIST
29618: PUSH
29619: LD_INT 1
29621: NEG
29622: PUSH
29623: LD_INT 2
29625: NEG
29626: PUSH
29627: EMPTY
29628: LIST
29629: LIST
29630: PUSH
29631: LD_INT 1
29633: PUSH
29634: LD_INT 1
29636: NEG
29637: PUSH
29638: EMPTY
29639: LIST
29640: LIST
29641: PUSH
29642: LD_INT 2
29644: PUSH
29645: LD_INT 0
29647: PUSH
29648: EMPTY
29649: LIST
29650: LIST
29651: PUSH
29652: LD_INT 2
29654: PUSH
29655: LD_INT 1
29657: PUSH
29658: EMPTY
29659: LIST
29660: LIST
29661: PUSH
29662: LD_INT 1
29664: PUSH
29665: LD_INT 2
29667: PUSH
29668: EMPTY
29669: LIST
29670: LIST
29671: PUSH
29672: LD_INT 0
29674: PUSH
29675: LD_INT 2
29677: PUSH
29678: EMPTY
29679: LIST
29680: LIST
29681: PUSH
29682: LD_INT 1
29684: NEG
29685: PUSH
29686: LD_INT 1
29688: PUSH
29689: EMPTY
29690: LIST
29691: LIST
29692: PUSH
29693: LD_INT 2
29695: NEG
29696: PUSH
29697: LD_INT 0
29699: PUSH
29700: EMPTY
29701: LIST
29702: LIST
29703: PUSH
29704: LD_INT 2
29706: NEG
29707: PUSH
29708: LD_INT 1
29710: NEG
29711: PUSH
29712: EMPTY
29713: LIST
29714: LIST
29715: PUSH
29716: LD_INT 2
29718: NEG
29719: PUSH
29720: LD_INT 2
29722: NEG
29723: PUSH
29724: EMPTY
29725: LIST
29726: LIST
29727: PUSH
29728: LD_INT 2
29730: NEG
29731: PUSH
29732: LD_INT 3
29734: NEG
29735: PUSH
29736: EMPTY
29737: LIST
29738: LIST
29739: PUSH
29740: LD_INT 2
29742: PUSH
29743: LD_INT 1
29745: NEG
29746: PUSH
29747: EMPTY
29748: LIST
29749: LIST
29750: PUSH
29751: LD_INT 3
29753: PUSH
29754: LD_INT 1
29756: PUSH
29757: EMPTY
29758: LIST
29759: LIST
29760: PUSH
29761: LD_INT 1
29763: PUSH
29764: LD_INT 3
29766: PUSH
29767: EMPTY
29768: LIST
29769: LIST
29770: PUSH
29771: LD_INT 1
29773: NEG
29774: PUSH
29775: LD_INT 2
29777: PUSH
29778: EMPTY
29779: LIST
29780: LIST
29781: PUSH
29782: LD_INT 3
29784: NEG
29785: PUSH
29786: LD_INT 2
29788: NEG
29789: PUSH
29790: EMPTY
29791: LIST
29792: LIST
29793: PUSH
29794: EMPTY
29795: LIST
29796: LIST
29797: LIST
29798: LIST
29799: LIST
29800: LIST
29801: LIST
29802: LIST
29803: LIST
29804: LIST
29805: LIST
29806: LIST
29807: LIST
29808: LIST
29809: LIST
29810: LIST
29811: LIST
29812: LIST
29813: LIST
29814: LIST
29815: LIST
29816: LIST
29817: LIST
29818: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
29819: LD_ADDR_VAR 0 34
29823: PUSH
29824: LD_INT 0
29826: PUSH
29827: LD_INT 0
29829: PUSH
29830: EMPTY
29831: LIST
29832: LIST
29833: PUSH
29834: LD_INT 0
29836: PUSH
29837: LD_INT 1
29839: NEG
29840: PUSH
29841: EMPTY
29842: LIST
29843: LIST
29844: PUSH
29845: LD_INT 1
29847: PUSH
29848: LD_INT 0
29850: PUSH
29851: EMPTY
29852: LIST
29853: LIST
29854: PUSH
29855: LD_INT 1
29857: PUSH
29858: LD_INT 1
29860: PUSH
29861: EMPTY
29862: LIST
29863: LIST
29864: PUSH
29865: LD_INT 0
29867: PUSH
29868: LD_INT 1
29870: PUSH
29871: EMPTY
29872: LIST
29873: LIST
29874: PUSH
29875: LD_INT 1
29877: NEG
29878: PUSH
29879: LD_INT 0
29881: PUSH
29882: EMPTY
29883: LIST
29884: LIST
29885: PUSH
29886: LD_INT 1
29888: NEG
29889: PUSH
29890: LD_INT 1
29892: NEG
29893: PUSH
29894: EMPTY
29895: LIST
29896: LIST
29897: PUSH
29898: LD_INT 1
29900: NEG
29901: PUSH
29902: LD_INT 2
29904: NEG
29905: PUSH
29906: EMPTY
29907: LIST
29908: LIST
29909: PUSH
29910: LD_INT 0
29912: PUSH
29913: LD_INT 2
29915: NEG
29916: PUSH
29917: EMPTY
29918: LIST
29919: LIST
29920: PUSH
29921: LD_INT 1
29923: PUSH
29924: LD_INT 1
29926: NEG
29927: PUSH
29928: EMPTY
29929: LIST
29930: LIST
29931: PUSH
29932: LD_INT 2
29934: PUSH
29935: LD_INT 1
29937: PUSH
29938: EMPTY
29939: LIST
29940: LIST
29941: PUSH
29942: LD_INT 2
29944: PUSH
29945: LD_INT 2
29947: PUSH
29948: EMPTY
29949: LIST
29950: LIST
29951: PUSH
29952: LD_INT 1
29954: PUSH
29955: LD_INT 2
29957: PUSH
29958: EMPTY
29959: LIST
29960: LIST
29961: PUSH
29962: LD_INT 1
29964: NEG
29965: PUSH
29966: LD_INT 1
29968: PUSH
29969: EMPTY
29970: LIST
29971: LIST
29972: PUSH
29973: LD_INT 2
29975: NEG
29976: PUSH
29977: LD_INT 0
29979: PUSH
29980: EMPTY
29981: LIST
29982: LIST
29983: PUSH
29984: LD_INT 2
29986: NEG
29987: PUSH
29988: LD_INT 1
29990: NEG
29991: PUSH
29992: EMPTY
29993: LIST
29994: LIST
29995: PUSH
29996: LD_INT 2
29998: NEG
29999: PUSH
30000: LD_INT 2
30002: NEG
30003: PUSH
30004: EMPTY
30005: LIST
30006: LIST
30007: PUSH
30008: LD_INT 1
30010: NEG
30011: PUSH
30012: LD_INT 3
30014: NEG
30015: PUSH
30016: EMPTY
30017: LIST
30018: LIST
30019: PUSH
30020: LD_INT 1
30022: PUSH
30023: LD_INT 2
30025: NEG
30026: PUSH
30027: EMPTY
30028: LIST
30029: LIST
30030: PUSH
30031: LD_INT 3
30033: PUSH
30034: LD_INT 2
30036: PUSH
30037: EMPTY
30038: LIST
30039: LIST
30040: PUSH
30041: LD_INT 2
30043: PUSH
30044: LD_INT 3
30046: PUSH
30047: EMPTY
30048: LIST
30049: LIST
30050: PUSH
30051: LD_INT 2
30053: NEG
30054: PUSH
30055: LD_INT 1
30057: PUSH
30058: EMPTY
30059: LIST
30060: LIST
30061: PUSH
30062: LD_INT 3
30064: NEG
30065: PUSH
30066: LD_INT 1
30068: NEG
30069: PUSH
30070: EMPTY
30071: LIST
30072: LIST
30073: PUSH
30074: EMPTY
30075: LIST
30076: LIST
30077: LIST
30078: LIST
30079: LIST
30080: LIST
30081: LIST
30082: LIST
30083: LIST
30084: LIST
30085: LIST
30086: LIST
30087: LIST
30088: LIST
30089: LIST
30090: LIST
30091: LIST
30092: LIST
30093: LIST
30094: LIST
30095: LIST
30096: LIST
30097: LIST
30098: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
30099: LD_ADDR_VAR 0 35
30103: PUSH
30104: LD_INT 0
30106: PUSH
30107: LD_INT 0
30109: PUSH
30110: EMPTY
30111: LIST
30112: LIST
30113: PUSH
30114: LD_INT 0
30116: PUSH
30117: LD_INT 1
30119: NEG
30120: PUSH
30121: EMPTY
30122: LIST
30123: LIST
30124: PUSH
30125: LD_INT 1
30127: PUSH
30128: LD_INT 0
30130: PUSH
30131: EMPTY
30132: LIST
30133: LIST
30134: PUSH
30135: LD_INT 1
30137: PUSH
30138: LD_INT 1
30140: PUSH
30141: EMPTY
30142: LIST
30143: LIST
30144: PUSH
30145: LD_INT 0
30147: PUSH
30148: LD_INT 1
30150: PUSH
30151: EMPTY
30152: LIST
30153: LIST
30154: PUSH
30155: LD_INT 1
30157: NEG
30158: PUSH
30159: LD_INT 0
30161: PUSH
30162: EMPTY
30163: LIST
30164: LIST
30165: PUSH
30166: LD_INT 1
30168: NEG
30169: PUSH
30170: LD_INT 1
30172: NEG
30173: PUSH
30174: EMPTY
30175: LIST
30176: LIST
30177: PUSH
30178: LD_INT 2
30180: PUSH
30181: LD_INT 1
30183: PUSH
30184: EMPTY
30185: LIST
30186: LIST
30187: PUSH
30188: LD_INT 2
30190: NEG
30191: PUSH
30192: LD_INT 1
30194: NEG
30195: PUSH
30196: EMPTY
30197: LIST
30198: LIST
30199: PUSH
30200: EMPTY
30201: LIST
30202: LIST
30203: LIST
30204: LIST
30205: LIST
30206: LIST
30207: LIST
30208: LIST
30209: LIST
30210: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
30211: LD_ADDR_VAR 0 36
30215: PUSH
30216: LD_INT 0
30218: PUSH
30219: LD_INT 0
30221: PUSH
30222: EMPTY
30223: LIST
30224: LIST
30225: PUSH
30226: LD_INT 0
30228: PUSH
30229: LD_INT 1
30231: NEG
30232: PUSH
30233: EMPTY
30234: LIST
30235: LIST
30236: PUSH
30237: LD_INT 1
30239: PUSH
30240: LD_INT 0
30242: PUSH
30243: EMPTY
30244: LIST
30245: LIST
30246: PUSH
30247: LD_INT 1
30249: PUSH
30250: LD_INT 1
30252: PUSH
30253: EMPTY
30254: LIST
30255: LIST
30256: PUSH
30257: LD_INT 0
30259: PUSH
30260: LD_INT 1
30262: PUSH
30263: EMPTY
30264: LIST
30265: LIST
30266: PUSH
30267: LD_INT 1
30269: NEG
30270: PUSH
30271: LD_INT 0
30273: PUSH
30274: EMPTY
30275: LIST
30276: LIST
30277: PUSH
30278: LD_INT 1
30280: NEG
30281: PUSH
30282: LD_INT 1
30284: NEG
30285: PUSH
30286: EMPTY
30287: LIST
30288: LIST
30289: PUSH
30290: LD_INT 1
30292: NEG
30293: PUSH
30294: LD_INT 2
30296: NEG
30297: PUSH
30298: EMPTY
30299: LIST
30300: LIST
30301: PUSH
30302: LD_INT 1
30304: PUSH
30305: LD_INT 2
30307: PUSH
30308: EMPTY
30309: LIST
30310: LIST
30311: PUSH
30312: EMPTY
30313: LIST
30314: LIST
30315: LIST
30316: LIST
30317: LIST
30318: LIST
30319: LIST
30320: LIST
30321: LIST
30322: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
30323: LD_ADDR_VAR 0 37
30327: PUSH
30328: LD_INT 0
30330: PUSH
30331: LD_INT 0
30333: PUSH
30334: EMPTY
30335: LIST
30336: LIST
30337: PUSH
30338: LD_INT 0
30340: PUSH
30341: LD_INT 1
30343: NEG
30344: PUSH
30345: EMPTY
30346: LIST
30347: LIST
30348: PUSH
30349: LD_INT 1
30351: PUSH
30352: LD_INT 0
30354: PUSH
30355: EMPTY
30356: LIST
30357: LIST
30358: PUSH
30359: LD_INT 1
30361: PUSH
30362: LD_INT 1
30364: PUSH
30365: EMPTY
30366: LIST
30367: LIST
30368: PUSH
30369: LD_INT 0
30371: PUSH
30372: LD_INT 1
30374: PUSH
30375: EMPTY
30376: LIST
30377: LIST
30378: PUSH
30379: LD_INT 1
30381: NEG
30382: PUSH
30383: LD_INT 0
30385: PUSH
30386: EMPTY
30387: LIST
30388: LIST
30389: PUSH
30390: LD_INT 1
30392: NEG
30393: PUSH
30394: LD_INT 1
30396: NEG
30397: PUSH
30398: EMPTY
30399: LIST
30400: LIST
30401: PUSH
30402: LD_INT 1
30404: PUSH
30405: LD_INT 1
30407: NEG
30408: PUSH
30409: EMPTY
30410: LIST
30411: LIST
30412: PUSH
30413: LD_INT 1
30415: NEG
30416: PUSH
30417: LD_INT 1
30419: PUSH
30420: EMPTY
30421: LIST
30422: LIST
30423: PUSH
30424: EMPTY
30425: LIST
30426: LIST
30427: LIST
30428: LIST
30429: LIST
30430: LIST
30431: LIST
30432: LIST
30433: LIST
30434: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
30435: LD_ADDR_VAR 0 38
30439: PUSH
30440: LD_INT 0
30442: PUSH
30443: LD_INT 0
30445: PUSH
30446: EMPTY
30447: LIST
30448: LIST
30449: PUSH
30450: LD_INT 0
30452: PUSH
30453: LD_INT 1
30455: NEG
30456: PUSH
30457: EMPTY
30458: LIST
30459: LIST
30460: PUSH
30461: LD_INT 1
30463: PUSH
30464: LD_INT 0
30466: PUSH
30467: EMPTY
30468: LIST
30469: LIST
30470: PUSH
30471: LD_INT 1
30473: PUSH
30474: LD_INT 1
30476: PUSH
30477: EMPTY
30478: LIST
30479: LIST
30480: PUSH
30481: LD_INT 0
30483: PUSH
30484: LD_INT 1
30486: PUSH
30487: EMPTY
30488: LIST
30489: LIST
30490: PUSH
30491: LD_INT 1
30493: NEG
30494: PUSH
30495: LD_INT 0
30497: PUSH
30498: EMPTY
30499: LIST
30500: LIST
30501: PUSH
30502: LD_INT 1
30504: NEG
30505: PUSH
30506: LD_INT 1
30508: NEG
30509: PUSH
30510: EMPTY
30511: LIST
30512: LIST
30513: PUSH
30514: LD_INT 2
30516: PUSH
30517: LD_INT 1
30519: PUSH
30520: EMPTY
30521: LIST
30522: LIST
30523: PUSH
30524: LD_INT 2
30526: NEG
30527: PUSH
30528: LD_INT 1
30530: NEG
30531: PUSH
30532: EMPTY
30533: LIST
30534: LIST
30535: PUSH
30536: EMPTY
30537: LIST
30538: LIST
30539: LIST
30540: LIST
30541: LIST
30542: LIST
30543: LIST
30544: LIST
30545: LIST
30546: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
30547: LD_ADDR_VAR 0 39
30551: PUSH
30552: LD_INT 0
30554: PUSH
30555: LD_INT 0
30557: PUSH
30558: EMPTY
30559: LIST
30560: LIST
30561: PUSH
30562: LD_INT 0
30564: PUSH
30565: LD_INT 1
30567: NEG
30568: PUSH
30569: EMPTY
30570: LIST
30571: LIST
30572: PUSH
30573: LD_INT 1
30575: PUSH
30576: LD_INT 0
30578: PUSH
30579: EMPTY
30580: LIST
30581: LIST
30582: PUSH
30583: LD_INT 1
30585: PUSH
30586: LD_INT 1
30588: PUSH
30589: EMPTY
30590: LIST
30591: LIST
30592: PUSH
30593: LD_INT 0
30595: PUSH
30596: LD_INT 1
30598: PUSH
30599: EMPTY
30600: LIST
30601: LIST
30602: PUSH
30603: LD_INT 1
30605: NEG
30606: PUSH
30607: LD_INT 0
30609: PUSH
30610: EMPTY
30611: LIST
30612: LIST
30613: PUSH
30614: LD_INT 1
30616: NEG
30617: PUSH
30618: LD_INT 1
30620: NEG
30621: PUSH
30622: EMPTY
30623: LIST
30624: LIST
30625: PUSH
30626: LD_INT 1
30628: NEG
30629: PUSH
30630: LD_INT 2
30632: NEG
30633: PUSH
30634: EMPTY
30635: LIST
30636: LIST
30637: PUSH
30638: LD_INT 1
30640: PUSH
30641: LD_INT 2
30643: PUSH
30644: EMPTY
30645: LIST
30646: LIST
30647: PUSH
30648: EMPTY
30649: LIST
30650: LIST
30651: LIST
30652: LIST
30653: LIST
30654: LIST
30655: LIST
30656: LIST
30657: LIST
30658: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
30659: LD_ADDR_VAR 0 40
30663: PUSH
30664: LD_INT 0
30666: PUSH
30667: LD_INT 0
30669: PUSH
30670: EMPTY
30671: LIST
30672: LIST
30673: PUSH
30674: LD_INT 0
30676: PUSH
30677: LD_INT 1
30679: NEG
30680: PUSH
30681: EMPTY
30682: LIST
30683: LIST
30684: PUSH
30685: LD_INT 1
30687: PUSH
30688: LD_INT 0
30690: PUSH
30691: EMPTY
30692: LIST
30693: LIST
30694: PUSH
30695: LD_INT 1
30697: PUSH
30698: LD_INT 1
30700: PUSH
30701: EMPTY
30702: LIST
30703: LIST
30704: PUSH
30705: LD_INT 0
30707: PUSH
30708: LD_INT 1
30710: PUSH
30711: EMPTY
30712: LIST
30713: LIST
30714: PUSH
30715: LD_INT 1
30717: NEG
30718: PUSH
30719: LD_INT 0
30721: PUSH
30722: EMPTY
30723: LIST
30724: LIST
30725: PUSH
30726: LD_INT 1
30728: NEG
30729: PUSH
30730: LD_INT 1
30732: NEG
30733: PUSH
30734: EMPTY
30735: LIST
30736: LIST
30737: PUSH
30738: LD_INT 1
30740: PUSH
30741: LD_INT 1
30743: NEG
30744: PUSH
30745: EMPTY
30746: LIST
30747: LIST
30748: PUSH
30749: LD_INT 1
30751: NEG
30752: PUSH
30753: LD_INT 1
30755: PUSH
30756: EMPTY
30757: LIST
30758: LIST
30759: PUSH
30760: EMPTY
30761: LIST
30762: LIST
30763: LIST
30764: LIST
30765: LIST
30766: LIST
30767: LIST
30768: LIST
30769: LIST
30770: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30771: LD_ADDR_VAR 0 41
30775: PUSH
30776: LD_INT 0
30778: PUSH
30779: LD_INT 0
30781: PUSH
30782: EMPTY
30783: LIST
30784: LIST
30785: PUSH
30786: LD_INT 0
30788: PUSH
30789: LD_INT 1
30791: NEG
30792: PUSH
30793: EMPTY
30794: LIST
30795: LIST
30796: PUSH
30797: LD_INT 1
30799: PUSH
30800: LD_INT 0
30802: PUSH
30803: EMPTY
30804: LIST
30805: LIST
30806: PUSH
30807: LD_INT 1
30809: PUSH
30810: LD_INT 1
30812: PUSH
30813: EMPTY
30814: LIST
30815: LIST
30816: PUSH
30817: LD_INT 0
30819: PUSH
30820: LD_INT 1
30822: PUSH
30823: EMPTY
30824: LIST
30825: LIST
30826: PUSH
30827: LD_INT 1
30829: NEG
30830: PUSH
30831: LD_INT 0
30833: PUSH
30834: EMPTY
30835: LIST
30836: LIST
30837: PUSH
30838: LD_INT 1
30840: NEG
30841: PUSH
30842: LD_INT 1
30844: NEG
30845: PUSH
30846: EMPTY
30847: LIST
30848: LIST
30849: PUSH
30850: LD_INT 1
30852: NEG
30853: PUSH
30854: LD_INT 2
30856: NEG
30857: PUSH
30858: EMPTY
30859: LIST
30860: LIST
30861: PUSH
30862: LD_INT 1
30864: PUSH
30865: LD_INT 1
30867: NEG
30868: PUSH
30869: EMPTY
30870: LIST
30871: LIST
30872: PUSH
30873: LD_INT 2
30875: PUSH
30876: LD_INT 0
30878: PUSH
30879: EMPTY
30880: LIST
30881: LIST
30882: PUSH
30883: LD_INT 2
30885: PUSH
30886: LD_INT 1
30888: PUSH
30889: EMPTY
30890: LIST
30891: LIST
30892: PUSH
30893: LD_INT 2
30895: PUSH
30896: LD_INT 2
30898: PUSH
30899: EMPTY
30900: LIST
30901: LIST
30902: PUSH
30903: LD_INT 1
30905: PUSH
30906: LD_INT 2
30908: PUSH
30909: EMPTY
30910: LIST
30911: LIST
30912: PUSH
30913: LD_INT 1
30915: NEG
30916: PUSH
30917: LD_INT 1
30919: PUSH
30920: EMPTY
30921: LIST
30922: LIST
30923: PUSH
30924: LD_INT 2
30926: NEG
30927: PUSH
30928: LD_INT 0
30930: PUSH
30931: EMPTY
30932: LIST
30933: LIST
30934: PUSH
30935: LD_INT 2
30937: NEG
30938: PUSH
30939: LD_INT 1
30941: NEG
30942: PUSH
30943: EMPTY
30944: LIST
30945: LIST
30946: PUSH
30947: LD_INT 2
30949: NEG
30950: PUSH
30951: LD_INT 2
30953: NEG
30954: PUSH
30955: EMPTY
30956: LIST
30957: LIST
30958: PUSH
30959: LD_INT 2
30961: NEG
30962: PUSH
30963: LD_INT 3
30965: NEG
30966: PUSH
30967: EMPTY
30968: LIST
30969: LIST
30970: PUSH
30971: LD_INT 2
30973: PUSH
30974: LD_INT 1
30976: NEG
30977: PUSH
30978: EMPTY
30979: LIST
30980: LIST
30981: PUSH
30982: LD_INT 3
30984: PUSH
30985: LD_INT 0
30987: PUSH
30988: EMPTY
30989: LIST
30990: LIST
30991: PUSH
30992: LD_INT 3
30994: PUSH
30995: LD_INT 1
30997: PUSH
30998: EMPTY
30999: LIST
31000: LIST
31001: PUSH
31002: LD_INT 3
31004: PUSH
31005: LD_INT 2
31007: PUSH
31008: EMPTY
31009: LIST
31010: LIST
31011: PUSH
31012: LD_INT 3
31014: PUSH
31015: LD_INT 3
31017: PUSH
31018: EMPTY
31019: LIST
31020: LIST
31021: PUSH
31022: LD_INT 2
31024: PUSH
31025: LD_INT 3
31027: PUSH
31028: EMPTY
31029: LIST
31030: LIST
31031: PUSH
31032: LD_INT 2
31034: NEG
31035: PUSH
31036: LD_INT 1
31038: PUSH
31039: EMPTY
31040: LIST
31041: LIST
31042: PUSH
31043: LD_INT 3
31045: NEG
31046: PUSH
31047: LD_INT 0
31049: PUSH
31050: EMPTY
31051: LIST
31052: LIST
31053: PUSH
31054: LD_INT 3
31056: NEG
31057: PUSH
31058: LD_INT 1
31060: NEG
31061: PUSH
31062: EMPTY
31063: LIST
31064: LIST
31065: PUSH
31066: LD_INT 3
31068: NEG
31069: PUSH
31070: LD_INT 2
31072: NEG
31073: PUSH
31074: EMPTY
31075: LIST
31076: LIST
31077: PUSH
31078: LD_INT 3
31080: NEG
31081: PUSH
31082: LD_INT 3
31084: NEG
31085: PUSH
31086: EMPTY
31087: LIST
31088: LIST
31089: PUSH
31090: EMPTY
31091: LIST
31092: LIST
31093: LIST
31094: LIST
31095: LIST
31096: LIST
31097: LIST
31098: LIST
31099: LIST
31100: LIST
31101: LIST
31102: LIST
31103: LIST
31104: LIST
31105: LIST
31106: LIST
31107: LIST
31108: LIST
31109: LIST
31110: LIST
31111: LIST
31112: LIST
31113: LIST
31114: LIST
31115: LIST
31116: LIST
31117: LIST
31118: LIST
31119: LIST
31120: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31121: LD_ADDR_VAR 0 42
31125: PUSH
31126: LD_INT 0
31128: PUSH
31129: LD_INT 0
31131: PUSH
31132: EMPTY
31133: LIST
31134: LIST
31135: PUSH
31136: LD_INT 0
31138: PUSH
31139: LD_INT 1
31141: NEG
31142: PUSH
31143: EMPTY
31144: LIST
31145: LIST
31146: PUSH
31147: LD_INT 1
31149: PUSH
31150: LD_INT 0
31152: PUSH
31153: EMPTY
31154: LIST
31155: LIST
31156: PUSH
31157: LD_INT 1
31159: PUSH
31160: LD_INT 1
31162: PUSH
31163: EMPTY
31164: LIST
31165: LIST
31166: PUSH
31167: LD_INT 0
31169: PUSH
31170: LD_INT 1
31172: PUSH
31173: EMPTY
31174: LIST
31175: LIST
31176: PUSH
31177: LD_INT 1
31179: NEG
31180: PUSH
31181: LD_INT 0
31183: PUSH
31184: EMPTY
31185: LIST
31186: LIST
31187: PUSH
31188: LD_INT 1
31190: NEG
31191: PUSH
31192: LD_INT 1
31194: NEG
31195: PUSH
31196: EMPTY
31197: LIST
31198: LIST
31199: PUSH
31200: LD_INT 1
31202: NEG
31203: PUSH
31204: LD_INT 2
31206: NEG
31207: PUSH
31208: EMPTY
31209: LIST
31210: LIST
31211: PUSH
31212: LD_INT 0
31214: PUSH
31215: LD_INT 2
31217: NEG
31218: PUSH
31219: EMPTY
31220: LIST
31221: LIST
31222: PUSH
31223: LD_INT 1
31225: PUSH
31226: LD_INT 1
31228: NEG
31229: PUSH
31230: EMPTY
31231: LIST
31232: LIST
31233: PUSH
31234: LD_INT 2
31236: PUSH
31237: LD_INT 1
31239: PUSH
31240: EMPTY
31241: LIST
31242: LIST
31243: PUSH
31244: LD_INT 2
31246: PUSH
31247: LD_INT 2
31249: PUSH
31250: EMPTY
31251: LIST
31252: LIST
31253: PUSH
31254: LD_INT 1
31256: PUSH
31257: LD_INT 2
31259: PUSH
31260: EMPTY
31261: LIST
31262: LIST
31263: PUSH
31264: LD_INT 0
31266: PUSH
31267: LD_INT 2
31269: PUSH
31270: EMPTY
31271: LIST
31272: LIST
31273: PUSH
31274: LD_INT 1
31276: NEG
31277: PUSH
31278: LD_INT 1
31280: PUSH
31281: EMPTY
31282: LIST
31283: LIST
31284: PUSH
31285: LD_INT 2
31287: NEG
31288: PUSH
31289: LD_INT 1
31291: NEG
31292: PUSH
31293: EMPTY
31294: LIST
31295: LIST
31296: PUSH
31297: LD_INT 2
31299: NEG
31300: PUSH
31301: LD_INT 2
31303: NEG
31304: PUSH
31305: EMPTY
31306: LIST
31307: LIST
31308: PUSH
31309: LD_INT 2
31311: NEG
31312: PUSH
31313: LD_INT 3
31315: NEG
31316: PUSH
31317: EMPTY
31318: LIST
31319: LIST
31320: PUSH
31321: LD_INT 1
31323: NEG
31324: PUSH
31325: LD_INT 3
31327: NEG
31328: PUSH
31329: EMPTY
31330: LIST
31331: LIST
31332: PUSH
31333: LD_INT 0
31335: PUSH
31336: LD_INT 3
31338: NEG
31339: PUSH
31340: EMPTY
31341: LIST
31342: LIST
31343: PUSH
31344: LD_INT 1
31346: PUSH
31347: LD_INT 2
31349: NEG
31350: PUSH
31351: EMPTY
31352: LIST
31353: LIST
31354: PUSH
31355: LD_INT 3
31357: PUSH
31358: LD_INT 2
31360: PUSH
31361: EMPTY
31362: LIST
31363: LIST
31364: PUSH
31365: LD_INT 3
31367: PUSH
31368: LD_INT 3
31370: PUSH
31371: EMPTY
31372: LIST
31373: LIST
31374: PUSH
31375: LD_INT 2
31377: PUSH
31378: LD_INT 3
31380: PUSH
31381: EMPTY
31382: LIST
31383: LIST
31384: PUSH
31385: LD_INT 1
31387: PUSH
31388: LD_INT 3
31390: PUSH
31391: EMPTY
31392: LIST
31393: LIST
31394: PUSH
31395: LD_INT 0
31397: PUSH
31398: LD_INT 3
31400: PUSH
31401: EMPTY
31402: LIST
31403: LIST
31404: PUSH
31405: LD_INT 1
31407: NEG
31408: PUSH
31409: LD_INT 2
31411: PUSH
31412: EMPTY
31413: LIST
31414: LIST
31415: PUSH
31416: LD_INT 3
31418: NEG
31419: PUSH
31420: LD_INT 2
31422: NEG
31423: PUSH
31424: EMPTY
31425: LIST
31426: LIST
31427: PUSH
31428: LD_INT 3
31430: NEG
31431: PUSH
31432: LD_INT 3
31434: NEG
31435: PUSH
31436: EMPTY
31437: LIST
31438: LIST
31439: PUSH
31440: EMPTY
31441: LIST
31442: LIST
31443: LIST
31444: LIST
31445: LIST
31446: LIST
31447: LIST
31448: LIST
31449: LIST
31450: LIST
31451: LIST
31452: LIST
31453: LIST
31454: LIST
31455: LIST
31456: LIST
31457: LIST
31458: LIST
31459: LIST
31460: LIST
31461: LIST
31462: LIST
31463: LIST
31464: LIST
31465: LIST
31466: LIST
31467: LIST
31468: LIST
31469: LIST
31470: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
31471: LD_ADDR_VAR 0 43
31475: PUSH
31476: LD_INT 0
31478: PUSH
31479: LD_INT 0
31481: PUSH
31482: EMPTY
31483: LIST
31484: LIST
31485: PUSH
31486: LD_INT 0
31488: PUSH
31489: LD_INT 1
31491: NEG
31492: PUSH
31493: EMPTY
31494: LIST
31495: LIST
31496: PUSH
31497: LD_INT 1
31499: PUSH
31500: LD_INT 0
31502: PUSH
31503: EMPTY
31504: LIST
31505: LIST
31506: PUSH
31507: LD_INT 1
31509: PUSH
31510: LD_INT 1
31512: PUSH
31513: EMPTY
31514: LIST
31515: LIST
31516: PUSH
31517: LD_INT 0
31519: PUSH
31520: LD_INT 1
31522: PUSH
31523: EMPTY
31524: LIST
31525: LIST
31526: PUSH
31527: LD_INT 1
31529: NEG
31530: PUSH
31531: LD_INT 0
31533: PUSH
31534: EMPTY
31535: LIST
31536: LIST
31537: PUSH
31538: LD_INT 1
31540: NEG
31541: PUSH
31542: LD_INT 1
31544: NEG
31545: PUSH
31546: EMPTY
31547: LIST
31548: LIST
31549: PUSH
31550: LD_INT 1
31552: NEG
31553: PUSH
31554: LD_INT 2
31556: NEG
31557: PUSH
31558: EMPTY
31559: LIST
31560: LIST
31561: PUSH
31562: LD_INT 0
31564: PUSH
31565: LD_INT 2
31567: NEG
31568: PUSH
31569: EMPTY
31570: LIST
31571: LIST
31572: PUSH
31573: LD_INT 1
31575: PUSH
31576: LD_INT 1
31578: NEG
31579: PUSH
31580: EMPTY
31581: LIST
31582: LIST
31583: PUSH
31584: LD_INT 2
31586: PUSH
31587: LD_INT 0
31589: PUSH
31590: EMPTY
31591: LIST
31592: LIST
31593: PUSH
31594: LD_INT 2
31596: PUSH
31597: LD_INT 1
31599: PUSH
31600: EMPTY
31601: LIST
31602: LIST
31603: PUSH
31604: LD_INT 1
31606: PUSH
31607: LD_INT 2
31609: PUSH
31610: EMPTY
31611: LIST
31612: LIST
31613: PUSH
31614: LD_INT 0
31616: PUSH
31617: LD_INT 2
31619: PUSH
31620: EMPTY
31621: LIST
31622: LIST
31623: PUSH
31624: LD_INT 1
31626: NEG
31627: PUSH
31628: LD_INT 1
31630: PUSH
31631: EMPTY
31632: LIST
31633: LIST
31634: PUSH
31635: LD_INT 2
31637: NEG
31638: PUSH
31639: LD_INT 0
31641: PUSH
31642: EMPTY
31643: LIST
31644: LIST
31645: PUSH
31646: LD_INT 2
31648: NEG
31649: PUSH
31650: LD_INT 1
31652: NEG
31653: PUSH
31654: EMPTY
31655: LIST
31656: LIST
31657: PUSH
31658: LD_INT 1
31660: NEG
31661: PUSH
31662: LD_INT 3
31664: NEG
31665: PUSH
31666: EMPTY
31667: LIST
31668: LIST
31669: PUSH
31670: LD_INT 0
31672: PUSH
31673: LD_INT 3
31675: NEG
31676: PUSH
31677: EMPTY
31678: LIST
31679: LIST
31680: PUSH
31681: LD_INT 1
31683: PUSH
31684: LD_INT 2
31686: NEG
31687: PUSH
31688: EMPTY
31689: LIST
31690: LIST
31691: PUSH
31692: LD_INT 2
31694: PUSH
31695: LD_INT 1
31697: NEG
31698: PUSH
31699: EMPTY
31700: LIST
31701: LIST
31702: PUSH
31703: LD_INT 3
31705: PUSH
31706: LD_INT 0
31708: PUSH
31709: EMPTY
31710: LIST
31711: LIST
31712: PUSH
31713: LD_INT 3
31715: PUSH
31716: LD_INT 1
31718: PUSH
31719: EMPTY
31720: LIST
31721: LIST
31722: PUSH
31723: LD_INT 1
31725: PUSH
31726: LD_INT 3
31728: PUSH
31729: EMPTY
31730: LIST
31731: LIST
31732: PUSH
31733: LD_INT 0
31735: PUSH
31736: LD_INT 3
31738: PUSH
31739: EMPTY
31740: LIST
31741: LIST
31742: PUSH
31743: LD_INT 1
31745: NEG
31746: PUSH
31747: LD_INT 2
31749: PUSH
31750: EMPTY
31751: LIST
31752: LIST
31753: PUSH
31754: LD_INT 2
31756: NEG
31757: PUSH
31758: LD_INT 1
31760: PUSH
31761: EMPTY
31762: LIST
31763: LIST
31764: PUSH
31765: LD_INT 3
31767: NEG
31768: PUSH
31769: LD_INT 0
31771: PUSH
31772: EMPTY
31773: LIST
31774: LIST
31775: PUSH
31776: LD_INT 3
31778: NEG
31779: PUSH
31780: LD_INT 1
31782: NEG
31783: PUSH
31784: EMPTY
31785: LIST
31786: LIST
31787: PUSH
31788: EMPTY
31789: LIST
31790: LIST
31791: LIST
31792: LIST
31793: LIST
31794: LIST
31795: LIST
31796: LIST
31797: LIST
31798: LIST
31799: LIST
31800: LIST
31801: LIST
31802: LIST
31803: LIST
31804: LIST
31805: LIST
31806: LIST
31807: LIST
31808: LIST
31809: LIST
31810: LIST
31811: LIST
31812: LIST
31813: LIST
31814: LIST
31815: LIST
31816: LIST
31817: LIST
31818: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31819: LD_ADDR_VAR 0 44
31823: PUSH
31824: LD_INT 0
31826: PUSH
31827: LD_INT 0
31829: PUSH
31830: EMPTY
31831: LIST
31832: LIST
31833: PUSH
31834: LD_INT 0
31836: PUSH
31837: LD_INT 1
31839: NEG
31840: PUSH
31841: EMPTY
31842: LIST
31843: LIST
31844: PUSH
31845: LD_INT 1
31847: PUSH
31848: LD_INT 0
31850: PUSH
31851: EMPTY
31852: LIST
31853: LIST
31854: PUSH
31855: LD_INT 1
31857: PUSH
31858: LD_INT 1
31860: PUSH
31861: EMPTY
31862: LIST
31863: LIST
31864: PUSH
31865: LD_INT 0
31867: PUSH
31868: LD_INT 1
31870: PUSH
31871: EMPTY
31872: LIST
31873: LIST
31874: PUSH
31875: LD_INT 1
31877: NEG
31878: PUSH
31879: LD_INT 0
31881: PUSH
31882: EMPTY
31883: LIST
31884: LIST
31885: PUSH
31886: LD_INT 1
31888: NEG
31889: PUSH
31890: LD_INT 1
31892: NEG
31893: PUSH
31894: EMPTY
31895: LIST
31896: LIST
31897: PUSH
31898: LD_INT 1
31900: NEG
31901: PUSH
31902: LD_INT 2
31904: NEG
31905: PUSH
31906: EMPTY
31907: LIST
31908: LIST
31909: PUSH
31910: LD_INT 1
31912: PUSH
31913: LD_INT 1
31915: NEG
31916: PUSH
31917: EMPTY
31918: LIST
31919: LIST
31920: PUSH
31921: LD_INT 2
31923: PUSH
31924: LD_INT 0
31926: PUSH
31927: EMPTY
31928: LIST
31929: LIST
31930: PUSH
31931: LD_INT 2
31933: PUSH
31934: LD_INT 1
31936: PUSH
31937: EMPTY
31938: LIST
31939: LIST
31940: PUSH
31941: LD_INT 2
31943: PUSH
31944: LD_INT 2
31946: PUSH
31947: EMPTY
31948: LIST
31949: LIST
31950: PUSH
31951: LD_INT 1
31953: PUSH
31954: LD_INT 2
31956: PUSH
31957: EMPTY
31958: LIST
31959: LIST
31960: PUSH
31961: LD_INT 1
31963: NEG
31964: PUSH
31965: LD_INT 1
31967: PUSH
31968: EMPTY
31969: LIST
31970: LIST
31971: PUSH
31972: LD_INT 2
31974: NEG
31975: PUSH
31976: LD_INT 0
31978: PUSH
31979: EMPTY
31980: LIST
31981: LIST
31982: PUSH
31983: LD_INT 2
31985: NEG
31986: PUSH
31987: LD_INT 1
31989: NEG
31990: PUSH
31991: EMPTY
31992: LIST
31993: LIST
31994: PUSH
31995: LD_INT 2
31997: NEG
31998: PUSH
31999: LD_INT 2
32001: NEG
32002: PUSH
32003: EMPTY
32004: LIST
32005: LIST
32006: PUSH
32007: LD_INT 2
32009: NEG
32010: PUSH
32011: LD_INT 3
32013: NEG
32014: PUSH
32015: EMPTY
32016: LIST
32017: LIST
32018: PUSH
32019: LD_INT 2
32021: PUSH
32022: LD_INT 1
32024: NEG
32025: PUSH
32026: EMPTY
32027: LIST
32028: LIST
32029: PUSH
32030: LD_INT 3
32032: PUSH
32033: LD_INT 0
32035: PUSH
32036: EMPTY
32037: LIST
32038: LIST
32039: PUSH
32040: LD_INT 3
32042: PUSH
32043: LD_INT 1
32045: PUSH
32046: EMPTY
32047: LIST
32048: LIST
32049: PUSH
32050: LD_INT 3
32052: PUSH
32053: LD_INT 2
32055: PUSH
32056: EMPTY
32057: LIST
32058: LIST
32059: PUSH
32060: LD_INT 3
32062: PUSH
32063: LD_INT 3
32065: PUSH
32066: EMPTY
32067: LIST
32068: LIST
32069: PUSH
32070: LD_INT 2
32072: PUSH
32073: LD_INT 3
32075: PUSH
32076: EMPTY
32077: LIST
32078: LIST
32079: PUSH
32080: LD_INT 2
32082: NEG
32083: PUSH
32084: LD_INT 1
32086: PUSH
32087: EMPTY
32088: LIST
32089: LIST
32090: PUSH
32091: LD_INT 3
32093: NEG
32094: PUSH
32095: LD_INT 0
32097: PUSH
32098: EMPTY
32099: LIST
32100: LIST
32101: PUSH
32102: LD_INT 3
32104: NEG
32105: PUSH
32106: LD_INT 1
32108: NEG
32109: PUSH
32110: EMPTY
32111: LIST
32112: LIST
32113: PUSH
32114: LD_INT 3
32116: NEG
32117: PUSH
32118: LD_INT 2
32120: NEG
32121: PUSH
32122: EMPTY
32123: LIST
32124: LIST
32125: PUSH
32126: LD_INT 3
32128: NEG
32129: PUSH
32130: LD_INT 3
32132: NEG
32133: PUSH
32134: EMPTY
32135: LIST
32136: LIST
32137: PUSH
32138: EMPTY
32139: LIST
32140: LIST
32141: LIST
32142: LIST
32143: LIST
32144: LIST
32145: LIST
32146: LIST
32147: LIST
32148: LIST
32149: LIST
32150: LIST
32151: LIST
32152: LIST
32153: LIST
32154: LIST
32155: LIST
32156: LIST
32157: LIST
32158: LIST
32159: LIST
32160: LIST
32161: LIST
32162: LIST
32163: LIST
32164: LIST
32165: LIST
32166: LIST
32167: LIST
32168: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32169: LD_ADDR_VAR 0 45
32173: PUSH
32174: LD_INT 0
32176: PUSH
32177: LD_INT 0
32179: PUSH
32180: EMPTY
32181: LIST
32182: LIST
32183: PUSH
32184: LD_INT 0
32186: PUSH
32187: LD_INT 1
32189: NEG
32190: PUSH
32191: EMPTY
32192: LIST
32193: LIST
32194: PUSH
32195: LD_INT 1
32197: PUSH
32198: LD_INT 0
32200: PUSH
32201: EMPTY
32202: LIST
32203: LIST
32204: PUSH
32205: LD_INT 1
32207: PUSH
32208: LD_INT 1
32210: PUSH
32211: EMPTY
32212: LIST
32213: LIST
32214: PUSH
32215: LD_INT 0
32217: PUSH
32218: LD_INT 1
32220: PUSH
32221: EMPTY
32222: LIST
32223: LIST
32224: PUSH
32225: LD_INT 1
32227: NEG
32228: PUSH
32229: LD_INT 0
32231: PUSH
32232: EMPTY
32233: LIST
32234: LIST
32235: PUSH
32236: LD_INT 1
32238: NEG
32239: PUSH
32240: LD_INT 1
32242: NEG
32243: PUSH
32244: EMPTY
32245: LIST
32246: LIST
32247: PUSH
32248: LD_INT 1
32250: NEG
32251: PUSH
32252: LD_INT 2
32254: NEG
32255: PUSH
32256: EMPTY
32257: LIST
32258: LIST
32259: PUSH
32260: LD_INT 0
32262: PUSH
32263: LD_INT 2
32265: NEG
32266: PUSH
32267: EMPTY
32268: LIST
32269: LIST
32270: PUSH
32271: LD_INT 1
32273: PUSH
32274: LD_INT 1
32276: NEG
32277: PUSH
32278: EMPTY
32279: LIST
32280: LIST
32281: PUSH
32282: LD_INT 2
32284: PUSH
32285: LD_INT 1
32287: PUSH
32288: EMPTY
32289: LIST
32290: LIST
32291: PUSH
32292: LD_INT 2
32294: PUSH
32295: LD_INT 2
32297: PUSH
32298: EMPTY
32299: LIST
32300: LIST
32301: PUSH
32302: LD_INT 1
32304: PUSH
32305: LD_INT 2
32307: PUSH
32308: EMPTY
32309: LIST
32310: LIST
32311: PUSH
32312: LD_INT 0
32314: PUSH
32315: LD_INT 2
32317: PUSH
32318: EMPTY
32319: LIST
32320: LIST
32321: PUSH
32322: LD_INT 1
32324: NEG
32325: PUSH
32326: LD_INT 1
32328: PUSH
32329: EMPTY
32330: LIST
32331: LIST
32332: PUSH
32333: LD_INT 2
32335: NEG
32336: PUSH
32337: LD_INT 1
32339: NEG
32340: PUSH
32341: EMPTY
32342: LIST
32343: LIST
32344: PUSH
32345: LD_INT 2
32347: NEG
32348: PUSH
32349: LD_INT 2
32351: NEG
32352: PUSH
32353: EMPTY
32354: LIST
32355: LIST
32356: PUSH
32357: LD_INT 2
32359: NEG
32360: PUSH
32361: LD_INT 3
32363: NEG
32364: PUSH
32365: EMPTY
32366: LIST
32367: LIST
32368: PUSH
32369: LD_INT 1
32371: NEG
32372: PUSH
32373: LD_INT 3
32375: NEG
32376: PUSH
32377: EMPTY
32378: LIST
32379: LIST
32380: PUSH
32381: LD_INT 0
32383: PUSH
32384: LD_INT 3
32386: NEG
32387: PUSH
32388: EMPTY
32389: LIST
32390: LIST
32391: PUSH
32392: LD_INT 1
32394: PUSH
32395: LD_INT 2
32397: NEG
32398: PUSH
32399: EMPTY
32400: LIST
32401: LIST
32402: PUSH
32403: LD_INT 3
32405: PUSH
32406: LD_INT 2
32408: PUSH
32409: EMPTY
32410: LIST
32411: LIST
32412: PUSH
32413: LD_INT 3
32415: PUSH
32416: LD_INT 3
32418: PUSH
32419: EMPTY
32420: LIST
32421: LIST
32422: PUSH
32423: LD_INT 2
32425: PUSH
32426: LD_INT 3
32428: PUSH
32429: EMPTY
32430: LIST
32431: LIST
32432: PUSH
32433: LD_INT 1
32435: PUSH
32436: LD_INT 3
32438: PUSH
32439: EMPTY
32440: LIST
32441: LIST
32442: PUSH
32443: LD_INT 0
32445: PUSH
32446: LD_INT 3
32448: PUSH
32449: EMPTY
32450: LIST
32451: LIST
32452: PUSH
32453: LD_INT 1
32455: NEG
32456: PUSH
32457: LD_INT 2
32459: PUSH
32460: EMPTY
32461: LIST
32462: LIST
32463: PUSH
32464: LD_INT 3
32466: NEG
32467: PUSH
32468: LD_INT 2
32470: NEG
32471: PUSH
32472: EMPTY
32473: LIST
32474: LIST
32475: PUSH
32476: LD_INT 3
32478: NEG
32479: PUSH
32480: LD_INT 3
32482: NEG
32483: PUSH
32484: EMPTY
32485: LIST
32486: LIST
32487: PUSH
32488: EMPTY
32489: LIST
32490: LIST
32491: LIST
32492: LIST
32493: LIST
32494: LIST
32495: LIST
32496: LIST
32497: LIST
32498: LIST
32499: LIST
32500: LIST
32501: LIST
32502: LIST
32503: LIST
32504: LIST
32505: LIST
32506: LIST
32507: LIST
32508: LIST
32509: LIST
32510: LIST
32511: LIST
32512: LIST
32513: LIST
32514: LIST
32515: LIST
32516: LIST
32517: LIST
32518: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
32519: LD_ADDR_VAR 0 46
32523: PUSH
32524: LD_INT 0
32526: PUSH
32527: LD_INT 0
32529: PUSH
32530: EMPTY
32531: LIST
32532: LIST
32533: PUSH
32534: LD_INT 0
32536: PUSH
32537: LD_INT 1
32539: NEG
32540: PUSH
32541: EMPTY
32542: LIST
32543: LIST
32544: PUSH
32545: LD_INT 1
32547: PUSH
32548: LD_INT 0
32550: PUSH
32551: EMPTY
32552: LIST
32553: LIST
32554: PUSH
32555: LD_INT 1
32557: PUSH
32558: LD_INT 1
32560: PUSH
32561: EMPTY
32562: LIST
32563: LIST
32564: PUSH
32565: LD_INT 0
32567: PUSH
32568: LD_INT 1
32570: PUSH
32571: EMPTY
32572: LIST
32573: LIST
32574: PUSH
32575: LD_INT 1
32577: NEG
32578: PUSH
32579: LD_INT 0
32581: PUSH
32582: EMPTY
32583: LIST
32584: LIST
32585: PUSH
32586: LD_INT 1
32588: NEG
32589: PUSH
32590: LD_INT 1
32592: NEG
32593: PUSH
32594: EMPTY
32595: LIST
32596: LIST
32597: PUSH
32598: LD_INT 1
32600: NEG
32601: PUSH
32602: LD_INT 2
32604: NEG
32605: PUSH
32606: EMPTY
32607: LIST
32608: LIST
32609: PUSH
32610: LD_INT 0
32612: PUSH
32613: LD_INT 2
32615: NEG
32616: PUSH
32617: EMPTY
32618: LIST
32619: LIST
32620: PUSH
32621: LD_INT 1
32623: PUSH
32624: LD_INT 1
32626: NEG
32627: PUSH
32628: EMPTY
32629: LIST
32630: LIST
32631: PUSH
32632: LD_INT 2
32634: PUSH
32635: LD_INT 0
32637: PUSH
32638: EMPTY
32639: LIST
32640: LIST
32641: PUSH
32642: LD_INT 2
32644: PUSH
32645: LD_INT 1
32647: PUSH
32648: EMPTY
32649: LIST
32650: LIST
32651: PUSH
32652: LD_INT 1
32654: PUSH
32655: LD_INT 2
32657: PUSH
32658: EMPTY
32659: LIST
32660: LIST
32661: PUSH
32662: LD_INT 0
32664: PUSH
32665: LD_INT 2
32667: PUSH
32668: EMPTY
32669: LIST
32670: LIST
32671: PUSH
32672: LD_INT 1
32674: NEG
32675: PUSH
32676: LD_INT 1
32678: PUSH
32679: EMPTY
32680: LIST
32681: LIST
32682: PUSH
32683: LD_INT 2
32685: NEG
32686: PUSH
32687: LD_INT 0
32689: PUSH
32690: EMPTY
32691: LIST
32692: LIST
32693: PUSH
32694: LD_INT 2
32696: NEG
32697: PUSH
32698: LD_INT 1
32700: NEG
32701: PUSH
32702: EMPTY
32703: LIST
32704: LIST
32705: PUSH
32706: LD_INT 1
32708: NEG
32709: PUSH
32710: LD_INT 3
32712: NEG
32713: PUSH
32714: EMPTY
32715: LIST
32716: LIST
32717: PUSH
32718: LD_INT 0
32720: PUSH
32721: LD_INT 3
32723: NEG
32724: PUSH
32725: EMPTY
32726: LIST
32727: LIST
32728: PUSH
32729: LD_INT 1
32731: PUSH
32732: LD_INT 2
32734: NEG
32735: PUSH
32736: EMPTY
32737: LIST
32738: LIST
32739: PUSH
32740: LD_INT 2
32742: PUSH
32743: LD_INT 1
32745: NEG
32746: PUSH
32747: EMPTY
32748: LIST
32749: LIST
32750: PUSH
32751: LD_INT 3
32753: PUSH
32754: LD_INT 0
32756: PUSH
32757: EMPTY
32758: LIST
32759: LIST
32760: PUSH
32761: LD_INT 3
32763: PUSH
32764: LD_INT 1
32766: PUSH
32767: EMPTY
32768: LIST
32769: LIST
32770: PUSH
32771: LD_INT 1
32773: PUSH
32774: LD_INT 3
32776: PUSH
32777: EMPTY
32778: LIST
32779: LIST
32780: PUSH
32781: LD_INT 0
32783: PUSH
32784: LD_INT 3
32786: PUSH
32787: EMPTY
32788: LIST
32789: LIST
32790: PUSH
32791: LD_INT 1
32793: NEG
32794: PUSH
32795: LD_INT 2
32797: PUSH
32798: EMPTY
32799: LIST
32800: LIST
32801: PUSH
32802: LD_INT 2
32804: NEG
32805: PUSH
32806: LD_INT 1
32808: PUSH
32809: EMPTY
32810: LIST
32811: LIST
32812: PUSH
32813: LD_INT 3
32815: NEG
32816: PUSH
32817: LD_INT 0
32819: PUSH
32820: EMPTY
32821: LIST
32822: LIST
32823: PUSH
32824: LD_INT 3
32826: NEG
32827: PUSH
32828: LD_INT 1
32830: NEG
32831: PUSH
32832: EMPTY
32833: LIST
32834: LIST
32835: PUSH
32836: EMPTY
32837: LIST
32838: LIST
32839: LIST
32840: LIST
32841: LIST
32842: LIST
32843: LIST
32844: LIST
32845: LIST
32846: LIST
32847: LIST
32848: LIST
32849: LIST
32850: LIST
32851: LIST
32852: LIST
32853: LIST
32854: LIST
32855: LIST
32856: LIST
32857: LIST
32858: LIST
32859: LIST
32860: LIST
32861: LIST
32862: LIST
32863: LIST
32864: LIST
32865: LIST
32866: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32867: LD_ADDR_VAR 0 47
32871: PUSH
32872: LD_INT 0
32874: PUSH
32875: LD_INT 0
32877: PUSH
32878: EMPTY
32879: LIST
32880: LIST
32881: PUSH
32882: LD_INT 0
32884: PUSH
32885: LD_INT 1
32887: NEG
32888: PUSH
32889: EMPTY
32890: LIST
32891: LIST
32892: PUSH
32893: LD_INT 1
32895: PUSH
32896: LD_INT 0
32898: PUSH
32899: EMPTY
32900: LIST
32901: LIST
32902: PUSH
32903: LD_INT 1
32905: PUSH
32906: LD_INT 1
32908: PUSH
32909: EMPTY
32910: LIST
32911: LIST
32912: PUSH
32913: LD_INT 0
32915: PUSH
32916: LD_INT 1
32918: PUSH
32919: EMPTY
32920: LIST
32921: LIST
32922: PUSH
32923: LD_INT 1
32925: NEG
32926: PUSH
32927: LD_INT 0
32929: PUSH
32930: EMPTY
32931: LIST
32932: LIST
32933: PUSH
32934: LD_INT 1
32936: NEG
32937: PUSH
32938: LD_INT 1
32940: NEG
32941: PUSH
32942: EMPTY
32943: LIST
32944: LIST
32945: PUSH
32946: LD_INT 1
32948: NEG
32949: PUSH
32950: LD_INT 2
32952: NEG
32953: PUSH
32954: EMPTY
32955: LIST
32956: LIST
32957: PUSH
32958: LD_INT 0
32960: PUSH
32961: LD_INT 2
32963: NEG
32964: PUSH
32965: EMPTY
32966: LIST
32967: LIST
32968: PUSH
32969: LD_INT 1
32971: PUSH
32972: LD_INT 1
32974: NEG
32975: PUSH
32976: EMPTY
32977: LIST
32978: LIST
32979: PUSH
32980: LD_INT 2
32982: NEG
32983: PUSH
32984: LD_INT 1
32986: NEG
32987: PUSH
32988: EMPTY
32989: LIST
32990: LIST
32991: PUSH
32992: LD_INT 2
32994: NEG
32995: PUSH
32996: LD_INT 2
32998: NEG
32999: PUSH
33000: EMPTY
33001: LIST
33002: LIST
33003: PUSH
33004: EMPTY
33005: LIST
33006: LIST
33007: LIST
33008: LIST
33009: LIST
33010: LIST
33011: LIST
33012: LIST
33013: LIST
33014: LIST
33015: LIST
33016: LIST
33017: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
33018: LD_ADDR_VAR 0 48
33022: PUSH
33023: LD_INT 0
33025: PUSH
33026: LD_INT 0
33028: PUSH
33029: EMPTY
33030: LIST
33031: LIST
33032: PUSH
33033: LD_INT 0
33035: PUSH
33036: LD_INT 1
33038: NEG
33039: PUSH
33040: EMPTY
33041: LIST
33042: LIST
33043: PUSH
33044: LD_INT 1
33046: PUSH
33047: LD_INT 0
33049: PUSH
33050: EMPTY
33051: LIST
33052: LIST
33053: PUSH
33054: LD_INT 1
33056: PUSH
33057: LD_INT 1
33059: PUSH
33060: EMPTY
33061: LIST
33062: LIST
33063: PUSH
33064: LD_INT 0
33066: PUSH
33067: LD_INT 1
33069: PUSH
33070: EMPTY
33071: LIST
33072: LIST
33073: PUSH
33074: LD_INT 1
33076: NEG
33077: PUSH
33078: LD_INT 0
33080: PUSH
33081: EMPTY
33082: LIST
33083: LIST
33084: PUSH
33085: LD_INT 1
33087: NEG
33088: PUSH
33089: LD_INT 1
33091: NEG
33092: PUSH
33093: EMPTY
33094: LIST
33095: LIST
33096: PUSH
33097: LD_INT 1
33099: NEG
33100: PUSH
33101: LD_INT 2
33103: NEG
33104: PUSH
33105: EMPTY
33106: LIST
33107: LIST
33108: PUSH
33109: LD_INT 0
33111: PUSH
33112: LD_INT 2
33114: NEG
33115: PUSH
33116: EMPTY
33117: LIST
33118: LIST
33119: PUSH
33120: LD_INT 1
33122: PUSH
33123: LD_INT 1
33125: NEG
33126: PUSH
33127: EMPTY
33128: LIST
33129: LIST
33130: PUSH
33131: LD_INT 2
33133: PUSH
33134: LD_INT 0
33136: PUSH
33137: EMPTY
33138: LIST
33139: LIST
33140: PUSH
33141: LD_INT 2
33143: PUSH
33144: LD_INT 1
33146: PUSH
33147: EMPTY
33148: LIST
33149: LIST
33150: PUSH
33151: EMPTY
33152: LIST
33153: LIST
33154: LIST
33155: LIST
33156: LIST
33157: LIST
33158: LIST
33159: LIST
33160: LIST
33161: LIST
33162: LIST
33163: LIST
33164: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
33165: LD_ADDR_VAR 0 49
33169: PUSH
33170: LD_INT 0
33172: PUSH
33173: LD_INT 0
33175: PUSH
33176: EMPTY
33177: LIST
33178: LIST
33179: PUSH
33180: LD_INT 0
33182: PUSH
33183: LD_INT 1
33185: NEG
33186: PUSH
33187: EMPTY
33188: LIST
33189: LIST
33190: PUSH
33191: LD_INT 1
33193: PUSH
33194: LD_INT 0
33196: PUSH
33197: EMPTY
33198: LIST
33199: LIST
33200: PUSH
33201: LD_INT 1
33203: PUSH
33204: LD_INT 1
33206: PUSH
33207: EMPTY
33208: LIST
33209: LIST
33210: PUSH
33211: LD_INT 0
33213: PUSH
33214: LD_INT 1
33216: PUSH
33217: EMPTY
33218: LIST
33219: LIST
33220: PUSH
33221: LD_INT 1
33223: NEG
33224: PUSH
33225: LD_INT 0
33227: PUSH
33228: EMPTY
33229: LIST
33230: LIST
33231: PUSH
33232: LD_INT 1
33234: NEG
33235: PUSH
33236: LD_INT 1
33238: NEG
33239: PUSH
33240: EMPTY
33241: LIST
33242: LIST
33243: PUSH
33244: LD_INT 1
33246: PUSH
33247: LD_INT 1
33249: NEG
33250: PUSH
33251: EMPTY
33252: LIST
33253: LIST
33254: PUSH
33255: LD_INT 2
33257: PUSH
33258: LD_INT 0
33260: PUSH
33261: EMPTY
33262: LIST
33263: LIST
33264: PUSH
33265: LD_INT 2
33267: PUSH
33268: LD_INT 1
33270: PUSH
33271: EMPTY
33272: LIST
33273: LIST
33274: PUSH
33275: LD_INT 2
33277: PUSH
33278: LD_INT 2
33280: PUSH
33281: EMPTY
33282: LIST
33283: LIST
33284: PUSH
33285: LD_INT 1
33287: PUSH
33288: LD_INT 2
33290: PUSH
33291: EMPTY
33292: LIST
33293: LIST
33294: PUSH
33295: EMPTY
33296: LIST
33297: LIST
33298: LIST
33299: LIST
33300: LIST
33301: LIST
33302: LIST
33303: LIST
33304: LIST
33305: LIST
33306: LIST
33307: LIST
33308: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
33309: LD_ADDR_VAR 0 50
33313: PUSH
33314: LD_INT 0
33316: PUSH
33317: LD_INT 0
33319: PUSH
33320: EMPTY
33321: LIST
33322: LIST
33323: PUSH
33324: LD_INT 0
33326: PUSH
33327: LD_INT 1
33329: NEG
33330: PUSH
33331: EMPTY
33332: LIST
33333: LIST
33334: PUSH
33335: LD_INT 1
33337: PUSH
33338: LD_INT 0
33340: PUSH
33341: EMPTY
33342: LIST
33343: LIST
33344: PUSH
33345: LD_INT 1
33347: PUSH
33348: LD_INT 1
33350: PUSH
33351: EMPTY
33352: LIST
33353: LIST
33354: PUSH
33355: LD_INT 0
33357: PUSH
33358: LD_INT 1
33360: PUSH
33361: EMPTY
33362: LIST
33363: LIST
33364: PUSH
33365: LD_INT 1
33367: NEG
33368: PUSH
33369: LD_INT 0
33371: PUSH
33372: EMPTY
33373: LIST
33374: LIST
33375: PUSH
33376: LD_INT 1
33378: NEG
33379: PUSH
33380: LD_INT 1
33382: NEG
33383: PUSH
33384: EMPTY
33385: LIST
33386: LIST
33387: PUSH
33388: LD_INT 2
33390: PUSH
33391: LD_INT 1
33393: PUSH
33394: EMPTY
33395: LIST
33396: LIST
33397: PUSH
33398: LD_INT 2
33400: PUSH
33401: LD_INT 2
33403: PUSH
33404: EMPTY
33405: LIST
33406: LIST
33407: PUSH
33408: LD_INT 1
33410: PUSH
33411: LD_INT 2
33413: PUSH
33414: EMPTY
33415: LIST
33416: LIST
33417: PUSH
33418: LD_INT 0
33420: PUSH
33421: LD_INT 2
33423: PUSH
33424: EMPTY
33425: LIST
33426: LIST
33427: PUSH
33428: LD_INT 1
33430: NEG
33431: PUSH
33432: LD_INT 1
33434: PUSH
33435: EMPTY
33436: LIST
33437: LIST
33438: PUSH
33439: EMPTY
33440: LIST
33441: LIST
33442: LIST
33443: LIST
33444: LIST
33445: LIST
33446: LIST
33447: LIST
33448: LIST
33449: LIST
33450: LIST
33451: LIST
33452: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
33453: LD_ADDR_VAR 0 51
33457: PUSH
33458: LD_INT 0
33460: PUSH
33461: LD_INT 0
33463: PUSH
33464: EMPTY
33465: LIST
33466: LIST
33467: PUSH
33468: LD_INT 0
33470: PUSH
33471: LD_INT 1
33473: NEG
33474: PUSH
33475: EMPTY
33476: LIST
33477: LIST
33478: PUSH
33479: LD_INT 1
33481: PUSH
33482: LD_INT 0
33484: PUSH
33485: EMPTY
33486: LIST
33487: LIST
33488: PUSH
33489: LD_INT 1
33491: PUSH
33492: LD_INT 1
33494: PUSH
33495: EMPTY
33496: LIST
33497: LIST
33498: PUSH
33499: LD_INT 0
33501: PUSH
33502: LD_INT 1
33504: PUSH
33505: EMPTY
33506: LIST
33507: LIST
33508: PUSH
33509: LD_INT 1
33511: NEG
33512: PUSH
33513: LD_INT 0
33515: PUSH
33516: EMPTY
33517: LIST
33518: LIST
33519: PUSH
33520: LD_INT 1
33522: NEG
33523: PUSH
33524: LD_INT 1
33526: NEG
33527: PUSH
33528: EMPTY
33529: LIST
33530: LIST
33531: PUSH
33532: LD_INT 1
33534: PUSH
33535: LD_INT 2
33537: PUSH
33538: EMPTY
33539: LIST
33540: LIST
33541: PUSH
33542: LD_INT 0
33544: PUSH
33545: LD_INT 2
33547: PUSH
33548: EMPTY
33549: LIST
33550: LIST
33551: PUSH
33552: LD_INT 1
33554: NEG
33555: PUSH
33556: LD_INT 1
33558: PUSH
33559: EMPTY
33560: LIST
33561: LIST
33562: PUSH
33563: LD_INT 2
33565: NEG
33566: PUSH
33567: LD_INT 0
33569: PUSH
33570: EMPTY
33571: LIST
33572: LIST
33573: PUSH
33574: LD_INT 2
33576: NEG
33577: PUSH
33578: LD_INT 1
33580: NEG
33581: PUSH
33582: EMPTY
33583: LIST
33584: LIST
33585: PUSH
33586: EMPTY
33587: LIST
33588: LIST
33589: LIST
33590: LIST
33591: LIST
33592: LIST
33593: LIST
33594: LIST
33595: LIST
33596: LIST
33597: LIST
33598: LIST
33599: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33600: LD_ADDR_VAR 0 52
33604: PUSH
33605: LD_INT 0
33607: PUSH
33608: LD_INT 0
33610: PUSH
33611: EMPTY
33612: LIST
33613: LIST
33614: PUSH
33615: LD_INT 0
33617: PUSH
33618: LD_INT 1
33620: NEG
33621: PUSH
33622: EMPTY
33623: LIST
33624: LIST
33625: PUSH
33626: LD_INT 1
33628: PUSH
33629: LD_INT 0
33631: PUSH
33632: EMPTY
33633: LIST
33634: LIST
33635: PUSH
33636: LD_INT 1
33638: PUSH
33639: LD_INT 1
33641: PUSH
33642: EMPTY
33643: LIST
33644: LIST
33645: PUSH
33646: LD_INT 0
33648: PUSH
33649: LD_INT 1
33651: PUSH
33652: EMPTY
33653: LIST
33654: LIST
33655: PUSH
33656: LD_INT 1
33658: NEG
33659: PUSH
33660: LD_INT 0
33662: PUSH
33663: EMPTY
33664: LIST
33665: LIST
33666: PUSH
33667: LD_INT 1
33669: NEG
33670: PUSH
33671: LD_INT 1
33673: NEG
33674: PUSH
33675: EMPTY
33676: LIST
33677: LIST
33678: PUSH
33679: LD_INT 1
33681: NEG
33682: PUSH
33683: LD_INT 2
33685: NEG
33686: PUSH
33687: EMPTY
33688: LIST
33689: LIST
33690: PUSH
33691: LD_INT 1
33693: NEG
33694: PUSH
33695: LD_INT 1
33697: PUSH
33698: EMPTY
33699: LIST
33700: LIST
33701: PUSH
33702: LD_INT 2
33704: NEG
33705: PUSH
33706: LD_INT 0
33708: PUSH
33709: EMPTY
33710: LIST
33711: LIST
33712: PUSH
33713: LD_INT 2
33715: NEG
33716: PUSH
33717: LD_INT 1
33719: NEG
33720: PUSH
33721: EMPTY
33722: LIST
33723: LIST
33724: PUSH
33725: LD_INT 2
33727: NEG
33728: PUSH
33729: LD_INT 2
33731: NEG
33732: PUSH
33733: EMPTY
33734: LIST
33735: LIST
33736: PUSH
33737: EMPTY
33738: LIST
33739: LIST
33740: LIST
33741: LIST
33742: LIST
33743: LIST
33744: LIST
33745: LIST
33746: LIST
33747: LIST
33748: LIST
33749: LIST
33750: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33751: LD_ADDR_VAR 0 53
33755: PUSH
33756: LD_INT 0
33758: PUSH
33759: LD_INT 0
33761: PUSH
33762: EMPTY
33763: LIST
33764: LIST
33765: PUSH
33766: LD_INT 0
33768: PUSH
33769: LD_INT 1
33771: NEG
33772: PUSH
33773: EMPTY
33774: LIST
33775: LIST
33776: PUSH
33777: LD_INT 1
33779: PUSH
33780: LD_INT 0
33782: PUSH
33783: EMPTY
33784: LIST
33785: LIST
33786: PUSH
33787: LD_INT 1
33789: PUSH
33790: LD_INT 1
33792: PUSH
33793: EMPTY
33794: LIST
33795: LIST
33796: PUSH
33797: LD_INT 0
33799: PUSH
33800: LD_INT 1
33802: PUSH
33803: EMPTY
33804: LIST
33805: LIST
33806: PUSH
33807: LD_INT 1
33809: NEG
33810: PUSH
33811: LD_INT 0
33813: PUSH
33814: EMPTY
33815: LIST
33816: LIST
33817: PUSH
33818: LD_INT 1
33820: NEG
33821: PUSH
33822: LD_INT 1
33824: NEG
33825: PUSH
33826: EMPTY
33827: LIST
33828: LIST
33829: PUSH
33830: LD_INT 1
33832: NEG
33833: PUSH
33834: LD_INT 2
33836: NEG
33837: PUSH
33838: EMPTY
33839: LIST
33840: LIST
33841: PUSH
33842: LD_INT 0
33844: PUSH
33845: LD_INT 2
33847: NEG
33848: PUSH
33849: EMPTY
33850: LIST
33851: LIST
33852: PUSH
33853: LD_INT 1
33855: PUSH
33856: LD_INT 1
33858: NEG
33859: PUSH
33860: EMPTY
33861: LIST
33862: LIST
33863: PUSH
33864: LD_INT 2
33866: PUSH
33867: LD_INT 0
33869: PUSH
33870: EMPTY
33871: LIST
33872: LIST
33873: PUSH
33874: LD_INT 2
33876: PUSH
33877: LD_INT 1
33879: PUSH
33880: EMPTY
33881: LIST
33882: LIST
33883: PUSH
33884: LD_INT 2
33886: PUSH
33887: LD_INT 2
33889: PUSH
33890: EMPTY
33891: LIST
33892: LIST
33893: PUSH
33894: LD_INT 1
33896: PUSH
33897: LD_INT 2
33899: PUSH
33900: EMPTY
33901: LIST
33902: LIST
33903: PUSH
33904: LD_INT 0
33906: PUSH
33907: LD_INT 2
33909: PUSH
33910: EMPTY
33911: LIST
33912: LIST
33913: PUSH
33914: LD_INT 1
33916: NEG
33917: PUSH
33918: LD_INT 1
33920: PUSH
33921: EMPTY
33922: LIST
33923: LIST
33924: PUSH
33925: LD_INT 2
33927: NEG
33928: PUSH
33929: LD_INT 0
33931: PUSH
33932: EMPTY
33933: LIST
33934: LIST
33935: PUSH
33936: LD_INT 2
33938: NEG
33939: PUSH
33940: LD_INT 1
33942: NEG
33943: PUSH
33944: EMPTY
33945: LIST
33946: LIST
33947: PUSH
33948: LD_INT 2
33950: NEG
33951: PUSH
33952: LD_INT 2
33954: NEG
33955: PUSH
33956: EMPTY
33957: LIST
33958: LIST
33959: PUSH
33960: EMPTY
33961: LIST
33962: LIST
33963: LIST
33964: LIST
33965: LIST
33966: LIST
33967: LIST
33968: LIST
33969: LIST
33970: LIST
33971: LIST
33972: LIST
33973: LIST
33974: LIST
33975: LIST
33976: LIST
33977: LIST
33978: LIST
33979: LIST
33980: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33981: LD_ADDR_VAR 0 54
33985: PUSH
33986: LD_INT 0
33988: PUSH
33989: LD_INT 0
33991: PUSH
33992: EMPTY
33993: LIST
33994: LIST
33995: PUSH
33996: LD_INT 0
33998: PUSH
33999: LD_INT 1
34001: NEG
34002: PUSH
34003: EMPTY
34004: LIST
34005: LIST
34006: PUSH
34007: LD_INT 1
34009: PUSH
34010: LD_INT 0
34012: PUSH
34013: EMPTY
34014: LIST
34015: LIST
34016: PUSH
34017: LD_INT 1
34019: PUSH
34020: LD_INT 1
34022: PUSH
34023: EMPTY
34024: LIST
34025: LIST
34026: PUSH
34027: LD_INT 0
34029: PUSH
34030: LD_INT 1
34032: PUSH
34033: EMPTY
34034: LIST
34035: LIST
34036: PUSH
34037: LD_INT 1
34039: NEG
34040: PUSH
34041: LD_INT 0
34043: PUSH
34044: EMPTY
34045: LIST
34046: LIST
34047: PUSH
34048: LD_INT 1
34050: NEG
34051: PUSH
34052: LD_INT 1
34054: NEG
34055: PUSH
34056: EMPTY
34057: LIST
34058: LIST
34059: PUSH
34060: LD_INT 1
34062: NEG
34063: PUSH
34064: LD_INT 2
34066: NEG
34067: PUSH
34068: EMPTY
34069: LIST
34070: LIST
34071: PUSH
34072: LD_INT 0
34074: PUSH
34075: LD_INT 2
34077: NEG
34078: PUSH
34079: EMPTY
34080: LIST
34081: LIST
34082: PUSH
34083: LD_INT 1
34085: PUSH
34086: LD_INT 1
34088: NEG
34089: PUSH
34090: EMPTY
34091: LIST
34092: LIST
34093: PUSH
34094: LD_INT 2
34096: PUSH
34097: LD_INT 0
34099: PUSH
34100: EMPTY
34101: LIST
34102: LIST
34103: PUSH
34104: LD_INT 2
34106: PUSH
34107: LD_INT 1
34109: PUSH
34110: EMPTY
34111: LIST
34112: LIST
34113: PUSH
34114: LD_INT 2
34116: PUSH
34117: LD_INT 2
34119: PUSH
34120: EMPTY
34121: LIST
34122: LIST
34123: PUSH
34124: LD_INT 1
34126: PUSH
34127: LD_INT 2
34129: PUSH
34130: EMPTY
34131: LIST
34132: LIST
34133: PUSH
34134: LD_INT 0
34136: PUSH
34137: LD_INT 2
34139: PUSH
34140: EMPTY
34141: LIST
34142: LIST
34143: PUSH
34144: LD_INT 1
34146: NEG
34147: PUSH
34148: LD_INT 1
34150: PUSH
34151: EMPTY
34152: LIST
34153: LIST
34154: PUSH
34155: LD_INT 2
34157: NEG
34158: PUSH
34159: LD_INT 0
34161: PUSH
34162: EMPTY
34163: LIST
34164: LIST
34165: PUSH
34166: LD_INT 2
34168: NEG
34169: PUSH
34170: LD_INT 1
34172: NEG
34173: PUSH
34174: EMPTY
34175: LIST
34176: LIST
34177: PUSH
34178: LD_INT 2
34180: NEG
34181: PUSH
34182: LD_INT 2
34184: NEG
34185: PUSH
34186: EMPTY
34187: LIST
34188: LIST
34189: PUSH
34190: EMPTY
34191: LIST
34192: LIST
34193: LIST
34194: LIST
34195: LIST
34196: LIST
34197: LIST
34198: LIST
34199: LIST
34200: LIST
34201: LIST
34202: LIST
34203: LIST
34204: LIST
34205: LIST
34206: LIST
34207: LIST
34208: LIST
34209: LIST
34210: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34211: LD_ADDR_VAR 0 55
34215: PUSH
34216: LD_INT 0
34218: PUSH
34219: LD_INT 0
34221: PUSH
34222: EMPTY
34223: LIST
34224: LIST
34225: PUSH
34226: LD_INT 0
34228: PUSH
34229: LD_INT 1
34231: NEG
34232: PUSH
34233: EMPTY
34234: LIST
34235: LIST
34236: PUSH
34237: LD_INT 1
34239: PUSH
34240: LD_INT 0
34242: PUSH
34243: EMPTY
34244: LIST
34245: LIST
34246: PUSH
34247: LD_INT 1
34249: PUSH
34250: LD_INT 1
34252: PUSH
34253: EMPTY
34254: LIST
34255: LIST
34256: PUSH
34257: LD_INT 0
34259: PUSH
34260: LD_INT 1
34262: PUSH
34263: EMPTY
34264: LIST
34265: LIST
34266: PUSH
34267: LD_INT 1
34269: NEG
34270: PUSH
34271: LD_INT 0
34273: PUSH
34274: EMPTY
34275: LIST
34276: LIST
34277: PUSH
34278: LD_INT 1
34280: NEG
34281: PUSH
34282: LD_INT 1
34284: NEG
34285: PUSH
34286: EMPTY
34287: LIST
34288: LIST
34289: PUSH
34290: LD_INT 1
34292: NEG
34293: PUSH
34294: LD_INT 2
34296: NEG
34297: PUSH
34298: EMPTY
34299: LIST
34300: LIST
34301: PUSH
34302: LD_INT 0
34304: PUSH
34305: LD_INT 2
34307: NEG
34308: PUSH
34309: EMPTY
34310: LIST
34311: LIST
34312: PUSH
34313: LD_INT 1
34315: PUSH
34316: LD_INT 1
34318: NEG
34319: PUSH
34320: EMPTY
34321: LIST
34322: LIST
34323: PUSH
34324: LD_INT 2
34326: PUSH
34327: LD_INT 0
34329: PUSH
34330: EMPTY
34331: LIST
34332: LIST
34333: PUSH
34334: LD_INT 2
34336: PUSH
34337: LD_INT 1
34339: PUSH
34340: EMPTY
34341: LIST
34342: LIST
34343: PUSH
34344: LD_INT 2
34346: PUSH
34347: LD_INT 2
34349: PUSH
34350: EMPTY
34351: LIST
34352: LIST
34353: PUSH
34354: LD_INT 1
34356: PUSH
34357: LD_INT 2
34359: PUSH
34360: EMPTY
34361: LIST
34362: LIST
34363: PUSH
34364: LD_INT 0
34366: PUSH
34367: LD_INT 2
34369: PUSH
34370: EMPTY
34371: LIST
34372: LIST
34373: PUSH
34374: LD_INT 1
34376: NEG
34377: PUSH
34378: LD_INT 1
34380: PUSH
34381: EMPTY
34382: LIST
34383: LIST
34384: PUSH
34385: LD_INT 2
34387: NEG
34388: PUSH
34389: LD_INT 0
34391: PUSH
34392: EMPTY
34393: LIST
34394: LIST
34395: PUSH
34396: LD_INT 2
34398: NEG
34399: PUSH
34400: LD_INT 1
34402: NEG
34403: PUSH
34404: EMPTY
34405: LIST
34406: LIST
34407: PUSH
34408: LD_INT 2
34410: NEG
34411: PUSH
34412: LD_INT 2
34414: NEG
34415: PUSH
34416: EMPTY
34417: LIST
34418: LIST
34419: PUSH
34420: EMPTY
34421: LIST
34422: LIST
34423: LIST
34424: LIST
34425: LIST
34426: LIST
34427: LIST
34428: LIST
34429: LIST
34430: LIST
34431: LIST
34432: LIST
34433: LIST
34434: LIST
34435: LIST
34436: LIST
34437: LIST
34438: LIST
34439: LIST
34440: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34441: LD_ADDR_VAR 0 56
34445: PUSH
34446: LD_INT 0
34448: PUSH
34449: LD_INT 0
34451: PUSH
34452: EMPTY
34453: LIST
34454: LIST
34455: PUSH
34456: LD_INT 0
34458: PUSH
34459: LD_INT 1
34461: NEG
34462: PUSH
34463: EMPTY
34464: LIST
34465: LIST
34466: PUSH
34467: LD_INT 1
34469: PUSH
34470: LD_INT 0
34472: PUSH
34473: EMPTY
34474: LIST
34475: LIST
34476: PUSH
34477: LD_INT 1
34479: PUSH
34480: LD_INT 1
34482: PUSH
34483: EMPTY
34484: LIST
34485: LIST
34486: PUSH
34487: LD_INT 0
34489: PUSH
34490: LD_INT 1
34492: PUSH
34493: EMPTY
34494: LIST
34495: LIST
34496: PUSH
34497: LD_INT 1
34499: NEG
34500: PUSH
34501: LD_INT 0
34503: PUSH
34504: EMPTY
34505: LIST
34506: LIST
34507: PUSH
34508: LD_INT 1
34510: NEG
34511: PUSH
34512: LD_INT 1
34514: NEG
34515: PUSH
34516: EMPTY
34517: LIST
34518: LIST
34519: PUSH
34520: LD_INT 1
34522: NEG
34523: PUSH
34524: LD_INT 2
34526: NEG
34527: PUSH
34528: EMPTY
34529: LIST
34530: LIST
34531: PUSH
34532: LD_INT 0
34534: PUSH
34535: LD_INT 2
34537: NEG
34538: PUSH
34539: EMPTY
34540: LIST
34541: LIST
34542: PUSH
34543: LD_INT 1
34545: PUSH
34546: LD_INT 1
34548: NEG
34549: PUSH
34550: EMPTY
34551: LIST
34552: LIST
34553: PUSH
34554: LD_INT 2
34556: PUSH
34557: LD_INT 0
34559: PUSH
34560: EMPTY
34561: LIST
34562: LIST
34563: PUSH
34564: LD_INT 2
34566: PUSH
34567: LD_INT 1
34569: PUSH
34570: EMPTY
34571: LIST
34572: LIST
34573: PUSH
34574: LD_INT 2
34576: PUSH
34577: LD_INT 2
34579: PUSH
34580: EMPTY
34581: LIST
34582: LIST
34583: PUSH
34584: LD_INT 1
34586: PUSH
34587: LD_INT 2
34589: PUSH
34590: EMPTY
34591: LIST
34592: LIST
34593: PUSH
34594: LD_INT 0
34596: PUSH
34597: LD_INT 2
34599: PUSH
34600: EMPTY
34601: LIST
34602: LIST
34603: PUSH
34604: LD_INT 1
34606: NEG
34607: PUSH
34608: LD_INT 1
34610: PUSH
34611: EMPTY
34612: LIST
34613: LIST
34614: PUSH
34615: LD_INT 2
34617: NEG
34618: PUSH
34619: LD_INT 0
34621: PUSH
34622: EMPTY
34623: LIST
34624: LIST
34625: PUSH
34626: LD_INT 2
34628: NEG
34629: PUSH
34630: LD_INT 1
34632: NEG
34633: PUSH
34634: EMPTY
34635: LIST
34636: LIST
34637: PUSH
34638: LD_INT 2
34640: NEG
34641: PUSH
34642: LD_INT 2
34644: NEG
34645: PUSH
34646: EMPTY
34647: LIST
34648: LIST
34649: PUSH
34650: EMPTY
34651: LIST
34652: LIST
34653: LIST
34654: LIST
34655: LIST
34656: LIST
34657: LIST
34658: LIST
34659: LIST
34660: LIST
34661: LIST
34662: LIST
34663: LIST
34664: LIST
34665: LIST
34666: LIST
34667: LIST
34668: LIST
34669: LIST
34670: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34671: LD_ADDR_VAR 0 57
34675: PUSH
34676: LD_INT 0
34678: PUSH
34679: LD_INT 0
34681: PUSH
34682: EMPTY
34683: LIST
34684: LIST
34685: PUSH
34686: LD_INT 0
34688: PUSH
34689: LD_INT 1
34691: NEG
34692: PUSH
34693: EMPTY
34694: LIST
34695: LIST
34696: PUSH
34697: LD_INT 1
34699: PUSH
34700: LD_INT 0
34702: PUSH
34703: EMPTY
34704: LIST
34705: LIST
34706: PUSH
34707: LD_INT 1
34709: PUSH
34710: LD_INT 1
34712: PUSH
34713: EMPTY
34714: LIST
34715: LIST
34716: PUSH
34717: LD_INT 0
34719: PUSH
34720: LD_INT 1
34722: PUSH
34723: EMPTY
34724: LIST
34725: LIST
34726: PUSH
34727: LD_INT 1
34729: NEG
34730: PUSH
34731: LD_INT 0
34733: PUSH
34734: EMPTY
34735: LIST
34736: LIST
34737: PUSH
34738: LD_INT 1
34740: NEG
34741: PUSH
34742: LD_INT 1
34744: NEG
34745: PUSH
34746: EMPTY
34747: LIST
34748: LIST
34749: PUSH
34750: LD_INT 1
34752: NEG
34753: PUSH
34754: LD_INT 2
34756: NEG
34757: PUSH
34758: EMPTY
34759: LIST
34760: LIST
34761: PUSH
34762: LD_INT 0
34764: PUSH
34765: LD_INT 2
34767: NEG
34768: PUSH
34769: EMPTY
34770: LIST
34771: LIST
34772: PUSH
34773: LD_INT 1
34775: PUSH
34776: LD_INT 1
34778: NEG
34779: PUSH
34780: EMPTY
34781: LIST
34782: LIST
34783: PUSH
34784: LD_INT 2
34786: PUSH
34787: LD_INT 0
34789: PUSH
34790: EMPTY
34791: LIST
34792: LIST
34793: PUSH
34794: LD_INT 2
34796: PUSH
34797: LD_INT 1
34799: PUSH
34800: EMPTY
34801: LIST
34802: LIST
34803: PUSH
34804: LD_INT 2
34806: PUSH
34807: LD_INT 2
34809: PUSH
34810: EMPTY
34811: LIST
34812: LIST
34813: PUSH
34814: LD_INT 1
34816: PUSH
34817: LD_INT 2
34819: PUSH
34820: EMPTY
34821: LIST
34822: LIST
34823: PUSH
34824: LD_INT 0
34826: PUSH
34827: LD_INT 2
34829: PUSH
34830: EMPTY
34831: LIST
34832: LIST
34833: PUSH
34834: LD_INT 1
34836: NEG
34837: PUSH
34838: LD_INT 1
34840: PUSH
34841: EMPTY
34842: LIST
34843: LIST
34844: PUSH
34845: LD_INT 2
34847: NEG
34848: PUSH
34849: LD_INT 0
34851: PUSH
34852: EMPTY
34853: LIST
34854: LIST
34855: PUSH
34856: LD_INT 2
34858: NEG
34859: PUSH
34860: LD_INT 1
34862: NEG
34863: PUSH
34864: EMPTY
34865: LIST
34866: LIST
34867: PUSH
34868: LD_INT 2
34870: NEG
34871: PUSH
34872: LD_INT 2
34874: NEG
34875: PUSH
34876: EMPTY
34877: LIST
34878: LIST
34879: PUSH
34880: EMPTY
34881: LIST
34882: LIST
34883: LIST
34884: LIST
34885: LIST
34886: LIST
34887: LIST
34888: LIST
34889: LIST
34890: LIST
34891: LIST
34892: LIST
34893: LIST
34894: LIST
34895: LIST
34896: LIST
34897: LIST
34898: LIST
34899: LIST
34900: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34901: LD_ADDR_VAR 0 58
34905: PUSH
34906: LD_INT 0
34908: PUSH
34909: LD_INT 0
34911: PUSH
34912: EMPTY
34913: LIST
34914: LIST
34915: PUSH
34916: LD_INT 0
34918: PUSH
34919: LD_INT 1
34921: NEG
34922: PUSH
34923: EMPTY
34924: LIST
34925: LIST
34926: PUSH
34927: LD_INT 1
34929: PUSH
34930: LD_INT 0
34932: PUSH
34933: EMPTY
34934: LIST
34935: LIST
34936: PUSH
34937: LD_INT 1
34939: PUSH
34940: LD_INT 1
34942: PUSH
34943: EMPTY
34944: LIST
34945: LIST
34946: PUSH
34947: LD_INT 0
34949: PUSH
34950: LD_INT 1
34952: PUSH
34953: EMPTY
34954: LIST
34955: LIST
34956: PUSH
34957: LD_INT 1
34959: NEG
34960: PUSH
34961: LD_INT 0
34963: PUSH
34964: EMPTY
34965: LIST
34966: LIST
34967: PUSH
34968: LD_INT 1
34970: NEG
34971: PUSH
34972: LD_INT 1
34974: NEG
34975: PUSH
34976: EMPTY
34977: LIST
34978: LIST
34979: PUSH
34980: LD_INT 1
34982: NEG
34983: PUSH
34984: LD_INT 2
34986: NEG
34987: PUSH
34988: EMPTY
34989: LIST
34990: LIST
34991: PUSH
34992: LD_INT 0
34994: PUSH
34995: LD_INT 2
34997: NEG
34998: PUSH
34999: EMPTY
35000: LIST
35001: LIST
35002: PUSH
35003: LD_INT 1
35005: PUSH
35006: LD_INT 1
35008: NEG
35009: PUSH
35010: EMPTY
35011: LIST
35012: LIST
35013: PUSH
35014: LD_INT 2
35016: PUSH
35017: LD_INT 0
35019: PUSH
35020: EMPTY
35021: LIST
35022: LIST
35023: PUSH
35024: LD_INT 2
35026: PUSH
35027: LD_INT 1
35029: PUSH
35030: EMPTY
35031: LIST
35032: LIST
35033: PUSH
35034: LD_INT 2
35036: PUSH
35037: LD_INT 2
35039: PUSH
35040: EMPTY
35041: LIST
35042: LIST
35043: PUSH
35044: LD_INT 1
35046: PUSH
35047: LD_INT 2
35049: PUSH
35050: EMPTY
35051: LIST
35052: LIST
35053: PUSH
35054: LD_INT 0
35056: PUSH
35057: LD_INT 2
35059: PUSH
35060: EMPTY
35061: LIST
35062: LIST
35063: PUSH
35064: LD_INT 1
35066: NEG
35067: PUSH
35068: LD_INT 1
35070: PUSH
35071: EMPTY
35072: LIST
35073: LIST
35074: PUSH
35075: LD_INT 2
35077: NEG
35078: PUSH
35079: LD_INT 0
35081: PUSH
35082: EMPTY
35083: LIST
35084: LIST
35085: PUSH
35086: LD_INT 2
35088: NEG
35089: PUSH
35090: LD_INT 1
35092: NEG
35093: PUSH
35094: EMPTY
35095: LIST
35096: LIST
35097: PUSH
35098: LD_INT 2
35100: NEG
35101: PUSH
35102: LD_INT 2
35104: NEG
35105: PUSH
35106: EMPTY
35107: LIST
35108: LIST
35109: PUSH
35110: EMPTY
35111: LIST
35112: LIST
35113: LIST
35114: LIST
35115: LIST
35116: LIST
35117: LIST
35118: LIST
35119: LIST
35120: LIST
35121: LIST
35122: LIST
35123: LIST
35124: LIST
35125: LIST
35126: LIST
35127: LIST
35128: LIST
35129: LIST
35130: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35131: LD_ADDR_VAR 0 59
35135: PUSH
35136: LD_INT 0
35138: PUSH
35139: LD_INT 0
35141: PUSH
35142: EMPTY
35143: LIST
35144: LIST
35145: PUSH
35146: LD_INT 0
35148: PUSH
35149: LD_INT 1
35151: NEG
35152: PUSH
35153: EMPTY
35154: LIST
35155: LIST
35156: PUSH
35157: LD_INT 1
35159: PUSH
35160: LD_INT 0
35162: PUSH
35163: EMPTY
35164: LIST
35165: LIST
35166: PUSH
35167: LD_INT 1
35169: PUSH
35170: LD_INT 1
35172: PUSH
35173: EMPTY
35174: LIST
35175: LIST
35176: PUSH
35177: LD_INT 0
35179: PUSH
35180: LD_INT 1
35182: PUSH
35183: EMPTY
35184: LIST
35185: LIST
35186: PUSH
35187: LD_INT 1
35189: NEG
35190: PUSH
35191: LD_INT 0
35193: PUSH
35194: EMPTY
35195: LIST
35196: LIST
35197: PUSH
35198: LD_INT 1
35200: NEG
35201: PUSH
35202: LD_INT 1
35204: NEG
35205: PUSH
35206: EMPTY
35207: LIST
35208: LIST
35209: PUSH
35210: EMPTY
35211: LIST
35212: LIST
35213: LIST
35214: LIST
35215: LIST
35216: LIST
35217: LIST
35218: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35219: LD_ADDR_VAR 0 60
35223: PUSH
35224: LD_INT 0
35226: PUSH
35227: LD_INT 0
35229: PUSH
35230: EMPTY
35231: LIST
35232: LIST
35233: PUSH
35234: LD_INT 0
35236: PUSH
35237: LD_INT 1
35239: NEG
35240: PUSH
35241: EMPTY
35242: LIST
35243: LIST
35244: PUSH
35245: LD_INT 1
35247: PUSH
35248: LD_INT 0
35250: PUSH
35251: EMPTY
35252: LIST
35253: LIST
35254: PUSH
35255: LD_INT 1
35257: PUSH
35258: LD_INT 1
35260: PUSH
35261: EMPTY
35262: LIST
35263: LIST
35264: PUSH
35265: LD_INT 0
35267: PUSH
35268: LD_INT 1
35270: PUSH
35271: EMPTY
35272: LIST
35273: LIST
35274: PUSH
35275: LD_INT 1
35277: NEG
35278: PUSH
35279: LD_INT 0
35281: PUSH
35282: EMPTY
35283: LIST
35284: LIST
35285: PUSH
35286: LD_INT 1
35288: NEG
35289: PUSH
35290: LD_INT 1
35292: NEG
35293: PUSH
35294: EMPTY
35295: LIST
35296: LIST
35297: PUSH
35298: EMPTY
35299: LIST
35300: LIST
35301: LIST
35302: LIST
35303: LIST
35304: LIST
35305: LIST
35306: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35307: LD_ADDR_VAR 0 61
35311: PUSH
35312: LD_INT 0
35314: PUSH
35315: LD_INT 0
35317: PUSH
35318: EMPTY
35319: LIST
35320: LIST
35321: PUSH
35322: LD_INT 0
35324: PUSH
35325: LD_INT 1
35327: NEG
35328: PUSH
35329: EMPTY
35330: LIST
35331: LIST
35332: PUSH
35333: LD_INT 1
35335: PUSH
35336: LD_INT 0
35338: PUSH
35339: EMPTY
35340: LIST
35341: LIST
35342: PUSH
35343: LD_INT 1
35345: PUSH
35346: LD_INT 1
35348: PUSH
35349: EMPTY
35350: LIST
35351: LIST
35352: PUSH
35353: LD_INT 0
35355: PUSH
35356: LD_INT 1
35358: PUSH
35359: EMPTY
35360: LIST
35361: LIST
35362: PUSH
35363: LD_INT 1
35365: NEG
35366: PUSH
35367: LD_INT 0
35369: PUSH
35370: EMPTY
35371: LIST
35372: LIST
35373: PUSH
35374: LD_INT 1
35376: NEG
35377: PUSH
35378: LD_INT 1
35380: NEG
35381: PUSH
35382: EMPTY
35383: LIST
35384: LIST
35385: PUSH
35386: EMPTY
35387: LIST
35388: LIST
35389: LIST
35390: LIST
35391: LIST
35392: LIST
35393: LIST
35394: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35395: LD_ADDR_VAR 0 62
35399: PUSH
35400: LD_INT 0
35402: PUSH
35403: LD_INT 0
35405: PUSH
35406: EMPTY
35407: LIST
35408: LIST
35409: PUSH
35410: LD_INT 0
35412: PUSH
35413: LD_INT 1
35415: NEG
35416: PUSH
35417: EMPTY
35418: LIST
35419: LIST
35420: PUSH
35421: LD_INT 1
35423: PUSH
35424: LD_INT 0
35426: PUSH
35427: EMPTY
35428: LIST
35429: LIST
35430: PUSH
35431: LD_INT 1
35433: PUSH
35434: LD_INT 1
35436: PUSH
35437: EMPTY
35438: LIST
35439: LIST
35440: PUSH
35441: LD_INT 0
35443: PUSH
35444: LD_INT 1
35446: PUSH
35447: EMPTY
35448: LIST
35449: LIST
35450: PUSH
35451: LD_INT 1
35453: NEG
35454: PUSH
35455: LD_INT 0
35457: PUSH
35458: EMPTY
35459: LIST
35460: LIST
35461: PUSH
35462: LD_INT 1
35464: NEG
35465: PUSH
35466: LD_INT 1
35468: NEG
35469: PUSH
35470: EMPTY
35471: LIST
35472: LIST
35473: PUSH
35474: EMPTY
35475: LIST
35476: LIST
35477: LIST
35478: LIST
35479: LIST
35480: LIST
35481: LIST
35482: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35483: LD_ADDR_VAR 0 63
35487: PUSH
35488: LD_INT 0
35490: PUSH
35491: LD_INT 0
35493: PUSH
35494: EMPTY
35495: LIST
35496: LIST
35497: PUSH
35498: LD_INT 0
35500: PUSH
35501: LD_INT 1
35503: NEG
35504: PUSH
35505: EMPTY
35506: LIST
35507: LIST
35508: PUSH
35509: LD_INT 1
35511: PUSH
35512: LD_INT 0
35514: PUSH
35515: EMPTY
35516: LIST
35517: LIST
35518: PUSH
35519: LD_INT 1
35521: PUSH
35522: LD_INT 1
35524: PUSH
35525: EMPTY
35526: LIST
35527: LIST
35528: PUSH
35529: LD_INT 0
35531: PUSH
35532: LD_INT 1
35534: PUSH
35535: EMPTY
35536: LIST
35537: LIST
35538: PUSH
35539: LD_INT 1
35541: NEG
35542: PUSH
35543: LD_INT 0
35545: PUSH
35546: EMPTY
35547: LIST
35548: LIST
35549: PUSH
35550: LD_INT 1
35552: NEG
35553: PUSH
35554: LD_INT 1
35556: NEG
35557: PUSH
35558: EMPTY
35559: LIST
35560: LIST
35561: PUSH
35562: EMPTY
35563: LIST
35564: LIST
35565: LIST
35566: LIST
35567: LIST
35568: LIST
35569: LIST
35570: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35571: LD_ADDR_VAR 0 64
35575: PUSH
35576: LD_INT 0
35578: PUSH
35579: LD_INT 0
35581: PUSH
35582: EMPTY
35583: LIST
35584: LIST
35585: PUSH
35586: LD_INT 0
35588: PUSH
35589: LD_INT 1
35591: NEG
35592: PUSH
35593: EMPTY
35594: LIST
35595: LIST
35596: PUSH
35597: LD_INT 1
35599: PUSH
35600: LD_INT 0
35602: PUSH
35603: EMPTY
35604: LIST
35605: LIST
35606: PUSH
35607: LD_INT 1
35609: PUSH
35610: LD_INT 1
35612: PUSH
35613: EMPTY
35614: LIST
35615: LIST
35616: PUSH
35617: LD_INT 0
35619: PUSH
35620: LD_INT 1
35622: PUSH
35623: EMPTY
35624: LIST
35625: LIST
35626: PUSH
35627: LD_INT 1
35629: NEG
35630: PUSH
35631: LD_INT 0
35633: PUSH
35634: EMPTY
35635: LIST
35636: LIST
35637: PUSH
35638: LD_INT 1
35640: NEG
35641: PUSH
35642: LD_INT 1
35644: NEG
35645: PUSH
35646: EMPTY
35647: LIST
35648: LIST
35649: PUSH
35650: EMPTY
35651: LIST
35652: LIST
35653: LIST
35654: LIST
35655: LIST
35656: LIST
35657: LIST
35658: ST_TO_ADDR
// end ; 1 :
35659: GO 41556
35661: LD_INT 1
35663: DOUBLE
35664: EQUAL
35665: IFTRUE 35669
35667: GO 38292
35669: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
35670: LD_ADDR_VAR 0 11
35674: PUSH
35675: LD_INT 1
35677: NEG
35678: PUSH
35679: LD_INT 3
35681: NEG
35682: PUSH
35683: EMPTY
35684: LIST
35685: LIST
35686: PUSH
35687: LD_INT 0
35689: PUSH
35690: LD_INT 3
35692: NEG
35693: PUSH
35694: EMPTY
35695: LIST
35696: LIST
35697: PUSH
35698: LD_INT 1
35700: PUSH
35701: LD_INT 2
35703: NEG
35704: PUSH
35705: EMPTY
35706: LIST
35707: LIST
35708: PUSH
35709: EMPTY
35710: LIST
35711: LIST
35712: LIST
35713: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
35714: LD_ADDR_VAR 0 12
35718: PUSH
35719: LD_INT 2
35721: PUSH
35722: LD_INT 1
35724: NEG
35725: PUSH
35726: EMPTY
35727: LIST
35728: LIST
35729: PUSH
35730: LD_INT 3
35732: PUSH
35733: LD_INT 0
35735: PUSH
35736: EMPTY
35737: LIST
35738: LIST
35739: PUSH
35740: LD_INT 3
35742: PUSH
35743: LD_INT 1
35745: PUSH
35746: EMPTY
35747: LIST
35748: LIST
35749: PUSH
35750: EMPTY
35751: LIST
35752: LIST
35753: LIST
35754: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
35755: LD_ADDR_VAR 0 13
35759: PUSH
35760: LD_INT 3
35762: PUSH
35763: LD_INT 2
35765: PUSH
35766: EMPTY
35767: LIST
35768: LIST
35769: PUSH
35770: LD_INT 3
35772: PUSH
35773: LD_INT 3
35775: PUSH
35776: EMPTY
35777: LIST
35778: LIST
35779: PUSH
35780: LD_INT 2
35782: PUSH
35783: LD_INT 3
35785: PUSH
35786: EMPTY
35787: LIST
35788: LIST
35789: PUSH
35790: EMPTY
35791: LIST
35792: LIST
35793: LIST
35794: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
35795: LD_ADDR_VAR 0 14
35799: PUSH
35800: LD_INT 1
35802: PUSH
35803: LD_INT 3
35805: PUSH
35806: EMPTY
35807: LIST
35808: LIST
35809: PUSH
35810: LD_INT 0
35812: PUSH
35813: LD_INT 3
35815: PUSH
35816: EMPTY
35817: LIST
35818: LIST
35819: PUSH
35820: LD_INT 1
35822: NEG
35823: PUSH
35824: LD_INT 2
35826: PUSH
35827: EMPTY
35828: LIST
35829: LIST
35830: PUSH
35831: EMPTY
35832: LIST
35833: LIST
35834: LIST
35835: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35836: LD_ADDR_VAR 0 15
35840: PUSH
35841: LD_INT 2
35843: NEG
35844: PUSH
35845: LD_INT 1
35847: PUSH
35848: EMPTY
35849: LIST
35850: LIST
35851: PUSH
35852: LD_INT 3
35854: NEG
35855: PUSH
35856: LD_INT 0
35858: PUSH
35859: EMPTY
35860: LIST
35861: LIST
35862: PUSH
35863: LD_INT 3
35865: NEG
35866: PUSH
35867: LD_INT 1
35869: NEG
35870: PUSH
35871: EMPTY
35872: LIST
35873: LIST
35874: PUSH
35875: EMPTY
35876: LIST
35877: LIST
35878: LIST
35879: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35880: LD_ADDR_VAR 0 16
35884: PUSH
35885: LD_INT 2
35887: NEG
35888: PUSH
35889: LD_INT 3
35891: NEG
35892: PUSH
35893: EMPTY
35894: LIST
35895: LIST
35896: PUSH
35897: LD_INT 3
35899: NEG
35900: PUSH
35901: LD_INT 2
35903: NEG
35904: PUSH
35905: EMPTY
35906: LIST
35907: LIST
35908: PUSH
35909: LD_INT 3
35911: NEG
35912: PUSH
35913: LD_INT 3
35915: NEG
35916: PUSH
35917: EMPTY
35918: LIST
35919: LIST
35920: PUSH
35921: EMPTY
35922: LIST
35923: LIST
35924: LIST
35925: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
35926: LD_ADDR_VAR 0 17
35930: PUSH
35931: LD_INT 1
35933: NEG
35934: PUSH
35935: LD_INT 3
35937: NEG
35938: PUSH
35939: EMPTY
35940: LIST
35941: LIST
35942: PUSH
35943: LD_INT 0
35945: PUSH
35946: LD_INT 3
35948: NEG
35949: PUSH
35950: EMPTY
35951: LIST
35952: LIST
35953: PUSH
35954: LD_INT 1
35956: PUSH
35957: LD_INT 2
35959: NEG
35960: PUSH
35961: EMPTY
35962: LIST
35963: LIST
35964: PUSH
35965: EMPTY
35966: LIST
35967: LIST
35968: LIST
35969: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
35970: LD_ADDR_VAR 0 18
35974: PUSH
35975: LD_INT 2
35977: PUSH
35978: LD_INT 1
35980: NEG
35981: PUSH
35982: EMPTY
35983: LIST
35984: LIST
35985: PUSH
35986: LD_INT 3
35988: PUSH
35989: LD_INT 0
35991: PUSH
35992: EMPTY
35993: LIST
35994: LIST
35995: PUSH
35996: LD_INT 3
35998: PUSH
35999: LD_INT 1
36001: PUSH
36002: EMPTY
36003: LIST
36004: LIST
36005: PUSH
36006: EMPTY
36007: LIST
36008: LIST
36009: LIST
36010: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
36011: LD_ADDR_VAR 0 19
36015: PUSH
36016: LD_INT 3
36018: PUSH
36019: LD_INT 2
36021: PUSH
36022: EMPTY
36023: LIST
36024: LIST
36025: PUSH
36026: LD_INT 3
36028: PUSH
36029: LD_INT 3
36031: PUSH
36032: EMPTY
36033: LIST
36034: LIST
36035: PUSH
36036: LD_INT 2
36038: PUSH
36039: LD_INT 3
36041: PUSH
36042: EMPTY
36043: LIST
36044: LIST
36045: PUSH
36046: EMPTY
36047: LIST
36048: LIST
36049: LIST
36050: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
36051: LD_ADDR_VAR 0 20
36055: PUSH
36056: LD_INT 1
36058: PUSH
36059: LD_INT 3
36061: PUSH
36062: EMPTY
36063: LIST
36064: LIST
36065: PUSH
36066: LD_INT 0
36068: PUSH
36069: LD_INT 3
36071: PUSH
36072: EMPTY
36073: LIST
36074: LIST
36075: PUSH
36076: LD_INT 1
36078: NEG
36079: PUSH
36080: LD_INT 2
36082: PUSH
36083: EMPTY
36084: LIST
36085: LIST
36086: PUSH
36087: EMPTY
36088: LIST
36089: LIST
36090: LIST
36091: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36092: LD_ADDR_VAR 0 21
36096: PUSH
36097: LD_INT 2
36099: NEG
36100: PUSH
36101: LD_INT 1
36103: PUSH
36104: EMPTY
36105: LIST
36106: LIST
36107: PUSH
36108: LD_INT 3
36110: NEG
36111: PUSH
36112: LD_INT 0
36114: PUSH
36115: EMPTY
36116: LIST
36117: LIST
36118: PUSH
36119: LD_INT 3
36121: NEG
36122: PUSH
36123: LD_INT 1
36125: NEG
36126: PUSH
36127: EMPTY
36128: LIST
36129: LIST
36130: PUSH
36131: EMPTY
36132: LIST
36133: LIST
36134: LIST
36135: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36136: LD_ADDR_VAR 0 22
36140: PUSH
36141: LD_INT 2
36143: NEG
36144: PUSH
36145: LD_INT 3
36147: NEG
36148: PUSH
36149: EMPTY
36150: LIST
36151: LIST
36152: PUSH
36153: LD_INT 3
36155: NEG
36156: PUSH
36157: LD_INT 2
36159: NEG
36160: PUSH
36161: EMPTY
36162: LIST
36163: LIST
36164: PUSH
36165: LD_INT 3
36167: NEG
36168: PUSH
36169: LD_INT 3
36171: NEG
36172: PUSH
36173: EMPTY
36174: LIST
36175: LIST
36176: PUSH
36177: EMPTY
36178: LIST
36179: LIST
36180: LIST
36181: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
36182: LD_ADDR_VAR 0 23
36186: PUSH
36187: LD_INT 0
36189: PUSH
36190: LD_INT 3
36192: NEG
36193: PUSH
36194: EMPTY
36195: LIST
36196: LIST
36197: PUSH
36198: LD_INT 1
36200: NEG
36201: PUSH
36202: LD_INT 4
36204: NEG
36205: PUSH
36206: EMPTY
36207: LIST
36208: LIST
36209: PUSH
36210: LD_INT 1
36212: PUSH
36213: LD_INT 3
36215: NEG
36216: PUSH
36217: EMPTY
36218: LIST
36219: LIST
36220: PUSH
36221: EMPTY
36222: LIST
36223: LIST
36224: LIST
36225: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
36226: LD_ADDR_VAR 0 24
36230: PUSH
36231: LD_INT 3
36233: PUSH
36234: LD_INT 0
36236: PUSH
36237: EMPTY
36238: LIST
36239: LIST
36240: PUSH
36241: LD_INT 3
36243: PUSH
36244: LD_INT 1
36246: NEG
36247: PUSH
36248: EMPTY
36249: LIST
36250: LIST
36251: PUSH
36252: LD_INT 4
36254: PUSH
36255: LD_INT 1
36257: PUSH
36258: EMPTY
36259: LIST
36260: LIST
36261: PUSH
36262: EMPTY
36263: LIST
36264: LIST
36265: LIST
36266: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
36267: LD_ADDR_VAR 0 25
36271: PUSH
36272: LD_INT 3
36274: PUSH
36275: LD_INT 3
36277: PUSH
36278: EMPTY
36279: LIST
36280: LIST
36281: PUSH
36282: LD_INT 4
36284: PUSH
36285: LD_INT 3
36287: PUSH
36288: EMPTY
36289: LIST
36290: LIST
36291: PUSH
36292: LD_INT 3
36294: PUSH
36295: LD_INT 4
36297: PUSH
36298: EMPTY
36299: LIST
36300: LIST
36301: PUSH
36302: EMPTY
36303: LIST
36304: LIST
36305: LIST
36306: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
36307: LD_ADDR_VAR 0 26
36311: PUSH
36312: LD_INT 0
36314: PUSH
36315: LD_INT 3
36317: PUSH
36318: EMPTY
36319: LIST
36320: LIST
36321: PUSH
36322: LD_INT 1
36324: PUSH
36325: LD_INT 4
36327: PUSH
36328: EMPTY
36329: LIST
36330: LIST
36331: PUSH
36332: LD_INT 1
36334: NEG
36335: PUSH
36336: LD_INT 3
36338: PUSH
36339: EMPTY
36340: LIST
36341: LIST
36342: PUSH
36343: EMPTY
36344: LIST
36345: LIST
36346: LIST
36347: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
36348: LD_ADDR_VAR 0 27
36352: PUSH
36353: LD_INT 3
36355: NEG
36356: PUSH
36357: LD_INT 0
36359: PUSH
36360: EMPTY
36361: LIST
36362: LIST
36363: PUSH
36364: LD_INT 3
36366: NEG
36367: PUSH
36368: LD_INT 1
36370: PUSH
36371: EMPTY
36372: LIST
36373: LIST
36374: PUSH
36375: LD_INT 4
36377: NEG
36378: PUSH
36379: LD_INT 1
36381: NEG
36382: PUSH
36383: EMPTY
36384: LIST
36385: LIST
36386: PUSH
36387: EMPTY
36388: LIST
36389: LIST
36390: LIST
36391: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
36392: LD_ADDR_VAR 0 28
36396: PUSH
36397: LD_INT 3
36399: NEG
36400: PUSH
36401: LD_INT 3
36403: NEG
36404: PUSH
36405: EMPTY
36406: LIST
36407: LIST
36408: PUSH
36409: LD_INT 3
36411: NEG
36412: PUSH
36413: LD_INT 4
36415: NEG
36416: PUSH
36417: EMPTY
36418: LIST
36419: LIST
36420: PUSH
36421: LD_INT 4
36423: NEG
36424: PUSH
36425: LD_INT 3
36427: NEG
36428: PUSH
36429: EMPTY
36430: LIST
36431: LIST
36432: PUSH
36433: EMPTY
36434: LIST
36435: LIST
36436: LIST
36437: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
36438: LD_ADDR_VAR 0 29
36442: PUSH
36443: LD_INT 1
36445: NEG
36446: PUSH
36447: LD_INT 3
36449: NEG
36450: PUSH
36451: EMPTY
36452: LIST
36453: LIST
36454: PUSH
36455: LD_INT 0
36457: PUSH
36458: LD_INT 3
36460: NEG
36461: PUSH
36462: EMPTY
36463: LIST
36464: LIST
36465: PUSH
36466: LD_INT 1
36468: PUSH
36469: LD_INT 2
36471: NEG
36472: PUSH
36473: EMPTY
36474: LIST
36475: LIST
36476: PUSH
36477: LD_INT 1
36479: NEG
36480: PUSH
36481: LD_INT 4
36483: NEG
36484: PUSH
36485: EMPTY
36486: LIST
36487: LIST
36488: PUSH
36489: LD_INT 0
36491: PUSH
36492: LD_INT 4
36494: NEG
36495: PUSH
36496: EMPTY
36497: LIST
36498: LIST
36499: PUSH
36500: LD_INT 1
36502: PUSH
36503: LD_INT 3
36505: NEG
36506: PUSH
36507: EMPTY
36508: LIST
36509: LIST
36510: PUSH
36511: LD_INT 1
36513: NEG
36514: PUSH
36515: LD_INT 5
36517: NEG
36518: PUSH
36519: EMPTY
36520: LIST
36521: LIST
36522: PUSH
36523: LD_INT 0
36525: PUSH
36526: LD_INT 5
36528: NEG
36529: PUSH
36530: EMPTY
36531: LIST
36532: LIST
36533: PUSH
36534: LD_INT 1
36536: PUSH
36537: LD_INT 4
36539: NEG
36540: PUSH
36541: EMPTY
36542: LIST
36543: LIST
36544: PUSH
36545: LD_INT 1
36547: NEG
36548: PUSH
36549: LD_INT 6
36551: NEG
36552: PUSH
36553: EMPTY
36554: LIST
36555: LIST
36556: PUSH
36557: LD_INT 0
36559: PUSH
36560: LD_INT 6
36562: NEG
36563: PUSH
36564: EMPTY
36565: LIST
36566: LIST
36567: PUSH
36568: LD_INT 1
36570: PUSH
36571: LD_INT 5
36573: NEG
36574: PUSH
36575: EMPTY
36576: LIST
36577: LIST
36578: PUSH
36579: EMPTY
36580: LIST
36581: LIST
36582: LIST
36583: LIST
36584: LIST
36585: LIST
36586: LIST
36587: LIST
36588: LIST
36589: LIST
36590: LIST
36591: LIST
36592: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
36593: LD_ADDR_VAR 0 30
36597: PUSH
36598: LD_INT 2
36600: PUSH
36601: LD_INT 1
36603: NEG
36604: PUSH
36605: EMPTY
36606: LIST
36607: LIST
36608: PUSH
36609: LD_INT 3
36611: PUSH
36612: LD_INT 0
36614: PUSH
36615: EMPTY
36616: LIST
36617: LIST
36618: PUSH
36619: LD_INT 3
36621: PUSH
36622: LD_INT 1
36624: PUSH
36625: EMPTY
36626: LIST
36627: LIST
36628: PUSH
36629: LD_INT 3
36631: PUSH
36632: LD_INT 1
36634: NEG
36635: PUSH
36636: EMPTY
36637: LIST
36638: LIST
36639: PUSH
36640: LD_INT 4
36642: PUSH
36643: LD_INT 0
36645: PUSH
36646: EMPTY
36647: LIST
36648: LIST
36649: PUSH
36650: LD_INT 4
36652: PUSH
36653: LD_INT 1
36655: PUSH
36656: EMPTY
36657: LIST
36658: LIST
36659: PUSH
36660: LD_INT 4
36662: PUSH
36663: LD_INT 1
36665: NEG
36666: PUSH
36667: EMPTY
36668: LIST
36669: LIST
36670: PUSH
36671: LD_INT 5
36673: PUSH
36674: LD_INT 0
36676: PUSH
36677: EMPTY
36678: LIST
36679: LIST
36680: PUSH
36681: LD_INT 5
36683: PUSH
36684: LD_INT 1
36686: PUSH
36687: EMPTY
36688: LIST
36689: LIST
36690: PUSH
36691: LD_INT 5
36693: PUSH
36694: LD_INT 1
36696: NEG
36697: PUSH
36698: EMPTY
36699: LIST
36700: LIST
36701: PUSH
36702: LD_INT 6
36704: PUSH
36705: LD_INT 0
36707: PUSH
36708: EMPTY
36709: LIST
36710: LIST
36711: PUSH
36712: LD_INT 6
36714: PUSH
36715: LD_INT 1
36717: PUSH
36718: EMPTY
36719: LIST
36720: LIST
36721: PUSH
36722: EMPTY
36723: LIST
36724: LIST
36725: LIST
36726: LIST
36727: LIST
36728: LIST
36729: LIST
36730: LIST
36731: LIST
36732: LIST
36733: LIST
36734: LIST
36735: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
36736: LD_ADDR_VAR 0 31
36740: PUSH
36741: LD_INT 3
36743: PUSH
36744: LD_INT 2
36746: PUSH
36747: EMPTY
36748: LIST
36749: LIST
36750: PUSH
36751: LD_INT 3
36753: PUSH
36754: LD_INT 3
36756: PUSH
36757: EMPTY
36758: LIST
36759: LIST
36760: PUSH
36761: LD_INT 2
36763: PUSH
36764: LD_INT 3
36766: PUSH
36767: EMPTY
36768: LIST
36769: LIST
36770: PUSH
36771: LD_INT 4
36773: PUSH
36774: LD_INT 3
36776: PUSH
36777: EMPTY
36778: LIST
36779: LIST
36780: PUSH
36781: LD_INT 4
36783: PUSH
36784: LD_INT 4
36786: PUSH
36787: EMPTY
36788: LIST
36789: LIST
36790: PUSH
36791: LD_INT 3
36793: PUSH
36794: LD_INT 4
36796: PUSH
36797: EMPTY
36798: LIST
36799: LIST
36800: PUSH
36801: LD_INT 5
36803: PUSH
36804: LD_INT 4
36806: PUSH
36807: EMPTY
36808: LIST
36809: LIST
36810: PUSH
36811: LD_INT 5
36813: PUSH
36814: LD_INT 5
36816: PUSH
36817: EMPTY
36818: LIST
36819: LIST
36820: PUSH
36821: LD_INT 4
36823: PUSH
36824: LD_INT 5
36826: PUSH
36827: EMPTY
36828: LIST
36829: LIST
36830: PUSH
36831: LD_INT 6
36833: PUSH
36834: LD_INT 5
36836: PUSH
36837: EMPTY
36838: LIST
36839: LIST
36840: PUSH
36841: LD_INT 6
36843: PUSH
36844: LD_INT 6
36846: PUSH
36847: EMPTY
36848: LIST
36849: LIST
36850: PUSH
36851: LD_INT 5
36853: PUSH
36854: LD_INT 6
36856: PUSH
36857: EMPTY
36858: LIST
36859: LIST
36860: PUSH
36861: EMPTY
36862: LIST
36863: LIST
36864: LIST
36865: LIST
36866: LIST
36867: LIST
36868: LIST
36869: LIST
36870: LIST
36871: LIST
36872: LIST
36873: LIST
36874: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
36875: LD_ADDR_VAR 0 32
36879: PUSH
36880: LD_INT 1
36882: PUSH
36883: LD_INT 3
36885: PUSH
36886: EMPTY
36887: LIST
36888: LIST
36889: PUSH
36890: LD_INT 0
36892: PUSH
36893: LD_INT 3
36895: PUSH
36896: EMPTY
36897: LIST
36898: LIST
36899: PUSH
36900: LD_INT 1
36902: NEG
36903: PUSH
36904: LD_INT 2
36906: PUSH
36907: EMPTY
36908: LIST
36909: LIST
36910: PUSH
36911: LD_INT 1
36913: PUSH
36914: LD_INT 4
36916: PUSH
36917: EMPTY
36918: LIST
36919: LIST
36920: PUSH
36921: LD_INT 0
36923: PUSH
36924: LD_INT 4
36926: PUSH
36927: EMPTY
36928: LIST
36929: LIST
36930: PUSH
36931: LD_INT 1
36933: NEG
36934: PUSH
36935: LD_INT 3
36937: PUSH
36938: EMPTY
36939: LIST
36940: LIST
36941: PUSH
36942: LD_INT 1
36944: PUSH
36945: LD_INT 5
36947: PUSH
36948: EMPTY
36949: LIST
36950: LIST
36951: PUSH
36952: LD_INT 0
36954: PUSH
36955: LD_INT 5
36957: PUSH
36958: EMPTY
36959: LIST
36960: LIST
36961: PUSH
36962: LD_INT 1
36964: NEG
36965: PUSH
36966: LD_INT 4
36968: PUSH
36969: EMPTY
36970: LIST
36971: LIST
36972: PUSH
36973: LD_INT 1
36975: PUSH
36976: LD_INT 6
36978: PUSH
36979: EMPTY
36980: LIST
36981: LIST
36982: PUSH
36983: LD_INT 0
36985: PUSH
36986: LD_INT 6
36988: PUSH
36989: EMPTY
36990: LIST
36991: LIST
36992: PUSH
36993: LD_INT 1
36995: NEG
36996: PUSH
36997: LD_INT 5
36999: PUSH
37000: EMPTY
37001: LIST
37002: LIST
37003: PUSH
37004: EMPTY
37005: LIST
37006: LIST
37007: LIST
37008: LIST
37009: LIST
37010: LIST
37011: LIST
37012: LIST
37013: LIST
37014: LIST
37015: LIST
37016: LIST
37017: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
37018: LD_ADDR_VAR 0 33
37022: PUSH
37023: LD_INT 2
37025: NEG
37026: PUSH
37027: LD_INT 1
37029: PUSH
37030: EMPTY
37031: LIST
37032: LIST
37033: PUSH
37034: LD_INT 3
37036: NEG
37037: PUSH
37038: LD_INT 0
37040: PUSH
37041: EMPTY
37042: LIST
37043: LIST
37044: PUSH
37045: LD_INT 3
37047: NEG
37048: PUSH
37049: LD_INT 1
37051: NEG
37052: PUSH
37053: EMPTY
37054: LIST
37055: LIST
37056: PUSH
37057: LD_INT 3
37059: NEG
37060: PUSH
37061: LD_INT 1
37063: PUSH
37064: EMPTY
37065: LIST
37066: LIST
37067: PUSH
37068: LD_INT 4
37070: NEG
37071: PUSH
37072: LD_INT 0
37074: PUSH
37075: EMPTY
37076: LIST
37077: LIST
37078: PUSH
37079: LD_INT 4
37081: NEG
37082: PUSH
37083: LD_INT 1
37085: NEG
37086: PUSH
37087: EMPTY
37088: LIST
37089: LIST
37090: PUSH
37091: LD_INT 4
37093: NEG
37094: PUSH
37095: LD_INT 1
37097: PUSH
37098: EMPTY
37099: LIST
37100: LIST
37101: PUSH
37102: LD_INT 5
37104: NEG
37105: PUSH
37106: LD_INT 0
37108: PUSH
37109: EMPTY
37110: LIST
37111: LIST
37112: PUSH
37113: LD_INT 5
37115: NEG
37116: PUSH
37117: LD_INT 1
37119: NEG
37120: PUSH
37121: EMPTY
37122: LIST
37123: LIST
37124: PUSH
37125: LD_INT 5
37127: NEG
37128: PUSH
37129: LD_INT 1
37131: PUSH
37132: EMPTY
37133: LIST
37134: LIST
37135: PUSH
37136: LD_INT 6
37138: NEG
37139: PUSH
37140: LD_INT 0
37142: PUSH
37143: EMPTY
37144: LIST
37145: LIST
37146: PUSH
37147: LD_INT 6
37149: NEG
37150: PUSH
37151: LD_INT 1
37153: NEG
37154: PUSH
37155: EMPTY
37156: LIST
37157: LIST
37158: PUSH
37159: EMPTY
37160: LIST
37161: LIST
37162: LIST
37163: LIST
37164: LIST
37165: LIST
37166: LIST
37167: LIST
37168: LIST
37169: LIST
37170: LIST
37171: LIST
37172: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
37173: LD_ADDR_VAR 0 34
37177: PUSH
37178: LD_INT 2
37180: NEG
37181: PUSH
37182: LD_INT 3
37184: NEG
37185: PUSH
37186: EMPTY
37187: LIST
37188: LIST
37189: PUSH
37190: LD_INT 3
37192: NEG
37193: PUSH
37194: LD_INT 2
37196: NEG
37197: PUSH
37198: EMPTY
37199: LIST
37200: LIST
37201: PUSH
37202: LD_INT 3
37204: NEG
37205: PUSH
37206: LD_INT 3
37208: NEG
37209: PUSH
37210: EMPTY
37211: LIST
37212: LIST
37213: PUSH
37214: LD_INT 3
37216: NEG
37217: PUSH
37218: LD_INT 4
37220: NEG
37221: PUSH
37222: EMPTY
37223: LIST
37224: LIST
37225: PUSH
37226: LD_INT 4
37228: NEG
37229: PUSH
37230: LD_INT 3
37232: NEG
37233: PUSH
37234: EMPTY
37235: LIST
37236: LIST
37237: PUSH
37238: LD_INT 4
37240: NEG
37241: PUSH
37242: LD_INT 4
37244: NEG
37245: PUSH
37246: EMPTY
37247: LIST
37248: LIST
37249: PUSH
37250: LD_INT 4
37252: NEG
37253: PUSH
37254: LD_INT 5
37256: NEG
37257: PUSH
37258: EMPTY
37259: LIST
37260: LIST
37261: PUSH
37262: LD_INT 5
37264: NEG
37265: PUSH
37266: LD_INT 4
37268: NEG
37269: PUSH
37270: EMPTY
37271: LIST
37272: LIST
37273: PUSH
37274: LD_INT 5
37276: NEG
37277: PUSH
37278: LD_INT 5
37280: NEG
37281: PUSH
37282: EMPTY
37283: LIST
37284: LIST
37285: PUSH
37286: LD_INT 5
37288: NEG
37289: PUSH
37290: LD_INT 6
37292: NEG
37293: PUSH
37294: EMPTY
37295: LIST
37296: LIST
37297: PUSH
37298: LD_INT 6
37300: NEG
37301: PUSH
37302: LD_INT 5
37304: NEG
37305: PUSH
37306: EMPTY
37307: LIST
37308: LIST
37309: PUSH
37310: LD_INT 6
37312: NEG
37313: PUSH
37314: LD_INT 6
37316: NEG
37317: PUSH
37318: EMPTY
37319: LIST
37320: LIST
37321: PUSH
37322: EMPTY
37323: LIST
37324: LIST
37325: LIST
37326: LIST
37327: LIST
37328: LIST
37329: LIST
37330: LIST
37331: LIST
37332: LIST
37333: LIST
37334: LIST
37335: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
37336: LD_ADDR_VAR 0 41
37340: PUSH
37341: LD_INT 0
37343: PUSH
37344: LD_INT 2
37346: NEG
37347: PUSH
37348: EMPTY
37349: LIST
37350: LIST
37351: PUSH
37352: LD_INT 1
37354: NEG
37355: PUSH
37356: LD_INT 3
37358: NEG
37359: PUSH
37360: EMPTY
37361: LIST
37362: LIST
37363: PUSH
37364: LD_INT 1
37366: PUSH
37367: LD_INT 2
37369: NEG
37370: PUSH
37371: EMPTY
37372: LIST
37373: LIST
37374: PUSH
37375: EMPTY
37376: LIST
37377: LIST
37378: LIST
37379: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
37380: LD_ADDR_VAR 0 42
37384: PUSH
37385: LD_INT 2
37387: PUSH
37388: LD_INT 0
37390: PUSH
37391: EMPTY
37392: LIST
37393: LIST
37394: PUSH
37395: LD_INT 2
37397: PUSH
37398: LD_INT 1
37400: NEG
37401: PUSH
37402: EMPTY
37403: LIST
37404: LIST
37405: PUSH
37406: LD_INT 3
37408: PUSH
37409: LD_INT 1
37411: PUSH
37412: EMPTY
37413: LIST
37414: LIST
37415: PUSH
37416: EMPTY
37417: LIST
37418: LIST
37419: LIST
37420: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
37421: LD_ADDR_VAR 0 43
37425: PUSH
37426: LD_INT 2
37428: PUSH
37429: LD_INT 2
37431: PUSH
37432: EMPTY
37433: LIST
37434: LIST
37435: PUSH
37436: LD_INT 3
37438: PUSH
37439: LD_INT 2
37441: PUSH
37442: EMPTY
37443: LIST
37444: LIST
37445: PUSH
37446: LD_INT 2
37448: PUSH
37449: LD_INT 3
37451: PUSH
37452: EMPTY
37453: LIST
37454: LIST
37455: PUSH
37456: EMPTY
37457: LIST
37458: LIST
37459: LIST
37460: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
37461: LD_ADDR_VAR 0 44
37465: PUSH
37466: LD_INT 0
37468: PUSH
37469: LD_INT 2
37471: PUSH
37472: EMPTY
37473: LIST
37474: LIST
37475: PUSH
37476: LD_INT 1
37478: PUSH
37479: LD_INT 3
37481: PUSH
37482: EMPTY
37483: LIST
37484: LIST
37485: PUSH
37486: LD_INT 1
37488: NEG
37489: PUSH
37490: LD_INT 2
37492: PUSH
37493: EMPTY
37494: LIST
37495: LIST
37496: PUSH
37497: EMPTY
37498: LIST
37499: LIST
37500: LIST
37501: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
37502: LD_ADDR_VAR 0 45
37506: PUSH
37507: LD_INT 2
37509: NEG
37510: PUSH
37511: LD_INT 0
37513: PUSH
37514: EMPTY
37515: LIST
37516: LIST
37517: PUSH
37518: LD_INT 2
37520: NEG
37521: PUSH
37522: LD_INT 1
37524: PUSH
37525: EMPTY
37526: LIST
37527: LIST
37528: PUSH
37529: LD_INT 3
37531: NEG
37532: PUSH
37533: LD_INT 1
37535: NEG
37536: PUSH
37537: EMPTY
37538: LIST
37539: LIST
37540: PUSH
37541: EMPTY
37542: LIST
37543: LIST
37544: LIST
37545: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
37546: LD_ADDR_VAR 0 46
37550: PUSH
37551: LD_INT 2
37553: NEG
37554: PUSH
37555: LD_INT 2
37557: NEG
37558: PUSH
37559: EMPTY
37560: LIST
37561: LIST
37562: PUSH
37563: LD_INT 2
37565: NEG
37566: PUSH
37567: LD_INT 3
37569: NEG
37570: PUSH
37571: EMPTY
37572: LIST
37573: LIST
37574: PUSH
37575: LD_INT 3
37577: NEG
37578: PUSH
37579: LD_INT 2
37581: NEG
37582: PUSH
37583: EMPTY
37584: LIST
37585: LIST
37586: PUSH
37587: EMPTY
37588: LIST
37589: LIST
37590: LIST
37591: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
37592: LD_ADDR_VAR 0 47
37596: PUSH
37597: LD_INT 2
37599: NEG
37600: PUSH
37601: LD_INT 3
37603: NEG
37604: PUSH
37605: EMPTY
37606: LIST
37607: LIST
37608: PUSH
37609: LD_INT 1
37611: NEG
37612: PUSH
37613: LD_INT 3
37615: NEG
37616: PUSH
37617: EMPTY
37618: LIST
37619: LIST
37620: PUSH
37621: EMPTY
37622: LIST
37623: LIST
37624: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
37625: LD_ADDR_VAR 0 48
37629: PUSH
37630: LD_INT 1
37632: PUSH
37633: LD_INT 2
37635: NEG
37636: PUSH
37637: EMPTY
37638: LIST
37639: LIST
37640: PUSH
37641: LD_INT 2
37643: PUSH
37644: LD_INT 1
37646: NEG
37647: PUSH
37648: EMPTY
37649: LIST
37650: LIST
37651: PUSH
37652: EMPTY
37653: LIST
37654: LIST
37655: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
37656: LD_ADDR_VAR 0 49
37660: PUSH
37661: LD_INT 3
37663: PUSH
37664: LD_INT 1
37666: PUSH
37667: EMPTY
37668: LIST
37669: LIST
37670: PUSH
37671: LD_INT 3
37673: PUSH
37674: LD_INT 2
37676: PUSH
37677: EMPTY
37678: LIST
37679: LIST
37680: PUSH
37681: EMPTY
37682: LIST
37683: LIST
37684: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
37685: LD_ADDR_VAR 0 50
37689: PUSH
37690: LD_INT 2
37692: PUSH
37693: LD_INT 3
37695: PUSH
37696: EMPTY
37697: LIST
37698: LIST
37699: PUSH
37700: LD_INT 1
37702: PUSH
37703: LD_INT 3
37705: PUSH
37706: EMPTY
37707: LIST
37708: LIST
37709: PUSH
37710: EMPTY
37711: LIST
37712: LIST
37713: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
37714: LD_ADDR_VAR 0 51
37718: PUSH
37719: LD_INT 1
37721: NEG
37722: PUSH
37723: LD_INT 2
37725: PUSH
37726: EMPTY
37727: LIST
37728: LIST
37729: PUSH
37730: LD_INT 2
37732: NEG
37733: PUSH
37734: LD_INT 1
37736: PUSH
37737: EMPTY
37738: LIST
37739: LIST
37740: PUSH
37741: EMPTY
37742: LIST
37743: LIST
37744: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
37745: LD_ADDR_VAR 0 52
37749: PUSH
37750: LD_INT 3
37752: NEG
37753: PUSH
37754: LD_INT 1
37756: NEG
37757: PUSH
37758: EMPTY
37759: LIST
37760: LIST
37761: PUSH
37762: LD_INT 3
37764: NEG
37765: PUSH
37766: LD_INT 2
37768: NEG
37769: PUSH
37770: EMPTY
37771: LIST
37772: LIST
37773: PUSH
37774: EMPTY
37775: LIST
37776: LIST
37777: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
37778: LD_ADDR_VAR 0 53
37782: PUSH
37783: LD_INT 1
37785: NEG
37786: PUSH
37787: LD_INT 3
37789: NEG
37790: PUSH
37791: EMPTY
37792: LIST
37793: LIST
37794: PUSH
37795: LD_INT 0
37797: PUSH
37798: LD_INT 3
37800: NEG
37801: PUSH
37802: EMPTY
37803: LIST
37804: LIST
37805: PUSH
37806: LD_INT 1
37808: PUSH
37809: LD_INT 2
37811: NEG
37812: PUSH
37813: EMPTY
37814: LIST
37815: LIST
37816: PUSH
37817: EMPTY
37818: LIST
37819: LIST
37820: LIST
37821: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
37822: LD_ADDR_VAR 0 54
37826: PUSH
37827: LD_INT 2
37829: PUSH
37830: LD_INT 1
37832: NEG
37833: PUSH
37834: EMPTY
37835: LIST
37836: LIST
37837: PUSH
37838: LD_INT 3
37840: PUSH
37841: LD_INT 0
37843: PUSH
37844: EMPTY
37845: LIST
37846: LIST
37847: PUSH
37848: LD_INT 3
37850: PUSH
37851: LD_INT 1
37853: PUSH
37854: EMPTY
37855: LIST
37856: LIST
37857: PUSH
37858: EMPTY
37859: LIST
37860: LIST
37861: LIST
37862: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
37863: LD_ADDR_VAR 0 55
37867: PUSH
37868: LD_INT 3
37870: PUSH
37871: LD_INT 2
37873: PUSH
37874: EMPTY
37875: LIST
37876: LIST
37877: PUSH
37878: LD_INT 3
37880: PUSH
37881: LD_INT 3
37883: PUSH
37884: EMPTY
37885: LIST
37886: LIST
37887: PUSH
37888: LD_INT 2
37890: PUSH
37891: LD_INT 3
37893: PUSH
37894: EMPTY
37895: LIST
37896: LIST
37897: PUSH
37898: EMPTY
37899: LIST
37900: LIST
37901: LIST
37902: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37903: LD_ADDR_VAR 0 56
37907: PUSH
37908: LD_INT 1
37910: PUSH
37911: LD_INT 3
37913: PUSH
37914: EMPTY
37915: LIST
37916: LIST
37917: PUSH
37918: LD_INT 0
37920: PUSH
37921: LD_INT 3
37923: PUSH
37924: EMPTY
37925: LIST
37926: LIST
37927: PUSH
37928: LD_INT 1
37930: NEG
37931: PUSH
37932: LD_INT 2
37934: PUSH
37935: EMPTY
37936: LIST
37937: LIST
37938: PUSH
37939: EMPTY
37940: LIST
37941: LIST
37942: LIST
37943: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37944: LD_ADDR_VAR 0 57
37948: PUSH
37949: LD_INT 2
37951: NEG
37952: PUSH
37953: LD_INT 1
37955: PUSH
37956: EMPTY
37957: LIST
37958: LIST
37959: PUSH
37960: LD_INT 3
37962: NEG
37963: PUSH
37964: LD_INT 0
37966: PUSH
37967: EMPTY
37968: LIST
37969: LIST
37970: PUSH
37971: LD_INT 3
37973: NEG
37974: PUSH
37975: LD_INT 1
37977: NEG
37978: PUSH
37979: EMPTY
37980: LIST
37981: LIST
37982: PUSH
37983: EMPTY
37984: LIST
37985: LIST
37986: LIST
37987: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37988: LD_ADDR_VAR 0 58
37992: PUSH
37993: LD_INT 2
37995: NEG
37996: PUSH
37997: LD_INT 3
37999: NEG
38000: PUSH
38001: EMPTY
38002: LIST
38003: LIST
38004: PUSH
38005: LD_INT 3
38007: NEG
38008: PUSH
38009: LD_INT 2
38011: NEG
38012: PUSH
38013: EMPTY
38014: LIST
38015: LIST
38016: PUSH
38017: LD_INT 3
38019: NEG
38020: PUSH
38021: LD_INT 3
38023: NEG
38024: PUSH
38025: EMPTY
38026: LIST
38027: LIST
38028: PUSH
38029: EMPTY
38030: LIST
38031: LIST
38032: LIST
38033: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
38034: LD_ADDR_VAR 0 59
38038: PUSH
38039: LD_INT 1
38041: NEG
38042: PUSH
38043: LD_INT 2
38045: NEG
38046: PUSH
38047: EMPTY
38048: LIST
38049: LIST
38050: PUSH
38051: LD_INT 0
38053: PUSH
38054: LD_INT 2
38056: NEG
38057: PUSH
38058: EMPTY
38059: LIST
38060: LIST
38061: PUSH
38062: LD_INT 1
38064: PUSH
38065: LD_INT 1
38067: NEG
38068: PUSH
38069: EMPTY
38070: LIST
38071: LIST
38072: PUSH
38073: EMPTY
38074: LIST
38075: LIST
38076: LIST
38077: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
38078: LD_ADDR_VAR 0 60
38082: PUSH
38083: LD_INT 1
38085: PUSH
38086: LD_INT 1
38088: NEG
38089: PUSH
38090: EMPTY
38091: LIST
38092: LIST
38093: PUSH
38094: LD_INT 2
38096: PUSH
38097: LD_INT 0
38099: PUSH
38100: EMPTY
38101: LIST
38102: LIST
38103: PUSH
38104: LD_INT 2
38106: PUSH
38107: LD_INT 1
38109: PUSH
38110: EMPTY
38111: LIST
38112: LIST
38113: PUSH
38114: EMPTY
38115: LIST
38116: LIST
38117: LIST
38118: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38119: LD_ADDR_VAR 0 61
38123: PUSH
38124: LD_INT 2
38126: PUSH
38127: LD_INT 1
38129: PUSH
38130: EMPTY
38131: LIST
38132: LIST
38133: PUSH
38134: LD_INT 2
38136: PUSH
38137: LD_INT 2
38139: PUSH
38140: EMPTY
38141: LIST
38142: LIST
38143: PUSH
38144: LD_INT 1
38146: PUSH
38147: LD_INT 2
38149: PUSH
38150: EMPTY
38151: LIST
38152: LIST
38153: PUSH
38154: EMPTY
38155: LIST
38156: LIST
38157: LIST
38158: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38159: LD_ADDR_VAR 0 62
38163: PUSH
38164: LD_INT 1
38166: PUSH
38167: LD_INT 2
38169: PUSH
38170: EMPTY
38171: LIST
38172: LIST
38173: PUSH
38174: LD_INT 0
38176: PUSH
38177: LD_INT 2
38179: PUSH
38180: EMPTY
38181: LIST
38182: LIST
38183: PUSH
38184: LD_INT 1
38186: NEG
38187: PUSH
38188: LD_INT 1
38190: PUSH
38191: EMPTY
38192: LIST
38193: LIST
38194: PUSH
38195: EMPTY
38196: LIST
38197: LIST
38198: LIST
38199: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38200: LD_ADDR_VAR 0 63
38204: PUSH
38205: LD_INT 1
38207: NEG
38208: PUSH
38209: LD_INT 1
38211: PUSH
38212: EMPTY
38213: LIST
38214: LIST
38215: PUSH
38216: LD_INT 2
38218: NEG
38219: PUSH
38220: LD_INT 0
38222: PUSH
38223: EMPTY
38224: LIST
38225: LIST
38226: PUSH
38227: LD_INT 2
38229: NEG
38230: PUSH
38231: LD_INT 1
38233: NEG
38234: PUSH
38235: EMPTY
38236: LIST
38237: LIST
38238: PUSH
38239: EMPTY
38240: LIST
38241: LIST
38242: LIST
38243: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38244: LD_ADDR_VAR 0 64
38248: PUSH
38249: LD_INT 1
38251: NEG
38252: PUSH
38253: LD_INT 2
38255: NEG
38256: PUSH
38257: EMPTY
38258: LIST
38259: LIST
38260: PUSH
38261: LD_INT 2
38263: NEG
38264: PUSH
38265: LD_INT 1
38267: NEG
38268: PUSH
38269: EMPTY
38270: LIST
38271: LIST
38272: PUSH
38273: LD_INT 2
38275: NEG
38276: PUSH
38277: LD_INT 2
38279: NEG
38280: PUSH
38281: EMPTY
38282: LIST
38283: LIST
38284: PUSH
38285: EMPTY
38286: LIST
38287: LIST
38288: LIST
38289: ST_TO_ADDR
// end ; 2 :
38290: GO 41556
38292: LD_INT 2
38294: DOUBLE
38295: EQUAL
38296: IFTRUE 38300
38298: GO 41555
38300: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
38301: LD_ADDR_VAR 0 29
38305: PUSH
38306: LD_INT 4
38308: PUSH
38309: LD_INT 0
38311: PUSH
38312: EMPTY
38313: LIST
38314: LIST
38315: PUSH
38316: LD_INT 4
38318: PUSH
38319: LD_INT 1
38321: NEG
38322: PUSH
38323: EMPTY
38324: LIST
38325: LIST
38326: PUSH
38327: LD_INT 5
38329: PUSH
38330: LD_INT 0
38332: PUSH
38333: EMPTY
38334: LIST
38335: LIST
38336: PUSH
38337: LD_INT 5
38339: PUSH
38340: LD_INT 1
38342: PUSH
38343: EMPTY
38344: LIST
38345: LIST
38346: PUSH
38347: LD_INT 4
38349: PUSH
38350: LD_INT 1
38352: PUSH
38353: EMPTY
38354: LIST
38355: LIST
38356: PUSH
38357: LD_INT 3
38359: PUSH
38360: LD_INT 0
38362: PUSH
38363: EMPTY
38364: LIST
38365: LIST
38366: PUSH
38367: LD_INT 3
38369: PUSH
38370: LD_INT 1
38372: NEG
38373: PUSH
38374: EMPTY
38375: LIST
38376: LIST
38377: PUSH
38378: LD_INT 3
38380: PUSH
38381: LD_INT 2
38383: NEG
38384: PUSH
38385: EMPTY
38386: LIST
38387: LIST
38388: PUSH
38389: LD_INT 5
38391: PUSH
38392: LD_INT 2
38394: PUSH
38395: EMPTY
38396: LIST
38397: LIST
38398: PUSH
38399: LD_INT 3
38401: PUSH
38402: LD_INT 3
38404: PUSH
38405: EMPTY
38406: LIST
38407: LIST
38408: PUSH
38409: LD_INT 3
38411: PUSH
38412: LD_INT 2
38414: PUSH
38415: EMPTY
38416: LIST
38417: LIST
38418: PUSH
38419: LD_INT 4
38421: PUSH
38422: LD_INT 3
38424: PUSH
38425: EMPTY
38426: LIST
38427: LIST
38428: PUSH
38429: LD_INT 4
38431: PUSH
38432: LD_INT 4
38434: PUSH
38435: EMPTY
38436: LIST
38437: LIST
38438: PUSH
38439: LD_INT 3
38441: PUSH
38442: LD_INT 4
38444: PUSH
38445: EMPTY
38446: LIST
38447: LIST
38448: PUSH
38449: LD_INT 2
38451: PUSH
38452: LD_INT 3
38454: PUSH
38455: EMPTY
38456: LIST
38457: LIST
38458: PUSH
38459: LD_INT 2
38461: PUSH
38462: LD_INT 2
38464: PUSH
38465: EMPTY
38466: LIST
38467: LIST
38468: PUSH
38469: LD_INT 4
38471: PUSH
38472: LD_INT 2
38474: PUSH
38475: EMPTY
38476: LIST
38477: LIST
38478: PUSH
38479: LD_INT 2
38481: PUSH
38482: LD_INT 4
38484: PUSH
38485: EMPTY
38486: LIST
38487: LIST
38488: PUSH
38489: LD_INT 0
38491: PUSH
38492: LD_INT 4
38494: PUSH
38495: EMPTY
38496: LIST
38497: LIST
38498: PUSH
38499: LD_INT 0
38501: PUSH
38502: LD_INT 3
38504: PUSH
38505: EMPTY
38506: LIST
38507: LIST
38508: PUSH
38509: LD_INT 1
38511: PUSH
38512: LD_INT 4
38514: PUSH
38515: EMPTY
38516: LIST
38517: LIST
38518: PUSH
38519: LD_INT 1
38521: PUSH
38522: LD_INT 5
38524: PUSH
38525: EMPTY
38526: LIST
38527: LIST
38528: PUSH
38529: LD_INT 0
38531: PUSH
38532: LD_INT 5
38534: PUSH
38535: EMPTY
38536: LIST
38537: LIST
38538: PUSH
38539: LD_INT 1
38541: NEG
38542: PUSH
38543: LD_INT 4
38545: PUSH
38546: EMPTY
38547: LIST
38548: LIST
38549: PUSH
38550: LD_INT 1
38552: NEG
38553: PUSH
38554: LD_INT 3
38556: PUSH
38557: EMPTY
38558: LIST
38559: LIST
38560: PUSH
38561: LD_INT 2
38563: PUSH
38564: LD_INT 5
38566: PUSH
38567: EMPTY
38568: LIST
38569: LIST
38570: PUSH
38571: LD_INT 2
38573: NEG
38574: PUSH
38575: LD_INT 3
38577: PUSH
38578: EMPTY
38579: LIST
38580: LIST
38581: PUSH
38582: LD_INT 3
38584: NEG
38585: PUSH
38586: LD_INT 0
38588: PUSH
38589: EMPTY
38590: LIST
38591: LIST
38592: PUSH
38593: LD_INT 3
38595: NEG
38596: PUSH
38597: LD_INT 1
38599: NEG
38600: PUSH
38601: EMPTY
38602: LIST
38603: LIST
38604: PUSH
38605: LD_INT 2
38607: NEG
38608: PUSH
38609: LD_INT 0
38611: PUSH
38612: EMPTY
38613: LIST
38614: LIST
38615: PUSH
38616: LD_INT 2
38618: NEG
38619: PUSH
38620: LD_INT 1
38622: PUSH
38623: EMPTY
38624: LIST
38625: LIST
38626: PUSH
38627: LD_INT 3
38629: NEG
38630: PUSH
38631: LD_INT 1
38633: PUSH
38634: EMPTY
38635: LIST
38636: LIST
38637: PUSH
38638: LD_INT 4
38640: NEG
38641: PUSH
38642: LD_INT 0
38644: PUSH
38645: EMPTY
38646: LIST
38647: LIST
38648: PUSH
38649: LD_INT 4
38651: NEG
38652: PUSH
38653: LD_INT 1
38655: NEG
38656: PUSH
38657: EMPTY
38658: LIST
38659: LIST
38660: PUSH
38661: LD_INT 4
38663: NEG
38664: PUSH
38665: LD_INT 2
38667: NEG
38668: PUSH
38669: EMPTY
38670: LIST
38671: LIST
38672: PUSH
38673: LD_INT 2
38675: NEG
38676: PUSH
38677: LD_INT 2
38679: PUSH
38680: EMPTY
38681: LIST
38682: LIST
38683: PUSH
38684: LD_INT 4
38686: NEG
38687: PUSH
38688: LD_INT 4
38690: NEG
38691: PUSH
38692: EMPTY
38693: LIST
38694: LIST
38695: PUSH
38696: LD_INT 4
38698: NEG
38699: PUSH
38700: LD_INT 5
38702: NEG
38703: PUSH
38704: EMPTY
38705: LIST
38706: LIST
38707: PUSH
38708: LD_INT 3
38710: NEG
38711: PUSH
38712: LD_INT 4
38714: NEG
38715: PUSH
38716: EMPTY
38717: LIST
38718: LIST
38719: PUSH
38720: LD_INT 3
38722: NEG
38723: PUSH
38724: LD_INT 3
38726: NEG
38727: PUSH
38728: EMPTY
38729: LIST
38730: LIST
38731: PUSH
38732: LD_INT 4
38734: NEG
38735: PUSH
38736: LD_INT 3
38738: NEG
38739: PUSH
38740: EMPTY
38741: LIST
38742: LIST
38743: PUSH
38744: LD_INT 5
38746: NEG
38747: PUSH
38748: LD_INT 4
38750: NEG
38751: PUSH
38752: EMPTY
38753: LIST
38754: LIST
38755: PUSH
38756: LD_INT 5
38758: NEG
38759: PUSH
38760: LD_INT 5
38762: NEG
38763: PUSH
38764: EMPTY
38765: LIST
38766: LIST
38767: PUSH
38768: LD_INT 3
38770: NEG
38771: PUSH
38772: LD_INT 5
38774: NEG
38775: PUSH
38776: EMPTY
38777: LIST
38778: LIST
38779: PUSH
38780: LD_INT 5
38782: NEG
38783: PUSH
38784: LD_INT 3
38786: NEG
38787: PUSH
38788: EMPTY
38789: LIST
38790: LIST
38791: PUSH
38792: EMPTY
38793: LIST
38794: LIST
38795: LIST
38796: LIST
38797: LIST
38798: LIST
38799: LIST
38800: LIST
38801: LIST
38802: LIST
38803: LIST
38804: LIST
38805: LIST
38806: LIST
38807: LIST
38808: LIST
38809: LIST
38810: LIST
38811: LIST
38812: LIST
38813: LIST
38814: LIST
38815: LIST
38816: LIST
38817: LIST
38818: LIST
38819: LIST
38820: LIST
38821: LIST
38822: LIST
38823: LIST
38824: LIST
38825: LIST
38826: LIST
38827: LIST
38828: LIST
38829: LIST
38830: LIST
38831: LIST
38832: LIST
38833: LIST
38834: LIST
38835: LIST
38836: LIST
38837: LIST
38838: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
38839: LD_ADDR_VAR 0 30
38843: PUSH
38844: LD_INT 4
38846: PUSH
38847: LD_INT 4
38849: PUSH
38850: EMPTY
38851: LIST
38852: LIST
38853: PUSH
38854: LD_INT 4
38856: PUSH
38857: LD_INT 3
38859: PUSH
38860: EMPTY
38861: LIST
38862: LIST
38863: PUSH
38864: LD_INT 5
38866: PUSH
38867: LD_INT 4
38869: PUSH
38870: EMPTY
38871: LIST
38872: LIST
38873: PUSH
38874: LD_INT 5
38876: PUSH
38877: LD_INT 5
38879: PUSH
38880: EMPTY
38881: LIST
38882: LIST
38883: PUSH
38884: LD_INT 4
38886: PUSH
38887: LD_INT 5
38889: PUSH
38890: EMPTY
38891: LIST
38892: LIST
38893: PUSH
38894: LD_INT 3
38896: PUSH
38897: LD_INT 4
38899: PUSH
38900: EMPTY
38901: LIST
38902: LIST
38903: PUSH
38904: LD_INT 3
38906: PUSH
38907: LD_INT 3
38909: PUSH
38910: EMPTY
38911: LIST
38912: LIST
38913: PUSH
38914: LD_INT 5
38916: PUSH
38917: LD_INT 3
38919: PUSH
38920: EMPTY
38921: LIST
38922: LIST
38923: PUSH
38924: LD_INT 3
38926: PUSH
38927: LD_INT 5
38929: PUSH
38930: EMPTY
38931: LIST
38932: LIST
38933: PUSH
38934: LD_INT 0
38936: PUSH
38937: LD_INT 3
38939: PUSH
38940: EMPTY
38941: LIST
38942: LIST
38943: PUSH
38944: LD_INT 0
38946: PUSH
38947: LD_INT 2
38949: PUSH
38950: EMPTY
38951: LIST
38952: LIST
38953: PUSH
38954: LD_INT 1
38956: PUSH
38957: LD_INT 3
38959: PUSH
38960: EMPTY
38961: LIST
38962: LIST
38963: PUSH
38964: LD_INT 1
38966: PUSH
38967: LD_INT 4
38969: PUSH
38970: EMPTY
38971: LIST
38972: LIST
38973: PUSH
38974: LD_INT 0
38976: PUSH
38977: LD_INT 4
38979: PUSH
38980: EMPTY
38981: LIST
38982: LIST
38983: PUSH
38984: LD_INT 1
38986: NEG
38987: PUSH
38988: LD_INT 3
38990: PUSH
38991: EMPTY
38992: LIST
38993: LIST
38994: PUSH
38995: LD_INT 1
38997: NEG
38998: PUSH
38999: LD_INT 2
39001: PUSH
39002: EMPTY
39003: LIST
39004: LIST
39005: PUSH
39006: LD_INT 2
39008: PUSH
39009: LD_INT 4
39011: PUSH
39012: EMPTY
39013: LIST
39014: LIST
39015: PUSH
39016: LD_INT 2
39018: NEG
39019: PUSH
39020: LD_INT 2
39022: PUSH
39023: EMPTY
39024: LIST
39025: LIST
39026: PUSH
39027: LD_INT 4
39029: NEG
39030: PUSH
39031: LD_INT 0
39033: PUSH
39034: EMPTY
39035: LIST
39036: LIST
39037: PUSH
39038: LD_INT 4
39040: NEG
39041: PUSH
39042: LD_INT 1
39044: NEG
39045: PUSH
39046: EMPTY
39047: LIST
39048: LIST
39049: PUSH
39050: LD_INT 3
39052: NEG
39053: PUSH
39054: LD_INT 0
39056: PUSH
39057: EMPTY
39058: LIST
39059: LIST
39060: PUSH
39061: LD_INT 3
39063: NEG
39064: PUSH
39065: LD_INT 1
39067: PUSH
39068: EMPTY
39069: LIST
39070: LIST
39071: PUSH
39072: LD_INT 4
39074: NEG
39075: PUSH
39076: LD_INT 1
39078: PUSH
39079: EMPTY
39080: LIST
39081: LIST
39082: PUSH
39083: LD_INT 5
39085: NEG
39086: PUSH
39087: LD_INT 0
39089: PUSH
39090: EMPTY
39091: LIST
39092: LIST
39093: PUSH
39094: LD_INT 5
39096: NEG
39097: PUSH
39098: LD_INT 1
39100: NEG
39101: PUSH
39102: EMPTY
39103: LIST
39104: LIST
39105: PUSH
39106: LD_INT 5
39108: NEG
39109: PUSH
39110: LD_INT 2
39112: NEG
39113: PUSH
39114: EMPTY
39115: LIST
39116: LIST
39117: PUSH
39118: LD_INT 3
39120: NEG
39121: PUSH
39122: LD_INT 2
39124: PUSH
39125: EMPTY
39126: LIST
39127: LIST
39128: PUSH
39129: LD_INT 3
39131: NEG
39132: PUSH
39133: LD_INT 3
39135: NEG
39136: PUSH
39137: EMPTY
39138: LIST
39139: LIST
39140: PUSH
39141: LD_INT 3
39143: NEG
39144: PUSH
39145: LD_INT 4
39147: NEG
39148: PUSH
39149: EMPTY
39150: LIST
39151: LIST
39152: PUSH
39153: LD_INT 2
39155: NEG
39156: PUSH
39157: LD_INT 3
39159: NEG
39160: PUSH
39161: EMPTY
39162: LIST
39163: LIST
39164: PUSH
39165: LD_INT 2
39167: NEG
39168: PUSH
39169: LD_INT 2
39171: NEG
39172: PUSH
39173: EMPTY
39174: LIST
39175: LIST
39176: PUSH
39177: LD_INT 3
39179: NEG
39180: PUSH
39181: LD_INT 2
39183: NEG
39184: PUSH
39185: EMPTY
39186: LIST
39187: LIST
39188: PUSH
39189: LD_INT 4
39191: NEG
39192: PUSH
39193: LD_INT 3
39195: NEG
39196: PUSH
39197: EMPTY
39198: LIST
39199: LIST
39200: PUSH
39201: LD_INT 4
39203: NEG
39204: PUSH
39205: LD_INT 4
39207: NEG
39208: PUSH
39209: EMPTY
39210: LIST
39211: LIST
39212: PUSH
39213: LD_INT 2
39215: NEG
39216: PUSH
39217: LD_INT 4
39219: NEG
39220: PUSH
39221: EMPTY
39222: LIST
39223: LIST
39224: PUSH
39225: LD_INT 4
39227: NEG
39228: PUSH
39229: LD_INT 2
39231: NEG
39232: PUSH
39233: EMPTY
39234: LIST
39235: LIST
39236: PUSH
39237: LD_INT 0
39239: PUSH
39240: LD_INT 4
39242: NEG
39243: PUSH
39244: EMPTY
39245: LIST
39246: LIST
39247: PUSH
39248: LD_INT 0
39250: PUSH
39251: LD_INT 5
39253: NEG
39254: PUSH
39255: EMPTY
39256: LIST
39257: LIST
39258: PUSH
39259: LD_INT 1
39261: PUSH
39262: LD_INT 4
39264: NEG
39265: PUSH
39266: EMPTY
39267: LIST
39268: LIST
39269: PUSH
39270: LD_INT 1
39272: PUSH
39273: LD_INT 3
39275: NEG
39276: PUSH
39277: EMPTY
39278: LIST
39279: LIST
39280: PUSH
39281: LD_INT 0
39283: PUSH
39284: LD_INT 3
39286: NEG
39287: PUSH
39288: EMPTY
39289: LIST
39290: LIST
39291: PUSH
39292: LD_INT 1
39294: NEG
39295: PUSH
39296: LD_INT 4
39298: NEG
39299: PUSH
39300: EMPTY
39301: LIST
39302: LIST
39303: PUSH
39304: LD_INT 1
39306: NEG
39307: PUSH
39308: LD_INT 5
39310: NEG
39311: PUSH
39312: EMPTY
39313: LIST
39314: LIST
39315: PUSH
39316: LD_INT 2
39318: PUSH
39319: LD_INT 3
39321: NEG
39322: PUSH
39323: EMPTY
39324: LIST
39325: LIST
39326: PUSH
39327: LD_INT 2
39329: NEG
39330: PUSH
39331: LD_INT 5
39333: NEG
39334: PUSH
39335: EMPTY
39336: LIST
39337: LIST
39338: PUSH
39339: EMPTY
39340: LIST
39341: LIST
39342: LIST
39343: LIST
39344: LIST
39345: LIST
39346: LIST
39347: LIST
39348: LIST
39349: LIST
39350: LIST
39351: LIST
39352: LIST
39353: LIST
39354: LIST
39355: LIST
39356: LIST
39357: LIST
39358: LIST
39359: LIST
39360: LIST
39361: LIST
39362: LIST
39363: LIST
39364: LIST
39365: LIST
39366: LIST
39367: LIST
39368: LIST
39369: LIST
39370: LIST
39371: LIST
39372: LIST
39373: LIST
39374: LIST
39375: LIST
39376: LIST
39377: LIST
39378: LIST
39379: LIST
39380: LIST
39381: LIST
39382: LIST
39383: LIST
39384: LIST
39385: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
39386: LD_ADDR_VAR 0 31
39390: PUSH
39391: LD_INT 0
39393: PUSH
39394: LD_INT 4
39396: PUSH
39397: EMPTY
39398: LIST
39399: LIST
39400: PUSH
39401: LD_INT 0
39403: PUSH
39404: LD_INT 3
39406: PUSH
39407: EMPTY
39408: LIST
39409: LIST
39410: PUSH
39411: LD_INT 1
39413: PUSH
39414: LD_INT 4
39416: PUSH
39417: EMPTY
39418: LIST
39419: LIST
39420: PUSH
39421: LD_INT 1
39423: PUSH
39424: LD_INT 5
39426: PUSH
39427: EMPTY
39428: LIST
39429: LIST
39430: PUSH
39431: LD_INT 0
39433: PUSH
39434: LD_INT 5
39436: PUSH
39437: EMPTY
39438: LIST
39439: LIST
39440: PUSH
39441: LD_INT 1
39443: NEG
39444: PUSH
39445: LD_INT 4
39447: PUSH
39448: EMPTY
39449: LIST
39450: LIST
39451: PUSH
39452: LD_INT 1
39454: NEG
39455: PUSH
39456: LD_INT 3
39458: PUSH
39459: EMPTY
39460: LIST
39461: LIST
39462: PUSH
39463: LD_INT 2
39465: PUSH
39466: LD_INT 5
39468: PUSH
39469: EMPTY
39470: LIST
39471: LIST
39472: PUSH
39473: LD_INT 2
39475: NEG
39476: PUSH
39477: LD_INT 3
39479: PUSH
39480: EMPTY
39481: LIST
39482: LIST
39483: PUSH
39484: LD_INT 3
39486: NEG
39487: PUSH
39488: LD_INT 0
39490: PUSH
39491: EMPTY
39492: LIST
39493: LIST
39494: PUSH
39495: LD_INT 3
39497: NEG
39498: PUSH
39499: LD_INT 1
39501: NEG
39502: PUSH
39503: EMPTY
39504: LIST
39505: LIST
39506: PUSH
39507: LD_INT 2
39509: NEG
39510: PUSH
39511: LD_INT 0
39513: PUSH
39514: EMPTY
39515: LIST
39516: LIST
39517: PUSH
39518: LD_INT 2
39520: NEG
39521: PUSH
39522: LD_INT 1
39524: PUSH
39525: EMPTY
39526: LIST
39527: LIST
39528: PUSH
39529: LD_INT 3
39531: NEG
39532: PUSH
39533: LD_INT 1
39535: PUSH
39536: EMPTY
39537: LIST
39538: LIST
39539: PUSH
39540: LD_INT 4
39542: NEG
39543: PUSH
39544: LD_INT 0
39546: PUSH
39547: EMPTY
39548: LIST
39549: LIST
39550: PUSH
39551: LD_INT 4
39553: NEG
39554: PUSH
39555: LD_INT 1
39557: NEG
39558: PUSH
39559: EMPTY
39560: LIST
39561: LIST
39562: PUSH
39563: LD_INT 4
39565: NEG
39566: PUSH
39567: LD_INT 2
39569: NEG
39570: PUSH
39571: EMPTY
39572: LIST
39573: LIST
39574: PUSH
39575: LD_INT 2
39577: NEG
39578: PUSH
39579: LD_INT 2
39581: PUSH
39582: EMPTY
39583: LIST
39584: LIST
39585: PUSH
39586: LD_INT 4
39588: NEG
39589: PUSH
39590: LD_INT 4
39592: NEG
39593: PUSH
39594: EMPTY
39595: LIST
39596: LIST
39597: PUSH
39598: LD_INT 4
39600: NEG
39601: PUSH
39602: LD_INT 5
39604: NEG
39605: PUSH
39606: EMPTY
39607: LIST
39608: LIST
39609: PUSH
39610: LD_INT 3
39612: NEG
39613: PUSH
39614: LD_INT 4
39616: NEG
39617: PUSH
39618: EMPTY
39619: LIST
39620: LIST
39621: PUSH
39622: LD_INT 3
39624: NEG
39625: PUSH
39626: LD_INT 3
39628: NEG
39629: PUSH
39630: EMPTY
39631: LIST
39632: LIST
39633: PUSH
39634: LD_INT 4
39636: NEG
39637: PUSH
39638: LD_INT 3
39640: NEG
39641: PUSH
39642: EMPTY
39643: LIST
39644: LIST
39645: PUSH
39646: LD_INT 5
39648: NEG
39649: PUSH
39650: LD_INT 4
39652: NEG
39653: PUSH
39654: EMPTY
39655: LIST
39656: LIST
39657: PUSH
39658: LD_INT 5
39660: NEG
39661: PUSH
39662: LD_INT 5
39664: NEG
39665: PUSH
39666: EMPTY
39667: LIST
39668: LIST
39669: PUSH
39670: LD_INT 3
39672: NEG
39673: PUSH
39674: LD_INT 5
39676: NEG
39677: PUSH
39678: EMPTY
39679: LIST
39680: LIST
39681: PUSH
39682: LD_INT 5
39684: NEG
39685: PUSH
39686: LD_INT 3
39688: NEG
39689: PUSH
39690: EMPTY
39691: LIST
39692: LIST
39693: PUSH
39694: LD_INT 0
39696: PUSH
39697: LD_INT 3
39699: NEG
39700: PUSH
39701: EMPTY
39702: LIST
39703: LIST
39704: PUSH
39705: LD_INT 0
39707: PUSH
39708: LD_INT 4
39710: NEG
39711: PUSH
39712: EMPTY
39713: LIST
39714: LIST
39715: PUSH
39716: LD_INT 1
39718: PUSH
39719: LD_INT 3
39721: NEG
39722: PUSH
39723: EMPTY
39724: LIST
39725: LIST
39726: PUSH
39727: LD_INT 1
39729: PUSH
39730: LD_INT 2
39732: NEG
39733: PUSH
39734: EMPTY
39735: LIST
39736: LIST
39737: PUSH
39738: LD_INT 0
39740: PUSH
39741: LD_INT 2
39743: NEG
39744: PUSH
39745: EMPTY
39746: LIST
39747: LIST
39748: PUSH
39749: LD_INT 1
39751: NEG
39752: PUSH
39753: LD_INT 3
39755: NEG
39756: PUSH
39757: EMPTY
39758: LIST
39759: LIST
39760: PUSH
39761: LD_INT 1
39763: NEG
39764: PUSH
39765: LD_INT 4
39767: NEG
39768: PUSH
39769: EMPTY
39770: LIST
39771: LIST
39772: PUSH
39773: LD_INT 2
39775: PUSH
39776: LD_INT 2
39778: NEG
39779: PUSH
39780: EMPTY
39781: LIST
39782: LIST
39783: PUSH
39784: LD_INT 2
39786: NEG
39787: PUSH
39788: LD_INT 4
39790: NEG
39791: PUSH
39792: EMPTY
39793: LIST
39794: LIST
39795: PUSH
39796: LD_INT 4
39798: PUSH
39799: LD_INT 0
39801: PUSH
39802: EMPTY
39803: LIST
39804: LIST
39805: PUSH
39806: LD_INT 4
39808: PUSH
39809: LD_INT 1
39811: NEG
39812: PUSH
39813: EMPTY
39814: LIST
39815: LIST
39816: PUSH
39817: LD_INT 5
39819: PUSH
39820: LD_INT 0
39822: PUSH
39823: EMPTY
39824: LIST
39825: LIST
39826: PUSH
39827: LD_INT 5
39829: PUSH
39830: LD_INT 1
39832: PUSH
39833: EMPTY
39834: LIST
39835: LIST
39836: PUSH
39837: LD_INT 4
39839: PUSH
39840: LD_INT 1
39842: PUSH
39843: EMPTY
39844: LIST
39845: LIST
39846: PUSH
39847: LD_INT 3
39849: PUSH
39850: LD_INT 0
39852: PUSH
39853: EMPTY
39854: LIST
39855: LIST
39856: PUSH
39857: LD_INT 3
39859: PUSH
39860: LD_INT 1
39862: NEG
39863: PUSH
39864: EMPTY
39865: LIST
39866: LIST
39867: PUSH
39868: LD_INT 3
39870: PUSH
39871: LD_INT 2
39873: NEG
39874: PUSH
39875: EMPTY
39876: LIST
39877: LIST
39878: PUSH
39879: LD_INT 5
39881: PUSH
39882: LD_INT 2
39884: PUSH
39885: EMPTY
39886: LIST
39887: LIST
39888: PUSH
39889: EMPTY
39890: LIST
39891: LIST
39892: LIST
39893: LIST
39894: LIST
39895: LIST
39896: LIST
39897: LIST
39898: LIST
39899: LIST
39900: LIST
39901: LIST
39902: LIST
39903: LIST
39904: LIST
39905: LIST
39906: LIST
39907: LIST
39908: LIST
39909: LIST
39910: LIST
39911: LIST
39912: LIST
39913: LIST
39914: LIST
39915: LIST
39916: LIST
39917: LIST
39918: LIST
39919: LIST
39920: LIST
39921: LIST
39922: LIST
39923: LIST
39924: LIST
39925: LIST
39926: LIST
39927: LIST
39928: LIST
39929: LIST
39930: LIST
39931: LIST
39932: LIST
39933: LIST
39934: LIST
39935: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
39936: LD_ADDR_VAR 0 32
39940: PUSH
39941: LD_INT 4
39943: NEG
39944: PUSH
39945: LD_INT 0
39947: PUSH
39948: EMPTY
39949: LIST
39950: LIST
39951: PUSH
39952: LD_INT 4
39954: NEG
39955: PUSH
39956: LD_INT 1
39958: NEG
39959: PUSH
39960: EMPTY
39961: LIST
39962: LIST
39963: PUSH
39964: LD_INT 3
39966: NEG
39967: PUSH
39968: LD_INT 0
39970: PUSH
39971: EMPTY
39972: LIST
39973: LIST
39974: PUSH
39975: LD_INT 3
39977: NEG
39978: PUSH
39979: LD_INT 1
39981: PUSH
39982: EMPTY
39983: LIST
39984: LIST
39985: PUSH
39986: LD_INT 4
39988: NEG
39989: PUSH
39990: LD_INT 1
39992: PUSH
39993: EMPTY
39994: LIST
39995: LIST
39996: PUSH
39997: LD_INT 5
39999: NEG
40000: PUSH
40001: LD_INT 0
40003: PUSH
40004: EMPTY
40005: LIST
40006: LIST
40007: PUSH
40008: LD_INT 5
40010: NEG
40011: PUSH
40012: LD_INT 1
40014: NEG
40015: PUSH
40016: EMPTY
40017: LIST
40018: LIST
40019: PUSH
40020: LD_INT 5
40022: NEG
40023: PUSH
40024: LD_INT 2
40026: NEG
40027: PUSH
40028: EMPTY
40029: LIST
40030: LIST
40031: PUSH
40032: LD_INT 3
40034: NEG
40035: PUSH
40036: LD_INT 2
40038: PUSH
40039: EMPTY
40040: LIST
40041: LIST
40042: PUSH
40043: LD_INT 3
40045: NEG
40046: PUSH
40047: LD_INT 3
40049: NEG
40050: PUSH
40051: EMPTY
40052: LIST
40053: LIST
40054: PUSH
40055: LD_INT 3
40057: NEG
40058: PUSH
40059: LD_INT 4
40061: NEG
40062: PUSH
40063: EMPTY
40064: LIST
40065: LIST
40066: PUSH
40067: LD_INT 2
40069: NEG
40070: PUSH
40071: LD_INT 3
40073: NEG
40074: PUSH
40075: EMPTY
40076: LIST
40077: LIST
40078: PUSH
40079: LD_INT 2
40081: NEG
40082: PUSH
40083: LD_INT 2
40085: NEG
40086: PUSH
40087: EMPTY
40088: LIST
40089: LIST
40090: PUSH
40091: LD_INT 3
40093: NEG
40094: PUSH
40095: LD_INT 2
40097: NEG
40098: PUSH
40099: EMPTY
40100: LIST
40101: LIST
40102: PUSH
40103: LD_INT 4
40105: NEG
40106: PUSH
40107: LD_INT 3
40109: NEG
40110: PUSH
40111: EMPTY
40112: LIST
40113: LIST
40114: PUSH
40115: LD_INT 4
40117: NEG
40118: PUSH
40119: LD_INT 4
40121: NEG
40122: PUSH
40123: EMPTY
40124: LIST
40125: LIST
40126: PUSH
40127: LD_INT 2
40129: NEG
40130: PUSH
40131: LD_INT 4
40133: NEG
40134: PUSH
40135: EMPTY
40136: LIST
40137: LIST
40138: PUSH
40139: LD_INT 4
40141: NEG
40142: PUSH
40143: LD_INT 2
40145: NEG
40146: PUSH
40147: EMPTY
40148: LIST
40149: LIST
40150: PUSH
40151: LD_INT 0
40153: PUSH
40154: LD_INT 4
40156: NEG
40157: PUSH
40158: EMPTY
40159: LIST
40160: LIST
40161: PUSH
40162: LD_INT 0
40164: PUSH
40165: LD_INT 5
40167: NEG
40168: PUSH
40169: EMPTY
40170: LIST
40171: LIST
40172: PUSH
40173: LD_INT 1
40175: PUSH
40176: LD_INT 4
40178: NEG
40179: PUSH
40180: EMPTY
40181: LIST
40182: LIST
40183: PUSH
40184: LD_INT 1
40186: PUSH
40187: LD_INT 3
40189: NEG
40190: PUSH
40191: EMPTY
40192: LIST
40193: LIST
40194: PUSH
40195: LD_INT 0
40197: PUSH
40198: LD_INT 3
40200: NEG
40201: PUSH
40202: EMPTY
40203: LIST
40204: LIST
40205: PUSH
40206: LD_INT 1
40208: NEG
40209: PUSH
40210: LD_INT 4
40212: NEG
40213: PUSH
40214: EMPTY
40215: LIST
40216: LIST
40217: PUSH
40218: LD_INT 1
40220: NEG
40221: PUSH
40222: LD_INT 5
40224: NEG
40225: PUSH
40226: EMPTY
40227: LIST
40228: LIST
40229: PUSH
40230: LD_INT 2
40232: PUSH
40233: LD_INT 3
40235: NEG
40236: PUSH
40237: EMPTY
40238: LIST
40239: LIST
40240: PUSH
40241: LD_INT 2
40243: NEG
40244: PUSH
40245: LD_INT 5
40247: NEG
40248: PUSH
40249: EMPTY
40250: LIST
40251: LIST
40252: PUSH
40253: LD_INT 3
40255: PUSH
40256: LD_INT 0
40258: PUSH
40259: EMPTY
40260: LIST
40261: LIST
40262: PUSH
40263: LD_INT 3
40265: PUSH
40266: LD_INT 1
40268: NEG
40269: PUSH
40270: EMPTY
40271: LIST
40272: LIST
40273: PUSH
40274: LD_INT 4
40276: PUSH
40277: LD_INT 0
40279: PUSH
40280: EMPTY
40281: LIST
40282: LIST
40283: PUSH
40284: LD_INT 4
40286: PUSH
40287: LD_INT 1
40289: PUSH
40290: EMPTY
40291: LIST
40292: LIST
40293: PUSH
40294: LD_INT 3
40296: PUSH
40297: LD_INT 1
40299: PUSH
40300: EMPTY
40301: LIST
40302: LIST
40303: PUSH
40304: LD_INT 2
40306: PUSH
40307: LD_INT 0
40309: PUSH
40310: EMPTY
40311: LIST
40312: LIST
40313: PUSH
40314: LD_INT 2
40316: PUSH
40317: LD_INT 1
40319: NEG
40320: PUSH
40321: EMPTY
40322: LIST
40323: LIST
40324: PUSH
40325: LD_INT 2
40327: PUSH
40328: LD_INT 2
40330: NEG
40331: PUSH
40332: EMPTY
40333: LIST
40334: LIST
40335: PUSH
40336: LD_INT 4
40338: PUSH
40339: LD_INT 2
40341: PUSH
40342: EMPTY
40343: LIST
40344: LIST
40345: PUSH
40346: LD_INT 4
40348: PUSH
40349: LD_INT 4
40351: PUSH
40352: EMPTY
40353: LIST
40354: LIST
40355: PUSH
40356: LD_INT 4
40358: PUSH
40359: LD_INT 3
40361: PUSH
40362: EMPTY
40363: LIST
40364: LIST
40365: PUSH
40366: LD_INT 5
40368: PUSH
40369: LD_INT 4
40371: PUSH
40372: EMPTY
40373: LIST
40374: LIST
40375: PUSH
40376: LD_INT 5
40378: PUSH
40379: LD_INT 5
40381: PUSH
40382: EMPTY
40383: LIST
40384: LIST
40385: PUSH
40386: LD_INT 4
40388: PUSH
40389: LD_INT 5
40391: PUSH
40392: EMPTY
40393: LIST
40394: LIST
40395: PUSH
40396: LD_INT 3
40398: PUSH
40399: LD_INT 4
40401: PUSH
40402: EMPTY
40403: LIST
40404: LIST
40405: PUSH
40406: LD_INT 3
40408: PUSH
40409: LD_INT 3
40411: PUSH
40412: EMPTY
40413: LIST
40414: LIST
40415: PUSH
40416: LD_INT 5
40418: PUSH
40419: LD_INT 3
40421: PUSH
40422: EMPTY
40423: LIST
40424: LIST
40425: PUSH
40426: LD_INT 3
40428: PUSH
40429: LD_INT 5
40431: PUSH
40432: EMPTY
40433: LIST
40434: LIST
40435: PUSH
40436: EMPTY
40437: LIST
40438: LIST
40439: LIST
40440: LIST
40441: LIST
40442: LIST
40443: LIST
40444: LIST
40445: LIST
40446: LIST
40447: LIST
40448: LIST
40449: LIST
40450: LIST
40451: LIST
40452: LIST
40453: LIST
40454: LIST
40455: LIST
40456: LIST
40457: LIST
40458: LIST
40459: LIST
40460: LIST
40461: LIST
40462: LIST
40463: LIST
40464: LIST
40465: LIST
40466: LIST
40467: LIST
40468: LIST
40469: LIST
40470: LIST
40471: LIST
40472: LIST
40473: LIST
40474: LIST
40475: LIST
40476: LIST
40477: LIST
40478: LIST
40479: LIST
40480: LIST
40481: LIST
40482: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
40483: LD_ADDR_VAR 0 33
40487: PUSH
40488: LD_INT 4
40490: NEG
40491: PUSH
40492: LD_INT 4
40494: NEG
40495: PUSH
40496: EMPTY
40497: LIST
40498: LIST
40499: PUSH
40500: LD_INT 4
40502: NEG
40503: PUSH
40504: LD_INT 5
40506: NEG
40507: PUSH
40508: EMPTY
40509: LIST
40510: LIST
40511: PUSH
40512: LD_INT 3
40514: NEG
40515: PUSH
40516: LD_INT 4
40518: NEG
40519: PUSH
40520: EMPTY
40521: LIST
40522: LIST
40523: PUSH
40524: LD_INT 3
40526: NEG
40527: PUSH
40528: LD_INT 3
40530: NEG
40531: PUSH
40532: EMPTY
40533: LIST
40534: LIST
40535: PUSH
40536: LD_INT 4
40538: NEG
40539: PUSH
40540: LD_INT 3
40542: NEG
40543: PUSH
40544: EMPTY
40545: LIST
40546: LIST
40547: PUSH
40548: LD_INT 5
40550: NEG
40551: PUSH
40552: LD_INT 4
40554: NEG
40555: PUSH
40556: EMPTY
40557: LIST
40558: LIST
40559: PUSH
40560: LD_INT 5
40562: NEG
40563: PUSH
40564: LD_INT 5
40566: NEG
40567: PUSH
40568: EMPTY
40569: LIST
40570: LIST
40571: PUSH
40572: LD_INT 3
40574: NEG
40575: PUSH
40576: LD_INT 5
40578: NEG
40579: PUSH
40580: EMPTY
40581: LIST
40582: LIST
40583: PUSH
40584: LD_INT 5
40586: NEG
40587: PUSH
40588: LD_INT 3
40590: NEG
40591: PUSH
40592: EMPTY
40593: LIST
40594: LIST
40595: PUSH
40596: LD_INT 0
40598: PUSH
40599: LD_INT 3
40601: NEG
40602: PUSH
40603: EMPTY
40604: LIST
40605: LIST
40606: PUSH
40607: LD_INT 0
40609: PUSH
40610: LD_INT 4
40612: NEG
40613: PUSH
40614: EMPTY
40615: LIST
40616: LIST
40617: PUSH
40618: LD_INT 1
40620: PUSH
40621: LD_INT 3
40623: NEG
40624: PUSH
40625: EMPTY
40626: LIST
40627: LIST
40628: PUSH
40629: LD_INT 1
40631: PUSH
40632: LD_INT 2
40634: NEG
40635: PUSH
40636: EMPTY
40637: LIST
40638: LIST
40639: PUSH
40640: LD_INT 0
40642: PUSH
40643: LD_INT 2
40645: NEG
40646: PUSH
40647: EMPTY
40648: LIST
40649: LIST
40650: PUSH
40651: LD_INT 1
40653: NEG
40654: PUSH
40655: LD_INT 3
40657: NEG
40658: PUSH
40659: EMPTY
40660: LIST
40661: LIST
40662: PUSH
40663: LD_INT 1
40665: NEG
40666: PUSH
40667: LD_INT 4
40669: NEG
40670: PUSH
40671: EMPTY
40672: LIST
40673: LIST
40674: PUSH
40675: LD_INT 2
40677: PUSH
40678: LD_INT 2
40680: NEG
40681: PUSH
40682: EMPTY
40683: LIST
40684: LIST
40685: PUSH
40686: LD_INT 2
40688: NEG
40689: PUSH
40690: LD_INT 4
40692: NEG
40693: PUSH
40694: EMPTY
40695: LIST
40696: LIST
40697: PUSH
40698: LD_INT 4
40700: PUSH
40701: LD_INT 0
40703: PUSH
40704: EMPTY
40705: LIST
40706: LIST
40707: PUSH
40708: LD_INT 4
40710: PUSH
40711: LD_INT 1
40713: NEG
40714: PUSH
40715: EMPTY
40716: LIST
40717: LIST
40718: PUSH
40719: LD_INT 5
40721: PUSH
40722: LD_INT 0
40724: PUSH
40725: EMPTY
40726: LIST
40727: LIST
40728: PUSH
40729: LD_INT 5
40731: PUSH
40732: LD_INT 1
40734: PUSH
40735: EMPTY
40736: LIST
40737: LIST
40738: PUSH
40739: LD_INT 4
40741: PUSH
40742: LD_INT 1
40744: PUSH
40745: EMPTY
40746: LIST
40747: LIST
40748: PUSH
40749: LD_INT 3
40751: PUSH
40752: LD_INT 0
40754: PUSH
40755: EMPTY
40756: LIST
40757: LIST
40758: PUSH
40759: LD_INT 3
40761: PUSH
40762: LD_INT 1
40764: NEG
40765: PUSH
40766: EMPTY
40767: LIST
40768: LIST
40769: PUSH
40770: LD_INT 3
40772: PUSH
40773: LD_INT 2
40775: NEG
40776: PUSH
40777: EMPTY
40778: LIST
40779: LIST
40780: PUSH
40781: LD_INT 5
40783: PUSH
40784: LD_INT 2
40786: PUSH
40787: EMPTY
40788: LIST
40789: LIST
40790: PUSH
40791: LD_INT 3
40793: PUSH
40794: LD_INT 3
40796: PUSH
40797: EMPTY
40798: LIST
40799: LIST
40800: PUSH
40801: LD_INT 3
40803: PUSH
40804: LD_INT 2
40806: PUSH
40807: EMPTY
40808: LIST
40809: LIST
40810: PUSH
40811: LD_INT 4
40813: PUSH
40814: LD_INT 3
40816: PUSH
40817: EMPTY
40818: LIST
40819: LIST
40820: PUSH
40821: LD_INT 4
40823: PUSH
40824: LD_INT 4
40826: PUSH
40827: EMPTY
40828: LIST
40829: LIST
40830: PUSH
40831: LD_INT 3
40833: PUSH
40834: LD_INT 4
40836: PUSH
40837: EMPTY
40838: LIST
40839: LIST
40840: PUSH
40841: LD_INT 2
40843: PUSH
40844: LD_INT 3
40846: PUSH
40847: EMPTY
40848: LIST
40849: LIST
40850: PUSH
40851: LD_INT 2
40853: PUSH
40854: LD_INT 2
40856: PUSH
40857: EMPTY
40858: LIST
40859: LIST
40860: PUSH
40861: LD_INT 4
40863: PUSH
40864: LD_INT 2
40866: PUSH
40867: EMPTY
40868: LIST
40869: LIST
40870: PUSH
40871: LD_INT 2
40873: PUSH
40874: LD_INT 4
40876: PUSH
40877: EMPTY
40878: LIST
40879: LIST
40880: PUSH
40881: LD_INT 0
40883: PUSH
40884: LD_INT 4
40886: PUSH
40887: EMPTY
40888: LIST
40889: LIST
40890: PUSH
40891: LD_INT 0
40893: PUSH
40894: LD_INT 3
40896: PUSH
40897: EMPTY
40898: LIST
40899: LIST
40900: PUSH
40901: LD_INT 1
40903: PUSH
40904: LD_INT 4
40906: PUSH
40907: EMPTY
40908: LIST
40909: LIST
40910: PUSH
40911: LD_INT 1
40913: PUSH
40914: LD_INT 5
40916: PUSH
40917: EMPTY
40918: LIST
40919: LIST
40920: PUSH
40921: LD_INT 0
40923: PUSH
40924: LD_INT 5
40926: PUSH
40927: EMPTY
40928: LIST
40929: LIST
40930: PUSH
40931: LD_INT 1
40933: NEG
40934: PUSH
40935: LD_INT 4
40937: PUSH
40938: EMPTY
40939: LIST
40940: LIST
40941: PUSH
40942: LD_INT 1
40944: NEG
40945: PUSH
40946: LD_INT 3
40948: PUSH
40949: EMPTY
40950: LIST
40951: LIST
40952: PUSH
40953: LD_INT 2
40955: PUSH
40956: LD_INT 5
40958: PUSH
40959: EMPTY
40960: LIST
40961: LIST
40962: PUSH
40963: LD_INT 2
40965: NEG
40966: PUSH
40967: LD_INT 3
40969: PUSH
40970: EMPTY
40971: LIST
40972: LIST
40973: PUSH
40974: EMPTY
40975: LIST
40976: LIST
40977: LIST
40978: LIST
40979: LIST
40980: LIST
40981: LIST
40982: LIST
40983: LIST
40984: LIST
40985: LIST
40986: LIST
40987: LIST
40988: LIST
40989: LIST
40990: LIST
40991: LIST
40992: LIST
40993: LIST
40994: LIST
40995: LIST
40996: LIST
40997: LIST
40998: LIST
40999: LIST
41000: LIST
41001: LIST
41002: LIST
41003: LIST
41004: LIST
41005: LIST
41006: LIST
41007: LIST
41008: LIST
41009: LIST
41010: LIST
41011: LIST
41012: LIST
41013: LIST
41014: LIST
41015: LIST
41016: LIST
41017: LIST
41018: LIST
41019: LIST
41020: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
41021: LD_ADDR_VAR 0 34
41025: PUSH
41026: LD_INT 0
41028: PUSH
41029: LD_INT 4
41031: NEG
41032: PUSH
41033: EMPTY
41034: LIST
41035: LIST
41036: PUSH
41037: LD_INT 0
41039: PUSH
41040: LD_INT 5
41042: NEG
41043: PUSH
41044: EMPTY
41045: LIST
41046: LIST
41047: PUSH
41048: LD_INT 1
41050: PUSH
41051: LD_INT 4
41053: NEG
41054: PUSH
41055: EMPTY
41056: LIST
41057: LIST
41058: PUSH
41059: LD_INT 1
41061: PUSH
41062: LD_INT 3
41064: NEG
41065: PUSH
41066: EMPTY
41067: LIST
41068: LIST
41069: PUSH
41070: LD_INT 0
41072: PUSH
41073: LD_INT 3
41075: NEG
41076: PUSH
41077: EMPTY
41078: LIST
41079: LIST
41080: PUSH
41081: LD_INT 1
41083: NEG
41084: PUSH
41085: LD_INT 4
41087: NEG
41088: PUSH
41089: EMPTY
41090: LIST
41091: LIST
41092: PUSH
41093: LD_INT 1
41095: NEG
41096: PUSH
41097: LD_INT 5
41099: NEG
41100: PUSH
41101: EMPTY
41102: LIST
41103: LIST
41104: PUSH
41105: LD_INT 2
41107: PUSH
41108: LD_INT 3
41110: NEG
41111: PUSH
41112: EMPTY
41113: LIST
41114: LIST
41115: PUSH
41116: LD_INT 2
41118: NEG
41119: PUSH
41120: LD_INT 5
41122: NEG
41123: PUSH
41124: EMPTY
41125: LIST
41126: LIST
41127: PUSH
41128: LD_INT 3
41130: PUSH
41131: LD_INT 0
41133: PUSH
41134: EMPTY
41135: LIST
41136: LIST
41137: PUSH
41138: LD_INT 3
41140: PUSH
41141: LD_INT 1
41143: NEG
41144: PUSH
41145: EMPTY
41146: LIST
41147: LIST
41148: PUSH
41149: LD_INT 4
41151: PUSH
41152: LD_INT 0
41154: PUSH
41155: EMPTY
41156: LIST
41157: LIST
41158: PUSH
41159: LD_INT 4
41161: PUSH
41162: LD_INT 1
41164: PUSH
41165: EMPTY
41166: LIST
41167: LIST
41168: PUSH
41169: LD_INT 3
41171: PUSH
41172: LD_INT 1
41174: PUSH
41175: EMPTY
41176: LIST
41177: LIST
41178: PUSH
41179: LD_INT 2
41181: PUSH
41182: LD_INT 0
41184: PUSH
41185: EMPTY
41186: LIST
41187: LIST
41188: PUSH
41189: LD_INT 2
41191: PUSH
41192: LD_INT 1
41194: NEG
41195: PUSH
41196: EMPTY
41197: LIST
41198: LIST
41199: PUSH
41200: LD_INT 2
41202: PUSH
41203: LD_INT 2
41205: NEG
41206: PUSH
41207: EMPTY
41208: LIST
41209: LIST
41210: PUSH
41211: LD_INT 4
41213: PUSH
41214: LD_INT 2
41216: PUSH
41217: EMPTY
41218: LIST
41219: LIST
41220: PUSH
41221: LD_INT 4
41223: PUSH
41224: LD_INT 4
41226: PUSH
41227: EMPTY
41228: LIST
41229: LIST
41230: PUSH
41231: LD_INT 4
41233: PUSH
41234: LD_INT 3
41236: PUSH
41237: EMPTY
41238: LIST
41239: LIST
41240: PUSH
41241: LD_INT 5
41243: PUSH
41244: LD_INT 4
41246: PUSH
41247: EMPTY
41248: LIST
41249: LIST
41250: PUSH
41251: LD_INT 5
41253: PUSH
41254: LD_INT 5
41256: PUSH
41257: EMPTY
41258: LIST
41259: LIST
41260: PUSH
41261: LD_INT 4
41263: PUSH
41264: LD_INT 5
41266: PUSH
41267: EMPTY
41268: LIST
41269: LIST
41270: PUSH
41271: LD_INT 3
41273: PUSH
41274: LD_INT 4
41276: PUSH
41277: EMPTY
41278: LIST
41279: LIST
41280: PUSH
41281: LD_INT 3
41283: PUSH
41284: LD_INT 3
41286: PUSH
41287: EMPTY
41288: LIST
41289: LIST
41290: PUSH
41291: LD_INT 5
41293: PUSH
41294: LD_INT 3
41296: PUSH
41297: EMPTY
41298: LIST
41299: LIST
41300: PUSH
41301: LD_INT 3
41303: PUSH
41304: LD_INT 5
41306: PUSH
41307: EMPTY
41308: LIST
41309: LIST
41310: PUSH
41311: LD_INT 0
41313: PUSH
41314: LD_INT 3
41316: PUSH
41317: EMPTY
41318: LIST
41319: LIST
41320: PUSH
41321: LD_INT 0
41323: PUSH
41324: LD_INT 2
41326: PUSH
41327: EMPTY
41328: LIST
41329: LIST
41330: PUSH
41331: LD_INT 1
41333: PUSH
41334: LD_INT 3
41336: PUSH
41337: EMPTY
41338: LIST
41339: LIST
41340: PUSH
41341: LD_INT 1
41343: PUSH
41344: LD_INT 4
41346: PUSH
41347: EMPTY
41348: LIST
41349: LIST
41350: PUSH
41351: LD_INT 0
41353: PUSH
41354: LD_INT 4
41356: PUSH
41357: EMPTY
41358: LIST
41359: LIST
41360: PUSH
41361: LD_INT 1
41363: NEG
41364: PUSH
41365: LD_INT 3
41367: PUSH
41368: EMPTY
41369: LIST
41370: LIST
41371: PUSH
41372: LD_INT 1
41374: NEG
41375: PUSH
41376: LD_INT 2
41378: PUSH
41379: EMPTY
41380: LIST
41381: LIST
41382: PUSH
41383: LD_INT 2
41385: PUSH
41386: LD_INT 4
41388: PUSH
41389: EMPTY
41390: LIST
41391: LIST
41392: PUSH
41393: LD_INT 2
41395: NEG
41396: PUSH
41397: LD_INT 2
41399: PUSH
41400: EMPTY
41401: LIST
41402: LIST
41403: PUSH
41404: LD_INT 4
41406: NEG
41407: PUSH
41408: LD_INT 0
41410: PUSH
41411: EMPTY
41412: LIST
41413: LIST
41414: PUSH
41415: LD_INT 4
41417: NEG
41418: PUSH
41419: LD_INT 1
41421: NEG
41422: PUSH
41423: EMPTY
41424: LIST
41425: LIST
41426: PUSH
41427: LD_INT 3
41429: NEG
41430: PUSH
41431: LD_INT 0
41433: PUSH
41434: EMPTY
41435: LIST
41436: LIST
41437: PUSH
41438: LD_INT 3
41440: NEG
41441: PUSH
41442: LD_INT 1
41444: PUSH
41445: EMPTY
41446: LIST
41447: LIST
41448: PUSH
41449: LD_INT 4
41451: NEG
41452: PUSH
41453: LD_INT 1
41455: PUSH
41456: EMPTY
41457: LIST
41458: LIST
41459: PUSH
41460: LD_INT 5
41462: NEG
41463: PUSH
41464: LD_INT 0
41466: PUSH
41467: EMPTY
41468: LIST
41469: LIST
41470: PUSH
41471: LD_INT 5
41473: NEG
41474: PUSH
41475: LD_INT 1
41477: NEG
41478: PUSH
41479: EMPTY
41480: LIST
41481: LIST
41482: PUSH
41483: LD_INT 5
41485: NEG
41486: PUSH
41487: LD_INT 2
41489: NEG
41490: PUSH
41491: EMPTY
41492: LIST
41493: LIST
41494: PUSH
41495: LD_INT 3
41497: NEG
41498: PUSH
41499: LD_INT 2
41501: PUSH
41502: EMPTY
41503: LIST
41504: LIST
41505: PUSH
41506: EMPTY
41507: LIST
41508: LIST
41509: LIST
41510: LIST
41511: LIST
41512: LIST
41513: LIST
41514: LIST
41515: LIST
41516: LIST
41517: LIST
41518: LIST
41519: LIST
41520: LIST
41521: LIST
41522: LIST
41523: LIST
41524: LIST
41525: LIST
41526: LIST
41527: LIST
41528: LIST
41529: LIST
41530: LIST
41531: LIST
41532: LIST
41533: LIST
41534: LIST
41535: LIST
41536: LIST
41537: LIST
41538: LIST
41539: LIST
41540: LIST
41541: LIST
41542: LIST
41543: LIST
41544: LIST
41545: LIST
41546: LIST
41547: LIST
41548: LIST
41549: LIST
41550: LIST
41551: LIST
41552: ST_TO_ADDR
// end ; end ;
41553: GO 41556
41555: POP
// case btype of b_depot , b_warehouse :
41556: LD_VAR 0 1
41560: PUSH
41561: LD_INT 0
41563: DOUBLE
41564: EQUAL
41565: IFTRUE 41575
41567: LD_INT 1
41569: DOUBLE
41570: EQUAL
41571: IFTRUE 41575
41573: GO 41776
41575: POP
// case nation of nation_american :
41576: LD_VAR 0 5
41580: PUSH
41581: LD_INT 1
41583: DOUBLE
41584: EQUAL
41585: IFTRUE 41589
41587: GO 41645
41589: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
41590: LD_ADDR_VAR 0 9
41594: PUSH
41595: LD_VAR 0 11
41599: PUSH
41600: LD_VAR 0 12
41604: PUSH
41605: LD_VAR 0 13
41609: PUSH
41610: LD_VAR 0 14
41614: PUSH
41615: LD_VAR 0 15
41619: PUSH
41620: LD_VAR 0 16
41624: PUSH
41625: EMPTY
41626: LIST
41627: LIST
41628: LIST
41629: LIST
41630: LIST
41631: LIST
41632: PUSH
41633: LD_VAR 0 4
41637: PUSH
41638: LD_INT 1
41640: PLUS
41641: ARRAY
41642: ST_TO_ADDR
41643: GO 41774
41645: LD_INT 2
41647: DOUBLE
41648: EQUAL
41649: IFTRUE 41653
41651: GO 41709
41653: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
41654: LD_ADDR_VAR 0 9
41658: PUSH
41659: LD_VAR 0 17
41663: PUSH
41664: LD_VAR 0 18
41668: PUSH
41669: LD_VAR 0 19
41673: PUSH
41674: LD_VAR 0 20
41678: PUSH
41679: LD_VAR 0 21
41683: PUSH
41684: LD_VAR 0 22
41688: PUSH
41689: EMPTY
41690: LIST
41691: LIST
41692: LIST
41693: LIST
41694: LIST
41695: LIST
41696: PUSH
41697: LD_VAR 0 4
41701: PUSH
41702: LD_INT 1
41704: PLUS
41705: ARRAY
41706: ST_TO_ADDR
41707: GO 41774
41709: LD_INT 3
41711: DOUBLE
41712: EQUAL
41713: IFTRUE 41717
41715: GO 41773
41717: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
41718: LD_ADDR_VAR 0 9
41722: PUSH
41723: LD_VAR 0 23
41727: PUSH
41728: LD_VAR 0 24
41732: PUSH
41733: LD_VAR 0 25
41737: PUSH
41738: LD_VAR 0 26
41742: PUSH
41743: LD_VAR 0 27
41747: PUSH
41748: LD_VAR 0 28
41752: PUSH
41753: EMPTY
41754: LIST
41755: LIST
41756: LIST
41757: LIST
41758: LIST
41759: LIST
41760: PUSH
41761: LD_VAR 0 4
41765: PUSH
41766: LD_INT 1
41768: PLUS
41769: ARRAY
41770: ST_TO_ADDR
41771: GO 41774
41773: POP
41774: GO 42329
41776: LD_INT 2
41778: DOUBLE
41779: EQUAL
41780: IFTRUE 41790
41782: LD_INT 3
41784: DOUBLE
41785: EQUAL
41786: IFTRUE 41790
41788: GO 41846
41790: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
41791: LD_ADDR_VAR 0 9
41795: PUSH
41796: LD_VAR 0 29
41800: PUSH
41801: LD_VAR 0 30
41805: PUSH
41806: LD_VAR 0 31
41810: PUSH
41811: LD_VAR 0 32
41815: PUSH
41816: LD_VAR 0 33
41820: PUSH
41821: LD_VAR 0 34
41825: PUSH
41826: EMPTY
41827: LIST
41828: LIST
41829: LIST
41830: LIST
41831: LIST
41832: LIST
41833: PUSH
41834: LD_VAR 0 4
41838: PUSH
41839: LD_INT 1
41841: PLUS
41842: ARRAY
41843: ST_TO_ADDR
41844: GO 42329
41846: LD_INT 16
41848: DOUBLE
41849: EQUAL
41850: IFTRUE 41908
41852: LD_INT 17
41854: DOUBLE
41855: EQUAL
41856: IFTRUE 41908
41858: LD_INT 18
41860: DOUBLE
41861: EQUAL
41862: IFTRUE 41908
41864: LD_INT 19
41866: DOUBLE
41867: EQUAL
41868: IFTRUE 41908
41870: LD_INT 22
41872: DOUBLE
41873: EQUAL
41874: IFTRUE 41908
41876: LD_INT 20
41878: DOUBLE
41879: EQUAL
41880: IFTRUE 41908
41882: LD_INT 21
41884: DOUBLE
41885: EQUAL
41886: IFTRUE 41908
41888: LD_INT 23
41890: DOUBLE
41891: EQUAL
41892: IFTRUE 41908
41894: LD_INT 24
41896: DOUBLE
41897: EQUAL
41898: IFTRUE 41908
41900: LD_INT 25
41902: DOUBLE
41903: EQUAL
41904: IFTRUE 41908
41906: GO 41964
41908: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
41909: LD_ADDR_VAR 0 9
41913: PUSH
41914: LD_VAR 0 35
41918: PUSH
41919: LD_VAR 0 36
41923: PUSH
41924: LD_VAR 0 37
41928: PUSH
41929: LD_VAR 0 38
41933: PUSH
41934: LD_VAR 0 39
41938: PUSH
41939: LD_VAR 0 40
41943: PUSH
41944: EMPTY
41945: LIST
41946: LIST
41947: LIST
41948: LIST
41949: LIST
41950: LIST
41951: PUSH
41952: LD_VAR 0 4
41956: PUSH
41957: LD_INT 1
41959: PLUS
41960: ARRAY
41961: ST_TO_ADDR
41962: GO 42329
41964: LD_INT 6
41966: DOUBLE
41967: EQUAL
41968: IFTRUE 42020
41970: LD_INT 7
41972: DOUBLE
41973: EQUAL
41974: IFTRUE 42020
41976: LD_INT 8
41978: DOUBLE
41979: EQUAL
41980: IFTRUE 42020
41982: LD_INT 13
41984: DOUBLE
41985: EQUAL
41986: IFTRUE 42020
41988: LD_INT 12
41990: DOUBLE
41991: EQUAL
41992: IFTRUE 42020
41994: LD_INT 15
41996: DOUBLE
41997: EQUAL
41998: IFTRUE 42020
42000: LD_INT 11
42002: DOUBLE
42003: EQUAL
42004: IFTRUE 42020
42006: LD_INT 14
42008: DOUBLE
42009: EQUAL
42010: IFTRUE 42020
42012: LD_INT 10
42014: DOUBLE
42015: EQUAL
42016: IFTRUE 42020
42018: GO 42076
42020: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
42021: LD_ADDR_VAR 0 9
42025: PUSH
42026: LD_VAR 0 41
42030: PUSH
42031: LD_VAR 0 42
42035: PUSH
42036: LD_VAR 0 43
42040: PUSH
42041: LD_VAR 0 44
42045: PUSH
42046: LD_VAR 0 45
42050: PUSH
42051: LD_VAR 0 46
42055: PUSH
42056: EMPTY
42057: LIST
42058: LIST
42059: LIST
42060: LIST
42061: LIST
42062: LIST
42063: PUSH
42064: LD_VAR 0 4
42068: PUSH
42069: LD_INT 1
42071: PLUS
42072: ARRAY
42073: ST_TO_ADDR
42074: GO 42329
42076: LD_INT 36
42078: DOUBLE
42079: EQUAL
42080: IFTRUE 42084
42082: GO 42140
42084: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
42085: LD_ADDR_VAR 0 9
42089: PUSH
42090: LD_VAR 0 47
42094: PUSH
42095: LD_VAR 0 48
42099: PUSH
42100: LD_VAR 0 49
42104: PUSH
42105: LD_VAR 0 50
42109: PUSH
42110: LD_VAR 0 51
42114: PUSH
42115: LD_VAR 0 52
42119: PUSH
42120: EMPTY
42121: LIST
42122: LIST
42123: LIST
42124: LIST
42125: LIST
42126: LIST
42127: PUSH
42128: LD_VAR 0 4
42132: PUSH
42133: LD_INT 1
42135: PLUS
42136: ARRAY
42137: ST_TO_ADDR
42138: GO 42329
42140: LD_INT 4
42142: DOUBLE
42143: EQUAL
42144: IFTRUE 42166
42146: LD_INT 5
42148: DOUBLE
42149: EQUAL
42150: IFTRUE 42166
42152: LD_INT 34
42154: DOUBLE
42155: EQUAL
42156: IFTRUE 42166
42158: LD_INT 37
42160: DOUBLE
42161: EQUAL
42162: IFTRUE 42166
42164: GO 42222
42166: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
42167: LD_ADDR_VAR 0 9
42171: PUSH
42172: LD_VAR 0 53
42176: PUSH
42177: LD_VAR 0 54
42181: PUSH
42182: LD_VAR 0 55
42186: PUSH
42187: LD_VAR 0 56
42191: PUSH
42192: LD_VAR 0 57
42196: PUSH
42197: LD_VAR 0 58
42201: PUSH
42202: EMPTY
42203: LIST
42204: LIST
42205: LIST
42206: LIST
42207: LIST
42208: LIST
42209: PUSH
42210: LD_VAR 0 4
42214: PUSH
42215: LD_INT 1
42217: PLUS
42218: ARRAY
42219: ST_TO_ADDR
42220: GO 42329
42222: LD_INT 31
42224: DOUBLE
42225: EQUAL
42226: IFTRUE 42272
42228: LD_INT 32
42230: DOUBLE
42231: EQUAL
42232: IFTRUE 42272
42234: LD_INT 33
42236: DOUBLE
42237: EQUAL
42238: IFTRUE 42272
42240: LD_INT 27
42242: DOUBLE
42243: EQUAL
42244: IFTRUE 42272
42246: LD_INT 26
42248: DOUBLE
42249: EQUAL
42250: IFTRUE 42272
42252: LD_INT 28
42254: DOUBLE
42255: EQUAL
42256: IFTRUE 42272
42258: LD_INT 29
42260: DOUBLE
42261: EQUAL
42262: IFTRUE 42272
42264: LD_INT 30
42266: DOUBLE
42267: EQUAL
42268: IFTRUE 42272
42270: GO 42328
42272: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
42273: LD_ADDR_VAR 0 9
42277: PUSH
42278: LD_VAR 0 59
42282: PUSH
42283: LD_VAR 0 60
42287: PUSH
42288: LD_VAR 0 61
42292: PUSH
42293: LD_VAR 0 62
42297: PUSH
42298: LD_VAR 0 63
42302: PUSH
42303: LD_VAR 0 64
42307: PUSH
42308: EMPTY
42309: LIST
42310: LIST
42311: LIST
42312: LIST
42313: LIST
42314: LIST
42315: PUSH
42316: LD_VAR 0 4
42320: PUSH
42321: LD_INT 1
42323: PLUS
42324: ARRAY
42325: ST_TO_ADDR
42326: GO 42329
42328: POP
// temp_list2 = [ ] ;
42329: LD_ADDR_VAR 0 10
42333: PUSH
42334: EMPTY
42335: ST_TO_ADDR
// for i in temp_list do
42336: LD_ADDR_VAR 0 8
42340: PUSH
42341: LD_VAR 0 9
42345: PUSH
42346: FOR_IN
42347: IFFALSE 42399
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
42349: LD_ADDR_VAR 0 10
42353: PUSH
42354: LD_VAR 0 10
42358: PUSH
42359: LD_VAR 0 8
42363: PUSH
42364: LD_INT 1
42366: ARRAY
42367: PUSH
42368: LD_VAR 0 2
42372: PLUS
42373: PUSH
42374: LD_VAR 0 8
42378: PUSH
42379: LD_INT 2
42381: ARRAY
42382: PUSH
42383: LD_VAR 0 3
42387: PLUS
42388: PUSH
42389: EMPTY
42390: LIST
42391: LIST
42392: PUSH
42393: EMPTY
42394: LIST
42395: ADD
42396: ST_TO_ADDR
42397: GO 42346
42399: POP
42400: POP
// result = temp_list2 ;
42401: LD_ADDR_VAR 0 7
42405: PUSH
42406: LD_VAR 0 10
42410: ST_TO_ADDR
// end ;
42411: LD_VAR 0 7
42415: RET
// export function EnemyInRange ( unit , dist ) ; begin
42416: LD_INT 0
42418: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
42419: LD_ADDR_VAR 0 3
42423: PUSH
42424: LD_VAR 0 1
42428: PPUSH
42429: CALL_OW 255
42433: PPUSH
42434: LD_VAR 0 1
42438: PPUSH
42439: CALL_OW 250
42443: PPUSH
42444: LD_VAR 0 1
42448: PPUSH
42449: CALL_OW 251
42453: PPUSH
42454: LD_VAR 0 2
42458: PPUSH
42459: CALL 15811 0 4
42463: PUSH
42464: LD_INT 4
42466: ARRAY
42467: ST_TO_ADDR
// end ;
42468: LD_VAR 0 3
42472: RET
// export function PlayerSeeMe ( unit ) ; begin
42473: LD_INT 0
42475: PPUSH
// result := See ( your_side , unit ) ;
42476: LD_ADDR_VAR 0 2
42480: PUSH
42481: LD_OWVAR 2
42485: PPUSH
42486: LD_VAR 0 1
42490: PPUSH
42491: CALL_OW 292
42495: ST_TO_ADDR
// end ;
42496: LD_VAR 0 2
42500: RET
// export function ReverseDir ( unit ) ; begin
42501: LD_INT 0
42503: PPUSH
// if not unit then
42504: LD_VAR 0 1
42508: NOT
42509: IFFALSE 42513
// exit ;
42511: GO 42536
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
42513: LD_ADDR_VAR 0 2
42517: PUSH
42518: LD_VAR 0 1
42522: PPUSH
42523: CALL_OW 254
42527: PUSH
42528: LD_INT 3
42530: PLUS
42531: PUSH
42532: LD_INT 6
42534: MOD
42535: ST_TO_ADDR
// end ;
42536: LD_VAR 0 2
42540: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
42541: LD_INT 0
42543: PPUSH
42544: PPUSH
42545: PPUSH
42546: PPUSH
42547: PPUSH
// if not hexes then
42548: LD_VAR 0 2
42552: NOT
42553: IFFALSE 42557
// exit ;
42555: GO 42705
// dist := 9999 ;
42557: LD_ADDR_VAR 0 5
42561: PUSH
42562: LD_INT 9999
42564: ST_TO_ADDR
// for i = 1 to hexes do
42565: LD_ADDR_VAR 0 4
42569: PUSH
42570: DOUBLE
42571: LD_INT 1
42573: DEC
42574: ST_TO_ADDR
42575: LD_VAR 0 2
42579: PUSH
42580: FOR_TO
42581: IFFALSE 42693
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
42583: LD_VAR 0 1
42587: PPUSH
42588: LD_VAR 0 2
42592: PUSH
42593: LD_VAR 0 4
42597: ARRAY
42598: PUSH
42599: LD_INT 1
42601: ARRAY
42602: PPUSH
42603: LD_VAR 0 2
42607: PUSH
42608: LD_VAR 0 4
42612: ARRAY
42613: PUSH
42614: LD_INT 2
42616: ARRAY
42617: PPUSH
42618: CALL_OW 297
42622: PUSH
42623: LD_VAR 0 5
42627: LESS
42628: IFFALSE 42691
// begin hex := hexes [ i ] ;
42630: LD_ADDR_VAR 0 7
42634: PUSH
42635: LD_VAR 0 2
42639: PUSH
42640: LD_VAR 0 4
42644: ARRAY
42645: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
42646: LD_ADDR_VAR 0 5
42650: PUSH
42651: LD_VAR 0 1
42655: PPUSH
42656: LD_VAR 0 2
42660: PUSH
42661: LD_VAR 0 4
42665: ARRAY
42666: PUSH
42667: LD_INT 1
42669: ARRAY
42670: PPUSH
42671: LD_VAR 0 2
42675: PUSH
42676: LD_VAR 0 4
42680: ARRAY
42681: PUSH
42682: LD_INT 2
42684: ARRAY
42685: PPUSH
42686: CALL_OW 297
42690: ST_TO_ADDR
// end ; end ;
42691: GO 42580
42693: POP
42694: POP
// result := hex ;
42695: LD_ADDR_VAR 0 3
42699: PUSH
42700: LD_VAR 0 7
42704: ST_TO_ADDR
// end ;
42705: LD_VAR 0 3
42709: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
42710: LD_INT 0
42712: PPUSH
42713: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
42714: LD_VAR 0 1
42718: NOT
42719: PUSH
42720: LD_VAR 0 1
42724: PUSH
42725: LD_INT 21
42727: PUSH
42728: LD_INT 2
42730: PUSH
42731: EMPTY
42732: LIST
42733: LIST
42734: PUSH
42735: LD_INT 23
42737: PUSH
42738: LD_INT 2
42740: PUSH
42741: EMPTY
42742: LIST
42743: LIST
42744: PUSH
42745: EMPTY
42746: LIST
42747: LIST
42748: PPUSH
42749: CALL_OW 69
42753: IN
42754: NOT
42755: OR
42756: IFFALSE 42760
// exit ;
42758: GO 42807
// for i = 1 to 3 do
42760: LD_ADDR_VAR 0 3
42764: PUSH
42765: DOUBLE
42766: LD_INT 1
42768: DEC
42769: ST_TO_ADDR
42770: LD_INT 3
42772: PUSH
42773: FOR_TO
42774: IFFALSE 42805
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
42776: LD_VAR 0 1
42780: PPUSH
42781: CALL_OW 250
42785: PPUSH
42786: LD_VAR 0 1
42790: PPUSH
42791: CALL_OW 251
42795: PPUSH
42796: LD_INT 1
42798: PPUSH
42799: CALL_OW 453
42803: GO 42773
42805: POP
42806: POP
// end ;
42807: LD_VAR 0 2
42811: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
42812: LD_INT 0
42814: PPUSH
42815: PPUSH
42816: PPUSH
42817: PPUSH
42818: PPUSH
42819: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
42820: LD_VAR 0 1
42824: NOT
42825: PUSH
42826: LD_VAR 0 2
42830: NOT
42831: OR
42832: PUSH
42833: LD_VAR 0 1
42837: PPUSH
42838: CALL_OW 314
42842: OR
42843: IFFALSE 42847
// exit ;
42845: GO 43288
// x := GetX ( enemy_unit ) ;
42847: LD_ADDR_VAR 0 7
42851: PUSH
42852: LD_VAR 0 2
42856: PPUSH
42857: CALL_OW 250
42861: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
42862: LD_ADDR_VAR 0 8
42866: PUSH
42867: LD_VAR 0 2
42871: PPUSH
42872: CALL_OW 251
42876: ST_TO_ADDR
// if not x or not y then
42877: LD_VAR 0 7
42881: NOT
42882: PUSH
42883: LD_VAR 0 8
42887: NOT
42888: OR
42889: IFFALSE 42893
// exit ;
42891: GO 43288
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
42893: LD_ADDR_VAR 0 6
42897: PUSH
42898: LD_VAR 0 7
42902: PPUSH
42903: LD_INT 0
42905: PPUSH
42906: LD_INT 4
42908: PPUSH
42909: CALL_OW 272
42913: PUSH
42914: LD_VAR 0 8
42918: PPUSH
42919: LD_INT 0
42921: PPUSH
42922: LD_INT 4
42924: PPUSH
42925: CALL_OW 273
42929: PUSH
42930: EMPTY
42931: LIST
42932: LIST
42933: PUSH
42934: LD_VAR 0 7
42938: PPUSH
42939: LD_INT 1
42941: PPUSH
42942: LD_INT 4
42944: PPUSH
42945: CALL_OW 272
42949: PUSH
42950: LD_VAR 0 8
42954: PPUSH
42955: LD_INT 1
42957: PPUSH
42958: LD_INT 4
42960: PPUSH
42961: CALL_OW 273
42965: PUSH
42966: EMPTY
42967: LIST
42968: LIST
42969: PUSH
42970: LD_VAR 0 7
42974: PPUSH
42975: LD_INT 2
42977: PPUSH
42978: LD_INT 4
42980: PPUSH
42981: CALL_OW 272
42985: PUSH
42986: LD_VAR 0 8
42990: PPUSH
42991: LD_INT 2
42993: PPUSH
42994: LD_INT 4
42996: PPUSH
42997: CALL_OW 273
43001: PUSH
43002: EMPTY
43003: LIST
43004: LIST
43005: PUSH
43006: LD_VAR 0 7
43010: PPUSH
43011: LD_INT 3
43013: PPUSH
43014: LD_INT 4
43016: PPUSH
43017: CALL_OW 272
43021: PUSH
43022: LD_VAR 0 8
43026: PPUSH
43027: LD_INT 3
43029: PPUSH
43030: LD_INT 4
43032: PPUSH
43033: CALL_OW 273
43037: PUSH
43038: EMPTY
43039: LIST
43040: LIST
43041: PUSH
43042: LD_VAR 0 7
43046: PPUSH
43047: LD_INT 4
43049: PPUSH
43050: LD_INT 4
43052: PPUSH
43053: CALL_OW 272
43057: PUSH
43058: LD_VAR 0 8
43062: PPUSH
43063: LD_INT 4
43065: PPUSH
43066: LD_INT 4
43068: PPUSH
43069: CALL_OW 273
43073: PUSH
43074: EMPTY
43075: LIST
43076: LIST
43077: PUSH
43078: LD_VAR 0 7
43082: PPUSH
43083: LD_INT 5
43085: PPUSH
43086: LD_INT 4
43088: PPUSH
43089: CALL_OW 272
43093: PUSH
43094: LD_VAR 0 8
43098: PPUSH
43099: LD_INT 5
43101: PPUSH
43102: LD_INT 4
43104: PPUSH
43105: CALL_OW 273
43109: PUSH
43110: EMPTY
43111: LIST
43112: LIST
43113: PUSH
43114: EMPTY
43115: LIST
43116: LIST
43117: LIST
43118: LIST
43119: LIST
43120: LIST
43121: ST_TO_ADDR
// for i = tmp downto 1 do
43122: LD_ADDR_VAR 0 4
43126: PUSH
43127: DOUBLE
43128: LD_VAR 0 6
43132: INC
43133: ST_TO_ADDR
43134: LD_INT 1
43136: PUSH
43137: FOR_DOWNTO
43138: IFFALSE 43239
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
43140: LD_VAR 0 6
43144: PUSH
43145: LD_VAR 0 4
43149: ARRAY
43150: PUSH
43151: LD_INT 1
43153: ARRAY
43154: PPUSH
43155: LD_VAR 0 6
43159: PUSH
43160: LD_VAR 0 4
43164: ARRAY
43165: PUSH
43166: LD_INT 2
43168: ARRAY
43169: PPUSH
43170: CALL_OW 488
43174: NOT
43175: PUSH
43176: LD_VAR 0 6
43180: PUSH
43181: LD_VAR 0 4
43185: ARRAY
43186: PUSH
43187: LD_INT 1
43189: ARRAY
43190: PPUSH
43191: LD_VAR 0 6
43195: PUSH
43196: LD_VAR 0 4
43200: ARRAY
43201: PUSH
43202: LD_INT 2
43204: ARRAY
43205: PPUSH
43206: CALL_OW 428
43210: PUSH
43211: LD_INT 0
43213: NONEQUAL
43214: OR
43215: IFFALSE 43237
// tmp := Delete ( tmp , i ) ;
43217: LD_ADDR_VAR 0 6
43221: PUSH
43222: LD_VAR 0 6
43226: PPUSH
43227: LD_VAR 0 4
43231: PPUSH
43232: CALL_OW 3
43236: ST_TO_ADDR
43237: GO 43137
43239: POP
43240: POP
// j := GetClosestHex ( unit , tmp ) ;
43241: LD_ADDR_VAR 0 5
43245: PUSH
43246: LD_VAR 0 1
43250: PPUSH
43251: LD_VAR 0 6
43255: PPUSH
43256: CALL 42541 0 2
43260: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
43261: LD_VAR 0 1
43265: PPUSH
43266: LD_VAR 0 5
43270: PUSH
43271: LD_INT 1
43273: ARRAY
43274: PPUSH
43275: LD_VAR 0 5
43279: PUSH
43280: LD_INT 2
43282: ARRAY
43283: PPUSH
43284: CALL_OW 111
// end ;
43288: LD_VAR 0 3
43292: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
43293: LD_INT 0
43295: PPUSH
43296: PPUSH
43297: PPUSH
// uc_side = 0 ;
43298: LD_ADDR_OWVAR 20
43302: PUSH
43303: LD_INT 0
43305: ST_TO_ADDR
// uc_nation = 0 ;
43306: LD_ADDR_OWVAR 21
43310: PUSH
43311: LD_INT 0
43313: ST_TO_ADDR
// InitHc_All ( ) ;
43314: CALL_OW 584
// InitVc ;
43318: CALL_OW 20
// if mastodonts then
43322: LD_VAR 0 6
43326: IFFALSE 43393
// for i = 1 to mastodonts do
43328: LD_ADDR_VAR 0 11
43332: PUSH
43333: DOUBLE
43334: LD_INT 1
43336: DEC
43337: ST_TO_ADDR
43338: LD_VAR 0 6
43342: PUSH
43343: FOR_TO
43344: IFFALSE 43391
// begin vc_chassis := 31 ;
43346: LD_ADDR_OWVAR 37
43350: PUSH
43351: LD_INT 31
43353: ST_TO_ADDR
// vc_control := control_rider ;
43354: LD_ADDR_OWVAR 38
43358: PUSH
43359: LD_INT 4
43361: ST_TO_ADDR
// animal := CreateVehicle ;
43362: LD_ADDR_VAR 0 12
43366: PUSH
43367: CALL_OW 45
43371: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
43372: LD_VAR 0 12
43376: PPUSH
43377: LD_VAR 0 8
43381: PPUSH
43382: LD_INT 0
43384: PPUSH
43385: CALL 45581 0 3
// end ;
43389: GO 43343
43391: POP
43392: POP
// if horses then
43393: LD_VAR 0 5
43397: IFFALSE 43464
// for i = 1 to horses do
43399: LD_ADDR_VAR 0 11
43403: PUSH
43404: DOUBLE
43405: LD_INT 1
43407: DEC
43408: ST_TO_ADDR
43409: LD_VAR 0 5
43413: PUSH
43414: FOR_TO
43415: IFFALSE 43462
// begin hc_class := 21 ;
43417: LD_ADDR_OWVAR 28
43421: PUSH
43422: LD_INT 21
43424: ST_TO_ADDR
// hc_gallery :=  ;
43425: LD_ADDR_OWVAR 33
43429: PUSH
43430: LD_STRING 
43432: ST_TO_ADDR
// animal := CreateHuman ;
43433: LD_ADDR_VAR 0 12
43437: PUSH
43438: CALL_OW 44
43442: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
43443: LD_VAR 0 12
43447: PPUSH
43448: LD_VAR 0 8
43452: PPUSH
43453: LD_INT 0
43455: PPUSH
43456: CALL 45581 0 3
// end ;
43460: GO 43414
43462: POP
43463: POP
// if birds then
43464: LD_VAR 0 1
43468: IFFALSE 43535
// for i = 1 to birds do
43470: LD_ADDR_VAR 0 11
43474: PUSH
43475: DOUBLE
43476: LD_INT 1
43478: DEC
43479: ST_TO_ADDR
43480: LD_VAR 0 1
43484: PUSH
43485: FOR_TO
43486: IFFALSE 43533
// begin hc_class = 18 ;
43488: LD_ADDR_OWVAR 28
43492: PUSH
43493: LD_INT 18
43495: ST_TO_ADDR
// hc_gallery =  ;
43496: LD_ADDR_OWVAR 33
43500: PUSH
43501: LD_STRING 
43503: ST_TO_ADDR
// animal := CreateHuman ;
43504: LD_ADDR_VAR 0 12
43508: PUSH
43509: CALL_OW 44
43513: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
43514: LD_VAR 0 12
43518: PPUSH
43519: LD_VAR 0 8
43523: PPUSH
43524: LD_INT 0
43526: PPUSH
43527: CALL 45581 0 3
// end ;
43531: GO 43485
43533: POP
43534: POP
// if tigers then
43535: LD_VAR 0 2
43539: IFFALSE 43623
// for i = 1 to tigers do
43541: LD_ADDR_VAR 0 11
43545: PUSH
43546: DOUBLE
43547: LD_INT 1
43549: DEC
43550: ST_TO_ADDR
43551: LD_VAR 0 2
43555: PUSH
43556: FOR_TO
43557: IFFALSE 43621
// begin hc_class = class_tiger ;
43559: LD_ADDR_OWVAR 28
43563: PUSH
43564: LD_INT 14
43566: ST_TO_ADDR
// hc_gallery =  ;
43567: LD_ADDR_OWVAR 33
43571: PUSH
43572: LD_STRING 
43574: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
43575: LD_ADDR_OWVAR 35
43579: PUSH
43580: LD_INT 7
43582: NEG
43583: PPUSH
43584: LD_INT 7
43586: PPUSH
43587: CALL_OW 12
43591: ST_TO_ADDR
// animal := CreateHuman ;
43592: LD_ADDR_VAR 0 12
43596: PUSH
43597: CALL_OW 44
43601: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
43602: LD_VAR 0 12
43606: PPUSH
43607: LD_VAR 0 8
43611: PPUSH
43612: LD_INT 0
43614: PPUSH
43615: CALL 45581 0 3
// end ;
43619: GO 43556
43621: POP
43622: POP
// if apemans then
43623: LD_VAR 0 3
43627: IFFALSE 43750
// for i = 1 to apemans do
43629: LD_ADDR_VAR 0 11
43633: PUSH
43634: DOUBLE
43635: LD_INT 1
43637: DEC
43638: ST_TO_ADDR
43639: LD_VAR 0 3
43643: PUSH
43644: FOR_TO
43645: IFFALSE 43748
// begin hc_class = class_apeman ;
43647: LD_ADDR_OWVAR 28
43651: PUSH
43652: LD_INT 12
43654: ST_TO_ADDR
// hc_gallery =  ;
43655: LD_ADDR_OWVAR 33
43659: PUSH
43660: LD_STRING 
43662: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
43663: LD_ADDR_OWVAR 35
43667: PUSH
43668: LD_INT 2
43670: NEG
43671: PPUSH
43672: LD_INT 2
43674: PPUSH
43675: CALL_OW 12
43679: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
43680: LD_ADDR_OWVAR 31
43684: PUSH
43685: LD_INT 1
43687: PPUSH
43688: LD_INT 3
43690: PPUSH
43691: CALL_OW 12
43695: PUSH
43696: LD_INT 1
43698: PPUSH
43699: LD_INT 3
43701: PPUSH
43702: CALL_OW 12
43706: PUSH
43707: LD_INT 0
43709: PUSH
43710: LD_INT 0
43712: PUSH
43713: EMPTY
43714: LIST
43715: LIST
43716: LIST
43717: LIST
43718: ST_TO_ADDR
// animal := CreateHuman ;
43719: LD_ADDR_VAR 0 12
43723: PUSH
43724: CALL_OW 44
43728: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
43729: LD_VAR 0 12
43733: PPUSH
43734: LD_VAR 0 8
43738: PPUSH
43739: LD_INT 0
43741: PPUSH
43742: CALL 45581 0 3
// end ;
43746: GO 43644
43748: POP
43749: POP
// if enchidnas then
43750: LD_VAR 0 4
43754: IFFALSE 43821
// for i = 1 to enchidnas do
43756: LD_ADDR_VAR 0 11
43760: PUSH
43761: DOUBLE
43762: LD_INT 1
43764: DEC
43765: ST_TO_ADDR
43766: LD_VAR 0 4
43770: PUSH
43771: FOR_TO
43772: IFFALSE 43819
// begin hc_class = 13 ;
43774: LD_ADDR_OWVAR 28
43778: PUSH
43779: LD_INT 13
43781: ST_TO_ADDR
// hc_gallery =  ;
43782: LD_ADDR_OWVAR 33
43786: PUSH
43787: LD_STRING 
43789: ST_TO_ADDR
// animal := CreateHuman ;
43790: LD_ADDR_VAR 0 12
43794: PUSH
43795: CALL_OW 44
43799: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
43800: LD_VAR 0 12
43804: PPUSH
43805: LD_VAR 0 8
43809: PPUSH
43810: LD_INT 0
43812: PPUSH
43813: CALL 45581 0 3
// end ;
43817: GO 43771
43819: POP
43820: POP
// if fishes then
43821: LD_VAR 0 7
43825: IFFALSE 43892
// for i = 1 to fishes do
43827: LD_ADDR_VAR 0 11
43831: PUSH
43832: DOUBLE
43833: LD_INT 1
43835: DEC
43836: ST_TO_ADDR
43837: LD_VAR 0 7
43841: PUSH
43842: FOR_TO
43843: IFFALSE 43890
// begin hc_class = 20 ;
43845: LD_ADDR_OWVAR 28
43849: PUSH
43850: LD_INT 20
43852: ST_TO_ADDR
// hc_gallery =  ;
43853: LD_ADDR_OWVAR 33
43857: PUSH
43858: LD_STRING 
43860: ST_TO_ADDR
// animal := CreateHuman ;
43861: LD_ADDR_VAR 0 12
43865: PUSH
43866: CALL_OW 44
43870: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
43871: LD_VAR 0 12
43875: PPUSH
43876: LD_VAR 0 9
43880: PPUSH
43881: LD_INT 0
43883: PPUSH
43884: CALL 45581 0 3
// end ;
43888: GO 43842
43890: POP
43891: POP
// end ;
43892: LD_VAR 0 10
43896: RET
// export function WantHeal ( sci , unit ) ; begin
43897: LD_INT 0
43899: PPUSH
// if GetTaskList ( sci ) > 0 then
43900: LD_VAR 0 1
43904: PPUSH
43905: CALL_OW 437
43909: PUSH
43910: LD_INT 0
43912: GREATER
43913: IFFALSE 43983
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
43915: LD_VAR 0 1
43919: PPUSH
43920: CALL_OW 437
43924: PUSH
43925: LD_INT 1
43927: ARRAY
43928: PUSH
43929: LD_INT 1
43931: ARRAY
43932: PUSH
43933: LD_STRING l
43935: EQUAL
43936: PUSH
43937: LD_VAR 0 1
43941: PPUSH
43942: CALL_OW 437
43946: PUSH
43947: LD_INT 1
43949: ARRAY
43950: PUSH
43951: LD_INT 4
43953: ARRAY
43954: PUSH
43955: LD_VAR 0 2
43959: EQUAL
43960: AND
43961: IFFALSE 43973
// result := true else
43963: LD_ADDR_VAR 0 3
43967: PUSH
43968: LD_INT 1
43970: ST_TO_ADDR
43971: GO 43981
// result := false ;
43973: LD_ADDR_VAR 0 3
43977: PUSH
43978: LD_INT 0
43980: ST_TO_ADDR
// end else
43981: GO 43991
// result := false ;
43983: LD_ADDR_VAR 0 3
43987: PUSH
43988: LD_INT 0
43990: ST_TO_ADDR
// end ;
43991: LD_VAR 0 3
43995: RET
// export function HealTarget ( sci ) ; begin
43996: LD_INT 0
43998: PPUSH
// if not sci then
43999: LD_VAR 0 1
44003: NOT
44004: IFFALSE 44008
// exit ;
44006: GO 44073
// result := 0 ;
44008: LD_ADDR_VAR 0 2
44012: PUSH
44013: LD_INT 0
44015: ST_TO_ADDR
// if GetTaskList ( sci ) then
44016: LD_VAR 0 1
44020: PPUSH
44021: CALL_OW 437
44025: IFFALSE 44073
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
44027: LD_VAR 0 1
44031: PPUSH
44032: CALL_OW 437
44036: PUSH
44037: LD_INT 1
44039: ARRAY
44040: PUSH
44041: LD_INT 1
44043: ARRAY
44044: PUSH
44045: LD_STRING l
44047: EQUAL
44048: IFFALSE 44073
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
44050: LD_ADDR_VAR 0 2
44054: PUSH
44055: LD_VAR 0 1
44059: PPUSH
44060: CALL_OW 437
44064: PUSH
44065: LD_INT 1
44067: ARRAY
44068: PUSH
44069: LD_INT 4
44071: ARRAY
44072: ST_TO_ADDR
// end ;
44073: LD_VAR 0 2
44077: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
44078: LD_INT 0
44080: PPUSH
44081: PPUSH
44082: PPUSH
44083: PPUSH
// if not base_units then
44084: LD_VAR 0 1
44088: NOT
44089: IFFALSE 44093
// exit ;
44091: GO 44180
// result := false ;
44093: LD_ADDR_VAR 0 2
44097: PUSH
44098: LD_INT 0
44100: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
44101: LD_ADDR_VAR 0 5
44105: PUSH
44106: LD_VAR 0 1
44110: PPUSH
44111: LD_INT 21
44113: PUSH
44114: LD_INT 3
44116: PUSH
44117: EMPTY
44118: LIST
44119: LIST
44120: PPUSH
44121: CALL_OW 72
44125: ST_TO_ADDR
// if not tmp then
44126: LD_VAR 0 5
44130: NOT
44131: IFFALSE 44135
// exit ;
44133: GO 44180
// for i in tmp do
44135: LD_ADDR_VAR 0 3
44139: PUSH
44140: LD_VAR 0 5
44144: PUSH
44145: FOR_IN
44146: IFFALSE 44178
// begin result := EnemyInRange ( i , 22 ) ;
44148: LD_ADDR_VAR 0 2
44152: PUSH
44153: LD_VAR 0 3
44157: PPUSH
44158: LD_INT 22
44160: PPUSH
44161: CALL 42416 0 2
44165: ST_TO_ADDR
// if result then
44166: LD_VAR 0 2
44170: IFFALSE 44176
// exit ;
44172: POP
44173: POP
44174: GO 44180
// end ;
44176: GO 44145
44178: POP
44179: POP
// end ;
44180: LD_VAR 0 2
44184: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
44185: LD_INT 0
44187: PPUSH
44188: PPUSH
// if not units then
44189: LD_VAR 0 1
44193: NOT
44194: IFFALSE 44198
// exit ;
44196: GO 44268
// result := [ ] ;
44198: LD_ADDR_VAR 0 3
44202: PUSH
44203: EMPTY
44204: ST_TO_ADDR
// for i in units do
44205: LD_ADDR_VAR 0 4
44209: PUSH
44210: LD_VAR 0 1
44214: PUSH
44215: FOR_IN
44216: IFFALSE 44266
// if GetTag ( i ) = tag then
44218: LD_VAR 0 4
44222: PPUSH
44223: CALL_OW 110
44227: PUSH
44228: LD_VAR 0 2
44232: EQUAL
44233: IFFALSE 44264
// result := Insert ( result , result + 1 , i ) ;
44235: LD_ADDR_VAR 0 3
44239: PUSH
44240: LD_VAR 0 3
44244: PPUSH
44245: LD_VAR 0 3
44249: PUSH
44250: LD_INT 1
44252: PLUS
44253: PPUSH
44254: LD_VAR 0 4
44258: PPUSH
44259: CALL_OW 2
44263: ST_TO_ADDR
44264: GO 44215
44266: POP
44267: POP
// end ;
44268: LD_VAR 0 3
44272: RET
// export function IsDriver ( un ) ; begin
44273: LD_INT 0
44275: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
44276: LD_ADDR_VAR 0 2
44280: PUSH
44281: LD_VAR 0 1
44285: PUSH
44286: LD_INT 55
44288: PUSH
44289: EMPTY
44290: LIST
44291: PPUSH
44292: CALL_OW 69
44296: IN
44297: ST_TO_ADDR
// end ;
44298: LD_VAR 0 2
44302: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
44303: LD_INT 0
44305: PPUSH
44306: PPUSH
// list := [ ] ;
44307: LD_ADDR_VAR 0 5
44311: PUSH
44312: EMPTY
44313: ST_TO_ADDR
// case d of 0 :
44314: LD_VAR 0 3
44318: PUSH
44319: LD_INT 0
44321: DOUBLE
44322: EQUAL
44323: IFTRUE 44327
44325: GO 44460
44327: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
44328: LD_ADDR_VAR 0 5
44332: PUSH
44333: LD_VAR 0 1
44337: PUSH
44338: LD_INT 4
44340: MINUS
44341: PUSH
44342: LD_VAR 0 2
44346: PUSH
44347: LD_INT 4
44349: MINUS
44350: PUSH
44351: LD_INT 2
44353: PUSH
44354: EMPTY
44355: LIST
44356: LIST
44357: LIST
44358: PUSH
44359: LD_VAR 0 1
44363: PUSH
44364: LD_INT 3
44366: MINUS
44367: PUSH
44368: LD_VAR 0 2
44372: PUSH
44373: LD_INT 1
44375: PUSH
44376: EMPTY
44377: LIST
44378: LIST
44379: LIST
44380: PUSH
44381: LD_VAR 0 1
44385: PUSH
44386: LD_INT 4
44388: PLUS
44389: PUSH
44390: LD_VAR 0 2
44394: PUSH
44395: LD_INT 4
44397: PUSH
44398: EMPTY
44399: LIST
44400: LIST
44401: LIST
44402: PUSH
44403: LD_VAR 0 1
44407: PUSH
44408: LD_INT 3
44410: PLUS
44411: PUSH
44412: LD_VAR 0 2
44416: PUSH
44417: LD_INT 3
44419: PLUS
44420: PUSH
44421: LD_INT 5
44423: PUSH
44424: EMPTY
44425: LIST
44426: LIST
44427: LIST
44428: PUSH
44429: LD_VAR 0 1
44433: PUSH
44434: LD_VAR 0 2
44438: PUSH
44439: LD_INT 4
44441: PLUS
44442: PUSH
44443: LD_INT 0
44445: PUSH
44446: EMPTY
44447: LIST
44448: LIST
44449: LIST
44450: PUSH
44451: EMPTY
44452: LIST
44453: LIST
44454: LIST
44455: LIST
44456: LIST
44457: ST_TO_ADDR
// end ; 1 :
44458: GO 45158
44460: LD_INT 1
44462: DOUBLE
44463: EQUAL
44464: IFTRUE 44468
44466: GO 44601
44468: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
44469: LD_ADDR_VAR 0 5
44473: PUSH
44474: LD_VAR 0 1
44478: PUSH
44479: LD_VAR 0 2
44483: PUSH
44484: LD_INT 4
44486: MINUS
44487: PUSH
44488: LD_INT 3
44490: PUSH
44491: EMPTY
44492: LIST
44493: LIST
44494: LIST
44495: PUSH
44496: LD_VAR 0 1
44500: PUSH
44501: LD_INT 3
44503: MINUS
44504: PUSH
44505: LD_VAR 0 2
44509: PUSH
44510: LD_INT 3
44512: MINUS
44513: PUSH
44514: LD_INT 2
44516: PUSH
44517: EMPTY
44518: LIST
44519: LIST
44520: LIST
44521: PUSH
44522: LD_VAR 0 1
44526: PUSH
44527: LD_INT 4
44529: MINUS
44530: PUSH
44531: LD_VAR 0 2
44535: PUSH
44536: LD_INT 1
44538: PUSH
44539: EMPTY
44540: LIST
44541: LIST
44542: LIST
44543: PUSH
44544: LD_VAR 0 1
44548: PUSH
44549: LD_VAR 0 2
44553: PUSH
44554: LD_INT 3
44556: PLUS
44557: PUSH
44558: LD_INT 0
44560: PUSH
44561: EMPTY
44562: LIST
44563: LIST
44564: LIST
44565: PUSH
44566: LD_VAR 0 1
44570: PUSH
44571: LD_INT 4
44573: PLUS
44574: PUSH
44575: LD_VAR 0 2
44579: PUSH
44580: LD_INT 4
44582: PLUS
44583: PUSH
44584: LD_INT 5
44586: PUSH
44587: EMPTY
44588: LIST
44589: LIST
44590: LIST
44591: PUSH
44592: EMPTY
44593: LIST
44594: LIST
44595: LIST
44596: LIST
44597: LIST
44598: ST_TO_ADDR
// end ; 2 :
44599: GO 45158
44601: LD_INT 2
44603: DOUBLE
44604: EQUAL
44605: IFTRUE 44609
44607: GO 44738
44609: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
44610: LD_ADDR_VAR 0 5
44614: PUSH
44615: LD_VAR 0 1
44619: PUSH
44620: LD_VAR 0 2
44624: PUSH
44625: LD_INT 3
44627: MINUS
44628: PUSH
44629: LD_INT 3
44631: PUSH
44632: EMPTY
44633: LIST
44634: LIST
44635: LIST
44636: PUSH
44637: LD_VAR 0 1
44641: PUSH
44642: LD_INT 4
44644: PLUS
44645: PUSH
44646: LD_VAR 0 2
44650: PUSH
44651: LD_INT 4
44653: PUSH
44654: EMPTY
44655: LIST
44656: LIST
44657: LIST
44658: PUSH
44659: LD_VAR 0 1
44663: PUSH
44664: LD_VAR 0 2
44668: PUSH
44669: LD_INT 4
44671: PLUS
44672: PUSH
44673: LD_INT 0
44675: PUSH
44676: EMPTY
44677: LIST
44678: LIST
44679: LIST
44680: PUSH
44681: LD_VAR 0 1
44685: PUSH
44686: LD_INT 3
44688: MINUS
44689: PUSH
44690: LD_VAR 0 2
44694: PUSH
44695: LD_INT 1
44697: PUSH
44698: EMPTY
44699: LIST
44700: LIST
44701: LIST
44702: PUSH
44703: LD_VAR 0 1
44707: PUSH
44708: LD_INT 4
44710: MINUS
44711: PUSH
44712: LD_VAR 0 2
44716: PUSH
44717: LD_INT 4
44719: MINUS
44720: PUSH
44721: LD_INT 2
44723: PUSH
44724: EMPTY
44725: LIST
44726: LIST
44727: LIST
44728: PUSH
44729: EMPTY
44730: LIST
44731: LIST
44732: LIST
44733: LIST
44734: LIST
44735: ST_TO_ADDR
// end ; 3 :
44736: GO 45158
44738: LD_INT 3
44740: DOUBLE
44741: EQUAL
44742: IFTRUE 44746
44744: GO 44879
44746: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
44747: LD_ADDR_VAR 0 5
44751: PUSH
44752: LD_VAR 0 1
44756: PUSH
44757: LD_INT 3
44759: PLUS
44760: PUSH
44761: LD_VAR 0 2
44765: PUSH
44766: LD_INT 4
44768: PUSH
44769: EMPTY
44770: LIST
44771: LIST
44772: LIST
44773: PUSH
44774: LD_VAR 0 1
44778: PUSH
44779: LD_INT 4
44781: PLUS
44782: PUSH
44783: LD_VAR 0 2
44787: PUSH
44788: LD_INT 4
44790: PLUS
44791: PUSH
44792: LD_INT 5
44794: PUSH
44795: EMPTY
44796: LIST
44797: LIST
44798: LIST
44799: PUSH
44800: LD_VAR 0 1
44804: PUSH
44805: LD_INT 4
44807: MINUS
44808: PUSH
44809: LD_VAR 0 2
44813: PUSH
44814: LD_INT 1
44816: PUSH
44817: EMPTY
44818: LIST
44819: LIST
44820: LIST
44821: PUSH
44822: LD_VAR 0 1
44826: PUSH
44827: LD_VAR 0 2
44831: PUSH
44832: LD_INT 4
44834: MINUS
44835: PUSH
44836: LD_INT 3
44838: PUSH
44839: EMPTY
44840: LIST
44841: LIST
44842: LIST
44843: PUSH
44844: LD_VAR 0 1
44848: PUSH
44849: LD_INT 3
44851: MINUS
44852: PUSH
44853: LD_VAR 0 2
44857: PUSH
44858: LD_INT 3
44860: MINUS
44861: PUSH
44862: LD_INT 2
44864: PUSH
44865: EMPTY
44866: LIST
44867: LIST
44868: LIST
44869: PUSH
44870: EMPTY
44871: LIST
44872: LIST
44873: LIST
44874: LIST
44875: LIST
44876: ST_TO_ADDR
// end ; 4 :
44877: GO 45158
44879: LD_INT 4
44881: DOUBLE
44882: EQUAL
44883: IFTRUE 44887
44885: GO 45020
44887: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
44888: LD_ADDR_VAR 0 5
44892: PUSH
44893: LD_VAR 0 1
44897: PUSH
44898: LD_VAR 0 2
44902: PUSH
44903: LD_INT 4
44905: PLUS
44906: PUSH
44907: LD_INT 0
44909: PUSH
44910: EMPTY
44911: LIST
44912: LIST
44913: LIST
44914: PUSH
44915: LD_VAR 0 1
44919: PUSH
44920: LD_INT 3
44922: PLUS
44923: PUSH
44924: LD_VAR 0 2
44928: PUSH
44929: LD_INT 3
44931: PLUS
44932: PUSH
44933: LD_INT 5
44935: PUSH
44936: EMPTY
44937: LIST
44938: LIST
44939: LIST
44940: PUSH
44941: LD_VAR 0 1
44945: PUSH
44946: LD_INT 4
44948: PLUS
44949: PUSH
44950: LD_VAR 0 2
44954: PUSH
44955: LD_INT 4
44957: PUSH
44958: EMPTY
44959: LIST
44960: LIST
44961: LIST
44962: PUSH
44963: LD_VAR 0 1
44967: PUSH
44968: LD_VAR 0 2
44972: PUSH
44973: LD_INT 3
44975: MINUS
44976: PUSH
44977: LD_INT 3
44979: PUSH
44980: EMPTY
44981: LIST
44982: LIST
44983: LIST
44984: PUSH
44985: LD_VAR 0 1
44989: PUSH
44990: LD_INT 4
44992: MINUS
44993: PUSH
44994: LD_VAR 0 2
44998: PUSH
44999: LD_INT 4
45001: MINUS
45002: PUSH
45003: LD_INT 2
45005: PUSH
45006: EMPTY
45007: LIST
45008: LIST
45009: LIST
45010: PUSH
45011: EMPTY
45012: LIST
45013: LIST
45014: LIST
45015: LIST
45016: LIST
45017: ST_TO_ADDR
// end ; 5 :
45018: GO 45158
45020: LD_INT 5
45022: DOUBLE
45023: EQUAL
45024: IFTRUE 45028
45026: GO 45157
45028: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
45029: LD_ADDR_VAR 0 5
45033: PUSH
45034: LD_VAR 0 1
45038: PUSH
45039: LD_INT 4
45041: MINUS
45042: PUSH
45043: LD_VAR 0 2
45047: PUSH
45048: LD_INT 1
45050: PUSH
45051: EMPTY
45052: LIST
45053: LIST
45054: LIST
45055: PUSH
45056: LD_VAR 0 1
45060: PUSH
45061: LD_VAR 0 2
45065: PUSH
45066: LD_INT 4
45068: MINUS
45069: PUSH
45070: LD_INT 3
45072: PUSH
45073: EMPTY
45074: LIST
45075: LIST
45076: LIST
45077: PUSH
45078: LD_VAR 0 1
45082: PUSH
45083: LD_INT 4
45085: PLUS
45086: PUSH
45087: LD_VAR 0 2
45091: PUSH
45092: LD_INT 4
45094: PLUS
45095: PUSH
45096: LD_INT 5
45098: PUSH
45099: EMPTY
45100: LIST
45101: LIST
45102: LIST
45103: PUSH
45104: LD_VAR 0 1
45108: PUSH
45109: LD_INT 3
45111: PLUS
45112: PUSH
45113: LD_VAR 0 2
45117: PUSH
45118: LD_INT 4
45120: PUSH
45121: EMPTY
45122: LIST
45123: LIST
45124: LIST
45125: PUSH
45126: LD_VAR 0 1
45130: PUSH
45131: LD_VAR 0 2
45135: PUSH
45136: LD_INT 3
45138: PLUS
45139: PUSH
45140: LD_INT 0
45142: PUSH
45143: EMPTY
45144: LIST
45145: LIST
45146: LIST
45147: PUSH
45148: EMPTY
45149: LIST
45150: LIST
45151: LIST
45152: LIST
45153: LIST
45154: ST_TO_ADDR
// end ; end ;
45155: GO 45158
45157: POP
// result := list ;
45158: LD_ADDR_VAR 0 4
45162: PUSH
45163: LD_VAR 0 5
45167: ST_TO_ADDR
// end ;
45168: LD_VAR 0 4
45172: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
45173: LD_INT 0
45175: PPUSH
45176: PPUSH
45177: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
45178: LD_VAR 0 1
45182: NOT
45183: PUSH
45184: LD_VAR 0 2
45188: PUSH
45189: LD_INT 1
45191: PUSH
45192: LD_INT 2
45194: PUSH
45195: LD_INT 3
45197: PUSH
45198: LD_INT 4
45200: PUSH
45201: EMPTY
45202: LIST
45203: LIST
45204: LIST
45205: LIST
45206: IN
45207: NOT
45208: OR
45209: IFFALSE 45213
// exit ;
45211: GO 45305
// tmp := [ ] ;
45213: LD_ADDR_VAR 0 5
45217: PUSH
45218: EMPTY
45219: ST_TO_ADDR
// for i in units do
45220: LD_ADDR_VAR 0 4
45224: PUSH
45225: LD_VAR 0 1
45229: PUSH
45230: FOR_IN
45231: IFFALSE 45274
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
45233: LD_ADDR_VAR 0 5
45237: PUSH
45238: LD_VAR 0 5
45242: PPUSH
45243: LD_VAR 0 5
45247: PUSH
45248: LD_INT 1
45250: PLUS
45251: PPUSH
45252: LD_VAR 0 4
45256: PPUSH
45257: LD_VAR 0 2
45261: PPUSH
45262: CALL_OW 259
45266: PPUSH
45267: CALL_OW 2
45271: ST_TO_ADDR
45272: GO 45230
45274: POP
45275: POP
// if not tmp then
45276: LD_VAR 0 5
45280: NOT
45281: IFFALSE 45285
// exit ;
45283: GO 45305
// result := SortListByListDesc ( units , tmp ) ;
45285: LD_ADDR_VAR 0 3
45289: PUSH
45290: LD_VAR 0 1
45294: PPUSH
45295: LD_VAR 0 5
45299: PPUSH
45300: CALL_OW 77
45304: ST_TO_ADDR
// end ;
45305: LD_VAR 0 3
45309: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
45310: LD_INT 0
45312: PPUSH
45313: PPUSH
45314: PPUSH
// result := false ;
45315: LD_ADDR_VAR 0 3
45319: PUSH
45320: LD_INT 0
45322: ST_TO_ADDR
// x := GetX ( building ) ;
45323: LD_ADDR_VAR 0 4
45327: PUSH
45328: LD_VAR 0 2
45332: PPUSH
45333: CALL_OW 250
45337: ST_TO_ADDR
// y := GetY ( building ) ;
45338: LD_ADDR_VAR 0 5
45342: PUSH
45343: LD_VAR 0 2
45347: PPUSH
45348: CALL_OW 251
45352: ST_TO_ADDR
// if not building or not x or not y then
45353: LD_VAR 0 2
45357: NOT
45358: PUSH
45359: LD_VAR 0 4
45363: NOT
45364: OR
45365: PUSH
45366: LD_VAR 0 5
45370: NOT
45371: OR
45372: IFFALSE 45376
// exit ;
45374: GO 45468
// if GetTaskList ( unit ) then
45376: LD_VAR 0 1
45380: PPUSH
45381: CALL_OW 437
45385: IFFALSE 45468
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
45387: LD_STRING e
45389: PUSH
45390: LD_VAR 0 1
45394: PPUSH
45395: CALL_OW 437
45399: PUSH
45400: LD_INT 1
45402: ARRAY
45403: PUSH
45404: LD_INT 1
45406: ARRAY
45407: EQUAL
45408: PUSH
45409: LD_VAR 0 4
45413: PUSH
45414: LD_VAR 0 1
45418: PPUSH
45419: CALL_OW 437
45423: PUSH
45424: LD_INT 1
45426: ARRAY
45427: PUSH
45428: LD_INT 2
45430: ARRAY
45431: EQUAL
45432: AND
45433: PUSH
45434: LD_VAR 0 5
45438: PUSH
45439: LD_VAR 0 1
45443: PPUSH
45444: CALL_OW 437
45448: PUSH
45449: LD_INT 1
45451: ARRAY
45452: PUSH
45453: LD_INT 3
45455: ARRAY
45456: EQUAL
45457: AND
45458: IFFALSE 45468
// result := true end ;
45460: LD_ADDR_VAR 0 3
45464: PUSH
45465: LD_INT 1
45467: ST_TO_ADDR
// end ;
45468: LD_VAR 0 3
45472: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
45473: LD_INT 0
45475: PPUSH
// result := false ;
45476: LD_ADDR_VAR 0 4
45480: PUSH
45481: LD_INT 0
45483: ST_TO_ADDR
// if GetTaskList ( unit ) then
45484: LD_VAR 0 1
45488: PPUSH
45489: CALL_OW 437
45493: IFFALSE 45576
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
45495: LD_STRING M
45497: PUSH
45498: LD_VAR 0 1
45502: PPUSH
45503: CALL_OW 437
45507: PUSH
45508: LD_INT 1
45510: ARRAY
45511: PUSH
45512: LD_INT 1
45514: ARRAY
45515: EQUAL
45516: PUSH
45517: LD_VAR 0 2
45521: PUSH
45522: LD_VAR 0 1
45526: PPUSH
45527: CALL_OW 437
45531: PUSH
45532: LD_INT 1
45534: ARRAY
45535: PUSH
45536: LD_INT 2
45538: ARRAY
45539: EQUAL
45540: AND
45541: PUSH
45542: LD_VAR 0 3
45546: PUSH
45547: LD_VAR 0 1
45551: PPUSH
45552: CALL_OW 437
45556: PUSH
45557: LD_INT 1
45559: ARRAY
45560: PUSH
45561: LD_INT 3
45563: ARRAY
45564: EQUAL
45565: AND
45566: IFFALSE 45576
// result := true ;
45568: LD_ADDR_VAR 0 4
45572: PUSH
45573: LD_INT 1
45575: ST_TO_ADDR
// end ; end ;
45576: LD_VAR 0 4
45580: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
45581: LD_INT 0
45583: PPUSH
45584: PPUSH
45585: PPUSH
45586: PPUSH
// if not unit or not area then
45587: LD_VAR 0 1
45591: NOT
45592: PUSH
45593: LD_VAR 0 2
45597: NOT
45598: OR
45599: IFFALSE 45603
// exit ;
45601: GO 45767
// tmp := AreaToList ( area , i ) ;
45603: LD_ADDR_VAR 0 6
45607: PUSH
45608: LD_VAR 0 2
45612: PPUSH
45613: LD_VAR 0 5
45617: PPUSH
45618: CALL_OW 517
45622: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
45623: LD_ADDR_VAR 0 5
45627: PUSH
45628: DOUBLE
45629: LD_INT 1
45631: DEC
45632: ST_TO_ADDR
45633: LD_VAR 0 6
45637: PUSH
45638: LD_INT 1
45640: ARRAY
45641: PUSH
45642: FOR_TO
45643: IFFALSE 45765
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
45645: LD_ADDR_VAR 0 7
45649: PUSH
45650: LD_VAR 0 6
45654: PUSH
45655: LD_INT 1
45657: ARRAY
45658: PUSH
45659: LD_VAR 0 5
45663: ARRAY
45664: PUSH
45665: LD_VAR 0 6
45669: PUSH
45670: LD_INT 2
45672: ARRAY
45673: PUSH
45674: LD_VAR 0 5
45678: ARRAY
45679: PUSH
45680: EMPTY
45681: LIST
45682: LIST
45683: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
45684: LD_VAR 0 7
45688: PUSH
45689: LD_INT 1
45691: ARRAY
45692: PPUSH
45693: LD_VAR 0 7
45697: PUSH
45698: LD_INT 2
45700: ARRAY
45701: PPUSH
45702: CALL_OW 428
45706: PUSH
45707: LD_INT 0
45709: EQUAL
45710: IFFALSE 45763
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
45712: LD_VAR 0 1
45716: PPUSH
45717: LD_VAR 0 7
45721: PUSH
45722: LD_INT 1
45724: ARRAY
45725: PPUSH
45726: LD_VAR 0 7
45730: PUSH
45731: LD_INT 2
45733: ARRAY
45734: PPUSH
45735: LD_VAR 0 3
45739: PPUSH
45740: CALL_OW 48
// result := IsPlaced ( unit ) ;
45744: LD_ADDR_VAR 0 4
45748: PUSH
45749: LD_VAR 0 1
45753: PPUSH
45754: CALL_OW 305
45758: ST_TO_ADDR
// exit ;
45759: POP
45760: POP
45761: GO 45767
// end ; end ;
45763: GO 45642
45765: POP
45766: POP
// end ;
45767: LD_VAR 0 4
45771: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
45772: LD_INT 0
45774: PPUSH
45775: PPUSH
45776: PPUSH
// if not side or side > 8 then
45777: LD_VAR 0 1
45781: NOT
45782: PUSH
45783: LD_VAR 0 1
45787: PUSH
45788: LD_INT 8
45790: GREATER
45791: OR
45792: IFFALSE 45796
// exit ;
45794: GO 45983
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
45796: LD_ADDR_VAR 0 4
45800: PUSH
45801: LD_INT 22
45803: PUSH
45804: LD_VAR 0 1
45808: PUSH
45809: EMPTY
45810: LIST
45811: LIST
45812: PUSH
45813: LD_INT 21
45815: PUSH
45816: LD_INT 3
45818: PUSH
45819: EMPTY
45820: LIST
45821: LIST
45822: PUSH
45823: EMPTY
45824: LIST
45825: LIST
45826: PPUSH
45827: CALL_OW 69
45831: ST_TO_ADDR
// if not tmp then
45832: LD_VAR 0 4
45836: NOT
45837: IFFALSE 45841
// exit ;
45839: GO 45983
// enable_addtolog := true ;
45841: LD_ADDR_OWVAR 81
45845: PUSH
45846: LD_INT 1
45848: ST_TO_ADDR
// AddToLog ( [ ) ;
45849: LD_STRING [
45851: PPUSH
45852: CALL_OW 561
// for i in tmp do
45856: LD_ADDR_VAR 0 3
45860: PUSH
45861: LD_VAR 0 4
45865: PUSH
45866: FOR_IN
45867: IFFALSE 45974
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
45869: LD_STRING [
45871: PUSH
45872: LD_VAR 0 3
45876: PPUSH
45877: CALL_OW 266
45881: STR
45882: PUSH
45883: LD_STRING , 
45885: STR
45886: PUSH
45887: LD_VAR 0 3
45891: PPUSH
45892: CALL_OW 250
45896: STR
45897: PUSH
45898: LD_STRING , 
45900: STR
45901: PUSH
45902: LD_VAR 0 3
45906: PPUSH
45907: CALL_OW 251
45911: STR
45912: PUSH
45913: LD_STRING , 
45915: STR
45916: PUSH
45917: LD_VAR 0 3
45921: PPUSH
45922: CALL_OW 254
45926: STR
45927: PUSH
45928: LD_STRING , 
45930: STR
45931: PUSH
45932: LD_VAR 0 3
45936: PPUSH
45937: LD_INT 1
45939: PPUSH
45940: CALL_OW 268
45944: STR
45945: PUSH
45946: LD_STRING , 
45948: STR
45949: PUSH
45950: LD_VAR 0 3
45954: PPUSH
45955: LD_INT 2
45957: PPUSH
45958: CALL_OW 268
45962: STR
45963: PUSH
45964: LD_STRING ],
45966: STR
45967: PPUSH
45968: CALL_OW 561
// end ;
45972: GO 45866
45974: POP
45975: POP
// AddToLog ( ]; ) ;
45976: LD_STRING ];
45978: PPUSH
45979: CALL_OW 561
// end ;
45983: LD_VAR 0 2
45987: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
45988: LD_INT 0
45990: PPUSH
45991: PPUSH
45992: PPUSH
45993: PPUSH
45994: PPUSH
// if not area or not rate or not max then
45995: LD_VAR 0 1
45999: NOT
46000: PUSH
46001: LD_VAR 0 2
46005: NOT
46006: OR
46007: PUSH
46008: LD_VAR 0 4
46012: NOT
46013: OR
46014: IFFALSE 46018
// exit ;
46016: GO 46210
// while 1 do
46018: LD_INT 1
46020: IFFALSE 46210
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
46022: LD_ADDR_VAR 0 9
46026: PUSH
46027: LD_VAR 0 1
46031: PPUSH
46032: LD_INT 1
46034: PPUSH
46035: CALL_OW 287
46039: PUSH
46040: LD_INT 10
46042: MUL
46043: ST_TO_ADDR
// r := rate / 10 ;
46044: LD_ADDR_VAR 0 7
46048: PUSH
46049: LD_VAR 0 2
46053: PUSH
46054: LD_INT 10
46056: DIVREAL
46057: ST_TO_ADDR
// time := 1 1$00 ;
46058: LD_ADDR_VAR 0 8
46062: PUSH
46063: LD_INT 2100
46065: ST_TO_ADDR
// if amount < min then
46066: LD_VAR 0 9
46070: PUSH
46071: LD_VAR 0 3
46075: LESS
46076: IFFALSE 46094
// r := r * 2 else
46078: LD_ADDR_VAR 0 7
46082: PUSH
46083: LD_VAR 0 7
46087: PUSH
46088: LD_INT 2
46090: MUL
46091: ST_TO_ADDR
46092: GO 46120
// if amount > max then
46094: LD_VAR 0 9
46098: PUSH
46099: LD_VAR 0 4
46103: GREATER
46104: IFFALSE 46120
// r := r / 2 ;
46106: LD_ADDR_VAR 0 7
46110: PUSH
46111: LD_VAR 0 7
46115: PUSH
46116: LD_INT 2
46118: DIVREAL
46119: ST_TO_ADDR
// time := time / r ;
46120: LD_ADDR_VAR 0 8
46124: PUSH
46125: LD_VAR 0 8
46129: PUSH
46130: LD_VAR 0 7
46134: DIVREAL
46135: ST_TO_ADDR
// if time < 0 then
46136: LD_VAR 0 8
46140: PUSH
46141: LD_INT 0
46143: LESS
46144: IFFALSE 46161
// time := time * - 1 ;
46146: LD_ADDR_VAR 0 8
46150: PUSH
46151: LD_VAR 0 8
46155: PUSH
46156: LD_INT 1
46158: NEG
46159: MUL
46160: ST_TO_ADDR
// wait ( time ) ;
46161: LD_VAR 0 8
46165: PPUSH
46166: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
46170: LD_INT 35
46172: PPUSH
46173: LD_INT 875
46175: PPUSH
46176: CALL_OW 12
46180: PPUSH
46181: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
46185: LD_INT 1
46187: PPUSH
46188: LD_INT 5
46190: PPUSH
46191: CALL_OW 12
46195: PPUSH
46196: LD_VAR 0 1
46200: PPUSH
46201: LD_INT 1
46203: PPUSH
46204: CALL_OW 55
// end ;
46208: GO 46018
// end ;
46210: LD_VAR 0 5
46214: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
46215: LD_INT 0
46217: PPUSH
46218: PPUSH
46219: PPUSH
46220: PPUSH
46221: PPUSH
46222: PPUSH
46223: PPUSH
46224: PPUSH
// if not turrets or not factories then
46225: LD_VAR 0 1
46229: NOT
46230: PUSH
46231: LD_VAR 0 2
46235: NOT
46236: OR
46237: IFFALSE 46241
// exit ;
46239: GO 46548
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
46241: LD_ADDR_VAR 0 10
46245: PUSH
46246: LD_INT 5
46248: PUSH
46249: LD_INT 6
46251: PUSH
46252: EMPTY
46253: LIST
46254: LIST
46255: PUSH
46256: LD_INT 2
46258: PUSH
46259: LD_INT 4
46261: PUSH
46262: EMPTY
46263: LIST
46264: LIST
46265: PUSH
46266: LD_INT 3
46268: PUSH
46269: LD_INT 5
46271: PUSH
46272: EMPTY
46273: LIST
46274: LIST
46275: PUSH
46276: EMPTY
46277: LIST
46278: LIST
46279: LIST
46280: PUSH
46281: LD_INT 24
46283: PUSH
46284: LD_INT 25
46286: PUSH
46287: EMPTY
46288: LIST
46289: LIST
46290: PUSH
46291: LD_INT 23
46293: PUSH
46294: LD_INT 27
46296: PUSH
46297: EMPTY
46298: LIST
46299: LIST
46300: PUSH
46301: EMPTY
46302: LIST
46303: LIST
46304: PUSH
46305: LD_INT 42
46307: PUSH
46308: LD_INT 43
46310: PUSH
46311: EMPTY
46312: LIST
46313: LIST
46314: PUSH
46315: LD_INT 44
46317: PUSH
46318: LD_INT 46
46320: PUSH
46321: EMPTY
46322: LIST
46323: LIST
46324: PUSH
46325: LD_INT 45
46327: PUSH
46328: LD_INT 47
46330: PUSH
46331: EMPTY
46332: LIST
46333: LIST
46334: PUSH
46335: EMPTY
46336: LIST
46337: LIST
46338: LIST
46339: PUSH
46340: EMPTY
46341: LIST
46342: LIST
46343: LIST
46344: ST_TO_ADDR
// result := [ ] ;
46345: LD_ADDR_VAR 0 3
46349: PUSH
46350: EMPTY
46351: ST_TO_ADDR
// for i in turrets do
46352: LD_ADDR_VAR 0 4
46356: PUSH
46357: LD_VAR 0 1
46361: PUSH
46362: FOR_IN
46363: IFFALSE 46546
// begin nat := GetNation ( i ) ;
46365: LD_ADDR_VAR 0 7
46369: PUSH
46370: LD_VAR 0 4
46374: PPUSH
46375: CALL_OW 248
46379: ST_TO_ADDR
// weapon := 0 ;
46380: LD_ADDR_VAR 0 8
46384: PUSH
46385: LD_INT 0
46387: ST_TO_ADDR
// if not nat then
46388: LD_VAR 0 7
46392: NOT
46393: IFFALSE 46397
// continue ;
46395: GO 46362
// for j in list [ nat ] do
46397: LD_ADDR_VAR 0 5
46401: PUSH
46402: LD_VAR 0 10
46406: PUSH
46407: LD_VAR 0 7
46411: ARRAY
46412: PUSH
46413: FOR_IN
46414: IFFALSE 46455
// if GetBWeapon ( i ) = j [ 1 ] then
46416: LD_VAR 0 4
46420: PPUSH
46421: CALL_OW 269
46425: PUSH
46426: LD_VAR 0 5
46430: PUSH
46431: LD_INT 1
46433: ARRAY
46434: EQUAL
46435: IFFALSE 46453
// begin weapon := j [ 2 ] ;
46437: LD_ADDR_VAR 0 8
46441: PUSH
46442: LD_VAR 0 5
46446: PUSH
46447: LD_INT 2
46449: ARRAY
46450: ST_TO_ADDR
// break ;
46451: GO 46455
// end ;
46453: GO 46413
46455: POP
46456: POP
// if not weapon then
46457: LD_VAR 0 8
46461: NOT
46462: IFFALSE 46466
// continue ;
46464: GO 46362
// for k in factories do
46466: LD_ADDR_VAR 0 6
46470: PUSH
46471: LD_VAR 0 2
46475: PUSH
46476: FOR_IN
46477: IFFALSE 46542
// begin weapons := AvailableWeaponList ( k ) ;
46479: LD_ADDR_VAR 0 9
46483: PUSH
46484: LD_VAR 0 6
46488: PPUSH
46489: CALL_OW 478
46493: ST_TO_ADDR
// if not weapons then
46494: LD_VAR 0 9
46498: NOT
46499: IFFALSE 46503
// continue ;
46501: GO 46476
// if weapon in weapons then
46503: LD_VAR 0 8
46507: PUSH
46508: LD_VAR 0 9
46512: IN
46513: IFFALSE 46540
// begin result := [ i , weapon ] ;
46515: LD_ADDR_VAR 0 3
46519: PUSH
46520: LD_VAR 0 4
46524: PUSH
46525: LD_VAR 0 8
46529: PUSH
46530: EMPTY
46531: LIST
46532: LIST
46533: ST_TO_ADDR
// exit ;
46534: POP
46535: POP
46536: POP
46537: POP
46538: GO 46548
// end ; end ;
46540: GO 46476
46542: POP
46543: POP
// end ;
46544: GO 46362
46546: POP
46547: POP
// end ;
46548: LD_VAR 0 3
46552: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
46553: LD_INT 0
46555: PPUSH
// if not side or side > 8 then
46556: LD_VAR 0 3
46560: NOT
46561: PUSH
46562: LD_VAR 0 3
46566: PUSH
46567: LD_INT 8
46569: GREATER
46570: OR
46571: IFFALSE 46575
// exit ;
46573: GO 46634
// if not range then
46575: LD_VAR 0 4
46579: NOT
46580: IFFALSE 46591
// range := - 12 ;
46582: LD_ADDR_VAR 0 4
46586: PUSH
46587: LD_INT 12
46589: NEG
46590: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
46591: LD_VAR 0 1
46595: PPUSH
46596: LD_VAR 0 2
46600: PPUSH
46601: LD_VAR 0 3
46605: PPUSH
46606: LD_VAR 0 4
46610: PPUSH
46611: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
46615: LD_VAR 0 1
46619: PPUSH
46620: LD_VAR 0 2
46624: PPUSH
46625: LD_VAR 0 3
46629: PPUSH
46630: CALL_OW 331
// end ;
46634: LD_VAR 0 5
46638: RET
// export function Video ( mode ) ; begin
46639: LD_INT 0
46641: PPUSH
// ingame_video = mode ;
46642: LD_ADDR_OWVAR 52
46646: PUSH
46647: LD_VAR 0 1
46651: ST_TO_ADDR
// interface_hidden = mode ;
46652: LD_ADDR_OWVAR 54
46656: PUSH
46657: LD_VAR 0 1
46661: ST_TO_ADDR
// end ;
46662: LD_VAR 0 2
46666: RET
// export function Join ( array , element ) ; begin
46667: LD_INT 0
46669: PPUSH
// result := Replace ( array , array + 1 , element ) ;
46670: LD_ADDR_VAR 0 3
46674: PUSH
46675: LD_VAR 0 1
46679: PPUSH
46680: LD_VAR 0 1
46684: PUSH
46685: LD_INT 1
46687: PLUS
46688: PPUSH
46689: LD_VAR 0 2
46693: PPUSH
46694: CALL_OW 1
46698: ST_TO_ADDR
// end ;
46699: LD_VAR 0 3
46703: RET
// export function JoinUnion ( array , element ) ; begin
46704: LD_INT 0
46706: PPUSH
// result := array union element ;
46707: LD_ADDR_VAR 0 3
46711: PUSH
46712: LD_VAR 0 1
46716: PUSH
46717: LD_VAR 0 2
46721: UNION
46722: ST_TO_ADDR
// end ;
46723: LD_VAR 0 3
46727: RET
// export function GetBehemoths ( side ) ; begin
46728: LD_INT 0
46730: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
46731: LD_ADDR_VAR 0 2
46735: PUSH
46736: LD_INT 22
46738: PUSH
46739: LD_VAR 0 1
46743: PUSH
46744: EMPTY
46745: LIST
46746: LIST
46747: PUSH
46748: LD_INT 31
46750: PUSH
46751: LD_INT 25
46753: PUSH
46754: EMPTY
46755: LIST
46756: LIST
46757: PUSH
46758: EMPTY
46759: LIST
46760: LIST
46761: PPUSH
46762: CALL_OW 69
46766: ST_TO_ADDR
// end ;
46767: LD_VAR 0 2
46771: RET
// export function Shuffle ( array ) ; var i , index ; begin
46772: LD_INT 0
46774: PPUSH
46775: PPUSH
46776: PPUSH
// result := [ ] ;
46777: LD_ADDR_VAR 0 2
46781: PUSH
46782: EMPTY
46783: ST_TO_ADDR
// if not array then
46784: LD_VAR 0 1
46788: NOT
46789: IFFALSE 46793
// exit ;
46791: GO 46892
// Randomize ;
46793: CALL_OW 10
// for i = array downto 1 do
46797: LD_ADDR_VAR 0 3
46801: PUSH
46802: DOUBLE
46803: LD_VAR 0 1
46807: INC
46808: ST_TO_ADDR
46809: LD_INT 1
46811: PUSH
46812: FOR_DOWNTO
46813: IFFALSE 46890
// begin index := rand ( 1 , array ) ;
46815: LD_ADDR_VAR 0 4
46819: PUSH
46820: LD_INT 1
46822: PPUSH
46823: LD_VAR 0 1
46827: PPUSH
46828: CALL_OW 12
46832: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
46833: LD_ADDR_VAR 0 2
46837: PUSH
46838: LD_VAR 0 2
46842: PPUSH
46843: LD_VAR 0 2
46847: PUSH
46848: LD_INT 1
46850: PLUS
46851: PPUSH
46852: LD_VAR 0 1
46856: PUSH
46857: LD_VAR 0 4
46861: ARRAY
46862: PPUSH
46863: CALL_OW 2
46867: ST_TO_ADDR
// array := Delete ( array , index ) ;
46868: LD_ADDR_VAR 0 1
46872: PUSH
46873: LD_VAR 0 1
46877: PPUSH
46878: LD_VAR 0 4
46882: PPUSH
46883: CALL_OW 3
46887: ST_TO_ADDR
// end ;
46888: GO 46812
46890: POP
46891: POP
// end ;
46892: LD_VAR 0 2
46896: RET
// export function GetBaseMaterials ( base ) ; begin
46897: LD_INT 0
46899: PPUSH
// result := [ 0 , 0 , 0 ] ;
46900: LD_ADDR_VAR 0 2
46904: PUSH
46905: LD_INT 0
46907: PUSH
46908: LD_INT 0
46910: PUSH
46911: LD_INT 0
46913: PUSH
46914: EMPTY
46915: LIST
46916: LIST
46917: LIST
46918: ST_TO_ADDR
// if not base then
46919: LD_VAR 0 1
46923: NOT
46924: IFFALSE 46928
// exit ;
46926: GO 46977
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
46928: LD_ADDR_VAR 0 2
46932: PUSH
46933: LD_VAR 0 1
46937: PPUSH
46938: LD_INT 1
46940: PPUSH
46941: CALL_OW 275
46945: PUSH
46946: LD_VAR 0 1
46950: PPUSH
46951: LD_INT 2
46953: PPUSH
46954: CALL_OW 275
46958: PUSH
46959: LD_VAR 0 1
46963: PPUSH
46964: LD_INT 3
46966: PPUSH
46967: CALL_OW 275
46971: PUSH
46972: EMPTY
46973: LIST
46974: LIST
46975: LIST
46976: ST_TO_ADDR
// end ;
46977: LD_VAR 0 2
46981: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
46982: LD_INT 0
46984: PPUSH
46985: PPUSH
// result := array ;
46986: LD_ADDR_VAR 0 3
46990: PUSH
46991: LD_VAR 0 1
46995: ST_TO_ADDR
// if size > 0 then
46996: LD_VAR 0 2
47000: PUSH
47001: LD_INT 0
47003: GREATER
47004: IFFALSE 47050
// for i := array downto size do
47006: LD_ADDR_VAR 0 4
47010: PUSH
47011: DOUBLE
47012: LD_VAR 0 1
47016: INC
47017: ST_TO_ADDR
47018: LD_VAR 0 2
47022: PUSH
47023: FOR_DOWNTO
47024: IFFALSE 47048
// result := Delete ( result , result ) ;
47026: LD_ADDR_VAR 0 3
47030: PUSH
47031: LD_VAR 0 3
47035: PPUSH
47036: LD_VAR 0 3
47040: PPUSH
47041: CALL_OW 3
47045: ST_TO_ADDR
47046: GO 47023
47048: POP
47049: POP
// end ;
47050: LD_VAR 0 3
47054: RET
// export function ComExit ( unit ) ; var tmp ; begin
47055: LD_INT 0
47057: PPUSH
47058: PPUSH
// if not IsInUnit ( unit ) then
47059: LD_VAR 0 1
47063: PPUSH
47064: CALL_OW 310
47068: NOT
47069: IFFALSE 47073
// exit ;
47071: GO 47133
// tmp := IsInUnit ( unit ) ;
47073: LD_ADDR_VAR 0 3
47077: PUSH
47078: LD_VAR 0 1
47082: PPUSH
47083: CALL_OW 310
47087: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
47088: LD_VAR 0 3
47092: PPUSH
47093: CALL_OW 247
47097: PUSH
47098: LD_INT 2
47100: EQUAL
47101: IFFALSE 47114
// ComExitVehicle ( unit ) else
47103: LD_VAR 0 1
47107: PPUSH
47108: CALL_OW 121
47112: GO 47123
// ComExitBuilding ( unit ) ;
47114: LD_VAR 0 1
47118: PPUSH
47119: CALL_OW 122
// result := tmp ;
47123: LD_ADDR_VAR 0 2
47127: PUSH
47128: LD_VAR 0 3
47132: ST_TO_ADDR
// end ;
47133: LD_VAR 0 2
47137: RET
// export function ComExitAll ( units ) ; var i ; begin
47138: LD_INT 0
47140: PPUSH
47141: PPUSH
// if not units then
47142: LD_VAR 0 1
47146: NOT
47147: IFFALSE 47151
// exit ;
47149: GO 47177
// for i in units do
47151: LD_ADDR_VAR 0 3
47155: PUSH
47156: LD_VAR 0 1
47160: PUSH
47161: FOR_IN
47162: IFFALSE 47175
// ComExit ( i ) ;
47164: LD_VAR 0 3
47168: PPUSH
47169: CALL 47055 0 1
47173: GO 47161
47175: POP
47176: POP
// end ;
47177: LD_VAR 0 2
47181: RET
// export function ResetHc ; begin
47182: LD_INT 0
47184: PPUSH
// InitHc ;
47185: CALL_OW 19
// hc_importance := 0 ;
47189: LD_ADDR_OWVAR 32
47193: PUSH
47194: LD_INT 0
47196: ST_TO_ADDR
// end ;
47197: LD_VAR 0 1
47201: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
47202: LD_INT 0
47204: PPUSH
47205: PPUSH
47206: PPUSH
// _x := ( x1 + x2 ) div 2 ;
47207: LD_ADDR_VAR 0 6
47211: PUSH
47212: LD_VAR 0 1
47216: PUSH
47217: LD_VAR 0 3
47221: PLUS
47222: PUSH
47223: LD_INT 2
47225: DIV
47226: ST_TO_ADDR
// if _x < 0 then
47227: LD_VAR 0 6
47231: PUSH
47232: LD_INT 0
47234: LESS
47235: IFFALSE 47252
// _x := _x * - 1 ;
47237: LD_ADDR_VAR 0 6
47241: PUSH
47242: LD_VAR 0 6
47246: PUSH
47247: LD_INT 1
47249: NEG
47250: MUL
47251: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
47252: LD_ADDR_VAR 0 7
47256: PUSH
47257: LD_VAR 0 2
47261: PUSH
47262: LD_VAR 0 4
47266: PLUS
47267: PUSH
47268: LD_INT 2
47270: DIV
47271: ST_TO_ADDR
// if _y < 0 then
47272: LD_VAR 0 7
47276: PUSH
47277: LD_INT 0
47279: LESS
47280: IFFALSE 47297
// _y := _y * - 1 ;
47282: LD_ADDR_VAR 0 7
47286: PUSH
47287: LD_VAR 0 7
47291: PUSH
47292: LD_INT 1
47294: NEG
47295: MUL
47296: ST_TO_ADDR
// result := [ _x , _y ] ;
47297: LD_ADDR_VAR 0 5
47301: PUSH
47302: LD_VAR 0 6
47306: PUSH
47307: LD_VAR 0 7
47311: PUSH
47312: EMPTY
47313: LIST
47314: LIST
47315: ST_TO_ADDR
// end ;
47316: LD_VAR 0 5
47320: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
47321: LD_INT 0
47323: PPUSH
47324: PPUSH
47325: PPUSH
47326: PPUSH
// task := GetTaskList ( unit ) ;
47327: LD_ADDR_VAR 0 7
47331: PUSH
47332: LD_VAR 0 1
47336: PPUSH
47337: CALL_OW 437
47341: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
47342: LD_VAR 0 7
47346: NOT
47347: PUSH
47348: LD_VAR 0 1
47352: PPUSH
47353: LD_VAR 0 2
47357: PPUSH
47358: CALL_OW 308
47362: NOT
47363: AND
47364: IFFALSE 47368
// exit ;
47366: GO 47486
// if IsInArea ( unit , area ) then
47368: LD_VAR 0 1
47372: PPUSH
47373: LD_VAR 0 2
47377: PPUSH
47378: CALL_OW 308
47382: IFFALSE 47400
// begin ComMoveToArea ( unit , goAway ) ;
47384: LD_VAR 0 1
47388: PPUSH
47389: LD_VAR 0 3
47393: PPUSH
47394: CALL_OW 113
// exit ;
47398: GO 47486
// end ; if task [ 1 ] [ 1 ] <> M then
47400: LD_VAR 0 7
47404: PUSH
47405: LD_INT 1
47407: ARRAY
47408: PUSH
47409: LD_INT 1
47411: ARRAY
47412: PUSH
47413: LD_STRING M
47415: NONEQUAL
47416: IFFALSE 47420
// exit ;
47418: GO 47486
// x := task [ 1 ] [ 2 ] ;
47420: LD_ADDR_VAR 0 5
47424: PUSH
47425: LD_VAR 0 7
47429: PUSH
47430: LD_INT 1
47432: ARRAY
47433: PUSH
47434: LD_INT 2
47436: ARRAY
47437: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
47438: LD_ADDR_VAR 0 6
47442: PUSH
47443: LD_VAR 0 7
47447: PUSH
47448: LD_INT 1
47450: ARRAY
47451: PUSH
47452: LD_INT 3
47454: ARRAY
47455: ST_TO_ADDR
// if InArea ( x , y , area ) then
47456: LD_VAR 0 5
47460: PPUSH
47461: LD_VAR 0 6
47465: PPUSH
47466: LD_VAR 0 2
47470: PPUSH
47471: CALL_OW 309
47475: IFFALSE 47486
// ComStop ( unit ) ;
47477: LD_VAR 0 1
47481: PPUSH
47482: CALL_OW 141
// end ;
47486: LD_VAR 0 4
47490: RET
// export function Abs ( value ) ; begin
47491: LD_INT 0
47493: PPUSH
// result := value ;
47494: LD_ADDR_VAR 0 2
47498: PUSH
47499: LD_VAR 0 1
47503: ST_TO_ADDR
// if value < 0 then
47504: LD_VAR 0 1
47508: PUSH
47509: LD_INT 0
47511: LESS
47512: IFFALSE 47529
// result := value * - 1 ;
47514: LD_ADDR_VAR 0 2
47518: PUSH
47519: LD_VAR 0 1
47523: PUSH
47524: LD_INT 1
47526: NEG
47527: MUL
47528: ST_TO_ADDR
// end ;
47529: LD_VAR 0 2
47533: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
47534: LD_INT 0
47536: PPUSH
47537: PPUSH
47538: PPUSH
47539: PPUSH
47540: PPUSH
47541: PPUSH
47542: PPUSH
47543: PPUSH
// if not unit or not building then
47544: LD_VAR 0 1
47548: NOT
47549: PUSH
47550: LD_VAR 0 2
47554: NOT
47555: OR
47556: IFFALSE 47560
// exit ;
47558: GO 47786
// x := GetX ( building ) ;
47560: LD_ADDR_VAR 0 4
47564: PUSH
47565: LD_VAR 0 2
47569: PPUSH
47570: CALL_OW 250
47574: ST_TO_ADDR
// y := GetY ( building ) ;
47575: LD_ADDR_VAR 0 6
47579: PUSH
47580: LD_VAR 0 2
47584: PPUSH
47585: CALL_OW 251
47589: ST_TO_ADDR
// d := GetDir ( building ) ;
47590: LD_ADDR_VAR 0 8
47594: PUSH
47595: LD_VAR 0 2
47599: PPUSH
47600: CALL_OW 254
47604: ST_TO_ADDR
// r := 4 ;
47605: LD_ADDR_VAR 0 9
47609: PUSH
47610: LD_INT 4
47612: ST_TO_ADDR
// for i := 1 to 5 do
47613: LD_ADDR_VAR 0 10
47617: PUSH
47618: DOUBLE
47619: LD_INT 1
47621: DEC
47622: ST_TO_ADDR
47623: LD_INT 5
47625: PUSH
47626: FOR_TO
47627: IFFALSE 47784
// begin _x := ShiftX ( x , d , r + i ) ;
47629: LD_ADDR_VAR 0 5
47633: PUSH
47634: LD_VAR 0 4
47638: PPUSH
47639: LD_VAR 0 8
47643: PPUSH
47644: LD_VAR 0 9
47648: PUSH
47649: LD_VAR 0 10
47653: PLUS
47654: PPUSH
47655: CALL_OW 272
47659: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
47660: LD_ADDR_VAR 0 7
47664: PUSH
47665: LD_VAR 0 6
47669: PPUSH
47670: LD_VAR 0 8
47674: PPUSH
47675: LD_VAR 0 9
47679: PUSH
47680: LD_VAR 0 10
47684: PLUS
47685: PPUSH
47686: CALL_OW 273
47690: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
47691: LD_VAR 0 5
47695: PPUSH
47696: LD_VAR 0 7
47700: PPUSH
47701: CALL_OW 488
47705: PUSH
47706: LD_VAR 0 5
47710: PPUSH
47711: LD_VAR 0 7
47715: PPUSH
47716: CALL_OW 428
47720: PPUSH
47721: CALL_OW 247
47725: PUSH
47726: LD_INT 3
47728: PUSH
47729: LD_INT 2
47731: PUSH
47732: EMPTY
47733: LIST
47734: LIST
47735: IN
47736: NOT
47737: AND
47738: IFFALSE 47782
// begin ComMoveXY ( unit , _x , _y ) ;
47740: LD_VAR 0 1
47744: PPUSH
47745: LD_VAR 0 5
47749: PPUSH
47750: LD_VAR 0 7
47754: PPUSH
47755: CALL_OW 111
// result := [ _x , _y ] ;
47759: LD_ADDR_VAR 0 3
47763: PUSH
47764: LD_VAR 0 5
47768: PUSH
47769: LD_VAR 0 7
47773: PUSH
47774: EMPTY
47775: LIST
47776: LIST
47777: ST_TO_ADDR
// exit ;
47778: POP
47779: POP
47780: GO 47786
// end ; end ;
47782: GO 47626
47784: POP
47785: POP
// end ;
47786: LD_VAR 0 3
47790: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
47791: LD_INT 0
47793: PPUSH
47794: PPUSH
47795: PPUSH
// result := 0 ;
47796: LD_ADDR_VAR 0 3
47800: PUSH
47801: LD_INT 0
47803: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
47804: LD_VAR 0 1
47808: PUSH
47809: LD_INT 0
47811: LESS
47812: PUSH
47813: LD_VAR 0 1
47817: PUSH
47818: LD_INT 8
47820: GREATER
47821: OR
47822: PUSH
47823: LD_VAR 0 2
47827: PUSH
47828: LD_INT 0
47830: LESS
47831: OR
47832: PUSH
47833: LD_VAR 0 2
47837: PUSH
47838: LD_INT 8
47840: GREATER
47841: OR
47842: IFFALSE 47846
// exit ;
47844: GO 47921
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
47846: LD_ADDR_VAR 0 4
47850: PUSH
47851: LD_INT 22
47853: PUSH
47854: LD_VAR 0 2
47858: PUSH
47859: EMPTY
47860: LIST
47861: LIST
47862: PPUSH
47863: CALL_OW 69
47867: PUSH
47868: FOR_IN
47869: IFFALSE 47919
// begin un := UnitShoot ( i ) ;
47871: LD_ADDR_VAR 0 5
47875: PUSH
47876: LD_VAR 0 4
47880: PPUSH
47881: CALL_OW 504
47885: ST_TO_ADDR
// if GetSide ( un ) = side1 then
47886: LD_VAR 0 5
47890: PPUSH
47891: CALL_OW 255
47895: PUSH
47896: LD_VAR 0 1
47900: EQUAL
47901: IFFALSE 47917
// begin result := un ;
47903: LD_ADDR_VAR 0 3
47907: PUSH
47908: LD_VAR 0 5
47912: ST_TO_ADDR
// exit ;
47913: POP
47914: POP
47915: GO 47921
// end ; end ;
47917: GO 47868
47919: POP
47920: POP
// end ;
47921: LD_VAR 0 3
47925: RET
// export function GetCargoBay ( units ) ; begin
47926: LD_INT 0
47928: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
47929: LD_ADDR_VAR 0 2
47933: PUSH
47934: LD_VAR 0 1
47938: PPUSH
47939: LD_INT 2
47941: PUSH
47942: LD_INT 34
47944: PUSH
47945: LD_INT 12
47947: PUSH
47948: EMPTY
47949: LIST
47950: LIST
47951: PUSH
47952: LD_INT 34
47954: PUSH
47955: LD_INT 51
47957: PUSH
47958: EMPTY
47959: LIST
47960: LIST
47961: PUSH
47962: LD_INT 34
47964: PUSH
47965: LD_INT 32
47967: PUSH
47968: EMPTY
47969: LIST
47970: LIST
47971: PUSH
47972: LD_INT 34
47974: PUSH
47975: LD_EXP 68
47979: PUSH
47980: EMPTY
47981: LIST
47982: LIST
47983: PUSH
47984: EMPTY
47985: LIST
47986: LIST
47987: LIST
47988: LIST
47989: LIST
47990: PPUSH
47991: CALL_OW 72
47995: ST_TO_ADDR
// end ;
47996: LD_VAR 0 2
48000: RET
// export function Negate ( value ) ; begin
48001: LD_INT 0
48003: PPUSH
// result := not value ;
48004: LD_ADDR_VAR 0 2
48008: PUSH
48009: LD_VAR 0 1
48013: NOT
48014: ST_TO_ADDR
// end ;
48015: LD_VAR 0 2
48019: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; begin
48020: LD_INT 0
48022: PPUSH
// if x1 = x2 then
48023: LD_VAR 0 1
48027: PUSH
48028: LD_VAR 0 3
48032: EQUAL
48033: IFFALSE 48067
// begin if y1 > y2 then
48035: LD_VAR 0 2
48039: PUSH
48040: LD_VAR 0 4
48044: GREATER
48045: IFFALSE 48057
// result := 0 else
48047: LD_ADDR_VAR 0 5
48051: PUSH
48052: LD_INT 0
48054: ST_TO_ADDR
48055: GO 48065
// result := 3 ;
48057: LD_ADDR_VAR 0 5
48061: PUSH
48062: LD_INT 3
48064: ST_TO_ADDR
// exit ;
48065: GO 48153
// end ; if y1 = y2 then
48067: LD_VAR 0 2
48071: PUSH
48072: LD_VAR 0 4
48076: EQUAL
48077: IFFALSE 48111
// begin if x1 > x2 then
48079: LD_VAR 0 1
48083: PUSH
48084: LD_VAR 0 3
48088: GREATER
48089: IFFALSE 48101
// result := 1 else
48091: LD_ADDR_VAR 0 5
48095: PUSH
48096: LD_INT 1
48098: ST_TO_ADDR
48099: GO 48109
// result := 4 ;
48101: LD_ADDR_VAR 0 5
48105: PUSH
48106: LD_INT 4
48108: ST_TO_ADDR
// exit ;
48109: GO 48153
// end ; if x1 > x2 and y1 > y2 then
48111: LD_VAR 0 1
48115: PUSH
48116: LD_VAR 0 3
48120: GREATER
48121: PUSH
48122: LD_VAR 0 2
48126: PUSH
48127: LD_VAR 0 4
48131: GREATER
48132: AND
48133: IFFALSE 48145
// result := 2 else
48135: LD_ADDR_VAR 0 5
48139: PUSH
48140: LD_INT 2
48142: ST_TO_ADDR
48143: GO 48153
// result := 5 ;
48145: LD_ADDR_VAR 0 5
48149: PUSH
48150: LD_INT 5
48152: ST_TO_ADDR
// end ;
48153: LD_VAR 0 5
48157: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
48158: LD_INT 0
48160: PPUSH
48161: PPUSH
// if not driver or not IsInUnit ( driver ) then
48162: LD_VAR 0 1
48166: NOT
48167: PUSH
48168: LD_VAR 0 1
48172: PPUSH
48173: CALL_OW 310
48177: NOT
48178: OR
48179: IFFALSE 48183
// exit ;
48181: GO 48273
// vehicle := IsInUnit ( driver ) ;
48183: LD_ADDR_VAR 0 3
48187: PUSH
48188: LD_VAR 0 1
48192: PPUSH
48193: CALL_OW 310
48197: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
48198: LD_VAR 0 1
48202: PPUSH
48203: LD_STRING \
48205: PUSH
48206: LD_INT 0
48208: PUSH
48209: LD_INT 0
48211: PUSH
48212: LD_INT 0
48214: PUSH
48215: LD_INT 0
48217: PUSH
48218: LD_INT 0
48220: PUSH
48221: LD_INT 0
48223: PUSH
48224: EMPTY
48225: LIST
48226: LIST
48227: LIST
48228: LIST
48229: LIST
48230: LIST
48231: LIST
48232: PUSH
48233: LD_STRING E
48235: PUSH
48236: LD_INT 0
48238: PUSH
48239: LD_INT 0
48241: PUSH
48242: LD_VAR 0 3
48246: PUSH
48247: LD_INT 0
48249: PUSH
48250: LD_INT 0
48252: PUSH
48253: LD_INT 0
48255: PUSH
48256: EMPTY
48257: LIST
48258: LIST
48259: LIST
48260: LIST
48261: LIST
48262: LIST
48263: LIST
48264: PUSH
48265: EMPTY
48266: LIST
48267: LIST
48268: PPUSH
48269: CALL_OW 446
// end ;
48273: LD_VAR 0 2
48277: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
48278: LD_INT 0
48280: PPUSH
48281: PPUSH
48282: PPUSH
// tmp := [ ] ;
48283: LD_ADDR_VAR 0 5
48287: PUSH
48288: EMPTY
48289: ST_TO_ADDR
// for i in units do
48290: LD_ADDR_VAR 0 4
48294: PUSH
48295: LD_VAR 0 1
48299: PUSH
48300: FOR_IN
48301: IFFALSE 48339
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
48303: LD_ADDR_VAR 0 5
48307: PUSH
48308: LD_VAR 0 5
48312: PPUSH
48313: LD_VAR 0 5
48317: PUSH
48318: LD_INT 1
48320: PLUS
48321: PPUSH
48322: LD_VAR 0 4
48326: PPUSH
48327: CALL_OW 256
48331: PPUSH
48332: CALL_OW 2
48336: ST_TO_ADDR
48337: GO 48300
48339: POP
48340: POP
// if not tmp then
48341: LD_VAR 0 5
48345: NOT
48346: IFFALSE 48350
// exit ;
48348: GO 48398
// if asc then
48350: LD_VAR 0 2
48354: IFFALSE 48378
// result := SortListByListAsc ( units , tmp ) else
48356: LD_ADDR_VAR 0 3
48360: PUSH
48361: LD_VAR 0 1
48365: PPUSH
48366: LD_VAR 0 5
48370: PPUSH
48371: CALL_OW 76
48375: ST_TO_ADDR
48376: GO 48398
// result := SortListByListDesc ( units , tmp ) ;
48378: LD_ADDR_VAR 0 3
48382: PUSH
48383: LD_VAR 0 1
48387: PPUSH
48388: LD_VAR 0 5
48392: PPUSH
48393: CALL_OW 77
48397: ST_TO_ADDR
// end ;
48398: LD_VAR 0 3
48402: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
48403: LD_INT 0
48405: PPUSH
48406: PPUSH
// task := GetTaskList ( mech ) ;
48407: LD_ADDR_VAR 0 4
48411: PUSH
48412: LD_VAR 0 1
48416: PPUSH
48417: CALL_OW 437
48421: ST_TO_ADDR
// if not task then
48422: LD_VAR 0 4
48426: NOT
48427: IFFALSE 48431
// exit ;
48429: GO 48473
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
48431: LD_ADDR_VAR 0 3
48435: PUSH
48436: LD_VAR 0 4
48440: PUSH
48441: LD_INT 1
48443: ARRAY
48444: PUSH
48445: LD_INT 1
48447: ARRAY
48448: PUSH
48449: LD_STRING r
48451: EQUAL
48452: PUSH
48453: LD_VAR 0 4
48457: PUSH
48458: LD_INT 1
48460: ARRAY
48461: PUSH
48462: LD_INT 4
48464: ARRAY
48465: PUSH
48466: LD_VAR 0 2
48470: EQUAL
48471: AND
48472: ST_TO_ADDR
// end ;
48473: LD_VAR 0 3
48477: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
48478: LD_INT 0
48480: PPUSH
// SetDir ( unit , d ) ;
48481: LD_VAR 0 1
48485: PPUSH
48486: LD_VAR 0 4
48490: PPUSH
48491: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
48495: LD_VAR 0 1
48499: PPUSH
48500: LD_VAR 0 2
48504: PPUSH
48505: LD_VAR 0 3
48509: PPUSH
48510: LD_VAR 0 5
48514: PPUSH
48515: CALL_OW 48
// end ; end_of_file
48519: LD_VAR 0 6
48523: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
48524: LD_INT 0
48526: PPUSH
48527: PPUSH
// skirmish := false ;
48528: LD_ADDR_EXP 21
48532: PUSH
48533: LD_INT 0
48535: ST_TO_ADDR
// debug_mc := false ;
48536: LD_ADDR_EXP 22
48540: PUSH
48541: LD_INT 0
48543: ST_TO_ADDR
// mc_bases := [ ] ;
48544: LD_ADDR_EXP 23
48548: PUSH
48549: EMPTY
48550: ST_TO_ADDR
// mc_sides := [ ] ;
48551: LD_ADDR_EXP 49
48555: PUSH
48556: EMPTY
48557: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
48558: LD_ADDR_EXP 24
48562: PUSH
48563: EMPTY
48564: ST_TO_ADDR
// mc_building_repairs := [ ] ;
48565: LD_ADDR_EXP 25
48569: PUSH
48570: EMPTY
48571: ST_TO_ADDR
// mc_need_heal := [ ] ;
48572: LD_ADDR_EXP 26
48576: PUSH
48577: EMPTY
48578: ST_TO_ADDR
// mc_healers := [ ] ;
48579: LD_ADDR_EXP 27
48583: PUSH
48584: EMPTY
48585: ST_TO_ADDR
// mc_build_list := [ ] ;
48586: LD_ADDR_EXP 28
48590: PUSH
48591: EMPTY
48592: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
48593: LD_ADDR_EXP 55
48597: PUSH
48598: EMPTY
48599: ST_TO_ADDR
// mc_builders := [ ] ;
48600: LD_ADDR_EXP 29
48604: PUSH
48605: EMPTY
48606: ST_TO_ADDR
// mc_construct_list := [ ] ;
48607: LD_ADDR_EXP 30
48611: PUSH
48612: EMPTY
48613: ST_TO_ADDR
// mc_turret_list := [ ] ;
48614: LD_ADDR_EXP 31
48618: PUSH
48619: EMPTY
48620: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
48621: LD_ADDR_EXP 32
48625: PUSH
48626: EMPTY
48627: ST_TO_ADDR
// mc_miners := [ ] ;
48628: LD_ADDR_EXP 37
48632: PUSH
48633: EMPTY
48634: ST_TO_ADDR
// mc_mines := [ ] ;
48635: LD_ADDR_EXP 36
48639: PUSH
48640: EMPTY
48641: ST_TO_ADDR
// mc_minefields := [ ] ;
48642: LD_ADDR_EXP 38
48646: PUSH
48647: EMPTY
48648: ST_TO_ADDR
// mc_crates := [ ] ;
48649: LD_ADDR_EXP 39
48653: PUSH
48654: EMPTY
48655: ST_TO_ADDR
// mc_crates_collector := [ ] ;
48656: LD_ADDR_EXP 40
48660: PUSH
48661: EMPTY
48662: ST_TO_ADDR
// mc_crates_area := [ ] ;
48663: LD_ADDR_EXP 41
48667: PUSH
48668: EMPTY
48669: ST_TO_ADDR
// mc_vehicles := [ ] ;
48670: LD_ADDR_EXP 42
48674: PUSH
48675: EMPTY
48676: ST_TO_ADDR
// mc_attack := [ ] ;
48677: LD_ADDR_EXP 43
48681: PUSH
48682: EMPTY
48683: ST_TO_ADDR
// mc_produce := [ ] ;
48684: LD_ADDR_EXP 44
48688: PUSH
48689: EMPTY
48690: ST_TO_ADDR
// mc_defender := [ ] ;
48691: LD_ADDR_EXP 45
48695: PUSH
48696: EMPTY
48697: ST_TO_ADDR
// mc_parking := [ ] ;
48698: LD_ADDR_EXP 47
48702: PUSH
48703: EMPTY
48704: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
48705: LD_ADDR_EXP 33
48709: PUSH
48710: EMPTY
48711: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
48712: LD_ADDR_EXP 35
48716: PUSH
48717: EMPTY
48718: ST_TO_ADDR
// mc_scan := [ ] ;
48719: LD_ADDR_EXP 46
48723: PUSH
48724: EMPTY
48725: ST_TO_ADDR
// mc_scan_area := [ ] ;
48726: LD_ADDR_EXP 48
48730: PUSH
48731: EMPTY
48732: ST_TO_ADDR
// mc_tech := [ ] ;
48733: LD_ADDR_EXP 50
48737: PUSH
48738: EMPTY
48739: ST_TO_ADDR
// mc_class := [ ] ;
48740: LD_ADDR_EXP 64
48744: PUSH
48745: EMPTY
48746: ST_TO_ADDR
// mc_class_case_use := [ ] ;
48747: LD_ADDR_EXP 65
48751: PUSH
48752: EMPTY
48753: ST_TO_ADDR
// mc_is_defending := [ ] ;
48754: LD_ADDR_EXP 66
48758: PUSH
48759: EMPTY
48760: ST_TO_ADDR
// end ;
48761: LD_VAR 0 1
48765: RET
// export function MC_Kill ( base ) ; begin
48766: LD_INT 0
48768: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
48769: LD_ADDR_EXP 23
48773: PUSH
48774: LD_EXP 23
48778: PPUSH
48779: LD_VAR 0 1
48783: PPUSH
48784: EMPTY
48785: PPUSH
48786: CALL_OW 1
48790: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
48791: LD_ADDR_EXP 24
48795: PUSH
48796: LD_EXP 24
48800: PPUSH
48801: LD_VAR 0 1
48805: PPUSH
48806: EMPTY
48807: PPUSH
48808: CALL_OW 1
48812: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
48813: LD_ADDR_EXP 25
48817: PUSH
48818: LD_EXP 25
48822: PPUSH
48823: LD_VAR 0 1
48827: PPUSH
48828: EMPTY
48829: PPUSH
48830: CALL_OW 1
48834: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
48835: LD_ADDR_EXP 26
48839: PUSH
48840: LD_EXP 26
48844: PPUSH
48845: LD_VAR 0 1
48849: PPUSH
48850: EMPTY
48851: PPUSH
48852: CALL_OW 1
48856: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
48857: LD_ADDR_EXP 27
48861: PUSH
48862: LD_EXP 27
48866: PPUSH
48867: LD_VAR 0 1
48871: PPUSH
48872: EMPTY
48873: PPUSH
48874: CALL_OW 1
48878: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
48879: LD_ADDR_EXP 28
48883: PUSH
48884: LD_EXP 28
48888: PPUSH
48889: LD_VAR 0 1
48893: PPUSH
48894: EMPTY
48895: PPUSH
48896: CALL_OW 1
48900: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
48901: LD_ADDR_EXP 29
48905: PUSH
48906: LD_EXP 29
48910: PPUSH
48911: LD_VAR 0 1
48915: PPUSH
48916: EMPTY
48917: PPUSH
48918: CALL_OW 1
48922: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
48923: LD_ADDR_EXP 30
48927: PUSH
48928: LD_EXP 30
48932: PPUSH
48933: LD_VAR 0 1
48937: PPUSH
48938: EMPTY
48939: PPUSH
48940: CALL_OW 1
48944: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
48945: LD_ADDR_EXP 31
48949: PUSH
48950: LD_EXP 31
48954: PPUSH
48955: LD_VAR 0 1
48959: PPUSH
48960: EMPTY
48961: PPUSH
48962: CALL_OW 1
48966: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
48967: LD_ADDR_EXP 32
48971: PUSH
48972: LD_EXP 32
48976: PPUSH
48977: LD_VAR 0 1
48981: PPUSH
48982: EMPTY
48983: PPUSH
48984: CALL_OW 1
48988: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
48989: LD_ADDR_EXP 33
48993: PUSH
48994: LD_EXP 33
48998: PPUSH
48999: LD_VAR 0 1
49003: PPUSH
49004: EMPTY
49005: PPUSH
49006: CALL_OW 1
49010: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
49011: LD_ADDR_EXP 34
49015: PUSH
49016: LD_EXP 34
49020: PPUSH
49021: LD_VAR 0 1
49025: PPUSH
49026: LD_INT 0
49028: PPUSH
49029: CALL_OW 1
49033: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
49034: LD_ADDR_EXP 35
49038: PUSH
49039: LD_EXP 35
49043: PPUSH
49044: LD_VAR 0 1
49048: PPUSH
49049: EMPTY
49050: PPUSH
49051: CALL_OW 1
49055: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
49056: LD_ADDR_EXP 36
49060: PUSH
49061: LD_EXP 36
49065: PPUSH
49066: LD_VAR 0 1
49070: PPUSH
49071: EMPTY
49072: PPUSH
49073: CALL_OW 1
49077: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
49078: LD_ADDR_EXP 37
49082: PUSH
49083: LD_EXP 37
49087: PPUSH
49088: LD_VAR 0 1
49092: PPUSH
49093: EMPTY
49094: PPUSH
49095: CALL_OW 1
49099: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
49100: LD_ADDR_EXP 38
49104: PUSH
49105: LD_EXP 38
49109: PPUSH
49110: LD_VAR 0 1
49114: PPUSH
49115: EMPTY
49116: PPUSH
49117: CALL_OW 1
49121: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
49122: LD_ADDR_EXP 39
49126: PUSH
49127: LD_EXP 39
49131: PPUSH
49132: LD_VAR 0 1
49136: PPUSH
49137: EMPTY
49138: PPUSH
49139: CALL_OW 1
49143: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
49144: LD_ADDR_EXP 40
49148: PUSH
49149: LD_EXP 40
49153: PPUSH
49154: LD_VAR 0 1
49158: PPUSH
49159: EMPTY
49160: PPUSH
49161: CALL_OW 1
49165: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
49166: LD_ADDR_EXP 41
49170: PUSH
49171: LD_EXP 41
49175: PPUSH
49176: LD_VAR 0 1
49180: PPUSH
49181: EMPTY
49182: PPUSH
49183: CALL_OW 1
49187: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
49188: LD_ADDR_EXP 42
49192: PUSH
49193: LD_EXP 42
49197: PPUSH
49198: LD_VAR 0 1
49202: PPUSH
49203: EMPTY
49204: PPUSH
49205: CALL_OW 1
49209: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
49210: LD_ADDR_EXP 43
49214: PUSH
49215: LD_EXP 43
49219: PPUSH
49220: LD_VAR 0 1
49224: PPUSH
49225: EMPTY
49226: PPUSH
49227: CALL_OW 1
49231: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
49232: LD_ADDR_EXP 44
49236: PUSH
49237: LD_EXP 44
49241: PPUSH
49242: LD_VAR 0 1
49246: PPUSH
49247: EMPTY
49248: PPUSH
49249: CALL_OW 1
49253: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
49254: LD_ADDR_EXP 45
49258: PUSH
49259: LD_EXP 45
49263: PPUSH
49264: LD_VAR 0 1
49268: PPUSH
49269: EMPTY
49270: PPUSH
49271: CALL_OW 1
49275: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
49276: LD_ADDR_EXP 46
49280: PUSH
49281: LD_EXP 46
49285: PPUSH
49286: LD_VAR 0 1
49290: PPUSH
49291: EMPTY
49292: PPUSH
49293: CALL_OW 1
49297: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
49298: LD_ADDR_EXP 47
49302: PUSH
49303: LD_EXP 47
49307: PPUSH
49308: LD_VAR 0 1
49312: PPUSH
49313: EMPTY
49314: PPUSH
49315: CALL_OW 1
49319: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
49320: LD_ADDR_EXP 48
49324: PUSH
49325: LD_EXP 48
49329: PPUSH
49330: LD_VAR 0 1
49334: PPUSH
49335: EMPTY
49336: PPUSH
49337: CALL_OW 1
49341: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
49342: LD_ADDR_EXP 50
49346: PUSH
49347: LD_EXP 50
49351: PPUSH
49352: LD_VAR 0 1
49356: PPUSH
49357: EMPTY
49358: PPUSH
49359: CALL_OW 1
49363: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
49364: LD_ADDR_EXP 52
49368: PUSH
49369: LD_EXP 52
49373: PPUSH
49374: LD_VAR 0 1
49378: PPUSH
49379: EMPTY
49380: PPUSH
49381: CALL_OW 1
49385: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
49386: LD_ADDR_EXP 53
49390: PUSH
49391: LD_EXP 53
49395: PPUSH
49396: LD_VAR 0 1
49400: PPUSH
49401: EMPTY
49402: PPUSH
49403: CALL_OW 1
49407: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
49408: LD_ADDR_EXP 54
49412: PUSH
49413: LD_EXP 54
49417: PPUSH
49418: LD_VAR 0 1
49422: PPUSH
49423: EMPTY
49424: PPUSH
49425: CALL_OW 1
49429: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
49430: LD_ADDR_EXP 55
49434: PUSH
49435: LD_EXP 55
49439: PPUSH
49440: LD_VAR 0 1
49444: PPUSH
49445: EMPTY
49446: PPUSH
49447: CALL_OW 1
49451: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
49452: LD_ADDR_EXP 56
49456: PUSH
49457: LD_EXP 56
49461: PPUSH
49462: LD_VAR 0 1
49466: PPUSH
49467: EMPTY
49468: PPUSH
49469: CALL_OW 1
49473: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
49474: LD_ADDR_EXP 57
49478: PUSH
49479: LD_EXP 57
49483: PPUSH
49484: LD_VAR 0 1
49488: PPUSH
49489: EMPTY
49490: PPUSH
49491: CALL_OW 1
49495: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
49496: LD_ADDR_EXP 58
49500: PUSH
49501: LD_EXP 58
49505: PPUSH
49506: LD_VAR 0 1
49510: PPUSH
49511: EMPTY
49512: PPUSH
49513: CALL_OW 1
49517: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
49518: LD_ADDR_EXP 59
49522: PUSH
49523: LD_EXP 59
49527: PPUSH
49528: LD_VAR 0 1
49532: PPUSH
49533: EMPTY
49534: PPUSH
49535: CALL_OW 1
49539: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
49540: LD_ADDR_EXP 60
49544: PUSH
49545: LD_EXP 60
49549: PPUSH
49550: LD_VAR 0 1
49554: PPUSH
49555: EMPTY
49556: PPUSH
49557: CALL_OW 1
49561: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
49562: LD_ADDR_EXP 61
49566: PUSH
49567: LD_EXP 61
49571: PPUSH
49572: LD_VAR 0 1
49576: PPUSH
49577: EMPTY
49578: PPUSH
49579: CALL_OW 1
49583: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
49584: LD_ADDR_EXP 62
49588: PUSH
49589: LD_EXP 62
49593: PPUSH
49594: LD_VAR 0 1
49598: PPUSH
49599: EMPTY
49600: PPUSH
49601: CALL_OW 1
49605: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
49606: LD_ADDR_EXP 63
49610: PUSH
49611: LD_EXP 63
49615: PPUSH
49616: LD_VAR 0 1
49620: PPUSH
49621: EMPTY
49622: PPUSH
49623: CALL_OW 1
49627: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
49628: LD_ADDR_EXP 64
49632: PUSH
49633: LD_EXP 64
49637: PPUSH
49638: LD_VAR 0 1
49642: PPUSH
49643: EMPTY
49644: PPUSH
49645: CALL_OW 1
49649: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
49650: LD_ADDR_EXP 65
49654: PUSH
49655: LD_EXP 65
49659: PPUSH
49660: LD_VAR 0 1
49664: PPUSH
49665: LD_INT 0
49667: PPUSH
49668: CALL_OW 1
49672: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
49673: LD_ADDR_EXP 66
49677: PUSH
49678: LD_EXP 66
49682: PPUSH
49683: LD_VAR 0 1
49687: PPUSH
49688: LD_INT 0
49690: PPUSH
49691: CALL_OW 1
49695: ST_TO_ADDR
// end ;
49696: LD_VAR 0 2
49700: RET
// export function MC_Add ( side , units ) ; var base ; begin
49701: LD_INT 0
49703: PPUSH
49704: PPUSH
// base := mc_bases + 1 ;
49705: LD_ADDR_VAR 0 4
49709: PUSH
49710: LD_EXP 23
49714: PUSH
49715: LD_INT 1
49717: PLUS
49718: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
49719: LD_ADDR_EXP 49
49723: PUSH
49724: LD_EXP 49
49728: PPUSH
49729: LD_VAR 0 4
49733: PPUSH
49734: LD_VAR 0 1
49738: PPUSH
49739: CALL_OW 1
49743: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
49744: LD_ADDR_EXP 23
49748: PUSH
49749: LD_EXP 23
49753: PPUSH
49754: LD_VAR 0 4
49758: PPUSH
49759: LD_VAR 0 2
49763: PPUSH
49764: CALL_OW 1
49768: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
49769: LD_ADDR_EXP 24
49773: PUSH
49774: LD_EXP 24
49778: PPUSH
49779: LD_VAR 0 4
49783: PPUSH
49784: EMPTY
49785: PPUSH
49786: CALL_OW 1
49790: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
49791: LD_ADDR_EXP 25
49795: PUSH
49796: LD_EXP 25
49800: PPUSH
49801: LD_VAR 0 4
49805: PPUSH
49806: EMPTY
49807: PPUSH
49808: CALL_OW 1
49812: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
49813: LD_ADDR_EXP 26
49817: PUSH
49818: LD_EXP 26
49822: PPUSH
49823: LD_VAR 0 4
49827: PPUSH
49828: EMPTY
49829: PPUSH
49830: CALL_OW 1
49834: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
49835: LD_ADDR_EXP 27
49839: PUSH
49840: LD_EXP 27
49844: PPUSH
49845: LD_VAR 0 4
49849: PPUSH
49850: EMPTY
49851: PPUSH
49852: CALL_OW 1
49856: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
49857: LD_ADDR_EXP 28
49861: PUSH
49862: LD_EXP 28
49866: PPUSH
49867: LD_VAR 0 4
49871: PPUSH
49872: EMPTY
49873: PPUSH
49874: CALL_OW 1
49878: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
49879: LD_ADDR_EXP 29
49883: PUSH
49884: LD_EXP 29
49888: PPUSH
49889: LD_VAR 0 4
49893: PPUSH
49894: EMPTY
49895: PPUSH
49896: CALL_OW 1
49900: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
49901: LD_ADDR_EXP 30
49905: PUSH
49906: LD_EXP 30
49910: PPUSH
49911: LD_VAR 0 4
49915: PPUSH
49916: EMPTY
49917: PPUSH
49918: CALL_OW 1
49922: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
49923: LD_ADDR_EXP 31
49927: PUSH
49928: LD_EXP 31
49932: PPUSH
49933: LD_VAR 0 4
49937: PPUSH
49938: EMPTY
49939: PPUSH
49940: CALL_OW 1
49944: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
49945: LD_ADDR_EXP 32
49949: PUSH
49950: LD_EXP 32
49954: PPUSH
49955: LD_VAR 0 4
49959: PPUSH
49960: EMPTY
49961: PPUSH
49962: CALL_OW 1
49966: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
49967: LD_ADDR_EXP 33
49971: PUSH
49972: LD_EXP 33
49976: PPUSH
49977: LD_VAR 0 4
49981: PPUSH
49982: EMPTY
49983: PPUSH
49984: CALL_OW 1
49988: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
49989: LD_ADDR_EXP 34
49993: PUSH
49994: LD_EXP 34
49998: PPUSH
49999: LD_VAR 0 4
50003: PPUSH
50004: LD_INT 0
50006: PPUSH
50007: CALL_OW 1
50011: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
50012: LD_ADDR_EXP 35
50016: PUSH
50017: LD_EXP 35
50021: PPUSH
50022: LD_VAR 0 4
50026: PPUSH
50027: EMPTY
50028: PPUSH
50029: CALL_OW 1
50033: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
50034: LD_ADDR_EXP 36
50038: PUSH
50039: LD_EXP 36
50043: PPUSH
50044: LD_VAR 0 4
50048: PPUSH
50049: EMPTY
50050: PPUSH
50051: CALL_OW 1
50055: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
50056: LD_ADDR_EXP 37
50060: PUSH
50061: LD_EXP 37
50065: PPUSH
50066: LD_VAR 0 4
50070: PPUSH
50071: EMPTY
50072: PPUSH
50073: CALL_OW 1
50077: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
50078: LD_ADDR_EXP 38
50082: PUSH
50083: LD_EXP 38
50087: PPUSH
50088: LD_VAR 0 4
50092: PPUSH
50093: EMPTY
50094: PPUSH
50095: CALL_OW 1
50099: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
50100: LD_ADDR_EXP 39
50104: PUSH
50105: LD_EXP 39
50109: PPUSH
50110: LD_VAR 0 4
50114: PPUSH
50115: EMPTY
50116: PPUSH
50117: CALL_OW 1
50121: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
50122: LD_ADDR_EXP 40
50126: PUSH
50127: LD_EXP 40
50131: PPUSH
50132: LD_VAR 0 4
50136: PPUSH
50137: EMPTY
50138: PPUSH
50139: CALL_OW 1
50143: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
50144: LD_ADDR_EXP 41
50148: PUSH
50149: LD_EXP 41
50153: PPUSH
50154: LD_VAR 0 4
50158: PPUSH
50159: EMPTY
50160: PPUSH
50161: CALL_OW 1
50165: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
50166: LD_ADDR_EXP 42
50170: PUSH
50171: LD_EXP 42
50175: PPUSH
50176: LD_VAR 0 4
50180: PPUSH
50181: EMPTY
50182: PPUSH
50183: CALL_OW 1
50187: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
50188: LD_ADDR_EXP 43
50192: PUSH
50193: LD_EXP 43
50197: PPUSH
50198: LD_VAR 0 4
50202: PPUSH
50203: EMPTY
50204: PPUSH
50205: CALL_OW 1
50209: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
50210: LD_ADDR_EXP 44
50214: PUSH
50215: LD_EXP 44
50219: PPUSH
50220: LD_VAR 0 4
50224: PPUSH
50225: EMPTY
50226: PPUSH
50227: CALL_OW 1
50231: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
50232: LD_ADDR_EXP 45
50236: PUSH
50237: LD_EXP 45
50241: PPUSH
50242: LD_VAR 0 4
50246: PPUSH
50247: EMPTY
50248: PPUSH
50249: CALL_OW 1
50253: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
50254: LD_ADDR_EXP 46
50258: PUSH
50259: LD_EXP 46
50263: PPUSH
50264: LD_VAR 0 4
50268: PPUSH
50269: EMPTY
50270: PPUSH
50271: CALL_OW 1
50275: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
50276: LD_ADDR_EXP 47
50280: PUSH
50281: LD_EXP 47
50285: PPUSH
50286: LD_VAR 0 4
50290: PPUSH
50291: EMPTY
50292: PPUSH
50293: CALL_OW 1
50297: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
50298: LD_ADDR_EXP 48
50302: PUSH
50303: LD_EXP 48
50307: PPUSH
50308: LD_VAR 0 4
50312: PPUSH
50313: EMPTY
50314: PPUSH
50315: CALL_OW 1
50319: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
50320: LD_ADDR_EXP 50
50324: PUSH
50325: LD_EXP 50
50329: PPUSH
50330: LD_VAR 0 4
50334: PPUSH
50335: EMPTY
50336: PPUSH
50337: CALL_OW 1
50341: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
50342: LD_ADDR_EXP 52
50346: PUSH
50347: LD_EXP 52
50351: PPUSH
50352: LD_VAR 0 4
50356: PPUSH
50357: EMPTY
50358: PPUSH
50359: CALL_OW 1
50363: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
50364: LD_ADDR_EXP 53
50368: PUSH
50369: LD_EXP 53
50373: PPUSH
50374: LD_VAR 0 4
50378: PPUSH
50379: EMPTY
50380: PPUSH
50381: CALL_OW 1
50385: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
50386: LD_ADDR_EXP 54
50390: PUSH
50391: LD_EXP 54
50395: PPUSH
50396: LD_VAR 0 4
50400: PPUSH
50401: EMPTY
50402: PPUSH
50403: CALL_OW 1
50407: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
50408: LD_ADDR_EXP 55
50412: PUSH
50413: LD_EXP 55
50417: PPUSH
50418: LD_VAR 0 4
50422: PPUSH
50423: EMPTY
50424: PPUSH
50425: CALL_OW 1
50429: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
50430: LD_ADDR_EXP 56
50434: PUSH
50435: LD_EXP 56
50439: PPUSH
50440: LD_VAR 0 4
50444: PPUSH
50445: EMPTY
50446: PPUSH
50447: CALL_OW 1
50451: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
50452: LD_ADDR_EXP 57
50456: PUSH
50457: LD_EXP 57
50461: PPUSH
50462: LD_VAR 0 4
50466: PPUSH
50467: EMPTY
50468: PPUSH
50469: CALL_OW 1
50473: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
50474: LD_ADDR_EXP 58
50478: PUSH
50479: LD_EXP 58
50483: PPUSH
50484: LD_VAR 0 4
50488: PPUSH
50489: EMPTY
50490: PPUSH
50491: CALL_OW 1
50495: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
50496: LD_ADDR_EXP 59
50500: PUSH
50501: LD_EXP 59
50505: PPUSH
50506: LD_VAR 0 4
50510: PPUSH
50511: EMPTY
50512: PPUSH
50513: CALL_OW 1
50517: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
50518: LD_ADDR_EXP 60
50522: PUSH
50523: LD_EXP 60
50527: PPUSH
50528: LD_VAR 0 4
50532: PPUSH
50533: EMPTY
50534: PPUSH
50535: CALL_OW 1
50539: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
50540: LD_ADDR_EXP 61
50544: PUSH
50545: LD_EXP 61
50549: PPUSH
50550: LD_VAR 0 4
50554: PPUSH
50555: EMPTY
50556: PPUSH
50557: CALL_OW 1
50561: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
50562: LD_ADDR_EXP 62
50566: PUSH
50567: LD_EXP 62
50571: PPUSH
50572: LD_VAR 0 4
50576: PPUSH
50577: EMPTY
50578: PPUSH
50579: CALL_OW 1
50583: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
50584: LD_ADDR_EXP 63
50588: PUSH
50589: LD_EXP 63
50593: PPUSH
50594: LD_VAR 0 4
50598: PPUSH
50599: EMPTY
50600: PPUSH
50601: CALL_OW 1
50605: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
50606: LD_ADDR_EXP 64
50610: PUSH
50611: LD_EXP 64
50615: PPUSH
50616: LD_VAR 0 4
50620: PPUSH
50621: EMPTY
50622: PPUSH
50623: CALL_OW 1
50627: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
50628: LD_ADDR_EXP 65
50632: PUSH
50633: LD_EXP 65
50637: PPUSH
50638: LD_VAR 0 4
50642: PPUSH
50643: LD_INT 0
50645: PPUSH
50646: CALL_OW 1
50650: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
50651: LD_ADDR_EXP 66
50655: PUSH
50656: LD_EXP 66
50660: PPUSH
50661: LD_VAR 0 4
50665: PPUSH
50666: LD_INT 0
50668: PPUSH
50669: CALL_OW 1
50673: ST_TO_ADDR
// result := base ;
50674: LD_ADDR_VAR 0 3
50678: PUSH
50679: LD_VAR 0 4
50683: ST_TO_ADDR
// end ;
50684: LD_VAR 0 3
50688: RET
// export function MC_Start ( ) ; var i ; begin
50689: LD_INT 0
50691: PPUSH
50692: PPUSH
// for i = 1 to mc_bases do
50693: LD_ADDR_VAR 0 2
50697: PUSH
50698: DOUBLE
50699: LD_INT 1
50701: DEC
50702: ST_TO_ADDR
50703: LD_EXP 23
50707: PUSH
50708: FOR_TO
50709: IFFALSE 51809
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
50711: LD_ADDR_EXP 23
50715: PUSH
50716: LD_EXP 23
50720: PPUSH
50721: LD_VAR 0 2
50725: PPUSH
50726: LD_EXP 23
50730: PUSH
50731: LD_VAR 0 2
50735: ARRAY
50736: PUSH
50737: LD_INT 0
50739: DIFF
50740: PPUSH
50741: CALL_OW 1
50745: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
50746: LD_ADDR_EXP 24
50750: PUSH
50751: LD_EXP 24
50755: PPUSH
50756: LD_VAR 0 2
50760: PPUSH
50761: EMPTY
50762: PPUSH
50763: CALL_OW 1
50767: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
50768: LD_ADDR_EXP 25
50772: PUSH
50773: LD_EXP 25
50777: PPUSH
50778: LD_VAR 0 2
50782: PPUSH
50783: EMPTY
50784: PPUSH
50785: CALL_OW 1
50789: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
50790: LD_ADDR_EXP 26
50794: PUSH
50795: LD_EXP 26
50799: PPUSH
50800: LD_VAR 0 2
50804: PPUSH
50805: EMPTY
50806: PPUSH
50807: CALL_OW 1
50811: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
50812: LD_ADDR_EXP 27
50816: PUSH
50817: LD_EXP 27
50821: PPUSH
50822: LD_VAR 0 2
50826: PPUSH
50827: EMPTY
50828: PUSH
50829: EMPTY
50830: PUSH
50831: EMPTY
50832: LIST
50833: LIST
50834: PPUSH
50835: CALL_OW 1
50839: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
50840: LD_ADDR_EXP 28
50844: PUSH
50845: LD_EXP 28
50849: PPUSH
50850: LD_VAR 0 2
50854: PPUSH
50855: EMPTY
50856: PPUSH
50857: CALL_OW 1
50861: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
50862: LD_ADDR_EXP 55
50866: PUSH
50867: LD_EXP 55
50871: PPUSH
50872: LD_VAR 0 2
50876: PPUSH
50877: EMPTY
50878: PPUSH
50879: CALL_OW 1
50883: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
50884: LD_ADDR_EXP 29
50888: PUSH
50889: LD_EXP 29
50893: PPUSH
50894: LD_VAR 0 2
50898: PPUSH
50899: EMPTY
50900: PPUSH
50901: CALL_OW 1
50905: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
50906: LD_ADDR_EXP 30
50910: PUSH
50911: LD_EXP 30
50915: PPUSH
50916: LD_VAR 0 2
50920: PPUSH
50921: EMPTY
50922: PPUSH
50923: CALL_OW 1
50927: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
50928: LD_ADDR_EXP 31
50932: PUSH
50933: LD_EXP 31
50937: PPUSH
50938: LD_VAR 0 2
50942: PPUSH
50943: LD_EXP 23
50947: PUSH
50948: LD_VAR 0 2
50952: ARRAY
50953: PPUSH
50954: LD_INT 2
50956: PUSH
50957: LD_INT 30
50959: PUSH
50960: LD_INT 32
50962: PUSH
50963: EMPTY
50964: LIST
50965: LIST
50966: PUSH
50967: LD_INT 30
50969: PUSH
50970: LD_INT 33
50972: PUSH
50973: EMPTY
50974: LIST
50975: LIST
50976: PUSH
50977: EMPTY
50978: LIST
50979: LIST
50980: LIST
50981: PPUSH
50982: CALL_OW 72
50986: PPUSH
50987: CALL_OW 1
50991: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
50992: LD_ADDR_EXP 32
50996: PUSH
50997: LD_EXP 32
51001: PPUSH
51002: LD_VAR 0 2
51006: PPUSH
51007: LD_EXP 23
51011: PUSH
51012: LD_VAR 0 2
51016: ARRAY
51017: PPUSH
51018: LD_INT 2
51020: PUSH
51021: LD_INT 30
51023: PUSH
51024: LD_INT 32
51026: PUSH
51027: EMPTY
51028: LIST
51029: LIST
51030: PUSH
51031: LD_INT 30
51033: PUSH
51034: LD_INT 31
51036: PUSH
51037: EMPTY
51038: LIST
51039: LIST
51040: PUSH
51041: EMPTY
51042: LIST
51043: LIST
51044: LIST
51045: PUSH
51046: LD_INT 58
51048: PUSH
51049: EMPTY
51050: LIST
51051: PUSH
51052: EMPTY
51053: LIST
51054: LIST
51055: PPUSH
51056: CALL_OW 72
51060: PPUSH
51061: CALL_OW 1
51065: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
51066: LD_ADDR_EXP 33
51070: PUSH
51071: LD_EXP 33
51075: PPUSH
51076: LD_VAR 0 2
51080: PPUSH
51081: EMPTY
51082: PPUSH
51083: CALL_OW 1
51087: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
51088: LD_ADDR_EXP 37
51092: PUSH
51093: LD_EXP 37
51097: PPUSH
51098: LD_VAR 0 2
51102: PPUSH
51103: EMPTY
51104: PPUSH
51105: CALL_OW 1
51109: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
51110: LD_ADDR_EXP 36
51114: PUSH
51115: LD_EXP 36
51119: PPUSH
51120: LD_VAR 0 2
51124: PPUSH
51125: EMPTY
51126: PPUSH
51127: CALL_OW 1
51131: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
51132: LD_ADDR_EXP 38
51136: PUSH
51137: LD_EXP 38
51141: PPUSH
51142: LD_VAR 0 2
51146: PPUSH
51147: EMPTY
51148: PPUSH
51149: CALL_OW 1
51153: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
51154: LD_ADDR_EXP 39
51158: PUSH
51159: LD_EXP 39
51163: PPUSH
51164: LD_VAR 0 2
51168: PPUSH
51169: EMPTY
51170: PPUSH
51171: CALL_OW 1
51175: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
51176: LD_ADDR_EXP 40
51180: PUSH
51181: LD_EXP 40
51185: PPUSH
51186: LD_VAR 0 2
51190: PPUSH
51191: EMPTY
51192: PPUSH
51193: CALL_OW 1
51197: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
51198: LD_ADDR_EXP 41
51202: PUSH
51203: LD_EXP 41
51207: PPUSH
51208: LD_VAR 0 2
51212: PPUSH
51213: EMPTY
51214: PPUSH
51215: CALL_OW 1
51219: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
51220: LD_ADDR_EXP 42
51224: PUSH
51225: LD_EXP 42
51229: PPUSH
51230: LD_VAR 0 2
51234: PPUSH
51235: EMPTY
51236: PPUSH
51237: CALL_OW 1
51241: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
51242: LD_ADDR_EXP 43
51246: PUSH
51247: LD_EXP 43
51251: PPUSH
51252: LD_VAR 0 2
51256: PPUSH
51257: EMPTY
51258: PPUSH
51259: CALL_OW 1
51263: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
51264: LD_ADDR_EXP 44
51268: PUSH
51269: LD_EXP 44
51273: PPUSH
51274: LD_VAR 0 2
51278: PPUSH
51279: EMPTY
51280: PPUSH
51281: CALL_OW 1
51285: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
51286: LD_ADDR_EXP 45
51290: PUSH
51291: LD_EXP 45
51295: PPUSH
51296: LD_VAR 0 2
51300: PPUSH
51301: EMPTY
51302: PPUSH
51303: CALL_OW 1
51307: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
51308: LD_ADDR_EXP 34
51312: PUSH
51313: LD_EXP 34
51317: PPUSH
51318: LD_VAR 0 2
51322: PPUSH
51323: LD_INT 0
51325: PPUSH
51326: CALL_OW 1
51330: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
51331: LD_ADDR_EXP 47
51335: PUSH
51336: LD_EXP 47
51340: PPUSH
51341: LD_VAR 0 2
51345: PPUSH
51346: LD_INT 0
51348: PPUSH
51349: CALL_OW 1
51353: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
51354: LD_ADDR_EXP 35
51358: PUSH
51359: LD_EXP 35
51363: PPUSH
51364: LD_VAR 0 2
51368: PPUSH
51369: EMPTY
51370: PPUSH
51371: CALL_OW 1
51375: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
51376: LD_ADDR_EXP 46
51380: PUSH
51381: LD_EXP 46
51385: PPUSH
51386: LD_VAR 0 2
51390: PPUSH
51391: LD_INT 0
51393: PPUSH
51394: CALL_OW 1
51398: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
51399: LD_ADDR_EXP 48
51403: PUSH
51404: LD_EXP 48
51408: PPUSH
51409: LD_VAR 0 2
51413: PPUSH
51414: EMPTY
51415: PPUSH
51416: CALL_OW 1
51420: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
51421: LD_ADDR_EXP 51
51425: PUSH
51426: LD_EXP 51
51430: PPUSH
51431: LD_VAR 0 2
51435: PPUSH
51436: LD_INT 0
51438: PPUSH
51439: CALL_OW 1
51443: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
51444: LD_ADDR_EXP 52
51448: PUSH
51449: LD_EXP 52
51453: PPUSH
51454: LD_VAR 0 2
51458: PPUSH
51459: EMPTY
51460: PPUSH
51461: CALL_OW 1
51465: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
51466: LD_ADDR_EXP 53
51470: PUSH
51471: LD_EXP 53
51475: PPUSH
51476: LD_VAR 0 2
51480: PPUSH
51481: EMPTY
51482: PPUSH
51483: CALL_OW 1
51487: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
51488: LD_ADDR_EXP 54
51492: PUSH
51493: LD_EXP 54
51497: PPUSH
51498: LD_VAR 0 2
51502: PPUSH
51503: EMPTY
51504: PPUSH
51505: CALL_OW 1
51509: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
51510: LD_ADDR_EXP 56
51514: PUSH
51515: LD_EXP 56
51519: PPUSH
51520: LD_VAR 0 2
51524: PPUSH
51525: LD_EXP 23
51529: PUSH
51530: LD_VAR 0 2
51534: ARRAY
51535: PPUSH
51536: LD_INT 2
51538: PUSH
51539: LD_INT 30
51541: PUSH
51542: LD_INT 6
51544: PUSH
51545: EMPTY
51546: LIST
51547: LIST
51548: PUSH
51549: LD_INT 30
51551: PUSH
51552: LD_INT 7
51554: PUSH
51555: EMPTY
51556: LIST
51557: LIST
51558: PUSH
51559: LD_INT 30
51561: PUSH
51562: LD_INT 8
51564: PUSH
51565: EMPTY
51566: LIST
51567: LIST
51568: PUSH
51569: EMPTY
51570: LIST
51571: LIST
51572: LIST
51573: LIST
51574: PPUSH
51575: CALL_OW 72
51579: PPUSH
51580: CALL_OW 1
51584: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
51585: LD_ADDR_EXP 57
51589: PUSH
51590: LD_EXP 57
51594: PPUSH
51595: LD_VAR 0 2
51599: PPUSH
51600: EMPTY
51601: PPUSH
51602: CALL_OW 1
51606: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
51607: LD_ADDR_EXP 58
51611: PUSH
51612: LD_EXP 58
51616: PPUSH
51617: LD_VAR 0 2
51621: PPUSH
51622: EMPTY
51623: PPUSH
51624: CALL_OW 1
51628: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
51629: LD_ADDR_EXP 59
51633: PUSH
51634: LD_EXP 59
51638: PPUSH
51639: LD_VAR 0 2
51643: PPUSH
51644: EMPTY
51645: PPUSH
51646: CALL_OW 1
51650: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
51651: LD_ADDR_EXP 60
51655: PUSH
51656: LD_EXP 60
51660: PPUSH
51661: LD_VAR 0 2
51665: PPUSH
51666: EMPTY
51667: PPUSH
51668: CALL_OW 1
51672: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
51673: LD_ADDR_EXP 61
51677: PUSH
51678: LD_EXP 61
51682: PPUSH
51683: LD_VAR 0 2
51687: PPUSH
51688: EMPTY
51689: PPUSH
51690: CALL_OW 1
51694: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
51695: LD_ADDR_EXP 62
51699: PUSH
51700: LD_EXP 62
51704: PPUSH
51705: LD_VAR 0 2
51709: PPUSH
51710: EMPTY
51711: PPUSH
51712: CALL_OW 1
51716: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
51717: LD_ADDR_EXP 63
51721: PUSH
51722: LD_EXP 63
51726: PPUSH
51727: LD_VAR 0 2
51731: PPUSH
51732: EMPTY
51733: PPUSH
51734: CALL_OW 1
51738: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
51739: LD_ADDR_EXP 64
51743: PUSH
51744: LD_EXP 64
51748: PPUSH
51749: LD_VAR 0 2
51753: PPUSH
51754: EMPTY
51755: PPUSH
51756: CALL_OW 1
51760: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
51761: LD_ADDR_EXP 65
51765: PUSH
51766: LD_EXP 65
51770: PPUSH
51771: LD_VAR 0 2
51775: PPUSH
51776: LD_INT 0
51778: PPUSH
51779: CALL_OW 1
51783: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
51784: LD_ADDR_EXP 66
51788: PUSH
51789: LD_EXP 66
51793: PPUSH
51794: LD_VAR 0 2
51798: PPUSH
51799: LD_INT 0
51801: PPUSH
51802: CALL_OW 1
51806: ST_TO_ADDR
// end ;
51807: GO 50708
51809: POP
51810: POP
// MC_InitSides ( ) ;
51811: CALL 52097 0 0
// MC_InitResearch ( ) ;
51815: CALL 51836 0 0
// CustomInitMacro ( ) ;
51819: CALL 277 0 0
// skirmish := true ;
51823: LD_ADDR_EXP 21
51827: PUSH
51828: LD_INT 1
51830: ST_TO_ADDR
// end ;
51831: LD_VAR 0 1
51835: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
51836: LD_INT 0
51838: PPUSH
51839: PPUSH
51840: PPUSH
51841: PPUSH
51842: PPUSH
51843: PPUSH
// if not mc_bases then
51844: LD_EXP 23
51848: NOT
51849: IFFALSE 51853
// exit ;
51851: GO 52092
// for i = 1 to 8 do
51853: LD_ADDR_VAR 0 2
51857: PUSH
51858: DOUBLE
51859: LD_INT 1
51861: DEC
51862: ST_TO_ADDR
51863: LD_INT 8
51865: PUSH
51866: FOR_TO
51867: IFFALSE 51893
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
51869: LD_ADDR_EXP 50
51873: PUSH
51874: LD_EXP 50
51878: PPUSH
51879: LD_VAR 0 2
51883: PPUSH
51884: EMPTY
51885: PPUSH
51886: CALL_OW 1
51890: ST_TO_ADDR
51891: GO 51866
51893: POP
51894: POP
// tmp := [ ] ;
51895: LD_ADDR_VAR 0 5
51899: PUSH
51900: EMPTY
51901: ST_TO_ADDR
// for i = 1 to mc_sides do
51902: LD_ADDR_VAR 0 2
51906: PUSH
51907: DOUBLE
51908: LD_INT 1
51910: DEC
51911: ST_TO_ADDR
51912: LD_EXP 49
51916: PUSH
51917: FOR_TO
51918: IFFALSE 51976
// if not mc_sides [ i ] in tmp then
51920: LD_EXP 49
51924: PUSH
51925: LD_VAR 0 2
51929: ARRAY
51930: PUSH
51931: LD_VAR 0 5
51935: IN
51936: NOT
51937: IFFALSE 51974
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
51939: LD_ADDR_VAR 0 5
51943: PUSH
51944: LD_VAR 0 5
51948: PPUSH
51949: LD_VAR 0 5
51953: PUSH
51954: LD_INT 1
51956: PLUS
51957: PPUSH
51958: LD_EXP 49
51962: PUSH
51963: LD_VAR 0 2
51967: ARRAY
51968: PPUSH
51969: CALL_OW 2
51973: ST_TO_ADDR
51974: GO 51917
51976: POP
51977: POP
// if not tmp then
51978: LD_VAR 0 5
51982: NOT
51983: IFFALSE 51987
// exit ;
51985: GO 52092
// for j in tmp do
51987: LD_ADDR_VAR 0 3
51991: PUSH
51992: LD_VAR 0 5
51996: PUSH
51997: FOR_IN
51998: IFFALSE 52090
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
52000: LD_ADDR_VAR 0 6
52004: PUSH
52005: LD_INT 22
52007: PUSH
52008: LD_VAR 0 3
52012: PUSH
52013: EMPTY
52014: LIST
52015: LIST
52016: PPUSH
52017: CALL_OW 69
52021: ST_TO_ADDR
// if not un then
52022: LD_VAR 0 6
52026: NOT
52027: IFFALSE 52031
// continue ;
52029: GO 51997
// nation := GetNation ( un [ 1 ] ) ;
52031: LD_ADDR_VAR 0 4
52035: PUSH
52036: LD_VAR 0 6
52040: PUSH
52041: LD_INT 1
52043: ARRAY
52044: PPUSH
52045: CALL_OW 248
52049: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
52050: LD_ADDR_EXP 50
52054: PUSH
52055: LD_EXP 50
52059: PPUSH
52060: LD_VAR 0 3
52064: PPUSH
52065: LD_VAR 0 3
52069: PPUSH
52070: LD_VAR 0 4
52074: PPUSH
52075: LD_INT 1
52077: PPUSH
52078: CALL 9992 0 3
52082: PPUSH
52083: CALL_OW 1
52087: ST_TO_ADDR
// end ;
52088: GO 51997
52090: POP
52091: POP
// end ;
52092: LD_VAR 0 1
52096: RET
// export function MC_InitSides ( ) ; var i ; begin
52097: LD_INT 0
52099: PPUSH
52100: PPUSH
// if not mc_bases then
52101: LD_EXP 23
52105: NOT
52106: IFFALSE 52110
// exit ;
52108: GO 52184
// for i = 1 to mc_bases do
52110: LD_ADDR_VAR 0 2
52114: PUSH
52115: DOUBLE
52116: LD_INT 1
52118: DEC
52119: ST_TO_ADDR
52120: LD_EXP 23
52124: PUSH
52125: FOR_TO
52126: IFFALSE 52182
// if mc_bases [ i ] then
52128: LD_EXP 23
52132: PUSH
52133: LD_VAR 0 2
52137: ARRAY
52138: IFFALSE 52180
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
52140: LD_ADDR_EXP 49
52144: PUSH
52145: LD_EXP 49
52149: PPUSH
52150: LD_VAR 0 2
52154: PPUSH
52155: LD_EXP 23
52159: PUSH
52160: LD_VAR 0 2
52164: ARRAY
52165: PUSH
52166: LD_INT 1
52168: ARRAY
52169: PPUSH
52170: CALL_OW 255
52174: PPUSH
52175: CALL_OW 1
52179: ST_TO_ADDR
52180: GO 52125
52182: POP
52183: POP
// end ;
52184: LD_VAR 0 1
52188: RET
// every 0 0$03 trigger skirmish do
52189: LD_EXP 21
52193: IFFALSE 52347
52195: GO 52197
52197: DISABLE
// begin enable ;
52198: ENABLE
// MC_CheckBuildings ( ) ;
52199: CALL 56845 0 0
// MC_CheckPeopleLife ( ) ;
52203: CALL 56970 0 0
// RaiseSailEvent ( 100 ) ;
52207: LD_INT 100
52209: PPUSH
52210: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
52214: LD_INT 103
52216: PPUSH
52217: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
52221: LD_INT 104
52223: PPUSH
52224: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
52228: LD_INT 105
52230: PPUSH
52231: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
52235: LD_INT 106
52237: PPUSH
52238: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
52242: LD_INT 107
52244: PPUSH
52245: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
52249: LD_INT 108
52251: PPUSH
52252: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
52256: LD_INT 109
52258: PPUSH
52259: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
52263: LD_INT 110
52265: PPUSH
52266: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
52270: LD_INT 111
52272: PPUSH
52273: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
52277: LD_INT 112
52279: PPUSH
52280: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
52284: LD_INT 113
52286: PPUSH
52287: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
52291: LD_INT 120
52293: PPUSH
52294: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
52298: LD_INT 121
52300: PPUSH
52301: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
52305: LD_INT 122
52307: PPUSH
52308: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
52312: LD_INT 123
52314: PPUSH
52315: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
52319: LD_INT 124
52321: PPUSH
52322: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
52326: LD_INT 125
52328: PPUSH
52329: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
52333: LD_INT 126
52335: PPUSH
52336: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
52340: LD_INT 200
52342: PPUSH
52343: CALL_OW 427
// end ;
52347: END
// on SailEvent ( event ) do begin if event < 100 then
52348: LD_VAR 0 1
52352: PUSH
52353: LD_INT 100
52355: LESS
52356: IFFALSE 52367
// CustomEvent ( event ) ;
52358: LD_VAR 0 1
52362: PPUSH
52363: CALL 9166 0 1
// if event = 100 then
52367: LD_VAR 0 1
52371: PUSH
52372: LD_INT 100
52374: EQUAL
52375: IFFALSE 52381
// MC_ClassManager ( ) ;
52377: CALL 52773 0 0
// if event = 101 then
52381: LD_VAR 0 1
52385: PUSH
52386: LD_INT 101
52388: EQUAL
52389: IFFALSE 52395
// MC_RepairBuildings ( ) ;
52391: CALL 57555 0 0
// if event = 102 then
52395: LD_VAR 0 1
52399: PUSH
52400: LD_INT 102
52402: EQUAL
52403: IFFALSE 52409
// MC_Heal ( ) ;
52405: CALL 58440 0 0
// if event = 103 then
52409: LD_VAR 0 1
52413: PUSH
52414: LD_INT 103
52416: EQUAL
52417: IFFALSE 52423
// MC_Build ( ) ;
52419: CALL 58862 0 0
// if event = 104 then
52423: LD_VAR 0 1
52427: PUSH
52428: LD_INT 104
52430: EQUAL
52431: IFFALSE 52437
// MC_TurretWeapon ( ) ;
52433: CALL 60503 0 0
// if event = 105 then
52437: LD_VAR 0 1
52441: PUSH
52442: LD_INT 105
52444: EQUAL
52445: IFFALSE 52451
// MC_BuildUpgrade ( ) ;
52447: CALL 60054 0 0
// if event = 106 then
52451: LD_VAR 0 1
52455: PUSH
52456: LD_INT 106
52458: EQUAL
52459: IFFALSE 52465
// MC_PlantMines ( ) ;
52461: CALL 60933 0 0
// if event = 107 then
52465: LD_VAR 0 1
52469: PUSH
52470: LD_INT 107
52472: EQUAL
52473: IFFALSE 52479
// MC_CollectCrates ( ) ;
52475: CALL 61724 0 0
// if event = 108 then
52479: LD_VAR 0 1
52483: PUSH
52484: LD_INT 108
52486: EQUAL
52487: IFFALSE 52493
// MC_LinkRemoteControl ( ) ;
52489: CALL 63574 0 0
// if event = 109 then
52493: LD_VAR 0 1
52497: PUSH
52498: LD_INT 109
52500: EQUAL
52501: IFFALSE 52507
// MC_ProduceVehicle ( ) ;
52503: CALL 63755 0 0
// if event = 110 then
52507: LD_VAR 0 1
52511: PUSH
52512: LD_INT 110
52514: EQUAL
52515: IFFALSE 52521
// MC_SendAttack ( ) ;
52517: CALL 64221 0 0
// if event = 111 then
52521: LD_VAR 0 1
52525: PUSH
52526: LD_INT 111
52528: EQUAL
52529: IFFALSE 52535
// MC_Defend ( ) ;
52531: CALL 64329 0 0
// if event = 112 then
52535: LD_VAR 0 1
52539: PUSH
52540: LD_INT 112
52542: EQUAL
52543: IFFALSE 52549
// MC_Research ( ) ;
52545: CALL 65051 0 0
// if event = 113 then
52549: LD_VAR 0 1
52553: PUSH
52554: LD_INT 113
52556: EQUAL
52557: IFFALSE 52563
// MC_MinesTrigger ( ) ;
52559: CALL 66165 0 0
// if event = 120 then
52563: LD_VAR 0 1
52567: PUSH
52568: LD_INT 120
52570: EQUAL
52571: IFFALSE 52577
// MC_RepairVehicle ( ) ;
52573: CALL 66264 0 0
// if event = 121 then
52577: LD_VAR 0 1
52581: PUSH
52582: LD_INT 121
52584: EQUAL
52585: IFFALSE 52591
// MC_TameApe ( ) ;
52587: CALL 67005 0 0
// if event = 122 then
52591: LD_VAR 0 1
52595: PUSH
52596: LD_INT 122
52598: EQUAL
52599: IFFALSE 52605
// MC_ChangeApeClass ( ) ;
52601: CALL 67834 0 0
// if event = 123 then
52605: LD_VAR 0 1
52609: PUSH
52610: LD_INT 123
52612: EQUAL
52613: IFFALSE 52619
// MC_Bazooka ( ) ;
52615: CALL 68484 0 0
// if event = 124 then
52619: LD_VAR 0 1
52623: PUSH
52624: LD_INT 124
52626: EQUAL
52627: IFFALSE 52633
// MC_TeleportExit ( ) ;
52629: CALL 68682 0 0
// if event = 125 then
52633: LD_VAR 0 1
52637: PUSH
52638: LD_INT 125
52640: EQUAL
52641: IFFALSE 52647
// MC_Deposits ( ) ;
52643: CALL 69329 0 0
// if event = 126 then
52647: LD_VAR 0 1
52651: PUSH
52652: LD_INT 126
52654: EQUAL
52655: IFFALSE 52661
// MC_RemoteDriver ( ) ;
52657: CALL 69954 0 0
// if event = 200 then
52661: LD_VAR 0 1
52665: PUSH
52666: LD_INT 200
52668: EQUAL
52669: IFFALSE 52675
// MC_Idle ( ) ;
52671: CALL 71903 0 0
// end ;
52675: PPOPN 1
52677: END
// export function MC_Reset ( base , tag ) ; var i ; begin
52678: LD_INT 0
52680: PPUSH
52681: PPUSH
// if not mc_bases [ base ] or not tag then
52682: LD_EXP 23
52686: PUSH
52687: LD_VAR 0 1
52691: ARRAY
52692: NOT
52693: PUSH
52694: LD_VAR 0 2
52698: NOT
52699: OR
52700: IFFALSE 52704
// exit ;
52702: GO 52768
// for i in mc_bases [ base ] union mc_ape [ base ] do
52704: LD_ADDR_VAR 0 4
52708: PUSH
52709: LD_EXP 23
52713: PUSH
52714: LD_VAR 0 1
52718: ARRAY
52719: PUSH
52720: LD_EXP 52
52724: PUSH
52725: LD_VAR 0 1
52729: ARRAY
52730: UNION
52731: PUSH
52732: FOR_IN
52733: IFFALSE 52766
// if GetTag ( i ) = tag then
52735: LD_VAR 0 4
52739: PPUSH
52740: CALL_OW 110
52744: PUSH
52745: LD_VAR 0 2
52749: EQUAL
52750: IFFALSE 52764
// SetTag ( i , 0 ) ;
52752: LD_VAR 0 4
52756: PPUSH
52757: LD_INT 0
52759: PPUSH
52760: CALL_OW 109
52764: GO 52732
52766: POP
52767: POP
// end ;
52768: LD_VAR 0 3
52772: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
52773: LD_INT 0
52775: PPUSH
52776: PPUSH
52777: PPUSH
52778: PPUSH
52779: PPUSH
52780: PPUSH
52781: PPUSH
52782: PPUSH
// if not mc_bases then
52783: LD_EXP 23
52787: NOT
52788: IFFALSE 52792
// exit ;
52790: GO 53250
// for i = 1 to mc_bases do
52792: LD_ADDR_VAR 0 2
52796: PUSH
52797: DOUBLE
52798: LD_INT 1
52800: DEC
52801: ST_TO_ADDR
52802: LD_EXP 23
52806: PUSH
52807: FOR_TO
52808: IFFALSE 53248
// begin tmp := MC_ClassCheckReq ( i ) ;
52810: LD_ADDR_VAR 0 4
52814: PUSH
52815: LD_VAR 0 2
52819: PPUSH
52820: CALL 53255 0 1
52824: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
52825: LD_ADDR_EXP 64
52829: PUSH
52830: LD_EXP 64
52834: PPUSH
52835: LD_VAR 0 2
52839: PPUSH
52840: LD_VAR 0 4
52844: PPUSH
52845: CALL_OW 1
52849: ST_TO_ADDR
// if not tmp then
52850: LD_VAR 0 4
52854: NOT
52855: IFFALSE 52859
// continue ;
52857: GO 52807
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
52859: LD_ADDR_VAR 0 6
52863: PUSH
52864: LD_EXP 23
52868: PUSH
52869: LD_VAR 0 2
52873: ARRAY
52874: PPUSH
52875: LD_INT 2
52877: PUSH
52878: LD_INT 30
52880: PUSH
52881: LD_INT 4
52883: PUSH
52884: EMPTY
52885: LIST
52886: LIST
52887: PUSH
52888: LD_INT 30
52890: PUSH
52891: LD_INT 5
52893: PUSH
52894: EMPTY
52895: LIST
52896: LIST
52897: PUSH
52898: EMPTY
52899: LIST
52900: LIST
52901: LIST
52902: PPUSH
52903: CALL_OW 72
52907: PUSH
52908: LD_EXP 23
52912: PUSH
52913: LD_VAR 0 2
52917: ARRAY
52918: PPUSH
52919: LD_INT 2
52921: PUSH
52922: LD_INT 30
52924: PUSH
52925: LD_INT 0
52927: PUSH
52928: EMPTY
52929: LIST
52930: LIST
52931: PUSH
52932: LD_INT 30
52934: PUSH
52935: LD_INT 1
52937: PUSH
52938: EMPTY
52939: LIST
52940: LIST
52941: PUSH
52942: EMPTY
52943: LIST
52944: LIST
52945: LIST
52946: PPUSH
52947: CALL_OW 72
52951: PUSH
52952: LD_EXP 23
52956: PUSH
52957: LD_VAR 0 2
52961: ARRAY
52962: PPUSH
52963: LD_INT 30
52965: PUSH
52966: LD_INT 3
52968: PUSH
52969: EMPTY
52970: LIST
52971: LIST
52972: PPUSH
52973: CALL_OW 72
52977: PUSH
52978: LD_EXP 23
52982: PUSH
52983: LD_VAR 0 2
52987: ARRAY
52988: PPUSH
52989: LD_INT 2
52991: PUSH
52992: LD_INT 30
52994: PUSH
52995: LD_INT 6
52997: PUSH
52998: EMPTY
52999: LIST
53000: LIST
53001: PUSH
53002: LD_INT 30
53004: PUSH
53005: LD_INT 7
53007: PUSH
53008: EMPTY
53009: LIST
53010: LIST
53011: PUSH
53012: LD_INT 30
53014: PUSH
53015: LD_INT 8
53017: PUSH
53018: EMPTY
53019: LIST
53020: LIST
53021: PUSH
53022: EMPTY
53023: LIST
53024: LIST
53025: LIST
53026: LIST
53027: PPUSH
53028: CALL_OW 72
53032: PUSH
53033: EMPTY
53034: LIST
53035: LIST
53036: LIST
53037: LIST
53038: ST_TO_ADDR
// for j = 1 to 4 do
53039: LD_ADDR_VAR 0 3
53043: PUSH
53044: DOUBLE
53045: LD_INT 1
53047: DEC
53048: ST_TO_ADDR
53049: LD_INT 4
53051: PUSH
53052: FOR_TO
53053: IFFALSE 53244
// begin if not tmp [ j ] then
53055: LD_VAR 0 4
53059: PUSH
53060: LD_VAR 0 3
53064: ARRAY
53065: NOT
53066: IFFALSE 53070
// continue ;
53068: GO 53052
// for p in tmp [ j ] do
53070: LD_ADDR_VAR 0 5
53074: PUSH
53075: LD_VAR 0 4
53079: PUSH
53080: LD_VAR 0 3
53084: ARRAY
53085: PUSH
53086: FOR_IN
53087: IFFALSE 53240
// begin if not b [ j ] then
53089: LD_VAR 0 6
53093: PUSH
53094: LD_VAR 0 3
53098: ARRAY
53099: NOT
53100: IFFALSE 53104
// break ;
53102: GO 53240
// e := 0 ;
53104: LD_ADDR_VAR 0 7
53108: PUSH
53109: LD_INT 0
53111: ST_TO_ADDR
// for k in b [ j ] do
53112: LD_ADDR_VAR 0 8
53116: PUSH
53117: LD_VAR 0 6
53121: PUSH
53122: LD_VAR 0 3
53126: ARRAY
53127: PUSH
53128: FOR_IN
53129: IFFALSE 53156
// if IsNotFull ( k ) then
53131: LD_VAR 0 8
53135: PPUSH
53136: CALL 12145 0 1
53140: IFFALSE 53154
// begin e := k ;
53142: LD_ADDR_VAR 0 7
53146: PUSH
53147: LD_VAR 0 8
53151: ST_TO_ADDR
// break ;
53152: GO 53156
// end ;
53154: GO 53128
53156: POP
53157: POP
// if e and not UnitGoingToBuilding ( p , e ) then
53158: LD_VAR 0 7
53162: PUSH
53163: LD_VAR 0 5
53167: PPUSH
53168: LD_VAR 0 7
53172: PPUSH
53173: CALL 45310 0 2
53177: NOT
53178: AND
53179: IFFALSE 53238
// begin if IsInUnit ( p ) then
53181: LD_VAR 0 5
53185: PPUSH
53186: CALL_OW 310
53190: IFFALSE 53201
// ComExitBuilding ( p ) ;
53192: LD_VAR 0 5
53196: PPUSH
53197: CALL_OW 122
// ComEnterUnit ( p , e ) ;
53201: LD_VAR 0 5
53205: PPUSH
53206: LD_VAR 0 7
53210: PPUSH
53211: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
53215: LD_VAR 0 5
53219: PPUSH
53220: LD_VAR 0 3
53224: PPUSH
53225: CALL_OW 183
// AddComExitBuilding ( p ) ;
53229: LD_VAR 0 5
53233: PPUSH
53234: CALL_OW 182
// end ; end ;
53238: GO 53086
53240: POP
53241: POP
// end ;
53242: GO 53052
53244: POP
53245: POP
// end ;
53246: GO 52807
53248: POP
53249: POP
// end ;
53250: LD_VAR 0 1
53254: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
53255: LD_INT 0
53257: PPUSH
53258: PPUSH
53259: PPUSH
53260: PPUSH
53261: PPUSH
53262: PPUSH
53263: PPUSH
53264: PPUSH
53265: PPUSH
53266: PPUSH
53267: PPUSH
53268: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
53269: LD_VAR 0 1
53273: NOT
53274: PUSH
53275: LD_EXP 23
53279: PUSH
53280: LD_VAR 0 1
53284: ARRAY
53285: NOT
53286: OR
53287: PUSH
53288: LD_EXP 23
53292: PUSH
53293: LD_VAR 0 1
53297: ARRAY
53298: PPUSH
53299: LD_INT 2
53301: PUSH
53302: LD_INT 30
53304: PUSH
53305: LD_INT 0
53307: PUSH
53308: EMPTY
53309: LIST
53310: LIST
53311: PUSH
53312: LD_INT 30
53314: PUSH
53315: LD_INT 1
53317: PUSH
53318: EMPTY
53319: LIST
53320: LIST
53321: PUSH
53322: EMPTY
53323: LIST
53324: LIST
53325: LIST
53326: PPUSH
53327: CALL_OW 72
53331: NOT
53332: OR
53333: IFFALSE 53337
// exit ;
53335: GO 56840
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
53337: LD_ADDR_VAR 0 4
53341: PUSH
53342: LD_EXP 23
53346: PUSH
53347: LD_VAR 0 1
53351: ARRAY
53352: PPUSH
53353: LD_INT 2
53355: PUSH
53356: LD_INT 25
53358: PUSH
53359: LD_INT 1
53361: PUSH
53362: EMPTY
53363: LIST
53364: LIST
53365: PUSH
53366: LD_INT 25
53368: PUSH
53369: LD_INT 2
53371: PUSH
53372: EMPTY
53373: LIST
53374: LIST
53375: PUSH
53376: LD_INT 25
53378: PUSH
53379: LD_INT 3
53381: PUSH
53382: EMPTY
53383: LIST
53384: LIST
53385: PUSH
53386: LD_INT 25
53388: PUSH
53389: LD_INT 4
53391: PUSH
53392: EMPTY
53393: LIST
53394: LIST
53395: PUSH
53396: LD_INT 25
53398: PUSH
53399: LD_INT 5
53401: PUSH
53402: EMPTY
53403: LIST
53404: LIST
53405: PUSH
53406: LD_INT 25
53408: PUSH
53409: LD_INT 8
53411: PUSH
53412: EMPTY
53413: LIST
53414: LIST
53415: PUSH
53416: LD_INT 25
53418: PUSH
53419: LD_INT 9
53421: PUSH
53422: EMPTY
53423: LIST
53424: LIST
53425: PUSH
53426: EMPTY
53427: LIST
53428: LIST
53429: LIST
53430: LIST
53431: LIST
53432: LIST
53433: LIST
53434: LIST
53435: PPUSH
53436: CALL_OW 72
53440: ST_TO_ADDR
// if not tmp then
53441: LD_VAR 0 4
53445: NOT
53446: IFFALSE 53450
// exit ;
53448: GO 56840
// for i in tmp do
53450: LD_ADDR_VAR 0 3
53454: PUSH
53455: LD_VAR 0 4
53459: PUSH
53460: FOR_IN
53461: IFFALSE 53492
// if GetTag ( i ) then
53463: LD_VAR 0 3
53467: PPUSH
53468: CALL_OW 110
53472: IFFALSE 53490
// tmp := tmp diff i ;
53474: LD_ADDR_VAR 0 4
53478: PUSH
53479: LD_VAR 0 4
53483: PUSH
53484: LD_VAR 0 3
53488: DIFF
53489: ST_TO_ADDR
53490: GO 53460
53492: POP
53493: POP
// if not tmp then
53494: LD_VAR 0 4
53498: NOT
53499: IFFALSE 53503
// exit ;
53501: GO 56840
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
53503: LD_ADDR_VAR 0 5
53507: PUSH
53508: LD_EXP 23
53512: PUSH
53513: LD_VAR 0 1
53517: ARRAY
53518: PPUSH
53519: LD_INT 2
53521: PUSH
53522: LD_INT 25
53524: PUSH
53525: LD_INT 1
53527: PUSH
53528: EMPTY
53529: LIST
53530: LIST
53531: PUSH
53532: LD_INT 25
53534: PUSH
53535: LD_INT 5
53537: PUSH
53538: EMPTY
53539: LIST
53540: LIST
53541: PUSH
53542: LD_INT 25
53544: PUSH
53545: LD_INT 8
53547: PUSH
53548: EMPTY
53549: LIST
53550: LIST
53551: PUSH
53552: LD_INT 25
53554: PUSH
53555: LD_INT 9
53557: PUSH
53558: EMPTY
53559: LIST
53560: LIST
53561: PUSH
53562: EMPTY
53563: LIST
53564: LIST
53565: LIST
53566: LIST
53567: LIST
53568: PPUSH
53569: CALL_OW 72
53573: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
53574: LD_ADDR_VAR 0 6
53578: PUSH
53579: LD_EXP 23
53583: PUSH
53584: LD_VAR 0 1
53588: ARRAY
53589: PPUSH
53590: LD_INT 25
53592: PUSH
53593: LD_INT 2
53595: PUSH
53596: EMPTY
53597: LIST
53598: LIST
53599: PPUSH
53600: CALL_OW 72
53604: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
53605: LD_ADDR_VAR 0 7
53609: PUSH
53610: LD_EXP 23
53614: PUSH
53615: LD_VAR 0 1
53619: ARRAY
53620: PPUSH
53621: LD_INT 25
53623: PUSH
53624: LD_INT 3
53626: PUSH
53627: EMPTY
53628: LIST
53629: LIST
53630: PPUSH
53631: CALL_OW 72
53635: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
53636: LD_ADDR_VAR 0 8
53640: PUSH
53641: LD_EXP 23
53645: PUSH
53646: LD_VAR 0 1
53650: ARRAY
53651: PPUSH
53652: LD_INT 25
53654: PUSH
53655: LD_INT 4
53657: PUSH
53658: EMPTY
53659: LIST
53660: LIST
53661: PUSH
53662: LD_INT 24
53664: PUSH
53665: LD_INT 251
53667: PUSH
53668: EMPTY
53669: LIST
53670: LIST
53671: PUSH
53672: EMPTY
53673: LIST
53674: LIST
53675: PPUSH
53676: CALL_OW 72
53680: ST_TO_ADDR
// if mc_scan [ base ] then
53681: LD_EXP 46
53685: PUSH
53686: LD_VAR 0 1
53690: ARRAY
53691: IFFALSE 54152
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
53693: LD_ADDR_EXP 65
53697: PUSH
53698: LD_EXP 65
53702: PPUSH
53703: LD_VAR 0 1
53707: PPUSH
53708: LD_INT 4
53710: PPUSH
53711: CALL_OW 1
53715: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
53716: LD_ADDR_VAR 0 12
53720: PUSH
53721: LD_EXP 23
53725: PUSH
53726: LD_VAR 0 1
53730: ARRAY
53731: PPUSH
53732: LD_INT 2
53734: PUSH
53735: LD_INT 30
53737: PUSH
53738: LD_INT 4
53740: PUSH
53741: EMPTY
53742: LIST
53743: LIST
53744: PUSH
53745: LD_INT 30
53747: PUSH
53748: LD_INT 5
53750: PUSH
53751: EMPTY
53752: LIST
53753: LIST
53754: PUSH
53755: EMPTY
53756: LIST
53757: LIST
53758: LIST
53759: PPUSH
53760: CALL_OW 72
53764: ST_TO_ADDR
// if not b then
53765: LD_VAR 0 12
53769: NOT
53770: IFFALSE 53774
// exit ;
53772: GO 56840
// p := [ ] ;
53774: LD_ADDR_VAR 0 11
53778: PUSH
53779: EMPTY
53780: ST_TO_ADDR
// if sci >= 2 then
53781: LD_VAR 0 8
53785: PUSH
53786: LD_INT 2
53788: GREATEREQUAL
53789: IFFALSE 53820
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
53791: LD_ADDR_VAR 0 8
53795: PUSH
53796: LD_VAR 0 8
53800: PUSH
53801: LD_INT 1
53803: ARRAY
53804: PUSH
53805: LD_VAR 0 8
53809: PUSH
53810: LD_INT 2
53812: ARRAY
53813: PUSH
53814: EMPTY
53815: LIST
53816: LIST
53817: ST_TO_ADDR
53818: GO 53881
// if sci = 1 then
53820: LD_VAR 0 8
53824: PUSH
53825: LD_INT 1
53827: EQUAL
53828: IFFALSE 53849
// sci := [ sci [ 1 ] ] else
53830: LD_ADDR_VAR 0 8
53834: PUSH
53835: LD_VAR 0 8
53839: PUSH
53840: LD_INT 1
53842: ARRAY
53843: PUSH
53844: EMPTY
53845: LIST
53846: ST_TO_ADDR
53847: GO 53881
// if sci = 0 then
53849: LD_VAR 0 8
53853: PUSH
53854: LD_INT 0
53856: EQUAL
53857: IFFALSE 53881
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
53859: LD_ADDR_VAR 0 11
53863: PUSH
53864: LD_VAR 0 4
53868: PPUSH
53869: LD_INT 4
53871: PPUSH
53872: CALL 45173 0 2
53876: PUSH
53877: LD_INT 1
53879: ARRAY
53880: ST_TO_ADDR
// if eng > 4 then
53881: LD_VAR 0 6
53885: PUSH
53886: LD_INT 4
53888: GREATER
53889: IFFALSE 53935
// for i = eng downto 4 do
53891: LD_ADDR_VAR 0 3
53895: PUSH
53896: DOUBLE
53897: LD_VAR 0 6
53901: INC
53902: ST_TO_ADDR
53903: LD_INT 4
53905: PUSH
53906: FOR_DOWNTO
53907: IFFALSE 53933
// eng := eng diff eng [ i ] ;
53909: LD_ADDR_VAR 0 6
53913: PUSH
53914: LD_VAR 0 6
53918: PUSH
53919: LD_VAR 0 6
53923: PUSH
53924: LD_VAR 0 3
53928: ARRAY
53929: DIFF
53930: ST_TO_ADDR
53931: GO 53906
53933: POP
53934: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
53935: LD_ADDR_VAR 0 4
53939: PUSH
53940: LD_VAR 0 4
53944: PUSH
53945: LD_VAR 0 5
53949: PUSH
53950: LD_VAR 0 6
53954: UNION
53955: PUSH
53956: LD_VAR 0 7
53960: UNION
53961: PUSH
53962: LD_VAR 0 8
53966: UNION
53967: DIFF
53968: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
53969: LD_ADDR_VAR 0 13
53973: PUSH
53974: LD_EXP 23
53978: PUSH
53979: LD_VAR 0 1
53983: ARRAY
53984: PPUSH
53985: LD_INT 2
53987: PUSH
53988: LD_INT 30
53990: PUSH
53991: LD_INT 32
53993: PUSH
53994: EMPTY
53995: LIST
53996: LIST
53997: PUSH
53998: LD_INT 30
54000: PUSH
54001: LD_INT 31
54003: PUSH
54004: EMPTY
54005: LIST
54006: LIST
54007: PUSH
54008: EMPTY
54009: LIST
54010: LIST
54011: LIST
54012: PPUSH
54013: CALL_OW 72
54017: PUSH
54018: LD_EXP 23
54022: PUSH
54023: LD_VAR 0 1
54027: ARRAY
54028: PPUSH
54029: LD_INT 2
54031: PUSH
54032: LD_INT 30
54034: PUSH
54035: LD_INT 4
54037: PUSH
54038: EMPTY
54039: LIST
54040: LIST
54041: PUSH
54042: LD_INT 30
54044: PUSH
54045: LD_INT 5
54047: PUSH
54048: EMPTY
54049: LIST
54050: LIST
54051: PUSH
54052: EMPTY
54053: LIST
54054: LIST
54055: LIST
54056: PPUSH
54057: CALL_OW 72
54061: PUSH
54062: LD_INT 6
54064: MUL
54065: PLUS
54066: ST_TO_ADDR
// if bcount < tmp then
54067: LD_VAR 0 13
54071: PUSH
54072: LD_VAR 0 4
54076: LESS
54077: IFFALSE 54123
// for i = tmp downto bcount do
54079: LD_ADDR_VAR 0 3
54083: PUSH
54084: DOUBLE
54085: LD_VAR 0 4
54089: INC
54090: ST_TO_ADDR
54091: LD_VAR 0 13
54095: PUSH
54096: FOR_DOWNTO
54097: IFFALSE 54121
// tmp := Delete ( tmp , tmp ) ;
54099: LD_ADDR_VAR 0 4
54103: PUSH
54104: LD_VAR 0 4
54108: PPUSH
54109: LD_VAR 0 4
54113: PPUSH
54114: CALL_OW 3
54118: ST_TO_ADDR
54119: GO 54096
54121: POP
54122: POP
// result := [ tmp , 0 , 0 , p ] ;
54123: LD_ADDR_VAR 0 2
54127: PUSH
54128: LD_VAR 0 4
54132: PUSH
54133: LD_INT 0
54135: PUSH
54136: LD_INT 0
54138: PUSH
54139: LD_VAR 0 11
54143: PUSH
54144: EMPTY
54145: LIST
54146: LIST
54147: LIST
54148: LIST
54149: ST_TO_ADDR
// exit ;
54150: GO 56840
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
54152: LD_EXP 23
54156: PUSH
54157: LD_VAR 0 1
54161: ARRAY
54162: PPUSH
54163: LD_INT 2
54165: PUSH
54166: LD_INT 30
54168: PUSH
54169: LD_INT 6
54171: PUSH
54172: EMPTY
54173: LIST
54174: LIST
54175: PUSH
54176: LD_INT 30
54178: PUSH
54179: LD_INT 7
54181: PUSH
54182: EMPTY
54183: LIST
54184: LIST
54185: PUSH
54186: LD_INT 30
54188: PUSH
54189: LD_INT 8
54191: PUSH
54192: EMPTY
54193: LIST
54194: LIST
54195: PUSH
54196: EMPTY
54197: LIST
54198: LIST
54199: LIST
54200: LIST
54201: PPUSH
54202: CALL_OW 72
54206: NOT
54207: PUSH
54208: LD_EXP 23
54212: PUSH
54213: LD_VAR 0 1
54217: ARRAY
54218: PPUSH
54219: LD_INT 30
54221: PUSH
54222: LD_INT 3
54224: PUSH
54225: EMPTY
54226: LIST
54227: LIST
54228: PPUSH
54229: CALL_OW 72
54233: NOT
54234: AND
54235: IFFALSE 54307
// begin if eng = tmp then
54237: LD_VAR 0 6
54241: PUSH
54242: LD_VAR 0 4
54246: EQUAL
54247: IFFALSE 54251
// exit ;
54249: GO 56840
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
54251: LD_ADDR_EXP 65
54255: PUSH
54256: LD_EXP 65
54260: PPUSH
54261: LD_VAR 0 1
54265: PPUSH
54266: LD_INT 1
54268: PPUSH
54269: CALL_OW 1
54273: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
54274: LD_ADDR_VAR 0 2
54278: PUSH
54279: LD_INT 0
54281: PUSH
54282: LD_VAR 0 4
54286: PUSH
54287: LD_VAR 0 6
54291: DIFF
54292: PUSH
54293: LD_INT 0
54295: PUSH
54296: LD_INT 0
54298: PUSH
54299: EMPTY
54300: LIST
54301: LIST
54302: LIST
54303: LIST
54304: ST_TO_ADDR
// exit ;
54305: GO 56840
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
54307: LD_EXP 50
54311: PUSH
54312: LD_EXP 49
54316: PUSH
54317: LD_VAR 0 1
54321: ARRAY
54322: ARRAY
54323: PUSH
54324: LD_EXP 23
54328: PUSH
54329: LD_VAR 0 1
54333: ARRAY
54334: PPUSH
54335: LD_INT 2
54337: PUSH
54338: LD_INT 30
54340: PUSH
54341: LD_INT 6
54343: PUSH
54344: EMPTY
54345: LIST
54346: LIST
54347: PUSH
54348: LD_INT 30
54350: PUSH
54351: LD_INT 7
54353: PUSH
54354: EMPTY
54355: LIST
54356: LIST
54357: PUSH
54358: LD_INT 30
54360: PUSH
54361: LD_INT 8
54363: PUSH
54364: EMPTY
54365: LIST
54366: LIST
54367: PUSH
54368: EMPTY
54369: LIST
54370: LIST
54371: LIST
54372: LIST
54373: PPUSH
54374: CALL_OW 72
54378: AND
54379: PUSH
54380: LD_EXP 23
54384: PUSH
54385: LD_VAR 0 1
54389: ARRAY
54390: PPUSH
54391: LD_INT 30
54393: PUSH
54394: LD_INT 3
54396: PUSH
54397: EMPTY
54398: LIST
54399: LIST
54400: PPUSH
54401: CALL_OW 72
54405: NOT
54406: AND
54407: IFFALSE 54621
// begin if sci >= 6 then
54409: LD_VAR 0 8
54413: PUSH
54414: LD_INT 6
54416: GREATEREQUAL
54417: IFFALSE 54421
// exit ;
54419: GO 56840
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
54421: LD_ADDR_EXP 65
54425: PUSH
54426: LD_EXP 65
54430: PPUSH
54431: LD_VAR 0 1
54435: PPUSH
54436: LD_INT 2
54438: PPUSH
54439: CALL_OW 1
54443: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
54444: LD_ADDR_VAR 0 9
54448: PUSH
54449: LD_VAR 0 4
54453: PUSH
54454: LD_VAR 0 8
54458: DIFF
54459: PPUSH
54460: LD_INT 4
54462: PPUSH
54463: CALL 45173 0 2
54467: ST_TO_ADDR
// p := [ ] ;
54468: LD_ADDR_VAR 0 11
54472: PUSH
54473: EMPTY
54474: ST_TO_ADDR
// if sci < 6 and sort > 6 then
54475: LD_VAR 0 8
54479: PUSH
54480: LD_INT 6
54482: LESS
54483: PUSH
54484: LD_VAR 0 9
54488: PUSH
54489: LD_INT 6
54491: GREATER
54492: AND
54493: IFFALSE 54574
// begin for i = 1 to 6 - sci do
54495: LD_ADDR_VAR 0 3
54499: PUSH
54500: DOUBLE
54501: LD_INT 1
54503: DEC
54504: ST_TO_ADDR
54505: LD_INT 6
54507: PUSH
54508: LD_VAR 0 8
54512: MINUS
54513: PUSH
54514: FOR_TO
54515: IFFALSE 54570
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
54517: LD_ADDR_VAR 0 11
54521: PUSH
54522: LD_VAR 0 11
54526: PPUSH
54527: LD_VAR 0 11
54531: PUSH
54532: LD_INT 1
54534: PLUS
54535: PPUSH
54536: LD_VAR 0 9
54540: PUSH
54541: LD_INT 1
54543: ARRAY
54544: PPUSH
54545: CALL_OW 2
54549: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
54550: LD_ADDR_VAR 0 9
54554: PUSH
54555: LD_VAR 0 9
54559: PPUSH
54560: LD_INT 1
54562: PPUSH
54563: CALL_OW 3
54567: ST_TO_ADDR
// end ;
54568: GO 54514
54570: POP
54571: POP
// end else
54572: GO 54594
// if sort then
54574: LD_VAR 0 9
54578: IFFALSE 54594
// p := sort [ 1 ] ;
54580: LD_ADDR_VAR 0 11
54584: PUSH
54585: LD_VAR 0 9
54589: PUSH
54590: LD_INT 1
54592: ARRAY
54593: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
54594: LD_ADDR_VAR 0 2
54598: PUSH
54599: LD_INT 0
54601: PUSH
54602: LD_INT 0
54604: PUSH
54605: LD_INT 0
54607: PUSH
54608: LD_VAR 0 11
54612: PUSH
54613: EMPTY
54614: LIST
54615: LIST
54616: LIST
54617: LIST
54618: ST_TO_ADDR
// exit ;
54619: GO 56840
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
54621: LD_EXP 50
54625: PUSH
54626: LD_EXP 49
54630: PUSH
54631: LD_VAR 0 1
54635: ARRAY
54636: ARRAY
54637: PUSH
54638: LD_EXP 23
54642: PUSH
54643: LD_VAR 0 1
54647: ARRAY
54648: PPUSH
54649: LD_INT 2
54651: PUSH
54652: LD_INT 30
54654: PUSH
54655: LD_INT 6
54657: PUSH
54658: EMPTY
54659: LIST
54660: LIST
54661: PUSH
54662: LD_INT 30
54664: PUSH
54665: LD_INT 7
54667: PUSH
54668: EMPTY
54669: LIST
54670: LIST
54671: PUSH
54672: LD_INT 30
54674: PUSH
54675: LD_INT 8
54677: PUSH
54678: EMPTY
54679: LIST
54680: LIST
54681: PUSH
54682: EMPTY
54683: LIST
54684: LIST
54685: LIST
54686: LIST
54687: PPUSH
54688: CALL_OW 72
54692: AND
54693: PUSH
54694: LD_EXP 23
54698: PUSH
54699: LD_VAR 0 1
54703: ARRAY
54704: PPUSH
54705: LD_INT 30
54707: PUSH
54708: LD_INT 3
54710: PUSH
54711: EMPTY
54712: LIST
54713: LIST
54714: PPUSH
54715: CALL_OW 72
54719: AND
54720: IFFALSE 55454
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
54722: LD_ADDR_EXP 65
54726: PUSH
54727: LD_EXP 65
54731: PPUSH
54732: LD_VAR 0 1
54736: PPUSH
54737: LD_INT 3
54739: PPUSH
54740: CALL_OW 1
54744: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
54745: LD_ADDR_VAR 0 2
54749: PUSH
54750: LD_INT 0
54752: PUSH
54753: LD_INT 0
54755: PUSH
54756: LD_INT 0
54758: PUSH
54759: LD_INT 0
54761: PUSH
54762: EMPTY
54763: LIST
54764: LIST
54765: LIST
54766: LIST
54767: ST_TO_ADDR
// if not eng then
54768: LD_VAR 0 6
54772: NOT
54773: IFFALSE 54836
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
54775: LD_ADDR_VAR 0 11
54779: PUSH
54780: LD_VAR 0 4
54784: PPUSH
54785: LD_INT 2
54787: PPUSH
54788: CALL 45173 0 2
54792: PUSH
54793: LD_INT 1
54795: ARRAY
54796: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
54797: LD_ADDR_VAR 0 2
54801: PUSH
54802: LD_VAR 0 2
54806: PPUSH
54807: LD_INT 2
54809: PPUSH
54810: LD_VAR 0 11
54814: PPUSH
54815: CALL_OW 1
54819: ST_TO_ADDR
// tmp := tmp diff p ;
54820: LD_ADDR_VAR 0 4
54824: PUSH
54825: LD_VAR 0 4
54829: PUSH
54830: LD_VAR 0 11
54834: DIFF
54835: ST_TO_ADDR
// end ; if tmp and sci < 6 then
54836: LD_VAR 0 4
54840: PUSH
54841: LD_VAR 0 8
54845: PUSH
54846: LD_INT 6
54848: LESS
54849: AND
54850: IFFALSE 55038
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
54852: LD_ADDR_VAR 0 9
54856: PUSH
54857: LD_VAR 0 4
54861: PUSH
54862: LD_VAR 0 8
54866: PUSH
54867: LD_VAR 0 7
54871: UNION
54872: DIFF
54873: PPUSH
54874: LD_INT 4
54876: PPUSH
54877: CALL 45173 0 2
54881: ST_TO_ADDR
// p := [ ] ;
54882: LD_ADDR_VAR 0 11
54886: PUSH
54887: EMPTY
54888: ST_TO_ADDR
// if sort then
54889: LD_VAR 0 9
54893: IFFALSE 55009
// for i = 1 to 6 - sci do
54895: LD_ADDR_VAR 0 3
54899: PUSH
54900: DOUBLE
54901: LD_INT 1
54903: DEC
54904: ST_TO_ADDR
54905: LD_INT 6
54907: PUSH
54908: LD_VAR 0 8
54912: MINUS
54913: PUSH
54914: FOR_TO
54915: IFFALSE 55007
// begin if i = sort then
54917: LD_VAR 0 3
54921: PUSH
54922: LD_VAR 0 9
54926: EQUAL
54927: IFFALSE 54931
// break ;
54929: GO 55007
// if GetClass ( i ) = 4 then
54931: LD_VAR 0 3
54935: PPUSH
54936: CALL_OW 257
54940: PUSH
54941: LD_INT 4
54943: EQUAL
54944: IFFALSE 54948
// continue ;
54946: GO 54914
// p := Insert ( p , p + 1 , sort [ i ] ) ;
54948: LD_ADDR_VAR 0 11
54952: PUSH
54953: LD_VAR 0 11
54957: PPUSH
54958: LD_VAR 0 11
54962: PUSH
54963: LD_INT 1
54965: PLUS
54966: PPUSH
54967: LD_VAR 0 9
54971: PUSH
54972: LD_VAR 0 3
54976: ARRAY
54977: PPUSH
54978: CALL_OW 2
54982: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
54983: LD_ADDR_VAR 0 4
54987: PUSH
54988: LD_VAR 0 4
54992: PUSH
54993: LD_VAR 0 9
54997: PUSH
54998: LD_VAR 0 3
55002: ARRAY
55003: DIFF
55004: ST_TO_ADDR
// end ;
55005: GO 54914
55007: POP
55008: POP
// if p then
55009: LD_VAR 0 11
55013: IFFALSE 55038
// result := Replace ( result , 4 , p ) ;
55015: LD_ADDR_VAR 0 2
55019: PUSH
55020: LD_VAR 0 2
55024: PPUSH
55025: LD_INT 4
55027: PPUSH
55028: LD_VAR 0 11
55032: PPUSH
55033: CALL_OW 1
55037: ST_TO_ADDR
// end ; if tmp and mech < 6 then
55038: LD_VAR 0 4
55042: PUSH
55043: LD_VAR 0 7
55047: PUSH
55048: LD_INT 6
55050: LESS
55051: AND
55052: IFFALSE 55240
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
55054: LD_ADDR_VAR 0 9
55058: PUSH
55059: LD_VAR 0 4
55063: PUSH
55064: LD_VAR 0 8
55068: PUSH
55069: LD_VAR 0 7
55073: UNION
55074: DIFF
55075: PPUSH
55076: LD_INT 3
55078: PPUSH
55079: CALL 45173 0 2
55083: ST_TO_ADDR
// p := [ ] ;
55084: LD_ADDR_VAR 0 11
55088: PUSH
55089: EMPTY
55090: ST_TO_ADDR
// if sort then
55091: LD_VAR 0 9
55095: IFFALSE 55211
// for i = 1 to 6 - mech do
55097: LD_ADDR_VAR 0 3
55101: PUSH
55102: DOUBLE
55103: LD_INT 1
55105: DEC
55106: ST_TO_ADDR
55107: LD_INT 6
55109: PUSH
55110: LD_VAR 0 7
55114: MINUS
55115: PUSH
55116: FOR_TO
55117: IFFALSE 55209
// begin if i = sort then
55119: LD_VAR 0 3
55123: PUSH
55124: LD_VAR 0 9
55128: EQUAL
55129: IFFALSE 55133
// break ;
55131: GO 55209
// if GetClass ( i ) = 3 then
55133: LD_VAR 0 3
55137: PPUSH
55138: CALL_OW 257
55142: PUSH
55143: LD_INT 3
55145: EQUAL
55146: IFFALSE 55150
// continue ;
55148: GO 55116
// p := Insert ( p , p + 1 , sort [ i ] ) ;
55150: LD_ADDR_VAR 0 11
55154: PUSH
55155: LD_VAR 0 11
55159: PPUSH
55160: LD_VAR 0 11
55164: PUSH
55165: LD_INT 1
55167: PLUS
55168: PPUSH
55169: LD_VAR 0 9
55173: PUSH
55174: LD_VAR 0 3
55178: ARRAY
55179: PPUSH
55180: CALL_OW 2
55184: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
55185: LD_ADDR_VAR 0 4
55189: PUSH
55190: LD_VAR 0 4
55194: PUSH
55195: LD_VAR 0 9
55199: PUSH
55200: LD_VAR 0 3
55204: ARRAY
55205: DIFF
55206: ST_TO_ADDR
// end ;
55207: GO 55116
55209: POP
55210: POP
// if p then
55211: LD_VAR 0 11
55215: IFFALSE 55240
// result := Replace ( result , 3 , p ) ;
55217: LD_ADDR_VAR 0 2
55221: PUSH
55222: LD_VAR 0 2
55226: PPUSH
55227: LD_INT 3
55229: PPUSH
55230: LD_VAR 0 11
55234: PPUSH
55235: CALL_OW 1
55239: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
55240: LD_VAR 0 4
55244: PUSH
55245: LD_INT 6
55247: GREATER
55248: PUSH
55249: LD_VAR 0 6
55253: PUSH
55254: LD_INT 6
55256: LESS
55257: AND
55258: IFFALSE 55452
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
55260: LD_ADDR_VAR 0 9
55264: PUSH
55265: LD_VAR 0 4
55269: PUSH
55270: LD_VAR 0 8
55274: PUSH
55275: LD_VAR 0 7
55279: UNION
55280: PUSH
55281: LD_VAR 0 6
55285: UNION
55286: DIFF
55287: PPUSH
55288: LD_INT 2
55290: PPUSH
55291: CALL 45173 0 2
55295: ST_TO_ADDR
// p := [ ] ;
55296: LD_ADDR_VAR 0 11
55300: PUSH
55301: EMPTY
55302: ST_TO_ADDR
// if sort then
55303: LD_VAR 0 9
55307: IFFALSE 55423
// for i = 1 to 6 - eng do
55309: LD_ADDR_VAR 0 3
55313: PUSH
55314: DOUBLE
55315: LD_INT 1
55317: DEC
55318: ST_TO_ADDR
55319: LD_INT 6
55321: PUSH
55322: LD_VAR 0 6
55326: MINUS
55327: PUSH
55328: FOR_TO
55329: IFFALSE 55421
// begin if i = sort then
55331: LD_VAR 0 3
55335: PUSH
55336: LD_VAR 0 9
55340: EQUAL
55341: IFFALSE 55345
// break ;
55343: GO 55421
// if GetClass ( i ) = 2 then
55345: LD_VAR 0 3
55349: PPUSH
55350: CALL_OW 257
55354: PUSH
55355: LD_INT 2
55357: EQUAL
55358: IFFALSE 55362
// continue ;
55360: GO 55328
// p := Insert ( p , p + 1 , sort [ i ] ) ;
55362: LD_ADDR_VAR 0 11
55366: PUSH
55367: LD_VAR 0 11
55371: PPUSH
55372: LD_VAR 0 11
55376: PUSH
55377: LD_INT 1
55379: PLUS
55380: PPUSH
55381: LD_VAR 0 9
55385: PUSH
55386: LD_VAR 0 3
55390: ARRAY
55391: PPUSH
55392: CALL_OW 2
55396: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
55397: LD_ADDR_VAR 0 4
55401: PUSH
55402: LD_VAR 0 4
55406: PUSH
55407: LD_VAR 0 9
55411: PUSH
55412: LD_VAR 0 3
55416: ARRAY
55417: DIFF
55418: ST_TO_ADDR
// end ;
55419: GO 55328
55421: POP
55422: POP
// if p then
55423: LD_VAR 0 11
55427: IFFALSE 55452
// result := Replace ( result , 2 , p ) ;
55429: LD_ADDR_VAR 0 2
55433: PUSH
55434: LD_VAR 0 2
55438: PPUSH
55439: LD_INT 2
55441: PPUSH
55442: LD_VAR 0 11
55446: PPUSH
55447: CALL_OW 1
55451: ST_TO_ADDR
// end ; exit ;
55452: GO 56840
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
55454: LD_EXP 50
55458: PUSH
55459: LD_EXP 49
55463: PUSH
55464: LD_VAR 0 1
55468: ARRAY
55469: ARRAY
55470: NOT
55471: PUSH
55472: LD_EXP 23
55476: PUSH
55477: LD_VAR 0 1
55481: ARRAY
55482: PPUSH
55483: LD_INT 30
55485: PUSH
55486: LD_INT 3
55488: PUSH
55489: EMPTY
55490: LIST
55491: LIST
55492: PPUSH
55493: CALL_OW 72
55497: AND
55498: PUSH
55499: LD_EXP 28
55503: PUSH
55504: LD_VAR 0 1
55508: ARRAY
55509: AND
55510: IFFALSE 56118
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
55512: LD_ADDR_EXP 65
55516: PUSH
55517: LD_EXP 65
55521: PPUSH
55522: LD_VAR 0 1
55526: PPUSH
55527: LD_INT 5
55529: PPUSH
55530: CALL_OW 1
55534: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
55535: LD_ADDR_VAR 0 2
55539: PUSH
55540: LD_INT 0
55542: PUSH
55543: LD_INT 0
55545: PUSH
55546: LD_INT 0
55548: PUSH
55549: LD_INT 0
55551: PUSH
55552: EMPTY
55553: LIST
55554: LIST
55555: LIST
55556: LIST
55557: ST_TO_ADDR
// if sci > 1 then
55558: LD_VAR 0 8
55562: PUSH
55563: LD_INT 1
55565: GREATER
55566: IFFALSE 55594
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
55568: LD_ADDR_VAR 0 4
55572: PUSH
55573: LD_VAR 0 4
55577: PUSH
55578: LD_VAR 0 8
55582: PUSH
55583: LD_VAR 0 8
55587: PUSH
55588: LD_INT 1
55590: ARRAY
55591: DIFF
55592: DIFF
55593: ST_TO_ADDR
// if tmp and not sci then
55594: LD_VAR 0 4
55598: PUSH
55599: LD_VAR 0 8
55603: NOT
55604: AND
55605: IFFALSE 55674
// begin sort := SortBySkill ( tmp , 4 ) ;
55607: LD_ADDR_VAR 0 9
55611: PUSH
55612: LD_VAR 0 4
55616: PPUSH
55617: LD_INT 4
55619: PPUSH
55620: CALL 45173 0 2
55624: ST_TO_ADDR
// if sort then
55625: LD_VAR 0 9
55629: IFFALSE 55645
// p := sort [ 1 ] ;
55631: LD_ADDR_VAR 0 11
55635: PUSH
55636: LD_VAR 0 9
55640: PUSH
55641: LD_INT 1
55643: ARRAY
55644: ST_TO_ADDR
// if p then
55645: LD_VAR 0 11
55649: IFFALSE 55674
// result := Replace ( result , 4 , p ) ;
55651: LD_ADDR_VAR 0 2
55655: PUSH
55656: LD_VAR 0 2
55660: PPUSH
55661: LD_INT 4
55663: PPUSH
55664: LD_VAR 0 11
55668: PPUSH
55669: CALL_OW 1
55673: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
55674: LD_ADDR_VAR 0 4
55678: PUSH
55679: LD_VAR 0 4
55683: PUSH
55684: LD_VAR 0 7
55688: DIFF
55689: ST_TO_ADDR
// if tmp and mech < 6 then
55690: LD_VAR 0 4
55694: PUSH
55695: LD_VAR 0 7
55699: PUSH
55700: LD_INT 6
55702: LESS
55703: AND
55704: IFFALSE 55892
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
55706: LD_ADDR_VAR 0 9
55710: PUSH
55711: LD_VAR 0 4
55715: PUSH
55716: LD_VAR 0 8
55720: PUSH
55721: LD_VAR 0 7
55725: UNION
55726: DIFF
55727: PPUSH
55728: LD_INT 3
55730: PPUSH
55731: CALL 45173 0 2
55735: ST_TO_ADDR
// p := [ ] ;
55736: LD_ADDR_VAR 0 11
55740: PUSH
55741: EMPTY
55742: ST_TO_ADDR
// if sort then
55743: LD_VAR 0 9
55747: IFFALSE 55863
// for i = 1 to 6 - mech do
55749: LD_ADDR_VAR 0 3
55753: PUSH
55754: DOUBLE
55755: LD_INT 1
55757: DEC
55758: ST_TO_ADDR
55759: LD_INT 6
55761: PUSH
55762: LD_VAR 0 7
55766: MINUS
55767: PUSH
55768: FOR_TO
55769: IFFALSE 55861
// begin if i = sort then
55771: LD_VAR 0 3
55775: PUSH
55776: LD_VAR 0 9
55780: EQUAL
55781: IFFALSE 55785
// break ;
55783: GO 55861
// if GetClass ( i ) = 3 then
55785: LD_VAR 0 3
55789: PPUSH
55790: CALL_OW 257
55794: PUSH
55795: LD_INT 3
55797: EQUAL
55798: IFFALSE 55802
// continue ;
55800: GO 55768
// p := Insert ( p , p + 1 , sort [ i ] ) ;
55802: LD_ADDR_VAR 0 11
55806: PUSH
55807: LD_VAR 0 11
55811: PPUSH
55812: LD_VAR 0 11
55816: PUSH
55817: LD_INT 1
55819: PLUS
55820: PPUSH
55821: LD_VAR 0 9
55825: PUSH
55826: LD_VAR 0 3
55830: ARRAY
55831: PPUSH
55832: CALL_OW 2
55836: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
55837: LD_ADDR_VAR 0 4
55841: PUSH
55842: LD_VAR 0 4
55846: PUSH
55847: LD_VAR 0 9
55851: PUSH
55852: LD_VAR 0 3
55856: ARRAY
55857: DIFF
55858: ST_TO_ADDR
// end ;
55859: GO 55768
55861: POP
55862: POP
// if p then
55863: LD_VAR 0 11
55867: IFFALSE 55892
// result := Replace ( result , 3 , p ) ;
55869: LD_ADDR_VAR 0 2
55873: PUSH
55874: LD_VAR 0 2
55878: PPUSH
55879: LD_INT 3
55881: PPUSH
55882: LD_VAR 0 11
55886: PPUSH
55887: CALL_OW 1
55891: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
55892: LD_ADDR_VAR 0 4
55896: PUSH
55897: LD_VAR 0 4
55901: PUSH
55902: LD_VAR 0 6
55906: DIFF
55907: ST_TO_ADDR
// if tmp and eng < 6 then
55908: LD_VAR 0 4
55912: PUSH
55913: LD_VAR 0 6
55917: PUSH
55918: LD_INT 6
55920: LESS
55921: AND
55922: IFFALSE 56116
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
55924: LD_ADDR_VAR 0 9
55928: PUSH
55929: LD_VAR 0 4
55933: PUSH
55934: LD_VAR 0 8
55938: PUSH
55939: LD_VAR 0 7
55943: UNION
55944: PUSH
55945: LD_VAR 0 6
55949: UNION
55950: DIFF
55951: PPUSH
55952: LD_INT 2
55954: PPUSH
55955: CALL 45173 0 2
55959: ST_TO_ADDR
// p := [ ] ;
55960: LD_ADDR_VAR 0 11
55964: PUSH
55965: EMPTY
55966: ST_TO_ADDR
// if sort then
55967: LD_VAR 0 9
55971: IFFALSE 56087
// for i = 1 to 6 - eng do
55973: LD_ADDR_VAR 0 3
55977: PUSH
55978: DOUBLE
55979: LD_INT 1
55981: DEC
55982: ST_TO_ADDR
55983: LD_INT 6
55985: PUSH
55986: LD_VAR 0 6
55990: MINUS
55991: PUSH
55992: FOR_TO
55993: IFFALSE 56085
// begin if i = sort then
55995: LD_VAR 0 3
55999: PUSH
56000: LD_VAR 0 9
56004: EQUAL
56005: IFFALSE 56009
// break ;
56007: GO 56085
// if GetClass ( i ) = 2 then
56009: LD_VAR 0 3
56013: PPUSH
56014: CALL_OW 257
56018: PUSH
56019: LD_INT 2
56021: EQUAL
56022: IFFALSE 56026
// continue ;
56024: GO 55992
// p := Insert ( p , p + 1 , sort [ i ] ) ;
56026: LD_ADDR_VAR 0 11
56030: PUSH
56031: LD_VAR 0 11
56035: PPUSH
56036: LD_VAR 0 11
56040: PUSH
56041: LD_INT 1
56043: PLUS
56044: PPUSH
56045: LD_VAR 0 9
56049: PUSH
56050: LD_VAR 0 3
56054: ARRAY
56055: PPUSH
56056: CALL_OW 2
56060: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
56061: LD_ADDR_VAR 0 4
56065: PUSH
56066: LD_VAR 0 4
56070: PUSH
56071: LD_VAR 0 9
56075: PUSH
56076: LD_VAR 0 3
56080: ARRAY
56081: DIFF
56082: ST_TO_ADDR
// end ;
56083: GO 55992
56085: POP
56086: POP
// if p then
56087: LD_VAR 0 11
56091: IFFALSE 56116
// result := Replace ( result , 2 , p ) ;
56093: LD_ADDR_VAR 0 2
56097: PUSH
56098: LD_VAR 0 2
56102: PPUSH
56103: LD_INT 2
56105: PPUSH
56106: LD_VAR 0 11
56110: PPUSH
56111: CALL_OW 1
56115: ST_TO_ADDR
// end ; exit ;
56116: GO 56840
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
56118: LD_EXP 50
56122: PUSH
56123: LD_EXP 49
56127: PUSH
56128: LD_VAR 0 1
56132: ARRAY
56133: ARRAY
56134: NOT
56135: PUSH
56136: LD_EXP 23
56140: PUSH
56141: LD_VAR 0 1
56145: ARRAY
56146: PPUSH
56147: LD_INT 30
56149: PUSH
56150: LD_INT 3
56152: PUSH
56153: EMPTY
56154: LIST
56155: LIST
56156: PPUSH
56157: CALL_OW 72
56161: AND
56162: PUSH
56163: LD_EXP 28
56167: PUSH
56168: LD_VAR 0 1
56172: ARRAY
56173: NOT
56174: AND
56175: IFFALSE 56840
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
56177: LD_ADDR_EXP 65
56181: PUSH
56182: LD_EXP 65
56186: PPUSH
56187: LD_VAR 0 1
56191: PPUSH
56192: LD_INT 6
56194: PPUSH
56195: CALL_OW 1
56199: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
56200: LD_ADDR_VAR 0 2
56204: PUSH
56205: LD_INT 0
56207: PUSH
56208: LD_INT 0
56210: PUSH
56211: LD_INT 0
56213: PUSH
56214: LD_INT 0
56216: PUSH
56217: EMPTY
56218: LIST
56219: LIST
56220: LIST
56221: LIST
56222: ST_TO_ADDR
// if sci >= 1 then
56223: LD_VAR 0 8
56227: PUSH
56228: LD_INT 1
56230: GREATEREQUAL
56231: IFFALSE 56253
// tmp := tmp diff sci [ 1 ] ;
56233: LD_ADDR_VAR 0 4
56237: PUSH
56238: LD_VAR 0 4
56242: PUSH
56243: LD_VAR 0 8
56247: PUSH
56248: LD_INT 1
56250: ARRAY
56251: DIFF
56252: ST_TO_ADDR
// if tmp and not sci then
56253: LD_VAR 0 4
56257: PUSH
56258: LD_VAR 0 8
56262: NOT
56263: AND
56264: IFFALSE 56333
// begin sort := SortBySkill ( tmp , 4 ) ;
56266: LD_ADDR_VAR 0 9
56270: PUSH
56271: LD_VAR 0 4
56275: PPUSH
56276: LD_INT 4
56278: PPUSH
56279: CALL 45173 0 2
56283: ST_TO_ADDR
// if sort then
56284: LD_VAR 0 9
56288: IFFALSE 56304
// p := sort [ 1 ] ;
56290: LD_ADDR_VAR 0 11
56294: PUSH
56295: LD_VAR 0 9
56299: PUSH
56300: LD_INT 1
56302: ARRAY
56303: ST_TO_ADDR
// if p then
56304: LD_VAR 0 11
56308: IFFALSE 56333
// result := Replace ( result , 4 , p ) ;
56310: LD_ADDR_VAR 0 2
56314: PUSH
56315: LD_VAR 0 2
56319: PPUSH
56320: LD_INT 4
56322: PPUSH
56323: LD_VAR 0 11
56327: PPUSH
56328: CALL_OW 1
56332: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
56333: LD_ADDR_VAR 0 4
56337: PUSH
56338: LD_VAR 0 4
56342: PUSH
56343: LD_VAR 0 7
56347: DIFF
56348: ST_TO_ADDR
// if tmp and mech < 6 then
56349: LD_VAR 0 4
56353: PUSH
56354: LD_VAR 0 7
56358: PUSH
56359: LD_INT 6
56361: LESS
56362: AND
56363: IFFALSE 56545
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
56365: LD_ADDR_VAR 0 9
56369: PUSH
56370: LD_VAR 0 4
56374: PUSH
56375: LD_VAR 0 7
56379: DIFF
56380: PPUSH
56381: LD_INT 3
56383: PPUSH
56384: CALL 45173 0 2
56388: ST_TO_ADDR
// p := [ ] ;
56389: LD_ADDR_VAR 0 11
56393: PUSH
56394: EMPTY
56395: ST_TO_ADDR
// if sort then
56396: LD_VAR 0 9
56400: IFFALSE 56516
// for i = 1 to 6 - mech do
56402: LD_ADDR_VAR 0 3
56406: PUSH
56407: DOUBLE
56408: LD_INT 1
56410: DEC
56411: ST_TO_ADDR
56412: LD_INT 6
56414: PUSH
56415: LD_VAR 0 7
56419: MINUS
56420: PUSH
56421: FOR_TO
56422: IFFALSE 56514
// begin if i = sort then
56424: LD_VAR 0 3
56428: PUSH
56429: LD_VAR 0 9
56433: EQUAL
56434: IFFALSE 56438
// break ;
56436: GO 56514
// if GetClass ( i ) = 3 then
56438: LD_VAR 0 3
56442: PPUSH
56443: CALL_OW 257
56447: PUSH
56448: LD_INT 3
56450: EQUAL
56451: IFFALSE 56455
// continue ;
56453: GO 56421
// p := Insert ( p , p + 1 , sort [ i ] ) ;
56455: LD_ADDR_VAR 0 11
56459: PUSH
56460: LD_VAR 0 11
56464: PPUSH
56465: LD_VAR 0 11
56469: PUSH
56470: LD_INT 1
56472: PLUS
56473: PPUSH
56474: LD_VAR 0 9
56478: PUSH
56479: LD_VAR 0 3
56483: ARRAY
56484: PPUSH
56485: CALL_OW 2
56489: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
56490: LD_ADDR_VAR 0 4
56494: PUSH
56495: LD_VAR 0 4
56499: PUSH
56500: LD_VAR 0 9
56504: PUSH
56505: LD_VAR 0 3
56509: ARRAY
56510: DIFF
56511: ST_TO_ADDR
// end ;
56512: GO 56421
56514: POP
56515: POP
// if p then
56516: LD_VAR 0 11
56520: IFFALSE 56545
// result := Replace ( result , 3 , p ) ;
56522: LD_ADDR_VAR 0 2
56526: PUSH
56527: LD_VAR 0 2
56531: PPUSH
56532: LD_INT 3
56534: PPUSH
56535: LD_VAR 0 11
56539: PPUSH
56540: CALL_OW 1
56544: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
56545: LD_ADDR_VAR 0 4
56549: PUSH
56550: LD_VAR 0 4
56554: PUSH
56555: LD_VAR 0 6
56559: DIFF
56560: ST_TO_ADDR
// if tmp and eng < 4 then
56561: LD_VAR 0 4
56565: PUSH
56566: LD_VAR 0 6
56570: PUSH
56571: LD_INT 4
56573: LESS
56574: AND
56575: IFFALSE 56765
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
56577: LD_ADDR_VAR 0 9
56581: PUSH
56582: LD_VAR 0 4
56586: PUSH
56587: LD_VAR 0 7
56591: PUSH
56592: LD_VAR 0 6
56596: UNION
56597: DIFF
56598: PPUSH
56599: LD_INT 2
56601: PPUSH
56602: CALL 45173 0 2
56606: ST_TO_ADDR
// p := [ ] ;
56607: LD_ADDR_VAR 0 11
56611: PUSH
56612: EMPTY
56613: ST_TO_ADDR
// if sort then
56614: LD_VAR 0 9
56618: IFFALSE 56734
// for i = 1 to 4 - eng do
56620: LD_ADDR_VAR 0 3
56624: PUSH
56625: DOUBLE
56626: LD_INT 1
56628: DEC
56629: ST_TO_ADDR
56630: LD_INT 4
56632: PUSH
56633: LD_VAR 0 6
56637: MINUS
56638: PUSH
56639: FOR_TO
56640: IFFALSE 56732
// begin if i = sort then
56642: LD_VAR 0 3
56646: PUSH
56647: LD_VAR 0 9
56651: EQUAL
56652: IFFALSE 56656
// break ;
56654: GO 56732
// if GetClass ( i ) = 2 then
56656: LD_VAR 0 3
56660: PPUSH
56661: CALL_OW 257
56665: PUSH
56666: LD_INT 2
56668: EQUAL
56669: IFFALSE 56673
// continue ;
56671: GO 56639
// p := Insert ( p , p + 1 , sort [ i ] ) ;
56673: LD_ADDR_VAR 0 11
56677: PUSH
56678: LD_VAR 0 11
56682: PPUSH
56683: LD_VAR 0 11
56687: PUSH
56688: LD_INT 1
56690: PLUS
56691: PPUSH
56692: LD_VAR 0 9
56696: PUSH
56697: LD_VAR 0 3
56701: ARRAY
56702: PPUSH
56703: CALL_OW 2
56707: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
56708: LD_ADDR_VAR 0 4
56712: PUSH
56713: LD_VAR 0 4
56717: PUSH
56718: LD_VAR 0 9
56722: PUSH
56723: LD_VAR 0 3
56727: ARRAY
56728: DIFF
56729: ST_TO_ADDR
// end ;
56730: GO 56639
56732: POP
56733: POP
// if p then
56734: LD_VAR 0 11
56738: IFFALSE 56763
// result := Replace ( result , 2 , p ) ;
56740: LD_ADDR_VAR 0 2
56744: PUSH
56745: LD_VAR 0 2
56749: PPUSH
56750: LD_INT 2
56752: PPUSH
56753: LD_VAR 0 11
56757: PPUSH
56758: CALL_OW 1
56762: ST_TO_ADDR
// end else
56763: GO 56809
// for i = eng downto 5 do
56765: LD_ADDR_VAR 0 3
56769: PUSH
56770: DOUBLE
56771: LD_VAR 0 6
56775: INC
56776: ST_TO_ADDR
56777: LD_INT 5
56779: PUSH
56780: FOR_DOWNTO
56781: IFFALSE 56807
// tmp := tmp union eng [ i ] ;
56783: LD_ADDR_VAR 0 4
56787: PUSH
56788: LD_VAR 0 4
56792: PUSH
56793: LD_VAR 0 6
56797: PUSH
56798: LD_VAR 0 3
56802: ARRAY
56803: UNION
56804: ST_TO_ADDR
56805: GO 56780
56807: POP
56808: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
56809: LD_ADDR_VAR 0 2
56813: PUSH
56814: LD_VAR 0 2
56818: PPUSH
56819: LD_INT 1
56821: PPUSH
56822: LD_VAR 0 4
56826: PUSH
56827: LD_VAR 0 5
56831: DIFF
56832: PPUSH
56833: CALL_OW 1
56837: ST_TO_ADDR
// exit ;
56838: GO 56840
// end ; end ;
56840: LD_VAR 0 2
56844: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
56845: LD_INT 0
56847: PPUSH
56848: PPUSH
56849: PPUSH
// if not mc_bases then
56850: LD_EXP 23
56854: NOT
56855: IFFALSE 56859
// exit ;
56857: GO 56965
// for i = 1 to mc_bases do
56859: LD_ADDR_VAR 0 2
56863: PUSH
56864: DOUBLE
56865: LD_INT 1
56867: DEC
56868: ST_TO_ADDR
56869: LD_EXP 23
56873: PUSH
56874: FOR_TO
56875: IFFALSE 56956
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
56877: LD_ADDR_VAR 0 3
56881: PUSH
56882: LD_EXP 23
56886: PUSH
56887: LD_VAR 0 2
56891: ARRAY
56892: PPUSH
56893: LD_INT 21
56895: PUSH
56896: LD_INT 3
56898: PUSH
56899: EMPTY
56900: LIST
56901: LIST
56902: PUSH
56903: LD_INT 3
56905: PUSH
56906: LD_INT 24
56908: PUSH
56909: LD_INT 1000
56911: PUSH
56912: EMPTY
56913: LIST
56914: LIST
56915: PUSH
56916: EMPTY
56917: LIST
56918: LIST
56919: PUSH
56920: EMPTY
56921: LIST
56922: LIST
56923: PPUSH
56924: CALL_OW 72
56928: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
56929: LD_ADDR_EXP 24
56933: PUSH
56934: LD_EXP 24
56938: PPUSH
56939: LD_VAR 0 2
56943: PPUSH
56944: LD_VAR 0 3
56948: PPUSH
56949: CALL_OW 1
56953: ST_TO_ADDR
// end ;
56954: GO 56874
56956: POP
56957: POP
// RaiseSailEvent ( 101 ) ;
56958: LD_INT 101
56960: PPUSH
56961: CALL_OW 427
// end ;
56965: LD_VAR 0 1
56969: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
56970: LD_INT 0
56972: PPUSH
56973: PPUSH
56974: PPUSH
56975: PPUSH
56976: PPUSH
56977: PPUSH
56978: PPUSH
// if not mc_bases then
56979: LD_EXP 23
56983: NOT
56984: IFFALSE 56988
// exit ;
56986: GO 57550
// for i = 1 to mc_bases do
56988: LD_ADDR_VAR 0 2
56992: PUSH
56993: DOUBLE
56994: LD_INT 1
56996: DEC
56997: ST_TO_ADDR
56998: LD_EXP 23
57002: PUSH
57003: FOR_TO
57004: IFFALSE 57541
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
57006: LD_ADDR_VAR 0 5
57010: PUSH
57011: LD_EXP 23
57015: PUSH
57016: LD_VAR 0 2
57020: ARRAY
57021: PUSH
57022: LD_EXP 52
57026: PUSH
57027: LD_VAR 0 2
57031: ARRAY
57032: UNION
57033: PPUSH
57034: LD_INT 21
57036: PUSH
57037: LD_INT 1
57039: PUSH
57040: EMPTY
57041: LIST
57042: LIST
57043: PUSH
57044: LD_INT 1
57046: PUSH
57047: LD_INT 3
57049: PUSH
57050: LD_INT 54
57052: PUSH
57053: EMPTY
57054: LIST
57055: PUSH
57056: EMPTY
57057: LIST
57058: LIST
57059: PUSH
57060: LD_INT 3
57062: PUSH
57063: LD_INT 24
57065: PUSH
57066: LD_INT 1000
57068: PUSH
57069: EMPTY
57070: LIST
57071: LIST
57072: PUSH
57073: EMPTY
57074: LIST
57075: LIST
57076: PUSH
57077: EMPTY
57078: LIST
57079: LIST
57080: LIST
57081: PUSH
57082: EMPTY
57083: LIST
57084: LIST
57085: PPUSH
57086: CALL_OW 72
57090: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
57091: LD_ADDR_VAR 0 6
57095: PUSH
57096: LD_EXP 23
57100: PUSH
57101: LD_VAR 0 2
57105: ARRAY
57106: PPUSH
57107: LD_INT 21
57109: PUSH
57110: LD_INT 1
57112: PUSH
57113: EMPTY
57114: LIST
57115: LIST
57116: PUSH
57117: LD_INT 1
57119: PUSH
57120: LD_INT 3
57122: PUSH
57123: LD_INT 54
57125: PUSH
57126: EMPTY
57127: LIST
57128: PUSH
57129: EMPTY
57130: LIST
57131: LIST
57132: PUSH
57133: LD_INT 3
57135: PUSH
57136: LD_INT 24
57138: PUSH
57139: LD_INT 250
57141: PUSH
57142: EMPTY
57143: LIST
57144: LIST
57145: PUSH
57146: EMPTY
57147: LIST
57148: LIST
57149: PUSH
57150: EMPTY
57151: LIST
57152: LIST
57153: LIST
57154: PUSH
57155: EMPTY
57156: LIST
57157: LIST
57158: PPUSH
57159: CALL_OW 72
57163: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
57164: LD_ADDR_VAR 0 7
57168: PUSH
57169: LD_VAR 0 5
57173: PUSH
57174: LD_VAR 0 6
57178: DIFF
57179: ST_TO_ADDR
// if not need_heal_1 then
57180: LD_VAR 0 6
57184: NOT
57185: IFFALSE 57218
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
57187: LD_ADDR_EXP 26
57191: PUSH
57192: LD_EXP 26
57196: PPUSH
57197: LD_VAR 0 2
57201: PUSH
57202: LD_INT 1
57204: PUSH
57205: EMPTY
57206: LIST
57207: LIST
57208: PPUSH
57209: EMPTY
57210: PPUSH
57211: CALL 14915 0 3
57215: ST_TO_ADDR
57216: GO 57288
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
57218: LD_ADDR_EXP 26
57222: PUSH
57223: LD_EXP 26
57227: PPUSH
57228: LD_VAR 0 2
57232: PUSH
57233: LD_INT 1
57235: PUSH
57236: EMPTY
57237: LIST
57238: LIST
57239: PPUSH
57240: LD_EXP 26
57244: PUSH
57245: LD_VAR 0 2
57249: ARRAY
57250: PUSH
57251: LD_INT 1
57253: ARRAY
57254: PPUSH
57255: LD_INT 3
57257: PUSH
57258: LD_INT 24
57260: PUSH
57261: LD_INT 1000
57263: PUSH
57264: EMPTY
57265: LIST
57266: LIST
57267: PUSH
57268: EMPTY
57269: LIST
57270: LIST
57271: PPUSH
57272: CALL_OW 72
57276: PUSH
57277: LD_VAR 0 6
57281: UNION
57282: PPUSH
57283: CALL 14915 0 3
57287: ST_TO_ADDR
// if not need_heal_2 then
57288: LD_VAR 0 7
57292: NOT
57293: IFFALSE 57326
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
57295: LD_ADDR_EXP 26
57299: PUSH
57300: LD_EXP 26
57304: PPUSH
57305: LD_VAR 0 2
57309: PUSH
57310: LD_INT 2
57312: PUSH
57313: EMPTY
57314: LIST
57315: LIST
57316: PPUSH
57317: EMPTY
57318: PPUSH
57319: CALL 14915 0 3
57323: ST_TO_ADDR
57324: GO 57358
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
57326: LD_ADDR_EXP 26
57330: PUSH
57331: LD_EXP 26
57335: PPUSH
57336: LD_VAR 0 2
57340: PUSH
57341: LD_INT 2
57343: PUSH
57344: EMPTY
57345: LIST
57346: LIST
57347: PPUSH
57348: LD_VAR 0 7
57352: PPUSH
57353: CALL 14915 0 3
57357: ST_TO_ADDR
// if need_heal_2 then
57358: LD_VAR 0 7
57362: IFFALSE 57523
// for j in need_heal_2 do
57364: LD_ADDR_VAR 0 3
57368: PUSH
57369: LD_VAR 0 7
57373: PUSH
57374: FOR_IN
57375: IFFALSE 57521
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57377: LD_ADDR_VAR 0 5
57381: PUSH
57382: LD_EXP 23
57386: PUSH
57387: LD_VAR 0 2
57391: ARRAY
57392: PPUSH
57393: LD_INT 2
57395: PUSH
57396: LD_INT 30
57398: PUSH
57399: LD_INT 6
57401: PUSH
57402: EMPTY
57403: LIST
57404: LIST
57405: PUSH
57406: LD_INT 30
57408: PUSH
57409: LD_INT 7
57411: PUSH
57412: EMPTY
57413: LIST
57414: LIST
57415: PUSH
57416: LD_INT 30
57418: PUSH
57419: LD_INT 8
57421: PUSH
57422: EMPTY
57423: LIST
57424: LIST
57425: PUSH
57426: LD_INT 30
57428: PUSH
57429: LD_INT 0
57431: PUSH
57432: EMPTY
57433: LIST
57434: LIST
57435: PUSH
57436: LD_INT 30
57438: PUSH
57439: LD_INT 1
57441: PUSH
57442: EMPTY
57443: LIST
57444: LIST
57445: PUSH
57446: EMPTY
57447: LIST
57448: LIST
57449: LIST
57450: LIST
57451: LIST
57452: LIST
57453: PPUSH
57454: CALL_OW 72
57458: ST_TO_ADDR
// if tmp then
57459: LD_VAR 0 5
57463: IFFALSE 57519
// begin k := NearestUnitToUnit ( tmp , j ) ;
57465: LD_ADDR_VAR 0 4
57469: PUSH
57470: LD_VAR 0 5
57474: PPUSH
57475: LD_VAR 0 3
57479: PPUSH
57480: CALL_OW 74
57484: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
57485: LD_VAR 0 3
57489: PPUSH
57490: LD_VAR 0 4
57494: PPUSH
57495: CALL_OW 296
57499: PUSH
57500: LD_INT 5
57502: GREATER
57503: IFFALSE 57519
// ComMoveToNearbyEntrance ( j , k ) ;
57505: LD_VAR 0 3
57509: PPUSH
57510: LD_VAR 0 4
57514: PPUSH
57515: CALL 47534 0 2
// end ; end ;
57519: GO 57374
57521: POP
57522: POP
// if not need_heal_1 and not need_heal_2 then
57523: LD_VAR 0 6
57527: NOT
57528: PUSH
57529: LD_VAR 0 7
57533: NOT
57534: AND
57535: IFFALSE 57539
// continue ;
57537: GO 57003
// end ;
57539: GO 57003
57541: POP
57542: POP
// RaiseSailEvent ( 102 ) ;
57543: LD_INT 102
57545: PPUSH
57546: CALL_OW 427
// end ;
57550: LD_VAR 0 1
57554: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
57555: LD_INT 0
57557: PPUSH
57558: PPUSH
57559: PPUSH
57560: PPUSH
57561: PPUSH
57562: PPUSH
57563: PPUSH
57564: PPUSH
// if not mc_bases then
57565: LD_EXP 23
57569: NOT
57570: IFFALSE 57574
// exit ;
57572: GO 58435
// for i = 1 to mc_bases do
57574: LD_ADDR_VAR 0 2
57578: PUSH
57579: DOUBLE
57580: LD_INT 1
57582: DEC
57583: ST_TO_ADDR
57584: LD_EXP 23
57588: PUSH
57589: FOR_TO
57590: IFFALSE 58433
// begin if not mc_building_need_repair [ i ] then
57592: LD_EXP 24
57596: PUSH
57597: LD_VAR 0 2
57601: ARRAY
57602: NOT
57603: IFFALSE 57790
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
57605: LD_ADDR_VAR 0 6
57609: PUSH
57610: LD_EXP 42
57614: PUSH
57615: LD_VAR 0 2
57619: ARRAY
57620: PPUSH
57621: LD_INT 3
57623: PUSH
57624: LD_INT 24
57626: PUSH
57627: LD_INT 1000
57629: PUSH
57630: EMPTY
57631: LIST
57632: LIST
57633: PUSH
57634: EMPTY
57635: LIST
57636: LIST
57637: PUSH
57638: LD_INT 2
57640: PUSH
57641: LD_INT 34
57643: PUSH
57644: LD_INT 13
57646: PUSH
57647: EMPTY
57648: LIST
57649: LIST
57650: PUSH
57651: LD_INT 34
57653: PUSH
57654: LD_INT 52
57656: PUSH
57657: EMPTY
57658: LIST
57659: LIST
57660: PUSH
57661: LD_INT 34
57663: PUSH
57664: LD_EXP 73
57668: PUSH
57669: EMPTY
57670: LIST
57671: LIST
57672: PUSH
57673: EMPTY
57674: LIST
57675: LIST
57676: LIST
57677: LIST
57678: PUSH
57679: EMPTY
57680: LIST
57681: LIST
57682: PPUSH
57683: CALL_OW 72
57687: ST_TO_ADDR
// if cranes then
57688: LD_VAR 0 6
57692: IFFALSE 57754
// for j in cranes do
57694: LD_ADDR_VAR 0 3
57698: PUSH
57699: LD_VAR 0 6
57703: PUSH
57704: FOR_IN
57705: IFFALSE 57752
// if not IsInArea ( j , mc_parking [ i ] ) then
57707: LD_VAR 0 3
57711: PPUSH
57712: LD_EXP 47
57716: PUSH
57717: LD_VAR 0 2
57721: ARRAY
57722: PPUSH
57723: CALL_OW 308
57727: NOT
57728: IFFALSE 57750
// ComMoveToArea ( j , mc_parking [ i ] ) ;
57730: LD_VAR 0 3
57734: PPUSH
57735: LD_EXP 47
57739: PUSH
57740: LD_VAR 0 2
57744: ARRAY
57745: PPUSH
57746: CALL_OW 113
57750: GO 57704
57752: POP
57753: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
57754: LD_ADDR_EXP 25
57758: PUSH
57759: LD_EXP 25
57763: PPUSH
57764: LD_VAR 0 2
57768: PPUSH
57769: EMPTY
57770: PPUSH
57771: CALL_OW 1
57775: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
57776: LD_VAR 0 2
57780: PPUSH
57781: LD_INT 101
57783: PPUSH
57784: CALL 52678 0 2
// continue ;
57788: GO 57589
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
57790: LD_ADDR_EXP 29
57794: PUSH
57795: LD_EXP 29
57799: PPUSH
57800: LD_VAR 0 2
57804: PPUSH
57805: EMPTY
57806: PPUSH
57807: CALL_OW 1
57811: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
57812: LD_VAR 0 2
57816: PPUSH
57817: LD_INT 103
57819: PPUSH
57820: CALL 52678 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
57824: LD_ADDR_VAR 0 5
57828: PUSH
57829: LD_EXP 23
57833: PUSH
57834: LD_VAR 0 2
57838: ARRAY
57839: PUSH
57840: LD_EXP 52
57844: PUSH
57845: LD_VAR 0 2
57849: ARRAY
57850: UNION
57851: PPUSH
57852: LD_INT 2
57854: PUSH
57855: LD_INT 25
57857: PUSH
57858: LD_INT 2
57860: PUSH
57861: EMPTY
57862: LIST
57863: LIST
57864: PUSH
57865: LD_INT 25
57867: PUSH
57868: LD_INT 16
57870: PUSH
57871: EMPTY
57872: LIST
57873: LIST
57874: PUSH
57875: EMPTY
57876: LIST
57877: LIST
57878: LIST
57879: PUSH
57880: EMPTY
57881: LIST
57882: PPUSH
57883: CALL_OW 72
57887: PUSH
57888: LD_EXP 26
57892: PUSH
57893: LD_VAR 0 2
57897: ARRAY
57898: PUSH
57899: LD_INT 1
57901: ARRAY
57902: PUSH
57903: LD_EXP 26
57907: PUSH
57908: LD_VAR 0 2
57912: ARRAY
57913: PUSH
57914: LD_INT 2
57916: ARRAY
57917: UNION
57918: DIFF
57919: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
57920: LD_ADDR_VAR 0 6
57924: PUSH
57925: LD_EXP 42
57929: PUSH
57930: LD_VAR 0 2
57934: ARRAY
57935: PPUSH
57936: LD_INT 2
57938: PUSH
57939: LD_INT 34
57941: PUSH
57942: LD_INT 13
57944: PUSH
57945: EMPTY
57946: LIST
57947: LIST
57948: PUSH
57949: LD_INT 34
57951: PUSH
57952: LD_INT 52
57954: PUSH
57955: EMPTY
57956: LIST
57957: LIST
57958: PUSH
57959: LD_INT 34
57961: PUSH
57962: LD_EXP 73
57966: PUSH
57967: EMPTY
57968: LIST
57969: LIST
57970: PUSH
57971: EMPTY
57972: LIST
57973: LIST
57974: LIST
57975: LIST
57976: PPUSH
57977: CALL_OW 72
57981: ST_TO_ADDR
// if cranes then
57982: LD_VAR 0 6
57986: IFFALSE 58122
// begin for j in cranes do
57988: LD_ADDR_VAR 0 3
57992: PUSH
57993: LD_VAR 0 6
57997: PUSH
57998: FOR_IN
57999: IFFALSE 58120
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
58001: LD_VAR 0 3
58005: PPUSH
58006: CALL_OW 256
58010: PUSH
58011: LD_INT 1000
58013: EQUAL
58014: PUSH
58015: LD_VAR 0 3
58019: PPUSH
58020: CALL_OW 314
58024: NOT
58025: AND
58026: IFFALSE 58060
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
58028: LD_VAR 0 3
58032: PPUSH
58033: LD_EXP 24
58037: PUSH
58038: LD_VAR 0 2
58042: ARRAY
58043: PPUSH
58044: LD_VAR 0 3
58048: PPUSH
58049: CALL_OW 74
58053: PPUSH
58054: CALL_OW 130
58058: GO 58118
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
58060: LD_VAR 0 3
58064: PPUSH
58065: CALL_OW 256
58069: PUSH
58070: LD_INT 500
58072: LESS
58073: PUSH
58074: LD_VAR 0 3
58078: PPUSH
58079: LD_EXP 47
58083: PUSH
58084: LD_VAR 0 2
58088: ARRAY
58089: PPUSH
58090: CALL_OW 308
58094: NOT
58095: AND
58096: IFFALSE 58118
// ComMoveToArea ( j , mc_parking [ i ] ) ;
58098: LD_VAR 0 3
58102: PPUSH
58103: LD_EXP 47
58107: PUSH
58108: LD_VAR 0 2
58112: ARRAY
58113: PPUSH
58114: CALL_OW 113
// end ;
58118: GO 57998
58120: POP
58121: POP
// end ; if tmp > 3 then
58122: LD_VAR 0 5
58126: PUSH
58127: LD_INT 3
58129: GREATER
58130: IFFALSE 58150
// tmp := ShrinkArray ( tmp , 4 ) ;
58132: LD_ADDR_VAR 0 5
58136: PUSH
58137: LD_VAR 0 5
58141: PPUSH
58142: LD_INT 4
58144: PPUSH
58145: CALL 46982 0 2
58149: ST_TO_ADDR
// if not tmp then
58150: LD_VAR 0 5
58154: NOT
58155: IFFALSE 58159
// continue ;
58157: GO 57589
// for j in tmp do
58159: LD_ADDR_VAR 0 3
58163: PUSH
58164: LD_VAR 0 5
58168: PUSH
58169: FOR_IN
58170: IFFALSE 58429
// begin if IsInUnit ( j ) then
58172: LD_VAR 0 3
58176: PPUSH
58177: CALL_OW 310
58181: IFFALSE 58192
// ComExitBuilding ( j ) ;
58183: LD_VAR 0 3
58187: PPUSH
58188: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
58192: LD_VAR 0 3
58196: PUSH
58197: LD_EXP 25
58201: PUSH
58202: LD_VAR 0 2
58206: ARRAY
58207: IN
58208: NOT
58209: IFFALSE 58267
// begin SetTag ( j , 101 ) ;
58211: LD_VAR 0 3
58215: PPUSH
58216: LD_INT 101
58218: PPUSH
58219: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
58223: LD_ADDR_EXP 25
58227: PUSH
58228: LD_EXP 25
58232: PPUSH
58233: LD_VAR 0 2
58237: PUSH
58238: LD_EXP 25
58242: PUSH
58243: LD_VAR 0 2
58247: ARRAY
58248: PUSH
58249: LD_INT 1
58251: PLUS
58252: PUSH
58253: EMPTY
58254: LIST
58255: LIST
58256: PPUSH
58257: LD_VAR 0 3
58261: PPUSH
58262: CALL 14915 0 3
58266: ST_TO_ADDR
// end ; wait ( 1 ) ;
58267: LD_INT 1
58269: PPUSH
58270: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
58274: LD_ADDR_VAR 0 7
58278: PUSH
58279: LD_EXP 24
58283: PUSH
58284: LD_VAR 0 2
58288: ARRAY
58289: ST_TO_ADDR
// if mc_scan [ i ] then
58290: LD_EXP 46
58294: PUSH
58295: LD_VAR 0 2
58299: ARRAY
58300: IFFALSE 58362
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
58302: LD_ADDR_VAR 0 7
58306: PUSH
58307: LD_EXP 24
58311: PUSH
58312: LD_VAR 0 2
58316: ARRAY
58317: PPUSH
58318: LD_INT 3
58320: PUSH
58321: LD_INT 30
58323: PUSH
58324: LD_INT 32
58326: PUSH
58327: EMPTY
58328: LIST
58329: LIST
58330: PUSH
58331: LD_INT 30
58333: PUSH
58334: LD_INT 33
58336: PUSH
58337: EMPTY
58338: LIST
58339: LIST
58340: PUSH
58341: LD_INT 30
58343: PUSH
58344: LD_INT 31
58346: PUSH
58347: EMPTY
58348: LIST
58349: LIST
58350: PUSH
58351: EMPTY
58352: LIST
58353: LIST
58354: LIST
58355: LIST
58356: PPUSH
58357: CALL_OW 72
58361: ST_TO_ADDR
// if not to_repair_tmp then
58362: LD_VAR 0 7
58366: NOT
58367: IFFALSE 58371
// continue ;
58369: GO 58169
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
58371: LD_ADDR_VAR 0 8
58375: PUSH
58376: LD_VAR 0 7
58380: PPUSH
58381: LD_VAR 0 3
58385: PPUSH
58386: CALL_OW 74
58390: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
58391: LD_VAR 0 8
58395: PPUSH
58396: LD_INT 16
58398: PPUSH
58399: CALL 17514 0 2
58403: PUSH
58404: LD_INT 4
58406: ARRAY
58407: PUSH
58408: LD_INT 10
58410: LESS
58411: IFFALSE 58427
// ComRepairBuilding ( j , to_repair ) ;
58413: LD_VAR 0 3
58417: PPUSH
58418: LD_VAR 0 8
58422: PPUSH
58423: CALL_OW 130
// end ;
58427: GO 58169
58429: POP
58430: POP
// end ;
58431: GO 57589
58433: POP
58434: POP
// end ;
58435: LD_VAR 0 1
58439: RET
// export function MC_Heal ; var i , j , tmp ; begin
58440: LD_INT 0
58442: PPUSH
58443: PPUSH
58444: PPUSH
58445: PPUSH
// if not mc_bases then
58446: LD_EXP 23
58450: NOT
58451: IFFALSE 58455
// exit ;
58453: GO 58857
// for i = 1 to mc_bases do
58455: LD_ADDR_VAR 0 2
58459: PUSH
58460: DOUBLE
58461: LD_INT 1
58463: DEC
58464: ST_TO_ADDR
58465: LD_EXP 23
58469: PUSH
58470: FOR_TO
58471: IFFALSE 58855
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
58473: LD_EXP 26
58477: PUSH
58478: LD_VAR 0 2
58482: ARRAY
58483: PUSH
58484: LD_INT 1
58486: ARRAY
58487: NOT
58488: PUSH
58489: LD_EXP 26
58493: PUSH
58494: LD_VAR 0 2
58498: ARRAY
58499: PUSH
58500: LD_INT 2
58502: ARRAY
58503: NOT
58504: AND
58505: IFFALSE 58543
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
58507: LD_ADDR_EXP 27
58511: PUSH
58512: LD_EXP 27
58516: PPUSH
58517: LD_VAR 0 2
58521: PPUSH
58522: EMPTY
58523: PPUSH
58524: CALL_OW 1
58528: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
58529: LD_VAR 0 2
58533: PPUSH
58534: LD_INT 102
58536: PPUSH
58537: CALL 52678 0 2
// continue ;
58541: GO 58470
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
58543: LD_ADDR_VAR 0 4
58547: PUSH
58548: LD_EXP 23
58552: PUSH
58553: LD_VAR 0 2
58557: ARRAY
58558: PPUSH
58559: LD_INT 25
58561: PUSH
58562: LD_INT 4
58564: PUSH
58565: EMPTY
58566: LIST
58567: LIST
58568: PPUSH
58569: CALL_OW 72
58573: ST_TO_ADDR
// if not tmp then
58574: LD_VAR 0 4
58578: NOT
58579: IFFALSE 58583
// continue ;
58581: GO 58470
// if mc_taming [ i ] then
58583: LD_EXP 54
58587: PUSH
58588: LD_VAR 0 2
58592: ARRAY
58593: IFFALSE 58617
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
58595: LD_ADDR_EXP 54
58599: PUSH
58600: LD_EXP 54
58604: PPUSH
58605: LD_VAR 0 2
58609: PPUSH
58610: EMPTY
58611: PPUSH
58612: CALL_OW 1
58616: ST_TO_ADDR
// for j in tmp do
58617: LD_ADDR_VAR 0 3
58621: PUSH
58622: LD_VAR 0 4
58626: PUSH
58627: FOR_IN
58628: IFFALSE 58851
// begin if IsInUnit ( j ) then
58630: LD_VAR 0 3
58634: PPUSH
58635: CALL_OW 310
58639: IFFALSE 58650
// ComExitBuilding ( j ) ;
58641: LD_VAR 0 3
58645: PPUSH
58646: CALL_OW 122
// if not j in mc_healers [ i ] then
58650: LD_VAR 0 3
58654: PUSH
58655: LD_EXP 27
58659: PUSH
58660: LD_VAR 0 2
58664: ARRAY
58665: IN
58666: NOT
58667: IFFALSE 58713
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
58669: LD_ADDR_EXP 27
58673: PUSH
58674: LD_EXP 27
58678: PPUSH
58679: LD_VAR 0 2
58683: PUSH
58684: LD_EXP 27
58688: PUSH
58689: LD_VAR 0 2
58693: ARRAY
58694: PUSH
58695: LD_INT 1
58697: PLUS
58698: PUSH
58699: EMPTY
58700: LIST
58701: LIST
58702: PPUSH
58703: LD_VAR 0 3
58707: PPUSH
58708: CALL 14915 0 3
58712: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
58713: LD_VAR 0 3
58717: PPUSH
58718: CALL_OW 110
58722: PUSH
58723: LD_INT 102
58725: NONEQUAL
58726: IFFALSE 58740
// SetTag ( j , 102 ) ;
58728: LD_VAR 0 3
58732: PPUSH
58733: LD_INT 102
58735: PPUSH
58736: CALL_OW 109
// Wait ( 3 ) ;
58740: LD_INT 3
58742: PPUSH
58743: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
58747: LD_EXP 26
58751: PUSH
58752: LD_VAR 0 2
58756: ARRAY
58757: PUSH
58758: LD_INT 1
58760: ARRAY
58761: IFFALSE 58793
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
58763: LD_VAR 0 3
58767: PPUSH
58768: LD_EXP 26
58772: PUSH
58773: LD_VAR 0 2
58777: ARRAY
58778: PUSH
58779: LD_INT 1
58781: ARRAY
58782: PUSH
58783: LD_INT 1
58785: ARRAY
58786: PPUSH
58787: CALL_OW 128
58791: GO 58849
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
58793: LD_VAR 0 3
58797: PPUSH
58798: CALL_OW 314
58802: NOT
58803: PUSH
58804: LD_EXP 26
58808: PUSH
58809: LD_VAR 0 2
58813: ARRAY
58814: PUSH
58815: LD_INT 2
58817: ARRAY
58818: AND
58819: IFFALSE 58849
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
58821: LD_VAR 0 3
58825: PPUSH
58826: LD_EXP 26
58830: PUSH
58831: LD_VAR 0 2
58835: ARRAY
58836: PUSH
58837: LD_INT 2
58839: ARRAY
58840: PUSH
58841: LD_INT 1
58843: ARRAY
58844: PPUSH
58845: CALL_OW 128
// end ;
58849: GO 58627
58851: POP
58852: POP
// end ;
58853: GO 58470
58855: POP
58856: POP
// end ;
58857: LD_VAR 0 1
58861: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
58862: LD_INT 0
58864: PPUSH
58865: PPUSH
58866: PPUSH
58867: PPUSH
58868: PPUSH
// if not mc_bases then
58869: LD_EXP 23
58873: NOT
58874: IFFALSE 58878
// exit ;
58876: GO 60049
// for i = 1 to mc_bases do
58878: LD_ADDR_VAR 0 2
58882: PUSH
58883: DOUBLE
58884: LD_INT 1
58886: DEC
58887: ST_TO_ADDR
58888: LD_EXP 23
58892: PUSH
58893: FOR_TO
58894: IFFALSE 60047
// begin if mc_scan [ i ] then
58896: LD_EXP 46
58900: PUSH
58901: LD_VAR 0 2
58905: ARRAY
58906: IFFALSE 58910
// continue ;
58908: GO 58893
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
58910: LD_EXP 28
58914: PUSH
58915: LD_VAR 0 2
58919: ARRAY
58920: NOT
58921: PUSH
58922: LD_EXP 30
58926: PUSH
58927: LD_VAR 0 2
58931: ARRAY
58932: NOT
58933: AND
58934: PUSH
58935: LD_EXP 29
58939: PUSH
58940: LD_VAR 0 2
58944: ARRAY
58945: AND
58946: IFFALSE 58984
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
58948: LD_ADDR_EXP 29
58952: PUSH
58953: LD_EXP 29
58957: PPUSH
58958: LD_VAR 0 2
58962: PPUSH
58963: EMPTY
58964: PPUSH
58965: CALL_OW 1
58969: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
58970: LD_VAR 0 2
58974: PPUSH
58975: LD_INT 103
58977: PPUSH
58978: CALL 52678 0 2
// continue ;
58982: GO 58893
// end ; if mc_construct_list [ i ] then
58984: LD_EXP 30
58988: PUSH
58989: LD_VAR 0 2
58993: ARRAY
58994: IFFALSE 59214
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
58996: LD_ADDR_VAR 0 4
59000: PUSH
59001: LD_EXP 23
59005: PUSH
59006: LD_VAR 0 2
59010: ARRAY
59011: PPUSH
59012: LD_INT 25
59014: PUSH
59015: LD_INT 2
59017: PUSH
59018: EMPTY
59019: LIST
59020: LIST
59021: PPUSH
59022: CALL_OW 72
59026: PUSH
59027: LD_EXP 25
59031: PUSH
59032: LD_VAR 0 2
59036: ARRAY
59037: DIFF
59038: ST_TO_ADDR
// if not tmp then
59039: LD_VAR 0 4
59043: NOT
59044: IFFALSE 59048
// continue ;
59046: GO 58893
// for j in tmp do
59048: LD_ADDR_VAR 0 3
59052: PUSH
59053: LD_VAR 0 4
59057: PUSH
59058: FOR_IN
59059: IFFALSE 59210
// begin if not mc_builders [ i ] then
59061: LD_EXP 29
59065: PUSH
59066: LD_VAR 0 2
59070: ARRAY
59071: NOT
59072: IFFALSE 59130
// begin SetTag ( j , 103 ) ;
59074: LD_VAR 0 3
59078: PPUSH
59079: LD_INT 103
59081: PPUSH
59082: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
59086: LD_ADDR_EXP 29
59090: PUSH
59091: LD_EXP 29
59095: PPUSH
59096: LD_VAR 0 2
59100: PUSH
59101: LD_EXP 29
59105: PUSH
59106: LD_VAR 0 2
59110: ARRAY
59111: PUSH
59112: LD_INT 1
59114: PLUS
59115: PUSH
59116: EMPTY
59117: LIST
59118: LIST
59119: PPUSH
59120: LD_VAR 0 3
59124: PPUSH
59125: CALL 14915 0 3
59129: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
59130: LD_VAR 0 3
59134: PPUSH
59135: CALL_OW 310
59139: IFFALSE 59150
// ComExitBuilding ( j ) ;
59141: LD_VAR 0 3
59145: PPUSH
59146: CALL_OW 122
// wait ( 3 ) ;
59150: LD_INT 3
59152: PPUSH
59153: CALL_OW 67
// if not mc_construct_list [ i ] then
59157: LD_EXP 30
59161: PUSH
59162: LD_VAR 0 2
59166: ARRAY
59167: NOT
59168: IFFALSE 59172
// break ;
59170: GO 59210
// if not HasTask ( j ) then
59172: LD_VAR 0 3
59176: PPUSH
59177: CALL_OW 314
59181: NOT
59182: IFFALSE 59208
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
59184: LD_VAR 0 3
59188: PPUSH
59189: LD_EXP 30
59193: PUSH
59194: LD_VAR 0 2
59198: ARRAY
59199: PUSH
59200: LD_INT 1
59202: ARRAY
59203: PPUSH
59204: CALL 17778 0 2
// end ;
59208: GO 59058
59210: POP
59211: POP
// end else
59212: GO 60045
// if mc_build_list [ i ] then
59214: LD_EXP 28
59218: PUSH
59219: LD_VAR 0 2
59223: ARRAY
59224: IFFALSE 60045
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
59226: LD_ADDR_VAR 0 5
59230: PUSH
59231: LD_EXP 23
59235: PUSH
59236: LD_VAR 0 2
59240: ARRAY
59241: PPUSH
59242: LD_INT 2
59244: PUSH
59245: LD_INT 30
59247: PUSH
59248: LD_INT 0
59250: PUSH
59251: EMPTY
59252: LIST
59253: LIST
59254: PUSH
59255: LD_INT 30
59257: PUSH
59258: LD_INT 1
59260: PUSH
59261: EMPTY
59262: LIST
59263: LIST
59264: PUSH
59265: EMPTY
59266: LIST
59267: LIST
59268: LIST
59269: PPUSH
59270: CALL_OW 72
59274: ST_TO_ADDR
// if depot then
59275: LD_VAR 0 5
59279: IFFALSE 59297
// depot := depot [ 1 ] else
59281: LD_ADDR_VAR 0 5
59285: PUSH
59286: LD_VAR 0 5
59290: PUSH
59291: LD_INT 1
59293: ARRAY
59294: ST_TO_ADDR
59295: GO 59305
// depot := 0 ;
59297: LD_ADDR_VAR 0 5
59301: PUSH
59302: LD_INT 0
59304: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
59305: LD_EXP 28
59309: PUSH
59310: LD_VAR 0 2
59314: ARRAY
59315: PUSH
59316: LD_INT 1
59318: ARRAY
59319: PUSH
59320: LD_INT 1
59322: ARRAY
59323: PPUSH
59324: CALL 17602 0 1
59328: PUSH
59329: LD_EXP 23
59333: PUSH
59334: LD_VAR 0 2
59338: ARRAY
59339: PPUSH
59340: LD_INT 2
59342: PUSH
59343: LD_INT 30
59345: PUSH
59346: LD_INT 2
59348: PUSH
59349: EMPTY
59350: LIST
59351: LIST
59352: PUSH
59353: LD_INT 30
59355: PUSH
59356: LD_INT 3
59358: PUSH
59359: EMPTY
59360: LIST
59361: LIST
59362: PUSH
59363: EMPTY
59364: LIST
59365: LIST
59366: LIST
59367: PPUSH
59368: CALL_OW 72
59372: NOT
59373: AND
59374: IFFALSE 59479
// begin for j = 1 to mc_build_list [ i ] do
59376: LD_ADDR_VAR 0 3
59380: PUSH
59381: DOUBLE
59382: LD_INT 1
59384: DEC
59385: ST_TO_ADDR
59386: LD_EXP 28
59390: PUSH
59391: LD_VAR 0 2
59395: ARRAY
59396: PUSH
59397: FOR_TO
59398: IFFALSE 59477
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
59400: LD_EXP 28
59404: PUSH
59405: LD_VAR 0 2
59409: ARRAY
59410: PUSH
59411: LD_VAR 0 3
59415: ARRAY
59416: PUSH
59417: LD_INT 1
59419: ARRAY
59420: PUSH
59421: LD_INT 2
59423: EQUAL
59424: IFFALSE 59475
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
59426: LD_ADDR_EXP 28
59430: PUSH
59431: LD_EXP 28
59435: PPUSH
59436: LD_VAR 0 2
59440: PPUSH
59441: LD_EXP 28
59445: PUSH
59446: LD_VAR 0 2
59450: ARRAY
59451: PPUSH
59452: LD_VAR 0 3
59456: PPUSH
59457: LD_INT 1
59459: PPUSH
59460: LD_INT 0
59462: PPUSH
59463: CALL 14333 0 4
59467: PPUSH
59468: CALL_OW 1
59472: ST_TO_ADDR
// break ;
59473: GO 59477
// end ;
59475: GO 59397
59477: POP
59478: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
59479: LD_EXP 28
59483: PUSH
59484: LD_VAR 0 2
59488: ARRAY
59489: PUSH
59490: LD_INT 1
59492: ARRAY
59493: PUSH
59494: LD_INT 1
59496: ARRAY
59497: PUSH
59498: LD_INT 0
59500: EQUAL
59501: PUSH
59502: LD_VAR 0 5
59506: PUSH
59507: LD_VAR 0 5
59511: PPUSH
59512: LD_EXP 28
59516: PUSH
59517: LD_VAR 0 2
59521: ARRAY
59522: PUSH
59523: LD_INT 1
59525: ARRAY
59526: PUSH
59527: LD_INT 1
59529: ARRAY
59530: PPUSH
59531: LD_EXP 28
59535: PUSH
59536: LD_VAR 0 2
59540: ARRAY
59541: PUSH
59542: LD_INT 1
59544: ARRAY
59545: PUSH
59546: LD_INT 2
59548: ARRAY
59549: PPUSH
59550: LD_EXP 28
59554: PUSH
59555: LD_VAR 0 2
59559: ARRAY
59560: PUSH
59561: LD_INT 1
59563: ARRAY
59564: PUSH
59565: LD_INT 3
59567: ARRAY
59568: PPUSH
59569: LD_EXP 28
59573: PUSH
59574: LD_VAR 0 2
59578: ARRAY
59579: PUSH
59580: LD_INT 1
59582: ARRAY
59583: PUSH
59584: LD_INT 4
59586: ARRAY
59587: PPUSH
59588: CALL 23019 0 5
59592: AND
59593: OR
59594: IFFALSE 59875
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
59596: LD_ADDR_VAR 0 4
59600: PUSH
59601: LD_EXP 23
59605: PUSH
59606: LD_VAR 0 2
59610: ARRAY
59611: PPUSH
59612: LD_INT 25
59614: PUSH
59615: LD_INT 2
59617: PUSH
59618: EMPTY
59619: LIST
59620: LIST
59621: PPUSH
59622: CALL_OW 72
59626: PUSH
59627: LD_EXP 25
59631: PUSH
59632: LD_VAR 0 2
59636: ARRAY
59637: DIFF
59638: ST_TO_ADDR
// if not tmp then
59639: LD_VAR 0 4
59643: NOT
59644: IFFALSE 59648
// continue ;
59646: GO 58893
// for j in tmp do
59648: LD_ADDR_VAR 0 3
59652: PUSH
59653: LD_VAR 0 4
59657: PUSH
59658: FOR_IN
59659: IFFALSE 59871
// begin if not mc_builders [ i ] then
59661: LD_EXP 29
59665: PUSH
59666: LD_VAR 0 2
59670: ARRAY
59671: NOT
59672: IFFALSE 59730
// begin SetTag ( j , 103 ) ;
59674: LD_VAR 0 3
59678: PPUSH
59679: LD_INT 103
59681: PPUSH
59682: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
59686: LD_ADDR_EXP 29
59690: PUSH
59691: LD_EXP 29
59695: PPUSH
59696: LD_VAR 0 2
59700: PUSH
59701: LD_EXP 29
59705: PUSH
59706: LD_VAR 0 2
59710: ARRAY
59711: PUSH
59712: LD_INT 1
59714: PLUS
59715: PUSH
59716: EMPTY
59717: LIST
59718: LIST
59719: PPUSH
59720: LD_VAR 0 3
59724: PPUSH
59725: CALL 14915 0 3
59729: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
59730: LD_VAR 0 3
59734: PPUSH
59735: CALL_OW 310
59739: IFFALSE 59750
// ComExitBuilding ( j ) ;
59741: LD_VAR 0 3
59745: PPUSH
59746: CALL_OW 122
// wait ( 3 ) ;
59750: LD_INT 3
59752: PPUSH
59753: CALL_OW 67
// if not mc_build_list [ i ] then
59757: LD_EXP 28
59761: PUSH
59762: LD_VAR 0 2
59766: ARRAY
59767: NOT
59768: IFFALSE 59772
// break ;
59770: GO 59871
// if not HasTask ( j ) then
59772: LD_VAR 0 3
59776: PPUSH
59777: CALL_OW 314
59781: NOT
59782: IFFALSE 59869
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
59784: LD_VAR 0 3
59788: PPUSH
59789: LD_EXP 28
59793: PUSH
59794: LD_VAR 0 2
59798: ARRAY
59799: PUSH
59800: LD_INT 1
59802: ARRAY
59803: PUSH
59804: LD_INT 1
59806: ARRAY
59807: PPUSH
59808: LD_EXP 28
59812: PUSH
59813: LD_VAR 0 2
59817: ARRAY
59818: PUSH
59819: LD_INT 1
59821: ARRAY
59822: PUSH
59823: LD_INT 2
59825: ARRAY
59826: PPUSH
59827: LD_EXP 28
59831: PUSH
59832: LD_VAR 0 2
59836: ARRAY
59837: PUSH
59838: LD_INT 1
59840: ARRAY
59841: PUSH
59842: LD_INT 3
59844: ARRAY
59845: PPUSH
59846: LD_EXP 28
59850: PUSH
59851: LD_VAR 0 2
59855: ARRAY
59856: PUSH
59857: LD_INT 1
59859: ARRAY
59860: PUSH
59861: LD_INT 4
59863: ARRAY
59864: PPUSH
59865: CALL_OW 145
// end ;
59869: GO 59658
59871: POP
59872: POP
// end else
59873: GO 60045
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
59875: LD_EXP 23
59879: PUSH
59880: LD_VAR 0 2
59884: ARRAY
59885: PPUSH
59886: LD_EXP 28
59890: PUSH
59891: LD_VAR 0 2
59895: ARRAY
59896: PUSH
59897: LD_INT 1
59899: ARRAY
59900: PUSH
59901: LD_INT 1
59903: ARRAY
59904: PPUSH
59905: LD_EXP 28
59909: PUSH
59910: LD_VAR 0 2
59914: ARRAY
59915: PUSH
59916: LD_INT 1
59918: ARRAY
59919: PUSH
59920: LD_INT 2
59922: ARRAY
59923: PPUSH
59924: LD_EXP 28
59928: PUSH
59929: LD_VAR 0 2
59933: ARRAY
59934: PUSH
59935: LD_INT 1
59937: ARRAY
59938: PUSH
59939: LD_INT 3
59941: ARRAY
59942: PPUSH
59943: LD_EXP 28
59947: PUSH
59948: LD_VAR 0 2
59952: ARRAY
59953: PUSH
59954: LD_INT 1
59956: ARRAY
59957: PUSH
59958: LD_INT 4
59960: ARRAY
59961: PPUSH
59962: LD_EXP 23
59966: PUSH
59967: LD_VAR 0 2
59971: ARRAY
59972: PPUSH
59973: LD_INT 21
59975: PUSH
59976: LD_INT 3
59978: PUSH
59979: EMPTY
59980: LIST
59981: LIST
59982: PPUSH
59983: CALL_OW 72
59987: PPUSH
59988: EMPTY
59989: PPUSH
59990: CALL 21769 0 7
59994: NOT
59995: IFFALSE 60045
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
59997: LD_ADDR_EXP 28
60001: PUSH
60002: LD_EXP 28
60006: PPUSH
60007: LD_VAR 0 2
60011: PPUSH
60012: LD_EXP 28
60016: PUSH
60017: LD_VAR 0 2
60021: ARRAY
60022: PPUSH
60023: LD_INT 1
60025: PPUSH
60026: LD_INT 1
60028: NEG
60029: PPUSH
60030: LD_INT 0
60032: PPUSH
60033: CALL 14333 0 4
60037: PPUSH
60038: CALL_OW 1
60042: ST_TO_ADDR
// continue ;
60043: GO 58893
// end ; end ; end ;
60045: GO 58893
60047: POP
60048: POP
// end ;
60049: LD_VAR 0 1
60053: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
60054: LD_INT 0
60056: PPUSH
60057: PPUSH
60058: PPUSH
60059: PPUSH
60060: PPUSH
60061: PPUSH
// if not mc_bases then
60062: LD_EXP 23
60066: NOT
60067: IFFALSE 60071
// exit ;
60069: GO 60498
// for i = 1 to mc_bases do
60071: LD_ADDR_VAR 0 2
60075: PUSH
60076: DOUBLE
60077: LD_INT 1
60079: DEC
60080: ST_TO_ADDR
60081: LD_EXP 23
60085: PUSH
60086: FOR_TO
60087: IFFALSE 60496
// begin tmp := mc_build_upgrade [ i ] ;
60089: LD_ADDR_VAR 0 4
60093: PUSH
60094: LD_EXP 55
60098: PUSH
60099: LD_VAR 0 2
60103: ARRAY
60104: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
60105: LD_ADDR_VAR 0 6
60109: PUSH
60110: LD_EXP 56
60114: PUSH
60115: LD_VAR 0 2
60119: ARRAY
60120: PPUSH
60121: LD_INT 2
60123: PUSH
60124: LD_INT 30
60126: PUSH
60127: LD_INT 6
60129: PUSH
60130: EMPTY
60131: LIST
60132: LIST
60133: PUSH
60134: LD_INT 30
60136: PUSH
60137: LD_INT 7
60139: PUSH
60140: EMPTY
60141: LIST
60142: LIST
60143: PUSH
60144: EMPTY
60145: LIST
60146: LIST
60147: LIST
60148: PPUSH
60149: CALL_OW 72
60153: ST_TO_ADDR
// if not tmp and not lab then
60154: LD_VAR 0 4
60158: NOT
60159: PUSH
60160: LD_VAR 0 6
60164: NOT
60165: AND
60166: IFFALSE 60170
// continue ;
60168: GO 60086
// if tmp then
60170: LD_VAR 0 4
60174: IFFALSE 60294
// for j in tmp do
60176: LD_ADDR_VAR 0 3
60180: PUSH
60181: LD_VAR 0 4
60185: PUSH
60186: FOR_IN
60187: IFFALSE 60292
// begin if UpgradeCost ( j ) then
60189: LD_VAR 0 3
60193: PPUSH
60194: CALL 21429 0 1
60198: IFFALSE 60290
// begin ComUpgrade ( j ) ;
60200: LD_VAR 0 3
60204: PPUSH
60205: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
60209: LD_ADDR_EXP 55
60213: PUSH
60214: LD_EXP 55
60218: PPUSH
60219: LD_VAR 0 2
60223: PPUSH
60224: LD_EXP 55
60228: PUSH
60229: LD_VAR 0 2
60233: ARRAY
60234: PUSH
60235: LD_VAR 0 3
60239: DIFF
60240: PPUSH
60241: CALL_OW 1
60245: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
60246: LD_ADDR_EXP 30
60250: PUSH
60251: LD_EXP 30
60255: PPUSH
60256: LD_VAR 0 2
60260: PUSH
60261: LD_EXP 30
60265: PUSH
60266: LD_VAR 0 2
60270: ARRAY
60271: PUSH
60272: LD_INT 1
60274: PLUS
60275: PUSH
60276: EMPTY
60277: LIST
60278: LIST
60279: PPUSH
60280: LD_VAR 0 3
60284: PPUSH
60285: CALL 14915 0 3
60289: ST_TO_ADDR
// end ; end ;
60290: GO 60186
60292: POP
60293: POP
// if not lab or not mc_lab_upgrade [ i ] then
60294: LD_VAR 0 6
60298: NOT
60299: PUSH
60300: LD_EXP 57
60304: PUSH
60305: LD_VAR 0 2
60309: ARRAY
60310: NOT
60311: OR
60312: IFFALSE 60316
// continue ;
60314: GO 60086
// for j in lab do
60316: LD_ADDR_VAR 0 3
60320: PUSH
60321: LD_VAR 0 6
60325: PUSH
60326: FOR_IN
60327: IFFALSE 60492
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
60329: LD_VAR 0 3
60333: PPUSH
60334: CALL_OW 266
60338: PUSH
60339: LD_INT 6
60341: PUSH
60342: LD_INT 7
60344: PUSH
60345: EMPTY
60346: LIST
60347: LIST
60348: IN
60349: PUSH
60350: LD_VAR 0 3
60354: PPUSH
60355: CALL_OW 461
60359: PUSH
60360: LD_INT 1
60362: NONEQUAL
60363: AND
60364: IFFALSE 60490
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
60366: LD_VAR 0 3
60370: PPUSH
60371: LD_EXP 57
60375: PUSH
60376: LD_VAR 0 2
60380: ARRAY
60381: PUSH
60382: LD_INT 1
60384: ARRAY
60385: PPUSH
60386: CALL 21634 0 2
60390: IFFALSE 60490
// begin ComCancel ( j ) ;
60392: LD_VAR 0 3
60396: PPUSH
60397: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
60401: LD_VAR 0 3
60405: PPUSH
60406: LD_EXP 57
60410: PUSH
60411: LD_VAR 0 2
60415: ARRAY
60416: PUSH
60417: LD_INT 1
60419: ARRAY
60420: PPUSH
60421: CALL_OW 207
// if not j in mc_construct_list [ i ] then
60425: LD_VAR 0 3
60429: PUSH
60430: LD_EXP 30
60434: PUSH
60435: LD_VAR 0 2
60439: ARRAY
60440: IN
60441: NOT
60442: IFFALSE 60488
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
60444: LD_ADDR_EXP 30
60448: PUSH
60449: LD_EXP 30
60453: PPUSH
60454: LD_VAR 0 2
60458: PUSH
60459: LD_EXP 30
60463: PUSH
60464: LD_VAR 0 2
60468: ARRAY
60469: PUSH
60470: LD_INT 1
60472: PLUS
60473: PUSH
60474: EMPTY
60475: LIST
60476: LIST
60477: PPUSH
60478: LD_VAR 0 3
60482: PPUSH
60483: CALL 14915 0 3
60487: ST_TO_ADDR
// break ;
60488: GO 60492
// end ; end ; end ;
60490: GO 60326
60492: POP
60493: POP
// end ;
60494: GO 60086
60496: POP
60497: POP
// end ;
60498: LD_VAR 0 1
60502: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
60503: LD_INT 0
60505: PPUSH
60506: PPUSH
60507: PPUSH
60508: PPUSH
60509: PPUSH
60510: PPUSH
60511: PPUSH
60512: PPUSH
60513: PPUSH
// if not mc_bases then
60514: LD_EXP 23
60518: NOT
60519: IFFALSE 60523
// exit ;
60521: GO 60928
// for i = 1 to mc_bases do
60523: LD_ADDR_VAR 0 2
60527: PUSH
60528: DOUBLE
60529: LD_INT 1
60531: DEC
60532: ST_TO_ADDR
60533: LD_EXP 23
60537: PUSH
60538: FOR_TO
60539: IFFALSE 60926
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
60541: LD_EXP 31
60545: PUSH
60546: LD_VAR 0 2
60550: ARRAY
60551: NOT
60552: PUSH
60553: LD_EXP 23
60557: PUSH
60558: LD_VAR 0 2
60562: ARRAY
60563: PPUSH
60564: LD_INT 30
60566: PUSH
60567: LD_INT 3
60569: PUSH
60570: EMPTY
60571: LIST
60572: LIST
60573: PPUSH
60574: CALL_OW 72
60578: NOT
60579: OR
60580: IFFALSE 60584
// continue ;
60582: GO 60538
// busy := false ;
60584: LD_ADDR_VAR 0 8
60588: PUSH
60589: LD_INT 0
60591: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
60592: LD_ADDR_VAR 0 4
60596: PUSH
60597: LD_EXP 23
60601: PUSH
60602: LD_VAR 0 2
60606: ARRAY
60607: PPUSH
60608: LD_INT 30
60610: PUSH
60611: LD_INT 3
60613: PUSH
60614: EMPTY
60615: LIST
60616: LIST
60617: PPUSH
60618: CALL_OW 72
60622: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
60623: LD_ADDR_VAR 0 6
60627: PUSH
60628: LD_EXP 31
60632: PUSH
60633: LD_VAR 0 2
60637: ARRAY
60638: PPUSH
60639: LD_INT 2
60641: PUSH
60642: LD_INT 30
60644: PUSH
60645: LD_INT 32
60647: PUSH
60648: EMPTY
60649: LIST
60650: LIST
60651: PUSH
60652: LD_INT 30
60654: PUSH
60655: LD_INT 33
60657: PUSH
60658: EMPTY
60659: LIST
60660: LIST
60661: PUSH
60662: EMPTY
60663: LIST
60664: LIST
60665: LIST
60666: PPUSH
60667: CALL_OW 72
60671: ST_TO_ADDR
// if not t then
60672: LD_VAR 0 6
60676: NOT
60677: IFFALSE 60681
// continue ;
60679: GO 60538
// for j in tmp do
60681: LD_ADDR_VAR 0 3
60685: PUSH
60686: LD_VAR 0 4
60690: PUSH
60691: FOR_IN
60692: IFFALSE 60722
// if not BuildingStatus ( j ) = bs_idle then
60694: LD_VAR 0 3
60698: PPUSH
60699: CALL_OW 461
60703: PUSH
60704: LD_INT 2
60706: EQUAL
60707: NOT
60708: IFFALSE 60720
// begin busy := true ;
60710: LD_ADDR_VAR 0 8
60714: PUSH
60715: LD_INT 1
60717: ST_TO_ADDR
// break ;
60718: GO 60722
// end ;
60720: GO 60691
60722: POP
60723: POP
// if busy then
60724: LD_VAR 0 8
60728: IFFALSE 60732
// continue ;
60730: GO 60538
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
60732: LD_ADDR_VAR 0 7
60736: PUSH
60737: LD_VAR 0 6
60741: PPUSH
60742: LD_INT 35
60744: PUSH
60745: LD_INT 0
60747: PUSH
60748: EMPTY
60749: LIST
60750: LIST
60751: PPUSH
60752: CALL_OW 72
60756: ST_TO_ADDR
// if tw then
60757: LD_VAR 0 7
60761: IFFALSE 60838
// begin tw := tw [ 1 ] ;
60763: LD_ADDR_VAR 0 7
60767: PUSH
60768: LD_VAR 0 7
60772: PUSH
60773: LD_INT 1
60775: ARRAY
60776: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
60777: LD_ADDR_VAR 0 9
60781: PUSH
60782: LD_VAR 0 7
60786: PPUSH
60787: LD_EXP 48
60791: PUSH
60792: LD_VAR 0 2
60796: ARRAY
60797: PPUSH
60798: CALL 19926 0 2
60802: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
60803: LD_EXP 62
60807: PUSH
60808: LD_VAR 0 2
60812: ARRAY
60813: IFFALSE 60836
// if not weapon in mc_allowed_tower_weapons [ i ] then
60815: LD_VAR 0 9
60819: PUSH
60820: LD_EXP 62
60824: PUSH
60825: LD_VAR 0 2
60829: ARRAY
60830: IN
60831: NOT
60832: IFFALSE 60836
// continue ;
60834: GO 60538
// end else
60836: GO 60901
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
60838: LD_ADDR_VAR 0 5
60842: PUSH
60843: LD_EXP 31
60847: PUSH
60848: LD_VAR 0 2
60852: ARRAY
60853: PPUSH
60854: LD_VAR 0 4
60858: PPUSH
60859: CALL 46215 0 2
60863: ST_TO_ADDR
// if not tmp2 then
60864: LD_VAR 0 5
60868: NOT
60869: IFFALSE 60873
// continue ;
60871: GO 60538
// tw := tmp2 [ 1 ] ;
60873: LD_ADDR_VAR 0 7
60877: PUSH
60878: LD_VAR 0 5
60882: PUSH
60883: LD_INT 1
60885: ARRAY
60886: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
60887: LD_ADDR_VAR 0 9
60891: PUSH
60892: LD_VAR 0 5
60896: PUSH
60897: LD_INT 2
60899: ARRAY
60900: ST_TO_ADDR
// end ; if not weapon then
60901: LD_VAR 0 9
60905: NOT
60906: IFFALSE 60910
// continue ;
60908: GO 60538
// ComPlaceWeapon ( tw , weapon ) ;
60910: LD_VAR 0 7
60914: PPUSH
60915: LD_VAR 0 9
60919: PPUSH
60920: CALL_OW 148
// end ;
60924: GO 60538
60926: POP
60927: POP
// end ;
60928: LD_VAR 0 1
60932: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
60933: LD_INT 0
60935: PPUSH
60936: PPUSH
60937: PPUSH
60938: PPUSH
60939: PPUSH
60940: PPUSH
60941: PPUSH
// if not mc_bases then
60942: LD_EXP 23
60946: NOT
60947: IFFALSE 60951
// exit ;
60949: GO 61719
// for i = 1 to mc_bases do
60951: LD_ADDR_VAR 0 2
60955: PUSH
60956: DOUBLE
60957: LD_INT 1
60959: DEC
60960: ST_TO_ADDR
60961: LD_EXP 23
60965: PUSH
60966: FOR_TO
60967: IFFALSE 61717
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
60969: LD_EXP 36
60973: PUSH
60974: LD_VAR 0 2
60978: ARRAY
60979: NOT
60980: PUSH
60981: LD_EXP 36
60985: PUSH
60986: LD_VAR 0 2
60990: ARRAY
60991: PUSH
60992: LD_EXP 37
60996: PUSH
60997: LD_VAR 0 2
61001: ARRAY
61002: EQUAL
61003: OR
61004: PUSH
61005: LD_EXP 46
61009: PUSH
61010: LD_VAR 0 2
61014: ARRAY
61015: OR
61016: IFFALSE 61020
// continue ;
61018: GO 60966
// if mc_miners [ i ] then
61020: LD_EXP 37
61024: PUSH
61025: LD_VAR 0 2
61029: ARRAY
61030: IFFALSE 61404
// begin for j = mc_miners [ i ] downto 1 do
61032: LD_ADDR_VAR 0 3
61036: PUSH
61037: DOUBLE
61038: LD_EXP 37
61042: PUSH
61043: LD_VAR 0 2
61047: ARRAY
61048: INC
61049: ST_TO_ADDR
61050: LD_INT 1
61052: PUSH
61053: FOR_DOWNTO
61054: IFFALSE 61402
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
61056: LD_EXP 37
61060: PUSH
61061: LD_VAR 0 2
61065: ARRAY
61066: PUSH
61067: LD_VAR 0 3
61071: ARRAY
61072: PPUSH
61073: CALL_OW 301
61077: PUSH
61078: LD_EXP 37
61082: PUSH
61083: LD_VAR 0 2
61087: ARRAY
61088: PUSH
61089: LD_VAR 0 3
61093: ARRAY
61094: PPUSH
61095: CALL_OW 257
61099: PUSH
61100: LD_INT 1
61102: NONEQUAL
61103: OR
61104: IFFALSE 61167
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
61106: LD_ADDR_VAR 0 5
61110: PUSH
61111: LD_EXP 37
61115: PUSH
61116: LD_VAR 0 2
61120: ARRAY
61121: PUSH
61122: LD_EXP 37
61126: PUSH
61127: LD_VAR 0 2
61131: ARRAY
61132: PUSH
61133: LD_VAR 0 3
61137: ARRAY
61138: DIFF
61139: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
61140: LD_ADDR_EXP 37
61144: PUSH
61145: LD_EXP 37
61149: PPUSH
61150: LD_VAR 0 2
61154: PPUSH
61155: LD_VAR 0 5
61159: PPUSH
61160: CALL_OW 1
61164: ST_TO_ADDR
// continue ;
61165: GO 61053
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
61167: LD_EXP 37
61171: PUSH
61172: LD_VAR 0 2
61176: ARRAY
61177: PUSH
61178: LD_VAR 0 3
61182: ARRAY
61183: PPUSH
61184: CALL_OW 257
61188: PUSH
61189: LD_INT 1
61191: EQUAL
61192: PUSH
61193: LD_EXP 37
61197: PUSH
61198: LD_VAR 0 2
61202: ARRAY
61203: PUSH
61204: LD_VAR 0 3
61208: ARRAY
61209: PPUSH
61210: CALL_OW 459
61214: NOT
61215: AND
61216: PUSH
61217: LD_EXP 37
61221: PUSH
61222: LD_VAR 0 2
61226: ARRAY
61227: PUSH
61228: LD_VAR 0 3
61232: ARRAY
61233: PPUSH
61234: CALL_OW 314
61238: NOT
61239: AND
61240: IFFALSE 61400
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
61242: LD_EXP 37
61246: PUSH
61247: LD_VAR 0 2
61251: ARRAY
61252: PUSH
61253: LD_VAR 0 3
61257: ARRAY
61258: PPUSH
61259: CALL_OW 310
61263: IFFALSE 61286
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
61265: LD_EXP 37
61269: PUSH
61270: LD_VAR 0 2
61274: ARRAY
61275: PUSH
61276: LD_VAR 0 3
61280: ARRAY
61281: PPUSH
61282: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
61286: LD_EXP 37
61290: PUSH
61291: LD_VAR 0 2
61295: ARRAY
61296: PUSH
61297: LD_VAR 0 3
61301: ARRAY
61302: PPUSH
61303: CALL_OW 314
61307: NOT
61308: IFFALSE 61400
// begin r := rand ( 1 , mc_mines [ i ] ) ;
61310: LD_ADDR_VAR 0 7
61314: PUSH
61315: LD_INT 1
61317: PPUSH
61318: LD_EXP 36
61322: PUSH
61323: LD_VAR 0 2
61327: ARRAY
61328: PPUSH
61329: CALL_OW 12
61333: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
61334: LD_EXP 37
61338: PUSH
61339: LD_VAR 0 2
61343: ARRAY
61344: PUSH
61345: LD_VAR 0 3
61349: ARRAY
61350: PPUSH
61351: LD_EXP 36
61355: PUSH
61356: LD_VAR 0 2
61360: ARRAY
61361: PUSH
61362: LD_VAR 0 7
61366: ARRAY
61367: PUSH
61368: LD_INT 1
61370: ARRAY
61371: PPUSH
61372: LD_EXP 36
61376: PUSH
61377: LD_VAR 0 2
61381: ARRAY
61382: PUSH
61383: LD_VAR 0 7
61387: ARRAY
61388: PUSH
61389: LD_INT 2
61391: ARRAY
61392: PPUSH
61393: LD_INT 0
61395: PPUSH
61396: CALL_OW 193
// end ; end ; end ;
61400: GO 61053
61402: POP
61403: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
61404: LD_ADDR_VAR 0 5
61408: PUSH
61409: LD_EXP 23
61413: PUSH
61414: LD_VAR 0 2
61418: ARRAY
61419: PPUSH
61420: LD_INT 2
61422: PUSH
61423: LD_INT 30
61425: PUSH
61426: LD_INT 4
61428: PUSH
61429: EMPTY
61430: LIST
61431: LIST
61432: PUSH
61433: LD_INT 30
61435: PUSH
61436: LD_INT 5
61438: PUSH
61439: EMPTY
61440: LIST
61441: LIST
61442: PUSH
61443: LD_INT 30
61445: PUSH
61446: LD_INT 32
61448: PUSH
61449: EMPTY
61450: LIST
61451: LIST
61452: PUSH
61453: EMPTY
61454: LIST
61455: LIST
61456: LIST
61457: LIST
61458: PPUSH
61459: CALL_OW 72
61463: ST_TO_ADDR
// if not tmp then
61464: LD_VAR 0 5
61468: NOT
61469: IFFALSE 61473
// continue ;
61471: GO 60966
// list := [ ] ;
61473: LD_ADDR_VAR 0 6
61477: PUSH
61478: EMPTY
61479: ST_TO_ADDR
// for j in tmp do
61480: LD_ADDR_VAR 0 3
61484: PUSH
61485: LD_VAR 0 5
61489: PUSH
61490: FOR_IN
61491: IFFALSE 61560
// begin for k in UnitsInside ( j ) do
61493: LD_ADDR_VAR 0 4
61497: PUSH
61498: LD_VAR 0 3
61502: PPUSH
61503: CALL_OW 313
61507: PUSH
61508: FOR_IN
61509: IFFALSE 61556
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
61511: LD_VAR 0 4
61515: PPUSH
61516: CALL_OW 257
61520: PUSH
61521: LD_INT 1
61523: EQUAL
61524: PUSH
61525: LD_VAR 0 4
61529: PPUSH
61530: CALL_OW 459
61534: NOT
61535: AND
61536: IFFALSE 61554
// list := list ^ k ;
61538: LD_ADDR_VAR 0 6
61542: PUSH
61543: LD_VAR 0 6
61547: PUSH
61548: LD_VAR 0 4
61552: ADD
61553: ST_TO_ADDR
61554: GO 61508
61556: POP
61557: POP
// end ;
61558: GO 61490
61560: POP
61561: POP
// list := list diff mc_miners [ i ] ;
61562: LD_ADDR_VAR 0 6
61566: PUSH
61567: LD_VAR 0 6
61571: PUSH
61572: LD_EXP 37
61576: PUSH
61577: LD_VAR 0 2
61581: ARRAY
61582: DIFF
61583: ST_TO_ADDR
// if not list then
61584: LD_VAR 0 6
61588: NOT
61589: IFFALSE 61593
// continue ;
61591: GO 60966
// k := mc_mines [ i ] - mc_miners [ i ] ;
61593: LD_ADDR_VAR 0 4
61597: PUSH
61598: LD_EXP 36
61602: PUSH
61603: LD_VAR 0 2
61607: ARRAY
61608: PUSH
61609: LD_EXP 37
61613: PUSH
61614: LD_VAR 0 2
61618: ARRAY
61619: MINUS
61620: ST_TO_ADDR
// if k > list then
61621: LD_VAR 0 4
61625: PUSH
61626: LD_VAR 0 6
61630: GREATER
61631: IFFALSE 61643
// k := list ;
61633: LD_ADDR_VAR 0 4
61637: PUSH
61638: LD_VAR 0 6
61642: ST_TO_ADDR
// for j = 1 to k do
61643: LD_ADDR_VAR 0 3
61647: PUSH
61648: DOUBLE
61649: LD_INT 1
61651: DEC
61652: ST_TO_ADDR
61653: LD_VAR 0 4
61657: PUSH
61658: FOR_TO
61659: IFFALSE 61713
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
61661: LD_ADDR_EXP 37
61665: PUSH
61666: LD_EXP 37
61670: PPUSH
61671: LD_VAR 0 2
61675: PUSH
61676: LD_EXP 37
61680: PUSH
61681: LD_VAR 0 2
61685: ARRAY
61686: PUSH
61687: LD_INT 1
61689: PLUS
61690: PUSH
61691: EMPTY
61692: LIST
61693: LIST
61694: PPUSH
61695: LD_VAR 0 6
61699: PUSH
61700: LD_VAR 0 3
61704: ARRAY
61705: PPUSH
61706: CALL 14915 0 3
61710: ST_TO_ADDR
61711: GO 61658
61713: POP
61714: POP
// end ;
61715: GO 60966
61717: POP
61718: POP
// end ;
61719: LD_VAR 0 1
61723: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
61724: LD_INT 0
61726: PPUSH
61727: PPUSH
61728: PPUSH
61729: PPUSH
61730: PPUSH
61731: PPUSH
61732: PPUSH
61733: PPUSH
61734: PPUSH
61735: PPUSH
61736: PPUSH
// if not mc_bases then
61737: LD_EXP 23
61741: NOT
61742: IFFALSE 61746
// exit ;
61744: GO 63569
// for i = 1 to mc_bases do
61746: LD_ADDR_VAR 0 2
61750: PUSH
61751: DOUBLE
61752: LD_INT 1
61754: DEC
61755: ST_TO_ADDR
61756: LD_EXP 23
61760: PUSH
61761: FOR_TO
61762: IFFALSE 63567
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
61764: LD_EXP 23
61768: PUSH
61769: LD_VAR 0 2
61773: ARRAY
61774: NOT
61775: PUSH
61776: LD_EXP 30
61780: PUSH
61781: LD_VAR 0 2
61785: ARRAY
61786: OR
61787: IFFALSE 61791
// continue ;
61789: GO 61761
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
61791: LD_EXP 39
61795: PUSH
61796: LD_VAR 0 2
61800: ARRAY
61801: NOT
61802: PUSH
61803: LD_EXP 40
61807: PUSH
61808: LD_VAR 0 2
61812: ARRAY
61813: AND
61814: IFFALSE 61852
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
61816: LD_ADDR_EXP 40
61820: PUSH
61821: LD_EXP 40
61825: PPUSH
61826: LD_VAR 0 2
61830: PPUSH
61831: EMPTY
61832: PPUSH
61833: CALL_OW 1
61837: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
61838: LD_VAR 0 2
61842: PPUSH
61843: LD_INT 107
61845: PPUSH
61846: CALL 52678 0 2
// continue ;
61850: GO 61761
// end ; target := [ ] ;
61852: LD_ADDR_VAR 0 7
61856: PUSH
61857: EMPTY
61858: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
61859: LD_ADDR_VAR 0 6
61863: PUSH
61864: LD_EXP 23
61868: PUSH
61869: LD_VAR 0 2
61873: ARRAY
61874: PUSH
61875: LD_INT 1
61877: ARRAY
61878: PPUSH
61879: CALL_OW 255
61883: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61884: LD_ADDR_VAR 0 9
61888: PUSH
61889: LD_EXP 23
61893: PUSH
61894: LD_VAR 0 2
61898: ARRAY
61899: PPUSH
61900: LD_INT 2
61902: PUSH
61903: LD_INT 30
61905: PUSH
61906: LD_INT 0
61908: PUSH
61909: EMPTY
61910: LIST
61911: LIST
61912: PUSH
61913: LD_INT 30
61915: PUSH
61916: LD_INT 1
61918: PUSH
61919: EMPTY
61920: LIST
61921: LIST
61922: PUSH
61923: EMPTY
61924: LIST
61925: LIST
61926: LIST
61927: PPUSH
61928: CALL_OW 72
61932: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
61933: LD_ADDR_VAR 0 3
61937: PUSH
61938: DOUBLE
61939: LD_EXP 39
61943: PUSH
61944: LD_VAR 0 2
61948: ARRAY
61949: INC
61950: ST_TO_ADDR
61951: LD_INT 1
61953: PUSH
61954: FOR_DOWNTO
61955: IFFALSE 62200
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
61957: LD_EXP 39
61961: PUSH
61962: LD_VAR 0 2
61966: ARRAY
61967: PUSH
61968: LD_VAR 0 3
61972: ARRAY
61973: PUSH
61974: LD_INT 2
61976: ARRAY
61977: PPUSH
61978: LD_EXP 39
61982: PUSH
61983: LD_VAR 0 2
61987: ARRAY
61988: PUSH
61989: LD_VAR 0 3
61993: ARRAY
61994: PUSH
61995: LD_INT 3
61997: ARRAY
61998: PPUSH
61999: CALL_OW 488
62003: PUSH
62004: LD_EXP 39
62008: PUSH
62009: LD_VAR 0 2
62013: ARRAY
62014: PUSH
62015: LD_VAR 0 3
62019: ARRAY
62020: PUSH
62021: LD_INT 2
62023: ARRAY
62024: PPUSH
62025: LD_EXP 39
62029: PUSH
62030: LD_VAR 0 2
62034: ARRAY
62035: PUSH
62036: LD_VAR 0 3
62040: ARRAY
62041: PUSH
62042: LD_INT 3
62044: ARRAY
62045: PPUSH
62046: CALL_OW 284
62050: PUSH
62051: LD_INT 0
62053: EQUAL
62054: AND
62055: IFFALSE 62110
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
62057: LD_ADDR_VAR 0 5
62061: PUSH
62062: LD_EXP 39
62066: PUSH
62067: LD_VAR 0 2
62071: ARRAY
62072: PPUSH
62073: LD_VAR 0 3
62077: PPUSH
62078: CALL_OW 3
62082: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
62083: LD_ADDR_EXP 39
62087: PUSH
62088: LD_EXP 39
62092: PPUSH
62093: LD_VAR 0 2
62097: PPUSH
62098: LD_VAR 0 5
62102: PPUSH
62103: CALL_OW 1
62107: ST_TO_ADDR
// continue ;
62108: GO 61954
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
62110: LD_VAR 0 6
62114: PPUSH
62115: LD_EXP 39
62119: PUSH
62120: LD_VAR 0 2
62124: ARRAY
62125: PUSH
62126: LD_VAR 0 3
62130: ARRAY
62131: PUSH
62132: LD_INT 2
62134: ARRAY
62135: PPUSH
62136: LD_EXP 39
62140: PUSH
62141: LD_VAR 0 2
62145: ARRAY
62146: PUSH
62147: LD_VAR 0 3
62151: ARRAY
62152: PUSH
62153: LD_INT 3
62155: ARRAY
62156: PPUSH
62157: LD_INT 30
62159: PPUSH
62160: CALL 15811 0 4
62164: PUSH
62165: LD_INT 4
62167: ARRAY
62168: PUSH
62169: LD_INT 0
62171: EQUAL
62172: IFFALSE 62198
// begin target := mc_crates [ i ] [ j ] ;
62174: LD_ADDR_VAR 0 7
62178: PUSH
62179: LD_EXP 39
62183: PUSH
62184: LD_VAR 0 2
62188: ARRAY
62189: PUSH
62190: LD_VAR 0 3
62194: ARRAY
62195: ST_TO_ADDR
// break ;
62196: GO 62200
// end ; end ;
62198: GO 61954
62200: POP
62201: POP
// if not target then
62202: LD_VAR 0 7
62206: NOT
62207: IFFALSE 62211
// continue ;
62209: GO 61761
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
62211: LD_ADDR_VAR 0 8
62215: PUSH
62216: LD_EXP 42
62220: PUSH
62221: LD_VAR 0 2
62225: ARRAY
62226: PPUSH
62227: LD_INT 2
62229: PUSH
62230: LD_INT 3
62232: PUSH
62233: LD_INT 58
62235: PUSH
62236: EMPTY
62237: LIST
62238: PUSH
62239: EMPTY
62240: LIST
62241: LIST
62242: PUSH
62243: LD_INT 61
62245: PUSH
62246: EMPTY
62247: LIST
62248: PUSH
62249: LD_INT 33
62251: PUSH
62252: LD_INT 5
62254: PUSH
62255: EMPTY
62256: LIST
62257: LIST
62258: PUSH
62259: LD_INT 33
62261: PUSH
62262: LD_INT 3
62264: PUSH
62265: EMPTY
62266: LIST
62267: LIST
62268: PUSH
62269: EMPTY
62270: LIST
62271: LIST
62272: LIST
62273: LIST
62274: LIST
62275: PUSH
62276: LD_INT 2
62278: PUSH
62279: LD_INT 34
62281: PUSH
62282: LD_INT 32
62284: PUSH
62285: EMPTY
62286: LIST
62287: LIST
62288: PUSH
62289: LD_INT 34
62291: PUSH
62292: LD_INT 51
62294: PUSH
62295: EMPTY
62296: LIST
62297: LIST
62298: PUSH
62299: LD_INT 34
62301: PUSH
62302: LD_INT 12
62304: PUSH
62305: EMPTY
62306: LIST
62307: LIST
62308: PUSH
62309: EMPTY
62310: LIST
62311: LIST
62312: LIST
62313: LIST
62314: PUSH
62315: EMPTY
62316: LIST
62317: LIST
62318: PPUSH
62319: CALL_OW 72
62323: ST_TO_ADDR
// if not cargo then
62324: LD_VAR 0 8
62328: NOT
62329: IFFALSE 63035
// begin if mc_crates_collector [ i ] < 5 then
62331: LD_EXP 40
62335: PUSH
62336: LD_VAR 0 2
62340: ARRAY
62341: PUSH
62342: LD_INT 5
62344: LESS
62345: IFFALSE 62711
// begin if mc_ape [ i ] then
62347: LD_EXP 52
62351: PUSH
62352: LD_VAR 0 2
62356: ARRAY
62357: IFFALSE 62404
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
62359: LD_ADDR_VAR 0 5
62363: PUSH
62364: LD_EXP 52
62368: PUSH
62369: LD_VAR 0 2
62373: ARRAY
62374: PPUSH
62375: LD_INT 25
62377: PUSH
62378: LD_INT 16
62380: PUSH
62381: EMPTY
62382: LIST
62383: LIST
62384: PUSH
62385: LD_INT 24
62387: PUSH
62388: LD_INT 750
62390: PUSH
62391: EMPTY
62392: LIST
62393: LIST
62394: PUSH
62395: EMPTY
62396: LIST
62397: LIST
62398: PPUSH
62399: CALL_OW 72
62403: ST_TO_ADDR
// if not tmp then
62404: LD_VAR 0 5
62408: NOT
62409: IFFALSE 62456
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
62411: LD_ADDR_VAR 0 5
62415: PUSH
62416: LD_EXP 23
62420: PUSH
62421: LD_VAR 0 2
62425: ARRAY
62426: PPUSH
62427: LD_INT 25
62429: PUSH
62430: LD_INT 2
62432: PUSH
62433: EMPTY
62434: LIST
62435: LIST
62436: PUSH
62437: LD_INT 24
62439: PUSH
62440: LD_INT 750
62442: PUSH
62443: EMPTY
62444: LIST
62445: LIST
62446: PUSH
62447: EMPTY
62448: LIST
62449: LIST
62450: PPUSH
62451: CALL_OW 72
62455: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
62456: LD_EXP 52
62460: PUSH
62461: LD_VAR 0 2
62465: ARRAY
62466: PUSH
62467: LD_EXP 23
62471: PUSH
62472: LD_VAR 0 2
62476: ARRAY
62477: PPUSH
62478: LD_INT 25
62480: PUSH
62481: LD_INT 2
62483: PUSH
62484: EMPTY
62485: LIST
62486: LIST
62487: PUSH
62488: LD_INT 24
62490: PUSH
62491: LD_INT 750
62493: PUSH
62494: EMPTY
62495: LIST
62496: LIST
62497: PUSH
62498: EMPTY
62499: LIST
62500: LIST
62501: PPUSH
62502: CALL_OW 72
62506: AND
62507: PUSH
62508: LD_VAR 0 5
62512: PUSH
62513: LD_INT 5
62515: LESS
62516: AND
62517: IFFALSE 62599
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
62519: LD_ADDR_VAR 0 3
62523: PUSH
62524: LD_EXP 23
62528: PUSH
62529: LD_VAR 0 2
62533: ARRAY
62534: PPUSH
62535: LD_INT 25
62537: PUSH
62538: LD_INT 2
62540: PUSH
62541: EMPTY
62542: LIST
62543: LIST
62544: PUSH
62545: LD_INT 24
62547: PUSH
62548: LD_INT 750
62550: PUSH
62551: EMPTY
62552: LIST
62553: LIST
62554: PUSH
62555: EMPTY
62556: LIST
62557: LIST
62558: PPUSH
62559: CALL_OW 72
62563: PUSH
62564: FOR_IN
62565: IFFALSE 62597
// begin tmp := tmp union j ;
62567: LD_ADDR_VAR 0 5
62571: PUSH
62572: LD_VAR 0 5
62576: PUSH
62577: LD_VAR 0 3
62581: UNION
62582: ST_TO_ADDR
// if tmp >= 5 then
62583: LD_VAR 0 5
62587: PUSH
62588: LD_INT 5
62590: GREATEREQUAL
62591: IFFALSE 62595
// break ;
62593: GO 62597
// end ;
62595: GO 62564
62597: POP
62598: POP
// end ; if not tmp then
62599: LD_VAR 0 5
62603: NOT
62604: IFFALSE 62608
// continue ;
62606: GO 61761
// for j in tmp do
62608: LD_ADDR_VAR 0 3
62612: PUSH
62613: LD_VAR 0 5
62617: PUSH
62618: FOR_IN
62619: IFFALSE 62709
// if not GetTag ( j ) then
62621: LD_VAR 0 3
62625: PPUSH
62626: CALL_OW 110
62630: NOT
62631: IFFALSE 62707
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
62633: LD_ADDR_EXP 40
62637: PUSH
62638: LD_EXP 40
62642: PPUSH
62643: LD_VAR 0 2
62647: PUSH
62648: LD_EXP 40
62652: PUSH
62653: LD_VAR 0 2
62657: ARRAY
62658: PUSH
62659: LD_INT 1
62661: PLUS
62662: PUSH
62663: EMPTY
62664: LIST
62665: LIST
62666: PPUSH
62667: LD_VAR 0 3
62671: PPUSH
62672: CALL 14915 0 3
62676: ST_TO_ADDR
// SetTag ( j , 107 ) ;
62677: LD_VAR 0 3
62681: PPUSH
62682: LD_INT 107
62684: PPUSH
62685: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
62689: LD_EXP 40
62693: PUSH
62694: LD_VAR 0 2
62698: ARRAY
62699: PUSH
62700: LD_INT 5
62702: GREATEREQUAL
62703: IFFALSE 62707
// break ;
62705: GO 62709
// end ;
62707: GO 62618
62709: POP
62710: POP
// end ; if mc_crates_collector [ i ] and target then
62711: LD_EXP 40
62715: PUSH
62716: LD_VAR 0 2
62720: ARRAY
62721: PUSH
62722: LD_VAR 0 7
62726: AND
62727: IFFALSE 63033
// begin if mc_crates_collector [ i ] < target [ 1 ] then
62729: LD_EXP 40
62733: PUSH
62734: LD_VAR 0 2
62738: ARRAY
62739: PUSH
62740: LD_VAR 0 7
62744: PUSH
62745: LD_INT 1
62747: ARRAY
62748: LESS
62749: IFFALSE 62769
// tmp := mc_crates_collector [ i ] else
62751: LD_ADDR_VAR 0 5
62755: PUSH
62756: LD_EXP 40
62760: PUSH
62761: LD_VAR 0 2
62765: ARRAY
62766: ST_TO_ADDR
62767: GO 62783
// tmp := target [ 1 ] ;
62769: LD_ADDR_VAR 0 5
62773: PUSH
62774: LD_VAR 0 7
62778: PUSH
62779: LD_INT 1
62781: ARRAY
62782: ST_TO_ADDR
// k := 0 ;
62783: LD_ADDR_VAR 0 4
62787: PUSH
62788: LD_INT 0
62790: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
62791: LD_ADDR_VAR 0 3
62795: PUSH
62796: LD_EXP 40
62800: PUSH
62801: LD_VAR 0 2
62805: ARRAY
62806: PUSH
62807: FOR_IN
62808: IFFALSE 63031
// begin k := k + 1 ;
62810: LD_ADDR_VAR 0 4
62814: PUSH
62815: LD_VAR 0 4
62819: PUSH
62820: LD_INT 1
62822: PLUS
62823: ST_TO_ADDR
// if k > tmp then
62824: LD_VAR 0 4
62828: PUSH
62829: LD_VAR 0 5
62833: GREATER
62834: IFFALSE 62838
// break ;
62836: GO 63031
// if not GetClass ( j ) in [ 2 , 16 ] then
62838: LD_VAR 0 3
62842: PPUSH
62843: CALL_OW 257
62847: PUSH
62848: LD_INT 2
62850: PUSH
62851: LD_INT 16
62853: PUSH
62854: EMPTY
62855: LIST
62856: LIST
62857: IN
62858: NOT
62859: IFFALSE 62912
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
62861: LD_ADDR_EXP 40
62865: PUSH
62866: LD_EXP 40
62870: PPUSH
62871: LD_VAR 0 2
62875: PPUSH
62876: LD_EXP 40
62880: PUSH
62881: LD_VAR 0 2
62885: ARRAY
62886: PUSH
62887: LD_VAR 0 3
62891: DIFF
62892: PPUSH
62893: CALL_OW 1
62897: ST_TO_ADDR
// SetTag ( j , 0 ) ;
62898: LD_VAR 0 3
62902: PPUSH
62903: LD_INT 0
62905: PPUSH
62906: CALL_OW 109
// continue ;
62910: GO 62807
// end ; if IsInUnit ( j ) then
62912: LD_VAR 0 3
62916: PPUSH
62917: CALL_OW 310
62921: IFFALSE 62932
// ComExitBuilding ( j ) ;
62923: LD_VAR 0 3
62927: PPUSH
62928: CALL_OW 122
// wait ( 3 ) ;
62932: LD_INT 3
62934: PPUSH
62935: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
62939: LD_VAR 0 3
62943: PPUSH
62944: CALL_OW 314
62948: PUSH
62949: LD_VAR 0 6
62953: PPUSH
62954: LD_VAR 0 7
62958: PUSH
62959: LD_INT 2
62961: ARRAY
62962: PPUSH
62963: LD_VAR 0 7
62967: PUSH
62968: LD_INT 3
62970: ARRAY
62971: PPUSH
62972: LD_INT 30
62974: PPUSH
62975: CALL 15811 0 4
62979: PUSH
62980: LD_INT 4
62982: ARRAY
62983: AND
62984: IFFALSE 63002
// ComStandNearbyBuilding ( j , depot ) else
62986: LD_VAR 0 3
62990: PPUSH
62991: LD_VAR 0 9
62995: PPUSH
62996: CALL 11493 0 2
63000: GO 63029
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
63002: LD_VAR 0 3
63006: PPUSH
63007: LD_VAR 0 7
63011: PUSH
63012: LD_INT 2
63014: ARRAY
63015: PPUSH
63016: LD_VAR 0 7
63020: PUSH
63021: LD_INT 3
63023: ARRAY
63024: PPUSH
63025: CALL_OW 117
// end ;
63029: GO 62807
63031: POP
63032: POP
// end ; end else
63033: GO 63565
// begin for j in cargo do
63035: LD_ADDR_VAR 0 3
63039: PUSH
63040: LD_VAR 0 8
63044: PUSH
63045: FOR_IN
63046: IFFALSE 63563
// begin if GetTag ( j ) <> 0 then
63048: LD_VAR 0 3
63052: PPUSH
63053: CALL_OW 110
63057: PUSH
63058: LD_INT 0
63060: NONEQUAL
63061: IFFALSE 63065
// continue ;
63063: GO 63045
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
63065: LD_VAR 0 3
63069: PPUSH
63070: CALL_OW 256
63074: PUSH
63075: LD_INT 1000
63077: LESS
63078: PUSH
63079: LD_VAR 0 3
63083: PPUSH
63084: LD_EXP 47
63088: PUSH
63089: LD_VAR 0 2
63093: ARRAY
63094: PPUSH
63095: CALL_OW 308
63099: NOT
63100: AND
63101: IFFALSE 63123
// ComMoveToArea ( j , mc_parking [ i ] ) ;
63103: LD_VAR 0 3
63107: PPUSH
63108: LD_EXP 47
63112: PUSH
63113: LD_VAR 0 2
63117: ARRAY
63118: PPUSH
63119: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
63123: LD_VAR 0 3
63127: PPUSH
63128: CALL_OW 256
63132: PUSH
63133: LD_INT 1000
63135: LESS
63136: PUSH
63137: LD_VAR 0 3
63141: PPUSH
63142: LD_EXP 47
63146: PUSH
63147: LD_VAR 0 2
63151: ARRAY
63152: PPUSH
63153: CALL_OW 308
63157: AND
63158: IFFALSE 63162
// continue ;
63160: GO 63045
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
63162: LD_VAR 0 3
63166: PPUSH
63167: CALL_OW 262
63171: PUSH
63172: LD_INT 2
63174: EQUAL
63175: PUSH
63176: LD_VAR 0 3
63180: PPUSH
63181: CALL_OW 261
63185: PUSH
63186: LD_INT 15
63188: LESS
63189: AND
63190: IFFALSE 63194
// continue ;
63192: GO 63045
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
63194: LD_VAR 0 3
63198: PPUSH
63199: CALL_OW 262
63203: PUSH
63204: LD_INT 1
63206: EQUAL
63207: PUSH
63208: LD_VAR 0 3
63212: PPUSH
63213: CALL_OW 261
63217: PUSH
63218: LD_INT 10
63220: LESS
63221: AND
63222: IFFALSE 63502
// begin if not depot then
63224: LD_VAR 0 9
63228: NOT
63229: IFFALSE 63233
// continue ;
63231: GO 63045
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
63233: LD_VAR 0 3
63237: PPUSH
63238: LD_VAR 0 9
63242: PPUSH
63243: LD_VAR 0 3
63247: PPUSH
63248: CALL_OW 74
63252: PPUSH
63253: CALL_OW 296
63257: PUSH
63258: LD_INT 6
63260: LESS
63261: IFFALSE 63277
// SetFuel ( j , 100 ) else
63263: LD_VAR 0 3
63267: PPUSH
63268: LD_INT 100
63270: PPUSH
63271: CALL_OW 240
63275: GO 63502
// if GetFuel ( j ) = 0 then
63277: LD_VAR 0 3
63281: PPUSH
63282: CALL_OW 261
63286: PUSH
63287: LD_INT 0
63289: EQUAL
63290: IFFALSE 63502
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
63292: LD_ADDR_EXP 42
63296: PUSH
63297: LD_EXP 42
63301: PPUSH
63302: LD_VAR 0 2
63306: PPUSH
63307: LD_EXP 42
63311: PUSH
63312: LD_VAR 0 2
63316: ARRAY
63317: PUSH
63318: LD_VAR 0 3
63322: DIFF
63323: PPUSH
63324: CALL_OW 1
63328: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
63329: LD_VAR 0 3
63333: PPUSH
63334: CALL_OW 263
63338: PUSH
63339: LD_INT 1
63341: EQUAL
63342: IFFALSE 63358
// ComExitVehicle ( IsInUnit ( j ) ) ;
63344: LD_VAR 0 3
63348: PPUSH
63349: CALL_OW 310
63353: PPUSH
63354: CALL_OW 121
// if GetControl ( j ) = control_remote then
63358: LD_VAR 0 3
63362: PPUSH
63363: CALL_OW 263
63367: PUSH
63368: LD_INT 2
63370: EQUAL
63371: IFFALSE 63382
// ComUnlink ( j ) ;
63373: LD_VAR 0 3
63377: PPUSH
63378: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
63382: LD_ADDR_VAR 0 10
63386: PUSH
63387: LD_VAR 0 2
63391: PPUSH
63392: LD_INT 3
63394: PPUSH
63395: CALL 72983 0 2
63399: ST_TO_ADDR
// if fac then
63400: LD_VAR 0 10
63404: IFFALSE 63500
// begin for k in fac do
63406: LD_ADDR_VAR 0 4
63410: PUSH
63411: LD_VAR 0 10
63415: PUSH
63416: FOR_IN
63417: IFFALSE 63498
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
63419: LD_ADDR_VAR 0 11
63423: PUSH
63424: LD_VAR 0 10
63428: PPUSH
63429: LD_VAR 0 3
63433: PPUSH
63434: CALL_OW 265
63438: PPUSH
63439: LD_VAR 0 3
63443: PPUSH
63444: CALL_OW 262
63448: PPUSH
63449: LD_VAR 0 3
63453: PPUSH
63454: CALL_OW 263
63458: PPUSH
63459: LD_VAR 0 3
63463: PPUSH
63464: CALL_OW 264
63468: PPUSH
63469: CALL 12411 0 5
63473: ST_TO_ADDR
// if components then
63474: LD_VAR 0 11
63478: IFFALSE 63496
// begin MC_InsertProduceList ( i , components ) ;
63480: LD_VAR 0 2
63484: PPUSH
63485: LD_VAR 0 11
63489: PPUSH
63490: CALL 72528 0 2
// break ;
63494: GO 63498
// end ; end ;
63496: GO 63416
63498: POP
63499: POP
// end ; continue ;
63500: GO 63045
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
63502: LD_VAR 0 3
63506: PPUSH
63507: LD_INT 1
63509: PPUSH
63510: CALL_OW 289
63514: PUSH
63515: LD_INT 100
63517: LESS
63518: PUSH
63519: LD_VAR 0 3
63523: PPUSH
63524: CALL_OW 314
63528: NOT
63529: AND
63530: IFFALSE 63559
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
63532: LD_VAR 0 3
63536: PPUSH
63537: LD_VAR 0 7
63541: PUSH
63542: LD_INT 2
63544: ARRAY
63545: PPUSH
63546: LD_VAR 0 7
63550: PUSH
63551: LD_INT 3
63553: ARRAY
63554: PPUSH
63555: CALL_OW 117
// break ;
63559: GO 63563
// end ;
63561: GO 63045
63563: POP
63564: POP
// end ; end ;
63565: GO 61761
63567: POP
63568: POP
// end ;
63569: LD_VAR 0 1
63573: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
63574: LD_INT 0
63576: PPUSH
63577: PPUSH
63578: PPUSH
63579: PPUSH
// if not mc_bases then
63580: LD_EXP 23
63584: NOT
63585: IFFALSE 63589
// exit ;
63587: GO 63750
// for i = 1 to mc_bases do
63589: LD_ADDR_VAR 0 2
63593: PUSH
63594: DOUBLE
63595: LD_INT 1
63597: DEC
63598: ST_TO_ADDR
63599: LD_EXP 23
63603: PUSH
63604: FOR_TO
63605: IFFALSE 63748
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
63607: LD_ADDR_VAR 0 4
63611: PUSH
63612: LD_EXP 42
63616: PUSH
63617: LD_VAR 0 2
63621: ARRAY
63622: PUSH
63623: LD_EXP 45
63627: PUSH
63628: LD_VAR 0 2
63632: ARRAY
63633: UNION
63634: PPUSH
63635: LD_INT 33
63637: PUSH
63638: LD_INT 2
63640: PUSH
63641: EMPTY
63642: LIST
63643: LIST
63644: PPUSH
63645: CALL_OW 72
63649: ST_TO_ADDR
// if tmp then
63650: LD_VAR 0 4
63654: IFFALSE 63746
// for j in tmp do
63656: LD_ADDR_VAR 0 3
63660: PUSH
63661: LD_VAR 0 4
63665: PUSH
63666: FOR_IN
63667: IFFALSE 63744
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
63669: LD_VAR 0 3
63673: PPUSH
63674: CALL_OW 312
63678: NOT
63679: PUSH
63680: LD_VAR 0 3
63684: PPUSH
63685: CALL_OW 256
63689: PUSH
63690: LD_INT 250
63692: GREATEREQUAL
63693: AND
63694: IFFALSE 63707
// Connect ( j ) else
63696: LD_VAR 0 3
63700: PPUSH
63701: CALL 17886 0 1
63705: GO 63742
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
63707: LD_VAR 0 3
63711: PPUSH
63712: CALL_OW 256
63716: PUSH
63717: LD_INT 250
63719: LESS
63720: PUSH
63721: LD_VAR 0 3
63725: PPUSH
63726: CALL_OW 312
63730: AND
63731: IFFALSE 63742
// ComUnlink ( j ) ;
63733: LD_VAR 0 3
63737: PPUSH
63738: CALL_OW 136
63742: GO 63666
63744: POP
63745: POP
// end ;
63746: GO 63604
63748: POP
63749: POP
// end ;
63750: LD_VAR 0 1
63754: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
63755: LD_INT 0
63757: PPUSH
63758: PPUSH
63759: PPUSH
63760: PPUSH
63761: PPUSH
// if not mc_bases then
63762: LD_EXP 23
63766: NOT
63767: IFFALSE 63771
// exit ;
63769: GO 64216
// for i = 1 to mc_bases do
63771: LD_ADDR_VAR 0 2
63775: PUSH
63776: DOUBLE
63777: LD_INT 1
63779: DEC
63780: ST_TO_ADDR
63781: LD_EXP 23
63785: PUSH
63786: FOR_TO
63787: IFFALSE 64214
// begin if not mc_produce [ i ] then
63789: LD_EXP 44
63793: PUSH
63794: LD_VAR 0 2
63798: ARRAY
63799: NOT
63800: IFFALSE 63804
// continue ;
63802: GO 63786
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
63804: LD_ADDR_VAR 0 5
63808: PUSH
63809: LD_EXP 23
63813: PUSH
63814: LD_VAR 0 2
63818: ARRAY
63819: PPUSH
63820: LD_INT 30
63822: PUSH
63823: LD_INT 3
63825: PUSH
63826: EMPTY
63827: LIST
63828: LIST
63829: PPUSH
63830: CALL_OW 72
63834: ST_TO_ADDR
// if not fac then
63835: LD_VAR 0 5
63839: NOT
63840: IFFALSE 63844
// continue ;
63842: GO 63786
// for j in fac do
63844: LD_ADDR_VAR 0 3
63848: PUSH
63849: LD_VAR 0 5
63853: PUSH
63854: FOR_IN
63855: IFFALSE 64210
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
63857: LD_VAR 0 3
63861: PPUSH
63862: CALL_OW 461
63866: PUSH
63867: LD_INT 2
63869: NONEQUAL
63870: PUSH
63871: LD_VAR 0 3
63875: PPUSH
63876: LD_INT 15
63878: PPUSH
63879: CALL 17514 0 2
63883: PUSH
63884: LD_INT 4
63886: ARRAY
63887: OR
63888: IFFALSE 63892
// continue ;
63890: GO 63854
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
63892: LD_VAR 0 3
63896: PPUSH
63897: LD_EXP 44
63901: PUSH
63902: LD_VAR 0 2
63906: ARRAY
63907: PUSH
63908: LD_INT 1
63910: ARRAY
63911: PUSH
63912: LD_INT 1
63914: ARRAY
63915: PPUSH
63916: LD_EXP 44
63920: PUSH
63921: LD_VAR 0 2
63925: ARRAY
63926: PUSH
63927: LD_INT 1
63929: ARRAY
63930: PUSH
63931: LD_INT 2
63933: ARRAY
63934: PPUSH
63935: LD_EXP 44
63939: PUSH
63940: LD_VAR 0 2
63944: ARRAY
63945: PUSH
63946: LD_INT 1
63948: ARRAY
63949: PUSH
63950: LD_INT 3
63952: ARRAY
63953: PPUSH
63954: LD_EXP 44
63958: PUSH
63959: LD_VAR 0 2
63963: ARRAY
63964: PUSH
63965: LD_INT 1
63967: ARRAY
63968: PUSH
63969: LD_INT 4
63971: ARRAY
63972: PPUSH
63973: CALL_OW 448
63977: PUSH
63978: LD_VAR 0 3
63982: PPUSH
63983: LD_EXP 44
63987: PUSH
63988: LD_VAR 0 2
63992: ARRAY
63993: PUSH
63994: LD_INT 1
63996: ARRAY
63997: PUSH
63998: LD_INT 1
64000: ARRAY
64001: PUSH
64002: LD_EXP 44
64006: PUSH
64007: LD_VAR 0 2
64011: ARRAY
64012: PUSH
64013: LD_INT 1
64015: ARRAY
64016: PUSH
64017: LD_INT 2
64019: ARRAY
64020: PUSH
64021: LD_EXP 44
64025: PUSH
64026: LD_VAR 0 2
64030: ARRAY
64031: PUSH
64032: LD_INT 1
64034: ARRAY
64035: PUSH
64036: LD_INT 3
64038: ARRAY
64039: PUSH
64040: LD_EXP 44
64044: PUSH
64045: LD_VAR 0 2
64049: ARRAY
64050: PUSH
64051: LD_INT 1
64053: ARRAY
64054: PUSH
64055: LD_INT 4
64057: ARRAY
64058: PUSH
64059: EMPTY
64060: LIST
64061: LIST
64062: LIST
64063: LIST
64064: PPUSH
64065: CALL 21282 0 2
64069: AND
64070: IFFALSE 64208
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
64072: LD_VAR 0 3
64076: PPUSH
64077: LD_EXP 44
64081: PUSH
64082: LD_VAR 0 2
64086: ARRAY
64087: PUSH
64088: LD_INT 1
64090: ARRAY
64091: PUSH
64092: LD_INT 1
64094: ARRAY
64095: PPUSH
64096: LD_EXP 44
64100: PUSH
64101: LD_VAR 0 2
64105: ARRAY
64106: PUSH
64107: LD_INT 1
64109: ARRAY
64110: PUSH
64111: LD_INT 2
64113: ARRAY
64114: PPUSH
64115: LD_EXP 44
64119: PUSH
64120: LD_VAR 0 2
64124: ARRAY
64125: PUSH
64126: LD_INT 1
64128: ARRAY
64129: PUSH
64130: LD_INT 3
64132: ARRAY
64133: PPUSH
64134: LD_EXP 44
64138: PUSH
64139: LD_VAR 0 2
64143: ARRAY
64144: PUSH
64145: LD_INT 1
64147: ARRAY
64148: PUSH
64149: LD_INT 4
64151: ARRAY
64152: PPUSH
64153: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
64157: LD_ADDR_VAR 0 4
64161: PUSH
64162: LD_EXP 44
64166: PUSH
64167: LD_VAR 0 2
64171: ARRAY
64172: PPUSH
64173: LD_INT 1
64175: PPUSH
64176: CALL_OW 3
64180: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
64181: LD_ADDR_EXP 44
64185: PUSH
64186: LD_EXP 44
64190: PPUSH
64191: LD_VAR 0 2
64195: PPUSH
64196: LD_VAR 0 4
64200: PPUSH
64201: CALL_OW 1
64205: ST_TO_ADDR
// break ;
64206: GO 64210
// end ; end ;
64208: GO 63854
64210: POP
64211: POP
// end ;
64212: GO 63786
64214: POP
64215: POP
// end ;
64216: LD_VAR 0 1
64220: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
64221: LD_INT 0
64223: PPUSH
64224: PPUSH
64225: PPUSH
// if not mc_bases then
64226: LD_EXP 23
64230: NOT
64231: IFFALSE 64235
// exit ;
64233: GO 64324
// for i = 1 to mc_bases do
64235: LD_ADDR_VAR 0 2
64239: PUSH
64240: DOUBLE
64241: LD_INT 1
64243: DEC
64244: ST_TO_ADDR
64245: LD_EXP 23
64249: PUSH
64250: FOR_TO
64251: IFFALSE 64322
// begin if mc_attack [ i ] then
64253: LD_EXP 43
64257: PUSH
64258: LD_VAR 0 2
64262: ARRAY
64263: IFFALSE 64320
// begin tmp := mc_attack [ i ] [ 1 ] ;
64265: LD_ADDR_VAR 0 3
64269: PUSH
64270: LD_EXP 43
64274: PUSH
64275: LD_VAR 0 2
64279: ARRAY
64280: PUSH
64281: LD_INT 1
64283: ARRAY
64284: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
64285: LD_ADDR_EXP 43
64289: PUSH
64290: LD_EXP 43
64294: PPUSH
64295: LD_VAR 0 2
64299: PPUSH
64300: EMPTY
64301: PPUSH
64302: CALL_OW 1
64306: ST_TO_ADDR
// Attack ( tmp ) ;
64307: LD_VAR 0 3
64311: PPUSH
64312: CALL 79102 0 1
// exit ;
64316: POP
64317: POP
64318: GO 64324
// end ; end ;
64320: GO 64250
64322: POP
64323: POP
// end ;
64324: LD_VAR 0 1
64328: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
64329: LD_INT 0
64331: PPUSH
64332: PPUSH
64333: PPUSH
64334: PPUSH
64335: PPUSH
64336: PPUSH
64337: PPUSH
// if not mc_bases then
64338: LD_EXP 23
64342: NOT
64343: IFFALSE 64347
// exit ;
64345: GO 65046
// for i = 1 to mc_bases do
64347: LD_ADDR_VAR 0 2
64351: PUSH
64352: DOUBLE
64353: LD_INT 1
64355: DEC
64356: ST_TO_ADDR
64357: LD_EXP 23
64361: PUSH
64362: FOR_TO
64363: IFFALSE 65044
// begin if not mc_bases [ i ] then
64365: LD_EXP 23
64369: PUSH
64370: LD_VAR 0 2
64374: ARRAY
64375: NOT
64376: IFFALSE 64380
// continue ;
64378: GO 64362
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
64380: LD_ADDR_VAR 0 7
64384: PUSH
64385: LD_EXP 23
64389: PUSH
64390: LD_VAR 0 2
64394: ARRAY
64395: PUSH
64396: LD_INT 1
64398: ARRAY
64399: PPUSH
64400: CALL 11715 0 1
64404: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
64405: LD_ADDR_EXP 46
64409: PUSH
64410: LD_EXP 46
64414: PPUSH
64415: LD_VAR 0 2
64419: PPUSH
64420: LD_EXP 23
64424: PUSH
64425: LD_VAR 0 2
64429: ARRAY
64430: PUSH
64431: LD_INT 1
64433: ARRAY
64434: PPUSH
64435: CALL_OW 255
64439: PPUSH
64440: LD_EXP 48
64444: PUSH
64445: LD_VAR 0 2
64449: ARRAY
64450: PPUSH
64451: CALL 11680 0 2
64455: PPUSH
64456: CALL_OW 1
64460: ST_TO_ADDR
// if not mc_scan [ i ] then
64461: LD_EXP 46
64465: PUSH
64466: LD_VAR 0 2
64470: ARRAY
64471: NOT
64472: IFFALSE 64650
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
64474: LD_ADDR_VAR 0 4
64478: PUSH
64479: LD_EXP 23
64483: PUSH
64484: LD_VAR 0 2
64488: ARRAY
64489: PPUSH
64490: LD_INT 2
64492: PUSH
64493: LD_INT 25
64495: PUSH
64496: LD_INT 5
64498: PUSH
64499: EMPTY
64500: LIST
64501: LIST
64502: PUSH
64503: LD_INT 25
64505: PUSH
64506: LD_INT 8
64508: PUSH
64509: EMPTY
64510: LIST
64511: LIST
64512: PUSH
64513: LD_INT 25
64515: PUSH
64516: LD_INT 9
64518: PUSH
64519: EMPTY
64520: LIST
64521: LIST
64522: PUSH
64523: EMPTY
64524: LIST
64525: LIST
64526: LIST
64527: LIST
64528: PPUSH
64529: CALL_OW 72
64533: ST_TO_ADDR
// if not tmp then
64534: LD_VAR 0 4
64538: NOT
64539: IFFALSE 64543
// continue ;
64541: GO 64362
// for j in tmp do
64543: LD_ADDR_VAR 0 3
64547: PUSH
64548: LD_VAR 0 4
64552: PUSH
64553: FOR_IN
64554: IFFALSE 64625
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
64556: LD_VAR 0 3
64560: PPUSH
64561: CALL_OW 310
64565: PPUSH
64566: CALL_OW 266
64570: PUSH
64571: LD_INT 5
64573: EQUAL
64574: PUSH
64575: LD_VAR 0 3
64579: PPUSH
64580: CALL_OW 257
64584: PUSH
64585: LD_INT 1
64587: EQUAL
64588: AND
64589: PUSH
64590: LD_VAR 0 3
64594: PPUSH
64595: CALL_OW 459
64599: NOT
64600: AND
64601: PUSH
64602: LD_VAR 0 7
64606: AND
64607: IFFALSE 64623
// ComChangeProfession ( j , class ) ;
64609: LD_VAR 0 3
64613: PPUSH
64614: LD_VAR 0 7
64618: PPUSH
64619: CALL_OW 123
64623: GO 64553
64625: POP
64626: POP
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
64627: LD_ADDR_EXP 66
64631: PUSH
64632: LD_EXP 66
64636: PPUSH
64637: LD_VAR 0 2
64641: PPUSH
64642: LD_INT 0
64644: PPUSH
64645: CALL_OW 1
64649: ST_TO_ADDR
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
64650: LD_EXP 46
64654: PUSH
64655: LD_VAR 0 2
64659: ARRAY
64660: PUSH
64661: LD_EXP 66
64665: PUSH
64666: LD_VAR 0 2
64670: ARRAY
64671: NOT
64672: AND
64673: PUSH
64674: LD_EXP 45
64678: PUSH
64679: LD_VAR 0 2
64683: ARRAY
64684: NOT
64685: AND
64686: PUSH
64687: LD_EXP 23
64691: PUSH
64692: LD_VAR 0 2
64696: ARRAY
64697: PPUSH
64698: LD_INT 30
64700: PUSH
64701: LD_INT 32
64703: PUSH
64704: EMPTY
64705: LIST
64706: LIST
64707: PPUSH
64708: CALL_OW 72
64712: NOT
64713: AND
64714: PUSH
64715: LD_EXP 23
64719: PUSH
64720: LD_VAR 0 2
64724: ARRAY
64725: PPUSH
64726: LD_INT 2
64728: PUSH
64729: LD_INT 30
64731: PUSH
64732: LD_INT 4
64734: PUSH
64735: EMPTY
64736: LIST
64737: LIST
64738: PUSH
64739: LD_INT 30
64741: PUSH
64742: LD_INT 5
64744: PUSH
64745: EMPTY
64746: LIST
64747: LIST
64748: PUSH
64749: EMPTY
64750: LIST
64751: LIST
64752: LIST
64753: PPUSH
64754: CALL_OW 72
64758: NOT
64759: AND
64760: IFFALSE 64915
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
64762: LD_ADDR_VAR 0 4
64766: PUSH
64767: LD_EXP 23
64771: PUSH
64772: LD_VAR 0 2
64776: ARRAY
64777: PPUSH
64778: LD_INT 2
64780: PUSH
64781: LD_INT 25
64783: PUSH
64784: LD_INT 1
64786: PUSH
64787: EMPTY
64788: LIST
64789: LIST
64790: PUSH
64791: LD_INT 25
64793: PUSH
64794: LD_INT 5
64796: PUSH
64797: EMPTY
64798: LIST
64799: LIST
64800: PUSH
64801: LD_INT 25
64803: PUSH
64804: LD_INT 8
64806: PUSH
64807: EMPTY
64808: LIST
64809: LIST
64810: PUSH
64811: LD_INT 25
64813: PUSH
64814: LD_INT 9
64816: PUSH
64817: EMPTY
64818: LIST
64819: LIST
64820: PUSH
64821: EMPTY
64822: LIST
64823: LIST
64824: LIST
64825: LIST
64826: LIST
64827: PPUSH
64828: CALL_OW 72
64832: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
64833: LD_ADDR_VAR 0 4
64837: PUSH
64838: LD_VAR 0 4
64842: PUSH
64843: LD_VAR 0 4
64847: PPUSH
64848: LD_INT 18
64850: PPUSH
64851: CALL 44185 0 2
64855: DIFF
64856: ST_TO_ADDR
// if tmp then
64857: LD_VAR 0 4
64861: IFFALSE 64915
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
64863: LD_ADDR_EXP 66
64867: PUSH
64868: LD_EXP 66
64872: PPUSH
64873: LD_VAR 0 2
64877: PPUSH
64878: LD_INT 1
64880: PPUSH
64881: CALL_OW 1
64885: ST_TO_ADDR
// BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
64886: LD_VAR 0 2
64890: PPUSH
64891: LD_VAR 0 4
64895: PPUSH
64896: LD_EXP 48
64900: PUSH
64901: LD_VAR 0 2
64905: ARRAY
64906: PPUSH
64907: CALL 83811 0 3
// exit ;
64911: POP
64912: POP
64913: GO 65046
// end ; end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
64915: LD_EXP 46
64919: PUSH
64920: LD_VAR 0 2
64924: ARRAY
64925: PUSH
64926: LD_EXP 66
64930: PUSH
64931: LD_VAR 0 2
64935: ARRAY
64936: NOT
64937: AND
64938: PUSH
64939: LD_EXP 45
64943: PUSH
64944: LD_VAR 0 2
64948: ARRAY
64949: AND
64950: IFFALSE 65042
// begin tmp := mc_defender [ i ] ;
64952: LD_ADDR_VAR 0 4
64956: PUSH
64957: LD_EXP 45
64961: PUSH
64962: LD_VAR 0 2
64966: ARRAY
64967: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
64968: LD_ADDR_EXP 45
64972: PUSH
64973: LD_EXP 45
64977: PPUSH
64978: LD_VAR 0 2
64982: PPUSH
64983: EMPTY
64984: PPUSH
64985: CALL_OW 1
64989: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , true ) ;
64990: LD_ADDR_EXP 66
64994: PUSH
64995: LD_EXP 66
64999: PPUSH
65000: LD_VAR 0 2
65004: PPUSH
65005: LD_INT 1
65007: PPUSH
65008: CALL_OW 1
65012: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
65013: LD_VAR 0 2
65017: PPUSH
65018: LD_VAR 0 4
65022: PPUSH
65023: LD_EXP 46
65027: PUSH
65028: LD_VAR 0 2
65032: ARRAY
65033: PPUSH
65034: CALL 84372 0 3
// exit ;
65038: POP
65039: POP
65040: GO 65046
// end ; end ;
65042: GO 64362
65044: POP
65045: POP
// end ;
65046: LD_VAR 0 1
65050: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
65051: LD_INT 0
65053: PPUSH
65054: PPUSH
65055: PPUSH
65056: PPUSH
65057: PPUSH
65058: PPUSH
65059: PPUSH
65060: PPUSH
65061: PPUSH
65062: PPUSH
65063: PPUSH
// if not mc_bases then
65064: LD_EXP 23
65068: NOT
65069: IFFALSE 65073
// exit ;
65071: GO 66160
// for i = 1 to mc_bases do
65073: LD_ADDR_VAR 0 2
65077: PUSH
65078: DOUBLE
65079: LD_INT 1
65081: DEC
65082: ST_TO_ADDR
65083: LD_EXP 23
65087: PUSH
65088: FOR_TO
65089: IFFALSE 66158
// begin tmp := mc_lab [ i ] ;
65091: LD_ADDR_VAR 0 6
65095: PUSH
65096: LD_EXP 56
65100: PUSH
65101: LD_VAR 0 2
65105: ARRAY
65106: ST_TO_ADDR
// if not tmp then
65107: LD_VAR 0 6
65111: NOT
65112: IFFALSE 65116
// continue ;
65114: GO 65088
// idle_lab := 0 ;
65116: LD_ADDR_VAR 0 11
65120: PUSH
65121: LD_INT 0
65123: ST_TO_ADDR
// for j in tmp do
65124: LD_ADDR_VAR 0 3
65128: PUSH
65129: LD_VAR 0 6
65133: PUSH
65134: FOR_IN
65135: IFFALSE 66154
// begin researching := false ;
65137: LD_ADDR_VAR 0 10
65141: PUSH
65142: LD_INT 0
65144: ST_TO_ADDR
// side := GetSide ( j ) ;
65145: LD_ADDR_VAR 0 4
65149: PUSH
65150: LD_VAR 0 3
65154: PPUSH
65155: CALL_OW 255
65159: ST_TO_ADDR
// if not mc_tech [ side ] then
65160: LD_EXP 50
65164: PUSH
65165: LD_VAR 0 4
65169: ARRAY
65170: NOT
65171: IFFALSE 65175
// continue ;
65173: GO 65134
// if BuildingStatus ( j ) = bs_idle then
65175: LD_VAR 0 3
65179: PPUSH
65180: CALL_OW 461
65184: PUSH
65185: LD_INT 2
65187: EQUAL
65188: IFFALSE 65376
// begin if idle_lab and UnitsInside ( j ) < 6 then
65190: LD_VAR 0 11
65194: PUSH
65195: LD_VAR 0 3
65199: PPUSH
65200: CALL_OW 313
65204: PUSH
65205: LD_INT 6
65207: LESS
65208: AND
65209: IFFALSE 65280
// begin tmp2 := UnitsInside ( idle_lab ) ;
65211: LD_ADDR_VAR 0 9
65215: PUSH
65216: LD_VAR 0 11
65220: PPUSH
65221: CALL_OW 313
65225: ST_TO_ADDR
// if tmp2 then
65226: LD_VAR 0 9
65230: IFFALSE 65272
// for x in tmp2 do
65232: LD_ADDR_VAR 0 7
65236: PUSH
65237: LD_VAR 0 9
65241: PUSH
65242: FOR_IN
65243: IFFALSE 65270
// begin ComExitBuilding ( x ) ;
65245: LD_VAR 0 7
65249: PPUSH
65250: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
65254: LD_VAR 0 7
65258: PPUSH
65259: LD_VAR 0 3
65263: PPUSH
65264: CALL_OW 180
// end ;
65268: GO 65242
65270: POP
65271: POP
// idle_lab := 0 ;
65272: LD_ADDR_VAR 0 11
65276: PUSH
65277: LD_INT 0
65279: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
65280: LD_ADDR_VAR 0 5
65284: PUSH
65285: LD_EXP 50
65289: PUSH
65290: LD_VAR 0 4
65294: ARRAY
65295: PUSH
65296: FOR_IN
65297: IFFALSE 65357
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
65299: LD_VAR 0 3
65303: PPUSH
65304: LD_VAR 0 5
65308: PPUSH
65309: CALL_OW 430
65313: PUSH
65314: LD_VAR 0 4
65318: PPUSH
65319: LD_VAR 0 5
65323: PPUSH
65324: CALL 10785 0 2
65328: AND
65329: IFFALSE 65355
// begin researching := true ;
65331: LD_ADDR_VAR 0 10
65335: PUSH
65336: LD_INT 1
65338: ST_TO_ADDR
// ComResearch ( j , t ) ;
65339: LD_VAR 0 3
65343: PPUSH
65344: LD_VAR 0 5
65348: PPUSH
65349: CALL_OW 124
// break ;
65353: GO 65357
// end ;
65355: GO 65296
65357: POP
65358: POP
// if not researching then
65359: LD_VAR 0 10
65363: NOT
65364: IFFALSE 65376
// idle_lab := j ;
65366: LD_ADDR_VAR 0 11
65370: PUSH
65371: LD_VAR 0 3
65375: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
65376: LD_VAR 0 3
65380: PPUSH
65381: CALL_OW 461
65385: PUSH
65386: LD_INT 10
65388: EQUAL
65389: IFFALSE 65977
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
65391: LD_EXP 52
65395: PUSH
65396: LD_VAR 0 2
65400: ARRAY
65401: NOT
65402: PUSH
65403: LD_EXP 53
65407: PUSH
65408: LD_VAR 0 2
65412: ARRAY
65413: NOT
65414: AND
65415: PUSH
65416: LD_EXP 50
65420: PUSH
65421: LD_VAR 0 4
65425: ARRAY
65426: PUSH
65427: LD_INT 1
65429: GREATER
65430: AND
65431: IFFALSE 65562
// begin ComCancel ( j ) ;
65433: LD_VAR 0 3
65437: PPUSH
65438: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
65442: LD_ADDR_EXP 50
65446: PUSH
65447: LD_EXP 50
65451: PPUSH
65452: LD_VAR 0 4
65456: PPUSH
65457: LD_EXP 50
65461: PUSH
65462: LD_VAR 0 4
65466: ARRAY
65467: PPUSH
65468: LD_EXP 50
65472: PUSH
65473: LD_VAR 0 4
65477: ARRAY
65478: PUSH
65479: LD_INT 1
65481: MINUS
65482: PPUSH
65483: LD_EXP 50
65487: PUSH
65488: LD_VAR 0 4
65492: ARRAY
65493: PPUSH
65494: LD_INT 0
65496: PPUSH
65497: CALL 14333 0 4
65501: PPUSH
65502: CALL_OW 1
65506: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
65507: LD_ADDR_EXP 50
65511: PUSH
65512: LD_EXP 50
65516: PPUSH
65517: LD_VAR 0 4
65521: PPUSH
65522: LD_EXP 50
65526: PUSH
65527: LD_VAR 0 4
65531: ARRAY
65532: PPUSH
65533: LD_EXP 50
65537: PUSH
65538: LD_VAR 0 4
65542: ARRAY
65543: PPUSH
65544: LD_INT 1
65546: PPUSH
65547: LD_INT 0
65549: PPUSH
65550: CALL 14333 0 4
65554: PPUSH
65555: CALL_OW 1
65559: ST_TO_ADDR
// continue ;
65560: GO 65134
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
65562: LD_EXP 52
65566: PUSH
65567: LD_VAR 0 2
65571: ARRAY
65572: PUSH
65573: LD_EXP 53
65577: PUSH
65578: LD_VAR 0 2
65582: ARRAY
65583: NOT
65584: AND
65585: IFFALSE 65712
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
65587: LD_ADDR_EXP 53
65591: PUSH
65592: LD_EXP 53
65596: PPUSH
65597: LD_VAR 0 2
65601: PUSH
65602: LD_EXP 53
65606: PUSH
65607: LD_VAR 0 2
65611: ARRAY
65612: PUSH
65613: LD_INT 1
65615: PLUS
65616: PUSH
65617: EMPTY
65618: LIST
65619: LIST
65620: PPUSH
65621: LD_EXP 52
65625: PUSH
65626: LD_VAR 0 2
65630: ARRAY
65631: PUSH
65632: LD_INT 1
65634: ARRAY
65635: PPUSH
65636: CALL 14915 0 3
65640: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
65641: LD_EXP 52
65645: PUSH
65646: LD_VAR 0 2
65650: ARRAY
65651: PUSH
65652: LD_INT 1
65654: ARRAY
65655: PPUSH
65656: LD_INT 112
65658: PPUSH
65659: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
65663: LD_ADDR_VAR 0 9
65667: PUSH
65668: LD_EXP 52
65672: PUSH
65673: LD_VAR 0 2
65677: ARRAY
65678: PPUSH
65679: LD_INT 1
65681: PPUSH
65682: CALL_OW 3
65686: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
65687: LD_ADDR_EXP 52
65691: PUSH
65692: LD_EXP 52
65696: PPUSH
65697: LD_VAR 0 2
65701: PPUSH
65702: LD_VAR 0 9
65706: PPUSH
65707: CALL_OW 1
65711: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
65712: LD_EXP 52
65716: PUSH
65717: LD_VAR 0 2
65721: ARRAY
65722: PUSH
65723: LD_EXP 53
65727: PUSH
65728: LD_VAR 0 2
65732: ARRAY
65733: AND
65734: PUSH
65735: LD_EXP 53
65739: PUSH
65740: LD_VAR 0 2
65744: ARRAY
65745: PUSH
65746: LD_INT 1
65748: ARRAY
65749: PPUSH
65750: CALL_OW 310
65754: NOT
65755: AND
65756: PUSH
65757: LD_VAR 0 3
65761: PPUSH
65762: CALL_OW 313
65766: PUSH
65767: LD_INT 6
65769: EQUAL
65770: AND
65771: IFFALSE 65827
// begin tmp2 := UnitsInside ( j ) ;
65773: LD_ADDR_VAR 0 9
65777: PUSH
65778: LD_VAR 0 3
65782: PPUSH
65783: CALL_OW 313
65787: ST_TO_ADDR
// if tmp2 = 6 then
65788: LD_VAR 0 9
65792: PUSH
65793: LD_INT 6
65795: EQUAL
65796: IFFALSE 65827
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
65798: LD_VAR 0 9
65802: PUSH
65803: LD_INT 1
65805: ARRAY
65806: PPUSH
65807: LD_INT 112
65809: PPUSH
65810: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
65814: LD_VAR 0 9
65818: PUSH
65819: LD_INT 1
65821: ARRAY
65822: PPUSH
65823: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
65827: LD_EXP 53
65831: PUSH
65832: LD_VAR 0 2
65836: ARRAY
65837: PUSH
65838: LD_EXP 53
65842: PUSH
65843: LD_VAR 0 2
65847: ARRAY
65848: PUSH
65849: LD_INT 1
65851: ARRAY
65852: PPUSH
65853: CALL_OW 314
65857: NOT
65858: AND
65859: PUSH
65860: LD_EXP 53
65864: PUSH
65865: LD_VAR 0 2
65869: ARRAY
65870: PUSH
65871: LD_INT 1
65873: ARRAY
65874: PPUSH
65875: CALL_OW 310
65879: NOT
65880: AND
65881: IFFALSE 65907
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
65883: LD_EXP 53
65887: PUSH
65888: LD_VAR 0 2
65892: ARRAY
65893: PUSH
65894: LD_INT 1
65896: ARRAY
65897: PPUSH
65898: LD_VAR 0 3
65902: PPUSH
65903: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
65907: LD_EXP 53
65911: PUSH
65912: LD_VAR 0 2
65916: ARRAY
65917: PUSH
65918: LD_INT 1
65920: ARRAY
65921: PPUSH
65922: CALL_OW 310
65926: PUSH
65927: LD_EXP 53
65931: PUSH
65932: LD_VAR 0 2
65936: ARRAY
65937: PUSH
65938: LD_INT 1
65940: ARRAY
65941: PPUSH
65942: CALL_OW 310
65946: PPUSH
65947: CALL_OW 461
65951: PUSH
65952: LD_INT 3
65954: NONEQUAL
65955: AND
65956: IFFALSE 65977
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
65958: LD_EXP 53
65962: PUSH
65963: LD_VAR 0 2
65967: ARRAY
65968: PUSH
65969: LD_INT 1
65971: ARRAY
65972: PPUSH
65973: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
65977: LD_VAR 0 3
65981: PPUSH
65982: CALL_OW 461
65986: PUSH
65987: LD_INT 6
65989: EQUAL
65990: PUSH
65991: LD_VAR 0 6
65995: PUSH
65996: LD_INT 1
65998: GREATER
65999: AND
66000: IFFALSE 66152
// begin sci := [ ] ;
66002: LD_ADDR_VAR 0 8
66006: PUSH
66007: EMPTY
66008: ST_TO_ADDR
// for x in ( tmp diff j ) do
66009: LD_ADDR_VAR 0 7
66013: PUSH
66014: LD_VAR 0 6
66018: PUSH
66019: LD_VAR 0 3
66023: DIFF
66024: PUSH
66025: FOR_IN
66026: IFFALSE 66078
// begin if sci = 6 then
66028: LD_VAR 0 8
66032: PUSH
66033: LD_INT 6
66035: EQUAL
66036: IFFALSE 66040
// break ;
66038: GO 66078
// if BuildingStatus ( x ) = bs_idle then
66040: LD_VAR 0 7
66044: PPUSH
66045: CALL_OW 461
66049: PUSH
66050: LD_INT 2
66052: EQUAL
66053: IFFALSE 66076
// sci := sci ^ UnitsInside ( x ) ;
66055: LD_ADDR_VAR 0 8
66059: PUSH
66060: LD_VAR 0 8
66064: PUSH
66065: LD_VAR 0 7
66069: PPUSH
66070: CALL_OW 313
66074: ADD
66075: ST_TO_ADDR
// end ;
66076: GO 66025
66078: POP
66079: POP
// if not sci then
66080: LD_VAR 0 8
66084: NOT
66085: IFFALSE 66089
// continue ;
66087: GO 65134
// for x in sci do
66089: LD_ADDR_VAR 0 7
66093: PUSH
66094: LD_VAR 0 8
66098: PUSH
66099: FOR_IN
66100: IFFALSE 66150
// if IsInUnit ( x ) and not HasTask ( x ) then
66102: LD_VAR 0 7
66106: PPUSH
66107: CALL_OW 310
66111: PUSH
66112: LD_VAR 0 7
66116: PPUSH
66117: CALL_OW 314
66121: NOT
66122: AND
66123: IFFALSE 66148
// begin ComExitBuilding ( x ) ;
66125: LD_VAR 0 7
66129: PPUSH
66130: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
66134: LD_VAR 0 7
66138: PPUSH
66139: LD_VAR 0 3
66143: PPUSH
66144: CALL_OW 180
// end ;
66148: GO 66099
66150: POP
66151: POP
// end ; end ;
66152: GO 65134
66154: POP
66155: POP
// end ;
66156: GO 65088
66158: POP
66159: POP
// end ;
66160: LD_VAR 0 1
66164: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
66165: LD_INT 0
66167: PPUSH
66168: PPUSH
// if not mc_bases then
66169: LD_EXP 23
66173: NOT
66174: IFFALSE 66178
// exit ;
66176: GO 66259
// for i = 1 to mc_bases do
66178: LD_ADDR_VAR 0 2
66182: PUSH
66183: DOUBLE
66184: LD_INT 1
66186: DEC
66187: ST_TO_ADDR
66188: LD_EXP 23
66192: PUSH
66193: FOR_TO
66194: IFFALSE 66257
// if mc_mines [ i ] and mc_miners [ i ] then
66196: LD_EXP 36
66200: PUSH
66201: LD_VAR 0 2
66205: ARRAY
66206: PUSH
66207: LD_EXP 37
66211: PUSH
66212: LD_VAR 0 2
66216: ARRAY
66217: AND
66218: IFFALSE 66255
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
66220: LD_EXP 37
66224: PUSH
66225: LD_VAR 0 2
66229: ARRAY
66230: PUSH
66231: LD_INT 1
66233: ARRAY
66234: PPUSH
66235: CALL_OW 255
66239: PPUSH
66240: LD_EXP 36
66244: PUSH
66245: LD_VAR 0 2
66249: ARRAY
66250: PPUSH
66251: CALL 11868 0 2
66255: GO 66193
66257: POP
66258: POP
// end ;
66259: LD_VAR 0 1
66263: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
66264: LD_INT 0
66266: PPUSH
66267: PPUSH
66268: PPUSH
66269: PPUSH
66270: PPUSH
66271: PPUSH
66272: PPUSH
66273: PPUSH
// if not mc_bases or not mc_parking then
66274: LD_EXP 23
66278: NOT
66279: PUSH
66280: LD_EXP 47
66284: NOT
66285: OR
66286: IFFALSE 66290
// exit ;
66288: GO 67000
// for i = 1 to mc_bases do
66290: LD_ADDR_VAR 0 2
66294: PUSH
66295: DOUBLE
66296: LD_INT 1
66298: DEC
66299: ST_TO_ADDR
66300: LD_EXP 23
66304: PUSH
66305: FOR_TO
66306: IFFALSE 66998
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
66308: LD_EXP 23
66312: PUSH
66313: LD_VAR 0 2
66317: ARRAY
66318: NOT
66319: PUSH
66320: LD_EXP 47
66324: PUSH
66325: LD_VAR 0 2
66329: ARRAY
66330: NOT
66331: OR
66332: IFFALSE 66336
// continue ;
66334: GO 66305
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
66336: LD_ADDR_VAR 0 5
66340: PUSH
66341: LD_EXP 23
66345: PUSH
66346: LD_VAR 0 2
66350: ARRAY
66351: PUSH
66352: LD_INT 1
66354: ARRAY
66355: PPUSH
66356: CALL_OW 255
66360: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
66361: LD_ADDR_VAR 0 6
66365: PUSH
66366: LD_EXP 23
66370: PUSH
66371: LD_VAR 0 2
66375: ARRAY
66376: PPUSH
66377: LD_INT 30
66379: PUSH
66380: LD_INT 3
66382: PUSH
66383: EMPTY
66384: LIST
66385: LIST
66386: PPUSH
66387: CALL_OW 72
66391: ST_TO_ADDR
// if not fac then
66392: LD_VAR 0 6
66396: NOT
66397: IFFALSE 66448
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
66399: LD_ADDR_VAR 0 6
66403: PUSH
66404: LD_EXP 23
66408: PUSH
66409: LD_VAR 0 2
66413: ARRAY
66414: PPUSH
66415: LD_INT 2
66417: PUSH
66418: LD_INT 30
66420: PUSH
66421: LD_INT 0
66423: PUSH
66424: EMPTY
66425: LIST
66426: LIST
66427: PUSH
66428: LD_INT 30
66430: PUSH
66431: LD_INT 1
66433: PUSH
66434: EMPTY
66435: LIST
66436: LIST
66437: PUSH
66438: EMPTY
66439: LIST
66440: LIST
66441: LIST
66442: PPUSH
66443: CALL_OW 72
66447: ST_TO_ADDR
// if not fac then
66448: LD_VAR 0 6
66452: NOT
66453: IFFALSE 66457
// continue ;
66455: GO 66305
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
66457: LD_ADDR_VAR 0 7
66461: PUSH
66462: LD_EXP 47
66466: PUSH
66467: LD_VAR 0 2
66471: ARRAY
66472: PPUSH
66473: LD_INT 22
66475: PUSH
66476: LD_VAR 0 5
66480: PUSH
66481: EMPTY
66482: LIST
66483: LIST
66484: PUSH
66485: LD_INT 21
66487: PUSH
66488: LD_INT 2
66490: PUSH
66491: EMPTY
66492: LIST
66493: LIST
66494: PUSH
66495: LD_INT 3
66497: PUSH
66498: LD_INT 24
66500: PUSH
66501: LD_INT 1000
66503: PUSH
66504: EMPTY
66505: LIST
66506: LIST
66507: PUSH
66508: EMPTY
66509: LIST
66510: LIST
66511: PUSH
66512: EMPTY
66513: LIST
66514: LIST
66515: LIST
66516: PPUSH
66517: CALL_OW 70
66521: ST_TO_ADDR
// for j in fac do
66522: LD_ADDR_VAR 0 3
66526: PUSH
66527: LD_VAR 0 6
66531: PUSH
66532: FOR_IN
66533: IFFALSE 66614
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
66535: LD_ADDR_VAR 0 7
66539: PUSH
66540: LD_VAR 0 7
66544: PUSH
66545: LD_INT 22
66547: PUSH
66548: LD_VAR 0 5
66552: PUSH
66553: EMPTY
66554: LIST
66555: LIST
66556: PUSH
66557: LD_INT 91
66559: PUSH
66560: LD_VAR 0 3
66564: PUSH
66565: LD_INT 15
66567: PUSH
66568: EMPTY
66569: LIST
66570: LIST
66571: LIST
66572: PUSH
66573: LD_INT 21
66575: PUSH
66576: LD_INT 2
66578: PUSH
66579: EMPTY
66580: LIST
66581: LIST
66582: PUSH
66583: LD_INT 3
66585: PUSH
66586: LD_INT 24
66588: PUSH
66589: LD_INT 1000
66591: PUSH
66592: EMPTY
66593: LIST
66594: LIST
66595: PUSH
66596: EMPTY
66597: LIST
66598: LIST
66599: PUSH
66600: EMPTY
66601: LIST
66602: LIST
66603: LIST
66604: LIST
66605: PPUSH
66606: CALL_OW 69
66610: UNION
66611: ST_TO_ADDR
66612: GO 66532
66614: POP
66615: POP
// if not vehs then
66616: LD_VAR 0 7
66620: NOT
66621: IFFALSE 66647
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
66623: LD_ADDR_EXP 35
66627: PUSH
66628: LD_EXP 35
66632: PPUSH
66633: LD_VAR 0 2
66637: PPUSH
66638: EMPTY
66639: PPUSH
66640: CALL_OW 1
66644: ST_TO_ADDR
// continue ;
66645: GO 66305
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
66647: LD_ADDR_VAR 0 8
66651: PUSH
66652: LD_EXP 23
66656: PUSH
66657: LD_VAR 0 2
66661: ARRAY
66662: PPUSH
66663: LD_INT 30
66665: PUSH
66666: LD_INT 3
66668: PUSH
66669: EMPTY
66670: LIST
66671: LIST
66672: PPUSH
66673: CALL_OW 72
66677: ST_TO_ADDR
// if tmp then
66678: LD_VAR 0 8
66682: IFFALSE 66785
// begin for j in tmp do
66684: LD_ADDR_VAR 0 3
66688: PUSH
66689: LD_VAR 0 8
66693: PUSH
66694: FOR_IN
66695: IFFALSE 66783
// for k in UnitsInside ( j ) do
66697: LD_ADDR_VAR 0 4
66701: PUSH
66702: LD_VAR 0 3
66706: PPUSH
66707: CALL_OW 313
66711: PUSH
66712: FOR_IN
66713: IFFALSE 66779
// if k then
66715: LD_VAR 0 4
66719: IFFALSE 66777
// if not k in mc_repair_vehicle [ i ] then
66721: LD_VAR 0 4
66725: PUSH
66726: LD_EXP 35
66730: PUSH
66731: LD_VAR 0 2
66735: ARRAY
66736: IN
66737: NOT
66738: IFFALSE 66777
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
66740: LD_ADDR_EXP 35
66744: PUSH
66745: LD_EXP 35
66749: PPUSH
66750: LD_VAR 0 2
66754: PPUSH
66755: LD_EXP 35
66759: PUSH
66760: LD_VAR 0 2
66764: ARRAY
66765: PUSH
66766: LD_VAR 0 4
66770: UNION
66771: PPUSH
66772: CALL_OW 1
66776: ST_TO_ADDR
66777: GO 66712
66779: POP
66780: POP
66781: GO 66694
66783: POP
66784: POP
// end ; if not mc_repair_vehicle [ i ] then
66785: LD_EXP 35
66789: PUSH
66790: LD_VAR 0 2
66794: ARRAY
66795: NOT
66796: IFFALSE 66800
// continue ;
66798: GO 66305
// for j in mc_repair_vehicle [ i ] do
66800: LD_ADDR_VAR 0 3
66804: PUSH
66805: LD_EXP 35
66809: PUSH
66810: LD_VAR 0 2
66814: ARRAY
66815: PUSH
66816: FOR_IN
66817: IFFALSE 66994
// begin if GetClass ( j ) <> 3 then
66819: LD_VAR 0 3
66823: PPUSH
66824: CALL_OW 257
66828: PUSH
66829: LD_INT 3
66831: NONEQUAL
66832: IFFALSE 66873
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
66834: LD_ADDR_EXP 35
66838: PUSH
66839: LD_EXP 35
66843: PPUSH
66844: LD_VAR 0 2
66848: PPUSH
66849: LD_EXP 35
66853: PUSH
66854: LD_VAR 0 2
66858: ARRAY
66859: PUSH
66860: LD_VAR 0 3
66864: DIFF
66865: PPUSH
66866: CALL_OW 1
66870: ST_TO_ADDR
// continue ;
66871: GO 66816
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
66873: LD_VAR 0 3
66877: PPUSH
66878: CALL_OW 311
66882: NOT
66883: PUSH
66884: LD_VAR 0 3
66888: PUSH
66889: LD_EXP 26
66893: PUSH
66894: LD_VAR 0 2
66898: ARRAY
66899: PUSH
66900: LD_INT 1
66902: ARRAY
66903: IN
66904: NOT
66905: AND
66906: PUSH
66907: LD_VAR 0 3
66911: PUSH
66912: LD_EXP 26
66916: PUSH
66917: LD_VAR 0 2
66921: ARRAY
66922: PUSH
66923: LD_INT 2
66925: ARRAY
66926: IN
66927: NOT
66928: AND
66929: IFFALSE 66992
// begin if IsInUnit ( j ) then
66931: LD_VAR 0 3
66935: PPUSH
66936: CALL_OW 310
66940: IFFALSE 66953
// ComExitBuilding ( j ) else
66942: LD_VAR 0 3
66946: PPUSH
66947: CALL_OW 122
66951: GO 66992
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
66953: LD_VAR 0 3
66957: PPUSH
66958: LD_VAR 0 7
66962: PUSH
66963: LD_INT 1
66965: ARRAY
66966: PPUSH
66967: CALL 48403 0 2
66971: NOT
66972: IFFALSE 66992
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
66974: LD_VAR 0 3
66978: PPUSH
66979: LD_VAR 0 7
66983: PUSH
66984: LD_INT 1
66986: ARRAY
66987: PPUSH
66988: CALL_OW 129
// end ; end ;
66992: GO 66816
66994: POP
66995: POP
// end ;
66996: GO 66305
66998: POP
66999: POP
// end ;
67000: LD_VAR 0 1
67004: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
67005: LD_INT 0
67007: PPUSH
67008: PPUSH
67009: PPUSH
67010: PPUSH
67011: PPUSH
67012: PPUSH
67013: PPUSH
67014: PPUSH
67015: PPUSH
67016: PPUSH
67017: PPUSH
// if not mc_bases then
67018: LD_EXP 23
67022: NOT
67023: IFFALSE 67027
// exit ;
67025: GO 67829
// for i = 1 to mc_bases do
67027: LD_ADDR_VAR 0 2
67031: PUSH
67032: DOUBLE
67033: LD_INT 1
67035: DEC
67036: ST_TO_ADDR
67037: LD_EXP 23
67041: PUSH
67042: FOR_TO
67043: IFFALSE 67827
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
67045: LD_EXP 51
67049: PUSH
67050: LD_VAR 0 2
67054: ARRAY
67055: NOT
67056: PUSH
67057: LD_EXP 26
67061: PUSH
67062: LD_VAR 0 2
67066: ARRAY
67067: PUSH
67068: LD_INT 1
67070: ARRAY
67071: OR
67072: PUSH
67073: LD_EXP 26
67077: PUSH
67078: LD_VAR 0 2
67082: ARRAY
67083: PUSH
67084: LD_INT 2
67086: ARRAY
67087: OR
67088: PUSH
67089: LD_EXP 49
67093: PUSH
67094: LD_VAR 0 2
67098: ARRAY
67099: PPUSH
67100: LD_INT 1
67102: PPUSH
67103: CALL_OW 325
67107: NOT
67108: OR
67109: PUSH
67110: LD_EXP 46
67114: PUSH
67115: LD_VAR 0 2
67119: ARRAY
67120: OR
67121: IFFALSE 67125
// continue ;
67123: GO 67042
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
67125: LD_ADDR_VAR 0 8
67129: PUSH
67130: LD_EXP 23
67134: PUSH
67135: LD_VAR 0 2
67139: ARRAY
67140: PPUSH
67141: LD_INT 25
67143: PUSH
67144: LD_INT 4
67146: PUSH
67147: EMPTY
67148: LIST
67149: LIST
67150: PUSH
67151: LD_INT 50
67153: PUSH
67154: EMPTY
67155: LIST
67156: PUSH
67157: LD_INT 3
67159: PUSH
67160: LD_INT 60
67162: PUSH
67163: EMPTY
67164: LIST
67165: PUSH
67166: EMPTY
67167: LIST
67168: LIST
67169: PUSH
67170: EMPTY
67171: LIST
67172: LIST
67173: LIST
67174: PPUSH
67175: CALL_OW 72
67179: PUSH
67180: LD_EXP 27
67184: PUSH
67185: LD_VAR 0 2
67189: ARRAY
67190: DIFF
67191: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67192: LD_ADDR_VAR 0 9
67196: PUSH
67197: LD_EXP 23
67201: PUSH
67202: LD_VAR 0 2
67206: ARRAY
67207: PPUSH
67208: LD_INT 2
67210: PUSH
67211: LD_INT 30
67213: PUSH
67214: LD_INT 0
67216: PUSH
67217: EMPTY
67218: LIST
67219: LIST
67220: PUSH
67221: LD_INT 30
67223: PUSH
67224: LD_INT 1
67226: PUSH
67227: EMPTY
67228: LIST
67229: LIST
67230: PUSH
67231: EMPTY
67232: LIST
67233: LIST
67234: LIST
67235: PPUSH
67236: CALL_OW 72
67240: ST_TO_ADDR
// if not tmp or not dep then
67241: LD_VAR 0 8
67245: NOT
67246: PUSH
67247: LD_VAR 0 9
67251: NOT
67252: OR
67253: IFFALSE 67257
// continue ;
67255: GO 67042
// side := GetSide ( tmp [ 1 ] ) ;
67257: LD_ADDR_VAR 0 11
67261: PUSH
67262: LD_VAR 0 8
67266: PUSH
67267: LD_INT 1
67269: ARRAY
67270: PPUSH
67271: CALL_OW 255
67275: ST_TO_ADDR
// dep := dep [ 1 ] ;
67276: LD_ADDR_VAR 0 9
67280: PUSH
67281: LD_VAR 0 9
67285: PUSH
67286: LD_INT 1
67288: ARRAY
67289: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
67290: LD_ADDR_VAR 0 7
67294: PUSH
67295: LD_EXP 51
67299: PUSH
67300: LD_VAR 0 2
67304: ARRAY
67305: PPUSH
67306: LD_INT 22
67308: PUSH
67309: LD_INT 0
67311: PUSH
67312: EMPTY
67313: LIST
67314: LIST
67315: PUSH
67316: LD_INT 25
67318: PUSH
67319: LD_INT 12
67321: PUSH
67322: EMPTY
67323: LIST
67324: LIST
67325: PUSH
67326: EMPTY
67327: LIST
67328: LIST
67329: PPUSH
67330: CALL_OW 70
67334: PUSH
67335: LD_INT 22
67337: PUSH
67338: LD_INT 0
67340: PUSH
67341: EMPTY
67342: LIST
67343: LIST
67344: PUSH
67345: LD_INT 25
67347: PUSH
67348: LD_INT 12
67350: PUSH
67351: EMPTY
67352: LIST
67353: LIST
67354: PUSH
67355: LD_INT 91
67357: PUSH
67358: LD_VAR 0 9
67362: PUSH
67363: LD_INT 20
67365: PUSH
67366: EMPTY
67367: LIST
67368: LIST
67369: LIST
67370: PUSH
67371: EMPTY
67372: LIST
67373: LIST
67374: LIST
67375: PPUSH
67376: CALL_OW 69
67380: UNION
67381: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
67382: LD_ADDR_VAR 0 10
67386: PUSH
67387: LD_EXP 51
67391: PUSH
67392: LD_VAR 0 2
67396: ARRAY
67397: PPUSH
67398: LD_INT 81
67400: PUSH
67401: LD_VAR 0 11
67405: PUSH
67406: EMPTY
67407: LIST
67408: LIST
67409: PPUSH
67410: CALL_OW 70
67414: ST_TO_ADDR
// if not apes or danger_at_area then
67415: LD_VAR 0 7
67419: NOT
67420: PUSH
67421: LD_VAR 0 10
67425: OR
67426: IFFALSE 67476
// begin if mc_taming [ i ] then
67428: LD_EXP 54
67432: PUSH
67433: LD_VAR 0 2
67437: ARRAY
67438: IFFALSE 67474
// begin MC_Reset ( i , 121 ) ;
67440: LD_VAR 0 2
67444: PPUSH
67445: LD_INT 121
67447: PPUSH
67448: CALL 52678 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
67452: LD_ADDR_EXP 54
67456: PUSH
67457: LD_EXP 54
67461: PPUSH
67462: LD_VAR 0 2
67466: PPUSH
67467: EMPTY
67468: PPUSH
67469: CALL_OW 1
67473: ST_TO_ADDR
// end ; continue ;
67474: GO 67042
// end ; for j in tmp do
67476: LD_ADDR_VAR 0 3
67480: PUSH
67481: LD_VAR 0 8
67485: PUSH
67486: FOR_IN
67487: IFFALSE 67823
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
67489: LD_VAR 0 3
67493: PUSH
67494: LD_EXP 54
67498: PUSH
67499: LD_VAR 0 2
67503: ARRAY
67504: IN
67505: NOT
67506: PUSH
67507: LD_EXP 54
67511: PUSH
67512: LD_VAR 0 2
67516: ARRAY
67517: PUSH
67518: LD_INT 3
67520: LESS
67521: AND
67522: IFFALSE 67580
// begin SetTag ( j , 121 ) ;
67524: LD_VAR 0 3
67528: PPUSH
67529: LD_INT 121
67531: PPUSH
67532: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
67536: LD_ADDR_EXP 54
67540: PUSH
67541: LD_EXP 54
67545: PPUSH
67546: LD_VAR 0 2
67550: PUSH
67551: LD_EXP 54
67555: PUSH
67556: LD_VAR 0 2
67560: ARRAY
67561: PUSH
67562: LD_INT 1
67564: PLUS
67565: PUSH
67566: EMPTY
67567: LIST
67568: LIST
67569: PPUSH
67570: LD_VAR 0 3
67574: PPUSH
67575: CALL 14915 0 3
67579: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
67580: LD_VAR 0 3
67584: PUSH
67585: LD_EXP 54
67589: PUSH
67590: LD_VAR 0 2
67594: ARRAY
67595: IN
67596: IFFALSE 67821
// begin if GetClass ( j ) <> 4 then
67598: LD_VAR 0 3
67602: PPUSH
67603: CALL_OW 257
67607: PUSH
67608: LD_INT 4
67610: NONEQUAL
67611: IFFALSE 67664
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
67613: LD_ADDR_EXP 54
67617: PUSH
67618: LD_EXP 54
67622: PPUSH
67623: LD_VAR 0 2
67627: PPUSH
67628: LD_EXP 54
67632: PUSH
67633: LD_VAR 0 2
67637: ARRAY
67638: PUSH
67639: LD_VAR 0 3
67643: DIFF
67644: PPUSH
67645: CALL_OW 1
67649: ST_TO_ADDR
// SetTag ( j , 0 ) ;
67650: LD_VAR 0 3
67654: PPUSH
67655: LD_INT 0
67657: PPUSH
67658: CALL_OW 109
// continue ;
67662: GO 67486
// end ; if IsInUnit ( j ) then
67664: LD_VAR 0 3
67668: PPUSH
67669: CALL_OW 310
67673: IFFALSE 67684
// ComExitBuilding ( j ) ;
67675: LD_VAR 0 3
67679: PPUSH
67680: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
67684: LD_ADDR_VAR 0 6
67688: PUSH
67689: LD_VAR 0 7
67693: PPUSH
67694: LD_VAR 0 3
67698: PPUSH
67699: CALL_OW 74
67703: ST_TO_ADDR
// if not ape then
67704: LD_VAR 0 6
67708: NOT
67709: IFFALSE 67713
// break ;
67711: GO 67823
// x := GetX ( ape ) ;
67713: LD_ADDR_VAR 0 4
67717: PUSH
67718: LD_VAR 0 6
67722: PPUSH
67723: CALL_OW 250
67727: ST_TO_ADDR
// y := GetY ( ape ) ;
67728: LD_ADDR_VAR 0 5
67732: PUSH
67733: LD_VAR 0 6
67737: PPUSH
67738: CALL_OW 251
67742: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
67743: LD_VAR 0 4
67747: PPUSH
67748: LD_VAR 0 5
67752: PPUSH
67753: CALL_OW 488
67757: NOT
67758: PUSH
67759: LD_VAR 0 11
67763: PPUSH
67764: LD_VAR 0 4
67768: PPUSH
67769: LD_VAR 0 5
67773: PPUSH
67774: LD_INT 20
67776: PPUSH
67777: CALL 15811 0 4
67781: PUSH
67782: LD_INT 4
67784: ARRAY
67785: OR
67786: IFFALSE 67790
// break ;
67788: GO 67823
// if not HasTask ( j ) then
67790: LD_VAR 0 3
67794: PPUSH
67795: CALL_OW 314
67799: NOT
67800: IFFALSE 67821
// ComTameXY ( j , x , y ) ;
67802: LD_VAR 0 3
67806: PPUSH
67807: LD_VAR 0 4
67811: PPUSH
67812: LD_VAR 0 5
67816: PPUSH
67817: CALL_OW 131
// end ; end ;
67821: GO 67486
67823: POP
67824: POP
// end ;
67825: GO 67042
67827: POP
67828: POP
// end ;
67829: LD_VAR 0 1
67833: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
67834: LD_INT 0
67836: PPUSH
67837: PPUSH
67838: PPUSH
67839: PPUSH
67840: PPUSH
67841: PPUSH
67842: PPUSH
67843: PPUSH
// if not mc_bases then
67844: LD_EXP 23
67848: NOT
67849: IFFALSE 67853
// exit ;
67851: GO 68479
// for i = 1 to mc_bases do
67853: LD_ADDR_VAR 0 2
67857: PUSH
67858: DOUBLE
67859: LD_INT 1
67861: DEC
67862: ST_TO_ADDR
67863: LD_EXP 23
67867: PUSH
67868: FOR_TO
67869: IFFALSE 68477
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
67871: LD_EXP 52
67875: PUSH
67876: LD_VAR 0 2
67880: ARRAY
67881: NOT
67882: PUSH
67883: LD_EXP 52
67887: PUSH
67888: LD_VAR 0 2
67892: ARRAY
67893: PPUSH
67894: LD_INT 25
67896: PUSH
67897: LD_INT 12
67899: PUSH
67900: EMPTY
67901: LIST
67902: LIST
67903: PPUSH
67904: CALL_OW 72
67908: NOT
67909: OR
67910: IFFALSE 67914
// continue ;
67912: GO 67868
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
67914: LD_ADDR_VAR 0 5
67918: PUSH
67919: LD_EXP 52
67923: PUSH
67924: LD_VAR 0 2
67928: ARRAY
67929: PUSH
67930: LD_INT 1
67932: ARRAY
67933: PPUSH
67934: CALL_OW 255
67938: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
67939: LD_VAR 0 5
67943: PPUSH
67944: LD_INT 2
67946: PPUSH
67947: CALL_OW 325
67951: IFFALSE 68204
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
67953: LD_ADDR_VAR 0 4
67957: PUSH
67958: LD_EXP 52
67962: PUSH
67963: LD_VAR 0 2
67967: ARRAY
67968: PPUSH
67969: LD_INT 25
67971: PUSH
67972: LD_INT 16
67974: PUSH
67975: EMPTY
67976: LIST
67977: LIST
67978: PPUSH
67979: CALL_OW 72
67983: ST_TO_ADDR
// if tmp < 6 then
67984: LD_VAR 0 4
67988: PUSH
67989: LD_INT 6
67991: LESS
67992: IFFALSE 68204
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67994: LD_ADDR_VAR 0 6
67998: PUSH
67999: LD_EXP 23
68003: PUSH
68004: LD_VAR 0 2
68008: ARRAY
68009: PPUSH
68010: LD_INT 2
68012: PUSH
68013: LD_INT 30
68015: PUSH
68016: LD_INT 0
68018: PUSH
68019: EMPTY
68020: LIST
68021: LIST
68022: PUSH
68023: LD_INT 30
68025: PUSH
68026: LD_INT 1
68028: PUSH
68029: EMPTY
68030: LIST
68031: LIST
68032: PUSH
68033: EMPTY
68034: LIST
68035: LIST
68036: LIST
68037: PPUSH
68038: CALL_OW 72
68042: ST_TO_ADDR
// if depot then
68043: LD_VAR 0 6
68047: IFFALSE 68204
// begin selected := 0 ;
68049: LD_ADDR_VAR 0 7
68053: PUSH
68054: LD_INT 0
68056: ST_TO_ADDR
// for j in depot do
68057: LD_ADDR_VAR 0 3
68061: PUSH
68062: LD_VAR 0 6
68066: PUSH
68067: FOR_IN
68068: IFFALSE 68099
// begin if UnitsInside ( j ) < 6 then
68070: LD_VAR 0 3
68074: PPUSH
68075: CALL_OW 313
68079: PUSH
68080: LD_INT 6
68082: LESS
68083: IFFALSE 68097
// begin selected := j ;
68085: LD_ADDR_VAR 0 7
68089: PUSH
68090: LD_VAR 0 3
68094: ST_TO_ADDR
// break ;
68095: GO 68099
// end ; end ;
68097: GO 68067
68099: POP
68100: POP
// if selected then
68101: LD_VAR 0 7
68105: IFFALSE 68204
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
68107: LD_ADDR_VAR 0 3
68111: PUSH
68112: LD_EXP 52
68116: PUSH
68117: LD_VAR 0 2
68121: ARRAY
68122: PPUSH
68123: LD_INT 25
68125: PUSH
68126: LD_INT 12
68128: PUSH
68129: EMPTY
68130: LIST
68131: LIST
68132: PPUSH
68133: CALL_OW 72
68137: PUSH
68138: FOR_IN
68139: IFFALSE 68202
// if not HasTask ( j ) then
68141: LD_VAR 0 3
68145: PPUSH
68146: CALL_OW 314
68150: NOT
68151: IFFALSE 68200
// begin if not IsInUnit ( j ) then
68153: LD_VAR 0 3
68157: PPUSH
68158: CALL_OW 310
68162: NOT
68163: IFFALSE 68179
// ComEnterUnit ( j , selected ) ;
68165: LD_VAR 0 3
68169: PPUSH
68170: LD_VAR 0 7
68174: PPUSH
68175: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
68179: LD_VAR 0 3
68183: PPUSH
68184: LD_INT 16
68186: PPUSH
68187: CALL_OW 183
// AddComExitBuilding ( j ) ;
68191: LD_VAR 0 3
68195: PPUSH
68196: CALL_OW 182
// end ;
68200: GO 68138
68202: POP
68203: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
68204: LD_VAR 0 5
68208: PPUSH
68209: LD_INT 11
68211: PPUSH
68212: CALL_OW 325
68216: IFFALSE 68475
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
68218: LD_ADDR_VAR 0 4
68222: PUSH
68223: LD_EXP 52
68227: PUSH
68228: LD_VAR 0 2
68232: ARRAY
68233: PPUSH
68234: LD_INT 25
68236: PUSH
68237: LD_INT 16
68239: PUSH
68240: EMPTY
68241: LIST
68242: LIST
68243: PPUSH
68244: CALL_OW 72
68248: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
68249: LD_VAR 0 4
68253: PUSH
68254: LD_INT 6
68256: GREATEREQUAL
68257: PUSH
68258: LD_VAR 0 5
68262: PPUSH
68263: LD_INT 2
68265: PPUSH
68266: CALL_OW 325
68270: NOT
68271: OR
68272: IFFALSE 68475
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
68274: LD_ADDR_VAR 0 8
68278: PUSH
68279: LD_EXP 23
68283: PUSH
68284: LD_VAR 0 2
68288: ARRAY
68289: PPUSH
68290: LD_INT 2
68292: PUSH
68293: LD_INT 30
68295: PUSH
68296: LD_INT 4
68298: PUSH
68299: EMPTY
68300: LIST
68301: LIST
68302: PUSH
68303: LD_INT 30
68305: PUSH
68306: LD_INT 5
68308: PUSH
68309: EMPTY
68310: LIST
68311: LIST
68312: PUSH
68313: EMPTY
68314: LIST
68315: LIST
68316: LIST
68317: PPUSH
68318: CALL_OW 72
68322: ST_TO_ADDR
// if barracks then
68323: LD_VAR 0 8
68327: IFFALSE 68475
// begin selected := 0 ;
68329: LD_ADDR_VAR 0 7
68333: PUSH
68334: LD_INT 0
68336: ST_TO_ADDR
// for j in barracks do
68337: LD_ADDR_VAR 0 3
68341: PUSH
68342: LD_VAR 0 8
68346: PUSH
68347: FOR_IN
68348: IFFALSE 68379
// begin if UnitsInside ( j ) < 6 then
68350: LD_VAR 0 3
68354: PPUSH
68355: CALL_OW 313
68359: PUSH
68360: LD_INT 6
68362: LESS
68363: IFFALSE 68377
// begin selected := j ;
68365: LD_ADDR_VAR 0 7
68369: PUSH
68370: LD_VAR 0 3
68374: ST_TO_ADDR
// break ;
68375: GO 68379
// end ; end ;
68377: GO 68347
68379: POP
68380: POP
// if selected then
68381: LD_VAR 0 7
68385: IFFALSE 68475
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
68387: LD_ADDR_VAR 0 3
68391: PUSH
68392: LD_EXP 52
68396: PUSH
68397: LD_VAR 0 2
68401: ARRAY
68402: PPUSH
68403: LD_INT 25
68405: PUSH
68406: LD_INT 12
68408: PUSH
68409: EMPTY
68410: LIST
68411: LIST
68412: PPUSH
68413: CALL_OW 72
68417: PUSH
68418: FOR_IN
68419: IFFALSE 68473
// if not IsInUnit ( j ) and not HasTask ( j ) then
68421: LD_VAR 0 3
68425: PPUSH
68426: CALL_OW 310
68430: NOT
68431: PUSH
68432: LD_VAR 0 3
68436: PPUSH
68437: CALL_OW 314
68441: NOT
68442: AND
68443: IFFALSE 68471
// begin ComEnterUnit ( j , selected ) ;
68445: LD_VAR 0 3
68449: PPUSH
68450: LD_VAR 0 7
68454: PPUSH
68455: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
68459: LD_VAR 0 3
68463: PPUSH
68464: LD_INT 15
68466: PPUSH
68467: CALL_OW 183
// end ;
68471: GO 68418
68473: POP
68474: POP
// end ; end ; end ; end ; end ;
68475: GO 67868
68477: POP
68478: POP
// end ;
68479: LD_VAR 0 1
68483: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
68484: LD_INT 0
68486: PPUSH
68487: PPUSH
68488: PPUSH
68489: PPUSH
// if not mc_bases then
68490: LD_EXP 23
68494: NOT
68495: IFFALSE 68499
// exit ;
68497: GO 68677
// for i = 1 to mc_bases do
68499: LD_ADDR_VAR 0 2
68503: PUSH
68504: DOUBLE
68505: LD_INT 1
68507: DEC
68508: ST_TO_ADDR
68509: LD_EXP 23
68513: PUSH
68514: FOR_TO
68515: IFFALSE 68675
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
68517: LD_ADDR_VAR 0 4
68521: PUSH
68522: LD_EXP 23
68526: PUSH
68527: LD_VAR 0 2
68531: ARRAY
68532: PPUSH
68533: LD_INT 25
68535: PUSH
68536: LD_INT 9
68538: PUSH
68539: EMPTY
68540: LIST
68541: LIST
68542: PPUSH
68543: CALL_OW 72
68547: ST_TO_ADDR
// if not tmp then
68548: LD_VAR 0 4
68552: NOT
68553: IFFALSE 68557
// continue ;
68555: GO 68514
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
68557: LD_EXP 49
68561: PUSH
68562: LD_VAR 0 2
68566: ARRAY
68567: PPUSH
68568: LD_INT 29
68570: PPUSH
68571: CALL_OW 325
68575: NOT
68576: PUSH
68577: LD_EXP 49
68581: PUSH
68582: LD_VAR 0 2
68586: ARRAY
68587: PPUSH
68588: LD_INT 28
68590: PPUSH
68591: CALL_OW 325
68595: NOT
68596: AND
68597: IFFALSE 68601
// continue ;
68599: GO 68514
// for j in tmp do
68601: LD_ADDR_VAR 0 3
68605: PUSH
68606: LD_VAR 0 4
68610: PUSH
68611: FOR_IN
68612: IFFALSE 68671
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
68614: LD_VAR 0 3
68618: PUSH
68619: LD_EXP 26
68623: PUSH
68624: LD_VAR 0 2
68628: ARRAY
68629: PUSH
68630: LD_INT 1
68632: ARRAY
68633: IN
68634: NOT
68635: PUSH
68636: LD_VAR 0 3
68640: PUSH
68641: LD_EXP 26
68645: PUSH
68646: LD_VAR 0 2
68650: ARRAY
68651: PUSH
68652: LD_INT 2
68654: ARRAY
68655: IN
68656: NOT
68657: AND
68658: IFFALSE 68669
// ComSpaceTimeShoot ( j ) ;
68660: LD_VAR 0 3
68664: PPUSH
68665: CALL 10876 0 1
68669: GO 68611
68671: POP
68672: POP
// end ;
68673: GO 68514
68675: POP
68676: POP
// end ;
68677: LD_VAR 0 1
68681: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
68682: LD_INT 0
68684: PPUSH
68685: PPUSH
68686: PPUSH
68687: PPUSH
68688: PPUSH
68689: PPUSH
68690: PPUSH
68691: PPUSH
68692: PPUSH
// if not mc_bases then
68693: LD_EXP 23
68697: NOT
68698: IFFALSE 68702
// exit ;
68700: GO 69324
// for i = 1 to mc_bases do
68702: LD_ADDR_VAR 0 2
68706: PUSH
68707: DOUBLE
68708: LD_INT 1
68710: DEC
68711: ST_TO_ADDR
68712: LD_EXP 23
68716: PUSH
68717: FOR_TO
68718: IFFALSE 69322
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
68720: LD_EXP 58
68724: PUSH
68725: LD_VAR 0 2
68729: ARRAY
68730: NOT
68731: PUSH
68732: LD_INT 38
68734: PPUSH
68735: LD_EXP 49
68739: PUSH
68740: LD_VAR 0 2
68744: ARRAY
68745: PPUSH
68746: CALL_OW 321
68750: PUSH
68751: LD_INT 2
68753: NONEQUAL
68754: OR
68755: IFFALSE 68759
// continue ;
68757: GO 68717
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
68759: LD_ADDR_VAR 0 8
68763: PUSH
68764: LD_EXP 23
68768: PUSH
68769: LD_VAR 0 2
68773: ARRAY
68774: PPUSH
68775: LD_INT 30
68777: PUSH
68778: LD_INT 34
68780: PUSH
68781: EMPTY
68782: LIST
68783: LIST
68784: PPUSH
68785: CALL_OW 72
68789: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
68790: LD_ADDR_VAR 0 9
68794: PUSH
68795: LD_EXP 23
68799: PUSH
68800: LD_VAR 0 2
68804: ARRAY
68805: PPUSH
68806: LD_INT 25
68808: PUSH
68809: LD_INT 4
68811: PUSH
68812: EMPTY
68813: LIST
68814: LIST
68815: PPUSH
68816: CALL_OW 72
68820: PPUSH
68821: LD_INT 0
68823: PPUSH
68824: CALL 44185 0 2
68828: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
68829: LD_VAR 0 9
68833: NOT
68834: PUSH
68835: LD_VAR 0 8
68839: NOT
68840: OR
68841: PUSH
68842: LD_EXP 23
68846: PUSH
68847: LD_VAR 0 2
68851: ARRAY
68852: PPUSH
68853: LD_INT 124
68855: PPUSH
68856: CALL 44185 0 2
68860: OR
68861: IFFALSE 68865
// continue ;
68863: GO 68717
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
68865: LD_EXP 59
68869: PUSH
68870: LD_VAR 0 2
68874: ARRAY
68875: PUSH
68876: LD_EXP 58
68880: PUSH
68881: LD_VAR 0 2
68885: ARRAY
68886: LESS
68887: PUSH
68888: LD_EXP 59
68892: PUSH
68893: LD_VAR 0 2
68897: ARRAY
68898: PUSH
68899: LD_VAR 0 8
68903: LESS
68904: AND
68905: IFFALSE 69320
// begin tmp := sci [ 1 ] ;
68907: LD_ADDR_VAR 0 7
68911: PUSH
68912: LD_VAR 0 9
68916: PUSH
68917: LD_INT 1
68919: ARRAY
68920: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
68921: LD_VAR 0 7
68925: PPUSH
68926: LD_INT 124
68928: PPUSH
68929: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
68933: LD_ADDR_VAR 0 3
68937: PUSH
68938: DOUBLE
68939: LD_EXP 58
68943: PUSH
68944: LD_VAR 0 2
68948: ARRAY
68949: INC
68950: ST_TO_ADDR
68951: LD_EXP 58
68955: PUSH
68956: LD_VAR 0 2
68960: ARRAY
68961: PUSH
68962: FOR_DOWNTO
68963: IFFALSE 69306
// begin if IsInUnit ( tmp ) then
68965: LD_VAR 0 7
68969: PPUSH
68970: CALL_OW 310
68974: IFFALSE 68985
// ComExitBuilding ( tmp ) ;
68976: LD_VAR 0 7
68980: PPUSH
68981: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
68985: LD_INT 35
68987: PPUSH
68988: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
68992: LD_VAR 0 7
68996: PPUSH
68997: CALL_OW 310
69001: NOT
69002: PUSH
69003: LD_VAR 0 7
69007: PPUSH
69008: CALL_OW 314
69012: NOT
69013: AND
69014: IFFALSE 68985
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
69016: LD_ADDR_VAR 0 6
69020: PUSH
69021: LD_VAR 0 7
69025: PPUSH
69026: CALL_OW 250
69030: PUSH
69031: LD_VAR 0 7
69035: PPUSH
69036: CALL_OW 251
69040: PUSH
69041: EMPTY
69042: LIST
69043: LIST
69044: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
69045: LD_INT 35
69047: PPUSH
69048: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
69052: LD_ADDR_VAR 0 4
69056: PUSH
69057: LD_EXP 58
69061: PUSH
69062: LD_VAR 0 2
69066: ARRAY
69067: PUSH
69068: LD_VAR 0 3
69072: ARRAY
69073: PUSH
69074: LD_INT 1
69076: ARRAY
69077: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
69078: LD_ADDR_VAR 0 5
69082: PUSH
69083: LD_EXP 58
69087: PUSH
69088: LD_VAR 0 2
69092: ARRAY
69093: PUSH
69094: LD_VAR 0 3
69098: ARRAY
69099: PUSH
69100: LD_INT 2
69102: ARRAY
69103: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
69104: LD_VAR 0 7
69108: PPUSH
69109: LD_INT 10
69111: PPUSH
69112: CALL 17514 0 2
69116: PUSH
69117: LD_INT 4
69119: ARRAY
69120: IFFALSE 69158
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
69122: LD_VAR 0 7
69126: PPUSH
69127: LD_VAR 0 6
69131: PUSH
69132: LD_INT 1
69134: ARRAY
69135: PPUSH
69136: LD_VAR 0 6
69140: PUSH
69141: LD_INT 2
69143: ARRAY
69144: PPUSH
69145: CALL_OW 111
// wait ( 0 0$10 ) ;
69149: LD_INT 350
69151: PPUSH
69152: CALL_OW 67
// end else
69156: GO 69184
// begin ComMoveXY ( tmp , x , y ) ;
69158: LD_VAR 0 7
69162: PPUSH
69163: LD_VAR 0 4
69167: PPUSH
69168: LD_VAR 0 5
69172: PPUSH
69173: CALL_OW 111
// wait ( 0 0$3 ) ;
69177: LD_INT 105
69179: PPUSH
69180: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
69184: LD_VAR 0 7
69188: PPUSH
69189: LD_VAR 0 4
69193: PPUSH
69194: LD_VAR 0 5
69198: PPUSH
69199: CALL_OW 307
69203: IFFALSE 69045
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
69205: LD_VAR 0 7
69209: PPUSH
69210: LD_VAR 0 4
69214: PPUSH
69215: LD_VAR 0 5
69219: PPUSH
69220: LD_VAR 0 8
69224: PUSH
69225: LD_VAR 0 3
69229: ARRAY
69230: PPUSH
69231: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
69235: LD_INT 35
69237: PPUSH
69238: CALL_OW 67
// until not HasTask ( tmp ) ;
69242: LD_VAR 0 7
69246: PPUSH
69247: CALL_OW 314
69251: NOT
69252: IFFALSE 69235
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
69254: LD_ADDR_EXP 59
69258: PUSH
69259: LD_EXP 59
69263: PPUSH
69264: LD_VAR 0 2
69268: PUSH
69269: LD_EXP 59
69273: PUSH
69274: LD_VAR 0 2
69278: ARRAY
69279: PUSH
69280: LD_INT 1
69282: PLUS
69283: PUSH
69284: EMPTY
69285: LIST
69286: LIST
69287: PPUSH
69288: LD_VAR 0 8
69292: PUSH
69293: LD_VAR 0 3
69297: ARRAY
69298: PPUSH
69299: CALL 14915 0 3
69303: ST_TO_ADDR
// end ;
69304: GO 68962
69306: POP
69307: POP
// MC_Reset ( i , 124 ) ;
69308: LD_VAR 0 2
69312: PPUSH
69313: LD_INT 124
69315: PPUSH
69316: CALL 52678 0 2
// end ; end ;
69320: GO 68717
69322: POP
69323: POP
// end ;
69324: LD_VAR 0 1
69328: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
69329: LD_INT 0
69331: PPUSH
69332: PPUSH
69333: PPUSH
// if not mc_bases then
69334: LD_EXP 23
69338: NOT
69339: IFFALSE 69343
// exit ;
69341: GO 69949
// for i = 1 to mc_bases do
69343: LD_ADDR_VAR 0 2
69347: PUSH
69348: DOUBLE
69349: LD_INT 1
69351: DEC
69352: ST_TO_ADDR
69353: LD_EXP 23
69357: PUSH
69358: FOR_TO
69359: IFFALSE 69947
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
69361: LD_ADDR_VAR 0 3
69365: PUSH
69366: LD_EXP 23
69370: PUSH
69371: LD_VAR 0 2
69375: ARRAY
69376: PPUSH
69377: LD_INT 25
69379: PUSH
69380: LD_INT 4
69382: PUSH
69383: EMPTY
69384: LIST
69385: LIST
69386: PPUSH
69387: CALL_OW 72
69391: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
69392: LD_VAR 0 3
69396: NOT
69397: PUSH
69398: LD_EXP 60
69402: PUSH
69403: LD_VAR 0 2
69407: ARRAY
69408: NOT
69409: OR
69410: PUSH
69411: LD_EXP 23
69415: PUSH
69416: LD_VAR 0 2
69420: ARRAY
69421: PPUSH
69422: LD_INT 2
69424: PUSH
69425: LD_INT 30
69427: PUSH
69428: LD_INT 0
69430: PUSH
69431: EMPTY
69432: LIST
69433: LIST
69434: PUSH
69435: LD_INT 30
69437: PUSH
69438: LD_INT 1
69440: PUSH
69441: EMPTY
69442: LIST
69443: LIST
69444: PUSH
69445: EMPTY
69446: LIST
69447: LIST
69448: LIST
69449: PPUSH
69450: CALL_OW 72
69454: NOT
69455: OR
69456: IFFALSE 69506
// begin if mc_deposits_finder [ i ] then
69458: LD_EXP 61
69462: PUSH
69463: LD_VAR 0 2
69467: ARRAY
69468: IFFALSE 69504
// begin MC_Reset ( i , 125 ) ;
69470: LD_VAR 0 2
69474: PPUSH
69475: LD_INT 125
69477: PPUSH
69478: CALL 52678 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
69482: LD_ADDR_EXP 61
69486: PUSH
69487: LD_EXP 61
69491: PPUSH
69492: LD_VAR 0 2
69496: PPUSH
69497: EMPTY
69498: PPUSH
69499: CALL_OW 1
69503: ST_TO_ADDR
// end ; continue ;
69504: GO 69358
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
69506: LD_EXP 60
69510: PUSH
69511: LD_VAR 0 2
69515: ARRAY
69516: PUSH
69517: LD_INT 1
69519: ARRAY
69520: PUSH
69521: LD_INT 3
69523: ARRAY
69524: PUSH
69525: LD_INT 1
69527: EQUAL
69528: PUSH
69529: LD_INT 20
69531: PPUSH
69532: LD_EXP 49
69536: PUSH
69537: LD_VAR 0 2
69541: ARRAY
69542: PPUSH
69543: CALL_OW 321
69547: PUSH
69548: LD_INT 2
69550: NONEQUAL
69551: AND
69552: IFFALSE 69602
// begin if mc_deposits_finder [ i ] then
69554: LD_EXP 61
69558: PUSH
69559: LD_VAR 0 2
69563: ARRAY
69564: IFFALSE 69600
// begin MC_Reset ( i , 125 ) ;
69566: LD_VAR 0 2
69570: PPUSH
69571: LD_INT 125
69573: PPUSH
69574: CALL 52678 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
69578: LD_ADDR_EXP 61
69582: PUSH
69583: LD_EXP 61
69587: PPUSH
69588: LD_VAR 0 2
69592: PPUSH
69593: EMPTY
69594: PPUSH
69595: CALL_OW 1
69599: ST_TO_ADDR
// end ; continue ;
69600: GO 69358
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
69602: LD_EXP 60
69606: PUSH
69607: LD_VAR 0 2
69611: ARRAY
69612: PUSH
69613: LD_INT 1
69615: ARRAY
69616: PUSH
69617: LD_INT 1
69619: ARRAY
69620: PPUSH
69621: LD_EXP 60
69625: PUSH
69626: LD_VAR 0 2
69630: ARRAY
69631: PUSH
69632: LD_INT 1
69634: ARRAY
69635: PUSH
69636: LD_INT 2
69638: ARRAY
69639: PPUSH
69640: LD_EXP 49
69644: PUSH
69645: LD_VAR 0 2
69649: ARRAY
69650: PPUSH
69651: CALL_OW 440
69655: IFFALSE 69698
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
69657: LD_ADDR_EXP 60
69661: PUSH
69662: LD_EXP 60
69666: PPUSH
69667: LD_VAR 0 2
69671: PPUSH
69672: LD_EXP 60
69676: PUSH
69677: LD_VAR 0 2
69681: ARRAY
69682: PPUSH
69683: LD_INT 1
69685: PPUSH
69686: CALL_OW 3
69690: PPUSH
69691: CALL_OW 1
69695: ST_TO_ADDR
69696: GO 69945
// begin if not mc_deposits_finder [ i ] then
69698: LD_EXP 61
69702: PUSH
69703: LD_VAR 0 2
69707: ARRAY
69708: NOT
69709: IFFALSE 69761
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
69711: LD_ADDR_EXP 61
69715: PUSH
69716: LD_EXP 61
69720: PPUSH
69721: LD_VAR 0 2
69725: PPUSH
69726: LD_VAR 0 3
69730: PUSH
69731: LD_INT 1
69733: ARRAY
69734: PUSH
69735: EMPTY
69736: LIST
69737: PPUSH
69738: CALL_OW 1
69742: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
69743: LD_VAR 0 3
69747: PUSH
69748: LD_INT 1
69750: ARRAY
69751: PPUSH
69752: LD_INT 125
69754: PPUSH
69755: CALL_OW 109
// end else
69759: GO 69945
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
69761: LD_EXP 61
69765: PUSH
69766: LD_VAR 0 2
69770: ARRAY
69771: PUSH
69772: LD_INT 1
69774: ARRAY
69775: PPUSH
69776: CALL_OW 310
69780: IFFALSE 69803
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
69782: LD_EXP 61
69786: PUSH
69787: LD_VAR 0 2
69791: ARRAY
69792: PUSH
69793: LD_INT 1
69795: ARRAY
69796: PPUSH
69797: CALL_OW 122
69801: GO 69945
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
69803: LD_EXP 61
69807: PUSH
69808: LD_VAR 0 2
69812: ARRAY
69813: PUSH
69814: LD_INT 1
69816: ARRAY
69817: PPUSH
69818: CALL_OW 314
69822: NOT
69823: PUSH
69824: LD_EXP 61
69828: PUSH
69829: LD_VAR 0 2
69833: ARRAY
69834: PUSH
69835: LD_INT 1
69837: ARRAY
69838: PPUSH
69839: LD_EXP 60
69843: PUSH
69844: LD_VAR 0 2
69848: ARRAY
69849: PUSH
69850: LD_INT 1
69852: ARRAY
69853: PUSH
69854: LD_INT 1
69856: ARRAY
69857: PPUSH
69858: LD_EXP 60
69862: PUSH
69863: LD_VAR 0 2
69867: ARRAY
69868: PUSH
69869: LD_INT 1
69871: ARRAY
69872: PUSH
69873: LD_INT 2
69875: ARRAY
69876: PPUSH
69877: CALL_OW 297
69881: PUSH
69882: LD_INT 6
69884: GREATER
69885: AND
69886: IFFALSE 69945
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
69888: LD_EXP 61
69892: PUSH
69893: LD_VAR 0 2
69897: ARRAY
69898: PUSH
69899: LD_INT 1
69901: ARRAY
69902: PPUSH
69903: LD_EXP 60
69907: PUSH
69908: LD_VAR 0 2
69912: ARRAY
69913: PUSH
69914: LD_INT 1
69916: ARRAY
69917: PUSH
69918: LD_INT 1
69920: ARRAY
69921: PPUSH
69922: LD_EXP 60
69926: PUSH
69927: LD_VAR 0 2
69931: ARRAY
69932: PUSH
69933: LD_INT 1
69935: ARRAY
69936: PUSH
69937: LD_INT 2
69939: ARRAY
69940: PPUSH
69941: CALL_OW 111
// end ; end ; end ;
69945: GO 69358
69947: POP
69948: POP
// end ;
69949: LD_VAR 0 1
69953: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
69954: LD_INT 0
69956: PPUSH
69957: PPUSH
69958: PPUSH
69959: PPUSH
69960: PPUSH
69961: PPUSH
69962: PPUSH
69963: PPUSH
69964: PPUSH
69965: PPUSH
69966: PPUSH
// if not mc_bases then
69967: LD_EXP 23
69971: NOT
69972: IFFALSE 69976
// exit ;
69974: GO 70916
// for i = 1 to mc_bases do
69976: LD_ADDR_VAR 0 2
69980: PUSH
69981: DOUBLE
69982: LD_INT 1
69984: DEC
69985: ST_TO_ADDR
69986: LD_EXP 23
69990: PUSH
69991: FOR_TO
69992: IFFALSE 70914
// begin if not mc_bases [ i ] or mc_scan [ i ] then
69994: LD_EXP 23
69998: PUSH
69999: LD_VAR 0 2
70003: ARRAY
70004: NOT
70005: PUSH
70006: LD_EXP 46
70010: PUSH
70011: LD_VAR 0 2
70015: ARRAY
70016: OR
70017: IFFALSE 70021
// continue ;
70019: GO 69991
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
70021: LD_ADDR_VAR 0 7
70025: PUSH
70026: LD_EXP 23
70030: PUSH
70031: LD_VAR 0 2
70035: ARRAY
70036: PUSH
70037: LD_INT 1
70039: ARRAY
70040: PPUSH
70041: CALL_OW 248
70045: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
70046: LD_VAR 0 7
70050: PUSH
70051: LD_INT 3
70053: EQUAL
70054: PUSH
70055: LD_EXP 42
70059: PUSH
70060: LD_VAR 0 2
70064: ARRAY
70065: PUSH
70066: LD_EXP 45
70070: PUSH
70071: LD_VAR 0 2
70075: ARRAY
70076: UNION
70077: PPUSH
70078: LD_INT 33
70080: PUSH
70081: LD_INT 2
70083: PUSH
70084: EMPTY
70085: LIST
70086: LIST
70087: PPUSH
70088: CALL_OW 72
70092: NOT
70093: OR
70094: IFFALSE 70098
// continue ;
70096: GO 69991
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
70098: LD_ADDR_VAR 0 9
70102: PUSH
70103: LD_EXP 23
70107: PUSH
70108: LD_VAR 0 2
70112: ARRAY
70113: PPUSH
70114: LD_INT 30
70116: PUSH
70117: LD_INT 36
70119: PUSH
70120: EMPTY
70121: LIST
70122: LIST
70123: PPUSH
70124: CALL_OW 72
70128: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
70129: LD_ADDR_VAR 0 10
70133: PUSH
70134: LD_EXP 42
70138: PUSH
70139: LD_VAR 0 2
70143: ARRAY
70144: PPUSH
70145: LD_INT 34
70147: PUSH
70148: LD_INT 31
70150: PUSH
70151: EMPTY
70152: LIST
70153: LIST
70154: PPUSH
70155: CALL_OW 72
70159: ST_TO_ADDR
// if not cts and not mcts then
70160: LD_VAR 0 9
70164: NOT
70165: PUSH
70166: LD_VAR 0 10
70170: NOT
70171: AND
70172: IFFALSE 70176
// continue ;
70174: GO 69991
// x := cts ;
70176: LD_ADDR_VAR 0 11
70180: PUSH
70181: LD_VAR 0 9
70185: ST_TO_ADDR
// if not x then
70186: LD_VAR 0 11
70190: NOT
70191: IFFALSE 70203
// x := mcts ;
70193: LD_ADDR_VAR 0 11
70197: PUSH
70198: LD_VAR 0 10
70202: ST_TO_ADDR
// if not x then
70203: LD_VAR 0 11
70207: NOT
70208: IFFALSE 70212
// continue ;
70210: GO 69991
// if mc_remote_driver [ i ] then
70212: LD_EXP 63
70216: PUSH
70217: LD_VAR 0 2
70221: ARRAY
70222: IFFALSE 70609
// for j in mc_remote_driver [ i ] do
70224: LD_ADDR_VAR 0 3
70228: PUSH
70229: LD_EXP 63
70233: PUSH
70234: LD_VAR 0 2
70238: ARRAY
70239: PUSH
70240: FOR_IN
70241: IFFALSE 70607
// begin if GetClass ( j ) <> 3 then
70243: LD_VAR 0 3
70247: PPUSH
70248: CALL_OW 257
70252: PUSH
70253: LD_INT 3
70255: NONEQUAL
70256: IFFALSE 70309
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
70258: LD_ADDR_EXP 63
70262: PUSH
70263: LD_EXP 63
70267: PPUSH
70268: LD_VAR 0 2
70272: PPUSH
70273: LD_EXP 63
70277: PUSH
70278: LD_VAR 0 2
70282: ARRAY
70283: PUSH
70284: LD_VAR 0 3
70288: DIFF
70289: PPUSH
70290: CALL_OW 1
70294: ST_TO_ADDR
// SetTag ( j , 0 ) ;
70295: LD_VAR 0 3
70299: PPUSH
70300: LD_INT 0
70302: PPUSH
70303: CALL_OW 109
// continue ;
70307: GO 70240
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
70309: LD_EXP 42
70313: PUSH
70314: LD_VAR 0 2
70318: ARRAY
70319: PPUSH
70320: LD_INT 34
70322: PUSH
70323: LD_INT 31
70325: PUSH
70326: EMPTY
70327: LIST
70328: LIST
70329: PUSH
70330: LD_INT 58
70332: PUSH
70333: EMPTY
70334: LIST
70335: PUSH
70336: EMPTY
70337: LIST
70338: LIST
70339: PPUSH
70340: CALL_OW 72
70344: PUSH
70345: LD_VAR 0 3
70349: PPUSH
70350: CALL 44273 0 1
70354: NOT
70355: AND
70356: IFFALSE 70427
// begin if IsInUnit ( j ) then
70358: LD_VAR 0 3
70362: PPUSH
70363: CALL_OW 310
70367: IFFALSE 70378
// ComExitBuilding ( j ) ;
70369: LD_VAR 0 3
70373: PPUSH
70374: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
70378: LD_VAR 0 3
70382: PPUSH
70383: LD_EXP 42
70387: PUSH
70388: LD_VAR 0 2
70392: ARRAY
70393: PPUSH
70394: LD_INT 34
70396: PUSH
70397: LD_INT 31
70399: PUSH
70400: EMPTY
70401: LIST
70402: LIST
70403: PUSH
70404: LD_INT 58
70406: PUSH
70407: EMPTY
70408: LIST
70409: PUSH
70410: EMPTY
70411: LIST
70412: LIST
70413: PPUSH
70414: CALL_OW 72
70418: PUSH
70419: LD_INT 1
70421: ARRAY
70422: PPUSH
70423: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
70427: LD_VAR 0 3
70431: PPUSH
70432: CALL_OW 310
70436: NOT
70437: PUSH
70438: LD_VAR 0 3
70442: PPUSH
70443: CALL_OW 310
70447: PPUSH
70448: CALL_OW 266
70452: PUSH
70453: LD_INT 36
70455: NONEQUAL
70456: PUSH
70457: LD_VAR 0 3
70461: PPUSH
70462: CALL 44273 0 1
70466: NOT
70467: AND
70468: OR
70469: IFFALSE 70605
// begin if IsInUnit ( j ) then
70471: LD_VAR 0 3
70475: PPUSH
70476: CALL_OW 310
70480: IFFALSE 70491
// ComExitBuilding ( j ) ;
70482: LD_VAR 0 3
70486: PPUSH
70487: CALL_OW 122
// ct := 0 ;
70491: LD_ADDR_VAR 0 8
70495: PUSH
70496: LD_INT 0
70498: ST_TO_ADDR
// for k in x do
70499: LD_ADDR_VAR 0 4
70503: PUSH
70504: LD_VAR 0 11
70508: PUSH
70509: FOR_IN
70510: IFFALSE 70583
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
70512: LD_VAR 0 4
70516: PPUSH
70517: CALL_OW 264
70521: PUSH
70522: LD_INT 31
70524: EQUAL
70525: PUSH
70526: LD_VAR 0 4
70530: PPUSH
70531: CALL_OW 311
70535: NOT
70536: AND
70537: PUSH
70538: LD_VAR 0 4
70542: PPUSH
70543: CALL_OW 266
70547: PUSH
70548: LD_INT 36
70550: EQUAL
70551: PUSH
70552: LD_VAR 0 4
70556: PPUSH
70557: CALL_OW 313
70561: PUSH
70562: LD_INT 3
70564: LESS
70565: AND
70566: OR
70567: IFFALSE 70581
// begin ct := k ;
70569: LD_ADDR_VAR 0 8
70573: PUSH
70574: LD_VAR 0 4
70578: ST_TO_ADDR
// break ;
70579: GO 70583
// end ;
70581: GO 70509
70583: POP
70584: POP
// if ct then
70585: LD_VAR 0 8
70589: IFFALSE 70605
// ComEnterUnit ( j , ct ) ;
70591: LD_VAR 0 3
70595: PPUSH
70596: LD_VAR 0 8
70600: PPUSH
70601: CALL_OW 120
// end ; end ;
70605: GO 70240
70607: POP
70608: POP
// places := 0 ;
70609: LD_ADDR_VAR 0 5
70613: PUSH
70614: LD_INT 0
70616: ST_TO_ADDR
// for j = 1 to x do
70617: LD_ADDR_VAR 0 3
70621: PUSH
70622: DOUBLE
70623: LD_INT 1
70625: DEC
70626: ST_TO_ADDR
70627: LD_VAR 0 11
70631: PUSH
70632: FOR_TO
70633: IFFALSE 70709
// if GetWeapon ( x [ j ] ) = ar_control_tower then
70635: LD_VAR 0 11
70639: PUSH
70640: LD_VAR 0 3
70644: ARRAY
70645: PPUSH
70646: CALL_OW 264
70650: PUSH
70651: LD_INT 31
70653: EQUAL
70654: IFFALSE 70672
// places := places + 1 else
70656: LD_ADDR_VAR 0 5
70660: PUSH
70661: LD_VAR 0 5
70665: PUSH
70666: LD_INT 1
70668: PLUS
70669: ST_TO_ADDR
70670: GO 70707
// if GetBType ( x [ j ] ) = b_control_tower then
70672: LD_VAR 0 11
70676: PUSH
70677: LD_VAR 0 3
70681: ARRAY
70682: PPUSH
70683: CALL_OW 266
70687: PUSH
70688: LD_INT 36
70690: EQUAL
70691: IFFALSE 70707
// places := places + 3 ;
70693: LD_ADDR_VAR 0 5
70697: PUSH
70698: LD_VAR 0 5
70702: PUSH
70703: LD_INT 3
70705: PLUS
70706: ST_TO_ADDR
70707: GO 70632
70709: POP
70710: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
70711: LD_VAR 0 5
70715: PUSH
70716: LD_INT 0
70718: EQUAL
70719: PUSH
70720: LD_VAR 0 5
70724: PUSH
70725: LD_EXP 63
70729: PUSH
70730: LD_VAR 0 2
70734: ARRAY
70735: LESSEQUAL
70736: OR
70737: IFFALSE 70741
// continue ;
70739: GO 69991
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
70741: LD_ADDR_VAR 0 6
70745: PUSH
70746: LD_EXP 23
70750: PUSH
70751: LD_VAR 0 2
70755: ARRAY
70756: PPUSH
70757: LD_INT 25
70759: PUSH
70760: LD_INT 3
70762: PUSH
70763: EMPTY
70764: LIST
70765: LIST
70766: PPUSH
70767: CALL_OW 72
70771: PUSH
70772: LD_EXP 63
70776: PUSH
70777: LD_VAR 0 2
70781: ARRAY
70782: DIFF
70783: PPUSH
70784: LD_INT 3
70786: PPUSH
70787: CALL 45173 0 2
70791: ST_TO_ADDR
// for j in tmp do
70792: LD_ADDR_VAR 0 3
70796: PUSH
70797: LD_VAR 0 6
70801: PUSH
70802: FOR_IN
70803: IFFALSE 70838
// if GetTag ( j ) > 0 then
70805: LD_VAR 0 3
70809: PPUSH
70810: CALL_OW 110
70814: PUSH
70815: LD_INT 0
70817: GREATER
70818: IFFALSE 70836
// tmp := tmp diff j ;
70820: LD_ADDR_VAR 0 6
70824: PUSH
70825: LD_VAR 0 6
70829: PUSH
70830: LD_VAR 0 3
70834: DIFF
70835: ST_TO_ADDR
70836: GO 70802
70838: POP
70839: POP
// if not tmp then
70840: LD_VAR 0 6
70844: NOT
70845: IFFALSE 70849
// continue ;
70847: GO 69991
// if places then
70849: LD_VAR 0 5
70853: IFFALSE 70912
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
70855: LD_ADDR_EXP 63
70859: PUSH
70860: LD_EXP 63
70864: PPUSH
70865: LD_VAR 0 2
70869: PPUSH
70870: LD_EXP 63
70874: PUSH
70875: LD_VAR 0 2
70879: ARRAY
70880: PUSH
70881: LD_VAR 0 6
70885: PUSH
70886: LD_INT 1
70888: ARRAY
70889: UNION
70890: PPUSH
70891: CALL_OW 1
70895: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
70896: LD_VAR 0 6
70900: PUSH
70901: LD_INT 1
70903: ARRAY
70904: PPUSH
70905: LD_INT 126
70907: PPUSH
70908: CALL_OW 109
// end ; end ;
70912: GO 69991
70914: POP
70915: POP
// end ;
70916: LD_VAR 0 1
70920: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
70921: LD_INT 0
70923: PPUSH
70924: PPUSH
70925: PPUSH
70926: PPUSH
70927: PPUSH
70928: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
70929: LD_VAR 0 1
70933: NOT
70934: PUSH
70935: LD_VAR 0 2
70939: NOT
70940: OR
70941: PUSH
70942: LD_VAR 0 3
70946: NOT
70947: OR
70948: PUSH
70949: LD_VAR 0 4
70953: PUSH
70954: LD_INT 1
70956: PUSH
70957: LD_INT 2
70959: PUSH
70960: LD_INT 3
70962: PUSH
70963: LD_INT 4
70965: PUSH
70966: LD_INT 5
70968: PUSH
70969: LD_INT 8
70971: PUSH
70972: LD_INT 9
70974: PUSH
70975: LD_INT 15
70977: PUSH
70978: LD_INT 16
70980: PUSH
70981: EMPTY
70982: LIST
70983: LIST
70984: LIST
70985: LIST
70986: LIST
70987: LIST
70988: LIST
70989: LIST
70990: LIST
70991: IN
70992: NOT
70993: OR
70994: IFFALSE 70998
// exit ;
70996: GO 71898
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
70998: LD_ADDR_VAR 0 2
71002: PUSH
71003: LD_VAR 0 2
71007: PPUSH
71008: LD_INT 21
71010: PUSH
71011: LD_INT 3
71013: PUSH
71014: EMPTY
71015: LIST
71016: LIST
71017: PUSH
71018: LD_INT 24
71020: PUSH
71021: LD_INT 250
71023: PUSH
71024: EMPTY
71025: LIST
71026: LIST
71027: PUSH
71028: EMPTY
71029: LIST
71030: LIST
71031: PPUSH
71032: CALL_OW 72
71036: ST_TO_ADDR
// case class of 1 , 15 :
71037: LD_VAR 0 4
71041: PUSH
71042: LD_INT 1
71044: DOUBLE
71045: EQUAL
71046: IFTRUE 71056
71048: LD_INT 15
71050: DOUBLE
71051: EQUAL
71052: IFTRUE 71056
71054: GO 71141
71056: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
71057: LD_ADDR_VAR 0 8
71061: PUSH
71062: LD_VAR 0 2
71066: PPUSH
71067: LD_INT 2
71069: PUSH
71070: LD_INT 30
71072: PUSH
71073: LD_INT 32
71075: PUSH
71076: EMPTY
71077: LIST
71078: LIST
71079: PUSH
71080: LD_INT 30
71082: PUSH
71083: LD_INT 31
71085: PUSH
71086: EMPTY
71087: LIST
71088: LIST
71089: PUSH
71090: EMPTY
71091: LIST
71092: LIST
71093: LIST
71094: PPUSH
71095: CALL_OW 72
71099: PUSH
71100: LD_VAR 0 2
71104: PPUSH
71105: LD_INT 2
71107: PUSH
71108: LD_INT 30
71110: PUSH
71111: LD_INT 4
71113: PUSH
71114: EMPTY
71115: LIST
71116: LIST
71117: PUSH
71118: LD_INT 30
71120: PUSH
71121: LD_INT 5
71123: PUSH
71124: EMPTY
71125: LIST
71126: LIST
71127: PUSH
71128: EMPTY
71129: LIST
71130: LIST
71131: LIST
71132: PPUSH
71133: CALL_OW 72
71137: ADD
71138: ST_TO_ADDR
71139: GO 71387
71141: LD_INT 2
71143: DOUBLE
71144: EQUAL
71145: IFTRUE 71155
71147: LD_INT 16
71149: DOUBLE
71150: EQUAL
71151: IFTRUE 71155
71153: GO 71201
71155: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
71156: LD_ADDR_VAR 0 8
71160: PUSH
71161: LD_VAR 0 2
71165: PPUSH
71166: LD_INT 2
71168: PUSH
71169: LD_INT 30
71171: PUSH
71172: LD_INT 0
71174: PUSH
71175: EMPTY
71176: LIST
71177: LIST
71178: PUSH
71179: LD_INT 30
71181: PUSH
71182: LD_INT 1
71184: PUSH
71185: EMPTY
71186: LIST
71187: LIST
71188: PUSH
71189: EMPTY
71190: LIST
71191: LIST
71192: LIST
71193: PPUSH
71194: CALL_OW 72
71198: ST_TO_ADDR
71199: GO 71387
71201: LD_INT 3
71203: DOUBLE
71204: EQUAL
71205: IFTRUE 71209
71207: GO 71255
71209: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
71210: LD_ADDR_VAR 0 8
71214: PUSH
71215: LD_VAR 0 2
71219: PPUSH
71220: LD_INT 2
71222: PUSH
71223: LD_INT 30
71225: PUSH
71226: LD_INT 2
71228: PUSH
71229: EMPTY
71230: LIST
71231: LIST
71232: PUSH
71233: LD_INT 30
71235: PUSH
71236: LD_INT 3
71238: PUSH
71239: EMPTY
71240: LIST
71241: LIST
71242: PUSH
71243: EMPTY
71244: LIST
71245: LIST
71246: LIST
71247: PPUSH
71248: CALL_OW 72
71252: ST_TO_ADDR
71253: GO 71387
71255: LD_INT 4
71257: DOUBLE
71258: EQUAL
71259: IFTRUE 71263
71261: GO 71320
71263: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
71264: LD_ADDR_VAR 0 8
71268: PUSH
71269: LD_VAR 0 2
71273: PPUSH
71274: LD_INT 2
71276: PUSH
71277: LD_INT 30
71279: PUSH
71280: LD_INT 6
71282: PUSH
71283: EMPTY
71284: LIST
71285: LIST
71286: PUSH
71287: LD_INT 30
71289: PUSH
71290: LD_INT 7
71292: PUSH
71293: EMPTY
71294: LIST
71295: LIST
71296: PUSH
71297: LD_INT 30
71299: PUSH
71300: LD_INT 8
71302: PUSH
71303: EMPTY
71304: LIST
71305: LIST
71306: PUSH
71307: EMPTY
71308: LIST
71309: LIST
71310: LIST
71311: LIST
71312: PPUSH
71313: CALL_OW 72
71317: ST_TO_ADDR
71318: GO 71387
71320: LD_INT 5
71322: DOUBLE
71323: EQUAL
71324: IFTRUE 71340
71326: LD_INT 8
71328: DOUBLE
71329: EQUAL
71330: IFTRUE 71340
71332: LD_INT 9
71334: DOUBLE
71335: EQUAL
71336: IFTRUE 71340
71338: GO 71386
71340: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
71341: LD_ADDR_VAR 0 8
71345: PUSH
71346: LD_VAR 0 2
71350: PPUSH
71351: LD_INT 2
71353: PUSH
71354: LD_INT 30
71356: PUSH
71357: LD_INT 4
71359: PUSH
71360: EMPTY
71361: LIST
71362: LIST
71363: PUSH
71364: LD_INT 30
71366: PUSH
71367: LD_INT 5
71369: PUSH
71370: EMPTY
71371: LIST
71372: LIST
71373: PUSH
71374: EMPTY
71375: LIST
71376: LIST
71377: LIST
71378: PPUSH
71379: CALL_OW 72
71383: ST_TO_ADDR
71384: GO 71387
71386: POP
// if not tmp then
71387: LD_VAR 0 8
71391: NOT
71392: IFFALSE 71396
// exit ;
71394: GO 71898
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
71396: LD_VAR 0 4
71400: PUSH
71401: LD_INT 1
71403: PUSH
71404: LD_INT 15
71406: PUSH
71407: EMPTY
71408: LIST
71409: LIST
71410: IN
71411: PUSH
71412: LD_EXP 32
71416: PUSH
71417: LD_VAR 0 1
71421: ARRAY
71422: AND
71423: IFFALSE 71579
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
71425: LD_ADDR_VAR 0 9
71429: PUSH
71430: LD_EXP 32
71434: PUSH
71435: LD_VAR 0 1
71439: ARRAY
71440: PUSH
71441: LD_INT 1
71443: ARRAY
71444: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
71445: LD_VAR 0 9
71449: PUSH
71450: LD_EXP 33
71454: PUSH
71455: LD_VAR 0 1
71459: ARRAY
71460: IN
71461: NOT
71462: IFFALSE 71577
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
71464: LD_ADDR_EXP 33
71468: PUSH
71469: LD_EXP 33
71473: PPUSH
71474: LD_VAR 0 1
71478: PUSH
71479: LD_EXP 33
71483: PUSH
71484: LD_VAR 0 1
71488: ARRAY
71489: PUSH
71490: LD_INT 1
71492: PLUS
71493: PUSH
71494: EMPTY
71495: LIST
71496: LIST
71497: PPUSH
71498: LD_VAR 0 9
71502: PPUSH
71503: CALL 14915 0 3
71507: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
71508: LD_ADDR_EXP 32
71512: PUSH
71513: LD_EXP 32
71517: PPUSH
71518: LD_VAR 0 1
71522: PPUSH
71523: LD_EXP 32
71527: PUSH
71528: LD_VAR 0 1
71532: ARRAY
71533: PUSH
71534: LD_VAR 0 9
71538: DIFF
71539: PPUSH
71540: CALL_OW 1
71544: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
71545: LD_VAR 0 3
71549: PPUSH
71550: LD_EXP 33
71554: PUSH
71555: LD_VAR 0 1
71559: ARRAY
71560: PUSH
71561: LD_EXP 33
71565: PUSH
71566: LD_VAR 0 1
71570: ARRAY
71571: ARRAY
71572: PPUSH
71573: CALL_OW 120
// end ; exit ;
71577: GO 71898
// end ; if tmp > 1 then
71579: LD_VAR 0 8
71583: PUSH
71584: LD_INT 1
71586: GREATER
71587: IFFALSE 71691
// for i = 2 to tmp do
71589: LD_ADDR_VAR 0 6
71593: PUSH
71594: DOUBLE
71595: LD_INT 2
71597: DEC
71598: ST_TO_ADDR
71599: LD_VAR 0 8
71603: PUSH
71604: FOR_TO
71605: IFFALSE 71689
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
71607: LD_VAR 0 8
71611: PUSH
71612: LD_VAR 0 6
71616: ARRAY
71617: PPUSH
71618: CALL_OW 461
71622: PUSH
71623: LD_INT 6
71625: EQUAL
71626: IFFALSE 71687
// begin x := tmp [ i ] ;
71628: LD_ADDR_VAR 0 9
71632: PUSH
71633: LD_VAR 0 8
71637: PUSH
71638: LD_VAR 0 6
71642: ARRAY
71643: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
71644: LD_ADDR_VAR 0 8
71648: PUSH
71649: LD_VAR 0 8
71653: PPUSH
71654: LD_VAR 0 6
71658: PPUSH
71659: CALL_OW 3
71663: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
71664: LD_ADDR_VAR 0 8
71668: PUSH
71669: LD_VAR 0 8
71673: PPUSH
71674: LD_INT 1
71676: PPUSH
71677: LD_VAR 0 9
71681: PPUSH
71682: CALL_OW 2
71686: ST_TO_ADDR
// end ;
71687: GO 71604
71689: POP
71690: POP
// for i in tmp do
71691: LD_ADDR_VAR 0 6
71695: PUSH
71696: LD_VAR 0 8
71700: PUSH
71701: FOR_IN
71702: IFFALSE 71771
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
71704: LD_VAR 0 6
71708: PPUSH
71709: CALL_OW 313
71713: PUSH
71714: LD_INT 6
71716: LESS
71717: PUSH
71718: LD_VAR 0 6
71722: PPUSH
71723: CALL_OW 266
71727: PUSH
71728: LD_INT 31
71730: PUSH
71731: LD_INT 32
71733: PUSH
71734: EMPTY
71735: LIST
71736: LIST
71737: IN
71738: NOT
71739: AND
71740: PUSH
71741: LD_VAR 0 6
71745: PPUSH
71746: CALL_OW 313
71750: PUSH
71751: LD_INT 0
71753: EQUAL
71754: OR
71755: IFFALSE 71769
// begin j := i ;
71757: LD_ADDR_VAR 0 7
71761: PUSH
71762: LD_VAR 0 6
71766: ST_TO_ADDR
// break ;
71767: GO 71771
// end ; end ;
71769: GO 71701
71771: POP
71772: POP
// if j then
71773: LD_VAR 0 7
71777: IFFALSE 71795
// ComEnterUnit ( unit , j ) else
71779: LD_VAR 0 3
71783: PPUSH
71784: LD_VAR 0 7
71788: PPUSH
71789: CALL_OW 120
71793: GO 71898
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71795: LD_ADDR_VAR 0 10
71799: PUSH
71800: LD_VAR 0 2
71804: PPUSH
71805: LD_INT 2
71807: PUSH
71808: LD_INT 30
71810: PUSH
71811: LD_INT 0
71813: PUSH
71814: EMPTY
71815: LIST
71816: LIST
71817: PUSH
71818: LD_INT 30
71820: PUSH
71821: LD_INT 1
71823: PUSH
71824: EMPTY
71825: LIST
71826: LIST
71827: PUSH
71828: EMPTY
71829: LIST
71830: LIST
71831: LIST
71832: PPUSH
71833: CALL_OW 72
71837: ST_TO_ADDR
// if depot then
71838: LD_VAR 0 10
71842: IFFALSE 71898
// begin depot := NearestUnitToUnit ( depot , unit ) ;
71844: LD_ADDR_VAR 0 10
71848: PUSH
71849: LD_VAR 0 10
71853: PPUSH
71854: LD_VAR 0 3
71858: PPUSH
71859: CALL_OW 74
71863: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
71864: LD_VAR 0 3
71868: PPUSH
71869: LD_VAR 0 10
71873: PPUSH
71874: CALL_OW 296
71878: PUSH
71879: LD_INT 10
71881: GREATER
71882: IFFALSE 71898
// ComStandNearbyBuilding ( unit , depot ) ;
71884: LD_VAR 0 3
71888: PPUSH
71889: LD_VAR 0 10
71893: PPUSH
71894: CALL 11493 0 2
// end ; end ; end ;
71898: LD_VAR 0 5
71902: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
71903: LD_INT 0
71905: PPUSH
71906: PPUSH
71907: PPUSH
71908: PPUSH
// if not mc_bases then
71909: LD_EXP 23
71913: NOT
71914: IFFALSE 71918
// exit ;
71916: GO 72157
// for i = 1 to mc_bases do
71918: LD_ADDR_VAR 0 2
71922: PUSH
71923: DOUBLE
71924: LD_INT 1
71926: DEC
71927: ST_TO_ADDR
71928: LD_EXP 23
71932: PUSH
71933: FOR_TO
71934: IFFALSE 72155
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
71936: LD_ADDR_VAR 0 4
71940: PUSH
71941: LD_EXP 23
71945: PUSH
71946: LD_VAR 0 2
71950: ARRAY
71951: PPUSH
71952: LD_INT 21
71954: PUSH
71955: LD_INT 1
71957: PUSH
71958: EMPTY
71959: LIST
71960: LIST
71961: PPUSH
71962: CALL_OW 72
71966: PUSH
71967: LD_EXP 52
71971: PUSH
71972: LD_VAR 0 2
71976: ARRAY
71977: UNION
71978: ST_TO_ADDR
// if not tmp then
71979: LD_VAR 0 4
71983: NOT
71984: IFFALSE 71988
// continue ;
71986: GO 71933
// for j in tmp do
71988: LD_ADDR_VAR 0 3
71992: PUSH
71993: LD_VAR 0 4
71997: PUSH
71998: FOR_IN
71999: IFFALSE 72151
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
72001: LD_VAR 0 3
72005: PPUSH
72006: CALL_OW 110
72010: NOT
72011: PUSH
72012: LD_VAR 0 3
72016: PPUSH
72017: CALL_OW 314
72021: NOT
72022: AND
72023: PUSH
72024: LD_VAR 0 3
72028: PPUSH
72029: CALL_OW 311
72033: NOT
72034: AND
72035: PUSH
72036: LD_VAR 0 3
72040: PPUSH
72041: CALL_OW 310
72045: NOT
72046: AND
72047: PUSH
72048: LD_VAR 0 3
72052: PUSH
72053: LD_EXP 26
72057: PUSH
72058: LD_VAR 0 2
72062: ARRAY
72063: PUSH
72064: LD_INT 1
72066: ARRAY
72067: IN
72068: NOT
72069: AND
72070: PUSH
72071: LD_VAR 0 3
72075: PUSH
72076: LD_EXP 26
72080: PUSH
72081: LD_VAR 0 2
72085: ARRAY
72086: PUSH
72087: LD_INT 2
72089: ARRAY
72090: IN
72091: NOT
72092: AND
72093: PUSH
72094: LD_VAR 0 3
72098: PUSH
72099: LD_EXP 35
72103: PUSH
72104: LD_VAR 0 2
72108: ARRAY
72109: IN
72110: NOT
72111: AND
72112: IFFALSE 72149
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
72114: LD_VAR 0 2
72118: PPUSH
72119: LD_EXP 23
72123: PUSH
72124: LD_VAR 0 2
72128: ARRAY
72129: PPUSH
72130: LD_VAR 0 3
72134: PPUSH
72135: LD_VAR 0 3
72139: PPUSH
72140: CALL_OW 257
72144: PPUSH
72145: CALL 70921 0 4
// end ;
72149: GO 71998
72151: POP
72152: POP
// end ;
72153: GO 71933
72155: POP
72156: POP
// end ;
72157: LD_VAR 0 1
72161: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
72162: LD_INT 0
72164: PPUSH
72165: PPUSH
72166: PPUSH
72167: PPUSH
72168: PPUSH
72169: PPUSH
// if not mc_bases [ base ] then
72170: LD_EXP 23
72174: PUSH
72175: LD_VAR 0 1
72179: ARRAY
72180: NOT
72181: IFFALSE 72185
// exit ;
72183: GO 72367
// tmp := [ ] ;
72185: LD_ADDR_VAR 0 6
72189: PUSH
72190: EMPTY
72191: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
72192: LD_ADDR_VAR 0 7
72196: PUSH
72197: LD_VAR 0 3
72201: PPUSH
72202: LD_INT 0
72204: PPUSH
72205: CALL_OW 517
72209: ST_TO_ADDR
// if not list then
72210: LD_VAR 0 7
72214: NOT
72215: IFFALSE 72219
// exit ;
72217: GO 72367
// for i = 1 to amount do
72219: LD_ADDR_VAR 0 5
72223: PUSH
72224: DOUBLE
72225: LD_INT 1
72227: DEC
72228: ST_TO_ADDR
72229: LD_VAR 0 2
72233: PUSH
72234: FOR_TO
72235: IFFALSE 72315
// begin x := rand ( 1 , list [ 1 ] ) ;
72237: LD_ADDR_VAR 0 8
72241: PUSH
72242: LD_INT 1
72244: PPUSH
72245: LD_VAR 0 7
72249: PUSH
72250: LD_INT 1
72252: ARRAY
72253: PPUSH
72254: CALL_OW 12
72258: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
72259: LD_ADDR_VAR 0 6
72263: PUSH
72264: LD_VAR 0 6
72268: PPUSH
72269: LD_VAR 0 5
72273: PPUSH
72274: LD_VAR 0 7
72278: PUSH
72279: LD_INT 1
72281: ARRAY
72282: PUSH
72283: LD_VAR 0 8
72287: ARRAY
72288: PUSH
72289: LD_VAR 0 7
72293: PUSH
72294: LD_INT 2
72296: ARRAY
72297: PUSH
72298: LD_VAR 0 8
72302: ARRAY
72303: PUSH
72304: EMPTY
72305: LIST
72306: LIST
72307: PPUSH
72308: CALL_OW 1
72312: ST_TO_ADDR
// end ;
72313: GO 72234
72315: POP
72316: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
72317: LD_ADDR_EXP 36
72321: PUSH
72322: LD_EXP 36
72326: PPUSH
72327: LD_VAR 0 1
72331: PPUSH
72332: LD_VAR 0 6
72336: PPUSH
72337: CALL_OW 1
72341: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
72342: LD_ADDR_EXP 38
72346: PUSH
72347: LD_EXP 38
72351: PPUSH
72352: LD_VAR 0 1
72356: PPUSH
72357: LD_VAR 0 3
72361: PPUSH
72362: CALL_OW 1
72366: ST_TO_ADDR
// end ;
72367: LD_VAR 0 4
72371: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
72372: LD_INT 0
72374: PPUSH
// if not mc_bases [ base ] then
72375: LD_EXP 23
72379: PUSH
72380: LD_VAR 0 1
72384: ARRAY
72385: NOT
72386: IFFALSE 72390
// exit ;
72388: GO 72415
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
72390: LD_ADDR_EXP 28
72394: PUSH
72395: LD_EXP 28
72399: PPUSH
72400: LD_VAR 0 1
72404: PPUSH
72405: LD_VAR 0 2
72409: PPUSH
72410: CALL_OW 1
72414: ST_TO_ADDR
// end ;
72415: LD_VAR 0 3
72419: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
72420: LD_INT 0
72422: PPUSH
// if not mc_bases [ base ] then
72423: LD_EXP 23
72427: PUSH
72428: LD_VAR 0 1
72432: ARRAY
72433: NOT
72434: IFFALSE 72438
// exit ;
72436: GO 72475
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
72438: LD_ADDR_EXP 28
72442: PUSH
72443: LD_EXP 28
72447: PPUSH
72448: LD_VAR 0 1
72452: PPUSH
72453: LD_EXP 28
72457: PUSH
72458: LD_VAR 0 1
72462: ARRAY
72463: PUSH
72464: LD_VAR 0 2
72468: UNION
72469: PPUSH
72470: CALL_OW 1
72474: ST_TO_ADDR
// end ;
72475: LD_VAR 0 3
72479: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
72480: LD_INT 0
72482: PPUSH
// if not mc_bases [ base ] then
72483: LD_EXP 23
72487: PUSH
72488: LD_VAR 0 1
72492: ARRAY
72493: NOT
72494: IFFALSE 72498
// exit ;
72496: GO 72523
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
72498: LD_ADDR_EXP 44
72502: PUSH
72503: LD_EXP 44
72507: PPUSH
72508: LD_VAR 0 1
72512: PPUSH
72513: LD_VAR 0 2
72517: PPUSH
72518: CALL_OW 1
72522: ST_TO_ADDR
// end ;
72523: LD_VAR 0 3
72527: RET
// export function MC_InsertProduceList ( base , components ) ; begin
72528: LD_INT 0
72530: PPUSH
// if not mc_bases [ base ] then
72531: LD_EXP 23
72535: PUSH
72536: LD_VAR 0 1
72540: ARRAY
72541: NOT
72542: IFFALSE 72546
// exit ;
72544: GO 72583
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
72546: LD_ADDR_EXP 44
72550: PUSH
72551: LD_EXP 44
72555: PPUSH
72556: LD_VAR 0 1
72560: PPUSH
72561: LD_EXP 44
72565: PUSH
72566: LD_VAR 0 1
72570: ARRAY
72571: PUSH
72572: LD_VAR 0 2
72576: ADD
72577: PPUSH
72578: CALL_OW 1
72582: ST_TO_ADDR
// end ;
72583: LD_VAR 0 3
72587: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
72588: LD_INT 0
72590: PPUSH
// if not mc_bases [ base ] then
72591: LD_EXP 23
72595: PUSH
72596: LD_VAR 0 1
72600: ARRAY
72601: NOT
72602: IFFALSE 72606
// exit ;
72604: GO 72660
// mc_defender := Replace ( mc_defender , base , deflist ) ;
72606: LD_ADDR_EXP 45
72610: PUSH
72611: LD_EXP 45
72615: PPUSH
72616: LD_VAR 0 1
72620: PPUSH
72621: LD_VAR 0 2
72625: PPUSH
72626: CALL_OW 1
72630: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
72631: LD_ADDR_EXP 34
72635: PUSH
72636: LD_EXP 34
72640: PPUSH
72641: LD_VAR 0 1
72645: PPUSH
72646: LD_VAR 0 2
72650: PUSH
72651: LD_INT 0
72653: PLUS
72654: PPUSH
72655: CALL_OW 1
72659: ST_TO_ADDR
// end ;
72660: LD_VAR 0 3
72664: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
72665: LD_INT 0
72667: PPUSH
// if not mc_bases [ base ] then
72668: LD_EXP 23
72672: PUSH
72673: LD_VAR 0 1
72677: ARRAY
72678: NOT
72679: IFFALSE 72683
// exit ;
72681: GO 72708
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
72683: LD_ADDR_EXP 34
72687: PUSH
72688: LD_EXP 34
72692: PPUSH
72693: LD_VAR 0 1
72697: PPUSH
72698: LD_VAR 0 2
72702: PPUSH
72703: CALL_OW 1
72707: ST_TO_ADDR
// end ;
72708: LD_VAR 0 3
72712: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
72713: LD_INT 0
72715: PPUSH
72716: PPUSH
72717: PPUSH
72718: PPUSH
// if not mc_bases [ base ] then
72719: LD_EXP 23
72723: PUSH
72724: LD_VAR 0 1
72728: ARRAY
72729: NOT
72730: IFFALSE 72734
// exit ;
72732: GO 72799
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
72734: LD_ADDR_EXP 43
72738: PUSH
72739: LD_EXP 43
72743: PPUSH
72744: LD_VAR 0 1
72748: PUSH
72749: LD_EXP 43
72753: PUSH
72754: LD_VAR 0 1
72758: ARRAY
72759: PUSH
72760: LD_INT 1
72762: PLUS
72763: PUSH
72764: EMPTY
72765: LIST
72766: LIST
72767: PPUSH
72768: LD_VAR 0 1
72772: PUSH
72773: LD_VAR 0 2
72777: PUSH
72778: LD_VAR 0 3
72782: PUSH
72783: LD_VAR 0 4
72787: PUSH
72788: EMPTY
72789: LIST
72790: LIST
72791: LIST
72792: LIST
72793: PPUSH
72794: CALL 14915 0 3
72798: ST_TO_ADDR
// end ;
72799: LD_VAR 0 5
72803: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
72804: LD_INT 0
72806: PPUSH
// if not mc_bases [ base ] then
72807: LD_EXP 23
72811: PUSH
72812: LD_VAR 0 1
72816: ARRAY
72817: NOT
72818: IFFALSE 72822
// exit ;
72820: GO 72847
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
72822: LD_ADDR_EXP 60
72826: PUSH
72827: LD_EXP 60
72831: PPUSH
72832: LD_VAR 0 1
72836: PPUSH
72837: LD_VAR 0 2
72841: PPUSH
72842: CALL_OW 1
72846: ST_TO_ADDR
// end ;
72847: LD_VAR 0 3
72851: RET
// export function MC_GetMinesField ( base ) ; begin
72852: LD_INT 0
72854: PPUSH
// result := mc_mines [ base ] ;
72855: LD_ADDR_VAR 0 2
72859: PUSH
72860: LD_EXP 36
72864: PUSH
72865: LD_VAR 0 1
72869: ARRAY
72870: ST_TO_ADDR
// end ;
72871: LD_VAR 0 2
72875: RET
// export function MC_GetProduceList ( base ) ; begin
72876: LD_INT 0
72878: PPUSH
// result := mc_produce [ base ] ;
72879: LD_ADDR_VAR 0 2
72883: PUSH
72884: LD_EXP 44
72888: PUSH
72889: LD_VAR 0 1
72893: ARRAY
72894: ST_TO_ADDR
// end ;
72895: LD_VAR 0 2
72899: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
72900: LD_INT 0
72902: PPUSH
72903: PPUSH
// if not mc_bases then
72904: LD_EXP 23
72908: NOT
72909: IFFALSE 72913
// exit ;
72911: GO 72978
// if mc_bases [ base ] then
72913: LD_EXP 23
72917: PUSH
72918: LD_VAR 0 1
72922: ARRAY
72923: IFFALSE 72978
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
72925: LD_ADDR_VAR 0 3
72929: PUSH
72930: LD_EXP 23
72934: PUSH
72935: LD_VAR 0 1
72939: ARRAY
72940: PPUSH
72941: LD_INT 30
72943: PUSH
72944: LD_VAR 0 2
72948: PUSH
72949: EMPTY
72950: LIST
72951: LIST
72952: PPUSH
72953: CALL_OW 72
72957: ST_TO_ADDR
// if result then
72958: LD_VAR 0 3
72962: IFFALSE 72978
// result := result [ 1 ] ;
72964: LD_ADDR_VAR 0 3
72968: PUSH
72969: LD_VAR 0 3
72973: PUSH
72974: LD_INT 1
72976: ARRAY
72977: ST_TO_ADDR
// end ; end ;
72978: LD_VAR 0 3
72982: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
72983: LD_INT 0
72985: PPUSH
72986: PPUSH
// if not mc_bases then
72987: LD_EXP 23
72991: NOT
72992: IFFALSE 72996
// exit ;
72994: GO 73041
// if mc_bases [ base ] then
72996: LD_EXP 23
73000: PUSH
73001: LD_VAR 0 1
73005: ARRAY
73006: IFFALSE 73041
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
73008: LD_ADDR_VAR 0 3
73012: PUSH
73013: LD_EXP 23
73017: PUSH
73018: LD_VAR 0 1
73022: ARRAY
73023: PPUSH
73024: LD_INT 30
73026: PUSH
73027: LD_VAR 0 2
73031: PUSH
73032: EMPTY
73033: LIST
73034: LIST
73035: PPUSH
73036: CALL_OW 72
73040: ST_TO_ADDR
// end ;
73041: LD_VAR 0 3
73045: RET
// export function MC_SetTame ( base , area ) ; begin
73046: LD_INT 0
73048: PPUSH
// if not mc_bases or not base then
73049: LD_EXP 23
73053: NOT
73054: PUSH
73055: LD_VAR 0 1
73059: NOT
73060: OR
73061: IFFALSE 73065
// exit ;
73063: GO 73090
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
73065: LD_ADDR_EXP 51
73069: PUSH
73070: LD_EXP 51
73074: PPUSH
73075: LD_VAR 0 1
73079: PPUSH
73080: LD_VAR 0 2
73084: PPUSH
73085: CALL_OW 1
73089: ST_TO_ADDR
// end ;
73090: LD_VAR 0 3
73094: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
73095: LD_INT 0
73097: PPUSH
73098: PPUSH
// if not mc_bases or not base then
73099: LD_EXP 23
73103: NOT
73104: PUSH
73105: LD_VAR 0 1
73109: NOT
73110: OR
73111: IFFALSE 73115
// exit ;
73113: GO 73217
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
73115: LD_ADDR_VAR 0 4
73119: PUSH
73120: LD_EXP 23
73124: PUSH
73125: LD_VAR 0 1
73129: ARRAY
73130: PPUSH
73131: LD_INT 30
73133: PUSH
73134: LD_VAR 0 2
73138: PUSH
73139: EMPTY
73140: LIST
73141: LIST
73142: PPUSH
73143: CALL_OW 72
73147: ST_TO_ADDR
// if not tmp then
73148: LD_VAR 0 4
73152: NOT
73153: IFFALSE 73157
// exit ;
73155: GO 73217
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
73157: LD_ADDR_EXP 55
73161: PUSH
73162: LD_EXP 55
73166: PPUSH
73167: LD_VAR 0 1
73171: PPUSH
73172: LD_EXP 55
73176: PUSH
73177: LD_VAR 0 1
73181: ARRAY
73182: PPUSH
73183: LD_EXP 55
73187: PUSH
73188: LD_VAR 0 1
73192: ARRAY
73193: PUSH
73194: LD_INT 1
73196: PLUS
73197: PPUSH
73198: LD_VAR 0 4
73202: PUSH
73203: LD_INT 1
73205: ARRAY
73206: PPUSH
73207: CALL_OW 2
73211: PPUSH
73212: CALL_OW 1
73216: ST_TO_ADDR
// end ;
73217: LD_VAR 0 3
73221: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
73222: LD_INT 0
73224: PPUSH
73225: PPUSH
// if not mc_bases or not base or not kinds then
73226: LD_EXP 23
73230: NOT
73231: PUSH
73232: LD_VAR 0 1
73236: NOT
73237: OR
73238: PUSH
73239: LD_VAR 0 2
73243: NOT
73244: OR
73245: IFFALSE 73249
// exit ;
73247: GO 73310
// for i in kinds do
73249: LD_ADDR_VAR 0 4
73253: PUSH
73254: LD_VAR 0 2
73258: PUSH
73259: FOR_IN
73260: IFFALSE 73308
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
73262: LD_ADDR_EXP 57
73266: PUSH
73267: LD_EXP 57
73271: PPUSH
73272: LD_VAR 0 1
73276: PUSH
73277: LD_EXP 57
73281: PUSH
73282: LD_VAR 0 1
73286: ARRAY
73287: PUSH
73288: LD_INT 1
73290: PLUS
73291: PUSH
73292: EMPTY
73293: LIST
73294: LIST
73295: PPUSH
73296: LD_VAR 0 4
73300: PPUSH
73301: CALL 14915 0 3
73305: ST_TO_ADDR
73306: GO 73259
73308: POP
73309: POP
// end ;
73310: LD_VAR 0 3
73314: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
73315: LD_INT 0
73317: PPUSH
// if not mc_bases or not base or not areas then
73318: LD_EXP 23
73322: NOT
73323: PUSH
73324: LD_VAR 0 1
73328: NOT
73329: OR
73330: PUSH
73331: LD_VAR 0 2
73335: NOT
73336: OR
73337: IFFALSE 73341
// exit ;
73339: GO 73366
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
73341: LD_ADDR_EXP 41
73345: PUSH
73346: LD_EXP 41
73350: PPUSH
73351: LD_VAR 0 1
73355: PPUSH
73356: LD_VAR 0 2
73360: PPUSH
73361: CALL_OW 1
73365: ST_TO_ADDR
// end ;
73366: LD_VAR 0 3
73370: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
73371: LD_INT 0
73373: PPUSH
// if not mc_bases or not base or not teleports_exit then
73374: LD_EXP 23
73378: NOT
73379: PUSH
73380: LD_VAR 0 1
73384: NOT
73385: OR
73386: PUSH
73387: LD_VAR 0 2
73391: NOT
73392: OR
73393: IFFALSE 73397
// exit ;
73395: GO 73422
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
73397: LD_ADDR_EXP 58
73401: PUSH
73402: LD_EXP 58
73406: PPUSH
73407: LD_VAR 0 1
73411: PPUSH
73412: LD_VAR 0 2
73416: PPUSH
73417: CALL_OW 1
73421: ST_TO_ADDR
// end ;
73422: LD_VAR 0 3
73426: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
73427: LD_INT 0
73429: PPUSH
73430: PPUSH
73431: PPUSH
// if not mc_bases or not base or not ext_list then
73432: LD_EXP 23
73436: NOT
73437: PUSH
73438: LD_VAR 0 1
73442: NOT
73443: OR
73444: PUSH
73445: LD_VAR 0 5
73449: NOT
73450: OR
73451: IFFALSE 73455
// exit ;
73453: GO 73628
// tmp := GetFacExtXYD ( x , y , d ) ;
73455: LD_ADDR_VAR 0 8
73459: PUSH
73460: LD_VAR 0 2
73464: PPUSH
73465: LD_VAR 0 3
73469: PPUSH
73470: LD_VAR 0 4
73474: PPUSH
73475: CALL 44303 0 3
73479: ST_TO_ADDR
// if not tmp then
73480: LD_VAR 0 8
73484: NOT
73485: IFFALSE 73489
// exit ;
73487: GO 73628
// for i in tmp do
73489: LD_ADDR_VAR 0 7
73493: PUSH
73494: LD_VAR 0 8
73498: PUSH
73499: FOR_IN
73500: IFFALSE 73626
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
73502: LD_ADDR_EXP 28
73506: PUSH
73507: LD_EXP 28
73511: PPUSH
73512: LD_VAR 0 1
73516: PPUSH
73517: LD_EXP 28
73521: PUSH
73522: LD_VAR 0 1
73526: ARRAY
73527: PPUSH
73528: LD_EXP 28
73532: PUSH
73533: LD_VAR 0 1
73537: ARRAY
73538: PUSH
73539: LD_INT 1
73541: PLUS
73542: PPUSH
73543: LD_VAR 0 5
73547: PUSH
73548: LD_INT 1
73550: ARRAY
73551: PUSH
73552: LD_VAR 0 7
73556: PUSH
73557: LD_INT 1
73559: ARRAY
73560: PUSH
73561: LD_VAR 0 7
73565: PUSH
73566: LD_INT 2
73568: ARRAY
73569: PUSH
73570: LD_VAR 0 7
73574: PUSH
73575: LD_INT 3
73577: ARRAY
73578: PUSH
73579: EMPTY
73580: LIST
73581: LIST
73582: LIST
73583: LIST
73584: PPUSH
73585: CALL_OW 2
73589: PPUSH
73590: CALL_OW 1
73594: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
73595: LD_ADDR_VAR 0 5
73599: PUSH
73600: LD_VAR 0 5
73604: PPUSH
73605: LD_INT 1
73607: PPUSH
73608: CALL_OW 3
73612: ST_TO_ADDR
// if not ext_list then
73613: LD_VAR 0 5
73617: NOT
73618: IFFALSE 73624
// exit ;
73620: POP
73621: POP
73622: GO 73628
// end ;
73624: GO 73499
73626: POP
73627: POP
// end ;
73628: LD_VAR 0 6
73632: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
73633: LD_INT 0
73635: PPUSH
// if not mc_bases or not base or not weapon_list then
73636: LD_EXP 23
73640: NOT
73641: PUSH
73642: LD_VAR 0 1
73646: NOT
73647: OR
73648: PUSH
73649: LD_VAR 0 2
73653: NOT
73654: OR
73655: IFFALSE 73659
// exit ;
73657: GO 73684
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
73659: LD_ADDR_EXP 62
73663: PUSH
73664: LD_EXP 62
73668: PPUSH
73669: LD_VAR 0 1
73673: PPUSH
73674: LD_VAR 0 2
73678: PPUSH
73679: CALL_OW 1
73683: ST_TO_ADDR
// end ;
73684: LD_VAR 0 3
73688: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
73689: LD_INT 0
73691: PPUSH
// if not mc_bases or not base or not tech_list then
73692: LD_EXP 23
73696: NOT
73697: PUSH
73698: LD_VAR 0 1
73702: NOT
73703: OR
73704: PUSH
73705: LD_VAR 0 2
73709: NOT
73710: OR
73711: IFFALSE 73715
// exit ;
73713: GO 73740
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
73715: LD_ADDR_EXP 50
73719: PUSH
73720: LD_EXP 50
73724: PPUSH
73725: LD_VAR 0 1
73729: PPUSH
73730: LD_VAR 0 2
73734: PPUSH
73735: CALL_OW 1
73739: ST_TO_ADDR
// end ;
73740: LD_VAR 0 3
73744: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
73745: LD_INT 0
73747: PPUSH
// if not mc_bases or not parking_area or not base then
73748: LD_EXP 23
73752: NOT
73753: PUSH
73754: LD_VAR 0 2
73758: NOT
73759: OR
73760: PUSH
73761: LD_VAR 0 1
73765: NOT
73766: OR
73767: IFFALSE 73771
// exit ;
73769: GO 73796
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
73771: LD_ADDR_EXP 47
73775: PUSH
73776: LD_EXP 47
73780: PPUSH
73781: LD_VAR 0 1
73785: PPUSH
73786: LD_VAR 0 2
73790: PPUSH
73791: CALL_OW 1
73795: ST_TO_ADDR
// end ;
73796: LD_VAR 0 3
73800: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
73801: LD_INT 0
73803: PPUSH
// if not mc_bases or not base or not scan_area then
73804: LD_EXP 23
73808: NOT
73809: PUSH
73810: LD_VAR 0 1
73814: NOT
73815: OR
73816: PUSH
73817: LD_VAR 0 2
73821: NOT
73822: OR
73823: IFFALSE 73827
// exit ;
73825: GO 73852
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
73827: LD_ADDR_EXP 48
73831: PUSH
73832: LD_EXP 48
73836: PPUSH
73837: LD_VAR 0 1
73841: PPUSH
73842: LD_VAR 0 2
73846: PPUSH
73847: CALL_OW 1
73851: ST_TO_ADDR
// end ;
73852: LD_VAR 0 3
73856: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
73857: LD_INT 0
73859: PPUSH
73860: PPUSH
// if not mc_bases or not base then
73861: LD_EXP 23
73865: NOT
73866: PUSH
73867: LD_VAR 0 1
73871: NOT
73872: OR
73873: IFFALSE 73877
// exit ;
73875: GO 73941
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
73877: LD_ADDR_VAR 0 3
73881: PUSH
73882: LD_INT 1
73884: PUSH
73885: LD_INT 2
73887: PUSH
73888: LD_INT 3
73890: PUSH
73891: LD_INT 4
73893: PUSH
73894: LD_INT 11
73896: PUSH
73897: EMPTY
73898: LIST
73899: LIST
73900: LIST
73901: LIST
73902: LIST
73903: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
73904: LD_ADDR_EXP 50
73908: PUSH
73909: LD_EXP 50
73913: PPUSH
73914: LD_VAR 0 1
73918: PPUSH
73919: LD_EXP 50
73923: PUSH
73924: LD_VAR 0 1
73928: ARRAY
73929: PUSH
73930: LD_VAR 0 3
73934: DIFF
73935: PPUSH
73936: CALL_OW 1
73940: ST_TO_ADDR
// end ;
73941: LD_VAR 0 2
73945: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
73946: LD_INT 0
73948: PPUSH
// result := mc_vehicles [ base ] ;
73949: LD_ADDR_VAR 0 3
73953: PUSH
73954: LD_EXP 42
73958: PUSH
73959: LD_VAR 0 1
73963: ARRAY
73964: ST_TO_ADDR
// if onlyCombat then
73965: LD_VAR 0 2
73969: IFFALSE 74147
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
73971: LD_ADDR_VAR 0 3
73975: PUSH
73976: LD_VAR 0 3
73980: PUSH
73981: LD_VAR 0 3
73985: PPUSH
73986: LD_INT 2
73988: PUSH
73989: LD_INT 34
73991: PUSH
73992: LD_INT 12
73994: PUSH
73995: EMPTY
73996: LIST
73997: LIST
73998: PUSH
73999: LD_INT 34
74001: PUSH
74002: LD_INT 51
74004: PUSH
74005: EMPTY
74006: LIST
74007: LIST
74008: PUSH
74009: LD_INT 34
74011: PUSH
74012: LD_EXP 68
74016: PUSH
74017: EMPTY
74018: LIST
74019: LIST
74020: PUSH
74021: LD_INT 34
74023: PUSH
74024: LD_INT 32
74026: PUSH
74027: EMPTY
74028: LIST
74029: LIST
74030: PUSH
74031: LD_INT 34
74033: PUSH
74034: LD_INT 13
74036: PUSH
74037: EMPTY
74038: LIST
74039: LIST
74040: PUSH
74041: LD_INT 34
74043: PUSH
74044: LD_INT 52
74046: PUSH
74047: EMPTY
74048: LIST
74049: LIST
74050: PUSH
74051: LD_INT 34
74053: PUSH
74054: LD_EXP 73
74058: PUSH
74059: EMPTY
74060: LIST
74061: LIST
74062: PUSH
74063: LD_INT 34
74065: PUSH
74066: LD_INT 14
74068: PUSH
74069: EMPTY
74070: LIST
74071: LIST
74072: PUSH
74073: LD_INT 34
74075: PUSH
74076: LD_INT 53
74078: PUSH
74079: EMPTY
74080: LIST
74081: LIST
74082: PUSH
74083: LD_INT 34
74085: PUSH
74086: LD_EXP 67
74090: PUSH
74091: EMPTY
74092: LIST
74093: LIST
74094: PUSH
74095: LD_INT 34
74097: PUSH
74098: LD_INT 31
74100: PUSH
74101: EMPTY
74102: LIST
74103: LIST
74104: PUSH
74105: LD_INT 34
74107: PUSH
74108: LD_INT 48
74110: PUSH
74111: EMPTY
74112: LIST
74113: LIST
74114: PUSH
74115: LD_INT 34
74117: PUSH
74118: LD_INT 8
74120: PUSH
74121: EMPTY
74122: LIST
74123: LIST
74124: PUSH
74125: EMPTY
74126: LIST
74127: LIST
74128: LIST
74129: LIST
74130: LIST
74131: LIST
74132: LIST
74133: LIST
74134: LIST
74135: LIST
74136: LIST
74137: LIST
74138: LIST
74139: LIST
74140: PPUSH
74141: CALL_OW 72
74145: DIFF
74146: ST_TO_ADDR
// end ; end_of_file
74147: LD_VAR 0 3
74151: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
74152: LD_INT 0
74154: PPUSH
74155: PPUSH
74156: PPUSH
// if not mc_bases or not skirmish then
74157: LD_EXP 23
74161: NOT
74162: PUSH
74163: LD_EXP 21
74167: NOT
74168: OR
74169: IFFALSE 74173
// exit ;
74171: GO 74338
// for i = 1 to mc_bases do
74173: LD_ADDR_VAR 0 4
74177: PUSH
74178: DOUBLE
74179: LD_INT 1
74181: DEC
74182: ST_TO_ADDR
74183: LD_EXP 23
74187: PUSH
74188: FOR_TO
74189: IFFALSE 74336
// begin if sci in mc_bases [ i ] then
74191: LD_VAR 0 2
74195: PUSH
74196: LD_EXP 23
74200: PUSH
74201: LD_VAR 0 4
74205: ARRAY
74206: IN
74207: IFFALSE 74334
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
74209: LD_ADDR_EXP 52
74213: PUSH
74214: LD_EXP 52
74218: PPUSH
74219: LD_VAR 0 4
74223: PUSH
74224: LD_EXP 52
74228: PUSH
74229: LD_VAR 0 4
74233: ARRAY
74234: PUSH
74235: LD_INT 1
74237: PLUS
74238: PUSH
74239: EMPTY
74240: LIST
74241: LIST
74242: PPUSH
74243: LD_VAR 0 1
74247: PPUSH
74248: CALL 14915 0 3
74252: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
74253: LD_ADDR_VAR 0 5
74257: PUSH
74258: LD_EXP 23
74262: PUSH
74263: LD_VAR 0 4
74267: ARRAY
74268: PPUSH
74269: LD_INT 2
74271: PUSH
74272: LD_INT 30
74274: PUSH
74275: LD_INT 0
74277: PUSH
74278: EMPTY
74279: LIST
74280: LIST
74281: PUSH
74282: LD_INT 30
74284: PUSH
74285: LD_INT 1
74287: PUSH
74288: EMPTY
74289: LIST
74290: LIST
74291: PUSH
74292: EMPTY
74293: LIST
74294: LIST
74295: LIST
74296: PPUSH
74297: CALL_OW 72
74301: PPUSH
74302: LD_VAR 0 1
74306: PPUSH
74307: CALL_OW 74
74311: ST_TO_ADDR
// if tmp then
74312: LD_VAR 0 5
74316: IFFALSE 74332
// ComStandNearbyBuilding ( ape , tmp ) ;
74318: LD_VAR 0 1
74322: PPUSH
74323: LD_VAR 0 5
74327: PPUSH
74328: CALL 11493 0 2
// break ;
74332: GO 74336
// end ; end ;
74334: GO 74188
74336: POP
74337: POP
// end ;
74338: LD_VAR 0 3
74342: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
74343: LD_INT 0
74345: PPUSH
74346: PPUSH
74347: PPUSH
// if not mc_bases or not skirmish then
74348: LD_EXP 23
74352: NOT
74353: PUSH
74354: LD_EXP 21
74358: NOT
74359: OR
74360: IFFALSE 74364
// exit ;
74362: GO 74453
// for i = 1 to mc_bases do
74364: LD_ADDR_VAR 0 4
74368: PUSH
74369: DOUBLE
74370: LD_INT 1
74372: DEC
74373: ST_TO_ADDR
74374: LD_EXP 23
74378: PUSH
74379: FOR_TO
74380: IFFALSE 74451
// begin if building in mc_busy_turret_list [ i ] then
74382: LD_VAR 0 1
74386: PUSH
74387: LD_EXP 33
74391: PUSH
74392: LD_VAR 0 4
74396: ARRAY
74397: IN
74398: IFFALSE 74449
// begin tmp := mc_busy_turret_list [ i ] diff building ;
74400: LD_ADDR_VAR 0 5
74404: PUSH
74405: LD_EXP 33
74409: PUSH
74410: LD_VAR 0 4
74414: ARRAY
74415: PUSH
74416: LD_VAR 0 1
74420: DIFF
74421: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
74422: LD_ADDR_EXP 33
74426: PUSH
74427: LD_EXP 33
74431: PPUSH
74432: LD_VAR 0 4
74436: PPUSH
74437: LD_VAR 0 5
74441: PPUSH
74442: CALL_OW 1
74446: ST_TO_ADDR
// break ;
74447: GO 74451
// end ; end ;
74449: GO 74379
74451: POP
74452: POP
// end ;
74453: LD_VAR 0 3
74457: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
74458: LD_INT 0
74460: PPUSH
74461: PPUSH
74462: PPUSH
// if not mc_bases or not skirmish then
74463: LD_EXP 23
74467: NOT
74468: PUSH
74469: LD_EXP 21
74473: NOT
74474: OR
74475: IFFALSE 74479
// exit ;
74477: GO 74678
// for i = 1 to mc_bases do
74479: LD_ADDR_VAR 0 5
74483: PUSH
74484: DOUBLE
74485: LD_INT 1
74487: DEC
74488: ST_TO_ADDR
74489: LD_EXP 23
74493: PUSH
74494: FOR_TO
74495: IFFALSE 74676
// if building in mc_bases [ i ] then
74497: LD_VAR 0 1
74501: PUSH
74502: LD_EXP 23
74506: PUSH
74507: LD_VAR 0 5
74511: ARRAY
74512: IN
74513: IFFALSE 74674
// begin tmp := mc_bases [ i ] diff building ;
74515: LD_ADDR_VAR 0 6
74519: PUSH
74520: LD_EXP 23
74524: PUSH
74525: LD_VAR 0 5
74529: ARRAY
74530: PUSH
74531: LD_VAR 0 1
74535: DIFF
74536: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
74537: LD_ADDR_EXP 23
74541: PUSH
74542: LD_EXP 23
74546: PPUSH
74547: LD_VAR 0 5
74551: PPUSH
74552: LD_VAR 0 6
74556: PPUSH
74557: CALL_OW 1
74561: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
74562: LD_VAR 0 1
74566: PUSH
74567: LD_EXP 31
74571: PUSH
74572: LD_VAR 0 5
74576: ARRAY
74577: IN
74578: IFFALSE 74617
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
74580: LD_ADDR_EXP 31
74584: PUSH
74585: LD_EXP 31
74589: PPUSH
74590: LD_VAR 0 5
74594: PPUSH
74595: LD_EXP 31
74599: PUSH
74600: LD_VAR 0 5
74604: ARRAY
74605: PUSH
74606: LD_VAR 0 1
74610: DIFF
74611: PPUSH
74612: CALL_OW 1
74616: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
74617: LD_VAR 0 1
74621: PUSH
74622: LD_EXP 32
74626: PUSH
74627: LD_VAR 0 5
74631: ARRAY
74632: IN
74633: IFFALSE 74672
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
74635: LD_ADDR_EXP 32
74639: PUSH
74640: LD_EXP 32
74644: PPUSH
74645: LD_VAR 0 5
74649: PPUSH
74650: LD_EXP 32
74654: PUSH
74655: LD_VAR 0 5
74659: ARRAY
74660: PUSH
74661: LD_VAR 0 1
74665: DIFF
74666: PPUSH
74667: CALL_OW 1
74671: ST_TO_ADDR
// break ;
74672: GO 74676
// end ;
74674: GO 74494
74676: POP
74677: POP
// end ;
74678: LD_VAR 0 4
74682: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
74683: LD_INT 0
74685: PPUSH
74686: PPUSH
74687: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
74688: LD_EXP 23
74692: NOT
74693: PUSH
74694: LD_EXP 21
74698: NOT
74699: OR
74700: PUSH
74701: LD_VAR 0 3
74705: PUSH
74706: LD_EXP 49
74710: IN
74711: NOT
74712: OR
74713: IFFALSE 74717
// exit ;
74715: GO 74840
// for i = 1 to mc_vehicles do
74717: LD_ADDR_VAR 0 6
74721: PUSH
74722: DOUBLE
74723: LD_INT 1
74725: DEC
74726: ST_TO_ADDR
74727: LD_EXP 42
74731: PUSH
74732: FOR_TO
74733: IFFALSE 74838
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
74735: LD_VAR 0 2
74739: PUSH
74740: LD_EXP 42
74744: PUSH
74745: LD_VAR 0 6
74749: ARRAY
74750: IN
74751: PUSH
74752: LD_VAR 0 1
74756: PUSH
74757: LD_EXP 42
74761: PUSH
74762: LD_VAR 0 6
74766: ARRAY
74767: IN
74768: OR
74769: IFFALSE 74836
// begin tmp := mc_vehicles [ i ] diff old ;
74771: LD_ADDR_VAR 0 7
74775: PUSH
74776: LD_EXP 42
74780: PUSH
74781: LD_VAR 0 6
74785: ARRAY
74786: PUSH
74787: LD_VAR 0 2
74791: DIFF
74792: ST_TO_ADDR
// tmp := tmp diff new ;
74793: LD_ADDR_VAR 0 7
74797: PUSH
74798: LD_VAR 0 7
74802: PUSH
74803: LD_VAR 0 1
74807: DIFF
74808: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
74809: LD_ADDR_EXP 42
74813: PUSH
74814: LD_EXP 42
74818: PPUSH
74819: LD_VAR 0 6
74823: PPUSH
74824: LD_VAR 0 7
74828: PPUSH
74829: CALL_OW 1
74833: ST_TO_ADDR
// break ;
74834: GO 74838
// end ;
74836: GO 74732
74838: POP
74839: POP
// end ;
74840: LD_VAR 0 5
74844: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
74845: LD_INT 0
74847: PPUSH
74848: PPUSH
74849: PPUSH
74850: PPUSH
// if not mc_bases or not skirmish then
74851: LD_EXP 23
74855: NOT
74856: PUSH
74857: LD_EXP 21
74861: NOT
74862: OR
74863: IFFALSE 74867
// exit ;
74865: GO 75259
// side := GetSide ( vehicle ) ;
74867: LD_ADDR_VAR 0 5
74871: PUSH
74872: LD_VAR 0 1
74876: PPUSH
74877: CALL_OW 255
74881: ST_TO_ADDR
// for i = 1 to mc_bases do
74882: LD_ADDR_VAR 0 4
74886: PUSH
74887: DOUBLE
74888: LD_INT 1
74890: DEC
74891: ST_TO_ADDR
74892: LD_EXP 23
74896: PUSH
74897: FOR_TO
74898: IFFALSE 75257
// begin if factory in mc_bases [ i ] then
74900: LD_VAR 0 2
74904: PUSH
74905: LD_EXP 23
74909: PUSH
74910: LD_VAR 0 4
74914: ARRAY
74915: IN
74916: IFFALSE 75255
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
74918: LD_EXP 45
74922: PUSH
74923: LD_VAR 0 4
74927: ARRAY
74928: PUSH
74929: LD_EXP 34
74933: PUSH
74934: LD_VAR 0 4
74938: ARRAY
74939: LESS
74940: PUSH
74941: LD_VAR 0 1
74945: PPUSH
74946: CALL_OW 264
74950: PUSH
74951: LD_INT 31
74953: PUSH
74954: LD_INT 32
74956: PUSH
74957: LD_INT 51
74959: PUSH
74960: LD_EXP 68
74964: PUSH
74965: LD_INT 12
74967: PUSH
74968: LD_INT 30
74970: PUSH
74971: LD_EXP 67
74975: PUSH
74976: LD_INT 11
74978: PUSH
74979: LD_INT 53
74981: PUSH
74982: LD_INT 14
74984: PUSH
74985: LD_EXP 71
74989: PUSH
74990: LD_INT 29
74992: PUSH
74993: LD_EXP 69
74997: PUSH
74998: LD_INT 13
75000: PUSH
75001: LD_INT 52
75003: PUSH
75004: LD_EXP 73
75008: PUSH
75009: LD_INT 48
75011: PUSH
75012: LD_INT 8
75014: PUSH
75015: EMPTY
75016: LIST
75017: LIST
75018: LIST
75019: LIST
75020: LIST
75021: LIST
75022: LIST
75023: LIST
75024: LIST
75025: LIST
75026: LIST
75027: LIST
75028: LIST
75029: LIST
75030: LIST
75031: LIST
75032: LIST
75033: LIST
75034: IN
75035: NOT
75036: AND
75037: IFFALSE 75085
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
75039: LD_ADDR_EXP 45
75043: PUSH
75044: LD_EXP 45
75048: PPUSH
75049: LD_VAR 0 4
75053: PUSH
75054: LD_EXP 45
75058: PUSH
75059: LD_VAR 0 4
75063: ARRAY
75064: PUSH
75065: LD_INT 1
75067: PLUS
75068: PUSH
75069: EMPTY
75070: LIST
75071: LIST
75072: PPUSH
75073: LD_VAR 0 1
75077: PPUSH
75078: CALL 14915 0 3
75082: ST_TO_ADDR
75083: GO 75129
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
75085: LD_ADDR_EXP 42
75089: PUSH
75090: LD_EXP 42
75094: PPUSH
75095: LD_VAR 0 4
75099: PUSH
75100: LD_EXP 42
75104: PUSH
75105: LD_VAR 0 4
75109: ARRAY
75110: PUSH
75111: LD_INT 1
75113: PLUS
75114: PUSH
75115: EMPTY
75116: LIST
75117: LIST
75118: PPUSH
75119: LD_VAR 0 1
75123: PPUSH
75124: CALL 14915 0 3
75128: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
75129: LD_VAR 0 1
75133: PPUSH
75134: CALL_OW 263
75138: PUSH
75139: LD_INT 2
75141: EQUAL
75142: IFFALSE 75171
// begin repeat Connect ( vehicle ) ;
75144: LD_VAR 0 1
75148: PPUSH
75149: CALL 17886 0 1
// wait ( 0 0$1 ) ;
75153: LD_INT 35
75155: PPUSH
75156: CALL_OW 67
// until IsControledBy ( vehicle ) ;
75160: LD_VAR 0 1
75164: PPUSH
75165: CALL_OW 312
75169: IFFALSE 75144
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
75171: LD_VAR 0 1
75175: PPUSH
75176: LD_EXP 47
75180: PUSH
75181: LD_VAR 0 4
75185: ARRAY
75186: PPUSH
75187: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
75191: LD_VAR 0 1
75195: PPUSH
75196: CALL_OW 263
75200: PUSH
75201: LD_INT 1
75203: NONEQUAL
75204: IFFALSE 75208
// break ;
75206: GO 75257
// repeat wait ( 0 0$1 ) ;
75208: LD_INT 35
75210: PPUSH
75211: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
75215: LD_VAR 0 1
75219: PPUSH
75220: LD_EXP 47
75224: PUSH
75225: LD_VAR 0 4
75229: ARRAY
75230: PPUSH
75231: CALL_OW 308
75235: IFFALSE 75208
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
75237: LD_VAR 0 1
75241: PPUSH
75242: CALL_OW 311
75246: PPUSH
75247: CALL_OW 121
// exit ;
75251: POP
75252: POP
75253: GO 75259
// end ; end ;
75255: GO 74897
75257: POP
75258: POP
// end ;
75259: LD_VAR 0 3
75263: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
75264: LD_INT 0
75266: PPUSH
75267: PPUSH
75268: PPUSH
75269: PPUSH
// if not mc_bases or not skirmish then
75270: LD_EXP 23
75274: NOT
75275: PUSH
75276: LD_EXP 21
75280: NOT
75281: OR
75282: IFFALSE 75286
// exit ;
75284: GO 75639
// repeat wait ( 0 0$1 ) ;
75286: LD_INT 35
75288: PPUSH
75289: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
75293: LD_VAR 0 2
75297: PPUSH
75298: LD_VAR 0 3
75302: PPUSH
75303: CALL_OW 284
75307: IFFALSE 75286
// if GetResourceTypeXY ( x , y ) = mat_artefact then
75309: LD_VAR 0 2
75313: PPUSH
75314: LD_VAR 0 3
75318: PPUSH
75319: CALL_OW 283
75323: PUSH
75324: LD_INT 4
75326: EQUAL
75327: IFFALSE 75331
// exit ;
75329: GO 75639
// for i = 1 to mc_bases do
75331: LD_ADDR_VAR 0 7
75335: PUSH
75336: DOUBLE
75337: LD_INT 1
75339: DEC
75340: ST_TO_ADDR
75341: LD_EXP 23
75345: PUSH
75346: FOR_TO
75347: IFFALSE 75637
// begin if mc_crates_area [ i ] then
75349: LD_EXP 41
75353: PUSH
75354: LD_VAR 0 7
75358: ARRAY
75359: IFFALSE 75470
// for j in mc_crates_area [ i ] do
75361: LD_ADDR_VAR 0 8
75365: PUSH
75366: LD_EXP 41
75370: PUSH
75371: LD_VAR 0 7
75375: ARRAY
75376: PUSH
75377: FOR_IN
75378: IFFALSE 75468
// if InArea ( x , y , j ) then
75380: LD_VAR 0 2
75384: PPUSH
75385: LD_VAR 0 3
75389: PPUSH
75390: LD_VAR 0 8
75394: PPUSH
75395: CALL_OW 309
75399: IFFALSE 75466
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
75401: LD_ADDR_EXP 39
75405: PUSH
75406: LD_EXP 39
75410: PPUSH
75411: LD_VAR 0 7
75415: PUSH
75416: LD_EXP 39
75420: PUSH
75421: LD_VAR 0 7
75425: ARRAY
75426: PUSH
75427: LD_INT 1
75429: PLUS
75430: PUSH
75431: EMPTY
75432: LIST
75433: LIST
75434: PPUSH
75435: LD_VAR 0 4
75439: PUSH
75440: LD_VAR 0 2
75444: PUSH
75445: LD_VAR 0 3
75449: PUSH
75450: EMPTY
75451: LIST
75452: LIST
75453: LIST
75454: PPUSH
75455: CALL 14915 0 3
75459: ST_TO_ADDR
// exit ;
75460: POP
75461: POP
75462: POP
75463: POP
75464: GO 75639
// end ;
75466: GO 75377
75468: POP
75469: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75470: LD_ADDR_VAR 0 9
75474: PUSH
75475: LD_EXP 23
75479: PUSH
75480: LD_VAR 0 7
75484: ARRAY
75485: PPUSH
75486: LD_INT 2
75488: PUSH
75489: LD_INT 30
75491: PUSH
75492: LD_INT 0
75494: PUSH
75495: EMPTY
75496: LIST
75497: LIST
75498: PUSH
75499: LD_INT 30
75501: PUSH
75502: LD_INT 1
75504: PUSH
75505: EMPTY
75506: LIST
75507: LIST
75508: PUSH
75509: EMPTY
75510: LIST
75511: LIST
75512: LIST
75513: PPUSH
75514: CALL_OW 72
75518: ST_TO_ADDR
// if not depot then
75519: LD_VAR 0 9
75523: NOT
75524: IFFALSE 75528
// continue ;
75526: GO 75346
// for j in depot do
75528: LD_ADDR_VAR 0 8
75532: PUSH
75533: LD_VAR 0 9
75537: PUSH
75538: FOR_IN
75539: IFFALSE 75633
// if GetDistUnitXY ( j , x , y ) < 30 then
75541: LD_VAR 0 8
75545: PPUSH
75546: LD_VAR 0 2
75550: PPUSH
75551: LD_VAR 0 3
75555: PPUSH
75556: CALL_OW 297
75560: PUSH
75561: LD_INT 30
75563: LESS
75564: IFFALSE 75631
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
75566: LD_ADDR_EXP 39
75570: PUSH
75571: LD_EXP 39
75575: PPUSH
75576: LD_VAR 0 7
75580: PUSH
75581: LD_EXP 39
75585: PUSH
75586: LD_VAR 0 7
75590: ARRAY
75591: PUSH
75592: LD_INT 1
75594: PLUS
75595: PUSH
75596: EMPTY
75597: LIST
75598: LIST
75599: PPUSH
75600: LD_VAR 0 4
75604: PUSH
75605: LD_VAR 0 2
75609: PUSH
75610: LD_VAR 0 3
75614: PUSH
75615: EMPTY
75616: LIST
75617: LIST
75618: LIST
75619: PPUSH
75620: CALL 14915 0 3
75624: ST_TO_ADDR
// exit ;
75625: POP
75626: POP
75627: POP
75628: POP
75629: GO 75639
// end ;
75631: GO 75538
75633: POP
75634: POP
// end ;
75635: GO 75346
75637: POP
75638: POP
// end ;
75639: LD_VAR 0 6
75643: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
75644: LD_INT 0
75646: PPUSH
75647: PPUSH
75648: PPUSH
75649: PPUSH
// if not mc_bases or not skirmish then
75650: LD_EXP 23
75654: NOT
75655: PUSH
75656: LD_EXP 21
75660: NOT
75661: OR
75662: IFFALSE 75666
// exit ;
75664: GO 75943
// side := GetSide ( lab ) ;
75666: LD_ADDR_VAR 0 4
75670: PUSH
75671: LD_VAR 0 2
75675: PPUSH
75676: CALL_OW 255
75680: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
75681: LD_VAR 0 4
75685: PUSH
75686: LD_EXP 49
75690: IN
75691: NOT
75692: PUSH
75693: LD_EXP 50
75697: NOT
75698: OR
75699: PUSH
75700: LD_EXP 23
75704: NOT
75705: OR
75706: IFFALSE 75710
// exit ;
75708: GO 75943
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
75710: LD_ADDR_EXP 50
75714: PUSH
75715: LD_EXP 50
75719: PPUSH
75720: LD_VAR 0 4
75724: PPUSH
75725: LD_EXP 50
75729: PUSH
75730: LD_VAR 0 4
75734: ARRAY
75735: PUSH
75736: LD_VAR 0 1
75740: DIFF
75741: PPUSH
75742: CALL_OW 1
75746: ST_TO_ADDR
// for i = 1 to mc_bases do
75747: LD_ADDR_VAR 0 5
75751: PUSH
75752: DOUBLE
75753: LD_INT 1
75755: DEC
75756: ST_TO_ADDR
75757: LD_EXP 23
75761: PUSH
75762: FOR_TO
75763: IFFALSE 75941
// begin if lab in mc_bases [ i ] then
75765: LD_VAR 0 2
75769: PUSH
75770: LD_EXP 23
75774: PUSH
75775: LD_VAR 0 5
75779: ARRAY
75780: IN
75781: IFFALSE 75939
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
75783: LD_VAR 0 1
75787: PUSH
75788: LD_INT 11
75790: PUSH
75791: LD_INT 4
75793: PUSH
75794: LD_INT 3
75796: PUSH
75797: LD_INT 2
75799: PUSH
75800: EMPTY
75801: LIST
75802: LIST
75803: LIST
75804: LIST
75805: IN
75806: PUSH
75807: LD_EXP 53
75811: PUSH
75812: LD_VAR 0 5
75816: ARRAY
75817: AND
75818: IFFALSE 75939
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
75820: LD_ADDR_VAR 0 6
75824: PUSH
75825: LD_EXP 53
75829: PUSH
75830: LD_VAR 0 5
75834: ARRAY
75835: PUSH
75836: LD_INT 1
75838: ARRAY
75839: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
75840: LD_ADDR_EXP 53
75844: PUSH
75845: LD_EXP 53
75849: PPUSH
75850: LD_VAR 0 5
75854: PPUSH
75855: EMPTY
75856: PPUSH
75857: CALL_OW 1
75861: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
75862: LD_VAR 0 6
75866: PPUSH
75867: LD_INT 0
75869: PPUSH
75870: CALL_OW 109
// ComExitBuilding ( tmp ) ;
75874: LD_VAR 0 6
75878: PPUSH
75879: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
75883: LD_ADDR_EXP 52
75887: PUSH
75888: LD_EXP 52
75892: PPUSH
75893: LD_VAR 0 5
75897: PPUSH
75898: LD_EXP 52
75902: PUSH
75903: LD_VAR 0 5
75907: ARRAY
75908: PPUSH
75909: LD_INT 1
75911: PPUSH
75912: LD_VAR 0 6
75916: PPUSH
75917: CALL_OW 2
75921: PPUSH
75922: CALL_OW 1
75926: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
75927: LD_VAR 0 5
75931: PPUSH
75932: LD_INT 112
75934: PPUSH
75935: CALL 52678 0 2
// end ; end ; end ;
75939: GO 75762
75941: POP
75942: POP
// end ;
75943: LD_VAR 0 3
75947: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
75948: LD_INT 0
75950: PPUSH
75951: PPUSH
75952: PPUSH
75953: PPUSH
75954: PPUSH
75955: PPUSH
75956: PPUSH
75957: PPUSH
// if not mc_bases or not skirmish then
75958: LD_EXP 23
75962: NOT
75963: PUSH
75964: LD_EXP 21
75968: NOT
75969: OR
75970: IFFALSE 75974
// exit ;
75972: GO 77345
// for i = 1 to mc_bases do
75974: LD_ADDR_VAR 0 3
75978: PUSH
75979: DOUBLE
75980: LD_INT 1
75982: DEC
75983: ST_TO_ADDR
75984: LD_EXP 23
75988: PUSH
75989: FOR_TO
75990: IFFALSE 77343
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
75992: LD_VAR 0 1
75996: PUSH
75997: LD_EXP 23
76001: PUSH
76002: LD_VAR 0 3
76006: ARRAY
76007: IN
76008: PUSH
76009: LD_VAR 0 1
76013: PUSH
76014: LD_EXP 30
76018: PUSH
76019: LD_VAR 0 3
76023: ARRAY
76024: IN
76025: OR
76026: PUSH
76027: LD_VAR 0 1
76031: PUSH
76032: LD_EXP 45
76036: PUSH
76037: LD_VAR 0 3
76041: ARRAY
76042: IN
76043: OR
76044: PUSH
76045: LD_VAR 0 1
76049: PUSH
76050: LD_EXP 42
76054: PUSH
76055: LD_VAR 0 3
76059: ARRAY
76060: IN
76061: OR
76062: PUSH
76063: LD_VAR 0 1
76067: PUSH
76068: LD_EXP 52
76072: PUSH
76073: LD_VAR 0 3
76077: ARRAY
76078: IN
76079: OR
76080: PUSH
76081: LD_VAR 0 1
76085: PUSH
76086: LD_EXP 53
76090: PUSH
76091: LD_VAR 0 3
76095: ARRAY
76096: IN
76097: OR
76098: IFFALSE 77341
// begin if un in mc_ape [ i ] then
76100: LD_VAR 0 1
76104: PUSH
76105: LD_EXP 52
76109: PUSH
76110: LD_VAR 0 3
76114: ARRAY
76115: IN
76116: IFFALSE 76155
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
76118: LD_ADDR_EXP 52
76122: PUSH
76123: LD_EXP 52
76127: PPUSH
76128: LD_VAR 0 3
76132: PPUSH
76133: LD_EXP 52
76137: PUSH
76138: LD_VAR 0 3
76142: ARRAY
76143: PUSH
76144: LD_VAR 0 1
76148: DIFF
76149: PPUSH
76150: CALL_OW 1
76154: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
76155: LD_VAR 0 1
76159: PUSH
76160: LD_EXP 53
76164: PUSH
76165: LD_VAR 0 3
76169: ARRAY
76170: IN
76171: IFFALSE 76195
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
76173: LD_ADDR_EXP 53
76177: PUSH
76178: LD_EXP 53
76182: PPUSH
76183: LD_VAR 0 3
76187: PPUSH
76188: EMPTY
76189: PPUSH
76190: CALL_OW 1
76194: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
76195: LD_VAR 0 1
76199: PPUSH
76200: CALL_OW 247
76204: PUSH
76205: LD_INT 2
76207: EQUAL
76208: PUSH
76209: LD_VAR 0 1
76213: PPUSH
76214: CALL_OW 110
76218: PUSH
76219: LD_INT 20
76221: EQUAL
76222: PUSH
76223: LD_VAR 0 1
76227: PUSH
76228: LD_EXP 45
76232: PUSH
76233: LD_VAR 0 3
76237: ARRAY
76238: IN
76239: OR
76240: PUSH
76241: LD_VAR 0 1
76245: PPUSH
76246: CALL_OW 264
76250: PUSH
76251: LD_INT 12
76253: PUSH
76254: LD_INT 51
76256: PUSH
76257: LD_EXP 68
76261: PUSH
76262: LD_INT 32
76264: PUSH
76265: LD_INT 13
76267: PUSH
76268: LD_INT 52
76270: PUSH
76271: LD_INT 31
76273: PUSH
76274: EMPTY
76275: LIST
76276: LIST
76277: LIST
76278: LIST
76279: LIST
76280: LIST
76281: LIST
76282: IN
76283: OR
76284: AND
76285: IFFALSE 76593
// begin if un in mc_defender [ i ] then
76287: LD_VAR 0 1
76291: PUSH
76292: LD_EXP 45
76296: PUSH
76297: LD_VAR 0 3
76301: ARRAY
76302: IN
76303: IFFALSE 76342
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
76305: LD_ADDR_EXP 45
76309: PUSH
76310: LD_EXP 45
76314: PPUSH
76315: LD_VAR 0 3
76319: PPUSH
76320: LD_EXP 45
76324: PUSH
76325: LD_VAR 0 3
76329: ARRAY
76330: PUSH
76331: LD_VAR 0 1
76335: DIFF
76336: PPUSH
76337: CALL_OW 1
76341: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
76342: LD_ADDR_VAR 0 8
76346: PUSH
76347: LD_VAR 0 3
76351: PPUSH
76352: LD_INT 3
76354: PPUSH
76355: CALL 72983 0 2
76359: ST_TO_ADDR
// if fac then
76360: LD_VAR 0 8
76364: IFFALSE 76593
// begin for j in fac do
76366: LD_ADDR_VAR 0 4
76370: PUSH
76371: LD_VAR 0 8
76375: PUSH
76376: FOR_IN
76377: IFFALSE 76591
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
76379: LD_ADDR_VAR 0 9
76383: PUSH
76384: LD_VAR 0 8
76388: PPUSH
76389: LD_VAR 0 1
76393: PPUSH
76394: CALL_OW 265
76398: PPUSH
76399: LD_VAR 0 1
76403: PPUSH
76404: CALL_OW 262
76408: PPUSH
76409: LD_VAR 0 1
76413: PPUSH
76414: CALL_OW 263
76418: PPUSH
76419: LD_VAR 0 1
76423: PPUSH
76424: CALL_OW 264
76428: PPUSH
76429: CALL 12411 0 5
76433: ST_TO_ADDR
// if components then
76434: LD_VAR 0 9
76438: IFFALSE 76589
// begin if GetWeapon ( un ) = ar_control_tower then
76440: LD_VAR 0 1
76444: PPUSH
76445: CALL_OW 264
76449: PUSH
76450: LD_INT 31
76452: EQUAL
76453: IFFALSE 76570
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
76455: LD_VAR 0 1
76459: PPUSH
76460: CALL_OW 311
76464: PPUSH
76465: LD_INT 0
76467: PPUSH
76468: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
76472: LD_ADDR_EXP 63
76476: PUSH
76477: LD_EXP 63
76481: PPUSH
76482: LD_VAR 0 3
76486: PPUSH
76487: LD_EXP 63
76491: PUSH
76492: LD_VAR 0 3
76496: ARRAY
76497: PUSH
76498: LD_VAR 0 1
76502: PPUSH
76503: CALL_OW 311
76507: DIFF
76508: PPUSH
76509: CALL_OW 1
76513: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
76514: LD_ADDR_VAR 0 7
76518: PUSH
76519: LD_EXP 44
76523: PUSH
76524: LD_VAR 0 3
76528: ARRAY
76529: PPUSH
76530: LD_INT 1
76532: PPUSH
76533: LD_VAR 0 9
76537: PPUSH
76538: CALL_OW 2
76542: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
76543: LD_ADDR_EXP 44
76547: PUSH
76548: LD_EXP 44
76552: PPUSH
76553: LD_VAR 0 3
76557: PPUSH
76558: LD_VAR 0 7
76562: PPUSH
76563: CALL_OW 1
76567: ST_TO_ADDR
// end else
76568: GO 76587
// MC_InsertProduceList ( i , [ components ] ) ;
76570: LD_VAR 0 3
76574: PPUSH
76575: LD_VAR 0 9
76579: PUSH
76580: EMPTY
76581: LIST
76582: PPUSH
76583: CALL 72528 0 2
// break ;
76587: GO 76591
// end ; end ;
76589: GO 76376
76591: POP
76592: POP
// end ; end ; if GetType ( un ) = unit_building then
76593: LD_VAR 0 1
76597: PPUSH
76598: CALL_OW 247
76602: PUSH
76603: LD_INT 3
76605: EQUAL
76606: IFFALSE 77009
// begin btype := GetBType ( un ) ;
76608: LD_ADDR_VAR 0 5
76612: PUSH
76613: LD_VAR 0 1
76617: PPUSH
76618: CALL_OW 266
76622: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
76623: LD_VAR 0 5
76627: PUSH
76628: LD_INT 29
76630: PUSH
76631: LD_INT 30
76633: PUSH
76634: EMPTY
76635: LIST
76636: LIST
76637: IN
76638: IFFALSE 76711
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
76640: LD_VAR 0 1
76644: PPUSH
76645: CALL_OW 250
76649: PPUSH
76650: LD_VAR 0 1
76654: PPUSH
76655: CALL_OW 251
76659: PPUSH
76660: LD_VAR 0 1
76664: PPUSH
76665: CALL_OW 255
76669: PPUSH
76670: CALL_OW 440
76674: NOT
76675: IFFALSE 76711
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
76677: LD_VAR 0 1
76681: PPUSH
76682: CALL_OW 250
76686: PPUSH
76687: LD_VAR 0 1
76691: PPUSH
76692: CALL_OW 251
76696: PPUSH
76697: LD_VAR 0 1
76701: PPUSH
76702: CALL_OW 255
76706: PPUSH
76707: CALL_OW 441
// end ; if btype = b_warehouse then
76711: LD_VAR 0 5
76715: PUSH
76716: LD_INT 1
76718: EQUAL
76719: IFFALSE 76737
// begin btype := b_depot ;
76721: LD_ADDR_VAR 0 5
76725: PUSH
76726: LD_INT 0
76728: ST_TO_ADDR
// pos := 1 ;
76729: LD_ADDR_VAR 0 6
76733: PUSH
76734: LD_INT 1
76736: ST_TO_ADDR
// end ; if btype = b_factory then
76737: LD_VAR 0 5
76741: PUSH
76742: LD_INT 3
76744: EQUAL
76745: IFFALSE 76763
// begin btype := b_workshop ;
76747: LD_ADDR_VAR 0 5
76751: PUSH
76752: LD_INT 2
76754: ST_TO_ADDR
// pos := 1 ;
76755: LD_ADDR_VAR 0 6
76759: PUSH
76760: LD_INT 1
76762: ST_TO_ADDR
// end ; if btype = b_barracks then
76763: LD_VAR 0 5
76767: PUSH
76768: LD_INT 5
76770: EQUAL
76771: IFFALSE 76781
// btype := b_armoury ;
76773: LD_ADDR_VAR 0 5
76777: PUSH
76778: LD_INT 4
76780: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
76781: LD_VAR 0 5
76785: PUSH
76786: LD_INT 7
76788: PUSH
76789: LD_INT 8
76791: PUSH
76792: EMPTY
76793: LIST
76794: LIST
76795: IN
76796: IFFALSE 76806
// btype := b_lab ;
76798: LD_ADDR_VAR 0 5
76802: PUSH
76803: LD_INT 6
76805: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
76806: LD_ADDR_EXP 28
76810: PUSH
76811: LD_EXP 28
76815: PPUSH
76816: LD_VAR 0 3
76820: PUSH
76821: LD_EXP 28
76825: PUSH
76826: LD_VAR 0 3
76830: ARRAY
76831: PUSH
76832: LD_INT 1
76834: PLUS
76835: PUSH
76836: EMPTY
76837: LIST
76838: LIST
76839: PPUSH
76840: LD_VAR 0 5
76844: PUSH
76845: LD_VAR 0 1
76849: PPUSH
76850: CALL_OW 250
76854: PUSH
76855: LD_VAR 0 1
76859: PPUSH
76860: CALL_OW 251
76864: PUSH
76865: LD_VAR 0 1
76869: PPUSH
76870: CALL_OW 254
76874: PUSH
76875: EMPTY
76876: LIST
76877: LIST
76878: LIST
76879: LIST
76880: PPUSH
76881: CALL 14915 0 3
76885: ST_TO_ADDR
// if pos = 1 then
76886: LD_VAR 0 6
76890: PUSH
76891: LD_INT 1
76893: EQUAL
76894: IFFALSE 77009
// begin tmp := mc_build_list [ i ] ;
76896: LD_ADDR_VAR 0 7
76900: PUSH
76901: LD_EXP 28
76905: PUSH
76906: LD_VAR 0 3
76910: ARRAY
76911: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
76912: LD_VAR 0 7
76916: PPUSH
76917: LD_INT 2
76919: PUSH
76920: LD_INT 30
76922: PUSH
76923: LD_INT 0
76925: PUSH
76926: EMPTY
76927: LIST
76928: LIST
76929: PUSH
76930: LD_INT 30
76932: PUSH
76933: LD_INT 1
76935: PUSH
76936: EMPTY
76937: LIST
76938: LIST
76939: PUSH
76940: EMPTY
76941: LIST
76942: LIST
76943: LIST
76944: PPUSH
76945: CALL_OW 72
76949: IFFALSE 76959
// pos := 2 ;
76951: LD_ADDR_VAR 0 6
76955: PUSH
76956: LD_INT 2
76958: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
76959: LD_ADDR_VAR 0 7
76963: PUSH
76964: LD_VAR 0 7
76968: PPUSH
76969: LD_VAR 0 6
76973: PPUSH
76974: LD_VAR 0 7
76978: PPUSH
76979: CALL 15241 0 3
76983: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
76984: LD_ADDR_EXP 28
76988: PUSH
76989: LD_EXP 28
76993: PPUSH
76994: LD_VAR 0 3
76998: PPUSH
76999: LD_VAR 0 7
77003: PPUSH
77004: CALL_OW 1
77008: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
77009: LD_VAR 0 1
77013: PUSH
77014: LD_EXP 23
77018: PUSH
77019: LD_VAR 0 3
77023: ARRAY
77024: IN
77025: IFFALSE 77064
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
77027: LD_ADDR_EXP 23
77031: PUSH
77032: LD_EXP 23
77036: PPUSH
77037: LD_VAR 0 3
77041: PPUSH
77042: LD_EXP 23
77046: PUSH
77047: LD_VAR 0 3
77051: ARRAY
77052: PUSH
77053: LD_VAR 0 1
77057: DIFF
77058: PPUSH
77059: CALL_OW 1
77063: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
77064: LD_VAR 0 1
77068: PUSH
77069: LD_EXP 30
77073: PUSH
77074: LD_VAR 0 3
77078: ARRAY
77079: IN
77080: IFFALSE 77119
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
77082: LD_ADDR_EXP 30
77086: PUSH
77087: LD_EXP 30
77091: PPUSH
77092: LD_VAR 0 3
77096: PPUSH
77097: LD_EXP 30
77101: PUSH
77102: LD_VAR 0 3
77106: ARRAY
77107: PUSH
77108: LD_VAR 0 1
77112: DIFF
77113: PPUSH
77114: CALL_OW 1
77118: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
77119: LD_VAR 0 1
77123: PUSH
77124: LD_EXP 42
77128: PUSH
77129: LD_VAR 0 3
77133: ARRAY
77134: IN
77135: IFFALSE 77174
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
77137: LD_ADDR_EXP 42
77141: PUSH
77142: LD_EXP 42
77146: PPUSH
77147: LD_VAR 0 3
77151: PPUSH
77152: LD_EXP 42
77156: PUSH
77157: LD_VAR 0 3
77161: ARRAY
77162: PUSH
77163: LD_VAR 0 1
77167: DIFF
77168: PPUSH
77169: CALL_OW 1
77173: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
77174: LD_VAR 0 1
77178: PUSH
77179: LD_EXP 45
77183: PUSH
77184: LD_VAR 0 3
77188: ARRAY
77189: IN
77190: IFFALSE 77229
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
77192: LD_ADDR_EXP 45
77196: PUSH
77197: LD_EXP 45
77201: PPUSH
77202: LD_VAR 0 3
77206: PPUSH
77207: LD_EXP 45
77211: PUSH
77212: LD_VAR 0 3
77216: ARRAY
77217: PUSH
77218: LD_VAR 0 1
77222: DIFF
77223: PPUSH
77224: CALL_OW 1
77228: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
77229: LD_VAR 0 1
77233: PUSH
77234: LD_EXP 32
77238: PUSH
77239: LD_VAR 0 3
77243: ARRAY
77244: IN
77245: IFFALSE 77284
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
77247: LD_ADDR_EXP 32
77251: PUSH
77252: LD_EXP 32
77256: PPUSH
77257: LD_VAR 0 3
77261: PPUSH
77262: LD_EXP 32
77266: PUSH
77267: LD_VAR 0 3
77271: ARRAY
77272: PUSH
77273: LD_VAR 0 1
77277: DIFF
77278: PPUSH
77279: CALL_OW 1
77283: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
77284: LD_VAR 0 1
77288: PUSH
77289: LD_EXP 31
77293: PUSH
77294: LD_VAR 0 3
77298: ARRAY
77299: IN
77300: IFFALSE 77339
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
77302: LD_ADDR_EXP 31
77306: PUSH
77307: LD_EXP 31
77311: PPUSH
77312: LD_VAR 0 3
77316: PPUSH
77317: LD_EXP 31
77321: PUSH
77322: LD_VAR 0 3
77326: ARRAY
77327: PUSH
77328: LD_VAR 0 1
77332: DIFF
77333: PPUSH
77334: CALL_OW 1
77338: ST_TO_ADDR
// end ; break ;
77339: GO 77343
// end ;
77341: GO 75989
77343: POP
77344: POP
// end ;
77345: LD_VAR 0 2
77349: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
77350: LD_INT 0
77352: PPUSH
77353: PPUSH
77354: PPUSH
// if not mc_bases or not skirmish then
77355: LD_EXP 23
77359: NOT
77360: PUSH
77361: LD_EXP 21
77365: NOT
77366: OR
77367: IFFALSE 77371
// exit ;
77369: GO 77586
// for i = 1 to mc_bases do
77371: LD_ADDR_VAR 0 3
77375: PUSH
77376: DOUBLE
77377: LD_INT 1
77379: DEC
77380: ST_TO_ADDR
77381: LD_EXP 23
77385: PUSH
77386: FOR_TO
77387: IFFALSE 77584
// begin if building in mc_construct_list [ i ] then
77389: LD_VAR 0 1
77393: PUSH
77394: LD_EXP 30
77398: PUSH
77399: LD_VAR 0 3
77403: ARRAY
77404: IN
77405: IFFALSE 77582
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
77407: LD_ADDR_EXP 30
77411: PUSH
77412: LD_EXP 30
77416: PPUSH
77417: LD_VAR 0 3
77421: PPUSH
77422: LD_EXP 30
77426: PUSH
77427: LD_VAR 0 3
77431: ARRAY
77432: PUSH
77433: LD_VAR 0 1
77437: DIFF
77438: PPUSH
77439: CALL_OW 1
77443: ST_TO_ADDR
// if building in mc_lab [ i ] then
77444: LD_VAR 0 1
77448: PUSH
77449: LD_EXP 56
77453: PUSH
77454: LD_VAR 0 3
77458: ARRAY
77459: IN
77460: IFFALSE 77515
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
77462: LD_ADDR_EXP 57
77466: PUSH
77467: LD_EXP 57
77471: PPUSH
77472: LD_VAR 0 3
77476: PPUSH
77477: LD_EXP 57
77481: PUSH
77482: LD_VAR 0 3
77486: ARRAY
77487: PPUSH
77488: LD_INT 1
77490: PPUSH
77491: LD_EXP 57
77495: PUSH
77496: LD_VAR 0 3
77500: ARRAY
77501: PPUSH
77502: LD_INT 0
77504: PPUSH
77505: CALL 14333 0 4
77509: PPUSH
77510: CALL_OW 1
77514: ST_TO_ADDR
// if not building in mc_bases [ i ] then
77515: LD_VAR 0 1
77519: PUSH
77520: LD_EXP 23
77524: PUSH
77525: LD_VAR 0 3
77529: ARRAY
77530: IN
77531: NOT
77532: IFFALSE 77578
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
77534: LD_ADDR_EXP 23
77538: PUSH
77539: LD_EXP 23
77543: PPUSH
77544: LD_VAR 0 3
77548: PUSH
77549: LD_EXP 23
77553: PUSH
77554: LD_VAR 0 3
77558: ARRAY
77559: PUSH
77560: LD_INT 1
77562: PLUS
77563: PUSH
77564: EMPTY
77565: LIST
77566: LIST
77567: PPUSH
77568: LD_VAR 0 1
77572: PPUSH
77573: CALL 14915 0 3
77577: ST_TO_ADDR
// exit ;
77578: POP
77579: POP
77580: GO 77586
// end ; end ;
77582: GO 77386
77584: POP
77585: POP
// end ;
77586: LD_VAR 0 2
77590: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
77591: LD_INT 0
77593: PPUSH
77594: PPUSH
77595: PPUSH
77596: PPUSH
77597: PPUSH
77598: PPUSH
77599: PPUSH
// if not mc_bases or not skirmish then
77600: LD_EXP 23
77604: NOT
77605: PUSH
77606: LD_EXP 21
77610: NOT
77611: OR
77612: IFFALSE 77616
// exit ;
77614: GO 78277
// for i = 1 to mc_bases do
77616: LD_ADDR_VAR 0 3
77620: PUSH
77621: DOUBLE
77622: LD_INT 1
77624: DEC
77625: ST_TO_ADDR
77626: LD_EXP 23
77630: PUSH
77631: FOR_TO
77632: IFFALSE 78275
// begin if building in mc_construct_list [ i ] then
77634: LD_VAR 0 1
77638: PUSH
77639: LD_EXP 30
77643: PUSH
77644: LD_VAR 0 3
77648: ARRAY
77649: IN
77650: IFFALSE 78273
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
77652: LD_ADDR_EXP 30
77656: PUSH
77657: LD_EXP 30
77661: PPUSH
77662: LD_VAR 0 3
77666: PPUSH
77667: LD_EXP 30
77671: PUSH
77672: LD_VAR 0 3
77676: ARRAY
77677: PUSH
77678: LD_VAR 0 1
77682: DIFF
77683: PPUSH
77684: CALL_OW 1
77688: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
77689: LD_ADDR_EXP 23
77693: PUSH
77694: LD_EXP 23
77698: PPUSH
77699: LD_VAR 0 3
77703: PUSH
77704: LD_EXP 23
77708: PUSH
77709: LD_VAR 0 3
77713: ARRAY
77714: PUSH
77715: LD_INT 1
77717: PLUS
77718: PUSH
77719: EMPTY
77720: LIST
77721: LIST
77722: PPUSH
77723: LD_VAR 0 1
77727: PPUSH
77728: CALL 14915 0 3
77732: ST_TO_ADDR
// btype := GetBType ( building ) ;
77733: LD_ADDR_VAR 0 5
77737: PUSH
77738: LD_VAR 0 1
77742: PPUSH
77743: CALL_OW 266
77747: ST_TO_ADDR
// side := GetSide ( building ) ;
77748: LD_ADDR_VAR 0 8
77752: PUSH
77753: LD_VAR 0 1
77757: PPUSH
77758: CALL_OW 255
77762: ST_TO_ADDR
// if btype = b_lab then
77763: LD_VAR 0 5
77767: PUSH
77768: LD_INT 6
77770: EQUAL
77771: IFFALSE 77821
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
77773: LD_ADDR_EXP 56
77777: PUSH
77778: LD_EXP 56
77782: PPUSH
77783: LD_VAR 0 3
77787: PUSH
77788: LD_EXP 56
77792: PUSH
77793: LD_VAR 0 3
77797: ARRAY
77798: PUSH
77799: LD_INT 1
77801: PLUS
77802: PUSH
77803: EMPTY
77804: LIST
77805: LIST
77806: PPUSH
77807: LD_VAR 0 1
77811: PPUSH
77812: CALL 14915 0 3
77816: ST_TO_ADDR
// exit ;
77817: POP
77818: POP
77819: GO 78277
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
77821: LD_VAR 0 5
77825: PUSH
77826: LD_INT 0
77828: PUSH
77829: LD_INT 2
77831: PUSH
77832: LD_INT 4
77834: PUSH
77835: EMPTY
77836: LIST
77837: LIST
77838: LIST
77839: IN
77840: IFFALSE 77964
// begin if btype = b_armoury then
77842: LD_VAR 0 5
77846: PUSH
77847: LD_INT 4
77849: EQUAL
77850: IFFALSE 77860
// btype := b_barracks ;
77852: LD_ADDR_VAR 0 5
77856: PUSH
77857: LD_INT 5
77859: ST_TO_ADDR
// if btype = b_depot then
77860: LD_VAR 0 5
77864: PUSH
77865: LD_INT 0
77867: EQUAL
77868: IFFALSE 77878
// btype := b_warehouse ;
77870: LD_ADDR_VAR 0 5
77874: PUSH
77875: LD_INT 1
77877: ST_TO_ADDR
// if btype = b_workshop then
77878: LD_VAR 0 5
77882: PUSH
77883: LD_INT 2
77885: EQUAL
77886: IFFALSE 77896
// btype := b_factory ;
77888: LD_ADDR_VAR 0 5
77892: PUSH
77893: LD_INT 3
77895: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
77896: LD_VAR 0 5
77900: PPUSH
77901: LD_VAR 0 8
77905: PPUSH
77906: CALL_OW 323
77910: PUSH
77911: LD_INT 1
77913: EQUAL
77914: IFFALSE 77960
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
77916: LD_ADDR_EXP 55
77920: PUSH
77921: LD_EXP 55
77925: PPUSH
77926: LD_VAR 0 3
77930: PUSH
77931: LD_EXP 55
77935: PUSH
77936: LD_VAR 0 3
77940: ARRAY
77941: PUSH
77942: LD_INT 1
77944: PLUS
77945: PUSH
77946: EMPTY
77947: LIST
77948: LIST
77949: PPUSH
77950: LD_VAR 0 1
77954: PPUSH
77955: CALL 14915 0 3
77959: ST_TO_ADDR
// exit ;
77960: POP
77961: POP
77962: GO 78277
// end ; if btype in [ b_bunker , b_turret ] then
77964: LD_VAR 0 5
77968: PUSH
77969: LD_INT 32
77971: PUSH
77972: LD_INT 33
77974: PUSH
77975: EMPTY
77976: LIST
77977: LIST
77978: IN
77979: IFFALSE 78269
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
77981: LD_ADDR_EXP 31
77985: PUSH
77986: LD_EXP 31
77990: PPUSH
77991: LD_VAR 0 3
77995: PUSH
77996: LD_EXP 31
78000: PUSH
78001: LD_VAR 0 3
78005: ARRAY
78006: PUSH
78007: LD_INT 1
78009: PLUS
78010: PUSH
78011: EMPTY
78012: LIST
78013: LIST
78014: PPUSH
78015: LD_VAR 0 1
78019: PPUSH
78020: CALL 14915 0 3
78024: ST_TO_ADDR
// if btype = b_bunker then
78025: LD_VAR 0 5
78029: PUSH
78030: LD_INT 32
78032: EQUAL
78033: IFFALSE 78269
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
78035: LD_ADDR_EXP 32
78039: PUSH
78040: LD_EXP 32
78044: PPUSH
78045: LD_VAR 0 3
78049: PUSH
78050: LD_EXP 32
78054: PUSH
78055: LD_VAR 0 3
78059: ARRAY
78060: PUSH
78061: LD_INT 1
78063: PLUS
78064: PUSH
78065: EMPTY
78066: LIST
78067: LIST
78068: PPUSH
78069: LD_VAR 0 1
78073: PPUSH
78074: CALL 14915 0 3
78078: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
78079: LD_ADDR_VAR 0 6
78083: PUSH
78084: LD_EXP 23
78088: PUSH
78089: LD_VAR 0 3
78093: ARRAY
78094: PPUSH
78095: LD_INT 25
78097: PUSH
78098: LD_INT 1
78100: PUSH
78101: EMPTY
78102: LIST
78103: LIST
78104: PUSH
78105: LD_INT 3
78107: PUSH
78108: LD_INT 54
78110: PUSH
78111: EMPTY
78112: LIST
78113: PUSH
78114: EMPTY
78115: LIST
78116: LIST
78117: PUSH
78118: EMPTY
78119: LIST
78120: LIST
78121: PPUSH
78122: CALL_OW 72
78126: ST_TO_ADDR
// if tmp then
78127: LD_VAR 0 6
78131: IFFALSE 78137
// exit ;
78133: POP
78134: POP
78135: GO 78277
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
78137: LD_ADDR_VAR 0 6
78141: PUSH
78142: LD_EXP 23
78146: PUSH
78147: LD_VAR 0 3
78151: ARRAY
78152: PPUSH
78153: LD_INT 2
78155: PUSH
78156: LD_INT 30
78158: PUSH
78159: LD_INT 4
78161: PUSH
78162: EMPTY
78163: LIST
78164: LIST
78165: PUSH
78166: LD_INT 30
78168: PUSH
78169: LD_INT 5
78171: PUSH
78172: EMPTY
78173: LIST
78174: LIST
78175: PUSH
78176: EMPTY
78177: LIST
78178: LIST
78179: LIST
78180: PPUSH
78181: CALL_OW 72
78185: ST_TO_ADDR
// if not tmp then
78186: LD_VAR 0 6
78190: NOT
78191: IFFALSE 78197
// exit ;
78193: POP
78194: POP
78195: GO 78277
// for j in tmp do
78197: LD_ADDR_VAR 0 4
78201: PUSH
78202: LD_VAR 0 6
78206: PUSH
78207: FOR_IN
78208: IFFALSE 78267
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
78210: LD_ADDR_VAR 0 7
78214: PUSH
78215: LD_VAR 0 4
78219: PPUSH
78220: CALL_OW 313
78224: PPUSH
78225: LD_INT 25
78227: PUSH
78228: LD_INT 1
78230: PUSH
78231: EMPTY
78232: LIST
78233: LIST
78234: PPUSH
78235: CALL_OW 72
78239: ST_TO_ADDR
// if units then
78240: LD_VAR 0 7
78244: IFFALSE 78265
// begin ComExitBuilding ( units [ 1 ] ) ;
78246: LD_VAR 0 7
78250: PUSH
78251: LD_INT 1
78253: ARRAY
78254: PPUSH
78255: CALL_OW 122
// exit ;
78259: POP
78260: POP
78261: POP
78262: POP
78263: GO 78277
// end ; end ;
78265: GO 78207
78267: POP
78268: POP
// end ; end ; exit ;
78269: POP
78270: POP
78271: GO 78277
// end ; end ;
78273: GO 77631
78275: POP
78276: POP
// end ;
78277: LD_VAR 0 2
78281: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
78282: LD_INT 0
78284: PPUSH
78285: PPUSH
78286: PPUSH
78287: PPUSH
78288: PPUSH
78289: PPUSH
78290: PPUSH
// if not mc_bases or not skirmish then
78291: LD_EXP 23
78295: NOT
78296: PUSH
78297: LD_EXP 21
78301: NOT
78302: OR
78303: IFFALSE 78307
// exit ;
78305: GO 78572
// btype := GetBType ( building ) ;
78307: LD_ADDR_VAR 0 6
78311: PUSH
78312: LD_VAR 0 1
78316: PPUSH
78317: CALL_OW 266
78321: ST_TO_ADDR
// x := GetX ( building ) ;
78322: LD_ADDR_VAR 0 7
78326: PUSH
78327: LD_VAR 0 1
78331: PPUSH
78332: CALL_OW 250
78336: ST_TO_ADDR
// y := GetY ( building ) ;
78337: LD_ADDR_VAR 0 8
78341: PUSH
78342: LD_VAR 0 1
78346: PPUSH
78347: CALL_OW 251
78351: ST_TO_ADDR
// d := GetDir ( building ) ;
78352: LD_ADDR_VAR 0 9
78356: PUSH
78357: LD_VAR 0 1
78361: PPUSH
78362: CALL_OW 254
78366: ST_TO_ADDR
// for i = 1 to mc_bases do
78367: LD_ADDR_VAR 0 4
78371: PUSH
78372: DOUBLE
78373: LD_INT 1
78375: DEC
78376: ST_TO_ADDR
78377: LD_EXP 23
78381: PUSH
78382: FOR_TO
78383: IFFALSE 78570
// begin if not mc_build_list [ i ] then
78385: LD_EXP 28
78389: PUSH
78390: LD_VAR 0 4
78394: ARRAY
78395: NOT
78396: IFFALSE 78400
// continue ;
78398: GO 78382
// for j := 1 to mc_build_list [ i ] do
78400: LD_ADDR_VAR 0 5
78404: PUSH
78405: DOUBLE
78406: LD_INT 1
78408: DEC
78409: ST_TO_ADDR
78410: LD_EXP 28
78414: PUSH
78415: LD_VAR 0 4
78419: ARRAY
78420: PUSH
78421: FOR_TO
78422: IFFALSE 78566
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
78424: LD_VAR 0 6
78428: PUSH
78429: LD_VAR 0 7
78433: PUSH
78434: LD_VAR 0 8
78438: PUSH
78439: LD_VAR 0 9
78443: PUSH
78444: EMPTY
78445: LIST
78446: LIST
78447: LIST
78448: LIST
78449: PPUSH
78450: LD_EXP 28
78454: PUSH
78455: LD_VAR 0 4
78459: ARRAY
78460: PUSH
78461: LD_VAR 0 5
78465: ARRAY
78466: PPUSH
78467: CALL 21098 0 2
78471: IFFALSE 78564
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
78473: LD_ADDR_EXP 28
78477: PUSH
78478: LD_EXP 28
78482: PPUSH
78483: LD_VAR 0 4
78487: PPUSH
78488: LD_EXP 28
78492: PUSH
78493: LD_VAR 0 4
78497: ARRAY
78498: PPUSH
78499: LD_VAR 0 5
78503: PPUSH
78504: CALL_OW 3
78508: PPUSH
78509: CALL_OW 1
78513: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
78514: LD_ADDR_EXP 30
78518: PUSH
78519: LD_EXP 30
78523: PPUSH
78524: LD_VAR 0 4
78528: PUSH
78529: LD_EXP 30
78533: PUSH
78534: LD_VAR 0 4
78538: ARRAY
78539: PUSH
78540: LD_INT 1
78542: PLUS
78543: PUSH
78544: EMPTY
78545: LIST
78546: LIST
78547: PPUSH
78548: LD_VAR 0 1
78552: PPUSH
78553: CALL 14915 0 3
78557: ST_TO_ADDR
// exit ;
78558: POP
78559: POP
78560: POP
78561: POP
78562: GO 78572
// end ;
78564: GO 78421
78566: POP
78567: POP
// end ;
78568: GO 78382
78570: POP
78571: POP
// end ;
78572: LD_VAR 0 3
78576: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
78577: LD_INT 0
78579: PPUSH
78580: PPUSH
78581: PPUSH
// if not mc_bases or not skirmish then
78582: LD_EXP 23
78586: NOT
78587: PUSH
78588: LD_EXP 21
78592: NOT
78593: OR
78594: IFFALSE 78598
// exit ;
78596: GO 78788
// for i = 1 to mc_bases do
78598: LD_ADDR_VAR 0 4
78602: PUSH
78603: DOUBLE
78604: LD_INT 1
78606: DEC
78607: ST_TO_ADDR
78608: LD_EXP 23
78612: PUSH
78613: FOR_TO
78614: IFFALSE 78701
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
78616: LD_VAR 0 1
78620: PUSH
78621: LD_EXP 31
78625: PUSH
78626: LD_VAR 0 4
78630: ARRAY
78631: IN
78632: PUSH
78633: LD_VAR 0 1
78637: PUSH
78638: LD_EXP 32
78642: PUSH
78643: LD_VAR 0 4
78647: ARRAY
78648: IN
78649: NOT
78650: AND
78651: IFFALSE 78699
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
78653: LD_ADDR_EXP 32
78657: PUSH
78658: LD_EXP 32
78662: PPUSH
78663: LD_VAR 0 4
78667: PUSH
78668: LD_EXP 32
78672: PUSH
78673: LD_VAR 0 4
78677: ARRAY
78678: PUSH
78679: LD_INT 1
78681: PLUS
78682: PUSH
78683: EMPTY
78684: LIST
78685: LIST
78686: PPUSH
78687: LD_VAR 0 1
78691: PPUSH
78692: CALL 14915 0 3
78696: ST_TO_ADDR
// break ;
78697: GO 78701
// end ; end ;
78699: GO 78613
78701: POP
78702: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
78703: LD_VAR 0 1
78707: PPUSH
78708: CALL_OW 257
78712: PUSH
78713: LD_EXP 49
78717: IN
78718: PUSH
78719: LD_VAR 0 1
78723: PPUSH
78724: CALL_OW 266
78728: PUSH
78729: LD_INT 5
78731: EQUAL
78732: AND
78733: PUSH
78734: LD_VAR 0 2
78738: PPUSH
78739: CALL_OW 110
78743: PUSH
78744: LD_INT 18
78746: NONEQUAL
78747: AND
78748: IFFALSE 78788
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
78750: LD_VAR 0 2
78754: PPUSH
78755: CALL_OW 257
78759: PUSH
78760: LD_INT 5
78762: PUSH
78763: LD_INT 8
78765: PUSH
78766: LD_INT 9
78768: PUSH
78769: EMPTY
78770: LIST
78771: LIST
78772: LIST
78773: IN
78774: IFFALSE 78788
// SetClass ( unit , 1 ) ;
78776: LD_VAR 0 2
78780: PPUSH
78781: LD_INT 1
78783: PPUSH
78784: CALL_OW 336
// end ;
78788: LD_VAR 0 3
78792: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
78793: LD_INT 0
78795: PPUSH
78796: PPUSH
// if not mc_bases or not skirmish then
78797: LD_EXP 23
78801: NOT
78802: PUSH
78803: LD_EXP 21
78807: NOT
78808: OR
78809: IFFALSE 78813
// exit ;
78811: GO 78929
// if GetLives ( abandoned_vehicle ) > 250 then
78813: LD_VAR 0 2
78817: PPUSH
78818: CALL_OW 256
78822: PUSH
78823: LD_INT 250
78825: GREATER
78826: IFFALSE 78830
// exit ;
78828: GO 78929
// for i = 1 to mc_bases do
78830: LD_ADDR_VAR 0 6
78834: PUSH
78835: DOUBLE
78836: LD_INT 1
78838: DEC
78839: ST_TO_ADDR
78840: LD_EXP 23
78844: PUSH
78845: FOR_TO
78846: IFFALSE 78927
// begin if driver in mc_bases [ i ] then
78848: LD_VAR 0 1
78852: PUSH
78853: LD_EXP 23
78857: PUSH
78858: LD_VAR 0 6
78862: ARRAY
78863: IN
78864: IFFALSE 78925
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
78866: LD_VAR 0 1
78870: PPUSH
78871: LD_EXP 23
78875: PUSH
78876: LD_VAR 0 6
78880: ARRAY
78881: PPUSH
78882: LD_INT 2
78884: PUSH
78885: LD_INT 30
78887: PUSH
78888: LD_INT 0
78890: PUSH
78891: EMPTY
78892: LIST
78893: LIST
78894: PUSH
78895: LD_INT 30
78897: PUSH
78898: LD_INT 1
78900: PUSH
78901: EMPTY
78902: LIST
78903: LIST
78904: PUSH
78905: EMPTY
78906: LIST
78907: LIST
78908: LIST
78909: PPUSH
78910: CALL_OW 72
78914: PUSH
78915: LD_INT 1
78917: ARRAY
78918: PPUSH
78919: CALL 47534 0 2
// break ;
78923: GO 78927
// end ; end ;
78925: GO 78845
78927: POP
78928: POP
// end ; end_of_file
78929: LD_VAR 0 5
78933: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
78934: LD_INT 0
78936: PPUSH
// ar_miner := 81 ;
78937: LD_ADDR_EXP 74
78941: PUSH
78942: LD_INT 81
78944: ST_TO_ADDR
// ar_crane := 88 ;
78945: LD_ADDR_EXP 73
78949: PUSH
78950: LD_INT 88
78952: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
78953: LD_ADDR_EXP 68
78957: PUSH
78958: LD_INT 89
78960: ST_TO_ADDR
// us_hack := 99 ;
78961: LD_ADDR_EXP 69
78965: PUSH
78966: LD_INT 99
78968: ST_TO_ADDR
// us_artillery := 97 ;
78969: LD_ADDR_EXP 70
78973: PUSH
78974: LD_INT 97
78976: ST_TO_ADDR
// ar_bio_bomb := 91 ;
78977: LD_ADDR_EXP 71
78981: PUSH
78982: LD_INT 91
78984: ST_TO_ADDR
// ar_mortar := 92 ;
78985: LD_ADDR_EXP 72
78989: PUSH
78990: LD_INT 92
78992: ST_TO_ADDR
// ru_radar := 98 ;
78993: LD_ADDR_EXP 67
78997: PUSH
78998: LD_INT 98
79000: ST_TO_ADDR
// tech_Artillery := 80 ;
79001: LD_ADDR_EXP 75
79005: PUSH
79006: LD_INT 80
79008: ST_TO_ADDR
// tech_RadMat := 81 ;
79009: LD_ADDR_EXP 76
79013: PUSH
79014: LD_INT 81
79016: ST_TO_ADDR
// tech_BasicTools := 82 ;
79017: LD_ADDR_EXP 77
79021: PUSH
79022: LD_INT 82
79024: ST_TO_ADDR
// tech_Cargo := 83 ;
79025: LD_ADDR_EXP 78
79029: PUSH
79030: LD_INT 83
79032: ST_TO_ADDR
// tech_Track := 84 ;
79033: LD_ADDR_EXP 79
79037: PUSH
79038: LD_INT 84
79040: ST_TO_ADDR
// tech_Crane := 85 ;
79041: LD_ADDR_EXP 80
79045: PUSH
79046: LD_INT 85
79048: ST_TO_ADDR
// tech_Bulldozer := 86 ;
79049: LD_ADDR_EXP 81
79053: PUSH
79054: LD_INT 86
79056: ST_TO_ADDR
// tech_Hovercraft := 87 ;
79057: LD_ADDR_EXP 82
79061: PUSH
79062: LD_INT 87
79064: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
79065: LD_ADDR_EXP 83
79069: PUSH
79070: LD_INT 88
79072: ST_TO_ADDR
// class_mastodont := 31 ;
79073: LD_ADDR_EXP 84
79077: PUSH
79078: LD_INT 31
79080: ST_TO_ADDR
// class_horse := 21 ;
79081: LD_ADDR_EXP 85
79085: PUSH
79086: LD_INT 21
79088: ST_TO_ADDR
// end ;
79089: LD_VAR 0 1
79093: RET
// every 1 do
79094: GO 79096
79096: DISABLE
// InitGlobalVariables ; end_of_file
79097: CALL 78934 0 0
79101: END
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
79102: LD_INT 0
79104: PPUSH
79105: PPUSH
79106: PPUSH
79107: PPUSH
79108: PPUSH
79109: PPUSH
79110: PPUSH
79111: PPUSH
79112: PPUSH
79113: PPUSH
79114: PPUSH
79115: PPUSH
79116: PPUSH
79117: PPUSH
79118: PPUSH
79119: PPUSH
79120: PPUSH
79121: PPUSH
79122: PPUSH
79123: PPUSH
79124: PPUSH
79125: PPUSH
79126: PPUSH
79127: PPUSH
79128: PPUSH
79129: PPUSH
79130: PPUSH
79131: PPUSH
79132: PPUSH
79133: PPUSH
79134: PPUSH
79135: PPUSH
79136: PPUSH
79137: PPUSH
// if not list then
79138: LD_VAR 0 1
79142: NOT
79143: IFFALSE 79147
// exit ;
79145: GO 83806
// base := list [ 1 ] ;
79147: LD_ADDR_VAR 0 3
79151: PUSH
79152: LD_VAR 0 1
79156: PUSH
79157: LD_INT 1
79159: ARRAY
79160: ST_TO_ADDR
// group := list [ 2 ] ;
79161: LD_ADDR_VAR 0 4
79165: PUSH
79166: LD_VAR 0 1
79170: PUSH
79171: LD_INT 2
79173: ARRAY
79174: ST_TO_ADDR
// path := list [ 3 ] ;
79175: LD_ADDR_VAR 0 5
79179: PUSH
79180: LD_VAR 0 1
79184: PUSH
79185: LD_INT 3
79187: ARRAY
79188: ST_TO_ADDR
// flags := list [ 4 ] ;
79189: LD_ADDR_VAR 0 6
79193: PUSH
79194: LD_VAR 0 1
79198: PUSH
79199: LD_INT 4
79201: ARRAY
79202: ST_TO_ADDR
// mined := [ ] ;
79203: LD_ADDR_VAR 0 27
79207: PUSH
79208: EMPTY
79209: ST_TO_ADDR
// bombed := [ ] ;
79210: LD_ADDR_VAR 0 28
79214: PUSH
79215: EMPTY
79216: ST_TO_ADDR
// healers := [ ] ;
79217: LD_ADDR_VAR 0 31
79221: PUSH
79222: EMPTY
79223: ST_TO_ADDR
// to_heal := [ ] ;
79224: LD_ADDR_VAR 0 30
79228: PUSH
79229: EMPTY
79230: ST_TO_ADDR
// repairs := [ ] ;
79231: LD_ADDR_VAR 0 33
79235: PUSH
79236: EMPTY
79237: ST_TO_ADDR
// to_repair := [ ] ;
79238: LD_ADDR_VAR 0 32
79242: PUSH
79243: EMPTY
79244: ST_TO_ADDR
// if not group or not path then
79245: LD_VAR 0 4
79249: NOT
79250: PUSH
79251: LD_VAR 0 5
79255: NOT
79256: OR
79257: IFFALSE 79261
// exit ;
79259: GO 83806
// side := GetSide ( group [ 1 ] ) ;
79261: LD_ADDR_VAR 0 35
79265: PUSH
79266: LD_VAR 0 4
79270: PUSH
79271: LD_INT 1
79273: ARRAY
79274: PPUSH
79275: CALL_OW 255
79279: ST_TO_ADDR
// if flags then
79280: LD_VAR 0 6
79284: IFFALSE 79428
// begin f_ignore_area := flags [ 1 ] ;
79286: LD_ADDR_VAR 0 17
79290: PUSH
79291: LD_VAR 0 6
79295: PUSH
79296: LD_INT 1
79298: ARRAY
79299: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
79300: LD_ADDR_VAR 0 18
79304: PUSH
79305: LD_VAR 0 6
79309: PUSH
79310: LD_INT 2
79312: ARRAY
79313: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
79314: LD_ADDR_VAR 0 19
79318: PUSH
79319: LD_VAR 0 6
79323: PUSH
79324: LD_INT 3
79326: ARRAY
79327: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
79328: LD_ADDR_VAR 0 20
79332: PUSH
79333: LD_VAR 0 6
79337: PUSH
79338: LD_INT 4
79340: ARRAY
79341: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
79342: LD_ADDR_VAR 0 21
79346: PUSH
79347: LD_VAR 0 6
79351: PUSH
79352: LD_INT 5
79354: ARRAY
79355: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
79356: LD_ADDR_VAR 0 22
79360: PUSH
79361: LD_VAR 0 6
79365: PUSH
79366: LD_INT 6
79368: ARRAY
79369: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
79370: LD_ADDR_VAR 0 23
79374: PUSH
79375: LD_VAR 0 6
79379: PUSH
79380: LD_INT 7
79382: ARRAY
79383: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
79384: LD_ADDR_VAR 0 24
79388: PUSH
79389: LD_VAR 0 6
79393: PUSH
79394: LD_INT 8
79396: ARRAY
79397: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
79398: LD_ADDR_VAR 0 25
79402: PUSH
79403: LD_VAR 0 6
79407: PUSH
79408: LD_INT 9
79410: ARRAY
79411: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
79412: LD_ADDR_VAR 0 26
79416: PUSH
79417: LD_VAR 0 6
79421: PUSH
79422: LD_INT 10
79424: ARRAY
79425: ST_TO_ADDR
// end else
79426: GO 79508
// begin f_ignore_area := false ;
79428: LD_ADDR_VAR 0 17
79432: PUSH
79433: LD_INT 0
79435: ST_TO_ADDR
// f_capture := false ;
79436: LD_ADDR_VAR 0 18
79440: PUSH
79441: LD_INT 0
79443: ST_TO_ADDR
// f_ignore_civ := false ;
79444: LD_ADDR_VAR 0 19
79448: PUSH
79449: LD_INT 0
79451: ST_TO_ADDR
// f_murder := false ;
79452: LD_ADDR_VAR 0 20
79456: PUSH
79457: LD_INT 0
79459: ST_TO_ADDR
// f_mines := false ;
79460: LD_ADDR_VAR 0 21
79464: PUSH
79465: LD_INT 0
79467: ST_TO_ADDR
// f_repair := false ;
79468: LD_ADDR_VAR 0 22
79472: PUSH
79473: LD_INT 0
79475: ST_TO_ADDR
// f_heal := false ;
79476: LD_ADDR_VAR 0 23
79480: PUSH
79481: LD_INT 0
79483: ST_TO_ADDR
// f_spacetime := false ;
79484: LD_ADDR_VAR 0 24
79488: PUSH
79489: LD_INT 0
79491: ST_TO_ADDR
// f_attack_depot := false ;
79492: LD_ADDR_VAR 0 25
79496: PUSH
79497: LD_INT 0
79499: ST_TO_ADDR
// f_crawl := false ;
79500: LD_ADDR_VAR 0 26
79504: PUSH
79505: LD_INT 0
79507: ST_TO_ADDR
// end ; if f_heal then
79508: LD_VAR 0 23
79512: IFFALSE 79539
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
79514: LD_ADDR_VAR 0 31
79518: PUSH
79519: LD_VAR 0 4
79523: PPUSH
79524: LD_INT 25
79526: PUSH
79527: LD_INT 4
79529: PUSH
79530: EMPTY
79531: LIST
79532: LIST
79533: PPUSH
79534: CALL_OW 72
79538: ST_TO_ADDR
// if f_repair then
79539: LD_VAR 0 22
79543: IFFALSE 79570
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
79545: LD_ADDR_VAR 0 33
79549: PUSH
79550: LD_VAR 0 4
79554: PPUSH
79555: LD_INT 25
79557: PUSH
79558: LD_INT 3
79560: PUSH
79561: EMPTY
79562: LIST
79563: LIST
79564: PPUSH
79565: CALL_OW 72
79569: ST_TO_ADDR
// units_path := [ ] ;
79570: LD_ADDR_VAR 0 16
79574: PUSH
79575: EMPTY
79576: ST_TO_ADDR
// for i = 1 to group do
79577: LD_ADDR_VAR 0 7
79581: PUSH
79582: DOUBLE
79583: LD_INT 1
79585: DEC
79586: ST_TO_ADDR
79587: LD_VAR 0 4
79591: PUSH
79592: FOR_TO
79593: IFFALSE 79622
// units_path := Replace ( units_path , i , path ) ;
79595: LD_ADDR_VAR 0 16
79599: PUSH
79600: LD_VAR 0 16
79604: PPUSH
79605: LD_VAR 0 7
79609: PPUSH
79610: LD_VAR 0 5
79614: PPUSH
79615: CALL_OW 1
79619: ST_TO_ADDR
79620: GO 79592
79622: POP
79623: POP
// repeat for i = group downto 1 do
79624: LD_ADDR_VAR 0 7
79628: PUSH
79629: DOUBLE
79630: LD_VAR 0 4
79634: INC
79635: ST_TO_ADDR
79636: LD_INT 1
79638: PUSH
79639: FOR_DOWNTO
79640: IFFALSE 83762
// begin wait ( 5 ) ;
79642: LD_INT 5
79644: PPUSH
79645: CALL_OW 67
// tmp := [ ] ;
79649: LD_ADDR_VAR 0 14
79653: PUSH
79654: EMPTY
79655: ST_TO_ADDR
// attacking := false ;
79656: LD_ADDR_VAR 0 29
79660: PUSH
79661: LD_INT 0
79663: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
79664: LD_VAR 0 4
79668: PUSH
79669: LD_VAR 0 7
79673: ARRAY
79674: PPUSH
79675: CALL_OW 301
79679: PUSH
79680: LD_VAR 0 4
79684: PUSH
79685: LD_VAR 0 7
79689: ARRAY
79690: NOT
79691: OR
79692: IFFALSE 79801
// begin if GetType ( group [ i ] ) = unit_human then
79694: LD_VAR 0 4
79698: PUSH
79699: LD_VAR 0 7
79703: ARRAY
79704: PPUSH
79705: CALL_OW 247
79709: PUSH
79710: LD_INT 1
79712: EQUAL
79713: IFFALSE 79759
// begin to_heal := to_heal diff group [ i ] ;
79715: LD_ADDR_VAR 0 30
79719: PUSH
79720: LD_VAR 0 30
79724: PUSH
79725: LD_VAR 0 4
79729: PUSH
79730: LD_VAR 0 7
79734: ARRAY
79735: DIFF
79736: ST_TO_ADDR
// healers := healers diff group [ i ] ;
79737: LD_ADDR_VAR 0 31
79741: PUSH
79742: LD_VAR 0 31
79746: PUSH
79747: LD_VAR 0 4
79751: PUSH
79752: LD_VAR 0 7
79756: ARRAY
79757: DIFF
79758: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
79759: LD_ADDR_VAR 0 4
79763: PUSH
79764: LD_VAR 0 4
79768: PPUSH
79769: LD_VAR 0 7
79773: PPUSH
79774: CALL_OW 3
79778: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
79779: LD_ADDR_VAR 0 16
79783: PUSH
79784: LD_VAR 0 16
79788: PPUSH
79789: LD_VAR 0 7
79793: PPUSH
79794: CALL_OW 3
79798: ST_TO_ADDR
// continue ;
79799: GO 79639
// end ; if f_repair then
79801: LD_VAR 0 22
79805: IFFALSE 80294
// begin if GetType ( group [ i ] ) = unit_vehicle then
79807: LD_VAR 0 4
79811: PUSH
79812: LD_VAR 0 7
79816: ARRAY
79817: PPUSH
79818: CALL_OW 247
79822: PUSH
79823: LD_INT 2
79825: EQUAL
79826: IFFALSE 80016
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
79828: LD_VAR 0 4
79832: PUSH
79833: LD_VAR 0 7
79837: ARRAY
79838: PPUSH
79839: CALL_OW 256
79843: PUSH
79844: LD_INT 700
79846: LESS
79847: PUSH
79848: LD_VAR 0 4
79852: PUSH
79853: LD_VAR 0 7
79857: ARRAY
79858: PUSH
79859: LD_VAR 0 32
79863: IN
79864: NOT
79865: AND
79866: IFFALSE 79890
// to_repair := to_repair union group [ i ] ;
79868: LD_ADDR_VAR 0 32
79872: PUSH
79873: LD_VAR 0 32
79877: PUSH
79878: LD_VAR 0 4
79882: PUSH
79883: LD_VAR 0 7
79887: ARRAY
79888: UNION
79889: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
79890: LD_VAR 0 4
79894: PUSH
79895: LD_VAR 0 7
79899: ARRAY
79900: PPUSH
79901: CALL_OW 256
79905: PUSH
79906: LD_INT 1000
79908: EQUAL
79909: PUSH
79910: LD_VAR 0 4
79914: PUSH
79915: LD_VAR 0 7
79919: ARRAY
79920: PUSH
79921: LD_VAR 0 32
79925: IN
79926: AND
79927: IFFALSE 79951
// to_repair := to_repair diff group [ i ] ;
79929: LD_ADDR_VAR 0 32
79933: PUSH
79934: LD_VAR 0 32
79938: PUSH
79939: LD_VAR 0 4
79943: PUSH
79944: LD_VAR 0 7
79948: ARRAY
79949: DIFF
79950: ST_TO_ADDR
// if group [ i ] in to_repair then
79951: LD_VAR 0 4
79955: PUSH
79956: LD_VAR 0 7
79960: ARRAY
79961: PUSH
79962: LD_VAR 0 32
79966: IN
79967: IFFALSE 80014
// begin if not IsInArea ( group [ i ] , f_repair ) then
79969: LD_VAR 0 4
79973: PUSH
79974: LD_VAR 0 7
79978: ARRAY
79979: PPUSH
79980: LD_VAR 0 22
79984: PPUSH
79985: CALL_OW 308
79989: NOT
79990: IFFALSE 80012
// ComMoveToArea ( group [ i ] , f_repair ) ;
79992: LD_VAR 0 4
79996: PUSH
79997: LD_VAR 0 7
80001: ARRAY
80002: PPUSH
80003: LD_VAR 0 22
80007: PPUSH
80008: CALL_OW 113
// continue ;
80012: GO 79639
// end ; end else
80014: GO 80294
// if group [ i ] in repairs then
80016: LD_VAR 0 4
80020: PUSH
80021: LD_VAR 0 7
80025: ARRAY
80026: PUSH
80027: LD_VAR 0 33
80031: IN
80032: IFFALSE 80294
// begin if IsInUnit ( group [ i ] ) then
80034: LD_VAR 0 4
80038: PUSH
80039: LD_VAR 0 7
80043: ARRAY
80044: PPUSH
80045: CALL_OW 310
80049: IFFALSE 80117
// begin z := IsInUnit ( group [ i ] ) ;
80051: LD_ADDR_VAR 0 13
80055: PUSH
80056: LD_VAR 0 4
80060: PUSH
80061: LD_VAR 0 7
80065: ARRAY
80066: PPUSH
80067: CALL_OW 310
80071: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
80072: LD_VAR 0 13
80076: PUSH
80077: LD_VAR 0 32
80081: IN
80082: PUSH
80083: LD_VAR 0 13
80087: PPUSH
80088: LD_VAR 0 22
80092: PPUSH
80093: CALL_OW 308
80097: AND
80098: IFFALSE 80115
// ComExitVehicle ( group [ i ] ) ;
80100: LD_VAR 0 4
80104: PUSH
80105: LD_VAR 0 7
80109: ARRAY
80110: PPUSH
80111: CALL_OW 121
// end else
80115: GO 80294
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
80117: LD_ADDR_VAR 0 13
80121: PUSH
80122: LD_VAR 0 4
80126: PPUSH
80127: LD_INT 95
80129: PUSH
80130: LD_VAR 0 22
80134: PUSH
80135: EMPTY
80136: LIST
80137: LIST
80138: PUSH
80139: LD_INT 58
80141: PUSH
80142: EMPTY
80143: LIST
80144: PUSH
80145: EMPTY
80146: LIST
80147: LIST
80148: PPUSH
80149: CALL_OW 72
80153: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
80154: LD_VAR 0 4
80158: PUSH
80159: LD_VAR 0 7
80163: ARRAY
80164: PPUSH
80165: CALL_OW 314
80169: NOT
80170: IFFALSE 80292
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
80172: LD_ADDR_VAR 0 10
80176: PUSH
80177: LD_VAR 0 13
80181: PPUSH
80182: LD_VAR 0 4
80186: PUSH
80187: LD_VAR 0 7
80191: ARRAY
80192: PPUSH
80193: CALL_OW 74
80197: ST_TO_ADDR
// if not x then
80198: LD_VAR 0 10
80202: NOT
80203: IFFALSE 80207
// continue ;
80205: GO 79639
// if GetLives ( x ) < 1000 then
80207: LD_VAR 0 10
80211: PPUSH
80212: CALL_OW 256
80216: PUSH
80217: LD_INT 1000
80219: LESS
80220: IFFALSE 80244
// ComRepairVehicle ( group [ i ] , x ) else
80222: LD_VAR 0 4
80226: PUSH
80227: LD_VAR 0 7
80231: ARRAY
80232: PPUSH
80233: LD_VAR 0 10
80237: PPUSH
80238: CALL_OW 129
80242: GO 80292
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
80244: LD_VAR 0 23
80248: PUSH
80249: LD_VAR 0 4
80253: PUSH
80254: LD_VAR 0 7
80258: ARRAY
80259: PPUSH
80260: CALL_OW 256
80264: PUSH
80265: LD_INT 1000
80267: LESS
80268: AND
80269: NOT
80270: IFFALSE 80292
// ComEnterUnit ( group [ i ] , x ) ;
80272: LD_VAR 0 4
80276: PUSH
80277: LD_VAR 0 7
80281: ARRAY
80282: PPUSH
80283: LD_VAR 0 10
80287: PPUSH
80288: CALL_OW 120
// end ; continue ;
80292: GO 79639
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
80294: LD_VAR 0 23
80298: PUSH
80299: LD_VAR 0 4
80303: PUSH
80304: LD_VAR 0 7
80308: ARRAY
80309: PPUSH
80310: CALL_OW 247
80314: PUSH
80315: LD_INT 1
80317: EQUAL
80318: AND
80319: IFFALSE 80797
// begin if group [ i ] in healers then
80321: LD_VAR 0 4
80325: PUSH
80326: LD_VAR 0 7
80330: ARRAY
80331: PUSH
80332: LD_VAR 0 31
80336: IN
80337: IFFALSE 80610
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
80339: LD_VAR 0 4
80343: PUSH
80344: LD_VAR 0 7
80348: ARRAY
80349: PPUSH
80350: LD_VAR 0 23
80354: PPUSH
80355: CALL_OW 308
80359: NOT
80360: PUSH
80361: LD_VAR 0 4
80365: PUSH
80366: LD_VAR 0 7
80370: ARRAY
80371: PPUSH
80372: CALL_OW 314
80376: NOT
80377: AND
80378: IFFALSE 80402
// ComMoveToArea ( group [ i ] , f_heal ) else
80380: LD_VAR 0 4
80384: PUSH
80385: LD_VAR 0 7
80389: ARRAY
80390: PPUSH
80391: LD_VAR 0 23
80395: PPUSH
80396: CALL_OW 113
80400: GO 80608
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
80402: LD_VAR 0 4
80406: PUSH
80407: LD_VAR 0 7
80411: ARRAY
80412: PPUSH
80413: CALL 43996 0 1
80417: PPUSH
80418: CALL_OW 256
80422: PUSH
80423: LD_INT 1000
80425: EQUAL
80426: IFFALSE 80445
// ComStop ( group [ i ] ) else
80428: LD_VAR 0 4
80432: PUSH
80433: LD_VAR 0 7
80437: ARRAY
80438: PPUSH
80439: CALL_OW 141
80443: GO 80608
// if not HasTask ( group [ i ] ) and to_heal then
80445: LD_VAR 0 4
80449: PUSH
80450: LD_VAR 0 7
80454: ARRAY
80455: PPUSH
80456: CALL_OW 314
80460: NOT
80461: PUSH
80462: LD_VAR 0 30
80466: AND
80467: IFFALSE 80608
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
80469: LD_ADDR_VAR 0 13
80473: PUSH
80474: LD_VAR 0 30
80478: PPUSH
80479: LD_INT 3
80481: PUSH
80482: LD_INT 54
80484: PUSH
80485: EMPTY
80486: LIST
80487: PUSH
80488: EMPTY
80489: LIST
80490: LIST
80491: PPUSH
80492: CALL_OW 72
80496: PPUSH
80497: LD_VAR 0 4
80501: PUSH
80502: LD_VAR 0 7
80506: ARRAY
80507: PPUSH
80508: CALL_OW 74
80512: ST_TO_ADDR
// if z then
80513: LD_VAR 0 13
80517: IFFALSE 80608
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
80519: LD_INT 91
80521: PUSH
80522: LD_VAR 0 13
80526: PUSH
80527: LD_INT 10
80529: PUSH
80530: EMPTY
80531: LIST
80532: LIST
80533: LIST
80534: PUSH
80535: LD_INT 81
80537: PUSH
80538: LD_VAR 0 13
80542: PPUSH
80543: CALL_OW 255
80547: PUSH
80548: EMPTY
80549: LIST
80550: LIST
80551: PUSH
80552: EMPTY
80553: LIST
80554: LIST
80555: PPUSH
80556: CALL_OW 69
80560: PUSH
80561: LD_INT 0
80563: EQUAL
80564: IFFALSE 80588
// ComHeal ( group [ i ] , z ) else
80566: LD_VAR 0 4
80570: PUSH
80571: LD_VAR 0 7
80575: ARRAY
80576: PPUSH
80577: LD_VAR 0 13
80581: PPUSH
80582: CALL_OW 128
80586: GO 80608
// ComMoveToArea ( group [ i ] , f_heal ) ;
80588: LD_VAR 0 4
80592: PUSH
80593: LD_VAR 0 7
80597: ARRAY
80598: PPUSH
80599: LD_VAR 0 23
80603: PPUSH
80604: CALL_OW 113
// end ; continue ;
80608: GO 79639
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
80610: LD_VAR 0 4
80614: PUSH
80615: LD_VAR 0 7
80619: ARRAY
80620: PPUSH
80621: CALL_OW 256
80625: PUSH
80626: LD_INT 700
80628: LESS
80629: PUSH
80630: LD_VAR 0 4
80634: PUSH
80635: LD_VAR 0 7
80639: ARRAY
80640: PUSH
80641: LD_VAR 0 30
80645: IN
80646: NOT
80647: AND
80648: IFFALSE 80672
// to_heal := to_heal union group [ i ] ;
80650: LD_ADDR_VAR 0 30
80654: PUSH
80655: LD_VAR 0 30
80659: PUSH
80660: LD_VAR 0 4
80664: PUSH
80665: LD_VAR 0 7
80669: ARRAY
80670: UNION
80671: ST_TO_ADDR
// if group [ i ] in to_heal then
80672: LD_VAR 0 4
80676: PUSH
80677: LD_VAR 0 7
80681: ARRAY
80682: PUSH
80683: LD_VAR 0 30
80687: IN
80688: IFFALSE 80797
// begin if GetLives ( group [ i ] ) = 1000 then
80690: LD_VAR 0 4
80694: PUSH
80695: LD_VAR 0 7
80699: ARRAY
80700: PPUSH
80701: CALL_OW 256
80705: PUSH
80706: LD_INT 1000
80708: EQUAL
80709: IFFALSE 80735
// to_heal := to_heal diff group [ i ] else
80711: LD_ADDR_VAR 0 30
80715: PUSH
80716: LD_VAR 0 30
80720: PUSH
80721: LD_VAR 0 4
80725: PUSH
80726: LD_VAR 0 7
80730: ARRAY
80731: DIFF
80732: ST_TO_ADDR
80733: GO 80797
// begin if not IsInArea ( group [ i ] , to_heal ) then
80735: LD_VAR 0 4
80739: PUSH
80740: LD_VAR 0 7
80744: ARRAY
80745: PPUSH
80746: LD_VAR 0 30
80750: PPUSH
80751: CALL_OW 308
80755: NOT
80756: IFFALSE 80780
// ComMoveToArea ( group [ i ] , f_heal ) else
80758: LD_VAR 0 4
80762: PUSH
80763: LD_VAR 0 7
80767: ARRAY
80768: PPUSH
80769: LD_VAR 0 23
80773: PPUSH
80774: CALL_OW 113
80778: GO 80795
// ComHold ( group [ i ] ) ;
80780: LD_VAR 0 4
80784: PUSH
80785: LD_VAR 0 7
80789: ARRAY
80790: PPUSH
80791: CALL_OW 140
// continue ;
80795: GO 79639
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
80797: LD_VAR 0 4
80801: PUSH
80802: LD_VAR 0 7
80806: ARRAY
80807: PPUSH
80808: LD_INT 10
80810: PPUSH
80811: CALL 42416 0 2
80815: NOT
80816: PUSH
80817: LD_VAR 0 16
80821: PUSH
80822: LD_VAR 0 7
80826: ARRAY
80827: PUSH
80828: EMPTY
80829: EQUAL
80830: NOT
80831: AND
80832: IFFALSE 81098
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
80834: LD_VAR 0 4
80838: PUSH
80839: LD_VAR 0 7
80843: ARRAY
80844: PPUSH
80845: CALL_OW 262
80849: PUSH
80850: LD_INT 1
80852: PUSH
80853: LD_INT 2
80855: PUSH
80856: EMPTY
80857: LIST
80858: LIST
80859: IN
80860: IFFALSE 80901
// if GetFuel ( group [ i ] ) < 10 then
80862: LD_VAR 0 4
80866: PUSH
80867: LD_VAR 0 7
80871: ARRAY
80872: PPUSH
80873: CALL_OW 261
80877: PUSH
80878: LD_INT 10
80880: LESS
80881: IFFALSE 80901
// SetFuel ( group [ i ] , 12 ) ;
80883: LD_VAR 0 4
80887: PUSH
80888: LD_VAR 0 7
80892: ARRAY
80893: PPUSH
80894: LD_INT 12
80896: PPUSH
80897: CALL_OW 240
// if units_path [ i ] then
80901: LD_VAR 0 16
80905: PUSH
80906: LD_VAR 0 7
80910: ARRAY
80911: IFFALSE 81096
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
80913: LD_VAR 0 4
80917: PUSH
80918: LD_VAR 0 7
80922: ARRAY
80923: PPUSH
80924: LD_VAR 0 16
80928: PUSH
80929: LD_VAR 0 7
80933: ARRAY
80934: PUSH
80935: LD_INT 1
80937: ARRAY
80938: PUSH
80939: LD_INT 1
80941: ARRAY
80942: PPUSH
80943: LD_VAR 0 16
80947: PUSH
80948: LD_VAR 0 7
80952: ARRAY
80953: PUSH
80954: LD_INT 1
80956: ARRAY
80957: PUSH
80958: LD_INT 2
80960: ARRAY
80961: PPUSH
80962: CALL_OW 297
80966: PUSH
80967: LD_INT 6
80969: GREATER
80970: IFFALSE 81045
// begin if not HasTask ( group [ i ] ) then
80972: LD_VAR 0 4
80976: PUSH
80977: LD_VAR 0 7
80981: ARRAY
80982: PPUSH
80983: CALL_OW 314
80987: NOT
80988: IFFALSE 81043
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
80990: LD_VAR 0 4
80994: PUSH
80995: LD_VAR 0 7
80999: ARRAY
81000: PPUSH
81001: LD_VAR 0 16
81005: PUSH
81006: LD_VAR 0 7
81010: ARRAY
81011: PUSH
81012: LD_INT 1
81014: ARRAY
81015: PUSH
81016: LD_INT 1
81018: ARRAY
81019: PPUSH
81020: LD_VAR 0 16
81024: PUSH
81025: LD_VAR 0 7
81029: ARRAY
81030: PUSH
81031: LD_INT 1
81033: ARRAY
81034: PUSH
81035: LD_INT 2
81037: ARRAY
81038: PPUSH
81039: CALL_OW 114
// end else
81043: GO 81096
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
81045: LD_ADDR_VAR 0 15
81049: PUSH
81050: LD_VAR 0 16
81054: PUSH
81055: LD_VAR 0 7
81059: ARRAY
81060: PPUSH
81061: LD_INT 1
81063: PPUSH
81064: CALL_OW 3
81068: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
81069: LD_ADDR_VAR 0 16
81073: PUSH
81074: LD_VAR 0 16
81078: PPUSH
81079: LD_VAR 0 7
81083: PPUSH
81084: LD_VAR 0 15
81088: PPUSH
81089: CALL_OW 1
81093: ST_TO_ADDR
// continue ;
81094: GO 79639
// end ; end ; end else
81096: GO 83760
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
81098: LD_ADDR_VAR 0 14
81102: PUSH
81103: LD_INT 81
81105: PUSH
81106: LD_VAR 0 4
81110: PUSH
81111: LD_VAR 0 7
81115: ARRAY
81116: PPUSH
81117: CALL_OW 255
81121: PUSH
81122: EMPTY
81123: LIST
81124: LIST
81125: PPUSH
81126: CALL_OW 69
81130: ST_TO_ADDR
// if not tmp then
81131: LD_VAR 0 14
81135: NOT
81136: IFFALSE 81140
// continue ;
81138: GO 79639
// if f_ignore_area then
81140: LD_VAR 0 17
81144: IFFALSE 81232
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
81146: LD_ADDR_VAR 0 15
81150: PUSH
81151: LD_VAR 0 14
81155: PPUSH
81156: LD_INT 3
81158: PUSH
81159: LD_INT 92
81161: PUSH
81162: LD_VAR 0 17
81166: PUSH
81167: LD_INT 1
81169: ARRAY
81170: PUSH
81171: LD_VAR 0 17
81175: PUSH
81176: LD_INT 2
81178: ARRAY
81179: PUSH
81180: LD_VAR 0 17
81184: PUSH
81185: LD_INT 3
81187: ARRAY
81188: PUSH
81189: EMPTY
81190: LIST
81191: LIST
81192: LIST
81193: LIST
81194: PUSH
81195: EMPTY
81196: LIST
81197: LIST
81198: PPUSH
81199: CALL_OW 72
81203: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
81204: LD_VAR 0 14
81208: PUSH
81209: LD_VAR 0 15
81213: DIFF
81214: IFFALSE 81232
// tmp := tmp diff tmp2 ;
81216: LD_ADDR_VAR 0 14
81220: PUSH
81221: LD_VAR 0 14
81225: PUSH
81226: LD_VAR 0 15
81230: DIFF
81231: ST_TO_ADDR
// end ; if not f_murder then
81232: LD_VAR 0 20
81236: NOT
81237: IFFALSE 81295
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
81239: LD_ADDR_VAR 0 15
81243: PUSH
81244: LD_VAR 0 14
81248: PPUSH
81249: LD_INT 3
81251: PUSH
81252: LD_INT 50
81254: PUSH
81255: EMPTY
81256: LIST
81257: PUSH
81258: EMPTY
81259: LIST
81260: LIST
81261: PPUSH
81262: CALL_OW 72
81266: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
81267: LD_VAR 0 14
81271: PUSH
81272: LD_VAR 0 15
81276: DIFF
81277: IFFALSE 81295
// tmp := tmp diff tmp2 ;
81279: LD_ADDR_VAR 0 14
81283: PUSH
81284: LD_VAR 0 14
81288: PUSH
81289: LD_VAR 0 15
81293: DIFF
81294: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
81295: LD_ADDR_VAR 0 14
81299: PUSH
81300: LD_VAR 0 4
81304: PUSH
81305: LD_VAR 0 7
81309: ARRAY
81310: PPUSH
81311: LD_VAR 0 14
81315: PPUSH
81316: LD_INT 1
81318: PPUSH
81319: LD_INT 1
81321: PPUSH
81322: CALL 15350 0 4
81326: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
81327: LD_VAR 0 4
81331: PUSH
81332: LD_VAR 0 7
81336: ARRAY
81337: PPUSH
81338: CALL_OW 257
81342: PUSH
81343: LD_INT 1
81345: EQUAL
81346: IFFALSE 81794
// begin if WantPlant ( group [ i ] ) then
81348: LD_VAR 0 4
81352: PUSH
81353: LD_VAR 0 7
81357: ARRAY
81358: PPUSH
81359: CALL 14851 0 1
81363: IFFALSE 81367
// continue ;
81365: GO 79639
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
81367: LD_VAR 0 18
81371: PUSH
81372: LD_VAR 0 4
81376: PUSH
81377: LD_VAR 0 7
81381: ARRAY
81382: PPUSH
81383: CALL_OW 310
81387: NOT
81388: AND
81389: PUSH
81390: LD_VAR 0 14
81394: PUSH
81395: LD_INT 1
81397: ARRAY
81398: PUSH
81399: LD_VAR 0 14
81403: PPUSH
81404: LD_INT 21
81406: PUSH
81407: LD_INT 2
81409: PUSH
81410: EMPTY
81411: LIST
81412: LIST
81413: PUSH
81414: LD_INT 58
81416: PUSH
81417: EMPTY
81418: LIST
81419: PUSH
81420: EMPTY
81421: LIST
81422: LIST
81423: PPUSH
81424: CALL_OW 72
81428: IN
81429: AND
81430: IFFALSE 81466
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
81432: LD_VAR 0 4
81436: PUSH
81437: LD_VAR 0 7
81441: ARRAY
81442: PPUSH
81443: LD_VAR 0 14
81447: PUSH
81448: LD_INT 1
81450: ARRAY
81451: PPUSH
81452: CALL_OW 120
// attacking := true ;
81456: LD_ADDR_VAR 0 29
81460: PUSH
81461: LD_INT 1
81463: ST_TO_ADDR
// continue ;
81464: GO 79639
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
81466: LD_VAR 0 26
81470: PUSH
81471: LD_VAR 0 4
81475: PUSH
81476: LD_VAR 0 7
81480: ARRAY
81481: PPUSH
81482: CALL_OW 257
81486: PUSH
81487: LD_INT 1
81489: EQUAL
81490: AND
81491: PUSH
81492: LD_VAR 0 4
81496: PUSH
81497: LD_VAR 0 7
81501: ARRAY
81502: PPUSH
81503: CALL_OW 256
81507: PUSH
81508: LD_INT 800
81510: LESS
81511: AND
81512: PUSH
81513: LD_VAR 0 4
81517: PUSH
81518: LD_VAR 0 7
81522: ARRAY
81523: PPUSH
81524: CALL_OW 318
81528: NOT
81529: AND
81530: IFFALSE 81547
// ComCrawl ( group [ i ] ) ;
81532: LD_VAR 0 4
81536: PUSH
81537: LD_VAR 0 7
81541: ARRAY
81542: PPUSH
81543: CALL_OW 137
// if f_mines then
81547: LD_VAR 0 21
81551: IFFALSE 81794
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
81553: LD_VAR 0 14
81557: PUSH
81558: LD_INT 1
81560: ARRAY
81561: PPUSH
81562: CALL_OW 247
81566: PUSH
81567: LD_INT 3
81569: EQUAL
81570: PUSH
81571: LD_VAR 0 14
81575: PUSH
81576: LD_INT 1
81578: ARRAY
81579: PUSH
81580: LD_VAR 0 27
81584: IN
81585: NOT
81586: AND
81587: IFFALSE 81794
// begin x := GetX ( tmp [ 1 ] ) ;
81589: LD_ADDR_VAR 0 10
81593: PUSH
81594: LD_VAR 0 14
81598: PUSH
81599: LD_INT 1
81601: ARRAY
81602: PPUSH
81603: CALL_OW 250
81607: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
81608: LD_ADDR_VAR 0 11
81612: PUSH
81613: LD_VAR 0 14
81617: PUSH
81618: LD_INT 1
81620: ARRAY
81621: PPUSH
81622: CALL_OW 251
81626: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
81627: LD_ADDR_VAR 0 12
81631: PUSH
81632: LD_VAR 0 4
81636: PUSH
81637: LD_VAR 0 7
81641: ARRAY
81642: PPUSH
81643: CALL 42501 0 1
81647: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
81648: LD_VAR 0 4
81652: PUSH
81653: LD_VAR 0 7
81657: ARRAY
81658: PPUSH
81659: LD_VAR 0 10
81663: PPUSH
81664: LD_VAR 0 11
81668: PPUSH
81669: LD_VAR 0 14
81673: PUSH
81674: LD_INT 1
81676: ARRAY
81677: PPUSH
81678: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
81682: LD_VAR 0 4
81686: PUSH
81687: LD_VAR 0 7
81691: ARRAY
81692: PPUSH
81693: LD_VAR 0 10
81697: PPUSH
81698: LD_VAR 0 12
81702: PPUSH
81703: LD_INT 7
81705: PPUSH
81706: CALL_OW 272
81710: PPUSH
81711: LD_VAR 0 11
81715: PPUSH
81716: LD_VAR 0 12
81720: PPUSH
81721: LD_INT 7
81723: PPUSH
81724: CALL_OW 273
81728: PPUSH
81729: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
81733: LD_VAR 0 4
81737: PUSH
81738: LD_VAR 0 7
81742: ARRAY
81743: PPUSH
81744: LD_INT 71
81746: PPUSH
81747: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
81751: LD_ADDR_VAR 0 27
81755: PUSH
81756: LD_VAR 0 27
81760: PPUSH
81761: LD_VAR 0 27
81765: PUSH
81766: LD_INT 1
81768: PLUS
81769: PPUSH
81770: LD_VAR 0 14
81774: PUSH
81775: LD_INT 1
81777: ARRAY
81778: PPUSH
81779: CALL_OW 1
81783: ST_TO_ADDR
// attacking := true ;
81784: LD_ADDR_VAR 0 29
81788: PUSH
81789: LD_INT 1
81791: ST_TO_ADDR
// continue ;
81792: GO 79639
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
81794: LD_VAR 0 4
81798: PUSH
81799: LD_VAR 0 7
81803: ARRAY
81804: PPUSH
81805: CALL_OW 257
81809: PUSH
81810: LD_INT 17
81812: EQUAL
81813: PUSH
81814: LD_VAR 0 4
81818: PUSH
81819: LD_VAR 0 7
81823: ARRAY
81824: PPUSH
81825: CALL_OW 110
81829: PUSH
81830: LD_INT 71
81832: EQUAL
81833: NOT
81834: AND
81835: IFFALSE 81981
// begin attacking := false ;
81837: LD_ADDR_VAR 0 29
81841: PUSH
81842: LD_INT 0
81844: ST_TO_ADDR
// k := 5 ;
81845: LD_ADDR_VAR 0 9
81849: PUSH
81850: LD_INT 5
81852: ST_TO_ADDR
// if tmp < k then
81853: LD_VAR 0 14
81857: PUSH
81858: LD_VAR 0 9
81862: LESS
81863: IFFALSE 81875
// k := tmp ;
81865: LD_ADDR_VAR 0 9
81869: PUSH
81870: LD_VAR 0 14
81874: ST_TO_ADDR
// for j = 1 to k do
81875: LD_ADDR_VAR 0 8
81879: PUSH
81880: DOUBLE
81881: LD_INT 1
81883: DEC
81884: ST_TO_ADDR
81885: LD_VAR 0 9
81889: PUSH
81890: FOR_TO
81891: IFFALSE 81979
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
81893: LD_VAR 0 14
81897: PUSH
81898: LD_VAR 0 8
81902: ARRAY
81903: PUSH
81904: LD_VAR 0 14
81908: PPUSH
81909: LD_INT 58
81911: PUSH
81912: EMPTY
81913: LIST
81914: PPUSH
81915: CALL_OW 72
81919: IN
81920: NOT
81921: IFFALSE 81977
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
81923: LD_VAR 0 4
81927: PUSH
81928: LD_VAR 0 7
81932: ARRAY
81933: PPUSH
81934: LD_VAR 0 14
81938: PUSH
81939: LD_VAR 0 8
81943: ARRAY
81944: PPUSH
81945: CALL_OW 115
// attacking := true ;
81949: LD_ADDR_VAR 0 29
81953: PUSH
81954: LD_INT 1
81956: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
81957: LD_VAR 0 4
81961: PUSH
81962: LD_VAR 0 7
81966: ARRAY
81967: PPUSH
81968: LD_INT 71
81970: PPUSH
81971: CALL_OW 109
// continue ;
81975: GO 81890
// end ; end ;
81977: GO 81890
81979: POP
81980: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
81981: LD_VAR 0 4
81985: PUSH
81986: LD_VAR 0 7
81990: ARRAY
81991: PPUSH
81992: CALL_OW 257
81996: PUSH
81997: LD_INT 8
81999: EQUAL
82000: PUSH
82001: LD_VAR 0 4
82005: PUSH
82006: LD_VAR 0 7
82010: ARRAY
82011: PPUSH
82012: CALL_OW 264
82016: PUSH
82017: LD_INT 28
82019: PUSH
82020: LD_INT 45
82022: PUSH
82023: LD_INT 7
82025: PUSH
82026: LD_INT 47
82028: PUSH
82029: EMPTY
82030: LIST
82031: LIST
82032: LIST
82033: LIST
82034: IN
82035: OR
82036: IFFALSE 82292
// begin attacking := false ;
82038: LD_ADDR_VAR 0 29
82042: PUSH
82043: LD_INT 0
82045: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
82046: LD_VAR 0 14
82050: PUSH
82051: LD_INT 1
82053: ARRAY
82054: PPUSH
82055: CALL_OW 266
82059: PUSH
82060: LD_INT 32
82062: PUSH
82063: LD_INT 31
82065: PUSH
82066: LD_INT 33
82068: PUSH
82069: LD_INT 4
82071: PUSH
82072: LD_INT 5
82074: PUSH
82075: EMPTY
82076: LIST
82077: LIST
82078: LIST
82079: LIST
82080: LIST
82081: IN
82082: IFFALSE 82268
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
82084: LD_ADDR_VAR 0 9
82088: PUSH
82089: LD_VAR 0 14
82093: PUSH
82094: LD_INT 1
82096: ARRAY
82097: PPUSH
82098: CALL_OW 266
82102: PPUSH
82103: LD_VAR 0 14
82107: PUSH
82108: LD_INT 1
82110: ARRAY
82111: PPUSH
82112: CALL_OW 250
82116: PPUSH
82117: LD_VAR 0 14
82121: PUSH
82122: LD_INT 1
82124: ARRAY
82125: PPUSH
82126: CALL_OW 251
82130: PPUSH
82131: LD_VAR 0 14
82135: PUSH
82136: LD_INT 1
82138: ARRAY
82139: PPUSH
82140: CALL_OW 254
82144: PPUSH
82145: LD_VAR 0 14
82149: PUSH
82150: LD_INT 1
82152: ARRAY
82153: PPUSH
82154: CALL_OW 248
82158: PPUSH
82159: LD_INT 0
82161: PPUSH
82162: CALL 23871 0 6
82166: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
82167: LD_ADDR_VAR 0 8
82171: PUSH
82172: LD_VAR 0 4
82176: PUSH
82177: LD_VAR 0 7
82181: ARRAY
82182: PPUSH
82183: LD_VAR 0 9
82187: PPUSH
82188: CALL 42541 0 2
82192: ST_TO_ADDR
// if j then
82193: LD_VAR 0 8
82197: IFFALSE 82266
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
82199: LD_VAR 0 8
82203: PUSH
82204: LD_INT 1
82206: ARRAY
82207: PPUSH
82208: LD_VAR 0 8
82212: PUSH
82213: LD_INT 2
82215: ARRAY
82216: PPUSH
82217: CALL_OW 488
82221: IFFALSE 82266
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
82223: LD_VAR 0 4
82227: PUSH
82228: LD_VAR 0 7
82232: ARRAY
82233: PPUSH
82234: LD_VAR 0 8
82238: PUSH
82239: LD_INT 1
82241: ARRAY
82242: PPUSH
82243: LD_VAR 0 8
82247: PUSH
82248: LD_INT 2
82250: ARRAY
82251: PPUSH
82252: CALL_OW 116
// attacking := true ;
82256: LD_ADDR_VAR 0 29
82260: PUSH
82261: LD_INT 1
82263: ST_TO_ADDR
// continue ;
82264: GO 79639
// end ; end else
82266: GO 82292
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
82268: LD_VAR 0 4
82272: PUSH
82273: LD_VAR 0 7
82277: ARRAY
82278: PPUSH
82279: LD_VAR 0 14
82283: PUSH
82284: LD_INT 1
82286: ARRAY
82287: PPUSH
82288: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
82292: LD_VAR 0 4
82296: PUSH
82297: LD_VAR 0 7
82301: ARRAY
82302: PPUSH
82303: CALL_OW 265
82307: PUSH
82308: LD_INT 11
82310: EQUAL
82311: IFFALSE 82589
// begin k := 10 ;
82313: LD_ADDR_VAR 0 9
82317: PUSH
82318: LD_INT 10
82320: ST_TO_ADDR
// x := 0 ;
82321: LD_ADDR_VAR 0 10
82325: PUSH
82326: LD_INT 0
82328: ST_TO_ADDR
// if tmp < k then
82329: LD_VAR 0 14
82333: PUSH
82334: LD_VAR 0 9
82338: LESS
82339: IFFALSE 82351
// k := tmp ;
82341: LD_ADDR_VAR 0 9
82345: PUSH
82346: LD_VAR 0 14
82350: ST_TO_ADDR
// for j = k downto 1 do
82351: LD_ADDR_VAR 0 8
82355: PUSH
82356: DOUBLE
82357: LD_VAR 0 9
82361: INC
82362: ST_TO_ADDR
82363: LD_INT 1
82365: PUSH
82366: FOR_DOWNTO
82367: IFFALSE 82442
// begin if GetType ( tmp [ j ] ) = unit_human then
82369: LD_VAR 0 14
82373: PUSH
82374: LD_VAR 0 8
82378: ARRAY
82379: PPUSH
82380: CALL_OW 247
82384: PUSH
82385: LD_INT 1
82387: EQUAL
82388: IFFALSE 82440
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
82390: LD_VAR 0 4
82394: PUSH
82395: LD_VAR 0 7
82399: ARRAY
82400: PPUSH
82401: LD_VAR 0 14
82405: PUSH
82406: LD_VAR 0 8
82410: ARRAY
82411: PPUSH
82412: CALL 42812 0 2
// x := tmp [ j ] ;
82416: LD_ADDR_VAR 0 10
82420: PUSH
82421: LD_VAR 0 14
82425: PUSH
82426: LD_VAR 0 8
82430: ARRAY
82431: ST_TO_ADDR
// attacking := true ;
82432: LD_ADDR_VAR 0 29
82436: PUSH
82437: LD_INT 1
82439: ST_TO_ADDR
// end ; end ;
82440: GO 82366
82442: POP
82443: POP
// if not x then
82444: LD_VAR 0 10
82448: NOT
82449: IFFALSE 82589
// begin attacking := true ;
82451: LD_ADDR_VAR 0 29
82455: PUSH
82456: LD_INT 1
82458: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
82459: LD_VAR 0 4
82463: PUSH
82464: LD_VAR 0 7
82468: ARRAY
82469: PPUSH
82470: CALL_OW 250
82474: PPUSH
82475: LD_VAR 0 4
82479: PUSH
82480: LD_VAR 0 7
82484: ARRAY
82485: PPUSH
82486: CALL_OW 251
82490: PPUSH
82491: CALL_OW 546
82495: PUSH
82496: LD_INT 2
82498: ARRAY
82499: PUSH
82500: LD_VAR 0 14
82504: PUSH
82505: LD_INT 1
82507: ARRAY
82508: PPUSH
82509: CALL_OW 250
82513: PPUSH
82514: LD_VAR 0 14
82518: PUSH
82519: LD_INT 1
82521: ARRAY
82522: PPUSH
82523: CALL_OW 251
82527: PPUSH
82528: CALL_OW 546
82532: PUSH
82533: LD_INT 2
82535: ARRAY
82536: EQUAL
82537: IFFALSE 82565
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
82539: LD_VAR 0 4
82543: PUSH
82544: LD_VAR 0 7
82548: ARRAY
82549: PPUSH
82550: LD_VAR 0 14
82554: PUSH
82555: LD_INT 1
82557: ARRAY
82558: PPUSH
82559: CALL 42812 0 2
82563: GO 82589
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
82565: LD_VAR 0 4
82569: PUSH
82570: LD_VAR 0 7
82574: ARRAY
82575: PPUSH
82576: LD_VAR 0 14
82580: PUSH
82581: LD_INT 1
82583: ARRAY
82584: PPUSH
82585: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
82589: LD_VAR 0 4
82593: PUSH
82594: LD_VAR 0 7
82598: ARRAY
82599: PPUSH
82600: CALL_OW 264
82604: PUSH
82605: LD_INT 29
82607: EQUAL
82608: IFFALSE 82974
// begin if WantsToAttack ( group [ i ] ) in bombed then
82610: LD_VAR 0 4
82614: PUSH
82615: LD_VAR 0 7
82619: ARRAY
82620: PPUSH
82621: CALL_OW 319
82625: PUSH
82626: LD_VAR 0 28
82630: IN
82631: IFFALSE 82635
// continue ;
82633: GO 79639
// k := 8 ;
82635: LD_ADDR_VAR 0 9
82639: PUSH
82640: LD_INT 8
82642: ST_TO_ADDR
// x := 0 ;
82643: LD_ADDR_VAR 0 10
82647: PUSH
82648: LD_INT 0
82650: ST_TO_ADDR
// if tmp < k then
82651: LD_VAR 0 14
82655: PUSH
82656: LD_VAR 0 9
82660: LESS
82661: IFFALSE 82673
// k := tmp ;
82663: LD_ADDR_VAR 0 9
82667: PUSH
82668: LD_VAR 0 14
82672: ST_TO_ADDR
// for j = 1 to k do
82673: LD_ADDR_VAR 0 8
82677: PUSH
82678: DOUBLE
82679: LD_INT 1
82681: DEC
82682: ST_TO_ADDR
82683: LD_VAR 0 9
82687: PUSH
82688: FOR_TO
82689: IFFALSE 82821
// begin if GetType ( tmp [ j ] ) = unit_building then
82691: LD_VAR 0 14
82695: PUSH
82696: LD_VAR 0 8
82700: ARRAY
82701: PPUSH
82702: CALL_OW 247
82706: PUSH
82707: LD_INT 3
82709: EQUAL
82710: IFFALSE 82819
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
82712: LD_VAR 0 14
82716: PUSH
82717: LD_VAR 0 8
82721: ARRAY
82722: PUSH
82723: LD_VAR 0 28
82727: IN
82728: NOT
82729: PUSH
82730: LD_VAR 0 14
82734: PUSH
82735: LD_VAR 0 8
82739: ARRAY
82740: PPUSH
82741: CALL_OW 313
82745: AND
82746: IFFALSE 82819
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
82748: LD_VAR 0 4
82752: PUSH
82753: LD_VAR 0 7
82757: ARRAY
82758: PPUSH
82759: LD_VAR 0 14
82763: PUSH
82764: LD_VAR 0 8
82768: ARRAY
82769: PPUSH
82770: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
82774: LD_ADDR_VAR 0 28
82778: PUSH
82779: LD_VAR 0 28
82783: PPUSH
82784: LD_VAR 0 28
82788: PUSH
82789: LD_INT 1
82791: PLUS
82792: PPUSH
82793: LD_VAR 0 14
82797: PUSH
82798: LD_VAR 0 8
82802: ARRAY
82803: PPUSH
82804: CALL_OW 1
82808: ST_TO_ADDR
// attacking := true ;
82809: LD_ADDR_VAR 0 29
82813: PUSH
82814: LD_INT 1
82816: ST_TO_ADDR
// break ;
82817: GO 82821
// end ; end ;
82819: GO 82688
82821: POP
82822: POP
// if not attacking and f_attack_depot then
82823: LD_VAR 0 29
82827: NOT
82828: PUSH
82829: LD_VAR 0 25
82833: AND
82834: IFFALSE 82929
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
82836: LD_ADDR_VAR 0 13
82840: PUSH
82841: LD_VAR 0 14
82845: PPUSH
82846: LD_INT 2
82848: PUSH
82849: LD_INT 30
82851: PUSH
82852: LD_INT 0
82854: PUSH
82855: EMPTY
82856: LIST
82857: LIST
82858: PUSH
82859: LD_INT 30
82861: PUSH
82862: LD_INT 1
82864: PUSH
82865: EMPTY
82866: LIST
82867: LIST
82868: PUSH
82869: EMPTY
82870: LIST
82871: LIST
82872: LIST
82873: PPUSH
82874: CALL_OW 72
82878: ST_TO_ADDR
// if z then
82879: LD_VAR 0 13
82883: IFFALSE 82929
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
82885: LD_VAR 0 4
82889: PUSH
82890: LD_VAR 0 7
82894: ARRAY
82895: PPUSH
82896: LD_VAR 0 13
82900: PPUSH
82901: LD_VAR 0 4
82905: PUSH
82906: LD_VAR 0 7
82910: ARRAY
82911: PPUSH
82912: CALL_OW 74
82916: PPUSH
82917: CALL_OW 115
// attacking := true ;
82921: LD_ADDR_VAR 0 29
82925: PUSH
82926: LD_INT 1
82928: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
82929: LD_VAR 0 4
82933: PUSH
82934: LD_VAR 0 7
82938: ARRAY
82939: PPUSH
82940: CALL_OW 256
82944: PUSH
82945: LD_INT 500
82947: LESS
82948: IFFALSE 82974
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
82950: LD_VAR 0 4
82954: PUSH
82955: LD_VAR 0 7
82959: ARRAY
82960: PPUSH
82961: LD_VAR 0 14
82965: PUSH
82966: LD_INT 1
82968: ARRAY
82969: PPUSH
82970: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
82974: LD_VAR 0 4
82978: PUSH
82979: LD_VAR 0 7
82983: ARRAY
82984: PPUSH
82985: CALL_OW 264
82989: PUSH
82990: LD_INT 49
82992: EQUAL
82993: IFFALSE 83114
// begin if not HasTask ( group [ i ] ) then
82995: LD_VAR 0 4
82999: PUSH
83000: LD_VAR 0 7
83004: ARRAY
83005: PPUSH
83006: CALL_OW 314
83010: NOT
83011: IFFALSE 83114
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
83013: LD_ADDR_VAR 0 9
83017: PUSH
83018: LD_INT 81
83020: PUSH
83021: LD_VAR 0 4
83025: PUSH
83026: LD_VAR 0 7
83030: ARRAY
83031: PPUSH
83032: CALL_OW 255
83036: PUSH
83037: EMPTY
83038: LIST
83039: LIST
83040: PPUSH
83041: CALL_OW 69
83045: PPUSH
83046: LD_VAR 0 4
83050: PUSH
83051: LD_VAR 0 7
83055: ARRAY
83056: PPUSH
83057: CALL_OW 74
83061: ST_TO_ADDR
// if k then
83062: LD_VAR 0 9
83066: IFFALSE 83114
// if GetDistUnits ( group [ i ] , k ) > 10 then
83068: LD_VAR 0 4
83072: PUSH
83073: LD_VAR 0 7
83077: ARRAY
83078: PPUSH
83079: LD_VAR 0 9
83083: PPUSH
83084: CALL_OW 296
83088: PUSH
83089: LD_INT 10
83091: GREATER
83092: IFFALSE 83114
// ComMoveUnit ( group [ i ] , k ) ;
83094: LD_VAR 0 4
83098: PUSH
83099: LD_VAR 0 7
83103: ARRAY
83104: PPUSH
83105: LD_VAR 0 9
83109: PPUSH
83110: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
83114: LD_VAR 0 4
83118: PUSH
83119: LD_VAR 0 7
83123: ARRAY
83124: PPUSH
83125: CALL_OW 256
83129: PUSH
83130: LD_INT 250
83132: LESS
83133: PUSH
83134: LD_VAR 0 4
83138: PUSH
83139: LD_VAR 0 7
83143: ARRAY
83144: PUSH
83145: LD_INT 21
83147: PUSH
83148: LD_INT 2
83150: PUSH
83151: EMPTY
83152: LIST
83153: LIST
83154: PUSH
83155: LD_INT 23
83157: PUSH
83158: LD_INT 2
83160: PUSH
83161: EMPTY
83162: LIST
83163: LIST
83164: PUSH
83165: EMPTY
83166: LIST
83167: LIST
83168: PPUSH
83169: CALL_OW 69
83173: IN
83174: AND
83175: IFFALSE 83300
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
83177: LD_ADDR_VAR 0 9
83181: PUSH
83182: LD_OWVAR 3
83186: PUSH
83187: LD_VAR 0 4
83191: PUSH
83192: LD_VAR 0 7
83196: ARRAY
83197: DIFF
83198: PPUSH
83199: LD_VAR 0 4
83203: PUSH
83204: LD_VAR 0 7
83208: ARRAY
83209: PPUSH
83210: CALL_OW 74
83214: ST_TO_ADDR
// if not k then
83215: LD_VAR 0 9
83219: NOT
83220: IFFALSE 83224
// continue ;
83222: GO 79639
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
83224: LD_VAR 0 9
83228: PUSH
83229: LD_INT 81
83231: PUSH
83232: LD_VAR 0 4
83236: PUSH
83237: LD_VAR 0 7
83241: ARRAY
83242: PPUSH
83243: CALL_OW 255
83247: PUSH
83248: EMPTY
83249: LIST
83250: LIST
83251: PPUSH
83252: CALL_OW 69
83256: IN
83257: PUSH
83258: LD_VAR 0 9
83262: PPUSH
83263: LD_VAR 0 4
83267: PUSH
83268: LD_VAR 0 7
83272: ARRAY
83273: PPUSH
83274: CALL_OW 296
83278: PUSH
83279: LD_INT 5
83281: LESS
83282: AND
83283: IFFALSE 83300
// ComAutodestruct ( group [ i ] ) ;
83285: LD_VAR 0 4
83289: PUSH
83290: LD_VAR 0 7
83294: ARRAY
83295: PPUSH
83296: CALL 42710 0 1
// end ; if f_attack_depot then
83300: LD_VAR 0 25
83304: IFFALSE 83416
// begin k := 6 ;
83306: LD_ADDR_VAR 0 9
83310: PUSH
83311: LD_INT 6
83313: ST_TO_ADDR
// if tmp < k then
83314: LD_VAR 0 14
83318: PUSH
83319: LD_VAR 0 9
83323: LESS
83324: IFFALSE 83336
// k := tmp ;
83326: LD_ADDR_VAR 0 9
83330: PUSH
83331: LD_VAR 0 14
83335: ST_TO_ADDR
// for j = 1 to k do
83336: LD_ADDR_VAR 0 8
83340: PUSH
83341: DOUBLE
83342: LD_INT 1
83344: DEC
83345: ST_TO_ADDR
83346: LD_VAR 0 9
83350: PUSH
83351: FOR_TO
83352: IFFALSE 83414
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
83354: LD_VAR 0 8
83358: PPUSH
83359: CALL_OW 266
83363: PUSH
83364: LD_INT 0
83366: PUSH
83367: LD_INT 1
83369: PUSH
83370: EMPTY
83371: LIST
83372: LIST
83373: IN
83374: IFFALSE 83412
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
83376: LD_VAR 0 4
83380: PUSH
83381: LD_VAR 0 7
83385: ARRAY
83386: PPUSH
83387: LD_VAR 0 14
83391: PUSH
83392: LD_VAR 0 8
83396: ARRAY
83397: PPUSH
83398: CALL_OW 115
// attacking := true ;
83402: LD_ADDR_VAR 0 29
83406: PUSH
83407: LD_INT 1
83409: ST_TO_ADDR
// break ;
83410: GO 83414
// end ;
83412: GO 83351
83414: POP
83415: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
83416: LD_VAR 0 4
83420: PUSH
83421: LD_VAR 0 7
83425: ARRAY
83426: PPUSH
83427: CALL_OW 302
83431: PUSH
83432: LD_VAR 0 29
83436: NOT
83437: AND
83438: IFFALSE 83760
// begin if GetTag ( group [ i ] ) = 71 then
83440: LD_VAR 0 4
83444: PUSH
83445: LD_VAR 0 7
83449: ARRAY
83450: PPUSH
83451: CALL_OW 110
83455: PUSH
83456: LD_INT 71
83458: EQUAL
83459: IFFALSE 83500
// begin if HasTask ( group [ i ] ) then
83461: LD_VAR 0 4
83465: PUSH
83466: LD_VAR 0 7
83470: ARRAY
83471: PPUSH
83472: CALL_OW 314
83476: IFFALSE 83482
// continue else
83478: GO 79639
83480: GO 83500
// SetTag ( group [ i ] , 0 ) ;
83482: LD_VAR 0 4
83486: PUSH
83487: LD_VAR 0 7
83491: ARRAY
83492: PPUSH
83493: LD_INT 0
83495: PPUSH
83496: CALL_OW 109
// end ; k := 8 ;
83500: LD_ADDR_VAR 0 9
83504: PUSH
83505: LD_INT 8
83507: ST_TO_ADDR
// x := 0 ;
83508: LD_ADDR_VAR 0 10
83512: PUSH
83513: LD_INT 0
83515: ST_TO_ADDR
// if tmp < k then
83516: LD_VAR 0 14
83520: PUSH
83521: LD_VAR 0 9
83525: LESS
83526: IFFALSE 83538
// k := tmp ;
83528: LD_ADDR_VAR 0 9
83532: PUSH
83533: LD_VAR 0 14
83537: ST_TO_ADDR
// for j = 1 to k do
83538: LD_ADDR_VAR 0 8
83542: PUSH
83543: DOUBLE
83544: LD_INT 1
83546: DEC
83547: ST_TO_ADDR
83548: LD_VAR 0 9
83552: PUSH
83553: FOR_TO
83554: IFFALSE 83652
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
83556: LD_VAR 0 14
83560: PUSH
83561: LD_VAR 0 8
83565: ARRAY
83566: PPUSH
83567: CALL_OW 247
83571: PUSH
83572: LD_INT 1
83574: EQUAL
83575: PUSH
83576: LD_VAR 0 14
83580: PUSH
83581: LD_VAR 0 8
83585: ARRAY
83586: PPUSH
83587: CALL_OW 256
83591: PUSH
83592: LD_INT 250
83594: LESS
83595: PUSH
83596: LD_VAR 0 20
83600: AND
83601: PUSH
83602: LD_VAR 0 20
83606: NOT
83607: PUSH
83608: LD_VAR 0 14
83612: PUSH
83613: LD_VAR 0 8
83617: ARRAY
83618: PPUSH
83619: CALL_OW 256
83623: PUSH
83624: LD_INT 250
83626: GREATEREQUAL
83627: AND
83628: OR
83629: AND
83630: IFFALSE 83650
// begin x := tmp [ j ] ;
83632: LD_ADDR_VAR 0 10
83636: PUSH
83637: LD_VAR 0 14
83641: PUSH
83642: LD_VAR 0 8
83646: ARRAY
83647: ST_TO_ADDR
// break ;
83648: GO 83652
// end ;
83650: GO 83553
83652: POP
83653: POP
// if x then
83654: LD_VAR 0 10
83658: IFFALSE 83682
// ComAttackUnit ( group [ i ] , x ) else
83660: LD_VAR 0 4
83664: PUSH
83665: LD_VAR 0 7
83669: ARRAY
83670: PPUSH
83671: LD_VAR 0 10
83675: PPUSH
83676: CALL_OW 115
83680: GO 83706
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
83682: LD_VAR 0 4
83686: PUSH
83687: LD_VAR 0 7
83691: ARRAY
83692: PPUSH
83693: LD_VAR 0 14
83697: PUSH
83698: LD_INT 1
83700: ARRAY
83701: PPUSH
83702: CALL_OW 115
// if not HasTask ( group [ i ] ) then
83706: LD_VAR 0 4
83710: PUSH
83711: LD_VAR 0 7
83715: ARRAY
83716: PPUSH
83717: CALL_OW 314
83721: NOT
83722: IFFALSE 83760
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
83724: LD_VAR 0 4
83728: PUSH
83729: LD_VAR 0 7
83733: ARRAY
83734: PPUSH
83735: LD_VAR 0 14
83739: PPUSH
83740: LD_VAR 0 4
83744: PUSH
83745: LD_VAR 0 7
83749: ARRAY
83750: PPUSH
83751: CALL_OW 74
83755: PPUSH
83756: CALL_OW 115
// end ; end ; end ;
83760: GO 79639
83762: POP
83763: POP
// wait ( 0 0$2 ) ;
83764: LD_INT 70
83766: PPUSH
83767: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
83771: LD_VAR 0 4
83775: NOT
83776: PUSH
83777: LD_VAR 0 4
83781: PUSH
83782: EMPTY
83783: EQUAL
83784: OR
83785: PUSH
83786: LD_INT 81
83788: PUSH
83789: LD_VAR 0 35
83793: PUSH
83794: EMPTY
83795: LIST
83796: LIST
83797: PPUSH
83798: CALL_OW 69
83802: NOT
83803: OR
83804: IFFALSE 79624
// end ;
83806: LD_VAR 0 2
83810: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
83811: LD_INT 0
83813: PPUSH
83814: PPUSH
83815: PPUSH
83816: PPUSH
83817: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
83818: LD_VAR 0 1
83822: NOT
83823: PUSH
83824: LD_EXP 23
83828: PUSH
83829: LD_VAR 0 1
83833: ARRAY
83834: NOT
83835: OR
83836: PUSH
83837: LD_VAR 0 2
83841: NOT
83842: OR
83843: PUSH
83844: LD_VAR 0 3
83848: NOT
83849: OR
83850: IFFALSE 83854
// exit ;
83852: GO 84367
// side := mc_sides [ base ] ;
83854: LD_ADDR_VAR 0 6
83858: PUSH
83859: LD_EXP 49
83863: PUSH
83864: LD_VAR 0 1
83868: ARRAY
83869: ST_TO_ADDR
// if not side then
83870: LD_VAR 0 6
83874: NOT
83875: IFFALSE 83879
// exit ;
83877: GO 84367
// for i in solds do
83879: LD_ADDR_VAR 0 7
83883: PUSH
83884: LD_VAR 0 2
83888: PUSH
83889: FOR_IN
83890: IFFALSE 83951
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
83892: LD_VAR 0 7
83896: PPUSH
83897: CALL_OW 310
83901: PPUSH
83902: CALL_OW 266
83906: PUSH
83907: LD_INT 32
83909: PUSH
83910: LD_INT 31
83912: PUSH
83913: EMPTY
83914: LIST
83915: LIST
83916: IN
83917: IFFALSE 83937
// solds := solds diff i else
83919: LD_ADDR_VAR 0 2
83923: PUSH
83924: LD_VAR 0 2
83928: PUSH
83929: LD_VAR 0 7
83933: DIFF
83934: ST_TO_ADDR
83935: GO 83949
// SetTag ( i , 18 ) ;
83937: LD_VAR 0 7
83941: PPUSH
83942: LD_INT 18
83944: PPUSH
83945: CALL_OW 109
83949: GO 83889
83951: POP
83952: POP
// if not solds then
83953: LD_VAR 0 2
83957: NOT
83958: IFFALSE 83962
// exit ;
83960: GO 84367
// repeat wait ( 0 0$2 ) ;
83962: LD_INT 70
83964: PPUSH
83965: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
83969: LD_ADDR_VAR 0 5
83973: PUSH
83974: LD_VAR 0 6
83978: PPUSH
83979: LD_VAR 0 3
83983: PPUSH
83984: CALL 11680 0 2
83988: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
83989: LD_EXP 23
83993: PUSH
83994: LD_VAR 0 1
83998: ARRAY
83999: NOT
84000: PUSH
84001: LD_EXP 23
84005: PUSH
84006: LD_VAR 0 1
84010: ARRAY
84011: PUSH
84012: EMPTY
84013: EQUAL
84014: OR
84015: IFFALSE 84052
// begin for i in solds do
84017: LD_ADDR_VAR 0 7
84021: PUSH
84022: LD_VAR 0 2
84026: PUSH
84027: FOR_IN
84028: IFFALSE 84041
// ComStop ( i ) ;
84030: LD_VAR 0 7
84034: PPUSH
84035: CALL_OW 141
84039: GO 84027
84041: POP
84042: POP
// solds := [ ] ;
84043: LD_ADDR_VAR 0 2
84047: PUSH
84048: EMPTY
84049: ST_TO_ADDR
// exit ;
84050: GO 84367
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
84052: LD_VAR 0 5
84056: NOT
84057: PUSH
84058: LD_VAR 0 5
84062: PUSH
84063: LD_INT 3
84065: GREATER
84066: OR
84067: PUSH
84068: LD_EXP 45
84072: PUSH
84073: LD_VAR 0 1
84077: ARRAY
84078: OR
84079: IFFALSE 84120
// begin for i in solds do
84081: LD_ADDR_VAR 0 7
84085: PUSH
84086: LD_VAR 0 2
84090: PUSH
84091: FOR_IN
84092: IFFALSE 84116
// if HasTask ( i ) then
84094: LD_VAR 0 7
84098: PPUSH
84099: CALL_OW 314
84103: IFFALSE 84114
// ComStop ( i ) ;
84105: LD_VAR 0 7
84109: PPUSH
84110: CALL_OW 141
84114: GO 84091
84116: POP
84117: POP
// break ;
84118: GO 84355
// end ; for i in solds do
84120: LD_ADDR_VAR 0 7
84124: PUSH
84125: LD_VAR 0 2
84129: PUSH
84130: FOR_IN
84131: IFFALSE 84347
// begin if IsInUnit ( i ) then
84133: LD_VAR 0 7
84137: PPUSH
84138: CALL_OW 310
84142: IFFALSE 84153
// ComExitBuilding ( i ) ;
84144: LD_VAR 0 7
84148: PPUSH
84149: CALL_OW 122
// if GetLives ( i ) > 333 then
84153: LD_VAR 0 7
84157: PPUSH
84158: CALL_OW 256
84162: PUSH
84163: LD_INT 333
84165: GREATER
84166: IFFALSE 84194
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
84168: LD_VAR 0 7
84172: PPUSH
84173: LD_VAR 0 5
84177: PPUSH
84178: LD_VAR 0 7
84182: PPUSH
84183: CALL_OW 74
84187: PPUSH
84188: CALL_OW 115
84192: GO 84345
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
84194: LD_ADDR_VAR 0 8
84198: PUSH
84199: LD_EXP 23
84203: PUSH
84204: LD_VAR 0 1
84208: ARRAY
84209: PPUSH
84210: LD_INT 2
84212: PUSH
84213: LD_INT 30
84215: PUSH
84216: LD_INT 0
84218: PUSH
84219: EMPTY
84220: LIST
84221: LIST
84222: PUSH
84223: LD_INT 30
84225: PUSH
84226: LD_INT 1
84228: PUSH
84229: EMPTY
84230: LIST
84231: LIST
84232: PUSH
84233: LD_INT 30
84235: PUSH
84236: LD_INT 6
84238: PUSH
84239: EMPTY
84240: LIST
84241: LIST
84242: PUSH
84243: EMPTY
84244: LIST
84245: LIST
84246: LIST
84247: LIST
84248: PPUSH
84249: CALL_OW 72
84253: PPUSH
84254: LD_VAR 0 7
84258: PPUSH
84259: CALL_OW 74
84263: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
84264: LD_VAR 0 7
84268: PPUSH
84269: LD_VAR 0 8
84273: PPUSH
84274: CALL_OW 250
84278: PPUSH
84279: LD_INT 3
84281: PPUSH
84282: LD_INT 5
84284: PPUSH
84285: CALL_OW 272
84289: PPUSH
84290: LD_VAR 0 8
84294: PPUSH
84295: CALL_OW 251
84299: PPUSH
84300: LD_INT 3
84302: PPUSH
84303: LD_INT 5
84305: PPUSH
84306: CALL_OW 273
84310: PPUSH
84311: CALL_OW 111
// SetTag ( i , 0 ) ;
84315: LD_VAR 0 7
84319: PPUSH
84320: LD_INT 0
84322: PPUSH
84323: CALL_OW 109
// solds := solds diff i ;
84327: LD_ADDR_VAR 0 2
84331: PUSH
84332: LD_VAR 0 2
84336: PUSH
84337: LD_VAR 0 7
84341: DIFF
84342: ST_TO_ADDR
// continue ;
84343: GO 84130
// end ; end ;
84345: GO 84130
84347: POP
84348: POP
// until solds ;
84349: LD_VAR 0 2
84353: IFFALSE 83962
// MC_Reset ( base , 18 ) ;
84355: LD_VAR 0 1
84359: PPUSH
84360: LD_INT 18
84362: PPUSH
84363: CALL 52678 0 2
// end ;
84367: LD_VAR 0 4
84371: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class ; begin
84372: LD_INT 0
84374: PPUSH
84375: PPUSH
84376: PPUSH
84377: PPUSH
84378: PPUSH
84379: PPUSH
84380: PPUSH
84381: PPUSH
84382: PPUSH
84383: PPUSH
84384: PPUSH
84385: PPUSH
84386: PPUSH
84387: PPUSH
84388: PPUSH
84389: PPUSH
84390: PPUSH
84391: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
84392: LD_ADDR_VAR 0 13
84396: PUSH
84397: LD_EXP 23
84401: PUSH
84402: LD_VAR 0 1
84406: ARRAY
84407: PPUSH
84408: LD_INT 25
84410: PUSH
84411: LD_INT 3
84413: PUSH
84414: EMPTY
84415: LIST
84416: LIST
84417: PPUSH
84418: CALL_OW 72
84422: ST_TO_ADDR
// if mc_remote_driver [ base ] then
84423: LD_EXP 63
84427: PUSH
84428: LD_VAR 0 1
84432: ARRAY
84433: IFFALSE 84457
// mechs := mechs diff mc_remote_driver [ base ] ;
84435: LD_ADDR_VAR 0 13
84439: PUSH
84440: LD_VAR 0 13
84444: PUSH
84445: LD_EXP 63
84449: PUSH
84450: LD_VAR 0 1
84454: ARRAY
84455: DIFF
84456: ST_TO_ADDR
// for i in mechs do
84457: LD_ADDR_VAR 0 5
84461: PUSH
84462: LD_VAR 0 13
84466: PUSH
84467: FOR_IN
84468: IFFALSE 84503
// if GetTag ( i ) > 0 then
84470: LD_VAR 0 5
84474: PPUSH
84475: CALL_OW 110
84479: PUSH
84480: LD_INT 0
84482: GREATER
84483: IFFALSE 84501
// mechs := mechs diff i ;
84485: LD_ADDR_VAR 0 13
84489: PUSH
84490: LD_VAR 0 13
84494: PUSH
84495: LD_VAR 0 5
84499: DIFF
84500: ST_TO_ADDR
84501: GO 84467
84503: POP
84504: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
84505: LD_ADDR_VAR 0 9
84509: PUSH
84510: LD_EXP 23
84514: PUSH
84515: LD_VAR 0 1
84519: ARRAY
84520: PPUSH
84521: LD_INT 2
84523: PUSH
84524: LD_INT 25
84526: PUSH
84527: LD_INT 1
84529: PUSH
84530: EMPTY
84531: LIST
84532: LIST
84533: PUSH
84534: LD_INT 25
84536: PUSH
84537: LD_INT 5
84539: PUSH
84540: EMPTY
84541: LIST
84542: LIST
84543: PUSH
84544: LD_INT 25
84546: PUSH
84547: LD_INT 8
84549: PUSH
84550: EMPTY
84551: LIST
84552: LIST
84553: PUSH
84554: LD_INT 25
84556: PUSH
84557: LD_INT 9
84559: PUSH
84560: EMPTY
84561: LIST
84562: LIST
84563: PUSH
84564: EMPTY
84565: LIST
84566: LIST
84567: LIST
84568: LIST
84569: LIST
84570: PPUSH
84571: CALL_OW 72
84575: ST_TO_ADDR
// if not defenders and not solds then
84576: LD_VAR 0 2
84580: NOT
84581: PUSH
84582: LD_VAR 0 9
84586: NOT
84587: AND
84588: IFFALSE 84592
// exit ;
84590: GO 86362
// depot_under_attack := false ;
84592: LD_ADDR_VAR 0 17
84596: PUSH
84597: LD_INT 0
84599: ST_TO_ADDR
// sold_defenders := [ ] ;
84600: LD_ADDR_VAR 0 18
84604: PUSH
84605: EMPTY
84606: ST_TO_ADDR
// if mechs then
84607: LD_VAR 0 13
84611: IFFALSE 84764
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
84613: LD_ADDR_VAR 0 5
84617: PUSH
84618: LD_VAR 0 2
84622: PPUSH
84623: LD_INT 21
84625: PUSH
84626: LD_INT 2
84628: PUSH
84629: EMPTY
84630: LIST
84631: LIST
84632: PPUSH
84633: CALL_OW 72
84637: PUSH
84638: FOR_IN
84639: IFFALSE 84762
// begin if GetTag ( i ) <> 20 then
84641: LD_VAR 0 5
84645: PPUSH
84646: CALL_OW 110
84650: PUSH
84651: LD_INT 20
84653: NONEQUAL
84654: IFFALSE 84668
// SetTag ( i , 20 ) ;
84656: LD_VAR 0 5
84660: PPUSH
84661: LD_INT 20
84663: PPUSH
84664: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
84668: LD_VAR 0 5
84672: PPUSH
84673: CALL_OW 263
84677: PUSH
84678: LD_INT 1
84680: EQUAL
84681: PUSH
84682: LD_VAR 0 5
84686: PPUSH
84687: CALL_OW 311
84691: NOT
84692: AND
84693: IFFALSE 84760
// begin un := mechs [ 1 ] ;
84695: LD_ADDR_VAR 0 11
84699: PUSH
84700: LD_VAR 0 13
84704: PUSH
84705: LD_INT 1
84707: ARRAY
84708: ST_TO_ADDR
// ComExit ( un ) ;
84709: LD_VAR 0 11
84713: PPUSH
84714: CALL 47055 0 1
// AddComEnterUnit ( un , i ) ;
84718: LD_VAR 0 11
84722: PPUSH
84723: LD_VAR 0 5
84727: PPUSH
84728: CALL_OW 180
// SetTag ( un , 19 ) ;
84732: LD_VAR 0 11
84736: PPUSH
84737: LD_INT 19
84739: PPUSH
84740: CALL_OW 109
// mechs := mechs diff un ;
84744: LD_ADDR_VAR 0 13
84748: PUSH
84749: LD_VAR 0 13
84753: PUSH
84754: LD_VAR 0 11
84758: DIFF
84759: ST_TO_ADDR
// end ; end ;
84760: GO 84638
84762: POP
84763: POP
// if solds then
84764: LD_VAR 0 9
84768: IFFALSE 84827
// for i in solds do
84770: LD_ADDR_VAR 0 5
84774: PUSH
84775: LD_VAR 0 9
84779: PUSH
84780: FOR_IN
84781: IFFALSE 84825
// if not GetTag ( i ) then
84783: LD_VAR 0 5
84787: PPUSH
84788: CALL_OW 110
84792: NOT
84793: IFFALSE 84823
// begin defenders := defenders union i ;
84795: LD_ADDR_VAR 0 2
84799: PUSH
84800: LD_VAR 0 2
84804: PUSH
84805: LD_VAR 0 5
84809: UNION
84810: ST_TO_ADDR
// SetTag ( i , 18 ) ;
84811: LD_VAR 0 5
84815: PPUSH
84816: LD_INT 18
84818: PPUSH
84819: CALL_OW 109
// end ;
84823: GO 84780
84825: POP
84826: POP
// repeat wait ( 0 0$2 ) ;
84827: LD_INT 70
84829: PPUSH
84830: CALL_OW 67
// enemy := mc_scan [ base ] ;
84834: LD_ADDR_VAR 0 3
84838: PUSH
84839: LD_EXP 46
84843: PUSH
84844: LD_VAR 0 1
84848: ARRAY
84849: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
84850: LD_EXP 23
84854: PUSH
84855: LD_VAR 0 1
84859: ARRAY
84860: NOT
84861: PUSH
84862: LD_EXP 23
84866: PUSH
84867: LD_VAR 0 1
84871: ARRAY
84872: PUSH
84873: EMPTY
84874: EQUAL
84875: OR
84876: IFFALSE 84913
// begin for i in defenders do
84878: LD_ADDR_VAR 0 5
84882: PUSH
84883: LD_VAR 0 2
84887: PUSH
84888: FOR_IN
84889: IFFALSE 84902
// ComStop ( i ) ;
84891: LD_VAR 0 5
84895: PPUSH
84896: CALL_OW 141
84900: GO 84888
84902: POP
84903: POP
// defenders := [ ] ;
84904: LD_ADDR_VAR 0 2
84908: PUSH
84909: EMPTY
84910: ST_TO_ADDR
// exit ;
84911: GO 86362
// end ; for i in defenders do
84913: LD_ADDR_VAR 0 5
84917: PUSH
84918: LD_VAR 0 2
84922: PUSH
84923: FOR_IN
84924: IFFALSE 85822
// begin e := NearestUnitToUnit ( enemy , i ) ;
84926: LD_ADDR_VAR 0 14
84930: PUSH
84931: LD_VAR 0 3
84935: PPUSH
84936: LD_VAR 0 5
84940: PPUSH
84941: CALL_OW 74
84945: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
84946: LD_ADDR_VAR 0 8
84950: PUSH
84951: LD_EXP 23
84955: PUSH
84956: LD_VAR 0 1
84960: ARRAY
84961: PPUSH
84962: LD_INT 2
84964: PUSH
84965: LD_INT 30
84967: PUSH
84968: LD_INT 0
84970: PUSH
84971: EMPTY
84972: LIST
84973: LIST
84974: PUSH
84975: LD_INT 30
84977: PUSH
84978: LD_INT 1
84980: PUSH
84981: EMPTY
84982: LIST
84983: LIST
84984: PUSH
84985: EMPTY
84986: LIST
84987: LIST
84988: LIST
84989: PPUSH
84990: CALL_OW 72
84994: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
84995: LD_ADDR_VAR 0 17
84999: PUSH
85000: LD_VAR 0 8
85004: NOT
85005: PUSH
85006: LD_VAR 0 8
85010: PPUSH
85011: LD_INT 3
85013: PUSH
85014: LD_INT 24
85016: PUSH
85017: LD_INT 600
85019: PUSH
85020: EMPTY
85021: LIST
85022: LIST
85023: PUSH
85024: EMPTY
85025: LIST
85026: LIST
85027: PPUSH
85028: CALL_OW 72
85032: OR
85033: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
85034: LD_VAR 0 5
85038: PPUSH
85039: CALL_OW 247
85043: PUSH
85044: LD_INT 2
85046: DOUBLE
85047: EQUAL
85048: IFTRUE 85052
85050: GO 85448
85052: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
85053: LD_VAR 0 5
85057: PPUSH
85058: CALL_OW 256
85062: PUSH
85063: LD_INT 1000
85065: EQUAL
85066: PUSH
85067: LD_VAR 0 5
85071: PPUSH
85072: LD_VAR 0 14
85076: PPUSH
85077: CALL_OW 296
85081: PUSH
85082: LD_INT 40
85084: LESS
85085: PUSH
85086: LD_VAR 0 14
85090: PPUSH
85091: LD_EXP 48
85095: PUSH
85096: LD_VAR 0 1
85100: ARRAY
85101: PPUSH
85102: CALL_OW 308
85106: OR
85107: AND
85108: IFFALSE 85230
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
85110: LD_VAR 0 5
85114: PPUSH
85115: CALL_OW 262
85119: PUSH
85120: LD_INT 1
85122: EQUAL
85123: PUSH
85124: LD_VAR 0 5
85128: PPUSH
85129: CALL_OW 261
85133: PUSH
85134: LD_INT 30
85136: LESS
85137: AND
85138: PUSH
85139: LD_VAR 0 8
85143: AND
85144: IFFALSE 85214
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
85146: LD_VAR 0 5
85150: PPUSH
85151: LD_VAR 0 8
85155: PPUSH
85156: LD_VAR 0 5
85160: PPUSH
85161: CALL_OW 74
85165: PPUSH
85166: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
85170: LD_VAR 0 5
85174: PPUSH
85175: LD_VAR 0 8
85179: PPUSH
85180: LD_VAR 0 5
85184: PPUSH
85185: CALL_OW 74
85189: PPUSH
85190: CALL_OW 296
85194: PUSH
85195: LD_INT 6
85197: LESS
85198: IFFALSE 85212
// SetFuel ( i , 100 ) ;
85200: LD_VAR 0 5
85204: PPUSH
85205: LD_INT 100
85207: PPUSH
85208: CALL_OW 240
// end else
85212: GO 85228
// ComAttackUnit ( i , e ) ;
85214: LD_VAR 0 5
85218: PPUSH
85219: LD_VAR 0 14
85223: PPUSH
85224: CALL_OW 115
// end else
85228: GO 85331
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
85230: LD_VAR 0 14
85234: PPUSH
85235: LD_EXP 48
85239: PUSH
85240: LD_VAR 0 1
85244: ARRAY
85245: PPUSH
85246: CALL_OW 308
85250: NOT
85251: PUSH
85252: LD_VAR 0 5
85256: PPUSH
85257: LD_VAR 0 14
85261: PPUSH
85262: CALL_OW 296
85266: PUSH
85267: LD_INT 40
85269: GREATEREQUAL
85270: AND
85271: PUSH
85272: LD_VAR 0 5
85276: PPUSH
85277: CALL_OW 256
85281: PUSH
85282: LD_INT 650
85284: LESSEQUAL
85285: OR
85286: PUSH
85287: LD_VAR 0 5
85291: PPUSH
85292: LD_EXP 47
85296: PUSH
85297: LD_VAR 0 1
85301: ARRAY
85302: PPUSH
85303: CALL_OW 308
85307: NOT
85308: AND
85309: IFFALSE 85331
// ComMoveToArea ( i , mc_parking [ base ] ) ;
85311: LD_VAR 0 5
85315: PPUSH
85316: LD_EXP 47
85320: PUSH
85321: LD_VAR 0 1
85325: ARRAY
85326: PPUSH
85327: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
85331: LD_VAR 0 5
85335: PPUSH
85336: CALL_OW 256
85340: PUSH
85341: LD_INT 1000
85343: LESS
85344: PUSH
85345: LD_VAR 0 5
85349: PPUSH
85350: CALL_OW 263
85354: PUSH
85355: LD_INT 1
85357: EQUAL
85358: AND
85359: PUSH
85360: LD_VAR 0 5
85364: PPUSH
85365: CALL_OW 311
85369: AND
85370: PUSH
85371: LD_VAR 0 5
85375: PPUSH
85376: LD_EXP 47
85380: PUSH
85381: LD_VAR 0 1
85385: ARRAY
85386: PPUSH
85387: CALL_OW 308
85391: AND
85392: IFFALSE 85446
// begin mech := IsDrivenBy ( i ) ;
85394: LD_ADDR_VAR 0 10
85398: PUSH
85399: LD_VAR 0 5
85403: PPUSH
85404: CALL_OW 311
85408: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
85409: LD_VAR 0 10
85413: PPUSH
85414: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
85418: LD_VAR 0 10
85422: PPUSH
85423: LD_VAR 0 5
85427: PPUSH
85428: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
85432: LD_VAR 0 10
85436: PPUSH
85437: LD_VAR 0 5
85441: PPUSH
85442: CALL_OW 180
// end ; end ; unit_human :
85446: GO 85793
85448: LD_INT 1
85450: DOUBLE
85451: EQUAL
85452: IFTRUE 85456
85454: GO 85792
85456: POP
// begin b := IsInUnit ( i ) ;
85457: LD_ADDR_VAR 0 19
85461: PUSH
85462: LD_VAR 0 5
85466: PPUSH
85467: CALL_OW 310
85471: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
85472: LD_ADDR_VAR 0 20
85476: PUSH
85477: LD_VAR 0 19
85481: NOT
85482: PUSH
85483: LD_VAR 0 19
85487: PPUSH
85488: CALL_OW 266
85492: PUSH
85493: LD_INT 32
85495: PUSH
85496: LD_INT 31
85498: PUSH
85499: EMPTY
85500: LIST
85501: LIST
85502: IN
85503: OR
85504: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
85505: LD_VAR 0 19
85509: PPUSH
85510: CALL_OW 266
85514: PUSH
85515: LD_INT 5
85517: EQUAL
85518: PUSH
85519: LD_VAR 0 5
85523: PPUSH
85524: CALL_OW 257
85528: PUSH
85529: LD_INT 1
85531: PUSH
85532: LD_INT 2
85534: PUSH
85535: LD_INT 3
85537: PUSH
85538: LD_INT 4
85540: PUSH
85541: EMPTY
85542: LIST
85543: LIST
85544: LIST
85545: LIST
85546: IN
85547: AND
85548: IFFALSE 85585
// begin class := AllowSpecClass ( i ) ;
85550: LD_ADDR_VAR 0 21
85554: PUSH
85555: LD_VAR 0 5
85559: PPUSH
85560: CALL 11715 0 1
85564: ST_TO_ADDR
// if class then
85565: LD_VAR 0 21
85569: IFFALSE 85585
// ComChangeProfession ( i , class ) ;
85571: LD_VAR 0 5
85575: PPUSH
85576: LD_VAR 0 21
85580: PPUSH
85581: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
85585: LD_VAR 0 17
85589: PUSH
85590: LD_VAR 0 2
85594: PPUSH
85595: LD_INT 21
85597: PUSH
85598: LD_INT 2
85600: PUSH
85601: EMPTY
85602: LIST
85603: LIST
85604: PPUSH
85605: CALL_OW 72
85609: PUSH
85610: LD_INT 1
85612: LESSEQUAL
85613: OR
85614: PUSH
85615: LD_VAR 0 20
85619: AND
85620: PUSH
85621: LD_VAR 0 5
85625: PUSH
85626: LD_VAR 0 18
85630: IN
85631: NOT
85632: AND
85633: IFFALSE 85726
// begin if b then
85635: LD_VAR 0 19
85639: IFFALSE 85688
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
85641: LD_VAR 0 19
85645: PPUSH
85646: LD_VAR 0 3
85650: PPUSH
85651: LD_VAR 0 19
85655: PPUSH
85656: CALL_OW 74
85660: PPUSH
85661: CALL_OW 296
85665: PUSH
85666: LD_INT 10
85668: LESS
85669: PUSH
85670: LD_VAR 0 19
85674: PPUSH
85675: CALL_OW 461
85679: PUSH
85680: LD_INT 7
85682: NONEQUAL
85683: AND
85684: IFFALSE 85688
// continue ;
85686: GO 84923
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
85688: LD_ADDR_VAR 0 18
85692: PUSH
85693: LD_VAR 0 18
85697: PPUSH
85698: LD_VAR 0 18
85702: PUSH
85703: LD_INT 1
85705: PLUS
85706: PPUSH
85707: LD_VAR 0 5
85711: PPUSH
85712: CALL_OW 1
85716: ST_TO_ADDR
// ComExitBuilding ( i ) ;
85717: LD_VAR 0 5
85721: PPUSH
85722: CALL_OW 122
// end ; if sold_defenders then
85726: LD_VAR 0 18
85730: IFFALSE 85790
// if i in sold_defenders then
85732: LD_VAR 0 5
85736: PUSH
85737: LD_VAR 0 18
85741: IN
85742: IFFALSE 85790
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
85744: LD_VAR 0 5
85748: PPUSH
85749: CALL_OW 314
85753: NOT
85754: PUSH
85755: LD_VAR 0 5
85759: PPUSH
85760: LD_VAR 0 14
85764: PPUSH
85765: CALL_OW 296
85769: PUSH
85770: LD_INT 30
85772: LESS
85773: AND
85774: IFFALSE 85790
// ComAttackUnit ( i , e ) ;
85776: LD_VAR 0 5
85780: PPUSH
85781: LD_VAR 0 14
85785: PPUSH
85786: CALL_OW 115
// end ; end ; end ;
85790: GO 85793
85792: POP
// if IsDead ( i ) then
85793: LD_VAR 0 5
85797: PPUSH
85798: CALL_OW 301
85802: IFFALSE 85820
// defenders := defenders diff i ;
85804: LD_ADDR_VAR 0 2
85808: PUSH
85809: LD_VAR 0 2
85813: PUSH
85814: LD_VAR 0 5
85818: DIFF
85819: ST_TO_ADDR
// end ;
85820: GO 84923
85822: POP
85823: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
85824: LD_VAR 0 3
85828: NOT
85829: PUSH
85830: LD_VAR 0 2
85834: NOT
85835: OR
85836: PUSH
85837: LD_EXP 23
85841: PUSH
85842: LD_VAR 0 1
85846: ARRAY
85847: NOT
85848: OR
85849: IFFALSE 84827
// MC_Reset ( base , 18 ) ;
85851: LD_VAR 0 1
85855: PPUSH
85856: LD_INT 18
85858: PPUSH
85859: CALL 52678 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
85863: LD_ADDR_VAR 0 2
85867: PUSH
85868: LD_VAR 0 2
85872: PUSH
85873: LD_VAR 0 2
85877: PPUSH
85878: LD_INT 2
85880: PUSH
85881: LD_INT 25
85883: PUSH
85884: LD_INT 1
85886: PUSH
85887: EMPTY
85888: LIST
85889: LIST
85890: PUSH
85891: LD_INT 25
85893: PUSH
85894: LD_INT 5
85896: PUSH
85897: EMPTY
85898: LIST
85899: LIST
85900: PUSH
85901: LD_INT 25
85903: PUSH
85904: LD_INT 8
85906: PUSH
85907: EMPTY
85908: LIST
85909: LIST
85910: PUSH
85911: LD_INT 25
85913: PUSH
85914: LD_INT 9
85916: PUSH
85917: EMPTY
85918: LIST
85919: LIST
85920: PUSH
85921: EMPTY
85922: LIST
85923: LIST
85924: LIST
85925: LIST
85926: LIST
85927: PPUSH
85928: CALL_OW 72
85932: DIFF
85933: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
85934: LD_VAR 0 3
85938: NOT
85939: PUSH
85940: LD_VAR 0 2
85944: PPUSH
85945: LD_INT 21
85947: PUSH
85948: LD_INT 2
85950: PUSH
85951: EMPTY
85952: LIST
85953: LIST
85954: PPUSH
85955: CALL_OW 72
85959: AND
85960: IFFALSE 86298
// begin tmp := FilterByTag ( defenders , 19 ) ;
85962: LD_ADDR_VAR 0 12
85966: PUSH
85967: LD_VAR 0 2
85971: PPUSH
85972: LD_INT 19
85974: PPUSH
85975: CALL 44185 0 2
85979: ST_TO_ADDR
// if tmp then
85980: LD_VAR 0 12
85984: IFFALSE 86054
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
85986: LD_ADDR_VAR 0 12
85990: PUSH
85991: LD_VAR 0 12
85995: PPUSH
85996: LD_INT 25
85998: PUSH
85999: LD_INT 3
86001: PUSH
86002: EMPTY
86003: LIST
86004: LIST
86005: PPUSH
86006: CALL_OW 72
86010: ST_TO_ADDR
// if tmp then
86011: LD_VAR 0 12
86015: IFFALSE 86054
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
86017: LD_ADDR_EXP 35
86021: PUSH
86022: LD_EXP 35
86026: PPUSH
86027: LD_VAR 0 1
86031: PPUSH
86032: LD_EXP 35
86036: PUSH
86037: LD_VAR 0 1
86041: ARRAY
86042: PUSH
86043: LD_VAR 0 12
86047: UNION
86048: PPUSH
86049: CALL_OW 1
86053: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
86054: LD_VAR 0 1
86058: PPUSH
86059: LD_INT 19
86061: PPUSH
86062: CALL 52678 0 2
// repeat wait ( 0 0$1 ) ;
86066: LD_INT 35
86068: PPUSH
86069: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
86073: LD_EXP 23
86077: PUSH
86078: LD_VAR 0 1
86082: ARRAY
86083: NOT
86084: PUSH
86085: LD_EXP 23
86089: PUSH
86090: LD_VAR 0 1
86094: ARRAY
86095: PUSH
86096: EMPTY
86097: EQUAL
86098: OR
86099: IFFALSE 86136
// begin for i in defenders do
86101: LD_ADDR_VAR 0 5
86105: PUSH
86106: LD_VAR 0 2
86110: PUSH
86111: FOR_IN
86112: IFFALSE 86125
// ComStop ( i ) ;
86114: LD_VAR 0 5
86118: PPUSH
86119: CALL_OW 141
86123: GO 86111
86125: POP
86126: POP
// defenders := [ ] ;
86127: LD_ADDR_VAR 0 2
86131: PUSH
86132: EMPTY
86133: ST_TO_ADDR
// exit ;
86134: GO 86362
// end ; for i in defenders do
86136: LD_ADDR_VAR 0 5
86140: PUSH
86141: LD_VAR 0 2
86145: PUSH
86146: FOR_IN
86147: IFFALSE 86236
// begin if not IsInArea ( i , mc_parking [ base ] ) then
86149: LD_VAR 0 5
86153: PPUSH
86154: LD_EXP 47
86158: PUSH
86159: LD_VAR 0 1
86163: ARRAY
86164: PPUSH
86165: CALL_OW 308
86169: NOT
86170: IFFALSE 86194
// ComMoveToArea ( i , mc_parking [ base ] ) else
86172: LD_VAR 0 5
86176: PPUSH
86177: LD_EXP 47
86181: PUSH
86182: LD_VAR 0 1
86186: ARRAY
86187: PPUSH
86188: CALL_OW 113
86192: GO 86234
// if GetControl ( i ) = control_manual then
86194: LD_VAR 0 5
86198: PPUSH
86199: CALL_OW 263
86203: PUSH
86204: LD_INT 1
86206: EQUAL
86207: IFFALSE 86234
// if IsDrivenBy ( i ) then
86209: LD_VAR 0 5
86213: PPUSH
86214: CALL_OW 311
86218: IFFALSE 86234
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
86220: LD_VAR 0 5
86224: PPUSH
86225: CALL_OW 311
86229: PPUSH
86230: CALL_OW 121
// end ;
86234: GO 86146
86236: POP
86237: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
86238: LD_VAR 0 2
86242: PPUSH
86243: LD_INT 95
86245: PUSH
86246: LD_EXP 47
86250: PUSH
86251: LD_VAR 0 1
86255: ARRAY
86256: PUSH
86257: EMPTY
86258: LIST
86259: LIST
86260: PPUSH
86261: CALL_OW 72
86265: PUSH
86266: LD_VAR 0 2
86270: EQUAL
86271: PUSH
86272: LD_EXP 46
86276: PUSH
86277: LD_VAR 0 1
86281: ARRAY
86282: OR
86283: PUSH
86284: LD_EXP 23
86288: PUSH
86289: LD_VAR 0 1
86293: ARRAY
86294: NOT
86295: OR
86296: IFFALSE 86066
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
86298: LD_ADDR_EXP 45
86302: PUSH
86303: LD_EXP 45
86307: PPUSH
86308: LD_VAR 0 1
86312: PPUSH
86313: LD_VAR 0 2
86317: PPUSH
86318: LD_INT 21
86320: PUSH
86321: LD_INT 2
86323: PUSH
86324: EMPTY
86325: LIST
86326: LIST
86327: PPUSH
86328: CALL_OW 72
86332: PPUSH
86333: CALL_OW 1
86337: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
86338: LD_VAR 0 1
86342: PPUSH
86343: LD_INT 19
86345: PPUSH
86346: CALL 52678 0 2
// MC_Reset ( base , 20 ) ;
86350: LD_VAR 0 1
86354: PPUSH
86355: LD_INT 20
86357: PPUSH
86358: CALL 52678 0 2
// end ; end_of_file
86362: LD_VAR 0 4
86366: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
86367: LD_INT 0
86369: PPUSH
86370: PPUSH
86371: PPUSH
86372: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
86373: LD_VAR 0 1
86377: PPUSH
86378: CALL_OW 264
86382: PUSH
86383: LD_EXP 71
86387: EQUAL
86388: IFFALSE 86460
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
86390: LD_INT 68
86392: PPUSH
86393: LD_VAR 0 1
86397: PPUSH
86398: CALL_OW 255
86402: PPUSH
86403: CALL_OW 321
86407: PUSH
86408: LD_INT 2
86410: EQUAL
86411: IFFALSE 86423
// eff := 70 else
86413: LD_ADDR_VAR 0 4
86417: PUSH
86418: LD_INT 70
86420: ST_TO_ADDR
86421: GO 86431
// eff := 30 ;
86423: LD_ADDR_VAR 0 4
86427: PUSH
86428: LD_INT 30
86430: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
86431: LD_VAR 0 1
86435: PPUSH
86436: CALL_OW 250
86440: PPUSH
86441: LD_VAR 0 1
86445: PPUSH
86446: CALL_OW 251
86450: PPUSH
86451: LD_VAR 0 4
86455: PPUSH
86456: CALL_OW 495
// end ; end ;
86460: LD_VAR 0 2
86464: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
86465: LD_INT 0
86467: PPUSH
// end ;
86468: LD_VAR 0 4
86472: RET
// export function SOS_Command ( cmd ) ; begin
86473: LD_INT 0
86475: PPUSH
// end ;
86476: LD_VAR 0 2
86480: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
86481: LD_INT 0
86483: PPUSH
// if cmd = 121 then
86484: LD_VAR 0 1
86488: PUSH
86489: LD_INT 121
86491: EQUAL
86492: IFFALSE 86494
// end ;
86494: LD_VAR 0 6
86498: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
86499: LD_INT 0
86501: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
86502: LD_VAR 0 1
86506: PUSH
86507: LD_INT 250
86509: EQUAL
86510: PUSH
86511: LD_VAR 0 2
86515: PPUSH
86516: CALL_OW 264
86520: PUSH
86521: LD_EXP 74
86525: EQUAL
86526: AND
86527: IFFALSE 86548
// MinerPlaceMine ( unit , x , y ) ;
86529: LD_VAR 0 2
86533: PPUSH
86534: LD_VAR 0 4
86538: PPUSH
86539: LD_VAR 0 5
86543: PPUSH
86544: CALL 88897 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
86548: LD_VAR 0 1
86552: PUSH
86553: LD_INT 251
86555: EQUAL
86556: PUSH
86557: LD_VAR 0 2
86561: PPUSH
86562: CALL_OW 264
86566: PUSH
86567: LD_EXP 74
86571: EQUAL
86572: AND
86573: IFFALSE 86594
// MinerDetonateMine ( unit , x , y ) ;
86575: LD_VAR 0 2
86579: PPUSH
86580: LD_VAR 0 4
86584: PPUSH
86585: LD_VAR 0 5
86589: PPUSH
86590: CALL 89174 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
86594: LD_VAR 0 1
86598: PUSH
86599: LD_INT 252
86601: EQUAL
86602: PUSH
86603: LD_VAR 0 2
86607: PPUSH
86608: CALL_OW 264
86612: PUSH
86613: LD_EXP 74
86617: EQUAL
86618: AND
86619: IFFALSE 86640
// MinerCreateMinefield ( unit , x , y ) ;
86621: LD_VAR 0 2
86625: PPUSH
86626: LD_VAR 0 4
86630: PPUSH
86631: LD_VAR 0 5
86635: PPUSH
86636: CALL 89591 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
86640: LD_VAR 0 1
86644: PUSH
86645: LD_INT 253
86647: EQUAL
86648: PUSH
86649: LD_VAR 0 2
86653: PPUSH
86654: CALL_OW 257
86658: PUSH
86659: LD_INT 5
86661: EQUAL
86662: AND
86663: IFFALSE 86684
// ComBinocular ( unit , x , y ) ;
86665: LD_VAR 0 2
86669: PPUSH
86670: LD_VAR 0 4
86674: PPUSH
86675: LD_VAR 0 5
86679: PPUSH
86680: CALL 89962 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
86684: LD_VAR 0 1
86688: PUSH
86689: LD_INT 254
86691: EQUAL
86692: PUSH
86693: LD_VAR 0 2
86697: PPUSH
86698: CALL_OW 264
86702: PUSH
86703: LD_EXP 69
86707: EQUAL
86708: AND
86709: PUSH
86710: LD_VAR 0 3
86714: PPUSH
86715: CALL_OW 263
86719: PUSH
86720: LD_INT 3
86722: EQUAL
86723: AND
86724: IFFALSE 86740
// HackDestroyVehicle ( unit , selectedUnit ) ;
86726: LD_VAR 0 2
86730: PPUSH
86731: LD_VAR 0 3
86735: PPUSH
86736: CALL 88257 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
86740: LD_VAR 0 1
86744: PUSH
86745: LD_INT 255
86747: EQUAL
86748: PUSH
86749: LD_VAR 0 2
86753: PPUSH
86754: CALL_OW 264
86758: PUSH
86759: LD_INT 14
86761: PUSH
86762: LD_INT 53
86764: PUSH
86765: EMPTY
86766: LIST
86767: LIST
86768: IN
86769: AND
86770: PUSH
86771: LD_VAR 0 4
86775: PPUSH
86776: LD_VAR 0 5
86780: PPUSH
86781: CALL_OW 488
86785: AND
86786: IFFALSE 86810
// CutTreeXYR ( unit , x , y , 12 ) ;
86788: LD_VAR 0 2
86792: PPUSH
86793: LD_VAR 0 4
86797: PPUSH
86798: LD_VAR 0 5
86802: PPUSH
86803: LD_INT 12
86805: PPUSH
86806: CALL 86823 0 4
// end ;
86810: LD_VAR 0 6
86814: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
86815: LD_INT 0
86817: PPUSH
// end ;
86818: LD_VAR 0 4
86822: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
86823: LD_INT 0
86825: PPUSH
86826: PPUSH
86827: PPUSH
86828: PPUSH
86829: PPUSH
86830: PPUSH
86831: PPUSH
86832: PPUSH
86833: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
86834: LD_VAR 0 1
86838: NOT
86839: PUSH
86840: LD_VAR 0 2
86844: PPUSH
86845: LD_VAR 0 3
86849: PPUSH
86850: CALL_OW 488
86854: NOT
86855: OR
86856: PUSH
86857: LD_VAR 0 4
86861: NOT
86862: OR
86863: IFFALSE 86867
// exit ;
86865: GO 87207
// list := [ ] ;
86867: LD_ADDR_VAR 0 13
86871: PUSH
86872: EMPTY
86873: ST_TO_ADDR
// if x - r < 0 then
86874: LD_VAR 0 2
86878: PUSH
86879: LD_VAR 0 4
86883: MINUS
86884: PUSH
86885: LD_INT 0
86887: LESS
86888: IFFALSE 86900
// min_x := 0 else
86890: LD_ADDR_VAR 0 7
86894: PUSH
86895: LD_INT 0
86897: ST_TO_ADDR
86898: GO 86916
// min_x := x - r ;
86900: LD_ADDR_VAR 0 7
86904: PUSH
86905: LD_VAR 0 2
86909: PUSH
86910: LD_VAR 0 4
86914: MINUS
86915: ST_TO_ADDR
// if y - r < 0 then
86916: LD_VAR 0 3
86920: PUSH
86921: LD_VAR 0 4
86925: MINUS
86926: PUSH
86927: LD_INT 0
86929: LESS
86930: IFFALSE 86942
// min_y := 0 else
86932: LD_ADDR_VAR 0 8
86936: PUSH
86937: LD_INT 0
86939: ST_TO_ADDR
86940: GO 86958
// min_y := y - r ;
86942: LD_ADDR_VAR 0 8
86946: PUSH
86947: LD_VAR 0 3
86951: PUSH
86952: LD_VAR 0 4
86956: MINUS
86957: ST_TO_ADDR
// max_x := x + r ;
86958: LD_ADDR_VAR 0 9
86962: PUSH
86963: LD_VAR 0 2
86967: PUSH
86968: LD_VAR 0 4
86972: PLUS
86973: ST_TO_ADDR
// max_y := y + r ;
86974: LD_ADDR_VAR 0 10
86978: PUSH
86979: LD_VAR 0 3
86983: PUSH
86984: LD_VAR 0 4
86988: PLUS
86989: ST_TO_ADDR
// for _x = min_x to max_x do
86990: LD_ADDR_VAR 0 11
86994: PUSH
86995: DOUBLE
86996: LD_VAR 0 7
87000: DEC
87001: ST_TO_ADDR
87002: LD_VAR 0 9
87006: PUSH
87007: FOR_TO
87008: IFFALSE 87125
// for _y = min_y to max_y do
87010: LD_ADDR_VAR 0 12
87014: PUSH
87015: DOUBLE
87016: LD_VAR 0 8
87020: DEC
87021: ST_TO_ADDR
87022: LD_VAR 0 10
87026: PUSH
87027: FOR_TO
87028: IFFALSE 87121
// begin if not ValidHex ( _x , _y ) then
87030: LD_VAR 0 11
87034: PPUSH
87035: LD_VAR 0 12
87039: PPUSH
87040: CALL_OW 488
87044: NOT
87045: IFFALSE 87049
// continue ;
87047: GO 87027
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
87049: LD_VAR 0 11
87053: PPUSH
87054: LD_VAR 0 12
87058: PPUSH
87059: CALL_OW 351
87063: PUSH
87064: LD_VAR 0 11
87068: PPUSH
87069: LD_VAR 0 12
87073: PPUSH
87074: CALL_OW 554
87078: AND
87079: IFFALSE 87119
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
87081: LD_ADDR_VAR 0 13
87085: PUSH
87086: LD_VAR 0 13
87090: PPUSH
87091: LD_VAR 0 13
87095: PUSH
87096: LD_INT 1
87098: PLUS
87099: PPUSH
87100: LD_VAR 0 11
87104: PUSH
87105: LD_VAR 0 12
87109: PUSH
87110: EMPTY
87111: LIST
87112: LIST
87113: PPUSH
87114: CALL_OW 2
87118: ST_TO_ADDR
// end ;
87119: GO 87027
87121: POP
87122: POP
87123: GO 87007
87125: POP
87126: POP
// if not list then
87127: LD_VAR 0 13
87131: NOT
87132: IFFALSE 87136
// exit ;
87134: GO 87207
// for i in list do
87136: LD_ADDR_VAR 0 6
87140: PUSH
87141: LD_VAR 0 13
87145: PUSH
87146: FOR_IN
87147: IFFALSE 87205
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
87149: LD_VAR 0 1
87153: PPUSH
87154: LD_STRING M
87156: PUSH
87157: LD_VAR 0 6
87161: PUSH
87162: LD_INT 1
87164: ARRAY
87165: PUSH
87166: LD_VAR 0 6
87170: PUSH
87171: LD_INT 2
87173: ARRAY
87174: PUSH
87175: LD_INT 0
87177: PUSH
87178: LD_INT 0
87180: PUSH
87181: LD_INT 0
87183: PUSH
87184: LD_INT 0
87186: PUSH
87187: EMPTY
87188: LIST
87189: LIST
87190: LIST
87191: LIST
87192: LIST
87193: LIST
87194: LIST
87195: PUSH
87196: EMPTY
87197: LIST
87198: PPUSH
87199: CALL_OW 447
87203: GO 87146
87205: POP
87206: POP
// end ;
87207: LD_VAR 0 5
87211: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
87212: LD_EXP 88
87216: NOT
87217: IFFALSE 87267
87219: GO 87221
87221: DISABLE
// begin initHack := true ;
87222: LD_ADDR_EXP 88
87226: PUSH
87227: LD_INT 1
87229: ST_TO_ADDR
// hackTanks := [ ] ;
87230: LD_ADDR_EXP 89
87234: PUSH
87235: EMPTY
87236: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
87237: LD_ADDR_EXP 90
87241: PUSH
87242: EMPTY
87243: ST_TO_ADDR
// hackLimit := 3 ;
87244: LD_ADDR_EXP 91
87248: PUSH
87249: LD_INT 3
87251: ST_TO_ADDR
// hackDist := 12 ;
87252: LD_ADDR_EXP 92
87256: PUSH
87257: LD_INT 12
87259: ST_TO_ADDR
// hackCounter := [ ] ;
87260: LD_ADDR_EXP 93
87264: PUSH
87265: EMPTY
87266: ST_TO_ADDR
// end ;
87267: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
87268: LD_EXP 88
87272: PUSH
87273: LD_INT 34
87275: PUSH
87276: LD_EXP 69
87280: PUSH
87281: EMPTY
87282: LIST
87283: LIST
87284: PPUSH
87285: CALL_OW 69
87289: AND
87290: IFFALSE 87545
87292: GO 87294
87294: DISABLE
87295: LD_INT 0
87297: PPUSH
87298: PPUSH
// begin enable ;
87299: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
87300: LD_ADDR_VAR 0 1
87304: PUSH
87305: LD_INT 34
87307: PUSH
87308: LD_EXP 69
87312: PUSH
87313: EMPTY
87314: LIST
87315: LIST
87316: PPUSH
87317: CALL_OW 69
87321: PUSH
87322: FOR_IN
87323: IFFALSE 87543
// begin if not i in hackTanks then
87325: LD_VAR 0 1
87329: PUSH
87330: LD_EXP 89
87334: IN
87335: NOT
87336: IFFALSE 87419
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
87338: LD_ADDR_EXP 89
87342: PUSH
87343: LD_EXP 89
87347: PPUSH
87348: LD_EXP 89
87352: PUSH
87353: LD_INT 1
87355: PLUS
87356: PPUSH
87357: LD_VAR 0 1
87361: PPUSH
87362: CALL_OW 1
87366: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
87367: LD_ADDR_EXP 90
87371: PUSH
87372: LD_EXP 90
87376: PPUSH
87377: LD_EXP 90
87381: PUSH
87382: LD_INT 1
87384: PLUS
87385: PPUSH
87386: EMPTY
87387: PPUSH
87388: CALL_OW 1
87392: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
87393: LD_ADDR_EXP 93
87397: PUSH
87398: LD_EXP 93
87402: PPUSH
87403: LD_EXP 93
87407: PUSH
87408: LD_INT 1
87410: PLUS
87411: PPUSH
87412: EMPTY
87413: PPUSH
87414: CALL_OW 1
87418: ST_TO_ADDR
// end ; if not IsOk ( i ) then
87419: LD_VAR 0 1
87423: PPUSH
87424: CALL_OW 302
87428: NOT
87429: IFFALSE 87442
// begin HackUnlinkAll ( i ) ;
87431: LD_VAR 0 1
87435: PPUSH
87436: CALL 87548 0 1
// continue ;
87440: GO 87322
// end ; HackCheckCapturedStatus ( i ) ;
87442: LD_VAR 0 1
87446: PPUSH
87447: CALL 87991 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
87451: LD_ADDR_VAR 0 2
87455: PUSH
87456: LD_INT 81
87458: PUSH
87459: LD_VAR 0 1
87463: PPUSH
87464: CALL_OW 255
87468: PUSH
87469: EMPTY
87470: LIST
87471: LIST
87472: PUSH
87473: LD_INT 33
87475: PUSH
87476: LD_INT 3
87478: PUSH
87479: EMPTY
87480: LIST
87481: LIST
87482: PUSH
87483: LD_INT 91
87485: PUSH
87486: LD_VAR 0 1
87490: PUSH
87491: LD_EXP 92
87495: PUSH
87496: EMPTY
87497: LIST
87498: LIST
87499: LIST
87500: PUSH
87501: LD_INT 50
87503: PUSH
87504: EMPTY
87505: LIST
87506: PUSH
87507: EMPTY
87508: LIST
87509: LIST
87510: LIST
87511: LIST
87512: PPUSH
87513: CALL_OW 69
87517: ST_TO_ADDR
// if not tmp then
87518: LD_VAR 0 2
87522: NOT
87523: IFFALSE 87527
// continue ;
87525: GO 87322
// HackLink ( i , tmp ) ;
87527: LD_VAR 0 1
87531: PPUSH
87532: LD_VAR 0 2
87536: PPUSH
87537: CALL 87684 0 2
// end ;
87541: GO 87322
87543: POP
87544: POP
// end ;
87545: PPOPN 2
87547: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
87548: LD_INT 0
87550: PPUSH
87551: PPUSH
87552: PPUSH
// if not hack in hackTanks then
87553: LD_VAR 0 1
87557: PUSH
87558: LD_EXP 89
87562: IN
87563: NOT
87564: IFFALSE 87568
// exit ;
87566: GO 87679
// index := GetElementIndex ( hackTanks , hack ) ;
87568: LD_ADDR_VAR 0 4
87572: PUSH
87573: LD_EXP 89
87577: PPUSH
87578: LD_VAR 0 1
87582: PPUSH
87583: CALL 14700 0 2
87587: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
87588: LD_EXP 90
87592: PUSH
87593: LD_VAR 0 4
87597: ARRAY
87598: IFFALSE 87679
// begin for i in hackTanksCaptured [ index ] do
87600: LD_ADDR_VAR 0 3
87604: PUSH
87605: LD_EXP 90
87609: PUSH
87610: LD_VAR 0 4
87614: ARRAY
87615: PUSH
87616: FOR_IN
87617: IFFALSE 87643
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
87619: LD_VAR 0 3
87623: PUSH
87624: LD_INT 1
87626: ARRAY
87627: PPUSH
87628: LD_VAR 0 3
87632: PUSH
87633: LD_INT 2
87635: ARRAY
87636: PPUSH
87637: CALL_OW 235
87641: GO 87616
87643: POP
87644: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
87645: LD_ADDR_EXP 90
87649: PUSH
87650: LD_EXP 90
87654: PPUSH
87655: LD_VAR 0 4
87659: PPUSH
87660: EMPTY
87661: PPUSH
87662: CALL_OW 1
87666: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
87667: LD_VAR 0 1
87671: PPUSH
87672: LD_INT 0
87674: PPUSH
87675: CALL_OW 505
// end ; end ;
87679: LD_VAR 0 2
87683: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
87684: LD_INT 0
87686: PPUSH
87687: PPUSH
87688: PPUSH
// if not hack in hackTanks or not vehicles then
87689: LD_VAR 0 1
87693: PUSH
87694: LD_EXP 89
87698: IN
87699: NOT
87700: PUSH
87701: LD_VAR 0 2
87705: NOT
87706: OR
87707: IFFALSE 87711
// exit ;
87709: GO 87986
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
87711: LD_ADDR_VAR 0 2
87715: PUSH
87716: LD_VAR 0 1
87720: PPUSH
87721: LD_VAR 0 2
87725: PPUSH
87726: LD_INT 1
87728: PPUSH
87729: LD_INT 1
87731: PPUSH
87732: CALL 15350 0 4
87736: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
87737: LD_ADDR_VAR 0 5
87741: PUSH
87742: LD_EXP 89
87746: PPUSH
87747: LD_VAR 0 1
87751: PPUSH
87752: CALL 14700 0 2
87756: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
87757: LD_EXP 90
87761: PUSH
87762: LD_VAR 0 5
87766: ARRAY
87767: PUSH
87768: LD_EXP 91
87772: LESS
87773: IFFALSE 87962
// begin for i := 1 to vehicles do
87775: LD_ADDR_VAR 0 4
87779: PUSH
87780: DOUBLE
87781: LD_INT 1
87783: DEC
87784: ST_TO_ADDR
87785: LD_VAR 0 2
87789: PUSH
87790: FOR_TO
87791: IFFALSE 87960
// begin if hackTanksCaptured [ index ] = hackLimit then
87793: LD_EXP 90
87797: PUSH
87798: LD_VAR 0 5
87802: ARRAY
87803: PUSH
87804: LD_EXP 91
87808: EQUAL
87809: IFFALSE 87813
// break ;
87811: GO 87960
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
87813: LD_ADDR_EXP 93
87817: PUSH
87818: LD_EXP 93
87822: PPUSH
87823: LD_VAR 0 5
87827: PPUSH
87828: LD_EXP 93
87832: PUSH
87833: LD_VAR 0 5
87837: ARRAY
87838: PUSH
87839: LD_INT 1
87841: PLUS
87842: PPUSH
87843: CALL_OW 1
87847: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
87848: LD_ADDR_EXP 90
87852: PUSH
87853: LD_EXP 90
87857: PPUSH
87858: LD_VAR 0 5
87862: PUSH
87863: LD_EXP 90
87867: PUSH
87868: LD_VAR 0 5
87872: ARRAY
87873: PUSH
87874: LD_INT 1
87876: PLUS
87877: PUSH
87878: EMPTY
87879: LIST
87880: LIST
87881: PPUSH
87882: LD_VAR 0 2
87886: PUSH
87887: LD_VAR 0 4
87891: ARRAY
87892: PUSH
87893: LD_VAR 0 2
87897: PUSH
87898: LD_VAR 0 4
87902: ARRAY
87903: PPUSH
87904: CALL_OW 255
87908: PUSH
87909: EMPTY
87910: LIST
87911: LIST
87912: PPUSH
87913: CALL 14915 0 3
87917: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
87918: LD_VAR 0 2
87922: PUSH
87923: LD_VAR 0 4
87927: ARRAY
87928: PPUSH
87929: LD_VAR 0 1
87933: PPUSH
87934: CALL_OW 255
87938: PPUSH
87939: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
87943: LD_VAR 0 2
87947: PUSH
87948: LD_VAR 0 4
87952: ARRAY
87953: PPUSH
87954: CALL_OW 141
// end ;
87958: GO 87790
87960: POP
87961: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
87962: LD_VAR 0 1
87966: PPUSH
87967: LD_EXP 90
87971: PUSH
87972: LD_VAR 0 5
87976: ARRAY
87977: PUSH
87978: LD_INT 0
87980: PLUS
87981: PPUSH
87982: CALL_OW 505
// end ;
87986: LD_VAR 0 3
87990: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
87991: LD_INT 0
87993: PPUSH
87994: PPUSH
87995: PPUSH
87996: PPUSH
// if not hack in hackTanks then
87997: LD_VAR 0 1
88001: PUSH
88002: LD_EXP 89
88006: IN
88007: NOT
88008: IFFALSE 88012
// exit ;
88010: GO 88252
// index := GetElementIndex ( hackTanks , hack ) ;
88012: LD_ADDR_VAR 0 4
88016: PUSH
88017: LD_EXP 89
88021: PPUSH
88022: LD_VAR 0 1
88026: PPUSH
88027: CALL 14700 0 2
88031: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
88032: LD_ADDR_VAR 0 3
88036: PUSH
88037: DOUBLE
88038: LD_EXP 90
88042: PUSH
88043: LD_VAR 0 4
88047: ARRAY
88048: INC
88049: ST_TO_ADDR
88050: LD_INT 1
88052: PUSH
88053: FOR_DOWNTO
88054: IFFALSE 88226
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
88056: LD_ADDR_VAR 0 5
88060: PUSH
88061: LD_EXP 90
88065: PUSH
88066: LD_VAR 0 4
88070: ARRAY
88071: PUSH
88072: LD_VAR 0 3
88076: ARRAY
88077: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
88078: LD_VAR 0 5
88082: PUSH
88083: LD_INT 1
88085: ARRAY
88086: PPUSH
88087: CALL_OW 302
88091: NOT
88092: PUSH
88093: LD_VAR 0 5
88097: PUSH
88098: LD_INT 1
88100: ARRAY
88101: PPUSH
88102: CALL_OW 255
88106: PUSH
88107: LD_VAR 0 1
88111: PPUSH
88112: CALL_OW 255
88116: NONEQUAL
88117: OR
88118: IFFALSE 88224
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
88120: LD_VAR 0 5
88124: PUSH
88125: LD_INT 1
88127: ARRAY
88128: PPUSH
88129: CALL_OW 305
88133: PUSH
88134: LD_VAR 0 5
88138: PUSH
88139: LD_INT 1
88141: ARRAY
88142: PPUSH
88143: CALL_OW 255
88147: PUSH
88148: LD_VAR 0 1
88152: PPUSH
88153: CALL_OW 255
88157: EQUAL
88158: AND
88159: IFFALSE 88183
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
88161: LD_VAR 0 5
88165: PUSH
88166: LD_INT 1
88168: ARRAY
88169: PPUSH
88170: LD_VAR 0 5
88174: PUSH
88175: LD_INT 2
88177: ARRAY
88178: PPUSH
88179: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
88183: LD_ADDR_EXP 90
88187: PUSH
88188: LD_EXP 90
88192: PPUSH
88193: LD_VAR 0 4
88197: PPUSH
88198: LD_EXP 90
88202: PUSH
88203: LD_VAR 0 4
88207: ARRAY
88208: PPUSH
88209: LD_VAR 0 3
88213: PPUSH
88214: CALL_OW 3
88218: PPUSH
88219: CALL_OW 1
88223: ST_TO_ADDR
// end ; end ;
88224: GO 88053
88226: POP
88227: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
88228: LD_VAR 0 1
88232: PPUSH
88233: LD_EXP 90
88237: PUSH
88238: LD_VAR 0 4
88242: ARRAY
88243: PUSH
88244: LD_INT 0
88246: PLUS
88247: PPUSH
88248: CALL_OW 505
// end ;
88252: LD_VAR 0 2
88256: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
88257: LD_INT 0
88259: PPUSH
88260: PPUSH
88261: PPUSH
88262: PPUSH
// if not hack in hackTanks then
88263: LD_VAR 0 1
88267: PUSH
88268: LD_EXP 89
88272: IN
88273: NOT
88274: IFFALSE 88278
// exit ;
88276: GO 88363
// index := GetElementIndex ( hackTanks , hack ) ;
88278: LD_ADDR_VAR 0 5
88282: PUSH
88283: LD_EXP 89
88287: PPUSH
88288: LD_VAR 0 1
88292: PPUSH
88293: CALL 14700 0 2
88297: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
88298: LD_ADDR_VAR 0 4
88302: PUSH
88303: DOUBLE
88304: LD_INT 1
88306: DEC
88307: ST_TO_ADDR
88308: LD_EXP 90
88312: PUSH
88313: LD_VAR 0 5
88317: ARRAY
88318: PUSH
88319: FOR_TO
88320: IFFALSE 88361
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
88322: LD_EXP 90
88326: PUSH
88327: LD_VAR 0 5
88331: ARRAY
88332: PUSH
88333: LD_VAR 0 4
88337: ARRAY
88338: PUSH
88339: LD_INT 1
88341: ARRAY
88342: PUSH
88343: LD_VAR 0 2
88347: EQUAL
88348: IFFALSE 88359
// KillUnit ( vehicle ) ;
88350: LD_VAR 0 2
88354: PPUSH
88355: CALL_OW 66
88359: GO 88319
88361: POP
88362: POP
// end ;
88363: LD_VAR 0 3
88367: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
88368: LD_EXP 94
88372: NOT
88373: IFFALSE 88408
88375: GO 88377
88377: DISABLE
// begin initMiner := true ;
88378: LD_ADDR_EXP 94
88382: PUSH
88383: LD_INT 1
88385: ST_TO_ADDR
// minersList := [ ] ;
88386: LD_ADDR_EXP 95
88390: PUSH
88391: EMPTY
88392: ST_TO_ADDR
// minerMinesList := [ ] ;
88393: LD_ADDR_EXP 96
88397: PUSH
88398: EMPTY
88399: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
88400: LD_ADDR_EXP 97
88404: PUSH
88405: LD_INT 5
88407: ST_TO_ADDR
// end ;
88408: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
88409: LD_EXP 94
88413: PUSH
88414: LD_INT 34
88416: PUSH
88417: LD_EXP 74
88421: PUSH
88422: EMPTY
88423: LIST
88424: LIST
88425: PPUSH
88426: CALL_OW 69
88430: AND
88431: IFFALSE 88894
88433: GO 88435
88435: DISABLE
88436: LD_INT 0
88438: PPUSH
88439: PPUSH
88440: PPUSH
88441: PPUSH
// begin enable ;
88442: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
88443: LD_ADDR_VAR 0 1
88447: PUSH
88448: LD_INT 34
88450: PUSH
88451: LD_EXP 74
88455: PUSH
88456: EMPTY
88457: LIST
88458: LIST
88459: PPUSH
88460: CALL_OW 69
88464: PUSH
88465: FOR_IN
88466: IFFALSE 88538
// begin if not i in minersList then
88468: LD_VAR 0 1
88472: PUSH
88473: LD_EXP 95
88477: IN
88478: NOT
88479: IFFALSE 88536
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
88481: LD_ADDR_EXP 95
88485: PUSH
88486: LD_EXP 95
88490: PPUSH
88491: LD_EXP 95
88495: PUSH
88496: LD_INT 1
88498: PLUS
88499: PPUSH
88500: LD_VAR 0 1
88504: PPUSH
88505: CALL_OW 1
88509: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
88510: LD_ADDR_EXP 96
88514: PUSH
88515: LD_EXP 96
88519: PPUSH
88520: LD_EXP 96
88524: PUSH
88525: LD_INT 1
88527: PLUS
88528: PPUSH
88529: EMPTY
88530: PPUSH
88531: CALL_OW 1
88535: ST_TO_ADDR
// end end ;
88536: GO 88465
88538: POP
88539: POP
// for i := minerMinesList downto 1 do
88540: LD_ADDR_VAR 0 1
88544: PUSH
88545: DOUBLE
88546: LD_EXP 96
88550: INC
88551: ST_TO_ADDR
88552: LD_INT 1
88554: PUSH
88555: FOR_DOWNTO
88556: IFFALSE 88892
// begin if IsLive ( minersList [ i ] ) then
88558: LD_EXP 95
88562: PUSH
88563: LD_VAR 0 1
88567: ARRAY
88568: PPUSH
88569: CALL_OW 300
88573: IFFALSE 88601
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
88575: LD_EXP 95
88579: PUSH
88580: LD_VAR 0 1
88584: ARRAY
88585: PPUSH
88586: LD_EXP 96
88590: PUSH
88591: LD_VAR 0 1
88595: ARRAY
88596: PPUSH
88597: CALL_OW 505
// if not minerMinesList [ i ] then
88601: LD_EXP 96
88605: PUSH
88606: LD_VAR 0 1
88610: ARRAY
88611: NOT
88612: IFFALSE 88616
// continue ;
88614: GO 88555
// for j := minerMinesList [ i ] downto 1 do
88616: LD_ADDR_VAR 0 2
88620: PUSH
88621: DOUBLE
88622: LD_EXP 96
88626: PUSH
88627: LD_VAR 0 1
88631: ARRAY
88632: INC
88633: ST_TO_ADDR
88634: LD_INT 1
88636: PUSH
88637: FOR_DOWNTO
88638: IFFALSE 88888
// begin side := GetSide ( minersList [ i ] ) ;
88640: LD_ADDR_VAR 0 3
88644: PUSH
88645: LD_EXP 95
88649: PUSH
88650: LD_VAR 0 1
88654: ARRAY
88655: PPUSH
88656: CALL_OW 255
88660: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
88661: LD_ADDR_VAR 0 4
88665: PUSH
88666: LD_EXP 96
88670: PUSH
88671: LD_VAR 0 1
88675: ARRAY
88676: PUSH
88677: LD_VAR 0 2
88681: ARRAY
88682: PUSH
88683: LD_INT 1
88685: ARRAY
88686: PPUSH
88687: LD_EXP 96
88691: PUSH
88692: LD_VAR 0 1
88696: ARRAY
88697: PUSH
88698: LD_VAR 0 2
88702: ARRAY
88703: PUSH
88704: LD_INT 2
88706: ARRAY
88707: PPUSH
88708: CALL_OW 428
88712: ST_TO_ADDR
// if not tmp then
88713: LD_VAR 0 4
88717: NOT
88718: IFFALSE 88722
// continue ;
88720: GO 88637
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
88722: LD_VAR 0 4
88726: PUSH
88727: LD_INT 81
88729: PUSH
88730: LD_VAR 0 3
88734: PUSH
88735: EMPTY
88736: LIST
88737: LIST
88738: PPUSH
88739: CALL_OW 69
88743: IN
88744: PUSH
88745: LD_EXP 96
88749: PUSH
88750: LD_VAR 0 1
88754: ARRAY
88755: PUSH
88756: LD_VAR 0 2
88760: ARRAY
88761: PUSH
88762: LD_INT 1
88764: ARRAY
88765: PPUSH
88766: LD_EXP 96
88770: PUSH
88771: LD_VAR 0 1
88775: ARRAY
88776: PUSH
88777: LD_VAR 0 2
88781: ARRAY
88782: PUSH
88783: LD_INT 2
88785: ARRAY
88786: PPUSH
88787: CALL_OW 458
88791: AND
88792: IFFALSE 88886
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
88794: LD_EXP 96
88798: PUSH
88799: LD_VAR 0 1
88803: ARRAY
88804: PUSH
88805: LD_VAR 0 2
88809: ARRAY
88810: PUSH
88811: LD_INT 1
88813: ARRAY
88814: PPUSH
88815: LD_EXP 96
88819: PUSH
88820: LD_VAR 0 1
88824: ARRAY
88825: PUSH
88826: LD_VAR 0 2
88830: ARRAY
88831: PUSH
88832: LD_INT 2
88834: ARRAY
88835: PPUSH
88836: LD_VAR 0 3
88840: PPUSH
88841: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
88845: LD_ADDR_EXP 96
88849: PUSH
88850: LD_EXP 96
88854: PPUSH
88855: LD_VAR 0 1
88859: PPUSH
88860: LD_EXP 96
88864: PUSH
88865: LD_VAR 0 1
88869: ARRAY
88870: PPUSH
88871: LD_VAR 0 2
88875: PPUSH
88876: CALL_OW 3
88880: PPUSH
88881: CALL_OW 1
88885: ST_TO_ADDR
// end ; end ;
88886: GO 88637
88888: POP
88889: POP
// end ;
88890: GO 88555
88892: POP
88893: POP
// end ;
88894: PPOPN 4
88896: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
88897: LD_INT 0
88899: PPUSH
88900: PPUSH
// result := false ;
88901: LD_ADDR_VAR 0 4
88905: PUSH
88906: LD_INT 0
88908: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
88909: LD_VAR 0 1
88913: PPUSH
88914: CALL_OW 264
88918: PUSH
88919: LD_EXP 74
88923: EQUAL
88924: NOT
88925: IFFALSE 88929
// exit ;
88927: GO 89169
// index := GetElementIndex ( minersList , unit ) ;
88929: LD_ADDR_VAR 0 5
88933: PUSH
88934: LD_EXP 95
88938: PPUSH
88939: LD_VAR 0 1
88943: PPUSH
88944: CALL 14700 0 2
88948: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
88949: LD_EXP 96
88953: PUSH
88954: LD_VAR 0 5
88958: ARRAY
88959: PUSH
88960: LD_EXP 97
88964: GREATEREQUAL
88965: IFFALSE 88969
// exit ;
88967: GO 89169
// ComMoveXY ( unit , x , y ) ;
88969: LD_VAR 0 1
88973: PPUSH
88974: LD_VAR 0 2
88978: PPUSH
88979: LD_VAR 0 3
88983: PPUSH
88984: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
88988: LD_INT 35
88990: PPUSH
88991: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
88995: LD_VAR 0 1
88999: PPUSH
89000: LD_VAR 0 2
89004: PPUSH
89005: LD_VAR 0 3
89009: PPUSH
89010: CALL 45473 0 3
89014: NOT
89015: PUSH
89016: LD_VAR 0 1
89020: PPUSH
89021: CALL_OW 314
89025: AND
89026: IFFALSE 89030
// exit ;
89028: GO 89169
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
89030: LD_VAR 0 2
89034: PPUSH
89035: LD_VAR 0 3
89039: PPUSH
89040: CALL_OW 428
89044: PUSH
89045: LD_VAR 0 1
89049: EQUAL
89050: PUSH
89051: LD_VAR 0 1
89055: PPUSH
89056: CALL_OW 314
89060: NOT
89061: AND
89062: IFFALSE 88988
// PlaySoundXY ( x , y , PlantMine ) ;
89064: LD_VAR 0 2
89068: PPUSH
89069: LD_VAR 0 3
89073: PPUSH
89074: LD_STRING PlantMine
89076: PPUSH
89077: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
89081: LD_VAR 0 2
89085: PPUSH
89086: LD_VAR 0 3
89090: PPUSH
89091: LD_VAR 0 1
89095: PPUSH
89096: CALL_OW 255
89100: PPUSH
89101: LD_INT 0
89103: PPUSH
89104: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
89108: LD_ADDR_EXP 96
89112: PUSH
89113: LD_EXP 96
89117: PPUSH
89118: LD_VAR 0 5
89122: PUSH
89123: LD_EXP 96
89127: PUSH
89128: LD_VAR 0 5
89132: ARRAY
89133: PUSH
89134: LD_INT 1
89136: PLUS
89137: PUSH
89138: EMPTY
89139: LIST
89140: LIST
89141: PPUSH
89142: LD_VAR 0 2
89146: PUSH
89147: LD_VAR 0 3
89151: PUSH
89152: EMPTY
89153: LIST
89154: LIST
89155: PPUSH
89156: CALL 14915 0 3
89160: ST_TO_ADDR
// result := true ;
89161: LD_ADDR_VAR 0 4
89165: PUSH
89166: LD_INT 1
89168: ST_TO_ADDR
// end ;
89169: LD_VAR 0 4
89173: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
89174: LD_INT 0
89176: PPUSH
89177: PPUSH
89178: PPUSH
// if not unit in minersList then
89179: LD_VAR 0 1
89183: PUSH
89184: LD_EXP 95
89188: IN
89189: NOT
89190: IFFALSE 89194
// exit ;
89192: GO 89586
// index := GetElementIndex ( minersList , unit ) ;
89194: LD_ADDR_VAR 0 6
89198: PUSH
89199: LD_EXP 95
89203: PPUSH
89204: LD_VAR 0 1
89208: PPUSH
89209: CALL 14700 0 2
89213: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
89214: LD_ADDR_VAR 0 5
89218: PUSH
89219: DOUBLE
89220: LD_EXP 96
89224: PUSH
89225: LD_VAR 0 6
89229: ARRAY
89230: INC
89231: ST_TO_ADDR
89232: LD_INT 1
89234: PUSH
89235: FOR_DOWNTO
89236: IFFALSE 89397
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
89238: LD_EXP 96
89242: PUSH
89243: LD_VAR 0 6
89247: ARRAY
89248: PUSH
89249: LD_VAR 0 5
89253: ARRAY
89254: PUSH
89255: LD_INT 1
89257: ARRAY
89258: PUSH
89259: LD_VAR 0 2
89263: EQUAL
89264: PUSH
89265: LD_EXP 96
89269: PUSH
89270: LD_VAR 0 6
89274: ARRAY
89275: PUSH
89276: LD_VAR 0 5
89280: ARRAY
89281: PUSH
89282: LD_INT 2
89284: ARRAY
89285: PUSH
89286: LD_VAR 0 3
89290: EQUAL
89291: AND
89292: IFFALSE 89395
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
89294: LD_EXP 96
89298: PUSH
89299: LD_VAR 0 6
89303: ARRAY
89304: PUSH
89305: LD_VAR 0 5
89309: ARRAY
89310: PUSH
89311: LD_INT 1
89313: ARRAY
89314: PPUSH
89315: LD_EXP 96
89319: PUSH
89320: LD_VAR 0 6
89324: ARRAY
89325: PUSH
89326: LD_VAR 0 5
89330: ARRAY
89331: PUSH
89332: LD_INT 2
89334: ARRAY
89335: PPUSH
89336: LD_VAR 0 1
89340: PPUSH
89341: CALL_OW 255
89345: PPUSH
89346: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
89350: LD_ADDR_EXP 96
89354: PUSH
89355: LD_EXP 96
89359: PPUSH
89360: LD_VAR 0 6
89364: PPUSH
89365: LD_EXP 96
89369: PUSH
89370: LD_VAR 0 6
89374: ARRAY
89375: PPUSH
89376: LD_VAR 0 5
89380: PPUSH
89381: CALL_OW 3
89385: PPUSH
89386: CALL_OW 1
89390: ST_TO_ADDR
// exit ;
89391: POP
89392: POP
89393: GO 89586
// end ; end ;
89395: GO 89235
89397: POP
89398: POP
// for i := minerMinesList [ index ] downto 1 do
89399: LD_ADDR_VAR 0 5
89403: PUSH
89404: DOUBLE
89405: LD_EXP 96
89409: PUSH
89410: LD_VAR 0 6
89414: ARRAY
89415: INC
89416: ST_TO_ADDR
89417: LD_INT 1
89419: PUSH
89420: FOR_DOWNTO
89421: IFFALSE 89584
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
89423: LD_EXP 96
89427: PUSH
89428: LD_VAR 0 6
89432: ARRAY
89433: PUSH
89434: LD_VAR 0 5
89438: ARRAY
89439: PUSH
89440: LD_INT 1
89442: ARRAY
89443: PPUSH
89444: LD_EXP 96
89448: PUSH
89449: LD_VAR 0 6
89453: ARRAY
89454: PUSH
89455: LD_VAR 0 5
89459: ARRAY
89460: PUSH
89461: LD_INT 2
89463: ARRAY
89464: PPUSH
89465: LD_VAR 0 2
89469: PPUSH
89470: LD_VAR 0 3
89474: PPUSH
89475: CALL_OW 298
89479: PUSH
89480: LD_INT 6
89482: LESS
89483: IFFALSE 89582
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
89485: LD_EXP 96
89489: PUSH
89490: LD_VAR 0 6
89494: ARRAY
89495: PUSH
89496: LD_VAR 0 5
89500: ARRAY
89501: PUSH
89502: LD_INT 1
89504: ARRAY
89505: PPUSH
89506: LD_EXP 96
89510: PUSH
89511: LD_VAR 0 6
89515: ARRAY
89516: PUSH
89517: LD_VAR 0 5
89521: ARRAY
89522: PUSH
89523: LD_INT 2
89525: ARRAY
89526: PPUSH
89527: LD_VAR 0 1
89531: PPUSH
89532: CALL_OW 255
89536: PPUSH
89537: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
89541: LD_ADDR_EXP 96
89545: PUSH
89546: LD_EXP 96
89550: PPUSH
89551: LD_VAR 0 6
89555: PPUSH
89556: LD_EXP 96
89560: PUSH
89561: LD_VAR 0 6
89565: ARRAY
89566: PPUSH
89567: LD_VAR 0 5
89571: PPUSH
89572: CALL_OW 3
89576: PPUSH
89577: CALL_OW 1
89581: ST_TO_ADDR
// end ; end ;
89582: GO 89420
89584: POP
89585: POP
// end ;
89586: LD_VAR 0 4
89590: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
89591: LD_INT 0
89593: PPUSH
89594: PPUSH
89595: PPUSH
89596: PPUSH
89597: PPUSH
89598: PPUSH
89599: PPUSH
89600: PPUSH
89601: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
89602: LD_VAR 0 1
89606: PPUSH
89607: CALL_OW 264
89611: PUSH
89612: LD_EXP 74
89616: EQUAL
89617: NOT
89618: PUSH
89619: LD_VAR 0 1
89623: PUSH
89624: LD_EXP 95
89628: IN
89629: NOT
89630: OR
89631: IFFALSE 89635
// exit ;
89633: GO 89957
// index := GetElementIndex ( minersList , unit ) ;
89635: LD_ADDR_VAR 0 6
89639: PUSH
89640: LD_EXP 95
89644: PPUSH
89645: LD_VAR 0 1
89649: PPUSH
89650: CALL 14700 0 2
89654: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
89655: LD_ADDR_VAR 0 8
89659: PUSH
89660: LD_EXP 97
89664: PUSH
89665: LD_EXP 96
89669: PUSH
89670: LD_VAR 0 6
89674: ARRAY
89675: MINUS
89676: ST_TO_ADDR
// if not minesFreeAmount then
89677: LD_VAR 0 8
89681: NOT
89682: IFFALSE 89686
// exit ;
89684: GO 89957
// tmp := [ ] ;
89686: LD_ADDR_VAR 0 7
89690: PUSH
89691: EMPTY
89692: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
89693: LD_ADDR_VAR 0 5
89697: PUSH
89698: DOUBLE
89699: LD_INT 1
89701: DEC
89702: ST_TO_ADDR
89703: LD_VAR 0 8
89707: PUSH
89708: FOR_TO
89709: IFFALSE 89904
// begin _d := rand ( 0 , 5 ) ;
89711: LD_ADDR_VAR 0 11
89715: PUSH
89716: LD_INT 0
89718: PPUSH
89719: LD_INT 5
89721: PPUSH
89722: CALL_OW 12
89726: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
89727: LD_ADDR_VAR 0 12
89731: PUSH
89732: LD_INT 2
89734: PPUSH
89735: LD_INT 6
89737: PPUSH
89738: CALL_OW 12
89742: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
89743: LD_ADDR_VAR 0 9
89747: PUSH
89748: LD_VAR 0 2
89752: PPUSH
89753: LD_VAR 0 11
89757: PPUSH
89758: LD_VAR 0 12
89762: PPUSH
89763: CALL_OW 272
89767: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
89768: LD_ADDR_VAR 0 10
89772: PUSH
89773: LD_VAR 0 3
89777: PPUSH
89778: LD_VAR 0 11
89782: PPUSH
89783: LD_VAR 0 12
89787: PPUSH
89788: CALL_OW 273
89792: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
89793: LD_VAR 0 9
89797: PPUSH
89798: LD_VAR 0 10
89802: PPUSH
89803: CALL_OW 488
89807: PUSH
89808: LD_VAR 0 9
89812: PUSH
89813: LD_VAR 0 10
89817: PUSH
89818: EMPTY
89819: LIST
89820: LIST
89821: PUSH
89822: LD_VAR 0 7
89826: IN
89827: NOT
89828: AND
89829: PUSH
89830: LD_VAR 0 9
89834: PPUSH
89835: LD_VAR 0 10
89839: PPUSH
89840: CALL_OW 458
89844: NOT
89845: AND
89846: IFFALSE 89888
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
89848: LD_ADDR_VAR 0 7
89852: PUSH
89853: LD_VAR 0 7
89857: PPUSH
89858: LD_VAR 0 7
89862: PUSH
89863: LD_INT 1
89865: PLUS
89866: PPUSH
89867: LD_VAR 0 9
89871: PUSH
89872: LD_VAR 0 10
89876: PUSH
89877: EMPTY
89878: LIST
89879: LIST
89880: PPUSH
89881: CALL_OW 1
89885: ST_TO_ADDR
89886: GO 89902
// i := i - 1 ;
89888: LD_ADDR_VAR 0 5
89892: PUSH
89893: LD_VAR 0 5
89897: PUSH
89898: LD_INT 1
89900: MINUS
89901: ST_TO_ADDR
// end ;
89902: GO 89708
89904: POP
89905: POP
// for i in tmp do
89906: LD_ADDR_VAR 0 5
89910: PUSH
89911: LD_VAR 0 7
89915: PUSH
89916: FOR_IN
89917: IFFALSE 89955
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
89919: LD_VAR 0 1
89923: PPUSH
89924: LD_VAR 0 5
89928: PUSH
89929: LD_INT 1
89931: ARRAY
89932: PPUSH
89933: LD_VAR 0 5
89937: PUSH
89938: LD_INT 2
89940: ARRAY
89941: PPUSH
89942: CALL 88897 0 3
89946: NOT
89947: IFFALSE 89953
// exit ;
89949: POP
89950: POP
89951: GO 89957
89953: GO 89916
89955: POP
89956: POP
// end ;
89957: LD_VAR 0 4
89961: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
89962: LD_INT 0
89964: PPUSH
89965: PPUSH
89966: PPUSH
89967: PPUSH
89968: PPUSH
89969: PPUSH
89970: PPUSH
// if not GetClass ( unit ) = class_sniper then
89971: LD_VAR 0 1
89975: PPUSH
89976: CALL_OW 257
89980: PUSH
89981: LD_INT 5
89983: EQUAL
89984: NOT
89985: IFFALSE 89989
// exit ;
89987: GO 90377
// dist := 8 ;
89989: LD_ADDR_VAR 0 5
89993: PUSH
89994: LD_INT 8
89996: ST_TO_ADDR
// viewRange := 12 ;
89997: LD_ADDR_VAR 0 7
90001: PUSH
90002: LD_INT 12
90004: ST_TO_ADDR
// side := GetSide ( unit ) ;
90005: LD_ADDR_VAR 0 6
90009: PUSH
90010: LD_VAR 0 1
90014: PPUSH
90015: CALL_OW 255
90019: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
90020: LD_INT 61
90022: PPUSH
90023: LD_VAR 0 6
90027: PPUSH
90028: CALL_OW 321
90032: PUSH
90033: LD_INT 2
90035: EQUAL
90036: IFFALSE 90046
// viewRange := 16 ;
90038: LD_ADDR_VAR 0 7
90042: PUSH
90043: LD_INT 16
90045: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
90046: LD_VAR 0 1
90050: PPUSH
90051: LD_VAR 0 2
90055: PPUSH
90056: LD_VAR 0 3
90060: PPUSH
90061: CALL_OW 297
90065: PUSH
90066: LD_VAR 0 5
90070: GREATER
90071: IFFALSE 90150
// begin ComMoveXY ( unit , x , y ) ;
90073: LD_VAR 0 1
90077: PPUSH
90078: LD_VAR 0 2
90082: PPUSH
90083: LD_VAR 0 3
90087: PPUSH
90088: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
90092: LD_INT 35
90094: PPUSH
90095: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
90099: LD_VAR 0 1
90103: PPUSH
90104: LD_VAR 0 2
90108: PPUSH
90109: LD_VAR 0 3
90113: PPUSH
90114: CALL 45473 0 3
90118: NOT
90119: IFFALSE 90123
// exit ;
90121: GO 90377
// until GetDistUnitXY ( unit , x , y ) < dist ;
90123: LD_VAR 0 1
90127: PPUSH
90128: LD_VAR 0 2
90132: PPUSH
90133: LD_VAR 0 3
90137: PPUSH
90138: CALL_OW 297
90142: PUSH
90143: LD_VAR 0 5
90147: LESS
90148: IFFALSE 90092
// end ; ComTurnXY ( unit , x , y ) ;
90150: LD_VAR 0 1
90154: PPUSH
90155: LD_VAR 0 2
90159: PPUSH
90160: LD_VAR 0 3
90164: PPUSH
90165: CALL_OW 118
// wait ( 5 ) ;
90169: LD_INT 5
90171: PPUSH
90172: CALL_OW 67
// _d := GetDir ( unit ) ;
90176: LD_ADDR_VAR 0 10
90180: PUSH
90181: LD_VAR 0 1
90185: PPUSH
90186: CALL_OW 254
90190: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
90191: LD_ADDR_VAR 0 8
90195: PUSH
90196: LD_VAR 0 1
90200: PPUSH
90201: CALL_OW 250
90205: PPUSH
90206: LD_VAR 0 10
90210: PPUSH
90211: LD_VAR 0 5
90215: PPUSH
90216: CALL_OW 272
90220: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
90221: LD_ADDR_VAR 0 9
90225: PUSH
90226: LD_VAR 0 1
90230: PPUSH
90231: CALL_OW 251
90235: PPUSH
90236: LD_VAR 0 10
90240: PPUSH
90241: LD_VAR 0 5
90245: PPUSH
90246: CALL_OW 273
90250: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
90251: LD_VAR 0 8
90255: PPUSH
90256: LD_VAR 0 9
90260: PPUSH
90261: CALL_OW 488
90265: NOT
90266: IFFALSE 90270
// exit ;
90268: GO 90377
// ComAnimCustom ( unit , 1 ) ;
90270: LD_VAR 0 1
90274: PPUSH
90275: LD_INT 1
90277: PPUSH
90278: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
90282: LD_VAR 0 8
90286: PPUSH
90287: LD_VAR 0 9
90291: PPUSH
90292: LD_VAR 0 6
90296: PPUSH
90297: LD_VAR 0 7
90301: PPUSH
90302: CALL_OW 330
// repeat wait ( 1 ) ;
90306: LD_INT 1
90308: PPUSH
90309: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
90313: LD_VAR 0 1
90317: PPUSH
90318: CALL_OW 316
90322: PUSH
90323: LD_VAR 0 1
90327: PPUSH
90328: CALL_OW 314
90332: OR
90333: PUSH
90334: LD_VAR 0 1
90338: PPUSH
90339: CALL_OW 302
90343: NOT
90344: OR
90345: PUSH
90346: LD_VAR 0 1
90350: PPUSH
90351: CALL_OW 301
90355: OR
90356: IFFALSE 90306
// RemoveSeeing ( _x , _y , side ) ;
90358: LD_VAR 0 8
90362: PPUSH
90363: LD_VAR 0 9
90367: PPUSH
90368: LD_VAR 0 6
90372: PPUSH
90373: CALL_OW 331
// end ; end_of_file end_of_file
90377: LD_VAR 0 4
90381: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
90382: LD_VAR 0 1
90386: PUSH
90387: LD_INT 200
90389: DOUBLE
90390: GREATEREQUAL
90391: IFFALSE 90399
90393: LD_INT 299
90395: DOUBLE
90396: LESSEQUAL
90397: IFTRUE 90401
90399: GO 90433
90401: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
90402: LD_VAR 0 1
90406: PPUSH
90407: LD_VAR 0 2
90411: PPUSH
90412: LD_VAR 0 3
90416: PPUSH
90417: LD_VAR 0 4
90421: PPUSH
90422: LD_VAR 0 5
90426: PPUSH
90427: CALL 86499 0 5
90431: GO 90510
90433: LD_INT 300
90435: DOUBLE
90436: GREATEREQUAL
90437: IFFALSE 90445
90439: LD_INT 399
90441: DOUBLE
90442: LESSEQUAL
90443: IFTRUE 90447
90445: GO 90509
90447: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
90448: LD_VAR 0 1
90452: PPUSH
90453: LD_VAR 0 2
90457: PPUSH
90458: LD_VAR 0 3
90462: PPUSH
90463: LD_VAR 0 4
90467: PPUSH
90468: LD_VAR 0 5
90472: PPUSH
90473: LD_VAR 0 6
90477: PPUSH
90478: LD_VAR 0 7
90482: PPUSH
90483: LD_VAR 0 8
90487: PPUSH
90488: LD_VAR 0 9
90492: PPUSH
90493: LD_VAR 0 10
90497: PPUSH
90498: LD_VAR 0 11
90502: PPUSH
90503: CALL 101737 0 11
90507: GO 90510
90509: POP
// end ;
90510: PPOPN 11
90512: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
90513: LD_VAR 0 1
90517: PPUSH
90518: LD_VAR 0 2
90522: PPUSH
90523: LD_VAR 0 3
90527: PPUSH
90528: LD_VAR 0 4
90532: PPUSH
90533: LD_VAR 0 5
90537: PPUSH
90538: CALL 86481 0 5
// end ; end_of_file
90542: PPOPN 5
90544: END
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
90545: LD_INT 0
90547: PPUSH
// if p2 = 100 then
90548: LD_VAR 0 2
90552: PUSH
90553: LD_INT 100
90555: EQUAL
90556: IFFALSE 91505
// begin if not StreamModeActive then
90558: LD_EXP 98
90562: NOT
90563: IFFALSE 90573
// StreamModeActive := true ;
90565: LD_ADDR_EXP 98
90569: PUSH
90570: LD_INT 1
90572: ST_TO_ADDR
// if p3 = 0 then
90573: LD_VAR 0 3
90577: PUSH
90578: LD_INT 0
90580: EQUAL
90581: IFFALSE 90587
// InitStreamMode ;
90583: CALL 91665 0 0
// if p3 = 1 then
90587: LD_VAR 0 3
90591: PUSH
90592: LD_INT 1
90594: EQUAL
90595: IFFALSE 90605
// sRocket := true ;
90597: LD_ADDR_EXP 103
90601: PUSH
90602: LD_INT 1
90604: ST_TO_ADDR
// if p3 = 2 then
90605: LD_VAR 0 3
90609: PUSH
90610: LD_INT 2
90612: EQUAL
90613: IFFALSE 90623
// sSpeed := true ;
90615: LD_ADDR_EXP 102
90619: PUSH
90620: LD_INT 1
90622: ST_TO_ADDR
// if p3 = 3 then
90623: LD_VAR 0 3
90627: PUSH
90628: LD_INT 3
90630: EQUAL
90631: IFFALSE 90641
// sEngine := true ;
90633: LD_ADDR_EXP 104
90637: PUSH
90638: LD_INT 1
90640: ST_TO_ADDR
// if p3 = 4 then
90641: LD_VAR 0 3
90645: PUSH
90646: LD_INT 4
90648: EQUAL
90649: IFFALSE 90659
// sSpec := true ;
90651: LD_ADDR_EXP 101
90655: PUSH
90656: LD_INT 1
90658: ST_TO_ADDR
// if p3 = 5 then
90659: LD_VAR 0 3
90663: PUSH
90664: LD_INT 5
90666: EQUAL
90667: IFFALSE 90677
// sLevel := true ;
90669: LD_ADDR_EXP 105
90673: PUSH
90674: LD_INT 1
90676: ST_TO_ADDR
// if p3 = 6 then
90677: LD_VAR 0 3
90681: PUSH
90682: LD_INT 6
90684: EQUAL
90685: IFFALSE 90695
// sArmoury := true ;
90687: LD_ADDR_EXP 106
90691: PUSH
90692: LD_INT 1
90694: ST_TO_ADDR
// if p3 = 7 then
90695: LD_VAR 0 3
90699: PUSH
90700: LD_INT 7
90702: EQUAL
90703: IFFALSE 90713
// sRadar := true ;
90705: LD_ADDR_EXP 107
90709: PUSH
90710: LD_INT 1
90712: ST_TO_ADDR
// if p3 = 8 then
90713: LD_VAR 0 3
90717: PUSH
90718: LD_INT 8
90720: EQUAL
90721: IFFALSE 90731
// sBunker := true ;
90723: LD_ADDR_EXP 108
90727: PUSH
90728: LD_INT 1
90730: ST_TO_ADDR
// if p3 = 9 then
90731: LD_VAR 0 3
90735: PUSH
90736: LD_INT 9
90738: EQUAL
90739: IFFALSE 90749
// sHack := true ;
90741: LD_ADDR_EXP 109
90745: PUSH
90746: LD_INT 1
90748: ST_TO_ADDR
// if p3 = 10 then
90749: LD_VAR 0 3
90753: PUSH
90754: LD_INT 10
90756: EQUAL
90757: IFFALSE 90767
// sFire := true ;
90759: LD_ADDR_EXP 110
90763: PUSH
90764: LD_INT 1
90766: ST_TO_ADDR
// if p3 = 11 then
90767: LD_VAR 0 3
90771: PUSH
90772: LD_INT 11
90774: EQUAL
90775: IFFALSE 90785
// sRefresh := true ;
90777: LD_ADDR_EXP 111
90781: PUSH
90782: LD_INT 1
90784: ST_TO_ADDR
// if p3 = 12 then
90785: LD_VAR 0 3
90789: PUSH
90790: LD_INT 12
90792: EQUAL
90793: IFFALSE 90803
// sExp := true ;
90795: LD_ADDR_EXP 112
90799: PUSH
90800: LD_INT 1
90802: ST_TO_ADDR
// if p3 = 13 then
90803: LD_VAR 0 3
90807: PUSH
90808: LD_INT 13
90810: EQUAL
90811: IFFALSE 90821
// sDepot := true ;
90813: LD_ADDR_EXP 113
90817: PUSH
90818: LD_INT 1
90820: ST_TO_ADDR
// if p3 = 14 then
90821: LD_VAR 0 3
90825: PUSH
90826: LD_INT 14
90828: EQUAL
90829: IFFALSE 90839
// sFlag := true ;
90831: LD_ADDR_EXP 114
90835: PUSH
90836: LD_INT 1
90838: ST_TO_ADDR
// if p3 = 15 then
90839: LD_VAR 0 3
90843: PUSH
90844: LD_INT 15
90846: EQUAL
90847: IFFALSE 90857
// sKamikadze := true ;
90849: LD_ADDR_EXP 122
90853: PUSH
90854: LD_INT 1
90856: ST_TO_ADDR
// if p3 = 16 then
90857: LD_VAR 0 3
90861: PUSH
90862: LD_INT 16
90864: EQUAL
90865: IFFALSE 90875
// sTroll := true ;
90867: LD_ADDR_EXP 123
90871: PUSH
90872: LD_INT 1
90874: ST_TO_ADDR
// if p3 = 17 then
90875: LD_VAR 0 3
90879: PUSH
90880: LD_INT 17
90882: EQUAL
90883: IFFALSE 90893
// sSlow := true ;
90885: LD_ADDR_EXP 124
90889: PUSH
90890: LD_INT 1
90892: ST_TO_ADDR
// if p3 = 18 then
90893: LD_VAR 0 3
90897: PUSH
90898: LD_INT 18
90900: EQUAL
90901: IFFALSE 90911
// sLack := true ;
90903: LD_ADDR_EXP 125
90907: PUSH
90908: LD_INT 1
90910: ST_TO_ADDR
// if p3 = 19 then
90911: LD_VAR 0 3
90915: PUSH
90916: LD_INT 19
90918: EQUAL
90919: IFFALSE 90929
// sTank := true ;
90921: LD_ADDR_EXP 127
90925: PUSH
90926: LD_INT 1
90928: ST_TO_ADDR
// if p3 = 20 then
90929: LD_VAR 0 3
90933: PUSH
90934: LD_INT 20
90936: EQUAL
90937: IFFALSE 90947
// sRemote := true ;
90939: LD_ADDR_EXP 128
90943: PUSH
90944: LD_INT 1
90946: ST_TO_ADDR
// if p3 = 21 then
90947: LD_VAR 0 3
90951: PUSH
90952: LD_INT 21
90954: EQUAL
90955: IFFALSE 90965
// sPowell := true ;
90957: LD_ADDR_EXP 129
90961: PUSH
90962: LD_INT 1
90964: ST_TO_ADDR
// if p3 = 22 then
90965: LD_VAR 0 3
90969: PUSH
90970: LD_INT 22
90972: EQUAL
90973: IFFALSE 90983
// sTeleport := true ;
90975: LD_ADDR_EXP 132
90979: PUSH
90980: LD_INT 1
90982: ST_TO_ADDR
// if p3 = 23 then
90983: LD_VAR 0 3
90987: PUSH
90988: LD_INT 23
90990: EQUAL
90991: IFFALSE 91001
// sOilTower := true ;
90993: LD_ADDR_EXP 134
90997: PUSH
90998: LD_INT 1
91000: ST_TO_ADDR
// if p3 = 24 then
91001: LD_VAR 0 3
91005: PUSH
91006: LD_INT 24
91008: EQUAL
91009: IFFALSE 91019
// sShovel := true ;
91011: LD_ADDR_EXP 135
91015: PUSH
91016: LD_INT 1
91018: ST_TO_ADDR
// if p3 = 25 then
91019: LD_VAR 0 3
91023: PUSH
91024: LD_INT 25
91026: EQUAL
91027: IFFALSE 91037
// sSheik := true ;
91029: LD_ADDR_EXP 136
91033: PUSH
91034: LD_INT 1
91036: ST_TO_ADDR
// if p3 = 26 then
91037: LD_VAR 0 3
91041: PUSH
91042: LD_INT 26
91044: EQUAL
91045: IFFALSE 91055
// sEarthquake := true ;
91047: LD_ADDR_EXP 138
91051: PUSH
91052: LD_INT 1
91054: ST_TO_ADDR
// if p3 = 27 then
91055: LD_VAR 0 3
91059: PUSH
91060: LD_INT 27
91062: EQUAL
91063: IFFALSE 91073
// sAI := true ;
91065: LD_ADDR_EXP 139
91069: PUSH
91070: LD_INT 1
91072: ST_TO_ADDR
// if p3 = 28 then
91073: LD_VAR 0 3
91077: PUSH
91078: LD_INT 28
91080: EQUAL
91081: IFFALSE 91091
// sCargo := true ;
91083: LD_ADDR_EXP 142
91087: PUSH
91088: LD_INT 1
91090: ST_TO_ADDR
// if p3 = 29 then
91091: LD_VAR 0 3
91095: PUSH
91096: LD_INT 29
91098: EQUAL
91099: IFFALSE 91109
// sDLaser := true ;
91101: LD_ADDR_EXP 143
91105: PUSH
91106: LD_INT 1
91108: ST_TO_ADDR
// if p3 = 30 then
91109: LD_VAR 0 3
91113: PUSH
91114: LD_INT 30
91116: EQUAL
91117: IFFALSE 91127
// sExchange := true ;
91119: LD_ADDR_EXP 144
91123: PUSH
91124: LD_INT 1
91126: ST_TO_ADDR
// if p3 = 31 then
91127: LD_VAR 0 3
91131: PUSH
91132: LD_INT 31
91134: EQUAL
91135: IFFALSE 91145
// sFac := true ;
91137: LD_ADDR_EXP 145
91141: PUSH
91142: LD_INT 1
91144: ST_TO_ADDR
// if p3 = 32 then
91145: LD_VAR 0 3
91149: PUSH
91150: LD_INT 32
91152: EQUAL
91153: IFFALSE 91163
// sPower := true ;
91155: LD_ADDR_EXP 146
91159: PUSH
91160: LD_INT 1
91162: ST_TO_ADDR
// if p3 = 33 then
91163: LD_VAR 0 3
91167: PUSH
91168: LD_INT 33
91170: EQUAL
91171: IFFALSE 91181
// sRandom := true ;
91173: LD_ADDR_EXP 147
91177: PUSH
91178: LD_INT 1
91180: ST_TO_ADDR
// if p3 = 34 then
91181: LD_VAR 0 3
91185: PUSH
91186: LD_INT 34
91188: EQUAL
91189: IFFALSE 91199
// sShield := true ;
91191: LD_ADDR_EXP 148
91195: PUSH
91196: LD_INT 1
91198: ST_TO_ADDR
// if p3 = 35 then
91199: LD_VAR 0 3
91203: PUSH
91204: LD_INT 35
91206: EQUAL
91207: IFFALSE 91217
// sTime := true ;
91209: LD_ADDR_EXP 149
91213: PUSH
91214: LD_INT 1
91216: ST_TO_ADDR
// if p3 = 36 then
91217: LD_VAR 0 3
91221: PUSH
91222: LD_INT 36
91224: EQUAL
91225: IFFALSE 91235
// sTools := true ;
91227: LD_ADDR_EXP 150
91231: PUSH
91232: LD_INT 1
91234: ST_TO_ADDR
// if p3 = 101 then
91235: LD_VAR 0 3
91239: PUSH
91240: LD_INT 101
91242: EQUAL
91243: IFFALSE 91253
// sSold := true ;
91245: LD_ADDR_EXP 115
91249: PUSH
91250: LD_INT 1
91252: ST_TO_ADDR
// if p3 = 102 then
91253: LD_VAR 0 3
91257: PUSH
91258: LD_INT 102
91260: EQUAL
91261: IFFALSE 91271
// sDiff := true ;
91263: LD_ADDR_EXP 116
91267: PUSH
91268: LD_INT 1
91270: ST_TO_ADDR
// if p3 = 103 then
91271: LD_VAR 0 3
91275: PUSH
91276: LD_INT 103
91278: EQUAL
91279: IFFALSE 91289
// sFog := true ;
91281: LD_ADDR_EXP 119
91285: PUSH
91286: LD_INT 1
91288: ST_TO_ADDR
// if p3 = 104 then
91289: LD_VAR 0 3
91293: PUSH
91294: LD_INT 104
91296: EQUAL
91297: IFFALSE 91307
// sReset := true ;
91299: LD_ADDR_EXP 120
91303: PUSH
91304: LD_INT 1
91306: ST_TO_ADDR
// if p3 = 105 then
91307: LD_VAR 0 3
91311: PUSH
91312: LD_INT 105
91314: EQUAL
91315: IFFALSE 91325
// sSun := true ;
91317: LD_ADDR_EXP 121
91321: PUSH
91322: LD_INT 1
91324: ST_TO_ADDR
// if p3 = 106 then
91325: LD_VAR 0 3
91329: PUSH
91330: LD_INT 106
91332: EQUAL
91333: IFFALSE 91343
// sTiger := true ;
91335: LD_ADDR_EXP 117
91339: PUSH
91340: LD_INT 1
91342: ST_TO_ADDR
// if p3 = 107 then
91343: LD_VAR 0 3
91347: PUSH
91348: LD_INT 107
91350: EQUAL
91351: IFFALSE 91361
// sBomb := true ;
91353: LD_ADDR_EXP 118
91357: PUSH
91358: LD_INT 1
91360: ST_TO_ADDR
// if p3 = 108 then
91361: LD_VAR 0 3
91365: PUSH
91366: LD_INT 108
91368: EQUAL
91369: IFFALSE 91379
// sWound := true ;
91371: LD_ADDR_EXP 126
91375: PUSH
91376: LD_INT 1
91378: ST_TO_ADDR
// if p3 = 109 then
91379: LD_VAR 0 3
91383: PUSH
91384: LD_INT 109
91386: EQUAL
91387: IFFALSE 91397
// sBetray := true ;
91389: LD_ADDR_EXP 130
91393: PUSH
91394: LD_INT 1
91396: ST_TO_ADDR
// if p3 = 110 then
91397: LD_VAR 0 3
91401: PUSH
91402: LD_INT 110
91404: EQUAL
91405: IFFALSE 91415
// sContamin := true ;
91407: LD_ADDR_EXP 131
91411: PUSH
91412: LD_INT 1
91414: ST_TO_ADDR
// if p3 = 111 then
91415: LD_VAR 0 3
91419: PUSH
91420: LD_INT 111
91422: EQUAL
91423: IFFALSE 91433
// sOil := true ;
91425: LD_ADDR_EXP 133
91429: PUSH
91430: LD_INT 1
91432: ST_TO_ADDR
// if p3 = 112 then
91433: LD_VAR 0 3
91437: PUSH
91438: LD_INT 112
91440: EQUAL
91441: IFFALSE 91451
// sStu := true ;
91443: LD_ADDR_EXP 137
91447: PUSH
91448: LD_INT 1
91450: ST_TO_ADDR
// if p3 = 113 then
91451: LD_VAR 0 3
91455: PUSH
91456: LD_INT 113
91458: EQUAL
91459: IFFALSE 91469
// sBazooka := true ;
91461: LD_ADDR_EXP 140
91465: PUSH
91466: LD_INT 1
91468: ST_TO_ADDR
// if p3 = 114 then
91469: LD_VAR 0 3
91473: PUSH
91474: LD_INT 114
91476: EQUAL
91477: IFFALSE 91487
// sMortar := true ;
91479: LD_ADDR_EXP 141
91483: PUSH
91484: LD_INT 1
91486: ST_TO_ADDR
// if p3 = 115 then
91487: LD_VAR 0 3
91491: PUSH
91492: LD_INT 115
91494: EQUAL
91495: IFFALSE 91505
// sRanger := true ;
91497: LD_ADDR_EXP 151
91501: PUSH
91502: LD_INT 1
91504: ST_TO_ADDR
// end ; if p2 = 101 then
91505: LD_VAR 0 2
91509: PUSH
91510: LD_INT 101
91512: EQUAL
91513: IFFALSE 91641
// begin case p3 of 1 :
91515: LD_VAR 0 3
91519: PUSH
91520: LD_INT 1
91522: DOUBLE
91523: EQUAL
91524: IFTRUE 91528
91526: GO 91535
91528: POP
// hHackUnlimitedResources ; 2 :
91529: CALL 102678 0 0
91533: GO 91641
91535: LD_INT 2
91537: DOUBLE
91538: EQUAL
91539: IFTRUE 91543
91541: GO 91550
91543: POP
// hHackSetLevel10 ; 3 :
91544: CALL 102811 0 0
91548: GO 91641
91550: LD_INT 3
91552: DOUBLE
91553: EQUAL
91554: IFTRUE 91558
91556: GO 91565
91558: POP
// hHackSetLevel10YourUnits ; 4 :
91559: CALL 102896 0 0
91563: GO 91641
91565: LD_INT 4
91567: DOUBLE
91568: EQUAL
91569: IFTRUE 91573
91571: GO 91580
91573: POP
// hHackInvincible ; 5 :
91574: CALL 103344 0 0
91578: GO 91641
91580: LD_INT 5
91582: DOUBLE
91583: EQUAL
91584: IFTRUE 91588
91586: GO 91595
91588: POP
// hHackInvisible ; 6 :
91589: CALL 103455 0 0
91593: GO 91641
91595: LD_INT 6
91597: DOUBLE
91598: EQUAL
91599: IFTRUE 91603
91601: GO 91610
91603: POP
// hHackChangeYourSide ; 7 :
91604: CALL 103512 0 0
91608: GO 91641
91610: LD_INT 7
91612: DOUBLE
91613: EQUAL
91614: IFTRUE 91618
91616: GO 91625
91618: POP
// hHackChangeUnitSide ; 8 :
91619: CALL 103554 0 0
91623: GO 91641
91625: LD_INT 8
91627: DOUBLE
91628: EQUAL
91629: IFTRUE 91633
91631: GO 91640
91633: POP
// hHackFog ; end ;
91634: CALL 103655 0 0
91638: GO 91641
91640: POP
// end ; end ;
91641: LD_VAR 0 7
91645: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
91646: GO 91648
91648: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
91649: LD_STRING initStreamRollete();
91651: PPUSH
91652: CALL_OW 559
// InitStreamMode ;
91656: CALL 91665 0 0
// DefineStreamItems ( ) ;
91660: CALL 92105 0 0
// end ;
91664: END
// function InitStreamMode ; begin
91665: LD_INT 0
91667: PPUSH
// streamModeActive := false ;
91668: LD_ADDR_EXP 98
91672: PUSH
91673: LD_INT 0
91675: ST_TO_ADDR
// normalCounter := 36 ;
91676: LD_ADDR_EXP 99
91680: PUSH
91681: LD_INT 36
91683: ST_TO_ADDR
// hardcoreCounter := 16 ;
91684: LD_ADDR_EXP 100
91688: PUSH
91689: LD_INT 16
91691: ST_TO_ADDR
// sRocket := false ;
91692: LD_ADDR_EXP 103
91696: PUSH
91697: LD_INT 0
91699: ST_TO_ADDR
// sSpeed := false ;
91700: LD_ADDR_EXP 102
91704: PUSH
91705: LD_INT 0
91707: ST_TO_ADDR
// sEngine := false ;
91708: LD_ADDR_EXP 104
91712: PUSH
91713: LD_INT 0
91715: ST_TO_ADDR
// sSpec := false ;
91716: LD_ADDR_EXP 101
91720: PUSH
91721: LD_INT 0
91723: ST_TO_ADDR
// sLevel := false ;
91724: LD_ADDR_EXP 105
91728: PUSH
91729: LD_INT 0
91731: ST_TO_ADDR
// sArmoury := false ;
91732: LD_ADDR_EXP 106
91736: PUSH
91737: LD_INT 0
91739: ST_TO_ADDR
// sRadar := false ;
91740: LD_ADDR_EXP 107
91744: PUSH
91745: LD_INT 0
91747: ST_TO_ADDR
// sBunker := false ;
91748: LD_ADDR_EXP 108
91752: PUSH
91753: LD_INT 0
91755: ST_TO_ADDR
// sHack := false ;
91756: LD_ADDR_EXP 109
91760: PUSH
91761: LD_INT 0
91763: ST_TO_ADDR
// sFire := false ;
91764: LD_ADDR_EXP 110
91768: PUSH
91769: LD_INT 0
91771: ST_TO_ADDR
// sRefresh := false ;
91772: LD_ADDR_EXP 111
91776: PUSH
91777: LD_INT 0
91779: ST_TO_ADDR
// sExp := false ;
91780: LD_ADDR_EXP 112
91784: PUSH
91785: LD_INT 0
91787: ST_TO_ADDR
// sDepot := false ;
91788: LD_ADDR_EXP 113
91792: PUSH
91793: LD_INT 0
91795: ST_TO_ADDR
// sFlag := false ;
91796: LD_ADDR_EXP 114
91800: PUSH
91801: LD_INT 0
91803: ST_TO_ADDR
// sKamikadze := false ;
91804: LD_ADDR_EXP 122
91808: PUSH
91809: LD_INT 0
91811: ST_TO_ADDR
// sTroll := false ;
91812: LD_ADDR_EXP 123
91816: PUSH
91817: LD_INT 0
91819: ST_TO_ADDR
// sSlow := false ;
91820: LD_ADDR_EXP 124
91824: PUSH
91825: LD_INT 0
91827: ST_TO_ADDR
// sLack := false ;
91828: LD_ADDR_EXP 125
91832: PUSH
91833: LD_INT 0
91835: ST_TO_ADDR
// sTank := false ;
91836: LD_ADDR_EXP 127
91840: PUSH
91841: LD_INT 0
91843: ST_TO_ADDR
// sRemote := false ;
91844: LD_ADDR_EXP 128
91848: PUSH
91849: LD_INT 0
91851: ST_TO_ADDR
// sPowell := false ;
91852: LD_ADDR_EXP 129
91856: PUSH
91857: LD_INT 0
91859: ST_TO_ADDR
// sTeleport := false ;
91860: LD_ADDR_EXP 132
91864: PUSH
91865: LD_INT 0
91867: ST_TO_ADDR
// sOilTower := false ;
91868: LD_ADDR_EXP 134
91872: PUSH
91873: LD_INT 0
91875: ST_TO_ADDR
// sShovel := false ;
91876: LD_ADDR_EXP 135
91880: PUSH
91881: LD_INT 0
91883: ST_TO_ADDR
// sSheik := false ;
91884: LD_ADDR_EXP 136
91888: PUSH
91889: LD_INT 0
91891: ST_TO_ADDR
// sEarthquake := false ;
91892: LD_ADDR_EXP 138
91896: PUSH
91897: LD_INT 0
91899: ST_TO_ADDR
// sAI := false ;
91900: LD_ADDR_EXP 139
91904: PUSH
91905: LD_INT 0
91907: ST_TO_ADDR
// sCargo := false ;
91908: LD_ADDR_EXP 142
91912: PUSH
91913: LD_INT 0
91915: ST_TO_ADDR
// sDLaser := false ;
91916: LD_ADDR_EXP 143
91920: PUSH
91921: LD_INT 0
91923: ST_TO_ADDR
// sExchange := false ;
91924: LD_ADDR_EXP 144
91928: PUSH
91929: LD_INT 0
91931: ST_TO_ADDR
// sFac := false ;
91932: LD_ADDR_EXP 145
91936: PUSH
91937: LD_INT 0
91939: ST_TO_ADDR
// sPower := false ;
91940: LD_ADDR_EXP 146
91944: PUSH
91945: LD_INT 0
91947: ST_TO_ADDR
// sRandom := false ;
91948: LD_ADDR_EXP 147
91952: PUSH
91953: LD_INT 0
91955: ST_TO_ADDR
// sShield := false ;
91956: LD_ADDR_EXP 148
91960: PUSH
91961: LD_INT 0
91963: ST_TO_ADDR
// sTime := false ;
91964: LD_ADDR_EXP 149
91968: PUSH
91969: LD_INT 0
91971: ST_TO_ADDR
// sTools := false ;
91972: LD_ADDR_EXP 150
91976: PUSH
91977: LD_INT 0
91979: ST_TO_ADDR
// sSold := false ;
91980: LD_ADDR_EXP 115
91984: PUSH
91985: LD_INT 0
91987: ST_TO_ADDR
// sDiff := false ;
91988: LD_ADDR_EXP 116
91992: PUSH
91993: LD_INT 0
91995: ST_TO_ADDR
// sFog := false ;
91996: LD_ADDR_EXP 119
92000: PUSH
92001: LD_INT 0
92003: ST_TO_ADDR
// sReset := false ;
92004: LD_ADDR_EXP 120
92008: PUSH
92009: LD_INT 0
92011: ST_TO_ADDR
// sSun := false ;
92012: LD_ADDR_EXP 121
92016: PUSH
92017: LD_INT 0
92019: ST_TO_ADDR
// sTiger := false ;
92020: LD_ADDR_EXP 117
92024: PUSH
92025: LD_INT 0
92027: ST_TO_ADDR
// sBomb := false ;
92028: LD_ADDR_EXP 118
92032: PUSH
92033: LD_INT 0
92035: ST_TO_ADDR
// sWound := false ;
92036: LD_ADDR_EXP 126
92040: PUSH
92041: LD_INT 0
92043: ST_TO_ADDR
// sBetray := false ;
92044: LD_ADDR_EXP 130
92048: PUSH
92049: LD_INT 0
92051: ST_TO_ADDR
// sContamin := false ;
92052: LD_ADDR_EXP 131
92056: PUSH
92057: LD_INT 0
92059: ST_TO_ADDR
// sOil := false ;
92060: LD_ADDR_EXP 133
92064: PUSH
92065: LD_INT 0
92067: ST_TO_ADDR
// sStu := false ;
92068: LD_ADDR_EXP 137
92072: PUSH
92073: LD_INT 0
92075: ST_TO_ADDR
// sBazooka := false ;
92076: LD_ADDR_EXP 140
92080: PUSH
92081: LD_INT 0
92083: ST_TO_ADDR
// sMortar := false ;
92084: LD_ADDR_EXP 141
92088: PUSH
92089: LD_INT 0
92091: ST_TO_ADDR
// sRanger := false ;
92092: LD_ADDR_EXP 151
92096: PUSH
92097: LD_INT 0
92099: ST_TO_ADDR
// end ;
92100: LD_VAR 0 1
92104: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
92105: LD_INT 0
92107: PPUSH
92108: PPUSH
92109: PPUSH
92110: PPUSH
92111: PPUSH
// result := [ ] ;
92112: LD_ADDR_VAR 0 1
92116: PUSH
92117: EMPTY
92118: ST_TO_ADDR
// if campaign_id = 1 then
92119: LD_OWVAR 69
92123: PUSH
92124: LD_INT 1
92126: EQUAL
92127: IFFALSE 95065
// begin case mission_number of 1 :
92129: LD_OWVAR 70
92133: PUSH
92134: LD_INT 1
92136: DOUBLE
92137: EQUAL
92138: IFTRUE 92142
92140: GO 92206
92142: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
92143: LD_ADDR_VAR 0 1
92147: PUSH
92148: LD_INT 2
92150: PUSH
92151: LD_INT 4
92153: PUSH
92154: LD_INT 11
92156: PUSH
92157: LD_INT 12
92159: PUSH
92160: LD_INT 15
92162: PUSH
92163: LD_INT 16
92165: PUSH
92166: LD_INT 22
92168: PUSH
92169: LD_INT 23
92171: PUSH
92172: LD_INT 26
92174: PUSH
92175: EMPTY
92176: LIST
92177: LIST
92178: LIST
92179: LIST
92180: LIST
92181: LIST
92182: LIST
92183: LIST
92184: LIST
92185: PUSH
92186: LD_INT 101
92188: PUSH
92189: LD_INT 102
92191: PUSH
92192: LD_INT 106
92194: PUSH
92195: EMPTY
92196: LIST
92197: LIST
92198: LIST
92199: PUSH
92200: EMPTY
92201: LIST
92202: LIST
92203: ST_TO_ADDR
92204: GO 95063
92206: LD_INT 2
92208: DOUBLE
92209: EQUAL
92210: IFTRUE 92214
92212: GO 92286
92214: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
92215: LD_ADDR_VAR 0 1
92219: PUSH
92220: LD_INT 2
92222: PUSH
92223: LD_INT 4
92225: PUSH
92226: LD_INT 11
92228: PUSH
92229: LD_INT 12
92231: PUSH
92232: LD_INT 15
92234: PUSH
92235: LD_INT 16
92237: PUSH
92238: LD_INT 22
92240: PUSH
92241: LD_INT 23
92243: PUSH
92244: LD_INT 26
92246: PUSH
92247: EMPTY
92248: LIST
92249: LIST
92250: LIST
92251: LIST
92252: LIST
92253: LIST
92254: LIST
92255: LIST
92256: LIST
92257: PUSH
92258: LD_INT 101
92260: PUSH
92261: LD_INT 102
92263: PUSH
92264: LD_INT 105
92266: PUSH
92267: LD_INT 106
92269: PUSH
92270: LD_INT 108
92272: PUSH
92273: EMPTY
92274: LIST
92275: LIST
92276: LIST
92277: LIST
92278: LIST
92279: PUSH
92280: EMPTY
92281: LIST
92282: LIST
92283: ST_TO_ADDR
92284: GO 95063
92286: LD_INT 3
92288: DOUBLE
92289: EQUAL
92290: IFTRUE 92294
92292: GO 92370
92294: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
92295: LD_ADDR_VAR 0 1
92299: PUSH
92300: LD_INT 2
92302: PUSH
92303: LD_INT 4
92305: PUSH
92306: LD_INT 5
92308: PUSH
92309: LD_INT 11
92311: PUSH
92312: LD_INT 12
92314: PUSH
92315: LD_INT 15
92317: PUSH
92318: LD_INT 16
92320: PUSH
92321: LD_INT 22
92323: PUSH
92324: LD_INT 26
92326: PUSH
92327: LD_INT 36
92329: PUSH
92330: EMPTY
92331: LIST
92332: LIST
92333: LIST
92334: LIST
92335: LIST
92336: LIST
92337: LIST
92338: LIST
92339: LIST
92340: LIST
92341: PUSH
92342: LD_INT 101
92344: PUSH
92345: LD_INT 102
92347: PUSH
92348: LD_INT 105
92350: PUSH
92351: LD_INT 106
92353: PUSH
92354: LD_INT 108
92356: PUSH
92357: EMPTY
92358: LIST
92359: LIST
92360: LIST
92361: LIST
92362: LIST
92363: PUSH
92364: EMPTY
92365: LIST
92366: LIST
92367: ST_TO_ADDR
92368: GO 95063
92370: LD_INT 4
92372: DOUBLE
92373: EQUAL
92374: IFTRUE 92378
92376: GO 92462
92378: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
92379: LD_ADDR_VAR 0 1
92383: PUSH
92384: LD_INT 2
92386: PUSH
92387: LD_INT 4
92389: PUSH
92390: LD_INT 5
92392: PUSH
92393: LD_INT 8
92395: PUSH
92396: LD_INT 11
92398: PUSH
92399: LD_INT 12
92401: PUSH
92402: LD_INT 15
92404: PUSH
92405: LD_INT 16
92407: PUSH
92408: LD_INT 22
92410: PUSH
92411: LD_INT 23
92413: PUSH
92414: LD_INT 26
92416: PUSH
92417: LD_INT 36
92419: PUSH
92420: EMPTY
92421: LIST
92422: LIST
92423: LIST
92424: LIST
92425: LIST
92426: LIST
92427: LIST
92428: LIST
92429: LIST
92430: LIST
92431: LIST
92432: LIST
92433: PUSH
92434: LD_INT 101
92436: PUSH
92437: LD_INT 102
92439: PUSH
92440: LD_INT 105
92442: PUSH
92443: LD_INT 106
92445: PUSH
92446: LD_INT 108
92448: PUSH
92449: EMPTY
92450: LIST
92451: LIST
92452: LIST
92453: LIST
92454: LIST
92455: PUSH
92456: EMPTY
92457: LIST
92458: LIST
92459: ST_TO_ADDR
92460: GO 95063
92462: LD_INT 5
92464: DOUBLE
92465: EQUAL
92466: IFTRUE 92470
92468: GO 92570
92470: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
92471: LD_ADDR_VAR 0 1
92475: PUSH
92476: LD_INT 2
92478: PUSH
92479: LD_INT 4
92481: PUSH
92482: LD_INT 5
92484: PUSH
92485: LD_INT 6
92487: PUSH
92488: LD_INT 8
92490: PUSH
92491: LD_INT 11
92493: PUSH
92494: LD_INT 12
92496: PUSH
92497: LD_INT 15
92499: PUSH
92500: LD_INT 16
92502: PUSH
92503: LD_INT 22
92505: PUSH
92506: LD_INT 23
92508: PUSH
92509: LD_INT 25
92511: PUSH
92512: LD_INT 26
92514: PUSH
92515: LD_INT 36
92517: PUSH
92518: EMPTY
92519: LIST
92520: LIST
92521: LIST
92522: LIST
92523: LIST
92524: LIST
92525: LIST
92526: LIST
92527: LIST
92528: LIST
92529: LIST
92530: LIST
92531: LIST
92532: LIST
92533: PUSH
92534: LD_INT 101
92536: PUSH
92537: LD_INT 102
92539: PUSH
92540: LD_INT 105
92542: PUSH
92543: LD_INT 106
92545: PUSH
92546: LD_INT 108
92548: PUSH
92549: LD_INT 109
92551: PUSH
92552: LD_INT 112
92554: PUSH
92555: EMPTY
92556: LIST
92557: LIST
92558: LIST
92559: LIST
92560: LIST
92561: LIST
92562: LIST
92563: PUSH
92564: EMPTY
92565: LIST
92566: LIST
92567: ST_TO_ADDR
92568: GO 95063
92570: LD_INT 6
92572: DOUBLE
92573: EQUAL
92574: IFTRUE 92578
92576: GO 92698
92578: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
92579: LD_ADDR_VAR 0 1
92583: PUSH
92584: LD_INT 2
92586: PUSH
92587: LD_INT 4
92589: PUSH
92590: LD_INT 5
92592: PUSH
92593: LD_INT 6
92595: PUSH
92596: LD_INT 8
92598: PUSH
92599: LD_INT 11
92601: PUSH
92602: LD_INT 12
92604: PUSH
92605: LD_INT 15
92607: PUSH
92608: LD_INT 16
92610: PUSH
92611: LD_INT 20
92613: PUSH
92614: LD_INT 21
92616: PUSH
92617: LD_INT 22
92619: PUSH
92620: LD_INT 23
92622: PUSH
92623: LD_INT 25
92625: PUSH
92626: LD_INT 26
92628: PUSH
92629: LD_INT 30
92631: PUSH
92632: LD_INT 31
92634: PUSH
92635: LD_INT 32
92637: PUSH
92638: LD_INT 36
92640: PUSH
92641: EMPTY
92642: LIST
92643: LIST
92644: LIST
92645: LIST
92646: LIST
92647: LIST
92648: LIST
92649: LIST
92650: LIST
92651: LIST
92652: LIST
92653: LIST
92654: LIST
92655: LIST
92656: LIST
92657: LIST
92658: LIST
92659: LIST
92660: LIST
92661: PUSH
92662: LD_INT 101
92664: PUSH
92665: LD_INT 102
92667: PUSH
92668: LD_INT 105
92670: PUSH
92671: LD_INT 106
92673: PUSH
92674: LD_INT 108
92676: PUSH
92677: LD_INT 109
92679: PUSH
92680: LD_INT 112
92682: PUSH
92683: EMPTY
92684: LIST
92685: LIST
92686: LIST
92687: LIST
92688: LIST
92689: LIST
92690: LIST
92691: PUSH
92692: EMPTY
92693: LIST
92694: LIST
92695: ST_TO_ADDR
92696: GO 95063
92698: LD_INT 7
92700: DOUBLE
92701: EQUAL
92702: IFTRUE 92706
92704: GO 92806
92706: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
92707: LD_ADDR_VAR 0 1
92711: PUSH
92712: LD_INT 2
92714: PUSH
92715: LD_INT 4
92717: PUSH
92718: LD_INT 5
92720: PUSH
92721: LD_INT 7
92723: PUSH
92724: LD_INT 11
92726: PUSH
92727: LD_INT 12
92729: PUSH
92730: LD_INT 15
92732: PUSH
92733: LD_INT 16
92735: PUSH
92736: LD_INT 20
92738: PUSH
92739: LD_INT 21
92741: PUSH
92742: LD_INT 22
92744: PUSH
92745: LD_INT 23
92747: PUSH
92748: LD_INT 25
92750: PUSH
92751: LD_INT 26
92753: PUSH
92754: EMPTY
92755: LIST
92756: LIST
92757: LIST
92758: LIST
92759: LIST
92760: LIST
92761: LIST
92762: LIST
92763: LIST
92764: LIST
92765: LIST
92766: LIST
92767: LIST
92768: LIST
92769: PUSH
92770: LD_INT 101
92772: PUSH
92773: LD_INT 102
92775: PUSH
92776: LD_INT 103
92778: PUSH
92779: LD_INT 105
92781: PUSH
92782: LD_INT 106
92784: PUSH
92785: LD_INT 108
92787: PUSH
92788: LD_INT 112
92790: PUSH
92791: EMPTY
92792: LIST
92793: LIST
92794: LIST
92795: LIST
92796: LIST
92797: LIST
92798: LIST
92799: PUSH
92800: EMPTY
92801: LIST
92802: LIST
92803: ST_TO_ADDR
92804: GO 95063
92806: LD_INT 8
92808: DOUBLE
92809: EQUAL
92810: IFTRUE 92814
92812: GO 92942
92814: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
92815: LD_ADDR_VAR 0 1
92819: PUSH
92820: LD_INT 2
92822: PUSH
92823: LD_INT 4
92825: PUSH
92826: LD_INT 5
92828: PUSH
92829: LD_INT 6
92831: PUSH
92832: LD_INT 7
92834: PUSH
92835: LD_INT 8
92837: PUSH
92838: LD_INT 11
92840: PUSH
92841: LD_INT 12
92843: PUSH
92844: LD_INT 15
92846: PUSH
92847: LD_INT 16
92849: PUSH
92850: LD_INT 20
92852: PUSH
92853: LD_INT 21
92855: PUSH
92856: LD_INT 22
92858: PUSH
92859: LD_INT 23
92861: PUSH
92862: LD_INT 25
92864: PUSH
92865: LD_INT 26
92867: PUSH
92868: LD_INT 30
92870: PUSH
92871: LD_INT 31
92873: PUSH
92874: LD_INT 32
92876: PUSH
92877: LD_INT 36
92879: PUSH
92880: EMPTY
92881: LIST
92882: LIST
92883: LIST
92884: LIST
92885: LIST
92886: LIST
92887: LIST
92888: LIST
92889: LIST
92890: LIST
92891: LIST
92892: LIST
92893: LIST
92894: LIST
92895: LIST
92896: LIST
92897: LIST
92898: LIST
92899: LIST
92900: LIST
92901: PUSH
92902: LD_INT 101
92904: PUSH
92905: LD_INT 102
92907: PUSH
92908: LD_INT 103
92910: PUSH
92911: LD_INT 105
92913: PUSH
92914: LD_INT 106
92916: PUSH
92917: LD_INT 108
92919: PUSH
92920: LD_INT 109
92922: PUSH
92923: LD_INT 112
92925: PUSH
92926: EMPTY
92927: LIST
92928: LIST
92929: LIST
92930: LIST
92931: LIST
92932: LIST
92933: LIST
92934: LIST
92935: PUSH
92936: EMPTY
92937: LIST
92938: LIST
92939: ST_TO_ADDR
92940: GO 95063
92942: LD_INT 9
92944: DOUBLE
92945: EQUAL
92946: IFTRUE 92950
92948: GO 93086
92950: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
92951: LD_ADDR_VAR 0 1
92955: PUSH
92956: LD_INT 2
92958: PUSH
92959: LD_INT 4
92961: PUSH
92962: LD_INT 5
92964: PUSH
92965: LD_INT 6
92967: PUSH
92968: LD_INT 7
92970: PUSH
92971: LD_INT 8
92973: PUSH
92974: LD_INT 11
92976: PUSH
92977: LD_INT 12
92979: PUSH
92980: LD_INT 15
92982: PUSH
92983: LD_INT 16
92985: PUSH
92986: LD_INT 20
92988: PUSH
92989: LD_INT 21
92991: PUSH
92992: LD_INT 22
92994: PUSH
92995: LD_INT 23
92997: PUSH
92998: LD_INT 25
93000: PUSH
93001: LD_INT 26
93003: PUSH
93004: LD_INT 28
93006: PUSH
93007: LD_INT 30
93009: PUSH
93010: LD_INT 31
93012: PUSH
93013: LD_INT 32
93015: PUSH
93016: LD_INT 36
93018: PUSH
93019: EMPTY
93020: LIST
93021: LIST
93022: LIST
93023: LIST
93024: LIST
93025: LIST
93026: LIST
93027: LIST
93028: LIST
93029: LIST
93030: LIST
93031: LIST
93032: LIST
93033: LIST
93034: LIST
93035: LIST
93036: LIST
93037: LIST
93038: LIST
93039: LIST
93040: LIST
93041: PUSH
93042: LD_INT 101
93044: PUSH
93045: LD_INT 102
93047: PUSH
93048: LD_INT 103
93050: PUSH
93051: LD_INT 105
93053: PUSH
93054: LD_INT 106
93056: PUSH
93057: LD_INT 108
93059: PUSH
93060: LD_INT 109
93062: PUSH
93063: LD_INT 112
93065: PUSH
93066: LD_INT 114
93068: PUSH
93069: EMPTY
93070: LIST
93071: LIST
93072: LIST
93073: LIST
93074: LIST
93075: LIST
93076: LIST
93077: LIST
93078: LIST
93079: PUSH
93080: EMPTY
93081: LIST
93082: LIST
93083: ST_TO_ADDR
93084: GO 95063
93086: LD_INT 10
93088: DOUBLE
93089: EQUAL
93090: IFTRUE 93094
93092: GO 93278
93094: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
93095: LD_ADDR_VAR 0 1
93099: PUSH
93100: LD_INT 2
93102: PUSH
93103: LD_INT 4
93105: PUSH
93106: LD_INT 5
93108: PUSH
93109: LD_INT 6
93111: PUSH
93112: LD_INT 7
93114: PUSH
93115: LD_INT 8
93117: PUSH
93118: LD_INT 9
93120: PUSH
93121: LD_INT 10
93123: PUSH
93124: LD_INT 11
93126: PUSH
93127: LD_INT 12
93129: PUSH
93130: LD_INT 13
93132: PUSH
93133: LD_INT 14
93135: PUSH
93136: LD_INT 15
93138: PUSH
93139: LD_INT 16
93141: PUSH
93142: LD_INT 17
93144: PUSH
93145: LD_INT 18
93147: PUSH
93148: LD_INT 19
93150: PUSH
93151: LD_INT 20
93153: PUSH
93154: LD_INT 21
93156: PUSH
93157: LD_INT 22
93159: PUSH
93160: LD_INT 23
93162: PUSH
93163: LD_INT 24
93165: PUSH
93166: LD_INT 25
93168: PUSH
93169: LD_INT 26
93171: PUSH
93172: LD_INT 28
93174: PUSH
93175: LD_INT 30
93177: PUSH
93178: LD_INT 31
93180: PUSH
93181: LD_INT 32
93183: PUSH
93184: LD_INT 36
93186: PUSH
93187: EMPTY
93188: LIST
93189: LIST
93190: LIST
93191: LIST
93192: LIST
93193: LIST
93194: LIST
93195: LIST
93196: LIST
93197: LIST
93198: LIST
93199: LIST
93200: LIST
93201: LIST
93202: LIST
93203: LIST
93204: LIST
93205: LIST
93206: LIST
93207: LIST
93208: LIST
93209: LIST
93210: LIST
93211: LIST
93212: LIST
93213: LIST
93214: LIST
93215: LIST
93216: LIST
93217: PUSH
93218: LD_INT 101
93220: PUSH
93221: LD_INT 102
93223: PUSH
93224: LD_INT 103
93226: PUSH
93227: LD_INT 104
93229: PUSH
93230: LD_INT 105
93232: PUSH
93233: LD_INT 106
93235: PUSH
93236: LD_INT 107
93238: PUSH
93239: LD_INT 108
93241: PUSH
93242: LD_INT 109
93244: PUSH
93245: LD_INT 110
93247: PUSH
93248: LD_INT 111
93250: PUSH
93251: LD_INT 112
93253: PUSH
93254: LD_INT 114
93256: PUSH
93257: EMPTY
93258: LIST
93259: LIST
93260: LIST
93261: LIST
93262: LIST
93263: LIST
93264: LIST
93265: LIST
93266: LIST
93267: LIST
93268: LIST
93269: LIST
93270: LIST
93271: PUSH
93272: EMPTY
93273: LIST
93274: LIST
93275: ST_TO_ADDR
93276: GO 95063
93278: LD_INT 11
93280: DOUBLE
93281: EQUAL
93282: IFTRUE 93286
93284: GO 93478
93286: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
93287: LD_ADDR_VAR 0 1
93291: PUSH
93292: LD_INT 2
93294: PUSH
93295: LD_INT 3
93297: PUSH
93298: LD_INT 4
93300: PUSH
93301: LD_INT 5
93303: PUSH
93304: LD_INT 6
93306: PUSH
93307: LD_INT 7
93309: PUSH
93310: LD_INT 8
93312: PUSH
93313: LD_INT 9
93315: PUSH
93316: LD_INT 10
93318: PUSH
93319: LD_INT 11
93321: PUSH
93322: LD_INT 12
93324: PUSH
93325: LD_INT 13
93327: PUSH
93328: LD_INT 14
93330: PUSH
93331: LD_INT 15
93333: PUSH
93334: LD_INT 16
93336: PUSH
93337: LD_INT 17
93339: PUSH
93340: LD_INT 18
93342: PUSH
93343: LD_INT 19
93345: PUSH
93346: LD_INT 20
93348: PUSH
93349: LD_INT 21
93351: PUSH
93352: LD_INT 22
93354: PUSH
93355: LD_INT 23
93357: PUSH
93358: LD_INT 24
93360: PUSH
93361: LD_INT 25
93363: PUSH
93364: LD_INT 26
93366: PUSH
93367: LD_INT 28
93369: PUSH
93370: LD_INT 30
93372: PUSH
93373: LD_INT 31
93375: PUSH
93376: LD_INT 32
93378: PUSH
93379: LD_INT 34
93381: PUSH
93382: LD_INT 36
93384: PUSH
93385: EMPTY
93386: LIST
93387: LIST
93388: LIST
93389: LIST
93390: LIST
93391: LIST
93392: LIST
93393: LIST
93394: LIST
93395: LIST
93396: LIST
93397: LIST
93398: LIST
93399: LIST
93400: LIST
93401: LIST
93402: LIST
93403: LIST
93404: LIST
93405: LIST
93406: LIST
93407: LIST
93408: LIST
93409: LIST
93410: LIST
93411: LIST
93412: LIST
93413: LIST
93414: LIST
93415: LIST
93416: LIST
93417: PUSH
93418: LD_INT 101
93420: PUSH
93421: LD_INT 102
93423: PUSH
93424: LD_INT 103
93426: PUSH
93427: LD_INT 104
93429: PUSH
93430: LD_INT 105
93432: PUSH
93433: LD_INT 106
93435: PUSH
93436: LD_INT 107
93438: PUSH
93439: LD_INT 108
93441: PUSH
93442: LD_INT 109
93444: PUSH
93445: LD_INT 110
93447: PUSH
93448: LD_INT 111
93450: PUSH
93451: LD_INT 112
93453: PUSH
93454: LD_INT 114
93456: PUSH
93457: EMPTY
93458: LIST
93459: LIST
93460: LIST
93461: LIST
93462: LIST
93463: LIST
93464: LIST
93465: LIST
93466: LIST
93467: LIST
93468: LIST
93469: LIST
93470: LIST
93471: PUSH
93472: EMPTY
93473: LIST
93474: LIST
93475: ST_TO_ADDR
93476: GO 95063
93478: LD_INT 12
93480: DOUBLE
93481: EQUAL
93482: IFTRUE 93486
93484: GO 93694
93486: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
93487: LD_ADDR_VAR 0 1
93491: PUSH
93492: LD_INT 1
93494: PUSH
93495: LD_INT 2
93497: PUSH
93498: LD_INT 3
93500: PUSH
93501: LD_INT 4
93503: PUSH
93504: LD_INT 5
93506: PUSH
93507: LD_INT 6
93509: PUSH
93510: LD_INT 7
93512: PUSH
93513: LD_INT 8
93515: PUSH
93516: LD_INT 9
93518: PUSH
93519: LD_INT 10
93521: PUSH
93522: LD_INT 11
93524: PUSH
93525: LD_INT 12
93527: PUSH
93528: LD_INT 13
93530: PUSH
93531: LD_INT 14
93533: PUSH
93534: LD_INT 15
93536: PUSH
93537: LD_INT 16
93539: PUSH
93540: LD_INT 17
93542: PUSH
93543: LD_INT 18
93545: PUSH
93546: LD_INT 19
93548: PUSH
93549: LD_INT 20
93551: PUSH
93552: LD_INT 21
93554: PUSH
93555: LD_INT 22
93557: PUSH
93558: LD_INT 23
93560: PUSH
93561: LD_INT 24
93563: PUSH
93564: LD_INT 25
93566: PUSH
93567: LD_INT 26
93569: PUSH
93570: LD_INT 27
93572: PUSH
93573: LD_INT 28
93575: PUSH
93576: LD_INT 30
93578: PUSH
93579: LD_INT 31
93581: PUSH
93582: LD_INT 32
93584: PUSH
93585: LD_INT 33
93587: PUSH
93588: LD_INT 34
93590: PUSH
93591: LD_INT 36
93593: PUSH
93594: EMPTY
93595: LIST
93596: LIST
93597: LIST
93598: LIST
93599: LIST
93600: LIST
93601: LIST
93602: LIST
93603: LIST
93604: LIST
93605: LIST
93606: LIST
93607: LIST
93608: LIST
93609: LIST
93610: LIST
93611: LIST
93612: LIST
93613: LIST
93614: LIST
93615: LIST
93616: LIST
93617: LIST
93618: LIST
93619: LIST
93620: LIST
93621: LIST
93622: LIST
93623: LIST
93624: LIST
93625: LIST
93626: LIST
93627: LIST
93628: LIST
93629: PUSH
93630: LD_INT 101
93632: PUSH
93633: LD_INT 102
93635: PUSH
93636: LD_INT 103
93638: PUSH
93639: LD_INT 104
93641: PUSH
93642: LD_INT 105
93644: PUSH
93645: LD_INT 106
93647: PUSH
93648: LD_INT 107
93650: PUSH
93651: LD_INT 108
93653: PUSH
93654: LD_INT 109
93656: PUSH
93657: LD_INT 110
93659: PUSH
93660: LD_INT 111
93662: PUSH
93663: LD_INT 112
93665: PUSH
93666: LD_INT 113
93668: PUSH
93669: LD_INT 114
93671: PUSH
93672: EMPTY
93673: LIST
93674: LIST
93675: LIST
93676: LIST
93677: LIST
93678: LIST
93679: LIST
93680: LIST
93681: LIST
93682: LIST
93683: LIST
93684: LIST
93685: LIST
93686: LIST
93687: PUSH
93688: EMPTY
93689: LIST
93690: LIST
93691: ST_TO_ADDR
93692: GO 95063
93694: LD_INT 13
93696: DOUBLE
93697: EQUAL
93698: IFTRUE 93702
93700: GO 93898
93702: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
93703: LD_ADDR_VAR 0 1
93707: PUSH
93708: LD_INT 1
93710: PUSH
93711: LD_INT 2
93713: PUSH
93714: LD_INT 3
93716: PUSH
93717: LD_INT 4
93719: PUSH
93720: LD_INT 5
93722: PUSH
93723: LD_INT 8
93725: PUSH
93726: LD_INT 9
93728: PUSH
93729: LD_INT 10
93731: PUSH
93732: LD_INT 11
93734: PUSH
93735: LD_INT 12
93737: PUSH
93738: LD_INT 14
93740: PUSH
93741: LD_INT 15
93743: PUSH
93744: LD_INT 16
93746: PUSH
93747: LD_INT 17
93749: PUSH
93750: LD_INT 18
93752: PUSH
93753: LD_INT 19
93755: PUSH
93756: LD_INT 20
93758: PUSH
93759: LD_INT 21
93761: PUSH
93762: LD_INT 22
93764: PUSH
93765: LD_INT 23
93767: PUSH
93768: LD_INT 24
93770: PUSH
93771: LD_INT 25
93773: PUSH
93774: LD_INT 26
93776: PUSH
93777: LD_INT 27
93779: PUSH
93780: LD_INT 28
93782: PUSH
93783: LD_INT 30
93785: PUSH
93786: LD_INT 31
93788: PUSH
93789: LD_INT 32
93791: PUSH
93792: LD_INT 33
93794: PUSH
93795: LD_INT 34
93797: PUSH
93798: LD_INT 36
93800: PUSH
93801: EMPTY
93802: LIST
93803: LIST
93804: LIST
93805: LIST
93806: LIST
93807: LIST
93808: LIST
93809: LIST
93810: LIST
93811: LIST
93812: LIST
93813: LIST
93814: LIST
93815: LIST
93816: LIST
93817: LIST
93818: LIST
93819: LIST
93820: LIST
93821: LIST
93822: LIST
93823: LIST
93824: LIST
93825: LIST
93826: LIST
93827: LIST
93828: LIST
93829: LIST
93830: LIST
93831: LIST
93832: LIST
93833: PUSH
93834: LD_INT 101
93836: PUSH
93837: LD_INT 102
93839: PUSH
93840: LD_INT 103
93842: PUSH
93843: LD_INT 104
93845: PUSH
93846: LD_INT 105
93848: PUSH
93849: LD_INT 106
93851: PUSH
93852: LD_INT 107
93854: PUSH
93855: LD_INT 108
93857: PUSH
93858: LD_INT 109
93860: PUSH
93861: LD_INT 110
93863: PUSH
93864: LD_INT 111
93866: PUSH
93867: LD_INT 112
93869: PUSH
93870: LD_INT 113
93872: PUSH
93873: LD_INT 114
93875: PUSH
93876: EMPTY
93877: LIST
93878: LIST
93879: LIST
93880: LIST
93881: LIST
93882: LIST
93883: LIST
93884: LIST
93885: LIST
93886: LIST
93887: LIST
93888: LIST
93889: LIST
93890: LIST
93891: PUSH
93892: EMPTY
93893: LIST
93894: LIST
93895: ST_TO_ADDR
93896: GO 95063
93898: LD_INT 14
93900: DOUBLE
93901: EQUAL
93902: IFTRUE 93906
93904: GO 94118
93906: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
93907: LD_ADDR_VAR 0 1
93911: PUSH
93912: LD_INT 1
93914: PUSH
93915: LD_INT 2
93917: PUSH
93918: LD_INT 3
93920: PUSH
93921: LD_INT 4
93923: PUSH
93924: LD_INT 5
93926: PUSH
93927: LD_INT 6
93929: PUSH
93930: LD_INT 7
93932: PUSH
93933: LD_INT 8
93935: PUSH
93936: LD_INT 9
93938: PUSH
93939: LD_INT 10
93941: PUSH
93942: LD_INT 11
93944: PUSH
93945: LD_INT 12
93947: PUSH
93948: LD_INT 13
93950: PUSH
93951: LD_INT 14
93953: PUSH
93954: LD_INT 15
93956: PUSH
93957: LD_INT 16
93959: PUSH
93960: LD_INT 17
93962: PUSH
93963: LD_INT 18
93965: PUSH
93966: LD_INT 19
93968: PUSH
93969: LD_INT 20
93971: PUSH
93972: LD_INT 21
93974: PUSH
93975: LD_INT 22
93977: PUSH
93978: LD_INT 23
93980: PUSH
93981: LD_INT 24
93983: PUSH
93984: LD_INT 25
93986: PUSH
93987: LD_INT 26
93989: PUSH
93990: LD_INT 27
93992: PUSH
93993: LD_INT 28
93995: PUSH
93996: LD_INT 29
93998: PUSH
93999: LD_INT 30
94001: PUSH
94002: LD_INT 31
94004: PUSH
94005: LD_INT 32
94007: PUSH
94008: LD_INT 33
94010: PUSH
94011: LD_INT 34
94013: PUSH
94014: LD_INT 36
94016: PUSH
94017: EMPTY
94018: LIST
94019: LIST
94020: LIST
94021: LIST
94022: LIST
94023: LIST
94024: LIST
94025: LIST
94026: LIST
94027: LIST
94028: LIST
94029: LIST
94030: LIST
94031: LIST
94032: LIST
94033: LIST
94034: LIST
94035: LIST
94036: LIST
94037: LIST
94038: LIST
94039: LIST
94040: LIST
94041: LIST
94042: LIST
94043: LIST
94044: LIST
94045: LIST
94046: LIST
94047: LIST
94048: LIST
94049: LIST
94050: LIST
94051: LIST
94052: LIST
94053: PUSH
94054: LD_INT 101
94056: PUSH
94057: LD_INT 102
94059: PUSH
94060: LD_INT 103
94062: PUSH
94063: LD_INT 104
94065: PUSH
94066: LD_INT 105
94068: PUSH
94069: LD_INT 106
94071: PUSH
94072: LD_INT 107
94074: PUSH
94075: LD_INT 108
94077: PUSH
94078: LD_INT 109
94080: PUSH
94081: LD_INT 110
94083: PUSH
94084: LD_INT 111
94086: PUSH
94087: LD_INT 112
94089: PUSH
94090: LD_INT 113
94092: PUSH
94093: LD_INT 114
94095: PUSH
94096: EMPTY
94097: LIST
94098: LIST
94099: LIST
94100: LIST
94101: LIST
94102: LIST
94103: LIST
94104: LIST
94105: LIST
94106: LIST
94107: LIST
94108: LIST
94109: LIST
94110: LIST
94111: PUSH
94112: EMPTY
94113: LIST
94114: LIST
94115: ST_TO_ADDR
94116: GO 95063
94118: LD_INT 15
94120: DOUBLE
94121: EQUAL
94122: IFTRUE 94126
94124: GO 94338
94126: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
94127: LD_ADDR_VAR 0 1
94131: PUSH
94132: LD_INT 1
94134: PUSH
94135: LD_INT 2
94137: PUSH
94138: LD_INT 3
94140: PUSH
94141: LD_INT 4
94143: PUSH
94144: LD_INT 5
94146: PUSH
94147: LD_INT 6
94149: PUSH
94150: LD_INT 7
94152: PUSH
94153: LD_INT 8
94155: PUSH
94156: LD_INT 9
94158: PUSH
94159: LD_INT 10
94161: PUSH
94162: LD_INT 11
94164: PUSH
94165: LD_INT 12
94167: PUSH
94168: LD_INT 13
94170: PUSH
94171: LD_INT 14
94173: PUSH
94174: LD_INT 15
94176: PUSH
94177: LD_INT 16
94179: PUSH
94180: LD_INT 17
94182: PUSH
94183: LD_INT 18
94185: PUSH
94186: LD_INT 19
94188: PUSH
94189: LD_INT 20
94191: PUSH
94192: LD_INT 21
94194: PUSH
94195: LD_INT 22
94197: PUSH
94198: LD_INT 23
94200: PUSH
94201: LD_INT 24
94203: PUSH
94204: LD_INT 25
94206: PUSH
94207: LD_INT 26
94209: PUSH
94210: LD_INT 27
94212: PUSH
94213: LD_INT 28
94215: PUSH
94216: LD_INT 29
94218: PUSH
94219: LD_INT 30
94221: PUSH
94222: LD_INT 31
94224: PUSH
94225: LD_INT 32
94227: PUSH
94228: LD_INT 33
94230: PUSH
94231: LD_INT 34
94233: PUSH
94234: LD_INT 36
94236: PUSH
94237: EMPTY
94238: LIST
94239: LIST
94240: LIST
94241: LIST
94242: LIST
94243: LIST
94244: LIST
94245: LIST
94246: LIST
94247: LIST
94248: LIST
94249: LIST
94250: LIST
94251: LIST
94252: LIST
94253: LIST
94254: LIST
94255: LIST
94256: LIST
94257: LIST
94258: LIST
94259: LIST
94260: LIST
94261: LIST
94262: LIST
94263: LIST
94264: LIST
94265: LIST
94266: LIST
94267: LIST
94268: LIST
94269: LIST
94270: LIST
94271: LIST
94272: LIST
94273: PUSH
94274: LD_INT 101
94276: PUSH
94277: LD_INT 102
94279: PUSH
94280: LD_INT 103
94282: PUSH
94283: LD_INT 104
94285: PUSH
94286: LD_INT 105
94288: PUSH
94289: LD_INT 106
94291: PUSH
94292: LD_INT 107
94294: PUSH
94295: LD_INT 108
94297: PUSH
94298: LD_INT 109
94300: PUSH
94301: LD_INT 110
94303: PUSH
94304: LD_INT 111
94306: PUSH
94307: LD_INT 112
94309: PUSH
94310: LD_INT 113
94312: PUSH
94313: LD_INT 114
94315: PUSH
94316: EMPTY
94317: LIST
94318: LIST
94319: LIST
94320: LIST
94321: LIST
94322: LIST
94323: LIST
94324: LIST
94325: LIST
94326: LIST
94327: LIST
94328: LIST
94329: LIST
94330: LIST
94331: PUSH
94332: EMPTY
94333: LIST
94334: LIST
94335: ST_TO_ADDR
94336: GO 95063
94338: LD_INT 16
94340: DOUBLE
94341: EQUAL
94342: IFTRUE 94346
94344: GO 94470
94346: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
94347: LD_ADDR_VAR 0 1
94351: PUSH
94352: LD_INT 2
94354: PUSH
94355: LD_INT 4
94357: PUSH
94358: LD_INT 5
94360: PUSH
94361: LD_INT 7
94363: PUSH
94364: LD_INT 11
94366: PUSH
94367: LD_INT 12
94369: PUSH
94370: LD_INT 15
94372: PUSH
94373: LD_INT 16
94375: PUSH
94376: LD_INT 20
94378: PUSH
94379: LD_INT 21
94381: PUSH
94382: LD_INT 22
94384: PUSH
94385: LD_INT 23
94387: PUSH
94388: LD_INT 25
94390: PUSH
94391: LD_INT 26
94393: PUSH
94394: LD_INT 30
94396: PUSH
94397: LD_INT 31
94399: PUSH
94400: LD_INT 32
94402: PUSH
94403: LD_INT 33
94405: PUSH
94406: LD_INT 34
94408: PUSH
94409: EMPTY
94410: LIST
94411: LIST
94412: LIST
94413: LIST
94414: LIST
94415: LIST
94416: LIST
94417: LIST
94418: LIST
94419: LIST
94420: LIST
94421: LIST
94422: LIST
94423: LIST
94424: LIST
94425: LIST
94426: LIST
94427: LIST
94428: LIST
94429: PUSH
94430: LD_INT 101
94432: PUSH
94433: LD_INT 102
94435: PUSH
94436: LD_INT 103
94438: PUSH
94439: LD_INT 106
94441: PUSH
94442: LD_INT 108
94444: PUSH
94445: LD_INT 112
94447: PUSH
94448: LD_INT 113
94450: PUSH
94451: LD_INT 114
94453: PUSH
94454: EMPTY
94455: LIST
94456: LIST
94457: LIST
94458: LIST
94459: LIST
94460: LIST
94461: LIST
94462: LIST
94463: PUSH
94464: EMPTY
94465: LIST
94466: LIST
94467: ST_TO_ADDR
94468: GO 95063
94470: LD_INT 17
94472: DOUBLE
94473: EQUAL
94474: IFTRUE 94478
94476: GO 94690
94478: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
94479: LD_ADDR_VAR 0 1
94483: PUSH
94484: LD_INT 1
94486: PUSH
94487: LD_INT 2
94489: PUSH
94490: LD_INT 3
94492: PUSH
94493: LD_INT 4
94495: PUSH
94496: LD_INT 5
94498: PUSH
94499: LD_INT 6
94501: PUSH
94502: LD_INT 7
94504: PUSH
94505: LD_INT 8
94507: PUSH
94508: LD_INT 9
94510: PUSH
94511: LD_INT 10
94513: PUSH
94514: LD_INT 11
94516: PUSH
94517: LD_INT 12
94519: PUSH
94520: LD_INT 13
94522: PUSH
94523: LD_INT 14
94525: PUSH
94526: LD_INT 15
94528: PUSH
94529: LD_INT 16
94531: PUSH
94532: LD_INT 17
94534: PUSH
94535: LD_INT 18
94537: PUSH
94538: LD_INT 19
94540: PUSH
94541: LD_INT 20
94543: PUSH
94544: LD_INT 21
94546: PUSH
94547: LD_INT 22
94549: PUSH
94550: LD_INT 23
94552: PUSH
94553: LD_INT 24
94555: PUSH
94556: LD_INT 25
94558: PUSH
94559: LD_INT 26
94561: PUSH
94562: LD_INT 27
94564: PUSH
94565: LD_INT 28
94567: PUSH
94568: LD_INT 29
94570: PUSH
94571: LD_INT 30
94573: PUSH
94574: LD_INT 31
94576: PUSH
94577: LD_INT 32
94579: PUSH
94580: LD_INT 33
94582: PUSH
94583: LD_INT 34
94585: PUSH
94586: LD_INT 36
94588: PUSH
94589: EMPTY
94590: LIST
94591: LIST
94592: LIST
94593: LIST
94594: LIST
94595: LIST
94596: LIST
94597: LIST
94598: LIST
94599: LIST
94600: LIST
94601: LIST
94602: LIST
94603: LIST
94604: LIST
94605: LIST
94606: LIST
94607: LIST
94608: LIST
94609: LIST
94610: LIST
94611: LIST
94612: LIST
94613: LIST
94614: LIST
94615: LIST
94616: LIST
94617: LIST
94618: LIST
94619: LIST
94620: LIST
94621: LIST
94622: LIST
94623: LIST
94624: LIST
94625: PUSH
94626: LD_INT 101
94628: PUSH
94629: LD_INT 102
94631: PUSH
94632: LD_INT 103
94634: PUSH
94635: LD_INT 104
94637: PUSH
94638: LD_INT 105
94640: PUSH
94641: LD_INT 106
94643: PUSH
94644: LD_INT 107
94646: PUSH
94647: LD_INT 108
94649: PUSH
94650: LD_INT 109
94652: PUSH
94653: LD_INT 110
94655: PUSH
94656: LD_INT 111
94658: PUSH
94659: LD_INT 112
94661: PUSH
94662: LD_INT 113
94664: PUSH
94665: LD_INT 114
94667: PUSH
94668: EMPTY
94669: LIST
94670: LIST
94671: LIST
94672: LIST
94673: LIST
94674: LIST
94675: LIST
94676: LIST
94677: LIST
94678: LIST
94679: LIST
94680: LIST
94681: LIST
94682: LIST
94683: PUSH
94684: EMPTY
94685: LIST
94686: LIST
94687: ST_TO_ADDR
94688: GO 95063
94690: LD_INT 18
94692: DOUBLE
94693: EQUAL
94694: IFTRUE 94698
94696: GO 94834
94698: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
94699: LD_ADDR_VAR 0 1
94703: PUSH
94704: LD_INT 2
94706: PUSH
94707: LD_INT 4
94709: PUSH
94710: LD_INT 5
94712: PUSH
94713: LD_INT 7
94715: PUSH
94716: LD_INT 11
94718: PUSH
94719: LD_INT 12
94721: PUSH
94722: LD_INT 15
94724: PUSH
94725: LD_INT 16
94727: PUSH
94728: LD_INT 20
94730: PUSH
94731: LD_INT 21
94733: PUSH
94734: LD_INT 22
94736: PUSH
94737: LD_INT 23
94739: PUSH
94740: LD_INT 25
94742: PUSH
94743: LD_INT 26
94745: PUSH
94746: LD_INT 30
94748: PUSH
94749: LD_INT 31
94751: PUSH
94752: LD_INT 32
94754: PUSH
94755: LD_INT 33
94757: PUSH
94758: LD_INT 34
94760: PUSH
94761: LD_INT 35
94763: PUSH
94764: LD_INT 36
94766: PUSH
94767: EMPTY
94768: LIST
94769: LIST
94770: LIST
94771: LIST
94772: LIST
94773: LIST
94774: LIST
94775: LIST
94776: LIST
94777: LIST
94778: LIST
94779: LIST
94780: LIST
94781: LIST
94782: LIST
94783: LIST
94784: LIST
94785: LIST
94786: LIST
94787: LIST
94788: LIST
94789: PUSH
94790: LD_INT 101
94792: PUSH
94793: LD_INT 102
94795: PUSH
94796: LD_INT 103
94798: PUSH
94799: LD_INT 106
94801: PUSH
94802: LD_INT 108
94804: PUSH
94805: LD_INT 112
94807: PUSH
94808: LD_INT 113
94810: PUSH
94811: LD_INT 114
94813: PUSH
94814: LD_INT 115
94816: PUSH
94817: EMPTY
94818: LIST
94819: LIST
94820: LIST
94821: LIST
94822: LIST
94823: LIST
94824: LIST
94825: LIST
94826: LIST
94827: PUSH
94828: EMPTY
94829: LIST
94830: LIST
94831: ST_TO_ADDR
94832: GO 95063
94834: LD_INT 19
94836: DOUBLE
94837: EQUAL
94838: IFTRUE 94842
94840: GO 95062
94842: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
94843: LD_ADDR_VAR 0 1
94847: PUSH
94848: LD_INT 1
94850: PUSH
94851: LD_INT 2
94853: PUSH
94854: LD_INT 3
94856: PUSH
94857: LD_INT 4
94859: PUSH
94860: LD_INT 5
94862: PUSH
94863: LD_INT 6
94865: PUSH
94866: LD_INT 7
94868: PUSH
94869: LD_INT 8
94871: PUSH
94872: LD_INT 9
94874: PUSH
94875: LD_INT 10
94877: PUSH
94878: LD_INT 11
94880: PUSH
94881: LD_INT 12
94883: PUSH
94884: LD_INT 13
94886: PUSH
94887: LD_INT 14
94889: PUSH
94890: LD_INT 15
94892: PUSH
94893: LD_INT 16
94895: PUSH
94896: LD_INT 17
94898: PUSH
94899: LD_INT 18
94901: PUSH
94902: LD_INT 19
94904: PUSH
94905: LD_INT 20
94907: PUSH
94908: LD_INT 21
94910: PUSH
94911: LD_INT 22
94913: PUSH
94914: LD_INT 23
94916: PUSH
94917: LD_INT 24
94919: PUSH
94920: LD_INT 25
94922: PUSH
94923: LD_INT 26
94925: PUSH
94926: LD_INT 27
94928: PUSH
94929: LD_INT 28
94931: PUSH
94932: LD_INT 29
94934: PUSH
94935: LD_INT 30
94937: PUSH
94938: LD_INT 31
94940: PUSH
94941: LD_INT 32
94943: PUSH
94944: LD_INT 33
94946: PUSH
94947: LD_INT 34
94949: PUSH
94950: LD_INT 35
94952: PUSH
94953: LD_INT 36
94955: PUSH
94956: EMPTY
94957: LIST
94958: LIST
94959: LIST
94960: LIST
94961: LIST
94962: LIST
94963: LIST
94964: LIST
94965: LIST
94966: LIST
94967: LIST
94968: LIST
94969: LIST
94970: LIST
94971: LIST
94972: LIST
94973: LIST
94974: LIST
94975: LIST
94976: LIST
94977: LIST
94978: LIST
94979: LIST
94980: LIST
94981: LIST
94982: LIST
94983: LIST
94984: LIST
94985: LIST
94986: LIST
94987: LIST
94988: LIST
94989: LIST
94990: LIST
94991: LIST
94992: LIST
94993: PUSH
94994: LD_INT 101
94996: PUSH
94997: LD_INT 102
94999: PUSH
95000: LD_INT 103
95002: PUSH
95003: LD_INT 104
95005: PUSH
95006: LD_INT 105
95008: PUSH
95009: LD_INT 106
95011: PUSH
95012: LD_INT 107
95014: PUSH
95015: LD_INT 108
95017: PUSH
95018: LD_INT 109
95020: PUSH
95021: LD_INT 110
95023: PUSH
95024: LD_INT 111
95026: PUSH
95027: LD_INT 112
95029: PUSH
95030: LD_INT 113
95032: PUSH
95033: LD_INT 114
95035: PUSH
95036: LD_INT 115
95038: PUSH
95039: EMPTY
95040: LIST
95041: LIST
95042: LIST
95043: LIST
95044: LIST
95045: LIST
95046: LIST
95047: LIST
95048: LIST
95049: LIST
95050: LIST
95051: LIST
95052: LIST
95053: LIST
95054: LIST
95055: PUSH
95056: EMPTY
95057: LIST
95058: LIST
95059: ST_TO_ADDR
95060: GO 95063
95062: POP
// end else
95063: GO 95282
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
95065: LD_ADDR_VAR 0 1
95069: PUSH
95070: LD_INT 1
95072: PUSH
95073: LD_INT 2
95075: PUSH
95076: LD_INT 3
95078: PUSH
95079: LD_INT 4
95081: PUSH
95082: LD_INT 5
95084: PUSH
95085: LD_INT 6
95087: PUSH
95088: LD_INT 7
95090: PUSH
95091: LD_INT 8
95093: PUSH
95094: LD_INT 9
95096: PUSH
95097: LD_INT 10
95099: PUSH
95100: LD_INT 11
95102: PUSH
95103: LD_INT 12
95105: PUSH
95106: LD_INT 13
95108: PUSH
95109: LD_INT 14
95111: PUSH
95112: LD_INT 15
95114: PUSH
95115: LD_INT 16
95117: PUSH
95118: LD_INT 17
95120: PUSH
95121: LD_INT 18
95123: PUSH
95124: LD_INT 19
95126: PUSH
95127: LD_INT 20
95129: PUSH
95130: LD_INT 21
95132: PUSH
95133: LD_INT 22
95135: PUSH
95136: LD_INT 23
95138: PUSH
95139: LD_INT 24
95141: PUSH
95142: LD_INT 25
95144: PUSH
95145: LD_INT 26
95147: PUSH
95148: LD_INT 27
95150: PUSH
95151: LD_INT 28
95153: PUSH
95154: LD_INT 29
95156: PUSH
95157: LD_INT 30
95159: PUSH
95160: LD_INT 31
95162: PUSH
95163: LD_INT 32
95165: PUSH
95166: LD_INT 33
95168: PUSH
95169: LD_INT 34
95171: PUSH
95172: LD_INT 35
95174: PUSH
95175: LD_INT 36
95177: PUSH
95178: EMPTY
95179: LIST
95180: LIST
95181: LIST
95182: LIST
95183: LIST
95184: LIST
95185: LIST
95186: LIST
95187: LIST
95188: LIST
95189: LIST
95190: LIST
95191: LIST
95192: LIST
95193: LIST
95194: LIST
95195: LIST
95196: LIST
95197: LIST
95198: LIST
95199: LIST
95200: LIST
95201: LIST
95202: LIST
95203: LIST
95204: LIST
95205: LIST
95206: LIST
95207: LIST
95208: LIST
95209: LIST
95210: LIST
95211: LIST
95212: LIST
95213: LIST
95214: LIST
95215: PUSH
95216: LD_INT 101
95218: PUSH
95219: LD_INT 102
95221: PUSH
95222: LD_INT 103
95224: PUSH
95225: LD_INT 104
95227: PUSH
95228: LD_INT 105
95230: PUSH
95231: LD_INT 106
95233: PUSH
95234: LD_INT 107
95236: PUSH
95237: LD_INT 108
95239: PUSH
95240: LD_INT 109
95242: PUSH
95243: LD_INT 110
95245: PUSH
95246: LD_INT 111
95248: PUSH
95249: LD_INT 112
95251: PUSH
95252: LD_INT 113
95254: PUSH
95255: LD_INT 114
95257: PUSH
95258: LD_INT 115
95260: PUSH
95261: EMPTY
95262: LIST
95263: LIST
95264: LIST
95265: LIST
95266: LIST
95267: LIST
95268: LIST
95269: LIST
95270: LIST
95271: LIST
95272: LIST
95273: LIST
95274: LIST
95275: LIST
95276: LIST
95277: PUSH
95278: EMPTY
95279: LIST
95280: LIST
95281: ST_TO_ADDR
// if result then
95282: LD_VAR 0 1
95286: IFFALSE 95575
// begin normal :=  ;
95288: LD_ADDR_VAR 0 3
95292: PUSH
95293: LD_STRING 
95295: ST_TO_ADDR
// hardcore :=  ;
95296: LD_ADDR_VAR 0 4
95300: PUSH
95301: LD_STRING 
95303: ST_TO_ADDR
// for i = 1 to normalCounter do
95304: LD_ADDR_VAR 0 5
95308: PUSH
95309: DOUBLE
95310: LD_INT 1
95312: DEC
95313: ST_TO_ADDR
95314: LD_EXP 99
95318: PUSH
95319: FOR_TO
95320: IFFALSE 95421
// begin tmp := 0 ;
95322: LD_ADDR_VAR 0 2
95326: PUSH
95327: LD_STRING 0
95329: ST_TO_ADDR
// if result [ 1 ] then
95330: LD_VAR 0 1
95334: PUSH
95335: LD_INT 1
95337: ARRAY
95338: IFFALSE 95403
// if result [ 1 ] [ 1 ] = i then
95340: LD_VAR 0 1
95344: PUSH
95345: LD_INT 1
95347: ARRAY
95348: PUSH
95349: LD_INT 1
95351: ARRAY
95352: PUSH
95353: LD_VAR 0 5
95357: EQUAL
95358: IFFALSE 95403
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
95360: LD_ADDR_VAR 0 1
95364: PUSH
95365: LD_VAR 0 1
95369: PPUSH
95370: LD_INT 1
95372: PPUSH
95373: LD_VAR 0 1
95377: PUSH
95378: LD_INT 1
95380: ARRAY
95381: PPUSH
95382: LD_INT 1
95384: PPUSH
95385: CALL_OW 3
95389: PPUSH
95390: CALL_OW 1
95394: ST_TO_ADDR
// tmp := 1 ;
95395: LD_ADDR_VAR 0 2
95399: PUSH
95400: LD_STRING 1
95402: ST_TO_ADDR
// end ; normal := normal & tmp ;
95403: LD_ADDR_VAR 0 3
95407: PUSH
95408: LD_VAR 0 3
95412: PUSH
95413: LD_VAR 0 2
95417: STR
95418: ST_TO_ADDR
// end ;
95419: GO 95319
95421: POP
95422: POP
// for i = 1 to hardcoreCounter do
95423: LD_ADDR_VAR 0 5
95427: PUSH
95428: DOUBLE
95429: LD_INT 1
95431: DEC
95432: ST_TO_ADDR
95433: LD_EXP 100
95437: PUSH
95438: FOR_TO
95439: IFFALSE 95544
// begin tmp := 0 ;
95441: LD_ADDR_VAR 0 2
95445: PUSH
95446: LD_STRING 0
95448: ST_TO_ADDR
// if result [ 2 ] then
95449: LD_VAR 0 1
95453: PUSH
95454: LD_INT 2
95456: ARRAY
95457: IFFALSE 95526
// if result [ 2 ] [ 1 ] = 100 + i then
95459: LD_VAR 0 1
95463: PUSH
95464: LD_INT 2
95466: ARRAY
95467: PUSH
95468: LD_INT 1
95470: ARRAY
95471: PUSH
95472: LD_INT 100
95474: PUSH
95475: LD_VAR 0 5
95479: PLUS
95480: EQUAL
95481: IFFALSE 95526
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
95483: LD_ADDR_VAR 0 1
95487: PUSH
95488: LD_VAR 0 1
95492: PPUSH
95493: LD_INT 2
95495: PPUSH
95496: LD_VAR 0 1
95500: PUSH
95501: LD_INT 2
95503: ARRAY
95504: PPUSH
95505: LD_INT 1
95507: PPUSH
95508: CALL_OW 3
95512: PPUSH
95513: CALL_OW 1
95517: ST_TO_ADDR
// tmp := 1 ;
95518: LD_ADDR_VAR 0 2
95522: PUSH
95523: LD_STRING 1
95525: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
95526: LD_ADDR_VAR 0 4
95530: PUSH
95531: LD_VAR 0 4
95535: PUSH
95536: LD_VAR 0 2
95540: STR
95541: ST_TO_ADDR
// end ;
95542: GO 95438
95544: POP
95545: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
95546: LD_STRING getStreamItemsFromMission("
95548: PUSH
95549: LD_VAR 0 3
95553: STR
95554: PUSH
95555: LD_STRING ","
95557: STR
95558: PUSH
95559: LD_VAR 0 4
95563: STR
95564: PUSH
95565: LD_STRING ")
95567: STR
95568: PPUSH
95569: CALL_OW 559
// end else
95573: GO 95582
// ToLua ( getStreamItemsFromMission("","") ) ;
95575: LD_STRING getStreamItemsFromMission("","")
95577: PPUSH
95578: CALL_OW 559
// end ;
95582: LD_VAR 0 1
95586: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
95587: LD_EXP 98
95591: PUSH
95592: LD_EXP 103
95596: AND
95597: IFFALSE 95721
95599: GO 95601
95601: DISABLE
95602: LD_INT 0
95604: PPUSH
95605: PPUSH
// begin enable ;
95606: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
95607: LD_ADDR_VAR 0 2
95611: PUSH
95612: LD_INT 22
95614: PUSH
95615: LD_OWVAR 2
95619: PUSH
95620: EMPTY
95621: LIST
95622: LIST
95623: PUSH
95624: LD_INT 2
95626: PUSH
95627: LD_INT 34
95629: PUSH
95630: LD_INT 7
95632: PUSH
95633: EMPTY
95634: LIST
95635: LIST
95636: PUSH
95637: LD_INT 34
95639: PUSH
95640: LD_INT 45
95642: PUSH
95643: EMPTY
95644: LIST
95645: LIST
95646: PUSH
95647: LD_INT 34
95649: PUSH
95650: LD_INT 28
95652: PUSH
95653: EMPTY
95654: LIST
95655: LIST
95656: PUSH
95657: LD_INT 34
95659: PUSH
95660: LD_INT 47
95662: PUSH
95663: EMPTY
95664: LIST
95665: LIST
95666: PUSH
95667: EMPTY
95668: LIST
95669: LIST
95670: LIST
95671: LIST
95672: LIST
95673: PUSH
95674: EMPTY
95675: LIST
95676: LIST
95677: PPUSH
95678: CALL_OW 69
95682: ST_TO_ADDR
// if not tmp then
95683: LD_VAR 0 2
95687: NOT
95688: IFFALSE 95692
// exit ;
95690: GO 95721
// for i in tmp do
95692: LD_ADDR_VAR 0 1
95696: PUSH
95697: LD_VAR 0 2
95701: PUSH
95702: FOR_IN
95703: IFFALSE 95719
// begin SetLives ( i , 0 ) ;
95705: LD_VAR 0 1
95709: PPUSH
95710: LD_INT 0
95712: PPUSH
95713: CALL_OW 234
// end ;
95717: GO 95702
95719: POP
95720: POP
// end ;
95721: PPOPN 2
95723: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
95724: LD_EXP 98
95728: PUSH
95729: LD_EXP 104
95733: AND
95734: IFFALSE 95818
95736: GO 95738
95738: DISABLE
95739: LD_INT 0
95741: PPUSH
95742: PPUSH
// begin enable ;
95743: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
95744: LD_ADDR_VAR 0 2
95748: PUSH
95749: LD_INT 22
95751: PUSH
95752: LD_OWVAR 2
95756: PUSH
95757: EMPTY
95758: LIST
95759: LIST
95760: PUSH
95761: LD_INT 32
95763: PUSH
95764: LD_INT 3
95766: PUSH
95767: EMPTY
95768: LIST
95769: LIST
95770: PUSH
95771: EMPTY
95772: LIST
95773: LIST
95774: PPUSH
95775: CALL_OW 69
95779: ST_TO_ADDR
// if not tmp then
95780: LD_VAR 0 2
95784: NOT
95785: IFFALSE 95789
// exit ;
95787: GO 95818
// for i in tmp do
95789: LD_ADDR_VAR 0 1
95793: PUSH
95794: LD_VAR 0 2
95798: PUSH
95799: FOR_IN
95800: IFFALSE 95816
// begin SetLives ( i , 0 ) ;
95802: LD_VAR 0 1
95806: PPUSH
95807: LD_INT 0
95809: PPUSH
95810: CALL_OW 234
// end ;
95814: GO 95799
95816: POP
95817: POP
// end ;
95818: PPOPN 2
95820: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
95821: LD_EXP 98
95825: PUSH
95826: LD_EXP 101
95830: AND
95831: IFFALSE 95924
95833: GO 95835
95835: DISABLE
95836: LD_INT 0
95838: PPUSH
// begin enable ;
95839: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
95840: LD_ADDR_VAR 0 1
95844: PUSH
95845: LD_INT 22
95847: PUSH
95848: LD_OWVAR 2
95852: PUSH
95853: EMPTY
95854: LIST
95855: LIST
95856: PUSH
95857: LD_INT 2
95859: PUSH
95860: LD_INT 25
95862: PUSH
95863: LD_INT 5
95865: PUSH
95866: EMPTY
95867: LIST
95868: LIST
95869: PUSH
95870: LD_INT 25
95872: PUSH
95873: LD_INT 9
95875: PUSH
95876: EMPTY
95877: LIST
95878: LIST
95879: PUSH
95880: LD_INT 25
95882: PUSH
95883: LD_INT 8
95885: PUSH
95886: EMPTY
95887: LIST
95888: LIST
95889: PUSH
95890: EMPTY
95891: LIST
95892: LIST
95893: LIST
95894: LIST
95895: PUSH
95896: EMPTY
95897: LIST
95898: LIST
95899: PPUSH
95900: CALL_OW 69
95904: PUSH
95905: FOR_IN
95906: IFFALSE 95922
// begin SetClass ( i , 1 ) ;
95908: LD_VAR 0 1
95912: PPUSH
95913: LD_INT 1
95915: PPUSH
95916: CALL_OW 336
// end ;
95920: GO 95905
95922: POP
95923: POP
// end ;
95924: PPOPN 1
95926: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
95927: LD_EXP 98
95931: PUSH
95932: LD_EXP 102
95936: AND
95937: PUSH
95938: LD_OWVAR 65
95942: PUSH
95943: LD_INT 7
95945: LESS
95946: AND
95947: IFFALSE 95961
95949: GO 95951
95951: DISABLE
// begin enable ;
95952: ENABLE
// game_speed := 7 ;
95953: LD_ADDR_OWVAR 65
95957: PUSH
95958: LD_INT 7
95960: ST_TO_ADDR
// end ;
95961: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
95962: LD_EXP 98
95966: PUSH
95967: LD_EXP 105
95971: AND
95972: IFFALSE 96174
95974: GO 95976
95976: DISABLE
95977: LD_INT 0
95979: PPUSH
95980: PPUSH
95981: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
95982: LD_ADDR_VAR 0 3
95986: PUSH
95987: LD_INT 81
95989: PUSH
95990: LD_OWVAR 2
95994: PUSH
95995: EMPTY
95996: LIST
95997: LIST
95998: PUSH
95999: LD_INT 21
96001: PUSH
96002: LD_INT 1
96004: PUSH
96005: EMPTY
96006: LIST
96007: LIST
96008: PUSH
96009: EMPTY
96010: LIST
96011: LIST
96012: PPUSH
96013: CALL_OW 69
96017: ST_TO_ADDR
// if not tmp then
96018: LD_VAR 0 3
96022: NOT
96023: IFFALSE 96027
// exit ;
96025: GO 96174
// if tmp > 5 then
96027: LD_VAR 0 3
96031: PUSH
96032: LD_INT 5
96034: GREATER
96035: IFFALSE 96047
// k := 5 else
96037: LD_ADDR_VAR 0 2
96041: PUSH
96042: LD_INT 5
96044: ST_TO_ADDR
96045: GO 96057
// k := tmp ;
96047: LD_ADDR_VAR 0 2
96051: PUSH
96052: LD_VAR 0 3
96056: ST_TO_ADDR
// for i := 1 to k do
96057: LD_ADDR_VAR 0 1
96061: PUSH
96062: DOUBLE
96063: LD_INT 1
96065: DEC
96066: ST_TO_ADDR
96067: LD_VAR 0 2
96071: PUSH
96072: FOR_TO
96073: IFFALSE 96172
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
96075: LD_VAR 0 3
96079: PUSH
96080: LD_VAR 0 1
96084: ARRAY
96085: PPUSH
96086: LD_VAR 0 1
96090: PUSH
96091: LD_INT 4
96093: MOD
96094: PUSH
96095: LD_INT 1
96097: PLUS
96098: PPUSH
96099: CALL_OW 259
96103: PUSH
96104: LD_INT 10
96106: LESS
96107: IFFALSE 96170
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
96109: LD_VAR 0 3
96113: PUSH
96114: LD_VAR 0 1
96118: ARRAY
96119: PPUSH
96120: LD_VAR 0 1
96124: PUSH
96125: LD_INT 4
96127: MOD
96128: PUSH
96129: LD_INT 1
96131: PLUS
96132: PPUSH
96133: LD_VAR 0 3
96137: PUSH
96138: LD_VAR 0 1
96142: ARRAY
96143: PPUSH
96144: LD_VAR 0 1
96148: PUSH
96149: LD_INT 4
96151: MOD
96152: PUSH
96153: LD_INT 1
96155: PLUS
96156: PPUSH
96157: CALL_OW 259
96161: PUSH
96162: LD_INT 1
96164: PLUS
96165: PPUSH
96166: CALL_OW 237
96170: GO 96072
96172: POP
96173: POP
// end ;
96174: PPOPN 3
96176: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
96177: LD_EXP 98
96181: PUSH
96182: LD_EXP 106
96186: AND
96187: IFFALSE 96207
96189: GO 96191
96191: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
96192: LD_INT 4
96194: PPUSH
96195: LD_OWVAR 2
96199: PPUSH
96200: LD_INT 0
96202: PPUSH
96203: CALL_OW 324
96207: END
// every 0 0$1 trigger StreamModeActive and sShovel do
96208: LD_EXP 98
96212: PUSH
96213: LD_EXP 135
96217: AND
96218: IFFALSE 96238
96220: GO 96222
96222: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
96223: LD_INT 19
96225: PPUSH
96226: LD_OWVAR 2
96230: PPUSH
96231: LD_INT 0
96233: PPUSH
96234: CALL_OW 324
96238: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
96239: LD_EXP 98
96243: PUSH
96244: LD_EXP 107
96248: AND
96249: IFFALSE 96351
96251: GO 96253
96253: DISABLE
96254: LD_INT 0
96256: PPUSH
96257: PPUSH
// begin enable ;
96258: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
96259: LD_ADDR_VAR 0 2
96263: PUSH
96264: LD_INT 22
96266: PUSH
96267: LD_OWVAR 2
96271: PUSH
96272: EMPTY
96273: LIST
96274: LIST
96275: PUSH
96276: LD_INT 2
96278: PUSH
96279: LD_INT 34
96281: PUSH
96282: LD_INT 11
96284: PUSH
96285: EMPTY
96286: LIST
96287: LIST
96288: PUSH
96289: LD_INT 34
96291: PUSH
96292: LD_INT 30
96294: PUSH
96295: EMPTY
96296: LIST
96297: LIST
96298: PUSH
96299: EMPTY
96300: LIST
96301: LIST
96302: LIST
96303: PUSH
96304: EMPTY
96305: LIST
96306: LIST
96307: PPUSH
96308: CALL_OW 69
96312: ST_TO_ADDR
// if not tmp then
96313: LD_VAR 0 2
96317: NOT
96318: IFFALSE 96322
// exit ;
96320: GO 96351
// for i in tmp do
96322: LD_ADDR_VAR 0 1
96326: PUSH
96327: LD_VAR 0 2
96331: PUSH
96332: FOR_IN
96333: IFFALSE 96349
// begin SetLives ( i , 0 ) ;
96335: LD_VAR 0 1
96339: PPUSH
96340: LD_INT 0
96342: PPUSH
96343: CALL_OW 234
// end ;
96347: GO 96332
96349: POP
96350: POP
// end ;
96351: PPOPN 2
96353: END
// every 0 0$1 trigger StreamModeActive and sBunker do
96354: LD_EXP 98
96358: PUSH
96359: LD_EXP 108
96363: AND
96364: IFFALSE 96384
96366: GO 96368
96368: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
96369: LD_INT 32
96371: PPUSH
96372: LD_OWVAR 2
96376: PPUSH
96377: LD_INT 0
96379: PPUSH
96380: CALL_OW 324
96384: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
96385: LD_EXP 98
96389: PUSH
96390: LD_EXP 109
96394: AND
96395: IFFALSE 96576
96397: GO 96399
96399: DISABLE
96400: LD_INT 0
96402: PPUSH
96403: PPUSH
96404: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
96405: LD_ADDR_VAR 0 2
96409: PUSH
96410: LD_INT 22
96412: PUSH
96413: LD_OWVAR 2
96417: PUSH
96418: EMPTY
96419: LIST
96420: LIST
96421: PUSH
96422: LD_INT 33
96424: PUSH
96425: LD_INT 3
96427: PUSH
96428: EMPTY
96429: LIST
96430: LIST
96431: PUSH
96432: EMPTY
96433: LIST
96434: LIST
96435: PPUSH
96436: CALL_OW 69
96440: ST_TO_ADDR
// if not tmp then
96441: LD_VAR 0 2
96445: NOT
96446: IFFALSE 96450
// exit ;
96448: GO 96576
// side := 0 ;
96450: LD_ADDR_VAR 0 3
96454: PUSH
96455: LD_INT 0
96457: ST_TO_ADDR
// for i := 1 to 8 do
96458: LD_ADDR_VAR 0 1
96462: PUSH
96463: DOUBLE
96464: LD_INT 1
96466: DEC
96467: ST_TO_ADDR
96468: LD_INT 8
96470: PUSH
96471: FOR_TO
96472: IFFALSE 96520
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
96474: LD_OWVAR 2
96478: PUSH
96479: LD_VAR 0 1
96483: NONEQUAL
96484: PUSH
96485: LD_OWVAR 2
96489: PPUSH
96490: LD_VAR 0 1
96494: PPUSH
96495: CALL_OW 81
96499: PUSH
96500: LD_INT 2
96502: EQUAL
96503: AND
96504: IFFALSE 96518
// begin side := i ;
96506: LD_ADDR_VAR 0 3
96510: PUSH
96511: LD_VAR 0 1
96515: ST_TO_ADDR
// break ;
96516: GO 96520
// end ;
96518: GO 96471
96520: POP
96521: POP
// if not side then
96522: LD_VAR 0 3
96526: NOT
96527: IFFALSE 96531
// exit ;
96529: GO 96576
// for i := 1 to tmp do
96531: LD_ADDR_VAR 0 1
96535: PUSH
96536: DOUBLE
96537: LD_INT 1
96539: DEC
96540: ST_TO_ADDR
96541: LD_VAR 0 2
96545: PUSH
96546: FOR_TO
96547: IFFALSE 96574
// if Prob ( 60 ) then
96549: LD_INT 60
96551: PPUSH
96552: CALL_OW 13
96556: IFFALSE 96572
// SetSide ( i , side ) ;
96558: LD_VAR 0 1
96562: PPUSH
96563: LD_VAR 0 3
96567: PPUSH
96568: CALL_OW 235
96572: GO 96546
96574: POP
96575: POP
// end ;
96576: PPOPN 3
96578: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
96579: LD_EXP 98
96583: PUSH
96584: LD_EXP 111
96588: AND
96589: IFFALSE 96708
96591: GO 96593
96593: DISABLE
96594: LD_INT 0
96596: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
96597: LD_ADDR_VAR 0 1
96601: PUSH
96602: LD_INT 22
96604: PUSH
96605: LD_OWVAR 2
96609: PUSH
96610: EMPTY
96611: LIST
96612: LIST
96613: PUSH
96614: LD_INT 21
96616: PUSH
96617: LD_INT 1
96619: PUSH
96620: EMPTY
96621: LIST
96622: LIST
96623: PUSH
96624: LD_INT 3
96626: PUSH
96627: LD_INT 23
96629: PUSH
96630: LD_INT 0
96632: PUSH
96633: EMPTY
96634: LIST
96635: LIST
96636: PUSH
96637: EMPTY
96638: LIST
96639: LIST
96640: PUSH
96641: EMPTY
96642: LIST
96643: LIST
96644: LIST
96645: PPUSH
96646: CALL_OW 69
96650: PUSH
96651: FOR_IN
96652: IFFALSE 96706
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
96654: LD_VAR 0 1
96658: PPUSH
96659: CALL_OW 257
96663: PUSH
96664: LD_INT 1
96666: PUSH
96667: LD_INT 2
96669: PUSH
96670: LD_INT 3
96672: PUSH
96673: LD_INT 4
96675: PUSH
96676: EMPTY
96677: LIST
96678: LIST
96679: LIST
96680: LIST
96681: IN
96682: IFFALSE 96704
// SetClass ( un , rand ( 1 , 4 ) ) ;
96684: LD_VAR 0 1
96688: PPUSH
96689: LD_INT 1
96691: PPUSH
96692: LD_INT 4
96694: PPUSH
96695: CALL_OW 12
96699: PPUSH
96700: CALL_OW 336
96704: GO 96651
96706: POP
96707: POP
// end ;
96708: PPOPN 1
96710: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
96711: LD_EXP 98
96715: PUSH
96716: LD_EXP 110
96720: AND
96721: IFFALSE 96800
96723: GO 96725
96725: DISABLE
96726: LD_INT 0
96728: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
96729: LD_ADDR_VAR 0 1
96733: PUSH
96734: LD_INT 22
96736: PUSH
96737: LD_OWVAR 2
96741: PUSH
96742: EMPTY
96743: LIST
96744: LIST
96745: PUSH
96746: LD_INT 21
96748: PUSH
96749: LD_INT 3
96751: PUSH
96752: EMPTY
96753: LIST
96754: LIST
96755: PUSH
96756: EMPTY
96757: LIST
96758: LIST
96759: PPUSH
96760: CALL_OW 69
96764: ST_TO_ADDR
// if not tmp then
96765: LD_VAR 0 1
96769: NOT
96770: IFFALSE 96774
// exit ;
96772: GO 96800
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
96774: LD_VAR 0 1
96778: PUSH
96779: LD_INT 1
96781: PPUSH
96782: LD_VAR 0 1
96786: PPUSH
96787: CALL_OW 12
96791: ARRAY
96792: PPUSH
96793: LD_INT 100
96795: PPUSH
96796: CALL_OW 234
// end ;
96800: PPOPN 1
96802: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
96803: LD_EXP 98
96807: PUSH
96808: LD_EXP 112
96812: AND
96813: IFFALSE 96911
96815: GO 96817
96817: DISABLE
96818: LD_INT 0
96820: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
96821: LD_ADDR_VAR 0 1
96825: PUSH
96826: LD_INT 22
96828: PUSH
96829: LD_OWVAR 2
96833: PUSH
96834: EMPTY
96835: LIST
96836: LIST
96837: PUSH
96838: LD_INT 21
96840: PUSH
96841: LD_INT 1
96843: PUSH
96844: EMPTY
96845: LIST
96846: LIST
96847: PUSH
96848: EMPTY
96849: LIST
96850: LIST
96851: PPUSH
96852: CALL_OW 69
96856: ST_TO_ADDR
// if not tmp then
96857: LD_VAR 0 1
96861: NOT
96862: IFFALSE 96866
// exit ;
96864: GO 96911
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
96866: LD_VAR 0 1
96870: PUSH
96871: LD_INT 1
96873: PPUSH
96874: LD_VAR 0 1
96878: PPUSH
96879: CALL_OW 12
96883: ARRAY
96884: PPUSH
96885: LD_INT 1
96887: PPUSH
96888: LD_INT 4
96890: PPUSH
96891: CALL_OW 12
96895: PPUSH
96896: LD_INT 3000
96898: PPUSH
96899: LD_INT 9000
96901: PPUSH
96902: CALL_OW 12
96906: PPUSH
96907: CALL_OW 492
// end ;
96911: PPOPN 1
96913: END
// every 0 0$1 trigger StreamModeActive and sDepot do
96914: LD_EXP 98
96918: PUSH
96919: LD_EXP 113
96923: AND
96924: IFFALSE 96944
96926: GO 96928
96928: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
96929: LD_INT 1
96931: PPUSH
96932: LD_OWVAR 2
96936: PPUSH
96937: LD_INT 0
96939: PPUSH
96940: CALL_OW 324
96944: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
96945: LD_EXP 98
96949: PUSH
96950: LD_EXP 114
96954: AND
96955: IFFALSE 97038
96957: GO 96959
96959: DISABLE
96960: LD_INT 0
96962: PPUSH
96963: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
96964: LD_ADDR_VAR 0 2
96968: PUSH
96969: LD_INT 22
96971: PUSH
96972: LD_OWVAR 2
96976: PUSH
96977: EMPTY
96978: LIST
96979: LIST
96980: PUSH
96981: LD_INT 21
96983: PUSH
96984: LD_INT 3
96986: PUSH
96987: EMPTY
96988: LIST
96989: LIST
96990: PUSH
96991: EMPTY
96992: LIST
96993: LIST
96994: PPUSH
96995: CALL_OW 69
96999: ST_TO_ADDR
// if not tmp then
97000: LD_VAR 0 2
97004: NOT
97005: IFFALSE 97009
// exit ;
97007: GO 97038
// for i in tmp do
97009: LD_ADDR_VAR 0 1
97013: PUSH
97014: LD_VAR 0 2
97018: PUSH
97019: FOR_IN
97020: IFFALSE 97036
// SetBLevel ( i , 10 ) ;
97022: LD_VAR 0 1
97026: PPUSH
97027: LD_INT 10
97029: PPUSH
97030: CALL_OW 241
97034: GO 97019
97036: POP
97037: POP
// end ;
97038: PPOPN 2
97040: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
97041: LD_EXP 98
97045: PUSH
97046: LD_EXP 115
97050: AND
97051: IFFALSE 97162
97053: GO 97055
97055: DISABLE
97056: LD_INT 0
97058: PPUSH
97059: PPUSH
97060: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97061: LD_ADDR_VAR 0 3
97065: PUSH
97066: LD_INT 22
97068: PUSH
97069: LD_OWVAR 2
97073: PUSH
97074: EMPTY
97075: LIST
97076: LIST
97077: PUSH
97078: LD_INT 25
97080: PUSH
97081: LD_INT 1
97083: PUSH
97084: EMPTY
97085: LIST
97086: LIST
97087: PUSH
97088: EMPTY
97089: LIST
97090: LIST
97091: PPUSH
97092: CALL_OW 69
97096: ST_TO_ADDR
// if not tmp then
97097: LD_VAR 0 3
97101: NOT
97102: IFFALSE 97106
// exit ;
97104: GO 97162
// un := tmp [ rand ( 1 , tmp ) ] ;
97106: LD_ADDR_VAR 0 2
97110: PUSH
97111: LD_VAR 0 3
97115: PUSH
97116: LD_INT 1
97118: PPUSH
97119: LD_VAR 0 3
97123: PPUSH
97124: CALL_OW 12
97128: ARRAY
97129: ST_TO_ADDR
// if Crawls ( un ) then
97130: LD_VAR 0 2
97134: PPUSH
97135: CALL_OW 318
97139: IFFALSE 97150
// ComWalk ( un ) ;
97141: LD_VAR 0 2
97145: PPUSH
97146: CALL_OW 138
// SetClass ( un , class_sniper ) ;
97150: LD_VAR 0 2
97154: PPUSH
97155: LD_INT 5
97157: PPUSH
97158: CALL_OW 336
// end ;
97162: PPOPN 3
97164: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
97165: LD_EXP 98
97169: PUSH
97170: LD_EXP 116
97174: AND
97175: PUSH
97176: LD_OWVAR 67
97180: PUSH
97181: LD_INT 3
97183: LESS
97184: AND
97185: IFFALSE 97204
97187: GO 97189
97189: DISABLE
// Difficulty := Difficulty + 1 ;
97190: LD_ADDR_OWVAR 67
97194: PUSH
97195: LD_OWVAR 67
97199: PUSH
97200: LD_INT 1
97202: PLUS
97203: ST_TO_ADDR
97204: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
97205: LD_EXP 98
97209: PUSH
97210: LD_EXP 117
97214: AND
97215: IFFALSE 97318
97217: GO 97219
97219: DISABLE
97220: LD_INT 0
97222: PPUSH
// begin for i := 1 to 5 do
97223: LD_ADDR_VAR 0 1
97227: PUSH
97228: DOUBLE
97229: LD_INT 1
97231: DEC
97232: ST_TO_ADDR
97233: LD_INT 5
97235: PUSH
97236: FOR_TO
97237: IFFALSE 97316
// begin uc_nation := nation_nature ;
97239: LD_ADDR_OWVAR 21
97243: PUSH
97244: LD_INT 0
97246: ST_TO_ADDR
// uc_side := 0 ;
97247: LD_ADDR_OWVAR 20
97251: PUSH
97252: LD_INT 0
97254: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
97255: LD_ADDR_OWVAR 29
97259: PUSH
97260: LD_INT 12
97262: PUSH
97263: LD_INT 12
97265: PUSH
97266: EMPTY
97267: LIST
97268: LIST
97269: ST_TO_ADDR
// hc_agressivity := 20 ;
97270: LD_ADDR_OWVAR 35
97274: PUSH
97275: LD_INT 20
97277: ST_TO_ADDR
// hc_class := class_tiger ;
97278: LD_ADDR_OWVAR 28
97282: PUSH
97283: LD_INT 14
97285: ST_TO_ADDR
// hc_gallery :=  ;
97286: LD_ADDR_OWVAR 33
97290: PUSH
97291: LD_STRING 
97293: ST_TO_ADDR
// hc_name :=  ;
97294: LD_ADDR_OWVAR 26
97298: PUSH
97299: LD_STRING 
97301: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
97302: CALL_OW 44
97306: PPUSH
97307: LD_INT 0
97309: PPUSH
97310: CALL_OW 51
// end ;
97314: GO 97236
97316: POP
97317: POP
// end ;
97318: PPOPN 1
97320: END
// every 0 0$1 trigger StreamModeActive and sBomb do
97321: LD_EXP 98
97325: PUSH
97326: LD_EXP 118
97330: AND
97331: IFFALSE 97340
97333: GO 97335
97335: DISABLE
// StreamSibBomb ;
97336: CALL 97341 0 0
97340: END
// export function StreamSibBomb ; var i , x , y ; begin
97341: LD_INT 0
97343: PPUSH
97344: PPUSH
97345: PPUSH
97346: PPUSH
// result := false ;
97347: LD_ADDR_VAR 0 1
97351: PUSH
97352: LD_INT 0
97354: ST_TO_ADDR
// for i := 1 to 16 do
97355: LD_ADDR_VAR 0 2
97359: PUSH
97360: DOUBLE
97361: LD_INT 1
97363: DEC
97364: ST_TO_ADDR
97365: LD_INT 16
97367: PUSH
97368: FOR_TO
97369: IFFALSE 97568
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
97371: LD_ADDR_VAR 0 3
97375: PUSH
97376: LD_INT 10
97378: PUSH
97379: LD_INT 20
97381: PUSH
97382: LD_INT 30
97384: PUSH
97385: LD_INT 40
97387: PUSH
97388: LD_INT 50
97390: PUSH
97391: LD_INT 60
97393: PUSH
97394: LD_INT 70
97396: PUSH
97397: LD_INT 80
97399: PUSH
97400: LD_INT 90
97402: PUSH
97403: LD_INT 100
97405: PUSH
97406: LD_INT 110
97408: PUSH
97409: LD_INT 120
97411: PUSH
97412: LD_INT 130
97414: PUSH
97415: LD_INT 140
97417: PUSH
97418: LD_INT 150
97420: PUSH
97421: EMPTY
97422: LIST
97423: LIST
97424: LIST
97425: LIST
97426: LIST
97427: LIST
97428: LIST
97429: LIST
97430: LIST
97431: LIST
97432: LIST
97433: LIST
97434: LIST
97435: LIST
97436: LIST
97437: PUSH
97438: LD_INT 1
97440: PPUSH
97441: LD_INT 15
97443: PPUSH
97444: CALL_OW 12
97448: ARRAY
97449: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
97450: LD_ADDR_VAR 0 4
97454: PUSH
97455: LD_INT 10
97457: PUSH
97458: LD_INT 20
97460: PUSH
97461: LD_INT 30
97463: PUSH
97464: LD_INT 40
97466: PUSH
97467: LD_INT 50
97469: PUSH
97470: LD_INT 60
97472: PUSH
97473: LD_INT 70
97475: PUSH
97476: LD_INT 80
97478: PUSH
97479: LD_INT 90
97481: PUSH
97482: LD_INT 100
97484: PUSH
97485: LD_INT 110
97487: PUSH
97488: LD_INT 120
97490: PUSH
97491: LD_INT 130
97493: PUSH
97494: LD_INT 140
97496: PUSH
97497: LD_INT 150
97499: PUSH
97500: EMPTY
97501: LIST
97502: LIST
97503: LIST
97504: LIST
97505: LIST
97506: LIST
97507: LIST
97508: LIST
97509: LIST
97510: LIST
97511: LIST
97512: LIST
97513: LIST
97514: LIST
97515: LIST
97516: PUSH
97517: LD_INT 1
97519: PPUSH
97520: LD_INT 15
97522: PPUSH
97523: CALL_OW 12
97527: ARRAY
97528: ST_TO_ADDR
// if ValidHex ( x , y ) then
97529: LD_VAR 0 3
97533: PPUSH
97534: LD_VAR 0 4
97538: PPUSH
97539: CALL_OW 488
97543: IFFALSE 97566
// begin result := [ x , y ] ;
97545: LD_ADDR_VAR 0 1
97549: PUSH
97550: LD_VAR 0 3
97554: PUSH
97555: LD_VAR 0 4
97559: PUSH
97560: EMPTY
97561: LIST
97562: LIST
97563: ST_TO_ADDR
// break ;
97564: GO 97568
// end ; end ;
97566: GO 97368
97568: POP
97569: POP
// if result then
97570: LD_VAR 0 1
97574: IFFALSE 97634
// begin ToLua ( playSibBomb() ) ;
97576: LD_STRING playSibBomb()
97578: PPUSH
97579: CALL_OW 559
// wait ( 0 0$14 ) ;
97583: LD_INT 490
97585: PPUSH
97586: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
97590: LD_VAR 0 1
97594: PUSH
97595: LD_INT 1
97597: ARRAY
97598: PPUSH
97599: LD_VAR 0 1
97603: PUSH
97604: LD_INT 2
97606: ARRAY
97607: PPUSH
97608: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
97612: LD_VAR 0 1
97616: PUSH
97617: LD_INT 1
97619: ARRAY
97620: PPUSH
97621: LD_VAR 0 1
97625: PUSH
97626: LD_INT 2
97628: ARRAY
97629: PPUSH
97630: CALL_OW 429
// end ; end ;
97634: LD_VAR 0 1
97638: RET
// every 0 0$1 trigger StreamModeActive and sReset do
97639: LD_EXP 98
97643: PUSH
97644: LD_EXP 120
97648: AND
97649: IFFALSE 97661
97651: GO 97653
97653: DISABLE
// YouLost (  ) ;
97654: LD_STRING 
97656: PPUSH
97657: CALL_OW 104
97661: END
// every 0 0$1 trigger StreamModeActive and sFog do
97662: LD_EXP 98
97666: PUSH
97667: LD_EXP 119
97671: AND
97672: IFFALSE 97686
97674: GO 97676
97676: DISABLE
// FogOff ( your_side ) ;
97677: LD_OWVAR 2
97681: PPUSH
97682: CALL_OW 344
97686: END
// every 0 0$1 trigger StreamModeActive and sSun do
97687: LD_EXP 98
97691: PUSH
97692: LD_EXP 121
97696: AND
97697: IFFALSE 97725
97699: GO 97701
97701: DISABLE
// begin solar_recharge_percent := 0 ;
97702: LD_ADDR_OWVAR 79
97706: PUSH
97707: LD_INT 0
97709: ST_TO_ADDR
// wait ( 5 5$00 ) ;
97710: LD_INT 10500
97712: PPUSH
97713: CALL_OW 67
// solar_recharge_percent := 100 ;
97717: LD_ADDR_OWVAR 79
97721: PUSH
97722: LD_INT 100
97724: ST_TO_ADDR
// end ;
97725: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
97726: LD_EXP 98
97730: PUSH
97731: LD_EXP 122
97735: AND
97736: IFFALSE 97975
97738: GO 97740
97740: DISABLE
97741: LD_INT 0
97743: PPUSH
97744: PPUSH
97745: PPUSH
// begin tmp := [ ] ;
97746: LD_ADDR_VAR 0 3
97750: PUSH
97751: EMPTY
97752: ST_TO_ADDR
// for i := 1 to 6 do
97753: LD_ADDR_VAR 0 1
97757: PUSH
97758: DOUBLE
97759: LD_INT 1
97761: DEC
97762: ST_TO_ADDR
97763: LD_INT 6
97765: PUSH
97766: FOR_TO
97767: IFFALSE 97872
// begin uc_nation := nation_nature ;
97769: LD_ADDR_OWVAR 21
97773: PUSH
97774: LD_INT 0
97776: ST_TO_ADDR
// uc_side := 0 ;
97777: LD_ADDR_OWVAR 20
97781: PUSH
97782: LD_INT 0
97784: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
97785: LD_ADDR_OWVAR 29
97789: PUSH
97790: LD_INT 12
97792: PUSH
97793: LD_INT 12
97795: PUSH
97796: EMPTY
97797: LIST
97798: LIST
97799: ST_TO_ADDR
// hc_agressivity := 20 ;
97800: LD_ADDR_OWVAR 35
97804: PUSH
97805: LD_INT 20
97807: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
97808: LD_ADDR_OWVAR 28
97812: PUSH
97813: LD_INT 17
97815: ST_TO_ADDR
// hc_gallery :=  ;
97816: LD_ADDR_OWVAR 33
97820: PUSH
97821: LD_STRING 
97823: ST_TO_ADDR
// hc_name :=  ;
97824: LD_ADDR_OWVAR 26
97828: PUSH
97829: LD_STRING 
97831: ST_TO_ADDR
// un := CreateHuman ;
97832: LD_ADDR_VAR 0 2
97836: PUSH
97837: CALL_OW 44
97841: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
97842: LD_VAR 0 2
97846: PPUSH
97847: LD_INT 1
97849: PPUSH
97850: CALL_OW 51
// tmp := tmp ^ un ;
97854: LD_ADDR_VAR 0 3
97858: PUSH
97859: LD_VAR 0 3
97863: PUSH
97864: LD_VAR 0 2
97868: ADD
97869: ST_TO_ADDR
// end ;
97870: GO 97766
97872: POP
97873: POP
// repeat wait ( 0 0$1 ) ;
97874: LD_INT 35
97876: PPUSH
97877: CALL_OW 67
// for un in tmp do
97881: LD_ADDR_VAR 0 2
97885: PUSH
97886: LD_VAR 0 3
97890: PUSH
97891: FOR_IN
97892: IFFALSE 97966
// begin if IsDead ( un ) then
97894: LD_VAR 0 2
97898: PPUSH
97899: CALL_OW 301
97903: IFFALSE 97923
// begin tmp := tmp diff un ;
97905: LD_ADDR_VAR 0 3
97909: PUSH
97910: LD_VAR 0 3
97914: PUSH
97915: LD_VAR 0 2
97919: DIFF
97920: ST_TO_ADDR
// continue ;
97921: GO 97891
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
97923: LD_VAR 0 2
97927: PPUSH
97928: LD_INT 3
97930: PUSH
97931: LD_INT 22
97933: PUSH
97934: LD_INT 0
97936: PUSH
97937: EMPTY
97938: LIST
97939: LIST
97940: PUSH
97941: EMPTY
97942: LIST
97943: LIST
97944: PPUSH
97945: CALL_OW 69
97949: PPUSH
97950: LD_VAR 0 2
97954: PPUSH
97955: CALL_OW 74
97959: PPUSH
97960: CALL_OW 115
// end ;
97964: GO 97891
97966: POP
97967: POP
// until not tmp ;
97968: LD_VAR 0 3
97972: NOT
97973: IFFALSE 97874
// end ;
97975: PPOPN 3
97977: END
// every 0 0$1 trigger StreamModeActive and sTroll do
97978: LD_EXP 98
97982: PUSH
97983: LD_EXP 123
97987: AND
97988: IFFALSE 98042
97990: GO 97992
97992: DISABLE
// begin ToLua ( displayTroll(); ) ;
97993: LD_STRING displayTroll();
97995: PPUSH
97996: CALL_OW 559
// wait ( 3 3$00 ) ;
98000: LD_INT 6300
98002: PPUSH
98003: CALL_OW 67
// ToLua ( hideTroll(); ) ;
98007: LD_STRING hideTroll();
98009: PPUSH
98010: CALL_OW 559
// wait ( 1 1$00 ) ;
98014: LD_INT 2100
98016: PPUSH
98017: CALL_OW 67
// ToLua ( displayTroll(); ) ;
98021: LD_STRING displayTroll();
98023: PPUSH
98024: CALL_OW 559
// wait ( 1 1$00 ) ;
98028: LD_INT 2100
98030: PPUSH
98031: CALL_OW 67
// ToLua ( hideTroll(); ) ;
98035: LD_STRING hideTroll();
98037: PPUSH
98038: CALL_OW 559
// end ;
98042: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
98043: LD_EXP 98
98047: PUSH
98048: LD_EXP 124
98052: AND
98053: IFFALSE 98116
98055: GO 98057
98057: DISABLE
98058: LD_INT 0
98060: PPUSH
// begin p := 0 ;
98061: LD_ADDR_VAR 0 1
98065: PUSH
98066: LD_INT 0
98068: ST_TO_ADDR
// repeat game_speed := 1 ;
98069: LD_ADDR_OWVAR 65
98073: PUSH
98074: LD_INT 1
98076: ST_TO_ADDR
// wait ( 0 0$1 ) ;
98077: LD_INT 35
98079: PPUSH
98080: CALL_OW 67
// p := p + 1 ;
98084: LD_ADDR_VAR 0 1
98088: PUSH
98089: LD_VAR 0 1
98093: PUSH
98094: LD_INT 1
98096: PLUS
98097: ST_TO_ADDR
// until p >= 60 ;
98098: LD_VAR 0 1
98102: PUSH
98103: LD_INT 60
98105: GREATEREQUAL
98106: IFFALSE 98069
// game_speed := 4 ;
98108: LD_ADDR_OWVAR 65
98112: PUSH
98113: LD_INT 4
98115: ST_TO_ADDR
// end ;
98116: PPOPN 1
98118: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
98119: LD_EXP 98
98123: PUSH
98124: LD_EXP 125
98128: AND
98129: IFFALSE 98275
98131: GO 98133
98133: DISABLE
98134: LD_INT 0
98136: PPUSH
98137: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
98138: LD_ADDR_VAR 0 1
98142: PUSH
98143: LD_INT 22
98145: PUSH
98146: LD_OWVAR 2
98150: PUSH
98151: EMPTY
98152: LIST
98153: LIST
98154: PUSH
98155: LD_INT 2
98157: PUSH
98158: LD_INT 30
98160: PUSH
98161: LD_INT 0
98163: PUSH
98164: EMPTY
98165: LIST
98166: LIST
98167: PUSH
98168: LD_INT 30
98170: PUSH
98171: LD_INT 1
98173: PUSH
98174: EMPTY
98175: LIST
98176: LIST
98177: PUSH
98178: EMPTY
98179: LIST
98180: LIST
98181: LIST
98182: PUSH
98183: EMPTY
98184: LIST
98185: LIST
98186: PPUSH
98187: CALL_OW 69
98191: ST_TO_ADDR
// if not depot then
98192: LD_VAR 0 1
98196: NOT
98197: IFFALSE 98201
// exit ;
98199: GO 98275
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
98201: LD_ADDR_VAR 0 2
98205: PUSH
98206: LD_VAR 0 1
98210: PUSH
98211: LD_INT 1
98213: PPUSH
98214: LD_VAR 0 1
98218: PPUSH
98219: CALL_OW 12
98223: ARRAY
98224: PPUSH
98225: CALL_OW 274
98229: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
98230: LD_VAR 0 2
98234: PPUSH
98235: LD_INT 1
98237: PPUSH
98238: LD_INT 0
98240: PPUSH
98241: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
98245: LD_VAR 0 2
98249: PPUSH
98250: LD_INT 2
98252: PPUSH
98253: LD_INT 0
98255: PPUSH
98256: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
98260: LD_VAR 0 2
98264: PPUSH
98265: LD_INT 3
98267: PPUSH
98268: LD_INT 0
98270: PPUSH
98271: CALL_OW 277
// end ;
98275: PPOPN 2
98277: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
98278: LD_EXP 98
98282: PUSH
98283: LD_EXP 126
98287: AND
98288: IFFALSE 98385
98290: GO 98292
98292: DISABLE
98293: LD_INT 0
98295: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
98296: LD_ADDR_VAR 0 1
98300: PUSH
98301: LD_INT 22
98303: PUSH
98304: LD_OWVAR 2
98308: PUSH
98309: EMPTY
98310: LIST
98311: LIST
98312: PUSH
98313: LD_INT 21
98315: PUSH
98316: LD_INT 1
98318: PUSH
98319: EMPTY
98320: LIST
98321: LIST
98322: PUSH
98323: LD_INT 3
98325: PUSH
98326: LD_INT 23
98328: PUSH
98329: LD_INT 0
98331: PUSH
98332: EMPTY
98333: LIST
98334: LIST
98335: PUSH
98336: EMPTY
98337: LIST
98338: LIST
98339: PUSH
98340: EMPTY
98341: LIST
98342: LIST
98343: LIST
98344: PPUSH
98345: CALL_OW 69
98349: ST_TO_ADDR
// if not tmp then
98350: LD_VAR 0 1
98354: NOT
98355: IFFALSE 98359
// exit ;
98357: GO 98385
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
98359: LD_VAR 0 1
98363: PUSH
98364: LD_INT 1
98366: PPUSH
98367: LD_VAR 0 1
98371: PPUSH
98372: CALL_OW 12
98376: ARRAY
98377: PPUSH
98378: LD_INT 200
98380: PPUSH
98381: CALL_OW 234
// end ;
98385: PPOPN 1
98387: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
98388: LD_EXP 98
98392: PUSH
98393: LD_EXP 127
98397: AND
98398: IFFALSE 98477
98400: GO 98402
98402: DISABLE
98403: LD_INT 0
98405: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
98406: LD_ADDR_VAR 0 1
98410: PUSH
98411: LD_INT 22
98413: PUSH
98414: LD_OWVAR 2
98418: PUSH
98419: EMPTY
98420: LIST
98421: LIST
98422: PUSH
98423: LD_INT 21
98425: PUSH
98426: LD_INT 2
98428: PUSH
98429: EMPTY
98430: LIST
98431: LIST
98432: PUSH
98433: EMPTY
98434: LIST
98435: LIST
98436: PPUSH
98437: CALL_OW 69
98441: ST_TO_ADDR
// if not tmp then
98442: LD_VAR 0 1
98446: NOT
98447: IFFALSE 98451
// exit ;
98449: GO 98477
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
98451: LD_VAR 0 1
98455: PUSH
98456: LD_INT 1
98458: PPUSH
98459: LD_VAR 0 1
98463: PPUSH
98464: CALL_OW 12
98468: ARRAY
98469: PPUSH
98470: LD_INT 60
98472: PPUSH
98473: CALL_OW 234
// end ;
98477: PPOPN 1
98479: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
98480: LD_EXP 98
98484: PUSH
98485: LD_EXP 128
98489: AND
98490: IFFALSE 98589
98492: GO 98494
98494: DISABLE
98495: LD_INT 0
98497: PPUSH
98498: PPUSH
// begin enable ;
98499: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
98500: LD_ADDR_VAR 0 1
98504: PUSH
98505: LD_INT 22
98507: PUSH
98508: LD_OWVAR 2
98512: PUSH
98513: EMPTY
98514: LIST
98515: LIST
98516: PUSH
98517: LD_INT 61
98519: PUSH
98520: EMPTY
98521: LIST
98522: PUSH
98523: LD_INT 33
98525: PUSH
98526: LD_INT 2
98528: PUSH
98529: EMPTY
98530: LIST
98531: LIST
98532: PUSH
98533: EMPTY
98534: LIST
98535: LIST
98536: LIST
98537: PPUSH
98538: CALL_OW 69
98542: ST_TO_ADDR
// if not tmp then
98543: LD_VAR 0 1
98547: NOT
98548: IFFALSE 98552
// exit ;
98550: GO 98589
// for i in tmp do
98552: LD_ADDR_VAR 0 2
98556: PUSH
98557: LD_VAR 0 1
98561: PUSH
98562: FOR_IN
98563: IFFALSE 98587
// if IsControledBy ( i ) then
98565: LD_VAR 0 2
98569: PPUSH
98570: CALL_OW 312
98574: IFFALSE 98585
// ComUnlink ( i ) ;
98576: LD_VAR 0 2
98580: PPUSH
98581: CALL_OW 136
98585: GO 98562
98587: POP
98588: POP
// end ;
98589: PPOPN 2
98591: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
98592: LD_EXP 98
98596: PUSH
98597: LD_EXP 129
98601: AND
98602: IFFALSE 98742
98604: GO 98606
98606: DISABLE
98607: LD_INT 0
98609: PPUSH
98610: PPUSH
// begin ToLua ( displayPowell(); ) ;
98611: LD_STRING displayPowell();
98613: PPUSH
98614: CALL_OW 559
// uc_side := 0 ;
98618: LD_ADDR_OWVAR 20
98622: PUSH
98623: LD_INT 0
98625: ST_TO_ADDR
// uc_nation := 2 ;
98626: LD_ADDR_OWVAR 21
98630: PUSH
98631: LD_INT 2
98633: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
98634: LD_ADDR_OWVAR 37
98638: PUSH
98639: LD_INT 14
98641: ST_TO_ADDR
// vc_engine := engine_siberite ;
98642: LD_ADDR_OWVAR 39
98646: PUSH
98647: LD_INT 3
98649: ST_TO_ADDR
// vc_control := control_apeman ;
98650: LD_ADDR_OWVAR 38
98654: PUSH
98655: LD_INT 5
98657: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
98658: LD_ADDR_OWVAR 40
98662: PUSH
98663: LD_INT 29
98665: ST_TO_ADDR
// un := CreateVehicle ;
98666: LD_ADDR_VAR 0 2
98670: PUSH
98671: CALL_OW 45
98675: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
98676: LD_VAR 0 2
98680: PPUSH
98681: LD_INT 1
98683: PPUSH
98684: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
98688: LD_INT 35
98690: PPUSH
98691: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
98695: LD_VAR 0 2
98699: PPUSH
98700: LD_INT 22
98702: PUSH
98703: LD_OWVAR 2
98707: PUSH
98708: EMPTY
98709: LIST
98710: LIST
98711: PPUSH
98712: CALL_OW 69
98716: PPUSH
98717: LD_VAR 0 2
98721: PPUSH
98722: CALL_OW 74
98726: PPUSH
98727: CALL_OW 115
// until IsDead ( un ) ;
98731: LD_VAR 0 2
98735: PPUSH
98736: CALL_OW 301
98740: IFFALSE 98688
// end ;
98742: PPOPN 2
98744: END
// every 0 0$1 trigger StreamModeActive and sStu do
98745: LD_EXP 98
98749: PUSH
98750: LD_EXP 137
98754: AND
98755: IFFALSE 98771
98757: GO 98759
98759: DISABLE
// begin ToLua ( displayStucuk(); ) ;
98760: LD_STRING displayStucuk();
98762: PPUSH
98763: CALL_OW 559
// ResetFog ;
98767: CALL_OW 335
// end ;
98771: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
98772: LD_EXP 98
98776: PUSH
98777: LD_EXP 130
98781: AND
98782: IFFALSE 98923
98784: GO 98786
98786: DISABLE
98787: LD_INT 0
98789: PPUSH
98790: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
98791: LD_ADDR_VAR 0 2
98795: PUSH
98796: LD_INT 22
98798: PUSH
98799: LD_OWVAR 2
98803: PUSH
98804: EMPTY
98805: LIST
98806: LIST
98807: PUSH
98808: LD_INT 21
98810: PUSH
98811: LD_INT 1
98813: PUSH
98814: EMPTY
98815: LIST
98816: LIST
98817: PUSH
98818: EMPTY
98819: LIST
98820: LIST
98821: PPUSH
98822: CALL_OW 69
98826: ST_TO_ADDR
// if not tmp then
98827: LD_VAR 0 2
98831: NOT
98832: IFFALSE 98836
// exit ;
98834: GO 98923
// un := tmp [ rand ( 1 , tmp ) ] ;
98836: LD_ADDR_VAR 0 1
98840: PUSH
98841: LD_VAR 0 2
98845: PUSH
98846: LD_INT 1
98848: PPUSH
98849: LD_VAR 0 2
98853: PPUSH
98854: CALL_OW 12
98858: ARRAY
98859: ST_TO_ADDR
// SetSide ( un , 0 ) ;
98860: LD_VAR 0 1
98864: PPUSH
98865: LD_INT 0
98867: PPUSH
98868: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
98872: LD_VAR 0 1
98876: PPUSH
98877: LD_OWVAR 3
98881: PUSH
98882: LD_VAR 0 1
98886: DIFF
98887: PPUSH
98888: LD_VAR 0 1
98892: PPUSH
98893: CALL_OW 74
98897: PPUSH
98898: CALL_OW 115
// wait ( 0 0$20 ) ;
98902: LD_INT 700
98904: PPUSH
98905: CALL_OW 67
// SetSide ( un , your_side ) ;
98909: LD_VAR 0 1
98913: PPUSH
98914: LD_OWVAR 2
98918: PPUSH
98919: CALL_OW 235
// end ;
98923: PPOPN 2
98925: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
98926: LD_EXP 98
98930: PUSH
98931: LD_EXP 131
98935: AND
98936: IFFALSE 99042
98938: GO 98940
98940: DISABLE
98941: LD_INT 0
98943: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
98944: LD_ADDR_VAR 0 1
98948: PUSH
98949: LD_INT 22
98951: PUSH
98952: LD_OWVAR 2
98956: PUSH
98957: EMPTY
98958: LIST
98959: LIST
98960: PUSH
98961: LD_INT 2
98963: PUSH
98964: LD_INT 30
98966: PUSH
98967: LD_INT 0
98969: PUSH
98970: EMPTY
98971: LIST
98972: LIST
98973: PUSH
98974: LD_INT 30
98976: PUSH
98977: LD_INT 1
98979: PUSH
98980: EMPTY
98981: LIST
98982: LIST
98983: PUSH
98984: EMPTY
98985: LIST
98986: LIST
98987: LIST
98988: PUSH
98989: EMPTY
98990: LIST
98991: LIST
98992: PPUSH
98993: CALL_OW 69
98997: ST_TO_ADDR
// if not depot then
98998: LD_VAR 0 1
99002: NOT
99003: IFFALSE 99007
// exit ;
99005: GO 99042
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
99007: LD_VAR 0 1
99011: PUSH
99012: LD_INT 1
99014: ARRAY
99015: PPUSH
99016: CALL_OW 250
99020: PPUSH
99021: LD_VAR 0 1
99025: PUSH
99026: LD_INT 1
99028: ARRAY
99029: PPUSH
99030: CALL_OW 251
99034: PPUSH
99035: LD_INT 70
99037: PPUSH
99038: CALL_OW 495
// end ;
99042: PPOPN 1
99044: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
99045: LD_EXP 98
99049: PUSH
99050: LD_EXP 132
99054: AND
99055: IFFALSE 99266
99057: GO 99059
99059: DISABLE
99060: LD_INT 0
99062: PPUSH
99063: PPUSH
99064: PPUSH
99065: PPUSH
99066: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99067: LD_ADDR_VAR 0 5
99071: PUSH
99072: LD_INT 22
99074: PUSH
99075: LD_OWVAR 2
99079: PUSH
99080: EMPTY
99081: LIST
99082: LIST
99083: PUSH
99084: LD_INT 21
99086: PUSH
99087: LD_INT 1
99089: PUSH
99090: EMPTY
99091: LIST
99092: LIST
99093: PUSH
99094: EMPTY
99095: LIST
99096: LIST
99097: PPUSH
99098: CALL_OW 69
99102: ST_TO_ADDR
// if not tmp then
99103: LD_VAR 0 5
99107: NOT
99108: IFFALSE 99112
// exit ;
99110: GO 99266
// for i in tmp do
99112: LD_ADDR_VAR 0 1
99116: PUSH
99117: LD_VAR 0 5
99121: PUSH
99122: FOR_IN
99123: IFFALSE 99264
// begin d := rand ( 0 , 5 ) ;
99125: LD_ADDR_VAR 0 4
99129: PUSH
99130: LD_INT 0
99132: PPUSH
99133: LD_INT 5
99135: PPUSH
99136: CALL_OW 12
99140: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
99141: LD_ADDR_VAR 0 2
99145: PUSH
99146: LD_VAR 0 1
99150: PPUSH
99151: CALL_OW 250
99155: PPUSH
99156: LD_VAR 0 4
99160: PPUSH
99161: LD_INT 3
99163: PPUSH
99164: LD_INT 12
99166: PPUSH
99167: CALL_OW 12
99171: PPUSH
99172: CALL_OW 272
99176: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
99177: LD_ADDR_VAR 0 3
99181: PUSH
99182: LD_VAR 0 1
99186: PPUSH
99187: CALL_OW 251
99191: PPUSH
99192: LD_VAR 0 4
99196: PPUSH
99197: LD_INT 3
99199: PPUSH
99200: LD_INT 12
99202: PPUSH
99203: CALL_OW 12
99207: PPUSH
99208: CALL_OW 273
99212: ST_TO_ADDR
// if ValidHex ( x , y ) then
99213: LD_VAR 0 2
99217: PPUSH
99218: LD_VAR 0 3
99222: PPUSH
99223: CALL_OW 488
99227: IFFALSE 99262
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
99229: LD_VAR 0 1
99233: PPUSH
99234: LD_VAR 0 2
99238: PPUSH
99239: LD_VAR 0 3
99243: PPUSH
99244: LD_INT 3
99246: PPUSH
99247: LD_INT 6
99249: PPUSH
99250: CALL_OW 12
99254: PPUSH
99255: LD_INT 1
99257: PPUSH
99258: CALL_OW 483
// end ;
99262: GO 99122
99264: POP
99265: POP
// end ;
99266: PPOPN 5
99268: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
99269: LD_EXP 98
99273: PUSH
99274: LD_EXP 133
99278: AND
99279: IFFALSE 99373
99281: GO 99283
99283: DISABLE
99284: LD_INT 0
99286: PPUSH
99287: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
99288: LD_ADDR_VAR 0 2
99292: PUSH
99293: LD_INT 22
99295: PUSH
99296: LD_OWVAR 2
99300: PUSH
99301: EMPTY
99302: LIST
99303: LIST
99304: PUSH
99305: LD_INT 32
99307: PUSH
99308: LD_INT 1
99310: PUSH
99311: EMPTY
99312: LIST
99313: LIST
99314: PUSH
99315: LD_INT 21
99317: PUSH
99318: LD_INT 2
99320: PUSH
99321: EMPTY
99322: LIST
99323: LIST
99324: PUSH
99325: EMPTY
99326: LIST
99327: LIST
99328: LIST
99329: PPUSH
99330: CALL_OW 69
99334: ST_TO_ADDR
// if not tmp then
99335: LD_VAR 0 2
99339: NOT
99340: IFFALSE 99344
// exit ;
99342: GO 99373
// for i in tmp do
99344: LD_ADDR_VAR 0 1
99348: PUSH
99349: LD_VAR 0 2
99353: PUSH
99354: FOR_IN
99355: IFFALSE 99371
// SetFuel ( i , 0 ) ;
99357: LD_VAR 0 1
99361: PPUSH
99362: LD_INT 0
99364: PPUSH
99365: CALL_OW 240
99369: GO 99354
99371: POP
99372: POP
// end ;
99373: PPOPN 2
99375: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
99376: LD_EXP 98
99380: PUSH
99381: LD_EXP 134
99385: AND
99386: IFFALSE 99452
99388: GO 99390
99390: DISABLE
99391: LD_INT 0
99393: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
99394: LD_ADDR_VAR 0 1
99398: PUSH
99399: LD_INT 22
99401: PUSH
99402: LD_OWVAR 2
99406: PUSH
99407: EMPTY
99408: LIST
99409: LIST
99410: PUSH
99411: LD_INT 30
99413: PUSH
99414: LD_INT 29
99416: PUSH
99417: EMPTY
99418: LIST
99419: LIST
99420: PUSH
99421: EMPTY
99422: LIST
99423: LIST
99424: PPUSH
99425: CALL_OW 69
99429: ST_TO_ADDR
// if not tmp then
99430: LD_VAR 0 1
99434: NOT
99435: IFFALSE 99439
// exit ;
99437: GO 99452
// DestroyUnit ( tmp [ 1 ] ) ;
99439: LD_VAR 0 1
99443: PUSH
99444: LD_INT 1
99446: ARRAY
99447: PPUSH
99448: CALL_OW 65
// end ;
99452: PPOPN 1
99454: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
99455: LD_EXP 98
99459: PUSH
99460: LD_EXP 136
99464: AND
99465: IFFALSE 99594
99467: GO 99469
99469: DISABLE
99470: LD_INT 0
99472: PPUSH
// begin uc_side := 0 ;
99473: LD_ADDR_OWVAR 20
99477: PUSH
99478: LD_INT 0
99480: ST_TO_ADDR
// uc_nation := nation_arabian ;
99481: LD_ADDR_OWVAR 21
99485: PUSH
99486: LD_INT 2
99488: ST_TO_ADDR
// hc_gallery :=  ;
99489: LD_ADDR_OWVAR 33
99493: PUSH
99494: LD_STRING 
99496: ST_TO_ADDR
// hc_name :=  ;
99497: LD_ADDR_OWVAR 26
99501: PUSH
99502: LD_STRING 
99504: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
99505: LD_INT 1
99507: PPUSH
99508: LD_INT 11
99510: PPUSH
99511: LD_INT 10
99513: PPUSH
99514: CALL_OW 380
// un := CreateHuman ;
99518: LD_ADDR_VAR 0 1
99522: PUSH
99523: CALL_OW 44
99527: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99528: LD_VAR 0 1
99532: PPUSH
99533: LD_INT 1
99535: PPUSH
99536: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
99540: LD_INT 35
99542: PPUSH
99543: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
99547: LD_VAR 0 1
99551: PPUSH
99552: LD_INT 22
99554: PUSH
99555: LD_OWVAR 2
99559: PUSH
99560: EMPTY
99561: LIST
99562: LIST
99563: PPUSH
99564: CALL_OW 69
99568: PPUSH
99569: LD_VAR 0 1
99573: PPUSH
99574: CALL_OW 74
99578: PPUSH
99579: CALL_OW 115
// until IsDead ( un ) ;
99583: LD_VAR 0 1
99587: PPUSH
99588: CALL_OW 301
99592: IFFALSE 99540
// end ;
99594: PPOPN 1
99596: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
99597: LD_EXP 98
99601: PUSH
99602: LD_EXP 138
99606: AND
99607: IFFALSE 99619
99609: GO 99611
99611: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
99612: LD_STRING earthquake(getX(game), 0, 32)
99614: PPUSH
99615: CALL_OW 559
99619: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
99620: LD_EXP 98
99624: PUSH
99625: LD_EXP 139
99629: AND
99630: IFFALSE 99721
99632: GO 99634
99634: DISABLE
99635: LD_INT 0
99637: PPUSH
// begin enable ;
99638: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
99639: LD_ADDR_VAR 0 1
99643: PUSH
99644: LD_INT 22
99646: PUSH
99647: LD_OWVAR 2
99651: PUSH
99652: EMPTY
99653: LIST
99654: LIST
99655: PUSH
99656: LD_INT 21
99658: PUSH
99659: LD_INT 2
99661: PUSH
99662: EMPTY
99663: LIST
99664: LIST
99665: PUSH
99666: LD_INT 33
99668: PUSH
99669: LD_INT 3
99671: PUSH
99672: EMPTY
99673: LIST
99674: LIST
99675: PUSH
99676: EMPTY
99677: LIST
99678: LIST
99679: LIST
99680: PPUSH
99681: CALL_OW 69
99685: ST_TO_ADDR
// if not tmp then
99686: LD_VAR 0 1
99690: NOT
99691: IFFALSE 99695
// exit ;
99693: GO 99721
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
99695: LD_VAR 0 1
99699: PUSH
99700: LD_INT 1
99702: PPUSH
99703: LD_VAR 0 1
99707: PPUSH
99708: CALL_OW 12
99712: ARRAY
99713: PPUSH
99714: LD_INT 1
99716: PPUSH
99717: CALL_OW 234
// end ;
99721: PPOPN 1
99723: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
99724: LD_EXP 98
99728: PUSH
99729: LD_EXP 140
99733: AND
99734: IFFALSE 99875
99736: GO 99738
99738: DISABLE
99739: LD_INT 0
99741: PPUSH
99742: PPUSH
99743: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99744: LD_ADDR_VAR 0 3
99748: PUSH
99749: LD_INT 22
99751: PUSH
99752: LD_OWVAR 2
99756: PUSH
99757: EMPTY
99758: LIST
99759: LIST
99760: PUSH
99761: LD_INT 25
99763: PUSH
99764: LD_INT 1
99766: PUSH
99767: EMPTY
99768: LIST
99769: LIST
99770: PUSH
99771: EMPTY
99772: LIST
99773: LIST
99774: PPUSH
99775: CALL_OW 69
99779: ST_TO_ADDR
// if not tmp then
99780: LD_VAR 0 3
99784: NOT
99785: IFFALSE 99789
// exit ;
99787: GO 99875
// un := tmp [ rand ( 1 , tmp ) ] ;
99789: LD_ADDR_VAR 0 2
99793: PUSH
99794: LD_VAR 0 3
99798: PUSH
99799: LD_INT 1
99801: PPUSH
99802: LD_VAR 0 3
99806: PPUSH
99807: CALL_OW 12
99811: ARRAY
99812: ST_TO_ADDR
// if Crawls ( un ) then
99813: LD_VAR 0 2
99817: PPUSH
99818: CALL_OW 318
99822: IFFALSE 99833
// ComWalk ( un ) ;
99824: LD_VAR 0 2
99828: PPUSH
99829: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
99833: LD_VAR 0 2
99837: PPUSH
99838: LD_INT 9
99840: PPUSH
99841: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
99845: LD_INT 28
99847: PPUSH
99848: LD_OWVAR 2
99852: PPUSH
99853: LD_INT 2
99855: PPUSH
99856: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
99860: LD_INT 29
99862: PPUSH
99863: LD_OWVAR 2
99867: PPUSH
99868: LD_INT 2
99870: PPUSH
99871: CALL_OW 322
// end ;
99875: PPOPN 3
99877: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
99878: LD_EXP 98
99882: PUSH
99883: LD_EXP 141
99887: AND
99888: IFFALSE 99999
99890: GO 99892
99892: DISABLE
99893: LD_INT 0
99895: PPUSH
99896: PPUSH
99897: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99898: LD_ADDR_VAR 0 3
99902: PUSH
99903: LD_INT 22
99905: PUSH
99906: LD_OWVAR 2
99910: PUSH
99911: EMPTY
99912: LIST
99913: LIST
99914: PUSH
99915: LD_INT 25
99917: PUSH
99918: LD_INT 1
99920: PUSH
99921: EMPTY
99922: LIST
99923: LIST
99924: PUSH
99925: EMPTY
99926: LIST
99927: LIST
99928: PPUSH
99929: CALL_OW 69
99933: ST_TO_ADDR
// if not tmp then
99934: LD_VAR 0 3
99938: NOT
99939: IFFALSE 99943
// exit ;
99941: GO 99999
// un := tmp [ rand ( 1 , tmp ) ] ;
99943: LD_ADDR_VAR 0 2
99947: PUSH
99948: LD_VAR 0 3
99952: PUSH
99953: LD_INT 1
99955: PPUSH
99956: LD_VAR 0 3
99960: PPUSH
99961: CALL_OW 12
99965: ARRAY
99966: ST_TO_ADDR
// if Crawls ( un ) then
99967: LD_VAR 0 2
99971: PPUSH
99972: CALL_OW 318
99976: IFFALSE 99987
// ComWalk ( un ) ;
99978: LD_VAR 0 2
99982: PPUSH
99983: CALL_OW 138
// SetClass ( un , class_mortar ) ;
99987: LD_VAR 0 2
99991: PPUSH
99992: LD_INT 8
99994: PPUSH
99995: CALL_OW 336
// end ;
99999: PPOPN 3
100001: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
100002: LD_EXP 98
100006: PUSH
100007: LD_EXP 142
100011: AND
100012: IFFALSE 100156
100014: GO 100016
100016: DISABLE
100017: LD_INT 0
100019: PPUSH
100020: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
100021: LD_ADDR_VAR 0 2
100025: PUSH
100026: LD_INT 22
100028: PUSH
100029: LD_OWVAR 2
100033: PUSH
100034: EMPTY
100035: LIST
100036: LIST
100037: PUSH
100038: LD_INT 21
100040: PUSH
100041: LD_INT 2
100043: PUSH
100044: EMPTY
100045: LIST
100046: LIST
100047: PUSH
100048: LD_INT 2
100050: PUSH
100051: LD_INT 34
100053: PUSH
100054: LD_INT 12
100056: PUSH
100057: EMPTY
100058: LIST
100059: LIST
100060: PUSH
100061: LD_INT 34
100063: PUSH
100064: LD_INT 51
100066: PUSH
100067: EMPTY
100068: LIST
100069: LIST
100070: PUSH
100071: LD_INT 34
100073: PUSH
100074: LD_INT 32
100076: PUSH
100077: EMPTY
100078: LIST
100079: LIST
100080: PUSH
100081: EMPTY
100082: LIST
100083: LIST
100084: LIST
100085: LIST
100086: PUSH
100087: EMPTY
100088: LIST
100089: LIST
100090: LIST
100091: PPUSH
100092: CALL_OW 69
100096: ST_TO_ADDR
// if not tmp then
100097: LD_VAR 0 2
100101: NOT
100102: IFFALSE 100106
// exit ;
100104: GO 100156
// for i in tmp do
100106: LD_ADDR_VAR 0 1
100110: PUSH
100111: LD_VAR 0 2
100115: PUSH
100116: FOR_IN
100117: IFFALSE 100154
// if GetCargo ( i , mat_artifact ) = 0 then
100119: LD_VAR 0 1
100123: PPUSH
100124: LD_INT 4
100126: PPUSH
100127: CALL_OW 289
100131: PUSH
100132: LD_INT 0
100134: EQUAL
100135: IFFALSE 100152
// SetCargo ( i , mat_siberit , 100 ) ;
100137: LD_VAR 0 1
100141: PPUSH
100142: LD_INT 3
100144: PPUSH
100145: LD_INT 100
100147: PPUSH
100148: CALL_OW 290
100152: GO 100116
100154: POP
100155: POP
// end ;
100156: PPOPN 2
100158: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
100159: LD_EXP 98
100163: PUSH
100164: LD_EXP 143
100168: AND
100169: IFFALSE 100352
100171: GO 100173
100173: DISABLE
100174: LD_INT 0
100176: PPUSH
100177: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
100178: LD_ADDR_VAR 0 2
100182: PUSH
100183: LD_INT 22
100185: PUSH
100186: LD_OWVAR 2
100190: PUSH
100191: EMPTY
100192: LIST
100193: LIST
100194: PPUSH
100195: CALL_OW 69
100199: ST_TO_ADDR
// if not tmp then
100200: LD_VAR 0 2
100204: NOT
100205: IFFALSE 100209
// exit ;
100207: GO 100352
// for i := 1 to 2 do
100209: LD_ADDR_VAR 0 1
100213: PUSH
100214: DOUBLE
100215: LD_INT 1
100217: DEC
100218: ST_TO_ADDR
100219: LD_INT 2
100221: PUSH
100222: FOR_TO
100223: IFFALSE 100350
// begin uc_side := your_side ;
100225: LD_ADDR_OWVAR 20
100229: PUSH
100230: LD_OWVAR 2
100234: ST_TO_ADDR
// uc_nation := nation_american ;
100235: LD_ADDR_OWVAR 21
100239: PUSH
100240: LD_INT 1
100242: ST_TO_ADDR
// vc_chassis := us_morphling ;
100243: LD_ADDR_OWVAR 37
100247: PUSH
100248: LD_INT 5
100250: ST_TO_ADDR
// vc_engine := engine_siberite ;
100251: LD_ADDR_OWVAR 39
100255: PUSH
100256: LD_INT 3
100258: ST_TO_ADDR
// vc_control := control_computer ;
100259: LD_ADDR_OWVAR 38
100263: PUSH
100264: LD_INT 3
100266: ST_TO_ADDR
// vc_weapon := us_double_laser ;
100267: LD_ADDR_OWVAR 40
100271: PUSH
100272: LD_INT 10
100274: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
100275: LD_VAR 0 2
100279: PUSH
100280: LD_INT 1
100282: ARRAY
100283: PPUSH
100284: CALL_OW 310
100288: NOT
100289: IFFALSE 100336
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
100291: CALL_OW 45
100295: PPUSH
100296: LD_VAR 0 2
100300: PUSH
100301: LD_INT 1
100303: ARRAY
100304: PPUSH
100305: CALL_OW 250
100309: PPUSH
100310: LD_VAR 0 2
100314: PUSH
100315: LD_INT 1
100317: ARRAY
100318: PPUSH
100319: CALL_OW 251
100323: PPUSH
100324: LD_INT 12
100326: PPUSH
100327: LD_INT 1
100329: PPUSH
100330: CALL_OW 50
100334: GO 100348
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
100336: CALL_OW 45
100340: PPUSH
100341: LD_INT 1
100343: PPUSH
100344: CALL_OW 51
// end ;
100348: GO 100222
100350: POP
100351: POP
// end ;
100352: PPOPN 2
100354: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
100355: LD_EXP 98
100359: PUSH
100360: LD_EXP 144
100364: AND
100365: IFFALSE 100587
100367: GO 100369
100369: DISABLE
100370: LD_INT 0
100372: PPUSH
100373: PPUSH
100374: PPUSH
100375: PPUSH
100376: PPUSH
100377: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100378: LD_ADDR_VAR 0 6
100382: PUSH
100383: LD_INT 22
100385: PUSH
100386: LD_OWVAR 2
100390: PUSH
100391: EMPTY
100392: LIST
100393: LIST
100394: PUSH
100395: LD_INT 21
100397: PUSH
100398: LD_INT 1
100400: PUSH
100401: EMPTY
100402: LIST
100403: LIST
100404: PUSH
100405: LD_INT 3
100407: PUSH
100408: LD_INT 23
100410: PUSH
100411: LD_INT 0
100413: PUSH
100414: EMPTY
100415: LIST
100416: LIST
100417: PUSH
100418: EMPTY
100419: LIST
100420: LIST
100421: PUSH
100422: EMPTY
100423: LIST
100424: LIST
100425: LIST
100426: PPUSH
100427: CALL_OW 69
100431: ST_TO_ADDR
// if not tmp then
100432: LD_VAR 0 6
100436: NOT
100437: IFFALSE 100441
// exit ;
100439: GO 100587
// s1 := rand ( 1 , 4 ) ;
100441: LD_ADDR_VAR 0 2
100445: PUSH
100446: LD_INT 1
100448: PPUSH
100449: LD_INT 4
100451: PPUSH
100452: CALL_OW 12
100456: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
100457: LD_ADDR_VAR 0 4
100461: PUSH
100462: LD_VAR 0 6
100466: PUSH
100467: LD_INT 1
100469: ARRAY
100470: PPUSH
100471: LD_VAR 0 2
100475: PPUSH
100476: CALL_OW 259
100480: ST_TO_ADDR
// if s1 = 1 then
100481: LD_VAR 0 2
100485: PUSH
100486: LD_INT 1
100488: EQUAL
100489: IFFALSE 100509
// s2 := rand ( 2 , 4 ) else
100491: LD_ADDR_VAR 0 3
100495: PUSH
100496: LD_INT 2
100498: PPUSH
100499: LD_INT 4
100501: PPUSH
100502: CALL_OW 12
100506: ST_TO_ADDR
100507: GO 100517
// s2 := 1 ;
100509: LD_ADDR_VAR 0 3
100513: PUSH
100514: LD_INT 1
100516: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
100517: LD_ADDR_VAR 0 5
100521: PUSH
100522: LD_VAR 0 6
100526: PUSH
100527: LD_INT 1
100529: ARRAY
100530: PPUSH
100531: LD_VAR 0 3
100535: PPUSH
100536: CALL_OW 259
100540: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
100541: LD_VAR 0 6
100545: PUSH
100546: LD_INT 1
100548: ARRAY
100549: PPUSH
100550: LD_VAR 0 2
100554: PPUSH
100555: LD_VAR 0 5
100559: PPUSH
100560: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
100564: LD_VAR 0 6
100568: PUSH
100569: LD_INT 1
100571: ARRAY
100572: PPUSH
100573: LD_VAR 0 3
100577: PPUSH
100578: LD_VAR 0 4
100582: PPUSH
100583: CALL_OW 237
// end ;
100587: PPOPN 6
100589: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
100590: LD_EXP 98
100594: PUSH
100595: LD_EXP 145
100599: AND
100600: IFFALSE 100679
100602: GO 100604
100604: DISABLE
100605: LD_INT 0
100607: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
100608: LD_ADDR_VAR 0 1
100612: PUSH
100613: LD_INT 22
100615: PUSH
100616: LD_OWVAR 2
100620: PUSH
100621: EMPTY
100622: LIST
100623: LIST
100624: PUSH
100625: LD_INT 30
100627: PUSH
100628: LD_INT 3
100630: PUSH
100631: EMPTY
100632: LIST
100633: LIST
100634: PUSH
100635: EMPTY
100636: LIST
100637: LIST
100638: PPUSH
100639: CALL_OW 69
100643: ST_TO_ADDR
// if not tmp then
100644: LD_VAR 0 1
100648: NOT
100649: IFFALSE 100653
// exit ;
100651: GO 100679
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
100653: LD_VAR 0 1
100657: PUSH
100658: LD_INT 1
100660: PPUSH
100661: LD_VAR 0 1
100665: PPUSH
100666: CALL_OW 12
100670: ARRAY
100671: PPUSH
100672: LD_INT 1
100674: PPUSH
100675: CALL_OW 234
// end ;
100679: PPOPN 1
100681: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
100682: LD_EXP 98
100686: PUSH
100687: LD_EXP 146
100691: AND
100692: IFFALSE 100804
100694: GO 100696
100696: DISABLE
100697: LD_INT 0
100699: PPUSH
100700: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
100701: LD_ADDR_VAR 0 2
100705: PUSH
100706: LD_INT 22
100708: PUSH
100709: LD_OWVAR 2
100713: PUSH
100714: EMPTY
100715: LIST
100716: LIST
100717: PUSH
100718: LD_INT 2
100720: PUSH
100721: LD_INT 30
100723: PUSH
100724: LD_INT 27
100726: PUSH
100727: EMPTY
100728: LIST
100729: LIST
100730: PUSH
100731: LD_INT 30
100733: PUSH
100734: LD_INT 26
100736: PUSH
100737: EMPTY
100738: LIST
100739: LIST
100740: PUSH
100741: LD_INT 30
100743: PUSH
100744: LD_INT 28
100746: PUSH
100747: EMPTY
100748: LIST
100749: LIST
100750: PUSH
100751: EMPTY
100752: LIST
100753: LIST
100754: LIST
100755: LIST
100756: PUSH
100757: EMPTY
100758: LIST
100759: LIST
100760: PPUSH
100761: CALL_OW 69
100765: ST_TO_ADDR
// if not tmp then
100766: LD_VAR 0 2
100770: NOT
100771: IFFALSE 100775
// exit ;
100773: GO 100804
// for i in tmp do
100775: LD_ADDR_VAR 0 1
100779: PUSH
100780: LD_VAR 0 2
100784: PUSH
100785: FOR_IN
100786: IFFALSE 100802
// SetLives ( i , 1 ) ;
100788: LD_VAR 0 1
100792: PPUSH
100793: LD_INT 1
100795: PPUSH
100796: CALL_OW 234
100800: GO 100785
100802: POP
100803: POP
// end ;
100804: PPOPN 2
100806: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
100807: LD_EXP 98
100811: PUSH
100812: LD_EXP 147
100816: AND
100817: IFFALSE 101091
100819: GO 100821
100821: DISABLE
100822: LD_INT 0
100824: PPUSH
100825: PPUSH
100826: PPUSH
// begin i := rand ( 1 , 7 ) ;
100827: LD_ADDR_VAR 0 1
100831: PUSH
100832: LD_INT 1
100834: PPUSH
100835: LD_INT 7
100837: PPUSH
100838: CALL_OW 12
100842: ST_TO_ADDR
// case i of 1 :
100843: LD_VAR 0 1
100847: PUSH
100848: LD_INT 1
100850: DOUBLE
100851: EQUAL
100852: IFTRUE 100856
100854: GO 100866
100856: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
100857: LD_STRING earthquake(getX(game), 0, 32)
100859: PPUSH
100860: CALL_OW 559
100864: GO 101091
100866: LD_INT 2
100868: DOUBLE
100869: EQUAL
100870: IFTRUE 100874
100872: GO 100888
100874: POP
// begin ToLua ( displayStucuk(); ) ;
100875: LD_STRING displayStucuk();
100877: PPUSH
100878: CALL_OW 559
// ResetFog ;
100882: CALL_OW 335
// end ; 3 :
100886: GO 101091
100888: LD_INT 3
100890: DOUBLE
100891: EQUAL
100892: IFTRUE 100896
100894: GO 101000
100896: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100897: LD_ADDR_VAR 0 2
100901: PUSH
100902: LD_INT 22
100904: PUSH
100905: LD_OWVAR 2
100909: PUSH
100910: EMPTY
100911: LIST
100912: LIST
100913: PUSH
100914: LD_INT 25
100916: PUSH
100917: LD_INT 1
100919: PUSH
100920: EMPTY
100921: LIST
100922: LIST
100923: PUSH
100924: EMPTY
100925: LIST
100926: LIST
100927: PPUSH
100928: CALL_OW 69
100932: ST_TO_ADDR
// if not tmp then
100933: LD_VAR 0 2
100937: NOT
100938: IFFALSE 100942
// exit ;
100940: GO 101091
// un := tmp [ rand ( 1 , tmp ) ] ;
100942: LD_ADDR_VAR 0 3
100946: PUSH
100947: LD_VAR 0 2
100951: PUSH
100952: LD_INT 1
100954: PPUSH
100955: LD_VAR 0 2
100959: PPUSH
100960: CALL_OW 12
100964: ARRAY
100965: ST_TO_ADDR
// if Crawls ( un ) then
100966: LD_VAR 0 3
100970: PPUSH
100971: CALL_OW 318
100975: IFFALSE 100986
// ComWalk ( un ) ;
100977: LD_VAR 0 3
100981: PPUSH
100982: CALL_OW 138
// SetClass ( un , class_mortar ) ;
100986: LD_VAR 0 3
100990: PPUSH
100991: LD_INT 8
100993: PPUSH
100994: CALL_OW 336
// end ; 4 :
100998: GO 101091
101000: LD_INT 4
101002: DOUBLE
101003: EQUAL
101004: IFTRUE 101008
101006: GO 101069
101008: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
101009: LD_ADDR_VAR 0 2
101013: PUSH
101014: LD_INT 22
101016: PUSH
101017: LD_OWVAR 2
101021: PUSH
101022: EMPTY
101023: LIST
101024: LIST
101025: PUSH
101026: LD_INT 30
101028: PUSH
101029: LD_INT 29
101031: PUSH
101032: EMPTY
101033: LIST
101034: LIST
101035: PUSH
101036: EMPTY
101037: LIST
101038: LIST
101039: PPUSH
101040: CALL_OW 69
101044: ST_TO_ADDR
// if not tmp then
101045: LD_VAR 0 2
101049: NOT
101050: IFFALSE 101054
// exit ;
101052: GO 101091
// DestroyUnit ( tmp [ 1 ] ) ;
101054: LD_VAR 0 2
101058: PUSH
101059: LD_INT 1
101061: ARRAY
101062: PPUSH
101063: CALL_OW 65
// end ; 5 .. 7 :
101067: GO 101091
101069: LD_INT 5
101071: DOUBLE
101072: GREATEREQUAL
101073: IFFALSE 101081
101075: LD_INT 7
101077: DOUBLE
101078: LESSEQUAL
101079: IFTRUE 101083
101081: GO 101090
101083: POP
// StreamSibBomb ; end ;
101084: CALL 97341 0 0
101088: GO 101091
101090: POP
// end ;
101091: PPOPN 3
101093: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
101094: LD_EXP 98
101098: PUSH
101099: LD_EXP 148
101103: AND
101104: IFFALSE 101260
101106: GO 101108
101108: DISABLE
101109: LD_INT 0
101111: PPUSH
101112: PPUSH
101113: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
101114: LD_ADDR_VAR 0 2
101118: PUSH
101119: LD_INT 81
101121: PUSH
101122: LD_OWVAR 2
101126: PUSH
101127: EMPTY
101128: LIST
101129: LIST
101130: PUSH
101131: LD_INT 2
101133: PUSH
101134: LD_INT 21
101136: PUSH
101137: LD_INT 1
101139: PUSH
101140: EMPTY
101141: LIST
101142: LIST
101143: PUSH
101144: LD_INT 21
101146: PUSH
101147: LD_INT 2
101149: PUSH
101150: EMPTY
101151: LIST
101152: LIST
101153: PUSH
101154: EMPTY
101155: LIST
101156: LIST
101157: LIST
101158: PUSH
101159: EMPTY
101160: LIST
101161: LIST
101162: PPUSH
101163: CALL_OW 69
101167: ST_TO_ADDR
// if not tmp then
101168: LD_VAR 0 2
101172: NOT
101173: IFFALSE 101177
// exit ;
101175: GO 101260
// p := 0 ;
101177: LD_ADDR_VAR 0 3
101181: PUSH
101182: LD_INT 0
101184: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
101185: LD_INT 35
101187: PPUSH
101188: CALL_OW 67
// p := p + 1 ;
101192: LD_ADDR_VAR 0 3
101196: PUSH
101197: LD_VAR 0 3
101201: PUSH
101202: LD_INT 1
101204: PLUS
101205: ST_TO_ADDR
// for i in tmp do
101206: LD_ADDR_VAR 0 1
101210: PUSH
101211: LD_VAR 0 2
101215: PUSH
101216: FOR_IN
101217: IFFALSE 101248
// if GetLives ( i ) < 1000 then
101219: LD_VAR 0 1
101223: PPUSH
101224: CALL_OW 256
101228: PUSH
101229: LD_INT 1000
101231: LESS
101232: IFFALSE 101246
// SetLives ( i , 1000 ) ;
101234: LD_VAR 0 1
101238: PPUSH
101239: LD_INT 1000
101241: PPUSH
101242: CALL_OW 234
101246: GO 101216
101248: POP
101249: POP
// until p > 20 ;
101250: LD_VAR 0 3
101254: PUSH
101255: LD_INT 20
101257: GREATER
101258: IFFALSE 101185
// end ;
101260: PPOPN 3
101262: END
// every 0 0$1 trigger StreamModeActive and sTime do
101263: LD_EXP 98
101267: PUSH
101268: LD_EXP 149
101272: AND
101273: IFFALSE 101308
101275: GO 101277
101277: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
101278: LD_INT 28
101280: PPUSH
101281: LD_OWVAR 2
101285: PPUSH
101286: LD_INT 2
101288: PPUSH
101289: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
101293: LD_INT 30
101295: PPUSH
101296: LD_OWVAR 2
101300: PPUSH
101301: LD_INT 2
101303: PPUSH
101304: CALL_OW 322
// end ;
101308: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
101309: LD_EXP 98
101313: PUSH
101314: LD_EXP 150
101318: AND
101319: IFFALSE 101440
101321: GO 101323
101323: DISABLE
101324: LD_INT 0
101326: PPUSH
101327: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
101328: LD_ADDR_VAR 0 2
101332: PUSH
101333: LD_INT 22
101335: PUSH
101336: LD_OWVAR 2
101340: PUSH
101341: EMPTY
101342: LIST
101343: LIST
101344: PUSH
101345: LD_INT 21
101347: PUSH
101348: LD_INT 1
101350: PUSH
101351: EMPTY
101352: LIST
101353: LIST
101354: PUSH
101355: LD_INT 3
101357: PUSH
101358: LD_INT 23
101360: PUSH
101361: LD_INT 0
101363: PUSH
101364: EMPTY
101365: LIST
101366: LIST
101367: PUSH
101368: EMPTY
101369: LIST
101370: LIST
101371: PUSH
101372: EMPTY
101373: LIST
101374: LIST
101375: LIST
101376: PPUSH
101377: CALL_OW 69
101381: ST_TO_ADDR
// if not tmp then
101382: LD_VAR 0 2
101386: NOT
101387: IFFALSE 101391
// exit ;
101389: GO 101440
// for i in tmp do
101391: LD_ADDR_VAR 0 1
101395: PUSH
101396: LD_VAR 0 2
101400: PUSH
101401: FOR_IN
101402: IFFALSE 101438
// begin if Crawls ( i ) then
101404: LD_VAR 0 1
101408: PPUSH
101409: CALL_OW 318
101413: IFFALSE 101424
// ComWalk ( i ) ;
101415: LD_VAR 0 1
101419: PPUSH
101420: CALL_OW 138
// SetClass ( i , 2 ) ;
101424: LD_VAR 0 1
101428: PPUSH
101429: LD_INT 2
101431: PPUSH
101432: CALL_OW 336
// end ;
101436: GO 101401
101438: POP
101439: POP
// end ;
101440: PPOPN 2
101442: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
101443: LD_EXP 98
101447: PUSH
101448: LD_EXP 151
101452: AND
101453: IFFALSE 101734
101455: GO 101457
101457: DISABLE
101458: LD_INT 0
101460: PPUSH
101461: PPUSH
101462: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
101463: LD_OWVAR 2
101467: PPUSH
101468: LD_INT 9
101470: PPUSH
101471: LD_INT 1
101473: PPUSH
101474: LD_INT 1
101476: PPUSH
101477: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
101481: LD_INT 9
101483: PPUSH
101484: LD_OWVAR 2
101488: PPUSH
101489: CALL_OW 343
// uc_side := 9 ;
101493: LD_ADDR_OWVAR 20
101497: PUSH
101498: LD_INT 9
101500: ST_TO_ADDR
// uc_nation := 2 ;
101501: LD_ADDR_OWVAR 21
101505: PUSH
101506: LD_INT 2
101508: ST_TO_ADDR
// hc_name := Dark Warrior ;
101509: LD_ADDR_OWVAR 26
101513: PUSH
101514: LD_STRING Dark Warrior
101516: ST_TO_ADDR
// hc_gallery :=  ;
101517: LD_ADDR_OWVAR 33
101521: PUSH
101522: LD_STRING 
101524: ST_TO_ADDR
// hc_noskilllimit := true ;
101525: LD_ADDR_OWVAR 76
101529: PUSH
101530: LD_INT 1
101532: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
101533: LD_ADDR_OWVAR 31
101537: PUSH
101538: LD_INT 30
101540: PUSH
101541: LD_INT 30
101543: PUSH
101544: LD_INT 30
101546: PUSH
101547: LD_INT 30
101549: PUSH
101550: EMPTY
101551: LIST
101552: LIST
101553: LIST
101554: LIST
101555: ST_TO_ADDR
// un := CreateHuman ;
101556: LD_ADDR_VAR 0 3
101560: PUSH
101561: CALL_OW 44
101565: ST_TO_ADDR
// hc_noskilllimit := false ;
101566: LD_ADDR_OWVAR 76
101570: PUSH
101571: LD_INT 0
101573: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101574: LD_VAR 0 3
101578: PPUSH
101579: LD_INT 1
101581: PPUSH
101582: CALL_OW 51
// p := 0 ;
101586: LD_ADDR_VAR 0 2
101590: PUSH
101591: LD_INT 0
101593: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
101594: LD_INT 35
101596: PPUSH
101597: CALL_OW 67
// p := p + 1 ;
101601: LD_ADDR_VAR 0 2
101605: PUSH
101606: LD_VAR 0 2
101610: PUSH
101611: LD_INT 1
101613: PLUS
101614: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
101615: LD_VAR 0 3
101619: PPUSH
101620: CALL_OW 256
101624: PUSH
101625: LD_INT 1000
101627: LESS
101628: IFFALSE 101642
// SetLives ( un , 1000 ) ;
101630: LD_VAR 0 3
101634: PPUSH
101635: LD_INT 1000
101637: PPUSH
101638: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
101642: LD_VAR 0 3
101646: PPUSH
101647: LD_INT 81
101649: PUSH
101650: LD_OWVAR 2
101654: PUSH
101655: EMPTY
101656: LIST
101657: LIST
101658: PUSH
101659: LD_INT 91
101661: PUSH
101662: LD_VAR 0 3
101666: PUSH
101667: LD_INT 30
101669: PUSH
101670: EMPTY
101671: LIST
101672: LIST
101673: LIST
101674: PUSH
101675: EMPTY
101676: LIST
101677: LIST
101678: PPUSH
101679: CALL_OW 69
101683: PPUSH
101684: LD_VAR 0 3
101688: PPUSH
101689: CALL_OW 74
101693: PPUSH
101694: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
101698: LD_VAR 0 2
101702: PUSH
101703: LD_INT 60
101705: GREATER
101706: PUSH
101707: LD_VAR 0 3
101711: PPUSH
101712: CALL_OW 301
101716: OR
101717: IFFALSE 101594
// if un then
101719: LD_VAR 0 3
101723: IFFALSE 101734
// RemoveUnit ( un ) ;
101725: LD_VAR 0 3
101729: PPUSH
101730: CALL_OW 64
// end ;
101734: PPOPN 3
101736: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
101737: LD_INT 0
101739: PPUSH
// case cmd of 301 :
101740: LD_VAR 0 1
101744: PUSH
101745: LD_INT 301
101747: DOUBLE
101748: EQUAL
101749: IFTRUE 101753
101751: GO 101785
101753: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
101754: LD_VAR 0 6
101758: PPUSH
101759: LD_VAR 0 7
101763: PPUSH
101764: LD_VAR 0 8
101768: PPUSH
101769: LD_VAR 0 4
101773: PPUSH
101774: LD_VAR 0 5
101778: PPUSH
101779: CALL 102986 0 5
101783: GO 101906
101785: LD_INT 302
101787: DOUBLE
101788: EQUAL
101789: IFTRUE 101793
101791: GO 101830
101793: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
101794: LD_VAR 0 6
101798: PPUSH
101799: LD_VAR 0 7
101803: PPUSH
101804: LD_VAR 0 8
101808: PPUSH
101809: LD_VAR 0 9
101813: PPUSH
101814: LD_VAR 0 4
101818: PPUSH
101819: LD_VAR 0 5
101823: PPUSH
101824: CALL 103077 0 6
101828: GO 101906
101830: LD_INT 303
101832: DOUBLE
101833: EQUAL
101834: IFTRUE 101838
101836: GO 101875
101838: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
101839: LD_VAR 0 6
101843: PPUSH
101844: LD_VAR 0 7
101848: PPUSH
101849: LD_VAR 0 8
101853: PPUSH
101854: LD_VAR 0 9
101858: PPUSH
101859: LD_VAR 0 4
101863: PPUSH
101864: LD_VAR 0 5
101868: PPUSH
101869: CALL 101911 0 6
101873: GO 101906
101875: LD_INT 304
101877: DOUBLE
101878: EQUAL
101879: IFTRUE 101883
101881: GO 101905
101883: POP
// hHackTeleport ( unit , x , y ) ; end ;
101884: LD_VAR 0 2
101888: PPUSH
101889: LD_VAR 0 4
101893: PPUSH
101894: LD_VAR 0 5
101898: PPUSH
101899: CALL 103670 0 3
101903: GO 101906
101905: POP
// end ;
101906: LD_VAR 0 12
101910: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
101911: LD_INT 0
101913: PPUSH
101914: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
101915: LD_VAR 0 1
101919: PUSH
101920: LD_INT 1
101922: LESS
101923: PUSH
101924: LD_VAR 0 1
101928: PUSH
101929: LD_INT 3
101931: GREATER
101932: OR
101933: PUSH
101934: LD_VAR 0 5
101938: PPUSH
101939: LD_VAR 0 6
101943: PPUSH
101944: CALL_OW 428
101948: OR
101949: IFFALSE 101953
// exit ;
101951: GO 102673
// uc_side := your_side ;
101953: LD_ADDR_OWVAR 20
101957: PUSH
101958: LD_OWVAR 2
101962: ST_TO_ADDR
// uc_nation := nation ;
101963: LD_ADDR_OWVAR 21
101967: PUSH
101968: LD_VAR 0 1
101972: ST_TO_ADDR
// bc_level = 1 ;
101973: LD_ADDR_OWVAR 43
101977: PUSH
101978: LD_INT 1
101980: ST_TO_ADDR
// case btype of 1 :
101981: LD_VAR 0 2
101985: PUSH
101986: LD_INT 1
101988: DOUBLE
101989: EQUAL
101990: IFTRUE 101994
101992: GO 102005
101994: POP
// bc_type := b_depot ; 2 :
101995: LD_ADDR_OWVAR 42
101999: PUSH
102000: LD_INT 0
102002: ST_TO_ADDR
102003: GO 102617
102005: LD_INT 2
102007: DOUBLE
102008: EQUAL
102009: IFTRUE 102013
102011: GO 102024
102013: POP
// bc_type := b_warehouse ; 3 :
102014: LD_ADDR_OWVAR 42
102018: PUSH
102019: LD_INT 1
102021: ST_TO_ADDR
102022: GO 102617
102024: LD_INT 3
102026: DOUBLE
102027: EQUAL
102028: IFTRUE 102032
102030: GO 102043
102032: POP
// bc_type := b_lab ; 4 .. 9 :
102033: LD_ADDR_OWVAR 42
102037: PUSH
102038: LD_INT 6
102040: ST_TO_ADDR
102041: GO 102617
102043: LD_INT 4
102045: DOUBLE
102046: GREATEREQUAL
102047: IFFALSE 102055
102049: LD_INT 9
102051: DOUBLE
102052: LESSEQUAL
102053: IFTRUE 102057
102055: GO 102109
102057: POP
// begin bc_type := b_lab_half ;
102058: LD_ADDR_OWVAR 42
102062: PUSH
102063: LD_INT 7
102065: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
102066: LD_ADDR_OWVAR 44
102070: PUSH
102071: LD_INT 10
102073: PUSH
102074: LD_INT 11
102076: PUSH
102077: LD_INT 12
102079: PUSH
102080: LD_INT 15
102082: PUSH
102083: LD_INT 14
102085: PUSH
102086: LD_INT 13
102088: PUSH
102089: EMPTY
102090: LIST
102091: LIST
102092: LIST
102093: LIST
102094: LIST
102095: LIST
102096: PUSH
102097: LD_VAR 0 2
102101: PUSH
102102: LD_INT 3
102104: MINUS
102105: ARRAY
102106: ST_TO_ADDR
// end ; 10 .. 13 :
102107: GO 102617
102109: LD_INT 10
102111: DOUBLE
102112: GREATEREQUAL
102113: IFFALSE 102121
102115: LD_INT 13
102117: DOUBLE
102118: LESSEQUAL
102119: IFTRUE 102123
102121: GO 102200
102123: POP
// begin bc_type := b_lab_full ;
102124: LD_ADDR_OWVAR 42
102128: PUSH
102129: LD_INT 8
102131: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
102132: LD_ADDR_OWVAR 44
102136: PUSH
102137: LD_INT 10
102139: PUSH
102140: LD_INT 12
102142: PUSH
102143: LD_INT 14
102145: PUSH
102146: LD_INT 13
102148: PUSH
102149: EMPTY
102150: LIST
102151: LIST
102152: LIST
102153: LIST
102154: PUSH
102155: LD_VAR 0 2
102159: PUSH
102160: LD_INT 9
102162: MINUS
102163: ARRAY
102164: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
102165: LD_ADDR_OWVAR 45
102169: PUSH
102170: LD_INT 11
102172: PUSH
102173: LD_INT 15
102175: PUSH
102176: LD_INT 12
102178: PUSH
102179: LD_INT 15
102181: PUSH
102182: EMPTY
102183: LIST
102184: LIST
102185: LIST
102186: LIST
102187: PUSH
102188: LD_VAR 0 2
102192: PUSH
102193: LD_INT 9
102195: MINUS
102196: ARRAY
102197: ST_TO_ADDR
// end ; 14 :
102198: GO 102617
102200: LD_INT 14
102202: DOUBLE
102203: EQUAL
102204: IFTRUE 102208
102206: GO 102219
102208: POP
// bc_type := b_workshop ; 15 :
102209: LD_ADDR_OWVAR 42
102213: PUSH
102214: LD_INT 2
102216: ST_TO_ADDR
102217: GO 102617
102219: LD_INT 15
102221: DOUBLE
102222: EQUAL
102223: IFTRUE 102227
102225: GO 102238
102227: POP
// bc_type := b_factory ; 16 :
102228: LD_ADDR_OWVAR 42
102232: PUSH
102233: LD_INT 3
102235: ST_TO_ADDR
102236: GO 102617
102238: LD_INT 16
102240: DOUBLE
102241: EQUAL
102242: IFTRUE 102246
102244: GO 102257
102246: POP
// bc_type := b_ext_gun ; 17 :
102247: LD_ADDR_OWVAR 42
102251: PUSH
102252: LD_INT 17
102254: ST_TO_ADDR
102255: GO 102617
102257: LD_INT 17
102259: DOUBLE
102260: EQUAL
102261: IFTRUE 102265
102263: GO 102293
102265: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
102266: LD_ADDR_OWVAR 42
102270: PUSH
102271: LD_INT 19
102273: PUSH
102274: LD_INT 23
102276: PUSH
102277: LD_INT 19
102279: PUSH
102280: EMPTY
102281: LIST
102282: LIST
102283: LIST
102284: PUSH
102285: LD_VAR 0 1
102289: ARRAY
102290: ST_TO_ADDR
102291: GO 102617
102293: LD_INT 18
102295: DOUBLE
102296: EQUAL
102297: IFTRUE 102301
102299: GO 102312
102301: POP
// bc_type := b_ext_radar ; 19 :
102302: LD_ADDR_OWVAR 42
102306: PUSH
102307: LD_INT 20
102309: ST_TO_ADDR
102310: GO 102617
102312: LD_INT 19
102314: DOUBLE
102315: EQUAL
102316: IFTRUE 102320
102318: GO 102331
102320: POP
// bc_type := b_ext_radio ; 20 :
102321: LD_ADDR_OWVAR 42
102325: PUSH
102326: LD_INT 22
102328: ST_TO_ADDR
102329: GO 102617
102331: LD_INT 20
102333: DOUBLE
102334: EQUAL
102335: IFTRUE 102339
102337: GO 102350
102339: POP
// bc_type := b_ext_siberium ; 21 :
102340: LD_ADDR_OWVAR 42
102344: PUSH
102345: LD_INT 21
102347: ST_TO_ADDR
102348: GO 102617
102350: LD_INT 21
102352: DOUBLE
102353: EQUAL
102354: IFTRUE 102358
102356: GO 102369
102358: POP
// bc_type := b_ext_computer ; 22 :
102359: LD_ADDR_OWVAR 42
102363: PUSH
102364: LD_INT 24
102366: ST_TO_ADDR
102367: GO 102617
102369: LD_INT 22
102371: DOUBLE
102372: EQUAL
102373: IFTRUE 102377
102375: GO 102388
102377: POP
// bc_type := b_ext_track ; 23 :
102378: LD_ADDR_OWVAR 42
102382: PUSH
102383: LD_INT 16
102385: ST_TO_ADDR
102386: GO 102617
102388: LD_INT 23
102390: DOUBLE
102391: EQUAL
102392: IFTRUE 102396
102394: GO 102407
102396: POP
// bc_type := b_ext_laser ; 24 :
102397: LD_ADDR_OWVAR 42
102401: PUSH
102402: LD_INT 25
102404: ST_TO_ADDR
102405: GO 102617
102407: LD_INT 24
102409: DOUBLE
102410: EQUAL
102411: IFTRUE 102415
102413: GO 102426
102415: POP
// bc_type := b_control_tower ; 25 :
102416: LD_ADDR_OWVAR 42
102420: PUSH
102421: LD_INT 36
102423: ST_TO_ADDR
102424: GO 102617
102426: LD_INT 25
102428: DOUBLE
102429: EQUAL
102430: IFTRUE 102434
102432: GO 102445
102434: POP
// bc_type := b_breastwork ; 26 :
102435: LD_ADDR_OWVAR 42
102439: PUSH
102440: LD_INT 31
102442: ST_TO_ADDR
102443: GO 102617
102445: LD_INT 26
102447: DOUBLE
102448: EQUAL
102449: IFTRUE 102453
102451: GO 102464
102453: POP
// bc_type := b_bunker ; 27 :
102454: LD_ADDR_OWVAR 42
102458: PUSH
102459: LD_INT 32
102461: ST_TO_ADDR
102462: GO 102617
102464: LD_INT 27
102466: DOUBLE
102467: EQUAL
102468: IFTRUE 102472
102470: GO 102483
102472: POP
// bc_type := b_turret ; 28 :
102473: LD_ADDR_OWVAR 42
102477: PUSH
102478: LD_INT 33
102480: ST_TO_ADDR
102481: GO 102617
102483: LD_INT 28
102485: DOUBLE
102486: EQUAL
102487: IFTRUE 102491
102489: GO 102502
102491: POP
// bc_type := b_armoury ; 29 :
102492: LD_ADDR_OWVAR 42
102496: PUSH
102497: LD_INT 4
102499: ST_TO_ADDR
102500: GO 102617
102502: LD_INT 29
102504: DOUBLE
102505: EQUAL
102506: IFTRUE 102510
102508: GO 102521
102510: POP
// bc_type := b_barracks ; 30 :
102511: LD_ADDR_OWVAR 42
102515: PUSH
102516: LD_INT 5
102518: ST_TO_ADDR
102519: GO 102617
102521: LD_INT 30
102523: DOUBLE
102524: EQUAL
102525: IFTRUE 102529
102527: GO 102540
102529: POP
// bc_type := b_solar_power ; 31 :
102530: LD_ADDR_OWVAR 42
102534: PUSH
102535: LD_INT 27
102537: ST_TO_ADDR
102538: GO 102617
102540: LD_INT 31
102542: DOUBLE
102543: EQUAL
102544: IFTRUE 102548
102546: GO 102559
102548: POP
// bc_type := b_oil_power ; 32 :
102549: LD_ADDR_OWVAR 42
102553: PUSH
102554: LD_INT 26
102556: ST_TO_ADDR
102557: GO 102617
102559: LD_INT 32
102561: DOUBLE
102562: EQUAL
102563: IFTRUE 102567
102565: GO 102578
102567: POP
// bc_type := b_siberite_power ; 33 :
102568: LD_ADDR_OWVAR 42
102572: PUSH
102573: LD_INT 28
102575: ST_TO_ADDR
102576: GO 102617
102578: LD_INT 33
102580: DOUBLE
102581: EQUAL
102582: IFTRUE 102586
102584: GO 102597
102586: POP
// bc_type := b_oil_mine ; 34 :
102587: LD_ADDR_OWVAR 42
102591: PUSH
102592: LD_INT 29
102594: ST_TO_ADDR
102595: GO 102617
102597: LD_INT 34
102599: DOUBLE
102600: EQUAL
102601: IFTRUE 102605
102603: GO 102616
102605: POP
// bc_type := b_siberite_mine ; end ;
102606: LD_ADDR_OWVAR 42
102610: PUSH
102611: LD_INT 30
102613: ST_TO_ADDR
102614: GO 102617
102616: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
102617: LD_ADDR_VAR 0 8
102621: PUSH
102622: LD_VAR 0 5
102626: PPUSH
102627: LD_VAR 0 6
102631: PPUSH
102632: LD_VAR 0 3
102636: PPUSH
102637: CALL_OW 47
102641: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
102642: LD_OWVAR 42
102646: PUSH
102647: LD_INT 32
102649: PUSH
102650: LD_INT 33
102652: PUSH
102653: EMPTY
102654: LIST
102655: LIST
102656: IN
102657: IFFALSE 102673
// PlaceWeaponTurret ( b , weapon ) ;
102659: LD_VAR 0 8
102663: PPUSH
102664: LD_VAR 0 4
102668: PPUSH
102669: CALL_OW 431
// end ;
102673: LD_VAR 0 7
102677: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
102678: LD_INT 0
102680: PPUSH
102681: PPUSH
102682: PPUSH
102683: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
102684: LD_ADDR_VAR 0 4
102688: PUSH
102689: LD_INT 22
102691: PUSH
102692: LD_OWVAR 2
102696: PUSH
102697: EMPTY
102698: LIST
102699: LIST
102700: PUSH
102701: LD_INT 2
102703: PUSH
102704: LD_INT 30
102706: PUSH
102707: LD_INT 0
102709: PUSH
102710: EMPTY
102711: LIST
102712: LIST
102713: PUSH
102714: LD_INT 30
102716: PUSH
102717: LD_INT 1
102719: PUSH
102720: EMPTY
102721: LIST
102722: LIST
102723: PUSH
102724: EMPTY
102725: LIST
102726: LIST
102727: LIST
102728: PUSH
102729: EMPTY
102730: LIST
102731: LIST
102732: PPUSH
102733: CALL_OW 69
102737: ST_TO_ADDR
// if not tmp then
102738: LD_VAR 0 4
102742: NOT
102743: IFFALSE 102747
// exit ;
102745: GO 102806
// for i in tmp do
102747: LD_ADDR_VAR 0 2
102751: PUSH
102752: LD_VAR 0 4
102756: PUSH
102757: FOR_IN
102758: IFFALSE 102804
// for j = 1 to 3 do
102760: LD_ADDR_VAR 0 3
102764: PUSH
102765: DOUBLE
102766: LD_INT 1
102768: DEC
102769: ST_TO_ADDR
102770: LD_INT 3
102772: PUSH
102773: FOR_TO
102774: IFFALSE 102800
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
102776: LD_VAR 0 2
102780: PPUSH
102781: CALL_OW 274
102785: PPUSH
102786: LD_VAR 0 3
102790: PPUSH
102791: LD_INT 99999
102793: PPUSH
102794: CALL_OW 277
102798: GO 102773
102800: POP
102801: POP
102802: GO 102757
102804: POP
102805: POP
// end ;
102806: LD_VAR 0 1
102810: RET
// export function hHackSetLevel10 ; var i , j ; begin
102811: LD_INT 0
102813: PPUSH
102814: PPUSH
102815: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
102816: LD_ADDR_VAR 0 2
102820: PUSH
102821: LD_INT 21
102823: PUSH
102824: LD_INT 1
102826: PUSH
102827: EMPTY
102828: LIST
102829: LIST
102830: PPUSH
102831: CALL_OW 69
102835: PUSH
102836: FOR_IN
102837: IFFALSE 102889
// if IsSelected ( i ) then
102839: LD_VAR 0 2
102843: PPUSH
102844: CALL_OW 306
102848: IFFALSE 102887
// begin for j := 1 to 4 do
102850: LD_ADDR_VAR 0 3
102854: PUSH
102855: DOUBLE
102856: LD_INT 1
102858: DEC
102859: ST_TO_ADDR
102860: LD_INT 4
102862: PUSH
102863: FOR_TO
102864: IFFALSE 102885
// SetSkill ( i , j , 10 ) ;
102866: LD_VAR 0 2
102870: PPUSH
102871: LD_VAR 0 3
102875: PPUSH
102876: LD_INT 10
102878: PPUSH
102879: CALL_OW 237
102883: GO 102863
102885: POP
102886: POP
// end ;
102887: GO 102836
102889: POP
102890: POP
// end ;
102891: LD_VAR 0 1
102895: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
102896: LD_INT 0
102898: PPUSH
102899: PPUSH
102900: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
102901: LD_ADDR_VAR 0 2
102905: PUSH
102906: LD_INT 22
102908: PUSH
102909: LD_OWVAR 2
102913: PUSH
102914: EMPTY
102915: LIST
102916: LIST
102917: PUSH
102918: LD_INT 21
102920: PUSH
102921: LD_INT 1
102923: PUSH
102924: EMPTY
102925: LIST
102926: LIST
102927: PUSH
102928: EMPTY
102929: LIST
102930: LIST
102931: PPUSH
102932: CALL_OW 69
102936: PUSH
102937: FOR_IN
102938: IFFALSE 102979
// begin for j := 1 to 4 do
102940: LD_ADDR_VAR 0 3
102944: PUSH
102945: DOUBLE
102946: LD_INT 1
102948: DEC
102949: ST_TO_ADDR
102950: LD_INT 4
102952: PUSH
102953: FOR_TO
102954: IFFALSE 102975
// SetSkill ( i , j , 10 ) ;
102956: LD_VAR 0 2
102960: PPUSH
102961: LD_VAR 0 3
102965: PPUSH
102966: LD_INT 10
102968: PPUSH
102969: CALL_OW 237
102973: GO 102953
102975: POP
102976: POP
// end ;
102977: GO 102937
102979: POP
102980: POP
// end ;
102981: LD_VAR 0 1
102985: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
102986: LD_INT 0
102988: PPUSH
// uc_side := your_side ;
102989: LD_ADDR_OWVAR 20
102993: PUSH
102994: LD_OWVAR 2
102998: ST_TO_ADDR
// uc_nation := nation ;
102999: LD_ADDR_OWVAR 21
103003: PUSH
103004: LD_VAR 0 1
103008: ST_TO_ADDR
// InitHc ;
103009: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
103013: LD_INT 0
103015: PPUSH
103016: LD_VAR 0 2
103020: PPUSH
103021: LD_VAR 0 3
103025: PPUSH
103026: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
103030: LD_VAR 0 4
103034: PPUSH
103035: LD_VAR 0 5
103039: PPUSH
103040: CALL_OW 428
103044: PUSH
103045: LD_INT 0
103047: EQUAL
103048: IFFALSE 103072
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
103050: CALL_OW 44
103054: PPUSH
103055: LD_VAR 0 4
103059: PPUSH
103060: LD_VAR 0 5
103064: PPUSH
103065: LD_INT 1
103067: PPUSH
103068: CALL_OW 48
// end ;
103072: LD_VAR 0 6
103076: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
103077: LD_INT 0
103079: PPUSH
103080: PPUSH
// uc_side := your_side ;
103081: LD_ADDR_OWVAR 20
103085: PUSH
103086: LD_OWVAR 2
103090: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
103091: LD_VAR 0 1
103095: PUSH
103096: LD_INT 1
103098: PUSH
103099: LD_INT 2
103101: PUSH
103102: LD_INT 3
103104: PUSH
103105: LD_INT 4
103107: PUSH
103108: LD_INT 5
103110: PUSH
103111: EMPTY
103112: LIST
103113: LIST
103114: LIST
103115: LIST
103116: LIST
103117: IN
103118: IFFALSE 103130
// uc_nation := nation_american else
103120: LD_ADDR_OWVAR 21
103124: PUSH
103125: LD_INT 1
103127: ST_TO_ADDR
103128: GO 103173
// if chassis in [ 11 , 12 , 13 , 14 ] then
103130: LD_VAR 0 1
103134: PUSH
103135: LD_INT 11
103137: PUSH
103138: LD_INT 12
103140: PUSH
103141: LD_INT 13
103143: PUSH
103144: LD_INT 14
103146: PUSH
103147: EMPTY
103148: LIST
103149: LIST
103150: LIST
103151: LIST
103152: IN
103153: IFFALSE 103165
// uc_nation := nation_arabian else
103155: LD_ADDR_OWVAR 21
103159: PUSH
103160: LD_INT 2
103162: ST_TO_ADDR
103163: GO 103173
// uc_nation := nation_russian ;
103165: LD_ADDR_OWVAR 21
103169: PUSH
103170: LD_INT 3
103172: ST_TO_ADDR
// vc_chassis := chassis ;
103173: LD_ADDR_OWVAR 37
103177: PUSH
103178: LD_VAR 0 1
103182: ST_TO_ADDR
// vc_engine := engine ;
103183: LD_ADDR_OWVAR 39
103187: PUSH
103188: LD_VAR 0 2
103192: ST_TO_ADDR
// vc_control := control ;
103193: LD_ADDR_OWVAR 38
103197: PUSH
103198: LD_VAR 0 3
103202: ST_TO_ADDR
// vc_weapon := weapon ;
103203: LD_ADDR_OWVAR 40
103207: PUSH
103208: LD_VAR 0 4
103212: ST_TO_ADDR
// un := CreateVehicle ;
103213: LD_ADDR_VAR 0 8
103217: PUSH
103218: CALL_OW 45
103222: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
103223: LD_VAR 0 8
103227: PPUSH
103228: LD_INT 0
103230: PPUSH
103231: LD_INT 5
103233: PPUSH
103234: CALL_OW 12
103238: PPUSH
103239: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
103243: LD_VAR 0 8
103247: PPUSH
103248: LD_VAR 0 5
103252: PPUSH
103253: LD_VAR 0 6
103257: PPUSH
103258: LD_INT 1
103260: PPUSH
103261: CALL_OW 48
// end ;
103265: LD_VAR 0 7
103269: RET
// export hInvincible ; every 1 do
103270: GO 103272
103272: DISABLE
// hInvincible := [ ] ;
103273: LD_ADDR_EXP 152
103277: PUSH
103278: EMPTY
103279: ST_TO_ADDR
103280: END
// every 10 do var i ;
103281: GO 103283
103283: DISABLE
103284: LD_INT 0
103286: PPUSH
// begin enable ;
103287: ENABLE
// if not hInvincible then
103288: LD_EXP 152
103292: NOT
103293: IFFALSE 103297
// exit ;
103295: GO 103341
// for i in hInvincible do
103297: LD_ADDR_VAR 0 1
103301: PUSH
103302: LD_EXP 152
103306: PUSH
103307: FOR_IN
103308: IFFALSE 103339
// if GetLives ( i ) < 1000 then
103310: LD_VAR 0 1
103314: PPUSH
103315: CALL_OW 256
103319: PUSH
103320: LD_INT 1000
103322: LESS
103323: IFFALSE 103337
// SetLives ( i , 1000 ) ;
103325: LD_VAR 0 1
103329: PPUSH
103330: LD_INT 1000
103332: PPUSH
103333: CALL_OW 234
103337: GO 103307
103339: POP
103340: POP
// end ;
103341: PPOPN 1
103343: END
// export function hHackInvincible ; var i ; begin
103344: LD_INT 0
103346: PPUSH
103347: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
103348: LD_ADDR_VAR 0 2
103352: PUSH
103353: LD_INT 2
103355: PUSH
103356: LD_INT 21
103358: PUSH
103359: LD_INT 1
103361: PUSH
103362: EMPTY
103363: LIST
103364: LIST
103365: PUSH
103366: LD_INT 21
103368: PUSH
103369: LD_INT 2
103371: PUSH
103372: EMPTY
103373: LIST
103374: LIST
103375: PUSH
103376: EMPTY
103377: LIST
103378: LIST
103379: LIST
103380: PPUSH
103381: CALL_OW 69
103385: PUSH
103386: FOR_IN
103387: IFFALSE 103448
// if IsSelected ( i ) then
103389: LD_VAR 0 2
103393: PPUSH
103394: CALL_OW 306
103398: IFFALSE 103446
// begin if i in hInvincible then
103400: LD_VAR 0 2
103404: PUSH
103405: LD_EXP 152
103409: IN
103410: IFFALSE 103430
// hInvincible := hInvincible diff i else
103412: LD_ADDR_EXP 152
103416: PUSH
103417: LD_EXP 152
103421: PUSH
103422: LD_VAR 0 2
103426: DIFF
103427: ST_TO_ADDR
103428: GO 103446
// hInvincible := hInvincible union i ;
103430: LD_ADDR_EXP 152
103434: PUSH
103435: LD_EXP 152
103439: PUSH
103440: LD_VAR 0 2
103444: UNION
103445: ST_TO_ADDR
// end ;
103446: GO 103386
103448: POP
103449: POP
// end ;
103450: LD_VAR 0 1
103454: RET
// export function hHackInvisible ; var i , j ; begin
103455: LD_INT 0
103457: PPUSH
103458: PPUSH
103459: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
103460: LD_ADDR_VAR 0 2
103464: PUSH
103465: LD_INT 21
103467: PUSH
103468: LD_INT 1
103470: PUSH
103471: EMPTY
103472: LIST
103473: LIST
103474: PPUSH
103475: CALL_OW 69
103479: PUSH
103480: FOR_IN
103481: IFFALSE 103505
// if IsSelected ( i ) then
103483: LD_VAR 0 2
103487: PPUSH
103488: CALL_OW 306
103492: IFFALSE 103503
// ComForceInvisible ( i ) ;
103494: LD_VAR 0 2
103498: PPUSH
103499: CALL_OW 496
103503: GO 103480
103505: POP
103506: POP
// end ;
103507: LD_VAR 0 1
103511: RET
// export function hHackChangeYourSide ; begin
103512: LD_INT 0
103514: PPUSH
// if your_side = 8 then
103515: LD_OWVAR 2
103519: PUSH
103520: LD_INT 8
103522: EQUAL
103523: IFFALSE 103535
// your_side := 0 else
103525: LD_ADDR_OWVAR 2
103529: PUSH
103530: LD_INT 0
103532: ST_TO_ADDR
103533: GO 103549
// your_side := your_side + 1 ;
103535: LD_ADDR_OWVAR 2
103539: PUSH
103540: LD_OWVAR 2
103544: PUSH
103545: LD_INT 1
103547: PLUS
103548: ST_TO_ADDR
// end ;
103549: LD_VAR 0 1
103553: RET
// export function hHackChangeUnitSide ; var i , j ; begin
103554: LD_INT 0
103556: PPUSH
103557: PPUSH
103558: PPUSH
// for i in all_units do
103559: LD_ADDR_VAR 0 2
103563: PUSH
103564: LD_OWVAR 3
103568: PUSH
103569: FOR_IN
103570: IFFALSE 103648
// if IsSelected ( i ) then
103572: LD_VAR 0 2
103576: PPUSH
103577: CALL_OW 306
103581: IFFALSE 103646
// begin j := GetSide ( i ) ;
103583: LD_ADDR_VAR 0 3
103587: PUSH
103588: LD_VAR 0 2
103592: PPUSH
103593: CALL_OW 255
103597: ST_TO_ADDR
// if j = 8 then
103598: LD_VAR 0 3
103602: PUSH
103603: LD_INT 8
103605: EQUAL
103606: IFFALSE 103618
// j := 0 else
103608: LD_ADDR_VAR 0 3
103612: PUSH
103613: LD_INT 0
103615: ST_TO_ADDR
103616: GO 103632
// j := j + 1 ;
103618: LD_ADDR_VAR 0 3
103622: PUSH
103623: LD_VAR 0 3
103627: PUSH
103628: LD_INT 1
103630: PLUS
103631: ST_TO_ADDR
// SetSide ( i , j ) ;
103632: LD_VAR 0 2
103636: PPUSH
103637: LD_VAR 0 3
103641: PPUSH
103642: CALL_OW 235
// end ;
103646: GO 103569
103648: POP
103649: POP
// end ;
103650: LD_VAR 0 1
103654: RET
// export function hHackFog ; begin
103655: LD_INT 0
103657: PPUSH
// FogOff ( true ) ;
103658: LD_INT 1
103660: PPUSH
103661: CALL_OW 344
// end ;
103665: LD_VAR 0 1
103669: RET
// export function hHackTeleport ( unit , x , y ) ; begin
103670: LD_INT 0
103672: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
103673: LD_VAR 0 1
103677: PPUSH
103678: LD_VAR 0 2
103682: PPUSH
103683: LD_VAR 0 3
103687: PPUSH
103688: LD_INT 1
103690: PPUSH
103691: LD_INT 1
103693: PPUSH
103694: CALL_OW 483
// CenterOnXY ( x , y ) ;
103698: LD_VAR 0 2
103702: PPUSH
103703: LD_VAR 0 3
103707: PPUSH
103708: CALL_OW 84
// end ; end_of_file
103712: LD_VAR 0 4
103716: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
103717: LD_VAR 0 1
103721: PPUSH
103722: LD_VAR 0 2
103726: PPUSH
103727: LD_VAR 0 3
103731: PPUSH
103732: LD_VAR 0 4
103736: PPUSH
103737: LD_VAR 0 5
103741: PPUSH
103742: LD_VAR 0 6
103746: PPUSH
103747: CALL 90545 0 6
// end ;
103751: PPOPN 6
103753: END
