// starting begin ResetFog ;
   0: CALL_OW 335
// InitVariables ;
   4: CALL 180 0 0
// if debug then
   8: LD_EXP 1
  12: IFFALSE 21
// begin FogOff ( 1 ) ;
  14: LD_INT 1
  16: PPUSH
  17: CALL_OW 344
// end ; ChangeSideFog ( 4 , 1 ) ;
  21: LD_INT 4
  23: PPUSH
  24: LD_INT 1
  26: PPUSH
  27: CALL_OW 343
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , gensher_ape , 0 ) ;
  31: LD_INT 0
  33: PPUSH
  34: LD_INT 0
  36: PPUSH
  37: LD_INT 3
  39: PPUSH
  40: LD_INT 0
  42: PPUSH
  43: LD_INT 0
  45: PPUSH
  46: LD_INT 0
  48: PPUSH
  49: LD_INT 0
  51: PPUSH
  52: LD_INT 7
  54: PPUSH
  55: LD_INT 0
  57: PPUSH
  58: CALL 37096 0 9
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , powell_ape , 0 ) ;
  62: LD_INT 0
  64: PPUSH
  65: LD_INT 0
  67: PPUSH
  68: LD_INT 3
  70: PPUSH
  71: LD_INT 0
  73: PPUSH
  74: LD_INT 0
  76: PPUSH
  77: LD_INT 0
  79: PPUSH
  80: LD_INT 0
  82: PPUSH
  83: LD_INT 4
  85: PPUSH
  86: LD_INT 0
  88: PPUSH
  89: CALL 37096 0 9
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , popov_ape , 0 ) ;
  93: LD_INT 0
  95: PPUSH
  96: LD_INT 0
  98: PPUSH
  99: LD_INT 3
 101: PPUSH
 102: LD_INT 0
 104: PPUSH
 105: LD_INT 0
 107: PPUSH
 108: LD_INT 0
 110: PPUSH
 111: LD_INT 0
 113: PPUSH
 114: LD_INT 11
 116: PPUSH
 117: LD_INT 0
 119: PPUSH
 120: CALL 37096 0 9
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , sikorski_ape , 0 ) ;
 124: LD_INT 0
 126: PPUSH
 127: LD_INT 0
 129: PPUSH
 130: LD_INT 3
 132: PPUSH
 133: LD_INT 0
 135: PPUSH
 136: LD_INT 0
 138: PPUSH
 139: LD_INT 0
 141: PPUSH
 142: LD_INT 0
 144: PPUSH
 145: LD_INT 14
 147: PPUSH
 148: LD_INT 0
 150: PPUSH
 151: CALL 37096 0 9
// PrepareGensher ;
 155: CALL 1331 0 0
// PreparePopov ;
 159: CALL 2581 0 0
// PreparePowell ;
 163: CALL 394 0 0
// PrepareSikorski ;
 167: CALL 3705 0 0
// MC_Start ( ) ;
 171: CALL 43405 0 0
// Action ;
 175: CALL 4112 0 0
// end ;
 179: END
// export debug , game , staticMines ; function InitVariables ; begin
 180: LD_INT 0
 182: PPUSH
// debug := false ;
 183: LD_ADDR_EXP 1
 187: PUSH
 188: LD_INT 0
 190: ST_TO_ADDR
// game := true ;
 191: LD_ADDR_EXP 2
 195: PUSH
 196: LD_INT 1
 198: ST_TO_ADDR
// staticMines := [ ] ;
 199: LD_ADDR_EXP 3
 203: PUSH
 204: EMPTY
 205: ST_TO_ADDR
// end ;
 206: LD_VAR 0 1
 210: RET
// export function CustomInitMacro ; begin
 211: LD_INT 0
 213: PPUSH
// InitMC_Gensher ( ) ;
 214: CALL 1719 0 0
// InitMC_Powell ( ) ;
 218: CALL 609 0 0
// InitMC_Popov ( ) ;
 222: CALL 2907 0 0
// end ;
 226: LD_VAR 0 1
 230: RET
// every 0 0$10 do var cr , time , i ;
 231: GO 233
 233: DISABLE
 234: LD_INT 0
 236: PPUSH
 237: PPUSH
 238: PPUSH
// begin time := 0 0$30 ;
 239: LD_ADDR_VAR 0 2
 243: PUSH
 244: LD_INT 1050
 246: ST_TO_ADDR
// repeat wait ( time ) ;
 247: LD_VAR 0 2
 251: PPUSH
 252: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
 256: LD_ADDR_VAR 0 1
 260: PUSH
 261: LD_INT 1
 263: PPUSH
 264: LD_INT 5
 266: PPUSH
 267: CALL_OW 12
 271: ST_TO_ADDR
// for i in [ powell_crates , gensher_crates , popov_crates , sikorski_crates ] do
 272: LD_ADDR_VAR 0 3
 276: PUSH
 277: LD_INT 5
 279: PUSH
 280: LD_INT 8
 282: PUSH
 283: LD_INT 12
 285: PUSH
 286: LD_INT 13
 288: PUSH
 289: EMPTY
 290: LIST
 291: LIST
 292: LIST
 293: LIST
 294: PUSH
 295: FOR_IN
 296: IFFALSE 350
// begin if GetResourceArea ( i , mat_cans ) < 20 then
 298: LD_VAR 0 3
 302: PPUSH
 303: LD_INT 1
 305: PPUSH
 306: CALL_OW 287
 310: PUSH
 311: LD_INT 20
 313: LESS
 314: IFFALSE 333
// CreateCratesArea ( cr , i , true ) ;
 316: LD_VAR 0 1
 320: PPUSH
 321: LD_VAR 0 3
 325: PPUSH
 326: LD_INT 1
 328: PPUSH
 329: CALL_OW 55
// wait ( rand ( 0 0$5 , 0 0$20 ) ) ;
 333: LD_INT 175
 335: PPUSH
 336: LD_INT 700
 338: PPUSH
 339: CALL_OW 12
 343: PPUSH
 344: CALL_OW 67
// end ;
 348: GO 295
 350: POP
 351: POP
// time := time + 0 0$2 ;
 352: LD_ADDR_VAR 0 2
 356: PUSH
 357: LD_VAR 0 2
 361: PUSH
 362: LD_INT 70
 364: PLUS
 365: ST_TO_ADDR
// if time > 1 1$00 then
 366: LD_VAR 0 2
 370: PUSH
 371: LD_INT 2100
 373: GREATER
 374: IFFALSE 384
// time := 0 0$25 ;
 376: LD_ADDR_VAR 0 2
 380: PUSH
 381: LD_INT 875
 383: ST_TO_ADDR
// until not game ;
 384: LD_EXP 2
 388: NOT
 389: IFFALSE 247
// end ; end_of_file
 391: PPOPN 3
 393: END
// export Powell , powell_side ; export function PreparePowell ; var i , tmp ; begin
 394: LD_INT 0
 396: PPUSH
 397: PPUSH
 398: PPUSH
// powell_side := 4 ;
 399: LD_ADDR_EXP 5
 403: PUSH
 404: LD_INT 4
 406: ST_TO_ADDR
// uc_side := powell_side ;
 407: LD_ADDR_OWVAR 20
 411: PUSH
 412: LD_EXP 5
 416: ST_TO_ADDR
// uc_nation := 1 ;
 417: LD_ADDR_OWVAR 21
 421: PUSH
 422: LD_INT 1
 424: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
 425: LD_ADDR_EXP 4
 429: PUSH
 430: LD_STRING Powell
 432: PPUSH
 433: CALL_OW 25
 437: ST_TO_ADDR
// SetSkill ( Powell , 1 , 7 ) ;
 438: LD_EXP 4
 442: PPUSH
 443: LD_INT 1
 445: PPUSH
 446: LD_INT 7
 448: PPUSH
 449: CALL_OW 237
// SetSkill ( Powell , 2 , 5 ) ;
 453: LD_EXP 4
 457: PPUSH
 458: LD_INT 2
 460: PPUSH
 461: LD_INT 5
 463: PPUSH
 464: CALL_OW 237
// SetSkill ( Powell , 3 , 6 ) ;
 468: LD_EXP 4
 472: PPUSH
 473: LD_INT 3
 475: PPUSH
 476: LD_INT 6
 478: PPUSH
 479: CALL_OW 237
// SetSkill ( Powell , 4 , 4 ) ;
 483: LD_EXP 4
 487: PPUSH
 488: LD_INT 4
 490: PPUSH
 491: LD_INT 4
 493: PPUSH
 494: CALL_OW 237
// PlaceHumanInUnit ( Powell , us_depot ) ;
 498: LD_EXP 4
 502: PPUSH
 503: LD_INT 4
 505: PPUSH
 506: CALL_OW 52
// tmp := PrepareBase ( us_depot , powell_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 1000 , 100 , 0 ] , [ 4 , 4 , 4 , 4 ] ) ;
 510: LD_ADDR_VAR 0 3
 514: PUSH
 515: LD_INT 4
 517: PPUSH
 518: LD_INT 1
 520: PPUSH
 521: LD_STRING 
 523: PPUSH
 524: LD_INT 8
 526: PUSH
 527: LD_INT 7
 529: PUSH
 530: LD_INT 6
 532: PUSH
 533: EMPTY
 534: LIST
 535: LIST
 536: LIST
 537: PUSH
 538: LD_OWVAR 67
 542: ARRAY
 543: PPUSH
 544: LD_INT 1000
 546: PUSH
 547: LD_INT 100
 549: PUSH
 550: LD_INT 0
 552: PUSH
 553: EMPTY
 554: LIST
 555: LIST
 556: LIST
 557: PPUSH
 558: LD_INT 4
 560: PUSH
 561: LD_INT 4
 563: PUSH
 564: LD_INT 4
 566: PUSH
 567: LD_INT 4
 569: PUSH
 570: EMPTY
 571: LIST
 572: LIST
 573: LIST
 574: LIST
 575: PPUSH
 576: CALL 12714 0 6
 580: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , tmp ) ;
 581: LD_ADDR_EXP 14
 585: PUSH
 586: LD_EXP 14
 590: PPUSH
 591: LD_INT 1
 593: PPUSH
 594: LD_VAR 0 3
 598: PPUSH
 599: CALL_OW 1
 603: ST_TO_ADDR
// end ;
 604: LD_VAR 0 1
 608: RET
// export function InitMC_Powell ( ) ; begin
 609: LD_INT 0
 611: PPUSH
// MC_SetScanArea ( 1 , powell_base ) ;
 612: LD_INT 1
 614: PPUSH
 615: LD_INT 1
 617: PPUSH
 618: CALL 66245 0 2
// MC_SetParkingArea ( 1 , powell_parking ) ;
 622: LD_INT 1
 624: PPUSH
 625: LD_INT 6
 627: PPUSH
 628: CALL 66189 0 2
// MC_SetDepositsXY ( 1 , [ [ 167 , 102 , 0 ] , [ 173 , 83 , 1 ] , [ 171 , 141 , 0 ] , [ 178 , 148 , 1 ] ] ) ;
 632: LD_INT 1
 634: PPUSH
 635: LD_INT 167
 637: PUSH
 638: LD_INT 102
 640: PUSH
 641: LD_INT 0
 643: PUSH
 644: EMPTY
 645: LIST
 646: LIST
 647: LIST
 648: PUSH
 649: LD_INT 173
 651: PUSH
 652: LD_INT 83
 654: PUSH
 655: LD_INT 1
 657: PUSH
 658: EMPTY
 659: LIST
 660: LIST
 661: LIST
 662: PUSH
 663: LD_INT 171
 665: PUSH
 666: LD_INT 141
 668: PUSH
 669: LD_INT 0
 671: PUSH
 672: EMPTY
 673: LIST
 674: LIST
 675: LIST
 676: PUSH
 677: LD_INT 178
 679: PUSH
 680: LD_INT 148
 682: PUSH
 683: LD_INT 1
 685: PUSH
 686: EMPTY
 687: LIST
 688: LIST
 689: LIST
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PPUSH
 697: CALL 65248 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ us_radar , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
 701: LD_INT 1
 703: PPUSH
 704: LD_INT 11
 706: PUSH
 707: LD_INT 6
 709: PUSH
 710: LD_INT 7
 712: PUSH
 713: LD_INT 9
 715: PUSH
 716: LD_INT 10
 718: PUSH
 719: EMPTY
 720: LIST
 721: LIST
 722: LIST
 723: LIST
 724: LIST
 725: PPUSH
 726: CALL 66077 0 2
// MC_SetCratesArea ( 1 , powell_crates ) ;
 730: LD_INT 1
 732: PPUSH
 733: LD_INT 5
 735: PPUSH
 736: CALL 65759 0 2
// MC_SetTame ( 1 , powell_ape ) ;
 740: LD_INT 1
 742: PPUSH
 743: LD_INT 4
 745: PPUSH
 746: CALL 65490 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 750: LD_INT 1
 752: PPUSH
 753: LD_INT 4
 755: PPUSH
 756: CALL 65109 0 2
// MC_SetProduceList ( 1 , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] ] ) ;
 760: LD_INT 1
 762: PPUSH
 763: LD_INT 3
 765: PUSH
 766: LD_INT 1
 768: PUSH
 769: LD_INT 2
 771: PUSH
 772: LD_INT 5
 774: PUSH
 775: EMPTY
 776: LIST
 777: LIST
 778: LIST
 779: LIST
 780: PUSH
 781: LD_INT 4
 783: PUSH
 784: LD_INT 1
 786: PUSH
 787: LD_INT 2
 789: PUSH
 790: LD_INT 6
 792: PUSH
 793: EMPTY
 794: LIST
 795: LIST
 796: LIST
 797: LIST
 798: PUSH
 799: LD_INT 4
 801: PUSH
 802: LD_INT 1
 804: PUSH
 805: LD_INT 2
 807: PUSH
 808: LD_INT 7
 810: PUSH
 811: EMPTY
 812: LIST
 813: LIST
 814: LIST
 815: LIST
 816: PUSH
 817: LD_INT 4
 819: PUSH
 820: LD_INT 1
 822: PUSH
 823: LD_INT 2
 825: PUSH
 826: LD_INT 6
 828: PUSH
 829: EMPTY
 830: LIST
 831: LIST
 832: LIST
 833: LIST
 834: PUSH
 835: LD_INT 5
 837: PUSH
 838: LD_INT 1
 840: PUSH
 841: LD_INT 2
 843: PUSH
 844: LD_INT 6
 846: PUSH
 847: EMPTY
 848: LIST
 849: LIST
 850: LIST
 851: LIST
 852: PUSH
 853: EMPTY
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: LIST
 859: PPUSH
 860: CALL 64924 0 2
// MC_SetBuildingList ( 1 , [ [ b_lab , 200 , 111 , 4 ] , [ b_oil_mine , 167 , 102 , 0 ] , [ b_armoury , 178 , 117 , 2 ] , [ b_workshop , 197 , 144 , 4 ] , [ b_solar_power , 206 , 124 , 3 ] , [ b_solar_power , 209 , 128 , 3 ] , [ b_solar_power , 211 , 132 , 3 ] , [ b_siberite_mine , 173 , 83 , 3 ] , [ b_lab , 186 , 103 , 2 ] , [ b_turret , 173 , 99 , 2 ] , [ b_bunker , 174 , 102 , 2 ] , [ b_bunker , 178 , 100 , 2 ] , [ b_turret , 174 , 108 , 1 ] , [ b_turret , 182 , 122 , 1 ] , [ b_control_tower , 194 , 124 , 5 ] , [ b_siberite_power , 204 , 133 , 3 ] , [ b_solar_power , 201 , 133 , 3 ] , [ b_siberite_power , 199 , 119 , 5 ] , [ b_turret , 184 , 141 , 1 ] , [ b_turret , 183 , 131 , 2 ] ] ) ;
 864: LD_INT 1
 866: PPUSH
 867: LD_INT 6
 869: PUSH
 870: LD_INT 200
 872: PUSH
 873: LD_INT 111
 875: PUSH
 876: LD_INT 4
 878: PUSH
 879: EMPTY
 880: LIST
 881: LIST
 882: LIST
 883: LIST
 884: PUSH
 885: LD_INT 29
 887: PUSH
 888: LD_INT 167
 890: PUSH
 891: LD_INT 102
 893: PUSH
 894: LD_INT 0
 896: PUSH
 897: EMPTY
 898: LIST
 899: LIST
 900: LIST
 901: LIST
 902: PUSH
 903: LD_INT 4
 905: PUSH
 906: LD_INT 178
 908: PUSH
 909: LD_INT 117
 911: PUSH
 912: LD_INT 2
 914: PUSH
 915: EMPTY
 916: LIST
 917: LIST
 918: LIST
 919: LIST
 920: PUSH
 921: LD_INT 2
 923: PUSH
 924: LD_INT 197
 926: PUSH
 927: LD_INT 144
 929: PUSH
 930: LD_INT 4
 932: PUSH
 933: EMPTY
 934: LIST
 935: LIST
 936: LIST
 937: LIST
 938: PUSH
 939: LD_INT 27
 941: PUSH
 942: LD_INT 206
 944: PUSH
 945: LD_INT 124
 947: PUSH
 948: LD_INT 3
 950: PUSH
 951: EMPTY
 952: LIST
 953: LIST
 954: LIST
 955: LIST
 956: PUSH
 957: LD_INT 27
 959: PUSH
 960: LD_INT 209
 962: PUSH
 963: LD_INT 128
 965: PUSH
 966: LD_INT 3
 968: PUSH
 969: EMPTY
 970: LIST
 971: LIST
 972: LIST
 973: LIST
 974: PUSH
 975: LD_INT 27
 977: PUSH
 978: LD_INT 211
 980: PUSH
 981: LD_INT 132
 983: PUSH
 984: LD_INT 3
 986: PUSH
 987: EMPTY
 988: LIST
 989: LIST
 990: LIST
 991: LIST
 992: PUSH
 993: LD_INT 30
 995: PUSH
 996: LD_INT 173
 998: PUSH
 999: LD_INT 83
1001: PUSH
1002: LD_INT 3
1004: PUSH
1005: EMPTY
1006: LIST
1007: LIST
1008: LIST
1009: LIST
1010: PUSH
1011: LD_INT 6
1013: PUSH
1014: LD_INT 186
1016: PUSH
1017: LD_INT 103
1019: PUSH
1020: LD_INT 2
1022: PUSH
1023: EMPTY
1024: LIST
1025: LIST
1026: LIST
1027: LIST
1028: PUSH
1029: LD_INT 33
1031: PUSH
1032: LD_INT 173
1034: PUSH
1035: LD_INT 99
1037: PUSH
1038: LD_INT 2
1040: PUSH
1041: EMPTY
1042: LIST
1043: LIST
1044: LIST
1045: LIST
1046: PUSH
1047: LD_INT 32
1049: PUSH
1050: LD_INT 174
1052: PUSH
1053: LD_INT 102
1055: PUSH
1056: LD_INT 2
1058: PUSH
1059: EMPTY
1060: LIST
1061: LIST
1062: LIST
1063: LIST
1064: PUSH
1065: LD_INT 32
1067: PUSH
1068: LD_INT 178
1070: PUSH
1071: LD_INT 100
1073: PUSH
1074: LD_INT 2
1076: PUSH
1077: EMPTY
1078: LIST
1079: LIST
1080: LIST
1081: LIST
1082: PUSH
1083: LD_INT 33
1085: PUSH
1086: LD_INT 174
1088: PUSH
1089: LD_INT 108
1091: PUSH
1092: LD_INT 1
1094: PUSH
1095: EMPTY
1096: LIST
1097: LIST
1098: LIST
1099: LIST
1100: PUSH
1101: LD_INT 33
1103: PUSH
1104: LD_INT 182
1106: PUSH
1107: LD_INT 122
1109: PUSH
1110: LD_INT 1
1112: PUSH
1113: EMPTY
1114: LIST
1115: LIST
1116: LIST
1117: LIST
1118: PUSH
1119: LD_INT 36
1121: PUSH
1122: LD_INT 194
1124: PUSH
1125: LD_INT 124
1127: PUSH
1128: LD_INT 5
1130: PUSH
1131: EMPTY
1132: LIST
1133: LIST
1134: LIST
1135: LIST
1136: PUSH
1137: LD_INT 28
1139: PUSH
1140: LD_INT 204
1142: PUSH
1143: LD_INT 133
1145: PUSH
1146: LD_INT 3
1148: PUSH
1149: EMPTY
1150: LIST
1151: LIST
1152: LIST
1153: LIST
1154: PUSH
1155: LD_INT 27
1157: PUSH
1158: LD_INT 201
1160: PUSH
1161: LD_INT 133
1163: PUSH
1164: LD_INT 3
1166: PUSH
1167: EMPTY
1168: LIST
1169: LIST
1170: LIST
1171: LIST
1172: PUSH
1173: LD_INT 28
1175: PUSH
1176: LD_INT 199
1178: PUSH
1179: LD_INT 119
1181: PUSH
1182: LD_INT 5
1184: PUSH
1185: EMPTY
1186: LIST
1187: LIST
1188: LIST
1189: LIST
1190: PUSH
1191: LD_INT 33
1193: PUSH
1194: LD_INT 184
1196: PUSH
1197: LD_INT 141
1199: PUSH
1200: LD_INT 1
1202: PUSH
1203: EMPTY
1204: LIST
1205: LIST
1206: LIST
1207: LIST
1208: PUSH
1209: LD_INT 33
1211: PUSH
1212: LD_INT 183
1214: PUSH
1215: LD_INT 131
1217: PUSH
1218: LD_INT 2
1220: PUSH
1221: EMPTY
1222: LIST
1223: LIST
1224: LIST
1225: LIST
1226: PUSH
1227: EMPTY
1228: LIST
1229: LIST
1230: LIST
1231: LIST
1232: LIST
1233: LIST
1234: LIST
1235: LIST
1236: LIST
1237: LIST
1238: LIST
1239: LIST
1240: LIST
1241: LIST
1242: LIST
1243: LIST
1244: LIST
1245: LIST
1246: LIST
1247: LIST
1248: PPUSH
1249: CALL 64816 0 2
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_opto , b_lab_computer , b_lab_siberium ] ) ;
1253: LD_INT 1
1255: PPUSH
1256: LD_INT 10
1258: PUSH
1259: LD_INT 15
1261: PUSH
1262: LD_INT 12
1264: PUSH
1265: LD_INT 11
1267: PUSH
1268: EMPTY
1269: LIST
1270: LIST
1271: LIST
1272: LIST
1273: PPUSH
1274: CALL 65666 0 2
// MC_SetFactoryExtension ( 1 , 197 , 144 , 4 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1278: LD_INT 1
1280: PPUSH
1281: LD_INT 197
1283: PPUSH
1284: LD_INT 144
1286: PPUSH
1287: LD_INT 4
1289: PPUSH
1290: LD_INT 19
1292: PUSH
1293: LD_INT 16
1295: PUSH
1296: LD_INT 17
1298: PUSH
1299: LD_INT 18
1301: PUSH
1302: LD_INT 22
1304: PUSH
1305: EMPTY
1306: LIST
1307: LIST
1308: LIST
1309: LIST
1310: LIST
1311: PPUSH
1312: CALL 65871 0 5
// MC_SetUpgradeBuilding ( 1 , b_depot ) ;
1316: LD_INT 1
1318: PPUSH
1319: LD_INT 0
1321: PPUSH
1322: CALL 65539 0 2
// end ; end_of_file
1326: LD_VAR 0 1
1330: RET
// export Gensher , gensher_side ; export function PrepareGensher ; var i , tmp , un ; begin
1331: LD_INT 0
1333: PPUSH
1334: PPUSH
1335: PPUSH
1336: PPUSH
// gensher_side := 2 ;
1337: LD_ADDR_EXP 7
1341: PUSH
1342: LD_INT 2
1344: ST_TO_ADDR
// uc_side := gensher_side ;
1345: LD_ADDR_OWVAR 20
1349: PUSH
1350: LD_EXP 7
1354: ST_TO_ADDR
// uc_nation := 2 ;
1355: LD_ADDR_OWVAR 21
1359: PUSH
1360: LD_INT 2
1362: ST_TO_ADDR
// tmp := PrepareBase ( ar_depot , gensher_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 1500 , 300 , 30 ] , [ 4 , 4 , 4 , 4 ] ) ;
1363: LD_ADDR_VAR 0 3
1367: PUSH
1368: LD_INT 7
1370: PPUSH
1371: LD_INT 2
1373: PPUSH
1374: LD_STRING 
1376: PPUSH
1377: LD_INT 8
1379: PUSH
1380: LD_INT 7
1382: PUSH
1383: LD_INT 6
1385: PUSH
1386: EMPTY
1387: LIST
1388: LIST
1389: LIST
1390: PUSH
1391: LD_OWVAR 67
1395: ARRAY
1396: PPUSH
1397: LD_INT 1500
1399: PUSH
1400: LD_INT 300
1402: PUSH
1403: LD_INT 30
1405: PUSH
1406: EMPTY
1407: LIST
1408: LIST
1409: LIST
1410: PPUSH
1411: LD_INT 4
1413: PUSH
1414: LD_INT 4
1416: PUSH
1417: LD_INT 4
1419: PUSH
1420: LD_INT 4
1422: PUSH
1423: EMPTY
1424: LIST
1425: LIST
1426: LIST
1427: LIST
1428: PPUSH
1429: CALL 12714 0 6
1433: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp ) ;
1434: LD_ADDR_EXP 14
1438: PUSH
1439: LD_EXP 14
1443: PPUSH
1444: LD_INT 2
1446: PPUSH
1447: LD_VAR 0 3
1451: PPUSH
1452: CALL_OW 1
1456: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] ] ) ;
1457: LD_ADDR_VAR 0 3
1461: PUSH
1462: LD_INT 22
1464: PUSH
1465: LD_INT 2
1467: PUSH
1468: EMPTY
1469: LIST
1470: LIST
1471: PUSH
1472: LD_INT 30
1474: PUSH
1475: LD_INT 31
1477: PUSH
1478: EMPTY
1479: LIST
1480: LIST
1481: PUSH
1482: EMPTY
1483: LIST
1484: LIST
1485: PPUSH
1486: CALL_OW 69
1490: ST_TO_ADDR
// for i in tmp do
1491: LD_ADDR_VAR 0 2
1495: PUSH
1496: LD_VAR 0 3
1500: PUSH
1501: FOR_IN
1502: IFFALSE 1572
// begin PrepareHuman ( false , 1 , [ 4 , 3 , 3 ] [ Difficulty ] ) ;
1504: LD_INT 0
1506: PPUSH
1507: LD_INT 1
1509: PPUSH
1510: LD_INT 4
1512: PUSH
1513: LD_INT 3
1515: PUSH
1516: LD_INT 3
1518: PUSH
1519: EMPTY
1520: LIST
1521: LIST
1522: LIST
1523: PUSH
1524: LD_OWVAR 67
1528: ARRAY
1529: PPUSH
1530: CALL_OW 380
// un := CreateHuman ;
1534: LD_ADDR_VAR 0 4
1538: PUSH
1539: CALL_OW 44
1543: ST_TO_ADDR
// SetDir ( un , 1 ) ;
1544: LD_VAR 0 4
1548: PPUSH
1549: LD_INT 1
1551: PPUSH
1552: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
1556: LD_VAR 0 4
1560: PPUSH
1561: LD_VAR 0 2
1565: PPUSH
1566: CALL_OW 52
// end ;
1570: GO 1501
1572: POP
1573: POP
// tmp := AreaToList ( gensher_mines , 0 ) ;
1574: LD_ADDR_VAR 0 3
1578: PUSH
1579: LD_INT 15
1581: PPUSH
1582: LD_INT 0
1584: PPUSH
1585: CALL_OW 517
1589: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
1590: LD_ADDR_VAR 0 2
1594: PUSH
1595: DOUBLE
1596: LD_INT 1
1598: DEC
1599: ST_TO_ADDR
1600: LD_VAR 0 3
1604: PUSH
1605: LD_INT 1
1607: ARRAY
1608: PUSH
1609: FOR_TO
1610: IFFALSE 1712
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
1612: LD_VAR 0 3
1616: PUSH
1617: LD_INT 1
1619: ARRAY
1620: PUSH
1621: LD_VAR 0 2
1625: ARRAY
1626: PPUSH
1627: LD_VAR 0 3
1631: PUSH
1632: LD_INT 2
1634: ARRAY
1635: PUSH
1636: LD_VAR 0 2
1640: ARRAY
1641: PPUSH
1642: LD_INT 2
1644: PPUSH
1645: LD_INT 0
1647: PPUSH
1648: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
1652: LD_ADDR_EXP 3
1656: PUSH
1657: LD_EXP 3
1661: PPUSH
1662: LD_EXP 3
1666: PUSH
1667: LD_INT 1
1669: PLUS
1670: PPUSH
1671: LD_VAR 0 3
1675: PUSH
1676: LD_INT 1
1678: ARRAY
1679: PUSH
1680: LD_VAR 0 2
1684: ARRAY
1685: PUSH
1686: LD_VAR 0 3
1690: PUSH
1691: LD_INT 2
1693: ARRAY
1694: PUSH
1695: LD_VAR 0 2
1699: ARRAY
1700: PUSH
1701: EMPTY
1702: LIST
1703: LIST
1704: PPUSH
1705: CALL_OW 2
1709: ST_TO_ADDR
// end ;
1710: GO 1609
1712: POP
1713: POP
// end ;
1714: LD_VAR 0 1
1718: RET
// export function InitMC_Gensher ( ) ; begin
1719: LD_INT 0
1721: PPUSH
// MC_SetScanArea ( 2 , gensher_base ) ;
1722: LD_INT 2
1724: PPUSH
1725: LD_INT 2
1727: PPUSH
1728: CALL 66245 0 2
// MC_SetParkingArea ( 2 , gensher_parking ) ;
1732: LD_INT 2
1734: PPUSH
1735: LD_INT 9
1737: PPUSH
1738: CALL 66189 0 2
// MC_SetDepositsXY ( 2 , [ [ 56 , 23 , 0 ] , [ 52 , 40 , 1 ] ] ) ;
1742: LD_INT 2
1744: PPUSH
1745: LD_INT 56
1747: PUSH
1748: LD_INT 23
1750: PUSH
1751: LD_INT 0
1753: PUSH
1754: EMPTY
1755: LIST
1756: LIST
1757: LIST
1758: PUSH
1759: LD_INT 52
1761: PUSH
1762: LD_INT 40
1764: PUSH
1765: LD_INT 1
1767: PUSH
1768: EMPTY
1769: LIST
1770: LIST
1771: LIST
1772: PUSH
1773: EMPTY
1774: LIST
1775: LIST
1776: PPUSH
1777: CALL 65248 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ar_gun , ar_rocket_launcher ] ) ;
1781: LD_INT 2
1783: PPUSH
1784: LD_INT 27
1786: PUSH
1787: LD_INT 28
1789: PUSH
1790: EMPTY
1791: LIST
1792: LIST
1793: PPUSH
1794: CALL 66077 0 2
// MC_SetCratesArea ( 2 , gensher_crates ) ;
1798: LD_INT 2
1800: PPUSH
1801: LD_INT 8
1803: PPUSH
1804: CALL 65759 0 2
// MC_SetTame ( 2 , gensher_ape ) ;
1808: LD_INT 2
1810: PPUSH
1811: LD_INT 7
1813: PPUSH
1814: CALL 65490 0 2
// MC_SetDefenderLimit ( 2 , 4 ) ;
1818: LD_INT 2
1820: PPUSH
1821: LD_INT 4
1823: PPUSH
1824: CALL 65109 0 2
// MC_SetProduceList ( 2 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_flame_thrower ] ] ) ;
1828: LD_INT 2
1830: PPUSH
1831: LD_INT 13
1833: PUSH
1834: LD_INT 2
1836: PUSH
1837: LD_INT 1
1839: PUSH
1840: LD_INT 31
1842: PUSH
1843: EMPTY
1844: LIST
1845: LIST
1846: LIST
1847: LIST
1848: PUSH
1849: LD_INT 13
1851: PUSH
1852: LD_INT 2
1854: PUSH
1855: LD_INT 1
1857: PUSH
1858: LD_INT 31
1860: PUSH
1861: EMPTY
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: PUSH
1867: LD_INT 14
1869: PUSH
1870: LD_INT 1
1872: PUSH
1873: LD_INT 2
1875: PUSH
1876: LD_INT 27
1878: PUSH
1879: EMPTY
1880: LIST
1881: LIST
1882: LIST
1883: LIST
1884: PUSH
1885: LD_INT 14
1887: PUSH
1888: LD_INT 1
1890: PUSH
1891: LD_INT 2
1893: PUSH
1894: LD_INT 27
1896: PUSH
1897: EMPTY
1898: LIST
1899: LIST
1900: LIST
1901: LIST
1902: PUSH
1903: LD_INT 14
1905: PUSH
1906: LD_INT 1
1908: PUSH
1909: LD_INT 2
1911: PUSH
1912: LD_INT 28
1914: PUSH
1915: EMPTY
1916: LIST
1917: LIST
1918: LIST
1919: LIST
1920: PUSH
1921: LD_INT 14
1923: PUSH
1924: LD_INT 1
1926: PUSH
1927: LD_INT 1
1929: PUSH
1930: LD_INT 26
1932: PUSH
1933: EMPTY
1934: LIST
1935: LIST
1936: LIST
1937: LIST
1938: PUSH
1939: EMPTY
1940: LIST
1941: LIST
1942: LIST
1943: LIST
1944: LIST
1945: LIST
1946: PPUSH
1947: CALL 64924 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 13 , 18 , 1 ] , [ b_lab , 17 , 27 , 1 ] , [ b_solar_power , 17 , 3 , 0 ] , [ b_oil_mine , 56 , 23 , 0 ] , [ b_armoury , 42 , 29 , 5 ] , [ b_workshop , 11 , 7 , 2 ] , [ b_solar_power , 20 , 3 , 0 ] , [ b_solar_power , 23 , 3 , 0 ] , [ b_solar_power , 26 , 3 , 0 ] , [ b_bunker , 27 , 44 , 5 ] , [ b_bunker , 41 , 41 , 5 ] , [ b_bunker , 45 , 24 , 5 ] , [ b_bunker , 48 , 19 , 5 ] , [ b_bunker , 41 , 3 , 4 ] , [ b_armoury , 44 , 9 , 4 ] , [ b_siberite_mine , 52 , 40 , 3 ] ] ) ;
1951: LD_INT 2
1953: PPUSH
1954: LD_INT 6
1956: PUSH
1957: LD_INT 13
1959: PUSH
1960: LD_INT 18
1962: PUSH
1963: LD_INT 1
1965: PUSH
1966: EMPTY
1967: LIST
1968: LIST
1969: LIST
1970: LIST
1971: PUSH
1972: LD_INT 6
1974: PUSH
1975: LD_INT 17
1977: PUSH
1978: LD_INT 27
1980: PUSH
1981: LD_INT 1
1983: PUSH
1984: EMPTY
1985: LIST
1986: LIST
1987: LIST
1988: LIST
1989: PUSH
1990: LD_INT 27
1992: PUSH
1993: LD_INT 17
1995: PUSH
1996: LD_INT 3
1998: PUSH
1999: LD_INT 0
2001: PUSH
2002: EMPTY
2003: LIST
2004: LIST
2005: LIST
2006: LIST
2007: PUSH
2008: LD_INT 29
2010: PUSH
2011: LD_INT 56
2013: PUSH
2014: LD_INT 23
2016: PUSH
2017: LD_INT 0
2019: PUSH
2020: EMPTY
2021: LIST
2022: LIST
2023: LIST
2024: LIST
2025: PUSH
2026: LD_INT 4
2028: PUSH
2029: LD_INT 42
2031: PUSH
2032: LD_INT 29
2034: PUSH
2035: LD_INT 5
2037: PUSH
2038: EMPTY
2039: LIST
2040: LIST
2041: LIST
2042: LIST
2043: PUSH
2044: LD_INT 2
2046: PUSH
2047: LD_INT 11
2049: PUSH
2050: LD_INT 7
2052: PUSH
2053: LD_INT 2
2055: PUSH
2056: EMPTY
2057: LIST
2058: LIST
2059: LIST
2060: LIST
2061: PUSH
2062: LD_INT 27
2064: PUSH
2065: LD_INT 20
2067: PUSH
2068: LD_INT 3
2070: PUSH
2071: LD_INT 0
2073: PUSH
2074: EMPTY
2075: LIST
2076: LIST
2077: LIST
2078: LIST
2079: PUSH
2080: LD_INT 27
2082: PUSH
2083: LD_INT 23
2085: PUSH
2086: LD_INT 3
2088: PUSH
2089: LD_INT 0
2091: PUSH
2092: EMPTY
2093: LIST
2094: LIST
2095: LIST
2096: LIST
2097: PUSH
2098: LD_INT 27
2100: PUSH
2101: LD_INT 26
2103: PUSH
2104: LD_INT 3
2106: PUSH
2107: LD_INT 0
2109: PUSH
2110: EMPTY
2111: LIST
2112: LIST
2113: LIST
2114: LIST
2115: PUSH
2116: LD_INT 32
2118: PUSH
2119: LD_INT 27
2121: PUSH
2122: LD_INT 44
2124: PUSH
2125: LD_INT 5
2127: PUSH
2128: EMPTY
2129: LIST
2130: LIST
2131: LIST
2132: LIST
2133: PUSH
2134: LD_INT 32
2136: PUSH
2137: LD_INT 41
2139: PUSH
2140: LD_INT 41
2142: PUSH
2143: LD_INT 5
2145: PUSH
2146: EMPTY
2147: LIST
2148: LIST
2149: LIST
2150: LIST
2151: PUSH
2152: LD_INT 32
2154: PUSH
2155: LD_INT 45
2157: PUSH
2158: LD_INT 24
2160: PUSH
2161: LD_INT 5
2163: PUSH
2164: EMPTY
2165: LIST
2166: LIST
2167: LIST
2168: LIST
2169: PUSH
2170: LD_INT 32
2172: PUSH
2173: LD_INT 48
2175: PUSH
2176: LD_INT 19
2178: PUSH
2179: LD_INT 5
2181: PUSH
2182: EMPTY
2183: LIST
2184: LIST
2185: LIST
2186: LIST
2187: PUSH
2188: LD_INT 32
2190: PUSH
2191: LD_INT 41
2193: PUSH
2194: LD_INT 3
2196: PUSH
2197: LD_INT 4
2199: PUSH
2200: EMPTY
2201: LIST
2202: LIST
2203: LIST
2204: LIST
2205: PUSH
2206: LD_INT 4
2208: PUSH
2209: LD_INT 44
2211: PUSH
2212: LD_INT 9
2214: PUSH
2215: LD_INT 4
2217: PUSH
2218: EMPTY
2219: LIST
2220: LIST
2221: LIST
2222: LIST
2223: PUSH
2224: LD_INT 30
2226: PUSH
2227: LD_INT 52
2229: PUSH
2230: LD_INT 40
2232: PUSH
2233: LD_INT 3
2235: PUSH
2236: EMPTY
2237: LIST
2238: LIST
2239: LIST
2240: LIST
2241: PUSH
2242: EMPTY
2243: LIST
2244: LIST
2245: LIST
2246: LIST
2247: LIST
2248: LIST
2249: LIST
2250: LIST
2251: LIST
2252: LIST
2253: LIST
2254: LIST
2255: LIST
2256: LIST
2257: LIST
2258: LIST
2259: PPUSH
2260: CALL 64816 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_opto , b_lab_biological , b_lab_siberium ] ) ;
2264: LD_INT 2
2266: PPUSH
2267: LD_INT 10
2269: PUSH
2270: LD_INT 15
2272: PUSH
2273: LD_INT 13
2275: PUSH
2276: LD_INT 11
2278: PUSH
2279: EMPTY
2280: LIST
2281: LIST
2282: LIST
2283: LIST
2284: PPUSH
2285: CALL 65666 0 2
// MC_SetFactoryExtension ( 2 , 11 , 7 , 2 , [ b_ext_stitch , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
2289: LD_INT 2
2291: PPUSH
2292: LD_INT 11
2294: PPUSH
2295: LD_INT 7
2297: PPUSH
2298: LD_INT 2
2300: PPUSH
2301: LD_INT 23
2303: PUSH
2304: LD_INT 16
2306: PUSH
2307: LD_INT 17
2309: PUSH
2310: LD_INT 18
2312: PUSH
2313: LD_INT 22
2315: PUSH
2316: EMPTY
2317: LIST
2318: LIST
2319: LIST
2320: LIST
2321: LIST
2322: PPUSH
2323: CALL 65871 0 5
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
2327: LD_INT 2
2329: PPUSH
2330: LD_INT 0
2332: PPUSH
2333: CALL 65539 0 2
// end ;
2337: LD_VAR 0 1
2341: RET
// every 10 trigger staticMines and FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) do var i , j , tmp , x , y ;
2342: LD_EXP 3
2346: PUSH
2347: LD_INT 15
2349: PPUSH
2350: LD_INT 81
2352: PUSH
2353: LD_INT 2
2355: PUSH
2356: EMPTY
2357: LIST
2358: LIST
2359: PPUSH
2360: CALL_OW 70
2364: AND
2365: IFFALSE 2578
2367: GO 2369
2369: DISABLE
2370: LD_INT 0
2372: PPUSH
2373: PPUSH
2374: PPUSH
2375: PPUSH
2376: PPUSH
// begin enable ;
2377: ENABLE
// tmp := FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) ;
2378: LD_ADDR_VAR 0 3
2382: PUSH
2383: LD_INT 15
2385: PPUSH
2386: LD_INT 81
2388: PUSH
2389: LD_INT 2
2391: PUSH
2392: EMPTY
2393: LIST
2394: LIST
2395: PPUSH
2396: CALL_OW 70
2400: ST_TO_ADDR
// if not tmp then
2401: LD_VAR 0 3
2405: NOT
2406: IFFALSE 2410
// exit ;
2408: GO 2578
// for i in tmp do
2410: LD_ADDR_VAR 0 1
2414: PUSH
2415: LD_VAR 0 3
2419: PUSH
2420: FOR_IN
2421: IFFALSE 2576
// begin x := GetX ( i ) ;
2423: LD_ADDR_VAR 0 4
2427: PUSH
2428: LD_VAR 0 1
2432: PPUSH
2433: CALL_OW 250
2437: ST_TO_ADDR
// y := GetY ( i ) ;
2438: LD_ADDR_VAR 0 5
2442: PUSH
2443: LD_VAR 0 1
2447: PPUSH
2448: CALL_OW 251
2452: ST_TO_ADDR
// if MineAtPos ( x , y ) then
2453: LD_VAR 0 4
2457: PPUSH
2458: LD_VAR 0 5
2462: PPUSH
2463: CALL_OW 458
2467: IFFALSE 2574
// begin LaunchMineAtPos ( x , y , 2 ) ;
2469: LD_VAR 0 4
2473: PPUSH
2474: LD_VAR 0 5
2478: PPUSH
2479: LD_INT 2
2481: PPUSH
2482: CALL_OW 456
// for j = 1 to staticMines do
2486: LD_ADDR_VAR 0 2
2490: PUSH
2491: DOUBLE
2492: LD_INT 1
2494: DEC
2495: ST_TO_ADDR
2496: LD_EXP 3
2500: PUSH
2501: FOR_TO
2502: IFFALSE 2572
// if staticMines [ j ] [ 1 ] = x and staticMines [ j ] [ 2 ] = y then
2504: LD_EXP 3
2508: PUSH
2509: LD_VAR 0 2
2513: ARRAY
2514: PUSH
2515: LD_INT 1
2517: ARRAY
2518: PUSH
2519: LD_VAR 0 4
2523: EQUAL
2524: PUSH
2525: LD_EXP 3
2529: PUSH
2530: LD_VAR 0 2
2534: ARRAY
2535: PUSH
2536: LD_INT 2
2538: ARRAY
2539: PUSH
2540: LD_VAR 0 5
2544: EQUAL
2545: AND
2546: IFFALSE 2570
// begin staticMines := Delete ( staticMines , j ) ;
2548: LD_ADDR_EXP 3
2552: PUSH
2553: LD_EXP 3
2557: PPUSH
2558: LD_VAR 0 2
2562: PPUSH
2563: CALL_OW 3
2567: ST_TO_ADDR
// break ;
2568: GO 2572
// end ;
2570: GO 2501
2572: POP
2573: POP
// end ; end ;
2574: GO 2420
2576: POP
2577: POP
// end ; end_of_file
2578: PPOPN 5
2580: END
// export Popov , popov_side , extraPopovForces ; export function PreparePopov ; var i , un , tmp ; begin
2581: LD_INT 0
2583: PPUSH
2584: PPUSH
2585: PPUSH
2586: PPUSH
// popov_side := 3 ;
2587: LD_ADDR_EXP 9
2591: PUSH
2592: LD_INT 3
2594: ST_TO_ADDR
// uc_side := popov_side ;
2595: LD_ADDR_OWVAR 20
2599: PUSH
2600: LD_EXP 9
2604: ST_TO_ADDR
// uc_nation := 3 ;
2605: LD_ADDR_OWVAR 21
2609: PUSH
2610: LD_INT 3
2612: ST_TO_ADDR
// tmp := PrepareBase ( ru_depot , popov_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 1500 , 300 , 30 ] , [ 4 , 4 , 4 , 4 ] ) ;
2613: LD_ADDR_VAR 0 4
2617: PUSH
2618: LD_INT 9
2620: PPUSH
2621: LD_INT 3
2623: PPUSH
2624: LD_STRING 
2626: PPUSH
2627: LD_INT 8
2629: PUSH
2630: LD_INT 7
2632: PUSH
2633: LD_INT 6
2635: PUSH
2636: EMPTY
2637: LIST
2638: LIST
2639: LIST
2640: PUSH
2641: LD_OWVAR 67
2645: ARRAY
2646: PPUSH
2647: LD_INT 1500
2649: PUSH
2650: LD_INT 300
2652: PUSH
2653: LD_INT 30
2655: PUSH
2656: EMPTY
2657: LIST
2658: LIST
2659: LIST
2660: PPUSH
2661: LD_INT 4
2663: PUSH
2664: LD_INT 4
2666: PUSH
2667: LD_INT 4
2669: PUSH
2670: LD_INT 4
2672: PUSH
2673: EMPTY
2674: LIST
2675: LIST
2676: LIST
2677: LIST
2678: PPUSH
2679: CALL 12714 0 6
2683: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 3 , tmp ) ;
2684: LD_ADDR_EXP 14
2688: PUSH
2689: LD_EXP 14
2693: PPUSH
2694: LD_INT 3
2696: PPUSH
2697: LD_VAR 0 4
2701: PPUSH
2702: CALL_OW 1
2706: ST_TO_ADDR
// extraPopovForces := [ ] ;
2707: LD_ADDR_EXP 10
2711: PUSH
2712: EMPTY
2713: ST_TO_ADDR
// for i := 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
2714: LD_ADDR_VAR 0 2
2718: PUSH
2719: DOUBLE
2720: LD_INT 1
2722: DEC
2723: ST_TO_ADDR
2724: LD_INT 4
2726: PUSH
2727: LD_INT 5
2729: PUSH
2730: LD_INT 6
2732: PUSH
2733: EMPTY
2734: LIST
2735: LIST
2736: LIST
2737: PUSH
2738: LD_OWVAR 67
2742: ARRAY
2743: PUSH
2744: FOR_TO
2745: IFFALSE 2848
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
2747: LD_INT 0
2749: PPUSH
2750: LD_INT 1
2752: PPUSH
2753: LD_INT 4
2755: PUSH
2756: LD_INT 5
2758: PUSH
2759: LD_INT 6
2761: PUSH
2762: EMPTY
2763: LIST
2764: LIST
2765: LIST
2766: PUSH
2767: LD_OWVAR 67
2771: ARRAY
2772: PPUSH
2773: CALL_OW 380
// un := CreateHuman ;
2777: LD_ADDR_VAR 0 3
2781: PUSH
2782: CALL_OW 44
2786: ST_TO_ADDR
// PlaceUnitXYR ( un , 131 , 110 , 8 , false ) ;
2787: LD_VAR 0 3
2791: PPUSH
2792: LD_INT 131
2794: PPUSH
2795: LD_INT 110
2797: PPUSH
2798: LD_INT 8
2800: PPUSH
2801: LD_INT 0
2803: PPUSH
2804: CALL_OW 50
// ComHold ( un ) ;
2808: LD_VAR 0 3
2812: PPUSH
2813: CALL_OW 140
// extraPopovForces := Replace ( extraPopovForces , extraPopovForces + 1 , un ) ;
2817: LD_ADDR_EXP 10
2821: PUSH
2822: LD_EXP 10
2826: PPUSH
2827: LD_EXP 10
2831: PUSH
2832: LD_INT 1
2834: PLUS
2835: PPUSH
2836: LD_VAR 0 3
2840: PPUSH
2841: CALL_OW 1
2845: ST_TO_ADDR
// end ;
2846: GO 2744
2848: POP
2849: POP
// PrepareSoldier ( false , 6 ) ;
2850: LD_INT 0
2852: PPUSH
2853: LD_INT 6
2855: PPUSH
2856: CALL_OW 381
// un := CreateHuman ;
2860: LD_ADDR_VAR 0 3
2864: PUSH
2865: CALL_OW 44
2869: ST_TO_ADDR
// SetDir ( un , 1 ) ;
2870: LD_VAR 0 3
2874: PPUSH
2875: LD_INT 1
2877: PPUSH
2878: CALL_OW 233
// PlaceHumanInUnit ( un , HexInfo ( 150 , 158 ) ) ;
2882: LD_VAR 0 3
2886: PPUSH
2887: LD_INT 150
2889: PPUSH
2890: LD_INT 158
2892: PPUSH
2893: CALL_OW 428
2897: PPUSH
2898: CALL_OW 52
// end ;
2902: LD_VAR 0 1
2906: RET
// export function InitMC_Popov ( ) ; begin
2907: LD_INT 0
2909: PPUSH
// MC_SetScanArea ( 3 , popov_base ) ;
2910: LD_INT 3
2912: PPUSH
2913: LD_INT 3
2915: PPUSH
2916: CALL 66245 0 2
// MC_SetParkingArea ( 3 , popov_parking ) ;
2920: LD_INT 3
2922: PPUSH
2923: LD_INT 10
2925: PPUSH
2926: CALL 66189 0 2
// MC_SetDepositsXY ( 3 , [ [ 86 , 118 , 0 ] , [ 123 , 151 , 1 ] , [ 106 , 113 , 0 ] ] ) ;
2930: LD_INT 3
2932: PPUSH
2933: LD_INT 86
2935: PUSH
2936: LD_INT 118
2938: PUSH
2939: LD_INT 0
2941: PUSH
2942: EMPTY
2943: LIST
2944: LIST
2945: LIST
2946: PUSH
2947: LD_INT 123
2949: PUSH
2950: LD_INT 151
2952: PUSH
2953: LD_INT 1
2955: PUSH
2956: EMPTY
2957: LIST
2958: LIST
2959: LIST
2960: PUSH
2961: LD_INT 106
2963: PUSH
2964: LD_INT 113
2966: PUSH
2967: LD_INT 0
2969: PUSH
2970: EMPTY
2971: LIST
2972: LIST
2973: LIST
2974: PUSH
2975: EMPTY
2976: LIST
2977: LIST
2978: LIST
2979: PPUSH
2980: CALL 65248 0 2
// MC_SetAllowedTurretWeapons ( 3 , [ ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ) ;
2984: LD_INT 3
2986: PPUSH
2987: LD_INT 46
2989: PUSH
2990: LD_INT 45
2992: PUSH
2993: LD_INT 47
2995: PUSH
2996: LD_INT 49
2998: PUSH
2999: EMPTY
3000: LIST
3001: LIST
3002: LIST
3003: LIST
3004: PPUSH
3005: CALL 66077 0 2
// MC_SetCratesArea ( 3 , popov_crates ) ;
3009: LD_INT 3
3011: PPUSH
3012: LD_INT 12
3014: PPUSH
3015: CALL 65759 0 2
// MC_SetTame ( 3 , popov_ape ) ;
3019: LD_INT 3
3021: PPUSH
3022: LD_INT 11
3024: PPUSH
3025: CALL 65490 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
3029: LD_INT 3
3031: PPUSH
3032: LD_INT 4
3034: PPUSH
3035: CALL 65109 0 2
// MC_SetProduceList ( 3 , [ [ ru_heavy_wheeled , engine_combustion , control_manual , ru_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] ] ) ;
3039: LD_INT 3
3041: PPUSH
3042: LD_INT 23
3044: PUSH
3045: LD_INT 1
3047: PUSH
3048: LD_INT 1
3050: PUSH
3051: LD_INT 44
3053: PUSH
3054: EMPTY
3055: LIST
3056: LIST
3057: LIST
3058: LIST
3059: PUSH
3060: LD_INT 23
3062: PUSH
3063: LD_INT 1
3065: PUSH
3066: LD_INT 3
3068: PUSH
3069: LD_INT 45
3071: PUSH
3072: EMPTY
3073: LIST
3074: LIST
3075: LIST
3076: LIST
3077: PUSH
3078: LD_INT 21
3080: PUSH
3081: LD_INT 1
3083: PUSH
3084: LD_INT 3
3086: PUSH
3087: LD_INT 43
3089: PUSH
3090: EMPTY
3091: LIST
3092: LIST
3093: LIST
3094: LIST
3095: PUSH
3096: LD_INT 21
3098: PUSH
3099: LD_INT 1
3101: PUSH
3102: LD_INT 3
3104: PUSH
3105: LD_INT 45
3107: PUSH
3108: EMPTY
3109: LIST
3110: LIST
3111: LIST
3112: LIST
3113: PUSH
3114: EMPTY
3115: LIST
3116: LIST
3117: LIST
3118: LIST
3119: PPUSH
3120: CALL 64924 0 2
// MC_SetBuildingList ( 3 , [ [ b_lab , 76 , 145 , 1 ] , [ b_oil_power , 87 , 144 , 0 ] , [ b_oil_mine , 86 , 118 , 0 ] , [ b_oil_mine , 106 , 113 , 0 ] , [ b_oil_power , 87 , 147 , 1 ] , [ b_workshop , 94 , 161 , 0 ] , [ b_lab , 81 , 155 , 1 ] , [ b_armoury , 103 , 147 , 3 ] , [ b_oil_power , 96 , 152 , 0 ] , [ b_oil_power , 96 , 149 , 3 ] , [ b_bunker , 109 , 142 , 3 ] , [ b_bunker , 112 , 148 , 3 ] , [ b_turret , 120 , 159 , 4 ] , [ b_turret , 122 , 163 , 4 ] , [ b_turret , 123 , 167 , 4 ] , [ b_turret , 59 , 111 , 3 ] , [ b_turret , 65 , 111 , 3 ] , [ b_turret , 76 , 117 , 3 ] , [ b_turret , 80 , 119 , 3 ] , [ b_turret , 87 , 125 , 3 ] , [ b_armoury , 92 , 129 , 3 ] , [ b_siberite_power , 85 , 165 , 0 ] , [ b_siberite_power , 83 , 161 , 4 ] , [ b_siberite_power , 91 , 166 , 3 ] , [ b_siberite_power , 102 , 166 , 2 ] , [ b_teleport , 91 , 147 , 3 ] ] ) ;
3124: LD_INT 3
3126: PPUSH
3127: LD_INT 6
3129: PUSH
3130: LD_INT 76
3132: PUSH
3133: LD_INT 145
3135: PUSH
3136: LD_INT 1
3138: PUSH
3139: EMPTY
3140: LIST
3141: LIST
3142: LIST
3143: LIST
3144: PUSH
3145: LD_INT 26
3147: PUSH
3148: LD_INT 87
3150: PUSH
3151: LD_INT 144
3153: PUSH
3154: LD_INT 0
3156: PUSH
3157: EMPTY
3158: LIST
3159: LIST
3160: LIST
3161: LIST
3162: PUSH
3163: LD_INT 29
3165: PUSH
3166: LD_INT 86
3168: PUSH
3169: LD_INT 118
3171: PUSH
3172: LD_INT 0
3174: PUSH
3175: EMPTY
3176: LIST
3177: LIST
3178: LIST
3179: LIST
3180: PUSH
3181: LD_INT 29
3183: PUSH
3184: LD_INT 106
3186: PUSH
3187: LD_INT 113
3189: PUSH
3190: LD_INT 0
3192: PUSH
3193: EMPTY
3194: LIST
3195: LIST
3196: LIST
3197: LIST
3198: PUSH
3199: LD_INT 26
3201: PUSH
3202: LD_INT 87
3204: PUSH
3205: LD_INT 147
3207: PUSH
3208: LD_INT 1
3210: PUSH
3211: EMPTY
3212: LIST
3213: LIST
3214: LIST
3215: LIST
3216: PUSH
3217: LD_INT 2
3219: PUSH
3220: LD_INT 94
3222: PUSH
3223: LD_INT 161
3225: PUSH
3226: LD_INT 0
3228: PUSH
3229: EMPTY
3230: LIST
3231: LIST
3232: LIST
3233: LIST
3234: PUSH
3235: LD_INT 6
3237: PUSH
3238: LD_INT 81
3240: PUSH
3241: LD_INT 155
3243: PUSH
3244: LD_INT 1
3246: PUSH
3247: EMPTY
3248: LIST
3249: LIST
3250: LIST
3251: LIST
3252: PUSH
3253: LD_INT 4
3255: PUSH
3256: LD_INT 103
3258: PUSH
3259: LD_INT 147
3261: PUSH
3262: LD_INT 3
3264: PUSH
3265: EMPTY
3266: LIST
3267: LIST
3268: LIST
3269: LIST
3270: PUSH
3271: LD_INT 26
3273: PUSH
3274: LD_INT 96
3276: PUSH
3277: LD_INT 152
3279: PUSH
3280: LD_INT 0
3282: PUSH
3283: EMPTY
3284: LIST
3285: LIST
3286: LIST
3287: LIST
3288: PUSH
3289: LD_INT 26
3291: PUSH
3292: LD_INT 96
3294: PUSH
3295: LD_INT 149
3297: PUSH
3298: LD_INT 3
3300: PUSH
3301: EMPTY
3302: LIST
3303: LIST
3304: LIST
3305: LIST
3306: PUSH
3307: LD_INT 32
3309: PUSH
3310: LD_INT 109
3312: PUSH
3313: LD_INT 142
3315: PUSH
3316: LD_INT 3
3318: PUSH
3319: EMPTY
3320: LIST
3321: LIST
3322: LIST
3323: LIST
3324: PUSH
3325: LD_INT 32
3327: PUSH
3328: LD_INT 112
3330: PUSH
3331: LD_INT 148
3333: PUSH
3334: LD_INT 3
3336: PUSH
3337: EMPTY
3338: LIST
3339: LIST
3340: LIST
3341: LIST
3342: PUSH
3343: LD_INT 33
3345: PUSH
3346: LD_INT 120
3348: PUSH
3349: LD_INT 159
3351: PUSH
3352: LD_INT 4
3354: PUSH
3355: EMPTY
3356: LIST
3357: LIST
3358: LIST
3359: LIST
3360: PUSH
3361: LD_INT 33
3363: PUSH
3364: LD_INT 122
3366: PUSH
3367: LD_INT 163
3369: PUSH
3370: LD_INT 4
3372: PUSH
3373: EMPTY
3374: LIST
3375: LIST
3376: LIST
3377: LIST
3378: PUSH
3379: LD_INT 33
3381: PUSH
3382: LD_INT 123
3384: PUSH
3385: LD_INT 167
3387: PUSH
3388: LD_INT 4
3390: PUSH
3391: EMPTY
3392: LIST
3393: LIST
3394: LIST
3395: LIST
3396: PUSH
3397: LD_INT 33
3399: PUSH
3400: LD_INT 59
3402: PUSH
3403: LD_INT 111
3405: PUSH
3406: LD_INT 3
3408: PUSH
3409: EMPTY
3410: LIST
3411: LIST
3412: LIST
3413: LIST
3414: PUSH
3415: LD_INT 33
3417: PUSH
3418: LD_INT 65
3420: PUSH
3421: LD_INT 111
3423: PUSH
3424: LD_INT 3
3426: PUSH
3427: EMPTY
3428: LIST
3429: LIST
3430: LIST
3431: LIST
3432: PUSH
3433: LD_INT 33
3435: PUSH
3436: LD_INT 76
3438: PUSH
3439: LD_INT 117
3441: PUSH
3442: LD_INT 3
3444: PUSH
3445: EMPTY
3446: LIST
3447: LIST
3448: LIST
3449: LIST
3450: PUSH
3451: LD_INT 33
3453: PUSH
3454: LD_INT 80
3456: PUSH
3457: LD_INT 119
3459: PUSH
3460: LD_INT 3
3462: PUSH
3463: EMPTY
3464: LIST
3465: LIST
3466: LIST
3467: LIST
3468: PUSH
3469: LD_INT 33
3471: PUSH
3472: LD_INT 87
3474: PUSH
3475: LD_INT 125
3477: PUSH
3478: LD_INT 3
3480: PUSH
3481: EMPTY
3482: LIST
3483: LIST
3484: LIST
3485: LIST
3486: PUSH
3487: LD_INT 4
3489: PUSH
3490: LD_INT 92
3492: PUSH
3493: LD_INT 129
3495: PUSH
3496: LD_INT 3
3498: PUSH
3499: EMPTY
3500: LIST
3501: LIST
3502: LIST
3503: LIST
3504: PUSH
3505: LD_INT 28
3507: PUSH
3508: LD_INT 85
3510: PUSH
3511: LD_INT 165
3513: PUSH
3514: LD_INT 0
3516: PUSH
3517: EMPTY
3518: LIST
3519: LIST
3520: LIST
3521: LIST
3522: PUSH
3523: LD_INT 28
3525: PUSH
3526: LD_INT 83
3528: PUSH
3529: LD_INT 161
3531: PUSH
3532: LD_INT 4
3534: PUSH
3535: EMPTY
3536: LIST
3537: LIST
3538: LIST
3539: LIST
3540: PUSH
3541: LD_INT 28
3543: PUSH
3544: LD_INT 91
3546: PUSH
3547: LD_INT 166
3549: PUSH
3550: LD_INT 3
3552: PUSH
3553: EMPTY
3554: LIST
3555: LIST
3556: LIST
3557: LIST
3558: PUSH
3559: LD_INT 28
3561: PUSH
3562: LD_INT 102
3564: PUSH
3565: LD_INT 166
3567: PUSH
3568: LD_INT 2
3570: PUSH
3571: EMPTY
3572: LIST
3573: LIST
3574: LIST
3575: LIST
3576: PUSH
3577: LD_INT 34
3579: PUSH
3580: LD_INT 91
3582: PUSH
3583: LD_INT 147
3585: PUSH
3586: LD_INT 3
3588: PUSH
3589: EMPTY
3590: LIST
3591: LIST
3592: LIST
3593: LIST
3594: PUSH
3595: EMPTY
3596: LIST
3597: LIST
3598: LIST
3599: LIST
3600: LIST
3601: LIST
3602: LIST
3603: LIST
3604: LIST
3605: LIST
3606: LIST
3607: LIST
3608: LIST
3609: LIST
3610: LIST
3611: LIST
3612: LIST
3613: LIST
3614: LIST
3615: LIST
3616: LIST
3617: LIST
3618: LIST
3619: LIST
3620: LIST
3621: LIST
3622: PPUSH
3623: CALL 64816 0 2
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_siberium ] ) ;
3627: LD_INT 3
3629: PPUSH
3630: LD_INT 10
3632: PUSH
3633: LD_INT 12
3635: PUSH
3636: LD_INT 14
3638: PUSH
3639: LD_INT 11
3641: PUSH
3642: EMPTY
3643: LIST
3644: LIST
3645: LIST
3646: LIST
3647: PPUSH
3648: CALL 65666 0 2
// MC_SetFactoryExtension ( 3 , 94 , 161 , 0 , [ b_ext_noncombat , b_ext_gun , b_ext_rocket , b_ext_computer , b_ext_siberium ] ) ;
3652: LD_INT 3
3654: PPUSH
3655: LD_INT 94
3657: PPUSH
3658: LD_INT 161
3660: PPUSH
3661: LD_INT 0
3663: PPUSH
3664: LD_INT 19
3666: PUSH
3667: LD_INT 17
3669: PUSH
3670: LD_INT 18
3672: PUSH
3673: LD_INT 24
3675: PUSH
3676: LD_INT 21
3678: PUSH
3679: EMPTY
3680: LIST
3681: LIST
3682: LIST
3683: LIST
3684: LIST
3685: PPUSH
3686: CALL 65871 0 5
// MC_SetUpgradeBuilding ( 3 , b_depot ) ;
3690: LD_INT 3
3692: PPUSH
3693: LD_INT 0
3695: PPUSH
3696: CALL 65539 0 2
// end ; end_of_file
3700: LD_VAR 0 1
3704: RET
// export Sikorski ; export function PrepareSikorski ; var i , j , un ; begin
3705: LD_INT 0
3707: PPUSH
3708: PPUSH
3709: PPUSH
3710: PPUSH
// uc_side := 1 ;
3711: LD_ADDR_OWVAR 20
3715: PUSH
3716: LD_INT 1
3718: ST_TO_ADDR
// uc_nation := 1 ;
3719: LD_ADDR_OWVAR 21
3723: PUSH
3724: LD_INT 1
3726: ST_TO_ADDR
// hc_importance := 100 ;
3727: LD_ADDR_OWVAR 32
3731: PUSH
3732: LD_INT 100
3734: ST_TO_ADDR
// hc_name := Jeremy Sikorski ;
3735: LD_ADDR_OWVAR 26
3739: PUSH
3740: LD_STRING Jeremy Sikorski
3742: ST_TO_ADDR
// hc_gallery := us ;
3743: LD_ADDR_OWVAR 33
3747: PUSH
3748: LD_STRING us
3750: ST_TO_ADDR
// hc_face_number := 19 ;
3751: LD_ADDR_OWVAR 34
3755: PUSH
3756: LD_INT 19
3758: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , [ 4 , 4 , 3 ] [ Difficulty ] ) ;
3759: LD_INT 1
3761: PPUSH
3762: LD_INT 1
3764: PPUSH
3765: LD_INT 4
3767: PUSH
3768: LD_INT 4
3770: PUSH
3771: LD_INT 3
3773: PUSH
3774: EMPTY
3775: LIST
3776: LIST
3777: LIST
3778: PUSH
3779: LD_OWVAR 67
3783: ARRAY
3784: PPUSH
3785: CALL_OW 380
// hc_attr := [ 10 , 12 ] ;
3789: LD_ADDR_OWVAR 29
3793: PUSH
3794: LD_INT 10
3796: PUSH
3797: LD_INT 12
3799: PUSH
3800: EMPTY
3801: LIST
3802: LIST
3803: ST_TO_ADDR
// Sikorski := CreateHuman ;
3804: LD_ADDR_EXP 11
3808: PUSH
3809: CALL_OW 44
3813: ST_TO_ADDR
// PlaceUnitXYR ( Sikorski , 133 , 19 , 2 , false ) ;
3814: LD_EXP 11
3818: PPUSH
3819: LD_INT 133
3821: PPUSH
3822: LD_INT 19
3824: PPUSH
3825: LD_INT 2
3827: PPUSH
3828: LD_INT 0
3830: PPUSH
3831: CALL_OW 50
// InitHc_All ( ) ;
3835: CALL_OW 584
// for i := 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
3839: LD_ADDR_VAR 0 2
3843: PUSH
3844: DOUBLE
3845: LD_INT 1
3847: DEC
3848: ST_TO_ADDR
3849: LD_INT 4
3851: PUSH
3852: LD_INT 3
3854: PUSH
3855: LD_INT 3
3857: PUSH
3858: EMPTY
3859: LIST
3860: LIST
3861: LIST
3862: PUSH
3863: LD_OWVAR 67
3867: ARRAY
3868: PUSH
3869: FOR_TO
3870: IFFALSE 3986
// for j := 1 to 4 do
3872: LD_ADDR_VAR 0 3
3876: PUSH
3877: DOUBLE
3878: LD_INT 1
3880: DEC
3881: ST_TO_ADDR
3882: LD_INT 4
3884: PUSH
3885: FOR_TO
3886: IFFALSE 3982
// begin PrepareHuman ( false , j , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
3888: LD_INT 0
3890: PPUSH
3891: LD_VAR 0 3
3895: PPUSH
3896: LD_INT 5
3898: PUSH
3899: LD_INT 4
3901: PUSH
3902: LD_INT 3
3904: PUSH
3905: EMPTY
3906: LIST
3907: LIST
3908: LIST
3909: PUSH
3910: LD_OWVAR 67
3914: ARRAY
3915: PPUSH
3916: CALL_OW 380
// un := CreateHuman ;
3920: LD_ADDR_VAR 0 4
3924: PUSH
3925: CALL_OW 44
3929: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3930: LD_VAR 0 4
3934: PPUSH
3935: LD_INT 0
3937: PPUSH
3938: LD_INT 5
3940: PPUSH
3941: CALL_OW 12
3945: PPUSH
3946: CALL_OW 233
// PlaceUnitXYR ( un , 133 , 19 , 6 , false ) ;
3950: LD_VAR 0 4
3954: PPUSH
3955: LD_INT 133
3957: PPUSH
3958: LD_INT 19
3960: PPUSH
3961: LD_INT 6
3963: PPUSH
3964: LD_INT 0
3966: PPUSH
3967: CALL_OW 50
// ComHold ( un ) ;
3971: LD_VAR 0 4
3975: PPUSH
3976: CALL_OW 140
// end ;
3980: GO 3885
3982: POP
3983: POP
3984: GO 3869
3986: POP
3987: POP
// vc_chassis := us_heavy_tracked ;
3988: LD_ADDR_OWVAR 37
3992: PUSH
3993: LD_INT 4
3995: ST_TO_ADDR
// vc_engine := engine_combustion ;
3996: LD_ADDR_OWVAR 39
4000: PUSH
4001: LD_INT 1
4003: ST_TO_ADDR
// vc_control := control_manual ;
4004: LD_ADDR_OWVAR 38
4008: PUSH
4009: LD_INT 1
4011: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
4012: LD_ADDR_OWVAR 40
4016: PUSH
4017: LD_INT 14
4019: ST_TO_ADDR
// vc_fuel_battery := 60 ;
4020: LD_ADDR_OWVAR 41
4024: PUSH
4025: LD_INT 60
4027: ST_TO_ADDR
// un := CreateVehicle ;
4028: LD_ADDR_VAR 0 4
4032: PUSH
4033: CALL_OW 45
4037: ST_TO_ADDR
// SetDir ( un , 2 ) ;
4038: LD_VAR 0 4
4042: PPUSH
4043: LD_INT 2
4045: PPUSH
4046: CALL_OW 233
// PlaceUnitXY ( un , 128 , 12 , false ) ;
4050: LD_VAR 0 4
4054: PPUSH
4055: LD_INT 128
4057: PPUSH
4058: LD_INT 12
4060: PPUSH
4061: LD_INT 0
4063: PPUSH
4064: CALL_OW 48
// for i := 1 to 3 do
4068: LD_ADDR_VAR 0 2
4072: PUSH
4073: DOUBLE
4074: LD_INT 1
4076: DEC
4077: ST_TO_ADDR
4078: LD_INT 3
4080: PUSH
4081: FOR_TO
4082: IFFALSE 4105
// CreateCratesXYR ( 5 , 133 , 19 , 3 , false ) ;
4084: LD_INT 5
4086: PPUSH
4087: LD_INT 133
4089: PPUSH
4090: LD_INT 19
4092: PPUSH
4093: LD_INT 3
4095: PPUSH
4096: LD_INT 0
4098: PPUSH
4099: CALL_OW 56
4103: GO 4081
4105: POP
4106: POP
// end ; end_of_file
4107: LD_VAR 0 1
4111: RET
// export function Action ; begin
4112: LD_INT 0
4114: PPUSH
// wait ( 0 0$5 ) ;
4115: LD_INT 175
4117: PPUSH
4118: CALL_OW 67
// InGameOn ;
4122: CALL_OW 8
// wait ( 0 0$2 ) ;
4126: LD_INT 70
4128: PPUSH
4129: CALL_OW 67
// CenterNowOnXY ( 133 , 19 ) ;
4133: LD_INT 133
4135: PPUSH
4136: LD_INT 19
4138: PPUSH
4139: CALL_OW 86
// Say ( Sikorski , WT-DS-1 ) ;
4143: LD_EXP 11
4147: PPUSH
4148: LD_STRING WT-DS-1
4150: PPUSH
4151: CALL_OW 88
// wait ( 0 0$5 ) ;
4155: LD_INT 175
4157: PPUSH
4158: CALL_OW 67
// InGameOff ;
4162: CALL_OW 9
// ChangeMissionObjectives ( DestroyEnemy ) ;
4166: LD_STRING DestroyEnemy
4168: PPUSH
4169: CALL_OW 337
// end ; end_of_file
4173: LD_VAR 0 1
4177: RET
// on UnitDestroyed ( un ) do begin MCE_UnitDestroyed ( un ) ;
4178: LD_VAR 0 1
4182: PPUSH
4183: CALL 68364 0 1
// if un = Powell then
4187: LD_VAR 0 1
4191: PUSH
4192: LD_EXP 4
4196: EQUAL
4197: IFFALSE 4206
// YouLost ( Powell ) ;
4199: LD_STRING Powell
4201: PPUSH
4202: CALL_OW 104
// end ;
4206: PPOPN 1
4208: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
4209: LD_VAR 0 1
4213: PPUSH
4214: LD_VAR 0 2
4218: PPUSH
4219: CALL 70698 0 2
// end ;
4223: PPOPN 2
4225: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
4226: LD_VAR 0 1
4230: PPUSH
4231: CALL 69766 0 1
// end ;
4235: PPOPN 1
4237: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
4238: LD_VAR 0 1
4242: PPUSH
4243: CALL 70007 0 1
// end ;
4247: PPOPN 1
4249: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
4250: LD_VAR 0 1
4254: PPUSH
4255: LD_VAR 0 2
4259: PPUSH
4260: CALL 68060 0 2
// end ;
4264: PPOPN 2
4266: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
4267: LD_VAR 0 1
4271: PPUSH
4272: LD_VAR 0 2
4276: PPUSH
4277: LD_VAR 0 3
4281: PPUSH
4282: LD_VAR 0 4
4286: PPUSH
4287: LD_VAR 0 5
4291: PPUSH
4292: CALL 67680 0 5
// end ;
4296: PPOPN 5
4298: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
4299: LD_VAR 0 1
4303: PPUSH
4304: LD_VAR 0 2
4308: PPUSH
4309: CALL 67276 0 2
// end ;
4313: PPOPN 2
4315: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
4316: LD_VAR 0 1
4320: PPUSH
4321: LD_VAR 0 2
4325: PPUSH
4326: LD_VAR 0 3
4330: PPUSH
4331: LD_VAR 0 4
4335: PPUSH
4336: CALL 67114 0 4
// end ;
4340: PPOPN 4
4342: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
4343: LD_VAR 0 1
4347: PPUSH
4348: LD_VAR 0 2
4352: PPUSH
4353: LD_VAR 0 3
4357: PPUSH
4358: CALL 66889 0 3
// end ;
4362: PPOPN 3
4364: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
4365: LD_VAR 0 1
4369: PPUSH
4370: LD_VAR 0 2
4374: PPUSH
4375: CALL 66774 0 2
// end ;
4379: PPOPN 2
4381: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
4382: LD_VAR 0 1
4386: PPUSH
4387: LD_VAR 0 2
4391: PPUSH
4392: CALL 70959 0 2
// end ;
4396: PPOPN 2
4398: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
4399: LD_VAR 0 1
4403: PPUSH
4404: LD_VAR 0 2
4408: PPUSH
4409: LD_VAR 0 3
4413: PPUSH
4414: LD_VAR 0 4
4418: PPUSH
4419: CALL 71175 0 4
// end ;
4423: PPOPN 4
4425: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
4426: LD_VAR 0 1
4430: PPUSH
4431: LD_VAR 0 2
4435: PPUSH
4436: CALL 66583 0 2
// end ;
4440: PPOPN 2
4442: END
// export function CustomEvent ( event ) ; begin
4443: LD_INT 0
4445: PPUSH
// end ;
4446: LD_VAR 0 2
4450: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 then
4451: LD_VAR 0 1
4455: PUSH
4456: LD_INT 1
4458: EQUAL
4459: PUSH
4460: LD_VAR 0 2
4464: PUSH
4465: LD_INT 4
4467: EQUAL
4468: AND
4469: IFFALSE 4478
// YouLost ( FriendlyFire ) ;
4471: LD_STRING FriendlyFire
4473: PPUSH
4474: CALL_OW 104
// end ; end_of_file
4478: PPOPN 2
4480: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
4481: LD_INT 0
4483: PPUSH
4484: PPUSH
// if exist_mode then
4485: LD_VAR 0 2
4489: IFFALSE 4514
// unit := CreateCharacter ( prefix & ident ) else
4491: LD_ADDR_VAR 0 5
4495: PUSH
4496: LD_VAR 0 3
4500: PUSH
4501: LD_VAR 0 1
4505: STR
4506: PPUSH
4507: CALL_OW 34
4511: ST_TO_ADDR
4512: GO 4529
// unit := NewCharacter ( ident ) ;
4514: LD_ADDR_VAR 0 5
4518: PUSH
4519: LD_VAR 0 1
4523: PPUSH
4524: CALL_OW 25
4528: ST_TO_ADDR
// result := unit ;
4529: LD_ADDR_VAR 0 4
4533: PUSH
4534: LD_VAR 0 5
4538: ST_TO_ADDR
// end ;
4539: LD_VAR 0 4
4543: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
4544: LD_INT 0
4546: PPUSH
4547: PPUSH
// if not side or not nation then
4548: LD_VAR 0 1
4552: NOT
4553: PUSH
4554: LD_VAR 0 2
4558: NOT
4559: OR
4560: IFFALSE 4564
// exit ;
4562: GO 5328
// case nation of nation_american :
4564: LD_VAR 0 2
4568: PUSH
4569: LD_INT 1
4571: DOUBLE
4572: EQUAL
4573: IFTRUE 4577
4575: GO 4791
4577: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
4578: LD_ADDR_VAR 0 4
4582: PUSH
4583: LD_INT 35
4585: PUSH
4586: LD_INT 45
4588: PUSH
4589: LD_INT 46
4591: PUSH
4592: LD_INT 47
4594: PUSH
4595: LD_INT 82
4597: PUSH
4598: LD_INT 83
4600: PUSH
4601: LD_INT 84
4603: PUSH
4604: LD_INT 85
4606: PUSH
4607: LD_INT 86
4609: PUSH
4610: LD_INT 1
4612: PUSH
4613: LD_INT 2
4615: PUSH
4616: LD_INT 6
4618: PUSH
4619: LD_INT 15
4621: PUSH
4622: LD_INT 16
4624: PUSH
4625: LD_INT 7
4627: PUSH
4628: LD_INT 12
4630: PUSH
4631: LD_INT 13
4633: PUSH
4634: LD_INT 10
4636: PUSH
4637: LD_INT 14
4639: PUSH
4640: LD_INT 20
4642: PUSH
4643: LD_INT 21
4645: PUSH
4646: LD_INT 22
4648: PUSH
4649: LD_INT 25
4651: PUSH
4652: LD_INT 32
4654: PUSH
4655: LD_INT 27
4657: PUSH
4658: LD_INT 36
4660: PUSH
4661: LD_INT 69
4663: PUSH
4664: LD_INT 39
4666: PUSH
4667: LD_INT 34
4669: PUSH
4670: LD_INT 40
4672: PUSH
4673: LD_INT 48
4675: PUSH
4676: LD_INT 49
4678: PUSH
4679: LD_INT 50
4681: PUSH
4682: LD_INT 51
4684: PUSH
4685: LD_INT 52
4687: PUSH
4688: LD_INT 53
4690: PUSH
4691: LD_INT 54
4693: PUSH
4694: LD_INT 55
4696: PUSH
4697: LD_INT 56
4699: PUSH
4700: LD_INT 57
4702: PUSH
4703: LD_INT 58
4705: PUSH
4706: LD_INT 59
4708: PUSH
4709: LD_INT 60
4711: PUSH
4712: LD_INT 61
4714: PUSH
4715: LD_INT 62
4717: PUSH
4718: LD_INT 80
4720: PUSH
4721: LD_INT 82
4723: PUSH
4724: LD_INT 83
4726: PUSH
4727: LD_INT 84
4729: PUSH
4730: LD_INT 85
4732: PUSH
4733: LD_INT 86
4735: PUSH
4736: EMPTY
4737: LIST
4738: LIST
4739: LIST
4740: LIST
4741: LIST
4742: LIST
4743: LIST
4744: LIST
4745: LIST
4746: LIST
4747: LIST
4748: LIST
4749: LIST
4750: LIST
4751: LIST
4752: LIST
4753: LIST
4754: LIST
4755: LIST
4756: LIST
4757: LIST
4758: LIST
4759: LIST
4760: LIST
4761: LIST
4762: LIST
4763: LIST
4764: LIST
4765: LIST
4766: LIST
4767: LIST
4768: LIST
4769: LIST
4770: LIST
4771: LIST
4772: LIST
4773: LIST
4774: LIST
4775: LIST
4776: LIST
4777: LIST
4778: LIST
4779: LIST
4780: LIST
4781: LIST
4782: LIST
4783: LIST
4784: LIST
4785: LIST
4786: LIST
4787: LIST
4788: ST_TO_ADDR
4789: GO 5252
4791: LD_INT 2
4793: DOUBLE
4794: EQUAL
4795: IFTRUE 4799
4797: GO 5021
4799: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
4800: LD_ADDR_VAR 0 4
4804: PUSH
4805: LD_INT 35
4807: PUSH
4808: LD_INT 45
4810: PUSH
4811: LD_INT 46
4813: PUSH
4814: LD_INT 47
4816: PUSH
4817: LD_INT 82
4819: PUSH
4820: LD_INT 83
4822: PUSH
4823: LD_INT 84
4825: PUSH
4826: LD_INT 85
4828: PUSH
4829: LD_INT 87
4831: PUSH
4832: LD_INT 70
4834: PUSH
4835: LD_INT 1
4837: PUSH
4838: LD_INT 11
4840: PUSH
4841: LD_INT 3
4843: PUSH
4844: LD_INT 4
4846: PUSH
4847: LD_INT 5
4849: PUSH
4850: LD_INT 6
4852: PUSH
4853: LD_INT 15
4855: PUSH
4856: LD_INT 18
4858: PUSH
4859: LD_INT 7
4861: PUSH
4862: LD_INT 17
4864: PUSH
4865: LD_INT 8
4867: PUSH
4868: LD_INT 20
4870: PUSH
4871: LD_INT 21
4873: PUSH
4874: LD_INT 22
4876: PUSH
4877: LD_INT 72
4879: PUSH
4880: LD_INT 26
4882: PUSH
4883: LD_INT 69
4885: PUSH
4886: LD_INT 39
4888: PUSH
4889: LD_INT 40
4891: PUSH
4892: LD_INT 41
4894: PUSH
4895: LD_INT 42
4897: PUSH
4898: LD_INT 43
4900: PUSH
4901: LD_INT 48
4903: PUSH
4904: LD_INT 49
4906: PUSH
4907: LD_INT 50
4909: PUSH
4910: LD_INT 51
4912: PUSH
4913: LD_INT 52
4915: PUSH
4916: LD_INT 53
4918: PUSH
4919: LD_INT 54
4921: PUSH
4922: LD_INT 55
4924: PUSH
4925: LD_INT 56
4927: PUSH
4928: LD_INT 60
4930: PUSH
4931: LD_INT 61
4933: PUSH
4934: LD_INT 62
4936: PUSH
4937: LD_INT 66
4939: PUSH
4940: LD_INT 67
4942: PUSH
4943: LD_INT 68
4945: PUSH
4946: LD_INT 81
4948: PUSH
4949: LD_INT 82
4951: PUSH
4952: LD_INT 83
4954: PUSH
4955: LD_INT 84
4957: PUSH
4958: LD_INT 85
4960: PUSH
4961: LD_INT 87
4963: PUSH
4964: EMPTY
4965: LIST
4966: LIST
4967: LIST
4968: LIST
4969: LIST
4970: LIST
4971: LIST
4972: LIST
4973: LIST
4974: LIST
4975: LIST
4976: LIST
4977: LIST
4978: LIST
4979: LIST
4980: LIST
4981: LIST
4982: LIST
4983: LIST
4984: LIST
4985: LIST
4986: LIST
4987: LIST
4988: LIST
4989: LIST
4990: LIST
4991: LIST
4992: LIST
4993: LIST
4994: LIST
4995: LIST
4996: LIST
4997: LIST
4998: LIST
4999: LIST
5000: LIST
5001: LIST
5002: LIST
5003: LIST
5004: LIST
5005: LIST
5006: LIST
5007: LIST
5008: LIST
5009: LIST
5010: LIST
5011: LIST
5012: LIST
5013: LIST
5014: LIST
5015: LIST
5016: LIST
5017: LIST
5018: ST_TO_ADDR
5019: GO 5252
5021: LD_INT 3
5023: DOUBLE
5024: EQUAL
5025: IFTRUE 5029
5027: GO 5251
5029: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
5030: LD_ADDR_VAR 0 4
5034: PUSH
5035: LD_INT 46
5037: PUSH
5038: LD_INT 47
5040: PUSH
5041: LD_INT 1
5043: PUSH
5044: LD_INT 2
5046: PUSH
5047: LD_INT 82
5049: PUSH
5050: LD_INT 83
5052: PUSH
5053: LD_INT 84
5055: PUSH
5056: LD_INT 85
5058: PUSH
5059: LD_INT 86
5061: PUSH
5062: LD_INT 11
5064: PUSH
5065: LD_INT 9
5067: PUSH
5068: LD_INT 20
5070: PUSH
5071: LD_INT 19
5073: PUSH
5074: LD_INT 21
5076: PUSH
5077: LD_INT 24
5079: PUSH
5080: LD_INT 22
5082: PUSH
5083: LD_INT 25
5085: PUSH
5086: LD_INT 28
5088: PUSH
5089: LD_INT 29
5091: PUSH
5092: LD_INT 30
5094: PUSH
5095: LD_INT 31
5097: PUSH
5098: LD_INT 37
5100: PUSH
5101: LD_INT 38
5103: PUSH
5104: LD_INT 32
5106: PUSH
5107: LD_INT 27
5109: PUSH
5110: LD_INT 33
5112: PUSH
5113: LD_INT 69
5115: PUSH
5116: LD_INT 39
5118: PUSH
5119: LD_INT 34
5121: PUSH
5122: LD_INT 40
5124: PUSH
5125: LD_INT 71
5127: PUSH
5128: LD_INT 23
5130: PUSH
5131: LD_INT 44
5133: PUSH
5134: LD_INT 48
5136: PUSH
5137: LD_INT 49
5139: PUSH
5140: LD_INT 50
5142: PUSH
5143: LD_INT 51
5145: PUSH
5146: LD_INT 52
5148: PUSH
5149: LD_INT 53
5151: PUSH
5152: LD_INT 54
5154: PUSH
5155: LD_INT 55
5157: PUSH
5158: LD_INT 56
5160: PUSH
5161: LD_INT 57
5163: PUSH
5164: LD_INT 58
5166: PUSH
5167: LD_INT 59
5169: PUSH
5170: LD_INT 63
5172: PUSH
5173: LD_INT 64
5175: PUSH
5176: LD_INT 65
5178: PUSH
5179: LD_INT 82
5181: PUSH
5182: LD_INT 83
5184: PUSH
5185: LD_INT 84
5187: PUSH
5188: LD_INT 85
5190: PUSH
5191: LD_INT 86
5193: PUSH
5194: EMPTY
5195: LIST
5196: LIST
5197: LIST
5198: LIST
5199: LIST
5200: LIST
5201: LIST
5202: LIST
5203: LIST
5204: LIST
5205: LIST
5206: LIST
5207: LIST
5208: LIST
5209: LIST
5210: LIST
5211: LIST
5212: LIST
5213: LIST
5214: LIST
5215: LIST
5216: LIST
5217: LIST
5218: LIST
5219: LIST
5220: LIST
5221: LIST
5222: LIST
5223: LIST
5224: LIST
5225: LIST
5226: LIST
5227: LIST
5228: LIST
5229: LIST
5230: LIST
5231: LIST
5232: LIST
5233: LIST
5234: LIST
5235: LIST
5236: LIST
5237: LIST
5238: LIST
5239: LIST
5240: LIST
5241: LIST
5242: LIST
5243: LIST
5244: LIST
5245: LIST
5246: LIST
5247: LIST
5248: ST_TO_ADDR
5249: GO 5252
5251: POP
// if state > - 1 and state < 3 then
5252: LD_VAR 0 3
5256: PUSH
5257: LD_INT 1
5259: NEG
5260: GREATER
5261: PUSH
5262: LD_VAR 0 3
5266: PUSH
5267: LD_INT 3
5269: LESS
5270: AND
5271: IFFALSE 5328
// for i in result do
5273: LD_ADDR_VAR 0 5
5277: PUSH
5278: LD_VAR 0 4
5282: PUSH
5283: FOR_IN
5284: IFFALSE 5326
// if GetTech ( i , side ) <> state then
5286: LD_VAR 0 5
5290: PPUSH
5291: LD_VAR 0 1
5295: PPUSH
5296: CALL_OW 321
5300: PUSH
5301: LD_VAR 0 3
5305: NONEQUAL
5306: IFFALSE 5324
// result := result diff i ;
5308: LD_ADDR_VAR 0 4
5312: PUSH
5313: LD_VAR 0 4
5317: PUSH
5318: LD_VAR 0 5
5322: DIFF
5323: ST_TO_ADDR
5324: GO 5283
5326: POP
5327: POP
// end ;
5328: LD_VAR 0 4
5332: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
5333: LD_INT 0
5335: PPUSH
5336: PPUSH
5337: PPUSH
// result := true ;
5338: LD_ADDR_VAR 0 3
5342: PUSH
5343: LD_INT 1
5345: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
5346: LD_ADDR_VAR 0 5
5350: PUSH
5351: LD_VAR 0 2
5355: PPUSH
5356: CALL_OW 480
5360: ST_TO_ADDR
// if not tmp then
5361: LD_VAR 0 5
5365: NOT
5366: IFFALSE 5370
// exit ;
5368: GO 5419
// for i in tmp do
5370: LD_ADDR_VAR 0 4
5374: PUSH
5375: LD_VAR 0 5
5379: PUSH
5380: FOR_IN
5381: IFFALSE 5417
// if GetTech ( i , side ) <> state_researched then
5383: LD_VAR 0 4
5387: PPUSH
5388: LD_VAR 0 1
5392: PPUSH
5393: CALL_OW 321
5397: PUSH
5398: LD_INT 2
5400: NONEQUAL
5401: IFFALSE 5415
// begin result := false ;
5403: LD_ADDR_VAR 0 3
5407: PUSH
5408: LD_INT 0
5410: ST_TO_ADDR
// exit ;
5411: POP
5412: POP
5413: GO 5419
// end ;
5415: GO 5380
5417: POP
5418: POP
// end ;
5419: LD_VAR 0 3
5423: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
5424: LD_INT 0
5426: PPUSH
5427: PPUSH
5428: PPUSH
5429: PPUSH
5430: PPUSH
5431: PPUSH
5432: PPUSH
5433: PPUSH
5434: PPUSH
5435: PPUSH
5436: PPUSH
5437: PPUSH
5438: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
5439: LD_VAR 0 1
5443: NOT
5444: PUSH
5445: LD_VAR 0 1
5449: PPUSH
5450: CALL_OW 257
5454: PUSH
5455: LD_INT 9
5457: NONEQUAL
5458: OR
5459: IFFALSE 5463
// exit ;
5461: GO 6036
// side := GetSide ( unit ) ;
5463: LD_ADDR_VAR 0 9
5467: PUSH
5468: LD_VAR 0 1
5472: PPUSH
5473: CALL_OW 255
5477: ST_TO_ADDR
// tech_space := tech_spacanom ;
5478: LD_ADDR_VAR 0 12
5482: PUSH
5483: LD_INT 29
5485: ST_TO_ADDR
// tech_time := tech_taurad ;
5486: LD_ADDR_VAR 0 13
5490: PUSH
5491: LD_INT 28
5493: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
5494: LD_ADDR_VAR 0 11
5498: PUSH
5499: LD_VAR 0 1
5503: PPUSH
5504: CALL_OW 310
5508: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
5509: LD_VAR 0 11
5513: PPUSH
5514: CALL_OW 247
5518: PUSH
5519: LD_INT 2
5521: EQUAL
5522: IFFALSE 5526
// exit ;
5524: GO 6036
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
5526: LD_ADDR_VAR 0 8
5530: PUSH
5531: LD_INT 81
5533: PUSH
5534: LD_VAR 0 9
5538: PUSH
5539: EMPTY
5540: LIST
5541: LIST
5542: PUSH
5543: LD_INT 3
5545: PUSH
5546: LD_INT 21
5548: PUSH
5549: LD_INT 3
5551: PUSH
5552: EMPTY
5553: LIST
5554: LIST
5555: PUSH
5556: EMPTY
5557: LIST
5558: LIST
5559: PUSH
5560: EMPTY
5561: LIST
5562: LIST
5563: PPUSH
5564: CALL_OW 69
5568: ST_TO_ADDR
// if not tmp then
5569: LD_VAR 0 8
5573: NOT
5574: IFFALSE 5578
// exit ;
5576: GO 6036
// if in_unit then
5578: LD_VAR 0 11
5582: IFFALSE 5606
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
5584: LD_ADDR_VAR 0 10
5588: PUSH
5589: LD_VAR 0 8
5593: PPUSH
5594: LD_VAR 0 11
5598: PPUSH
5599: CALL_OW 74
5603: ST_TO_ADDR
5604: GO 5626
// enemy := NearestUnitToUnit ( tmp , unit ) ;
5606: LD_ADDR_VAR 0 10
5610: PUSH
5611: LD_VAR 0 8
5615: PPUSH
5616: LD_VAR 0 1
5620: PPUSH
5621: CALL_OW 74
5625: ST_TO_ADDR
// if not enemy then
5626: LD_VAR 0 10
5630: NOT
5631: IFFALSE 5635
// exit ;
5633: GO 6036
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
5635: LD_VAR 0 11
5639: PUSH
5640: LD_VAR 0 11
5644: PPUSH
5645: LD_VAR 0 10
5649: PPUSH
5650: CALL_OW 296
5654: PUSH
5655: LD_INT 13
5657: GREATER
5658: AND
5659: PUSH
5660: LD_VAR 0 1
5664: PPUSH
5665: LD_VAR 0 10
5669: PPUSH
5670: CALL_OW 296
5674: PUSH
5675: LD_INT 12
5677: GREATER
5678: OR
5679: IFFALSE 5683
// exit ;
5681: GO 6036
// missile := [ 1 ] ;
5683: LD_ADDR_VAR 0 14
5687: PUSH
5688: LD_INT 1
5690: PUSH
5691: EMPTY
5692: LIST
5693: ST_TO_ADDR
// if Researched ( side , tech_space ) then
5694: LD_VAR 0 9
5698: PPUSH
5699: LD_VAR 0 12
5703: PPUSH
5704: CALL_OW 325
5708: IFFALSE 5737
// missile := Insert ( missile , missile + 1 , 2 ) ;
5710: LD_ADDR_VAR 0 14
5714: PUSH
5715: LD_VAR 0 14
5719: PPUSH
5720: LD_VAR 0 14
5724: PUSH
5725: LD_INT 1
5727: PLUS
5728: PPUSH
5729: LD_INT 2
5731: PPUSH
5732: CALL_OW 2
5736: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
5737: LD_VAR 0 9
5741: PPUSH
5742: LD_VAR 0 13
5746: PPUSH
5747: CALL_OW 325
5751: PUSH
5752: LD_VAR 0 10
5756: PPUSH
5757: CALL_OW 255
5761: PPUSH
5762: LD_VAR 0 13
5766: PPUSH
5767: CALL_OW 325
5771: NOT
5772: AND
5773: IFFALSE 5802
// missile := Insert ( missile , missile + 1 , 3 ) ;
5775: LD_ADDR_VAR 0 14
5779: PUSH
5780: LD_VAR 0 14
5784: PPUSH
5785: LD_VAR 0 14
5789: PUSH
5790: LD_INT 1
5792: PLUS
5793: PPUSH
5794: LD_INT 3
5796: PPUSH
5797: CALL_OW 2
5801: ST_TO_ADDR
// if missile < 2 then
5802: LD_VAR 0 14
5806: PUSH
5807: LD_INT 2
5809: LESS
5810: IFFALSE 5814
// exit ;
5812: GO 6036
// x := GetX ( enemy ) ;
5814: LD_ADDR_VAR 0 4
5818: PUSH
5819: LD_VAR 0 10
5823: PPUSH
5824: CALL_OW 250
5828: ST_TO_ADDR
// y := GetY ( enemy ) ;
5829: LD_ADDR_VAR 0 5
5833: PUSH
5834: LD_VAR 0 10
5838: PPUSH
5839: CALL_OW 251
5843: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
5844: LD_ADDR_VAR 0 6
5848: PUSH
5849: LD_VAR 0 4
5853: PUSH
5854: LD_INT 1
5856: NEG
5857: PPUSH
5858: LD_INT 1
5860: PPUSH
5861: CALL_OW 12
5865: PLUS
5866: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
5867: LD_ADDR_VAR 0 7
5871: PUSH
5872: LD_VAR 0 5
5876: PUSH
5877: LD_INT 1
5879: NEG
5880: PPUSH
5881: LD_INT 1
5883: PPUSH
5884: CALL_OW 12
5888: PLUS
5889: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
5890: LD_VAR 0 6
5894: PPUSH
5895: LD_VAR 0 7
5899: PPUSH
5900: CALL_OW 488
5904: NOT
5905: IFFALSE 5927
// begin _x := x ;
5907: LD_ADDR_VAR 0 6
5911: PUSH
5912: LD_VAR 0 4
5916: ST_TO_ADDR
// _y := y ;
5917: LD_ADDR_VAR 0 7
5921: PUSH
5922: LD_VAR 0 5
5926: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
5927: LD_ADDR_VAR 0 3
5931: PUSH
5932: LD_INT 1
5934: PPUSH
5935: LD_VAR 0 14
5939: PPUSH
5940: CALL_OW 12
5944: ST_TO_ADDR
// case i of 1 :
5945: LD_VAR 0 3
5949: PUSH
5950: LD_INT 1
5952: DOUBLE
5953: EQUAL
5954: IFTRUE 5958
5956: GO 5975
5958: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
5959: LD_VAR 0 1
5963: PPUSH
5964: LD_VAR 0 10
5968: PPUSH
5969: CALL_OW 115
5973: GO 6036
5975: LD_INT 2
5977: DOUBLE
5978: EQUAL
5979: IFTRUE 5983
5981: GO 6005
5983: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
5984: LD_VAR 0 1
5988: PPUSH
5989: LD_VAR 0 6
5993: PPUSH
5994: LD_VAR 0 7
5998: PPUSH
5999: CALL_OW 153
6003: GO 6036
6005: LD_INT 3
6007: DOUBLE
6008: EQUAL
6009: IFTRUE 6013
6011: GO 6035
6013: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
6014: LD_VAR 0 1
6018: PPUSH
6019: LD_VAR 0 6
6023: PPUSH
6024: LD_VAR 0 7
6028: PPUSH
6029: CALL_OW 154
6033: GO 6036
6035: POP
// end ;
6036: LD_VAR 0 2
6040: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
6041: LD_INT 0
6043: PPUSH
6044: PPUSH
6045: PPUSH
6046: PPUSH
6047: PPUSH
6048: PPUSH
// if not unit or not building then
6049: LD_VAR 0 1
6053: NOT
6054: PUSH
6055: LD_VAR 0 2
6059: NOT
6060: OR
6061: IFFALSE 6065
// exit ;
6063: GO 6223
// x := GetX ( building ) ;
6065: LD_ADDR_VAR 0 5
6069: PUSH
6070: LD_VAR 0 2
6074: PPUSH
6075: CALL_OW 250
6079: ST_TO_ADDR
// y := GetY ( building ) ;
6080: LD_ADDR_VAR 0 6
6084: PUSH
6085: LD_VAR 0 2
6089: PPUSH
6090: CALL_OW 251
6094: ST_TO_ADDR
// for i = 0 to 5 do
6095: LD_ADDR_VAR 0 4
6099: PUSH
6100: DOUBLE
6101: LD_INT 0
6103: DEC
6104: ST_TO_ADDR
6105: LD_INT 5
6107: PUSH
6108: FOR_TO
6109: IFFALSE 6221
// begin _x := ShiftX ( x , i , 3 ) ;
6111: LD_ADDR_VAR 0 7
6115: PUSH
6116: LD_VAR 0 5
6120: PPUSH
6121: LD_VAR 0 4
6125: PPUSH
6126: LD_INT 3
6128: PPUSH
6129: CALL_OW 272
6133: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
6134: LD_ADDR_VAR 0 8
6138: PUSH
6139: LD_VAR 0 6
6143: PPUSH
6144: LD_VAR 0 4
6148: PPUSH
6149: LD_INT 3
6151: PPUSH
6152: CALL_OW 273
6156: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
6157: LD_VAR 0 7
6161: PPUSH
6162: LD_VAR 0 8
6166: PPUSH
6167: CALL_OW 488
6171: NOT
6172: IFFALSE 6176
// continue ;
6174: GO 6108
// if HexInfo ( _x , _y ) = 0 then
6176: LD_VAR 0 7
6180: PPUSH
6181: LD_VAR 0 8
6185: PPUSH
6186: CALL_OW 428
6190: PUSH
6191: LD_INT 0
6193: EQUAL
6194: IFFALSE 6219
// begin ComMoveXY ( unit , _x , _y ) ;
6196: LD_VAR 0 1
6200: PPUSH
6201: LD_VAR 0 7
6205: PPUSH
6206: LD_VAR 0 8
6210: PPUSH
6211: CALL_OW 111
// exit ;
6215: POP
6216: POP
6217: GO 6223
// end ; end ;
6219: GO 6108
6221: POP
6222: POP
// end ;
6223: LD_VAR 0 3
6227: RET
// export function ScanBase ( side , base_area ) ; begin
6228: LD_INT 0
6230: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
6231: LD_ADDR_VAR 0 3
6235: PUSH
6236: LD_VAR 0 2
6240: PPUSH
6241: LD_INT 81
6243: PUSH
6244: LD_VAR 0 1
6248: PUSH
6249: EMPTY
6250: LIST
6251: LIST
6252: PPUSH
6253: CALL_OW 70
6257: ST_TO_ADDR
// end ;
6258: LD_VAR 0 3
6262: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
6263: LD_INT 0
6265: PPUSH
6266: PPUSH
6267: PPUSH
6268: PPUSH
// result := false ;
6269: LD_ADDR_VAR 0 2
6273: PUSH
6274: LD_INT 0
6276: ST_TO_ADDR
// side := GetSide ( unit ) ;
6277: LD_ADDR_VAR 0 3
6281: PUSH
6282: LD_VAR 0 1
6286: PPUSH
6287: CALL_OW 255
6291: ST_TO_ADDR
// nat := GetNation ( unit ) ;
6292: LD_ADDR_VAR 0 4
6296: PUSH
6297: LD_VAR 0 1
6301: PPUSH
6302: CALL_OW 248
6306: ST_TO_ADDR
// case nat of 1 :
6307: LD_VAR 0 4
6311: PUSH
6312: LD_INT 1
6314: DOUBLE
6315: EQUAL
6316: IFTRUE 6320
6318: GO 6331
6320: POP
// tech := tech_lassight ; 2 :
6321: LD_ADDR_VAR 0 5
6325: PUSH
6326: LD_INT 12
6328: ST_TO_ADDR
6329: GO 6370
6331: LD_INT 2
6333: DOUBLE
6334: EQUAL
6335: IFTRUE 6339
6337: GO 6350
6339: POP
// tech := tech_mortar ; 3 :
6340: LD_ADDR_VAR 0 5
6344: PUSH
6345: LD_INT 41
6347: ST_TO_ADDR
6348: GO 6370
6350: LD_INT 3
6352: DOUBLE
6353: EQUAL
6354: IFTRUE 6358
6356: GO 6369
6358: POP
// tech := tech_bazooka ; end ;
6359: LD_ADDR_VAR 0 5
6363: PUSH
6364: LD_INT 44
6366: ST_TO_ADDR
6367: GO 6370
6369: POP
// if Researched ( side , tech ) then
6370: LD_VAR 0 3
6374: PPUSH
6375: LD_VAR 0 5
6379: PPUSH
6380: CALL_OW 325
6384: IFFALSE 6411
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
6386: LD_ADDR_VAR 0 2
6390: PUSH
6391: LD_INT 5
6393: PUSH
6394: LD_INT 8
6396: PUSH
6397: LD_INT 9
6399: PUSH
6400: EMPTY
6401: LIST
6402: LIST
6403: LIST
6404: PUSH
6405: LD_VAR 0 4
6409: ARRAY
6410: ST_TO_ADDR
// end ;
6411: LD_VAR 0 2
6415: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
6416: LD_INT 0
6418: PPUSH
6419: PPUSH
6420: PPUSH
// if not mines then
6421: LD_VAR 0 2
6425: NOT
6426: IFFALSE 6430
// exit ;
6428: GO 6574
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
6430: LD_ADDR_VAR 0 5
6434: PUSH
6435: LD_INT 81
6437: PUSH
6438: LD_VAR 0 1
6442: PUSH
6443: EMPTY
6444: LIST
6445: LIST
6446: PUSH
6447: LD_INT 3
6449: PUSH
6450: LD_INT 21
6452: PUSH
6453: LD_INT 3
6455: PUSH
6456: EMPTY
6457: LIST
6458: LIST
6459: PUSH
6460: EMPTY
6461: LIST
6462: LIST
6463: PUSH
6464: EMPTY
6465: LIST
6466: LIST
6467: PPUSH
6468: CALL_OW 69
6472: ST_TO_ADDR
// for i in mines do
6473: LD_ADDR_VAR 0 4
6477: PUSH
6478: LD_VAR 0 2
6482: PUSH
6483: FOR_IN
6484: IFFALSE 6572
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
6486: LD_VAR 0 4
6490: PUSH
6491: LD_INT 1
6493: ARRAY
6494: PPUSH
6495: LD_VAR 0 4
6499: PUSH
6500: LD_INT 2
6502: ARRAY
6503: PPUSH
6504: CALL_OW 458
6508: NOT
6509: IFFALSE 6513
// continue ;
6511: GO 6483
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
6513: LD_VAR 0 4
6517: PUSH
6518: LD_INT 1
6520: ARRAY
6521: PPUSH
6522: LD_VAR 0 4
6526: PUSH
6527: LD_INT 2
6529: ARRAY
6530: PPUSH
6531: CALL_OW 428
6535: PUSH
6536: LD_VAR 0 5
6540: IN
6541: IFFALSE 6570
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
6543: LD_VAR 0 4
6547: PUSH
6548: LD_INT 1
6550: ARRAY
6551: PPUSH
6552: LD_VAR 0 4
6556: PUSH
6557: LD_INT 2
6559: ARRAY
6560: PPUSH
6561: LD_VAR 0 1
6565: PPUSH
6566: CALL_OW 456
// end ;
6570: GO 6483
6572: POP
6573: POP
// end ;
6574: LD_VAR 0 3
6578: RET
// export function Count ( array ) ; var i ; begin
6579: LD_INT 0
6581: PPUSH
6582: PPUSH
// result := 0 ;
6583: LD_ADDR_VAR 0 2
6587: PUSH
6588: LD_INT 0
6590: ST_TO_ADDR
// for i in array do
6591: LD_ADDR_VAR 0 3
6595: PUSH
6596: LD_VAR 0 1
6600: PUSH
6601: FOR_IN
6602: IFFALSE 6626
// if i then
6604: LD_VAR 0 3
6608: IFFALSE 6624
// result := result + 1 ;
6610: LD_ADDR_VAR 0 2
6614: PUSH
6615: LD_VAR 0 2
6619: PUSH
6620: LD_INT 1
6622: PLUS
6623: ST_TO_ADDR
6624: GO 6601
6626: POP
6627: POP
// end ;
6628: LD_VAR 0 2
6632: RET
// export function IsEmpty ( building ) ; begin
6633: LD_INT 0
6635: PPUSH
// if not building then
6636: LD_VAR 0 1
6640: NOT
6641: IFFALSE 6645
// exit ;
6643: GO 6688
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
6645: LD_ADDR_VAR 0 2
6649: PUSH
6650: LD_VAR 0 1
6654: PUSH
6655: LD_INT 22
6657: PUSH
6658: LD_VAR 0 1
6662: PPUSH
6663: CALL_OW 255
6667: PUSH
6668: EMPTY
6669: LIST
6670: LIST
6671: PUSH
6672: LD_INT 58
6674: PUSH
6675: EMPTY
6676: LIST
6677: PUSH
6678: EMPTY
6679: LIST
6680: LIST
6681: PPUSH
6682: CALL_OW 69
6686: IN
6687: ST_TO_ADDR
// end ;
6688: LD_VAR 0 2
6692: RET
// export function IsNotFull ( building ) ; begin
6693: LD_INT 0
6695: PPUSH
// if not building then
6696: LD_VAR 0 1
6700: NOT
6701: IFFALSE 6705
// exit ;
6703: GO 6724
// result := UnitsInside ( building ) < 6 ;
6705: LD_ADDR_VAR 0 2
6709: PUSH
6710: LD_VAR 0 1
6714: PPUSH
6715: CALL_OW 313
6719: PUSH
6720: LD_INT 6
6722: LESS
6723: ST_TO_ADDR
// end ;
6724: LD_VAR 0 2
6728: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
6729: LD_INT 0
6731: PPUSH
6732: PPUSH
6733: PPUSH
6734: PPUSH
// tmp := [ ] ;
6735: LD_ADDR_VAR 0 3
6739: PUSH
6740: EMPTY
6741: ST_TO_ADDR
// list := [ ] ;
6742: LD_ADDR_VAR 0 5
6746: PUSH
6747: EMPTY
6748: ST_TO_ADDR
// for i = 16 to 25 do
6749: LD_ADDR_VAR 0 4
6753: PUSH
6754: DOUBLE
6755: LD_INT 16
6757: DEC
6758: ST_TO_ADDR
6759: LD_INT 25
6761: PUSH
6762: FOR_TO
6763: IFFALSE 6836
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
6765: LD_ADDR_VAR 0 3
6769: PUSH
6770: LD_VAR 0 3
6774: PUSH
6775: LD_INT 22
6777: PUSH
6778: LD_VAR 0 1
6782: PPUSH
6783: CALL_OW 255
6787: PUSH
6788: EMPTY
6789: LIST
6790: LIST
6791: PUSH
6792: LD_INT 91
6794: PUSH
6795: LD_VAR 0 1
6799: PUSH
6800: LD_INT 6
6802: PUSH
6803: EMPTY
6804: LIST
6805: LIST
6806: LIST
6807: PUSH
6808: LD_INT 30
6810: PUSH
6811: LD_VAR 0 4
6815: PUSH
6816: EMPTY
6817: LIST
6818: LIST
6819: PUSH
6820: EMPTY
6821: LIST
6822: LIST
6823: LIST
6824: PUSH
6825: EMPTY
6826: LIST
6827: PPUSH
6828: CALL_OW 69
6832: ADD
6833: ST_TO_ADDR
6834: GO 6762
6836: POP
6837: POP
// for i = 1 to tmp do
6838: LD_ADDR_VAR 0 4
6842: PUSH
6843: DOUBLE
6844: LD_INT 1
6846: DEC
6847: ST_TO_ADDR
6848: LD_VAR 0 3
6852: PUSH
6853: FOR_TO
6854: IFFALSE 6942
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
6856: LD_ADDR_VAR 0 5
6860: PUSH
6861: LD_VAR 0 5
6865: PUSH
6866: LD_VAR 0 3
6870: PUSH
6871: LD_VAR 0 4
6875: ARRAY
6876: PPUSH
6877: CALL_OW 266
6881: PUSH
6882: LD_VAR 0 3
6886: PUSH
6887: LD_VAR 0 4
6891: ARRAY
6892: PPUSH
6893: CALL_OW 250
6897: PUSH
6898: LD_VAR 0 3
6902: PUSH
6903: LD_VAR 0 4
6907: ARRAY
6908: PPUSH
6909: CALL_OW 251
6913: PUSH
6914: LD_VAR 0 3
6918: PUSH
6919: LD_VAR 0 4
6923: ARRAY
6924: PPUSH
6925: CALL_OW 254
6929: PUSH
6930: EMPTY
6931: LIST
6932: LIST
6933: LIST
6934: LIST
6935: PUSH
6936: EMPTY
6937: LIST
6938: ADD
6939: ST_TO_ADDR
6940: GO 6853
6942: POP
6943: POP
// result := list ;
6944: LD_ADDR_VAR 0 2
6948: PUSH
6949: LD_VAR 0 5
6953: ST_TO_ADDR
// end ;
6954: LD_VAR 0 2
6958: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
6959: LD_INT 0
6961: PPUSH
6962: PPUSH
6963: PPUSH
6964: PPUSH
6965: PPUSH
6966: PPUSH
6967: PPUSH
// if not factory then
6968: LD_VAR 0 1
6972: NOT
6973: IFFALSE 6977
// exit ;
6975: GO 7570
// if control = control_apeman then
6977: LD_VAR 0 4
6981: PUSH
6982: LD_INT 5
6984: EQUAL
6985: IFFALSE 7094
// begin tmp := UnitsInside ( factory ) ;
6987: LD_ADDR_VAR 0 8
6991: PUSH
6992: LD_VAR 0 1
6996: PPUSH
6997: CALL_OW 313
7001: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
7002: LD_VAR 0 8
7006: PPUSH
7007: LD_INT 25
7009: PUSH
7010: LD_INT 12
7012: PUSH
7013: EMPTY
7014: LIST
7015: LIST
7016: PPUSH
7017: CALL_OW 72
7021: NOT
7022: IFFALSE 7032
// control := control_manual ;
7024: LD_ADDR_VAR 0 4
7028: PUSH
7029: LD_INT 1
7031: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
7032: LD_ADDR_VAR 0 8
7036: PUSH
7037: LD_VAR 0 1
7041: PPUSH
7042: CALL 6729 0 1
7046: ST_TO_ADDR
// if tmp then
7047: LD_VAR 0 8
7051: IFFALSE 7094
// begin for i in tmp do
7053: LD_ADDR_VAR 0 7
7057: PUSH
7058: LD_VAR 0 8
7062: PUSH
7063: FOR_IN
7064: IFFALSE 7092
// if i [ 1 ] = b_ext_radio then
7066: LD_VAR 0 7
7070: PUSH
7071: LD_INT 1
7073: ARRAY
7074: PUSH
7075: LD_INT 22
7077: EQUAL
7078: IFFALSE 7090
// begin control := control_remote ;
7080: LD_ADDR_VAR 0 4
7084: PUSH
7085: LD_INT 2
7087: ST_TO_ADDR
// break ;
7088: GO 7092
// end ;
7090: GO 7063
7092: POP
7093: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
7094: LD_VAR 0 1
7098: PPUSH
7099: LD_VAR 0 2
7103: PPUSH
7104: LD_VAR 0 3
7108: PPUSH
7109: LD_VAR 0 4
7113: PPUSH
7114: LD_VAR 0 5
7118: PPUSH
7119: CALL_OW 448
7123: IFFALSE 7158
// begin result := [ chassis , engine , control , weapon ] ;
7125: LD_ADDR_VAR 0 6
7129: PUSH
7130: LD_VAR 0 2
7134: PUSH
7135: LD_VAR 0 3
7139: PUSH
7140: LD_VAR 0 4
7144: PUSH
7145: LD_VAR 0 5
7149: PUSH
7150: EMPTY
7151: LIST
7152: LIST
7153: LIST
7154: LIST
7155: ST_TO_ADDR
// exit ;
7156: GO 7570
// end ; _chassis := AvailableChassisList ( factory ) ;
7158: LD_ADDR_VAR 0 9
7162: PUSH
7163: LD_VAR 0 1
7167: PPUSH
7168: CALL_OW 475
7172: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
7173: LD_ADDR_VAR 0 11
7177: PUSH
7178: LD_VAR 0 1
7182: PPUSH
7183: CALL_OW 476
7187: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
7188: LD_ADDR_VAR 0 12
7192: PUSH
7193: LD_VAR 0 1
7197: PPUSH
7198: CALL_OW 477
7202: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
7203: LD_ADDR_VAR 0 10
7207: PUSH
7208: LD_VAR 0 1
7212: PPUSH
7213: CALL_OW 478
7217: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
7218: LD_VAR 0 9
7222: NOT
7223: PUSH
7224: LD_VAR 0 11
7228: NOT
7229: OR
7230: PUSH
7231: LD_VAR 0 12
7235: NOT
7236: OR
7237: PUSH
7238: LD_VAR 0 10
7242: NOT
7243: OR
7244: IFFALSE 7279
// begin result := [ chassis , engine , control , weapon ] ;
7246: LD_ADDR_VAR 0 6
7250: PUSH
7251: LD_VAR 0 2
7255: PUSH
7256: LD_VAR 0 3
7260: PUSH
7261: LD_VAR 0 4
7265: PUSH
7266: LD_VAR 0 5
7270: PUSH
7271: EMPTY
7272: LIST
7273: LIST
7274: LIST
7275: LIST
7276: ST_TO_ADDR
// exit ;
7277: GO 7570
// end ; if not chassis in _chassis then
7279: LD_VAR 0 2
7283: PUSH
7284: LD_VAR 0 9
7288: IN
7289: NOT
7290: IFFALSE 7316
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
7292: LD_ADDR_VAR 0 2
7296: PUSH
7297: LD_VAR 0 9
7301: PUSH
7302: LD_INT 1
7304: PPUSH
7305: LD_VAR 0 9
7309: PPUSH
7310: CALL_OW 12
7314: ARRAY
7315: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
7316: LD_VAR 0 2
7320: PPUSH
7321: LD_VAR 0 3
7325: PPUSH
7326: CALL 7575 0 2
7330: NOT
7331: IFFALSE 7390
// repeat engine := _engine [ 1 ] ;
7333: LD_ADDR_VAR 0 3
7337: PUSH
7338: LD_VAR 0 11
7342: PUSH
7343: LD_INT 1
7345: ARRAY
7346: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
7347: LD_ADDR_VAR 0 11
7351: PUSH
7352: LD_VAR 0 11
7356: PPUSH
7357: LD_INT 1
7359: PPUSH
7360: CALL_OW 3
7364: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
7365: LD_VAR 0 2
7369: PPUSH
7370: LD_VAR 0 3
7374: PPUSH
7375: CALL 7575 0 2
7379: PUSH
7380: LD_VAR 0 11
7384: PUSH
7385: EMPTY
7386: EQUAL
7387: OR
7388: IFFALSE 7333
// if not control in _control then
7390: LD_VAR 0 4
7394: PUSH
7395: LD_VAR 0 12
7399: IN
7400: NOT
7401: IFFALSE 7427
// control := _control [ rand ( 1 , _control ) ] ;
7403: LD_ADDR_VAR 0 4
7407: PUSH
7408: LD_VAR 0 12
7412: PUSH
7413: LD_INT 1
7415: PPUSH
7416: LD_VAR 0 12
7420: PPUSH
7421: CALL_OW 12
7425: ARRAY
7426: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
7427: LD_VAR 0 2
7431: PPUSH
7432: LD_VAR 0 5
7436: PPUSH
7437: CALL 7795 0 2
7441: NOT
7442: IFFALSE 7501
// repeat weapon := _weapon [ 1 ] ;
7444: LD_ADDR_VAR 0 5
7448: PUSH
7449: LD_VAR 0 10
7453: PUSH
7454: LD_INT 1
7456: ARRAY
7457: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
7458: LD_ADDR_VAR 0 10
7462: PUSH
7463: LD_VAR 0 10
7467: PPUSH
7468: LD_INT 1
7470: PPUSH
7471: CALL_OW 3
7475: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
7476: LD_VAR 0 2
7480: PPUSH
7481: LD_VAR 0 5
7485: PPUSH
7486: CALL 7795 0 2
7490: PUSH
7491: LD_VAR 0 10
7495: PUSH
7496: EMPTY
7497: EQUAL
7498: OR
7499: IFFALSE 7444
// result := [ ] ;
7501: LD_ADDR_VAR 0 6
7505: PUSH
7506: EMPTY
7507: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
7508: LD_VAR 0 1
7512: PPUSH
7513: LD_VAR 0 2
7517: PPUSH
7518: LD_VAR 0 3
7522: PPUSH
7523: LD_VAR 0 4
7527: PPUSH
7528: LD_VAR 0 5
7532: PPUSH
7533: CALL_OW 448
7537: IFFALSE 7570
// result := [ chassis , engine , control , weapon ] ;
7539: LD_ADDR_VAR 0 6
7543: PUSH
7544: LD_VAR 0 2
7548: PUSH
7549: LD_VAR 0 3
7553: PUSH
7554: LD_VAR 0 4
7558: PUSH
7559: LD_VAR 0 5
7563: PUSH
7564: EMPTY
7565: LIST
7566: LIST
7567: LIST
7568: LIST
7569: ST_TO_ADDR
// end ;
7570: LD_VAR 0 6
7574: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
7575: LD_INT 0
7577: PPUSH
// if not chassis or not engine then
7578: LD_VAR 0 1
7582: NOT
7583: PUSH
7584: LD_VAR 0 2
7588: NOT
7589: OR
7590: IFFALSE 7594
// exit ;
7592: GO 7790
// case engine of engine_solar :
7594: LD_VAR 0 2
7598: PUSH
7599: LD_INT 2
7601: DOUBLE
7602: EQUAL
7603: IFTRUE 7607
7605: GO 7645
7607: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
7608: LD_ADDR_VAR 0 3
7612: PUSH
7613: LD_INT 11
7615: PUSH
7616: LD_INT 12
7618: PUSH
7619: LD_INT 13
7621: PUSH
7622: LD_INT 14
7624: PUSH
7625: LD_INT 1
7627: PUSH
7628: LD_INT 2
7630: PUSH
7631: LD_INT 3
7633: PUSH
7634: EMPTY
7635: LIST
7636: LIST
7637: LIST
7638: LIST
7639: LIST
7640: LIST
7641: LIST
7642: ST_TO_ADDR
7643: GO 7774
7645: LD_INT 1
7647: DOUBLE
7648: EQUAL
7649: IFTRUE 7653
7651: GO 7715
7653: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
7654: LD_ADDR_VAR 0 3
7658: PUSH
7659: LD_INT 11
7661: PUSH
7662: LD_INT 12
7664: PUSH
7665: LD_INT 13
7667: PUSH
7668: LD_INT 14
7670: PUSH
7671: LD_INT 1
7673: PUSH
7674: LD_INT 2
7676: PUSH
7677: LD_INT 3
7679: PUSH
7680: LD_INT 4
7682: PUSH
7683: LD_INT 5
7685: PUSH
7686: LD_INT 21
7688: PUSH
7689: LD_INT 23
7691: PUSH
7692: LD_INT 22
7694: PUSH
7695: LD_INT 24
7697: PUSH
7698: EMPTY
7699: LIST
7700: LIST
7701: LIST
7702: LIST
7703: LIST
7704: LIST
7705: LIST
7706: LIST
7707: LIST
7708: LIST
7709: LIST
7710: LIST
7711: LIST
7712: ST_TO_ADDR
7713: GO 7774
7715: LD_INT 3
7717: DOUBLE
7718: EQUAL
7719: IFTRUE 7723
7721: GO 7773
7723: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
7724: LD_ADDR_VAR 0 3
7728: PUSH
7729: LD_INT 13
7731: PUSH
7732: LD_INT 14
7734: PUSH
7735: LD_INT 2
7737: PUSH
7738: LD_INT 3
7740: PUSH
7741: LD_INT 4
7743: PUSH
7744: LD_INT 5
7746: PUSH
7747: LD_INT 21
7749: PUSH
7750: LD_INT 22
7752: PUSH
7753: LD_INT 23
7755: PUSH
7756: LD_INT 24
7758: PUSH
7759: EMPTY
7760: LIST
7761: LIST
7762: LIST
7763: LIST
7764: LIST
7765: LIST
7766: LIST
7767: LIST
7768: LIST
7769: LIST
7770: ST_TO_ADDR
7771: GO 7774
7773: POP
// result := ( chassis in result ) ;
7774: LD_ADDR_VAR 0 3
7778: PUSH
7779: LD_VAR 0 1
7783: PUSH
7784: LD_VAR 0 3
7788: IN
7789: ST_TO_ADDR
// end ;
7790: LD_VAR 0 3
7794: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
7795: LD_INT 0
7797: PPUSH
// if not chassis or not weapon then
7798: LD_VAR 0 1
7802: NOT
7803: PUSH
7804: LD_VAR 0 2
7808: NOT
7809: OR
7810: IFFALSE 7814
// exit ;
7812: GO 8840
// case weapon of us_machine_gun :
7814: LD_VAR 0 2
7818: PUSH
7819: LD_INT 2
7821: DOUBLE
7822: EQUAL
7823: IFTRUE 7827
7825: GO 7857
7827: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
7828: LD_ADDR_VAR 0 3
7832: PUSH
7833: LD_INT 1
7835: PUSH
7836: LD_INT 2
7838: PUSH
7839: LD_INT 3
7841: PUSH
7842: LD_INT 4
7844: PUSH
7845: LD_INT 5
7847: PUSH
7848: EMPTY
7849: LIST
7850: LIST
7851: LIST
7852: LIST
7853: LIST
7854: ST_TO_ADDR
7855: GO 8824
7857: LD_INT 3
7859: DOUBLE
7860: EQUAL
7861: IFTRUE 7865
7863: GO 7895
7865: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
7866: LD_ADDR_VAR 0 3
7870: PUSH
7871: LD_INT 1
7873: PUSH
7874: LD_INT 2
7876: PUSH
7877: LD_INT 3
7879: PUSH
7880: LD_INT 4
7882: PUSH
7883: LD_INT 5
7885: PUSH
7886: EMPTY
7887: LIST
7888: LIST
7889: LIST
7890: LIST
7891: LIST
7892: ST_TO_ADDR
7893: GO 8824
7895: LD_INT 11
7897: DOUBLE
7898: EQUAL
7899: IFTRUE 7903
7901: GO 7933
7903: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
7904: LD_ADDR_VAR 0 3
7908: PUSH
7909: LD_INT 1
7911: PUSH
7912: LD_INT 2
7914: PUSH
7915: LD_INT 3
7917: PUSH
7918: LD_INT 4
7920: PUSH
7921: LD_INT 5
7923: PUSH
7924: EMPTY
7925: LIST
7926: LIST
7927: LIST
7928: LIST
7929: LIST
7930: ST_TO_ADDR
7931: GO 8824
7933: LD_INT 4
7935: DOUBLE
7936: EQUAL
7937: IFTRUE 7941
7939: GO 7967
7941: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
7942: LD_ADDR_VAR 0 3
7946: PUSH
7947: LD_INT 2
7949: PUSH
7950: LD_INT 3
7952: PUSH
7953: LD_INT 4
7955: PUSH
7956: LD_INT 5
7958: PUSH
7959: EMPTY
7960: LIST
7961: LIST
7962: LIST
7963: LIST
7964: ST_TO_ADDR
7965: GO 8824
7967: LD_INT 5
7969: DOUBLE
7970: EQUAL
7971: IFTRUE 7975
7973: GO 8001
7975: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
7976: LD_ADDR_VAR 0 3
7980: PUSH
7981: LD_INT 2
7983: PUSH
7984: LD_INT 3
7986: PUSH
7987: LD_INT 4
7989: PUSH
7990: LD_INT 5
7992: PUSH
7993: EMPTY
7994: LIST
7995: LIST
7996: LIST
7997: LIST
7998: ST_TO_ADDR
7999: GO 8824
8001: LD_INT 9
8003: DOUBLE
8004: EQUAL
8005: IFTRUE 8009
8007: GO 8035
8009: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
8010: LD_ADDR_VAR 0 3
8014: PUSH
8015: LD_INT 2
8017: PUSH
8018: LD_INT 3
8020: PUSH
8021: LD_INT 4
8023: PUSH
8024: LD_INT 5
8026: PUSH
8027: EMPTY
8028: LIST
8029: LIST
8030: LIST
8031: LIST
8032: ST_TO_ADDR
8033: GO 8824
8035: LD_INT 7
8037: DOUBLE
8038: EQUAL
8039: IFTRUE 8043
8041: GO 8069
8043: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
8044: LD_ADDR_VAR 0 3
8048: PUSH
8049: LD_INT 2
8051: PUSH
8052: LD_INT 3
8054: PUSH
8055: LD_INT 4
8057: PUSH
8058: LD_INT 5
8060: PUSH
8061: EMPTY
8062: LIST
8063: LIST
8064: LIST
8065: LIST
8066: ST_TO_ADDR
8067: GO 8824
8069: LD_INT 12
8071: DOUBLE
8072: EQUAL
8073: IFTRUE 8077
8075: GO 8103
8077: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
8078: LD_ADDR_VAR 0 3
8082: PUSH
8083: LD_INT 2
8085: PUSH
8086: LD_INT 3
8088: PUSH
8089: LD_INT 4
8091: PUSH
8092: LD_INT 5
8094: PUSH
8095: EMPTY
8096: LIST
8097: LIST
8098: LIST
8099: LIST
8100: ST_TO_ADDR
8101: GO 8824
8103: LD_INT 13
8105: DOUBLE
8106: EQUAL
8107: IFTRUE 8111
8109: GO 8137
8111: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
8112: LD_ADDR_VAR 0 3
8116: PUSH
8117: LD_INT 2
8119: PUSH
8120: LD_INT 3
8122: PUSH
8123: LD_INT 4
8125: PUSH
8126: LD_INT 5
8128: PUSH
8129: EMPTY
8130: LIST
8131: LIST
8132: LIST
8133: LIST
8134: ST_TO_ADDR
8135: GO 8824
8137: LD_INT 14
8139: DOUBLE
8140: EQUAL
8141: IFTRUE 8145
8143: GO 8163
8145: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
8146: LD_ADDR_VAR 0 3
8150: PUSH
8151: LD_INT 4
8153: PUSH
8154: LD_INT 5
8156: PUSH
8157: EMPTY
8158: LIST
8159: LIST
8160: ST_TO_ADDR
8161: GO 8824
8163: LD_INT 6
8165: DOUBLE
8166: EQUAL
8167: IFTRUE 8171
8169: GO 8189
8171: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
8172: LD_ADDR_VAR 0 3
8176: PUSH
8177: LD_INT 4
8179: PUSH
8180: LD_INT 5
8182: PUSH
8183: EMPTY
8184: LIST
8185: LIST
8186: ST_TO_ADDR
8187: GO 8824
8189: LD_INT 10
8191: DOUBLE
8192: EQUAL
8193: IFTRUE 8197
8195: GO 8215
8197: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
8198: LD_ADDR_VAR 0 3
8202: PUSH
8203: LD_INT 4
8205: PUSH
8206: LD_INT 5
8208: PUSH
8209: EMPTY
8210: LIST
8211: LIST
8212: ST_TO_ADDR
8213: GO 8824
8215: LD_INT 22
8217: DOUBLE
8218: EQUAL
8219: IFTRUE 8223
8221: GO 8249
8223: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
8224: LD_ADDR_VAR 0 3
8228: PUSH
8229: LD_INT 11
8231: PUSH
8232: LD_INT 12
8234: PUSH
8235: LD_INT 13
8237: PUSH
8238: LD_INT 14
8240: PUSH
8241: EMPTY
8242: LIST
8243: LIST
8244: LIST
8245: LIST
8246: ST_TO_ADDR
8247: GO 8824
8249: LD_INT 23
8251: DOUBLE
8252: EQUAL
8253: IFTRUE 8257
8255: GO 8283
8257: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
8258: LD_ADDR_VAR 0 3
8262: PUSH
8263: LD_INT 11
8265: PUSH
8266: LD_INT 12
8268: PUSH
8269: LD_INT 13
8271: PUSH
8272: LD_INT 14
8274: PUSH
8275: EMPTY
8276: LIST
8277: LIST
8278: LIST
8279: LIST
8280: ST_TO_ADDR
8281: GO 8824
8283: LD_INT 24
8285: DOUBLE
8286: EQUAL
8287: IFTRUE 8291
8289: GO 8317
8291: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
8292: LD_ADDR_VAR 0 3
8296: PUSH
8297: LD_INT 11
8299: PUSH
8300: LD_INT 12
8302: PUSH
8303: LD_INT 13
8305: PUSH
8306: LD_INT 14
8308: PUSH
8309: EMPTY
8310: LIST
8311: LIST
8312: LIST
8313: LIST
8314: ST_TO_ADDR
8315: GO 8824
8317: LD_INT 30
8319: DOUBLE
8320: EQUAL
8321: IFTRUE 8325
8323: GO 8351
8325: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
8326: LD_ADDR_VAR 0 3
8330: PUSH
8331: LD_INT 11
8333: PUSH
8334: LD_INT 12
8336: PUSH
8337: LD_INT 13
8339: PUSH
8340: LD_INT 14
8342: PUSH
8343: EMPTY
8344: LIST
8345: LIST
8346: LIST
8347: LIST
8348: ST_TO_ADDR
8349: GO 8824
8351: LD_INT 25
8353: DOUBLE
8354: EQUAL
8355: IFTRUE 8359
8357: GO 8377
8359: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
8360: LD_ADDR_VAR 0 3
8364: PUSH
8365: LD_INT 13
8367: PUSH
8368: LD_INT 14
8370: PUSH
8371: EMPTY
8372: LIST
8373: LIST
8374: ST_TO_ADDR
8375: GO 8824
8377: LD_INT 27
8379: DOUBLE
8380: EQUAL
8381: IFTRUE 8385
8383: GO 8403
8385: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
8386: LD_ADDR_VAR 0 3
8390: PUSH
8391: LD_INT 13
8393: PUSH
8394: LD_INT 14
8396: PUSH
8397: EMPTY
8398: LIST
8399: LIST
8400: ST_TO_ADDR
8401: GO 8824
8403: LD_INT 28
8405: DOUBLE
8406: EQUAL
8407: IFTRUE 8411
8409: GO 8429
8411: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
8412: LD_ADDR_VAR 0 3
8416: PUSH
8417: LD_INT 13
8419: PUSH
8420: LD_INT 14
8422: PUSH
8423: EMPTY
8424: LIST
8425: LIST
8426: ST_TO_ADDR
8427: GO 8824
8429: LD_INT 29
8431: DOUBLE
8432: EQUAL
8433: IFTRUE 8437
8435: GO 8455
8437: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
8438: LD_ADDR_VAR 0 3
8442: PUSH
8443: LD_INT 13
8445: PUSH
8446: LD_INT 14
8448: PUSH
8449: EMPTY
8450: LIST
8451: LIST
8452: ST_TO_ADDR
8453: GO 8824
8455: LD_INT 31
8457: DOUBLE
8458: EQUAL
8459: IFTRUE 8463
8461: GO 8481
8463: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
8464: LD_ADDR_VAR 0 3
8468: PUSH
8469: LD_INT 13
8471: PUSH
8472: LD_INT 14
8474: PUSH
8475: EMPTY
8476: LIST
8477: LIST
8478: ST_TO_ADDR
8479: GO 8824
8481: LD_INT 26
8483: DOUBLE
8484: EQUAL
8485: IFTRUE 8489
8487: GO 8507
8489: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
8490: LD_ADDR_VAR 0 3
8494: PUSH
8495: LD_INT 13
8497: PUSH
8498: LD_INT 14
8500: PUSH
8501: EMPTY
8502: LIST
8503: LIST
8504: ST_TO_ADDR
8505: GO 8824
8507: LD_INT 42
8509: DOUBLE
8510: EQUAL
8511: IFTRUE 8515
8513: GO 8541
8515: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
8516: LD_ADDR_VAR 0 3
8520: PUSH
8521: LD_INT 21
8523: PUSH
8524: LD_INT 22
8526: PUSH
8527: LD_INT 23
8529: PUSH
8530: LD_INT 24
8532: PUSH
8533: EMPTY
8534: LIST
8535: LIST
8536: LIST
8537: LIST
8538: ST_TO_ADDR
8539: GO 8824
8541: LD_INT 43
8543: DOUBLE
8544: EQUAL
8545: IFTRUE 8549
8547: GO 8575
8549: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
8550: LD_ADDR_VAR 0 3
8554: PUSH
8555: LD_INT 21
8557: PUSH
8558: LD_INT 22
8560: PUSH
8561: LD_INT 23
8563: PUSH
8564: LD_INT 24
8566: PUSH
8567: EMPTY
8568: LIST
8569: LIST
8570: LIST
8571: LIST
8572: ST_TO_ADDR
8573: GO 8824
8575: LD_INT 44
8577: DOUBLE
8578: EQUAL
8579: IFTRUE 8583
8581: GO 8609
8583: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
8584: LD_ADDR_VAR 0 3
8588: PUSH
8589: LD_INT 21
8591: PUSH
8592: LD_INT 22
8594: PUSH
8595: LD_INT 23
8597: PUSH
8598: LD_INT 24
8600: PUSH
8601: EMPTY
8602: LIST
8603: LIST
8604: LIST
8605: LIST
8606: ST_TO_ADDR
8607: GO 8824
8609: LD_INT 45
8611: DOUBLE
8612: EQUAL
8613: IFTRUE 8617
8615: GO 8643
8617: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
8618: LD_ADDR_VAR 0 3
8622: PUSH
8623: LD_INT 21
8625: PUSH
8626: LD_INT 22
8628: PUSH
8629: LD_INT 23
8631: PUSH
8632: LD_INT 24
8634: PUSH
8635: EMPTY
8636: LIST
8637: LIST
8638: LIST
8639: LIST
8640: ST_TO_ADDR
8641: GO 8824
8643: LD_INT 49
8645: DOUBLE
8646: EQUAL
8647: IFTRUE 8651
8649: GO 8677
8651: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
8652: LD_ADDR_VAR 0 3
8656: PUSH
8657: LD_INT 21
8659: PUSH
8660: LD_INT 22
8662: PUSH
8663: LD_INT 23
8665: PUSH
8666: LD_INT 24
8668: PUSH
8669: EMPTY
8670: LIST
8671: LIST
8672: LIST
8673: LIST
8674: ST_TO_ADDR
8675: GO 8824
8677: LD_INT 51
8679: DOUBLE
8680: EQUAL
8681: IFTRUE 8685
8683: GO 8711
8685: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
8686: LD_ADDR_VAR 0 3
8690: PUSH
8691: LD_INT 21
8693: PUSH
8694: LD_INT 22
8696: PUSH
8697: LD_INT 23
8699: PUSH
8700: LD_INT 24
8702: PUSH
8703: EMPTY
8704: LIST
8705: LIST
8706: LIST
8707: LIST
8708: ST_TO_ADDR
8709: GO 8824
8711: LD_INT 52
8713: DOUBLE
8714: EQUAL
8715: IFTRUE 8719
8717: GO 8745
8719: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
8720: LD_ADDR_VAR 0 3
8724: PUSH
8725: LD_INT 21
8727: PUSH
8728: LD_INT 22
8730: PUSH
8731: LD_INT 23
8733: PUSH
8734: LD_INT 24
8736: PUSH
8737: EMPTY
8738: LIST
8739: LIST
8740: LIST
8741: LIST
8742: ST_TO_ADDR
8743: GO 8824
8745: LD_INT 53
8747: DOUBLE
8748: EQUAL
8749: IFTRUE 8753
8751: GO 8771
8753: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
8754: LD_ADDR_VAR 0 3
8758: PUSH
8759: LD_INT 23
8761: PUSH
8762: LD_INT 24
8764: PUSH
8765: EMPTY
8766: LIST
8767: LIST
8768: ST_TO_ADDR
8769: GO 8824
8771: LD_INT 46
8773: DOUBLE
8774: EQUAL
8775: IFTRUE 8779
8777: GO 8797
8779: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
8780: LD_ADDR_VAR 0 3
8784: PUSH
8785: LD_INT 23
8787: PUSH
8788: LD_INT 24
8790: PUSH
8791: EMPTY
8792: LIST
8793: LIST
8794: ST_TO_ADDR
8795: GO 8824
8797: LD_INT 47
8799: DOUBLE
8800: EQUAL
8801: IFTRUE 8805
8803: GO 8823
8805: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
8806: LD_ADDR_VAR 0 3
8810: PUSH
8811: LD_INT 23
8813: PUSH
8814: LD_INT 24
8816: PUSH
8817: EMPTY
8818: LIST
8819: LIST
8820: ST_TO_ADDR
8821: GO 8824
8823: POP
// result := ( chassis in result ) ;
8824: LD_ADDR_VAR 0 3
8828: PUSH
8829: LD_VAR 0 1
8833: PUSH
8834: LD_VAR 0 3
8838: IN
8839: ST_TO_ADDR
// end ;
8840: LD_VAR 0 3
8844: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
8845: LD_INT 0
8847: PPUSH
8848: PPUSH
8849: PPUSH
8850: PPUSH
8851: PPUSH
8852: PPUSH
8853: PPUSH
// result := array ;
8854: LD_ADDR_VAR 0 5
8858: PUSH
8859: LD_VAR 0 1
8863: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
8864: LD_VAR 0 1
8868: NOT
8869: PUSH
8870: LD_VAR 0 2
8874: NOT
8875: OR
8876: PUSH
8877: LD_VAR 0 3
8881: NOT
8882: OR
8883: PUSH
8884: LD_VAR 0 2
8888: PUSH
8889: LD_VAR 0 1
8893: GREATER
8894: OR
8895: PUSH
8896: LD_VAR 0 3
8900: PUSH
8901: LD_VAR 0 1
8905: GREATER
8906: OR
8907: IFFALSE 8911
// exit ;
8909: GO 9207
// if direction then
8911: LD_VAR 0 4
8915: IFFALSE 8979
// begin d := 1 ;
8917: LD_ADDR_VAR 0 9
8921: PUSH
8922: LD_INT 1
8924: ST_TO_ADDR
// if i_from > i_to then
8925: LD_VAR 0 2
8929: PUSH
8930: LD_VAR 0 3
8934: GREATER
8935: IFFALSE 8961
// length := ( array - i_from ) + i_to else
8937: LD_ADDR_VAR 0 11
8941: PUSH
8942: LD_VAR 0 1
8946: PUSH
8947: LD_VAR 0 2
8951: MINUS
8952: PUSH
8953: LD_VAR 0 3
8957: PLUS
8958: ST_TO_ADDR
8959: GO 8977
// length := i_to - i_from ;
8961: LD_ADDR_VAR 0 11
8965: PUSH
8966: LD_VAR 0 3
8970: PUSH
8971: LD_VAR 0 2
8975: MINUS
8976: ST_TO_ADDR
// end else
8977: GO 9040
// begin d := - 1 ;
8979: LD_ADDR_VAR 0 9
8983: PUSH
8984: LD_INT 1
8986: NEG
8987: ST_TO_ADDR
// if i_from > i_to then
8988: LD_VAR 0 2
8992: PUSH
8993: LD_VAR 0 3
8997: GREATER
8998: IFFALSE 9018
// length := i_from - i_to else
9000: LD_ADDR_VAR 0 11
9004: PUSH
9005: LD_VAR 0 2
9009: PUSH
9010: LD_VAR 0 3
9014: MINUS
9015: ST_TO_ADDR
9016: GO 9040
// length := ( array - i_to ) + i_from ;
9018: LD_ADDR_VAR 0 11
9022: PUSH
9023: LD_VAR 0 1
9027: PUSH
9028: LD_VAR 0 3
9032: MINUS
9033: PUSH
9034: LD_VAR 0 2
9038: PLUS
9039: ST_TO_ADDR
// end ; if not length then
9040: LD_VAR 0 11
9044: NOT
9045: IFFALSE 9049
// exit ;
9047: GO 9207
// tmp := array ;
9049: LD_ADDR_VAR 0 10
9053: PUSH
9054: LD_VAR 0 1
9058: ST_TO_ADDR
// for i = 1 to length do
9059: LD_ADDR_VAR 0 6
9063: PUSH
9064: DOUBLE
9065: LD_INT 1
9067: DEC
9068: ST_TO_ADDR
9069: LD_VAR 0 11
9073: PUSH
9074: FOR_TO
9075: IFFALSE 9195
// begin for j = 1 to array do
9077: LD_ADDR_VAR 0 7
9081: PUSH
9082: DOUBLE
9083: LD_INT 1
9085: DEC
9086: ST_TO_ADDR
9087: LD_VAR 0 1
9091: PUSH
9092: FOR_TO
9093: IFFALSE 9181
// begin k := j + d ;
9095: LD_ADDR_VAR 0 8
9099: PUSH
9100: LD_VAR 0 7
9104: PUSH
9105: LD_VAR 0 9
9109: PLUS
9110: ST_TO_ADDR
// if k > array then
9111: LD_VAR 0 8
9115: PUSH
9116: LD_VAR 0 1
9120: GREATER
9121: IFFALSE 9131
// k := 1 ;
9123: LD_ADDR_VAR 0 8
9127: PUSH
9128: LD_INT 1
9130: ST_TO_ADDR
// if not k then
9131: LD_VAR 0 8
9135: NOT
9136: IFFALSE 9148
// k := array ;
9138: LD_ADDR_VAR 0 8
9142: PUSH
9143: LD_VAR 0 1
9147: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
9148: LD_ADDR_VAR 0 10
9152: PUSH
9153: LD_VAR 0 10
9157: PPUSH
9158: LD_VAR 0 8
9162: PPUSH
9163: LD_VAR 0 1
9167: PUSH
9168: LD_VAR 0 7
9172: ARRAY
9173: PPUSH
9174: CALL_OW 1
9178: ST_TO_ADDR
// end ;
9179: GO 9092
9181: POP
9182: POP
// array := tmp ;
9183: LD_ADDR_VAR 0 1
9187: PUSH
9188: LD_VAR 0 10
9192: ST_TO_ADDR
// end ;
9193: GO 9074
9195: POP
9196: POP
// result := array ;
9197: LD_ADDR_VAR 0 5
9201: PUSH
9202: LD_VAR 0 1
9206: ST_TO_ADDR
// end ;
9207: LD_VAR 0 5
9211: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
9212: LD_INT 0
9214: PPUSH
9215: PPUSH
// result := 0 ;
9216: LD_ADDR_VAR 0 3
9220: PUSH
9221: LD_INT 0
9223: ST_TO_ADDR
// if not array or not value in array then
9224: LD_VAR 0 1
9228: NOT
9229: PUSH
9230: LD_VAR 0 2
9234: PUSH
9235: LD_VAR 0 1
9239: IN
9240: NOT
9241: OR
9242: IFFALSE 9246
// exit ;
9244: GO 9300
// for i = 1 to array do
9246: LD_ADDR_VAR 0 4
9250: PUSH
9251: DOUBLE
9252: LD_INT 1
9254: DEC
9255: ST_TO_ADDR
9256: LD_VAR 0 1
9260: PUSH
9261: FOR_TO
9262: IFFALSE 9298
// if value = array [ i ] then
9264: LD_VAR 0 2
9268: PUSH
9269: LD_VAR 0 1
9273: PUSH
9274: LD_VAR 0 4
9278: ARRAY
9279: EQUAL
9280: IFFALSE 9296
// begin result := i ;
9282: LD_ADDR_VAR 0 3
9286: PUSH
9287: LD_VAR 0 4
9291: ST_TO_ADDR
// exit ;
9292: POP
9293: POP
9294: GO 9300
// end ;
9296: GO 9261
9298: POP
9299: POP
// end ;
9300: LD_VAR 0 3
9304: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
9305: LD_INT 0
9307: PPUSH
// vc_chassis := chassis ;
9308: LD_ADDR_OWVAR 37
9312: PUSH
9313: LD_VAR 0 1
9317: ST_TO_ADDR
// vc_engine := engine ;
9318: LD_ADDR_OWVAR 39
9322: PUSH
9323: LD_VAR 0 2
9327: ST_TO_ADDR
// vc_control := control ;
9328: LD_ADDR_OWVAR 38
9332: PUSH
9333: LD_VAR 0 3
9337: ST_TO_ADDR
// vc_weapon := weapon ;
9338: LD_ADDR_OWVAR 40
9342: PUSH
9343: LD_VAR 0 4
9347: ST_TO_ADDR
// vc_fuel_battery := fuel ;
9348: LD_ADDR_OWVAR 41
9352: PUSH
9353: LD_VAR 0 5
9357: ST_TO_ADDR
// end ;
9358: LD_VAR 0 6
9362: RET
// export function WantPlant ( unit ) ; var task ; begin
9363: LD_INT 0
9365: PPUSH
9366: PPUSH
// result := false ;
9367: LD_ADDR_VAR 0 2
9371: PUSH
9372: LD_INT 0
9374: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
9375: LD_ADDR_VAR 0 3
9379: PUSH
9380: LD_VAR 0 1
9384: PPUSH
9385: CALL_OW 437
9389: ST_TO_ADDR
// if task then
9390: LD_VAR 0 3
9394: IFFALSE 9422
// if task [ 1 ] [ 1 ] = p then
9396: LD_VAR 0 3
9400: PUSH
9401: LD_INT 1
9403: ARRAY
9404: PUSH
9405: LD_INT 1
9407: ARRAY
9408: PUSH
9409: LD_STRING p
9411: EQUAL
9412: IFFALSE 9422
// result := true ;
9414: LD_ADDR_VAR 0 2
9418: PUSH
9419: LD_INT 1
9421: ST_TO_ADDR
// end ;
9422: LD_VAR 0 2
9426: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
9427: LD_INT 0
9429: PPUSH
9430: PPUSH
9431: PPUSH
9432: PPUSH
// if pos < 1 then
9433: LD_VAR 0 2
9437: PUSH
9438: LD_INT 1
9440: LESS
9441: IFFALSE 9445
// exit ;
9443: GO 9748
// if pos = 1 then
9445: LD_VAR 0 2
9449: PUSH
9450: LD_INT 1
9452: EQUAL
9453: IFFALSE 9486
// result := Replace ( arr , pos [ 1 ] , value ) else
9455: LD_ADDR_VAR 0 4
9459: PUSH
9460: LD_VAR 0 1
9464: PPUSH
9465: LD_VAR 0 2
9469: PUSH
9470: LD_INT 1
9472: ARRAY
9473: PPUSH
9474: LD_VAR 0 3
9478: PPUSH
9479: CALL_OW 1
9483: ST_TO_ADDR
9484: GO 9748
// begin tmp := arr ;
9486: LD_ADDR_VAR 0 6
9490: PUSH
9491: LD_VAR 0 1
9495: ST_TO_ADDR
// s_arr := [ tmp ] ;
9496: LD_ADDR_VAR 0 7
9500: PUSH
9501: LD_VAR 0 6
9505: PUSH
9506: EMPTY
9507: LIST
9508: ST_TO_ADDR
// for i = 1 to pos - 1 do
9509: LD_ADDR_VAR 0 5
9513: PUSH
9514: DOUBLE
9515: LD_INT 1
9517: DEC
9518: ST_TO_ADDR
9519: LD_VAR 0 2
9523: PUSH
9524: LD_INT 1
9526: MINUS
9527: PUSH
9528: FOR_TO
9529: IFFALSE 9574
// begin tmp := tmp [ pos [ i ] ] ;
9531: LD_ADDR_VAR 0 6
9535: PUSH
9536: LD_VAR 0 6
9540: PUSH
9541: LD_VAR 0 2
9545: PUSH
9546: LD_VAR 0 5
9550: ARRAY
9551: ARRAY
9552: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
9553: LD_ADDR_VAR 0 7
9557: PUSH
9558: LD_VAR 0 7
9562: PUSH
9563: LD_VAR 0 6
9567: PUSH
9568: EMPTY
9569: LIST
9570: ADD
9571: ST_TO_ADDR
// end ;
9572: GO 9528
9574: POP
9575: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
9576: LD_ADDR_VAR 0 6
9580: PUSH
9581: LD_VAR 0 6
9585: PPUSH
9586: LD_VAR 0 2
9590: PUSH
9591: LD_VAR 0 2
9595: ARRAY
9596: PPUSH
9597: LD_VAR 0 3
9601: PPUSH
9602: CALL_OW 1
9606: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
9607: LD_ADDR_VAR 0 7
9611: PUSH
9612: LD_VAR 0 7
9616: PPUSH
9617: LD_VAR 0 7
9621: PPUSH
9622: LD_VAR 0 6
9626: PPUSH
9627: CALL_OW 1
9631: ST_TO_ADDR
// for i = s_arr downto 2 do
9632: LD_ADDR_VAR 0 5
9636: PUSH
9637: DOUBLE
9638: LD_VAR 0 7
9642: INC
9643: ST_TO_ADDR
9644: LD_INT 2
9646: PUSH
9647: FOR_DOWNTO
9648: IFFALSE 9732
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
9650: LD_ADDR_VAR 0 6
9654: PUSH
9655: LD_VAR 0 7
9659: PUSH
9660: LD_VAR 0 5
9664: PUSH
9665: LD_INT 1
9667: MINUS
9668: ARRAY
9669: PPUSH
9670: LD_VAR 0 2
9674: PUSH
9675: LD_VAR 0 5
9679: PUSH
9680: LD_INT 1
9682: MINUS
9683: ARRAY
9684: PPUSH
9685: LD_VAR 0 7
9689: PUSH
9690: LD_VAR 0 5
9694: ARRAY
9695: PPUSH
9696: CALL_OW 1
9700: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
9701: LD_ADDR_VAR 0 7
9705: PUSH
9706: LD_VAR 0 7
9710: PPUSH
9711: LD_VAR 0 5
9715: PUSH
9716: LD_INT 1
9718: MINUS
9719: PPUSH
9720: LD_VAR 0 6
9724: PPUSH
9725: CALL_OW 1
9729: ST_TO_ADDR
// end ;
9730: GO 9647
9732: POP
9733: POP
// result := s_arr [ 1 ] ;
9734: LD_ADDR_VAR 0 4
9738: PUSH
9739: LD_VAR 0 7
9743: PUSH
9744: LD_INT 1
9746: ARRAY
9747: ST_TO_ADDR
// end ; end ;
9748: LD_VAR 0 4
9752: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
9753: LD_INT 0
9755: PPUSH
9756: PPUSH
// if not list then
9757: LD_VAR 0 1
9761: NOT
9762: IFFALSE 9766
// exit ;
9764: GO 9857
// i := list [ pos1 ] ;
9766: LD_ADDR_VAR 0 5
9770: PUSH
9771: LD_VAR 0 1
9775: PUSH
9776: LD_VAR 0 2
9780: ARRAY
9781: ST_TO_ADDR
// if not i then
9782: LD_VAR 0 5
9786: NOT
9787: IFFALSE 9791
// exit ;
9789: GO 9857
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
9791: LD_ADDR_VAR 0 1
9795: PUSH
9796: LD_VAR 0 1
9800: PPUSH
9801: LD_VAR 0 2
9805: PPUSH
9806: LD_VAR 0 1
9810: PUSH
9811: LD_VAR 0 3
9815: ARRAY
9816: PPUSH
9817: CALL_OW 1
9821: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
9822: LD_ADDR_VAR 0 1
9826: PUSH
9827: LD_VAR 0 1
9831: PPUSH
9832: LD_VAR 0 3
9836: PPUSH
9837: LD_VAR 0 5
9841: PPUSH
9842: CALL_OW 1
9846: ST_TO_ADDR
// result := list ;
9847: LD_ADDR_VAR 0 4
9851: PUSH
9852: LD_VAR 0 1
9856: ST_TO_ADDR
// end ;
9857: LD_VAR 0 4
9861: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
9862: LD_INT 0
9864: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
9865: LD_ADDR_VAR 0 5
9869: PUSH
9870: LD_VAR 0 1
9874: PPUSH
9875: CALL_OW 250
9879: PPUSH
9880: LD_VAR 0 1
9884: PPUSH
9885: CALL_OW 251
9889: PPUSH
9890: LD_VAR 0 2
9894: PPUSH
9895: LD_VAR 0 3
9899: PPUSH
9900: LD_VAR 0 4
9904: PPUSH
9905: CALL 9915 0 5
9909: ST_TO_ADDR
// end ;
9910: LD_VAR 0 5
9914: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
9915: LD_INT 0
9917: PPUSH
9918: PPUSH
9919: PPUSH
9920: PPUSH
// if not list then
9921: LD_VAR 0 3
9925: NOT
9926: IFFALSE 9930
// exit ;
9928: GO 10318
// result := [ ] ;
9930: LD_ADDR_VAR 0 6
9934: PUSH
9935: EMPTY
9936: ST_TO_ADDR
// for i in list do
9937: LD_ADDR_VAR 0 7
9941: PUSH
9942: LD_VAR 0 3
9946: PUSH
9947: FOR_IN
9948: IFFALSE 10150
// begin tmp := GetDistUnitXY ( i , x , y ) ;
9950: LD_ADDR_VAR 0 9
9954: PUSH
9955: LD_VAR 0 7
9959: PPUSH
9960: LD_VAR 0 1
9964: PPUSH
9965: LD_VAR 0 2
9969: PPUSH
9970: CALL_OW 297
9974: ST_TO_ADDR
// if not result then
9975: LD_VAR 0 6
9979: NOT
9980: IFFALSE 10006
// result := [ [ i , tmp ] ] else
9982: LD_ADDR_VAR 0 6
9986: PUSH
9987: LD_VAR 0 7
9991: PUSH
9992: LD_VAR 0 9
9996: PUSH
9997: EMPTY
9998: LIST
9999: LIST
10000: PUSH
10001: EMPTY
10002: LIST
10003: ST_TO_ADDR
10004: GO 10148
// begin if result [ result ] [ 2 ] < tmp then
10006: LD_VAR 0 6
10010: PUSH
10011: LD_VAR 0 6
10015: ARRAY
10016: PUSH
10017: LD_INT 2
10019: ARRAY
10020: PUSH
10021: LD_VAR 0 9
10025: LESS
10026: IFFALSE 10068
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
10028: LD_ADDR_VAR 0 6
10032: PUSH
10033: LD_VAR 0 6
10037: PPUSH
10038: LD_VAR 0 6
10042: PUSH
10043: LD_INT 1
10045: PLUS
10046: PPUSH
10047: LD_VAR 0 7
10051: PUSH
10052: LD_VAR 0 9
10056: PUSH
10057: EMPTY
10058: LIST
10059: LIST
10060: PPUSH
10061: CALL_OW 2
10065: ST_TO_ADDR
10066: GO 10148
// for j = 1 to result do
10068: LD_ADDR_VAR 0 8
10072: PUSH
10073: DOUBLE
10074: LD_INT 1
10076: DEC
10077: ST_TO_ADDR
10078: LD_VAR 0 6
10082: PUSH
10083: FOR_TO
10084: IFFALSE 10146
// begin if tmp < result [ j ] [ 2 ] then
10086: LD_VAR 0 9
10090: PUSH
10091: LD_VAR 0 6
10095: PUSH
10096: LD_VAR 0 8
10100: ARRAY
10101: PUSH
10102: LD_INT 2
10104: ARRAY
10105: LESS
10106: IFFALSE 10144
// begin result := Insert ( result , j , [ i , tmp ] ) ;
10108: LD_ADDR_VAR 0 6
10112: PUSH
10113: LD_VAR 0 6
10117: PPUSH
10118: LD_VAR 0 8
10122: PPUSH
10123: LD_VAR 0 7
10127: PUSH
10128: LD_VAR 0 9
10132: PUSH
10133: EMPTY
10134: LIST
10135: LIST
10136: PPUSH
10137: CALL_OW 2
10141: ST_TO_ADDR
// break ;
10142: GO 10146
// end ; end ;
10144: GO 10083
10146: POP
10147: POP
// end ; end ;
10148: GO 9947
10150: POP
10151: POP
// if result and not asc then
10152: LD_VAR 0 6
10156: PUSH
10157: LD_VAR 0 4
10161: NOT
10162: AND
10163: IFFALSE 10238
// begin tmp := result ;
10165: LD_ADDR_VAR 0 9
10169: PUSH
10170: LD_VAR 0 6
10174: ST_TO_ADDR
// for i = tmp downto 1 do
10175: LD_ADDR_VAR 0 7
10179: PUSH
10180: DOUBLE
10181: LD_VAR 0 9
10185: INC
10186: ST_TO_ADDR
10187: LD_INT 1
10189: PUSH
10190: FOR_DOWNTO
10191: IFFALSE 10236
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
10193: LD_ADDR_VAR 0 6
10197: PUSH
10198: LD_VAR 0 6
10202: PPUSH
10203: LD_VAR 0 9
10207: PUSH
10208: LD_VAR 0 7
10212: MINUS
10213: PUSH
10214: LD_INT 1
10216: PLUS
10217: PPUSH
10218: LD_VAR 0 9
10222: PUSH
10223: LD_VAR 0 7
10227: ARRAY
10228: PPUSH
10229: CALL_OW 1
10233: ST_TO_ADDR
10234: GO 10190
10236: POP
10237: POP
// end ; tmp := [ ] ;
10238: LD_ADDR_VAR 0 9
10242: PUSH
10243: EMPTY
10244: ST_TO_ADDR
// if mode then
10245: LD_VAR 0 5
10249: IFFALSE 10318
// begin for i = 1 to result do
10251: LD_ADDR_VAR 0 7
10255: PUSH
10256: DOUBLE
10257: LD_INT 1
10259: DEC
10260: ST_TO_ADDR
10261: LD_VAR 0 6
10265: PUSH
10266: FOR_TO
10267: IFFALSE 10306
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
10269: LD_ADDR_VAR 0 9
10273: PUSH
10274: LD_VAR 0 9
10278: PPUSH
10279: LD_VAR 0 7
10283: PPUSH
10284: LD_VAR 0 6
10288: PUSH
10289: LD_VAR 0 7
10293: ARRAY
10294: PUSH
10295: LD_INT 1
10297: ARRAY
10298: PPUSH
10299: CALL_OW 1
10303: ST_TO_ADDR
10304: GO 10266
10306: POP
10307: POP
// result := tmp ;
10308: LD_ADDR_VAR 0 6
10312: PUSH
10313: LD_VAR 0 9
10317: ST_TO_ADDR
// end ; end ;
10318: LD_VAR 0 6
10322: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
10323: LD_INT 0
10325: PPUSH
10326: PPUSH
10327: PPUSH
10328: PPUSH
10329: PPUSH
10330: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
10331: LD_ADDR_VAR 0 5
10335: PUSH
10336: LD_INT 0
10338: PUSH
10339: LD_INT 0
10341: PUSH
10342: LD_INT 0
10344: PUSH
10345: EMPTY
10346: PUSH
10347: EMPTY
10348: LIST
10349: LIST
10350: LIST
10351: LIST
10352: ST_TO_ADDR
// if not x or not y then
10353: LD_VAR 0 2
10357: NOT
10358: PUSH
10359: LD_VAR 0 3
10363: NOT
10364: OR
10365: IFFALSE 10369
// exit ;
10367: GO 12015
// if not range then
10369: LD_VAR 0 4
10373: NOT
10374: IFFALSE 10384
// range := 10 ;
10376: LD_ADDR_VAR 0 4
10380: PUSH
10381: LD_INT 10
10383: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
10384: LD_ADDR_VAR 0 8
10388: PUSH
10389: LD_INT 81
10391: PUSH
10392: LD_VAR 0 1
10396: PUSH
10397: EMPTY
10398: LIST
10399: LIST
10400: PUSH
10401: LD_INT 92
10403: PUSH
10404: LD_VAR 0 2
10408: PUSH
10409: LD_VAR 0 3
10413: PUSH
10414: LD_VAR 0 4
10418: PUSH
10419: EMPTY
10420: LIST
10421: LIST
10422: LIST
10423: LIST
10424: PUSH
10425: LD_INT 3
10427: PUSH
10428: LD_INT 21
10430: PUSH
10431: LD_INT 3
10433: PUSH
10434: EMPTY
10435: LIST
10436: LIST
10437: PUSH
10438: EMPTY
10439: LIST
10440: LIST
10441: PUSH
10442: EMPTY
10443: LIST
10444: LIST
10445: LIST
10446: PPUSH
10447: CALL_OW 69
10451: ST_TO_ADDR
// if not tmp then
10452: LD_VAR 0 8
10456: NOT
10457: IFFALSE 10461
// exit ;
10459: GO 12015
// for i in tmp do
10461: LD_ADDR_VAR 0 6
10465: PUSH
10466: LD_VAR 0 8
10470: PUSH
10471: FOR_IN
10472: IFFALSE 11990
// begin points := [ 0 , 0 , 0 ] ;
10474: LD_ADDR_VAR 0 9
10478: PUSH
10479: LD_INT 0
10481: PUSH
10482: LD_INT 0
10484: PUSH
10485: LD_INT 0
10487: PUSH
10488: EMPTY
10489: LIST
10490: LIST
10491: LIST
10492: ST_TO_ADDR
// bpoints := 1 ;
10493: LD_ADDR_VAR 0 10
10497: PUSH
10498: LD_INT 1
10500: ST_TO_ADDR
// case GetType ( i ) of unit_human :
10501: LD_VAR 0 6
10505: PPUSH
10506: CALL_OW 247
10510: PUSH
10511: LD_INT 1
10513: DOUBLE
10514: EQUAL
10515: IFTRUE 10519
10517: GO 11097
10519: POP
// begin if GetClass ( i ) = 1 then
10520: LD_VAR 0 6
10524: PPUSH
10525: CALL_OW 257
10529: PUSH
10530: LD_INT 1
10532: EQUAL
10533: IFFALSE 10554
// points := [ 10 , 5 , 3 ] ;
10535: LD_ADDR_VAR 0 9
10539: PUSH
10540: LD_INT 10
10542: PUSH
10543: LD_INT 5
10545: PUSH
10546: LD_INT 3
10548: PUSH
10549: EMPTY
10550: LIST
10551: LIST
10552: LIST
10553: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
10554: LD_VAR 0 6
10558: PPUSH
10559: CALL_OW 257
10563: PUSH
10564: LD_INT 2
10566: PUSH
10567: LD_INT 3
10569: PUSH
10570: LD_INT 4
10572: PUSH
10573: EMPTY
10574: LIST
10575: LIST
10576: LIST
10577: IN
10578: IFFALSE 10599
// points := [ 3 , 2 , 1 ] ;
10580: LD_ADDR_VAR 0 9
10584: PUSH
10585: LD_INT 3
10587: PUSH
10588: LD_INT 2
10590: PUSH
10591: LD_INT 1
10593: PUSH
10594: EMPTY
10595: LIST
10596: LIST
10597: LIST
10598: ST_TO_ADDR
// if GetClass ( i ) = 5 then
10599: LD_VAR 0 6
10603: PPUSH
10604: CALL_OW 257
10608: PUSH
10609: LD_INT 5
10611: EQUAL
10612: IFFALSE 10633
// points := [ 130 , 5 , 2 ] ;
10614: LD_ADDR_VAR 0 9
10618: PUSH
10619: LD_INT 130
10621: PUSH
10622: LD_INT 5
10624: PUSH
10625: LD_INT 2
10627: PUSH
10628: EMPTY
10629: LIST
10630: LIST
10631: LIST
10632: ST_TO_ADDR
// if GetClass ( i ) = 8 then
10633: LD_VAR 0 6
10637: PPUSH
10638: CALL_OW 257
10642: PUSH
10643: LD_INT 8
10645: EQUAL
10646: IFFALSE 10667
// points := [ 35 , 35 , 30 ] ;
10648: LD_ADDR_VAR 0 9
10652: PUSH
10653: LD_INT 35
10655: PUSH
10656: LD_INT 35
10658: PUSH
10659: LD_INT 30
10661: PUSH
10662: EMPTY
10663: LIST
10664: LIST
10665: LIST
10666: ST_TO_ADDR
// if GetClass ( i ) = 9 then
10667: LD_VAR 0 6
10671: PPUSH
10672: CALL_OW 257
10676: PUSH
10677: LD_INT 9
10679: EQUAL
10680: IFFALSE 10701
// points := [ 20 , 55 , 40 ] ;
10682: LD_ADDR_VAR 0 9
10686: PUSH
10687: LD_INT 20
10689: PUSH
10690: LD_INT 55
10692: PUSH
10693: LD_INT 40
10695: PUSH
10696: EMPTY
10697: LIST
10698: LIST
10699: LIST
10700: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
10701: LD_VAR 0 6
10705: PPUSH
10706: CALL_OW 257
10710: PUSH
10711: LD_INT 12
10713: PUSH
10714: LD_INT 16
10716: PUSH
10717: EMPTY
10718: LIST
10719: LIST
10720: IN
10721: IFFALSE 10742
// points := [ 5 , 3 , 2 ] ;
10723: LD_ADDR_VAR 0 9
10727: PUSH
10728: LD_INT 5
10730: PUSH
10731: LD_INT 3
10733: PUSH
10734: LD_INT 2
10736: PUSH
10737: EMPTY
10738: LIST
10739: LIST
10740: LIST
10741: ST_TO_ADDR
// if GetClass ( i ) = 17 then
10742: LD_VAR 0 6
10746: PPUSH
10747: CALL_OW 257
10751: PUSH
10752: LD_INT 17
10754: EQUAL
10755: IFFALSE 10776
// points := [ 100 , 50 , 75 ] ;
10757: LD_ADDR_VAR 0 9
10761: PUSH
10762: LD_INT 100
10764: PUSH
10765: LD_INT 50
10767: PUSH
10768: LD_INT 75
10770: PUSH
10771: EMPTY
10772: LIST
10773: LIST
10774: LIST
10775: ST_TO_ADDR
// if GetClass ( i ) = 15 then
10776: LD_VAR 0 6
10780: PPUSH
10781: CALL_OW 257
10785: PUSH
10786: LD_INT 15
10788: EQUAL
10789: IFFALSE 10810
// points := [ 10 , 5 , 3 ] ;
10791: LD_ADDR_VAR 0 9
10795: PUSH
10796: LD_INT 10
10798: PUSH
10799: LD_INT 5
10801: PUSH
10802: LD_INT 3
10804: PUSH
10805: EMPTY
10806: LIST
10807: LIST
10808: LIST
10809: ST_TO_ADDR
// if GetClass ( i ) = 14 then
10810: LD_VAR 0 6
10814: PPUSH
10815: CALL_OW 257
10819: PUSH
10820: LD_INT 14
10822: EQUAL
10823: IFFALSE 10844
// points := [ 10 , 0 , 0 ] ;
10825: LD_ADDR_VAR 0 9
10829: PUSH
10830: LD_INT 10
10832: PUSH
10833: LD_INT 0
10835: PUSH
10836: LD_INT 0
10838: PUSH
10839: EMPTY
10840: LIST
10841: LIST
10842: LIST
10843: ST_TO_ADDR
// if GetClass ( i ) = 11 then
10844: LD_VAR 0 6
10848: PPUSH
10849: CALL_OW 257
10853: PUSH
10854: LD_INT 11
10856: EQUAL
10857: IFFALSE 10878
// points := [ 30 , 10 , 5 ] ;
10859: LD_ADDR_VAR 0 9
10863: PUSH
10864: LD_INT 30
10866: PUSH
10867: LD_INT 10
10869: PUSH
10870: LD_INT 5
10872: PUSH
10873: EMPTY
10874: LIST
10875: LIST
10876: LIST
10877: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
10878: LD_VAR 0 1
10882: PPUSH
10883: LD_INT 5
10885: PPUSH
10886: CALL_OW 321
10890: PUSH
10891: LD_INT 2
10893: EQUAL
10894: IFFALSE 10911
// bpoints := bpoints * 1.8 ;
10896: LD_ADDR_VAR 0 10
10900: PUSH
10901: LD_VAR 0 10
10905: PUSH
10906: LD_REAL  1.80000000000000E+0000
10909: MUL
10910: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
10911: LD_VAR 0 6
10915: PPUSH
10916: CALL_OW 257
10920: PUSH
10921: LD_INT 1
10923: PUSH
10924: LD_INT 2
10926: PUSH
10927: LD_INT 3
10929: PUSH
10930: LD_INT 4
10932: PUSH
10933: EMPTY
10934: LIST
10935: LIST
10936: LIST
10937: LIST
10938: IN
10939: PUSH
10940: LD_VAR 0 1
10944: PPUSH
10945: LD_INT 51
10947: PPUSH
10948: CALL_OW 321
10952: PUSH
10953: LD_INT 2
10955: EQUAL
10956: AND
10957: IFFALSE 10974
// bpoints := bpoints * 1.2 ;
10959: LD_ADDR_VAR 0 10
10963: PUSH
10964: LD_VAR 0 10
10968: PUSH
10969: LD_REAL  1.20000000000000E+0000
10972: MUL
10973: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
10974: LD_VAR 0 6
10978: PPUSH
10979: CALL_OW 257
10983: PUSH
10984: LD_INT 5
10986: PUSH
10987: LD_INT 7
10989: PUSH
10990: LD_INT 9
10992: PUSH
10993: EMPTY
10994: LIST
10995: LIST
10996: LIST
10997: IN
10998: PUSH
10999: LD_VAR 0 1
11003: PPUSH
11004: LD_INT 52
11006: PPUSH
11007: CALL_OW 321
11011: PUSH
11012: LD_INT 2
11014: EQUAL
11015: AND
11016: IFFALSE 11033
// bpoints := bpoints * 1.5 ;
11018: LD_ADDR_VAR 0 10
11022: PUSH
11023: LD_VAR 0 10
11027: PUSH
11028: LD_REAL  1.50000000000000E+0000
11031: MUL
11032: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
11033: LD_VAR 0 1
11037: PPUSH
11038: LD_INT 66
11040: PPUSH
11041: CALL_OW 321
11045: PUSH
11046: LD_INT 2
11048: EQUAL
11049: IFFALSE 11066
// bpoints := bpoints * 1.1 ;
11051: LD_ADDR_VAR 0 10
11055: PUSH
11056: LD_VAR 0 10
11060: PUSH
11061: LD_REAL  1.10000000000000E+0000
11064: MUL
11065: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
11066: LD_ADDR_VAR 0 10
11070: PUSH
11071: LD_VAR 0 10
11075: PUSH
11076: LD_VAR 0 6
11080: PPUSH
11081: LD_INT 1
11083: PPUSH
11084: CALL_OW 259
11088: PUSH
11089: LD_REAL  1.15000000000000E+0000
11092: MUL
11093: MUL
11094: ST_TO_ADDR
// end ; unit_vehicle :
11095: GO 11919
11097: LD_INT 2
11099: DOUBLE
11100: EQUAL
11101: IFTRUE 11105
11103: GO 11907
11105: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
11106: LD_VAR 0 6
11110: PPUSH
11111: CALL_OW 264
11115: PUSH
11116: LD_INT 2
11118: PUSH
11119: LD_INT 42
11121: PUSH
11122: LD_INT 24
11124: PUSH
11125: EMPTY
11126: LIST
11127: LIST
11128: LIST
11129: IN
11130: IFFALSE 11151
// points := [ 25 , 5 , 3 ] ;
11132: LD_ADDR_VAR 0 9
11136: PUSH
11137: LD_INT 25
11139: PUSH
11140: LD_INT 5
11142: PUSH
11143: LD_INT 3
11145: PUSH
11146: EMPTY
11147: LIST
11148: LIST
11149: LIST
11150: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
11151: LD_VAR 0 6
11155: PPUSH
11156: CALL_OW 264
11160: PUSH
11161: LD_INT 4
11163: PUSH
11164: LD_INT 43
11166: PUSH
11167: LD_INT 25
11169: PUSH
11170: EMPTY
11171: LIST
11172: LIST
11173: LIST
11174: IN
11175: IFFALSE 11196
// points := [ 40 , 15 , 5 ] ;
11177: LD_ADDR_VAR 0 9
11181: PUSH
11182: LD_INT 40
11184: PUSH
11185: LD_INT 15
11187: PUSH
11188: LD_INT 5
11190: PUSH
11191: EMPTY
11192: LIST
11193: LIST
11194: LIST
11195: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
11196: LD_VAR 0 6
11200: PPUSH
11201: CALL_OW 264
11205: PUSH
11206: LD_INT 3
11208: PUSH
11209: LD_INT 23
11211: PUSH
11212: EMPTY
11213: LIST
11214: LIST
11215: IN
11216: IFFALSE 11237
// points := [ 7 , 25 , 8 ] ;
11218: LD_ADDR_VAR 0 9
11222: PUSH
11223: LD_INT 7
11225: PUSH
11226: LD_INT 25
11228: PUSH
11229: LD_INT 8
11231: PUSH
11232: EMPTY
11233: LIST
11234: LIST
11235: LIST
11236: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
11237: LD_VAR 0 6
11241: PPUSH
11242: CALL_OW 264
11246: PUSH
11247: LD_INT 5
11249: PUSH
11250: LD_INT 27
11252: PUSH
11253: LD_INT 44
11255: PUSH
11256: EMPTY
11257: LIST
11258: LIST
11259: LIST
11260: IN
11261: IFFALSE 11282
// points := [ 14 , 50 , 16 ] ;
11263: LD_ADDR_VAR 0 9
11267: PUSH
11268: LD_INT 14
11270: PUSH
11271: LD_INT 50
11273: PUSH
11274: LD_INT 16
11276: PUSH
11277: EMPTY
11278: LIST
11279: LIST
11280: LIST
11281: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
11282: LD_VAR 0 6
11286: PPUSH
11287: CALL_OW 264
11291: PUSH
11292: LD_INT 6
11294: PUSH
11295: LD_INT 46
11297: PUSH
11298: EMPTY
11299: LIST
11300: LIST
11301: IN
11302: IFFALSE 11323
// points := [ 32 , 120 , 70 ] ;
11304: LD_ADDR_VAR 0 9
11308: PUSH
11309: LD_INT 32
11311: PUSH
11312: LD_INT 120
11314: PUSH
11315: LD_INT 70
11317: PUSH
11318: EMPTY
11319: LIST
11320: LIST
11321: LIST
11322: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
11323: LD_VAR 0 6
11327: PPUSH
11328: CALL_OW 264
11332: PUSH
11333: LD_INT 7
11335: PUSH
11336: LD_INT 28
11338: PUSH
11339: LD_INT 45
11341: PUSH
11342: EMPTY
11343: LIST
11344: LIST
11345: LIST
11346: IN
11347: IFFALSE 11368
// points := [ 35 , 20 , 45 ] ;
11349: LD_ADDR_VAR 0 9
11353: PUSH
11354: LD_INT 35
11356: PUSH
11357: LD_INT 20
11359: PUSH
11360: LD_INT 45
11362: PUSH
11363: EMPTY
11364: LIST
11365: LIST
11366: LIST
11367: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
11368: LD_VAR 0 6
11372: PPUSH
11373: CALL_OW 264
11377: PUSH
11378: LD_INT 47
11380: PUSH
11381: EMPTY
11382: LIST
11383: IN
11384: IFFALSE 11405
// points := [ 67 , 45 , 75 ] ;
11386: LD_ADDR_VAR 0 9
11390: PUSH
11391: LD_INT 67
11393: PUSH
11394: LD_INT 45
11396: PUSH
11397: LD_INT 75
11399: PUSH
11400: EMPTY
11401: LIST
11402: LIST
11403: LIST
11404: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
11405: LD_VAR 0 6
11409: PPUSH
11410: CALL_OW 264
11414: PUSH
11415: LD_INT 26
11417: PUSH
11418: EMPTY
11419: LIST
11420: IN
11421: IFFALSE 11442
// points := [ 120 , 30 , 80 ] ;
11423: LD_ADDR_VAR 0 9
11427: PUSH
11428: LD_INT 120
11430: PUSH
11431: LD_INT 30
11433: PUSH
11434: LD_INT 80
11436: PUSH
11437: EMPTY
11438: LIST
11439: LIST
11440: LIST
11441: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
11442: LD_VAR 0 6
11446: PPUSH
11447: CALL_OW 264
11451: PUSH
11452: LD_INT 22
11454: PUSH
11455: EMPTY
11456: LIST
11457: IN
11458: IFFALSE 11479
// points := [ 40 , 1 , 1 ] ;
11460: LD_ADDR_VAR 0 9
11464: PUSH
11465: LD_INT 40
11467: PUSH
11468: LD_INT 1
11470: PUSH
11471: LD_INT 1
11473: PUSH
11474: EMPTY
11475: LIST
11476: LIST
11477: LIST
11478: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
11479: LD_VAR 0 6
11483: PPUSH
11484: CALL_OW 264
11488: PUSH
11489: LD_INT 29
11491: PUSH
11492: EMPTY
11493: LIST
11494: IN
11495: IFFALSE 11516
// points := [ 70 , 200 , 400 ] ;
11497: LD_ADDR_VAR 0 9
11501: PUSH
11502: LD_INT 70
11504: PUSH
11505: LD_INT 200
11507: PUSH
11508: LD_INT 400
11510: PUSH
11511: EMPTY
11512: LIST
11513: LIST
11514: LIST
11515: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
11516: LD_VAR 0 6
11520: PPUSH
11521: CALL_OW 264
11525: PUSH
11526: LD_INT 14
11528: PUSH
11529: LD_INT 53
11531: PUSH
11532: EMPTY
11533: LIST
11534: LIST
11535: IN
11536: IFFALSE 11557
// points := [ 40 , 10 , 20 ] ;
11538: LD_ADDR_VAR 0 9
11542: PUSH
11543: LD_INT 40
11545: PUSH
11546: LD_INT 10
11548: PUSH
11549: LD_INT 20
11551: PUSH
11552: EMPTY
11553: LIST
11554: LIST
11555: LIST
11556: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
11557: LD_VAR 0 6
11561: PPUSH
11562: CALL_OW 264
11566: PUSH
11567: LD_INT 9
11569: PUSH
11570: EMPTY
11571: LIST
11572: IN
11573: IFFALSE 11594
// points := [ 5 , 70 , 20 ] ;
11575: LD_ADDR_VAR 0 9
11579: PUSH
11580: LD_INT 5
11582: PUSH
11583: LD_INT 70
11585: PUSH
11586: LD_INT 20
11588: PUSH
11589: EMPTY
11590: LIST
11591: LIST
11592: LIST
11593: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
11594: LD_VAR 0 6
11598: PPUSH
11599: CALL_OW 264
11603: PUSH
11604: LD_INT 10
11606: PUSH
11607: EMPTY
11608: LIST
11609: IN
11610: IFFALSE 11631
// points := [ 35 , 110 , 70 ] ;
11612: LD_ADDR_VAR 0 9
11616: PUSH
11617: LD_INT 35
11619: PUSH
11620: LD_INT 110
11622: PUSH
11623: LD_INT 70
11625: PUSH
11626: EMPTY
11627: LIST
11628: LIST
11629: LIST
11630: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
11631: LD_VAR 0 6
11635: PPUSH
11636: CALL_OW 265
11640: PUSH
11641: LD_INT 25
11643: EQUAL
11644: IFFALSE 11665
// points := [ 80 , 65 , 100 ] ;
11646: LD_ADDR_VAR 0 9
11650: PUSH
11651: LD_INT 80
11653: PUSH
11654: LD_INT 65
11656: PUSH
11657: LD_INT 100
11659: PUSH
11660: EMPTY
11661: LIST
11662: LIST
11663: LIST
11664: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
11665: LD_VAR 0 6
11669: PPUSH
11670: CALL_OW 263
11674: PUSH
11675: LD_INT 1
11677: EQUAL
11678: IFFALSE 11713
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
11680: LD_ADDR_VAR 0 10
11684: PUSH
11685: LD_VAR 0 10
11689: PUSH
11690: LD_VAR 0 6
11694: PPUSH
11695: CALL_OW 311
11699: PPUSH
11700: LD_INT 3
11702: PPUSH
11703: CALL_OW 259
11707: PUSH
11708: LD_INT 4
11710: MUL
11711: MUL
11712: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
11713: LD_VAR 0 6
11717: PPUSH
11718: CALL_OW 263
11722: PUSH
11723: LD_INT 2
11725: EQUAL
11726: IFFALSE 11777
// begin j := IsControledBy ( i ) ;
11728: LD_ADDR_VAR 0 7
11732: PUSH
11733: LD_VAR 0 6
11737: PPUSH
11738: CALL_OW 312
11742: ST_TO_ADDR
// if j then
11743: LD_VAR 0 7
11747: IFFALSE 11777
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
11749: LD_ADDR_VAR 0 10
11753: PUSH
11754: LD_VAR 0 10
11758: PUSH
11759: LD_VAR 0 7
11763: PPUSH
11764: LD_INT 3
11766: PPUSH
11767: CALL_OW 259
11771: PUSH
11772: LD_INT 3
11774: MUL
11775: MUL
11776: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
11777: LD_VAR 0 6
11781: PPUSH
11782: CALL_OW 264
11786: PUSH
11787: LD_INT 5
11789: PUSH
11790: LD_INT 6
11792: PUSH
11793: LD_INT 46
11795: PUSH
11796: LD_INT 44
11798: PUSH
11799: LD_INT 47
11801: PUSH
11802: LD_INT 45
11804: PUSH
11805: LD_INT 28
11807: PUSH
11808: LD_INT 7
11810: PUSH
11811: LD_INT 27
11813: PUSH
11814: LD_INT 29
11816: PUSH
11817: EMPTY
11818: LIST
11819: LIST
11820: LIST
11821: LIST
11822: LIST
11823: LIST
11824: LIST
11825: LIST
11826: LIST
11827: LIST
11828: IN
11829: PUSH
11830: LD_VAR 0 1
11834: PPUSH
11835: LD_INT 52
11837: PPUSH
11838: CALL_OW 321
11842: PUSH
11843: LD_INT 2
11845: EQUAL
11846: AND
11847: IFFALSE 11864
// bpoints := bpoints * 1.2 ;
11849: LD_ADDR_VAR 0 10
11853: PUSH
11854: LD_VAR 0 10
11858: PUSH
11859: LD_REAL  1.20000000000000E+0000
11862: MUL
11863: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
11864: LD_VAR 0 6
11868: PPUSH
11869: CALL_OW 264
11873: PUSH
11874: LD_INT 6
11876: PUSH
11877: LD_INT 46
11879: PUSH
11880: LD_INT 47
11882: PUSH
11883: EMPTY
11884: LIST
11885: LIST
11886: LIST
11887: IN
11888: IFFALSE 11905
// bpoints := bpoints * 1.2 ;
11890: LD_ADDR_VAR 0 10
11894: PUSH
11895: LD_VAR 0 10
11899: PUSH
11900: LD_REAL  1.20000000000000E+0000
11903: MUL
11904: ST_TO_ADDR
// end ; unit_building :
11905: GO 11919
11907: LD_INT 3
11909: DOUBLE
11910: EQUAL
11911: IFTRUE 11915
11913: GO 11918
11915: POP
// ; end ;
11916: GO 11919
11918: POP
// for j = 1 to 3 do
11919: LD_ADDR_VAR 0 7
11923: PUSH
11924: DOUBLE
11925: LD_INT 1
11927: DEC
11928: ST_TO_ADDR
11929: LD_INT 3
11931: PUSH
11932: FOR_TO
11933: IFFALSE 11986
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
11935: LD_ADDR_VAR 0 5
11939: PUSH
11940: LD_VAR 0 5
11944: PPUSH
11945: LD_VAR 0 7
11949: PPUSH
11950: LD_VAR 0 5
11954: PUSH
11955: LD_VAR 0 7
11959: ARRAY
11960: PUSH
11961: LD_VAR 0 9
11965: PUSH
11966: LD_VAR 0 7
11970: ARRAY
11971: PUSH
11972: LD_VAR 0 10
11976: MUL
11977: PLUS
11978: PPUSH
11979: CALL_OW 1
11983: ST_TO_ADDR
11984: GO 11932
11986: POP
11987: POP
// end ;
11988: GO 10471
11990: POP
11991: POP
// result := Replace ( result , 4 , tmp ) ;
11992: LD_ADDR_VAR 0 5
11996: PUSH
11997: LD_VAR 0 5
12001: PPUSH
12002: LD_INT 4
12004: PPUSH
12005: LD_VAR 0 8
12009: PPUSH
12010: CALL_OW 1
12014: ST_TO_ADDR
// end ;
12015: LD_VAR 0 5
12019: RET
// export function DangerAtRange ( unit , range ) ; begin
12020: LD_INT 0
12022: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
12023: LD_ADDR_VAR 0 3
12027: PUSH
12028: LD_VAR 0 1
12032: PPUSH
12033: CALL_OW 255
12037: PPUSH
12038: LD_VAR 0 1
12042: PPUSH
12043: CALL_OW 250
12047: PPUSH
12048: LD_VAR 0 1
12052: PPUSH
12053: CALL_OW 251
12057: PPUSH
12058: LD_VAR 0 2
12062: PPUSH
12063: CALL 10323 0 4
12067: ST_TO_ADDR
// end ;
12068: LD_VAR 0 3
12072: RET
// export function DangerInArea ( side , area ) ; begin
12073: LD_INT 0
12075: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
12076: LD_ADDR_VAR 0 3
12080: PUSH
12081: LD_VAR 0 2
12085: PPUSH
12086: LD_INT 81
12088: PUSH
12089: LD_VAR 0 1
12093: PUSH
12094: EMPTY
12095: LIST
12096: LIST
12097: PPUSH
12098: CALL_OW 70
12102: ST_TO_ADDR
// end ;
12103: LD_VAR 0 3
12107: RET
// export function IsExtension ( b ) ; begin
12108: LD_INT 0
12110: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
12111: LD_ADDR_VAR 0 2
12115: PUSH
12116: LD_VAR 0 1
12120: PUSH
12121: LD_INT 23
12123: PUSH
12124: LD_INT 20
12126: PUSH
12127: LD_INT 22
12129: PUSH
12130: LD_INT 17
12132: PUSH
12133: LD_INT 24
12135: PUSH
12136: LD_INT 21
12138: PUSH
12139: LD_INT 19
12141: PUSH
12142: LD_INT 16
12144: PUSH
12145: LD_INT 25
12147: PUSH
12148: LD_INT 18
12150: PUSH
12151: EMPTY
12152: LIST
12153: LIST
12154: LIST
12155: LIST
12156: LIST
12157: LIST
12158: LIST
12159: LIST
12160: LIST
12161: LIST
12162: IN
12163: ST_TO_ADDR
// end ;
12164: LD_VAR 0 2
12168: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
12169: LD_INT 0
12171: PPUSH
12172: PPUSH
12173: PPUSH
// result := [ ] ;
12174: LD_ADDR_VAR 0 3
12178: PUSH
12179: EMPTY
12180: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
12181: LD_ADDR_VAR 0 4
12185: PUSH
12186: LD_VAR 0 2
12190: PPUSH
12191: LD_INT 21
12193: PUSH
12194: LD_INT 3
12196: PUSH
12197: EMPTY
12198: LIST
12199: LIST
12200: PPUSH
12201: CALL_OW 70
12205: ST_TO_ADDR
// if not tmp then
12206: LD_VAR 0 4
12210: NOT
12211: IFFALSE 12215
// exit ;
12213: GO 12273
// for i in tmp do
12215: LD_ADDR_VAR 0 5
12219: PUSH
12220: LD_VAR 0 4
12224: PUSH
12225: FOR_IN
12226: IFFALSE 12261
// if GetBase ( i ) <> base then
12228: LD_VAR 0 5
12232: PPUSH
12233: CALL_OW 274
12237: PUSH
12238: LD_VAR 0 1
12242: NONEQUAL
12243: IFFALSE 12259
// ComLinkToBase ( base , i ) ;
12245: LD_VAR 0 1
12249: PPUSH
12250: LD_VAR 0 5
12254: PPUSH
12255: CALL_OW 169
12259: GO 12225
12261: POP
12262: POP
// result := tmp ;
12263: LD_ADDR_VAR 0 3
12267: PUSH
12268: LD_VAR 0 4
12272: ST_TO_ADDR
// end ;
12273: LD_VAR 0 3
12277: RET
// export function ComComplete ( unit , b ) ; var i ; begin
12278: LD_INT 0
12280: PPUSH
12281: PPUSH
// if BuildingStatus ( b ) = bs_build then
12282: LD_VAR 0 2
12286: PPUSH
12287: CALL_OW 461
12291: PUSH
12292: LD_INT 1
12294: EQUAL
12295: IFFALSE 12355
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
12297: LD_VAR 0 1
12301: PPUSH
12302: LD_STRING h
12304: PUSH
12305: LD_VAR 0 2
12309: PPUSH
12310: CALL_OW 250
12314: PUSH
12315: LD_VAR 0 2
12319: PPUSH
12320: CALL_OW 251
12324: PUSH
12325: LD_VAR 0 2
12329: PUSH
12330: LD_INT 0
12332: PUSH
12333: LD_INT 0
12335: PUSH
12336: LD_INT 0
12338: PUSH
12339: EMPTY
12340: LIST
12341: LIST
12342: LIST
12343: LIST
12344: LIST
12345: LIST
12346: LIST
12347: PUSH
12348: EMPTY
12349: LIST
12350: PPUSH
12351: CALL_OW 446
// end ;
12355: LD_VAR 0 3
12359: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
12360: LD_INT 0
12362: PPUSH
12363: PPUSH
12364: PPUSH
12365: PPUSH
12366: PPUSH
12367: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
12368: LD_VAR 0 1
12372: NOT
12373: PUSH
12374: LD_VAR 0 1
12378: PPUSH
12379: CALL_OW 263
12383: PUSH
12384: LD_INT 2
12386: EQUAL
12387: NOT
12388: OR
12389: IFFALSE 12393
// exit ;
12391: GO 12709
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
12393: LD_ADDR_VAR 0 6
12397: PUSH
12398: LD_INT 22
12400: PUSH
12401: LD_VAR 0 1
12405: PPUSH
12406: CALL_OW 255
12410: PUSH
12411: EMPTY
12412: LIST
12413: LIST
12414: PUSH
12415: LD_INT 2
12417: PUSH
12418: LD_INT 30
12420: PUSH
12421: LD_INT 36
12423: PUSH
12424: EMPTY
12425: LIST
12426: LIST
12427: PUSH
12428: LD_INT 34
12430: PUSH
12431: LD_INT 31
12433: PUSH
12434: EMPTY
12435: LIST
12436: LIST
12437: PUSH
12438: EMPTY
12439: LIST
12440: LIST
12441: LIST
12442: PUSH
12443: EMPTY
12444: LIST
12445: LIST
12446: PPUSH
12447: CALL_OW 69
12451: ST_TO_ADDR
// if not tmp then
12452: LD_VAR 0 6
12456: NOT
12457: IFFALSE 12461
// exit ;
12459: GO 12709
// result := [ ] ;
12461: LD_ADDR_VAR 0 2
12465: PUSH
12466: EMPTY
12467: ST_TO_ADDR
// for i in tmp do
12468: LD_ADDR_VAR 0 3
12472: PUSH
12473: LD_VAR 0 6
12477: PUSH
12478: FOR_IN
12479: IFFALSE 12550
// begin t := UnitsInside ( i ) ;
12481: LD_ADDR_VAR 0 4
12485: PUSH
12486: LD_VAR 0 3
12490: PPUSH
12491: CALL_OW 313
12495: ST_TO_ADDR
// if t then
12496: LD_VAR 0 4
12500: IFFALSE 12548
// for j in t do
12502: LD_ADDR_VAR 0 7
12506: PUSH
12507: LD_VAR 0 4
12511: PUSH
12512: FOR_IN
12513: IFFALSE 12546
// result := Insert ( result , result + 1 , j ) ;
12515: LD_ADDR_VAR 0 2
12519: PUSH
12520: LD_VAR 0 2
12524: PPUSH
12525: LD_VAR 0 2
12529: PUSH
12530: LD_INT 1
12532: PLUS
12533: PPUSH
12534: LD_VAR 0 7
12538: PPUSH
12539: CALL_OW 2
12543: ST_TO_ADDR
12544: GO 12512
12546: POP
12547: POP
// end ;
12548: GO 12478
12550: POP
12551: POP
// if not result then
12552: LD_VAR 0 2
12556: NOT
12557: IFFALSE 12561
// exit ;
12559: GO 12709
// mech := result [ 1 ] ;
12561: LD_ADDR_VAR 0 5
12565: PUSH
12566: LD_VAR 0 2
12570: PUSH
12571: LD_INT 1
12573: ARRAY
12574: ST_TO_ADDR
// if result > 1 then
12575: LD_VAR 0 2
12579: PUSH
12580: LD_INT 1
12582: GREATER
12583: IFFALSE 12695
// for i = 2 to result do
12585: LD_ADDR_VAR 0 3
12589: PUSH
12590: DOUBLE
12591: LD_INT 2
12593: DEC
12594: ST_TO_ADDR
12595: LD_VAR 0 2
12599: PUSH
12600: FOR_TO
12601: IFFALSE 12693
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
12603: LD_ADDR_VAR 0 4
12607: PUSH
12608: LD_VAR 0 2
12612: PUSH
12613: LD_VAR 0 3
12617: ARRAY
12618: PPUSH
12619: LD_INT 3
12621: PPUSH
12622: CALL_OW 259
12626: PUSH
12627: LD_VAR 0 2
12631: PUSH
12632: LD_VAR 0 3
12636: ARRAY
12637: PPUSH
12638: CALL_OW 432
12642: MINUS
12643: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
12644: LD_VAR 0 4
12648: PUSH
12649: LD_VAR 0 5
12653: PPUSH
12654: LD_INT 3
12656: PPUSH
12657: CALL_OW 259
12661: PUSH
12662: LD_VAR 0 5
12666: PPUSH
12667: CALL_OW 432
12671: MINUS
12672: GREATEREQUAL
12673: IFFALSE 12691
// mech := result [ i ] ;
12675: LD_ADDR_VAR 0 5
12679: PUSH
12680: LD_VAR 0 2
12684: PUSH
12685: LD_VAR 0 3
12689: ARRAY
12690: ST_TO_ADDR
// end ;
12691: GO 12600
12693: POP
12694: POP
// ComLinkTo ( vehicle , mech ) ;
12695: LD_VAR 0 1
12699: PPUSH
12700: LD_VAR 0 5
12704: PPUSH
12705: CALL_OW 135
// end ;
12709: LD_VAR 0 2
12713: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
12714: LD_INT 0
12716: PPUSH
12717: PPUSH
12718: PPUSH
12719: PPUSH
12720: PPUSH
12721: PPUSH
12722: PPUSH
12723: PPUSH
12724: PPUSH
12725: PPUSH
12726: PPUSH
12727: PPUSH
12728: PPUSH
// result := [ ] ;
12729: LD_ADDR_VAR 0 7
12733: PUSH
12734: EMPTY
12735: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
12736: LD_VAR 0 1
12740: PPUSH
12741: CALL_OW 266
12745: PUSH
12746: LD_INT 0
12748: PUSH
12749: LD_INT 1
12751: PUSH
12752: EMPTY
12753: LIST
12754: LIST
12755: IN
12756: NOT
12757: IFFALSE 12761
// exit ;
12759: GO 14392
// if name then
12761: LD_VAR 0 3
12765: IFFALSE 12781
// SetBName ( base_dep , name ) ;
12767: LD_VAR 0 1
12771: PPUSH
12772: LD_VAR 0 3
12776: PPUSH
12777: CALL_OW 500
// base := GetBase ( base_dep ) ;
12781: LD_ADDR_VAR 0 15
12785: PUSH
12786: LD_VAR 0 1
12790: PPUSH
12791: CALL_OW 274
12795: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
12796: LD_ADDR_VAR 0 16
12800: PUSH
12801: LD_VAR 0 1
12805: PPUSH
12806: CALL_OW 255
12810: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
12811: LD_ADDR_VAR 0 17
12815: PUSH
12816: LD_VAR 0 1
12820: PPUSH
12821: CALL_OW 248
12825: ST_TO_ADDR
// if sources then
12826: LD_VAR 0 5
12830: IFFALSE 12877
// for i = 1 to 3 do
12832: LD_ADDR_VAR 0 8
12836: PUSH
12837: DOUBLE
12838: LD_INT 1
12840: DEC
12841: ST_TO_ADDR
12842: LD_INT 3
12844: PUSH
12845: FOR_TO
12846: IFFALSE 12875
// AddResourceType ( base , i , sources [ i ] ) ;
12848: LD_VAR 0 15
12852: PPUSH
12853: LD_VAR 0 8
12857: PPUSH
12858: LD_VAR 0 5
12862: PUSH
12863: LD_VAR 0 8
12867: ARRAY
12868: PPUSH
12869: CALL_OW 276
12873: GO 12845
12875: POP
12876: POP
// buildings := GetBaseBuildings ( base , area ) ;
12877: LD_ADDR_VAR 0 18
12881: PUSH
12882: LD_VAR 0 15
12886: PPUSH
12887: LD_VAR 0 2
12891: PPUSH
12892: CALL 12169 0 2
12896: ST_TO_ADDR
// InitHc ;
12897: CALL_OW 19
// InitUc ;
12901: CALL_OW 18
// uc_side := side ;
12905: LD_ADDR_OWVAR 20
12909: PUSH
12910: LD_VAR 0 16
12914: ST_TO_ADDR
// uc_nation := nation ;
12915: LD_ADDR_OWVAR 21
12919: PUSH
12920: LD_VAR 0 17
12924: ST_TO_ADDR
// if buildings then
12925: LD_VAR 0 18
12929: IFFALSE 14251
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
12931: LD_ADDR_VAR 0 19
12935: PUSH
12936: LD_VAR 0 18
12940: PPUSH
12941: LD_INT 2
12943: PUSH
12944: LD_INT 30
12946: PUSH
12947: LD_INT 29
12949: PUSH
12950: EMPTY
12951: LIST
12952: LIST
12953: PUSH
12954: LD_INT 30
12956: PUSH
12957: LD_INT 30
12959: PUSH
12960: EMPTY
12961: LIST
12962: LIST
12963: PUSH
12964: EMPTY
12965: LIST
12966: LIST
12967: LIST
12968: PPUSH
12969: CALL_OW 72
12973: ST_TO_ADDR
// if tmp then
12974: LD_VAR 0 19
12978: IFFALSE 13026
// for i in tmp do
12980: LD_ADDR_VAR 0 8
12984: PUSH
12985: LD_VAR 0 19
12989: PUSH
12990: FOR_IN
12991: IFFALSE 13024
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
12993: LD_VAR 0 8
12997: PPUSH
12998: CALL_OW 250
13002: PPUSH
13003: LD_VAR 0 8
13007: PPUSH
13008: CALL_OW 251
13012: PPUSH
13013: LD_VAR 0 16
13017: PPUSH
13018: CALL_OW 441
13022: GO 12990
13024: POP
13025: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
13026: LD_VAR 0 18
13030: PPUSH
13031: LD_INT 2
13033: PUSH
13034: LD_INT 30
13036: PUSH
13037: LD_INT 32
13039: PUSH
13040: EMPTY
13041: LIST
13042: LIST
13043: PUSH
13044: LD_INT 30
13046: PUSH
13047: LD_INT 33
13049: PUSH
13050: EMPTY
13051: LIST
13052: LIST
13053: PUSH
13054: EMPTY
13055: LIST
13056: LIST
13057: LIST
13058: PPUSH
13059: CALL_OW 72
13063: IFFALSE 13151
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
13065: LD_ADDR_VAR 0 8
13069: PUSH
13070: LD_VAR 0 18
13074: PPUSH
13075: LD_INT 2
13077: PUSH
13078: LD_INT 30
13080: PUSH
13081: LD_INT 32
13083: PUSH
13084: EMPTY
13085: LIST
13086: LIST
13087: PUSH
13088: LD_INT 30
13090: PUSH
13091: LD_INT 33
13093: PUSH
13094: EMPTY
13095: LIST
13096: LIST
13097: PUSH
13098: EMPTY
13099: LIST
13100: LIST
13101: LIST
13102: PPUSH
13103: CALL_OW 72
13107: PUSH
13108: FOR_IN
13109: IFFALSE 13149
// begin if not GetBWeapon ( i ) then
13111: LD_VAR 0 8
13115: PPUSH
13116: CALL_OW 269
13120: NOT
13121: IFFALSE 13147
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
13123: LD_VAR 0 8
13127: PPUSH
13128: LD_VAR 0 8
13132: PPUSH
13133: LD_VAR 0 2
13137: PPUSH
13138: CALL 14397 0 2
13142: PPUSH
13143: CALL_OW 431
// end ;
13147: GO 13108
13149: POP
13150: POP
// end ; for i = 1 to personel do
13151: LD_ADDR_VAR 0 8
13155: PUSH
13156: DOUBLE
13157: LD_INT 1
13159: DEC
13160: ST_TO_ADDR
13161: LD_VAR 0 6
13165: PUSH
13166: FOR_TO
13167: IFFALSE 14231
// begin if i > 4 then
13169: LD_VAR 0 8
13173: PUSH
13174: LD_INT 4
13176: GREATER
13177: IFFALSE 13181
// break ;
13179: GO 14231
// case i of 1 :
13181: LD_VAR 0 8
13185: PUSH
13186: LD_INT 1
13188: DOUBLE
13189: EQUAL
13190: IFTRUE 13194
13192: GO 13274
13194: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
13195: LD_ADDR_VAR 0 12
13199: PUSH
13200: LD_VAR 0 18
13204: PPUSH
13205: LD_INT 22
13207: PUSH
13208: LD_VAR 0 16
13212: PUSH
13213: EMPTY
13214: LIST
13215: LIST
13216: PUSH
13217: LD_INT 58
13219: PUSH
13220: EMPTY
13221: LIST
13222: PUSH
13223: LD_INT 2
13225: PUSH
13226: LD_INT 30
13228: PUSH
13229: LD_INT 32
13231: PUSH
13232: EMPTY
13233: LIST
13234: LIST
13235: PUSH
13236: LD_INT 30
13238: PUSH
13239: LD_INT 4
13241: PUSH
13242: EMPTY
13243: LIST
13244: LIST
13245: PUSH
13246: LD_INT 30
13248: PUSH
13249: LD_INT 5
13251: PUSH
13252: EMPTY
13253: LIST
13254: LIST
13255: PUSH
13256: EMPTY
13257: LIST
13258: LIST
13259: LIST
13260: LIST
13261: PUSH
13262: EMPTY
13263: LIST
13264: LIST
13265: LIST
13266: PPUSH
13267: CALL_OW 72
13271: ST_TO_ADDR
13272: GO 13496
13274: LD_INT 2
13276: DOUBLE
13277: EQUAL
13278: IFTRUE 13282
13280: GO 13344
13282: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
13283: LD_ADDR_VAR 0 12
13287: PUSH
13288: LD_VAR 0 18
13292: PPUSH
13293: LD_INT 22
13295: PUSH
13296: LD_VAR 0 16
13300: PUSH
13301: EMPTY
13302: LIST
13303: LIST
13304: PUSH
13305: LD_INT 2
13307: PUSH
13308: LD_INT 30
13310: PUSH
13311: LD_INT 0
13313: PUSH
13314: EMPTY
13315: LIST
13316: LIST
13317: PUSH
13318: LD_INT 30
13320: PUSH
13321: LD_INT 1
13323: PUSH
13324: EMPTY
13325: LIST
13326: LIST
13327: PUSH
13328: EMPTY
13329: LIST
13330: LIST
13331: LIST
13332: PUSH
13333: EMPTY
13334: LIST
13335: LIST
13336: PPUSH
13337: CALL_OW 72
13341: ST_TO_ADDR
13342: GO 13496
13344: LD_INT 3
13346: DOUBLE
13347: EQUAL
13348: IFTRUE 13352
13350: GO 13414
13352: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
13353: LD_ADDR_VAR 0 12
13357: PUSH
13358: LD_VAR 0 18
13362: PPUSH
13363: LD_INT 22
13365: PUSH
13366: LD_VAR 0 16
13370: PUSH
13371: EMPTY
13372: LIST
13373: LIST
13374: PUSH
13375: LD_INT 2
13377: PUSH
13378: LD_INT 30
13380: PUSH
13381: LD_INT 2
13383: PUSH
13384: EMPTY
13385: LIST
13386: LIST
13387: PUSH
13388: LD_INT 30
13390: PUSH
13391: LD_INT 3
13393: PUSH
13394: EMPTY
13395: LIST
13396: LIST
13397: PUSH
13398: EMPTY
13399: LIST
13400: LIST
13401: LIST
13402: PUSH
13403: EMPTY
13404: LIST
13405: LIST
13406: PPUSH
13407: CALL_OW 72
13411: ST_TO_ADDR
13412: GO 13496
13414: LD_INT 4
13416: DOUBLE
13417: EQUAL
13418: IFTRUE 13422
13420: GO 13495
13422: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
13423: LD_ADDR_VAR 0 12
13427: PUSH
13428: LD_VAR 0 18
13432: PPUSH
13433: LD_INT 22
13435: PUSH
13436: LD_VAR 0 16
13440: PUSH
13441: EMPTY
13442: LIST
13443: LIST
13444: PUSH
13445: LD_INT 2
13447: PUSH
13448: LD_INT 30
13450: PUSH
13451: LD_INT 6
13453: PUSH
13454: EMPTY
13455: LIST
13456: LIST
13457: PUSH
13458: LD_INT 30
13460: PUSH
13461: LD_INT 7
13463: PUSH
13464: EMPTY
13465: LIST
13466: LIST
13467: PUSH
13468: LD_INT 30
13470: PUSH
13471: LD_INT 8
13473: PUSH
13474: EMPTY
13475: LIST
13476: LIST
13477: PUSH
13478: EMPTY
13479: LIST
13480: LIST
13481: LIST
13482: LIST
13483: PUSH
13484: EMPTY
13485: LIST
13486: LIST
13487: PPUSH
13488: CALL_OW 72
13492: ST_TO_ADDR
13493: GO 13496
13495: POP
// if i = 1 then
13496: LD_VAR 0 8
13500: PUSH
13501: LD_INT 1
13503: EQUAL
13504: IFFALSE 13615
// begin tmp := [ ] ;
13506: LD_ADDR_VAR 0 19
13510: PUSH
13511: EMPTY
13512: ST_TO_ADDR
// for j in f do
13513: LD_ADDR_VAR 0 9
13517: PUSH
13518: LD_VAR 0 12
13522: PUSH
13523: FOR_IN
13524: IFFALSE 13597
// if GetBType ( j ) = b_bunker then
13526: LD_VAR 0 9
13530: PPUSH
13531: CALL_OW 266
13535: PUSH
13536: LD_INT 32
13538: EQUAL
13539: IFFALSE 13566
// tmp := Insert ( tmp , 1 , j ) else
13541: LD_ADDR_VAR 0 19
13545: PUSH
13546: LD_VAR 0 19
13550: PPUSH
13551: LD_INT 1
13553: PPUSH
13554: LD_VAR 0 9
13558: PPUSH
13559: CALL_OW 2
13563: ST_TO_ADDR
13564: GO 13595
// tmp := Insert ( tmp , tmp + 1 , j ) ;
13566: LD_ADDR_VAR 0 19
13570: PUSH
13571: LD_VAR 0 19
13575: PPUSH
13576: LD_VAR 0 19
13580: PUSH
13581: LD_INT 1
13583: PLUS
13584: PPUSH
13585: LD_VAR 0 9
13589: PPUSH
13590: CALL_OW 2
13594: ST_TO_ADDR
13595: GO 13523
13597: POP
13598: POP
// if tmp then
13599: LD_VAR 0 19
13603: IFFALSE 13615
// f := tmp ;
13605: LD_ADDR_VAR 0 12
13609: PUSH
13610: LD_VAR 0 19
13614: ST_TO_ADDR
// end ; x := personel [ i ] ;
13615: LD_ADDR_VAR 0 13
13619: PUSH
13620: LD_VAR 0 6
13624: PUSH
13625: LD_VAR 0 8
13629: ARRAY
13630: ST_TO_ADDR
// if x = - 1 then
13631: LD_VAR 0 13
13635: PUSH
13636: LD_INT 1
13638: NEG
13639: EQUAL
13640: IFFALSE 13849
// begin for j in f do
13642: LD_ADDR_VAR 0 9
13646: PUSH
13647: LD_VAR 0 12
13651: PUSH
13652: FOR_IN
13653: IFFALSE 13845
// repeat InitHc ;
13655: CALL_OW 19
// if GetBType ( j ) = b_barracks then
13659: LD_VAR 0 9
13663: PPUSH
13664: CALL_OW 266
13668: PUSH
13669: LD_INT 5
13671: EQUAL
13672: IFFALSE 13742
// begin if UnitsInside ( j ) < 3 then
13674: LD_VAR 0 9
13678: PPUSH
13679: CALL_OW 313
13683: PUSH
13684: LD_INT 3
13686: LESS
13687: IFFALSE 13723
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
13689: LD_INT 0
13691: PPUSH
13692: LD_INT 5
13694: PUSH
13695: LD_INT 8
13697: PUSH
13698: LD_INT 9
13700: PUSH
13701: EMPTY
13702: LIST
13703: LIST
13704: LIST
13705: PUSH
13706: LD_VAR 0 17
13710: ARRAY
13711: PPUSH
13712: LD_VAR 0 4
13716: PPUSH
13717: CALL_OW 380
13721: GO 13740
// PrepareHuman ( false , i , skill ) ;
13723: LD_INT 0
13725: PPUSH
13726: LD_VAR 0 8
13730: PPUSH
13731: LD_VAR 0 4
13735: PPUSH
13736: CALL_OW 380
// end else
13740: GO 13759
// PrepareHuman ( false , i , skill ) ;
13742: LD_INT 0
13744: PPUSH
13745: LD_VAR 0 8
13749: PPUSH
13750: LD_VAR 0 4
13754: PPUSH
13755: CALL_OW 380
// un := CreateHuman ;
13759: LD_ADDR_VAR 0 14
13763: PUSH
13764: CALL_OW 44
13768: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
13769: LD_ADDR_VAR 0 7
13773: PUSH
13774: LD_VAR 0 7
13778: PPUSH
13779: LD_INT 1
13781: PPUSH
13782: LD_VAR 0 14
13786: PPUSH
13787: CALL_OW 2
13791: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
13792: LD_VAR 0 14
13796: PPUSH
13797: LD_VAR 0 9
13801: PPUSH
13802: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
13806: LD_VAR 0 9
13810: PPUSH
13811: CALL_OW 313
13815: PUSH
13816: LD_INT 6
13818: EQUAL
13819: PUSH
13820: LD_VAR 0 9
13824: PPUSH
13825: CALL_OW 266
13829: PUSH
13830: LD_INT 32
13832: PUSH
13833: LD_INT 31
13835: PUSH
13836: EMPTY
13837: LIST
13838: LIST
13839: IN
13840: OR
13841: IFFALSE 13655
13843: GO 13652
13845: POP
13846: POP
// end else
13847: GO 14229
// for j = 1 to x do
13849: LD_ADDR_VAR 0 9
13853: PUSH
13854: DOUBLE
13855: LD_INT 1
13857: DEC
13858: ST_TO_ADDR
13859: LD_VAR 0 13
13863: PUSH
13864: FOR_TO
13865: IFFALSE 14227
// begin InitHc ;
13867: CALL_OW 19
// if not f then
13871: LD_VAR 0 12
13875: NOT
13876: IFFALSE 13965
// begin PrepareHuman ( false , i , skill ) ;
13878: LD_INT 0
13880: PPUSH
13881: LD_VAR 0 8
13885: PPUSH
13886: LD_VAR 0 4
13890: PPUSH
13891: CALL_OW 380
// un := CreateHuman ;
13895: LD_ADDR_VAR 0 14
13899: PUSH
13900: CALL_OW 44
13904: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
13905: LD_ADDR_VAR 0 7
13909: PUSH
13910: LD_VAR 0 7
13914: PPUSH
13915: LD_INT 1
13917: PPUSH
13918: LD_VAR 0 14
13922: PPUSH
13923: CALL_OW 2
13927: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
13928: LD_VAR 0 14
13932: PPUSH
13933: LD_VAR 0 1
13937: PPUSH
13938: CALL_OW 250
13942: PPUSH
13943: LD_VAR 0 1
13947: PPUSH
13948: CALL_OW 251
13952: PPUSH
13953: LD_INT 10
13955: PPUSH
13956: LD_INT 0
13958: PPUSH
13959: CALL_OW 50
// continue ;
13963: GO 13864
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
13965: LD_VAR 0 12
13969: PUSH
13970: LD_INT 1
13972: ARRAY
13973: PPUSH
13974: CALL_OW 313
13978: PUSH
13979: LD_VAR 0 12
13983: PUSH
13984: LD_INT 1
13986: ARRAY
13987: PPUSH
13988: CALL_OW 266
13992: PUSH
13993: LD_INT 32
13995: PUSH
13996: LD_INT 31
13998: PUSH
13999: EMPTY
14000: LIST
14001: LIST
14002: IN
14003: AND
14004: PUSH
14005: LD_VAR 0 12
14009: PUSH
14010: LD_INT 1
14012: ARRAY
14013: PPUSH
14014: CALL_OW 313
14018: PUSH
14019: LD_INT 6
14021: EQUAL
14022: OR
14023: IFFALSE 14043
// f := Delete ( f , 1 ) ;
14025: LD_ADDR_VAR 0 12
14029: PUSH
14030: LD_VAR 0 12
14034: PPUSH
14035: LD_INT 1
14037: PPUSH
14038: CALL_OW 3
14042: ST_TO_ADDR
// if not f then
14043: LD_VAR 0 12
14047: NOT
14048: IFFALSE 14066
// begin x := x + 2 ;
14050: LD_ADDR_VAR 0 13
14054: PUSH
14055: LD_VAR 0 13
14059: PUSH
14060: LD_INT 2
14062: PLUS
14063: ST_TO_ADDR
// continue ;
14064: GO 13864
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
14066: LD_VAR 0 12
14070: PUSH
14071: LD_INT 1
14073: ARRAY
14074: PPUSH
14075: CALL_OW 266
14079: PUSH
14080: LD_INT 5
14082: EQUAL
14083: IFFALSE 14157
// begin if UnitsInside ( f [ 1 ] ) < 3 then
14085: LD_VAR 0 12
14089: PUSH
14090: LD_INT 1
14092: ARRAY
14093: PPUSH
14094: CALL_OW 313
14098: PUSH
14099: LD_INT 3
14101: LESS
14102: IFFALSE 14138
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
14104: LD_INT 0
14106: PPUSH
14107: LD_INT 5
14109: PUSH
14110: LD_INT 8
14112: PUSH
14113: LD_INT 9
14115: PUSH
14116: EMPTY
14117: LIST
14118: LIST
14119: LIST
14120: PUSH
14121: LD_VAR 0 17
14125: ARRAY
14126: PPUSH
14127: LD_VAR 0 4
14131: PPUSH
14132: CALL_OW 380
14136: GO 14155
// PrepareHuman ( false , i , skill ) ;
14138: LD_INT 0
14140: PPUSH
14141: LD_VAR 0 8
14145: PPUSH
14146: LD_VAR 0 4
14150: PPUSH
14151: CALL_OW 380
// end else
14155: GO 14174
// PrepareHuman ( false , i , skill ) ;
14157: LD_INT 0
14159: PPUSH
14160: LD_VAR 0 8
14164: PPUSH
14165: LD_VAR 0 4
14169: PPUSH
14170: CALL_OW 380
// un := CreateHuman ;
14174: LD_ADDR_VAR 0 14
14178: PUSH
14179: CALL_OW 44
14183: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
14184: LD_ADDR_VAR 0 7
14188: PUSH
14189: LD_VAR 0 7
14193: PPUSH
14194: LD_INT 1
14196: PPUSH
14197: LD_VAR 0 14
14201: PPUSH
14202: CALL_OW 2
14206: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
14207: LD_VAR 0 14
14211: PPUSH
14212: LD_VAR 0 12
14216: PUSH
14217: LD_INT 1
14219: ARRAY
14220: PPUSH
14221: CALL_OW 52
// end ;
14225: GO 13864
14227: POP
14228: POP
// end ;
14229: GO 13166
14231: POP
14232: POP
// result := result ^ buildings ;
14233: LD_ADDR_VAR 0 7
14237: PUSH
14238: LD_VAR 0 7
14242: PUSH
14243: LD_VAR 0 18
14247: ADD
14248: ST_TO_ADDR
// end else
14249: GO 14392
// begin for i = 1 to personel do
14251: LD_ADDR_VAR 0 8
14255: PUSH
14256: DOUBLE
14257: LD_INT 1
14259: DEC
14260: ST_TO_ADDR
14261: LD_VAR 0 6
14265: PUSH
14266: FOR_TO
14267: IFFALSE 14390
// begin if i > 4 then
14269: LD_VAR 0 8
14273: PUSH
14274: LD_INT 4
14276: GREATER
14277: IFFALSE 14281
// break ;
14279: GO 14390
// x := personel [ i ] ;
14281: LD_ADDR_VAR 0 13
14285: PUSH
14286: LD_VAR 0 6
14290: PUSH
14291: LD_VAR 0 8
14295: ARRAY
14296: ST_TO_ADDR
// if x = - 1 then
14297: LD_VAR 0 13
14301: PUSH
14302: LD_INT 1
14304: NEG
14305: EQUAL
14306: IFFALSE 14310
// continue ;
14308: GO 14266
// PrepareHuman ( false , i , skill ) ;
14310: LD_INT 0
14312: PPUSH
14313: LD_VAR 0 8
14317: PPUSH
14318: LD_VAR 0 4
14322: PPUSH
14323: CALL_OW 380
// un := CreateHuman ;
14327: LD_ADDR_VAR 0 14
14331: PUSH
14332: CALL_OW 44
14336: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
14337: LD_VAR 0 14
14341: PPUSH
14342: LD_VAR 0 1
14346: PPUSH
14347: CALL_OW 250
14351: PPUSH
14352: LD_VAR 0 1
14356: PPUSH
14357: CALL_OW 251
14361: PPUSH
14362: LD_INT 10
14364: PPUSH
14365: LD_INT 0
14367: PPUSH
14368: CALL_OW 50
// result := result ^ un ;
14372: LD_ADDR_VAR 0 7
14376: PUSH
14377: LD_VAR 0 7
14381: PUSH
14382: LD_VAR 0 14
14386: ADD
14387: ST_TO_ADDR
// end ;
14388: GO 14266
14390: POP
14391: POP
// end ; end ;
14392: LD_VAR 0 7
14396: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
14397: LD_INT 0
14399: PPUSH
14400: PPUSH
14401: PPUSH
14402: PPUSH
14403: PPUSH
14404: PPUSH
14405: PPUSH
14406: PPUSH
14407: PPUSH
14408: PPUSH
14409: PPUSH
14410: PPUSH
14411: PPUSH
14412: PPUSH
14413: PPUSH
14414: PPUSH
// result := false ;
14415: LD_ADDR_VAR 0 3
14419: PUSH
14420: LD_INT 0
14422: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
14423: LD_VAR 0 1
14427: NOT
14428: PUSH
14429: LD_VAR 0 1
14433: PPUSH
14434: CALL_OW 266
14438: PUSH
14439: LD_INT 32
14441: PUSH
14442: LD_INT 33
14444: PUSH
14445: EMPTY
14446: LIST
14447: LIST
14448: IN
14449: NOT
14450: OR
14451: IFFALSE 14455
// exit ;
14453: GO 15591
// nat := GetNation ( tower ) ;
14455: LD_ADDR_VAR 0 12
14459: PUSH
14460: LD_VAR 0 1
14464: PPUSH
14465: CALL_OW 248
14469: ST_TO_ADDR
// side := GetSide ( tower ) ;
14470: LD_ADDR_VAR 0 16
14474: PUSH
14475: LD_VAR 0 1
14479: PPUSH
14480: CALL_OW 255
14484: ST_TO_ADDR
// x := GetX ( tower ) ;
14485: LD_ADDR_VAR 0 10
14489: PUSH
14490: LD_VAR 0 1
14494: PPUSH
14495: CALL_OW 250
14499: ST_TO_ADDR
// y := GetY ( tower ) ;
14500: LD_ADDR_VAR 0 11
14504: PUSH
14505: LD_VAR 0 1
14509: PPUSH
14510: CALL_OW 251
14514: ST_TO_ADDR
// if not x or not y then
14515: LD_VAR 0 10
14519: NOT
14520: PUSH
14521: LD_VAR 0 11
14525: NOT
14526: OR
14527: IFFALSE 14531
// exit ;
14529: GO 15591
// weapon := 0 ;
14531: LD_ADDR_VAR 0 18
14535: PUSH
14536: LD_INT 0
14538: ST_TO_ADDR
// fac_list := [ ] ;
14539: LD_ADDR_VAR 0 17
14543: PUSH
14544: EMPTY
14545: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
14546: LD_ADDR_VAR 0 6
14550: PUSH
14551: LD_VAR 0 1
14555: PPUSH
14556: CALL_OW 274
14560: PPUSH
14561: LD_VAR 0 2
14565: PPUSH
14566: CALL 12169 0 2
14570: PPUSH
14571: LD_INT 30
14573: PUSH
14574: LD_INT 3
14576: PUSH
14577: EMPTY
14578: LIST
14579: LIST
14580: PPUSH
14581: CALL_OW 72
14585: ST_TO_ADDR
// if not factories then
14586: LD_VAR 0 6
14590: NOT
14591: IFFALSE 14595
// exit ;
14593: GO 15591
// for i in factories do
14595: LD_ADDR_VAR 0 8
14599: PUSH
14600: LD_VAR 0 6
14604: PUSH
14605: FOR_IN
14606: IFFALSE 14631
// fac_list := fac_list union AvailableWeaponList ( i ) ;
14608: LD_ADDR_VAR 0 17
14612: PUSH
14613: LD_VAR 0 17
14617: PUSH
14618: LD_VAR 0 8
14622: PPUSH
14623: CALL_OW 478
14627: UNION
14628: ST_TO_ADDR
14629: GO 14605
14631: POP
14632: POP
// if not fac_list then
14633: LD_VAR 0 17
14637: NOT
14638: IFFALSE 14642
// exit ;
14640: GO 15591
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
14642: LD_ADDR_VAR 0 5
14646: PUSH
14647: LD_INT 4
14649: PUSH
14650: LD_INT 5
14652: PUSH
14653: LD_INT 9
14655: PUSH
14656: LD_INT 10
14658: PUSH
14659: LD_INT 6
14661: PUSH
14662: LD_INT 7
14664: PUSH
14665: LD_INT 11
14667: PUSH
14668: EMPTY
14669: LIST
14670: LIST
14671: LIST
14672: LIST
14673: LIST
14674: LIST
14675: LIST
14676: PUSH
14677: LD_INT 27
14679: PUSH
14680: LD_INT 28
14682: PUSH
14683: LD_INT 26
14685: PUSH
14686: LD_INT 30
14688: PUSH
14689: EMPTY
14690: LIST
14691: LIST
14692: LIST
14693: LIST
14694: PUSH
14695: LD_INT 43
14697: PUSH
14698: LD_INT 44
14700: PUSH
14701: LD_INT 46
14703: PUSH
14704: LD_INT 45
14706: PUSH
14707: LD_INT 47
14709: PUSH
14710: LD_INT 49
14712: PUSH
14713: EMPTY
14714: LIST
14715: LIST
14716: LIST
14717: LIST
14718: LIST
14719: LIST
14720: PUSH
14721: EMPTY
14722: LIST
14723: LIST
14724: LIST
14725: PUSH
14726: LD_VAR 0 12
14730: ARRAY
14731: ST_TO_ADDR
// for i in list do
14732: LD_ADDR_VAR 0 8
14736: PUSH
14737: LD_VAR 0 5
14741: PUSH
14742: FOR_IN
14743: IFFALSE 14776
// if not i in fac_list then
14745: LD_VAR 0 8
14749: PUSH
14750: LD_VAR 0 17
14754: IN
14755: NOT
14756: IFFALSE 14774
// list := list diff i ;
14758: LD_ADDR_VAR 0 5
14762: PUSH
14763: LD_VAR 0 5
14767: PUSH
14768: LD_VAR 0 8
14772: DIFF
14773: ST_TO_ADDR
14774: GO 14742
14776: POP
14777: POP
// if not list then
14778: LD_VAR 0 5
14782: NOT
14783: IFFALSE 14787
// exit ;
14785: GO 15591
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
14787: LD_VAR 0 12
14791: PUSH
14792: LD_INT 3
14794: EQUAL
14795: PUSH
14796: LD_INT 49
14798: PUSH
14799: LD_VAR 0 5
14803: IN
14804: AND
14805: PUSH
14806: LD_INT 31
14808: PPUSH
14809: LD_VAR 0 16
14813: PPUSH
14814: CALL_OW 321
14818: PUSH
14819: LD_INT 2
14821: EQUAL
14822: AND
14823: IFFALSE 14883
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
14825: LD_INT 22
14827: PUSH
14828: LD_VAR 0 16
14832: PUSH
14833: EMPTY
14834: LIST
14835: LIST
14836: PUSH
14837: LD_INT 35
14839: PUSH
14840: LD_INT 49
14842: PUSH
14843: EMPTY
14844: LIST
14845: LIST
14846: PUSH
14847: LD_INT 91
14849: PUSH
14850: LD_VAR 0 1
14854: PUSH
14855: LD_INT 10
14857: PUSH
14858: EMPTY
14859: LIST
14860: LIST
14861: LIST
14862: PUSH
14863: EMPTY
14864: LIST
14865: LIST
14866: LIST
14867: PPUSH
14868: CALL_OW 69
14872: NOT
14873: IFFALSE 14883
// weapon := ru_time_lapser ;
14875: LD_ADDR_VAR 0 18
14879: PUSH
14880: LD_INT 49
14882: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
14883: LD_VAR 0 12
14887: PUSH
14888: LD_INT 1
14890: PUSH
14891: LD_INT 2
14893: PUSH
14894: EMPTY
14895: LIST
14896: LIST
14897: IN
14898: PUSH
14899: LD_INT 11
14901: PUSH
14902: LD_VAR 0 5
14906: IN
14907: PUSH
14908: LD_INT 30
14910: PUSH
14911: LD_VAR 0 5
14915: IN
14916: OR
14917: AND
14918: PUSH
14919: LD_INT 6
14921: PPUSH
14922: LD_VAR 0 16
14926: PPUSH
14927: CALL_OW 321
14931: PUSH
14932: LD_INT 2
14934: EQUAL
14935: AND
14936: IFFALSE 15101
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
14938: LD_INT 22
14940: PUSH
14941: LD_VAR 0 16
14945: PUSH
14946: EMPTY
14947: LIST
14948: LIST
14949: PUSH
14950: LD_INT 2
14952: PUSH
14953: LD_INT 35
14955: PUSH
14956: LD_INT 11
14958: PUSH
14959: EMPTY
14960: LIST
14961: LIST
14962: PUSH
14963: LD_INT 35
14965: PUSH
14966: LD_INT 30
14968: PUSH
14969: EMPTY
14970: LIST
14971: LIST
14972: PUSH
14973: EMPTY
14974: LIST
14975: LIST
14976: LIST
14977: PUSH
14978: LD_INT 91
14980: PUSH
14981: LD_VAR 0 1
14985: PUSH
14986: LD_INT 18
14988: PUSH
14989: EMPTY
14990: LIST
14991: LIST
14992: LIST
14993: PUSH
14994: EMPTY
14995: LIST
14996: LIST
14997: LIST
14998: PPUSH
14999: CALL_OW 69
15003: NOT
15004: PUSH
15005: LD_INT 22
15007: PUSH
15008: LD_VAR 0 16
15012: PUSH
15013: EMPTY
15014: LIST
15015: LIST
15016: PUSH
15017: LD_INT 2
15019: PUSH
15020: LD_INT 30
15022: PUSH
15023: LD_INT 32
15025: PUSH
15026: EMPTY
15027: LIST
15028: LIST
15029: PUSH
15030: LD_INT 30
15032: PUSH
15033: LD_INT 33
15035: PUSH
15036: EMPTY
15037: LIST
15038: LIST
15039: PUSH
15040: EMPTY
15041: LIST
15042: LIST
15043: LIST
15044: PUSH
15045: LD_INT 91
15047: PUSH
15048: LD_VAR 0 1
15052: PUSH
15053: LD_INT 12
15055: PUSH
15056: EMPTY
15057: LIST
15058: LIST
15059: LIST
15060: PUSH
15061: EMPTY
15062: LIST
15063: LIST
15064: LIST
15065: PUSH
15066: EMPTY
15067: LIST
15068: PPUSH
15069: CALL_OW 69
15073: PUSH
15074: LD_INT 2
15076: GREATER
15077: AND
15078: IFFALSE 15101
// weapon := [ us_radar , ar_radar ] [ nat ] ;
15080: LD_ADDR_VAR 0 18
15084: PUSH
15085: LD_INT 11
15087: PUSH
15088: LD_INT 30
15090: PUSH
15091: EMPTY
15092: LIST
15093: LIST
15094: PUSH
15095: LD_VAR 0 12
15099: ARRAY
15100: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
15101: LD_VAR 0 18
15105: NOT
15106: PUSH
15107: LD_INT 40
15109: PPUSH
15110: LD_VAR 0 16
15114: PPUSH
15115: CALL_OW 321
15119: PUSH
15120: LD_INT 2
15122: EQUAL
15123: AND
15124: PUSH
15125: LD_INT 7
15127: PUSH
15128: LD_VAR 0 5
15132: IN
15133: PUSH
15134: LD_INT 28
15136: PUSH
15137: LD_VAR 0 5
15141: IN
15142: OR
15143: PUSH
15144: LD_INT 45
15146: PUSH
15147: LD_VAR 0 5
15151: IN
15152: OR
15153: AND
15154: IFFALSE 15408
// begin hex := GetHexInfo ( x , y ) ;
15156: LD_ADDR_VAR 0 4
15160: PUSH
15161: LD_VAR 0 10
15165: PPUSH
15166: LD_VAR 0 11
15170: PPUSH
15171: CALL_OW 546
15175: ST_TO_ADDR
// if hex [ 1 ] then
15176: LD_VAR 0 4
15180: PUSH
15181: LD_INT 1
15183: ARRAY
15184: IFFALSE 15188
// exit ;
15186: GO 15591
// height := hex [ 2 ] ;
15188: LD_ADDR_VAR 0 15
15192: PUSH
15193: LD_VAR 0 4
15197: PUSH
15198: LD_INT 2
15200: ARRAY
15201: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
15202: LD_ADDR_VAR 0 14
15206: PUSH
15207: LD_INT 0
15209: PUSH
15210: LD_INT 2
15212: PUSH
15213: LD_INT 3
15215: PUSH
15216: LD_INT 5
15218: PUSH
15219: EMPTY
15220: LIST
15221: LIST
15222: LIST
15223: LIST
15224: ST_TO_ADDR
// for i in tmp do
15225: LD_ADDR_VAR 0 8
15229: PUSH
15230: LD_VAR 0 14
15234: PUSH
15235: FOR_IN
15236: IFFALSE 15406
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
15238: LD_ADDR_VAR 0 9
15242: PUSH
15243: LD_VAR 0 10
15247: PPUSH
15248: LD_VAR 0 8
15252: PPUSH
15253: LD_INT 5
15255: PPUSH
15256: CALL_OW 272
15260: PUSH
15261: LD_VAR 0 11
15265: PPUSH
15266: LD_VAR 0 8
15270: PPUSH
15271: LD_INT 5
15273: PPUSH
15274: CALL_OW 273
15278: PUSH
15279: EMPTY
15280: LIST
15281: LIST
15282: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
15283: LD_VAR 0 9
15287: PUSH
15288: LD_INT 1
15290: ARRAY
15291: PPUSH
15292: LD_VAR 0 9
15296: PUSH
15297: LD_INT 2
15299: ARRAY
15300: PPUSH
15301: CALL_OW 488
15305: IFFALSE 15404
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
15307: LD_ADDR_VAR 0 4
15311: PUSH
15312: LD_VAR 0 9
15316: PUSH
15317: LD_INT 1
15319: ARRAY
15320: PPUSH
15321: LD_VAR 0 9
15325: PUSH
15326: LD_INT 2
15328: ARRAY
15329: PPUSH
15330: CALL_OW 546
15334: ST_TO_ADDR
// if hex [ 1 ] then
15335: LD_VAR 0 4
15339: PUSH
15340: LD_INT 1
15342: ARRAY
15343: IFFALSE 15347
// continue ;
15345: GO 15235
// h := hex [ 2 ] ;
15347: LD_ADDR_VAR 0 13
15351: PUSH
15352: LD_VAR 0 4
15356: PUSH
15357: LD_INT 2
15359: ARRAY
15360: ST_TO_ADDR
// if h + 7 < height then
15361: LD_VAR 0 13
15365: PUSH
15366: LD_INT 7
15368: PLUS
15369: PUSH
15370: LD_VAR 0 15
15374: LESS
15375: IFFALSE 15404
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
15377: LD_ADDR_VAR 0 18
15381: PUSH
15382: LD_INT 7
15384: PUSH
15385: LD_INT 28
15387: PUSH
15388: LD_INT 45
15390: PUSH
15391: EMPTY
15392: LIST
15393: LIST
15394: LIST
15395: PUSH
15396: LD_VAR 0 12
15400: ARRAY
15401: ST_TO_ADDR
// break ;
15402: GO 15406
// end ; end ; end ;
15404: GO 15235
15406: POP
15407: POP
// end ; if not weapon then
15408: LD_VAR 0 18
15412: NOT
15413: IFFALSE 15473
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
15415: LD_ADDR_VAR 0 5
15419: PUSH
15420: LD_VAR 0 5
15424: PUSH
15425: LD_INT 11
15427: PUSH
15428: LD_INT 30
15430: PUSH
15431: LD_INT 49
15433: PUSH
15434: EMPTY
15435: LIST
15436: LIST
15437: LIST
15438: DIFF
15439: ST_TO_ADDR
// if not list then
15440: LD_VAR 0 5
15444: NOT
15445: IFFALSE 15449
// exit ;
15447: GO 15591
// weapon := list [ rand ( 1 , list ) ] ;
15449: LD_ADDR_VAR 0 18
15453: PUSH
15454: LD_VAR 0 5
15458: PUSH
15459: LD_INT 1
15461: PPUSH
15462: LD_VAR 0 5
15466: PPUSH
15467: CALL_OW 12
15471: ARRAY
15472: ST_TO_ADDR
// end ; if weapon then
15473: LD_VAR 0 18
15477: IFFALSE 15591
// begin tmp := CostOfWeapon ( weapon ) ;
15479: LD_ADDR_VAR 0 14
15483: PUSH
15484: LD_VAR 0 18
15488: PPUSH
15489: CALL_OW 451
15493: ST_TO_ADDR
// j := GetBase ( tower ) ;
15494: LD_ADDR_VAR 0 9
15498: PUSH
15499: LD_VAR 0 1
15503: PPUSH
15504: CALL_OW 274
15508: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
15509: LD_VAR 0 9
15513: PPUSH
15514: LD_INT 1
15516: PPUSH
15517: CALL_OW 275
15521: PUSH
15522: LD_VAR 0 14
15526: PUSH
15527: LD_INT 1
15529: ARRAY
15530: GREATEREQUAL
15531: PUSH
15532: LD_VAR 0 9
15536: PPUSH
15537: LD_INT 2
15539: PPUSH
15540: CALL_OW 275
15544: PUSH
15545: LD_VAR 0 14
15549: PUSH
15550: LD_INT 2
15552: ARRAY
15553: GREATEREQUAL
15554: AND
15555: PUSH
15556: LD_VAR 0 9
15560: PPUSH
15561: LD_INT 3
15563: PPUSH
15564: CALL_OW 275
15568: PUSH
15569: LD_VAR 0 14
15573: PUSH
15574: LD_INT 3
15576: ARRAY
15577: GREATEREQUAL
15578: AND
15579: IFFALSE 15591
// result := weapon ;
15581: LD_ADDR_VAR 0 3
15585: PUSH
15586: LD_VAR 0 18
15590: ST_TO_ADDR
// end ; end ;
15591: LD_VAR 0 3
15595: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
15596: LD_INT 0
15598: PPUSH
15599: PPUSH
// result := true ;
15600: LD_ADDR_VAR 0 3
15604: PUSH
15605: LD_INT 1
15607: ST_TO_ADDR
// if array1 = array2 then
15608: LD_VAR 0 1
15612: PUSH
15613: LD_VAR 0 2
15617: EQUAL
15618: IFFALSE 15678
// begin for i = 1 to array1 do
15620: LD_ADDR_VAR 0 4
15624: PUSH
15625: DOUBLE
15626: LD_INT 1
15628: DEC
15629: ST_TO_ADDR
15630: LD_VAR 0 1
15634: PUSH
15635: FOR_TO
15636: IFFALSE 15674
// if array1 [ i ] <> array2 [ i ] then
15638: LD_VAR 0 1
15642: PUSH
15643: LD_VAR 0 4
15647: ARRAY
15648: PUSH
15649: LD_VAR 0 2
15653: PUSH
15654: LD_VAR 0 4
15658: ARRAY
15659: NONEQUAL
15660: IFFALSE 15672
// begin result := false ;
15662: LD_ADDR_VAR 0 3
15666: PUSH
15667: LD_INT 0
15669: ST_TO_ADDR
// break ;
15670: GO 15674
// end ;
15672: GO 15635
15674: POP
15675: POP
// end else
15676: GO 15686
// result := false ;
15678: LD_ADDR_VAR 0 3
15682: PUSH
15683: LD_INT 0
15685: ST_TO_ADDR
// end ;
15686: LD_VAR 0 3
15690: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
15691: LD_INT 0
15693: PPUSH
15694: PPUSH
15695: PPUSH
// pom := GetBase ( fac ) ;
15696: LD_ADDR_VAR 0 5
15700: PUSH
15701: LD_VAR 0 1
15705: PPUSH
15706: CALL_OW 274
15710: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
15711: LD_ADDR_VAR 0 4
15715: PUSH
15716: LD_VAR 0 2
15720: PUSH
15721: LD_INT 1
15723: ARRAY
15724: PPUSH
15725: LD_VAR 0 2
15729: PUSH
15730: LD_INT 2
15732: ARRAY
15733: PPUSH
15734: LD_VAR 0 2
15738: PUSH
15739: LD_INT 3
15741: ARRAY
15742: PPUSH
15743: LD_VAR 0 2
15747: PUSH
15748: LD_INT 4
15750: ARRAY
15751: PPUSH
15752: CALL_OW 449
15756: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
15757: LD_ADDR_VAR 0 3
15761: PUSH
15762: LD_VAR 0 5
15766: PPUSH
15767: LD_INT 1
15769: PPUSH
15770: CALL_OW 275
15774: PUSH
15775: LD_VAR 0 4
15779: PUSH
15780: LD_INT 1
15782: ARRAY
15783: GREATEREQUAL
15784: PUSH
15785: LD_VAR 0 5
15789: PPUSH
15790: LD_INT 2
15792: PPUSH
15793: CALL_OW 275
15797: PUSH
15798: LD_VAR 0 4
15802: PUSH
15803: LD_INT 2
15805: ARRAY
15806: GREATEREQUAL
15807: AND
15808: PUSH
15809: LD_VAR 0 5
15813: PPUSH
15814: LD_INT 3
15816: PPUSH
15817: CALL_OW 275
15821: PUSH
15822: LD_VAR 0 4
15826: PUSH
15827: LD_INT 3
15829: ARRAY
15830: GREATEREQUAL
15831: AND
15832: ST_TO_ADDR
// end ;
15833: LD_VAR 0 3
15837: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
15838: LD_INT 0
15840: PPUSH
15841: PPUSH
15842: PPUSH
15843: PPUSH
// pom := GetBase ( building ) ;
15844: LD_ADDR_VAR 0 3
15848: PUSH
15849: LD_VAR 0 1
15853: PPUSH
15854: CALL_OW 274
15858: ST_TO_ADDR
// if not pom then
15859: LD_VAR 0 3
15863: NOT
15864: IFFALSE 15868
// exit ;
15866: GO 16038
// btype := GetBType ( building ) ;
15868: LD_ADDR_VAR 0 5
15872: PUSH
15873: LD_VAR 0 1
15877: PPUSH
15878: CALL_OW 266
15882: ST_TO_ADDR
// if btype = b_armoury then
15883: LD_VAR 0 5
15887: PUSH
15888: LD_INT 4
15890: EQUAL
15891: IFFALSE 15901
// btype := b_barracks ;
15893: LD_ADDR_VAR 0 5
15897: PUSH
15898: LD_INT 5
15900: ST_TO_ADDR
// if btype = b_depot then
15901: LD_VAR 0 5
15905: PUSH
15906: LD_INT 0
15908: EQUAL
15909: IFFALSE 15919
// btype := b_warehouse ;
15911: LD_ADDR_VAR 0 5
15915: PUSH
15916: LD_INT 1
15918: ST_TO_ADDR
// if btype = b_workshop then
15919: LD_VAR 0 5
15923: PUSH
15924: LD_INT 2
15926: EQUAL
15927: IFFALSE 15937
// btype := b_factory ;
15929: LD_ADDR_VAR 0 5
15933: PUSH
15934: LD_INT 3
15936: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
15937: LD_ADDR_VAR 0 4
15941: PUSH
15942: LD_VAR 0 5
15946: PPUSH
15947: LD_VAR 0 1
15951: PPUSH
15952: CALL_OW 248
15956: PPUSH
15957: CALL_OW 450
15961: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
15962: LD_ADDR_VAR 0 2
15966: PUSH
15967: LD_VAR 0 3
15971: PPUSH
15972: LD_INT 1
15974: PPUSH
15975: CALL_OW 275
15979: PUSH
15980: LD_VAR 0 4
15984: PUSH
15985: LD_INT 1
15987: ARRAY
15988: GREATEREQUAL
15989: PUSH
15990: LD_VAR 0 3
15994: PPUSH
15995: LD_INT 2
15997: PPUSH
15998: CALL_OW 275
16002: PUSH
16003: LD_VAR 0 4
16007: PUSH
16008: LD_INT 2
16010: ARRAY
16011: GREATEREQUAL
16012: AND
16013: PUSH
16014: LD_VAR 0 3
16018: PPUSH
16019: LD_INT 3
16021: PPUSH
16022: CALL_OW 275
16026: PUSH
16027: LD_VAR 0 4
16031: PUSH
16032: LD_INT 3
16034: ARRAY
16035: GREATEREQUAL
16036: AND
16037: ST_TO_ADDR
// end ;
16038: LD_VAR 0 2
16042: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
16043: LD_INT 0
16045: PPUSH
16046: PPUSH
16047: PPUSH
// pom := GetBase ( building ) ;
16048: LD_ADDR_VAR 0 4
16052: PUSH
16053: LD_VAR 0 1
16057: PPUSH
16058: CALL_OW 274
16062: ST_TO_ADDR
// if not pom then
16063: LD_VAR 0 4
16067: NOT
16068: IFFALSE 16072
// exit ;
16070: GO 16173
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
16072: LD_ADDR_VAR 0 5
16076: PUSH
16077: LD_VAR 0 2
16081: PPUSH
16082: LD_VAR 0 1
16086: PPUSH
16087: CALL_OW 248
16091: PPUSH
16092: CALL_OW 450
16096: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
16097: LD_ADDR_VAR 0 3
16101: PUSH
16102: LD_VAR 0 4
16106: PPUSH
16107: LD_INT 1
16109: PPUSH
16110: CALL_OW 275
16114: PUSH
16115: LD_VAR 0 5
16119: PUSH
16120: LD_INT 1
16122: ARRAY
16123: GREATEREQUAL
16124: PUSH
16125: LD_VAR 0 4
16129: PPUSH
16130: LD_INT 2
16132: PPUSH
16133: CALL_OW 275
16137: PUSH
16138: LD_VAR 0 5
16142: PUSH
16143: LD_INT 2
16145: ARRAY
16146: GREATEREQUAL
16147: AND
16148: PUSH
16149: LD_VAR 0 4
16153: PPUSH
16154: LD_INT 3
16156: PPUSH
16157: CALL_OW 275
16161: PUSH
16162: LD_VAR 0 5
16166: PUSH
16167: LD_INT 3
16169: ARRAY
16170: GREATEREQUAL
16171: AND
16172: ST_TO_ADDR
// end ;
16173: LD_VAR 0 3
16177: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
16178: LD_INT 0
16180: PPUSH
16181: PPUSH
16182: PPUSH
16183: PPUSH
16184: PPUSH
16185: PPUSH
16186: PPUSH
16187: PPUSH
16188: PPUSH
16189: PPUSH
// result := false ;
16190: LD_ADDR_VAR 0 6
16194: PUSH
16195: LD_INT 0
16197: ST_TO_ADDR
// if not base or not btype or not x or not y then
16198: LD_VAR 0 1
16202: NOT
16203: PUSH
16204: LD_VAR 0 2
16208: NOT
16209: OR
16210: PUSH
16211: LD_VAR 0 3
16215: NOT
16216: OR
16217: PUSH
16218: LD_VAR 0 4
16222: NOT
16223: OR
16224: IFFALSE 16228
// exit ;
16226: GO 16837
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
16228: LD_ADDR_VAR 0 12
16232: PUSH
16233: LD_VAR 0 2
16237: PPUSH
16238: LD_VAR 0 3
16242: PPUSH
16243: LD_VAR 0 4
16247: PPUSH
16248: LD_VAR 0 5
16252: PPUSH
16253: LD_VAR 0 1
16257: PUSH
16258: LD_INT 1
16260: ARRAY
16261: PPUSH
16262: CALL_OW 248
16266: PPUSH
16267: LD_INT 0
16269: PPUSH
16270: CALL 17674 0 6
16274: ST_TO_ADDR
// if not hexes then
16275: LD_VAR 0 12
16279: NOT
16280: IFFALSE 16284
// exit ;
16282: GO 16837
// for i = 1 to hexes do
16284: LD_ADDR_VAR 0 7
16288: PUSH
16289: DOUBLE
16290: LD_INT 1
16292: DEC
16293: ST_TO_ADDR
16294: LD_VAR 0 12
16298: PUSH
16299: FOR_TO
16300: IFFALSE 16835
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
16302: LD_ADDR_VAR 0 11
16306: PUSH
16307: LD_VAR 0 12
16311: PUSH
16312: LD_VAR 0 7
16316: ARRAY
16317: PUSH
16318: LD_INT 1
16320: ARRAY
16321: PPUSH
16322: LD_VAR 0 12
16326: PUSH
16327: LD_VAR 0 7
16331: ARRAY
16332: PUSH
16333: LD_INT 2
16335: ARRAY
16336: PPUSH
16337: CALL_OW 428
16341: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
16342: LD_VAR 0 12
16346: PUSH
16347: LD_VAR 0 7
16351: ARRAY
16352: PUSH
16353: LD_INT 1
16355: ARRAY
16356: PPUSH
16357: LD_VAR 0 12
16361: PUSH
16362: LD_VAR 0 7
16366: ARRAY
16367: PUSH
16368: LD_INT 2
16370: ARRAY
16371: PPUSH
16372: CALL_OW 351
16376: PUSH
16377: LD_VAR 0 12
16381: PUSH
16382: LD_VAR 0 7
16386: ARRAY
16387: PUSH
16388: LD_INT 1
16390: ARRAY
16391: PPUSH
16392: LD_VAR 0 12
16396: PUSH
16397: LD_VAR 0 7
16401: ARRAY
16402: PUSH
16403: LD_INT 2
16405: ARRAY
16406: PPUSH
16407: CALL_OW 488
16411: NOT
16412: OR
16413: PUSH
16414: LD_VAR 0 11
16418: PPUSH
16419: CALL_OW 247
16423: PUSH
16424: LD_INT 3
16426: EQUAL
16427: OR
16428: IFFALSE 16434
// exit ;
16430: POP
16431: POP
16432: GO 16837
// if not tmp or not tmp in base then
16434: LD_VAR 0 11
16438: NOT
16439: PUSH
16440: LD_VAR 0 11
16444: PUSH
16445: LD_VAR 0 1
16449: IN
16450: NOT
16451: OR
16452: IFFALSE 16456
// continue ;
16454: GO 16299
// result := true ;
16456: LD_ADDR_VAR 0 6
16460: PUSH
16461: LD_INT 1
16463: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
16464: LD_ADDR_VAR 0 15
16468: PUSH
16469: LD_VAR 0 1
16473: PPUSH
16474: LD_INT 22
16476: PUSH
16477: LD_VAR 0 11
16481: PPUSH
16482: CALL_OW 255
16486: PUSH
16487: EMPTY
16488: LIST
16489: LIST
16490: PUSH
16491: LD_INT 2
16493: PUSH
16494: LD_INT 30
16496: PUSH
16497: LD_INT 0
16499: PUSH
16500: EMPTY
16501: LIST
16502: LIST
16503: PUSH
16504: LD_INT 30
16506: PUSH
16507: LD_INT 1
16509: PUSH
16510: EMPTY
16511: LIST
16512: LIST
16513: PUSH
16514: EMPTY
16515: LIST
16516: LIST
16517: LIST
16518: PUSH
16519: EMPTY
16520: LIST
16521: LIST
16522: PPUSH
16523: CALL_OW 72
16527: ST_TO_ADDR
// if dep then
16528: LD_VAR 0 15
16532: IFFALSE 16668
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
16534: LD_ADDR_VAR 0 14
16538: PUSH
16539: LD_VAR 0 15
16543: PUSH
16544: LD_INT 1
16546: ARRAY
16547: PPUSH
16548: CALL_OW 250
16552: PPUSH
16553: LD_VAR 0 15
16557: PUSH
16558: LD_INT 1
16560: ARRAY
16561: PPUSH
16562: CALL_OW 254
16566: PPUSH
16567: LD_INT 5
16569: PPUSH
16570: CALL_OW 272
16574: PUSH
16575: LD_VAR 0 15
16579: PUSH
16580: LD_INT 1
16582: ARRAY
16583: PPUSH
16584: CALL_OW 251
16588: PPUSH
16589: LD_VAR 0 15
16593: PUSH
16594: LD_INT 1
16596: ARRAY
16597: PPUSH
16598: CALL_OW 254
16602: PPUSH
16603: LD_INT 5
16605: PPUSH
16606: CALL_OW 273
16610: PUSH
16611: EMPTY
16612: LIST
16613: LIST
16614: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
16615: LD_VAR 0 14
16619: PUSH
16620: LD_INT 1
16622: ARRAY
16623: PPUSH
16624: LD_VAR 0 14
16628: PUSH
16629: LD_INT 2
16631: ARRAY
16632: PPUSH
16633: CALL_OW 488
16637: IFFALSE 16668
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
16639: LD_VAR 0 11
16643: PPUSH
16644: LD_VAR 0 14
16648: PUSH
16649: LD_INT 1
16651: ARRAY
16652: PPUSH
16653: LD_VAR 0 14
16657: PUSH
16658: LD_INT 2
16660: ARRAY
16661: PPUSH
16662: CALL_OW 111
// continue ;
16666: GO 16299
// end ; end ; r := GetDir ( tmp ) ;
16668: LD_ADDR_VAR 0 13
16672: PUSH
16673: LD_VAR 0 11
16677: PPUSH
16678: CALL_OW 254
16682: ST_TO_ADDR
// if r = 5 then
16683: LD_VAR 0 13
16687: PUSH
16688: LD_INT 5
16690: EQUAL
16691: IFFALSE 16701
// r := 0 ;
16693: LD_ADDR_VAR 0 13
16697: PUSH
16698: LD_INT 0
16700: ST_TO_ADDR
// for j = r to 5 do
16701: LD_ADDR_VAR 0 8
16705: PUSH
16706: DOUBLE
16707: LD_VAR 0 13
16711: DEC
16712: ST_TO_ADDR
16713: LD_INT 5
16715: PUSH
16716: FOR_TO
16717: IFFALSE 16831
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
16719: LD_ADDR_VAR 0 9
16723: PUSH
16724: LD_VAR 0 11
16728: PPUSH
16729: CALL_OW 250
16733: PPUSH
16734: LD_VAR 0 8
16738: PPUSH
16739: LD_INT 2
16741: PPUSH
16742: CALL_OW 272
16746: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
16747: LD_ADDR_VAR 0 10
16751: PUSH
16752: LD_VAR 0 11
16756: PPUSH
16757: CALL_OW 251
16761: PPUSH
16762: LD_VAR 0 8
16766: PPUSH
16767: LD_INT 2
16769: PPUSH
16770: CALL_OW 273
16774: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
16775: LD_VAR 0 9
16779: PPUSH
16780: LD_VAR 0 10
16784: PPUSH
16785: CALL_OW 488
16789: PUSH
16790: LD_VAR 0 9
16794: PPUSH
16795: LD_VAR 0 10
16799: PPUSH
16800: CALL_OW 428
16804: NOT
16805: AND
16806: IFFALSE 16829
// begin ComMoveXY ( tmp , _x , _y ) ;
16808: LD_VAR 0 11
16812: PPUSH
16813: LD_VAR 0 9
16817: PPUSH
16818: LD_VAR 0 10
16822: PPUSH
16823: CALL_OW 111
// break ;
16827: GO 16831
// end ; end ;
16829: GO 16716
16831: POP
16832: POP
// end ;
16833: GO 16299
16835: POP
16836: POP
// end ;
16837: LD_VAR 0 6
16841: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
16842: LD_INT 0
16844: PPUSH
16845: PPUSH
16846: PPUSH
16847: PPUSH
16848: PPUSH
16849: PPUSH
16850: PPUSH
16851: PPUSH
16852: PPUSH
16853: PPUSH
// result := false ;
16854: LD_ADDR_VAR 0 6
16858: PUSH
16859: LD_INT 0
16861: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
16862: LD_VAR 0 1
16866: NOT
16867: PUSH
16868: LD_VAR 0 1
16872: PPUSH
16873: CALL_OW 266
16877: PUSH
16878: LD_INT 0
16880: PUSH
16881: LD_INT 1
16883: PUSH
16884: EMPTY
16885: LIST
16886: LIST
16887: IN
16888: NOT
16889: OR
16890: PUSH
16891: LD_VAR 0 2
16895: NOT
16896: OR
16897: PUSH
16898: LD_VAR 0 5
16902: PUSH
16903: LD_INT 0
16905: PUSH
16906: LD_INT 1
16908: PUSH
16909: LD_INT 2
16911: PUSH
16912: LD_INT 3
16914: PUSH
16915: LD_INT 4
16917: PUSH
16918: LD_INT 5
16920: PUSH
16921: EMPTY
16922: LIST
16923: LIST
16924: LIST
16925: LIST
16926: LIST
16927: LIST
16928: IN
16929: NOT
16930: OR
16931: PUSH
16932: LD_VAR 0 3
16936: PPUSH
16937: LD_VAR 0 4
16941: PPUSH
16942: CALL_OW 488
16946: NOT
16947: OR
16948: IFFALSE 16952
// exit ;
16950: GO 17669
// pom := GetBase ( depot ) ;
16952: LD_ADDR_VAR 0 10
16956: PUSH
16957: LD_VAR 0 1
16961: PPUSH
16962: CALL_OW 274
16966: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
16967: LD_ADDR_VAR 0 11
16971: PUSH
16972: LD_VAR 0 2
16976: PPUSH
16977: LD_VAR 0 1
16981: PPUSH
16982: CALL_OW 248
16986: PPUSH
16987: CALL_OW 450
16991: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
16992: LD_VAR 0 10
16996: PPUSH
16997: LD_INT 1
16999: PPUSH
17000: CALL_OW 275
17004: PUSH
17005: LD_VAR 0 11
17009: PUSH
17010: LD_INT 1
17012: ARRAY
17013: GREATEREQUAL
17014: PUSH
17015: LD_VAR 0 10
17019: PPUSH
17020: LD_INT 2
17022: PPUSH
17023: CALL_OW 275
17027: PUSH
17028: LD_VAR 0 11
17032: PUSH
17033: LD_INT 2
17035: ARRAY
17036: GREATEREQUAL
17037: AND
17038: PUSH
17039: LD_VAR 0 10
17043: PPUSH
17044: LD_INT 3
17046: PPUSH
17047: CALL_OW 275
17051: PUSH
17052: LD_VAR 0 11
17056: PUSH
17057: LD_INT 3
17059: ARRAY
17060: GREATEREQUAL
17061: AND
17062: NOT
17063: IFFALSE 17067
// exit ;
17065: GO 17669
// if GetBType ( depot ) = b_depot then
17067: LD_VAR 0 1
17071: PPUSH
17072: CALL_OW 266
17076: PUSH
17077: LD_INT 0
17079: EQUAL
17080: IFFALSE 17092
// dist := 28 else
17082: LD_ADDR_VAR 0 14
17086: PUSH
17087: LD_INT 28
17089: ST_TO_ADDR
17090: GO 17100
// dist := 36 ;
17092: LD_ADDR_VAR 0 14
17096: PUSH
17097: LD_INT 36
17099: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
17100: LD_VAR 0 1
17104: PPUSH
17105: LD_VAR 0 3
17109: PPUSH
17110: LD_VAR 0 4
17114: PPUSH
17115: CALL_OW 297
17119: PUSH
17120: LD_VAR 0 14
17124: GREATER
17125: IFFALSE 17129
// exit ;
17127: GO 17669
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
17129: LD_ADDR_VAR 0 12
17133: PUSH
17134: LD_VAR 0 2
17138: PPUSH
17139: LD_VAR 0 3
17143: PPUSH
17144: LD_VAR 0 4
17148: PPUSH
17149: LD_VAR 0 5
17153: PPUSH
17154: LD_VAR 0 1
17158: PPUSH
17159: CALL_OW 248
17163: PPUSH
17164: LD_INT 0
17166: PPUSH
17167: CALL 17674 0 6
17171: ST_TO_ADDR
// if not hexes then
17172: LD_VAR 0 12
17176: NOT
17177: IFFALSE 17181
// exit ;
17179: GO 17669
// hex := GetHexInfo ( x , y ) ;
17181: LD_ADDR_VAR 0 15
17185: PUSH
17186: LD_VAR 0 3
17190: PPUSH
17191: LD_VAR 0 4
17195: PPUSH
17196: CALL_OW 546
17200: ST_TO_ADDR
// if hex [ 1 ] then
17201: LD_VAR 0 15
17205: PUSH
17206: LD_INT 1
17208: ARRAY
17209: IFFALSE 17213
// exit ;
17211: GO 17669
// height := hex [ 2 ] ;
17213: LD_ADDR_VAR 0 13
17217: PUSH
17218: LD_VAR 0 15
17222: PUSH
17223: LD_INT 2
17225: ARRAY
17226: ST_TO_ADDR
// for i = 1 to hexes do
17227: LD_ADDR_VAR 0 7
17231: PUSH
17232: DOUBLE
17233: LD_INT 1
17235: DEC
17236: ST_TO_ADDR
17237: LD_VAR 0 12
17241: PUSH
17242: FOR_TO
17243: IFFALSE 17573
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
17245: LD_VAR 0 12
17249: PUSH
17250: LD_VAR 0 7
17254: ARRAY
17255: PUSH
17256: LD_INT 1
17258: ARRAY
17259: PPUSH
17260: LD_VAR 0 12
17264: PUSH
17265: LD_VAR 0 7
17269: ARRAY
17270: PUSH
17271: LD_INT 2
17273: ARRAY
17274: PPUSH
17275: CALL_OW 488
17279: NOT
17280: PUSH
17281: LD_VAR 0 12
17285: PUSH
17286: LD_VAR 0 7
17290: ARRAY
17291: PUSH
17292: LD_INT 1
17294: ARRAY
17295: PPUSH
17296: LD_VAR 0 12
17300: PUSH
17301: LD_VAR 0 7
17305: ARRAY
17306: PUSH
17307: LD_INT 2
17309: ARRAY
17310: PPUSH
17311: CALL_OW 428
17315: PUSH
17316: LD_INT 0
17318: GREATER
17319: OR
17320: PUSH
17321: LD_VAR 0 12
17325: PUSH
17326: LD_VAR 0 7
17330: ARRAY
17331: PUSH
17332: LD_INT 1
17334: ARRAY
17335: PPUSH
17336: LD_VAR 0 12
17340: PUSH
17341: LD_VAR 0 7
17345: ARRAY
17346: PUSH
17347: LD_INT 2
17349: ARRAY
17350: PPUSH
17351: CALL_OW 351
17355: OR
17356: IFFALSE 17362
// exit ;
17358: POP
17359: POP
17360: GO 17669
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
17362: LD_ADDR_VAR 0 8
17366: PUSH
17367: LD_VAR 0 12
17371: PUSH
17372: LD_VAR 0 7
17376: ARRAY
17377: PUSH
17378: LD_INT 1
17380: ARRAY
17381: PPUSH
17382: LD_VAR 0 12
17386: PUSH
17387: LD_VAR 0 7
17391: ARRAY
17392: PUSH
17393: LD_INT 2
17395: ARRAY
17396: PPUSH
17397: CALL_OW 546
17401: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
17402: LD_VAR 0 8
17406: PUSH
17407: LD_INT 1
17409: ARRAY
17410: PUSH
17411: LD_VAR 0 8
17415: PUSH
17416: LD_INT 2
17418: ARRAY
17419: PUSH
17420: LD_VAR 0 13
17424: PUSH
17425: LD_INT 2
17427: PLUS
17428: GREATER
17429: OR
17430: PUSH
17431: LD_VAR 0 8
17435: PUSH
17436: LD_INT 2
17438: ARRAY
17439: PUSH
17440: LD_VAR 0 13
17444: PUSH
17445: LD_INT 2
17447: MINUS
17448: LESS
17449: OR
17450: PUSH
17451: LD_VAR 0 8
17455: PUSH
17456: LD_INT 3
17458: ARRAY
17459: PUSH
17460: LD_INT 0
17462: PUSH
17463: LD_INT 8
17465: PUSH
17466: LD_INT 9
17468: PUSH
17469: LD_INT 10
17471: PUSH
17472: LD_INT 11
17474: PUSH
17475: LD_INT 12
17477: PUSH
17478: LD_INT 13
17480: PUSH
17481: LD_INT 16
17483: PUSH
17484: LD_INT 17
17486: PUSH
17487: LD_INT 18
17489: PUSH
17490: LD_INT 19
17492: PUSH
17493: LD_INT 20
17495: PUSH
17496: LD_INT 21
17498: PUSH
17499: EMPTY
17500: LIST
17501: LIST
17502: LIST
17503: LIST
17504: LIST
17505: LIST
17506: LIST
17507: LIST
17508: LIST
17509: LIST
17510: LIST
17511: LIST
17512: LIST
17513: IN
17514: NOT
17515: OR
17516: PUSH
17517: LD_VAR 0 8
17521: PUSH
17522: LD_INT 5
17524: ARRAY
17525: NOT
17526: OR
17527: PUSH
17528: LD_VAR 0 8
17532: PUSH
17533: LD_INT 6
17535: ARRAY
17536: PUSH
17537: LD_INT 1
17539: PUSH
17540: LD_INT 2
17542: PUSH
17543: LD_INT 7
17545: PUSH
17546: LD_INT 9
17548: PUSH
17549: LD_INT 10
17551: PUSH
17552: LD_INT 11
17554: PUSH
17555: EMPTY
17556: LIST
17557: LIST
17558: LIST
17559: LIST
17560: LIST
17561: LIST
17562: IN
17563: NOT
17564: OR
17565: IFFALSE 17571
// exit ;
17567: POP
17568: POP
17569: GO 17669
// end ;
17571: GO 17242
17573: POP
17574: POP
// side := GetSide ( depot ) ;
17575: LD_ADDR_VAR 0 9
17579: PUSH
17580: LD_VAR 0 1
17584: PPUSH
17585: CALL_OW 255
17589: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
17590: LD_VAR 0 9
17594: PPUSH
17595: LD_VAR 0 3
17599: PPUSH
17600: LD_VAR 0 4
17604: PPUSH
17605: LD_INT 20
17607: PPUSH
17608: CALL 10323 0 4
17612: PUSH
17613: LD_INT 4
17615: ARRAY
17616: IFFALSE 17620
// exit ;
17618: GO 17669
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
17620: LD_VAR 0 2
17624: PUSH
17625: LD_INT 29
17627: PUSH
17628: LD_INT 30
17630: PUSH
17631: EMPTY
17632: LIST
17633: LIST
17634: IN
17635: PUSH
17636: LD_VAR 0 3
17640: PPUSH
17641: LD_VAR 0 4
17645: PPUSH
17646: LD_VAR 0 9
17650: PPUSH
17651: CALL_OW 440
17655: NOT
17656: AND
17657: IFFALSE 17661
// exit ;
17659: GO 17669
// result := true ;
17661: LD_ADDR_VAR 0 6
17665: PUSH
17666: LD_INT 1
17668: ST_TO_ADDR
// end ;
17669: LD_VAR 0 6
17673: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
17674: LD_INT 0
17676: PPUSH
17677: PPUSH
17678: PPUSH
17679: PPUSH
17680: PPUSH
17681: PPUSH
17682: PPUSH
17683: PPUSH
17684: PPUSH
17685: PPUSH
17686: PPUSH
17687: PPUSH
17688: PPUSH
17689: PPUSH
17690: PPUSH
17691: PPUSH
17692: PPUSH
17693: PPUSH
17694: PPUSH
17695: PPUSH
17696: PPUSH
17697: PPUSH
17698: PPUSH
17699: PPUSH
17700: PPUSH
17701: PPUSH
17702: PPUSH
17703: PPUSH
17704: PPUSH
17705: PPUSH
17706: PPUSH
17707: PPUSH
17708: PPUSH
17709: PPUSH
17710: PPUSH
17711: PPUSH
17712: PPUSH
17713: PPUSH
17714: PPUSH
17715: PPUSH
17716: PPUSH
17717: PPUSH
17718: PPUSH
17719: PPUSH
17720: PPUSH
17721: PPUSH
17722: PPUSH
17723: PPUSH
17724: PPUSH
17725: PPUSH
17726: PPUSH
17727: PPUSH
17728: PPUSH
17729: PPUSH
17730: PPUSH
17731: PPUSH
17732: PPUSH
17733: PPUSH
// result = [ ] ;
17734: LD_ADDR_VAR 0 7
17738: PUSH
17739: EMPTY
17740: ST_TO_ADDR
// temp_list = [ ] ;
17741: LD_ADDR_VAR 0 9
17745: PUSH
17746: EMPTY
17747: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
17748: LD_VAR 0 4
17752: PUSH
17753: LD_INT 0
17755: PUSH
17756: LD_INT 1
17758: PUSH
17759: LD_INT 2
17761: PUSH
17762: LD_INT 3
17764: PUSH
17765: LD_INT 4
17767: PUSH
17768: LD_INT 5
17770: PUSH
17771: EMPTY
17772: LIST
17773: LIST
17774: LIST
17775: LIST
17776: LIST
17777: LIST
17778: IN
17779: NOT
17780: PUSH
17781: LD_VAR 0 1
17785: PUSH
17786: LD_INT 0
17788: PUSH
17789: LD_INT 1
17791: PUSH
17792: EMPTY
17793: LIST
17794: LIST
17795: IN
17796: PUSH
17797: LD_VAR 0 5
17801: PUSH
17802: LD_INT 1
17804: PUSH
17805: LD_INT 2
17807: PUSH
17808: LD_INT 3
17810: PUSH
17811: EMPTY
17812: LIST
17813: LIST
17814: LIST
17815: IN
17816: NOT
17817: AND
17818: OR
17819: IFFALSE 17823
// exit ;
17821: GO 36214
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
17823: LD_VAR 0 1
17827: PUSH
17828: LD_INT 6
17830: PUSH
17831: LD_INT 7
17833: PUSH
17834: LD_INT 8
17836: PUSH
17837: LD_INT 13
17839: PUSH
17840: LD_INT 12
17842: PUSH
17843: LD_INT 15
17845: PUSH
17846: LD_INT 11
17848: PUSH
17849: LD_INT 14
17851: PUSH
17852: LD_INT 10
17854: PUSH
17855: EMPTY
17856: LIST
17857: LIST
17858: LIST
17859: LIST
17860: LIST
17861: LIST
17862: LIST
17863: LIST
17864: LIST
17865: IN
17866: IFFALSE 17876
// btype = b_lab ;
17868: LD_ADDR_VAR 0 1
17872: PUSH
17873: LD_INT 6
17875: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
17876: LD_VAR 0 6
17880: PUSH
17881: LD_INT 0
17883: PUSH
17884: LD_INT 1
17886: PUSH
17887: LD_INT 2
17889: PUSH
17890: EMPTY
17891: LIST
17892: LIST
17893: LIST
17894: IN
17895: NOT
17896: PUSH
17897: LD_VAR 0 1
17901: PUSH
17902: LD_INT 0
17904: PUSH
17905: LD_INT 1
17907: PUSH
17908: LD_INT 2
17910: PUSH
17911: LD_INT 3
17913: PUSH
17914: LD_INT 6
17916: PUSH
17917: LD_INT 36
17919: PUSH
17920: LD_INT 4
17922: PUSH
17923: LD_INT 5
17925: PUSH
17926: LD_INT 31
17928: PUSH
17929: LD_INT 32
17931: PUSH
17932: LD_INT 33
17934: PUSH
17935: EMPTY
17936: LIST
17937: LIST
17938: LIST
17939: LIST
17940: LIST
17941: LIST
17942: LIST
17943: LIST
17944: LIST
17945: LIST
17946: LIST
17947: IN
17948: NOT
17949: PUSH
17950: LD_VAR 0 6
17954: PUSH
17955: LD_INT 1
17957: EQUAL
17958: AND
17959: OR
17960: PUSH
17961: LD_VAR 0 1
17965: PUSH
17966: LD_INT 2
17968: PUSH
17969: LD_INT 3
17971: PUSH
17972: EMPTY
17973: LIST
17974: LIST
17975: IN
17976: NOT
17977: PUSH
17978: LD_VAR 0 6
17982: PUSH
17983: LD_INT 2
17985: EQUAL
17986: AND
17987: OR
17988: IFFALSE 17998
// mode = 0 ;
17990: LD_ADDR_VAR 0 6
17994: PUSH
17995: LD_INT 0
17997: ST_TO_ADDR
// case mode of 0 :
17998: LD_VAR 0 6
18002: PUSH
18003: LD_INT 0
18005: DOUBLE
18006: EQUAL
18007: IFTRUE 18011
18009: GO 29464
18011: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
18012: LD_ADDR_VAR 0 11
18016: PUSH
18017: LD_INT 0
18019: PUSH
18020: LD_INT 0
18022: PUSH
18023: EMPTY
18024: LIST
18025: LIST
18026: PUSH
18027: LD_INT 0
18029: PUSH
18030: LD_INT 1
18032: NEG
18033: PUSH
18034: EMPTY
18035: LIST
18036: LIST
18037: PUSH
18038: LD_INT 1
18040: PUSH
18041: LD_INT 0
18043: PUSH
18044: EMPTY
18045: LIST
18046: LIST
18047: PUSH
18048: LD_INT 1
18050: PUSH
18051: LD_INT 1
18053: PUSH
18054: EMPTY
18055: LIST
18056: LIST
18057: PUSH
18058: LD_INT 0
18060: PUSH
18061: LD_INT 1
18063: PUSH
18064: EMPTY
18065: LIST
18066: LIST
18067: PUSH
18068: LD_INT 1
18070: NEG
18071: PUSH
18072: LD_INT 0
18074: PUSH
18075: EMPTY
18076: LIST
18077: LIST
18078: PUSH
18079: LD_INT 1
18081: NEG
18082: PUSH
18083: LD_INT 1
18085: NEG
18086: PUSH
18087: EMPTY
18088: LIST
18089: LIST
18090: PUSH
18091: LD_INT 1
18093: NEG
18094: PUSH
18095: LD_INT 2
18097: NEG
18098: PUSH
18099: EMPTY
18100: LIST
18101: LIST
18102: PUSH
18103: LD_INT 0
18105: PUSH
18106: LD_INT 2
18108: NEG
18109: PUSH
18110: EMPTY
18111: LIST
18112: LIST
18113: PUSH
18114: LD_INT 1
18116: PUSH
18117: LD_INT 1
18119: NEG
18120: PUSH
18121: EMPTY
18122: LIST
18123: LIST
18124: PUSH
18125: LD_INT 1
18127: PUSH
18128: LD_INT 2
18130: PUSH
18131: EMPTY
18132: LIST
18133: LIST
18134: PUSH
18135: LD_INT 0
18137: PUSH
18138: LD_INT 2
18140: PUSH
18141: EMPTY
18142: LIST
18143: LIST
18144: PUSH
18145: LD_INT 1
18147: NEG
18148: PUSH
18149: LD_INT 1
18151: PUSH
18152: EMPTY
18153: LIST
18154: LIST
18155: PUSH
18156: LD_INT 1
18158: PUSH
18159: LD_INT 3
18161: PUSH
18162: EMPTY
18163: LIST
18164: LIST
18165: PUSH
18166: LD_INT 0
18168: PUSH
18169: LD_INT 3
18171: PUSH
18172: EMPTY
18173: LIST
18174: LIST
18175: PUSH
18176: LD_INT 1
18178: NEG
18179: PUSH
18180: LD_INT 2
18182: PUSH
18183: EMPTY
18184: LIST
18185: LIST
18186: PUSH
18187: EMPTY
18188: LIST
18189: LIST
18190: LIST
18191: LIST
18192: LIST
18193: LIST
18194: LIST
18195: LIST
18196: LIST
18197: LIST
18198: LIST
18199: LIST
18200: LIST
18201: LIST
18202: LIST
18203: LIST
18204: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
18205: LD_ADDR_VAR 0 12
18209: PUSH
18210: LD_INT 0
18212: PUSH
18213: LD_INT 0
18215: PUSH
18216: EMPTY
18217: LIST
18218: LIST
18219: PUSH
18220: LD_INT 0
18222: PUSH
18223: LD_INT 1
18225: NEG
18226: PUSH
18227: EMPTY
18228: LIST
18229: LIST
18230: PUSH
18231: LD_INT 1
18233: PUSH
18234: LD_INT 0
18236: PUSH
18237: EMPTY
18238: LIST
18239: LIST
18240: PUSH
18241: LD_INT 1
18243: PUSH
18244: LD_INT 1
18246: PUSH
18247: EMPTY
18248: LIST
18249: LIST
18250: PUSH
18251: LD_INT 0
18253: PUSH
18254: LD_INT 1
18256: PUSH
18257: EMPTY
18258: LIST
18259: LIST
18260: PUSH
18261: LD_INT 1
18263: NEG
18264: PUSH
18265: LD_INT 0
18267: PUSH
18268: EMPTY
18269: LIST
18270: LIST
18271: PUSH
18272: LD_INT 1
18274: NEG
18275: PUSH
18276: LD_INT 1
18278: NEG
18279: PUSH
18280: EMPTY
18281: LIST
18282: LIST
18283: PUSH
18284: LD_INT 1
18286: PUSH
18287: LD_INT 1
18289: NEG
18290: PUSH
18291: EMPTY
18292: LIST
18293: LIST
18294: PUSH
18295: LD_INT 2
18297: PUSH
18298: LD_INT 0
18300: PUSH
18301: EMPTY
18302: LIST
18303: LIST
18304: PUSH
18305: LD_INT 2
18307: PUSH
18308: LD_INT 1
18310: PUSH
18311: EMPTY
18312: LIST
18313: LIST
18314: PUSH
18315: LD_INT 1
18317: NEG
18318: PUSH
18319: LD_INT 1
18321: PUSH
18322: EMPTY
18323: LIST
18324: LIST
18325: PUSH
18326: LD_INT 2
18328: NEG
18329: PUSH
18330: LD_INT 0
18332: PUSH
18333: EMPTY
18334: LIST
18335: LIST
18336: PUSH
18337: LD_INT 2
18339: NEG
18340: PUSH
18341: LD_INT 1
18343: NEG
18344: PUSH
18345: EMPTY
18346: LIST
18347: LIST
18348: PUSH
18349: LD_INT 2
18351: NEG
18352: PUSH
18353: LD_INT 1
18355: PUSH
18356: EMPTY
18357: LIST
18358: LIST
18359: PUSH
18360: LD_INT 3
18362: NEG
18363: PUSH
18364: LD_INT 0
18366: PUSH
18367: EMPTY
18368: LIST
18369: LIST
18370: PUSH
18371: LD_INT 3
18373: NEG
18374: PUSH
18375: LD_INT 1
18377: NEG
18378: PUSH
18379: EMPTY
18380: LIST
18381: LIST
18382: PUSH
18383: EMPTY
18384: LIST
18385: LIST
18386: LIST
18387: LIST
18388: LIST
18389: LIST
18390: LIST
18391: LIST
18392: LIST
18393: LIST
18394: LIST
18395: LIST
18396: LIST
18397: LIST
18398: LIST
18399: LIST
18400: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
18401: LD_ADDR_VAR 0 13
18405: PUSH
18406: LD_INT 0
18408: PUSH
18409: LD_INT 0
18411: PUSH
18412: EMPTY
18413: LIST
18414: LIST
18415: PUSH
18416: LD_INT 0
18418: PUSH
18419: LD_INT 1
18421: NEG
18422: PUSH
18423: EMPTY
18424: LIST
18425: LIST
18426: PUSH
18427: LD_INT 1
18429: PUSH
18430: LD_INT 0
18432: PUSH
18433: EMPTY
18434: LIST
18435: LIST
18436: PUSH
18437: LD_INT 1
18439: PUSH
18440: LD_INT 1
18442: PUSH
18443: EMPTY
18444: LIST
18445: LIST
18446: PUSH
18447: LD_INT 0
18449: PUSH
18450: LD_INT 1
18452: PUSH
18453: EMPTY
18454: LIST
18455: LIST
18456: PUSH
18457: LD_INT 1
18459: NEG
18460: PUSH
18461: LD_INT 0
18463: PUSH
18464: EMPTY
18465: LIST
18466: LIST
18467: PUSH
18468: LD_INT 1
18470: NEG
18471: PUSH
18472: LD_INT 1
18474: NEG
18475: PUSH
18476: EMPTY
18477: LIST
18478: LIST
18479: PUSH
18480: LD_INT 1
18482: NEG
18483: PUSH
18484: LD_INT 2
18486: NEG
18487: PUSH
18488: EMPTY
18489: LIST
18490: LIST
18491: PUSH
18492: LD_INT 2
18494: PUSH
18495: LD_INT 1
18497: PUSH
18498: EMPTY
18499: LIST
18500: LIST
18501: PUSH
18502: LD_INT 2
18504: PUSH
18505: LD_INT 2
18507: PUSH
18508: EMPTY
18509: LIST
18510: LIST
18511: PUSH
18512: LD_INT 1
18514: PUSH
18515: LD_INT 2
18517: PUSH
18518: EMPTY
18519: LIST
18520: LIST
18521: PUSH
18522: LD_INT 2
18524: NEG
18525: PUSH
18526: LD_INT 1
18528: NEG
18529: PUSH
18530: EMPTY
18531: LIST
18532: LIST
18533: PUSH
18534: LD_INT 2
18536: NEG
18537: PUSH
18538: LD_INT 2
18540: NEG
18541: PUSH
18542: EMPTY
18543: LIST
18544: LIST
18545: PUSH
18546: LD_INT 2
18548: NEG
18549: PUSH
18550: LD_INT 3
18552: NEG
18553: PUSH
18554: EMPTY
18555: LIST
18556: LIST
18557: PUSH
18558: LD_INT 3
18560: NEG
18561: PUSH
18562: LD_INT 2
18564: NEG
18565: PUSH
18566: EMPTY
18567: LIST
18568: LIST
18569: PUSH
18570: LD_INT 3
18572: NEG
18573: PUSH
18574: LD_INT 3
18576: NEG
18577: PUSH
18578: EMPTY
18579: LIST
18580: LIST
18581: PUSH
18582: EMPTY
18583: LIST
18584: LIST
18585: LIST
18586: LIST
18587: LIST
18588: LIST
18589: LIST
18590: LIST
18591: LIST
18592: LIST
18593: LIST
18594: LIST
18595: LIST
18596: LIST
18597: LIST
18598: LIST
18599: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
18600: LD_ADDR_VAR 0 14
18604: PUSH
18605: LD_INT 0
18607: PUSH
18608: LD_INT 0
18610: PUSH
18611: EMPTY
18612: LIST
18613: LIST
18614: PUSH
18615: LD_INT 0
18617: PUSH
18618: LD_INT 1
18620: NEG
18621: PUSH
18622: EMPTY
18623: LIST
18624: LIST
18625: PUSH
18626: LD_INT 1
18628: PUSH
18629: LD_INT 0
18631: PUSH
18632: EMPTY
18633: LIST
18634: LIST
18635: PUSH
18636: LD_INT 1
18638: PUSH
18639: LD_INT 1
18641: PUSH
18642: EMPTY
18643: LIST
18644: LIST
18645: PUSH
18646: LD_INT 0
18648: PUSH
18649: LD_INT 1
18651: PUSH
18652: EMPTY
18653: LIST
18654: LIST
18655: PUSH
18656: LD_INT 1
18658: NEG
18659: PUSH
18660: LD_INT 0
18662: PUSH
18663: EMPTY
18664: LIST
18665: LIST
18666: PUSH
18667: LD_INT 1
18669: NEG
18670: PUSH
18671: LD_INT 1
18673: NEG
18674: PUSH
18675: EMPTY
18676: LIST
18677: LIST
18678: PUSH
18679: LD_INT 1
18681: NEG
18682: PUSH
18683: LD_INT 2
18685: NEG
18686: PUSH
18687: EMPTY
18688: LIST
18689: LIST
18690: PUSH
18691: LD_INT 0
18693: PUSH
18694: LD_INT 2
18696: NEG
18697: PUSH
18698: EMPTY
18699: LIST
18700: LIST
18701: PUSH
18702: LD_INT 1
18704: PUSH
18705: LD_INT 1
18707: NEG
18708: PUSH
18709: EMPTY
18710: LIST
18711: LIST
18712: PUSH
18713: LD_INT 1
18715: PUSH
18716: LD_INT 2
18718: PUSH
18719: EMPTY
18720: LIST
18721: LIST
18722: PUSH
18723: LD_INT 0
18725: PUSH
18726: LD_INT 2
18728: PUSH
18729: EMPTY
18730: LIST
18731: LIST
18732: PUSH
18733: LD_INT 1
18735: NEG
18736: PUSH
18737: LD_INT 1
18739: PUSH
18740: EMPTY
18741: LIST
18742: LIST
18743: PUSH
18744: LD_INT 1
18746: NEG
18747: PUSH
18748: LD_INT 3
18750: NEG
18751: PUSH
18752: EMPTY
18753: LIST
18754: LIST
18755: PUSH
18756: LD_INT 0
18758: PUSH
18759: LD_INT 3
18761: NEG
18762: PUSH
18763: EMPTY
18764: LIST
18765: LIST
18766: PUSH
18767: LD_INT 1
18769: PUSH
18770: LD_INT 2
18772: NEG
18773: PUSH
18774: EMPTY
18775: LIST
18776: LIST
18777: PUSH
18778: EMPTY
18779: LIST
18780: LIST
18781: LIST
18782: LIST
18783: LIST
18784: LIST
18785: LIST
18786: LIST
18787: LIST
18788: LIST
18789: LIST
18790: LIST
18791: LIST
18792: LIST
18793: LIST
18794: LIST
18795: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
18796: LD_ADDR_VAR 0 15
18800: PUSH
18801: LD_INT 0
18803: PUSH
18804: LD_INT 0
18806: PUSH
18807: EMPTY
18808: LIST
18809: LIST
18810: PUSH
18811: LD_INT 0
18813: PUSH
18814: LD_INT 1
18816: NEG
18817: PUSH
18818: EMPTY
18819: LIST
18820: LIST
18821: PUSH
18822: LD_INT 1
18824: PUSH
18825: LD_INT 0
18827: PUSH
18828: EMPTY
18829: LIST
18830: LIST
18831: PUSH
18832: LD_INT 1
18834: PUSH
18835: LD_INT 1
18837: PUSH
18838: EMPTY
18839: LIST
18840: LIST
18841: PUSH
18842: LD_INT 0
18844: PUSH
18845: LD_INT 1
18847: PUSH
18848: EMPTY
18849: LIST
18850: LIST
18851: PUSH
18852: LD_INT 1
18854: NEG
18855: PUSH
18856: LD_INT 0
18858: PUSH
18859: EMPTY
18860: LIST
18861: LIST
18862: PUSH
18863: LD_INT 1
18865: NEG
18866: PUSH
18867: LD_INT 1
18869: NEG
18870: PUSH
18871: EMPTY
18872: LIST
18873: LIST
18874: PUSH
18875: LD_INT 1
18877: PUSH
18878: LD_INT 1
18880: NEG
18881: PUSH
18882: EMPTY
18883: LIST
18884: LIST
18885: PUSH
18886: LD_INT 2
18888: PUSH
18889: LD_INT 0
18891: PUSH
18892: EMPTY
18893: LIST
18894: LIST
18895: PUSH
18896: LD_INT 2
18898: PUSH
18899: LD_INT 1
18901: PUSH
18902: EMPTY
18903: LIST
18904: LIST
18905: PUSH
18906: LD_INT 1
18908: NEG
18909: PUSH
18910: LD_INT 1
18912: PUSH
18913: EMPTY
18914: LIST
18915: LIST
18916: PUSH
18917: LD_INT 2
18919: NEG
18920: PUSH
18921: LD_INT 0
18923: PUSH
18924: EMPTY
18925: LIST
18926: LIST
18927: PUSH
18928: LD_INT 2
18930: NEG
18931: PUSH
18932: LD_INT 1
18934: NEG
18935: PUSH
18936: EMPTY
18937: LIST
18938: LIST
18939: PUSH
18940: LD_INT 2
18942: PUSH
18943: LD_INT 1
18945: NEG
18946: PUSH
18947: EMPTY
18948: LIST
18949: LIST
18950: PUSH
18951: LD_INT 3
18953: PUSH
18954: LD_INT 0
18956: PUSH
18957: EMPTY
18958: LIST
18959: LIST
18960: PUSH
18961: LD_INT 3
18963: PUSH
18964: LD_INT 1
18966: PUSH
18967: EMPTY
18968: LIST
18969: LIST
18970: PUSH
18971: EMPTY
18972: LIST
18973: LIST
18974: LIST
18975: LIST
18976: LIST
18977: LIST
18978: LIST
18979: LIST
18980: LIST
18981: LIST
18982: LIST
18983: LIST
18984: LIST
18985: LIST
18986: LIST
18987: LIST
18988: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
18989: LD_ADDR_VAR 0 16
18993: PUSH
18994: LD_INT 0
18996: PUSH
18997: LD_INT 0
18999: PUSH
19000: EMPTY
19001: LIST
19002: LIST
19003: PUSH
19004: LD_INT 0
19006: PUSH
19007: LD_INT 1
19009: NEG
19010: PUSH
19011: EMPTY
19012: LIST
19013: LIST
19014: PUSH
19015: LD_INT 1
19017: PUSH
19018: LD_INT 0
19020: PUSH
19021: EMPTY
19022: LIST
19023: LIST
19024: PUSH
19025: LD_INT 1
19027: PUSH
19028: LD_INT 1
19030: PUSH
19031: EMPTY
19032: LIST
19033: LIST
19034: PUSH
19035: LD_INT 0
19037: PUSH
19038: LD_INT 1
19040: PUSH
19041: EMPTY
19042: LIST
19043: LIST
19044: PUSH
19045: LD_INT 1
19047: NEG
19048: PUSH
19049: LD_INT 0
19051: PUSH
19052: EMPTY
19053: LIST
19054: LIST
19055: PUSH
19056: LD_INT 1
19058: NEG
19059: PUSH
19060: LD_INT 1
19062: NEG
19063: PUSH
19064: EMPTY
19065: LIST
19066: LIST
19067: PUSH
19068: LD_INT 1
19070: NEG
19071: PUSH
19072: LD_INT 2
19074: NEG
19075: PUSH
19076: EMPTY
19077: LIST
19078: LIST
19079: PUSH
19080: LD_INT 2
19082: PUSH
19083: LD_INT 1
19085: PUSH
19086: EMPTY
19087: LIST
19088: LIST
19089: PUSH
19090: LD_INT 2
19092: PUSH
19093: LD_INT 2
19095: PUSH
19096: EMPTY
19097: LIST
19098: LIST
19099: PUSH
19100: LD_INT 1
19102: PUSH
19103: LD_INT 2
19105: PUSH
19106: EMPTY
19107: LIST
19108: LIST
19109: PUSH
19110: LD_INT 2
19112: NEG
19113: PUSH
19114: LD_INT 1
19116: NEG
19117: PUSH
19118: EMPTY
19119: LIST
19120: LIST
19121: PUSH
19122: LD_INT 2
19124: NEG
19125: PUSH
19126: LD_INT 2
19128: NEG
19129: PUSH
19130: EMPTY
19131: LIST
19132: LIST
19133: PUSH
19134: LD_INT 3
19136: PUSH
19137: LD_INT 2
19139: PUSH
19140: EMPTY
19141: LIST
19142: LIST
19143: PUSH
19144: LD_INT 3
19146: PUSH
19147: LD_INT 3
19149: PUSH
19150: EMPTY
19151: LIST
19152: LIST
19153: PUSH
19154: LD_INT 2
19156: PUSH
19157: LD_INT 3
19159: PUSH
19160: EMPTY
19161: LIST
19162: LIST
19163: PUSH
19164: EMPTY
19165: LIST
19166: LIST
19167: LIST
19168: LIST
19169: LIST
19170: LIST
19171: LIST
19172: LIST
19173: LIST
19174: LIST
19175: LIST
19176: LIST
19177: LIST
19178: LIST
19179: LIST
19180: LIST
19181: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
19182: LD_ADDR_VAR 0 17
19186: PUSH
19187: LD_INT 0
19189: PUSH
19190: LD_INT 0
19192: PUSH
19193: EMPTY
19194: LIST
19195: LIST
19196: PUSH
19197: LD_INT 0
19199: PUSH
19200: LD_INT 1
19202: NEG
19203: PUSH
19204: EMPTY
19205: LIST
19206: LIST
19207: PUSH
19208: LD_INT 1
19210: PUSH
19211: LD_INT 0
19213: PUSH
19214: EMPTY
19215: LIST
19216: LIST
19217: PUSH
19218: LD_INT 1
19220: PUSH
19221: LD_INT 1
19223: PUSH
19224: EMPTY
19225: LIST
19226: LIST
19227: PUSH
19228: LD_INT 0
19230: PUSH
19231: LD_INT 1
19233: PUSH
19234: EMPTY
19235: LIST
19236: LIST
19237: PUSH
19238: LD_INT 1
19240: NEG
19241: PUSH
19242: LD_INT 0
19244: PUSH
19245: EMPTY
19246: LIST
19247: LIST
19248: PUSH
19249: LD_INT 1
19251: NEG
19252: PUSH
19253: LD_INT 1
19255: NEG
19256: PUSH
19257: EMPTY
19258: LIST
19259: LIST
19260: PUSH
19261: LD_INT 1
19263: NEG
19264: PUSH
19265: LD_INT 2
19267: NEG
19268: PUSH
19269: EMPTY
19270: LIST
19271: LIST
19272: PUSH
19273: LD_INT 0
19275: PUSH
19276: LD_INT 2
19278: NEG
19279: PUSH
19280: EMPTY
19281: LIST
19282: LIST
19283: PUSH
19284: LD_INT 1
19286: PUSH
19287: LD_INT 1
19289: NEG
19290: PUSH
19291: EMPTY
19292: LIST
19293: LIST
19294: PUSH
19295: LD_INT 2
19297: PUSH
19298: LD_INT 0
19300: PUSH
19301: EMPTY
19302: LIST
19303: LIST
19304: PUSH
19305: LD_INT 2
19307: PUSH
19308: LD_INT 1
19310: PUSH
19311: EMPTY
19312: LIST
19313: LIST
19314: PUSH
19315: LD_INT 2
19317: PUSH
19318: LD_INT 2
19320: PUSH
19321: EMPTY
19322: LIST
19323: LIST
19324: PUSH
19325: LD_INT 1
19327: PUSH
19328: LD_INT 2
19330: PUSH
19331: EMPTY
19332: LIST
19333: LIST
19334: PUSH
19335: LD_INT 0
19337: PUSH
19338: LD_INT 2
19340: PUSH
19341: EMPTY
19342: LIST
19343: LIST
19344: PUSH
19345: LD_INT 1
19347: NEG
19348: PUSH
19349: LD_INT 1
19351: PUSH
19352: EMPTY
19353: LIST
19354: LIST
19355: PUSH
19356: LD_INT 2
19358: NEG
19359: PUSH
19360: LD_INT 0
19362: PUSH
19363: EMPTY
19364: LIST
19365: LIST
19366: PUSH
19367: LD_INT 2
19369: NEG
19370: PUSH
19371: LD_INT 1
19373: NEG
19374: PUSH
19375: EMPTY
19376: LIST
19377: LIST
19378: PUSH
19379: LD_INT 2
19381: NEG
19382: PUSH
19383: LD_INT 2
19385: NEG
19386: PUSH
19387: EMPTY
19388: LIST
19389: LIST
19390: PUSH
19391: EMPTY
19392: LIST
19393: LIST
19394: LIST
19395: LIST
19396: LIST
19397: LIST
19398: LIST
19399: LIST
19400: LIST
19401: LIST
19402: LIST
19403: LIST
19404: LIST
19405: LIST
19406: LIST
19407: LIST
19408: LIST
19409: LIST
19410: LIST
19411: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
19412: LD_ADDR_VAR 0 18
19416: PUSH
19417: LD_INT 0
19419: PUSH
19420: LD_INT 0
19422: PUSH
19423: EMPTY
19424: LIST
19425: LIST
19426: PUSH
19427: LD_INT 0
19429: PUSH
19430: LD_INT 1
19432: NEG
19433: PUSH
19434: EMPTY
19435: LIST
19436: LIST
19437: PUSH
19438: LD_INT 1
19440: PUSH
19441: LD_INT 0
19443: PUSH
19444: EMPTY
19445: LIST
19446: LIST
19447: PUSH
19448: LD_INT 1
19450: PUSH
19451: LD_INT 1
19453: PUSH
19454: EMPTY
19455: LIST
19456: LIST
19457: PUSH
19458: LD_INT 0
19460: PUSH
19461: LD_INT 1
19463: PUSH
19464: EMPTY
19465: LIST
19466: LIST
19467: PUSH
19468: LD_INT 1
19470: NEG
19471: PUSH
19472: LD_INT 0
19474: PUSH
19475: EMPTY
19476: LIST
19477: LIST
19478: PUSH
19479: LD_INT 1
19481: NEG
19482: PUSH
19483: LD_INT 1
19485: NEG
19486: PUSH
19487: EMPTY
19488: LIST
19489: LIST
19490: PUSH
19491: LD_INT 1
19493: NEG
19494: PUSH
19495: LD_INT 2
19497: NEG
19498: PUSH
19499: EMPTY
19500: LIST
19501: LIST
19502: PUSH
19503: LD_INT 0
19505: PUSH
19506: LD_INT 2
19508: NEG
19509: PUSH
19510: EMPTY
19511: LIST
19512: LIST
19513: PUSH
19514: LD_INT 1
19516: PUSH
19517: LD_INT 1
19519: NEG
19520: PUSH
19521: EMPTY
19522: LIST
19523: LIST
19524: PUSH
19525: LD_INT 2
19527: PUSH
19528: LD_INT 0
19530: PUSH
19531: EMPTY
19532: LIST
19533: LIST
19534: PUSH
19535: LD_INT 2
19537: PUSH
19538: LD_INT 1
19540: PUSH
19541: EMPTY
19542: LIST
19543: LIST
19544: PUSH
19545: LD_INT 2
19547: PUSH
19548: LD_INT 2
19550: PUSH
19551: EMPTY
19552: LIST
19553: LIST
19554: PUSH
19555: LD_INT 1
19557: PUSH
19558: LD_INT 2
19560: PUSH
19561: EMPTY
19562: LIST
19563: LIST
19564: PUSH
19565: LD_INT 0
19567: PUSH
19568: LD_INT 2
19570: PUSH
19571: EMPTY
19572: LIST
19573: LIST
19574: PUSH
19575: LD_INT 1
19577: NEG
19578: PUSH
19579: LD_INT 1
19581: PUSH
19582: EMPTY
19583: LIST
19584: LIST
19585: PUSH
19586: LD_INT 2
19588: NEG
19589: PUSH
19590: LD_INT 0
19592: PUSH
19593: EMPTY
19594: LIST
19595: LIST
19596: PUSH
19597: LD_INT 2
19599: NEG
19600: PUSH
19601: LD_INT 1
19603: NEG
19604: PUSH
19605: EMPTY
19606: LIST
19607: LIST
19608: PUSH
19609: LD_INT 2
19611: NEG
19612: PUSH
19613: LD_INT 2
19615: NEG
19616: PUSH
19617: EMPTY
19618: LIST
19619: LIST
19620: PUSH
19621: EMPTY
19622: LIST
19623: LIST
19624: LIST
19625: LIST
19626: LIST
19627: LIST
19628: LIST
19629: LIST
19630: LIST
19631: LIST
19632: LIST
19633: LIST
19634: LIST
19635: LIST
19636: LIST
19637: LIST
19638: LIST
19639: LIST
19640: LIST
19641: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
19642: LD_ADDR_VAR 0 19
19646: PUSH
19647: LD_INT 0
19649: PUSH
19650: LD_INT 0
19652: PUSH
19653: EMPTY
19654: LIST
19655: LIST
19656: PUSH
19657: LD_INT 0
19659: PUSH
19660: LD_INT 1
19662: NEG
19663: PUSH
19664: EMPTY
19665: LIST
19666: LIST
19667: PUSH
19668: LD_INT 1
19670: PUSH
19671: LD_INT 0
19673: PUSH
19674: EMPTY
19675: LIST
19676: LIST
19677: PUSH
19678: LD_INT 1
19680: PUSH
19681: LD_INT 1
19683: PUSH
19684: EMPTY
19685: LIST
19686: LIST
19687: PUSH
19688: LD_INT 0
19690: PUSH
19691: LD_INT 1
19693: PUSH
19694: EMPTY
19695: LIST
19696: LIST
19697: PUSH
19698: LD_INT 1
19700: NEG
19701: PUSH
19702: LD_INT 0
19704: PUSH
19705: EMPTY
19706: LIST
19707: LIST
19708: PUSH
19709: LD_INT 1
19711: NEG
19712: PUSH
19713: LD_INT 1
19715: NEG
19716: PUSH
19717: EMPTY
19718: LIST
19719: LIST
19720: PUSH
19721: LD_INT 1
19723: NEG
19724: PUSH
19725: LD_INT 2
19727: NEG
19728: PUSH
19729: EMPTY
19730: LIST
19731: LIST
19732: PUSH
19733: LD_INT 0
19735: PUSH
19736: LD_INT 2
19738: NEG
19739: PUSH
19740: EMPTY
19741: LIST
19742: LIST
19743: PUSH
19744: LD_INT 1
19746: PUSH
19747: LD_INT 1
19749: NEG
19750: PUSH
19751: EMPTY
19752: LIST
19753: LIST
19754: PUSH
19755: LD_INT 2
19757: PUSH
19758: LD_INT 0
19760: PUSH
19761: EMPTY
19762: LIST
19763: LIST
19764: PUSH
19765: LD_INT 2
19767: PUSH
19768: LD_INT 1
19770: PUSH
19771: EMPTY
19772: LIST
19773: LIST
19774: PUSH
19775: LD_INT 2
19777: PUSH
19778: LD_INT 2
19780: PUSH
19781: EMPTY
19782: LIST
19783: LIST
19784: PUSH
19785: LD_INT 1
19787: PUSH
19788: LD_INT 2
19790: PUSH
19791: EMPTY
19792: LIST
19793: LIST
19794: PUSH
19795: LD_INT 0
19797: PUSH
19798: LD_INT 2
19800: PUSH
19801: EMPTY
19802: LIST
19803: LIST
19804: PUSH
19805: LD_INT 1
19807: NEG
19808: PUSH
19809: LD_INT 1
19811: PUSH
19812: EMPTY
19813: LIST
19814: LIST
19815: PUSH
19816: LD_INT 2
19818: NEG
19819: PUSH
19820: LD_INT 0
19822: PUSH
19823: EMPTY
19824: LIST
19825: LIST
19826: PUSH
19827: LD_INT 2
19829: NEG
19830: PUSH
19831: LD_INT 1
19833: NEG
19834: PUSH
19835: EMPTY
19836: LIST
19837: LIST
19838: PUSH
19839: LD_INT 2
19841: NEG
19842: PUSH
19843: LD_INT 2
19845: NEG
19846: PUSH
19847: EMPTY
19848: LIST
19849: LIST
19850: PUSH
19851: EMPTY
19852: LIST
19853: LIST
19854: LIST
19855: LIST
19856: LIST
19857: LIST
19858: LIST
19859: LIST
19860: LIST
19861: LIST
19862: LIST
19863: LIST
19864: LIST
19865: LIST
19866: LIST
19867: LIST
19868: LIST
19869: LIST
19870: LIST
19871: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
19872: LD_ADDR_VAR 0 20
19876: PUSH
19877: LD_INT 0
19879: PUSH
19880: LD_INT 0
19882: PUSH
19883: EMPTY
19884: LIST
19885: LIST
19886: PUSH
19887: LD_INT 0
19889: PUSH
19890: LD_INT 1
19892: NEG
19893: PUSH
19894: EMPTY
19895: LIST
19896: LIST
19897: PUSH
19898: LD_INT 1
19900: PUSH
19901: LD_INT 0
19903: PUSH
19904: EMPTY
19905: LIST
19906: LIST
19907: PUSH
19908: LD_INT 1
19910: PUSH
19911: LD_INT 1
19913: PUSH
19914: EMPTY
19915: LIST
19916: LIST
19917: PUSH
19918: LD_INT 0
19920: PUSH
19921: LD_INT 1
19923: PUSH
19924: EMPTY
19925: LIST
19926: LIST
19927: PUSH
19928: LD_INT 1
19930: NEG
19931: PUSH
19932: LD_INT 0
19934: PUSH
19935: EMPTY
19936: LIST
19937: LIST
19938: PUSH
19939: LD_INT 1
19941: NEG
19942: PUSH
19943: LD_INT 1
19945: NEG
19946: PUSH
19947: EMPTY
19948: LIST
19949: LIST
19950: PUSH
19951: LD_INT 1
19953: NEG
19954: PUSH
19955: LD_INT 2
19957: NEG
19958: PUSH
19959: EMPTY
19960: LIST
19961: LIST
19962: PUSH
19963: LD_INT 0
19965: PUSH
19966: LD_INT 2
19968: NEG
19969: PUSH
19970: EMPTY
19971: LIST
19972: LIST
19973: PUSH
19974: LD_INT 1
19976: PUSH
19977: LD_INT 1
19979: NEG
19980: PUSH
19981: EMPTY
19982: LIST
19983: LIST
19984: PUSH
19985: LD_INT 2
19987: PUSH
19988: LD_INT 0
19990: PUSH
19991: EMPTY
19992: LIST
19993: LIST
19994: PUSH
19995: LD_INT 2
19997: PUSH
19998: LD_INT 1
20000: PUSH
20001: EMPTY
20002: LIST
20003: LIST
20004: PUSH
20005: LD_INT 2
20007: PUSH
20008: LD_INT 2
20010: PUSH
20011: EMPTY
20012: LIST
20013: LIST
20014: PUSH
20015: LD_INT 1
20017: PUSH
20018: LD_INT 2
20020: PUSH
20021: EMPTY
20022: LIST
20023: LIST
20024: PUSH
20025: LD_INT 0
20027: PUSH
20028: LD_INT 2
20030: PUSH
20031: EMPTY
20032: LIST
20033: LIST
20034: PUSH
20035: LD_INT 1
20037: NEG
20038: PUSH
20039: LD_INT 1
20041: PUSH
20042: EMPTY
20043: LIST
20044: LIST
20045: PUSH
20046: LD_INT 2
20048: NEG
20049: PUSH
20050: LD_INT 0
20052: PUSH
20053: EMPTY
20054: LIST
20055: LIST
20056: PUSH
20057: LD_INT 2
20059: NEG
20060: PUSH
20061: LD_INT 1
20063: NEG
20064: PUSH
20065: EMPTY
20066: LIST
20067: LIST
20068: PUSH
20069: LD_INT 2
20071: NEG
20072: PUSH
20073: LD_INT 2
20075: NEG
20076: PUSH
20077: EMPTY
20078: LIST
20079: LIST
20080: PUSH
20081: EMPTY
20082: LIST
20083: LIST
20084: LIST
20085: LIST
20086: LIST
20087: LIST
20088: LIST
20089: LIST
20090: LIST
20091: LIST
20092: LIST
20093: LIST
20094: LIST
20095: LIST
20096: LIST
20097: LIST
20098: LIST
20099: LIST
20100: LIST
20101: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
20102: LD_ADDR_VAR 0 21
20106: PUSH
20107: LD_INT 0
20109: PUSH
20110: LD_INT 0
20112: PUSH
20113: EMPTY
20114: LIST
20115: LIST
20116: PUSH
20117: LD_INT 0
20119: PUSH
20120: LD_INT 1
20122: NEG
20123: PUSH
20124: EMPTY
20125: LIST
20126: LIST
20127: PUSH
20128: LD_INT 1
20130: PUSH
20131: LD_INT 0
20133: PUSH
20134: EMPTY
20135: LIST
20136: LIST
20137: PUSH
20138: LD_INT 1
20140: PUSH
20141: LD_INT 1
20143: PUSH
20144: EMPTY
20145: LIST
20146: LIST
20147: PUSH
20148: LD_INT 0
20150: PUSH
20151: LD_INT 1
20153: PUSH
20154: EMPTY
20155: LIST
20156: LIST
20157: PUSH
20158: LD_INT 1
20160: NEG
20161: PUSH
20162: LD_INT 0
20164: PUSH
20165: EMPTY
20166: LIST
20167: LIST
20168: PUSH
20169: LD_INT 1
20171: NEG
20172: PUSH
20173: LD_INT 1
20175: NEG
20176: PUSH
20177: EMPTY
20178: LIST
20179: LIST
20180: PUSH
20181: LD_INT 1
20183: NEG
20184: PUSH
20185: LD_INT 2
20187: NEG
20188: PUSH
20189: EMPTY
20190: LIST
20191: LIST
20192: PUSH
20193: LD_INT 0
20195: PUSH
20196: LD_INT 2
20198: NEG
20199: PUSH
20200: EMPTY
20201: LIST
20202: LIST
20203: PUSH
20204: LD_INT 1
20206: PUSH
20207: LD_INT 1
20209: NEG
20210: PUSH
20211: EMPTY
20212: LIST
20213: LIST
20214: PUSH
20215: LD_INT 2
20217: PUSH
20218: LD_INT 0
20220: PUSH
20221: EMPTY
20222: LIST
20223: LIST
20224: PUSH
20225: LD_INT 2
20227: PUSH
20228: LD_INT 1
20230: PUSH
20231: EMPTY
20232: LIST
20233: LIST
20234: PUSH
20235: LD_INT 2
20237: PUSH
20238: LD_INT 2
20240: PUSH
20241: EMPTY
20242: LIST
20243: LIST
20244: PUSH
20245: LD_INT 1
20247: PUSH
20248: LD_INT 2
20250: PUSH
20251: EMPTY
20252: LIST
20253: LIST
20254: PUSH
20255: LD_INT 0
20257: PUSH
20258: LD_INT 2
20260: PUSH
20261: EMPTY
20262: LIST
20263: LIST
20264: PUSH
20265: LD_INT 1
20267: NEG
20268: PUSH
20269: LD_INT 1
20271: PUSH
20272: EMPTY
20273: LIST
20274: LIST
20275: PUSH
20276: LD_INT 2
20278: NEG
20279: PUSH
20280: LD_INT 0
20282: PUSH
20283: EMPTY
20284: LIST
20285: LIST
20286: PUSH
20287: LD_INT 2
20289: NEG
20290: PUSH
20291: LD_INT 1
20293: NEG
20294: PUSH
20295: EMPTY
20296: LIST
20297: LIST
20298: PUSH
20299: LD_INT 2
20301: NEG
20302: PUSH
20303: LD_INT 2
20305: NEG
20306: PUSH
20307: EMPTY
20308: LIST
20309: LIST
20310: PUSH
20311: EMPTY
20312: LIST
20313: LIST
20314: LIST
20315: LIST
20316: LIST
20317: LIST
20318: LIST
20319: LIST
20320: LIST
20321: LIST
20322: LIST
20323: LIST
20324: LIST
20325: LIST
20326: LIST
20327: LIST
20328: LIST
20329: LIST
20330: LIST
20331: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
20332: LD_ADDR_VAR 0 22
20336: PUSH
20337: LD_INT 0
20339: PUSH
20340: LD_INT 0
20342: PUSH
20343: EMPTY
20344: LIST
20345: LIST
20346: PUSH
20347: LD_INT 0
20349: PUSH
20350: LD_INT 1
20352: NEG
20353: PUSH
20354: EMPTY
20355: LIST
20356: LIST
20357: PUSH
20358: LD_INT 1
20360: PUSH
20361: LD_INT 0
20363: PUSH
20364: EMPTY
20365: LIST
20366: LIST
20367: PUSH
20368: LD_INT 1
20370: PUSH
20371: LD_INT 1
20373: PUSH
20374: EMPTY
20375: LIST
20376: LIST
20377: PUSH
20378: LD_INT 0
20380: PUSH
20381: LD_INT 1
20383: PUSH
20384: EMPTY
20385: LIST
20386: LIST
20387: PUSH
20388: LD_INT 1
20390: NEG
20391: PUSH
20392: LD_INT 0
20394: PUSH
20395: EMPTY
20396: LIST
20397: LIST
20398: PUSH
20399: LD_INT 1
20401: NEG
20402: PUSH
20403: LD_INT 1
20405: NEG
20406: PUSH
20407: EMPTY
20408: LIST
20409: LIST
20410: PUSH
20411: LD_INT 1
20413: NEG
20414: PUSH
20415: LD_INT 2
20417: NEG
20418: PUSH
20419: EMPTY
20420: LIST
20421: LIST
20422: PUSH
20423: LD_INT 0
20425: PUSH
20426: LD_INT 2
20428: NEG
20429: PUSH
20430: EMPTY
20431: LIST
20432: LIST
20433: PUSH
20434: LD_INT 1
20436: PUSH
20437: LD_INT 1
20439: NEG
20440: PUSH
20441: EMPTY
20442: LIST
20443: LIST
20444: PUSH
20445: LD_INT 2
20447: PUSH
20448: LD_INT 0
20450: PUSH
20451: EMPTY
20452: LIST
20453: LIST
20454: PUSH
20455: LD_INT 2
20457: PUSH
20458: LD_INT 1
20460: PUSH
20461: EMPTY
20462: LIST
20463: LIST
20464: PUSH
20465: LD_INT 2
20467: PUSH
20468: LD_INT 2
20470: PUSH
20471: EMPTY
20472: LIST
20473: LIST
20474: PUSH
20475: LD_INT 1
20477: PUSH
20478: LD_INT 2
20480: PUSH
20481: EMPTY
20482: LIST
20483: LIST
20484: PUSH
20485: LD_INT 0
20487: PUSH
20488: LD_INT 2
20490: PUSH
20491: EMPTY
20492: LIST
20493: LIST
20494: PUSH
20495: LD_INT 1
20497: NEG
20498: PUSH
20499: LD_INT 1
20501: PUSH
20502: EMPTY
20503: LIST
20504: LIST
20505: PUSH
20506: LD_INT 2
20508: NEG
20509: PUSH
20510: LD_INT 0
20512: PUSH
20513: EMPTY
20514: LIST
20515: LIST
20516: PUSH
20517: LD_INT 2
20519: NEG
20520: PUSH
20521: LD_INT 1
20523: NEG
20524: PUSH
20525: EMPTY
20526: LIST
20527: LIST
20528: PUSH
20529: LD_INT 2
20531: NEG
20532: PUSH
20533: LD_INT 2
20535: NEG
20536: PUSH
20537: EMPTY
20538: LIST
20539: LIST
20540: PUSH
20541: EMPTY
20542: LIST
20543: LIST
20544: LIST
20545: LIST
20546: LIST
20547: LIST
20548: LIST
20549: LIST
20550: LIST
20551: LIST
20552: LIST
20553: LIST
20554: LIST
20555: LIST
20556: LIST
20557: LIST
20558: LIST
20559: LIST
20560: LIST
20561: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
20562: LD_ADDR_VAR 0 23
20566: PUSH
20567: LD_INT 0
20569: PUSH
20570: LD_INT 0
20572: PUSH
20573: EMPTY
20574: LIST
20575: LIST
20576: PUSH
20577: LD_INT 0
20579: PUSH
20580: LD_INT 1
20582: NEG
20583: PUSH
20584: EMPTY
20585: LIST
20586: LIST
20587: PUSH
20588: LD_INT 1
20590: PUSH
20591: LD_INT 0
20593: PUSH
20594: EMPTY
20595: LIST
20596: LIST
20597: PUSH
20598: LD_INT 1
20600: PUSH
20601: LD_INT 1
20603: PUSH
20604: EMPTY
20605: LIST
20606: LIST
20607: PUSH
20608: LD_INT 0
20610: PUSH
20611: LD_INT 1
20613: PUSH
20614: EMPTY
20615: LIST
20616: LIST
20617: PUSH
20618: LD_INT 1
20620: NEG
20621: PUSH
20622: LD_INT 0
20624: PUSH
20625: EMPTY
20626: LIST
20627: LIST
20628: PUSH
20629: LD_INT 1
20631: NEG
20632: PUSH
20633: LD_INT 1
20635: NEG
20636: PUSH
20637: EMPTY
20638: LIST
20639: LIST
20640: PUSH
20641: LD_INT 1
20643: NEG
20644: PUSH
20645: LD_INT 2
20647: NEG
20648: PUSH
20649: EMPTY
20650: LIST
20651: LIST
20652: PUSH
20653: LD_INT 0
20655: PUSH
20656: LD_INT 2
20658: NEG
20659: PUSH
20660: EMPTY
20661: LIST
20662: LIST
20663: PUSH
20664: LD_INT 1
20666: PUSH
20667: LD_INT 1
20669: NEG
20670: PUSH
20671: EMPTY
20672: LIST
20673: LIST
20674: PUSH
20675: LD_INT 2
20677: PUSH
20678: LD_INT 0
20680: PUSH
20681: EMPTY
20682: LIST
20683: LIST
20684: PUSH
20685: LD_INT 2
20687: PUSH
20688: LD_INT 1
20690: PUSH
20691: EMPTY
20692: LIST
20693: LIST
20694: PUSH
20695: LD_INT 2
20697: PUSH
20698: LD_INT 2
20700: PUSH
20701: EMPTY
20702: LIST
20703: LIST
20704: PUSH
20705: LD_INT 1
20707: PUSH
20708: LD_INT 2
20710: PUSH
20711: EMPTY
20712: LIST
20713: LIST
20714: PUSH
20715: LD_INT 0
20717: PUSH
20718: LD_INT 2
20720: PUSH
20721: EMPTY
20722: LIST
20723: LIST
20724: PUSH
20725: LD_INT 1
20727: NEG
20728: PUSH
20729: LD_INT 1
20731: PUSH
20732: EMPTY
20733: LIST
20734: LIST
20735: PUSH
20736: LD_INT 2
20738: NEG
20739: PUSH
20740: LD_INT 0
20742: PUSH
20743: EMPTY
20744: LIST
20745: LIST
20746: PUSH
20747: LD_INT 2
20749: NEG
20750: PUSH
20751: LD_INT 1
20753: NEG
20754: PUSH
20755: EMPTY
20756: LIST
20757: LIST
20758: PUSH
20759: LD_INT 2
20761: NEG
20762: PUSH
20763: LD_INT 2
20765: NEG
20766: PUSH
20767: EMPTY
20768: LIST
20769: LIST
20770: PUSH
20771: LD_INT 2
20773: NEG
20774: PUSH
20775: LD_INT 3
20777: NEG
20778: PUSH
20779: EMPTY
20780: LIST
20781: LIST
20782: PUSH
20783: LD_INT 1
20785: NEG
20786: PUSH
20787: LD_INT 3
20789: NEG
20790: PUSH
20791: EMPTY
20792: LIST
20793: LIST
20794: PUSH
20795: LD_INT 1
20797: PUSH
20798: LD_INT 2
20800: NEG
20801: PUSH
20802: EMPTY
20803: LIST
20804: LIST
20805: PUSH
20806: LD_INT 2
20808: PUSH
20809: LD_INT 1
20811: NEG
20812: PUSH
20813: EMPTY
20814: LIST
20815: LIST
20816: PUSH
20817: EMPTY
20818: LIST
20819: LIST
20820: LIST
20821: LIST
20822: LIST
20823: LIST
20824: LIST
20825: LIST
20826: LIST
20827: LIST
20828: LIST
20829: LIST
20830: LIST
20831: LIST
20832: LIST
20833: LIST
20834: LIST
20835: LIST
20836: LIST
20837: LIST
20838: LIST
20839: LIST
20840: LIST
20841: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
20842: LD_ADDR_VAR 0 24
20846: PUSH
20847: LD_INT 0
20849: PUSH
20850: LD_INT 0
20852: PUSH
20853: EMPTY
20854: LIST
20855: LIST
20856: PUSH
20857: LD_INT 0
20859: PUSH
20860: LD_INT 1
20862: NEG
20863: PUSH
20864: EMPTY
20865: LIST
20866: LIST
20867: PUSH
20868: LD_INT 1
20870: PUSH
20871: LD_INT 0
20873: PUSH
20874: EMPTY
20875: LIST
20876: LIST
20877: PUSH
20878: LD_INT 1
20880: PUSH
20881: LD_INT 1
20883: PUSH
20884: EMPTY
20885: LIST
20886: LIST
20887: PUSH
20888: LD_INT 0
20890: PUSH
20891: LD_INT 1
20893: PUSH
20894: EMPTY
20895: LIST
20896: LIST
20897: PUSH
20898: LD_INT 1
20900: NEG
20901: PUSH
20902: LD_INT 0
20904: PUSH
20905: EMPTY
20906: LIST
20907: LIST
20908: PUSH
20909: LD_INT 1
20911: NEG
20912: PUSH
20913: LD_INT 1
20915: NEG
20916: PUSH
20917: EMPTY
20918: LIST
20919: LIST
20920: PUSH
20921: LD_INT 1
20923: NEG
20924: PUSH
20925: LD_INT 2
20927: NEG
20928: PUSH
20929: EMPTY
20930: LIST
20931: LIST
20932: PUSH
20933: LD_INT 0
20935: PUSH
20936: LD_INT 2
20938: NEG
20939: PUSH
20940: EMPTY
20941: LIST
20942: LIST
20943: PUSH
20944: LD_INT 1
20946: PUSH
20947: LD_INT 1
20949: NEG
20950: PUSH
20951: EMPTY
20952: LIST
20953: LIST
20954: PUSH
20955: LD_INT 2
20957: PUSH
20958: LD_INT 0
20960: PUSH
20961: EMPTY
20962: LIST
20963: LIST
20964: PUSH
20965: LD_INT 2
20967: PUSH
20968: LD_INT 1
20970: PUSH
20971: EMPTY
20972: LIST
20973: LIST
20974: PUSH
20975: LD_INT 2
20977: PUSH
20978: LD_INT 2
20980: PUSH
20981: EMPTY
20982: LIST
20983: LIST
20984: PUSH
20985: LD_INT 1
20987: PUSH
20988: LD_INT 2
20990: PUSH
20991: EMPTY
20992: LIST
20993: LIST
20994: PUSH
20995: LD_INT 0
20997: PUSH
20998: LD_INT 2
21000: PUSH
21001: EMPTY
21002: LIST
21003: LIST
21004: PUSH
21005: LD_INT 1
21007: NEG
21008: PUSH
21009: LD_INT 1
21011: PUSH
21012: EMPTY
21013: LIST
21014: LIST
21015: PUSH
21016: LD_INT 2
21018: NEG
21019: PUSH
21020: LD_INT 0
21022: PUSH
21023: EMPTY
21024: LIST
21025: LIST
21026: PUSH
21027: LD_INT 2
21029: NEG
21030: PUSH
21031: LD_INT 1
21033: NEG
21034: PUSH
21035: EMPTY
21036: LIST
21037: LIST
21038: PUSH
21039: LD_INT 2
21041: NEG
21042: PUSH
21043: LD_INT 2
21045: NEG
21046: PUSH
21047: EMPTY
21048: LIST
21049: LIST
21050: PUSH
21051: LD_INT 1
21053: PUSH
21054: LD_INT 2
21056: NEG
21057: PUSH
21058: EMPTY
21059: LIST
21060: LIST
21061: PUSH
21062: LD_INT 2
21064: PUSH
21065: LD_INT 1
21067: NEG
21068: PUSH
21069: EMPTY
21070: LIST
21071: LIST
21072: PUSH
21073: LD_INT 3
21075: PUSH
21076: LD_INT 1
21078: PUSH
21079: EMPTY
21080: LIST
21081: LIST
21082: PUSH
21083: LD_INT 3
21085: PUSH
21086: LD_INT 2
21088: PUSH
21089: EMPTY
21090: LIST
21091: LIST
21092: PUSH
21093: EMPTY
21094: LIST
21095: LIST
21096: LIST
21097: LIST
21098: LIST
21099: LIST
21100: LIST
21101: LIST
21102: LIST
21103: LIST
21104: LIST
21105: LIST
21106: LIST
21107: LIST
21108: LIST
21109: LIST
21110: LIST
21111: LIST
21112: LIST
21113: LIST
21114: LIST
21115: LIST
21116: LIST
21117: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
21118: LD_ADDR_VAR 0 25
21122: PUSH
21123: LD_INT 0
21125: PUSH
21126: LD_INT 0
21128: PUSH
21129: EMPTY
21130: LIST
21131: LIST
21132: PUSH
21133: LD_INT 0
21135: PUSH
21136: LD_INT 1
21138: NEG
21139: PUSH
21140: EMPTY
21141: LIST
21142: LIST
21143: PUSH
21144: LD_INT 1
21146: PUSH
21147: LD_INT 0
21149: PUSH
21150: EMPTY
21151: LIST
21152: LIST
21153: PUSH
21154: LD_INT 1
21156: PUSH
21157: LD_INT 1
21159: PUSH
21160: EMPTY
21161: LIST
21162: LIST
21163: PUSH
21164: LD_INT 0
21166: PUSH
21167: LD_INT 1
21169: PUSH
21170: EMPTY
21171: LIST
21172: LIST
21173: PUSH
21174: LD_INT 1
21176: NEG
21177: PUSH
21178: LD_INT 0
21180: PUSH
21181: EMPTY
21182: LIST
21183: LIST
21184: PUSH
21185: LD_INT 1
21187: NEG
21188: PUSH
21189: LD_INT 1
21191: NEG
21192: PUSH
21193: EMPTY
21194: LIST
21195: LIST
21196: PUSH
21197: LD_INT 1
21199: NEG
21200: PUSH
21201: LD_INT 2
21203: NEG
21204: PUSH
21205: EMPTY
21206: LIST
21207: LIST
21208: PUSH
21209: LD_INT 0
21211: PUSH
21212: LD_INT 2
21214: NEG
21215: PUSH
21216: EMPTY
21217: LIST
21218: LIST
21219: PUSH
21220: LD_INT 1
21222: PUSH
21223: LD_INT 1
21225: NEG
21226: PUSH
21227: EMPTY
21228: LIST
21229: LIST
21230: PUSH
21231: LD_INT 2
21233: PUSH
21234: LD_INT 0
21236: PUSH
21237: EMPTY
21238: LIST
21239: LIST
21240: PUSH
21241: LD_INT 2
21243: PUSH
21244: LD_INT 1
21246: PUSH
21247: EMPTY
21248: LIST
21249: LIST
21250: PUSH
21251: LD_INT 2
21253: PUSH
21254: LD_INT 2
21256: PUSH
21257: EMPTY
21258: LIST
21259: LIST
21260: PUSH
21261: LD_INT 1
21263: PUSH
21264: LD_INT 2
21266: PUSH
21267: EMPTY
21268: LIST
21269: LIST
21270: PUSH
21271: LD_INT 0
21273: PUSH
21274: LD_INT 2
21276: PUSH
21277: EMPTY
21278: LIST
21279: LIST
21280: PUSH
21281: LD_INT 1
21283: NEG
21284: PUSH
21285: LD_INT 1
21287: PUSH
21288: EMPTY
21289: LIST
21290: LIST
21291: PUSH
21292: LD_INT 2
21294: NEG
21295: PUSH
21296: LD_INT 0
21298: PUSH
21299: EMPTY
21300: LIST
21301: LIST
21302: PUSH
21303: LD_INT 2
21305: NEG
21306: PUSH
21307: LD_INT 1
21309: NEG
21310: PUSH
21311: EMPTY
21312: LIST
21313: LIST
21314: PUSH
21315: LD_INT 2
21317: NEG
21318: PUSH
21319: LD_INT 2
21321: NEG
21322: PUSH
21323: EMPTY
21324: LIST
21325: LIST
21326: PUSH
21327: LD_INT 3
21329: PUSH
21330: LD_INT 1
21332: PUSH
21333: EMPTY
21334: LIST
21335: LIST
21336: PUSH
21337: LD_INT 3
21339: PUSH
21340: LD_INT 2
21342: PUSH
21343: EMPTY
21344: LIST
21345: LIST
21346: PUSH
21347: LD_INT 2
21349: PUSH
21350: LD_INT 3
21352: PUSH
21353: EMPTY
21354: LIST
21355: LIST
21356: PUSH
21357: LD_INT 1
21359: PUSH
21360: LD_INT 3
21362: PUSH
21363: EMPTY
21364: LIST
21365: LIST
21366: PUSH
21367: EMPTY
21368: LIST
21369: LIST
21370: LIST
21371: LIST
21372: LIST
21373: LIST
21374: LIST
21375: LIST
21376: LIST
21377: LIST
21378: LIST
21379: LIST
21380: LIST
21381: LIST
21382: LIST
21383: LIST
21384: LIST
21385: LIST
21386: LIST
21387: LIST
21388: LIST
21389: LIST
21390: LIST
21391: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
21392: LD_ADDR_VAR 0 26
21396: PUSH
21397: LD_INT 0
21399: PUSH
21400: LD_INT 0
21402: PUSH
21403: EMPTY
21404: LIST
21405: LIST
21406: PUSH
21407: LD_INT 0
21409: PUSH
21410: LD_INT 1
21412: NEG
21413: PUSH
21414: EMPTY
21415: LIST
21416: LIST
21417: PUSH
21418: LD_INT 1
21420: PUSH
21421: LD_INT 0
21423: PUSH
21424: EMPTY
21425: LIST
21426: LIST
21427: PUSH
21428: LD_INT 1
21430: PUSH
21431: LD_INT 1
21433: PUSH
21434: EMPTY
21435: LIST
21436: LIST
21437: PUSH
21438: LD_INT 0
21440: PUSH
21441: LD_INT 1
21443: PUSH
21444: EMPTY
21445: LIST
21446: LIST
21447: PUSH
21448: LD_INT 1
21450: NEG
21451: PUSH
21452: LD_INT 0
21454: PUSH
21455: EMPTY
21456: LIST
21457: LIST
21458: PUSH
21459: LD_INT 1
21461: NEG
21462: PUSH
21463: LD_INT 1
21465: NEG
21466: PUSH
21467: EMPTY
21468: LIST
21469: LIST
21470: PUSH
21471: LD_INT 1
21473: NEG
21474: PUSH
21475: LD_INT 2
21477: NEG
21478: PUSH
21479: EMPTY
21480: LIST
21481: LIST
21482: PUSH
21483: LD_INT 0
21485: PUSH
21486: LD_INT 2
21488: NEG
21489: PUSH
21490: EMPTY
21491: LIST
21492: LIST
21493: PUSH
21494: LD_INT 1
21496: PUSH
21497: LD_INT 1
21499: NEG
21500: PUSH
21501: EMPTY
21502: LIST
21503: LIST
21504: PUSH
21505: LD_INT 2
21507: PUSH
21508: LD_INT 0
21510: PUSH
21511: EMPTY
21512: LIST
21513: LIST
21514: PUSH
21515: LD_INT 2
21517: PUSH
21518: LD_INT 1
21520: PUSH
21521: EMPTY
21522: LIST
21523: LIST
21524: PUSH
21525: LD_INT 2
21527: PUSH
21528: LD_INT 2
21530: PUSH
21531: EMPTY
21532: LIST
21533: LIST
21534: PUSH
21535: LD_INT 1
21537: PUSH
21538: LD_INT 2
21540: PUSH
21541: EMPTY
21542: LIST
21543: LIST
21544: PUSH
21545: LD_INT 0
21547: PUSH
21548: LD_INT 2
21550: PUSH
21551: EMPTY
21552: LIST
21553: LIST
21554: PUSH
21555: LD_INT 1
21557: NEG
21558: PUSH
21559: LD_INT 1
21561: PUSH
21562: EMPTY
21563: LIST
21564: LIST
21565: PUSH
21566: LD_INT 2
21568: NEG
21569: PUSH
21570: LD_INT 0
21572: PUSH
21573: EMPTY
21574: LIST
21575: LIST
21576: PUSH
21577: LD_INT 2
21579: NEG
21580: PUSH
21581: LD_INT 1
21583: NEG
21584: PUSH
21585: EMPTY
21586: LIST
21587: LIST
21588: PUSH
21589: LD_INT 2
21591: NEG
21592: PUSH
21593: LD_INT 2
21595: NEG
21596: PUSH
21597: EMPTY
21598: LIST
21599: LIST
21600: PUSH
21601: LD_INT 2
21603: PUSH
21604: LD_INT 3
21606: PUSH
21607: EMPTY
21608: LIST
21609: LIST
21610: PUSH
21611: LD_INT 1
21613: PUSH
21614: LD_INT 3
21616: PUSH
21617: EMPTY
21618: LIST
21619: LIST
21620: PUSH
21621: LD_INT 1
21623: NEG
21624: PUSH
21625: LD_INT 2
21627: PUSH
21628: EMPTY
21629: LIST
21630: LIST
21631: PUSH
21632: LD_INT 2
21634: NEG
21635: PUSH
21636: LD_INT 1
21638: PUSH
21639: EMPTY
21640: LIST
21641: LIST
21642: PUSH
21643: EMPTY
21644: LIST
21645: LIST
21646: LIST
21647: LIST
21648: LIST
21649: LIST
21650: LIST
21651: LIST
21652: LIST
21653: LIST
21654: LIST
21655: LIST
21656: LIST
21657: LIST
21658: LIST
21659: LIST
21660: LIST
21661: LIST
21662: LIST
21663: LIST
21664: LIST
21665: LIST
21666: LIST
21667: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
21668: LD_ADDR_VAR 0 27
21672: PUSH
21673: LD_INT 0
21675: PUSH
21676: LD_INT 0
21678: PUSH
21679: EMPTY
21680: LIST
21681: LIST
21682: PUSH
21683: LD_INT 0
21685: PUSH
21686: LD_INT 1
21688: NEG
21689: PUSH
21690: EMPTY
21691: LIST
21692: LIST
21693: PUSH
21694: LD_INT 1
21696: PUSH
21697: LD_INT 0
21699: PUSH
21700: EMPTY
21701: LIST
21702: LIST
21703: PUSH
21704: LD_INT 1
21706: PUSH
21707: LD_INT 1
21709: PUSH
21710: EMPTY
21711: LIST
21712: LIST
21713: PUSH
21714: LD_INT 0
21716: PUSH
21717: LD_INT 1
21719: PUSH
21720: EMPTY
21721: LIST
21722: LIST
21723: PUSH
21724: LD_INT 1
21726: NEG
21727: PUSH
21728: LD_INT 0
21730: PUSH
21731: EMPTY
21732: LIST
21733: LIST
21734: PUSH
21735: LD_INT 1
21737: NEG
21738: PUSH
21739: LD_INT 1
21741: NEG
21742: PUSH
21743: EMPTY
21744: LIST
21745: LIST
21746: PUSH
21747: LD_INT 1
21749: NEG
21750: PUSH
21751: LD_INT 2
21753: NEG
21754: PUSH
21755: EMPTY
21756: LIST
21757: LIST
21758: PUSH
21759: LD_INT 0
21761: PUSH
21762: LD_INT 2
21764: NEG
21765: PUSH
21766: EMPTY
21767: LIST
21768: LIST
21769: PUSH
21770: LD_INT 1
21772: PUSH
21773: LD_INT 1
21775: NEG
21776: PUSH
21777: EMPTY
21778: LIST
21779: LIST
21780: PUSH
21781: LD_INT 2
21783: PUSH
21784: LD_INT 0
21786: PUSH
21787: EMPTY
21788: LIST
21789: LIST
21790: PUSH
21791: LD_INT 2
21793: PUSH
21794: LD_INT 1
21796: PUSH
21797: EMPTY
21798: LIST
21799: LIST
21800: PUSH
21801: LD_INT 2
21803: PUSH
21804: LD_INT 2
21806: PUSH
21807: EMPTY
21808: LIST
21809: LIST
21810: PUSH
21811: LD_INT 1
21813: PUSH
21814: LD_INT 2
21816: PUSH
21817: EMPTY
21818: LIST
21819: LIST
21820: PUSH
21821: LD_INT 0
21823: PUSH
21824: LD_INT 2
21826: PUSH
21827: EMPTY
21828: LIST
21829: LIST
21830: PUSH
21831: LD_INT 1
21833: NEG
21834: PUSH
21835: LD_INT 1
21837: PUSH
21838: EMPTY
21839: LIST
21840: LIST
21841: PUSH
21842: LD_INT 2
21844: NEG
21845: PUSH
21846: LD_INT 0
21848: PUSH
21849: EMPTY
21850: LIST
21851: LIST
21852: PUSH
21853: LD_INT 2
21855: NEG
21856: PUSH
21857: LD_INT 1
21859: NEG
21860: PUSH
21861: EMPTY
21862: LIST
21863: LIST
21864: PUSH
21865: LD_INT 2
21867: NEG
21868: PUSH
21869: LD_INT 2
21871: NEG
21872: PUSH
21873: EMPTY
21874: LIST
21875: LIST
21876: PUSH
21877: LD_INT 1
21879: NEG
21880: PUSH
21881: LD_INT 2
21883: PUSH
21884: EMPTY
21885: LIST
21886: LIST
21887: PUSH
21888: LD_INT 2
21890: NEG
21891: PUSH
21892: LD_INT 1
21894: PUSH
21895: EMPTY
21896: LIST
21897: LIST
21898: PUSH
21899: LD_INT 3
21901: NEG
21902: PUSH
21903: LD_INT 1
21905: NEG
21906: PUSH
21907: EMPTY
21908: LIST
21909: LIST
21910: PUSH
21911: LD_INT 3
21913: NEG
21914: PUSH
21915: LD_INT 2
21917: NEG
21918: PUSH
21919: EMPTY
21920: LIST
21921: LIST
21922: PUSH
21923: EMPTY
21924: LIST
21925: LIST
21926: LIST
21927: LIST
21928: LIST
21929: LIST
21930: LIST
21931: LIST
21932: LIST
21933: LIST
21934: LIST
21935: LIST
21936: LIST
21937: LIST
21938: LIST
21939: LIST
21940: LIST
21941: LIST
21942: LIST
21943: LIST
21944: LIST
21945: LIST
21946: LIST
21947: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
21948: LD_ADDR_VAR 0 28
21952: PUSH
21953: LD_INT 0
21955: PUSH
21956: LD_INT 0
21958: PUSH
21959: EMPTY
21960: LIST
21961: LIST
21962: PUSH
21963: LD_INT 0
21965: PUSH
21966: LD_INT 1
21968: NEG
21969: PUSH
21970: EMPTY
21971: LIST
21972: LIST
21973: PUSH
21974: LD_INT 1
21976: PUSH
21977: LD_INT 0
21979: PUSH
21980: EMPTY
21981: LIST
21982: LIST
21983: PUSH
21984: LD_INT 1
21986: PUSH
21987: LD_INT 1
21989: PUSH
21990: EMPTY
21991: LIST
21992: LIST
21993: PUSH
21994: LD_INT 0
21996: PUSH
21997: LD_INT 1
21999: PUSH
22000: EMPTY
22001: LIST
22002: LIST
22003: PUSH
22004: LD_INT 1
22006: NEG
22007: PUSH
22008: LD_INT 0
22010: PUSH
22011: EMPTY
22012: LIST
22013: LIST
22014: PUSH
22015: LD_INT 1
22017: NEG
22018: PUSH
22019: LD_INT 1
22021: NEG
22022: PUSH
22023: EMPTY
22024: LIST
22025: LIST
22026: PUSH
22027: LD_INT 1
22029: NEG
22030: PUSH
22031: LD_INT 2
22033: NEG
22034: PUSH
22035: EMPTY
22036: LIST
22037: LIST
22038: PUSH
22039: LD_INT 0
22041: PUSH
22042: LD_INT 2
22044: NEG
22045: PUSH
22046: EMPTY
22047: LIST
22048: LIST
22049: PUSH
22050: LD_INT 1
22052: PUSH
22053: LD_INT 1
22055: NEG
22056: PUSH
22057: EMPTY
22058: LIST
22059: LIST
22060: PUSH
22061: LD_INT 2
22063: PUSH
22064: LD_INT 0
22066: PUSH
22067: EMPTY
22068: LIST
22069: LIST
22070: PUSH
22071: LD_INT 2
22073: PUSH
22074: LD_INT 1
22076: PUSH
22077: EMPTY
22078: LIST
22079: LIST
22080: PUSH
22081: LD_INT 2
22083: PUSH
22084: LD_INT 2
22086: PUSH
22087: EMPTY
22088: LIST
22089: LIST
22090: PUSH
22091: LD_INT 1
22093: PUSH
22094: LD_INT 2
22096: PUSH
22097: EMPTY
22098: LIST
22099: LIST
22100: PUSH
22101: LD_INT 0
22103: PUSH
22104: LD_INT 2
22106: PUSH
22107: EMPTY
22108: LIST
22109: LIST
22110: PUSH
22111: LD_INT 1
22113: NEG
22114: PUSH
22115: LD_INT 1
22117: PUSH
22118: EMPTY
22119: LIST
22120: LIST
22121: PUSH
22122: LD_INT 2
22124: NEG
22125: PUSH
22126: LD_INT 0
22128: PUSH
22129: EMPTY
22130: LIST
22131: LIST
22132: PUSH
22133: LD_INT 2
22135: NEG
22136: PUSH
22137: LD_INT 1
22139: NEG
22140: PUSH
22141: EMPTY
22142: LIST
22143: LIST
22144: PUSH
22145: LD_INT 2
22147: NEG
22148: PUSH
22149: LD_INT 2
22151: NEG
22152: PUSH
22153: EMPTY
22154: LIST
22155: LIST
22156: PUSH
22157: LD_INT 2
22159: NEG
22160: PUSH
22161: LD_INT 3
22163: NEG
22164: PUSH
22165: EMPTY
22166: LIST
22167: LIST
22168: PUSH
22169: LD_INT 1
22171: NEG
22172: PUSH
22173: LD_INT 3
22175: NEG
22176: PUSH
22177: EMPTY
22178: LIST
22179: LIST
22180: PUSH
22181: LD_INT 3
22183: NEG
22184: PUSH
22185: LD_INT 1
22187: NEG
22188: PUSH
22189: EMPTY
22190: LIST
22191: LIST
22192: PUSH
22193: LD_INT 3
22195: NEG
22196: PUSH
22197: LD_INT 2
22199: NEG
22200: PUSH
22201: EMPTY
22202: LIST
22203: LIST
22204: PUSH
22205: EMPTY
22206: LIST
22207: LIST
22208: LIST
22209: LIST
22210: LIST
22211: LIST
22212: LIST
22213: LIST
22214: LIST
22215: LIST
22216: LIST
22217: LIST
22218: LIST
22219: LIST
22220: LIST
22221: LIST
22222: LIST
22223: LIST
22224: LIST
22225: LIST
22226: LIST
22227: LIST
22228: LIST
22229: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
22230: LD_ADDR_VAR 0 29
22234: PUSH
22235: LD_INT 0
22237: PUSH
22238: LD_INT 0
22240: PUSH
22241: EMPTY
22242: LIST
22243: LIST
22244: PUSH
22245: LD_INT 0
22247: PUSH
22248: LD_INT 1
22250: NEG
22251: PUSH
22252: EMPTY
22253: LIST
22254: LIST
22255: PUSH
22256: LD_INT 1
22258: PUSH
22259: LD_INT 0
22261: PUSH
22262: EMPTY
22263: LIST
22264: LIST
22265: PUSH
22266: LD_INT 1
22268: PUSH
22269: LD_INT 1
22271: PUSH
22272: EMPTY
22273: LIST
22274: LIST
22275: PUSH
22276: LD_INT 0
22278: PUSH
22279: LD_INT 1
22281: PUSH
22282: EMPTY
22283: LIST
22284: LIST
22285: PUSH
22286: LD_INT 1
22288: NEG
22289: PUSH
22290: LD_INT 0
22292: PUSH
22293: EMPTY
22294: LIST
22295: LIST
22296: PUSH
22297: LD_INT 1
22299: NEG
22300: PUSH
22301: LD_INT 1
22303: NEG
22304: PUSH
22305: EMPTY
22306: LIST
22307: LIST
22308: PUSH
22309: LD_INT 1
22311: NEG
22312: PUSH
22313: LD_INT 2
22315: NEG
22316: PUSH
22317: EMPTY
22318: LIST
22319: LIST
22320: PUSH
22321: LD_INT 0
22323: PUSH
22324: LD_INT 2
22326: NEG
22327: PUSH
22328: EMPTY
22329: LIST
22330: LIST
22331: PUSH
22332: LD_INT 1
22334: PUSH
22335: LD_INT 1
22337: NEG
22338: PUSH
22339: EMPTY
22340: LIST
22341: LIST
22342: PUSH
22343: LD_INT 2
22345: PUSH
22346: LD_INT 0
22348: PUSH
22349: EMPTY
22350: LIST
22351: LIST
22352: PUSH
22353: LD_INT 2
22355: PUSH
22356: LD_INT 1
22358: PUSH
22359: EMPTY
22360: LIST
22361: LIST
22362: PUSH
22363: LD_INT 1
22365: PUSH
22366: LD_INT 2
22368: PUSH
22369: EMPTY
22370: LIST
22371: LIST
22372: PUSH
22373: LD_INT 0
22375: PUSH
22376: LD_INT 2
22378: PUSH
22379: EMPTY
22380: LIST
22381: LIST
22382: PUSH
22383: LD_INT 1
22385: NEG
22386: PUSH
22387: LD_INT 1
22389: PUSH
22390: EMPTY
22391: LIST
22392: LIST
22393: PUSH
22394: LD_INT 2
22396: NEG
22397: PUSH
22398: LD_INT 1
22400: NEG
22401: PUSH
22402: EMPTY
22403: LIST
22404: LIST
22405: PUSH
22406: LD_INT 2
22408: NEG
22409: PUSH
22410: LD_INT 2
22412: NEG
22413: PUSH
22414: EMPTY
22415: LIST
22416: LIST
22417: PUSH
22418: LD_INT 2
22420: NEG
22421: PUSH
22422: LD_INT 3
22424: NEG
22425: PUSH
22426: EMPTY
22427: LIST
22428: LIST
22429: PUSH
22430: LD_INT 2
22432: PUSH
22433: LD_INT 1
22435: NEG
22436: PUSH
22437: EMPTY
22438: LIST
22439: LIST
22440: PUSH
22441: LD_INT 3
22443: PUSH
22444: LD_INT 1
22446: PUSH
22447: EMPTY
22448: LIST
22449: LIST
22450: PUSH
22451: LD_INT 1
22453: PUSH
22454: LD_INT 3
22456: PUSH
22457: EMPTY
22458: LIST
22459: LIST
22460: PUSH
22461: LD_INT 1
22463: NEG
22464: PUSH
22465: LD_INT 2
22467: PUSH
22468: EMPTY
22469: LIST
22470: LIST
22471: PUSH
22472: LD_INT 3
22474: NEG
22475: PUSH
22476: LD_INT 2
22478: NEG
22479: PUSH
22480: EMPTY
22481: LIST
22482: LIST
22483: PUSH
22484: EMPTY
22485: LIST
22486: LIST
22487: LIST
22488: LIST
22489: LIST
22490: LIST
22491: LIST
22492: LIST
22493: LIST
22494: LIST
22495: LIST
22496: LIST
22497: LIST
22498: LIST
22499: LIST
22500: LIST
22501: LIST
22502: LIST
22503: LIST
22504: LIST
22505: LIST
22506: LIST
22507: LIST
22508: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
22509: LD_ADDR_VAR 0 30
22513: PUSH
22514: LD_INT 0
22516: PUSH
22517: LD_INT 0
22519: PUSH
22520: EMPTY
22521: LIST
22522: LIST
22523: PUSH
22524: LD_INT 0
22526: PUSH
22527: LD_INT 1
22529: NEG
22530: PUSH
22531: EMPTY
22532: LIST
22533: LIST
22534: PUSH
22535: LD_INT 1
22537: PUSH
22538: LD_INT 0
22540: PUSH
22541: EMPTY
22542: LIST
22543: LIST
22544: PUSH
22545: LD_INT 1
22547: PUSH
22548: LD_INT 1
22550: PUSH
22551: EMPTY
22552: LIST
22553: LIST
22554: PUSH
22555: LD_INT 0
22557: PUSH
22558: LD_INT 1
22560: PUSH
22561: EMPTY
22562: LIST
22563: LIST
22564: PUSH
22565: LD_INT 1
22567: NEG
22568: PUSH
22569: LD_INT 0
22571: PUSH
22572: EMPTY
22573: LIST
22574: LIST
22575: PUSH
22576: LD_INT 1
22578: NEG
22579: PUSH
22580: LD_INT 1
22582: NEG
22583: PUSH
22584: EMPTY
22585: LIST
22586: LIST
22587: PUSH
22588: LD_INT 1
22590: NEG
22591: PUSH
22592: LD_INT 2
22594: NEG
22595: PUSH
22596: EMPTY
22597: LIST
22598: LIST
22599: PUSH
22600: LD_INT 0
22602: PUSH
22603: LD_INT 2
22605: NEG
22606: PUSH
22607: EMPTY
22608: LIST
22609: LIST
22610: PUSH
22611: LD_INT 1
22613: PUSH
22614: LD_INT 1
22616: NEG
22617: PUSH
22618: EMPTY
22619: LIST
22620: LIST
22621: PUSH
22622: LD_INT 2
22624: PUSH
22625: LD_INT 0
22627: PUSH
22628: EMPTY
22629: LIST
22630: LIST
22631: PUSH
22632: LD_INT 2
22634: PUSH
22635: LD_INT 1
22637: PUSH
22638: EMPTY
22639: LIST
22640: LIST
22641: PUSH
22642: LD_INT 2
22644: PUSH
22645: LD_INT 2
22647: PUSH
22648: EMPTY
22649: LIST
22650: LIST
22651: PUSH
22652: LD_INT 1
22654: PUSH
22655: LD_INT 2
22657: PUSH
22658: EMPTY
22659: LIST
22660: LIST
22661: PUSH
22662: LD_INT 1
22664: NEG
22665: PUSH
22666: LD_INT 1
22668: PUSH
22669: EMPTY
22670: LIST
22671: LIST
22672: PUSH
22673: LD_INT 2
22675: NEG
22676: PUSH
22677: LD_INT 0
22679: PUSH
22680: EMPTY
22681: LIST
22682: LIST
22683: PUSH
22684: LD_INT 2
22686: NEG
22687: PUSH
22688: LD_INT 1
22690: NEG
22691: PUSH
22692: EMPTY
22693: LIST
22694: LIST
22695: PUSH
22696: LD_INT 1
22698: NEG
22699: PUSH
22700: LD_INT 3
22702: NEG
22703: PUSH
22704: EMPTY
22705: LIST
22706: LIST
22707: PUSH
22708: LD_INT 1
22710: PUSH
22711: LD_INT 2
22713: NEG
22714: PUSH
22715: EMPTY
22716: LIST
22717: LIST
22718: PUSH
22719: LD_INT 3
22721: PUSH
22722: LD_INT 2
22724: PUSH
22725: EMPTY
22726: LIST
22727: LIST
22728: PUSH
22729: LD_INT 2
22731: PUSH
22732: LD_INT 3
22734: PUSH
22735: EMPTY
22736: LIST
22737: LIST
22738: PUSH
22739: LD_INT 2
22741: NEG
22742: PUSH
22743: LD_INT 1
22745: PUSH
22746: EMPTY
22747: LIST
22748: LIST
22749: PUSH
22750: LD_INT 3
22752: NEG
22753: PUSH
22754: LD_INT 1
22756: NEG
22757: PUSH
22758: EMPTY
22759: LIST
22760: LIST
22761: PUSH
22762: EMPTY
22763: LIST
22764: LIST
22765: LIST
22766: LIST
22767: LIST
22768: LIST
22769: LIST
22770: LIST
22771: LIST
22772: LIST
22773: LIST
22774: LIST
22775: LIST
22776: LIST
22777: LIST
22778: LIST
22779: LIST
22780: LIST
22781: LIST
22782: LIST
22783: LIST
22784: LIST
22785: LIST
22786: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
22787: LD_ADDR_VAR 0 31
22791: PUSH
22792: LD_INT 0
22794: PUSH
22795: LD_INT 0
22797: PUSH
22798: EMPTY
22799: LIST
22800: LIST
22801: PUSH
22802: LD_INT 0
22804: PUSH
22805: LD_INT 1
22807: NEG
22808: PUSH
22809: EMPTY
22810: LIST
22811: LIST
22812: PUSH
22813: LD_INT 1
22815: PUSH
22816: LD_INT 0
22818: PUSH
22819: EMPTY
22820: LIST
22821: LIST
22822: PUSH
22823: LD_INT 1
22825: PUSH
22826: LD_INT 1
22828: PUSH
22829: EMPTY
22830: LIST
22831: LIST
22832: PUSH
22833: LD_INT 0
22835: PUSH
22836: LD_INT 1
22838: PUSH
22839: EMPTY
22840: LIST
22841: LIST
22842: PUSH
22843: LD_INT 1
22845: NEG
22846: PUSH
22847: LD_INT 0
22849: PUSH
22850: EMPTY
22851: LIST
22852: LIST
22853: PUSH
22854: LD_INT 1
22856: NEG
22857: PUSH
22858: LD_INT 1
22860: NEG
22861: PUSH
22862: EMPTY
22863: LIST
22864: LIST
22865: PUSH
22866: LD_INT 1
22868: NEG
22869: PUSH
22870: LD_INT 2
22872: NEG
22873: PUSH
22874: EMPTY
22875: LIST
22876: LIST
22877: PUSH
22878: LD_INT 1
22880: PUSH
22881: LD_INT 1
22883: NEG
22884: PUSH
22885: EMPTY
22886: LIST
22887: LIST
22888: PUSH
22889: LD_INT 2
22891: PUSH
22892: LD_INT 0
22894: PUSH
22895: EMPTY
22896: LIST
22897: LIST
22898: PUSH
22899: LD_INT 2
22901: PUSH
22902: LD_INT 1
22904: PUSH
22905: EMPTY
22906: LIST
22907: LIST
22908: PUSH
22909: LD_INT 2
22911: PUSH
22912: LD_INT 2
22914: PUSH
22915: EMPTY
22916: LIST
22917: LIST
22918: PUSH
22919: LD_INT 1
22921: PUSH
22922: LD_INT 2
22924: PUSH
22925: EMPTY
22926: LIST
22927: LIST
22928: PUSH
22929: LD_INT 0
22931: PUSH
22932: LD_INT 2
22934: PUSH
22935: EMPTY
22936: LIST
22937: LIST
22938: PUSH
22939: LD_INT 1
22941: NEG
22942: PUSH
22943: LD_INT 1
22945: PUSH
22946: EMPTY
22947: LIST
22948: LIST
22949: PUSH
22950: LD_INT 2
22952: NEG
22953: PUSH
22954: LD_INT 1
22956: NEG
22957: PUSH
22958: EMPTY
22959: LIST
22960: LIST
22961: PUSH
22962: LD_INT 2
22964: NEG
22965: PUSH
22966: LD_INT 2
22968: NEG
22969: PUSH
22970: EMPTY
22971: LIST
22972: LIST
22973: PUSH
22974: LD_INT 2
22976: NEG
22977: PUSH
22978: LD_INT 3
22980: NEG
22981: PUSH
22982: EMPTY
22983: LIST
22984: LIST
22985: PUSH
22986: LD_INT 2
22988: PUSH
22989: LD_INT 1
22991: NEG
22992: PUSH
22993: EMPTY
22994: LIST
22995: LIST
22996: PUSH
22997: LD_INT 3
22999: PUSH
23000: LD_INT 1
23002: PUSH
23003: EMPTY
23004: LIST
23005: LIST
23006: PUSH
23007: LD_INT 1
23009: PUSH
23010: LD_INT 3
23012: PUSH
23013: EMPTY
23014: LIST
23015: LIST
23016: PUSH
23017: LD_INT 1
23019: NEG
23020: PUSH
23021: LD_INT 2
23023: PUSH
23024: EMPTY
23025: LIST
23026: LIST
23027: PUSH
23028: LD_INT 3
23030: NEG
23031: PUSH
23032: LD_INT 2
23034: NEG
23035: PUSH
23036: EMPTY
23037: LIST
23038: LIST
23039: PUSH
23040: EMPTY
23041: LIST
23042: LIST
23043: LIST
23044: LIST
23045: LIST
23046: LIST
23047: LIST
23048: LIST
23049: LIST
23050: LIST
23051: LIST
23052: LIST
23053: LIST
23054: LIST
23055: LIST
23056: LIST
23057: LIST
23058: LIST
23059: LIST
23060: LIST
23061: LIST
23062: LIST
23063: LIST
23064: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
23065: LD_ADDR_VAR 0 32
23069: PUSH
23070: LD_INT 0
23072: PUSH
23073: LD_INT 0
23075: PUSH
23076: EMPTY
23077: LIST
23078: LIST
23079: PUSH
23080: LD_INT 0
23082: PUSH
23083: LD_INT 1
23085: NEG
23086: PUSH
23087: EMPTY
23088: LIST
23089: LIST
23090: PUSH
23091: LD_INT 1
23093: PUSH
23094: LD_INT 0
23096: PUSH
23097: EMPTY
23098: LIST
23099: LIST
23100: PUSH
23101: LD_INT 1
23103: PUSH
23104: LD_INT 1
23106: PUSH
23107: EMPTY
23108: LIST
23109: LIST
23110: PUSH
23111: LD_INT 0
23113: PUSH
23114: LD_INT 1
23116: PUSH
23117: EMPTY
23118: LIST
23119: LIST
23120: PUSH
23121: LD_INT 1
23123: NEG
23124: PUSH
23125: LD_INT 0
23127: PUSH
23128: EMPTY
23129: LIST
23130: LIST
23131: PUSH
23132: LD_INT 1
23134: NEG
23135: PUSH
23136: LD_INT 1
23138: NEG
23139: PUSH
23140: EMPTY
23141: LIST
23142: LIST
23143: PUSH
23144: LD_INT 1
23146: NEG
23147: PUSH
23148: LD_INT 2
23150: NEG
23151: PUSH
23152: EMPTY
23153: LIST
23154: LIST
23155: PUSH
23156: LD_INT 0
23158: PUSH
23159: LD_INT 2
23161: NEG
23162: PUSH
23163: EMPTY
23164: LIST
23165: LIST
23166: PUSH
23167: LD_INT 1
23169: PUSH
23170: LD_INT 1
23172: NEG
23173: PUSH
23174: EMPTY
23175: LIST
23176: LIST
23177: PUSH
23178: LD_INT 2
23180: PUSH
23181: LD_INT 1
23183: PUSH
23184: EMPTY
23185: LIST
23186: LIST
23187: PUSH
23188: LD_INT 2
23190: PUSH
23191: LD_INT 2
23193: PUSH
23194: EMPTY
23195: LIST
23196: LIST
23197: PUSH
23198: LD_INT 1
23200: PUSH
23201: LD_INT 2
23203: PUSH
23204: EMPTY
23205: LIST
23206: LIST
23207: PUSH
23208: LD_INT 0
23210: PUSH
23211: LD_INT 2
23213: PUSH
23214: EMPTY
23215: LIST
23216: LIST
23217: PUSH
23218: LD_INT 1
23220: NEG
23221: PUSH
23222: LD_INT 1
23224: PUSH
23225: EMPTY
23226: LIST
23227: LIST
23228: PUSH
23229: LD_INT 2
23231: NEG
23232: PUSH
23233: LD_INT 0
23235: PUSH
23236: EMPTY
23237: LIST
23238: LIST
23239: PUSH
23240: LD_INT 2
23242: NEG
23243: PUSH
23244: LD_INT 1
23246: NEG
23247: PUSH
23248: EMPTY
23249: LIST
23250: LIST
23251: PUSH
23252: LD_INT 1
23254: NEG
23255: PUSH
23256: LD_INT 3
23258: NEG
23259: PUSH
23260: EMPTY
23261: LIST
23262: LIST
23263: PUSH
23264: LD_INT 1
23266: PUSH
23267: LD_INT 2
23269: NEG
23270: PUSH
23271: EMPTY
23272: LIST
23273: LIST
23274: PUSH
23275: LD_INT 3
23277: PUSH
23278: LD_INT 2
23280: PUSH
23281: EMPTY
23282: LIST
23283: LIST
23284: PUSH
23285: LD_INT 2
23287: PUSH
23288: LD_INT 3
23290: PUSH
23291: EMPTY
23292: LIST
23293: LIST
23294: PUSH
23295: LD_INT 2
23297: NEG
23298: PUSH
23299: LD_INT 1
23301: PUSH
23302: EMPTY
23303: LIST
23304: LIST
23305: PUSH
23306: LD_INT 3
23308: NEG
23309: PUSH
23310: LD_INT 1
23312: NEG
23313: PUSH
23314: EMPTY
23315: LIST
23316: LIST
23317: PUSH
23318: EMPTY
23319: LIST
23320: LIST
23321: LIST
23322: LIST
23323: LIST
23324: LIST
23325: LIST
23326: LIST
23327: LIST
23328: LIST
23329: LIST
23330: LIST
23331: LIST
23332: LIST
23333: LIST
23334: LIST
23335: LIST
23336: LIST
23337: LIST
23338: LIST
23339: LIST
23340: LIST
23341: LIST
23342: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
23343: LD_ADDR_VAR 0 33
23347: PUSH
23348: LD_INT 0
23350: PUSH
23351: LD_INT 0
23353: PUSH
23354: EMPTY
23355: LIST
23356: LIST
23357: PUSH
23358: LD_INT 0
23360: PUSH
23361: LD_INT 1
23363: NEG
23364: PUSH
23365: EMPTY
23366: LIST
23367: LIST
23368: PUSH
23369: LD_INT 1
23371: PUSH
23372: LD_INT 0
23374: PUSH
23375: EMPTY
23376: LIST
23377: LIST
23378: PUSH
23379: LD_INT 1
23381: PUSH
23382: LD_INT 1
23384: PUSH
23385: EMPTY
23386: LIST
23387: LIST
23388: PUSH
23389: LD_INT 0
23391: PUSH
23392: LD_INT 1
23394: PUSH
23395: EMPTY
23396: LIST
23397: LIST
23398: PUSH
23399: LD_INT 1
23401: NEG
23402: PUSH
23403: LD_INT 0
23405: PUSH
23406: EMPTY
23407: LIST
23408: LIST
23409: PUSH
23410: LD_INT 1
23412: NEG
23413: PUSH
23414: LD_INT 1
23416: NEG
23417: PUSH
23418: EMPTY
23419: LIST
23420: LIST
23421: PUSH
23422: LD_INT 1
23424: NEG
23425: PUSH
23426: LD_INT 2
23428: NEG
23429: PUSH
23430: EMPTY
23431: LIST
23432: LIST
23433: PUSH
23434: LD_INT 1
23436: PUSH
23437: LD_INT 1
23439: NEG
23440: PUSH
23441: EMPTY
23442: LIST
23443: LIST
23444: PUSH
23445: LD_INT 2
23447: PUSH
23448: LD_INT 0
23450: PUSH
23451: EMPTY
23452: LIST
23453: LIST
23454: PUSH
23455: LD_INT 2
23457: PUSH
23458: LD_INT 1
23460: PUSH
23461: EMPTY
23462: LIST
23463: LIST
23464: PUSH
23465: LD_INT 1
23467: PUSH
23468: LD_INT 2
23470: PUSH
23471: EMPTY
23472: LIST
23473: LIST
23474: PUSH
23475: LD_INT 0
23477: PUSH
23478: LD_INT 2
23480: PUSH
23481: EMPTY
23482: LIST
23483: LIST
23484: PUSH
23485: LD_INT 1
23487: NEG
23488: PUSH
23489: LD_INT 1
23491: PUSH
23492: EMPTY
23493: LIST
23494: LIST
23495: PUSH
23496: LD_INT 2
23498: NEG
23499: PUSH
23500: LD_INT 0
23502: PUSH
23503: EMPTY
23504: LIST
23505: LIST
23506: PUSH
23507: LD_INT 2
23509: NEG
23510: PUSH
23511: LD_INT 1
23513: NEG
23514: PUSH
23515: EMPTY
23516: LIST
23517: LIST
23518: PUSH
23519: LD_INT 2
23521: NEG
23522: PUSH
23523: LD_INT 2
23525: NEG
23526: PUSH
23527: EMPTY
23528: LIST
23529: LIST
23530: PUSH
23531: LD_INT 2
23533: NEG
23534: PUSH
23535: LD_INT 3
23537: NEG
23538: PUSH
23539: EMPTY
23540: LIST
23541: LIST
23542: PUSH
23543: LD_INT 2
23545: PUSH
23546: LD_INT 1
23548: NEG
23549: PUSH
23550: EMPTY
23551: LIST
23552: LIST
23553: PUSH
23554: LD_INT 3
23556: PUSH
23557: LD_INT 1
23559: PUSH
23560: EMPTY
23561: LIST
23562: LIST
23563: PUSH
23564: LD_INT 1
23566: PUSH
23567: LD_INT 3
23569: PUSH
23570: EMPTY
23571: LIST
23572: LIST
23573: PUSH
23574: LD_INT 1
23576: NEG
23577: PUSH
23578: LD_INT 2
23580: PUSH
23581: EMPTY
23582: LIST
23583: LIST
23584: PUSH
23585: LD_INT 3
23587: NEG
23588: PUSH
23589: LD_INT 2
23591: NEG
23592: PUSH
23593: EMPTY
23594: LIST
23595: LIST
23596: PUSH
23597: EMPTY
23598: LIST
23599: LIST
23600: LIST
23601: LIST
23602: LIST
23603: LIST
23604: LIST
23605: LIST
23606: LIST
23607: LIST
23608: LIST
23609: LIST
23610: LIST
23611: LIST
23612: LIST
23613: LIST
23614: LIST
23615: LIST
23616: LIST
23617: LIST
23618: LIST
23619: LIST
23620: LIST
23621: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
23622: LD_ADDR_VAR 0 34
23626: PUSH
23627: LD_INT 0
23629: PUSH
23630: LD_INT 0
23632: PUSH
23633: EMPTY
23634: LIST
23635: LIST
23636: PUSH
23637: LD_INT 0
23639: PUSH
23640: LD_INT 1
23642: NEG
23643: PUSH
23644: EMPTY
23645: LIST
23646: LIST
23647: PUSH
23648: LD_INT 1
23650: PUSH
23651: LD_INT 0
23653: PUSH
23654: EMPTY
23655: LIST
23656: LIST
23657: PUSH
23658: LD_INT 1
23660: PUSH
23661: LD_INT 1
23663: PUSH
23664: EMPTY
23665: LIST
23666: LIST
23667: PUSH
23668: LD_INT 0
23670: PUSH
23671: LD_INT 1
23673: PUSH
23674: EMPTY
23675: LIST
23676: LIST
23677: PUSH
23678: LD_INT 1
23680: NEG
23681: PUSH
23682: LD_INT 0
23684: PUSH
23685: EMPTY
23686: LIST
23687: LIST
23688: PUSH
23689: LD_INT 1
23691: NEG
23692: PUSH
23693: LD_INT 1
23695: NEG
23696: PUSH
23697: EMPTY
23698: LIST
23699: LIST
23700: PUSH
23701: LD_INT 1
23703: NEG
23704: PUSH
23705: LD_INT 2
23707: NEG
23708: PUSH
23709: EMPTY
23710: LIST
23711: LIST
23712: PUSH
23713: LD_INT 0
23715: PUSH
23716: LD_INT 2
23718: NEG
23719: PUSH
23720: EMPTY
23721: LIST
23722: LIST
23723: PUSH
23724: LD_INT 1
23726: PUSH
23727: LD_INT 1
23729: NEG
23730: PUSH
23731: EMPTY
23732: LIST
23733: LIST
23734: PUSH
23735: LD_INT 2
23737: PUSH
23738: LD_INT 1
23740: PUSH
23741: EMPTY
23742: LIST
23743: LIST
23744: PUSH
23745: LD_INT 2
23747: PUSH
23748: LD_INT 2
23750: PUSH
23751: EMPTY
23752: LIST
23753: LIST
23754: PUSH
23755: LD_INT 1
23757: PUSH
23758: LD_INT 2
23760: PUSH
23761: EMPTY
23762: LIST
23763: LIST
23764: PUSH
23765: LD_INT 1
23767: NEG
23768: PUSH
23769: LD_INT 1
23771: PUSH
23772: EMPTY
23773: LIST
23774: LIST
23775: PUSH
23776: LD_INT 2
23778: NEG
23779: PUSH
23780: LD_INT 0
23782: PUSH
23783: EMPTY
23784: LIST
23785: LIST
23786: PUSH
23787: LD_INT 2
23789: NEG
23790: PUSH
23791: LD_INT 1
23793: NEG
23794: PUSH
23795: EMPTY
23796: LIST
23797: LIST
23798: PUSH
23799: LD_INT 2
23801: NEG
23802: PUSH
23803: LD_INT 2
23805: NEG
23806: PUSH
23807: EMPTY
23808: LIST
23809: LIST
23810: PUSH
23811: LD_INT 1
23813: NEG
23814: PUSH
23815: LD_INT 3
23817: NEG
23818: PUSH
23819: EMPTY
23820: LIST
23821: LIST
23822: PUSH
23823: LD_INT 1
23825: PUSH
23826: LD_INT 2
23828: NEG
23829: PUSH
23830: EMPTY
23831: LIST
23832: LIST
23833: PUSH
23834: LD_INT 3
23836: PUSH
23837: LD_INT 2
23839: PUSH
23840: EMPTY
23841: LIST
23842: LIST
23843: PUSH
23844: LD_INT 2
23846: PUSH
23847: LD_INT 3
23849: PUSH
23850: EMPTY
23851: LIST
23852: LIST
23853: PUSH
23854: LD_INT 2
23856: NEG
23857: PUSH
23858: LD_INT 1
23860: PUSH
23861: EMPTY
23862: LIST
23863: LIST
23864: PUSH
23865: LD_INT 3
23867: NEG
23868: PUSH
23869: LD_INT 1
23871: NEG
23872: PUSH
23873: EMPTY
23874: LIST
23875: LIST
23876: PUSH
23877: EMPTY
23878: LIST
23879: LIST
23880: LIST
23881: LIST
23882: LIST
23883: LIST
23884: LIST
23885: LIST
23886: LIST
23887: LIST
23888: LIST
23889: LIST
23890: LIST
23891: LIST
23892: LIST
23893: LIST
23894: LIST
23895: LIST
23896: LIST
23897: LIST
23898: LIST
23899: LIST
23900: LIST
23901: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
23902: LD_ADDR_VAR 0 35
23906: PUSH
23907: LD_INT 0
23909: PUSH
23910: LD_INT 0
23912: PUSH
23913: EMPTY
23914: LIST
23915: LIST
23916: PUSH
23917: LD_INT 0
23919: PUSH
23920: LD_INT 1
23922: NEG
23923: PUSH
23924: EMPTY
23925: LIST
23926: LIST
23927: PUSH
23928: LD_INT 1
23930: PUSH
23931: LD_INT 0
23933: PUSH
23934: EMPTY
23935: LIST
23936: LIST
23937: PUSH
23938: LD_INT 1
23940: PUSH
23941: LD_INT 1
23943: PUSH
23944: EMPTY
23945: LIST
23946: LIST
23947: PUSH
23948: LD_INT 0
23950: PUSH
23951: LD_INT 1
23953: PUSH
23954: EMPTY
23955: LIST
23956: LIST
23957: PUSH
23958: LD_INT 1
23960: NEG
23961: PUSH
23962: LD_INT 0
23964: PUSH
23965: EMPTY
23966: LIST
23967: LIST
23968: PUSH
23969: LD_INT 1
23971: NEG
23972: PUSH
23973: LD_INT 1
23975: NEG
23976: PUSH
23977: EMPTY
23978: LIST
23979: LIST
23980: PUSH
23981: LD_INT 2
23983: PUSH
23984: LD_INT 1
23986: PUSH
23987: EMPTY
23988: LIST
23989: LIST
23990: PUSH
23991: LD_INT 2
23993: NEG
23994: PUSH
23995: LD_INT 1
23997: NEG
23998: PUSH
23999: EMPTY
24000: LIST
24001: LIST
24002: PUSH
24003: EMPTY
24004: LIST
24005: LIST
24006: LIST
24007: LIST
24008: LIST
24009: LIST
24010: LIST
24011: LIST
24012: LIST
24013: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
24014: LD_ADDR_VAR 0 36
24018: PUSH
24019: LD_INT 0
24021: PUSH
24022: LD_INT 0
24024: PUSH
24025: EMPTY
24026: LIST
24027: LIST
24028: PUSH
24029: LD_INT 0
24031: PUSH
24032: LD_INT 1
24034: NEG
24035: PUSH
24036: EMPTY
24037: LIST
24038: LIST
24039: PUSH
24040: LD_INT 1
24042: PUSH
24043: LD_INT 0
24045: PUSH
24046: EMPTY
24047: LIST
24048: LIST
24049: PUSH
24050: LD_INT 1
24052: PUSH
24053: LD_INT 1
24055: PUSH
24056: EMPTY
24057: LIST
24058: LIST
24059: PUSH
24060: LD_INT 0
24062: PUSH
24063: LD_INT 1
24065: PUSH
24066: EMPTY
24067: LIST
24068: LIST
24069: PUSH
24070: LD_INT 1
24072: NEG
24073: PUSH
24074: LD_INT 0
24076: PUSH
24077: EMPTY
24078: LIST
24079: LIST
24080: PUSH
24081: LD_INT 1
24083: NEG
24084: PUSH
24085: LD_INT 1
24087: NEG
24088: PUSH
24089: EMPTY
24090: LIST
24091: LIST
24092: PUSH
24093: LD_INT 1
24095: NEG
24096: PUSH
24097: LD_INT 2
24099: NEG
24100: PUSH
24101: EMPTY
24102: LIST
24103: LIST
24104: PUSH
24105: LD_INT 1
24107: PUSH
24108: LD_INT 2
24110: PUSH
24111: EMPTY
24112: LIST
24113: LIST
24114: PUSH
24115: EMPTY
24116: LIST
24117: LIST
24118: LIST
24119: LIST
24120: LIST
24121: LIST
24122: LIST
24123: LIST
24124: LIST
24125: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
24126: LD_ADDR_VAR 0 37
24130: PUSH
24131: LD_INT 0
24133: PUSH
24134: LD_INT 0
24136: PUSH
24137: EMPTY
24138: LIST
24139: LIST
24140: PUSH
24141: LD_INT 0
24143: PUSH
24144: LD_INT 1
24146: NEG
24147: PUSH
24148: EMPTY
24149: LIST
24150: LIST
24151: PUSH
24152: LD_INT 1
24154: PUSH
24155: LD_INT 0
24157: PUSH
24158: EMPTY
24159: LIST
24160: LIST
24161: PUSH
24162: LD_INT 1
24164: PUSH
24165: LD_INT 1
24167: PUSH
24168: EMPTY
24169: LIST
24170: LIST
24171: PUSH
24172: LD_INT 0
24174: PUSH
24175: LD_INT 1
24177: PUSH
24178: EMPTY
24179: LIST
24180: LIST
24181: PUSH
24182: LD_INT 1
24184: NEG
24185: PUSH
24186: LD_INT 0
24188: PUSH
24189: EMPTY
24190: LIST
24191: LIST
24192: PUSH
24193: LD_INT 1
24195: NEG
24196: PUSH
24197: LD_INT 1
24199: NEG
24200: PUSH
24201: EMPTY
24202: LIST
24203: LIST
24204: PUSH
24205: LD_INT 1
24207: PUSH
24208: LD_INT 1
24210: NEG
24211: PUSH
24212: EMPTY
24213: LIST
24214: LIST
24215: PUSH
24216: LD_INT 1
24218: NEG
24219: PUSH
24220: LD_INT 1
24222: PUSH
24223: EMPTY
24224: LIST
24225: LIST
24226: PUSH
24227: EMPTY
24228: LIST
24229: LIST
24230: LIST
24231: LIST
24232: LIST
24233: LIST
24234: LIST
24235: LIST
24236: LIST
24237: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
24238: LD_ADDR_VAR 0 38
24242: PUSH
24243: LD_INT 0
24245: PUSH
24246: LD_INT 0
24248: PUSH
24249: EMPTY
24250: LIST
24251: LIST
24252: PUSH
24253: LD_INT 0
24255: PUSH
24256: LD_INT 1
24258: NEG
24259: PUSH
24260: EMPTY
24261: LIST
24262: LIST
24263: PUSH
24264: LD_INT 1
24266: PUSH
24267: LD_INT 0
24269: PUSH
24270: EMPTY
24271: LIST
24272: LIST
24273: PUSH
24274: LD_INT 1
24276: PUSH
24277: LD_INT 1
24279: PUSH
24280: EMPTY
24281: LIST
24282: LIST
24283: PUSH
24284: LD_INT 0
24286: PUSH
24287: LD_INT 1
24289: PUSH
24290: EMPTY
24291: LIST
24292: LIST
24293: PUSH
24294: LD_INT 1
24296: NEG
24297: PUSH
24298: LD_INT 0
24300: PUSH
24301: EMPTY
24302: LIST
24303: LIST
24304: PUSH
24305: LD_INT 1
24307: NEG
24308: PUSH
24309: LD_INT 1
24311: NEG
24312: PUSH
24313: EMPTY
24314: LIST
24315: LIST
24316: PUSH
24317: LD_INT 2
24319: PUSH
24320: LD_INT 1
24322: PUSH
24323: EMPTY
24324: LIST
24325: LIST
24326: PUSH
24327: LD_INT 2
24329: NEG
24330: PUSH
24331: LD_INT 1
24333: NEG
24334: PUSH
24335: EMPTY
24336: LIST
24337: LIST
24338: PUSH
24339: EMPTY
24340: LIST
24341: LIST
24342: LIST
24343: LIST
24344: LIST
24345: LIST
24346: LIST
24347: LIST
24348: LIST
24349: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
24350: LD_ADDR_VAR 0 39
24354: PUSH
24355: LD_INT 0
24357: PUSH
24358: LD_INT 0
24360: PUSH
24361: EMPTY
24362: LIST
24363: LIST
24364: PUSH
24365: LD_INT 0
24367: PUSH
24368: LD_INT 1
24370: NEG
24371: PUSH
24372: EMPTY
24373: LIST
24374: LIST
24375: PUSH
24376: LD_INT 1
24378: PUSH
24379: LD_INT 0
24381: PUSH
24382: EMPTY
24383: LIST
24384: LIST
24385: PUSH
24386: LD_INT 1
24388: PUSH
24389: LD_INT 1
24391: PUSH
24392: EMPTY
24393: LIST
24394: LIST
24395: PUSH
24396: LD_INT 0
24398: PUSH
24399: LD_INT 1
24401: PUSH
24402: EMPTY
24403: LIST
24404: LIST
24405: PUSH
24406: LD_INT 1
24408: NEG
24409: PUSH
24410: LD_INT 0
24412: PUSH
24413: EMPTY
24414: LIST
24415: LIST
24416: PUSH
24417: LD_INT 1
24419: NEG
24420: PUSH
24421: LD_INT 1
24423: NEG
24424: PUSH
24425: EMPTY
24426: LIST
24427: LIST
24428: PUSH
24429: LD_INT 1
24431: NEG
24432: PUSH
24433: LD_INT 2
24435: NEG
24436: PUSH
24437: EMPTY
24438: LIST
24439: LIST
24440: PUSH
24441: LD_INT 1
24443: PUSH
24444: LD_INT 2
24446: PUSH
24447: EMPTY
24448: LIST
24449: LIST
24450: PUSH
24451: EMPTY
24452: LIST
24453: LIST
24454: LIST
24455: LIST
24456: LIST
24457: LIST
24458: LIST
24459: LIST
24460: LIST
24461: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
24462: LD_ADDR_VAR 0 40
24466: PUSH
24467: LD_INT 0
24469: PUSH
24470: LD_INT 0
24472: PUSH
24473: EMPTY
24474: LIST
24475: LIST
24476: PUSH
24477: LD_INT 0
24479: PUSH
24480: LD_INT 1
24482: NEG
24483: PUSH
24484: EMPTY
24485: LIST
24486: LIST
24487: PUSH
24488: LD_INT 1
24490: PUSH
24491: LD_INT 0
24493: PUSH
24494: EMPTY
24495: LIST
24496: LIST
24497: PUSH
24498: LD_INT 1
24500: PUSH
24501: LD_INT 1
24503: PUSH
24504: EMPTY
24505: LIST
24506: LIST
24507: PUSH
24508: LD_INT 0
24510: PUSH
24511: LD_INT 1
24513: PUSH
24514: EMPTY
24515: LIST
24516: LIST
24517: PUSH
24518: LD_INT 1
24520: NEG
24521: PUSH
24522: LD_INT 0
24524: PUSH
24525: EMPTY
24526: LIST
24527: LIST
24528: PUSH
24529: LD_INT 1
24531: NEG
24532: PUSH
24533: LD_INT 1
24535: NEG
24536: PUSH
24537: EMPTY
24538: LIST
24539: LIST
24540: PUSH
24541: LD_INT 1
24543: PUSH
24544: LD_INT 1
24546: NEG
24547: PUSH
24548: EMPTY
24549: LIST
24550: LIST
24551: PUSH
24552: LD_INT 1
24554: NEG
24555: PUSH
24556: LD_INT 1
24558: PUSH
24559: EMPTY
24560: LIST
24561: LIST
24562: PUSH
24563: EMPTY
24564: LIST
24565: LIST
24566: LIST
24567: LIST
24568: LIST
24569: LIST
24570: LIST
24571: LIST
24572: LIST
24573: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
24574: LD_ADDR_VAR 0 41
24578: PUSH
24579: LD_INT 0
24581: PUSH
24582: LD_INT 0
24584: PUSH
24585: EMPTY
24586: LIST
24587: LIST
24588: PUSH
24589: LD_INT 0
24591: PUSH
24592: LD_INT 1
24594: NEG
24595: PUSH
24596: EMPTY
24597: LIST
24598: LIST
24599: PUSH
24600: LD_INT 1
24602: PUSH
24603: LD_INT 0
24605: PUSH
24606: EMPTY
24607: LIST
24608: LIST
24609: PUSH
24610: LD_INT 1
24612: PUSH
24613: LD_INT 1
24615: PUSH
24616: EMPTY
24617: LIST
24618: LIST
24619: PUSH
24620: LD_INT 0
24622: PUSH
24623: LD_INT 1
24625: PUSH
24626: EMPTY
24627: LIST
24628: LIST
24629: PUSH
24630: LD_INT 1
24632: NEG
24633: PUSH
24634: LD_INT 0
24636: PUSH
24637: EMPTY
24638: LIST
24639: LIST
24640: PUSH
24641: LD_INT 1
24643: NEG
24644: PUSH
24645: LD_INT 1
24647: NEG
24648: PUSH
24649: EMPTY
24650: LIST
24651: LIST
24652: PUSH
24653: LD_INT 1
24655: NEG
24656: PUSH
24657: LD_INT 2
24659: NEG
24660: PUSH
24661: EMPTY
24662: LIST
24663: LIST
24664: PUSH
24665: LD_INT 1
24667: PUSH
24668: LD_INT 1
24670: NEG
24671: PUSH
24672: EMPTY
24673: LIST
24674: LIST
24675: PUSH
24676: LD_INT 2
24678: PUSH
24679: LD_INT 0
24681: PUSH
24682: EMPTY
24683: LIST
24684: LIST
24685: PUSH
24686: LD_INT 2
24688: PUSH
24689: LD_INT 1
24691: PUSH
24692: EMPTY
24693: LIST
24694: LIST
24695: PUSH
24696: LD_INT 2
24698: PUSH
24699: LD_INT 2
24701: PUSH
24702: EMPTY
24703: LIST
24704: LIST
24705: PUSH
24706: LD_INT 1
24708: PUSH
24709: LD_INT 2
24711: PUSH
24712: EMPTY
24713: LIST
24714: LIST
24715: PUSH
24716: LD_INT 1
24718: NEG
24719: PUSH
24720: LD_INT 1
24722: PUSH
24723: EMPTY
24724: LIST
24725: LIST
24726: PUSH
24727: LD_INT 2
24729: NEG
24730: PUSH
24731: LD_INT 0
24733: PUSH
24734: EMPTY
24735: LIST
24736: LIST
24737: PUSH
24738: LD_INT 2
24740: NEG
24741: PUSH
24742: LD_INT 1
24744: NEG
24745: PUSH
24746: EMPTY
24747: LIST
24748: LIST
24749: PUSH
24750: LD_INT 2
24752: NEG
24753: PUSH
24754: LD_INT 2
24756: NEG
24757: PUSH
24758: EMPTY
24759: LIST
24760: LIST
24761: PUSH
24762: LD_INT 2
24764: NEG
24765: PUSH
24766: LD_INT 3
24768: NEG
24769: PUSH
24770: EMPTY
24771: LIST
24772: LIST
24773: PUSH
24774: LD_INT 2
24776: PUSH
24777: LD_INT 1
24779: NEG
24780: PUSH
24781: EMPTY
24782: LIST
24783: LIST
24784: PUSH
24785: LD_INT 3
24787: PUSH
24788: LD_INT 0
24790: PUSH
24791: EMPTY
24792: LIST
24793: LIST
24794: PUSH
24795: LD_INT 3
24797: PUSH
24798: LD_INT 1
24800: PUSH
24801: EMPTY
24802: LIST
24803: LIST
24804: PUSH
24805: LD_INT 3
24807: PUSH
24808: LD_INT 2
24810: PUSH
24811: EMPTY
24812: LIST
24813: LIST
24814: PUSH
24815: LD_INT 3
24817: PUSH
24818: LD_INT 3
24820: PUSH
24821: EMPTY
24822: LIST
24823: LIST
24824: PUSH
24825: LD_INT 2
24827: PUSH
24828: LD_INT 3
24830: PUSH
24831: EMPTY
24832: LIST
24833: LIST
24834: PUSH
24835: LD_INT 2
24837: NEG
24838: PUSH
24839: LD_INT 1
24841: PUSH
24842: EMPTY
24843: LIST
24844: LIST
24845: PUSH
24846: LD_INT 3
24848: NEG
24849: PUSH
24850: LD_INT 0
24852: PUSH
24853: EMPTY
24854: LIST
24855: LIST
24856: PUSH
24857: LD_INT 3
24859: NEG
24860: PUSH
24861: LD_INT 1
24863: NEG
24864: PUSH
24865: EMPTY
24866: LIST
24867: LIST
24868: PUSH
24869: LD_INT 3
24871: NEG
24872: PUSH
24873: LD_INT 2
24875: NEG
24876: PUSH
24877: EMPTY
24878: LIST
24879: LIST
24880: PUSH
24881: LD_INT 3
24883: NEG
24884: PUSH
24885: LD_INT 3
24887: NEG
24888: PUSH
24889: EMPTY
24890: LIST
24891: LIST
24892: PUSH
24893: EMPTY
24894: LIST
24895: LIST
24896: LIST
24897: LIST
24898: LIST
24899: LIST
24900: LIST
24901: LIST
24902: LIST
24903: LIST
24904: LIST
24905: LIST
24906: LIST
24907: LIST
24908: LIST
24909: LIST
24910: LIST
24911: LIST
24912: LIST
24913: LIST
24914: LIST
24915: LIST
24916: LIST
24917: LIST
24918: LIST
24919: LIST
24920: LIST
24921: LIST
24922: LIST
24923: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
24924: LD_ADDR_VAR 0 42
24928: PUSH
24929: LD_INT 0
24931: PUSH
24932: LD_INT 0
24934: PUSH
24935: EMPTY
24936: LIST
24937: LIST
24938: PUSH
24939: LD_INT 0
24941: PUSH
24942: LD_INT 1
24944: NEG
24945: PUSH
24946: EMPTY
24947: LIST
24948: LIST
24949: PUSH
24950: LD_INT 1
24952: PUSH
24953: LD_INT 0
24955: PUSH
24956: EMPTY
24957: LIST
24958: LIST
24959: PUSH
24960: LD_INT 1
24962: PUSH
24963: LD_INT 1
24965: PUSH
24966: EMPTY
24967: LIST
24968: LIST
24969: PUSH
24970: LD_INT 0
24972: PUSH
24973: LD_INT 1
24975: PUSH
24976: EMPTY
24977: LIST
24978: LIST
24979: PUSH
24980: LD_INT 1
24982: NEG
24983: PUSH
24984: LD_INT 0
24986: PUSH
24987: EMPTY
24988: LIST
24989: LIST
24990: PUSH
24991: LD_INT 1
24993: NEG
24994: PUSH
24995: LD_INT 1
24997: NEG
24998: PUSH
24999: EMPTY
25000: LIST
25001: LIST
25002: PUSH
25003: LD_INT 1
25005: NEG
25006: PUSH
25007: LD_INT 2
25009: NEG
25010: PUSH
25011: EMPTY
25012: LIST
25013: LIST
25014: PUSH
25015: LD_INT 0
25017: PUSH
25018: LD_INT 2
25020: NEG
25021: PUSH
25022: EMPTY
25023: LIST
25024: LIST
25025: PUSH
25026: LD_INT 1
25028: PUSH
25029: LD_INT 1
25031: NEG
25032: PUSH
25033: EMPTY
25034: LIST
25035: LIST
25036: PUSH
25037: LD_INT 2
25039: PUSH
25040: LD_INT 1
25042: PUSH
25043: EMPTY
25044: LIST
25045: LIST
25046: PUSH
25047: LD_INT 2
25049: PUSH
25050: LD_INT 2
25052: PUSH
25053: EMPTY
25054: LIST
25055: LIST
25056: PUSH
25057: LD_INT 1
25059: PUSH
25060: LD_INT 2
25062: PUSH
25063: EMPTY
25064: LIST
25065: LIST
25066: PUSH
25067: LD_INT 0
25069: PUSH
25070: LD_INT 2
25072: PUSH
25073: EMPTY
25074: LIST
25075: LIST
25076: PUSH
25077: LD_INT 1
25079: NEG
25080: PUSH
25081: LD_INT 1
25083: PUSH
25084: EMPTY
25085: LIST
25086: LIST
25087: PUSH
25088: LD_INT 2
25090: NEG
25091: PUSH
25092: LD_INT 1
25094: NEG
25095: PUSH
25096: EMPTY
25097: LIST
25098: LIST
25099: PUSH
25100: LD_INT 2
25102: NEG
25103: PUSH
25104: LD_INT 2
25106: NEG
25107: PUSH
25108: EMPTY
25109: LIST
25110: LIST
25111: PUSH
25112: LD_INT 2
25114: NEG
25115: PUSH
25116: LD_INT 3
25118: NEG
25119: PUSH
25120: EMPTY
25121: LIST
25122: LIST
25123: PUSH
25124: LD_INT 1
25126: NEG
25127: PUSH
25128: LD_INT 3
25130: NEG
25131: PUSH
25132: EMPTY
25133: LIST
25134: LIST
25135: PUSH
25136: LD_INT 0
25138: PUSH
25139: LD_INT 3
25141: NEG
25142: PUSH
25143: EMPTY
25144: LIST
25145: LIST
25146: PUSH
25147: LD_INT 1
25149: PUSH
25150: LD_INT 2
25152: NEG
25153: PUSH
25154: EMPTY
25155: LIST
25156: LIST
25157: PUSH
25158: LD_INT 3
25160: PUSH
25161: LD_INT 2
25163: PUSH
25164: EMPTY
25165: LIST
25166: LIST
25167: PUSH
25168: LD_INT 3
25170: PUSH
25171: LD_INT 3
25173: PUSH
25174: EMPTY
25175: LIST
25176: LIST
25177: PUSH
25178: LD_INT 2
25180: PUSH
25181: LD_INT 3
25183: PUSH
25184: EMPTY
25185: LIST
25186: LIST
25187: PUSH
25188: LD_INT 1
25190: PUSH
25191: LD_INT 3
25193: PUSH
25194: EMPTY
25195: LIST
25196: LIST
25197: PUSH
25198: LD_INT 0
25200: PUSH
25201: LD_INT 3
25203: PUSH
25204: EMPTY
25205: LIST
25206: LIST
25207: PUSH
25208: LD_INT 1
25210: NEG
25211: PUSH
25212: LD_INT 2
25214: PUSH
25215: EMPTY
25216: LIST
25217: LIST
25218: PUSH
25219: LD_INT 3
25221: NEG
25222: PUSH
25223: LD_INT 2
25225: NEG
25226: PUSH
25227: EMPTY
25228: LIST
25229: LIST
25230: PUSH
25231: LD_INT 3
25233: NEG
25234: PUSH
25235: LD_INT 3
25237: NEG
25238: PUSH
25239: EMPTY
25240: LIST
25241: LIST
25242: PUSH
25243: EMPTY
25244: LIST
25245: LIST
25246: LIST
25247: LIST
25248: LIST
25249: LIST
25250: LIST
25251: LIST
25252: LIST
25253: LIST
25254: LIST
25255: LIST
25256: LIST
25257: LIST
25258: LIST
25259: LIST
25260: LIST
25261: LIST
25262: LIST
25263: LIST
25264: LIST
25265: LIST
25266: LIST
25267: LIST
25268: LIST
25269: LIST
25270: LIST
25271: LIST
25272: LIST
25273: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
25274: LD_ADDR_VAR 0 43
25278: PUSH
25279: LD_INT 0
25281: PUSH
25282: LD_INT 0
25284: PUSH
25285: EMPTY
25286: LIST
25287: LIST
25288: PUSH
25289: LD_INT 0
25291: PUSH
25292: LD_INT 1
25294: NEG
25295: PUSH
25296: EMPTY
25297: LIST
25298: LIST
25299: PUSH
25300: LD_INT 1
25302: PUSH
25303: LD_INT 0
25305: PUSH
25306: EMPTY
25307: LIST
25308: LIST
25309: PUSH
25310: LD_INT 1
25312: PUSH
25313: LD_INT 1
25315: PUSH
25316: EMPTY
25317: LIST
25318: LIST
25319: PUSH
25320: LD_INT 0
25322: PUSH
25323: LD_INT 1
25325: PUSH
25326: EMPTY
25327: LIST
25328: LIST
25329: PUSH
25330: LD_INT 1
25332: NEG
25333: PUSH
25334: LD_INT 0
25336: PUSH
25337: EMPTY
25338: LIST
25339: LIST
25340: PUSH
25341: LD_INT 1
25343: NEG
25344: PUSH
25345: LD_INT 1
25347: NEG
25348: PUSH
25349: EMPTY
25350: LIST
25351: LIST
25352: PUSH
25353: LD_INT 1
25355: NEG
25356: PUSH
25357: LD_INT 2
25359: NEG
25360: PUSH
25361: EMPTY
25362: LIST
25363: LIST
25364: PUSH
25365: LD_INT 0
25367: PUSH
25368: LD_INT 2
25370: NEG
25371: PUSH
25372: EMPTY
25373: LIST
25374: LIST
25375: PUSH
25376: LD_INT 1
25378: PUSH
25379: LD_INT 1
25381: NEG
25382: PUSH
25383: EMPTY
25384: LIST
25385: LIST
25386: PUSH
25387: LD_INT 2
25389: PUSH
25390: LD_INT 0
25392: PUSH
25393: EMPTY
25394: LIST
25395: LIST
25396: PUSH
25397: LD_INT 2
25399: PUSH
25400: LD_INT 1
25402: PUSH
25403: EMPTY
25404: LIST
25405: LIST
25406: PUSH
25407: LD_INT 1
25409: PUSH
25410: LD_INT 2
25412: PUSH
25413: EMPTY
25414: LIST
25415: LIST
25416: PUSH
25417: LD_INT 0
25419: PUSH
25420: LD_INT 2
25422: PUSH
25423: EMPTY
25424: LIST
25425: LIST
25426: PUSH
25427: LD_INT 1
25429: NEG
25430: PUSH
25431: LD_INT 1
25433: PUSH
25434: EMPTY
25435: LIST
25436: LIST
25437: PUSH
25438: LD_INT 2
25440: NEG
25441: PUSH
25442: LD_INT 0
25444: PUSH
25445: EMPTY
25446: LIST
25447: LIST
25448: PUSH
25449: LD_INT 2
25451: NEG
25452: PUSH
25453: LD_INT 1
25455: NEG
25456: PUSH
25457: EMPTY
25458: LIST
25459: LIST
25460: PUSH
25461: LD_INT 1
25463: NEG
25464: PUSH
25465: LD_INT 3
25467: NEG
25468: PUSH
25469: EMPTY
25470: LIST
25471: LIST
25472: PUSH
25473: LD_INT 0
25475: PUSH
25476: LD_INT 3
25478: NEG
25479: PUSH
25480: EMPTY
25481: LIST
25482: LIST
25483: PUSH
25484: LD_INT 1
25486: PUSH
25487: LD_INT 2
25489: NEG
25490: PUSH
25491: EMPTY
25492: LIST
25493: LIST
25494: PUSH
25495: LD_INT 2
25497: PUSH
25498: LD_INT 1
25500: NEG
25501: PUSH
25502: EMPTY
25503: LIST
25504: LIST
25505: PUSH
25506: LD_INT 3
25508: PUSH
25509: LD_INT 0
25511: PUSH
25512: EMPTY
25513: LIST
25514: LIST
25515: PUSH
25516: LD_INT 3
25518: PUSH
25519: LD_INT 1
25521: PUSH
25522: EMPTY
25523: LIST
25524: LIST
25525: PUSH
25526: LD_INT 1
25528: PUSH
25529: LD_INT 3
25531: PUSH
25532: EMPTY
25533: LIST
25534: LIST
25535: PUSH
25536: LD_INT 0
25538: PUSH
25539: LD_INT 3
25541: PUSH
25542: EMPTY
25543: LIST
25544: LIST
25545: PUSH
25546: LD_INT 1
25548: NEG
25549: PUSH
25550: LD_INT 2
25552: PUSH
25553: EMPTY
25554: LIST
25555: LIST
25556: PUSH
25557: LD_INT 2
25559: NEG
25560: PUSH
25561: LD_INT 1
25563: PUSH
25564: EMPTY
25565: LIST
25566: LIST
25567: PUSH
25568: LD_INT 3
25570: NEG
25571: PUSH
25572: LD_INT 0
25574: PUSH
25575: EMPTY
25576: LIST
25577: LIST
25578: PUSH
25579: LD_INT 3
25581: NEG
25582: PUSH
25583: LD_INT 1
25585: NEG
25586: PUSH
25587: EMPTY
25588: LIST
25589: LIST
25590: PUSH
25591: EMPTY
25592: LIST
25593: LIST
25594: LIST
25595: LIST
25596: LIST
25597: LIST
25598: LIST
25599: LIST
25600: LIST
25601: LIST
25602: LIST
25603: LIST
25604: LIST
25605: LIST
25606: LIST
25607: LIST
25608: LIST
25609: LIST
25610: LIST
25611: LIST
25612: LIST
25613: LIST
25614: LIST
25615: LIST
25616: LIST
25617: LIST
25618: LIST
25619: LIST
25620: LIST
25621: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
25622: LD_ADDR_VAR 0 44
25626: PUSH
25627: LD_INT 0
25629: PUSH
25630: LD_INT 0
25632: PUSH
25633: EMPTY
25634: LIST
25635: LIST
25636: PUSH
25637: LD_INT 0
25639: PUSH
25640: LD_INT 1
25642: NEG
25643: PUSH
25644: EMPTY
25645: LIST
25646: LIST
25647: PUSH
25648: LD_INT 1
25650: PUSH
25651: LD_INT 0
25653: PUSH
25654: EMPTY
25655: LIST
25656: LIST
25657: PUSH
25658: LD_INT 1
25660: PUSH
25661: LD_INT 1
25663: PUSH
25664: EMPTY
25665: LIST
25666: LIST
25667: PUSH
25668: LD_INT 0
25670: PUSH
25671: LD_INT 1
25673: PUSH
25674: EMPTY
25675: LIST
25676: LIST
25677: PUSH
25678: LD_INT 1
25680: NEG
25681: PUSH
25682: LD_INT 0
25684: PUSH
25685: EMPTY
25686: LIST
25687: LIST
25688: PUSH
25689: LD_INT 1
25691: NEG
25692: PUSH
25693: LD_INT 1
25695: NEG
25696: PUSH
25697: EMPTY
25698: LIST
25699: LIST
25700: PUSH
25701: LD_INT 1
25703: NEG
25704: PUSH
25705: LD_INT 2
25707: NEG
25708: PUSH
25709: EMPTY
25710: LIST
25711: LIST
25712: PUSH
25713: LD_INT 1
25715: PUSH
25716: LD_INT 1
25718: NEG
25719: PUSH
25720: EMPTY
25721: LIST
25722: LIST
25723: PUSH
25724: LD_INT 2
25726: PUSH
25727: LD_INT 0
25729: PUSH
25730: EMPTY
25731: LIST
25732: LIST
25733: PUSH
25734: LD_INT 2
25736: PUSH
25737: LD_INT 1
25739: PUSH
25740: EMPTY
25741: LIST
25742: LIST
25743: PUSH
25744: LD_INT 2
25746: PUSH
25747: LD_INT 2
25749: PUSH
25750: EMPTY
25751: LIST
25752: LIST
25753: PUSH
25754: LD_INT 1
25756: PUSH
25757: LD_INT 2
25759: PUSH
25760: EMPTY
25761: LIST
25762: LIST
25763: PUSH
25764: LD_INT 1
25766: NEG
25767: PUSH
25768: LD_INT 1
25770: PUSH
25771: EMPTY
25772: LIST
25773: LIST
25774: PUSH
25775: LD_INT 2
25777: NEG
25778: PUSH
25779: LD_INT 0
25781: PUSH
25782: EMPTY
25783: LIST
25784: LIST
25785: PUSH
25786: LD_INT 2
25788: NEG
25789: PUSH
25790: LD_INT 1
25792: NEG
25793: PUSH
25794: EMPTY
25795: LIST
25796: LIST
25797: PUSH
25798: LD_INT 2
25800: NEG
25801: PUSH
25802: LD_INT 2
25804: NEG
25805: PUSH
25806: EMPTY
25807: LIST
25808: LIST
25809: PUSH
25810: LD_INT 2
25812: NEG
25813: PUSH
25814: LD_INT 3
25816: NEG
25817: PUSH
25818: EMPTY
25819: LIST
25820: LIST
25821: PUSH
25822: LD_INT 2
25824: PUSH
25825: LD_INT 1
25827: NEG
25828: PUSH
25829: EMPTY
25830: LIST
25831: LIST
25832: PUSH
25833: LD_INT 3
25835: PUSH
25836: LD_INT 0
25838: PUSH
25839: EMPTY
25840: LIST
25841: LIST
25842: PUSH
25843: LD_INT 3
25845: PUSH
25846: LD_INT 1
25848: PUSH
25849: EMPTY
25850: LIST
25851: LIST
25852: PUSH
25853: LD_INT 3
25855: PUSH
25856: LD_INT 2
25858: PUSH
25859: EMPTY
25860: LIST
25861: LIST
25862: PUSH
25863: LD_INT 3
25865: PUSH
25866: LD_INT 3
25868: PUSH
25869: EMPTY
25870: LIST
25871: LIST
25872: PUSH
25873: LD_INT 2
25875: PUSH
25876: LD_INT 3
25878: PUSH
25879: EMPTY
25880: LIST
25881: LIST
25882: PUSH
25883: LD_INT 2
25885: NEG
25886: PUSH
25887: LD_INT 1
25889: PUSH
25890: EMPTY
25891: LIST
25892: LIST
25893: PUSH
25894: LD_INT 3
25896: NEG
25897: PUSH
25898: LD_INT 0
25900: PUSH
25901: EMPTY
25902: LIST
25903: LIST
25904: PUSH
25905: LD_INT 3
25907: NEG
25908: PUSH
25909: LD_INT 1
25911: NEG
25912: PUSH
25913: EMPTY
25914: LIST
25915: LIST
25916: PUSH
25917: LD_INT 3
25919: NEG
25920: PUSH
25921: LD_INT 2
25923: NEG
25924: PUSH
25925: EMPTY
25926: LIST
25927: LIST
25928: PUSH
25929: LD_INT 3
25931: NEG
25932: PUSH
25933: LD_INT 3
25935: NEG
25936: PUSH
25937: EMPTY
25938: LIST
25939: LIST
25940: PUSH
25941: EMPTY
25942: LIST
25943: LIST
25944: LIST
25945: LIST
25946: LIST
25947: LIST
25948: LIST
25949: LIST
25950: LIST
25951: LIST
25952: LIST
25953: LIST
25954: LIST
25955: LIST
25956: LIST
25957: LIST
25958: LIST
25959: LIST
25960: LIST
25961: LIST
25962: LIST
25963: LIST
25964: LIST
25965: LIST
25966: LIST
25967: LIST
25968: LIST
25969: LIST
25970: LIST
25971: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
25972: LD_ADDR_VAR 0 45
25976: PUSH
25977: LD_INT 0
25979: PUSH
25980: LD_INT 0
25982: PUSH
25983: EMPTY
25984: LIST
25985: LIST
25986: PUSH
25987: LD_INT 0
25989: PUSH
25990: LD_INT 1
25992: NEG
25993: PUSH
25994: EMPTY
25995: LIST
25996: LIST
25997: PUSH
25998: LD_INT 1
26000: PUSH
26001: LD_INT 0
26003: PUSH
26004: EMPTY
26005: LIST
26006: LIST
26007: PUSH
26008: LD_INT 1
26010: PUSH
26011: LD_INT 1
26013: PUSH
26014: EMPTY
26015: LIST
26016: LIST
26017: PUSH
26018: LD_INT 0
26020: PUSH
26021: LD_INT 1
26023: PUSH
26024: EMPTY
26025: LIST
26026: LIST
26027: PUSH
26028: LD_INT 1
26030: NEG
26031: PUSH
26032: LD_INT 0
26034: PUSH
26035: EMPTY
26036: LIST
26037: LIST
26038: PUSH
26039: LD_INT 1
26041: NEG
26042: PUSH
26043: LD_INT 1
26045: NEG
26046: PUSH
26047: EMPTY
26048: LIST
26049: LIST
26050: PUSH
26051: LD_INT 1
26053: NEG
26054: PUSH
26055: LD_INT 2
26057: NEG
26058: PUSH
26059: EMPTY
26060: LIST
26061: LIST
26062: PUSH
26063: LD_INT 0
26065: PUSH
26066: LD_INT 2
26068: NEG
26069: PUSH
26070: EMPTY
26071: LIST
26072: LIST
26073: PUSH
26074: LD_INT 1
26076: PUSH
26077: LD_INT 1
26079: NEG
26080: PUSH
26081: EMPTY
26082: LIST
26083: LIST
26084: PUSH
26085: LD_INT 2
26087: PUSH
26088: LD_INT 1
26090: PUSH
26091: EMPTY
26092: LIST
26093: LIST
26094: PUSH
26095: LD_INT 2
26097: PUSH
26098: LD_INT 2
26100: PUSH
26101: EMPTY
26102: LIST
26103: LIST
26104: PUSH
26105: LD_INT 1
26107: PUSH
26108: LD_INT 2
26110: PUSH
26111: EMPTY
26112: LIST
26113: LIST
26114: PUSH
26115: LD_INT 0
26117: PUSH
26118: LD_INT 2
26120: PUSH
26121: EMPTY
26122: LIST
26123: LIST
26124: PUSH
26125: LD_INT 1
26127: NEG
26128: PUSH
26129: LD_INT 1
26131: PUSH
26132: EMPTY
26133: LIST
26134: LIST
26135: PUSH
26136: LD_INT 2
26138: NEG
26139: PUSH
26140: LD_INT 1
26142: NEG
26143: PUSH
26144: EMPTY
26145: LIST
26146: LIST
26147: PUSH
26148: LD_INT 2
26150: NEG
26151: PUSH
26152: LD_INT 2
26154: NEG
26155: PUSH
26156: EMPTY
26157: LIST
26158: LIST
26159: PUSH
26160: LD_INT 2
26162: NEG
26163: PUSH
26164: LD_INT 3
26166: NEG
26167: PUSH
26168: EMPTY
26169: LIST
26170: LIST
26171: PUSH
26172: LD_INT 1
26174: NEG
26175: PUSH
26176: LD_INT 3
26178: NEG
26179: PUSH
26180: EMPTY
26181: LIST
26182: LIST
26183: PUSH
26184: LD_INT 0
26186: PUSH
26187: LD_INT 3
26189: NEG
26190: PUSH
26191: EMPTY
26192: LIST
26193: LIST
26194: PUSH
26195: LD_INT 1
26197: PUSH
26198: LD_INT 2
26200: NEG
26201: PUSH
26202: EMPTY
26203: LIST
26204: LIST
26205: PUSH
26206: LD_INT 3
26208: PUSH
26209: LD_INT 2
26211: PUSH
26212: EMPTY
26213: LIST
26214: LIST
26215: PUSH
26216: LD_INT 3
26218: PUSH
26219: LD_INT 3
26221: PUSH
26222: EMPTY
26223: LIST
26224: LIST
26225: PUSH
26226: LD_INT 2
26228: PUSH
26229: LD_INT 3
26231: PUSH
26232: EMPTY
26233: LIST
26234: LIST
26235: PUSH
26236: LD_INT 1
26238: PUSH
26239: LD_INT 3
26241: PUSH
26242: EMPTY
26243: LIST
26244: LIST
26245: PUSH
26246: LD_INT 0
26248: PUSH
26249: LD_INT 3
26251: PUSH
26252: EMPTY
26253: LIST
26254: LIST
26255: PUSH
26256: LD_INT 1
26258: NEG
26259: PUSH
26260: LD_INT 2
26262: PUSH
26263: EMPTY
26264: LIST
26265: LIST
26266: PUSH
26267: LD_INT 3
26269: NEG
26270: PUSH
26271: LD_INT 2
26273: NEG
26274: PUSH
26275: EMPTY
26276: LIST
26277: LIST
26278: PUSH
26279: LD_INT 3
26281: NEG
26282: PUSH
26283: LD_INT 3
26285: NEG
26286: PUSH
26287: EMPTY
26288: LIST
26289: LIST
26290: PUSH
26291: EMPTY
26292: LIST
26293: LIST
26294: LIST
26295: LIST
26296: LIST
26297: LIST
26298: LIST
26299: LIST
26300: LIST
26301: LIST
26302: LIST
26303: LIST
26304: LIST
26305: LIST
26306: LIST
26307: LIST
26308: LIST
26309: LIST
26310: LIST
26311: LIST
26312: LIST
26313: LIST
26314: LIST
26315: LIST
26316: LIST
26317: LIST
26318: LIST
26319: LIST
26320: LIST
26321: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
26322: LD_ADDR_VAR 0 46
26326: PUSH
26327: LD_INT 0
26329: PUSH
26330: LD_INT 0
26332: PUSH
26333: EMPTY
26334: LIST
26335: LIST
26336: PUSH
26337: LD_INT 0
26339: PUSH
26340: LD_INT 1
26342: NEG
26343: PUSH
26344: EMPTY
26345: LIST
26346: LIST
26347: PUSH
26348: LD_INT 1
26350: PUSH
26351: LD_INT 0
26353: PUSH
26354: EMPTY
26355: LIST
26356: LIST
26357: PUSH
26358: LD_INT 1
26360: PUSH
26361: LD_INT 1
26363: PUSH
26364: EMPTY
26365: LIST
26366: LIST
26367: PUSH
26368: LD_INT 0
26370: PUSH
26371: LD_INT 1
26373: PUSH
26374: EMPTY
26375: LIST
26376: LIST
26377: PUSH
26378: LD_INT 1
26380: NEG
26381: PUSH
26382: LD_INT 0
26384: PUSH
26385: EMPTY
26386: LIST
26387: LIST
26388: PUSH
26389: LD_INT 1
26391: NEG
26392: PUSH
26393: LD_INT 1
26395: NEG
26396: PUSH
26397: EMPTY
26398: LIST
26399: LIST
26400: PUSH
26401: LD_INT 1
26403: NEG
26404: PUSH
26405: LD_INT 2
26407: NEG
26408: PUSH
26409: EMPTY
26410: LIST
26411: LIST
26412: PUSH
26413: LD_INT 0
26415: PUSH
26416: LD_INT 2
26418: NEG
26419: PUSH
26420: EMPTY
26421: LIST
26422: LIST
26423: PUSH
26424: LD_INT 1
26426: PUSH
26427: LD_INT 1
26429: NEG
26430: PUSH
26431: EMPTY
26432: LIST
26433: LIST
26434: PUSH
26435: LD_INT 2
26437: PUSH
26438: LD_INT 0
26440: PUSH
26441: EMPTY
26442: LIST
26443: LIST
26444: PUSH
26445: LD_INT 2
26447: PUSH
26448: LD_INT 1
26450: PUSH
26451: EMPTY
26452: LIST
26453: LIST
26454: PUSH
26455: LD_INT 1
26457: PUSH
26458: LD_INT 2
26460: PUSH
26461: EMPTY
26462: LIST
26463: LIST
26464: PUSH
26465: LD_INT 0
26467: PUSH
26468: LD_INT 2
26470: PUSH
26471: EMPTY
26472: LIST
26473: LIST
26474: PUSH
26475: LD_INT 1
26477: NEG
26478: PUSH
26479: LD_INT 1
26481: PUSH
26482: EMPTY
26483: LIST
26484: LIST
26485: PUSH
26486: LD_INT 2
26488: NEG
26489: PUSH
26490: LD_INT 0
26492: PUSH
26493: EMPTY
26494: LIST
26495: LIST
26496: PUSH
26497: LD_INT 2
26499: NEG
26500: PUSH
26501: LD_INT 1
26503: NEG
26504: PUSH
26505: EMPTY
26506: LIST
26507: LIST
26508: PUSH
26509: LD_INT 1
26511: NEG
26512: PUSH
26513: LD_INT 3
26515: NEG
26516: PUSH
26517: EMPTY
26518: LIST
26519: LIST
26520: PUSH
26521: LD_INT 0
26523: PUSH
26524: LD_INT 3
26526: NEG
26527: PUSH
26528: EMPTY
26529: LIST
26530: LIST
26531: PUSH
26532: LD_INT 1
26534: PUSH
26535: LD_INT 2
26537: NEG
26538: PUSH
26539: EMPTY
26540: LIST
26541: LIST
26542: PUSH
26543: LD_INT 2
26545: PUSH
26546: LD_INT 1
26548: NEG
26549: PUSH
26550: EMPTY
26551: LIST
26552: LIST
26553: PUSH
26554: LD_INT 3
26556: PUSH
26557: LD_INT 0
26559: PUSH
26560: EMPTY
26561: LIST
26562: LIST
26563: PUSH
26564: LD_INT 3
26566: PUSH
26567: LD_INT 1
26569: PUSH
26570: EMPTY
26571: LIST
26572: LIST
26573: PUSH
26574: LD_INT 1
26576: PUSH
26577: LD_INT 3
26579: PUSH
26580: EMPTY
26581: LIST
26582: LIST
26583: PUSH
26584: LD_INT 0
26586: PUSH
26587: LD_INT 3
26589: PUSH
26590: EMPTY
26591: LIST
26592: LIST
26593: PUSH
26594: LD_INT 1
26596: NEG
26597: PUSH
26598: LD_INT 2
26600: PUSH
26601: EMPTY
26602: LIST
26603: LIST
26604: PUSH
26605: LD_INT 2
26607: NEG
26608: PUSH
26609: LD_INT 1
26611: PUSH
26612: EMPTY
26613: LIST
26614: LIST
26615: PUSH
26616: LD_INT 3
26618: NEG
26619: PUSH
26620: LD_INT 0
26622: PUSH
26623: EMPTY
26624: LIST
26625: LIST
26626: PUSH
26627: LD_INT 3
26629: NEG
26630: PUSH
26631: LD_INT 1
26633: NEG
26634: PUSH
26635: EMPTY
26636: LIST
26637: LIST
26638: PUSH
26639: EMPTY
26640: LIST
26641: LIST
26642: LIST
26643: LIST
26644: LIST
26645: LIST
26646: LIST
26647: LIST
26648: LIST
26649: LIST
26650: LIST
26651: LIST
26652: LIST
26653: LIST
26654: LIST
26655: LIST
26656: LIST
26657: LIST
26658: LIST
26659: LIST
26660: LIST
26661: LIST
26662: LIST
26663: LIST
26664: LIST
26665: LIST
26666: LIST
26667: LIST
26668: LIST
26669: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26670: LD_ADDR_VAR 0 47
26674: PUSH
26675: LD_INT 0
26677: PUSH
26678: LD_INT 0
26680: PUSH
26681: EMPTY
26682: LIST
26683: LIST
26684: PUSH
26685: LD_INT 0
26687: PUSH
26688: LD_INT 1
26690: NEG
26691: PUSH
26692: EMPTY
26693: LIST
26694: LIST
26695: PUSH
26696: LD_INT 1
26698: PUSH
26699: LD_INT 0
26701: PUSH
26702: EMPTY
26703: LIST
26704: LIST
26705: PUSH
26706: LD_INT 1
26708: PUSH
26709: LD_INT 1
26711: PUSH
26712: EMPTY
26713: LIST
26714: LIST
26715: PUSH
26716: LD_INT 0
26718: PUSH
26719: LD_INT 1
26721: PUSH
26722: EMPTY
26723: LIST
26724: LIST
26725: PUSH
26726: LD_INT 1
26728: NEG
26729: PUSH
26730: LD_INT 0
26732: PUSH
26733: EMPTY
26734: LIST
26735: LIST
26736: PUSH
26737: LD_INT 1
26739: NEG
26740: PUSH
26741: LD_INT 1
26743: NEG
26744: PUSH
26745: EMPTY
26746: LIST
26747: LIST
26748: PUSH
26749: LD_INT 1
26751: NEG
26752: PUSH
26753: LD_INT 2
26755: NEG
26756: PUSH
26757: EMPTY
26758: LIST
26759: LIST
26760: PUSH
26761: LD_INT 0
26763: PUSH
26764: LD_INT 2
26766: NEG
26767: PUSH
26768: EMPTY
26769: LIST
26770: LIST
26771: PUSH
26772: LD_INT 1
26774: PUSH
26775: LD_INT 1
26777: NEG
26778: PUSH
26779: EMPTY
26780: LIST
26781: LIST
26782: PUSH
26783: LD_INT 2
26785: NEG
26786: PUSH
26787: LD_INT 1
26789: NEG
26790: PUSH
26791: EMPTY
26792: LIST
26793: LIST
26794: PUSH
26795: LD_INT 2
26797: NEG
26798: PUSH
26799: LD_INT 2
26801: NEG
26802: PUSH
26803: EMPTY
26804: LIST
26805: LIST
26806: PUSH
26807: EMPTY
26808: LIST
26809: LIST
26810: LIST
26811: LIST
26812: LIST
26813: LIST
26814: LIST
26815: LIST
26816: LIST
26817: LIST
26818: LIST
26819: LIST
26820: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
26821: LD_ADDR_VAR 0 48
26825: PUSH
26826: LD_INT 0
26828: PUSH
26829: LD_INT 0
26831: PUSH
26832: EMPTY
26833: LIST
26834: LIST
26835: PUSH
26836: LD_INT 0
26838: PUSH
26839: LD_INT 1
26841: NEG
26842: PUSH
26843: EMPTY
26844: LIST
26845: LIST
26846: PUSH
26847: LD_INT 1
26849: PUSH
26850: LD_INT 0
26852: PUSH
26853: EMPTY
26854: LIST
26855: LIST
26856: PUSH
26857: LD_INT 1
26859: PUSH
26860: LD_INT 1
26862: PUSH
26863: EMPTY
26864: LIST
26865: LIST
26866: PUSH
26867: LD_INT 0
26869: PUSH
26870: LD_INT 1
26872: PUSH
26873: EMPTY
26874: LIST
26875: LIST
26876: PUSH
26877: LD_INT 1
26879: NEG
26880: PUSH
26881: LD_INT 0
26883: PUSH
26884: EMPTY
26885: LIST
26886: LIST
26887: PUSH
26888: LD_INT 1
26890: NEG
26891: PUSH
26892: LD_INT 1
26894: NEG
26895: PUSH
26896: EMPTY
26897: LIST
26898: LIST
26899: PUSH
26900: LD_INT 1
26902: NEG
26903: PUSH
26904: LD_INT 2
26906: NEG
26907: PUSH
26908: EMPTY
26909: LIST
26910: LIST
26911: PUSH
26912: LD_INT 0
26914: PUSH
26915: LD_INT 2
26917: NEG
26918: PUSH
26919: EMPTY
26920: LIST
26921: LIST
26922: PUSH
26923: LD_INT 1
26925: PUSH
26926: LD_INT 1
26928: NEG
26929: PUSH
26930: EMPTY
26931: LIST
26932: LIST
26933: PUSH
26934: LD_INT 2
26936: PUSH
26937: LD_INT 0
26939: PUSH
26940: EMPTY
26941: LIST
26942: LIST
26943: PUSH
26944: LD_INT 2
26946: PUSH
26947: LD_INT 1
26949: PUSH
26950: EMPTY
26951: LIST
26952: LIST
26953: PUSH
26954: EMPTY
26955: LIST
26956: LIST
26957: LIST
26958: LIST
26959: LIST
26960: LIST
26961: LIST
26962: LIST
26963: LIST
26964: LIST
26965: LIST
26966: LIST
26967: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
26968: LD_ADDR_VAR 0 49
26972: PUSH
26973: LD_INT 0
26975: PUSH
26976: LD_INT 0
26978: PUSH
26979: EMPTY
26980: LIST
26981: LIST
26982: PUSH
26983: LD_INT 0
26985: PUSH
26986: LD_INT 1
26988: NEG
26989: PUSH
26990: EMPTY
26991: LIST
26992: LIST
26993: PUSH
26994: LD_INT 1
26996: PUSH
26997: LD_INT 0
26999: PUSH
27000: EMPTY
27001: LIST
27002: LIST
27003: PUSH
27004: LD_INT 1
27006: PUSH
27007: LD_INT 1
27009: PUSH
27010: EMPTY
27011: LIST
27012: LIST
27013: PUSH
27014: LD_INT 0
27016: PUSH
27017: LD_INT 1
27019: PUSH
27020: EMPTY
27021: LIST
27022: LIST
27023: PUSH
27024: LD_INT 1
27026: NEG
27027: PUSH
27028: LD_INT 0
27030: PUSH
27031: EMPTY
27032: LIST
27033: LIST
27034: PUSH
27035: LD_INT 1
27037: NEG
27038: PUSH
27039: LD_INT 1
27041: NEG
27042: PUSH
27043: EMPTY
27044: LIST
27045: LIST
27046: PUSH
27047: LD_INT 1
27049: PUSH
27050: LD_INT 1
27052: NEG
27053: PUSH
27054: EMPTY
27055: LIST
27056: LIST
27057: PUSH
27058: LD_INT 2
27060: PUSH
27061: LD_INT 0
27063: PUSH
27064: EMPTY
27065: LIST
27066: LIST
27067: PUSH
27068: LD_INT 2
27070: PUSH
27071: LD_INT 1
27073: PUSH
27074: EMPTY
27075: LIST
27076: LIST
27077: PUSH
27078: LD_INT 2
27080: PUSH
27081: LD_INT 2
27083: PUSH
27084: EMPTY
27085: LIST
27086: LIST
27087: PUSH
27088: LD_INT 1
27090: PUSH
27091: LD_INT 2
27093: PUSH
27094: EMPTY
27095: LIST
27096: LIST
27097: PUSH
27098: EMPTY
27099: LIST
27100: LIST
27101: LIST
27102: LIST
27103: LIST
27104: LIST
27105: LIST
27106: LIST
27107: LIST
27108: LIST
27109: LIST
27110: LIST
27111: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
27112: LD_ADDR_VAR 0 50
27116: PUSH
27117: LD_INT 0
27119: PUSH
27120: LD_INT 0
27122: PUSH
27123: EMPTY
27124: LIST
27125: LIST
27126: PUSH
27127: LD_INT 0
27129: PUSH
27130: LD_INT 1
27132: NEG
27133: PUSH
27134: EMPTY
27135: LIST
27136: LIST
27137: PUSH
27138: LD_INT 1
27140: PUSH
27141: LD_INT 0
27143: PUSH
27144: EMPTY
27145: LIST
27146: LIST
27147: PUSH
27148: LD_INT 1
27150: PUSH
27151: LD_INT 1
27153: PUSH
27154: EMPTY
27155: LIST
27156: LIST
27157: PUSH
27158: LD_INT 0
27160: PUSH
27161: LD_INT 1
27163: PUSH
27164: EMPTY
27165: LIST
27166: LIST
27167: PUSH
27168: LD_INT 1
27170: NEG
27171: PUSH
27172: LD_INT 0
27174: PUSH
27175: EMPTY
27176: LIST
27177: LIST
27178: PUSH
27179: LD_INT 1
27181: NEG
27182: PUSH
27183: LD_INT 1
27185: NEG
27186: PUSH
27187: EMPTY
27188: LIST
27189: LIST
27190: PUSH
27191: LD_INT 2
27193: PUSH
27194: LD_INT 1
27196: PUSH
27197: EMPTY
27198: LIST
27199: LIST
27200: PUSH
27201: LD_INT 2
27203: PUSH
27204: LD_INT 2
27206: PUSH
27207: EMPTY
27208: LIST
27209: LIST
27210: PUSH
27211: LD_INT 1
27213: PUSH
27214: LD_INT 2
27216: PUSH
27217: EMPTY
27218: LIST
27219: LIST
27220: PUSH
27221: LD_INT 0
27223: PUSH
27224: LD_INT 2
27226: PUSH
27227: EMPTY
27228: LIST
27229: LIST
27230: PUSH
27231: LD_INT 1
27233: NEG
27234: PUSH
27235: LD_INT 1
27237: PUSH
27238: EMPTY
27239: LIST
27240: LIST
27241: PUSH
27242: EMPTY
27243: LIST
27244: LIST
27245: LIST
27246: LIST
27247: LIST
27248: LIST
27249: LIST
27250: LIST
27251: LIST
27252: LIST
27253: LIST
27254: LIST
27255: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
27256: LD_ADDR_VAR 0 51
27260: PUSH
27261: LD_INT 0
27263: PUSH
27264: LD_INT 0
27266: PUSH
27267: EMPTY
27268: LIST
27269: LIST
27270: PUSH
27271: LD_INT 0
27273: PUSH
27274: LD_INT 1
27276: NEG
27277: PUSH
27278: EMPTY
27279: LIST
27280: LIST
27281: PUSH
27282: LD_INT 1
27284: PUSH
27285: LD_INT 0
27287: PUSH
27288: EMPTY
27289: LIST
27290: LIST
27291: PUSH
27292: LD_INT 1
27294: PUSH
27295: LD_INT 1
27297: PUSH
27298: EMPTY
27299: LIST
27300: LIST
27301: PUSH
27302: LD_INT 0
27304: PUSH
27305: LD_INT 1
27307: PUSH
27308: EMPTY
27309: LIST
27310: LIST
27311: PUSH
27312: LD_INT 1
27314: NEG
27315: PUSH
27316: LD_INT 0
27318: PUSH
27319: EMPTY
27320: LIST
27321: LIST
27322: PUSH
27323: LD_INT 1
27325: NEG
27326: PUSH
27327: LD_INT 1
27329: NEG
27330: PUSH
27331: EMPTY
27332: LIST
27333: LIST
27334: PUSH
27335: LD_INT 1
27337: PUSH
27338: LD_INT 2
27340: PUSH
27341: EMPTY
27342: LIST
27343: LIST
27344: PUSH
27345: LD_INT 0
27347: PUSH
27348: LD_INT 2
27350: PUSH
27351: EMPTY
27352: LIST
27353: LIST
27354: PUSH
27355: LD_INT 1
27357: NEG
27358: PUSH
27359: LD_INT 1
27361: PUSH
27362: EMPTY
27363: LIST
27364: LIST
27365: PUSH
27366: LD_INT 2
27368: NEG
27369: PUSH
27370: LD_INT 0
27372: PUSH
27373: EMPTY
27374: LIST
27375: LIST
27376: PUSH
27377: LD_INT 2
27379: NEG
27380: PUSH
27381: LD_INT 1
27383: NEG
27384: PUSH
27385: EMPTY
27386: LIST
27387: LIST
27388: PUSH
27389: EMPTY
27390: LIST
27391: LIST
27392: LIST
27393: LIST
27394: LIST
27395: LIST
27396: LIST
27397: LIST
27398: LIST
27399: LIST
27400: LIST
27401: LIST
27402: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27403: LD_ADDR_VAR 0 52
27407: PUSH
27408: LD_INT 0
27410: PUSH
27411: LD_INT 0
27413: PUSH
27414: EMPTY
27415: LIST
27416: LIST
27417: PUSH
27418: LD_INT 0
27420: PUSH
27421: LD_INT 1
27423: NEG
27424: PUSH
27425: EMPTY
27426: LIST
27427: LIST
27428: PUSH
27429: LD_INT 1
27431: PUSH
27432: LD_INT 0
27434: PUSH
27435: EMPTY
27436: LIST
27437: LIST
27438: PUSH
27439: LD_INT 1
27441: PUSH
27442: LD_INT 1
27444: PUSH
27445: EMPTY
27446: LIST
27447: LIST
27448: PUSH
27449: LD_INT 0
27451: PUSH
27452: LD_INT 1
27454: PUSH
27455: EMPTY
27456: LIST
27457: LIST
27458: PUSH
27459: LD_INT 1
27461: NEG
27462: PUSH
27463: LD_INT 0
27465: PUSH
27466: EMPTY
27467: LIST
27468: LIST
27469: PUSH
27470: LD_INT 1
27472: NEG
27473: PUSH
27474: LD_INT 1
27476: NEG
27477: PUSH
27478: EMPTY
27479: LIST
27480: LIST
27481: PUSH
27482: LD_INT 1
27484: NEG
27485: PUSH
27486: LD_INT 2
27488: NEG
27489: PUSH
27490: EMPTY
27491: LIST
27492: LIST
27493: PUSH
27494: LD_INT 1
27496: NEG
27497: PUSH
27498: LD_INT 1
27500: PUSH
27501: EMPTY
27502: LIST
27503: LIST
27504: PUSH
27505: LD_INT 2
27507: NEG
27508: PUSH
27509: LD_INT 0
27511: PUSH
27512: EMPTY
27513: LIST
27514: LIST
27515: PUSH
27516: LD_INT 2
27518: NEG
27519: PUSH
27520: LD_INT 1
27522: NEG
27523: PUSH
27524: EMPTY
27525: LIST
27526: LIST
27527: PUSH
27528: LD_INT 2
27530: NEG
27531: PUSH
27532: LD_INT 2
27534: NEG
27535: PUSH
27536: EMPTY
27537: LIST
27538: LIST
27539: PUSH
27540: EMPTY
27541: LIST
27542: LIST
27543: LIST
27544: LIST
27545: LIST
27546: LIST
27547: LIST
27548: LIST
27549: LIST
27550: LIST
27551: LIST
27552: LIST
27553: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27554: LD_ADDR_VAR 0 53
27558: PUSH
27559: LD_INT 0
27561: PUSH
27562: LD_INT 0
27564: PUSH
27565: EMPTY
27566: LIST
27567: LIST
27568: PUSH
27569: LD_INT 0
27571: PUSH
27572: LD_INT 1
27574: NEG
27575: PUSH
27576: EMPTY
27577: LIST
27578: LIST
27579: PUSH
27580: LD_INT 1
27582: PUSH
27583: LD_INT 0
27585: PUSH
27586: EMPTY
27587: LIST
27588: LIST
27589: PUSH
27590: LD_INT 1
27592: PUSH
27593: LD_INT 1
27595: PUSH
27596: EMPTY
27597: LIST
27598: LIST
27599: PUSH
27600: LD_INT 0
27602: PUSH
27603: LD_INT 1
27605: PUSH
27606: EMPTY
27607: LIST
27608: LIST
27609: PUSH
27610: LD_INT 1
27612: NEG
27613: PUSH
27614: LD_INT 0
27616: PUSH
27617: EMPTY
27618: LIST
27619: LIST
27620: PUSH
27621: LD_INT 1
27623: NEG
27624: PUSH
27625: LD_INT 1
27627: NEG
27628: PUSH
27629: EMPTY
27630: LIST
27631: LIST
27632: PUSH
27633: LD_INT 1
27635: NEG
27636: PUSH
27637: LD_INT 2
27639: NEG
27640: PUSH
27641: EMPTY
27642: LIST
27643: LIST
27644: PUSH
27645: LD_INT 0
27647: PUSH
27648: LD_INT 2
27650: NEG
27651: PUSH
27652: EMPTY
27653: LIST
27654: LIST
27655: PUSH
27656: LD_INT 1
27658: PUSH
27659: LD_INT 1
27661: NEG
27662: PUSH
27663: EMPTY
27664: LIST
27665: LIST
27666: PUSH
27667: LD_INT 2
27669: PUSH
27670: LD_INT 0
27672: PUSH
27673: EMPTY
27674: LIST
27675: LIST
27676: PUSH
27677: LD_INT 2
27679: PUSH
27680: LD_INT 1
27682: PUSH
27683: EMPTY
27684: LIST
27685: LIST
27686: PUSH
27687: LD_INT 2
27689: PUSH
27690: LD_INT 2
27692: PUSH
27693: EMPTY
27694: LIST
27695: LIST
27696: PUSH
27697: LD_INT 1
27699: PUSH
27700: LD_INT 2
27702: PUSH
27703: EMPTY
27704: LIST
27705: LIST
27706: PUSH
27707: LD_INT 0
27709: PUSH
27710: LD_INT 2
27712: PUSH
27713: EMPTY
27714: LIST
27715: LIST
27716: PUSH
27717: LD_INT 1
27719: NEG
27720: PUSH
27721: LD_INT 1
27723: PUSH
27724: EMPTY
27725: LIST
27726: LIST
27727: PUSH
27728: LD_INT 2
27730: NEG
27731: PUSH
27732: LD_INT 0
27734: PUSH
27735: EMPTY
27736: LIST
27737: LIST
27738: PUSH
27739: LD_INT 2
27741: NEG
27742: PUSH
27743: LD_INT 1
27745: NEG
27746: PUSH
27747: EMPTY
27748: LIST
27749: LIST
27750: PUSH
27751: LD_INT 2
27753: NEG
27754: PUSH
27755: LD_INT 2
27757: NEG
27758: PUSH
27759: EMPTY
27760: LIST
27761: LIST
27762: PUSH
27763: EMPTY
27764: LIST
27765: LIST
27766: LIST
27767: LIST
27768: LIST
27769: LIST
27770: LIST
27771: LIST
27772: LIST
27773: LIST
27774: LIST
27775: LIST
27776: LIST
27777: LIST
27778: LIST
27779: LIST
27780: LIST
27781: LIST
27782: LIST
27783: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27784: LD_ADDR_VAR 0 54
27788: PUSH
27789: LD_INT 0
27791: PUSH
27792: LD_INT 0
27794: PUSH
27795: EMPTY
27796: LIST
27797: LIST
27798: PUSH
27799: LD_INT 0
27801: PUSH
27802: LD_INT 1
27804: NEG
27805: PUSH
27806: EMPTY
27807: LIST
27808: LIST
27809: PUSH
27810: LD_INT 1
27812: PUSH
27813: LD_INT 0
27815: PUSH
27816: EMPTY
27817: LIST
27818: LIST
27819: PUSH
27820: LD_INT 1
27822: PUSH
27823: LD_INT 1
27825: PUSH
27826: EMPTY
27827: LIST
27828: LIST
27829: PUSH
27830: LD_INT 0
27832: PUSH
27833: LD_INT 1
27835: PUSH
27836: EMPTY
27837: LIST
27838: LIST
27839: PUSH
27840: LD_INT 1
27842: NEG
27843: PUSH
27844: LD_INT 0
27846: PUSH
27847: EMPTY
27848: LIST
27849: LIST
27850: PUSH
27851: LD_INT 1
27853: NEG
27854: PUSH
27855: LD_INT 1
27857: NEG
27858: PUSH
27859: EMPTY
27860: LIST
27861: LIST
27862: PUSH
27863: LD_INT 1
27865: NEG
27866: PUSH
27867: LD_INT 2
27869: NEG
27870: PUSH
27871: EMPTY
27872: LIST
27873: LIST
27874: PUSH
27875: LD_INT 0
27877: PUSH
27878: LD_INT 2
27880: NEG
27881: PUSH
27882: EMPTY
27883: LIST
27884: LIST
27885: PUSH
27886: LD_INT 1
27888: PUSH
27889: LD_INT 1
27891: NEG
27892: PUSH
27893: EMPTY
27894: LIST
27895: LIST
27896: PUSH
27897: LD_INT 2
27899: PUSH
27900: LD_INT 0
27902: PUSH
27903: EMPTY
27904: LIST
27905: LIST
27906: PUSH
27907: LD_INT 2
27909: PUSH
27910: LD_INT 1
27912: PUSH
27913: EMPTY
27914: LIST
27915: LIST
27916: PUSH
27917: LD_INT 2
27919: PUSH
27920: LD_INT 2
27922: PUSH
27923: EMPTY
27924: LIST
27925: LIST
27926: PUSH
27927: LD_INT 1
27929: PUSH
27930: LD_INT 2
27932: PUSH
27933: EMPTY
27934: LIST
27935: LIST
27936: PUSH
27937: LD_INT 0
27939: PUSH
27940: LD_INT 2
27942: PUSH
27943: EMPTY
27944: LIST
27945: LIST
27946: PUSH
27947: LD_INT 1
27949: NEG
27950: PUSH
27951: LD_INT 1
27953: PUSH
27954: EMPTY
27955: LIST
27956: LIST
27957: PUSH
27958: LD_INT 2
27960: NEG
27961: PUSH
27962: LD_INT 0
27964: PUSH
27965: EMPTY
27966: LIST
27967: LIST
27968: PUSH
27969: LD_INT 2
27971: NEG
27972: PUSH
27973: LD_INT 1
27975: NEG
27976: PUSH
27977: EMPTY
27978: LIST
27979: LIST
27980: PUSH
27981: LD_INT 2
27983: NEG
27984: PUSH
27985: LD_INT 2
27987: NEG
27988: PUSH
27989: EMPTY
27990: LIST
27991: LIST
27992: PUSH
27993: EMPTY
27994: LIST
27995: LIST
27996: LIST
27997: LIST
27998: LIST
27999: LIST
28000: LIST
28001: LIST
28002: LIST
28003: LIST
28004: LIST
28005: LIST
28006: LIST
28007: LIST
28008: LIST
28009: LIST
28010: LIST
28011: LIST
28012: LIST
28013: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28014: LD_ADDR_VAR 0 55
28018: PUSH
28019: LD_INT 0
28021: PUSH
28022: LD_INT 0
28024: PUSH
28025: EMPTY
28026: LIST
28027: LIST
28028: PUSH
28029: LD_INT 0
28031: PUSH
28032: LD_INT 1
28034: NEG
28035: PUSH
28036: EMPTY
28037: LIST
28038: LIST
28039: PUSH
28040: LD_INT 1
28042: PUSH
28043: LD_INT 0
28045: PUSH
28046: EMPTY
28047: LIST
28048: LIST
28049: PUSH
28050: LD_INT 1
28052: PUSH
28053: LD_INT 1
28055: PUSH
28056: EMPTY
28057: LIST
28058: LIST
28059: PUSH
28060: LD_INT 0
28062: PUSH
28063: LD_INT 1
28065: PUSH
28066: EMPTY
28067: LIST
28068: LIST
28069: PUSH
28070: LD_INT 1
28072: NEG
28073: PUSH
28074: LD_INT 0
28076: PUSH
28077: EMPTY
28078: LIST
28079: LIST
28080: PUSH
28081: LD_INT 1
28083: NEG
28084: PUSH
28085: LD_INT 1
28087: NEG
28088: PUSH
28089: EMPTY
28090: LIST
28091: LIST
28092: PUSH
28093: LD_INT 1
28095: NEG
28096: PUSH
28097: LD_INT 2
28099: NEG
28100: PUSH
28101: EMPTY
28102: LIST
28103: LIST
28104: PUSH
28105: LD_INT 0
28107: PUSH
28108: LD_INT 2
28110: NEG
28111: PUSH
28112: EMPTY
28113: LIST
28114: LIST
28115: PUSH
28116: LD_INT 1
28118: PUSH
28119: LD_INT 1
28121: NEG
28122: PUSH
28123: EMPTY
28124: LIST
28125: LIST
28126: PUSH
28127: LD_INT 2
28129: PUSH
28130: LD_INT 0
28132: PUSH
28133: EMPTY
28134: LIST
28135: LIST
28136: PUSH
28137: LD_INT 2
28139: PUSH
28140: LD_INT 1
28142: PUSH
28143: EMPTY
28144: LIST
28145: LIST
28146: PUSH
28147: LD_INT 2
28149: PUSH
28150: LD_INT 2
28152: PUSH
28153: EMPTY
28154: LIST
28155: LIST
28156: PUSH
28157: LD_INT 1
28159: PUSH
28160: LD_INT 2
28162: PUSH
28163: EMPTY
28164: LIST
28165: LIST
28166: PUSH
28167: LD_INT 0
28169: PUSH
28170: LD_INT 2
28172: PUSH
28173: EMPTY
28174: LIST
28175: LIST
28176: PUSH
28177: LD_INT 1
28179: NEG
28180: PUSH
28181: LD_INT 1
28183: PUSH
28184: EMPTY
28185: LIST
28186: LIST
28187: PUSH
28188: LD_INT 2
28190: NEG
28191: PUSH
28192: LD_INT 0
28194: PUSH
28195: EMPTY
28196: LIST
28197: LIST
28198: PUSH
28199: LD_INT 2
28201: NEG
28202: PUSH
28203: LD_INT 1
28205: NEG
28206: PUSH
28207: EMPTY
28208: LIST
28209: LIST
28210: PUSH
28211: LD_INT 2
28213: NEG
28214: PUSH
28215: LD_INT 2
28217: NEG
28218: PUSH
28219: EMPTY
28220: LIST
28221: LIST
28222: PUSH
28223: EMPTY
28224: LIST
28225: LIST
28226: LIST
28227: LIST
28228: LIST
28229: LIST
28230: LIST
28231: LIST
28232: LIST
28233: LIST
28234: LIST
28235: LIST
28236: LIST
28237: LIST
28238: LIST
28239: LIST
28240: LIST
28241: LIST
28242: LIST
28243: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28244: LD_ADDR_VAR 0 56
28248: PUSH
28249: LD_INT 0
28251: PUSH
28252: LD_INT 0
28254: PUSH
28255: EMPTY
28256: LIST
28257: LIST
28258: PUSH
28259: LD_INT 0
28261: PUSH
28262: LD_INT 1
28264: NEG
28265: PUSH
28266: EMPTY
28267: LIST
28268: LIST
28269: PUSH
28270: LD_INT 1
28272: PUSH
28273: LD_INT 0
28275: PUSH
28276: EMPTY
28277: LIST
28278: LIST
28279: PUSH
28280: LD_INT 1
28282: PUSH
28283: LD_INT 1
28285: PUSH
28286: EMPTY
28287: LIST
28288: LIST
28289: PUSH
28290: LD_INT 0
28292: PUSH
28293: LD_INT 1
28295: PUSH
28296: EMPTY
28297: LIST
28298: LIST
28299: PUSH
28300: LD_INT 1
28302: NEG
28303: PUSH
28304: LD_INT 0
28306: PUSH
28307: EMPTY
28308: LIST
28309: LIST
28310: PUSH
28311: LD_INT 1
28313: NEG
28314: PUSH
28315: LD_INT 1
28317: NEG
28318: PUSH
28319: EMPTY
28320: LIST
28321: LIST
28322: PUSH
28323: LD_INT 1
28325: NEG
28326: PUSH
28327: LD_INT 2
28329: NEG
28330: PUSH
28331: EMPTY
28332: LIST
28333: LIST
28334: PUSH
28335: LD_INT 0
28337: PUSH
28338: LD_INT 2
28340: NEG
28341: PUSH
28342: EMPTY
28343: LIST
28344: LIST
28345: PUSH
28346: LD_INT 1
28348: PUSH
28349: LD_INT 1
28351: NEG
28352: PUSH
28353: EMPTY
28354: LIST
28355: LIST
28356: PUSH
28357: LD_INT 2
28359: PUSH
28360: LD_INT 0
28362: PUSH
28363: EMPTY
28364: LIST
28365: LIST
28366: PUSH
28367: LD_INT 2
28369: PUSH
28370: LD_INT 1
28372: PUSH
28373: EMPTY
28374: LIST
28375: LIST
28376: PUSH
28377: LD_INT 2
28379: PUSH
28380: LD_INT 2
28382: PUSH
28383: EMPTY
28384: LIST
28385: LIST
28386: PUSH
28387: LD_INT 1
28389: PUSH
28390: LD_INT 2
28392: PUSH
28393: EMPTY
28394: LIST
28395: LIST
28396: PUSH
28397: LD_INT 0
28399: PUSH
28400: LD_INT 2
28402: PUSH
28403: EMPTY
28404: LIST
28405: LIST
28406: PUSH
28407: LD_INT 1
28409: NEG
28410: PUSH
28411: LD_INT 1
28413: PUSH
28414: EMPTY
28415: LIST
28416: LIST
28417: PUSH
28418: LD_INT 2
28420: NEG
28421: PUSH
28422: LD_INT 0
28424: PUSH
28425: EMPTY
28426: LIST
28427: LIST
28428: PUSH
28429: LD_INT 2
28431: NEG
28432: PUSH
28433: LD_INT 1
28435: NEG
28436: PUSH
28437: EMPTY
28438: LIST
28439: LIST
28440: PUSH
28441: LD_INT 2
28443: NEG
28444: PUSH
28445: LD_INT 2
28447: NEG
28448: PUSH
28449: EMPTY
28450: LIST
28451: LIST
28452: PUSH
28453: EMPTY
28454: LIST
28455: LIST
28456: LIST
28457: LIST
28458: LIST
28459: LIST
28460: LIST
28461: LIST
28462: LIST
28463: LIST
28464: LIST
28465: LIST
28466: LIST
28467: LIST
28468: LIST
28469: LIST
28470: LIST
28471: LIST
28472: LIST
28473: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28474: LD_ADDR_VAR 0 57
28478: PUSH
28479: LD_INT 0
28481: PUSH
28482: LD_INT 0
28484: PUSH
28485: EMPTY
28486: LIST
28487: LIST
28488: PUSH
28489: LD_INT 0
28491: PUSH
28492: LD_INT 1
28494: NEG
28495: PUSH
28496: EMPTY
28497: LIST
28498: LIST
28499: PUSH
28500: LD_INT 1
28502: PUSH
28503: LD_INT 0
28505: PUSH
28506: EMPTY
28507: LIST
28508: LIST
28509: PUSH
28510: LD_INT 1
28512: PUSH
28513: LD_INT 1
28515: PUSH
28516: EMPTY
28517: LIST
28518: LIST
28519: PUSH
28520: LD_INT 0
28522: PUSH
28523: LD_INT 1
28525: PUSH
28526: EMPTY
28527: LIST
28528: LIST
28529: PUSH
28530: LD_INT 1
28532: NEG
28533: PUSH
28534: LD_INT 0
28536: PUSH
28537: EMPTY
28538: LIST
28539: LIST
28540: PUSH
28541: LD_INT 1
28543: NEG
28544: PUSH
28545: LD_INT 1
28547: NEG
28548: PUSH
28549: EMPTY
28550: LIST
28551: LIST
28552: PUSH
28553: LD_INT 1
28555: NEG
28556: PUSH
28557: LD_INT 2
28559: NEG
28560: PUSH
28561: EMPTY
28562: LIST
28563: LIST
28564: PUSH
28565: LD_INT 0
28567: PUSH
28568: LD_INT 2
28570: NEG
28571: PUSH
28572: EMPTY
28573: LIST
28574: LIST
28575: PUSH
28576: LD_INT 1
28578: PUSH
28579: LD_INT 1
28581: NEG
28582: PUSH
28583: EMPTY
28584: LIST
28585: LIST
28586: PUSH
28587: LD_INT 2
28589: PUSH
28590: LD_INT 0
28592: PUSH
28593: EMPTY
28594: LIST
28595: LIST
28596: PUSH
28597: LD_INT 2
28599: PUSH
28600: LD_INT 1
28602: PUSH
28603: EMPTY
28604: LIST
28605: LIST
28606: PUSH
28607: LD_INT 2
28609: PUSH
28610: LD_INT 2
28612: PUSH
28613: EMPTY
28614: LIST
28615: LIST
28616: PUSH
28617: LD_INT 1
28619: PUSH
28620: LD_INT 2
28622: PUSH
28623: EMPTY
28624: LIST
28625: LIST
28626: PUSH
28627: LD_INT 0
28629: PUSH
28630: LD_INT 2
28632: PUSH
28633: EMPTY
28634: LIST
28635: LIST
28636: PUSH
28637: LD_INT 1
28639: NEG
28640: PUSH
28641: LD_INT 1
28643: PUSH
28644: EMPTY
28645: LIST
28646: LIST
28647: PUSH
28648: LD_INT 2
28650: NEG
28651: PUSH
28652: LD_INT 0
28654: PUSH
28655: EMPTY
28656: LIST
28657: LIST
28658: PUSH
28659: LD_INT 2
28661: NEG
28662: PUSH
28663: LD_INT 1
28665: NEG
28666: PUSH
28667: EMPTY
28668: LIST
28669: LIST
28670: PUSH
28671: LD_INT 2
28673: NEG
28674: PUSH
28675: LD_INT 2
28677: NEG
28678: PUSH
28679: EMPTY
28680: LIST
28681: LIST
28682: PUSH
28683: EMPTY
28684: LIST
28685: LIST
28686: LIST
28687: LIST
28688: LIST
28689: LIST
28690: LIST
28691: LIST
28692: LIST
28693: LIST
28694: LIST
28695: LIST
28696: LIST
28697: LIST
28698: LIST
28699: LIST
28700: LIST
28701: LIST
28702: LIST
28703: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28704: LD_ADDR_VAR 0 58
28708: PUSH
28709: LD_INT 0
28711: PUSH
28712: LD_INT 0
28714: PUSH
28715: EMPTY
28716: LIST
28717: LIST
28718: PUSH
28719: LD_INT 0
28721: PUSH
28722: LD_INT 1
28724: NEG
28725: PUSH
28726: EMPTY
28727: LIST
28728: LIST
28729: PUSH
28730: LD_INT 1
28732: PUSH
28733: LD_INT 0
28735: PUSH
28736: EMPTY
28737: LIST
28738: LIST
28739: PUSH
28740: LD_INT 1
28742: PUSH
28743: LD_INT 1
28745: PUSH
28746: EMPTY
28747: LIST
28748: LIST
28749: PUSH
28750: LD_INT 0
28752: PUSH
28753: LD_INT 1
28755: PUSH
28756: EMPTY
28757: LIST
28758: LIST
28759: PUSH
28760: LD_INT 1
28762: NEG
28763: PUSH
28764: LD_INT 0
28766: PUSH
28767: EMPTY
28768: LIST
28769: LIST
28770: PUSH
28771: LD_INT 1
28773: NEG
28774: PUSH
28775: LD_INT 1
28777: NEG
28778: PUSH
28779: EMPTY
28780: LIST
28781: LIST
28782: PUSH
28783: LD_INT 1
28785: NEG
28786: PUSH
28787: LD_INT 2
28789: NEG
28790: PUSH
28791: EMPTY
28792: LIST
28793: LIST
28794: PUSH
28795: LD_INT 0
28797: PUSH
28798: LD_INT 2
28800: NEG
28801: PUSH
28802: EMPTY
28803: LIST
28804: LIST
28805: PUSH
28806: LD_INT 1
28808: PUSH
28809: LD_INT 1
28811: NEG
28812: PUSH
28813: EMPTY
28814: LIST
28815: LIST
28816: PUSH
28817: LD_INT 2
28819: PUSH
28820: LD_INT 0
28822: PUSH
28823: EMPTY
28824: LIST
28825: LIST
28826: PUSH
28827: LD_INT 2
28829: PUSH
28830: LD_INT 1
28832: PUSH
28833: EMPTY
28834: LIST
28835: LIST
28836: PUSH
28837: LD_INT 2
28839: PUSH
28840: LD_INT 2
28842: PUSH
28843: EMPTY
28844: LIST
28845: LIST
28846: PUSH
28847: LD_INT 1
28849: PUSH
28850: LD_INT 2
28852: PUSH
28853: EMPTY
28854: LIST
28855: LIST
28856: PUSH
28857: LD_INT 0
28859: PUSH
28860: LD_INT 2
28862: PUSH
28863: EMPTY
28864: LIST
28865: LIST
28866: PUSH
28867: LD_INT 1
28869: NEG
28870: PUSH
28871: LD_INT 1
28873: PUSH
28874: EMPTY
28875: LIST
28876: LIST
28877: PUSH
28878: LD_INT 2
28880: NEG
28881: PUSH
28882: LD_INT 0
28884: PUSH
28885: EMPTY
28886: LIST
28887: LIST
28888: PUSH
28889: LD_INT 2
28891: NEG
28892: PUSH
28893: LD_INT 1
28895: NEG
28896: PUSH
28897: EMPTY
28898: LIST
28899: LIST
28900: PUSH
28901: LD_INT 2
28903: NEG
28904: PUSH
28905: LD_INT 2
28907: NEG
28908: PUSH
28909: EMPTY
28910: LIST
28911: LIST
28912: PUSH
28913: EMPTY
28914: LIST
28915: LIST
28916: LIST
28917: LIST
28918: LIST
28919: LIST
28920: LIST
28921: LIST
28922: LIST
28923: LIST
28924: LIST
28925: LIST
28926: LIST
28927: LIST
28928: LIST
28929: LIST
28930: LIST
28931: LIST
28932: LIST
28933: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
28934: LD_ADDR_VAR 0 59
28938: PUSH
28939: LD_INT 0
28941: PUSH
28942: LD_INT 0
28944: PUSH
28945: EMPTY
28946: LIST
28947: LIST
28948: PUSH
28949: LD_INT 0
28951: PUSH
28952: LD_INT 1
28954: NEG
28955: PUSH
28956: EMPTY
28957: LIST
28958: LIST
28959: PUSH
28960: LD_INT 1
28962: PUSH
28963: LD_INT 0
28965: PUSH
28966: EMPTY
28967: LIST
28968: LIST
28969: PUSH
28970: LD_INT 1
28972: PUSH
28973: LD_INT 1
28975: PUSH
28976: EMPTY
28977: LIST
28978: LIST
28979: PUSH
28980: LD_INT 0
28982: PUSH
28983: LD_INT 1
28985: PUSH
28986: EMPTY
28987: LIST
28988: LIST
28989: PUSH
28990: LD_INT 1
28992: NEG
28993: PUSH
28994: LD_INT 0
28996: PUSH
28997: EMPTY
28998: LIST
28999: LIST
29000: PUSH
29001: LD_INT 1
29003: NEG
29004: PUSH
29005: LD_INT 1
29007: NEG
29008: PUSH
29009: EMPTY
29010: LIST
29011: LIST
29012: PUSH
29013: EMPTY
29014: LIST
29015: LIST
29016: LIST
29017: LIST
29018: LIST
29019: LIST
29020: LIST
29021: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
29022: LD_ADDR_VAR 0 60
29026: PUSH
29027: LD_INT 0
29029: PUSH
29030: LD_INT 0
29032: PUSH
29033: EMPTY
29034: LIST
29035: LIST
29036: PUSH
29037: LD_INT 0
29039: PUSH
29040: LD_INT 1
29042: NEG
29043: PUSH
29044: EMPTY
29045: LIST
29046: LIST
29047: PUSH
29048: LD_INT 1
29050: PUSH
29051: LD_INT 0
29053: PUSH
29054: EMPTY
29055: LIST
29056: LIST
29057: PUSH
29058: LD_INT 1
29060: PUSH
29061: LD_INT 1
29063: PUSH
29064: EMPTY
29065: LIST
29066: LIST
29067: PUSH
29068: LD_INT 0
29070: PUSH
29071: LD_INT 1
29073: PUSH
29074: EMPTY
29075: LIST
29076: LIST
29077: PUSH
29078: LD_INT 1
29080: NEG
29081: PUSH
29082: LD_INT 0
29084: PUSH
29085: EMPTY
29086: LIST
29087: LIST
29088: PUSH
29089: LD_INT 1
29091: NEG
29092: PUSH
29093: LD_INT 1
29095: NEG
29096: PUSH
29097: EMPTY
29098: LIST
29099: LIST
29100: PUSH
29101: EMPTY
29102: LIST
29103: LIST
29104: LIST
29105: LIST
29106: LIST
29107: LIST
29108: LIST
29109: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
29110: LD_ADDR_VAR 0 61
29114: PUSH
29115: LD_INT 0
29117: PUSH
29118: LD_INT 0
29120: PUSH
29121: EMPTY
29122: LIST
29123: LIST
29124: PUSH
29125: LD_INT 0
29127: PUSH
29128: LD_INT 1
29130: NEG
29131: PUSH
29132: EMPTY
29133: LIST
29134: LIST
29135: PUSH
29136: LD_INT 1
29138: PUSH
29139: LD_INT 0
29141: PUSH
29142: EMPTY
29143: LIST
29144: LIST
29145: PUSH
29146: LD_INT 1
29148: PUSH
29149: LD_INT 1
29151: PUSH
29152: EMPTY
29153: LIST
29154: LIST
29155: PUSH
29156: LD_INT 0
29158: PUSH
29159: LD_INT 1
29161: PUSH
29162: EMPTY
29163: LIST
29164: LIST
29165: PUSH
29166: LD_INT 1
29168: NEG
29169: PUSH
29170: LD_INT 0
29172: PUSH
29173: EMPTY
29174: LIST
29175: LIST
29176: PUSH
29177: LD_INT 1
29179: NEG
29180: PUSH
29181: LD_INT 1
29183: NEG
29184: PUSH
29185: EMPTY
29186: LIST
29187: LIST
29188: PUSH
29189: EMPTY
29190: LIST
29191: LIST
29192: LIST
29193: LIST
29194: LIST
29195: LIST
29196: LIST
29197: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
29198: LD_ADDR_VAR 0 62
29202: PUSH
29203: LD_INT 0
29205: PUSH
29206: LD_INT 0
29208: PUSH
29209: EMPTY
29210: LIST
29211: LIST
29212: PUSH
29213: LD_INT 0
29215: PUSH
29216: LD_INT 1
29218: NEG
29219: PUSH
29220: EMPTY
29221: LIST
29222: LIST
29223: PUSH
29224: LD_INT 1
29226: PUSH
29227: LD_INT 0
29229: PUSH
29230: EMPTY
29231: LIST
29232: LIST
29233: PUSH
29234: LD_INT 1
29236: PUSH
29237: LD_INT 1
29239: PUSH
29240: EMPTY
29241: LIST
29242: LIST
29243: PUSH
29244: LD_INT 0
29246: PUSH
29247: LD_INT 1
29249: PUSH
29250: EMPTY
29251: LIST
29252: LIST
29253: PUSH
29254: LD_INT 1
29256: NEG
29257: PUSH
29258: LD_INT 0
29260: PUSH
29261: EMPTY
29262: LIST
29263: LIST
29264: PUSH
29265: LD_INT 1
29267: NEG
29268: PUSH
29269: LD_INT 1
29271: NEG
29272: PUSH
29273: EMPTY
29274: LIST
29275: LIST
29276: PUSH
29277: EMPTY
29278: LIST
29279: LIST
29280: LIST
29281: LIST
29282: LIST
29283: LIST
29284: LIST
29285: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
29286: LD_ADDR_VAR 0 63
29290: PUSH
29291: LD_INT 0
29293: PUSH
29294: LD_INT 0
29296: PUSH
29297: EMPTY
29298: LIST
29299: LIST
29300: PUSH
29301: LD_INT 0
29303: PUSH
29304: LD_INT 1
29306: NEG
29307: PUSH
29308: EMPTY
29309: LIST
29310: LIST
29311: PUSH
29312: LD_INT 1
29314: PUSH
29315: LD_INT 0
29317: PUSH
29318: EMPTY
29319: LIST
29320: LIST
29321: PUSH
29322: LD_INT 1
29324: PUSH
29325: LD_INT 1
29327: PUSH
29328: EMPTY
29329: LIST
29330: LIST
29331: PUSH
29332: LD_INT 0
29334: PUSH
29335: LD_INT 1
29337: PUSH
29338: EMPTY
29339: LIST
29340: LIST
29341: PUSH
29342: LD_INT 1
29344: NEG
29345: PUSH
29346: LD_INT 0
29348: PUSH
29349: EMPTY
29350: LIST
29351: LIST
29352: PUSH
29353: LD_INT 1
29355: NEG
29356: PUSH
29357: LD_INT 1
29359: NEG
29360: PUSH
29361: EMPTY
29362: LIST
29363: LIST
29364: PUSH
29365: EMPTY
29366: LIST
29367: LIST
29368: LIST
29369: LIST
29370: LIST
29371: LIST
29372: LIST
29373: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
29374: LD_ADDR_VAR 0 64
29378: PUSH
29379: LD_INT 0
29381: PUSH
29382: LD_INT 0
29384: PUSH
29385: EMPTY
29386: LIST
29387: LIST
29388: PUSH
29389: LD_INT 0
29391: PUSH
29392: LD_INT 1
29394: NEG
29395: PUSH
29396: EMPTY
29397: LIST
29398: LIST
29399: PUSH
29400: LD_INT 1
29402: PUSH
29403: LD_INT 0
29405: PUSH
29406: EMPTY
29407: LIST
29408: LIST
29409: PUSH
29410: LD_INT 1
29412: PUSH
29413: LD_INT 1
29415: PUSH
29416: EMPTY
29417: LIST
29418: LIST
29419: PUSH
29420: LD_INT 0
29422: PUSH
29423: LD_INT 1
29425: PUSH
29426: EMPTY
29427: LIST
29428: LIST
29429: PUSH
29430: LD_INT 1
29432: NEG
29433: PUSH
29434: LD_INT 0
29436: PUSH
29437: EMPTY
29438: LIST
29439: LIST
29440: PUSH
29441: LD_INT 1
29443: NEG
29444: PUSH
29445: LD_INT 1
29447: NEG
29448: PUSH
29449: EMPTY
29450: LIST
29451: LIST
29452: PUSH
29453: EMPTY
29454: LIST
29455: LIST
29456: LIST
29457: LIST
29458: LIST
29459: LIST
29460: LIST
29461: ST_TO_ADDR
// end ; 1 :
29462: GO 35359
29464: LD_INT 1
29466: DOUBLE
29467: EQUAL
29468: IFTRUE 29472
29470: GO 32095
29472: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
29473: LD_ADDR_VAR 0 11
29477: PUSH
29478: LD_INT 1
29480: NEG
29481: PUSH
29482: LD_INT 3
29484: NEG
29485: PUSH
29486: EMPTY
29487: LIST
29488: LIST
29489: PUSH
29490: LD_INT 0
29492: PUSH
29493: LD_INT 3
29495: NEG
29496: PUSH
29497: EMPTY
29498: LIST
29499: LIST
29500: PUSH
29501: LD_INT 1
29503: PUSH
29504: LD_INT 2
29506: NEG
29507: PUSH
29508: EMPTY
29509: LIST
29510: LIST
29511: PUSH
29512: EMPTY
29513: LIST
29514: LIST
29515: LIST
29516: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
29517: LD_ADDR_VAR 0 12
29521: PUSH
29522: LD_INT 2
29524: PUSH
29525: LD_INT 1
29527: NEG
29528: PUSH
29529: EMPTY
29530: LIST
29531: LIST
29532: PUSH
29533: LD_INT 3
29535: PUSH
29536: LD_INT 0
29538: PUSH
29539: EMPTY
29540: LIST
29541: LIST
29542: PUSH
29543: LD_INT 3
29545: PUSH
29546: LD_INT 1
29548: PUSH
29549: EMPTY
29550: LIST
29551: LIST
29552: PUSH
29553: EMPTY
29554: LIST
29555: LIST
29556: LIST
29557: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
29558: LD_ADDR_VAR 0 13
29562: PUSH
29563: LD_INT 3
29565: PUSH
29566: LD_INT 2
29568: PUSH
29569: EMPTY
29570: LIST
29571: LIST
29572: PUSH
29573: LD_INT 3
29575: PUSH
29576: LD_INT 3
29578: PUSH
29579: EMPTY
29580: LIST
29581: LIST
29582: PUSH
29583: LD_INT 2
29585: PUSH
29586: LD_INT 3
29588: PUSH
29589: EMPTY
29590: LIST
29591: LIST
29592: PUSH
29593: EMPTY
29594: LIST
29595: LIST
29596: LIST
29597: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
29598: LD_ADDR_VAR 0 14
29602: PUSH
29603: LD_INT 1
29605: PUSH
29606: LD_INT 3
29608: PUSH
29609: EMPTY
29610: LIST
29611: LIST
29612: PUSH
29613: LD_INT 0
29615: PUSH
29616: LD_INT 3
29618: PUSH
29619: EMPTY
29620: LIST
29621: LIST
29622: PUSH
29623: LD_INT 1
29625: NEG
29626: PUSH
29627: LD_INT 2
29629: PUSH
29630: EMPTY
29631: LIST
29632: LIST
29633: PUSH
29634: EMPTY
29635: LIST
29636: LIST
29637: LIST
29638: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
29639: LD_ADDR_VAR 0 15
29643: PUSH
29644: LD_INT 2
29646: NEG
29647: PUSH
29648: LD_INT 1
29650: PUSH
29651: EMPTY
29652: LIST
29653: LIST
29654: PUSH
29655: LD_INT 3
29657: NEG
29658: PUSH
29659: LD_INT 0
29661: PUSH
29662: EMPTY
29663: LIST
29664: LIST
29665: PUSH
29666: LD_INT 3
29668: NEG
29669: PUSH
29670: LD_INT 1
29672: NEG
29673: PUSH
29674: EMPTY
29675: LIST
29676: LIST
29677: PUSH
29678: EMPTY
29679: LIST
29680: LIST
29681: LIST
29682: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29683: LD_ADDR_VAR 0 16
29687: PUSH
29688: LD_INT 2
29690: NEG
29691: PUSH
29692: LD_INT 3
29694: NEG
29695: PUSH
29696: EMPTY
29697: LIST
29698: LIST
29699: PUSH
29700: LD_INT 3
29702: NEG
29703: PUSH
29704: LD_INT 2
29706: NEG
29707: PUSH
29708: EMPTY
29709: LIST
29710: LIST
29711: PUSH
29712: LD_INT 3
29714: NEG
29715: PUSH
29716: LD_INT 3
29718: NEG
29719: PUSH
29720: EMPTY
29721: LIST
29722: LIST
29723: PUSH
29724: EMPTY
29725: LIST
29726: LIST
29727: LIST
29728: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
29729: LD_ADDR_VAR 0 17
29733: PUSH
29734: LD_INT 1
29736: NEG
29737: PUSH
29738: LD_INT 3
29740: NEG
29741: PUSH
29742: EMPTY
29743: LIST
29744: LIST
29745: PUSH
29746: LD_INT 0
29748: PUSH
29749: LD_INT 3
29751: NEG
29752: PUSH
29753: EMPTY
29754: LIST
29755: LIST
29756: PUSH
29757: LD_INT 1
29759: PUSH
29760: LD_INT 2
29762: NEG
29763: PUSH
29764: EMPTY
29765: LIST
29766: LIST
29767: PUSH
29768: EMPTY
29769: LIST
29770: LIST
29771: LIST
29772: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
29773: LD_ADDR_VAR 0 18
29777: PUSH
29778: LD_INT 2
29780: PUSH
29781: LD_INT 1
29783: NEG
29784: PUSH
29785: EMPTY
29786: LIST
29787: LIST
29788: PUSH
29789: LD_INT 3
29791: PUSH
29792: LD_INT 0
29794: PUSH
29795: EMPTY
29796: LIST
29797: LIST
29798: PUSH
29799: LD_INT 3
29801: PUSH
29802: LD_INT 1
29804: PUSH
29805: EMPTY
29806: LIST
29807: LIST
29808: PUSH
29809: EMPTY
29810: LIST
29811: LIST
29812: LIST
29813: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
29814: LD_ADDR_VAR 0 19
29818: PUSH
29819: LD_INT 3
29821: PUSH
29822: LD_INT 2
29824: PUSH
29825: EMPTY
29826: LIST
29827: LIST
29828: PUSH
29829: LD_INT 3
29831: PUSH
29832: LD_INT 3
29834: PUSH
29835: EMPTY
29836: LIST
29837: LIST
29838: PUSH
29839: LD_INT 2
29841: PUSH
29842: LD_INT 3
29844: PUSH
29845: EMPTY
29846: LIST
29847: LIST
29848: PUSH
29849: EMPTY
29850: LIST
29851: LIST
29852: LIST
29853: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
29854: LD_ADDR_VAR 0 20
29858: PUSH
29859: LD_INT 1
29861: PUSH
29862: LD_INT 3
29864: PUSH
29865: EMPTY
29866: LIST
29867: LIST
29868: PUSH
29869: LD_INT 0
29871: PUSH
29872: LD_INT 3
29874: PUSH
29875: EMPTY
29876: LIST
29877: LIST
29878: PUSH
29879: LD_INT 1
29881: NEG
29882: PUSH
29883: LD_INT 2
29885: PUSH
29886: EMPTY
29887: LIST
29888: LIST
29889: PUSH
29890: EMPTY
29891: LIST
29892: LIST
29893: LIST
29894: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
29895: LD_ADDR_VAR 0 21
29899: PUSH
29900: LD_INT 2
29902: NEG
29903: PUSH
29904: LD_INT 1
29906: PUSH
29907: EMPTY
29908: LIST
29909: LIST
29910: PUSH
29911: LD_INT 3
29913: NEG
29914: PUSH
29915: LD_INT 0
29917: PUSH
29918: EMPTY
29919: LIST
29920: LIST
29921: PUSH
29922: LD_INT 3
29924: NEG
29925: PUSH
29926: LD_INT 1
29928: NEG
29929: PUSH
29930: EMPTY
29931: LIST
29932: LIST
29933: PUSH
29934: EMPTY
29935: LIST
29936: LIST
29937: LIST
29938: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29939: LD_ADDR_VAR 0 22
29943: PUSH
29944: LD_INT 2
29946: NEG
29947: PUSH
29948: LD_INT 3
29950: NEG
29951: PUSH
29952: EMPTY
29953: LIST
29954: LIST
29955: PUSH
29956: LD_INT 3
29958: NEG
29959: PUSH
29960: LD_INT 2
29962: NEG
29963: PUSH
29964: EMPTY
29965: LIST
29966: LIST
29967: PUSH
29968: LD_INT 3
29970: NEG
29971: PUSH
29972: LD_INT 3
29974: NEG
29975: PUSH
29976: EMPTY
29977: LIST
29978: LIST
29979: PUSH
29980: EMPTY
29981: LIST
29982: LIST
29983: LIST
29984: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
29985: LD_ADDR_VAR 0 23
29989: PUSH
29990: LD_INT 0
29992: PUSH
29993: LD_INT 3
29995: NEG
29996: PUSH
29997: EMPTY
29998: LIST
29999: LIST
30000: PUSH
30001: LD_INT 1
30003: NEG
30004: PUSH
30005: LD_INT 4
30007: NEG
30008: PUSH
30009: EMPTY
30010: LIST
30011: LIST
30012: PUSH
30013: LD_INT 1
30015: PUSH
30016: LD_INT 3
30018: NEG
30019: PUSH
30020: EMPTY
30021: LIST
30022: LIST
30023: PUSH
30024: EMPTY
30025: LIST
30026: LIST
30027: LIST
30028: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
30029: LD_ADDR_VAR 0 24
30033: PUSH
30034: LD_INT 3
30036: PUSH
30037: LD_INT 0
30039: PUSH
30040: EMPTY
30041: LIST
30042: LIST
30043: PUSH
30044: LD_INT 3
30046: PUSH
30047: LD_INT 1
30049: NEG
30050: PUSH
30051: EMPTY
30052: LIST
30053: LIST
30054: PUSH
30055: LD_INT 4
30057: PUSH
30058: LD_INT 1
30060: PUSH
30061: EMPTY
30062: LIST
30063: LIST
30064: PUSH
30065: EMPTY
30066: LIST
30067: LIST
30068: LIST
30069: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
30070: LD_ADDR_VAR 0 25
30074: PUSH
30075: LD_INT 3
30077: PUSH
30078: LD_INT 3
30080: PUSH
30081: EMPTY
30082: LIST
30083: LIST
30084: PUSH
30085: LD_INT 4
30087: PUSH
30088: LD_INT 3
30090: PUSH
30091: EMPTY
30092: LIST
30093: LIST
30094: PUSH
30095: LD_INT 3
30097: PUSH
30098: LD_INT 4
30100: PUSH
30101: EMPTY
30102: LIST
30103: LIST
30104: PUSH
30105: EMPTY
30106: LIST
30107: LIST
30108: LIST
30109: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
30110: LD_ADDR_VAR 0 26
30114: PUSH
30115: LD_INT 0
30117: PUSH
30118: LD_INT 3
30120: PUSH
30121: EMPTY
30122: LIST
30123: LIST
30124: PUSH
30125: LD_INT 1
30127: PUSH
30128: LD_INT 4
30130: PUSH
30131: EMPTY
30132: LIST
30133: LIST
30134: PUSH
30135: LD_INT 1
30137: NEG
30138: PUSH
30139: LD_INT 3
30141: PUSH
30142: EMPTY
30143: LIST
30144: LIST
30145: PUSH
30146: EMPTY
30147: LIST
30148: LIST
30149: LIST
30150: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
30151: LD_ADDR_VAR 0 27
30155: PUSH
30156: LD_INT 3
30158: NEG
30159: PUSH
30160: LD_INT 0
30162: PUSH
30163: EMPTY
30164: LIST
30165: LIST
30166: PUSH
30167: LD_INT 3
30169: NEG
30170: PUSH
30171: LD_INT 1
30173: PUSH
30174: EMPTY
30175: LIST
30176: LIST
30177: PUSH
30178: LD_INT 4
30180: NEG
30181: PUSH
30182: LD_INT 1
30184: NEG
30185: PUSH
30186: EMPTY
30187: LIST
30188: LIST
30189: PUSH
30190: EMPTY
30191: LIST
30192: LIST
30193: LIST
30194: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
30195: LD_ADDR_VAR 0 28
30199: PUSH
30200: LD_INT 3
30202: NEG
30203: PUSH
30204: LD_INT 3
30206: NEG
30207: PUSH
30208: EMPTY
30209: LIST
30210: LIST
30211: PUSH
30212: LD_INT 3
30214: NEG
30215: PUSH
30216: LD_INT 4
30218: NEG
30219: PUSH
30220: EMPTY
30221: LIST
30222: LIST
30223: PUSH
30224: LD_INT 4
30226: NEG
30227: PUSH
30228: LD_INT 3
30230: NEG
30231: PUSH
30232: EMPTY
30233: LIST
30234: LIST
30235: PUSH
30236: EMPTY
30237: LIST
30238: LIST
30239: LIST
30240: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
30241: LD_ADDR_VAR 0 29
30245: PUSH
30246: LD_INT 1
30248: NEG
30249: PUSH
30250: LD_INT 3
30252: NEG
30253: PUSH
30254: EMPTY
30255: LIST
30256: LIST
30257: PUSH
30258: LD_INT 0
30260: PUSH
30261: LD_INT 3
30263: NEG
30264: PUSH
30265: EMPTY
30266: LIST
30267: LIST
30268: PUSH
30269: LD_INT 1
30271: PUSH
30272: LD_INT 2
30274: NEG
30275: PUSH
30276: EMPTY
30277: LIST
30278: LIST
30279: PUSH
30280: LD_INT 1
30282: NEG
30283: PUSH
30284: LD_INT 4
30286: NEG
30287: PUSH
30288: EMPTY
30289: LIST
30290: LIST
30291: PUSH
30292: LD_INT 0
30294: PUSH
30295: LD_INT 4
30297: NEG
30298: PUSH
30299: EMPTY
30300: LIST
30301: LIST
30302: PUSH
30303: LD_INT 1
30305: PUSH
30306: LD_INT 3
30308: NEG
30309: PUSH
30310: EMPTY
30311: LIST
30312: LIST
30313: PUSH
30314: LD_INT 1
30316: NEG
30317: PUSH
30318: LD_INT 5
30320: NEG
30321: PUSH
30322: EMPTY
30323: LIST
30324: LIST
30325: PUSH
30326: LD_INT 0
30328: PUSH
30329: LD_INT 5
30331: NEG
30332: PUSH
30333: EMPTY
30334: LIST
30335: LIST
30336: PUSH
30337: LD_INT 1
30339: PUSH
30340: LD_INT 4
30342: NEG
30343: PUSH
30344: EMPTY
30345: LIST
30346: LIST
30347: PUSH
30348: LD_INT 1
30350: NEG
30351: PUSH
30352: LD_INT 6
30354: NEG
30355: PUSH
30356: EMPTY
30357: LIST
30358: LIST
30359: PUSH
30360: LD_INT 0
30362: PUSH
30363: LD_INT 6
30365: NEG
30366: PUSH
30367: EMPTY
30368: LIST
30369: LIST
30370: PUSH
30371: LD_INT 1
30373: PUSH
30374: LD_INT 5
30376: NEG
30377: PUSH
30378: EMPTY
30379: LIST
30380: LIST
30381: PUSH
30382: EMPTY
30383: LIST
30384: LIST
30385: LIST
30386: LIST
30387: LIST
30388: LIST
30389: LIST
30390: LIST
30391: LIST
30392: LIST
30393: LIST
30394: LIST
30395: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
30396: LD_ADDR_VAR 0 30
30400: PUSH
30401: LD_INT 2
30403: PUSH
30404: LD_INT 1
30406: NEG
30407: PUSH
30408: EMPTY
30409: LIST
30410: LIST
30411: PUSH
30412: LD_INT 3
30414: PUSH
30415: LD_INT 0
30417: PUSH
30418: EMPTY
30419: LIST
30420: LIST
30421: PUSH
30422: LD_INT 3
30424: PUSH
30425: LD_INT 1
30427: PUSH
30428: EMPTY
30429: LIST
30430: LIST
30431: PUSH
30432: LD_INT 3
30434: PUSH
30435: LD_INT 1
30437: NEG
30438: PUSH
30439: EMPTY
30440: LIST
30441: LIST
30442: PUSH
30443: LD_INT 4
30445: PUSH
30446: LD_INT 0
30448: PUSH
30449: EMPTY
30450: LIST
30451: LIST
30452: PUSH
30453: LD_INT 4
30455: PUSH
30456: LD_INT 1
30458: PUSH
30459: EMPTY
30460: LIST
30461: LIST
30462: PUSH
30463: LD_INT 4
30465: PUSH
30466: LD_INT 1
30468: NEG
30469: PUSH
30470: EMPTY
30471: LIST
30472: LIST
30473: PUSH
30474: LD_INT 5
30476: PUSH
30477: LD_INT 0
30479: PUSH
30480: EMPTY
30481: LIST
30482: LIST
30483: PUSH
30484: LD_INT 5
30486: PUSH
30487: LD_INT 1
30489: PUSH
30490: EMPTY
30491: LIST
30492: LIST
30493: PUSH
30494: LD_INT 5
30496: PUSH
30497: LD_INT 1
30499: NEG
30500: PUSH
30501: EMPTY
30502: LIST
30503: LIST
30504: PUSH
30505: LD_INT 6
30507: PUSH
30508: LD_INT 0
30510: PUSH
30511: EMPTY
30512: LIST
30513: LIST
30514: PUSH
30515: LD_INT 6
30517: PUSH
30518: LD_INT 1
30520: PUSH
30521: EMPTY
30522: LIST
30523: LIST
30524: PUSH
30525: EMPTY
30526: LIST
30527: LIST
30528: LIST
30529: LIST
30530: LIST
30531: LIST
30532: LIST
30533: LIST
30534: LIST
30535: LIST
30536: LIST
30537: LIST
30538: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
30539: LD_ADDR_VAR 0 31
30543: PUSH
30544: LD_INT 3
30546: PUSH
30547: LD_INT 2
30549: PUSH
30550: EMPTY
30551: LIST
30552: LIST
30553: PUSH
30554: LD_INT 3
30556: PUSH
30557: LD_INT 3
30559: PUSH
30560: EMPTY
30561: LIST
30562: LIST
30563: PUSH
30564: LD_INT 2
30566: PUSH
30567: LD_INT 3
30569: PUSH
30570: EMPTY
30571: LIST
30572: LIST
30573: PUSH
30574: LD_INT 4
30576: PUSH
30577: LD_INT 3
30579: PUSH
30580: EMPTY
30581: LIST
30582: LIST
30583: PUSH
30584: LD_INT 4
30586: PUSH
30587: LD_INT 4
30589: PUSH
30590: EMPTY
30591: LIST
30592: LIST
30593: PUSH
30594: LD_INT 3
30596: PUSH
30597: LD_INT 4
30599: PUSH
30600: EMPTY
30601: LIST
30602: LIST
30603: PUSH
30604: LD_INT 5
30606: PUSH
30607: LD_INT 4
30609: PUSH
30610: EMPTY
30611: LIST
30612: LIST
30613: PUSH
30614: LD_INT 5
30616: PUSH
30617: LD_INT 5
30619: PUSH
30620: EMPTY
30621: LIST
30622: LIST
30623: PUSH
30624: LD_INT 4
30626: PUSH
30627: LD_INT 5
30629: PUSH
30630: EMPTY
30631: LIST
30632: LIST
30633: PUSH
30634: LD_INT 6
30636: PUSH
30637: LD_INT 5
30639: PUSH
30640: EMPTY
30641: LIST
30642: LIST
30643: PUSH
30644: LD_INT 6
30646: PUSH
30647: LD_INT 6
30649: PUSH
30650: EMPTY
30651: LIST
30652: LIST
30653: PUSH
30654: LD_INT 5
30656: PUSH
30657: LD_INT 6
30659: PUSH
30660: EMPTY
30661: LIST
30662: LIST
30663: PUSH
30664: EMPTY
30665: LIST
30666: LIST
30667: LIST
30668: LIST
30669: LIST
30670: LIST
30671: LIST
30672: LIST
30673: LIST
30674: LIST
30675: LIST
30676: LIST
30677: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
30678: LD_ADDR_VAR 0 32
30682: PUSH
30683: LD_INT 1
30685: PUSH
30686: LD_INT 3
30688: PUSH
30689: EMPTY
30690: LIST
30691: LIST
30692: PUSH
30693: LD_INT 0
30695: PUSH
30696: LD_INT 3
30698: PUSH
30699: EMPTY
30700: LIST
30701: LIST
30702: PUSH
30703: LD_INT 1
30705: NEG
30706: PUSH
30707: LD_INT 2
30709: PUSH
30710: EMPTY
30711: LIST
30712: LIST
30713: PUSH
30714: LD_INT 1
30716: PUSH
30717: LD_INT 4
30719: PUSH
30720: EMPTY
30721: LIST
30722: LIST
30723: PUSH
30724: LD_INT 0
30726: PUSH
30727: LD_INT 4
30729: PUSH
30730: EMPTY
30731: LIST
30732: LIST
30733: PUSH
30734: LD_INT 1
30736: NEG
30737: PUSH
30738: LD_INT 3
30740: PUSH
30741: EMPTY
30742: LIST
30743: LIST
30744: PUSH
30745: LD_INT 1
30747: PUSH
30748: LD_INT 5
30750: PUSH
30751: EMPTY
30752: LIST
30753: LIST
30754: PUSH
30755: LD_INT 0
30757: PUSH
30758: LD_INT 5
30760: PUSH
30761: EMPTY
30762: LIST
30763: LIST
30764: PUSH
30765: LD_INT 1
30767: NEG
30768: PUSH
30769: LD_INT 4
30771: PUSH
30772: EMPTY
30773: LIST
30774: LIST
30775: PUSH
30776: LD_INT 1
30778: PUSH
30779: LD_INT 6
30781: PUSH
30782: EMPTY
30783: LIST
30784: LIST
30785: PUSH
30786: LD_INT 0
30788: PUSH
30789: LD_INT 6
30791: PUSH
30792: EMPTY
30793: LIST
30794: LIST
30795: PUSH
30796: LD_INT 1
30798: NEG
30799: PUSH
30800: LD_INT 5
30802: PUSH
30803: EMPTY
30804: LIST
30805: LIST
30806: PUSH
30807: EMPTY
30808: LIST
30809: LIST
30810: LIST
30811: LIST
30812: LIST
30813: LIST
30814: LIST
30815: LIST
30816: LIST
30817: LIST
30818: LIST
30819: LIST
30820: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
30821: LD_ADDR_VAR 0 33
30825: PUSH
30826: LD_INT 2
30828: NEG
30829: PUSH
30830: LD_INT 1
30832: PUSH
30833: EMPTY
30834: LIST
30835: LIST
30836: PUSH
30837: LD_INT 3
30839: NEG
30840: PUSH
30841: LD_INT 0
30843: PUSH
30844: EMPTY
30845: LIST
30846: LIST
30847: PUSH
30848: LD_INT 3
30850: NEG
30851: PUSH
30852: LD_INT 1
30854: NEG
30855: PUSH
30856: EMPTY
30857: LIST
30858: LIST
30859: PUSH
30860: LD_INT 3
30862: NEG
30863: PUSH
30864: LD_INT 1
30866: PUSH
30867: EMPTY
30868: LIST
30869: LIST
30870: PUSH
30871: LD_INT 4
30873: NEG
30874: PUSH
30875: LD_INT 0
30877: PUSH
30878: EMPTY
30879: LIST
30880: LIST
30881: PUSH
30882: LD_INT 4
30884: NEG
30885: PUSH
30886: LD_INT 1
30888: NEG
30889: PUSH
30890: EMPTY
30891: LIST
30892: LIST
30893: PUSH
30894: LD_INT 4
30896: NEG
30897: PUSH
30898: LD_INT 1
30900: PUSH
30901: EMPTY
30902: LIST
30903: LIST
30904: PUSH
30905: LD_INT 5
30907: NEG
30908: PUSH
30909: LD_INT 0
30911: PUSH
30912: EMPTY
30913: LIST
30914: LIST
30915: PUSH
30916: LD_INT 5
30918: NEG
30919: PUSH
30920: LD_INT 1
30922: NEG
30923: PUSH
30924: EMPTY
30925: LIST
30926: LIST
30927: PUSH
30928: LD_INT 5
30930: NEG
30931: PUSH
30932: LD_INT 1
30934: PUSH
30935: EMPTY
30936: LIST
30937: LIST
30938: PUSH
30939: LD_INT 6
30941: NEG
30942: PUSH
30943: LD_INT 0
30945: PUSH
30946: EMPTY
30947: LIST
30948: LIST
30949: PUSH
30950: LD_INT 6
30952: NEG
30953: PUSH
30954: LD_INT 1
30956: NEG
30957: PUSH
30958: EMPTY
30959: LIST
30960: LIST
30961: PUSH
30962: EMPTY
30963: LIST
30964: LIST
30965: LIST
30966: LIST
30967: LIST
30968: LIST
30969: LIST
30970: LIST
30971: LIST
30972: LIST
30973: LIST
30974: LIST
30975: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
30976: LD_ADDR_VAR 0 34
30980: PUSH
30981: LD_INT 2
30983: NEG
30984: PUSH
30985: LD_INT 3
30987: NEG
30988: PUSH
30989: EMPTY
30990: LIST
30991: LIST
30992: PUSH
30993: LD_INT 3
30995: NEG
30996: PUSH
30997: LD_INT 2
30999: NEG
31000: PUSH
31001: EMPTY
31002: LIST
31003: LIST
31004: PUSH
31005: LD_INT 3
31007: NEG
31008: PUSH
31009: LD_INT 3
31011: NEG
31012: PUSH
31013: EMPTY
31014: LIST
31015: LIST
31016: PUSH
31017: LD_INT 3
31019: NEG
31020: PUSH
31021: LD_INT 4
31023: NEG
31024: PUSH
31025: EMPTY
31026: LIST
31027: LIST
31028: PUSH
31029: LD_INT 4
31031: NEG
31032: PUSH
31033: LD_INT 3
31035: NEG
31036: PUSH
31037: EMPTY
31038: LIST
31039: LIST
31040: PUSH
31041: LD_INT 4
31043: NEG
31044: PUSH
31045: LD_INT 4
31047: NEG
31048: PUSH
31049: EMPTY
31050: LIST
31051: LIST
31052: PUSH
31053: LD_INT 4
31055: NEG
31056: PUSH
31057: LD_INT 5
31059: NEG
31060: PUSH
31061: EMPTY
31062: LIST
31063: LIST
31064: PUSH
31065: LD_INT 5
31067: NEG
31068: PUSH
31069: LD_INT 4
31071: NEG
31072: PUSH
31073: EMPTY
31074: LIST
31075: LIST
31076: PUSH
31077: LD_INT 5
31079: NEG
31080: PUSH
31081: LD_INT 5
31083: NEG
31084: PUSH
31085: EMPTY
31086: LIST
31087: LIST
31088: PUSH
31089: LD_INT 5
31091: NEG
31092: PUSH
31093: LD_INT 6
31095: NEG
31096: PUSH
31097: EMPTY
31098: LIST
31099: LIST
31100: PUSH
31101: LD_INT 6
31103: NEG
31104: PUSH
31105: LD_INT 5
31107: NEG
31108: PUSH
31109: EMPTY
31110: LIST
31111: LIST
31112: PUSH
31113: LD_INT 6
31115: NEG
31116: PUSH
31117: LD_INT 6
31119: NEG
31120: PUSH
31121: EMPTY
31122: LIST
31123: LIST
31124: PUSH
31125: EMPTY
31126: LIST
31127: LIST
31128: LIST
31129: LIST
31130: LIST
31131: LIST
31132: LIST
31133: LIST
31134: LIST
31135: LIST
31136: LIST
31137: LIST
31138: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
31139: LD_ADDR_VAR 0 41
31143: PUSH
31144: LD_INT 0
31146: PUSH
31147: LD_INT 2
31149: NEG
31150: PUSH
31151: EMPTY
31152: LIST
31153: LIST
31154: PUSH
31155: LD_INT 1
31157: NEG
31158: PUSH
31159: LD_INT 3
31161: NEG
31162: PUSH
31163: EMPTY
31164: LIST
31165: LIST
31166: PUSH
31167: LD_INT 1
31169: PUSH
31170: LD_INT 2
31172: NEG
31173: PUSH
31174: EMPTY
31175: LIST
31176: LIST
31177: PUSH
31178: EMPTY
31179: LIST
31180: LIST
31181: LIST
31182: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
31183: LD_ADDR_VAR 0 42
31187: PUSH
31188: LD_INT 2
31190: PUSH
31191: LD_INT 0
31193: PUSH
31194: EMPTY
31195: LIST
31196: LIST
31197: PUSH
31198: LD_INT 2
31200: PUSH
31201: LD_INT 1
31203: NEG
31204: PUSH
31205: EMPTY
31206: LIST
31207: LIST
31208: PUSH
31209: LD_INT 3
31211: PUSH
31212: LD_INT 1
31214: PUSH
31215: EMPTY
31216: LIST
31217: LIST
31218: PUSH
31219: EMPTY
31220: LIST
31221: LIST
31222: LIST
31223: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
31224: LD_ADDR_VAR 0 43
31228: PUSH
31229: LD_INT 2
31231: PUSH
31232: LD_INT 2
31234: PUSH
31235: EMPTY
31236: LIST
31237: LIST
31238: PUSH
31239: LD_INT 3
31241: PUSH
31242: LD_INT 2
31244: PUSH
31245: EMPTY
31246: LIST
31247: LIST
31248: PUSH
31249: LD_INT 2
31251: PUSH
31252: LD_INT 3
31254: PUSH
31255: EMPTY
31256: LIST
31257: LIST
31258: PUSH
31259: EMPTY
31260: LIST
31261: LIST
31262: LIST
31263: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
31264: LD_ADDR_VAR 0 44
31268: PUSH
31269: LD_INT 0
31271: PUSH
31272: LD_INT 2
31274: PUSH
31275: EMPTY
31276: LIST
31277: LIST
31278: PUSH
31279: LD_INT 1
31281: PUSH
31282: LD_INT 3
31284: PUSH
31285: EMPTY
31286: LIST
31287: LIST
31288: PUSH
31289: LD_INT 1
31291: NEG
31292: PUSH
31293: LD_INT 2
31295: PUSH
31296: EMPTY
31297: LIST
31298: LIST
31299: PUSH
31300: EMPTY
31301: LIST
31302: LIST
31303: LIST
31304: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
31305: LD_ADDR_VAR 0 45
31309: PUSH
31310: LD_INT 2
31312: NEG
31313: PUSH
31314: LD_INT 0
31316: PUSH
31317: EMPTY
31318: LIST
31319: LIST
31320: PUSH
31321: LD_INT 2
31323: NEG
31324: PUSH
31325: LD_INT 1
31327: PUSH
31328: EMPTY
31329: LIST
31330: LIST
31331: PUSH
31332: LD_INT 3
31334: NEG
31335: PUSH
31336: LD_INT 1
31338: NEG
31339: PUSH
31340: EMPTY
31341: LIST
31342: LIST
31343: PUSH
31344: EMPTY
31345: LIST
31346: LIST
31347: LIST
31348: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
31349: LD_ADDR_VAR 0 46
31353: PUSH
31354: LD_INT 2
31356: NEG
31357: PUSH
31358: LD_INT 2
31360: NEG
31361: PUSH
31362: EMPTY
31363: LIST
31364: LIST
31365: PUSH
31366: LD_INT 2
31368: NEG
31369: PUSH
31370: LD_INT 3
31372: NEG
31373: PUSH
31374: EMPTY
31375: LIST
31376: LIST
31377: PUSH
31378: LD_INT 3
31380: NEG
31381: PUSH
31382: LD_INT 2
31384: NEG
31385: PUSH
31386: EMPTY
31387: LIST
31388: LIST
31389: PUSH
31390: EMPTY
31391: LIST
31392: LIST
31393: LIST
31394: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
31395: LD_ADDR_VAR 0 47
31399: PUSH
31400: LD_INT 2
31402: NEG
31403: PUSH
31404: LD_INT 3
31406: NEG
31407: PUSH
31408: EMPTY
31409: LIST
31410: LIST
31411: PUSH
31412: LD_INT 1
31414: NEG
31415: PUSH
31416: LD_INT 3
31418: NEG
31419: PUSH
31420: EMPTY
31421: LIST
31422: LIST
31423: PUSH
31424: EMPTY
31425: LIST
31426: LIST
31427: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
31428: LD_ADDR_VAR 0 48
31432: PUSH
31433: LD_INT 1
31435: PUSH
31436: LD_INT 2
31438: NEG
31439: PUSH
31440: EMPTY
31441: LIST
31442: LIST
31443: PUSH
31444: LD_INT 2
31446: PUSH
31447: LD_INT 1
31449: NEG
31450: PUSH
31451: EMPTY
31452: LIST
31453: LIST
31454: PUSH
31455: EMPTY
31456: LIST
31457: LIST
31458: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
31459: LD_ADDR_VAR 0 49
31463: PUSH
31464: LD_INT 3
31466: PUSH
31467: LD_INT 1
31469: PUSH
31470: EMPTY
31471: LIST
31472: LIST
31473: PUSH
31474: LD_INT 3
31476: PUSH
31477: LD_INT 2
31479: PUSH
31480: EMPTY
31481: LIST
31482: LIST
31483: PUSH
31484: EMPTY
31485: LIST
31486: LIST
31487: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
31488: LD_ADDR_VAR 0 50
31492: PUSH
31493: LD_INT 2
31495: PUSH
31496: LD_INT 3
31498: PUSH
31499: EMPTY
31500: LIST
31501: LIST
31502: PUSH
31503: LD_INT 1
31505: PUSH
31506: LD_INT 3
31508: PUSH
31509: EMPTY
31510: LIST
31511: LIST
31512: PUSH
31513: EMPTY
31514: LIST
31515: LIST
31516: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
31517: LD_ADDR_VAR 0 51
31521: PUSH
31522: LD_INT 1
31524: NEG
31525: PUSH
31526: LD_INT 2
31528: PUSH
31529: EMPTY
31530: LIST
31531: LIST
31532: PUSH
31533: LD_INT 2
31535: NEG
31536: PUSH
31537: LD_INT 1
31539: PUSH
31540: EMPTY
31541: LIST
31542: LIST
31543: PUSH
31544: EMPTY
31545: LIST
31546: LIST
31547: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31548: LD_ADDR_VAR 0 52
31552: PUSH
31553: LD_INT 3
31555: NEG
31556: PUSH
31557: LD_INT 1
31559: NEG
31560: PUSH
31561: EMPTY
31562: LIST
31563: LIST
31564: PUSH
31565: LD_INT 3
31567: NEG
31568: PUSH
31569: LD_INT 2
31571: NEG
31572: PUSH
31573: EMPTY
31574: LIST
31575: LIST
31576: PUSH
31577: EMPTY
31578: LIST
31579: LIST
31580: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
31581: LD_ADDR_VAR 0 53
31585: PUSH
31586: LD_INT 1
31588: NEG
31589: PUSH
31590: LD_INT 3
31592: NEG
31593: PUSH
31594: EMPTY
31595: LIST
31596: LIST
31597: PUSH
31598: LD_INT 0
31600: PUSH
31601: LD_INT 3
31603: NEG
31604: PUSH
31605: EMPTY
31606: LIST
31607: LIST
31608: PUSH
31609: LD_INT 1
31611: PUSH
31612: LD_INT 2
31614: NEG
31615: PUSH
31616: EMPTY
31617: LIST
31618: LIST
31619: PUSH
31620: EMPTY
31621: LIST
31622: LIST
31623: LIST
31624: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
31625: LD_ADDR_VAR 0 54
31629: PUSH
31630: LD_INT 2
31632: PUSH
31633: LD_INT 1
31635: NEG
31636: PUSH
31637: EMPTY
31638: LIST
31639: LIST
31640: PUSH
31641: LD_INT 3
31643: PUSH
31644: LD_INT 0
31646: PUSH
31647: EMPTY
31648: LIST
31649: LIST
31650: PUSH
31651: LD_INT 3
31653: PUSH
31654: LD_INT 1
31656: PUSH
31657: EMPTY
31658: LIST
31659: LIST
31660: PUSH
31661: EMPTY
31662: LIST
31663: LIST
31664: LIST
31665: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
31666: LD_ADDR_VAR 0 55
31670: PUSH
31671: LD_INT 3
31673: PUSH
31674: LD_INT 2
31676: PUSH
31677: EMPTY
31678: LIST
31679: LIST
31680: PUSH
31681: LD_INT 3
31683: PUSH
31684: LD_INT 3
31686: PUSH
31687: EMPTY
31688: LIST
31689: LIST
31690: PUSH
31691: LD_INT 2
31693: PUSH
31694: LD_INT 3
31696: PUSH
31697: EMPTY
31698: LIST
31699: LIST
31700: PUSH
31701: EMPTY
31702: LIST
31703: LIST
31704: LIST
31705: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
31706: LD_ADDR_VAR 0 56
31710: PUSH
31711: LD_INT 1
31713: PUSH
31714: LD_INT 3
31716: PUSH
31717: EMPTY
31718: LIST
31719: LIST
31720: PUSH
31721: LD_INT 0
31723: PUSH
31724: LD_INT 3
31726: PUSH
31727: EMPTY
31728: LIST
31729: LIST
31730: PUSH
31731: LD_INT 1
31733: NEG
31734: PUSH
31735: LD_INT 2
31737: PUSH
31738: EMPTY
31739: LIST
31740: LIST
31741: PUSH
31742: EMPTY
31743: LIST
31744: LIST
31745: LIST
31746: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
31747: LD_ADDR_VAR 0 57
31751: PUSH
31752: LD_INT 2
31754: NEG
31755: PUSH
31756: LD_INT 1
31758: PUSH
31759: EMPTY
31760: LIST
31761: LIST
31762: PUSH
31763: LD_INT 3
31765: NEG
31766: PUSH
31767: LD_INT 0
31769: PUSH
31770: EMPTY
31771: LIST
31772: LIST
31773: PUSH
31774: LD_INT 3
31776: NEG
31777: PUSH
31778: LD_INT 1
31780: NEG
31781: PUSH
31782: EMPTY
31783: LIST
31784: LIST
31785: PUSH
31786: EMPTY
31787: LIST
31788: LIST
31789: LIST
31790: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31791: LD_ADDR_VAR 0 58
31795: PUSH
31796: LD_INT 2
31798: NEG
31799: PUSH
31800: LD_INT 3
31802: NEG
31803: PUSH
31804: EMPTY
31805: LIST
31806: LIST
31807: PUSH
31808: LD_INT 3
31810: NEG
31811: PUSH
31812: LD_INT 2
31814: NEG
31815: PUSH
31816: EMPTY
31817: LIST
31818: LIST
31819: PUSH
31820: LD_INT 3
31822: NEG
31823: PUSH
31824: LD_INT 3
31826: NEG
31827: PUSH
31828: EMPTY
31829: LIST
31830: LIST
31831: PUSH
31832: EMPTY
31833: LIST
31834: LIST
31835: LIST
31836: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
31837: LD_ADDR_VAR 0 59
31841: PUSH
31842: LD_INT 1
31844: NEG
31845: PUSH
31846: LD_INT 2
31848: NEG
31849: PUSH
31850: EMPTY
31851: LIST
31852: LIST
31853: PUSH
31854: LD_INT 0
31856: PUSH
31857: LD_INT 2
31859: NEG
31860: PUSH
31861: EMPTY
31862: LIST
31863: LIST
31864: PUSH
31865: LD_INT 1
31867: PUSH
31868: LD_INT 1
31870: NEG
31871: PUSH
31872: EMPTY
31873: LIST
31874: LIST
31875: PUSH
31876: EMPTY
31877: LIST
31878: LIST
31879: LIST
31880: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
31881: LD_ADDR_VAR 0 60
31885: PUSH
31886: LD_INT 1
31888: PUSH
31889: LD_INT 1
31891: NEG
31892: PUSH
31893: EMPTY
31894: LIST
31895: LIST
31896: PUSH
31897: LD_INT 2
31899: PUSH
31900: LD_INT 0
31902: PUSH
31903: EMPTY
31904: LIST
31905: LIST
31906: PUSH
31907: LD_INT 2
31909: PUSH
31910: LD_INT 1
31912: PUSH
31913: EMPTY
31914: LIST
31915: LIST
31916: PUSH
31917: EMPTY
31918: LIST
31919: LIST
31920: LIST
31921: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
31922: LD_ADDR_VAR 0 61
31926: PUSH
31927: LD_INT 2
31929: PUSH
31930: LD_INT 1
31932: PUSH
31933: EMPTY
31934: LIST
31935: LIST
31936: PUSH
31937: LD_INT 2
31939: PUSH
31940: LD_INT 2
31942: PUSH
31943: EMPTY
31944: LIST
31945: LIST
31946: PUSH
31947: LD_INT 1
31949: PUSH
31950: LD_INT 2
31952: PUSH
31953: EMPTY
31954: LIST
31955: LIST
31956: PUSH
31957: EMPTY
31958: LIST
31959: LIST
31960: LIST
31961: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
31962: LD_ADDR_VAR 0 62
31966: PUSH
31967: LD_INT 1
31969: PUSH
31970: LD_INT 2
31972: PUSH
31973: EMPTY
31974: LIST
31975: LIST
31976: PUSH
31977: LD_INT 0
31979: PUSH
31980: LD_INT 2
31982: PUSH
31983: EMPTY
31984: LIST
31985: LIST
31986: PUSH
31987: LD_INT 1
31989: NEG
31990: PUSH
31991: LD_INT 1
31993: PUSH
31994: EMPTY
31995: LIST
31996: LIST
31997: PUSH
31998: EMPTY
31999: LIST
32000: LIST
32001: LIST
32002: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
32003: LD_ADDR_VAR 0 63
32007: PUSH
32008: LD_INT 1
32010: NEG
32011: PUSH
32012: LD_INT 1
32014: PUSH
32015: EMPTY
32016: LIST
32017: LIST
32018: PUSH
32019: LD_INT 2
32021: NEG
32022: PUSH
32023: LD_INT 0
32025: PUSH
32026: EMPTY
32027: LIST
32028: LIST
32029: PUSH
32030: LD_INT 2
32032: NEG
32033: PUSH
32034: LD_INT 1
32036: NEG
32037: PUSH
32038: EMPTY
32039: LIST
32040: LIST
32041: PUSH
32042: EMPTY
32043: LIST
32044: LIST
32045: LIST
32046: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32047: LD_ADDR_VAR 0 64
32051: PUSH
32052: LD_INT 1
32054: NEG
32055: PUSH
32056: LD_INT 2
32058: NEG
32059: PUSH
32060: EMPTY
32061: LIST
32062: LIST
32063: PUSH
32064: LD_INT 2
32066: NEG
32067: PUSH
32068: LD_INT 1
32070: NEG
32071: PUSH
32072: EMPTY
32073: LIST
32074: LIST
32075: PUSH
32076: LD_INT 2
32078: NEG
32079: PUSH
32080: LD_INT 2
32082: NEG
32083: PUSH
32084: EMPTY
32085: LIST
32086: LIST
32087: PUSH
32088: EMPTY
32089: LIST
32090: LIST
32091: LIST
32092: ST_TO_ADDR
// end ; 2 :
32093: GO 35359
32095: LD_INT 2
32097: DOUBLE
32098: EQUAL
32099: IFTRUE 32103
32101: GO 35358
32103: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
32104: LD_ADDR_VAR 0 29
32108: PUSH
32109: LD_INT 4
32111: PUSH
32112: LD_INT 0
32114: PUSH
32115: EMPTY
32116: LIST
32117: LIST
32118: PUSH
32119: LD_INT 4
32121: PUSH
32122: LD_INT 1
32124: NEG
32125: PUSH
32126: EMPTY
32127: LIST
32128: LIST
32129: PUSH
32130: LD_INT 5
32132: PUSH
32133: LD_INT 0
32135: PUSH
32136: EMPTY
32137: LIST
32138: LIST
32139: PUSH
32140: LD_INT 5
32142: PUSH
32143: LD_INT 1
32145: PUSH
32146: EMPTY
32147: LIST
32148: LIST
32149: PUSH
32150: LD_INT 4
32152: PUSH
32153: LD_INT 1
32155: PUSH
32156: EMPTY
32157: LIST
32158: LIST
32159: PUSH
32160: LD_INT 3
32162: PUSH
32163: LD_INT 0
32165: PUSH
32166: EMPTY
32167: LIST
32168: LIST
32169: PUSH
32170: LD_INT 3
32172: PUSH
32173: LD_INT 1
32175: NEG
32176: PUSH
32177: EMPTY
32178: LIST
32179: LIST
32180: PUSH
32181: LD_INT 3
32183: PUSH
32184: LD_INT 2
32186: NEG
32187: PUSH
32188: EMPTY
32189: LIST
32190: LIST
32191: PUSH
32192: LD_INT 5
32194: PUSH
32195: LD_INT 2
32197: PUSH
32198: EMPTY
32199: LIST
32200: LIST
32201: PUSH
32202: LD_INT 3
32204: PUSH
32205: LD_INT 3
32207: PUSH
32208: EMPTY
32209: LIST
32210: LIST
32211: PUSH
32212: LD_INT 3
32214: PUSH
32215: LD_INT 2
32217: PUSH
32218: EMPTY
32219: LIST
32220: LIST
32221: PUSH
32222: LD_INT 4
32224: PUSH
32225: LD_INT 3
32227: PUSH
32228: EMPTY
32229: LIST
32230: LIST
32231: PUSH
32232: LD_INT 4
32234: PUSH
32235: LD_INT 4
32237: PUSH
32238: EMPTY
32239: LIST
32240: LIST
32241: PUSH
32242: LD_INT 3
32244: PUSH
32245: LD_INT 4
32247: PUSH
32248: EMPTY
32249: LIST
32250: LIST
32251: PUSH
32252: LD_INT 2
32254: PUSH
32255: LD_INT 3
32257: PUSH
32258: EMPTY
32259: LIST
32260: LIST
32261: PUSH
32262: LD_INT 2
32264: PUSH
32265: LD_INT 2
32267: PUSH
32268: EMPTY
32269: LIST
32270: LIST
32271: PUSH
32272: LD_INT 4
32274: PUSH
32275: LD_INT 2
32277: PUSH
32278: EMPTY
32279: LIST
32280: LIST
32281: PUSH
32282: LD_INT 2
32284: PUSH
32285: LD_INT 4
32287: PUSH
32288: EMPTY
32289: LIST
32290: LIST
32291: PUSH
32292: LD_INT 0
32294: PUSH
32295: LD_INT 4
32297: PUSH
32298: EMPTY
32299: LIST
32300: LIST
32301: PUSH
32302: LD_INT 0
32304: PUSH
32305: LD_INT 3
32307: PUSH
32308: EMPTY
32309: LIST
32310: LIST
32311: PUSH
32312: LD_INT 1
32314: PUSH
32315: LD_INT 4
32317: PUSH
32318: EMPTY
32319: LIST
32320: LIST
32321: PUSH
32322: LD_INT 1
32324: PUSH
32325: LD_INT 5
32327: PUSH
32328: EMPTY
32329: LIST
32330: LIST
32331: PUSH
32332: LD_INT 0
32334: PUSH
32335: LD_INT 5
32337: PUSH
32338: EMPTY
32339: LIST
32340: LIST
32341: PUSH
32342: LD_INT 1
32344: NEG
32345: PUSH
32346: LD_INT 4
32348: PUSH
32349: EMPTY
32350: LIST
32351: LIST
32352: PUSH
32353: LD_INT 1
32355: NEG
32356: PUSH
32357: LD_INT 3
32359: PUSH
32360: EMPTY
32361: LIST
32362: LIST
32363: PUSH
32364: LD_INT 2
32366: PUSH
32367: LD_INT 5
32369: PUSH
32370: EMPTY
32371: LIST
32372: LIST
32373: PUSH
32374: LD_INT 2
32376: NEG
32377: PUSH
32378: LD_INT 3
32380: PUSH
32381: EMPTY
32382: LIST
32383: LIST
32384: PUSH
32385: LD_INT 3
32387: NEG
32388: PUSH
32389: LD_INT 0
32391: PUSH
32392: EMPTY
32393: LIST
32394: LIST
32395: PUSH
32396: LD_INT 3
32398: NEG
32399: PUSH
32400: LD_INT 1
32402: NEG
32403: PUSH
32404: EMPTY
32405: LIST
32406: LIST
32407: PUSH
32408: LD_INT 2
32410: NEG
32411: PUSH
32412: LD_INT 0
32414: PUSH
32415: EMPTY
32416: LIST
32417: LIST
32418: PUSH
32419: LD_INT 2
32421: NEG
32422: PUSH
32423: LD_INT 1
32425: PUSH
32426: EMPTY
32427: LIST
32428: LIST
32429: PUSH
32430: LD_INT 3
32432: NEG
32433: PUSH
32434: LD_INT 1
32436: PUSH
32437: EMPTY
32438: LIST
32439: LIST
32440: PUSH
32441: LD_INT 4
32443: NEG
32444: PUSH
32445: LD_INT 0
32447: PUSH
32448: EMPTY
32449: LIST
32450: LIST
32451: PUSH
32452: LD_INT 4
32454: NEG
32455: PUSH
32456: LD_INT 1
32458: NEG
32459: PUSH
32460: EMPTY
32461: LIST
32462: LIST
32463: PUSH
32464: LD_INT 4
32466: NEG
32467: PUSH
32468: LD_INT 2
32470: NEG
32471: PUSH
32472: EMPTY
32473: LIST
32474: LIST
32475: PUSH
32476: LD_INT 2
32478: NEG
32479: PUSH
32480: LD_INT 2
32482: PUSH
32483: EMPTY
32484: LIST
32485: LIST
32486: PUSH
32487: LD_INT 4
32489: NEG
32490: PUSH
32491: LD_INT 4
32493: NEG
32494: PUSH
32495: EMPTY
32496: LIST
32497: LIST
32498: PUSH
32499: LD_INT 4
32501: NEG
32502: PUSH
32503: LD_INT 5
32505: NEG
32506: PUSH
32507: EMPTY
32508: LIST
32509: LIST
32510: PUSH
32511: LD_INT 3
32513: NEG
32514: PUSH
32515: LD_INT 4
32517: NEG
32518: PUSH
32519: EMPTY
32520: LIST
32521: LIST
32522: PUSH
32523: LD_INT 3
32525: NEG
32526: PUSH
32527: LD_INT 3
32529: NEG
32530: PUSH
32531: EMPTY
32532: LIST
32533: LIST
32534: PUSH
32535: LD_INT 4
32537: NEG
32538: PUSH
32539: LD_INT 3
32541: NEG
32542: PUSH
32543: EMPTY
32544: LIST
32545: LIST
32546: PUSH
32547: LD_INT 5
32549: NEG
32550: PUSH
32551: LD_INT 4
32553: NEG
32554: PUSH
32555: EMPTY
32556: LIST
32557: LIST
32558: PUSH
32559: LD_INT 5
32561: NEG
32562: PUSH
32563: LD_INT 5
32565: NEG
32566: PUSH
32567: EMPTY
32568: LIST
32569: LIST
32570: PUSH
32571: LD_INT 3
32573: NEG
32574: PUSH
32575: LD_INT 5
32577: NEG
32578: PUSH
32579: EMPTY
32580: LIST
32581: LIST
32582: PUSH
32583: LD_INT 5
32585: NEG
32586: PUSH
32587: LD_INT 3
32589: NEG
32590: PUSH
32591: EMPTY
32592: LIST
32593: LIST
32594: PUSH
32595: EMPTY
32596: LIST
32597: LIST
32598: LIST
32599: LIST
32600: LIST
32601: LIST
32602: LIST
32603: LIST
32604: LIST
32605: LIST
32606: LIST
32607: LIST
32608: LIST
32609: LIST
32610: LIST
32611: LIST
32612: LIST
32613: LIST
32614: LIST
32615: LIST
32616: LIST
32617: LIST
32618: LIST
32619: LIST
32620: LIST
32621: LIST
32622: LIST
32623: LIST
32624: LIST
32625: LIST
32626: LIST
32627: LIST
32628: LIST
32629: LIST
32630: LIST
32631: LIST
32632: LIST
32633: LIST
32634: LIST
32635: LIST
32636: LIST
32637: LIST
32638: LIST
32639: LIST
32640: LIST
32641: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
32642: LD_ADDR_VAR 0 30
32646: PUSH
32647: LD_INT 4
32649: PUSH
32650: LD_INT 4
32652: PUSH
32653: EMPTY
32654: LIST
32655: LIST
32656: PUSH
32657: LD_INT 4
32659: PUSH
32660: LD_INT 3
32662: PUSH
32663: EMPTY
32664: LIST
32665: LIST
32666: PUSH
32667: LD_INT 5
32669: PUSH
32670: LD_INT 4
32672: PUSH
32673: EMPTY
32674: LIST
32675: LIST
32676: PUSH
32677: LD_INT 5
32679: PUSH
32680: LD_INT 5
32682: PUSH
32683: EMPTY
32684: LIST
32685: LIST
32686: PUSH
32687: LD_INT 4
32689: PUSH
32690: LD_INT 5
32692: PUSH
32693: EMPTY
32694: LIST
32695: LIST
32696: PUSH
32697: LD_INT 3
32699: PUSH
32700: LD_INT 4
32702: PUSH
32703: EMPTY
32704: LIST
32705: LIST
32706: PUSH
32707: LD_INT 3
32709: PUSH
32710: LD_INT 3
32712: PUSH
32713: EMPTY
32714: LIST
32715: LIST
32716: PUSH
32717: LD_INT 5
32719: PUSH
32720: LD_INT 3
32722: PUSH
32723: EMPTY
32724: LIST
32725: LIST
32726: PUSH
32727: LD_INT 3
32729: PUSH
32730: LD_INT 5
32732: PUSH
32733: EMPTY
32734: LIST
32735: LIST
32736: PUSH
32737: LD_INT 0
32739: PUSH
32740: LD_INT 3
32742: PUSH
32743: EMPTY
32744: LIST
32745: LIST
32746: PUSH
32747: LD_INT 0
32749: PUSH
32750: LD_INT 2
32752: PUSH
32753: EMPTY
32754: LIST
32755: LIST
32756: PUSH
32757: LD_INT 1
32759: PUSH
32760: LD_INT 3
32762: PUSH
32763: EMPTY
32764: LIST
32765: LIST
32766: PUSH
32767: LD_INT 1
32769: PUSH
32770: LD_INT 4
32772: PUSH
32773: EMPTY
32774: LIST
32775: LIST
32776: PUSH
32777: LD_INT 0
32779: PUSH
32780: LD_INT 4
32782: PUSH
32783: EMPTY
32784: LIST
32785: LIST
32786: PUSH
32787: LD_INT 1
32789: NEG
32790: PUSH
32791: LD_INT 3
32793: PUSH
32794: EMPTY
32795: LIST
32796: LIST
32797: PUSH
32798: LD_INT 1
32800: NEG
32801: PUSH
32802: LD_INT 2
32804: PUSH
32805: EMPTY
32806: LIST
32807: LIST
32808: PUSH
32809: LD_INT 2
32811: PUSH
32812: LD_INT 4
32814: PUSH
32815: EMPTY
32816: LIST
32817: LIST
32818: PUSH
32819: LD_INT 2
32821: NEG
32822: PUSH
32823: LD_INT 2
32825: PUSH
32826: EMPTY
32827: LIST
32828: LIST
32829: PUSH
32830: LD_INT 4
32832: NEG
32833: PUSH
32834: LD_INT 0
32836: PUSH
32837: EMPTY
32838: LIST
32839: LIST
32840: PUSH
32841: LD_INT 4
32843: NEG
32844: PUSH
32845: LD_INT 1
32847: NEG
32848: PUSH
32849: EMPTY
32850: LIST
32851: LIST
32852: PUSH
32853: LD_INT 3
32855: NEG
32856: PUSH
32857: LD_INT 0
32859: PUSH
32860: EMPTY
32861: LIST
32862: LIST
32863: PUSH
32864: LD_INT 3
32866: NEG
32867: PUSH
32868: LD_INT 1
32870: PUSH
32871: EMPTY
32872: LIST
32873: LIST
32874: PUSH
32875: LD_INT 4
32877: NEG
32878: PUSH
32879: LD_INT 1
32881: PUSH
32882: EMPTY
32883: LIST
32884: LIST
32885: PUSH
32886: LD_INT 5
32888: NEG
32889: PUSH
32890: LD_INT 0
32892: PUSH
32893: EMPTY
32894: LIST
32895: LIST
32896: PUSH
32897: LD_INT 5
32899: NEG
32900: PUSH
32901: LD_INT 1
32903: NEG
32904: PUSH
32905: EMPTY
32906: LIST
32907: LIST
32908: PUSH
32909: LD_INT 5
32911: NEG
32912: PUSH
32913: LD_INT 2
32915: NEG
32916: PUSH
32917: EMPTY
32918: LIST
32919: LIST
32920: PUSH
32921: LD_INT 3
32923: NEG
32924: PUSH
32925: LD_INT 2
32927: PUSH
32928: EMPTY
32929: LIST
32930: LIST
32931: PUSH
32932: LD_INT 3
32934: NEG
32935: PUSH
32936: LD_INT 3
32938: NEG
32939: PUSH
32940: EMPTY
32941: LIST
32942: LIST
32943: PUSH
32944: LD_INT 3
32946: NEG
32947: PUSH
32948: LD_INT 4
32950: NEG
32951: PUSH
32952: EMPTY
32953: LIST
32954: LIST
32955: PUSH
32956: LD_INT 2
32958: NEG
32959: PUSH
32960: LD_INT 3
32962: NEG
32963: PUSH
32964: EMPTY
32965: LIST
32966: LIST
32967: PUSH
32968: LD_INT 2
32970: NEG
32971: PUSH
32972: LD_INT 2
32974: NEG
32975: PUSH
32976: EMPTY
32977: LIST
32978: LIST
32979: PUSH
32980: LD_INT 3
32982: NEG
32983: PUSH
32984: LD_INT 2
32986: NEG
32987: PUSH
32988: EMPTY
32989: LIST
32990: LIST
32991: PUSH
32992: LD_INT 4
32994: NEG
32995: PUSH
32996: LD_INT 3
32998: NEG
32999: PUSH
33000: EMPTY
33001: LIST
33002: LIST
33003: PUSH
33004: LD_INT 4
33006: NEG
33007: PUSH
33008: LD_INT 4
33010: NEG
33011: PUSH
33012: EMPTY
33013: LIST
33014: LIST
33015: PUSH
33016: LD_INT 2
33018: NEG
33019: PUSH
33020: LD_INT 4
33022: NEG
33023: PUSH
33024: EMPTY
33025: LIST
33026: LIST
33027: PUSH
33028: LD_INT 4
33030: NEG
33031: PUSH
33032: LD_INT 2
33034: NEG
33035: PUSH
33036: EMPTY
33037: LIST
33038: LIST
33039: PUSH
33040: LD_INT 0
33042: PUSH
33043: LD_INT 4
33045: NEG
33046: PUSH
33047: EMPTY
33048: LIST
33049: LIST
33050: PUSH
33051: LD_INT 0
33053: PUSH
33054: LD_INT 5
33056: NEG
33057: PUSH
33058: EMPTY
33059: LIST
33060: LIST
33061: PUSH
33062: LD_INT 1
33064: PUSH
33065: LD_INT 4
33067: NEG
33068: PUSH
33069: EMPTY
33070: LIST
33071: LIST
33072: PUSH
33073: LD_INT 1
33075: PUSH
33076: LD_INT 3
33078: NEG
33079: PUSH
33080: EMPTY
33081: LIST
33082: LIST
33083: PUSH
33084: LD_INT 0
33086: PUSH
33087: LD_INT 3
33089: NEG
33090: PUSH
33091: EMPTY
33092: LIST
33093: LIST
33094: PUSH
33095: LD_INT 1
33097: NEG
33098: PUSH
33099: LD_INT 4
33101: NEG
33102: PUSH
33103: EMPTY
33104: LIST
33105: LIST
33106: PUSH
33107: LD_INT 1
33109: NEG
33110: PUSH
33111: LD_INT 5
33113: NEG
33114: PUSH
33115: EMPTY
33116: LIST
33117: LIST
33118: PUSH
33119: LD_INT 2
33121: PUSH
33122: LD_INT 3
33124: NEG
33125: PUSH
33126: EMPTY
33127: LIST
33128: LIST
33129: PUSH
33130: LD_INT 2
33132: NEG
33133: PUSH
33134: LD_INT 5
33136: NEG
33137: PUSH
33138: EMPTY
33139: LIST
33140: LIST
33141: PUSH
33142: EMPTY
33143: LIST
33144: LIST
33145: LIST
33146: LIST
33147: LIST
33148: LIST
33149: LIST
33150: LIST
33151: LIST
33152: LIST
33153: LIST
33154: LIST
33155: LIST
33156: LIST
33157: LIST
33158: LIST
33159: LIST
33160: LIST
33161: LIST
33162: LIST
33163: LIST
33164: LIST
33165: LIST
33166: LIST
33167: LIST
33168: LIST
33169: LIST
33170: LIST
33171: LIST
33172: LIST
33173: LIST
33174: LIST
33175: LIST
33176: LIST
33177: LIST
33178: LIST
33179: LIST
33180: LIST
33181: LIST
33182: LIST
33183: LIST
33184: LIST
33185: LIST
33186: LIST
33187: LIST
33188: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
33189: LD_ADDR_VAR 0 31
33193: PUSH
33194: LD_INT 0
33196: PUSH
33197: LD_INT 4
33199: PUSH
33200: EMPTY
33201: LIST
33202: LIST
33203: PUSH
33204: LD_INT 0
33206: PUSH
33207: LD_INT 3
33209: PUSH
33210: EMPTY
33211: LIST
33212: LIST
33213: PUSH
33214: LD_INT 1
33216: PUSH
33217: LD_INT 4
33219: PUSH
33220: EMPTY
33221: LIST
33222: LIST
33223: PUSH
33224: LD_INT 1
33226: PUSH
33227: LD_INT 5
33229: PUSH
33230: EMPTY
33231: LIST
33232: LIST
33233: PUSH
33234: LD_INT 0
33236: PUSH
33237: LD_INT 5
33239: PUSH
33240: EMPTY
33241: LIST
33242: LIST
33243: PUSH
33244: LD_INT 1
33246: NEG
33247: PUSH
33248: LD_INT 4
33250: PUSH
33251: EMPTY
33252: LIST
33253: LIST
33254: PUSH
33255: LD_INT 1
33257: NEG
33258: PUSH
33259: LD_INT 3
33261: PUSH
33262: EMPTY
33263: LIST
33264: LIST
33265: PUSH
33266: LD_INT 2
33268: PUSH
33269: LD_INT 5
33271: PUSH
33272: EMPTY
33273: LIST
33274: LIST
33275: PUSH
33276: LD_INT 2
33278: NEG
33279: PUSH
33280: LD_INT 3
33282: PUSH
33283: EMPTY
33284: LIST
33285: LIST
33286: PUSH
33287: LD_INT 3
33289: NEG
33290: PUSH
33291: LD_INT 0
33293: PUSH
33294: EMPTY
33295: LIST
33296: LIST
33297: PUSH
33298: LD_INT 3
33300: NEG
33301: PUSH
33302: LD_INT 1
33304: NEG
33305: PUSH
33306: EMPTY
33307: LIST
33308: LIST
33309: PUSH
33310: LD_INT 2
33312: NEG
33313: PUSH
33314: LD_INT 0
33316: PUSH
33317: EMPTY
33318: LIST
33319: LIST
33320: PUSH
33321: LD_INT 2
33323: NEG
33324: PUSH
33325: LD_INT 1
33327: PUSH
33328: EMPTY
33329: LIST
33330: LIST
33331: PUSH
33332: LD_INT 3
33334: NEG
33335: PUSH
33336: LD_INT 1
33338: PUSH
33339: EMPTY
33340: LIST
33341: LIST
33342: PUSH
33343: LD_INT 4
33345: NEG
33346: PUSH
33347: LD_INT 0
33349: PUSH
33350: EMPTY
33351: LIST
33352: LIST
33353: PUSH
33354: LD_INT 4
33356: NEG
33357: PUSH
33358: LD_INT 1
33360: NEG
33361: PUSH
33362: EMPTY
33363: LIST
33364: LIST
33365: PUSH
33366: LD_INT 4
33368: NEG
33369: PUSH
33370: LD_INT 2
33372: NEG
33373: PUSH
33374: EMPTY
33375: LIST
33376: LIST
33377: PUSH
33378: LD_INT 2
33380: NEG
33381: PUSH
33382: LD_INT 2
33384: PUSH
33385: EMPTY
33386: LIST
33387: LIST
33388: PUSH
33389: LD_INT 4
33391: NEG
33392: PUSH
33393: LD_INT 4
33395: NEG
33396: PUSH
33397: EMPTY
33398: LIST
33399: LIST
33400: PUSH
33401: LD_INT 4
33403: NEG
33404: PUSH
33405: LD_INT 5
33407: NEG
33408: PUSH
33409: EMPTY
33410: LIST
33411: LIST
33412: PUSH
33413: LD_INT 3
33415: NEG
33416: PUSH
33417: LD_INT 4
33419: NEG
33420: PUSH
33421: EMPTY
33422: LIST
33423: LIST
33424: PUSH
33425: LD_INT 3
33427: NEG
33428: PUSH
33429: LD_INT 3
33431: NEG
33432: PUSH
33433: EMPTY
33434: LIST
33435: LIST
33436: PUSH
33437: LD_INT 4
33439: NEG
33440: PUSH
33441: LD_INT 3
33443: NEG
33444: PUSH
33445: EMPTY
33446: LIST
33447: LIST
33448: PUSH
33449: LD_INT 5
33451: NEG
33452: PUSH
33453: LD_INT 4
33455: NEG
33456: PUSH
33457: EMPTY
33458: LIST
33459: LIST
33460: PUSH
33461: LD_INT 5
33463: NEG
33464: PUSH
33465: LD_INT 5
33467: NEG
33468: PUSH
33469: EMPTY
33470: LIST
33471: LIST
33472: PUSH
33473: LD_INT 3
33475: NEG
33476: PUSH
33477: LD_INT 5
33479: NEG
33480: PUSH
33481: EMPTY
33482: LIST
33483: LIST
33484: PUSH
33485: LD_INT 5
33487: NEG
33488: PUSH
33489: LD_INT 3
33491: NEG
33492: PUSH
33493: EMPTY
33494: LIST
33495: LIST
33496: PUSH
33497: LD_INT 0
33499: PUSH
33500: LD_INT 3
33502: NEG
33503: PUSH
33504: EMPTY
33505: LIST
33506: LIST
33507: PUSH
33508: LD_INT 0
33510: PUSH
33511: LD_INT 4
33513: NEG
33514: PUSH
33515: EMPTY
33516: LIST
33517: LIST
33518: PUSH
33519: LD_INT 1
33521: PUSH
33522: LD_INT 3
33524: NEG
33525: PUSH
33526: EMPTY
33527: LIST
33528: LIST
33529: PUSH
33530: LD_INT 1
33532: PUSH
33533: LD_INT 2
33535: NEG
33536: PUSH
33537: EMPTY
33538: LIST
33539: LIST
33540: PUSH
33541: LD_INT 0
33543: PUSH
33544: LD_INT 2
33546: NEG
33547: PUSH
33548: EMPTY
33549: LIST
33550: LIST
33551: PUSH
33552: LD_INT 1
33554: NEG
33555: PUSH
33556: LD_INT 3
33558: NEG
33559: PUSH
33560: EMPTY
33561: LIST
33562: LIST
33563: PUSH
33564: LD_INT 1
33566: NEG
33567: PUSH
33568: LD_INT 4
33570: NEG
33571: PUSH
33572: EMPTY
33573: LIST
33574: LIST
33575: PUSH
33576: LD_INT 2
33578: PUSH
33579: LD_INT 2
33581: NEG
33582: PUSH
33583: EMPTY
33584: LIST
33585: LIST
33586: PUSH
33587: LD_INT 2
33589: NEG
33590: PUSH
33591: LD_INT 4
33593: NEG
33594: PUSH
33595: EMPTY
33596: LIST
33597: LIST
33598: PUSH
33599: LD_INT 4
33601: PUSH
33602: LD_INT 0
33604: PUSH
33605: EMPTY
33606: LIST
33607: LIST
33608: PUSH
33609: LD_INT 4
33611: PUSH
33612: LD_INT 1
33614: NEG
33615: PUSH
33616: EMPTY
33617: LIST
33618: LIST
33619: PUSH
33620: LD_INT 5
33622: PUSH
33623: LD_INT 0
33625: PUSH
33626: EMPTY
33627: LIST
33628: LIST
33629: PUSH
33630: LD_INT 5
33632: PUSH
33633: LD_INT 1
33635: PUSH
33636: EMPTY
33637: LIST
33638: LIST
33639: PUSH
33640: LD_INT 4
33642: PUSH
33643: LD_INT 1
33645: PUSH
33646: EMPTY
33647: LIST
33648: LIST
33649: PUSH
33650: LD_INT 3
33652: PUSH
33653: LD_INT 0
33655: PUSH
33656: EMPTY
33657: LIST
33658: LIST
33659: PUSH
33660: LD_INT 3
33662: PUSH
33663: LD_INT 1
33665: NEG
33666: PUSH
33667: EMPTY
33668: LIST
33669: LIST
33670: PUSH
33671: LD_INT 3
33673: PUSH
33674: LD_INT 2
33676: NEG
33677: PUSH
33678: EMPTY
33679: LIST
33680: LIST
33681: PUSH
33682: LD_INT 5
33684: PUSH
33685: LD_INT 2
33687: PUSH
33688: EMPTY
33689: LIST
33690: LIST
33691: PUSH
33692: EMPTY
33693: LIST
33694: LIST
33695: LIST
33696: LIST
33697: LIST
33698: LIST
33699: LIST
33700: LIST
33701: LIST
33702: LIST
33703: LIST
33704: LIST
33705: LIST
33706: LIST
33707: LIST
33708: LIST
33709: LIST
33710: LIST
33711: LIST
33712: LIST
33713: LIST
33714: LIST
33715: LIST
33716: LIST
33717: LIST
33718: LIST
33719: LIST
33720: LIST
33721: LIST
33722: LIST
33723: LIST
33724: LIST
33725: LIST
33726: LIST
33727: LIST
33728: LIST
33729: LIST
33730: LIST
33731: LIST
33732: LIST
33733: LIST
33734: LIST
33735: LIST
33736: LIST
33737: LIST
33738: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
33739: LD_ADDR_VAR 0 32
33743: PUSH
33744: LD_INT 4
33746: NEG
33747: PUSH
33748: LD_INT 0
33750: PUSH
33751: EMPTY
33752: LIST
33753: LIST
33754: PUSH
33755: LD_INT 4
33757: NEG
33758: PUSH
33759: LD_INT 1
33761: NEG
33762: PUSH
33763: EMPTY
33764: LIST
33765: LIST
33766: PUSH
33767: LD_INT 3
33769: NEG
33770: PUSH
33771: LD_INT 0
33773: PUSH
33774: EMPTY
33775: LIST
33776: LIST
33777: PUSH
33778: LD_INT 3
33780: NEG
33781: PUSH
33782: LD_INT 1
33784: PUSH
33785: EMPTY
33786: LIST
33787: LIST
33788: PUSH
33789: LD_INT 4
33791: NEG
33792: PUSH
33793: LD_INT 1
33795: PUSH
33796: EMPTY
33797: LIST
33798: LIST
33799: PUSH
33800: LD_INT 5
33802: NEG
33803: PUSH
33804: LD_INT 0
33806: PUSH
33807: EMPTY
33808: LIST
33809: LIST
33810: PUSH
33811: LD_INT 5
33813: NEG
33814: PUSH
33815: LD_INT 1
33817: NEG
33818: PUSH
33819: EMPTY
33820: LIST
33821: LIST
33822: PUSH
33823: LD_INT 5
33825: NEG
33826: PUSH
33827: LD_INT 2
33829: NEG
33830: PUSH
33831: EMPTY
33832: LIST
33833: LIST
33834: PUSH
33835: LD_INT 3
33837: NEG
33838: PUSH
33839: LD_INT 2
33841: PUSH
33842: EMPTY
33843: LIST
33844: LIST
33845: PUSH
33846: LD_INT 3
33848: NEG
33849: PUSH
33850: LD_INT 3
33852: NEG
33853: PUSH
33854: EMPTY
33855: LIST
33856: LIST
33857: PUSH
33858: LD_INT 3
33860: NEG
33861: PUSH
33862: LD_INT 4
33864: NEG
33865: PUSH
33866: EMPTY
33867: LIST
33868: LIST
33869: PUSH
33870: LD_INT 2
33872: NEG
33873: PUSH
33874: LD_INT 3
33876: NEG
33877: PUSH
33878: EMPTY
33879: LIST
33880: LIST
33881: PUSH
33882: LD_INT 2
33884: NEG
33885: PUSH
33886: LD_INT 2
33888: NEG
33889: PUSH
33890: EMPTY
33891: LIST
33892: LIST
33893: PUSH
33894: LD_INT 3
33896: NEG
33897: PUSH
33898: LD_INT 2
33900: NEG
33901: PUSH
33902: EMPTY
33903: LIST
33904: LIST
33905: PUSH
33906: LD_INT 4
33908: NEG
33909: PUSH
33910: LD_INT 3
33912: NEG
33913: PUSH
33914: EMPTY
33915: LIST
33916: LIST
33917: PUSH
33918: LD_INT 4
33920: NEG
33921: PUSH
33922: LD_INT 4
33924: NEG
33925: PUSH
33926: EMPTY
33927: LIST
33928: LIST
33929: PUSH
33930: LD_INT 2
33932: NEG
33933: PUSH
33934: LD_INT 4
33936: NEG
33937: PUSH
33938: EMPTY
33939: LIST
33940: LIST
33941: PUSH
33942: LD_INT 4
33944: NEG
33945: PUSH
33946: LD_INT 2
33948: NEG
33949: PUSH
33950: EMPTY
33951: LIST
33952: LIST
33953: PUSH
33954: LD_INT 0
33956: PUSH
33957: LD_INT 4
33959: NEG
33960: PUSH
33961: EMPTY
33962: LIST
33963: LIST
33964: PUSH
33965: LD_INT 0
33967: PUSH
33968: LD_INT 5
33970: NEG
33971: PUSH
33972: EMPTY
33973: LIST
33974: LIST
33975: PUSH
33976: LD_INT 1
33978: PUSH
33979: LD_INT 4
33981: NEG
33982: PUSH
33983: EMPTY
33984: LIST
33985: LIST
33986: PUSH
33987: LD_INT 1
33989: PUSH
33990: LD_INT 3
33992: NEG
33993: PUSH
33994: EMPTY
33995: LIST
33996: LIST
33997: PUSH
33998: LD_INT 0
34000: PUSH
34001: LD_INT 3
34003: NEG
34004: PUSH
34005: EMPTY
34006: LIST
34007: LIST
34008: PUSH
34009: LD_INT 1
34011: NEG
34012: PUSH
34013: LD_INT 4
34015: NEG
34016: PUSH
34017: EMPTY
34018: LIST
34019: LIST
34020: PUSH
34021: LD_INT 1
34023: NEG
34024: PUSH
34025: LD_INT 5
34027: NEG
34028: PUSH
34029: EMPTY
34030: LIST
34031: LIST
34032: PUSH
34033: LD_INT 2
34035: PUSH
34036: LD_INT 3
34038: NEG
34039: PUSH
34040: EMPTY
34041: LIST
34042: LIST
34043: PUSH
34044: LD_INT 2
34046: NEG
34047: PUSH
34048: LD_INT 5
34050: NEG
34051: PUSH
34052: EMPTY
34053: LIST
34054: LIST
34055: PUSH
34056: LD_INT 3
34058: PUSH
34059: LD_INT 0
34061: PUSH
34062: EMPTY
34063: LIST
34064: LIST
34065: PUSH
34066: LD_INT 3
34068: PUSH
34069: LD_INT 1
34071: NEG
34072: PUSH
34073: EMPTY
34074: LIST
34075: LIST
34076: PUSH
34077: LD_INT 4
34079: PUSH
34080: LD_INT 0
34082: PUSH
34083: EMPTY
34084: LIST
34085: LIST
34086: PUSH
34087: LD_INT 4
34089: PUSH
34090: LD_INT 1
34092: PUSH
34093: EMPTY
34094: LIST
34095: LIST
34096: PUSH
34097: LD_INT 3
34099: PUSH
34100: LD_INT 1
34102: PUSH
34103: EMPTY
34104: LIST
34105: LIST
34106: PUSH
34107: LD_INT 2
34109: PUSH
34110: LD_INT 0
34112: PUSH
34113: EMPTY
34114: LIST
34115: LIST
34116: PUSH
34117: LD_INT 2
34119: PUSH
34120: LD_INT 1
34122: NEG
34123: PUSH
34124: EMPTY
34125: LIST
34126: LIST
34127: PUSH
34128: LD_INT 2
34130: PUSH
34131: LD_INT 2
34133: NEG
34134: PUSH
34135: EMPTY
34136: LIST
34137: LIST
34138: PUSH
34139: LD_INT 4
34141: PUSH
34142: LD_INT 2
34144: PUSH
34145: EMPTY
34146: LIST
34147: LIST
34148: PUSH
34149: LD_INT 4
34151: PUSH
34152: LD_INT 4
34154: PUSH
34155: EMPTY
34156: LIST
34157: LIST
34158: PUSH
34159: LD_INT 4
34161: PUSH
34162: LD_INT 3
34164: PUSH
34165: EMPTY
34166: LIST
34167: LIST
34168: PUSH
34169: LD_INT 5
34171: PUSH
34172: LD_INT 4
34174: PUSH
34175: EMPTY
34176: LIST
34177: LIST
34178: PUSH
34179: LD_INT 5
34181: PUSH
34182: LD_INT 5
34184: PUSH
34185: EMPTY
34186: LIST
34187: LIST
34188: PUSH
34189: LD_INT 4
34191: PUSH
34192: LD_INT 5
34194: PUSH
34195: EMPTY
34196: LIST
34197: LIST
34198: PUSH
34199: LD_INT 3
34201: PUSH
34202: LD_INT 4
34204: PUSH
34205: EMPTY
34206: LIST
34207: LIST
34208: PUSH
34209: LD_INT 3
34211: PUSH
34212: LD_INT 3
34214: PUSH
34215: EMPTY
34216: LIST
34217: LIST
34218: PUSH
34219: LD_INT 5
34221: PUSH
34222: LD_INT 3
34224: PUSH
34225: EMPTY
34226: LIST
34227: LIST
34228: PUSH
34229: LD_INT 3
34231: PUSH
34232: LD_INT 5
34234: PUSH
34235: EMPTY
34236: LIST
34237: LIST
34238: PUSH
34239: EMPTY
34240: LIST
34241: LIST
34242: LIST
34243: LIST
34244: LIST
34245: LIST
34246: LIST
34247: LIST
34248: LIST
34249: LIST
34250: LIST
34251: LIST
34252: LIST
34253: LIST
34254: LIST
34255: LIST
34256: LIST
34257: LIST
34258: LIST
34259: LIST
34260: LIST
34261: LIST
34262: LIST
34263: LIST
34264: LIST
34265: LIST
34266: LIST
34267: LIST
34268: LIST
34269: LIST
34270: LIST
34271: LIST
34272: LIST
34273: LIST
34274: LIST
34275: LIST
34276: LIST
34277: LIST
34278: LIST
34279: LIST
34280: LIST
34281: LIST
34282: LIST
34283: LIST
34284: LIST
34285: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
34286: LD_ADDR_VAR 0 33
34290: PUSH
34291: LD_INT 4
34293: NEG
34294: PUSH
34295: LD_INT 4
34297: NEG
34298: PUSH
34299: EMPTY
34300: LIST
34301: LIST
34302: PUSH
34303: LD_INT 4
34305: NEG
34306: PUSH
34307: LD_INT 5
34309: NEG
34310: PUSH
34311: EMPTY
34312: LIST
34313: LIST
34314: PUSH
34315: LD_INT 3
34317: NEG
34318: PUSH
34319: LD_INT 4
34321: NEG
34322: PUSH
34323: EMPTY
34324: LIST
34325: LIST
34326: PUSH
34327: LD_INT 3
34329: NEG
34330: PUSH
34331: LD_INT 3
34333: NEG
34334: PUSH
34335: EMPTY
34336: LIST
34337: LIST
34338: PUSH
34339: LD_INT 4
34341: NEG
34342: PUSH
34343: LD_INT 3
34345: NEG
34346: PUSH
34347: EMPTY
34348: LIST
34349: LIST
34350: PUSH
34351: LD_INT 5
34353: NEG
34354: PUSH
34355: LD_INT 4
34357: NEG
34358: PUSH
34359: EMPTY
34360: LIST
34361: LIST
34362: PUSH
34363: LD_INT 5
34365: NEG
34366: PUSH
34367: LD_INT 5
34369: NEG
34370: PUSH
34371: EMPTY
34372: LIST
34373: LIST
34374: PUSH
34375: LD_INT 3
34377: NEG
34378: PUSH
34379: LD_INT 5
34381: NEG
34382: PUSH
34383: EMPTY
34384: LIST
34385: LIST
34386: PUSH
34387: LD_INT 5
34389: NEG
34390: PUSH
34391: LD_INT 3
34393: NEG
34394: PUSH
34395: EMPTY
34396: LIST
34397: LIST
34398: PUSH
34399: LD_INT 0
34401: PUSH
34402: LD_INT 3
34404: NEG
34405: PUSH
34406: EMPTY
34407: LIST
34408: LIST
34409: PUSH
34410: LD_INT 0
34412: PUSH
34413: LD_INT 4
34415: NEG
34416: PUSH
34417: EMPTY
34418: LIST
34419: LIST
34420: PUSH
34421: LD_INT 1
34423: PUSH
34424: LD_INT 3
34426: NEG
34427: PUSH
34428: EMPTY
34429: LIST
34430: LIST
34431: PUSH
34432: LD_INT 1
34434: PUSH
34435: LD_INT 2
34437: NEG
34438: PUSH
34439: EMPTY
34440: LIST
34441: LIST
34442: PUSH
34443: LD_INT 0
34445: PUSH
34446: LD_INT 2
34448: NEG
34449: PUSH
34450: EMPTY
34451: LIST
34452: LIST
34453: PUSH
34454: LD_INT 1
34456: NEG
34457: PUSH
34458: LD_INT 3
34460: NEG
34461: PUSH
34462: EMPTY
34463: LIST
34464: LIST
34465: PUSH
34466: LD_INT 1
34468: NEG
34469: PUSH
34470: LD_INT 4
34472: NEG
34473: PUSH
34474: EMPTY
34475: LIST
34476: LIST
34477: PUSH
34478: LD_INT 2
34480: PUSH
34481: LD_INT 2
34483: NEG
34484: PUSH
34485: EMPTY
34486: LIST
34487: LIST
34488: PUSH
34489: LD_INT 2
34491: NEG
34492: PUSH
34493: LD_INT 4
34495: NEG
34496: PUSH
34497: EMPTY
34498: LIST
34499: LIST
34500: PUSH
34501: LD_INT 4
34503: PUSH
34504: LD_INT 0
34506: PUSH
34507: EMPTY
34508: LIST
34509: LIST
34510: PUSH
34511: LD_INT 4
34513: PUSH
34514: LD_INT 1
34516: NEG
34517: PUSH
34518: EMPTY
34519: LIST
34520: LIST
34521: PUSH
34522: LD_INT 5
34524: PUSH
34525: LD_INT 0
34527: PUSH
34528: EMPTY
34529: LIST
34530: LIST
34531: PUSH
34532: LD_INT 5
34534: PUSH
34535: LD_INT 1
34537: PUSH
34538: EMPTY
34539: LIST
34540: LIST
34541: PUSH
34542: LD_INT 4
34544: PUSH
34545: LD_INT 1
34547: PUSH
34548: EMPTY
34549: LIST
34550: LIST
34551: PUSH
34552: LD_INT 3
34554: PUSH
34555: LD_INT 0
34557: PUSH
34558: EMPTY
34559: LIST
34560: LIST
34561: PUSH
34562: LD_INT 3
34564: PUSH
34565: LD_INT 1
34567: NEG
34568: PUSH
34569: EMPTY
34570: LIST
34571: LIST
34572: PUSH
34573: LD_INT 3
34575: PUSH
34576: LD_INT 2
34578: NEG
34579: PUSH
34580: EMPTY
34581: LIST
34582: LIST
34583: PUSH
34584: LD_INT 5
34586: PUSH
34587: LD_INT 2
34589: PUSH
34590: EMPTY
34591: LIST
34592: LIST
34593: PUSH
34594: LD_INT 3
34596: PUSH
34597: LD_INT 3
34599: PUSH
34600: EMPTY
34601: LIST
34602: LIST
34603: PUSH
34604: LD_INT 3
34606: PUSH
34607: LD_INT 2
34609: PUSH
34610: EMPTY
34611: LIST
34612: LIST
34613: PUSH
34614: LD_INT 4
34616: PUSH
34617: LD_INT 3
34619: PUSH
34620: EMPTY
34621: LIST
34622: LIST
34623: PUSH
34624: LD_INT 4
34626: PUSH
34627: LD_INT 4
34629: PUSH
34630: EMPTY
34631: LIST
34632: LIST
34633: PUSH
34634: LD_INT 3
34636: PUSH
34637: LD_INT 4
34639: PUSH
34640: EMPTY
34641: LIST
34642: LIST
34643: PUSH
34644: LD_INT 2
34646: PUSH
34647: LD_INT 3
34649: PUSH
34650: EMPTY
34651: LIST
34652: LIST
34653: PUSH
34654: LD_INT 2
34656: PUSH
34657: LD_INT 2
34659: PUSH
34660: EMPTY
34661: LIST
34662: LIST
34663: PUSH
34664: LD_INT 4
34666: PUSH
34667: LD_INT 2
34669: PUSH
34670: EMPTY
34671: LIST
34672: LIST
34673: PUSH
34674: LD_INT 2
34676: PUSH
34677: LD_INT 4
34679: PUSH
34680: EMPTY
34681: LIST
34682: LIST
34683: PUSH
34684: LD_INT 0
34686: PUSH
34687: LD_INT 4
34689: PUSH
34690: EMPTY
34691: LIST
34692: LIST
34693: PUSH
34694: LD_INT 0
34696: PUSH
34697: LD_INT 3
34699: PUSH
34700: EMPTY
34701: LIST
34702: LIST
34703: PUSH
34704: LD_INT 1
34706: PUSH
34707: LD_INT 4
34709: PUSH
34710: EMPTY
34711: LIST
34712: LIST
34713: PUSH
34714: LD_INT 1
34716: PUSH
34717: LD_INT 5
34719: PUSH
34720: EMPTY
34721: LIST
34722: LIST
34723: PUSH
34724: LD_INT 0
34726: PUSH
34727: LD_INT 5
34729: PUSH
34730: EMPTY
34731: LIST
34732: LIST
34733: PUSH
34734: LD_INT 1
34736: NEG
34737: PUSH
34738: LD_INT 4
34740: PUSH
34741: EMPTY
34742: LIST
34743: LIST
34744: PUSH
34745: LD_INT 1
34747: NEG
34748: PUSH
34749: LD_INT 3
34751: PUSH
34752: EMPTY
34753: LIST
34754: LIST
34755: PUSH
34756: LD_INT 2
34758: PUSH
34759: LD_INT 5
34761: PUSH
34762: EMPTY
34763: LIST
34764: LIST
34765: PUSH
34766: LD_INT 2
34768: NEG
34769: PUSH
34770: LD_INT 3
34772: PUSH
34773: EMPTY
34774: LIST
34775: LIST
34776: PUSH
34777: EMPTY
34778: LIST
34779: LIST
34780: LIST
34781: LIST
34782: LIST
34783: LIST
34784: LIST
34785: LIST
34786: LIST
34787: LIST
34788: LIST
34789: LIST
34790: LIST
34791: LIST
34792: LIST
34793: LIST
34794: LIST
34795: LIST
34796: LIST
34797: LIST
34798: LIST
34799: LIST
34800: LIST
34801: LIST
34802: LIST
34803: LIST
34804: LIST
34805: LIST
34806: LIST
34807: LIST
34808: LIST
34809: LIST
34810: LIST
34811: LIST
34812: LIST
34813: LIST
34814: LIST
34815: LIST
34816: LIST
34817: LIST
34818: LIST
34819: LIST
34820: LIST
34821: LIST
34822: LIST
34823: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
34824: LD_ADDR_VAR 0 34
34828: PUSH
34829: LD_INT 0
34831: PUSH
34832: LD_INT 4
34834: NEG
34835: PUSH
34836: EMPTY
34837: LIST
34838: LIST
34839: PUSH
34840: LD_INT 0
34842: PUSH
34843: LD_INT 5
34845: NEG
34846: PUSH
34847: EMPTY
34848: LIST
34849: LIST
34850: PUSH
34851: LD_INT 1
34853: PUSH
34854: LD_INT 4
34856: NEG
34857: PUSH
34858: EMPTY
34859: LIST
34860: LIST
34861: PUSH
34862: LD_INT 1
34864: PUSH
34865: LD_INT 3
34867: NEG
34868: PUSH
34869: EMPTY
34870: LIST
34871: LIST
34872: PUSH
34873: LD_INT 0
34875: PUSH
34876: LD_INT 3
34878: NEG
34879: PUSH
34880: EMPTY
34881: LIST
34882: LIST
34883: PUSH
34884: LD_INT 1
34886: NEG
34887: PUSH
34888: LD_INT 4
34890: NEG
34891: PUSH
34892: EMPTY
34893: LIST
34894: LIST
34895: PUSH
34896: LD_INT 1
34898: NEG
34899: PUSH
34900: LD_INT 5
34902: NEG
34903: PUSH
34904: EMPTY
34905: LIST
34906: LIST
34907: PUSH
34908: LD_INT 2
34910: PUSH
34911: LD_INT 3
34913: NEG
34914: PUSH
34915: EMPTY
34916: LIST
34917: LIST
34918: PUSH
34919: LD_INT 2
34921: NEG
34922: PUSH
34923: LD_INT 5
34925: NEG
34926: PUSH
34927: EMPTY
34928: LIST
34929: LIST
34930: PUSH
34931: LD_INT 3
34933: PUSH
34934: LD_INT 0
34936: PUSH
34937: EMPTY
34938: LIST
34939: LIST
34940: PUSH
34941: LD_INT 3
34943: PUSH
34944: LD_INT 1
34946: NEG
34947: PUSH
34948: EMPTY
34949: LIST
34950: LIST
34951: PUSH
34952: LD_INT 4
34954: PUSH
34955: LD_INT 0
34957: PUSH
34958: EMPTY
34959: LIST
34960: LIST
34961: PUSH
34962: LD_INT 4
34964: PUSH
34965: LD_INT 1
34967: PUSH
34968: EMPTY
34969: LIST
34970: LIST
34971: PUSH
34972: LD_INT 3
34974: PUSH
34975: LD_INT 1
34977: PUSH
34978: EMPTY
34979: LIST
34980: LIST
34981: PUSH
34982: LD_INT 2
34984: PUSH
34985: LD_INT 0
34987: PUSH
34988: EMPTY
34989: LIST
34990: LIST
34991: PUSH
34992: LD_INT 2
34994: PUSH
34995: LD_INT 1
34997: NEG
34998: PUSH
34999: EMPTY
35000: LIST
35001: LIST
35002: PUSH
35003: LD_INT 2
35005: PUSH
35006: LD_INT 2
35008: NEG
35009: PUSH
35010: EMPTY
35011: LIST
35012: LIST
35013: PUSH
35014: LD_INT 4
35016: PUSH
35017: LD_INT 2
35019: PUSH
35020: EMPTY
35021: LIST
35022: LIST
35023: PUSH
35024: LD_INT 4
35026: PUSH
35027: LD_INT 4
35029: PUSH
35030: EMPTY
35031: LIST
35032: LIST
35033: PUSH
35034: LD_INT 4
35036: PUSH
35037: LD_INT 3
35039: PUSH
35040: EMPTY
35041: LIST
35042: LIST
35043: PUSH
35044: LD_INT 5
35046: PUSH
35047: LD_INT 4
35049: PUSH
35050: EMPTY
35051: LIST
35052: LIST
35053: PUSH
35054: LD_INT 5
35056: PUSH
35057: LD_INT 5
35059: PUSH
35060: EMPTY
35061: LIST
35062: LIST
35063: PUSH
35064: LD_INT 4
35066: PUSH
35067: LD_INT 5
35069: PUSH
35070: EMPTY
35071: LIST
35072: LIST
35073: PUSH
35074: LD_INT 3
35076: PUSH
35077: LD_INT 4
35079: PUSH
35080: EMPTY
35081: LIST
35082: LIST
35083: PUSH
35084: LD_INT 3
35086: PUSH
35087: LD_INT 3
35089: PUSH
35090: EMPTY
35091: LIST
35092: LIST
35093: PUSH
35094: LD_INT 5
35096: PUSH
35097: LD_INT 3
35099: PUSH
35100: EMPTY
35101: LIST
35102: LIST
35103: PUSH
35104: LD_INT 3
35106: PUSH
35107: LD_INT 5
35109: PUSH
35110: EMPTY
35111: LIST
35112: LIST
35113: PUSH
35114: LD_INT 0
35116: PUSH
35117: LD_INT 3
35119: PUSH
35120: EMPTY
35121: LIST
35122: LIST
35123: PUSH
35124: LD_INT 0
35126: PUSH
35127: LD_INT 2
35129: PUSH
35130: EMPTY
35131: LIST
35132: LIST
35133: PUSH
35134: LD_INT 1
35136: PUSH
35137: LD_INT 3
35139: PUSH
35140: EMPTY
35141: LIST
35142: LIST
35143: PUSH
35144: LD_INT 1
35146: PUSH
35147: LD_INT 4
35149: PUSH
35150: EMPTY
35151: LIST
35152: LIST
35153: PUSH
35154: LD_INT 0
35156: PUSH
35157: LD_INT 4
35159: PUSH
35160: EMPTY
35161: LIST
35162: LIST
35163: PUSH
35164: LD_INT 1
35166: NEG
35167: PUSH
35168: LD_INT 3
35170: PUSH
35171: EMPTY
35172: LIST
35173: LIST
35174: PUSH
35175: LD_INT 1
35177: NEG
35178: PUSH
35179: LD_INT 2
35181: PUSH
35182: EMPTY
35183: LIST
35184: LIST
35185: PUSH
35186: LD_INT 2
35188: PUSH
35189: LD_INT 4
35191: PUSH
35192: EMPTY
35193: LIST
35194: LIST
35195: PUSH
35196: LD_INT 2
35198: NEG
35199: PUSH
35200: LD_INT 2
35202: PUSH
35203: EMPTY
35204: LIST
35205: LIST
35206: PUSH
35207: LD_INT 4
35209: NEG
35210: PUSH
35211: LD_INT 0
35213: PUSH
35214: EMPTY
35215: LIST
35216: LIST
35217: PUSH
35218: LD_INT 4
35220: NEG
35221: PUSH
35222: LD_INT 1
35224: NEG
35225: PUSH
35226: EMPTY
35227: LIST
35228: LIST
35229: PUSH
35230: LD_INT 3
35232: NEG
35233: PUSH
35234: LD_INT 0
35236: PUSH
35237: EMPTY
35238: LIST
35239: LIST
35240: PUSH
35241: LD_INT 3
35243: NEG
35244: PUSH
35245: LD_INT 1
35247: PUSH
35248: EMPTY
35249: LIST
35250: LIST
35251: PUSH
35252: LD_INT 4
35254: NEG
35255: PUSH
35256: LD_INT 1
35258: PUSH
35259: EMPTY
35260: LIST
35261: LIST
35262: PUSH
35263: LD_INT 5
35265: NEG
35266: PUSH
35267: LD_INT 0
35269: PUSH
35270: EMPTY
35271: LIST
35272: LIST
35273: PUSH
35274: LD_INT 5
35276: NEG
35277: PUSH
35278: LD_INT 1
35280: NEG
35281: PUSH
35282: EMPTY
35283: LIST
35284: LIST
35285: PUSH
35286: LD_INT 5
35288: NEG
35289: PUSH
35290: LD_INT 2
35292: NEG
35293: PUSH
35294: EMPTY
35295: LIST
35296: LIST
35297: PUSH
35298: LD_INT 3
35300: NEG
35301: PUSH
35302: LD_INT 2
35304: PUSH
35305: EMPTY
35306: LIST
35307: LIST
35308: PUSH
35309: EMPTY
35310: LIST
35311: LIST
35312: LIST
35313: LIST
35314: LIST
35315: LIST
35316: LIST
35317: LIST
35318: LIST
35319: LIST
35320: LIST
35321: LIST
35322: LIST
35323: LIST
35324: LIST
35325: LIST
35326: LIST
35327: LIST
35328: LIST
35329: LIST
35330: LIST
35331: LIST
35332: LIST
35333: LIST
35334: LIST
35335: LIST
35336: LIST
35337: LIST
35338: LIST
35339: LIST
35340: LIST
35341: LIST
35342: LIST
35343: LIST
35344: LIST
35345: LIST
35346: LIST
35347: LIST
35348: LIST
35349: LIST
35350: LIST
35351: LIST
35352: LIST
35353: LIST
35354: LIST
35355: ST_TO_ADDR
// end ; end ;
35356: GO 35359
35358: POP
// case btype of b_depot , b_warehouse :
35359: LD_VAR 0 1
35363: PUSH
35364: LD_INT 0
35366: DOUBLE
35367: EQUAL
35368: IFTRUE 35378
35370: LD_INT 1
35372: DOUBLE
35373: EQUAL
35374: IFTRUE 35378
35376: GO 35579
35378: POP
// case nation of nation_american :
35379: LD_VAR 0 5
35383: PUSH
35384: LD_INT 1
35386: DOUBLE
35387: EQUAL
35388: IFTRUE 35392
35390: GO 35448
35392: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
35393: LD_ADDR_VAR 0 9
35397: PUSH
35398: LD_VAR 0 11
35402: PUSH
35403: LD_VAR 0 12
35407: PUSH
35408: LD_VAR 0 13
35412: PUSH
35413: LD_VAR 0 14
35417: PUSH
35418: LD_VAR 0 15
35422: PUSH
35423: LD_VAR 0 16
35427: PUSH
35428: EMPTY
35429: LIST
35430: LIST
35431: LIST
35432: LIST
35433: LIST
35434: LIST
35435: PUSH
35436: LD_VAR 0 4
35440: PUSH
35441: LD_INT 1
35443: PLUS
35444: ARRAY
35445: ST_TO_ADDR
35446: GO 35577
35448: LD_INT 2
35450: DOUBLE
35451: EQUAL
35452: IFTRUE 35456
35454: GO 35512
35456: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
35457: LD_ADDR_VAR 0 9
35461: PUSH
35462: LD_VAR 0 17
35466: PUSH
35467: LD_VAR 0 18
35471: PUSH
35472: LD_VAR 0 19
35476: PUSH
35477: LD_VAR 0 20
35481: PUSH
35482: LD_VAR 0 21
35486: PUSH
35487: LD_VAR 0 22
35491: PUSH
35492: EMPTY
35493: LIST
35494: LIST
35495: LIST
35496: LIST
35497: LIST
35498: LIST
35499: PUSH
35500: LD_VAR 0 4
35504: PUSH
35505: LD_INT 1
35507: PLUS
35508: ARRAY
35509: ST_TO_ADDR
35510: GO 35577
35512: LD_INT 3
35514: DOUBLE
35515: EQUAL
35516: IFTRUE 35520
35518: GO 35576
35520: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
35521: LD_ADDR_VAR 0 9
35525: PUSH
35526: LD_VAR 0 23
35530: PUSH
35531: LD_VAR 0 24
35535: PUSH
35536: LD_VAR 0 25
35540: PUSH
35541: LD_VAR 0 26
35545: PUSH
35546: LD_VAR 0 27
35550: PUSH
35551: LD_VAR 0 28
35555: PUSH
35556: EMPTY
35557: LIST
35558: LIST
35559: LIST
35560: LIST
35561: LIST
35562: LIST
35563: PUSH
35564: LD_VAR 0 4
35568: PUSH
35569: LD_INT 1
35571: PLUS
35572: ARRAY
35573: ST_TO_ADDR
35574: GO 35577
35576: POP
35577: GO 36132
35579: LD_INT 2
35581: DOUBLE
35582: EQUAL
35583: IFTRUE 35593
35585: LD_INT 3
35587: DOUBLE
35588: EQUAL
35589: IFTRUE 35593
35591: GO 35649
35593: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
35594: LD_ADDR_VAR 0 9
35598: PUSH
35599: LD_VAR 0 29
35603: PUSH
35604: LD_VAR 0 30
35608: PUSH
35609: LD_VAR 0 31
35613: PUSH
35614: LD_VAR 0 32
35618: PUSH
35619: LD_VAR 0 33
35623: PUSH
35624: LD_VAR 0 34
35628: PUSH
35629: EMPTY
35630: LIST
35631: LIST
35632: LIST
35633: LIST
35634: LIST
35635: LIST
35636: PUSH
35637: LD_VAR 0 4
35641: PUSH
35642: LD_INT 1
35644: PLUS
35645: ARRAY
35646: ST_TO_ADDR
35647: GO 36132
35649: LD_INT 16
35651: DOUBLE
35652: EQUAL
35653: IFTRUE 35711
35655: LD_INT 17
35657: DOUBLE
35658: EQUAL
35659: IFTRUE 35711
35661: LD_INT 18
35663: DOUBLE
35664: EQUAL
35665: IFTRUE 35711
35667: LD_INT 19
35669: DOUBLE
35670: EQUAL
35671: IFTRUE 35711
35673: LD_INT 22
35675: DOUBLE
35676: EQUAL
35677: IFTRUE 35711
35679: LD_INT 20
35681: DOUBLE
35682: EQUAL
35683: IFTRUE 35711
35685: LD_INT 21
35687: DOUBLE
35688: EQUAL
35689: IFTRUE 35711
35691: LD_INT 23
35693: DOUBLE
35694: EQUAL
35695: IFTRUE 35711
35697: LD_INT 24
35699: DOUBLE
35700: EQUAL
35701: IFTRUE 35711
35703: LD_INT 25
35705: DOUBLE
35706: EQUAL
35707: IFTRUE 35711
35709: GO 35767
35711: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
35712: LD_ADDR_VAR 0 9
35716: PUSH
35717: LD_VAR 0 35
35721: PUSH
35722: LD_VAR 0 36
35726: PUSH
35727: LD_VAR 0 37
35731: PUSH
35732: LD_VAR 0 38
35736: PUSH
35737: LD_VAR 0 39
35741: PUSH
35742: LD_VAR 0 40
35746: PUSH
35747: EMPTY
35748: LIST
35749: LIST
35750: LIST
35751: LIST
35752: LIST
35753: LIST
35754: PUSH
35755: LD_VAR 0 4
35759: PUSH
35760: LD_INT 1
35762: PLUS
35763: ARRAY
35764: ST_TO_ADDR
35765: GO 36132
35767: LD_INT 6
35769: DOUBLE
35770: EQUAL
35771: IFTRUE 35823
35773: LD_INT 7
35775: DOUBLE
35776: EQUAL
35777: IFTRUE 35823
35779: LD_INT 8
35781: DOUBLE
35782: EQUAL
35783: IFTRUE 35823
35785: LD_INT 13
35787: DOUBLE
35788: EQUAL
35789: IFTRUE 35823
35791: LD_INT 12
35793: DOUBLE
35794: EQUAL
35795: IFTRUE 35823
35797: LD_INT 15
35799: DOUBLE
35800: EQUAL
35801: IFTRUE 35823
35803: LD_INT 11
35805: DOUBLE
35806: EQUAL
35807: IFTRUE 35823
35809: LD_INT 14
35811: DOUBLE
35812: EQUAL
35813: IFTRUE 35823
35815: LD_INT 10
35817: DOUBLE
35818: EQUAL
35819: IFTRUE 35823
35821: GO 35879
35823: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
35824: LD_ADDR_VAR 0 9
35828: PUSH
35829: LD_VAR 0 41
35833: PUSH
35834: LD_VAR 0 42
35838: PUSH
35839: LD_VAR 0 43
35843: PUSH
35844: LD_VAR 0 44
35848: PUSH
35849: LD_VAR 0 45
35853: PUSH
35854: LD_VAR 0 46
35858: PUSH
35859: EMPTY
35860: LIST
35861: LIST
35862: LIST
35863: LIST
35864: LIST
35865: LIST
35866: PUSH
35867: LD_VAR 0 4
35871: PUSH
35872: LD_INT 1
35874: PLUS
35875: ARRAY
35876: ST_TO_ADDR
35877: GO 36132
35879: LD_INT 36
35881: DOUBLE
35882: EQUAL
35883: IFTRUE 35887
35885: GO 35943
35887: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
35888: LD_ADDR_VAR 0 9
35892: PUSH
35893: LD_VAR 0 47
35897: PUSH
35898: LD_VAR 0 48
35902: PUSH
35903: LD_VAR 0 49
35907: PUSH
35908: LD_VAR 0 50
35912: PUSH
35913: LD_VAR 0 51
35917: PUSH
35918: LD_VAR 0 52
35922: PUSH
35923: EMPTY
35924: LIST
35925: LIST
35926: LIST
35927: LIST
35928: LIST
35929: LIST
35930: PUSH
35931: LD_VAR 0 4
35935: PUSH
35936: LD_INT 1
35938: PLUS
35939: ARRAY
35940: ST_TO_ADDR
35941: GO 36132
35943: LD_INT 4
35945: DOUBLE
35946: EQUAL
35947: IFTRUE 35969
35949: LD_INT 5
35951: DOUBLE
35952: EQUAL
35953: IFTRUE 35969
35955: LD_INT 34
35957: DOUBLE
35958: EQUAL
35959: IFTRUE 35969
35961: LD_INT 37
35963: DOUBLE
35964: EQUAL
35965: IFTRUE 35969
35967: GO 36025
35969: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
35970: LD_ADDR_VAR 0 9
35974: PUSH
35975: LD_VAR 0 53
35979: PUSH
35980: LD_VAR 0 54
35984: PUSH
35985: LD_VAR 0 55
35989: PUSH
35990: LD_VAR 0 56
35994: PUSH
35995: LD_VAR 0 57
35999: PUSH
36000: LD_VAR 0 58
36004: PUSH
36005: EMPTY
36006: LIST
36007: LIST
36008: LIST
36009: LIST
36010: LIST
36011: LIST
36012: PUSH
36013: LD_VAR 0 4
36017: PUSH
36018: LD_INT 1
36020: PLUS
36021: ARRAY
36022: ST_TO_ADDR
36023: GO 36132
36025: LD_INT 31
36027: DOUBLE
36028: EQUAL
36029: IFTRUE 36075
36031: LD_INT 32
36033: DOUBLE
36034: EQUAL
36035: IFTRUE 36075
36037: LD_INT 33
36039: DOUBLE
36040: EQUAL
36041: IFTRUE 36075
36043: LD_INT 27
36045: DOUBLE
36046: EQUAL
36047: IFTRUE 36075
36049: LD_INT 26
36051: DOUBLE
36052: EQUAL
36053: IFTRUE 36075
36055: LD_INT 28
36057: DOUBLE
36058: EQUAL
36059: IFTRUE 36075
36061: LD_INT 29
36063: DOUBLE
36064: EQUAL
36065: IFTRUE 36075
36067: LD_INT 30
36069: DOUBLE
36070: EQUAL
36071: IFTRUE 36075
36073: GO 36131
36075: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
36076: LD_ADDR_VAR 0 9
36080: PUSH
36081: LD_VAR 0 59
36085: PUSH
36086: LD_VAR 0 60
36090: PUSH
36091: LD_VAR 0 61
36095: PUSH
36096: LD_VAR 0 62
36100: PUSH
36101: LD_VAR 0 63
36105: PUSH
36106: LD_VAR 0 64
36110: PUSH
36111: EMPTY
36112: LIST
36113: LIST
36114: LIST
36115: LIST
36116: LIST
36117: LIST
36118: PUSH
36119: LD_VAR 0 4
36123: PUSH
36124: LD_INT 1
36126: PLUS
36127: ARRAY
36128: ST_TO_ADDR
36129: GO 36132
36131: POP
// temp_list2 = [ ] ;
36132: LD_ADDR_VAR 0 10
36136: PUSH
36137: EMPTY
36138: ST_TO_ADDR
// for i in temp_list do
36139: LD_ADDR_VAR 0 8
36143: PUSH
36144: LD_VAR 0 9
36148: PUSH
36149: FOR_IN
36150: IFFALSE 36202
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
36152: LD_ADDR_VAR 0 10
36156: PUSH
36157: LD_VAR 0 10
36161: PUSH
36162: LD_VAR 0 8
36166: PUSH
36167: LD_INT 1
36169: ARRAY
36170: PUSH
36171: LD_VAR 0 2
36175: PLUS
36176: PUSH
36177: LD_VAR 0 8
36181: PUSH
36182: LD_INT 2
36184: ARRAY
36185: PUSH
36186: LD_VAR 0 3
36190: PLUS
36191: PUSH
36192: EMPTY
36193: LIST
36194: LIST
36195: PUSH
36196: EMPTY
36197: LIST
36198: ADD
36199: ST_TO_ADDR
36200: GO 36149
36202: POP
36203: POP
// result = temp_list2 ;
36204: LD_ADDR_VAR 0 7
36208: PUSH
36209: LD_VAR 0 10
36213: ST_TO_ADDR
// end ;
36214: LD_VAR 0 7
36218: RET
// export function EnemyInRange ( unit , dist ) ; begin
36219: LD_INT 0
36221: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
36222: LD_ADDR_VAR 0 3
36226: PUSH
36227: LD_VAR 0 1
36231: PPUSH
36232: CALL_OW 255
36236: PPUSH
36237: LD_VAR 0 1
36241: PPUSH
36242: CALL_OW 250
36246: PPUSH
36247: LD_VAR 0 1
36251: PPUSH
36252: CALL_OW 251
36256: PPUSH
36257: LD_VAR 0 2
36261: PPUSH
36262: CALL 10323 0 4
36266: PUSH
36267: LD_INT 4
36269: ARRAY
36270: ST_TO_ADDR
// end ;
36271: LD_VAR 0 3
36275: RET
// export function PlayerSeeMe ( unit ) ; begin
36276: LD_INT 0
36278: PPUSH
// result := See ( your_side , unit ) ;
36279: LD_ADDR_VAR 0 2
36283: PUSH
36284: LD_OWVAR 2
36288: PPUSH
36289: LD_VAR 0 1
36293: PPUSH
36294: CALL_OW 292
36298: ST_TO_ADDR
// end ;
36299: LD_VAR 0 2
36303: RET
// export function ReverseDir ( unit ) ; begin
36304: LD_INT 0
36306: PPUSH
// if not unit then
36307: LD_VAR 0 1
36311: NOT
36312: IFFALSE 36316
// exit ;
36314: GO 36339
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
36316: LD_ADDR_VAR 0 2
36320: PUSH
36321: LD_VAR 0 1
36325: PPUSH
36326: CALL_OW 254
36330: PUSH
36331: LD_INT 3
36333: PLUS
36334: PUSH
36335: LD_INT 6
36337: MOD
36338: ST_TO_ADDR
// end ;
36339: LD_VAR 0 2
36343: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
36344: LD_INT 0
36346: PPUSH
36347: PPUSH
36348: PPUSH
36349: PPUSH
36350: PPUSH
// if not hexes then
36351: LD_VAR 0 2
36355: NOT
36356: IFFALSE 36360
// exit ;
36358: GO 36508
// dist := 9999 ;
36360: LD_ADDR_VAR 0 5
36364: PUSH
36365: LD_INT 9999
36367: ST_TO_ADDR
// for i = 1 to hexes do
36368: LD_ADDR_VAR 0 4
36372: PUSH
36373: DOUBLE
36374: LD_INT 1
36376: DEC
36377: ST_TO_ADDR
36378: LD_VAR 0 2
36382: PUSH
36383: FOR_TO
36384: IFFALSE 36496
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
36386: LD_VAR 0 1
36390: PPUSH
36391: LD_VAR 0 2
36395: PUSH
36396: LD_VAR 0 4
36400: ARRAY
36401: PUSH
36402: LD_INT 1
36404: ARRAY
36405: PPUSH
36406: LD_VAR 0 2
36410: PUSH
36411: LD_VAR 0 4
36415: ARRAY
36416: PUSH
36417: LD_INT 2
36419: ARRAY
36420: PPUSH
36421: CALL_OW 297
36425: PUSH
36426: LD_VAR 0 5
36430: LESS
36431: IFFALSE 36494
// begin hex := hexes [ i ] ;
36433: LD_ADDR_VAR 0 7
36437: PUSH
36438: LD_VAR 0 2
36442: PUSH
36443: LD_VAR 0 4
36447: ARRAY
36448: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
36449: LD_ADDR_VAR 0 5
36453: PUSH
36454: LD_VAR 0 1
36458: PPUSH
36459: LD_VAR 0 2
36463: PUSH
36464: LD_VAR 0 4
36468: ARRAY
36469: PUSH
36470: LD_INT 1
36472: ARRAY
36473: PPUSH
36474: LD_VAR 0 2
36478: PUSH
36479: LD_VAR 0 4
36483: ARRAY
36484: PUSH
36485: LD_INT 2
36487: ARRAY
36488: PPUSH
36489: CALL_OW 297
36493: ST_TO_ADDR
// end ; end ;
36494: GO 36383
36496: POP
36497: POP
// result := hex ;
36498: LD_ADDR_VAR 0 3
36502: PUSH
36503: LD_VAR 0 7
36507: ST_TO_ADDR
// end ;
36508: LD_VAR 0 3
36512: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
36513: LD_INT 0
36515: PPUSH
36516: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
36517: LD_VAR 0 1
36521: NOT
36522: PUSH
36523: LD_VAR 0 1
36527: PUSH
36528: LD_INT 21
36530: PUSH
36531: LD_INT 2
36533: PUSH
36534: EMPTY
36535: LIST
36536: LIST
36537: PUSH
36538: LD_INT 23
36540: PUSH
36541: LD_INT 2
36543: PUSH
36544: EMPTY
36545: LIST
36546: LIST
36547: PUSH
36548: EMPTY
36549: LIST
36550: LIST
36551: PPUSH
36552: CALL_OW 69
36556: IN
36557: NOT
36558: OR
36559: IFFALSE 36563
// exit ;
36561: GO 36610
// for i = 1 to 3 do
36563: LD_ADDR_VAR 0 3
36567: PUSH
36568: DOUBLE
36569: LD_INT 1
36571: DEC
36572: ST_TO_ADDR
36573: LD_INT 3
36575: PUSH
36576: FOR_TO
36577: IFFALSE 36608
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
36579: LD_VAR 0 1
36583: PPUSH
36584: CALL_OW 250
36588: PPUSH
36589: LD_VAR 0 1
36593: PPUSH
36594: CALL_OW 251
36598: PPUSH
36599: LD_INT 1
36601: PPUSH
36602: CALL_OW 453
36606: GO 36576
36608: POP
36609: POP
// end ;
36610: LD_VAR 0 2
36614: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
36615: LD_INT 0
36617: PPUSH
36618: PPUSH
36619: PPUSH
36620: PPUSH
36621: PPUSH
36622: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
36623: LD_VAR 0 1
36627: NOT
36628: PUSH
36629: LD_VAR 0 2
36633: NOT
36634: OR
36635: PUSH
36636: LD_VAR 0 1
36640: PPUSH
36641: CALL_OW 314
36645: OR
36646: IFFALSE 36650
// exit ;
36648: GO 37091
// x := GetX ( enemy_unit ) ;
36650: LD_ADDR_VAR 0 7
36654: PUSH
36655: LD_VAR 0 2
36659: PPUSH
36660: CALL_OW 250
36664: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
36665: LD_ADDR_VAR 0 8
36669: PUSH
36670: LD_VAR 0 2
36674: PPUSH
36675: CALL_OW 251
36679: ST_TO_ADDR
// if not x or not y then
36680: LD_VAR 0 7
36684: NOT
36685: PUSH
36686: LD_VAR 0 8
36690: NOT
36691: OR
36692: IFFALSE 36696
// exit ;
36694: GO 37091
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
36696: LD_ADDR_VAR 0 6
36700: PUSH
36701: LD_VAR 0 7
36705: PPUSH
36706: LD_INT 0
36708: PPUSH
36709: LD_INT 4
36711: PPUSH
36712: CALL_OW 272
36716: PUSH
36717: LD_VAR 0 8
36721: PPUSH
36722: LD_INT 0
36724: PPUSH
36725: LD_INT 4
36727: PPUSH
36728: CALL_OW 273
36732: PUSH
36733: EMPTY
36734: LIST
36735: LIST
36736: PUSH
36737: LD_VAR 0 7
36741: PPUSH
36742: LD_INT 1
36744: PPUSH
36745: LD_INT 4
36747: PPUSH
36748: CALL_OW 272
36752: PUSH
36753: LD_VAR 0 8
36757: PPUSH
36758: LD_INT 1
36760: PPUSH
36761: LD_INT 4
36763: PPUSH
36764: CALL_OW 273
36768: PUSH
36769: EMPTY
36770: LIST
36771: LIST
36772: PUSH
36773: LD_VAR 0 7
36777: PPUSH
36778: LD_INT 2
36780: PPUSH
36781: LD_INT 4
36783: PPUSH
36784: CALL_OW 272
36788: PUSH
36789: LD_VAR 0 8
36793: PPUSH
36794: LD_INT 2
36796: PPUSH
36797: LD_INT 4
36799: PPUSH
36800: CALL_OW 273
36804: PUSH
36805: EMPTY
36806: LIST
36807: LIST
36808: PUSH
36809: LD_VAR 0 7
36813: PPUSH
36814: LD_INT 3
36816: PPUSH
36817: LD_INT 4
36819: PPUSH
36820: CALL_OW 272
36824: PUSH
36825: LD_VAR 0 8
36829: PPUSH
36830: LD_INT 3
36832: PPUSH
36833: LD_INT 4
36835: PPUSH
36836: CALL_OW 273
36840: PUSH
36841: EMPTY
36842: LIST
36843: LIST
36844: PUSH
36845: LD_VAR 0 7
36849: PPUSH
36850: LD_INT 4
36852: PPUSH
36853: LD_INT 4
36855: PPUSH
36856: CALL_OW 272
36860: PUSH
36861: LD_VAR 0 8
36865: PPUSH
36866: LD_INT 4
36868: PPUSH
36869: LD_INT 4
36871: PPUSH
36872: CALL_OW 273
36876: PUSH
36877: EMPTY
36878: LIST
36879: LIST
36880: PUSH
36881: LD_VAR 0 7
36885: PPUSH
36886: LD_INT 5
36888: PPUSH
36889: LD_INT 4
36891: PPUSH
36892: CALL_OW 272
36896: PUSH
36897: LD_VAR 0 8
36901: PPUSH
36902: LD_INT 5
36904: PPUSH
36905: LD_INT 4
36907: PPUSH
36908: CALL_OW 273
36912: PUSH
36913: EMPTY
36914: LIST
36915: LIST
36916: PUSH
36917: EMPTY
36918: LIST
36919: LIST
36920: LIST
36921: LIST
36922: LIST
36923: LIST
36924: ST_TO_ADDR
// for i = tmp downto 1 do
36925: LD_ADDR_VAR 0 4
36929: PUSH
36930: DOUBLE
36931: LD_VAR 0 6
36935: INC
36936: ST_TO_ADDR
36937: LD_INT 1
36939: PUSH
36940: FOR_DOWNTO
36941: IFFALSE 37042
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
36943: LD_VAR 0 6
36947: PUSH
36948: LD_VAR 0 4
36952: ARRAY
36953: PUSH
36954: LD_INT 1
36956: ARRAY
36957: PPUSH
36958: LD_VAR 0 6
36962: PUSH
36963: LD_VAR 0 4
36967: ARRAY
36968: PUSH
36969: LD_INT 2
36971: ARRAY
36972: PPUSH
36973: CALL_OW 488
36977: NOT
36978: PUSH
36979: LD_VAR 0 6
36983: PUSH
36984: LD_VAR 0 4
36988: ARRAY
36989: PUSH
36990: LD_INT 1
36992: ARRAY
36993: PPUSH
36994: LD_VAR 0 6
36998: PUSH
36999: LD_VAR 0 4
37003: ARRAY
37004: PUSH
37005: LD_INT 2
37007: ARRAY
37008: PPUSH
37009: CALL_OW 428
37013: PUSH
37014: LD_INT 0
37016: NONEQUAL
37017: OR
37018: IFFALSE 37040
// tmp := Delete ( tmp , i ) ;
37020: LD_ADDR_VAR 0 6
37024: PUSH
37025: LD_VAR 0 6
37029: PPUSH
37030: LD_VAR 0 4
37034: PPUSH
37035: CALL_OW 3
37039: ST_TO_ADDR
37040: GO 36940
37042: POP
37043: POP
// j := GetClosestHex ( unit , tmp ) ;
37044: LD_ADDR_VAR 0 5
37048: PUSH
37049: LD_VAR 0 1
37053: PPUSH
37054: LD_VAR 0 6
37058: PPUSH
37059: CALL 36344 0 2
37063: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
37064: LD_VAR 0 1
37068: PPUSH
37069: LD_VAR 0 5
37073: PUSH
37074: LD_INT 1
37076: ARRAY
37077: PPUSH
37078: LD_VAR 0 5
37082: PUSH
37083: LD_INT 2
37085: ARRAY
37086: PPUSH
37087: CALL_OW 111
// end ;
37091: LD_VAR 0 3
37095: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
37096: LD_INT 0
37098: PPUSH
37099: PPUSH
37100: PPUSH
// uc_side = 0 ;
37101: LD_ADDR_OWVAR 20
37105: PUSH
37106: LD_INT 0
37108: ST_TO_ADDR
// uc_nation = 0 ;
37109: LD_ADDR_OWVAR 21
37113: PUSH
37114: LD_INT 0
37116: ST_TO_ADDR
// InitHc_All ( ) ;
37117: CALL_OW 584
// InitVc ;
37121: CALL_OW 20
// if mastodonts then
37125: LD_VAR 0 6
37129: IFFALSE 37196
// for i = 1 to mastodonts do
37131: LD_ADDR_VAR 0 11
37135: PUSH
37136: DOUBLE
37137: LD_INT 1
37139: DEC
37140: ST_TO_ADDR
37141: LD_VAR 0 6
37145: PUSH
37146: FOR_TO
37147: IFFALSE 37194
// begin vc_chassis := 31 ;
37149: LD_ADDR_OWVAR 37
37153: PUSH
37154: LD_INT 31
37156: ST_TO_ADDR
// vc_control := control_rider ;
37157: LD_ADDR_OWVAR 38
37161: PUSH
37162: LD_INT 4
37164: ST_TO_ADDR
// animal := CreateVehicle ;
37165: LD_ADDR_VAR 0 12
37169: PUSH
37170: CALL_OW 45
37174: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
37175: LD_VAR 0 12
37179: PPUSH
37180: LD_VAR 0 8
37184: PPUSH
37185: LD_INT 0
37187: PPUSH
37188: CALL 39384 0 3
// end ;
37192: GO 37146
37194: POP
37195: POP
// if horses then
37196: LD_VAR 0 5
37200: IFFALSE 37267
// for i = 1 to horses do
37202: LD_ADDR_VAR 0 11
37206: PUSH
37207: DOUBLE
37208: LD_INT 1
37210: DEC
37211: ST_TO_ADDR
37212: LD_VAR 0 5
37216: PUSH
37217: FOR_TO
37218: IFFALSE 37265
// begin hc_class := 21 ;
37220: LD_ADDR_OWVAR 28
37224: PUSH
37225: LD_INT 21
37227: ST_TO_ADDR
// hc_gallery :=  ;
37228: LD_ADDR_OWVAR 33
37232: PUSH
37233: LD_STRING 
37235: ST_TO_ADDR
// animal := CreateHuman ;
37236: LD_ADDR_VAR 0 12
37240: PUSH
37241: CALL_OW 44
37245: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
37246: LD_VAR 0 12
37250: PPUSH
37251: LD_VAR 0 8
37255: PPUSH
37256: LD_INT 0
37258: PPUSH
37259: CALL 39384 0 3
// end ;
37263: GO 37217
37265: POP
37266: POP
// if birds then
37267: LD_VAR 0 1
37271: IFFALSE 37338
// for i = 1 to birds do
37273: LD_ADDR_VAR 0 11
37277: PUSH
37278: DOUBLE
37279: LD_INT 1
37281: DEC
37282: ST_TO_ADDR
37283: LD_VAR 0 1
37287: PUSH
37288: FOR_TO
37289: IFFALSE 37336
// begin hc_class = 18 ;
37291: LD_ADDR_OWVAR 28
37295: PUSH
37296: LD_INT 18
37298: ST_TO_ADDR
// hc_gallery =  ;
37299: LD_ADDR_OWVAR 33
37303: PUSH
37304: LD_STRING 
37306: ST_TO_ADDR
// animal := CreateHuman ;
37307: LD_ADDR_VAR 0 12
37311: PUSH
37312: CALL_OW 44
37316: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
37317: LD_VAR 0 12
37321: PPUSH
37322: LD_VAR 0 8
37326: PPUSH
37327: LD_INT 0
37329: PPUSH
37330: CALL 39384 0 3
// end ;
37334: GO 37288
37336: POP
37337: POP
// if tigers then
37338: LD_VAR 0 2
37342: IFFALSE 37426
// for i = 1 to tigers do
37344: LD_ADDR_VAR 0 11
37348: PUSH
37349: DOUBLE
37350: LD_INT 1
37352: DEC
37353: ST_TO_ADDR
37354: LD_VAR 0 2
37358: PUSH
37359: FOR_TO
37360: IFFALSE 37424
// begin hc_class = class_tiger ;
37362: LD_ADDR_OWVAR 28
37366: PUSH
37367: LD_INT 14
37369: ST_TO_ADDR
// hc_gallery =  ;
37370: LD_ADDR_OWVAR 33
37374: PUSH
37375: LD_STRING 
37377: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
37378: LD_ADDR_OWVAR 35
37382: PUSH
37383: LD_INT 7
37385: NEG
37386: PPUSH
37387: LD_INT 7
37389: PPUSH
37390: CALL_OW 12
37394: ST_TO_ADDR
// animal := CreateHuman ;
37395: LD_ADDR_VAR 0 12
37399: PUSH
37400: CALL_OW 44
37404: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
37405: LD_VAR 0 12
37409: PPUSH
37410: LD_VAR 0 8
37414: PPUSH
37415: LD_INT 0
37417: PPUSH
37418: CALL 39384 0 3
// end ;
37422: GO 37359
37424: POP
37425: POP
// if apemans then
37426: LD_VAR 0 3
37430: IFFALSE 37553
// for i = 1 to apemans do
37432: LD_ADDR_VAR 0 11
37436: PUSH
37437: DOUBLE
37438: LD_INT 1
37440: DEC
37441: ST_TO_ADDR
37442: LD_VAR 0 3
37446: PUSH
37447: FOR_TO
37448: IFFALSE 37551
// begin hc_class = class_apeman ;
37450: LD_ADDR_OWVAR 28
37454: PUSH
37455: LD_INT 12
37457: ST_TO_ADDR
// hc_gallery =  ;
37458: LD_ADDR_OWVAR 33
37462: PUSH
37463: LD_STRING 
37465: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
37466: LD_ADDR_OWVAR 35
37470: PUSH
37471: LD_INT 5
37473: NEG
37474: PPUSH
37475: LD_INT 5
37477: PPUSH
37478: CALL_OW 12
37482: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
37483: LD_ADDR_OWVAR 31
37487: PUSH
37488: LD_INT 1
37490: PPUSH
37491: LD_INT 3
37493: PPUSH
37494: CALL_OW 12
37498: PUSH
37499: LD_INT 1
37501: PPUSH
37502: LD_INT 3
37504: PPUSH
37505: CALL_OW 12
37509: PUSH
37510: LD_INT 0
37512: PUSH
37513: LD_INT 0
37515: PUSH
37516: EMPTY
37517: LIST
37518: LIST
37519: LIST
37520: LIST
37521: ST_TO_ADDR
// animal := CreateHuman ;
37522: LD_ADDR_VAR 0 12
37526: PUSH
37527: CALL_OW 44
37531: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
37532: LD_VAR 0 12
37536: PPUSH
37537: LD_VAR 0 8
37541: PPUSH
37542: LD_INT 0
37544: PPUSH
37545: CALL 39384 0 3
// end ;
37549: GO 37447
37551: POP
37552: POP
// if enchidnas then
37553: LD_VAR 0 4
37557: IFFALSE 37624
// for i = 1 to enchidnas do
37559: LD_ADDR_VAR 0 11
37563: PUSH
37564: DOUBLE
37565: LD_INT 1
37567: DEC
37568: ST_TO_ADDR
37569: LD_VAR 0 4
37573: PUSH
37574: FOR_TO
37575: IFFALSE 37622
// begin hc_class = 13 ;
37577: LD_ADDR_OWVAR 28
37581: PUSH
37582: LD_INT 13
37584: ST_TO_ADDR
// hc_gallery =  ;
37585: LD_ADDR_OWVAR 33
37589: PUSH
37590: LD_STRING 
37592: ST_TO_ADDR
// animal := CreateHuman ;
37593: LD_ADDR_VAR 0 12
37597: PUSH
37598: CALL_OW 44
37602: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
37603: LD_VAR 0 12
37607: PPUSH
37608: LD_VAR 0 8
37612: PPUSH
37613: LD_INT 0
37615: PPUSH
37616: CALL 39384 0 3
// end ;
37620: GO 37574
37622: POP
37623: POP
// if fishes then
37624: LD_VAR 0 7
37628: IFFALSE 37695
// for i = 1 to fishes do
37630: LD_ADDR_VAR 0 11
37634: PUSH
37635: DOUBLE
37636: LD_INT 1
37638: DEC
37639: ST_TO_ADDR
37640: LD_VAR 0 7
37644: PUSH
37645: FOR_TO
37646: IFFALSE 37693
// begin hc_class = 20 ;
37648: LD_ADDR_OWVAR 28
37652: PUSH
37653: LD_INT 20
37655: ST_TO_ADDR
// hc_gallery =  ;
37656: LD_ADDR_OWVAR 33
37660: PUSH
37661: LD_STRING 
37663: ST_TO_ADDR
// animal := CreateHuman ;
37664: LD_ADDR_VAR 0 12
37668: PUSH
37669: CALL_OW 44
37673: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
37674: LD_VAR 0 12
37678: PPUSH
37679: LD_VAR 0 9
37683: PPUSH
37684: LD_INT 0
37686: PPUSH
37687: CALL 39384 0 3
// end ;
37691: GO 37645
37693: POP
37694: POP
// end ;
37695: LD_VAR 0 10
37699: RET
// export function WantHeal ( sci , unit ) ; begin
37700: LD_INT 0
37702: PPUSH
// if GetTaskList ( sci ) > 0 then
37703: LD_VAR 0 1
37707: PPUSH
37708: CALL_OW 437
37712: PUSH
37713: LD_INT 0
37715: GREATER
37716: IFFALSE 37786
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
37718: LD_VAR 0 1
37722: PPUSH
37723: CALL_OW 437
37727: PUSH
37728: LD_INT 1
37730: ARRAY
37731: PUSH
37732: LD_INT 1
37734: ARRAY
37735: PUSH
37736: LD_STRING l
37738: EQUAL
37739: PUSH
37740: LD_VAR 0 1
37744: PPUSH
37745: CALL_OW 437
37749: PUSH
37750: LD_INT 1
37752: ARRAY
37753: PUSH
37754: LD_INT 4
37756: ARRAY
37757: PUSH
37758: LD_VAR 0 2
37762: EQUAL
37763: AND
37764: IFFALSE 37776
// result := true else
37766: LD_ADDR_VAR 0 3
37770: PUSH
37771: LD_INT 1
37773: ST_TO_ADDR
37774: GO 37784
// result := false ;
37776: LD_ADDR_VAR 0 3
37780: PUSH
37781: LD_INT 0
37783: ST_TO_ADDR
// end else
37784: GO 37794
// result := false ;
37786: LD_ADDR_VAR 0 3
37790: PUSH
37791: LD_INT 0
37793: ST_TO_ADDR
// end ;
37794: LD_VAR 0 3
37798: RET
// export function HealTarget ( sci ) ; begin
37799: LD_INT 0
37801: PPUSH
// if not sci then
37802: LD_VAR 0 1
37806: NOT
37807: IFFALSE 37811
// exit ;
37809: GO 37876
// result := 0 ;
37811: LD_ADDR_VAR 0 2
37815: PUSH
37816: LD_INT 0
37818: ST_TO_ADDR
// if GetTaskList ( sci ) then
37819: LD_VAR 0 1
37823: PPUSH
37824: CALL_OW 437
37828: IFFALSE 37876
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
37830: LD_VAR 0 1
37834: PPUSH
37835: CALL_OW 437
37839: PUSH
37840: LD_INT 1
37842: ARRAY
37843: PUSH
37844: LD_INT 1
37846: ARRAY
37847: PUSH
37848: LD_STRING l
37850: EQUAL
37851: IFFALSE 37876
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
37853: LD_ADDR_VAR 0 2
37857: PUSH
37858: LD_VAR 0 1
37862: PPUSH
37863: CALL_OW 437
37867: PUSH
37868: LD_INT 1
37870: ARRAY
37871: PUSH
37872: LD_INT 4
37874: ARRAY
37875: ST_TO_ADDR
// end ;
37876: LD_VAR 0 2
37880: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
37881: LD_INT 0
37883: PPUSH
37884: PPUSH
37885: PPUSH
37886: PPUSH
// if not base_units then
37887: LD_VAR 0 1
37891: NOT
37892: IFFALSE 37896
// exit ;
37894: GO 37983
// result := false ;
37896: LD_ADDR_VAR 0 2
37900: PUSH
37901: LD_INT 0
37903: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
37904: LD_ADDR_VAR 0 5
37908: PUSH
37909: LD_VAR 0 1
37913: PPUSH
37914: LD_INT 21
37916: PUSH
37917: LD_INT 3
37919: PUSH
37920: EMPTY
37921: LIST
37922: LIST
37923: PPUSH
37924: CALL_OW 72
37928: ST_TO_ADDR
// if not tmp then
37929: LD_VAR 0 5
37933: NOT
37934: IFFALSE 37938
// exit ;
37936: GO 37983
// for i in tmp do
37938: LD_ADDR_VAR 0 3
37942: PUSH
37943: LD_VAR 0 5
37947: PUSH
37948: FOR_IN
37949: IFFALSE 37981
// begin result := EnemyInRange ( i , 22 ) ;
37951: LD_ADDR_VAR 0 2
37955: PUSH
37956: LD_VAR 0 3
37960: PPUSH
37961: LD_INT 22
37963: PPUSH
37964: CALL 36219 0 2
37968: ST_TO_ADDR
// if result then
37969: LD_VAR 0 2
37973: IFFALSE 37979
// exit ;
37975: POP
37976: POP
37977: GO 37983
// end ;
37979: GO 37948
37981: POP
37982: POP
// end ;
37983: LD_VAR 0 2
37987: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
37988: LD_INT 0
37990: PPUSH
37991: PPUSH
// if not units then
37992: LD_VAR 0 1
37996: NOT
37997: IFFALSE 38001
// exit ;
37999: GO 38071
// result := [ ] ;
38001: LD_ADDR_VAR 0 3
38005: PUSH
38006: EMPTY
38007: ST_TO_ADDR
// for i in units do
38008: LD_ADDR_VAR 0 4
38012: PUSH
38013: LD_VAR 0 1
38017: PUSH
38018: FOR_IN
38019: IFFALSE 38069
// if GetTag ( i ) = tag then
38021: LD_VAR 0 4
38025: PPUSH
38026: CALL_OW 110
38030: PUSH
38031: LD_VAR 0 2
38035: EQUAL
38036: IFFALSE 38067
// result := Insert ( result , result + 1 , i ) ;
38038: LD_ADDR_VAR 0 3
38042: PUSH
38043: LD_VAR 0 3
38047: PPUSH
38048: LD_VAR 0 3
38052: PUSH
38053: LD_INT 1
38055: PLUS
38056: PPUSH
38057: LD_VAR 0 4
38061: PPUSH
38062: CALL_OW 2
38066: ST_TO_ADDR
38067: GO 38018
38069: POP
38070: POP
// end ;
38071: LD_VAR 0 3
38075: RET
// export function IsDriver ( un ) ; begin
38076: LD_INT 0
38078: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
38079: LD_ADDR_VAR 0 2
38083: PUSH
38084: LD_VAR 0 1
38088: PUSH
38089: LD_INT 55
38091: PUSH
38092: EMPTY
38093: LIST
38094: PPUSH
38095: CALL_OW 69
38099: IN
38100: ST_TO_ADDR
// end ;
38101: LD_VAR 0 2
38105: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
38106: LD_INT 0
38108: PPUSH
38109: PPUSH
// list := [ ] ;
38110: LD_ADDR_VAR 0 5
38114: PUSH
38115: EMPTY
38116: ST_TO_ADDR
// case d of 0 :
38117: LD_VAR 0 3
38121: PUSH
38122: LD_INT 0
38124: DOUBLE
38125: EQUAL
38126: IFTRUE 38130
38128: GO 38263
38130: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
38131: LD_ADDR_VAR 0 5
38135: PUSH
38136: LD_VAR 0 1
38140: PUSH
38141: LD_INT 4
38143: MINUS
38144: PUSH
38145: LD_VAR 0 2
38149: PUSH
38150: LD_INT 4
38152: MINUS
38153: PUSH
38154: LD_INT 2
38156: PUSH
38157: EMPTY
38158: LIST
38159: LIST
38160: LIST
38161: PUSH
38162: LD_VAR 0 1
38166: PUSH
38167: LD_INT 3
38169: MINUS
38170: PUSH
38171: LD_VAR 0 2
38175: PUSH
38176: LD_INT 1
38178: PUSH
38179: EMPTY
38180: LIST
38181: LIST
38182: LIST
38183: PUSH
38184: LD_VAR 0 1
38188: PUSH
38189: LD_INT 4
38191: PLUS
38192: PUSH
38193: LD_VAR 0 2
38197: PUSH
38198: LD_INT 4
38200: PUSH
38201: EMPTY
38202: LIST
38203: LIST
38204: LIST
38205: PUSH
38206: LD_VAR 0 1
38210: PUSH
38211: LD_INT 3
38213: PLUS
38214: PUSH
38215: LD_VAR 0 2
38219: PUSH
38220: LD_INT 3
38222: PLUS
38223: PUSH
38224: LD_INT 5
38226: PUSH
38227: EMPTY
38228: LIST
38229: LIST
38230: LIST
38231: PUSH
38232: LD_VAR 0 1
38236: PUSH
38237: LD_VAR 0 2
38241: PUSH
38242: LD_INT 4
38244: PLUS
38245: PUSH
38246: LD_INT 0
38248: PUSH
38249: EMPTY
38250: LIST
38251: LIST
38252: LIST
38253: PUSH
38254: EMPTY
38255: LIST
38256: LIST
38257: LIST
38258: LIST
38259: LIST
38260: ST_TO_ADDR
// end ; 1 :
38261: GO 38961
38263: LD_INT 1
38265: DOUBLE
38266: EQUAL
38267: IFTRUE 38271
38269: GO 38404
38271: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
38272: LD_ADDR_VAR 0 5
38276: PUSH
38277: LD_VAR 0 1
38281: PUSH
38282: LD_VAR 0 2
38286: PUSH
38287: LD_INT 4
38289: MINUS
38290: PUSH
38291: LD_INT 3
38293: PUSH
38294: EMPTY
38295: LIST
38296: LIST
38297: LIST
38298: PUSH
38299: LD_VAR 0 1
38303: PUSH
38304: LD_INT 3
38306: MINUS
38307: PUSH
38308: LD_VAR 0 2
38312: PUSH
38313: LD_INT 3
38315: MINUS
38316: PUSH
38317: LD_INT 2
38319: PUSH
38320: EMPTY
38321: LIST
38322: LIST
38323: LIST
38324: PUSH
38325: LD_VAR 0 1
38329: PUSH
38330: LD_INT 4
38332: MINUS
38333: PUSH
38334: LD_VAR 0 2
38338: PUSH
38339: LD_INT 1
38341: PUSH
38342: EMPTY
38343: LIST
38344: LIST
38345: LIST
38346: PUSH
38347: LD_VAR 0 1
38351: PUSH
38352: LD_VAR 0 2
38356: PUSH
38357: LD_INT 3
38359: PLUS
38360: PUSH
38361: LD_INT 0
38363: PUSH
38364: EMPTY
38365: LIST
38366: LIST
38367: LIST
38368: PUSH
38369: LD_VAR 0 1
38373: PUSH
38374: LD_INT 4
38376: PLUS
38377: PUSH
38378: LD_VAR 0 2
38382: PUSH
38383: LD_INT 4
38385: PLUS
38386: PUSH
38387: LD_INT 5
38389: PUSH
38390: EMPTY
38391: LIST
38392: LIST
38393: LIST
38394: PUSH
38395: EMPTY
38396: LIST
38397: LIST
38398: LIST
38399: LIST
38400: LIST
38401: ST_TO_ADDR
// end ; 2 :
38402: GO 38961
38404: LD_INT 2
38406: DOUBLE
38407: EQUAL
38408: IFTRUE 38412
38410: GO 38541
38412: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
38413: LD_ADDR_VAR 0 5
38417: PUSH
38418: LD_VAR 0 1
38422: PUSH
38423: LD_VAR 0 2
38427: PUSH
38428: LD_INT 3
38430: MINUS
38431: PUSH
38432: LD_INT 3
38434: PUSH
38435: EMPTY
38436: LIST
38437: LIST
38438: LIST
38439: PUSH
38440: LD_VAR 0 1
38444: PUSH
38445: LD_INT 4
38447: PLUS
38448: PUSH
38449: LD_VAR 0 2
38453: PUSH
38454: LD_INT 4
38456: PUSH
38457: EMPTY
38458: LIST
38459: LIST
38460: LIST
38461: PUSH
38462: LD_VAR 0 1
38466: PUSH
38467: LD_VAR 0 2
38471: PUSH
38472: LD_INT 4
38474: PLUS
38475: PUSH
38476: LD_INT 0
38478: PUSH
38479: EMPTY
38480: LIST
38481: LIST
38482: LIST
38483: PUSH
38484: LD_VAR 0 1
38488: PUSH
38489: LD_INT 3
38491: MINUS
38492: PUSH
38493: LD_VAR 0 2
38497: PUSH
38498: LD_INT 1
38500: PUSH
38501: EMPTY
38502: LIST
38503: LIST
38504: LIST
38505: PUSH
38506: LD_VAR 0 1
38510: PUSH
38511: LD_INT 4
38513: MINUS
38514: PUSH
38515: LD_VAR 0 2
38519: PUSH
38520: LD_INT 4
38522: MINUS
38523: PUSH
38524: LD_INT 2
38526: PUSH
38527: EMPTY
38528: LIST
38529: LIST
38530: LIST
38531: PUSH
38532: EMPTY
38533: LIST
38534: LIST
38535: LIST
38536: LIST
38537: LIST
38538: ST_TO_ADDR
// end ; 3 :
38539: GO 38961
38541: LD_INT 3
38543: DOUBLE
38544: EQUAL
38545: IFTRUE 38549
38547: GO 38682
38549: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
38550: LD_ADDR_VAR 0 5
38554: PUSH
38555: LD_VAR 0 1
38559: PUSH
38560: LD_INT 3
38562: PLUS
38563: PUSH
38564: LD_VAR 0 2
38568: PUSH
38569: LD_INT 4
38571: PUSH
38572: EMPTY
38573: LIST
38574: LIST
38575: LIST
38576: PUSH
38577: LD_VAR 0 1
38581: PUSH
38582: LD_INT 4
38584: PLUS
38585: PUSH
38586: LD_VAR 0 2
38590: PUSH
38591: LD_INT 4
38593: PLUS
38594: PUSH
38595: LD_INT 5
38597: PUSH
38598: EMPTY
38599: LIST
38600: LIST
38601: LIST
38602: PUSH
38603: LD_VAR 0 1
38607: PUSH
38608: LD_INT 4
38610: MINUS
38611: PUSH
38612: LD_VAR 0 2
38616: PUSH
38617: LD_INT 1
38619: PUSH
38620: EMPTY
38621: LIST
38622: LIST
38623: LIST
38624: PUSH
38625: LD_VAR 0 1
38629: PUSH
38630: LD_VAR 0 2
38634: PUSH
38635: LD_INT 4
38637: MINUS
38638: PUSH
38639: LD_INT 3
38641: PUSH
38642: EMPTY
38643: LIST
38644: LIST
38645: LIST
38646: PUSH
38647: LD_VAR 0 1
38651: PUSH
38652: LD_INT 3
38654: MINUS
38655: PUSH
38656: LD_VAR 0 2
38660: PUSH
38661: LD_INT 3
38663: MINUS
38664: PUSH
38665: LD_INT 2
38667: PUSH
38668: EMPTY
38669: LIST
38670: LIST
38671: LIST
38672: PUSH
38673: EMPTY
38674: LIST
38675: LIST
38676: LIST
38677: LIST
38678: LIST
38679: ST_TO_ADDR
// end ; 4 :
38680: GO 38961
38682: LD_INT 4
38684: DOUBLE
38685: EQUAL
38686: IFTRUE 38690
38688: GO 38823
38690: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
38691: LD_ADDR_VAR 0 5
38695: PUSH
38696: LD_VAR 0 1
38700: PUSH
38701: LD_VAR 0 2
38705: PUSH
38706: LD_INT 4
38708: PLUS
38709: PUSH
38710: LD_INT 0
38712: PUSH
38713: EMPTY
38714: LIST
38715: LIST
38716: LIST
38717: PUSH
38718: LD_VAR 0 1
38722: PUSH
38723: LD_INT 3
38725: PLUS
38726: PUSH
38727: LD_VAR 0 2
38731: PUSH
38732: LD_INT 3
38734: PLUS
38735: PUSH
38736: LD_INT 5
38738: PUSH
38739: EMPTY
38740: LIST
38741: LIST
38742: LIST
38743: PUSH
38744: LD_VAR 0 1
38748: PUSH
38749: LD_INT 4
38751: PLUS
38752: PUSH
38753: LD_VAR 0 2
38757: PUSH
38758: LD_INT 4
38760: PUSH
38761: EMPTY
38762: LIST
38763: LIST
38764: LIST
38765: PUSH
38766: LD_VAR 0 1
38770: PUSH
38771: LD_VAR 0 2
38775: PUSH
38776: LD_INT 3
38778: MINUS
38779: PUSH
38780: LD_INT 3
38782: PUSH
38783: EMPTY
38784: LIST
38785: LIST
38786: LIST
38787: PUSH
38788: LD_VAR 0 1
38792: PUSH
38793: LD_INT 4
38795: MINUS
38796: PUSH
38797: LD_VAR 0 2
38801: PUSH
38802: LD_INT 4
38804: MINUS
38805: PUSH
38806: LD_INT 2
38808: PUSH
38809: EMPTY
38810: LIST
38811: LIST
38812: LIST
38813: PUSH
38814: EMPTY
38815: LIST
38816: LIST
38817: LIST
38818: LIST
38819: LIST
38820: ST_TO_ADDR
// end ; 5 :
38821: GO 38961
38823: LD_INT 5
38825: DOUBLE
38826: EQUAL
38827: IFTRUE 38831
38829: GO 38960
38831: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
38832: LD_ADDR_VAR 0 5
38836: PUSH
38837: LD_VAR 0 1
38841: PUSH
38842: LD_INT 4
38844: MINUS
38845: PUSH
38846: LD_VAR 0 2
38850: PUSH
38851: LD_INT 1
38853: PUSH
38854: EMPTY
38855: LIST
38856: LIST
38857: LIST
38858: PUSH
38859: LD_VAR 0 1
38863: PUSH
38864: LD_VAR 0 2
38868: PUSH
38869: LD_INT 4
38871: MINUS
38872: PUSH
38873: LD_INT 3
38875: PUSH
38876: EMPTY
38877: LIST
38878: LIST
38879: LIST
38880: PUSH
38881: LD_VAR 0 1
38885: PUSH
38886: LD_INT 4
38888: PLUS
38889: PUSH
38890: LD_VAR 0 2
38894: PUSH
38895: LD_INT 4
38897: PLUS
38898: PUSH
38899: LD_INT 5
38901: PUSH
38902: EMPTY
38903: LIST
38904: LIST
38905: LIST
38906: PUSH
38907: LD_VAR 0 1
38911: PUSH
38912: LD_INT 3
38914: PLUS
38915: PUSH
38916: LD_VAR 0 2
38920: PUSH
38921: LD_INT 4
38923: PUSH
38924: EMPTY
38925: LIST
38926: LIST
38927: LIST
38928: PUSH
38929: LD_VAR 0 1
38933: PUSH
38934: LD_VAR 0 2
38938: PUSH
38939: LD_INT 3
38941: PLUS
38942: PUSH
38943: LD_INT 0
38945: PUSH
38946: EMPTY
38947: LIST
38948: LIST
38949: LIST
38950: PUSH
38951: EMPTY
38952: LIST
38953: LIST
38954: LIST
38955: LIST
38956: LIST
38957: ST_TO_ADDR
// end ; end ;
38958: GO 38961
38960: POP
// result := list ;
38961: LD_ADDR_VAR 0 4
38965: PUSH
38966: LD_VAR 0 5
38970: ST_TO_ADDR
// end ;
38971: LD_VAR 0 4
38975: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
38976: LD_INT 0
38978: PPUSH
38979: PPUSH
38980: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
38981: LD_VAR 0 1
38985: NOT
38986: PUSH
38987: LD_VAR 0 2
38991: PUSH
38992: LD_INT 1
38994: PUSH
38995: LD_INT 2
38997: PUSH
38998: LD_INT 3
39000: PUSH
39001: LD_INT 4
39003: PUSH
39004: EMPTY
39005: LIST
39006: LIST
39007: LIST
39008: LIST
39009: IN
39010: NOT
39011: OR
39012: IFFALSE 39016
// exit ;
39014: GO 39108
// tmp := [ ] ;
39016: LD_ADDR_VAR 0 5
39020: PUSH
39021: EMPTY
39022: ST_TO_ADDR
// for i in units do
39023: LD_ADDR_VAR 0 4
39027: PUSH
39028: LD_VAR 0 1
39032: PUSH
39033: FOR_IN
39034: IFFALSE 39077
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
39036: LD_ADDR_VAR 0 5
39040: PUSH
39041: LD_VAR 0 5
39045: PPUSH
39046: LD_VAR 0 5
39050: PUSH
39051: LD_INT 1
39053: PLUS
39054: PPUSH
39055: LD_VAR 0 4
39059: PPUSH
39060: LD_VAR 0 2
39064: PPUSH
39065: CALL_OW 259
39069: PPUSH
39070: CALL_OW 2
39074: ST_TO_ADDR
39075: GO 39033
39077: POP
39078: POP
// if not tmp then
39079: LD_VAR 0 5
39083: NOT
39084: IFFALSE 39088
// exit ;
39086: GO 39108
// result := SortListByListDesc ( units , tmp ) ;
39088: LD_ADDR_VAR 0 3
39092: PUSH
39093: LD_VAR 0 1
39097: PPUSH
39098: LD_VAR 0 5
39102: PPUSH
39103: CALL_OW 77
39107: ST_TO_ADDR
// end ;
39108: LD_VAR 0 3
39112: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
39113: LD_INT 0
39115: PPUSH
39116: PPUSH
39117: PPUSH
// result := false ;
39118: LD_ADDR_VAR 0 3
39122: PUSH
39123: LD_INT 0
39125: ST_TO_ADDR
// x := GetX ( building ) ;
39126: LD_ADDR_VAR 0 4
39130: PUSH
39131: LD_VAR 0 2
39135: PPUSH
39136: CALL_OW 250
39140: ST_TO_ADDR
// y := GetY ( building ) ;
39141: LD_ADDR_VAR 0 5
39145: PUSH
39146: LD_VAR 0 2
39150: PPUSH
39151: CALL_OW 251
39155: ST_TO_ADDR
// if not building or not x or not y then
39156: LD_VAR 0 2
39160: NOT
39161: PUSH
39162: LD_VAR 0 4
39166: NOT
39167: OR
39168: PUSH
39169: LD_VAR 0 5
39173: NOT
39174: OR
39175: IFFALSE 39179
// exit ;
39177: GO 39271
// if GetTaskList ( unit ) then
39179: LD_VAR 0 1
39183: PPUSH
39184: CALL_OW 437
39188: IFFALSE 39271
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
39190: LD_STRING e
39192: PUSH
39193: LD_VAR 0 1
39197: PPUSH
39198: CALL_OW 437
39202: PUSH
39203: LD_INT 1
39205: ARRAY
39206: PUSH
39207: LD_INT 1
39209: ARRAY
39210: EQUAL
39211: PUSH
39212: LD_VAR 0 4
39216: PUSH
39217: LD_VAR 0 1
39221: PPUSH
39222: CALL_OW 437
39226: PUSH
39227: LD_INT 1
39229: ARRAY
39230: PUSH
39231: LD_INT 2
39233: ARRAY
39234: EQUAL
39235: AND
39236: PUSH
39237: LD_VAR 0 5
39241: PUSH
39242: LD_VAR 0 1
39246: PPUSH
39247: CALL_OW 437
39251: PUSH
39252: LD_INT 1
39254: ARRAY
39255: PUSH
39256: LD_INT 3
39258: ARRAY
39259: EQUAL
39260: AND
39261: IFFALSE 39271
// result := true end ;
39263: LD_ADDR_VAR 0 3
39267: PUSH
39268: LD_INT 1
39270: ST_TO_ADDR
// end ;
39271: LD_VAR 0 3
39275: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
39276: LD_INT 0
39278: PPUSH
// result := false ;
39279: LD_ADDR_VAR 0 4
39283: PUSH
39284: LD_INT 0
39286: ST_TO_ADDR
// if GetTaskList ( unit ) then
39287: LD_VAR 0 1
39291: PPUSH
39292: CALL_OW 437
39296: IFFALSE 39379
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
39298: LD_STRING M
39300: PUSH
39301: LD_VAR 0 1
39305: PPUSH
39306: CALL_OW 437
39310: PUSH
39311: LD_INT 1
39313: ARRAY
39314: PUSH
39315: LD_INT 1
39317: ARRAY
39318: EQUAL
39319: PUSH
39320: LD_VAR 0 2
39324: PUSH
39325: LD_VAR 0 1
39329: PPUSH
39330: CALL_OW 437
39334: PUSH
39335: LD_INT 1
39337: ARRAY
39338: PUSH
39339: LD_INT 2
39341: ARRAY
39342: EQUAL
39343: AND
39344: PUSH
39345: LD_VAR 0 3
39349: PUSH
39350: LD_VAR 0 1
39354: PPUSH
39355: CALL_OW 437
39359: PUSH
39360: LD_INT 1
39362: ARRAY
39363: PUSH
39364: LD_INT 3
39366: ARRAY
39367: EQUAL
39368: AND
39369: IFFALSE 39379
// result := true ;
39371: LD_ADDR_VAR 0 4
39375: PUSH
39376: LD_INT 1
39378: ST_TO_ADDR
// end ; end ;
39379: LD_VAR 0 4
39383: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
39384: LD_INT 0
39386: PPUSH
39387: PPUSH
39388: PPUSH
39389: PPUSH
// if not unit or not area then
39390: LD_VAR 0 1
39394: NOT
39395: PUSH
39396: LD_VAR 0 2
39400: NOT
39401: OR
39402: IFFALSE 39406
// exit ;
39404: GO 39570
// tmp := AreaToList ( area , i ) ;
39406: LD_ADDR_VAR 0 6
39410: PUSH
39411: LD_VAR 0 2
39415: PPUSH
39416: LD_VAR 0 5
39420: PPUSH
39421: CALL_OW 517
39425: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
39426: LD_ADDR_VAR 0 5
39430: PUSH
39431: DOUBLE
39432: LD_INT 1
39434: DEC
39435: ST_TO_ADDR
39436: LD_VAR 0 6
39440: PUSH
39441: LD_INT 1
39443: ARRAY
39444: PUSH
39445: FOR_TO
39446: IFFALSE 39568
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
39448: LD_ADDR_VAR 0 7
39452: PUSH
39453: LD_VAR 0 6
39457: PUSH
39458: LD_INT 1
39460: ARRAY
39461: PUSH
39462: LD_VAR 0 5
39466: ARRAY
39467: PUSH
39468: LD_VAR 0 6
39472: PUSH
39473: LD_INT 2
39475: ARRAY
39476: PUSH
39477: LD_VAR 0 5
39481: ARRAY
39482: PUSH
39483: EMPTY
39484: LIST
39485: LIST
39486: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
39487: LD_VAR 0 7
39491: PUSH
39492: LD_INT 1
39494: ARRAY
39495: PPUSH
39496: LD_VAR 0 7
39500: PUSH
39501: LD_INT 2
39503: ARRAY
39504: PPUSH
39505: CALL_OW 428
39509: PUSH
39510: LD_INT 0
39512: EQUAL
39513: IFFALSE 39566
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
39515: LD_VAR 0 1
39519: PPUSH
39520: LD_VAR 0 7
39524: PUSH
39525: LD_INT 1
39527: ARRAY
39528: PPUSH
39529: LD_VAR 0 7
39533: PUSH
39534: LD_INT 2
39536: ARRAY
39537: PPUSH
39538: LD_VAR 0 3
39542: PPUSH
39543: CALL_OW 48
// result := IsPlaced ( unit ) ;
39547: LD_ADDR_VAR 0 4
39551: PUSH
39552: LD_VAR 0 1
39556: PPUSH
39557: CALL_OW 305
39561: ST_TO_ADDR
// exit ;
39562: POP
39563: POP
39564: GO 39570
// end ; end ;
39566: GO 39445
39568: POP
39569: POP
// end ;
39570: LD_VAR 0 4
39574: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
39575: LD_INT 0
39577: PPUSH
39578: PPUSH
39579: PPUSH
// if not side or side > 8 then
39580: LD_VAR 0 1
39584: NOT
39585: PUSH
39586: LD_VAR 0 1
39590: PUSH
39591: LD_INT 8
39593: GREATER
39594: OR
39595: IFFALSE 39599
// exit ;
39597: GO 39786
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
39599: LD_ADDR_VAR 0 4
39603: PUSH
39604: LD_INT 22
39606: PUSH
39607: LD_VAR 0 1
39611: PUSH
39612: EMPTY
39613: LIST
39614: LIST
39615: PUSH
39616: LD_INT 21
39618: PUSH
39619: LD_INT 3
39621: PUSH
39622: EMPTY
39623: LIST
39624: LIST
39625: PUSH
39626: EMPTY
39627: LIST
39628: LIST
39629: PPUSH
39630: CALL_OW 69
39634: ST_TO_ADDR
// if not tmp then
39635: LD_VAR 0 4
39639: NOT
39640: IFFALSE 39644
// exit ;
39642: GO 39786
// enable_addtolog := true ;
39644: LD_ADDR_OWVAR 81
39648: PUSH
39649: LD_INT 1
39651: ST_TO_ADDR
// AddToLog ( [ ) ;
39652: LD_STRING [
39654: PPUSH
39655: CALL_OW 561
// for i in tmp do
39659: LD_ADDR_VAR 0 3
39663: PUSH
39664: LD_VAR 0 4
39668: PUSH
39669: FOR_IN
39670: IFFALSE 39777
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
39672: LD_STRING [
39674: PUSH
39675: LD_VAR 0 3
39679: PPUSH
39680: CALL_OW 266
39684: STR
39685: PUSH
39686: LD_STRING , 
39688: STR
39689: PUSH
39690: LD_VAR 0 3
39694: PPUSH
39695: CALL_OW 250
39699: STR
39700: PUSH
39701: LD_STRING , 
39703: STR
39704: PUSH
39705: LD_VAR 0 3
39709: PPUSH
39710: CALL_OW 251
39714: STR
39715: PUSH
39716: LD_STRING , 
39718: STR
39719: PUSH
39720: LD_VAR 0 3
39724: PPUSH
39725: CALL_OW 254
39729: STR
39730: PUSH
39731: LD_STRING , 
39733: STR
39734: PUSH
39735: LD_VAR 0 3
39739: PPUSH
39740: LD_INT 1
39742: PPUSH
39743: CALL_OW 268
39747: STR
39748: PUSH
39749: LD_STRING , 
39751: STR
39752: PUSH
39753: LD_VAR 0 3
39757: PPUSH
39758: LD_INT 2
39760: PPUSH
39761: CALL_OW 268
39765: STR
39766: PUSH
39767: LD_STRING ],
39769: STR
39770: PPUSH
39771: CALL_OW 561
// end ;
39775: GO 39669
39777: POP
39778: POP
// AddToLog ( ]; ) ;
39779: LD_STRING ];
39781: PPUSH
39782: CALL_OW 561
// end ;
39786: LD_VAR 0 2
39790: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
39791: LD_INT 0
39793: PPUSH
39794: PPUSH
39795: PPUSH
39796: PPUSH
39797: PPUSH
// if not area or not rate or not max then
39798: LD_VAR 0 1
39802: NOT
39803: PUSH
39804: LD_VAR 0 2
39808: NOT
39809: OR
39810: PUSH
39811: LD_VAR 0 4
39815: NOT
39816: OR
39817: IFFALSE 39821
// exit ;
39819: GO 40013
// while 1 do
39821: LD_INT 1
39823: IFFALSE 40013
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
39825: LD_ADDR_VAR 0 9
39829: PUSH
39830: LD_VAR 0 1
39834: PPUSH
39835: LD_INT 1
39837: PPUSH
39838: CALL_OW 287
39842: PUSH
39843: LD_INT 10
39845: MUL
39846: ST_TO_ADDR
// r := rate / 10 ;
39847: LD_ADDR_VAR 0 7
39851: PUSH
39852: LD_VAR 0 2
39856: PUSH
39857: LD_INT 10
39859: DIVREAL
39860: ST_TO_ADDR
// time := 1 1$00 ;
39861: LD_ADDR_VAR 0 8
39865: PUSH
39866: LD_INT 2100
39868: ST_TO_ADDR
// if amount < min then
39869: LD_VAR 0 9
39873: PUSH
39874: LD_VAR 0 3
39878: LESS
39879: IFFALSE 39897
// r := r * 2 else
39881: LD_ADDR_VAR 0 7
39885: PUSH
39886: LD_VAR 0 7
39890: PUSH
39891: LD_INT 2
39893: MUL
39894: ST_TO_ADDR
39895: GO 39923
// if amount > max then
39897: LD_VAR 0 9
39901: PUSH
39902: LD_VAR 0 4
39906: GREATER
39907: IFFALSE 39923
// r := r / 2 ;
39909: LD_ADDR_VAR 0 7
39913: PUSH
39914: LD_VAR 0 7
39918: PUSH
39919: LD_INT 2
39921: DIVREAL
39922: ST_TO_ADDR
// time := time / r ;
39923: LD_ADDR_VAR 0 8
39927: PUSH
39928: LD_VAR 0 8
39932: PUSH
39933: LD_VAR 0 7
39937: DIVREAL
39938: ST_TO_ADDR
// if time < 0 then
39939: LD_VAR 0 8
39943: PUSH
39944: LD_INT 0
39946: LESS
39947: IFFALSE 39964
// time := time * - 1 ;
39949: LD_ADDR_VAR 0 8
39953: PUSH
39954: LD_VAR 0 8
39958: PUSH
39959: LD_INT 1
39961: NEG
39962: MUL
39963: ST_TO_ADDR
// wait ( time ) ;
39964: LD_VAR 0 8
39968: PPUSH
39969: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
39973: LD_INT 35
39975: PPUSH
39976: LD_INT 875
39978: PPUSH
39979: CALL_OW 12
39983: PPUSH
39984: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
39988: LD_INT 1
39990: PPUSH
39991: LD_INT 5
39993: PPUSH
39994: CALL_OW 12
39998: PPUSH
39999: LD_VAR 0 1
40003: PPUSH
40004: LD_INT 1
40006: PPUSH
40007: CALL_OW 55
// end ;
40011: GO 39821
// end ;
40013: LD_VAR 0 5
40017: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
40018: LD_INT 0
40020: PPUSH
40021: PPUSH
40022: PPUSH
40023: PPUSH
40024: PPUSH
40025: PPUSH
40026: PPUSH
40027: PPUSH
// if not turrets or not factories then
40028: LD_VAR 0 1
40032: NOT
40033: PUSH
40034: LD_VAR 0 2
40038: NOT
40039: OR
40040: IFFALSE 40044
// exit ;
40042: GO 40351
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
40044: LD_ADDR_VAR 0 10
40048: PUSH
40049: LD_INT 5
40051: PUSH
40052: LD_INT 6
40054: PUSH
40055: EMPTY
40056: LIST
40057: LIST
40058: PUSH
40059: LD_INT 2
40061: PUSH
40062: LD_INT 4
40064: PUSH
40065: EMPTY
40066: LIST
40067: LIST
40068: PUSH
40069: LD_INT 3
40071: PUSH
40072: LD_INT 5
40074: PUSH
40075: EMPTY
40076: LIST
40077: LIST
40078: PUSH
40079: EMPTY
40080: LIST
40081: LIST
40082: LIST
40083: PUSH
40084: LD_INT 24
40086: PUSH
40087: LD_INT 25
40089: PUSH
40090: EMPTY
40091: LIST
40092: LIST
40093: PUSH
40094: LD_INT 23
40096: PUSH
40097: LD_INT 27
40099: PUSH
40100: EMPTY
40101: LIST
40102: LIST
40103: PUSH
40104: EMPTY
40105: LIST
40106: LIST
40107: PUSH
40108: LD_INT 42
40110: PUSH
40111: LD_INT 43
40113: PUSH
40114: EMPTY
40115: LIST
40116: LIST
40117: PUSH
40118: LD_INT 44
40120: PUSH
40121: LD_INT 46
40123: PUSH
40124: EMPTY
40125: LIST
40126: LIST
40127: PUSH
40128: LD_INT 45
40130: PUSH
40131: LD_INT 47
40133: PUSH
40134: EMPTY
40135: LIST
40136: LIST
40137: PUSH
40138: EMPTY
40139: LIST
40140: LIST
40141: LIST
40142: PUSH
40143: EMPTY
40144: LIST
40145: LIST
40146: LIST
40147: ST_TO_ADDR
// result := [ ] ;
40148: LD_ADDR_VAR 0 3
40152: PUSH
40153: EMPTY
40154: ST_TO_ADDR
// for i in turrets do
40155: LD_ADDR_VAR 0 4
40159: PUSH
40160: LD_VAR 0 1
40164: PUSH
40165: FOR_IN
40166: IFFALSE 40349
// begin nat := GetNation ( i ) ;
40168: LD_ADDR_VAR 0 7
40172: PUSH
40173: LD_VAR 0 4
40177: PPUSH
40178: CALL_OW 248
40182: ST_TO_ADDR
// weapon := 0 ;
40183: LD_ADDR_VAR 0 8
40187: PUSH
40188: LD_INT 0
40190: ST_TO_ADDR
// if not nat then
40191: LD_VAR 0 7
40195: NOT
40196: IFFALSE 40200
// continue ;
40198: GO 40165
// for j in list [ nat ] do
40200: LD_ADDR_VAR 0 5
40204: PUSH
40205: LD_VAR 0 10
40209: PUSH
40210: LD_VAR 0 7
40214: ARRAY
40215: PUSH
40216: FOR_IN
40217: IFFALSE 40258
// if GetBWeapon ( i ) = j [ 1 ] then
40219: LD_VAR 0 4
40223: PPUSH
40224: CALL_OW 269
40228: PUSH
40229: LD_VAR 0 5
40233: PUSH
40234: LD_INT 1
40236: ARRAY
40237: EQUAL
40238: IFFALSE 40256
// begin weapon := j [ 2 ] ;
40240: LD_ADDR_VAR 0 8
40244: PUSH
40245: LD_VAR 0 5
40249: PUSH
40250: LD_INT 2
40252: ARRAY
40253: ST_TO_ADDR
// break ;
40254: GO 40258
// end ;
40256: GO 40216
40258: POP
40259: POP
// if not weapon then
40260: LD_VAR 0 8
40264: NOT
40265: IFFALSE 40269
// continue ;
40267: GO 40165
// for k in factories do
40269: LD_ADDR_VAR 0 6
40273: PUSH
40274: LD_VAR 0 2
40278: PUSH
40279: FOR_IN
40280: IFFALSE 40345
// begin weapons := AvailableWeaponList ( k ) ;
40282: LD_ADDR_VAR 0 9
40286: PUSH
40287: LD_VAR 0 6
40291: PPUSH
40292: CALL_OW 478
40296: ST_TO_ADDR
// if not weapons then
40297: LD_VAR 0 9
40301: NOT
40302: IFFALSE 40306
// continue ;
40304: GO 40279
// if weapon in weapons then
40306: LD_VAR 0 8
40310: PUSH
40311: LD_VAR 0 9
40315: IN
40316: IFFALSE 40343
// begin result := [ i , weapon ] ;
40318: LD_ADDR_VAR 0 3
40322: PUSH
40323: LD_VAR 0 4
40327: PUSH
40328: LD_VAR 0 8
40332: PUSH
40333: EMPTY
40334: LIST
40335: LIST
40336: ST_TO_ADDR
// exit ;
40337: POP
40338: POP
40339: POP
40340: POP
40341: GO 40351
// end ; end ;
40343: GO 40279
40345: POP
40346: POP
// end ;
40347: GO 40165
40349: POP
40350: POP
// end ;
40351: LD_VAR 0 3
40355: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
40356: LD_INT 0
40358: PPUSH
// if not side or side > 8 then
40359: LD_VAR 0 3
40363: NOT
40364: PUSH
40365: LD_VAR 0 3
40369: PUSH
40370: LD_INT 8
40372: GREATER
40373: OR
40374: IFFALSE 40378
// exit ;
40376: GO 40437
// if not range then
40378: LD_VAR 0 4
40382: NOT
40383: IFFALSE 40394
// range := - 12 ;
40385: LD_ADDR_VAR 0 4
40389: PUSH
40390: LD_INT 12
40392: NEG
40393: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
40394: LD_VAR 0 1
40398: PPUSH
40399: LD_VAR 0 2
40403: PPUSH
40404: LD_VAR 0 3
40408: PPUSH
40409: LD_VAR 0 4
40413: PPUSH
40414: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
40418: LD_VAR 0 1
40422: PPUSH
40423: LD_VAR 0 2
40427: PPUSH
40428: LD_VAR 0 3
40432: PPUSH
40433: CALL_OW 331
// end ;
40437: LD_VAR 0 5
40441: RET
// export function Video ( mode ) ; begin
40442: LD_INT 0
40444: PPUSH
// ingame_video = mode ;
40445: LD_ADDR_OWVAR 52
40449: PUSH
40450: LD_VAR 0 1
40454: ST_TO_ADDR
// interface_hidden = mode ;
40455: LD_ADDR_OWVAR 54
40459: PUSH
40460: LD_VAR 0 1
40464: ST_TO_ADDR
// end ;
40465: LD_VAR 0 2
40469: RET
// export function Join ( array , element ) ; begin
40470: LD_INT 0
40472: PPUSH
// result := Replace ( array , array + 1 , element ) ;
40473: LD_ADDR_VAR 0 3
40477: PUSH
40478: LD_VAR 0 1
40482: PPUSH
40483: LD_VAR 0 1
40487: PUSH
40488: LD_INT 1
40490: PLUS
40491: PPUSH
40492: LD_VAR 0 2
40496: PPUSH
40497: CALL_OW 1
40501: ST_TO_ADDR
// end ;
40502: LD_VAR 0 3
40506: RET
// export function JoinUnion ( array , element ) ; begin
40507: LD_INT 0
40509: PPUSH
// result := array union element ;
40510: LD_ADDR_VAR 0 3
40514: PUSH
40515: LD_VAR 0 1
40519: PUSH
40520: LD_VAR 0 2
40524: UNION
40525: ST_TO_ADDR
// end ;
40526: LD_VAR 0 3
40530: RET
// export function GetBehemoths ( side ) ; begin
40531: LD_INT 0
40533: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
40534: LD_ADDR_VAR 0 2
40538: PUSH
40539: LD_INT 22
40541: PUSH
40542: LD_VAR 0 1
40546: PUSH
40547: EMPTY
40548: LIST
40549: LIST
40550: PUSH
40551: LD_INT 31
40553: PUSH
40554: LD_INT 25
40556: PUSH
40557: EMPTY
40558: LIST
40559: LIST
40560: PUSH
40561: EMPTY
40562: LIST
40563: LIST
40564: PPUSH
40565: CALL_OW 69
40569: ST_TO_ADDR
// end ;
40570: LD_VAR 0 2
40574: RET
// export function Shuffle ( array ) ; var i , index ; begin
40575: LD_INT 0
40577: PPUSH
40578: PPUSH
40579: PPUSH
// result := [ ] ;
40580: LD_ADDR_VAR 0 2
40584: PUSH
40585: EMPTY
40586: ST_TO_ADDR
// if not array then
40587: LD_VAR 0 1
40591: NOT
40592: IFFALSE 40596
// exit ;
40594: GO 40695
// Randomize ;
40596: CALL_OW 10
// for i = array downto 1 do
40600: LD_ADDR_VAR 0 3
40604: PUSH
40605: DOUBLE
40606: LD_VAR 0 1
40610: INC
40611: ST_TO_ADDR
40612: LD_INT 1
40614: PUSH
40615: FOR_DOWNTO
40616: IFFALSE 40693
// begin index := rand ( 1 , array ) ;
40618: LD_ADDR_VAR 0 4
40622: PUSH
40623: LD_INT 1
40625: PPUSH
40626: LD_VAR 0 1
40630: PPUSH
40631: CALL_OW 12
40635: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
40636: LD_ADDR_VAR 0 2
40640: PUSH
40641: LD_VAR 0 2
40645: PPUSH
40646: LD_VAR 0 2
40650: PUSH
40651: LD_INT 1
40653: PLUS
40654: PPUSH
40655: LD_VAR 0 1
40659: PUSH
40660: LD_VAR 0 4
40664: ARRAY
40665: PPUSH
40666: CALL_OW 2
40670: ST_TO_ADDR
// array := Delete ( array , index ) ;
40671: LD_ADDR_VAR 0 1
40675: PUSH
40676: LD_VAR 0 1
40680: PPUSH
40681: LD_VAR 0 4
40685: PPUSH
40686: CALL_OW 3
40690: ST_TO_ADDR
// end ;
40691: GO 40615
40693: POP
40694: POP
// end ;
40695: LD_VAR 0 2
40699: RET
// export function GetBaseMaterials ( base ) ; begin
40700: LD_INT 0
40702: PPUSH
// result := [ 0 , 0 , 0 ] ;
40703: LD_ADDR_VAR 0 2
40707: PUSH
40708: LD_INT 0
40710: PUSH
40711: LD_INT 0
40713: PUSH
40714: LD_INT 0
40716: PUSH
40717: EMPTY
40718: LIST
40719: LIST
40720: LIST
40721: ST_TO_ADDR
// if not base then
40722: LD_VAR 0 1
40726: NOT
40727: IFFALSE 40731
// exit ;
40729: GO 40780
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
40731: LD_ADDR_VAR 0 2
40735: PUSH
40736: LD_VAR 0 1
40740: PPUSH
40741: LD_INT 1
40743: PPUSH
40744: CALL_OW 275
40748: PUSH
40749: LD_VAR 0 1
40753: PPUSH
40754: LD_INT 2
40756: PPUSH
40757: CALL_OW 275
40761: PUSH
40762: LD_VAR 0 1
40766: PPUSH
40767: LD_INT 3
40769: PPUSH
40770: CALL_OW 275
40774: PUSH
40775: EMPTY
40776: LIST
40777: LIST
40778: LIST
40779: ST_TO_ADDR
// end ;
40780: LD_VAR 0 2
40784: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
40785: LD_INT 0
40787: PPUSH
40788: PPUSH
// result := array ;
40789: LD_ADDR_VAR 0 3
40793: PUSH
40794: LD_VAR 0 1
40798: ST_TO_ADDR
// if size > 0 then
40799: LD_VAR 0 2
40803: PUSH
40804: LD_INT 0
40806: GREATER
40807: IFFALSE 40853
// for i := array downto size do
40809: LD_ADDR_VAR 0 4
40813: PUSH
40814: DOUBLE
40815: LD_VAR 0 1
40819: INC
40820: ST_TO_ADDR
40821: LD_VAR 0 2
40825: PUSH
40826: FOR_DOWNTO
40827: IFFALSE 40851
// result := Delete ( result , result ) ;
40829: LD_ADDR_VAR 0 3
40833: PUSH
40834: LD_VAR 0 3
40838: PPUSH
40839: LD_VAR 0 3
40843: PPUSH
40844: CALL_OW 3
40848: ST_TO_ADDR
40849: GO 40826
40851: POP
40852: POP
// end ;
40853: LD_VAR 0 3
40857: RET
// export function ComExit ( unit ) ; var tmp ; begin
40858: LD_INT 0
40860: PPUSH
40861: PPUSH
// if not IsInUnit ( unit ) then
40862: LD_VAR 0 1
40866: PPUSH
40867: CALL_OW 310
40871: NOT
40872: IFFALSE 40876
// exit ;
40874: GO 40936
// tmp := IsInUnit ( unit ) ;
40876: LD_ADDR_VAR 0 3
40880: PUSH
40881: LD_VAR 0 1
40885: PPUSH
40886: CALL_OW 310
40890: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
40891: LD_VAR 0 3
40895: PPUSH
40896: CALL_OW 247
40900: PUSH
40901: LD_INT 2
40903: EQUAL
40904: IFFALSE 40917
// ComExitVehicle ( unit ) else
40906: LD_VAR 0 1
40910: PPUSH
40911: CALL_OW 121
40915: GO 40926
// ComExitBuilding ( unit ) ;
40917: LD_VAR 0 1
40921: PPUSH
40922: CALL_OW 122
// result := tmp ;
40926: LD_ADDR_VAR 0 2
40930: PUSH
40931: LD_VAR 0 3
40935: ST_TO_ADDR
// end ;
40936: LD_VAR 0 2
40940: RET
// export function ResetHc ; begin
40941: LD_INT 0
40943: PPUSH
// InitHc ;
40944: CALL_OW 19
// hc_importance := 0 ;
40948: LD_ADDR_OWVAR 32
40952: PUSH
40953: LD_INT 0
40955: ST_TO_ADDR
// end ;
40956: LD_VAR 0 1
40960: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
40961: LD_INT 0
40963: PPUSH
40964: PPUSH
40965: PPUSH
// _x := ( x1 + x2 ) div 2 ;
40966: LD_ADDR_VAR 0 6
40970: PUSH
40971: LD_VAR 0 1
40975: PUSH
40976: LD_VAR 0 3
40980: PLUS
40981: PUSH
40982: LD_INT 2
40984: DIV
40985: ST_TO_ADDR
// if _x < 0 then
40986: LD_VAR 0 6
40990: PUSH
40991: LD_INT 0
40993: LESS
40994: IFFALSE 41011
// _x := _x * - 1 ;
40996: LD_ADDR_VAR 0 6
41000: PUSH
41001: LD_VAR 0 6
41005: PUSH
41006: LD_INT 1
41008: NEG
41009: MUL
41010: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
41011: LD_ADDR_VAR 0 7
41015: PUSH
41016: LD_VAR 0 2
41020: PUSH
41021: LD_VAR 0 4
41025: PLUS
41026: PUSH
41027: LD_INT 2
41029: DIV
41030: ST_TO_ADDR
// if _y < 0 then
41031: LD_VAR 0 7
41035: PUSH
41036: LD_INT 0
41038: LESS
41039: IFFALSE 41056
// _y := _y * - 1 ;
41041: LD_ADDR_VAR 0 7
41045: PUSH
41046: LD_VAR 0 7
41050: PUSH
41051: LD_INT 1
41053: NEG
41054: MUL
41055: ST_TO_ADDR
// result := [ _x , _y ] ;
41056: LD_ADDR_VAR 0 5
41060: PUSH
41061: LD_VAR 0 6
41065: PUSH
41066: LD_VAR 0 7
41070: PUSH
41071: EMPTY
41072: LIST
41073: LIST
41074: ST_TO_ADDR
// end ;
41075: LD_VAR 0 5
41079: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
41080: LD_INT 0
41082: PPUSH
41083: PPUSH
41084: PPUSH
41085: PPUSH
// task := GetTaskList ( unit ) ;
41086: LD_ADDR_VAR 0 7
41090: PUSH
41091: LD_VAR 0 1
41095: PPUSH
41096: CALL_OW 437
41100: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
41101: LD_VAR 0 7
41105: NOT
41106: PUSH
41107: LD_VAR 0 1
41111: PPUSH
41112: LD_VAR 0 2
41116: PPUSH
41117: CALL_OW 308
41121: NOT
41122: AND
41123: IFFALSE 41127
// exit ;
41125: GO 41245
// if IsInArea ( unit , area ) then
41127: LD_VAR 0 1
41131: PPUSH
41132: LD_VAR 0 2
41136: PPUSH
41137: CALL_OW 308
41141: IFFALSE 41159
// begin ComMoveToArea ( unit , goAway ) ;
41143: LD_VAR 0 1
41147: PPUSH
41148: LD_VAR 0 3
41152: PPUSH
41153: CALL_OW 113
// exit ;
41157: GO 41245
// end ; if task [ 1 ] [ 1 ] <> M then
41159: LD_VAR 0 7
41163: PUSH
41164: LD_INT 1
41166: ARRAY
41167: PUSH
41168: LD_INT 1
41170: ARRAY
41171: PUSH
41172: LD_STRING M
41174: NONEQUAL
41175: IFFALSE 41179
// exit ;
41177: GO 41245
// x := task [ 1 ] [ 2 ] ;
41179: LD_ADDR_VAR 0 5
41183: PUSH
41184: LD_VAR 0 7
41188: PUSH
41189: LD_INT 1
41191: ARRAY
41192: PUSH
41193: LD_INT 2
41195: ARRAY
41196: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
41197: LD_ADDR_VAR 0 6
41201: PUSH
41202: LD_VAR 0 7
41206: PUSH
41207: LD_INT 1
41209: ARRAY
41210: PUSH
41211: LD_INT 3
41213: ARRAY
41214: ST_TO_ADDR
// if InArea ( x , y , area ) then
41215: LD_VAR 0 5
41219: PPUSH
41220: LD_VAR 0 6
41224: PPUSH
41225: LD_VAR 0 2
41229: PPUSH
41230: CALL_OW 309
41234: IFFALSE 41245
// ComStop ( unit ) ;
41236: LD_VAR 0 1
41240: PPUSH
41241: CALL_OW 141
// end ;
41245: LD_VAR 0 4
41249: RET
// export function Abs ( value ) ; begin
41250: LD_INT 0
41252: PPUSH
// result := value ;
41253: LD_ADDR_VAR 0 2
41257: PUSH
41258: LD_VAR 0 1
41262: ST_TO_ADDR
// if value < 0 then
41263: LD_VAR 0 1
41267: PUSH
41268: LD_INT 0
41270: LESS
41271: IFFALSE 41288
// result := value * - 1 ;
41273: LD_ADDR_VAR 0 2
41277: PUSH
41278: LD_VAR 0 1
41282: PUSH
41283: LD_INT 1
41285: NEG
41286: MUL
41287: ST_TO_ADDR
// end ; end_of_file
41288: LD_VAR 0 2
41292: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
41293: LD_INT 0
41295: PPUSH
41296: PPUSH
// skirmish := false ;
41297: LD_ADDR_EXP 12
41301: PUSH
41302: LD_INT 0
41304: ST_TO_ADDR
// debug_mc := false ;
41305: LD_ADDR_EXP 13
41309: PUSH
41310: LD_INT 0
41312: ST_TO_ADDR
// mc_bases := [ ] ;
41313: LD_ADDR_EXP 14
41317: PUSH
41318: EMPTY
41319: ST_TO_ADDR
// mc_sides := [ ] ;
41320: LD_ADDR_EXP 40
41324: PUSH
41325: EMPTY
41326: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
41327: LD_ADDR_EXP 15
41331: PUSH
41332: EMPTY
41333: ST_TO_ADDR
// mc_building_repairs := [ ] ;
41334: LD_ADDR_EXP 16
41338: PUSH
41339: EMPTY
41340: ST_TO_ADDR
// mc_need_heal := [ ] ;
41341: LD_ADDR_EXP 17
41345: PUSH
41346: EMPTY
41347: ST_TO_ADDR
// mc_healers := [ ] ;
41348: LD_ADDR_EXP 18
41352: PUSH
41353: EMPTY
41354: ST_TO_ADDR
// mc_build_list := [ ] ;
41355: LD_ADDR_EXP 19
41359: PUSH
41360: EMPTY
41361: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
41362: LD_ADDR_EXP 46
41366: PUSH
41367: EMPTY
41368: ST_TO_ADDR
// mc_builders := [ ] ;
41369: LD_ADDR_EXP 20
41373: PUSH
41374: EMPTY
41375: ST_TO_ADDR
// mc_construct_list := [ ] ;
41376: LD_ADDR_EXP 21
41380: PUSH
41381: EMPTY
41382: ST_TO_ADDR
// mc_turret_list := [ ] ;
41383: LD_ADDR_EXP 22
41387: PUSH
41388: EMPTY
41389: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
41390: LD_ADDR_EXP 23
41394: PUSH
41395: EMPTY
41396: ST_TO_ADDR
// mc_miners := [ ] ;
41397: LD_ADDR_EXP 28
41401: PUSH
41402: EMPTY
41403: ST_TO_ADDR
// mc_mines := [ ] ;
41404: LD_ADDR_EXP 27
41408: PUSH
41409: EMPTY
41410: ST_TO_ADDR
// mc_minefields := [ ] ;
41411: LD_ADDR_EXP 29
41415: PUSH
41416: EMPTY
41417: ST_TO_ADDR
// mc_crates := [ ] ;
41418: LD_ADDR_EXP 30
41422: PUSH
41423: EMPTY
41424: ST_TO_ADDR
// mc_crates_collector := [ ] ;
41425: LD_ADDR_EXP 31
41429: PUSH
41430: EMPTY
41431: ST_TO_ADDR
// mc_crates_area := [ ] ;
41432: LD_ADDR_EXP 32
41436: PUSH
41437: EMPTY
41438: ST_TO_ADDR
// mc_vehicles := [ ] ;
41439: LD_ADDR_EXP 33
41443: PUSH
41444: EMPTY
41445: ST_TO_ADDR
// mc_attack := [ ] ;
41446: LD_ADDR_EXP 34
41450: PUSH
41451: EMPTY
41452: ST_TO_ADDR
// mc_produce := [ ] ;
41453: LD_ADDR_EXP 35
41457: PUSH
41458: EMPTY
41459: ST_TO_ADDR
// mc_defender := [ ] ;
41460: LD_ADDR_EXP 36
41464: PUSH
41465: EMPTY
41466: ST_TO_ADDR
// mc_parking := [ ] ;
41467: LD_ADDR_EXP 38
41471: PUSH
41472: EMPTY
41473: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
41474: LD_ADDR_EXP 24
41478: PUSH
41479: EMPTY
41480: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
41481: LD_ADDR_EXP 26
41485: PUSH
41486: EMPTY
41487: ST_TO_ADDR
// mc_scan := [ ] ;
41488: LD_ADDR_EXP 37
41492: PUSH
41493: EMPTY
41494: ST_TO_ADDR
// mc_scan_area := [ ] ;
41495: LD_ADDR_EXP 39
41499: PUSH
41500: EMPTY
41501: ST_TO_ADDR
// mc_tech := [ ] ;
41502: LD_ADDR_EXP 41
41506: PUSH
41507: EMPTY
41508: ST_TO_ADDR
// mc_class := [ ] ;
41509: LD_ADDR_EXP 55
41513: PUSH
41514: EMPTY
41515: ST_TO_ADDR
// mc_class_case_use := [ ] ;
41516: LD_ADDR_EXP 56
41520: PUSH
41521: EMPTY
41522: ST_TO_ADDR
// end ;
41523: LD_VAR 0 1
41527: RET
// export function MC_Kill ( base ) ; begin
41528: LD_INT 0
41530: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
41531: LD_ADDR_EXP 14
41535: PUSH
41536: LD_EXP 14
41540: PPUSH
41541: LD_VAR 0 1
41545: PPUSH
41546: EMPTY
41547: PPUSH
41548: CALL_OW 1
41552: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
41553: LD_ADDR_EXP 15
41557: PUSH
41558: LD_EXP 15
41562: PPUSH
41563: LD_VAR 0 1
41567: PPUSH
41568: EMPTY
41569: PPUSH
41570: CALL_OW 1
41574: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
41575: LD_ADDR_EXP 16
41579: PUSH
41580: LD_EXP 16
41584: PPUSH
41585: LD_VAR 0 1
41589: PPUSH
41590: EMPTY
41591: PPUSH
41592: CALL_OW 1
41596: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
41597: LD_ADDR_EXP 17
41601: PUSH
41602: LD_EXP 17
41606: PPUSH
41607: LD_VAR 0 1
41611: PPUSH
41612: EMPTY
41613: PPUSH
41614: CALL_OW 1
41618: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
41619: LD_ADDR_EXP 18
41623: PUSH
41624: LD_EXP 18
41628: PPUSH
41629: LD_VAR 0 1
41633: PPUSH
41634: EMPTY
41635: PPUSH
41636: CALL_OW 1
41640: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
41641: LD_ADDR_EXP 19
41645: PUSH
41646: LD_EXP 19
41650: PPUSH
41651: LD_VAR 0 1
41655: PPUSH
41656: EMPTY
41657: PPUSH
41658: CALL_OW 1
41662: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
41663: LD_ADDR_EXP 20
41667: PUSH
41668: LD_EXP 20
41672: PPUSH
41673: LD_VAR 0 1
41677: PPUSH
41678: EMPTY
41679: PPUSH
41680: CALL_OW 1
41684: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
41685: LD_ADDR_EXP 21
41689: PUSH
41690: LD_EXP 21
41694: PPUSH
41695: LD_VAR 0 1
41699: PPUSH
41700: EMPTY
41701: PPUSH
41702: CALL_OW 1
41706: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
41707: LD_ADDR_EXP 22
41711: PUSH
41712: LD_EXP 22
41716: PPUSH
41717: LD_VAR 0 1
41721: PPUSH
41722: EMPTY
41723: PPUSH
41724: CALL_OW 1
41728: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
41729: LD_ADDR_EXP 23
41733: PUSH
41734: LD_EXP 23
41738: PPUSH
41739: LD_VAR 0 1
41743: PPUSH
41744: EMPTY
41745: PPUSH
41746: CALL_OW 1
41750: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
41751: LD_ADDR_EXP 24
41755: PUSH
41756: LD_EXP 24
41760: PPUSH
41761: LD_VAR 0 1
41765: PPUSH
41766: EMPTY
41767: PPUSH
41768: CALL_OW 1
41772: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
41773: LD_ADDR_EXP 25
41777: PUSH
41778: LD_EXP 25
41782: PPUSH
41783: LD_VAR 0 1
41787: PPUSH
41788: LD_INT 0
41790: PPUSH
41791: CALL_OW 1
41795: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
41796: LD_ADDR_EXP 26
41800: PUSH
41801: LD_EXP 26
41805: PPUSH
41806: LD_VAR 0 1
41810: PPUSH
41811: EMPTY
41812: PPUSH
41813: CALL_OW 1
41817: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
41818: LD_ADDR_EXP 27
41822: PUSH
41823: LD_EXP 27
41827: PPUSH
41828: LD_VAR 0 1
41832: PPUSH
41833: EMPTY
41834: PPUSH
41835: CALL_OW 1
41839: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
41840: LD_ADDR_EXP 28
41844: PUSH
41845: LD_EXP 28
41849: PPUSH
41850: LD_VAR 0 1
41854: PPUSH
41855: EMPTY
41856: PPUSH
41857: CALL_OW 1
41861: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
41862: LD_ADDR_EXP 29
41866: PUSH
41867: LD_EXP 29
41871: PPUSH
41872: LD_VAR 0 1
41876: PPUSH
41877: EMPTY
41878: PPUSH
41879: CALL_OW 1
41883: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
41884: LD_ADDR_EXP 30
41888: PUSH
41889: LD_EXP 30
41893: PPUSH
41894: LD_VAR 0 1
41898: PPUSH
41899: EMPTY
41900: PPUSH
41901: CALL_OW 1
41905: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
41906: LD_ADDR_EXP 31
41910: PUSH
41911: LD_EXP 31
41915: PPUSH
41916: LD_VAR 0 1
41920: PPUSH
41921: EMPTY
41922: PPUSH
41923: CALL_OW 1
41927: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
41928: LD_ADDR_EXP 32
41932: PUSH
41933: LD_EXP 32
41937: PPUSH
41938: LD_VAR 0 1
41942: PPUSH
41943: EMPTY
41944: PPUSH
41945: CALL_OW 1
41949: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
41950: LD_ADDR_EXP 33
41954: PUSH
41955: LD_EXP 33
41959: PPUSH
41960: LD_VAR 0 1
41964: PPUSH
41965: EMPTY
41966: PPUSH
41967: CALL_OW 1
41971: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
41972: LD_ADDR_EXP 34
41976: PUSH
41977: LD_EXP 34
41981: PPUSH
41982: LD_VAR 0 1
41986: PPUSH
41987: EMPTY
41988: PPUSH
41989: CALL_OW 1
41993: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
41994: LD_ADDR_EXP 35
41998: PUSH
41999: LD_EXP 35
42003: PPUSH
42004: LD_VAR 0 1
42008: PPUSH
42009: EMPTY
42010: PPUSH
42011: CALL_OW 1
42015: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
42016: LD_ADDR_EXP 36
42020: PUSH
42021: LD_EXP 36
42025: PPUSH
42026: LD_VAR 0 1
42030: PPUSH
42031: EMPTY
42032: PPUSH
42033: CALL_OW 1
42037: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
42038: LD_ADDR_EXP 37
42042: PUSH
42043: LD_EXP 37
42047: PPUSH
42048: LD_VAR 0 1
42052: PPUSH
42053: EMPTY
42054: PPUSH
42055: CALL_OW 1
42059: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
42060: LD_ADDR_EXP 38
42064: PUSH
42065: LD_EXP 38
42069: PPUSH
42070: LD_VAR 0 1
42074: PPUSH
42075: EMPTY
42076: PPUSH
42077: CALL_OW 1
42081: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
42082: LD_ADDR_EXP 39
42086: PUSH
42087: LD_EXP 39
42091: PPUSH
42092: LD_VAR 0 1
42096: PPUSH
42097: EMPTY
42098: PPUSH
42099: CALL_OW 1
42103: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
42104: LD_ADDR_EXP 41
42108: PUSH
42109: LD_EXP 41
42113: PPUSH
42114: LD_VAR 0 1
42118: PPUSH
42119: EMPTY
42120: PPUSH
42121: CALL_OW 1
42125: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
42126: LD_ADDR_EXP 43
42130: PUSH
42131: LD_EXP 43
42135: PPUSH
42136: LD_VAR 0 1
42140: PPUSH
42141: EMPTY
42142: PPUSH
42143: CALL_OW 1
42147: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
42148: LD_ADDR_EXP 44
42152: PUSH
42153: LD_EXP 44
42157: PPUSH
42158: LD_VAR 0 1
42162: PPUSH
42163: EMPTY
42164: PPUSH
42165: CALL_OW 1
42169: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
42170: LD_ADDR_EXP 45
42174: PUSH
42175: LD_EXP 45
42179: PPUSH
42180: LD_VAR 0 1
42184: PPUSH
42185: EMPTY
42186: PPUSH
42187: CALL_OW 1
42191: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
42192: LD_ADDR_EXP 46
42196: PUSH
42197: LD_EXP 46
42201: PPUSH
42202: LD_VAR 0 1
42206: PPUSH
42207: EMPTY
42208: PPUSH
42209: CALL_OW 1
42213: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
42214: LD_ADDR_EXP 47
42218: PUSH
42219: LD_EXP 47
42223: PPUSH
42224: LD_VAR 0 1
42228: PPUSH
42229: EMPTY
42230: PPUSH
42231: CALL_OW 1
42235: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
42236: LD_ADDR_EXP 48
42240: PUSH
42241: LD_EXP 48
42245: PPUSH
42246: LD_VAR 0 1
42250: PPUSH
42251: EMPTY
42252: PPUSH
42253: CALL_OW 1
42257: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
42258: LD_ADDR_EXP 49
42262: PUSH
42263: LD_EXP 49
42267: PPUSH
42268: LD_VAR 0 1
42272: PPUSH
42273: EMPTY
42274: PPUSH
42275: CALL_OW 1
42279: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
42280: LD_ADDR_EXP 50
42284: PUSH
42285: LD_EXP 50
42289: PPUSH
42290: LD_VAR 0 1
42294: PPUSH
42295: EMPTY
42296: PPUSH
42297: CALL_OW 1
42301: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
42302: LD_ADDR_EXP 51
42306: PUSH
42307: LD_EXP 51
42311: PPUSH
42312: LD_VAR 0 1
42316: PPUSH
42317: EMPTY
42318: PPUSH
42319: CALL_OW 1
42323: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
42324: LD_ADDR_EXP 52
42328: PUSH
42329: LD_EXP 52
42333: PPUSH
42334: LD_VAR 0 1
42338: PPUSH
42339: EMPTY
42340: PPUSH
42341: CALL_OW 1
42345: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
42346: LD_ADDR_EXP 53
42350: PUSH
42351: LD_EXP 53
42355: PPUSH
42356: LD_VAR 0 1
42360: PPUSH
42361: EMPTY
42362: PPUSH
42363: CALL_OW 1
42367: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
42368: LD_ADDR_EXP 54
42372: PUSH
42373: LD_EXP 54
42377: PPUSH
42378: LD_VAR 0 1
42382: PPUSH
42383: EMPTY
42384: PPUSH
42385: CALL_OW 1
42389: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
42390: LD_ADDR_EXP 55
42394: PUSH
42395: LD_EXP 55
42399: PPUSH
42400: LD_VAR 0 1
42404: PPUSH
42405: EMPTY
42406: PPUSH
42407: CALL_OW 1
42411: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
42412: LD_ADDR_EXP 56
42416: PUSH
42417: LD_EXP 56
42421: PPUSH
42422: LD_VAR 0 1
42426: PPUSH
42427: LD_INT 0
42429: PPUSH
42430: CALL_OW 1
42434: ST_TO_ADDR
// end ;
42435: LD_VAR 0 2
42439: RET
// export function MC_Add ( side , units ) ; var base ; begin
42440: LD_INT 0
42442: PPUSH
42443: PPUSH
// base := mc_bases + 1 ;
42444: LD_ADDR_VAR 0 4
42448: PUSH
42449: LD_EXP 14
42453: PUSH
42454: LD_INT 1
42456: PLUS
42457: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
42458: LD_ADDR_EXP 40
42462: PUSH
42463: LD_EXP 40
42467: PPUSH
42468: LD_VAR 0 4
42472: PPUSH
42473: LD_VAR 0 1
42477: PPUSH
42478: CALL_OW 1
42482: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
42483: LD_ADDR_EXP 14
42487: PUSH
42488: LD_EXP 14
42492: PPUSH
42493: LD_VAR 0 4
42497: PPUSH
42498: LD_VAR 0 2
42502: PPUSH
42503: CALL_OW 1
42507: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
42508: LD_ADDR_EXP 15
42512: PUSH
42513: LD_EXP 15
42517: PPUSH
42518: LD_VAR 0 4
42522: PPUSH
42523: EMPTY
42524: PPUSH
42525: CALL_OW 1
42529: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
42530: LD_ADDR_EXP 16
42534: PUSH
42535: LD_EXP 16
42539: PPUSH
42540: LD_VAR 0 4
42544: PPUSH
42545: EMPTY
42546: PPUSH
42547: CALL_OW 1
42551: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
42552: LD_ADDR_EXP 17
42556: PUSH
42557: LD_EXP 17
42561: PPUSH
42562: LD_VAR 0 4
42566: PPUSH
42567: EMPTY
42568: PPUSH
42569: CALL_OW 1
42573: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
42574: LD_ADDR_EXP 18
42578: PUSH
42579: LD_EXP 18
42583: PPUSH
42584: LD_VAR 0 4
42588: PPUSH
42589: EMPTY
42590: PPUSH
42591: CALL_OW 1
42595: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
42596: LD_ADDR_EXP 19
42600: PUSH
42601: LD_EXP 19
42605: PPUSH
42606: LD_VAR 0 4
42610: PPUSH
42611: EMPTY
42612: PPUSH
42613: CALL_OW 1
42617: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
42618: LD_ADDR_EXP 20
42622: PUSH
42623: LD_EXP 20
42627: PPUSH
42628: LD_VAR 0 4
42632: PPUSH
42633: EMPTY
42634: PPUSH
42635: CALL_OW 1
42639: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
42640: LD_ADDR_EXP 21
42644: PUSH
42645: LD_EXP 21
42649: PPUSH
42650: LD_VAR 0 4
42654: PPUSH
42655: EMPTY
42656: PPUSH
42657: CALL_OW 1
42661: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
42662: LD_ADDR_EXP 22
42666: PUSH
42667: LD_EXP 22
42671: PPUSH
42672: LD_VAR 0 4
42676: PPUSH
42677: EMPTY
42678: PPUSH
42679: CALL_OW 1
42683: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
42684: LD_ADDR_EXP 23
42688: PUSH
42689: LD_EXP 23
42693: PPUSH
42694: LD_VAR 0 4
42698: PPUSH
42699: EMPTY
42700: PPUSH
42701: CALL_OW 1
42705: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
42706: LD_ADDR_EXP 24
42710: PUSH
42711: LD_EXP 24
42715: PPUSH
42716: LD_VAR 0 4
42720: PPUSH
42721: EMPTY
42722: PPUSH
42723: CALL_OW 1
42727: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
42728: LD_ADDR_EXP 25
42732: PUSH
42733: LD_EXP 25
42737: PPUSH
42738: LD_VAR 0 4
42742: PPUSH
42743: LD_INT 0
42745: PPUSH
42746: CALL_OW 1
42750: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
42751: LD_ADDR_EXP 26
42755: PUSH
42756: LD_EXP 26
42760: PPUSH
42761: LD_VAR 0 4
42765: PPUSH
42766: EMPTY
42767: PPUSH
42768: CALL_OW 1
42772: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
42773: LD_ADDR_EXP 27
42777: PUSH
42778: LD_EXP 27
42782: PPUSH
42783: LD_VAR 0 4
42787: PPUSH
42788: EMPTY
42789: PPUSH
42790: CALL_OW 1
42794: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
42795: LD_ADDR_EXP 28
42799: PUSH
42800: LD_EXP 28
42804: PPUSH
42805: LD_VAR 0 4
42809: PPUSH
42810: EMPTY
42811: PPUSH
42812: CALL_OW 1
42816: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
42817: LD_ADDR_EXP 29
42821: PUSH
42822: LD_EXP 29
42826: PPUSH
42827: LD_VAR 0 4
42831: PPUSH
42832: EMPTY
42833: PPUSH
42834: CALL_OW 1
42838: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
42839: LD_ADDR_EXP 30
42843: PUSH
42844: LD_EXP 30
42848: PPUSH
42849: LD_VAR 0 4
42853: PPUSH
42854: EMPTY
42855: PPUSH
42856: CALL_OW 1
42860: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
42861: LD_ADDR_EXP 31
42865: PUSH
42866: LD_EXP 31
42870: PPUSH
42871: LD_VAR 0 4
42875: PPUSH
42876: EMPTY
42877: PPUSH
42878: CALL_OW 1
42882: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
42883: LD_ADDR_EXP 32
42887: PUSH
42888: LD_EXP 32
42892: PPUSH
42893: LD_VAR 0 4
42897: PPUSH
42898: EMPTY
42899: PPUSH
42900: CALL_OW 1
42904: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
42905: LD_ADDR_EXP 33
42909: PUSH
42910: LD_EXP 33
42914: PPUSH
42915: LD_VAR 0 4
42919: PPUSH
42920: EMPTY
42921: PPUSH
42922: CALL_OW 1
42926: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
42927: LD_ADDR_EXP 34
42931: PUSH
42932: LD_EXP 34
42936: PPUSH
42937: LD_VAR 0 4
42941: PPUSH
42942: EMPTY
42943: PPUSH
42944: CALL_OW 1
42948: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
42949: LD_ADDR_EXP 35
42953: PUSH
42954: LD_EXP 35
42958: PPUSH
42959: LD_VAR 0 4
42963: PPUSH
42964: EMPTY
42965: PPUSH
42966: CALL_OW 1
42970: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
42971: LD_ADDR_EXP 36
42975: PUSH
42976: LD_EXP 36
42980: PPUSH
42981: LD_VAR 0 4
42985: PPUSH
42986: EMPTY
42987: PPUSH
42988: CALL_OW 1
42992: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
42993: LD_ADDR_EXP 37
42997: PUSH
42998: LD_EXP 37
43002: PPUSH
43003: LD_VAR 0 4
43007: PPUSH
43008: EMPTY
43009: PPUSH
43010: CALL_OW 1
43014: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
43015: LD_ADDR_EXP 38
43019: PUSH
43020: LD_EXP 38
43024: PPUSH
43025: LD_VAR 0 4
43029: PPUSH
43030: EMPTY
43031: PPUSH
43032: CALL_OW 1
43036: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
43037: LD_ADDR_EXP 39
43041: PUSH
43042: LD_EXP 39
43046: PPUSH
43047: LD_VAR 0 4
43051: PPUSH
43052: EMPTY
43053: PPUSH
43054: CALL_OW 1
43058: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
43059: LD_ADDR_EXP 41
43063: PUSH
43064: LD_EXP 41
43068: PPUSH
43069: LD_VAR 0 4
43073: PPUSH
43074: EMPTY
43075: PPUSH
43076: CALL_OW 1
43080: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
43081: LD_ADDR_EXP 43
43085: PUSH
43086: LD_EXP 43
43090: PPUSH
43091: LD_VAR 0 4
43095: PPUSH
43096: EMPTY
43097: PPUSH
43098: CALL_OW 1
43102: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
43103: LD_ADDR_EXP 44
43107: PUSH
43108: LD_EXP 44
43112: PPUSH
43113: LD_VAR 0 4
43117: PPUSH
43118: EMPTY
43119: PPUSH
43120: CALL_OW 1
43124: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
43125: LD_ADDR_EXP 45
43129: PUSH
43130: LD_EXP 45
43134: PPUSH
43135: LD_VAR 0 4
43139: PPUSH
43140: EMPTY
43141: PPUSH
43142: CALL_OW 1
43146: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
43147: LD_ADDR_EXP 46
43151: PUSH
43152: LD_EXP 46
43156: PPUSH
43157: LD_VAR 0 4
43161: PPUSH
43162: EMPTY
43163: PPUSH
43164: CALL_OW 1
43168: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
43169: LD_ADDR_EXP 47
43173: PUSH
43174: LD_EXP 47
43178: PPUSH
43179: LD_VAR 0 4
43183: PPUSH
43184: EMPTY
43185: PPUSH
43186: CALL_OW 1
43190: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
43191: LD_ADDR_EXP 48
43195: PUSH
43196: LD_EXP 48
43200: PPUSH
43201: LD_VAR 0 4
43205: PPUSH
43206: EMPTY
43207: PPUSH
43208: CALL_OW 1
43212: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
43213: LD_ADDR_EXP 49
43217: PUSH
43218: LD_EXP 49
43222: PPUSH
43223: LD_VAR 0 4
43227: PPUSH
43228: EMPTY
43229: PPUSH
43230: CALL_OW 1
43234: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
43235: LD_ADDR_EXP 50
43239: PUSH
43240: LD_EXP 50
43244: PPUSH
43245: LD_VAR 0 4
43249: PPUSH
43250: EMPTY
43251: PPUSH
43252: CALL_OW 1
43256: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
43257: LD_ADDR_EXP 51
43261: PUSH
43262: LD_EXP 51
43266: PPUSH
43267: LD_VAR 0 4
43271: PPUSH
43272: EMPTY
43273: PPUSH
43274: CALL_OW 1
43278: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
43279: LD_ADDR_EXP 52
43283: PUSH
43284: LD_EXP 52
43288: PPUSH
43289: LD_VAR 0 4
43293: PPUSH
43294: EMPTY
43295: PPUSH
43296: CALL_OW 1
43300: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
43301: LD_ADDR_EXP 53
43305: PUSH
43306: LD_EXP 53
43310: PPUSH
43311: LD_VAR 0 4
43315: PPUSH
43316: EMPTY
43317: PPUSH
43318: CALL_OW 1
43322: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
43323: LD_ADDR_EXP 54
43327: PUSH
43328: LD_EXP 54
43332: PPUSH
43333: LD_VAR 0 4
43337: PPUSH
43338: EMPTY
43339: PPUSH
43340: CALL_OW 1
43344: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
43345: LD_ADDR_EXP 55
43349: PUSH
43350: LD_EXP 55
43354: PPUSH
43355: LD_VAR 0 4
43359: PPUSH
43360: EMPTY
43361: PPUSH
43362: CALL_OW 1
43366: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
43367: LD_ADDR_EXP 56
43371: PUSH
43372: LD_EXP 56
43376: PPUSH
43377: LD_VAR 0 4
43381: PPUSH
43382: LD_INT 0
43384: PPUSH
43385: CALL_OW 1
43389: ST_TO_ADDR
// result := base ;
43390: LD_ADDR_VAR 0 3
43394: PUSH
43395: LD_VAR 0 4
43399: ST_TO_ADDR
// end ;
43400: LD_VAR 0 3
43404: RET
// export function MC_Start ( ) ; var i ; begin
43405: LD_INT 0
43407: PPUSH
43408: PPUSH
// for i = 1 to mc_bases do
43409: LD_ADDR_VAR 0 2
43413: PUSH
43414: DOUBLE
43415: LD_INT 1
43417: DEC
43418: ST_TO_ADDR
43419: LD_EXP 14
43423: PUSH
43424: FOR_TO
43425: IFFALSE 44502
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
43427: LD_ADDR_EXP 14
43431: PUSH
43432: LD_EXP 14
43436: PPUSH
43437: LD_VAR 0 2
43441: PPUSH
43442: LD_EXP 14
43446: PUSH
43447: LD_VAR 0 2
43451: ARRAY
43452: PUSH
43453: LD_INT 0
43455: DIFF
43456: PPUSH
43457: CALL_OW 1
43461: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
43462: LD_ADDR_EXP 15
43466: PUSH
43467: LD_EXP 15
43471: PPUSH
43472: LD_VAR 0 2
43476: PPUSH
43477: EMPTY
43478: PPUSH
43479: CALL_OW 1
43483: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
43484: LD_ADDR_EXP 16
43488: PUSH
43489: LD_EXP 16
43493: PPUSH
43494: LD_VAR 0 2
43498: PPUSH
43499: EMPTY
43500: PPUSH
43501: CALL_OW 1
43505: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
43506: LD_ADDR_EXP 17
43510: PUSH
43511: LD_EXP 17
43515: PPUSH
43516: LD_VAR 0 2
43520: PPUSH
43521: EMPTY
43522: PPUSH
43523: CALL_OW 1
43527: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
43528: LD_ADDR_EXP 18
43532: PUSH
43533: LD_EXP 18
43537: PPUSH
43538: LD_VAR 0 2
43542: PPUSH
43543: EMPTY
43544: PUSH
43545: EMPTY
43546: PUSH
43547: EMPTY
43548: LIST
43549: LIST
43550: PPUSH
43551: CALL_OW 1
43555: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
43556: LD_ADDR_EXP 19
43560: PUSH
43561: LD_EXP 19
43565: PPUSH
43566: LD_VAR 0 2
43570: PPUSH
43571: EMPTY
43572: PPUSH
43573: CALL_OW 1
43577: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
43578: LD_ADDR_EXP 46
43582: PUSH
43583: LD_EXP 46
43587: PPUSH
43588: LD_VAR 0 2
43592: PPUSH
43593: EMPTY
43594: PPUSH
43595: CALL_OW 1
43599: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
43600: LD_ADDR_EXP 20
43604: PUSH
43605: LD_EXP 20
43609: PPUSH
43610: LD_VAR 0 2
43614: PPUSH
43615: EMPTY
43616: PPUSH
43617: CALL_OW 1
43621: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
43622: LD_ADDR_EXP 21
43626: PUSH
43627: LD_EXP 21
43631: PPUSH
43632: LD_VAR 0 2
43636: PPUSH
43637: EMPTY
43638: PPUSH
43639: CALL_OW 1
43643: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
43644: LD_ADDR_EXP 22
43648: PUSH
43649: LD_EXP 22
43653: PPUSH
43654: LD_VAR 0 2
43658: PPUSH
43659: LD_EXP 14
43663: PUSH
43664: LD_VAR 0 2
43668: ARRAY
43669: PPUSH
43670: LD_INT 2
43672: PUSH
43673: LD_INT 30
43675: PUSH
43676: LD_INT 32
43678: PUSH
43679: EMPTY
43680: LIST
43681: LIST
43682: PUSH
43683: LD_INT 30
43685: PUSH
43686: LD_INT 33
43688: PUSH
43689: EMPTY
43690: LIST
43691: LIST
43692: PUSH
43693: EMPTY
43694: LIST
43695: LIST
43696: LIST
43697: PPUSH
43698: CALL_OW 72
43702: PPUSH
43703: CALL_OW 1
43707: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
43708: LD_ADDR_EXP 23
43712: PUSH
43713: LD_EXP 23
43717: PPUSH
43718: LD_VAR 0 2
43722: PPUSH
43723: LD_EXP 14
43727: PUSH
43728: LD_VAR 0 2
43732: ARRAY
43733: PPUSH
43734: LD_INT 2
43736: PUSH
43737: LD_INT 30
43739: PUSH
43740: LD_INT 32
43742: PUSH
43743: EMPTY
43744: LIST
43745: LIST
43746: PUSH
43747: LD_INT 30
43749: PUSH
43750: LD_INT 31
43752: PUSH
43753: EMPTY
43754: LIST
43755: LIST
43756: PUSH
43757: EMPTY
43758: LIST
43759: LIST
43760: LIST
43761: PUSH
43762: LD_INT 58
43764: PUSH
43765: EMPTY
43766: LIST
43767: PUSH
43768: EMPTY
43769: LIST
43770: LIST
43771: PPUSH
43772: CALL_OW 72
43776: PPUSH
43777: CALL_OW 1
43781: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
43782: LD_ADDR_EXP 24
43786: PUSH
43787: LD_EXP 24
43791: PPUSH
43792: LD_VAR 0 2
43796: PPUSH
43797: EMPTY
43798: PPUSH
43799: CALL_OW 1
43803: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
43804: LD_ADDR_EXP 28
43808: PUSH
43809: LD_EXP 28
43813: PPUSH
43814: LD_VAR 0 2
43818: PPUSH
43819: EMPTY
43820: PPUSH
43821: CALL_OW 1
43825: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
43826: LD_ADDR_EXP 27
43830: PUSH
43831: LD_EXP 27
43835: PPUSH
43836: LD_VAR 0 2
43840: PPUSH
43841: EMPTY
43842: PPUSH
43843: CALL_OW 1
43847: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
43848: LD_ADDR_EXP 29
43852: PUSH
43853: LD_EXP 29
43857: PPUSH
43858: LD_VAR 0 2
43862: PPUSH
43863: EMPTY
43864: PPUSH
43865: CALL_OW 1
43869: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
43870: LD_ADDR_EXP 30
43874: PUSH
43875: LD_EXP 30
43879: PPUSH
43880: LD_VAR 0 2
43884: PPUSH
43885: EMPTY
43886: PPUSH
43887: CALL_OW 1
43891: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
43892: LD_ADDR_EXP 31
43896: PUSH
43897: LD_EXP 31
43901: PPUSH
43902: LD_VAR 0 2
43906: PPUSH
43907: EMPTY
43908: PPUSH
43909: CALL_OW 1
43913: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
43914: LD_ADDR_EXP 32
43918: PUSH
43919: LD_EXP 32
43923: PPUSH
43924: LD_VAR 0 2
43928: PPUSH
43929: EMPTY
43930: PPUSH
43931: CALL_OW 1
43935: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
43936: LD_ADDR_EXP 33
43940: PUSH
43941: LD_EXP 33
43945: PPUSH
43946: LD_VAR 0 2
43950: PPUSH
43951: EMPTY
43952: PPUSH
43953: CALL_OW 1
43957: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
43958: LD_ADDR_EXP 34
43962: PUSH
43963: LD_EXP 34
43967: PPUSH
43968: LD_VAR 0 2
43972: PPUSH
43973: EMPTY
43974: PPUSH
43975: CALL_OW 1
43979: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
43980: LD_ADDR_EXP 35
43984: PUSH
43985: LD_EXP 35
43989: PPUSH
43990: LD_VAR 0 2
43994: PPUSH
43995: EMPTY
43996: PPUSH
43997: CALL_OW 1
44001: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
44002: LD_ADDR_EXP 36
44006: PUSH
44007: LD_EXP 36
44011: PPUSH
44012: LD_VAR 0 2
44016: PPUSH
44017: EMPTY
44018: PPUSH
44019: CALL_OW 1
44023: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
44024: LD_ADDR_EXP 25
44028: PUSH
44029: LD_EXP 25
44033: PPUSH
44034: LD_VAR 0 2
44038: PPUSH
44039: LD_INT 0
44041: PPUSH
44042: CALL_OW 1
44046: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
44047: LD_ADDR_EXP 38
44051: PUSH
44052: LD_EXP 38
44056: PPUSH
44057: LD_VAR 0 2
44061: PPUSH
44062: LD_INT 0
44064: PPUSH
44065: CALL_OW 1
44069: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
44070: LD_ADDR_EXP 26
44074: PUSH
44075: LD_EXP 26
44079: PPUSH
44080: LD_VAR 0 2
44084: PPUSH
44085: EMPTY
44086: PPUSH
44087: CALL_OW 1
44091: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
44092: LD_ADDR_EXP 37
44096: PUSH
44097: LD_EXP 37
44101: PPUSH
44102: LD_VAR 0 2
44106: PPUSH
44107: LD_INT 0
44109: PPUSH
44110: CALL_OW 1
44114: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
44115: LD_ADDR_EXP 39
44119: PUSH
44120: LD_EXP 39
44124: PPUSH
44125: LD_VAR 0 2
44129: PPUSH
44130: EMPTY
44131: PPUSH
44132: CALL_OW 1
44136: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
44137: LD_ADDR_EXP 42
44141: PUSH
44142: LD_EXP 42
44146: PPUSH
44147: LD_VAR 0 2
44151: PPUSH
44152: LD_INT 0
44154: PPUSH
44155: CALL_OW 1
44159: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
44160: LD_ADDR_EXP 43
44164: PUSH
44165: LD_EXP 43
44169: PPUSH
44170: LD_VAR 0 2
44174: PPUSH
44175: EMPTY
44176: PPUSH
44177: CALL_OW 1
44181: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
44182: LD_ADDR_EXP 44
44186: PUSH
44187: LD_EXP 44
44191: PPUSH
44192: LD_VAR 0 2
44196: PPUSH
44197: EMPTY
44198: PPUSH
44199: CALL_OW 1
44203: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
44204: LD_ADDR_EXP 45
44208: PUSH
44209: LD_EXP 45
44213: PPUSH
44214: LD_VAR 0 2
44218: PPUSH
44219: EMPTY
44220: PPUSH
44221: CALL_OW 1
44225: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
44226: LD_ADDR_EXP 47
44230: PUSH
44231: LD_EXP 47
44235: PPUSH
44236: LD_VAR 0 2
44240: PPUSH
44241: LD_EXP 14
44245: PUSH
44246: LD_VAR 0 2
44250: ARRAY
44251: PPUSH
44252: LD_INT 2
44254: PUSH
44255: LD_INT 30
44257: PUSH
44258: LD_INT 6
44260: PUSH
44261: EMPTY
44262: LIST
44263: LIST
44264: PUSH
44265: LD_INT 30
44267: PUSH
44268: LD_INT 7
44270: PUSH
44271: EMPTY
44272: LIST
44273: LIST
44274: PUSH
44275: LD_INT 30
44277: PUSH
44278: LD_INT 8
44280: PUSH
44281: EMPTY
44282: LIST
44283: LIST
44284: PUSH
44285: EMPTY
44286: LIST
44287: LIST
44288: LIST
44289: LIST
44290: PPUSH
44291: CALL_OW 72
44295: PPUSH
44296: CALL_OW 1
44300: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
44301: LD_ADDR_EXP 48
44305: PUSH
44306: LD_EXP 48
44310: PPUSH
44311: LD_VAR 0 2
44315: PPUSH
44316: EMPTY
44317: PPUSH
44318: CALL_OW 1
44322: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
44323: LD_ADDR_EXP 49
44327: PUSH
44328: LD_EXP 49
44332: PPUSH
44333: LD_VAR 0 2
44337: PPUSH
44338: EMPTY
44339: PPUSH
44340: CALL_OW 1
44344: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
44345: LD_ADDR_EXP 50
44349: PUSH
44350: LD_EXP 50
44354: PPUSH
44355: LD_VAR 0 2
44359: PPUSH
44360: EMPTY
44361: PPUSH
44362: CALL_OW 1
44366: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
44367: LD_ADDR_EXP 51
44371: PUSH
44372: LD_EXP 51
44376: PPUSH
44377: LD_VAR 0 2
44381: PPUSH
44382: EMPTY
44383: PPUSH
44384: CALL_OW 1
44388: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
44389: LD_ADDR_EXP 52
44393: PUSH
44394: LD_EXP 52
44398: PPUSH
44399: LD_VAR 0 2
44403: PPUSH
44404: EMPTY
44405: PPUSH
44406: CALL_OW 1
44410: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
44411: LD_ADDR_EXP 53
44415: PUSH
44416: LD_EXP 53
44420: PPUSH
44421: LD_VAR 0 2
44425: PPUSH
44426: EMPTY
44427: PPUSH
44428: CALL_OW 1
44432: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
44433: LD_ADDR_EXP 54
44437: PUSH
44438: LD_EXP 54
44442: PPUSH
44443: LD_VAR 0 2
44447: PPUSH
44448: EMPTY
44449: PPUSH
44450: CALL_OW 1
44454: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
44455: LD_ADDR_EXP 55
44459: PUSH
44460: LD_EXP 55
44464: PPUSH
44465: LD_VAR 0 2
44469: PPUSH
44470: EMPTY
44471: PPUSH
44472: CALL_OW 1
44476: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
44477: LD_ADDR_EXP 56
44481: PUSH
44482: LD_EXP 56
44486: PPUSH
44487: LD_VAR 0 2
44491: PPUSH
44492: LD_INT 0
44494: PPUSH
44495: CALL_OW 1
44499: ST_TO_ADDR
// end ;
44500: GO 43424
44502: POP
44503: POP
// MC_InitSides ( ) ;
44504: CALL 44790 0 0
// MC_InitResearch ( ) ;
44508: CALL 44529 0 0
// CustomInitMacro ( ) ;
44512: CALL 211 0 0
// skirmish := true ;
44516: LD_ADDR_EXP 12
44520: PUSH
44521: LD_INT 1
44523: ST_TO_ADDR
// end ;
44524: LD_VAR 0 1
44528: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
44529: LD_INT 0
44531: PPUSH
44532: PPUSH
44533: PPUSH
44534: PPUSH
44535: PPUSH
44536: PPUSH
// if not mc_bases then
44537: LD_EXP 14
44541: NOT
44542: IFFALSE 44546
// exit ;
44544: GO 44785
// for i = 1 to 8 do
44546: LD_ADDR_VAR 0 2
44550: PUSH
44551: DOUBLE
44552: LD_INT 1
44554: DEC
44555: ST_TO_ADDR
44556: LD_INT 8
44558: PUSH
44559: FOR_TO
44560: IFFALSE 44586
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
44562: LD_ADDR_EXP 41
44566: PUSH
44567: LD_EXP 41
44571: PPUSH
44572: LD_VAR 0 2
44576: PPUSH
44577: EMPTY
44578: PPUSH
44579: CALL_OW 1
44583: ST_TO_ADDR
44584: GO 44559
44586: POP
44587: POP
// tmp := [ ] ;
44588: LD_ADDR_VAR 0 5
44592: PUSH
44593: EMPTY
44594: ST_TO_ADDR
// for i = 1 to mc_sides do
44595: LD_ADDR_VAR 0 2
44599: PUSH
44600: DOUBLE
44601: LD_INT 1
44603: DEC
44604: ST_TO_ADDR
44605: LD_EXP 40
44609: PUSH
44610: FOR_TO
44611: IFFALSE 44669
// if not mc_sides [ i ] in tmp then
44613: LD_EXP 40
44617: PUSH
44618: LD_VAR 0 2
44622: ARRAY
44623: PUSH
44624: LD_VAR 0 5
44628: IN
44629: NOT
44630: IFFALSE 44667
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
44632: LD_ADDR_VAR 0 5
44636: PUSH
44637: LD_VAR 0 5
44641: PPUSH
44642: LD_VAR 0 5
44646: PUSH
44647: LD_INT 1
44649: PLUS
44650: PPUSH
44651: LD_EXP 40
44655: PUSH
44656: LD_VAR 0 2
44660: ARRAY
44661: PPUSH
44662: CALL_OW 2
44666: ST_TO_ADDR
44667: GO 44610
44669: POP
44670: POP
// if not tmp then
44671: LD_VAR 0 5
44675: NOT
44676: IFFALSE 44680
// exit ;
44678: GO 44785
// for j in tmp do
44680: LD_ADDR_VAR 0 3
44684: PUSH
44685: LD_VAR 0 5
44689: PUSH
44690: FOR_IN
44691: IFFALSE 44783
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
44693: LD_ADDR_VAR 0 6
44697: PUSH
44698: LD_INT 22
44700: PUSH
44701: LD_VAR 0 3
44705: PUSH
44706: EMPTY
44707: LIST
44708: LIST
44709: PPUSH
44710: CALL_OW 69
44714: ST_TO_ADDR
// if not un then
44715: LD_VAR 0 6
44719: NOT
44720: IFFALSE 44724
// continue ;
44722: GO 44690
// nation := GetNation ( un [ 1 ] ) ;
44724: LD_ADDR_VAR 0 4
44728: PUSH
44729: LD_VAR 0 6
44733: PUSH
44734: LD_INT 1
44736: ARRAY
44737: PPUSH
44738: CALL_OW 248
44742: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
44743: LD_ADDR_EXP 41
44747: PUSH
44748: LD_EXP 41
44752: PPUSH
44753: LD_VAR 0 3
44757: PPUSH
44758: LD_VAR 0 3
44762: PPUSH
44763: LD_VAR 0 4
44767: PPUSH
44768: LD_INT 1
44770: PPUSH
44771: CALL 4544 0 3
44775: PPUSH
44776: CALL_OW 1
44780: ST_TO_ADDR
// end ;
44781: GO 44690
44783: POP
44784: POP
// end ;
44785: LD_VAR 0 1
44789: RET
// export function MC_InitSides ( ) ; var i ; begin
44790: LD_INT 0
44792: PPUSH
44793: PPUSH
// if not mc_bases then
44794: LD_EXP 14
44798: NOT
44799: IFFALSE 44803
// exit ;
44801: GO 44877
// for i = 1 to mc_bases do
44803: LD_ADDR_VAR 0 2
44807: PUSH
44808: DOUBLE
44809: LD_INT 1
44811: DEC
44812: ST_TO_ADDR
44813: LD_EXP 14
44817: PUSH
44818: FOR_TO
44819: IFFALSE 44875
// if mc_bases [ i ] then
44821: LD_EXP 14
44825: PUSH
44826: LD_VAR 0 2
44830: ARRAY
44831: IFFALSE 44873
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
44833: LD_ADDR_EXP 40
44837: PUSH
44838: LD_EXP 40
44842: PPUSH
44843: LD_VAR 0 2
44847: PPUSH
44848: LD_EXP 14
44852: PUSH
44853: LD_VAR 0 2
44857: ARRAY
44858: PUSH
44859: LD_INT 1
44861: ARRAY
44862: PPUSH
44863: CALL_OW 255
44867: PPUSH
44868: CALL_OW 1
44872: ST_TO_ADDR
44873: GO 44818
44875: POP
44876: POP
// end ;
44877: LD_VAR 0 1
44881: RET
// every 0 0$01 trigger skirmish do
44882: LD_EXP 12
44886: IFFALSE 45040
44888: GO 44890
44890: DISABLE
// begin enable ;
44891: ENABLE
// MC_CheckBuildings ( ) ;
44892: CALL 49538 0 0
// MC_CheckPeopleLife ( ) ;
44896: CALL 49663 0 0
// RaiseSailEvent ( 100 ) ;
44900: LD_INT 100
44902: PPUSH
44903: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
44907: LD_INT 103
44909: PPUSH
44910: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
44914: LD_INT 104
44916: PPUSH
44917: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
44921: LD_INT 105
44923: PPUSH
44924: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
44928: LD_INT 106
44930: PPUSH
44931: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
44935: LD_INT 107
44937: PPUSH
44938: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
44942: LD_INT 108
44944: PPUSH
44945: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
44949: LD_INT 109
44951: PPUSH
44952: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
44956: LD_INT 110
44958: PPUSH
44959: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
44963: LD_INT 111
44965: PPUSH
44966: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
44970: LD_INT 112
44972: PPUSH
44973: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
44977: LD_INT 113
44979: PPUSH
44980: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
44984: LD_INT 120
44986: PPUSH
44987: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
44991: LD_INT 121
44993: PPUSH
44994: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
44998: LD_INT 122
45000: PPUSH
45001: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
45005: LD_INT 123
45007: PPUSH
45008: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
45012: LD_INT 124
45014: PPUSH
45015: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
45019: LD_INT 125
45021: PPUSH
45022: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
45026: LD_INT 126
45028: PPUSH
45029: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
45033: LD_INT 200
45035: PPUSH
45036: CALL_OW 427
// end ;
45040: END
// on SailEvent ( event ) do begin if event < 100 then
45041: LD_VAR 0 1
45045: PUSH
45046: LD_INT 100
45048: LESS
45049: IFFALSE 45060
// CustomEvent ( event ) ;
45051: LD_VAR 0 1
45055: PPUSH
45056: CALL 4443 0 1
// if event = 100 then
45060: LD_VAR 0 1
45064: PUSH
45065: LD_INT 100
45067: EQUAL
45068: IFFALSE 45074
// MC_ClassManager ( ) ;
45070: CALL 45466 0 0
// if event = 101 then
45074: LD_VAR 0 1
45078: PUSH
45079: LD_INT 101
45081: EQUAL
45082: IFFALSE 45088
// MC_RepairBuildings ( ) ;
45084: CALL 50248 0 0
// if event = 102 then
45088: LD_VAR 0 1
45092: PUSH
45093: LD_INT 102
45095: EQUAL
45096: IFFALSE 45102
// MC_Heal ( ) ;
45098: CALL 51107 0 0
// if event = 103 then
45102: LD_VAR 0 1
45106: PUSH
45107: LD_INT 103
45109: EQUAL
45110: IFFALSE 45116
// MC_Build ( ) ;
45112: CALL 51529 0 0
// if event = 104 then
45116: LD_VAR 0 1
45120: PUSH
45121: LD_INT 104
45123: EQUAL
45124: IFFALSE 45130
// MC_TurretWeapon ( ) ;
45126: CALL 53142 0 0
// if event = 105 then
45130: LD_VAR 0 1
45134: PUSH
45135: LD_INT 105
45137: EQUAL
45138: IFFALSE 45144
// MC_BuildUpgrade ( ) ;
45140: CALL 52693 0 0
// if event = 106 then
45144: LD_VAR 0 1
45148: PUSH
45149: LD_INT 106
45151: EQUAL
45152: IFFALSE 45158
// MC_PlantMines ( ) ;
45154: CALL 53572 0 0
// if event = 107 then
45158: LD_VAR 0 1
45162: PUSH
45163: LD_INT 107
45165: EQUAL
45166: IFFALSE 45172
// MC_CollectCrates ( ) ;
45168: CALL 54370 0 0
// if event = 108 then
45172: LD_VAR 0 1
45176: PUSH
45177: LD_INT 108
45179: EQUAL
45180: IFFALSE 45186
// MC_LinkRemoteControl ( ) ;
45182: CALL 56146 0 0
// if event = 109 then
45186: LD_VAR 0 1
45190: PUSH
45191: LD_INT 109
45193: EQUAL
45194: IFFALSE 45200
// MC_ProduceVehicle ( ) ;
45196: CALL 56327 0 0
// if event = 110 then
45200: LD_VAR 0 1
45204: PUSH
45205: LD_INT 110
45207: EQUAL
45208: IFFALSE 45214
// MC_SendAttack ( ) ;
45210: CALL 56793 0 0
// if event = 111 then
45214: LD_VAR 0 1
45218: PUSH
45219: LD_INT 111
45221: EQUAL
45222: IFFALSE 45228
// MC_Defend ( ) ;
45224: CALL 56901 0 0
// if event = 112 then
45228: LD_VAR 0 1
45232: PUSH
45233: LD_INT 112
45235: EQUAL
45236: IFFALSE 45242
// MC_Research ( ) ;
45238: CALL 57506 0 0
// if event = 113 then
45242: LD_VAR 0 1
45246: PUSH
45247: LD_INT 113
45249: EQUAL
45250: IFFALSE 45256
// MC_MinesTrigger ( ) ;
45252: CALL 58620 0 0
// if event = 120 then
45256: LD_VAR 0 1
45260: PUSH
45261: LD_INT 120
45263: EQUAL
45264: IFFALSE 45270
// MC_RepairVehicle ( ) ;
45266: CALL 58719 0 0
// if event = 121 then
45270: LD_VAR 0 1
45274: PUSH
45275: LD_INT 121
45277: EQUAL
45278: IFFALSE 45284
// MC_TameApe ( ) ;
45280: CALL 59449 0 0
// if event = 122 then
45284: LD_VAR 0 1
45288: PUSH
45289: LD_INT 122
45291: EQUAL
45292: IFFALSE 45298
// MC_ChangeApeClass ( ) ;
45294: CALL 60278 0 0
// if event = 123 then
45298: LD_VAR 0 1
45302: PUSH
45303: LD_INT 123
45305: EQUAL
45306: IFFALSE 45312
// MC_Bazooka ( ) ;
45308: CALL 60928 0 0
// if event = 124 then
45312: LD_VAR 0 1
45316: PUSH
45317: LD_INT 124
45319: EQUAL
45320: IFFALSE 45326
// MC_TeleportExit ( ) ;
45322: CALL 61126 0 0
// if event = 125 then
45326: LD_VAR 0 1
45330: PUSH
45331: LD_INT 125
45333: EQUAL
45334: IFFALSE 45340
// MC_Deposits ( ) ;
45336: CALL 61773 0 0
// if event = 126 then
45340: LD_VAR 0 1
45344: PUSH
45345: LD_INT 126
45347: EQUAL
45348: IFFALSE 45354
// MC_RemoteDriver ( ) ;
45350: CALL 62398 0 0
// if event = 200 then
45354: LD_VAR 0 1
45358: PUSH
45359: LD_INT 200
45361: EQUAL
45362: IFFALSE 45368
// MC_Idle ( ) ;
45364: CALL 64347 0 0
// end ;
45368: PPOPN 1
45370: END
// export function MC_Reset ( base , tag ) ; var i ; begin
45371: LD_INT 0
45373: PPUSH
45374: PPUSH
// if not mc_bases [ base ] or not tag then
45375: LD_EXP 14
45379: PUSH
45380: LD_VAR 0 1
45384: ARRAY
45385: NOT
45386: PUSH
45387: LD_VAR 0 2
45391: NOT
45392: OR
45393: IFFALSE 45397
// exit ;
45395: GO 45461
// for i in mc_bases [ base ] union mc_ape [ base ] do
45397: LD_ADDR_VAR 0 4
45401: PUSH
45402: LD_EXP 14
45406: PUSH
45407: LD_VAR 0 1
45411: ARRAY
45412: PUSH
45413: LD_EXP 43
45417: PUSH
45418: LD_VAR 0 1
45422: ARRAY
45423: UNION
45424: PUSH
45425: FOR_IN
45426: IFFALSE 45459
// if GetTag ( i ) = tag then
45428: LD_VAR 0 4
45432: PPUSH
45433: CALL_OW 110
45437: PUSH
45438: LD_VAR 0 2
45442: EQUAL
45443: IFFALSE 45457
// SetTag ( i , 0 ) ;
45445: LD_VAR 0 4
45449: PPUSH
45450: LD_INT 0
45452: PPUSH
45453: CALL_OW 109
45457: GO 45425
45459: POP
45460: POP
// end ;
45461: LD_VAR 0 3
45465: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
45466: LD_INT 0
45468: PPUSH
45469: PPUSH
45470: PPUSH
45471: PPUSH
45472: PPUSH
45473: PPUSH
45474: PPUSH
45475: PPUSH
// if not mc_bases then
45476: LD_EXP 14
45480: NOT
45481: IFFALSE 45485
// exit ;
45483: GO 45943
// for i = 1 to mc_bases do
45485: LD_ADDR_VAR 0 2
45489: PUSH
45490: DOUBLE
45491: LD_INT 1
45493: DEC
45494: ST_TO_ADDR
45495: LD_EXP 14
45499: PUSH
45500: FOR_TO
45501: IFFALSE 45941
// begin tmp := MC_ClassCheckReq ( i ) ;
45503: LD_ADDR_VAR 0 4
45507: PUSH
45508: LD_VAR 0 2
45512: PPUSH
45513: CALL 45948 0 1
45517: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
45518: LD_ADDR_EXP 55
45522: PUSH
45523: LD_EXP 55
45527: PPUSH
45528: LD_VAR 0 2
45532: PPUSH
45533: LD_VAR 0 4
45537: PPUSH
45538: CALL_OW 1
45542: ST_TO_ADDR
// if not tmp then
45543: LD_VAR 0 4
45547: NOT
45548: IFFALSE 45552
// continue ;
45550: GO 45500
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
45552: LD_ADDR_VAR 0 6
45556: PUSH
45557: LD_EXP 14
45561: PUSH
45562: LD_VAR 0 2
45566: ARRAY
45567: PPUSH
45568: LD_INT 2
45570: PUSH
45571: LD_INT 30
45573: PUSH
45574: LD_INT 4
45576: PUSH
45577: EMPTY
45578: LIST
45579: LIST
45580: PUSH
45581: LD_INT 30
45583: PUSH
45584: LD_INT 5
45586: PUSH
45587: EMPTY
45588: LIST
45589: LIST
45590: PUSH
45591: EMPTY
45592: LIST
45593: LIST
45594: LIST
45595: PPUSH
45596: CALL_OW 72
45600: PUSH
45601: LD_EXP 14
45605: PUSH
45606: LD_VAR 0 2
45610: ARRAY
45611: PPUSH
45612: LD_INT 2
45614: PUSH
45615: LD_INT 30
45617: PUSH
45618: LD_INT 0
45620: PUSH
45621: EMPTY
45622: LIST
45623: LIST
45624: PUSH
45625: LD_INT 30
45627: PUSH
45628: LD_INT 1
45630: PUSH
45631: EMPTY
45632: LIST
45633: LIST
45634: PUSH
45635: EMPTY
45636: LIST
45637: LIST
45638: LIST
45639: PPUSH
45640: CALL_OW 72
45644: PUSH
45645: LD_EXP 14
45649: PUSH
45650: LD_VAR 0 2
45654: ARRAY
45655: PPUSH
45656: LD_INT 30
45658: PUSH
45659: LD_INT 3
45661: PUSH
45662: EMPTY
45663: LIST
45664: LIST
45665: PPUSH
45666: CALL_OW 72
45670: PUSH
45671: LD_EXP 14
45675: PUSH
45676: LD_VAR 0 2
45680: ARRAY
45681: PPUSH
45682: LD_INT 2
45684: PUSH
45685: LD_INT 30
45687: PUSH
45688: LD_INT 6
45690: PUSH
45691: EMPTY
45692: LIST
45693: LIST
45694: PUSH
45695: LD_INT 30
45697: PUSH
45698: LD_INT 7
45700: PUSH
45701: EMPTY
45702: LIST
45703: LIST
45704: PUSH
45705: LD_INT 30
45707: PUSH
45708: LD_INT 8
45710: PUSH
45711: EMPTY
45712: LIST
45713: LIST
45714: PUSH
45715: EMPTY
45716: LIST
45717: LIST
45718: LIST
45719: LIST
45720: PPUSH
45721: CALL_OW 72
45725: PUSH
45726: EMPTY
45727: LIST
45728: LIST
45729: LIST
45730: LIST
45731: ST_TO_ADDR
// for j = 1 to 4 do
45732: LD_ADDR_VAR 0 3
45736: PUSH
45737: DOUBLE
45738: LD_INT 1
45740: DEC
45741: ST_TO_ADDR
45742: LD_INT 4
45744: PUSH
45745: FOR_TO
45746: IFFALSE 45937
// begin if not tmp [ j ] then
45748: LD_VAR 0 4
45752: PUSH
45753: LD_VAR 0 3
45757: ARRAY
45758: NOT
45759: IFFALSE 45763
// continue ;
45761: GO 45745
// for p in tmp [ j ] do
45763: LD_ADDR_VAR 0 5
45767: PUSH
45768: LD_VAR 0 4
45772: PUSH
45773: LD_VAR 0 3
45777: ARRAY
45778: PUSH
45779: FOR_IN
45780: IFFALSE 45933
// begin if not b [ j ] then
45782: LD_VAR 0 6
45786: PUSH
45787: LD_VAR 0 3
45791: ARRAY
45792: NOT
45793: IFFALSE 45797
// break ;
45795: GO 45933
// e := 0 ;
45797: LD_ADDR_VAR 0 7
45801: PUSH
45802: LD_INT 0
45804: ST_TO_ADDR
// for k in b [ j ] do
45805: LD_ADDR_VAR 0 8
45809: PUSH
45810: LD_VAR 0 6
45814: PUSH
45815: LD_VAR 0 3
45819: ARRAY
45820: PUSH
45821: FOR_IN
45822: IFFALSE 45849
// if IsNotFull ( k ) then
45824: LD_VAR 0 8
45828: PPUSH
45829: CALL 6693 0 1
45833: IFFALSE 45847
// begin e := k ;
45835: LD_ADDR_VAR 0 7
45839: PUSH
45840: LD_VAR 0 8
45844: ST_TO_ADDR
// break ;
45845: GO 45849
// end ;
45847: GO 45821
45849: POP
45850: POP
// if e and not UnitGoingToBuilding ( p , e ) then
45851: LD_VAR 0 7
45855: PUSH
45856: LD_VAR 0 5
45860: PPUSH
45861: LD_VAR 0 7
45865: PPUSH
45866: CALL 39113 0 2
45870: NOT
45871: AND
45872: IFFALSE 45931
// begin if IsInUnit ( p ) then
45874: LD_VAR 0 5
45878: PPUSH
45879: CALL_OW 310
45883: IFFALSE 45894
// ComExitBuilding ( p ) ;
45885: LD_VAR 0 5
45889: PPUSH
45890: CALL_OW 122
// ComEnterUnit ( p , e ) ;
45894: LD_VAR 0 5
45898: PPUSH
45899: LD_VAR 0 7
45903: PPUSH
45904: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
45908: LD_VAR 0 5
45912: PPUSH
45913: LD_VAR 0 3
45917: PPUSH
45918: CALL_OW 183
// AddComExitBuilding ( p ) ;
45922: LD_VAR 0 5
45926: PPUSH
45927: CALL_OW 182
// end ; end ;
45931: GO 45779
45933: POP
45934: POP
// end ;
45935: GO 45745
45937: POP
45938: POP
// end ;
45939: GO 45500
45941: POP
45942: POP
// end ;
45943: LD_VAR 0 1
45947: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
45948: LD_INT 0
45950: PPUSH
45951: PPUSH
45952: PPUSH
45953: PPUSH
45954: PPUSH
45955: PPUSH
45956: PPUSH
45957: PPUSH
45958: PPUSH
45959: PPUSH
45960: PPUSH
45961: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
45962: LD_VAR 0 1
45966: NOT
45967: PUSH
45968: LD_EXP 14
45972: PUSH
45973: LD_VAR 0 1
45977: ARRAY
45978: NOT
45979: OR
45980: PUSH
45981: LD_EXP 14
45985: PUSH
45986: LD_VAR 0 1
45990: ARRAY
45991: PPUSH
45992: LD_INT 2
45994: PUSH
45995: LD_INT 30
45997: PUSH
45998: LD_INT 0
46000: PUSH
46001: EMPTY
46002: LIST
46003: LIST
46004: PUSH
46005: LD_INT 30
46007: PUSH
46008: LD_INT 1
46010: PUSH
46011: EMPTY
46012: LIST
46013: LIST
46014: PUSH
46015: EMPTY
46016: LIST
46017: LIST
46018: LIST
46019: PPUSH
46020: CALL_OW 72
46024: NOT
46025: OR
46026: IFFALSE 46030
// exit ;
46028: GO 49533
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
46030: LD_ADDR_VAR 0 4
46034: PUSH
46035: LD_EXP 14
46039: PUSH
46040: LD_VAR 0 1
46044: ARRAY
46045: PPUSH
46046: LD_INT 2
46048: PUSH
46049: LD_INT 25
46051: PUSH
46052: LD_INT 1
46054: PUSH
46055: EMPTY
46056: LIST
46057: LIST
46058: PUSH
46059: LD_INT 25
46061: PUSH
46062: LD_INT 2
46064: PUSH
46065: EMPTY
46066: LIST
46067: LIST
46068: PUSH
46069: LD_INT 25
46071: PUSH
46072: LD_INT 3
46074: PUSH
46075: EMPTY
46076: LIST
46077: LIST
46078: PUSH
46079: LD_INT 25
46081: PUSH
46082: LD_INT 4
46084: PUSH
46085: EMPTY
46086: LIST
46087: LIST
46088: PUSH
46089: LD_INT 25
46091: PUSH
46092: LD_INT 5
46094: PUSH
46095: EMPTY
46096: LIST
46097: LIST
46098: PUSH
46099: LD_INT 25
46101: PUSH
46102: LD_INT 8
46104: PUSH
46105: EMPTY
46106: LIST
46107: LIST
46108: PUSH
46109: LD_INT 25
46111: PUSH
46112: LD_INT 9
46114: PUSH
46115: EMPTY
46116: LIST
46117: LIST
46118: PUSH
46119: EMPTY
46120: LIST
46121: LIST
46122: LIST
46123: LIST
46124: LIST
46125: LIST
46126: LIST
46127: LIST
46128: PPUSH
46129: CALL_OW 72
46133: ST_TO_ADDR
// if not tmp then
46134: LD_VAR 0 4
46138: NOT
46139: IFFALSE 46143
// exit ;
46141: GO 49533
// for i in tmp do
46143: LD_ADDR_VAR 0 3
46147: PUSH
46148: LD_VAR 0 4
46152: PUSH
46153: FOR_IN
46154: IFFALSE 46185
// if GetTag ( i ) then
46156: LD_VAR 0 3
46160: PPUSH
46161: CALL_OW 110
46165: IFFALSE 46183
// tmp := tmp diff i ;
46167: LD_ADDR_VAR 0 4
46171: PUSH
46172: LD_VAR 0 4
46176: PUSH
46177: LD_VAR 0 3
46181: DIFF
46182: ST_TO_ADDR
46183: GO 46153
46185: POP
46186: POP
// if not tmp then
46187: LD_VAR 0 4
46191: NOT
46192: IFFALSE 46196
// exit ;
46194: GO 49533
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
46196: LD_ADDR_VAR 0 5
46200: PUSH
46201: LD_EXP 14
46205: PUSH
46206: LD_VAR 0 1
46210: ARRAY
46211: PPUSH
46212: LD_INT 2
46214: PUSH
46215: LD_INT 25
46217: PUSH
46218: LD_INT 1
46220: PUSH
46221: EMPTY
46222: LIST
46223: LIST
46224: PUSH
46225: LD_INT 25
46227: PUSH
46228: LD_INT 5
46230: PUSH
46231: EMPTY
46232: LIST
46233: LIST
46234: PUSH
46235: LD_INT 25
46237: PUSH
46238: LD_INT 8
46240: PUSH
46241: EMPTY
46242: LIST
46243: LIST
46244: PUSH
46245: LD_INT 25
46247: PUSH
46248: LD_INT 9
46250: PUSH
46251: EMPTY
46252: LIST
46253: LIST
46254: PUSH
46255: EMPTY
46256: LIST
46257: LIST
46258: LIST
46259: LIST
46260: LIST
46261: PPUSH
46262: CALL_OW 72
46266: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
46267: LD_ADDR_VAR 0 6
46271: PUSH
46272: LD_EXP 14
46276: PUSH
46277: LD_VAR 0 1
46281: ARRAY
46282: PPUSH
46283: LD_INT 25
46285: PUSH
46286: LD_INT 2
46288: PUSH
46289: EMPTY
46290: LIST
46291: LIST
46292: PPUSH
46293: CALL_OW 72
46297: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
46298: LD_ADDR_VAR 0 7
46302: PUSH
46303: LD_EXP 14
46307: PUSH
46308: LD_VAR 0 1
46312: ARRAY
46313: PPUSH
46314: LD_INT 25
46316: PUSH
46317: LD_INT 3
46319: PUSH
46320: EMPTY
46321: LIST
46322: LIST
46323: PPUSH
46324: CALL_OW 72
46328: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
46329: LD_ADDR_VAR 0 8
46333: PUSH
46334: LD_EXP 14
46338: PUSH
46339: LD_VAR 0 1
46343: ARRAY
46344: PPUSH
46345: LD_INT 25
46347: PUSH
46348: LD_INT 4
46350: PUSH
46351: EMPTY
46352: LIST
46353: LIST
46354: PUSH
46355: LD_INT 24
46357: PUSH
46358: LD_INT 251
46360: PUSH
46361: EMPTY
46362: LIST
46363: LIST
46364: PUSH
46365: EMPTY
46366: LIST
46367: LIST
46368: PPUSH
46369: CALL_OW 72
46373: ST_TO_ADDR
// if mc_scan [ base ] then
46374: LD_EXP 37
46378: PUSH
46379: LD_VAR 0 1
46383: ARRAY
46384: IFFALSE 46845
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
46386: LD_ADDR_EXP 56
46390: PUSH
46391: LD_EXP 56
46395: PPUSH
46396: LD_VAR 0 1
46400: PPUSH
46401: LD_INT 4
46403: PPUSH
46404: CALL_OW 1
46408: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
46409: LD_ADDR_VAR 0 12
46413: PUSH
46414: LD_EXP 14
46418: PUSH
46419: LD_VAR 0 1
46423: ARRAY
46424: PPUSH
46425: LD_INT 2
46427: PUSH
46428: LD_INT 30
46430: PUSH
46431: LD_INT 4
46433: PUSH
46434: EMPTY
46435: LIST
46436: LIST
46437: PUSH
46438: LD_INT 30
46440: PUSH
46441: LD_INT 5
46443: PUSH
46444: EMPTY
46445: LIST
46446: LIST
46447: PUSH
46448: EMPTY
46449: LIST
46450: LIST
46451: LIST
46452: PPUSH
46453: CALL_OW 72
46457: ST_TO_ADDR
// if not b then
46458: LD_VAR 0 12
46462: NOT
46463: IFFALSE 46467
// exit ;
46465: GO 49533
// p := [ ] ;
46467: LD_ADDR_VAR 0 11
46471: PUSH
46472: EMPTY
46473: ST_TO_ADDR
// if sci >= 2 then
46474: LD_VAR 0 8
46478: PUSH
46479: LD_INT 2
46481: GREATEREQUAL
46482: IFFALSE 46513
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
46484: LD_ADDR_VAR 0 8
46488: PUSH
46489: LD_VAR 0 8
46493: PUSH
46494: LD_INT 1
46496: ARRAY
46497: PUSH
46498: LD_VAR 0 8
46502: PUSH
46503: LD_INT 2
46505: ARRAY
46506: PUSH
46507: EMPTY
46508: LIST
46509: LIST
46510: ST_TO_ADDR
46511: GO 46574
// if sci = 1 then
46513: LD_VAR 0 8
46517: PUSH
46518: LD_INT 1
46520: EQUAL
46521: IFFALSE 46542
// sci := [ sci [ 1 ] ] else
46523: LD_ADDR_VAR 0 8
46527: PUSH
46528: LD_VAR 0 8
46532: PUSH
46533: LD_INT 1
46535: ARRAY
46536: PUSH
46537: EMPTY
46538: LIST
46539: ST_TO_ADDR
46540: GO 46574
// if sci = 0 then
46542: LD_VAR 0 8
46546: PUSH
46547: LD_INT 0
46549: EQUAL
46550: IFFALSE 46574
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
46552: LD_ADDR_VAR 0 11
46556: PUSH
46557: LD_VAR 0 4
46561: PPUSH
46562: LD_INT 4
46564: PPUSH
46565: CALL 38976 0 2
46569: PUSH
46570: LD_INT 1
46572: ARRAY
46573: ST_TO_ADDR
// if eng > 4 then
46574: LD_VAR 0 6
46578: PUSH
46579: LD_INT 4
46581: GREATER
46582: IFFALSE 46628
// for i = eng downto 4 do
46584: LD_ADDR_VAR 0 3
46588: PUSH
46589: DOUBLE
46590: LD_VAR 0 6
46594: INC
46595: ST_TO_ADDR
46596: LD_INT 4
46598: PUSH
46599: FOR_DOWNTO
46600: IFFALSE 46626
// eng := eng diff eng [ i ] ;
46602: LD_ADDR_VAR 0 6
46606: PUSH
46607: LD_VAR 0 6
46611: PUSH
46612: LD_VAR 0 6
46616: PUSH
46617: LD_VAR 0 3
46621: ARRAY
46622: DIFF
46623: ST_TO_ADDR
46624: GO 46599
46626: POP
46627: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
46628: LD_ADDR_VAR 0 4
46632: PUSH
46633: LD_VAR 0 4
46637: PUSH
46638: LD_VAR 0 5
46642: PUSH
46643: LD_VAR 0 6
46647: UNION
46648: PUSH
46649: LD_VAR 0 7
46653: UNION
46654: PUSH
46655: LD_VAR 0 8
46659: UNION
46660: DIFF
46661: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
46662: LD_ADDR_VAR 0 13
46666: PUSH
46667: LD_EXP 14
46671: PUSH
46672: LD_VAR 0 1
46676: ARRAY
46677: PPUSH
46678: LD_INT 2
46680: PUSH
46681: LD_INT 30
46683: PUSH
46684: LD_INT 32
46686: PUSH
46687: EMPTY
46688: LIST
46689: LIST
46690: PUSH
46691: LD_INT 30
46693: PUSH
46694: LD_INT 31
46696: PUSH
46697: EMPTY
46698: LIST
46699: LIST
46700: PUSH
46701: EMPTY
46702: LIST
46703: LIST
46704: LIST
46705: PPUSH
46706: CALL_OW 72
46710: PUSH
46711: LD_EXP 14
46715: PUSH
46716: LD_VAR 0 1
46720: ARRAY
46721: PPUSH
46722: LD_INT 2
46724: PUSH
46725: LD_INT 30
46727: PUSH
46728: LD_INT 4
46730: PUSH
46731: EMPTY
46732: LIST
46733: LIST
46734: PUSH
46735: LD_INT 30
46737: PUSH
46738: LD_INT 5
46740: PUSH
46741: EMPTY
46742: LIST
46743: LIST
46744: PUSH
46745: EMPTY
46746: LIST
46747: LIST
46748: LIST
46749: PPUSH
46750: CALL_OW 72
46754: PUSH
46755: LD_INT 6
46757: MUL
46758: PLUS
46759: ST_TO_ADDR
// if bcount < tmp then
46760: LD_VAR 0 13
46764: PUSH
46765: LD_VAR 0 4
46769: LESS
46770: IFFALSE 46816
// for i = tmp downto bcount do
46772: LD_ADDR_VAR 0 3
46776: PUSH
46777: DOUBLE
46778: LD_VAR 0 4
46782: INC
46783: ST_TO_ADDR
46784: LD_VAR 0 13
46788: PUSH
46789: FOR_DOWNTO
46790: IFFALSE 46814
// tmp := Delete ( tmp , tmp ) ;
46792: LD_ADDR_VAR 0 4
46796: PUSH
46797: LD_VAR 0 4
46801: PPUSH
46802: LD_VAR 0 4
46806: PPUSH
46807: CALL_OW 3
46811: ST_TO_ADDR
46812: GO 46789
46814: POP
46815: POP
// result := [ tmp , 0 , 0 , p ] ;
46816: LD_ADDR_VAR 0 2
46820: PUSH
46821: LD_VAR 0 4
46825: PUSH
46826: LD_INT 0
46828: PUSH
46829: LD_INT 0
46831: PUSH
46832: LD_VAR 0 11
46836: PUSH
46837: EMPTY
46838: LIST
46839: LIST
46840: LIST
46841: LIST
46842: ST_TO_ADDR
// exit ;
46843: GO 49533
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
46845: LD_EXP 14
46849: PUSH
46850: LD_VAR 0 1
46854: ARRAY
46855: PPUSH
46856: LD_INT 2
46858: PUSH
46859: LD_INT 30
46861: PUSH
46862: LD_INT 6
46864: PUSH
46865: EMPTY
46866: LIST
46867: LIST
46868: PUSH
46869: LD_INT 30
46871: PUSH
46872: LD_INT 7
46874: PUSH
46875: EMPTY
46876: LIST
46877: LIST
46878: PUSH
46879: LD_INT 30
46881: PUSH
46882: LD_INT 8
46884: PUSH
46885: EMPTY
46886: LIST
46887: LIST
46888: PUSH
46889: EMPTY
46890: LIST
46891: LIST
46892: LIST
46893: LIST
46894: PPUSH
46895: CALL_OW 72
46899: NOT
46900: PUSH
46901: LD_EXP 14
46905: PUSH
46906: LD_VAR 0 1
46910: ARRAY
46911: PPUSH
46912: LD_INT 30
46914: PUSH
46915: LD_INT 3
46917: PUSH
46918: EMPTY
46919: LIST
46920: LIST
46921: PPUSH
46922: CALL_OW 72
46926: NOT
46927: AND
46928: IFFALSE 47000
// begin if eng = tmp then
46930: LD_VAR 0 6
46934: PUSH
46935: LD_VAR 0 4
46939: EQUAL
46940: IFFALSE 46944
// exit ;
46942: GO 49533
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
46944: LD_ADDR_EXP 56
46948: PUSH
46949: LD_EXP 56
46953: PPUSH
46954: LD_VAR 0 1
46958: PPUSH
46959: LD_INT 1
46961: PPUSH
46962: CALL_OW 1
46966: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
46967: LD_ADDR_VAR 0 2
46971: PUSH
46972: LD_INT 0
46974: PUSH
46975: LD_VAR 0 4
46979: PUSH
46980: LD_VAR 0 6
46984: DIFF
46985: PUSH
46986: LD_INT 0
46988: PUSH
46989: LD_INT 0
46991: PUSH
46992: EMPTY
46993: LIST
46994: LIST
46995: LIST
46996: LIST
46997: ST_TO_ADDR
// exit ;
46998: GO 49533
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
47000: LD_EXP 41
47004: PUSH
47005: LD_EXP 40
47009: PUSH
47010: LD_VAR 0 1
47014: ARRAY
47015: ARRAY
47016: PUSH
47017: LD_EXP 14
47021: PUSH
47022: LD_VAR 0 1
47026: ARRAY
47027: PPUSH
47028: LD_INT 2
47030: PUSH
47031: LD_INT 30
47033: PUSH
47034: LD_INT 6
47036: PUSH
47037: EMPTY
47038: LIST
47039: LIST
47040: PUSH
47041: LD_INT 30
47043: PUSH
47044: LD_INT 7
47046: PUSH
47047: EMPTY
47048: LIST
47049: LIST
47050: PUSH
47051: LD_INT 30
47053: PUSH
47054: LD_INT 8
47056: PUSH
47057: EMPTY
47058: LIST
47059: LIST
47060: PUSH
47061: EMPTY
47062: LIST
47063: LIST
47064: LIST
47065: LIST
47066: PPUSH
47067: CALL_OW 72
47071: AND
47072: PUSH
47073: LD_EXP 14
47077: PUSH
47078: LD_VAR 0 1
47082: ARRAY
47083: PPUSH
47084: LD_INT 30
47086: PUSH
47087: LD_INT 3
47089: PUSH
47090: EMPTY
47091: LIST
47092: LIST
47093: PPUSH
47094: CALL_OW 72
47098: NOT
47099: AND
47100: IFFALSE 47314
// begin if sci >= 6 then
47102: LD_VAR 0 8
47106: PUSH
47107: LD_INT 6
47109: GREATEREQUAL
47110: IFFALSE 47114
// exit ;
47112: GO 49533
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
47114: LD_ADDR_EXP 56
47118: PUSH
47119: LD_EXP 56
47123: PPUSH
47124: LD_VAR 0 1
47128: PPUSH
47129: LD_INT 2
47131: PPUSH
47132: CALL_OW 1
47136: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
47137: LD_ADDR_VAR 0 9
47141: PUSH
47142: LD_VAR 0 4
47146: PUSH
47147: LD_VAR 0 8
47151: DIFF
47152: PPUSH
47153: LD_INT 4
47155: PPUSH
47156: CALL 38976 0 2
47160: ST_TO_ADDR
// p := [ ] ;
47161: LD_ADDR_VAR 0 11
47165: PUSH
47166: EMPTY
47167: ST_TO_ADDR
// if sci < 6 and sort > 6 then
47168: LD_VAR 0 8
47172: PUSH
47173: LD_INT 6
47175: LESS
47176: PUSH
47177: LD_VAR 0 9
47181: PUSH
47182: LD_INT 6
47184: GREATER
47185: AND
47186: IFFALSE 47267
// begin for i = 1 to 6 - sci do
47188: LD_ADDR_VAR 0 3
47192: PUSH
47193: DOUBLE
47194: LD_INT 1
47196: DEC
47197: ST_TO_ADDR
47198: LD_INT 6
47200: PUSH
47201: LD_VAR 0 8
47205: MINUS
47206: PUSH
47207: FOR_TO
47208: IFFALSE 47263
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
47210: LD_ADDR_VAR 0 11
47214: PUSH
47215: LD_VAR 0 11
47219: PPUSH
47220: LD_VAR 0 11
47224: PUSH
47225: LD_INT 1
47227: PLUS
47228: PPUSH
47229: LD_VAR 0 9
47233: PUSH
47234: LD_INT 1
47236: ARRAY
47237: PPUSH
47238: CALL_OW 2
47242: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
47243: LD_ADDR_VAR 0 9
47247: PUSH
47248: LD_VAR 0 9
47252: PPUSH
47253: LD_INT 1
47255: PPUSH
47256: CALL_OW 3
47260: ST_TO_ADDR
// end ;
47261: GO 47207
47263: POP
47264: POP
// end else
47265: GO 47287
// if sort then
47267: LD_VAR 0 9
47271: IFFALSE 47287
// p := sort [ 1 ] ;
47273: LD_ADDR_VAR 0 11
47277: PUSH
47278: LD_VAR 0 9
47282: PUSH
47283: LD_INT 1
47285: ARRAY
47286: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
47287: LD_ADDR_VAR 0 2
47291: PUSH
47292: LD_INT 0
47294: PUSH
47295: LD_INT 0
47297: PUSH
47298: LD_INT 0
47300: PUSH
47301: LD_VAR 0 11
47305: PUSH
47306: EMPTY
47307: LIST
47308: LIST
47309: LIST
47310: LIST
47311: ST_TO_ADDR
// exit ;
47312: GO 49533
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
47314: LD_EXP 41
47318: PUSH
47319: LD_EXP 40
47323: PUSH
47324: LD_VAR 0 1
47328: ARRAY
47329: ARRAY
47330: PUSH
47331: LD_EXP 14
47335: PUSH
47336: LD_VAR 0 1
47340: ARRAY
47341: PPUSH
47342: LD_INT 2
47344: PUSH
47345: LD_INT 30
47347: PUSH
47348: LD_INT 6
47350: PUSH
47351: EMPTY
47352: LIST
47353: LIST
47354: PUSH
47355: LD_INT 30
47357: PUSH
47358: LD_INT 7
47360: PUSH
47361: EMPTY
47362: LIST
47363: LIST
47364: PUSH
47365: LD_INT 30
47367: PUSH
47368: LD_INT 8
47370: PUSH
47371: EMPTY
47372: LIST
47373: LIST
47374: PUSH
47375: EMPTY
47376: LIST
47377: LIST
47378: LIST
47379: LIST
47380: PPUSH
47381: CALL_OW 72
47385: AND
47386: PUSH
47387: LD_EXP 14
47391: PUSH
47392: LD_VAR 0 1
47396: ARRAY
47397: PPUSH
47398: LD_INT 30
47400: PUSH
47401: LD_INT 3
47403: PUSH
47404: EMPTY
47405: LIST
47406: LIST
47407: PPUSH
47408: CALL_OW 72
47412: AND
47413: IFFALSE 48147
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
47415: LD_ADDR_EXP 56
47419: PUSH
47420: LD_EXP 56
47424: PPUSH
47425: LD_VAR 0 1
47429: PPUSH
47430: LD_INT 3
47432: PPUSH
47433: CALL_OW 1
47437: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
47438: LD_ADDR_VAR 0 2
47442: PUSH
47443: LD_INT 0
47445: PUSH
47446: LD_INT 0
47448: PUSH
47449: LD_INT 0
47451: PUSH
47452: LD_INT 0
47454: PUSH
47455: EMPTY
47456: LIST
47457: LIST
47458: LIST
47459: LIST
47460: ST_TO_ADDR
// if not eng then
47461: LD_VAR 0 6
47465: NOT
47466: IFFALSE 47529
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
47468: LD_ADDR_VAR 0 11
47472: PUSH
47473: LD_VAR 0 4
47477: PPUSH
47478: LD_INT 2
47480: PPUSH
47481: CALL 38976 0 2
47485: PUSH
47486: LD_INT 1
47488: ARRAY
47489: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
47490: LD_ADDR_VAR 0 2
47494: PUSH
47495: LD_VAR 0 2
47499: PPUSH
47500: LD_INT 2
47502: PPUSH
47503: LD_VAR 0 11
47507: PPUSH
47508: CALL_OW 1
47512: ST_TO_ADDR
// tmp := tmp diff p ;
47513: LD_ADDR_VAR 0 4
47517: PUSH
47518: LD_VAR 0 4
47522: PUSH
47523: LD_VAR 0 11
47527: DIFF
47528: ST_TO_ADDR
// end ; if tmp and sci < 6 then
47529: LD_VAR 0 4
47533: PUSH
47534: LD_VAR 0 8
47538: PUSH
47539: LD_INT 6
47541: LESS
47542: AND
47543: IFFALSE 47731
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
47545: LD_ADDR_VAR 0 9
47549: PUSH
47550: LD_VAR 0 4
47554: PUSH
47555: LD_VAR 0 8
47559: PUSH
47560: LD_VAR 0 7
47564: UNION
47565: DIFF
47566: PPUSH
47567: LD_INT 4
47569: PPUSH
47570: CALL 38976 0 2
47574: ST_TO_ADDR
// p := [ ] ;
47575: LD_ADDR_VAR 0 11
47579: PUSH
47580: EMPTY
47581: ST_TO_ADDR
// if sort then
47582: LD_VAR 0 9
47586: IFFALSE 47702
// for i = 1 to 6 - sci do
47588: LD_ADDR_VAR 0 3
47592: PUSH
47593: DOUBLE
47594: LD_INT 1
47596: DEC
47597: ST_TO_ADDR
47598: LD_INT 6
47600: PUSH
47601: LD_VAR 0 8
47605: MINUS
47606: PUSH
47607: FOR_TO
47608: IFFALSE 47700
// begin if i = sort then
47610: LD_VAR 0 3
47614: PUSH
47615: LD_VAR 0 9
47619: EQUAL
47620: IFFALSE 47624
// break ;
47622: GO 47700
// if GetClass ( i ) = 4 then
47624: LD_VAR 0 3
47628: PPUSH
47629: CALL_OW 257
47633: PUSH
47634: LD_INT 4
47636: EQUAL
47637: IFFALSE 47641
// continue ;
47639: GO 47607
// p := Insert ( p , p + 1 , sort [ i ] ) ;
47641: LD_ADDR_VAR 0 11
47645: PUSH
47646: LD_VAR 0 11
47650: PPUSH
47651: LD_VAR 0 11
47655: PUSH
47656: LD_INT 1
47658: PLUS
47659: PPUSH
47660: LD_VAR 0 9
47664: PUSH
47665: LD_VAR 0 3
47669: ARRAY
47670: PPUSH
47671: CALL_OW 2
47675: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
47676: LD_ADDR_VAR 0 4
47680: PUSH
47681: LD_VAR 0 4
47685: PUSH
47686: LD_VAR 0 9
47690: PUSH
47691: LD_VAR 0 3
47695: ARRAY
47696: DIFF
47697: ST_TO_ADDR
// end ;
47698: GO 47607
47700: POP
47701: POP
// if p then
47702: LD_VAR 0 11
47706: IFFALSE 47731
// result := Replace ( result , 4 , p ) ;
47708: LD_ADDR_VAR 0 2
47712: PUSH
47713: LD_VAR 0 2
47717: PPUSH
47718: LD_INT 4
47720: PPUSH
47721: LD_VAR 0 11
47725: PPUSH
47726: CALL_OW 1
47730: ST_TO_ADDR
// end ; if tmp and mech < 6 then
47731: LD_VAR 0 4
47735: PUSH
47736: LD_VAR 0 7
47740: PUSH
47741: LD_INT 6
47743: LESS
47744: AND
47745: IFFALSE 47933
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
47747: LD_ADDR_VAR 0 9
47751: PUSH
47752: LD_VAR 0 4
47756: PUSH
47757: LD_VAR 0 8
47761: PUSH
47762: LD_VAR 0 7
47766: UNION
47767: DIFF
47768: PPUSH
47769: LD_INT 3
47771: PPUSH
47772: CALL 38976 0 2
47776: ST_TO_ADDR
// p := [ ] ;
47777: LD_ADDR_VAR 0 11
47781: PUSH
47782: EMPTY
47783: ST_TO_ADDR
// if sort then
47784: LD_VAR 0 9
47788: IFFALSE 47904
// for i = 1 to 6 - mech do
47790: LD_ADDR_VAR 0 3
47794: PUSH
47795: DOUBLE
47796: LD_INT 1
47798: DEC
47799: ST_TO_ADDR
47800: LD_INT 6
47802: PUSH
47803: LD_VAR 0 7
47807: MINUS
47808: PUSH
47809: FOR_TO
47810: IFFALSE 47902
// begin if i = sort then
47812: LD_VAR 0 3
47816: PUSH
47817: LD_VAR 0 9
47821: EQUAL
47822: IFFALSE 47826
// break ;
47824: GO 47902
// if GetClass ( i ) = 3 then
47826: LD_VAR 0 3
47830: PPUSH
47831: CALL_OW 257
47835: PUSH
47836: LD_INT 3
47838: EQUAL
47839: IFFALSE 47843
// continue ;
47841: GO 47809
// p := Insert ( p , p + 1 , sort [ i ] ) ;
47843: LD_ADDR_VAR 0 11
47847: PUSH
47848: LD_VAR 0 11
47852: PPUSH
47853: LD_VAR 0 11
47857: PUSH
47858: LD_INT 1
47860: PLUS
47861: PPUSH
47862: LD_VAR 0 9
47866: PUSH
47867: LD_VAR 0 3
47871: ARRAY
47872: PPUSH
47873: CALL_OW 2
47877: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
47878: LD_ADDR_VAR 0 4
47882: PUSH
47883: LD_VAR 0 4
47887: PUSH
47888: LD_VAR 0 9
47892: PUSH
47893: LD_VAR 0 3
47897: ARRAY
47898: DIFF
47899: ST_TO_ADDR
// end ;
47900: GO 47809
47902: POP
47903: POP
// if p then
47904: LD_VAR 0 11
47908: IFFALSE 47933
// result := Replace ( result , 3 , p ) ;
47910: LD_ADDR_VAR 0 2
47914: PUSH
47915: LD_VAR 0 2
47919: PPUSH
47920: LD_INT 3
47922: PPUSH
47923: LD_VAR 0 11
47927: PPUSH
47928: CALL_OW 1
47932: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
47933: LD_VAR 0 4
47937: PUSH
47938: LD_INT 6
47940: GREATER
47941: PUSH
47942: LD_VAR 0 6
47946: PUSH
47947: LD_INT 6
47949: LESS
47950: AND
47951: IFFALSE 48145
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
47953: LD_ADDR_VAR 0 9
47957: PUSH
47958: LD_VAR 0 4
47962: PUSH
47963: LD_VAR 0 8
47967: PUSH
47968: LD_VAR 0 7
47972: UNION
47973: PUSH
47974: LD_VAR 0 6
47978: UNION
47979: DIFF
47980: PPUSH
47981: LD_INT 2
47983: PPUSH
47984: CALL 38976 0 2
47988: ST_TO_ADDR
// p := [ ] ;
47989: LD_ADDR_VAR 0 11
47993: PUSH
47994: EMPTY
47995: ST_TO_ADDR
// if sort then
47996: LD_VAR 0 9
48000: IFFALSE 48116
// for i = 1 to 6 - eng do
48002: LD_ADDR_VAR 0 3
48006: PUSH
48007: DOUBLE
48008: LD_INT 1
48010: DEC
48011: ST_TO_ADDR
48012: LD_INT 6
48014: PUSH
48015: LD_VAR 0 6
48019: MINUS
48020: PUSH
48021: FOR_TO
48022: IFFALSE 48114
// begin if i = sort then
48024: LD_VAR 0 3
48028: PUSH
48029: LD_VAR 0 9
48033: EQUAL
48034: IFFALSE 48038
// break ;
48036: GO 48114
// if GetClass ( i ) = 2 then
48038: LD_VAR 0 3
48042: PPUSH
48043: CALL_OW 257
48047: PUSH
48048: LD_INT 2
48050: EQUAL
48051: IFFALSE 48055
// continue ;
48053: GO 48021
// p := Insert ( p , p + 1 , sort [ i ] ) ;
48055: LD_ADDR_VAR 0 11
48059: PUSH
48060: LD_VAR 0 11
48064: PPUSH
48065: LD_VAR 0 11
48069: PUSH
48070: LD_INT 1
48072: PLUS
48073: PPUSH
48074: LD_VAR 0 9
48078: PUSH
48079: LD_VAR 0 3
48083: ARRAY
48084: PPUSH
48085: CALL_OW 2
48089: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
48090: LD_ADDR_VAR 0 4
48094: PUSH
48095: LD_VAR 0 4
48099: PUSH
48100: LD_VAR 0 9
48104: PUSH
48105: LD_VAR 0 3
48109: ARRAY
48110: DIFF
48111: ST_TO_ADDR
// end ;
48112: GO 48021
48114: POP
48115: POP
// if p then
48116: LD_VAR 0 11
48120: IFFALSE 48145
// result := Replace ( result , 2 , p ) ;
48122: LD_ADDR_VAR 0 2
48126: PUSH
48127: LD_VAR 0 2
48131: PPUSH
48132: LD_INT 2
48134: PPUSH
48135: LD_VAR 0 11
48139: PPUSH
48140: CALL_OW 1
48144: ST_TO_ADDR
// end ; exit ;
48145: GO 49533
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
48147: LD_EXP 41
48151: PUSH
48152: LD_EXP 40
48156: PUSH
48157: LD_VAR 0 1
48161: ARRAY
48162: ARRAY
48163: NOT
48164: PUSH
48165: LD_EXP 14
48169: PUSH
48170: LD_VAR 0 1
48174: ARRAY
48175: PPUSH
48176: LD_INT 30
48178: PUSH
48179: LD_INT 3
48181: PUSH
48182: EMPTY
48183: LIST
48184: LIST
48185: PPUSH
48186: CALL_OW 72
48190: AND
48191: PUSH
48192: LD_EXP 19
48196: PUSH
48197: LD_VAR 0 1
48201: ARRAY
48202: AND
48203: IFFALSE 48811
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
48205: LD_ADDR_EXP 56
48209: PUSH
48210: LD_EXP 56
48214: PPUSH
48215: LD_VAR 0 1
48219: PPUSH
48220: LD_INT 5
48222: PPUSH
48223: CALL_OW 1
48227: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
48228: LD_ADDR_VAR 0 2
48232: PUSH
48233: LD_INT 0
48235: PUSH
48236: LD_INT 0
48238: PUSH
48239: LD_INT 0
48241: PUSH
48242: LD_INT 0
48244: PUSH
48245: EMPTY
48246: LIST
48247: LIST
48248: LIST
48249: LIST
48250: ST_TO_ADDR
// if sci > 1 then
48251: LD_VAR 0 8
48255: PUSH
48256: LD_INT 1
48258: GREATER
48259: IFFALSE 48287
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
48261: LD_ADDR_VAR 0 4
48265: PUSH
48266: LD_VAR 0 4
48270: PUSH
48271: LD_VAR 0 8
48275: PUSH
48276: LD_VAR 0 8
48280: PUSH
48281: LD_INT 1
48283: ARRAY
48284: DIFF
48285: DIFF
48286: ST_TO_ADDR
// if tmp and not sci then
48287: LD_VAR 0 4
48291: PUSH
48292: LD_VAR 0 8
48296: NOT
48297: AND
48298: IFFALSE 48367
// begin sort := SortBySkill ( tmp , 4 ) ;
48300: LD_ADDR_VAR 0 9
48304: PUSH
48305: LD_VAR 0 4
48309: PPUSH
48310: LD_INT 4
48312: PPUSH
48313: CALL 38976 0 2
48317: ST_TO_ADDR
// if sort then
48318: LD_VAR 0 9
48322: IFFALSE 48338
// p := sort [ 1 ] ;
48324: LD_ADDR_VAR 0 11
48328: PUSH
48329: LD_VAR 0 9
48333: PUSH
48334: LD_INT 1
48336: ARRAY
48337: ST_TO_ADDR
// if p then
48338: LD_VAR 0 11
48342: IFFALSE 48367
// result := Replace ( result , 4 , p ) ;
48344: LD_ADDR_VAR 0 2
48348: PUSH
48349: LD_VAR 0 2
48353: PPUSH
48354: LD_INT 4
48356: PPUSH
48357: LD_VAR 0 11
48361: PPUSH
48362: CALL_OW 1
48366: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
48367: LD_ADDR_VAR 0 4
48371: PUSH
48372: LD_VAR 0 4
48376: PUSH
48377: LD_VAR 0 7
48381: DIFF
48382: ST_TO_ADDR
// if tmp and mech < 6 then
48383: LD_VAR 0 4
48387: PUSH
48388: LD_VAR 0 7
48392: PUSH
48393: LD_INT 6
48395: LESS
48396: AND
48397: IFFALSE 48585
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
48399: LD_ADDR_VAR 0 9
48403: PUSH
48404: LD_VAR 0 4
48408: PUSH
48409: LD_VAR 0 8
48413: PUSH
48414: LD_VAR 0 7
48418: UNION
48419: DIFF
48420: PPUSH
48421: LD_INT 3
48423: PPUSH
48424: CALL 38976 0 2
48428: ST_TO_ADDR
// p := [ ] ;
48429: LD_ADDR_VAR 0 11
48433: PUSH
48434: EMPTY
48435: ST_TO_ADDR
// if sort then
48436: LD_VAR 0 9
48440: IFFALSE 48556
// for i = 1 to 6 - mech do
48442: LD_ADDR_VAR 0 3
48446: PUSH
48447: DOUBLE
48448: LD_INT 1
48450: DEC
48451: ST_TO_ADDR
48452: LD_INT 6
48454: PUSH
48455: LD_VAR 0 7
48459: MINUS
48460: PUSH
48461: FOR_TO
48462: IFFALSE 48554
// begin if i = sort then
48464: LD_VAR 0 3
48468: PUSH
48469: LD_VAR 0 9
48473: EQUAL
48474: IFFALSE 48478
// break ;
48476: GO 48554
// if GetClass ( i ) = 3 then
48478: LD_VAR 0 3
48482: PPUSH
48483: CALL_OW 257
48487: PUSH
48488: LD_INT 3
48490: EQUAL
48491: IFFALSE 48495
// continue ;
48493: GO 48461
// p := Insert ( p , p + 1 , sort [ i ] ) ;
48495: LD_ADDR_VAR 0 11
48499: PUSH
48500: LD_VAR 0 11
48504: PPUSH
48505: LD_VAR 0 11
48509: PUSH
48510: LD_INT 1
48512: PLUS
48513: PPUSH
48514: LD_VAR 0 9
48518: PUSH
48519: LD_VAR 0 3
48523: ARRAY
48524: PPUSH
48525: CALL_OW 2
48529: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
48530: LD_ADDR_VAR 0 4
48534: PUSH
48535: LD_VAR 0 4
48539: PUSH
48540: LD_VAR 0 9
48544: PUSH
48545: LD_VAR 0 3
48549: ARRAY
48550: DIFF
48551: ST_TO_ADDR
// end ;
48552: GO 48461
48554: POP
48555: POP
// if p then
48556: LD_VAR 0 11
48560: IFFALSE 48585
// result := Replace ( result , 3 , p ) ;
48562: LD_ADDR_VAR 0 2
48566: PUSH
48567: LD_VAR 0 2
48571: PPUSH
48572: LD_INT 3
48574: PPUSH
48575: LD_VAR 0 11
48579: PPUSH
48580: CALL_OW 1
48584: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
48585: LD_ADDR_VAR 0 4
48589: PUSH
48590: LD_VAR 0 4
48594: PUSH
48595: LD_VAR 0 6
48599: DIFF
48600: ST_TO_ADDR
// if tmp and eng < 6 then
48601: LD_VAR 0 4
48605: PUSH
48606: LD_VAR 0 6
48610: PUSH
48611: LD_INT 6
48613: LESS
48614: AND
48615: IFFALSE 48809
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
48617: LD_ADDR_VAR 0 9
48621: PUSH
48622: LD_VAR 0 4
48626: PUSH
48627: LD_VAR 0 8
48631: PUSH
48632: LD_VAR 0 7
48636: UNION
48637: PUSH
48638: LD_VAR 0 6
48642: UNION
48643: DIFF
48644: PPUSH
48645: LD_INT 2
48647: PPUSH
48648: CALL 38976 0 2
48652: ST_TO_ADDR
// p := [ ] ;
48653: LD_ADDR_VAR 0 11
48657: PUSH
48658: EMPTY
48659: ST_TO_ADDR
// if sort then
48660: LD_VAR 0 9
48664: IFFALSE 48780
// for i = 1 to 6 - eng do
48666: LD_ADDR_VAR 0 3
48670: PUSH
48671: DOUBLE
48672: LD_INT 1
48674: DEC
48675: ST_TO_ADDR
48676: LD_INT 6
48678: PUSH
48679: LD_VAR 0 6
48683: MINUS
48684: PUSH
48685: FOR_TO
48686: IFFALSE 48778
// begin if i = sort then
48688: LD_VAR 0 3
48692: PUSH
48693: LD_VAR 0 9
48697: EQUAL
48698: IFFALSE 48702
// break ;
48700: GO 48778
// if GetClass ( i ) = 2 then
48702: LD_VAR 0 3
48706: PPUSH
48707: CALL_OW 257
48711: PUSH
48712: LD_INT 2
48714: EQUAL
48715: IFFALSE 48719
// continue ;
48717: GO 48685
// p := Insert ( p , p + 1 , sort [ i ] ) ;
48719: LD_ADDR_VAR 0 11
48723: PUSH
48724: LD_VAR 0 11
48728: PPUSH
48729: LD_VAR 0 11
48733: PUSH
48734: LD_INT 1
48736: PLUS
48737: PPUSH
48738: LD_VAR 0 9
48742: PUSH
48743: LD_VAR 0 3
48747: ARRAY
48748: PPUSH
48749: CALL_OW 2
48753: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
48754: LD_ADDR_VAR 0 4
48758: PUSH
48759: LD_VAR 0 4
48763: PUSH
48764: LD_VAR 0 9
48768: PUSH
48769: LD_VAR 0 3
48773: ARRAY
48774: DIFF
48775: ST_TO_ADDR
// end ;
48776: GO 48685
48778: POP
48779: POP
// if p then
48780: LD_VAR 0 11
48784: IFFALSE 48809
// result := Replace ( result , 2 , p ) ;
48786: LD_ADDR_VAR 0 2
48790: PUSH
48791: LD_VAR 0 2
48795: PPUSH
48796: LD_INT 2
48798: PPUSH
48799: LD_VAR 0 11
48803: PPUSH
48804: CALL_OW 1
48808: ST_TO_ADDR
// end ; exit ;
48809: GO 49533
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
48811: LD_EXP 41
48815: PUSH
48816: LD_EXP 40
48820: PUSH
48821: LD_VAR 0 1
48825: ARRAY
48826: ARRAY
48827: NOT
48828: PUSH
48829: LD_EXP 14
48833: PUSH
48834: LD_VAR 0 1
48838: ARRAY
48839: PPUSH
48840: LD_INT 30
48842: PUSH
48843: LD_INT 3
48845: PUSH
48846: EMPTY
48847: LIST
48848: LIST
48849: PPUSH
48850: CALL_OW 72
48854: AND
48855: PUSH
48856: LD_EXP 19
48860: PUSH
48861: LD_VAR 0 1
48865: ARRAY
48866: NOT
48867: AND
48868: IFFALSE 49533
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
48870: LD_ADDR_EXP 56
48874: PUSH
48875: LD_EXP 56
48879: PPUSH
48880: LD_VAR 0 1
48884: PPUSH
48885: LD_INT 6
48887: PPUSH
48888: CALL_OW 1
48892: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
48893: LD_ADDR_VAR 0 2
48897: PUSH
48898: LD_INT 0
48900: PUSH
48901: LD_INT 0
48903: PUSH
48904: LD_INT 0
48906: PUSH
48907: LD_INT 0
48909: PUSH
48910: EMPTY
48911: LIST
48912: LIST
48913: LIST
48914: LIST
48915: ST_TO_ADDR
// if sci >= 1 then
48916: LD_VAR 0 8
48920: PUSH
48921: LD_INT 1
48923: GREATEREQUAL
48924: IFFALSE 48946
// tmp := tmp diff sci [ 1 ] ;
48926: LD_ADDR_VAR 0 4
48930: PUSH
48931: LD_VAR 0 4
48935: PUSH
48936: LD_VAR 0 8
48940: PUSH
48941: LD_INT 1
48943: ARRAY
48944: DIFF
48945: ST_TO_ADDR
// if tmp and not sci then
48946: LD_VAR 0 4
48950: PUSH
48951: LD_VAR 0 8
48955: NOT
48956: AND
48957: IFFALSE 49026
// begin sort := SortBySkill ( tmp , 4 ) ;
48959: LD_ADDR_VAR 0 9
48963: PUSH
48964: LD_VAR 0 4
48968: PPUSH
48969: LD_INT 4
48971: PPUSH
48972: CALL 38976 0 2
48976: ST_TO_ADDR
// if sort then
48977: LD_VAR 0 9
48981: IFFALSE 48997
// p := sort [ 1 ] ;
48983: LD_ADDR_VAR 0 11
48987: PUSH
48988: LD_VAR 0 9
48992: PUSH
48993: LD_INT 1
48995: ARRAY
48996: ST_TO_ADDR
// if p then
48997: LD_VAR 0 11
49001: IFFALSE 49026
// result := Replace ( result , 4 , p ) ;
49003: LD_ADDR_VAR 0 2
49007: PUSH
49008: LD_VAR 0 2
49012: PPUSH
49013: LD_INT 4
49015: PPUSH
49016: LD_VAR 0 11
49020: PPUSH
49021: CALL_OW 1
49025: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
49026: LD_ADDR_VAR 0 4
49030: PUSH
49031: LD_VAR 0 4
49035: PUSH
49036: LD_VAR 0 7
49040: DIFF
49041: ST_TO_ADDR
// if tmp and mech < 6 then
49042: LD_VAR 0 4
49046: PUSH
49047: LD_VAR 0 7
49051: PUSH
49052: LD_INT 6
49054: LESS
49055: AND
49056: IFFALSE 49238
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
49058: LD_ADDR_VAR 0 9
49062: PUSH
49063: LD_VAR 0 4
49067: PUSH
49068: LD_VAR 0 7
49072: DIFF
49073: PPUSH
49074: LD_INT 3
49076: PPUSH
49077: CALL 38976 0 2
49081: ST_TO_ADDR
// p := [ ] ;
49082: LD_ADDR_VAR 0 11
49086: PUSH
49087: EMPTY
49088: ST_TO_ADDR
// if sort then
49089: LD_VAR 0 9
49093: IFFALSE 49209
// for i = 1 to 6 - mech do
49095: LD_ADDR_VAR 0 3
49099: PUSH
49100: DOUBLE
49101: LD_INT 1
49103: DEC
49104: ST_TO_ADDR
49105: LD_INT 6
49107: PUSH
49108: LD_VAR 0 7
49112: MINUS
49113: PUSH
49114: FOR_TO
49115: IFFALSE 49207
// begin if i = sort then
49117: LD_VAR 0 3
49121: PUSH
49122: LD_VAR 0 9
49126: EQUAL
49127: IFFALSE 49131
// break ;
49129: GO 49207
// if GetClass ( i ) = 3 then
49131: LD_VAR 0 3
49135: PPUSH
49136: CALL_OW 257
49140: PUSH
49141: LD_INT 3
49143: EQUAL
49144: IFFALSE 49148
// continue ;
49146: GO 49114
// p := Insert ( p , p + 1 , sort [ i ] ) ;
49148: LD_ADDR_VAR 0 11
49152: PUSH
49153: LD_VAR 0 11
49157: PPUSH
49158: LD_VAR 0 11
49162: PUSH
49163: LD_INT 1
49165: PLUS
49166: PPUSH
49167: LD_VAR 0 9
49171: PUSH
49172: LD_VAR 0 3
49176: ARRAY
49177: PPUSH
49178: CALL_OW 2
49182: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
49183: LD_ADDR_VAR 0 4
49187: PUSH
49188: LD_VAR 0 4
49192: PUSH
49193: LD_VAR 0 9
49197: PUSH
49198: LD_VAR 0 3
49202: ARRAY
49203: DIFF
49204: ST_TO_ADDR
// end ;
49205: GO 49114
49207: POP
49208: POP
// if p then
49209: LD_VAR 0 11
49213: IFFALSE 49238
// result := Replace ( result , 3 , p ) ;
49215: LD_ADDR_VAR 0 2
49219: PUSH
49220: LD_VAR 0 2
49224: PPUSH
49225: LD_INT 3
49227: PPUSH
49228: LD_VAR 0 11
49232: PPUSH
49233: CALL_OW 1
49237: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
49238: LD_ADDR_VAR 0 4
49242: PUSH
49243: LD_VAR 0 4
49247: PUSH
49248: LD_VAR 0 6
49252: DIFF
49253: ST_TO_ADDR
// if tmp and eng < 4 then
49254: LD_VAR 0 4
49258: PUSH
49259: LD_VAR 0 6
49263: PUSH
49264: LD_INT 4
49266: LESS
49267: AND
49268: IFFALSE 49458
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
49270: LD_ADDR_VAR 0 9
49274: PUSH
49275: LD_VAR 0 4
49279: PUSH
49280: LD_VAR 0 7
49284: PUSH
49285: LD_VAR 0 6
49289: UNION
49290: DIFF
49291: PPUSH
49292: LD_INT 2
49294: PPUSH
49295: CALL 38976 0 2
49299: ST_TO_ADDR
// p := [ ] ;
49300: LD_ADDR_VAR 0 11
49304: PUSH
49305: EMPTY
49306: ST_TO_ADDR
// if sort then
49307: LD_VAR 0 9
49311: IFFALSE 49427
// for i = 1 to 4 - eng do
49313: LD_ADDR_VAR 0 3
49317: PUSH
49318: DOUBLE
49319: LD_INT 1
49321: DEC
49322: ST_TO_ADDR
49323: LD_INT 4
49325: PUSH
49326: LD_VAR 0 6
49330: MINUS
49331: PUSH
49332: FOR_TO
49333: IFFALSE 49425
// begin if i = sort then
49335: LD_VAR 0 3
49339: PUSH
49340: LD_VAR 0 9
49344: EQUAL
49345: IFFALSE 49349
// break ;
49347: GO 49425
// if GetClass ( i ) = 2 then
49349: LD_VAR 0 3
49353: PPUSH
49354: CALL_OW 257
49358: PUSH
49359: LD_INT 2
49361: EQUAL
49362: IFFALSE 49366
// continue ;
49364: GO 49332
// p := Insert ( p , p + 1 , sort [ i ] ) ;
49366: LD_ADDR_VAR 0 11
49370: PUSH
49371: LD_VAR 0 11
49375: PPUSH
49376: LD_VAR 0 11
49380: PUSH
49381: LD_INT 1
49383: PLUS
49384: PPUSH
49385: LD_VAR 0 9
49389: PUSH
49390: LD_VAR 0 3
49394: ARRAY
49395: PPUSH
49396: CALL_OW 2
49400: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
49401: LD_ADDR_VAR 0 4
49405: PUSH
49406: LD_VAR 0 4
49410: PUSH
49411: LD_VAR 0 9
49415: PUSH
49416: LD_VAR 0 3
49420: ARRAY
49421: DIFF
49422: ST_TO_ADDR
// end ;
49423: GO 49332
49425: POP
49426: POP
// if p then
49427: LD_VAR 0 11
49431: IFFALSE 49456
// result := Replace ( result , 2 , p ) ;
49433: LD_ADDR_VAR 0 2
49437: PUSH
49438: LD_VAR 0 2
49442: PPUSH
49443: LD_INT 2
49445: PPUSH
49446: LD_VAR 0 11
49450: PPUSH
49451: CALL_OW 1
49455: ST_TO_ADDR
// end else
49456: GO 49502
// for i = eng downto 5 do
49458: LD_ADDR_VAR 0 3
49462: PUSH
49463: DOUBLE
49464: LD_VAR 0 6
49468: INC
49469: ST_TO_ADDR
49470: LD_INT 5
49472: PUSH
49473: FOR_DOWNTO
49474: IFFALSE 49500
// tmp := tmp union eng [ i ] ;
49476: LD_ADDR_VAR 0 4
49480: PUSH
49481: LD_VAR 0 4
49485: PUSH
49486: LD_VAR 0 6
49490: PUSH
49491: LD_VAR 0 3
49495: ARRAY
49496: UNION
49497: ST_TO_ADDR
49498: GO 49473
49500: POP
49501: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
49502: LD_ADDR_VAR 0 2
49506: PUSH
49507: LD_VAR 0 2
49511: PPUSH
49512: LD_INT 1
49514: PPUSH
49515: LD_VAR 0 4
49519: PUSH
49520: LD_VAR 0 5
49524: DIFF
49525: PPUSH
49526: CALL_OW 1
49530: ST_TO_ADDR
// exit ;
49531: GO 49533
// end ; end ;
49533: LD_VAR 0 2
49537: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
49538: LD_INT 0
49540: PPUSH
49541: PPUSH
49542: PPUSH
// if not mc_bases then
49543: LD_EXP 14
49547: NOT
49548: IFFALSE 49552
// exit ;
49550: GO 49658
// for i = 1 to mc_bases do
49552: LD_ADDR_VAR 0 2
49556: PUSH
49557: DOUBLE
49558: LD_INT 1
49560: DEC
49561: ST_TO_ADDR
49562: LD_EXP 14
49566: PUSH
49567: FOR_TO
49568: IFFALSE 49649
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
49570: LD_ADDR_VAR 0 3
49574: PUSH
49575: LD_EXP 14
49579: PUSH
49580: LD_VAR 0 2
49584: ARRAY
49585: PPUSH
49586: LD_INT 21
49588: PUSH
49589: LD_INT 3
49591: PUSH
49592: EMPTY
49593: LIST
49594: LIST
49595: PUSH
49596: LD_INT 3
49598: PUSH
49599: LD_INT 24
49601: PUSH
49602: LD_INT 1000
49604: PUSH
49605: EMPTY
49606: LIST
49607: LIST
49608: PUSH
49609: EMPTY
49610: LIST
49611: LIST
49612: PUSH
49613: EMPTY
49614: LIST
49615: LIST
49616: PPUSH
49617: CALL_OW 72
49621: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
49622: LD_ADDR_EXP 15
49626: PUSH
49627: LD_EXP 15
49631: PPUSH
49632: LD_VAR 0 2
49636: PPUSH
49637: LD_VAR 0 3
49641: PPUSH
49642: CALL_OW 1
49646: ST_TO_ADDR
// end ;
49647: GO 49567
49649: POP
49650: POP
// RaiseSailEvent ( 101 ) ;
49651: LD_INT 101
49653: PPUSH
49654: CALL_OW 427
// end ;
49658: LD_VAR 0 1
49662: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
49663: LD_INT 0
49665: PPUSH
49666: PPUSH
49667: PPUSH
49668: PPUSH
49669: PPUSH
49670: PPUSH
49671: PPUSH
// if not mc_bases then
49672: LD_EXP 14
49676: NOT
49677: IFFALSE 49681
// exit ;
49679: GO 50243
// for i = 1 to mc_bases do
49681: LD_ADDR_VAR 0 2
49685: PUSH
49686: DOUBLE
49687: LD_INT 1
49689: DEC
49690: ST_TO_ADDR
49691: LD_EXP 14
49695: PUSH
49696: FOR_TO
49697: IFFALSE 50234
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
49699: LD_ADDR_VAR 0 5
49703: PUSH
49704: LD_EXP 14
49708: PUSH
49709: LD_VAR 0 2
49713: ARRAY
49714: PUSH
49715: LD_EXP 43
49719: PUSH
49720: LD_VAR 0 2
49724: ARRAY
49725: UNION
49726: PPUSH
49727: LD_INT 21
49729: PUSH
49730: LD_INT 1
49732: PUSH
49733: EMPTY
49734: LIST
49735: LIST
49736: PUSH
49737: LD_INT 1
49739: PUSH
49740: LD_INT 3
49742: PUSH
49743: LD_INT 54
49745: PUSH
49746: EMPTY
49747: LIST
49748: PUSH
49749: EMPTY
49750: LIST
49751: LIST
49752: PUSH
49753: LD_INT 3
49755: PUSH
49756: LD_INT 24
49758: PUSH
49759: LD_INT 800
49761: PUSH
49762: EMPTY
49763: LIST
49764: LIST
49765: PUSH
49766: EMPTY
49767: LIST
49768: LIST
49769: PUSH
49770: EMPTY
49771: LIST
49772: LIST
49773: LIST
49774: PUSH
49775: EMPTY
49776: LIST
49777: LIST
49778: PPUSH
49779: CALL_OW 72
49783: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
49784: LD_ADDR_VAR 0 6
49788: PUSH
49789: LD_EXP 14
49793: PUSH
49794: LD_VAR 0 2
49798: ARRAY
49799: PPUSH
49800: LD_INT 21
49802: PUSH
49803: LD_INT 1
49805: PUSH
49806: EMPTY
49807: LIST
49808: LIST
49809: PUSH
49810: LD_INT 1
49812: PUSH
49813: LD_INT 3
49815: PUSH
49816: LD_INT 54
49818: PUSH
49819: EMPTY
49820: LIST
49821: PUSH
49822: EMPTY
49823: LIST
49824: LIST
49825: PUSH
49826: LD_INT 3
49828: PUSH
49829: LD_INT 24
49831: PUSH
49832: LD_INT 250
49834: PUSH
49835: EMPTY
49836: LIST
49837: LIST
49838: PUSH
49839: EMPTY
49840: LIST
49841: LIST
49842: PUSH
49843: EMPTY
49844: LIST
49845: LIST
49846: LIST
49847: PUSH
49848: EMPTY
49849: LIST
49850: LIST
49851: PPUSH
49852: CALL_OW 72
49856: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
49857: LD_ADDR_VAR 0 7
49861: PUSH
49862: LD_VAR 0 5
49866: PUSH
49867: LD_VAR 0 6
49871: DIFF
49872: ST_TO_ADDR
// if not need_heal_1 then
49873: LD_VAR 0 6
49877: NOT
49878: IFFALSE 49911
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
49880: LD_ADDR_EXP 17
49884: PUSH
49885: LD_EXP 17
49889: PPUSH
49890: LD_VAR 0 2
49894: PUSH
49895: LD_INT 1
49897: PUSH
49898: EMPTY
49899: LIST
49900: LIST
49901: PPUSH
49902: EMPTY
49903: PPUSH
49904: CALL 9427 0 3
49908: ST_TO_ADDR
49909: GO 49981
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
49911: LD_ADDR_EXP 17
49915: PUSH
49916: LD_EXP 17
49920: PPUSH
49921: LD_VAR 0 2
49925: PUSH
49926: LD_INT 1
49928: PUSH
49929: EMPTY
49930: LIST
49931: LIST
49932: PPUSH
49933: LD_EXP 17
49937: PUSH
49938: LD_VAR 0 2
49942: ARRAY
49943: PUSH
49944: LD_INT 1
49946: ARRAY
49947: PPUSH
49948: LD_INT 3
49950: PUSH
49951: LD_INT 24
49953: PUSH
49954: LD_INT 1000
49956: PUSH
49957: EMPTY
49958: LIST
49959: LIST
49960: PUSH
49961: EMPTY
49962: LIST
49963: LIST
49964: PPUSH
49965: CALL_OW 72
49969: PUSH
49970: LD_VAR 0 6
49974: UNION
49975: PPUSH
49976: CALL 9427 0 3
49980: ST_TO_ADDR
// if not need_heal_2 then
49981: LD_VAR 0 7
49985: NOT
49986: IFFALSE 50019
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
49988: LD_ADDR_EXP 17
49992: PUSH
49993: LD_EXP 17
49997: PPUSH
49998: LD_VAR 0 2
50002: PUSH
50003: LD_INT 2
50005: PUSH
50006: EMPTY
50007: LIST
50008: LIST
50009: PPUSH
50010: EMPTY
50011: PPUSH
50012: CALL 9427 0 3
50016: ST_TO_ADDR
50017: GO 50051
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
50019: LD_ADDR_EXP 17
50023: PUSH
50024: LD_EXP 17
50028: PPUSH
50029: LD_VAR 0 2
50033: PUSH
50034: LD_INT 2
50036: PUSH
50037: EMPTY
50038: LIST
50039: LIST
50040: PPUSH
50041: LD_VAR 0 7
50045: PPUSH
50046: CALL 9427 0 3
50050: ST_TO_ADDR
// if need_heal_2 then
50051: LD_VAR 0 7
50055: IFFALSE 50216
// for j in need_heal_2 do
50057: LD_ADDR_VAR 0 3
50061: PUSH
50062: LD_VAR 0 7
50066: PUSH
50067: FOR_IN
50068: IFFALSE 50214
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
50070: LD_ADDR_VAR 0 5
50074: PUSH
50075: LD_EXP 14
50079: PUSH
50080: LD_VAR 0 2
50084: ARRAY
50085: PPUSH
50086: LD_INT 2
50088: PUSH
50089: LD_INT 30
50091: PUSH
50092: LD_INT 6
50094: PUSH
50095: EMPTY
50096: LIST
50097: LIST
50098: PUSH
50099: LD_INT 30
50101: PUSH
50102: LD_INT 7
50104: PUSH
50105: EMPTY
50106: LIST
50107: LIST
50108: PUSH
50109: LD_INT 30
50111: PUSH
50112: LD_INT 8
50114: PUSH
50115: EMPTY
50116: LIST
50117: LIST
50118: PUSH
50119: LD_INT 30
50121: PUSH
50122: LD_INT 0
50124: PUSH
50125: EMPTY
50126: LIST
50127: LIST
50128: PUSH
50129: LD_INT 30
50131: PUSH
50132: LD_INT 1
50134: PUSH
50135: EMPTY
50136: LIST
50137: LIST
50138: PUSH
50139: EMPTY
50140: LIST
50141: LIST
50142: LIST
50143: LIST
50144: LIST
50145: LIST
50146: PPUSH
50147: CALL_OW 72
50151: ST_TO_ADDR
// if tmp then
50152: LD_VAR 0 5
50156: IFFALSE 50212
// begin k := NearestUnitToUnit ( tmp , j ) ;
50158: LD_ADDR_VAR 0 4
50162: PUSH
50163: LD_VAR 0 5
50167: PPUSH
50168: LD_VAR 0 3
50172: PPUSH
50173: CALL_OW 74
50177: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
50178: LD_VAR 0 3
50182: PPUSH
50183: LD_VAR 0 4
50187: PPUSH
50188: CALL_OW 296
50192: PUSH
50193: LD_INT 5
50195: GREATER
50196: IFFALSE 50212
// ComMoveUnit ( j , k ) ;
50198: LD_VAR 0 3
50202: PPUSH
50203: LD_VAR 0 4
50207: PPUSH
50208: CALL_OW 112
// end ; end ;
50212: GO 50067
50214: POP
50215: POP
// if not need_heal_1 and not need_heal_2 then
50216: LD_VAR 0 6
50220: NOT
50221: PUSH
50222: LD_VAR 0 7
50226: NOT
50227: AND
50228: IFFALSE 50232
// continue ;
50230: GO 49696
// end ;
50232: GO 49696
50234: POP
50235: POP
// RaiseSailEvent ( 102 ) ;
50236: LD_INT 102
50238: PPUSH
50239: CALL_OW 427
// end ;
50243: LD_VAR 0 1
50247: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
50248: LD_INT 0
50250: PPUSH
50251: PPUSH
50252: PPUSH
50253: PPUSH
50254: PPUSH
50255: PPUSH
50256: PPUSH
50257: PPUSH
// if not mc_bases then
50258: LD_EXP 14
50262: NOT
50263: IFFALSE 50267
// exit ;
50265: GO 51102
// for i = 1 to mc_bases do
50267: LD_ADDR_VAR 0 2
50271: PUSH
50272: DOUBLE
50273: LD_INT 1
50275: DEC
50276: ST_TO_ADDR
50277: LD_EXP 14
50281: PUSH
50282: FOR_TO
50283: IFFALSE 51100
// begin if not mc_building_need_repair [ i ] then
50285: LD_EXP 15
50289: PUSH
50290: LD_VAR 0 2
50294: ARRAY
50295: NOT
50296: IFFALSE 50470
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
50298: LD_ADDR_VAR 0 6
50302: PUSH
50303: LD_EXP 33
50307: PUSH
50308: LD_VAR 0 2
50312: ARRAY
50313: PPUSH
50314: LD_INT 3
50316: PUSH
50317: LD_INT 24
50319: PUSH
50320: LD_INT 1000
50322: PUSH
50323: EMPTY
50324: LIST
50325: LIST
50326: PUSH
50327: EMPTY
50328: LIST
50329: LIST
50330: PUSH
50331: LD_INT 2
50333: PUSH
50334: LD_INT 34
50336: PUSH
50337: LD_INT 13
50339: PUSH
50340: EMPTY
50341: LIST
50342: LIST
50343: PUSH
50344: LD_INT 34
50346: PUSH
50347: LD_INT 52
50349: PUSH
50350: EMPTY
50351: LIST
50352: LIST
50353: PUSH
50354: EMPTY
50355: LIST
50356: LIST
50357: LIST
50358: PUSH
50359: EMPTY
50360: LIST
50361: LIST
50362: PPUSH
50363: CALL_OW 72
50367: ST_TO_ADDR
// if cranes then
50368: LD_VAR 0 6
50372: IFFALSE 50434
// for j in cranes do
50374: LD_ADDR_VAR 0 3
50378: PUSH
50379: LD_VAR 0 6
50383: PUSH
50384: FOR_IN
50385: IFFALSE 50432
// if not IsInArea ( j , mc_parking [ i ] ) then
50387: LD_VAR 0 3
50391: PPUSH
50392: LD_EXP 38
50396: PUSH
50397: LD_VAR 0 2
50401: ARRAY
50402: PPUSH
50403: CALL_OW 308
50407: NOT
50408: IFFALSE 50430
// ComMoveToArea ( j , mc_parking [ i ] ) ;
50410: LD_VAR 0 3
50414: PPUSH
50415: LD_EXP 38
50419: PUSH
50420: LD_VAR 0 2
50424: ARRAY
50425: PPUSH
50426: CALL_OW 113
50430: GO 50384
50432: POP
50433: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
50434: LD_ADDR_EXP 16
50438: PUSH
50439: LD_EXP 16
50443: PPUSH
50444: LD_VAR 0 2
50448: PPUSH
50449: EMPTY
50450: PPUSH
50451: CALL_OW 1
50455: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
50456: LD_VAR 0 2
50460: PPUSH
50461: LD_INT 101
50463: PPUSH
50464: CALL 45371 0 2
// continue ;
50468: GO 50282
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
50470: LD_ADDR_EXP 20
50474: PUSH
50475: LD_EXP 20
50479: PPUSH
50480: LD_VAR 0 2
50484: PPUSH
50485: EMPTY
50486: PPUSH
50487: CALL_OW 1
50491: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
50492: LD_VAR 0 2
50496: PPUSH
50497: LD_INT 103
50499: PPUSH
50500: CALL 45371 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
50504: LD_ADDR_VAR 0 5
50508: PUSH
50509: LD_EXP 14
50513: PUSH
50514: LD_VAR 0 2
50518: ARRAY
50519: PUSH
50520: LD_EXP 43
50524: PUSH
50525: LD_VAR 0 2
50529: ARRAY
50530: UNION
50531: PPUSH
50532: LD_INT 2
50534: PUSH
50535: LD_INT 25
50537: PUSH
50538: LD_INT 2
50540: PUSH
50541: EMPTY
50542: LIST
50543: LIST
50544: PUSH
50545: LD_INT 25
50547: PUSH
50548: LD_INT 16
50550: PUSH
50551: EMPTY
50552: LIST
50553: LIST
50554: PUSH
50555: EMPTY
50556: LIST
50557: LIST
50558: LIST
50559: PUSH
50560: EMPTY
50561: LIST
50562: PPUSH
50563: CALL_OW 72
50567: PUSH
50568: LD_EXP 17
50572: PUSH
50573: LD_VAR 0 2
50577: ARRAY
50578: PUSH
50579: LD_INT 1
50581: ARRAY
50582: PUSH
50583: LD_EXP 17
50587: PUSH
50588: LD_VAR 0 2
50592: ARRAY
50593: PUSH
50594: LD_INT 2
50596: ARRAY
50597: UNION
50598: DIFF
50599: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
50600: LD_ADDR_VAR 0 6
50604: PUSH
50605: LD_EXP 33
50609: PUSH
50610: LD_VAR 0 2
50614: ARRAY
50615: PPUSH
50616: LD_INT 2
50618: PUSH
50619: LD_INT 34
50621: PUSH
50622: LD_INT 13
50624: PUSH
50625: EMPTY
50626: LIST
50627: LIST
50628: PUSH
50629: LD_INT 34
50631: PUSH
50632: LD_INT 52
50634: PUSH
50635: EMPTY
50636: LIST
50637: LIST
50638: PUSH
50639: EMPTY
50640: LIST
50641: LIST
50642: LIST
50643: PPUSH
50644: CALL_OW 72
50648: ST_TO_ADDR
// if cranes then
50649: LD_VAR 0 6
50653: IFFALSE 50789
// begin for j in cranes do
50655: LD_ADDR_VAR 0 3
50659: PUSH
50660: LD_VAR 0 6
50664: PUSH
50665: FOR_IN
50666: IFFALSE 50787
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
50668: LD_VAR 0 3
50672: PPUSH
50673: CALL_OW 256
50677: PUSH
50678: LD_INT 500
50680: GREATEREQUAL
50681: PUSH
50682: LD_VAR 0 3
50686: PPUSH
50687: CALL_OW 314
50691: NOT
50692: AND
50693: IFFALSE 50727
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
50695: LD_VAR 0 3
50699: PPUSH
50700: LD_EXP 15
50704: PUSH
50705: LD_VAR 0 2
50709: ARRAY
50710: PPUSH
50711: LD_VAR 0 3
50715: PPUSH
50716: CALL_OW 74
50720: PPUSH
50721: CALL_OW 130
50725: GO 50785
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
50727: LD_VAR 0 3
50731: PPUSH
50732: CALL_OW 256
50736: PUSH
50737: LD_INT 500
50739: LESS
50740: PUSH
50741: LD_VAR 0 3
50745: PPUSH
50746: LD_EXP 38
50750: PUSH
50751: LD_VAR 0 2
50755: ARRAY
50756: PPUSH
50757: CALL_OW 308
50761: NOT
50762: AND
50763: IFFALSE 50785
// ComMoveToArea ( j , mc_parking [ i ] ) ;
50765: LD_VAR 0 3
50769: PPUSH
50770: LD_EXP 38
50774: PUSH
50775: LD_VAR 0 2
50779: ARRAY
50780: PPUSH
50781: CALL_OW 113
50785: GO 50665
50787: POP
50788: POP
// end ; if tmp > 3 then
50789: LD_VAR 0 5
50793: PUSH
50794: LD_INT 3
50796: GREATER
50797: IFFALSE 50817
// tmp := ShrinkArray ( tmp , 4 ) ;
50799: LD_ADDR_VAR 0 5
50803: PUSH
50804: LD_VAR 0 5
50808: PPUSH
50809: LD_INT 4
50811: PPUSH
50812: CALL 40785 0 2
50816: ST_TO_ADDR
// if not tmp then
50817: LD_VAR 0 5
50821: NOT
50822: IFFALSE 50826
// continue ;
50824: GO 50282
// for j in tmp do
50826: LD_ADDR_VAR 0 3
50830: PUSH
50831: LD_VAR 0 5
50835: PUSH
50836: FOR_IN
50837: IFFALSE 51096
// begin if IsInUnit ( j ) then
50839: LD_VAR 0 3
50843: PPUSH
50844: CALL_OW 310
50848: IFFALSE 50859
// ComExitBuilding ( j ) ;
50850: LD_VAR 0 3
50854: PPUSH
50855: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
50859: LD_VAR 0 3
50863: PUSH
50864: LD_EXP 16
50868: PUSH
50869: LD_VAR 0 2
50873: ARRAY
50874: IN
50875: NOT
50876: IFFALSE 50934
// begin SetTag ( j , 101 ) ;
50878: LD_VAR 0 3
50882: PPUSH
50883: LD_INT 101
50885: PPUSH
50886: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
50890: LD_ADDR_EXP 16
50894: PUSH
50895: LD_EXP 16
50899: PPUSH
50900: LD_VAR 0 2
50904: PUSH
50905: LD_EXP 16
50909: PUSH
50910: LD_VAR 0 2
50914: ARRAY
50915: PUSH
50916: LD_INT 1
50918: PLUS
50919: PUSH
50920: EMPTY
50921: LIST
50922: LIST
50923: PPUSH
50924: LD_VAR 0 3
50928: PPUSH
50929: CALL 9427 0 3
50933: ST_TO_ADDR
// end ; wait ( 1 ) ;
50934: LD_INT 1
50936: PPUSH
50937: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
50941: LD_ADDR_VAR 0 7
50945: PUSH
50946: LD_EXP 15
50950: PUSH
50951: LD_VAR 0 2
50955: ARRAY
50956: ST_TO_ADDR
// if mc_scan [ i ] then
50957: LD_EXP 37
50961: PUSH
50962: LD_VAR 0 2
50966: ARRAY
50967: IFFALSE 51029
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
50969: LD_ADDR_VAR 0 7
50973: PUSH
50974: LD_EXP 15
50978: PUSH
50979: LD_VAR 0 2
50983: ARRAY
50984: PPUSH
50985: LD_INT 3
50987: PUSH
50988: LD_INT 30
50990: PUSH
50991: LD_INT 32
50993: PUSH
50994: EMPTY
50995: LIST
50996: LIST
50997: PUSH
50998: LD_INT 30
51000: PUSH
51001: LD_INT 33
51003: PUSH
51004: EMPTY
51005: LIST
51006: LIST
51007: PUSH
51008: LD_INT 30
51010: PUSH
51011: LD_INT 31
51013: PUSH
51014: EMPTY
51015: LIST
51016: LIST
51017: PUSH
51018: EMPTY
51019: LIST
51020: LIST
51021: LIST
51022: LIST
51023: PPUSH
51024: CALL_OW 72
51028: ST_TO_ADDR
// if not to_repair_tmp then
51029: LD_VAR 0 7
51033: NOT
51034: IFFALSE 51038
// continue ;
51036: GO 50836
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
51038: LD_ADDR_VAR 0 8
51042: PUSH
51043: LD_VAR 0 7
51047: PPUSH
51048: LD_VAR 0 3
51052: PPUSH
51053: CALL_OW 74
51057: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 5 then
51058: LD_VAR 0 8
51062: PPUSH
51063: LD_INT 16
51065: PPUSH
51066: CALL 12020 0 2
51070: PUSH
51071: LD_INT 4
51073: ARRAY
51074: PUSH
51075: LD_INT 5
51077: LESS
51078: IFFALSE 51094
// ComRepairBuilding ( j , to_repair ) ;
51080: LD_VAR 0 3
51084: PPUSH
51085: LD_VAR 0 8
51089: PPUSH
51090: CALL_OW 130
// end ;
51094: GO 50836
51096: POP
51097: POP
// end ;
51098: GO 50282
51100: POP
51101: POP
// end ;
51102: LD_VAR 0 1
51106: RET
// export function MC_Heal ; var i , j , tmp ; begin
51107: LD_INT 0
51109: PPUSH
51110: PPUSH
51111: PPUSH
51112: PPUSH
// if not mc_bases then
51113: LD_EXP 14
51117: NOT
51118: IFFALSE 51122
// exit ;
51120: GO 51524
// for i = 1 to mc_bases do
51122: LD_ADDR_VAR 0 2
51126: PUSH
51127: DOUBLE
51128: LD_INT 1
51130: DEC
51131: ST_TO_ADDR
51132: LD_EXP 14
51136: PUSH
51137: FOR_TO
51138: IFFALSE 51522
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
51140: LD_EXP 17
51144: PUSH
51145: LD_VAR 0 2
51149: ARRAY
51150: PUSH
51151: LD_INT 1
51153: ARRAY
51154: NOT
51155: PUSH
51156: LD_EXP 17
51160: PUSH
51161: LD_VAR 0 2
51165: ARRAY
51166: PUSH
51167: LD_INT 2
51169: ARRAY
51170: NOT
51171: AND
51172: IFFALSE 51210
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
51174: LD_ADDR_EXP 18
51178: PUSH
51179: LD_EXP 18
51183: PPUSH
51184: LD_VAR 0 2
51188: PPUSH
51189: EMPTY
51190: PPUSH
51191: CALL_OW 1
51195: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
51196: LD_VAR 0 2
51200: PPUSH
51201: LD_INT 102
51203: PPUSH
51204: CALL 45371 0 2
// continue ;
51208: GO 51137
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
51210: LD_ADDR_VAR 0 4
51214: PUSH
51215: LD_EXP 14
51219: PUSH
51220: LD_VAR 0 2
51224: ARRAY
51225: PPUSH
51226: LD_INT 25
51228: PUSH
51229: LD_INT 4
51231: PUSH
51232: EMPTY
51233: LIST
51234: LIST
51235: PPUSH
51236: CALL_OW 72
51240: ST_TO_ADDR
// if not tmp then
51241: LD_VAR 0 4
51245: NOT
51246: IFFALSE 51250
// continue ;
51248: GO 51137
// if mc_taming [ i ] then
51250: LD_EXP 45
51254: PUSH
51255: LD_VAR 0 2
51259: ARRAY
51260: IFFALSE 51284
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
51262: LD_ADDR_EXP 45
51266: PUSH
51267: LD_EXP 45
51271: PPUSH
51272: LD_VAR 0 2
51276: PPUSH
51277: EMPTY
51278: PPUSH
51279: CALL_OW 1
51283: ST_TO_ADDR
// for j in tmp do
51284: LD_ADDR_VAR 0 3
51288: PUSH
51289: LD_VAR 0 4
51293: PUSH
51294: FOR_IN
51295: IFFALSE 51518
// begin if IsInUnit ( j ) then
51297: LD_VAR 0 3
51301: PPUSH
51302: CALL_OW 310
51306: IFFALSE 51317
// ComExitBuilding ( j ) ;
51308: LD_VAR 0 3
51312: PPUSH
51313: CALL_OW 122
// if not j in mc_healers [ i ] then
51317: LD_VAR 0 3
51321: PUSH
51322: LD_EXP 18
51326: PUSH
51327: LD_VAR 0 2
51331: ARRAY
51332: IN
51333: NOT
51334: IFFALSE 51380
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
51336: LD_ADDR_EXP 18
51340: PUSH
51341: LD_EXP 18
51345: PPUSH
51346: LD_VAR 0 2
51350: PUSH
51351: LD_EXP 18
51355: PUSH
51356: LD_VAR 0 2
51360: ARRAY
51361: PUSH
51362: LD_INT 1
51364: PLUS
51365: PUSH
51366: EMPTY
51367: LIST
51368: LIST
51369: PPUSH
51370: LD_VAR 0 3
51374: PPUSH
51375: CALL 9427 0 3
51379: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
51380: LD_VAR 0 3
51384: PPUSH
51385: CALL_OW 110
51389: PUSH
51390: LD_INT 102
51392: NONEQUAL
51393: IFFALSE 51407
// SetTag ( j , 102 ) ;
51395: LD_VAR 0 3
51399: PPUSH
51400: LD_INT 102
51402: PPUSH
51403: CALL_OW 109
// Wait ( 3 ) ;
51407: LD_INT 3
51409: PPUSH
51410: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
51414: LD_EXP 17
51418: PUSH
51419: LD_VAR 0 2
51423: ARRAY
51424: PUSH
51425: LD_INT 1
51427: ARRAY
51428: IFFALSE 51460
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
51430: LD_VAR 0 3
51434: PPUSH
51435: LD_EXP 17
51439: PUSH
51440: LD_VAR 0 2
51444: ARRAY
51445: PUSH
51446: LD_INT 1
51448: ARRAY
51449: PUSH
51450: LD_INT 1
51452: ARRAY
51453: PPUSH
51454: CALL_OW 128
51458: GO 51516
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
51460: LD_VAR 0 3
51464: PPUSH
51465: CALL_OW 314
51469: NOT
51470: PUSH
51471: LD_EXP 17
51475: PUSH
51476: LD_VAR 0 2
51480: ARRAY
51481: PUSH
51482: LD_INT 2
51484: ARRAY
51485: AND
51486: IFFALSE 51516
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
51488: LD_VAR 0 3
51492: PPUSH
51493: LD_EXP 17
51497: PUSH
51498: LD_VAR 0 2
51502: ARRAY
51503: PUSH
51504: LD_INT 2
51506: ARRAY
51507: PUSH
51508: LD_INT 1
51510: ARRAY
51511: PPUSH
51512: CALL_OW 128
// end ;
51516: GO 51294
51518: POP
51519: POP
// end ;
51520: GO 51137
51522: POP
51523: POP
// end ;
51524: LD_VAR 0 1
51528: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
51529: LD_INT 0
51531: PPUSH
51532: PPUSH
51533: PPUSH
51534: PPUSH
51535: PPUSH
// if not mc_bases then
51536: LD_EXP 14
51540: NOT
51541: IFFALSE 51545
// exit ;
51543: GO 52688
// for i = 1 to mc_bases do
51545: LD_ADDR_VAR 0 2
51549: PUSH
51550: DOUBLE
51551: LD_INT 1
51553: DEC
51554: ST_TO_ADDR
51555: LD_EXP 14
51559: PUSH
51560: FOR_TO
51561: IFFALSE 52686
// begin if mc_scan [ i ] then
51563: LD_EXP 37
51567: PUSH
51568: LD_VAR 0 2
51572: ARRAY
51573: IFFALSE 51577
// continue ;
51575: GO 51560
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
51577: LD_EXP 19
51581: PUSH
51582: LD_VAR 0 2
51586: ARRAY
51587: NOT
51588: PUSH
51589: LD_EXP 21
51593: PUSH
51594: LD_VAR 0 2
51598: ARRAY
51599: NOT
51600: AND
51601: PUSH
51602: LD_EXP 20
51606: PUSH
51607: LD_VAR 0 2
51611: ARRAY
51612: AND
51613: IFFALSE 51651
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
51615: LD_ADDR_EXP 20
51619: PUSH
51620: LD_EXP 20
51624: PPUSH
51625: LD_VAR 0 2
51629: PPUSH
51630: EMPTY
51631: PPUSH
51632: CALL_OW 1
51636: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
51637: LD_VAR 0 2
51641: PPUSH
51642: LD_INT 103
51644: PPUSH
51645: CALL 45371 0 2
// continue ;
51649: GO 51560
// end ; if mc_construct_list [ i ] then
51651: LD_EXP 21
51655: PUSH
51656: LD_VAR 0 2
51660: ARRAY
51661: IFFALSE 51881
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
51663: LD_ADDR_VAR 0 4
51667: PUSH
51668: LD_EXP 14
51672: PUSH
51673: LD_VAR 0 2
51677: ARRAY
51678: PPUSH
51679: LD_INT 25
51681: PUSH
51682: LD_INT 2
51684: PUSH
51685: EMPTY
51686: LIST
51687: LIST
51688: PPUSH
51689: CALL_OW 72
51693: PUSH
51694: LD_EXP 16
51698: PUSH
51699: LD_VAR 0 2
51703: ARRAY
51704: DIFF
51705: ST_TO_ADDR
// if not tmp then
51706: LD_VAR 0 4
51710: NOT
51711: IFFALSE 51715
// continue ;
51713: GO 51560
// for j in tmp do
51715: LD_ADDR_VAR 0 3
51719: PUSH
51720: LD_VAR 0 4
51724: PUSH
51725: FOR_IN
51726: IFFALSE 51877
// begin if not mc_builders [ i ] then
51728: LD_EXP 20
51732: PUSH
51733: LD_VAR 0 2
51737: ARRAY
51738: NOT
51739: IFFALSE 51797
// begin SetTag ( j , 103 ) ;
51741: LD_VAR 0 3
51745: PPUSH
51746: LD_INT 103
51748: PPUSH
51749: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
51753: LD_ADDR_EXP 20
51757: PUSH
51758: LD_EXP 20
51762: PPUSH
51763: LD_VAR 0 2
51767: PUSH
51768: LD_EXP 20
51772: PUSH
51773: LD_VAR 0 2
51777: ARRAY
51778: PUSH
51779: LD_INT 1
51781: PLUS
51782: PUSH
51783: EMPTY
51784: LIST
51785: LIST
51786: PPUSH
51787: LD_VAR 0 3
51791: PPUSH
51792: CALL 9427 0 3
51796: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
51797: LD_VAR 0 3
51801: PPUSH
51802: CALL_OW 310
51806: IFFALSE 51817
// ComExitBuilding ( j ) ;
51808: LD_VAR 0 3
51812: PPUSH
51813: CALL_OW 122
// wait ( 3 ) ;
51817: LD_INT 3
51819: PPUSH
51820: CALL_OW 67
// if not mc_construct_list [ i ] then
51824: LD_EXP 21
51828: PUSH
51829: LD_VAR 0 2
51833: ARRAY
51834: NOT
51835: IFFALSE 51839
// break ;
51837: GO 51877
// if not HasTask ( j ) then
51839: LD_VAR 0 3
51843: PPUSH
51844: CALL_OW 314
51848: NOT
51849: IFFALSE 51875
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
51851: LD_VAR 0 3
51855: PPUSH
51856: LD_EXP 21
51860: PUSH
51861: LD_VAR 0 2
51865: ARRAY
51866: PUSH
51867: LD_INT 1
51869: ARRAY
51870: PPUSH
51871: CALL 12278 0 2
// end ;
51875: GO 51725
51877: POP
51878: POP
// end else
51879: GO 52684
// if mc_build_list [ i ] then
51881: LD_EXP 19
51885: PUSH
51886: LD_VAR 0 2
51890: ARRAY
51891: IFFALSE 52684
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
51893: LD_ADDR_VAR 0 5
51897: PUSH
51898: LD_EXP 14
51902: PUSH
51903: LD_VAR 0 2
51907: ARRAY
51908: PPUSH
51909: LD_INT 2
51911: PUSH
51912: LD_INT 30
51914: PUSH
51915: LD_INT 0
51917: PUSH
51918: EMPTY
51919: LIST
51920: LIST
51921: PUSH
51922: LD_INT 30
51924: PUSH
51925: LD_INT 1
51927: PUSH
51928: EMPTY
51929: LIST
51930: LIST
51931: PUSH
51932: EMPTY
51933: LIST
51934: LIST
51935: LIST
51936: PPUSH
51937: CALL_OW 72
51941: ST_TO_ADDR
// if depot then
51942: LD_VAR 0 5
51946: IFFALSE 51964
// depot := depot [ 1 ] else
51948: LD_ADDR_VAR 0 5
51952: PUSH
51953: LD_VAR 0 5
51957: PUSH
51958: LD_INT 1
51960: ARRAY
51961: ST_TO_ADDR
51962: GO 51972
// depot := 0 ;
51964: LD_ADDR_VAR 0 5
51968: PUSH
51969: LD_INT 0
51971: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
51972: LD_EXP 19
51976: PUSH
51977: LD_VAR 0 2
51981: ARRAY
51982: PUSH
51983: LD_INT 1
51985: ARRAY
51986: PUSH
51987: LD_INT 1
51989: ARRAY
51990: PPUSH
51991: CALL 12108 0 1
51995: PUSH
51996: LD_EXP 14
52000: PUSH
52001: LD_VAR 0 2
52005: ARRAY
52006: PPUSH
52007: LD_INT 2
52009: PUSH
52010: LD_INT 30
52012: PUSH
52013: LD_INT 2
52015: PUSH
52016: EMPTY
52017: LIST
52018: LIST
52019: PUSH
52020: LD_INT 30
52022: PUSH
52023: LD_INT 3
52025: PUSH
52026: EMPTY
52027: LIST
52028: LIST
52029: PUSH
52030: EMPTY
52031: LIST
52032: LIST
52033: LIST
52034: PPUSH
52035: CALL_OW 72
52039: NOT
52040: AND
52041: IFFALSE 52146
// begin for j = 1 to mc_build_list [ i ] do
52043: LD_ADDR_VAR 0 3
52047: PUSH
52048: DOUBLE
52049: LD_INT 1
52051: DEC
52052: ST_TO_ADDR
52053: LD_EXP 19
52057: PUSH
52058: LD_VAR 0 2
52062: ARRAY
52063: PUSH
52064: FOR_TO
52065: IFFALSE 52144
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
52067: LD_EXP 19
52071: PUSH
52072: LD_VAR 0 2
52076: ARRAY
52077: PUSH
52078: LD_VAR 0 3
52082: ARRAY
52083: PUSH
52084: LD_INT 1
52086: ARRAY
52087: PUSH
52088: LD_INT 2
52090: EQUAL
52091: IFFALSE 52142
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
52093: LD_ADDR_EXP 19
52097: PUSH
52098: LD_EXP 19
52102: PPUSH
52103: LD_VAR 0 2
52107: PPUSH
52108: LD_EXP 19
52112: PUSH
52113: LD_VAR 0 2
52117: ARRAY
52118: PPUSH
52119: LD_VAR 0 3
52123: PPUSH
52124: LD_INT 1
52126: PPUSH
52127: LD_INT 0
52129: PPUSH
52130: CALL 8845 0 4
52134: PPUSH
52135: CALL_OW 1
52139: ST_TO_ADDR
// break ;
52140: GO 52144
// end ;
52142: GO 52064
52144: POP
52145: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
52146: LD_EXP 19
52150: PUSH
52151: LD_VAR 0 2
52155: ARRAY
52156: PUSH
52157: LD_INT 1
52159: ARRAY
52160: PUSH
52161: LD_INT 1
52163: ARRAY
52164: PUSH
52165: LD_INT 0
52167: EQUAL
52168: PUSH
52169: LD_VAR 0 5
52173: PUSH
52174: LD_VAR 0 5
52178: PPUSH
52179: LD_EXP 19
52183: PUSH
52184: LD_VAR 0 2
52188: ARRAY
52189: PUSH
52190: LD_INT 1
52192: ARRAY
52193: PUSH
52194: LD_INT 1
52196: ARRAY
52197: PPUSH
52198: LD_EXP 19
52202: PUSH
52203: LD_VAR 0 2
52207: ARRAY
52208: PUSH
52209: LD_INT 1
52211: ARRAY
52212: PUSH
52213: LD_INT 2
52215: ARRAY
52216: PPUSH
52217: LD_EXP 19
52221: PUSH
52222: LD_VAR 0 2
52226: ARRAY
52227: PUSH
52228: LD_INT 1
52230: ARRAY
52231: PUSH
52232: LD_INT 3
52234: ARRAY
52235: PPUSH
52236: LD_EXP 19
52240: PUSH
52241: LD_VAR 0 2
52245: ARRAY
52246: PUSH
52247: LD_INT 1
52249: ARRAY
52250: PUSH
52251: LD_INT 4
52253: ARRAY
52254: PPUSH
52255: CALL 16842 0 5
52259: AND
52260: OR
52261: IFFALSE 52542
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
52263: LD_ADDR_VAR 0 4
52267: PUSH
52268: LD_EXP 14
52272: PUSH
52273: LD_VAR 0 2
52277: ARRAY
52278: PPUSH
52279: LD_INT 25
52281: PUSH
52282: LD_INT 2
52284: PUSH
52285: EMPTY
52286: LIST
52287: LIST
52288: PPUSH
52289: CALL_OW 72
52293: PUSH
52294: LD_EXP 16
52298: PUSH
52299: LD_VAR 0 2
52303: ARRAY
52304: DIFF
52305: ST_TO_ADDR
// if not tmp then
52306: LD_VAR 0 4
52310: NOT
52311: IFFALSE 52315
// continue ;
52313: GO 51560
// for j in tmp do
52315: LD_ADDR_VAR 0 3
52319: PUSH
52320: LD_VAR 0 4
52324: PUSH
52325: FOR_IN
52326: IFFALSE 52538
// begin if not mc_builders [ i ] then
52328: LD_EXP 20
52332: PUSH
52333: LD_VAR 0 2
52337: ARRAY
52338: NOT
52339: IFFALSE 52397
// begin SetTag ( j , 103 ) ;
52341: LD_VAR 0 3
52345: PPUSH
52346: LD_INT 103
52348: PPUSH
52349: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
52353: LD_ADDR_EXP 20
52357: PUSH
52358: LD_EXP 20
52362: PPUSH
52363: LD_VAR 0 2
52367: PUSH
52368: LD_EXP 20
52372: PUSH
52373: LD_VAR 0 2
52377: ARRAY
52378: PUSH
52379: LD_INT 1
52381: PLUS
52382: PUSH
52383: EMPTY
52384: LIST
52385: LIST
52386: PPUSH
52387: LD_VAR 0 3
52391: PPUSH
52392: CALL 9427 0 3
52396: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
52397: LD_VAR 0 3
52401: PPUSH
52402: CALL_OW 310
52406: IFFALSE 52417
// ComExitBuilding ( j ) ;
52408: LD_VAR 0 3
52412: PPUSH
52413: CALL_OW 122
// wait ( 3 ) ;
52417: LD_INT 3
52419: PPUSH
52420: CALL_OW 67
// if not mc_build_list [ i ] then
52424: LD_EXP 19
52428: PUSH
52429: LD_VAR 0 2
52433: ARRAY
52434: NOT
52435: IFFALSE 52439
// break ;
52437: GO 52538
// if not HasTask ( j ) then
52439: LD_VAR 0 3
52443: PPUSH
52444: CALL_OW 314
52448: NOT
52449: IFFALSE 52536
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
52451: LD_VAR 0 3
52455: PPUSH
52456: LD_EXP 19
52460: PUSH
52461: LD_VAR 0 2
52465: ARRAY
52466: PUSH
52467: LD_INT 1
52469: ARRAY
52470: PUSH
52471: LD_INT 1
52473: ARRAY
52474: PPUSH
52475: LD_EXP 19
52479: PUSH
52480: LD_VAR 0 2
52484: ARRAY
52485: PUSH
52486: LD_INT 1
52488: ARRAY
52489: PUSH
52490: LD_INT 2
52492: ARRAY
52493: PPUSH
52494: LD_EXP 19
52498: PUSH
52499: LD_VAR 0 2
52503: ARRAY
52504: PUSH
52505: LD_INT 1
52507: ARRAY
52508: PUSH
52509: LD_INT 3
52511: ARRAY
52512: PPUSH
52513: LD_EXP 19
52517: PUSH
52518: LD_VAR 0 2
52522: ARRAY
52523: PUSH
52524: LD_INT 1
52526: ARRAY
52527: PUSH
52528: LD_INT 4
52530: ARRAY
52531: PPUSH
52532: CALL_OW 145
// end ;
52536: GO 52325
52538: POP
52539: POP
// end else
52540: GO 52684
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
52542: LD_EXP 14
52546: PUSH
52547: LD_VAR 0 2
52551: ARRAY
52552: PPUSH
52553: LD_EXP 19
52557: PUSH
52558: LD_VAR 0 2
52562: ARRAY
52563: PUSH
52564: LD_INT 1
52566: ARRAY
52567: PUSH
52568: LD_INT 1
52570: ARRAY
52571: PPUSH
52572: LD_EXP 19
52576: PUSH
52577: LD_VAR 0 2
52581: ARRAY
52582: PUSH
52583: LD_INT 1
52585: ARRAY
52586: PUSH
52587: LD_INT 2
52589: ARRAY
52590: PPUSH
52591: LD_EXP 19
52595: PUSH
52596: LD_VAR 0 2
52600: ARRAY
52601: PUSH
52602: LD_INT 1
52604: ARRAY
52605: PUSH
52606: LD_INT 3
52608: ARRAY
52609: PPUSH
52610: LD_EXP 19
52614: PUSH
52615: LD_VAR 0 2
52619: ARRAY
52620: PUSH
52621: LD_INT 1
52623: ARRAY
52624: PUSH
52625: LD_INT 4
52627: ARRAY
52628: PPUSH
52629: CALL 16178 0 5
52633: NOT
52634: IFFALSE 52684
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
52636: LD_ADDR_EXP 19
52640: PUSH
52641: LD_EXP 19
52645: PPUSH
52646: LD_VAR 0 2
52650: PPUSH
52651: LD_EXP 19
52655: PUSH
52656: LD_VAR 0 2
52660: ARRAY
52661: PPUSH
52662: LD_INT 1
52664: PPUSH
52665: LD_INT 1
52667: NEG
52668: PPUSH
52669: LD_INT 0
52671: PPUSH
52672: CALL 8845 0 4
52676: PPUSH
52677: CALL_OW 1
52681: ST_TO_ADDR
// continue ;
52682: GO 51560
// end ; end ; end ;
52684: GO 51560
52686: POP
52687: POP
// end ;
52688: LD_VAR 0 1
52692: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
52693: LD_INT 0
52695: PPUSH
52696: PPUSH
52697: PPUSH
52698: PPUSH
52699: PPUSH
52700: PPUSH
// if not mc_bases then
52701: LD_EXP 14
52705: NOT
52706: IFFALSE 52710
// exit ;
52708: GO 53137
// for i = 1 to mc_bases do
52710: LD_ADDR_VAR 0 2
52714: PUSH
52715: DOUBLE
52716: LD_INT 1
52718: DEC
52719: ST_TO_ADDR
52720: LD_EXP 14
52724: PUSH
52725: FOR_TO
52726: IFFALSE 53135
// begin tmp := mc_build_upgrade [ i ] ;
52728: LD_ADDR_VAR 0 4
52732: PUSH
52733: LD_EXP 46
52737: PUSH
52738: LD_VAR 0 2
52742: ARRAY
52743: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
52744: LD_ADDR_VAR 0 6
52748: PUSH
52749: LD_EXP 47
52753: PUSH
52754: LD_VAR 0 2
52758: ARRAY
52759: PPUSH
52760: LD_INT 2
52762: PUSH
52763: LD_INT 30
52765: PUSH
52766: LD_INT 6
52768: PUSH
52769: EMPTY
52770: LIST
52771: LIST
52772: PUSH
52773: LD_INT 30
52775: PUSH
52776: LD_INT 7
52778: PUSH
52779: EMPTY
52780: LIST
52781: LIST
52782: PUSH
52783: EMPTY
52784: LIST
52785: LIST
52786: LIST
52787: PPUSH
52788: CALL_OW 72
52792: ST_TO_ADDR
// if not tmp and not lab then
52793: LD_VAR 0 4
52797: NOT
52798: PUSH
52799: LD_VAR 0 6
52803: NOT
52804: AND
52805: IFFALSE 52809
// continue ;
52807: GO 52725
// if tmp then
52809: LD_VAR 0 4
52813: IFFALSE 52933
// for j in tmp do
52815: LD_ADDR_VAR 0 3
52819: PUSH
52820: LD_VAR 0 4
52824: PUSH
52825: FOR_IN
52826: IFFALSE 52931
// begin if UpgradeCost ( j ) then
52828: LD_VAR 0 3
52832: PPUSH
52833: CALL 15838 0 1
52837: IFFALSE 52929
// begin ComUpgrade ( j ) ;
52839: LD_VAR 0 3
52843: PPUSH
52844: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
52848: LD_ADDR_EXP 46
52852: PUSH
52853: LD_EXP 46
52857: PPUSH
52858: LD_VAR 0 2
52862: PPUSH
52863: LD_EXP 46
52867: PUSH
52868: LD_VAR 0 2
52872: ARRAY
52873: PUSH
52874: LD_VAR 0 3
52878: DIFF
52879: PPUSH
52880: CALL_OW 1
52884: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
52885: LD_ADDR_EXP 21
52889: PUSH
52890: LD_EXP 21
52894: PPUSH
52895: LD_VAR 0 2
52899: PUSH
52900: LD_EXP 21
52904: PUSH
52905: LD_VAR 0 2
52909: ARRAY
52910: PUSH
52911: LD_INT 1
52913: PLUS
52914: PUSH
52915: EMPTY
52916: LIST
52917: LIST
52918: PPUSH
52919: LD_VAR 0 3
52923: PPUSH
52924: CALL 9427 0 3
52928: ST_TO_ADDR
// end ; end ;
52929: GO 52825
52931: POP
52932: POP
// if not lab or not mc_lab_upgrade [ i ] then
52933: LD_VAR 0 6
52937: NOT
52938: PUSH
52939: LD_EXP 48
52943: PUSH
52944: LD_VAR 0 2
52948: ARRAY
52949: NOT
52950: OR
52951: IFFALSE 52955
// continue ;
52953: GO 52725
// for j in lab do
52955: LD_ADDR_VAR 0 3
52959: PUSH
52960: LD_VAR 0 6
52964: PUSH
52965: FOR_IN
52966: IFFALSE 53131
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
52968: LD_VAR 0 3
52972: PPUSH
52973: CALL_OW 266
52977: PUSH
52978: LD_INT 6
52980: PUSH
52981: LD_INT 7
52983: PUSH
52984: EMPTY
52985: LIST
52986: LIST
52987: IN
52988: PUSH
52989: LD_VAR 0 3
52993: PPUSH
52994: CALL_OW 461
52998: PUSH
52999: LD_INT 1
53001: NONEQUAL
53002: AND
53003: IFFALSE 53129
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
53005: LD_VAR 0 3
53009: PPUSH
53010: LD_EXP 48
53014: PUSH
53015: LD_VAR 0 2
53019: ARRAY
53020: PUSH
53021: LD_INT 1
53023: ARRAY
53024: PPUSH
53025: CALL 16043 0 2
53029: IFFALSE 53129
// begin ComCancel ( j ) ;
53031: LD_VAR 0 3
53035: PPUSH
53036: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
53040: LD_VAR 0 3
53044: PPUSH
53045: LD_EXP 48
53049: PUSH
53050: LD_VAR 0 2
53054: ARRAY
53055: PUSH
53056: LD_INT 1
53058: ARRAY
53059: PPUSH
53060: CALL_OW 207
// if not j in mc_construct_list [ i ] then
53064: LD_VAR 0 3
53068: PUSH
53069: LD_EXP 21
53073: PUSH
53074: LD_VAR 0 2
53078: ARRAY
53079: IN
53080: NOT
53081: IFFALSE 53127
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
53083: LD_ADDR_EXP 21
53087: PUSH
53088: LD_EXP 21
53092: PPUSH
53093: LD_VAR 0 2
53097: PUSH
53098: LD_EXP 21
53102: PUSH
53103: LD_VAR 0 2
53107: ARRAY
53108: PUSH
53109: LD_INT 1
53111: PLUS
53112: PUSH
53113: EMPTY
53114: LIST
53115: LIST
53116: PPUSH
53117: LD_VAR 0 3
53121: PPUSH
53122: CALL 9427 0 3
53126: ST_TO_ADDR
// break ;
53127: GO 53131
// end ; end ; end ;
53129: GO 52965
53131: POP
53132: POP
// end ;
53133: GO 52725
53135: POP
53136: POP
// end ;
53137: LD_VAR 0 1
53141: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
53142: LD_INT 0
53144: PPUSH
53145: PPUSH
53146: PPUSH
53147: PPUSH
53148: PPUSH
53149: PPUSH
53150: PPUSH
53151: PPUSH
53152: PPUSH
// if not mc_bases then
53153: LD_EXP 14
53157: NOT
53158: IFFALSE 53162
// exit ;
53160: GO 53567
// for i = 1 to mc_bases do
53162: LD_ADDR_VAR 0 2
53166: PUSH
53167: DOUBLE
53168: LD_INT 1
53170: DEC
53171: ST_TO_ADDR
53172: LD_EXP 14
53176: PUSH
53177: FOR_TO
53178: IFFALSE 53565
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
53180: LD_EXP 22
53184: PUSH
53185: LD_VAR 0 2
53189: ARRAY
53190: NOT
53191: PUSH
53192: LD_EXP 14
53196: PUSH
53197: LD_VAR 0 2
53201: ARRAY
53202: PPUSH
53203: LD_INT 30
53205: PUSH
53206: LD_INT 3
53208: PUSH
53209: EMPTY
53210: LIST
53211: LIST
53212: PPUSH
53213: CALL_OW 72
53217: NOT
53218: OR
53219: IFFALSE 53223
// continue ;
53221: GO 53177
// busy := false ;
53223: LD_ADDR_VAR 0 8
53227: PUSH
53228: LD_INT 0
53230: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
53231: LD_ADDR_VAR 0 4
53235: PUSH
53236: LD_EXP 14
53240: PUSH
53241: LD_VAR 0 2
53245: ARRAY
53246: PPUSH
53247: LD_INT 30
53249: PUSH
53250: LD_INT 3
53252: PUSH
53253: EMPTY
53254: LIST
53255: LIST
53256: PPUSH
53257: CALL_OW 72
53261: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
53262: LD_ADDR_VAR 0 6
53266: PUSH
53267: LD_EXP 22
53271: PUSH
53272: LD_VAR 0 2
53276: ARRAY
53277: PPUSH
53278: LD_INT 2
53280: PUSH
53281: LD_INT 30
53283: PUSH
53284: LD_INT 32
53286: PUSH
53287: EMPTY
53288: LIST
53289: LIST
53290: PUSH
53291: LD_INT 30
53293: PUSH
53294: LD_INT 33
53296: PUSH
53297: EMPTY
53298: LIST
53299: LIST
53300: PUSH
53301: EMPTY
53302: LIST
53303: LIST
53304: LIST
53305: PPUSH
53306: CALL_OW 72
53310: ST_TO_ADDR
// if not t then
53311: LD_VAR 0 6
53315: NOT
53316: IFFALSE 53320
// continue ;
53318: GO 53177
// for j in tmp do
53320: LD_ADDR_VAR 0 3
53324: PUSH
53325: LD_VAR 0 4
53329: PUSH
53330: FOR_IN
53331: IFFALSE 53361
// if not BuildingStatus ( j ) = bs_idle then
53333: LD_VAR 0 3
53337: PPUSH
53338: CALL_OW 461
53342: PUSH
53343: LD_INT 2
53345: EQUAL
53346: NOT
53347: IFFALSE 53359
// begin busy := true ;
53349: LD_ADDR_VAR 0 8
53353: PUSH
53354: LD_INT 1
53356: ST_TO_ADDR
// break ;
53357: GO 53361
// end ;
53359: GO 53330
53361: POP
53362: POP
// if busy then
53363: LD_VAR 0 8
53367: IFFALSE 53371
// continue ;
53369: GO 53177
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
53371: LD_ADDR_VAR 0 7
53375: PUSH
53376: LD_VAR 0 6
53380: PPUSH
53381: LD_INT 35
53383: PUSH
53384: LD_INT 0
53386: PUSH
53387: EMPTY
53388: LIST
53389: LIST
53390: PPUSH
53391: CALL_OW 72
53395: ST_TO_ADDR
// if tw then
53396: LD_VAR 0 7
53400: IFFALSE 53477
// begin tw := tw [ 1 ] ;
53402: LD_ADDR_VAR 0 7
53406: PUSH
53407: LD_VAR 0 7
53411: PUSH
53412: LD_INT 1
53414: ARRAY
53415: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
53416: LD_ADDR_VAR 0 9
53420: PUSH
53421: LD_VAR 0 7
53425: PPUSH
53426: LD_EXP 39
53430: PUSH
53431: LD_VAR 0 2
53435: ARRAY
53436: PPUSH
53437: CALL 14397 0 2
53441: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
53442: LD_EXP 53
53446: PUSH
53447: LD_VAR 0 2
53451: ARRAY
53452: IFFALSE 53475
// if not weapon in mc_allowed_tower_weapons [ i ] then
53454: LD_VAR 0 9
53458: PUSH
53459: LD_EXP 53
53463: PUSH
53464: LD_VAR 0 2
53468: ARRAY
53469: IN
53470: NOT
53471: IFFALSE 53475
// continue ;
53473: GO 53177
// end else
53475: GO 53540
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
53477: LD_ADDR_VAR 0 5
53481: PUSH
53482: LD_EXP 22
53486: PUSH
53487: LD_VAR 0 2
53491: ARRAY
53492: PPUSH
53493: LD_VAR 0 4
53497: PPUSH
53498: CALL 40018 0 2
53502: ST_TO_ADDR
// if not tmp2 then
53503: LD_VAR 0 5
53507: NOT
53508: IFFALSE 53512
// continue ;
53510: GO 53177
// tw := tmp2 [ 1 ] ;
53512: LD_ADDR_VAR 0 7
53516: PUSH
53517: LD_VAR 0 5
53521: PUSH
53522: LD_INT 1
53524: ARRAY
53525: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
53526: LD_ADDR_VAR 0 9
53530: PUSH
53531: LD_VAR 0 5
53535: PUSH
53536: LD_INT 2
53538: ARRAY
53539: ST_TO_ADDR
// end ; if not weapon then
53540: LD_VAR 0 9
53544: NOT
53545: IFFALSE 53549
// continue ;
53547: GO 53177
// ComPlaceWeapon ( tw , weapon ) ;
53549: LD_VAR 0 7
53553: PPUSH
53554: LD_VAR 0 9
53558: PPUSH
53559: CALL_OW 148
// end ;
53563: GO 53177
53565: POP
53566: POP
// end ;
53567: LD_VAR 0 1
53571: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
53572: LD_INT 0
53574: PPUSH
53575: PPUSH
53576: PPUSH
53577: PPUSH
53578: PPUSH
53579: PPUSH
// if not mc_bases then
53580: LD_EXP 14
53584: NOT
53585: IFFALSE 53589
// exit ;
53587: GO 54365
// for i = 1 to mc_bases do
53589: LD_ADDR_VAR 0 2
53593: PUSH
53594: DOUBLE
53595: LD_INT 1
53597: DEC
53598: ST_TO_ADDR
53599: LD_EXP 14
53603: PUSH
53604: FOR_TO
53605: IFFALSE 54363
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
53607: LD_EXP 27
53611: PUSH
53612: LD_VAR 0 2
53616: ARRAY
53617: NOT
53618: PUSH
53619: LD_EXP 27
53623: PUSH
53624: LD_VAR 0 2
53628: ARRAY
53629: PUSH
53630: LD_EXP 28
53634: PUSH
53635: LD_VAR 0 2
53639: ARRAY
53640: EQUAL
53641: OR
53642: PUSH
53643: LD_EXP 37
53647: PUSH
53648: LD_VAR 0 2
53652: ARRAY
53653: OR
53654: IFFALSE 53658
// continue ;
53656: GO 53604
// if mc_miners [ i ] then
53658: LD_EXP 28
53662: PUSH
53663: LD_VAR 0 2
53667: ARRAY
53668: IFFALSE 54050
// begin for j = mc_miners [ i ] downto 1 do
53670: LD_ADDR_VAR 0 3
53674: PUSH
53675: DOUBLE
53676: LD_EXP 28
53680: PUSH
53681: LD_VAR 0 2
53685: ARRAY
53686: INC
53687: ST_TO_ADDR
53688: LD_INT 1
53690: PUSH
53691: FOR_DOWNTO
53692: IFFALSE 54048
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
53694: LD_EXP 28
53698: PUSH
53699: LD_VAR 0 2
53703: ARRAY
53704: PUSH
53705: LD_VAR 0 3
53709: ARRAY
53710: PPUSH
53711: CALL_OW 301
53715: PUSH
53716: LD_EXP 28
53720: PUSH
53721: LD_VAR 0 2
53725: ARRAY
53726: PUSH
53727: LD_VAR 0 3
53731: ARRAY
53732: PPUSH
53733: CALL_OW 257
53737: PUSH
53738: LD_INT 1
53740: NONEQUAL
53741: OR
53742: IFFALSE 53805
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
53744: LD_ADDR_VAR 0 5
53748: PUSH
53749: LD_EXP 28
53753: PUSH
53754: LD_VAR 0 2
53758: ARRAY
53759: PUSH
53760: LD_EXP 28
53764: PUSH
53765: LD_VAR 0 2
53769: ARRAY
53770: PUSH
53771: LD_VAR 0 3
53775: ARRAY
53776: DIFF
53777: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
53778: LD_ADDR_EXP 28
53782: PUSH
53783: LD_EXP 28
53787: PPUSH
53788: LD_VAR 0 2
53792: PPUSH
53793: LD_VAR 0 5
53797: PPUSH
53798: CALL_OW 1
53802: ST_TO_ADDR
// continue ;
53803: GO 53691
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
53805: LD_EXP 28
53809: PUSH
53810: LD_VAR 0 2
53814: ARRAY
53815: PUSH
53816: LD_VAR 0 3
53820: ARRAY
53821: PPUSH
53822: CALL_OW 257
53826: PUSH
53827: LD_INT 1
53829: EQUAL
53830: PUSH
53831: LD_EXP 28
53835: PUSH
53836: LD_VAR 0 2
53840: ARRAY
53841: PUSH
53842: LD_VAR 0 3
53846: ARRAY
53847: PPUSH
53848: CALL_OW 459
53852: NOT
53853: AND
53854: PUSH
53855: LD_EXP 28
53859: PUSH
53860: LD_VAR 0 2
53864: ARRAY
53865: PUSH
53866: LD_VAR 0 3
53870: ARRAY
53871: PPUSH
53872: CALL_OW 314
53876: NOT
53877: AND
53878: IFFALSE 54046
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
53880: LD_EXP 28
53884: PUSH
53885: LD_VAR 0 2
53889: ARRAY
53890: PUSH
53891: LD_VAR 0 3
53895: ARRAY
53896: PPUSH
53897: CALL_OW 310
53901: IFFALSE 53924
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
53903: LD_EXP 28
53907: PUSH
53908: LD_VAR 0 2
53912: ARRAY
53913: PUSH
53914: LD_VAR 0 3
53918: ARRAY
53919: PPUSH
53920: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
53924: LD_EXP 28
53928: PUSH
53929: LD_VAR 0 2
53933: ARRAY
53934: PUSH
53935: LD_VAR 0 3
53939: ARRAY
53940: PPUSH
53941: CALL_OW 314
53945: NOT
53946: IFFALSE 54046
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
53948: LD_EXP 28
53952: PUSH
53953: LD_VAR 0 2
53957: ARRAY
53958: PUSH
53959: LD_VAR 0 3
53963: ARRAY
53964: PPUSH
53965: LD_EXP 27
53969: PUSH
53970: LD_VAR 0 2
53974: ARRAY
53975: PUSH
53976: LD_VAR 0 3
53980: PUSH
53981: LD_EXP 27
53985: PUSH
53986: LD_VAR 0 2
53990: ARRAY
53991: MOD
53992: PUSH
53993: LD_INT 1
53995: PLUS
53996: ARRAY
53997: PUSH
53998: LD_INT 1
54000: ARRAY
54001: PPUSH
54002: LD_EXP 27
54006: PUSH
54007: LD_VAR 0 2
54011: ARRAY
54012: PUSH
54013: LD_VAR 0 3
54017: PUSH
54018: LD_EXP 27
54022: PUSH
54023: LD_VAR 0 2
54027: ARRAY
54028: MOD
54029: PUSH
54030: LD_INT 1
54032: PLUS
54033: ARRAY
54034: PUSH
54035: LD_INT 2
54037: ARRAY
54038: PPUSH
54039: LD_INT 0
54041: PPUSH
54042: CALL_OW 193
// end ; end ;
54046: GO 53691
54048: POP
54049: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
54050: LD_ADDR_VAR 0 5
54054: PUSH
54055: LD_EXP 14
54059: PUSH
54060: LD_VAR 0 2
54064: ARRAY
54065: PPUSH
54066: LD_INT 2
54068: PUSH
54069: LD_INT 30
54071: PUSH
54072: LD_INT 4
54074: PUSH
54075: EMPTY
54076: LIST
54077: LIST
54078: PUSH
54079: LD_INT 30
54081: PUSH
54082: LD_INT 5
54084: PUSH
54085: EMPTY
54086: LIST
54087: LIST
54088: PUSH
54089: LD_INT 30
54091: PUSH
54092: LD_INT 32
54094: PUSH
54095: EMPTY
54096: LIST
54097: LIST
54098: PUSH
54099: EMPTY
54100: LIST
54101: LIST
54102: LIST
54103: LIST
54104: PPUSH
54105: CALL_OW 72
54109: ST_TO_ADDR
// if not tmp then
54110: LD_VAR 0 5
54114: NOT
54115: IFFALSE 54119
// continue ;
54117: GO 53604
// list := [ ] ;
54119: LD_ADDR_VAR 0 6
54123: PUSH
54124: EMPTY
54125: ST_TO_ADDR
// for j in tmp do
54126: LD_ADDR_VAR 0 3
54130: PUSH
54131: LD_VAR 0 5
54135: PUSH
54136: FOR_IN
54137: IFFALSE 54206
// begin for k in UnitsInside ( j ) do
54139: LD_ADDR_VAR 0 4
54143: PUSH
54144: LD_VAR 0 3
54148: PPUSH
54149: CALL_OW 313
54153: PUSH
54154: FOR_IN
54155: IFFALSE 54202
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
54157: LD_VAR 0 4
54161: PPUSH
54162: CALL_OW 257
54166: PUSH
54167: LD_INT 1
54169: EQUAL
54170: PUSH
54171: LD_VAR 0 4
54175: PPUSH
54176: CALL_OW 459
54180: NOT
54181: AND
54182: IFFALSE 54200
// list := list ^ k ;
54184: LD_ADDR_VAR 0 6
54188: PUSH
54189: LD_VAR 0 6
54193: PUSH
54194: LD_VAR 0 4
54198: ADD
54199: ST_TO_ADDR
54200: GO 54154
54202: POP
54203: POP
// end ;
54204: GO 54136
54206: POP
54207: POP
// list := list diff mc_miners [ i ] ;
54208: LD_ADDR_VAR 0 6
54212: PUSH
54213: LD_VAR 0 6
54217: PUSH
54218: LD_EXP 28
54222: PUSH
54223: LD_VAR 0 2
54227: ARRAY
54228: DIFF
54229: ST_TO_ADDR
// if not list then
54230: LD_VAR 0 6
54234: NOT
54235: IFFALSE 54239
// continue ;
54237: GO 53604
// k := mc_mines [ i ] - mc_miners [ i ] ;
54239: LD_ADDR_VAR 0 4
54243: PUSH
54244: LD_EXP 27
54248: PUSH
54249: LD_VAR 0 2
54253: ARRAY
54254: PUSH
54255: LD_EXP 28
54259: PUSH
54260: LD_VAR 0 2
54264: ARRAY
54265: MINUS
54266: ST_TO_ADDR
// if k > list then
54267: LD_VAR 0 4
54271: PUSH
54272: LD_VAR 0 6
54276: GREATER
54277: IFFALSE 54289
// k := list ;
54279: LD_ADDR_VAR 0 4
54283: PUSH
54284: LD_VAR 0 6
54288: ST_TO_ADDR
// for j = 1 to k do
54289: LD_ADDR_VAR 0 3
54293: PUSH
54294: DOUBLE
54295: LD_INT 1
54297: DEC
54298: ST_TO_ADDR
54299: LD_VAR 0 4
54303: PUSH
54304: FOR_TO
54305: IFFALSE 54359
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
54307: LD_ADDR_EXP 28
54311: PUSH
54312: LD_EXP 28
54316: PPUSH
54317: LD_VAR 0 2
54321: PUSH
54322: LD_EXP 28
54326: PUSH
54327: LD_VAR 0 2
54331: ARRAY
54332: PUSH
54333: LD_INT 1
54335: PLUS
54336: PUSH
54337: EMPTY
54338: LIST
54339: LIST
54340: PPUSH
54341: LD_VAR 0 6
54345: PUSH
54346: LD_VAR 0 3
54350: ARRAY
54351: PPUSH
54352: CALL 9427 0 3
54356: ST_TO_ADDR
54357: GO 54304
54359: POP
54360: POP
// end ;
54361: GO 53604
54363: POP
54364: POP
// end ;
54365: LD_VAR 0 1
54369: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
54370: LD_INT 0
54372: PPUSH
54373: PPUSH
54374: PPUSH
54375: PPUSH
54376: PPUSH
54377: PPUSH
54378: PPUSH
54379: PPUSH
54380: PPUSH
54381: PPUSH
// if not mc_bases then
54382: LD_EXP 14
54386: NOT
54387: IFFALSE 54391
// exit ;
54389: GO 56141
// for i = 1 to mc_bases do
54391: LD_ADDR_VAR 0 2
54395: PUSH
54396: DOUBLE
54397: LD_INT 1
54399: DEC
54400: ST_TO_ADDR
54401: LD_EXP 14
54405: PUSH
54406: FOR_TO
54407: IFFALSE 56139
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
54409: LD_EXP 14
54413: PUSH
54414: LD_VAR 0 2
54418: ARRAY
54419: NOT
54420: PUSH
54421: LD_EXP 21
54425: PUSH
54426: LD_VAR 0 2
54430: ARRAY
54431: OR
54432: IFFALSE 54436
// continue ;
54434: GO 54406
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
54436: LD_EXP 30
54440: PUSH
54441: LD_VAR 0 2
54445: ARRAY
54446: NOT
54447: PUSH
54448: LD_EXP 31
54452: PUSH
54453: LD_VAR 0 2
54457: ARRAY
54458: AND
54459: IFFALSE 54497
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
54461: LD_ADDR_EXP 31
54465: PUSH
54466: LD_EXP 31
54470: PPUSH
54471: LD_VAR 0 2
54475: PPUSH
54476: EMPTY
54477: PPUSH
54478: CALL_OW 1
54482: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
54483: LD_VAR 0 2
54487: PPUSH
54488: LD_INT 107
54490: PPUSH
54491: CALL 45371 0 2
// continue ;
54495: GO 54406
// end ; target := [ ] ;
54497: LD_ADDR_VAR 0 6
54501: PUSH
54502: EMPTY
54503: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
54504: LD_ADDR_VAR 0 3
54508: PUSH
54509: DOUBLE
54510: LD_EXP 30
54514: PUSH
54515: LD_VAR 0 2
54519: ARRAY
54520: INC
54521: ST_TO_ADDR
54522: LD_INT 1
54524: PUSH
54525: FOR_DOWNTO
54526: IFFALSE 54786
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
54528: LD_EXP 30
54532: PUSH
54533: LD_VAR 0 2
54537: ARRAY
54538: PUSH
54539: LD_VAR 0 3
54543: ARRAY
54544: PUSH
54545: LD_INT 2
54547: ARRAY
54548: PPUSH
54549: LD_EXP 30
54553: PUSH
54554: LD_VAR 0 2
54558: ARRAY
54559: PUSH
54560: LD_VAR 0 3
54564: ARRAY
54565: PUSH
54566: LD_INT 3
54568: ARRAY
54569: PPUSH
54570: CALL_OW 488
54574: PUSH
54575: LD_EXP 30
54579: PUSH
54580: LD_VAR 0 2
54584: ARRAY
54585: PUSH
54586: LD_VAR 0 3
54590: ARRAY
54591: PUSH
54592: LD_INT 2
54594: ARRAY
54595: PPUSH
54596: LD_EXP 30
54600: PUSH
54601: LD_VAR 0 2
54605: ARRAY
54606: PUSH
54607: LD_VAR 0 3
54611: ARRAY
54612: PUSH
54613: LD_INT 3
54615: ARRAY
54616: PPUSH
54617: CALL_OW 284
54621: PUSH
54622: LD_INT 0
54624: EQUAL
54625: AND
54626: IFFALSE 54681
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
54628: LD_ADDR_VAR 0 5
54632: PUSH
54633: LD_EXP 30
54637: PUSH
54638: LD_VAR 0 2
54642: ARRAY
54643: PPUSH
54644: LD_VAR 0 3
54648: PPUSH
54649: CALL_OW 3
54653: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
54654: LD_ADDR_EXP 30
54658: PUSH
54659: LD_EXP 30
54663: PPUSH
54664: LD_VAR 0 2
54668: PPUSH
54669: LD_VAR 0 5
54673: PPUSH
54674: CALL_OW 1
54678: ST_TO_ADDR
// continue ;
54679: GO 54525
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
54681: LD_EXP 14
54685: PUSH
54686: LD_VAR 0 2
54690: ARRAY
54691: PUSH
54692: LD_INT 1
54694: ARRAY
54695: PPUSH
54696: CALL_OW 255
54700: PPUSH
54701: LD_EXP 30
54705: PUSH
54706: LD_VAR 0 2
54710: ARRAY
54711: PUSH
54712: LD_VAR 0 3
54716: ARRAY
54717: PUSH
54718: LD_INT 2
54720: ARRAY
54721: PPUSH
54722: LD_EXP 30
54726: PUSH
54727: LD_VAR 0 2
54731: ARRAY
54732: PUSH
54733: LD_VAR 0 3
54737: ARRAY
54738: PUSH
54739: LD_INT 3
54741: ARRAY
54742: PPUSH
54743: LD_INT 30
54745: PPUSH
54746: CALL 10323 0 4
54750: PUSH
54751: LD_INT 4
54753: ARRAY
54754: PUSH
54755: LD_INT 0
54757: EQUAL
54758: IFFALSE 54784
// begin target := mc_crates [ i ] [ j ] ;
54760: LD_ADDR_VAR 0 6
54764: PUSH
54765: LD_EXP 30
54769: PUSH
54770: LD_VAR 0 2
54774: ARRAY
54775: PUSH
54776: LD_VAR 0 3
54780: ARRAY
54781: ST_TO_ADDR
// break ;
54782: GO 54786
// end ; end ;
54784: GO 54525
54786: POP
54787: POP
// if not target then
54788: LD_VAR 0 6
54792: NOT
54793: IFFALSE 54797
// continue ;
54795: GO 54406
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
54797: LD_ADDR_VAR 0 7
54801: PUSH
54802: LD_EXP 33
54806: PUSH
54807: LD_VAR 0 2
54811: ARRAY
54812: PPUSH
54813: LD_INT 2
54815: PUSH
54816: LD_INT 3
54818: PUSH
54819: LD_INT 58
54821: PUSH
54822: EMPTY
54823: LIST
54824: PUSH
54825: EMPTY
54826: LIST
54827: LIST
54828: PUSH
54829: LD_INT 61
54831: PUSH
54832: EMPTY
54833: LIST
54834: PUSH
54835: LD_INT 33
54837: PUSH
54838: LD_INT 5
54840: PUSH
54841: EMPTY
54842: LIST
54843: LIST
54844: PUSH
54845: LD_INT 33
54847: PUSH
54848: LD_INT 3
54850: PUSH
54851: EMPTY
54852: LIST
54853: LIST
54854: PUSH
54855: EMPTY
54856: LIST
54857: LIST
54858: LIST
54859: LIST
54860: LIST
54861: PUSH
54862: LD_INT 2
54864: PUSH
54865: LD_INT 34
54867: PUSH
54868: LD_INT 32
54870: PUSH
54871: EMPTY
54872: LIST
54873: LIST
54874: PUSH
54875: LD_INT 34
54877: PUSH
54878: LD_INT 51
54880: PUSH
54881: EMPTY
54882: LIST
54883: LIST
54884: PUSH
54885: LD_INT 34
54887: PUSH
54888: LD_INT 12
54890: PUSH
54891: EMPTY
54892: LIST
54893: LIST
54894: PUSH
54895: EMPTY
54896: LIST
54897: LIST
54898: LIST
54899: LIST
54900: PUSH
54901: EMPTY
54902: LIST
54903: LIST
54904: PPUSH
54905: CALL_OW 72
54909: ST_TO_ADDR
// if not cargo then
54910: LD_VAR 0 7
54914: NOT
54915: IFFALSE 55558
// begin if mc_crates_collector [ i ] < 5 then
54917: LD_EXP 31
54921: PUSH
54922: LD_VAR 0 2
54926: ARRAY
54927: PUSH
54928: LD_INT 5
54930: LESS
54931: IFFALSE 55297
// begin if mc_ape [ i ] then
54933: LD_EXP 43
54937: PUSH
54938: LD_VAR 0 2
54942: ARRAY
54943: IFFALSE 54990
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
54945: LD_ADDR_VAR 0 5
54949: PUSH
54950: LD_EXP 43
54954: PUSH
54955: LD_VAR 0 2
54959: ARRAY
54960: PPUSH
54961: LD_INT 25
54963: PUSH
54964: LD_INT 16
54966: PUSH
54967: EMPTY
54968: LIST
54969: LIST
54970: PUSH
54971: LD_INT 24
54973: PUSH
54974: LD_INT 750
54976: PUSH
54977: EMPTY
54978: LIST
54979: LIST
54980: PUSH
54981: EMPTY
54982: LIST
54983: LIST
54984: PPUSH
54985: CALL_OW 72
54989: ST_TO_ADDR
// if not tmp then
54990: LD_VAR 0 5
54994: NOT
54995: IFFALSE 55042
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
54997: LD_ADDR_VAR 0 5
55001: PUSH
55002: LD_EXP 14
55006: PUSH
55007: LD_VAR 0 2
55011: ARRAY
55012: PPUSH
55013: LD_INT 25
55015: PUSH
55016: LD_INT 2
55018: PUSH
55019: EMPTY
55020: LIST
55021: LIST
55022: PUSH
55023: LD_INT 24
55025: PUSH
55026: LD_INT 750
55028: PUSH
55029: EMPTY
55030: LIST
55031: LIST
55032: PUSH
55033: EMPTY
55034: LIST
55035: LIST
55036: PPUSH
55037: CALL_OW 72
55041: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
55042: LD_EXP 43
55046: PUSH
55047: LD_VAR 0 2
55051: ARRAY
55052: PUSH
55053: LD_EXP 14
55057: PUSH
55058: LD_VAR 0 2
55062: ARRAY
55063: PPUSH
55064: LD_INT 25
55066: PUSH
55067: LD_INT 2
55069: PUSH
55070: EMPTY
55071: LIST
55072: LIST
55073: PUSH
55074: LD_INT 24
55076: PUSH
55077: LD_INT 750
55079: PUSH
55080: EMPTY
55081: LIST
55082: LIST
55083: PUSH
55084: EMPTY
55085: LIST
55086: LIST
55087: PPUSH
55088: CALL_OW 72
55092: AND
55093: PUSH
55094: LD_VAR 0 5
55098: PUSH
55099: LD_INT 5
55101: LESS
55102: AND
55103: IFFALSE 55185
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
55105: LD_ADDR_VAR 0 3
55109: PUSH
55110: LD_EXP 14
55114: PUSH
55115: LD_VAR 0 2
55119: ARRAY
55120: PPUSH
55121: LD_INT 25
55123: PUSH
55124: LD_INT 2
55126: PUSH
55127: EMPTY
55128: LIST
55129: LIST
55130: PUSH
55131: LD_INT 24
55133: PUSH
55134: LD_INT 750
55136: PUSH
55137: EMPTY
55138: LIST
55139: LIST
55140: PUSH
55141: EMPTY
55142: LIST
55143: LIST
55144: PPUSH
55145: CALL_OW 72
55149: PUSH
55150: FOR_IN
55151: IFFALSE 55183
// begin tmp := tmp union j ;
55153: LD_ADDR_VAR 0 5
55157: PUSH
55158: LD_VAR 0 5
55162: PUSH
55163: LD_VAR 0 3
55167: UNION
55168: ST_TO_ADDR
// if tmp >= 5 then
55169: LD_VAR 0 5
55173: PUSH
55174: LD_INT 5
55176: GREATEREQUAL
55177: IFFALSE 55181
// break ;
55179: GO 55183
// end ;
55181: GO 55150
55183: POP
55184: POP
// end ; if not tmp then
55185: LD_VAR 0 5
55189: NOT
55190: IFFALSE 55194
// continue ;
55192: GO 54406
// for j in tmp do
55194: LD_ADDR_VAR 0 3
55198: PUSH
55199: LD_VAR 0 5
55203: PUSH
55204: FOR_IN
55205: IFFALSE 55295
// if not GetTag ( j ) then
55207: LD_VAR 0 3
55211: PPUSH
55212: CALL_OW 110
55216: NOT
55217: IFFALSE 55293
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
55219: LD_ADDR_EXP 31
55223: PUSH
55224: LD_EXP 31
55228: PPUSH
55229: LD_VAR 0 2
55233: PUSH
55234: LD_EXP 31
55238: PUSH
55239: LD_VAR 0 2
55243: ARRAY
55244: PUSH
55245: LD_INT 1
55247: PLUS
55248: PUSH
55249: EMPTY
55250: LIST
55251: LIST
55252: PPUSH
55253: LD_VAR 0 3
55257: PPUSH
55258: CALL 9427 0 3
55262: ST_TO_ADDR
// SetTag ( j , 107 ) ;
55263: LD_VAR 0 3
55267: PPUSH
55268: LD_INT 107
55270: PPUSH
55271: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
55275: LD_EXP 31
55279: PUSH
55280: LD_VAR 0 2
55284: ARRAY
55285: PUSH
55286: LD_INT 5
55288: GREATEREQUAL
55289: IFFALSE 55293
// break ;
55291: GO 55295
// end ;
55293: GO 55204
55295: POP
55296: POP
// end ; if mc_crates_collector [ i ] and target then
55297: LD_EXP 31
55301: PUSH
55302: LD_VAR 0 2
55306: ARRAY
55307: PUSH
55308: LD_VAR 0 6
55312: AND
55313: IFFALSE 55556
// begin if mc_crates_collector [ i ] < target [ 1 ] then
55315: LD_EXP 31
55319: PUSH
55320: LD_VAR 0 2
55324: ARRAY
55325: PUSH
55326: LD_VAR 0 6
55330: PUSH
55331: LD_INT 1
55333: ARRAY
55334: LESS
55335: IFFALSE 55355
// tmp := mc_crates_collector [ i ] else
55337: LD_ADDR_VAR 0 5
55341: PUSH
55342: LD_EXP 31
55346: PUSH
55347: LD_VAR 0 2
55351: ARRAY
55352: ST_TO_ADDR
55353: GO 55369
// tmp := target [ 1 ] ;
55355: LD_ADDR_VAR 0 5
55359: PUSH
55360: LD_VAR 0 6
55364: PUSH
55365: LD_INT 1
55367: ARRAY
55368: ST_TO_ADDR
// k := 0 ;
55369: LD_ADDR_VAR 0 4
55373: PUSH
55374: LD_INT 0
55376: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
55377: LD_ADDR_VAR 0 3
55381: PUSH
55382: LD_EXP 31
55386: PUSH
55387: LD_VAR 0 2
55391: ARRAY
55392: PUSH
55393: FOR_IN
55394: IFFALSE 55554
// begin k := k + 1 ;
55396: LD_ADDR_VAR 0 4
55400: PUSH
55401: LD_VAR 0 4
55405: PUSH
55406: LD_INT 1
55408: PLUS
55409: ST_TO_ADDR
// if k > tmp then
55410: LD_VAR 0 4
55414: PUSH
55415: LD_VAR 0 5
55419: GREATER
55420: IFFALSE 55424
// break ;
55422: GO 55554
// if not GetClass ( j ) in [ 2 , 16 ] then
55424: LD_VAR 0 3
55428: PPUSH
55429: CALL_OW 257
55433: PUSH
55434: LD_INT 2
55436: PUSH
55437: LD_INT 16
55439: PUSH
55440: EMPTY
55441: LIST
55442: LIST
55443: IN
55444: NOT
55445: IFFALSE 55498
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
55447: LD_ADDR_EXP 31
55451: PUSH
55452: LD_EXP 31
55456: PPUSH
55457: LD_VAR 0 2
55461: PPUSH
55462: LD_EXP 31
55466: PUSH
55467: LD_VAR 0 2
55471: ARRAY
55472: PUSH
55473: LD_VAR 0 3
55477: DIFF
55478: PPUSH
55479: CALL_OW 1
55483: ST_TO_ADDR
// SetTag ( j , 0 ) ;
55484: LD_VAR 0 3
55488: PPUSH
55489: LD_INT 0
55491: PPUSH
55492: CALL_OW 109
// continue ;
55496: GO 55393
// end ; if IsInUnit ( j ) then
55498: LD_VAR 0 3
55502: PPUSH
55503: CALL_OW 310
55507: IFFALSE 55518
// ComExitBuilding ( j ) ;
55509: LD_VAR 0 3
55513: PPUSH
55514: CALL_OW 122
// wait ( 3 ) ;
55518: LD_INT 3
55520: PPUSH
55521: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
55525: LD_VAR 0 3
55529: PPUSH
55530: LD_VAR 0 6
55534: PUSH
55535: LD_INT 2
55537: ARRAY
55538: PPUSH
55539: LD_VAR 0 6
55543: PUSH
55544: LD_INT 3
55546: ARRAY
55547: PPUSH
55548: CALL_OW 117
// end ;
55552: GO 55393
55554: POP
55555: POP
// end ; end else
55556: GO 56137
// begin for j in cargo do
55558: LD_ADDR_VAR 0 3
55562: PUSH
55563: LD_VAR 0 7
55567: PUSH
55568: FOR_IN
55569: IFFALSE 56135
// begin if GetTag ( j ) <> 0 then
55571: LD_VAR 0 3
55575: PPUSH
55576: CALL_OW 110
55580: PUSH
55581: LD_INT 0
55583: NONEQUAL
55584: IFFALSE 55588
// continue ;
55586: GO 55568
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
55588: LD_VAR 0 3
55592: PPUSH
55593: CALL_OW 256
55597: PUSH
55598: LD_INT 1000
55600: LESS
55601: PUSH
55602: LD_VAR 0 3
55606: PPUSH
55607: LD_EXP 38
55611: PUSH
55612: LD_VAR 0 2
55616: ARRAY
55617: PPUSH
55618: CALL_OW 308
55622: NOT
55623: AND
55624: IFFALSE 55646
// ComMoveToArea ( j , mc_parking [ i ] ) ;
55626: LD_VAR 0 3
55630: PPUSH
55631: LD_EXP 38
55635: PUSH
55636: LD_VAR 0 2
55640: ARRAY
55641: PPUSH
55642: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
55646: LD_VAR 0 3
55650: PPUSH
55651: CALL_OW 256
55655: PUSH
55656: LD_INT 1000
55658: LESS
55659: PUSH
55660: LD_VAR 0 3
55664: PPUSH
55665: LD_EXP 38
55669: PUSH
55670: LD_VAR 0 2
55674: ARRAY
55675: PPUSH
55676: CALL_OW 308
55680: AND
55681: IFFALSE 55685
// continue ;
55683: GO 55568
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
55685: LD_VAR 0 3
55689: PPUSH
55690: CALL_OW 262
55694: PUSH
55695: LD_INT 2
55697: EQUAL
55698: PUSH
55699: LD_VAR 0 3
55703: PPUSH
55704: CALL_OW 261
55708: PUSH
55709: LD_INT 15
55711: LESS
55712: AND
55713: IFFALSE 55717
// continue ;
55715: GO 55568
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
55717: LD_VAR 0 3
55721: PPUSH
55722: CALL_OW 262
55726: PUSH
55727: LD_INT 1
55729: EQUAL
55730: PUSH
55731: LD_VAR 0 3
55735: PPUSH
55736: CALL_OW 261
55740: PUSH
55741: LD_INT 10
55743: LESS
55744: AND
55745: IFFALSE 56074
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
55747: LD_ADDR_VAR 0 8
55751: PUSH
55752: LD_EXP 14
55756: PUSH
55757: LD_VAR 0 2
55761: ARRAY
55762: PPUSH
55763: LD_INT 2
55765: PUSH
55766: LD_INT 30
55768: PUSH
55769: LD_INT 0
55771: PUSH
55772: EMPTY
55773: LIST
55774: LIST
55775: PUSH
55776: LD_INT 30
55778: PUSH
55779: LD_INT 1
55781: PUSH
55782: EMPTY
55783: LIST
55784: LIST
55785: PUSH
55786: EMPTY
55787: LIST
55788: LIST
55789: LIST
55790: PPUSH
55791: CALL_OW 72
55795: ST_TO_ADDR
// if not depot then
55796: LD_VAR 0 8
55800: NOT
55801: IFFALSE 55805
// continue ;
55803: GO 55568
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
55805: LD_VAR 0 3
55809: PPUSH
55810: LD_VAR 0 8
55814: PPUSH
55815: LD_VAR 0 3
55819: PPUSH
55820: CALL_OW 74
55824: PPUSH
55825: CALL_OW 296
55829: PUSH
55830: LD_INT 6
55832: LESS
55833: IFFALSE 55849
// SetFuel ( j , 100 ) else
55835: LD_VAR 0 3
55839: PPUSH
55840: LD_INT 100
55842: PPUSH
55843: CALL_OW 240
55847: GO 56074
// if GetFuel ( j ) = 0 then
55849: LD_VAR 0 3
55853: PPUSH
55854: CALL_OW 261
55858: PUSH
55859: LD_INT 0
55861: EQUAL
55862: IFFALSE 56074
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
55864: LD_ADDR_EXP 33
55868: PUSH
55869: LD_EXP 33
55873: PPUSH
55874: LD_VAR 0 2
55878: PPUSH
55879: LD_EXP 33
55883: PUSH
55884: LD_VAR 0 2
55888: ARRAY
55889: PUSH
55890: LD_VAR 0 3
55894: DIFF
55895: PPUSH
55896: CALL_OW 1
55900: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
55901: LD_VAR 0 3
55905: PPUSH
55906: CALL_OW 263
55910: PUSH
55911: LD_INT 1
55913: EQUAL
55914: IFFALSE 55930
// ComExitVehicle ( IsInUnit ( j ) ) ;
55916: LD_VAR 0 3
55920: PPUSH
55921: CALL_OW 310
55925: PPUSH
55926: CALL_OW 121
// if GetControl ( j ) = control_remote then
55930: LD_VAR 0 3
55934: PPUSH
55935: CALL_OW 263
55939: PUSH
55940: LD_INT 2
55942: EQUAL
55943: IFFALSE 55954
// ComUnlink ( j ) ;
55945: LD_VAR 0 3
55949: PPUSH
55950: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
55954: LD_ADDR_VAR 0 9
55958: PUSH
55959: LD_VAR 0 2
55963: PPUSH
55964: LD_INT 3
55966: PPUSH
55967: CALL 65427 0 2
55971: ST_TO_ADDR
// if fac then
55972: LD_VAR 0 9
55976: IFFALSE 56072
// begin for k in fac do
55978: LD_ADDR_VAR 0 4
55982: PUSH
55983: LD_VAR 0 9
55987: PUSH
55988: FOR_IN
55989: IFFALSE 56070
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
55991: LD_ADDR_VAR 0 10
55995: PUSH
55996: LD_VAR 0 9
56000: PPUSH
56001: LD_VAR 0 3
56005: PPUSH
56006: CALL_OW 265
56010: PPUSH
56011: LD_VAR 0 3
56015: PPUSH
56016: CALL_OW 262
56020: PPUSH
56021: LD_VAR 0 3
56025: PPUSH
56026: CALL_OW 263
56030: PPUSH
56031: LD_VAR 0 3
56035: PPUSH
56036: CALL_OW 264
56040: PPUSH
56041: CALL 6959 0 5
56045: ST_TO_ADDR
// if components then
56046: LD_VAR 0 10
56050: IFFALSE 56068
// begin MC_InsertProduceList ( i , components ) ;
56052: LD_VAR 0 2
56056: PPUSH
56057: LD_VAR 0 10
56061: PPUSH
56062: CALL 64972 0 2
// break ;
56066: GO 56070
// end ; end ;
56068: GO 55988
56070: POP
56071: POP
// end ; continue ;
56072: GO 55568
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
56074: LD_VAR 0 3
56078: PPUSH
56079: LD_INT 1
56081: PPUSH
56082: CALL_OW 289
56086: PUSH
56087: LD_INT 100
56089: LESS
56090: PUSH
56091: LD_VAR 0 3
56095: PPUSH
56096: CALL_OW 314
56100: NOT
56101: AND
56102: IFFALSE 56131
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
56104: LD_VAR 0 3
56108: PPUSH
56109: LD_VAR 0 6
56113: PUSH
56114: LD_INT 2
56116: ARRAY
56117: PPUSH
56118: LD_VAR 0 6
56122: PUSH
56123: LD_INT 3
56125: ARRAY
56126: PPUSH
56127: CALL_OW 117
// break ;
56131: GO 56135
// end ;
56133: GO 55568
56135: POP
56136: POP
// end ; end ;
56137: GO 54406
56139: POP
56140: POP
// end ;
56141: LD_VAR 0 1
56145: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
56146: LD_INT 0
56148: PPUSH
56149: PPUSH
56150: PPUSH
56151: PPUSH
// if not mc_bases then
56152: LD_EXP 14
56156: NOT
56157: IFFALSE 56161
// exit ;
56159: GO 56322
// for i = 1 to mc_bases do
56161: LD_ADDR_VAR 0 2
56165: PUSH
56166: DOUBLE
56167: LD_INT 1
56169: DEC
56170: ST_TO_ADDR
56171: LD_EXP 14
56175: PUSH
56176: FOR_TO
56177: IFFALSE 56320
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
56179: LD_ADDR_VAR 0 4
56183: PUSH
56184: LD_EXP 33
56188: PUSH
56189: LD_VAR 0 2
56193: ARRAY
56194: PUSH
56195: LD_EXP 36
56199: PUSH
56200: LD_VAR 0 2
56204: ARRAY
56205: UNION
56206: PPUSH
56207: LD_INT 33
56209: PUSH
56210: LD_INT 2
56212: PUSH
56213: EMPTY
56214: LIST
56215: LIST
56216: PPUSH
56217: CALL_OW 72
56221: ST_TO_ADDR
// if tmp then
56222: LD_VAR 0 4
56226: IFFALSE 56318
// for j in tmp do
56228: LD_ADDR_VAR 0 3
56232: PUSH
56233: LD_VAR 0 4
56237: PUSH
56238: FOR_IN
56239: IFFALSE 56316
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
56241: LD_VAR 0 3
56245: PPUSH
56246: CALL_OW 312
56250: NOT
56251: PUSH
56252: LD_VAR 0 3
56256: PPUSH
56257: CALL_OW 256
56261: PUSH
56262: LD_INT 250
56264: GREATEREQUAL
56265: AND
56266: IFFALSE 56279
// Connect ( j ) else
56268: LD_VAR 0 3
56272: PPUSH
56273: CALL 12360 0 1
56277: GO 56314
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
56279: LD_VAR 0 3
56283: PPUSH
56284: CALL_OW 256
56288: PUSH
56289: LD_INT 250
56291: LESS
56292: PUSH
56293: LD_VAR 0 3
56297: PPUSH
56298: CALL_OW 312
56302: AND
56303: IFFALSE 56314
// ComUnlink ( j ) ;
56305: LD_VAR 0 3
56309: PPUSH
56310: CALL_OW 136
56314: GO 56238
56316: POP
56317: POP
// end ;
56318: GO 56176
56320: POP
56321: POP
// end ;
56322: LD_VAR 0 1
56326: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
56327: LD_INT 0
56329: PPUSH
56330: PPUSH
56331: PPUSH
56332: PPUSH
56333: PPUSH
// if not mc_bases then
56334: LD_EXP 14
56338: NOT
56339: IFFALSE 56343
// exit ;
56341: GO 56788
// for i = 1 to mc_bases do
56343: LD_ADDR_VAR 0 2
56347: PUSH
56348: DOUBLE
56349: LD_INT 1
56351: DEC
56352: ST_TO_ADDR
56353: LD_EXP 14
56357: PUSH
56358: FOR_TO
56359: IFFALSE 56786
// begin if not mc_produce [ i ] then
56361: LD_EXP 35
56365: PUSH
56366: LD_VAR 0 2
56370: ARRAY
56371: NOT
56372: IFFALSE 56376
// continue ;
56374: GO 56358
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
56376: LD_ADDR_VAR 0 5
56380: PUSH
56381: LD_EXP 14
56385: PUSH
56386: LD_VAR 0 2
56390: ARRAY
56391: PPUSH
56392: LD_INT 30
56394: PUSH
56395: LD_INT 3
56397: PUSH
56398: EMPTY
56399: LIST
56400: LIST
56401: PPUSH
56402: CALL_OW 72
56406: ST_TO_ADDR
// if not fac then
56407: LD_VAR 0 5
56411: NOT
56412: IFFALSE 56416
// continue ;
56414: GO 56358
// for j in fac do
56416: LD_ADDR_VAR 0 3
56420: PUSH
56421: LD_VAR 0 5
56425: PUSH
56426: FOR_IN
56427: IFFALSE 56782
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
56429: LD_VAR 0 3
56433: PPUSH
56434: CALL_OW 461
56438: PUSH
56439: LD_INT 2
56441: NONEQUAL
56442: PUSH
56443: LD_VAR 0 3
56447: PPUSH
56448: LD_INT 15
56450: PPUSH
56451: CALL 12020 0 2
56455: PUSH
56456: LD_INT 4
56458: ARRAY
56459: OR
56460: IFFALSE 56464
// continue ;
56462: GO 56426
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
56464: LD_VAR 0 3
56468: PPUSH
56469: LD_EXP 35
56473: PUSH
56474: LD_VAR 0 2
56478: ARRAY
56479: PUSH
56480: LD_INT 1
56482: ARRAY
56483: PUSH
56484: LD_INT 1
56486: ARRAY
56487: PPUSH
56488: LD_EXP 35
56492: PUSH
56493: LD_VAR 0 2
56497: ARRAY
56498: PUSH
56499: LD_INT 1
56501: ARRAY
56502: PUSH
56503: LD_INT 2
56505: ARRAY
56506: PPUSH
56507: LD_EXP 35
56511: PUSH
56512: LD_VAR 0 2
56516: ARRAY
56517: PUSH
56518: LD_INT 1
56520: ARRAY
56521: PUSH
56522: LD_INT 3
56524: ARRAY
56525: PPUSH
56526: LD_EXP 35
56530: PUSH
56531: LD_VAR 0 2
56535: ARRAY
56536: PUSH
56537: LD_INT 1
56539: ARRAY
56540: PUSH
56541: LD_INT 4
56543: ARRAY
56544: PPUSH
56545: CALL_OW 448
56549: PUSH
56550: LD_VAR 0 3
56554: PPUSH
56555: LD_EXP 35
56559: PUSH
56560: LD_VAR 0 2
56564: ARRAY
56565: PUSH
56566: LD_INT 1
56568: ARRAY
56569: PUSH
56570: LD_INT 1
56572: ARRAY
56573: PUSH
56574: LD_EXP 35
56578: PUSH
56579: LD_VAR 0 2
56583: ARRAY
56584: PUSH
56585: LD_INT 1
56587: ARRAY
56588: PUSH
56589: LD_INT 2
56591: ARRAY
56592: PUSH
56593: LD_EXP 35
56597: PUSH
56598: LD_VAR 0 2
56602: ARRAY
56603: PUSH
56604: LD_INT 1
56606: ARRAY
56607: PUSH
56608: LD_INT 3
56610: ARRAY
56611: PUSH
56612: LD_EXP 35
56616: PUSH
56617: LD_VAR 0 2
56621: ARRAY
56622: PUSH
56623: LD_INT 1
56625: ARRAY
56626: PUSH
56627: LD_INT 4
56629: ARRAY
56630: PUSH
56631: EMPTY
56632: LIST
56633: LIST
56634: LIST
56635: LIST
56636: PPUSH
56637: CALL 15691 0 2
56641: AND
56642: IFFALSE 56780
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
56644: LD_VAR 0 3
56648: PPUSH
56649: LD_EXP 35
56653: PUSH
56654: LD_VAR 0 2
56658: ARRAY
56659: PUSH
56660: LD_INT 1
56662: ARRAY
56663: PUSH
56664: LD_INT 1
56666: ARRAY
56667: PPUSH
56668: LD_EXP 35
56672: PUSH
56673: LD_VAR 0 2
56677: ARRAY
56678: PUSH
56679: LD_INT 1
56681: ARRAY
56682: PUSH
56683: LD_INT 2
56685: ARRAY
56686: PPUSH
56687: LD_EXP 35
56691: PUSH
56692: LD_VAR 0 2
56696: ARRAY
56697: PUSH
56698: LD_INT 1
56700: ARRAY
56701: PUSH
56702: LD_INT 3
56704: ARRAY
56705: PPUSH
56706: LD_EXP 35
56710: PUSH
56711: LD_VAR 0 2
56715: ARRAY
56716: PUSH
56717: LD_INT 1
56719: ARRAY
56720: PUSH
56721: LD_INT 4
56723: ARRAY
56724: PPUSH
56725: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
56729: LD_ADDR_VAR 0 4
56733: PUSH
56734: LD_EXP 35
56738: PUSH
56739: LD_VAR 0 2
56743: ARRAY
56744: PPUSH
56745: LD_INT 1
56747: PPUSH
56748: CALL_OW 3
56752: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
56753: LD_ADDR_EXP 35
56757: PUSH
56758: LD_EXP 35
56762: PPUSH
56763: LD_VAR 0 2
56767: PPUSH
56768: LD_VAR 0 4
56772: PPUSH
56773: CALL_OW 1
56777: ST_TO_ADDR
// break ;
56778: GO 56782
// end ; end ;
56780: GO 56426
56782: POP
56783: POP
// end ;
56784: GO 56358
56786: POP
56787: POP
// end ;
56788: LD_VAR 0 1
56792: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
56793: LD_INT 0
56795: PPUSH
56796: PPUSH
56797: PPUSH
// if not mc_bases then
56798: LD_EXP 14
56802: NOT
56803: IFFALSE 56807
// exit ;
56805: GO 56896
// for i = 1 to mc_bases do
56807: LD_ADDR_VAR 0 2
56811: PUSH
56812: DOUBLE
56813: LD_INT 1
56815: DEC
56816: ST_TO_ADDR
56817: LD_EXP 14
56821: PUSH
56822: FOR_TO
56823: IFFALSE 56894
// begin if mc_attack [ i ] then
56825: LD_EXP 34
56829: PUSH
56830: LD_VAR 0 2
56834: ARRAY
56835: IFFALSE 56892
// begin tmp := mc_attack [ i ] [ 1 ] ;
56837: LD_ADDR_VAR 0 3
56841: PUSH
56842: LD_EXP 34
56846: PUSH
56847: LD_VAR 0 2
56851: ARRAY
56852: PUSH
56853: LD_INT 1
56855: ARRAY
56856: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
56857: LD_ADDR_EXP 34
56861: PUSH
56862: LD_EXP 34
56866: PPUSH
56867: LD_VAR 0 2
56871: PPUSH
56872: EMPTY
56873: PPUSH
56874: CALL_OW 1
56878: ST_TO_ADDR
// Attack ( tmp ) ;
56879: LD_VAR 0 3
56883: PPUSH
56884: CALL 71460 0 1
// exit ;
56888: POP
56889: POP
56890: GO 56896
// end ; end ;
56892: GO 56822
56894: POP
56895: POP
// end ;
56896: LD_VAR 0 1
56900: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
56901: LD_INT 0
56903: PPUSH
56904: PPUSH
56905: PPUSH
56906: PPUSH
56907: PPUSH
56908: PPUSH
56909: PPUSH
// if not mc_bases then
56910: LD_EXP 14
56914: NOT
56915: IFFALSE 56919
// exit ;
56917: GO 57501
// for i = 1 to mc_bases do
56919: LD_ADDR_VAR 0 2
56923: PUSH
56924: DOUBLE
56925: LD_INT 1
56927: DEC
56928: ST_TO_ADDR
56929: LD_EXP 14
56933: PUSH
56934: FOR_TO
56935: IFFALSE 57499
// begin if not mc_bases [ i ] then
56937: LD_EXP 14
56941: PUSH
56942: LD_VAR 0 2
56946: ARRAY
56947: NOT
56948: IFFALSE 56952
// continue ;
56950: GO 56934
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
56952: LD_ADDR_VAR 0 7
56956: PUSH
56957: LD_EXP 14
56961: PUSH
56962: LD_VAR 0 2
56966: ARRAY
56967: PUSH
56968: LD_INT 1
56970: ARRAY
56971: PPUSH
56972: CALL 6263 0 1
56976: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
56977: LD_ADDR_EXP 37
56981: PUSH
56982: LD_EXP 37
56986: PPUSH
56987: LD_VAR 0 2
56991: PPUSH
56992: LD_EXP 14
56996: PUSH
56997: LD_VAR 0 2
57001: ARRAY
57002: PUSH
57003: LD_INT 1
57005: ARRAY
57006: PPUSH
57007: CALL_OW 255
57011: PPUSH
57012: LD_EXP 39
57016: PUSH
57017: LD_VAR 0 2
57021: ARRAY
57022: PPUSH
57023: CALL 6228 0 2
57027: PPUSH
57028: CALL_OW 1
57032: ST_TO_ADDR
// if not mc_scan [ i ] then
57033: LD_EXP 37
57037: PUSH
57038: LD_VAR 0 2
57042: ARRAY
57043: NOT
57044: IFFALSE 57199
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
57046: LD_ADDR_VAR 0 4
57050: PUSH
57051: LD_EXP 14
57055: PUSH
57056: LD_VAR 0 2
57060: ARRAY
57061: PPUSH
57062: LD_INT 2
57064: PUSH
57065: LD_INT 25
57067: PUSH
57068: LD_INT 5
57070: PUSH
57071: EMPTY
57072: LIST
57073: LIST
57074: PUSH
57075: LD_INT 25
57077: PUSH
57078: LD_INT 8
57080: PUSH
57081: EMPTY
57082: LIST
57083: LIST
57084: PUSH
57085: LD_INT 25
57087: PUSH
57088: LD_INT 9
57090: PUSH
57091: EMPTY
57092: LIST
57093: LIST
57094: PUSH
57095: EMPTY
57096: LIST
57097: LIST
57098: LIST
57099: LIST
57100: PPUSH
57101: CALL_OW 72
57105: ST_TO_ADDR
// if not tmp then
57106: LD_VAR 0 4
57110: NOT
57111: IFFALSE 57115
// continue ;
57113: GO 56934
// for j in tmp do
57115: LD_ADDR_VAR 0 3
57119: PUSH
57120: LD_VAR 0 4
57124: PUSH
57125: FOR_IN
57126: IFFALSE 57197
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
57128: LD_VAR 0 3
57132: PPUSH
57133: CALL_OW 310
57137: PPUSH
57138: CALL_OW 266
57142: PUSH
57143: LD_INT 5
57145: EQUAL
57146: PUSH
57147: LD_VAR 0 3
57151: PPUSH
57152: CALL_OW 257
57156: PUSH
57157: LD_INT 1
57159: EQUAL
57160: AND
57161: PUSH
57162: LD_VAR 0 3
57166: PPUSH
57167: CALL_OW 459
57171: NOT
57172: AND
57173: PUSH
57174: LD_VAR 0 7
57178: AND
57179: IFFALSE 57195
// ComChangeProfession ( j , class ) ;
57181: LD_VAR 0 3
57185: PPUSH
57186: LD_VAR 0 7
57190: PPUSH
57191: CALL_OW 123
57195: GO 57125
57197: POP
57198: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
57199: LD_EXP 37
57203: PUSH
57204: LD_VAR 0 2
57208: ARRAY
57209: PUSH
57210: LD_EXP 36
57214: PUSH
57215: LD_VAR 0 2
57219: ARRAY
57220: NOT
57221: AND
57222: PUSH
57223: LD_EXP 14
57227: PUSH
57228: LD_VAR 0 2
57232: ARRAY
57233: PPUSH
57234: LD_INT 30
57236: PUSH
57237: LD_INT 32
57239: PUSH
57240: EMPTY
57241: LIST
57242: LIST
57243: PPUSH
57244: CALL_OW 72
57248: NOT
57249: AND
57250: PUSH
57251: LD_EXP 14
57255: PUSH
57256: LD_VAR 0 2
57260: ARRAY
57261: PPUSH
57262: LD_INT 2
57264: PUSH
57265: LD_INT 30
57267: PUSH
57268: LD_INT 4
57270: PUSH
57271: EMPTY
57272: LIST
57273: LIST
57274: PUSH
57275: LD_INT 30
57277: PUSH
57278: LD_INT 5
57280: PUSH
57281: EMPTY
57282: LIST
57283: LIST
57284: PUSH
57285: EMPTY
57286: LIST
57287: LIST
57288: LIST
57289: PPUSH
57290: CALL_OW 72
57294: NOT
57295: AND
57296: IFFALSE 57428
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
57298: LD_ADDR_VAR 0 4
57302: PUSH
57303: LD_EXP 14
57307: PUSH
57308: LD_VAR 0 2
57312: ARRAY
57313: PPUSH
57314: LD_INT 2
57316: PUSH
57317: LD_INT 25
57319: PUSH
57320: LD_INT 1
57322: PUSH
57323: EMPTY
57324: LIST
57325: LIST
57326: PUSH
57327: LD_INT 25
57329: PUSH
57330: LD_INT 5
57332: PUSH
57333: EMPTY
57334: LIST
57335: LIST
57336: PUSH
57337: LD_INT 25
57339: PUSH
57340: LD_INT 8
57342: PUSH
57343: EMPTY
57344: LIST
57345: LIST
57346: PUSH
57347: LD_INT 25
57349: PUSH
57350: LD_INT 9
57352: PUSH
57353: EMPTY
57354: LIST
57355: LIST
57356: PUSH
57357: EMPTY
57358: LIST
57359: LIST
57360: LIST
57361: LIST
57362: LIST
57363: PPUSH
57364: CALL_OW 72
57368: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
57369: LD_ADDR_VAR 0 4
57373: PUSH
57374: LD_VAR 0 4
57378: PUSH
57379: LD_VAR 0 4
57383: PPUSH
57384: LD_INT 18
57386: PPUSH
57387: CALL 37988 0 2
57391: DIFF
57392: ST_TO_ADDR
// if tmp then
57393: LD_VAR 0 4
57397: IFFALSE 57428
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
57399: LD_VAR 0 2
57403: PPUSH
57404: LD_VAR 0 4
57408: PPUSH
57409: LD_EXP 39
57413: PUSH
57414: LD_VAR 0 2
57418: ARRAY
57419: PPUSH
57420: CALL 76169 0 3
// exit ;
57424: POP
57425: POP
57426: GO 57501
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
57428: LD_EXP 37
57432: PUSH
57433: LD_VAR 0 2
57437: ARRAY
57438: PUSH
57439: LD_EXP 36
57443: PUSH
57444: LD_VAR 0 2
57448: ARRAY
57449: AND
57450: IFFALSE 57497
// begin tmp := mc_defender [ i ] ;
57452: LD_ADDR_VAR 0 4
57456: PUSH
57457: LD_EXP 36
57461: PUSH
57462: LD_VAR 0 2
57466: ARRAY
57467: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
57468: LD_VAR 0 2
57472: PPUSH
57473: LD_VAR 0 4
57477: PPUSH
57478: LD_EXP 37
57482: PUSH
57483: LD_VAR 0 2
57487: ARRAY
57488: PPUSH
57489: CALL 76730 0 3
// exit ;
57493: POP
57494: POP
57495: GO 57501
// end ; end ;
57497: GO 56934
57499: POP
57500: POP
// end ;
57501: LD_VAR 0 1
57505: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
57506: LD_INT 0
57508: PPUSH
57509: PPUSH
57510: PPUSH
57511: PPUSH
57512: PPUSH
57513: PPUSH
57514: PPUSH
57515: PPUSH
57516: PPUSH
57517: PPUSH
57518: PPUSH
// if not mc_bases then
57519: LD_EXP 14
57523: NOT
57524: IFFALSE 57528
// exit ;
57526: GO 58615
// for i = 1 to mc_bases do
57528: LD_ADDR_VAR 0 2
57532: PUSH
57533: DOUBLE
57534: LD_INT 1
57536: DEC
57537: ST_TO_ADDR
57538: LD_EXP 14
57542: PUSH
57543: FOR_TO
57544: IFFALSE 58613
// begin tmp := mc_lab [ i ] ;
57546: LD_ADDR_VAR 0 6
57550: PUSH
57551: LD_EXP 47
57555: PUSH
57556: LD_VAR 0 2
57560: ARRAY
57561: ST_TO_ADDR
// if not tmp then
57562: LD_VAR 0 6
57566: NOT
57567: IFFALSE 57571
// continue ;
57569: GO 57543
// idle_lab := 0 ;
57571: LD_ADDR_VAR 0 11
57575: PUSH
57576: LD_INT 0
57578: ST_TO_ADDR
// for j in tmp do
57579: LD_ADDR_VAR 0 3
57583: PUSH
57584: LD_VAR 0 6
57588: PUSH
57589: FOR_IN
57590: IFFALSE 58609
// begin researching := false ;
57592: LD_ADDR_VAR 0 10
57596: PUSH
57597: LD_INT 0
57599: ST_TO_ADDR
// side := GetSide ( j ) ;
57600: LD_ADDR_VAR 0 4
57604: PUSH
57605: LD_VAR 0 3
57609: PPUSH
57610: CALL_OW 255
57614: ST_TO_ADDR
// if not mc_tech [ side ] then
57615: LD_EXP 41
57619: PUSH
57620: LD_VAR 0 4
57624: ARRAY
57625: NOT
57626: IFFALSE 57630
// continue ;
57628: GO 57589
// if BuildingStatus ( j ) = bs_idle then
57630: LD_VAR 0 3
57634: PPUSH
57635: CALL_OW 461
57639: PUSH
57640: LD_INT 2
57642: EQUAL
57643: IFFALSE 57831
// begin if idle_lab and UnitsInside ( j ) < 6 then
57645: LD_VAR 0 11
57649: PUSH
57650: LD_VAR 0 3
57654: PPUSH
57655: CALL_OW 313
57659: PUSH
57660: LD_INT 6
57662: LESS
57663: AND
57664: IFFALSE 57735
// begin tmp2 := UnitsInside ( idle_lab ) ;
57666: LD_ADDR_VAR 0 9
57670: PUSH
57671: LD_VAR 0 11
57675: PPUSH
57676: CALL_OW 313
57680: ST_TO_ADDR
// if tmp2 then
57681: LD_VAR 0 9
57685: IFFALSE 57727
// for x in tmp2 do
57687: LD_ADDR_VAR 0 7
57691: PUSH
57692: LD_VAR 0 9
57696: PUSH
57697: FOR_IN
57698: IFFALSE 57725
// begin ComExitBuilding ( x ) ;
57700: LD_VAR 0 7
57704: PPUSH
57705: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
57709: LD_VAR 0 7
57713: PPUSH
57714: LD_VAR 0 3
57718: PPUSH
57719: CALL_OW 180
// end ;
57723: GO 57697
57725: POP
57726: POP
// idle_lab := 0 ;
57727: LD_ADDR_VAR 0 11
57731: PUSH
57732: LD_INT 0
57734: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
57735: LD_ADDR_VAR 0 5
57739: PUSH
57740: LD_EXP 41
57744: PUSH
57745: LD_VAR 0 4
57749: ARRAY
57750: PUSH
57751: FOR_IN
57752: IFFALSE 57812
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
57754: LD_VAR 0 3
57758: PPUSH
57759: LD_VAR 0 5
57763: PPUSH
57764: CALL_OW 430
57768: PUSH
57769: LD_VAR 0 4
57773: PPUSH
57774: LD_VAR 0 5
57778: PPUSH
57779: CALL 5333 0 2
57783: AND
57784: IFFALSE 57810
// begin researching := true ;
57786: LD_ADDR_VAR 0 10
57790: PUSH
57791: LD_INT 1
57793: ST_TO_ADDR
// ComResearch ( j , t ) ;
57794: LD_VAR 0 3
57798: PPUSH
57799: LD_VAR 0 5
57803: PPUSH
57804: CALL_OW 124
// break ;
57808: GO 57812
// end ;
57810: GO 57751
57812: POP
57813: POP
// if not researching then
57814: LD_VAR 0 10
57818: NOT
57819: IFFALSE 57831
// idle_lab := j ;
57821: LD_ADDR_VAR 0 11
57825: PUSH
57826: LD_VAR 0 3
57830: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
57831: LD_VAR 0 3
57835: PPUSH
57836: CALL_OW 461
57840: PUSH
57841: LD_INT 10
57843: EQUAL
57844: IFFALSE 58432
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
57846: LD_EXP 43
57850: PUSH
57851: LD_VAR 0 2
57855: ARRAY
57856: NOT
57857: PUSH
57858: LD_EXP 44
57862: PUSH
57863: LD_VAR 0 2
57867: ARRAY
57868: NOT
57869: AND
57870: PUSH
57871: LD_EXP 41
57875: PUSH
57876: LD_VAR 0 4
57880: ARRAY
57881: PUSH
57882: LD_INT 1
57884: GREATER
57885: AND
57886: IFFALSE 58017
// begin ComCancel ( j ) ;
57888: LD_VAR 0 3
57892: PPUSH
57893: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
57897: LD_ADDR_EXP 41
57901: PUSH
57902: LD_EXP 41
57906: PPUSH
57907: LD_VAR 0 4
57911: PPUSH
57912: LD_EXP 41
57916: PUSH
57917: LD_VAR 0 4
57921: ARRAY
57922: PPUSH
57923: LD_EXP 41
57927: PUSH
57928: LD_VAR 0 4
57932: ARRAY
57933: PUSH
57934: LD_INT 1
57936: MINUS
57937: PPUSH
57938: LD_EXP 41
57942: PUSH
57943: LD_VAR 0 4
57947: ARRAY
57948: PPUSH
57949: LD_INT 0
57951: PPUSH
57952: CALL 8845 0 4
57956: PPUSH
57957: CALL_OW 1
57961: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
57962: LD_ADDR_EXP 41
57966: PUSH
57967: LD_EXP 41
57971: PPUSH
57972: LD_VAR 0 4
57976: PPUSH
57977: LD_EXP 41
57981: PUSH
57982: LD_VAR 0 4
57986: ARRAY
57987: PPUSH
57988: LD_EXP 41
57992: PUSH
57993: LD_VAR 0 4
57997: ARRAY
57998: PPUSH
57999: LD_INT 1
58001: PPUSH
58002: LD_INT 0
58004: PPUSH
58005: CALL 8845 0 4
58009: PPUSH
58010: CALL_OW 1
58014: ST_TO_ADDR
// continue ;
58015: GO 57589
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
58017: LD_EXP 43
58021: PUSH
58022: LD_VAR 0 2
58026: ARRAY
58027: PUSH
58028: LD_EXP 44
58032: PUSH
58033: LD_VAR 0 2
58037: ARRAY
58038: NOT
58039: AND
58040: IFFALSE 58167
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
58042: LD_ADDR_EXP 44
58046: PUSH
58047: LD_EXP 44
58051: PPUSH
58052: LD_VAR 0 2
58056: PUSH
58057: LD_EXP 44
58061: PUSH
58062: LD_VAR 0 2
58066: ARRAY
58067: PUSH
58068: LD_INT 1
58070: PLUS
58071: PUSH
58072: EMPTY
58073: LIST
58074: LIST
58075: PPUSH
58076: LD_EXP 43
58080: PUSH
58081: LD_VAR 0 2
58085: ARRAY
58086: PUSH
58087: LD_INT 1
58089: ARRAY
58090: PPUSH
58091: CALL 9427 0 3
58095: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
58096: LD_EXP 43
58100: PUSH
58101: LD_VAR 0 2
58105: ARRAY
58106: PUSH
58107: LD_INT 1
58109: ARRAY
58110: PPUSH
58111: LD_INT 112
58113: PPUSH
58114: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
58118: LD_ADDR_VAR 0 9
58122: PUSH
58123: LD_EXP 43
58127: PUSH
58128: LD_VAR 0 2
58132: ARRAY
58133: PPUSH
58134: LD_INT 1
58136: PPUSH
58137: CALL_OW 3
58141: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
58142: LD_ADDR_EXP 43
58146: PUSH
58147: LD_EXP 43
58151: PPUSH
58152: LD_VAR 0 2
58156: PPUSH
58157: LD_VAR 0 9
58161: PPUSH
58162: CALL_OW 1
58166: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
58167: LD_EXP 43
58171: PUSH
58172: LD_VAR 0 2
58176: ARRAY
58177: PUSH
58178: LD_EXP 44
58182: PUSH
58183: LD_VAR 0 2
58187: ARRAY
58188: AND
58189: PUSH
58190: LD_EXP 44
58194: PUSH
58195: LD_VAR 0 2
58199: ARRAY
58200: PUSH
58201: LD_INT 1
58203: ARRAY
58204: PPUSH
58205: CALL_OW 310
58209: NOT
58210: AND
58211: PUSH
58212: LD_VAR 0 3
58216: PPUSH
58217: CALL_OW 313
58221: PUSH
58222: LD_INT 6
58224: EQUAL
58225: AND
58226: IFFALSE 58282
// begin tmp2 := UnitsInside ( j ) ;
58228: LD_ADDR_VAR 0 9
58232: PUSH
58233: LD_VAR 0 3
58237: PPUSH
58238: CALL_OW 313
58242: ST_TO_ADDR
// if tmp2 = 6 then
58243: LD_VAR 0 9
58247: PUSH
58248: LD_INT 6
58250: EQUAL
58251: IFFALSE 58282
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
58253: LD_VAR 0 9
58257: PUSH
58258: LD_INT 1
58260: ARRAY
58261: PPUSH
58262: LD_INT 112
58264: PPUSH
58265: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
58269: LD_VAR 0 9
58273: PUSH
58274: LD_INT 1
58276: ARRAY
58277: PPUSH
58278: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
58282: LD_EXP 44
58286: PUSH
58287: LD_VAR 0 2
58291: ARRAY
58292: PUSH
58293: LD_EXP 44
58297: PUSH
58298: LD_VAR 0 2
58302: ARRAY
58303: PUSH
58304: LD_INT 1
58306: ARRAY
58307: PPUSH
58308: CALL_OW 314
58312: NOT
58313: AND
58314: PUSH
58315: LD_EXP 44
58319: PUSH
58320: LD_VAR 0 2
58324: ARRAY
58325: PUSH
58326: LD_INT 1
58328: ARRAY
58329: PPUSH
58330: CALL_OW 310
58334: NOT
58335: AND
58336: IFFALSE 58362
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
58338: LD_EXP 44
58342: PUSH
58343: LD_VAR 0 2
58347: ARRAY
58348: PUSH
58349: LD_INT 1
58351: ARRAY
58352: PPUSH
58353: LD_VAR 0 3
58357: PPUSH
58358: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
58362: LD_EXP 44
58366: PUSH
58367: LD_VAR 0 2
58371: ARRAY
58372: PUSH
58373: LD_INT 1
58375: ARRAY
58376: PPUSH
58377: CALL_OW 310
58381: PUSH
58382: LD_EXP 44
58386: PUSH
58387: LD_VAR 0 2
58391: ARRAY
58392: PUSH
58393: LD_INT 1
58395: ARRAY
58396: PPUSH
58397: CALL_OW 310
58401: PPUSH
58402: CALL_OW 461
58406: PUSH
58407: LD_INT 3
58409: NONEQUAL
58410: AND
58411: IFFALSE 58432
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
58413: LD_EXP 44
58417: PUSH
58418: LD_VAR 0 2
58422: ARRAY
58423: PUSH
58424: LD_INT 1
58426: ARRAY
58427: PPUSH
58428: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
58432: LD_VAR 0 3
58436: PPUSH
58437: CALL_OW 461
58441: PUSH
58442: LD_INT 6
58444: EQUAL
58445: PUSH
58446: LD_VAR 0 6
58450: PUSH
58451: LD_INT 1
58453: GREATER
58454: AND
58455: IFFALSE 58607
// begin sci := [ ] ;
58457: LD_ADDR_VAR 0 8
58461: PUSH
58462: EMPTY
58463: ST_TO_ADDR
// for x in ( tmp diff j ) do
58464: LD_ADDR_VAR 0 7
58468: PUSH
58469: LD_VAR 0 6
58473: PUSH
58474: LD_VAR 0 3
58478: DIFF
58479: PUSH
58480: FOR_IN
58481: IFFALSE 58533
// begin if sci = 6 then
58483: LD_VAR 0 8
58487: PUSH
58488: LD_INT 6
58490: EQUAL
58491: IFFALSE 58495
// break ;
58493: GO 58533
// if BuildingStatus ( x ) = bs_idle then
58495: LD_VAR 0 7
58499: PPUSH
58500: CALL_OW 461
58504: PUSH
58505: LD_INT 2
58507: EQUAL
58508: IFFALSE 58531
// sci := sci ^ UnitsInside ( x ) ;
58510: LD_ADDR_VAR 0 8
58514: PUSH
58515: LD_VAR 0 8
58519: PUSH
58520: LD_VAR 0 7
58524: PPUSH
58525: CALL_OW 313
58529: ADD
58530: ST_TO_ADDR
// end ;
58531: GO 58480
58533: POP
58534: POP
// if not sci then
58535: LD_VAR 0 8
58539: NOT
58540: IFFALSE 58544
// continue ;
58542: GO 57589
// for x in sci do
58544: LD_ADDR_VAR 0 7
58548: PUSH
58549: LD_VAR 0 8
58553: PUSH
58554: FOR_IN
58555: IFFALSE 58605
// if IsInUnit ( x ) and not HasTask ( x ) then
58557: LD_VAR 0 7
58561: PPUSH
58562: CALL_OW 310
58566: PUSH
58567: LD_VAR 0 7
58571: PPUSH
58572: CALL_OW 314
58576: NOT
58577: AND
58578: IFFALSE 58603
// begin ComExitBuilding ( x ) ;
58580: LD_VAR 0 7
58584: PPUSH
58585: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
58589: LD_VAR 0 7
58593: PPUSH
58594: LD_VAR 0 3
58598: PPUSH
58599: CALL_OW 180
// end ;
58603: GO 58554
58605: POP
58606: POP
// end ; end ;
58607: GO 57589
58609: POP
58610: POP
// end ;
58611: GO 57543
58613: POP
58614: POP
// end ;
58615: LD_VAR 0 1
58619: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
58620: LD_INT 0
58622: PPUSH
58623: PPUSH
// if not mc_bases then
58624: LD_EXP 14
58628: NOT
58629: IFFALSE 58633
// exit ;
58631: GO 58714
// for i = 1 to mc_bases do
58633: LD_ADDR_VAR 0 2
58637: PUSH
58638: DOUBLE
58639: LD_INT 1
58641: DEC
58642: ST_TO_ADDR
58643: LD_EXP 14
58647: PUSH
58648: FOR_TO
58649: IFFALSE 58712
// if mc_mines [ i ] and mc_miners [ i ] then
58651: LD_EXP 27
58655: PUSH
58656: LD_VAR 0 2
58660: ARRAY
58661: PUSH
58662: LD_EXP 28
58666: PUSH
58667: LD_VAR 0 2
58671: ARRAY
58672: AND
58673: IFFALSE 58710
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
58675: LD_EXP 28
58679: PUSH
58680: LD_VAR 0 2
58684: ARRAY
58685: PUSH
58686: LD_INT 1
58688: ARRAY
58689: PPUSH
58690: CALL_OW 255
58694: PPUSH
58695: LD_EXP 27
58699: PUSH
58700: LD_VAR 0 2
58704: ARRAY
58705: PPUSH
58706: CALL 6416 0 2
58710: GO 58648
58712: POP
58713: POP
// end ;
58714: LD_VAR 0 1
58718: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
58719: LD_INT 0
58721: PPUSH
58722: PPUSH
58723: PPUSH
58724: PPUSH
58725: PPUSH
58726: PPUSH
58727: PPUSH
58728: PPUSH
// if not mc_bases or not mc_parking then
58729: LD_EXP 14
58733: NOT
58734: PUSH
58735: LD_EXP 38
58739: NOT
58740: OR
58741: IFFALSE 58745
// exit ;
58743: GO 59444
// for i = 1 to mc_bases do
58745: LD_ADDR_VAR 0 2
58749: PUSH
58750: DOUBLE
58751: LD_INT 1
58753: DEC
58754: ST_TO_ADDR
58755: LD_EXP 14
58759: PUSH
58760: FOR_TO
58761: IFFALSE 59442
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
58763: LD_EXP 14
58767: PUSH
58768: LD_VAR 0 2
58772: ARRAY
58773: NOT
58774: PUSH
58775: LD_EXP 38
58779: PUSH
58780: LD_VAR 0 2
58784: ARRAY
58785: NOT
58786: OR
58787: IFFALSE 58791
// continue ;
58789: GO 58760
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
58791: LD_ADDR_VAR 0 5
58795: PUSH
58796: LD_EXP 14
58800: PUSH
58801: LD_VAR 0 2
58805: ARRAY
58806: PUSH
58807: LD_INT 1
58809: ARRAY
58810: PPUSH
58811: CALL_OW 255
58815: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
58816: LD_ADDR_VAR 0 6
58820: PUSH
58821: LD_EXP 14
58825: PUSH
58826: LD_VAR 0 2
58830: ARRAY
58831: PPUSH
58832: LD_INT 30
58834: PUSH
58835: LD_INT 3
58837: PUSH
58838: EMPTY
58839: LIST
58840: LIST
58841: PPUSH
58842: CALL_OW 72
58846: ST_TO_ADDR
// if not fac then
58847: LD_VAR 0 6
58851: NOT
58852: IFFALSE 58903
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58854: LD_ADDR_VAR 0 6
58858: PUSH
58859: LD_EXP 14
58863: PUSH
58864: LD_VAR 0 2
58868: ARRAY
58869: PPUSH
58870: LD_INT 2
58872: PUSH
58873: LD_INT 30
58875: PUSH
58876: LD_INT 0
58878: PUSH
58879: EMPTY
58880: LIST
58881: LIST
58882: PUSH
58883: LD_INT 30
58885: PUSH
58886: LD_INT 1
58888: PUSH
58889: EMPTY
58890: LIST
58891: LIST
58892: PUSH
58893: EMPTY
58894: LIST
58895: LIST
58896: LIST
58897: PPUSH
58898: CALL_OW 72
58902: ST_TO_ADDR
// if not fac then
58903: LD_VAR 0 6
58907: NOT
58908: IFFALSE 58912
// continue ;
58910: GO 58760
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
58912: LD_ADDR_VAR 0 7
58916: PUSH
58917: LD_EXP 38
58921: PUSH
58922: LD_VAR 0 2
58926: ARRAY
58927: PPUSH
58928: LD_INT 22
58930: PUSH
58931: LD_VAR 0 5
58935: PUSH
58936: EMPTY
58937: LIST
58938: LIST
58939: PUSH
58940: LD_INT 21
58942: PUSH
58943: LD_INT 2
58945: PUSH
58946: EMPTY
58947: LIST
58948: LIST
58949: PUSH
58950: LD_INT 3
58952: PUSH
58953: LD_INT 24
58955: PUSH
58956: LD_INT 1000
58958: PUSH
58959: EMPTY
58960: LIST
58961: LIST
58962: PUSH
58963: EMPTY
58964: LIST
58965: LIST
58966: PUSH
58967: EMPTY
58968: LIST
58969: LIST
58970: LIST
58971: PPUSH
58972: CALL_OW 70
58976: ST_TO_ADDR
// for j in fac do
58977: LD_ADDR_VAR 0 3
58981: PUSH
58982: LD_VAR 0 6
58986: PUSH
58987: FOR_IN
58988: IFFALSE 59069
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
58990: LD_ADDR_VAR 0 7
58994: PUSH
58995: LD_VAR 0 7
58999: PUSH
59000: LD_INT 22
59002: PUSH
59003: LD_VAR 0 5
59007: PUSH
59008: EMPTY
59009: LIST
59010: LIST
59011: PUSH
59012: LD_INT 91
59014: PUSH
59015: LD_VAR 0 3
59019: PUSH
59020: LD_INT 15
59022: PUSH
59023: EMPTY
59024: LIST
59025: LIST
59026: LIST
59027: PUSH
59028: LD_INT 21
59030: PUSH
59031: LD_INT 2
59033: PUSH
59034: EMPTY
59035: LIST
59036: LIST
59037: PUSH
59038: LD_INT 3
59040: PUSH
59041: LD_INT 24
59043: PUSH
59044: LD_INT 1000
59046: PUSH
59047: EMPTY
59048: LIST
59049: LIST
59050: PUSH
59051: EMPTY
59052: LIST
59053: LIST
59054: PUSH
59055: EMPTY
59056: LIST
59057: LIST
59058: LIST
59059: LIST
59060: PPUSH
59061: CALL_OW 69
59065: UNION
59066: ST_TO_ADDR
59067: GO 58987
59069: POP
59070: POP
// if not vehs then
59071: LD_VAR 0 7
59075: NOT
59076: IFFALSE 59102
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
59078: LD_ADDR_EXP 26
59082: PUSH
59083: LD_EXP 26
59087: PPUSH
59088: LD_VAR 0 2
59092: PPUSH
59093: EMPTY
59094: PPUSH
59095: CALL_OW 1
59099: ST_TO_ADDR
// continue ;
59100: GO 58760
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
59102: LD_ADDR_VAR 0 8
59106: PUSH
59107: LD_EXP 14
59111: PUSH
59112: LD_VAR 0 2
59116: ARRAY
59117: PPUSH
59118: LD_INT 30
59120: PUSH
59121: LD_INT 3
59123: PUSH
59124: EMPTY
59125: LIST
59126: LIST
59127: PPUSH
59128: CALL_OW 72
59132: ST_TO_ADDR
// if tmp then
59133: LD_VAR 0 8
59137: IFFALSE 59240
// begin for j in tmp do
59139: LD_ADDR_VAR 0 3
59143: PUSH
59144: LD_VAR 0 8
59148: PUSH
59149: FOR_IN
59150: IFFALSE 59238
// for k in UnitsInside ( j ) do
59152: LD_ADDR_VAR 0 4
59156: PUSH
59157: LD_VAR 0 3
59161: PPUSH
59162: CALL_OW 313
59166: PUSH
59167: FOR_IN
59168: IFFALSE 59234
// if k then
59170: LD_VAR 0 4
59174: IFFALSE 59232
// if not k in mc_repair_vehicle [ i ] then
59176: LD_VAR 0 4
59180: PUSH
59181: LD_EXP 26
59185: PUSH
59186: LD_VAR 0 2
59190: ARRAY
59191: IN
59192: NOT
59193: IFFALSE 59232
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
59195: LD_ADDR_EXP 26
59199: PUSH
59200: LD_EXP 26
59204: PPUSH
59205: LD_VAR 0 2
59209: PPUSH
59210: LD_EXP 26
59214: PUSH
59215: LD_VAR 0 2
59219: ARRAY
59220: PUSH
59221: LD_VAR 0 4
59225: UNION
59226: PPUSH
59227: CALL_OW 1
59231: ST_TO_ADDR
59232: GO 59167
59234: POP
59235: POP
59236: GO 59149
59238: POP
59239: POP
// end ; if not mc_repair_vehicle [ i ] then
59240: LD_EXP 26
59244: PUSH
59245: LD_VAR 0 2
59249: ARRAY
59250: NOT
59251: IFFALSE 59255
// continue ;
59253: GO 58760
// for j in mc_repair_vehicle [ i ] do
59255: LD_ADDR_VAR 0 3
59259: PUSH
59260: LD_EXP 26
59264: PUSH
59265: LD_VAR 0 2
59269: ARRAY
59270: PUSH
59271: FOR_IN
59272: IFFALSE 59438
// begin if GetClass ( j ) <> 3 then
59274: LD_VAR 0 3
59278: PPUSH
59279: CALL_OW 257
59283: PUSH
59284: LD_INT 3
59286: NONEQUAL
59287: IFFALSE 59328
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
59289: LD_ADDR_EXP 26
59293: PUSH
59294: LD_EXP 26
59298: PPUSH
59299: LD_VAR 0 2
59303: PPUSH
59304: LD_EXP 26
59308: PUSH
59309: LD_VAR 0 2
59313: ARRAY
59314: PUSH
59315: LD_VAR 0 3
59319: DIFF
59320: PPUSH
59321: CALL_OW 1
59325: ST_TO_ADDR
// continue ;
59326: GO 59271
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
59328: LD_VAR 0 3
59332: PPUSH
59333: CALL_OW 311
59337: NOT
59338: PUSH
59339: LD_VAR 0 3
59343: PUSH
59344: LD_EXP 17
59348: PUSH
59349: LD_VAR 0 2
59353: ARRAY
59354: PUSH
59355: LD_INT 1
59357: ARRAY
59358: IN
59359: NOT
59360: AND
59361: PUSH
59362: LD_VAR 0 3
59366: PUSH
59367: LD_EXP 17
59371: PUSH
59372: LD_VAR 0 2
59376: ARRAY
59377: PUSH
59378: LD_INT 2
59380: ARRAY
59381: IN
59382: NOT
59383: AND
59384: IFFALSE 59436
// begin if IsInUnit ( j ) then
59386: LD_VAR 0 3
59390: PPUSH
59391: CALL_OW 310
59395: IFFALSE 59406
// ComExitBuilding ( j ) ;
59397: LD_VAR 0 3
59401: PPUSH
59402: CALL_OW 122
// if not HasTask ( j ) then
59406: LD_VAR 0 3
59410: PPUSH
59411: CALL_OW 314
59415: NOT
59416: IFFALSE 59436
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
59418: LD_VAR 0 3
59422: PPUSH
59423: LD_VAR 0 7
59427: PUSH
59428: LD_INT 1
59430: ARRAY
59431: PPUSH
59432: CALL_OW 189
// end ; end ;
59436: GO 59271
59438: POP
59439: POP
// end ;
59440: GO 58760
59442: POP
59443: POP
// end ;
59444: LD_VAR 0 1
59448: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
59449: LD_INT 0
59451: PPUSH
59452: PPUSH
59453: PPUSH
59454: PPUSH
59455: PPUSH
59456: PPUSH
59457: PPUSH
59458: PPUSH
59459: PPUSH
59460: PPUSH
59461: PPUSH
// if not mc_bases then
59462: LD_EXP 14
59466: NOT
59467: IFFALSE 59471
// exit ;
59469: GO 60273
// for i = 1 to mc_bases do
59471: LD_ADDR_VAR 0 2
59475: PUSH
59476: DOUBLE
59477: LD_INT 1
59479: DEC
59480: ST_TO_ADDR
59481: LD_EXP 14
59485: PUSH
59486: FOR_TO
59487: IFFALSE 60271
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
59489: LD_EXP 42
59493: PUSH
59494: LD_VAR 0 2
59498: ARRAY
59499: NOT
59500: PUSH
59501: LD_EXP 17
59505: PUSH
59506: LD_VAR 0 2
59510: ARRAY
59511: PUSH
59512: LD_INT 1
59514: ARRAY
59515: OR
59516: PUSH
59517: LD_EXP 17
59521: PUSH
59522: LD_VAR 0 2
59526: ARRAY
59527: PUSH
59528: LD_INT 2
59530: ARRAY
59531: OR
59532: PUSH
59533: LD_EXP 40
59537: PUSH
59538: LD_VAR 0 2
59542: ARRAY
59543: PPUSH
59544: LD_INT 1
59546: PPUSH
59547: CALL_OW 325
59551: NOT
59552: OR
59553: PUSH
59554: LD_EXP 37
59558: PUSH
59559: LD_VAR 0 2
59563: ARRAY
59564: OR
59565: IFFALSE 59569
// continue ;
59567: GO 59486
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
59569: LD_ADDR_VAR 0 8
59573: PUSH
59574: LD_EXP 14
59578: PUSH
59579: LD_VAR 0 2
59583: ARRAY
59584: PPUSH
59585: LD_INT 25
59587: PUSH
59588: LD_INT 4
59590: PUSH
59591: EMPTY
59592: LIST
59593: LIST
59594: PUSH
59595: LD_INT 50
59597: PUSH
59598: EMPTY
59599: LIST
59600: PUSH
59601: LD_INT 3
59603: PUSH
59604: LD_INT 60
59606: PUSH
59607: EMPTY
59608: LIST
59609: PUSH
59610: EMPTY
59611: LIST
59612: LIST
59613: PUSH
59614: EMPTY
59615: LIST
59616: LIST
59617: LIST
59618: PPUSH
59619: CALL_OW 72
59623: PUSH
59624: LD_EXP 18
59628: PUSH
59629: LD_VAR 0 2
59633: ARRAY
59634: DIFF
59635: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
59636: LD_ADDR_VAR 0 9
59640: PUSH
59641: LD_EXP 14
59645: PUSH
59646: LD_VAR 0 2
59650: ARRAY
59651: PPUSH
59652: LD_INT 2
59654: PUSH
59655: LD_INT 30
59657: PUSH
59658: LD_INT 0
59660: PUSH
59661: EMPTY
59662: LIST
59663: LIST
59664: PUSH
59665: LD_INT 30
59667: PUSH
59668: LD_INT 1
59670: PUSH
59671: EMPTY
59672: LIST
59673: LIST
59674: PUSH
59675: EMPTY
59676: LIST
59677: LIST
59678: LIST
59679: PPUSH
59680: CALL_OW 72
59684: ST_TO_ADDR
// if not tmp or not dep then
59685: LD_VAR 0 8
59689: NOT
59690: PUSH
59691: LD_VAR 0 9
59695: NOT
59696: OR
59697: IFFALSE 59701
// continue ;
59699: GO 59486
// side := GetSide ( tmp [ 1 ] ) ;
59701: LD_ADDR_VAR 0 11
59705: PUSH
59706: LD_VAR 0 8
59710: PUSH
59711: LD_INT 1
59713: ARRAY
59714: PPUSH
59715: CALL_OW 255
59719: ST_TO_ADDR
// dep := dep [ 1 ] ;
59720: LD_ADDR_VAR 0 9
59724: PUSH
59725: LD_VAR 0 9
59729: PUSH
59730: LD_INT 1
59732: ARRAY
59733: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
59734: LD_ADDR_VAR 0 7
59738: PUSH
59739: LD_EXP 42
59743: PUSH
59744: LD_VAR 0 2
59748: ARRAY
59749: PPUSH
59750: LD_INT 22
59752: PUSH
59753: LD_INT 0
59755: PUSH
59756: EMPTY
59757: LIST
59758: LIST
59759: PUSH
59760: LD_INT 25
59762: PUSH
59763: LD_INT 12
59765: PUSH
59766: EMPTY
59767: LIST
59768: LIST
59769: PUSH
59770: EMPTY
59771: LIST
59772: LIST
59773: PPUSH
59774: CALL_OW 70
59778: PUSH
59779: LD_INT 22
59781: PUSH
59782: LD_INT 0
59784: PUSH
59785: EMPTY
59786: LIST
59787: LIST
59788: PUSH
59789: LD_INT 25
59791: PUSH
59792: LD_INT 12
59794: PUSH
59795: EMPTY
59796: LIST
59797: LIST
59798: PUSH
59799: LD_INT 91
59801: PUSH
59802: LD_VAR 0 9
59806: PUSH
59807: LD_INT 20
59809: PUSH
59810: EMPTY
59811: LIST
59812: LIST
59813: LIST
59814: PUSH
59815: EMPTY
59816: LIST
59817: LIST
59818: LIST
59819: PPUSH
59820: CALL_OW 69
59824: UNION
59825: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
59826: LD_ADDR_VAR 0 10
59830: PUSH
59831: LD_EXP 42
59835: PUSH
59836: LD_VAR 0 2
59840: ARRAY
59841: PPUSH
59842: LD_INT 81
59844: PUSH
59845: LD_VAR 0 11
59849: PUSH
59850: EMPTY
59851: LIST
59852: LIST
59853: PPUSH
59854: CALL_OW 70
59858: ST_TO_ADDR
// if not apes or danger_at_area then
59859: LD_VAR 0 7
59863: NOT
59864: PUSH
59865: LD_VAR 0 10
59869: OR
59870: IFFALSE 59920
// begin if mc_taming [ i ] then
59872: LD_EXP 45
59876: PUSH
59877: LD_VAR 0 2
59881: ARRAY
59882: IFFALSE 59918
// begin MC_Reset ( i , 121 ) ;
59884: LD_VAR 0 2
59888: PPUSH
59889: LD_INT 121
59891: PPUSH
59892: CALL 45371 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
59896: LD_ADDR_EXP 45
59900: PUSH
59901: LD_EXP 45
59905: PPUSH
59906: LD_VAR 0 2
59910: PPUSH
59911: EMPTY
59912: PPUSH
59913: CALL_OW 1
59917: ST_TO_ADDR
// end ; continue ;
59918: GO 59486
// end ; for j in tmp do
59920: LD_ADDR_VAR 0 3
59924: PUSH
59925: LD_VAR 0 8
59929: PUSH
59930: FOR_IN
59931: IFFALSE 60267
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
59933: LD_VAR 0 3
59937: PUSH
59938: LD_EXP 45
59942: PUSH
59943: LD_VAR 0 2
59947: ARRAY
59948: IN
59949: NOT
59950: PUSH
59951: LD_EXP 45
59955: PUSH
59956: LD_VAR 0 2
59960: ARRAY
59961: PUSH
59962: LD_INT 3
59964: LESS
59965: AND
59966: IFFALSE 60024
// begin SetTag ( j , 121 ) ;
59968: LD_VAR 0 3
59972: PPUSH
59973: LD_INT 121
59975: PPUSH
59976: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
59980: LD_ADDR_EXP 45
59984: PUSH
59985: LD_EXP 45
59989: PPUSH
59990: LD_VAR 0 2
59994: PUSH
59995: LD_EXP 45
59999: PUSH
60000: LD_VAR 0 2
60004: ARRAY
60005: PUSH
60006: LD_INT 1
60008: PLUS
60009: PUSH
60010: EMPTY
60011: LIST
60012: LIST
60013: PPUSH
60014: LD_VAR 0 3
60018: PPUSH
60019: CALL 9427 0 3
60023: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
60024: LD_VAR 0 3
60028: PUSH
60029: LD_EXP 45
60033: PUSH
60034: LD_VAR 0 2
60038: ARRAY
60039: IN
60040: IFFALSE 60265
// begin if GetClass ( j ) <> 4 then
60042: LD_VAR 0 3
60046: PPUSH
60047: CALL_OW 257
60051: PUSH
60052: LD_INT 4
60054: NONEQUAL
60055: IFFALSE 60108
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
60057: LD_ADDR_EXP 45
60061: PUSH
60062: LD_EXP 45
60066: PPUSH
60067: LD_VAR 0 2
60071: PPUSH
60072: LD_EXP 45
60076: PUSH
60077: LD_VAR 0 2
60081: ARRAY
60082: PUSH
60083: LD_VAR 0 3
60087: DIFF
60088: PPUSH
60089: CALL_OW 1
60093: ST_TO_ADDR
// SetTag ( j , 0 ) ;
60094: LD_VAR 0 3
60098: PPUSH
60099: LD_INT 0
60101: PPUSH
60102: CALL_OW 109
// continue ;
60106: GO 59930
// end ; if IsInUnit ( j ) then
60108: LD_VAR 0 3
60112: PPUSH
60113: CALL_OW 310
60117: IFFALSE 60128
// ComExitBuilding ( j ) ;
60119: LD_VAR 0 3
60123: PPUSH
60124: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
60128: LD_ADDR_VAR 0 6
60132: PUSH
60133: LD_VAR 0 7
60137: PPUSH
60138: LD_VAR 0 3
60142: PPUSH
60143: CALL_OW 74
60147: ST_TO_ADDR
// if not ape then
60148: LD_VAR 0 6
60152: NOT
60153: IFFALSE 60157
// break ;
60155: GO 60267
// x := GetX ( ape ) ;
60157: LD_ADDR_VAR 0 4
60161: PUSH
60162: LD_VAR 0 6
60166: PPUSH
60167: CALL_OW 250
60171: ST_TO_ADDR
// y := GetY ( ape ) ;
60172: LD_ADDR_VAR 0 5
60176: PUSH
60177: LD_VAR 0 6
60181: PPUSH
60182: CALL_OW 251
60186: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
60187: LD_VAR 0 4
60191: PPUSH
60192: LD_VAR 0 5
60196: PPUSH
60197: CALL_OW 488
60201: NOT
60202: PUSH
60203: LD_VAR 0 11
60207: PPUSH
60208: LD_VAR 0 4
60212: PPUSH
60213: LD_VAR 0 5
60217: PPUSH
60218: LD_INT 20
60220: PPUSH
60221: CALL 10323 0 4
60225: PUSH
60226: LD_INT 4
60228: ARRAY
60229: OR
60230: IFFALSE 60234
// break ;
60232: GO 60267
// if not HasTask ( j ) then
60234: LD_VAR 0 3
60238: PPUSH
60239: CALL_OW 314
60243: NOT
60244: IFFALSE 60265
// ComTameXY ( j , x , y ) ;
60246: LD_VAR 0 3
60250: PPUSH
60251: LD_VAR 0 4
60255: PPUSH
60256: LD_VAR 0 5
60260: PPUSH
60261: CALL_OW 131
// end ; end ;
60265: GO 59930
60267: POP
60268: POP
// end ;
60269: GO 59486
60271: POP
60272: POP
// end ;
60273: LD_VAR 0 1
60277: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
60278: LD_INT 0
60280: PPUSH
60281: PPUSH
60282: PPUSH
60283: PPUSH
60284: PPUSH
60285: PPUSH
60286: PPUSH
60287: PPUSH
// if not mc_bases then
60288: LD_EXP 14
60292: NOT
60293: IFFALSE 60297
// exit ;
60295: GO 60923
// for i = 1 to mc_bases do
60297: LD_ADDR_VAR 0 2
60301: PUSH
60302: DOUBLE
60303: LD_INT 1
60305: DEC
60306: ST_TO_ADDR
60307: LD_EXP 14
60311: PUSH
60312: FOR_TO
60313: IFFALSE 60921
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
60315: LD_EXP 43
60319: PUSH
60320: LD_VAR 0 2
60324: ARRAY
60325: NOT
60326: PUSH
60327: LD_EXP 43
60331: PUSH
60332: LD_VAR 0 2
60336: ARRAY
60337: PPUSH
60338: LD_INT 25
60340: PUSH
60341: LD_INT 12
60343: PUSH
60344: EMPTY
60345: LIST
60346: LIST
60347: PPUSH
60348: CALL_OW 72
60352: NOT
60353: OR
60354: IFFALSE 60358
// continue ;
60356: GO 60312
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
60358: LD_ADDR_VAR 0 5
60362: PUSH
60363: LD_EXP 43
60367: PUSH
60368: LD_VAR 0 2
60372: ARRAY
60373: PUSH
60374: LD_INT 1
60376: ARRAY
60377: PPUSH
60378: CALL_OW 255
60382: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
60383: LD_VAR 0 5
60387: PPUSH
60388: LD_INT 2
60390: PPUSH
60391: CALL_OW 325
60395: IFFALSE 60648
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
60397: LD_ADDR_VAR 0 4
60401: PUSH
60402: LD_EXP 43
60406: PUSH
60407: LD_VAR 0 2
60411: ARRAY
60412: PPUSH
60413: LD_INT 25
60415: PUSH
60416: LD_INT 16
60418: PUSH
60419: EMPTY
60420: LIST
60421: LIST
60422: PPUSH
60423: CALL_OW 72
60427: ST_TO_ADDR
// if tmp < 6 then
60428: LD_VAR 0 4
60432: PUSH
60433: LD_INT 6
60435: LESS
60436: IFFALSE 60648
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60438: LD_ADDR_VAR 0 6
60442: PUSH
60443: LD_EXP 14
60447: PUSH
60448: LD_VAR 0 2
60452: ARRAY
60453: PPUSH
60454: LD_INT 2
60456: PUSH
60457: LD_INT 30
60459: PUSH
60460: LD_INT 0
60462: PUSH
60463: EMPTY
60464: LIST
60465: LIST
60466: PUSH
60467: LD_INT 30
60469: PUSH
60470: LD_INT 1
60472: PUSH
60473: EMPTY
60474: LIST
60475: LIST
60476: PUSH
60477: EMPTY
60478: LIST
60479: LIST
60480: LIST
60481: PPUSH
60482: CALL_OW 72
60486: ST_TO_ADDR
// if depot then
60487: LD_VAR 0 6
60491: IFFALSE 60648
// begin selected := 0 ;
60493: LD_ADDR_VAR 0 7
60497: PUSH
60498: LD_INT 0
60500: ST_TO_ADDR
// for j in depot do
60501: LD_ADDR_VAR 0 3
60505: PUSH
60506: LD_VAR 0 6
60510: PUSH
60511: FOR_IN
60512: IFFALSE 60543
// begin if UnitsInside ( j ) < 6 then
60514: LD_VAR 0 3
60518: PPUSH
60519: CALL_OW 313
60523: PUSH
60524: LD_INT 6
60526: LESS
60527: IFFALSE 60541
// begin selected := j ;
60529: LD_ADDR_VAR 0 7
60533: PUSH
60534: LD_VAR 0 3
60538: ST_TO_ADDR
// break ;
60539: GO 60543
// end ; end ;
60541: GO 60511
60543: POP
60544: POP
// if selected then
60545: LD_VAR 0 7
60549: IFFALSE 60648
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
60551: LD_ADDR_VAR 0 3
60555: PUSH
60556: LD_EXP 43
60560: PUSH
60561: LD_VAR 0 2
60565: ARRAY
60566: PPUSH
60567: LD_INT 25
60569: PUSH
60570: LD_INT 12
60572: PUSH
60573: EMPTY
60574: LIST
60575: LIST
60576: PPUSH
60577: CALL_OW 72
60581: PUSH
60582: FOR_IN
60583: IFFALSE 60646
// if not HasTask ( j ) then
60585: LD_VAR 0 3
60589: PPUSH
60590: CALL_OW 314
60594: NOT
60595: IFFALSE 60644
// begin if not IsInUnit ( j ) then
60597: LD_VAR 0 3
60601: PPUSH
60602: CALL_OW 310
60606: NOT
60607: IFFALSE 60623
// ComEnterUnit ( j , selected ) ;
60609: LD_VAR 0 3
60613: PPUSH
60614: LD_VAR 0 7
60618: PPUSH
60619: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
60623: LD_VAR 0 3
60627: PPUSH
60628: LD_INT 16
60630: PPUSH
60631: CALL_OW 183
// AddComExitBuilding ( j ) ;
60635: LD_VAR 0 3
60639: PPUSH
60640: CALL_OW 182
// end ;
60644: GO 60582
60646: POP
60647: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
60648: LD_VAR 0 5
60652: PPUSH
60653: LD_INT 11
60655: PPUSH
60656: CALL_OW 325
60660: IFFALSE 60919
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
60662: LD_ADDR_VAR 0 4
60666: PUSH
60667: LD_EXP 43
60671: PUSH
60672: LD_VAR 0 2
60676: ARRAY
60677: PPUSH
60678: LD_INT 25
60680: PUSH
60681: LD_INT 16
60683: PUSH
60684: EMPTY
60685: LIST
60686: LIST
60687: PPUSH
60688: CALL_OW 72
60692: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
60693: LD_VAR 0 4
60697: PUSH
60698: LD_INT 6
60700: GREATEREQUAL
60701: PUSH
60702: LD_VAR 0 5
60706: PPUSH
60707: LD_INT 2
60709: PPUSH
60710: CALL_OW 325
60714: NOT
60715: OR
60716: IFFALSE 60919
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
60718: LD_ADDR_VAR 0 8
60722: PUSH
60723: LD_EXP 14
60727: PUSH
60728: LD_VAR 0 2
60732: ARRAY
60733: PPUSH
60734: LD_INT 2
60736: PUSH
60737: LD_INT 30
60739: PUSH
60740: LD_INT 4
60742: PUSH
60743: EMPTY
60744: LIST
60745: LIST
60746: PUSH
60747: LD_INT 30
60749: PUSH
60750: LD_INT 5
60752: PUSH
60753: EMPTY
60754: LIST
60755: LIST
60756: PUSH
60757: EMPTY
60758: LIST
60759: LIST
60760: LIST
60761: PPUSH
60762: CALL_OW 72
60766: ST_TO_ADDR
// if barracks then
60767: LD_VAR 0 8
60771: IFFALSE 60919
// begin selected := 0 ;
60773: LD_ADDR_VAR 0 7
60777: PUSH
60778: LD_INT 0
60780: ST_TO_ADDR
// for j in barracks do
60781: LD_ADDR_VAR 0 3
60785: PUSH
60786: LD_VAR 0 8
60790: PUSH
60791: FOR_IN
60792: IFFALSE 60823
// begin if UnitsInside ( j ) < 6 then
60794: LD_VAR 0 3
60798: PPUSH
60799: CALL_OW 313
60803: PUSH
60804: LD_INT 6
60806: LESS
60807: IFFALSE 60821
// begin selected := j ;
60809: LD_ADDR_VAR 0 7
60813: PUSH
60814: LD_VAR 0 3
60818: ST_TO_ADDR
// break ;
60819: GO 60823
// end ; end ;
60821: GO 60791
60823: POP
60824: POP
// if selected then
60825: LD_VAR 0 7
60829: IFFALSE 60919
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
60831: LD_ADDR_VAR 0 3
60835: PUSH
60836: LD_EXP 43
60840: PUSH
60841: LD_VAR 0 2
60845: ARRAY
60846: PPUSH
60847: LD_INT 25
60849: PUSH
60850: LD_INT 12
60852: PUSH
60853: EMPTY
60854: LIST
60855: LIST
60856: PPUSH
60857: CALL_OW 72
60861: PUSH
60862: FOR_IN
60863: IFFALSE 60917
// if not IsInUnit ( j ) and not HasTask ( j ) then
60865: LD_VAR 0 3
60869: PPUSH
60870: CALL_OW 310
60874: NOT
60875: PUSH
60876: LD_VAR 0 3
60880: PPUSH
60881: CALL_OW 314
60885: NOT
60886: AND
60887: IFFALSE 60915
// begin ComEnterUnit ( j , selected ) ;
60889: LD_VAR 0 3
60893: PPUSH
60894: LD_VAR 0 7
60898: PPUSH
60899: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
60903: LD_VAR 0 3
60907: PPUSH
60908: LD_INT 15
60910: PPUSH
60911: CALL_OW 183
// end ;
60915: GO 60862
60917: POP
60918: POP
// end ; end ; end ; end ; end ;
60919: GO 60312
60921: POP
60922: POP
// end ;
60923: LD_VAR 0 1
60927: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
60928: LD_INT 0
60930: PPUSH
60931: PPUSH
60932: PPUSH
60933: PPUSH
// if not mc_bases then
60934: LD_EXP 14
60938: NOT
60939: IFFALSE 60943
// exit ;
60941: GO 61121
// for i = 1 to mc_bases do
60943: LD_ADDR_VAR 0 2
60947: PUSH
60948: DOUBLE
60949: LD_INT 1
60951: DEC
60952: ST_TO_ADDR
60953: LD_EXP 14
60957: PUSH
60958: FOR_TO
60959: IFFALSE 61119
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
60961: LD_ADDR_VAR 0 4
60965: PUSH
60966: LD_EXP 14
60970: PUSH
60971: LD_VAR 0 2
60975: ARRAY
60976: PPUSH
60977: LD_INT 25
60979: PUSH
60980: LD_INT 9
60982: PUSH
60983: EMPTY
60984: LIST
60985: LIST
60986: PPUSH
60987: CALL_OW 72
60991: ST_TO_ADDR
// if not tmp then
60992: LD_VAR 0 4
60996: NOT
60997: IFFALSE 61001
// continue ;
60999: GO 60958
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
61001: LD_EXP 40
61005: PUSH
61006: LD_VAR 0 2
61010: ARRAY
61011: PPUSH
61012: LD_INT 29
61014: PPUSH
61015: CALL_OW 325
61019: NOT
61020: PUSH
61021: LD_EXP 40
61025: PUSH
61026: LD_VAR 0 2
61030: ARRAY
61031: PPUSH
61032: LD_INT 28
61034: PPUSH
61035: CALL_OW 325
61039: NOT
61040: AND
61041: IFFALSE 61045
// continue ;
61043: GO 60958
// for j in tmp do
61045: LD_ADDR_VAR 0 3
61049: PUSH
61050: LD_VAR 0 4
61054: PUSH
61055: FOR_IN
61056: IFFALSE 61115
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
61058: LD_VAR 0 3
61062: PUSH
61063: LD_EXP 17
61067: PUSH
61068: LD_VAR 0 2
61072: ARRAY
61073: PUSH
61074: LD_INT 1
61076: ARRAY
61077: IN
61078: NOT
61079: PUSH
61080: LD_VAR 0 3
61084: PUSH
61085: LD_EXP 17
61089: PUSH
61090: LD_VAR 0 2
61094: ARRAY
61095: PUSH
61096: LD_INT 2
61098: ARRAY
61099: IN
61100: NOT
61101: AND
61102: IFFALSE 61113
// ComSpaceTimeShoot ( j ) ;
61104: LD_VAR 0 3
61108: PPUSH
61109: CALL 5424 0 1
61113: GO 61055
61115: POP
61116: POP
// end ;
61117: GO 60958
61119: POP
61120: POP
// end ;
61121: LD_VAR 0 1
61125: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
61126: LD_INT 0
61128: PPUSH
61129: PPUSH
61130: PPUSH
61131: PPUSH
61132: PPUSH
61133: PPUSH
61134: PPUSH
61135: PPUSH
61136: PPUSH
// if not mc_bases then
61137: LD_EXP 14
61141: NOT
61142: IFFALSE 61146
// exit ;
61144: GO 61768
// for i = 1 to mc_bases do
61146: LD_ADDR_VAR 0 2
61150: PUSH
61151: DOUBLE
61152: LD_INT 1
61154: DEC
61155: ST_TO_ADDR
61156: LD_EXP 14
61160: PUSH
61161: FOR_TO
61162: IFFALSE 61766
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
61164: LD_EXP 49
61168: PUSH
61169: LD_VAR 0 2
61173: ARRAY
61174: NOT
61175: PUSH
61176: LD_INT 38
61178: PPUSH
61179: LD_EXP 40
61183: PUSH
61184: LD_VAR 0 2
61188: ARRAY
61189: PPUSH
61190: CALL_OW 321
61194: PUSH
61195: LD_INT 2
61197: NONEQUAL
61198: OR
61199: IFFALSE 61203
// continue ;
61201: GO 61161
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
61203: LD_ADDR_VAR 0 8
61207: PUSH
61208: LD_EXP 14
61212: PUSH
61213: LD_VAR 0 2
61217: ARRAY
61218: PPUSH
61219: LD_INT 30
61221: PUSH
61222: LD_INT 34
61224: PUSH
61225: EMPTY
61226: LIST
61227: LIST
61228: PPUSH
61229: CALL_OW 72
61233: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
61234: LD_ADDR_VAR 0 9
61238: PUSH
61239: LD_EXP 14
61243: PUSH
61244: LD_VAR 0 2
61248: ARRAY
61249: PPUSH
61250: LD_INT 25
61252: PUSH
61253: LD_INT 4
61255: PUSH
61256: EMPTY
61257: LIST
61258: LIST
61259: PPUSH
61260: CALL_OW 72
61264: PPUSH
61265: LD_INT 0
61267: PPUSH
61268: CALL 37988 0 2
61272: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
61273: LD_VAR 0 9
61277: NOT
61278: PUSH
61279: LD_VAR 0 8
61283: NOT
61284: OR
61285: PUSH
61286: LD_EXP 14
61290: PUSH
61291: LD_VAR 0 2
61295: ARRAY
61296: PPUSH
61297: LD_INT 124
61299: PPUSH
61300: CALL 37988 0 2
61304: OR
61305: IFFALSE 61309
// continue ;
61307: GO 61161
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
61309: LD_EXP 50
61313: PUSH
61314: LD_VAR 0 2
61318: ARRAY
61319: PUSH
61320: LD_EXP 49
61324: PUSH
61325: LD_VAR 0 2
61329: ARRAY
61330: LESS
61331: PUSH
61332: LD_EXP 50
61336: PUSH
61337: LD_VAR 0 2
61341: ARRAY
61342: PUSH
61343: LD_VAR 0 8
61347: LESS
61348: AND
61349: IFFALSE 61764
// begin tmp := sci [ 1 ] ;
61351: LD_ADDR_VAR 0 7
61355: PUSH
61356: LD_VAR 0 9
61360: PUSH
61361: LD_INT 1
61363: ARRAY
61364: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
61365: LD_VAR 0 7
61369: PPUSH
61370: LD_INT 124
61372: PPUSH
61373: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
61377: LD_ADDR_VAR 0 3
61381: PUSH
61382: DOUBLE
61383: LD_EXP 49
61387: PUSH
61388: LD_VAR 0 2
61392: ARRAY
61393: INC
61394: ST_TO_ADDR
61395: LD_EXP 49
61399: PUSH
61400: LD_VAR 0 2
61404: ARRAY
61405: PUSH
61406: FOR_DOWNTO
61407: IFFALSE 61750
// begin if IsInUnit ( tmp ) then
61409: LD_VAR 0 7
61413: PPUSH
61414: CALL_OW 310
61418: IFFALSE 61429
// ComExitBuilding ( tmp ) ;
61420: LD_VAR 0 7
61424: PPUSH
61425: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
61429: LD_INT 35
61431: PPUSH
61432: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
61436: LD_VAR 0 7
61440: PPUSH
61441: CALL_OW 310
61445: NOT
61446: PUSH
61447: LD_VAR 0 7
61451: PPUSH
61452: CALL_OW 314
61456: NOT
61457: AND
61458: IFFALSE 61429
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
61460: LD_ADDR_VAR 0 6
61464: PUSH
61465: LD_VAR 0 7
61469: PPUSH
61470: CALL_OW 250
61474: PUSH
61475: LD_VAR 0 7
61479: PPUSH
61480: CALL_OW 251
61484: PUSH
61485: EMPTY
61486: LIST
61487: LIST
61488: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
61489: LD_INT 35
61491: PPUSH
61492: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
61496: LD_ADDR_VAR 0 4
61500: PUSH
61501: LD_EXP 49
61505: PUSH
61506: LD_VAR 0 2
61510: ARRAY
61511: PUSH
61512: LD_VAR 0 3
61516: ARRAY
61517: PUSH
61518: LD_INT 1
61520: ARRAY
61521: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
61522: LD_ADDR_VAR 0 5
61526: PUSH
61527: LD_EXP 49
61531: PUSH
61532: LD_VAR 0 2
61536: ARRAY
61537: PUSH
61538: LD_VAR 0 3
61542: ARRAY
61543: PUSH
61544: LD_INT 2
61546: ARRAY
61547: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
61548: LD_VAR 0 7
61552: PPUSH
61553: LD_INT 10
61555: PPUSH
61556: CALL 12020 0 2
61560: PUSH
61561: LD_INT 4
61563: ARRAY
61564: IFFALSE 61602
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
61566: LD_VAR 0 7
61570: PPUSH
61571: LD_VAR 0 6
61575: PUSH
61576: LD_INT 1
61578: ARRAY
61579: PPUSH
61580: LD_VAR 0 6
61584: PUSH
61585: LD_INT 2
61587: ARRAY
61588: PPUSH
61589: CALL_OW 111
// wait ( 0 0$10 ) ;
61593: LD_INT 350
61595: PPUSH
61596: CALL_OW 67
// end else
61600: GO 61628
// begin ComMoveXY ( tmp , x , y ) ;
61602: LD_VAR 0 7
61606: PPUSH
61607: LD_VAR 0 4
61611: PPUSH
61612: LD_VAR 0 5
61616: PPUSH
61617: CALL_OW 111
// wait ( 0 0$3 ) ;
61621: LD_INT 105
61623: PPUSH
61624: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
61628: LD_VAR 0 7
61632: PPUSH
61633: LD_VAR 0 4
61637: PPUSH
61638: LD_VAR 0 5
61642: PPUSH
61643: CALL_OW 307
61647: IFFALSE 61489
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
61649: LD_VAR 0 7
61653: PPUSH
61654: LD_VAR 0 4
61658: PPUSH
61659: LD_VAR 0 5
61663: PPUSH
61664: LD_VAR 0 8
61668: PUSH
61669: LD_VAR 0 3
61673: ARRAY
61674: PPUSH
61675: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
61679: LD_INT 35
61681: PPUSH
61682: CALL_OW 67
// until not HasTask ( tmp ) ;
61686: LD_VAR 0 7
61690: PPUSH
61691: CALL_OW 314
61695: NOT
61696: IFFALSE 61679
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
61698: LD_ADDR_EXP 50
61702: PUSH
61703: LD_EXP 50
61707: PPUSH
61708: LD_VAR 0 2
61712: PUSH
61713: LD_EXP 50
61717: PUSH
61718: LD_VAR 0 2
61722: ARRAY
61723: PUSH
61724: LD_INT 1
61726: PLUS
61727: PUSH
61728: EMPTY
61729: LIST
61730: LIST
61731: PPUSH
61732: LD_VAR 0 8
61736: PUSH
61737: LD_VAR 0 3
61741: ARRAY
61742: PPUSH
61743: CALL 9427 0 3
61747: ST_TO_ADDR
// end ;
61748: GO 61406
61750: POP
61751: POP
// MC_Reset ( i , 124 ) ;
61752: LD_VAR 0 2
61756: PPUSH
61757: LD_INT 124
61759: PPUSH
61760: CALL 45371 0 2
// end ; end ;
61764: GO 61161
61766: POP
61767: POP
// end ;
61768: LD_VAR 0 1
61772: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
61773: LD_INT 0
61775: PPUSH
61776: PPUSH
61777: PPUSH
// if not mc_bases then
61778: LD_EXP 14
61782: NOT
61783: IFFALSE 61787
// exit ;
61785: GO 62393
// for i = 1 to mc_bases do
61787: LD_ADDR_VAR 0 2
61791: PUSH
61792: DOUBLE
61793: LD_INT 1
61795: DEC
61796: ST_TO_ADDR
61797: LD_EXP 14
61801: PUSH
61802: FOR_TO
61803: IFFALSE 62391
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
61805: LD_ADDR_VAR 0 3
61809: PUSH
61810: LD_EXP 14
61814: PUSH
61815: LD_VAR 0 2
61819: ARRAY
61820: PPUSH
61821: LD_INT 25
61823: PUSH
61824: LD_INT 4
61826: PUSH
61827: EMPTY
61828: LIST
61829: LIST
61830: PPUSH
61831: CALL_OW 72
61835: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
61836: LD_VAR 0 3
61840: NOT
61841: PUSH
61842: LD_EXP 51
61846: PUSH
61847: LD_VAR 0 2
61851: ARRAY
61852: NOT
61853: OR
61854: PUSH
61855: LD_EXP 14
61859: PUSH
61860: LD_VAR 0 2
61864: ARRAY
61865: PPUSH
61866: LD_INT 2
61868: PUSH
61869: LD_INT 30
61871: PUSH
61872: LD_INT 0
61874: PUSH
61875: EMPTY
61876: LIST
61877: LIST
61878: PUSH
61879: LD_INT 30
61881: PUSH
61882: LD_INT 1
61884: PUSH
61885: EMPTY
61886: LIST
61887: LIST
61888: PUSH
61889: EMPTY
61890: LIST
61891: LIST
61892: LIST
61893: PPUSH
61894: CALL_OW 72
61898: NOT
61899: OR
61900: IFFALSE 61950
// begin if mc_deposits_finder [ i ] then
61902: LD_EXP 52
61906: PUSH
61907: LD_VAR 0 2
61911: ARRAY
61912: IFFALSE 61948
// begin MC_Reset ( i , 125 ) ;
61914: LD_VAR 0 2
61918: PPUSH
61919: LD_INT 125
61921: PPUSH
61922: CALL 45371 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
61926: LD_ADDR_EXP 52
61930: PUSH
61931: LD_EXP 52
61935: PPUSH
61936: LD_VAR 0 2
61940: PPUSH
61941: EMPTY
61942: PPUSH
61943: CALL_OW 1
61947: ST_TO_ADDR
// end ; continue ;
61948: GO 61802
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
61950: LD_EXP 51
61954: PUSH
61955: LD_VAR 0 2
61959: ARRAY
61960: PUSH
61961: LD_INT 1
61963: ARRAY
61964: PUSH
61965: LD_INT 3
61967: ARRAY
61968: PUSH
61969: LD_INT 1
61971: EQUAL
61972: PUSH
61973: LD_INT 20
61975: PPUSH
61976: LD_EXP 40
61980: PUSH
61981: LD_VAR 0 2
61985: ARRAY
61986: PPUSH
61987: CALL_OW 321
61991: PUSH
61992: LD_INT 2
61994: NONEQUAL
61995: AND
61996: IFFALSE 62046
// begin if mc_deposits_finder [ i ] then
61998: LD_EXP 52
62002: PUSH
62003: LD_VAR 0 2
62007: ARRAY
62008: IFFALSE 62044
// begin MC_Reset ( i , 125 ) ;
62010: LD_VAR 0 2
62014: PPUSH
62015: LD_INT 125
62017: PPUSH
62018: CALL 45371 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
62022: LD_ADDR_EXP 52
62026: PUSH
62027: LD_EXP 52
62031: PPUSH
62032: LD_VAR 0 2
62036: PPUSH
62037: EMPTY
62038: PPUSH
62039: CALL_OW 1
62043: ST_TO_ADDR
// end ; continue ;
62044: GO 61802
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
62046: LD_EXP 51
62050: PUSH
62051: LD_VAR 0 2
62055: ARRAY
62056: PUSH
62057: LD_INT 1
62059: ARRAY
62060: PUSH
62061: LD_INT 1
62063: ARRAY
62064: PPUSH
62065: LD_EXP 51
62069: PUSH
62070: LD_VAR 0 2
62074: ARRAY
62075: PUSH
62076: LD_INT 1
62078: ARRAY
62079: PUSH
62080: LD_INT 2
62082: ARRAY
62083: PPUSH
62084: LD_EXP 40
62088: PUSH
62089: LD_VAR 0 2
62093: ARRAY
62094: PPUSH
62095: CALL_OW 440
62099: IFFALSE 62142
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
62101: LD_ADDR_EXP 51
62105: PUSH
62106: LD_EXP 51
62110: PPUSH
62111: LD_VAR 0 2
62115: PPUSH
62116: LD_EXP 51
62120: PUSH
62121: LD_VAR 0 2
62125: ARRAY
62126: PPUSH
62127: LD_INT 1
62129: PPUSH
62130: CALL_OW 3
62134: PPUSH
62135: CALL_OW 1
62139: ST_TO_ADDR
62140: GO 62389
// begin if not mc_deposits_finder [ i ] then
62142: LD_EXP 52
62146: PUSH
62147: LD_VAR 0 2
62151: ARRAY
62152: NOT
62153: IFFALSE 62205
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
62155: LD_ADDR_EXP 52
62159: PUSH
62160: LD_EXP 52
62164: PPUSH
62165: LD_VAR 0 2
62169: PPUSH
62170: LD_VAR 0 3
62174: PUSH
62175: LD_INT 1
62177: ARRAY
62178: PUSH
62179: EMPTY
62180: LIST
62181: PPUSH
62182: CALL_OW 1
62186: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
62187: LD_VAR 0 3
62191: PUSH
62192: LD_INT 1
62194: ARRAY
62195: PPUSH
62196: LD_INT 125
62198: PPUSH
62199: CALL_OW 109
// end else
62203: GO 62389
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
62205: LD_EXP 52
62209: PUSH
62210: LD_VAR 0 2
62214: ARRAY
62215: PUSH
62216: LD_INT 1
62218: ARRAY
62219: PPUSH
62220: CALL_OW 310
62224: IFFALSE 62247
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
62226: LD_EXP 52
62230: PUSH
62231: LD_VAR 0 2
62235: ARRAY
62236: PUSH
62237: LD_INT 1
62239: ARRAY
62240: PPUSH
62241: CALL_OW 122
62245: GO 62389
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
62247: LD_EXP 52
62251: PUSH
62252: LD_VAR 0 2
62256: ARRAY
62257: PUSH
62258: LD_INT 1
62260: ARRAY
62261: PPUSH
62262: CALL_OW 314
62266: NOT
62267: PUSH
62268: LD_EXP 52
62272: PUSH
62273: LD_VAR 0 2
62277: ARRAY
62278: PUSH
62279: LD_INT 1
62281: ARRAY
62282: PPUSH
62283: LD_EXP 51
62287: PUSH
62288: LD_VAR 0 2
62292: ARRAY
62293: PUSH
62294: LD_INT 1
62296: ARRAY
62297: PUSH
62298: LD_INT 1
62300: ARRAY
62301: PPUSH
62302: LD_EXP 51
62306: PUSH
62307: LD_VAR 0 2
62311: ARRAY
62312: PUSH
62313: LD_INT 1
62315: ARRAY
62316: PUSH
62317: LD_INT 2
62319: ARRAY
62320: PPUSH
62321: CALL_OW 297
62325: PUSH
62326: LD_INT 6
62328: GREATER
62329: AND
62330: IFFALSE 62389
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
62332: LD_EXP 52
62336: PUSH
62337: LD_VAR 0 2
62341: ARRAY
62342: PUSH
62343: LD_INT 1
62345: ARRAY
62346: PPUSH
62347: LD_EXP 51
62351: PUSH
62352: LD_VAR 0 2
62356: ARRAY
62357: PUSH
62358: LD_INT 1
62360: ARRAY
62361: PUSH
62362: LD_INT 1
62364: ARRAY
62365: PPUSH
62366: LD_EXP 51
62370: PUSH
62371: LD_VAR 0 2
62375: ARRAY
62376: PUSH
62377: LD_INT 1
62379: ARRAY
62380: PUSH
62381: LD_INT 2
62383: ARRAY
62384: PPUSH
62385: CALL_OW 111
// end ; end ; end ;
62389: GO 61802
62391: POP
62392: POP
// end ;
62393: LD_VAR 0 1
62397: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
62398: LD_INT 0
62400: PPUSH
62401: PPUSH
62402: PPUSH
62403: PPUSH
62404: PPUSH
62405: PPUSH
62406: PPUSH
62407: PPUSH
62408: PPUSH
62409: PPUSH
62410: PPUSH
// if not mc_bases then
62411: LD_EXP 14
62415: NOT
62416: IFFALSE 62420
// exit ;
62418: GO 63360
// for i = 1 to mc_bases do
62420: LD_ADDR_VAR 0 2
62424: PUSH
62425: DOUBLE
62426: LD_INT 1
62428: DEC
62429: ST_TO_ADDR
62430: LD_EXP 14
62434: PUSH
62435: FOR_TO
62436: IFFALSE 63358
// begin if not mc_bases [ i ] or mc_scan [ i ] then
62438: LD_EXP 14
62442: PUSH
62443: LD_VAR 0 2
62447: ARRAY
62448: NOT
62449: PUSH
62450: LD_EXP 37
62454: PUSH
62455: LD_VAR 0 2
62459: ARRAY
62460: OR
62461: IFFALSE 62465
// continue ;
62463: GO 62435
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
62465: LD_ADDR_VAR 0 7
62469: PUSH
62470: LD_EXP 14
62474: PUSH
62475: LD_VAR 0 2
62479: ARRAY
62480: PUSH
62481: LD_INT 1
62483: ARRAY
62484: PPUSH
62485: CALL_OW 248
62489: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
62490: LD_VAR 0 7
62494: PUSH
62495: LD_INT 3
62497: EQUAL
62498: PUSH
62499: LD_EXP 33
62503: PUSH
62504: LD_VAR 0 2
62508: ARRAY
62509: PUSH
62510: LD_EXP 36
62514: PUSH
62515: LD_VAR 0 2
62519: ARRAY
62520: UNION
62521: PPUSH
62522: LD_INT 33
62524: PUSH
62525: LD_INT 2
62527: PUSH
62528: EMPTY
62529: LIST
62530: LIST
62531: PPUSH
62532: CALL_OW 72
62536: NOT
62537: OR
62538: IFFALSE 62542
// continue ;
62540: GO 62435
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
62542: LD_ADDR_VAR 0 9
62546: PUSH
62547: LD_EXP 14
62551: PUSH
62552: LD_VAR 0 2
62556: ARRAY
62557: PPUSH
62558: LD_INT 30
62560: PUSH
62561: LD_INT 36
62563: PUSH
62564: EMPTY
62565: LIST
62566: LIST
62567: PPUSH
62568: CALL_OW 72
62572: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
62573: LD_ADDR_VAR 0 10
62577: PUSH
62578: LD_EXP 33
62582: PUSH
62583: LD_VAR 0 2
62587: ARRAY
62588: PPUSH
62589: LD_INT 34
62591: PUSH
62592: LD_INT 31
62594: PUSH
62595: EMPTY
62596: LIST
62597: LIST
62598: PPUSH
62599: CALL_OW 72
62603: ST_TO_ADDR
// if not cts and not mcts then
62604: LD_VAR 0 9
62608: NOT
62609: PUSH
62610: LD_VAR 0 10
62614: NOT
62615: AND
62616: IFFALSE 62620
// continue ;
62618: GO 62435
// x := cts ;
62620: LD_ADDR_VAR 0 11
62624: PUSH
62625: LD_VAR 0 9
62629: ST_TO_ADDR
// if not x then
62630: LD_VAR 0 11
62634: NOT
62635: IFFALSE 62647
// x := mcts ;
62637: LD_ADDR_VAR 0 11
62641: PUSH
62642: LD_VAR 0 10
62646: ST_TO_ADDR
// if not x then
62647: LD_VAR 0 11
62651: NOT
62652: IFFALSE 62656
// continue ;
62654: GO 62435
// if mc_remote_driver [ i ] then
62656: LD_EXP 54
62660: PUSH
62661: LD_VAR 0 2
62665: ARRAY
62666: IFFALSE 63053
// for j in mc_remote_driver [ i ] do
62668: LD_ADDR_VAR 0 3
62672: PUSH
62673: LD_EXP 54
62677: PUSH
62678: LD_VAR 0 2
62682: ARRAY
62683: PUSH
62684: FOR_IN
62685: IFFALSE 63051
// begin if GetClass ( j ) <> 3 then
62687: LD_VAR 0 3
62691: PPUSH
62692: CALL_OW 257
62696: PUSH
62697: LD_INT 3
62699: NONEQUAL
62700: IFFALSE 62753
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
62702: LD_ADDR_EXP 54
62706: PUSH
62707: LD_EXP 54
62711: PPUSH
62712: LD_VAR 0 2
62716: PPUSH
62717: LD_EXP 54
62721: PUSH
62722: LD_VAR 0 2
62726: ARRAY
62727: PUSH
62728: LD_VAR 0 3
62732: DIFF
62733: PPUSH
62734: CALL_OW 1
62738: ST_TO_ADDR
// SetTag ( j , 0 ) ;
62739: LD_VAR 0 3
62743: PPUSH
62744: LD_INT 0
62746: PPUSH
62747: CALL_OW 109
// continue ;
62751: GO 62684
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
62753: LD_EXP 33
62757: PUSH
62758: LD_VAR 0 2
62762: ARRAY
62763: PPUSH
62764: LD_INT 34
62766: PUSH
62767: LD_INT 31
62769: PUSH
62770: EMPTY
62771: LIST
62772: LIST
62773: PUSH
62774: LD_INT 58
62776: PUSH
62777: EMPTY
62778: LIST
62779: PUSH
62780: EMPTY
62781: LIST
62782: LIST
62783: PPUSH
62784: CALL_OW 72
62788: PUSH
62789: LD_VAR 0 3
62793: PPUSH
62794: CALL 38076 0 1
62798: NOT
62799: AND
62800: IFFALSE 62871
// begin if IsInUnit ( j ) then
62802: LD_VAR 0 3
62806: PPUSH
62807: CALL_OW 310
62811: IFFALSE 62822
// ComExitBuilding ( j ) ;
62813: LD_VAR 0 3
62817: PPUSH
62818: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
62822: LD_VAR 0 3
62826: PPUSH
62827: LD_EXP 33
62831: PUSH
62832: LD_VAR 0 2
62836: ARRAY
62837: PPUSH
62838: LD_INT 34
62840: PUSH
62841: LD_INT 31
62843: PUSH
62844: EMPTY
62845: LIST
62846: LIST
62847: PUSH
62848: LD_INT 58
62850: PUSH
62851: EMPTY
62852: LIST
62853: PUSH
62854: EMPTY
62855: LIST
62856: LIST
62857: PPUSH
62858: CALL_OW 72
62862: PUSH
62863: LD_INT 1
62865: ARRAY
62866: PPUSH
62867: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
62871: LD_VAR 0 3
62875: PPUSH
62876: CALL_OW 310
62880: NOT
62881: PUSH
62882: LD_VAR 0 3
62886: PPUSH
62887: CALL_OW 310
62891: PPUSH
62892: CALL_OW 266
62896: PUSH
62897: LD_INT 36
62899: NONEQUAL
62900: PUSH
62901: LD_VAR 0 3
62905: PPUSH
62906: CALL 38076 0 1
62910: NOT
62911: AND
62912: OR
62913: IFFALSE 63049
// begin if IsInUnit ( j ) then
62915: LD_VAR 0 3
62919: PPUSH
62920: CALL_OW 310
62924: IFFALSE 62935
// ComExitBuilding ( j ) ;
62926: LD_VAR 0 3
62930: PPUSH
62931: CALL_OW 122
// ct := 0 ;
62935: LD_ADDR_VAR 0 8
62939: PUSH
62940: LD_INT 0
62942: ST_TO_ADDR
// for k in x do
62943: LD_ADDR_VAR 0 4
62947: PUSH
62948: LD_VAR 0 11
62952: PUSH
62953: FOR_IN
62954: IFFALSE 63027
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
62956: LD_VAR 0 4
62960: PPUSH
62961: CALL_OW 264
62965: PUSH
62966: LD_INT 31
62968: EQUAL
62969: PUSH
62970: LD_VAR 0 4
62974: PPUSH
62975: CALL_OW 311
62979: NOT
62980: AND
62981: PUSH
62982: LD_VAR 0 4
62986: PPUSH
62987: CALL_OW 266
62991: PUSH
62992: LD_INT 36
62994: EQUAL
62995: PUSH
62996: LD_VAR 0 4
63000: PPUSH
63001: CALL_OW 313
63005: PUSH
63006: LD_INT 3
63008: LESS
63009: AND
63010: OR
63011: IFFALSE 63025
// begin ct := k ;
63013: LD_ADDR_VAR 0 8
63017: PUSH
63018: LD_VAR 0 4
63022: ST_TO_ADDR
// break ;
63023: GO 63027
// end ;
63025: GO 62953
63027: POP
63028: POP
// if ct then
63029: LD_VAR 0 8
63033: IFFALSE 63049
// ComEnterUnit ( j , ct ) ;
63035: LD_VAR 0 3
63039: PPUSH
63040: LD_VAR 0 8
63044: PPUSH
63045: CALL_OW 120
// end ; end ;
63049: GO 62684
63051: POP
63052: POP
// places := 0 ;
63053: LD_ADDR_VAR 0 5
63057: PUSH
63058: LD_INT 0
63060: ST_TO_ADDR
// for j = 1 to x do
63061: LD_ADDR_VAR 0 3
63065: PUSH
63066: DOUBLE
63067: LD_INT 1
63069: DEC
63070: ST_TO_ADDR
63071: LD_VAR 0 11
63075: PUSH
63076: FOR_TO
63077: IFFALSE 63153
// if GetWeapon ( x [ j ] ) = ar_control_tower then
63079: LD_VAR 0 11
63083: PUSH
63084: LD_VAR 0 3
63088: ARRAY
63089: PPUSH
63090: CALL_OW 264
63094: PUSH
63095: LD_INT 31
63097: EQUAL
63098: IFFALSE 63116
// places := places + 1 else
63100: LD_ADDR_VAR 0 5
63104: PUSH
63105: LD_VAR 0 5
63109: PUSH
63110: LD_INT 1
63112: PLUS
63113: ST_TO_ADDR
63114: GO 63151
// if GetBType ( x [ j ] ) = b_control_tower then
63116: LD_VAR 0 11
63120: PUSH
63121: LD_VAR 0 3
63125: ARRAY
63126: PPUSH
63127: CALL_OW 266
63131: PUSH
63132: LD_INT 36
63134: EQUAL
63135: IFFALSE 63151
// places := places + 3 ;
63137: LD_ADDR_VAR 0 5
63141: PUSH
63142: LD_VAR 0 5
63146: PUSH
63147: LD_INT 3
63149: PLUS
63150: ST_TO_ADDR
63151: GO 63076
63153: POP
63154: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
63155: LD_VAR 0 5
63159: PUSH
63160: LD_INT 0
63162: EQUAL
63163: PUSH
63164: LD_VAR 0 5
63168: PUSH
63169: LD_EXP 54
63173: PUSH
63174: LD_VAR 0 2
63178: ARRAY
63179: LESSEQUAL
63180: OR
63181: IFFALSE 63185
// continue ;
63183: GO 62435
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
63185: LD_ADDR_VAR 0 6
63189: PUSH
63190: LD_EXP 14
63194: PUSH
63195: LD_VAR 0 2
63199: ARRAY
63200: PPUSH
63201: LD_INT 25
63203: PUSH
63204: LD_INT 3
63206: PUSH
63207: EMPTY
63208: LIST
63209: LIST
63210: PPUSH
63211: CALL_OW 72
63215: PUSH
63216: LD_EXP 54
63220: PUSH
63221: LD_VAR 0 2
63225: ARRAY
63226: DIFF
63227: PPUSH
63228: LD_INT 3
63230: PPUSH
63231: CALL 38976 0 2
63235: ST_TO_ADDR
// for j in tmp do
63236: LD_ADDR_VAR 0 3
63240: PUSH
63241: LD_VAR 0 6
63245: PUSH
63246: FOR_IN
63247: IFFALSE 63282
// if GetTag ( j ) > 0 then
63249: LD_VAR 0 3
63253: PPUSH
63254: CALL_OW 110
63258: PUSH
63259: LD_INT 0
63261: GREATER
63262: IFFALSE 63280
// tmp := tmp diff j ;
63264: LD_ADDR_VAR 0 6
63268: PUSH
63269: LD_VAR 0 6
63273: PUSH
63274: LD_VAR 0 3
63278: DIFF
63279: ST_TO_ADDR
63280: GO 63246
63282: POP
63283: POP
// if not tmp then
63284: LD_VAR 0 6
63288: NOT
63289: IFFALSE 63293
// continue ;
63291: GO 62435
// if places then
63293: LD_VAR 0 5
63297: IFFALSE 63356
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
63299: LD_ADDR_EXP 54
63303: PUSH
63304: LD_EXP 54
63308: PPUSH
63309: LD_VAR 0 2
63313: PPUSH
63314: LD_EXP 54
63318: PUSH
63319: LD_VAR 0 2
63323: ARRAY
63324: PUSH
63325: LD_VAR 0 6
63329: PUSH
63330: LD_INT 1
63332: ARRAY
63333: UNION
63334: PPUSH
63335: CALL_OW 1
63339: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
63340: LD_VAR 0 6
63344: PUSH
63345: LD_INT 1
63347: ARRAY
63348: PPUSH
63349: LD_INT 126
63351: PPUSH
63352: CALL_OW 109
// end ; end ;
63356: GO 62435
63358: POP
63359: POP
// end ;
63360: LD_VAR 0 1
63364: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
63365: LD_INT 0
63367: PPUSH
63368: PPUSH
63369: PPUSH
63370: PPUSH
63371: PPUSH
63372: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
63373: LD_VAR 0 1
63377: NOT
63378: PUSH
63379: LD_VAR 0 2
63383: NOT
63384: OR
63385: PUSH
63386: LD_VAR 0 3
63390: NOT
63391: OR
63392: PUSH
63393: LD_VAR 0 4
63397: PUSH
63398: LD_INT 1
63400: PUSH
63401: LD_INT 2
63403: PUSH
63404: LD_INT 3
63406: PUSH
63407: LD_INT 4
63409: PUSH
63410: LD_INT 5
63412: PUSH
63413: LD_INT 8
63415: PUSH
63416: LD_INT 9
63418: PUSH
63419: LD_INT 15
63421: PUSH
63422: LD_INT 16
63424: PUSH
63425: EMPTY
63426: LIST
63427: LIST
63428: LIST
63429: LIST
63430: LIST
63431: LIST
63432: LIST
63433: LIST
63434: LIST
63435: IN
63436: NOT
63437: OR
63438: IFFALSE 63442
// exit ;
63440: GO 64342
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
63442: LD_ADDR_VAR 0 2
63446: PUSH
63447: LD_VAR 0 2
63451: PPUSH
63452: LD_INT 21
63454: PUSH
63455: LD_INT 3
63457: PUSH
63458: EMPTY
63459: LIST
63460: LIST
63461: PUSH
63462: LD_INT 24
63464: PUSH
63465: LD_INT 250
63467: PUSH
63468: EMPTY
63469: LIST
63470: LIST
63471: PUSH
63472: EMPTY
63473: LIST
63474: LIST
63475: PPUSH
63476: CALL_OW 72
63480: ST_TO_ADDR
// case class of 1 , 15 :
63481: LD_VAR 0 4
63485: PUSH
63486: LD_INT 1
63488: DOUBLE
63489: EQUAL
63490: IFTRUE 63500
63492: LD_INT 15
63494: DOUBLE
63495: EQUAL
63496: IFTRUE 63500
63498: GO 63585
63500: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
63501: LD_ADDR_VAR 0 8
63505: PUSH
63506: LD_VAR 0 2
63510: PPUSH
63511: LD_INT 2
63513: PUSH
63514: LD_INT 30
63516: PUSH
63517: LD_INT 32
63519: PUSH
63520: EMPTY
63521: LIST
63522: LIST
63523: PUSH
63524: LD_INT 30
63526: PUSH
63527: LD_INT 31
63529: PUSH
63530: EMPTY
63531: LIST
63532: LIST
63533: PUSH
63534: EMPTY
63535: LIST
63536: LIST
63537: LIST
63538: PPUSH
63539: CALL_OW 72
63543: PUSH
63544: LD_VAR 0 2
63548: PPUSH
63549: LD_INT 2
63551: PUSH
63552: LD_INT 30
63554: PUSH
63555: LD_INT 4
63557: PUSH
63558: EMPTY
63559: LIST
63560: LIST
63561: PUSH
63562: LD_INT 30
63564: PUSH
63565: LD_INT 5
63567: PUSH
63568: EMPTY
63569: LIST
63570: LIST
63571: PUSH
63572: EMPTY
63573: LIST
63574: LIST
63575: LIST
63576: PPUSH
63577: CALL_OW 72
63581: ADD
63582: ST_TO_ADDR
63583: GO 63831
63585: LD_INT 2
63587: DOUBLE
63588: EQUAL
63589: IFTRUE 63599
63591: LD_INT 16
63593: DOUBLE
63594: EQUAL
63595: IFTRUE 63599
63597: GO 63645
63599: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
63600: LD_ADDR_VAR 0 8
63604: PUSH
63605: LD_VAR 0 2
63609: PPUSH
63610: LD_INT 2
63612: PUSH
63613: LD_INT 30
63615: PUSH
63616: LD_INT 0
63618: PUSH
63619: EMPTY
63620: LIST
63621: LIST
63622: PUSH
63623: LD_INT 30
63625: PUSH
63626: LD_INT 1
63628: PUSH
63629: EMPTY
63630: LIST
63631: LIST
63632: PUSH
63633: EMPTY
63634: LIST
63635: LIST
63636: LIST
63637: PPUSH
63638: CALL_OW 72
63642: ST_TO_ADDR
63643: GO 63831
63645: LD_INT 3
63647: DOUBLE
63648: EQUAL
63649: IFTRUE 63653
63651: GO 63699
63653: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
63654: LD_ADDR_VAR 0 8
63658: PUSH
63659: LD_VAR 0 2
63663: PPUSH
63664: LD_INT 2
63666: PUSH
63667: LD_INT 30
63669: PUSH
63670: LD_INT 2
63672: PUSH
63673: EMPTY
63674: LIST
63675: LIST
63676: PUSH
63677: LD_INT 30
63679: PUSH
63680: LD_INT 3
63682: PUSH
63683: EMPTY
63684: LIST
63685: LIST
63686: PUSH
63687: EMPTY
63688: LIST
63689: LIST
63690: LIST
63691: PPUSH
63692: CALL_OW 72
63696: ST_TO_ADDR
63697: GO 63831
63699: LD_INT 4
63701: DOUBLE
63702: EQUAL
63703: IFTRUE 63707
63705: GO 63764
63707: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
63708: LD_ADDR_VAR 0 8
63712: PUSH
63713: LD_VAR 0 2
63717: PPUSH
63718: LD_INT 2
63720: PUSH
63721: LD_INT 30
63723: PUSH
63724: LD_INT 6
63726: PUSH
63727: EMPTY
63728: LIST
63729: LIST
63730: PUSH
63731: LD_INT 30
63733: PUSH
63734: LD_INT 7
63736: PUSH
63737: EMPTY
63738: LIST
63739: LIST
63740: PUSH
63741: LD_INT 30
63743: PUSH
63744: LD_INT 8
63746: PUSH
63747: EMPTY
63748: LIST
63749: LIST
63750: PUSH
63751: EMPTY
63752: LIST
63753: LIST
63754: LIST
63755: LIST
63756: PPUSH
63757: CALL_OW 72
63761: ST_TO_ADDR
63762: GO 63831
63764: LD_INT 5
63766: DOUBLE
63767: EQUAL
63768: IFTRUE 63784
63770: LD_INT 8
63772: DOUBLE
63773: EQUAL
63774: IFTRUE 63784
63776: LD_INT 9
63778: DOUBLE
63779: EQUAL
63780: IFTRUE 63784
63782: GO 63830
63784: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
63785: LD_ADDR_VAR 0 8
63789: PUSH
63790: LD_VAR 0 2
63794: PPUSH
63795: LD_INT 2
63797: PUSH
63798: LD_INT 30
63800: PUSH
63801: LD_INT 4
63803: PUSH
63804: EMPTY
63805: LIST
63806: LIST
63807: PUSH
63808: LD_INT 30
63810: PUSH
63811: LD_INT 5
63813: PUSH
63814: EMPTY
63815: LIST
63816: LIST
63817: PUSH
63818: EMPTY
63819: LIST
63820: LIST
63821: LIST
63822: PPUSH
63823: CALL_OW 72
63827: ST_TO_ADDR
63828: GO 63831
63830: POP
// if not tmp then
63831: LD_VAR 0 8
63835: NOT
63836: IFFALSE 63840
// exit ;
63838: GO 64342
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
63840: LD_VAR 0 4
63844: PUSH
63845: LD_INT 1
63847: PUSH
63848: LD_INT 15
63850: PUSH
63851: EMPTY
63852: LIST
63853: LIST
63854: IN
63855: PUSH
63856: LD_EXP 23
63860: PUSH
63861: LD_VAR 0 1
63865: ARRAY
63866: AND
63867: IFFALSE 64023
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
63869: LD_ADDR_VAR 0 9
63873: PUSH
63874: LD_EXP 23
63878: PUSH
63879: LD_VAR 0 1
63883: ARRAY
63884: PUSH
63885: LD_INT 1
63887: ARRAY
63888: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
63889: LD_VAR 0 9
63893: PUSH
63894: LD_EXP 24
63898: PUSH
63899: LD_VAR 0 1
63903: ARRAY
63904: IN
63905: NOT
63906: IFFALSE 64021
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
63908: LD_ADDR_EXP 24
63912: PUSH
63913: LD_EXP 24
63917: PPUSH
63918: LD_VAR 0 1
63922: PUSH
63923: LD_EXP 24
63927: PUSH
63928: LD_VAR 0 1
63932: ARRAY
63933: PUSH
63934: LD_INT 1
63936: PLUS
63937: PUSH
63938: EMPTY
63939: LIST
63940: LIST
63941: PPUSH
63942: LD_VAR 0 9
63946: PPUSH
63947: CALL 9427 0 3
63951: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
63952: LD_ADDR_EXP 23
63956: PUSH
63957: LD_EXP 23
63961: PPUSH
63962: LD_VAR 0 1
63966: PPUSH
63967: LD_EXP 23
63971: PUSH
63972: LD_VAR 0 1
63976: ARRAY
63977: PUSH
63978: LD_VAR 0 9
63982: DIFF
63983: PPUSH
63984: CALL_OW 1
63988: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
63989: LD_VAR 0 3
63993: PPUSH
63994: LD_EXP 24
63998: PUSH
63999: LD_VAR 0 1
64003: ARRAY
64004: PUSH
64005: LD_EXP 24
64009: PUSH
64010: LD_VAR 0 1
64014: ARRAY
64015: ARRAY
64016: PPUSH
64017: CALL_OW 120
// end ; exit ;
64021: GO 64342
// end ; if tmp > 1 then
64023: LD_VAR 0 8
64027: PUSH
64028: LD_INT 1
64030: GREATER
64031: IFFALSE 64135
// for i = 2 to tmp do
64033: LD_ADDR_VAR 0 6
64037: PUSH
64038: DOUBLE
64039: LD_INT 2
64041: DEC
64042: ST_TO_ADDR
64043: LD_VAR 0 8
64047: PUSH
64048: FOR_TO
64049: IFFALSE 64133
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
64051: LD_VAR 0 8
64055: PUSH
64056: LD_VAR 0 6
64060: ARRAY
64061: PPUSH
64062: CALL_OW 461
64066: PUSH
64067: LD_INT 6
64069: EQUAL
64070: IFFALSE 64131
// begin x := tmp [ i ] ;
64072: LD_ADDR_VAR 0 9
64076: PUSH
64077: LD_VAR 0 8
64081: PUSH
64082: LD_VAR 0 6
64086: ARRAY
64087: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
64088: LD_ADDR_VAR 0 8
64092: PUSH
64093: LD_VAR 0 8
64097: PPUSH
64098: LD_VAR 0 6
64102: PPUSH
64103: CALL_OW 3
64107: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
64108: LD_ADDR_VAR 0 8
64112: PUSH
64113: LD_VAR 0 8
64117: PPUSH
64118: LD_INT 1
64120: PPUSH
64121: LD_VAR 0 9
64125: PPUSH
64126: CALL_OW 2
64130: ST_TO_ADDR
// end ;
64131: GO 64048
64133: POP
64134: POP
// for i in tmp do
64135: LD_ADDR_VAR 0 6
64139: PUSH
64140: LD_VAR 0 8
64144: PUSH
64145: FOR_IN
64146: IFFALSE 64215
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
64148: LD_VAR 0 6
64152: PPUSH
64153: CALL_OW 313
64157: PUSH
64158: LD_INT 6
64160: LESS
64161: PUSH
64162: LD_VAR 0 6
64166: PPUSH
64167: CALL_OW 266
64171: PUSH
64172: LD_INT 31
64174: PUSH
64175: LD_INT 32
64177: PUSH
64178: EMPTY
64179: LIST
64180: LIST
64181: IN
64182: NOT
64183: AND
64184: PUSH
64185: LD_VAR 0 6
64189: PPUSH
64190: CALL_OW 313
64194: PUSH
64195: LD_INT 0
64197: EQUAL
64198: OR
64199: IFFALSE 64213
// begin j := i ;
64201: LD_ADDR_VAR 0 7
64205: PUSH
64206: LD_VAR 0 6
64210: ST_TO_ADDR
// break ;
64211: GO 64215
// end ; end ;
64213: GO 64145
64215: POP
64216: POP
// if j then
64217: LD_VAR 0 7
64221: IFFALSE 64239
// ComEnterUnit ( unit , j ) else
64223: LD_VAR 0 3
64227: PPUSH
64228: LD_VAR 0 7
64232: PPUSH
64233: CALL_OW 120
64237: GO 64342
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64239: LD_ADDR_VAR 0 10
64243: PUSH
64244: LD_VAR 0 2
64248: PPUSH
64249: LD_INT 2
64251: PUSH
64252: LD_INT 30
64254: PUSH
64255: LD_INT 0
64257: PUSH
64258: EMPTY
64259: LIST
64260: LIST
64261: PUSH
64262: LD_INT 30
64264: PUSH
64265: LD_INT 1
64267: PUSH
64268: EMPTY
64269: LIST
64270: LIST
64271: PUSH
64272: EMPTY
64273: LIST
64274: LIST
64275: LIST
64276: PPUSH
64277: CALL_OW 72
64281: ST_TO_ADDR
// if depot then
64282: LD_VAR 0 10
64286: IFFALSE 64342
// begin depot := NearestUnitToUnit ( depot , unit ) ;
64288: LD_ADDR_VAR 0 10
64292: PUSH
64293: LD_VAR 0 10
64297: PPUSH
64298: LD_VAR 0 3
64302: PPUSH
64303: CALL_OW 74
64307: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
64308: LD_VAR 0 3
64312: PPUSH
64313: LD_VAR 0 10
64317: PPUSH
64318: CALL_OW 296
64322: PUSH
64323: LD_INT 10
64325: GREATER
64326: IFFALSE 64342
// ComStandNearbyBuilding ( unit , depot ) ;
64328: LD_VAR 0 3
64332: PPUSH
64333: LD_VAR 0 10
64337: PPUSH
64338: CALL 6041 0 2
// end ; end ; end ;
64342: LD_VAR 0 5
64346: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
64347: LD_INT 0
64349: PPUSH
64350: PPUSH
64351: PPUSH
64352: PPUSH
// if not mc_bases then
64353: LD_EXP 14
64357: NOT
64358: IFFALSE 64362
// exit ;
64360: GO 64601
// for i = 1 to mc_bases do
64362: LD_ADDR_VAR 0 2
64366: PUSH
64367: DOUBLE
64368: LD_INT 1
64370: DEC
64371: ST_TO_ADDR
64372: LD_EXP 14
64376: PUSH
64377: FOR_TO
64378: IFFALSE 64599
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
64380: LD_ADDR_VAR 0 4
64384: PUSH
64385: LD_EXP 14
64389: PUSH
64390: LD_VAR 0 2
64394: ARRAY
64395: PPUSH
64396: LD_INT 21
64398: PUSH
64399: LD_INT 1
64401: PUSH
64402: EMPTY
64403: LIST
64404: LIST
64405: PPUSH
64406: CALL_OW 72
64410: PUSH
64411: LD_EXP 43
64415: PUSH
64416: LD_VAR 0 2
64420: ARRAY
64421: UNION
64422: ST_TO_ADDR
// if not tmp then
64423: LD_VAR 0 4
64427: NOT
64428: IFFALSE 64432
// continue ;
64430: GO 64377
// for j in tmp do
64432: LD_ADDR_VAR 0 3
64436: PUSH
64437: LD_VAR 0 4
64441: PUSH
64442: FOR_IN
64443: IFFALSE 64595
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
64445: LD_VAR 0 3
64449: PPUSH
64450: CALL_OW 110
64454: NOT
64455: PUSH
64456: LD_VAR 0 3
64460: PPUSH
64461: CALL_OW 314
64465: NOT
64466: AND
64467: PUSH
64468: LD_VAR 0 3
64472: PPUSH
64473: CALL_OW 311
64477: NOT
64478: AND
64479: PUSH
64480: LD_VAR 0 3
64484: PPUSH
64485: CALL_OW 310
64489: NOT
64490: AND
64491: PUSH
64492: LD_VAR 0 3
64496: PUSH
64497: LD_EXP 17
64501: PUSH
64502: LD_VAR 0 2
64506: ARRAY
64507: PUSH
64508: LD_INT 1
64510: ARRAY
64511: IN
64512: NOT
64513: AND
64514: PUSH
64515: LD_VAR 0 3
64519: PUSH
64520: LD_EXP 17
64524: PUSH
64525: LD_VAR 0 2
64529: ARRAY
64530: PUSH
64531: LD_INT 2
64533: ARRAY
64534: IN
64535: NOT
64536: AND
64537: PUSH
64538: LD_VAR 0 3
64542: PUSH
64543: LD_EXP 26
64547: PUSH
64548: LD_VAR 0 2
64552: ARRAY
64553: IN
64554: NOT
64555: AND
64556: IFFALSE 64593
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
64558: LD_VAR 0 2
64562: PPUSH
64563: LD_EXP 14
64567: PUSH
64568: LD_VAR 0 2
64572: ARRAY
64573: PPUSH
64574: LD_VAR 0 3
64578: PPUSH
64579: LD_VAR 0 3
64583: PPUSH
64584: CALL_OW 257
64588: PPUSH
64589: CALL 63365 0 4
// end ;
64593: GO 64442
64595: POP
64596: POP
// end ;
64597: GO 64377
64599: POP
64600: POP
// end ;
64601: LD_VAR 0 1
64605: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
64606: LD_INT 0
64608: PPUSH
64609: PPUSH
64610: PPUSH
64611: PPUSH
64612: PPUSH
64613: PPUSH
// if not mc_bases [ base ] then
64614: LD_EXP 14
64618: PUSH
64619: LD_VAR 0 1
64623: ARRAY
64624: NOT
64625: IFFALSE 64629
// exit ;
64627: GO 64811
// tmp := [ ] ;
64629: LD_ADDR_VAR 0 6
64633: PUSH
64634: EMPTY
64635: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
64636: LD_ADDR_VAR 0 7
64640: PUSH
64641: LD_VAR 0 3
64645: PPUSH
64646: LD_INT 0
64648: PPUSH
64649: CALL_OW 517
64653: ST_TO_ADDR
// if not list then
64654: LD_VAR 0 7
64658: NOT
64659: IFFALSE 64663
// exit ;
64661: GO 64811
// for i = 1 to amount do
64663: LD_ADDR_VAR 0 5
64667: PUSH
64668: DOUBLE
64669: LD_INT 1
64671: DEC
64672: ST_TO_ADDR
64673: LD_VAR 0 2
64677: PUSH
64678: FOR_TO
64679: IFFALSE 64759
// begin x := rand ( 1 , list [ 1 ] ) ;
64681: LD_ADDR_VAR 0 8
64685: PUSH
64686: LD_INT 1
64688: PPUSH
64689: LD_VAR 0 7
64693: PUSH
64694: LD_INT 1
64696: ARRAY
64697: PPUSH
64698: CALL_OW 12
64702: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
64703: LD_ADDR_VAR 0 6
64707: PUSH
64708: LD_VAR 0 6
64712: PPUSH
64713: LD_VAR 0 5
64717: PPUSH
64718: LD_VAR 0 7
64722: PUSH
64723: LD_INT 1
64725: ARRAY
64726: PUSH
64727: LD_VAR 0 8
64731: ARRAY
64732: PUSH
64733: LD_VAR 0 7
64737: PUSH
64738: LD_INT 2
64740: ARRAY
64741: PUSH
64742: LD_VAR 0 8
64746: ARRAY
64747: PUSH
64748: EMPTY
64749: LIST
64750: LIST
64751: PPUSH
64752: CALL_OW 1
64756: ST_TO_ADDR
// end ;
64757: GO 64678
64759: POP
64760: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
64761: LD_ADDR_EXP 27
64765: PUSH
64766: LD_EXP 27
64770: PPUSH
64771: LD_VAR 0 1
64775: PPUSH
64776: LD_VAR 0 6
64780: PPUSH
64781: CALL_OW 1
64785: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
64786: LD_ADDR_EXP 29
64790: PUSH
64791: LD_EXP 29
64795: PPUSH
64796: LD_VAR 0 1
64800: PPUSH
64801: LD_VAR 0 3
64805: PPUSH
64806: CALL_OW 1
64810: ST_TO_ADDR
// end ;
64811: LD_VAR 0 4
64815: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
64816: LD_INT 0
64818: PPUSH
// if not mc_bases [ base ] then
64819: LD_EXP 14
64823: PUSH
64824: LD_VAR 0 1
64828: ARRAY
64829: NOT
64830: IFFALSE 64834
// exit ;
64832: GO 64859
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
64834: LD_ADDR_EXP 19
64838: PUSH
64839: LD_EXP 19
64843: PPUSH
64844: LD_VAR 0 1
64848: PPUSH
64849: LD_VAR 0 2
64853: PPUSH
64854: CALL_OW 1
64858: ST_TO_ADDR
// end ;
64859: LD_VAR 0 3
64863: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
64864: LD_INT 0
64866: PPUSH
// if not mc_bases [ base ] then
64867: LD_EXP 14
64871: PUSH
64872: LD_VAR 0 1
64876: ARRAY
64877: NOT
64878: IFFALSE 64882
// exit ;
64880: GO 64919
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
64882: LD_ADDR_EXP 19
64886: PUSH
64887: LD_EXP 19
64891: PPUSH
64892: LD_VAR 0 1
64896: PPUSH
64897: LD_EXP 19
64901: PUSH
64902: LD_VAR 0 1
64906: ARRAY
64907: PUSH
64908: LD_VAR 0 2
64912: UNION
64913: PPUSH
64914: CALL_OW 1
64918: ST_TO_ADDR
// end ;
64919: LD_VAR 0 3
64923: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
64924: LD_INT 0
64926: PPUSH
// if not mc_bases [ base ] then
64927: LD_EXP 14
64931: PUSH
64932: LD_VAR 0 1
64936: ARRAY
64937: NOT
64938: IFFALSE 64942
// exit ;
64940: GO 64967
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
64942: LD_ADDR_EXP 35
64946: PUSH
64947: LD_EXP 35
64951: PPUSH
64952: LD_VAR 0 1
64956: PPUSH
64957: LD_VAR 0 2
64961: PPUSH
64962: CALL_OW 1
64966: ST_TO_ADDR
// end ;
64967: LD_VAR 0 3
64971: RET
// export function MC_InsertProduceList ( base , components ) ; begin
64972: LD_INT 0
64974: PPUSH
// if not mc_bases [ base ] then
64975: LD_EXP 14
64979: PUSH
64980: LD_VAR 0 1
64984: ARRAY
64985: NOT
64986: IFFALSE 64990
// exit ;
64988: GO 65027
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
64990: LD_ADDR_EXP 35
64994: PUSH
64995: LD_EXP 35
64999: PPUSH
65000: LD_VAR 0 1
65004: PPUSH
65005: LD_EXP 35
65009: PUSH
65010: LD_VAR 0 1
65014: ARRAY
65015: PUSH
65016: LD_VAR 0 2
65020: ADD
65021: PPUSH
65022: CALL_OW 1
65026: ST_TO_ADDR
// end ;
65027: LD_VAR 0 3
65031: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
65032: LD_INT 0
65034: PPUSH
// if not mc_bases [ base ] then
65035: LD_EXP 14
65039: PUSH
65040: LD_VAR 0 1
65044: ARRAY
65045: NOT
65046: IFFALSE 65050
// exit ;
65048: GO 65104
// mc_defender := Replace ( mc_defender , base , deflist ) ;
65050: LD_ADDR_EXP 36
65054: PUSH
65055: LD_EXP 36
65059: PPUSH
65060: LD_VAR 0 1
65064: PPUSH
65065: LD_VAR 0 2
65069: PPUSH
65070: CALL_OW 1
65074: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
65075: LD_ADDR_EXP 25
65079: PUSH
65080: LD_EXP 25
65084: PPUSH
65085: LD_VAR 0 1
65089: PPUSH
65090: LD_VAR 0 2
65094: PUSH
65095: LD_INT 0
65097: PLUS
65098: PPUSH
65099: CALL_OW 1
65103: ST_TO_ADDR
// end ;
65104: LD_VAR 0 3
65108: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
65109: LD_INT 0
65111: PPUSH
// if not mc_bases [ base ] then
65112: LD_EXP 14
65116: PUSH
65117: LD_VAR 0 1
65121: ARRAY
65122: NOT
65123: IFFALSE 65127
// exit ;
65125: GO 65152
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
65127: LD_ADDR_EXP 25
65131: PUSH
65132: LD_EXP 25
65136: PPUSH
65137: LD_VAR 0 1
65141: PPUSH
65142: LD_VAR 0 2
65146: PPUSH
65147: CALL_OW 1
65151: ST_TO_ADDR
// end ;
65152: LD_VAR 0 3
65156: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
65157: LD_INT 0
65159: PPUSH
65160: PPUSH
65161: PPUSH
65162: PPUSH
// if not mc_bases [ base ] then
65163: LD_EXP 14
65167: PUSH
65168: LD_VAR 0 1
65172: ARRAY
65173: NOT
65174: IFFALSE 65178
// exit ;
65176: GO 65243
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
65178: LD_ADDR_EXP 34
65182: PUSH
65183: LD_EXP 34
65187: PPUSH
65188: LD_VAR 0 1
65192: PUSH
65193: LD_EXP 34
65197: PUSH
65198: LD_VAR 0 1
65202: ARRAY
65203: PUSH
65204: LD_INT 1
65206: PLUS
65207: PUSH
65208: EMPTY
65209: LIST
65210: LIST
65211: PPUSH
65212: LD_VAR 0 1
65216: PUSH
65217: LD_VAR 0 2
65221: PUSH
65222: LD_VAR 0 3
65226: PUSH
65227: LD_VAR 0 4
65231: PUSH
65232: EMPTY
65233: LIST
65234: LIST
65235: LIST
65236: LIST
65237: PPUSH
65238: CALL 9427 0 3
65242: ST_TO_ADDR
// end ;
65243: LD_VAR 0 5
65247: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
65248: LD_INT 0
65250: PPUSH
// if not mc_bases [ base ] then
65251: LD_EXP 14
65255: PUSH
65256: LD_VAR 0 1
65260: ARRAY
65261: NOT
65262: IFFALSE 65266
// exit ;
65264: GO 65291
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
65266: LD_ADDR_EXP 51
65270: PUSH
65271: LD_EXP 51
65275: PPUSH
65276: LD_VAR 0 1
65280: PPUSH
65281: LD_VAR 0 2
65285: PPUSH
65286: CALL_OW 1
65290: ST_TO_ADDR
// end ;
65291: LD_VAR 0 3
65295: RET
// export function MC_GetMinesField ( base ) ; begin
65296: LD_INT 0
65298: PPUSH
// result := mc_mines [ base ] ;
65299: LD_ADDR_VAR 0 2
65303: PUSH
65304: LD_EXP 27
65308: PUSH
65309: LD_VAR 0 1
65313: ARRAY
65314: ST_TO_ADDR
// end ;
65315: LD_VAR 0 2
65319: RET
// export function MC_GetProduceList ( base ) ; begin
65320: LD_INT 0
65322: PPUSH
// result := mc_produce [ base ] ;
65323: LD_ADDR_VAR 0 2
65327: PUSH
65328: LD_EXP 35
65332: PUSH
65333: LD_VAR 0 1
65337: ARRAY
65338: ST_TO_ADDR
// end ;
65339: LD_VAR 0 2
65343: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
65344: LD_INT 0
65346: PPUSH
65347: PPUSH
// if not mc_bases then
65348: LD_EXP 14
65352: NOT
65353: IFFALSE 65357
// exit ;
65355: GO 65422
// if mc_bases [ base ] then
65357: LD_EXP 14
65361: PUSH
65362: LD_VAR 0 1
65366: ARRAY
65367: IFFALSE 65422
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
65369: LD_ADDR_VAR 0 3
65373: PUSH
65374: LD_EXP 14
65378: PUSH
65379: LD_VAR 0 1
65383: ARRAY
65384: PPUSH
65385: LD_INT 30
65387: PUSH
65388: LD_VAR 0 2
65392: PUSH
65393: EMPTY
65394: LIST
65395: LIST
65396: PPUSH
65397: CALL_OW 72
65401: ST_TO_ADDR
// if result then
65402: LD_VAR 0 3
65406: IFFALSE 65422
// result := result [ 1 ] ;
65408: LD_ADDR_VAR 0 3
65412: PUSH
65413: LD_VAR 0 3
65417: PUSH
65418: LD_INT 1
65420: ARRAY
65421: ST_TO_ADDR
// end ; end ;
65422: LD_VAR 0 3
65426: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
65427: LD_INT 0
65429: PPUSH
65430: PPUSH
// if not mc_bases then
65431: LD_EXP 14
65435: NOT
65436: IFFALSE 65440
// exit ;
65438: GO 65485
// if mc_bases [ base ] then
65440: LD_EXP 14
65444: PUSH
65445: LD_VAR 0 1
65449: ARRAY
65450: IFFALSE 65485
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
65452: LD_ADDR_VAR 0 3
65456: PUSH
65457: LD_EXP 14
65461: PUSH
65462: LD_VAR 0 1
65466: ARRAY
65467: PPUSH
65468: LD_INT 30
65470: PUSH
65471: LD_VAR 0 2
65475: PUSH
65476: EMPTY
65477: LIST
65478: LIST
65479: PPUSH
65480: CALL_OW 72
65484: ST_TO_ADDR
// end ;
65485: LD_VAR 0 3
65489: RET
// export function MC_SetTame ( base , area ) ; begin
65490: LD_INT 0
65492: PPUSH
// if not mc_bases or not base then
65493: LD_EXP 14
65497: NOT
65498: PUSH
65499: LD_VAR 0 1
65503: NOT
65504: OR
65505: IFFALSE 65509
// exit ;
65507: GO 65534
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
65509: LD_ADDR_EXP 42
65513: PUSH
65514: LD_EXP 42
65518: PPUSH
65519: LD_VAR 0 1
65523: PPUSH
65524: LD_VAR 0 2
65528: PPUSH
65529: CALL_OW 1
65533: ST_TO_ADDR
// end ;
65534: LD_VAR 0 3
65538: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
65539: LD_INT 0
65541: PPUSH
65542: PPUSH
// if not mc_bases or not base then
65543: LD_EXP 14
65547: NOT
65548: PUSH
65549: LD_VAR 0 1
65553: NOT
65554: OR
65555: IFFALSE 65559
// exit ;
65557: GO 65661
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
65559: LD_ADDR_VAR 0 4
65563: PUSH
65564: LD_EXP 14
65568: PUSH
65569: LD_VAR 0 1
65573: ARRAY
65574: PPUSH
65575: LD_INT 30
65577: PUSH
65578: LD_VAR 0 2
65582: PUSH
65583: EMPTY
65584: LIST
65585: LIST
65586: PPUSH
65587: CALL_OW 72
65591: ST_TO_ADDR
// if not tmp then
65592: LD_VAR 0 4
65596: NOT
65597: IFFALSE 65601
// exit ;
65599: GO 65661
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
65601: LD_ADDR_EXP 46
65605: PUSH
65606: LD_EXP 46
65610: PPUSH
65611: LD_VAR 0 1
65615: PPUSH
65616: LD_EXP 46
65620: PUSH
65621: LD_VAR 0 1
65625: ARRAY
65626: PPUSH
65627: LD_EXP 46
65631: PUSH
65632: LD_VAR 0 1
65636: ARRAY
65637: PUSH
65638: LD_INT 1
65640: PLUS
65641: PPUSH
65642: LD_VAR 0 4
65646: PUSH
65647: LD_INT 1
65649: ARRAY
65650: PPUSH
65651: CALL_OW 2
65655: PPUSH
65656: CALL_OW 1
65660: ST_TO_ADDR
// end ;
65661: LD_VAR 0 3
65665: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
65666: LD_INT 0
65668: PPUSH
65669: PPUSH
// if not mc_bases or not base or not kinds then
65670: LD_EXP 14
65674: NOT
65675: PUSH
65676: LD_VAR 0 1
65680: NOT
65681: OR
65682: PUSH
65683: LD_VAR 0 2
65687: NOT
65688: OR
65689: IFFALSE 65693
// exit ;
65691: GO 65754
// for i in kinds do
65693: LD_ADDR_VAR 0 4
65697: PUSH
65698: LD_VAR 0 2
65702: PUSH
65703: FOR_IN
65704: IFFALSE 65752
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
65706: LD_ADDR_EXP 48
65710: PUSH
65711: LD_EXP 48
65715: PPUSH
65716: LD_VAR 0 1
65720: PUSH
65721: LD_EXP 48
65725: PUSH
65726: LD_VAR 0 1
65730: ARRAY
65731: PUSH
65732: LD_INT 1
65734: PLUS
65735: PUSH
65736: EMPTY
65737: LIST
65738: LIST
65739: PPUSH
65740: LD_VAR 0 4
65744: PPUSH
65745: CALL 9427 0 3
65749: ST_TO_ADDR
65750: GO 65703
65752: POP
65753: POP
// end ;
65754: LD_VAR 0 3
65758: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
65759: LD_INT 0
65761: PPUSH
// if not mc_bases or not base or not areas then
65762: LD_EXP 14
65766: NOT
65767: PUSH
65768: LD_VAR 0 1
65772: NOT
65773: OR
65774: PUSH
65775: LD_VAR 0 2
65779: NOT
65780: OR
65781: IFFALSE 65785
// exit ;
65783: GO 65810
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
65785: LD_ADDR_EXP 32
65789: PUSH
65790: LD_EXP 32
65794: PPUSH
65795: LD_VAR 0 1
65799: PPUSH
65800: LD_VAR 0 2
65804: PPUSH
65805: CALL_OW 1
65809: ST_TO_ADDR
// end ;
65810: LD_VAR 0 3
65814: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
65815: LD_INT 0
65817: PPUSH
// if not mc_bases or not base or not teleports_exit then
65818: LD_EXP 14
65822: NOT
65823: PUSH
65824: LD_VAR 0 1
65828: NOT
65829: OR
65830: PUSH
65831: LD_VAR 0 2
65835: NOT
65836: OR
65837: IFFALSE 65841
// exit ;
65839: GO 65866
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
65841: LD_ADDR_EXP 49
65845: PUSH
65846: LD_EXP 49
65850: PPUSH
65851: LD_VAR 0 1
65855: PPUSH
65856: LD_VAR 0 2
65860: PPUSH
65861: CALL_OW 1
65865: ST_TO_ADDR
// end ;
65866: LD_VAR 0 3
65870: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
65871: LD_INT 0
65873: PPUSH
65874: PPUSH
65875: PPUSH
// if not mc_bases or not base or not ext_list then
65876: LD_EXP 14
65880: NOT
65881: PUSH
65882: LD_VAR 0 1
65886: NOT
65887: OR
65888: PUSH
65889: LD_VAR 0 5
65893: NOT
65894: OR
65895: IFFALSE 65899
// exit ;
65897: GO 66072
// tmp := GetFacExtXYD ( x , y , d ) ;
65899: LD_ADDR_VAR 0 8
65903: PUSH
65904: LD_VAR 0 2
65908: PPUSH
65909: LD_VAR 0 3
65913: PPUSH
65914: LD_VAR 0 4
65918: PPUSH
65919: CALL 38106 0 3
65923: ST_TO_ADDR
// if not tmp then
65924: LD_VAR 0 8
65928: NOT
65929: IFFALSE 65933
// exit ;
65931: GO 66072
// for i in tmp do
65933: LD_ADDR_VAR 0 7
65937: PUSH
65938: LD_VAR 0 8
65942: PUSH
65943: FOR_IN
65944: IFFALSE 66070
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
65946: LD_ADDR_EXP 19
65950: PUSH
65951: LD_EXP 19
65955: PPUSH
65956: LD_VAR 0 1
65960: PPUSH
65961: LD_EXP 19
65965: PUSH
65966: LD_VAR 0 1
65970: ARRAY
65971: PPUSH
65972: LD_EXP 19
65976: PUSH
65977: LD_VAR 0 1
65981: ARRAY
65982: PUSH
65983: LD_INT 1
65985: PLUS
65986: PPUSH
65987: LD_VAR 0 5
65991: PUSH
65992: LD_INT 1
65994: ARRAY
65995: PUSH
65996: LD_VAR 0 7
66000: PUSH
66001: LD_INT 1
66003: ARRAY
66004: PUSH
66005: LD_VAR 0 7
66009: PUSH
66010: LD_INT 2
66012: ARRAY
66013: PUSH
66014: LD_VAR 0 7
66018: PUSH
66019: LD_INT 3
66021: ARRAY
66022: PUSH
66023: EMPTY
66024: LIST
66025: LIST
66026: LIST
66027: LIST
66028: PPUSH
66029: CALL_OW 2
66033: PPUSH
66034: CALL_OW 1
66038: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
66039: LD_ADDR_VAR 0 5
66043: PUSH
66044: LD_VAR 0 5
66048: PPUSH
66049: LD_INT 1
66051: PPUSH
66052: CALL_OW 3
66056: ST_TO_ADDR
// if not ext_list then
66057: LD_VAR 0 5
66061: NOT
66062: IFFALSE 66068
// exit ;
66064: POP
66065: POP
66066: GO 66072
// end ;
66068: GO 65943
66070: POP
66071: POP
// end ;
66072: LD_VAR 0 6
66076: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
66077: LD_INT 0
66079: PPUSH
// if not mc_bases or not base or not weapon_list then
66080: LD_EXP 14
66084: NOT
66085: PUSH
66086: LD_VAR 0 1
66090: NOT
66091: OR
66092: PUSH
66093: LD_VAR 0 2
66097: NOT
66098: OR
66099: IFFALSE 66103
// exit ;
66101: GO 66128
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
66103: LD_ADDR_EXP 53
66107: PUSH
66108: LD_EXP 53
66112: PPUSH
66113: LD_VAR 0 1
66117: PPUSH
66118: LD_VAR 0 2
66122: PPUSH
66123: CALL_OW 1
66127: ST_TO_ADDR
// end ;
66128: LD_VAR 0 3
66132: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
66133: LD_INT 0
66135: PPUSH
// if not mc_bases or not base or not tech_list then
66136: LD_EXP 14
66140: NOT
66141: PUSH
66142: LD_VAR 0 1
66146: NOT
66147: OR
66148: PUSH
66149: LD_VAR 0 2
66153: NOT
66154: OR
66155: IFFALSE 66159
// exit ;
66157: GO 66184
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
66159: LD_ADDR_EXP 41
66163: PUSH
66164: LD_EXP 41
66168: PPUSH
66169: LD_VAR 0 1
66173: PPUSH
66174: LD_VAR 0 2
66178: PPUSH
66179: CALL_OW 1
66183: ST_TO_ADDR
// end ;
66184: LD_VAR 0 3
66188: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
66189: LD_INT 0
66191: PPUSH
// if not mc_bases or not parking_area or not base then
66192: LD_EXP 14
66196: NOT
66197: PUSH
66198: LD_VAR 0 2
66202: NOT
66203: OR
66204: PUSH
66205: LD_VAR 0 1
66209: NOT
66210: OR
66211: IFFALSE 66215
// exit ;
66213: GO 66240
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
66215: LD_ADDR_EXP 38
66219: PUSH
66220: LD_EXP 38
66224: PPUSH
66225: LD_VAR 0 1
66229: PPUSH
66230: LD_VAR 0 2
66234: PPUSH
66235: CALL_OW 1
66239: ST_TO_ADDR
// end ;
66240: LD_VAR 0 3
66244: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
66245: LD_INT 0
66247: PPUSH
// if not mc_bases or not base or not scan_area then
66248: LD_EXP 14
66252: NOT
66253: PUSH
66254: LD_VAR 0 1
66258: NOT
66259: OR
66260: PUSH
66261: LD_VAR 0 2
66265: NOT
66266: OR
66267: IFFALSE 66271
// exit ;
66269: GO 66296
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
66271: LD_ADDR_EXP 39
66275: PUSH
66276: LD_EXP 39
66280: PPUSH
66281: LD_VAR 0 1
66285: PPUSH
66286: LD_VAR 0 2
66290: PPUSH
66291: CALL_OW 1
66295: ST_TO_ADDR
// end ;
66296: LD_VAR 0 3
66300: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
66301: LD_INT 0
66303: PPUSH
66304: PPUSH
// if not mc_bases or not base then
66305: LD_EXP 14
66309: NOT
66310: PUSH
66311: LD_VAR 0 1
66315: NOT
66316: OR
66317: IFFALSE 66321
// exit ;
66319: GO 66385
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
66321: LD_ADDR_VAR 0 3
66325: PUSH
66326: LD_INT 1
66328: PUSH
66329: LD_INT 2
66331: PUSH
66332: LD_INT 3
66334: PUSH
66335: LD_INT 4
66337: PUSH
66338: LD_INT 11
66340: PUSH
66341: EMPTY
66342: LIST
66343: LIST
66344: LIST
66345: LIST
66346: LIST
66347: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
66348: LD_ADDR_EXP 41
66352: PUSH
66353: LD_EXP 41
66357: PPUSH
66358: LD_VAR 0 1
66362: PPUSH
66363: LD_EXP 41
66367: PUSH
66368: LD_VAR 0 1
66372: ARRAY
66373: PUSH
66374: LD_VAR 0 3
66378: DIFF
66379: PPUSH
66380: CALL_OW 1
66384: ST_TO_ADDR
// end ;
66385: LD_VAR 0 2
66389: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
66390: LD_INT 0
66392: PPUSH
// result := mc_vehicles [ base ] ;
66393: LD_ADDR_VAR 0 3
66397: PUSH
66398: LD_EXP 33
66402: PUSH
66403: LD_VAR 0 1
66407: ARRAY
66408: ST_TO_ADDR
// if onlyCombat then
66409: LD_VAR 0 2
66413: IFFALSE 66578
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
66415: LD_ADDR_VAR 0 3
66419: PUSH
66420: LD_VAR 0 3
66424: PUSH
66425: LD_VAR 0 3
66429: PPUSH
66430: LD_INT 2
66432: PUSH
66433: LD_INT 34
66435: PUSH
66436: LD_INT 12
66438: PUSH
66439: EMPTY
66440: LIST
66441: LIST
66442: PUSH
66443: LD_INT 34
66445: PUSH
66446: LD_INT 51
66448: PUSH
66449: EMPTY
66450: LIST
66451: LIST
66452: PUSH
66453: LD_INT 34
66455: PUSH
66456: LD_EXP 58
66460: PUSH
66461: EMPTY
66462: LIST
66463: LIST
66464: PUSH
66465: LD_INT 34
66467: PUSH
66468: LD_INT 32
66470: PUSH
66471: EMPTY
66472: LIST
66473: LIST
66474: PUSH
66475: LD_INT 34
66477: PUSH
66478: LD_INT 13
66480: PUSH
66481: EMPTY
66482: LIST
66483: LIST
66484: PUSH
66485: LD_INT 34
66487: PUSH
66488: LD_INT 52
66490: PUSH
66491: EMPTY
66492: LIST
66493: LIST
66494: PUSH
66495: LD_INT 34
66497: PUSH
66498: LD_INT 14
66500: PUSH
66501: EMPTY
66502: LIST
66503: LIST
66504: PUSH
66505: LD_INT 34
66507: PUSH
66508: LD_INT 53
66510: PUSH
66511: EMPTY
66512: LIST
66513: LIST
66514: PUSH
66515: LD_INT 34
66517: PUSH
66518: LD_EXP 57
66522: PUSH
66523: EMPTY
66524: LIST
66525: LIST
66526: PUSH
66527: LD_INT 34
66529: PUSH
66530: LD_INT 31
66532: PUSH
66533: EMPTY
66534: LIST
66535: LIST
66536: PUSH
66537: LD_INT 34
66539: PUSH
66540: LD_INT 48
66542: PUSH
66543: EMPTY
66544: LIST
66545: LIST
66546: PUSH
66547: LD_INT 34
66549: PUSH
66550: LD_INT 8
66552: PUSH
66553: EMPTY
66554: LIST
66555: LIST
66556: PUSH
66557: EMPTY
66558: LIST
66559: LIST
66560: LIST
66561: LIST
66562: LIST
66563: LIST
66564: LIST
66565: LIST
66566: LIST
66567: LIST
66568: LIST
66569: LIST
66570: LIST
66571: PPUSH
66572: CALL_OW 72
66576: DIFF
66577: ST_TO_ADDR
// end ; end_of_file
66578: LD_VAR 0 3
66582: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
66583: LD_INT 0
66585: PPUSH
66586: PPUSH
66587: PPUSH
// if not mc_bases or not skirmish then
66588: LD_EXP 14
66592: NOT
66593: PUSH
66594: LD_EXP 12
66598: NOT
66599: OR
66600: IFFALSE 66604
// exit ;
66602: GO 66769
// for i = 1 to mc_bases do
66604: LD_ADDR_VAR 0 4
66608: PUSH
66609: DOUBLE
66610: LD_INT 1
66612: DEC
66613: ST_TO_ADDR
66614: LD_EXP 14
66618: PUSH
66619: FOR_TO
66620: IFFALSE 66767
// begin if sci in mc_bases [ i ] then
66622: LD_VAR 0 2
66626: PUSH
66627: LD_EXP 14
66631: PUSH
66632: LD_VAR 0 4
66636: ARRAY
66637: IN
66638: IFFALSE 66765
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
66640: LD_ADDR_EXP 43
66644: PUSH
66645: LD_EXP 43
66649: PPUSH
66650: LD_VAR 0 4
66654: PUSH
66655: LD_EXP 43
66659: PUSH
66660: LD_VAR 0 4
66664: ARRAY
66665: PUSH
66666: LD_INT 1
66668: PLUS
66669: PUSH
66670: EMPTY
66671: LIST
66672: LIST
66673: PPUSH
66674: LD_VAR 0 1
66678: PPUSH
66679: CALL 9427 0 3
66683: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
66684: LD_ADDR_VAR 0 5
66688: PUSH
66689: LD_EXP 14
66693: PUSH
66694: LD_VAR 0 4
66698: ARRAY
66699: PPUSH
66700: LD_INT 2
66702: PUSH
66703: LD_INT 30
66705: PUSH
66706: LD_INT 0
66708: PUSH
66709: EMPTY
66710: LIST
66711: LIST
66712: PUSH
66713: LD_INT 30
66715: PUSH
66716: LD_INT 1
66718: PUSH
66719: EMPTY
66720: LIST
66721: LIST
66722: PUSH
66723: EMPTY
66724: LIST
66725: LIST
66726: LIST
66727: PPUSH
66728: CALL_OW 72
66732: PPUSH
66733: LD_VAR 0 1
66737: PPUSH
66738: CALL_OW 74
66742: ST_TO_ADDR
// if tmp then
66743: LD_VAR 0 5
66747: IFFALSE 66763
// ComStandNearbyBuilding ( ape , tmp ) ;
66749: LD_VAR 0 1
66753: PPUSH
66754: LD_VAR 0 5
66758: PPUSH
66759: CALL 6041 0 2
// break ;
66763: GO 66767
// end ; end ;
66765: GO 66619
66767: POP
66768: POP
// end ;
66769: LD_VAR 0 3
66773: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
66774: LD_INT 0
66776: PPUSH
66777: PPUSH
66778: PPUSH
// if not mc_bases or not skirmish then
66779: LD_EXP 14
66783: NOT
66784: PUSH
66785: LD_EXP 12
66789: NOT
66790: OR
66791: IFFALSE 66795
// exit ;
66793: GO 66884
// for i = 1 to mc_bases do
66795: LD_ADDR_VAR 0 4
66799: PUSH
66800: DOUBLE
66801: LD_INT 1
66803: DEC
66804: ST_TO_ADDR
66805: LD_EXP 14
66809: PUSH
66810: FOR_TO
66811: IFFALSE 66882
// begin if building in mc_busy_turret_list [ i ] then
66813: LD_VAR 0 1
66817: PUSH
66818: LD_EXP 24
66822: PUSH
66823: LD_VAR 0 4
66827: ARRAY
66828: IN
66829: IFFALSE 66880
// begin tmp := mc_busy_turret_list [ i ] diff building ;
66831: LD_ADDR_VAR 0 5
66835: PUSH
66836: LD_EXP 24
66840: PUSH
66841: LD_VAR 0 4
66845: ARRAY
66846: PUSH
66847: LD_VAR 0 1
66851: DIFF
66852: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
66853: LD_ADDR_EXP 24
66857: PUSH
66858: LD_EXP 24
66862: PPUSH
66863: LD_VAR 0 4
66867: PPUSH
66868: LD_VAR 0 5
66872: PPUSH
66873: CALL_OW 1
66877: ST_TO_ADDR
// break ;
66878: GO 66882
// end ; end ;
66880: GO 66810
66882: POP
66883: POP
// end ;
66884: LD_VAR 0 3
66888: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
66889: LD_INT 0
66891: PPUSH
66892: PPUSH
66893: PPUSH
// if not mc_bases or not skirmish then
66894: LD_EXP 14
66898: NOT
66899: PUSH
66900: LD_EXP 12
66904: NOT
66905: OR
66906: IFFALSE 66910
// exit ;
66908: GO 67109
// for i = 1 to mc_bases do
66910: LD_ADDR_VAR 0 5
66914: PUSH
66915: DOUBLE
66916: LD_INT 1
66918: DEC
66919: ST_TO_ADDR
66920: LD_EXP 14
66924: PUSH
66925: FOR_TO
66926: IFFALSE 67107
// if building in mc_bases [ i ] then
66928: LD_VAR 0 1
66932: PUSH
66933: LD_EXP 14
66937: PUSH
66938: LD_VAR 0 5
66942: ARRAY
66943: IN
66944: IFFALSE 67105
// begin tmp := mc_bases [ i ] diff building ;
66946: LD_ADDR_VAR 0 6
66950: PUSH
66951: LD_EXP 14
66955: PUSH
66956: LD_VAR 0 5
66960: ARRAY
66961: PUSH
66962: LD_VAR 0 1
66966: DIFF
66967: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
66968: LD_ADDR_EXP 14
66972: PUSH
66973: LD_EXP 14
66977: PPUSH
66978: LD_VAR 0 5
66982: PPUSH
66983: LD_VAR 0 6
66987: PPUSH
66988: CALL_OW 1
66992: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
66993: LD_VAR 0 1
66997: PUSH
66998: LD_EXP 22
67002: PUSH
67003: LD_VAR 0 5
67007: ARRAY
67008: IN
67009: IFFALSE 67048
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
67011: LD_ADDR_EXP 22
67015: PUSH
67016: LD_EXP 22
67020: PPUSH
67021: LD_VAR 0 5
67025: PPUSH
67026: LD_EXP 22
67030: PUSH
67031: LD_VAR 0 5
67035: ARRAY
67036: PUSH
67037: LD_VAR 0 1
67041: DIFF
67042: PPUSH
67043: CALL_OW 1
67047: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
67048: LD_VAR 0 1
67052: PUSH
67053: LD_EXP 23
67057: PUSH
67058: LD_VAR 0 5
67062: ARRAY
67063: IN
67064: IFFALSE 67103
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
67066: LD_ADDR_EXP 23
67070: PUSH
67071: LD_EXP 23
67075: PPUSH
67076: LD_VAR 0 5
67080: PPUSH
67081: LD_EXP 23
67085: PUSH
67086: LD_VAR 0 5
67090: ARRAY
67091: PUSH
67092: LD_VAR 0 1
67096: DIFF
67097: PPUSH
67098: CALL_OW 1
67102: ST_TO_ADDR
// break ;
67103: GO 67107
// end ;
67105: GO 66925
67107: POP
67108: POP
// end ;
67109: LD_VAR 0 4
67113: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
67114: LD_INT 0
67116: PPUSH
67117: PPUSH
67118: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
67119: LD_EXP 14
67123: NOT
67124: PUSH
67125: LD_EXP 12
67129: NOT
67130: OR
67131: PUSH
67132: LD_VAR 0 3
67136: PUSH
67137: LD_EXP 40
67141: IN
67142: NOT
67143: OR
67144: IFFALSE 67148
// exit ;
67146: GO 67271
// for i = 1 to mc_vehicles do
67148: LD_ADDR_VAR 0 6
67152: PUSH
67153: DOUBLE
67154: LD_INT 1
67156: DEC
67157: ST_TO_ADDR
67158: LD_EXP 33
67162: PUSH
67163: FOR_TO
67164: IFFALSE 67269
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
67166: LD_VAR 0 2
67170: PUSH
67171: LD_EXP 33
67175: PUSH
67176: LD_VAR 0 6
67180: ARRAY
67181: IN
67182: PUSH
67183: LD_VAR 0 1
67187: PUSH
67188: LD_EXP 33
67192: PUSH
67193: LD_VAR 0 6
67197: ARRAY
67198: IN
67199: OR
67200: IFFALSE 67267
// begin tmp := mc_vehicles [ i ] diff old ;
67202: LD_ADDR_VAR 0 7
67206: PUSH
67207: LD_EXP 33
67211: PUSH
67212: LD_VAR 0 6
67216: ARRAY
67217: PUSH
67218: LD_VAR 0 2
67222: DIFF
67223: ST_TO_ADDR
// tmp := tmp diff new ;
67224: LD_ADDR_VAR 0 7
67228: PUSH
67229: LD_VAR 0 7
67233: PUSH
67234: LD_VAR 0 1
67238: DIFF
67239: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
67240: LD_ADDR_EXP 33
67244: PUSH
67245: LD_EXP 33
67249: PPUSH
67250: LD_VAR 0 6
67254: PPUSH
67255: LD_VAR 0 7
67259: PPUSH
67260: CALL_OW 1
67264: ST_TO_ADDR
// break ;
67265: GO 67269
// end ;
67267: GO 67163
67269: POP
67270: POP
// end ;
67271: LD_VAR 0 5
67275: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
67276: LD_INT 0
67278: PPUSH
67279: PPUSH
67280: PPUSH
67281: PPUSH
// if not mc_bases or not skirmish then
67282: LD_EXP 14
67286: NOT
67287: PUSH
67288: LD_EXP 12
67292: NOT
67293: OR
67294: IFFALSE 67298
// exit ;
67296: GO 67675
// side := GetSide ( vehicle ) ;
67298: LD_ADDR_VAR 0 5
67302: PUSH
67303: LD_VAR 0 1
67307: PPUSH
67308: CALL_OW 255
67312: ST_TO_ADDR
// for i = 1 to mc_bases do
67313: LD_ADDR_VAR 0 4
67317: PUSH
67318: DOUBLE
67319: LD_INT 1
67321: DEC
67322: ST_TO_ADDR
67323: LD_EXP 14
67327: PUSH
67328: FOR_TO
67329: IFFALSE 67673
// begin if factory in mc_bases [ i ] then
67331: LD_VAR 0 2
67335: PUSH
67336: LD_EXP 14
67340: PUSH
67341: LD_VAR 0 4
67345: ARRAY
67346: IN
67347: IFFALSE 67671
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
67349: LD_EXP 36
67353: PUSH
67354: LD_VAR 0 4
67358: ARRAY
67359: PUSH
67360: LD_EXP 25
67364: PUSH
67365: LD_VAR 0 4
67369: ARRAY
67370: LESS
67371: PUSH
67372: LD_VAR 0 1
67376: PPUSH
67377: CALL_OW 264
67381: PUSH
67382: LD_INT 31
67384: PUSH
67385: LD_INT 32
67387: PUSH
67388: LD_INT 51
67390: PUSH
67391: LD_EXP 58
67395: PUSH
67396: LD_INT 12
67398: PUSH
67399: LD_INT 30
67401: PUSH
67402: LD_EXP 57
67406: PUSH
67407: LD_INT 11
67409: PUSH
67410: LD_INT 53
67412: PUSH
67413: LD_INT 14
67415: PUSH
67416: LD_EXP 61
67420: PUSH
67421: LD_INT 29
67423: PUSH
67424: LD_EXP 59
67428: PUSH
67429: LD_INT 13
67431: PUSH
67432: LD_INT 52
67434: PUSH
67435: LD_INT 48
67437: PUSH
67438: LD_INT 8
67440: PUSH
67441: EMPTY
67442: LIST
67443: LIST
67444: LIST
67445: LIST
67446: LIST
67447: LIST
67448: LIST
67449: LIST
67450: LIST
67451: LIST
67452: LIST
67453: LIST
67454: LIST
67455: LIST
67456: LIST
67457: LIST
67458: LIST
67459: IN
67460: NOT
67461: AND
67462: IFFALSE 67510
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
67464: LD_ADDR_EXP 36
67468: PUSH
67469: LD_EXP 36
67473: PPUSH
67474: LD_VAR 0 4
67478: PUSH
67479: LD_EXP 36
67483: PUSH
67484: LD_VAR 0 4
67488: ARRAY
67489: PUSH
67490: LD_INT 1
67492: PLUS
67493: PUSH
67494: EMPTY
67495: LIST
67496: LIST
67497: PPUSH
67498: LD_VAR 0 1
67502: PPUSH
67503: CALL 9427 0 3
67507: ST_TO_ADDR
67508: GO 67554
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
67510: LD_ADDR_EXP 33
67514: PUSH
67515: LD_EXP 33
67519: PPUSH
67520: LD_VAR 0 4
67524: PUSH
67525: LD_EXP 33
67529: PUSH
67530: LD_VAR 0 4
67534: ARRAY
67535: PUSH
67536: LD_INT 1
67538: PLUS
67539: PUSH
67540: EMPTY
67541: LIST
67542: LIST
67543: PPUSH
67544: LD_VAR 0 1
67548: PPUSH
67549: CALL 9427 0 3
67553: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
67554: LD_VAR 0 1
67558: PPUSH
67559: CALL_OW 263
67563: PUSH
67564: LD_INT 2
67566: EQUAL
67567: IFFALSE 67587
// begin repeat wait ( 0 0$1 ) ;
67569: LD_INT 35
67571: PPUSH
67572: CALL_OW 67
// until IsControledBy ( vehicle ) ;
67576: LD_VAR 0 1
67580: PPUSH
67581: CALL_OW 312
67585: IFFALSE 67569
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
67587: LD_VAR 0 1
67591: PPUSH
67592: LD_EXP 38
67596: PUSH
67597: LD_VAR 0 4
67601: ARRAY
67602: PPUSH
67603: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
67607: LD_VAR 0 1
67611: PPUSH
67612: CALL_OW 263
67616: PUSH
67617: LD_INT 1
67619: NONEQUAL
67620: IFFALSE 67624
// break ;
67622: GO 67673
// repeat wait ( 0 0$1 ) ;
67624: LD_INT 35
67626: PPUSH
67627: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
67631: LD_VAR 0 1
67635: PPUSH
67636: LD_EXP 38
67640: PUSH
67641: LD_VAR 0 4
67645: ARRAY
67646: PPUSH
67647: CALL_OW 308
67651: IFFALSE 67624
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
67653: LD_VAR 0 1
67657: PPUSH
67658: CALL_OW 311
67662: PPUSH
67663: CALL_OW 121
// exit ;
67667: POP
67668: POP
67669: GO 67675
// end ; end ;
67671: GO 67328
67673: POP
67674: POP
// end ;
67675: LD_VAR 0 3
67679: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
67680: LD_INT 0
67682: PPUSH
67683: PPUSH
67684: PPUSH
67685: PPUSH
// if not mc_bases or not skirmish then
67686: LD_EXP 14
67690: NOT
67691: PUSH
67692: LD_EXP 12
67696: NOT
67697: OR
67698: IFFALSE 67702
// exit ;
67700: GO 68055
// repeat wait ( 0 0$1 ) ;
67702: LD_INT 35
67704: PPUSH
67705: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
67709: LD_VAR 0 2
67713: PPUSH
67714: LD_VAR 0 3
67718: PPUSH
67719: CALL_OW 284
67723: IFFALSE 67702
// if GetResourceTypeXY ( x , y ) = mat_artefact then
67725: LD_VAR 0 2
67729: PPUSH
67730: LD_VAR 0 3
67734: PPUSH
67735: CALL_OW 283
67739: PUSH
67740: LD_INT 4
67742: EQUAL
67743: IFFALSE 67747
// exit ;
67745: GO 68055
// for i = 1 to mc_bases do
67747: LD_ADDR_VAR 0 7
67751: PUSH
67752: DOUBLE
67753: LD_INT 1
67755: DEC
67756: ST_TO_ADDR
67757: LD_EXP 14
67761: PUSH
67762: FOR_TO
67763: IFFALSE 68053
// begin if mc_crates_area [ i ] then
67765: LD_EXP 32
67769: PUSH
67770: LD_VAR 0 7
67774: ARRAY
67775: IFFALSE 67886
// for j in mc_crates_area [ i ] do
67777: LD_ADDR_VAR 0 8
67781: PUSH
67782: LD_EXP 32
67786: PUSH
67787: LD_VAR 0 7
67791: ARRAY
67792: PUSH
67793: FOR_IN
67794: IFFALSE 67884
// if InArea ( x , y , j ) then
67796: LD_VAR 0 2
67800: PPUSH
67801: LD_VAR 0 3
67805: PPUSH
67806: LD_VAR 0 8
67810: PPUSH
67811: CALL_OW 309
67815: IFFALSE 67882
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
67817: LD_ADDR_EXP 30
67821: PUSH
67822: LD_EXP 30
67826: PPUSH
67827: LD_VAR 0 7
67831: PUSH
67832: LD_EXP 30
67836: PUSH
67837: LD_VAR 0 7
67841: ARRAY
67842: PUSH
67843: LD_INT 1
67845: PLUS
67846: PUSH
67847: EMPTY
67848: LIST
67849: LIST
67850: PPUSH
67851: LD_VAR 0 4
67855: PUSH
67856: LD_VAR 0 2
67860: PUSH
67861: LD_VAR 0 3
67865: PUSH
67866: EMPTY
67867: LIST
67868: LIST
67869: LIST
67870: PPUSH
67871: CALL 9427 0 3
67875: ST_TO_ADDR
// exit ;
67876: POP
67877: POP
67878: POP
67879: POP
67880: GO 68055
// end ;
67882: GO 67793
67884: POP
67885: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67886: LD_ADDR_VAR 0 9
67890: PUSH
67891: LD_EXP 14
67895: PUSH
67896: LD_VAR 0 7
67900: ARRAY
67901: PPUSH
67902: LD_INT 2
67904: PUSH
67905: LD_INT 30
67907: PUSH
67908: LD_INT 0
67910: PUSH
67911: EMPTY
67912: LIST
67913: LIST
67914: PUSH
67915: LD_INT 30
67917: PUSH
67918: LD_INT 1
67920: PUSH
67921: EMPTY
67922: LIST
67923: LIST
67924: PUSH
67925: EMPTY
67926: LIST
67927: LIST
67928: LIST
67929: PPUSH
67930: CALL_OW 72
67934: ST_TO_ADDR
// if not depot then
67935: LD_VAR 0 9
67939: NOT
67940: IFFALSE 67944
// continue ;
67942: GO 67762
// for j in depot do
67944: LD_ADDR_VAR 0 8
67948: PUSH
67949: LD_VAR 0 9
67953: PUSH
67954: FOR_IN
67955: IFFALSE 68049
// if GetDistUnitXY ( j , x , y ) < 30 then
67957: LD_VAR 0 8
67961: PPUSH
67962: LD_VAR 0 2
67966: PPUSH
67967: LD_VAR 0 3
67971: PPUSH
67972: CALL_OW 297
67976: PUSH
67977: LD_INT 30
67979: LESS
67980: IFFALSE 68047
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
67982: LD_ADDR_EXP 30
67986: PUSH
67987: LD_EXP 30
67991: PPUSH
67992: LD_VAR 0 7
67996: PUSH
67997: LD_EXP 30
68001: PUSH
68002: LD_VAR 0 7
68006: ARRAY
68007: PUSH
68008: LD_INT 1
68010: PLUS
68011: PUSH
68012: EMPTY
68013: LIST
68014: LIST
68015: PPUSH
68016: LD_VAR 0 4
68020: PUSH
68021: LD_VAR 0 2
68025: PUSH
68026: LD_VAR 0 3
68030: PUSH
68031: EMPTY
68032: LIST
68033: LIST
68034: LIST
68035: PPUSH
68036: CALL 9427 0 3
68040: ST_TO_ADDR
// exit ;
68041: POP
68042: POP
68043: POP
68044: POP
68045: GO 68055
// end ;
68047: GO 67954
68049: POP
68050: POP
// end ;
68051: GO 67762
68053: POP
68054: POP
// end ;
68055: LD_VAR 0 6
68059: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
68060: LD_INT 0
68062: PPUSH
68063: PPUSH
68064: PPUSH
68065: PPUSH
// if not mc_bases or not skirmish then
68066: LD_EXP 14
68070: NOT
68071: PUSH
68072: LD_EXP 12
68076: NOT
68077: OR
68078: IFFALSE 68082
// exit ;
68080: GO 68359
// side := GetSide ( lab ) ;
68082: LD_ADDR_VAR 0 4
68086: PUSH
68087: LD_VAR 0 2
68091: PPUSH
68092: CALL_OW 255
68096: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
68097: LD_VAR 0 4
68101: PUSH
68102: LD_EXP 40
68106: IN
68107: NOT
68108: PUSH
68109: LD_EXP 41
68113: NOT
68114: OR
68115: PUSH
68116: LD_EXP 14
68120: NOT
68121: OR
68122: IFFALSE 68126
// exit ;
68124: GO 68359
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
68126: LD_ADDR_EXP 41
68130: PUSH
68131: LD_EXP 41
68135: PPUSH
68136: LD_VAR 0 4
68140: PPUSH
68141: LD_EXP 41
68145: PUSH
68146: LD_VAR 0 4
68150: ARRAY
68151: PUSH
68152: LD_VAR 0 1
68156: DIFF
68157: PPUSH
68158: CALL_OW 1
68162: ST_TO_ADDR
// for i = 1 to mc_bases do
68163: LD_ADDR_VAR 0 5
68167: PUSH
68168: DOUBLE
68169: LD_INT 1
68171: DEC
68172: ST_TO_ADDR
68173: LD_EXP 14
68177: PUSH
68178: FOR_TO
68179: IFFALSE 68357
// begin if lab in mc_bases [ i ] then
68181: LD_VAR 0 2
68185: PUSH
68186: LD_EXP 14
68190: PUSH
68191: LD_VAR 0 5
68195: ARRAY
68196: IN
68197: IFFALSE 68355
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
68199: LD_VAR 0 1
68203: PUSH
68204: LD_INT 11
68206: PUSH
68207: LD_INT 4
68209: PUSH
68210: LD_INT 3
68212: PUSH
68213: LD_INT 2
68215: PUSH
68216: EMPTY
68217: LIST
68218: LIST
68219: LIST
68220: LIST
68221: IN
68222: PUSH
68223: LD_EXP 44
68227: PUSH
68228: LD_VAR 0 5
68232: ARRAY
68233: AND
68234: IFFALSE 68355
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
68236: LD_ADDR_VAR 0 6
68240: PUSH
68241: LD_EXP 44
68245: PUSH
68246: LD_VAR 0 5
68250: ARRAY
68251: PUSH
68252: LD_INT 1
68254: ARRAY
68255: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
68256: LD_ADDR_EXP 44
68260: PUSH
68261: LD_EXP 44
68265: PPUSH
68266: LD_VAR 0 5
68270: PPUSH
68271: EMPTY
68272: PPUSH
68273: CALL_OW 1
68277: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
68278: LD_VAR 0 6
68282: PPUSH
68283: LD_INT 0
68285: PPUSH
68286: CALL_OW 109
// ComExitBuilding ( tmp ) ;
68290: LD_VAR 0 6
68294: PPUSH
68295: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
68299: LD_ADDR_EXP 43
68303: PUSH
68304: LD_EXP 43
68308: PPUSH
68309: LD_VAR 0 5
68313: PPUSH
68314: LD_EXP 43
68318: PUSH
68319: LD_VAR 0 5
68323: ARRAY
68324: PPUSH
68325: LD_INT 1
68327: PPUSH
68328: LD_VAR 0 6
68332: PPUSH
68333: CALL_OW 2
68337: PPUSH
68338: CALL_OW 1
68342: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
68343: LD_VAR 0 5
68347: PPUSH
68348: LD_INT 112
68350: PPUSH
68351: CALL 45371 0 2
// end ; end ; end ;
68355: GO 68178
68357: POP
68358: POP
// end ;
68359: LD_VAR 0 3
68363: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
68364: LD_INT 0
68366: PPUSH
68367: PPUSH
68368: PPUSH
68369: PPUSH
68370: PPUSH
68371: PPUSH
68372: PPUSH
68373: PPUSH
// if not mc_bases or not skirmish then
68374: LD_EXP 14
68378: NOT
68379: PUSH
68380: LD_EXP 12
68384: NOT
68385: OR
68386: IFFALSE 68390
// exit ;
68388: GO 69761
// for i = 1 to mc_bases do
68390: LD_ADDR_VAR 0 3
68394: PUSH
68395: DOUBLE
68396: LD_INT 1
68398: DEC
68399: ST_TO_ADDR
68400: LD_EXP 14
68404: PUSH
68405: FOR_TO
68406: IFFALSE 69759
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
68408: LD_VAR 0 1
68412: PUSH
68413: LD_EXP 14
68417: PUSH
68418: LD_VAR 0 3
68422: ARRAY
68423: IN
68424: PUSH
68425: LD_VAR 0 1
68429: PUSH
68430: LD_EXP 21
68434: PUSH
68435: LD_VAR 0 3
68439: ARRAY
68440: IN
68441: OR
68442: PUSH
68443: LD_VAR 0 1
68447: PUSH
68448: LD_EXP 36
68452: PUSH
68453: LD_VAR 0 3
68457: ARRAY
68458: IN
68459: OR
68460: PUSH
68461: LD_VAR 0 1
68465: PUSH
68466: LD_EXP 33
68470: PUSH
68471: LD_VAR 0 3
68475: ARRAY
68476: IN
68477: OR
68478: PUSH
68479: LD_VAR 0 1
68483: PUSH
68484: LD_EXP 43
68488: PUSH
68489: LD_VAR 0 3
68493: ARRAY
68494: IN
68495: OR
68496: PUSH
68497: LD_VAR 0 1
68501: PUSH
68502: LD_EXP 44
68506: PUSH
68507: LD_VAR 0 3
68511: ARRAY
68512: IN
68513: OR
68514: IFFALSE 69757
// begin if un in mc_ape [ i ] then
68516: LD_VAR 0 1
68520: PUSH
68521: LD_EXP 43
68525: PUSH
68526: LD_VAR 0 3
68530: ARRAY
68531: IN
68532: IFFALSE 68571
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
68534: LD_ADDR_EXP 43
68538: PUSH
68539: LD_EXP 43
68543: PPUSH
68544: LD_VAR 0 3
68548: PPUSH
68549: LD_EXP 43
68553: PUSH
68554: LD_VAR 0 3
68558: ARRAY
68559: PUSH
68560: LD_VAR 0 1
68564: DIFF
68565: PPUSH
68566: CALL_OW 1
68570: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
68571: LD_VAR 0 1
68575: PUSH
68576: LD_EXP 44
68580: PUSH
68581: LD_VAR 0 3
68585: ARRAY
68586: IN
68587: IFFALSE 68611
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
68589: LD_ADDR_EXP 44
68593: PUSH
68594: LD_EXP 44
68598: PPUSH
68599: LD_VAR 0 3
68603: PPUSH
68604: EMPTY
68605: PPUSH
68606: CALL_OW 1
68610: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
68611: LD_VAR 0 1
68615: PPUSH
68616: CALL_OW 247
68620: PUSH
68621: LD_INT 2
68623: EQUAL
68624: PUSH
68625: LD_VAR 0 1
68629: PPUSH
68630: CALL_OW 110
68634: PUSH
68635: LD_INT 20
68637: EQUAL
68638: PUSH
68639: LD_VAR 0 1
68643: PUSH
68644: LD_EXP 36
68648: PUSH
68649: LD_VAR 0 3
68653: ARRAY
68654: IN
68655: OR
68656: PUSH
68657: LD_VAR 0 1
68661: PPUSH
68662: CALL_OW 264
68666: PUSH
68667: LD_INT 12
68669: PUSH
68670: LD_INT 51
68672: PUSH
68673: LD_EXP 58
68677: PUSH
68678: LD_INT 32
68680: PUSH
68681: LD_INT 13
68683: PUSH
68684: LD_INT 52
68686: PUSH
68687: LD_INT 31
68689: PUSH
68690: EMPTY
68691: LIST
68692: LIST
68693: LIST
68694: LIST
68695: LIST
68696: LIST
68697: LIST
68698: IN
68699: OR
68700: AND
68701: IFFALSE 69009
// begin if un in mc_defender [ i ] then
68703: LD_VAR 0 1
68707: PUSH
68708: LD_EXP 36
68712: PUSH
68713: LD_VAR 0 3
68717: ARRAY
68718: IN
68719: IFFALSE 68758
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
68721: LD_ADDR_EXP 36
68725: PUSH
68726: LD_EXP 36
68730: PPUSH
68731: LD_VAR 0 3
68735: PPUSH
68736: LD_EXP 36
68740: PUSH
68741: LD_VAR 0 3
68745: ARRAY
68746: PUSH
68747: LD_VAR 0 1
68751: DIFF
68752: PPUSH
68753: CALL_OW 1
68757: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
68758: LD_ADDR_VAR 0 8
68762: PUSH
68763: LD_VAR 0 3
68767: PPUSH
68768: LD_INT 3
68770: PPUSH
68771: CALL 65427 0 2
68775: ST_TO_ADDR
// if fac then
68776: LD_VAR 0 8
68780: IFFALSE 69009
// begin for j in fac do
68782: LD_ADDR_VAR 0 4
68786: PUSH
68787: LD_VAR 0 8
68791: PUSH
68792: FOR_IN
68793: IFFALSE 69007
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
68795: LD_ADDR_VAR 0 9
68799: PUSH
68800: LD_VAR 0 8
68804: PPUSH
68805: LD_VAR 0 1
68809: PPUSH
68810: CALL_OW 265
68814: PPUSH
68815: LD_VAR 0 1
68819: PPUSH
68820: CALL_OW 262
68824: PPUSH
68825: LD_VAR 0 1
68829: PPUSH
68830: CALL_OW 263
68834: PPUSH
68835: LD_VAR 0 1
68839: PPUSH
68840: CALL_OW 264
68844: PPUSH
68845: CALL 6959 0 5
68849: ST_TO_ADDR
// if components then
68850: LD_VAR 0 9
68854: IFFALSE 69005
// begin if GetWeapon ( un ) = ar_control_tower then
68856: LD_VAR 0 1
68860: PPUSH
68861: CALL_OW 264
68865: PUSH
68866: LD_INT 31
68868: EQUAL
68869: IFFALSE 68986
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
68871: LD_VAR 0 1
68875: PPUSH
68876: CALL_OW 311
68880: PPUSH
68881: LD_INT 0
68883: PPUSH
68884: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
68888: LD_ADDR_EXP 54
68892: PUSH
68893: LD_EXP 54
68897: PPUSH
68898: LD_VAR 0 3
68902: PPUSH
68903: LD_EXP 54
68907: PUSH
68908: LD_VAR 0 3
68912: ARRAY
68913: PUSH
68914: LD_VAR 0 1
68918: PPUSH
68919: CALL_OW 311
68923: DIFF
68924: PPUSH
68925: CALL_OW 1
68929: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
68930: LD_ADDR_VAR 0 7
68934: PUSH
68935: LD_EXP 35
68939: PUSH
68940: LD_VAR 0 3
68944: ARRAY
68945: PPUSH
68946: LD_INT 1
68948: PPUSH
68949: LD_VAR 0 9
68953: PPUSH
68954: CALL_OW 2
68958: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
68959: LD_ADDR_EXP 35
68963: PUSH
68964: LD_EXP 35
68968: PPUSH
68969: LD_VAR 0 3
68973: PPUSH
68974: LD_VAR 0 7
68978: PPUSH
68979: CALL_OW 1
68983: ST_TO_ADDR
// end else
68984: GO 69003
// MC_InsertProduceList ( i , [ components ] ) ;
68986: LD_VAR 0 3
68990: PPUSH
68991: LD_VAR 0 9
68995: PUSH
68996: EMPTY
68997: LIST
68998: PPUSH
68999: CALL 64972 0 2
// break ;
69003: GO 69007
// end ; end ;
69005: GO 68792
69007: POP
69008: POP
// end ; end ; if GetType ( un ) = unit_building then
69009: LD_VAR 0 1
69013: PPUSH
69014: CALL_OW 247
69018: PUSH
69019: LD_INT 3
69021: EQUAL
69022: IFFALSE 69425
// begin btype := GetBType ( un ) ;
69024: LD_ADDR_VAR 0 5
69028: PUSH
69029: LD_VAR 0 1
69033: PPUSH
69034: CALL_OW 266
69038: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
69039: LD_VAR 0 5
69043: PUSH
69044: LD_INT 29
69046: PUSH
69047: LD_INT 30
69049: PUSH
69050: EMPTY
69051: LIST
69052: LIST
69053: IN
69054: IFFALSE 69127
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
69056: LD_VAR 0 1
69060: PPUSH
69061: CALL_OW 250
69065: PPUSH
69066: LD_VAR 0 1
69070: PPUSH
69071: CALL_OW 251
69075: PPUSH
69076: LD_VAR 0 1
69080: PPUSH
69081: CALL_OW 255
69085: PPUSH
69086: CALL_OW 440
69090: NOT
69091: IFFALSE 69127
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
69093: LD_VAR 0 1
69097: PPUSH
69098: CALL_OW 250
69102: PPUSH
69103: LD_VAR 0 1
69107: PPUSH
69108: CALL_OW 251
69112: PPUSH
69113: LD_VAR 0 1
69117: PPUSH
69118: CALL_OW 255
69122: PPUSH
69123: CALL_OW 441
// end ; if btype = b_warehouse then
69127: LD_VAR 0 5
69131: PUSH
69132: LD_INT 1
69134: EQUAL
69135: IFFALSE 69153
// begin btype := b_depot ;
69137: LD_ADDR_VAR 0 5
69141: PUSH
69142: LD_INT 0
69144: ST_TO_ADDR
// pos := 1 ;
69145: LD_ADDR_VAR 0 6
69149: PUSH
69150: LD_INT 1
69152: ST_TO_ADDR
// end ; if btype = b_factory then
69153: LD_VAR 0 5
69157: PUSH
69158: LD_INT 3
69160: EQUAL
69161: IFFALSE 69179
// begin btype := b_workshop ;
69163: LD_ADDR_VAR 0 5
69167: PUSH
69168: LD_INT 2
69170: ST_TO_ADDR
// pos := 1 ;
69171: LD_ADDR_VAR 0 6
69175: PUSH
69176: LD_INT 1
69178: ST_TO_ADDR
// end ; if btype = b_barracks then
69179: LD_VAR 0 5
69183: PUSH
69184: LD_INT 5
69186: EQUAL
69187: IFFALSE 69197
// btype := b_armoury ;
69189: LD_ADDR_VAR 0 5
69193: PUSH
69194: LD_INT 4
69196: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
69197: LD_VAR 0 5
69201: PUSH
69202: LD_INT 7
69204: PUSH
69205: LD_INT 8
69207: PUSH
69208: EMPTY
69209: LIST
69210: LIST
69211: IN
69212: IFFALSE 69222
// btype := b_lab ;
69214: LD_ADDR_VAR 0 5
69218: PUSH
69219: LD_INT 6
69221: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
69222: LD_ADDR_EXP 19
69226: PUSH
69227: LD_EXP 19
69231: PPUSH
69232: LD_VAR 0 3
69236: PUSH
69237: LD_EXP 19
69241: PUSH
69242: LD_VAR 0 3
69246: ARRAY
69247: PUSH
69248: LD_INT 1
69250: PLUS
69251: PUSH
69252: EMPTY
69253: LIST
69254: LIST
69255: PPUSH
69256: LD_VAR 0 5
69260: PUSH
69261: LD_VAR 0 1
69265: PPUSH
69266: CALL_OW 250
69270: PUSH
69271: LD_VAR 0 1
69275: PPUSH
69276: CALL_OW 251
69280: PUSH
69281: LD_VAR 0 1
69285: PPUSH
69286: CALL_OW 254
69290: PUSH
69291: EMPTY
69292: LIST
69293: LIST
69294: LIST
69295: LIST
69296: PPUSH
69297: CALL 9427 0 3
69301: ST_TO_ADDR
// if pos = 1 then
69302: LD_VAR 0 6
69306: PUSH
69307: LD_INT 1
69309: EQUAL
69310: IFFALSE 69425
// begin tmp := mc_build_list [ i ] ;
69312: LD_ADDR_VAR 0 7
69316: PUSH
69317: LD_EXP 19
69321: PUSH
69322: LD_VAR 0 3
69326: ARRAY
69327: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
69328: LD_VAR 0 7
69332: PPUSH
69333: LD_INT 2
69335: PUSH
69336: LD_INT 30
69338: PUSH
69339: LD_INT 0
69341: PUSH
69342: EMPTY
69343: LIST
69344: LIST
69345: PUSH
69346: LD_INT 30
69348: PUSH
69349: LD_INT 1
69351: PUSH
69352: EMPTY
69353: LIST
69354: LIST
69355: PUSH
69356: EMPTY
69357: LIST
69358: LIST
69359: LIST
69360: PPUSH
69361: CALL_OW 72
69365: IFFALSE 69375
// pos := 2 ;
69367: LD_ADDR_VAR 0 6
69371: PUSH
69372: LD_INT 2
69374: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
69375: LD_ADDR_VAR 0 7
69379: PUSH
69380: LD_VAR 0 7
69384: PPUSH
69385: LD_VAR 0 6
69389: PPUSH
69390: LD_VAR 0 7
69394: PPUSH
69395: CALL 9753 0 3
69399: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
69400: LD_ADDR_EXP 19
69404: PUSH
69405: LD_EXP 19
69409: PPUSH
69410: LD_VAR 0 3
69414: PPUSH
69415: LD_VAR 0 7
69419: PPUSH
69420: CALL_OW 1
69424: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
69425: LD_VAR 0 1
69429: PUSH
69430: LD_EXP 14
69434: PUSH
69435: LD_VAR 0 3
69439: ARRAY
69440: IN
69441: IFFALSE 69480
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
69443: LD_ADDR_EXP 14
69447: PUSH
69448: LD_EXP 14
69452: PPUSH
69453: LD_VAR 0 3
69457: PPUSH
69458: LD_EXP 14
69462: PUSH
69463: LD_VAR 0 3
69467: ARRAY
69468: PUSH
69469: LD_VAR 0 1
69473: DIFF
69474: PPUSH
69475: CALL_OW 1
69479: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
69480: LD_VAR 0 1
69484: PUSH
69485: LD_EXP 21
69489: PUSH
69490: LD_VAR 0 3
69494: ARRAY
69495: IN
69496: IFFALSE 69535
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
69498: LD_ADDR_EXP 21
69502: PUSH
69503: LD_EXP 21
69507: PPUSH
69508: LD_VAR 0 3
69512: PPUSH
69513: LD_EXP 21
69517: PUSH
69518: LD_VAR 0 3
69522: ARRAY
69523: PUSH
69524: LD_VAR 0 1
69528: DIFF
69529: PPUSH
69530: CALL_OW 1
69534: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
69535: LD_VAR 0 1
69539: PUSH
69540: LD_EXP 33
69544: PUSH
69545: LD_VAR 0 3
69549: ARRAY
69550: IN
69551: IFFALSE 69590
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
69553: LD_ADDR_EXP 33
69557: PUSH
69558: LD_EXP 33
69562: PPUSH
69563: LD_VAR 0 3
69567: PPUSH
69568: LD_EXP 33
69572: PUSH
69573: LD_VAR 0 3
69577: ARRAY
69578: PUSH
69579: LD_VAR 0 1
69583: DIFF
69584: PPUSH
69585: CALL_OW 1
69589: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
69590: LD_VAR 0 1
69594: PUSH
69595: LD_EXP 36
69599: PUSH
69600: LD_VAR 0 3
69604: ARRAY
69605: IN
69606: IFFALSE 69645
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
69608: LD_ADDR_EXP 36
69612: PUSH
69613: LD_EXP 36
69617: PPUSH
69618: LD_VAR 0 3
69622: PPUSH
69623: LD_EXP 36
69627: PUSH
69628: LD_VAR 0 3
69632: ARRAY
69633: PUSH
69634: LD_VAR 0 1
69638: DIFF
69639: PPUSH
69640: CALL_OW 1
69644: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
69645: LD_VAR 0 1
69649: PUSH
69650: LD_EXP 23
69654: PUSH
69655: LD_VAR 0 3
69659: ARRAY
69660: IN
69661: IFFALSE 69700
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
69663: LD_ADDR_EXP 23
69667: PUSH
69668: LD_EXP 23
69672: PPUSH
69673: LD_VAR 0 3
69677: PPUSH
69678: LD_EXP 23
69682: PUSH
69683: LD_VAR 0 3
69687: ARRAY
69688: PUSH
69689: LD_VAR 0 1
69693: DIFF
69694: PPUSH
69695: CALL_OW 1
69699: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
69700: LD_VAR 0 1
69704: PUSH
69705: LD_EXP 22
69709: PUSH
69710: LD_VAR 0 3
69714: ARRAY
69715: IN
69716: IFFALSE 69755
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
69718: LD_ADDR_EXP 22
69722: PUSH
69723: LD_EXP 22
69727: PPUSH
69728: LD_VAR 0 3
69732: PPUSH
69733: LD_EXP 22
69737: PUSH
69738: LD_VAR 0 3
69742: ARRAY
69743: PUSH
69744: LD_VAR 0 1
69748: DIFF
69749: PPUSH
69750: CALL_OW 1
69754: ST_TO_ADDR
// end ; break ;
69755: GO 69759
// end ;
69757: GO 68405
69759: POP
69760: POP
// end ;
69761: LD_VAR 0 2
69765: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
69766: LD_INT 0
69768: PPUSH
69769: PPUSH
69770: PPUSH
// if not mc_bases or not skirmish then
69771: LD_EXP 14
69775: NOT
69776: PUSH
69777: LD_EXP 12
69781: NOT
69782: OR
69783: IFFALSE 69787
// exit ;
69785: GO 70002
// for i = 1 to mc_bases do
69787: LD_ADDR_VAR 0 3
69791: PUSH
69792: DOUBLE
69793: LD_INT 1
69795: DEC
69796: ST_TO_ADDR
69797: LD_EXP 14
69801: PUSH
69802: FOR_TO
69803: IFFALSE 70000
// begin if building in mc_construct_list [ i ] then
69805: LD_VAR 0 1
69809: PUSH
69810: LD_EXP 21
69814: PUSH
69815: LD_VAR 0 3
69819: ARRAY
69820: IN
69821: IFFALSE 69998
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
69823: LD_ADDR_EXP 21
69827: PUSH
69828: LD_EXP 21
69832: PPUSH
69833: LD_VAR 0 3
69837: PPUSH
69838: LD_EXP 21
69842: PUSH
69843: LD_VAR 0 3
69847: ARRAY
69848: PUSH
69849: LD_VAR 0 1
69853: DIFF
69854: PPUSH
69855: CALL_OW 1
69859: ST_TO_ADDR
// if building in mc_lab [ i ] then
69860: LD_VAR 0 1
69864: PUSH
69865: LD_EXP 47
69869: PUSH
69870: LD_VAR 0 3
69874: ARRAY
69875: IN
69876: IFFALSE 69931
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
69878: LD_ADDR_EXP 48
69882: PUSH
69883: LD_EXP 48
69887: PPUSH
69888: LD_VAR 0 3
69892: PPUSH
69893: LD_EXP 48
69897: PUSH
69898: LD_VAR 0 3
69902: ARRAY
69903: PPUSH
69904: LD_INT 1
69906: PPUSH
69907: LD_EXP 48
69911: PUSH
69912: LD_VAR 0 3
69916: ARRAY
69917: PPUSH
69918: LD_INT 0
69920: PPUSH
69921: CALL 8845 0 4
69925: PPUSH
69926: CALL_OW 1
69930: ST_TO_ADDR
// if not building in mc_bases [ i ] then
69931: LD_VAR 0 1
69935: PUSH
69936: LD_EXP 14
69940: PUSH
69941: LD_VAR 0 3
69945: ARRAY
69946: IN
69947: NOT
69948: IFFALSE 69994
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
69950: LD_ADDR_EXP 14
69954: PUSH
69955: LD_EXP 14
69959: PPUSH
69960: LD_VAR 0 3
69964: PUSH
69965: LD_EXP 14
69969: PUSH
69970: LD_VAR 0 3
69974: ARRAY
69975: PUSH
69976: LD_INT 1
69978: PLUS
69979: PUSH
69980: EMPTY
69981: LIST
69982: LIST
69983: PPUSH
69984: LD_VAR 0 1
69988: PPUSH
69989: CALL 9427 0 3
69993: ST_TO_ADDR
// exit ;
69994: POP
69995: POP
69996: GO 70002
// end ; end ;
69998: GO 69802
70000: POP
70001: POP
// end ;
70002: LD_VAR 0 2
70006: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
70007: LD_INT 0
70009: PPUSH
70010: PPUSH
70011: PPUSH
70012: PPUSH
70013: PPUSH
70014: PPUSH
70015: PPUSH
// if not mc_bases or not skirmish then
70016: LD_EXP 14
70020: NOT
70021: PUSH
70022: LD_EXP 12
70026: NOT
70027: OR
70028: IFFALSE 70032
// exit ;
70030: GO 70693
// for i = 1 to mc_bases do
70032: LD_ADDR_VAR 0 3
70036: PUSH
70037: DOUBLE
70038: LD_INT 1
70040: DEC
70041: ST_TO_ADDR
70042: LD_EXP 14
70046: PUSH
70047: FOR_TO
70048: IFFALSE 70691
// begin if building in mc_construct_list [ i ] then
70050: LD_VAR 0 1
70054: PUSH
70055: LD_EXP 21
70059: PUSH
70060: LD_VAR 0 3
70064: ARRAY
70065: IN
70066: IFFALSE 70689
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
70068: LD_ADDR_EXP 21
70072: PUSH
70073: LD_EXP 21
70077: PPUSH
70078: LD_VAR 0 3
70082: PPUSH
70083: LD_EXP 21
70087: PUSH
70088: LD_VAR 0 3
70092: ARRAY
70093: PUSH
70094: LD_VAR 0 1
70098: DIFF
70099: PPUSH
70100: CALL_OW 1
70104: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
70105: LD_ADDR_EXP 14
70109: PUSH
70110: LD_EXP 14
70114: PPUSH
70115: LD_VAR 0 3
70119: PUSH
70120: LD_EXP 14
70124: PUSH
70125: LD_VAR 0 3
70129: ARRAY
70130: PUSH
70131: LD_INT 1
70133: PLUS
70134: PUSH
70135: EMPTY
70136: LIST
70137: LIST
70138: PPUSH
70139: LD_VAR 0 1
70143: PPUSH
70144: CALL 9427 0 3
70148: ST_TO_ADDR
// btype := GetBType ( building ) ;
70149: LD_ADDR_VAR 0 5
70153: PUSH
70154: LD_VAR 0 1
70158: PPUSH
70159: CALL_OW 266
70163: ST_TO_ADDR
// side := GetSide ( building ) ;
70164: LD_ADDR_VAR 0 8
70168: PUSH
70169: LD_VAR 0 1
70173: PPUSH
70174: CALL_OW 255
70178: ST_TO_ADDR
// if btype = b_lab then
70179: LD_VAR 0 5
70183: PUSH
70184: LD_INT 6
70186: EQUAL
70187: IFFALSE 70237
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
70189: LD_ADDR_EXP 47
70193: PUSH
70194: LD_EXP 47
70198: PPUSH
70199: LD_VAR 0 3
70203: PUSH
70204: LD_EXP 47
70208: PUSH
70209: LD_VAR 0 3
70213: ARRAY
70214: PUSH
70215: LD_INT 1
70217: PLUS
70218: PUSH
70219: EMPTY
70220: LIST
70221: LIST
70222: PPUSH
70223: LD_VAR 0 1
70227: PPUSH
70228: CALL 9427 0 3
70232: ST_TO_ADDR
// exit ;
70233: POP
70234: POP
70235: GO 70693
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
70237: LD_VAR 0 5
70241: PUSH
70242: LD_INT 0
70244: PUSH
70245: LD_INT 2
70247: PUSH
70248: LD_INT 4
70250: PUSH
70251: EMPTY
70252: LIST
70253: LIST
70254: LIST
70255: IN
70256: IFFALSE 70380
// begin if btype = b_armoury then
70258: LD_VAR 0 5
70262: PUSH
70263: LD_INT 4
70265: EQUAL
70266: IFFALSE 70276
// btype := b_barracks ;
70268: LD_ADDR_VAR 0 5
70272: PUSH
70273: LD_INT 5
70275: ST_TO_ADDR
// if btype = b_depot then
70276: LD_VAR 0 5
70280: PUSH
70281: LD_INT 0
70283: EQUAL
70284: IFFALSE 70294
// btype := b_warehouse ;
70286: LD_ADDR_VAR 0 5
70290: PUSH
70291: LD_INT 1
70293: ST_TO_ADDR
// if btype = b_workshop then
70294: LD_VAR 0 5
70298: PUSH
70299: LD_INT 2
70301: EQUAL
70302: IFFALSE 70312
// btype := b_factory ;
70304: LD_ADDR_VAR 0 5
70308: PUSH
70309: LD_INT 3
70311: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
70312: LD_VAR 0 5
70316: PPUSH
70317: LD_VAR 0 8
70321: PPUSH
70322: CALL_OW 323
70326: PUSH
70327: LD_INT 1
70329: EQUAL
70330: IFFALSE 70376
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
70332: LD_ADDR_EXP 46
70336: PUSH
70337: LD_EXP 46
70341: PPUSH
70342: LD_VAR 0 3
70346: PUSH
70347: LD_EXP 46
70351: PUSH
70352: LD_VAR 0 3
70356: ARRAY
70357: PUSH
70358: LD_INT 1
70360: PLUS
70361: PUSH
70362: EMPTY
70363: LIST
70364: LIST
70365: PPUSH
70366: LD_VAR 0 1
70370: PPUSH
70371: CALL 9427 0 3
70375: ST_TO_ADDR
// exit ;
70376: POP
70377: POP
70378: GO 70693
// end ; if btype in [ b_bunker , b_turret ] then
70380: LD_VAR 0 5
70384: PUSH
70385: LD_INT 32
70387: PUSH
70388: LD_INT 33
70390: PUSH
70391: EMPTY
70392: LIST
70393: LIST
70394: IN
70395: IFFALSE 70685
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
70397: LD_ADDR_EXP 22
70401: PUSH
70402: LD_EXP 22
70406: PPUSH
70407: LD_VAR 0 3
70411: PUSH
70412: LD_EXP 22
70416: PUSH
70417: LD_VAR 0 3
70421: ARRAY
70422: PUSH
70423: LD_INT 1
70425: PLUS
70426: PUSH
70427: EMPTY
70428: LIST
70429: LIST
70430: PPUSH
70431: LD_VAR 0 1
70435: PPUSH
70436: CALL 9427 0 3
70440: ST_TO_ADDR
// if btype = b_bunker then
70441: LD_VAR 0 5
70445: PUSH
70446: LD_INT 32
70448: EQUAL
70449: IFFALSE 70685
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
70451: LD_ADDR_EXP 23
70455: PUSH
70456: LD_EXP 23
70460: PPUSH
70461: LD_VAR 0 3
70465: PUSH
70466: LD_EXP 23
70470: PUSH
70471: LD_VAR 0 3
70475: ARRAY
70476: PUSH
70477: LD_INT 1
70479: PLUS
70480: PUSH
70481: EMPTY
70482: LIST
70483: LIST
70484: PPUSH
70485: LD_VAR 0 1
70489: PPUSH
70490: CALL 9427 0 3
70494: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
70495: LD_ADDR_VAR 0 6
70499: PUSH
70500: LD_EXP 14
70504: PUSH
70505: LD_VAR 0 3
70509: ARRAY
70510: PPUSH
70511: LD_INT 25
70513: PUSH
70514: LD_INT 1
70516: PUSH
70517: EMPTY
70518: LIST
70519: LIST
70520: PUSH
70521: LD_INT 3
70523: PUSH
70524: LD_INT 54
70526: PUSH
70527: EMPTY
70528: LIST
70529: PUSH
70530: EMPTY
70531: LIST
70532: LIST
70533: PUSH
70534: EMPTY
70535: LIST
70536: LIST
70537: PPUSH
70538: CALL_OW 72
70542: ST_TO_ADDR
// if tmp then
70543: LD_VAR 0 6
70547: IFFALSE 70553
// exit ;
70549: POP
70550: POP
70551: GO 70693
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
70553: LD_ADDR_VAR 0 6
70557: PUSH
70558: LD_EXP 14
70562: PUSH
70563: LD_VAR 0 3
70567: ARRAY
70568: PPUSH
70569: LD_INT 2
70571: PUSH
70572: LD_INT 30
70574: PUSH
70575: LD_INT 4
70577: PUSH
70578: EMPTY
70579: LIST
70580: LIST
70581: PUSH
70582: LD_INT 30
70584: PUSH
70585: LD_INT 5
70587: PUSH
70588: EMPTY
70589: LIST
70590: LIST
70591: PUSH
70592: EMPTY
70593: LIST
70594: LIST
70595: LIST
70596: PPUSH
70597: CALL_OW 72
70601: ST_TO_ADDR
// if not tmp then
70602: LD_VAR 0 6
70606: NOT
70607: IFFALSE 70613
// exit ;
70609: POP
70610: POP
70611: GO 70693
// for j in tmp do
70613: LD_ADDR_VAR 0 4
70617: PUSH
70618: LD_VAR 0 6
70622: PUSH
70623: FOR_IN
70624: IFFALSE 70683
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
70626: LD_ADDR_VAR 0 7
70630: PUSH
70631: LD_VAR 0 4
70635: PPUSH
70636: CALL_OW 313
70640: PPUSH
70641: LD_INT 25
70643: PUSH
70644: LD_INT 1
70646: PUSH
70647: EMPTY
70648: LIST
70649: LIST
70650: PPUSH
70651: CALL_OW 72
70655: ST_TO_ADDR
// if units then
70656: LD_VAR 0 7
70660: IFFALSE 70681
// begin ComExitBuilding ( units [ 1 ] ) ;
70662: LD_VAR 0 7
70666: PUSH
70667: LD_INT 1
70669: ARRAY
70670: PPUSH
70671: CALL_OW 122
// exit ;
70675: POP
70676: POP
70677: POP
70678: POP
70679: GO 70693
// end ; end ;
70681: GO 70623
70683: POP
70684: POP
// end ; end ; exit ;
70685: POP
70686: POP
70687: GO 70693
// end ; end ;
70689: GO 70047
70691: POP
70692: POP
// end ;
70693: LD_VAR 0 2
70697: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
70698: LD_INT 0
70700: PPUSH
70701: PPUSH
70702: PPUSH
70703: PPUSH
70704: PPUSH
70705: PPUSH
70706: PPUSH
// if not mc_bases or not skirmish then
70707: LD_EXP 14
70711: NOT
70712: PUSH
70713: LD_EXP 12
70717: NOT
70718: OR
70719: IFFALSE 70723
// exit ;
70721: GO 70954
// btype := GetBType ( building ) ;
70723: LD_ADDR_VAR 0 6
70727: PUSH
70728: LD_VAR 0 1
70732: PPUSH
70733: CALL_OW 266
70737: ST_TO_ADDR
// x := GetX ( building ) ;
70738: LD_ADDR_VAR 0 7
70742: PUSH
70743: LD_VAR 0 1
70747: PPUSH
70748: CALL_OW 250
70752: ST_TO_ADDR
// y := GetY ( building ) ;
70753: LD_ADDR_VAR 0 8
70757: PUSH
70758: LD_VAR 0 1
70762: PPUSH
70763: CALL_OW 251
70767: ST_TO_ADDR
// d := GetDir ( building ) ;
70768: LD_ADDR_VAR 0 9
70772: PUSH
70773: LD_VAR 0 1
70777: PPUSH
70778: CALL_OW 254
70782: ST_TO_ADDR
// for i = 1 to mc_bases do
70783: LD_ADDR_VAR 0 4
70787: PUSH
70788: DOUBLE
70789: LD_INT 1
70791: DEC
70792: ST_TO_ADDR
70793: LD_EXP 14
70797: PUSH
70798: FOR_TO
70799: IFFALSE 70952
// begin if not mc_build_list [ i ] then
70801: LD_EXP 19
70805: PUSH
70806: LD_VAR 0 4
70810: ARRAY
70811: NOT
70812: IFFALSE 70816
// continue ;
70814: GO 70798
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
70816: LD_VAR 0 6
70820: PUSH
70821: LD_VAR 0 7
70825: PUSH
70826: LD_VAR 0 8
70830: PUSH
70831: LD_VAR 0 9
70835: PUSH
70836: EMPTY
70837: LIST
70838: LIST
70839: LIST
70840: LIST
70841: PPUSH
70842: LD_EXP 19
70846: PUSH
70847: LD_VAR 0 4
70851: ARRAY
70852: PUSH
70853: LD_INT 1
70855: ARRAY
70856: PPUSH
70857: CALL 15596 0 2
70861: IFFALSE 70950
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
70863: LD_ADDR_EXP 19
70867: PUSH
70868: LD_EXP 19
70872: PPUSH
70873: LD_VAR 0 4
70877: PPUSH
70878: LD_EXP 19
70882: PUSH
70883: LD_VAR 0 4
70887: ARRAY
70888: PPUSH
70889: LD_INT 1
70891: PPUSH
70892: CALL_OW 3
70896: PPUSH
70897: CALL_OW 1
70901: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
70902: LD_ADDR_EXP 21
70906: PUSH
70907: LD_EXP 21
70911: PPUSH
70912: LD_VAR 0 4
70916: PUSH
70917: LD_EXP 21
70921: PUSH
70922: LD_VAR 0 4
70926: ARRAY
70927: PUSH
70928: LD_INT 1
70930: PLUS
70931: PUSH
70932: EMPTY
70933: LIST
70934: LIST
70935: PPUSH
70936: LD_VAR 0 1
70940: PPUSH
70941: CALL 9427 0 3
70945: ST_TO_ADDR
// exit ;
70946: POP
70947: POP
70948: GO 70954
// end ; end ;
70950: GO 70798
70952: POP
70953: POP
// end ;
70954: LD_VAR 0 3
70958: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
70959: LD_INT 0
70961: PPUSH
70962: PPUSH
70963: PPUSH
// if not mc_bases or not skirmish then
70964: LD_EXP 14
70968: NOT
70969: PUSH
70970: LD_EXP 12
70974: NOT
70975: OR
70976: IFFALSE 70980
// exit ;
70978: GO 71170
// for i = 1 to mc_bases do
70980: LD_ADDR_VAR 0 4
70984: PUSH
70985: DOUBLE
70986: LD_INT 1
70988: DEC
70989: ST_TO_ADDR
70990: LD_EXP 14
70994: PUSH
70995: FOR_TO
70996: IFFALSE 71083
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
70998: LD_VAR 0 1
71002: PUSH
71003: LD_EXP 22
71007: PUSH
71008: LD_VAR 0 4
71012: ARRAY
71013: IN
71014: PUSH
71015: LD_VAR 0 1
71019: PUSH
71020: LD_EXP 23
71024: PUSH
71025: LD_VAR 0 4
71029: ARRAY
71030: IN
71031: NOT
71032: AND
71033: IFFALSE 71081
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
71035: LD_ADDR_EXP 23
71039: PUSH
71040: LD_EXP 23
71044: PPUSH
71045: LD_VAR 0 4
71049: PUSH
71050: LD_EXP 23
71054: PUSH
71055: LD_VAR 0 4
71059: ARRAY
71060: PUSH
71061: LD_INT 1
71063: PLUS
71064: PUSH
71065: EMPTY
71066: LIST
71067: LIST
71068: PPUSH
71069: LD_VAR 0 1
71073: PPUSH
71074: CALL 9427 0 3
71078: ST_TO_ADDR
// break ;
71079: GO 71083
// end ; end ;
71081: GO 70995
71083: POP
71084: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
71085: LD_VAR 0 1
71089: PPUSH
71090: CALL_OW 257
71094: PUSH
71095: LD_EXP 40
71099: IN
71100: PUSH
71101: LD_VAR 0 1
71105: PPUSH
71106: CALL_OW 266
71110: PUSH
71111: LD_INT 5
71113: EQUAL
71114: AND
71115: PUSH
71116: LD_VAR 0 2
71120: PPUSH
71121: CALL_OW 110
71125: PUSH
71126: LD_INT 18
71128: NONEQUAL
71129: AND
71130: IFFALSE 71170
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
71132: LD_VAR 0 2
71136: PPUSH
71137: CALL_OW 257
71141: PUSH
71142: LD_INT 5
71144: PUSH
71145: LD_INT 8
71147: PUSH
71148: LD_INT 9
71150: PUSH
71151: EMPTY
71152: LIST
71153: LIST
71154: LIST
71155: IN
71156: IFFALSE 71170
// SetClass ( unit , 1 ) ;
71158: LD_VAR 0 2
71162: PPUSH
71163: LD_INT 1
71165: PPUSH
71166: CALL_OW 336
// end ;
71170: LD_VAR 0 3
71174: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
71175: LD_INT 0
71177: PPUSH
71178: PPUSH
// if not mc_bases or not skirmish then
71179: LD_EXP 14
71183: NOT
71184: PUSH
71185: LD_EXP 12
71189: NOT
71190: OR
71191: IFFALSE 71195
// exit ;
71193: GO 71311
// if GetLives ( abandoned_vehicle ) > 250 then
71195: LD_VAR 0 2
71199: PPUSH
71200: CALL_OW 256
71204: PUSH
71205: LD_INT 250
71207: GREATER
71208: IFFALSE 71212
// exit ;
71210: GO 71311
// for i = 1 to mc_bases do
71212: LD_ADDR_VAR 0 6
71216: PUSH
71217: DOUBLE
71218: LD_INT 1
71220: DEC
71221: ST_TO_ADDR
71222: LD_EXP 14
71226: PUSH
71227: FOR_TO
71228: IFFALSE 71309
// begin if driver in mc_bases [ i ] then
71230: LD_VAR 0 1
71234: PUSH
71235: LD_EXP 14
71239: PUSH
71240: LD_VAR 0 6
71244: ARRAY
71245: IN
71246: IFFALSE 71307
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
71248: LD_VAR 0 1
71252: PPUSH
71253: LD_EXP 14
71257: PUSH
71258: LD_VAR 0 6
71262: ARRAY
71263: PPUSH
71264: LD_INT 2
71266: PUSH
71267: LD_INT 30
71269: PUSH
71270: LD_INT 0
71272: PUSH
71273: EMPTY
71274: LIST
71275: LIST
71276: PUSH
71277: LD_INT 30
71279: PUSH
71280: LD_INT 1
71282: PUSH
71283: EMPTY
71284: LIST
71285: LIST
71286: PUSH
71287: EMPTY
71288: LIST
71289: LIST
71290: LIST
71291: PPUSH
71292: CALL_OW 72
71296: PUSH
71297: LD_INT 1
71299: ARRAY
71300: PPUSH
71301: CALL_OW 112
// break ;
71305: GO 71309
// end ; end ;
71307: GO 71227
71309: POP
71310: POP
// end ; end_of_file
71311: LD_VAR 0 5
71315: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
71316: LD_INT 0
71318: PPUSH
// ar_miner := 81 ;
71319: LD_ADDR_EXP 64
71323: PUSH
71324: LD_INT 81
71326: ST_TO_ADDR
// ar_crane := 88 ;
71327: LD_ADDR_EXP 63
71331: PUSH
71332: LD_INT 88
71334: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
71335: LD_ADDR_EXP 58
71339: PUSH
71340: LD_INT 89
71342: ST_TO_ADDR
// us_hack := 99 ;
71343: LD_ADDR_EXP 59
71347: PUSH
71348: LD_INT 99
71350: ST_TO_ADDR
// us_artillery := 97 ;
71351: LD_ADDR_EXP 60
71355: PUSH
71356: LD_INT 97
71358: ST_TO_ADDR
// ar_bio_bomb := 91 ;
71359: LD_ADDR_EXP 61
71363: PUSH
71364: LD_INT 91
71366: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
71367: LD_ADDR_EXP 62
71371: PUSH
71372: LD_INT 92
71374: ST_TO_ADDR
// ru_radar := 98 ;
71375: LD_ADDR_EXP 57
71379: PUSH
71380: LD_INT 98
71382: ST_TO_ADDR
// tech_Artillery := 80 ;
71383: LD_ADDR_EXP 65
71387: PUSH
71388: LD_INT 80
71390: ST_TO_ADDR
// tech_RadMat := 81 ;
71391: LD_ADDR_EXP 66
71395: PUSH
71396: LD_INT 81
71398: ST_TO_ADDR
// tech_BasicTools := 82 ;
71399: LD_ADDR_EXP 67
71403: PUSH
71404: LD_INT 82
71406: ST_TO_ADDR
// tech_Cargo := 83 ;
71407: LD_ADDR_EXP 68
71411: PUSH
71412: LD_INT 83
71414: ST_TO_ADDR
// tech_Track := 84 ;
71415: LD_ADDR_EXP 69
71419: PUSH
71420: LD_INT 84
71422: ST_TO_ADDR
// tech_Crane := 85 ;
71423: LD_ADDR_EXP 70
71427: PUSH
71428: LD_INT 85
71430: ST_TO_ADDR
// tech_Bulldozer := 86 ;
71431: LD_ADDR_EXP 71
71435: PUSH
71436: LD_INT 86
71438: ST_TO_ADDR
// tech_Hovercraft := 87 ;
71439: LD_ADDR_EXP 72
71443: PUSH
71444: LD_INT 87
71446: ST_TO_ADDR
// end ;
71447: LD_VAR 0 1
71451: RET
// every 1 do
71452: GO 71454
71454: DISABLE
// InitGlobalVariables ; end_of_file
71455: CALL 71316 0 0
71459: END
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
71460: LD_INT 0
71462: PPUSH
71463: PPUSH
71464: PPUSH
71465: PPUSH
71466: PPUSH
71467: PPUSH
71468: PPUSH
71469: PPUSH
71470: PPUSH
71471: PPUSH
71472: PPUSH
71473: PPUSH
71474: PPUSH
71475: PPUSH
71476: PPUSH
71477: PPUSH
71478: PPUSH
71479: PPUSH
71480: PPUSH
71481: PPUSH
71482: PPUSH
71483: PPUSH
71484: PPUSH
71485: PPUSH
71486: PPUSH
71487: PPUSH
71488: PPUSH
71489: PPUSH
71490: PPUSH
71491: PPUSH
71492: PPUSH
71493: PPUSH
71494: PPUSH
71495: PPUSH
// if not list then
71496: LD_VAR 0 1
71500: NOT
71501: IFFALSE 71505
// exit ;
71503: GO 76164
// base := list [ 1 ] ;
71505: LD_ADDR_VAR 0 3
71509: PUSH
71510: LD_VAR 0 1
71514: PUSH
71515: LD_INT 1
71517: ARRAY
71518: ST_TO_ADDR
// group := list [ 2 ] ;
71519: LD_ADDR_VAR 0 4
71523: PUSH
71524: LD_VAR 0 1
71528: PUSH
71529: LD_INT 2
71531: ARRAY
71532: ST_TO_ADDR
// path := list [ 3 ] ;
71533: LD_ADDR_VAR 0 5
71537: PUSH
71538: LD_VAR 0 1
71542: PUSH
71543: LD_INT 3
71545: ARRAY
71546: ST_TO_ADDR
// flags := list [ 4 ] ;
71547: LD_ADDR_VAR 0 6
71551: PUSH
71552: LD_VAR 0 1
71556: PUSH
71557: LD_INT 4
71559: ARRAY
71560: ST_TO_ADDR
// mined := [ ] ;
71561: LD_ADDR_VAR 0 27
71565: PUSH
71566: EMPTY
71567: ST_TO_ADDR
// bombed := [ ] ;
71568: LD_ADDR_VAR 0 28
71572: PUSH
71573: EMPTY
71574: ST_TO_ADDR
// healers := [ ] ;
71575: LD_ADDR_VAR 0 31
71579: PUSH
71580: EMPTY
71581: ST_TO_ADDR
// to_heal := [ ] ;
71582: LD_ADDR_VAR 0 30
71586: PUSH
71587: EMPTY
71588: ST_TO_ADDR
// repairs := [ ] ;
71589: LD_ADDR_VAR 0 33
71593: PUSH
71594: EMPTY
71595: ST_TO_ADDR
// to_repair := [ ] ;
71596: LD_ADDR_VAR 0 32
71600: PUSH
71601: EMPTY
71602: ST_TO_ADDR
// if not group or not path then
71603: LD_VAR 0 4
71607: NOT
71608: PUSH
71609: LD_VAR 0 5
71613: NOT
71614: OR
71615: IFFALSE 71619
// exit ;
71617: GO 76164
// side := GetSide ( group [ 1 ] ) ;
71619: LD_ADDR_VAR 0 35
71623: PUSH
71624: LD_VAR 0 4
71628: PUSH
71629: LD_INT 1
71631: ARRAY
71632: PPUSH
71633: CALL_OW 255
71637: ST_TO_ADDR
// if flags then
71638: LD_VAR 0 6
71642: IFFALSE 71786
// begin f_ignore_area := flags [ 1 ] ;
71644: LD_ADDR_VAR 0 17
71648: PUSH
71649: LD_VAR 0 6
71653: PUSH
71654: LD_INT 1
71656: ARRAY
71657: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
71658: LD_ADDR_VAR 0 18
71662: PUSH
71663: LD_VAR 0 6
71667: PUSH
71668: LD_INT 2
71670: ARRAY
71671: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
71672: LD_ADDR_VAR 0 19
71676: PUSH
71677: LD_VAR 0 6
71681: PUSH
71682: LD_INT 3
71684: ARRAY
71685: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
71686: LD_ADDR_VAR 0 20
71690: PUSH
71691: LD_VAR 0 6
71695: PUSH
71696: LD_INT 4
71698: ARRAY
71699: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
71700: LD_ADDR_VAR 0 21
71704: PUSH
71705: LD_VAR 0 6
71709: PUSH
71710: LD_INT 5
71712: ARRAY
71713: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
71714: LD_ADDR_VAR 0 22
71718: PUSH
71719: LD_VAR 0 6
71723: PUSH
71724: LD_INT 6
71726: ARRAY
71727: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
71728: LD_ADDR_VAR 0 23
71732: PUSH
71733: LD_VAR 0 6
71737: PUSH
71738: LD_INT 7
71740: ARRAY
71741: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
71742: LD_ADDR_VAR 0 24
71746: PUSH
71747: LD_VAR 0 6
71751: PUSH
71752: LD_INT 8
71754: ARRAY
71755: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
71756: LD_ADDR_VAR 0 25
71760: PUSH
71761: LD_VAR 0 6
71765: PUSH
71766: LD_INT 9
71768: ARRAY
71769: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
71770: LD_ADDR_VAR 0 26
71774: PUSH
71775: LD_VAR 0 6
71779: PUSH
71780: LD_INT 10
71782: ARRAY
71783: ST_TO_ADDR
// end else
71784: GO 71866
// begin f_ignore_area := false ;
71786: LD_ADDR_VAR 0 17
71790: PUSH
71791: LD_INT 0
71793: ST_TO_ADDR
// f_capture := false ;
71794: LD_ADDR_VAR 0 18
71798: PUSH
71799: LD_INT 0
71801: ST_TO_ADDR
// f_ignore_civ := false ;
71802: LD_ADDR_VAR 0 19
71806: PUSH
71807: LD_INT 0
71809: ST_TO_ADDR
// f_murder := false ;
71810: LD_ADDR_VAR 0 20
71814: PUSH
71815: LD_INT 0
71817: ST_TO_ADDR
// f_mines := false ;
71818: LD_ADDR_VAR 0 21
71822: PUSH
71823: LD_INT 0
71825: ST_TO_ADDR
// f_repair := false ;
71826: LD_ADDR_VAR 0 22
71830: PUSH
71831: LD_INT 0
71833: ST_TO_ADDR
// f_heal := false ;
71834: LD_ADDR_VAR 0 23
71838: PUSH
71839: LD_INT 0
71841: ST_TO_ADDR
// f_spacetime := false ;
71842: LD_ADDR_VAR 0 24
71846: PUSH
71847: LD_INT 0
71849: ST_TO_ADDR
// f_attack_depot := false ;
71850: LD_ADDR_VAR 0 25
71854: PUSH
71855: LD_INT 0
71857: ST_TO_ADDR
// f_crawl := false ;
71858: LD_ADDR_VAR 0 26
71862: PUSH
71863: LD_INT 0
71865: ST_TO_ADDR
// end ; if f_heal then
71866: LD_VAR 0 23
71870: IFFALSE 71897
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
71872: LD_ADDR_VAR 0 31
71876: PUSH
71877: LD_VAR 0 4
71881: PPUSH
71882: LD_INT 25
71884: PUSH
71885: LD_INT 4
71887: PUSH
71888: EMPTY
71889: LIST
71890: LIST
71891: PPUSH
71892: CALL_OW 72
71896: ST_TO_ADDR
// if f_repair then
71897: LD_VAR 0 22
71901: IFFALSE 71928
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
71903: LD_ADDR_VAR 0 33
71907: PUSH
71908: LD_VAR 0 4
71912: PPUSH
71913: LD_INT 25
71915: PUSH
71916: LD_INT 3
71918: PUSH
71919: EMPTY
71920: LIST
71921: LIST
71922: PPUSH
71923: CALL_OW 72
71927: ST_TO_ADDR
// units_path := [ ] ;
71928: LD_ADDR_VAR 0 16
71932: PUSH
71933: EMPTY
71934: ST_TO_ADDR
// for i = 1 to group do
71935: LD_ADDR_VAR 0 7
71939: PUSH
71940: DOUBLE
71941: LD_INT 1
71943: DEC
71944: ST_TO_ADDR
71945: LD_VAR 0 4
71949: PUSH
71950: FOR_TO
71951: IFFALSE 71980
// units_path := Replace ( units_path , i , path ) ;
71953: LD_ADDR_VAR 0 16
71957: PUSH
71958: LD_VAR 0 16
71962: PPUSH
71963: LD_VAR 0 7
71967: PPUSH
71968: LD_VAR 0 5
71972: PPUSH
71973: CALL_OW 1
71977: ST_TO_ADDR
71978: GO 71950
71980: POP
71981: POP
// repeat for i = group downto 1 do
71982: LD_ADDR_VAR 0 7
71986: PUSH
71987: DOUBLE
71988: LD_VAR 0 4
71992: INC
71993: ST_TO_ADDR
71994: LD_INT 1
71996: PUSH
71997: FOR_DOWNTO
71998: IFFALSE 76120
// begin wait ( 5 ) ;
72000: LD_INT 5
72002: PPUSH
72003: CALL_OW 67
// tmp := [ ] ;
72007: LD_ADDR_VAR 0 14
72011: PUSH
72012: EMPTY
72013: ST_TO_ADDR
// attacking := false ;
72014: LD_ADDR_VAR 0 29
72018: PUSH
72019: LD_INT 0
72021: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
72022: LD_VAR 0 4
72026: PUSH
72027: LD_VAR 0 7
72031: ARRAY
72032: PPUSH
72033: CALL_OW 301
72037: PUSH
72038: LD_VAR 0 4
72042: PUSH
72043: LD_VAR 0 7
72047: ARRAY
72048: NOT
72049: OR
72050: IFFALSE 72159
// begin if GetType ( group [ i ] ) = unit_human then
72052: LD_VAR 0 4
72056: PUSH
72057: LD_VAR 0 7
72061: ARRAY
72062: PPUSH
72063: CALL_OW 247
72067: PUSH
72068: LD_INT 1
72070: EQUAL
72071: IFFALSE 72117
// begin to_heal := to_heal diff group [ i ] ;
72073: LD_ADDR_VAR 0 30
72077: PUSH
72078: LD_VAR 0 30
72082: PUSH
72083: LD_VAR 0 4
72087: PUSH
72088: LD_VAR 0 7
72092: ARRAY
72093: DIFF
72094: ST_TO_ADDR
// healers := healers diff group [ i ] ;
72095: LD_ADDR_VAR 0 31
72099: PUSH
72100: LD_VAR 0 31
72104: PUSH
72105: LD_VAR 0 4
72109: PUSH
72110: LD_VAR 0 7
72114: ARRAY
72115: DIFF
72116: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
72117: LD_ADDR_VAR 0 4
72121: PUSH
72122: LD_VAR 0 4
72126: PPUSH
72127: LD_VAR 0 7
72131: PPUSH
72132: CALL_OW 3
72136: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
72137: LD_ADDR_VAR 0 16
72141: PUSH
72142: LD_VAR 0 16
72146: PPUSH
72147: LD_VAR 0 7
72151: PPUSH
72152: CALL_OW 3
72156: ST_TO_ADDR
// continue ;
72157: GO 71997
// end ; if f_repair then
72159: LD_VAR 0 22
72163: IFFALSE 72652
// begin if GetType ( group [ i ] ) = unit_vehicle then
72165: LD_VAR 0 4
72169: PUSH
72170: LD_VAR 0 7
72174: ARRAY
72175: PPUSH
72176: CALL_OW 247
72180: PUSH
72181: LD_INT 2
72183: EQUAL
72184: IFFALSE 72374
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
72186: LD_VAR 0 4
72190: PUSH
72191: LD_VAR 0 7
72195: ARRAY
72196: PPUSH
72197: CALL_OW 256
72201: PUSH
72202: LD_INT 700
72204: LESS
72205: PUSH
72206: LD_VAR 0 4
72210: PUSH
72211: LD_VAR 0 7
72215: ARRAY
72216: PUSH
72217: LD_VAR 0 32
72221: IN
72222: NOT
72223: AND
72224: IFFALSE 72248
// to_repair := to_repair union group [ i ] ;
72226: LD_ADDR_VAR 0 32
72230: PUSH
72231: LD_VAR 0 32
72235: PUSH
72236: LD_VAR 0 4
72240: PUSH
72241: LD_VAR 0 7
72245: ARRAY
72246: UNION
72247: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
72248: LD_VAR 0 4
72252: PUSH
72253: LD_VAR 0 7
72257: ARRAY
72258: PPUSH
72259: CALL_OW 256
72263: PUSH
72264: LD_INT 1000
72266: EQUAL
72267: PUSH
72268: LD_VAR 0 4
72272: PUSH
72273: LD_VAR 0 7
72277: ARRAY
72278: PUSH
72279: LD_VAR 0 32
72283: IN
72284: AND
72285: IFFALSE 72309
// to_repair := to_repair diff group [ i ] ;
72287: LD_ADDR_VAR 0 32
72291: PUSH
72292: LD_VAR 0 32
72296: PUSH
72297: LD_VAR 0 4
72301: PUSH
72302: LD_VAR 0 7
72306: ARRAY
72307: DIFF
72308: ST_TO_ADDR
// if group [ i ] in to_repair then
72309: LD_VAR 0 4
72313: PUSH
72314: LD_VAR 0 7
72318: ARRAY
72319: PUSH
72320: LD_VAR 0 32
72324: IN
72325: IFFALSE 72372
// begin if not IsInArea ( group [ i ] , f_repair ) then
72327: LD_VAR 0 4
72331: PUSH
72332: LD_VAR 0 7
72336: ARRAY
72337: PPUSH
72338: LD_VAR 0 22
72342: PPUSH
72343: CALL_OW 308
72347: NOT
72348: IFFALSE 72370
// ComMoveToArea ( group [ i ] , f_repair ) ;
72350: LD_VAR 0 4
72354: PUSH
72355: LD_VAR 0 7
72359: ARRAY
72360: PPUSH
72361: LD_VAR 0 22
72365: PPUSH
72366: CALL_OW 113
// continue ;
72370: GO 71997
// end ; end else
72372: GO 72652
// if group [ i ] in repairs then
72374: LD_VAR 0 4
72378: PUSH
72379: LD_VAR 0 7
72383: ARRAY
72384: PUSH
72385: LD_VAR 0 33
72389: IN
72390: IFFALSE 72652
// begin if IsInUnit ( group [ i ] ) then
72392: LD_VAR 0 4
72396: PUSH
72397: LD_VAR 0 7
72401: ARRAY
72402: PPUSH
72403: CALL_OW 310
72407: IFFALSE 72475
// begin z := IsInUnit ( group [ i ] ) ;
72409: LD_ADDR_VAR 0 13
72413: PUSH
72414: LD_VAR 0 4
72418: PUSH
72419: LD_VAR 0 7
72423: ARRAY
72424: PPUSH
72425: CALL_OW 310
72429: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
72430: LD_VAR 0 13
72434: PUSH
72435: LD_VAR 0 32
72439: IN
72440: PUSH
72441: LD_VAR 0 13
72445: PPUSH
72446: LD_VAR 0 22
72450: PPUSH
72451: CALL_OW 308
72455: AND
72456: IFFALSE 72473
// ComExitVehicle ( group [ i ] ) ;
72458: LD_VAR 0 4
72462: PUSH
72463: LD_VAR 0 7
72467: ARRAY
72468: PPUSH
72469: CALL_OW 121
// end else
72473: GO 72652
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
72475: LD_ADDR_VAR 0 13
72479: PUSH
72480: LD_VAR 0 4
72484: PPUSH
72485: LD_INT 95
72487: PUSH
72488: LD_VAR 0 22
72492: PUSH
72493: EMPTY
72494: LIST
72495: LIST
72496: PUSH
72497: LD_INT 58
72499: PUSH
72500: EMPTY
72501: LIST
72502: PUSH
72503: EMPTY
72504: LIST
72505: LIST
72506: PPUSH
72507: CALL_OW 72
72511: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
72512: LD_VAR 0 4
72516: PUSH
72517: LD_VAR 0 7
72521: ARRAY
72522: PPUSH
72523: CALL_OW 314
72527: NOT
72528: IFFALSE 72650
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
72530: LD_ADDR_VAR 0 10
72534: PUSH
72535: LD_VAR 0 13
72539: PPUSH
72540: LD_VAR 0 4
72544: PUSH
72545: LD_VAR 0 7
72549: ARRAY
72550: PPUSH
72551: CALL_OW 74
72555: ST_TO_ADDR
// if not x then
72556: LD_VAR 0 10
72560: NOT
72561: IFFALSE 72565
// continue ;
72563: GO 71997
// if GetLives ( x ) < 1000 then
72565: LD_VAR 0 10
72569: PPUSH
72570: CALL_OW 256
72574: PUSH
72575: LD_INT 1000
72577: LESS
72578: IFFALSE 72602
// ComRepairVehicle ( group [ i ] , x ) else
72580: LD_VAR 0 4
72584: PUSH
72585: LD_VAR 0 7
72589: ARRAY
72590: PPUSH
72591: LD_VAR 0 10
72595: PPUSH
72596: CALL_OW 129
72600: GO 72650
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
72602: LD_VAR 0 23
72606: PUSH
72607: LD_VAR 0 4
72611: PUSH
72612: LD_VAR 0 7
72616: ARRAY
72617: PPUSH
72618: CALL_OW 256
72622: PUSH
72623: LD_INT 1000
72625: LESS
72626: AND
72627: NOT
72628: IFFALSE 72650
// ComEnterUnit ( group [ i ] , x ) ;
72630: LD_VAR 0 4
72634: PUSH
72635: LD_VAR 0 7
72639: ARRAY
72640: PPUSH
72641: LD_VAR 0 10
72645: PPUSH
72646: CALL_OW 120
// end ; continue ;
72650: GO 71997
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
72652: LD_VAR 0 23
72656: PUSH
72657: LD_VAR 0 4
72661: PUSH
72662: LD_VAR 0 7
72666: ARRAY
72667: PPUSH
72668: CALL_OW 247
72672: PUSH
72673: LD_INT 1
72675: EQUAL
72676: AND
72677: IFFALSE 73155
// begin if group [ i ] in healers then
72679: LD_VAR 0 4
72683: PUSH
72684: LD_VAR 0 7
72688: ARRAY
72689: PUSH
72690: LD_VAR 0 31
72694: IN
72695: IFFALSE 72968
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
72697: LD_VAR 0 4
72701: PUSH
72702: LD_VAR 0 7
72706: ARRAY
72707: PPUSH
72708: LD_VAR 0 23
72712: PPUSH
72713: CALL_OW 308
72717: NOT
72718: PUSH
72719: LD_VAR 0 4
72723: PUSH
72724: LD_VAR 0 7
72728: ARRAY
72729: PPUSH
72730: CALL_OW 314
72734: NOT
72735: AND
72736: IFFALSE 72760
// ComMoveToArea ( group [ i ] , f_heal ) else
72738: LD_VAR 0 4
72742: PUSH
72743: LD_VAR 0 7
72747: ARRAY
72748: PPUSH
72749: LD_VAR 0 23
72753: PPUSH
72754: CALL_OW 113
72758: GO 72966
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
72760: LD_VAR 0 4
72764: PUSH
72765: LD_VAR 0 7
72769: ARRAY
72770: PPUSH
72771: CALL 37799 0 1
72775: PPUSH
72776: CALL_OW 256
72780: PUSH
72781: LD_INT 1000
72783: EQUAL
72784: IFFALSE 72803
// ComStop ( group [ i ] ) else
72786: LD_VAR 0 4
72790: PUSH
72791: LD_VAR 0 7
72795: ARRAY
72796: PPUSH
72797: CALL_OW 141
72801: GO 72966
// if not HasTask ( group [ i ] ) and to_heal then
72803: LD_VAR 0 4
72807: PUSH
72808: LD_VAR 0 7
72812: ARRAY
72813: PPUSH
72814: CALL_OW 314
72818: NOT
72819: PUSH
72820: LD_VAR 0 30
72824: AND
72825: IFFALSE 72966
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
72827: LD_ADDR_VAR 0 13
72831: PUSH
72832: LD_VAR 0 30
72836: PPUSH
72837: LD_INT 3
72839: PUSH
72840: LD_INT 54
72842: PUSH
72843: EMPTY
72844: LIST
72845: PUSH
72846: EMPTY
72847: LIST
72848: LIST
72849: PPUSH
72850: CALL_OW 72
72854: PPUSH
72855: LD_VAR 0 4
72859: PUSH
72860: LD_VAR 0 7
72864: ARRAY
72865: PPUSH
72866: CALL_OW 74
72870: ST_TO_ADDR
// if z then
72871: LD_VAR 0 13
72875: IFFALSE 72966
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
72877: LD_INT 91
72879: PUSH
72880: LD_VAR 0 13
72884: PUSH
72885: LD_INT 10
72887: PUSH
72888: EMPTY
72889: LIST
72890: LIST
72891: LIST
72892: PUSH
72893: LD_INT 81
72895: PUSH
72896: LD_VAR 0 13
72900: PPUSH
72901: CALL_OW 255
72905: PUSH
72906: EMPTY
72907: LIST
72908: LIST
72909: PUSH
72910: EMPTY
72911: LIST
72912: LIST
72913: PPUSH
72914: CALL_OW 69
72918: PUSH
72919: LD_INT 0
72921: EQUAL
72922: IFFALSE 72946
// ComHeal ( group [ i ] , z ) else
72924: LD_VAR 0 4
72928: PUSH
72929: LD_VAR 0 7
72933: ARRAY
72934: PPUSH
72935: LD_VAR 0 13
72939: PPUSH
72940: CALL_OW 128
72944: GO 72966
// ComMoveToArea ( group [ i ] , f_heal ) ;
72946: LD_VAR 0 4
72950: PUSH
72951: LD_VAR 0 7
72955: ARRAY
72956: PPUSH
72957: LD_VAR 0 23
72961: PPUSH
72962: CALL_OW 113
// end ; continue ;
72966: GO 71997
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
72968: LD_VAR 0 4
72972: PUSH
72973: LD_VAR 0 7
72977: ARRAY
72978: PPUSH
72979: CALL_OW 256
72983: PUSH
72984: LD_INT 700
72986: LESS
72987: PUSH
72988: LD_VAR 0 4
72992: PUSH
72993: LD_VAR 0 7
72997: ARRAY
72998: PUSH
72999: LD_VAR 0 30
73003: IN
73004: NOT
73005: AND
73006: IFFALSE 73030
// to_heal := to_heal union group [ i ] ;
73008: LD_ADDR_VAR 0 30
73012: PUSH
73013: LD_VAR 0 30
73017: PUSH
73018: LD_VAR 0 4
73022: PUSH
73023: LD_VAR 0 7
73027: ARRAY
73028: UNION
73029: ST_TO_ADDR
// if group [ i ] in to_heal then
73030: LD_VAR 0 4
73034: PUSH
73035: LD_VAR 0 7
73039: ARRAY
73040: PUSH
73041: LD_VAR 0 30
73045: IN
73046: IFFALSE 73155
// begin if GetLives ( group [ i ] ) = 1000 then
73048: LD_VAR 0 4
73052: PUSH
73053: LD_VAR 0 7
73057: ARRAY
73058: PPUSH
73059: CALL_OW 256
73063: PUSH
73064: LD_INT 1000
73066: EQUAL
73067: IFFALSE 73093
// to_heal := to_heal diff group [ i ] else
73069: LD_ADDR_VAR 0 30
73073: PUSH
73074: LD_VAR 0 30
73078: PUSH
73079: LD_VAR 0 4
73083: PUSH
73084: LD_VAR 0 7
73088: ARRAY
73089: DIFF
73090: ST_TO_ADDR
73091: GO 73155
// begin if not IsInArea ( group [ i ] , to_heal ) then
73093: LD_VAR 0 4
73097: PUSH
73098: LD_VAR 0 7
73102: ARRAY
73103: PPUSH
73104: LD_VAR 0 30
73108: PPUSH
73109: CALL_OW 308
73113: NOT
73114: IFFALSE 73138
// ComMoveToArea ( group [ i ] , f_heal ) else
73116: LD_VAR 0 4
73120: PUSH
73121: LD_VAR 0 7
73125: ARRAY
73126: PPUSH
73127: LD_VAR 0 23
73131: PPUSH
73132: CALL_OW 113
73136: GO 73153
// ComHold ( group [ i ] ) ;
73138: LD_VAR 0 4
73142: PUSH
73143: LD_VAR 0 7
73147: ARRAY
73148: PPUSH
73149: CALL_OW 140
// continue ;
73153: GO 71997
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
73155: LD_VAR 0 4
73159: PUSH
73160: LD_VAR 0 7
73164: ARRAY
73165: PPUSH
73166: LD_INT 10
73168: PPUSH
73169: CALL 36219 0 2
73173: NOT
73174: PUSH
73175: LD_VAR 0 16
73179: PUSH
73180: LD_VAR 0 7
73184: ARRAY
73185: PUSH
73186: EMPTY
73187: EQUAL
73188: NOT
73189: AND
73190: IFFALSE 73456
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
73192: LD_VAR 0 4
73196: PUSH
73197: LD_VAR 0 7
73201: ARRAY
73202: PPUSH
73203: CALL_OW 262
73207: PUSH
73208: LD_INT 1
73210: PUSH
73211: LD_INT 2
73213: PUSH
73214: EMPTY
73215: LIST
73216: LIST
73217: IN
73218: IFFALSE 73259
// if GetFuel ( group [ i ] ) < 10 then
73220: LD_VAR 0 4
73224: PUSH
73225: LD_VAR 0 7
73229: ARRAY
73230: PPUSH
73231: CALL_OW 261
73235: PUSH
73236: LD_INT 10
73238: LESS
73239: IFFALSE 73259
// SetFuel ( group [ i ] , 12 ) ;
73241: LD_VAR 0 4
73245: PUSH
73246: LD_VAR 0 7
73250: ARRAY
73251: PPUSH
73252: LD_INT 12
73254: PPUSH
73255: CALL_OW 240
// if units_path [ i ] then
73259: LD_VAR 0 16
73263: PUSH
73264: LD_VAR 0 7
73268: ARRAY
73269: IFFALSE 73454
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
73271: LD_VAR 0 4
73275: PUSH
73276: LD_VAR 0 7
73280: ARRAY
73281: PPUSH
73282: LD_VAR 0 16
73286: PUSH
73287: LD_VAR 0 7
73291: ARRAY
73292: PUSH
73293: LD_INT 1
73295: ARRAY
73296: PUSH
73297: LD_INT 1
73299: ARRAY
73300: PPUSH
73301: LD_VAR 0 16
73305: PUSH
73306: LD_VAR 0 7
73310: ARRAY
73311: PUSH
73312: LD_INT 1
73314: ARRAY
73315: PUSH
73316: LD_INT 2
73318: ARRAY
73319: PPUSH
73320: CALL_OW 297
73324: PUSH
73325: LD_INT 6
73327: GREATER
73328: IFFALSE 73403
// begin if not HasTask ( group [ i ] ) then
73330: LD_VAR 0 4
73334: PUSH
73335: LD_VAR 0 7
73339: ARRAY
73340: PPUSH
73341: CALL_OW 314
73345: NOT
73346: IFFALSE 73401
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
73348: LD_VAR 0 4
73352: PUSH
73353: LD_VAR 0 7
73357: ARRAY
73358: PPUSH
73359: LD_VAR 0 16
73363: PUSH
73364: LD_VAR 0 7
73368: ARRAY
73369: PUSH
73370: LD_INT 1
73372: ARRAY
73373: PUSH
73374: LD_INT 1
73376: ARRAY
73377: PPUSH
73378: LD_VAR 0 16
73382: PUSH
73383: LD_VAR 0 7
73387: ARRAY
73388: PUSH
73389: LD_INT 1
73391: ARRAY
73392: PUSH
73393: LD_INT 2
73395: ARRAY
73396: PPUSH
73397: CALL_OW 114
// end else
73401: GO 73454
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
73403: LD_ADDR_VAR 0 15
73407: PUSH
73408: LD_VAR 0 16
73412: PUSH
73413: LD_VAR 0 7
73417: ARRAY
73418: PPUSH
73419: LD_INT 1
73421: PPUSH
73422: CALL_OW 3
73426: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
73427: LD_ADDR_VAR 0 16
73431: PUSH
73432: LD_VAR 0 16
73436: PPUSH
73437: LD_VAR 0 7
73441: PPUSH
73442: LD_VAR 0 15
73446: PPUSH
73447: CALL_OW 1
73451: ST_TO_ADDR
// continue ;
73452: GO 71997
// end ; end ; end else
73454: GO 76118
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
73456: LD_ADDR_VAR 0 14
73460: PUSH
73461: LD_INT 81
73463: PUSH
73464: LD_VAR 0 4
73468: PUSH
73469: LD_VAR 0 7
73473: ARRAY
73474: PPUSH
73475: CALL_OW 255
73479: PUSH
73480: EMPTY
73481: LIST
73482: LIST
73483: PPUSH
73484: CALL_OW 69
73488: ST_TO_ADDR
// if not tmp then
73489: LD_VAR 0 14
73493: NOT
73494: IFFALSE 73498
// continue ;
73496: GO 71997
// if f_ignore_area then
73498: LD_VAR 0 17
73502: IFFALSE 73590
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
73504: LD_ADDR_VAR 0 15
73508: PUSH
73509: LD_VAR 0 14
73513: PPUSH
73514: LD_INT 3
73516: PUSH
73517: LD_INT 92
73519: PUSH
73520: LD_VAR 0 17
73524: PUSH
73525: LD_INT 1
73527: ARRAY
73528: PUSH
73529: LD_VAR 0 17
73533: PUSH
73534: LD_INT 2
73536: ARRAY
73537: PUSH
73538: LD_VAR 0 17
73542: PUSH
73543: LD_INT 3
73545: ARRAY
73546: PUSH
73547: EMPTY
73548: LIST
73549: LIST
73550: LIST
73551: LIST
73552: PUSH
73553: EMPTY
73554: LIST
73555: LIST
73556: PPUSH
73557: CALL_OW 72
73561: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
73562: LD_VAR 0 14
73566: PUSH
73567: LD_VAR 0 15
73571: DIFF
73572: IFFALSE 73590
// tmp := tmp diff tmp2 ;
73574: LD_ADDR_VAR 0 14
73578: PUSH
73579: LD_VAR 0 14
73583: PUSH
73584: LD_VAR 0 15
73588: DIFF
73589: ST_TO_ADDR
// end ; if not f_murder then
73590: LD_VAR 0 20
73594: NOT
73595: IFFALSE 73653
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
73597: LD_ADDR_VAR 0 15
73601: PUSH
73602: LD_VAR 0 14
73606: PPUSH
73607: LD_INT 3
73609: PUSH
73610: LD_INT 50
73612: PUSH
73613: EMPTY
73614: LIST
73615: PUSH
73616: EMPTY
73617: LIST
73618: LIST
73619: PPUSH
73620: CALL_OW 72
73624: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
73625: LD_VAR 0 14
73629: PUSH
73630: LD_VAR 0 15
73634: DIFF
73635: IFFALSE 73653
// tmp := tmp diff tmp2 ;
73637: LD_ADDR_VAR 0 14
73641: PUSH
73642: LD_VAR 0 14
73646: PUSH
73647: LD_VAR 0 15
73651: DIFF
73652: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
73653: LD_ADDR_VAR 0 14
73657: PUSH
73658: LD_VAR 0 4
73662: PUSH
73663: LD_VAR 0 7
73667: ARRAY
73668: PPUSH
73669: LD_VAR 0 14
73673: PPUSH
73674: LD_INT 1
73676: PPUSH
73677: LD_INT 1
73679: PPUSH
73680: CALL 9862 0 4
73684: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
73685: LD_VAR 0 4
73689: PUSH
73690: LD_VAR 0 7
73694: ARRAY
73695: PPUSH
73696: CALL_OW 257
73700: PUSH
73701: LD_INT 1
73703: EQUAL
73704: IFFALSE 74152
// begin if WantPlant ( group [ i ] ) then
73706: LD_VAR 0 4
73710: PUSH
73711: LD_VAR 0 7
73715: ARRAY
73716: PPUSH
73717: CALL 9363 0 1
73721: IFFALSE 73725
// continue ;
73723: GO 71997
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
73725: LD_VAR 0 18
73729: PUSH
73730: LD_VAR 0 4
73734: PUSH
73735: LD_VAR 0 7
73739: ARRAY
73740: PPUSH
73741: CALL_OW 310
73745: NOT
73746: AND
73747: PUSH
73748: LD_VAR 0 14
73752: PUSH
73753: LD_INT 1
73755: ARRAY
73756: PUSH
73757: LD_VAR 0 14
73761: PPUSH
73762: LD_INT 21
73764: PUSH
73765: LD_INT 2
73767: PUSH
73768: EMPTY
73769: LIST
73770: LIST
73771: PUSH
73772: LD_INT 58
73774: PUSH
73775: EMPTY
73776: LIST
73777: PUSH
73778: EMPTY
73779: LIST
73780: LIST
73781: PPUSH
73782: CALL_OW 72
73786: IN
73787: AND
73788: IFFALSE 73824
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
73790: LD_VAR 0 4
73794: PUSH
73795: LD_VAR 0 7
73799: ARRAY
73800: PPUSH
73801: LD_VAR 0 14
73805: PUSH
73806: LD_INT 1
73808: ARRAY
73809: PPUSH
73810: CALL_OW 120
// attacking := true ;
73814: LD_ADDR_VAR 0 29
73818: PUSH
73819: LD_INT 1
73821: ST_TO_ADDR
// continue ;
73822: GO 71997
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
73824: LD_VAR 0 26
73828: PUSH
73829: LD_VAR 0 4
73833: PUSH
73834: LD_VAR 0 7
73838: ARRAY
73839: PPUSH
73840: CALL_OW 257
73844: PUSH
73845: LD_INT 1
73847: EQUAL
73848: AND
73849: PUSH
73850: LD_VAR 0 4
73854: PUSH
73855: LD_VAR 0 7
73859: ARRAY
73860: PPUSH
73861: CALL_OW 256
73865: PUSH
73866: LD_INT 800
73868: LESS
73869: AND
73870: PUSH
73871: LD_VAR 0 4
73875: PUSH
73876: LD_VAR 0 7
73880: ARRAY
73881: PPUSH
73882: CALL_OW 318
73886: NOT
73887: AND
73888: IFFALSE 73905
// ComCrawl ( group [ i ] ) ;
73890: LD_VAR 0 4
73894: PUSH
73895: LD_VAR 0 7
73899: ARRAY
73900: PPUSH
73901: CALL_OW 137
// if f_mines then
73905: LD_VAR 0 21
73909: IFFALSE 74152
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
73911: LD_VAR 0 14
73915: PUSH
73916: LD_INT 1
73918: ARRAY
73919: PPUSH
73920: CALL_OW 247
73924: PUSH
73925: LD_INT 3
73927: EQUAL
73928: PUSH
73929: LD_VAR 0 14
73933: PUSH
73934: LD_INT 1
73936: ARRAY
73937: PUSH
73938: LD_VAR 0 27
73942: IN
73943: NOT
73944: AND
73945: IFFALSE 74152
// begin x := GetX ( tmp [ 1 ] ) ;
73947: LD_ADDR_VAR 0 10
73951: PUSH
73952: LD_VAR 0 14
73956: PUSH
73957: LD_INT 1
73959: ARRAY
73960: PPUSH
73961: CALL_OW 250
73965: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
73966: LD_ADDR_VAR 0 11
73970: PUSH
73971: LD_VAR 0 14
73975: PUSH
73976: LD_INT 1
73978: ARRAY
73979: PPUSH
73980: CALL_OW 251
73984: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
73985: LD_ADDR_VAR 0 12
73989: PUSH
73990: LD_VAR 0 4
73994: PUSH
73995: LD_VAR 0 7
73999: ARRAY
74000: PPUSH
74001: CALL 36304 0 1
74005: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
74006: LD_VAR 0 4
74010: PUSH
74011: LD_VAR 0 7
74015: ARRAY
74016: PPUSH
74017: LD_VAR 0 10
74021: PPUSH
74022: LD_VAR 0 11
74026: PPUSH
74027: LD_VAR 0 14
74031: PUSH
74032: LD_INT 1
74034: ARRAY
74035: PPUSH
74036: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
74040: LD_VAR 0 4
74044: PUSH
74045: LD_VAR 0 7
74049: ARRAY
74050: PPUSH
74051: LD_VAR 0 10
74055: PPUSH
74056: LD_VAR 0 12
74060: PPUSH
74061: LD_INT 7
74063: PPUSH
74064: CALL_OW 272
74068: PPUSH
74069: LD_VAR 0 11
74073: PPUSH
74074: LD_VAR 0 12
74078: PPUSH
74079: LD_INT 7
74081: PPUSH
74082: CALL_OW 273
74086: PPUSH
74087: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
74091: LD_VAR 0 4
74095: PUSH
74096: LD_VAR 0 7
74100: ARRAY
74101: PPUSH
74102: LD_INT 71
74104: PPUSH
74105: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
74109: LD_ADDR_VAR 0 27
74113: PUSH
74114: LD_VAR 0 27
74118: PPUSH
74119: LD_VAR 0 27
74123: PUSH
74124: LD_INT 1
74126: PLUS
74127: PPUSH
74128: LD_VAR 0 14
74132: PUSH
74133: LD_INT 1
74135: ARRAY
74136: PPUSH
74137: CALL_OW 1
74141: ST_TO_ADDR
// attacking := true ;
74142: LD_ADDR_VAR 0 29
74146: PUSH
74147: LD_INT 1
74149: ST_TO_ADDR
// continue ;
74150: GO 71997
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
74152: LD_VAR 0 4
74156: PUSH
74157: LD_VAR 0 7
74161: ARRAY
74162: PPUSH
74163: CALL_OW 257
74167: PUSH
74168: LD_INT 17
74170: EQUAL
74171: PUSH
74172: LD_VAR 0 4
74176: PUSH
74177: LD_VAR 0 7
74181: ARRAY
74182: PPUSH
74183: CALL_OW 110
74187: PUSH
74188: LD_INT 71
74190: EQUAL
74191: NOT
74192: AND
74193: IFFALSE 74339
// begin attacking := false ;
74195: LD_ADDR_VAR 0 29
74199: PUSH
74200: LD_INT 0
74202: ST_TO_ADDR
// k := 5 ;
74203: LD_ADDR_VAR 0 9
74207: PUSH
74208: LD_INT 5
74210: ST_TO_ADDR
// if tmp < k then
74211: LD_VAR 0 14
74215: PUSH
74216: LD_VAR 0 9
74220: LESS
74221: IFFALSE 74233
// k := tmp ;
74223: LD_ADDR_VAR 0 9
74227: PUSH
74228: LD_VAR 0 14
74232: ST_TO_ADDR
// for j = 1 to k do
74233: LD_ADDR_VAR 0 8
74237: PUSH
74238: DOUBLE
74239: LD_INT 1
74241: DEC
74242: ST_TO_ADDR
74243: LD_VAR 0 9
74247: PUSH
74248: FOR_TO
74249: IFFALSE 74337
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
74251: LD_VAR 0 14
74255: PUSH
74256: LD_VAR 0 8
74260: ARRAY
74261: PUSH
74262: LD_VAR 0 14
74266: PPUSH
74267: LD_INT 58
74269: PUSH
74270: EMPTY
74271: LIST
74272: PPUSH
74273: CALL_OW 72
74277: IN
74278: NOT
74279: IFFALSE 74335
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
74281: LD_VAR 0 4
74285: PUSH
74286: LD_VAR 0 7
74290: ARRAY
74291: PPUSH
74292: LD_VAR 0 14
74296: PUSH
74297: LD_VAR 0 8
74301: ARRAY
74302: PPUSH
74303: CALL_OW 115
// attacking := true ;
74307: LD_ADDR_VAR 0 29
74311: PUSH
74312: LD_INT 1
74314: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
74315: LD_VAR 0 4
74319: PUSH
74320: LD_VAR 0 7
74324: ARRAY
74325: PPUSH
74326: LD_INT 71
74328: PPUSH
74329: CALL_OW 109
// continue ;
74333: GO 74248
// end ; end ;
74335: GO 74248
74337: POP
74338: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
74339: LD_VAR 0 4
74343: PUSH
74344: LD_VAR 0 7
74348: ARRAY
74349: PPUSH
74350: CALL_OW 257
74354: PUSH
74355: LD_INT 8
74357: EQUAL
74358: PUSH
74359: LD_VAR 0 4
74363: PUSH
74364: LD_VAR 0 7
74368: ARRAY
74369: PPUSH
74370: CALL_OW 264
74374: PUSH
74375: LD_INT 28
74377: PUSH
74378: LD_INT 45
74380: PUSH
74381: LD_INT 7
74383: PUSH
74384: LD_INT 47
74386: PUSH
74387: EMPTY
74388: LIST
74389: LIST
74390: LIST
74391: LIST
74392: IN
74393: OR
74394: IFFALSE 74650
// begin attacking := false ;
74396: LD_ADDR_VAR 0 29
74400: PUSH
74401: LD_INT 0
74403: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
74404: LD_VAR 0 14
74408: PUSH
74409: LD_INT 1
74411: ARRAY
74412: PPUSH
74413: CALL_OW 266
74417: PUSH
74418: LD_INT 32
74420: PUSH
74421: LD_INT 31
74423: PUSH
74424: LD_INT 33
74426: PUSH
74427: LD_INT 4
74429: PUSH
74430: LD_INT 5
74432: PUSH
74433: EMPTY
74434: LIST
74435: LIST
74436: LIST
74437: LIST
74438: LIST
74439: IN
74440: IFFALSE 74626
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
74442: LD_ADDR_VAR 0 9
74446: PUSH
74447: LD_VAR 0 14
74451: PUSH
74452: LD_INT 1
74454: ARRAY
74455: PPUSH
74456: CALL_OW 266
74460: PPUSH
74461: LD_VAR 0 14
74465: PUSH
74466: LD_INT 1
74468: ARRAY
74469: PPUSH
74470: CALL_OW 250
74474: PPUSH
74475: LD_VAR 0 14
74479: PUSH
74480: LD_INT 1
74482: ARRAY
74483: PPUSH
74484: CALL_OW 251
74488: PPUSH
74489: LD_VAR 0 14
74493: PUSH
74494: LD_INT 1
74496: ARRAY
74497: PPUSH
74498: CALL_OW 254
74502: PPUSH
74503: LD_VAR 0 14
74507: PUSH
74508: LD_INT 1
74510: ARRAY
74511: PPUSH
74512: CALL_OW 248
74516: PPUSH
74517: LD_INT 0
74519: PPUSH
74520: CALL 17674 0 6
74524: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
74525: LD_ADDR_VAR 0 8
74529: PUSH
74530: LD_VAR 0 4
74534: PUSH
74535: LD_VAR 0 7
74539: ARRAY
74540: PPUSH
74541: LD_VAR 0 9
74545: PPUSH
74546: CALL 36344 0 2
74550: ST_TO_ADDR
// if j then
74551: LD_VAR 0 8
74555: IFFALSE 74624
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
74557: LD_VAR 0 8
74561: PUSH
74562: LD_INT 1
74564: ARRAY
74565: PPUSH
74566: LD_VAR 0 8
74570: PUSH
74571: LD_INT 2
74573: ARRAY
74574: PPUSH
74575: CALL_OW 488
74579: IFFALSE 74624
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
74581: LD_VAR 0 4
74585: PUSH
74586: LD_VAR 0 7
74590: ARRAY
74591: PPUSH
74592: LD_VAR 0 8
74596: PUSH
74597: LD_INT 1
74599: ARRAY
74600: PPUSH
74601: LD_VAR 0 8
74605: PUSH
74606: LD_INT 2
74608: ARRAY
74609: PPUSH
74610: CALL_OW 116
// attacking := true ;
74614: LD_ADDR_VAR 0 29
74618: PUSH
74619: LD_INT 1
74621: ST_TO_ADDR
// continue ;
74622: GO 71997
// end ; end else
74624: GO 74650
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
74626: LD_VAR 0 4
74630: PUSH
74631: LD_VAR 0 7
74635: ARRAY
74636: PPUSH
74637: LD_VAR 0 14
74641: PUSH
74642: LD_INT 1
74644: ARRAY
74645: PPUSH
74646: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
74650: LD_VAR 0 4
74654: PUSH
74655: LD_VAR 0 7
74659: ARRAY
74660: PPUSH
74661: CALL_OW 265
74665: PUSH
74666: LD_INT 11
74668: EQUAL
74669: IFFALSE 74947
// begin k := 10 ;
74671: LD_ADDR_VAR 0 9
74675: PUSH
74676: LD_INT 10
74678: ST_TO_ADDR
// x := 0 ;
74679: LD_ADDR_VAR 0 10
74683: PUSH
74684: LD_INT 0
74686: ST_TO_ADDR
// if tmp < k then
74687: LD_VAR 0 14
74691: PUSH
74692: LD_VAR 0 9
74696: LESS
74697: IFFALSE 74709
// k := tmp ;
74699: LD_ADDR_VAR 0 9
74703: PUSH
74704: LD_VAR 0 14
74708: ST_TO_ADDR
// for j = k downto 1 do
74709: LD_ADDR_VAR 0 8
74713: PUSH
74714: DOUBLE
74715: LD_VAR 0 9
74719: INC
74720: ST_TO_ADDR
74721: LD_INT 1
74723: PUSH
74724: FOR_DOWNTO
74725: IFFALSE 74800
// begin if GetType ( tmp [ j ] ) = unit_human then
74727: LD_VAR 0 14
74731: PUSH
74732: LD_VAR 0 8
74736: ARRAY
74737: PPUSH
74738: CALL_OW 247
74742: PUSH
74743: LD_INT 1
74745: EQUAL
74746: IFFALSE 74798
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
74748: LD_VAR 0 4
74752: PUSH
74753: LD_VAR 0 7
74757: ARRAY
74758: PPUSH
74759: LD_VAR 0 14
74763: PUSH
74764: LD_VAR 0 8
74768: ARRAY
74769: PPUSH
74770: CALL 36615 0 2
// x := tmp [ j ] ;
74774: LD_ADDR_VAR 0 10
74778: PUSH
74779: LD_VAR 0 14
74783: PUSH
74784: LD_VAR 0 8
74788: ARRAY
74789: ST_TO_ADDR
// attacking := true ;
74790: LD_ADDR_VAR 0 29
74794: PUSH
74795: LD_INT 1
74797: ST_TO_ADDR
// end ; end ;
74798: GO 74724
74800: POP
74801: POP
// if not x then
74802: LD_VAR 0 10
74806: NOT
74807: IFFALSE 74947
// begin attacking := true ;
74809: LD_ADDR_VAR 0 29
74813: PUSH
74814: LD_INT 1
74816: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
74817: LD_VAR 0 4
74821: PUSH
74822: LD_VAR 0 7
74826: ARRAY
74827: PPUSH
74828: CALL_OW 250
74832: PPUSH
74833: LD_VAR 0 4
74837: PUSH
74838: LD_VAR 0 7
74842: ARRAY
74843: PPUSH
74844: CALL_OW 251
74848: PPUSH
74849: CALL_OW 546
74853: PUSH
74854: LD_INT 2
74856: ARRAY
74857: PUSH
74858: LD_VAR 0 14
74862: PUSH
74863: LD_INT 1
74865: ARRAY
74866: PPUSH
74867: CALL_OW 250
74871: PPUSH
74872: LD_VAR 0 14
74876: PUSH
74877: LD_INT 1
74879: ARRAY
74880: PPUSH
74881: CALL_OW 251
74885: PPUSH
74886: CALL_OW 546
74890: PUSH
74891: LD_INT 2
74893: ARRAY
74894: EQUAL
74895: IFFALSE 74923
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
74897: LD_VAR 0 4
74901: PUSH
74902: LD_VAR 0 7
74906: ARRAY
74907: PPUSH
74908: LD_VAR 0 14
74912: PUSH
74913: LD_INT 1
74915: ARRAY
74916: PPUSH
74917: CALL 36615 0 2
74921: GO 74947
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
74923: LD_VAR 0 4
74927: PUSH
74928: LD_VAR 0 7
74932: ARRAY
74933: PPUSH
74934: LD_VAR 0 14
74938: PUSH
74939: LD_INT 1
74941: ARRAY
74942: PPUSH
74943: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
74947: LD_VAR 0 4
74951: PUSH
74952: LD_VAR 0 7
74956: ARRAY
74957: PPUSH
74958: CALL_OW 264
74962: PUSH
74963: LD_INT 29
74965: EQUAL
74966: IFFALSE 75332
// begin if WantsToAttack ( group [ i ] ) in bombed then
74968: LD_VAR 0 4
74972: PUSH
74973: LD_VAR 0 7
74977: ARRAY
74978: PPUSH
74979: CALL_OW 319
74983: PUSH
74984: LD_VAR 0 28
74988: IN
74989: IFFALSE 74993
// continue ;
74991: GO 71997
// k := 8 ;
74993: LD_ADDR_VAR 0 9
74997: PUSH
74998: LD_INT 8
75000: ST_TO_ADDR
// x := 0 ;
75001: LD_ADDR_VAR 0 10
75005: PUSH
75006: LD_INT 0
75008: ST_TO_ADDR
// if tmp < k then
75009: LD_VAR 0 14
75013: PUSH
75014: LD_VAR 0 9
75018: LESS
75019: IFFALSE 75031
// k := tmp ;
75021: LD_ADDR_VAR 0 9
75025: PUSH
75026: LD_VAR 0 14
75030: ST_TO_ADDR
// for j = 1 to k do
75031: LD_ADDR_VAR 0 8
75035: PUSH
75036: DOUBLE
75037: LD_INT 1
75039: DEC
75040: ST_TO_ADDR
75041: LD_VAR 0 9
75045: PUSH
75046: FOR_TO
75047: IFFALSE 75179
// begin if GetType ( tmp [ j ] ) = unit_building then
75049: LD_VAR 0 14
75053: PUSH
75054: LD_VAR 0 8
75058: ARRAY
75059: PPUSH
75060: CALL_OW 247
75064: PUSH
75065: LD_INT 3
75067: EQUAL
75068: IFFALSE 75177
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
75070: LD_VAR 0 14
75074: PUSH
75075: LD_VAR 0 8
75079: ARRAY
75080: PUSH
75081: LD_VAR 0 28
75085: IN
75086: NOT
75087: PUSH
75088: LD_VAR 0 14
75092: PUSH
75093: LD_VAR 0 8
75097: ARRAY
75098: PPUSH
75099: CALL_OW 313
75103: AND
75104: IFFALSE 75177
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
75106: LD_VAR 0 4
75110: PUSH
75111: LD_VAR 0 7
75115: ARRAY
75116: PPUSH
75117: LD_VAR 0 14
75121: PUSH
75122: LD_VAR 0 8
75126: ARRAY
75127: PPUSH
75128: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
75132: LD_ADDR_VAR 0 28
75136: PUSH
75137: LD_VAR 0 28
75141: PPUSH
75142: LD_VAR 0 28
75146: PUSH
75147: LD_INT 1
75149: PLUS
75150: PPUSH
75151: LD_VAR 0 14
75155: PUSH
75156: LD_VAR 0 8
75160: ARRAY
75161: PPUSH
75162: CALL_OW 1
75166: ST_TO_ADDR
// attacking := true ;
75167: LD_ADDR_VAR 0 29
75171: PUSH
75172: LD_INT 1
75174: ST_TO_ADDR
// break ;
75175: GO 75179
// end ; end ;
75177: GO 75046
75179: POP
75180: POP
// if not attacking and f_attack_depot then
75181: LD_VAR 0 29
75185: NOT
75186: PUSH
75187: LD_VAR 0 25
75191: AND
75192: IFFALSE 75287
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75194: LD_ADDR_VAR 0 13
75198: PUSH
75199: LD_VAR 0 14
75203: PPUSH
75204: LD_INT 2
75206: PUSH
75207: LD_INT 30
75209: PUSH
75210: LD_INT 0
75212: PUSH
75213: EMPTY
75214: LIST
75215: LIST
75216: PUSH
75217: LD_INT 30
75219: PUSH
75220: LD_INT 1
75222: PUSH
75223: EMPTY
75224: LIST
75225: LIST
75226: PUSH
75227: EMPTY
75228: LIST
75229: LIST
75230: LIST
75231: PPUSH
75232: CALL_OW 72
75236: ST_TO_ADDR
// if z then
75237: LD_VAR 0 13
75241: IFFALSE 75287
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
75243: LD_VAR 0 4
75247: PUSH
75248: LD_VAR 0 7
75252: ARRAY
75253: PPUSH
75254: LD_VAR 0 13
75258: PPUSH
75259: LD_VAR 0 4
75263: PUSH
75264: LD_VAR 0 7
75268: ARRAY
75269: PPUSH
75270: CALL_OW 74
75274: PPUSH
75275: CALL_OW 115
// attacking := true ;
75279: LD_ADDR_VAR 0 29
75283: PUSH
75284: LD_INT 1
75286: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
75287: LD_VAR 0 4
75291: PUSH
75292: LD_VAR 0 7
75296: ARRAY
75297: PPUSH
75298: CALL_OW 256
75302: PUSH
75303: LD_INT 500
75305: LESS
75306: IFFALSE 75332
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
75308: LD_VAR 0 4
75312: PUSH
75313: LD_VAR 0 7
75317: ARRAY
75318: PPUSH
75319: LD_VAR 0 14
75323: PUSH
75324: LD_INT 1
75326: ARRAY
75327: PPUSH
75328: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
75332: LD_VAR 0 4
75336: PUSH
75337: LD_VAR 0 7
75341: ARRAY
75342: PPUSH
75343: CALL_OW 264
75347: PUSH
75348: LD_INT 49
75350: EQUAL
75351: IFFALSE 75472
// begin if not HasTask ( group [ i ] ) then
75353: LD_VAR 0 4
75357: PUSH
75358: LD_VAR 0 7
75362: ARRAY
75363: PPUSH
75364: CALL_OW 314
75368: NOT
75369: IFFALSE 75472
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
75371: LD_ADDR_VAR 0 9
75375: PUSH
75376: LD_INT 81
75378: PUSH
75379: LD_VAR 0 4
75383: PUSH
75384: LD_VAR 0 7
75388: ARRAY
75389: PPUSH
75390: CALL_OW 255
75394: PUSH
75395: EMPTY
75396: LIST
75397: LIST
75398: PPUSH
75399: CALL_OW 69
75403: PPUSH
75404: LD_VAR 0 4
75408: PUSH
75409: LD_VAR 0 7
75413: ARRAY
75414: PPUSH
75415: CALL_OW 74
75419: ST_TO_ADDR
// if k then
75420: LD_VAR 0 9
75424: IFFALSE 75472
// if GetDistUnits ( group [ i ] , k ) > 10 then
75426: LD_VAR 0 4
75430: PUSH
75431: LD_VAR 0 7
75435: ARRAY
75436: PPUSH
75437: LD_VAR 0 9
75441: PPUSH
75442: CALL_OW 296
75446: PUSH
75447: LD_INT 10
75449: GREATER
75450: IFFALSE 75472
// ComMoveUnit ( group [ i ] , k ) ;
75452: LD_VAR 0 4
75456: PUSH
75457: LD_VAR 0 7
75461: ARRAY
75462: PPUSH
75463: LD_VAR 0 9
75467: PPUSH
75468: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
75472: LD_VAR 0 4
75476: PUSH
75477: LD_VAR 0 7
75481: ARRAY
75482: PPUSH
75483: CALL_OW 256
75487: PUSH
75488: LD_INT 250
75490: LESS
75491: PUSH
75492: LD_VAR 0 4
75496: PUSH
75497: LD_VAR 0 7
75501: ARRAY
75502: PUSH
75503: LD_INT 21
75505: PUSH
75506: LD_INT 2
75508: PUSH
75509: EMPTY
75510: LIST
75511: LIST
75512: PUSH
75513: LD_INT 23
75515: PUSH
75516: LD_INT 2
75518: PUSH
75519: EMPTY
75520: LIST
75521: LIST
75522: PUSH
75523: EMPTY
75524: LIST
75525: LIST
75526: PPUSH
75527: CALL_OW 69
75531: IN
75532: AND
75533: IFFALSE 75658
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
75535: LD_ADDR_VAR 0 9
75539: PUSH
75540: LD_OWVAR 3
75544: PUSH
75545: LD_VAR 0 4
75549: PUSH
75550: LD_VAR 0 7
75554: ARRAY
75555: DIFF
75556: PPUSH
75557: LD_VAR 0 4
75561: PUSH
75562: LD_VAR 0 7
75566: ARRAY
75567: PPUSH
75568: CALL_OW 74
75572: ST_TO_ADDR
// if not k then
75573: LD_VAR 0 9
75577: NOT
75578: IFFALSE 75582
// continue ;
75580: GO 71997
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
75582: LD_VAR 0 9
75586: PUSH
75587: LD_INT 81
75589: PUSH
75590: LD_VAR 0 4
75594: PUSH
75595: LD_VAR 0 7
75599: ARRAY
75600: PPUSH
75601: CALL_OW 255
75605: PUSH
75606: EMPTY
75607: LIST
75608: LIST
75609: PPUSH
75610: CALL_OW 69
75614: IN
75615: PUSH
75616: LD_VAR 0 9
75620: PPUSH
75621: LD_VAR 0 4
75625: PUSH
75626: LD_VAR 0 7
75630: ARRAY
75631: PPUSH
75632: CALL_OW 296
75636: PUSH
75637: LD_INT 5
75639: LESS
75640: AND
75641: IFFALSE 75658
// ComAutodestruct ( group [ i ] ) ;
75643: LD_VAR 0 4
75647: PUSH
75648: LD_VAR 0 7
75652: ARRAY
75653: PPUSH
75654: CALL 36513 0 1
// end ; if f_attack_depot then
75658: LD_VAR 0 25
75662: IFFALSE 75774
// begin k := 6 ;
75664: LD_ADDR_VAR 0 9
75668: PUSH
75669: LD_INT 6
75671: ST_TO_ADDR
// if tmp < k then
75672: LD_VAR 0 14
75676: PUSH
75677: LD_VAR 0 9
75681: LESS
75682: IFFALSE 75694
// k := tmp ;
75684: LD_ADDR_VAR 0 9
75688: PUSH
75689: LD_VAR 0 14
75693: ST_TO_ADDR
// for j = 1 to k do
75694: LD_ADDR_VAR 0 8
75698: PUSH
75699: DOUBLE
75700: LD_INT 1
75702: DEC
75703: ST_TO_ADDR
75704: LD_VAR 0 9
75708: PUSH
75709: FOR_TO
75710: IFFALSE 75772
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
75712: LD_VAR 0 8
75716: PPUSH
75717: CALL_OW 266
75721: PUSH
75722: LD_INT 0
75724: PUSH
75725: LD_INT 1
75727: PUSH
75728: EMPTY
75729: LIST
75730: LIST
75731: IN
75732: IFFALSE 75770
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
75734: LD_VAR 0 4
75738: PUSH
75739: LD_VAR 0 7
75743: ARRAY
75744: PPUSH
75745: LD_VAR 0 14
75749: PUSH
75750: LD_VAR 0 8
75754: ARRAY
75755: PPUSH
75756: CALL_OW 115
// attacking := true ;
75760: LD_ADDR_VAR 0 29
75764: PUSH
75765: LD_INT 1
75767: ST_TO_ADDR
// break ;
75768: GO 75772
// end ;
75770: GO 75709
75772: POP
75773: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
75774: LD_VAR 0 4
75778: PUSH
75779: LD_VAR 0 7
75783: ARRAY
75784: PPUSH
75785: CALL_OW 302
75789: PUSH
75790: LD_VAR 0 29
75794: NOT
75795: AND
75796: IFFALSE 76118
// begin if GetTag ( group [ i ] ) = 71 then
75798: LD_VAR 0 4
75802: PUSH
75803: LD_VAR 0 7
75807: ARRAY
75808: PPUSH
75809: CALL_OW 110
75813: PUSH
75814: LD_INT 71
75816: EQUAL
75817: IFFALSE 75858
// begin if HasTask ( group [ i ] ) then
75819: LD_VAR 0 4
75823: PUSH
75824: LD_VAR 0 7
75828: ARRAY
75829: PPUSH
75830: CALL_OW 314
75834: IFFALSE 75840
// continue else
75836: GO 71997
75838: GO 75858
// SetTag ( group [ i ] , 0 ) ;
75840: LD_VAR 0 4
75844: PUSH
75845: LD_VAR 0 7
75849: ARRAY
75850: PPUSH
75851: LD_INT 0
75853: PPUSH
75854: CALL_OW 109
// end ; k := 8 ;
75858: LD_ADDR_VAR 0 9
75862: PUSH
75863: LD_INT 8
75865: ST_TO_ADDR
// x := 0 ;
75866: LD_ADDR_VAR 0 10
75870: PUSH
75871: LD_INT 0
75873: ST_TO_ADDR
// if tmp < k then
75874: LD_VAR 0 14
75878: PUSH
75879: LD_VAR 0 9
75883: LESS
75884: IFFALSE 75896
// k := tmp ;
75886: LD_ADDR_VAR 0 9
75890: PUSH
75891: LD_VAR 0 14
75895: ST_TO_ADDR
// for j = 1 to k do
75896: LD_ADDR_VAR 0 8
75900: PUSH
75901: DOUBLE
75902: LD_INT 1
75904: DEC
75905: ST_TO_ADDR
75906: LD_VAR 0 9
75910: PUSH
75911: FOR_TO
75912: IFFALSE 76010
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
75914: LD_VAR 0 14
75918: PUSH
75919: LD_VAR 0 8
75923: ARRAY
75924: PPUSH
75925: CALL_OW 247
75929: PUSH
75930: LD_INT 1
75932: EQUAL
75933: PUSH
75934: LD_VAR 0 14
75938: PUSH
75939: LD_VAR 0 8
75943: ARRAY
75944: PPUSH
75945: CALL_OW 256
75949: PUSH
75950: LD_INT 250
75952: LESS
75953: PUSH
75954: LD_VAR 0 20
75958: AND
75959: PUSH
75960: LD_VAR 0 20
75964: NOT
75965: PUSH
75966: LD_VAR 0 14
75970: PUSH
75971: LD_VAR 0 8
75975: ARRAY
75976: PPUSH
75977: CALL_OW 256
75981: PUSH
75982: LD_INT 250
75984: GREATEREQUAL
75985: AND
75986: OR
75987: AND
75988: IFFALSE 76008
// begin x := tmp [ j ] ;
75990: LD_ADDR_VAR 0 10
75994: PUSH
75995: LD_VAR 0 14
75999: PUSH
76000: LD_VAR 0 8
76004: ARRAY
76005: ST_TO_ADDR
// break ;
76006: GO 76010
// end ;
76008: GO 75911
76010: POP
76011: POP
// if x then
76012: LD_VAR 0 10
76016: IFFALSE 76040
// ComAttackUnit ( group [ i ] , x ) else
76018: LD_VAR 0 4
76022: PUSH
76023: LD_VAR 0 7
76027: ARRAY
76028: PPUSH
76029: LD_VAR 0 10
76033: PPUSH
76034: CALL_OW 115
76038: GO 76064
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
76040: LD_VAR 0 4
76044: PUSH
76045: LD_VAR 0 7
76049: ARRAY
76050: PPUSH
76051: LD_VAR 0 14
76055: PUSH
76056: LD_INT 1
76058: ARRAY
76059: PPUSH
76060: CALL_OW 115
// if not HasTask ( group [ i ] ) then
76064: LD_VAR 0 4
76068: PUSH
76069: LD_VAR 0 7
76073: ARRAY
76074: PPUSH
76075: CALL_OW 314
76079: NOT
76080: IFFALSE 76118
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
76082: LD_VAR 0 4
76086: PUSH
76087: LD_VAR 0 7
76091: ARRAY
76092: PPUSH
76093: LD_VAR 0 14
76097: PPUSH
76098: LD_VAR 0 4
76102: PUSH
76103: LD_VAR 0 7
76107: ARRAY
76108: PPUSH
76109: CALL_OW 74
76113: PPUSH
76114: CALL_OW 115
// end ; end ; end ;
76118: GO 71997
76120: POP
76121: POP
// wait ( 0 0$2 ) ;
76122: LD_INT 70
76124: PPUSH
76125: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
76129: LD_VAR 0 4
76133: NOT
76134: PUSH
76135: LD_VAR 0 4
76139: PUSH
76140: EMPTY
76141: EQUAL
76142: OR
76143: PUSH
76144: LD_INT 81
76146: PUSH
76147: LD_VAR 0 35
76151: PUSH
76152: EMPTY
76153: LIST
76154: LIST
76155: PPUSH
76156: CALL_OW 69
76160: NOT
76161: OR
76162: IFFALSE 71982
// end ;
76164: LD_VAR 0 2
76168: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
76169: LD_INT 0
76171: PPUSH
76172: PPUSH
76173: PPUSH
76174: PPUSH
76175: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
76176: LD_VAR 0 1
76180: NOT
76181: PUSH
76182: LD_EXP 14
76186: PUSH
76187: LD_VAR 0 1
76191: ARRAY
76192: NOT
76193: OR
76194: PUSH
76195: LD_VAR 0 2
76199: NOT
76200: OR
76201: PUSH
76202: LD_VAR 0 3
76206: NOT
76207: OR
76208: IFFALSE 76212
// exit ;
76210: GO 76725
// side := mc_sides [ base ] ;
76212: LD_ADDR_VAR 0 6
76216: PUSH
76217: LD_EXP 40
76221: PUSH
76222: LD_VAR 0 1
76226: ARRAY
76227: ST_TO_ADDR
// if not side then
76228: LD_VAR 0 6
76232: NOT
76233: IFFALSE 76237
// exit ;
76235: GO 76725
// for i in solds do
76237: LD_ADDR_VAR 0 7
76241: PUSH
76242: LD_VAR 0 2
76246: PUSH
76247: FOR_IN
76248: IFFALSE 76309
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
76250: LD_VAR 0 7
76254: PPUSH
76255: CALL_OW 310
76259: PPUSH
76260: CALL_OW 266
76264: PUSH
76265: LD_INT 32
76267: PUSH
76268: LD_INT 31
76270: PUSH
76271: EMPTY
76272: LIST
76273: LIST
76274: IN
76275: IFFALSE 76295
// solds := solds diff i else
76277: LD_ADDR_VAR 0 2
76281: PUSH
76282: LD_VAR 0 2
76286: PUSH
76287: LD_VAR 0 7
76291: DIFF
76292: ST_TO_ADDR
76293: GO 76307
// SetTag ( i , 18 ) ;
76295: LD_VAR 0 7
76299: PPUSH
76300: LD_INT 18
76302: PPUSH
76303: CALL_OW 109
76307: GO 76247
76309: POP
76310: POP
// if not solds then
76311: LD_VAR 0 2
76315: NOT
76316: IFFALSE 76320
// exit ;
76318: GO 76725
// repeat wait ( 0 0$1 ) ;
76320: LD_INT 35
76322: PPUSH
76323: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
76327: LD_ADDR_VAR 0 5
76331: PUSH
76332: LD_VAR 0 6
76336: PPUSH
76337: LD_VAR 0 3
76341: PPUSH
76342: CALL 6228 0 2
76346: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
76347: LD_EXP 14
76351: PUSH
76352: LD_VAR 0 1
76356: ARRAY
76357: NOT
76358: PUSH
76359: LD_EXP 14
76363: PUSH
76364: LD_VAR 0 1
76368: ARRAY
76369: PUSH
76370: EMPTY
76371: EQUAL
76372: OR
76373: IFFALSE 76410
// begin for i in solds do
76375: LD_ADDR_VAR 0 7
76379: PUSH
76380: LD_VAR 0 2
76384: PUSH
76385: FOR_IN
76386: IFFALSE 76399
// ComStop ( i ) ;
76388: LD_VAR 0 7
76392: PPUSH
76393: CALL_OW 141
76397: GO 76385
76399: POP
76400: POP
// solds := [ ] ;
76401: LD_ADDR_VAR 0 2
76405: PUSH
76406: EMPTY
76407: ST_TO_ADDR
// exit ;
76408: GO 76725
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
76410: LD_VAR 0 5
76414: NOT
76415: PUSH
76416: LD_VAR 0 5
76420: PUSH
76421: LD_INT 3
76423: GREATER
76424: OR
76425: PUSH
76426: LD_EXP 36
76430: PUSH
76431: LD_VAR 0 1
76435: ARRAY
76436: OR
76437: IFFALSE 76478
// begin for i in solds do
76439: LD_ADDR_VAR 0 7
76443: PUSH
76444: LD_VAR 0 2
76448: PUSH
76449: FOR_IN
76450: IFFALSE 76474
// if HasTask ( i ) then
76452: LD_VAR 0 7
76456: PPUSH
76457: CALL_OW 314
76461: IFFALSE 76472
// ComStop ( i ) ;
76463: LD_VAR 0 7
76467: PPUSH
76468: CALL_OW 141
76472: GO 76449
76474: POP
76475: POP
// break ;
76476: GO 76713
// end ; for i in solds do
76478: LD_ADDR_VAR 0 7
76482: PUSH
76483: LD_VAR 0 2
76487: PUSH
76488: FOR_IN
76489: IFFALSE 76705
// begin if IsInUnit ( i ) then
76491: LD_VAR 0 7
76495: PPUSH
76496: CALL_OW 310
76500: IFFALSE 76511
// ComExitBuilding ( i ) ;
76502: LD_VAR 0 7
76506: PPUSH
76507: CALL_OW 122
// if GetLives ( i ) > 333 then
76511: LD_VAR 0 7
76515: PPUSH
76516: CALL_OW 256
76520: PUSH
76521: LD_INT 333
76523: GREATER
76524: IFFALSE 76552
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
76526: LD_VAR 0 7
76530: PPUSH
76531: LD_VAR 0 5
76535: PPUSH
76536: LD_VAR 0 7
76540: PPUSH
76541: CALL_OW 74
76545: PPUSH
76546: CALL_OW 115
76550: GO 76703
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
76552: LD_ADDR_VAR 0 8
76556: PUSH
76557: LD_EXP 14
76561: PUSH
76562: LD_VAR 0 1
76566: ARRAY
76567: PPUSH
76568: LD_INT 2
76570: PUSH
76571: LD_INT 30
76573: PUSH
76574: LD_INT 0
76576: PUSH
76577: EMPTY
76578: LIST
76579: LIST
76580: PUSH
76581: LD_INT 30
76583: PUSH
76584: LD_INT 1
76586: PUSH
76587: EMPTY
76588: LIST
76589: LIST
76590: PUSH
76591: LD_INT 30
76593: PUSH
76594: LD_INT 6
76596: PUSH
76597: EMPTY
76598: LIST
76599: LIST
76600: PUSH
76601: EMPTY
76602: LIST
76603: LIST
76604: LIST
76605: LIST
76606: PPUSH
76607: CALL_OW 72
76611: PPUSH
76612: LD_VAR 0 7
76616: PPUSH
76617: CALL_OW 74
76621: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
76622: LD_VAR 0 7
76626: PPUSH
76627: LD_VAR 0 8
76631: PPUSH
76632: CALL_OW 250
76636: PPUSH
76637: LD_INT 3
76639: PPUSH
76640: LD_INT 5
76642: PPUSH
76643: CALL_OW 272
76647: PPUSH
76648: LD_VAR 0 8
76652: PPUSH
76653: CALL_OW 251
76657: PPUSH
76658: LD_INT 3
76660: PPUSH
76661: LD_INT 5
76663: PPUSH
76664: CALL_OW 273
76668: PPUSH
76669: CALL_OW 111
// SetTag ( i , 0 ) ;
76673: LD_VAR 0 7
76677: PPUSH
76678: LD_INT 0
76680: PPUSH
76681: CALL_OW 109
// solds := solds diff i ;
76685: LD_ADDR_VAR 0 2
76689: PUSH
76690: LD_VAR 0 2
76694: PUSH
76695: LD_VAR 0 7
76699: DIFF
76700: ST_TO_ADDR
// continue ;
76701: GO 76488
// end ; end ;
76703: GO 76488
76705: POP
76706: POP
// until solds ;
76707: LD_VAR 0 2
76711: IFFALSE 76320
// MC_Reset ( base , 18 ) ;
76713: LD_VAR 0 1
76717: PPUSH
76718: LD_INT 18
76720: PPUSH
76721: CALL 45371 0 2
// end ;
76725: LD_VAR 0 4
76729: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
76730: LD_INT 0
76732: PPUSH
76733: PPUSH
76734: PPUSH
76735: PPUSH
76736: PPUSH
76737: PPUSH
76738: PPUSH
76739: PPUSH
76740: PPUSH
76741: PPUSH
76742: PPUSH
76743: PPUSH
76744: PPUSH
76745: PPUSH
76746: PPUSH
76747: PPUSH
76748: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
76749: LD_ADDR_VAR 0 13
76753: PUSH
76754: LD_EXP 14
76758: PUSH
76759: LD_VAR 0 1
76763: ARRAY
76764: PPUSH
76765: LD_INT 25
76767: PUSH
76768: LD_INT 3
76770: PUSH
76771: EMPTY
76772: LIST
76773: LIST
76774: PPUSH
76775: CALL_OW 72
76779: ST_TO_ADDR
// if mc_remote_driver [ base ] then
76780: LD_EXP 54
76784: PUSH
76785: LD_VAR 0 1
76789: ARRAY
76790: IFFALSE 76814
// mechs := mechs diff mc_remote_driver [ base ] ;
76792: LD_ADDR_VAR 0 13
76796: PUSH
76797: LD_VAR 0 13
76801: PUSH
76802: LD_EXP 54
76806: PUSH
76807: LD_VAR 0 1
76811: ARRAY
76812: DIFF
76813: ST_TO_ADDR
// for i in mechs do
76814: LD_ADDR_VAR 0 5
76818: PUSH
76819: LD_VAR 0 13
76823: PUSH
76824: FOR_IN
76825: IFFALSE 76860
// if GetTag ( i ) > 0 then
76827: LD_VAR 0 5
76831: PPUSH
76832: CALL_OW 110
76836: PUSH
76837: LD_INT 0
76839: GREATER
76840: IFFALSE 76858
// mechs := mechs diff i ;
76842: LD_ADDR_VAR 0 13
76846: PUSH
76847: LD_VAR 0 13
76851: PUSH
76852: LD_VAR 0 5
76856: DIFF
76857: ST_TO_ADDR
76858: GO 76824
76860: POP
76861: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
76862: LD_ADDR_VAR 0 9
76866: PUSH
76867: LD_EXP 14
76871: PUSH
76872: LD_VAR 0 1
76876: ARRAY
76877: PPUSH
76878: LD_INT 2
76880: PUSH
76881: LD_INT 25
76883: PUSH
76884: LD_INT 1
76886: PUSH
76887: EMPTY
76888: LIST
76889: LIST
76890: PUSH
76891: LD_INT 25
76893: PUSH
76894: LD_INT 5
76896: PUSH
76897: EMPTY
76898: LIST
76899: LIST
76900: PUSH
76901: LD_INT 25
76903: PUSH
76904: LD_INT 8
76906: PUSH
76907: EMPTY
76908: LIST
76909: LIST
76910: PUSH
76911: LD_INT 25
76913: PUSH
76914: LD_INT 9
76916: PUSH
76917: EMPTY
76918: LIST
76919: LIST
76920: PUSH
76921: EMPTY
76922: LIST
76923: LIST
76924: LIST
76925: LIST
76926: LIST
76927: PPUSH
76928: CALL_OW 72
76932: ST_TO_ADDR
// if not defenders and not solds then
76933: LD_VAR 0 2
76937: NOT
76938: PUSH
76939: LD_VAR 0 9
76943: NOT
76944: AND
76945: IFFALSE 76949
// exit ;
76947: GO 78575
// depot_under_attack := false ;
76949: LD_ADDR_VAR 0 17
76953: PUSH
76954: LD_INT 0
76956: ST_TO_ADDR
// sold_defenders := [ ] ;
76957: LD_ADDR_VAR 0 18
76961: PUSH
76962: EMPTY
76963: ST_TO_ADDR
// if mechs then
76964: LD_VAR 0 13
76968: IFFALSE 77097
// for i in defenders do
76970: LD_ADDR_VAR 0 5
76974: PUSH
76975: LD_VAR 0 2
76979: PUSH
76980: FOR_IN
76981: IFFALSE 77095
// begin SetTag ( i , 20 ) ;
76983: LD_VAR 0 5
76987: PPUSH
76988: LD_INT 20
76990: PPUSH
76991: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
76995: LD_VAR 0 5
76999: PPUSH
77000: CALL_OW 263
77004: PUSH
77005: LD_INT 1
77007: EQUAL
77008: PUSH
77009: LD_VAR 0 5
77013: PPUSH
77014: CALL_OW 311
77018: NOT
77019: AND
77020: PUSH
77021: LD_VAR 0 13
77025: AND
77026: IFFALSE 77093
// begin un := mechs [ 1 ] ;
77028: LD_ADDR_VAR 0 11
77032: PUSH
77033: LD_VAR 0 13
77037: PUSH
77038: LD_INT 1
77040: ARRAY
77041: ST_TO_ADDR
// ComExitBuilding ( un ) ;
77042: LD_VAR 0 11
77046: PPUSH
77047: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
77051: LD_VAR 0 11
77055: PPUSH
77056: LD_VAR 0 5
77060: PPUSH
77061: CALL_OW 180
// SetTag ( un , 19 ) ;
77065: LD_VAR 0 11
77069: PPUSH
77070: LD_INT 19
77072: PPUSH
77073: CALL_OW 109
// mechs := mechs diff un ;
77077: LD_ADDR_VAR 0 13
77081: PUSH
77082: LD_VAR 0 13
77086: PUSH
77087: LD_VAR 0 11
77091: DIFF
77092: ST_TO_ADDR
// end ; end ;
77093: GO 76980
77095: POP
77096: POP
// if solds then
77097: LD_VAR 0 9
77101: IFFALSE 77160
// for i in solds do
77103: LD_ADDR_VAR 0 5
77107: PUSH
77108: LD_VAR 0 9
77112: PUSH
77113: FOR_IN
77114: IFFALSE 77158
// if not GetTag ( i ) then
77116: LD_VAR 0 5
77120: PPUSH
77121: CALL_OW 110
77125: NOT
77126: IFFALSE 77156
// begin defenders := defenders union i ;
77128: LD_ADDR_VAR 0 2
77132: PUSH
77133: LD_VAR 0 2
77137: PUSH
77138: LD_VAR 0 5
77142: UNION
77143: ST_TO_ADDR
// SetTag ( i , 18 ) ;
77144: LD_VAR 0 5
77148: PPUSH
77149: LD_INT 18
77151: PPUSH
77152: CALL_OW 109
// end ;
77156: GO 77113
77158: POP
77159: POP
// repeat wait ( 0 0$1 ) ;
77160: LD_INT 35
77162: PPUSH
77163: CALL_OW 67
// enemy := mc_scan [ base ] ;
77167: LD_ADDR_VAR 0 3
77171: PUSH
77172: LD_EXP 37
77176: PUSH
77177: LD_VAR 0 1
77181: ARRAY
77182: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
77183: LD_EXP 14
77187: PUSH
77188: LD_VAR 0 1
77192: ARRAY
77193: NOT
77194: PUSH
77195: LD_EXP 14
77199: PUSH
77200: LD_VAR 0 1
77204: ARRAY
77205: PUSH
77206: EMPTY
77207: EQUAL
77208: OR
77209: IFFALSE 77246
// begin for i in defenders do
77211: LD_ADDR_VAR 0 5
77215: PUSH
77216: LD_VAR 0 2
77220: PUSH
77221: FOR_IN
77222: IFFALSE 77235
// ComStop ( i ) ;
77224: LD_VAR 0 5
77228: PPUSH
77229: CALL_OW 141
77233: GO 77221
77235: POP
77236: POP
// defenders := [ ] ;
77237: LD_ADDR_VAR 0 2
77241: PUSH
77242: EMPTY
77243: ST_TO_ADDR
// exit ;
77244: GO 78575
// end ; for i in defenders do
77246: LD_ADDR_VAR 0 5
77250: PUSH
77251: LD_VAR 0 2
77255: PUSH
77256: FOR_IN
77257: IFFALSE 78075
// begin e := NearestUnitToUnit ( enemy , i ) ;
77259: LD_ADDR_VAR 0 14
77263: PUSH
77264: LD_VAR 0 3
77268: PPUSH
77269: LD_VAR 0 5
77273: PPUSH
77274: CALL_OW 74
77278: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
77279: LD_ADDR_VAR 0 8
77283: PUSH
77284: LD_EXP 14
77288: PUSH
77289: LD_VAR 0 1
77293: ARRAY
77294: PPUSH
77295: LD_INT 2
77297: PUSH
77298: LD_INT 30
77300: PUSH
77301: LD_INT 0
77303: PUSH
77304: EMPTY
77305: LIST
77306: LIST
77307: PUSH
77308: LD_INT 30
77310: PUSH
77311: LD_INT 1
77313: PUSH
77314: EMPTY
77315: LIST
77316: LIST
77317: PUSH
77318: EMPTY
77319: LIST
77320: LIST
77321: LIST
77322: PPUSH
77323: CALL_OW 72
77327: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
77328: LD_ADDR_VAR 0 17
77332: PUSH
77333: LD_VAR 0 8
77337: NOT
77338: PUSH
77339: LD_VAR 0 8
77343: PPUSH
77344: LD_INT 3
77346: PUSH
77347: LD_INT 24
77349: PUSH
77350: LD_INT 600
77352: PUSH
77353: EMPTY
77354: LIST
77355: LIST
77356: PUSH
77357: EMPTY
77358: LIST
77359: LIST
77360: PPUSH
77361: CALL_OW 72
77365: OR
77366: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
77367: LD_VAR 0 5
77371: PPUSH
77372: CALL_OW 247
77376: PUSH
77377: LD_INT 2
77379: DOUBLE
77380: EQUAL
77381: IFTRUE 77385
77383: GO 77781
77385: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
77386: LD_VAR 0 5
77390: PPUSH
77391: CALL_OW 256
77395: PUSH
77396: LD_INT 650
77398: GREATER
77399: PUSH
77400: LD_VAR 0 5
77404: PPUSH
77405: LD_VAR 0 14
77409: PPUSH
77410: CALL_OW 296
77414: PUSH
77415: LD_INT 40
77417: LESS
77418: PUSH
77419: LD_VAR 0 14
77423: PPUSH
77424: LD_EXP 39
77428: PUSH
77429: LD_VAR 0 1
77433: ARRAY
77434: PPUSH
77435: CALL_OW 308
77439: OR
77440: AND
77441: IFFALSE 77563
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
77443: LD_VAR 0 5
77447: PPUSH
77448: CALL_OW 262
77452: PUSH
77453: LD_INT 1
77455: EQUAL
77456: PUSH
77457: LD_VAR 0 5
77461: PPUSH
77462: CALL_OW 261
77466: PUSH
77467: LD_INT 30
77469: LESS
77470: AND
77471: PUSH
77472: LD_VAR 0 8
77476: AND
77477: IFFALSE 77547
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
77479: LD_VAR 0 5
77483: PPUSH
77484: LD_VAR 0 8
77488: PPUSH
77489: LD_VAR 0 5
77493: PPUSH
77494: CALL_OW 74
77498: PPUSH
77499: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
77503: LD_VAR 0 5
77507: PPUSH
77508: LD_VAR 0 8
77512: PPUSH
77513: LD_VAR 0 5
77517: PPUSH
77518: CALL_OW 74
77522: PPUSH
77523: CALL_OW 296
77527: PUSH
77528: LD_INT 6
77530: LESS
77531: IFFALSE 77545
// SetFuel ( i , 100 ) ;
77533: LD_VAR 0 5
77537: PPUSH
77538: LD_INT 100
77540: PPUSH
77541: CALL_OW 240
// end else
77545: GO 77561
// ComAttackUnit ( i , e ) ;
77547: LD_VAR 0 5
77551: PPUSH
77552: LD_VAR 0 14
77556: PPUSH
77557: CALL_OW 115
// end else
77561: GO 77664
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
77563: LD_VAR 0 14
77567: PPUSH
77568: LD_EXP 39
77572: PUSH
77573: LD_VAR 0 1
77577: ARRAY
77578: PPUSH
77579: CALL_OW 308
77583: NOT
77584: PUSH
77585: LD_VAR 0 5
77589: PPUSH
77590: LD_VAR 0 14
77594: PPUSH
77595: CALL_OW 296
77599: PUSH
77600: LD_INT 40
77602: GREATEREQUAL
77603: AND
77604: PUSH
77605: LD_VAR 0 5
77609: PPUSH
77610: CALL_OW 256
77614: PUSH
77615: LD_INT 650
77617: LESSEQUAL
77618: OR
77619: PUSH
77620: LD_VAR 0 5
77624: PPUSH
77625: LD_EXP 38
77629: PUSH
77630: LD_VAR 0 1
77634: ARRAY
77635: PPUSH
77636: CALL_OW 308
77640: NOT
77641: AND
77642: IFFALSE 77664
// ComMoveToArea ( i , mc_parking [ base ] ) ;
77644: LD_VAR 0 5
77648: PPUSH
77649: LD_EXP 38
77653: PUSH
77654: LD_VAR 0 1
77658: ARRAY
77659: PPUSH
77660: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
77664: LD_VAR 0 5
77668: PPUSH
77669: CALL_OW 256
77673: PUSH
77674: LD_INT 998
77676: LESS
77677: PUSH
77678: LD_VAR 0 5
77682: PPUSH
77683: CALL_OW 263
77687: PUSH
77688: LD_INT 1
77690: EQUAL
77691: AND
77692: PUSH
77693: LD_VAR 0 5
77697: PPUSH
77698: CALL_OW 311
77702: AND
77703: PUSH
77704: LD_VAR 0 5
77708: PPUSH
77709: LD_EXP 38
77713: PUSH
77714: LD_VAR 0 1
77718: ARRAY
77719: PPUSH
77720: CALL_OW 308
77724: AND
77725: IFFALSE 77779
// begin mech := IsDrivenBy ( i ) ;
77727: LD_ADDR_VAR 0 10
77731: PUSH
77732: LD_VAR 0 5
77736: PPUSH
77737: CALL_OW 311
77741: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
77742: LD_VAR 0 10
77746: PPUSH
77747: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
77751: LD_VAR 0 10
77755: PPUSH
77756: LD_VAR 0 5
77760: PPUSH
77761: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
77765: LD_VAR 0 10
77769: PPUSH
77770: LD_VAR 0 5
77774: PPUSH
77775: CALL_OW 180
// end ; end ; unit_human :
77779: GO 78046
77781: LD_INT 1
77783: DOUBLE
77784: EQUAL
77785: IFTRUE 77789
77787: GO 78045
77789: POP
// begin b := IsInUnit ( i ) ;
77790: LD_ADDR_VAR 0 19
77794: PUSH
77795: LD_VAR 0 5
77799: PPUSH
77800: CALL_OW 310
77804: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
77805: LD_ADDR_VAR 0 20
77809: PUSH
77810: LD_VAR 0 19
77814: NOT
77815: PUSH
77816: LD_VAR 0 19
77820: PPUSH
77821: CALL_OW 266
77825: PUSH
77826: LD_INT 32
77828: PUSH
77829: LD_INT 31
77831: PUSH
77832: EMPTY
77833: LIST
77834: LIST
77835: IN
77836: OR
77837: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
77838: LD_VAR 0 17
77842: PUSH
77843: LD_VAR 0 2
77847: PPUSH
77848: LD_INT 21
77850: PUSH
77851: LD_INT 2
77853: PUSH
77854: EMPTY
77855: LIST
77856: LIST
77857: PPUSH
77858: CALL_OW 72
77862: PUSH
77863: LD_INT 1
77865: LESSEQUAL
77866: OR
77867: PUSH
77868: LD_VAR 0 20
77872: AND
77873: PUSH
77874: LD_VAR 0 5
77878: PUSH
77879: LD_VAR 0 18
77883: IN
77884: NOT
77885: AND
77886: IFFALSE 77979
// begin if b then
77888: LD_VAR 0 19
77892: IFFALSE 77941
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
77894: LD_VAR 0 19
77898: PPUSH
77899: LD_VAR 0 3
77903: PPUSH
77904: LD_VAR 0 19
77908: PPUSH
77909: CALL_OW 74
77913: PPUSH
77914: CALL_OW 296
77918: PUSH
77919: LD_INT 10
77921: LESS
77922: PUSH
77923: LD_VAR 0 19
77927: PPUSH
77928: CALL_OW 461
77932: PUSH
77933: LD_INT 7
77935: NONEQUAL
77936: AND
77937: IFFALSE 77941
// continue ;
77939: GO 77256
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
77941: LD_ADDR_VAR 0 18
77945: PUSH
77946: LD_VAR 0 18
77950: PPUSH
77951: LD_VAR 0 18
77955: PUSH
77956: LD_INT 1
77958: PLUS
77959: PPUSH
77960: LD_VAR 0 5
77964: PPUSH
77965: CALL_OW 1
77969: ST_TO_ADDR
// ComExitBuilding ( i ) ;
77970: LD_VAR 0 5
77974: PPUSH
77975: CALL_OW 122
// end ; if sold_defenders then
77979: LD_VAR 0 18
77983: IFFALSE 78043
// if i in sold_defenders then
77985: LD_VAR 0 5
77989: PUSH
77990: LD_VAR 0 18
77994: IN
77995: IFFALSE 78043
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
77997: LD_VAR 0 5
78001: PPUSH
78002: CALL_OW 314
78006: NOT
78007: PUSH
78008: LD_VAR 0 5
78012: PPUSH
78013: LD_VAR 0 14
78017: PPUSH
78018: CALL_OW 296
78022: PUSH
78023: LD_INT 30
78025: LESS
78026: AND
78027: IFFALSE 78043
// ComAttackUnit ( i , e ) ;
78029: LD_VAR 0 5
78033: PPUSH
78034: LD_VAR 0 14
78038: PPUSH
78039: CALL_OW 115
// end ; end ; end ;
78043: GO 78046
78045: POP
// if IsDead ( i ) then
78046: LD_VAR 0 5
78050: PPUSH
78051: CALL_OW 301
78055: IFFALSE 78073
// defenders := defenders diff i ;
78057: LD_ADDR_VAR 0 2
78061: PUSH
78062: LD_VAR 0 2
78066: PUSH
78067: LD_VAR 0 5
78071: DIFF
78072: ST_TO_ADDR
// end ;
78073: GO 77256
78075: POP
78076: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
78077: LD_VAR 0 3
78081: NOT
78082: PUSH
78083: LD_VAR 0 2
78087: NOT
78088: OR
78089: PUSH
78090: LD_EXP 14
78094: PUSH
78095: LD_VAR 0 1
78099: ARRAY
78100: NOT
78101: OR
78102: IFFALSE 77160
// MC_Reset ( base , 18 ) ;
78104: LD_VAR 0 1
78108: PPUSH
78109: LD_INT 18
78111: PPUSH
78112: CALL 45371 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
78116: LD_ADDR_VAR 0 2
78120: PUSH
78121: LD_VAR 0 2
78125: PUSH
78126: LD_VAR 0 2
78130: PPUSH
78131: LD_INT 2
78133: PUSH
78134: LD_INT 25
78136: PUSH
78137: LD_INT 1
78139: PUSH
78140: EMPTY
78141: LIST
78142: LIST
78143: PUSH
78144: LD_INT 25
78146: PUSH
78147: LD_INT 5
78149: PUSH
78150: EMPTY
78151: LIST
78152: LIST
78153: PUSH
78154: LD_INT 25
78156: PUSH
78157: LD_INT 8
78159: PUSH
78160: EMPTY
78161: LIST
78162: LIST
78163: PUSH
78164: LD_INT 25
78166: PUSH
78167: LD_INT 9
78169: PUSH
78170: EMPTY
78171: LIST
78172: LIST
78173: PUSH
78174: EMPTY
78175: LIST
78176: LIST
78177: LIST
78178: LIST
78179: LIST
78180: PPUSH
78181: CALL_OW 72
78185: DIFF
78186: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
78187: LD_VAR 0 3
78191: NOT
78192: PUSH
78193: LD_VAR 0 2
78197: PPUSH
78198: LD_INT 21
78200: PUSH
78201: LD_INT 2
78203: PUSH
78204: EMPTY
78205: LIST
78206: LIST
78207: PPUSH
78208: CALL_OW 72
78212: AND
78213: IFFALSE 78551
// begin tmp := FilterByTag ( defenders , 19 ) ;
78215: LD_ADDR_VAR 0 12
78219: PUSH
78220: LD_VAR 0 2
78224: PPUSH
78225: LD_INT 19
78227: PPUSH
78228: CALL 37988 0 2
78232: ST_TO_ADDR
// if tmp then
78233: LD_VAR 0 12
78237: IFFALSE 78307
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
78239: LD_ADDR_VAR 0 12
78243: PUSH
78244: LD_VAR 0 12
78248: PPUSH
78249: LD_INT 25
78251: PUSH
78252: LD_INT 3
78254: PUSH
78255: EMPTY
78256: LIST
78257: LIST
78258: PPUSH
78259: CALL_OW 72
78263: ST_TO_ADDR
// if tmp then
78264: LD_VAR 0 12
78268: IFFALSE 78307
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
78270: LD_ADDR_EXP 26
78274: PUSH
78275: LD_EXP 26
78279: PPUSH
78280: LD_VAR 0 1
78284: PPUSH
78285: LD_EXP 26
78289: PUSH
78290: LD_VAR 0 1
78294: ARRAY
78295: PUSH
78296: LD_VAR 0 12
78300: UNION
78301: PPUSH
78302: CALL_OW 1
78306: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
78307: LD_VAR 0 1
78311: PPUSH
78312: LD_INT 19
78314: PPUSH
78315: CALL 45371 0 2
// repeat wait ( 0 0$1 ) ;
78319: LD_INT 35
78321: PPUSH
78322: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
78326: LD_EXP 14
78330: PUSH
78331: LD_VAR 0 1
78335: ARRAY
78336: NOT
78337: PUSH
78338: LD_EXP 14
78342: PUSH
78343: LD_VAR 0 1
78347: ARRAY
78348: PUSH
78349: EMPTY
78350: EQUAL
78351: OR
78352: IFFALSE 78389
// begin for i in defenders do
78354: LD_ADDR_VAR 0 5
78358: PUSH
78359: LD_VAR 0 2
78363: PUSH
78364: FOR_IN
78365: IFFALSE 78378
// ComStop ( i ) ;
78367: LD_VAR 0 5
78371: PPUSH
78372: CALL_OW 141
78376: GO 78364
78378: POP
78379: POP
// defenders := [ ] ;
78380: LD_ADDR_VAR 0 2
78384: PUSH
78385: EMPTY
78386: ST_TO_ADDR
// exit ;
78387: GO 78575
// end ; for i in defenders do
78389: LD_ADDR_VAR 0 5
78393: PUSH
78394: LD_VAR 0 2
78398: PUSH
78399: FOR_IN
78400: IFFALSE 78489
// begin if not IsInArea ( i , mc_parking [ base ] ) then
78402: LD_VAR 0 5
78406: PPUSH
78407: LD_EXP 38
78411: PUSH
78412: LD_VAR 0 1
78416: ARRAY
78417: PPUSH
78418: CALL_OW 308
78422: NOT
78423: IFFALSE 78447
// ComMoveToArea ( i , mc_parking [ base ] ) else
78425: LD_VAR 0 5
78429: PPUSH
78430: LD_EXP 38
78434: PUSH
78435: LD_VAR 0 1
78439: ARRAY
78440: PPUSH
78441: CALL_OW 113
78445: GO 78487
// if GetControl ( i ) = control_manual then
78447: LD_VAR 0 5
78451: PPUSH
78452: CALL_OW 263
78456: PUSH
78457: LD_INT 1
78459: EQUAL
78460: IFFALSE 78487
// if IsDrivenBy ( i ) then
78462: LD_VAR 0 5
78466: PPUSH
78467: CALL_OW 311
78471: IFFALSE 78487
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
78473: LD_VAR 0 5
78477: PPUSH
78478: CALL_OW 311
78482: PPUSH
78483: CALL_OW 121
// end ;
78487: GO 78399
78489: POP
78490: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
78491: LD_VAR 0 2
78495: PPUSH
78496: LD_INT 95
78498: PUSH
78499: LD_EXP 38
78503: PUSH
78504: LD_VAR 0 1
78508: ARRAY
78509: PUSH
78510: EMPTY
78511: LIST
78512: LIST
78513: PPUSH
78514: CALL_OW 72
78518: PUSH
78519: LD_VAR 0 2
78523: EQUAL
78524: PUSH
78525: LD_EXP 37
78529: PUSH
78530: LD_VAR 0 1
78534: ARRAY
78535: OR
78536: PUSH
78537: LD_EXP 14
78541: PUSH
78542: LD_VAR 0 1
78546: ARRAY
78547: NOT
78548: OR
78549: IFFALSE 78319
// end ; MC_Reset ( base , 19 ) ;
78551: LD_VAR 0 1
78555: PPUSH
78556: LD_INT 19
78558: PPUSH
78559: CALL 45371 0 2
// MC_Reset ( base , 20 ) ;
78563: LD_VAR 0 1
78567: PPUSH
78568: LD_INT 20
78570: PPUSH
78571: CALL 45371 0 2
// end ; end_of_file
78575: LD_VAR 0 4
78579: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
78580: LD_INT 0
78582: PPUSH
78583: PPUSH
78584: PPUSH
78585: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
78586: LD_VAR 0 1
78590: PPUSH
78591: CALL_OW 264
78595: PUSH
78596: LD_EXP 61
78600: EQUAL
78601: IFFALSE 78673
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
78603: LD_INT 68
78605: PPUSH
78606: LD_VAR 0 1
78610: PPUSH
78611: CALL_OW 255
78615: PPUSH
78616: CALL_OW 321
78620: PUSH
78621: LD_INT 2
78623: EQUAL
78624: IFFALSE 78636
// eff := 70 else
78626: LD_ADDR_VAR 0 4
78630: PUSH
78631: LD_INT 70
78633: ST_TO_ADDR
78634: GO 78644
// eff := 30 ;
78636: LD_ADDR_VAR 0 4
78640: PUSH
78641: LD_INT 30
78643: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
78644: LD_VAR 0 1
78648: PPUSH
78649: CALL_OW 250
78653: PPUSH
78654: LD_VAR 0 1
78658: PPUSH
78659: CALL_OW 251
78663: PPUSH
78664: LD_VAR 0 4
78668: PPUSH
78669: CALL_OW 495
// end ; end ;
78673: LD_VAR 0 2
78677: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
78678: LD_INT 0
78680: PPUSH
// end ;
78681: LD_VAR 0 4
78685: RET
// export function SOS_Command ( cmd ) ; begin
78686: LD_INT 0
78688: PPUSH
// end ;
78689: LD_VAR 0 2
78693: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
78694: LD_INT 0
78696: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
78697: LD_VAR 0 1
78701: PUSH
78702: LD_INT 250
78704: EQUAL
78705: PUSH
78706: LD_VAR 0 2
78710: PPUSH
78711: CALL_OW 264
78715: PUSH
78716: LD_EXP 64
78720: EQUAL
78721: AND
78722: IFFALSE 78743
// MinerPlaceMine ( unit , x , y ) ;
78724: LD_VAR 0 2
78728: PPUSH
78729: LD_VAR 0 4
78733: PPUSH
78734: LD_VAR 0 5
78738: PPUSH
78739: CALL 81084 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
78743: LD_VAR 0 1
78747: PUSH
78748: LD_INT 251
78750: EQUAL
78751: PUSH
78752: LD_VAR 0 2
78756: PPUSH
78757: CALL_OW 264
78761: PUSH
78762: LD_EXP 64
78766: EQUAL
78767: AND
78768: IFFALSE 78789
// MinerDetonateMine ( unit , x , y ) ;
78770: LD_VAR 0 2
78774: PPUSH
78775: LD_VAR 0 4
78779: PPUSH
78780: LD_VAR 0 5
78784: PPUSH
78785: CALL 81361 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
78789: LD_VAR 0 1
78793: PUSH
78794: LD_INT 252
78796: EQUAL
78797: PUSH
78798: LD_VAR 0 2
78802: PPUSH
78803: CALL_OW 264
78807: PUSH
78808: LD_EXP 64
78812: EQUAL
78813: AND
78814: IFFALSE 78835
// MinerCreateMinefield ( unit , x , y ) ;
78816: LD_VAR 0 2
78820: PPUSH
78821: LD_VAR 0 4
78825: PPUSH
78826: LD_VAR 0 5
78830: PPUSH
78831: CALL 81778 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
78835: LD_VAR 0 1
78839: PUSH
78840: LD_INT 253
78842: EQUAL
78843: PUSH
78844: LD_VAR 0 2
78848: PPUSH
78849: CALL_OW 257
78853: PUSH
78854: LD_INT 5
78856: EQUAL
78857: AND
78858: IFFALSE 78879
// ComBinocular ( unit , x , y ) ;
78860: LD_VAR 0 2
78864: PPUSH
78865: LD_VAR 0 4
78869: PPUSH
78870: LD_VAR 0 5
78874: PPUSH
78875: CALL 82149 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
78879: LD_VAR 0 1
78883: PUSH
78884: LD_INT 254
78886: EQUAL
78887: PUSH
78888: LD_VAR 0 2
78892: PPUSH
78893: CALL_OW 264
78897: PUSH
78898: LD_EXP 59
78902: EQUAL
78903: AND
78904: PUSH
78905: LD_VAR 0 3
78909: PPUSH
78910: CALL_OW 263
78914: PUSH
78915: LD_INT 3
78917: EQUAL
78918: AND
78919: IFFALSE 78935
// HackDestroyVehicle ( unit , selectedUnit ) ;
78921: LD_VAR 0 2
78925: PPUSH
78926: LD_VAR 0 3
78930: PPUSH
78931: CALL 80444 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
78935: LD_VAR 0 1
78939: PUSH
78940: LD_INT 255
78942: EQUAL
78943: PUSH
78944: LD_VAR 0 2
78948: PPUSH
78949: CALL_OW 264
78953: PUSH
78954: LD_INT 14
78956: PUSH
78957: LD_INT 53
78959: PUSH
78960: EMPTY
78961: LIST
78962: LIST
78963: IN
78964: AND
78965: PUSH
78966: LD_VAR 0 4
78970: PPUSH
78971: LD_VAR 0 5
78975: PPUSH
78976: CALL_OW 488
78980: AND
78981: IFFALSE 79005
// CutTreeXYR ( unit , x , y , 12 ) ;
78983: LD_VAR 0 2
78987: PPUSH
78988: LD_VAR 0 4
78992: PPUSH
78993: LD_VAR 0 5
78997: PPUSH
78998: LD_INT 12
79000: PPUSH
79001: CALL 79010 0 4
// end ;
79005: LD_VAR 0 6
79009: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
79010: LD_INT 0
79012: PPUSH
79013: PPUSH
79014: PPUSH
79015: PPUSH
79016: PPUSH
79017: PPUSH
79018: PPUSH
79019: PPUSH
79020: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
79021: LD_VAR 0 1
79025: NOT
79026: PUSH
79027: LD_VAR 0 2
79031: PPUSH
79032: LD_VAR 0 3
79036: PPUSH
79037: CALL_OW 488
79041: NOT
79042: OR
79043: PUSH
79044: LD_VAR 0 4
79048: NOT
79049: OR
79050: IFFALSE 79054
// exit ;
79052: GO 79394
// list := [ ] ;
79054: LD_ADDR_VAR 0 13
79058: PUSH
79059: EMPTY
79060: ST_TO_ADDR
// if x - r < 0 then
79061: LD_VAR 0 2
79065: PUSH
79066: LD_VAR 0 4
79070: MINUS
79071: PUSH
79072: LD_INT 0
79074: LESS
79075: IFFALSE 79087
// min_x := 0 else
79077: LD_ADDR_VAR 0 7
79081: PUSH
79082: LD_INT 0
79084: ST_TO_ADDR
79085: GO 79103
// min_x := x - r ;
79087: LD_ADDR_VAR 0 7
79091: PUSH
79092: LD_VAR 0 2
79096: PUSH
79097: LD_VAR 0 4
79101: MINUS
79102: ST_TO_ADDR
// if y - r < 0 then
79103: LD_VAR 0 3
79107: PUSH
79108: LD_VAR 0 4
79112: MINUS
79113: PUSH
79114: LD_INT 0
79116: LESS
79117: IFFALSE 79129
// min_y := 0 else
79119: LD_ADDR_VAR 0 8
79123: PUSH
79124: LD_INT 0
79126: ST_TO_ADDR
79127: GO 79145
// min_y := y - r ;
79129: LD_ADDR_VAR 0 8
79133: PUSH
79134: LD_VAR 0 3
79138: PUSH
79139: LD_VAR 0 4
79143: MINUS
79144: ST_TO_ADDR
// max_x := x + r ;
79145: LD_ADDR_VAR 0 9
79149: PUSH
79150: LD_VAR 0 2
79154: PUSH
79155: LD_VAR 0 4
79159: PLUS
79160: ST_TO_ADDR
// max_y := y + r ;
79161: LD_ADDR_VAR 0 10
79165: PUSH
79166: LD_VAR 0 3
79170: PUSH
79171: LD_VAR 0 4
79175: PLUS
79176: ST_TO_ADDR
// for _x = min_x to max_x do
79177: LD_ADDR_VAR 0 11
79181: PUSH
79182: DOUBLE
79183: LD_VAR 0 7
79187: DEC
79188: ST_TO_ADDR
79189: LD_VAR 0 9
79193: PUSH
79194: FOR_TO
79195: IFFALSE 79312
// for _y = min_y to max_y do
79197: LD_ADDR_VAR 0 12
79201: PUSH
79202: DOUBLE
79203: LD_VAR 0 8
79207: DEC
79208: ST_TO_ADDR
79209: LD_VAR 0 10
79213: PUSH
79214: FOR_TO
79215: IFFALSE 79308
// begin if not ValidHex ( _x , _y ) then
79217: LD_VAR 0 11
79221: PPUSH
79222: LD_VAR 0 12
79226: PPUSH
79227: CALL_OW 488
79231: NOT
79232: IFFALSE 79236
// continue ;
79234: GO 79214
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
79236: LD_VAR 0 11
79240: PPUSH
79241: LD_VAR 0 12
79245: PPUSH
79246: CALL_OW 351
79250: PUSH
79251: LD_VAR 0 11
79255: PPUSH
79256: LD_VAR 0 12
79260: PPUSH
79261: CALL_OW 554
79265: AND
79266: IFFALSE 79306
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
79268: LD_ADDR_VAR 0 13
79272: PUSH
79273: LD_VAR 0 13
79277: PPUSH
79278: LD_VAR 0 13
79282: PUSH
79283: LD_INT 1
79285: PLUS
79286: PPUSH
79287: LD_VAR 0 11
79291: PUSH
79292: LD_VAR 0 12
79296: PUSH
79297: EMPTY
79298: LIST
79299: LIST
79300: PPUSH
79301: CALL_OW 2
79305: ST_TO_ADDR
// end ;
79306: GO 79214
79308: POP
79309: POP
79310: GO 79194
79312: POP
79313: POP
// if not list then
79314: LD_VAR 0 13
79318: NOT
79319: IFFALSE 79323
// exit ;
79321: GO 79394
// for i in list do
79323: LD_ADDR_VAR 0 6
79327: PUSH
79328: LD_VAR 0 13
79332: PUSH
79333: FOR_IN
79334: IFFALSE 79392
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
79336: LD_VAR 0 1
79340: PPUSH
79341: LD_STRING M
79343: PUSH
79344: LD_VAR 0 6
79348: PUSH
79349: LD_INT 1
79351: ARRAY
79352: PUSH
79353: LD_VAR 0 6
79357: PUSH
79358: LD_INT 2
79360: ARRAY
79361: PUSH
79362: LD_INT 0
79364: PUSH
79365: LD_INT 0
79367: PUSH
79368: LD_INT 0
79370: PUSH
79371: LD_INT 0
79373: PUSH
79374: EMPTY
79375: LIST
79376: LIST
79377: LIST
79378: LIST
79379: LIST
79380: LIST
79381: LIST
79382: PUSH
79383: EMPTY
79384: LIST
79385: PPUSH
79386: CALL_OW 447
79390: GO 79333
79392: POP
79393: POP
// end ;
79394: LD_VAR 0 5
79398: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
79399: LD_EXP 73
79403: NOT
79404: IFFALSE 79454
79406: GO 79408
79408: DISABLE
// begin initHack := true ;
79409: LD_ADDR_EXP 73
79413: PUSH
79414: LD_INT 1
79416: ST_TO_ADDR
// hackTanks := [ ] ;
79417: LD_ADDR_EXP 74
79421: PUSH
79422: EMPTY
79423: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
79424: LD_ADDR_EXP 75
79428: PUSH
79429: EMPTY
79430: ST_TO_ADDR
// hackLimit := 3 ;
79431: LD_ADDR_EXP 76
79435: PUSH
79436: LD_INT 3
79438: ST_TO_ADDR
// hackDist := 12 ;
79439: LD_ADDR_EXP 77
79443: PUSH
79444: LD_INT 12
79446: ST_TO_ADDR
// hackCounter := [ ] ;
79447: LD_ADDR_EXP 78
79451: PUSH
79452: EMPTY
79453: ST_TO_ADDR
// end ;
79454: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
79455: LD_EXP 73
79459: PUSH
79460: LD_INT 34
79462: PUSH
79463: LD_EXP 59
79467: PUSH
79468: EMPTY
79469: LIST
79470: LIST
79471: PPUSH
79472: CALL_OW 69
79476: AND
79477: IFFALSE 79732
79479: GO 79481
79481: DISABLE
79482: LD_INT 0
79484: PPUSH
79485: PPUSH
// begin enable ;
79486: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
79487: LD_ADDR_VAR 0 1
79491: PUSH
79492: LD_INT 34
79494: PUSH
79495: LD_EXP 59
79499: PUSH
79500: EMPTY
79501: LIST
79502: LIST
79503: PPUSH
79504: CALL_OW 69
79508: PUSH
79509: FOR_IN
79510: IFFALSE 79730
// begin if not i in hackTanks then
79512: LD_VAR 0 1
79516: PUSH
79517: LD_EXP 74
79521: IN
79522: NOT
79523: IFFALSE 79606
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
79525: LD_ADDR_EXP 74
79529: PUSH
79530: LD_EXP 74
79534: PPUSH
79535: LD_EXP 74
79539: PUSH
79540: LD_INT 1
79542: PLUS
79543: PPUSH
79544: LD_VAR 0 1
79548: PPUSH
79549: CALL_OW 1
79553: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
79554: LD_ADDR_EXP 75
79558: PUSH
79559: LD_EXP 75
79563: PPUSH
79564: LD_EXP 75
79568: PUSH
79569: LD_INT 1
79571: PLUS
79572: PPUSH
79573: EMPTY
79574: PPUSH
79575: CALL_OW 1
79579: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
79580: LD_ADDR_EXP 78
79584: PUSH
79585: LD_EXP 78
79589: PPUSH
79590: LD_EXP 78
79594: PUSH
79595: LD_INT 1
79597: PLUS
79598: PPUSH
79599: EMPTY
79600: PPUSH
79601: CALL_OW 1
79605: ST_TO_ADDR
// end ; if not IsOk ( i ) then
79606: LD_VAR 0 1
79610: PPUSH
79611: CALL_OW 302
79615: NOT
79616: IFFALSE 79629
// begin HackUnlinkAll ( i ) ;
79618: LD_VAR 0 1
79622: PPUSH
79623: CALL 79735 0 1
// continue ;
79627: GO 79509
// end ; HackCheckCapturedStatus ( i ) ;
79629: LD_VAR 0 1
79633: PPUSH
79634: CALL 80178 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
79638: LD_ADDR_VAR 0 2
79642: PUSH
79643: LD_INT 81
79645: PUSH
79646: LD_VAR 0 1
79650: PPUSH
79651: CALL_OW 255
79655: PUSH
79656: EMPTY
79657: LIST
79658: LIST
79659: PUSH
79660: LD_INT 33
79662: PUSH
79663: LD_INT 3
79665: PUSH
79666: EMPTY
79667: LIST
79668: LIST
79669: PUSH
79670: LD_INT 91
79672: PUSH
79673: LD_VAR 0 1
79677: PUSH
79678: LD_EXP 77
79682: PUSH
79683: EMPTY
79684: LIST
79685: LIST
79686: LIST
79687: PUSH
79688: LD_INT 50
79690: PUSH
79691: EMPTY
79692: LIST
79693: PUSH
79694: EMPTY
79695: LIST
79696: LIST
79697: LIST
79698: LIST
79699: PPUSH
79700: CALL_OW 69
79704: ST_TO_ADDR
// if not tmp then
79705: LD_VAR 0 2
79709: NOT
79710: IFFALSE 79714
// continue ;
79712: GO 79509
// HackLink ( i , tmp ) ;
79714: LD_VAR 0 1
79718: PPUSH
79719: LD_VAR 0 2
79723: PPUSH
79724: CALL 79871 0 2
// end ;
79728: GO 79509
79730: POP
79731: POP
// end ;
79732: PPOPN 2
79734: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
79735: LD_INT 0
79737: PPUSH
79738: PPUSH
79739: PPUSH
// if not hack in hackTanks then
79740: LD_VAR 0 1
79744: PUSH
79745: LD_EXP 74
79749: IN
79750: NOT
79751: IFFALSE 79755
// exit ;
79753: GO 79866
// index := GetElementIndex ( hackTanks , hack ) ;
79755: LD_ADDR_VAR 0 4
79759: PUSH
79760: LD_EXP 74
79764: PPUSH
79765: LD_VAR 0 1
79769: PPUSH
79770: CALL 9212 0 2
79774: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
79775: LD_EXP 75
79779: PUSH
79780: LD_VAR 0 4
79784: ARRAY
79785: IFFALSE 79866
// begin for i in hackTanksCaptured [ index ] do
79787: LD_ADDR_VAR 0 3
79791: PUSH
79792: LD_EXP 75
79796: PUSH
79797: LD_VAR 0 4
79801: ARRAY
79802: PUSH
79803: FOR_IN
79804: IFFALSE 79830
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
79806: LD_VAR 0 3
79810: PUSH
79811: LD_INT 1
79813: ARRAY
79814: PPUSH
79815: LD_VAR 0 3
79819: PUSH
79820: LD_INT 2
79822: ARRAY
79823: PPUSH
79824: CALL_OW 235
79828: GO 79803
79830: POP
79831: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
79832: LD_ADDR_EXP 75
79836: PUSH
79837: LD_EXP 75
79841: PPUSH
79842: LD_VAR 0 4
79846: PPUSH
79847: EMPTY
79848: PPUSH
79849: CALL_OW 1
79853: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
79854: LD_VAR 0 1
79858: PPUSH
79859: LD_INT 0
79861: PPUSH
79862: CALL_OW 505
// end ; end ;
79866: LD_VAR 0 2
79870: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
79871: LD_INT 0
79873: PPUSH
79874: PPUSH
79875: PPUSH
// if not hack in hackTanks or not vehicles then
79876: LD_VAR 0 1
79880: PUSH
79881: LD_EXP 74
79885: IN
79886: NOT
79887: PUSH
79888: LD_VAR 0 2
79892: NOT
79893: OR
79894: IFFALSE 79898
// exit ;
79896: GO 80173
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
79898: LD_ADDR_VAR 0 2
79902: PUSH
79903: LD_VAR 0 1
79907: PPUSH
79908: LD_VAR 0 2
79912: PPUSH
79913: LD_INT 1
79915: PPUSH
79916: LD_INT 1
79918: PPUSH
79919: CALL 9862 0 4
79923: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
79924: LD_ADDR_VAR 0 5
79928: PUSH
79929: LD_EXP 74
79933: PPUSH
79934: LD_VAR 0 1
79938: PPUSH
79939: CALL 9212 0 2
79943: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
79944: LD_EXP 75
79948: PUSH
79949: LD_VAR 0 5
79953: ARRAY
79954: PUSH
79955: LD_EXP 76
79959: LESS
79960: IFFALSE 80149
// begin for i := 1 to vehicles do
79962: LD_ADDR_VAR 0 4
79966: PUSH
79967: DOUBLE
79968: LD_INT 1
79970: DEC
79971: ST_TO_ADDR
79972: LD_VAR 0 2
79976: PUSH
79977: FOR_TO
79978: IFFALSE 80147
// begin if hackTanksCaptured [ index ] = hackLimit then
79980: LD_EXP 75
79984: PUSH
79985: LD_VAR 0 5
79989: ARRAY
79990: PUSH
79991: LD_EXP 76
79995: EQUAL
79996: IFFALSE 80000
// break ;
79998: GO 80147
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
80000: LD_ADDR_EXP 78
80004: PUSH
80005: LD_EXP 78
80009: PPUSH
80010: LD_VAR 0 5
80014: PPUSH
80015: LD_EXP 78
80019: PUSH
80020: LD_VAR 0 5
80024: ARRAY
80025: PUSH
80026: LD_INT 1
80028: PLUS
80029: PPUSH
80030: CALL_OW 1
80034: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
80035: LD_ADDR_EXP 75
80039: PUSH
80040: LD_EXP 75
80044: PPUSH
80045: LD_VAR 0 5
80049: PUSH
80050: LD_EXP 75
80054: PUSH
80055: LD_VAR 0 5
80059: ARRAY
80060: PUSH
80061: LD_INT 1
80063: PLUS
80064: PUSH
80065: EMPTY
80066: LIST
80067: LIST
80068: PPUSH
80069: LD_VAR 0 2
80073: PUSH
80074: LD_VAR 0 4
80078: ARRAY
80079: PUSH
80080: LD_VAR 0 2
80084: PUSH
80085: LD_VAR 0 4
80089: ARRAY
80090: PPUSH
80091: CALL_OW 255
80095: PUSH
80096: EMPTY
80097: LIST
80098: LIST
80099: PPUSH
80100: CALL 9427 0 3
80104: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
80105: LD_VAR 0 2
80109: PUSH
80110: LD_VAR 0 4
80114: ARRAY
80115: PPUSH
80116: LD_VAR 0 1
80120: PPUSH
80121: CALL_OW 255
80125: PPUSH
80126: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
80130: LD_VAR 0 2
80134: PUSH
80135: LD_VAR 0 4
80139: ARRAY
80140: PPUSH
80141: CALL_OW 141
// end ;
80145: GO 79977
80147: POP
80148: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
80149: LD_VAR 0 1
80153: PPUSH
80154: LD_EXP 75
80158: PUSH
80159: LD_VAR 0 5
80163: ARRAY
80164: PUSH
80165: LD_INT 0
80167: PLUS
80168: PPUSH
80169: CALL_OW 505
// end ;
80173: LD_VAR 0 3
80177: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
80178: LD_INT 0
80180: PPUSH
80181: PPUSH
80182: PPUSH
80183: PPUSH
// if not hack in hackTanks then
80184: LD_VAR 0 1
80188: PUSH
80189: LD_EXP 74
80193: IN
80194: NOT
80195: IFFALSE 80199
// exit ;
80197: GO 80439
// index := GetElementIndex ( hackTanks , hack ) ;
80199: LD_ADDR_VAR 0 4
80203: PUSH
80204: LD_EXP 74
80208: PPUSH
80209: LD_VAR 0 1
80213: PPUSH
80214: CALL 9212 0 2
80218: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
80219: LD_ADDR_VAR 0 3
80223: PUSH
80224: DOUBLE
80225: LD_EXP 75
80229: PUSH
80230: LD_VAR 0 4
80234: ARRAY
80235: INC
80236: ST_TO_ADDR
80237: LD_INT 1
80239: PUSH
80240: FOR_DOWNTO
80241: IFFALSE 80413
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
80243: LD_ADDR_VAR 0 5
80247: PUSH
80248: LD_EXP 75
80252: PUSH
80253: LD_VAR 0 4
80257: ARRAY
80258: PUSH
80259: LD_VAR 0 3
80263: ARRAY
80264: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
80265: LD_VAR 0 5
80269: PUSH
80270: LD_INT 1
80272: ARRAY
80273: PPUSH
80274: CALL_OW 302
80278: NOT
80279: PUSH
80280: LD_VAR 0 5
80284: PUSH
80285: LD_INT 1
80287: ARRAY
80288: PPUSH
80289: CALL_OW 255
80293: PUSH
80294: LD_VAR 0 1
80298: PPUSH
80299: CALL_OW 255
80303: NONEQUAL
80304: OR
80305: IFFALSE 80411
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
80307: LD_VAR 0 5
80311: PUSH
80312: LD_INT 1
80314: ARRAY
80315: PPUSH
80316: CALL_OW 305
80320: PUSH
80321: LD_VAR 0 5
80325: PUSH
80326: LD_INT 1
80328: ARRAY
80329: PPUSH
80330: CALL_OW 255
80334: PUSH
80335: LD_VAR 0 1
80339: PPUSH
80340: CALL_OW 255
80344: EQUAL
80345: AND
80346: IFFALSE 80370
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
80348: LD_VAR 0 5
80352: PUSH
80353: LD_INT 1
80355: ARRAY
80356: PPUSH
80357: LD_VAR 0 5
80361: PUSH
80362: LD_INT 2
80364: ARRAY
80365: PPUSH
80366: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
80370: LD_ADDR_EXP 75
80374: PUSH
80375: LD_EXP 75
80379: PPUSH
80380: LD_VAR 0 4
80384: PPUSH
80385: LD_EXP 75
80389: PUSH
80390: LD_VAR 0 4
80394: ARRAY
80395: PPUSH
80396: LD_VAR 0 3
80400: PPUSH
80401: CALL_OW 3
80405: PPUSH
80406: CALL_OW 1
80410: ST_TO_ADDR
// end ; end ;
80411: GO 80240
80413: POP
80414: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
80415: LD_VAR 0 1
80419: PPUSH
80420: LD_EXP 75
80424: PUSH
80425: LD_VAR 0 4
80429: ARRAY
80430: PUSH
80431: LD_INT 0
80433: PLUS
80434: PPUSH
80435: CALL_OW 505
// end ;
80439: LD_VAR 0 2
80443: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
80444: LD_INT 0
80446: PPUSH
80447: PPUSH
80448: PPUSH
80449: PPUSH
// if not hack in hackTanks then
80450: LD_VAR 0 1
80454: PUSH
80455: LD_EXP 74
80459: IN
80460: NOT
80461: IFFALSE 80465
// exit ;
80463: GO 80550
// index := GetElementIndex ( hackTanks , hack ) ;
80465: LD_ADDR_VAR 0 5
80469: PUSH
80470: LD_EXP 74
80474: PPUSH
80475: LD_VAR 0 1
80479: PPUSH
80480: CALL 9212 0 2
80484: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
80485: LD_ADDR_VAR 0 4
80489: PUSH
80490: DOUBLE
80491: LD_INT 1
80493: DEC
80494: ST_TO_ADDR
80495: LD_EXP 75
80499: PUSH
80500: LD_VAR 0 5
80504: ARRAY
80505: PUSH
80506: FOR_TO
80507: IFFALSE 80548
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
80509: LD_EXP 75
80513: PUSH
80514: LD_VAR 0 5
80518: ARRAY
80519: PUSH
80520: LD_VAR 0 4
80524: ARRAY
80525: PUSH
80526: LD_INT 1
80528: ARRAY
80529: PUSH
80530: LD_VAR 0 2
80534: EQUAL
80535: IFFALSE 80546
// KillUnit ( vehicle ) ;
80537: LD_VAR 0 2
80541: PPUSH
80542: CALL_OW 66
80546: GO 80506
80548: POP
80549: POP
// end ;
80550: LD_VAR 0 3
80554: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
80555: LD_EXP 79
80559: NOT
80560: IFFALSE 80595
80562: GO 80564
80564: DISABLE
// begin initMiner := true ;
80565: LD_ADDR_EXP 79
80569: PUSH
80570: LD_INT 1
80572: ST_TO_ADDR
// minersList := [ ] ;
80573: LD_ADDR_EXP 80
80577: PUSH
80578: EMPTY
80579: ST_TO_ADDR
// minerMinesList := [ ] ;
80580: LD_ADDR_EXP 81
80584: PUSH
80585: EMPTY
80586: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
80587: LD_ADDR_EXP 82
80591: PUSH
80592: LD_INT 5
80594: ST_TO_ADDR
// end ;
80595: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
80596: LD_EXP 79
80600: PUSH
80601: LD_INT 34
80603: PUSH
80604: LD_EXP 64
80608: PUSH
80609: EMPTY
80610: LIST
80611: LIST
80612: PPUSH
80613: CALL_OW 69
80617: AND
80618: IFFALSE 81081
80620: GO 80622
80622: DISABLE
80623: LD_INT 0
80625: PPUSH
80626: PPUSH
80627: PPUSH
80628: PPUSH
// begin enable ;
80629: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
80630: LD_ADDR_VAR 0 1
80634: PUSH
80635: LD_INT 34
80637: PUSH
80638: LD_EXP 64
80642: PUSH
80643: EMPTY
80644: LIST
80645: LIST
80646: PPUSH
80647: CALL_OW 69
80651: PUSH
80652: FOR_IN
80653: IFFALSE 80725
// begin if not i in minersList then
80655: LD_VAR 0 1
80659: PUSH
80660: LD_EXP 80
80664: IN
80665: NOT
80666: IFFALSE 80723
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
80668: LD_ADDR_EXP 80
80672: PUSH
80673: LD_EXP 80
80677: PPUSH
80678: LD_EXP 80
80682: PUSH
80683: LD_INT 1
80685: PLUS
80686: PPUSH
80687: LD_VAR 0 1
80691: PPUSH
80692: CALL_OW 1
80696: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
80697: LD_ADDR_EXP 81
80701: PUSH
80702: LD_EXP 81
80706: PPUSH
80707: LD_EXP 81
80711: PUSH
80712: LD_INT 1
80714: PLUS
80715: PPUSH
80716: EMPTY
80717: PPUSH
80718: CALL_OW 1
80722: ST_TO_ADDR
// end end ;
80723: GO 80652
80725: POP
80726: POP
// for i := minerMinesList downto 1 do
80727: LD_ADDR_VAR 0 1
80731: PUSH
80732: DOUBLE
80733: LD_EXP 81
80737: INC
80738: ST_TO_ADDR
80739: LD_INT 1
80741: PUSH
80742: FOR_DOWNTO
80743: IFFALSE 81079
// begin if IsLive ( minersList [ i ] ) then
80745: LD_EXP 80
80749: PUSH
80750: LD_VAR 0 1
80754: ARRAY
80755: PPUSH
80756: CALL_OW 300
80760: IFFALSE 80788
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
80762: LD_EXP 80
80766: PUSH
80767: LD_VAR 0 1
80771: ARRAY
80772: PPUSH
80773: LD_EXP 81
80777: PUSH
80778: LD_VAR 0 1
80782: ARRAY
80783: PPUSH
80784: CALL_OW 505
// if not minerMinesList [ i ] then
80788: LD_EXP 81
80792: PUSH
80793: LD_VAR 0 1
80797: ARRAY
80798: NOT
80799: IFFALSE 80803
// continue ;
80801: GO 80742
// for j := minerMinesList [ i ] downto 1 do
80803: LD_ADDR_VAR 0 2
80807: PUSH
80808: DOUBLE
80809: LD_EXP 81
80813: PUSH
80814: LD_VAR 0 1
80818: ARRAY
80819: INC
80820: ST_TO_ADDR
80821: LD_INT 1
80823: PUSH
80824: FOR_DOWNTO
80825: IFFALSE 81075
// begin side := GetSide ( minersList [ i ] ) ;
80827: LD_ADDR_VAR 0 3
80831: PUSH
80832: LD_EXP 80
80836: PUSH
80837: LD_VAR 0 1
80841: ARRAY
80842: PPUSH
80843: CALL_OW 255
80847: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
80848: LD_ADDR_VAR 0 4
80852: PUSH
80853: LD_EXP 81
80857: PUSH
80858: LD_VAR 0 1
80862: ARRAY
80863: PUSH
80864: LD_VAR 0 2
80868: ARRAY
80869: PUSH
80870: LD_INT 1
80872: ARRAY
80873: PPUSH
80874: LD_EXP 81
80878: PUSH
80879: LD_VAR 0 1
80883: ARRAY
80884: PUSH
80885: LD_VAR 0 2
80889: ARRAY
80890: PUSH
80891: LD_INT 2
80893: ARRAY
80894: PPUSH
80895: CALL_OW 428
80899: ST_TO_ADDR
// if not tmp then
80900: LD_VAR 0 4
80904: NOT
80905: IFFALSE 80909
// continue ;
80907: GO 80824
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
80909: LD_VAR 0 4
80913: PUSH
80914: LD_INT 81
80916: PUSH
80917: LD_VAR 0 3
80921: PUSH
80922: EMPTY
80923: LIST
80924: LIST
80925: PPUSH
80926: CALL_OW 69
80930: IN
80931: PUSH
80932: LD_EXP 81
80936: PUSH
80937: LD_VAR 0 1
80941: ARRAY
80942: PUSH
80943: LD_VAR 0 2
80947: ARRAY
80948: PUSH
80949: LD_INT 1
80951: ARRAY
80952: PPUSH
80953: LD_EXP 81
80957: PUSH
80958: LD_VAR 0 1
80962: ARRAY
80963: PUSH
80964: LD_VAR 0 2
80968: ARRAY
80969: PUSH
80970: LD_INT 2
80972: ARRAY
80973: PPUSH
80974: CALL_OW 458
80978: AND
80979: IFFALSE 81073
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
80981: LD_EXP 81
80985: PUSH
80986: LD_VAR 0 1
80990: ARRAY
80991: PUSH
80992: LD_VAR 0 2
80996: ARRAY
80997: PUSH
80998: LD_INT 1
81000: ARRAY
81001: PPUSH
81002: LD_EXP 81
81006: PUSH
81007: LD_VAR 0 1
81011: ARRAY
81012: PUSH
81013: LD_VAR 0 2
81017: ARRAY
81018: PUSH
81019: LD_INT 2
81021: ARRAY
81022: PPUSH
81023: LD_VAR 0 3
81027: PPUSH
81028: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
81032: LD_ADDR_EXP 81
81036: PUSH
81037: LD_EXP 81
81041: PPUSH
81042: LD_VAR 0 1
81046: PPUSH
81047: LD_EXP 81
81051: PUSH
81052: LD_VAR 0 1
81056: ARRAY
81057: PPUSH
81058: LD_VAR 0 2
81062: PPUSH
81063: CALL_OW 3
81067: PPUSH
81068: CALL_OW 1
81072: ST_TO_ADDR
// end ; end ;
81073: GO 80824
81075: POP
81076: POP
// end ;
81077: GO 80742
81079: POP
81080: POP
// end ;
81081: PPOPN 4
81083: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
81084: LD_INT 0
81086: PPUSH
81087: PPUSH
// result := false ;
81088: LD_ADDR_VAR 0 4
81092: PUSH
81093: LD_INT 0
81095: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
81096: LD_VAR 0 1
81100: PPUSH
81101: CALL_OW 264
81105: PUSH
81106: LD_EXP 64
81110: EQUAL
81111: NOT
81112: IFFALSE 81116
// exit ;
81114: GO 81356
// index := GetElementIndex ( minersList , unit ) ;
81116: LD_ADDR_VAR 0 5
81120: PUSH
81121: LD_EXP 80
81125: PPUSH
81126: LD_VAR 0 1
81130: PPUSH
81131: CALL 9212 0 2
81135: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
81136: LD_EXP 81
81140: PUSH
81141: LD_VAR 0 5
81145: ARRAY
81146: PUSH
81147: LD_EXP 82
81151: GREATEREQUAL
81152: IFFALSE 81156
// exit ;
81154: GO 81356
// ComMoveXY ( unit , x , y ) ;
81156: LD_VAR 0 1
81160: PPUSH
81161: LD_VAR 0 2
81165: PPUSH
81166: LD_VAR 0 3
81170: PPUSH
81171: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
81175: LD_INT 35
81177: PPUSH
81178: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
81182: LD_VAR 0 1
81186: PPUSH
81187: LD_VAR 0 2
81191: PPUSH
81192: LD_VAR 0 3
81196: PPUSH
81197: CALL 39276 0 3
81201: NOT
81202: PUSH
81203: LD_VAR 0 1
81207: PPUSH
81208: CALL_OW 314
81212: AND
81213: IFFALSE 81217
// exit ;
81215: GO 81356
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
81217: LD_VAR 0 2
81221: PPUSH
81222: LD_VAR 0 3
81226: PPUSH
81227: CALL_OW 428
81231: PUSH
81232: LD_VAR 0 1
81236: EQUAL
81237: PUSH
81238: LD_VAR 0 1
81242: PPUSH
81243: CALL_OW 314
81247: NOT
81248: AND
81249: IFFALSE 81175
// PlaySoundXY ( x , y , PlantMine ) ;
81251: LD_VAR 0 2
81255: PPUSH
81256: LD_VAR 0 3
81260: PPUSH
81261: LD_STRING PlantMine
81263: PPUSH
81264: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
81268: LD_VAR 0 2
81272: PPUSH
81273: LD_VAR 0 3
81277: PPUSH
81278: LD_VAR 0 1
81282: PPUSH
81283: CALL_OW 255
81287: PPUSH
81288: LD_INT 0
81290: PPUSH
81291: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
81295: LD_ADDR_EXP 81
81299: PUSH
81300: LD_EXP 81
81304: PPUSH
81305: LD_VAR 0 5
81309: PUSH
81310: LD_EXP 81
81314: PUSH
81315: LD_VAR 0 5
81319: ARRAY
81320: PUSH
81321: LD_INT 1
81323: PLUS
81324: PUSH
81325: EMPTY
81326: LIST
81327: LIST
81328: PPUSH
81329: LD_VAR 0 2
81333: PUSH
81334: LD_VAR 0 3
81338: PUSH
81339: EMPTY
81340: LIST
81341: LIST
81342: PPUSH
81343: CALL 9427 0 3
81347: ST_TO_ADDR
// result := true ;
81348: LD_ADDR_VAR 0 4
81352: PUSH
81353: LD_INT 1
81355: ST_TO_ADDR
// end ;
81356: LD_VAR 0 4
81360: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
81361: LD_INT 0
81363: PPUSH
81364: PPUSH
81365: PPUSH
// if not unit in minersList then
81366: LD_VAR 0 1
81370: PUSH
81371: LD_EXP 80
81375: IN
81376: NOT
81377: IFFALSE 81381
// exit ;
81379: GO 81773
// index := GetElementIndex ( minersList , unit ) ;
81381: LD_ADDR_VAR 0 6
81385: PUSH
81386: LD_EXP 80
81390: PPUSH
81391: LD_VAR 0 1
81395: PPUSH
81396: CALL 9212 0 2
81400: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
81401: LD_ADDR_VAR 0 5
81405: PUSH
81406: DOUBLE
81407: LD_EXP 81
81411: PUSH
81412: LD_VAR 0 6
81416: ARRAY
81417: INC
81418: ST_TO_ADDR
81419: LD_INT 1
81421: PUSH
81422: FOR_DOWNTO
81423: IFFALSE 81584
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
81425: LD_EXP 81
81429: PUSH
81430: LD_VAR 0 6
81434: ARRAY
81435: PUSH
81436: LD_VAR 0 5
81440: ARRAY
81441: PUSH
81442: LD_INT 1
81444: ARRAY
81445: PUSH
81446: LD_VAR 0 2
81450: EQUAL
81451: PUSH
81452: LD_EXP 81
81456: PUSH
81457: LD_VAR 0 6
81461: ARRAY
81462: PUSH
81463: LD_VAR 0 5
81467: ARRAY
81468: PUSH
81469: LD_INT 2
81471: ARRAY
81472: PUSH
81473: LD_VAR 0 3
81477: EQUAL
81478: AND
81479: IFFALSE 81582
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
81481: LD_EXP 81
81485: PUSH
81486: LD_VAR 0 6
81490: ARRAY
81491: PUSH
81492: LD_VAR 0 5
81496: ARRAY
81497: PUSH
81498: LD_INT 1
81500: ARRAY
81501: PPUSH
81502: LD_EXP 81
81506: PUSH
81507: LD_VAR 0 6
81511: ARRAY
81512: PUSH
81513: LD_VAR 0 5
81517: ARRAY
81518: PUSH
81519: LD_INT 2
81521: ARRAY
81522: PPUSH
81523: LD_VAR 0 1
81527: PPUSH
81528: CALL_OW 255
81532: PPUSH
81533: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
81537: LD_ADDR_EXP 81
81541: PUSH
81542: LD_EXP 81
81546: PPUSH
81547: LD_VAR 0 6
81551: PPUSH
81552: LD_EXP 81
81556: PUSH
81557: LD_VAR 0 6
81561: ARRAY
81562: PPUSH
81563: LD_VAR 0 5
81567: PPUSH
81568: CALL_OW 3
81572: PPUSH
81573: CALL_OW 1
81577: ST_TO_ADDR
// exit ;
81578: POP
81579: POP
81580: GO 81773
// end ; end ;
81582: GO 81422
81584: POP
81585: POP
// for i := minerMinesList [ index ] downto 1 do
81586: LD_ADDR_VAR 0 5
81590: PUSH
81591: DOUBLE
81592: LD_EXP 81
81596: PUSH
81597: LD_VAR 0 6
81601: ARRAY
81602: INC
81603: ST_TO_ADDR
81604: LD_INT 1
81606: PUSH
81607: FOR_DOWNTO
81608: IFFALSE 81771
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
81610: LD_EXP 81
81614: PUSH
81615: LD_VAR 0 6
81619: ARRAY
81620: PUSH
81621: LD_VAR 0 5
81625: ARRAY
81626: PUSH
81627: LD_INT 1
81629: ARRAY
81630: PPUSH
81631: LD_EXP 81
81635: PUSH
81636: LD_VAR 0 6
81640: ARRAY
81641: PUSH
81642: LD_VAR 0 5
81646: ARRAY
81647: PUSH
81648: LD_INT 2
81650: ARRAY
81651: PPUSH
81652: LD_VAR 0 2
81656: PPUSH
81657: LD_VAR 0 3
81661: PPUSH
81662: CALL_OW 298
81666: PUSH
81667: LD_INT 6
81669: LESS
81670: IFFALSE 81769
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
81672: LD_EXP 81
81676: PUSH
81677: LD_VAR 0 6
81681: ARRAY
81682: PUSH
81683: LD_VAR 0 5
81687: ARRAY
81688: PUSH
81689: LD_INT 1
81691: ARRAY
81692: PPUSH
81693: LD_EXP 81
81697: PUSH
81698: LD_VAR 0 6
81702: ARRAY
81703: PUSH
81704: LD_VAR 0 5
81708: ARRAY
81709: PUSH
81710: LD_INT 2
81712: ARRAY
81713: PPUSH
81714: LD_VAR 0 1
81718: PPUSH
81719: CALL_OW 255
81723: PPUSH
81724: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
81728: LD_ADDR_EXP 81
81732: PUSH
81733: LD_EXP 81
81737: PPUSH
81738: LD_VAR 0 6
81742: PPUSH
81743: LD_EXP 81
81747: PUSH
81748: LD_VAR 0 6
81752: ARRAY
81753: PPUSH
81754: LD_VAR 0 5
81758: PPUSH
81759: CALL_OW 3
81763: PPUSH
81764: CALL_OW 1
81768: ST_TO_ADDR
// end ; end ;
81769: GO 81607
81771: POP
81772: POP
// end ;
81773: LD_VAR 0 4
81777: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
81778: LD_INT 0
81780: PPUSH
81781: PPUSH
81782: PPUSH
81783: PPUSH
81784: PPUSH
81785: PPUSH
81786: PPUSH
81787: PPUSH
81788: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
81789: LD_VAR 0 1
81793: PPUSH
81794: CALL_OW 264
81798: PUSH
81799: LD_EXP 64
81803: EQUAL
81804: NOT
81805: PUSH
81806: LD_VAR 0 1
81810: PUSH
81811: LD_EXP 80
81815: IN
81816: NOT
81817: OR
81818: IFFALSE 81822
// exit ;
81820: GO 82144
// index := GetElementIndex ( minersList , unit ) ;
81822: LD_ADDR_VAR 0 6
81826: PUSH
81827: LD_EXP 80
81831: PPUSH
81832: LD_VAR 0 1
81836: PPUSH
81837: CALL 9212 0 2
81841: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
81842: LD_ADDR_VAR 0 8
81846: PUSH
81847: LD_EXP 82
81851: PUSH
81852: LD_EXP 81
81856: PUSH
81857: LD_VAR 0 6
81861: ARRAY
81862: MINUS
81863: ST_TO_ADDR
// if not minesFreeAmount then
81864: LD_VAR 0 8
81868: NOT
81869: IFFALSE 81873
// exit ;
81871: GO 82144
// tmp := [ ] ;
81873: LD_ADDR_VAR 0 7
81877: PUSH
81878: EMPTY
81879: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
81880: LD_ADDR_VAR 0 5
81884: PUSH
81885: DOUBLE
81886: LD_INT 1
81888: DEC
81889: ST_TO_ADDR
81890: LD_VAR 0 8
81894: PUSH
81895: FOR_TO
81896: IFFALSE 82091
// begin _d := rand ( 0 , 5 ) ;
81898: LD_ADDR_VAR 0 11
81902: PUSH
81903: LD_INT 0
81905: PPUSH
81906: LD_INT 5
81908: PPUSH
81909: CALL_OW 12
81913: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
81914: LD_ADDR_VAR 0 12
81918: PUSH
81919: LD_INT 2
81921: PPUSH
81922: LD_INT 6
81924: PPUSH
81925: CALL_OW 12
81929: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
81930: LD_ADDR_VAR 0 9
81934: PUSH
81935: LD_VAR 0 2
81939: PPUSH
81940: LD_VAR 0 11
81944: PPUSH
81945: LD_VAR 0 12
81949: PPUSH
81950: CALL_OW 272
81954: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
81955: LD_ADDR_VAR 0 10
81959: PUSH
81960: LD_VAR 0 3
81964: PPUSH
81965: LD_VAR 0 11
81969: PPUSH
81970: LD_VAR 0 12
81974: PPUSH
81975: CALL_OW 273
81979: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
81980: LD_VAR 0 9
81984: PPUSH
81985: LD_VAR 0 10
81989: PPUSH
81990: CALL_OW 488
81994: PUSH
81995: LD_VAR 0 9
81999: PUSH
82000: LD_VAR 0 10
82004: PUSH
82005: EMPTY
82006: LIST
82007: LIST
82008: PUSH
82009: LD_VAR 0 7
82013: IN
82014: NOT
82015: AND
82016: PUSH
82017: LD_VAR 0 9
82021: PPUSH
82022: LD_VAR 0 10
82026: PPUSH
82027: CALL_OW 458
82031: NOT
82032: AND
82033: IFFALSE 82075
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
82035: LD_ADDR_VAR 0 7
82039: PUSH
82040: LD_VAR 0 7
82044: PPUSH
82045: LD_VAR 0 7
82049: PUSH
82050: LD_INT 1
82052: PLUS
82053: PPUSH
82054: LD_VAR 0 9
82058: PUSH
82059: LD_VAR 0 10
82063: PUSH
82064: EMPTY
82065: LIST
82066: LIST
82067: PPUSH
82068: CALL_OW 1
82072: ST_TO_ADDR
82073: GO 82089
// i := i - 1 ;
82075: LD_ADDR_VAR 0 5
82079: PUSH
82080: LD_VAR 0 5
82084: PUSH
82085: LD_INT 1
82087: MINUS
82088: ST_TO_ADDR
// end ;
82089: GO 81895
82091: POP
82092: POP
// for i in tmp do
82093: LD_ADDR_VAR 0 5
82097: PUSH
82098: LD_VAR 0 7
82102: PUSH
82103: FOR_IN
82104: IFFALSE 82142
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
82106: LD_VAR 0 1
82110: PPUSH
82111: LD_VAR 0 5
82115: PUSH
82116: LD_INT 1
82118: ARRAY
82119: PPUSH
82120: LD_VAR 0 5
82124: PUSH
82125: LD_INT 2
82127: ARRAY
82128: PPUSH
82129: CALL 81084 0 3
82133: NOT
82134: IFFALSE 82140
// exit ;
82136: POP
82137: POP
82138: GO 82144
82140: GO 82103
82142: POP
82143: POP
// end ;
82144: LD_VAR 0 4
82148: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
82149: LD_INT 0
82151: PPUSH
82152: PPUSH
82153: PPUSH
82154: PPUSH
82155: PPUSH
82156: PPUSH
82157: PPUSH
// if not GetClass ( unit ) = class_sniper then
82158: LD_VAR 0 1
82162: PPUSH
82163: CALL_OW 257
82167: PUSH
82168: LD_INT 5
82170: EQUAL
82171: NOT
82172: IFFALSE 82176
// exit ;
82174: GO 82564
// dist := 8 ;
82176: LD_ADDR_VAR 0 5
82180: PUSH
82181: LD_INT 8
82183: ST_TO_ADDR
// viewRange := 12 ;
82184: LD_ADDR_VAR 0 7
82188: PUSH
82189: LD_INT 12
82191: ST_TO_ADDR
// side := GetSide ( unit ) ;
82192: LD_ADDR_VAR 0 6
82196: PUSH
82197: LD_VAR 0 1
82201: PPUSH
82202: CALL_OW 255
82206: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
82207: LD_INT 61
82209: PPUSH
82210: LD_VAR 0 6
82214: PPUSH
82215: CALL_OW 321
82219: PUSH
82220: LD_INT 2
82222: EQUAL
82223: IFFALSE 82233
// viewRange := 16 ;
82225: LD_ADDR_VAR 0 7
82229: PUSH
82230: LD_INT 16
82232: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
82233: LD_VAR 0 1
82237: PPUSH
82238: LD_VAR 0 2
82242: PPUSH
82243: LD_VAR 0 3
82247: PPUSH
82248: CALL_OW 297
82252: PUSH
82253: LD_VAR 0 5
82257: GREATER
82258: IFFALSE 82337
// begin ComMoveXY ( unit , x , y ) ;
82260: LD_VAR 0 1
82264: PPUSH
82265: LD_VAR 0 2
82269: PPUSH
82270: LD_VAR 0 3
82274: PPUSH
82275: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
82279: LD_INT 35
82281: PPUSH
82282: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
82286: LD_VAR 0 1
82290: PPUSH
82291: LD_VAR 0 2
82295: PPUSH
82296: LD_VAR 0 3
82300: PPUSH
82301: CALL 39276 0 3
82305: NOT
82306: IFFALSE 82310
// exit ;
82308: GO 82564
// until GetDistUnitXY ( unit , x , y ) < dist ;
82310: LD_VAR 0 1
82314: PPUSH
82315: LD_VAR 0 2
82319: PPUSH
82320: LD_VAR 0 3
82324: PPUSH
82325: CALL_OW 297
82329: PUSH
82330: LD_VAR 0 5
82334: LESS
82335: IFFALSE 82279
// end ; ComTurnXY ( unit , x , y ) ;
82337: LD_VAR 0 1
82341: PPUSH
82342: LD_VAR 0 2
82346: PPUSH
82347: LD_VAR 0 3
82351: PPUSH
82352: CALL_OW 118
// wait ( 5 ) ;
82356: LD_INT 5
82358: PPUSH
82359: CALL_OW 67
// _d := GetDir ( unit ) ;
82363: LD_ADDR_VAR 0 10
82367: PUSH
82368: LD_VAR 0 1
82372: PPUSH
82373: CALL_OW 254
82377: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
82378: LD_ADDR_VAR 0 8
82382: PUSH
82383: LD_VAR 0 1
82387: PPUSH
82388: CALL_OW 250
82392: PPUSH
82393: LD_VAR 0 10
82397: PPUSH
82398: LD_VAR 0 5
82402: PPUSH
82403: CALL_OW 272
82407: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
82408: LD_ADDR_VAR 0 9
82412: PUSH
82413: LD_VAR 0 1
82417: PPUSH
82418: CALL_OW 251
82422: PPUSH
82423: LD_VAR 0 10
82427: PPUSH
82428: LD_VAR 0 5
82432: PPUSH
82433: CALL_OW 273
82437: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
82438: LD_VAR 0 8
82442: PPUSH
82443: LD_VAR 0 9
82447: PPUSH
82448: CALL_OW 488
82452: NOT
82453: IFFALSE 82457
// exit ;
82455: GO 82564
// ComAnimCustom ( unit , 1 ) ;
82457: LD_VAR 0 1
82461: PPUSH
82462: LD_INT 1
82464: PPUSH
82465: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
82469: LD_VAR 0 8
82473: PPUSH
82474: LD_VAR 0 9
82478: PPUSH
82479: LD_VAR 0 6
82483: PPUSH
82484: LD_VAR 0 7
82488: PPUSH
82489: CALL_OW 330
// repeat wait ( 1 ) ;
82493: LD_INT 1
82495: PPUSH
82496: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
82500: LD_VAR 0 1
82504: PPUSH
82505: CALL_OW 316
82509: PUSH
82510: LD_VAR 0 1
82514: PPUSH
82515: CALL_OW 314
82519: OR
82520: PUSH
82521: LD_VAR 0 1
82525: PPUSH
82526: CALL_OW 302
82530: NOT
82531: OR
82532: PUSH
82533: LD_VAR 0 1
82537: PPUSH
82538: CALL_OW 301
82542: OR
82543: IFFALSE 82493
// RemoveSeeing ( _x , _y , side ) ;
82545: LD_VAR 0 8
82549: PPUSH
82550: LD_VAR 0 9
82554: PPUSH
82555: LD_VAR 0 6
82559: PPUSH
82560: CALL_OW 331
// end ; end_of_file end_of_file
82564: LD_VAR 0 4
82568: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
82569: LD_VAR 0 1
82573: PUSH
82574: LD_INT 200
82576: DOUBLE
82577: GREATEREQUAL
82578: IFFALSE 82586
82580: LD_INT 299
82582: DOUBLE
82583: LESSEQUAL
82584: IFTRUE 82588
82586: GO 82620
82588: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
82589: LD_VAR 0 1
82593: PPUSH
82594: LD_VAR 0 2
82598: PPUSH
82599: LD_VAR 0 3
82603: PPUSH
82604: LD_VAR 0 4
82608: PPUSH
82609: LD_VAR 0 5
82613: PPUSH
82614: CALL 78694 0 5
82618: GO 82697
82620: LD_INT 300
82622: DOUBLE
82623: GREATEREQUAL
82624: IFFALSE 82632
82626: LD_INT 399
82628: DOUBLE
82629: LESSEQUAL
82630: IFTRUE 82634
82632: GO 82696
82634: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
82635: LD_VAR 0 1
82639: PPUSH
82640: LD_VAR 0 2
82644: PPUSH
82645: LD_VAR 0 3
82649: PPUSH
82650: LD_VAR 0 4
82654: PPUSH
82655: LD_VAR 0 5
82659: PPUSH
82660: LD_VAR 0 6
82664: PPUSH
82665: LD_VAR 0 7
82669: PPUSH
82670: LD_VAR 0 8
82674: PPUSH
82675: LD_VAR 0 9
82679: PPUSH
82680: LD_VAR 0 10
82684: PPUSH
82685: LD_VAR 0 11
82689: PPUSH
82690: CALL 93887 0 11
82694: GO 82697
82696: POP
// end ; end_of_file
82697: PPOPN 11
82699: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
82700: LD_VAR 0 2
82704: PUSH
82705: LD_INT 100
82707: EQUAL
82708: IFFALSE 83657
// begin if not StreamModeActive then
82710: LD_EXP 83
82714: NOT
82715: IFFALSE 82725
// StreamModeActive := true ;
82717: LD_ADDR_EXP 83
82721: PUSH
82722: LD_INT 1
82724: ST_TO_ADDR
// if p3 = 0 then
82725: LD_VAR 0 3
82729: PUSH
82730: LD_INT 0
82732: EQUAL
82733: IFFALSE 82739
// InitStreamMode ;
82735: CALL 83815 0 0
// if p3 = 1 then
82739: LD_VAR 0 3
82743: PUSH
82744: LD_INT 1
82746: EQUAL
82747: IFFALSE 82757
// sRocket := true ;
82749: LD_ADDR_EXP 88
82753: PUSH
82754: LD_INT 1
82756: ST_TO_ADDR
// if p3 = 2 then
82757: LD_VAR 0 3
82761: PUSH
82762: LD_INT 2
82764: EQUAL
82765: IFFALSE 82775
// sSpeed := true ;
82767: LD_ADDR_EXP 87
82771: PUSH
82772: LD_INT 1
82774: ST_TO_ADDR
// if p3 = 3 then
82775: LD_VAR 0 3
82779: PUSH
82780: LD_INT 3
82782: EQUAL
82783: IFFALSE 82793
// sEngine := true ;
82785: LD_ADDR_EXP 89
82789: PUSH
82790: LD_INT 1
82792: ST_TO_ADDR
// if p3 = 4 then
82793: LD_VAR 0 3
82797: PUSH
82798: LD_INT 4
82800: EQUAL
82801: IFFALSE 82811
// sSpec := true ;
82803: LD_ADDR_EXP 86
82807: PUSH
82808: LD_INT 1
82810: ST_TO_ADDR
// if p3 = 5 then
82811: LD_VAR 0 3
82815: PUSH
82816: LD_INT 5
82818: EQUAL
82819: IFFALSE 82829
// sLevel := true ;
82821: LD_ADDR_EXP 90
82825: PUSH
82826: LD_INT 1
82828: ST_TO_ADDR
// if p3 = 6 then
82829: LD_VAR 0 3
82833: PUSH
82834: LD_INT 6
82836: EQUAL
82837: IFFALSE 82847
// sArmoury := true ;
82839: LD_ADDR_EXP 91
82843: PUSH
82844: LD_INT 1
82846: ST_TO_ADDR
// if p3 = 7 then
82847: LD_VAR 0 3
82851: PUSH
82852: LD_INT 7
82854: EQUAL
82855: IFFALSE 82865
// sRadar := true ;
82857: LD_ADDR_EXP 92
82861: PUSH
82862: LD_INT 1
82864: ST_TO_ADDR
// if p3 = 8 then
82865: LD_VAR 0 3
82869: PUSH
82870: LD_INT 8
82872: EQUAL
82873: IFFALSE 82883
// sBunker := true ;
82875: LD_ADDR_EXP 93
82879: PUSH
82880: LD_INT 1
82882: ST_TO_ADDR
// if p3 = 9 then
82883: LD_VAR 0 3
82887: PUSH
82888: LD_INT 9
82890: EQUAL
82891: IFFALSE 82901
// sHack := true ;
82893: LD_ADDR_EXP 94
82897: PUSH
82898: LD_INT 1
82900: ST_TO_ADDR
// if p3 = 10 then
82901: LD_VAR 0 3
82905: PUSH
82906: LD_INT 10
82908: EQUAL
82909: IFFALSE 82919
// sFire := true ;
82911: LD_ADDR_EXP 95
82915: PUSH
82916: LD_INT 1
82918: ST_TO_ADDR
// if p3 = 11 then
82919: LD_VAR 0 3
82923: PUSH
82924: LD_INT 11
82926: EQUAL
82927: IFFALSE 82937
// sRefresh := true ;
82929: LD_ADDR_EXP 96
82933: PUSH
82934: LD_INT 1
82936: ST_TO_ADDR
// if p3 = 12 then
82937: LD_VAR 0 3
82941: PUSH
82942: LD_INT 12
82944: EQUAL
82945: IFFALSE 82955
// sExp := true ;
82947: LD_ADDR_EXP 97
82951: PUSH
82952: LD_INT 1
82954: ST_TO_ADDR
// if p3 = 13 then
82955: LD_VAR 0 3
82959: PUSH
82960: LD_INT 13
82962: EQUAL
82963: IFFALSE 82973
// sDepot := true ;
82965: LD_ADDR_EXP 98
82969: PUSH
82970: LD_INT 1
82972: ST_TO_ADDR
// if p3 = 14 then
82973: LD_VAR 0 3
82977: PUSH
82978: LD_INT 14
82980: EQUAL
82981: IFFALSE 82991
// sFlag := true ;
82983: LD_ADDR_EXP 99
82987: PUSH
82988: LD_INT 1
82990: ST_TO_ADDR
// if p3 = 15 then
82991: LD_VAR 0 3
82995: PUSH
82996: LD_INT 15
82998: EQUAL
82999: IFFALSE 83009
// sKamikadze := true ;
83001: LD_ADDR_EXP 107
83005: PUSH
83006: LD_INT 1
83008: ST_TO_ADDR
// if p3 = 16 then
83009: LD_VAR 0 3
83013: PUSH
83014: LD_INT 16
83016: EQUAL
83017: IFFALSE 83027
// sTroll := true ;
83019: LD_ADDR_EXP 108
83023: PUSH
83024: LD_INT 1
83026: ST_TO_ADDR
// if p3 = 17 then
83027: LD_VAR 0 3
83031: PUSH
83032: LD_INT 17
83034: EQUAL
83035: IFFALSE 83045
// sSlow := true ;
83037: LD_ADDR_EXP 109
83041: PUSH
83042: LD_INT 1
83044: ST_TO_ADDR
// if p3 = 18 then
83045: LD_VAR 0 3
83049: PUSH
83050: LD_INT 18
83052: EQUAL
83053: IFFALSE 83063
// sLack := true ;
83055: LD_ADDR_EXP 110
83059: PUSH
83060: LD_INT 1
83062: ST_TO_ADDR
// if p3 = 19 then
83063: LD_VAR 0 3
83067: PUSH
83068: LD_INT 19
83070: EQUAL
83071: IFFALSE 83081
// sTank := true ;
83073: LD_ADDR_EXP 112
83077: PUSH
83078: LD_INT 1
83080: ST_TO_ADDR
// if p3 = 20 then
83081: LD_VAR 0 3
83085: PUSH
83086: LD_INT 20
83088: EQUAL
83089: IFFALSE 83099
// sRemote := true ;
83091: LD_ADDR_EXP 113
83095: PUSH
83096: LD_INT 1
83098: ST_TO_ADDR
// if p3 = 21 then
83099: LD_VAR 0 3
83103: PUSH
83104: LD_INT 21
83106: EQUAL
83107: IFFALSE 83117
// sPowell := true ;
83109: LD_ADDR_EXP 114
83113: PUSH
83114: LD_INT 1
83116: ST_TO_ADDR
// if p3 = 22 then
83117: LD_VAR 0 3
83121: PUSH
83122: LD_INT 22
83124: EQUAL
83125: IFFALSE 83135
// sTeleport := true ;
83127: LD_ADDR_EXP 117
83131: PUSH
83132: LD_INT 1
83134: ST_TO_ADDR
// if p3 = 23 then
83135: LD_VAR 0 3
83139: PUSH
83140: LD_INT 23
83142: EQUAL
83143: IFFALSE 83153
// sOilTower := true ;
83145: LD_ADDR_EXP 119
83149: PUSH
83150: LD_INT 1
83152: ST_TO_ADDR
// if p3 = 24 then
83153: LD_VAR 0 3
83157: PUSH
83158: LD_INT 24
83160: EQUAL
83161: IFFALSE 83171
// sShovel := true ;
83163: LD_ADDR_EXP 120
83167: PUSH
83168: LD_INT 1
83170: ST_TO_ADDR
// if p3 = 25 then
83171: LD_VAR 0 3
83175: PUSH
83176: LD_INT 25
83178: EQUAL
83179: IFFALSE 83189
// sSheik := true ;
83181: LD_ADDR_EXP 121
83185: PUSH
83186: LD_INT 1
83188: ST_TO_ADDR
// if p3 = 26 then
83189: LD_VAR 0 3
83193: PUSH
83194: LD_INT 26
83196: EQUAL
83197: IFFALSE 83207
// sEarthquake := true ;
83199: LD_ADDR_EXP 123
83203: PUSH
83204: LD_INT 1
83206: ST_TO_ADDR
// if p3 = 27 then
83207: LD_VAR 0 3
83211: PUSH
83212: LD_INT 27
83214: EQUAL
83215: IFFALSE 83225
// sAI := true ;
83217: LD_ADDR_EXP 124
83221: PUSH
83222: LD_INT 1
83224: ST_TO_ADDR
// if p3 = 28 then
83225: LD_VAR 0 3
83229: PUSH
83230: LD_INT 28
83232: EQUAL
83233: IFFALSE 83243
// sCargo := true ;
83235: LD_ADDR_EXP 127
83239: PUSH
83240: LD_INT 1
83242: ST_TO_ADDR
// if p3 = 29 then
83243: LD_VAR 0 3
83247: PUSH
83248: LD_INT 29
83250: EQUAL
83251: IFFALSE 83261
// sDLaser := true ;
83253: LD_ADDR_EXP 128
83257: PUSH
83258: LD_INT 1
83260: ST_TO_ADDR
// if p3 = 30 then
83261: LD_VAR 0 3
83265: PUSH
83266: LD_INT 30
83268: EQUAL
83269: IFFALSE 83279
// sExchange := true ;
83271: LD_ADDR_EXP 129
83275: PUSH
83276: LD_INT 1
83278: ST_TO_ADDR
// if p3 = 31 then
83279: LD_VAR 0 3
83283: PUSH
83284: LD_INT 31
83286: EQUAL
83287: IFFALSE 83297
// sFac := true ;
83289: LD_ADDR_EXP 130
83293: PUSH
83294: LD_INT 1
83296: ST_TO_ADDR
// if p3 = 32 then
83297: LD_VAR 0 3
83301: PUSH
83302: LD_INT 32
83304: EQUAL
83305: IFFALSE 83315
// sPower := true ;
83307: LD_ADDR_EXP 131
83311: PUSH
83312: LD_INT 1
83314: ST_TO_ADDR
// if p3 = 33 then
83315: LD_VAR 0 3
83319: PUSH
83320: LD_INT 33
83322: EQUAL
83323: IFFALSE 83333
// sRandom := true ;
83325: LD_ADDR_EXP 132
83329: PUSH
83330: LD_INT 1
83332: ST_TO_ADDR
// if p3 = 34 then
83333: LD_VAR 0 3
83337: PUSH
83338: LD_INT 34
83340: EQUAL
83341: IFFALSE 83351
// sShield := true ;
83343: LD_ADDR_EXP 133
83347: PUSH
83348: LD_INT 1
83350: ST_TO_ADDR
// if p3 = 35 then
83351: LD_VAR 0 3
83355: PUSH
83356: LD_INT 35
83358: EQUAL
83359: IFFALSE 83369
// sTime := true ;
83361: LD_ADDR_EXP 134
83365: PUSH
83366: LD_INT 1
83368: ST_TO_ADDR
// if p3 = 36 then
83369: LD_VAR 0 3
83373: PUSH
83374: LD_INT 36
83376: EQUAL
83377: IFFALSE 83387
// sTools := true ;
83379: LD_ADDR_EXP 135
83383: PUSH
83384: LD_INT 1
83386: ST_TO_ADDR
// if p3 = 101 then
83387: LD_VAR 0 3
83391: PUSH
83392: LD_INT 101
83394: EQUAL
83395: IFFALSE 83405
// sSold := true ;
83397: LD_ADDR_EXP 100
83401: PUSH
83402: LD_INT 1
83404: ST_TO_ADDR
// if p3 = 102 then
83405: LD_VAR 0 3
83409: PUSH
83410: LD_INT 102
83412: EQUAL
83413: IFFALSE 83423
// sDiff := true ;
83415: LD_ADDR_EXP 101
83419: PUSH
83420: LD_INT 1
83422: ST_TO_ADDR
// if p3 = 103 then
83423: LD_VAR 0 3
83427: PUSH
83428: LD_INT 103
83430: EQUAL
83431: IFFALSE 83441
// sFog := true ;
83433: LD_ADDR_EXP 104
83437: PUSH
83438: LD_INT 1
83440: ST_TO_ADDR
// if p3 = 104 then
83441: LD_VAR 0 3
83445: PUSH
83446: LD_INT 104
83448: EQUAL
83449: IFFALSE 83459
// sReset := true ;
83451: LD_ADDR_EXP 105
83455: PUSH
83456: LD_INT 1
83458: ST_TO_ADDR
// if p3 = 105 then
83459: LD_VAR 0 3
83463: PUSH
83464: LD_INT 105
83466: EQUAL
83467: IFFALSE 83477
// sSun := true ;
83469: LD_ADDR_EXP 106
83473: PUSH
83474: LD_INT 1
83476: ST_TO_ADDR
// if p3 = 106 then
83477: LD_VAR 0 3
83481: PUSH
83482: LD_INT 106
83484: EQUAL
83485: IFFALSE 83495
// sTiger := true ;
83487: LD_ADDR_EXP 102
83491: PUSH
83492: LD_INT 1
83494: ST_TO_ADDR
// if p3 = 107 then
83495: LD_VAR 0 3
83499: PUSH
83500: LD_INT 107
83502: EQUAL
83503: IFFALSE 83513
// sBomb := true ;
83505: LD_ADDR_EXP 103
83509: PUSH
83510: LD_INT 1
83512: ST_TO_ADDR
// if p3 = 108 then
83513: LD_VAR 0 3
83517: PUSH
83518: LD_INT 108
83520: EQUAL
83521: IFFALSE 83531
// sWound := true ;
83523: LD_ADDR_EXP 111
83527: PUSH
83528: LD_INT 1
83530: ST_TO_ADDR
// if p3 = 109 then
83531: LD_VAR 0 3
83535: PUSH
83536: LD_INT 109
83538: EQUAL
83539: IFFALSE 83549
// sBetray := true ;
83541: LD_ADDR_EXP 115
83545: PUSH
83546: LD_INT 1
83548: ST_TO_ADDR
// if p3 = 110 then
83549: LD_VAR 0 3
83553: PUSH
83554: LD_INT 110
83556: EQUAL
83557: IFFALSE 83567
// sContamin := true ;
83559: LD_ADDR_EXP 116
83563: PUSH
83564: LD_INT 1
83566: ST_TO_ADDR
// if p3 = 111 then
83567: LD_VAR 0 3
83571: PUSH
83572: LD_INT 111
83574: EQUAL
83575: IFFALSE 83585
// sOil := true ;
83577: LD_ADDR_EXP 118
83581: PUSH
83582: LD_INT 1
83584: ST_TO_ADDR
// if p3 = 112 then
83585: LD_VAR 0 3
83589: PUSH
83590: LD_INT 112
83592: EQUAL
83593: IFFALSE 83603
// sStu := true ;
83595: LD_ADDR_EXP 122
83599: PUSH
83600: LD_INT 1
83602: ST_TO_ADDR
// if p3 = 113 then
83603: LD_VAR 0 3
83607: PUSH
83608: LD_INT 113
83610: EQUAL
83611: IFFALSE 83621
// sBazooka := true ;
83613: LD_ADDR_EXP 125
83617: PUSH
83618: LD_INT 1
83620: ST_TO_ADDR
// if p3 = 114 then
83621: LD_VAR 0 3
83625: PUSH
83626: LD_INT 114
83628: EQUAL
83629: IFFALSE 83639
// sMortar := true ;
83631: LD_ADDR_EXP 126
83635: PUSH
83636: LD_INT 1
83638: ST_TO_ADDR
// if p3 = 115 then
83639: LD_VAR 0 3
83643: PUSH
83644: LD_INT 115
83646: EQUAL
83647: IFFALSE 83657
// sRanger := true ;
83649: LD_ADDR_EXP 136
83653: PUSH
83654: LD_INT 1
83656: ST_TO_ADDR
// end ; if p2 = 101 then
83657: LD_VAR 0 2
83661: PUSH
83662: LD_INT 101
83664: EQUAL
83665: IFFALSE 83793
// begin case p3 of 1 :
83667: LD_VAR 0 3
83671: PUSH
83672: LD_INT 1
83674: DOUBLE
83675: EQUAL
83676: IFTRUE 83680
83678: GO 83687
83680: POP
// hHackUnlimitedResources ; 2 :
83681: CALL 94828 0 0
83685: GO 83793
83687: LD_INT 2
83689: DOUBLE
83690: EQUAL
83691: IFTRUE 83695
83693: GO 83702
83695: POP
// hHackSetLevel10 ; 3 :
83696: CALL 94961 0 0
83700: GO 83793
83702: LD_INT 3
83704: DOUBLE
83705: EQUAL
83706: IFTRUE 83710
83708: GO 83717
83710: POP
// hHackSetLevel10YourUnits ; 4 :
83711: CALL 95046 0 0
83715: GO 83793
83717: LD_INT 4
83719: DOUBLE
83720: EQUAL
83721: IFTRUE 83725
83723: GO 83732
83725: POP
// hHackInvincible ; 5 :
83726: CALL 95494 0 0
83730: GO 83793
83732: LD_INT 5
83734: DOUBLE
83735: EQUAL
83736: IFTRUE 83740
83738: GO 83747
83740: POP
// hHackInvisible ; 6 :
83741: CALL 95605 0 0
83745: GO 83793
83747: LD_INT 6
83749: DOUBLE
83750: EQUAL
83751: IFTRUE 83755
83753: GO 83762
83755: POP
// hHackChangeYourSide ; 7 :
83756: CALL 95662 0 0
83760: GO 83793
83762: LD_INT 7
83764: DOUBLE
83765: EQUAL
83766: IFTRUE 83770
83768: GO 83777
83770: POP
// hHackChangeUnitSide ; 8 :
83771: CALL 95704 0 0
83775: GO 83793
83777: LD_INT 8
83779: DOUBLE
83780: EQUAL
83781: IFTRUE 83785
83783: GO 83792
83785: POP
// hHackFog ; end ;
83786: CALL 95805 0 0
83790: GO 83793
83792: POP
// end ; end ;
83793: PPOPN 6
83795: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
83796: GO 83798
83798: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
83799: LD_STRING initStreamRollete();
83801: PPUSH
83802: CALL_OW 559
// InitStreamMode ;
83806: CALL 83815 0 0
// DefineStreamItems ( ) ;
83810: CALL 84255 0 0
// end ;
83814: END
// function InitStreamMode ; begin
83815: LD_INT 0
83817: PPUSH
// streamModeActive := false ;
83818: LD_ADDR_EXP 83
83822: PUSH
83823: LD_INT 0
83825: ST_TO_ADDR
// normalCounter := 36 ;
83826: LD_ADDR_EXP 84
83830: PUSH
83831: LD_INT 36
83833: ST_TO_ADDR
// hardcoreCounter := 16 ;
83834: LD_ADDR_EXP 85
83838: PUSH
83839: LD_INT 16
83841: ST_TO_ADDR
// sRocket := false ;
83842: LD_ADDR_EXP 88
83846: PUSH
83847: LD_INT 0
83849: ST_TO_ADDR
// sSpeed := false ;
83850: LD_ADDR_EXP 87
83854: PUSH
83855: LD_INT 0
83857: ST_TO_ADDR
// sEngine := false ;
83858: LD_ADDR_EXP 89
83862: PUSH
83863: LD_INT 0
83865: ST_TO_ADDR
// sSpec := false ;
83866: LD_ADDR_EXP 86
83870: PUSH
83871: LD_INT 0
83873: ST_TO_ADDR
// sLevel := false ;
83874: LD_ADDR_EXP 90
83878: PUSH
83879: LD_INT 0
83881: ST_TO_ADDR
// sArmoury := false ;
83882: LD_ADDR_EXP 91
83886: PUSH
83887: LD_INT 0
83889: ST_TO_ADDR
// sRadar := false ;
83890: LD_ADDR_EXP 92
83894: PUSH
83895: LD_INT 0
83897: ST_TO_ADDR
// sBunker := false ;
83898: LD_ADDR_EXP 93
83902: PUSH
83903: LD_INT 0
83905: ST_TO_ADDR
// sHack := false ;
83906: LD_ADDR_EXP 94
83910: PUSH
83911: LD_INT 0
83913: ST_TO_ADDR
// sFire := false ;
83914: LD_ADDR_EXP 95
83918: PUSH
83919: LD_INT 0
83921: ST_TO_ADDR
// sRefresh := false ;
83922: LD_ADDR_EXP 96
83926: PUSH
83927: LD_INT 0
83929: ST_TO_ADDR
// sExp := false ;
83930: LD_ADDR_EXP 97
83934: PUSH
83935: LD_INT 0
83937: ST_TO_ADDR
// sDepot := false ;
83938: LD_ADDR_EXP 98
83942: PUSH
83943: LD_INT 0
83945: ST_TO_ADDR
// sFlag := false ;
83946: LD_ADDR_EXP 99
83950: PUSH
83951: LD_INT 0
83953: ST_TO_ADDR
// sKamikadze := false ;
83954: LD_ADDR_EXP 107
83958: PUSH
83959: LD_INT 0
83961: ST_TO_ADDR
// sTroll := false ;
83962: LD_ADDR_EXP 108
83966: PUSH
83967: LD_INT 0
83969: ST_TO_ADDR
// sSlow := false ;
83970: LD_ADDR_EXP 109
83974: PUSH
83975: LD_INT 0
83977: ST_TO_ADDR
// sLack := false ;
83978: LD_ADDR_EXP 110
83982: PUSH
83983: LD_INT 0
83985: ST_TO_ADDR
// sTank := false ;
83986: LD_ADDR_EXP 112
83990: PUSH
83991: LD_INT 0
83993: ST_TO_ADDR
// sRemote := false ;
83994: LD_ADDR_EXP 113
83998: PUSH
83999: LD_INT 0
84001: ST_TO_ADDR
// sPowell := false ;
84002: LD_ADDR_EXP 114
84006: PUSH
84007: LD_INT 0
84009: ST_TO_ADDR
// sTeleport := false ;
84010: LD_ADDR_EXP 117
84014: PUSH
84015: LD_INT 0
84017: ST_TO_ADDR
// sOilTower := false ;
84018: LD_ADDR_EXP 119
84022: PUSH
84023: LD_INT 0
84025: ST_TO_ADDR
// sShovel := false ;
84026: LD_ADDR_EXP 120
84030: PUSH
84031: LD_INT 0
84033: ST_TO_ADDR
// sSheik := false ;
84034: LD_ADDR_EXP 121
84038: PUSH
84039: LD_INT 0
84041: ST_TO_ADDR
// sEarthquake := false ;
84042: LD_ADDR_EXP 123
84046: PUSH
84047: LD_INT 0
84049: ST_TO_ADDR
// sAI := false ;
84050: LD_ADDR_EXP 124
84054: PUSH
84055: LD_INT 0
84057: ST_TO_ADDR
// sCargo := false ;
84058: LD_ADDR_EXP 127
84062: PUSH
84063: LD_INT 0
84065: ST_TO_ADDR
// sDLaser := false ;
84066: LD_ADDR_EXP 128
84070: PUSH
84071: LD_INT 0
84073: ST_TO_ADDR
// sExchange := false ;
84074: LD_ADDR_EXP 129
84078: PUSH
84079: LD_INT 0
84081: ST_TO_ADDR
// sFac := false ;
84082: LD_ADDR_EXP 130
84086: PUSH
84087: LD_INT 0
84089: ST_TO_ADDR
// sPower := false ;
84090: LD_ADDR_EXP 131
84094: PUSH
84095: LD_INT 0
84097: ST_TO_ADDR
// sRandom := false ;
84098: LD_ADDR_EXP 132
84102: PUSH
84103: LD_INT 0
84105: ST_TO_ADDR
// sShield := false ;
84106: LD_ADDR_EXP 133
84110: PUSH
84111: LD_INT 0
84113: ST_TO_ADDR
// sTime := false ;
84114: LD_ADDR_EXP 134
84118: PUSH
84119: LD_INT 0
84121: ST_TO_ADDR
// sTools := false ;
84122: LD_ADDR_EXP 135
84126: PUSH
84127: LD_INT 0
84129: ST_TO_ADDR
// sSold := false ;
84130: LD_ADDR_EXP 100
84134: PUSH
84135: LD_INT 0
84137: ST_TO_ADDR
// sDiff := false ;
84138: LD_ADDR_EXP 101
84142: PUSH
84143: LD_INT 0
84145: ST_TO_ADDR
// sFog := false ;
84146: LD_ADDR_EXP 104
84150: PUSH
84151: LD_INT 0
84153: ST_TO_ADDR
// sReset := false ;
84154: LD_ADDR_EXP 105
84158: PUSH
84159: LD_INT 0
84161: ST_TO_ADDR
// sSun := false ;
84162: LD_ADDR_EXP 106
84166: PUSH
84167: LD_INT 0
84169: ST_TO_ADDR
// sTiger := false ;
84170: LD_ADDR_EXP 102
84174: PUSH
84175: LD_INT 0
84177: ST_TO_ADDR
// sBomb := false ;
84178: LD_ADDR_EXP 103
84182: PUSH
84183: LD_INT 0
84185: ST_TO_ADDR
// sWound := false ;
84186: LD_ADDR_EXP 111
84190: PUSH
84191: LD_INT 0
84193: ST_TO_ADDR
// sBetray := false ;
84194: LD_ADDR_EXP 115
84198: PUSH
84199: LD_INT 0
84201: ST_TO_ADDR
// sContamin := false ;
84202: LD_ADDR_EXP 116
84206: PUSH
84207: LD_INT 0
84209: ST_TO_ADDR
// sOil := false ;
84210: LD_ADDR_EXP 118
84214: PUSH
84215: LD_INT 0
84217: ST_TO_ADDR
// sStu := false ;
84218: LD_ADDR_EXP 122
84222: PUSH
84223: LD_INT 0
84225: ST_TO_ADDR
// sBazooka := false ;
84226: LD_ADDR_EXP 125
84230: PUSH
84231: LD_INT 0
84233: ST_TO_ADDR
// sMortar := false ;
84234: LD_ADDR_EXP 126
84238: PUSH
84239: LD_INT 0
84241: ST_TO_ADDR
// sRanger := false ;
84242: LD_ADDR_EXP 136
84246: PUSH
84247: LD_INT 0
84249: ST_TO_ADDR
// end ;
84250: LD_VAR 0 1
84254: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
84255: LD_INT 0
84257: PPUSH
84258: PPUSH
84259: PPUSH
84260: PPUSH
84261: PPUSH
// result := [ ] ;
84262: LD_ADDR_VAR 0 1
84266: PUSH
84267: EMPTY
84268: ST_TO_ADDR
// if campaign_id = 1 then
84269: LD_OWVAR 69
84273: PUSH
84274: LD_INT 1
84276: EQUAL
84277: IFFALSE 87215
// begin case mission_number of 1 :
84279: LD_OWVAR 70
84283: PUSH
84284: LD_INT 1
84286: DOUBLE
84287: EQUAL
84288: IFTRUE 84292
84290: GO 84356
84292: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
84293: LD_ADDR_VAR 0 1
84297: PUSH
84298: LD_INT 2
84300: PUSH
84301: LD_INT 4
84303: PUSH
84304: LD_INT 11
84306: PUSH
84307: LD_INT 12
84309: PUSH
84310: LD_INT 15
84312: PUSH
84313: LD_INT 16
84315: PUSH
84316: LD_INT 22
84318: PUSH
84319: LD_INT 23
84321: PUSH
84322: LD_INT 26
84324: PUSH
84325: EMPTY
84326: LIST
84327: LIST
84328: LIST
84329: LIST
84330: LIST
84331: LIST
84332: LIST
84333: LIST
84334: LIST
84335: PUSH
84336: LD_INT 101
84338: PUSH
84339: LD_INT 102
84341: PUSH
84342: LD_INT 106
84344: PUSH
84345: EMPTY
84346: LIST
84347: LIST
84348: LIST
84349: PUSH
84350: EMPTY
84351: LIST
84352: LIST
84353: ST_TO_ADDR
84354: GO 87213
84356: LD_INT 2
84358: DOUBLE
84359: EQUAL
84360: IFTRUE 84364
84362: GO 84436
84364: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
84365: LD_ADDR_VAR 0 1
84369: PUSH
84370: LD_INT 2
84372: PUSH
84373: LD_INT 4
84375: PUSH
84376: LD_INT 11
84378: PUSH
84379: LD_INT 12
84381: PUSH
84382: LD_INT 15
84384: PUSH
84385: LD_INT 16
84387: PUSH
84388: LD_INT 22
84390: PUSH
84391: LD_INT 23
84393: PUSH
84394: LD_INT 26
84396: PUSH
84397: EMPTY
84398: LIST
84399: LIST
84400: LIST
84401: LIST
84402: LIST
84403: LIST
84404: LIST
84405: LIST
84406: LIST
84407: PUSH
84408: LD_INT 101
84410: PUSH
84411: LD_INT 102
84413: PUSH
84414: LD_INT 105
84416: PUSH
84417: LD_INT 106
84419: PUSH
84420: LD_INT 108
84422: PUSH
84423: EMPTY
84424: LIST
84425: LIST
84426: LIST
84427: LIST
84428: LIST
84429: PUSH
84430: EMPTY
84431: LIST
84432: LIST
84433: ST_TO_ADDR
84434: GO 87213
84436: LD_INT 3
84438: DOUBLE
84439: EQUAL
84440: IFTRUE 84444
84442: GO 84520
84444: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
84445: LD_ADDR_VAR 0 1
84449: PUSH
84450: LD_INT 2
84452: PUSH
84453: LD_INT 4
84455: PUSH
84456: LD_INT 5
84458: PUSH
84459: LD_INT 11
84461: PUSH
84462: LD_INT 12
84464: PUSH
84465: LD_INT 15
84467: PUSH
84468: LD_INT 16
84470: PUSH
84471: LD_INT 22
84473: PUSH
84474: LD_INT 26
84476: PUSH
84477: LD_INT 36
84479: PUSH
84480: EMPTY
84481: LIST
84482: LIST
84483: LIST
84484: LIST
84485: LIST
84486: LIST
84487: LIST
84488: LIST
84489: LIST
84490: LIST
84491: PUSH
84492: LD_INT 101
84494: PUSH
84495: LD_INT 102
84497: PUSH
84498: LD_INT 105
84500: PUSH
84501: LD_INT 106
84503: PUSH
84504: LD_INT 108
84506: PUSH
84507: EMPTY
84508: LIST
84509: LIST
84510: LIST
84511: LIST
84512: LIST
84513: PUSH
84514: EMPTY
84515: LIST
84516: LIST
84517: ST_TO_ADDR
84518: GO 87213
84520: LD_INT 4
84522: DOUBLE
84523: EQUAL
84524: IFTRUE 84528
84526: GO 84612
84528: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
84529: LD_ADDR_VAR 0 1
84533: PUSH
84534: LD_INT 2
84536: PUSH
84537: LD_INT 4
84539: PUSH
84540: LD_INT 5
84542: PUSH
84543: LD_INT 8
84545: PUSH
84546: LD_INT 11
84548: PUSH
84549: LD_INT 12
84551: PUSH
84552: LD_INT 15
84554: PUSH
84555: LD_INT 16
84557: PUSH
84558: LD_INT 22
84560: PUSH
84561: LD_INT 23
84563: PUSH
84564: LD_INT 26
84566: PUSH
84567: LD_INT 36
84569: PUSH
84570: EMPTY
84571: LIST
84572: LIST
84573: LIST
84574: LIST
84575: LIST
84576: LIST
84577: LIST
84578: LIST
84579: LIST
84580: LIST
84581: LIST
84582: LIST
84583: PUSH
84584: LD_INT 101
84586: PUSH
84587: LD_INT 102
84589: PUSH
84590: LD_INT 105
84592: PUSH
84593: LD_INT 106
84595: PUSH
84596: LD_INT 108
84598: PUSH
84599: EMPTY
84600: LIST
84601: LIST
84602: LIST
84603: LIST
84604: LIST
84605: PUSH
84606: EMPTY
84607: LIST
84608: LIST
84609: ST_TO_ADDR
84610: GO 87213
84612: LD_INT 5
84614: DOUBLE
84615: EQUAL
84616: IFTRUE 84620
84618: GO 84720
84620: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
84621: LD_ADDR_VAR 0 1
84625: PUSH
84626: LD_INT 2
84628: PUSH
84629: LD_INT 4
84631: PUSH
84632: LD_INT 5
84634: PUSH
84635: LD_INT 6
84637: PUSH
84638: LD_INT 8
84640: PUSH
84641: LD_INT 11
84643: PUSH
84644: LD_INT 12
84646: PUSH
84647: LD_INT 15
84649: PUSH
84650: LD_INT 16
84652: PUSH
84653: LD_INT 22
84655: PUSH
84656: LD_INT 23
84658: PUSH
84659: LD_INT 25
84661: PUSH
84662: LD_INT 26
84664: PUSH
84665: LD_INT 36
84667: PUSH
84668: EMPTY
84669: LIST
84670: LIST
84671: LIST
84672: LIST
84673: LIST
84674: LIST
84675: LIST
84676: LIST
84677: LIST
84678: LIST
84679: LIST
84680: LIST
84681: LIST
84682: LIST
84683: PUSH
84684: LD_INT 101
84686: PUSH
84687: LD_INT 102
84689: PUSH
84690: LD_INT 105
84692: PUSH
84693: LD_INT 106
84695: PUSH
84696: LD_INT 108
84698: PUSH
84699: LD_INT 109
84701: PUSH
84702: LD_INT 112
84704: PUSH
84705: EMPTY
84706: LIST
84707: LIST
84708: LIST
84709: LIST
84710: LIST
84711: LIST
84712: LIST
84713: PUSH
84714: EMPTY
84715: LIST
84716: LIST
84717: ST_TO_ADDR
84718: GO 87213
84720: LD_INT 6
84722: DOUBLE
84723: EQUAL
84724: IFTRUE 84728
84726: GO 84848
84728: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
84729: LD_ADDR_VAR 0 1
84733: PUSH
84734: LD_INT 2
84736: PUSH
84737: LD_INT 4
84739: PUSH
84740: LD_INT 5
84742: PUSH
84743: LD_INT 6
84745: PUSH
84746: LD_INT 8
84748: PUSH
84749: LD_INT 11
84751: PUSH
84752: LD_INT 12
84754: PUSH
84755: LD_INT 15
84757: PUSH
84758: LD_INT 16
84760: PUSH
84761: LD_INT 20
84763: PUSH
84764: LD_INT 21
84766: PUSH
84767: LD_INT 22
84769: PUSH
84770: LD_INT 23
84772: PUSH
84773: LD_INT 25
84775: PUSH
84776: LD_INT 26
84778: PUSH
84779: LD_INT 30
84781: PUSH
84782: LD_INT 31
84784: PUSH
84785: LD_INT 32
84787: PUSH
84788: LD_INT 36
84790: PUSH
84791: EMPTY
84792: LIST
84793: LIST
84794: LIST
84795: LIST
84796: LIST
84797: LIST
84798: LIST
84799: LIST
84800: LIST
84801: LIST
84802: LIST
84803: LIST
84804: LIST
84805: LIST
84806: LIST
84807: LIST
84808: LIST
84809: LIST
84810: LIST
84811: PUSH
84812: LD_INT 101
84814: PUSH
84815: LD_INT 102
84817: PUSH
84818: LD_INT 105
84820: PUSH
84821: LD_INT 106
84823: PUSH
84824: LD_INT 108
84826: PUSH
84827: LD_INT 109
84829: PUSH
84830: LD_INT 112
84832: PUSH
84833: EMPTY
84834: LIST
84835: LIST
84836: LIST
84837: LIST
84838: LIST
84839: LIST
84840: LIST
84841: PUSH
84842: EMPTY
84843: LIST
84844: LIST
84845: ST_TO_ADDR
84846: GO 87213
84848: LD_INT 7
84850: DOUBLE
84851: EQUAL
84852: IFTRUE 84856
84854: GO 84956
84856: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
84857: LD_ADDR_VAR 0 1
84861: PUSH
84862: LD_INT 2
84864: PUSH
84865: LD_INT 4
84867: PUSH
84868: LD_INT 5
84870: PUSH
84871: LD_INT 7
84873: PUSH
84874: LD_INT 11
84876: PUSH
84877: LD_INT 12
84879: PUSH
84880: LD_INT 15
84882: PUSH
84883: LD_INT 16
84885: PUSH
84886: LD_INT 20
84888: PUSH
84889: LD_INT 21
84891: PUSH
84892: LD_INT 22
84894: PUSH
84895: LD_INT 23
84897: PUSH
84898: LD_INT 25
84900: PUSH
84901: LD_INT 26
84903: PUSH
84904: EMPTY
84905: LIST
84906: LIST
84907: LIST
84908: LIST
84909: LIST
84910: LIST
84911: LIST
84912: LIST
84913: LIST
84914: LIST
84915: LIST
84916: LIST
84917: LIST
84918: LIST
84919: PUSH
84920: LD_INT 101
84922: PUSH
84923: LD_INT 102
84925: PUSH
84926: LD_INT 103
84928: PUSH
84929: LD_INT 105
84931: PUSH
84932: LD_INT 106
84934: PUSH
84935: LD_INT 108
84937: PUSH
84938: LD_INT 112
84940: PUSH
84941: EMPTY
84942: LIST
84943: LIST
84944: LIST
84945: LIST
84946: LIST
84947: LIST
84948: LIST
84949: PUSH
84950: EMPTY
84951: LIST
84952: LIST
84953: ST_TO_ADDR
84954: GO 87213
84956: LD_INT 8
84958: DOUBLE
84959: EQUAL
84960: IFTRUE 84964
84962: GO 85092
84964: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
84965: LD_ADDR_VAR 0 1
84969: PUSH
84970: LD_INT 2
84972: PUSH
84973: LD_INT 4
84975: PUSH
84976: LD_INT 5
84978: PUSH
84979: LD_INT 6
84981: PUSH
84982: LD_INT 7
84984: PUSH
84985: LD_INT 8
84987: PUSH
84988: LD_INT 11
84990: PUSH
84991: LD_INT 12
84993: PUSH
84994: LD_INT 15
84996: PUSH
84997: LD_INT 16
84999: PUSH
85000: LD_INT 20
85002: PUSH
85003: LD_INT 21
85005: PUSH
85006: LD_INT 22
85008: PUSH
85009: LD_INT 23
85011: PUSH
85012: LD_INT 25
85014: PUSH
85015: LD_INT 26
85017: PUSH
85018: LD_INT 30
85020: PUSH
85021: LD_INT 31
85023: PUSH
85024: LD_INT 32
85026: PUSH
85027: LD_INT 36
85029: PUSH
85030: EMPTY
85031: LIST
85032: LIST
85033: LIST
85034: LIST
85035: LIST
85036: LIST
85037: LIST
85038: LIST
85039: LIST
85040: LIST
85041: LIST
85042: LIST
85043: LIST
85044: LIST
85045: LIST
85046: LIST
85047: LIST
85048: LIST
85049: LIST
85050: LIST
85051: PUSH
85052: LD_INT 101
85054: PUSH
85055: LD_INT 102
85057: PUSH
85058: LD_INT 103
85060: PUSH
85061: LD_INT 105
85063: PUSH
85064: LD_INT 106
85066: PUSH
85067: LD_INT 108
85069: PUSH
85070: LD_INT 109
85072: PUSH
85073: LD_INT 112
85075: PUSH
85076: EMPTY
85077: LIST
85078: LIST
85079: LIST
85080: LIST
85081: LIST
85082: LIST
85083: LIST
85084: LIST
85085: PUSH
85086: EMPTY
85087: LIST
85088: LIST
85089: ST_TO_ADDR
85090: GO 87213
85092: LD_INT 9
85094: DOUBLE
85095: EQUAL
85096: IFTRUE 85100
85098: GO 85236
85100: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
85101: LD_ADDR_VAR 0 1
85105: PUSH
85106: LD_INT 2
85108: PUSH
85109: LD_INT 4
85111: PUSH
85112: LD_INT 5
85114: PUSH
85115: LD_INT 6
85117: PUSH
85118: LD_INT 7
85120: PUSH
85121: LD_INT 8
85123: PUSH
85124: LD_INT 11
85126: PUSH
85127: LD_INT 12
85129: PUSH
85130: LD_INT 15
85132: PUSH
85133: LD_INT 16
85135: PUSH
85136: LD_INT 20
85138: PUSH
85139: LD_INT 21
85141: PUSH
85142: LD_INT 22
85144: PUSH
85145: LD_INT 23
85147: PUSH
85148: LD_INT 25
85150: PUSH
85151: LD_INT 26
85153: PUSH
85154: LD_INT 28
85156: PUSH
85157: LD_INT 30
85159: PUSH
85160: LD_INT 31
85162: PUSH
85163: LD_INT 32
85165: PUSH
85166: LD_INT 36
85168: PUSH
85169: EMPTY
85170: LIST
85171: LIST
85172: LIST
85173: LIST
85174: LIST
85175: LIST
85176: LIST
85177: LIST
85178: LIST
85179: LIST
85180: LIST
85181: LIST
85182: LIST
85183: LIST
85184: LIST
85185: LIST
85186: LIST
85187: LIST
85188: LIST
85189: LIST
85190: LIST
85191: PUSH
85192: LD_INT 101
85194: PUSH
85195: LD_INT 102
85197: PUSH
85198: LD_INT 103
85200: PUSH
85201: LD_INT 105
85203: PUSH
85204: LD_INT 106
85206: PUSH
85207: LD_INT 108
85209: PUSH
85210: LD_INT 109
85212: PUSH
85213: LD_INT 112
85215: PUSH
85216: LD_INT 114
85218: PUSH
85219: EMPTY
85220: LIST
85221: LIST
85222: LIST
85223: LIST
85224: LIST
85225: LIST
85226: LIST
85227: LIST
85228: LIST
85229: PUSH
85230: EMPTY
85231: LIST
85232: LIST
85233: ST_TO_ADDR
85234: GO 87213
85236: LD_INT 10
85238: DOUBLE
85239: EQUAL
85240: IFTRUE 85244
85242: GO 85428
85244: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
85245: LD_ADDR_VAR 0 1
85249: PUSH
85250: LD_INT 2
85252: PUSH
85253: LD_INT 4
85255: PUSH
85256: LD_INT 5
85258: PUSH
85259: LD_INT 6
85261: PUSH
85262: LD_INT 7
85264: PUSH
85265: LD_INT 8
85267: PUSH
85268: LD_INT 9
85270: PUSH
85271: LD_INT 10
85273: PUSH
85274: LD_INT 11
85276: PUSH
85277: LD_INT 12
85279: PUSH
85280: LD_INT 13
85282: PUSH
85283: LD_INT 14
85285: PUSH
85286: LD_INT 15
85288: PUSH
85289: LD_INT 16
85291: PUSH
85292: LD_INT 17
85294: PUSH
85295: LD_INT 18
85297: PUSH
85298: LD_INT 19
85300: PUSH
85301: LD_INT 20
85303: PUSH
85304: LD_INT 21
85306: PUSH
85307: LD_INT 22
85309: PUSH
85310: LD_INT 23
85312: PUSH
85313: LD_INT 24
85315: PUSH
85316: LD_INT 25
85318: PUSH
85319: LD_INT 26
85321: PUSH
85322: LD_INT 28
85324: PUSH
85325: LD_INT 30
85327: PUSH
85328: LD_INT 31
85330: PUSH
85331: LD_INT 32
85333: PUSH
85334: LD_INT 36
85336: PUSH
85337: EMPTY
85338: LIST
85339: LIST
85340: LIST
85341: LIST
85342: LIST
85343: LIST
85344: LIST
85345: LIST
85346: LIST
85347: LIST
85348: LIST
85349: LIST
85350: LIST
85351: LIST
85352: LIST
85353: LIST
85354: LIST
85355: LIST
85356: LIST
85357: LIST
85358: LIST
85359: LIST
85360: LIST
85361: LIST
85362: LIST
85363: LIST
85364: LIST
85365: LIST
85366: LIST
85367: PUSH
85368: LD_INT 101
85370: PUSH
85371: LD_INT 102
85373: PUSH
85374: LD_INT 103
85376: PUSH
85377: LD_INT 104
85379: PUSH
85380: LD_INT 105
85382: PUSH
85383: LD_INT 106
85385: PUSH
85386: LD_INT 107
85388: PUSH
85389: LD_INT 108
85391: PUSH
85392: LD_INT 109
85394: PUSH
85395: LD_INT 110
85397: PUSH
85398: LD_INT 111
85400: PUSH
85401: LD_INT 112
85403: PUSH
85404: LD_INT 114
85406: PUSH
85407: EMPTY
85408: LIST
85409: LIST
85410: LIST
85411: LIST
85412: LIST
85413: LIST
85414: LIST
85415: LIST
85416: LIST
85417: LIST
85418: LIST
85419: LIST
85420: LIST
85421: PUSH
85422: EMPTY
85423: LIST
85424: LIST
85425: ST_TO_ADDR
85426: GO 87213
85428: LD_INT 11
85430: DOUBLE
85431: EQUAL
85432: IFTRUE 85436
85434: GO 85628
85436: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
85437: LD_ADDR_VAR 0 1
85441: PUSH
85442: LD_INT 2
85444: PUSH
85445: LD_INT 3
85447: PUSH
85448: LD_INT 4
85450: PUSH
85451: LD_INT 5
85453: PUSH
85454: LD_INT 6
85456: PUSH
85457: LD_INT 7
85459: PUSH
85460: LD_INT 8
85462: PUSH
85463: LD_INT 9
85465: PUSH
85466: LD_INT 10
85468: PUSH
85469: LD_INT 11
85471: PUSH
85472: LD_INT 12
85474: PUSH
85475: LD_INT 13
85477: PUSH
85478: LD_INT 14
85480: PUSH
85481: LD_INT 15
85483: PUSH
85484: LD_INT 16
85486: PUSH
85487: LD_INT 17
85489: PUSH
85490: LD_INT 18
85492: PUSH
85493: LD_INT 19
85495: PUSH
85496: LD_INT 20
85498: PUSH
85499: LD_INT 21
85501: PUSH
85502: LD_INT 22
85504: PUSH
85505: LD_INT 23
85507: PUSH
85508: LD_INT 24
85510: PUSH
85511: LD_INT 25
85513: PUSH
85514: LD_INT 26
85516: PUSH
85517: LD_INT 28
85519: PUSH
85520: LD_INT 30
85522: PUSH
85523: LD_INT 31
85525: PUSH
85526: LD_INT 32
85528: PUSH
85529: LD_INT 34
85531: PUSH
85532: LD_INT 36
85534: PUSH
85535: EMPTY
85536: LIST
85537: LIST
85538: LIST
85539: LIST
85540: LIST
85541: LIST
85542: LIST
85543: LIST
85544: LIST
85545: LIST
85546: LIST
85547: LIST
85548: LIST
85549: LIST
85550: LIST
85551: LIST
85552: LIST
85553: LIST
85554: LIST
85555: LIST
85556: LIST
85557: LIST
85558: LIST
85559: LIST
85560: LIST
85561: LIST
85562: LIST
85563: LIST
85564: LIST
85565: LIST
85566: LIST
85567: PUSH
85568: LD_INT 101
85570: PUSH
85571: LD_INT 102
85573: PUSH
85574: LD_INT 103
85576: PUSH
85577: LD_INT 104
85579: PUSH
85580: LD_INT 105
85582: PUSH
85583: LD_INT 106
85585: PUSH
85586: LD_INT 107
85588: PUSH
85589: LD_INT 108
85591: PUSH
85592: LD_INT 109
85594: PUSH
85595: LD_INT 110
85597: PUSH
85598: LD_INT 111
85600: PUSH
85601: LD_INT 112
85603: PUSH
85604: LD_INT 114
85606: PUSH
85607: EMPTY
85608: LIST
85609: LIST
85610: LIST
85611: LIST
85612: LIST
85613: LIST
85614: LIST
85615: LIST
85616: LIST
85617: LIST
85618: LIST
85619: LIST
85620: LIST
85621: PUSH
85622: EMPTY
85623: LIST
85624: LIST
85625: ST_TO_ADDR
85626: GO 87213
85628: LD_INT 12
85630: DOUBLE
85631: EQUAL
85632: IFTRUE 85636
85634: GO 85844
85636: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
85637: LD_ADDR_VAR 0 1
85641: PUSH
85642: LD_INT 1
85644: PUSH
85645: LD_INT 2
85647: PUSH
85648: LD_INT 3
85650: PUSH
85651: LD_INT 4
85653: PUSH
85654: LD_INT 5
85656: PUSH
85657: LD_INT 6
85659: PUSH
85660: LD_INT 7
85662: PUSH
85663: LD_INT 8
85665: PUSH
85666: LD_INT 9
85668: PUSH
85669: LD_INT 10
85671: PUSH
85672: LD_INT 11
85674: PUSH
85675: LD_INT 12
85677: PUSH
85678: LD_INT 13
85680: PUSH
85681: LD_INT 14
85683: PUSH
85684: LD_INT 15
85686: PUSH
85687: LD_INT 16
85689: PUSH
85690: LD_INT 17
85692: PUSH
85693: LD_INT 18
85695: PUSH
85696: LD_INT 19
85698: PUSH
85699: LD_INT 20
85701: PUSH
85702: LD_INT 21
85704: PUSH
85705: LD_INT 22
85707: PUSH
85708: LD_INT 23
85710: PUSH
85711: LD_INT 24
85713: PUSH
85714: LD_INT 25
85716: PUSH
85717: LD_INT 26
85719: PUSH
85720: LD_INT 27
85722: PUSH
85723: LD_INT 28
85725: PUSH
85726: LD_INT 30
85728: PUSH
85729: LD_INT 31
85731: PUSH
85732: LD_INT 32
85734: PUSH
85735: LD_INT 33
85737: PUSH
85738: LD_INT 34
85740: PUSH
85741: LD_INT 36
85743: PUSH
85744: EMPTY
85745: LIST
85746: LIST
85747: LIST
85748: LIST
85749: LIST
85750: LIST
85751: LIST
85752: LIST
85753: LIST
85754: LIST
85755: LIST
85756: LIST
85757: LIST
85758: LIST
85759: LIST
85760: LIST
85761: LIST
85762: LIST
85763: LIST
85764: LIST
85765: LIST
85766: LIST
85767: LIST
85768: LIST
85769: LIST
85770: LIST
85771: LIST
85772: LIST
85773: LIST
85774: LIST
85775: LIST
85776: LIST
85777: LIST
85778: LIST
85779: PUSH
85780: LD_INT 101
85782: PUSH
85783: LD_INT 102
85785: PUSH
85786: LD_INT 103
85788: PUSH
85789: LD_INT 104
85791: PUSH
85792: LD_INT 105
85794: PUSH
85795: LD_INT 106
85797: PUSH
85798: LD_INT 107
85800: PUSH
85801: LD_INT 108
85803: PUSH
85804: LD_INT 109
85806: PUSH
85807: LD_INT 110
85809: PUSH
85810: LD_INT 111
85812: PUSH
85813: LD_INT 112
85815: PUSH
85816: LD_INT 113
85818: PUSH
85819: LD_INT 114
85821: PUSH
85822: EMPTY
85823: LIST
85824: LIST
85825: LIST
85826: LIST
85827: LIST
85828: LIST
85829: LIST
85830: LIST
85831: LIST
85832: LIST
85833: LIST
85834: LIST
85835: LIST
85836: LIST
85837: PUSH
85838: EMPTY
85839: LIST
85840: LIST
85841: ST_TO_ADDR
85842: GO 87213
85844: LD_INT 13
85846: DOUBLE
85847: EQUAL
85848: IFTRUE 85852
85850: GO 86048
85852: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
85853: LD_ADDR_VAR 0 1
85857: PUSH
85858: LD_INT 1
85860: PUSH
85861: LD_INT 2
85863: PUSH
85864: LD_INT 3
85866: PUSH
85867: LD_INT 4
85869: PUSH
85870: LD_INT 5
85872: PUSH
85873: LD_INT 8
85875: PUSH
85876: LD_INT 9
85878: PUSH
85879: LD_INT 10
85881: PUSH
85882: LD_INT 11
85884: PUSH
85885: LD_INT 12
85887: PUSH
85888: LD_INT 14
85890: PUSH
85891: LD_INT 15
85893: PUSH
85894: LD_INT 16
85896: PUSH
85897: LD_INT 17
85899: PUSH
85900: LD_INT 18
85902: PUSH
85903: LD_INT 19
85905: PUSH
85906: LD_INT 20
85908: PUSH
85909: LD_INT 21
85911: PUSH
85912: LD_INT 22
85914: PUSH
85915: LD_INT 23
85917: PUSH
85918: LD_INT 24
85920: PUSH
85921: LD_INT 25
85923: PUSH
85924: LD_INT 26
85926: PUSH
85927: LD_INT 27
85929: PUSH
85930: LD_INT 28
85932: PUSH
85933: LD_INT 30
85935: PUSH
85936: LD_INT 31
85938: PUSH
85939: LD_INT 32
85941: PUSH
85942: LD_INT 33
85944: PUSH
85945: LD_INT 34
85947: PUSH
85948: LD_INT 36
85950: PUSH
85951: EMPTY
85952: LIST
85953: LIST
85954: LIST
85955: LIST
85956: LIST
85957: LIST
85958: LIST
85959: LIST
85960: LIST
85961: LIST
85962: LIST
85963: LIST
85964: LIST
85965: LIST
85966: LIST
85967: LIST
85968: LIST
85969: LIST
85970: LIST
85971: LIST
85972: LIST
85973: LIST
85974: LIST
85975: LIST
85976: LIST
85977: LIST
85978: LIST
85979: LIST
85980: LIST
85981: LIST
85982: LIST
85983: PUSH
85984: LD_INT 101
85986: PUSH
85987: LD_INT 102
85989: PUSH
85990: LD_INT 103
85992: PUSH
85993: LD_INT 104
85995: PUSH
85996: LD_INT 105
85998: PUSH
85999: LD_INT 106
86001: PUSH
86002: LD_INT 107
86004: PUSH
86005: LD_INT 108
86007: PUSH
86008: LD_INT 109
86010: PUSH
86011: LD_INT 110
86013: PUSH
86014: LD_INT 111
86016: PUSH
86017: LD_INT 112
86019: PUSH
86020: LD_INT 113
86022: PUSH
86023: LD_INT 114
86025: PUSH
86026: EMPTY
86027: LIST
86028: LIST
86029: LIST
86030: LIST
86031: LIST
86032: LIST
86033: LIST
86034: LIST
86035: LIST
86036: LIST
86037: LIST
86038: LIST
86039: LIST
86040: LIST
86041: PUSH
86042: EMPTY
86043: LIST
86044: LIST
86045: ST_TO_ADDR
86046: GO 87213
86048: LD_INT 14
86050: DOUBLE
86051: EQUAL
86052: IFTRUE 86056
86054: GO 86268
86056: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
86057: LD_ADDR_VAR 0 1
86061: PUSH
86062: LD_INT 1
86064: PUSH
86065: LD_INT 2
86067: PUSH
86068: LD_INT 3
86070: PUSH
86071: LD_INT 4
86073: PUSH
86074: LD_INT 5
86076: PUSH
86077: LD_INT 6
86079: PUSH
86080: LD_INT 7
86082: PUSH
86083: LD_INT 8
86085: PUSH
86086: LD_INT 9
86088: PUSH
86089: LD_INT 10
86091: PUSH
86092: LD_INT 11
86094: PUSH
86095: LD_INT 12
86097: PUSH
86098: LD_INT 13
86100: PUSH
86101: LD_INT 14
86103: PUSH
86104: LD_INT 15
86106: PUSH
86107: LD_INT 16
86109: PUSH
86110: LD_INT 17
86112: PUSH
86113: LD_INT 18
86115: PUSH
86116: LD_INT 19
86118: PUSH
86119: LD_INT 20
86121: PUSH
86122: LD_INT 21
86124: PUSH
86125: LD_INT 22
86127: PUSH
86128: LD_INT 23
86130: PUSH
86131: LD_INT 24
86133: PUSH
86134: LD_INT 25
86136: PUSH
86137: LD_INT 26
86139: PUSH
86140: LD_INT 27
86142: PUSH
86143: LD_INT 28
86145: PUSH
86146: LD_INT 29
86148: PUSH
86149: LD_INT 30
86151: PUSH
86152: LD_INT 31
86154: PUSH
86155: LD_INT 32
86157: PUSH
86158: LD_INT 33
86160: PUSH
86161: LD_INT 34
86163: PUSH
86164: LD_INT 36
86166: PUSH
86167: EMPTY
86168: LIST
86169: LIST
86170: LIST
86171: LIST
86172: LIST
86173: LIST
86174: LIST
86175: LIST
86176: LIST
86177: LIST
86178: LIST
86179: LIST
86180: LIST
86181: LIST
86182: LIST
86183: LIST
86184: LIST
86185: LIST
86186: LIST
86187: LIST
86188: LIST
86189: LIST
86190: LIST
86191: LIST
86192: LIST
86193: LIST
86194: LIST
86195: LIST
86196: LIST
86197: LIST
86198: LIST
86199: LIST
86200: LIST
86201: LIST
86202: LIST
86203: PUSH
86204: LD_INT 101
86206: PUSH
86207: LD_INT 102
86209: PUSH
86210: LD_INT 103
86212: PUSH
86213: LD_INT 104
86215: PUSH
86216: LD_INT 105
86218: PUSH
86219: LD_INT 106
86221: PUSH
86222: LD_INT 107
86224: PUSH
86225: LD_INT 108
86227: PUSH
86228: LD_INT 109
86230: PUSH
86231: LD_INT 110
86233: PUSH
86234: LD_INT 111
86236: PUSH
86237: LD_INT 112
86239: PUSH
86240: LD_INT 113
86242: PUSH
86243: LD_INT 114
86245: PUSH
86246: EMPTY
86247: LIST
86248: LIST
86249: LIST
86250: LIST
86251: LIST
86252: LIST
86253: LIST
86254: LIST
86255: LIST
86256: LIST
86257: LIST
86258: LIST
86259: LIST
86260: LIST
86261: PUSH
86262: EMPTY
86263: LIST
86264: LIST
86265: ST_TO_ADDR
86266: GO 87213
86268: LD_INT 15
86270: DOUBLE
86271: EQUAL
86272: IFTRUE 86276
86274: GO 86488
86276: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
86277: LD_ADDR_VAR 0 1
86281: PUSH
86282: LD_INT 1
86284: PUSH
86285: LD_INT 2
86287: PUSH
86288: LD_INT 3
86290: PUSH
86291: LD_INT 4
86293: PUSH
86294: LD_INT 5
86296: PUSH
86297: LD_INT 6
86299: PUSH
86300: LD_INT 7
86302: PUSH
86303: LD_INT 8
86305: PUSH
86306: LD_INT 9
86308: PUSH
86309: LD_INT 10
86311: PUSH
86312: LD_INT 11
86314: PUSH
86315: LD_INT 12
86317: PUSH
86318: LD_INT 13
86320: PUSH
86321: LD_INT 14
86323: PUSH
86324: LD_INT 15
86326: PUSH
86327: LD_INT 16
86329: PUSH
86330: LD_INT 17
86332: PUSH
86333: LD_INT 18
86335: PUSH
86336: LD_INT 19
86338: PUSH
86339: LD_INT 20
86341: PUSH
86342: LD_INT 21
86344: PUSH
86345: LD_INT 22
86347: PUSH
86348: LD_INT 23
86350: PUSH
86351: LD_INT 24
86353: PUSH
86354: LD_INT 25
86356: PUSH
86357: LD_INT 26
86359: PUSH
86360: LD_INT 27
86362: PUSH
86363: LD_INT 28
86365: PUSH
86366: LD_INT 29
86368: PUSH
86369: LD_INT 30
86371: PUSH
86372: LD_INT 31
86374: PUSH
86375: LD_INT 32
86377: PUSH
86378: LD_INT 33
86380: PUSH
86381: LD_INT 34
86383: PUSH
86384: LD_INT 36
86386: PUSH
86387: EMPTY
86388: LIST
86389: LIST
86390: LIST
86391: LIST
86392: LIST
86393: LIST
86394: LIST
86395: LIST
86396: LIST
86397: LIST
86398: LIST
86399: LIST
86400: LIST
86401: LIST
86402: LIST
86403: LIST
86404: LIST
86405: LIST
86406: LIST
86407: LIST
86408: LIST
86409: LIST
86410: LIST
86411: LIST
86412: LIST
86413: LIST
86414: LIST
86415: LIST
86416: LIST
86417: LIST
86418: LIST
86419: LIST
86420: LIST
86421: LIST
86422: LIST
86423: PUSH
86424: LD_INT 101
86426: PUSH
86427: LD_INT 102
86429: PUSH
86430: LD_INT 103
86432: PUSH
86433: LD_INT 104
86435: PUSH
86436: LD_INT 105
86438: PUSH
86439: LD_INT 106
86441: PUSH
86442: LD_INT 107
86444: PUSH
86445: LD_INT 108
86447: PUSH
86448: LD_INT 109
86450: PUSH
86451: LD_INT 110
86453: PUSH
86454: LD_INT 111
86456: PUSH
86457: LD_INT 112
86459: PUSH
86460: LD_INT 113
86462: PUSH
86463: LD_INT 114
86465: PUSH
86466: EMPTY
86467: LIST
86468: LIST
86469: LIST
86470: LIST
86471: LIST
86472: LIST
86473: LIST
86474: LIST
86475: LIST
86476: LIST
86477: LIST
86478: LIST
86479: LIST
86480: LIST
86481: PUSH
86482: EMPTY
86483: LIST
86484: LIST
86485: ST_TO_ADDR
86486: GO 87213
86488: LD_INT 16
86490: DOUBLE
86491: EQUAL
86492: IFTRUE 86496
86494: GO 86620
86496: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
86497: LD_ADDR_VAR 0 1
86501: PUSH
86502: LD_INT 2
86504: PUSH
86505: LD_INT 4
86507: PUSH
86508: LD_INT 5
86510: PUSH
86511: LD_INT 7
86513: PUSH
86514: LD_INT 11
86516: PUSH
86517: LD_INT 12
86519: PUSH
86520: LD_INT 15
86522: PUSH
86523: LD_INT 16
86525: PUSH
86526: LD_INT 20
86528: PUSH
86529: LD_INT 21
86531: PUSH
86532: LD_INT 22
86534: PUSH
86535: LD_INT 23
86537: PUSH
86538: LD_INT 25
86540: PUSH
86541: LD_INT 26
86543: PUSH
86544: LD_INT 30
86546: PUSH
86547: LD_INT 31
86549: PUSH
86550: LD_INT 32
86552: PUSH
86553: LD_INT 33
86555: PUSH
86556: LD_INT 34
86558: PUSH
86559: EMPTY
86560: LIST
86561: LIST
86562: LIST
86563: LIST
86564: LIST
86565: LIST
86566: LIST
86567: LIST
86568: LIST
86569: LIST
86570: LIST
86571: LIST
86572: LIST
86573: LIST
86574: LIST
86575: LIST
86576: LIST
86577: LIST
86578: LIST
86579: PUSH
86580: LD_INT 101
86582: PUSH
86583: LD_INT 102
86585: PUSH
86586: LD_INT 103
86588: PUSH
86589: LD_INT 106
86591: PUSH
86592: LD_INT 108
86594: PUSH
86595: LD_INT 112
86597: PUSH
86598: LD_INT 113
86600: PUSH
86601: LD_INT 114
86603: PUSH
86604: EMPTY
86605: LIST
86606: LIST
86607: LIST
86608: LIST
86609: LIST
86610: LIST
86611: LIST
86612: LIST
86613: PUSH
86614: EMPTY
86615: LIST
86616: LIST
86617: ST_TO_ADDR
86618: GO 87213
86620: LD_INT 17
86622: DOUBLE
86623: EQUAL
86624: IFTRUE 86628
86626: GO 86840
86628: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
86629: LD_ADDR_VAR 0 1
86633: PUSH
86634: LD_INT 1
86636: PUSH
86637: LD_INT 2
86639: PUSH
86640: LD_INT 3
86642: PUSH
86643: LD_INT 4
86645: PUSH
86646: LD_INT 5
86648: PUSH
86649: LD_INT 6
86651: PUSH
86652: LD_INT 7
86654: PUSH
86655: LD_INT 8
86657: PUSH
86658: LD_INT 9
86660: PUSH
86661: LD_INT 10
86663: PUSH
86664: LD_INT 11
86666: PUSH
86667: LD_INT 12
86669: PUSH
86670: LD_INT 13
86672: PUSH
86673: LD_INT 14
86675: PUSH
86676: LD_INT 15
86678: PUSH
86679: LD_INT 16
86681: PUSH
86682: LD_INT 17
86684: PUSH
86685: LD_INT 18
86687: PUSH
86688: LD_INT 19
86690: PUSH
86691: LD_INT 20
86693: PUSH
86694: LD_INT 21
86696: PUSH
86697: LD_INT 22
86699: PUSH
86700: LD_INT 23
86702: PUSH
86703: LD_INT 24
86705: PUSH
86706: LD_INT 25
86708: PUSH
86709: LD_INT 26
86711: PUSH
86712: LD_INT 27
86714: PUSH
86715: LD_INT 28
86717: PUSH
86718: LD_INT 29
86720: PUSH
86721: LD_INT 30
86723: PUSH
86724: LD_INT 31
86726: PUSH
86727: LD_INT 32
86729: PUSH
86730: LD_INT 33
86732: PUSH
86733: LD_INT 34
86735: PUSH
86736: LD_INT 36
86738: PUSH
86739: EMPTY
86740: LIST
86741: LIST
86742: LIST
86743: LIST
86744: LIST
86745: LIST
86746: LIST
86747: LIST
86748: LIST
86749: LIST
86750: LIST
86751: LIST
86752: LIST
86753: LIST
86754: LIST
86755: LIST
86756: LIST
86757: LIST
86758: LIST
86759: LIST
86760: LIST
86761: LIST
86762: LIST
86763: LIST
86764: LIST
86765: LIST
86766: LIST
86767: LIST
86768: LIST
86769: LIST
86770: LIST
86771: LIST
86772: LIST
86773: LIST
86774: LIST
86775: PUSH
86776: LD_INT 101
86778: PUSH
86779: LD_INT 102
86781: PUSH
86782: LD_INT 103
86784: PUSH
86785: LD_INT 104
86787: PUSH
86788: LD_INT 105
86790: PUSH
86791: LD_INT 106
86793: PUSH
86794: LD_INT 107
86796: PUSH
86797: LD_INT 108
86799: PUSH
86800: LD_INT 109
86802: PUSH
86803: LD_INT 110
86805: PUSH
86806: LD_INT 111
86808: PUSH
86809: LD_INT 112
86811: PUSH
86812: LD_INT 113
86814: PUSH
86815: LD_INT 114
86817: PUSH
86818: EMPTY
86819: LIST
86820: LIST
86821: LIST
86822: LIST
86823: LIST
86824: LIST
86825: LIST
86826: LIST
86827: LIST
86828: LIST
86829: LIST
86830: LIST
86831: LIST
86832: LIST
86833: PUSH
86834: EMPTY
86835: LIST
86836: LIST
86837: ST_TO_ADDR
86838: GO 87213
86840: LD_INT 18
86842: DOUBLE
86843: EQUAL
86844: IFTRUE 86848
86846: GO 86984
86848: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
86849: LD_ADDR_VAR 0 1
86853: PUSH
86854: LD_INT 2
86856: PUSH
86857: LD_INT 4
86859: PUSH
86860: LD_INT 5
86862: PUSH
86863: LD_INT 7
86865: PUSH
86866: LD_INT 11
86868: PUSH
86869: LD_INT 12
86871: PUSH
86872: LD_INT 15
86874: PUSH
86875: LD_INT 16
86877: PUSH
86878: LD_INT 20
86880: PUSH
86881: LD_INT 21
86883: PUSH
86884: LD_INT 22
86886: PUSH
86887: LD_INT 23
86889: PUSH
86890: LD_INT 25
86892: PUSH
86893: LD_INT 26
86895: PUSH
86896: LD_INT 30
86898: PUSH
86899: LD_INT 31
86901: PUSH
86902: LD_INT 32
86904: PUSH
86905: LD_INT 33
86907: PUSH
86908: LD_INT 34
86910: PUSH
86911: LD_INT 35
86913: PUSH
86914: LD_INT 36
86916: PUSH
86917: EMPTY
86918: LIST
86919: LIST
86920: LIST
86921: LIST
86922: LIST
86923: LIST
86924: LIST
86925: LIST
86926: LIST
86927: LIST
86928: LIST
86929: LIST
86930: LIST
86931: LIST
86932: LIST
86933: LIST
86934: LIST
86935: LIST
86936: LIST
86937: LIST
86938: LIST
86939: PUSH
86940: LD_INT 101
86942: PUSH
86943: LD_INT 102
86945: PUSH
86946: LD_INT 103
86948: PUSH
86949: LD_INT 106
86951: PUSH
86952: LD_INT 108
86954: PUSH
86955: LD_INT 112
86957: PUSH
86958: LD_INT 113
86960: PUSH
86961: LD_INT 114
86963: PUSH
86964: LD_INT 115
86966: PUSH
86967: EMPTY
86968: LIST
86969: LIST
86970: LIST
86971: LIST
86972: LIST
86973: LIST
86974: LIST
86975: LIST
86976: LIST
86977: PUSH
86978: EMPTY
86979: LIST
86980: LIST
86981: ST_TO_ADDR
86982: GO 87213
86984: LD_INT 19
86986: DOUBLE
86987: EQUAL
86988: IFTRUE 86992
86990: GO 87212
86992: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
86993: LD_ADDR_VAR 0 1
86997: PUSH
86998: LD_INT 1
87000: PUSH
87001: LD_INT 2
87003: PUSH
87004: LD_INT 3
87006: PUSH
87007: LD_INT 4
87009: PUSH
87010: LD_INT 5
87012: PUSH
87013: LD_INT 6
87015: PUSH
87016: LD_INT 7
87018: PUSH
87019: LD_INT 8
87021: PUSH
87022: LD_INT 9
87024: PUSH
87025: LD_INT 10
87027: PUSH
87028: LD_INT 11
87030: PUSH
87031: LD_INT 12
87033: PUSH
87034: LD_INT 13
87036: PUSH
87037: LD_INT 14
87039: PUSH
87040: LD_INT 15
87042: PUSH
87043: LD_INT 16
87045: PUSH
87046: LD_INT 17
87048: PUSH
87049: LD_INT 18
87051: PUSH
87052: LD_INT 19
87054: PUSH
87055: LD_INT 20
87057: PUSH
87058: LD_INT 21
87060: PUSH
87061: LD_INT 22
87063: PUSH
87064: LD_INT 23
87066: PUSH
87067: LD_INT 24
87069: PUSH
87070: LD_INT 25
87072: PUSH
87073: LD_INT 26
87075: PUSH
87076: LD_INT 27
87078: PUSH
87079: LD_INT 28
87081: PUSH
87082: LD_INT 29
87084: PUSH
87085: LD_INT 30
87087: PUSH
87088: LD_INT 31
87090: PUSH
87091: LD_INT 32
87093: PUSH
87094: LD_INT 33
87096: PUSH
87097: LD_INT 34
87099: PUSH
87100: LD_INT 35
87102: PUSH
87103: LD_INT 36
87105: PUSH
87106: EMPTY
87107: LIST
87108: LIST
87109: LIST
87110: LIST
87111: LIST
87112: LIST
87113: LIST
87114: LIST
87115: LIST
87116: LIST
87117: LIST
87118: LIST
87119: LIST
87120: LIST
87121: LIST
87122: LIST
87123: LIST
87124: LIST
87125: LIST
87126: LIST
87127: LIST
87128: LIST
87129: LIST
87130: LIST
87131: LIST
87132: LIST
87133: LIST
87134: LIST
87135: LIST
87136: LIST
87137: LIST
87138: LIST
87139: LIST
87140: LIST
87141: LIST
87142: LIST
87143: PUSH
87144: LD_INT 101
87146: PUSH
87147: LD_INT 102
87149: PUSH
87150: LD_INT 103
87152: PUSH
87153: LD_INT 104
87155: PUSH
87156: LD_INT 105
87158: PUSH
87159: LD_INT 106
87161: PUSH
87162: LD_INT 107
87164: PUSH
87165: LD_INT 108
87167: PUSH
87168: LD_INT 109
87170: PUSH
87171: LD_INT 110
87173: PUSH
87174: LD_INT 111
87176: PUSH
87177: LD_INT 112
87179: PUSH
87180: LD_INT 113
87182: PUSH
87183: LD_INT 114
87185: PUSH
87186: LD_INT 115
87188: PUSH
87189: EMPTY
87190: LIST
87191: LIST
87192: LIST
87193: LIST
87194: LIST
87195: LIST
87196: LIST
87197: LIST
87198: LIST
87199: LIST
87200: LIST
87201: LIST
87202: LIST
87203: LIST
87204: LIST
87205: PUSH
87206: EMPTY
87207: LIST
87208: LIST
87209: ST_TO_ADDR
87210: GO 87213
87212: POP
// end else
87213: GO 87432
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
87215: LD_ADDR_VAR 0 1
87219: PUSH
87220: LD_INT 1
87222: PUSH
87223: LD_INT 2
87225: PUSH
87226: LD_INT 3
87228: PUSH
87229: LD_INT 4
87231: PUSH
87232: LD_INT 5
87234: PUSH
87235: LD_INT 6
87237: PUSH
87238: LD_INT 7
87240: PUSH
87241: LD_INT 8
87243: PUSH
87244: LD_INT 9
87246: PUSH
87247: LD_INT 10
87249: PUSH
87250: LD_INT 11
87252: PUSH
87253: LD_INT 12
87255: PUSH
87256: LD_INT 13
87258: PUSH
87259: LD_INT 14
87261: PUSH
87262: LD_INT 15
87264: PUSH
87265: LD_INT 16
87267: PUSH
87268: LD_INT 17
87270: PUSH
87271: LD_INT 18
87273: PUSH
87274: LD_INT 19
87276: PUSH
87277: LD_INT 20
87279: PUSH
87280: LD_INT 21
87282: PUSH
87283: LD_INT 22
87285: PUSH
87286: LD_INT 23
87288: PUSH
87289: LD_INT 24
87291: PUSH
87292: LD_INT 25
87294: PUSH
87295: LD_INT 26
87297: PUSH
87298: LD_INT 27
87300: PUSH
87301: LD_INT 28
87303: PUSH
87304: LD_INT 29
87306: PUSH
87307: LD_INT 30
87309: PUSH
87310: LD_INT 31
87312: PUSH
87313: LD_INT 32
87315: PUSH
87316: LD_INT 33
87318: PUSH
87319: LD_INT 34
87321: PUSH
87322: LD_INT 35
87324: PUSH
87325: LD_INT 36
87327: PUSH
87328: EMPTY
87329: LIST
87330: LIST
87331: LIST
87332: LIST
87333: LIST
87334: LIST
87335: LIST
87336: LIST
87337: LIST
87338: LIST
87339: LIST
87340: LIST
87341: LIST
87342: LIST
87343: LIST
87344: LIST
87345: LIST
87346: LIST
87347: LIST
87348: LIST
87349: LIST
87350: LIST
87351: LIST
87352: LIST
87353: LIST
87354: LIST
87355: LIST
87356: LIST
87357: LIST
87358: LIST
87359: LIST
87360: LIST
87361: LIST
87362: LIST
87363: LIST
87364: LIST
87365: PUSH
87366: LD_INT 101
87368: PUSH
87369: LD_INT 102
87371: PUSH
87372: LD_INT 103
87374: PUSH
87375: LD_INT 104
87377: PUSH
87378: LD_INT 105
87380: PUSH
87381: LD_INT 106
87383: PUSH
87384: LD_INT 107
87386: PUSH
87387: LD_INT 108
87389: PUSH
87390: LD_INT 109
87392: PUSH
87393: LD_INT 110
87395: PUSH
87396: LD_INT 111
87398: PUSH
87399: LD_INT 112
87401: PUSH
87402: LD_INT 113
87404: PUSH
87405: LD_INT 114
87407: PUSH
87408: LD_INT 115
87410: PUSH
87411: EMPTY
87412: LIST
87413: LIST
87414: LIST
87415: LIST
87416: LIST
87417: LIST
87418: LIST
87419: LIST
87420: LIST
87421: LIST
87422: LIST
87423: LIST
87424: LIST
87425: LIST
87426: LIST
87427: PUSH
87428: EMPTY
87429: LIST
87430: LIST
87431: ST_TO_ADDR
// if result then
87432: LD_VAR 0 1
87436: IFFALSE 87725
// begin normal :=  ;
87438: LD_ADDR_VAR 0 3
87442: PUSH
87443: LD_STRING 
87445: ST_TO_ADDR
// hardcore :=  ;
87446: LD_ADDR_VAR 0 4
87450: PUSH
87451: LD_STRING 
87453: ST_TO_ADDR
// for i = 1 to normalCounter do
87454: LD_ADDR_VAR 0 5
87458: PUSH
87459: DOUBLE
87460: LD_INT 1
87462: DEC
87463: ST_TO_ADDR
87464: LD_EXP 84
87468: PUSH
87469: FOR_TO
87470: IFFALSE 87571
// begin tmp := 0 ;
87472: LD_ADDR_VAR 0 2
87476: PUSH
87477: LD_STRING 0
87479: ST_TO_ADDR
// if result [ 1 ] then
87480: LD_VAR 0 1
87484: PUSH
87485: LD_INT 1
87487: ARRAY
87488: IFFALSE 87553
// if result [ 1 ] [ 1 ] = i then
87490: LD_VAR 0 1
87494: PUSH
87495: LD_INT 1
87497: ARRAY
87498: PUSH
87499: LD_INT 1
87501: ARRAY
87502: PUSH
87503: LD_VAR 0 5
87507: EQUAL
87508: IFFALSE 87553
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
87510: LD_ADDR_VAR 0 1
87514: PUSH
87515: LD_VAR 0 1
87519: PPUSH
87520: LD_INT 1
87522: PPUSH
87523: LD_VAR 0 1
87527: PUSH
87528: LD_INT 1
87530: ARRAY
87531: PPUSH
87532: LD_INT 1
87534: PPUSH
87535: CALL_OW 3
87539: PPUSH
87540: CALL_OW 1
87544: ST_TO_ADDR
// tmp := 1 ;
87545: LD_ADDR_VAR 0 2
87549: PUSH
87550: LD_STRING 1
87552: ST_TO_ADDR
// end ; normal := normal & tmp ;
87553: LD_ADDR_VAR 0 3
87557: PUSH
87558: LD_VAR 0 3
87562: PUSH
87563: LD_VAR 0 2
87567: STR
87568: ST_TO_ADDR
// end ;
87569: GO 87469
87571: POP
87572: POP
// for i = 1 to hardcoreCounter do
87573: LD_ADDR_VAR 0 5
87577: PUSH
87578: DOUBLE
87579: LD_INT 1
87581: DEC
87582: ST_TO_ADDR
87583: LD_EXP 85
87587: PUSH
87588: FOR_TO
87589: IFFALSE 87694
// begin tmp := 0 ;
87591: LD_ADDR_VAR 0 2
87595: PUSH
87596: LD_STRING 0
87598: ST_TO_ADDR
// if result [ 2 ] then
87599: LD_VAR 0 1
87603: PUSH
87604: LD_INT 2
87606: ARRAY
87607: IFFALSE 87676
// if result [ 2 ] [ 1 ] = 100 + i then
87609: LD_VAR 0 1
87613: PUSH
87614: LD_INT 2
87616: ARRAY
87617: PUSH
87618: LD_INT 1
87620: ARRAY
87621: PUSH
87622: LD_INT 100
87624: PUSH
87625: LD_VAR 0 5
87629: PLUS
87630: EQUAL
87631: IFFALSE 87676
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
87633: LD_ADDR_VAR 0 1
87637: PUSH
87638: LD_VAR 0 1
87642: PPUSH
87643: LD_INT 2
87645: PPUSH
87646: LD_VAR 0 1
87650: PUSH
87651: LD_INT 2
87653: ARRAY
87654: PPUSH
87655: LD_INT 1
87657: PPUSH
87658: CALL_OW 3
87662: PPUSH
87663: CALL_OW 1
87667: ST_TO_ADDR
// tmp := 1 ;
87668: LD_ADDR_VAR 0 2
87672: PUSH
87673: LD_STRING 1
87675: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
87676: LD_ADDR_VAR 0 4
87680: PUSH
87681: LD_VAR 0 4
87685: PUSH
87686: LD_VAR 0 2
87690: STR
87691: ST_TO_ADDR
// end ;
87692: GO 87588
87694: POP
87695: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
87696: LD_STRING getStreamItemsFromMission("
87698: PUSH
87699: LD_VAR 0 3
87703: STR
87704: PUSH
87705: LD_STRING ","
87707: STR
87708: PUSH
87709: LD_VAR 0 4
87713: STR
87714: PUSH
87715: LD_STRING ")
87717: STR
87718: PPUSH
87719: CALL_OW 559
// end else
87723: GO 87732
// ToLua ( getStreamItemsFromMission("","") ) ;
87725: LD_STRING getStreamItemsFromMission("","")
87727: PPUSH
87728: CALL_OW 559
// end ;
87732: LD_VAR 0 1
87736: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
87737: LD_EXP 83
87741: PUSH
87742: LD_EXP 88
87746: AND
87747: IFFALSE 87871
87749: GO 87751
87751: DISABLE
87752: LD_INT 0
87754: PPUSH
87755: PPUSH
// begin enable ;
87756: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
87757: LD_ADDR_VAR 0 2
87761: PUSH
87762: LD_INT 22
87764: PUSH
87765: LD_OWVAR 2
87769: PUSH
87770: EMPTY
87771: LIST
87772: LIST
87773: PUSH
87774: LD_INT 2
87776: PUSH
87777: LD_INT 34
87779: PUSH
87780: LD_INT 7
87782: PUSH
87783: EMPTY
87784: LIST
87785: LIST
87786: PUSH
87787: LD_INT 34
87789: PUSH
87790: LD_INT 45
87792: PUSH
87793: EMPTY
87794: LIST
87795: LIST
87796: PUSH
87797: LD_INT 34
87799: PUSH
87800: LD_INT 28
87802: PUSH
87803: EMPTY
87804: LIST
87805: LIST
87806: PUSH
87807: LD_INT 34
87809: PUSH
87810: LD_INT 47
87812: PUSH
87813: EMPTY
87814: LIST
87815: LIST
87816: PUSH
87817: EMPTY
87818: LIST
87819: LIST
87820: LIST
87821: LIST
87822: LIST
87823: PUSH
87824: EMPTY
87825: LIST
87826: LIST
87827: PPUSH
87828: CALL_OW 69
87832: ST_TO_ADDR
// if not tmp then
87833: LD_VAR 0 2
87837: NOT
87838: IFFALSE 87842
// exit ;
87840: GO 87871
// for i in tmp do
87842: LD_ADDR_VAR 0 1
87846: PUSH
87847: LD_VAR 0 2
87851: PUSH
87852: FOR_IN
87853: IFFALSE 87869
// begin SetLives ( i , 0 ) ;
87855: LD_VAR 0 1
87859: PPUSH
87860: LD_INT 0
87862: PPUSH
87863: CALL_OW 234
// end ;
87867: GO 87852
87869: POP
87870: POP
// end ;
87871: PPOPN 2
87873: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
87874: LD_EXP 83
87878: PUSH
87879: LD_EXP 89
87883: AND
87884: IFFALSE 87968
87886: GO 87888
87888: DISABLE
87889: LD_INT 0
87891: PPUSH
87892: PPUSH
// begin enable ;
87893: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
87894: LD_ADDR_VAR 0 2
87898: PUSH
87899: LD_INT 22
87901: PUSH
87902: LD_OWVAR 2
87906: PUSH
87907: EMPTY
87908: LIST
87909: LIST
87910: PUSH
87911: LD_INT 32
87913: PUSH
87914: LD_INT 3
87916: PUSH
87917: EMPTY
87918: LIST
87919: LIST
87920: PUSH
87921: EMPTY
87922: LIST
87923: LIST
87924: PPUSH
87925: CALL_OW 69
87929: ST_TO_ADDR
// if not tmp then
87930: LD_VAR 0 2
87934: NOT
87935: IFFALSE 87939
// exit ;
87937: GO 87968
// for i in tmp do
87939: LD_ADDR_VAR 0 1
87943: PUSH
87944: LD_VAR 0 2
87948: PUSH
87949: FOR_IN
87950: IFFALSE 87966
// begin SetLives ( i , 0 ) ;
87952: LD_VAR 0 1
87956: PPUSH
87957: LD_INT 0
87959: PPUSH
87960: CALL_OW 234
// end ;
87964: GO 87949
87966: POP
87967: POP
// end ;
87968: PPOPN 2
87970: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
87971: LD_EXP 83
87975: PUSH
87976: LD_EXP 86
87980: AND
87981: IFFALSE 88074
87983: GO 87985
87985: DISABLE
87986: LD_INT 0
87988: PPUSH
// begin enable ;
87989: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
87990: LD_ADDR_VAR 0 1
87994: PUSH
87995: LD_INT 22
87997: PUSH
87998: LD_OWVAR 2
88002: PUSH
88003: EMPTY
88004: LIST
88005: LIST
88006: PUSH
88007: LD_INT 2
88009: PUSH
88010: LD_INT 25
88012: PUSH
88013: LD_INT 5
88015: PUSH
88016: EMPTY
88017: LIST
88018: LIST
88019: PUSH
88020: LD_INT 25
88022: PUSH
88023: LD_INT 9
88025: PUSH
88026: EMPTY
88027: LIST
88028: LIST
88029: PUSH
88030: LD_INT 25
88032: PUSH
88033: LD_INT 8
88035: PUSH
88036: EMPTY
88037: LIST
88038: LIST
88039: PUSH
88040: EMPTY
88041: LIST
88042: LIST
88043: LIST
88044: LIST
88045: PUSH
88046: EMPTY
88047: LIST
88048: LIST
88049: PPUSH
88050: CALL_OW 69
88054: PUSH
88055: FOR_IN
88056: IFFALSE 88072
// begin SetClass ( i , 1 ) ;
88058: LD_VAR 0 1
88062: PPUSH
88063: LD_INT 1
88065: PPUSH
88066: CALL_OW 336
// end ;
88070: GO 88055
88072: POP
88073: POP
// end ;
88074: PPOPN 1
88076: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
88077: LD_EXP 83
88081: PUSH
88082: LD_EXP 87
88086: AND
88087: PUSH
88088: LD_OWVAR 65
88092: PUSH
88093: LD_INT 7
88095: LESS
88096: AND
88097: IFFALSE 88111
88099: GO 88101
88101: DISABLE
// begin enable ;
88102: ENABLE
// game_speed := 7 ;
88103: LD_ADDR_OWVAR 65
88107: PUSH
88108: LD_INT 7
88110: ST_TO_ADDR
// end ;
88111: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
88112: LD_EXP 83
88116: PUSH
88117: LD_EXP 90
88121: AND
88122: IFFALSE 88324
88124: GO 88126
88126: DISABLE
88127: LD_INT 0
88129: PPUSH
88130: PPUSH
88131: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
88132: LD_ADDR_VAR 0 3
88136: PUSH
88137: LD_INT 81
88139: PUSH
88140: LD_OWVAR 2
88144: PUSH
88145: EMPTY
88146: LIST
88147: LIST
88148: PUSH
88149: LD_INT 21
88151: PUSH
88152: LD_INT 1
88154: PUSH
88155: EMPTY
88156: LIST
88157: LIST
88158: PUSH
88159: EMPTY
88160: LIST
88161: LIST
88162: PPUSH
88163: CALL_OW 69
88167: ST_TO_ADDR
// if not tmp then
88168: LD_VAR 0 3
88172: NOT
88173: IFFALSE 88177
// exit ;
88175: GO 88324
// if tmp > 5 then
88177: LD_VAR 0 3
88181: PUSH
88182: LD_INT 5
88184: GREATER
88185: IFFALSE 88197
// k := 5 else
88187: LD_ADDR_VAR 0 2
88191: PUSH
88192: LD_INT 5
88194: ST_TO_ADDR
88195: GO 88207
// k := tmp ;
88197: LD_ADDR_VAR 0 2
88201: PUSH
88202: LD_VAR 0 3
88206: ST_TO_ADDR
// for i := 1 to k do
88207: LD_ADDR_VAR 0 1
88211: PUSH
88212: DOUBLE
88213: LD_INT 1
88215: DEC
88216: ST_TO_ADDR
88217: LD_VAR 0 2
88221: PUSH
88222: FOR_TO
88223: IFFALSE 88322
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
88225: LD_VAR 0 3
88229: PUSH
88230: LD_VAR 0 1
88234: ARRAY
88235: PPUSH
88236: LD_VAR 0 1
88240: PUSH
88241: LD_INT 4
88243: MOD
88244: PUSH
88245: LD_INT 1
88247: PLUS
88248: PPUSH
88249: CALL_OW 259
88253: PUSH
88254: LD_INT 10
88256: LESS
88257: IFFALSE 88320
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
88259: LD_VAR 0 3
88263: PUSH
88264: LD_VAR 0 1
88268: ARRAY
88269: PPUSH
88270: LD_VAR 0 1
88274: PUSH
88275: LD_INT 4
88277: MOD
88278: PUSH
88279: LD_INT 1
88281: PLUS
88282: PPUSH
88283: LD_VAR 0 3
88287: PUSH
88288: LD_VAR 0 1
88292: ARRAY
88293: PPUSH
88294: LD_VAR 0 1
88298: PUSH
88299: LD_INT 4
88301: MOD
88302: PUSH
88303: LD_INT 1
88305: PLUS
88306: PPUSH
88307: CALL_OW 259
88311: PUSH
88312: LD_INT 1
88314: PLUS
88315: PPUSH
88316: CALL_OW 237
88320: GO 88222
88322: POP
88323: POP
// end ;
88324: PPOPN 3
88326: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
88327: LD_EXP 83
88331: PUSH
88332: LD_EXP 91
88336: AND
88337: IFFALSE 88357
88339: GO 88341
88341: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
88342: LD_INT 4
88344: PPUSH
88345: LD_OWVAR 2
88349: PPUSH
88350: LD_INT 0
88352: PPUSH
88353: CALL_OW 324
88357: END
// every 0 0$1 trigger StreamModeActive and sShovel do
88358: LD_EXP 83
88362: PUSH
88363: LD_EXP 120
88367: AND
88368: IFFALSE 88388
88370: GO 88372
88372: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
88373: LD_INT 19
88375: PPUSH
88376: LD_OWVAR 2
88380: PPUSH
88381: LD_INT 0
88383: PPUSH
88384: CALL_OW 324
88388: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
88389: LD_EXP 83
88393: PUSH
88394: LD_EXP 92
88398: AND
88399: IFFALSE 88501
88401: GO 88403
88403: DISABLE
88404: LD_INT 0
88406: PPUSH
88407: PPUSH
// begin enable ;
88408: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
88409: LD_ADDR_VAR 0 2
88413: PUSH
88414: LD_INT 22
88416: PUSH
88417: LD_OWVAR 2
88421: PUSH
88422: EMPTY
88423: LIST
88424: LIST
88425: PUSH
88426: LD_INT 2
88428: PUSH
88429: LD_INT 34
88431: PUSH
88432: LD_INT 11
88434: PUSH
88435: EMPTY
88436: LIST
88437: LIST
88438: PUSH
88439: LD_INT 34
88441: PUSH
88442: LD_INT 30
88444: PUSH
88445: EMPTY
88446: LIST
88447: LIST
88448: PUSH
88449: EMPTY
88450: LIST
88451: LIST
88452: LIST
88453: PUSH
88454: EMPTY
88455: LIST
88456: LIST
88457: PPUSH
88458: CALL_OW 69
88462: ST_TO_ADDR
// if not tmp then
88463: LD_VAR 0 2
88467: NOT
88468: IFFALSE 88472
// exit ;
88470: GO 88501
// for i in tmp do
88472: LD_ADDR_VAR 0 1
88476: PUSH
88477: LD_VAR 0 2
88481: PUSH
88482: FOR_IN
88483: IFFALSE 88499
// begin SetLives ( i , 0 ) ;
88485: LD_VAR 0 1
88489: PPUSH
88490: LD_INT 0
88492: PPUSH
88493: CALL_OW 234
// end ;
88497: GO 88482
88499: POP
88500: POP
// end ;
88501: PPOPN 2
88503: END
// every 0 0$1 trigger StreamModeActive and sBunker do
88504: LD_EXP 83
88508: PUSH
88509: LD_EXP 93
88513: AND
88514: IFFALSE 88534
88516: GO 88518
88518: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
88519: LD_INT 32
88521: PPUSH
88522: LD_OWVAR 2
88526: PPUSH
88527: LD_INT 0
88529: PPUSH
88530: CALL_OW 324
88534: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
88535: LD_EXP 83
88539: PUSH
88540: LD_EXP 94
88544: AND
88545: IFFALSE 88726
88547: GO 88549
88549: DISABLE
88550: LD_INT 0
88552: PPUSH
88553: PPUSH
88554: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
88555: LD_ADDR_VAR 0 2
88559: PUSH
88560: LD_INT 22
88562: PUSH
88563: LD_OWVAR 2
88567: PUSH
88568: EMPTY
88569: LIST
88570: LIST
88571: PUSH
88572: LD_INT 33
88574: PUSH
88575: LD_INT 3
88577: PUSH
88578: EMPTY
88579: LIST
88580: LIST
88581: PUSH
88582: EMPTY
88583: LIST
88584: LIST
88585: PPUSH
88586: CALL_OW 69
88590: ST_TO_ADDR
// if not tmp then
88591: LD_VAR 0 2
88595: NOT
88596: IFFALSE 88600
// exit ;
88598: GO 88726
// side := 0 ;
88600: LD_ADDR_VAR 0 3
88604: PUSH
88605: LD_INT 0
88607: ST_TO_ADDR
// for i := 1 to 8 do
88608: LD_ADDR_VAR 0 1
88612: PUSH
88613: DOUBLE
88614: LD_INT 1
88616: DEC
88617: ST_TO_ADDR
88618: LD_INT 8
88620: PUSH
88621: FOR_TO
88622: IFFALSE 88670
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
88624: LD_OWVAR 2
88628: PUSH
88629: LD_VAR 0 1
88633: NONEQUAL
88634: PUSH
88635: LD_OWVAR 2
88639: PPUSH
88640: LD_VAR 0 1
88644: PPUSH
88645: CALL_OW 81
88649: PUSH
88650: LD_INT 2
88652: EQUAL
88653: AND
88654: IFFALSE 88668
// begin side := i ;
88656: LD_ADDR_VAR 0 3
88660: PUSH
88661: LD_VAR 0 1
88665: ST_TO_ADDR
// break ;
88666: GO 88670
// end ;
88668: GO 88621
88670: POP
88671: POP
// if not side then
88672: LD_VAR 0 3
88676: NOT
88677: IFFALSE 88681
// exit ;
88679: GO 88726
// for i := 1 to tmp do
88681: LD_ADDR_VAR 0 1
88685: PUSH
88686: DOUBLE
88687: LD_INT 1
88689: DEC
88690: ST_TO_ADDR
88691: LD_VAR 0 2
88695: PUSH
88696: FOR_TO
88697: IFFALSE 88724
// if Prob ( 60 ) then
88699: LD_INT 60
88701: PPUSH
88702: CALL_OW 13
88706: IFFALSE 88722
// SetSide ( i , side ) ;
88708: LD_VAR 0 1
88712: PPUSH
88713: LD_VAR 0 3
88717: PPUSH
88718: CALL_OW 235
88722: GO 88696
88724: POP
88725: POP
// end ;
88726: PPOPN 3
88728: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
88729: LD_EXP 83
88733: PUSH
88734: LD_EXP 96
88738: AND
88739: IFFALSE 88858
88741: GO 88743
88743: DISABLE
88744: LD_INT 0
88746: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
88747: LD_ADDR_VAR 0 1
88751: PUSH
88752: LD_INT 22
88754: PUSH
88755: LD_OWVAR 2
88759: PUSH
88760: EMPTY
88761: LIST
88762: LIST
88763: PUSH
88764: LD_INT 21
88766: PUSH
88767: LD_INT 1
88769: PUSH
88770: EMPTY
88771: LIST
88772: LIST
88773: PUSH
88774: LD_INT 3
88776: PUSH
88777: LD_INT 23
88779: PUSH
88780: LD_INT 0
88782: PUSH
88783: EMPTY
88784: LIST
88785: LIST
88786: PUSH
88787: EMPTY
88788: LIST
88789: LIST
88790: PUSH
88791: EMPTY
88792: LIST
88793: LIST
88794: LIST
88795: PPUSH
88796: CALL_OW 69
88800: PUSH
88801: FOR_IN
88802: IFFALSE 88856
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
88804: LD_VAR 0 1
88808: PPUSH
88809: CALL_OW 257
88813: PUSH
88814: LD_INT 1
88816: PUSH
88817: LD_INT 2
88819: PUSH
88820: LD_INT 3
88822: PUSH
88823: LD_INT 4
88825: PUSH
88826: EMPTY
88827: LIST
88828: LIST
88829: LIST
88830: LIST
88831: IN
88832: IFFALSE 88854
// SetClass ( un , rand ( 1 , 4 ) ) ;
88834: LD_VAR 0 1
88838: PPUSH
88839: LD_INT 1
88841: PPUSH
88842: LD_INT 4
88844: PPUSH
88845: CALL_OW 12
88849: PPUSH
88850: CALL_OW 336
88854: GO 88801
88856: POP
88857: POP
// end ;
88858: PPOPN 1
88860: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
88861: LD_EXP 83
88865: PUSH
88866: LD_EXP 95
88870: AND
88871: IFFALSE 88950
88873: GO 88875
88875: DISABLE
88876: LD_INT 0
88878: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
88879: LD_ADDR_VAR 0 1
88883: PUSH
88884: LD_INT 22
88886: PUSH
88887: LD_OWVAR 2
88891: PUSH
88892: EMPTY
88893: LIST
88894: LIST
88895: PUSH
88896: LD_INT 21
88898: PUSH
88899: LD_INT 3
88901: PUSH
88902: EMPTY
88903: LIST
88904: LIST
88905: PUSH
88906: EMPTY
88907: LIST
88908: LIST
88909: PPUSH
88910: CALL_OW 69
88914: ST_TO_ADDR
// if not tmp then
88915: LD_VAR 0 1
88919: NOT
88920: IFFALSE 88924
// exit ;
88922: GO 88950
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
88924: LD_VAR 0 1
88928: PUSH
88929: LD_INT 1
88931: PPUSH
88932: LD_VAR 0 1
88936: PPUSH
88937: CALL_OW 12
88941: ARRAY
88942: PPUSH
88943: LD_INT 100
88945: PPUSH
88946: CALL_OW 234
// end ;
88950: PPOPN 1
88952: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
88953: LD_EXP 83
88957: PUSH
88958: LD_EXP 97
88962: AND
88963: IFFALSE 89061
88965: GO 88967
88967: DISABLE
88968: LD_INT 0
88970: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
88971: LD_ADDR_VAR 0 1
88975: PUSH
88976: LD_INT 22
88978: PUSH
88979: LD_OWVAR 2
88983: PUSH
88984: EMPTY
88985: LIST
88986: LIST
88987: PUSH
88988: LD_INT 21
88990: PUSH
88991: LD_INT 1
88993: PUSH
88994: EMPTY
88995: LIST
88996: LIST
88997: PUSH
88998: EMPTY
88999: LIST
89000: LIST
89001: PPUSH
89002: CALL_OW 69
89006: ST_TO_ADDR
// if not tmp then
89007: LD_VAR 0 1
89011: NOT
89012: IFFALSE 89016
// exit ;
89014: GO 89061
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
89016: LD_VAR 0 1
89020: PUSH
89021: LD_INT 1
89023: PPUSH
89024: LD_VAR 0 1
89028: PPUSH
89029: CALL_OW 12
89033: ARRAY
89034: PPUSH
89035: LD_INT 1
89037: PPUSH
89038: LD_INT 4
89040: PPUSH
89041: CALL_OW 12
89045: PPUSH
89046: LD_INT 3000
89048: PPUSH
89049: LD_INT 9000
89051: PPUSH
89052: CALL_OW 12
89056: PPUSH
89057: CALL_OW 492
// end ;
89061: PPOPN 1
89063: END
// every 0 0$1 trigger StreamModeActive and sDepot do
89064: LD_EXP 83
89068: PUSH
89069: LD_EXP 98
89073: AND
89074: IFFALSE 89094
89076: GO 89078
89078: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
89079: LD_INT 1
89081: PPUSH
89082: LD_OWVAR 2
89086: PPUSH
89087: LD_INT 0
89089: PPUSH
89090: CALL_OW 324
89094: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
89095: LD_EXP 83
89099: PUSH
89100: LD_EXP 99
89104: AND
89105: IFFALSE 89188
89107: GO 89109
89109: DISABLE
89110: LD_INT 0
89112: PPUSH
89113: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
89114: LD_ADDR_VAR 0 2
89118: PUSH
89119: LD_INT 22
89121: PUSH
89122: LD_OWVAR 2
89126: PUSH
89127: EMPTY
89128: LIST
89129: LIST
89130: PUSH
89131: LD_INT 21
89133: PUSH
89134: LD_INT 3
89136: PUSH
89137: EMPTY
89138: LIST
89139: LIST
89140: PUSH
89141: EMPTY
89142: LIST
89143: LIST
89144: PPUSH
89145: CALL_OW 69
89149: ST_TO_ADDR
// if not tmp then
89150: LD_VAR 0 2
89154: NOT
89155: IFFALSE 89159
// exit ;
89157: GO 89188
// for i in tmp do
89159: LD_ADDR_VAR 0 1
89163: PUSH
89164: LD_VAR 0 2
89168: PUSH
89169: FOR_IN
89170: IFFALSE 89186
// SetBLevel ( i , 10 ) ;
89172: LD_VAR 0 1
89176: PPUSH
89177: LD_INT 10
89179: PPUSH
89180: CALL_OW 241
89184: GO 89169
89186: POP
89187: POP
// end ;
89188: PPOPN 2
89190: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
89191: LD_EXP 83
89195: PUSH
89196: LD_EXP 100
89200: AND
89201: IFFALSE 89312
89203: GO 89205
89205: DISABLE
89206: LD_INT 0
89208: PPUSH
89209: PPUSH
89210: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
89211: LD_ADDR_VAR 0 3
89215: PUSH
89216: LD_INT 22
89218: PUSH
89219: LD_OWVAR 2
89223: PUSH
89224: EMPTY
89225: LIST
89226: LIST
89227: PUSH
89228: LD_INT 25
89230: PUSH
89231: LD_INT 1
89233: PUSH
89234: EMPTY
89235: LIST
89236: LIST
89237: PUSH
89238: EMPTY
89239: LIST
89240: LIST
89241: PPUSH
89242: CALL_OW 69
89246: ST_TO_ADDR
// if not tmp then
89247: LD_VAR 0 3
89251: NOT
89252: IFFALSE 89256
// exit ;
89254: GO 89312
// un := tmp [ rand ( 1 , tmp ) ] ;
89256: LD_ADDR_VAR 0 2
89260: PUSH
89261: LD_VAR 0 3
89265: PUSH
89266: LD_INT 1
89268: PPUSH
89269: LD_VAR 0 3
89273: PPUSH
89274: CALL_OW 12
89278: ARRAY
89279: ST_TO_ADDR
// if Crawls ( un ) then
89280: LD_VAR 0 2
89284: PPUSH
89285: CALL_OW 318
89289: IFFALSE 89300
// ComWalk ( un ) ;
89291: LD_VAR 0 2
89295: PPUSH
89296: CALL_OW 138
// SetClass ( un , class_sniper ) ;
89300: LD_VAR 0 2
89304: PPUSH
89305: LD_INT 5
89307: PPUSH
89308: CALL_OW 336
// end ;
89312: PPOPN 3
89314: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
89315: LD_EXP 83
89319: PUSH
89320: LD_EXP 101
89324: AND
89325: PUSH
89326: LD_OWVAR 67
89330: PUSH
89331: LD_INT 3
89333: LESS
89334: AND
89335: IFFALSE 89354
89337: GO 89339
89339: DISABLE
// Difficulty := Difficulty + 1 ;
89340: LD_ADDR_OWVAR 67
89344: PUSH
89345: LD_OWVAR 67
89349: PUSH
89350: LD_INT 1
89352: PLUS
89353: ST_TO_ADDR
89354: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
89355: LD_EXP 83
89359: PUSH
89360: LD_EXP 102
89364: AND
89365: IFFALSE 89468
89367: GO 89369
89369: DISABLE
89370: LD_INT 0
89372: PPUSH
// begin for i := 1 to 5 do
89373: LD_ADDR_VAR 0 1
89377: PUSH
89378: DOUBLE
89379: LD_INT 1
89381: DEC
89382: ST_TO_ADDR
89383: LD_INT 5
89385: PUSH
89386: FOR_TO
89387: IFFALSE 89466
// begin uc_nation := nation_nature ;
89389: LD_ADDR_OWVAR 21
89393: PUSH
89394: LD_INT 0
89396: ST_TO_ADDR
// uc_side := 0 ;
89397: LD_ADDR_OWVAR 20
89401: PUSH
89402: LD_INT 0
89404: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
89405: LD_ADDR_OWVAR 29
89409: PUSH
89410: LD_INT 12
89412: PUSH
89413: LD_INT 12
89415: PUSH
89416: EMPTY
89417: LIST
89418: LIST
89419: ST_TO_ADDR
// hc_agressivity := 20 ;
89420: LD_ADDR_OWVAR 35
89424: PUSH
89425: LD_INT 20
89427: ST_TO_ADDR
// hc_class := class_tiger ;
89428: LD_ADDR_OWVAR 28
89432: PUSH
89433: LD_INT 14
89435: ST_TO_ADDR
// hc_gallery :=  ;
89436: LD_ADDR_OWVAR 33
89440: PUSH
89441: LD_STRING 
89443: ST_TO_ADDR
// hc_name :=  ;
89444: LD_ADDR_OWVAR 26
89448: PUSH
89449: LD_STRING 
89451: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
89452: CALL_OW 44
89456: PPUSH
89457: LD_INT 0
89459: PPUSH
89460: CALL_OW 51
// end ;
89464: GO 89386
89466: POP
89467: POP
// end ;
89468: PPOPN 1
89470: END
// every 0 0$1 trigger StreamModeActive and sBomb do
89471: LD_EXP 83
89475: PUSH
89476: LD_EXP 103
89480: AND
89481: IFFALSE 89490
89483: GO 89485
89485: DISABLE
// StreamSibBomb ;
89486: CALL 89491 0 0
89490: END
// export function StreamSibBomb ; var i , x , y ; begin
89491: LD_INT 0
89493: PPUSH
89494: PPUSH
89495: PPUSH
89496: PPUSH
// result := false ;
89497: LD_ADDR_VAR 0 1
89501: PUSH
89502: LD_INT 0
89504: ST_TO_ADDR
// for i := 1 to 16 do
89505: LD_ADDR_VAR 0 2
89509: PUSH
89510: DOUBLE
89511: LD_INT 1
89513: DEC
89514: ST_TO_ADDR
89515: LD_INT 16
89517: PUSH
89518: FOR_TO
89519: IFFALSE 89718
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
89521: LD_ADDR_VAR 0 3
89525: PUSH
89526: LD_INT 10
89528: PUSH
89529: LD_INT 20
89531: PUSH
89532: LD_INT 30
89534: PUSH
89535: LD_INT 40
89537: PUSH
89538: LD_INT 50
89540: PUSH
89541: LD_INT 60
89543: PUSH
89544: LD_INT 70
89546: PUSH
89547: LD_INT 80
89549: PUSH
89550: LD_INT 90
89552: PUSH
89553: LD_INT 100
89555: PUSH
89556: LD_INT 110
89558: PUSH
89559: LD_INT 120
89561: PUSH
89562: LD_INT 130
89564: PUSH
89565: LD_INT 140
89567: PUSH
89568: LD_INT 150
89570: PUSH
89571: EMPTY
89572: LIST
89573: LIST
89574: LIST
89575: LIST
89576: LIST
89577: LIST
89578: LIST
89579: LIST
89580: LIST
89581: LIST
89582: LIST
89583: LIST
89584: LIST
89585: LIST
89586: LIST
89587: PUSH
89588: LD_INT 1
89590: PPUSH
89591: LD_INT 15
89593: PPUSH
89594: CALL_OW 12
89598: ARRAY
89599: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
89600: LD_ADDR_VAR 0 4
89604: PUSH
89605: LD_INT 10
89607: PUSH
89608: LD_INT 20
89610: PUSH
89611: LD_INT 30
89613: PUSH
89614: LD_INT 40
89616: PUSH
89617: LD_INT 50
89619: PUSH
89620: LD_INT 60
89622: PUSH
89623: LD_INT 70
89625: PUSH
89626: LD_INT 80
89628: PUSH
89629: LD_INT 90
89631: PUSH
89632: LD_INT 100
89634: PUSH
89635: LD_INT 110
89637: PUSH
89638: LD_INT 120
89640: PUSH
89641: LD_INT 130
89643: PUSH
89644: LD_INT 140
89646: PUSH
89647: LD_INT 150
89649: PUSH
89650: EMPTY
89651: LIST
89652: LIST
89653: LIST
89654: LIST
89655: LIST
89656: LIST
89657: LIST
89658: LIST
89659: LIST
89660: LIST
89661: LIST
89662: LIST
89663: LIST
89664: LIST
89665: LIST
89666: PUSH
89667: LD_INT 1
89669: PPUSH
89670: LD_INT 15
89672: PPUSH
89673: CALL_OW 12
89677: ARRAY
89678: ST_TO_ADDR
// if ValidHex ( x , y ) then
89679: LD_VAR 0 3
89683: PPUSH
89684: LD_VAR 0 4
89688: PPUSH
89689: CALL_OW 488
89693: IFFALSE 89716
// begin result := [ x , y ] ;
89695: LD_ADDR_VAR 0 1
89699: PUSH
89700: LD_VAR 0 3
89704: PUSH
89705: LD_VAR 0 4
89709: PUSH
89710: EMPTY
89711: LIST
89712: LIST
89713: ST_TO_ADDR
// break ;
89714: GO 89718
// end ; end ;
89716: GO 89518
89718: POP
89719: POP
// if result then
89720: LD_VAR 0 1
89724: IFFALSE 89784
// begin ToLua ( playSibBomb() ) ;
89726: LD_STRING playSibBomb()
89728: PPUSH
89729: CALL_OW 559
// wait ( 0 0$14 ) ;
89733: LD_INT 490
89735: PPUSH
89736: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
89740: LD_VAR 0 1
89744: PUSH
89745: LD_INT 1
89747: ARRAY
89748: PPUSH
89749: LD_VAR 0 1
89753: PUSH
89754: LD_INT 2
89756: ARRAY
89757: PPUSH
89758: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
89762: LD_VAR 0 1
89766: PUSH
89767: LD_INT 1
89769: ARRAY
89770: PPUSH
89771: LD_VAR 0 1
89775: PUSH
89776: LD_INT 2
89778: ARRAY
89779: PPUSH
89780: CALL_OW 429
// end ; end ;
89784: LD_VAR 0 1
89788: RET
// every 0 0$1 trigger StreamModeActive and sReset do
89789: LD_EXP 83
89793: PUSH
89794: LD_EXP 105
89798: AND
89799: IFFALSE 89811
89801: GO 89803
89803: DISABLE
// YouLost (  ) ;
89804: LD_STRING 
89806: PPUSH
89807: CALL_OW 104
89811: END
// every 0 0$1 trigger StreamModeActive and sFog do
89812: LD_EXP 83
89816: PUSH
89817: LD_EXP 104
89821: AND
89822: IFFALSE 89836
89824: GO 89826
89826: DISABLE
// FogOff ( your_side ) ;
89827: LD_OWVAR 2
89831: PPUSH
89832: CALL_OW 344
89836: END
// every 0 0$1 trigger StreamModeActive and sSun do
89837: LD_EXP 83
89841: PUSH
89842: LD_EXP 106
89846: AND
89847: IFFALSE 89875
89849: GO 89851
89851: DISABLE
// begin solar_recharge_percent := 0 ;
89852: LD_ADDR_OWVAR 79
89856: PUSH
89857: LD_INT 0
89859: ST_TO_ADDR
// wait ( 5 5$00 ) ;
89860: LD_INT 10500
89862: PPUSH
89863: CALL_OW 67
// solar_recharge_percent := 100 ;
89867: LD_ADDR_OWVAR 79
89871: PUSH
89872: LD_INT 100
89874: ST_TO_ADDR
// end ;
89875: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
89876: LD_EXP 83
89880: PUSH
89881: LD_EXP 107
89885: AND
89886: IFFALSE 90125
89888: GO 89890
89890: DISABLE
89891: LD_INT 0
89893: PPUSH
89894: PPUSH
89895: PPUSH
// begin tmp := [ ] ;
89896: LD_ADDR_VAR 0 3
89900: PUSH
89901: EMPTY
89902: ST_TO_ADDR
// for i := 1 to 6 do
89903: LD_ADDR_VAR 0 1
89907: PUSH
89908: DOUBLE
89909: LD_INT 1
89911: DEC
89912: ST_TO_ADDR
89913: LD_INT 6
89915: PUSH
89916: FOR_TO
89917: IFFALSE 90022
// begin uc_nation := nation_nature ;
89919: LD_ADDR_OWVAR 21
89923: PUSH
89924: LD_INT 0
89926: ST_TO_ADDR
// uc_side := 0 ;
89927: LD_ADDR_OWVAR 20
89931: PUSH
89932: LD_INT 0
89934: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
89935: LD_ADDR_OWVAR 29
89939: PUSH
89940: LD_INT 12
89942: PUSH
89943: LD_INT 12
89945: PUSH
89946: EMPTY
89947: LIST
89948: LIST
89949: ST_TO_ADDR
// hc_agressivity := 20 ;
89950: LD_ADDR_OWVAR 35
89954: PUSH
89955: LD_INT 20
89957: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
89958: LD_ADDR_OWVAR 28
89962: PUSH
89963: LD_INT 17
89965: ST_TO_ADDR
// hc_gallery :=  ;
89966: LD_ADDR_OWVAR 33
89970: PUSH
89971: LD_STRING 
89973: ST_TO_ADDR
// hc_name :=  ;
89974: LD_ADDR_OWVAR 26
89978: PUSH
89979: LD_STRING 
89981: ST_TO_ADDR
// un := CreateHuman ;
89982: LD_ADDR_VAR 0 2
89986: PUSH
89987: CALL_OW 44
89991: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
89992: LD_VAR 0 2
89996: PPUSH
89997: LD_INT 1
89999: PPUSH
90000: CALL_OW 51
// tmp := tmp ^ un ;
90004: LD_ADDR_VAR 0 3
90008: PUSH
90009: LD_VAR 0 3
90013: PUSH
90014: LD_VAR 0 2
90018: ADD
90019: ST_TO_ADDR
// end ;
90020: GO 89916
90022: POP
90023: POP
// repeat wait ( 0 0$1 ) ;
90024: LD_INT 35
90026: PPUSH
90027: CALL_OW 67
// for un in tmp do
90031: LD_ADDR_VAR 0 2
90035: PUSH
90036: LD_VAR 0 3
90040: PUSH
90041: FOR_IN
90042: IFFALSE 90116
// begin if IsDead ( un ) then
90044: LD_VAR 0 2
90048: PPUSH
90049: CALL_OW 301
90053: IFFALSE 90073
// begin tmp := tmp diff un ;
90055: LD_ADDR_VAR 0 3
90059: PUSH
90060: LD_VAR 0 3
90064: PUSH
90065: LD_VAR 0 2
90069: DIFF
90070: ST_TO_ADDR
// continue ;
90071: GO 90041
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
90073: LD_VAR 0 2
90077: PPUSH
90078: LD_INT 3
90080: PUSH
90081: LD_INT 22
90083: PUSH
90084: LD_INT 0
90086: PUSH
90087: EMPTY
90088: LIST
90089: LIST
90090: PUSH
90091: EMPTY
90092: LIST
90093: LIST
90094: PPUSH
90095: CALL_OW 69
90099: PPUSH
90100: LD_VAR 0 2
90104: PPUSH
90105: CALL_OW 74
90109: PPUSH
90110: CALL_OW 115
// end ;
90114: GO 90041
90116: POP
90117: POP
// until not tmp ;
90118: LD_VAR 0 3
90122: NOT
90123: IFFALSE 90024
// end ;
90125: PPOPN 3
90127: END
// every 0 0$1 trigger StreamModeActive and sTroll do
90128: LD_EXP 83
90132: PUSH
90133: LD_EXP 108
90137: AND
90138: IFFALSE 90192
90140: GO 90142
90142: DISABLE
// begin ToLua ( displayTroll(); ) ;
90143: LD_STRING displayTroll();
90145: PPUSH
90146: CALL_OW 559
// wait ( 3 3$00 ) ;
90150: LD_INT 6300
90152: PPUSH
90153: CALL_OW 67
// ToLua ( hideTroll(); ) ;
90157: LD_STRING hideTroll();
90159: PPUSH
90160: CALL_OW 559
// wait ( 1 1$00 ) ;
90164: LD_INT 2100
90166: PPUSH
90167: CALL_OW 67
// ToLua ( displayTroll(); ) ;
90171: LD_STRING displayTroll();
90173: PPUSH
90174: CALL_OW 559
// wait ( 1 1$00 ) ;
90178: LD_INT 2100
90180: PPUSH
90181: CALL_OW 67
// ToLua ( hideTroll(); ) ;
90185: LD_STRING hideTroll();
90187: PPUSH
90188: CALL_OW 559
// end ;
90192: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
90193: LD_EXP 83
90197: PUSH
90198: LD_EXP 109
90202: AND
90203: IFFALSE 90266
90205: GO 90207
90207: DISABLE
90208: LD_INT 0
90210: PPUSH
// begin p := 0 ;
90211: LD_ADDR_VAR 0 1
90215: PUSH
90216: LD_INT 0
90218: ST_TO_ADDR
// repeat game_speed := 1 ;
90219: LD_ADDR_OWVAR 65
90223: PUSH
90224: LD_INT 1
90226: ST_TO_ADDR
// wait ( 0 0$1 ) ;
90227: LD_INT 35
90229: PPUSH
90230: CALL_OW 67
// p := p + 1 ;
90234: LD_ADDR_VAR 0 1
90238: PUSH
90239: LD_VAR 0 1
90243: PUSH
90244: LD_INT 1
90246: PLUS
90247: ST_TO_ADDR
// until p >= 60 ;
90248: LD_VAR 0 1
90252: PUSH
90253: LD_INT 60
90255: GREATEREQUAL
90256: IFFALSE 90219
// game_speed := 4 ;
90258: LD_ADDR_OWVAR 65
90262: PUSH
90263: LD_INT 4
90265: ST_TO_ADDR
// end ;
90266: PPOPN 1
90268: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
90269: LD_EXP 83
90273: PUSH
90274: LD_EXP 110
90278: AND
90279: IFFALSE 90425
90281: GO 90283
90283: DISABLE
90284: LD_INT 0
90286: PPUSH
90287: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
90288: LD_ADDR_VAR 0 1
90292: PUSH
90293: LD_INT 22
90295: PUSH
90296: LD_OWVAR 2
90300: PUSH
90301: EMPTY
90302: LIST
90303: LIST
90304: PUSH
90305: LD_INT 2
90307: PUSH
90308: LD_INT 30
90310: PUSH
90311: LD_INT 0
90313: PUSH
90314: EMPTY
90315: LIST
90316: LIST
90317: PUSH
90318: LD_INT 30
90320: PUSH
90321: LD_INT 1
90323: PUSH
90324: EMPTY
90325: LIST
90326: LIST
90327: PUSH
90328: EMPTY
90329: LIST
90330: LIST
90331: LIST
90332: PUSH
90333: EMPTY
90334: LIST
90335: LIST
90336: PPUSH
90337: CALL_OW 69
90341: ST_TO_ADDR
// if not depot then
90342: LD_VAR 0 1
90346: NOT
90347: IFFALSE 90351
// exit ;
90349: GO 90425
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
90351: LD_ADDR_VAR 0 2
90355: PUSH
90356: LD_VAR 0 1
90360: PUSH
90361: LD_INT 1
90363: PPUSH
90364: LD_VAR 0 1
90368: PPUSH
90369: CALL_OW 12
90373: ARRAY
90374: PPUSH
90375: CALL_OW 274
90379: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
90380: LD_VAR 0 2
90384: PPUSH
90385: LD_INT 1
90387: PPUSH
90388: LD_INT 0
90390: PPUSH
90391: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
90395: LD_VAR 0 2
90399: PPUSH
90400: LD_INT 2
90402: PPUSH
90403: LD_INT 0
90405: PPUSH
90406: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
90410: LD_VAR 0 2
90414: PPUSH
90415: LD_INT 3
90417: PPUSH
90418: LD_INT 0
90420: PPUSH
90421: CALL_OW 277
// end ;
90425: PPOPN 2
90427: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
90428: LD_EXP 83
90432: PUSH
90433: LD_EXP 111
90437: AND
90438: IFFALSE 90535
90440: GO 90442
90442: DISABLE
90443: LD_INT 0
90445: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
90446: LD_ADDR_VAR 0 1
90450: PUSH
90451: LD_INT 22
90453: PUSH
90454: LD_OWVAR 2
90458: PUSH
90459: EMPTY
90460: LIST
90461: LIST
90462: PUSH
90463: LD_INT 21
90465: PUSH
90466: LD_INT 1
90468: PUSH
90469: EMPTY
90470: LIST
90471: LIST
90472: PUSH
90473: LD_INT 3
90475: PUSH
90476: LD_INT 23
90478: PUSH
90479: LD_INT 0
90481: PUSH
90482: EMPTY
90483: LIST
90484: LIST
90485: PUSH
90486: EMPTY
90487: LIST
90488: LIST
90489: PUSH
90490: EMPTY
90491: LIST
90492: LIST
90493: LIST
90494: PPUSH
90495: CALL_OW 69
90499: ST_TO_ADDR
// if not tmp then
90500: LD_VAR 0 1
90504: NOT
90505: IFFALSE 90509
// exit ;
90507: GO 90535
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
90509: LD_VAR 0 1
90513: PUSH
90514: LD_INT 1
90516: PPUSH
90517: LD_VAR 0 1
90521: PPUSH
90522: CALL_OW 12
90526: ARRAY
90527: PPUSH
90528: LD_INT 200
90530: PPUSH
90531: CALL_OW 234
// end ;
90535: PPOPN 1
90537: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
90538: LD_EXP 83
90542: PUSH
90543: LD_EXP 112
90547: AND
90548: IFFALSE 90627
90550: GO 90552
90552: DISABLE
90553: LD_INT 0
90555: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
90556: LD_ADDR_VAR 0 1
90560: PUSH
90561: LD_INT 22
90563: PUSH
90564: LD_OWVAR 2
90568: PUSH
90569: EMPTY
90570: LIST
90571: LIST
90572: PUSH
90573: LD_INT 21
90575: PUSH
90576: LD_INT 2
90578: PUSH
90579: EMPTY
90580: LIST
90581: LIST
90582: PUSH
90583: EMPTY
90584: LIST
90585: LIST
90586: PPUSH
90587: CALL_OW 69
90591: ST_TO_ADDR
// if not tmp then
90592: LD_VAR 0 1
90596: NOT
90597: IFFALSE 90601
// exit ;
90599: GO 90627
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
90601: LD_VAR 0 1
90605: PUSH
90606: LD_INT 1
90608: PPUSH
90609: LD_VAR 0 1
90613: PPUSH
90614: CALL_OW 12
90618: ARRAY
90619: PPUSH
90620: LD_INT 60
90622: PPUSH
90623: CALL_OW 234
// end ;
90627: PPOPN 1
90629: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
90630: LD_EXP 83
90634: PUSH
90635: LD_EXP 113
90639: AND
90640: IFFALSE 90739
90642: GO 90644
90644: DISABLE
90645: LD_INT 0
90647: PPUSH
90648: PPUSH
// begin enable ;
90649: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
90650: LD_ADDR_VAR 0 1
90654: PUSH
90655: LD_INT 22
90657: PUSH
90658: LD_OWVAR 2
90662: PUSH
90663: EMPTY
90664: LIST
90665: LIST
90666: PUSH
90667: LD_INT 61
90669: PUSH
90670: EMPTY
90671: LIST
90672: PUSH
90673: LD_INT 33
90675: PUSH
90676: LD_INT 2
90678: PUSH
90679: EMPTY
90680: LIST
90681: LIST
90682: PUSH
90683: EMPTY
90684: LIST
90685: LIST
90686: LIST
90687: PPUSH
90688: CALL_OW 69
90692: ST_TO_ADDR
// if not tmp then
90693: LD_VAR 0 1
90697: NOT
90698: IFFALSE 90702
// exit ;
90700: GO 90739
// for i in tmp do
90702: LD_ADDR_VAR 0 2
90706: PUSH
90707: LD_VAR 0 1
90711: PUSH
90712: FOR_IN
90713: IFFALSE 90737
// if IsControledBy ( i ) then
90715: LD_VAR 0 2
90719: PPUSH
90720: CALL_OW 312
90724: IFFALSE 90735
// ComUnlink ( i ) ;
90726: LD_VAR 0 2
90730: PPUSH
90731: CALL_OW 136
90735: GO 90712
90737: POP
90738: POP
// end ;
90739: PPOPN 2
90741: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
90742: LD_EXP 83
90746: PUSH
90747: LD_EXP 114
90751: AND
90752: IFFALSE 90892
90754: GO 90756
90756: DISABLE
90757: LD_INT 0
90759: PPUSH
90760: PPUSH
// begin ToLua ( displayPowell(); ) ;
90761: LD_STRING displayPowell();
90763: PPUSH
90764: CALL_OW 559
// uc_side := 0 ;
90768: LD_ADDR_OWVAR 20
90772: PUSH
90773: LD_INT 0
90775: ST_TO_ADDR
// uc_nation := 2 ;
90776: LD_ADDR_OWVAR 21
90780: PUSH
90781: LD_INT 2
90783: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
90784: LD_ADDR_OWVAR 37
90788: PUSH
90789: LD_INT 14
90791: ST_TO_ADDR
// vc_engine := engine_siberite ;
90792: LD_ADDR_OWVAR 39
90796: PUSH
90797: LD_INT 3
90799: ST_TO_ADDR
// vc_control := control_apeman ;
90800: LD_ADDR_OWVAR 38
90804: PUSH
90805: LD_INT 5
90807: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
90808: LD_ADDR_OWVAR 40
90812: PUSH
90813: LD_INT 29
90815: ST_TO_ADDR
// un := CreateVehicle ;
90816: LD_ADDR_VAR 0 2
90820: PUSH
90821: CALL_OW 45
90825: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
90826: LD_VAR 0 2
90830: PPUSH
90831: LD_INT 1
90833: PPUSH
90834: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
90838: LD_INT 35
90840: PPUSH
90841: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
90845: LD_VAR 0 2
90849: PPUSH
90850: LD_INT 22
90852: PUSH
90853: LD_OWVAR 2
90857: PUSH
90858: EMPTY
90859: LIST
90860: LIST
90861: PPUSH
90862: CALL_OW 69
90866: PPUSH
90867: LD_VAR 0 2
90871: PPUSH
90872: CALL_OW 74
90876: PPUSH
90877: CALL_OW 115
// until IsDead ( un ) ;
90881: LD_VAR 0 2
90885: PPUSH
90886: CALL_OW 301
90890: IFFALSE 90838
// end ;
90892: PPOPN 2
90894: END
// every 0 0$1 trigger StreamModeActive and sStu do
90895: LD_EXP 83
90899: PUSH
90900: LD_EXP 122
90904: AND
90905: IFFALSE 90921
90907: GO 90909
90909: DISABLE
// begin ToLua ( displayStucuk(); ) ;
90910: LD_STRING displayStucuk();
90912: PPUSH
90913: CALL_OW 559
// ResetFog ;
90917: CALL_OW 335
// end ;
90921: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
90922: LD_EXP 83
90926: PUSH
90927: LD_EXP 115
90931: AND
90932: IFFALSE 91073
90934: GO 90936
90936: DISABLE
90937: LD_INT 0
90939: PPUSH
90940: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
90941: LD_ADDR_VAR 0 2
90945: PUSH
90946: LD_INT 22
90948: PUSH
90949: LD_OWVAR 2
90953: PUSH
90954: EMPTY
90955: LIST
90956: LIST
90957: PUSH
90958: LD_INT 21
90960: PUSH
90961: LD_INT 1
90963: PUSH
90964: EMPTY
90965: LIST
90966: LIST
90967: PUSH
90968: EMPTY
90969: LIST
90970: LIST
90971: PPUSH
90972: CALL_OW 69
90976: ST_TO_ADDR
// if not tmp then
90977: LD_VAR 0 2
90981: NOT
90982: IFFALSE 90986
// exit ;
90984: GO 91073
// un := tmp [ rand ( 1 , tmp ) ] ;
90986: LD_ADDR_VAR 0 1
90990: PUSH
90991: LD_VAR 0 2
90995: PUSH
90996: LD_INT 1
90998: PPUSH
90999: LD_VAR 0 2
91003: PPUSH
91004: CALL_OW 12
91008: ARRAY
91009: ST_TO_ADDR
// SetSide ( un , 0 ) ;
91010: LD_VAR 0 1
91014: PPUSH
91015: LD_INT 0
91017: PPUSH
91018: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
91022: LD_VAR 0 1
91026: PPUSH
91027: LD_OWVAR 3
91031: PUSH
91032: LD_VAR 0 1
91036: DIFF
91037: PPUSH
91038: LD_VAR 0 1
91042: PPUSH
91043: CALL_OW 74
91047: PPUSH
91048: CALL_OW 115
// wait ( 0 0$20 ) ;
91052: LD_INT 700
91054: PPUSH
91055: CALL_OW 67
// SetSide ( un , your_side ) ;
91059: LD_VAR 0 1
91063: PPUSH
91064: LD_OWVAR 2
91068: PPUSH
91069: CALL_OW 235
// end ;
91073: PPOPN 2
91075: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
91076: LD_EXP 83
91080: PUSH
91081: LD_EXP 116
91085: AND
91086: IFFALSE 91192
91088: GO 91090
91090: DISABLE
91091: LD_INT 0
91093: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
91094: LD_ADDR_VAR 0 1
91098: PUSH
91099: LD_INT 22
91101: PUSH
91102: LD_OWVAR 2
91106: PUSH
91107: EMPTY
91108: LIST
91109: LIST
91110: PUSH
91111: LD_INT 2
91113: PUSH
91114: LD_INT 30
91116: PUSH
91117: LD_INT 0
91119: PUSH
91120: EMPTY
91121: LIST
91122: LIST
91123: PUSH
91124: LD_INT 30
91126: PUSH
91127: LD_INT 1
91129: PUSH
91130: EMPTY
91131: LIST
91132: LIST
91133: PUSH
91134: EMPTY
91135: LIST
91136: LIST
91137: LIST
91138: PUSH
91139: EMPTY
91140: LIST
91141: LIST
91142: PPUSH
91143: CALL_OW 69
91147: ST_TO_ADDR
// if not depot then
91148: LD_VAR 0 1
91152: NOT
91153: IFFALSE 91157
// exit ;
91155: GO 91192
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
91157: LD_VAR 0 1
91161: PUSH
91162: LD_INT 1
91164: ARRAY
91165: PPUSH
91166: CALL_OW 250
91170: PPUSH
91171: LD_VAR 0 1
91175: PUSH
91176: LD_INT 1
91178: ARRAY
91179: PPUSH
91180: CALL_OW 251
91184: PPUSH
91185: LD_INT 70
91187: PPUSH
91188: CALL_OW 495
// end ;
91192: PPOPN 1
91194: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
91195: LD_EXP 83
91199: PUSH
91200: LD_EXP 117
91204: AND
91205: IFFALSE 91416
91207: GO 91209
91209: DISABLE
91210: LD_INT 0
91212: PPUSH
91213: PPUSH
91214: PPUSH
91215: PPUSH
91216: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
91217: LD_ADDR_VAR 0 5
91221: PUSH
91222: LD_INT 22
91224: PUSH
91225: LD_OWVAR 2
91229: PUSH
91230: EMPTY
91231: LIST
91232: LIST
91233: PUSH
91234: LD_INT 21
91236: PUSH
91237: LD_INT 1
91239: PUSH
91240: EMPTY
91241: LIST
91242: LIST
91243: PUSH
91244: EMPTY
91245: LIST
91246: LIST
91247: PPUSH
91248: CALL_OW 69
91252: ST_TO_ADDR
// if not tmp then
91253: LD_VAR 0 5
91257: NOT
91258: IFFALSE 91262
// exit ;
91260: GO 91416
// for i in tmp do
91262: LD_ADDR_VAR 0 1
91266: PUSH
91267: LD_VAR 0 5
91271: PUSH
91272: FOR_IN
91273: IFFALSE 91414
// begin d := rand ( 0 , 5 ) ;
91275: LD_ADDR_VAR 0 4
91279: PUSH
91280: LD_INT 0
91282: PPUSH
91283: LD_INT 5
91285: PPUSH
91286: CALL_OW 12
91290: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
91291: LD_ADDR_VAR 0 2
91295: PUSH
91296: LD_VAR 0 1
91300: PPUSH
91301: CALL_OW 250
91305: PPUSH
91306: LD_VAR 0 4
91310: PPUSH
91311: LD_INT 3
91313: PPUSH
91314: LD_INT 12
91316: PPUSH
91317: CALL_OW 12
91321: PPUSH
91322: CALL_OW 272
91326: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
91327: LD_ADDR_VAR 0 3
91331: PUSH
91332: LD_VAR 0 1
91336: PPUSH
91337: CALL_OW 251
91341: PPUSH
91342: LD_VAR 0 4
91346: PPUSH
91347: LD_INT 3
91349: PPUSH
91350: LD_INT 12
91352: PPUSH
91353: CALL_OW 12
91357: PPUSH
91358: CALL_OW 273
91362: ST_TO_ADDR
// if ValidHex ( x , y ) then
91363: LD_VAR 0 2
91367: PPUSH
91368: LD_VAR 0 3
91372: PPUSH
91373: CALL_OW 488
91377: IFFALSE 91412
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
91379: LD_VAR 0 1
91383: PPUSH
91384: LD_VAR 0 2
91388: PPUSH
91389: LD_VAR 0 3
91393: PPUSH
91394: LD_INT 3
91396: PPUSH
91397: LD_INT 6
91399: PPUSH
91400: CALL_OW 12
91404: PPUSH
91405: LD_INT 1
91407: PPUSH
91408: CALL_OW 483
// end ;
91412: GO 91272
91414: POP
91415: POP
// end ;
91416: PPOPN 5
91418: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
91419: LD_EXP 83
91423: PUSH
91424: LD_EXP 118
91428: AND
91429: IFFALSE 91523
91431: GO 91433
91433: DISABLE
91434: LD_INT 0
91436: PPUSH
91437: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
91438: LD_ADDR_VAR 0 2
91442: PUSH
91443: LD_INT 22
91445: PUSH
91446: LD_OWVAR 2
91450: PUSH
91451: EMPTY
91452: LIST
91453: LIST
91454: PUSH
91455: LD_INT 32
91457: PUSH
91458: LD_INT 1
91460: PUSH
91461: EMPTY
91462: LIST
91463: LIST
91464: PUSH
91465: LD_INT 21
91467: PUSH
91468: LD_INT 2
91470: PUSH
91471: EMPTY
91472: LIST
91473: LIST
91474: PUSH
91475: EMPTY
91476: LIST
91477: LIST
91478: LIST
91479: PPUSH
91480: CALL_OW 69
91484: ST_TO_ADDR
// if not tmp then
91485: LD_VAR 0 2
91489: NOT
91490: IFFALSE 91494
// exit ;
91492: GO 91523
// for i in tmp do
91494: LD_ADDR_VAR 0 1
91498: PUSH
91499: LD_VAR 0 2
91503: PUSH
91504: FOR_IN
91505: IFFALSE 91521
// SetFuel ( i , 0 ) ;
91507: LD_VAR 0 1
91511: PPUSH
91512: LD_INT 0
91514: PPUSH
91515: CALL_OW 240
91519: GO 91504
91521: POP
91522: POP
// end ;
91523: PPOPN 2
91525: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
91526: LD_EXP 83
91530: PUSH
91531: LD_EXP 119
91535: AND
91536: IFFALSE 91602
91538: GO 91540
91540: DISABLE
91541: LD_INT 0
91543: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
91544: LD_ADDR_VAR 0 1
91548: PUSH
91549: LD_INT 22
91551: PUSH
91552: LD_OWVAR 2
91556: PUSH
91557: EMPTY
91558: LIST
91559: LIST
91560: PUSH
91561: LD_INT 30
91563: PUSH
91564: LD_INT 29
91566: PUSH
91567: EMPTY
91568: LIST
91569: LIST
91570: PUSH
91571: EMPTY
91572: LIST
91573: LIST
91574: PPUSH
91575: CALL_OW 69
91579: ST_TO_ADDR
// if not tmp then
91580: LD_VAR 0 1
91584: NOT
91585: IFFALSE 91589
// exit ;
91587: GO 91602
// DestroyUnit ( tmp [ 1 ] ) ;
91589: LD_VAR 0 1
91593: PUSH
91594: LD_INT 1
91596: ARRAY
91597: PPUSH
91598: CALL_OW 65
// end ;
91602: PPOPN 1
91604: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
91605: LD_EXP 83
91609: PUSH
91610: LD_EXP 121
91614: AND
91615: IFFALSE 91744
91617: GO 91619
91619: DISABLE
91620: LD_INT 0
91622: PPUSH
// begin uc_side := 0 ;
91623: LD_ADDR_OWVAR 20
91627: PUSH
91628: LD_INT 0
91630: ST_TO_ADDR
// uc_nation := nation_arabian ;
91631: LD_ADDR_OWVAR 21
91635: PUSH
91636: LD_INT 2
91638: ST_TO_ADDR
// hc_gallery :=  ;
91639: LD_ADDR_OWVAR 33
91643: PUSH
91644: LD_STRING 
91646: ST_TO_ADDR
// hc_name :=  ;
91647: LD_ADDR_OWVAR 26
91651: PUSH
91652: LD_STRING 
91654: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
91655: LD_INT 1
91657: PPUSH
91658: LD_INT 11
91660: PPUSH
91661: LD_INT 10
91663: PPUSH
91664: CALL_OW 380
// un := CreateHuman ;
91668: LD_ADDR_VAR 0 1
91672: PUSH
91673: CALL_OW 44
91677: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
91678: LD_VAR 0 1
91682: PPUSH
91683: LD_INT 1
91685: PPUSH
91686: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
91690: LD_INT 35
91692: PPUSH
91693: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
91697: LD_VAR 0 1
91701: PPUSH
91702: LD_INT 22
91704: PUSH
91705: LD_OWVAR 2
91709: PUSH
91710: EMPTY
91711: LIST
91712: LIST
91713: PPUSH
91714: CALL_OW 69
91718: PPUSH
91719: LD_VAR 0 1
91723: PPUSH
91724: CALL_OW 74
91728: PPUSH
91729: CALL_OW 115
// until IsDead ( un ) ;
91733: LD_VAR 0 1
91737: PPUSH
91738: CALL_OW 301
91742: IFFALSE 91690
// end ;
91744: PPOPN 1
91746: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
91747: LD_EXP 83
91751: PUSH
91752: LD_EXP 123
91756: AND
91757: IFFALSE 91769
91759: GO 91761
91761: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
91762: LD_STRING earthquake(getX(game), 0, 32)
91764: PPUSH
91765: CALL_OW 559
91769: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
91770: LD_EXP 83
91774: PUSH
91775: LD_EXP 124
91779: AND
91780: IFFALSE 91871
91782: GO 91784
91784: DISABLE
91785: LD_INT 0
91787: PPUSH
// begin enable ;
91788: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
91789: LD_ADDR_VAR 0 1
91793: PUSH
91794: LD_INT 22
91796: PUSH
91797: LD_OWVAR 2
91801: PUSH
91802: EMPTY
91803: LIST
91804: LIST
91805: PUSH
91806: LD_INT 21
91808: PUSH
91809: LD_INT 2
91811: PUSH
91812: EMPTY
91813: LIST
91814: LIST
91815: PUSH
91816: LD_INT 33
91818: PUSH
91819: LD_INT 3
91821: PUSH
91822: EMPTY
91823: LIST
91824: LIST
91825: PUSH
91826: EMPTY
91827: LIST
91828: LIST
91829: LIST
91830: PPUSH
91831: CALL_OW 69
91835: ST_TO_ADDR
// if not tmp then
91836: LD_VAR 0 1
91840: NOT
91841: IFFALSE 91845
// exit ;
91843: GO 91871
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
91845: LD_VAR 0 1
91849: PUSH
91850: LD_INT 1
91852: PPUSH
91853: LD_VAR 0 1
91857: PPUSH
91858: CALL_OW 12
91862: ARRAY
91863: PPUSH
91864: LD_INT 1
91866: PPUSH
91867: CALL_OW 234
// end ;
91871: PPOPN 1
91873: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
91874: LD_EXP 83
91878: PUSH
91879: LD_EXP 125
91883: AND
91884: IFFALSE 92025
91886: GO 91888
91888: DISABLE
91889: LD_INT 0
91891: PPUSH
91892: PPUSH
91893: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
91894: LD_ADDR_VAR 0 3
91898: PUSH
91899: LD_INT 22
91901: PUSH
91902: LD_OWVAR 2
91906: PUSH
91907: EMPTY
91908: LIST
91909: LIST
91910: PUSH
91911: LD_INT 25
91913: PUSH
91914: LD_INT 1
91916: PUSH
91917: EMPTY
91918: LIST
91919: LIST
91920: PUSH
91921: EMPTY
91922: LIST
91923: LIST
91924: PPUSH
91925: CALL_OW 69
91929: ST_TO_ADDR
// if not tmp then
91930: LD_VAR 0 3
91934: NOT
91935: IFFALSE 91939
// exit ;
91937: GO 92025
// un := tmp [ rand ( 1 , tmp ) ] ;
91939: LD_ADDR_VAR 0 2
91943: PUSH
91944: LD_VAR 0 3
91948: PUSH
91949: LD_INT 1
91951: PPUSH
91952: LD_VAR 0 3
91956: PPUSH
91957: CALL_OW 12
91961: ARRAY
91962: ST_TO_ADDR
// if Crawls ( un ) then
91963: LD_VAR 0 2
91967: PPUSH
91968: CALL_OW 318
91972: IFFALSE 91983
// ComWalk ( un ) ;
91974: LD_VAR 0 2
91978: PPUSH
91979: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
91983: LD_VAR 0 2
91987: PPUSH
91988: LD_INT 9
91990: PPUSH
91991: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
91995: LD_INT 28
91997: PPUSH
91998: LD_OWVAR 2
92002: PPUSH
92003: LD_INT 2
92005: PPUSH
92006: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
92010: LD_INT 29
92012: PPUSH
92013: LD_OWVAR 2
92017: PPUSH
92018: LD_INT 2
92020: PPUSH
92021: CALL_OW 322
// end ;
92025: PPOPN 3
92027: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
92028: LD_EXP 83
92032: PUSH
92033: LD_EXP 126
92037: AND
92038: IFFALSE 92149
92040: GO 92042
92042: DISABLE
92043: LD_INT 0
92045: PPUSH
92046: PPUSH
92047: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
92048: LD_ADDR_VAR 0 3
92052: PUSH
92053: LD_INT 22
92055: PUSH
92056: LD_OWVAR 2
92060: PUSH
92061: EMPTY
92062: LIST
92063: LIST
92064: PUSH
92065: LD_INT 25
92067: PUSH
92068: LD_INT 1
92070: PUSH
92071: EMPTY
92072: LIST
92073: LIST
92074: PUSH
92075: EMPTY
92076: LIST
92077: LIST
92078: PPUSH
92079: CALL_OW 69
92083: ST_TO_ADDR
// if not tmp then
92084: LD_VAR 0 3
92088: NOT
92089: IFFALSE 92093
// exit ;
92091: GO 92149
// un := tmp [ rand ( 1 , tmp ) ] ;
92093: LD_ADDR_VAR 0 2
92097: PUSH
92098: LD_VAR 0 3
92102: PUSH
92103: LD_INT 1
92105: PPUSH
92106: LD_VAR 0 3
92110: PPUSH
92111: CALL_OW 12
92115: ARRAY
92116: ST_TO_ADDR
// if Crawls ( un ) then
92117: LD_VAR 0 2
92121: PPUSH
92122: CALL_OW 318
92126: IFFALSE 92137
// ComWalk ( un ) ;
92128: LD_VAR 0 2
92132: PPUSH
92133: CALL_OW 138
// SetClass ( un , class_mortar ) ;
92137: LD_VAR 0 2
92141: PPUSH
92142: LD_INT 8
92144: PPUSH
92145: CALL_OW 336
// end ;
92149: PPOPN 3
92151: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
92152: LD_EXP 83
92156: PUSH
92157: LD_EXP 127
92161: AND
92162: IFFALSE 92306
92164: GO 92166
92166: DISABLE
92167: LD_INT 0
92169: PPUSH
92170: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
92171: LD_ADDR_VAR 0 2
92175: PUSH
92176: LD_INT 22
92178: PUSH
92179: LD_OWVAR 2
92183: PUSH
92184: EMPTY
92185: LIST
92186: LIST
92187: PUSH
92188: LD_INT 21
92190: PUSH
92191: LD_INT 2
92193: PUSH
92194: EMPTY
92195: LIST
92196: LIST
92197: PUSH
92198: LD_INT 2
92200: PUSH
92201: LD_INT 34
92203: PUSH
92204: LD_INT 12
92206: PUSH
92207: EMPTY
92208: LIST
92209: LIST
92210: PUSH
92211: LD_INT 34
92213: PUSH
92214: LD_INT 51
92216: PUSH
92217: EMPTY
92218: LIST
92219: LIST
92220: PUSH
92221: LD_INT 34
92223: PUSH
92224: LD_INT 32
92226: PUSH
92227: EMPTY
92228: LIST
92229: LIST
92230: PUSH
92231: EMPTY
92232: LIST
92233: LIST
92234: LIST
92235: LIST
92236: PUSH
92237: EMPTY
92238: LIST
92239: LIST
92240: LIST
92241: PPUSH
92242: CALL_OW 69
92246: ST_TO_ADDR
// if not tmp then
92247: LD_VAR 0 2
92251: NOT
92252: IFFALSE 92256
// exit ;
92254: GO 92306
// for i in tmp do
92256: LD_ADDR_VAR 0 1
92260: PUSH
92261: LD_VAR 0 2
92265: PUSH
92266: FOR_IN
92267: IFFALSE 92304
// if GetCargo ( i , mat_artifact ) = 0 then
92269: LD_VAR 0 1
92273: PPUSH
92274: LD_INT 4
92276: PPUSH
92277: CALL_OW 289
92281: PUSH
92282: LD_INT 0
92284: EQUAL
92285: IFFALSE 92302
// SetCargo ( i , mat_siberit , 100 ) ;
92287: LD_VAR 0 1
92291: PPUSH
92292: LD_INT 3
92294: PPUSH
92295: LD_INT 100
92297: PPUSH
92298: CALL_OW 290
92302: GO 92266
92304: POP
92305: POP
// end ;
92306: PPOPN 2
92308: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
92309: LD_EXP 83
92313: PUSH
92314: LD_EXP 128
92318: AND
92319: IFFALSE 92502
92321: GO 92323
92323: DISABLE
92324: LD_INT 0
92326: PPUSH
92327: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
92328: LD_ADDR_VAR 0 2
92332: PUSH
92333: LD_INT 22
92335: PUSH
92336: LD_OWVAR 2
92340: PUSH
92341: EMPTY
92342: LIST
92343: LIST
92344: PPUSH
92345: CALL_OW 69
92349: ST_TO_ADDR
// if not tmp then
92350: LD_VAR 0 2
92354: NOT
92355: IFFALSE 92359
// exit ;
92357: GO 92502
// for i := 1 to 2 do
92359: LD_ADDR_VAR 0 1
92363: PUSH
92364: DOUBLE
92365: LD_INT 1
92367: DEC
92368: ST_TO_ADDR
92369: LD_INT 2
92371: PUSH
92372: FOR_TO
92373: IFFALSE 92500
// begin uc_side := your_side ;
92375: LD_ADDR_OWVAR 20
92379: PUSH
92380: LD_OWVAR 2
92384: ST_TO_ADDR
// uc_nation := nation_american ;
92385: LD_ADDR_OWVAR 21
92389: PUSH
92390: LD_INT 1
92392: ST_TO_ADDR
// vc_chassis := us_morphling ;
92393: LD_ADDR_OWVAR 37
92397: PUSH
92398: LD_INT 5
92400: ST_TO_ADDR
// vc_engine := engine_siberite ;
92401: LD_ADDR_OWVAR 39
92405: PUSH
92406: LD_INT 3
92408: ST_TO_ADDR
// vc_control := control_computer ;
92409: LD_ADDR_OWVAR 38
92413: PUSH
92414: LD_INT 3
92416: ST_TO_ADDR
// vc_weapon := us_double_laser ;
92417: LD_ADDR_OWVAR 40
92421: PUSH
92422: LD_INT 10
92424: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
92425: LD_VAR 0 2
92429: PUSH
92430: LD_INT 1
92432: ARRAY
92433: PPUSH
92434: CALL_OW 310
92438: NOT
92439: IFFALSE 92486
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
92441: CALL_OW 45
92445: PPUSH
92446: LD_VAR 0 2
92450: PUSH
92451: LD_INT 1
92453: ARRAY
92454: PPUSH
92455: CALL_OW 250
92459: PPUSH
92460: LD_VAR 0 2
92464: PUSH
92465: LD_INT 1
92467: ARRAY
92468: PPUSH
92469: CALL_OW 251
92473: PPUSH
92474: LD_INT 12
92476: PPUSH
92477: LD_INT 1
92479: PPUSH
92480: CALL_OW 50
92484: GO 92498
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
92486: CALL_OW 45
92490: PPUSH
92491: LD_INT 1
92493: PPUSH
92494: CALL_OW 51
// end ;
92498: GO 92372
92500: POP
92501: POP
// end ;
92502: PPOPN 2
92504: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
92505: LD_EXP 83
92509: PUSH
92510: LD_EXP 129
92514: AND
92515: IFFALSE 92737
92517: GO 92519
92519: DISABLE
92520: LD_INT 0
92522: PPUSH
92523: PPUSH
92524: PPUSH
92525: PPUSH
92526: PPUSH
92527: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
92528: LD_ADDR_VAR 0 6
92532: PUSH
92533: LD_INT 22
92535: PUSH
92536: LD_OWVAR 2
92540: PUSH
92541: EMPTY
92542: LIST
92543: LIST
92544: PUSH
92545: LD_INT 21
92547: PUSH
92548: LD_INT 1
92550: PUSH
92551: EMPTY
92552: LIST
92553: LIST
92554: PUSH
92555: LD_INT 3
92557: PUSH
92558: LD_INT 23
92560: PUSH
92561: LD_INT 0
92563: PUSH
92564: EMPTY
92565: LIST
92566: LIST
92567: PUSH
92568: EMPTY
92569: LIST
92570: LIST
92571: PUSH
92572: EMPTY
92573: LIST
92574: LIST
92575: LIST
92576: PPUSH
92577: CALL_OW 69
92581: ST_TO_ADDR
// if not tmp then
92582: LD_VAR 0 6
92586: NOT
92587: IFFALSE 92591
// exit ;
92589: GO 92737
// s1 := rand ( 1 , 4 ) ;
92591: LD_ADDR_VAR 0 2
92595: PUSH
92596: LD_INT 1
92598: PPUSH
92599: LD_INT 4
92601: PPUSH
92602: CALL_OW 12
92606: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
92607: LD_ADDR_VAR 0 4
92611: PUSH
92612: LD_VAR 0 6
92616: PUSH
92617: LD_INT 1
92619: ARRAY
92620: PPUSH
92621: LD_VAR 0 2
92625: PPUSH
92626: CALL_OW 259
92630: ST_TO_ADDR
// if s1 = 1 then
92631: LD_VAR 0 2
92635: PUSH
92636: LD_INT 1
92638: EQUAL
92639: IFFALSE 92659
// s2 := rand ( 2 , 4 ) else
92641: LD_ADDR_VAR 0 3
92645: PUSH
92646: LD_INT 2
92648: PPUSH
92649: LD_INT 4
92651: PPUSH
92652: CALL_OW 12
92656: ST_TO_ADDR
92657: GO 92667
// s2 := 1 ;
92659: LD_ADDR_VAR 0 3
92663: PUSH
92664: LD_INT 1
92666: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
92667: LD_ADDR_VAR 0 5
92671: PUSH
92672: LD_VAR 0 6
92676: PUSH
92677: LD_INT 1
92679: ARRAY
92680: PPUSH
92681: LD_VAR 0 3
92685: PPUSH
92686: CALL_OW 259
92690: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
92691: LD_VAR 0 6
92695: PUSH
92696: LD_INT 1
92698: ARRAY
92699: PPUSH
92700: LD_VAR 0 2
92704: PPUSH
92705: LD_VAR 0 5
92709: PPUSH
92710: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
92714: LD_VAR 0 6
92718: PUSH
92719: LD_INT 1
92721: ARRAY
92722: PPUSH
92723: LD_VAR 0 3
92727: PPUSH
92728: LD_VAR 0 4
92732: PPUSH
92733: CALL_OW 237
// end ;
92737: PPOPN 6
92739: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
92740: LD_EXP 83
92744: PUSH
92745: LD_EXP 130
92749: AND
92750: IFFALSE 92829
92752: GO 92754
92754: DISABLE
92755: LD_INT 0
92757: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
92758: LD_ADDR_VAR 0 1
92762: PUSH
92763: LD_INT 22
92765: PUSH
92766: LD_OWVAR 2
92770: PUSH
92771: EMPTY
92772: LIST
92773: LIST
92774: PUSH
92775: LD_INT 30
92777: PUSH
92778: LD_INT 3
92780: PUSH
92781: EMPTY
92782: LIST
92783: LIST
92784: PUSH
92785: EMPTY
92786: LIST
92787: LIST
92788: PPUSH
92789: CALL_OW 69
92793: ST_TO_ADDR
// if not tmp then
92794: LD_VAR 0 1
92798: NOT
92799: IFFALSE 92803
// exit ;
92801: GO 92829
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
92803: LD_VAR 0 1
92807: PUSH
92808: LD_INT 1
92810: PPUSH
92811: LD_VAR 0 1
92815: PPUSH
92816: CALL_OW 12
92820: ARRAY
92821: PPUSH
92822: LD_INT 1
92824: PPUSH
92825: CALL_OW 234
// end ;
92829: PPOPN 1
92831: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
92832: LD_EXP 83
92836: PUSH
92837: LD_EXP 131
92841: AND
92842: IFFALSE 92954
92844: GO 92846
92846: DISABLE
92847: LD_INT 0
92849: PPUSH
92850: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
92851: LD_ADDR_VAR 0 2
92855: PUSH
92856: LD_INT 22
92858: PUSH
92859: LD_OWVAR 2
92863: PUSH
92864: EMPTY
92865: LIST
92866: LIST
92867: PUSH
92868: LD_INT 2
92870: PUSH
92871: LD_INT 30
92873: PUSH
92874: LD_INT 27
92876: PUSH
92877: EMPTY
92878: LIST
92879: LIST
92880: PUSH
92881: LD_INT 30
92883: PUSH
92884: LD_INT 26
92886: PUSH
92887: EMPTY
92888: LIST
92889: LIST
92890: PUSH
92891: LD_INT 30
92893: PUSH
92894: LD_INT 28
92896: PUSH
92897: EMPTY
92898: LIST
92899: LIST
92900: PUSH
92901: EMPTY
92902: LIST
92903: LIST
92904: LIST
92905: LIST
92906: PUSH
92907: EMPTY
92908: LIST
92909: LIST
92910: PPUSH
92911: CALL_OW 69
92915: ST_TO_ADDR
// if not tmp then
92916: LD_VAR 0 2
92920: NOT
92921: IFFALSE 92925
// exit ;
92923: GO 92954
// for i in tmp do
92925: LD_ADDR_VAR 0 1
92929: PUSH
92930: LD_VAR 0 2
92934: PUSH
92935: FOR_IN
92936: IFFALSE 92952
// SetLives ( i , 1 ) ;
92938: LD_VAR 0 1
92942: PPUSH
92943: LD_INT 1
92945: PPUSH
92946: CALL_OW 234
92950: GO 92935
92952: POP
92953: POP
// end ;
92954: PPOPN 2
92956: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
92957: LD_EXP 83
92961: PUSH
92962: LD_EXP 132
92966: AND
92967: IFFALSE 93241
92969: GO 92971
92971: DISABLE
92972: LD_INT 0
92974: PPUSH
92975: PPUSH
92976: PPUSH
// begin i := rand ( 1 , 7 ) ;
92977: LD_ADDR_VAR 0 1
92981: PUSH
92982: LD_INT 1
92984: PPUSH
92985: LD_INT 7
92987: PPUSH
92988: CALL_OW 12
92992: ST_TO_ADDR
// case i of 1 :
92993: LD_VAR 0 1
92997: PUSH
92998: LD_INT 1
93000: DOUBLE
93001: EQUAL
93002: IFTRUE 93006
93004: GO 93016
93006: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
93007: LD_STRING earthquake(getX(game), 0, 32)
93009: PPUSH
93010: CALL_OW 559
93014: GO 93241
93016: LD_INT 2
93018: DOUBLE
93019: EQUAL
93020: IFTRUE 93024
93022: GO 93038
93024: POP
// begin ToLua ( displayStucuk(); ) ;
93025: LD_STRING displayStucuk();
93027: PPUSH
93028: CALL_OW 559
// ResetFog ;
93032: CALL_OW 335
// end ; 3 :
93036: GO 93241
93038: LD_INT 3
93040: DOUBLE
93041: EQUAL
93042: IFTRUE 93046
93044: GO 93150
93046: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
93047: LD_ADDR_VAR 0 2
93051: PUSH
93052: LD_INT 22
93054: PUSH
93055: LD_OWVAR 2
93059: PUSH
93060: EMPTY
93061: LIST
93062: LIST
93063: PUSH
93064: LD_INT 25
93066: PUSH
93067: LD_INT 1
93069: PUSH
93070: EMPTY
93071: LIST
93072: LIST
93073: PUSH
93074: EMPTY
93075: LIST
93076: LIST
93077: PPUSH
93078: CALL_OW 69
93082: ST_TO_ADDR
// if not tmp then
93083: LD_VAR 0 2
93087: NOT
93088: IFFALSE 93092
// exit ;
93090: GO 93241
// un := tmp [ rand ( 1 , tmp ) ] ;
93092: LD_ADDR_VAR 0 3
93096: PUSH
93097: LD_VAR 0 2
93101: PUSH
93102: LD_INT 1
93104: PPUSH
93105: LD_VAR 0 2
93109: PPUSH
93110: CALL_OW 12
93114: ARRAY
93115: ST_TO_ADDR
// if Crawls ( un ) then
93116: LD_VAR 0 3
93120: PPUSH
93121: CALL_OW 318
93125: IFFALSE 93136
// ComWalk ( un ) ;
93127: LD_VAR 0 3
93131: PPUSH
93132: CALL_OW 138
// SetClass ( un , class_mortar ) ;
93136: LD_VAR 0 3
93140: PPUSH
93141: LD_INT 8
93143: PPUSH
93144: CALL_OW 336
// end ; 4 :
93148: GO 93241
93150: LD_INT 4
93152: DOUBLE
93153: EQUAL
93154: IFTRUE 93158
93156: GO 93219
93158: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
93159: LD_ADDR_VAR 0 2
93163: PUSH
93164: LD_INT 22
93166: PUSH
93167: LD_OWVAR 2
93171: PUSH
93172: EMPTY
93173: LIST
93174: LIST
93175: PUSH
93176: LD_INT 30
93178: PUSH
93179: LD_INT 29
93181: PUSH
93182: EMPTY
93183: LIST
93184: LIST
93185: PUSH
93186: EMPTY
93187: LIST
93188: LIST
93189: PPUSH
93190: CALL_OW 69
93194: ST_TO_ADDR
// if not tmp then
93195: LD_VAR 0 2
93199: NOT
93200: IFFALSE 93204
// exit ;
93202: GO 93241
// DestroyUnit ( tmp [ 1 ] ) ;
93204: LD_VAR 0 2
93208: PUSH
93209: LD_INT 1
93211: ARRAY
93212: PPUSH
93213: CALL_OW 65
// end ; 5 .. 7 :
93217: GO 93241
93219: LD_INT 5
93221: DOUBLE
93222: GREATEREQUAL
93223: IFFALSE 93231
93225: LD_INT 7
93227: DOUBLE
93228: LESSEQUAL
93229: IFTRUE 93233
93231: GO 93240
93233: POP
// StreamSibBomb ; end ;
93234: CALL 89491 0 0
93238: GO 93241
93240: POP
// end ;
93241: PPOPN 3
93243: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
93244: LD_EXP 83
93248: PUSH
93249: LD_EXP 133
93253: AND
93254: IFFALSE 93410
93256: GO 93258
93258: DISABLE
93259: LD_INT 0
93261: PPUSH
93262: PPUSH
93263: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
93264: LD_ADDR_VAR 0 2
93268: PUSH
93269: LD_INT 81
93271: PUSH
93272: LD_OWVAR 2
93276: PUSH
93277: EMPTY
93278: LIST
93279: LIST
93280: PUSH
93281: LD_INT 2
93283: PUSH
93284: LD_INT 21
93286: PUSH
93287: LD_INT 1
93289: PUSH
93290: EMPTY
93291: LIST
93292: LIST
93293: PUSH
93294: LD_INT 21
93296: PUSH
93297: LD_INT 2
93299: PUSH
93300: EMPTY
93301: LIST
93302: LIST
93303: PUSH
93304: EMPTY
93305: LIST
93306: LIST
93307: LIST
93308: PUSH
93309: EMPTY
93310: LIST
93311: LIST
93312: PPUSH
93313: CALL_OW 69
93317: ST_TO_ADDR
// if not tmp then
93318: LD_VAR 0 2
93322: NOT
93323: IFFALSE 93327
// exit ;
93325: GO 93410
// p := 0 ;
93327: LD_ADDR_VAR 0 3
93331: PUSH
93332: LD_INT 0
93334: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
93335: LD_INT 35
93337: PPUSH
93338: CALL_OW 67
// p := p + 1 ;
93342: LD_ADDR_VAR 0 3
93346: PUSH
93347: LD_VAR 0 3
93351: PUSH
93352: LD_INT 1
93354: PLUS
93355: ST_TO_ADDR
// for i in tmp do
93356: LD_ADDR_VAR 0 1
93360: PUSH
93361: LD_VAR 0 2
93365: PUSH
93366: FOR_IN
93367: IFFALSE 93398
// if GetLives ( i ) < 1000 then
93369: LD_VAR 0 1
93373: PPUSH
93374: CALL_OW 256
93378: PUSH
93379: LD_INT 1000
93381: LESS
93382: IFFALSE 93396
// SetLives ( i , 1000 ) ;
93384: LD_VAR 0 1
93388: PPUSH
93389: LD_INT 1000
93391: PPUSH
93392: CALL_OW 234
93396: GO 93366
93398: POP
93399: POP
// until p > 20 ;
93400: LD_VAR 0 3
93404: PUSH
93405: LD_INT 20
93407: GREATER
93408: IFFALSE 93335
// end ;
93410: PPOPN 3
93412: END
// every 0 0$1 trigger StreamModeActive and sTime do
93413: LD_EXP 83
93417: PUSH
93418: LD_EXP 134
93422: AND
93423: IFFALSE 93458
93425: GO 93427
93427: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
93428: LD_INT 28
93430: PPUSH
93431: LD_OWVAR 2
93435: PPUSH
93436: LD_INT 2
93438: PPUSH
93439: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
93443: LD_INT 30
93445: PPUSH
93446: LD_OWVAR 2
93450: PPUSH
93451: LD_INT 2
93453: PPUSH
93454: CALL_OW 322
// end ;
93458: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
93459: LD_EXP 83
93463: PUSH
93464: LD_EXP 135
93468: AND
93469: IFFALSE 93590
93471: GO 93473
93473: DISABLE
93474: LD_INT 0
93476: PPUSH
93477: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
93478: LD_ADDR_VAR 0 2
93482: PUSH
93483: LD_INT 22
93485: PUSH
93486: LD_OWVAR 2
93490: PUSH
93491: EMPTY
93492: LIST
93493: LIST
93494: PUSH
93495: LD_INT 21
93497: PUSH
93498: LD_INT 1
93500: PUSH
93501: EMPTY
93502: LIST
93503: LIST
93504: PUSH
93505: LD_INT 3
93507: PUSH
93508: LD_INT 23
93510: PUSH
93511: LD_INT 0
93513: PUSH
93514: EMPTY
93515: LIST
93516: LIST
93517: PUSH
93518: EMPTY
93519: LIST
93520: LIST
93521: PUSH
93522: EMPTY
93523: LIST
93524: LIST
93525: LIST
93526: PPUSH
93527: CALL_OW 69
93531: ST_TO_ADDR
// if not tmp then
93532: LD_VAR 0 2
93536: NOT
93537: IFFALSE 93541
// exit ;
93539: GO 93590
// for i in tmp do
93541: LD_ADDR_VAR 0 1
93545: PUSH
93546: LD_VAR 0 2
93550: PUSH
93551: FOR_IN
93552: IFFALSE 93588
// begin if Crawls ( i ) then
93554: LD_VAR 0 1
93558: PPUSH
93559: CALL_OW 318
93563: IFFALSE 93574
// ComWalk ( i ) ;
93565: LD_VAR 0 1
93569: PPUSH
93570: CALL_OW 138
// SetClass ( i , 2 ) ;
93574: LD_VAR 0 1
93578: PPUSH
93579: LD_INT 2
93581: PPUSH
93582: CALL_OW 336
// end ;
93586: GO 93551
93588: POP
93589: POP
// end ;
93590: PPOPN 2
93592: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
93593: LD_EXP 83
93597: PUSH
93598: LD_EXP 136
93602: AND
93603: IFFALSE 93884
93605: GO 93607
93607: DISABLE
93608: LD_INT 0
93610: PPUSH
93611: PPUSH
93612: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
93613: LD_OWVAR 2
93617: PPUSH
93618: LD_INT 9
93620: PPUSH
93621: LD_INT 1
93623: PPUSH
93624: LD_INT 1
93626: PPUSH
93627: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
93631: LD_INT 9
93633: PPUSH
93634: LD_OWVAR 2
93638: PPUSH
93639: CALL_OW 343
// uc_side := 9 ;
93643: LD_ADDR_OWVAR 20
93647: PUSH
93648: LD_INT 9
93650: ST_TO_ADDR
// uc_nation := 2 ;
93651: LD_ADDR_OWVAR 21
93655: PUSH
93656: LD_INT 2
93658: ST_TO_ADDR
// hc_name := Dark Warrior ;
93659: LD_ADDR_OWVAR 26
93663: PUSH
93664: LD_STRING Dark Warrior
93666: ST_TO_ADDR
// hc_gallery :=  ;
93667: LD_ADDR_OWVAR 33
93671: PUSH
93672: LD_STRING 
93674: ST_TO_ADDR
// hc_noskilllimit := true ;
93675: LD_ADDR_OWVAR 76
93679: PUSH
93680: LD_INT 1
93682: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
93683: LD_ADDR_OWVAR 31
93687: PUSH
93688: LD_INT 30
93690: PUSH
93691: LD_INT 30
93693: PUSH
93694: LD_INT 30
93696: PUSH
93697: LD_INT 30
93699: PUSH
93700: EMPTY
93701: LIST
93702: LIST
93703: LIST
93704: LIST
93705: ST_TO_ADDR
// un := CreateHuman ;
93706: LD_ADDR_VAR 0 3
93710: PUSH
93711: CALL_OW 44
93715: ST_TO_ADDR
// hc_noskilllimit := false ;
93716: LD_ADDR_OWVAR 76
93720: PUSH
93721: LD_INT 0
93723: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
93724: LD_VAR 0 3
93728: PPUSH
93729: LD_INT 1
93731: PPUSH
93732: CALL_OW 51
// p := 0 ;
93736: LD_ADDR_VAR 0 2
93740: PUSH
93741: LD_INT 0
93743: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
93744: LD_INT 35
93746: PPUSH
93747: CALL_OW 67
// p := p + 1 ;
93751: LD_ADDR_VAR 0 2
93755: PUSH
93756: LD_VAR 0 2
93760: PUSH
93761: LD_INT 1
93763: PLUS
93764: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
93765: LD_VAR 0 3
93769: PPUSH
93770: CALL_OW 256
93774: PUSH
93775: LD_INT 1000
93777: LESS
93778: IFFALSE 93792
// SetLives ( un , 1000 ) ;
93780: LD_VAR 0 3
93784: PPUSH
93785: LD_INT 1000
93787: PPUSH
93788: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
93792: LD_VAR 0 3
93796: PPUSH
93797: LD_INT 81
93799: PUSH
93800: LD_OWVAR 2
93804: PUSH
93805: EMPTY
93806: LIST
93807: LIST
93808: PUSH
93809: LD_INT 91
93811: PUSH
93812: LD_VAR 0 3
93816: PUSH
93817: LD_INT 30
93819: PUSH
93820: EMPTY
93821: LIST
93822: LIST
93823: LIST
93824: PUSH
93825: EMPTY
93826: LIST
93827: LIST
93828: PPUSH
93829: CALL_OW 69
93833: PPUSH
93834: LD_VAR 0 3
93838: PPUSH
93839: CALL_OW 74
93843: PPUSH
93844: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
93848: LD_VAR 0 2
93852: PUSH
93853: LD_INT 60
93855: GREATER
93856: PUSH
93857: LD_VAR 0 3
93861: PPUSH
93862: CALL_OW 301
93866: OR
93867: IFFALSE 93744
// if un then
93869: LD_VAR 0 3
93873: IFFALSE 93884
// RemoveUnit ( un ) ;
93875: LD_VAR 0 3
93879: PPUSH
93880: CALL_OW 64
// end ;
93884: PPOPN 3
93886: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
93887: LD_INT 0
93889: PPUSH
// case cmd of 301 :
93890: LD_VAR 0 1
93894: PUSH
93895: LD_INT 301
93897: DOUBLE
93898: EQUAL
93899: IFTRUE 93903
93901: GO 93935
93903: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
93904: LD_VAR 0 6
93908: PPUSH
93909: LD_VAR 0 7
93913: PPUSH
93914: LD_VAR 0 8
93918: PPUSH
93919: LD_VAR 0 4
93923: PPUSH
93924: LD_VAR 0 5
93928: PPUSH
93929: CALL 95136 0 5
93933: GO 94056
93935: LD_INT 302
93937: DOUBLE
93938: EQUAL
93939: IFTRUE 93943
93941: GO 93980
93943: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
93944: LD_VAR 0 6
93948: PPUSH
93949: LD_VAR 0 7
93953: PPUSH
93954: LD_VAR 0 8
93958: PPUSH
93959: LD_VAR 0 9
93963: PPUSH
93964: LD_VAR 0 4
93968: PPUSH
93969: LD_VAR 0 5
93973: PPUSH
93974: CALL 95227 0 6
93978: GO 94056
93980: LD_INT 303
93982: DOUBLE
93983: EQUAL
93984: IFTRUE 93988
93986: GO 94025
93988: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
93989: LD_VAR 0 6
93993: PPUSH
93994: LD_VAR 0 7
93998: PPUSH
93999: LD_VAR 0 8
94003: PPUSH
94004: LD_VAR 0 9
94008: PPUSH
94009: LD_VAR 0 4
94013: PPUSH
94014: LD_VAR 0 5
94018: PPUSH
94019: CALL 94061 0 6
94023: GO 94056
94025: LD_INT 304
94027: DOUBLE
94028: EQUAL
94029: IFTRUE 94033
94031: GO 94055
94033: POP
// hHackTeleport ( unit , x , y ) ; end ;
94034: LD_VAR 0 2
94038: PPUSH
94039: LD_VAR 0 4
94043: PPUSH
94044: LD_VAR 0 5
94048: PPUSH
94049: CALL 95820 0 3
94053: GO 94056
94055: POP
// end ;
94056: LD_VAR 0 12
94060: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
94061: LD_INT 0
94063: PPUSH
94064: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
94065: LD_VAR 0 1
94069: PUSH
94070: LD_INT 1
94072: LESS
94073: PUSH
94074: LD_VAR 0 1
94078: PUSH
94079: LD_INT 3
94081: GREATER
94082: OR
94083: PUSH
94084: LD_VAR 0 5
94088: PPUSH
94089: LD_VAR 0 6
94093: PPUSH
94094: CALL_OW 428
94098: OR
94099: IFFALSE 94103
// exit ;
94101: GO 94823
// uc_side := your_side ;
94103: LD_ADDR_OWVAR 20
94107: PUSH
94108: LD_OWVAR 2
94112: ST_TO_ADDR
// uc_nation := nation ;
94113: LD_ADDR_OWVAR 21
94117: PUSH
94118: LD_VAR 0 1
94122: ST_TO_ADDR
// bc_level = 1 ;
94123: LD_ADDR_OWVAR 43
94127: PUSH
94128: LD_INT 1
94130: ST_TO_ADDR
// case btype of 1 :
94131: LD_VAR 0 2
94135: PUSH
94136: LD_INT 1
94138: DOUBLE
94139: EQUAL
94140: IFTRUE 94144
94142: GO 94155
94144: POP
// bc_type := b_depot ; 2 :
94145: LD_ADDR_OWVAR 42
94149: PUSH
94150: LD_INT 0
94152: ST_TO_ADDR
94153: GO 94767
94155: LD_INT 2
94157: DOUBLE
94158: EQUAL
94159: IFTRUE 94163
94161: GO 94174
94163: POP
// bc_type := b_warehouse ; 3 :
94164: LD_ADDR_OWVAR 42
94168: PUSH
94169: LD_INT 1
94171: ST_TO_ADDR
94172: GO 94767
94174: LD_INT 3
94176: DOUBLE
94177: EQUAL
94178: IFTRUE 94182
94180: GO 94193
94182: POP
// bc_type := b_lab ; 4 .. 9 :
94183: LD_ADDR_OWVAR 42
94187: PUSH
94188: LD_INT 6
94190: ST_TO_ADDR
94191: GO 94767
94193: LD_INT 4
94195: DOUBLE
94196: GREATEREQUAL
94197: IFFALSE 94205
94199: LD_INT 9
94201: DOUBLE
94202: LESSEQUAL
94203: IFTRUE 94207
94205: GO 94259
94207: POP
// begin bc_type := b_lab_half ;
94208: LD_ADDR_OWVAR 42
94212: PUSH
94213: LD_INT 7
94215: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
94216: LD_ADDR_OWVAR 44
94220: PUSH
94221: LD_INT 10
94223: PUSH
94224: LD_INT 11
94226: PUSH
94227: LD_INT 12
94229: PUSH
94230: LD_INT 15
94232: PUSH
94233: LD_INT 14
94235: PUSH
94236: LD_INT 13
94238: PUSH
94239: EMPTY
94240: LIST
94241: LIST
94242: LIST
94243: LIST
94244: LIST
94245: LIST
94246: PUSH
94247: LD_VAR 0 2
94251: PUSH
94252: LD_INT 3
94254: MINUS
94255: ARRAY
94256: ST_TO_ADDR
// end ; 10 .. 13 :
94257: GO 94767
94259: LD_INT 10
94261: DOUBLE
94262: GREATEREQUAL
94263: IFFALSE 94271
94265: LD_INT 13
94267: DOUBLE
94268: LESSEQUAL
94269: IFTRUE 94273
94271: GO 94350
94273: POP
// begin bc_type := b_lab_full ;
94274: LD_ADDR_OWVAR 42
94278: PUSH
94279: LD_INT 8
94281: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
94282: LD_ADDR_OWVAR 44
94286: PUSH
94287: LD_INT 10
94289: PUSH
94290: LD_INT 12
94292: PUSH
94293: LD_INT 14
94295: PUSH
94296: LD_INT 13
94298: PUSH
94299: EMPTY
94300: LIST
94301: LIST
94302: LIST
94303: LIST
94304: PUSH
94305: LD_VAR 0 2
94309: PUSH
94310: LD_INT 9
94312: MINUS
94313: ARRAY
94314: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
94315: LD_ADDR_OWVAR 45
94319: PUSH
94320: LD_INT 11
94322: PUSH
94323: LD_INT 15
94325: PUSH
94326: LD_INT 12
94328: PUSH
94329: LD_INT 15
94331: PUSH
94332: EMPTY
94333: LIST
94334: LIST
94335: LIST
94336: LIST
94337: PUSH
94338: LD_VAR 0 2
94342: PUSH
94343: LD_INT 9
94345: MINUS
94346: ARRAY
94347: ST_TO_ADDR
// end ; 14 :
94348: GO 94767
94350: LD_INT 14
94352: DOUBLE
94353: EQUAL
94354: IFTRUE 94358
94356: GO 94369
94358: POP
// bc_type := b_workshop ; 15 :
94359: LD_ADDR_OWVAR 42
94363: PUSH
94364: LD_INT 2
94366: ST_TO_ADDR
94367: GO 94767
94369: LD_INT 15
94371: DOUBLE
94372: EQUAL
94373: IFTRUE 94377
94375: GO 94388
94377: POP
// bc_type := b_factory ; 16 :
94378: LD_ADDR_OWVAR 42
94382: PUSH
94383: LD_INT 3
94385: ST_TO_ADDR
94386: GO 94767
94388: LD_INT 16
94390: DOUBLE
94391: EQUAL
94392: IFTRUE 94396
94394: GO 94407
94396: POP
// bc_type := b_ext_gun ; 17 :
94397: LD_ADDR_OWVAR 42
94401: PUSH
94402: LD_INT 17
94404: ST_TO_ADDR
94405: GO 94767
94407: LD_INT 17
94409: DOUBLE
94410: EQUAL
94411: IFTRUE 94415
94413: GO 94443
94415: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
94416: LD_ADDR_OWVAR 42
94420: PUSH
94421: LD_INT 19
94423: PUSH
94424: LD_INT 23
94426: PUSH
94427: LD_INT 19
94429: PUSH
94430: EMPTY
94431: LIST
94432: LIST
94433: LIST
94434: PUSH
94435: LD_VAR 0 1
94439: ARRAY
94440: ST_TO_ADDR
94441: GO 94767
94443: LD_INT 18
94445: DOUBLE
94446: EQUAL
94447: IFTRUE 94451
94449: GO 94462
94451: POP
// bc_type := b_ext_radar ; 19 :
94452: LD_ADDR_OWVAR 42
94456: PUSH
94457: LD_INT 20
94459: ST_TO_ADDR
94460: GO 94767
94462: LD_INT 19
94464: DOUBLE
94465: EQUAL
94466: IFTRUE 94470
94468: GO 94481
94470: POP
// bc_type := b_ext_radio ; 20 :
94471: LD_ADDR_OWVAR 42
94475: PUSH
94476: LD_INT 22
94478: ST_TO_ADDR
94479: GO 94767
94481: LD_INT 20
94483: DOUBLE
94484: EQUAL
94485: IFTRUE 94489
94487: GO 94500
94489: POP
// bc_type := b_ext_siberium ; 21 :
94490: LD_ADDR_OWVAR 42
94494: PUSH
94495: LD_INT 21
94497: ST_TO_ADDR
94498: GO 94767
94500: LD_INT 21
94502: DOUBLE
94503: EQUAL
94504: IFTRUE 94508
94506: GO 94519
94508: POP
// bc_type := b_ext_computer ; 22 :
94509: LD_ADDR_OWVAR 42
94513: PUSH
94514: LD_INT 24
94516: ST_TO_ADDR
94517: GO 94767
94519: LD_INT 22
94521: DOUBLE
94522: EQUAL
94523: IFTRUE 94527
94525: GO 94538
94527: POP
// bc_type := b_ext_track ; 23 :
94528: LD_ADDR_OWVAR 42
94532: PUSH
94533: LD_INT 16
94535: ST_TO_ADDR
94536: GO 94767
94538: LD_INT 23
94540: DOUBLE
94541: EQUAL
94542: IFTRUE 94546
94544: GO 94557
94546: POP
// bc_type := b_ext_laser ; 24 :
94547: LD_ADDR_OWVAR 42
94551: PUSH
94552: LD_INT 25
94554: ST_TO_ADDR
94555: GO 94767
94557: LD_INT 24
94559: DOUBLE
94560: EQUAL
94561: IFTRUE 94565
94563: GO 94576
94565: POP
// bc_type := b_control_tower ; 25 :
94566: LD_ADDR_OWVAR 42
94570: PUSH
94571: LD_INT 36
94573: ST_TO_ADDR
94574: GO 94767
94576: LD_INT 25
94578: DOUBLE
94579: EQUAL
94580: IFTRUE 94584
94582: GO 94595
94584: POP
// bc_type := b_breastwork ; 26 :
94585: LD_ADDR_OWVAR 42
94589: PUSH
94590: LD_INT 31
94592: ST_TO_ADDR
94593: GO 94767
94595: LD_INT 26
94597: DOUBLE
94598: EQUAL
94599: IFTRUE 94603
94601: GO 94614
94603: POP
// bc_type := b_bunker ; 27 :
94604: LD_ADDR_OWVAR 42
94608: PUSH
94609: LD_INT 32
94611: ST_TO_ADDR
94612: GO 94767
94614: LD_INT 27
94616: DOUBLE
94617: EQUAL
94618: IFTRUE 94622
94620: GO 94633
94622: POP
// bc_type := b_turret ; 28 :
94623: LD_ADDR_OWVAR 42
94627: PUSH
94628: LD_INT 33
94630: ST_TO_ADDR
94631: GO 94767
94633: LD_INT 28
94635: DOUBLE
94636: EQUAL
94637: IFTRUE 94641
94639: GO 94652
94641: POP
// bc_type := b_armoury ; 29 :
94642: LD_ADDR_OWVAR 42
94646: PUSH
94647: LD_INT 4
94649: ST_TO_ADDR
94650: GO 94767
94652: LD_INT 29
94654: DOUBLE
94655: EQUAL
94656: IFTRUE 94660
94658: GO 94671
94660: POP
// bc_type := b_barracks ; 30 :
94661: LD_ADDR_OWVAR 42
94665: PUSH
94666: LD_INT 5
94668: ST_TO_ADDR
94669: GO 94767
94671: LD_INT 30
94673: DOUBLE
94674: EQUAL
94675: IFTRUE 94679
94677: GO 94690
94679: POP
// bc_type := b_solar_power ; 31 :
94680: LD_ADDR_OWVAR 42
94684: PUSH
94685: LD_INT 27
94687: ST_TO_ADDR
94688: GO 94767
94690: LD_INT 31
94692: DOUBLE
94693: EQUAL
94694: IFTRUE 94698
94696: GO 94709
94698: POP
// bc_type := b_oil_power ; 32 :
94699: LD_ADDR_OWVAR 42
94703: PUSH
94704: LD_INT 26
94706: ST_TO_ADDR
94707: GO 94767
94709: LD_INT 32
94711: DOUBLE
94712: EQUAL
94713: IFTRUE 94717
94715: GO 94728
94717: POP
// bc_type := b_siberite_power ; 33 :
94718: LD_ADDR_OWVAR 42
94722: PUSH
94723: LD_INT 28
94725: ST_TO_ADDR
94726: GO 94767
94728: LD_INT 33
94730: DOUBLE
94731: EQUAL
94732: IFTRUE 94736
94734: GO 94747
94736: POP
// bc_type := b_oil_mine ; 34 :
94737: LD_ADDR_OWVAR 42
94741: PUSH
94742: LD_INT 29
94744: ST_TO_ADDR
94745: GO 94767
94747: LD_INT 34
94749: DOUBLE
94750: EQUAL
94751: IFTRUE 94755
94753: GO 94766
94755: POP
// bc_type := b_siberite_mine ; end ;
94756: LD_ADDR_OWVAR 42
94760: PUSH
94761: LD_INT 30
94763: ST_TO_ADDR
94764: GO 94767
94766: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
94767: LD_ADDR_VAR 0 8
94771: PUSH
94772: LD_VAR 0 5
94776: PPUSH
94777: LD_VAR 0 6
94781: PPUSH
94782: LD_VAR 0 3
94786: PPUSH
94787: CALL_OW 47
94791: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
94792: LD_OWVAR 42
94796: PUSH
94797: LD_INT 32
94799: PUSH
94800: LD_INT 33
94802: PUSH
94803: EMPTY
94804: LIST
94805: LIST
94806: IN
94807: IFFALSE 94823
// PlaceWeaponTurret ( b , weapon ) ;
94809: LD_VAR 0 8
94813: PPUSH
94814: LD_VAR 0 4
94818: PPUSH
94819: CALL_OW 431
// end ;
94823: LD_VAR 0 7
94827: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
94828: LD_INT 0
94830: PPUSH
94831: PPUSH
94832: PPUSH
94833: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
94834: LD_ADDR_VAR 0 4
94838: PUSH
94839: LD_INT 22
94841: PUSH
94842: LD_OWVAR 2
94846: PUSH
94847: EMPTY
94848: LIST
94849: LIST
94850: PUSH
94851: LD_INT 2
94853: PUSH
94854: LD_INT 30
94856: PUSH
94857: LD_INT 0
94859: PUSH
94860: EMPTY
94861: LIST
94862: LIST
94863: PUSH
94864: LD_INT 30
94866: PUSH
94867: LD_INT 1
94869: PUSH
94870: EMPTY
94871: LIST
94872: LIST
94873: PUSH
94874: EMPTY
94875: LIST
94876: LIST
94877: LIST
94878: PUSH
94879: EMPTY
94880: LIST
94881: LIST
94882: PPUSH
94883: CALL_OW 69
94887: ST_TO_ADDR
// if not tmp then
94888: LD_VAR 0 4
94892: NOT
94893: IFFALSE 94897
// exit ;
94895: GO 94956
// for i in tmp do
94897: LD_ADDR_VAR 0 2
94901: PUSH
94902: LD_VAR 0 4
94906: PUSH
94907: FOR_IN
94908: IFFALSE 94954
// for j = 1 to 3 do
94910: LD_ADDR_VAR 0 3
94914: PUSH
94915: DOUBLE
94916: LD_INT 1
94918: DEC
94919: ST_TO_ADDR
94920: LD_INT 3
94922: PUSH
94923: FOR_TO
94924: IFFALSE 94950
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
94926: LD_VAR 0 2
94930: PPUSH
94931: CALL_OW 274
94935: PPUSH
94936: LD_VAR 0 3
94940: PPUSH
94941: LD_INT 99999
94943: PPUSH
94944: CALL_OW 277
94948: GO 94923
94950: POP
94951: POP
94952: GO 94907
94954: POP
94955: POP
// end ;
94956: LD_VAR 0 1
94960: RET
// export function hHackSetLevel10 ; var i , j ; begin
94961: LD_INT 0
94963: PPUSH
94964: PPUSH
94965: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
94966: LD_ADDR_VAR 0 2
94970: PUSH
94971: LD_INT 21
94973: PUSH
94974: LD_INT 1
94976: PUSH
94977: EMPTY
94978: LIST
94979: LIST
94980: PPUSH
94981: CALL_OW 69
94985: PUSH
94986: FOR_IN
94987: IFFALSE 95039
// if IsSelected ( i ) then
94989: LD_VAR 0 2
94993: PPUSH
94994: CALL_OW 306
94998: IFFALSE 95037
// begin for j := 1 to 4 do
95000: LD_ADDR_VAR 0 3
95004: PUSH
95005: DOUBLE
95006: LD_INT 1
95008: DEC
95009: ST_TO_ADDR
95010: LD_INT 4
95012: PUSH
95013: FOR_TO
95014: IFFALSE 95035
// SetSkill ( i , j , 10 ) ;
95016: LD_VAR 0 2
95020: PPUSH
95021: LD_VAR 0 3
95025: PPUSH
95026: LD_INT 10
95028: PPUSH
95029: CALL_OW 237
95033: GO 95013
95035: POP
95036: POP
// end ;
95037: GO 94986
95039: POP
95040: POP
// end ;
95041: LD_VAR 0 1
95045: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
95046: LD_INT 0
95048: PPUSH
95049: PPUSH
95050: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
95051: LD_ADDR_VAR 0 2
95055: PUSH
95056: LD_INT 22
95058: PUSH
95059: LD_OWVAR 2
95063: PUSH
95064: EMPTY
95065: LIST
95066: LIST
95067: PUSH
95068: LD_INT 21
95070: PUSH
95071: LD_INT 1
95073: PUSH
95074: EMPTY
95075: LIST
95076: LIST
95077: PUSH
95078: EMPTY
95079: LIST
95080: LIST
95081: PPUSH
95082: CALL_OW 69
95086: PUSH
95087: FOR_IN
95088: IFFALSE 95129
// begin for j := 1 to 4 do
95090: LD_ADDR_VAR 0 3
95094: PUSH
95095: DOUBLE
95096: LD_INT 1
95098: DEC
95099: ST_TO_ADDR
95100: LD_INT 4
95102: PUSH
95103: FOR_TO
95104: IFFALSE 95125
// SetSkill ( i , j , 10 ) ;
95106: LD_VAR 0 2
95110: PPUSH
95111: LD_VAR 0 3
95115: PPUSH
95116: LD_INT 10
95118: PPUSH
95119: CALL_OW 237
95123: GO 95103
95125: POP
95126: POP
// end ;
95127: GO 95087
95129: POP
95130: POP
// end ;
95131: LD_VAR 0 1
95135: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
95136: LD_INT 0
95138: PPUSH
// uc_side := your_side ;
95139: LD_ADDR_OWVAR 20
95143: PUSH
95144: LD_OWVAR 2
95148: ST_TO_ADDR
// uc_nation := nation ;
95149: LD_ADDR_OWVAR 21
95153: PUSH
95154: LD_VAR 0 1
95158: ST_TO_ADDR
// InitHc ;
95159: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
95163: LD_INT 0
95165: PPUSH
95166: LD_VAR 0 2
95170: PPUSH
95171: LD_VAR 0 3
95175: PPUSH
95176: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
95180: LD_VAR 0 4
95184: PPUSH
95185: LD_VAR 0 5
95189: PPUSH
95190: CALL_OW 428
95194: PUSH
95195: LD_INT 0
95197: EQUAL
95198: IFFALSE 95222
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
95200: CALL_OW 44
95204: PPUSH
95205: LD_VAR 0 4
95209: PPUSH
95210: LD_VAR 0 5
95214: PPUSH
95215: LD_INT 1
95217: PPUSH
95218: CALL_OW 48
// end ;
95222: LD_VAR 0 6
95226: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
95227: LD_INT 0
95229: PPUSH
95230: PPUSH
// uc_side := your_side ;
95231: LD_ADDR_OWVAR 20
95235: PUSH
95236: LD_OWVAR 2
95240: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
95241: LD_VAR 0 1
95245: PUSH
95246: LD_INT 1
95248: PUSH
95249: LD_INT 2
95251: PUSH
95252: LD_INT 3
95254: PUSH
95255: LD_INT 4
95257: PUSH
95258: LD_INT 5
95260: PUSH
95261: EMPTY
95262: LIST
95263: LIST
95264: LIST
95265: LIST
95266: LIST
95267: IN
95268: IFFALSE 95280
// uc_nation := nation_american else
95270: LD_ADDR_OWVAR 21
95274: PUSH
95275: LD_INT 1
95277: ST_TO_ADDR
95278: GO 95323
// if chassis in [ 11 , 12 , 13 , 14 ] then
95280: LD_VAR 0 1
95284: PUSH
95285: LD_INT 11
95287: PUSH
95288: LD_INT 12
95290: PUSH
95291: LD_INT 13
95293: PUSH
95294: LD_INT 14
95296: PUSH
95297: EMPTY
95298: LIST
95299: LIST
95300: LIST
95301: LIST
95302: IN
95303: IFFALSE 95315
// uc_nation := nation_arabian else
95305: LD_ADDR_OWVAR 21
95309: PUSH
95310: LD_INT 2
95312: ST_TO_ADDR
95313: GO 95323
// uc_nation := nation_russian ;
95315: LD_ADDR_OWVAR 21
95319: PUSH
95320: LD_INT 3
95322: ST_TO_ADDR
// vc_chassis := chassis ;
95323: LD_ADDR_OWVAR 37
95327: PUSH
95328: LD_VAR 0 1
95332: ST_TO_ADDR
// vc_engine := engine ;
95333: LD_ADDR_OWVAR 39
95337: PUSH
95338: LD_VAR 0 2
95342: ST_TO_ADDR
// vc_control := control ;
95343: LD_ADDR_OWVAR 38
95347: PUSH
95348: LD_VAR 0 3
95352: ST_TO_ADDR
// vc_weapon := weapon ;
95353: LD_ADDR_OWVAR 40
95357: PUSH
95358: LD_VAR 0 4
95362: ST_TO_ADDR
// un := CreateVehicle ;
95363: LD_ADDR_VAR 0 8
95367: PUSH
95368: CALL_OW 45
95372: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
95373: LD_VAR 0 8
95377: PPUSH
95378: LD_INT 0
95380: PPUSH
95381: LD_INT 5
95383: PPUSH
95384: CALL_OW 12
95388: PPUSH
95389: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
95393: LD_VAR 0 8
95397: PPUSH
95398: LD_VAR 0 5
95402: PPUSH
95403: LD_VAR 0 6
95407: PPUSH
95408: LD_INT 1
95410: PPUSH
95411: CALL_OW 48
// end ;
95415: LD_VAR 0 7
95419: RET
// export hInvincible ; every 1 do
95420: GO 95422
95422: DISABLE
// hInvincible := [ ] ;
95423: LD_ADDR_EXP 137
95427: PUSH
95428: EMPTY
95429: ST_TO_ADDR
95430: END
// every 10 do var i ;
95431: GO 95433
95433: DISABLE
95434: LD_INT 0
95436: PPUSH
// begin enable ;
95437: ENABLE
// if not hInvincible then
95438: LD_EXP 137
95442: NOT
95443: IFFALSE 95447
// exit ;
95445: GO 95491
// for i in hInvincible do
95447: LD_ADDR_VAR 0 1
95451: PUSH
95452: LD_EXP 137
95456: PUSH
95457: FOR_IN
95458: IFFALSE 95489
// if GetLives ( i ) < 1000 then
95460: LD_VAR 0 1
95464: PPUSH
95465: CALL_OW 256
95469: PUSH
95470: LD_INT 1000
95472: LESS
95473: IFFALSE 95487
// SetLives ( i , 1000 ) ;
95475: LD_VAR 0 1
95479: PPUSH
95480: LD_INT 1000
95482: PPUSH
95483: CALL_OW 234
95487: GO 95457
95489: POP
95490: POP
// end ;
95491: PPOPN 1
95493: END
// export function hHackInvincible ; var i ; begin
95494: LD_INT 0
95496: PPUSH
95497: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
95498: LD_ADDR_VAR 0 2
95502: PUSH
95503: LD_INT 2
95505: PUSH
95506: LD_INT 21
95508: PUSH
95509: LD_INT 1
95511: PUSH
95512: EMPTY
95513: LIST
95514: LIST
95515: PUSH
95516: LD_INT 21
95518: PUSH
95519: LD_INT 2
95521: PUSH
95522: EMPTY
95523: LIST
95524: LIST
95525: PUSH
95526: EMPTY
95527: LIST
95528: LIST
95529: LIST
95530: PPUSH
95531: CALL_OW 69
95535: PUSH
95536: FOR_IN
95537: IFFALSE 95598
// if IsSelected ( i ) then
95539: LD_VAR 0 2
95543: PPUSH
95544: CALL_OW 306
95548: IFFALSE 95596
// begin if i in hInvincible then
95550: LD_VAR 0 2
95554: PUSH
95555: LD_EXP 137
95559: IN
95560: IFFALSE 95580
// hInvincible := hInvincible diff i else
95562: LD_ADDR_EXP 137
95566: PUSH
95567: LD_EXP 137
95571: PUSH
95572: LD_VAR 0 2
95576: DIFF
95577: ST_TO_ADDR
95578: GO 95596
// hInvincible := hInvincible union i ;
95580: LD_ADDR_EXP 137
95584: PUSH
95585: LD_EXP 137
95589: PUSH
95590: LD_VAR 0 2
95594: UNION
95595: ST_TO_ADDR
// end ;
95596: GO 95536
95598: POP
95599: POP
// end ;
95600: LD_VAR 0 1
95604: RET
// export function hHackInvisible ; var i , j ; begin
95605: LD_INT 0
95607: PPUSH
95608: PPUSH
95609: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
95610: LD_ADDR_VAR 0 2
95614: PUSH
95615: LD_INT 21
95617: PUSH
95618: LD_INT 1
95620: PUSH
95621: EMPTY
95622: LIST
95623: LIST
95624: PPUSH
95625: CALL_OW 69
95629: PUSH
95630: FOR_IN
95631: IFFALSE 95655
// if IsSelected ( i ) then
95633: LD_VAR 0 2
95637: PPUSH
95638: CALL_OW 306
95642: IFFALSE 95653
// ComForceInvisible ( i ) ;
95644: LD_VAR 0 2
95648: PPUSH
95649: CALL_OW 496
95653: GO 95630
95655: POP
95656: POP
// end ;
95657: LD_VAR 0 1
95661: RET
// export function hHackChangeYourSide ; begin
95662: LD_INT 0
95664: PPUSH
// if your_side = 8 then
95665: LD_OWVAR 2
95669: PUSH
95670: LD_INT 8
95672: EQUAL
95673: IFFALSE 95685
// your_side := 0 else
95675: LD_ADDR_OWVAR 2
95679: PUSH
95680: LD_INT 0
95682: ST_TO_ADDR
95683: GO 95699
// your_side := your_side + 1 ;
95685: LD_ADDR_OWVAR 2
95689: PUSH
95690: LD_OWVAR 2
95694: PUSH
95695: LD_INT 1
95697: PLUS
95698: ST_TO_ADDR
// end ;
95699: LD_VAR 0 1
95703: RET
// export function hHackChangeUnitSide ; var i , j ; begin
95704: LD_INT 0
95706: PPUSH
95707: PPUSH
95708: PPUSH
// for i in all_units do
95709: LD_ADDR_VAR 0 2
95713: PUSH
95714: LD_OWVAR 3
95718: PUSH
95719: FOR_IN
95720: IFFALSE 95798
// if IsSelected ( i ) then
95722: LD_VAR 0 2
95726: PPUSH
95727: CALL_OW 306
95731: IFFALSE 95796
// begin j := GetSide ( i ) ;
95733: LD_ADDR_VAR 0 3
95737: PUSH
95738: LD_VAR 0 2
95742: PPUSH
95743: CALL_OW 255
95747: ST_TO_ADDR
// if j = 8 then
95748: LD_VAR 0 3
95752: PUSH
95753: LD_INT 8
95755: EQUAL
95756: IFFALSE 95768
// j := 0 else
95758: LD_ADDR_VAR 0 3
95762: PUSH
95763: LD_INT 0
95765: ST_TO_ADDR
95766: GO 95782
// j := j + 1 ;
95768: LD_ADDR_VAR 0 3
95772: PUSH
95773: LD_VAR 0 3
95777: PUSH
95778: LD_INT 1
95780: PLUS
95781: ST_TO_ADDR
// SetSide ( i , j ) ;
95782: LD_VAR 0 2
95786: PPUSH
95787: LD_VAR 0 3
95791: PPUSH
95792: CALL_OW 235
// end ;
95796: GO 95719
95798: POP
95799: POP
// end ;
95800: LD_VAR 0 1
95804: RET
// export function hHackFog ; begin
95805: LD_INT 0
95807: PPUSH
// FogOff ( true ) ;
95808: LD_INT 1
95810: PPUSH
95811: CALL_OW 344
// end ;
95815: LD_VAR 0 1
95819: RET
// export function hHackTeleport ( unit , x , y ) ; begin
95820: LD_INT 0
95822: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
95823: LD_VAR 0 1
95827: PPUSH
95828: LD_VAR 0 2
95832: PPUSH
95833: LD_VAR 0 3
95837: PPUSH
95838: LD_INT 1
95840: PPUSH
95841: LD_INT 1
95843: PPUSH
95844: CALL_OW 483
// CenterOnXY ( x , y ) ;
95848: LD_VAR 0 2
95852: PPUSH
95853: LD_VAR 0 3
95857: PPUSH
95858: CALL_OW 84
// end ;
95862: LD_VAR 0 4
95866: RET
