// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 210 0 0
// if debug then
  15: LD_EXP 1
  19: IFFALSE 38
// begin FogOff ( 1 ) ;
  21: LD_INT 1
  23: PPUSH
  24: CALL_OW 344
// Difficulty := 2 ;
  28: LD_ADDR_OWVAR 67
  32: PUSH
  33: LD_INT 2
  35: ST_TO_ADDR
// end else
  36: GO 51
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  38: LD_ADDR_OWVAR 67
  42: PUSH
  43: LD_INT 0
  45: PPUSH
  46: CALL_OW 426
  50: ST_TO_ADDR
// ChangeSideFog ( 4 , 1 ) ;
  51: LD_INT 4
  53: PPUSH
  54: LD_INT 1
  56: PPUSH
  57: CALL_OW 343
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , gensher_ape , 0 ) ;
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 0
  66: PPUSH
  67: LD_INT 5
  69: PPUSH
  70: LD_INT 0
  72: PPUSH
  73: LD_INT 0
  75: PPUSH
  76: LD_INT 0
  78: PPUSH
  79: LD_INT 0
  81: PPUSH
  82: LD_INT 7
  84: PPUSH
  85: LD_INT 0
  87: PPUSH
  88: CALL 45077 0 9
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , powell_ape , 0 ) ;
  92: LD_INT 0
  94: PPUSH
  95: LD_INT 0
  97: PPUSH
  98: LD_INT 3
 100: PPUSH
 101: LD_INT 0
 103: PPUSH
 104: LD_INT 0
 106: PPUSH
 107: LD_INT 0
 109: PPUSH
 110: LD_INT 0
 112: PPUSH
 113: LD_INT 4
 115: PPUSH
 116: LD_INT 0
 118: PPUSH
 119: CALL 45077 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , popov_ape , 0 ) ;
 123: LD_INT 0
 125: PPUSH
 126: LD_INT 0
 128: PPUSH
 129: LD_INT 5
 131: PPUSH
 132: LD_INT 0
 134: PPUSH
 135: LD_INT 0
 137: PPUSH
 138: LD_INT 0
 140: PPUSH
 141: LD_INT 0
 143: PPUSH
 144: LD_INT 11
 146: PPUSH
 147: LD_INT 0
 149: PPUSH
 150: CALL 45077 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , sikorski_ape , 0 ) ;
 154: LD_INT 0
 156: PPUSH
 157: LD_INT 0
 159: PPUSH
 160: LD_INT 5
 162: PPUSH
 163: LD_INT 0
 165: PPUSH
 166: LD_INT 0
 168: PPUSH
 169: LD_INT 0
 171: PPUSH
 172: LD_INT 0
 174: PPUSH
 175: LD_INT 14
 177: PPUSH
 178: LD_INT 0
 180: PPUSH
 181: CALL 45077 0 9
// PrepareGensher ;
 185: CALL 3156 0 0
// PreparePopov ;
 189: CALL 6363 0 0
// PreparePowell ;
 193: CALL 589 0 0
// PrepareSikorski ;
 197: CALL 9051 0 0
// MC_Start ( ) ;
 201: CALL 54369 0 0
// Action ;
 205: CALL 9458 0 0
// end ;
 209: END
// export debug , game , staticMines , arDestroyed , ruDestroyed , loseCounter , powellLoseCounter , powellInTrouble , sikorskiInTrouble ; function InitVariables ; begin
 210: LD_INT 0
 212: PPUSH
// debug := false ;
 213: LD_ADDR_EXP 1
 217: PUSH
 218: LD_INT 0
 220: ST_TO_ADDR
// game := true ;
 221: LD_ADDR_EXP 2
 225: PUSH
 226: LD_INT 1
 228: ST_TO_ADDR
// staticMines := [ ] ;
 229: LD_ADDR_EXP 3
 233: PUSH
 234: EMPTY
 235: ST_TO_ADDR
// arDestroyed := false ;
 236: LD_ADDR_EXP 4
 240: PUSH
 241: LD_INT 0
 243: ST_TO_ADDR
// ruDestroyed := false ;
 244: LD_ADDR_EXP 5
 248: PUSH
 249: LD_INT 0
 251: ST_TO_ADDR
// powellInTrouble := false ;
 252: LD_ADDR_EXP 8
 256: PUSH
 257: LD_INT 0
 259: ST_TO_ADDR
// sikorskiInTrouble := false ;
 260: LD_ADDR_EXP 9
 264: PUSH
 265: LD_INT 0
 267: ST_TO_ADDR
// end ;
 268: LD_VAR 0 1
 272: RET
// export function CustomInitMacro ; begin
 273: LD_INT 0
 275: PPUSH
// InitMC_Gensher ( ) ;
 276: CALL 4290 0 0
// InitMC_Powell ( ) ;
 280: CALL 1511 0 0
// InitMC_Popov ( ) ;
 284: CALL 7521 0 0
// end ;
 288: LD_VAR 0 1
 292: RET
// every 0 0$10 do var cr , time , i ;
 293: GO 295
 295: DISABLE
 296: LD_INT 0
 298: PPUSH
 299: PPUSH
 300: PPUSH
// begin time := 0 0$20 ;
 301: LD_ADDR_VAR 0 2
 305: PUSH
 306: LD_INT 700
 308: ST_TO_ADDR
// repeat wait ( time ) ;
 309: LD_VAR 0 2
 313: PPUSH
 314: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
 318: LD_ADDR_VAR 0 1
 322: PUSH
 323: LD_INT 1
 325: PPUSH
 326: LD_INT 5
 328: PPUSH
 329: CALL_OW 12
 333: ST_TO_ADDR
// for i in [ powell_crates , gensher_crates , popov_crates , sikorski_crates ] do
 334: LD_ADDR_VAR 0 3
 338: PUSH
 339: LD_INT 5
 341: PUSH
 342: LD_INT 8
 344: PUSH
 345: LD_INT 12
 347: PUSH
 348: LD_INT 13
 350: PUSH
 351: EMPTY
 352: LIST
 353: LIST
 354: LIST
 355: LIST
 356: PUSH
 357: FOR_IN
 358: IFFALSE 412
// begin if GetResourceArea ( i , mat_cans ) < 40 then
 360: LD_VAR 0 3
 364: PPUSH
 365: LD_INT 1
 367: PPUSH
 368: CALL_OW 287
 372: PUSH
 373: LD_INT 40
 375: LESS
 376: IFFALSE 395
// CreateCratesArea ( cr , i , true ) ;
 378: LD_VAR 0 1
 382: PPUSH
 383: LD_VAR 0 3
 387: PPUSH
 388: LD_INT 1
 390: PPUSH
 391: CALL_OW 55
// wait ( rand ( 0 0$5 , 0 0$15 ) ) ;
 395: LD_INT 175
 397: PPUSH
 398: LD_INT 525
 400: PPUSH
 401: CALL_OW 12
 405: PPUSH
 406: CALL_OW 67
// end ;
 410: GO 357
 412: POP
 413: POP
// time := time + 0 0$2 ;
 414: LD_ADDR_VAR 0 2
 418: PUSH
 419: LD_VAR 0 2
 423: PUSH
 424: LD_INT 70
 426: PLUS
 427: ST_TO_ADDR
// if time > 0 0$35 then
 428: LD_VAR 0 2
 432: PUSH
 433: LD_INT 1225
 435: GREATER
 436: IFFALSE 446
// time := 0 0$25 ;
 438: LD_ADDR_VAR 0 2
 442: PUSH
 443: LD_INT 875
 445: ST_TO_ADDR
// until not game ;
 446: LD_EXP 2
 450: NOT
 451: IFFALSE 309
// end ;
 453: PPOPN 3
 455: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
 456: LD_INT 3
 458: PUSH
 459: LD_INT 22
 461: PUSH
 462: LD_INT 1
 464: PUSH
 465: EMPTY
 466: LIST
 467: LIST
 468: PUSH
 469: EMPTY
 470: LIST
 471: LIST
 472: PUSH
 473: LD_INT 32
 475: PUSH
 476: LD_INT 1
 478: PUSH
 479: EMPTY
 480: LIST
 481: LIST
 482: PUSH
 483: EMPTY
 484: LIST
 485: LIST
 486: PPUSH
 487: CALL_OW 69
 491: IFFALSE 586
 493: GO 495
 495: DISABLE
 496: LD_INT 0
 498: PPUSH
 499: PPUSH
// begin enable ;
 500: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
 501: LD_ADDR_VAR 0 2
 505: PUSH
 506: LD_INT 3
 508: PUSH
 509: LD_INT 22
 511: PUSH
 512: LD_INT 1
 514: PUSH
 515: EMPTY
 516: LIST
 517: LIST
 518: PUSH
 519: EMPTY
 520: LIST
 521: LIST
 522: PUSH
 523: LD_INT 32
 525: PUSH
 526: LD_INT 1
 528: PUSH
 529: EMPTY
 530: LIST
 531: LIST
 532: PUSH
 533: EMPTY
 534: LIST
 535: LIST
 536: PPUSH
 537: CALL_OW 69
 541: ST_TO_ADDR
// for i in tmp do
 542: LD_ADDR_VAR 0 1
 546: PUSH
 547: LD_VAR 0 2
 551: PUSH
 552: FOR_IN
 553: IFFALSE 584
// if GetFuel ( i ) < 5 then
 555: LD_VAR 0 1
 559: PPUSH
 560: CALL_OW 261
 564: PUSH
 565: LD_INT 5
 567: LESS
 568: IFFALSE 582
// SetFuel ( i , 5 ) ;
 570: LD_VAR 0 1
 574: PPUSH
 575: LD_INT 5
 577: PPUSH
 578: CALL_OW 240
 582: GO 552
 584: POP
 585: POP
// end ; end_of_file
 586: PPOPN 2
 588: END
// export Powell , powell_side , powellAttackGroup ; export function PreparePowell ; var i , list , b , tmp ; begin
 589: LD_INT 0
 591: PPUSH
 592: PPUSH
 593: PPUSH
 594: PPUSH
 595: PPUSH
// powell_side := 4 ;
 596: LD_ADDR_EXP 11
 600: PUSH
 601: LD_INT 4
 603: ST_TO_ADDR
// uc_side := powell_side ;
 604: LD_ADDR_OWVAR 20
 608: PUSH
 609: LD_EXP 11
 613: ST_TO_ADDR
// uc_nation := 1 ;
 614: LD_ADDR_OWVAR 21
 618: PUSH
 619: LD_INT 1
 621: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
 622: LD_ADDR_EXP 10
 626: PUSH
 627: LD_STRING Powell
 629: PPUSH
 630: CALL_OW 25
 634: ST_TO_ADDR
// SetSkill ( Powell , 1 , 7 ) ;
 635: LD_EXP 10
 639: PPUSH
 640: LD_INT 1
 642: PPUSH
 643: LD_INT 7
 645: PPUSH
 646: CALL_OW 237
// SetSkill ( Powell , 2 , 5 ) ;
 650: LD_EXP 10
 654: PPUSH
 655: LD_INT 2
 657: PPUSH
 658: LD_INT 5
 660: PPUSH
 661: CALL_OW 237
// SetSkill ( Powell , 3 , 6 ) ;
 665: LD_EXP 10
 669: PPUSH
 670: LD_INT 3
 672: PPUSH
 673: LD_INT 6
 675: PPUSH
 676: CALL_OW 237
// SetSkill ( Powell , 4 , 4 ) ;
 680: LD_EXP 10
 684: PPUSH
 685: LD_INT 4
 687: PPUSH
 688: LD_INT 4
 690: PPUSH
 691: CALL_OW 237
// PlaceHumanInUnit ( Powell , us_depot ) ;
 695: LD_EXP 10
 699: PPUSH
 700: LD_INT 4
 702: PPUSH
 703: CALL_OW 52
// list := [ [ b_barracks , 178 , 117 , 2 ] , [ b_oil_mine , 167 , 102 , 0 ] , [ b_lab , 200 , 111 , 4 , b_lab_weapon , b_lab_siberium ] , [ b_factory , 201 , 140 , 4 ] , [ b_solar_power , 206 , 124 , 3 ] , [ b_solar_power , 209 , 128 , 3 ] , [ b_solar_power , 211 , 132 , 3 ] , [ b_siberite_mine , 173 , 83 , 3 ] , [ b_lab , 186 , 103 , 2 , b_lab_computer , b_lab_opto ] , [ b_turret , 173 , 99 , 2 , us_heavy_gun ] , [ b_bunker , 174 , 102 , 2 , us_heavy_gun ] , [ b_bunker , 178 , 100 , 2 , us_heavy_gun ] , [ b_turret , 174 , 108 , 1 , us_rocket_launcher ] , [ b_turret , 182 , 122 , 1 , us_rocket_launcher ] , [ b_control_tower , 194 , 124 , 5 ] , [ b_turret , 184 , 141 , 1 , us_heavy_gun ] , [ b_turret , 183 , 131 , 2 , us_radar ] , [ b_turret , 194 , 146 , 4 , us_rocket_launcher ] , [ b_turret , 190 , 142 , 4 , us_rocket_launcher ] , [ b_siberite_power , 204 , 133 , 3 ] , [ b_solar_power , 201 , 133 , 3 ] , [ b_siberite_power , 199 , 119 , 5 ] ] ;
 707: LD_ADDR_VAR 0 3
 711: PUSH
 712: LD_INT 5
 714: PUSH
 715: LD_INT 178
 717: PUSH
 718: LD_INT 117
 720: PUSH
 721: LD_INT 2
 723: PUSH
 724: EMPTY
 725: LIST
 726: LIST
 727: LIST
 728: LIST
 729: PUSH
 730: LD_INT 29
 732: PUSH
 733: LD_INT 167
 735: PUSH
 736: LD_INT 102
 738: PUSH
 739: LD_INT 0
 741: PUSH
 742: EMPTY
 743: LIST
 744: LIST
 745: LIST
 746: LIST
 747: PUSH
 748: LD_INT 6
 750: PUSH
 751: LD_INT 200
 753: PUSH
 754: LD_INT 111
 756: PUSH
 757: LD_INT 4
 759: PUSH
 760: LD_INT 10
 762: PUSH
 763: LD_INT 11
 765: PUSH
 766: EMPTY
 767: LIST
 768: LIST
 769: LIST
 770: LIST
 771: LIST
 772: LIST
 773: PUSH
 774: LD_INT 3
 776: PUSH
 777: LD_INT 201
 779: PUSH
 780: LD_INT 140
 782: PUSH
 783: LD_INT 4
 785: PUSH
 786: EMPTY
 787: LIST
 788: LIST
 789: LIST
 790: LIST
 791: PUSH
 792: LD_INT 27
 794: PUSH
 795: LD_INT 206
 797: PUSH
 798: LD_INT 124
 800: PUSH
 801: LD_INT 3
 803: PUSH
 804: EMPTY
 805: LIST
 806: LIST
 807: LIST
 808: LIST
 809: PUSH
 810: LD_INT 27
 812: PUSH
 813: LD_INT 209
 815: PUSH
 816: LD_INT 128
 818: PUSH
 819: LD_INT 3
 821: PUSH
 822: EMPTY
 823: LIST
 824: LIST
 825: LIST
 826: LIST
 827: PUSH
 828: LD_INT 27
 830: PUSH
 831: LD_INT 211
 833: PUSH
 834: LD_INT 132
 836: PUSH
 837: LD_INT 3
 839: PUSH
 840: EMPTY
 841: LIST
 842: LIST
 843: LIST
 844: LIST
 845: PUSH
 846: LD_INT 30
 848: PUSH
 849: LD_INT 173
 851: PUSH
 852: LD_INT 83
 854: PUSH
 855: LD_INT 3
 857: PUSH
 858: EMPTY
 859: LIST
 860: LIST
 861: LIST
 862: LIST
 863: PUSH
 864: LD_INT 6
 866: PUSH
 867: LD_INT 186
 869: PUSH
 870: LD_INT 103
 872: PUSH
 873: LD_INT 2
 875: PUSH
 876: LD_INT 12
 878: PUSH
 879: LD_INT 15
 881: PUSH
 882: EMPTY
 883: LIST
 884: LIST
 885: LIST
 886: LIST
 887: LIST
 888: LIST
 889: PUSH
 890: LD_INT 33
 892: PUSH
 893: LD_INT 173
 895: PUSH
 896: LD_INT 99
 898: PUSH
 899: LD_INT 2
 901: PUSH
 902: LD_INT 6
 904: PUSH
 905: EMPTY
 906: LIST
 907: LIST
 908: LIST
 909: LIST
 910: LIST
 911: PUSH
 912: LD_INT 32
 914: PUSH
 915: LD_INT 174
 917: PUSH
 918: LD_INT 102
 920: PUSH
 921: LD_INT 2
 923: PUSH
 924: LD_INT 6
 926: PUSH
 927: EMPTY
 928: LIST
 929: LIST
 930: LIST
 931: LIST
 932: LIST
 933: PUSH
 934: LD_INT 32
 936: PUSH
 937: LD_INT 178
 939: PUSH
 940: LD_INT 100
 942: PUSH
 943: LD_INT 2
 945: PUSH
 946: LD_INT 6
 948: PUSH
 949: EMPTY
 950: LIST
 951: LIST
 952: LIST
 953: LIST
 954: LIST
 955: PUSH
 956: LD_INT 33
 958: PUSH
 959: LD_INT 174
 961: PUSH
 962: LD_INT 108
 964: PUSH
 965: LD_INT 1
 967: PUSH
 968: LD_INT 7
 970: PUSH
 971: EMPTY
 972: LIST
 973: LIST
 974: LIST
 975: LIST
 976: LIST
 977: PUSH
 978: LD_INT 33
 980: PUSH
 981: LD_INT 182
 983: PUSH
 984: LD_INT 122
 986: PUSH
 987: LD_INT 1
 989: PUSH
 990: LD_INT 7
 992: PUSH
 993: EMPTY
 994: LIST
 995: LIST
 996: LIST
 997: LIST
 998: LIST
 999: PUSH
1000: LD_INT 36
1002: PUSH
1003: LD_INT 194
1005: PUSH
1006: LD_INT 124
1008: PUSH
1009: LD_INT 5
1011: PUSH
1012: EMPTY
1013: LIST
1014: LIST
1015: LIST
1016: LIST
1017: PUSH
1018: LD_INT 33
1020: PUSH
1021: LD_INT 184
1023: PUSH
1024: LD_INT 141
1026: PUSH
1027: LD_INT 1
1029: PUSH
1030: LD_INT 6
1032: PUSH
1033: EMPTY
1034: LIST
1035: LIST
1036: LIST
1037: LIST
1038: LIST
1039: PUSH
1040: LD_INT 33
1042: PUSH
1043: LD_INT 183
1045: PUSH
1046: LD_INT 131
1048: PUSH
1049: LD_INT 2
1051: PUSH
1052: LD_INT 11
1054: PUSH
1055: EMPTY
1056: LIST
1057: LIST
1058: LIST
1059: LIST
1060: LIST
1061: PUSH
1062: LD_INT 33
1064: PUSH
1065: LD_INT 194
1067: PUSH
1068: LD_INT 146
1070: PUSH
1071: LD_INT 4
1073: PUSH
1074: LD_INT 7
1076: PUSH
1077: EMPTY
1078: LIST
1079: LIST
1080: LIST
1081: LIST
1082: LIST
1083: PUSH
1084: LD_INT 33
1086: PUSH
1087: LD_INT 190
1089: PUSH
1090: LD_INT 142
1092: PUSH
1093: LD_INT 4
1095: PUSH
1096: LD_INT 7
1098: PUSH
1099: EMPTY
1100: LIST
1101: LIST
1102: LIST
1103: LIST
1104: LIST
1105: PUSH
1106: LD_INT 28
1108: PUSH
1109: LD_INT 204
1111: PUSH
1112: LD_INT 133
1114: PUSH
1115: LD_INT 3
1117: PUSH
1118: EMPTY
1119: LIST
1120: LIST
1121: LIST
1122: LIST
1123: PUSH
1124: LD_INT 27
1126: PUSH
1127: LD_INT 201
1129: PUSH
1130: LD_INT 133
1132: PUSH
1133: LD_INT 3
1135: PUSH
1136: EMPTY
1137: LIST
1138: LIST
1139: LIST
1140: LIST
1141: PUSH
1142: LD_INT 28
1144: PUSH
1145: LD_INT 199
1147: PUSH
1148: LD_INT 119
1150: PUSH
1151: LD_INT 5
1153: PUSH
1154: EMPTY
1155: LIST
1156: LIST
1157: LIST
1158: LIST
1159: PUSH
1160: EMPTY
1161: LIST
1162: LIST
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: LIST
1168: LIST
1169: LIST
1170: LIST
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: LIST
1180: LIST
1181: LIST
1182: LIST
1183: ST_TO_ADDR
// for i in list do
1184: LD_ADDR_VAR 0 2
1188: PUSH
1189: LD_VAR 0 3
1193: PUSH
1194: FOR_IN
1195: IFFALSE 1373
// begin uc_side := 4 ;
1197: LD_ADDR_OWVAR 20
1201: PUSH
1202: LD_INT 4
1204: ST_TO_ADDR
// uc_nation := 1 ;
1205: LD_ADDR_OWVAR 21
1209: PUSH
1210: LD_INT 1
1212: ST_TO_ADDR
// bc_type := i [ 1 ] ;
1213: LD_ADDR_OWVAR 42
1217: PUSH
1218: LD_VAR 0 2
1222: PUSH
1223: LD_INT 1
1225: ARRAY
1226: ST_TO_ADDR
// bc_kind1 := - 1 ;
1227: LD_ADDR_OWVAR 44
1231: PUSH
1232: LD_INT 1
1234: NEG
1235: ST_TO_ADDR
// bc_kind2 := - 1 ;
1236: LD_ADDR_OWVAR 45
1240: PUSH
1241: LD_INT 1
1243: NEG
1244: ST_TO_ADDR
// if i [ 1 ] = b_lab then
1245: LD_VAR 0 2
1249: PUSH
1250: LD_INT 1
1252: ARRAY
1253: PUSH
1254: LD_INT 6
1256: EQUAL
1257: IFFALSE 1295
// begin bc_type := b_lab_full ;
1259: LD_ADDR_OWVAR 42
1263: PUSH
1264: LD_INT 8
1266: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
1267: LD_ADDR_OWVAR 44
1271: PUSH
1272: LD_VAR 0 2
1276: PUSH
1277: LD_INT 5
1279: ARRAY
1280: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
1281: LD_ADDR_OWVAR 45
1285: PUSH
1286: LD_VAR 0 2
1290: PUSH
1291: LD_INT 6
1293: ARRAY
1294: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1295: LD_ADDR_VAR 0 4
1299: PUSH
1300: LD_VAR 0 2
1304: PUSH
1305: LD_INT 2
1307: ARRAY
1308: PPUSH
1309: LD_VAR 0 2
1313: PUSH
1314: LD_INT 3
1316: ARRAY
1317: PPUSH
1318: LD_VAR 0 2
1322: PUSH
1323: LD_INT 4
1325: ARRAY
1326: PPUSH
1327: CALL_OW 47
1331: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
1332: LD_VAR 0 2
1336: PUSH
1337: LD_INT 1
1339: ARRAY
1340: PUSH
1341: LD_INT 33
1343: PUSH
1344: LD_INT 32
1346: PUSH
1347: EMPTY
1348: LIST
1349: LIST
1350: IN
1351: IFFALSE 1371
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
1353: LD_VAR 0 4
1357: PPUSH
1358: LD_VAR 0 2
1362: PUSH
1363: LD_INT 5
1365: ARRAY
1366: PPUSH
1367: CALL_OW 431
// end ;
1371: GO 1194
1373: POP
1374: POP
// tmp := PrepareBase ( us_depot , powell_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 5500 , 500 , 0 ] , [ 6 , 6 , 6 , 6 ] ) ;
1375: LD_ADDR_VAR 0 5
1379: PUSH
1380: LD_INT 4
1382: PPUSH
1383: LD_INT 1
1385: PPUSH
1386: LD_STRING 
1388: PPUSH
1389: LD_INT 8
1391: PUSH
1392: LD_INT 7
1394: PUSH
1395: LD_INT 6
1397: PUSH
1398: EMPTY
1399: LIST
1400: LIST
1401: LIST
1402: PUSH
1403: LD_OWVAR 67
1407: ARRAY
1408: PPUSH
1409: LD_INT 5500
1411: PUSH
1412: LD_INT 500
1414: PUSH
1415: LD_INT 0
1417: PUSH
1418: EMPTY
1419: LIST
1420: LIST
1421: LIST
1422: PPUSH
1423: LD_INT 6
1425: PUSH
1426: LD_INT 6
1428: PUSH
1429: LD_INT 6
1431: PUSH
1432: LD_INT 6
1434: PUSH
1435: EMPTY
1436: LIST
1437: LIST
1438: LIST
1439: LIST
1440: PPUSH
1441: CALL 19478 0 6
1445: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , tmp union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) ) ;
1446: LD_ADDR_EXP 23
1450: PUSH
1451: LD_EXP 23
1455: PPUSH
1456: LD_INT 1
1458: PPUSH
1459: LD_VAR 0 5
1463: PUSH
1464: LD_INT 22
1466: PUSH
1467: LD_INT 4
1469: PUSH
1470: EMPTY
1471: LIST
1472: LIST
1473: PUSH
1474: LD_INT 21
1476: PUSH
1477: LD_INT 3
1479: PUSH
1480: EMPTY
1481: LIST
1482: LIST
1483: PUSH
1484: EMPTY
1485: LIST
1486: LIST
1487: PPUSH
1488: CALL_OW 69
1492: UNION
1493: PPUSH
1494: CALL_OW 1
1498: ST_TO_ADDR
// powellAttackGroup := [ ] ;
1499: LD_ADDR_EXP 12
1503: PUSH
1504: EMPTY
1505: ST_TO_ADDR
// end ;
1506: LD_VAR 0 1
1510: RET
// export function InitMC_Powell ( ) ; begin
1511: LD_INT 0
1513: PPUSH
// MC_SetScanArea ( 1 , powell_base ) ;
1514: LD_INT 1
1516: PPUSH
1517: LD_INT 1
1519: PPUSH
1520: CALL 77693 0 2
// MC_SetParkingArea ( 1 , powell_parking ) ;
1524: LD_INT 1
1526: PPUSH
1527: LD_INT 6
1529: PPUSH
1530: CALL 77637 0 2
// MC_SetDepositsXY ( 1 , [ [ 167 , 102 , 0 ] , [ 173 , 83 , 1 ] , [ 171 , 141 , 0 ] , [ 178 , 148 , 1 ] ] ) ;
1534: LD_INT 1
1536: PPUSH
1537: LD_INT 167
1539: PUSH
1540: LD_INT 102
1542: PUSH
1543: LD_INT 0
1545: PUSH
1546: EMPTY
1547: LIST
1548: LIST
1549: LIST
1550: PUSH
1551: LD_INT 173
1553: PUSH
1554: LD_INT 83
1556: PUSH
1557: LD_INT 1
1559: PUSH
1560: EMPTY
1561: LIST
1562: LIST
1563: LIST
1564: PUSH
1565: LD_INT 171
1567: PUSH
1568: LD_INT 141
1570: PUSH
1571: LD_INT 0
1573: PUSH
1574: EMPTY
1575: LIST
1576: LIST
1577: LIST
1578: PUSH
1579: LD_INT 178
1581: PUSH
1582: LD_INT 148
1584: PUSH
1585: LD_INT 1
1587: PUSH
1588: EMPTY
1589: LIST
1590: LIST
1591: LIST
1592: PUSH
1593: EMPTY
1594: LIST
1595: LIST
1596: LIST
1597: LIST
1598: PPUSH
1599: CALL 76696 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ us_radar , us_heavy_gun , us_rocket_launcher ] ) ;
1603: LD_INT 1
1605: PPUSH
1606: LD_INT 11
1608: PUSH
1609: LD_INT 6
1611: PUSH
1612: LD_INT 7
1614: PUSH
1615: EMPTY
1616: LIST
1617: LIST
1618: LIST
1619: PPUSH
1620: CALL 77525 0 2
// MC_SetCratesArea ( 1 , powell_crates ) ;
1624: LD_INT 1
1626: PPUSH
1627: LD_INT 5
1629: PPUSH
1630: CALL 77207 0 2
// MC_SetTame ( 1 , powell_ape ) ;
1634: LD_INT 1
1636: PPUSH
1637: LD_INT 4
1639: PPUSH
1640: CALL 76938 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
1644: LD_INT 1
1646: PPUSH
1647: LD_INT 4
1649: PPUSH
1650: CALL 76557 0 2
// MC_SetProduceList ( 1 , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ] ) ;
1654: LD_INT 1
1656: PPUSH
1657: LD_INT 3
1659: PUSH
1660: LD_INT 1
1662: PUSH
1663: LD_INT 2
1665: PUSH
1666: LD_INT 5
1668: PUSH
1669: EMPTY
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: PUSH
1675: LD_INT 4
1677: PUSH
1678: LD_INT 1
1680: PUSH
1681: LD_INT 2
1683: PUSH
1684: LD_INT 6
1686: PUSH
1687: EMPTY
1688: LIST
1689: LIST
1690: LIST
1691: LIST
1692: PUSH
1693: LD_INT 4
1695: PUSH
1696: LD_INT 1
1698: PUSH
1699: LD_INT 2
1701: PUSH
1702: LD_INT 7
1704: PUSH
1705: EMPTY
1706: LIST
1707: LIST
1708: LIST
1709: LIST
1710: PUSH
1711: LD_INT 4
1713: PUSH
1714: LD_INT 1
1716: PUSH
1717: LD_INT 2
1719: PUSH
1720: LD_INT 6
1722: PUSH
1723: EMPTY
1724: LIST
1725: LIST
1726: LIST
1727: LIST
1728: PUSH
1729: EMPTY
1730: LIST
1731: LIST
1732: LIST
1733: LIST
1734: PPUSH
1735: CALL 76372 0 2
// MC_SetFactoryExtension ( 1 , 201 , 140 , 4 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1739: LD_INT 1
1741: PPUSH
1742: LD_INT 201
1744: PPUSH
1745: LD_INT 140
1747: PPUSH
1748: LD_INT 4
1750: PPUSH
1751: LD_INT 19
1753: PUSH
1754: LD_INT 16
1756: PUSH
1757: LD_INT 17
1759: PUSH
1760: LD_INT 18
1762: PUSH
1763: LD_INT 22
1765: PUSH
1766: EMPTY
1767: LIST
1768: LIST
1769: LIST
1770: LIST
1771: LIST
1772: PPUSH
1773: CALL 77319 0 5
// end ;
1777: LD_VAR 0 1
1781: RET
// every 8 8$00 + 2 2$00 trigger IsOk ( us_depot ) do var i , base , tmp , attackers , amount ;
1782: LD_INT 4
1784: PPUSH
1785: CALL_OW 302
1789: IFFALSE 2449
1791: GO 1793
1793: DISABLE
1794: LD_INT 0
1796: PPUSH
1797: PPUSH
1798: PPUSH
1799: PPUSH
1800: PPUSH
// begin enable ;
1801: ENABLE
// base := 1 ;
1802: LD_ADDR_VAR 0 2
1806: PUSH
1807: LD_INT 1
1809: ST_TO_ADDR
// tmp := [ [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ] ;
1810: LD_ADDR_VAR 0 3
1814: PUSH
1815: LD_INT 4
1817: PUSH
1818: LD_INT 1
1820: PUSH
1821: LD_INT 2
1823: PUSH
1824: LD_INT 6
1826: PUSH
1827: EMPTY
1828: LIST
1829: LIST
1830: LIST
1831: LIST
1832: PUSH
1833: LD_INT 4
1835: PUSH
1836: LD_INT 1
1838: PUSH
1839: LD_INT 2
1841: PUSH
1842: LD_INT 6
1844: PUSH
1845: EMPTY
1846: LIST
1847: LIST
1848: LIST
1849: LIST
1850: PUSH
1851: LD_INT 3
1853: PUSH
1854: LD_INT 1
1856: PUSH
1857: LD_INT 2
1859: PUSH
1860: LD_INT 7
1862: PUSH
1863: EMPTY
1864: LIST
1865: LIST
1866: LIST
1867: LIST
1868: PUSH
1869: LD_INT 3
1871: PUSH
1872: LD_INT 1
1874: PUSH
1875: LD_INT 2
1877: PUSH
1878: LD_INT 7
1880: PUSH
1881: EMPTY
1882: LIST
1883: LIST
1884: LIST
1885: LIST
1886: PUSH
1887: EMPTY
1888: LIST
1889: LIST
1890: LIST
1891: LIST
1892: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
1893: LD_ADDR_VAR 0 5
1897: PUSH
1898: LD_VAR 0 5
1902: PUSH
1903: LD_OWVAR 1
1907: PUSH
1908: LD_INT 21000
1910: DIV
1911: PLUS
1912: ST_TO_ADDR
// if amount > 8 then
1913: LD_VAR 0 5
1917: PUSH
1918: LD_INT 8
1920: GREATER
1921: IFFALSE 1931
// amount := 8 ;
1923: LD_ADDR_VAR 0 5
1927: PUSH
1928: LD_INT 8
1930: ST_TO_ADDR
// for i = 1 to amount do
1931: LD_ADDR_VAR 0 1
1935: PUSH
1936: DOUBLE
1937: LD_INT 1
1939: DEC
1940: ST_TO_ADDR
1941: LD_VAR 0 5
1945: PUSH
1946: FOR_TO
1947: IFFALSE 2031
// tmp := Insert ( tmp , tmp + 1 , [ [ us_medium_tracked , us_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ us_rocket_launcher , us_double_gun ] [ rand ( 1 , 2 ) ] ] ) ;
1949: LD_ADDR_VAR 0 3
1953: PUSH
1954: LD_VAR 0 3
1958: PPUSH
1959: LD_VAR 0 3
1963: PUSH
1964: LD_INT 1
1966: PLUS
1967: PPUSH
1968: LD_INT 3
1970: PUSH
1971: LD_INT 4
1973: PUSH
1974: EMPTY
1975: LIST
1976: LIST
1977: PUSH
1978: LD_INT 1
1980: PPUSH
1981: LD_INT 2
1983: PPUSH
1984: CALL_OW 12
1988: ARRAY
1989: PUSH
1990: LD_INT 1
1992: PUSH
1993: LD_INT 2
1995: PUSH
1996: LD_INT 7
1998: PUSH
1999: LD_INT 5
2001: PUSH
2002: EMPTY
2003: LIST
2004: LIST
2005: PUSH
2006: LD_INT 1
2008: PPUSH
2009: LD_INT 2
2011: PPUSH
2012: CALL_OW 12
2016: ARRAY
2017: PUSH
2018: EMPTY
2019: LIST
2020: LIST
2021: LIST
2022: LIST
2023: PPUSH
2024: CALL_OW 2
2028: ST_TO_ADDR
2029: GO 1946
2031: POP
2032: POP
// MC_InsertProduceList ( base , tmp ) ;
2033: LD_VAR 0 2
2037: PPUSH
2038: LD_VAR 0 3
2042: PPUSH
2043: CALL 76420 0 2
// repeat wait ( 0 0$1 ) ;
2047: LD_INT 35
2049: PPUSH
2050: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
2054: LD_VAR 0 2
2058: PPUSH
2059: LD_INT 1
2061: PPUSH
2062: CALL 77838 0 2
2066: PUSH
2067: LD_VAR 0 5
2071: GREATEREQUAL
2072: IFFALSE 2047
// wait ( 0 0$30 ) ;
2074: LD_INT 1050
2076: PPUSH
2077: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , us_bulldozer ] ] ) ;
2081: LD_ADDR_VAR 0 4
2085: PUSH
2086: LD_EXP 42
2090: PUSH
2091: LD_VAR 0 2
2095: ARRAY
2096: PUSH
2097: LD_EXP 42
2101: PUSH
2102: LD_VAR 0 2
2106: ARRAY
2107: PPUSH
2108: LD_INT 2
2110: PUSH
2111: LD_INT 34
2113: PUSH
2114: LD_INT 12
2116: PUSH
2117: EMPTY
2118: LIST
2119: LIST
2120: PUSH
2121: LD_INT 34
2123: PUSH
2124: LD_INT 13
2126: PUSH
2127: EMPTY
2128: LIST
2129: LIST
2130: PUSH
2131: LD_INT 34
2133: PUSH
2134: LD_INT 14
2136: PUSH
2137: EMPTY
2138: LIST
2139: LIST
2140: PUSH
2141: EMPTY
2142: LIST
2143: LIST
2144: LIST
2145: LIST
2146: PPUSH
2147: CALL_OW 72
2151: DIFF
2152: ST_TO_ADDR
// if not attackers then
2153: LD_VAR 0 4
2157: NOT
2158: IFFALSE 2162
// exit ;
2160: GO 2449
// DialogPowellsAttack ;
2162: CALL 9589 0 0
// powellAttackGroup := attackers ;
2166: LD_ADDR_EXP 12
2170: PUSH
2171: LD_VAR 0 4
2175: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
2176: LD_ADDR_EXP 42
2180: PUSH
2181: LD_EXP 42
2185: PPUSH
2186: LD_VAR 0 2
2190: PPUSH
2191: LD_EXP 42
2195: PUSH
2196: LD_VAR 0 2
2200: ARRAY
2201: PUSH
2202: LD_VAR 0 4
2206: DIFF
2207: PPUSH
2208: CALL_OW 1
2212: ST_TO_ADDR
// if sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 4 ] ) then
2213: LD_EXP 9
2217: PUSH
2218: LD_INT 16
2220: PPUSH
2221: LD_INT 81
2223: PUSH
2224: LD_INT 4
2226: PUSH
2227: EMPTY
2228: LIST
2229: LIST
2230: PPUSH
2231: CALL_OW 70
2235: AND
2236: IFFALSE 2255
// ComAgressiveMove ( attackers , 135 , 21 ) else
2238: LD_VAR 0 4
2242: PPUSH
2243: LD_INT 135
2245: PPUSH
2246: LD_INT 21
2248: PPUSH
2249: CALL_OW 114
2253: GO 2270
// ComAgressiveMove ( attackers , 146 , 103 ) ;
2255: LD_VAR 0 4
2259: PPUSH
2260: LD_INT 146
2262: PPUSH
2263: LD_INT 103
2265: PPUSH
2266: CALL_OW 114
// wait ( 0 0$5 ) ;
2270: LD_INT 175
2272: PPUSH
2273: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
2277: LD_INT 35
2279: PPUSH
2280: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
2284: LD_VAR 0 4
2288: PPUSH
2289: LD_INT 60
2291: PUSH
2292: EMPTY
2293: LIST
2294: PPUSH
2295: CALL_OW 72
2299: NOT
2300: IFFALSE 2277
// if FilterAllUnits ( [ f_side , 3 ] ) then
2302: LD_INT 22
2304: PUSH
2305: LD_INT 3
2307: PUSH
2308: EMPTY
2309: LIST
2310: LIST
2311: PPUSH
2312: CALL_OW 69
2316: IFFALSE 2335
// ComAgressiveMove ( attackers , 102 , 116 ) else
2318: LD_VAR 0 4
2322: PPUSH
2323: LD_INT 102
2325: PPUSH
2326: LD_INT 116
2328: PPUSH
2329: CALL_OW 114
2333: GO 2350
// ComAgressiveMove ( attackers , 66 , 41 ) ;
2335: LD_VAR 0 4
2339: PPUSH
2340: LD_INT 66
2342: PPUSH
2343: LD_INT 41
2345: PPUSH
2346: CALL_OW 114
// wait ( 0 0$10 ) ;
2350: LD_INT 350
2352: PPUSH
2353: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
2357: LD_INT 35
2359: PPUSH
2360: CALL_OW 67
// for i in attackers do
2364: LD_ADDR_VAR 0 1
2368: PUSH
2369: LD_VAR 0 4
2373: PUSH
2374: FOR_IN
2375: IFFALSE 2425
// if not HasTask ( i ) then
2377: LD_VAR 0 1
2381: PPUSH
2382: CALL_OW 314
2386: NOT
2387: IFFALSE 2423
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) ;
2389: LD_VAR 0 1
2393: PPUSH
2394: LD_INT 81
2396: PUSH
2397: LD_INT 4
2399: PUSH
2400: EMPTY
2401: LIST
2402: LIST
2403: PPUSH
2404: CALL_OW 69
2408: PPUSH
2409: LD_VAR 0 1
2413: PPUSH
2414: CALL_OW 74
2418: PPUSH
2419: CALL_OW 115
2423: GO 2374
2425: POP
2426: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
2427: LD_VAR 0 4
2431: PPUSH
2432: LD_INT 50
2434: PUSH
2435: EMPTY
2436: LIST
2437: PPUSH
2438: CALL_OW 72
2442: NOT
2443: IFFALSE 2357
// DialogPowellsAttackFailed ;
2445: CALL 9854 0 0
// end ;
2449: PPOPN 5
2451: END
// every 0 0$2 do var vehicles , mechs , i ;
2452: GO 2454
2454: DISABLE
2455: LD_INT 0
2457: PPUSH
2458: PPUSH
2459: PPUSH
// begin enable ;
2460: ENABLE
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] , [ f_distxy , 191 , 140 , 10 ] ] ) ;
2461: LD_ADDR_VAR 0 1
2465: PUSH
2466: LD_INT 22
2468: PUSH
2469: LD_INT 1
2471: PUSH
2472: EMPTY
2473: LIST
2474: LIST
2475: PUSH
2476: LD_INT 21
2478: PUSH
2479: LD_INT 2
2481: PUSH
2482: EMPTY
2483: LIST
2484: LIST
2485: PUSH
2486: LD_INT 3
2488: PUSH
2489: LD_INT 24
2491: PUSH
2492: LD_INT 1000
2494: PUSH
2495: EMPTY
2496: LIST
2497: LIST
2498: PUSH
2499: EMPTY
2500: LIST
2501: LIST
2502: PUSH
2503: LD_INT 92
2505: PUSH
2506: LD_INT 191
2508: PUSH
2509: LD_INT 140
2511: PUSH
2512: LD_INT 10
2514: PUSH
2515: EMPTY
2516: LIST
2517: LIST
2518: LIST
2519: LIST
2520: PUSH
2521: EMPTY
2522: LIST
2523: LIST
2524: LIST
2525: LIST
2526: PPUSH
2527: CALL_OW 69
2531: ST_TO_ADDR
// mechs := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 3 ] ] ) ;
2532: LD_ADDR_VAR 0 2
2536: PUSH
2537: LD_INT 22
2539: PUSH
2540: LD_INT 4
2542: PUSH
2543: EMPTY
2544: LIST
2545: LIST
2546: PUSH
2547: LD_INT 25
2549: PUSH
2550: LD_INT 3
2552: PUSH
2553: EMPTY
2554: LIST
2555: LIST
2556: PUSH
2557: EMPTY
2558: LIST
2559: LIST
2560: PPUSH
2561: CALL_OW 69
2565: ST_TO_ADDR
// if not mechs then
2566: LD_VAR 0 2
2570: NOT
2571: IFFALSE 2575
// exit ;
2573: GO 2749
// if mc_remote_driver [ 1 ] then
2575: LD_EXP 63
2579: PUSH
2580: LD_INT 1
2582: ARRAY
2583: IFFALSE 2605
// mechs := mechs diff mc_remote_driver [ 1 ] ;
2585: LD_ADDR_VAR 0 2
2589: PUSH
2590: LD_VAR 0 2
2594: PUSH
2595: LD_EXP 63
2599: PUSH
2600: LD_INT 1
2602: ARRAY
2603: DIFF
2604: ST_TO_ADDR
// if not mechs then
2605: LD_VAR 0 2
2609: NOT
2610: IFFALSE 2614
// exit ;
2612: GO 2749
// if vehicles then
2614: LD_VAR 0 1
2618: IFFALSE 2706
// begin for i in mechs do
2620: LD_ADDR_VAR 0 3
2624: PUSH
2625: LD_VAR 0 2
2629: PUSH
2630: FOR_IN
2631: IFFALSE 2702
// begin if GetTag ( i ) <> 120 then
2633: LD_VAR 0 3
2637: PPUSH
2638: CALL_OW 110
2642: PUSH
2643: LD_INT 120
2645: NONEQUAL
2646: IFFALSE 2660
// SetTag ( i , 120 ) ;
2648: LD_VAR 0 3
2652: PPUSH
2653: LD_INT 120
2655: PPUSH
2656: CALL_OW 109
// if IsInUnit ( i ) then
2660: LD_VAR 0 3
2664: PPUSH
2665: CALL_OW 310
2669: IFFALSE 2682
// ComExitBuilding ( i ) else
2671: LD_VAR 0 3
2675: PPUSH
2676: CALL_OW 122
2680: GO 2700
// ComRepairVehicle ( i , vehicles [ 1 ] ) ;
2682: LD_VAR 0 3
2686: PPUSH
2687: LD_VAR 0 1
2691: PUSH
2692: LD_INT 1
2694: ARRAY
2695: PPUSH
2696: CALL_OW 129
// end ;
2700: GO 2630
2702: POP
2703: POP
// end else
2704: GO 2749
// if FilterByTag ( mechs , 120 ) then
2706: LD_VAR 0 2
2710: PPUSH
2711: LD_INT 120
2713: PPUSH
2714: CALL 45969 0 2
2718: IFFALSE 2749
// begin for i in mechs do
2720: LD_ADDR_VAR 0 3
2724: PUSH
2725: LD_VAR 0 2
2729: PUSH
2730: FOR_IN
2731: IFFALSE 2747
// begin SetTag ( i , 0 ) ;
2733: LD_VAR 0 3
2737: PPUSH
2738: LD_INT 0
2740: PPUSH
2741: CALL_OW 109
// end ;
2745: GO 2730
2747: POP
2748: POP
// end ; end ;
2749: PPOPN 3
2751: END
// every 0 0$2 do var people , sci , i ;
2752: GO 2754
2754: DISABLE
2755: LD_INT 0
2757: PPUSH
2758: PPUSH
2759: PPUSH
// begin enable ;
2760: ENABLE
// people := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] , [ f_distxy , 188 , 112 , 10 ] ] ) ;
2761: LD_ADDR_VAR 0 1
2765: PUSH
2766: LD_INT 22
2768: PUSH
2769: LD_INT 1
2771: PUSH
2772: EMPTY
2773: LIST
2774: LIST
2775: PUSH
2776: LD_INT 21
2778: PUSH
2779: LD_INT 1
2781: PUSH
2782: EMPTY
2783: LIST
2784: LIST
2785: PUSH
2786: LD_INT 3
2788: PUSH
2789: LD_INT 24
2791: PUSH
2792: LD_INT 1000
2794: PUSH
2795: EMPTY
2796: LIST
2797: LIST
2798: PUSH
2799: EMPTY
2800: LIST
2801: LIST
2802: PUSH
2803: LD_INT 92
2805: PUSH
2806: LD_INT 188
2808: PUSH
2809: LD_INT 112
2811: PUSH
2812: LD_INT 10
2814: PUSH
2815: EMPTY
2816: LIST
2817: LIST
2818: LIST
2819: LIST
2820: PUSH
2821: EMPTY
2822: LIST
2823: LIST
2824: LIST
2825: LIST
2826: PPUSH
2827: CALL_OW 69
2831: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 4 ] ] ) ;
2832: LD_ADDR_VAR 0 2
2836: PUSH
2837: LD_INT 22
2839: PUSH
2840: LD_INT 4
2842: PUSH
2843: EMPTY
2844: LIST
2845: LIST
2846: PUSH
2847: LD_INT 25
2849: PUSH
2850: LD_INT 4
2852: PUSH
2853: EMPTY
2854: LIST
2855: LIST
2856: PUSH
2857: EMPTY
2858: LIST
2859: LIST
2860: PPUSH
2861: CALL_OW 69
2865: ST_TO_ADDR
// if not sci then
2866: LD_VAR 0 2
2870: NOT
2871: IFFALSE 2875
// exit ;
2873: GO 3010
// if people then
2875: LD_VAR 0 1
2879: IFFALSE 2967
// begin for i in sci do
2881: LD_ADDR_VAR 0 3
2885: PUSH
2886: LD_VAR 0 2
2890: PUSH
2891: FOR_IN
2892: IFFALSE 2963
// begin if GetTag ( i ) <> 102 then
2894: LD_VAR 0 3
2898: PPUSH
2899: CALL_OW 110
2903: PUSH
2904: LD_INT 102
2906: NONEQUAL
2907: IFFALSE 2921
// SetTag ( i , 102 ) ;
2909: LD_VAR 0 3
2913: PPUSH
2914: LD_INT 102
2916: PPUSH
2917: CALL_OW 109
// if IsInUnit ( i ) then
2921: LD_VAR 0 3
2925: PPUSH
2926: CALL_OW 310
2930: IFFALSE 2943
// ComExitBuilding ( i ) else
2932: LD_VAR 0 3
2936: PPUSH
2937: CALL_OW 122
2941: GO 2961
// ComHeal ( i , people [ 1 ] ) ;
2943: LD_VAR 0 3
2947: PPUSH
2948: LD_VAR 0 1
2952: PUSH
2953: LD_INT 1
2955: ARRAY
2956: PPUSH
2957: CALL_OW 128
// end ;
2961: GO 2891
2963: POP
2964: POP
// end else
2965: GO 3010
// if FilterByTag ( sci , 102 ) then
2967: LD_VAR 0 2
2971: PPUSH
2972: LD_INT 102
2974: PPUSH
2975: CALL 45969 0 2
2979: IFFALSE 3010
// begin for i in sci do
2981: LD_ADDR_VAR 0 3
2985: PUSH
2986: LD_VAR 0 2
2990: PUSH
2991: FOR_IN
2992: IFFALSE 3008
// begin SetTag ( i , 0 ) ;
2994: LD_VAR 0 3
2998: PPUSH
2999: LD_INT 0
3001: PPUSH
3002: CALL_OW 109
// end ;
3006: GO 2991
3008: POP
3009: POP
// end ; end ;
3010: PPOPN 3
3012: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 4 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
3013: LD_INT 22
3015: PUSH
3016: LD_INT 4
3018: PUSH
3019: EMPTY
3020: LIST
3021: LIST
3022: PUSH
3023: LD_INT 33
3025: PUSH
3026: LD_INT 2
3028: PUSH
3029: EMPTY
3030: LIST
3031: LIST
3032: PUSH
3033: LD_INT 50
3035: PUSH
3036: EMPTY
3037: LIST
3038: PUSH
3039: LD_INT 3
3041: PUSH
3042: LD_INT 61
3044: PUSH
3045: EMPTY
3046: LIST
3047: PUSH
3048: EMPTY
3049: LIST
3050: LIST
3051: PUSH
3052: EMPTY
3053: LIST
3054: LIST
3055: LIST
3056: LIST
3057: PPUSH
3058: CALL_OW 69
3062: IFFALSE 3153
3064: GO 3066
3066: DISABLE
3067: LD_INT 0
3069: PPUSH
3070: PPUSH
// begin enable ;
3071: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
3072: LD_ADDR_VAR 0 2
3076: PUSH
3077: LD_INT 22
3079: PUSH
3080: LD_INT 4
3082: PUSH
3083: EMPTY
3084: LIST
3085: LIST
3086: PUSH
3087: LD_INT 33
3089: PUSH
3090: LD_INT 2
3092: PUSH
3093: EMPTY
3094: LIST
3095: LIST
3096: PUSH
3097: LD_INT 50
3099: PUSH
3100: EMPTY
3101: LIST
3102: PUSH
3103: LD_INT 3
3105: PUSH
3106: LD_INT 61
3108: PUSH
3109: EMPTY
3110: LIST
3111: PUSH
3112: EMPTY
3113: LIST
3114: LIST
3115: PUSH
3116: EMPTY
3117: LIST
3118: LIST
3119: LIST
3120: LIST
3121: PPUSH
3122: CALL_OW 69
3126: ST_TO_ADDR
// for i in tmp do
3127: LD_ADDR_VAR 0 1
3131: PUSH
3132: LD_VAR 0 2
3136: PUSH
3137: FOR_IN
3138: IFFALSE 3151
// Connect ( i ) ;
3140: LD_VAR 0 1
3144: PPUSH
3145: CALL 19125 0 1
3149: GO 3137
3151: POP
3152: POP
// end ; end_of_file
3153: PPOPN 2
3155: END
// export Gensher , gensher_side , gensherAttackGroup ; export function PrepareGensher ; var i , b , tmp , un , list ; begin
3156: LD_INT 0
3158: PPUSH
3159: PPUSH
3160: PPUSH
3161: PPUSH
3162: PPUSH
3163: PPUSH
// gensher_side := 2 ;
3164: LD_ADDR_EXP 14
3168: PUSH
3169: LD_INT 2
3171: ST_TO_ADDR
// uc_side := gensher_side ;
3172: LD_ADDR_OWVAR 20
3176: PUSH
3177: LD_EXP 14
3181: ST_TO_ADDR
// uc_nation := 2 ;
3182: LD_ADDR_OWVAR 21
3186: PUSH
3187: LD_INT 2
3189: ST_TO_ADDR
// list := [ [ b_barracks , 42 , 29 , 5 ] , [ b_barracks , 36 , 40 , 5 ] , [ b_lab , 13 , 18 , 1 , b_lab_weapon , b_lab_opto ] , [ b_solar_power , 17 , 3 , 0 ] , [ b_oil_mine , 56 , 23 , 0 ] , [ b_factory , 11 , 7 , 2 ] , [ b_solar_power , 20 , 3 , 0 ] , [ b_solar_power , 23 , 3 , 0 ] , [ b_solar_power , 26 , 3 , 0 ] , [ b_lab , 17 , 27 , 1 , b_lab_biological , b_lab_siberium ] , [ b_bunker , 27 , 44 , 5 , ar_gun ] , [ b_bunker , 41 , 41 , 5 , ar_gun ] , [ b_bunker , 45 , 24 , 5 , ar_rocket_launcher ] , [ b_bunker , 48 , 19 , 5 , ar_rocket_launcher ] , [ b_bunker , 41 , 3 , 4 , ar_rocket_launcher ] , [ b_barracks , 44 , 9 , 4 ] , [ b_siberite_mine , 52 , 40 , 3 ] ] ;
3190: LD_ADDR_VAR 0 6
3194: PUSH
3195: LD_INT 5
3197: PUSH
3198: LD_INT 42
3200: PUSH
3201: LD_INT 29
3203: PUSH
3204: LD_INT 5
3206: PUSH
3207: EMPTY
3208: LIST
3209: LIST
3210: LIST
3211: LIST
3212: PUSH
3213: LD_INT 5
3215: PUSH
3216: LD_INT 36
3218: PUSH
3219: LD_INT 40
3221: PUSH
3222: LD_INT 5
3224: PUSH
3225: EMPTY
3226: LIST
3227: LIST
3228: LIST
3229: LIST
3230: PUSH
3231: LD_INT 6
3233: PUSH
3234: LD_INT 13
3236: PUSH
3237: LD_INT 18
3239: PUSH
3240: LD_INT 1
3242: PUSH
3243: LD_INT 10
3245: PUSH
3246: LD_INT 15
3248: PUSH
3249: EMPTY
3250: LIST
3251: LIST
3252: LIST
3253: LIST
3254: LIST
3255: LIST
3256: PUSH
3257: LD_INT 27
3259: PUSH
3260: LD_INT 17
3262: PUSH
3263: LD_INT 3
3265: PUSH
3266: LD_INT 0
3268: PUSH
3269: EMPTY
3270: LIST
3271: LIST
3272: LIST
3273: LIST
3274: PUSH
3275: LD_INT 29
3277: PUSH
3278: LD_INT 56
3280: PUSH
3281: LD_INT 23
3283: PUSH
3284: LD_INT 0
3286: PUSH
3287: EMPTY
3288: LIST
3289: LIST
3290: LIST
3291: LIST
3292: PUSH
3293: LD_INT 3
3295: PUSH
3296: LD_INT 11
3298: PUSH
3299: LD_INT 7
3301: PUSH
3302: LD_INT 2
3304: PUSH
3305: EMPTY
3306: LIST
3307: LIST
3308: LIST
3309: LIST
3310: PUSH
3311: LD_INT 27
3313: PUSH
3314: LD_INT 20
3316: PUSH
3317: LD_INT 3
3319: PUSH
3320: LD_INT 0
3322: PUSH
3323: EMPTY
3324: LIST
3325: LIST
3326: LIST
3327: LIST
3328: PUSH
3329: LD_INT 27
3331: PUSH
3332: LD_INT 23
3334: PUSH
3335: LD_INT 3
3337: PUSH
3338: LD_INT 0
3340: PUSH
3341: EMPTY
3342: LIST
3343: LIST
3344: LIST
3345: LIST
3346: PUSH
3347: LD_INT 27
3349: PUSH
3350: LD_INT 26
3352: PUSH
3353: LD_INT 3
3355: PUSH
3356: LD_INT 0
3358: PUSH
3359: EMPTY
3360: LIST
3361: LIST
3362: LIST
3363: LIST
3364: PUSH
3365: LD_INT 6
3367: PUSH
3368: LD_INT 17
3370: PUSH
3371: LD_INT 27
3373: PUSH
3374: LD_INT 1
3376: PUSH
3377: LD_INT 13
3379: PUSH
3380: LD_INT 11
3382: PUSH
3383: EMPTY
3384: LIST
3385: LIST
3386: LIST
3387: LIST
3388: LIST
3389: LIST
3390: PUSH
3391: LD_INT 32
3393: PUSH
3394: LD_INT 27
3396: PUSH
3397: LD_INT 44
3399: PUSH
3400: LD_INT 5
3402: PUSH
3403: LD_INT 27
3405: PUSH
3406: EMPTY
3407: LIST
3408: LIST
3409: LIST
3410: LIST
3411: LIST
3412: PUSH
3413: LD_INT 32
3415: PUSH
3416: LD_INT 41
3418: PUSH
3419: LD_INT 41
3421: PUSH
3422: LD_INT 5
3424: PUSH
3425: LD_INT 27
3427: PUSH
3428: EMPTY
3429: LIST
3430: LIST
3431: LIST
3432: LIST
3433: LIST
3434: PUSH
3435: LD_INT 32
3437: PUSH
3438: LD_INT 45
3440: PUSH
3441: LD_INT 24
3443: PUSH
3444: LD_INT 5
3446: PUSH
3447: LD_INT 28
3449: PUSH
3450: EMPTY
3451: LIST
3452: LIST
3453: LIST
3454: LIST
3455: LIST
3456: PUSH
3457: LD_INT 32
3459: PUSH
3460: LD_INT 48
3462: PUSH
3463: LD_INT 19
3465: PUSH
3466: LD_INT 5
3468: PUSH
3469: LD_INT 28
3471: PUSH
3472: EMPTY
3473: LIST
3474: LIST
3475: LIST
3476: LIST
3477: LIST
3478: PUSH
3479: LD_INT 32
3481: PUSH
3482: LD_INT 41
3484: PUSH
3485: LD_INT 3
3487: PUSH
3488: LD_INT 4
3490: PUSH
3491: LD_INT 28
3493: PUSH
3494: EMPTY
3495: LIST
3496: LIST
3497: LIST
3498: LIST
3499: LIST
3500: PUSH
3501: LD_INT 5
3503: PUSH
3504: LD_INT 44
3506: PUSH
3507: LD_INT 9
3509: PUSH
3510: LD_INT 4
3512: PUSH
3513: EMPTY
3514: LIST
3515: LIST
3516: LIST
3517: LIST
3518: PUSH
3519: LD_INT 30
3521: PUSH
3522: LD_INT 52
3524: PUSH
3525: LD_INT 40
3527: PUSH
3528: LD_INT 3
3530: PUSH
3531: EMPTY
3532: LIST
3533: LIST
3534: LIST
3535: LIST
3536: PUSH
3537: EMPTY
3538: LIST
3539: LIST
3540: LIST
3541: LIST
3542: LIST
3543: LIST
3544: LIST
3545: LIST
3546: LIST
3547: LIST
3548: LIST
3549: LIST
3550: LIST
3551: LIST
3552: LIST
3553: LIST
3554: LIST
3555: ST_TO_ADDR
// for i in list do
3556: LD_ADDR_VAR 0 2
3560: PUSH
3561: LD_VAR 0 6
3565: PUSH
3566: FOR_IN
3567: IFFALSE 3745
// begin uc_side := 2 ;
3569: LD_ADDR_OWVAR 20
3573: PUSH
3574: LD_INT 2
3576: ST_TO_ADDR
// uc_nation := 2 ;
3577: LD_ADDR_OWVAR 21
3581: PUSH
3582: LD_INT 2
3584: ST_TO_ADDR
// bc_type := i [ 1 ] ;
3585: LD_ADDR_OWVAR 42
3589: PUSH
3590: LD_VAR 0 2
3594: PUSH
3595: LD_INT 1
3597: ARRAY
3598: ST_TO_ADDR
// bc_kind1 := - 1 ;
3599: LD_ADDR_OWVAR 44
3603: PUSH
3604: LD_INT 1
3606: NEG
3607: ST_TO_ADDR
// bc_kind2 := - 1 ;
3608: LD_ADDR_OWVAR 45
3612: PUSH
3613: LD_INT 1
3615: NEG
3616: ST_TO_ADDR
// if i [ 1 ] = b_lab then
3617: LD_VAR 0 2
3621: PUSH
3622: LD_INT 1
3624: ARRAY
3625: PUSH
3626: LD_INT 6
3628: EQUAL
3629: IFFALSE 3667
// begin bc_type := b_lab_full ;
3631: LD_ADDR_OWVAR 42
3635: PUSH
3636: LD_INT 8
3638: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
3639: LD_ADDR_OWVAR 44
3643: PUSH
3644: LD_VAR 0 2
3648: PUSH
3649: LD_INT 5
3651: ARRAY
3652: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
3653: LD_ADDR_OWVAR 45
3657: PUSH
3658: LD_VAR 0 2
3662: PUSH
3663: LD_INT 6
3665: ARRAY
3666: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
3667: LD_ADDR_VAR 0 3
3671: PUSH
3672: LD_VAR 0 2
3676: PUSH
3677: LD_INT 2
3679: ARRAY
3680: PPUSH
3681: LD_VAR 0 2
3685: PUSH
3686: LD_INT 3
3688: ARRAY
3689: PPUSH
3690: LD_VAR 0 2
3694: PUSH
3695: LD_INT 4
3697: ARRAY
3698: PPUSH
3699: CALL_OW 47
3703: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
3704: LD_VAR 0 2
3708: PUSH
3709: LD_INT 1
3711: ARRAY
3712: PUSH
3713: LD_INT 33
3715: PUSH
3716: LD_INT 32
3718: PUSH
3719: EMPTY
3720: LIST
3721: LIST
3722: IN
3723: IFFALSE 3743
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
3725: LD_VAR 0 3
3729: PPUSH
3730: LD_VAR 0 2
3734: PUSH
3735: LD_INT 5
3737: ARRAY
3738: PPUSH
3739: CALL_OW 431
// end ;
3743: GO 3566
3745: POP
3746: POP
// tmp := PrepareBase ( ar_depot , gensher_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 11500 , 1100 , 60 ] , [ 6 , 6 , 6 , 6 ] ) ;
3747: LD_ADDR_VAR 0 4
3751: PUSH
3752: LD_INT 7
3754: PPUSH
3755: LD_INT 2
3757: PPUSH
3758: LD_STRING 
3760: PPUSH
3761: LD_INT 8
3763: PUSH
3764: LD_INT 7
3766: PUSH
3767: LD_INT 6
3769: PUSH
3770: EMPTY
3771: LIST
3772: LIST
3773: LIST
3774: PUSH
3775: LD_OWVAR 67
3779: ARRAY
3780: PPUSH
3781: LD_INT 11500
3783: PUSH
3784: LD_INT 1100
3786: PUSH
3787: LD_INT 60
3789: PUSH
3790: EMPTY
3791: LIST
3792: LIST
3793: LIST
3794: PPUSH
3795: LD_INT 6
3797: PUSH
3798: LD_INT 6
3800: PUSH
3801: LD_INT 6
3803: PUSH
3804: LD_INT 6
3806: PUSH
3807: EMPTY
3808: LIST
3809: LIST
3810: LIST
3811: LIST
3812: PPUSH
3813: CALL 19478 0 6
3817: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ) ;
3818: LD_ADDR_EXP 23
3822: PUSH
3823: LD_EXP 23
3827: PPUSH
3828: LD_INT 2
3830: PPUSH
3831: LD_VAR 0 4
3835: PUSH
3836: LD_INT 22
3838: PUSH
3839: LD_INT 2
3841: PUSH
3842: EMPTY
3843: LIST
3844: LIST
3845: PUSH
3846: LD_INT 21
3848: PUSH
3849: LD_INT 3
3851: PUSH
3852: EMPTY
3853: LIST
3854: LIST
3855: PUSH
3856: EMPTY
3857: LIST
3858: LIST
3859: PPUSH
3860: CALL_OW 69
3864: UNION
3865: PPUSH
3866: CALL_OW 1
3870: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] ] ) ;
3871: LD_ADDR_VAR 0 4
3875: PUSH
3876: LD_INT 22
3878: PUSH
3879: LD_INT 2
3881: PUSH
3882: EMPTY
3883: LIST
3884: LIST
3885: PUSH
3886: LD_INT 30
3888: PUSH
3889: LD_INT 31
3891: PUSH
3892: EMPTY
3893: LIST
3894: LIST
3895: PUSH
3896: EMPTY
3897: LIST
3898: LIST
3899: PPUSH
3900: CALL_OW 69
3904: ST_TO_ADDR
// for i in tmp do
3905: LD_ADDR_VAR 0 2
3909: PUSH
3910: LD_VAR 0 4
3914: PUSH
3915: FOR_IN
3916: IFFALSE 3986
// begin PrepareHuman ( false , 1 , [ 4 , 3 , 3 ] [ Difficulty ] ) ;
3918: LD_INT 0
3920: PPUSH
3921: LD_INT 1
3923: PPUSH
3924: LD_INT 4
3926: PUSH
3927: LD_INT 3
3929: PUSH
3930: LD_INT 3
3932: PUSH
3933: EMPTY
3934: LIST
3935: LIST
3936: LIST
3937: PUSH
3938: LD_OWVAR 67
3942: ARRAY
3943: PPUSH
3944: CALL_OW 380
// un := CreateHuman ;
3948: LD_ADDR_VAR 0 5
3952: PUSH
3953: CALL_OW 44
3957: ST_TO_ADDR
// SetDir ( un , 1 ) ;
3958: LD_VAR 0 5
3962: PPUSH
3963: LD_INT 1
3965: PPUSH
3966: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3970: LD_VAR 0 5
3974: PPUSH
3975: LD_VAR 0 2
3979: PPUSH
3980: CALL_OW 52
// end ;
3984: GO 3915
3986: POP
3987: POP
// tmp := AreaToList ( gensher_mines , 0 ) ;
3988: LD_ADDR_VAR 0 4
3992: PUSH
3993: LD_INT 15
3995: PPUSH
3996: LD_INT 0
3998: PPUSH
3999: CALL_OW 517
4003: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
4004: LD_ADDR_VAR 0 2
4008: PUSH
4009: DOUBLE
4010: LD_INT 1
4012: DEC
4013: ST_TO_ADDR
4014: LD_VAR 0 4
4018: PUSH
4019: LD_INT 1
4021: ARRAY
4022: PUSH
4023: FOR_TO
4024: IFFALSE 4126
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
4026: LD_VAR 0 4
4030: PUSH
4031: LD_INT 1
4033: ARRAY
4034: PUSH
4035: LD_VAR 0 2
4039: ARRAY
4040: PPUSH
4041: LD_VAR 0 4
4045: PUSH
4046: LD_INT 2
4048: ARRAY
4049: PUSH
4050: LD_VAR 0 2
4054: ARRAY
4055: PPUSH
4056: LD_INT 2
4058: PPUSH
4059: LD_INT 0
4061: PPUSH
4062: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
4066: LD_ADDR_EXP 3
4070: PUSH
4071: LD_EXP 3
4075: PPUSH
4076: LD_EXP 3
4080: PUSH
4081: LD_INT 1
4083: PLUS
4084: PPUSH
4085: LD_VAR 0 4
4089: PUSH
4090: LD_INT 1
4092: ARRAY
4093: PUSH
4094: LD_VAR 0 2
4098: ARRAY
4099: PUSH
4100: LD_VAR 0 4
4104: PUSH
4105: LD_INT 2
4107: ARRAY
4108: PUSH
4109: LD_VAR 0 2
4113: ARRAY
4114: PUSH
4115: EMPTY
4116: LIST
4117: LIST
4118: PPUSH
4119: CALL_OW 2
4123: ST_TO_ADDR
// end ;
4124: GO 4023
4126: POP
4127: POP
// if Difficulty > 1 then
4128: LD_OWVAR 67
4132: PUSH
4133: LD_INT 1
4135: GREATER
4136: IFFALSE 4278
// begin tmp := AreaToList ( gensher_mines2 , 0 ) ;
4138: LD_ADDR_VAR 0 4
4142: PUSH
4143: LD_INT 19
4145: PPUSH
4146: LD_INT 0
4148: PPUSH
4149: CALL_OW 517
4153: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
4154: LD_ADDR_VAR 0 2
4158: PUSH
4159: DOUBLE
4160: LD_INT 1
4162: DEC
4163: ST_TO_ADDR
4164: LD_VAR 0 4
4168: PUSH
4169: LD_INT 1
4171: ARRAY
4172: PUSH
4173: FOR_TO
4174: IFFALSE 4276
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
4176: LD_VAR 0 4
4180: PUSH
4181: LD_INT 1
4183: ARRAY
4184: PUSH
4185: LD_VAR 0 2
4189: ARRAY
4190: PPUSH
4191: LD_VAR 0 4
4195: PUSH
4196: LD_INT 2
4198: ARRAY
4199: PUSH
4200: LD_VAR 0 2
4204: ARRAY
4205: PPUSH
4206: LD_INT 2
4208: PPUSH
4209: LD_INT 0
4211: PPUSH
4212: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
4216: LD_ADDR_EXP 3
4220: PUSH
4221: LD_EXP 3
4225: PPUSH
4226: LD_EXP 3
4230: PUSH
4231: LD_INT 1
4233: PLUS
4234: PPUSH
4235: LD_VAR 0 4
4239: PUSH
4240: LD_INT 1
4242: ARRAY
4243: PUSH
4244: LD_VAR 0 2
4248: ARRAY
4249: PUSH
4250: LD_VAR 0 4
4254: PUSH
4255: LD_INT 2
4257: ARRAY
4258: PUSH
4259: LD_VAR 0 2
4263: ARRAY
4264: PUSH
4265: EMPTY
4266: LIST
4267: LIST
4268: PPUSH
4269: CALL_OW 2
4273: ST_TO_ADDR
// end ;
4274: GO 4173
4276: POP
4277: POP
// end ; gensherAttackGroup := [ ] ;
4278: LD_ADDR_EXP 15
4282: PUSH
4283: EMPTY
4284: ST_TO_ADDR
// end ;
4285: LD_VAR 0 1
4289: RET
// export function InitMC_Gensher ( ) ; begin
4290: LD_INT 0
4292: PPUSH
// MC_SetScanArea ( 2 , gensher_base ) ;
4293: LD_INT 2
4295: PPUSH
4296: LD_INT 2
4298: PPUSH
4299: CALL 77693 0 2
// MC_SetParkingArea ( 2 , gensher_parking ) ;
4303: LD_INT 2
4305: PPUSH
4306: LD_INT 9
4308: PPUSH
4309: CALL 77637 0 2
// MC_SetDepositsXY ( 2 , [ [ 56 , 23 , 0 ] , [ 52 , 40 , 1 ] ] ) ;
4313: LD_INT 2
4315: PPUSH
4316: LD_INT 56
4318: PUSH
4319: LD_INT 23
4321: PUSH
4322: LD_INT 0
4324: PUSH
4325: EMPTY
4326: LIST
4327: LIST
4328: LIST
4329: PUSH
4330: LD_INT 52
4332: PUSH
4333: LD_INT 40
4335: PUSH
4336: LD_INT 1
4338: PUSH
4339: EMPTY
4340: LIST
4341: LIST
4342: LIST
4343: PUSH
4344: EMPTY
4345: LIST
4346: LIST
4347: PPUSH
4348: CALL 76696 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ar_gun , ar_rocket_launcher ] ) ;
4352: LD_INT 2
4354: PPUSH
4355: LD_INT 27
4357: PUSH
4358: LD_INT 28
4360: PUSH
4361: EMPTY
4362: LIST
4363: LIST
4364: PPUSH
4365: CALL 77525 0 2
// MC_SetCratesArea ( 2 , gensher_crates ) ;
4369: LD_INT 2
4371: PPUSH
4372: LD_INT 8
4374: PPUSH
4375: CALL 77207 0 2
// MC_SetTame ( 2 , gensher_ape ) ;
4379: LD_INT 2
4381: PPUSH
4382: LD_INT 7
4384: PPUSH
4385: CALL 76938 0 2
// MC_SetDefenderLimit ( 2 , 4 ) ;
4389: LD_INT 2
4391: PPUSH
4392: LD_INT 4
4394: PPUSH
4395: CALL 76557 0 2
// MC_SetProduceList ( 2 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ) ;
4399: LD_INT 2
4401: PPUSH
4402: LD_INT 13
4404: PUSH
4405: LD_INT 2
4407: PUSH
4408: LD_INT 1
4410: PUSH
4411: LD_INT 31
4413: PUSH
4414: EMPTY
4415: LIST
4416: LIST
4417: LIST
4418: LIST
4419: PUSH
4420: LD_INT 13
4422: PUSH
4423: LD_INT 2
4425: PUSH
4426: LD_INT 1
4428: PUSH
4429: LD_INT 31
4431: PUSH
4432: EMPTY
4433: LIST
4434: LIST
4435: LIST
4436: LIST
4437: PUSH
4438: LD_INT 14
4440: PUSH
4441: LD_INT 1
4443: PUSH
4444: LD_INT 2
4446: PUSH
4447: LD_INT 27
4449: PUSH
4450: EMPTY
4451: LIST
4452: LIST
4453: LIST
4454: LIST
4455: PUSH
4456: LD_INT 14
4458: PUSH
4459: LD_INT 1
4461: PUSH
4462: LD_INT 2
4464: PUSH
4465: LD_INT 27
4467: PUSH
4468: EMPTY
4469: LIST
4470: LIST
4471: LIST
4472: LIST
4473: PUSH
4474: LD_INT 14
4476: PUSH
4477: LD_INT 1
4479: PUSH
4480: LD_INT 2
4482: PUSH
4483: LD_INT 28
4485: PUSH
4486: EMPTY
4487: LIST
4488: LIST
4489: LIST
4490: LIST
4491: PUSH
4492: LD_INT 14
4494: PUSH
4495: LD_INT 1
4497: PUSH
4498: LD_INT 2
4500: PUSH
4501: LD_INT 26
4503: PUSH
4504: EMPTY
4505: LIST
4506: LIST
4507: LIST
4508: LIST
4509: PUSH
4510: EMPTY
4511: LIST
4512: LIST
4513: LIST
4514: LIST
4515: LIST
4516: LIST
4517: PPUSH
4518: CALL 76372 0 2
// MC_SetFactoryExtension ( 2 , 11 , 7 , 2 , [ b_ext_stitch , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
4522: LD_INT 2
4524: PPUSH
4525: LD_INT 11
4527: PPUSH
4528: LD_INT 7
4530: PPUSH
4531: LD_INT 2
4533: PPUSH
4534: LD_INT 23
4536: PUSH
4537: LD_INT 16
4539: PUSH
4540: LD_INT 17
4542: PUSH
4543: LD_INT 18
4545: PUSH
4546: LD_INT 22
4548: PUSH
4549: EMPTY
4550: LIST
4551: LIST
4552: LIST
4553: LIST
4554: LIST
4555: PPUSH
4556: CALL 77319 0 5
// end ;
4560: LD_VAR 0 1
4564: RET
// every 2 trigger staticMines and FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) do var i , j , tmp , x , y ;
4565: LD_EXP 3
4569: PUSH
4570: LD_INT 15
4572: PPUSH
4573: LD_INT 81
4575: PUSH
4576: LD_INT 2
4578: PUSH
4579: EMPTY
4580: LIST
4581: LIST
4582: PPUSH
4583: CALL_OW 70
4587: AND
4588: IFFALSE 4801
4590: GO 4592
4592: DISABLE
4593: LD_INT 0
4595: PPUSH
4596: PPUSH
4597: PPUSH
4598: PPUSH
4599: PPUSH
// begin enable ;
4600: ENABLE
// tmp := FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) ;
4601: LD_ADDR_VAR 0 3
4605: PUSH
4606: LD_INT 15
4608: PPUSH
4609: LD_INT 81
4611: PUSH
4612: LD_INT 2
4614: PUSH
4615: EMPTY
4616: LIST
4617: LIST
4618: PPUSH
4619: CALL_OW 70
4623: ST_TO_ADDR
// if not tmp then
4624: LD_VAR 0 3
4628: NOT
4629: IFFALSE 4633
// exit ;
4631: GO 4801
// for i in tmp do
4633: LD_ADDR_VAR 0 1
4637: PUSH
4638: LD_VAR 0 3
4642: PUSH
4643: FOR_IN
4644: IFFALSE 4799
// begin x := GetX ( i ) ;
4646: LD_ADDR_VAR 0 4
4650: PUSH
4651: LD_VAR 0 1
4655: PPUSH
4656: CALL_OW 250
4660: ST_TO_ADDR
// y := GetY ( i ) ;
4661: LD_ADDR_VAR 0 5
4665: PUSH
4666: LD_VAR 0 1
4670: PPUSH
4671: CALL_OW 251
4675: ST_TO_ADDR
// if MineAtPos ( x , y ) then
4676: LD_VAR 0 4
4680: PPUSH
4681: LD_VAR 0 5
4685: PPUSH
4686: CALL_OW 458
4690: IFFALSE 4797
// begin LaunchMineAtPos ( x , y , 2 ) ;
4692: LD_VAR 0 4
4696: PPUSH
4697: LD_VAR 0 5
4701: PPUSH
4702: LD_INT 2
4704: PPUSH
4705: CALL_OW 456
// for j = 1 to staticMines do
4709: LD_ADDR_VAR 0 2
4713: PUSH
4714: DOUBLE
4715: LD_INT 1
4717: DEC
4718: ST_TO_ADDR
4719: LD_EXP 3
4723: PUSH
4724: FOR_TO
4725: IFFALSE 4795
// if staticMines [ j ] [ 1 ] = x and staticMines [ j ] [ 2 ] = y then
4727: LD_EXP 3
4731: PUSH
4732: LD_VAR 0 2
4736: ARRAY
4737: PUSH
4738: LD_INT 1
4740: ARRAY
4741: PUSH
4742: LD_VAR 0 4
4746: EQUAL
4747: PUSH
4748: LD_EXP 3
4752: PUSH
4753: LD_VAR 0 2
4757: ARRAY
4758: PUSH
4759: LD_INT 2
4761: ARRAY
4762: PUSH
4763: LD_VAR 0 5
4767: EQUAL
4768: AND
4769: IFFALSE 4793
// begin staticMines := Delete ( staticMines , j ) ;
4771: LD_ADDR_EXP 3
4775: PUSH
4776: LD_EXP 3
4780: PPUSH
4781: LD_VAR 0 2
4785: PPUSH
4786: CALL_OW 3
4790: ST_TO_ADDR
// break ;
4791: GO 4795
// end ;
4793: GO 4724
4795: POP
4796: POP
// end ; end ;
4797: GO 4643
4799: POP
4800: POP
// end ;
4801: PPOPN 5
4803: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ar_depot ) and not arDestroyed do var i , base , tmp , attackers , amount ;
4804: LD_INT 7
4806: PPUSH
4807: CALL_OW 302
4811: PUSH
4812: LD_EXP 4
4816: NOT
4817: AND
4818: IFFALSE 5418
4820: GO 4822
4822: DISABLE
4823: LD_INT 0
4825: PPUSH
4826: PPUSH
4827: PPUSH
4828: PPUSH
4829: PPUSH
// begin enable ;
4830: ENABLE
// base := 2 ;
4831: LD_ADDR_VAR 0 2
4835: PUSH
4836: LD_INT 2
4838: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_mortar ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ;
4839: LD_ADDR_VAR 0 3
4843: PUSH
4844: LD_INT 14
4846: PUSH
4847: LD_INT 1
4849: PUSH
4850: LD_INT 2
4852: PUSH
4853: LD_INT 27
4855: PUSH
4856: EMPTY
4857: LIST
4858: LIST
4859: LIST
4860: LIST
4861: PUSH
4862: LD_INT 14
4864: PUSH
4865: LD_INT 1
4867: PUSH
4868: LD_INT 2
4870: PUSH
4871: LD_INT 27
4873: PUSH
4874: EMPTY
4875: LIST
4876: LIST
4877: LIST
4878: LIST
4879: PUSH
4880: LD_INT 14
4882: PUSH
4883: LD_INT 1
4885: PUSH
4886: LD_INT 2
4888: PUSH
4889: LD_INT 92
4891: PUSH
4892: EMPTY
4893: LIST
4894: LIST
4895: LIST
4896: LIST
4897: PUSH
4898: LD_INT 14
4900: PUSH
4901: LD_INT 1
4903: PUSH
4904: LD_INT 2
4906: PUSH
4907: LD_INT 26
4909: PUSH
4910: EMPTY
4911: LIST
4912: LIST
4913: LIST
4914: LIST
4915: PUSH
4916: EMPTY
4917: LIST
4918: LIST
4919: LIST
4920: LIST
4921: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
4922: LD_ADDR_VAR 0 5
4926: PUSH
4927: LD_VAR 0 5
4931: PUSH
4932: LD_OWVAR 1
4936: PUSH
4937: LD_INT 21000
4939: DIV
4940: PLUS
4941: ST_TO_ADDR
// if amount > 8 then
4942: LD_VAR 0 5
4946: PUSH
4947: LD_INT 8
4949: GREATER
4950: IFFALSE 4960
// amount := 8 ;
4952: LD_ADDR_VAR 0 5
4956: PUSH
4957: LD_INT 8
4959: ST_TO_ADDR
// for i = 1 to amount do
4960: LD_ADDR_VAR 0 1
4964: PUSH
4965: DOUBLE
4966: LD_INT 1
4968: DEC
4969: ST_TO_ADDR
4970: LD_VAR 0 5
4974: PUSH
4975: FOR_TO
4976: IFFALSE 5064
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_half_tracked , ar_medium_trike ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gatling_gun , ar_gun ] [ rand ( 1 , 3 ) ] ] ) ;
4978: LD_ADDR_VAR 0 3
4982: PUSH
4983: LD_VAR 0 3
4987: PPUSH
4988: LD_VAR 0 3
4992: PUSH
4993: LD_INT 1
4995: PLUS
4996: PPUSH
4997: LD_INT 14
4999: PUSH
5000: LD_INT 13
5002: PUSH
5003: EMPTY
5004: LIST
5005: LIST
5006: PUSH
5007: LD_INT 1
5009: PPUSH
5010: LD_INT 2
5012: PPUSH
5013: CALL_OW 12
5017: ARRAY
5018: PUSH
5019: LD_INT 1
5021: PUSH
5022: LD_INT 2
5024: PUSH
5025: LD_INT 28
5027: PUSH
5028: LD_INT 25
5030: PUSH
5031: LD_INT 27
5033: PUSH
5034: EMPTY
5035: LIST
5036: LIST
5037: LIST
5038: PUSH
5039: LD_INT 1
5041: PPUSH
5042: LD_INT 3
5044: PPUSH
5045: CALL_OW 12
5049: ARRAY
5050: PUSH
5051: EMPTY
5052: LIST
5053: LIST
5054: LIST
5055: LIST
5056: PPUSH
5057: CALL_OW 2
5061: ST_TO_ADDR
5062: GO 4975
5064: POP
5065: POP
// MC_InsertProduceList ( base , tmp ) ;
5066: LD_VAR 0 2
5070: PPUSH
5071: LD_VAR 0 3
5075: PPUSH
5076: CALL 76420 0 2
// repeat wait ( 0 0$1 ) ;
5080: LD_INT 35
5082: PPUSH
5083: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
5087: LD_VAR 0 2
5091: PPUSH
5092: LD_INT 1
5094: PPUSH
5095: CALL 77838 0 2
5099: PUSH
5100: LD_VAR 0 5
5104: GREATEREQUAL
5105: IFFALSE 5080
// wait ( 0 0$30 ) ;
5107: LD_INT 1050
5109: PPUSH
5110: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_control_tower ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
5114: LD_ADDR_VAR 0 4
5118: PUSH
5119: LD_EXP 42
5123: PUSH
5124: LD_VAR 0 2
5128: ARRAY
5129: PUSH
5130: LD_EXP 42
5134: PUSH
5135: LD_VAR 0 2
5139: ARRAY
5140: PPUSH
5141: LD_INT 2
5143: PUSH
5144: LD_INT 34
5146: PUSH
5147: LD_INT 31
5149: PUSH
5150: EMPTY
5151: LIST
5152: LIST
5153: PUSH
5154: LD_INT 34
5156: PUSH
5157: LD_INT 32
5159: PUSH
5160: EMPTY
5161: LIST
5162: LIST
5163: PUSH
5164: LD_INT 34
5166: PUSH
5167: LD_INT 88
5169: PUSH
5170: EMPTY
5171: LIST
5172: LIST
5173: PUSH
5174: EMPTY
5175: LIST
5176: LIST
5177: LIST
5178: LIST
5179: PPUSH
5180: CALL_OW 72
5184: DIFF
5185: ST_TO_ADDR
// if not attackers then
5186: LD_VAR 0 4
5190: NOT
5191: IFFALSE 5195
// exit ;
5193: GO 5418
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
5195: LD_ADDR_EXP 42
5199: PUSH
5200: LD_EXP 42
5204: PPUSH
5205: LD_VAR 0 2
5209: PPUSH
5210: LD_EXP 42
5214: PUSH
5215: LD_VAR 0 2
5219: ARRAY
5220: PUSH
5221: LD_VAR 0 4
5225: DIFF
5226: PPUSH
5227: CALL_OW 1
5231: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
5232: LD_VAR 0 4
5236: PPUSH
5237: LD_INT 107
5239: PPUSH
5240: LD_INT 74
5242: PPUSH
5243: CALL_OW 114
// wait ( 0 0$5 ) ;
5247: LD_INT 175
5249: PPUSH
5250: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
5254: LD_INT 35
5256: PPUSH
5257: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5261: LD_VAR 0 4
5265: PPUSH
5266: LD_INT 60
5268: PUSH
5269: EMPTY
5270: LIST
5271: PPUSH
5272: CALL_OW 72
5276: NOT
5277: IFFALSE 5254
// if rand ( 0 , 1 ) then
5279: LD_INT 0
5281: PPUSH
5282: LD_INT 1
5284: PPUSH
5285: CALL_OW 12
5289: IFFALSE 5308
// ComAgressiveMove ( attackers , 155 , 108 ) else
5291: LD_VAR 0 4
5295: PPUSH
5296: LD_INT 155
5298: PPUSH
5299: LD_INT 108
5301: PPUSH
5302: CALL_OW 114
5306: GO 5323
// ComAgressiveMove ( attackers , 149 , 55 ) ;
5308: LD_VAR 0 4
5312: PPUSH
5313: LD_INT 149
5315: PPUSH
5316: LD_INT 55
5318: PPUSH
5319: CALL_OW 114
// wait ( 0 0$10 ) ;
5323: LD_INT 350
5325: PPUSH
5326: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
5330: LD_INT 35
5332: PPUSH
5333: CALL_OW 67
// for i in attackers do
5337: LD_ADDR_VAR 0 1
5341: PUSH
5342: LD_VAR 0 4
5346: PUSH
5347: FOR_IN
5348: IFFALSE 5398
// if not HasTask ( i ) then
5350: LD_VAR 0 1
5354: PPUSH
5355: CALL_OW 314
5359: NOT
5360: IFFALSE 5396
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
5362: LD_VAR 0 1
5366: PPUSH
5367: LD_INT 81
5369: PUSH
5370: LD_INT 2
5372: PUSH
5373: EMPTY
5374: LIST
5375: LIST
5376: PPUSH
5377: CALL_OW 69
5381: PPUSH
5382: LD_VAR 0 1
5386: PPUSH
5387: CALL_OW 74
5391: PPUSH
5392: CALL_OW 115
5396: GO 5347
5398: POP
5399: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
5400: LD_VAR 0 4
5404: PPUSH
5405: LD_INT 50
5407: PUSH
5408: EMPTY
5409: LIST
5410: PPUSH
5411: CALL_OW 72
5415: NOT
5416: IFFALSE 5330
// end ;
5418: PPOPN 5
5420: END
// every 8 8$00 + 9 9$00 trigger not arDestroyed and tick < 91 91$00 do var i , un , tmp ;
5421: LD_EXP 4
5425: NOT
5426: PUSH
5427: LD_OWVAR 1
5431: PUSH
5432: LD_INT 191100
5434: LESS
5435: AND
5436: IFFALSE 6108
5438: GO 5440
5440: DISABLE
5441: LD_INT 0
5443: PPUSH
5444: PPUSH
5445: PPUSH
// begin enable ;
5446: ENABLE
// tmp := [ ] ;
5447: LD_ADDR_VAR 0 3
5451: PUSH
5452: EMPTY
5453: ST_TO_ADDR
// if tick < 35 35$00 then
5454: LD_OWVAR 1
5458: PUSH
5459: LD_INT 73500
5461: LESS
5462: IFFALSE 5660
// begin for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
5464: LD_ADDR_VAR 0 1
5468: PUSH
5469: DOUBLE
5470: LD_INT 1
5472: DEC
5473: ST_TO_ADDR
5474: LD_INT 4
5476: PUSH
5477: LD_INT 5
5479: PUSH
5480: LD_INT 5
5482: PUSH
5483: EMPTY
5484: LIST
5485: LIST
5486: LIST
5487: PUSH
5488: LD_OWVAR 67
5492: ARRAY
5493: PUSH
5494: FOR_TO
5495: IFFALSE 5656
// begin uc_side := 2 ;
5497: LD_ADDR_OWVAR 20
5501: PUSH
5502: LD_INT 2
5504: ST_TO_ADDR
// uc_nation := 2 ;
5505: LD_ADDR_OWVAR 21
5509: PUSH
5510: LD_INT 2
5512: ST_TO_ADDR
// InitHC_All ( ) ;
5513: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
5517: LD_INT 0
5519: PPUSH
5520: LD_INT 1
5522: PPUSH
5523: LD_INT 5
5525: PUSH
5526: LD_INT 6
5528: PUSH
5529: LD_INT 7
5531: PUSH
5532: EMPTY
5533: LIST
5534: LIST
5535: LIST
5536: PUSH
5537: LD_OWVAR 67
5541: ARRAY
5542: PPUSH
5543: CALL_OW 380
// un := CreateHuman ;
5547: LD_ADDR_VAR 0 2
5551: PUSH
5552: CALL_OW 44
5556: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5557: LD_VAR 0 2
5561: PPUSH
5562: LD_INT 17
5564: PPUSH
5565: LD_INT 0
5567: PPUSH
5568: CALL_OW 49
// SetClass ( un , [ class_soldier , class_mortar ] [ rand ( 1 , 2 ) ] ) ;
5572: LD_VAR 0 2
5576: PPUSH
5577: LD_INT 1
5579: PUSH
5580: LD_INT 8
5582: PUSH
5583: EMPTY
5584: LIST
5585: LIST
5586: PUSH
5587: LD_INT 1
5589: PPUSH
5590: LD_INT 2
5592: PPUSH
5593: CALL_OW 12
5597: ARRAY
5598: PPUSH
5599: CALL_OW 336
// ComAgressiveMove ( un , 111 , 34 ) ;
5603: LD_VAR 0 2
5607: PPUSH
5608: LD_INT 111
5610: PPUSH
5611: LD_INT 34
5613: PPUSH
5614: CALL_OW 114
// wait ( 0 0$2 ) ;
5618: LD_INT 70
5620: PPUSH
5621: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5625: LD_ADDR_VAR 0 3
5629: PUSH
5630: LD_VAR 0 3
5634: PPUSH
5635: LD_VAR 0 3
5639: PUSH
5640: LD_INT 1
5642: PLUS
5643: PPUSH
5644: LD_VAR 0 2
5648: PPUSH
5649: CALL_OW 1
5653: ST_TO_ADDR
// end ;
5654: GO 5494
5656: POP
5657: POP
// end else
5658: GO 5801
// begin for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
5660: LD_ADDR_VAR 0 1
5664: PUSH
5665: DOUBLE
5666: LD_INT 1
5668: DEC
5669: ST_TO_ADDR
5670: LD_INT 4
5672: PUSH
5673: LD_INT 5
5675: PUSH
5676: LD_INT 5
5678: PUSH
5679: EMPTY
5680: LIST
5681: LIST
5682: LIST
5683: PUSH
5684: LD_OWVAR 67
5688: ARRAY
5689: PUSH
5690: FOR_TO
5691: IFFALSE 5799
// begin uc_side := 2 ;
5693: LD_ADDR_OWVAR 20
5697: PUSH
5698: LD_INT 2
5700: ST_TO_ADDR
// uc_nation := 0 ;
5701: LD_ADDR_OWVAR 21
5705: PUSH
5706: LD_INT 0
5708: ST_TO_ADDR
// InitHC_All ( ) ;
5709: CALL_OW 584
// hc_class := class_apeman_kamikaze ;
5713: LD_ADDR_OWVAR 28
5717: PUSH
5718: LD_INT 17
5720: ST_TO_ADDR
// un := CreateHuman ;
5721: LD_ADDR_VAR 0 2
5725: PUSH
5726: CALL_OW 44
5730: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5731: LD_VAR 0 2
5735: PPUSH
5736: LD_INT 17
5738: PPUSH
5739: LD_INT 0
5741: PPUSH
5742: CALL_OW 49
// ComAgressiveMove ( un , 110 , 33 ) ;
5746: LD_VAR 0 2
5750: PPUSH
5751: LD_INT 110
5753: PPUSH
5754: LD_INT 33
5756: PPUSH
5757: CALL_OW 114
// wait ( 0 0$2 ) ;
5761: LD_INT 70
5763: PPUSH
5764: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5768: LD_ADDR_VAR 0 3
5772: PUSH
5773: LD_VAR 0 3
5777: PPUSH
5778: LD_VAR 0 3
5782: PUSH
5783: LD_INT 1
5785: PLUS
5786: PPUSH
5787: LD_VAR 0 2
5791: PPUSH
5792: CALL_OW 1
5796: ST_TO_ADDR
// end ;
5797: GO 5690
5799: POP
5800: POP
// end ; for i := 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
5801: LD_ADDR_VAR 0 1
5805: PUSH
5806: DOUBLE
5807: LD_INT 1
5809: DEC
5810: ST_TO_ADDR
5811: LD_INT 3
5813: PUSH
5814: LD_INT 4
5816: PUSH
5817: LD_INT 5
5819: PUSH
5820: EMPTY
5821: LIST
5822: LIST
5823: LIST
5824: PUSH
5825: LD_OWVAR 67
5829: ARRAY
5830: PUSH
5831: FOR_TO
5832: IFFALSE 5997
// begin uc_side := 2 ;
5834: LD_ADDR_OWVAR 20
5838: PUSH
5839: LD_INT 2
5841: ST_TO_ADDR
// uc_nation := 2 ;
5842: LD_ADDR_OWVAR 21
5846: PUSH
5847: LD_INT 2
5849: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_selfpropelled_bomb , ar_rocket_launcher , ar_gun ] [ rand ( 1 , 3 ) ] , 90 ) ;
5850: LD_INT 14
5852: PPUSH
5853: LD_INT 3
5855: PPUSH
5856: LD_INT 5
5858: PPUSH
5859: LD_INT 29
5861: PUSH
5862: LD_INT 28
5864: PUSH
5865: LD_INT 27
5867: PUSH
5868: EMPTY
5869: LIST
5870: LIST
5871: LIST
5872: PUSH
5873: LD_INT 1
5875: PPUSH
5876: LD_INT 3
5878: PPUSH
5879: CALL_OW 12
5883: ARRAY
5884: PPUSH
5885: LD_INT 90
5887: PPUSH
5888: CALL 16034 0 5
// un := CreateVehicle ;
5892: LD_ADDR_VAR 0 2
5896: PUSH
5897: CALL_OW 45
5901: ST_TO_ADDR
// SetDir ( un , 2 ) ;
5902: LD_VAR 0 2
5906: PPUSH
5907: LD_INT 2
5909: PPUSH
5910: CALL_OW 233
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5914: LD_VAR 0 2
5918: PPUSH
5919: LD_INT 17
5921: PPUSH
5922: LD_INT 0
5924: PPUSH
5925: CALL_OW 49
// ComMoveXY ( un , 66 , 23 ) ;
5929: LD_VAR 0 2
5933: PPUSH
5934: LD_INT 66
5936: PPUSH
5937: LD_INT 23
5939: PPUSH
5940: CALL_OW 111
// wait ( 0 0$3 ) ;
5944: LD_INT 105
5946: PPUSH
5947: CALL_OW 67
// AddComAgressiveMove ( un , 147 , 103 ) ;
5951: LD_VAR 0 2
5955: PPUSH
5956: LD_INT 147
5958: PPUSH
5959: LD_INT 103
5961: PPUSH
5962: CALL_OW 174
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5966: LD_ADDR_VAR 0 3
5970: PUSH
5971: LD_VAR 0 3
5975: PPUSH
5976: LD_VAR 0 3
5980: PUSH
5981: LD_INT 1
5983: PLUS
5984: PPUSH
5985: LD_VAR 0 2
5989: PPUSH
5990: CALL_OW 1
5994: ST_TO_ADDR
// end ;
5995: GO 5831
5997: POP
5998: POP
// if not tmp then
5999: LD_VAR 0 3
6003: NOT
6004: IFFALSE 6008
// exit ;
6006: GO 6108
// wait ( 0 0$5 ) ;
6008: LD_INT 175
6010: PPUSH
6011: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
6015: LD_INT 70
6017: PPUSH
6018: CALL_OW 67
// for i in tmp do
6022: LD_ADDR_VAR 0 1
6026: PUSH
6027: LD_VAR 0 3
6031: PUSH
6032: FOR_IN
6033: IFFALSE 6099
// begin if not IsOk ( i ) then
6035: LD_VAR 0 1
6039: PPUSH
6040: CALL_OW 302
6044: NOT
6045: IFFALSE 6063
// tmp := tmp diff i ;
6047: LD_ADDR_VAR 0 3
6051: PUSH
6052: LD_VAR 0 3
6056: PUSH
6057: LD_VAR 0 1
6061: DIFF
6062: ST_TO_ADDR
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
6063: LD_VAR 0 1
6067: PPUSH
6068: LD_INT 81
6070: PUSH
6071: LD_INT 2
6073: PUSH
6074: EMPTY
6075: LIST
6076: LIST
6077: PPUSH
6078: CALL_OW 69
6082: PPUSH
6083: LD_VAR 0 1
6087: PPUSH
6088: CALL_OW 74
6092: PPUSH
6093: CALL_OW 115
// end ;
6097: GO 6032
6099: POP
6100: POP
// until not tmp ;
6101: LD_VAR 0 3
6105: NOT
6106: IFFALSE 6015
// end ;
6108: PPOPN 3
6110: END
// every 9 9$00 trigger Difficulty > 1 do var un ;
6111: LD_OWVAR 67
6115: PUSH
6116: LD_INT 1
6118: GREATER
6119: IFFALSE 6217
6121: GO 6123
6123: DISABLE
6124: LD_INT 0
6126: PPUSH
// begin uc_side := 2 ;
6127: LD_ADDR_OWVAR 20
6131: PUSH
6132: LD_INT 2
6134: ST_TO_ADDR
// uc_nation := 2 ;
6135: LD_ADDR_OWVAR 21
6139: PUSH
6140: LD_INT 2
6142: ST_TO_ADDR
// PrepareHuman ( false , 4 , 6 ) ;
6143: LD_INT 0
6145: PPUSH
6146: LD_INT 4
6148: PPUSH
6149: LD_INT 6
6151: PPUSH
6152: CALL_OW 380
// un := CreateHuman ;
6156: LD_ADDR_VAR 0 1
6160: PUSH
6161: CALL_OW 44
6165: ST_TO_ADDR
// PlaceUnitXYD ( un , 88 , 1 , 2 , false ) ;
6166: LD_VAR 0 1
6170: PPUSH
6171: LD_INT 88
6173: PPUSH
6174: LD_INT 1
6176: PPUSH
6177: LD_INT 2
6179: PPUSH
6180: LD_INT 0
6182: PPUSH
6183: CALL 50535 0 5
// ComMoveXY ( un , 130 , 35 ) ;
6187: LD_VAR 0 1
6191: PPUSH
6192: LD_INT 130
6194: PPUSH
6195: LD_INT 35
6197: PPUSH
6198: CALL_OW 111
// AddComContaminate ( un , 132 , 39 ) ;
6202: LD_VAR 0 1
6206: PPUSH
6207: LD_INT 132
6209: PPUSH
6210: LD_INT 39
6212: PPUSH
6213: CALL_OW 218
// end ;
6217: PPOPN 1
6219: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
6220: LD_INT 22
6222: PUSH
6223: LD_INT 2
6225: PUSH
6226: EMPTY
6227: LIST
6228: LIST
6229: PUSH
6230: LD_INT 33
6232: PUSH
6233: LD_INT 2
6235: PUSH
6236: EMPTY
6237: LIST
6238: LIST
6239: PUSH
6240: LD_INT 50
6242: PUSH
6243: EMPTY
6244: LIST
6245: PUSH
6246: LD_INT 3
6248: PUSH
6249: LD_INT 61
6251: PUSH
6252: EMPTY
6253: LIST
6254: PUSH
6255: EMPTY
6256: LIST
6257: LIST
6258: PUSH
6259: EMPTY
6260: LIST
6261: LIST
6262: LIST
6263: LIST
6264: PPUSH
6265: CALL_OW 69
6269: IFFALSE 6360
6271: GO 6273
6273: DISABLE
6274: LD_INT 0
6276: PPUSH
6277: PPUSH
// begin enable ;
6278: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
6279: LD_ADDR_VAR 0 2
6283: PUSH
6284: LD_INT 22
6286: PUSH
6287: LD_INT 2
6289: PUSH
6290: EMPTY
6291: LIST
6292: LIST
6293: PUSH
6294: LD_INT 33
6296: PUSH
6297: LD_INT 2
6299: PUSH
6300: EMPTY
6301: LIST
6302: LIST
6303: PUSH
6304: LD_INT 50
6306: PUSH
6307: EMPTY
6308: LIST
6309: PUSH
6310: LD_INT 3
6312: PUSH
6313: LD_INT 61
6315: PUSH
6316: EMPTY
6317: LIST
6318: PUSH
6319: EMPTY
6320: LIST
6321: LIST
6322: PUSH
6323: EMPTY
6324: LIST
6325: LIST
6326: LIST
6327: LIST
6328: PPUSH
6329: CALL_OW 69
6333: ST_TO_ADDR
// for i in tmp do
6334: LD_ADDR_VAR 0 1
6338: PUSH
6339: LD_VAR 0 2
6343: PUSH
6344: FOR_IN
6345: IFFALSE 6358
// Connect ( i ) ;
6347: LD_VAR 0 1
6351: PPUSH
6352: CALL 19125 0 1
6356: GO 6344
6358: POP
6359: POP
// end ; end_of_file
6360: PPOPN 2
6362: END
// export Popov , popov_side , extraPopovForces , popovAttackGroup ; export function PreparePopov ; var i , un , tmp , b , list ; begin
6363: LD_INT 0
6365: PPUSH
6366: PPUSH
6367: PPUSH
6368: PPUSH
6369: PPUSH
6370: PPUSH
// popov_side := 3 ;
6371: LD_ADDR_EXP 17
6375: PUSH
6376: LD_INT 3
6378: ST_TO_ADDR
// uc_side := popov_side ;
6379: LD_ADDR_OWVAR 20
6383: PUSH
6384: LD_EXP 17
6388: ST_TO_ADDR
// uc_nation := 3 ;
6389: LD_ADDR_OWVAR 21
6393: PUSH
6394: LD_INT 3
6396: ST_TO_ADDR
// list := [ [ b_barracks , 103 , 147 , 3 ] , [ b_barracks , 70 , 117 , 3 ] , [ b_lab , 76 , 145 , 1 , b_lab_weapon , b_lab_siberium ] , [ b_oil_power , 87 , 144 , 0 ] , [ b_oil_mine , 86 , 118 , 0 ] , [ b_oil_mine , 98 , 121 , 0 ] , [ b_oil_power , 87 , 147 , 1 ] , [ b_siberite_mine , 123 , 151 , 1 ] , [ b_factory , 94 , 161 , 0 ] , [ b_lab , 81 , 155 , 1 , b_lab_computer , b_lab_spacetime ] , [ b_oil_power , 96 , 152 , 0 ] , [ b_oil_power , 96 , 149 , 3 ] , [ b_bunker , 109 , 142 , 3 , ru_heavy_gun ] , [ b_bunker , 112 , 148 , 3 , ru_heavy_gun ] , [ b_turret , 120 , 159 , 4 , ru_rocket_launcher ] , [ b_turret , 122 , 163 , 4 , ru_rocket_launcher ] , [ b_turret , 123 , 167 , 4 , ru_rocket_launcher ] , [ b_turret , 59 , 111 , 3 , ru_rocket_launcher ] , [ b_turret , 65 , 111 , 3 , ru_heavy_gun ] , [ b_turret , 76 , 117 , 3 , ru_rocket_launcher ] , [ b_turret , 80 , 119 , 3 , ru_heavy_gun ] , [ b_turret , 87 , 125 , 3 , ru_rocket_launcher ] , [ b_barracks , 92 , 129 , 3 ] , [ b_siberite_power , 85 , 165 , 0 ] , [ b_siberite_power , 83 , 161 , 4 ] , [ b_siberite_power , 91 , 166 , 3 ] , [ b_siberite_power , 102 , 166 , 2 ] ] ;
6397: LD_ADDR_VAR 0 6
6401: PUSH
6402: LD_INT 5
6404: PUSH
6405: LD_INT 103
6407: PUSH
6408: LD_INT 147
6410: PUSH
6411: LD_INT 3
6413: PUSH
6414: EMPTY
6415: LIST
6416: LIST
6417: LIST
6418: LIST
6419: PUSH
6420: LD_INT 5
6422: PUSH
6423: LD_INT 70
6425: PUSH
6426: LD_INT 117
6428: PUSH
6429: LD_INT 3
6431: PUSH
6432: EMPTY
6433: LIST
6434: LIST
6435: LIST
6436: LIST
6437: PUSH
6438: LD_INT 6
6440: PUSH
6441: LD_INT 76
6443: PUSH
6444: LD_INT 145
6446: PUSH
6447: LD_INT 1
6449: PUSH
6450: LD_INT 10
6452: PUSH
6453: LD_INT 11
6455: PUSH
6456: EMPTY
6457: LIST
6458: LIST
6459: LIST
6460: LIST
6461: LIST
6462: LIST
6463: PUSH
6464: LD_INT 26
6466: PUSH
6467: LD_INT 87
6469: PUSH
6470: LD_INT 144
6472: PUSH
6473: LD_INT 0
6475: PUSH
6476: EMPTY
6477: LIST
6478: LIST
6479: LIST
6480: LIST
6481: PUSH
6482: LD_INT 29
6484: PUSH
6485: LD_INT 86
6487: PUSH
6488: LD_INT 118
6490: PUSH
6491: LD_INT 0
6493: PUSH
6494: EMPTY
6495: LIST
6496: LIST
6497: LIST
6498: LIST
6499: PUSH
6500: LD_INT 29
6502: PUSH
6503: LD_INT 98
6505: PUSH
6506: LD_INT 121
6508: PUSH
6509: LD_INT 0
6511: PUSH
6512: EMPTY
6513: LIST
6514: LIST
6515: LIST
6516: LIST
6517: PUSH
6518: LD_INT 26
6520: PUSH
6521: LD_INT 87
6523: PUSH
6524: LD_INT 147
6526: PUSH
6527: LD_INT 1
6529: PUSH
6530: EMPTY
6531: LIST
6532: LIST
6533: LIST
6534: LIST
6535: PUSH
6536: LD_INT 30
6538: PUSH
6539: LD_INT 123
6541: PUSH
6542: LD_INT 151
6544: PUSH
6545: LD_INT 1
6547: PUSH
6548: EMPTY
6549: LIST
6550: LIST
6551: LIST
6552: LIST
6553: PUSH
6554: LD_INT 3
6556: PUSH
6557: LD_INT 94
6559: PUSH
6560: LD_INT 161
6562: PUSH
6563: LD_INT 0
6565: PUSH
6566: EMPTY
6567: LIST
6568: LIST
6569: LIST
6570: LIST
6571: PUSH
6572: LD_INT 6
6574: PUSH
6575: LD_INT 81
6577: PUSH
6578: LD_INT 155
6580: PUSH
6581: LD_INT 1
6583: PUSH
6584: LD_INT 12
6586: PUSH
6587: LD_INT 14
6589: PUSH
6590: EMPTY
6591: LIST
6592: LIST
6593: LIST
6594: LIST
6595: LIST
6596: LIST
6597: PUSH
6598: LD_INT 26
6600: PUSH
6601: LD_INT 96
6603: PUSH
6604: LD_INT 152
6606: PUSH
6607: LD_INT 0
6609: PUSH
6610: EMPTY
6611: LIST
6612: LIST
6613: LIST
6614: LIST
6615: PUSH
6616: LD_INT 26
6618: PUSH
6619: LD_INT 96
6621: PUSH
6622: LD_INT 149
6624: PUSH
6625: LD_INT 3
6627: PUSH
6628: EMPTY
6629: LIST
6630: LIST
6631: LIST
6632: LIST
6633: PUSH
6634: LD_INT 32
6636: PUSH
6637: LD_INT 109
6639: PUSH
6640: LD_INT 142
6642: PUSH
6643: LD_INT 3
6645: PUSH
6646: LD_INT 46
6648: PUSH
6649: EMPTY
6650: LIST
6651: LIST
6652: LIST
6653: LIST
6654: LIST
6655: PUSH
6656: LD_INT 32
6658: PUSH
6659: LD_INT 112
6661: PUSH
6662: LD_INT 148
6664: PUSH
6665: LD_INT 3
6667: PUSH
6668: LD_INT 46
6670: PUSH
6671: EMPTY
6672: LIST
6673: LIST
6674: LIST
6675: LIST
6676: LIST
6677: PUSH
6678: LD_INT 33
6680: PUSH
6681: LD_INT 120
6683: PUSH
6684: LD_INT 159
6686: PUSH
6687: LD_INT 4
6689: PUSH
6690: LD_INT 45
6692: PUSH
6693: EMPTY
6694: LIST
6695: LIST
6696: LIST
6697: LIST
6698: LIST
6699: PUSH
6700: LD_INT 33
6702: PUSH
6703: LD_INT 122
6705: PUSH
6706: LD_INT 163
6708: PUSH
6709: LD_INT 4
6711: PUSH
6712: LD_INT 45
6714: PUSH
6715: EMPTY
6716: LIST
6717: LIST
6718: LIST
6719: LIST
6720: LIST
6721: PUSH
6722: LD_INT 33
6724: PUSH
6725: LD_INT 123
6727: PUSH
6728: LD_INT 167
6730: PUSH
6731: LD_INT 4
6733: PUSH
6734: LD_INT 45
6736: PUSH
6737: EMPTY
6738: LIST
6739: LIST
6740: LIST
6741: LIST
6742: LIST
6743: PUSH
6744: LD_INT 33
6746: PUSH
6747: LD_INT 59
6749: PUSH
6750: LD_INT 111
6752: PUSH
6753: LD_INT 3
6755: PUSH
6756: LD_INT 45
6758: PUSH
6759: EMPTY
6760: LIST
6761: LIST
6762: LIST
6763: LIST
6764: LIST
6765: PUSH
6766: LD_INT 33
6768: PUSH
6769: LD_INT 65
6771: PUSH
6772: LD_INT 111
6774: PUSH
6775: LD_INT 3
6777: PUSH
6778: LD_INT 46
6780: PUSH
6781: EMPTY
6782: LIST
6783: LIST
6784: LIST
6785: LIST
6786: LIST
6787: PUSH
6788: LD_INT 33
6790: PUSH
6791: LD_INT 76
6793: PUSH
6794: LD_INT 117
6796: PUSH
6797: LD_INT 3
6799: PUSH
6800: LD_INT 45
6802: PUSH
6803: EMPTY
6804: LIST
6805: LIST
6806: LIST
6807: LIST
6808: LIST
6809: PUSH
6810: LD_INT 33
6812: PUSH
6813: LD_INT 80
6815: PUSH
6816: LD_INT 119
6818: PUSH
6819: LD_INT 3
6821: PUSH
6822: LD_INT 46
6824: PUSH
6825: EMPTY
6826: LIST
6827: LIST
6828: LIST
6829: LIST
6830: LIST
6831: PUSH
6832: LD_INT 33
6834: PUSH
6835: LD_INT 87
6837: PUSH
6838: LD_INT 125
6840: PUSH
6841: LD_INT 3
6843: PUSH
6844: LD_INT 45
6846: PUSH
6847: EMPTY
6848: LIST
6849: LIST
6850: LIST
6851: LIST
6852: LIST
6853: PUSH
6854: LD_INT 5
6856: PUSH
6857: LD_INT 92
6859: PUSH
6860: LD_INT 129
6862: PUSH
6863: LD_INT 3
6865: PUSH
6866: EMPTY
6867: LIST
6868: LIST
6869: LIST
6870: LIST
6871: PUSH
6872: LD_INT 28
6874: PUSH
6875: LD_INT 85
6877: PUSH
6878: LD_INT 165
6880: PUSH
6881: LD_INT 0
6883: PUSH
6884: EMPTY
6885: LIST
6886: LIST
6887: LIST
6888: LIST
6889: PUSH
6890: LD_INT 28
6892: PUSH
6893: LD_INT 83
6895: PUSH
6896: LD_INT 161
6898: PUSH
6899: LD_INT 4
6901: PUSH
6902: EMPTY
6903: LIST
6904: LIST
6905: LIST
6906: LIST
6907: PUSH
6908: LD_INT 28
6910: PUSH
6911: LD_INT 91
6913: PUSH
6914: LD_INT 166
6916: PUSH
6917: LD_INT 3
6919: PUSH
6920: EMPTY
6921: LIST
6922: LIST
6923: LIST
6924: LIST
6925: PUSH
6926: LD_INT 28
6928: PUSH
6929: LD_INT 102
6931: PUSH
6932: LD_INT 166
6934: PUSH
6935: LD_INT 2
6937: PUSH
6938: EMPTY
6939: LIST
6940: LIST
6941: LIST
6942: LIST
6943: PUSH
6944: EMPTY
6945: LIST
6946: LIST
6947: LIST
6948: LIST
6949: LIST
6950: LIST
6951: LIST
6952: LIST
6953: LIST
6954: LIST
6955: LIST
6956: LIST
6957: LIST
6958: LIST
6959: LIST
6960: LIST
6961: LIST
6962: LIST
6963: LIST
6964: LIST
6965: LIST
6966: LIST
6967: LIST
6968: LIST
6969: LIST
6970: LIST
6971: LIST
6972: ST_TO_ADDR
// for i in list do
6973: LD_ADDR_VAR 0 2
6977: PUSH
6978: LD_VAR 0 6
6982: PUSH
6983: FOR_IN
6984: IFFALSE 7162
// begin uc_side := 3 ;
6986: LD_ADDR_OWVAR 20
6990: PUSH
6991: LD_INT 3
6993: ST_TO_ADDR
// uc_nation := 3 ;
6994: LD_ADDR_OWVAR 21
6998: PUSH
6999: LD_INT 3
7001: ST_TO_ADDR
// bc_type := i [ 1 ] ;
7002: LD_ADDR_OWVAR 42
7006: PUSH
7007: LD_VAR 0 2
7011: PUSH
7012: LD_INT 1
7014: ARRAY
7015: ST_TO_ADDR
// bc_kind1 := - 1 ;
7016: LD_ADDR_OWVAR 44
7020: PUSH
7021: LD_INT 1
7023: NEG
7024: ST_TO_ADDR
// bc_kind2 := - 1 ;
7025: LD_ADDR_OWVAR 45
7029: PUSH
7030: LD_INT 1
7032: NEG
7033: ST_TO_ADDR
// if i [ 1 ] = b_lab then
7034: LD_VAR 0 2
7038: PUSH
7039: LD_INT 1
7041: ARRAY
7042: PUSH
7043: LD_INT 6
7045: EQUAL
7046: IFFALSE 7084
// begin bc_type := b_lab_full ;
7048: LD_ADDR_OWVAR 42
7052: PUSH
7053: LD_INT 8
7055: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
7056: LD_ADDR_OWVAR 44
7060: PUSH
7061: LD_VAR 0 2
7065: PUSH
7066: LD_INT 5
7068: ARRAY
7069: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
7070: LD_ADDR_OWVAR 45
7074: PUSH
7075: LD_VAR 0 2
7079: PUSH
7080: LD_INT 6
7082: ARRAY
7083: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
7084: LD_ADDR_VAR 0 5
7088: PUSH
7089: LD_VAR 0 2
7093: PUSH
7094: LD_INT 2
7096: ARRAY
7097: PPUSH
7098: LD_VAR 0 2
7102: PUSH
7103: LD_INT 3
7105: ARRAY
7106: PPUSH
7107: LD_VAR 0 2
7111: PUSH
7112: LD_INT 4
7114: ARRAY
7115: PPUSH
7116: CALL_OW 47
7120: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
7121: LD_VAR 0 2
7125: PUSH
7126: LD_INT 1
7128: ARRAY
7129: PUSH
7130: LD_INT 33
7132: PUSH
7133: LD_INT 32
7135: PUSH
7136: EMPTY
7137: LIST
7138: LIST
7139: IN
7140: IFFALSE 7160
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
7142: LD_VAR 0 5
7146: PPUSH
7147: LD_VAR 0 2
7151: PUSH
7152: LD_INT 5
7154: ARRAY
7155: PPUSH
7156: CALL_OW 431
// end ;
7160: GO 6983
7162: POP
7163: POP
// tmp := PrepareBase ( ru_depot , popov_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 11500 , 1100 , 60 ] , [ 6 , 6 , 6 , 6 ] ) ;
7164: LD_ADDR_VAR 0 4
7168: PUSH
7169: LD_INT 9
7171: PPUSH
7172: LD_INT 3
7174: PPUSH
7175: LD_STRING 
7177: PPUSH
7178: LD_INT 8
7180: PUSH
7181: LD_INT 7
7183: PUSH
7184: LD_INT 6
7186: PUSH
7187: EMPTY
7188: LIST
7189: LIST
7190: LIST
7191: PUSH
7192: LD_OWVAR 67
7196: ARRAY
7197: PPUSH
7198: LD_INT 11500
7200: PUSH
7201: LD_INT 1100
7203: PUSH
7204: LD_INT 60
7206: PUSH
7207: EMPTY
7208: LIST
7209: LIST
7210: LIST
7211: PPUSH
7212: LD_INT 6
7214: PUSH
7215: LD_INT 6
7217: PUSH
7218: LD_INT 6
7220: PUSH
7221: LD_INT 6
7223: PUSH
7224: EMPTY
7225: LIST
7226: LIST
7227: LIST
7228: LIST
7229: PPUSH
7230: CALL 19478 0 6
7234: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 3 , tmp union FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ) ;
7235: LD_ADDR_EXP 23
7239: PUSH
7240: LD_EXP 23
7244: PPUSH
7245: LD_INT 3
7247: PPUSH
7248: LD_VAR 0 4
7252: PUSH
7253: LD_INT 22
7255: PUSH
7256: LD_INT 3
7258: PUSH
7259: EMPTY
7260: LIST
7261: LIST
7262: PUSH
7263: LD_INT 21
7265: PUSH
7266: LD_INT 3
7268: PUSH
7269: EMPTY
7270: LIST
7271: LIST
7272: PUSH
7273: EMPTY
7274: LIST
7275: LIST
7276: PPUSH
7277: CALL_OW 69
7281: UNION
7282: PPUSH
7283: CALL_OW 1
7287: ST_TO_ADDR
// extraPopovForces := [ ] ;
7288: LD_ADDR_EXP 18
7292: PUSH
7293: EMPTY
7294: ST_TO_ADDR
// for i := 1 to [ 8 , 9 , 10 ] [ Difficulty ] do
7295: LD_ADDR_VAR 0 2
7299: PUSH
7300: DOUBLE
7301: LD_INT 1
7303: DEC
7304: ST_TO_ADDR
7305: LD_INT 8
7307: PUSH
7308: LD_INT 9
7310: PUSH
7311: LD_INT 10
7313: PUSH
7314: EMPTY
7315: LIST
7316: LIST
7317: LIST
7318: PUSH
7319: LD_OWVAR 67
7323: ARRAY
7324: PUSH
7325: FOR_TO
7326: IFFALSE 7455
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
7328: LD_INT 0
7330: PPUSH
7331: LD_INT 1
7333: PPUSH
7334: LD_INT 4
7336: PUSH
7337: LD_INT 5
7339: PUSH
7340: LD_INT 6
7342: PUSH
7343: EMPTY
7344: LIST
7345: LIST
7346: LIST
7347: PUSH
7348: LD_OWVAR 67
7352: ARRAY
7353: PPUSH
7354: CALL_OW 380
// un := CreateHuman ;
7358: LD_ADDR_VAR 0 3
7362: PUSH
7363: CALL_OW 44
7367: ST_TO_ADDR
// if rand ( 0 , 1 ) then
7368: LD_INT 0
7370: PPUSH
7371: LD_INT 1
7373: PPUSH
7374: CALL_OW 12
7378: IFFALSE 7403
// PlaceUnitXYR ( un , 131 , 110 , 8 , false ) else
7380: LD_VAR 0 3
7384: PPUSH
7385: LD_INT 131
7387: PPUSH
7388: LD_INT 110
7390: PPUSH
7391: LD_INT 8
7393: PPUSH
7394: LD_INT 0
7396: PPUSH
7397: CALL_OW 50
7401: GO 7424
// PlaceUnitXYR ( un , 100 , 99 , 8 , false ) ;
7403: LD_VAR 0 3
7407: PPUSH
7408: LD_INT 100
7410: PPUSH
7411: LD_INT 99
7413: PPUSH
7414: LD_INT 8
7416: PPUSH
7417: LD_INT 0
7419: PPUSH
7420: CALL_OW 50
// extraPopovForces := Replace ( extraPopovForces , extraPopovForces + 1 , un ) ;
7424: LD_ADDR_EXP 18
7428: PUSH
7429: LD_EXP 18
7433: PPUSH
7434: LD_EXP 18
7438: PUSH
7439: LD_INT 1
7441: PLUS
7442: PPUSH
7443: LD_VAR 0 3
7447: PPUSH
7448: CALL_OW 1
7452: ST_TO_ADDR
// end ;
7453: GO 7325
7455: POP
7456: POP
// PrepareSoldier ( false , 6 ) ;
7457: LD_INT 0
7459: PPUSH
7460: LD_INT 6
7462: PPUSH
7463: CALL_OW 381
// un := CreateHuman ;
7467: LD_ADDR_VAR 0 3
7471: PUSH
7472: CALL_OW 44
7476: ST_TO_ADDR
// SetDir ( un , 1 ) ;
7477: LD_VAR 0 3
7481: PPUSH
7482: LD_INT 1
7484: PPUSH
7485: CALL_OW 233
// PlaceHumanInUnit ( un , HexInfo ( 150 , 158 ) ) ;
7489: LD_VAR 0 3
7493: PPUSH
7494: LD_INT 150
7496: PPUSH
7497: LD_INT 158
7499: PPUSH
7500: CALL_OW 428
7504: PPUSH
7505: CALL_OW 52
// popovAttackGroup := [ ] ;
7509: LD_ADDR_EXP 19
7513: PUSH
7514: EMPTY
7515: ST_TO_ADDR
// end ;
7516: LD_VAR 0 1
7520: RET
// export function InitMC_Popov ( ) ; begin
7521: LD_INT 0
7523: PPUSH
// MC_SetScanArea ( 3 , popov_base ) ;
7524: LD_INT 3
7526: PPUSH
7527: LD_INT 3
7529: PPUSH
7530: CALL 77693 0 2
// MC_SetParkingArea ( 3 , popov_parking ) ;
7534: LD_INT 3
7536: PPUSH
7537: LD_INT 10
7539: PPUSH
7540: CALL 77637 0 2
// MC_SetDepositsXY ( 3 , [ [ 86 , 118 , 0 ] , [ 123 , 151 , 1 ] , [ 98 , 121 , 0 ] ] ) ;
7544: LD_INT 3
7546: PPUSH
7547: LD_INT 86
7549: PUSH
7550: LD_INT 118
7552: PUSH
7553: LD_INT 0
7555: PUSH
7556: EMPTY
7557: LIST
7558: LIST
7559: LIST
7560: PUSH
7561: LD_INT 123
7563: PUSH
7564: LD_INT 151
7566: PUSH
7567: LD_INT 1
7569: PUSH
7570: EMPTY
7571: LIST
7572: LIST
7573: LIST
7574: PUSH
7575: LD_INT 98
7577: PUSH
7578: LD_INT 121
7580: PUSH
7581: LD_INT 0
7583: PUSH
7584: EMPTY
7585: LIST
7586: LIST
7587: LIST
7588: PUSH
7589: EMPTY
7590: LIST
7591: LIST
7592: LIST
7593: PPUSH
7594: CALL 76696 0 2
// MC_SetAllowedTurretWeapons ( 3 , [ ru_heavy_gun , ru_rocket_launcher ] ) ;
7598: LD_INT 3
7600: PPUSH
7601: LD_INT 46
7603: PUSH
7604: LD_INT 45
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: PPUSH
7611: CALL 77525 0 2
// MC_SetCratesArea ( 3 , popov_crates ) ;
7615: LD_INT 3
7617: PPUSH
7618: LD_INT 12
7620: PPUSH
7621: CALL 77207 0 2
// MC_SetTame ( 3 , popov_ape ) ;
7625: LD_INT 3
7627: PPUSH
7628: LD_INT 11
7630: PPUSH
7631: CALL 76938 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
7635: LD_INT 3
7637: PPUSH
7638: LD_INT 4
7640: PPUSH
7641: CALL 76557 0 2
// MC_SetProduceList ( 3 , [ [ ru_heavy_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] ] ) ;
7645: LD_INT 3
7647: PPUSH
7648: LD_INT 23
7650: PUSH
7651: LD_INT 1
7653: PUSH
7654: LD_INT 3
7656: PUSH
7657: LD_INT 44
7659: PUSH
7660: EMPTY
7661: LIST
7662: LIST
7663: LIST
7664: LIST
7665: PUSH
7666: LD_INT 23
7668: PUSH
7669: LD_INT 1
7671: PUSH
7672: LD_INT 3
7674: PUSH
7675: LD_INT 45
7677: PUSH
7678: EMPTY
7679: LIST
7680: LIST
7681: LIST
7682: LIST
7683: PUSH
7684: LD_INT 21
7686: PUSH
7687: LD_INT 1
7689: PUSH
7690: LD_INT 3
7692: PUSH
7693: LD_INT 44
7695: PUSH
7696: EMPTY
7697: LIST
7698: LIST
7699: LIST
7700: LIST
7701: PUSH
7702: LD_INT 21
7704: PUSH
7705: LD_INT 1
7707: PUSH
7708: LD_INT 3
7710: PUSH
7711: LD_INT 45
7713: PUSH
7714: EMPTY
7715: LIST
7716: LIST
7717: LIST
7718: LIST
7719: PUSH
7720: EMPTY
7721: LIST
7722: LIST
7723: LIST
7724: LIST
7725: PPUSH
7726: CALL 76372 0 2
// MC_SetFactoryExtension ( 3 , 94 , 161 , 0 , [ b_ext_noncombat , b_ext_gun , b_ext_rocket , b_ext_computer , b_ext_siberium ] ) ;
7730: LD_INT 3
7732: PPUSH
7733: LD_INT 94
7735: PPUSH
7736: LD_INT 161
7738: PPUSH
7739: LD_INT 0
7741: PPUSH
7742: LD_INT 19
7744: PUSH
7745: LD_INT 17
7747: PUSH
7748: LD_INT 18
7750: PUSH
7751: LD_INT 24
7753: PUSH
7754: LD_INT 21
7756: PUSH
7757: EMPTY
7758: LIST
7759: LIST
7760: LIST
7761: LIST
7762: LIST
7763: PPUSH
7764: CALL 77319 0 5
// MC_InsertProduceList ( 3 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] ] ) ;
7768: LD_INT 3
7770: PPUSH
7771: LD_INT 21
7773: PUSH
7774: LD_INT 1
7776: PUSH
7777: LD_INT 3
7779: PUSH
7780: LD_INT 51
7782: PUSH
7783: EMPTY
7784: LIST
7785: LIST
7786: LIST
7787: LIST
7788: PUSH
7789: EMPTY
7790: LIST
7791: PPUSH
7792: CALL 76420 0 2
// end ;
7796: LD_VAR 0 1
7800: RET
// every 9 9$00 trigger extraPopovForces and not ruDestroyed do
7801: LD_EXP 18
7805: PUSH
7806: LD_EXP 5
7810: NOT
7811: AND
7812: IFFALSE 7872
7814: GO 7816
7816: DISABLE
// begin ComMoveXY ( extraPopovForces , 106 , 137 ) ;
7817: LD_EXP 18
7821: PPUSH
7822: LD_INT 106
7824: PPUSH
7825: LD_INT 137
7827: PPUSH
7828: CALL_OW 111
// mc_bases := Replace ( mc_bases , 3 , mc_bases [ 3 ] union extraPopovForces ) ;
7832: LD_ADDR_EXP 23
7836: PUSH
7837: LD_EXP 23
7841: PPUSH
7842: LD_INT 3
7844: PPUSH
7845: LD_EXP 23
7849: PUSH
7850: LD_INT 3
7852: ARRAY
7853: PUSH
7854: LD_EXP 18
7858: UNION
7859: PPUSH
7860: CALL_OW 1
7864: ST_TO_ADDR
// extraPopovForces := [ ] ;
7865: LD_ADDR_EXP 18
7869: PUSH
7870: EMPTY
7871: ST_TO_ADDR
// end ;
7872: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ru_depot ) and not ruDestroyed do var i , base , tmp , attackers , amount ;
7873: LD_INT 9
7875: PPUSH
7876: CALL_OW 302
7880: PUSH
7881: LD_EXP 5
7885: NOT
7886: AND
7887: IFFALSE 8453
7889: GO 7891
7891: DISABLE
7892: LD_INT 0
7894: PPUSH
7895: PPUSH
7896: PPUSH
7897: PPUSH
7898: PPUSH
// begin enable ;
7899: ENABLE
// base := 3 ;
7900: LD_ADDR_VAR 0 2
7904: PUSH
7905: LD_INT 3
7907: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] ] ;
7908: LD_ADDR_VAR 0 3
7912: PUSH
7913: LD_INT 22
7915: PUSH
7916: LD_INT 1
7918: PUSH
7919: LD_INT 3
7921: PUSH
7922: LD_INT 44
7924: PUSH
7925: EMPTY
7926: LIST
7927: LIST
7928: LIST
7929: LIST
7930: PUSH
7931: LD_INT 24
7933: PUSH
7934: LD_INT 1
7936: PUSH
7937: LD_INT 3
7939: PUSH
7940: LD_INT 46
7942: PUSH
7943: EMPTY
7944: LIST
7945: LIST
7946: LIST
7947: LIST
7948: PUSH
7949: LD_INT 24
7951: PUSH
7952: LD_INT 1
7954: PUSH
7955: LD_INT 3
7957: PUSH
7958: LD_INT 46
7960: PUSH
7961: EMPTY
7962: LIST
7963: LIST
7964: LIST
7965: LIST
7966: PUSH
7967: LD_INT 24
7969: PUSH
7970: LD_INT 1
7972: PUSH
7973: LD_INT 3
7975: PUSH
7976: LD_INT 46
7978: PUSH
7979: EMPTY
7980: LIST
7981: LIST
7982: LIST
7983: LIST
7984: PUSH
7985: EMPTY
7986: LIST
7987: LIST
7988: LIST
7989: LIST
7990: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
7991: LD_ADDR_VAR 0 5
7995: PUSH
7996: LD_VAR 0 5
8000: PUSH
8001: LD_OWVAR 1
8005: PUSH
8006: LD_INT 21000
8008: DIV
8009: PLUS
8010: ST_TO_ADDR
// if amount > 8 then
8011: LD_VAR 0 5
8015: PUSH
8016: LD_INT 8
8018: GREATER
8019: IFFALSE 8029
// amount := 8 ;
8021: LD_ADDR_VAR 0 5
8025: PUSH
8026: LD_INT 8
8028: ST_TO_ADDR
// for i = 1 to amount do
8029: LD_ADDR_VAR 0 1
8033: PUSH
8034: DOUBLE
8035: LD_INT 1
8037: DEC
8038: ST_TO_ADDR
8039: LD_VAR 0 5
8043: PUSH
8044: FOR_TO
8045: IFFALSE 8110
// tmp := Insert ( tmp , tmp + 1 , [ ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
8047: LD_ADDR_VAR 0 3
8051: PUSH
8052: LD_VAR 0 3
8056: PPUSH
8057: LD_VAR 0 3
8061: PUSH
8062: LD_INT 1
8064: PLUS
8065: PPUSH
8066: LD_INT 24
8068: PUSH
8069: LD_INT 1
8071: PUSH
8072: LD_INT 3
8074: PUSH
8075: LD_INT 46
8077: PUSH
8078: LD_INT 45
8080: PUSH
8081: EMPTY
8082: LIST
8083: LIST
8084: PUSH
8085: LD_INT 1
8087: PPUSH
8088: LD_INT 2
8090: PPUSH
8091: CALL_OW 12
8095: ARRAY
8096: PUSH
8097: EMPTY
8098: LIST
8099: LIST
8100: LIST
8101: LIST
8102: PPUSH
8103: CALL_OW 2
8107: ST_TO_ADDR
8108: GO 8044
8110: POP
8111: POP
// MC_InsertProduceList ( base , tmp ) ;
8112: LD_VAR 0 2
8116: PPUSH
8117: LD_VAR 0 3
8121: PPUSH
8122: CALL 76420 0 2
// repeat wait ( 0 0$1 ) ;
8126: LD_INT 35
8128: PPUSH
8129: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
8133: LD_VAR 0 2
8137: PPUSH
8138: LD_INT 1
8140: PPUSH
8141: CALL 77838 0 2
8145: PUSH
8146: LD_VAR 0 5
8150: GREATEREQUAL
8151: IFFALSE 8126
// wait ( 0 0$30 ) ;
8153: LD_INT 1050
8155: PPUSH
8156: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
8160: LD_ADDR_VAR 0 4
8164: PUSH
8165: LD_EXP 42
8169: PUSH
8170: LD_VAR 0 2
8174: ARRAY
8175: PUSH
8176: LD_EXP 42
8180: PUSH
8181: LD_VAR 0 2
8185: ARRAY
8186: PPUSH
8187: LD_INT 2
8189: PUSH
8190: LD_INT 34
8192: PUSH
8193: LD_INT 51
8195: PUSH
8196: EMPTY
8197: LIST
8198: LIST
8199: PUSH
8200: LD_INT 34
8202: PUSH
8203: LD_INT 52
8205: PUSH
8206: EMPTY
8207: LIST
8208: LIST
8209: PUSH
8210: EMPTY
8211: LIST
8212: LIST
8213: LIST
8214: PPUSH
8215: CALL_OW 72
8219: DIFF
8220: ST_TO_ADDR
// if not attackers then
8221: LD_VAR 0 4
8225: NOT
8226: IFFALSE 8230
// exit ;
8228: GO 8453
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
8230: LD_ADDR_EXP 42
8234: PUSH
8235: LD_EXP 42
8239: PPUSH
8240: LD_VAR 0 2
8244: PPUSH
8245: LD_EXP 42
8249: PUSH
8250: LD_VAR 0 2
8254: ARRAY
8255: PUSH
8256: LD_VAR 0 4
8260: DIFF
8261: PPUSH
8262: CALL_OW 1
8266: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
8267: LD_VAR 0 4
8271: PPUSH
8272: LD_INT 107
8274: PPUSH
8275: LD_INT 74
8277: PPUSH
8278: CALL_OW 114
// wait ( 0 0$5 ) ;
8282: LD_INT 175
8284: PPUSH
8285: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8289: LD_INT 35
8291: PPUSH
8292: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
8296: LD_VAR 0 4
8300: PPUSH
8301: LD_INT 60
8303: PUSH
8304: EMPTY
8305: LIST
8306: PPUSH
8307: CALL_OW 72
8311: NOT
8312: IFFALSE 8289
// if rand ( 0 , 1 ) then
8314: LD_INT 0
8316: PPUSH
8317: LD_INT 1
8319: PPUSH
8320: CALL_OW 12
8324: IFFALSE 8343
// ComAgressiveMove ( attackers , 155 , 108 ) else
8326: LD_VAR 0 4
8330: PPUSH
8331: LD_INT 155
8333: PPUSH
8334: LD_INT 108
8336: PPUSH
8337: CALL_OW 114
8341: GO 8358
// ComAgressiveMove ( attackers , 149 , 55 ) ;
8343: LD_VAR 0 4
8347: PPUSH
8348: LD_INT 149
8350: PPUSH
8351: LD_INT 55
8353: PPUSH
8354: CALL_OW 114
// wait ( 0 0$10 ) ;
8358: LD_INT 350
8360: PPUSH
8361: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8365: LD_INT 35
8367: PPUSH
8368: CALL_OW 67
// for i in attackers do
8372: LD_ADDR_VAR 0 1
8376: PUSH
8377: LD_VAR 0 4
8381: PUSH
8382: FOR_IN
8383: IFFALSE 8433
// if not HasTask ( i ) then
8385: LD_VAR 0 1
8389: PPUSH
8390: CALL_OW 314
8394: NOT
8395: IFFALSE 8431
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8397: LD_VAR 0 1
8401: PPUSH
8402: LD_INT 81
8404: PUSH
8405: LD_INT 3
8407: PUSH
8408: EMPTY
8409: LIST
8410: LIST
8411: PPUSH
8412: CALL_OW 69
8416: PPUSH
8417: LD_VAR 0 1
8421: PPUSH
8422: CALL_OW 74
8426: PPUSH
8427: CALL_OW 115
8431: GO 8382
8433: POP
8434: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
8435: LD_VAR 0 4
8439: PPUSH
8440: LD_INT 50
8442: PUSH
8443: EMPTY
8444: LIST
8445: PPUSH
8446: CALL_OW 72
8450: NOT
8451: IFFALSE 8365
// end ;
8453: PPOPN 5
8455: END
// every 12 12$00 + 10 10$00 trigger not ruDestroyed do var i , un , tmp , amount ;
8456: LD_EXP 5
8460: NOT
8461: IFFALSE 9048
8463: GO 8465
8465: DISABLE
8466: LD_INT 0
8468: PPUSH
8469: PPUSH
8470: PPUSH
8471: PPUSH
// begin enable ;
8472: ENABLE
// if Difficulty = 1 and tick < 30 30$00 then
8473: LD_OWVAR 67
8477: PUSH
8478: LD_INT 1
8480: EQUAL
8481: PUSH
8482: LD_OWVAR 1
8486: PUSH
8487: LD_INT 63000
8489: LESS
8490: AND
8491: IFFALSE 8495
// exit ;
8493: GO 9048
// tmp := [ ] ;
8495: LD_ADDR_VAR 0 3
8499: PUSH
8500: EMPTY
8501: ST_TO_ADDR
// if tick < 45 45$00 then
8502: LD_OWVAR 1
8506: PUSH
8507: LD_INT 94500
8509: LESS
8510: IFFALSE 8687
// begin for i := 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
8512: LD_ADDR_VAR 0 1
8516: PUSH
8517: DOUBLE
8518: LD_INT 1
8520: DEC
8521: ST_TO_ADDR
8522: LD_INT 2
8524: PUSH
8525: LD_INT 3
8527: PUSH
8528: LD_INT 4
8530: PUSH
8531: EMPTY
8532: LIST
8533: LIST
8534: LIST
8535: PUSH
8536: LD_OWVAR 67
8540: ARRAY
8541: PUSH
8542: FOR_TO
8543: IFFALSE 8685
// begin uc_side := 3 ;
8545: LD_ADDR_OWVAR 20
8549: PUSH
8550: LD_INT 3
8552: ST_TO_ADDR
// uc_nation := 3 ;
8553: LD_ADDR_OWVAR 21
8557: PUSH
8558: LD_INT 3
8560: ST_TO_ADDR
// InitHC_All ( ) ;
8561: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
8565: LD_INT 0
8567: PPUSH
8568: LD_INT 1
8570: PPUSH
8571: LD_INT 5
8573: PUSH
8574: LD_INT 6
8576: PUSH
8577: LD_INT 7
8579: PUSH
8580: EMPTY
8581: LIST
8582: LIST
8583: LIST
8584: PUSH
8585: LD_OWVAR 67
8589: ARRAY
8590: PPUSH
8591: CALL_OW 380
// un := CreateHuman ;
8595: LD_ADDR_VAR 0 2
8599: PUSH
8600: CALL_OW 44
8604: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
8605: LD_VAR 0 2
8609: PPUSH
8610: LD_INT 18
8612: PPUSH
8613: LD_INT 0
8615: PPUSH
8616: CALL_OW 49
// SetClass ( un , class_bazooker ) ;
8620: LD_VAR 0 2
8624: PPUSH
8625: LD_INT 9
8627: PPUSH
8628: CALL_OW 336
// ComMoveXY ( un , 147 , 161 ) ;
8632: LD_VAR 0 2
8636: PPUSH
8637: LD_INT 147
8639: PPUSH
8640: LD_INT 161
8642: PPUSH
8643: CALL_OW 111
// wait ( 0 0$2 ) ;
8647: LD_INT 70
8649: PPUSH
8650: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8654: LD_ADDR_VAR 0 3
8658: PUSH
8659: LD_VAR 0 3
8663: PPUSH
8664: LD_VAR 0 3
8668: PUSH
8669: LD_INT 1
8671: PLUS
8672: PPUSH
8673: LD_VAR 0 2
8677: PPUSH
8678: CALL_OW 1
8682: ST_TO_ADDR
// end ;
8683: GO 8542
8685: POP
8686: POP
// end ; amount := [ 3 , 4 , 5 ] [ Difficulty ] + tick div 10 10$00 ;
8687: LD_ADDR_VAR 0 4
8691: PUSH
8692: LD_INT 3
8694: PUSH
8695: LD_INT 4
8697: PUSH
8698: LD_INT 5
8700: PUSH
8701: EMPTY
8702: LIST
8703: LIST
8704: LIST
8705: PUSH
8706: LD_OWVAR 67
8710: ARRAY
8711: PUSH
8712: LD_OWVAR 1
8716: PUSH
8717: LD_INT 21000
8719: DIV
8720: PLUS
8721: ST_TO_ADDR
// if amount > 15 then
8722: LD_VAR 0 4
8726: PUSH
8727: LD_INT 15
8729: GREATER
8730: IFFALSE 8740
// amount := 15 ;
8732: LD_ADDR_VAR 0 4
8736: PUSH
8737: LD_INT 15
8739: ST_TO_ADDR
// for i := 1 to amount do
8740: LD_ADDR_VAR 0 1
8744: PUSH
8745: DOUBLE
8746: LD_INT 1
8748: DEC
8749: ST_TO_ADDR
8750: LD_VAR 0 4
8754: PUSH
8755: FOR_TO
8756: IFFALSE 8902
// begin uc_side := 3 ;
8758: LD_ADDR_OWVAR 20
8762: PUSH
8763: LD_INT 3
8765: ST_TO_ADDR
// uc_nation := 3 ;
8766: LD_ADDR_OWVAR 21
8770: PUSH
8771: LD_INT 3
8773: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 5 ) ] , 90 ) ;
8774: LD_INT 24
8776: PPUSH
8777: LD_INT 1
8779: PPUSH
8780: LD_INT 3
8782: PPUSH
8783: LD_INT 46
8785: PUSH
8786: LD_INT 45
8788: PUSH
8789: LD_INT 44
8791: PUSH
8792: LD_INT 43
8794: PUSH
8795: LD_INT 42
8797: PUSH
8798: EMPTY
8799: LIST
8800: LIST
8801: LIST
8802: LIST
8803: LIST
8804: PUSH
8805: LD_INT 1
8807: PPUSH
8808: LD_INT 5
8810: PPUSH
8811: CALL_OW 12
8815: ARRAY
8816: PPUSH
8817: LD_INT 90
8819: PPUSH
8820: CALL 16034 0 5
// un := CreateVehicle ;
8824: LD_ADDR_VAR 0 2
8828: PUSH
8829: CALL_OW 45
8833: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
8834: LD_VAR 0 2
8838: PPUSH
8839: LD_INT 18
8841: PPUSH
8842: LD_INT 0
8844: PPUSH
8845: CALL_OW 49
// ComMoveXY ( un , 147 , 161 ) ;
8849: LD_VAR 0 2
8853: PPUSH
8854: LD_INT 147
8856: PPUSH
8857: LD_INT 161
8859: PPUSH
8860: CALL_OW 111
// wait ( 0 0$3 ) ;
8864: LD_INT 105
8866: PPUSH
8867: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8871: LD_ADDR_VAR 0 3
8875: PUSH
8876: LD_VAR 0 3
8880: PPUSH
8881: LD_VAR 0 3
8885: PUSH
8886: LD_INT 1
8888: PLUS
8889: PPUSH
8890: LD_VAR 0 2
8894: PPUSH
8895: CALL_OW 1
8899: ST_TO_ADDR
// end ;
8900: GO 8755
8902: POP
8903: POP
// if not tmp then
8904: LD_VAR 0 3
8908: NOT
8909: IFFALSE 8913
// exit ;
8911: GO 9048
// wait ( 0 0$5 ) ;
8913: LD_INT 175
8915: PPUSH
8916: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
8920: LD_INT 70
8922: PPUSH
8923: CALL_OW 67
// for i in tmp do
8927: LD_ADDR_VAR 0 1
8931: PUSH
8932: LD_VAR 0 3
8936: PUSH
8937: FOR_IN
8938: IFFALSE 9039
// begin if not IsOk ( i ) or IsDead ( i ) then
8940: LD_VAR 0 1
8944: PPUSH
8945: CALL_OW 302
8949: NOT
8950: PUSH
8951: LD_VAR 0 1
8955: PPUSH
8956: CALL_OW 301
8960: OR
8961: IFFALSE 8979
// tmp := tmp diff i ;
8963: LD_ADDR_VAR 0 3
8967: PUSH
8968: LD_VAR 0 3
8972: PUSH
8973: LD_VAR 0 1
8977: DIFF
8978: ST_TO_ADDR
// if GetClass ( i ) = class_bazooker then
8979: LD_VAR 0 1
8983: PPUSH
8984: CALL_OW 257
8988: PUSH
8989: LD_INT 9
8991: EQUAL
8992: IFFALSE 9003
// ComSpaceTimeShoot ( i ) ;
8994: LD_VAR 0 1
8998: PPUSH
8999: CALL 11966 0 1
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9003: LD_VAR 0 1
9007: PPUSH
9008: LD_INT 81
9010: PUSH
9011: LD_INT 3
9013: PUSH
9014: EMPTY
9015: LIST
9016: LIST
9017: PPUSH
9018: CALL_OW 69
9022: PPUSH
9023: LD_VAR 0 1
9027: PPUSH
9028: CALL_OW 74
9032: PPUSH
9033: CALL_OW 115
// end ;
9037: GO 8937
9039: POP
9040: POP
// until not tmp ;
9041: LD_VAR 0 3
9045: NOT
9046: IFFALSE 8920
// end ; end_of_file
9048: PPOPN 4
9050: END
// export Sikorski ; export function PrepareSikorski ; var i , j , un ; begin
9051: LD_INT 0
9053: PPUSH
9054: PPUSH
9055: PPUSH
9056: PPUSH
// uc_side := 1 ;
9057: LD_ADDR_OWVAR 20
9061: PUSH
9062: LD_INT 1
9064: ST_TO_ADDR
// uc_nation := 1 ;
9065: LD_ADDR_OWVAR 21
9069: PUSH
9070: LD_INT 1
9072: ST_TO_ADDR
// hc_importance := 100 ;
9073: LD_ADDR_OWVAR 32
9077: PUSH
9078: LD_INT 100
9080: ST_TO_ADDR
// hc_name := Jeremy Sikorski ;
9081: LD_ADDR_OWVAR 26
9085: PUSH
9086: LD_STRING Jeremy Sikorski
9088: ST_TO_ADDR
// hc_gallery := us ;
9089: LD_ADDR_OWVAR 33
9093: PUSH
9094: LD_STRING us
9096: ST_TO_ADDR
// hc_face_number := 19 ;
9097: LD_ADDR_OWVAR 34
9101: PUSH
9102: LD_INT 19
9104: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , [ 4 , 4 , 3 ] [ Difficulty ] ) ;
9105: LD_INT 1
9107: PPUSH
9108: LD_INT 1
9110: PPUSH
9111: LD_INT 4
9113: PUSH
9114: LD_INT 4
9116: PUSH
9117: LD_INT 3
9119: PUSH
9120: EMPTY
9121: LIST
9122: LIST
9123: LIST
9124: PUSH
9125: LD_OWVAR 67
9129: ARRAY
9130: PPUSH
9131: CALL_OW 380
// hc_attr := [ 10 , 12 ] ;
9135: LD_ADDR_OWVAR 29
9139: PUSH
9140: LD_INT 10
9142: PUSH
9143: LD_INT 12
9145: PUSH
9146: EMPTY
9147: LIST
9148: LIST
9149: ST_TO_ADDR
// Sikorski := CreateHuman ;
9150: LD_ADDR_EXP 20
9154: PUSH
9155: CALL_OW 44
9159: ST_TO_ADDR
// PlaceUnitXYR ( Sikorski , 133 , 19 , 2 , false ) ;
9160: LD_EXP 20
9164: PPUSH
9165: LD_INT 133
9167: PPUSH
9168: LD_INT 19
9170: PPUSH
9171: LD_INT 2
9173: PPUSH
9174: LD_INT 0
9176: PPUSH
9177: CALL_OW 50
// InitHc_All ( ) ;
9181: CALL_OW 584
// for i := 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
9185: LD_ADDR_VAR 0 2
9189: PUSH
9190: DOUBLE
9191: LD_INT 1
9193: DEC
9194: ST_TO_ADDR
9195: LD_INT 4
9197: PUSH
9198: LD_INT 3
9200: PUSH
9201: LD_INT 3
9203: PUSH
9204: EMPTY
9205: LIST
9206: LIST
9207: LIST
9208: PUSH
9209: LD_OWVAR 67
9213: ARRAY
9214: PUSH
9215: FOR_TO
9216: IFFALSE 9332
// for j := 1 to 4 do
9218: LD_ADDR_VAR 0 3
9222: PUSH
9223: DOUBLE
9224: LD_INT 1
9226: DEC
9227: ST_TO_ADDR
9228: LD_INT 4
9230: PUSH
9231: FOR_TO
9232: IFFALSE 9328
// begin PrepareHuman ( false , j , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
9234: LD_INT 0
9236: PPUSH
9237: LD_VAR 0 3
9241: PPUSH
9242: LD_INT 5
9244: PUSH
9245: LD_INT 4
9247: PUSH
9248: LD_INT 3
9250: PUSH
9251: EMPTY
9252: LIST
9253: LIST
9254: LIST
9255: PUSH
9256: LD_OWVAR 67
9260: ARRAY
9261: PPUSH
9262: CALL_OW 380
// un := CreateHuman ;
9266: LD_ADDR_VAR 0 4
9270: PUSH
9271: CALL_OW 44
9275: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
9276: LD_VAR 0 4
9280: PPUSH
9281: LD_INT 0
9283: PPUSH
9284: LD_INT 5
9286: PPUSH
9287: CALL_OW 12
9291: PPUSH
9292: CALL_OW 233
// PlaceUnitXYR ( un , 133 , 19 , 6 , false ) ;
9296: LD_VAR 0 4
9300: PPUSH
9301: LD_INT 133
9303: PPUSH
9304: LD_INT 19
9306: PPUSH
9307: LD_INT 6
9309: PPUSH
9310: LD_INT 0
9312: PPUSH
9313: CALL_OW 50
// ComHold ( un ) ;
9317: LD_VAR 0 4
9321: PPUSH
9322: CALL_OW 140
// end ;
9326: GO 9231
9328: POP
9329: POP
9330: GO 9215
9332: POP
9333: POP
// vc_chassis := us_heavy_tracked ;
9334: LD_ADDR_OWVAR 37
9338: PUSH
9339: LD_INT 4
9341: ST_TO_ADDR
// vc_engine := engine_combustion ;
9342: LD_ADDR_OWVAR 39
9346: PUSH
9347: LD_INT 1
9349: ST_TO_ADDR
// vc_control := control_manual ;
9350: LD_ADDR_OWVAR 38
9354: PUSH
9355: LD_INT 1
9357: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
9358: LD_ADDR_OWVAR 40
9362: PUSH
9363: LD_INT 14
9365: ST_TO_ADDR
// vc_fuel_battery := 60 ;
9366: LD_ADDR_OWVAR 41
9370: PUSH
9371: LD_INT 60
9373: ST_TO_ADDR
// un := CreateVehicle ;
9374: LD_ADDR_VAR 0 4
9378: PUSH
9379: CALL_OW 45
9383: ST_TO_ADDR
// SetDir ( un , 2 ) ;
9384: LD_VAR 0 4
9388: PPUSH
9389: LD_INT 2
9391: PPUSH
9392: CALL_OW 233
// PlaceUnitXY ( un , 128 , 12 , false ) ;
9396: LD_VAR 0 4
9400: PPUSH
9401: LD_INT 128
9403: PPUSH
9404: LD_INT 12
9406: PPUSH
9407: LD_INT 0
9409: PPUSH
9410: CALL_OW 48
// for i := 1 to 3 do
9414: LD_ADDR_VAR 0 2
9418: PUSH
9419: DOUBLE
9420: LD_INT 1
9422: DEC
9423: ST_TO_ADDR
9424: LD_INT 3
9426: PUSH
9427: FOR_TO
9428: IFFALSE 9451
// CreateCratesXYR ( 5 , 133 , 19 , 3 , false ) ;
9430: LD_INT 5
9432: PPUSH
9433: LD_INT 133
9435: PPUSH
9436: LD_INT 19
9438: PPUSH
9439: LD_INT 3
9441: PPUSH
9442: LD_INT 0
9444: PPUSH
9445: CALL_OW 56
9449: GO 9427
9451: POP
9452: POP
// end ; end_of_file
9453: LD_VAR 0 1
9457: RET
// export function Action ; begin
9458: LD_INT 0
9460: PPUSH
// InGameOn ;
9461: CALL_OW 8
// CenterNowOnXY ( 133 , 19 ) ;
9465: LD_INT 133
9467: PPUSH
9468: LD_INT 19
9470: PPUSH
9471: CALL_OW 86
// Say ( Sikorski , WT-DS-1 ) ;
9475: LD_EXP 20
9479: PPUSH
9480: LD_STRING WT-DS-1
9482: PPUSH
9483: CALL_OW 88
// InGameOff ;
9487: CALL_OW 9
// ChangeMissionObjectives ( DestroyEnemy ) ;
9491: LD_STRING DestroyEnemy
9493: PPUSH
9494: CALL_OW 337
// wait ( 0 0$20 ) ;
9498: LD_INT 700
9500: PPUSH
9501: CALL_OW 67
// DialogueOn ;
9505: CALL_OW 6
// PlaceSeeing ( 100 , 37 , 1 , - 30 ) ;
9509: LD_INT 100
9511: PPUSH
9512: LD_INT 37
9514: PPUSH
9515: LD_INT 1
9517: PPUSH
9518: LD_INT 30
9520: NEG
9521: PPUSH
9522: CALL_OW 330
// CenterNowOnXY ( 100 , 37 ) ;
9526: LD_INT 100
9528: PPUSH
9529: LD_INT 37
9531: PPUSH
9532: CALL_OW 86
// SayRadio ( Powell , WT-PL-1 ) ;
9536: LD_EXP 10
9540: PPUSH
9541: LD_STRING WT-PL-1
9543: PPUSH
9544: CALL_OW 94
// Say ( Sikorski , WT-DS-2 ) ;
9548: LD_EXP 20
9552: PPUSH
9553: LD_STRING WT-DS-2
9555: PPUSH
9556: CALL_OW 88
// DialogueOff ;
9560: CALL_OW 7
// wait ( 0 0$2 ) ;
9564: LD_INT 70
9566: PPUSH
9567: CALL_OW 67
// RemoveSeeing ( 100 , 37 , 1 ) ;
9571: LD_INT 100
9573: PPUSH
9574: LD_INT 37
9576: PPUSH
9577: LD_INT 1
9579: PPUSH
9580: CALL_OW 331
// end ;
9584: LD_VAR 0 1
9588: RET
// export function DialogPowellsAttack ; begin
9589: LD_INT 0
9591: PPUSH
// SayRadio ( Powell , WT-PL-8 ) ;
9592: LD_EXP 10
9596: PPUSH
9597: LD_STRING WT-PL-8
9599: PPUSH
9600: CALL_OW 94
// end ;
9604: LD_VAR 0 1
9608: RET
// export function DialogContaminateSib ( x , y ) ; begin
9609: LD_INT 0
9611: PPUSH
// DialogueOn ;
9612: CALL_OW 6
// CenterNowOnXY ( x , y ) ;
9616: LD_VAR 0 1
9620: PPUSH
9621: LD_VAR 0 2
9625: PPUSH
9626: CALL_OW 86
// Say ( Sikorski , WT-DS-3 ) ;
9630: LD_EXP 20
9634: PPUSH
9635: LD_STRING WT-DS-3
9637: PPUSH
9638: CALL_OW 88
// DialogueOff ;
9642: CALL_OW 7
// end ;
9646: LD_VAR 0 3
9650: RET
// every 0 0$3 trigger not powellInTrouble and FilterUnitsInArea ( powell_base , [ f_enemy , 4 ] ) > 3 do
9651: LD_EXP 8
9655: NOT
9656: PUSH
9657: LD_INT 1
9659: PPUSH
9660: LD_INT 81
9662: PUSH
9663: LD_INT 4
9665: PUSH
9666: EMPTY
9667: LIST
9668: LIST
9669: PPUSH
9670: CALL_OW 70
9674: PUSH
9675: LD_INT 3
9677: GREATER
9678: AND
9679: IFFALSE 9751
9681: GO 9683
9683: DISABLE
// begin powellInTrouble := true ;
9684: LD_ADDR_EXP 8
9688: PUSH
9689: LD_INT 1
9691: ST_TO_ADDR
// Say ( Sikorski , WT-DS-6 ) ;
9692: LD_EXP 20
9696: PPUSH
9697: LD_STRING WT-DS-6
9699: PPUSH
9700: CALL_OW 88
// if not FilterUnitsInArea ( powell_base , [ f_side , 1 ] ) then
9704: LD_INT 1
9706: PPUSH
9707: LD_INT 22
9709: PUSH
9710: LD_INT 1
9712: PUSH
9713: EMPTY
9714: LIST
9715: LIST
9716: PPUSH
9717: CALL_OW 70
9721: NOT
9722: IFFALSE 9736
// SayRadio ( Powell , WT-PL-6 ) ;
9724: LD_EXP 10
9728: PPUSH
9729: LD_STRING WT-PL-6
9731: PPUSH
9732: CALL_OW 94
// wait ( 1 1$30 ) ;
9736: LD_INT 3150
9738: PPUSH
9739: CALL_OW 67
// powellInTrouble := false ;
9743: LD_ADDR_EXP 8
9747: PUSH
9748: LD_INT 0
9750: ST_TO_ADDR
// end ;
9751: END
// every 0 0$3 trigger not sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 1 ] ) > 6 do
9752: LD_EXP 9
9756: NOT
9757: PUSH
9758: LD_INT 16
9760: PPUSH
9761: LD_INT 81
9763: PUSH
9764: LD_INT 1
9766: PUSH
9767: EMPTY
9768: LIST
9769: LIST
9770: PPUSH
9771: CALL_OW 70
9775: PUSH
9776: LD_INT 6
9778: GREATER
9779: AND
9780: IFFALSE 9853
9782: GO 9784
9784: DISABLE
// begin sikorskiInTrouble := true ;
9785: LD_ADDR_EXP 9
9789: PUSH
9790: LD_INT 1
9792: ST_TO_ADDR
// Say ( Sikorski , WT-DS-7 ) ;
9793: LD_EXP 20
9797: PPUSH
9798: LD_STRING WT-DS-7
9800: PPUSH
9801: CALL_OW 88
// if not powellAttackGroup then
9805: LD_EXP 12
9809: NOT
9810: IFFALSE 9826
// SayRadio ( Powell , WT-PL-7n ) else
9812: LD_EXP 10
9816: PPUSH
9817: LD_STRING WT-PL-7n
9819: PPUSH
9820: CALL_OW 94
9824: GO 9838
// SayRadio ( Powell , WT-PL-7y ) ;
9826: LD_EXP 10
9830: PPUSH
9831: LD_STRING WT-PL-7y
9833: PPUSH
9834: CALL_OW 94
// wait ( 1 1$30 ) ;
9838: LD_INT 3150
9840: PPUSH
9841: CALL_OW 67
// sikorskiInTrouble := false ;
9845: LD_ADDR_EXP 9
9849: PUSH
9850: LD_INT 0
9852: ST_TO_ADDR
// end ;
9853: END
// export function DialogPowellsAttackFailed ; begin
9854: LD_INT 0
9856: PPUSH
// if not ruDestroyed then
9857: LD_EXP 5
9861: NOT
9862: IFFALSE 9878
// SayRadio ( Powell , WT-PL-9 ) else
9864: LD_EXP 10
9868: PPUSH
9869: LD_STRING WT-PL-9
9871: PPUSH
9872: CALL_OW 94
9876: GO 9890
// SayRadio ( Powell , WT-PL-10 ) ;
9878: LD_EXP 10
9882: PPUSH
9883: LD_STRING WT-PL-10
9885: PPUSH
9886: CALL_OW 94
// end ;
9890: LD_VAR 0 1
9894: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
9895: LD_INT 22
9897: PUSH
9898: LD_INT 2
9900: PUSH
9901: EMPTY
9902: LIST
9903: LIST
9904: PUSH
9905: LD_INT 21
9907: PUSH
9908: LD_INT 1
9910: PUSH
9911: EMPTY
9912: LIST
9913: LIST
9914: PUSH
9915: EMPTY
9916: LIST
9917: LIST
9918: PPUSH
9919: CALL_OW 69
9923: PUSH
9924: LD_INT 0
9926: EQUAL
9927: IFFALSE 9971
9929: GO 9931
9931: DISABLE
// begin arDestroyed := true ;
9932: LD_ADDR_EXP 4
9936: PUSH
9937: LD_INT 1
9939: ST_TO_ADDR
// MC_Kill ( 2 ) ;
9940: LD_INT 2
9942: PPUSH
9943: CALL 52446 0 1
// Say ( Sikorski , WT-DS-4 ) ;
9947: LD_EXP 20
9951: PPUSH
9952: LD_STRING WT-DS-4
9954: PPUSH
9955: CALL_OW 88
// SayRadio ( Powell , WT-PL-4 ) ;
9959: LD_EXP 10
9963: PPUSH
9964: LD_STRING WT-PL-4
9966: PPUSH
9967: CALL_OW 94
// end ;
9971: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
9972: LD_INT 22
9974: PUSH
9975: LD_INT 3
9977: PUSH
9978: EMPTY
9979: LIST
9980: LIST
9981: PUSH
9982: LD_INT 21
9984: PUSH
9985: LD_INT 1
9987: PUSH
9988: EMPTY
9989: LIST
9990: LIST
9991: PUSH
9992: EMPTY
9993: LIST
9994: LIST
9995: PPUSH
9996: CALL_OW 69
10000: PUSH
10001: LD_INT 0
10003: EQUAL
10004: IFFALSE 10048
10006: GO 10008
10008: DISABLE
// begin ruDestroyed := true ;
10009: LD_ADDR_EXP 5
10013: PUSH
10014: LD_INT 1
10016: ST_TO_ADDR
// MC_Kill ( 3 ) ;
10017: LD_INT 3
10019: PPUSH
10020: CALL 52446 0 1
// Say ( Sikorski , WT-DS-5 ) ;
10024: LD_EXP 20
10028: PPUSH
10029: LD_STRING WT-DS-5
10031: PPUSH
10032: CALL_OW 88
// SayRadio ( Powell , WT-PL-5 ) ;
10036: LD_EXP 10
10040: PPUSH
10041: LD_STRING WT-PL-5
10043: PPUSH
10044: CALL_OW 94
// end ;
10048: END
// every 0 0$1 trigger ruDestroyed and arDestroyed do
10049: LD_EXP 5
10053: PUSH
10054: LD_EXP 4
10058: AND
10059: IFFALSE 10232
10061: GO 10063
10063: DISABLE
// begin wait ( 0 0$3 ) ;
10064: LD_INT 105
10066: PPUSH
10067: CALL_OW 67
// if tick >= [ 60 60$00 , 50 50$00 , 45 45$00 ] [ Difficulty ] then
10071: LD_OWVAR 1
10075: PUSH
10076: LD_INT 126000
10078: PUSH
10079: LD_INT 105000
10081: PUSH
10082: LD_INT 94500
10084: PUSH
10085: EMPTY
10086: LIST
10087: LIST
10088: LIST
10089: PUSH
10090: LD_OWVAR 67
10094: ARRAY
10095: GREATEREQUAL
10096: IFFALSE 10111
// AddMedal ( WoT-med-1 , - 1 ) else
10098: LD_STRING WoT-med-1
10100: PPUSH
10101: LD_INT 1
10103: NEG
10104: PPUSH
10105: CALL_OW 101
10109: GO 10121
// AddMedal ( WoT-med-1 , 1 ) ;
10111: LD_STRING WoT-med-1
10113: PPUSH
10114: LD_INT 1
10116: PPUSH
10117: CALL_OW 101
// if loseCounter >= [ 4 , 3 , 2 ] [ Difficulty ] then
10121: LD_EXP 6
10125: PUSH
10126: LD_INT 4
10128: PUSH
10129: LD_INT 3
10131: PUSH
10132: LD_INT 2
10134: PUSH
10135: EMPTY
10136: LIST
10137: LIST
10138: LIST
10139: PUSH
10140: LD_OWVAR 67
10144: ARRAY
10145: GREATEREQUAL
10146: IFFALSE 10161
// AddMedal ( WoT-med-2 , - 1 ) else
10148: LD_STRING WoT-med-2
10150: PPUSH
10151: LD_INT 1
10153: NEG
10154: PPUSH
10155: CALL_OW 101
10159: GO 10171
// AddMedal ( WoT-med-2 , 1 ) ;
10161: LD_STRING WoT-med-2
10163: PPUSH
10164: LD_INT 1
10166: PPUSH
10167: CALL_OW 101
// if powellLoseCounter >= [ 8 , 6 , 5 ] [ Difficulty ] then
10171: LD_EXP 7
10175: PUSH
10176: LD_INT 8
10178: PUSH
10179: LD_INT 6
10181: PUSH
10182: LD_INT 5
10184: PUSH
10185: EMPTY
10186: LIST
10187: LIST
10188: LIST
10189: PUSH
10190: LD_OWVAR 67
10194: ARRAY
10195: GREATEREQUAL
10196: IFFALSE 10211
// AddMedal ( WoT-med-3 , - 1 ) else
10198: LD_STRING WoT-med-3
10200: PPUSH
10201: LD_INT 1
10203: NEG
10204: PPUSH
10205: CALL_OW 101
10209: GO 10221
// AddMedal ( WoT-med-3 , 1 ) ;
10211: LD_STRING WoT-med-3
10213: PPUSH
10214: LD_INT 1
10216: PPUSH
10217: CALL_OW 101
// GiveMedals ( MAIN ) ;
10221: LD_STRING MAIN
10223: PPUSH
10224: CALL_OW 102
// YouWin ;
10228: CALL_OW 103
// end ; end_of_file
10232: END
// export function CustomEvent ( event ) ; begin
10233: LD_INT 0
10235: PPUSH
// end ;
10236: LD_VAR 0 2
10240: RET
// on Command ( com ) do var i , j , temp ;
10241: LD_INT 0
10243: PPUSH
10244: PPUSH
10245: PPUSH
// begin if com = 60 then
10246: LD_VAR 0 1
10250: PUSH
10251: LD_INT 60
10253: EQUAL
10254: IFFALSE 10433
// begin for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_weapon , us_cargo_bay ] ] ] ) do
10256: LD_ADDR_VAR 0 2
10260: PUSH
10261: LD_INT 22
10263: PUSH
10264: LD_INT 1
10266: PUSH
10267: EMPTY
10268: LIST
10269: LIST
10270: PUSH
10271: LD_INT 2
10273: PUSH
10274: LD_INT 21
10276: PUSH
10277: LD_INT 1
10279: PUSH
10280: EMPTY
10281: LIST
10282: LIST
10283: PUSH
10284: LD_INT 34
10286: PUSH
10287: LD_INT 12
10289: PUSH
10290: EMPTY
10291: LIST
10292: LIST
10293: PUSH
10294: EMPTY
10295: LIST
10296: LIST
10297: LIST
10298: PUSH
10299: EMPTY
10300: LIST
10301: LIST
10302: PPUSH
10303: CALL_OW 69
10307: PUSH
10308: FOR_IN
10309: IFFALSE 10431
// begin if GetTaskList ( i ) > 0 then
10311: LD_VAR 0 2
10315: PPUSH
10316: CALL_OW 437
10320: PUSH
10321: LD_INT 0
10323: GREATER
10324: IFFALSE 10429
// for j = 1 to GetTaskList ( i ) do
10326: LD_ADDR_VAR 0 3
10330: PUSH
10331: DOUBLE
10332: LD_INT 1
10334: DEC
10335: ST_TO_ADDR
10336: LD_VAR 0 2
10340: PPUSH
10341: CALL_OW 437
10345: PUSH
10346: FOR_TO
10347: IFFALSE 10427
// begin temp = GetTaskList ( i ) [ j ] [ 4 ] ;
10349: LD_ADDR_VAR 0 4
10353: PUSH
10354: LD_VAR 0 2
10358: PPUSH
10359: CALL_OW 437
10363: PUSH
10364: LD_VAR 0 3
10368: ARRAY
10369: PUSH
10370: LD_INT 4
10372: ARRAY
10373: ST_TO_ADDR
// if GetSide ( temp ) = 4 and GetTaskList ( i ) [ j ] [ 1 ] = < then
10374: LD_VAR 0 4
10378: PPUSH
10379: CALL_OW 255
10383: PUSH
10384: LD_INT 4
10386: EQUAL
10387: PUSH
10388: LD_VAR 0 2
10392: PPUSH
10393: CALL_OW 437
10397: PUSH
10398: LD_VAR 0 3
10402: ARRAY
10403: PUSH
10404: LD_INT 1
10406: ARRAY
10407: PUSH
10408: LD_STRING <
10410: EQUAL
10411: AND
10412: IFFALSE 10425
// SetTaskList ( i , [ ] ) ;
10414: LD_VAR 0 2
10418: PPUSH
10419: EMPTY
10420: PPUSH
10421: CALL_OW 446
// end ;
10425: GO 10346
10427: POP
10428: POP
// end ;
10429: GO 10308
10431: POP
10432: POP
// end ; end ;
10433: PPOPN 4
10435: END
// on SibDepositContaminated ( sci , x , y ) do begin if GetSide ( HexInfo ( x , y ) ) = 1 or ( x = 132 and y = 39 ) then
10436: LD_VAR 0 2
10440: PPUSH
10441: LD_VAR 0 3
10445: PPUSH
10446: CALL_OW 428
10450: PPUSH
10451: CALL_OW 255
10455: PUSH
10456: LD_INT 1
10458: EQUAL
10459: PUSH
10460: LD_VAR 0 2
10464: PUSH
10465: LD_INT 132
10467: EQUAL
10468: PUSH
10469: LD_VAR 0 3
10473: PUSH
10474: LD_INT 39
10476: EQUAL
10477: AND
10478: OR
10479: IFFALSE 10495
// DialogContaminateSib ( x , y ) ;
10481: LD_VAR 0 2
10485: PPUSH
10486: LD_VAR 0 3
10490: PPUSH
10491: CALL 9609 0 2
// end ;
10495: PPOPN 3
10497: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
10498: LD_VAR 0 1
10502: PPUSH
10503: CALL 90109 0 1
// MCE_UnitDestroyed ( un ) ;
10507: LD_VAR 0 1
10511: PPUSH
10512: CALL 79824 0 1
// if un = Powell then
10516: LD_VAR 0 1
10520: PUSH
10521: LD_EXP 10
10525: EQUAL
10526: IFFALSE 10535
// YouLost ( Powell ) ;
10528: LD_STRING Powell
10530: PPUSH
10531: CALL_OW 104
// if un = Sikorski then
10535: LD_VAR 0 1
10539: PUSH
10540: LD_EXP 20
10544: EQUAL
10545: IFFALSE 10554
// YouLost ( Sikorski ) ;
10547: LD_STRING Sikorski
10549: PPUSH
10550: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) then
10554: LD_VAR 0 1
10558: PUSH
10559: LD_INT 22
10561: PUSH
10562: LD_INT 1
10564: PUSH
10565: EMPTY
10566: LIST
10567: LIST
10568: PUSH
10569: LD_INT 21
10571: PUSH
10572: LD_INT 1
10574: PUSH
10575: EMPTY
10576: LIST
10577: LIST
10578: PUSH
10579: EMPTY
10580: LIST
10581: LIST
10582: PPUSH
10583: CALL_OW 69
10587: IN
10588: IFFALSE 10604
// loseCounter := loseCounter + 1 ;
10590: LD_ADDR_EXP 6
10594: PUSH
10595: LD_EXP 6
10599: PUSH
10600: LD_INT 1
10602: PLUS
10603: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) then
10604: LD_VAR 0 1
10608: PUSH
10609: LD_INT 22
10611: PUSH
10612: LD_INT 4
10614: PUSH
10615: EMPTY
10616: LIST
10617: LIST
10618: PUSH
10619: LD_INT 21
10621: PUSH
10622: LD_INT 1
10624: PUSH
10625: EMPTY
10626: LIST
10627: LIST
10628: PUSH
10629: EMPTY
10630: LIST
10631: LIST
10632: PPUSH
10633: CALL_OW 69
10637: IN
10638: IFFALSE 10654
// powellLoseCounter := powellLoseCounter + 1 ;
10640: LD_ADDR_EXP 7
10644: PUSH
10645: LD_EXP 7
10649: PUSH
10650: LD_INT 1
10652: PLUS
10653: ST_TO_ADDR
// if un in powellAttackGroup then
10654: LD_VAR 0 1
10658: PUSH
10659: LD_EXP 12
10663: IN
10664: IFFALSE 10682
// powellAttackGroup := powellAttackGroup diff un ;
10666: LD_ADDR_EXP 12
10670: PUSH
10671: LD_EXP 12
10675: PUSH
10676: LD_VAR 0 1
10680: DIFF
10681: ST_TO_ADDR
// if un in gensherAttackGroup then
10682: LD_VAR 0 1
10686: PUSH
10687: LD_EXP 15
10691: IN
10692: IFFALSE 10710
// gensherAttackGroup := gensherAttackGroup diff un ;
10694: LD_ADDR_EXP 15
10698: PUSH
10699: LD_EXP 15
10703: PUSH
10704: LD_VAR 0 1
10708: DIFF
10709: ST_TO_ADDR
// if un in popovAttackGroup then
10710: LD_VAR 0 1
10714: PUSH
10715: LD_EXP 19
10719: IN
10720: IFFALSE 10738
// popovAttackGroup := popovAttackGroup diff un ;
10722: LD_ADDR_EXP 19
10726: PUSH
10727: LD_EXP 19
10731: PUSH
10732: LD_VAR 0 1
10736: DIFF
10737: ST_TO_ADDR
// end ;
10738: PPOPN 1
10740: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10741: LD_VAR 0 1
10745: PPUSH
10746: LD_VAR 0 2
10750: PPUSH
10751: CALL 82156 0 2
// end ;
10755: PPOPN 2
10757: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10758: LD_VAR 0 1
10762: PPUSH
10763: CALL 81224 0 1
// end ;
10767: PPOPN 1
10769: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
10770: LD_VAR 0 1
10774: PPUSH
10775: CALL 81465 0 1
// end ;
10779: PPOPN 1
10781: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10782: LD_VAR 0 1
10786: PPUSH
10787: LD_VAR 0 2
10791: PPUSH
10792: CALL 79520 0 2
// end ;
10796: PPOPN 2
10798: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10799: LD_VAR 0 1
10803: PPUSH
10804: LD_VAR 0 2
10808: PPUSH
10809: LD_VAR 0 3
10813: PPUSH
10814: LD_VAR 0 4
10818: PPUSH
10819: LD_VAR 0 5
10823: PPUSH
10824: CALL 79140 0 5
// end ;
10828: PPOPN 5
10830: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
10831: LD_VAR 0 1
10835: PPUSH
10836: LD_VAR 0 2
10840: PPUSH
10841: CALL 90229 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
10845: LD_VAR 0 1
10849: PPUSH
10850: LD_VAR 0 2
10854: PPUSH
10855: CALL 78731 0 2
// end ;
10859: PPOPN 2
10861: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10862: LD_VAR 0 1
10866: PPUSH
10867: LD_VAR 0 2
10871: PPUSH
10872: LD_VAR 0 3
10876: PPUSH
10877: LD_VAR 0 4
10881: PPUSH
10882: CALL 78569 0 4
// end ;
10886: PPOPN 4
10888: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10889: LD_VAR 0 1
10893: PPUSH
10894: LD_VAR 0 2
10898: PPUSH
10899: LD_VAR 0 3
10903: PPUSH
10904: CALL 78344 0 3
// end ;
10908: PPOPN 3
10910: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10911: LD_VAR 0 1
10915: PPUSH
10916: LD_VAR 0 2
10920: PPUSH
10921: CALL 78229 0 2
// end ;
10925: PPOPN 2
10927: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10928: LD_VAR 0 1
10932: PPUSH
10933: LD_VAR 0 2
10937: PPUSH
10938: CALL 82451 0 2
// end ;
10942: PPOPN 2
10944: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10945: LD_VAR 0 1
10949: PPUSH
10950: LD_VAR 0 2
10954: PPUSH
10955: LD_VAR 0 3
10959: PPUSH
10960: LD_VAR 0 4
10964: PPUSH
10965: CALL 82667 0 4
// end ;
10969: PPOPN 4
10971: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10972: LD_VAR 0 1
10976: PPUSH
10977: LD_VAR 0 2
10981: PPUSH
10982: CALL 78038 0 2
// end ;
10986: PPOPN 2
10988: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 then
10989: LD_VAR 0 1
10993: PUSH
10994: LD_INT 1
10996: EQUAL
10997: PUSH
10998: LD_VAR 0 2
11002: PUSH
11003: LD_INT 4
11005: EQUAL
11006: AND
11007: IFFALSE 11016
// YouLost ( FriendlyFire ) ;
11009: LD_STRING FriendlyFire
11011: PPUSH
11012: CALL_OW 104
// end ; end_of_file
11016: PPOPN 2
11018: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
11019: LD_INT 0
11021: PPUSH
11022: PPUSH
// if exist_mode then
11023: LD_VAR 0 2
11027: IFFALSE 11052
// unit := CreateCharacter ( prefix & ident ) else
11029: LD_ADDR_VAR 0 5
11033: PUSH
11034: LD_VAR 0 3
11038: PUSH
11039: LD_VAR 0 1
11043: STR
11044: PPUSH
11045: CALL_OW 34
11049: ST_TO_ADDR
11050: GO 11067
// unit := NewCharacter ( ident ) ;
11052: LD_ADDR_VAR 0 5
11056: PUSH
11057: LD_VAR 0 1
11061: PPUSH
11062: CALL_OW 25
11066: ST_TO_ADDR
// result := unit ;
11067: LD_ADDR_VAR 0 4
11071: PUSH
11072: LD_VAR 0 5
11076: ST_TO_ADDR
// end ;
11077: LD_VAR 0 4
11081: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
11082: LD_INT 0
11084: PPUSH
11085: PPUSH
// if not side or not nation then
11086: LD_VAR 0 1
11090: NOT
11091: PUSH
11092: LD_VAR 0 2
11096: NOT
11097: OR
11098: IFFALSE 11102
// exit ;
11100: GO 11870
// case nation of nation_american :
11102: LD_VAR 0 2
11106: PUSH
11107: LD_INT 1
11109: DOUBLE
11110: EQUAL
11111: IFTRUE 11115
11113: GO 11329
11115: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
11116: LD_ADDR_VAR 0 4
11120: PUSH
11121: LD_INT 35
11123: PUSH
11124: LD_INT 45
11126: PUSH
11127: LD_INT 46
11129: PUSH
11130: LD_INT 47
11132: PUSH
11133: LD_INT 82
11135: PUSH
11136: LD_INT 83
11138: PUSH
11139: LD_INT 84
11141: PUSH
11142: LD_INT 85
11144: PUSH
11145: LD_INT 86
11147: PUSH
11148: LD_INT 1
11150: PUSH
11151: LD_INT 2
11153: PUSH
11154: LD_INT 6
11156: PUSH
11157: LD_INT 15
11159: PUSH
11160: LD_INT 16
11162: PUSH
11163: LD_INT 7
11165: PUSH
11166: LD_INT 12
11168: PUSH
11169: LD_INT 13
11171: PUSH
11172: LD_INT 10
11174: PUSH
11175: LD_INT 14
11177: PUSH
11178: LD_INT 20
11180: PUSH
11181: LD_INT 21
11183: PUSH
11184: LD_INT 22
11186: PUSH
11187: LD_INT 25
11189: PUSH
11190: LD_INT 32
11192: PUSH
11193: LD_INT 27
11195: PUSH
11196: LD_INT 36
11198: PUSH
11199: LD_INT 69
11201: PUSH
11202: LD_INT 39
11204: PUSH
11205: LD_INT 34
11207: PUSH
11208: LD_INT 40
11210: PUSH
11211: LD_INT 48
11213: PUSH
11214: LD_INT 49
11216: PUSH
11217: LD_INT 50
11219: PUSH
11220: LD_INT 51
11222: PUSH
11223: LD_INT 52
11225: PUSH
11226: LD_INT 53
11228: PUSH
11229: LD_INT 54
11231: PUSH
11232: LD_INT 55
11234: PUSH
11235: LD_INT 56
11237: PUSH
11238: LD_INT 57
11240: PUSH
11241: LD_INT 58
11243: PUSH
11244: LD_INT 59
11246: PUSH
11247: LD_INT 60
11249: PUSH
11250: LD_INT 61
11252: PUSH
11253: LD_INT 62
11255: PUSH
11256: LD_INT 80
11258: PUSH
11259: LD_INT 82
11261: PUSH
11262: LD_INT 83
11264: PUSH
11265: LD_INT 84
11267: PUSH
11268: LD_INT 85
11270: PUSH
11271: LD_INT 86
11273: PUSH
11274: EMPTY
11275: LIST
11276: LIST
11277: LIST
11278: LIST
11279: LIST
11280: LIST
11281: LIST
11282: LIST
11283: LIST
11284: LIST
11285: LIST
11286: LIST
11287: LIST
11288: LIST
11289: LIST
11290: LIST
11291: LIST
11292: LIST
11293: LIST
11294: LIST
11295: LIST
11296: LIST
11297: LIST
11298: LIST
11299: LIST
11300: LIST
11301: LIST
11302: LIST
11303: LIST
11304: LIST
11305: LIST
11306: LIST
11307: LIST
11308: LIST
11309: LIST
11310: LIST
11311: LIST
11312: LIST
11313: LIST
11314: LIST
11315: LIST
11316: LIST
11317: LIST
11318: LIST
11319: LIST
11320: LIST
11321: LIST
11322: LIST
11323: LIST
11324: LIST
11325: LIST
11326: ST_TO_ADDR
11327: GO 11794
11329: LD_INT 2
11331: DOUBLE
11332: EQUAL
11333: IFTRUE 11337
11335: GO 11563
11337: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
11338: LD_ADDR_VAR 0 4
11342: PUSH
11343: LD_INT 35
11345: PUSH
11346: LD_INT 45
11348: PUSH
11349: LD_INT 46
11351: PUSH
11352: LD_INT 47
11354: PUSH
11355: LD_INT 82
11357: PUSH
11358: LD_INT 83
11360: PUSH
11361: LD_INT 84
11363: PUSH
11364: LD_INT 85
11366: PUSH
11367: LD_INT 87
11369: PUSH
11370: LD_INT 70
11372: PUSH
11373: LD_INT 1
11375: PUSH
11376: LD_INT 11
11378: PUSH
11379: LD_INT 3
11381: PUSH
11382: LD_INT 4
11384: PUSH
11385: LD_INT 5
11387: PUSH
11388: LD_INT 6
11390: PUSH
11391: LD_INT 15
11393: PUSH
11394: LD_INT 18
11396: PUSH
11397: LD_INT 7
11399: PUSH
11400: LD_INT 17
11402: PUSH
11403: LD_INT 8
11405: PUSH
11406: LD_INT 20
11408: PUSH
11409: LD_INT 21
11411: PUSH
11412: LD_INT 22
11414: PUSH
11415: LD_INT 72
11417: PUSH
11418: LD_INT 26
11420: PUSH
11421: LD_INT 69
11423: PUSH
11424: LD_INT 39
11426: PUSH
11427: LD_INT 40
11429: PUSH
11430: LD_INT 41
11432: PUSH
11433: LD_INT 42
11435: PUSH
11436: LD_INT 43
11438: PUSH
11439: LD_INT 48
11441: PUSH
11442: LD_INT 49
11444: PUSH
11445: LD_INT 50
11447: PUSH
11448: LD_INT 51
11450: PUSH
11451: LD_INT 52
11453: PUSH
11454: LD_INT 53
11456: PUSH
11457: LD_INT 54
11459: PUSH
11460: LD_INT 55
11462: PUSH
11463: LD_INT 56
11465: PUSH
11466: LD_INT 60
11468: PUSH
11469: LD_INT 61
11471: PUSH
11472: LD_INT 62
11474: PUSH
11475: LD_INT 66
11477: PUSH
11478: LD_INT 67
11480: PUSH
11481: LD_INT 68
11483: PUSH
11484: LD_INT 81
11486: PUSH
11487: LD_INT 82
11489: PUSH
11490: LD_INT 83
11492: PUSH
11493: LD_INT 84
11495: PUSH
11496: LD_INT 85
11498: PUSH
11499: LD_INT 87
11501: PUSH
11502: LD_INT 88
11504: PUSH
11505: EMPTY
11506: LIST
11507: LIST
11508: LIST
11509: LIST
11510: LIST
11511: LIST
11512: LIST
11513: LIST
11514: LIST
11515: LIST
11516: LIST
11517: LIST
11518: LIST
11519: LIST
11520: LIST
11521: LIST
11522: LIST
11523: LIST
11524: LIST
11525: LIST
11526: LIST
11527: LIST
11528: LIST
11529: LIST
11530: LIST
11531: LIST
11532: LIST
11533: LIST
11534: LIST
11535: LIST
11536: LIST
11537: LIST
11538: LIST
11539: LIST
11540: LIST
11541: LIST
11542: LIST
11543: LIST
11544: LIST
11545: LIST
11546: LIST
11547: LIST
11548: LIST
11549: LIST
11550: LIST
11551: LIST
11552: LIST
11553: LIST
11554: LIST
11555: LIST
11556: LIST
11557: LIST
11558: LIST
11559: LIST
11560: ST_TO_ADDR
11561: GO 11794
11563: LD_INT 3
11565: DOUBLE
11566: EQUAL
11567: IFTRUE 11571
11569: GO 11793
11571: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
11572: LD_ADDR_VAR 0 4
11576: PUSH
11577: LD_INT 46
11579: PUSH
11580: LD_INT 47
11582: PUSH
11583: LD_INT 1
11585: PUSH
11586: LD_INT 2
11588: PUSH
11589: LD_INT 82
11591: PUSH
11592: LD_INT 83
11594: PUSH
11595: LD_INT 84
11597: PUSH
11598: LD_INT 85
11600: PUSH
11601: LD_INT 86
11603: PUSH
11604: LD_INT 11
11606: PUSH
11607: LD_INT 9
11609: PUSH
11610: LD_INT 20
11612: PUSH
11613: LD_INT 19
11615: PUSH
11616: LD_INT 21
11618: PUSH
11619: LD_INT 24
11621: PUSH
11622: LD_INT 22
11624: PUSH
11625: LD_INT 25
11627: PUSH
11628: LD_INT 28
11630: PUSH
11631: LD_INT 29
11633: PUSH
11634: LD_INT 30
11636: PUSH
11637: LD_INT 31
11639: PUSH
11640: LD_INT 37
11642: PUSH
11643: LD_INT 38
11645: PUSH
11646: LD_INT 32
11648: PUSH
11649: LD_INT 27
11651: PUSH
11652: LD_INT 33
11654: PUSH
11655: LD_INT 69
11657: PUSH
11658: LD_INT 39
11660: PUSH
11661: LD_INT 34
11663: PUSH
11664: LD_INT 40
11666: PUSH
11667: LD_INT 71
11669: PUSH
11670: LD_INT 23
11672: PUSH
11673: LD_INT 44
11675: PUSH
11676: LD_INT 48
11678: PUSH
11679: LD_INT 49
11681: PUSH
11682: LD_INT 50
11684: PUSH
11685: LD_INT 51
11687: PUSH
11688: LD_INT 52
11690: PUSH
11691: LD_INT 53
11693: PUSH
11694: LD_INT 54
11696: PUSH
11697: LD_INT 55
11699: PUSH
11700: LD_INT 56
11702: PUSH
11703: LD_INT 57
11705: PUSH
11706: LD_INT 58
11708: PUSH
11709: LD_INT 59
11711: PUSH
11712: LD_INT 63
11714: PUSH
11715: LD_INT 64
11717: PUSH
11718: LD_INT 65
11720: PUSH
11721: LD_INT 82
11723: PUSH
11724: LD_INT 83
11726: PUSH
11727: LD_INT 84
11729: PUSH
11730: LD_INT 85
11732: PUSH
11733: LD_INT 86
11735: PUSH
11736: EMPTY
11737: LIST
11738: LIST
11739: LIST
11740: LIST
11741: LIST
11742: LIST
11743: LIST
11744: LIST
11745: LIST
11746: LIST
11747: LIST
11748: LIST
11749: LIST
11750: LIST
11751: LIST
11752: LIST
11753: LIST
11754: LIST
11755: LIST
11756: LIST
11757: LIST
11758: LIST
11759: LIST
11760: LIST
11761: LIST
11762: LIST
11763: LIST
11764: LIST
11765: LIST
11766: LIST
11767: LIST
11768: LIST
11769: LIST
11770: LIST
11771: LIST
11772: LIST
11773: LIST
11774: LIST
11775: LIST
11776: LIST
11777: LIST
11778: LIST
11779: LIST
11780: LIST
11781: LIST
11782: LIST
11783: LIST
11784: LIST
11785: LIST
11786: LIST
11787: LIST
11788: LIST
11789: LIST
11790: ST_TO_ADDR
11791: GO 11794
11793: POP
// if state > - 1 and state < 3 then
11794: LD_VAR 0 3
11798: PUSH
11799: LD_INT 1
11801: NEG
11802: GREATER
11803: PUSH
11804: LD_VAR 0 3
11808: PUSH
11809: LD_INT 3
11811: LESS
11812: AND
11813: IFFALSE 11870
// for i in result do
11815: LD_ADDR_VAR 0 5
11819: PUSH
11820: LD_VAR 0 4
11824: PUSH
11825: FOR_IN
11826: IFFALSE 11868
// if GetTech ( i , side ) <> state then
11828: LD_VAR 0 5
11832: PPUSH
11833: LD_VAR 0 1
11837: PPUSH
11838: CALL_OW 321
11842: PUSH
11843: LD_VAR 0 3
11847: NONEQUAL
11848: IFFALSE 11866
// result := result diff i ;
11850: LD_ADDR_VAR 0 4
11854: PUSH
11855: LD_VAR 0 4
11859: PUSH
11860: LD_VAR 0 5
11864: DIFF
11865: ST_TO_ADDR
11866: GO 11825
11868: POP
11869: POP
// end ;
11870: LD_VAR 0 4
11874: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
11875: LD_INT 0
11877: PPUSH
11878: PPUSH
11879: PPUSH
// result := true ;
11880: LD_ADDR_VAR 0 3
11884: PUSH
11885: LD_INT 1
11887: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
11888: LD_ADDR_VAR 0 5
11892: PUSH
11893: LD_VAR 0 2
11897: PPUSH
11898: CALL_OW 480
11902: ST_TO_ADDR
// if not tmp then
11903: LD_VAR 0 5
11907: NOT
11908: IFFALSE 11912
// exit ;
11910: GO 11961
// for i in tmp do
11912: LD_ADDR_VAR 0 4
11916: PUSH
11917: LD_VAR 0 5
11921: PUSH
11922: FOR_IN
11923: IFFALSE 11959
// if GetTech ( i , side ) <> state_researched then
11925: LD_VAR 0 4
11929: PPUSH
11930: LD_VAR 0 1
11934: PPUSH
11935: CALL_OW 321
11939: PUSH
11940: LD_INT 2
11942: NONEQUAL
11943: IFFALSE 11957
// begin result := false ;
11945: LD_ADDR_VAR 0 3
11949: PUSH
11950: LD_INT 0
11952: ST_TO_ADDR
// exit ;
11953: POP
11954: POP
11955: GO 11961
// end ;
11957: GO 11922
11959: POP
11960: POP
// end ;
11961: LD_VAR 0 3
11965: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
11966: LD_INT 0
11968: PPUSH
11969: PPUSH
11970: PPUSH
11971: PPUSH
11972: PPUSH
11973: PPUSH
11974: PPUSH
11975: PPUSH
11976: PPUSH
11977: PPUSH
11978: PPUSH
11979: PPUSH
11980: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
11981: LD_VAR 0 1
11985: NOT
11986: PUSH
11987: LD_VAR 0 1
11991: PPUSH
11992: CALL_OW 257
11996: PUSH
11997: LD_INT 9
11999: NONEQUAL
12000: OR
12001: IFFALSE 12005
// exit ;
12003: GO 12578
// side := GetSide ( unit ) ;
12005: LD_ADDR_VAR 0 9
12009: PUSH
12010: LD_VAR 0 1
12014: PPUSH
12015: CALL_OW 255
12019: ST_TO_ADDR
// tech_space := tech_spacanom ;
12020: LD_ADDR_VAR 0 12
12024: PUSH
12025: LD_INT 29
12027: ST_TO_ADDR
// tech_time := tech_taurad ;
12028: LD_ADDR_VAR 0 13
12032: PUSH
12033: LD_INT 28
12035: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
12036: LD_ADDR_VAR 0 11
12040: PUSH
12041: LD_VAR 0 1
12045: PPUSH
12046: CALL_OW 310
12050: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
12051: LD_VAR 0 11
12055: PPUSH
12056: CALL_OW 247
12060: PUSH
12061: LD_INT 2
12063: EQUAL
12064: IFFALSE 12068
// exit ;
12066: GO 12578
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
12068: LD_ADDR_VAR 0 8
12072: PUSH
12073: LD_INT 81
12075: PUSH
12076: LD_VAR 0 9
12080: PUSH
12081: EMPTY
12082: LIST
12083: LIST
12084: PUSH
12085: LD_INT 3
12087: PUSH
12088: LD_INT 21
12090: PUSH
12091: LD_INT 3
12093: PUSH
12094: EMPTY
12095: LIST
12096: LIST
12097: PUSH
12098: EMPTY
12099: LIST
12100: LIST
12101: PUSH
12102: EMPTY
12103: LIST
12104: LIST
12105: PPUSH
12106: CALL_OW 69
12110: ST_TO_ADDR
// if not tmp then
12111: LD_VAR 0 8
12115: NOT
12116: IFFALSE 12120
// exit ;
12118: GO 12578
// if in_unit then
12120: LD_VAR 0 11
12124: IFFALSE 12148
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
12126: LD_ADDR_VAR 0 10
12130: PUSH
12131: LD_VAR 0 8
12135: PPUSH
12136: LD_VAR 0 11
12140: PPUSH
12141: CALL_OW 74
12145: ST_TO_ADDR
12146: GO 12168
// enemy := NearestUnitToUnit ( tmp , unit ) ;
12148: LD_ADDR_VAR 0 10
12152: PUSH
12153: LD_VAR 0 8
12157: PPUSH
12158: LD_VAR 0 1
12162: PPUSH
12163: CALL_OW 74
12167: ST_TO_ADDR
// if not enemy then
12168: LD_VAR 0 10
12172: NOT
12173: IFFALSE 12177
// exit ;
12175: GO 12578
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
12177: LD_VAR 0 11
12181: PUSH
12182: LD_VAR 0 11
12186: PPUSH
12187: LD_VAR 0 10
12191: PPUSH
12192: CALL_OW 296
12196: PUSH
12197: LD_INT 13
12199: GREATER
12200: AND
12201: PUSH
12202: LD_VAR 0 1
12206: PPUSH
12207: LD_VAR 0 10
12211: PPUSH
12212: CALL_OW 296
12216: PUSH
12217: LD_INT 12
12219: GREATER
12220: OR
12221: IFFALSE 12225
// exit ;
12223: GO 12578
// missile := [ 1 ] ;
12225: LD_ADDR_VAR 0 14
12229: PUSH
12230: LD_INT 1
12232: PUSH
12233: EMPTY
12234: LIST
12235: ST_TO_ADDR
// if Researched ( side , tech_space ) then
12236: LD_VAR 0 9
12240: PPUSH
12241: LD_VAR 0 12
12245: PPUSH
12246: CALL_OW 325
12250: IFFALSE 12279
// missile := Replace ( missile , missile + 1 , 2 ) ;
12252: LD_ADDR_VAR 0 14
12256: PUSH
12257: LD_VAR 0 14
12261: PPUSH
12262: LD_VAR 0 14
12266: PUSH
12267: LD_INT 1
12269: PLUS
12270: PPUSH
12271: LD_INT 2
12273: PPUSH
12274: CALL_OW 1
12278: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
12279: LD_VAR 0 9
12283: PPUSH
12284: LD_VAR 0 13
12288: PPUSH
12289: CALL_OW 325
12293: PUSH
12294: LD_VAR 0 10
12298: PPUSH
12299: CALL_OW 255
12303: PPUSH
12304: LD_VAR 0 13
12308: PPUSH
12309: CALL_OW 325
12313: NOT
12314: AND
12315: IFFALSE 12344
// missile := Replace ( missile , missile + 1 , 3 ) ;
12317: LD_ADDR_VAR 0 14
12321: PUSH
12322: LD_VAR 0 14
12326: PPUSH
12327: LD_VAR 0 14
12331: PUSH
12332: LD_INT 1
12334: PLUS
12335: PPUSH
12336: LD_INT 3
12338: PPUSH
12339: CALL_OW 1
12343: ST_TO_ADDR
// if missile < 2 then
12344: LD_VAR 0 14
12348: PUSH
12349: LD_INT 2
12351: LESS
12352: IFFALSE 12356
// exit ;
12354: GO 12578
// x := GetX ( enemy ) ;
12356: LD_ADDR_VAR 0 4
12360: PUSH
12361: LD_VAR 0 10
12365: PPUSH
12366: CALL_OW 250
12370: ST_TO_ADDR
// y := GetY ( enemy ) ;
12371: LD_ADDR_VAR 0 5
12375: PUSH
12376: LD_VAR 0 10
12380: PPUSH
12381: CALL_OW 251
12385: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
12386: LD_ADDR_VAR 0 6
12390: PUSH
12391: LD_VAR 0 4
12395: PUSH
12396: LD_INT 1
12398: NEG
12399: PPUSH
12400: LD_INT 1
12402: PPUSH
12403: CALL_OW 12
12407: PLUS
12408: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
12409: LD_ADDR_VAR 0 7
12413: PUSH
12414: LD_VAR 0 5
12418: PUSH
12419: LD_INT 1
12421: NEG
12422: PPUSH
12423: LD_INT 1
12425: PPUSH
12426: CALL_OW 12
12430: PLUS
12431: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
12432: LD_VAR 0 6
12436: PPUSH
12437: LD_VAR 0 7
12441: PPUSH
12442: CALL_OW 488
12446: NOT
12447: IFFALSE 12469
// begin _x := x ;
12449: LD_ADDR_VAR 0 6
12453: PUSH
12454: LD_VAR 0 4
12458: ST_TO_ADDR
// _y := y ;
12459: LD_ADDR_VAR 0 7
12463: PUSH
12464: LD_VAR 0 5
12468: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
12469: LD_ADDR_VAR 0 3
12473: PUSH
12474: LD_INT 1
12476: PPUSH
12477: LD_VAR 0 14
12481: PPUSH
12482: CALL_OW 12
12486: ST_TO_ADDR
// case i of 1 :
12487: LD_VAR 0 3
12491: PUSH
12492: LD_INT 1
12494: DOUBLE
12495: EQUAL
12496: IFTRUE 12500
12498: GO 12517
12500: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
12501: LD_VAR 0 1
12505: PPUSH
12506: LD_VAR 0 10
12510: PPUSH
12511: CALL_OW 115
12515: GO 12578
12517: LD_INT 2
12519: DOUBLE
12520: EQUAL
12521: IFTRUE 12525
12523: GO 12547
12525: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
12526: LD_VAR 0 1
12530: PPUSH
12531: LD_VAR 0 6
12535: PPUSH
12536: LD_VAR 0 7
12540: PPUSH
12541: CALL_OW 153
12545: GO 12578
12547: LD_INT 3
12549: DOUBLE
12550: EQUAL
12551: IFTRUE 12555
12553: GO 12577
12555: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
12556: LD_VAR 0 1
12560: PPUSH
12561: LD_VAR 0 6
12565: PPUSH
12566: LD_VAR 0 7
12570: PPUSH
12571: CALL_OW 154
12575: GO 12578
12577: POP
// end ;
12578: LD_VAR 0 2
12582: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
12583: LD_INT 0
12585: PPUSH
12586: PPUSH
12587: PPUSH
12588: PPUSH
12589: PPUSH
12590: PPUSH
// if not unit or not building then
12591: LD_VAR 0 1
12595: NOT
12596: PUSH
12597: LD_VAR 0 2
12601: NOT
12602: OR
12603: IFFALSE 12607
// exit ;
12605: GO 12765
// x := GetX ( building ) ;
12607: LD_ADDR_VAR 0 5
12611: PUSH
12612: LD_VAR 0 2
12616: PPUSH
12617: CALL_OW 250
12621: ST_TO_ADDR
// y := GetY ( building ) ;
12622: LD_ADDR_VAR 0 6
12626: PUSH
12627: LD_VAR 0 2
12631: PPUSH
12632: CALL_OW 251
12636: ST_TO_ADDR
// for i = 0 to 5 do
12637: LD_ADDR_VAR 0 4
12641: PUSH
12642: DOUBLE
12643: LD_INT 0
12645: DEC
12646: ST_TO_ADDR
12647: LD_INT 5
12649: PUSH
12650: FOR_TO
12651: IFFALSE 12763
// begin _x := ShiftX ( x , i , 3 ) ;
12653: LD_ADDR_VAR 0 7
12657: PUSH
12658: LD_VAR 0 5
12662: PPUSH
12663: LD_VAR 0 4
12667: PPUSH
12668: LD_INT 3
12670: PPUSH
12671: CALL_OW 272
12675: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
12676: LD_ADDR_VAR 0 8
12680: PUSH
12681: LD_VAR 0 6
12685: PPUSH
12686: LD_VAR 0 4
12690: PPUSH
12691: LD_INT 3
12693: PPUSH
12694: CALL_OW 273
12698: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
12699: LD_VAR 0 7
12703: PPUSH
12704: LD_VAR 0 8
12708: PPUSH
12709: CALL_OW 488
12713: NOT
12714: IFFALSE 12718
// continue ;
12716: GO 12650
// if HexInfo ( _x , _y ) = 0 then
12718: LD_VAR 0 7
12722: PPUSH
12723: LD_VAR 0 8
12727: PPUSH
12728: CALL_OW 428
12732: PUSH
12733: LD_INT 0
12735: EQUAL
12736: IFFALSE 12761
// begin ComMoveXY ( unit , _x , _y ) ;
12738: LD_VAR 0 1
12742: PPUSH
12743: LD_VAR 0 7
12747: PPUSH
12748: LD_VAR 0 8
12752: PPUSH
12753: CALL_OW 111
// exit ;
12757: POP
12758: POP
12759: GO 12765
// end ; end ;
12761: GO 12650
12763: POP
12764: POP
// end ;
12765: LD_VAR 0 3
12769: RET
// export function ScanBase ( side , base_area ) ; begin
12770: LD_INT 0
12772: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
12773: LD_ADDR_VAR 0 3
12777: PUSH
12778: LD_VAR 0 2
12782: PPUSH
12783: LD_INT 81
12785: PUSH
12786: LD_VAR 0 1
12790: PUSH
12791: EMPTY
12792: LIST
12793: LIST
12794: PPUSH
12795: CALL_OW 70
12799: ST_TO_ADDR
// end ;
12800: LD_VAR 0 3
12804: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
12805: LD_INT 0
12807: PPUSH
12808: PPUSH
12809: PPUSH
12810: PPUSH
// result := false ;
12811: LD_ADDR_VAR 0 2
12815: PUSH
12816: LD_INT 0
12818: ST_TO_ADDR
// side := GetSide ( unit ) ;
12819: LD_ADDR_VAR 0 3
12823: PUSH
12824: LD_VAR 0 1
12828: PPUSH
12829: CALL_OW 255
12833: ST_TO_ADDR
// nat := GetNation ( unit ) ;
12834: LD_ADDR_VAR 0 4
12838: PUSH
12839: LD_VAR 0 1
12843: PPUSH
12844: CALL_OW 248
12848: ST_TO_ADDR
// case nat of 1 :
12849: LD_VAR 0 4
12853: PUSH
12854: LD_INT 1
12856: DOUBLE
12857: EQUAL
12858: IFTRUE 12862
12860: GO 12873
12862: POP
// tech := tech_lassight ; 2 :
12863: LD_ADDR_VAR 0 5
12867: PUSH
12868: LD_INT 12
12870: ST_TO_ADDR
12871: GO 12912
12873: LD_INT 2
12875: DOUBLE
12876: EQUAL
12877: IFTRUE 12881
12879: GO 12892
12881: POP
// tech := tech_mortar ; 3 :
12882: LD_ADDR_VAR 0 5
12886: PUSH
12887: LD_INT 41
12889: ST_TO_ADDR
12890: GO 12912
12892: LD_INT 3
12894: DOUBLE
12895: EQUAL
12896: IFTRUE 12900
12898: GO 12911
12900: POP
// tech := tech_bazooka ; end ;
12901: LD_ADDR_VAR 0 5
12905: PUSH
12906: LD_INT 44
12908: ST_TO_ADDR
12909: GO 12912
12911: POP
// if Researched ( side , tech ) then
12912: LD_VAR 0 3
12916: PPUSH
12917: LD_VAR 0 5
12921: PPUSH
12922: CALL_OW 325
12926: IFFALSE 12953
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
12928: LD_ADDR_VAR 0 2
12932: PUSH
12933: LD_INT 5
12935: PUSH
12936: LD_INT 8
12938: PUSH
12939: LD_INT 9
12941: PUSH
12942: EMPTY
12943: LIST
12944: LIST
12945: LIST
12946: PUSH
12947: LD_VAR 0 4
12951: ARRAY
12952: ST_TO_ADDR
// end ;
12953: LD_VAR 0 2
12957: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
12958: LD_INT 0
12960: PPUSH
12961: PPUSH
12962: PPUSH
// if not mines then
12963: LD_VAR 0 2
12967: NOT
12968: IFFALSE 12972
// exit ;
12970: GO 13116
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
12972: LD_ADDR_VAR 0 5
12976: PUSH
12977: LD_INT 81
12979: PUSH
12980: LD_VAR 0 1
12984: PUSH
12985: EMPTY
12986: LIST
12987: LIST
12988: PUSH
12989: LD_INT 3
12991: PUSH
12992: LD_INT 21
12994: PUSH
12995: LD_INT 3
12997: PUSH
12998: EMPTY
12999: LIST
13000: LIST
13001: PUSH
13002: EMPTY
13003: LIST
13004: LIST
13005: PUSH
13006: EMPTY
13007: LIST
13008: LIST
13009: PPUSH
13010: CALL_OW 69
13014: ST_TO_ADDR
// for i in mines do
13015: LD_ADDR_VAR 0 4
13019: PUSH
13020: LD_VAR 0 2
13024: PUSH
13025: FOR_IN
13026: IFFALSE 13114
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
13028: LD_VAR 0 4
13032: PUSH
13033: LD_INT 1
13035: ARRAY
13036: PPUSH
13037: LD_VAR 0 4
13041: PUSH
13042: LD_INT 2
13044: ARRAY
13045: PPUSH
13046: CALL_OW 458
13050: NOT
13051: IFFALSE 13055
// continue ;
13053: GO 13025
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
13055: LD_VAR 0 4
13059: PUSH
13060: LD_INT 1
13062: ARRAY
13063: PPUSH
13064: LD_VAR 0 4
13068: PUSH
13069: LD_INT 2
13071: ARRAY
13072: PPUSH
13073: CALL_OW 428
13077: PUSH
13078: LD_VAR 0 5
13082: IN
13083: IFFALSE 13112
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
13085: LD_VAR 0 4
13089: PUSH
13090: LD_INT 1
13092: ARRAY
13093: PPUSH
13094: LD_VAR 0 4
13098: PUSH
13099: LD_INT 2
13101: ARRAY
13102: PPUSH
13103: LD_VAR 0 1
13107: PPUSH
13108: CALL_OW 456
// end ;
13112: GO 13025
13114: POP
13115: POP
// end ;
13116: LD_VAR 0 3
13120: RET
// export function Count ( array ) ; var i ; begin
13121: LD_INT 0
13123: PPUSH
13124: PPUSH
// result := 0 ;
13125: LD_ADDR_VAR 0 2
13129: PUSH
13130: LD_INT 0
13132: ST_TO_ADDR
// for i in array do
13133: LD_ADDR_VAR 0 3
13137: PUSH
13138: LD_VAR 0 1
13142: PUSH
13143: FOR_IN
13144: IFFALSE 13168
// if i then
13146: LD_VAR 0 3
13150: IFFALSE 13166
// result := result + 1 ;
13152: LD_ADDR_VAR 0 2
13156: PUSH
13157: LD_VAR 0 2
13161: PUSH
13162: LD_INT 1
13164: PLUS
13165: ST_TO_ADDR
13166: GO 13143
13168: POP
13169: POP
// end ;
13170: LD_VAR 0 2
13174: RET
// export function IsEmpty ( building ) ; begin
13175: LD_INT 0
13177: PPUSH
// if not building then
13178: LD_VAR 0 1
13182: NOT
13183: IFFALSE 13187
// exit ;
13185: GO 13230
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
13187: LD_ADDR_VAR 0 2
13191: PUSH
13192: LD_VAR 0 1
13196: PUSH
13197: LD_INT 22
13199: PUSH
13200: LD_VAR 0 1
13204: PPUSH
13205: CALL_OW 255
13209: PUSH
13210: EMPTY
13211: LIST
13212: LIST
13213: PUSH
13214: LD_INT 58
13216: PUSH
13217: EMPTY
13218: LIST
13219: PUSH
13220: EMPTY
13221: LIST
13222: LIST
13223: PPUSH
13224: CALL_OW 69
13228: IN
13229: ST_TO_ADDR
// end ;
13230: LD_VAR 0 2
13234: RET
// export function IsNotFull ( building ) ; var places ; begin
13235: LD_INT 0
13237: PPUSH
13238: PPUSH
// if not building then
13239: LD_VAR 0 1
13243: NOT
13244: IFFALSE 13248
// exit ;
13246: GO 13419
// result := false ;
13248: LD_ADDR_VAR 0 2
13252: PUSH
13253: LD_INT 0
13255: ST_TO_ADDR
// places := 0 ;
13256: LD_ADDR_VAR 0 3
13260: PUSH
13261: LD_INT 0
13263: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
13264: LD_VAR 0 1
13268: PPUSH
13269: CALL_OW 266
13273: PUSH
13274: LD_INT 0
13276: DOUBLE
13277: EQUAL
13278: IFTRUE 13336
13280: LD_INT 1
13282: DOUBLE
13283: EQUAL
13284: IFTRUE 13336
13286: LD_INT 6
13288: DOUBLE
13289: EQUAL
13290: IFTRUE 13336
13292: LD_INT 7
13294: DOUBLE
13295: EQUAL
13296: IFTRUE 13336
13298: LD_INT 8
13300: DOUBLE
13301: EQUAL
13302: IFTRUE 13336
13304: LD_INT 4
13306: DOUBLE
13307: EQUAL
13308: IFTRUE 13336
13310: LD_INT 5
13312: DOUBLE
13313: EQUAL
13314: IFTRUE 13336
13316: LD_INT 2
13318: DOUBLE
13319: EQUAL
13320: IFTRUE 13336
13322: LD_INT 3
13324: DOUBLE
13325: EQUAL
13326: IFTRUE 13336
13328: LD_INT 35
13330: DOUBLE
13331: EQUAL
13332: IFTRUE 13336
13334: GO 13347
13336: POP
// places := 6 ; b_bunker , b_breastwork :
13337: LD_ADDR_VAR 0 3
13341: PUSH
13342: LD_INT 6
13344: ST_TO_ADDR
13345: GO 13392
13347: LD_INT 32
13349: DOUBLE
13350: EQUAL
13351: IFTRUE 13361
13353: LD_INT 31
13355: DOUBLE
13356: EQUAL
13357: IFTRUE 13361
13359: GO 13372
13361: POP
// places := 1 ; b_control_tower :
13362: LD_ADDR_VAR 0 3
13366: PUSH
13367: LD_INT 1
13369: ST_TO_ADDR
13370: GO 13392
13372: LD_INT 36
13374: DOUBLE
13375: EQUAL
13376: IFTRUE 13380
13378: GO 13391
13380: POP
// places := 3 ; end ;
13381: LD_ADDR_VAR 0 3
13385: PUSH
13386: LD_INT 3
13388: ST_TO_ADDR
13389: GO 13392
13391: POP
// if places then
13392: LD_VAR 0 3
13396: IFFALSE 13419
// result := UnitsInside ( building ) < places ;
13398: LD_ADDR_VAR 0 2
13402: PUSH
13403: LD_VAR 0 1
13407: PPUSH
13408: CALL_OW 313
13412: PUSH
13413: LD_VAR 0 3
13417: LESS
13418: ST_TO_ADDR
// end ;
13419: LD_VAR 0 2
13423: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
13424: LD_INT 0
13426: PPUSH
13427: PPUSH
13428: PPUSH
13429: PPUSH
// tmp := [ ] ;
13430: LD_ADDR_VAR 0 3
13434: PUSH
13435: EMPTY
13436: ST_TO_ADDR
// list := [ ] ;
13437: LD_ADDR_VAR 0 5
13441: PUSH
13442: EMPTY
13443: ST_TO_ADDR
// for i = 16 to 25 do
13444: LD_ADDR_VAR 0 4
13448: PUSH
13449: DOUBLE
13450: LD_INT 16
13452: DEC
13453: ST_TO_ADDR
13454: LD_INT 25
13456: PUSH
13457: FOR_TO
13458: IFFALSE 13531
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
13460: LD_ADDR_VAR 0 3
13464: PUSH
13465: LD_VAR 0 3
13469: PUSH
13470: LD_INT 22
13472: PUSH
13473: LD_VAR 0 1
13477: PPUSH
13478: CALL_OW 255
13482: PUSH
13483: EMPTY
13484: LIST
13485: LIST
13486: PUSH
13487: LD_INT 91
13489: PUSH
13490: LD_VAR 0 1
13494: PUSH
13495: LD_INT 6
13497: PUSH
13498: EMPTY
13499: LIST
13500: LIST
13501: LIST
13502: PUSH
13503: LD_INT 30
13505: PUSH
13506: LD_VAR 0 4
13510: PUSH
13511: EMPTY
13512: LIST
13513: LIST
13514: PUSH
13515: EMPTY
13516: LIST
13517: LIST
13518: LIST
13519: PUSH
13520: EMPTY
13521: LIST
13522: PPUSH
13523: CALL_OW 69
13527: ADD
13528: ST_TO_ADDR
13529: GO 13457
13531: POP
13532: POP
// for i = 1 to tmp do
13533: LD_ADDR_VAR 0 4
13537: PUSH
13538: DOUBLE
13539: LD_INT 1
13541: DEC
13542: ST_TO_ADDR
13543: LD_VAR 0 3
13547: PUSH
13548: FOR_TO
13549: IFFALSE 13637
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
13551: LD_ADDR_VAR 0 5
13555: PUSH
13556: LD_VAR 0 5
13560: PUSH
13561: LD_VAR 0 3
13565: PUSH
13566: LD_VAR 0 4
13570: ARRAY
13571: PPUSH
13572: CALL_OW 266
13576: PUSH
13577: LD_VAR 0 3
13581: PUSH
13582: LD_VAR 0 4
13586: ARRAY
13587: PPUSH
13588: CALL_OW 250
13592: PUSH
13593: LD_VAR 0 3
13597: PUSH
13598: LD_VAR 0 4
13602: ARRAY
13603: PPUSH
13604: CALL_OW 251
13608: PUSH
13609: LD_VAR 0 3
13613: PUSH
13614: LD_VAR 0 4
13618: ARRAY
13619: PPUSH
13620: CALL_OW 254
13624: PUSH
13625: EMPTY
13626: LIST
13627: LIST
13628: LIST
13629: LIST
13630: PUSH
13631: EMPTY
13632: LIST
13633: ADD
13634: ST_TO_ADDR
13635: GO 13548
13637: POP
13638: POP
// result := list ;
13639: LD_ADDR_VAR 0 2
13643: PUSH
13644: LD_VAR 0 5
13648: ST_TO_ADDR
// end ;
13649: LD_VAR 0 2
13653: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
13654: LD_INT 0
13656: PPUSH
13657: PPUSH
13658: PPUSH
13659: PPUSH
13660: PPUSH
13661: PPUSH
13662: PPUSH
// if not factory then
13663: LD_VAR 0 1
13667: NOT
13668: IFFALSE 13672
// exit ;
13670: GO 14265
// if control = control_apeman then
13672: LD_VAR 0 4
13676: PUSH
13677: LD_INT 5
13679: EQUAL
13680: IFFALSE 13789
// begin tmp := UnitsInside ( factory ) ;
13682: LD_ADDR_VAR 0 8
13686: PUSH
13687: LD_VAR 0 1
13691: PPUSH
13692: CALL_OW 313
13696: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
13697: LD_VAR 0 8
13701: PPUSH
13702: LD_INT 25
13704: PUSH
13705: LD_INT 12
13707: PUSH
13708: EMPTY
13709: LIST
13710: LIST
13711: PPUSH
13712: CALL_OW 72
13716: NOT
13717: IFFALSE 13727
// control := control_manual ;
13719: LD_ADDR_VAR 0 4
13723: PUSH
13724: LD_INT 1
13726: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
13727: LD_ADDR_VAR 0 8
13731: PUSH
13732: LD_VAR 0 1
13736: PPUSH
13737: CALL 13424 0 1
13741: ST_TO_ADDR
// if tmp then
13742: LD_VAR 0 8
13746: IFFALSE 13789
// begin for i in tmp do
13748: LD_ADDR_VAR 0 7
13752: PUSH
13753: LD_VAR 0 8
13757: PUSH
13758: FOR_IN
13759: IFFALSE 13787
// if i [ 1 ] = b_ext_radio then
13761: LD_VAR 0 7
13765: PUSH
13766: LD_INT 1
13768: ARRAY
13769: PUSH
13770: LD_INT 22
13772: EQUAL
13773: IFFALSE 13785
// begin control := control_remote ;
13775: LD_ADDR_VAR 0 4
13779: PUSH
13780: LD_INT 2
13782: ST_TO_ADDR
// break ;
13783: GO 13787
// end ;
13785: GO 13758
13787: POP
13788: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
13789: LD_VAR 0 1
13793: PPUSH
13794: LD_VAR 0 2
13798: PPUSH
13799: LD_VAR 0 3
13803: PPUSH
13804: LD_VAR 0 4
13808: PPUSH
13809: LD_VAR 0 5
13813: PPUSH
13814: CALL_OW 448
13818: IFFALSE 13853
// begin result := [ chassis , engine , control , weapon ] ;
13820: LD_ADDR_VAR 0 6
13824: PUSH
13825: LD_VAR 0 2
13829: PUSH
13830: LD_VAR 0 3
13834: PUSH
13835: LD_VAR 0 4
13839: PUSH
13840: LD_VAR 0 5
13844: PUSH
13845: EMPTY
13846: LIST
13847: LIST
13848: LIST
13849: LIST
13850: ST_TO_ADDR
// exit ;
13851: GO 14265
// end ; _chassis := AvailableChassisList ( factory ) ;
13853: LD_ADDR_VAR 0 9
13857: PUSH
13858: LD_VAR 0 1
13862: PPUSH
13863: CALL_OW 475
13867: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
13868: LD_ADDR_VAR 0 11
13872: PUSH
13873: LD_VAR 0 1
13877: PPUSH
13878: CALL_OW 476
13882: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
13883: LD_ADDR_VAR 0 12
13887: PUSH
13888: LD_VAR 0 1
13892: PPUSH
13893: CALL_OW 477
13897: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
13898: LD_ADDR_VAR 0 10
13902: PUSH
13903: LD_VAR 0 1
13907: PPUSH
13908: CALL_OW 478
13912: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
13913: LD_VAR 0 9
13917: NOT
13918: PUSH
13919: LD_VAR 0 11
13923: NOT
13924: OR
13925: PUSH
13926: LD_VAR 0 12
13930: NOT
13931: OR
13932: PUSH
13933: LD_VAR 0 10
13937: NOT
13938: OR
13939: IFFALSE 13974
// begin result := [ chassis , engine , control , weapon ] ;
13941: LD_ADDR_VAR 0 6
13945: PUSH
13946: LD_VAR 0 2
13950: PUSH
13951: LD_VAR 0 3
13955: PUSH
13956: LD_VAR 0 4
13960: PUSH
13961: LD_VAR 0 5
13965: PUSH
13966: EMPTY
13967: LIST
13968: LIST
13969: LIST
13970: LIST
13971: ST_TO_ADDR
// exit ;
13972: GO 14265
// end ; if not chassis in _chassis then
13974: LD_VAR 0 2
13978: PUSH
13979: LD_VAR 0 9
13983: IN
13984: NOT
13985: IFFALSE 14011
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
13987: LD_ADDR_VAR 0 2
13991: PUSH
13992: LD_VAR 0 9
13996: PUSH
13997: LD_INT 1
13999: PPUSH
14000: LD_VAR 0 9
14004: PPUSH
14005: CALL_OW 12
14009: ARRAY
14010: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
14011: LD_VAR 0 2
14015: PPUSH
14016: LD_VAR 0 3
14020: PPUSH
14021: CALL 14270 0 2
14025: NOT
14026: IFFALSE 14085
// repeat engine := _engine [ 1 ] ;
14028: LD_ADDR_VAR 0 3
14032: PUSH
14033: LD_VAR 0 11
14037: PUSH
14038: LD_INT 1
14040: ARRAY
14041: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
14042: LD_ADDR_VAR 0 11
14046: PUSH
14047: LD_VAR 0 11
14051: PPUSH
14052: LD_INT 1
14054: PPUSH
14055: CALL_OW 3
14059: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
14060: LD_VAR 0 2
14064: PPUSH
14065: LD_VAR 0 3
14069: PPUSH
14070: CALL 14270 0 2
14074: PUSH
14075: LD_VAR 0 11
14079: PUSH
14080: EMPTY
14081: EQUAL
14082: OR
14083: IFFALSE 14028
// if not control in _control then
14085: LD_VAR 0 4
14089: PUSH
14090: LD_VAR 0 12
14094: IN
14095: NOT
14096: IFFALSE 14122
// control := _control [ rand ( 1 , _control ) ] ;
14098: LD_ADDR_VAR 0 4
14102: PUSH
14103: LD_VAR 0 12
14107: PUSH
14108: LD_INT 1
14110: PPUSH
14111: LD_VAR 0 12
14115: PPUSH
14116: CALL_OW 12
14120: ARRAY
14121: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
14122: LD_VAR 0 2
14126: PPUSH
14127: LD_VAR 0 5
14131: PPUSH
14132: CALL 14490 0 2
14136: NOT
14137: IFFALSE 14196
// repeat weapon := _weapon [ 1 ] ;
14139: LD_ADDR_VAR 0 5
14143: PUSH
14144: LD_VAR 0 10
14148: PUSH
14149: LD_INT 1
14151: ARRAY
14152: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
14153: LD_ADDR_VAR 0 10
14157: PUSH
14158: LD_VAR 0 10
14162: PPUSH
14163: LD_INT 1
14165: PPUSH
14166: CALL_OW 3
14170: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
14171: LD_VAR 0 2
14175: PPUSH
14176: LD_VAR 0 5
14180: PPUSH
14181: CALL 14490 0 2
14185: PUSH
14186: LD_VAR 0 10
14190: PUSH
14191: EMPTY
14192: EQUAL
14193: OR
14194: IFFALSE 14139
// result := [ ] ;
14196: LD_ADDR_VAR 0 6
14200: PUSH
14201: EMPTY
14202: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
14203: LD_VAR 0 1
14207: PPUSH
14208: LD_VAR 0 2
14212: PPUSH
14213: LD_VAR 0 3
14217: PPUSH
14218: LD_VAR 0 4
14222: PPUSH
14223: LD_VAR 0 5
14227: PPUSH
14228: CALL_OW 448
14232: IFFALSE 14265
// result := [ chassis , engine , control , weapon ] ;
14234: LD_ADDR_VAR 0 6
14238: PUSH
14239: LD_VAR 0 2
14243: PUSH
14244: LD_VAR 0 3
14248: PUSH
14249: LD_VAR 0 4
14253: PUSH
14254: LD_VAR 0 5
14258: PUSH
14259: EMPTY
14260: LIST
14261: LIST
14262: LIST
14263: LIST
14264: ST_TO_ADDR
// end ;
14265: LD_VAR 0 6
14269: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
14270: LD_INT 0
14272: PPUSH
// if not chassis or not engine then
14273: LD_VAR 0 1
14277: NOT
14278: PUSH
14279: LD_VAR 0 2
14283: NOT
14284: OR
14285: IFFALSE 14289
// exit ;
14287: GO 14485
// case engine of engine_solar :
14289: LD_VAR 0 2
14293: PUSH
14294: LD_INT 2
14296: DOUBLE
14297: EQUAL
14298: IFTRUE 14302
14300: GO 14340
14302: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
14303: LD_ADDR_VAR 0 3
14307: PUSH
14308: LD_INT 11
14310: PUSH
14311: LD_INT 12
14313: PUSH
14314: LD_INT 13
14316: PUSH
14317: LD_INT 14
14319: PUSH
14320: LD_INT 1
14322: PUSH
14323: LD_INT 2
14325: PUSH
14326: LD_INT 3
14328: PUSH
14329: EMPTY
14330: LIST
14331: LIST
14332: LIST
14333: LIST
14334: LIST
14335: LIST
14336: LIST
14337: ST_TO_ADDR
14338: GO 14469
14340: LD_INT 1
14342: DOUBLE
14343: EQUAL
14344: IFTRUE 14348
14346: GO 14410
14348: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
14349: LD_ADDR_VAR 0 3
14353: PUSH
14354: LD_INT 11
14356: PUSH
14357: LD_INT 12
14359: PUSH
14360: LD_INT 13
14362: PUSH
14363: LD_INT 14
14365: PUSH
14366: LD_INT 1
14368: PUSH
14369: LD_INT 2
14371: PUSH
14372: LD_INT 3
14374: PUSH
14375: LD_INT 4
14377: PUSH
14378: LD_INT 5
14380: PUSH
14381: LD_INT 21
14383: PUSH
14384: LD_INT 23
14386: PUSH
14387: LD_INT 22
14389: PUSH
14390: LD_INT 24
14392: PUSH
14393: EMPTY
14394: LIST
14395: LIST
14396: LIST
14397: LIST
14398: LIST
14399: LIST
14400: LIST
14401: LIST
14402: LIST
14403: LIST
14404: LIST
14405: LIST
14406: LIST
14407: ST_TO_ADDR
14408: GO 14469
14410: LD_INT 3
14412: DOUBLE
14413: EQUAL
14414: IFTRUE 14418
14416: GO 14468
14418: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
14419: LD_ADDR_VAR 0 3
14423: PUSH
14424: LD_INT 13
14426: PUSH
14427: LD_INT 14
14429: PUSH
14430: LD_INT 2
14432: PUSH
14433: LD_INT 3
14435: PUSH
14436: LD_INT 4
14438: PUSH
14439: LD_INT 5
14441: PUSH
14442: LD_INT 21
14444: PUSH
14445: LD_INT 22
14447: PUSH
14448: LD_INT 23
14450: PUSH
14451: LD_INT 24
14453: PUSH
14454: EMPTY
14455: LIST
14456: LIST
14457: LIST
14458: LIST
14459: LIST
14460: LIST
14461: LIST
14462: LIST
14463: LIST
14464: LIST
14465: ST_TO_ADDR
14466: GO 14469
14468: POP
// result := ( chassis in result ) ;
14469: LD_ADDR_VAR 0 3
14473: PUSH
14474: LD_VAR 0 1
14478: PUSH
14479: LD_VAR 0 3
14483: IN
14484: ST_TO_ADDR
// end ;
14485: LD_VAR 0 3
14489: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
14490: LD_INT 0
14492: PPUSH
// if not chassis or not weapon then
14493: LD_VAR 0 1
14497: NOT
14498: PUSH
14499: LD_VAR 0 2
14503: NOT
14504: OR
14505: IFFALSE 14509
// exit ;
14507: GO 15569
// case weapon of us_machine_gun :
14509: LD_VAR 0 2
14513: PUSH
14514: LD_INT 2
14516: DOUBLE
14517: EQUAL
14518: IFTRUE 14522
14520: GO 14552
14522: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
14523: LD_ADDR_VAR 0 3
14527: PUSH
14528: LD_INT 1
14530: PUSH
14531: LD_INT 2
14533: PUSH
14534: LD_INT 3
14536: PUSH
14537: LD_INT 4
14539: PUSH
14540: LD_INT 5
14542: PUSH
14543: EMPTY
14544: LIST
14545: LIST
14546: LIST
14547: LIST
14548: LIST
14549: ST_TO_ADDR
14550: GO 15553
14552: LD_INT 3
14554: DOUBLE
14555: EQUAL
14556: IFTRUE 14560
14558: GO 14590
14560: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
14561: LD_ADDR_VAR 0 3
14565: PUSH
14566: LD_INT 1
14568: PUSH
14569: LD_INT 2
14571: PUSH
14572: LD_INT 3
14574: PUSH
14575: LD_INT 4
14577: PUSH
14578: LD_INT 5
14580: PUSH
14581: EMPTY
14582: LIST
14583: LIST
14584: LIST
14585: LIST
14586: LIST
14587: ST_TO_ADDR
14588: GO 15553
14590: LD_INT 11
14592: DOUBLE
14593: EQUAL
14594: IFTRUE 14598
14596: GO 14628
14598: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
14599: LD_ADDR_VAR 0 3
14603: PUSH
14604: LD_INT 1
14606: PUSH
14607: LD_INT 2
14609: PUSH
14610: LD_INT 3
14612: PUSH
14613: LD_INT 4
14615: PUSH
14616: LD_INT 5
14618: PUSH
14619: EMPTY
14620: LIST
14621: LIST
14622: LIST
14623: LIST
14624: LIST
14625: ST_TO_ADDR
14626: GO 15553
14628: LD_INT 4
14630: DOUBLE
14631: EQUAL
14632: IFTRUE 14636
14634: GO 14662
14636: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
14637: LD_ADDR_VAR 0 3
14641: PUSH
14642: LD_INT 2
14644: PUSH
14645: LD_INT 3
14647: PUSH
14648: LD_INT 4
14650: PUSH
14651: LD_INT 5
14653: PUSH
14654: EMPTY
14655: LIST
14656: LIST
14657: LIST
14658: LIST
14659: ST_TO_ADDR
14660: GO 15553
14662: LD_INT 5
14664: DOUBLE
14665: EQUAL
14666: IFTRUE 14670
14668: GO 14696
14670: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
14671: LD_ADDR_VAR 0 3
14675: PUSH
14676: LD_INT 2
14678: PUSH
14679: LD_INT 3
14681: PUSH
14682: LD_INT 4
14684: PUSH
14685: LD_INT 5
14687: PUSH
14688: EMPTY
14689: LIST
14690: LIST
14691: LIST
14692: LIST
14693: ST_TO_ADDR
14694: GO 15553
14696: LD_INT 9
14698: DOUBLE
14699: EQUAL
14700: IFTRUE 14704
14702: GO 14730
14704: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
14705: LD_ADDR_VAR 0 3
14709: PUSH
14710: LD_INT 2
14712: PUSH
14713: LD_INT 3
14715: PUSH
14716: LD_INT 4
14718: PUSH
14719: LD_INT 5
14721: PUSH
14722: EMPTY
14723: LIST
14724: LIST
14725: LIST
14726: LIST
14727: ST_TO_ADDR
14728: GO 15553
14730: LD_INT 7
14732: DOUBLE
14733: EQUAL
14734: IFTRUE 14738
14736: GO 14764
14738: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
14739: LD_ADDR_VAR 0 3
14743: PUSH
14744: LD_INT 2
14746: PUSH
14747: LD_INT 3
14749: PUSH
14750: LD_INT 4
14752: PUSH
14753: LD_INT 5
14755: PUSH
14756: EMPTY
14757: LIST
14758: LIST
14759: LIST
14760: LIST
14761: ST_TO_ADDR
14762: GO 15553
14764: LD_INT 12
14766: DOUBLE
14767: EQUAL
14768: IFTRUE 14772
14770: GO 14798
14772: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
14773: LD_ADDR_VAR 0 3
14777: PUSH
14778: LD_INT 2
14780: PUSH
14781: LD_INT 3
14783: PUSH
14784: LD_INT 4
14786: PUSH
14787: LD_INT 5
14789: PUSH
14790: EMPTY
14791: LIST
14792: LIST
14793: LIST
14794: LIST
14795: ST_TO_ADDR
14796: GO 15553
14798: LD_INT 13
14800: DOUBLE
14801: EQUAL
14802: IFTRUE 14806
14804: GO 14832
14806: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
14807: LD_ADDR_VAR 0 3
14811: PUSH
14812: LD_INT 2
14814: PUSH
14815: LD_INT 3
14817: PUSH
14818: LD_INT 4
14820: PUSH
14821: LD_INT 5
14823: PUSH
14824: EMPTY
14825: LIST
14826: LIST
14827: LIST
14828: LIST
14829: ST_TO_ADDR
14830: GO 15553
14832: LD_INT 14
14834: DOUBLE
14835: EQUAL
14836: IFTRUE 14840
14838: GO 14858
14840: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
14841: LD_ADDR_VAR 0 3
14845: PUSH
14846: LD_INT 4
14848: PUSH
14849: LD_INT 5
14851: PUSH
14852: EMPTY
14853: LIST
14854: LIST
14855: ST_TO_ADDR
14856: GO 15553
14858: LD_INT 6
14860: DOUBLE
14861: EQUAL
14862: IFTRUE 14866
14864: GO 14884
14866: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
14867: LD_ADDR_VAR 0 3
14871: PUSH
14872: LD_INT 4
14874: PUSH
14875: LD_INT 5
14877: PUSH
14878: EMPTY
14879: LIST
14880: LIST
14881: ST_TO_ADDR
14882: GO 15553
14884: LD_INT 10
14886: DOUBLE
14887: EQUAL
14888: IFTRUE 14892
14890: GO 14910
14892: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
14893: LD_ADDR_VAR 0 3
14897: PUSH
14898: LD_INT 4
14900: PUSH
14901: LD_INT 5
14903: PUSH
14904: EMPTY
14905: LIST
14906: LIST
14907: ST_TO_ADDR
14908: GO 15553
14910: LD_INT 22
14912: DOUBLE
14913: EQUAL
14914: IFTRUE 14918
14916: GO 14944
14918: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
14919: LD_ADDR_VAR 0 3
14923: PUSH
14924: LD_INT 11
14926: PUSH
14927: LD_INT 12
14929: PUSH
14930: LD_INT 13
14932: PUSH
14933: LD_INT 14
14935: PUSH
14936: EMPTY
14937: LIST
14938: LIST
14939: LIST
14940: LIST
14941: ST_TO_ADDR
14942: GO 15553
14944: LD_INT 23
14946: DOUBLE
14947: EQUAL
14948: IFTRUE 14952
14950: GO 14978
14952: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
14953: LD_ADDR_VAR 0 3
14957: PUSH
14958: LD_INT 11
14960: PUSH
14961: LD_INT 12
14963: PUSH
14964: LD_INT 13
14966: PUSH
14967: LD_INT 14
14969: PUSH
14970: EMPTY
14971: LIST
14972: LIST
14973: LIST
14974: LIST
14975: ST_TO_ADDR
14976: GO 15553
14978: LD_INT 24
14980: DOUBLE
14981: EQUAL
14982: IFTRUE 14986
14984: GO 15012
14986: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
14987: LD_ADDR_VAR 0 3
14991: PUSH
14992: LD_INT 11
14994: PUSH
14995: LD_INT 12
14997: PUSH
14998: LD_INT 13
15000: PUSH
15001: LD_INT 14
15003: PUSH
15004: EMPTY
15005: LIST
15006: LIST
15007: LIST
15008: LIST
15009: ST_TO_ADDR
15010: GO 15553
15012: LD_INT 30
15014: DOUBLE
15015: EQUAL
15016: IFTRUE 15020
15018: GO 15046
15020: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
15021: LD_ADDR_VAR 0 3
15025: PUSH
15026: LD_INT 11
15028: PUSH
15029: LD_INT 12
15031: PUSH
15032: LD_INT 13
15034: PUSH
15035: LD_INT 14
15037: PUSH
15038: EMPTY
15039: LIST
15040: LIST
15041: LIST
15042: LIST
15043: ST_TO_ADDR
15044: GO 15553
15046: LD_INT 25
15048: DOUBLE
15049: EQUAL
15050: IFTRUE 15054
15052: GO 15072
15054: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
15055: LD_ADDR_VAR 0 3
15059: PUSH
15060: LD_INT 13
15062: PUSH
15063: LD_INT 14
15065: PUSH
15066: EMPTY
15067: LIST
15068: LIST
15069: ST_TO_ADDR
15070: GO 15553
15072: LD_INT 27
15074: DOUBLE
15075: EQUAL
15076: IFTRUE 15080
15078: GO 15098
15080: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
15081: LD_ADDR_VAR 0 3
15085: PUSH
15086: LD_INT 13
15088: PUSH
15089: LD_INT 14
15091: PUSH
15092: EMPTY
15093: LIST
15094: LIST
15095: ST_TO_ADDR
15096: GO 15553
15098: LD_INT 92
15100: DOUBLE
15101: EQUAL
15102: IFTRUE 15106
15104: GO 15132
15106: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
15107: LD_ADDR_VAR 0 3
15111: PUSH
15112: LD_INT 11
15114: PUSH
15115: LD_INT 12
15117: PUSH
15118: LD_INT 13
15120: PUSH
15121: LD_INT 14
15123: PUSH
15124: EMPTY
15125: LIST
15126: LIST
15127: LIST
15128: LIST
15129: ST_TO_ADDR
15130: GO 15553
15132: LD_INT 28
15134: DOUBLE
15135: EQUAL
15136: IFTRUE 15140
15138: GO 15158
15140: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
15141: LD_ADDR_VAR 0 3
15145: PUSH
15146: LD_INT 13
15148: PUSH
15149: LD_INT 14
15151: PUSH
15152: EMPTY
15153: LIST
15154: LIST
15155: ST_TO_ADDR
15156: GO 15553
15158: LD_INT 29
15160: DOUBLE
15161: EQUAL
15162: IFTRUE 15166
15164: GO 15184
15166: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
15167: LD_ADDR_VAR 0 3
15171: PUSH
15172: LD_INT 13
15174: PUSH
15175: LD_INT 14
15177: PUSH
15178: EMPTY
15179: LIST
15180: LIST
15181: ST_TO_ADDR
15182: GO 15553
15184: LD_INT 31
15186: DOUBLE
15187: EQUAL
15188: IFTRUE 15192
15190: GO 15210
15192: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
15193: LD_ADDR_VAR 0 3
15197: PUSH
15198: LD_INT 13
15200: PUSH
15201: LD_INT 14
15203: PUSH
15204: EMPTY
15205: LIST
15206: LIST
15207: ST_TO_ADDR
15208: GO 15553
15210: LD_INT 26
15212: DOUBLE
15213: EQUAL
15214: IFTRUE 15218
15216: GO 15236
15218: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
15219: LD_ADDR_VAR 0 3
15223: PUSH
15224: LD_INT 13
15226: PUSH
15227: LD_INT 14
15229: PUSH
15230: EMPTY
15231: LIST
15232: LIST
15233: ST_TO_ADDR
15234: GO 15553
15236: LD_INT 42
15238: DOUBLE
15239: EQUAL
15240: IFTRUE 15244
15242: GO 15270
15244: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
15245: LD_ADDR_VAR 0 3
15249: PUSH
15250: LD_INT 21
15252: PUSH
15253: LD_INT 22
15255: PUSH
15256: LD_INT 23
15258: PUSH
15259: LD_INT 24
15261: PUSH
15262: EMPTY
15263: LIST
15264: LIST
15265: LIST
15266: LIST
15267: ST_TO_ADDR
15268: GO 15553
15270: LD_INT 43
15272: DOUBLE
15273: EQUAL
15274: IFTRUE 15278
15276: GO 15304
15278: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
15279: LD_ADDR_VAR 0 3
15283: PUSH
15284: LD_INT 21
15286: PUSH
15287: LD_INT 22
15289: PUSH
15290: LD_INT 23
15292: PUSH
15293: LD_INT 24
15295: PUSH
15296: EMPTY
15297: LIST
15298: LIST
15299: LIST
15300: LIST
15301: ST_TO_ADDR
15302: GO 15553
15304: LD_INT 44
15306: DOUBLE
15307: EQUAL
15308: IFTRUE 15312
15310: GO 15338
15312: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
15313: LD_ADDR_VAR 0 3
15317: PUSH
15318: LD_INT 21
15320: PUSH
15321: LD_INT 22
15323: PUSH
15324: LD_INT 23
15326: PUSH
15327: LD_INT 24
15329: PUSH
15330: EMPTY
15331: LIST
15332: LIST
15333: LIST
15334: LIST
15335: ST_TO_ADDR
15336: GO 15553
15338: LD_INT 45
15340: DOUBLE
15341: EQUAL
15342: IFTRUE 15346
15344: GO 15372
15346: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
15347: LD_ADDR_VAR 0 3
15351: PUSH
15352: LD_INT 21
15354: PUSH
15355: LD_INT 22
15357: PUSH
15358: LD_INT 23
15360: PUSH
15361: LD_INT 24
15363: PUSH
15364: EMPTY
15365: LIST
15366: LIST
15367: LIST
15368: LIST
15369: ST_TO_ADDR
15370: GO 15553
15372: LD_INT 49
15374: DOUBLE
15375: EQUAL
15376: IFTRUE 15380
15378: GO 15406
15380: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
15381: LD_ADDR_VAR 0 3
15385: PUSH
15386: LD_INT 21
15388: PUSH
15389: LD_INT 22
15391: PUSH
15392: LD_INT 23
15394: PUSH
15395: LD_INT 24
15397: PUSH
15398: EMPTY
15399: LIST
15400: LIST
15401: LIST
15402: LIST
15403: ST_TO_ADDR
15404: GO 15553
15406: LD_INT 51
15408: DOUBLE
15409: EQUAL
15410: IFTRUE 15414
15412: GO 15440
15414: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
15415: LD_ADDR_VAR 0 3
15419: PUSH
15420: LD_INT 21
15422: PUSH
15423: LD_INT 22
15425: PUSH
15426: LD_INT 23
15428: PUSH
15429: LD_INT 24
15431: PUSH
15432: EMPTY
15433: LIST
15434: LIST
15435: LIST
15436: LIST
15437: ST_TO_ADDR
15438: GO 15553
15440: LD_INT 52
15442: DOUBLE
15443: EQUAL
15444: IFTRUE 15448
15446: GO 15474
15448: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
15449: LD_ADDR_VAR 0 3
15453: PUSH
15454: LD_INT 21
15456: PUSH
15457: LD_INT 22
15459: PUSH
15460: LD_INT 23
15462: PUSH
15463: LD_INT 24
15465: PUSH
15466: EMPTY
15467: LIST
15468: LIST
15469: LIST
15470: LIST
15471: ST_TO_ADDR
15472: GO 15553
15474: LD_INT 53
15476: DOUBLE
15477: EQUAL
15478: IFTRUE 15482
15480: GO 15500
15482: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
15483: LD_ADDR_VAR 0 3
15487: PUSH
15488: LD_INT 23
15490: PUSH
15491: LD_INT 24
15493: PUSH
15494: EMPTY
15495: LIST
15496: LIST
15497: ST_TO_ADDR
15498: GO 15553
15500: LD_INT 46
15502: DOUBLE
15503: EQUAL
15504: IFTRUE 15508
15506: GO 15526
15508: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
15509: LD_ADDR_VAR 0 3
15513: PUSH
15514: LD_INT 23
15516: PUSH
15517: LD_INT 24
15519: PUSH
15520: EMPTY
15521: LIST
15522: LIST
15523: ST_TO_ADDR
15524: GO 15553
15526: LD_INT 47
15528: DOUBLE
15529: EQUAL
15530: IFTRUE 15534
15532: GO 15552
15534: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
15535: LD_ADDR_VAR 0 3
15539: PUSH
15540: LD_INT 23
15542: PUSH
15543: LD_INT 24
15545: PUSH
15546: EMPTY
15547: LIST
15548: LIST
15549: ST_TO_ADDR
15550: GO 15553
15552: POP
// result := ( chassis in result ) ;
15553: LD_ADDR_VAR 0 3
15557: PUSH
15558: LD_VAR 0 1
15562: PUSH
15563: LD_VAR 0 3
15567: IN
15568: ST_TO_ADDR
// end ;
15569: LD_VAR 0 3
15573: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
15574: LD_INT 0
15576: PPUSH
15577: PPUSH
15578: PPUSH
15579: PPUSH
15580: PPUSH
15581: PPUSH
15582: PPUSH
// result := array ;
15583: LD_ADDR_VAR 0 5
15587: PUSH
15588: LD_VAR 0 1
15592: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
15593: LD_VAR 0 1
15597: NOT
15598: PUSH
15599: LD_VAR 0 2
15603: NOT
15604: OR
15605: PUSH
15606: LD_VAR 0 3
15610: NOT
15611: OR
15612: PUSH
15613: LD_VAR 0 2
15617: PUSH
15618: LD_VAR 0 1
15622: GREATER
15623: OR
15624: PUSH
15625: LD_VAR 0 3
15629: PUSH
15630: LD_VAR 0 1
15634: GREATER
15635: OR
15636: IFFALSE 15640
// exit ;
15638: GO 15936
// if direction then
15640: LD_VAR 0 4
15644: IFFALSE 15708
// begin d := 1 ;
15646: LD_ADDR_VAR 0 9
15650: PUSH
15651: LD_INT 1
15653: ST_TO_ADDR
// if i_from > i_to then
15654: LD_VAR 0 2
15658: PUSH
15659: LD_VAR 0 3
15663: GREATER
15664: IFFALSE 15690
// length := ( array - i_from ) + i_to else
15666: LD_ADDR_VAR 0 11
15670: PUSH
15671: LD_VAR 0 1
15675: PUSH
15676: LD_VAR 0 2
15680: MINUS
15681: PUSH
15682: LD_VAR 0 3
15686: PLUS
15687: ST_TO_ADDR
15688: GO 15706
// length := i_to - i_from ;
15690: LD_ADDR_VAR 0 11
15694: PUSH
15695: LD_VAR 0 3
15699: PUSH
15700: LD_VAR 0 2
15704: MINUS
15705: ST_TO_ADDR
// end else
15706: GO 15769
// begin d := - 1 ;
15708: LD_ADDR_VAR 0 9
15712: PUSH
15713: LD_INT 1
15715: NEG
15716: ST_TO_ADDR
// if i_from > i_to then
15717: LD_VAR 0 2
15721: PUSH
15722: LD_VAR 0 3
15726: GREATER
15727: IFFALSE 15747
// length := i_from - i_to else
15729: LD_ADDR_VAR 0 11
15733: PUSH
15734: LD_VAR 0 2
15738: PUSH
15739: LD_VAR 0 3
15743: MINUS
15744: ST_TO_ADDR
15745: GO 15769
// length := ( array - i_to ) + i_from ;
15747: LD_ADDR_VAR 0 11
15751: PUSH
15752: LD_VAR 0 1
15756: PUSH
15757: LD_VAR 0 3
15761: MINUS
15762: PUSH
15763: LD_VAR 0 2
15767: PLUS
15768: ST_TO_ADDR
// end ; if not length then
15769: LD_VAR 0 11
15773: NOT
15774: IFFALSE 15778
// exit ;
15776: GO 15936
// tmp := array ;
15778: LD_ADDR_VAR 0 10
15782: PUSH
15783: LD_VAR 0 1
15787: ST_TO_ADDR
// for i = 1 to length do
15788: LD_ADDR_VAR 0 6
15792: PUSH
15793: DOUBLE
15794: LD_INT 1
15796: DEC
15797: ST_TO_ADDR
15798: LD_VAR 0 11
15802: PUSH
15803: FOR_TO
15804: IFFALSE 15924
// begin for j = 1 to array do
15806: LD_ADDR_VAR 0 7
15810: PUSH
15811: DOUBLE
15812: LD_INT 1
15814: DEC
15815: ST_TO_ADDR
15816: LD_VAR 0 1
15820: PUSH
15821: FOR_TO
15822: IFFALSE 15910
// begin k := j + d ;
15824: LD_ADDR_VAR 0 8
15828: PUSH
15829: LD_VAR 0 7
15833: PUSH
15834: LD_VAR 0 9
15838: PLUS
15839: ST_TO_ADDR
// if k > array then
15840: LD_VAR 0 8
15844: PUSH
15845: LD_VAR 0 1
15849: GREATER
15850: IFFALSE 15860
// k := 1 ;
15852: LD_ADDR_VAR 0 8
15856: PUSH
15857: LD_INT 1
15859: ST_TO_ADDR
// if not k then
15860: LD_VAR 0 8
15864: NOT
15865: IFFALSE 15877
// k := array ;
15867: LD_ADDR_VAR 0 8
15871: PUSH
15872: LD_VAR 0 1
15876: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
15877: LD_ADDR_VAR 0 10
15881: PUSH
15882: LD_VAR 0 10
15886: PPUSH
15887: LD_VAR 0 8
15891: PPUSH
15892: LD_VAR 0 1
15896: PUSH
15897: LD_VAR 0 7
15901: ARRAY
15902: PPUSH
15903: CALL_OW 1
15907: ST_TO_ADDR
// end ;
15908: GO 15821
15910: POP
15911: POP
// array := tmp ;
15912: LD_ADDR_VAR 0 1
15916: PUSH
15917: LD_VAR 0 10
15921: ST_TO_ADDR
// end ;
15922: GO 15803
15924: POP
15925: POP
// result := array ;
15926: LD_ADDR_VAR 0 5
15930: PUSH
15931: LD_VAR 0 1
15935: ST_TO_ADDR
// end ;
15936: LD_VAR 0 5
15940: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
15941: LD_INT 0
15943: PPUSH
15944: PPUSH
// result := 0 ;
15945: LD_ADDR_VAR 0 3
15949: PUSH
15950: LD_INT 0
15952: ST_TO_ADDR
// if not array or not value in array then
15953: LD_VAR 0 1
15957: NOT
15958: PUSH
15959: LD_VAR 0 2
15963: PUSH
15964: LD_VAR 0 1
15968: IN
15969: NOT
15970: OR
15971: IFFALSE 15975
// exit ;
15973: GO 16029
// for i = 1 to array do
15975: LD_ADDR_VAR 0 4
15979: PUSH
15980: DOUBLE
15981: LD_INT 1
15983: DEC
15984: ST_TO_ADDR
15985: LD_VAR 0 1
15989: PUSH
15990: FOR_TO
15991: IFFALSE 16027
// if value = array [ i ] then
15993: LD_VAR 0 2
15997: PUSH
15998: LD_VAR 0 1
16002: PUSH
16003: LD_VAR 0 4
16007: ARRAY
16008: EQUAL
16009: IFFALSE 16025
// begin result := i ;
16011: LD_ADDR_VAR 0 3
16015: PUSH
16016: LD_VAR 0 4
16020: ST_TO_ADDR
// exit ;
16021: POP
16022: POP
16023: GO 16029
// end ;
16025: GO 15990
16027: POP
16028: POP
// end ;
16029: LD_VAR 0 3
16033: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
16034: LD_INT 0
16036: PPUSH
// vc_chassis := chassis ;
16037: LD_ADDR_OWVAR 37
16041: PUSH
16042: LD_VAR 0 1
16046: ST_TO_ADDR
// vc_engine := engine ;
16047: LD_ADDR_OWVAR 39
16051: PUSH
16052: LD_VAR 0 2
16056: ST_TO_ADDR
// vc_control := control ;
16057: LD_ADDR_OWVAR 38
16061: PUSH
16062: LD_VAR 0 3
16066: ST_TO_ADDR
// vc_weapon := weapon ;
16067: LD_ADDR_OWVAR 40
16071: PUSH
16072: LD_VAR 0 4
16076: ST_TO_ADDR
// vc_fuel_battery := fuel ;
16077: LD_ADDR_OWVAR 41
16081: PUSH
16082: LD_VAR 0 5
16086: ST_TO_ADDR
// end ;
16087: LD_VAR 0 6
16091: RET
// export function WantPlant ( unit ) ; var task ; begin
16092: LD_INT 0
16094: PPUSH
16095: PPUSH
// result := false ;
16096: LD_ADDR_VAR 0 2
16100: PUSH
16101: LD_INT 0
16103: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
16104: LD_ADDR_VAR 0 3
16108: PUSH
16109: LD_VAR 0 1
16113: PPUSH
16114: CALL_OW 437
16118: ST_TO_ADDR
// if task then
16119: LD_VAR 0 3
16123: IFFALSE 16151
// if task [ 1 ] [ 1 ] = p then
16125: LD_VAR 0 3
16129: PUSH
16130: LD_INT 1
16132: ARRAY
16133: PUSH
16134: LD_INT 1
16136: ARRAY
16137: PUSH
16138: LD_STRING p
16140: EQUAL
16141: IFFALSE 16151
// result := true ;
16143: LD_ADDR_VAR 0 2
16147: PUSH
16148: LD_INT 1
16150: ST_TO_ADDR
// end ;
16151: LD_VAR 0 2
16155: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
16156: LD_INT 0
16158: PPUSH
16159: PPUSH
16160: PPUSH
16161: PPUSH
// if pos < 1 then
16162: LD_VAR 0 2
16166: PUSH
16167: LD_INT 1
16169: LESS
16170: IFFALSE 16174
// exit ;
16172: GO 16477
// if pos = 1 then
16174: LD_VAR 0 2
16178: PUSH
16179: LD_INT 1
16181: EQUAL
16182: IFFALSE 16215
// result := Replace ( arr , pos [ 1 ] , value ) else
16184: LD_ADDR_VAR 0 4
16188: PUSH
16189: LD_VAR 0 1
16193: PPUSH
16194: LD_VAR 0 2
16198: PUSH
16199: LD_INT 1
16201: ARRAY
16202: PPUSH
16203: LD_VAR 0 3
16207: PPUSH
16208: CALL_OW 1
16212: ST_TO_ADDR
16213: GO 16477
// begin tmp := arr ;
16215: LD_ADDR_VAR 0 6
16219: PUSH
16220: LD_VAR 0 1
16224: ST_TO_ADDR
// s_arr := [ tmp ] ;
16225: LD_ADDR_VAR 0 7
16229: PUSH
16230: LD_VAR 0 6
16234: PUSH
16235: EMPTY
16236: LIST
16237: ST_TO_ADDR
// for i = 1 to pos - 1 do
16238: LD_ADDR_VAR 0 5
16242: PUSH
16243: DOUBLE
16244: LD_INT 1
16246: DEC
16247: ST_TO_ADDR
16248: LD_VAR 0 2
16252: PUSH
16253: LD_INT 1
16255: MINUS
16256: PUSH
16257: FOR_TO
16258: IFFALSE 16303
// begin tmp := tmp [ pos [ i ] ] ;
16260: LD_ADDR_VAR 0 6
16264: PUSH
16265: LD_VAR 0 6
16269: PUSH
16270: LD_VAR 0 2
16274: PUSH
16275: LD_VAR 0 5
16279: ARRAY
16280: ARRAY
16281: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
16282: LD_ADDR_VAR 0 7
16286: PUSH
16287: LD_VAR 0 7
16291: PUSH
16292: LD_VAR 0 6
16296: PUSH
16297: EMPTY
16298: LIST
16299: ADD
16300: ST_TO_ADDR
// end ;
16301: GO 16257
16303: POP
16304: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
16305: LD_ADDR_VAR 0 6
16309: PUSH
16310: LD_VAR 0 6
16314: PPUSH
16315: LD_VAR 0 2
16319: PUSH
16320: LD_VAR 0 2
16324: ARRAY
16325: PPUSH
16326: LD_VAR 0 3
16330: PPUSH
16331: CALL_OW 1
16335: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
16336: LD_ADDR_VAR 0 7
16340: PUSH
16341: LD_VAR 0 7
16345: PPUSH
16346: LD_VAR 0 7
16350: PPUSH
16351: LD_VAR 0 6
16355: PPUSH
16356: CALL_OW 1
16360: ST_TO_ADDR
// for i = s_arr downto 2 do
16361: LD_ADDR_VAR 0 5
16365: PUSH
16366: DOUBLE
16367: LD_VAR 0 7
16371: INC
16372: ST_TO_ADDR
16373: LD_INT 2
16375: PUSH
16376: FOR_DOWNTO
16377: IFFALSE 16461
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
16379: LD_ADDR_VAR 0 6
16383: PUSH
16384: LD_VAR 0 7
16388: PUSH
16389: LD_VAR 0 5
16393: PUSH
16394: LD_INT 1
16396: MINUS
16397: ARRAY
16398: PPUSH
16399: LD_VAR 0 2
16403: PUSH
16404: LD_VAR 0 5
16408: PUSH
16409: LD_INT 1
16411: MINUS
16412: ARRAY
16413: PPUSH
16414: LD_VAR 0 7
16418: PUSH
16419: LD_VAR 0 5
16423: ARRAY
16424: PPUSH
16425: CALL_OW 1
16429: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
16430: LD_ADDR_VAR 0 7
16434: PUSH
16435: LD_VAR 0 7
16439: PPUSH
16440: LD_VAR 0 5
16444: PUSH
16445: LD_INT 1
16447: MINUS
16448: PPUSH
16449: LD_VAR 0 6
16453: PPUSH
16454: CALL_OW 1
16458: ST_TO_ADDR
// end ;
16459: GO 16376
16461: POP
16462: POP
// result := s_arr [ 1 ] ;
16463: LD_ADDR_VAR 0 4
16467: PUSH
16468: LD_VAR 0 7
16472: PUSH
16473: LD_INT 1
16475: ARRAY
16476: ST_TO_ADDR
// end ; end ;
16477: LD_VAR 0 4
16481: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
16482: LD_INT 0
16484: PPUSH
16485: PPUSH
// if not list then
16486: LD_VAR 0 1
16490: NOT
16491: IFFALSE 16495
// exit ;
16493: GO 16586
// i := list [ pos1 ] ;
16495: LD_ADDR_VAR 0 5
16499: PUSH
16500: LD_VAR 0 1
16504: PUSH
16505: LD_VAR 0 2
16509: ARRAY
16510: ST_TO_ADDR
// if not i then
16511: LD_VAR 0 5
16515: NOT
16516: IFFALSE 16520
// exit ;
16518: GO 16586
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
16520: LD_ADDR_VAR 0 1
16524: PUSH
16525: LD_VAR 0 1
16529: PPUSH
16530: LD_VAR 0 2
16534: PPUSH
16535: LD_VAR 0 1
16539: PUSH
16540: LD_VAR 0 3
16544: ARRAY
16545: PPUSH
16546: CALL_OW 1
16550: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
16551: LD_ADDR_VAR 0 1
16555: PUSH
16556: LD_VAR 0 1
16560: PPUSH
16561: LD_VAR 0 3
16565: PPUSH
16566: LD_VAR 0 5
16570: PPUSH
16571: CALL_OW 1
16575: ST_TO_ADDR
// result := list ;
16576: LD_ADDR_VAR 0 4
16580: PUSH
16581: LD_VAR 0 1
16585: ST_TO_ADDR
// end ;
16586: LD_VAR 0 4
16590: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
16591: LD_INT 0
16593: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
16594: LD_ADDR_VAR 0 5
16598: PUSH
16599: LD_VAR 0 1
16603: PPUSH
16604: CALL_OW 250
16608: PPUSH
16609: LD_VAR 0 1
16613: PPUSH
16614: CALL_OW 251
16618: PPUSH
16619: LD_VAR 0 2
16623: PPUSH
16624: LD_VAR 0 3
16628: PPUSH
16629: LD_VAR 0 4
16633: PPUSH
16634: CALL 16644 0 5
16638: ST_TO_ADDR
// end ;
16639: LD_VAR 0 5
16643: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
16644: LD_INT 0
16646: PPUSH
16647: PPUSH
16648: PPUSH
16649: PPUSH
// if not list then
16650: LD_VAR 0 3
16654: NOT
16655: IFFALSE 16659
// exit ;
16657: GO 17047
// result := [ ] ;
16659: LD_ADDR_VAR 0 6
16663: PUSH
16664: EMPTY
16665: ST_TO_ADDR
// for i in list do
16666: LD_ADDR_VAR 0 7
16670: PUSH
16671: LD_VAR 0 3
16675: PUSH
16676: FOR_IN
16677: IFFALSE 16879
// begin tmp := GetDistUnitXY ( i , x , y ) ;
16679: LD_ADDR_VAR 0 9
16683: PUSH
16684: LD_VAR 0 7
16688: PPUSH
16689: LD_VAR 0 1
16693: PPUSH
16694: LD_VAR 0 2
16698: PPUSH
16699: CALL_OW 297
16703: ST_TO_ADDR
// if not result then
16704: LD_VAR 0 6
16708: NOT
16709: IFFALSE 16735
// result := [ [ i , tmp ] ] else
16711: LD_ADDR_VAR 0 6
16715: PUSH
16716: LD_VAR 0 7
16720: PUSH
16721: LD_VAR 0 9
16725: PUSH
16726: EMPTY
16727: LIST
16728: LIST
16729: PUSH
16730: EMPTY
16731: LIST
16732: ST_TO_ADDR
16733: GO 16877
// begin if result [ result ] [ 2 ] < tmp then
16735: LD_VAR 0 6
16739: PUSH
16740: LD_VAR 0 6
16744: ARRAY
16745: PUSH
16746: LD_INT 2
16748: ARRAY
16749: PUSH
16750: LD_VAR 0 9
16754: LESS
16755: IFFALSE 16797
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
16757: LD_ADDR_VAR 0 6
16761: PUSH
16762: LD_VAR 0 6
16766: PPUSH
16767: LD_VAR 0 6
16771: PUSH
16772: LD_INT 1
16774: PLUS
16775: PPUSH
16776: LD_VAR 0 7
16780: PUSH
16781: LD_VAR 0 9
16785: PUSH
16786: EMPTY
16787: LIST
16788: LIST
16789: PPUSH
16790: CALL_OW 2
16794: ST_TO_ADDR
16795: GO 16877
// for j = 1 to result do
16797: LD_ADDR_VAR 0 8
16801: PUSH
16802: DOUBLE
16803: LD_INT 1
16805: DEC
16806: ST_TO_ADDR
16807: LD_VAR 0 6
16811: PUSH
16812: FOR_TO
16813: IFFALSE 16875
// begin if tmp < result [ j ] [ 2 ] then
16815: LD_VAR 0 9
16819: PUSH
16820: LD_VAR 0 6
16824: PUSH
16825: LD_VAR 0 8
16829: ARRAY
16830: PUSH
16831: LD_INT 2
16833: ARRAY
16834: LESS
16835: IFFALSE 16873
// begin result := Insert ( result , j , [ i , tmp ] ) ;
16837: LD_ADDR_VAR 0 6
16841: PUSH
16842: LD_VAR 0 6
16846: PPUSH
16847: LD_VAR 0 8
16851: PPUSH
16852: LD_VAR 0 7
16856: PUSH
16857: LD_VAR 0 9
16861: PUSH
16862: EMPTY
16863: LIST
16864: LIST
16865: PPUSH
16866: CALL_OW 2
16870: ST_TO_ADDR
// break ;
16871: GO 16875
// end ; end ;
16873: GO 16812
16875: POP
16876: POP
// end ; end ;
16877: GO 16676
16879: POP
16880: POP
// if result and not asc then
16881: LD_VAR 0 6
16885: PUSH
16886: LD_VAR 0 4
16890: NOT
16891: AND
16892: IFFALSE 16967
// begin tmp := result ;
16894: LD_ADDR_VAR 0 9
16898: PUSH
16899: LD_VAR 0 6
16903: ST_TO_ADDR
// for i = tmp downto 1 do
16904: LD_ADDR_VAR 0 7
16908: PUSH
16909: DOUBLE
16910: LD_VAR 0 9
16914: INC
16915: ST_TO_ADDR
16916: LD_INT 1
16918: PUSH
16919: FOR_DOWNTO
16920: IFFALSE 16965
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
16922: LD_ADDR_VAR 0 6
16926: PUSH
16927: LD_VAR 0 6
16931: PPUSH
16932: LD_VAR 0 9
16936: PUSH
16937: LD_VAR 0 7
16941: MINUS
16942: PUSH
16943: LD_INT 1
16945: PLUS
16946: PPUSH
16947: LD_VAR 0 9
16951: PUSH
16952: LD_VAR 0 7
16956: ARRAY
16957: PPUSH
16958: CALL_OW 1
16962: ST_TO_ADDR
16963: GO 16919
16965: POP
16966: POP
// end ; tmp := [ ] ;
16967: LD_ADDR_VAR 0 9
16971: PUSH
16972: EMPTY
16973: ST_TO_ADDR
// if mode then
16974: LD_VAR 0 5
16978: IFFALSE 17047
// begin for i = 1 to result do
16980: LD_ADDR_VAR 0 7
16984: PUSH
16985: DOUBLE
16986: LD_INT 1
16988: DEC
16989: ST_TO_ADDR
16990: LD_VAR 0 6
16994: PUSH
16995: FOR_TO
16996: IFFALSE 17035
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
16998: LD_ADDR_VAR 0 9
17002: PUSH
17003: LD_VAR 0 9
17007: PPUSH
17008: LD_VAR 0 7
17012: PPUSH
17013: LD_VAR 0 6
17017: PUSH
17018: LD_VAR 0 7
17022: ARRAY
17023: PUSH
17024: LD_INT 1
17026: ARRAY
17027: PPUSH
17028: CALL_OW 1
17032: ST_TO_ADDR
17033: GO 16995
17035: POP
17036: POP
// result := tmp ;
17037: LD_ADDR_VAR 0 6
17041: PUSH
17042: LD_VAR 0 9
17046: ST_TO_ADDR
// end ; end ;
17047: LD_VAR 0 6
17051: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
17052: LD_INT 0
17054: PPUSH
17055: PPUSH
17056: PPUSH
17057: PPUSH
17058: PPUSH
17059: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
17060: LD_ADDR_VAR 0 5
17064: PUSH
17065: LD_INT 0
17067: PUSH
17068: LD_INT 0
17070: PUSH
17071: LD_INT 0
17073: PUSH
17074: EMPTY
17075: PUSH
17076: EMPTY
17077: LIST
17078: LIST
17079: LIST
17080: LIST
17081: ST_TO_ADDR
// if not x or not y then
17082: LD_VAR 0 2
17086: NOT
17087: PUSH
17088: LD_VAR 0 3
17092: NOT
17093: OR
17094: IFFALSE 17098
// exit ;
17096: GO 18748
// if not range then
17098: LD_VAR 0 4
17102: NOT
17103: IFFALSE 17113
// range := 10 ;
17105: LD_ADDR_VAR 0 4
17109: PUSH
17110: LD_INT 10
17112: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
17113: LD_ADDR_VAR 0 8
17117: PUSH
17118: LD_INT 81
17120: PUSH
17121: LD_VAR 0 1
17125: PUSH
17126: EMPTY
17127: LIST
17128: LIST
17129: PUSH
17130: LD_INT 92
17132: PUSH
17133: LD_VAR 0 2
17137: PUSH
17138: LD_VAR 0 3
17142: PUSH
17143: LD_VAR 0 4
17147: PUSH
17148: EMPTY
17149: LIST
17150: LIST
17151: LIST
17152: LIST
17153: PUSH
17154: LD_INT 3
17156: PUSH
17157: LD_INT 21
17159: PUSH
17160: LD_INT 3
17162: PUSH
17163: EMPTY
17164: LIST
17165: LIST
17166: PUSH
17167: EMPTY
17168: LIST
17169: LIST
17170: PUSH
17171: EMPTY
17172: LIST
17173: LIST
17174: LIST
17175: PPUSH
17176: CALL_OW 69
17180: ST_TO_ADDR
// if not tmp then
17181: LD_VAR 0 8
17185: NOT
17186: IFFALSE 17190
// exit ;
17188: GO 18748
// for i in tmp do
17190: LD_ADDR_VAR 0 6
17194: PUSH
17195: LD_VAR 0 8
17199: PUSH
17200: FOR_IN
17201: IFFALSE 18723
// begin points := [ 0 , 0 , 0 ] ;
17203: LD_ADDR_VAR 0 9
17207: PUSH
17208: LD_INT 0
17210: PUSH
17211: LD_INT 0
17213: PUSH
17214: LD_INT 0
17216: PUSH
17217: EMPTY
17218: LIST
17219: LIST
17220: LIST
17221: ST_TO_ADDR
// bpoints := 1 ;
17222: LD_ADDR_VAR 0 10
17226: PUSH
17227: LD_INT 1
17229: ST_TO_ADDR
// case GetType ( i ) of unit_human :
17230: LD_VAR 0 6
17234: PPUSH
17235: CALL_OW 247
17239: PUSH
17240: LD_INT 1
17242: DOUBLE
17243: EQUAL
17244: IFTRUE 17248
17246: GO 17826
17248: POP
// begin if GetClass ( i ) = 1 then
17249: LD_VAR 0 6
17253: PPUSH
17254: CALL_OW 257
17258: PUSH
17259: LD_INT 1
17261: EQUAL
17262: IFFALSE 17283
// points := [ 10 , 5 , 3 ] ;
17264: LD_ADDR_VAR 0 9
17268: PUSH
17269: LD_INT 10
17271: PUSH
17272: LD_INT 5
17274: PUSH
17275: LD_INT 3
17277: PUSH
17278: EMPTY
17279: LIST
17280: LIST
17281: LIST
17282: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
17283: LD_VAR 0 6
17287: PPUSH
17288: CALL_OW 257
17292: PUSH
17293: LD_INT 2
17295: PUSH
17296: LD_INT 3
17298: PUSH
17299: LD_INT 4
17301: PUSH
17302: EMPTY
17303: LIST
17304: LIST
17305: LIST
17306: IN
17307: IFFALSE 17328
// points := [ 3 , 2 , 1 ] ;
17309: LD_ADDR_VAR 0 9
17313: PUSH
17314: LD_INT 3
17316: PUSH
17317: LD_INT 2
17319: PUSH
17320: LD_INT 1
17322: PUSH
17323: EMPTY
17324: LIST
17325: LIST
17326: LIST
17327: ST_TO_ADDR
// if GetClass ( i ) = 5 then
17328: LD_VAR 0 6
17332: PPUSH
17333: CALL_OW 257
17337: PUSH
17338: LD_INT 5
17340: EQUAL
17341: IFFALSE 17362
// points := [ 130 , 5 , 2 ] ;
17343: LD_ADDR_VAR 0 9
17347: PUSH
17348: LD_INT 130
17350: PUSH
17351: LD_INT 5
17353: PUSH
17354: LD_INT 2
17356: PUSH
17357: EMPTY
17358: LIST
17359: LIST
17360: LIST
17361: ST_TO_ADDR
// if GetClass ( i ) = 8 then
17362: LD_VAR 0 6
17366: PPUSH
17367: CALL_OW 257
17371: PUSH
17372: LD_INT 8
17374: EQUAL
17375: IFFALSE 17396
// points := [ 35 , 35 , 30 ] ;
17377: LD_ADDR_VAR 0 9
17381: PUSH
17382: LD_INT 35
17384: PUSH
17385: LD_INT 35
17387: PUSH
17388: LD_INT 30
17390: PUSH
17391: EMPTY
17392: LIST
17393: LIST
17394: LIST
17395: ST_TO_ADDR
// if GetClass ( i ) = 9 then
17396: LD_VAR 0 6
17400: PPUSH
17401: CALL_OW 257
17405: PUSH
17406: LD_INT 9
17408: EQUAL
17409: IFFALSE 17430
// points := [ 20 , 55 , 40 ] ;
17411: LD_ADDR_VAR 0 9
17415: PUSH
17416: LD_INT 20
17418: PUSH
17419: LD_INT 55
17421: PUSH
17422: LD_INT 40
17424: PUSH
17425: EMPTY
17426: LIST
17427: LIST
17428: LIST
17429: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
17430: LD_VAR 0 6
17434: PPUSH
17435: CALL_OW 257
17439: PUSH
17440: LD_INT 12
17442: PUSH
17443: LD_INT 16
17445: PUSH
17446: EMPTY
17447: LIST
17448: LIST
17449: IN
17450: IFFALSE 17471
// points := [ 5 , 3 , 2 ] ;
17452: LD_ADDR_VAR 0 9
17456: PUSH
17457: LD_INT 5
17459: PUSH
17460: LD_INT 3
17462: PUSH
17463: LD_INT 2
17465: PUSH
17466: EMPTY
17467: LIST
17468: LIST
17469: LIST
17470: ST_TO_ADDR
// if GetClass ( i ) = 17 then
17471: LD_VAR 0 6
17475: PPUSH
17476: CALL_OW 257
17480: PUSH
17481: LD_INT 17
17483: EQUAL
17484: IFFALSE 17505
// points := [ 100 , 50 , 75 ] ;
17486: LD_ADDR_VAR 0 9
17490: PUSH
17491: LD_INT 100
17493: PUSH
17494: LD_INT 50
17496: PUSH
17497: LD_INT 75
17499: PUSH
17500: EMPTY
17501: LIST
17502: LIST
17503: LIST
17504: ST_TO_ADDR
// if GetClass ( i ) = 15 then
17505: LD_VAR 0 6
17509: PPUSH
17510: CALL_OW 257
17514: PUSH
17515: LD_INT 15
17517: EQUAL
17518: IFFALSE 17539
// points := [ 10 , 5 , 3 ] ;
17520: LD_ADDR_VAR 0 9
17524: PUSH
17525: LD_INT 10
17527: PUSH
17528: LD_INT 5
17530: PUSH
17531: LD_INT 3
17533: PUSH
17534: EMPTY
17535: LIST
17536: LIST
17537: LIST
17538: ST_TO_ADDR
// if GetClass ( i ) = 14 then
17539: LD_VAR 0 6
17543: PPUSH
17544: CALL_OW 257
17548: PUSH
17549: LD_INT 14
17551: EQUAL
17552: IFFALSE 17573
// points := [ 10 , 0 , 0 ] ;
17554: LD_ADDR_VAR 0 9
17558: PUSH
17559: LD_INT 10
17561: PUSH
17562: LD_INT 0
17564: PUSH
17565: LD_INT 0
17567: PUSH
17568: EMPTY
17569: LIST
17570: LIST
17571: LIST
17572: ST_TO_ADDR
// if GetClass ( i ) = 11 then
17573: LD_VAR 0 6
17577: PPUSH
17578: CALL_OW 257
17582: PUSH
17583: LD_INT 11
17585: EQUAL
17586: IFFALSE 17607
// points := [ 30 , 10 , 5 ] ;
17588: LD_ADDR_VAR 0 9
17592: PUSH
17593: LD_INT 30
17595: PUSH
17596: LD_INT 10
17598: PUSH
17599: LD_INT 5
17601: PUSH
17602: EMPTY
17603: LIST
17604: LIST
17605: LIST
17606: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
17607: LD_VAR 0 1
17611: PPUSH
17612: LD_INT 5
17614: PPUSH
17615: CALL_OW 321
17619: PUSH
17620: LD_INT 2
17622: EQUAL
17623: IFFALSE 17640
// bpoints := bpoints * 1.8 ;
17625: LD_ADDR_VAR 0 10
17629: PUSH
17630: LD_VAR 0 10
17634: PUSH
17635: LD_REAL  1.80000000000000E+0000
17638: MUL
17639: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
17640: LD_VAR 0 6
17644: PPUSH
17645: CALL_OW 257
17649: PUSH
17650: LD_INT 1
17652: PUSH
17653: LD_INT 2
17655: PUSH
17656: LD_INT 3
17658: PUSH
17659: LD_INT 4
17661: PUSH
17662: EMPTY
17663: LIST
17664: LIST
17665: LIST
17666: LIST
17667: IN
17668: PUSH
17669: LD_VAR 0 1
17673: PPUSH
17674: LD_INT 51
17676: PPUSH
17677: CALL_OW 321
17681: PUSH
17682: LD_INT 2
17684: EQUAL
17685: AND
17686: IFFALSE 17703
// bpoints := bpoints * 1.2 ;
17688: LD_ADDR_VAR 0 10
17692: PUSH
17693: LD_VAR 0 10
17697: PUSH
17698: LD_REAL  1.20000000000000E+0000
17701: MUL
17702: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
17703: LD_VAR 0 6
17707: PPUSH
17708: CALL_OW 257
17712: PUSH
17713: LD_INT 5
17715: PUSH
17716: LD_INT 7
17718: PUSH
17719: LD_INT 9
17721: PUSH
17722: EMPTY
17723: LIST
17724: LIST
17725: LIST
17726: IN
17727: PUSH
17728: LD_VAR 0 1
17732: PPUSH
17733: LD_INT 52
17735: PPUSH
17736: CALL_OW 321
17740: PUSH
17741: LD_INT 2
17743: EQUAL
17744: AND
17745: IFFALSE 17762
// bpoints := bpoints * 1.5 ;
17747: LD_ADDR_VAR 0 10
17751: PUSH
17752: LD_VAR 0 10
17756: PUSH
17757: LD_REAL  1.50000000000000E+0000
17760: MUL
17761: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
17762: LD_VAR 0 1
17766: PPUSH
17767: LD_INT 66
17769: PPUSH
17770: CALL_OW 321
17774: PUSH
17775: LD_INT 2
17777: EQUAL
17778: IFFALSE 17795
// bpoints := bpoints * 1.1 ;
17780: LD_ADDR_VAR 0 10
17784: PUSH
17785: LD_VAR 0 10
17789: PUSH
17790: LD_REAL  1.10000000000000E+0000
17793: MUL
17794: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
17795: LD_ADDR_VAR 0 10
17799: PUSH
17800: LD_VAR 0 10
17804: PUSH
17805: LD_VAR 0 6
17809: PPUSH
17810: LD_INT 1
17812: PPUSH
17813: CALL_OW 259
17817: PUSH
17818: LD_REAL  1.15000000000000E+0000
17821: MUL
17822: MUL
17823: ST_TO_ADDR
// end ; unit_vehicle :
17824: GO 18652
17826: LD_INT 2
17828: DOUBLE
17829: EQUAL
17830: IFTRUE 17834
17832: GO 18640
17834: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
17835: LD_VAR 0 6
17839: PPUSH
17840: CALL_OW 264
17844: PUSH
17845: LD_INT 2
17847: PUSH
17848: LD_INT 42
17850: PUSH
17851: LD_INT 24
17853: PUSH
17854: EMPTY
17855: LIST
17856: LIST
17857: LIST
17858: IN
17859: IFFALSE 17880
// points := [ 25 , 5 , 3 ] ;
17861: LD_ADDR_VAR 0 9
17865: PUSH
17866: LD_INT 25
17868: PUSH
17869: LD_INT 5
17871: PUSH
17872: LD_INT 3
17874: PUSH
17875: EMPTY
17876: LIST
17877: LIST
17878: LIST
17879: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
17880: LD_VAR 0 6
17884: PPUSH
17885: CALL_OW 264
17889: PUSH
17890: LD_INT 4
17892: PUSH
17893: LD_INT 43
17895: PUSH
17896: LD_INT 25
17898: PUSH
17899: EMPTY
17900: LIST
17901: LIST
17902: LIST
17903: IN
17904: IFFALSE 17925
// points := [ 40 , 15 , 5 ] ;
17906: LD_ADDR_VAR 0 9
17910: PUSH
17911: LD_INT 40
17913: PUSH
17914: LD_INT 15
17916: PUSH
17917: LD_INT 5
17919: PUSH
17920: EMPTY
17921: LIST
17922: LIST
17923: LIST
17924: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
17925: LD_VAR 0 6
17929: PPUSH
17930: CALL_OW 264
17934: PUSH
17935: LD_INT 3
17937: PUSH
17938: LD_INT 23
17940: PUSH
17941: EMPTY
17942: LIST
17943: LIST
17944: IN
17945: IFFALSE 17966
// points := [ 7 , 25 , 8 ] ;
17947: LD_ADDR_VAR 0 9
17951: PUSH
17952: LD_INT 7
17954: PUSH
17955: LD_INT 25
17957: PUSH
17958: LD_INT 8
17960: PUSH
17961: EMPTY
17962: LIST
17963: LIST
17964: LIST
17965: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
17966: LD_VAR 0 6
17970: PPUSH
17971: CALL_OW 264
17975: PUSH
17976: LD_INT 5
17978: PUSH
17979: LD_INT 27
17981: PUSH
17982: LD_INT 44
17984: PUSH
17985: EMPTY
17986: LIST
17987: LIST
17988: LIST
17989: IN
17990: IFFALSE 18011
// points := [ 14 , 50 , 16 ] ;
17992: LD_ADDR_VAR 0 9
17996: PUSH
17997: LD_INT 14
17999: PUSH
18000: LD_INT 50
18002: PUSH
18003: LD_INT 16
18005: PUSH
18006: EMPTY
18007: LIST
18008: LIST
18009: LIST
18010: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
18011: LD_VAR 0 6
18015: PPUSH
18016: CALL_OW 264
18020: PUSH
18021: LD_INT 6
18023: PUSH
18024: LD_INT 46
18026: PUSH
18027: EMPTY
18028: LIST
18029: LIST
18030: IN
18031: IFFALSE 18052
// points := [ 32 , 120 , 70 ] ;
18033: LD_ADDR_VAR 0 9
18037: PUSH
18038: LD_INT 32
18040: PUSH
18041: LD_INT 120
18043: PUSH
18044: LD_INT 70
18046: PUSH
18047: EMPTY
18048: LIST
18049: LIST
18050: LIST
18051: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
18052: LD_VAR 0 6
18056: PPUSH
18057: CALL_OW 264
18061: PUSH
18062: LD_INT 7
18064: PUSH
18065: LD_INT 28
18067: PUSH
18068: LD_INT 45
18070: PUSH
18071: LD_INT 92
18073: PUSH
18074: EMPTY
18075: LIST
18076: LIST
18077: LIST
18078: LIST
18079: IN
18080: IFFALSE 18101
// points := [ 35 , 20 , 45 ] ;
18082: LD_ADDR_VAR 0 9
18086: PUSH
18087: LD_INT 35
18089: PUSH
18090: LD_INT 20
18092: PUSH
18093: LD_INT 45
18095: PUSH
18096: EMPTY
18097: LIST
18098: LIST
18099: LIST
18100: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
18101: LD_VAR 0 6
18105: PPUSH
18106: CALL_OW 264
18110: PUSH
18111: LD_INT 47
18113: PUSH
18114: EMPTY
18115: LIST
18116: IN
18117: IFFALSE 18138
// points := [ 67 , 45 , 75 ] ;
18119: LD_ADDR_VAR 0 9
18123: PUSH
18124: LD_INT 67
18126: PUSH
18127: LD_INT 45
18129: PUSH
18130: LD_INT 75
18132: PUSH
18133: EMPTY
18134: LIST
18135: LIST
18136: LIST
18137: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
18138: LD_VAR 0 6
18142: PPUSH
18143: CALL_OW 264
18147: PUSH
18148: LD_INT 26
18150: PUSH
18151: EMPTY
18152: LIST
18153: IN
18154: IFFALSE 18175
// points := [ 120 , 30 , 80 ] ;
18156: LD_ADDR_VAR 0 9
18160: PUSH
18161: LD_INT 120
18163: PUSH
18164: LD_INT 30
18166: PUSH
18167: LD_INT 80
18169: PUSH
18170: EMPTY
18171: LIST
18172: LIST
18173: LIST
18174: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
18175: LD_VAR 0 6
18179: PPUSH
18180: CALL_OW 264
18184: PUSH
18185: LD_INT 22
18187: PUSH
18188: EMPTY
18189: LIST
18190: IN
18191: IFFALSE 18212
// points := [ 40 , 1 , 1 ] ;
18193: LD_ADDR_VAR 0 9
18197: PUSH
18198: LD_INT 40
18200: PUSH
18201: LD_INT 1
18203: PUSH
18204: LD_INT 1
18206: PUSH
18207: EMPTY
18208: LIST
18209: LIST
18210: LIST
18211: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
18212: LD_VAR 0 6
18216: PPUSH
18217: CALL_OW 264
18221: PUSH
18222: LD_INT 29
18224: PUSH
18225: EMPTY
18226: LIST
18227: IN
18228: IFFALSE 18249
// points := [ 70 , 200 , 400 ] ;
18230: LD_ADDR_VAR 0 9
18234: PUSH
18235: LD_INT 70
18237: PUSH
18238: LD_INT 200
18240: PUSH
18241: LD_INT 400
18243: PUSH
18244: EMPTY
18245: LIST
18246: LIST
18247: LIST
18248: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
18249: LD_VAR 0 6
18253: PPUSH
18254: CALL_OW 264
18258: PUSH
18259: LD_INT 14
18261: PUSH
18262: LD_INT 53
18264: PUSH
18265: EMPTY
18266: LIST
18267: LIST
18268: IN
18269: IFFALSE 18290
// points := [ 40 , 10 , 20 ] ;
18271: LD_ADDR_VAR 0 9
18275: PUSH
18276: LD_INT 40
18278: PUSH
18279: LD_INT 10
18281: PUSH
18282: LD_INT 20
18284: PUSH
18285: EMPTY
18286: LIST
18287: LIST
18288: LIST
18289: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
18290: LD_VAR 0 6
18294: PPUSH
18295: CALL_OW 264
18299: PUSH
18300: LD_INT 9
18302: PUSH
18303: EMPTY
18304: LIST
18305: IN
18306: IFFALSE 18327
// points := [ 5 , 70 , 20 ] ;
18308: LD_ADDR_VAR 0 9
18312: PUSH
18313: LD_INT 5
18315: PUSH
18316: LD_INT 70
18318: PUSH
18319: LD_INT 20
18321: PUSH
18322: EMPTY
18323: LIST
18324: LIST
18325: LIST
18326: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
18327: LD_VAR 0 6
18331: PPUSH
18332: CALL_OW 264
18336: PUSH
18337: LD_INT 10
18339: PUSH
18340: EMPTY
18341: LIST
18342: IN
18343: IFFALSE 18364
// points := [ 35 , 110 , 70 ] ;
18345: LD_ADDR_VAR 0 9
18349: PUSH
18350: LD_INT 35
18352: PUSH
18353: LD_INT 110
18355: PUSH
18356: LD_INT 70
18358: PUSH
18359: EMPTY
18360: LIST
18361: LIST
18362: LIST
18363: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
18364: LD_VAR 0 6
18368: PPUSH
18369: CALL_OW 265
18373: PUSH
18374: LD_INT 25
18376: EQUAL
18377: IFFALSE 18398
// points := [ 80 , 65 , 100 ] ;
18379: LD_ADDR_VAR 0 9
18383: PUSH
18384: LD_INT 80
18386: PUSH
18387: LD_INT 65
18389: PUSH
18390: LD_INT 100
18392: PUSH
18393: EMPTY
18394: LIST
18395: LIST
18396: LIST
18397: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
18398: LD_VAR 0 6
18402: PPUSH
18403: CALL_OW 263
18407: PUSH
18408: LD_INT 1
18410: EQUAL
18411: IFFALSE 18446
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
18413: LD_ADDR_VAR 0 10
18417: PUSH
18418: LD_VAR 0 10
18422: PUSH
18423: LD_VAR 0 6
18427: PPUSH
18428: CALL_OW 311
18432: PPUSH
18433: LD_INT 3
18435: PPUSH
18436: CALL_OW 259
18440: PUSH
18441: LD_INT 4
18443: MUL
18444: MUL
18445: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
18446: LD_VAR 0 6
18450: PPUSH
18451: CALL_OW 263
18455: PUSH
18456: LD_INT 2
18458: EQUAL
18459: IFFALSE 18510
// begin j := IsControledBy ( i ) ;
18461: LD_ADDR_VAR 0 7
18465: PUSH
18466: LD_VAR 0 6
18470: PPUSH
18471: CALL_OW 312
18475: ST_TO_ADDR
// if j then
18476: LD_VAR 0 7
18480: IFFALSE 18510
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
18482: LD_ADDR_VAR 0 10
18486: PUSH
18487: LD_VAR 0 10
18491: PUSH
18492: LD_VAR 0 7
18496: PPUSH
18497: LD_INT 3
18499: PPUSH
18500: CALL_OW 259
18504: PUSH
18505: LD_INT 3
18507: MUL
18508: MUL
18509: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
18510: LD_VAR 0 6
18514: PPUSH
18515: CALL_OW 264
18519: PUSH
18520: LD_INT 5
18522: PUSH
18523: LD_INT 6
18525: PUSH
18526: LD_INT 46
18528: PUSH
18529: LD_INT 44
18531: PUSH
18532: LD_INT 47
18534: PUSH
18535: LD_INT 45
18537: PUSH
18538: LD_INT 28
18540: PUSH
18541: LD_INT 7
18543: PUSH
18544: LD_INT 27
18546: PUSH
18547: LD_INT 29
18549: PUSH
18550: EMPTY
18551: LIST
18552: LIST
18553: LIST
18554: LIST
18555: LIST
18556: LIST
18557: LIST
18558: LIST
18559: LIST
18560: LIST
18561: IN
18562: PUSH
18563: LD_VAR 0 1
18567: PPUSH
18568: LD_INT 52
18570: PPUSH
18571: CALL_OW 321
18575: PUSH
18576: LD_INT 2
18578: EQUAL
18579: AND
18580: IFFALSE 18597
// bpoints := bpoints * 1.2 ;
18582: LD_ADDR_VAR 0 10
18586: PUSH
18587: LD_VAR 0 10
18591: PUSH
18592: LD_REAL  1.20000000000000E+0000
18595: MUL
18596: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
18597: LD_VAR 0 6
18601: PPUSH
18602: CALL_OW 264
18606: PUSH
18607: LD_INT 6
18609: PUSH
18610: LD_INT 46
18612: PUSH
18613: LD_INT 47
18615: PUSH
18616: EMPTY
18617: LIST
18618: LIST
18619: LIST
18620: IN
18621: IFFALSE 18638
// bpoints := bpoints * 1.2 ;
18623: LD_ADDR_VAR 0 10
18627: PUSH
18628: LD_VAR 0 10
18632: PUSH
18633: LD_REAL  1.20000000000000E+0000
18636: MUL
18637: ST_TO_ADDR
// end ; unit_building :
18638: GO 18652
18640: LD_INT 3
18642: DOUBLE
18643: EQUAL
18644: IFTRUE 18648
18646: GO 18651
18648: POP
// ; end ;
18649: GO 18652
18651: POP
// for j = 1 to 3 do
18652: LD_ADDR_VAR 0 7
18656: PUSH
18657: DOUBLE
18658: LD_INT 1
18660: DEC
18661: ST_TO_ADDR
18662: LD_INT 3
18664: PUSH
18665: FOR_TO
18666: IFFALSE 18719
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
18668: LD_ADDR_VAR 0 5
18672: PUSH
18673: LD_VAR 0 5
18677: PPUSH
18678: LD_VAR 0 7
18682: PPUSH
18683: LD_VAR 0 5
18687: PUSH
18688: LD_VAR 0 7
18692: ARRAY
18693: PUSH
18694: LD_VAR 0 9
18698: PUSH
18699: LD_VAR 0 7
18703: ARRAY
18704: PUSH
18705: LD_VAR 0 10
18709: MUL
18710: PLUS
18711: PPUSH
18712: CALL_OW 1
18716: ST_TO_ADDR
18717: GO 18665
18719: POP
18720: POP
// end ;
18721: GO 17200
18723: POP
18724: POP
// result := Replace ( result , 4 , tmp ) ;
18725: LD_ADDR_VAR 0 5
18729: PUSH
18730: LD_VAR 0 5
18734: PPUSH
18735: LD_INT 4
18737: PPUSH
18738: LD_VAR 0 8
18742: PPUSH
18743: CALL_OW 1
18747: ST_TO_ADDR
// end ;
18748: LD_VAR 0 5
18752: RET
// export function DangerAtRange ( unit , range ) ; begin
18753: LD_INT 0
18755: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
18756: LD_ADDR_VAR 0 3
18760: PUSH
18761: LD_VAR 0 1
18765: PPUSH
18766: CALL_OW 255
18770: PPUSH
18771: LD_VAR 0 1
18775: PPUSH
18776: CALL_OW 250
18780: PPUSH
18781: LD_VAR 0 1
18785: PPUSH
18786: CALL_OW 251
18790: PPUSH
18791: LD_VAR 0 2
18795: PPUSH
18796: CALL 17052 0 4
18800: ST_TO_ADDR
// end ;
18801: LD_VAR 0 3
18805: RET
// export function DangerInArea ( side , area ) ; begin
18806: LD_INT 0
18808: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
18809: LD_ADDR_VAR 0 3
18813: PUSH
18814: LD_VAR 0 2
18818: PPUSH
18819: LD_INT 81
18821: PUSH
18822: LD_VAR 0 1
18826: PUSH
18827: EMPTY
18828: LIST
18829: LIST
18830: PPUSH
18831: CALL_OW 70
18835: ST_TO_ADDR
// end ;
18836: LD_VAR 0 3
18840: RET
// export function IsExtension ( b ) ; begin
18841: LD_INT 0
18843: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
18844: LD_ADDR_VAR 0 2
18848: PUSH
18849: LD_VAR 0 1
18853: PUSH
18854: LD_INT 23
18856: PUSH
18857: LD_INT 20
18859: PUSH
18860: LD_INT 22
18862: PUSH
18863: LD_INT 17
18865: PUSH
18866: LD_INT 24
18868: PUSH
18869: LD_INT 21
18871: PUSH
18872: LD_INT 19
18874: PUSH
18875: LD_INT 16
18877: PUSH
18878: LD_INT 25
18880: PUSH
18881: LD_INT 18
18883: PUSH
18884: EMPTY
18885: LIST
18886: LIST
18887: LIST
18888: LIST
18889: LIST
18890: LIST
18891: LIST
18892: LIST
18893: LIST
18894: LIST
18895: IN
18896: ST_TO_ADDR
// end ;
18897: LD_VAR 0 2
18901: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
18902: LD_INT 0
18904: PPUSH
18905: PPUSH
18906: PPUSH
// result := [ ] ;
18907: LD_ADDR_VAR 0 4
18911: PUSH
18912: EMPTY
18913: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
18914: LD_ADDR_VAR 0 5
18918: PUSH
18919: LD_VAR 0 2
18923: PPUSH
18924: LD_INT 21
18926: PUSH
18927: LD_INT 3
18929: PUSH
18930: EMPTY
18931: LIST
18932: LIST
18933: PPUSH
18934: CALL_OW 70
18938: ST_TO_ADDR
// if not tmp then
18939: LD_VAR 0 5
18943: NOT
18944: IFFALSE 18948
// exit ;
18946: GO 19012
// if checkLink then
18948: LD_VAR 0 3
18952: IFFALSE 19002
// begin for i in tmp do
18954: LD_ADDR_VAR 0 6
18958: PUSH
18959: LD_VAR 0 5
18963: PUSH
18964: FOR_IN
18965: IFFALSE 19000
// if GetBase ( i ) <> base then
18967: LD_VAR 0 6
18971: PPUSH
18972: CALL_OW 274
18976: PUSH
18977: LD_VAR 0 1
18981: NONEQUAL
18982: IFFALSE 18998
// ComLinkToBase ( base , i ) ;
18984: LD_VAR 0 1
18988: PPUSH
18989: LD_VAR 0 6
18993: PPUSH
18994: CALL_OW 169
18998: GO 18964
19000: POP
19001: POP
// end ; result := tmp ;
19002: LD_ADDR_VAR 0 4
19006: PUSH
19007: LD_VAR 0 5
19011: ST_TO_ADDR
// end ;
19012: LD_VAR 0 4
19016: RET
// export function ComComplete ( units , b ) ; var i ; begin
19017: LD_INT 0
19019: PPUSH
19020: PPUSH
// if not units then
19021: LD_VAR 0 1
19025: NOT
19026: IFFALSE 19030
// exit ;
19028: GO 19120
// for i in units do
19030: LD_ADDR_VAR 0 4
19034: PUSH
19035: LD_VAR 0 1
19039: PUSH
19040: FOR_IN
19041: IFFALSE 19118
// if BuildingStatus ( b ) = bs_build then
19043: LD_VAR 0 2
19047: PPUSH
19048: CALL_OW 461
19052: PUSH
19053: LD_INT 1
19055: EQUAL
19056: IFFALSE 19116
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
19058: LD_VAR 0 4
19062: PPUSH
19063: LD_STRING h
19065: PUSH
19066: LD_VAR 0 2
19070: PPUSH
19071: CALL_OW 250
19075: PUSH
19076: LD_VAR 0 2
19080: PPUSH
19081: CALL_OW 251
19085: PUSH
19086: LD_VAR 0 2
19090: PUSH
19091: LD_INT 0
19093: PUSH
19094: LD_INT 0
19096: PUSH
19097: LD_INT 0
19099: PUSH
19100: EMPTY
19101: LIST
19102: LIST
19103: LIST
19104: LIST
19105: LIST
19106: LIST
19107: LIST
19108: PUSH
19109: EMPTY
19110: LIST
19111: PPUSH
19112: CALL_OW 446
19116: GO 19040
19118: POP
19119: POP
// end ;
19120: LD_VAR 0 3
19124: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
19125: LD_INT 0
19127: PPUSH
19128: PPUSH
19129: PPUSH
19130: PPUSH
19131: PPUSH
19132: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
19133: LD_VAR 0 1
19137: NOT
19138: PUSH
19139: LD_VAR 0 1
19143: PPUSH
19144: CALL_OW 263
19148: PUSH
19149: LD_INT 2
19151: NONEQUAL
19152: OR
19153: IFFALSE 19157
// exit ;
19155: GO 19473
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
19157: LD_ADDR_VAR 0 6
19161: PUSH
19162: LD_INT 22
19164: PUSH
19165: LD_VAR 0 1
19169: PPUSH
19170: CALL_OW 255
19174: PUSH
19175: EMPTY
19176: LIST
19177: LIST
19178: PUSH
19179: LD_INT 2
19181: PUSH
19182: LD_INT 30
19184: PUSH
19185: LD_INT 36
19187: PUSH
19188: EMPTY
19189: LIST
19190: LIST
19191: PUSH
19192: LD_INT 34
19194: PUSH
19195: LD_INT 31
19197: PUSH
19198: EMPTY
19199: LIST
19200: LIST
19201: PUSH
19202: EMPTY
19203: LIST
19204: LIST
19205: LIST
19206: PUSH
19207: EMPTY
19208: LIST
19209: LIST
19210: PPUSH
19211: CALL_OW 69
19215: ST_TO_ADDR
// if not tmp then
19216: LD_VAR 0 6
19220: NOT
19221: IFFALSE 19225
// exit ;
19223: GO 19473
// result := [ ] ;
19225: LD_ADDR_VAR 0 2
19229: PUSH
19230: EMPTY
19231: ST_TO_ADDR
// for i in tmp do
19232: LD_ADDR_VAR 0 3
19236: PUSH
19237: LD_VAR 0 6
19241: PUSH
19242: FOR_IN
19243: IFFALSE 19314
// begin t := UnitsInside ( i ) ;
19245: LD_ADDR_VAR 0 4
19249: PUSH
19250: LD_VAR 0 3
19254: PPUSH
19255: CALL_OW 313
19259: ST_TO_ADDR
// if t then
19260: LD_VAR 0 4
19264: IFFALSE 19312
// for j in t do
19266: LD_ADDR_VAR 0 7
19270: PUSH
19271: LD_VAR 0 4
19275: PUSH
19276: FOR_IN
19277: IFFALSE 19310
// result := Replace ( result , result + 1 , j ) ;
19279: LD_ADDR_VAR 0 2
19283: PUSH
19284: LD_VAR 0 2
19288: PPUSH
19289: LD_VAR 0 2
19293: PUSH
19294: LD_INT 1
19296: PLUS
19297: PPUSH
19298: LD_VAR 0 7
19302: PPUSH
19303: CALL_OW 1
19307: ST_TO_ADDR
19308: GO 19276
19310: POP
19311: POP
// end ;
19312: GO 19242
19314: POP
19315: POP
// if not result then
19316: LD_VAR 0 2
19320: NOT
19321: IFFALSE 19325
// exit ;
19323: GO 19473
// mech := result [ 1 ] ;
19325: LD_ADDR_VAR 0 5
19329: PUSH
19330: LD_VAR 0 2
19334: PUSH
19335: LD_INT 1
19337: ARRAY
19338: ST_TO_ADDR
// if result > 1 then
19339: LD_VAR 0 2
19343: PUSH
19344: LD_INT 1
19346: GREATER
19347: IFFALSE 19459
// begin for i = 2 to result do
19349: LD_ADDR_VAR 0 3
19353: PUSH
19354: DOUBLE
19355: LD_INT 2
19357: DEC
19358: ST_TO_ADDR
19359: LD_VAR 0 2
19363: PUSH
19364: FOR_TO
19365: IFFALSE 19457
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
19367: LD_ADDR_VAR 0 4
19371: PUSH
19372: LD_VAR 0 2
19376: PUSH
19377: LD_VAR 0 3
19381: ARRAY
19382: PPUSH
19383: LD_INT 3
19385: PPUSH
19386: CALL_OW 259
19390: PUSH
19391: LD_VAR 0 2
19395: PUSH
19396: LD_VAR 0 3
19400: ARRAY
19401: PPUSH
19402: CALL_OW 432
19406: MINUS
19407: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
19408: LD_VAR 0 4
19412: PUSH
19413: LD_VAR 0 5
19417: PPUSH
19418: LD_INT 3
19420: PPUSH
19421: CALL_OW 259
19425: PUSH
19426: LD_VAR 0 5
19430: PPUSH
19431: CALL_OW 432
19435: MINUS
19436: GREATEREQUAL
19437: IFFALSE 19455
// mech := result [ i ] ;
19439: LD_ADDR_VAR 0 5
19443: PUSH
19444: LD_VAR 0 2
19448: PUSH
19449: LD_VAR 0 3
19453: ARRAY
19454: ST_TO_ADDR
// end ;
19455: GO 19364
19457: POP
19458: POP
// end ; ComLinkTo ( vehicle , mech ) ;
19459: LD_VAR 0 1
19463: PPUSH
19464: LD_VAR 0 5
19468: PPUSH
19469: CALL_OW 135
// end ;
19473: LD_VAR 0 2
19477: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
19478: LD_INT 0
19480: PPUSH
19481: PPUSH
19482: PPUSH
19483: PPUSH
19484: PPUSH
19485: PPUSH
19486: PPUSH
19487: PPUSH
19488: PPUSH
19489: PPUSH
19490: PPUSH
19491: PPUSH
19492: PPUSH
// result := [ ] ;
19493: LD_ADDR_VAR 0 7
19497: PUSH
19498: EMPTY
19499: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
19500: LD_VAR 0 1
19504: PPUSH
19505: CALL_OW 266
19509: PUSH
19510: LD_INT 0
19512: PUSH
19513: LD_INT 1
19515: PUSH
19516: EMPTY
19517: LIST
19518: LIST
19519: IN
19520: NOT
19521: IFFALSE 19525
// exit ;
19523: GO 21159
// if name then
19525: LD_VAR 0 3
19529: IFFALSE 19545
// SetBName ( base_dep , name ) ;
19531: LD_VAR 0 1
19535: PPUSH
19536: LD_VAR 0 3
19540: PPUSH
19541: CALL_OW 500
// base := GetBase ( base_dep ) ;
19545: LD_ADDR_VAR 0 15
19549: PUSH
19550: LD_VAR 0 1
19554: PPUSH
19555: CALL_OW 274
19559: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
19560: LD_ADDR_VAR 0 16
19564: PUSH
19565: LD_VAR 0 1
19569: PPUSH
19570: CALL_OW 255
19574: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
19575: LD_ADDR_VAR 0 17
19579: PUSH
19580: LD_VAR 0 1
19584: PPUSH
19585: CALL_OW 248
19589: ST_TO_ADDR
// if sources then
19590: LD_VAR 0 5
19594: IFFALSE 19641
// for i = 1 to 3 do
19596: LD_ADDR_VAR 0 8
19600: PUSH
19601: DOUBLE
19602: LD_INT 1
19604: DEC
19605: ST_TO_ADDR
19606: LD_INT 3
19608: PUSH
19609: FOR_TO
19610: IFFALSE 19639
// AddResourceType ( base , i , sources [ i ] ) ;
19612: LD_VAR 0 15
19616: PPUSH
19617: LD_VAR 0 8
19621: PPUSH
19622: LD_VAR 0 5
19626: PUSH
19627: LD_VAR 0 8
19631: ARRAY
19632: PPUSH
19633: CALL_OW 276
19637: GO 19609
19639: POP
19640: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
19641: LD_ADDR_VAR 0 18
19645: PUSH
19646: LD_VAR 0 15
19650: PPUSH
19651: LD_VAR 0 2
19655: PPUSH
19656: LD_INT 1
19658: PPUSH
19659: CALL 18902 0 3
19663: ST_TO_ADDR
// InitHc ;
19664: CALL_OW 19
// InitUc ;
19668: CALL_OW 18
// uc_side := side ;
19672: LD_ADDR_OWVAR 20
19676: PUSH
19677: LD_VAR 0 16
19681: ST_TO_ADDR
// uc_nation := nation ;
19682: LD_ADDR_OWVAR 21
19686: PUSH
19687: LD_VAR 0 17
19691: ST_TO_ADDR
// if buildings then
19692: LD_VAR 0 18
19696: IFFALSE 21018
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
19698: LD_ADDR_VAR 0 19
19702: PUSH
19703: LD_VAR 0 18
19707: PPUSH
19708: LD_INT 2
19710: PUSH
19711: LD_INT 30
19713: PUSH
19714: LD_INT 29
19716: PUSH
19717: EMPTY
19718: LIST
19719: LIST
19720: PUSH
19721: LD_INT 30
19723: PUSH
19724: LD_INT 30
19726: PUSH
19727: EMPTY
19728: LIST
19729: LIST
19730: PUSH
19731: EMPTY
19732: LIST
19733: LIST
19734: LIST
19735: PPUSH
19736: CALL_OW 72
19740: ST_TO_ADDR
// if tmp then
19741: LD_VAR 0 19
19745: IFFALSE 19793
// for i in tmp do
19747: LD_ADDR_VAR 0 8
19751: PUSH
19752: LD_VAR 0 19
19756: PUSH
19757: FOR_IN
19758: IFFALSE 19791
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
19760: LD_VAR 0 8
19764: PPUSH
19765: CALL_OW 250
19769: PPUSH
19770: LD_VAR 0 8
19774: PPUSH
19775: CALL_OW 251
19779: PPUSH
19780: LD_VAR 0 16
19784: PPUSH
19785: CALL_OW 441
19789: GO 19757
19791: POP
19792: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
19793: LD_VAR 0 18
19797: PPUSH
19798: LD_INT 2
19800: PUSH
19801: LD_INT 30
19803: PUSH
19804: LD_INT 32
19806: PUSH
19807: EMPTY
19808: LIST
19809: LIST
19810: PUSH
19811: LD_INT 30
19813: PUSH
19814: LD_INT 33
19816: PUSH
19817: EMPTY
19818: LIST
19819: LIST
19820: PUSH
19821: EMPTY
19822: LIST
19823: LIST
19824: LIST
19825: PPUSH
19826: CALL_OW 72
19830: IFFALSE 19918
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
19832: LD_ADDR_VAR 0 8
19836: PUSH
19837: LD_VAR 0 18
19841: PPUSH
19842: LD_INT 2
19844: PUSH
19845: LD_INT 30
19847: PUSH
19848: LD_INT 32
19850: PUSH
19851: EMPTY
19852: LIST
19853: LIST
19854: PUSH
19855: LD_INT 30
19857: PUSH
19858: LD_INT 33
19860: PUSH
19861: EMPTY
19862: LIST
19863: LIST
19864: PUSH
19865: EMPTY
19866: LIST
19867: LIST
19868: LIST
19869: PPUSH
19870: CALL_OW 72
19874: PUSH
19875: FOR_IN
19876: IFFALSE 19916
// begin if not GetBWeapon ( i ) then
19878: LD_VAR 0 8
19882: PPUSH
19883: CALL_OW 269
19887: NOT
19888: IFFALSE 19914
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
19890: LD_VAR 0 8
19894: PPUSH
19895: LD_VAR 0 8
19899: PPUSH
19900: LD_VAR 0 2
19904: PPUSH
19905: CALL 21164 0 2
19909: PPUSH
19910: CALL_OW 431
// end ;
19914: GO 19875
19916: POP
19917: POP
// end ; for i = 1 to personel do
19918: LD_ADDR_VAR 0 8
19922: PUSH
19923: DOUBLE
19924: LD_INT 1
19926: DEC
19927: ST_TO_ADDR
19928: LD_VAR 0 6
19932: PUSH
19933: FOR_TO
19934: IFFALSE 20998
// begin if i > 4 then
19936: LD_VAR 0 8
19940: PUSH
19941: LD_INT 4
19943: GREATER
19944: IFFALSE 19948
// break ;
19946: GO 20998
// case i of 1 :
19948: LD_VAR 0 8
19952: PUSH
19953: LD_INT 1
19955: DOUBLE
19956: EQUAL
19957: IFTRUE 19961
19959: GO 20041
19961: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
19962: LD_ADDR_VAR 0 12
19966: PUSH
19967: LD_VAR 0 18
19971: PPUSH
19972: LD_INT 22
19974: PUSH
19975: LD_VAR 0 16
19979: PUSH
19980: EMPTY
19981: LIST
19982: LIST
19983: PUSH
19984: LD_INT 58
19986: PUSH
19987: EMPTY
19988: LIST
19989: PUSH
19990: LD_INT 2
19992: PUSH
19993: LD_INT 30
19995: PUSH
19996: LD_INT 32
19998: PUSH
19999: EMPTY
20000: LIST
20001: LIST
20002: PUSH
20003: LD_INT 30
20005: PUSH
20006: LD_INT 4
20008: PUSH
20009: EMPTY
20010: LIST
20011: LIST
20012: PUSH
20013: LD_INT 30
20015: PUSH
20016: LD_INT 5
20018: PUSH
20019: EMPTY
20020: LIST
20021: LIST
20022: PUSH
20023: EMPTY
20024: LIST
20025: LIST
20026: LIST
20027: LIST
20028: PUSH
20029: EMPTY
20030: LIST
20031: LIST
20032: LIST
20033: PPUSH
20034: CALL_OW 72
20038: ST_TO_ADDR
20039: GO 20263
20041: LD_INT 2
20043: DOUBLE
20044: EQUAL
20045: IFTRUE 20049
20047: GO 20111
20049: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
20050: LD_ADDR_VAR 0 12
20054: PUSH
20055: LD_VAR 0 18
20059: PPUSH
20060: LD_INT 22
20062: PUSH
20063: LD_VAR 0 16
20067: PUSH
20068: EMPTY
20069: LIST
20070: LIST
20071: PUSH
20072: LD_INT 2
20074: PUSH
20075: LD_INT 30
20077: PUSH
20078: LD_INT 0
20080: PUSH
20081: EMPTY
20082: LIST
20083: LIST
20084: PUSH
20085: LD_INT 30
20087: PUSH
20088: LD_INT 1
20090: PUSH
20091: EMPTY
20092: LIST
20093: LIST
20094: PUSH
20095: EMPTY
20096: LIST
20097: LIST
20098: LIST
20099: PUSH
20100: EMPTY
20101: LIST
20102: LIST
20103: PPUSH
20104: CALL_OW 72
20108: ST_TO_ADDR
20109: GO 20263
20111: LD_INT 3
20113: DOUBLE
20114: EQUAL
20115: IFTRUE 20119
20117: GO 20181
20119: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
20120: LD_ADDR_VAR 0 12
20124: PUSH
20125: LD_VAR 0 18
20129: PPUSH
20130: LD_INT 22
20132: PUSH
20133: LD_VAR 0 16
20137: PUSH
20138: EMPTY
20139: LIST
20140: LIST
20141: PUSH
20142: LD_INT 2
20144: PUSH
20145: LD_INT 30
20147: PUSH
20148: LD_INT 2
20150: PUSH
20151: EMPTY
20152: LIST
20153: LIST
20154: PUSH
20155: LD_INT 30
20157: PUSH
20158: LD_INT 3
20160: PUSH
20161: EMPTY
20162: LIST
20163: LIST
20164: PUSH
20165: EMPTY
20166: LIST
20167: LIST
20168: LIST
20169: PUSH
20170: EMPTY
20171: LIST
20172: LIST
20173: PPUSH
20174: CALL_OW 72
20178: ST_TO_ADDR
20179: GO 20263
20181: LD_INT 4
20183: DOUBLE
20184: EQUAL
20185: IFTRUE 20189
20187: GO 20262
20189: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
20190: LD_ADDR_VAR 0 12
20194: PUSH
20195: LD_VAR 0 18
20199: PPUSH
20200: LD_INT 22
20202: PUSH
20203: LD_VAR 0 16
20207: PUSH
20208: EMPTY
20209: LIST
20210: LIST
20211: PUSH
20212: LD_INT 2
20214: PUSH
20215: LD_INT 30
20217: PUSH
20218: LD_INT 6
20220: PUSH
20221: EMPTY
20222: LIST
20223: LIST
20224: PUSH
20225: LD_INT 30
20227: PUSH
20228: LD_INT 7
20230: PUSH
20231: EMPTY
20232: LIST
20233: LIST
20234: PUSH
20235: LD_INT 30
20237: PUSH
20238: LD_INT 8
20240: PUSH
20241: EMPTY
20242: LIST
20243: LIST
20244: PUSH
20245: EMPTY
20246: LIST
20247: LIST
20248: LIST
20249: LIST
20250: PUSH
20251: EMPTY
20252: LIST
20253: LIST
20254: PPUSH
20255: CALL_OW 72
20259: ST_TO_ADDR
20260: GO 20263
20262: POP
// if i = 1 then
20263: LD_VAR 0 8
20267: PUSH
20268: LD_INT 1
20270: EQUAL
20271: IFFALSE 20382
// begin tmp := [ ] ;
20273: LD_ADDR_VAR 0 19
20277: PUSH
20278: EMPTY
20279: ST_TO_ADDR
// for j in f do
20280: LD_ADDR_VAR 0 9
20284: PUSH
20285: LD_VAR 0 12
20289: PUSH
20290: FOR_IN
20291: IFFALSE 20364
// if GetBType ( j ) = b_bunker then
20293: LD_VAR 0 9
20297: PPUSH
20298: CALL_OW 266
20302: PUSH
20303: LD_INT 32
20305: EQUAL
20306: IFFALSE 20333
// tmp := Insert ( tmp , 1 , j ) else
20308: LD_ADDR_VAR 0 19
20312: PUSH
20313: LD_VAR 0 19
20317: PPUSH
20318: LD_INT 1
20320: PPUSH
20321: LD_VAR 0 9
20325: PPUSH
20326: CALL_OW 2
20330: ST_TO_ADDR
20331: GO 20362
// tmp := Insert ( tmp , tmp + 1 , j ) ;
20333: LD_ADDR_VAR 0 19
20337: PUSH
20338: LD_VAR 0 19
20342: PPUSH
20343: LD_VAR 0 19
20347: PUSH
20348: LD_INT 1
20350: PLUS
20351: PPUSH
20352: LD_VAR 0 9
20356: PPUSH
20357: CALL_OW 2
20361: ST_TO_ADDR
20362: GO 20290
20364: POP
20365: POP
// if tmp then
20366: LD_VAR 0 19
20370: IFFALSE 20382
// f := tmp ;
20372: LD_ADDR_VAR 0 12
20376: PUSH
20377: LD_VAR 0 19
20381: ST_TO_ADDR
// end ; x := personel [ i ] ;
20382: LD_ADDR_VAR 0 13
20386: PUSH
20387: LD_VAR 0 6
20391: PUSH
20392: LD_VAR 0 8
20396: ARRAY
20397: ST_TO_ADDR
// if x = - 1 then
20398: LD_VAR 0 13
20402: PUSH
20403: LD_INT 1
20405: NEG
20406: EQUAL
20407: IFFALSE 20616
// begin for j in f do
20409: LD_ADDR_VAR 0 9
20413: PUSH
20414: LD_VAR 0 12
20418: PUSH
20419: FOR_IN
20420: IFFALSE 20612
// repeat InitHc ;
20422: CALL_OW 19
// if GetBType ( j ) = b_barracks then
20426: LD_VAR 0 9
20430: PPUSH
20431: CALL_OW 266
20435: PUSH
20436: LD_INT 5
20438: EQUAL
20439: IFFALSE 20509
// begin if UnitsInside ( j ) < 3 then
20441: LD_VAR 0 9
20445: PPUSH
20446: CALL_OW 313
20450: PUSH
20451: LD_INT 3
20453: LESS
20454: IFFALSE 20490
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
20456: LD_INT 0
20458: PPUSH
20459: LD_INT 5
20461: PUSH
20462: LD_INT 8
20464: PUSH
20465: LD_INT 9
20467: PUSH
20468: EMPTY
20469: LIST
20470: LIST
20471: LIST
20472: PUSH
20473: LD_VAR 0 17
20477: ARRAY
20478: PPUSH
20479: LD_VAR 0 4
20483: PPUSH
20484: CALL_OW 380
20488: GO 20507
// PrepareHuman ( false , i , skill ) ;
20490: LD_INT 0
20492: PPUSH
20493: LD_VAR 0 8
20497: PPUSH
20498: LD_VAR 0 4
20502: PPUSH
20503: CALL_OW 380
// end else
20507: GO 20526
// PrepareHuman ( false , i , skill ) ;
20509: LD_INT 0
20511: PPUSH
20512: LD_VAR 0 8
20516: PPUSH
20517: LD_VAR 0 4
20521: PPUSH
20522: CALL_OW 380
// un := CreateHuman ;
20526: LD_ADDR_VAR 0 14
20530: PUSH
20531: CALL_OW 44
20535: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20536: LD_ADDR_VAR 0 7
20540: PUSH
20541: LD_VAR 0 7
20545: PPUSH
20546: LD_INT 1
20548: PPUSH
20549: LD_VAR 0 14
20553: PPUSH
20554: CALL_OW 2
20558: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
20559: LD_VAR 0 14
20563: PPUSH
20564: LD_VAR 0 9
20568: PPUSH
20569: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
20573: LD_VAR 0 9
20577: PPUSH
20578: CALL_OW 313
20582: PUSH
20583: LD_INT 6
20585: EQUAL
20586: PUSH
20587: LD_VAR 0 9
20591: PPUSH
20592: CALL_OW 266
20596: PUSH
20597: LD_INT 32
20599: PUSH
20600: LD_INT 31
20602: PUSH
20603: EMPTY
20604: LIST
20605: LIST
20606: IN
20607: OR
20608: IFFALSE 20422
20610: GO 20419
20612: POP
20613: POP
// end else
20614: GO 20996
// for j = 1 to x do
20616: LD_ADDR_VAR 0 9
20620: PUSH
20621: DOUBLE
20622: LD_INT 1
20624: DEC
20625: ST_TO_ADDR
20626: LD_VAR 0 13
20630: PUSH
20631: FOR_TO
20632: IFFALSE 20994
// begin InitHc ;
20634: CALL_OW 19
// if not f then
20638: LD_VAR 0 12
20642: NOT
20643: IFFALSE 20732
// begin PrepareHuman ( false , i , skill ) ;
20645: LD_INT 0
20647: PPUSH
20648: LD_VAR 0 8
20652: PPUSH
20653: LD_VAR 0 4
20657: PPUSH
20658: CALL_OW 380
// un := CreateHuman ;
20662: LD_ADDR_VAR 0 14
20666: PUSH
20667: CALL_OW 44
20671: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20672: LD_ADDR_VAR 0 7
20676: PUSH
20677: LD_VAR 0 7
20681: PPUSH
20682: LD_INT 1
20684: PPUSH
20685: LD_VAR 0 14
20689: PPUSH
20690: CALL_OW 2
20694: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
20695: LD_VAR 0 14
20699: PPUSH
20700: LD_VAR 0 1
20704: PPUSH
20705: CALL_OW 250
20709: PPUSH
20710: LD_VAR 0 1
20714: PPUSH
20715: CALL_OW 251
20719: PPUSH
20720: LD_INT 10
20722: PPUSH
20723: LD_INT 0
20725: PPUSH
20726: CALL_OW 50
// continue ;
20730: GO 20631
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
20732: LD_VAR 0 12
20736: PUSH
20737: LD_INT 1
20739: ARRAY
20740: PPUSH
20741: CALL_OW 313
20745: PUSH
20746: LD_VAR 0 12
20750: PUSH
20751: LD_INT 1
20753: ARRAY
20754: PPUSH
20755: CALL_OW 266
20759: PUSH
20760: LD_INT 32
20762: PUSH
20763: LD_INT 31
20765: PUSH
20766: EMPTY
20767: LIST
20768: LIST
20769: IN
20770: AND
20771: PUSH
20772: LD_VAR 0 12
20776: PUSH
20777: LD_INT 1
20779: ARRAY
20780: PPUSH
20781: CALL_OW 313
20785: PUSH
20786: LD_INT 6
20788: EQUAL
20789: OR
20790: IFFALSE 20810
// f := Delete ( f , 1 ) ;
20792: LD_ADDR_VAR 0 12
20796: PUSH
20797: LD_VAR 0 12
20801: PPUSH
20802: LD_INT 1
20804: PPUSH
20805: CALL_OW 3
20809: ST_TO_ADDR
// if not f then
20810: LD_VAR 0 12
20814: NOT
20815: IFFALSE 20833
// begin x := x + 2 ;
20817: LD_ADDR_VAR 0 13
20821: PUSH
20822: LD_VAR 0 13
20826: PUSH
20827: LD_INT 2
20829: PLUS
20830: ST_TO_ADDR
// continue ;
20831: GO 20631
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
20833: LD_VAR 0 12
20837: PUSH
20838: LD_INT 1
20840: ARRAY
20841: PPUSH
20842: CALL_OW 266
20846: PUSH
20847: LD_INT 5
20849: EQUAL
20850: IFFALSE 20924
// begin if UnitsInside ( f [ 1 ] ) < 3 then
20852: LD_VAR 0 12
20856: PUSH
20857: LD_INT 1
20859: ARRAY
20860: PPUSH
20861: CALL_OW 313
20865: PUSH
20866: LD_INT 3
20868: LESS
20869: IFFALSE 20905
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
20871: LD_INT 0
20873: PPUSH
20874: LD_INT 5
20876: PUSH
20877: LD_INT 8
20879: PUSH
20880: LD_INT 9
20882: PUSH
20883: EMPTY
20884: LIST
20885: LIST
20886: LIST
20887: PUSH
20888: LD_VAR 0 17
20892: ARRAY
20893: PPUSH
20894: LD_VAR 0 4
20898: PPUSH
20899: CALL_OW 380
20903: GO 20922
// PrepareHuman ( false , i , skill ) ;
20905: LD_INT 0
20907: PPUSH
20908: LD_VAR 0 8
20912: PPUSH
20913: LD_VAR 0 4
20917: PPUSH
20918: CALL_OW 380
// end else
20922: GO 20941
// PrepareHuman ( false , i , skill ) ;
20924: LD_INT 0
20926: PPUSH
20927: LD_VAR 0 8
20931: PPUSH
20932: LD_VAR 0 4
20936: PPUSH
20937: CALL_OW 380
// un := CreateHuman ;
20941: LD_ADDR_VAR 0 14
20945: PUSH
20946: CALL_OW 44
20950: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20951: LD_ADDR_VAR 0 7
20955: PUSH
20956: LD_VAR 0 7
20960: PPUSH
20961: LD_INT 1
20963: PPUSH
20964: LD_VAR 0 14
20968: PPUSH
20969: CALL_OW 2
20973: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
20974: LD_VAR 0 14
20978: PPUSH
20979: LD_VAR 0 12
20983: PUSH
20984: LD_INT 1
20986: ARRAY
20987: PPUSH
20988: CALL_OW 52
// end ;
20992: GO 20631
20994: POP
20995: POP
// end ;
20996: GO 19933
20998: POP
20999: POP
// result := result ^ buildings ;
21000: LD_ADDR_VAR 0 7
21004: PUSH
21005: LD_VAR 0 7
21009: PUSH
21010: LD_VAR 0 18
21014: ADD
21015: ST_TO_ADDR
// end else
21016: GO 21159
// begin for i = 1 to personel do
21018: LD_ADDR_VAR 0 8
21022: PUSH
21023: DOUBLE
21024: LD_INT 1
21026: DEC
21027: ST_TO_ADDR
21028: LD_VAR 0 6
21032: PUSH
21033: FOR_TO
21034: IFFALSE 21157
// begin if i > 4 then
21036: LD_VAR 0 8
21040: PUSH
21041: LD_INT 4
21043: GREATER
21044: IFFALSE 21048
// break ;
21046: GO 21157
// x := personel [ i ] ;
21048: LD_ADDR_VAR 0 13
21052: PUSH
21053: LD_VAR 0 6
21057: PUSH
21058: LD_VAR 0 8
21062: ARRAY
21063: ST_TO_ADDR
// if x = - 1 then
21064: LD_VAR 0 13
21068: PUSH
21069: LD_INT 1
21071: NEG
21072: EQUAL
21073: IFFALSE 21077
// continue ;
21075: GO 21033
// PrepareHuman ( false , i , skill ) ;
21077: LD_INT 0
21079: PPUSH
21080: LD_VAR 0 8
21084: PPUSH
21085: LD_VAR 0 4
21089: PPUSH
21090: CALL_OW 380
// un := CreateHuman ;
21094: LD_ADDR_VAR 0 14
21098: PUSH
21099: CALL_OW 44
21103: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
21104: LD_VAR 0 14
21108: PPUSH
21109: LD_VAR 0 1
21113: PPUSH
21114: CALL_OW 250
21118: PPUSH
21119: LD_VAR 0 1
21123: PPUSH
21124: CALL_OW 251
21128: PPUSH
21129: LD_INT 10
21131: PPUSH
21132: LD_INT 0
21134: PPUSH
21135: CALL_OW 50
// result := result ^ un ;
21139: LD_ADDR_VAR 0 7
21143: PUSH
21144: LD_VAR 0 7
21148: PUSH
21149: LD_VAR 0 14
21153: ADD
21154: ST_TO_ADDR
// end ;
21155: GO 21033
21157: POP
21158: POP
// end ; end ;
21159: LD_VAR 0 7
21163: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
21164: LD_INT 0
21166: PPUSH
21167: PPUSH
21168: PPUSH
21169: PPUSH
21170: PPUSH
21171: PPUSH
21172: PPUSH
21173: PPUSH
21174: PPUSH
21175: PPUSH
21176: PPUSH
21177: PPUSH
21178: PPUSH
21179: PPUSH
21180: PPUSH
21181: PPUSH
// result := false ;
21182: LD_ADDR_VAR 0 3
21186: PUSH
21187: LD_INT 0
21189: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
21190: LD_VAR 0 1
21194: NOT
21195: PUSH
21196: LD_VAR 0 1
21200: PPUSH
21201: CALL_OW 266
21205: PUSH
21206: LD_INT 32
21208: PUSH
21209: LD_INT 33
21211: PUSH
21212: EMPTY
21213: LIST
21214: LIST
21215: IN
21216: NOT
21217: OR
21218: IFFALSE 21222
// exit ;
21220: GO 22331
// nat := GetNation ( tower ) ;
21222: LD_ADDR_VAR 0 12
21226: PUSH
21227: LD_VAR 0 1
21231: PPUSH
21232: CALL_OW 248
21236: ST_TO_ADDR
// side := GetSide ( tower ) ;
21237: LD_ADDR_VAR 0 16
21241: PUSH
21242: LD_VAR 0 1
21246: PPUSH
21247: CALL_OW 255
21251: ST_TO_ADDR
// x := GetX ( tower ) ;
21252: LD_ADDR_VAR 0 10
21256: PUSH
21257: LD_VAR 0 1
21261: PPUSH
21262: CALL_OW 250
21266: ST_TO_ADDR
// y := GetY ( tower ) ;
21267: LD_ADDR_VAR 0 11
21271: PUSH
21272: LD_VAR 0 1
21276: PPUSH
21277: CALL_OW 251
21281: ST_TO_ADDR
// if not x or not y then
21282: LD_VAR 0 10
21286: NOT
21287: PUSH
21288: LD_VAR 0 11
21292: NOT
21293: OR
21294: IFFALSE 21298
// exit ;
21296: GO 22331
// weapon := 0 ;
21298: LD_ADDR_VAR 0 18
21302: PUSH
21303: LD_INT 0
21305: ST_TO_ADDR
// fac_list := [ ] ;
21306: LD_ADDR_VAR 0 17
21310: PUSH
21311: EMPTY
21312: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
21313: LD_ADDR_VAR 0 6
21317: PUSH
21318: LD_VAR 0 1
21322: PPUSH
21323: CALL_OW 274
21327: PPUSH
21328: LD_VAR 0 2
21332: PPUSH
21333: LD_INT 0
21335: PPUSH
21336: CALL 18902 0 3
21340: PPUSH
21341: LD_INT 30
21343: PUSH
21344: LD_INT 3
21346: PUSH
21347: EMPTY
21348: LIST
21349: LIST
21350: PPUSH
21351: CALL_OW 72
21355: ST_TO_ADDR
// if not factories then
21356: LD_VAR 0 6
21360: NOT
21361: IFFALSE 21365
// exit ;
21363: GO 22331
// for i in factories do
21365: LD_ADDR_VAR 0 8
21369: PUSH
21370: LD_VAR 0 6
21374: PUSH
21375: FOR_IN
21376: IFFALSE 21401
// fac_list := fac_list union AvailableWeaponList ( i ) ;
21378: LD_ADDR_VAR 0 17
21382: PUSH
21383: LD_VAR 0 17
21387: PUSH
21388: LD_VAR 0 8
21392: PPUSH
21393: CALL_OW 478
21397: UNION
21398: ST_TO_ADDR
21399: GO 21375
21401: POP
21402: POP
// if not fac_list then
21403: LD_VAR 0 17
21407: NOT
21408: IFFALSE 21412
// exit ;
21410: GO 22331
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
21412: LD_ADDR_VAR 0 5
21416: PUSH
21417: LD_INT 4
21419: PUSH
21420: LD_INT 5
21422: PUSH
21423: LD_INT 9
21425: PUSH
21426: LD_INT 10
21428: PUSH
21429: LD_INT 6
21431: PUSH
21432: LD_INT 7
21434: PUSH
21435: LD_INT 11
21437: PUSH
21438: EMPTY
21439: LIST
21440: LIST
21441: LIST
21442: LIST
21443: LIST
21444: LIST
21445: LIST
21446: PUSH
21447: LD_INT 27
21449: PUSH
21450: LD_INT 28
21452: PUSH
21453: LD_INT 26
21455: PUSH
21456: LD_INT 30
21458: PUSH
21459: EMPTY
21460: LIST
21461: LIST
21462: LIST
21463: LIST
21464: PUSH
21465: LD_INT 43
21467: PUSH
21468: LD_INT 44
21470: PUSH
21471: LD_INT 46
21473: PUSH
21474: LD_INT 45
21476: PUSH
21477: LD_INT 47
21479: PUSH
21480: LD_INT 49
21482: PUSH
21483: EMPTY
21484: LIST
21485: LIST
21486: LIST
21487: LIST
21488: LIST
21489: LIST
21490: PUSH
21491: EMPTY
21492: LIST
21493: LIST
21494: LIST
21495: PUSH
21496: LD_VAR 0 12
21500: ARRAY
21501: ST_TO_ADDR
// list := list isect fac_list ;
21502: LD_ADDR_VAR 0 5
21506: PUSH
21507: LD_VAR 0 5
21511: PUSH
21512: LD_VAR 0 17
21516: ISECT
21517: ST_TO_ADDR
// if not list then
21518: LD_VAR 0 5
21522: NOT
21523: IFFALSE 21527
// exit ;
21525: GO 22331
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
21527: LD_VAR 0 12
21531: PUSH
21532: LD_INT 3
21534: EQUAL
21535: PUSH
21536: LD_INT 49
21538: PUSH
21539: LD_VAR 0 5
21543: IN
21544: AND
21545: PUSH
21546: LD_INT 31
21548: PPUSH
21549: LD_VAR 0 16
21553: PPUSH
21554: CALL_OW 321
21558: PUSH
21559: LD_INT 2
21561: EQUAL
21562: AND
21563: IFFALSE 21623
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
21565: LD_INT 22
21567: PUSH
21568: LD_VAR 0 16
21572: PUSH
21573: EMPTY
21574: LIST
21575: LIST
21576: PUSH
21577: LD_INT 35
21579: PUSH
21580: LD_INT 49
21582: PUSH
21583: EMPTY
21584: LIST
21585: LIST
21586: PUSH
21587: LD_INT 91
21589: PUSH
21590: LD_VAR 0 1
21594: PUSH
21595: LD_INT 10
21597: PUSH
21598: EMPTY
21599: LIST
21600: LIST
21601: LIST
21602: PUSH
21603: EMPTY
21604: LIST
21605: LIST
21606: LIST
21607: PPUSH
21608: CALL_OW 69
21612: NOT
21613: IFFALSE 21623
// weapon := ru_time_lapser ;
21615: LD_ADDR_VAR 0 18
21619: PUSH
21620: LD_INT 49
21622: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
21623: LD_VAR 0 12
21627: PUSH
21628: LD_INT 1
21630: PUSH
21631: LD_INT 2
21633: PUSH
21634: EMPTY
21635: LIST
21636: LIST
21637: IN
21638: PUSH
21639: LD_INT 11
21641: PUSH
21642: LD_VAR 0 5
21646: IN
21647: PUSH
21648: LD_INT 30
21650: PUSH
21651: LD_VAR 0 5
21655: IN
21656: OR
21657: AND
21658: PUSH
21659: LD_INT 6
21661: PPUSH
21662: LD_VAR 0 16
21666: PPUSH
21667: CALL_OW 321
21671: PUSH
21672: LD_INT 2
21674: EQUAL
21675: AND
21676: IFFALSE 21841
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
21678: LD_INT 22
21680: PUSH
21681: LD_VAR 0 16
21685: PUSH
21686: EMPTY
21687: LIST
21688: LIST
21689: PUSH
21690: LD_INT 2
21692: PUSH
21693: LD_INT 35
21695: PUSH
21696: LD_INT 11
21698: PUSH
21699: EMPTY
21700: LIST
21701: LIST
21702: PUSH
21703: LD_INT 35
21705: PUSH
21706: LD_INT 30
21708: PUSH
21709: EMPTY
21710: LIST
21711: LIST
21712: PUSH
21713: EMPTY
21714: LIST
21715: LIST
21716: LIST
21717: PUSH
21718: LD_INT 91
21720: PUSH
21721: LD_VAR 0 1
21725: PUSH
21726: LD_INT 18
21728: PUSH
21729: EMPTY
21730: LIST
21731: LIST
21732: LIST
21733: PUSH
21734: EMPTY
21735: LIST
21736: LIST
21737: LIST
21738: PPUSH
21739: CALL_OW 69
21743: NOT
21744: PUSH
21745: LD_INT 22
21747: PUSH
21748: LD_VAR 0 16
21752: PUSH
21753: EMPTY
21754: LIST
21755: LIST
21756: PUSH
21757: LD_INT 2
21759: PUSH
21760: LD_INT 30
21762: PUSH
21763: LD_INT 32
21765: PUSH
21766: EMPTY
21767: LIST
21768: LIST
21769: PUSH
21770: LD_INT 30
21772: PUSH
21773: LD_INT 33
21775: PUSH
21776: EMPTY
21777: LIST
21778: LIST
21779: PUSH
21780: EMPTY
21781: LIST
21782: LIST
21783: LIST
21784: PUSH
21785: LD_INT 91
21787: PUSH
21788: LD_VAR 0 1
21792: PUSH
21793: LD_INT 12
21795: PUSH
21796: EMPTY
21797: LIST
21798: LIST
21799: LIST
21800: PUSH
21801: EMPTY
21802: LIST
21803: LIST
21804: LIST
21805: PUSH
21806: EMPTY
21807: LIST
21808: PPUSH
21809: CALL_OW 69
21813: PUSH
21814: LD_INT 2
21816: GREATER
21817: AND
21818: IFFALSE 21841
// weapon := [ us_radar , ar_radar ] [ nat ] ;
21820: LD_ADDR_VAR 0 18
21824: PUSH
21825: LD_INT 11
21827: PUSH
21828: LD_INT 30
21830: PUSH
21831: EMPTY
21832: LIST
21833: LIST
21834: PUSH
21835: LD_VAR 0 12
21839: ARRAY
21840: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
21841: LD_VAR 0 18
21845: NOT
21846: PUSH
21847: LD_INT 40
21849: PPUSH
21850: LD_VAR 0 16
21854: PPUSH
21855: CALL_OW 321
21859: PUSH
21860: LD_INT 2
21862: EQUAL
21863: AND
21864: PUSH
21865: LD_INT 7
21867: PUSH
21868: LD_VAR 0 5
21872: IN
21873: PUSH
21874: LD_INT 28
21876: PUSH
21877: LD_VAR 0 5
21881: IN
21882: OR
21883: PUSH
21884: LD_INT 45
21886: PUSH
21887: LD_VAR 0 5
21891: IN
21892: OR
21893: AND
21894: IFFALSE 22148
// begin hex := GetHexInfo ( x , y ) ;
21896: LD_ADDR_VAR 0 4
21900: PUSH
21901: LD_VAR 0 10
21905: PPUSH
21906: LD_VAR 0 11
21910: PPUSH
21911: CALL_OW 546
21915: ST_TO_ADDR
// if hex [ 1 ] then
21916: LD_VAR 0 4
21920: PUSH
21921: LD_INT 1
21923: ARRAY
21924: IFFALSE 21928
// exit ;
21926: GO 22331
// height := hex [ 2 ] ;
21928: LD_ADDR_VAR 0 15
21932: PUSH
21933: LD_VAR 0 4
21937: PUSH
21938: LD_INT 2
21940: ARRAY
21941: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
21942: LD_ADDR_VAR 0 14
21946: PUSH
21947: LD_INT 0
21949: PUSH
21950: LD_INT 2
21952: PUSH
21953: LD_INT 3
21955: PUSH
21956: LD_INT 5
21958: PUSH
21959: EMPTY
21960: LIST
21961: LIST
21962: LIST
21963: LIST
21964: ST_TO_ADDR
// for i in tmp do
21965: LD_ADDR_VAR 0 8
21969: PUSH
21970: LD_VAR 0 14
21974: PUSH
21975: FOR_IN
21976: IFFALSE 22146
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
21978: LD_ADDR_VAR 0 9
21982: PUSH
21983: LD_VAR 0 10
21987: PPUSH
21988: LD_VAR 0 8
21992: PPUSH
21993: LD_INT 5
21995: PPUSH
21996: CALL_OW 272
22000: PUSH
22001: LD_VAR 0 11
22005: PPUSH
22006: LD_VAR 0 8
22010: PPUSH
22011: LD_INT 5
22013: PPUSH
22014: CALL_OW 273
22018: PUSH
22019: EMPTY
22020: LIST
22021: LIST
22022: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
22023: LD_VAR 0 9
22027: PUSH
22028: LD_INT 1
22030: ARRAY
22031: PPUSH
22032: LD_VAR 0 9
22036: PUSH
22037: LD_INT 2
22039: ARRAY
22040: PPUSH
22041: CALL_OW 488
22045: IFFALSE 22144
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
22047: LD_ADDR_VAR 0 4
22051: PUSH
22052: LD_VAR 0 9
22056: PUSH
22057: LD_INT 1
22059: ARRAY
22060: PPUSH
22061: LD_VAR 0 9
22065: PUSH
22066: LD_INT 2
22068: ARRAY
22069: PPUSH
22070: CALL_OW 546
22074: ST_TO_ADDR
// if hex [ 1 ] then
22075: LD_VAR 0 4
22079: PUSH
22080: LD_INT 1
22082: ARRAY
22083: IFFALSE 22087
// continue ;
22085: GO 21975
// h := hex [ 2 ] ;
22087: LD_ADDR_VAR 0 13
22091: PUSH
22092: LD_VAR 0 4
22096: PUSH
22097: LD_INT 2
22099: ARRAY
22100: ST_TO_ADDR
// if h + 7 < height then
22101: LD_VAR 0 13
22105: PUSH
22106: LD_INT 7
22108: PLUS
22109: PUSH
22110: LD_VAR 0 15
22114: LESS
22115: IFFALSE 22144
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
22117: LD_ADDR_VAR 0 18
22121: PUSH
22122: LD_INT 7
22124: PUSH
22125: LD_INT 28
22127: PUSH
22128: LD_INT 45
22130: PUSH
22131: EMPTY
22132: LIST
22133: LIST
22134: LIST
22135: PUSH
22136: LD_VAR 0 12
22140: ARRAY
22141: ST_TO_ADDR
// break ;
22142: GO 22146
// end ; end ; end ;
22144: GO 21975
22146: POP
22147: POP
// end ; if not weapon then
22148: LD_VAR 0 18
22152: NOT
22153: IFFALSE 22213
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
22155: LD_ADDR_VAR 0 5
22159: PUSH
22160: LD_VAR 0 5
22164: PUSH
22165: LD_INT 11
22167: PUSH
22168: LD_INT 30
22170: PUSH
22171: LD_INT 49
22173: PUSH
22174: EMPTY
22175: LIST
22176: LIST
22177: LIST
22178: DIFF
22179: ST_TO_ADDR
// if not list then
22180: LD_VAR 0 5
22184: NOT
22185: IFFALSE 22189
// exit ;
22187: GO 22331
// weapon := list [ rand ( 1 , list ) ] ;
22189: LD_ADDR_VAR 0 18
22193: PUSH
22194: LD_VAR 0 5
22198: PUSH
22199: LD_INT 1
22201: PPUSH
22202: LD_VAR 0 5
22206: PPUSH
22207: CALL_OW 12
22211: ARRAY
22212: ST_TO_ADDR
// end ; if weapon then
22213: LD_VAR 0 18
22217: IFFALSE 22331
// begin tmp := CostOfWeapon ( weapon ) ;
22219: LD_ADDR_VAR 0 14
22223: PUSH
22224: LD_VAR 0 18
22228: PPUSH
22229: CALL_OW 451
22233: ST_TO_ADDR
// j := GetBase ( tower ) ;
22234: LD_ADDR_VAR 0 9
22238: PUSH
22239: LD_VAR 0 1
22243: PPUSH
22244: CALL_OW 274
22248: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
22249: LD_VAR 0 9
22253: PPUSH
22254: LD_INT 1
22256: PPUSH
22257: CALL_OW 275
22261: PUSH
22262: LD_VAR 0 14
22266: PUSH
22267: LD_INT 1
22269: ARRAY
22270: GREATEREQUAL
22271: PUSH
22272: LD_VAR 0 9
22276: PPUSH
22277: LD_INT 2
22279: PPUSH
22280: CALL_OW 275
22284: PUSH
22285: LD_VAR 0 14
22289: PUSH
22290: LD_INT 2
22292: ARRAY
22293: GREATEREQUAL
22294: AND
22295: PUSH
22296: LD_VAR 0 9
22300: PPUSH
22301: LD_INT 3
22303: PPUSH
22304: CALL_OW 275
22308: PUSH
22309: LD_VAR 0 14
22313: PUSH
22314: LD_INT 3
22316: ARRAY
22317: GREATEREQUAL
22318: AND
22319: IFFALSE 22331
// result := weapon ;
22321: LD_ADDR_VAR 0 3
22325: PUSH
22326: LD_VAR 0 18
22330: ST_TO_ADDR
// end ; end ;
22331: LD_VAR 0 3
22335: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
22336: LD_INT 0
22338: PPUSH
22339: PPUSH
// result := true ;
22340: LD_ADDR_VAR 0 3
22344: PUSH
22345: LD_INT 1
22347: ST_TO_ADDR
// if array1 = array2 then
22348: LD_VAR 0 1
22352: PUSH
22353: LD_VAR 0 2
22357: EQUAL
22358: IFFALSE 22418
// begin for i = 1 to array1 do
22360: LD_ADDR_VAR 0 4
22364: PUSH
22365: DOUBLE
22366: LD_INT 1
22368: DEC
22369: ST_TO_ADDR
22370: LD_VAR 0 1
22374: PUSH
22375: FOR_TO
22376: IFFALSE 22414
// if array1 [ i ] <> array2 [ i ] then
22378: LD_VAR 0 1
22382: PUSH
22383: LD_VAR 0 4
22387: ARRAY
22388: PUSH
22389: LD_VAR 0 2
22393: PUSH
22394: LD_VAR 0 4
22398: ARRAY
22399: NONEQUAL
22400: IFFALSE 22412
// begin result := false ;
22402: LD_ADDR_VAR 0 3
22406: PUSH
22407: LD_INT 0
22409: ST_TO_ADDR
// break ;
22410: GO 22414
// end ;
22412: GO 22375
22414: POP
22415: POP
// end else
22416: GO 22426
// result := false ;
22418: LD_ADDR_VAR 0 3
22422: PUSH
22423: LD_INT 0
22425: ST_TO_ADDR
// end ;
22426: LD_VAR 0 3
22430: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
22431: LD_INT 0
22433: PPUSH
22434: PPUSH
// if not array1 or not array2 then
22435: LD_VAR 0 1
22439: NOT
22440: PUSH
22441: LD_VAR 0 2
22445: NOT
22446: OR
22447: IFFALSE 22451
// exit ;
22449: GO 22515
// result := true ;
22451: LD_ADDR_VAR 0 3
22455: PUSH
22456: LD_INT 1
22458: ST_TO_ADDR
// for i = 1 to array1 do
22459: LD_ADDR_VAR 0 4
22463: PUSH
22464: DOUBLE
22465: LD_INT 1
22467: DEC
22468: ST_TO_ADDR
22469: LD_VAR 0 1
22473: PUSH
22474: FOR_TO
22475: IFFALSE 22513
// if array1 [ i ] <> array2 [ i ] then
22477: LD_VAR 0 1
22481: PUSH
22482: LD_VAR 0 4
22486: ARRAY
22487: PUSH
22488: LD_VAR 0 2
22492: PUSH
22493: LD_VAR 0 4
22497: ARRAY
22498: NONEQUAL
22499: IFFALSE 22511
// begin result := false ;
22501: LD_ADDR_VAR 0 3
22505: PUSH
22506: LD_INT 0
22508: ST_TO_ADDR
// break ;
22509: GO 22513
// end ;
22511: GO 22474
22513: POP
22514: POP
// end ;
22515: LD_VAR 0 3
22519: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
22520: LD_INT 0
22522: PPUSH
22523: PPUSH
22524: PPUSH
// pom := GetBase ( fac ) ;
22525: LD_ADDR_VAR 0 5
22529: PUSH
22530: LD_VAR 0 1
22534: PPUSH
22535: CALL_OW 274
22539: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
22540: LD_ADDR_VAR 0 4
22544: PUSH
22545: LD_VAR 0 2
22549: PUSH
22550: LD_INT 1
22552: ARRAY
22553: PPUSH
22554: LD_VAR 0 2
22558: PUSH
22559: LD_INT 2
22561: ARRAY
22562: PPUSH
22563: LD_VAR 0 2
22567: PUSH
22568: LD_INT 3
22570: ARRAY
22571: PPUSH
22572: LD_VAR 0 2
22576: PUSH
22577: LD_INT 4
22579: ARRAY
22580: PPUSH
22581: CALL_OW 449
22585: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22586: LD_ADDR_VAR 0 3
22590: PUSH
22591: LD_VAR 0 5
22595: PPUSH
22596: LD_INT 1
22598: PPUSH
22599: CALL_OW 275
22603: PUSH
22604: LD_VAR 0 4
22608: PUSH
22609: LD_INT 1
22611: ARRAY
22612: GREATEREQUAL
22613: PUSH
22614: LD_VAR 0 5
22618: PPUSH
22619: LD_INT 2
22621: PPUSH
22622: CALL_OW 275
22626: PUSH
22627: LD_VAR 0 4
22631: PUSH
22632: LD_INT 2
22634: ARRAY
22635: GREATEREQUAL
22636: AND
22637: PUSH
22638: LD_VAR 0 5
22642: PPUSH
22643: LD_INT 3
22645: PPUSH
22646: CALL_OW 275
22650: PUSH
22651: LD_VAR 0 4
22655: PUSH
22656: LD_INT 3
22658: ARRAY
22659: GREATEREQUAL
22660: AND
22661: ST_TO_ADDR
// end ;
22662: LD_VAR 0 3
22666: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
22667: LD_INT 0
22669: PPUSH
22670: PPUSH
22671: PPUSH
22672: PPUSH
// pom := GetBase ( building ) ;
22673: LD_ADDR_VAR 0 3
22677: PUSH
22678: LD_VAR 0 1
22682: PPUSH
22683: CALL_OW 274
22687: ST_TO_ADDR
// if not pom then
22688: LD_VAR 0 3
22692: NOT
22693: IFFALSE 22697
// exit ;
22695: GO 22867
// btype := GetBType ( building ) ;
22697: LD_ADDR_VAR 0 5
22701: PUSH
22702: LD_VAR 0 1
22706: PPUSH
22707: CALL_OW 266
22711: ST_TO_ADDR
// if btype = b_armoury then
22712: LD_VAR 0 5
22716: PUSH
22717: LD_INT 4
22719: EQUAL
22720: IFFALSE 22730
// btype := b_barracks ;
22722: LD_ADDR_VAR 0 5
22726: PUSH
22727: LD_INT 5
22729: ST_TO_ADDR
// if btype = b_depot then
22730: LD_VAR 0 5
22734: PUSH
22735: LD_INT 0
22737: EQUAL
22738: IFFALSE 22748
// btype := b_warehouse ;
22740: LD_ADDR_VAR 0 5
22744: PUSH
22745: LD_INT 1
22747: ST_TO_ADDR
// if btype = b_workshop then
22748: LD_VAR 0 5
22752: PUSH
22753: LD_INT 2
22755: EQUAL
22756: IFFALSE 22766
// btype := b_factory ;
22758: LD_ADDR_VAR 0 5
22762: PUSH
22763: LD_INT 3
22765: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
22766: LD_ADDR_VAR 0 4
22770: PUSH
22771: LD_VAR 0 5
22775: PPUSH
22776: LD_VAR 0 1
22780: PPUSH
22781: CALL_OW 248
22785: PPUSH
22786: CALL_OW 450
22790: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22791: LD_ADDR_VAR 0 2
22795: PUSH
22796: LD_VAR 0 3
22800: PPUSH
22801: LD_INT 1
22803: PPUSH
22804: CALL_OW 275
22808: PUSH
22809: LD_VAR 0 4
22813: PUSH
22814: LD_INT 1
22816: ARRAY
22817: GREATEREQUAL
22818: PUSH
22819: LD_VAR 0 3
22823: PPUSH
22824: LD_INT 2
22826: PPUSH
22827: CALL_OW 275
22831: PUSH
22832: LD_VAR 0 4
22836: PUSH
22837: LD_INT 2
22839: ARRAY
22840: GREATEREQUAL
22841: AND
22842: PUSH
22843: LD_VAR 0 3
22847: PPUSH
22848: LD_INT 3
22850: PPUSH
22851: CALL_OW 275
22855: PUSH
22856: LD_VAR 0 4
22860: PUSH
22861: LD_INT 3
22863: ARRAY
22864: GREATEREQUAL
22865: AND
22866: ST_TO_ADDR
// end ;
22867: LD_VAR 0 2
22871: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
22872: LD_INT 0
22874: PPUSH
22875: PPUSH
22876: PPUSH
// pom := GetBase ( building ) ;
22877: LD_ADDR_VAR 0 4
22881: PUSH
22882: LD_VAR 0 1
22886: PPUSH
22887: CALL_OW 274
22891: ST_TO_ADDR
// if not pom then
22892: LD_VAR 0 4
22896: NOT
22897: IFFALSE 22901
// exit ;
22899: GO 23002
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
22901: LD_ADDR_VAR 0 5
22905: PUSH
22906: LD_VAR 0 2
22910: PPUSH
22911: LD_VAR 0 1
22915: PPUSH
22916: CALL_OW 248
22920: PPUSH
22921: CALL_OW 450
22925: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22926: LD_ADDR_VAR 0 3
22930: PUSH
22931: LD_VAR 0 4
22935: PPUSH
22936: LD_INT 1
22938: PPUSH
22939: CALL_OW 275
22943: PUSH
22944: LD_VAR 0 5
22948: PUSH
22949: LD_INT 1
22951: ARRAY
22952: GREATEREQUAL
22953: PUSH
22954: LD_VAR 0 4
22958: PPUSH
22959: LD_INT 2
22961: PPUSH
22962: CALL_OW 275
22966: PUSH
22967: LD_VAR 0 5
22971: PUSH
22972: LD_INT 2
22974: ARRAY
22975: GREATEREQUAL
22976: AND
22977: PUSH
22978: LD_VAR 0 4
22982: PPUSH
22983: LD_INT 3
22985: PPUSH
22986: CALL_OW 275
22990: PUSH
22991: LD_VAR 0 5
22995: PUSH
22996: LD_INT 3
22998: ARRAY
22999: GREATEREQUAL
23000: AND
23001: ST_TO_ADDR
// end ;
23002: LD_VAR 0 3
23006: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
23007: LD_INT 0
23009: PPUSH
23010: PPUSH
23011: PPUSH
23012: PPUSH
23013: PPUSH
23014: PPUSH
23015: PPUSH
23016: PPUSH
23017: PPUSH
23018: PPUSH
23019: PPUSH
// result := false ;
23020: LD_ADDR_VAR 0 8
23024: PUSH
23025: LD_INT 0
23027: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
23028: LD_VAR 0 5
23032: NOT
23033: PUSH
23034: LD_VAR 0 1
23038: NOT
23039: OR
23040: PUSH
23041: LD_VAR 0 2
23045: NOT
23046: OR
23047: PUSH
23048: LD_VAR 0 3
23052: NOT
23053: OR
23054: IFFALSE 23058
// exit ;
23056: GO 23872
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
23058: LD_ADDR_VAR 0 14
23062: PUSH
23063: LD_VAR 0 1
23067: PPUSH
23068: LD_VAR 0 2
23072: PPUSH
23073: LD_VAR 0 3
23077: PPUSH
23078: LD_VAR 0 4
23082: PPUSH
23083: LD_VAR 0 5
23087: PUSH
23088: LD_INT 1
23090: ARRAY
23091: PPUSH
23092: CALL_OW 248
23096: PPUSH
23097: LD_INT 0
23099: PPUSH
23100: CALL 25105 0 6
23104: ST_TO_ADDR
// if not hexes then
23105: LD_VAR 0 14
23109: NOT
23110: IFFALSE 23114
// exit ;
23112: GO 23872
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
23114: LD_ADDR_VAR 0 17
23118: PUSH
23119: LD_VAR 0 5
23123: PPUSH
23124: LD_INT 22
23126: PUSH
23127: LD_VAR 0 13
23131: PPUSH
23132: CALL_OW 255
23136: PUSH
23137: EMPTY
23138: LIST
23139: LIST
23140: PUSH
23141: LD_INT 2
23143: PUSH
23144: LD_INT 30
23146: PUSH
23147: LD_INT 0
23149: PUSH
23150: EMPTY
23151: LIST
23152: LIST
23153: PUSH
23154: LD_INT 30
23156: PUSH
23157: LD_INT 1
23159: PUSH
23160: EMPTY
23161: LIST
23162: LIST
23163: PUSH
23164: EMPTY
23165: LIST
23166: LIST
23167: LIST
23168: PUSH
23169: EMPTY
23170: LIST
23171: LIST
23172: PPUSH
23173: CALL_OW 72
23177: ST_TO_ADDR
// for i = 1 to hexes do
23178: LD_ADDR_VAR 0 9
23182: PUSH
23183: DOUBLE
23184: LD_INT 1
23186: DEC
23187: ST_TO_ADDR
23188: LD_VAR 0 14
23192: PUSH
23193: FOR_TO
23194: IFFALSE 23870
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
23196: LD_ADDR_VAR 0 13
23200: PUSH
23201: LD_VAR 0 14
23205: PUSH
23206: LD_VAR 0 9
23210: ARRAY
23211: PUSH
23212: LD_INT 1
23214: ARRAY
23215: PPUSH
23216: LD_VAR 0 14
23220: PUSH
23221: LD_VAR 0 9
23225: ARRAY
23226: PUSH
23227: LD_INT 2
23229: ARRAY
23230: PPUSH
23231: CALL_OW 428
23235: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
23236: LD_VAR 0 14
23240: PUSH
23241: LD_VAR 0 9
23245: ARRAY
23246: PUSH
23247: LD_INT 1
23249: ARRAY
23250: PPUSH
23251: LD_VAR 0 14
23255: PUSH
23256: LD_VAR 0 9
23260: ARRAY
23261: PUSH
23262: LD_INT 2
23264: ARRAY
23265: PPUSH
23266: CALL_OW 351
23270: PUSH
23271: LD_VAR 0 14
23275: PUSH
23276: LD_VAR 0 9
23280: ARRAY
23281: PUSH
23282: LD_INT 1
23284: ARRAY
23285: PPUSH
23286: LD_VAR 0 14
23290: PUSH
23291: LD_VAR 0 9
23295: ARRAY
23296: PUSH
23297: LD_INT 2
23299: ARRAY
23300: PPUSH
23301: CALL_OW 488
23305: NOT
23306: OR
23307: PUSH
23308: LD_VAR 0 13
23312: PPUSH
23313: CALL_OW 247
23317: PUSH
23318: LD_INT 3
23320: EQUAL
23321: OR
23322: IFFALSE 23328
// exit ;
23324: POP
23325: POP
23326: GO 23872
// if not tmp then
23328: LD_VAR 0 13
23332: NOT
23333: IFFALSE 23337
// continue ;
23335: GO 23193
// result := true ;
23337: LD_ADDR_VAR 0 8
23341: PUSH
23342: LD_INT 1
23344: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
23345: LD_VAR 0 6
23349: PUSH
23350: LD_VAR 0 13
23354: PPUSH
23355: CALL_OW 247
23359: PUSH
23360: LD_INT 2
23362: EQUAL
23363: AND
23364: PUSH
23365: LD_VAR 0 13
23369: PPUSH
23370: CALL_OW 263
23374: PUSH
23375: LD_INT 1
23377: EQUAL
23378: AND
23379: IFFALSE 23543
// begin if IsDrivenBy ( tmp ) then
23381: LD_VAR 0 13
23385: PPUSH
23386: CALL_OW 311
23390: IFFALSE 23394
// continue ;
23392: GO 23193
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
23394: LD_VAR 0 6
23398: PPUSH
23399: LD_INT 3
23401: PUSH
23402: LD_INT 60
23404: PUSH
23405: EMPTY
23406: LIST
23407: PUSH
23408: EMPTY
23409: LIST
23410: LIST
23411: PUSH
23412: LD_INT 3
23414: PUSH
23415: LD_INT 55
23417: PUSH
23418: EMPTY
23419: LIST
23420: PUSH
23421: EMPTY
23422: LIST
23423: LIST
23424: PUSH
23425: EMPTY
23426: LIST
23427: LIST
23428: PPUSH
23429: CALL_OW 72
23433: IFFALSE 23541
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
23435: LD_ADDR_VAR 0 18
23439: PUSH
23440: LD_VAR 0 6
23444: PPUSH
23445: LD_INT 3
23447: PUSH
23448: LD_INT 60
23450: PUSH
23451: EMPTY
23452: LIST
23453: PUSH
23454: EMPTY
23455: LIST
23456: LIST
23457: PUSH
23458: LD_INT 3
23460: PUSH
23461: LD_INT 55
23463: PUSH
23464: EMPTY
23465: LIST
23466: PUSH
23467: EMPTY
23468: LIST
23469: LIST
23470: PUSH
23471: EMPTY
23472: LIST
23473: LIST
23474: PPUSH
23475: CALL_OW 72
23479: PUSH
23480: LD_INT 1
23482: ARRAY
23483: ST_TO_ADDR
// if IsInUnit ( driver ) then
23484: LD_VAR 0 18
23488: PPUSH
23489: CALL_OW 310
23493: IFFALSE 23504
// ComExit ( driver ) ;
23495: LD_VAR 0 18
23499: PPUSH
23500: CALL 48793 0 1
// AddComEnterUnit ( driver , tmp ) ;
23504: LD_VAR 0 18
23508: PPUSH
23509: LD_VAR 0 13
23513: PPUSH
23514: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
23518: LD_VAR 0 18
23522: PPUSH
23523: LD_VAR 0 7
23527: PPUSH
23528: CALL_OW 173
// AddComExitVehicle ( driver ) ;
23532: LD_VAR 0 18
23536: PPUSH
23537: CALL_OW 181
// end ; continue ;
23541: GO 23193
// end ; if not cleaners or not tmp in cleaners then
23543: LD_VAR 0 6
23547: NOT
23548: PUSH
23549: LD_VAR 0 13
23553: PUSH
23554: LD_VAR 0 6
23558: IN
23559: NOT
23560: OR
23561: IFFALSE 23868
// begin if dep then
23563: LD_VAR 0 17
23567: IFFALSE 23703
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
23569: LD_ADDR_VAR 0 16
23573: PUSH
23574: LD_VAR 0 17
23578: PUSH
23579: LD_INT 1
23581: ARRAY
23582: PPUSH
23583: CALL_OW 250
23587: PPUSH
23588: LD_VAR 0 17
23592: PUSH
23593: LD_INT 1
23595: ARRAY
23596: PPUSH
23597: CALL_OW 254
23601: PPUSH
23602: LD_INT 5
23604: PPUSH
23605: CALL_OW 272
23609: PUSH
23610: LD_VAR 0 17
23614: PUSH
23615: LD_INT 1
23617: ARRAY
23618: PPUSH
23619: CALL_OW 251
23623: PPUSH
23624: LD_VAR 0 17
23628: PUSH
23629: LD_INT 1
23631: ARRAY
23632: PPUSH
23633: CALL_OW 254
23637: PPUSH
23638: LD_INT 5
23640: PPUSH
23641: CALL_OW 273
23645: PUSH
23646: EMPTY
23647: LIST
23648: LIST
23649: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
23650: LD_VAR 0 16
23654: PUSH
23655: LD_INT 1
23657: ARRAY
23658: PPUSH
23659: LD_VAR 0 16
23663: PUSH
23664: LD_INT 2
23666: ARRAY
23667: PPUSH
23668: CALL_OW 488
23672: IFFALSE 23703
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
23674: LD_VAR 0 13
23678: PPUSH
23679: LD_VAR 0 16
23683: PUSH
23684: LD_INT 1
23686: ARRAY
23687: PPUSH
23688: LD_VAR 0 16
23692: PUSH
23693: LD_INT 2
23695: ARRAY
23696: PPUSH
23697: CALL_OW 111
// continue ;
23701: GO 23193
// end ; end ; r := GetDir ( tmp ) ;
23703: LD_ADDR_VAR 0 15
23707: PUSH
23708: LD_VAR 0 13
23712: PPUSH
23713: CALL_OW 254
23717: ST_TO_ADDR
// if r = 5 then
23718: LD_VAR 0 15
23722: PUSH
23723: LD_INT 5
23725: EQUAL
23726: IFFALSE 23736
// r := 0 ;
23728: LD_ADDR_VAR 0 15
23732: PUSH
23733: LD_INT 0
23735: ST_TO_ADDR
// for j = r to 5 do
23736: LD_ADDR_VAR 0 10
23740: PUSH
23741: DOUBLE
23742: LD_VAR 0 15
23746: DEC
23747: ST_TO_ADDR
23748: LD_INT 5
23750: PUSH
23751: FOR_TO
23752: IFFALSE 23866
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
23754: LD_ADDR_VAR 0 11
23758: PUSH
23759: LD_VAR 0 13
23763: PPUSH
23764: CALL_OW 250
23768: PPUSH
23769: LD_VAR 0 10
23773: PPUSH
23774: LD_INT 2
23776: PPUSH
23777: CALL_OW 272
23781: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
23782: LD_ADDR_VAR 0 12
23786: PUSH
23787: LD_VAR 0 13
23791: PPUSH
23792: CALL_OW 251
23796: PPUSH
23797: LD_VAR 0 10
23801: PPUSH
23802: LD_INT 2
23804: PPUSH
23805: CALL_OW 273
23809: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
23810: LD_VAR 0 11
23814: PPUSH
23815: LD_VAR 0 12
23819: PPUSH
23820: CALL_OW 488
23824: PUSH
23825: LD_VAR 0 11
23829: PPUSH
23830: LD_VAR 0 12
23834: PPUSH
23835: CALL_OW 428
23839: NOT
23840: AND
23841: IFFALSE 23864
// begin ComMoveXY ( tmp , _x , _y ) ;
23843: LD_VAR 0 13
23847: PPUSH
23848: LD_VAR 0 11
23852: PPUSH
23853: LD_VAR 0 12
23857: PPUSH
23858: CALL_OW 111
// break ;
23862: GO 23866
// end ; end ;
23864: GO 23751
23866: POP
23867: POP
// end ; end ;
23868: GO 23193
23870: POP
23871: POP
// end ;
23872: LD_VAR 0 8
23876: RET
// export function BuildingTechInvented ( side , btype ) ; begin
23877: LD_INT 0
23879: PPUSH
// result := true ;
23880: LD_ADDR_VAR 0 3
23884: PUSH
23885: LD_INT 1
23887: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
23888: LD_VAR 0 2
23892: PUSH
23893: LD_INT 24
23895: DOUBLE
23896: EQUAL
23897: IFTRUE 23907
23899: LD_INT 33
23901: DOUBLE
23902: EQUAL
23903: IFTRUE 23907
23905: GO 23932
23907: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
23908: LD_ADDR_VAR 0 3
23912: PUSH
23913: LD_INT 32
23915: PPUSH
23916: LD_VAR 0 1
23920: PPUSH
23921: CALL_OW 321
23925: PUSH
23926: LD_INT 2
23928: EQUAL
23929: ST_TO_ADDR
23930: GO 24248
23932: LD_INT 20
23934: DOUBLE
23935: EQUAL
23936: IFTRUE 23940
23938: GO 23965
23940: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
23941: LD_ADDR_VAR 0 3
23945: PUSH
23946: LD_INT 6
23948: PPUSH
23949: LD_VAR 0 1
23953: PPUSH
23954: CALL_OW 321
23958: PUSH
23959: LD_INT 2
23961: EQUAL
23962: ST_TO_ADDR
23963: GO 24248
23965: LD_INT 22
23967: DOUBLE
23968: EQUAL
23969: IFTRUE 23979
23971: LD_INT 36
23973: DOUBLE
23974: EQUAL
23975: IFTRUE 23979
23977: GO 24004
23979: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
23980: LD_ADDR_VAR 0 3
23984: PUSH
23985: LD_INT 15
23987: PPUSH
23988: LD_VAR 0 1
23992: PPUSH
23993: CALL_OW 321
23997: PUSH
23998: LD_INT 2
24000: EQUAL
24001: ST_TO_ADDR
24002: GO 24248
24004: LD_INT 30
24006: DOUBLE
24007: EQUAL
24008: IFTRUE 24012
24010: GO 24037
24012: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
24013: LD_ADDR_VAR 0 3
24017: PUSH
24018: LD_INT 20
24020: PPUSH
24021: LD_VAR 0 1
24025: PPUSH
24026: CALL_OW 321
24030: PUSH
24031: LD_INT 2
24033: EQUAL
24034: ST_TO_ADDR
24035: GO 24248
24037: LD_INT 28
24039: DOUBLE
24040: EQUAL
24041: IFTRUE 24051
24043: LD_INT 21
24045: DOUBLE
24046: EQUAL
24047: IFTRUE 24051
24049: GO 24076
24051: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
24052: LD_ADDR_VAR 0 3
24056: PUSH
24057: LD_INT 21
24059: PPUSH
24060: LD_VAR 0 1
24064: PPUSH
24065: CALL_OW 321
24069: PUSH
24070: LD_INT 2
24072: EQUAL
24073: ST_TO_ADDR
24074: GO 24248
24076: LD_INT 16
24078: DOUBLE
24079: EQUAL
24080: IFTRUE 24084
24082: GO 24109
24084: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
24085: LD_ADDR_VAR 0 3
24089: PUSH
24090: LD_INT 84
24092: PPUSH
24093: LD_VAR 0 1
24097: PPUSH
24098: CALL_OW 321
24102: PUSH
24103: LD_INT 2
24105: EQUAL
24106: ST_TO_ADDR
24107: GO 24248
24109: LD_INT 19
24111: DOUBLE
24112: EQUAL
24113: IFTRUE 24123
24115: LD_INT 23
24117: DOUBLE
24118: EQUAL
24119: IFTRUE 24123
24121: GO 24148
24123: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
24124: LD_ADDR_VAR 0 3
24128: PUSH
24129: LD_INT 83
24131: PPUSH
24132: LD_VAR 0 1
24136: PPUSH
24137: CALL_OW 321
24141: PUSH
24142: LD_INT 2
24144: EQUAL
24145: ST_TO_ADDR
24146: GO 24248
24148: LD_INT 17
24150: DOUBLE
24151: EQUAL
24152: IFTRUE 24156
24154: GO 24181
24156: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
24157: LD_ADDR_VAR 0 3
24161: PUSH
24162: LD_INT 39
24164: PPUSH
24165: LD_VAR 0 1
24169: PPUSH
24170: CALL_OW 321
24174: PUSH
24175: LD_INT 2
24177: EQUAL
24178: ST_TO_ADDR
24179: GO 24248
24181: LD_INT 18
24183: DOUBLE
24184: EQUAL
24185: IFTRUE 24189
24187: GO 24214
24189: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
24190: LD_ADDR_VAR 0 3
24194: PUSH
24195: LD_INT 40
24197: PPUSH
24198: LD_VAR 0 1
24202: PPUSH
24203: CALL_OW 321
24207: PUSH
24208: LD_INT 2
24210: EQUAL
24211: ST_TO_ADDR
24212: GO 24248
24214: LD_INT 27
24216: DOUBLE
24217: EQUAL
24218: IFTRUE 24222
24220: GO 24247
24222: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
24223: LD_ADDR_VAR 0 3
24227: PUSH
24228: LD_INT 35
24230: PPUSH
24231: LD_VAR 0 1
24235: PPUSH
24236: CALL_OW 321
24240: PUSH
24241: LD_INT 2
24243: EQUAL
24244: ST_TO_ADDR
24245: GO 24248
24247: POP
// end ;
24248: LD_VAR 0 3
24252: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
24253: LD_INT 0
24255: PPUSH
24256: PPUSH
24257: PPUSH
24258: PPUSH
24259: PPUSH
24260: PPUSH
24261: PPUSH
24262: PPUSH
24263: PPUSH
24264: PPUSH
24265: PPUSH
// result := false ;
24266: LD_ADDR_VAR 0 6
24270: PUSH
24271: LD_INT 0
24273: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
24274: LD_VAR 0 1
24278: NOT
24279: PUSH
24280: LD_VAR 0 1
24284: PPUSH
24285: CALL_OW 266
24289: PUSH
24290: LD_INT 0
24292: PUSH
24293: LD_INT 1
24295: PUSH
24296: EMPTY
24297: LIST
24298: LIST
24299: IN
24300: NOT
24301: OR
24302: PUSH
24303: LD_VAR 0 2
24307: NOT
24308: OR
24309: PUSH
24310: LD_VAR 0 5
24314: PUSH
24315: LD_INT 0
24317: PUSH
24318: LD_INT 1
24320: PUSH
24321: LD_INT 2
24323: PUSH
24324: LD_INT 3
24326: PUSH
24327: LD_INT 4
24329: PUSH
24330: LD_INT 5
24332: PUSH
24333: EMPTY
24334: LIST
24335: LIST
24336: LIST
24337: LIST
24338: LIST
24339: LIST
24340: IN
24341: NOT
24342: OR
24343: PUSH
24344: LD_VAR 0 3
24348: PPUSH
24349: LD_VAR 0 4
24353: PPUSH
24354: CALL_OW 488
24358: NOT
24359: OR
24360: IFFALSE 24364
// exit ;
24362: GO 25100
// side := GetSide ( depot ) ;
24364: LD_ADDR_VAR 0 9
24368: PUSH
24369: LD_VAR 0 1
24373: PPUSH
24374: CALL_OW 255
24378: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
24379: LD_VAR 0 9
24383: PPUSH
24384: LD_VAR 0 2
24388: PPUSH
24389: CALL 23877 0 2
24393: NOT
24394: IFFALSE 24398
// exit ;
24396: GO 25100
// pom := GetBase ( depot ) ;
24398: LD_ADDR_VAR 0 10
24402: PUSH
24403: LD_VAR 0 1
24407: PPUSH
24408: CALL_OW 274
24412: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
24413: LD_ADDR_VAR 0 11
24417: PUSH
24418: LD_VAR 0 2
24422: PPUSH
24423: LD_VAR 0 1
24427: PPUSH
24428: CALL_OW 248
24432: PPUSH
24433: CALL_OW 450
24437: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
24438: LD_VAR 0 10
24442: PPUSH
24443: LD_INT 1
24445: PPUSH
24446: CALL_OW 275
24450: PUSH
24451: LD_VAR 0 11
24455: PUSH
24456: LD_INT 1
24458: ARRAY
24459: GREATEREQUAL
24460: PUSH
24461: LD_VAR 0 10
24465: PPUSH
24466: LD_INT 2
24468: PPUSH
24469: CALL_OW 275
24473: PUSH
24474: LD_VAR 0 11
24478: PUSH
24479: LD_INT 2
24481: ARRAY
24482: GREATEREQUAL
24483: AND
24484: PUSH
24485: LD_VAR 0 10
24489: PPUSH
24490: LD_INT 3
24492: PPUSH
24493: CALL_OW 275
24497: PUSH
24498: LD_VAR 0 11
24502: PUSH
24503: LD_INT 3
24505: ARRAY
24506: GREATEREQUAL
24507: AND
24508: NOT
24509: IFFALSE 24513
// exit ;
24511: GO 25100
// if GetBType ( depot ) = b_depot then
24513: LD_VAR 0 1
24517: PPUSH
24518: CALL_OW 266
24522: PUSH
24523: LD_INT 0
24525: EQUAL
24526: IFFALSE 24538
// dist := 28 else
24528: LD_ADDR_VAR 0 14
24532: PUSH
24533: LD_INT 28
24535: ST_TO_ADDR
24536: GO 24546
// dist := 36 ;
24538: LD_ADDR_VAR 0 14
24542: PUSH
24543: LD_INT 36
24545: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
24546: LD_VAR 0 1
24550: PPUSH
24551: LD_VAR 0 3
24555: PPUSH
24556: LD_VAR 0 4
24560: PPUSH
24561: CALL_OW 297
24565: PUSH
24566: LD_VAR 0 14
24570: GREATER
24571: IFFALSE 24575
// exit ;
24573: GO 25100
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
24575: LD_ADDR_VAR 0 12
24579: PUSH
24580: LD_VAR 0 2
24584: PPUSH
24585: LD_VAR 0 3
24589: PPUSH
24590: LD_VAR 0 4
24594: PPUSH
24595: LD_VAR 0 5
24599: PPUSH
24600: LD_VAR 0 1
24604: PPUSH
24605: CALL_OW 248
24609: PPUSH
24610: LD_INT 0
24612: PPUSH
24613: CALL 25105 0 6
24617: ST_TO_ADDR
// if not hexes then
24618: LD_VAR 0 12
24622: NOT
24623: IFFALSE 24627
// exit ;
24625: GO 25100
// hex := GetHexInfo ( x , y ) ;
24627: LD_ADDR_VAR 0 15
24631: PUSH
24632: LD_VAR 0 3
24636: PPUSH
24637: LD_VAR 0 4
24641: PPUSH
24642: CALL_OW 546
24646: ST_TO_ADDR
// if hex [ 1 ] then
24647: LD_VAR 0 15
24651: PUSH
24652: LD_INT 1
24654: ARRAY
24655: IFFALSE 24659
// exit ;
24657: GO 25100
// height := hex [ 2 ] ;
24659: LD_ADDR_VAR 0 13
24663: PUSH
24664: LD_VAR 0 15
24668: PUSH
24669: LD_INT 2
24671: ARRAY
24672: ST_TO_ADDR
// for i = 1 to hexes do
24673: LD_ADDR_VAR 0 7
24677: PUSH
24678: DOUBLE
24679: LD_INT 1
24681: DEC
24682: ST_TO_ADDR
24683: LD_VAR 0 12
24687: PUSH
24688: FOR_TO
24689: IFFALSE 25019
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
24691: LD_VAR 0 12
24695: PUSH
24696: LD_VAR 0 7
24700: ARRAY
24701: PUSH
24702: LD_INT 1
24704: ARRAY
24705: PPUSH
24706: LD_VAR 0 12
24710: PUSH
24711: LD_VAR 0 7
24715: ARRAY
24716: PUSH
24717: LD_INT 2
24719: ARRAY
24720: PPUSH
24721: CALL_OW 488
24725: NOT
24726: PUSH
24727: LD_VAR 0 12
24731: PUSH
24732: LD_VAR 0 7
24736: ARRAY
24737: PUSH
24738: LD_INT 1
24740: ARRAY
24741: PPUSH
24742: LD_VAR 0 12
24746: PUSH
24747: LD_VAR 0 7
24751: ARRAY
24752: PUSH
24753: LD_INT 2
24755: ARRAY
24756: PPUSH
24757: CALL_OW 428
24761: PUSH
24762: LD_INT 0
24764: GREATER
24765: OR
24766: PUSH
24767: LD_VAR 0 12
24771: PUSH
24772: LD_VAR 0 7
24776: ARRAY
24777: PUSH
24778: LD_INT 1
24780: ARRAY
24781: PPUSH
24782: LD_VAR 0 12
24786: PUSH
24787: LD_VAR 0 7
24791: ARRAY
24792: PUSH
24793: LD_INT 2
24795: ARRAY
24796: PPUSH
24797: CALL_OW 351
24801: OR
24802: IFFALSE 24808
// exit ;
24804: POP
24805: POP
24806: GO 25100
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
24808: LD_ADDR_VAR 0 8
24812: PUSH
24813: LD_VAR 0 12
24817: PUSH
24818: LD_VAR 0 7
24822: ARRAY
24823: PUSH
24824: LD_INT 1
24826: ARRAY
24827: PPUSH
24828: LD_VAR 0 12
24832: PUSH
24833: LD_VAR 0 7
24837: ARRAY
24838: PUSH
24839: LD_INT 2
24841: ARRAY
24842: PPUSH
24843: CALL_OW 546
24847: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
24848: LD_VAR 0 8
24852: PUSH
24853: LD_INT 1
24855: ARRAY
24856: PUSH
24857: LD_VAR 0 8
24861: PUSH
24862: LD_INT 2
24864: ARRAY
24865: PUSH
24866: LD_VAR 0 13
24870: PUSH
24871: LD_INT 2
24873: PLUS
24874: GREATER
24875: OR
24876: PUSH
24877: LD_VAR 0 8
24881: PUSH
24882: LD_INT 2
24884: ARRAY
24885: PUSH
24886: LD_VAR 0 13
24890: PUSH
24891: LD_INT 2
24893: MINUS
24894: LESS
24895: OR
24896: PUSH
24897: LD_VAR 0 8
24901: PUSH
24902: LD_INT 3
24904: ARRAY
24905: PUSH
24906: LD_INT 0
24908: PUSH
24909: LD_INT 8
24911: PUSH
24912: LD_INT 9
24914: PUSH
24915: LD_INT 10
24917: PUSH
24918: LD_INT 11
24920: PUSH
24921: LD_INT 12
24923: PUSH
24924: LD_INT 13
24926: PUSH
24927: LD_INT 16
24929: PUSH
24930: LD_INT 17
24932: PUSH
24933: LD_INT 18
24935: PUSH
24936: LD_INT 19
24938: PUSH
24939: LD_INT 20
24941: PUSH
24942: LD_INT 21
24944: PUSH
24945: EMPTY
24946: LIST
24947: LIST
24948: LIST
24949: LIST
24950: LIST
24951: LIST
24952: LIST
24953: LIST
24954: LIST
24955: LIST
24956: LIST
24957: LIST
24958: LIST
24959: IN
24960: NOT
24961: OR
24962: PUSH
24963: LD_VAR 0 8
24967: PUSH
24968: LD_INT 5
24970: ARRAY
24971: NOT
24972: OR
24973: PUSH
24974: LD_VAR 0 8
24978: PUSH
24979: LD_INT 6
24981: ARRAY
24982: PUSH
24983: LD_INT 1
24985: PUSH
24986: LD_INT 2
24988: PUSH
24989: LD_INT 7
24991: PUSH
24992: LD_INT 9
24994: PUSH
24995: LD_INT 10
24997: PUSH
24998: LD_INT 11
25000: PUSH
25001: EMPTY
25002: LIST
25003: LIST
25004: LIST
25005: LIST
25006: LIST
25007: LIST
25008: IN
25009: NOT
25010: OR
25011: IFFALSE 25017
// exit ;
25013: POP
25014: POP
25015: GO 25100
// end ;
25017: GO 24688
25019: POP
25020: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
25021: LD_VAR 0 9
25025: PPUSH
25026: LD_VAR 0 3
25030: PPUSH
25031: LD_VAR 0 4
25035: PPUSH
25036: LD_INT 20
25038: PPUSH
25039: CALL 17052 0 4
25043: PUSH
25044: LD_INT 4
25046: ARRAY
25047: IFFALSE 25051
// exit ;
25049: GO 25100
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
25051: LD_VAR 0 2
25055: PUSH
25056: LD_INT 29
25058: PUSH
25059: LD_INT 30
25061: PUSH
25062: EMPTY
25063: LIST
25064: LIST
25065: IN
25066: PUSH
25067: LD_VAR 0 3
25071: PPUSH
25072: LD_VAR 0 4
25076: PPUSH
25077: LD_VAR 0 9
25081: PPUSH
25082: CALL_OW 440
25086: NOT
25087: AND
25088: IFFALSE 25092
// exit ;
25090: GO 25100
// result := true ;
25092: LD_ADDR_VAR 0 6
25096: PUSH
25097: LD_INT 1
25099: ST_TO_ADDR
// end ;
25100: LD_VAR 0 6
25104: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
25105: LD_INT 0
25107: PPUSH
25108: PPUSH
25109: PPUSH
25110: PPUSH
25111: PPUSH
25112: PPUSH
25113: PPUSH
25114: PPUSH
25115: PPUSH
25116: PPUSH
25117: PPUSH
25118: PPUSH
25119: PPUSH
25120: PPUSH
25121: PPUSH
25122: PPUSH
25123: PPUSH
25124: PPUSH
25125: PPUSH
25126: PPUSH
25127: PPUSH
25128: PPUSH
25129: PPUSH
25130: PPUSH
25131: PPUSH
25132: PPUSH
25133: PPUSH
25134: PPUSH
25135: PPUSH
25136: PPUSH
25137: PPUSH
25138: PPUSH
25139: PPUSH
25140: PPUSH
25141: PPUSH
25142: PPUSH
25143: PPUSH
25144: PPUSH
25145: PPUSH
25146: PPUSH
25147: PPUSH
25148: PPUSH
25149: PPUSH
25150: PPUSH
25151: PPUSH
25152: PPUSH
25153: PPUSH
25154: PPUSH
25155: PPUSH
25156: PPUSH
25157: PPUSH
25158: PPUSH
25159: PPUSH
25160: PPUSH
25161: PPUSH
25162: PPUSH
25163: PPUSH
25164: PPUSH
// result = [ ] ;
25165: LD_ADDR_VAR 0 7
25169: PUSH
25170: EMPTY
25171: ST_TO_ADDR
// temp_list = [ ] ;
25172: LD_ADDR_VAR 0 9
25176: PUSH
25177: EMPTY
25178: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
25179: LD_VAR 0 4
25183: PUSH
25184: LD_INT 0
25186: PUSH
25187: LD_INT 1
25189: PUSH
25190: LD_INT 2
25192: PUSH
25193: LD_INT 3
25195: PUSH
25196: LD_INT 4
25198: PUSH
25199: LD_INT 5
25201: PUSH
25202: EMPTY
25203: LIST
25204: LIST
25205: LIST
25206: LIST
25207: LIST
25208: LIST
25209: IN
25210: NOT
25211: PUSH
25212: LD_VAR 0 1
25216: PUSH
25217: LD_INT 0
25219: PUSH
25220: LD_INT 1
25222: PUSH
25223: EMPTY
25224: LIST
25225: LIST
25226: IN
25227: PUSH
25228: LD_VAR 0 5
25232: PUSH
25233: LD_INT 1
25235: PUSH
25236: LD_INT 2
25238: PUSH
25239: LD_INT 3
25241: PUSH
25242: EMPTY
25243: LIST
25244: LIST
25245: LIST
25246: IN
25247: NOT
25248: AND
25249: OR
25250: IFFALSE 25254
// exit ;
25252: GO 43645
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
25254: LD_VAR 0 1
25258: PUSH
25259: LD_INT 6
25261: PUSH
25262: LD_INT 7
25264: PUSH
25265: LD_INT 8
25267: PUSH
25268: LD_INT 13
25270: PUSH
25271: LD_INT 12
25273: PUSH
25274: LD_INT 15
25276: PUSH
25277: LD_INT 11
25279: PUSH
25280: LD_INT 14
25282: PUSH
25283: LD_INT 10
25285: PUSH
25286: EMPTY
25287: LIST
25288: LIST
25289: LIST
25290: LIST
25291: LIST
25292: LIST
25293: LIST
25294: LIST
25295: LIST
25296: IN
25297: IFFALSE 25307
// btype = b_lab ;
25299: LD_ADDR_VAR 0 1
25303: PUSH
25304: LD_INT 6
25306: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
25307: LD_VAR 0 6
25311: PUSH
25312: LD_INT 0
25314: PUSH
25315: LD_INT 1
25317: PUSH
25318: LD_INT 2
25320: PUSH
25321: EMPTY
25322: LIST
25323: LIST
25324: LIST
25325: IN
25326: NOT
25327: PUSH
25328: LD_VAR 0 1
25332: PUSH
25333: LD_INT 0
25335: PUSH
25336: LD_INT 1
25338: PUSH
25339: LD_INT 2
25341: PUSH
25342: LD_INT 3
25344: PUSH
25345: LD_INT 6
25347: PUSH
25348: LD_INT 36
25350: PUSH
25351: LD_INT 4
25353: PUSH
25354: LD_INT 5
25356: PUSH
25357: LD_INT 31
25359: PUSH
25360: LD_INT 32
25362: PUSH
25363: LD_INT 33
25365: PUSH
25366: EMPTY
25367: LIST
25368: LIST
25369: LIST
25370: LIST
25371: LIST
25372: LIST
25373: LIST
25374: LIST
25375: LIST
25376: LIST
25377: LIST
25378: IN
25379: NOT
25380: PUSH
25381: LD_VAR 0 6
25385: PUSH
25386: LD_INT 1
25388: EQUAL
25389: AND
25390: OR
25391: PUSH
25392: LD_VAR 0 1
25396: PUSH
25397: LD_INT 2
25399: PUSH
25400: LD_INT 3
25402: PUSH
25403: EMPTY
25404: LIST
25405: LIST
25406: IN
25407: NOT
25408: PUSH
25409: LD_VAR 0 6
25413: PUSH
25414: LD_INT 2
25416: EQUAL
25417: AND
25418: OR
25419: IFFALSE 25429
// mode = 0 ;
25421: LD_ADDR_VAR 0 6
25425: PUSH
25426: LD_INT 0
25428: ST_TO_ADDR
// case mode of 0 :
25429: LD_VAR 0 6
25433: PUSH
25434: LD_INT 0
25436: DOUBLE
25437: EQUAL
25438: IFTRUE 25442
25440: GO 36895
25442: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
25443: LD_ADDR_VAR 0 11
25447: PUSH
25448: LD_INT 0
25450: PUSH
25451: LD_INT 0
25453: PUSH
25454: EMPTY
25455: LIST
25456: LIST
25457: PUSH
25458: LD_INT 0
25460: PUSH
25461: LD_INT 1
25463: NEG
25464: PUSH
25465: EMPTY
25466: LIST
25467: LIST
25468: PUSH
25469: LD_INT 1
25471: PUSH
25472: LD_INT 0
25474: PUSH
25475: EMPTY
25476: LIST
25477: LIST
25478: PUSH
25479: LD_INT 1
25481: PUSH
25482: LD_INT 1
25484: PUSH
25485: EMPTY
25486: LIST
25487: LIST
25488: PUSH
25489: LD_INT 0
25491: PUSH
25492: LD_INT 1
25494: PUSH
25495: EMPTY
25496: LIST
25497: LIST
25498: PUSH
25499: LD_INT 1
25501: NEG
25502: PUSH
25503: LD_INT 0
25505: PUSH
25506: EMPTY
25507: LIST
25508: LIST
25509: PUSH
25510: LD_INT 1
25512: NEG
25513: PUSH
25514: LD_INT 1
25516: NEG
25517: PUSH
25518: EMPTY
25519: LIST
25520: LIST
25521: PUSH
25522: LD_INT 1
25524: NEG
25525: PUSH
25526: LD_INT 2
25528: NEG
25529: PUSH
25530: EMPTY
25531: LIST
25532: LIST
25533: PUSH
25534: LD_INT 0
25536: PUSH
25537: LD_INT 2
25539: NEG
25540: PUSH
25541: EMPTY
25542: LIST
25543: LIST
25544: PUSH
25545: LD_INT 1
25547: PUSH
25548: LD_INT 1
25550: NEG
25551: PUSH
25552: EMPTY
25553: LIST
25554: LIST
25555: PUSH
25556: LD_INT 1
25558: PUSH
25559: LD_INT 2
25561: PUSH
25562: EMPTY
25563: LIST
25564: LIST
25565: PUSH
25566: LD_INT 0
25568: PUSH
25569: LD_INT 2
25571: PUSH
25572: EMPTY
25573: LIST
25574: LIST
25575: PUSH
25576: LD_INT 1
25578: NEG
25579: PUSH
25580: LD_INT 1
25582: PUSH
25583: EMPTY
25584: LIST
25585: LIST
25586: PUSH
25587: LD_INT 1
25589: PUSH
25590: LD_INT 3
25592: PUSH
25593: EMPTY
25594: LIST
25595: LIST
25596: PUSH
25597: LD_INT 0
25599: PUSH
25600: LD_INT 3
25602: PUSH
25603: EMPTY
25604: LIST
25605: LIST
25606: PUSH
25607: LD_INT 1
25609: NEG
25610: PUSH
25611: LD_INT 2
25613: PUSH
25614: EMPTY
25615: LIST
25616: LIST
25617: PUSH
25618: EMPTY
25619: LIST
25620: LIST
25621: LIST
25622: LIST
25623: LIST
25624: LIST
25625: LIST
25626: LIST
25627: LIST
25628: LIST
25629: LIST
25630: LIST
25631: LIST
25632: LIST
25633: LIST
25634: LIST
25635: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
25636: LD_ADDR_VAR 0 12
25640: PUSH
25641: LD_INT 0
25643: PUSH
25644: LD_INT 0
25646: PUSH
25647: EMPTY
25648: LIST
25649: LIST
25650: PUSH
25651: LD_INT 0
25653: PUSH
25654: LD_INT 1
25656: NEG
25657: PUSH
25658: EMPTY
25659: LIST
25660: LIST
25661: PUSH
25662: LD_INT 1
25664: PUSH
25665: LD_INT 0
25667: PUSH
25668: EMPTY
25669: LIST
25670: LIST
25671: PUSH
25672: LD_INT 1
25674: PUSH
25675: LD_INT 1
25677: PUSH
25678: EMPTY
25679: LIST
25680: LIST
25681: PUSH
25682: LD_INT 0
25684: PUSH
25685: LD_INT 1
25687: PUSH
25688: EMPTY
25689: LIST
25690: LIST
25691: PUSH
25692: LD_INT 1
25694: NEG
25695: PUSH
25696: LD_INT 0
25698: PUSH
25699: EMPTY
25700: LIST
25701: LIST
25702: PUSH
25703: LD_INT 1
25705: NEG
25706: PUSH
25707: LD_INT 1
25709: NEG
25710: PUSH
25711: EMPTY
25712: LIST
25713: LIST
25714: PUSH
25715: LD_INT 1
25717: PUSH
25718: LD_INT 1
25720: NEG
25721: PUSH
25722: EMPTY
25723: LIST
25724: LIST
25725: PUSH
25726: LD_INT 2
25728: PUSH
25729: LD_INT 0
25731: PUSH
25732: EMPTY
25733: LIST
25734: LIST
25735: PUSH
25736: LD_INT 2
25738: PUSH
25739: LD_INT 1
25741: PUSH
25742: EMPTY
25743: LIST
25744: LIST
25745: PUSH
25746: LD_INT 1
25748: NEG
25749: PUSH
25750: LD_INT 1
25752: PUSH
25753: EMPTY
25754: LIST
25755: LIST
25756: PUSH
25757: LD_INT 2
25759: NEG
25760: PUSH
25761: LD_INT 0
25763: PUSH
25764: EMPTY
25765: LIST
25766: LIST
25767: PUSH
25768: LD_INT 2
25770: NEG
25771: PUSH
25772: LD_INT 1
25774: NEG
25775: PUSH
25776: EMPTY
25777: LIST
25778: LIST
25779: PUSH
25780: LD_INT 2
25782: NEG
25783: PUSH
25784: LD_INT 1
25786: PUSH
25787: EMPTY
25788: LIST
25789: LIST
25790: PUSH
25791: LD_INT 3
25793: NEG
25794: PUSH
25795: LD_INT 0
25797: PUSH
25798: EMPTY
25799: LIST
25800: LIST
25801: PUSH
25802: LD_INT 3
25804: NEG
25805: PUSH
25806: LD_INT 1
25808: NEG
25809: PUSH
25810: EMPTY
25811: LIST
25812: LIST
25813: PUSH
25814: EMPTY
25815: LIST
25816: LIST
25817: LIST
25818: LIST
25819: LIST
25820: LIST
25821: LIST
25822: LIST
25823: LIST
25824: LIST
25825: LIST
25826: LIST
25827: LIST
25828: LIST
25829: LIST
25830: LIST
25831: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
25832: LD_ADDR_VAR 0 13
25836: PUSH
25837: LD_INT 0
25839: PUSH
25840: LD_INT 0
25842: PUSH
25843: EMPTY
25844: LIST
25845: LIST
25846: PUSH
25847: LD_INT 0
25849: PUSH
25850: LD_INT 1
25852: NEG
25853: PUSH
25854: EMPTY
25855: LIST
25856: LIST
25857: PUSH
25858: LD_INT 1
25860: PUSH
25861: LD_INT 0
25863: PUSH
25864: EMPTY
25865: LIST
25866: LIST
25867: PUSH
25868: LD_INT 1
25870: PUSH
25871: LD_INT 1
25873: PUSH
25874: EMPTY
25875: LIST
25876: LIST
25877: PUSH
25878: LD_INT 0
25880: PUSH
25881: LD_INT 1
25883: PUSH
25884: EMPTY
25885: LIST
25886: LIST
25887: PUSH
25888: LD_INT 1
25890: NEG
25891: PUSH
25892: LD_INT 0
25894: PUSH
25895: EMPTY
25896: LIST
25897: LIST
25898: PUSH
25899: LD_INT 1
25901: NEG
25902: PUSH
25903: LD_INT 1
25905: NEG
25906: PUSH
25907: EMPTY
25908: LIST
25909: LIST
25910: PUSH
25911: LD_INT 1
25913: NEG
25914: PUSH
25915: LD_INT 2
25917: NEG
25918: PUSH
25919: EMPTY
25920: LIST
25921: LIST
25922: PUSH
25923: LD_INT 2
25925: PUSH
25926: LD_INT 1
25928: PUSH
25929: EMPTY
25930: LIST
25931: LIST
25932: PUSH
25933: LD_INT 2
25935: PUSH
25936: LD_INT 2
25938: PUSH
25939: EMPTY
25940: LIST
25941: LIST
25942: PUSH
25943: LD_INT 1
25945: PUSH
25946: LD_INT 2
25948: PUSH
25949: EMPTY
25950: LIST
25951: LIST
25952: PUSH
25953: LD_INT 2
25955: NEG
25956: PUSH
25957: LD_INT 1
25959: NEG
25960: PUSH
25961: EMPTY
25962: LIST
25963: LIST
25964: PUSH
25965: LD_INT 2
25967: NEG
25968: PUSH
25969: LD_INT 2
25971: NEG
25972: PUSH
25973: EMPTY
25974: LIST
25975: LIST
25976: PUSH
25977: LD_INT 2
25979: NEG
25980: PUSH
25981: LD_INT 3
25983: NEG
25984: PUSH
25985: EMPTY
25986: LIST
25987: LIST
25988: PUSH
25989: LD_INT 3
25991: NEG
25992: PUSH
25993: LD_INT 2
25995: NEG
25996: PUSH
25997: EMPTY
25998: LIST
25999: LIST
26000: PUSH
26001: LD_INT 3
26003: NEG
26004: PUSH
26005: LD_INT 3
26007: NEG
26008: PUSH
26009: EMPTY
26010: LIST
26011: LIST
26012: PUSH
26013: EMPTY
26014: LIST
26015: LIST
26016: LIST
26017: LIST
26018: LIST
26019: LIST
26020: LIST
26021: LIST
26022: LIST
26023: LIST
26024: LIST
26025: LIST
26026: LIST
26027: LIST
26028: LIST
26029: LIST
26030: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
26031: LD_ADDR_VAR 0 14
26035: PUSH
26036: LD_INT 0
26038: PUSH
26039: LD_INT 0
26041: PUSH
26042: EMPTY
26043: LIST
26044: LIST
26045: PUSH
26046: LD_INT 0
26048: PUSH
26049: LD_INT 1
26051: NEG
26052: PUSH
26053: EMPTY
26054: LIST
26055: LIST
26056: PUSH
26057: LD_INT 1
26059: PUSH
26060: LD_INT 0
26062: PUSH
26063: EMPTY
26064: LIST
26065: LIST
26066: PUSH
26067: LD_INT 1
26069: PUSH
26070: LD_INT 1
26072: PUSH
26073: EMPTY
26074: LIST
26075: LIST
26076: PUSH
26077: LD_INT 0
26079: PUSH
26080: LD_INT 1
26082: PUSH
26083: EMPTY
26084: LIST
26085: LIST
26086: PUSH
26087: LD_INT 1
26089: NEG
26090: PUSH
26091: LD_INT 0
26093: PUSH
26094: EMPTY
26095: LIST
26096: LIST
26097: PUSH
26098: LD_INT 1
26100: NEG
26101: PUSH
26102: LD_INT 1
26104: NEG
26105: PUSH
26106: EMPTY
26107: LIST
26108: LIST
26109: PUSH
26110: LD_INT 1
26112: NEG
26113: PUSH
26114: LD_INT 2
26116: NEG
26117: PUSH
26118: EMPTY
26119: LIST
26120: LIST
26121: PUSH
26122: LD_INT 0
26124: PUSH
26125: LD_INT 2
26127: NEG
26128: PUSH
26129: EMPTY
26130: LIST
26131: LIST
26132: PUSH
26133: LD_INT 1
26135: PUSH
26136: LD_INT 1
26138: NEG
26139: PUSH
26140: EMPTY
26141: LIST
26142: LIST
26143: PUSH
26144: LD_INT 1
26146: PUSH
26147: LD_INT 2
26149: PUSH
26150: EMPTY
26151: LIST
26152: LIST
26153: PUSH
26154: LD_INT 0
26156: PUSH
26157: LD_INT 2
26159: PUSH
26160: EMPTY
26161: LIST
26162: LIST
26163: PUSH
26164: LD_INT 1
26166: NEG
26167: PUSH
26168: LD_INT 1
26170: PUSH
26171: EMPTY
26172: LIST
26173: LIST
26174: PUSH
26175: LD_INT 1
26177: NEG
26178: PUSH
26179: LD_INT 3
26181: NEG
26182: PUSH
26183: EMPTY
26184: LIST
26185: LIST
26186: PUSH
26187: LD_INT 0
26189: PUSH
26190: LD_INT 3
26192: NEG
26193: PUSH
26194: EMPTY
26195: LIST
26196: LIST
26197: PUSH
26198: LD_INT 1
26200: PUSH
26201: LD_INT 2
26203: NEG
26204: PUSH
26205: EMPTY
26206: LIST
26207: LIST
26208: PUSH
26209: EMPTY
26210: LIST
26211: LIST
26212: LIST
26213: LIST
26214: LIST
26215: LIST
26216: LIST
26217: LIST
26218: LIST
26219: LIST
26220: LIST
26221: LIST
26222: LIST
26223: LIST
26224: LIST
26225: LIST
26226: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
26227: LD_ADDR_VAR 0 15
26231: PUSH
26232: LD_INT 0
26234: PUSH
26235: LD_INT 0
26237: PUSH
26238: EMPTY
26239: LIST
26240: LIST
26241: PUSH
26242: LD_INT 0
26244: PUSH
26245: LD_INT 1
26247: NEG
26248: PUSH
26249: EMPTY
26250: LIST
26251: LIST
26252: PUSH
26253: LD_INT 1
26255: PUSH
26256: LD_INT 0
26258: PUSH
26259: EMPTY
26260: LIST
26261: LIST
26262: PUSH
26263: LD_INT 1
26265: PUSH
26266: LD_INT 1
26268: PUSH
26269: EMPTY
26270: LIST
26271: LIST
26272: PUSH
26273: LD_INT 0
26275: PUSH
26276: LD_INT 1
26278: PUSH
26279: EMPTY
26280: LIST
26281: LIST
26282: PUSH
26283: LD_INT 1
26285: NEG
26286: PUSH
26287: LD_INT 0
26289: PUSH
26290: EMPTY
26291: LIST
26292: LIST
26293: PUSH
26294: LD_INT 1
26296: NEG
26297: PUSH
26298: LD_INT 1
26300: NEG
26301: PUSH
26302: EMPTY
26303: LIST
26304: LIST
26305: PUSH
26306: LD_INT 1
26308: PUSH
26309: LD_INT 1
26311: NEG
26312: PUSH
26313: EMPTY
26314: LIST
26315: LIST
26316: PUSH
26317: LD_INT 2
26319: PUSH
26320: LD_INT 0
26322: PUSH
26323: EMPTY
26324: LIST
26325: LIST
26326: PUSH
26327: LD_INT 2
26329: PUSH
26330: LD_INT 1
26332: PUSH
26333: EMPTY
26334: LIST
26335: LIST
26336: PUSH
26337: LD_INT 1
26339: NEG
26340: PUSH
26341: LD_INT 1
26343: PUSH
26344: EMPTY
26345: LIST
26346: LIST
26347: PUSH
26348: LD_INT 2
26350: NEG
26351: PUSH
26352: LD_INT 0
26354: PUSH
26355: EMPTY
26356: LIST
26357: LIST
26358: PUSH
26359: LD_INT 2
26361: NEG
26362: PUSH
26363: LD_INT 1
26365: NEG
26366: PUSH
26367: EMPTY
26368: LIST
26369: LIST
26370: PUSH
26371: LD_INT 2
26373: PUSH
26374: LD_INT 1
26376: NEG
26377: PUSH
26378: EMPTY
26379: LIST
26380: LIST
26381: PUSH
26382: LD_INT 3
26384: PUSH
26385: LD_INT 0
26387: PUSH
26388: EMPTY
26389: LIST
26390: LIST
26391: PUSH
26392: LD_INT 3
26394: PUSH
26395: LD_INT 1
26397: PUSH
26398: EMPTY
26399: LIST
26400: LIST
26401: PUSH
26402: EMPTY
26403: LIST
26404: LIST
26405: LIST
26406: LIST
26407: LIST
26408: LIST
26409: LIST
26410: LIST
26411: LIST
26412: LIST
26413: LIST
26414: LIST
26415: LIST
26416: LIST
26417: LIST
26418: LIST
26419: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
26420: LD_ADDR_VAR 0 16
26424: PUSH
26425: LD_INT 0
26427: PUSH
26428: LD_INT 0
26430: PUSH
26431: EMPTY
26432: LIST
26433: LIST
26434: PUSH
26435: LD_INT 0
26437: PUSH
26438: LD_INT 1
26440: NEG
26441: PUSH
26442: EMPTY
26443: LIST
26444: LIST
26445: PUSH
26446: LD_INT 1
26448: PUSH
26449: LD_INT 0
26451: PUSH
26452: EMPTY
26453: LIST
26454: LIST
26455: PUSH
26456: LD_INT 1
26458: PUSH
26459: LD_INT 1
26461: PUSH
26462: EMPTY
26463: LIST
26464: LIST
26465: PUSH
26466: LD_INT 0
26468: PUSH
26469: LD_INT 1
26471: PUSH
26472: EMPTY
26473: LIST
26474: LIST
26475: PUSH
26476: LD_INT 1
26478: NEG
26479: PUSH
26480: LD_INT 0
26482: PUSH
26483: EMPTY
26484: LIST
26485: LIST
26486: PUSH
26487: LD_INT 1
26489: NEG
26490: PUSH
26491: LD_INT 1
26493: NEG
26494: PUSH
26495: EMPTY
26496: LIST
26497: LIST
26498: PUSH
26499: LD_INT 1
26501: NEG
26502: PUSH
26503: LD_INT 2
26505: NEG
26506: PUSH
26507: EMPTY
26508: LIST
26509: LIST
26510: PUSH
26511: LD_INT 2
26513: PUSH
26514: LD_INT 1
26516: PUSH
26517: EMPTY
26518: LIST
26519: LIST
26520: PUSH
26521: LD_INT 2
26523: PUSH
26524: LD_INT 2
26526: PUSH
26527: EMPTY
26528: LIST
26529: LIST
26530: PUSH
26531: LD_INT 1
26533: PUSH
26534: LD_INT 2
26536: PUSH
26537: EMPTY
26538: LIST
26539: LIST
26540: PUSH
26541: LD_INT 2
26543: NEG
26544: PUSH
26545: LD_INT 1
26547: NEG
26548: PUSH
26549: EMPTY
26550: LIST
26551: LIST
26552: PUSH
26553: LD_INT 2
26555: NEG
26556: PUSH
26557: LD_INT 2
26559: NEG
26560: PUSH
26561: EMPTY
26562: LIST
26563: LIST
26564: PUSH
26565: LD_INT 3
26567: PUSH
26568: LD_INT 2
26570: PUSH
26571: EMPTY
26572: LIST
26573: LIST
26574: PUSH
26575: LD_INT 3
26577: PUSH
26578: LD_INT 3
26580: PUSH
26581: EMPTY
26582: LIST
26583: LIST
26584: PUSH
26585: LD_INT 2
26587: PUSH
26588: LD_INT 3
26590: PUSH
26591: EMPTY
26592: LIST
26593: LIST
26594: PUSH
26595: EMPTY
26596: LIST
26597: LIST
26598: LIST
26599: LIST
26600: LIST
26601: LIST
26602: LIST
26603: LIST
26604: LIST
26605: LIST
26606: LIST
26607: LIST
26608: LIST
26609: LIST
26610: LIST
26611: LIST
26612: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26613: LD_ADDR_VAR 0 17
26617: PUSH
26618: LD_INT 0
26620: PUSH
26621: LD_INT 0
26623: PUSH
26624: EMPTY
26625: LIST
26626: LIST
26627: PUSH
26628: LD_INT 0
26630: PUSH
26631: LD_INT 1
26633: NEG
26634: PUSH
26635: EMPTY
26636: LIST
26637: LIST
26638: PUSH
26639: LD_INT 1
26641: PUSH
26642: LD_INT 0
26644: PUSH
26645: EMPTY
26646: LIST
26647: LIST
26648: PUSH
26649: LD_INT 1
26651: PUSH
26652: LD_INT 1
26654: PUSH
26655: EMPTY
26656: LIST
26657: LIST
26658: PUSH
26659: LD_INT 0
26661: PUSH
26662: LD_INT 1
26664: PUSH
26665: EMPTY
26666: LIST
26667: LIST
26668: PUSH
26669: LD_INT 1
26671: NEG
26672: PUSH
26673: LD_INT 0
26675: PUSH
26676: EMPTY
26677: LIST
26678: LIST
26679: PUSH
26680: LD_INT 1
26682: NEG
26683: PUSH
26684: LD_INT 1
26686: NEG
26687: PUSH
26688: EMPTY
26689: LIST
26690: LIST
26691: PUSH
26692: LD_INT 1
26694: NEG
26695: PUSH
26696: LD_INT 2
26698: NEG
26699: PUSH
26700: EMPTY
26701: LIST
26702: LIST
26703: PUSH
26704: LD_INT 0
26706: PUSH
26707: LD_INT 2
26709: NEG
26710: PUSH
26711: EMPTY
26712: LIST
26713: LIST
26714: PUSH
26715: LD_INT 1
26717: PUSH
26718: LD_INT 1
26720: NEG
26721: PUSH
26722: EMPTY
26723: LIST
26724: LIST
26725: PUSH
26726: LD_INT 2
26728: PUSH
26729: LD_INT 0
26731: PUSH
26732: EMPTY
26733: LIST
26734: LIST
26735: PUSH
26736: LD_INT 2
26738: PUSH
26739: LD_INT 1
26741: PUSH
26742: EMPTY
26743: LIST
26744: LIST
26745: PUSH
26746: LD_INT 2
26748: PUSH
26749: LD_INT 2
26751: PUSH
26752: EMPTY
26753: LIST
26754: LIST
26755: PUSH
26756: LD_INT 1
26758: PUSH
26759: LD_INT 2
26761: PUSH
26762: EMPTY
26763: LIST
26764: LIST
26765: PUSH
26766: LD_INT 0
26768: PUSH
26769: LD_INT 2
26771: PUSH
26772: EMPTY
26773: LIST
26774: LIST
26775: PUSH
26776: LD_INT 1
26778: NEG
26779: PUSH
26780: LD_INT 1
26782: PUSH
26783: EMPTY
26784: LIST
26785: LIST
26786: PUSH
26787: LD_INT 2
26789: NEG
26790: PUSH
26791: LD_INT 0
26793: PUSH
26794: EMPTY
26795: LIST
26796: LIST
26797: PUSH
26798: LD_INT 2
26800: NEG
26801: PUSH
26802: LD_INT 1
26804: NEG
26805: PUSH
26806: EMPTY
26807: LIST
26808: LIST
26809: PUSH
26810: LD_INT 2
26812: NEG
26813: PUSH
26814: LD_INT 2
26816: NEG
26817: PUSH
26818: EMPTY
26819: LIST
26820: LIST
26821: PUSH
26822: EMPTY
26823: LIST
26824: LIST
26825: LIST
26826: LIST
26827: LIST
26828: LIST
26829: LIST
26830: LIST
26831: LIST
26832: LIST
26833: LIST
26834: LIST
26835: LIST
26836: LIST
26837: LIST
26838: LIST
26839: LIST
26840: LIST
26841: LIST
26842: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26843: LD_ADDR_VAR 0 18
26847: PUSH
26848: LD_INT 0
26850: PUSH
26851: LD_INT 0
26853: PUSH
26854: EMPTY
26855: LIST
26856: LIST
26857: PUSH
26858: LD_INT 0
26860: PUSH
26861: LD_INT 1
26863: NEG
26864: PUSH
26865: EMPTY
26866: LIST
26867: LIST
26868: PUSH
26869: LD_INT 1
26871: PUSH
26872: LD_INT 0
26874: PUSH
26875: EMPTY
26876: LIST
26877: LIST
26878: PUSH
26879: LD_INT 1
26881: PUSH
26882: LD_INT 1
26884: PUSH
26885: EMPTY
26886: LIST
26887: LIST
26888: PUSH
26889: LD_INT 0
26891: PUSH
26892: LD_INT 1
26894: PUSH
26895: EMPTY
26896: LIST
26897: LIST
26898: PUSH
26899: LD_INT 1
26901: NEG
26902: PUSH
26903: LD_INT 0
26905: PUSH
26906: EMPTY
26907: LIST
26908: LIST
26909: PUSH
26910: LD_INT 1
26912: NEG
26913: PUSH
26914: LD_INT 1
26916: NEG
26917: PUSH
26918: EMPTY
26919: LIST
26920: LIST
26921: PUSH
26922: LD_INT 1
26924: NEG
26925: PUSH
26926: LD_INT 2
26928: NEG
26929: PUSH
26930: EMPTY
26931: LIST
26932: LIST
26933: PUSH
26934: LD_INT 0
26936: PUSH
26937: LD_INT 2
26939: NEG
26940: PUSH
26941: EMPTY
26942: LIST
26943: LIST
26944: PUSH
26945: LD_INT 1
26947: PUSH
26948: LD_INT 1
26950: NEG
26951: PUSH
26952: EMPTY
26953: LIST
26954: LIST
26955: PUSH
26956: LD_INT 2
26958: PUSH
26959: LD_INT 0
26961: PUSH
26962: EMPTY
26963: LIST
26964: LIST
26965: PUSH
26966: LD_INT 2
26968: PUSH
26969: LD_INT 1
26971: PUSH
26972: EMPTY
26973: LIST
26974: LIST
26975: PUSH
26976: LD_INT 2
26978: PUSH
26979: LD_INT 2
26981: PUSH
26982: EMPTY
26983: LIST
26984: LIST
26985: PUSH
26986: LD_INT 1
26988: PUSH
26989: LD_INT 2
26991: PUSH
26992: EMPTY
26993: LIST
26994: LIST
26995: PUSH
26996: LD_INT 0
26998: PUSH
26999: LD_INT 2
27001: PUSH
27002: EMPTY
27003: LIST
27004: LIST
27005: PUSH
27006: LD_INT 1
27008: NEG
27009: PUSH
27010: LD_INT 1
27012: PUSH
27013: EMPTY
27014: LIST
27015: LIST
27016: PUSH
27017: LD_INT 2
27019: NEG
27020: PUSH
27021: LD_INT 0
27023: PUSH
27024: EMPTY
27025: LIST
27026: LIST
27027: PUSH
27028: LD_INT 2
27030: NEG
27031: PUSH
27032: LD_INT 1
27034: NEG
27035: PUSH
27036: EMPTY
27037: LIST
27038: LIST
27039: PUSH
27040: LD_INT 2
27042: NEG
27043: PUSH
27044: LD_INT 2
27046: NEG
27047: PUSH
27048: EMPTY
27049: LIST
27050: LIST
27051: PUSH
27052: EMPTY
27053: LIST
27054: LIST
27055: LIST
27056: LIST
27057: LIST
27058: LIST
27059: LIST
27060: LIST
27061: LIST
27062: LIST
27063: LIST
27064: LIST
27065: LIST
27066: LIST
27067: LIST
27068: LIST
27069: LIST
27070: LIST
27071: LIST
27072: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27073: LD_ADDR_VAR 0 19
27077: PUSH
27078: LD_INT 0
27080: PUSH
27081: LD_INT 0
27083: PUSH
27084: EMPTY
27085: LIST
27086: LIST
27087: PUSH
27088: LD_INT 0
27090: PUSH
27091: LD_INT 1
27093: NEG
27094: PUSH
27095: EMPTY
27096: LIST
27097: LIST
27098: PUSH
27099: LD_INT 1
27101: PUSH
27102: LD_INT 0
27104: PUSH
27105: EMPTY
27106: LIST
27107: LIST
27108: PUSH
27109: LD_INT 1
27111: PUSH
27112: LD_INT 1
27114: PUSH
27115: EMPTY
27116: LIST
27117: LIST
27118: PUSH
27119: LD_INT 0
27121: PUSH
27122: LD_INT 1
27124: PUSH
27125: EMPTY
27126: LIST
27127: LIST
27128: PUSH
27129: LD_INT 1
27131: NEG
27132: PUSH
27133: LD_INT 0
27135: PUSH
27136: EMPTY
27137: LIST
27138: LIST
27139: PUSH
27140: LD_INT 1
27142: NEG
27143: PUSH
27144: LD_INT 1
27146: NEG
27147: PUSH
27148: EMPTY
27149: LIST
27150: LIST
27151: PUSH
27152: LD_INT 1
27154: NEG
27155: PUSH
27156: LD_INT 2
27158: NEG
27159: PUSH
27160: EMPTY
27161: LIST
27162: LIST
27163: PUSH
27164: LD_INT 0
27166: PUSH
27167: LD_INT 2
27169: NEG
27170: PUSH
27171: EMPTY
27172: LIST
27173: LIST
27174: PUSH
27175: LD_INT 1
27177: PUSH
27178: LD_INT 1
27180: NEG
27181: PUSH
27182: EMPTY
27183: LIST
27184: LIST
27185: PUSH
27186: LD_INT 2
27188: PUSH
27189: LD_INT 0
27191: PUSH
27192: EMPTY
27193: LIST
27194: LIST
27195: PUSH
27196: LD_INT 2
27198: PUSH
27199: LD_INT 1
27201: PUSH
27202: EMPTY
27203: LIST
27204: LIST
27205: PUSH
27206: LD_INT 2
27208: PUSH
27209: LD_INT 2
27211: PUSH
27212: EMPTY
27213: LIST
27214: LIST
27215: PUSH
27216: LD_INT 1
27218: PUSH
27219: LD_INT 2
27221: PUSH
27222: EMPTY
27223: LIST
27224: LIST
27225: PUSH
27226: LD_INT 0
27228: PUSH
27229: LD_INT 2
27231: PUSH
27232: EMPTY
27233: LIST
27234: LIST
27235: PUSH
27236: LD_INT 1
27238: NEG
27239: PUSH
27240: LD_INT 1
27242: PUSH
27243: EMPTY
27244: LIST
27245: LIST
27246: PUSH
27247: LD_INT 2
27249: NEG
27250: PUSH
27251: LD_INT 0
27253: PUSH
27254: EMPTY
27255: LIST
27256: LIST
27257: PUSH
27258: LD_INT 2
27260: NEG
27261: PUSH
27262: LD_INT 1
27264: NEG
27265: PUSH
27266: EMPTY
27267: LIST
27268: LIST
27269: PUSH
27270: LD_INT 2
27272: NEG
27273: PUSH
27274: LD_INT 2
27276: NEG
27277: PUSH
27278: EMPTY
27279: LIST
27280: LIST
27281: PUSH
27282: EMPTY
27283: LIST
27284: LIST
27285: LIST
27286: LIST
27287: LIST
27288: LIST
27289: LIST
27290: LIST
27291: LIST
27292: LIST
27293: LIST
27294: LIST
27295: LIST
27296: LIST
27297: LIST
27298: LIST
27299: LIST
27300: LIST
27301: LIST
27302: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27303: LD_ADDR_VAR 0 20
27307: PUSH
27308: LD_INT 0
27310: PUSH
27311: LD_INT 0
27313: PUSH
27314: EMPTY
27315: LIST
27316: LIST
27317: PUSH
27318: LD_INT 0
27320: PUSH
27321: LD_INT 1
27323: NEG
27324: PUSH
27325: EMPTY
27326: LIST
27327: LIST
27328: PUSH
27329: LD_INT 1
27331: PUSH
27332: LD_INT 0
27334: PUSH
27335: EMPTY
27336: LIST
27337: LIST
27338: PUSH
27339: LD_INT 1
27341: PUSH
27342: LD_INT 1
27344: PUSH
27345: EMPTY
27346: LIST
27347: LIST
27348: PUSH
27349: LD_INT 0
27351: PUSH
27352: LD_INT 1
27354: PUSH
27355: EMPTY
27356: LIST
27357: LIST
27358: PUSH
27359: LD_INT 1
27361: NEG
27362: PUSH
27363: LD_INT 0
27365: PUSH
27366: EMPTY
27367: LIST
27368: LIST
27369: PUSH
27370: LD_INT 1
27372: NEG
27373: PUSH
27374: LD_INT 1
27376: NEG
27377: PUSH
27378: EMPTY
27379: LIST
27380: LIST
27381: PUSH
27382: LD_INT 1
27384: NEG
27385: PUSH
27386: LD_INT 2
27388: NEG
27389: PUSH
27390: EMPTY
27391: LIST
27392: LIST
27393: PUSH
27394: LD_INT 0
27396: PUSH
27397: LD_INT 2
27399: NEG
27400: PUSH
27401: EMPTY
27402: LIST
27403: LIST
27404: PUSH
27405: LD_INT 1
27407: PUSH
27408: LD_INT 1
27410: NEG
27411: PUSH
27412: EMPTY
27413: LIST
27414: LIST
27415: PUSH
27416: LD_INT 2
27418: PUSH
27419: LD_INT 0
27421: PUSH
27422: EMPTY
27423: LIST
27424: LIST
27425: PUSH
27426: LD_INT 2
27428: PUSH
27429: LD_INT 1
27431: PUSH
27432: EMPTY
27433: LIST
27434: LIST
27435: PUSH
27436: LD_INT 2
27438: PUSH
27439: LD_INT 2
27441: PUSH
27442: EMPTY
27443: LIST
27444: LIST
27445: PUSH
27446: LD_INT 1
27448: PUSH
27449: LD_INT 2
27451: PUSH
27452: EMPTY
27453: LIST
27454: LIST
27455: PUSH
27456: LD_INT 0
27458: PUSH
27459: LD_INT 2
27461: PUSH
27462: EMPTY
27463: LIST
27464: LIST
27465: PUSH
27466: LD_INT 1
27468: NEG
27469: PUSH
27470: LD_INT 1
27472: PUSH
27473: EMPTY
27474: LIST
27475: LIST
27476: PUSH
27477: LD_INT 2
27479: NEG
27480: PUSH
27481: LD_INT 0
27483: PUSH
27484: EMPTY
27485: LIST
27486: LIST
27487: PUSH
27488: LD_INT 2
27490: NEG
27491: PUSH
27492: LD_INT 1
27494: NEG
27495: PUSH
27496: EMPTY
27497: LIST
27498: LIST
27499: PUSH
27500: LD_INT 2
27502: NEG
27503: PUSH
27504: LD_INT 2
27506: NEG
27507: PUSH
27508: EMPTY
27509: LIST
27510: LIST
27511: PUSH
27512: EMPTY
27513: LIST
27514: LIST
27515: LIST
27516: LIST
27517: LIST
27518: LIST
27519: LIST
27520: LIST
27521: LIST
27522: LIST
27523: LIST
27524: LIST
27525: LIST
27526: LIST
27527: LIST
27528: LIST
27529: LIST
27530: LIST
27531: LIST
27532: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27533: LD_ADDR_VAR 0 21
27537: PUSH
27538: LD_INT 0
27540: PUSH
27541: LD_INT 0
27543: PUSH
27544: EMPTY
27545: LIST
27546: LIST
27547: PUSH
27548: LD_INT 0
27550: PUSH
27551: LD_INT 1
27553: NEG
27554: PUSH
27555: EMPTY
27556: LIST
27557: LIST
27558: PUSH
27559: LD_INT 1
27561: PUSH
27562: LD_INT 0
27564: PUSH
27565: EMPTY
27566: LIST
27567: LIST
27568: PUSH
27569: LD_INT 1
27571: PUSH
27572: LD_INT 1
27574: PUSH
27575: EMPTY
27576: LIST
27577: LIST
27578: PUSH
27579: LD_INT 0
27581: PUSH
27582: LD_INT 1
27584: PUSH
27585: EMPTY
27586: LIST
27587: LIST
27588: PUSH
27589: LD_INT 1
27591: NEG
27592: PUSH
27593: LD_INT 0
27595: PUSH
27596: EMPTY
27597: LIST
27598: LIST
27599: PUSH
27600: LD_INT 1
27602: NEG
27603: PUSH
27604: LD_INT 1
27606: NEG
27607: PUSH
27608: EMPTY
27609: LIST
27610: LIST
27611: PUSH
27612: LD_INT 1
27614: NEG
27615: PUSH
27616: LD_INT 2
27618: NEG
27619: PUSH
27620: EMPTY
27621: LIST
27622: LIST
27623: PUSH
27624: LD_INT 0
27626: PUSH
27627: LD_INT 2
27629: NEG
27630: PUSH
27631: EMPTY
27632: LIST
27633: LIST
27634: PUSH
27635: LD_INT 1
27637: PUSH
27638: LD_INT 1
27640: NEG
27641: PUSH
27642: EMPTY
27643: LIST
27644: LIST
27645: PUSH
27646: LD_INT 2
27648: PUSH
27649: LD_INT 0
27651: PUSH
27652: EMPTY
27653: LIST
27654: LIST
27655: PUSH
27656: LD_INT 2
27658: PUSH
27659: LD_INT 1
27661: PUSH
27662: EMPTY
27663: LIST
27664: LIST
27665: PUSH
27666: LD_INT 2
27668: PUSH
27669: LD_INT 2
27671: PUSH
27672: EMPTY
27673: LIST
27674: LIST
27675: PUSH
27676: LD_INT 1
27678: PUSH
27679: LD_INT 2
27681: PUSH
27682: EMPTY
27683: LIST
27684: LIST
27685: PUSH
27686: LD_INT 0
27688: PUSH
27689: LD_INT 2
27691: PUSH
27692: EMPTY
27693: LIST
27694: LIST
27695: PUSH
27696: LD_INT 1
27698: NEG
27699: PUSH
27700: LD_INT 1
27702: PUSH
27703: EMPTY
27704: LIST
27705: LIST
27706: PUSH
27707: LD_INT 2
27709: NEG
27710: PUSH
27711: LD_INT 0
27713: PUSH
27714: EMPTY
27715: LIST
27716: LIST
27717: PUSH
27718: LD_INT 2
27720: NEG
27721: PUSH
27722: LD_INT 1
27724: NEG
27725: PUSH
27726: EMPTY
27727: LIST
27728: LIST
27729: PUSH
27730: LD_INT 2
27732: NEG
27733: PUSH
27734: LD_INT 2
27736: NEG
27737: PUSH
27738: EMPTY
27739: LIST
27740: LIST
27741: PUSH
27742: EMPTY
27743: LIST
27744: LIST
27745: LIST
27746: LIST
27747: LIST
27748: LIST
27749: LIST
27750: LIST
27751: LIST
27752: LIST
27753: LIST
27754: LIST
27755: LIST
27756: LIST
27757: LIST
27758: LIST
27759: LIST
27760: LIST
27761: LIST
27762: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27763: LD_ADDR_VAR 0 22
27767: PUSH
27768: LD_INT 0
27770: PUSH
27771: LD_INT 0
27773: PUSH
27774: EMPTY
27775: LIST
27776: LIST
27777: PUSH
27778: LD_INT 0
27780: PUSH
27781: LD_INT 1
27783: NEG
27784: PUSH
27785: EMPTY
27786: LIST
27787: LIST
27788: PUSH
27789: LD_INT 1
27791: PUSH
27792: LD_INT 0
27794: PUSH
27795: EMPTY
27796: LIST
27797: LIST
27798: PUSH
27799: LD_INT 1
27801: PUSH
27802: LD_INT 1
27804: PUSH
27805: EMPTY
27806: LIST
27807: LIST
27808: PUSH
27809: LD_INT 0
27811: PUSH
27812: LD_INT 1
27814: PUSH
27815: EMPTY
27816: LIST
27817: LIST
27818: PUSH
27819: LD_INT 1
27821: NEG
27822: PUSH
27823: LD_INT 0
27825: PUSH
27826: EMPTY
27827: LIST
27828: LIST
27829: PUSH
27830: LD_INT 1
27832: NEG
27833: PUSH
27834: LD_INT 1
27836: NEG
27837: PUSH
27838: EMPTY
27839: LIST
27840: LIST
27841: PUSH
27842: LD_INT 1
27844: NEG
27845: PUSH
27846: LD_INT 2
27848: NEG
27849: PUSH
27850: EMPTY
27851: LIST
27852: LIST
27853: PUSH
27854: LD_INT 0
27856: PUSH
27857: LD_INT 2
27859: NEG
27860: PUSH
27861: EMPTY
27862: LIST
27863: LIST
27864: PUSH
27865: LD_INT 1
27867: PUSH
27868: LD_INT 1
27870: NEG
27871: PUSH
27872: EMPTY
27873: LIST
27874: LIST
27875: PUSH
27876: LD_INT 2
27878: PUSH
27879: LD_INT 0
27881: PUSH
27882: EMPTY
27883: LIST
27884: LIST
27885: PUSH
27886: LD_INT 2
27888: PUSH
27889: LD_INT 1
27891: PUSH
27892: EMPTY
27893: LIST
27894: LIST
27895: PUSH
27896: LD_INT 2
27898: PUSH
27899: LD_INT 2
27901: PUSH
27902: EMPTY
27903: LIST
27904: LIST
27905: PUSH
27906: LD_INT 1
27908: PUSH
27909: LD_INT 2
27911: PUSH
27912: EMPTY
27913: LIST
27914: LIST
27915: PUSH
27916: LD_INT 0
27918: PUSH
27919: LD_INT 2
27921: PUSH
27922: EMPTY
27923: LIST
27924: LIST
27925: PUSH
27926: LD_INT 1
27928: NEG
27929: PUSH
27930: LD_INT 1
27932: PUSH
27933: EMPTY
27934: LIST
27935: LIST
27936: PUSH
27937: LD_INT 2
27939: NEG
27940: PUSH
27941: LD_INT 0
27943: PUSH
27944: EMPTY
27945: LIST
27946: LIST
27947: PUSH
27948: LD_INT 2
27950: NEG
27951: PUSH
27952: LD_INT 1
27954: NEG
27955: PUSH
27956: EMPTY
27957: LIST
27958: LIST
27959: PUSH
27960: LD_INT 2
27962: NEG
27963: PUSH
27964: LD_INT 2
27966: NEG
27967: PUSH
27968: EMPTY
27969: LIST
27970: LIST
27971: PUSH
27972: EMPTY
27973: LIST
27974: LIST
27975: LIST
27976: LIST
27977: LIST
27978: LIST
27979: LIST
27980: LIST
27981: LIST
27982: LIST
27983: LIST
27984: LIST
27985: LIST
27986: LIST
27987: LIST
27988: LIST
27989: LIST
27990: LIST
27991: LIST
27992: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
27993: LD_ADDR_VAR 0 23
27997: PUSH
27998: LD_INT 0
28000: PUSH
28001: LD_INT 0
28003: PUSH
28004: EMPTY
28005: LIST
28006: LIST
28007: PUSH
28008: LD_INT 0
28010: PUSH
28011: LD_INT 1
28013: NEG
28014: PUSH
28015: EMPTY
28016: LIST
28017: LIST
28018: PUSH
28019: LD_INT 1
28021: PUSH
28022: LD_INT 0
28024: PUSH
28025: EMPTY
28026: LIST
28027: LIST
28028: PUSH
28029: LD_INT 1
28031: PUSH
28032: LD_INT 1
28034: PUSH
28035: EMPTY
28036: LIST
28037: LIST
28038: PUSH
28039: LD_INT 0
28041: PUSH
28042: LD_INT 1
28044: PUSH
28045: EMPTY
28046: LIST
28047: LIST
28048: PUSH
28049: LD_INT 1
28051: NEG
28052: PUSH
28053: LD_INT 0
28055: PUSH
28056: EMPTY
28057: LIST
28058: LIST
28059: PUSH
28060: LD_INT 1
28062: NEG
28063: PUSH
28064: LD_INT 1
28066: NEG
28067: PUSH
28068: EMPTY
28069: LIST
28070: LIST
28071: PUSH
28072: LD_INT 1
28074: NEG
28075: PUSH
28076: LD_INT 2
28078: NEG
28079: PUSH
28080: EMPTY
28081: LIST
28082: LIST
28083: PUSH
28084: LD_INT 0
28086: PUSH
28087: LD_INT 2
28089: NEG
28090: PUSH
28091: EMPTY
28092: LIST
28093: LIST
28094: PUSH
28095: LD_INT 1
28097: PUSH
28098: LD_INT 1
28100: NEG
28101: PUSH
28102: EMPTY
28103: LIST
28104: LIST
28105: PUSH
28106: LD_INT 2
28108: PUSH
28109: LD_INT 0
28111: PUSH
28112: EMPTY
28113: LIST
28114: LIST
28115: PUSH
28116: LD_INT 2
28118: PUSH
28119: LD_INT 1
28121: PUSH
28122: EMPTY
28123: LIST
28124: LIST
28125: PUSH
28126: LD_INT 2
28128: PUSH
28129: LD_INT 2
28131: PUSH
28132: EMPTY
28133: LIST
28134: LIST
28135: PUSH
28136: LD_INT 1
28138: PUSH
28139: LD_INT 2
28141: PUSH
28142: EMPTY
28143: LIST
28144: LIST
28145: PUSH
28146: LD_INT 0
28148: PUSH
28149: LD_INT 2
28151: PUSH
28152: EMPTY
28153: LIST
28154: LIST
28155: PUSH
28156: LD_INT 1
28158: NEG
28159: PUSH
28160: LD_INT 1
28162: PUSH
28163: EMPTY
28164: LIST
28165: LIST
28166: PUSH
28167: LD_INT 2
28169: NEG
28170: PUSH
28171: LD_INT 0
28173: PUSH
28174: EMPTY
28175: LIST
28176: LIST
28177: PUSH
28178: LD_INT 2
28180: NEG
28181: PUSH
28182: LD_INT 1
28184: NEG
28185: PUSH
28186: EMPTY
28187: LIST
28188: LIST
28189: PUSH
28190: LD_INT 2
28192: NEG
28193: PUSH
28194: LD_INT 2
28196: NEG
28197: PUSH
28198: EMPTY
28199: LIST
28200: LIST
28201: PUSH
28202: LD_INT 2
28204: NEG
28205: PUSH
28206: LD_INT 3
28208: NEG
28209: PUSH
28210: EMPTY
28211: LIST
28212: LIST
28213: PUSH
28214: LD_INT 1
28216: NEG
28217: PUSH
28218: LD_INT 3
28220: NEG
28221: PUSH
28222: EMPTY
28223: LIST
28224: LIST
28225: PUSH
28226: LD_INT 1
28228: PUSH
28229: LD_INT 2
28231: NEG
28232: PUSH
28233: EMPTY
28234: LIST
28235: LIST
28236: PUSH
28237: LD_INT 2
28239: PUSH
28240: LD_INT 1
28242: NEG
28243: PUSH
28244: EMPTY
28245: LIST
28246: LIST
28247: PUSH
28248: EMPTY
28249: LIST
28250: LIST
28251: LIST
28252: LIST
28253: LIST
28254: LIST
28255: LIST
28256: LIST
28257: LIST
28258: LIST
28259: LIST
28260: LIST
28261: LIST
28262: LIST
28263: LIST
28264: LIST
28265: LIST
28266: LIST
28267: LIST
28268: LIST
28269: LIST
28270: LIST
28271: LIST
28272: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
28273: LD_ADDR_VAR 0 24
28277: PUSH
28278: LD_INT 0
28280: PUSH
28281: LD_INT 0
28283: PUSH
28284: EMPTY
28285: LIST
28286: LIST
28287: PUSH
28288: LD_INT 0
28290: PUSH
28291: LD_INT 1
28293: NEG
28294: PUSH
28295: EMPTY
28296: LIST
28297: LIST
28298: PUSH
28299: LD_INT 1
28301: PUSH
28302: LD_INT 0
28304: PUSH
28305: EMPTY
28306: LIST
28307: LIST
28308: PUSH
28309: LD_INT 1
28311: PUSH
28312: LD_INT 1
28314: PUSH
28315: EMPTY
28316: LIST
28317: LIST
28318: PUSH
28319: LD_INT 0
28321: PUSH
28322: LD_INT 1
28324: PUSH
28325: EMPTY
28326: LIST
28327: LIST
28328: PUSH
28329: LD_INT 1
28331: NEG
28332: PUSH
28333: LD_INT 0
28335: PUSH
28336: EMPTY
28337: LIST
28338: LIST
28339: PUSH
28340: LD_INT 1
28342: NEG
28343: PUSH
28344: LD_INT 1
28346: NEG
28347: PUSH
28348: EMPTY
28349: LIST
28350: LIST
28351: PUSH
28352: LD_INT 1
28354: NEG
28355: PUSH
28356: LD_INT 2
28358: NEG
28359: PUSH
28360: EMPTY
28361: LIST
28362: LIST
28363: PUSH
28364: LD_INT 0
28366: PUSH
28367: LD_INT 2
28369: NEG
28370: PUSH
28371: EMPTY
28372: LIST
28373: LIST
28374: PUSH
28375: LD_INT 1
28377: PUSH
28378: LD_INT 1
28380: NEG
28381: PUSH
28382: EMPTY
28383: LIST
28384: LIST
28385: PUSH
28386: LD_INT 2
28388: PUSH
28389: LD_INT 0
28391: PUSH
28392: EMPTY
28393: LIST
28394: LIST
28395: PUSH
28396: LD_INT 2
28398: PUSH
28399: LD_INT 1
28401: PUSH
28402: EMPTY
28403: LIST
28404: LIST
28405: PUSH
28406: LD_INT 2
28408: PUSH
28409: LD_INT 2
28411: PUSH
28412: EMPTY
28413: LIST
28414: LIST
28415: PUSH
28416: LD_INT 1
28418: PUSH
28419: LD_INT 2
28421: PUSH
28422: EMPTY
28423: LIST
28424: LIST
28425: PUSH
28426: LD_INT 0
28428: PUSH
28429: LD_INT 2
28431: PUSH
28432: EMPTY
28433: LIST
28434: LIST
28435: PUSH
28436: LD_INT 1
28438: NEG
28439: PUSH
28440: LD_INT 1
28442: PUSH
28443: EMPTY
28444: LIST
28445: LIST
28446: PUSH
28447: LD_INT 2
28449: NEG
28450: PUSH
28451: LD_INT 0
28453: PUSH
28454: EMPTY
28455: LIST
28456: LIST
28457: PUSH
28458: LD_INT 2
28460: NEG
28461: PUSH
28462: LD_INT 1
28464: NEG
28465: PUSH
28466: EMPTY
28467: LIST
28468: LIST
28469: PUSH
28470: LD_INT 2
28472: NEG
28473: PUSH
28474: LD_INT 2
28476: NEG
28477: PUSH
28478: EMPTY
28479: LIST
28480: LIST
28481: PUSH
28482: LD_INT 1
28484: PUSH
28485: LD_INT 2
28487: NEG
28488: PUSH
28489: EMPTY
28490: LIST
28491: LIST
28492: PUSH
28493: LD_INT 2
28495: PUSH
28496: LD_INT 1
28498: NEG
28499: PUSH
28500: EMPTY
28501: LIST
28502: LIST
28503: PUSH
28504: LD_INT 3
28506: PUSH
28507: LD_INT 1
28509: PUSH
28510: EMPTY
28511: LIST
28512: LIST
28513: PUSH
28514: LD_INT 3
28516: PUSH
28517: LD_INT 2
28519: PUSH
28520: EMPTY
28521: LIST
28522: LIST
28523: PUSH
28524: EMPTY
28525: LIST
28526: LIST
28527: LIST
28528: LIST
28529: LIST
28530: LIST
28531: LIST
28532: LIST
28533: LIST
28534: LIST
28535: LIST
28536: LIST
28537: LIST
28538: LIST
28539: LIST
28540: LIST
28541: LIST
28542: LIST
28543: LIST
28544: LIST
28545: LIST
28546: LIST
28547: LIST
28548: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
28549: LD_ADDR_VAR 0 25
28553: PUSH
28554: LD_INT 0
28556: PUSH
28557: LD_INT 0
28559: PUSH
28560: EMPTY
28561: LIST
28562: LIST
28563: PUSH
28564: LD_INT 0
28566: PUSH
28567: LD_INT 1
28569: NEG
28570: PUSH
28571: EMPTY
28572: LIST
28573: LIST
28574: PUSH
28575: LD_INT 1
28577: PUSH
28578: LD_INT 0
28580: PUSH
28581: EMPTY
28582: LIST
28583: LIST
28584: PUSH
28585: LD_INT 1
28587: PUSH
28588: LD_INT 1
28590: PUSH
28591: EMPTY
28592: LIST
28593: LIST
28594: PUSH
28595: LD_INT 0
28597: PUSH
28598: LD_INT 1
28600: PUSH
28601: EMPTY
28602: LIST
28603: LIST
28604: PUSH
28605: LD_INT 1
28607: NEG
28608: PUSH
28609: LD_INT 0
28611: PUSH
28612: EMPTY
28613: LIST
28614: LIST
28615: PUSH
28616: LD_INT 1
28618: NEG
28619: PUSH
28620: LD_INT 1
28622: NEG
28623: PUSH
28624: EMPTY
28625: LIST
28626: LIST
28627: PUSH
28628: LD_INT 1
28630: NEG
28631: PUSH
28632: LD_INT 2
28634: NEG
28635: PUSH
28636: EMPTY
28637: LIST
28638: LIST
28639: PUSH
28640: LD_INT 0
28642: PUSH
28643: LD_INT 2
28645: NEG
28646: PUSH
28647: EMPTY
28648: LIST
28649: LIST
28650: PUSH
28651: LD_INT 1
28653: PUSH
28654: LD_INT 1
28656: NEG
28657: PUSH
28658: EMPTY
28659: LIST
28660: LIST
28661: PUSH
28662: LD_INT 2
28664: PUSH
28665: LD_INT 0
28667: PUSH
28668: EMPTY
28669: LIST
28670: LIST
28671: PUSH
28672: LD_INT 2
28674: PUSH
28675: LD_INT 1
28677: PUSH
28678: EMPTY
28679: LIST
28680: LIST
28681: PUSH
28682: LD_INT 2
28684: PUSH
28685: LD_INT 2
28687: PUSH
28688: EMPTY
28689: LIST
28690: LIST
28691: PUSH
28692: LD_INT 1
28694: PUSH
28695: LD_INT 2
28697: PUSH
28698: EMPTY
28699: LIST
28700: LIST
28701: PUSH
28702: LD_INT 0
28704: PUSH
28705: LD_INT 2
28707: PUSH
28708: EMPTY
28709: LIST
28710: LIST
28711: PUSH
28712: LD_INT 1
28714: NEG
28715: PUSH
28716: LD_INT 1
28718: PUSH
28719: EMPTY
28720: LIST
28721: LIST
28722: PUSH
28723: LD_INT 2
28725: NEG
28726: PUSH
28727: LD_INT 0
28729: PUSH
28730: EMPTY
28731: LIST
28732: LIST
28733: PUSH
28734: LD_INT 2
28736: NEG
28737: PUSH
28738: LD_INT 1
28740: NEG
28741: PUSH
28742: EMPTY
28743: LIST
28744: LIST
28745: PUSH
28746: LD_INT 2
28748: NEG
28749: PUSH
28750: LD_INT 2
28752: NEG
28753: PUSH
28754: EMPTY
28755: LIST
28756: LIST
28757: PUSH
28758: LD_INT 3
28760: PUSH
28761: LD_INT 1
28763: PUSH
28764: EMPTY
28765: LIST
28766: LIST
28767: PUSH
28768: LD_INT 3
28770: PUSH
28771: LD_INT 2
28773: PUSH
28774: EMPTY
28775: LIST
28776: LIST
28777: PUSH
28778: LD_INT 2
28780: PUSH
28781: LD_INT 3
28783: PUSH
28784: EMPTY
28785: LIST
28786: LIST
28787: PUSH
28788: LD_INT 1
28790: PUSH
28791: LD_INT 3
28793: PUSH
28794: EMPTY
28795: LIST
28796: LIST
28797: PUSH
28798: EMPTY
28799: LIST
28800: LIST
28801: LIST
28802: LIST
28803: LIST
28804: LIST
28805: LIST
28806: LIST
28807: LIST
28808: LIST
28809: LIST
28810: LIST
28811: LIST
28812: LIST
28813: LIST
28814: LIST
28815: LIST
28816: LIST
28817: LIST
28818: LIST
28819: LIST
28820: LIST
28821: LIST
28822: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
28823: LD_ADDR_VAR 0 26
28827: PUSH
28828: LD_INT 0
28830: PUSH
28831: LD_INT 0
28833: PUSH
28834: EMPTY
28835: LIST
28836: LIST
28837: PUSH
28838: LD_INT 0
28840: PUSH
28841: LD_INT 1
28843: NEG
28844: PUSH
28845: EMPTY
28846: LIST
28847: LIST
28848: PUSH
28849: LD_INT 1
28851: PUSH
28852: LD_INT 0
28854: PUSH
28855: EMPTY
28856: LIST
28857: LIST
28858: PUSH
28859: LD_INT 1
28861: PUSH
28862: LD_INT 1
28864: PUSH
28865: EMPTY
28866: LIST
28867: LIST
28868: PUSH
28869: LD_INT 0
28871: PUSH
28872: LD_INT 1
28874: PUSH
28875: EMPTY
28876: LIST
28877: LIST
28878: PUSH
28879: LD_INT 1
28881: NEG
28882: PUSH
28883: LD_INT 0
28885: PUSH
28886: EMPTY
28887: LIST
28888: LIST
28889: PUSH
28890: LD_INT 1
28892: NEG
28893: PUSH
28894: LD_INT 1
28896: NEG
28897: PUSH
28898: EMPTY
28899: LIST
28900: LIST
28901: PUSH
28902: LD_INT 1
28904: NEG
28905: PUSH
28906: LD_INT 2
28908: NEG
28909: PUSH
28910: EMPTY
28911: LIST
28912: LIST
28913: PUSH
28914: LD_INT 0
28916: PUSH
28917: LD_INT 2
28919: NEG
28920: PUSH
28921: EMPTY
28922: LIST
28923: LIST
28924: PUSH
28925: LD_INT 1
28927: PUSH
28928: LD_INT 1
28930: NEG
28931: PUSH
28932: EMPTY
28933: LIST
28934: LIST
28935: PUSH
28936: LD_INT 2
28938: PUSH
28939: LD_INT 0
28941: PUSH
28942: EMPTY
28943: LIST
28944: LIST
28945: PUSH
28946: LD_INT 2
28948: PUSH
28949: LD_INT 1
28951: PUSH
28952: EMPTY
28953: LIST
28954: LIST
28955: PUSH
28956: LD_INT 2
28958: PUSH
28959: LD_INT 2
28961: PUSH
28962: EMPTY
28963: LIST
28964: LIST
28965: PUSH
28966: LD_INT 1
28968: PUSH
28969: LD_INT 2
28971: PUSH
28972: EMPTY
28973: LIST
28974: LIST
28975: PUSH
28976: LD_INT 0
28978: PUSH
28979: LD_INT 2
28981: PUSH
28982: EMPTY
28983: LIST
28984: LIST
28985: PUSH
28986: LD_INT 1
28988: NEG
28989: PUSH
28990: LD_INT 1
28992: PUSH
28993: EMPTY
28994: LIST
28995: LIST
28996: PUSH
28997: LD_INT 2
28999: NEG
29000: PUSH
29001: LD_INT 0
29003: PUSH
29004: EMPTY
29005: LIST
29006: LIST
29007: PUSH
29008: LD_INT 2
29010: NEG
29011: PUSH
29012: LD_INT 1
29014: NEG
29015: PUSH
29016: EMPTY
29017: LIST
29018: LIST
29019: PUSH
29020: LD_INT 2
29022: NEG
29023: PUSH
29024: LD_INT 2
29026: NEG
29027: PUSH
29028: EMPTY
29029: LIST
29030: LIST
29031: PUSH
29032: LD_INT 2
29034: PUSH
29035: LD_INT 3
29037: PUSH
29038: EMPTY
29039: LIST
29040: LIST
29041: PUSH
29042: LD_INT 1
29044: PUSH
29045: LD_INT 3
29047: PUSH
29048: EMPTY
29049: LIST
29050: LIST
29051: PUSH
29052: LD_INT 1
29054: NEG
29055: PUSH
29056: LD_INT 2
29058: PUSH
29059: EMPTY
29060: LIST
29061: LIST
29062: PUSH
29063: LD_INT 2
29065: NEG
29066: PUSH
29067: LD_INT 1
29069: PUSH
29070: EMPTY
29071: LIST
29072: LIST
29073: PUSH
29074: EMPTY
29075: LIST
29076: LIST
29077: LIST
29078: LIST
29079: LIST
29080: LIST
29081: LIST
29082: LIST
29083: LIST
29084: LIST
29085: LIST
29086: LIST
29087: LIST
29088: LIST
29089: LIST
29090: LIST
29091: LIST
29092: LIST
29093: LIST
29094: LIST
29095: LIST
29096: LIST
29097: LIST
29098: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
29099: LD_ADDR_VAR 0 27
29103: PUSH
29104: LD_INT 0
29106: PUSH
29107: LD_INT 0
29109: PUSH
29110: EMPTY
29111: LIST
29112: LIST
29113: PUSH
29114: LD_INT 0
29116: PUSH
29117: LD_INT 1
29119: NEG
29120: PUSH
29121: EMPTY
29122: LIST
29123: LIST
29124: PUSH
29125: LD_INT 1
29127: PUSH
29128: LD_INT 0
29130: PUSH
29131: EMPTY
29132: LIST
29133: LIST
29134: PUSH
29135: LD_INT 1
29137: PUSH
29138: LD_INT 1
29140: PUSH
29141: EMPTY
29142: LIST
29143: LIST
29144: PUSH
29145: LD_INT 0
29147: PUSH
29148: LD_INT 1
29150: PUSH
29151: EMPTY
29152: LIST
29153: LIST
29154: PUSH
29155: LD_INT 1
29157: NEG
29158: PUSH
29159: LD_INT 0
29161: PUSH
29162: EMPTY
29163: LIST
29164: LIST
29165: PUSH
29166: LD_INT 1
29168: NEG
29169: PUSH
29170: LD_INT 1
29172: NEG
29173: PUSH
29174: EMPTY
29175: LIST
29176: LIST
29177: PUSH
29178: LD_INT 1
29180: NEG
29181: PUSH
29182: LD_INT 2
29184: NEG
29185: PUSH
29186: EMPTY
29187: LIST
29188: LIST
29189: PUSH
29190: LD_INT 0
29192: PUSH
29193: LD_INT 2
29195: NEG
29196: PUSH
29197: EMPTY
29198: LIST
29199: LIST
29200: PUSH
29201: LD_INT 1
29203: PUSH
29204: LD_INT 1
29206: NEG
29207: PUSH
29208: EMPTY
29209: LIST
29210: LIST
29211: PUSH
29212: LD_INT 2
29214: PUSH
29215: LD_INT 0
29217: PUSH
29218: EMPTY
29219: LIST
29220: LIST
29221: PUSH
29222: LD_INT 2
29224: PUSH
29225: LD_INT 1
29227: PUSH
29228: EMPTY
29229: LIST
29230: LIST
29231: PUSH
29232: LD_INT 2
29234: PUSH
29235: LD_INT 2
29237: PUSH
29238: EMPTY
29239: LIST
29240: LIST
29241: PUSH
29242: LD_INT 1
29244: PUSH
29245: LD_INT 2
29247: PUSH
29248: EMPTY
29249: LIST
29250: LIST
29251: PUSH
29252: LD_INT 0
29254: PUSH
29255: LD_INT 2
29257: PUSH
29258: EMPTY
29259: LIST
29260: LIST
29261: PUSH
29262: LD_INT 1
29264: NEG
29265: PUSH
29266: LD_INT 1
29268: PUSH
29269: EMPTY
29270: LIST
29271: LIST
29272: PUSH
29273: LD_INT 2
29275: NEG
29276: PUSH
29277: LD_INT 0
29279: PUSH
29280: EMPTY
29281: LIST
29282: LIST
29283: PUSH
29284: LD_INT 2
29286: NEG
29287: PUSH
29288: LD_INT 1
29290: NEG
29291: PUSH
29292: EMPTY
29293: LIST
29294: LIST
29295: PUSH
29296: LD_INT 2
29298: NEG
29299: PUSH
29300: LD_INT 2
29302: NEG
29303: PUSH
29304: EMPTY
29305: LIST
29306: LIST
29307: PUSH
29308: LD_INT 1
29310: NEG
29311: PUSH
29312: LD_INT 2
29314: PUSH
29315: EMPTY
29316: LIST
29317: LIST
29318: PUSH
29319: LD_INT 2
29321: NEG
29322: PUSH
29323: LD_INT 1
29325: PUSH
29326: EMPTY
29327: LIST
29328: LIST
29329: PUSH
29330: LD_INT 3
29332: NEG
29333: PUSH
29334: LD_INT 1
29336: NEG
29337: PUSH
29338: EMPTY
29339: LIST
29340: LIST
29341: PUSH
29342: LD_INT 3
29344: NEG
29345: PUSH
29346: LD_INT 2
29348: NEG
29349: PUSH
29350: EMPTY
29351: LIST
29352: LIST
29353: PUSH
29354: EMPTY
29355: LIST
29356: LIST
29357: LIST
29358: LIST
29359: LIST
29360: LIST
29361: LIST
29362: LIST
29363: LIST
29364: LIST
29365: LIST
29366: LIST
29367: LIST
29368: LIST
29369: LIST
29370: LIST
29371: LIST
29372: LIST
29373: LIST
29374: LIST
29375: LIST
29376: LIST
29377: LIST
29378: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
29379: LD_ADDR_VAR 0 28
29383: PUSH
29384: LD_INT 0
29386: PUSH
29387: LD_INT 0
29389: PUSH
29390: EMPTY
29391: LIST
29392: LIST
29393: PUSH
29394: LD_INT 0
29396: PUSH
29397: LD_INT 1
29399: NEG
29400: PUSH
29401: EMPTY
29402: LIST
29403: LIST
29404: PUSH
29405: LD_INT 1
29407: PUSH
29408: LD_INT 0
29410: PUSH
29411: EMPTY
29412: LIST
29413: LIST
29414: PUSH
29415: LD_INT 1
29417: PUSH
29418: LD_INT 1
29420: PUSH
29421: EMPTY
29422: LIST
29423: LIST
29424: PUSH
29425: LD_INT 0
29427: PUSH
29428: LD_INT 1
29430: PUSH
29431: EMPTY
29432: LIST
29433: LIST
29434: PUSH
29435: LD_INT 1
29437: NEG
29438: PUSH
29439: LD_INT 0
29441: PUSH
29442: EMPTY
29443: LIST
29444: LIST
29445: PUSH
29446: LD_INT 1
29448: NEG
29449: PUSH
29450: LD_INT 1
29452: NEG
29453: PUSH
29454: EMPTY
29455: LIST
29456: LIST
29457: PUSH
29458: LD_INT 1
29460: NEG
29461: PUSH
29462: LD_INT 2
29464: NEG
29465: PUSH
29466: EMPTY
29467: LIST
29468: LIST
29469: PUSH
29470: LD_INT 0
29472: PUSH
29473: LD_INT 2
29475: NEG
29476: PUSH
29477: EMPTY
29478: LIST
29479: LIST
29480: PUSH
29481: LD_INT 1
29483: PUSH
29484: LD_INT 1
29486: NEG
29487: PUSH
29488: EMPTY
29489: LIST
29490: LIST
29491: PUSH
29492: LD_INT 2
29494: PUSH
29495: LD_INT 0
29497: PUSH
29498: EMPTY
29499: LIST
29500: LIST
29501: PUSH
29502: LD_INT 2
29504: PUSH
29505: LD_INT 1
29507: PUSH
29508: EMPTY
29509: LIST
29510: LIST
29511: PUSH
29512: LD_INT 2
29514: PUSH
29515: LD_INT 2
29517: PUSH
29518: EMPTY
29519: LIST
29520: LIST
29521: PUSH
29522: LD_INT 1
29524: PUSH
29525: LD_INT 2
29527: PUSH
29528: EMPTY
29529: LIST
29530: LIST
29531: PUSH
29532: LD_INT 0
29534: PUSH
29535: LD_INT 2
29537: PUSH
29538: EMPTY
29539: LIST
29540: LIST
29541: PUSH
29542: LD_INT 1
29544: NEG
29545: PUSH
29546: LD_INT 1
29548: PUSH
29549: EMPTY
29550: LIST
29551: LIST
29552: PUSH
29553: LD_INT 2
29555: NEG
29556: PUSH
29557: LD_INT 0
29559: PUSH
29560: EMPTY
29561: LIST
29562: LIST
29563: PUSH
29564: LD_INT 2
29566: NEG
29567: PUSH
29568: LD_INT 1
29570: NEG
29571: PUSH
29572: EMPTY
29573: LIST
29574: LIST
29575: PUSH
29576: LD_INT 2
29578: NEG
29579: PUSH
29580: LD_INT 2
29582: NEG
29583: PUSH
29584: EMPTY
29585: LIST
29586: LIST
29587: PUSH
29588: LD_INT 2
29590: NEG
29591: PUSH
29592: LD_INT 3
29594: NEG
29595: PUSH
29596: EMPTY
29597: LIST
29598: LIST
29599: PUSH
29600: LD_INT 1
29602: NEG
29603: PUSH
29604: LD_INT 3
29606: NEG
29607: PUSH
29608: EMPTY
29609: LIST
29610: LIST
29611: PUSH
29612: LD_INT 3
29614: NEG
29615: PUSH
29616: LD_INT 1
29618: NEG
29619: PUSH
29620: EMPTY
29621: LIST
29622: LIST
29623: PUSH
29624: LD_INT 3
29626: NEG
29627: PUSH
29628: LD_INT 2
29630: NEG
29631: PUSH
29632: EMPTY
29633: LIST
29634: LIST
29635: PUSH
29636: EMPTY
29637: LIST
29638: LIST
29639: LIST
29640: LIST
29641: LIST
29642: LIST
29643: LIST
29644: LIST
29645: LIST
29646: LIST
29647: LIST
29648: LIST
29649: LIST
29650: LIST
29651: LIST
29652: LIST
29653: LIST
29654: LIST
29655: LIST
29656: LIST
29657: LIST
29658: LIST
29659: LIST
29660: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
29661: LD_ADDR_VAR 0 29
29665: PUSH
29666: LD_INT 0
29668: PUSH
29669: LD_INT 0
29671: PUSH
29672: EMPTY
29673: LIST
29674: LIST
29675: PUSH
29676: LD_INT 0
29678: PUSH
29679: LD_INT 1
29681: NEG
29682: PUSH
29683: EMPTY
29684: LIST
29685: LIST
29686: PUSH
29687: LD_INT 1
29689: PUSH
29690: LD_INT 0
29692: PUSH
29693: EMPTY
29694: LIST
29695: LIST
29696: PUSH
29697: LD_INT 1
29699: PUSH
29700: LD_INT 1
29702: PUSH
29703: EMPTY
29704: LIST
29705: LIST
29706: PUSH
29707: LD_INT 0
29709: PUSH
29710: LD_INT 1
29712: PUSH
29713: EMPTY
29714: LIST
29715: LIST
29716: PUSH
29717: LD_INT 1
29719: NEG
29720: PUSH
29721: LD_INT 0
29723: PUSH
29724: EMPTY
29725: LIST
29726: LIST
29727: PUSH
29728: LD_INT 1
29730: NEG
29731: PUSH
29732: LD_INT 1
29734: NEG
29735: PUSH
29736: EMPTY
29737: LIST
29738: LIST
29739: PUSH
29740: LD_INT 1
29742: NEG
29743: PUSH
29744: LD_INT 2
29746: NEG
29747: PUSH
29748: EMPTY
29749: LIST
29750: LIST
29751: PUSH
29752: LD_INT 0
29754: PUSH
29755: LD_INT 2
29757: NEG
29758: PUSH
29759: EMPTY
29760: LIST
29761: LIST
29762: PUSH
29763: LD_INT 1
29765: PUSH
29766: LD_INT 1
29768: NEG
29769: PUSH
29770: EMPTY
29771: LIST
29772: LIST
29773: PUSH
29774: LD_INT 2
29776: PUSH
29777: LD_INT 0
29779: PUSH
29780: EMPTY
29781: LIST
29782: LIST
29783: PUSH
29784: LD_INT 2
29786: PUSH
29787: LD_INT 1
29789: PUSH
29790: EMPTY
29791: LIST
29792: LIST
29793: PUSH
29794: LD_INT 1
29796: PUSH
29797: LD_INT 2
29799: PUSH
29800: EMPTY
29801: LIST
29802: LIST
29803: PUSH
29804: LD_INT 0
29806: PUSH
29807: LD_INT 2
29809: PUSH
29810: EMPTY
29811: LIST
29812: LIST
29813: PUSH
29814: LD_INT 1
29816: NEG
29817: PUSH
29818: LD_INT 1
29820: PUSH
29821: EMPTY
29822: LIST
29823: LIST
29824: PUSH
29825: LD_INT 2
29827: NEG
29828: PUSH
29829: LD_INT 1
29831: NEG
29832: PUSH
29833: EMPTY
29834: LIST
29835: LIST
29836: PUSH
29837: LD_INT 2
29839: NEG
29840: PUSH
29841: LD_INT 2
29843: NEG
29844: PUSH
29845: EMPTY
29846: LIST
29847: LIST
29848: PUSH
29849: LD_INT 2
29851: NEG
29852: PUSH
29853: LD_INT 3
29855: NEG
29856: PUSH
29857: EMPTY
29858: LIST
29859: LIST
29860: PUSH
29861: LD_INT 2
29863: PUSH
29864: LD_INT 1
29866: NEG
29867: PUSH
29868: EMPTY
29869: LIST
29870: LIST
29871: PUSH
29872: LD_INT 3
29874: PUSH
29875: LD_INT 1
29877: PUSH
29878: EMPTY
29879: LIST
29880: LIST
29881: PUSH
29882: LD_INT 1
29884: PUSH
29885: LD_INT 3
29887: PUSH
29888: EMPTY
29889: LIST
29890: LIST
29891: PUSH
29892: LD_INT 1
29894: NEG
29895: PUSH
29896: LD_INT 2
29898: PUSH
29899: EMPTY
29900: LIST
29901: LIST
29902: PUSH
29903: LD_INT 3
29905: NEG
29906: PUSH
29907: LD_INT 2
29909: NEG
29910: PUSH
29911: EMPTY
29912: LIST
29913: LIST
29914: PUSH
29915: EMPTY
29916: LIST
29917: LIST
29918: LIST
29919: LIST
29920: LIST
29921: LIST
29922: LIST
29923: LIST
29924: LIST
29925: LIST
29926: LIST
29927: LIST
29928: LIST
29929: LIST
29930: LIST
29931: LIST
29932: LIST
29933: LIST
29934: LIST
29935: LIST
29936: LIST
29937: LIST
29938: LIST
29939: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
29940: LD_ADDR_VAR 0 30
29944: PUSH
29945: LD_INT 0
29947: PUSH
29948: LD_INT 0
29950: PUSH
29951: EMPTY
29952: LIST
29953: LIST
29954: PUSH
29955: LD_INT 0
29957: PUSH
29958: LD_INT 1
29960: NEG
29961: PUSH
29962: EMPTY
29963: LIST
29964: LIST
29965: PUSH
29966: LD_INT 1
29968: PUSH
29969: LD_INT 0
29971: PUSH
29972: EMPTY
29973: LIST
29974: LIST
29975: PUSH
29976: LD_INT 1
29978: PUSH
29979: LD_INT 1
29981: PUSH
29982: EMPTY
29983: LIST
29984: LIST
29985: PUSH
29986: LD_INT 0
29988: PUSH
29989: LD_INT 1
29991: PUSH
29992: EMPTY
29993: LIST
29994: LIST
29995: PUSH
29996: LD_INT 1
29998: NEG
29999: PUSH
30000: LD_INT 0
30002: PUSH
30003: EMPTY
30004: LIST
30005: LIST
30006: PUSH
30007: LD_INT 1
30009: NEG
30010: PUSH
30011: LD_INT 1
30013: NEG
30014: PUSH
30015: EMPTY
30016: LIST
30017: LIST
30018: PUSH
30019: LD_INT 1
30021: NEG
30022: PUSH
30023: LD_INT 2
30025: NEG
30026: PUSH
30027: EMPTY
30028: LIST
30029: LIST
30030: PUSH
30031: LD_INT 0
30033: PUSH
30034: LD_INT 2
30036: NEG
30037: PUSH
30038: EMPTY
30039: LIST
30040: LIST
30041: PUSH
30042: LD_INT 1
30044: PUSH
30045: LD_INT 1
30047: NEG
30048: PUSH
30049: EMPTY
30050: LIST
30051: LIST
30052: PUSH
30053: LD_INT 2
30055: PUSH
30056: LD_INT 0
30058: PUSH
30059: EMPTY
30060: LIST
30061: LIST
30062: PUSH
30063: LD_INT 2
30065: PUSH
30066: LD_INT 1
30068: PUSH
30069: EMPTY
30070: LIST
30071: LIST
30072: PUSH
30073: LD_INT 2
30075: PUSH
30076: LD_INT 2
30078: PUSH
30079: EMPTY
30080: LIST
30081: LIST
30082: PUSH
30083: LD_INT 1
30085: PUSH
30086: LD_INT 2
30088: PUSH
30089: EMPTY
30090: LIST
30091: LIST
30092: PUSH
30093: LD_INT 1
30095: NEG
30096: PUSH
30097: LD_INT 1
30099: PUSH
30100: EMPTY
30101: LIST
30102: LIST
30103: PUSH
30104: LD_INT 2
30106: NEG
30107: PUSH
30108: LD_INT 0
30110: PUSH
30111: EMPTY
30112: LIST
30113: LIST
30114: PUSH
30115: LD_INT 2
30117: NEG
30118: PUSH
30119: LD_INT 1
30121: NEG
30122: PUSH
30123: EMPTY
30124: LIST
30125: LIST
30126: PUSH
30127: LD_INT 1
30129: NEG
30130: PUSH
30131: LD_INT 3
30133: NEG
30134: PUSH
30135: EMPTY
30136: LIST
30137: LIST
30138: PUSH
30139: LD_INT 1
30141: PUSH
30142: LD_INT 2
30144: NEG
30145: PUSH
30146: EMPTY
30147: LIST
30148: LIST
30149: PUSH
30150: LD_INT 3
30152: PUSH
30153: LD_INT 2
30155: PUSH
30156: EMPTY
30157: LIST
30158: LIST
30159: PUSH
30160: LD_INT 2
30162: PUSH
30163: LD_INT 3
30165: PUSH
30166: EMPTY
30167: LIST
30168: LIST
30169: PUSH
30170: LD_INT 2
30172: NEG
30173: PUSH
30174: LD_INT 1
30176: PUSH
30177: EMPTY
30178: LIST
30179: LIST
30180: PUSH
30181: LD_INT 3
30183: NEG
30184: PUSH
30185: LD_INT 1
30187: NEG
30188: PUSH
30189: EMPTY
30190: LIST
30191: LIST
30192: PUSH
30193: EMPTY
30194: LIST
30195: LIST
30196: LIST
30197: LIST
30198: LIST
30199: LIST
30200: LIST
30201: LIST
30202: LIST
30203: LIST
30204: LIST
30205: LIST
30206: LIST
30207: LIST
30208: LIST
30209: LIST
30210: LIST
30211: LIST
30212: LIST
30213: LIST
30214: LIST
30215: LIST
30216: LIST
30217: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
30218: LD_ADDR_VAR 0 31
30222: PUSH
30223: LD_INT 0
30225: PUSH
30226: LD_INT 0
30228: PUSH
30229: EMPTY
30230: LIST
30231: LIST
30232: PUSH
30233: LD_INT 0
30235: PUSH
30236: LD_INT 1
30238: NEG
30239: PUSH
30240: EMPTY
30241: LIST
30242: LIST
30243: PUSH
30244: LD_INT 1
30246: PUSH
30247: LD_INT 0
30249: PUSH
30250: EMPTY
30251: LIST
30252: LIST
30253: PUSH
30254: LD_INT 1
30256: PUSH
30257: LD_INT 1
30259: PUSH
30260: EMPTY
30261: LIST
30262: LIST
30263: PUSH
30264: LD_INT 0
30266: PUSH
30267: LD_INT 1
30269: PUSH
30270: EMPTY
30271: LIST
30272: LIST
30273: PUSH
30274: LD_INT 1
30276: NEG
30277: PUSH
30278: LD_INT 0
30280: PUSH
30281: EMPTY
30282: LIST
30283: LIST
30284: PUSH
30285: LD_INT 1
30287: NEG
30288: PUSH
30289: LD_INT 1
30291: NEG
30292: PUSH
30293: EMPTY
30294: LIST
30295: LIST
30296: PUSH
30297: LD_INT 1
30299: NEG
30300: PUSH
30301: LD_INT 2
30303: NEG
30304: PUSH
30305: EMPTY
30306: LIST
30307: LIST
30308: PUSH
30309: LD_INT 1
30311: PUSH
30312: LD_INT 1
30314: NEG
30315: PUSH
30316: EMPTY
30317: LIST
30318: LIST
30319: PUSH
30320: LD_INT 2
30322: PUSH
30323: LD_INT 0
30325: PUSH
30326: EMPTY
30327: LIST
30328: LIST
30329: PUSH
30330: LD_INT 2
30332: PUSH
30333: LD_INT 1
30335: PUSH
30336: EMPTY
30337: LIST
30338: LIST
30339: PUSH
30340: LD_INT 2
30342: PUSH
30343: LD_INT 2
30345: PUSH
30346: EMPTY
30347: LIST
30348: LIST
30349: PUSH
30350: LD_INT 1
30352: PUSH
30353: LD_INT 2
30355: PUSH
30356: EMPTY
30357: LIST
30358: LIST
30359: PUSH
30360: LD_INT 0
30362: PUSH
30363: LD_INT 2
30365: PUSH
30366: EMPTY
30367: LIST
30368: LIST
30369: PUSH
30370: LD_INT 1
30372: NEG
30373: PUSH
30374: LD_INT 1
30376: PUSH
30377: EMPTY
30378: LIST
30379: LIST
30380: PUSH
30381: LD_INT 2
30383: NEG
30384: PUSH
30385: LD_INT 1
30387: NEG
30388: PUSH
30389: EMPTY
30390: LIST
30391: LIST
30392: PUSH
30393: LD_INT 2
30395: NEG
30396: PUSH
30397: LD_INT 2
30399: NEG
30400: PUSH
30401: EMPTY
30402: LIST
30403: LIST
30404: PUSH
30405: LD_INT 2
30407: NEG
30408: PUSH
30409: LD_INT 3
30411: NEG
30412: PUSH
30413: EMPTY
30414: LIST
30415: LIST
30416: PUSH
30417: LD_INT 2
30419: PUSH
30420: LD_INT 1
30422: NEG
30423: PUSH
30424: EMPTY
30425: LIST
30426: LIST
30427: PUSH
30428: LD_INT 3
30430: PUSH
30431: LD_INT 1
30433: PUSH
30434: EMPTY
30435: LIST
30436: LIST
30437: PUSH
30438: LD_INT 1
30440: PUSH
30441: LD_INT 3
30443: PUSH
30444: EMPTY
30445: LIST
30446: LIST
30447: PUSH
30448: LD_INT 1
30450: NEG
30451: PUSH
30452: LD_INT 2
30454: PUSH
30455: EMPTY
30456: LIST
30457: LIST
30458: PUSH
30459: LD_INT 3
30461: NEG
30462: PUSH
30463: LD_INT 2
30465: NEG
30466: PUSH
30467: EMPTY
30468: LIST
30469: LIST
30470: PUSH
30471: EMPTY
30472: LIST
30473: LIST
30474: LIST
30475: LIST
30476: LIST
30477: LIST
30478: LIST
30479: LIST
30480: LIST
30481: LIST
30482: LIST
30483: LIST
30484: LIST
30485: LIST
30486: LIST
30487: LIST
30488: LIST
30489: LIST
30490: LIST
30491: LIST
30492: LIST
30493: LIST
30494: LIST
30495: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
30496: LD_ADDR_VAR 0 32
30500: PUSH
30501: LD_INT 0
30503: PUSH
30504: LD_INT 0
30506: PUSH
30507: EMPTY
30508: LIST
30509: LIST
30510: PUSH
30511: LD_INT 0
30513: PUSH
30514: LD_INT 1
30516: NEG
30517: PUSH
30518: EMPTY
30519: LIST
30520: LIST
30521: PUSH
30522: LD_INT 1
30524: PUSH
30525: LD_INT 0
30527: PUSH
30528: EMPTY
30529: LIST
30530: LIST
30531: PUSH
30532: LD_INT 1
30534: PUSH
30535: LD_INT 1
30537: PUSH
30538: EMPTY
30539: LIST
30540: LIST
30541: PUSH
30542: LD_INT 0
30544: PUSH
30545: LD_INT 1
30547: PUSH
30548: EMPTY
30549: LIST
30550: LIST
30551: PUSH
30552: LD_INT 1
30554: NEG
30555: PUSH
30556: LD_INT 0
30558: PUSH
30559: EMPTY
30560: LIST
30561: LIST
30562: PUSH
30563: LD_INT 1
30565: NEG
30566: PUSH
30567: LD_INT 1
30569: NEG
30570: PUSH
30571: EMPTY
30572: LIST
30573: LIST
30574: PUSH
30575: LD_INT 1
30577: NEG
30578: PUSH
30579: LD_INT 2
30581: NEG
30582: PUSH
30583: EMPTY
30584: LIST
30585: LIST
30586: PUSH
30587: LD_INT 0
30589: PUSH
30590: LD_INT 2
30592: NEG
30593: PUSH
30594: EMPTY
30595: LIST
30596: LIST
30597: PUSH
30598: LD_INT 1
30600: PUSH
30601: LD_INT 1
30603: NEG
30604: PUSH
30605: EMPTY
30606: LIST
30607: LIST
30608: PUSH
30609: LD_INT 2
30611: PUSH
30612: LD_INT 1
30614: PUSH
30615: EMPTY
30616: LIST
30617: LIST
30618: PUSH
30619: LD_INT 2
30621: PUSH
30622: LD_INT 2
30624: PUSH
30625: EMPTY
30626: LIST
30627: LIST
30628: PUSH
30629: LD_INT 1
30631: PUSH
30632: LD_INT 2
30634: PUSH
30635: EMPTY
30636: LIST
30637: LIST
30638: PUSH
30639: LD_INT 0
30641: PUSH
30642: LD_INT 2
30644: PUSH
30645: EMPTY
30646: LIST
30647: LIST
30648: PUSH
30649: LD_INT 1
30651: NEG
30652: PUSH
30653: LD_INT 1
30655: PUSH
30656: EMPTY
30657: LIST
30658: LIST
30659: PUSH
30660: LD_INT 2
30662: NEG
30663: PUSH
30664: LD_INT 0
30666: PUSH
30667: EMPTY
30668: LIST
30669: LIST
30670: PUSH
30671: LD_INT 2
30673: NEG
30674: PUSH
30675: LD_INT 1
30677: NEG
30678: PUSH
30679: EMPTY
30680: LIST
30681: LIST
30682: PUSH
30683: LD_INT 1
30685: NEG
30686: PUSH
30687: LD_INT 3
30689: NEG
30690: PUSH
30691: EMPTY
30692: LIST
30693: LIST
30694: PUSH
30695: LD_INT 1
30697: PUSH
30698: LD_INT 2
30700: NEG
30701: PUSH
30702: EMPTY
30703: LIST
30704: LIST
30705: PUSH
30706: LD_INT 3
30708: PUSH
30709: LD_INT 2
30711: PUSH
30712: EMPTY
30713: LIST
30714: LIST
30715: PUSH
30716: LD_INT 2
30718: PUSH
30719: LD_INT 3
30721: PUSH
30722: EMPTY
30723: LIST
30724: LIST
30725: PUSH
30726: LD_INT 2
30728: NEG
30729: PUSH
30730: LD_INT 1
30732: PUSH
30733: EMPTY
30734: LIST
30735: LIST
30736: PUSH
30737: LD_INT 3
30739: NEG
30740: PUSH
30741: LD_INT 1
30743: NEG
30744: PUSH
30745: EMPTY
30746: LIST
30747: LIST
30748: PUSH
30749: EMPTY
30750: LIST
30751: LIST
30752: LIST
30753: LIST
30754: LIST
30755: LIST
30756: LIST
30757: LIST
30758: LIST
30759: LIST
30760: LIST
30761: LIST
30762: LIST
30763: LIST
30764: LIST
30765: LIST
30766: LIST
30767: LIST
30768: LIST
30769: LIST
30770: LIST
30771: LIST
30772: LIST
30773: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
30774: LD_ADDR_VAR 0 33
30778: PUSH
30779: LD_INT 0
30781: PUSH
30782: LD_INT 0
30784: PUSH
30785: EMPTY
30786: LIST
30787: LIST
30788: PUSH
30789: LD_INT 0
30791: PUSH
30792: LD_INT 1
30794: NEG
30795: PUSH
30796: EMPTY
30797: LIST
30798: LIST
30799: PUSH
30800: LD_INT 1
30802: PUSH
30803: LD_INT 0
30805: PUSH
30806: EMPTY
30807: LIST
30808: LIST
30809: PUSH
30810: LD_INT 1
30812: PUSH
30813: LD_INT 1
30815: PUSH
30816: EMPTY
30817: LIST
30818: LIST
30819: PUSH
30820: LD_INT 0
30822: PUSH
30823: LD_INT 1
30825: PUSH
30826: EMPTY
30827: LIST
30828: LIST
30829: PUSH
30830: LD_INT 1
30832: NEG
30833: PUSH
30834: LD_INT 0
30836: PUSH
30837: EMPTY
30838: LIST
30839: LIST
30840: PUSH
30841: LD_INT 1
30843: NEG
30844: PUSH
30845: LD_INT 1
30847: NEG
30848: PUSH
30849: EMPTY
30850: LIST
30851: LIST
30852: PUSH
30853: LD_INT 1
30855: NEG
30856: PUSH
30857: LD_INT 2
30859: NEG
30860: PUSH
30861: EMPTY
30862: LIST
30863: LIST
30864: PUSH
30865: LD_INT 1
30867: PUSH
30868: LD_INT 1
30870: NEG
30871: PUSH
30872: EMPTY
30873: LIST
30874: LIST
30875: PUSH
30876: LD_INT 2
30878: PUSH
30879: LD_INT 0
30881: PUSH
30882: EMPTY
30883: LIST
30884: LIST
30885: PUSH
30886: LD_INT 2
30888: PUSH
30889: LD_INT 1
30891: PUSH
30892: EMPTY
30893: LIST
30894: LIST
30895: PUSH
30896: LD_INT 1
30898: PUSH
30899: LD_INT 2
30901: PUSH
30902: EMPTY
30903: LIST
30904: LIST
30905: PUSH
30906: LD_INT 0
30908: PUSH
30909: LD_INT 2
30911: PUSH
30912: EMPTY
30913: LIST
30914: LIST
30915: PUSH
30916: LD_INT 1
30918: NEG
30919: PUSH
30920: LD_INT 1
30922: PUSH
30923: EMPTY
30924: LIST
30925: LIST
30926: PUSH
30927: LD_INT 2
30929: NEG
30930: PUSH
30931: LD_INT 0
30933: PUSH
30934: EMPTY
30935: LIST
30936: LIST
30937: PUSH
30938: LD_INT 2
30940: NEG
30941: PUSH
30942: LD_INT 1
30944: NEG
30945: PUSH
30946: EMPTY
30947: LIST
30948: LIST
30949: PUSH
30950: LD_INT 2
30952: NEG
30953: PUSH
30954: LD_INT 2
30956: NEG
30957: PUSH
30958: EMPTY
30959: LIST
30960: LIST
30961: PUSH
30962: LD_INT 2
30964: NEG
30965: PUSH
30966: LD_INT 3
30968: NEG
30969: PUSH
30970: EMPTY
30971: LIST
30972: LIST
30973: PUSH
30974: LD_INT 2
30976: PUSH
30977: LD_INT 1
30979: NEG
30980: PUSH
30981: EMPTY
30982: LIST
30983: LIST
30984: PUSH
30985: LD_INT 3
30987: PUSH
30988: LD_INT 1
30990: PUSH
30991: EMPTY
30992: LIST
30993: LIST
30994: PUSH
30995: LD_INT 1
30997: PUSH
30998: LD_INT 3
31000: PUSH
31001: EMPTY
31002: LIST
31003: LIST
31004: PUSH
31005: LD_INT 1
31007: NEG
31008: PUSH
31009: LD_INT 2
31011: PUSH
31012: EMPTY
31013: LIST
31014: LIST
31015: PUSH
31016: LD_INT 3
31018: NEG
31019: PUSH
31020: LD_INT 2
31022: NEG
31023: PUSH
31024: EMPTY
31025: LIST
31026: LIST
31027: PUSH
31028: EMPTY
31029: LIST
31030: LIST
31031: LIST
31032: LIST
31033: LIST
31034: LIST
31035: LIST
31036: LIST
31037: LIST
31038: LIST
31039: LIST
31040: LIST
31041: LIST
31042: LIST
31043: LIST
31044: LIST
31045: LIST
31046: LIST
31047: LIST
31048: LIST
31049: LIST
31050: LIST
31051: LIST
31052: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
31053: LD_ADDR_VAR 0 34
31057: PUSH
31058: LD_INT 0
31060: PUSH
31061: LD_INT 0
31063: PUSH
31064: EMPTY
31065: LIST
31066: LIST
31067: PUSH
31068: LD_INT 0
31070: PUSH
31071: LD_INT 1
31073: NEG
31074: PUSH
31075: EMPTY
31076: LIST
31077: LIST
31078: PUSH
31079: LD_INT 1
31081: PUSH
31082: LD_INT 0
31084: PUSH
31085: EMPTY
31086: LIST
31087: LIST
31088: PUSH
31089: LD_INT 1
31091: PUSH
31092: LD_INT 1
31094: PUSH
31095: EMPTY
31096: LIST
31097: LIST
31098: PUSH
31099: LD_INT 0
31101: PUSH
31102: LD_INT 1
31104: PUSH
31105: EMPTY
31106: LIST
31107: LIST
31108: PUSH
31109: LD_INT 1
31111: NEG
31112: PUSH
31113: LD_INT 0
31115: PUSH
31116: EMPTY
31117: LIST
31118: LIST
31119: PUSH
31120: LD_INT 1
31122: NEG
31123: PUSH
31124: LD_INT 1
31126: NEG
31127: PUSH
31128: EMPTY
31129: LIST
31130: LIST
31131: PUSH
31132: LD_INT 1
31134: NEG
31135: PUSH
31136: LD_INT 2
31138: NEG
31139: PUSH
31140: EMPTY
31141: LIST
31142: LIST
31143: PUSH
31144: LD_INT 0
31146: PUSH
31147: LD_INT 2
31149: NEG
31150: PUSH
31151: EMPTY
31152: LIST
31153: LIST
31154: PUSH
31155: LD_INT 1
31157: PUSH
31158: LD_INT 1
31160: NEG
31161: PUSH
31162: EMPTY
31163: LIST
31164: LIST
31165: PUSH
31166: LD_INT 2
31168: PUSH
31169: LD_INT 1
31171: PUSH
31172: EMPTY
31173: LIST
31174: LIST
31175: PUSH
31176: LD_INT 2
31178: PUSH
31179: LD_INT 2
31181: PUSH
31182: EMPTY
31183: LIST
31184: LIST
31185: PUSH
31186: LD_INT 1
31188: PUSH
31189: LD_INT 2
31191: PUSH
31192: EMPTY
31193: LIST
31194: LIST
31195: PUSH
31196: LD_INT 1
31198: NEG
31199: PUSH
31200: LD_INT 1
31202: PUSH
31203: EMPTY
31204: LIST
31205: LIST
31206: PUSH
31207: LD_INT 2
31209: NEG
31210: PUSH
31211: LD_INT 0
31213: PUSH
31214: EMPTY
31215: LIST
31216: LIST
31217: PUSH
31218: LD_INT 2
31220: NEG
31221: PUSH
31222: LD_INT 1
31224: NEG
31225: PUSH
31226: EMPTY
31227: LIST
31228: LIST
31229: PUSH
31230: LD_INT 2
31232: NEG
31233: PUSH
31234: LD_INT 2
31236: NEG
31237: PUSH
31238: EMPTY
31239: LIST
31240: LIST
31241: PUSH
31242: LD_INT 1
31244: NEG
31245: PUSH
31246: LD_INT 3
31248: NEG
31249: PUSH
31250: EMPTY
31251: LIST
31252: LIST
31253: PUSH
31254: LD_INT 1
31256: PUSH
31257: LD_INT 2
31259: NEG
31260: PUSH
31261: EMPTY
31262: LIST
31263: LIST
31264: PUSH
31265: LD_INT 3
31267: PUSH
31268: LD_INT 2
31270: PUSH
31271: EMPTY
31272: LIST
31273: LIST
31274: PUSH
31275: LD_INT 2
31277: PUSH
31278: LD_INT 3
31280: PUSH
31281: EMPTY
31282: LIST
31283: LIST
31284: PUSH
31285: LD_INT 2
31287: NEG
31288: PUSH
31289: LD_INT 1
31291: PUSH
31292: EMPTY
31293: LIST
31294: LIST
31295: PUSH
31296: LD_INT 3
31298: NEG
31299: PUSH
31300: LD_INT 1
31302: NEG
31303: PUSH
31304: EMPTY
31305: LIST
31306: LIST
31307: PUSH
31308: EMPTY
31309: LIST
31310: LIST
31311: LIST
31312: LIST
31313: LIST
31314: LIST
31315: LIST
31316: LIST
31317: LIST
31318: LIST
31319: LIST
31320: LIST
31321: LIST
31322: LIST
31323: LIST
31324: LIST
31325: LIST
31326: LIST
31327: LIST
31328: LIST
31329: LIST
31330: LIST
31331: LIST
31332: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
31333: LD_ADDR_VAR 0 35
31337: PUSH
31338: LD_INT 0
31340: PUSH
31341: LD_INT 0
31343: PUSH
31344: EMPTY
31345: LIST
31346: LIST
31347: PUSH
31348: LD_INT 0
31350: PUSH
31351: LD_INT 1
31353: NEG
31354: PUSH
31355: EMPTY
31356: LIST
31357: LIST
31358: PUSH
31359: LD_INT 1
31361: PUSH
31362: LD_INT 0
31364: PUSH
31365: EMPTY
31366: LIST
31367: LIST
31368: PUSH
31369: LD_INT 1
31371: PUSH
31372: LD_INT 1
31374: PUSH
31375: EMPTY
31376: LIST
31377: LIST
31378: PUSH
31379: LD_INT 0
31381: PUSH
31382: LD_INT 1
31384: PUSH
31385: EMPTY
31386: LIST
31387: LIST
31388: PUSH
31389: LD_INT 1
31391: NEG
31392: PUSH
31393: LD_INT 0
31395: PUSH
31396: EMPTY
31397: LIST
31398: LIST
31399: PUSH
31400: LD_INT 1
31402: NEG
31403: PUSH
31404: LD_INT 1
31406: NEG
31407: PUSH
31408: EMPTY
31409: LIST
31410: LIST
31411: PUSH
31412: LD_INT 2
31414: PUSH
31415: LD_INT 1
31417: PUSH
31418: EMPTY
31419: LIST
31420: LIST
31421: PUSH
31422: LD_INT 2
31424: NEG
31425: PUSH
31426: LD_INT 1
31428: NEG
31429: PUSH
31430: EMPTY
31431: LIST
31432: LIST
31433: PUSH
31434: EMPTY
31435: LIST
31436: LIST
31437: LIST
31438: LIST
31439: LIST
31440: LIST
31441: LIST
31442: LIST
31443: LIST
31444: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
31445: LD_ADDR_VAR 0 36
31449: PUSH
31450: LD_INT 0
31452: PUSH
31453: LD_INT 0
31455: PUSH
31456: EMPTY
31457: LIST
31458: LIST
31459: PUSH
31460: LD_INT 0
31462: PUSH
31463: LD_INT 1
31465: NEG
31466: PUSH
31467: EMPTY
31468: LIST
31469: LIST
31470: PUSH
31471: LD_INT 1
31473: PUSH
31474: LD_INT 0
31476: PUSH
31477: EMPTY
31478: LIST
31479: LIST
31480: PUSH
31481: LD_INT 1
31483: PUSH
31484: LD_INT 1
31486: PUSH
31487: EMPTY
31488: LIST
31489: LIST
31490: PUSH
31491: LD_INT 0
31493: PUSH
31494: LD_INT 1
31496: PUSH
31497: EMPTY
31498: LIST
31499: LIST
31500: PUSH
31501: LD_INT 1
31503: NEG
31504: PUSH
31505: LD_INT 0
31507: PUSH
31508: EMPTY
31509: LIST
31510: LIST
31511: PUSH
31512: LD_INT 1
31514: NEG
31515: PUSH
31516: LD_INT 1
31518: NEG
31519: PUSH
31520: EMPTY
31521: LIST
31522: LIST
31523: PUSH
31524: LD_INT 1
31526: NEG
31527: PUSH
31528: LD_INT 2
31530: NEG
31531: PUSH
31532: EMPTY
31533: LIST
31534: LIST
31535: PUSH
31536: LD_INT 1
31538: PUSH
31539: LD_INT 2
31541: PUSH
31542: EMPTY
31543: LIST
31544: LIST
31545: PUSH
31546: EMPTY
31547: LIST
31548: LIST
31549: LIST
31550: LIST
31551: LIST
31552: LIST
31553: LIST
31554: LIST
31555: LIST
31556: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
31557: LD_ADDR_VAR 0 37
31561: PUSH
31562: LD_INT 0
31564: PUSH
31565: LD_INT 0
31567: PUSH
31568: EMPTY
31569: LIST
31570: LIST
31571: PUSH
31572: LD_INT 0
31574: PUSH
31575: LD_INT 1
31577: NEG
31578: PUSH
31579: EMPTY
31580: LIST
31581: LIST
31582: PUSH
31583: LD_INT 1
31585: PUSH
31586: LD_INT 0
31588: PUSH
31589: EMPTY
31590: LIST
31591: LIST
31592: PUSH
31593: LD_INT 1
31595: PUSH
31596: LD_INT 1
31598: PUSH
31599: EMPTY
31600: LIST
31601: LIST
31602: PUSH
31603: LD_INT 0
31605: PUSH
31606: LD_INT 1
31608: PUSH
31609: EMPTY
31610: LIST
31611: LIST
31612: PUSH
31613: LD_INT 1
31615: NEG
31616: PUSH
31617: LD_INT 0
31619: PUSH
31620: EMPTY
31621: LIST
31622: LIST
31623: PUSH
31624: LD_INT 1
31626: NEG
31627: PUSH
31628: LD_INT 1
31630: NEG
31631: PUSH
31632: EMPTY
31633: LIST
31634: LIST
31635: PUSH
31636: LD_INT 1
31638: PUSH
31639: LD_INT 1
31641: NEG
31642: PUSH
31643: EMPTY
31644: LIST
31645: LIST
31646: PUSH
31647: LD_INT 1
31649: NEG
31650: PUSH
31651: LD_INT 1
31653: PUSH
31654: EMPTY
31655: LIST
31656: LIST
31657: PUSH
31658: EMPTY
31659: LIST
31660: LIST
31661: LIST
31662: LIST
31663: LIST
31664: LIST
31665: LIST
31666: LIST
31667: LIST
31668: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
31669: LD_ADDR_VAR 0 38
31673: PUSH
31674: LD_INT 0
31676: PUSH
31677: LD_INT 0
31679: PUSH
31680: EMPTY
31681: LIST
31682: LIST
31683: PUSH
31684: LD_INT 0
31686: PUSH
31687: LD_INT 1
31689: NEG
31690: PUSH
31691: EMPTY
31692: LIST
31693: LIST
31694: PUSH
31695: LD_INT 1
31697: PUSH
31698: LD_INT 0
31700: PUSH
31701: EMPTY
31702: LIST
31703: LIST
31704: PUSH
31705: LD_INT 1
31707: PUSH
31708: LD_INT 1
31710: PUSH
31711: EMPTY
31712: LIST
31713: LIST
31714: PUSH
31715: LD_INT 0
31717: PUSH
31718: LD_INT 1
31720: PUSH
31721: EMPTY
31722: LIST
31723: LIST
31724: PUSH
31725: LD_INT 1
31727: NEG
31728: PUSH
31729: LD_INT 0
31731: PUSH
31732: EMPTY
31733: LIST
31734: LIST
31735: PUSH
31736: LD_INT 1
31738: NEG
31739: PUSH
31740: LD_INT 1
31742: NEG
31743: PUSH
31744: EMPTY
31745: LIST
31746: LIST
31747: PUSH
31748: LD_INT 2
31750: PUSH
31751: LD_INT 1
31753: PUSH
31754: EMPTY
31755: LIST
31756: LIST
31757: PUSH
31758: LD_INT 2
31760: NEG
31761: PUSH
31762: LD_INT 1
31764: NEG
31765: PUSH
31766: EMPTY
31767: LIST
31768: LIST
31769: PUSH
31770: EMPTY
31771: LIST
31772: LIST
31773: LIST
31774: LIST
31775: LIST
31776: LIST
31777: LIST
31778: LIST
31779: LIST
31780: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
31781: LD_ADDR_VAR 0 39
31785: PUSH
31786: LD_INT 0
31788: PUSH
31789: LD_INT 0
31791: PUSH
31792: EMPTY
31793: LIST
31794: LIST
31795: PUSH
31796: LD_INT 0
31798: PUSH
31799: LD_INT 1
31801: NEG
31802: PUSH
31803: EMPTY
31804: LIST
31805: LIST
31806: PUSH
31807: LD_INT 1
31809: PUSH
31810: LD_INT 0
31812: PUSH
31813: EMPTY
31814: LIST
31815: LIST
31816: PUSH
31817: LD_INT 1
31819: PUSH
31820: LD_INT 1
31822: PUSH
31823: EMPTY
31824: LIST
31825: LIST
31826: PUSH
31827: LD_INT 0
31829: PUSH
31830: LD_INT 1
31832: PUSH
31833: EMPTY
31834: LIST
31835: LIST
31836: PUSH
31837: LD_INT 1
31839: NEG
31840: PUSH
31841: LD_INT 0
31843: PUSH
31844: EMPTY
31845: LIST
31846: LIST
31847: PUSH
31848: LD_INT 1
31850: NEG
31851: PUSH
31852: LD_INT 1
31854: NEG
31855: PUSH
31856: EMPTY
31857: LIST
31858: LIST
31859: PUSH
31860: LD_INT 1
31862: NEG
31863: PUSH
31864: LD_INT 2
31866: NEG
31867: PUSH
31868: EMPTY
31869: LIST
31870: LIST
31871: PUSH
31872: LD_INT 1
31874: PUSH
31875: LD_INT 2
31877: PUSH
31878: EMPTY
31879: LIST
31880: LIST
31881: PUSH
31882: EMPTY
31883: LIST
31884: LIST
31885: LIST
31886: LIST
31887: LIST
31888: LIST
31889: LIST
31890: LIST
31891: LIST
31892: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
31893: LD_ADDR_VAR 0 40
31897: PUSH
31898: LD_INT 0
31900: PUSH
31901: LD_INT 0
31903: PUSH
31904: EMPTY
31905: LIST
31906: LIST
31907: PUSH
31908: LD_INT 0
31910: PUSH
31911: LD_INT 1
31913: NEG
31914: PUSH
31915: EMPTY
31916: LIST
31917: LIST
31918: PUSH
31919: LD_INT 1
31921: PUSH
31922: LD_INT 0
31924: PUSH
31925: EMPTY
31926: LIST
31927: LIST
31928: PUSH
31929: LD_INT 1
31931: PUSH
31932: LD_INT 1
31934: PUSH
31935: EMPTY
31936: LIST
31937: LIST
31938: PUSH
31939: LD_INT 0
31941: PUSH
31942: LD_INT 1
31944: PUSH
31945: EMPTY
31946: LIST
31947: LIST
31948: PUSH
31949: LD_INT 1
31951: NEG
31952: PUSH
31953: LD_INT 0
31955: PUSH
31956: EMPTY
31957: LIST
31958: LIST
31959: PUSH
31960: LD_INT 1
31962: NEG
31963: PUSH
31964: LD_INT 1
31966: NEG
31967: PUSH
31968: EMPTY
31969: LIST
31970: LIST
31971: PUSH
31972: LD_INT 1
31974: PUSH
31975: LD_INT 1
31977: NEG
31978: PUSH
31979: EMPTY
31980: LIST
31981: LIST
31982: PUSH
31983: LD_INT 1
31985: NEG
31986: PUSH
31987: LD_INT 1
31989: PUSH
31990: EMPTY
31991: LIST
31992: LIST
31993: PUSH
31994: EMPTY
31995: LIST
31996: LIST
31997: LIST
31998: LIST
31999: LIST
32000: LIST
32001: LIST
32002: LIST
32003: LIST
32004: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32005: LD_ADDR_VAR 0 41
32009: PUSH
32010: LD_INT 0
32012: PUSH
32013: LD_INT 0
32015: PUSH
32016: EMPTY
32017: LIST
32018: LIST
32019: PUSH
32020: LD_INT 0
32022: PUSH
32023: LD_INT 1
32025: NEG
32026: PUSH
32027: EMPTY
32028: LIST
32029: LIST
32030: PUSH
32031: LD_INT 1
32033: PUSH
32034: LD_INT 0
32036: PUSH
32037: EMPTY
32038: LIST
32039: LIST
32040: PUSH
32041: LD_INT 1
32043: PUSH
32044: LD_INT 1
32046: PUSH
32047: EMPTY
32048: LIST
32049: LIST
32050: PUSH
32051: LD_INT 0
32053: PUSH
32054: LD_INT 1
32056: PUSH
32057: EMPTY
32058: LIST
32059: LIST
32060: PUSH
32061: LD_INT 1
32063: NEG
32064: PUSH
32065: LD_INT 0
32067: PUSH
32068: EMPTY
32069: LIST
32070: LIST
32071: PUSH
32072: LD_INT 1
32074: NEG
32075: PUSH
32076: LD_INT 1
32078: NEG
32079: PUSH
32080: EMPTY
32081: LIST
32082: LIST
32083: PUSH
32084: LD_INT 1
32086: NEG
32087: PUSH
32088: LD_INT 2
32090: NEG
32091: PUSH
32092: EMPTY
32093: LIST
32094: LIST
32095: PUSH
32096: LD_INT 1
32098: PUSH
32099: LD_INT 1
32101: NEG
32102: PUSH
32103: EMPTY
32104: LIST
32105: LIST
32106: PUSH
32107: LD_INT 2
32109: PUSH
32110: LD_INT 0
32112: PUSH
32113: EMPTY
32114: LIST
32115: LIST
32116: PUSH
32117: LD_INT 2
32119: PUSH
32120: LD_INT 1
32122: PUSH
32123: EMPTY
32124: LIST
32125: LIST
32126: PUSH
32127: LD_INT 2
32129: PUSH
32130: LD_INT 2
32132: PUSH
32133: EMPTY
32134: LIST
32135: LIST
32136: PUSH
32137: LD_INT 1
32139: PUSH
32140: LD_INT 2
32142: PUSH
32143: EMPTY
32144: LIST
32145: LIST
32146: PUSH
32147: LD_INT 1
32149: NEG
32150: PUSH
32151: LD_INT 1
32153: PUSH
32154: EMPTY
32155: LIST
32156: LIST
32157: PUSH
32158: LD_INT 2
32160: NEG
32161: PUSH
32162: LD_INT 0
32164: PUSH
32165: EMPTY
32166: LIST
32167: LIST
32168: PUSH
32169: LD_INT 2
32171: NEG
32172: PUSH
32173: LD_INT 1
32175: NEG
32176: PUSH
32177: EMPTY
32178: LIST
32179: LIST
32180: PUSH
32181: LD_INT 2
32183: NEG
32184: PUSH
32185: LD_INT 2
32187: NEG
32188: PUSH
32189: EMPTY
32190: LIST
32191: LIST
32192: PUSH
32193: LD_INT 2
32195: NEG
32196: PUSH
32197: LD_INT 3
32199: NEG
32200: PUSH
32201: EMPTY
32202: LIST
32203: LIST
32204: PUSH
32205: LD_INT 2
32207: PUSH
32208: LD_INT 1
32210: NEG
32211: PUSH
32212: EMPTY
32213: LIST
32214: LIST
32215: PUSH
32216: LD_INT 3
32218: PUSH
32219: LD_INT 0
32221: PUSH
32222: EMPTY
32223: LIST
32224: LIST
32225: PUSH
32226: LD_INT 3
32228: PUSH
32229: LD_INT 1
32231: PUSH
32232: EMPTY
32233: LIST
32234: LIST
32235: PUSH
32236: LD_INT 3
32238: PUSH
32239: LD_INT 2
32241: PUSH
32242: EMPTY
32243: LIST
32244: LIST
32245: PUSH
32246: LD_INT 3
32248: PUSH
32249: LD_INT 3
32251: PUSH
32252: EMPTY
32253: LIST
32254: LIST
32255: PUSH
32256: LD_INT 2
32258: PUSH
32259: LD_INT 3
32261: PUSH
32262: EMPTY
32263: LIST
32264: LIST
32265: PUSH
32266: LD_INT 2
32268: NEG
32269: PUSH
32270: LD_INT 1
32272: PUSH
32273: EMPTY
32274: LIST
32275: LIST
32276: PUSH
32277: LD_INT 3
32279: NEG
32280: PUSH
32281: LD_INT 0
32283: PUSH
32284: EMPTY
32285: LIST
32286: LIST
32287: PUSH
32288: LD_INT 3
32290: NEG
32291: PUSH
32292: LD_INT 1
32294: NEG
32295: PUSH
32296: EMPTY
32297: LIST
32298: LIST
32299: PUSH
32300: LD_INT 3
32302: NEG
32303: PUSH
32304: LD_INT 2
32306: NEG
32307: PUSH
32308: EMPTY
32309: LIST
32310: LIST
32311: PUSH
32312: LD_INT 3
32314: NEG
32315: PUSH
32316: LD_INT 3
32318: NEG
32319: PUSH
32320: EMPTY
32321: LIST
32322: LIST
32323: PUSH
32324: EMPTY
32325: LIST
32326: LIST
32327: LIST
32328: LIST
32329: LIST
32330: LIST
32331: LIST
32332: LIST
32333: LIST
32334: LIST
32335: LIST
32336: LIST
32337: LIST
32338: LIST
32339: LIST
32340: LIST
32341: LIST
32342: LIST
32343: LIST
32344: LIST
32345: LIST
32346: LIST
32347: LIST
32348: LIST
32349: LIST
32350: LIST
32351: LIST
32352: LIST
32353: LIST
32354: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32355: LD_ADDR_VAR 0 42
32359: PUSH
32360: LD_INT 0
32362: PUSH
32363: LD_INT 0
32365: PUSH
32366: EMPTY
32367: LIST
32368: LIST
32369: PUSH
32370: LD_INT 0
32372: PUSH
32373: LD_INT 1
32375: NEG
32376: PUSH
32377: EMPTY
32378: LIST
32379: LIST
32380: PUSH
32381: LD_INT 1
32383: PUSH
32384: LD_INT 0
32386: PUSH
32387: EMPTY
32388: LIST
32389: LIST
32390: PUSH
32391: LD_INT 1
32393: PUSH
32394: LD_INT 1
32396: PUSH
32397: EMPTY
32398: LIST
32399: LIST
32400: PUSH
32401: LD_INT 0
32403: PUSH
32404: LD_INT 1
32406: PUSH
32407: EMPTY
32408: LIST
32409: LIST
32410: PUSH
32411: LD_INT 1
32413: NEG
32414: PUSH
32415: LD_INT 0
32417: PUSH
32418: EMPTY
32419: LIST
32420: LIST
32421: PUSH
32422: LD_INT 1
32424: NEG
32425: PUSH
32426: LD_INT 1
32428: NEG
32429: PUSH
32430: EMPTY
32431: LIST
32432: LIST
32433: PUSH
32434: LD_INT 1
32436: NEG
32437: PUSH
32438: LD_INT 2
32440: NEG
32441: PUSH
32442: EMPTY
32443: LIST
32444: LIST
32445: PUSH
32446: LD_INT 0
32448: PUSH
32449: LD_INT 2
32451: NEG
32452: PUSH
32453: EMPTY
32454: LIST
32455: LIST
32456: PUSH
32457: LD_INT 1
32459: PUSH
32460: LD_INT 1
32462: NEG
32463: PUSH
32464: EMPTY
32465: LIST
32466: LIST
32467: PUSH
32468: LD_INT 2
32470: PUSH
32471: LD_INT 1
32473: PUSH
32474: EMPTY
32475: LIST
32476: LIST
32477: PUSH
32478: LD_INT 2
32480: PUSH
32481: LD_INT 2
32483: PUSH
32484: EMPTY
32485: LIST
32486: LIST
32487: PUSH
32488: LD_INT 1
32490: PUSH
32491: LD_INT 2
32493: PUSH
32494: EMPTY
32495: LIST
32496: LIST
32497: PUSH
32498: LD_INT 0
32500: PUSH
32501: LD_INT 2
32503: PUSH
32504: EMPTY
32505: LIST
32506: LIST
32507: PUSH
32508: LD_INT 1
32510: NEG
32511: PUSH
32512: LD_INT 1
32514: PUSH
32515: EMPTY
32516: LIST
32517: LIST
32518: PUSH
32519: LD_INT 2
32521: NEG
32522: PUSH
32523: LD_INT 1
32525: NEG
32526: PUSH
32527: EMPTY
32528: LIST
32529: LIST
32530: PUSH
32531: LD_INT 2
32533: NEG
32534: PUSH
32535: LD_INT 2
32537: NEG
32538: PUSH
32539: EMPTY
32540: LIST
32541: LIST
32542: PUSH
32543: LD_INT 2
32545: NEG
32546: PUSH
32547: LD_INT 3
32549: NEG
32550: PUSH
32551: EMPTY
32552: LIST
32553: LIST
32554: PUSH
32555: LD_INT 1
32557: NEG
32558: PUSH
32559: LD_INT 3
32561: NEG
32562: PUSH
32563: EMPTY
32564: LIST
32565: LIST
32566: PUSH
32567: LD_INT 0
32569: PUSH
32570: LD_INT 3
32572: NEG
32573: PUSH
32574: EMPTY
32575: LIST
32576: LIST
32577: PUSH
32578: LD_INT 1
32580: PUSH
32581: LD_INT 2
32583: NEG
32584: PUSH
32585: EMPTY
32586: LIST
32587: LIST
32588: PUSH
32589: LD_INT 3
32591: PUSH
32592: LD_INT 2
32594: PUSH
32595: EMPTY
32596: LIST
32597: LIST
32598: PUSH
32599: LD_INT 3
32601: PUSH
32602: LD_INT 3
32604: PUSH
32605: EMPTY
32606: LIST
32607: LIST
32608: PUSH
32609: LD_INT 2
32611: PUSH
32612: LD_INT 3
32614: PUSH
32615: EMPTY
32616: LIST
32617: LIST
32618: PUSH
32619: LD_INT 1
32621: PUSH
32622: LD_INT 3
32624: PUSH
32625: EMPTY
32626: LIST
32627: LIST
32628: PUSH
32629: LD_INT 0
32631: PUSH
32632: LD_INT 3
32634: PUSH
32635: EMPTY
32636: LIST
32637: LIST
32638: PUSH
32639: LD_INT 1
32641: NEG
32642: PUSH
32643: LD_INT 2
32645: PUSH
32646: EMPTY
32647: LIST
32648: LIST
32649: PUSH
32650: LD_INT 3
32652: NEG
32653: PUSH
32654: LD_INT 2
32656: NEG
32657: PUSH
32658: EMPTY
32659: LIST
32660: LIST
32661: PUSH
32662: LD_INT 3
32664: NEG
32665: PUSH
32666: LD_INT 3
32668: NEG
32669: PUSH
32670: EMPTY
32671: LIST
32672: LIST
32673: PUSH
32674: EMPTY
32675: LIST
32676: LIST
32677: LIST
32678: LIST
32679: LIST
32680: LIST
32681: LIST
32682: LIST
32683: LIST
32684: LIST
32685: LIST
32686: LIST
32687: LIST
32688: LIST
32689: LIST
32690: LIST
32691: LIST
32692: LIST
32693: LIST
32694: LIST
32695: LIST
32696: LIST
32697: LIST
32698: LIST
32699: LIST
32700: LIST
32701: LIST
32702: LIST
32703: LIST
32704: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
32705: LD_ADDR_VAR 0 43
32709: PUSH
32710: LD_INT 0
32712: PUSH
32713: LD_INT 0
32715: PUSH
32716: EMPTY
32717: LIST
32718: LIST
32719: PUSH
32720: LD_INT 0
32722: PUSH
32723: LD_INT 1
32725: NEG
32726: PUSH
32727: EMPTY
32728: LIST
32729: LIST
32730: PUSH
32731: LD_INT 1
32733: PUSH
32734: LD_INT 0
32736: PUSH
32737: EMPTY
32738: LIST
32739: LIST
32740: PUSH
32741: LD_INT 1
32743: PUSH
32744: LD_INT 1
32746: PUSH
32747: EMPTY
32748: LIST
32749: LIST
32750: PUSH
32751: LD_INT 0
32753: PUSH
32754: LD_INT 1
32756: PUSH
32757: EMPTY
32758: LIST
32759: LIST
32760: PUSH
32761: LD_INT 1
32763: NEG
32764: PUSH
32765: LD_INT 0
32767: PUSH
32768: EMPTY
32769: LIST
32770: LIST
32771: PUSH
32772: LD_INT 1
32774: NEG
32775: PUSH
32776: LD_INT 1
32778: NEG
32779: PUSH
32780: EMPTY
32781: LIST
32782: LIST
32783: PUSH
32784: LD_INT 1
32786: NEG
32787: PUSH
32788: LD_INT 2
32790: NEG
32791: PUSH
32792: EMPTY
32793: LIST
32794: LIST
32795: PUSH
32796: LD_INT 0
32798: PUSH
32799: LD_INT 2
32801: NEG
32802: PUSH
32803: EMPTY
32804: LIST
32805: LIST
32806: PUSH
32807: LD_INT 1
32809: PUSH
32810: LD_INT 1
32812: NEG
32813: PUSH
32814: EMPTY
32815: LIST
32816: LIST
32817: PUSH
32818: LD_INT 2
32820: PUSH
32821: LD_INT 0
32823: PUSH
32824: EMPTY
32825: LIST
32826: LIST
32827: PUSH
32828: LD_INT 2
32830: PUSH
32831: LD_INT 1
32833: PUSH
32834: EMPTY
32835: LIST
32836: LIST
32837: PUSH
32838: LD_INT 1
32840: PUSH
32841: LD_INT 2
32843: PUSH
32844: EMPTY
32845: LIST
32846: LIST
32847: PUSH
32848: LD_INT 0
32850: PUSH
32851: LD_INT 2
32853: PUSH
32854: EMPTY
32855: LIST
32856: LIST
32857: PUSH
32858: LD_INT 1
32860: NEG
32861: PUSH
32862: LD_INT 1
32864: PUSH
32865: EMPTY
32866: LIST
32867: LIST
32868: PUSH
32869: LD_INT 2
32871: NEG
32872: PUSH
32873: LD_INT 0
32875: PUSH
32876: EMPTY
32877: LIST
32878: LIST
32879: PUSH
32880: LD_INT 2
32882: NEG
32883: PUSH
32884: LD_INT 1
32886: NEG
32887: PUSH
32888: EMPTY
32889: LIST
32890: LIST
32891: PUSH
32892: LD_INT 1
32894: NEG
32895: PUSH
32896: LD_INT 3
32898: NEG
32899: PUSH
32900: EMPTY
32901: LIST
32902: LIST
32903: PUSH
32904: LD_INT 0
32906: PUSH
32907: LD_INT 3
32909: NEG
32910: PUSH
32911: EMPTY
32912: LIST
32913: LIST
32914: PUSH
32915: LD_INT 1
32917: PUSH
32918: LD_INT 2
32920: NEG
32921: PUSH
32922: EMPTY
32923: LIST
32924: LIST
32925: PUSH
32926: LD_INT 2
32928: PUSH
32929: LD_INT 1
32931: NEG
32932: PUSH
32933: EMPTY
32934: LIST
32935: LIST
32936: PUSH
32937: LD_INT 3
32939: PUSH
32940: LD_INT 0
32942: PUSH
32943: EMPTY
32944: LIST
32945: LIST
32946: PUSH
32947: LD_INT 3
32949: PUSH
32950: LD_INT 1
32952: PUSH
32953: EMPTY
32954: LIST
32955: LIST
32956: PUSH
32957: LD_INT 1
32959: PUSH
32960: LD_INT 3
32962: PUSH
32963: EMPTY
32964: LIST
32965: LIST
32966: PUSH
32967: LD_INT 0
32969: PUSH
32970: LD_INT 3
32972: PUSH
32973: EMPTY
32974: LIST
32975: LIST
32976: PUSH
32977: LD_INT 1
32979: NEG
32980: PUSH
32981: LD_INT 2
32983: PUSH
32984: EMPTY
32985: LIST
32986: LIST
32987: PUSH
32988: LD_INT 2
32990: NEG
32991: PUSH
32992: LD_INT 1
32994: PUSH
32995: EMPTY
32996: LIST
32997: LIST
32998: PUSH
32999: LD_INT 3
33001: NEG
33002: PUSH
33003: LD_INT 0
33005: PUSH
33006: EMPTY
33007: LIST
33008: LIST
33009: PUSH
33010: LD_INT 3
33012: NEG
33013: PUSH
33014: LD_INT 1
33016: NEG
33017: PUSH
33018: EMPTY
33019: LIST
33020: LIST
33021: PUSH
33022: EMPTY
33023: LIST
33024: LIST
33025: LIST
33026: LIST
33027: LIST
33028: LIST
33029: LIST
33030: LIST
33031: LIST
33032: LIST
33033: LIST
33034: LIST
33035: LIST
33036: LIST
33037: LIST
33038: LIST
33039: LIST
33040: LIST
33041: LIST
33042: LIST
33043: LIST
33044: LIST
33045: LIST
33046: LIST
33047: LIST
33048: LIST
33049: LIST
33050: LIST
33051: LIST
33052: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33053: LD_ADDR_VAR 0 44
33057: PUSH
33058: LD_INT 0
33060: PUSH
33061: LD_INT 0
33063: PUSH
33064: EMPTY
33065: LIST
33066: LIST
33067: PUSH
33068: LD_INT 0
33070: PUSH
33071: LD_INT 1
33073: NEG
33074: PUSH
33075: EMPTY
33076: LIST
33077: LIST
33078: PUSH
33079: LD_INT 1
33081: PUSH
33082: LD_INT 0
33084: PUSH
33085: EMPTY
33086: LIST
33087: LIST
33088: PUSH
33089: LD_INT 1
33091: PUSH
33092: LD_INT 1
33094: PUSH
33095: EMPTY
33096: LIST
33097: LIST
33098: PUSH
33099: LD_INT 0
33101: PUSH
33102: LD_INT 1
33104: PUSH
33105: EMPTY
33106: LIST
33107: LIST
33108: PUSH
33109: LD_INT 1
33111: NEG
33112: PUSH
33113: LD_INT 0
33115: PUSH
33116: EMPTY
33117: LIST
33118: LIST
33119: PUSH
33120: LD_INT 1
33122: NEG
33123: PUSH
33124: LD_INT 1
33126: NEG
33127: PUSH
33128: EMPTY
33129: LIST
33130: LIST
33131: PUSH
33132: LD_INT 1
33134: NEG
33135: PUSH
33136: LD_INT 2
33138: NEG
33139: PUSH
33140: EMPTY
33141: LIST
33142: LIST
33143: PUSH
33144: LD_INT 1
33146: PUSH
33147: LD_INT 1
33149: NEG
33150: PUSH
33151: EMPTY
33152: LIST
33153: LIST
33154: PUSH
33155: LD_INT 2
33157: PUSH
33158: LD_INT 0
33160: PUSH
33161: EMPTY
33162: LIST
33163: LIST
33164: PUSH
33165: LD_INT 2
33167: PUSH
33168: LD_INT 1
33170: PUSH
33171: EMPTY
33172: LIST
33173: LIST
33174: PUSH
33175: LD_INT 2
33177: PUSH
33178: LD_INT 2
33180: PUSH
33181: EMPTY
33182: LIST
33183: LIST
33184: PUSH
33185: LD_INT 1
33187: PUSH
33188: LD_INT 2
33190: PUSH
33191: EMPTY
33192: LIST
33193: LIST
33194: PUSH
33195: LD_INT 1
33197: NEG
33198: PUSH
33199: LD_INT 1
33201: PUSH
33202: EMPTY
33203: LIST
33204: LIST
33205: PUSH
33206: LD_INT 2
33208: NEG
33209: PUSH
33210: LD_INT 0
33212: PUSH
33213: EMPTY
33214: LIST
33215: LIST
33216: PUSH
33217: LD_INT 2
33219: NEG
33220: PUSH
33221: LD_INT 1
33223: NEG
33224: PUSH
33225: EMPTY
33226: LIST
33227: LIST
33228: PUSH
33229: LD_INT 2
33231: NEG
33232: PUSH
33233: LD_INT 2
33235: NEG
33236: PUSH
33237: EMPTY
33238: LIST
33239: LIST
33240: PUSH
33241: LD_INT 2
33243: NEG
33244: PUSH
33245: LD_INT 3
33247: NEG
33248: PUSH
33249: EMPTY
33250: LIST
33251: LIST
33252: PUSH
33253: LD_INT 2
33255: PUSH
33256: LD_INT 1
33258: NEG
33259: PUSH
33260: EMPTY
33261: LIST
33262: LIST
33263: PUSH
33264: LD_INT 3
33266: PUSH
33267: LD_INT 0
33269: PUSH
33270: EMPTY
33271: LIST
33272: LIST
33273: PUSH
33274: LD_INT 3
33276: PUSH
33277: LD_INT 1
33279: PUSH
33280: EMPTY
33281: LIST
33282: LIST
33283: PUSH
33284: LD_INT 3
33286: PUSH
33287: LD_INT 2
33289: PUSH
33290: EMPTY
33291: LIST
33292: LIST
33293: PUSH
33294: LD_INT 3
33296: PUSH
33297: LD_INT 3
33299: PUSH
33300: EMPTY
33301: LIST
33302: LIST
33303: PUSH
33304: LD_INT 2
33306: PUSH
33307: LD_INT 3
33309: PUSH
33310: EMPTY
33311: LIST
33312: LIST
33313: PUSH
33314: LD_INT 2
33316: NEG
33317: PUSH
33318: LD_INT 1
33320: PUSH
33321: EMPTY
33322: LIST
33323: LIST
33324: PUSH
33325: LD_INT 3
33327: NEG
33328: PUSH
33329: LD_INT 0
33331: PUSH
33332: EMPTY
33333: LIST
33334: LIST
33335: PUSH
33336: LD_INT 3
33338: NEG
33339: PUSH
33340: LD_INT 1
33342: NEG
33343: PUSH
33344: EMPTY
33345: LIST
33346: LIST
33347: PUSH
33348: LD_INT 3
33350: NEG
33351: PUSH
33352: LD_INT 2
33354: NEG
33355: PUSH
33356: EMPTY
33357: LIST
33358: LIST
33359: PUSH
33360: LD_INT 3
33362: NEG
33363: PUSH
33364: LD_INT 3
33366: NEG
33367: PUSH
33368: EMPTY
33369: LIST
33370: LIST
33371: PUSH
33372: EMPTY
33373: LIST
33374: LIST
33375: LIST
33376: LIST
33377: LIST
33378: LIST
33379: LIST
33380: LIST
33381: LIST
33382: LIST
33383: LIST
33384: LIST
33385: LIST
33386: LIST
33387: LIST
33388: LIST
33389: LIST
33390: LIST
33391: LIST
33392: LIST
33393: LIST
33394: LIST
33395: LIST
33396: LIST
33397: LIST
33398: LIST
33399: LIST
33400: LIST
33401: LIST
33402: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33403: LD_ADDR_VAR 0 45
33407: PUSH
33408: LD_INT 0
33410: PUSH
33411: LD_INT 0
33413: PUSH
33414: EMPTY
33415: LIST
33416: LIST
33417: PUSH
33418: LD_INT 0
33420: PUSH
33421: LD_INT 1
33423: NEG
33424: PUSH
33425: EMPTY
33426: LIST
33427: LIST
33428: PUSH
33429: LD_INT 1
33431: PUSH
33432: LD_INT 0
33434: PUSH
33435: EMPTY
33436: LIST
33437: LIST
33438: PUSH
33439: LD_INT 1
33441: PUSH
33442: LD_INT 1
33444: PUSH
33445: EMPTY
33446: LIST
33447: LIST
33448: PUSH
33449: LD_INT 0
33451: PUSH
33452: LD_INT 1
33454: PUSH
33455: EMPTY
33456: LIST
33457: LIST
33458: PUSH
33459: LD_INT 1
33461: NEG
33462: PUSH
33463: LD_INT 0
33465: PUSH
33466: EMPTY
33467: LIST
33468: LIST
33469: PUSH
33470: LD_INT 1
33472: NEG
33473: PUSH
33474: LD_INT 1
33476: NEG
33477: PUSH
33478: EMPTY
33479: LIST
33480: LIST
33481: PUSH
33482: LD_INT 1
33484: NEG
33485: PUSH
33486: LD_INT 2
33488: NEG
33489: PUSH
33490: EMPTY
33491: LIST
33492: LIST
33493: PUSH
33494: LD_INT 0
33496: PUSH
33497: LD_INT 2
33499: NEG
33500: PUSH
33501: EMPTY
33502: LIST
33503: LIST
33504: PUSH
33505: LD_INT 1
33507: PUSH
33508: LD_INT 1
33510: NEG
33511: PUSH
33512: EMPTY
33513: LIST
33514: LIST
33515: PUSH
33516: LD_INT 2
33518: PUSH
33519: LD_INT 1
33521: PUSH
33522: EMPTY
33523: LIST
33524: LIST
33525: PUSH
33526: LD_INT 2
33528: PUSH
33529: LD_INT 2
33531: PUSH
33532: EMPTY
33533: LIST
33534: LIST
33535: PUSH
33536: LD_INT 1
33538: PUSH
33539: LD_INT 2
33541: PUSH
33542: EMPTY
33543: LIST
33544: LIST
33545: PUSH
33546: LD_INT 0
33548: PUSH
33549: LD_INT 2
33551: PUSH
33552: EMPTY
33553: LIST
33554: LIST
33555: PUSH
33556: LD_INT 1
33558: NEG
33559: PUSH
33560: LD_INT 1
33562: PUSH
33563: EMPTY
33564: LIST
33565: LIST
33566: PUSH
33567: LD_INT 2
33569: NEG
33570: PUSH
33571: LD_INT 1
33573: NEG
33574: PUSH
33575: EMPTY
33576: LIST
33577: LIST
33578: PUSH
33579: LD_INT 2
33581: NEG
33582: PUSH
33583: LD_INT 2
33585: NEG
33586: PUSH
33587: EMPTY
33588: LIST
33589: LIST
33590: PUSH
33591: LD_INT 2
33593: NEG
33594: PUSH
33595: LD_INT 3
33597: NEG
33598: PUSH
33599: EMPTY
33600: LIST
33601: LIST
33602: PUSH
33603: LD_INT 1
33605: NEG
33606: PUSH
33607: LD_INT 3
33609: NEG
33610: PUSH
33611: EMPTY
33612: LIST
33613: LIST
33614: PUSH
33615: LD_INT 0
33617: PUSH
33618: LD_INT 3
33620: NEG
33621: PUSH
33622: EMPTY
33623: LIST
33624: LIST
33625: PUSH
33626: LD_INT 1
33628: PUSH
33629: LD_INT 2
33631: NEG
33632: PUSH
33633: EMPTY
33634: LIST
33635: LIST
33636: PUSH
33637: LD_INT 3
33639: PUSH
33640: LD_INT 2
33642: PUSH
33643: EMPTY
33644: LIST
33645: LIST
33646: PUSH
33647: LD_INT 3
33649: PUSH
33650: LD_INT 3
33652: PUSH
33653: EMPTY
33654: LIST
33655: LIST
33656: PUSH
33657: LD_INT 2
33659: PUSH
33660: LD_INT 3
33662: PUSH
33663: EMPTY
33664: LIST
33665: LIST
33666: PUSH
33667: LD_INT 1
33669: PUSH
33670: LD_INT 3
33672: PUSH
33673: EMPTY
33674: LIST
33675: LIST
33676: PUSH
33677: LD_INT 0
33679: PUSH
33680: LD_INT 3
33682: PUSH
33683: EMPTY
33684: LIST
33685: LIST
33686: PUSH
33687: LD_INT 1
33689: NEG
33690: PUSH
33691: LD_INT 2
33693: PUSH
33694: EMPTY
33695: LIST
33696: LIST
33697: PUSH
33698: LD_INT 3
33700: NEG
33701: PUSH
33702: LD_INT 2
33704: NEG
33705: PUSH
33706: EMPTY
33707: LIST
33708: LIST
33709: PUSH
33710: LD_INT 3
33712: NEG
33713: PUSH
33714: LD_INT 3
33716: NEG
33717: PUSH
33718: EMPTY
33719: LIST
33720: LIST
33721: PUSH
33722: EMPTY
33723: LIST
33724: LIST
33725: LIST
33726: LIST
33727: LIST
33728: LIST
33729: LIST
33730: LIST
33731: LIST
33732: LIST
33733: LIST
33734: LIST
33735: LIST
33736: LIST
33737: LIST
33738: LIST
33739: LIST
33740: LIST
33741: LIST
33742: LIST
33743: LIST
33744: LIST
33745: LIST
33746: LIST
33747: LIST
33748: LIST
33749: LIST
33750: LIST
33751: LIST
33752: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
33753: LD_ADDR_VAR 0 46
33757: PUSH
33758: LD_INT 0
33760: PUSH
33761: LD_INT 0
33763: PUSH
33764: EMPTY
33765: LIST
33766: LIST
33767: PUSH
33768: LD_INT 0
33770: PUSH
33771: LD_INT 1
33773: NEG
33774: PUSH
33775: EMPTY
33776: LIST
33777: LIST
33778: PUSH
33779: LD_INT 1
33781: PUSH
33782: LD_INT 0
33784: PUSH
33785: EMPTY
33786: LIST
33787: LIST
33788: PUSH
33789: LD_INT 1
33791: PUSH
33792: LD_INT 1
33794: PUSH
33795: EMPTY
33796: LIST
33797: LIST
33798: PUSH
33799: LD_INT 0
33801: PUSH
33802: LD_INT 1
33804: PUSH
33805: EMPTY
33806: LIST
33807: LIST
33808: PUSH
33809: LD_INT 1
33811: NEG
33812: PUSH
33813: LD_INT 0
33815: PUSH
33816: EMPTY
33817: LIST
33818: LIST
33819: PUSH
33820: LD_INT 1
33822: NEG
33823: PUSH
33824: LD_INT 1
33826: NEG
33827: PUSH
33828: EMPTY
33829: LIST
33830: LIST
33831: PUSH
33832: LD_INT 1
33834: NEG
33835: PUSH
33836: LD_INT 2
33838: NEG
33839: PUSH
33840: EMPTY
33841: LIST
33842: LIST
33843: PUSH
33844: LD_INT 0
33846: PUSH
33847: LD_INT 2
33849: NEG
33850: PUSH
33851: EMPTY
33852: LIST
33853: LIST
33854: PUSH
33855: LD_INT 1
33857: PUSH
33858: LD_INT 1
33860: NEG
33861: PUSH
33862: EMPTY
33863: LIST
33864: LIST
33865: PUSH
33866: LD_INT 2
33868: PUSH
33869: LD_INT 0
33871: PUSH
33872: EMPTY
33873: LIST
33874: LIST
33875: PUSH
33876: LD_INT 2
33878: PUSH
33879: LD_INT 1
33881: PUSH
33882: EMPTY
33883: LIST
33884: LIST
33885: PUSH
33886: LD_INT 1
33888: PUSH
33889: LD_INT 2
33891: PUSH
33892: EMPTY
33893: LIST
33894: LIST
33895: PUSH
33896: LD_INT 0
33898: PUSH
33899: LD_INT 2
33901: PUSH
33902: EMPTY
33903: LIST
33904: LIST
33905: PUSH
33906: LD_INT 1
33908: NEG
33909: PUSH
33910: LD_INT 1
33912: PUSH
33913: EMPTY
33914: LIST
33915: LIST
33916: PUSH
33917: LD_INT 2
33919: NEG
33920: PUSH
33921: LD_INT 0
33923: PUSH
33924: EMPTY
33925: LIST
33926: LIST
33927: PUSH
33928: LD_INT 2
33930: NEG
33931: PUSH
33932: LD_INT 1
33934: NEG
33935: PUSH
33936: EMPTY
33937: LIST
33938: LIST
33939: PUSH
33940: LD_INT 1
33942: NEG
33943: PUSH
33944: LD_INT 3
33946: NEG
33947: PUSH
33948: EMPTY
33949: LIST
33950: LIST
33951: PUSH
33952: LD_INT 0
33954: PUSH
33955: LD_INT 3
33957: NEG
33958: PUSH
33959: EMPTY
33960: LIST
33961: LIST
33962: PUSH
33963: LD_INT 1
33965: PUSH
33966: LD_INT 2
33968: NEG
33969: PUSH
33970: EMPTY
33971: LIST
33972: LIST
33973: PUSH
33974: LD_INT 2
33976: PUSH
33977: LD_INT 1
33979: NEG
33980: PUSH
33981: EMPTY
33982: LIST
33983: LIST
33984: PUSH
33985: LD_INT 3
33987: PUSH
33988: LD_INT 0
33990: PUSH
33991: EMPTY
33992: LIST
33993: LIST
33994: PUSH
33995: LD_INT 3
33997: PUSH
33998: LD_INT 1
34000: PUSH
34001: EMPTY
34002: LIST
34003: LIST
34004: PUSH
34005: LD_INT 1
34007: PUSH
34008: LD_INT 3
34010: PUSH
34011: EMPTY
34012: LIST
34013: LIST
34014: PUSH
34015: LD_INT 0
34017: PUSH
34018: LD_INT 3
34020: PUSH
34021: EMPTY
34022: LIST
34023: LIST
34024: PUSH
34025: LD_INT 1
34027: NEG
34028: PUSH
34029: LD_INT 2
34031: PUSH
34032: EMPTY
34033: LIST
34034: LIST
34035: PUSH
34036: LD_INT 2
34038: NEG
34039: PUSH
34040: LD_INT 1
34042: PUSH
34043: EMPTY
34044: LIST
34045: LIST
34046: PUSH
34047: LD_INT 3
34049: NEG
34050: PUSH
34051: LD_INT 0
34053: PUSH
34054: EMPTY
34055: LIST
34056: LIST
34057: PUSH
34058: LD_INT 3
34060: NEG
34061: PUSH
34062: LD_INT 1
34064: NEG
34065: PUSH
34066: EMPTY
34067: LIST
34068: LIST
34069: PUSH
34070: EMPTY
34071: LIST
34072: LIST
34073: LIST
34074: LIST
34075: LIST
34076: LIST
34077: LIST
34078: LIST
34079: LIST
34080: LIST
34081: LIST
34082: LIST
34083: LIST
34084: LIST
34085: LIST
34086: LIST
34087: LIST
34088: LIST
34089: LIST
34090: LIST
34091: LIST
34092: LIST
34093: LIST
34094: LIST
34095: LIST
34096: LIST
34097: LIST
34098: LIST
34099: LIST
34100: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34101: LD_ADDR_VAR 0 47
34105: PUSH
34106: LD_INT 0
34108: PUSH
34109: LD_INT 0
34111: PUSH
34112: EMPTY
34113: LIST
34114: LIST
34115: PUSH
34116: LD_INT 0
34118: PUSH
34119: LD_INT 1
34121: NEG
34122: PUSH
34123: EMPTY
34124: LIST
34125: LIST
34126: PUSH
34127: LD_INT 1
34129: PUSH
34130: LD_INT 0
34132: PUSH
34133: EMPTY
34134: LIST
34135: LIST
34136: PUSH
34137: LD_INT 1
34139: PUSH
34140: LD_INT 1
34142: PUSH
34143: EMPTY
34144: LIST
34145: LIST
34146: PUSH
34147: LD_INT 0
34149: PUSH
34150: LD_INT 1
34152: PUSH
34153: EMPTY
34154: LIST
34155: LIST
34156: PUSH
34157: LD_INT 1
34159: NEG
34160: PUSH
34161: LD_INT 0
34163: PUSH
34164: EMPTY
34165: LIST
34166: LIST
34167: PUSH
34168: LD_INT 1
34170: NEG
34171: PUSH
34172: LD_INT 1
34174: NEG
34175: PUSH
34176: EMPTY
34177: LIST
34178: LIST
34179: PUSH
34180: LD_INT 1
34182: NEG
34183: PUSH
34184: LD_INT 2
34186: NEG
34187: PUSH
34188: EMPTY
34189: LIST
34190: LIST
34191: PUSH
34192: LD_INT 0
34194: PUSH
34195: LD_INT 2
34197: NEG
34198: PUSH
34199: EMPTY
34200: LIST
34201: LIST
34202: PUSH
34203: LD_INT 1
34205: PUSH
34206: LD_INT 1
34208: NEG
34209: PUSH
34210: EMPTY
34211: LIST
34212: LIST
34213: PUSH
34214: LD_INT 2
34216: NEG
34217: PUSH
34218: LD_INT 1
34220: NEG
34221: PUSH
34222: EMPTY
34223: LIST
34224: LIST
34225: PUSH
34226: LD_INT 2
34228: NEG
34229: PUSH
34230: LD_INT 2
34232: NEG
34233: PUSH
34234: EMPTY
34235: LIST
34236: LIST
34237: PUSH
34238: EMPTY
34239: LIST
34240: LIST
34241: LIST
34242: LIST
34243: LIST
34244: LIST
34245: LIST
34246: LIST
34247: LIST
34248: LIST
34249: LIST
34250: LIST
34251: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
34252: LD_ADDR_VAR 0 48
34256: PUSH
34257: LD_INT 0
34259: PUSH
34260: LD_INT 0
34262: PUSH
34263: EMPTY
34264: LIST
34265: LIST
34266: PUSH
34267: LD_INT 0
34269: PUSH
34270: LD_INT 1
34272: NEG
34273: PUSH
34274: EMPTY
34275: LIST
34276: LIST
34277: PUSH
34278: LD_INT 1
34280: PUSH
34281: LD_INT 0
34283: PUSH
34284: EMPTY
34285: LIST
34286: LIST
34287: PUSH
34288: LD_INT 1
34290: PUSH
34291: LD_INT 1
34293: PUSH
34294: EMPTY
34295: LIST
34296: LIST
34297: PUSH
34298: LD_INT 0
34300: PUSH
34301: LD_INT 1
34303: PUSH
34304: EMPTY
34305: LIST
34306: LIST
34307: PUSH
34308: LD_INT 1
34310: NEG
34311: PUSH
34312: LD_INT 0
34314: PUSH
34315: EMPTY
34316: LIST
34317: LIST
34318: PUSH
34319: LD_INT 1
34321: NEG
34322: PUSH
34323: LD_INT 1
34325: NEG
34326: PUSH
34327: EMPTY
34328: LIST
34329: LIST
34330: PUSH
34331: LD_INT 1
34333: NEG
34334: PUSH
34335: LD_INT 2
34337: NEG
34338: PUSH
34339: EMPTY
34340: LIST
34341: LIST
34342: PUSH
34343: LD_INT 0
34345: PUSH
34346: LD_INT 2
34348: NEG
34349: PUSH
34350: EMPTY
34351: LIST
34352: LIST
34353: PUSH
34354: LD_INT 1
34356: PUSH
34357: LD_INT 1
34359: NEG
34360: PUSH
34361: EMPTY
34362: LIST
34363: LIST
34364: PUSH
34365: LD_INT 2
34367: PUSH
34368: LD_INT 0
34370: PUSH
34371: EMPTY
34372: LIST
34373: LIST
34374: PUSH
34375: LD_INT 2
34377: PUSH
34378: LD_INT 1
34380: PUSH
34381: EMPTY
34382: LIST
34383: LIST
34384: PUSH
34385: EMPTY
34386: LIST
34387: LIST
34388: LIST
34389: LIST
34390: LIST
34391: LIST
34392: LIST
34393: LIST
34394: LIST
34395: LIST
34396: LIST
34397: LIST
34398: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
34399: LD_ADDR_VAR 0 49
34403: PUSH
34404: LD_INT 0
34406: PUSH
34407: LD_INT 0
34409: PUSH
34410: EMPTY
34411: LIST
34412: LIST
34413: PUSH
34414: LD_INT 0
34416: PUSH
34417: LD_INT 1
34419: NEG
34420: PUSH
34421: EMPTY
34422: LIST
34423: LIST
34424: PUSH
34425: LD_INT 1
34427: PUSH
34428: LD_INT 0
34430: PUSH
34431: EMPTY
34432: LIST
34433: LIST
34434: PUSH
34435: LD_INT 1
34437: PUSH
34438: LD_INT 1
34440: PUSH
34441: EMPTY
34442: LIST
34443: LIST
34444: PUSH
34445: LD_INT 0
34447: PUSH
34448: LD_INT 1
34450: PUSH
34451: EMPTY
34452: LIST
34453: LIST
34454: PUSH
34455: LD_INT 1
34457: NEG
34458: PUSH
34459: LD_INT 0
34461: PUSH
34462: EMPTY
34463: LIST
34464: LIST
34465: PUSH
34466: LD_INT 1
34468: NEG
34469: PUSH
34470: LD_INT 1
34472: NEG
34473: PUSH
34474: EMPTY
34475: LIST
34476: LIST
34477: PUSH
34478: LD_INT 1
34480: PUSH
34481: LD_INT 1
34483: NEG
34484: PUSH
34485: EMPTY
34486: LIST
34487: LIST
34488: PUSH
34489: LD_INT 2
34491: PUSH
34492: LD_INT 0
34494: PUSH
34495: EMPTY
34496: LIST
34497: LIST
34498: PUSH
34499: LD_INT 2
34501: PUSH
34502: LD_INT 1
34504: PUSH
34505: EMPTY
34506: LIST
34507: LIST
34508: PUSH
34509: LD_INT 2
34511: PUSH
34512: LD_INT 2
34514: PUSH
34515: EMPTY
34516: LIST
34517: LIST
34518: PUSH
34519: LD_INT 1
34521: PUSH
34522: LD_INT 2
34524: PUSH
34525: EMPTY
34526: LIST
34527: LIST
34528: PUSH
34529: EMPTY
34530: LIST
34531: LIST
34532: LIST
34533: LIST
34534: LIST
34535: LIST
34536: LIST
34537: LIST
34538: LIST
34539: LIST
34540: LIST
34541: LIST
34542: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
34543: LD_ADDR_VAR 0 50
34547: PUSH
34548: LD_INT 0
34550: PUSH
34551: LD_INT 0
34553: PUSH
34554: EMPTY
34555: LIST
34556: LIST
34557: PUSH
34558: LD_INT 0
34560: PUSH
34561: LD_INT 1
34563: NEG
34564: PUSH
34565: EMPTY
34566: LIST
34567: LIST
34568: PUSH
34569: LD_INT 1
34571: PUSH
34572: LD_INT 0
34574: PUSH
34575: EMPTY
34576: LIST
34577: LIST
34578: PUSH
34579: LD_INT 1
34581: PUSH
34582: LD_INT 1
34584: PUSH
34585: EMPTY
34586: LIST
34587: LIST
34588: PUSH
34589: LD_INT 0
34591: PUSH
34592: LD_INT 1
34594: PUSH
34595: EMPTY
34596: LIST
34597: LIST
34598: PUSH
34599: LD_INT 1
34601: NEG
34602: PUSH
34603: LD_INT 0
34605: PUSH
34606: EMPTY
34607: LIST
34608: LIST
34609: PUSH
34610: LD_INT 1
34612: NEG
34613: PUSH
34614: LD_INT 1
34616: NEG
34617: PUSH
34618: EMPTY
34619: LIST
34620: LIST
34621: PUSH
34622: LD_INT 2
34624: PUSH
34625: LD_INT 1
34627: PUSH
34628: EMPTY
34629: LIST
34630: LIST
34631: PUSH
34632: LD_INT 2
34634: PUSH
34635: LD_INT 2
34637: PUSH
34638: EMPTY
34639: LIST
34640: LIST
34641: PUSH
34642: LD_INT 1
34644: PUSH
34645: LD_INT 2
34647: PUSH
34648: EMPTY
34649: LIST
34650: LIST
34651: PUSH
34652: LD_INT 0
34654: PUSH
34655: LD_INT 2
34657: PUSH
34658: EMPTY
34659: LIST
34660: LIST
34661: PUSH
34662: LD_INT 1
34664: NEG
34665: PUSH
34666: LD_INT 1
34668: PUSH
34669: EMPTY
34670: LIST
34671: LIST
34672: PUSH
34673: EMPTY
34674: LIST
34675: LIST
34676: LIST
34677: LIST
34678: LIST
34679: LIST
34680: LIST
34681: LIST
34682: LIST
34683: LIST
34684: LIST
34685: LIST
34686: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
34687: LD_ADDR_VAR 0 51
34691: PUSH
34692: LD_INT 0
34694: PUSH
34695: LD_INT 0
34697: PUSH
34698: EMPTY
34699: LIST
34700: LIST
34701: PUSH
34702: LD_INT 0
34704: PUSH
34705: LD_INT 1
34707: NEG
34708: PUSH
34709: EMPTY
34710: LIST
34711: LIST
34712: PUSH
34713: LD_INT 1
34715: PUSH
34716: LD_INT 0
34718: PUSH
34719: EMPTY
34720: LIST
34721: LIST
34722: PUSH
34723: LD_INT 1
34725: PUSH
34726: LD_INT 1
34728: PUSH
34729: EMPTY
34730: LIST
34731: LIST
34732: PUSH
34733: LD_INT 0
34735: PUSH
34736: LD_INT 1
34738: PUSH
34739: EMPTY
34740: LIST
34741: LIST
34742: PUSH
34743: LD_INT 1
34745: NEG
34746: PUSH
34747: LD_INT 0
34749: PUSH
34750: EMPTY
34751: LIST
34752: LIST
34753: PUSH
34754: LD_INT 1
34756: NEG
34757: PUSH
34758: LD_INT 1
34760: NEG
34761: PUSH
34762: EMPTY
34763: LIST
34764: LIST
34765: PUSH
34766: LD_INT 1
34768: PUSH
34769: LD_INT 2
34771: PUSH
34772: EMPTY
34773: LIST
34774: LIST
34775: PUSH
34776: LD_INT 0
34778: PUSH
34779: LD_INT 2
34781: PUSH
34782: EMPTY
34783: LIST
34784: LIST
34785: PUSH
34786: LD_INT 1
34788: NEG
34789: PUSH
34790: LD_INT 1
34792: PUSH
34793: EMPTY
34794: LIST
34795: LIST
34796: PUSH
34797: LD_INT 2
34799: NEG
34800: PUSH
34801: LD_INT 0
34803: PUSH
34804: EMPTY
34805: LIST
34806: LIST
34807: PUSH
34808: LD_INT 2
34810: NEG
34811: PUSH
34812: LD_INT 1
34814: NEG
34815: PUSH
34816: EMPTY
34817: LIST
34818: LIST
34819: PUSH
34820: EMPTY
34821: LIST
34822: LIST
34823: LIST
34824: LIST
34825: LIST
34826: LIST
34827: LIST
34828: LIST
34829: LIST
34830: LIST
34831: LIST
34832: LIST
34833: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34834: LD_ADDR_VAR 0 52
34838: PUSH
34839: LD_INT 0
34841: PUSH
34842: LD_INT 0
34844: PUSH
34845: EMPTY
34846: LIST
34847: LIST
34848: PUSH
34849: LD_INT 0
34851: PUSH
34852: LD_INT 1
34854: NEG
34855: PUSH
34856: EMPTY
34857: LIST
34858: LIST
34859: PUSH
34860: LD_INT 1
34862: PUSH
34863: LD_INT 0
34865: PUSH
34866: EMPTY
34867: LIST
34868: LIST
34869: PUSH
34870: LD_INT 1
34872: PUSH
34873: LD_INT 1
34875: PUSH
34876: EMPTY
34877: LIST
34878: LIST
34879: PUSH
34880: LD_INT 0
34882: PUSH
34883: LD_INT 1
34885: PUSH
34886: EMPTY
34887: LIST
34888: LIST
34889: PUSH
34890: LD_INT 1
34892: NEG
34893: PUSH
34894: LD_INT 0
34896: PUSH
34897: EMPTY
34898: LIST
34899: LIST
34900: PUSH
34901: LD_INT 1
34903: NEG
34904: PUSH
34905: LD_INT 1
34907: NEG
34908: PUSH
34909: EMPTY
34910: LIST
34911: LIST
34912: PUSH
34913: LD_INT 1
34915: NEG
34916: PUSH
34917: LD_INT 2
34919: NEG
34920: PUSH
34921: EMPTY
34922: LIST
34923: LIST
34924: PUSH
34925: LD_INT 1
34927: NEG
34928: PUSH
34929: LD_INT 1
34931: PUSH
34932: EMPTY
34933: LIST
34934: LIST
34935: PUSH
34936: LD_INT 2
34938: NEG
34939: PUSH
34940: LD_INT 0
34942: PUSH
34943: EMPTY
34944: LIST
34945: LIST
34946: PUSH
34947: LD_INT 2
34949: NEG
34950: PUSH
34951: LD_INT 1
34953: NEG
34954: PUSH
34955: EMPTY
34956: LIST
34957: LIST
34958: PUSH
34959: LD_INT 2
34961: NEG
34962: PUSH
34963: LD_INT 2
34965: NEG
34966: PUSH
34967: EMPTY
34968: LIST
34969: LIST
34970: PUSH
34971: EMPTY
34972: LIST
34973: LIST
34974: LIST
34975: LIST
34976: LIST
34977: LIST
34978: LIST
34979: LIST
34980: LIST
34981: LIST
34982: LIST
34983: LIST
34984: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34985: LD_ADDR_VAR 0 53
34989: PUSH
34990: LD_INT 0
34992: PUSH
34993: LD_INT 0
34995: PUSH
34996: EMPTY
34997: LIST
34998: LIST
34999: PUSH
35000: LD_INT 0
35002: PUSH
35003: LD_INT 1
35005: NEG
35006: PUSH
35007: EMPTY
35008: LIST
35009: LIST
35010: PUSH
35011: LD_INT 1
35013: PUSH
35014: LD_INT 0
35016: PUSH
35017: EMPTY
35018: LIST
35019: LIST
35020: PUSH
35021: LD_INT 1
35023: PUSH
35024: LD_INT 1
35026: PUSH
35027: EMPTY
35028: LIST
35029: LIST
35030: PUSH
35031: LD_INT 0
35033: PUSH
35034: LD_INT 1
35036: PUSH
35037: EMPTY
35038: LIST
35039: LIST
35040: PUSH
35041: LD_INT 1
35043: NEG
35044: PUSH
35045: LD_INT 0
35047: PUSH
35048: EMPTY
35049: LIST
35050: LIST
35051: PUSH
35052: LD_INT 1
35054: NEG
35055: PUSH
35056: LD_INT 1
35058: NEG
35059: PUSH
35060: EMPTY
35061: LIST
35062: LIST
35063: PUSH
35064: LD_INT 1
35066: NEG
35067: PUSH
35068: LD_INT 2
35070: NEG
35071: PUSH
35072: EMPTY
35073: LIST
35074: LIST
35075: PUSH
35076: LD_INT 0
35078: PUSH
35079: LD_INT 2
35081: NEG
35082: PUSH
35083: EMPTY
35084: LIST
35085: LIST
35086: PUSH
35087: LD_INT 1
35089: PUSH
35090: LD_INT 1
35092: NEG
35093: PUSH
35094: EMPTY
35095: LIST
35096: LIST
35097: PUSH
35098: LD_INT 2
35100: PUSH
35101: LD_INT 0
35103: PUSH
35104: EMPTY
35105: LIST
35106: LIST
35107: PUSH
35108: LD_INT 2
35110: PUSH
35111: LD_INT 1
35113: PUSH
35114: EMPTY
35115: LIST
35116: LIST
35117: PUSH
35118: LD_INT 2
35120: PUSH
35121: LD_INT 2
35123: PUSH
35124: EMPTY
35125: LIST
35126: LIST
35127: PUSH
35128: LD_INT 1
35130: PUSH
35131: LD_INT 2
35133: PUSH
35134: EMPTY
35135: LIST
35136: LIST
35137: PUSH
35138: LD_INT 0
35140: PUSH
35141: LD_INT 2
35143: PUSH
35144: EMPTY
35145: LIST
35146: LIST
35147: PUSH
35148: LD_INT 1
35150: NEG
35151: PUSH
35152: LD_INT 1
35154: PUSH
35155: EMPTY
35156: LIST
35157: LIST
35158: PUSH
35159: LD_INT 2
35161: NEG
35162: PUSH
35163: LD_INT 0
35165: PUSH
35166: EMPTY
35167: LIST
35168: LIST
35169: PUSH
35170: LD_INT 2
35172: NEG
35173: PUSH
35174: LD_INT 1
35176: NEG
35177: PUSH
35178: EMPTY
35179: LIST
35180: LIST
35181: PUSH
35182: LD_INT 2
35184: NEG
35185: PUSH
35186: LD_INT 2
35188: NEG
35189: PUSH
35190: EMPTY
35191: LIST
35192: LIST
35193: PUSH
35194: EMPTY
35195: LIST
35196: LIST
35197: LIST
35198: LIST
35199: LIST
35200: LIST
35201: LIST
35202: LIST
35203: LIST
35204: LIST
35205: LIST
35206: LIST
35207: LIST
35208: LIST
35209: LIST
35210: LIST
35211: LIST
35212: LIST
35213: LIST
35214: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35215: LD_ADDR_VAR 0 54
35219: PUSH
35220: LD_INT 0
35222: PUSH
35223: LD_INT 0
35225: PUSH
35226: EMPTY
35227: LIST
35228: LIST
35229: PUSH
35230: LD_INT 0
35232: PUSH
35233: LD_INT 1
35235: NEG
35236: PUSH
35237: EMPTY
35238: LIST
35239: LIST
35240: PUSH
35241: LD_INT 1
35243: PUSH
35244: LD_INT 0
35246: PUSH
35247: EMPTY
35248: LIST
35249: LIST
35250: PUSH
35251: LD_INT 1
35253: PUSH
35254: LD_INT 1
35256: PUSH
35257: EMPTY
35258: LIST
35259: LIST
35260: PUSH
35261: LD_INT 0
35263: PUSH
35264: LD_INT 1
35266: PUSH
35267: EMPTY
35268: LIST
35269: LIST
35270: PUSH
35271: LD_INT 1
35273: NEG
35274: PUSH
35275: LD_INT 0
35277: PUSH
35278: EMPTY
35279: LIST
35280: LIST
35281: PUSH
35282: LD_INT 1
35284: NEG
35285: PUSH
35286: LD_INT 1
35288: NEG
35289: PUSH
35290: EMPTY
35291: LIST
35292: LIST
35293: PUSH
35294: LD_INT 1
35296: NEG
35297: PUSH
35298: LD_INT 2
35300: NEG
35301: PUSH
35302: EMPTY
35303: LIST
35304: LIST
35305: PUSH
35306: LD_INT 0
35308: PUSH
35309: LD_INT 2
35311: NEG
35312: PUSH
35313: EMPTY
35314: LIST
35315: LIST
35316: PUSH
35317: LD_INT 1
35319: PUSH
35320: LD_INT 1
35322: NEG
35323: PUSH
35324: EMPTY
35325: LIST
35326: LIST
35327: PUSH
35328: LD_INT 2
35330: PUSH
35331: LD_INT 0
35333: PUSH
35334: EMPTY
35335: LIST
35336: LIST
35337: PUSH
35338: LD_INT 2
35340: PUSH
35341: LD_INT 1
35343: PUSH
35344: EMPTY
35345: LIST
35346: LIST
35347: PUSH
35348: LD_INT 2
35350: PUSH
35351: LD_INT 2
35353: PUSH
35354: EMPTY
35355: LIST
35356: LIST
35357: PUSH
35358: LD_INT 1
35360: PUSH
35361: LD_INT 2
35363: PUSH
35364: EMPTY
35365: LIST
35366: LIST
35367: PUSH
35368: LD_INT 0
35370: PUSH
35371: LD_INT 2
35373: PUSH
35374: EMPTY
35375: LIST
35376: LIST
35377: PUSH
35378: LD_INT 1
35380: NEG
35381: PUSH
35382: LD_INT 1
35384: PUSH
35385: EMPTY
35386: LIST
35387: LIST
35388: PUSH
35389: LD_INT 2
35391: NEG
35392: PUSH
35393: LD_INT 0
35395: PUSH
35396: EMPTY
35397: LIST
35398: LIST
35399: PUSH
35400: LD_INT 2
35402: NEG
35403: PUSH
35404: LD_INT 1
35406: NEG
35407: PUSH
35408: EMPTY
35409: LIST
35410: LIST
35411: PUSH
35412: LD_INT 2
35414: NEG
35415: PUSH
35416: LD_INT 2
35418: NEG
35419: PUSH
35420: EMPTY
35421: LIST
35422: LIST
35423: PUSH
35424: EMPTY
35425: LIST
35426: LIST
35427: LIST
35428: LIST
35429: LIST
35430: LIST
35431: LIST
35432: LIST
35433: LIST
35434: LIST
35435: LIST
35436: LIST
35437: LIST
35438: LIST
35439: LIST
35440: LIST
35441: LIST
35442: LIST
35443: LIST
35444: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35445: LD_ADDR_VAR 0 55
35449: PUSH
35450: LD_INT 0
35452: PUSH
35453: LD_INT 0
35455: PUSH
35456: EMPTY
35457: LIST
35458: LIST
35459: PUSH
35460: LD_INT 0
35462: PUSH
35463: LD_INT 1
35465: NEG
35466: PUSH
35467: EMPTY
35468: LIST
35469: LIST
35470: PUSH
35471: LD_INT 1
35473: PUSH
35474: LD_INT 0
35476: PUSH
35477: EMPTY
35478: LIST
35479: LIST
35480: PUSH
35481: LD_INT 1
35483: PUSH
35484: LD_INT 1
35486: PUSH
35487: EMPTY
35488: LIST
35489: LIST
35490: PUSH
35491: LD_INT 0
35493: PUSH
35494: LD_INT 1
35496: PUSH
35497: EMPTY
35498: LIST
35499: LIST
35500: PUSH
35501: LD_INT 1
35503: NEG
35504: PUSH
35505: LD_INT 0
35507: PUSH
35508: EMPTY
35509: LIST
35510: LIST
35511: PUSH
35512: LD_INT 1
35514: NEG
35515: PUSH
35516: LD_INT 1
35518: NEG
35519: PUSH
35520: EMPTY
35521: LIST
35522: LIST
35523: PUSH
35524: LD_INT 1
35526: NEG
35527: PUSH
35528: LD_INT 2
35530: NEG
35531: PUSH
35532: EMPTY
35533: LIST
35534: LIST
35535: PUSH
35536: LD_INT 0
35538: PUSH
35539: LD_INT 2
35541: NEG
35542: PUSH
35543: EMPTY
35544: LIST
35545: LIST
35546: PUSH
35547: LD_INT 1
35549: PUSH
35550: LD_INT 1
35552: NEG
35553: PUSH
35554: EMPTY
35555: LIST
35556: LIST
35557: PUSH
35558: LD_INT 2
35560: PUSH
35561: LD_INT 0
35563: PUSH
35564: EMPTY
35565: LIST
35566: LIST
35567: PUSH
35568: LD_INT 2
35570: PUSH
35571: LD_INT 1
35573: PUSH
35574: EMPTY
35575: LIST
35576: LIST
35577: PUSH
35578: LD_INT 2
35580: PUSH
35581: LD_INT 2
35583: PUSH
35584: EMPTY
35585: LIST
35586: LIST
35587: PUSH
35588: LD_INT 1
35590: PUSH
35591: LD_INT 2
35593: PUSH
35594: EMPTY
35595: LIST
35596: LIST
35597: PUSH
35598: LD_INT 0
35600: PUSH
35601: LD_INT 2
35603: PUSH
35604: EMPTY
35605: LIST
35606: LIST
35607: PUSH
35608: LD_INT 1
35610: NEG
35611: PUSH
35612: LD_INT 1
35614: PUSH
35615: EMPTY
35616: LIST
35617: LIST
35618: PUSH
35619: LD_INT 2
35621: NEG
35622: PUSH
35623: LD_INT 0
35625: PUSH
35626: EMPTY
35627: LIST
35628: LIST
35629: PUSH
35630: LD_INT 2
35632: NEG
35633: PUSH
35634: LD_INT 1
35636: NEG
35637: PUSH
35638: EMPTY
35639: LIST
35640: LIST
35641: PUSH
35642: LD_INT 2
35644: NEG
35645: PUSH
35646: LD_INT 2
35648: NEG
35649: PUSH
35650: EMPTY
35651: LIST
35652: LIST
35653: PUSH
35654: EMPTY
35655: LIST
35656: LIST
35657: LIST
35658: LIST
35659: LIST
35660: LIST
35661: LIST
35662: LIST
35663: LIST
35664: LIST
35665: LIST
35666: LIST
35667: LIST
35668: LIST
35669: LIST
35670: LIST
35671: LIST
35672: LIST
35673: LIST
35674: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35675: LD_ADDR_VAR 0 56
35679: PUSH
35680: LD_INT 0
35682: PUSH
35683: LD_INT 0
35685: PUSH
35686: EMPTY
35687: LIST
35688: LIST
35689: PUSH
35690: LD_INT 0
35692: PUSH
35693: LD_INT 1
35695: NEG
35696: PUSH
35697: EMPTY
35698: LIST
35699: LIST
35700: PUSH
35701: LD_INT 1
35703: PUSH
35704: LD_INT 0
35706: PUSH
35707: EMPTY
35708: LIST
35709: LIST
35710: PUSH
35711: LD_INT 1
35713: PUSH
35714: LD_INT 1
35716: PUSH
35717: EMPTY
35718: LIST
35719: LIST
35720: PUSH
35721: LD_INT 0
35723: PUSH
35724: LD_INT 1
35726: PUSH
35727: EMPTY
35728: LIST
35729: LIST
35730: PUSH
35731: LD_INT 1
35733: NEG
35734: PUSH
35735: LD_INT 0
35737: PUSH
35738: EMPTY
35739: LIST
35740: LIST
35741: PUSH
35742: LD_INT 1
35744: NEG
35745: PUSH
35746: LD_INT 1
35748: NEG
35749: PUSH
35750: EMPTY
35751: LIST
35752: LIST
35753: PUSH
35754: LD_INT 1
35756: NEG
35757: PUSH
35758: LD_INT 2
35760: NEG
35761: PUSH
35762: EMPTY
35763: LIST
35764: LIST
35765: PUSH
35766: LD_INT 0
35768: PUSH
35769: LD_INT 2
35771: NEG
35772: PUSH
35773: EMPTY
35774: LIST
35775: LIST
35776: PUSH
35777: LD_INT 1
35779: PUSH
35780: LD_INT 1
35782: NEG
35783: PUSH
35784: EMPTY
35785: LIST
35786: LIST
35787: PUSH
35788: LD_INT 2
35790: PUSH
35791: LD_INT 0
35793: PUSH
35794: EMPTY
35795: LIST
35796: LIST
35797: PUSH
35798: LD_INT 2
35800: PUSH
35801: LD_INT 1
35803: PUSH
35804: EMPTY
35805: LIST
35806: LIST
35807: PUSH
35808: LD_INT 2
35810: PUSH
35811: LD_INT 2
35813: PUSH
35814: EMPTY
35815: LIST
35816: LIST
35817: PUSH
35818: LD_INT 1
35820: PUSH
35821: LD_INT 2
35823: PUSH
35824: EMPTY
35825: LIST
35826: LIST
35827: PUSH
35828: LD_INT 0
35830: PUSH
35831: LD_INT 2
35833: PUSH
35834: EMPTY
35835: LIST
35836: LIST
35837: PUSH
35838: LD_INT 1
35840: NEG
35841: PUSH
35842: LD_INT 1
35844: PUSH
35845: EMPTY
35846: LIST
35847: LIST
35848: PUSH
35849: LD_INT 2
35851: NEG
35852: PUSH
35853: LD_INT 0
35855: PUSH
35856: EMPTY
35857: LIST
35858: LIST
35859: PUSH
35860: LD_INT 2
35862: NEG
35863: PUSH
35864: LD_INT 1
35866: NEG
35867: PUSH
35868: EMPTY
35869: LIST
35870: LIST
35871: PUSH
35872: LD_INT 2
35874: NEG
35875: PUSH
35876: LD_INT 2
35878: NEG
35879: PUSH
35880: EMPTY
35881: LIST
35882: LIST
35883: PUSH
35884: EMPTY
35885: LIST
35886: LIST
35887: LIST
35888: LIST
35889: LIST
35890: LIST
35891: LIST
35892: LIST
35893: LIST
35894: LIST
35895: LIST
35896: LIST
35897: LIST
35898: LIST
35899: LIST
35900: LIST
35901: LIST
35902: LIST
35903: LIST
35904: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35905: LD_ADDR_VAR 0 57
35909: PUSH
35910: LD_INT 0
35912: PUSH
35913: LD_INT 0
35915: PUSH
35916: EMPTY
35917: LIST
35918: LIST
35919: PUSH
35920: LD_INT 0
35922: PUSH
35923: LD_INT 1
35925: NEG
35926: PUSH
35927: EMPTY
35928: LIST
35929: LIST
35930: PUSH
35931: LD_INT 1
35933: PUSH
35934: LD_INT 0
35936: PUSH
35937: EMPTY
35938: LIST
35939: LIST
35940: PUSH
35941: LD_INT 1
35943: PUSH
35944: LD_INT 1
35946: PUSH
35947: EMPTY
35948: LIST
35949: LIST
35950: PUSH
35951: LD_INT 0
35953: PUSH
35954: LD_INT 1
35956: PUSH
35957: EMPTY
35958: LIST
35959: LIST
35960: PUSH
35961: LD_INT 1
35963: NEG
35964: PUSH
35965: LD_INT 0
35967: PUSH
35968: EMPTY
35969: LIST
35970: LIST
35971: PUSH
35972: LD_INT 1
35974: NEG
35975: PUSH
35976: LD_INT 1
35978: NEG
35979: PUSH
35980: EMPTY
35981: LIST
35982: LIST
35983: PUSH
35984: LD_INT 1
35986: NEG
35987: PUSH
35988: LD_INT 2
35990: NEG
35991: PUSH
35992: EMPTY
35993: LIST
35994: LIST
35995: PUSH
35996: LD_INT 0
35998: PUSH
35999: LD_INT 2
36001: NEG
36002: PUSH
36003: EMPTY
36004: LIST
36005: LIST
36006: PUSH
36007: LD_INT 1
36009: PUSH
36010: LD_INT 1
36012: NEG
36013: PUSH
36014: EMPTY
36015: LIST
36016: LIST
36017: PUSH
36018: LD_INT 2
36020: PUSH
36021: LD_INT 0
36023: PUSH
36024: EMPTY
36025: LIST
36026: LIST
36027: PUSH
36028: LD_INT 2
36030: PUSH
36031: LD_INT 1
36033: PUSH
36034: EMPTY
36035: LIST
36036: LIST
36037: PUSH
36038: LD_INT 2
36040: PUSH
36041: LD_INT 2
36043: PUSH
36044: EMPTY
36045: LIST
36046: LIST
36047: PUSH
36048: LD_INT 1
36050: PUSH
36051: LD_INT 2
36053: PUSH
36054: EMPTY
36055: LIST
36056: LIST
36057: PUSH
36058: LD_INT 0
36060: PUSH
36061: LD_INT 2
36063: PUSH
36064: EMPTY
36065: LIST
36066: LIST
36067: PUSH
36068: LD_INT 1
36070: NEG
36071: PUSH
36072: LD_INT 1
36074: PUSH
36075: EMPTY
36076: LIST
36077: LIST
36078: PUSH
36079: LD_INT 2
36081: NEG
36082: PUSH
36083: LD_INT 0
36085: PUSH
36086: EMPTY
36087: LIST
36088: LIST
36089: PUSH
36090: LD_INT 2
36092: NEG
36093: PUSH
36094: LD_INT 1
36096: NEG
36097: PUSH
36098: EMPTY
36099: LIST
36100: LIST
36101: PUSH
36102: LD_INT 2
36104: NEG
36105: PUSH
36106: LD_INT 2
36108: NEG
36109: PUSH
36110: EMPTY
36111: LIST
36112: LIST
36113: PUSH
36114: EMPTY
36115: LIST
36116: LIST
36117: LIST
36118: LIST
36119: LIST
36120: LIST
36121: LIST
36122: LIST
36123: LIST
36124: LIST
36125: LIST
36126: LIST
36127: LIST
36128: LIST
36129: LIST
36130: LIST
36131: LIST
36132: LIST
36133: LIST
36134: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36135: LD_ADDR_VAR 0 58
36139: PUSH
36140: LD_INT 0
36142: PUSH
36143: LD_INT 0
36145: PUSH
36146: EMPTY
36147: LIST
36148: LIST
36149: PUSH
36150: LD_INT 0
36152: PUSH
36153: LD_INT 1
36155: NEG
36156: PUSH
36157: EMPTY
36158: LIST
36159: LIST
36160: PUSH
36161: LD_INT 1
36163: PUSH
36164: LD_INT 0
36166: PUSH
36167: EMPTY
36168: LIST
36169: LIST
36170: PUSH
36171: LD_INT 1
36173: PUSH
36174: LD_INT 1
36176: PUSH
36177: EMPTY
36178: LIST
36179: LIST
36180: PUSH
36181: LD_INT 0
36183: PUSH
36184: LD_INT 1
36186: PUSH
36187: EMPTY
36188: LIST
36189: LIST
36190: PUSH
36191: LD_INT 1
36193: NEG
36194: PUSH
36195: LD_INT 0
36197: PUSH
36198: EMPTY
36199: LIST
36200: LIST
36201: PUSH
36202: LD_INT 1
36204: NEG
36205: PUSH
36206: LD_INT 1
36208: NEG
36209: PUSH
36210: EMPTY
36211: LIST
36212: LIST
36213: PUSH
36214: LD_INT 1
36216: NEG
36217: PUSH
36218: LD_INT 2
36220: NEG
36221: PUSH
36222: EMPTY
36223: LIST
36224: LIST
36225: PUSH
36226: LD_INT 0
36228: PUSH
36229: LD_INT 2
36231: NEG
36232: PUSH
36233: EMPTY
36234: LIST
36235: LIST
36236: PUSH
36237: LD_INT 1
36239: PUSH
36240: LD_INT 1
36242: NEG
36243: PUSH
36244: EMPTY
36245: LIST
36246: LIST
36247: PUSH
36248: LD_INT 2
36250: PUSH
36251: LD_INT 0
36253: PUSH
36254: EMPTY
36255: LIST
36256: LIST
36257: PUSH
36258: LD_INT 2
36260: PUSH
36261: LD_INT 1
36263: PUSH
36264: EMPTY
36265: LIST
36266: LIST
36267: PUSH
36268: LD_INT 2
36270: PUSH
36271: LD_INT 2
36273: PUSH
36274: EMPTY
36275: LIST
36276: LIST
36277: PUSH
36278: LD_INT 1
36280: PUSH
36281: LD_INT 2
36283: PUSH
36284: EMPTY
36285: LIST
36286: LIST
36287: PUSH
36288: LD_INT 0
36290: PUSH
36291: LD_INT 2
36293: PUSH
36294: EMPTY
36295: LIST
36296: LIST
36297: PUSH
36298: LD_INT 1
36300: NEG
36301: PUSH
36302: LD_INT 1
36304: PUSH
36305: EMPTY
36306: LIST
36307: LIST
36308: PUSH
36309: LD_INT 2
36311: NEG
36312: PUSH
36313: LD_INT 0
36315: PUSH
36316: EMPTY
36317: LIST
36318: LIST
36319: PUSH
36320: LD_INT 2
36322: NEG
36323: PUSH
36324: LD_INT 1
36326: NEG
36327: PUSH
36328: EMPTY
36329: LIST
36330: LIST
36331: PUSH
36332: LD_INT 2
36334: NEG
36335: PUSH
36336: LD_INT 2
36338: NEG
36339: PUSH
36340: EMPTY
36341: LIST
36342: LIST
36343: PUSH
36344: EMPTY
36345: LIST
36346: LIST
36347: LIST
36348: LIST
36349: LIST
36350: LIST
36351: LIST
36352: LIST
36353: LIST
36354: LIST
36355: LIST
36356: LIST
36357: LIST
36358: LIST
36359: LIST
36360: LIST
36361: LIST
36362: LIST
36363: LIST
36364: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36365: LD_ADDR_VAR 0 59
36369: PUSH
36370: LD_INT 0
36372: PUSH
36373: LD_INT 0
36375: PUSH
36376: EMPTY
36377: LIST
36378: LIST
36379: PUSH
36380: LD_INT 0
36382: PUSH
36383: LD_INT 1
36385: NEG
36386: PUSH
36387: EMPTY
36388: LIST
36389: LIST
36390: PUSH
36391: LD_INT 1
36393: PUSH
36394: LD_INT 0
36396: PUSH
36397: EMPTY
36398: LIST
36399: LIST
36400: PUSH
36401: LD_INT 1
36403: PUSH
36404: LD_INT 1
36406: PUSH
36407: EMPTY
36408: LIST
36409: LIST
36410: PUSH
36411: LD_INT 0
36413: PUSH
36414: LD_INT 1
36416: PUSH
36417: EMPTY
36418: LIST
36419: LIST
36420: PUSH
36421: LD_INT 1
36423: NEG
36424: PUSH
36425: LD_INT 0
36427: PUSH
36428: EMPTY
36429: LIST
36430: LIST
36431: PUSH
36432: LD_INT 1
36434: NEG
36435: PUSH
36436: LD_INT 1
36438: NEG
36439: PUSH
36440: EMPTY
36441: LIST
36442: LIST
36443: PUSH
36444: EMPTY
36445: LIST
36446: LIST
36447: LIST
36448: LIST
36449: LIST
36450: LIST
36451: LIST
36452: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36453: LD_ADDR_VAR 0 60
36457: PUSH
36458: LD_INT 0
36460: PUSH
36461: LD_INT 0
36463: PUSH
36464: EMPTY
36465: LIST
36466: LIST
36467: PUSH
36468: LD_INT 0
36470: PUSH
36471: LD_INT 1
36473: NEG
36474: PUSH
36475: EMPTY
36476: LIST
36477: LIST
36478: PUSH
36479: LD_INT 1
36481: PUSH
36482: LD_INT 0
36484: PUSH
36485: EMPTY
36486: LIST
36487: LIST
36488: PUSH
36489: LD_INT 1
36491: PUSH
36492: LD_INT 1
36494: PUSH
36495: EMPTY
36496: LIST
36497: LIST
36498: PUSH
36499: LD_INT 0
36501: PUSH
36502: LD_INT 1
36504: PUSH
36505: EMPTY
36506: LIST
36507: LIST
36508: PUSH
36509: LD_INT 1
36511: NEG
36512: PUSH
36513: LD_INT 0
36515: PUSH
36516: EMPTY
36517: LIST
36518: LIST
36519: PUSH
36520: LD_INT 1
36522: NEG
36523: PUSH
36524: LD_INT 1
36526: NEG
36527: PUSH
36528: EMPTY
36529: LIST
36530: LIST
36531: PUSH
36532: EMPTY
36533: LIST
36534: LIST
36535: LIST
36536: LIST
36537: LIST
36538: LIST
36539: LIST
36540: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36541: LD_ADDR_VAR 0 61
36545: PUSH
36546: LD_INT 0
36548: PUSH
36549: LD_INT 0
36551: PUSH
36552: EMPTY
36553: LIST
36554: LIST
36555: PUSH
36556: LD_INT 0
36558: PUSH
36559: LD_INT 1
36561: NEG
36562: PUSH
36563: EMPTY
36564: LIST
36565: LIST
36566: PUSH
36567: LD_INT 1
36569: PUSH
36570: LD_INT 0
36572: PUSH
36573: EMPTY
36574: LIST
36575: LIST
36576: PUSH
36577: LD_INT 1
36579: PUSH
36580: LD_INT 1
36582: PUSH
36583: EMPTY
36584: LIST
36585: LIST
36586: PUSH
36587: LD_INT 0
36589: PUSH
36590: LD_INT 1
36592: PUSH
36593: EMPTY
36594: LIST
36595: LIST
36596: PUSH
36597: LD_INT 1
36599: NEG
36600: PUSH
36601: LD_INT 0
36603: PUSH
36604: EMPTY
36605: LIST
36606: LIST
36607: PUSH
36608: LD_INT 1
36610: NEG
36611: PUSH
36612: LD_INT 1
36614: NEG
36615: PUSH
36616: EMPTY
36617: LIST
36618: LIST
36619: PUSH
36620: EMPTY
36621: LIST
36622: LIST
36623: LIST
36624: LIST
36625: LIST
36626: LIST
36627: LIST
36628: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36629: LD_ADDR_VAR 0 62
36633: PUSH
36634: LD_INT 0
36636: PUSH
36637: LD_INT 0
36639: PUSH
36640: EMPTY
36641: LIST
36642: LIST
36643: PUSH
36644: LD_INT 0
36646: PUSH
36647: LD_INT 1
36649: NEG
36650: PUSH
36651: EMPTY
36652: LIST
36653: LIST
36654: PUSH
36655: LD_INT 1
36657: PUSH
36658: LD_INT 0
36660: PUSH
36661: EMPTY
36662: LIST
36663: LIST
36664: PUSH
36665: LD_INT 1
36667: PUSH
36668: LD_INT 1
36670: PUSH
36671: EMPTY
36672: LIST
36673: LIST
36674: PUSH
36675: LD_INT 0
36677: PUSH
36678: LD_INT 1
36680: PUSH
36681: EMPTY
36682: LIST
36683: LIST
36684: PUSH
36685: LD_INT 1
36687: NEG
36688: PUSH
36689: LD_INT 0
36691: PUSH
36692: EMPTY
36693: LIST
36694: LIST
36695: PUSH
36696: LD_INT 1
36698: NEG
36699: PUSH
36700: LD_INT 1
36702: NEG
36703: PUSH
36704: EMPTY
36705: LIST
36706: LIST
36707: PUSH
36708: EMPTY
36709: LIST
36710: LIST
36711: LIST
36712: LIST
36713: LIST
36714: LIST
36715: LIST
36716: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36717: LD_ADDR_VAR 0 63
36721: PUSH
36722: LD_INT 0
36724: PUSH
36725: LD_INT 0
36727: PUSH
36728: EMPTY
36729: LIST
36730: LIST
36731: PUSH
36732: LD_INT 0
36734: PUSH
36735: LD_INT 1
36737: NEG
36738: PUSH
36739: EMPTY
36740: LIST
36741: LIST
36742: PUSH
36743: LD_INT 1
36745: PUSH
36746: LD_INT 0
36748: PUSH
36749: EMPTY
36750: LIST
36751: LIST
36752: PUSH
36753: LD_INT 1
36755: PUSH
36756: LD_INT 1
36758: PUSH
36759: EMPTY
36760: LIST
36761: LIST
36762: PUSH
36763: LD_INT 0
36765: PUSH
36766: LD_INT 1
36768: PUSH
36769: EMPTY
36770: LIST
36771: LIST
36772: PUSH
36773: LD_INT 1
36775: NEG
36776: PUSH
36777: LD_INT 0
36779: PUSH
36780: EMPTY
36781: LIST
36782: LIST
36783: PUSH
36784: LD_INT 1
36786: NEG
36787: PUSH
36788: LD_INT 1
36790: NEG
36791: PUSH
36792: EMPTY
36793: LIST
36794: LIST
36795: PUSH
36796: EMPTY
36797: LIST
36798: LIST
36799: LIST
36800: LIST
36801: LIST
36802: LIST
36803: LIST
36804: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36805: LD_ADDR_VAR 0 64
36809: PUSH
36810: LD_INT 0
36812: PUSH
36813: LD_INT 0
36815: PUSH
36816: EMPTY
36817: LIST
36818: LIST
36819: PUSH
36820: LD_INT 0
36822: PUSH
36823: LD_INT 1
36825: NEG
36826: PUSH
36827: EMPTY
36828: LIST
36829: LIST
36830: PUSH
36831: LD_INT 1
36833: PUSH
36834: LD_INT 0
36836: PUSH
36837: EMPTY
36838: LIST
36839: LIST
36840: PUSH
36841: LD_INT 1
36843: PUSH
36844: LD_INT 1
36846: PUSH
36847: EMPTY
36848: LIST
36849: LIST
36850: PUSH
36851: LD_INT 0
36853: PUSH
36854: LD_INT 1
36856: PUSH
36857: EMPTY
36858: LIST
36859: LIST
36860: PUSH
36861: LD_INT 1
36863: NEG
36864: PUSH
36865: LD_INT 0
36867: PUSH
36868: EMPTY
36869: LIST
36870: LIST
36871: PUSH
36872: LD_INT 1
36874: NEG
36875: PUSH
36876: LD_INT 1
36878: NEG
36879: PUSH
36880: EMPTY
36881: LIST
36882: LIST
36883: PUSH
36884: EMPTY
36885: LIST
36886: LIST
36887: LIST
36888: LIST
36889: LIST
36890: LIST
36891: LIST
36892: ST_TO_ADDR
// end ; 1 :
36893: GO 42790
36895: LD_INT 1
36897: DOUBLE
36898: EQUAL
36899: IFTRUE 36903
36901: GO 39526
36903: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
36904: LD_ADDR_VAR 0 11
36908: PUSH
36909: LD_INT 1
36911: NEG
36912: PUSH
36913: LD_INT 3
36915: NEG
36916: PUSH
36917: EMPTY
36918: LIST
36919: LIST
36920: PUSH
36921: LD_INT 0
36923: PUSH
36924: LD_INT 3
36926: NEG
36927: PUSH
36928: EMPTY
36929: LIST
36930: LIST
36931: PUSH
36932: LD_INT 1
36934: PUSH
36935: LD_INT 2
36937: NEG
36938: PUSH
36939: EMPTY
36940: LIST
36941: LIST
36942: PUSH
36943: EMPTY
36944: LIST
36945: LIST
36946: LIST
36947: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
36948: LD_ADDR_VAR 0 12
36952: PUSH
36953: LD_INT 2
36955: PUSH
36956: LD_INT 1
36958: NEG
36959: PUSH
36960: EMPTY
36961: LIST
36962: LIST
36963: PUSH
36964: LD_INT 3
36966: PUSH
36967: LD_INT 0
36969: PUSH
36970: EMPTY
36971: LIST
36972: LIST
36973: PUSH
36974: LD_INT 3
36976: PUSH
36977: LD_INT 1
36979: PUSH
36980: EMPTY
36981: LIST
36982: LIST
36983: PUSH
36984: EMPTY
36985: LIST
36986: LIST
36987: LIST
36988: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
36989: LD_ADDR_VAR 0 13
36993: PUSH
36994: LD_INT 3
36996: PUSH
36997: LD_INT 2
36999: PUSH
37000: EMPTY
37001: LIST
37002: LIST
37003: PUSH
37004: LD_INT 3
37006: PUSH
37007: LD_INT 3
37009: PUSH
37010: EMPTY
37011: LIST
37012: LIST
37013: PUSH
37014: LD_INT 2
37016: PUSH
37017: LD_INT 3
37019: PUSH
37020: EMPTY
37021: LIST
37022: LIST
37023: PUSH
37024: EMPTY
37025: LIST
37026: LIST
37027: LIST
37028: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37029: LD_ADDR_VAR 0 14
37033: PUSH
37034: LD_INT 1
37036: PUSH
37037: LD_INT 3
37039: PUSH
37040: EMPTY
37041: LIST
37042: LIST
37043: PUSH
37044: LD_INT 0
37046: PUSH
37047: LD_INT 3
37049: PUSH
37050: EMPTY
37051: LIST
37052: LIST
37053: PUSH
37054: LD_INT 1
37056: NEG
37057: PUSH
37058: LD_INT 2
37060: PUSH
37061: EMPTY
37062: LIST
37063: LIST
37064: PUSH
37065: EMPTY
37066: LIST
37067: LIST
37068: LIST
37069: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37070: LD_ADDR_VAR 0 15
37074: PUSH
37075: LD_INT 2
37077: NEG
37078: PUSH
37079: LD_INT 1
37081: PUSH
37082: EMPTY
37083: LIST
37084: LIST
37085: PUSH
37086: LD_INT 3
37088: NEG
37089: PUSH
37090: LD_INT 0
37092: PUSH
37093: EMPTY
37094: LIST
37095: LIST
37096: PUSH
37097: LD_INT 3
37099: NEG
37100: PUSH
37101: LD_INT 1
37103: NEG
37104: PUSH
37105: EMPTY
37106: LIST
37107: LIST
37108: PUSH
37109: EMPTY
37110: LIST
37111: LIST
37112: LIST
37113: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37114: LD_ADDR_VAR 0 16
37118: PUSH
37119: LD_INT 2
37121: NEG
37122: PUSH
37123: LD_INT 3
37125: NEG
37126: PUSH
37127: EMPTY
37128: LIST
37129: LIST
37130: PUSH
37131: LD_INT 3
37133: NEG
37134: PUSH
37135: LD_INT 2
37137: NEG
37138: PUSH
37139: EMPTY
37140: LIST
37141: LIST
37142: PUSH
37143: LD_INT 3
37145: NEG
37146: PUSH
37147: LD_INT 3
37149: NEG
37150: PUSH
37151: EMPTY
37152: LIST
37153: LIST
37154: PUSH
37155: EMPTY
37156: LIST
37157: LIST
37158: LIST
37159: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
37160: LD_ADDR_VAR 0 17
37164: PUSH
37165: LD_INT 1
37167: NEG
37168: PUSH
37169: LD_INT 3
37171: NEG
37172: PUSH
37173: EMPTY
37174: LIST
37175: LIST
37176: PUSH
37177: LD_INT 0
37179: PUSH
37180: LD_INT 3
37182: NEG
37183: PUSH
37184: EMPTY
37185: LIST
37186: LIST
37187: PUSH
37188: LD_INT 1
37190: PUSH
37191: LD_INT 2
37193: NEG
37194: PUSH
37195: EMPTY
37196: LIST
37197: LIST
37198: PUSH
37199: EMPTY
37200: LIST
37201: LIST
37202: LIST
37203: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
37204: LD_ADDR_VAR 0 18
37208: PUSH
37209: LD_INT 2
37211: PUSH
37212: LD_INT 1
37214: NEG
37215: PUSH
37216: EMPTY
37217: LIST
37218: LIST
37219: PUSH
37220: LD_INT 3
37222: PUSH
37223: LD_INT 0
37225: PUSH
37226: EMPTY
37227: LIST
37228: LIST
37229: PUSH
37230: LD_INT 3
37232: PUSH
37233: LD_INT 1
37235: PUSH
37236: EMPTY
37237: LIST
37238: LIST
37239: PUSH
37240: EMPTY
37241: LIST
37242: LIST
37243: LIST
37244: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
37245: LD_ADDR_VAR 0 19
37249: PUSH
37250: LD_INT 3
37252: PUSH
37253: LD_INT 2
37255: PUSH
37256: EMPTY
37257: LIST
37258: LIST
37259: PUSH
37260: LD_INT 3
37262: PUSH
37263: LD_INT 3
37265: PUSH
37266: EMPTY
37267: LIST
37268: LIST
37269: PUSH
37270: LD_INT 2
37272: PUSH
37273: LD_INT 3
37275: PUSH
37276: EMPTY
37277: LIST
37278: LIST
37279: PUSH
37280: EMPTY
37281: LIST
37282: LIST
37283: LIST
37284: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37285: LD_ADDR_VAR 0 20
37289: PUSH
37290: LD_INT 1
37292: PUSH
37293: LD_INT 3
37295: PUSH
37296: EMPTY
37297: LIST
37298: LIST
37299: PUSH
37300: LD_INT 0
37302: PUSH
37303: LD_INT 3
37305: PUSH
37306: EMPTY
37307: LIST
37308: LIST
37309: PUSH
37310: LD_INT 1
37312: NEG
37313: PUSH
37314: LD_INT 2
37316: PUSH
37317: EMPTY
37318: LIST
37319: LIST
37320: PUSH
37321: EMPTY
37322: LIST
37323: LIST
37324: LIST
37325: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37326: LD_ADDR_VAR 0 21
37330: PUSH
37331: LD_INT 2
37333: NEG
37334: PUSH
37335: LD_INT 1
37337: PUSH
37338: EMPTY
37339: LIST
37340: LIST
37341: PUSH
37342: LD_INT 3
37344: NEG
37345: PUSH
37346: LD_INT 0
37348: PUSH
37349: EMPTY
37350: LIST
37351: LIST
37352: PUSH
37353: LD_INT 3
37355: NEG
37356: PUSH
37357: LD_INT 1
37359: NEG
37360: PUSH
37361: EMPTY
37362: LIST
37363: LIST
37364: PUSH
37365: EMPTY
37366: LIST
37367: LIST
37368: LIST
37369: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37370: LD_ADDR_VAR 0 22
37374: PUSH
37375: LD_INT 2
37377: NEG
37378: PUSH
37379: LD_INT 3
37381: NEG
37382: PUSH
37383: EMPTY
37384: LIST
37385: LIST
37386: PUSH
37387: LD_INT 3
37389: NEG
37390: PUSH
37391: LD_INT 2
37393: NEG
37394: PUSH
37395: EMPTY
37396: LIST
37397: LIST
37398: PUSH
37399: LD_INT 3
37401: NEG
37402: PUSH
37403: LD_INT 3
37405: NEG
37406: PUSH
37407: EMPTY
37408: LIST
37409: LIST
37410: PUSH
37411: EMPTY
37412: LIST
37413: LIST
37414: LIST
37415: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
37416: LD_ADDR_VAR 0 23
37420: PUSH
37421: LD_INT 0
37423: PUSH
37424: LD_INT 3
37426: NEG
37427: PUSH
37428: EMPTY
37429: LIST
37430: LIST
37431: PUSH
37432: LD_INT 1
37434: NEG
37435: PUSH
37436: LD_INT 4
37438: NEG
37439: PUSH
37440: EMPTY
37441: LIST
37442: LIST
37443: PUSH
37444: LD_INT 1
37446: PUSH
37447: LD_INT 3
37449: NEG
37450: PUSH
37451: EMPTY
37452: LIST
37453: LIST
37454: PUSH
37455: EMPTY
37456: LIST
37457: LIST
37458: LIST
37459: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
37460: LD_ADDR_VAR 0 24
37464: PUSH
37465: LD_INT 3
37467: PUSH
37468: LD_INT 0
37470: PUSH
37471: EMPTY
37472: LIST
37473: LIST
37474: PUSH
37475: LD_INT 3
37477: PUSH
37478: LD_INT 1
37480: NEG
37481: PUSH
37482: EMPTY
37483: LIST
37484: LIST
37485: PUSH
37486: LD_INT 4
37488: PUSH
37489: LD_INT 1
37491: PUSH
37492: EMPTY
37493: LIST
37494: LIST
37495: PUSH
37496: EMPTY
37497: LIST
37498: LIST
37499: LIST
37500: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
37501: LD_ADDR_VAR 0 25
37505: PUSH
37506: LD_INT 3
37508: PUSH
37509: LD_INT 3
37511: PUSH
37512: EMPTY
37513: LIST
37514: LIST
37515: PUSH
37516: LD_INT 4
37518: PUSH
37519: LD_INT 3
37521: PUSH
37522: EMPTY
37523: LIST
37524: LIST
37525: PUSH
37526: LD_INT 3
37528: PUSH
37529: LD_INT 4
37531: PUSH
37532: EMPTY
37533: LIST
37534: LIST
37535: PUSH
37536: EMPTY
37537: LIST
37538: LIST
37539: LIST
37540: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
37541: LD_ADDR_VAR 0 26
37545: PUSH
37546: LD_INT 0
37548: PUSH
37549: LD_INT 3
37551: PUSH
37552: EMPTY
37553: LIST
37554: LIST
37555: PUSH
37556: LD_INT 1
37558: PUSH
37559: LD_INT 4
37561: PUSH
37562: EMPTY
37563: LIST
37564: LIST
37565: PUSH
37566: LD_INT 1
37568: NEG
37569: PUSH
37570: LD_INT 3
37572: PUSH
37573: EMPTY
37574: LIST
37575: LIST
37576: PUSH
37577: EMPTY
37578: LIST
37579: LIST
37580: LIST
37581: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
37582: LD_ADDR_VAR 0 27
37586: PUSH
37587: LD_INT 3
37589: NEG
37590: PUSH
37591: LD_INT 0
37593: PUSH
37594: EMPTY
37595: LIST
37596: LIST
37597: PUSH
37598: LD_INT 3
37600: NEG
37601: PUSH
37602: LD_INT 1
37604: PUSH
37605: EMPTY
37606: LIST
37607: LIST
37608: PUSH
37609: LD_INT 4
37611: NEG
37612: PUSH
37613: LD_INT 1
37615: NEG
37616: PUSH
37617: EMPTY
37618: LIST
37619: LIST
37620: PUSH
37621: EMPTY
37622: LIST
37623: LIST
37624: LIST
37625: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
37626: LD_ADDR_VAR 0 28
37630: PUSH
37631: LD_INT 3
37633: NEG
37634: PUSH
37635: LD_INT 3
37637: NEG
37638: PUSH
37639: EMPTY
37640: LIST
37641: LIST
37642: PUSH
37643: LD_INT 3
37645: NEG
37646: PUSH
37647: LD_INT 4
37649: NEG
37650: PUSH
37651: EMPTY
37652: LIST
37653: LIST
37654: PUSH
37655: LD_INT 4
37657: NEG
37658: PUSH
37659: LD_INT 3
37661: NEG
37662: PUSH
37663: EMPTY
37664: LIST
37665: LIST
37666: PUSH
37667: EMPTY
37668: LIST
37669: LIST
37670: LIST
37671: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
37672: LD_ADDR_VAR 0 29
37676: PUSH
37677: LD_INT 1
37679: NEG
37680: PUSH
37681: LD_INT 3
37683: NEG
37684: PUSH
37685: EMPTY
37686: LIST
37687: LIST
37688: PUSH
37689: LD_INT 0
37691: PUSH
37692: LD_INT 3
37694: NEG
37695: PUSH
37696: EMPTY
37697: LIST
37698: LIST
37699: PUSH
37700: LD_INT 1
37702: PUSH
37703: LD_INT 2
37705: NEG
37706: PUSH
37707: EMPTY
37708: LIST
37709: LIST
37710: PUSH
37711: LD_INT 1
37713: NEG
37714: PUSH
37715: LD_INT 4
37717: NEG
37718: PUSH
37719: EMPTY
37720: LIST
37721: LIST
37722: PUSH
37723: LD_INT 0
37725: PUSH
37726: LD_INT 4
37728: NEG
37729: PUSH
37730: EMPTY
37731: LIST
37732: LIST
37733: PUSH
37734: LD_INT 1
37736: PUSH
37737: LD_INT 3
37739: NEG
37740: PUSH
37741: EMPTY
37742: LIST
37743: LIST
37744: PUSH
37745: LD_INT 1
37747: NEG
37748: PUSH
37749: LD_INT 5
37751: NEG
37752: PUSH
37753: EMPTY
37754: LIST
37755: LIST
37756: PUSH
37757: LD_INT 0
37759: PUSH
37760: LD_INT 5
37762: NEG
37763: PUSH
37764: EMPTY
37765: LIST
37766: LIST
37767: PUSH
37768: LD_INT 1
37770: PUSH
37771: LD_INT 4
37773: NEG
37774: PUSH
37775: EMPTY
37776: LIST
37777: LIST
37778: PUSH
37779: LD_INT 1
37781: NEG
37782: PUSH
37783: LD_INT 6
37785: NEG
37786: PUSH
37787: EMPTY
37788: LIST
37789: LIST
37790: PUSH
37791: LD_INT 0
37793: PUSH
37794: LD_INT 6
37796: NEG
37797: PUSH
37798: EMPTY
37799: LIST
37800: LIST
37801: PUSH
37802: LD_INT 1
37804: PUSH
37805: LD_INT 5
37807: NEG
37808: PUSH
37809: EMPTY
37810: LIST
37811: LIST
37812: PUSH
37813: EMPTY
37814: LIST
37815: LIST
37816: LIST
37817: LIST
37818: LIST
37819: LIST
37820: LIST
37821: LIST
37822: LIST
37823: LIST
37824: LIST
37825: LIST
37826: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
37827: LD_ADDR_VAR 0 30
37831: PUSH
37832: LD_INT 2
37834: PUSH
37835: LD_INT 1
37837: NEG
37838: PUSH
37839: EMPTY
37840: LIST
37841: LIST
37842: PUSH
37843: LD_INT 3
37845: PUSH
37846: LD_INT 0
37848: PUSH
37849: EMPTY
37850: LIST
37851: LIST
37852: PUSH
37853: LD_INT 3
37855: PUSH
37856: LD_INT 1
37858: PUSH
37859: EMPTY
37860: LIST
37861: LIST
37862: PUSH
37863: LD_INT 3
37865: PUSH
37866: LD_INT 1
37868: NEG
37869: PUSH
37870: EMPTY
37871: LIST
37872: LIST
37873: PUSH
37874: LD_INT 4
37876: PUSH
37877: LD_INT 0
37879: PUSH
37880: EMPTY
37881: LIST
37882: LIST
37883: PUSH
37884: LD_INT 4
37886: PUSH
37887: LD_INT 1
37889: PUSH
37890: EMPTY
37891: LIST
37892: LIST
37893: PUSH
37894: LD_INT 4
37896: PUSH
37897: LD_INT 1
37899: NEG
37900: PUSH
37901: EMPTY
37902: LIST
37903: LIST
37904: PUSH
37905: LD_INT 5
37907: PUSH
37908: LD_INT 0
37910: PUSH
37911: EMPTY
37912: LIST
37913: LIST
37914: PUSH
37915: LD_INT 5
37917: PUSH
37918: LD_INT 1
37920: PUSH
37921: EMPTY
37922: LIST
37923: LIST
37924: PUSH
37925: LD_INT 5
37927: PUSH
37928: LD_INT 1
37930: NEG
37931: PUSH
37932: EMPTY
37933: LIST
37934: LIST
37935: PUSH
37936: LD_INT 6
37938: PUSH
37939: LD_INT 0
37941: PUSH
37942: EMPTY
37943: LIST
37944: LIST
37945: PUSH
37946: LD_INT 6
37948: PUSH
37949: LD_INT 1
37951: PUSH
37952: EMPTY
37953: LIST
37954: LIST
37955: PUSH
37956: EMPTY
37957: LIST
37958: LIST
37959: LIST
37960: LIST
37961: LIST
37962: LIST
37963: LIST
37964: LIST
37965: LIST
37966: LIST
37967: LIST
37968: LIST
37969: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
37970: LD_ADDR_VAR 0 31
37974: PUSH
37975: LD_INT 3
37977: PUSH
37978: LD_INT 2
37980: PUSH
37981: EMPTY
37982: LIST
37983: LIST
37984: PUSH
37985: LD_INT 3
37987: PUSH
37988: LD_INT 3
37990: PUSH
37991: EMPTY
37992: LIST
37993: LIST
37994: PUSH
37995: LD_INT 2
37997: PUSH
37998: LD_INT 3
38000: PUSH
38001: EMPTY
38002: LIST
38003: LIST
38004: PUSH
38005: LD_INT 4
38007: PUSH
38008: LD_INT 3
38010: PUSH
38011: EMPTY
38012: LIST
38013: LIST
38014: PUSH
38015: LD_INT 4
38017: PUSH
38018: LD_INT 4
38020: PUSH
38021: EMPTY
38022: LIST
38023: LIST
38024: PUSH
38025: LD_INT 3
38027: PUSH
38028: LD_INT 4
38030: PUSH
38031: EMPTY
38032: LIST
38033: LIST
38034: PUSH
38035: LD_INT 5
38037: PUSH
38038: LD_INT 4
38040: PUSH
38041: EMPTY
38042: LIST
38043: LIST
38044: PUSH
38045: LD_INT 5
38047: PUSH
38048: LD_INT 5
38050: PUSH
38051: EMPTY
38052: LIST
38053: LIST
38054: PUSH
38055: LD_INT 4
38057: PUSH
38058: LD_INT 5
38060: PUSH
38061: EMPTY
38062: LIST
38063: LIST
38064: PUSH
38065: LD_INT 6
38067: PUSH
38068: LD_INT 5
38070: PUSH
38071: EMPTY
38072: LIST
38073: LIST
38074: PUSH
38075: LD_INT 6
38077: PUSH
38078: LD_INT 6
38080: PUSH
38081: EMPTY
38082: LIST
38083: LIST
38084: PUSH
38085: LD_INT 5
38087: PUSH
38088: LD_INT 6
38090: PUSH
38091: EMPTY
38092: LIST
38093: LIST
38094: PUSH
38095: EMPTY
38096: LIST
38097: LIST
38098: LIST
38099: LIST
38100: LIST
38101: LIST
38102: LIST
38103: LIST
38104: LIST
38105: LIST
38106: LIST
38107: LIST
38108: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
38109: LD_ADDR_VAR 0 32
38113: PUSH
38114: LD_INT 1
38116: PUSH
38117: LD_INT 3
38119: PUSH
38120: EMPTY
38121: LIST
38122: LIST
38123: PUSH
38124: LD_INT 0
38126: PUSH
38127: LD_INT 3
38129: PUSH
38130: EMPTY
38131: LIST
38132: LIST
38133: PUSH
38134: LD_INT 1
38136: NEG
38137: PUSH
38138: LD_INT 2
38140: PUSH
38141: EMPTY
38142: LIST
38143: LIST
38144: PUSH
38145: LD_INT 1
38147: PUSH
38148: LD_INT 4
38150: PUSH
38151: EMPTY
38152: LIST
38153: LIST
38154: PUSH
38155: LD_INT 0
38157: PUSH
38158: LD_INT 4
38160: PUSH
38161: EMPTY
38162: LIST
38163: LIST
38164: PUSH
38165: LD_INT 1
38167: NEG
38168: PUSH
38169: LD_INT 3
38171: PUSH
38172: EMPTY
38173: LIST
38174: LIST
38175: PUSH
38176: LD_INT 1
38178: PUSH
38179: LD_INT 5
38181: PUSH
38182: EMPTY
38183: LIST
38184: LIST
38185: PUSH
38186: LD_INT 0
38188: PUSH
38189: LD_INT 5
38191: PUSH
38192: EMPTY
38193: LIST
38194: LIST
38195: PUSH
38196: LD_INT 1
38198: NEG
38199: PUSH
38200: LD_INT 4
38202: PUSH
38203: EMPTY
38204: LIST
38205: LIST
38206: PUSH
38207: LD_INT 1
38209: PUSH
38210: LD_INT 6
38212: PUSH
38213: EMPTY
38214: LIST
38215: LIST
38216: PUSH
38217: LD_INT 0
38219: PUSH
38220: LD_INT 6
38222: PUSH
38223: EMPTY
38224: LIST
38225: LIST
38226: PUSH
38227: LD_INT 1
38229: NEG
38230: PUSH
38231: LD_INT 5
38233: PUSH
38234: EMPTY
38235: LIST
38236: LIST
38237: PUSH
38238: EMPTY
38239: LIST
38240: LIST
38241: LIST
38242: LIST
38243: LIST
38244: LIST
38245: LIST
38246: LIST
38247: LIST
38248: LIST
38249: LIST
38250: LIST
38251: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
38252: LD_ADDR_VAR 0 33
38256: PUSH
38257: LD_INT 2
38259: NEG
38260: PUSH
38261: LD_INT 1
38263: PUSH
38264: EMPTY
38265: LIST
38266: LIST
38267: PUSH
38268: LD_INT 3
38270: NEG
38271: PUSH
38272: LD_INT 0
38274: PUSH
38275: EMPTY
38276: LIST
38277: LIST
38278: PUSH
38279: LD_INT 3
38281: NEG
38282: PUSH
38283: LD_INT 1
38285: NEG
38286: PUSH
38287: EMPTY
38288: LIST
38289: LIST
38290: PUSH
38291: LD_INT 3
38293: NEG
38294: PUSH
38295: LD_INT 1
38297: PUSH
38298: EMPTY
38299: LIST
38300: LIST
38301: PUSH
38302: LD_INT 4
38304: NEG
38305: PUSH
38306: LD_INT 0
38308: PUSH
38309: EMPTY
38310: LIST
38311: LIST
38312: PUSH
38313: LD_INT 4
38315: NEG
38316: PUSH
38317: LD_INT 1
38319: NEG
38320: PUSH
38321: EMPTY
38322: LIST
38323: LIST
38324: PUSH
38325: LD_INT 4
38327: NEG
38328: PUSH
38329: LD_INT 1
38331: PUSH
38332: EMPTY
38333: LIST
38334: LIST
38335: PUSH
38336: LD_INT 5
38338: NEG
38339: PUSH
38340: LD_INT 0
38342: PUSH
38343: EMPTY
38344: LIST
38345: LIST
38346: PUSH
38347: LD_INT 5
38349: NEG
38350: PUSH
38351: LD_INT 1
38353: NEG
38354: PUSH
38355: EMPTY
38356: LIST
38357: LIST
38358: PUSH
38359: LD_INT 5
38361: NEG
38362: PUSH
38363: LD_INT 1
38365: PUSH
38366: EMPTY
38367: LIST
38368: LIST
38369: PUSH
38370: LD_INT 6
38372: NEG
38373: PUSH
38374: LD_INT 0
38376: PUSH
38377: EMPTY
38378: LIST
38379: LIST
38380: PUSH
38381: LD_INT 6
38383: NEG
38384: PUSH
38385: LD_INT 1
38387: NEG
38388: PUSH
38389: EMPTY
38390: LIST
38391: LIST
38392: PUSH
38393: EMPTY
38394: LIST
38395: LIST
38396: LIST
38397: LIST
38398: LIST
38399: LIST
38400: LIST
38401: LIST
38402: LIST
38403: LIST
38404: LIST
38405: LIST
38406: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
38407: LD_ADDR_VAR 0 34
38411: PUSH
38412: LD_INT 2
38414: NEG
38415: PUSH
38416: LD_INT 3
38418: NEG
38419: PUSH
38420: EMPTY
38421: LIST
38422: LIST
38423: PUSH
38424: LD_INT 3
38426: NEG
38427: PUSH
38428: LD_INT 2
38430: NEG
38431: PUSH
38432: EMPTY
38433: LIST
38434: LIST
38435: PUSH
38436: LD_INT 3
38438: NEG
38439: PUSH
38440: LD_INT 3
38442: NEG
38443: PUSH
38444: EMPTY
38445: LIST
38446: LIST
38447: PUSH
38448: LD_INT 3
38450: NEG
38451: PUSH
38452: LD_INT 4
38454: NEG
38455: PUSH
38456: EMPTY
38457: LIST
38458: LIST
38459: PUSH
38460: LD_INT 4
38462: NEG
38463: PUSH
38464: LD_INT 3
38466: NEG
38467: PUSH
38468: EMPTY
38469: LIST
38470: LIST
38471: PUSH
38472: LD_INT 4
38474: NEG
38475: PUSH
38476: LD_INT 4
38478: NEG
38479: PUSH
38480: EMPTY
38481: LIST
38482: LIST
38483: PUSH
38484: LD_INT 4
38486: NEG
38487: PUSH
38488: LD_INT 5
38490: NEG
38491: PUSH
38492: EMPTY
38493: LIST
38494: LIST
38495: PUSH
38496: LD_INT 5
38498: NEG
38499: PUSH
38500: LD_INT 4
38502: NEG
38503: PUSH
38504: EMPTY
38505: LIST
38506: LIST
38507: PUSH
38508: LD_INT 5
38510: NEG
38511: PUSH
38512: LD_INT 5
38514: NEG
38515: PUSH
38516: EMPTY
38517: LIST
38518: LIST
38519: PUSH
38520: LD_INT 5
38522: NEG
38523: PUSH
38524: LD_INT 6
38526: NEG
38527: PUSH
38528: EMPTY
38529: LIST
38530: LIST
38531: PUSH
38532: LD_INT 6
38534: NEG
38535: PUSH
38536: LD_INT 5
38538: NEG
38539: PUSH
38540: EMPTY
38541: LIST
38542: LIST
38543: PUSH
38544: LD_INT 6
38546: NEG
38547: PUSH
38548: LD_INT 6
38550: NEG
38551: PUSH
38552: EMPTY
38553: LIST
38554: LIST
38555: PUSH
38556: EMPTY
38557: LIST
38558: LIST
38559: LIST
38560: LIST
38561: LIST
38562: LIST
38563: LIST
38564: LIST
38565: LIST
38566: LIST
38567: LIST
38568: LIST
38569: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
38570: LD_ADDR_VAR 0 41
38574: PUSH
38575: LD_INT 0
38577: PUSH
38578: LD_INT 2
38580: NEG
38581: PUSH
38582: EMPTY
38583: LIST
38584: LIST
38585: PUSH
38586: LD_INT 1
38588: NEG
38589: PUSH
38590: LD_INT 3
38592: NEG
38593: PUSH
38594: EMPTY
38595: LIST
38596: LIST
38597: PUSH
38598: LD_INT 1
38600: PUSH
38601: LD_INT 2
38603: NEG
38604: PUSH
38605: EMPTY
38606: LIST
38607: LIST
38608: PUSH
38609: EMPTY
38610: LIST
38611: LIST
38612: LIST
38613: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
38614: LD_ADDR_VAR 0 42
38618: PUSH
38619: LD_INT 2
38621: PUSH
38622: LD_INT 0
38624: PUSH
38625: EMPTY
38626: LIST
38627: LIST
38628: PUSH
38629: LD_INT 2
38631: PUSH
38632: LD_INT 1
38634: NEG
38635: PUSH
38636: EMPTY
38637: LIST
38638: LIST
38639: PUSH
38640: LD_INT 3
38642: PUSH
38643: LD_INT 1
38645: PUSH
38646: EMPTY
38647: LIST
38648: LIST
38649: PUSH
38650: EMPTY
38651: LIST
38652: LIST
38653: LIST
38654: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
38655: LD_ADDR_VAR 0 43
38659: PUSH
38660: LD_INT 2
38662: PUSH
38663: LD_INT 2
38665: PUSH
38666: EMPTY
38667: LIST
38668: LIST
38669: PUSH
38670: LD_INT 3
38672: PUSH
38673: LD_INT 2
38675: PUSH
38676: EMPTY
38677: LIST
38678: LIST
38679: PUSH
38680: LD_INT 2
38682: PUSH
38683: LD_INT 3
38685: PUSH
38686: EMPTY
38687: LIST
38688: LIST
38689: PUSH
38690: EMPTY
38691: LIST
38692: LIST
38693: LIST
38694: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
38695: LD_ADDR_VAR 0 44
38699: PUSH
38700: LD_INT 0
38702: PUSH
38703: LD_INT 2
38705: PUSH
38706: EMPTY
38707: LIST
38708: LIST
38709: PUSH
38710: LD_INT 1
38712: PUSH
38713: LD_INT 3
38715: PUSH
38716: EMPTY
38717: LIST
38718: LIST
38719: PUSH
38720: LD_INT 1
38722: NEG
38723: PUSH
38724: LD_INT 2
38726: PUSH
38727: EMPTY
38728: LIST
38729: LIST
38730: PUSH
38731: EMPTY
38732: LIST
38733: LIST
38734: LIST
38735: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38736: LD_ADDR_VAR 0 45
38740: PUSH
38741: LD_INT 2
38743: NEG
38744: PUSH
38745: LD_INT 0
38747: PUSH
38748: EMPTY
38749: LIST
38750: LIST
38751: PUSH
38752: LD_INT 2
38754: NEG
38755: PUSH
38756: LD_INT 1
38758: PUSH
38759: EMPTY
38760: LIST
38761: LIST
38762: PUSH
38763: LD_INT 3
38765: NEG
38766: PUSH
38767: LD_INT 1
38769: NEG
38770: PUSH
38771: EMPTY
38772: LIST
38773: LIST
38774: PUSH
38775: EMPTY
38776: LIST
38777: LIST
38778: LIST
38779: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
38780: LD_ADDR_VAR 0 46
38784: PUSH
38785: LD_INT 2
38787: NEG
38788: PUSH
38789: LD_INT 2
38791: NEG
38792: PUSH
38793: EMPTY
38794: LIST
38795: LIST
38796: PUSH
38797: LD_INT 2
38799: NEG
38800: PUSH
38801: LD_INT 3
38803: NEG
38804: PUSH
38805: EMPTY
38806: LIST
38807: LIST
38808: PUSH
38809: LD_INT 3
38811: NEG
38812: PUSH
38813: LD_INT 2
38815: NEG
38816: PUSH
38817: EMPTY
38818: LIST
38819: LIST
38820: PUSH
38821: EMPTY
38822: LIST
38823: LIST
38824: LIST
38825: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
38826: LD_ADDR_VAR 0 47
38830: PUSH
38831: LD_INT 2
38833: NEG
38834: PUSH
38835: LD_INT 3
38837: NEG
38838: PUSH
38839: EMPTY
38840: LIST
38841: LIST
38842: PUSH
38843: LD_INT 1
38845: NEG
38846: PUSH
38847: LD_INT 3
38849: NEG
38850: PUSH
38851: EMPTY
38852: LIST
38853: LIST
38854: PUSH
38855: EMPTY
38856: LIST
38857: LIST
38858: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
38859: LD_ADDR_VAR 0 48
38863: PUSH
38864: LD_INT 1
38866: PUSH
38867: LD_INT 2
38869: NEG
38870: PUSH
38871: EMPTY
38872: LIST
38873: LIST
38874: PUSH
38875: LD_INT 2
38877: PUSH
38878: LD_INT 1
38880: NEG
38881: PUSH
38882: EMPTY
38883: LIST
38884: LIST
38885: PUSH
38886: EMPTY
38887: LIST
38888: LIST
38889: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
38890: LD_ADDR_VAR 0 49
38894: PUSH
38895: LD_INT 3
38897: PUSH
38898: LD_INT 1
38900: PUSH
38901: EMPTY
38902: LIST
38903: LIST
38904: PUSH
38905: LD_INT 3
38907: PUSH
38908: LD_INT 2
38910: PUSH
38911: EMPTY
38912: LIST
38913: LIST
38914: PUSH
38915: EMPTY
38916: LIST
38917: LIST
38918: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
38919: LD_ADDR_VAR 0 50
38923: PUSH
38924: LD_INT 2
38926: PUSH
38927: LD_INT 3
38929: PUSH
38930: EMPTY
38931: LIST
38932: LIST
38933: PUSH
38934: LD_INT 1
38936: PUSH
38937: LD_INT 3
38939: PUSH
38940: EMPTY
38941: LIST
38942: LIST
38943: PUSH
38944: EMPTY
38945: LIST
38946: LIST
38947: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
38948: LD_ADDR_VAR 0 51
38952: PUSH
38953: LD_INT 1
38955: NEG
38956: PUSH
38957: LD_INT 2
38959: PUSH
38960: EMPTY
38961: LIST
38962: LIST
38963: PUSH
38964: LD_INT 2
38966: NEG
38967: PUSH
38968: LD_INT 1
38970: PUSH
38971: EMPTY
38972: LIST
38973: LIST
38974: PUSH
38975: EMPTY
38976: LIST
38977: LIST
38978: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
38979: LD_ADDR_VAR 0 52
38983: PUSH
38984: LD_INT 3
38986: NEG
38987: PUSH
38988: LD_INT 1
38990: NEG
38991: PUSH
38992: EMPTY
38993: LIST
38994: LIST
38995: PUSH
38996: LD_INT 3
38998: NEG
38999: PUSH
39000: LD_INT 2
39002: NEG
39003: PUSH
39004: EMPTY
39005: LIST
39006: LIST
39007: PUSH
39008: EMPTY
39009: LIST
39010: LIST
39011: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39012: LD_ADDR_VAR 0 53
39016: PUSH
39017: LD_INT 1
39019: NEG
39020: PUSH
39021: LD_INT 3
39023: NEG
39024: PUSH
39025: EMPTY
39026: LIST
39027: LIST
39028: PUSH
39029: LD_INT 0
39031: PUSH
39032: LD_INT 3
39034: NEG
39035: PUSH
39036: EMPTY
39037: LIST
39038: LIST
39039: PUSH
39040: LD_INT 1
39042: PUSH
39043: LD_INT 2
39045: NEG
39046: PUSH
39047: EMPTY
39048: LIST
39049: LIST
39050: PUSH
39051: EMPTY
39052: LIST
39053: LIST
39054: LIST
39055: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39056: LD_ADDR_VAR 0 54
39060: PUSH
39061: LD_INT 2
39063: PUSH
39064: LD_INT 1
39066: NEG
39067: PUSH
39068: EMPTY
39069: LIST
39070: LIST
39071: PUSH
39072: LD_INT 3
39074: PUSH
39075: LD_INT 0
39077: PUSH
39078: EMPTY
39079: LIST
39080: LIST
39081: PUSH
39082: LD_INT 3
39084: PUSH
39085: LD_INT 1
39087: PUSH
39088: EMPTY
39089: LIST
39090: LIST
39091: PUSH
39092: EMPTY
39093: LIST
39094: LIST
39095: LIST
39096: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39097: LD_ADDR_VAR 0 55
39101: PUSH
39102: LD_INT 3
39104: PUSH
39105: LD_INT 2
39107: PUSH
39108: EMPTY
39109: LIST
39110: LIST
39111: PUSH
39112: LD_INT 3
39114: PUSH
39115: LD_INT 3
39117: PUSH
39118: EMPTY
39119: LIST
39120: LIST
39121: PUSH
39122: LD_INT 2
39124: PUSH
39125: LD_INT 3
39127: PUSH
39128: EMPTY
39129: LIST
39130: LIST
39131: PUSH
39132: EMPTY
39133: LIST
39134: LIST
39135: LIST
39136: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39137: LD_ADDR_VAR 0 56
39141: PUSH
39142: LD_INT 1
39144: PUSH
39145: LD_INT 3
39147: PUSH
39148: EMPTY
39149: LIST
39150: LIST
39151: PUSH
39152: LD_INT 0
39154: PUSH
39155: LD_INT 3
39157: PUSH
39158: EMPTY
39159: LIST
39160: LIST
39161: PUSH
39162: LD_INT 1
39164: NEG
39165: PUSH
39166: LD_INT 2
39168: PUSH
39169: EMPTY
39170: LIST
39171: LIST
39172: PUSH
39173: EMPTY
39174: LIST
39175: LIST
39176: LIST
39177: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39178: LD_ADDR_VAR 0 57
39182: PUSH
39183: LD_INT 2
39185: NEG
39186: PUSH
39187: LD_INT 1
39189: PUSH
39190: EMPTY
39191: LIST
39192: LIST
39193: PUSH
39194: LD_INT 3
39196: NEG
39197: PUSH
39198: LD_INT 0
39200: PUSH
39201: EMPTY
39202: LIST
39203: LIST
39204: PUSH
39205: LD_INT 3
39207: NEG
39208: PUSH
39209: LD_INT 1
39211: NEG
39212: PUSH
39213: EMPTY
39214: LIST
39215: LIST
39216: PUSH
39217: EMPTY
39218: LIST
39219: LIST
39220: LIST
39221: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39222: LD_ADDR_VAR 0 58
39226: PUSH
39227: LD_INT 2
39229: NEG
39230: PUSH
39231: LD_INT 3
39233: NEG
39234: PUSH
39235: EMPTY
39236: LIST
39237: LIST
39238: PUSH
39239: LD_INT 3
39241: NEG
39242: PUSH
39243: LD_INT 2
39245: NEG
39246: PUSH
39247: EMPTY
39248: LIST
39249: LIST
39250: PUSH
39251: LD_INT 3
39253: NEG
39254: PUSH
39255: LD_INT 3
39257: NEG
39258: PUSH
39259: EMPTY
39260: LIST
39261: LIST
39262: PUSH
39263: EMPTY
39264: LIST
39265: LIST
39266: LIST
39267: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
39268: LD_ADDR_VAR 0 59
39272: PUSH
39273: LD_INT 1
39275: NEG
39276: PUSH
39277: LD_INT 2
39279: NEG
39280: PUSH
39281: EMPTY
39282: LIST
39283: LIST
39284: PUSH
39285: LD_INT 0
39287: PUSH
39288: LD_INT 2
39290: NEG
39291: PUSH
39292: EMPTY
39293: LIST
39294: LIST
39295: PUSH
39296: LD_INT 1
39298: PUSH
39299: LD_INT 1
39301: NEG
39302: PUSH
39303: EMPTY
39304: LIST
39305: LIST
39306: PUSH
39307: EMPTY
39308: LIST
39309: LIST
39310: LIST
39311: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
39312: LD_ADDR_VAR 0 60
39316: PUSH
39317: LD_INT 1
39319: PUSH
39320: LD_INT 1
39322: NEG
39323: PUSH
39324: EMPTY
39325: LIST
39326: LIST
39327: PUSH
39328: LD_INT 2
39330: PUSH
39331: LD_INT 0
39333: PUSH
39334: EMPTY
39335: LIST
39336: LIST
39337: PUSH
39338: LD_INT 2
39340: PUSH
39341: LD_INT 1
39343: PUSH
39344: EMPTY
39345: LIST
39346: LIST
39347: PUSH
39348: EMPTY
39349: LIST
39350: LIST
39351: LIST
39352: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
39353: LD_ADDR_VAR 0 61
39357: PUSH
39358: LD_INT 2
39360: PUSH
39361: LD_INT 1
39363: PUSH
39364: EMPTY
39365: LIST
39366: LIST
39367: PUSH
39368: LD_INT 2
39370: PUSH
39371: LD_INT 2
39373: PUSH
39374: EMPTY
39375: LIST
39376: LIST
39377: PUSH
39378: LD_INT 1
39380: PUSH
39381: LD_INT 2
39383: PUSH
39384: EMPTY
39385: LIST
39386: LIST
39387: PUSH
39388: EMPTY
39389: LIST
39390: LIST
39391: LIST
39392: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
39393: LD_ADDR_VAR 0 62
39397: PUSH
39398: LD_INT 1
39400: PUSH
39401: LD_INT 2
39403: PUSH
39404: EMPTY
39405: LIST
39406: LIST
39407: PUSH
39408: LD_INT 0
39410: PUSH
39411: LD_INT 2
39413: PUSH
39414: EMPTY
39415: LIST
39416: LIST
39417: PUSH
39418: LD_INT 1
39420: NEG
39421: PUSH
39422: LD_INT 1
39424: PUSH
39425: EMPTY
39426: LIST
39427: LIST
39428: PUSH
39429: EMPTY
39430: LIST
39431: LIST
39432: LIST
39433: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
39434: LD_ADDR_VAR 0 63
39438: PUSH
39439: LD_INT 1
39441: NEG
39442: PUSH
39443: LD_INT 1
39445: PUSH
39446: EMPTY
39447: LIST
39448: LIST
39449: PUSH
39450: LD_INT 2
39452: NEG
39453: PUSH
39454: LD_INT 0
39456: PUSH
39457: EMPTY
39458: LIST
39459: LIST
39460: PUSH
39461: LD_INT 2
39463: NEG
39464: PUSH
39465: LD_INT 1
39467: NEG
39468: PUSH
39469: EMPTY
39470: LIST
39471: LIST
39472: PUSH
39473: EMPTY
39474: LIST
39475: LIST
39476: LIST
39477: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39478: LD_ADDR_VAR 0 64
39482: PUSH
39483: LD_INT 1
39485: NEG
39486: PUSH
39487: LD_INT 2
39489: NEG
39490: PUSH
39491: EMPTY
39492: LIST
39493: LIST
39494: PUSH
39495: LD_INT 2
39497: NEG
39498: PUSH
39499: LD_INT 1
39501: NEG
39502: PUSH
39503: EMPTY
39504: LIST
39505: LIST
39506: PUSH
39507: LD_INT 2
39509: NEG
39510: PUSH
39511: LD_INT 2
39513: NEG
39514: PUSH
39515: EMPTY
39516: LIST
39517: LIST
39518: PUSH
39519: EMPTY
39520: LIST
39521: LIST
39522: LIST
39523: ST_TO_ADDR
// end ; 2 :
39524: GO 42790
39526: LD_INT 2
39528: DOUBLE
39529: EQUAL
39530: IFTRUE 39534
39532: GO 42789
39534: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
39535: LD_ADDR_VAR 0 29
39539: PUSH
39540: LD_INT 4
39542: PUSH
39543: LD_INT 0
39545: PUSH
39546: EMPTY
39547: LIST
39548: LIST
39549: PUSH
39550: LD_INT 4
39552: PUSH
39553: LD_INT 1
39555: NEG
39556: PUSH
39557: EMPTY
39558: LIST
39559: LIST
39560: PUSH
39561: LD_INT 5
39563: PUSH
39564: LD_INT 0
39566: PUSH
39567: EMPTY
39568: LIST
39569: LIST
39570: PUSH
39571: LD_INT 5
39573: PUSH
39574: LD_INT 1
39576: PUSH
39577: EMPTY
39578: LIST
39579: LIST
39580: PUSH
39581: LD_INT 4
39583: PUSH
39584: LD_INT 1
39586: PUSH
39587: EMPTY
39588: LIST
39589: LIST
39590: PUSH
39591: LD_INT 3
39593: PUSH
39594: LD_INT 0
39596: PUSH
39597: EMPTY
39598: LIST
39599: LIST
39600: PUSH
39601: LD_INT 3
39603: PUSH
39604: LD_INT 1
39606: NEG
39607: PUSH
39608: EMPTY
39609: LIST
39610: LIST
39611: PUSH
39612: LD_INT 3
39614: PUSH
39615: LD_INT 2
39617: NEG
39618: PUSH
39619: EMPTY
39620: LIST
39621: LIST
39622: PUSH
39623: LD_INT 5
39625: PUSH
39626: LD_INT 2
39628: PUSH
39629: EMPTY
39630: LIST
39631: LIST
39632: PUSH
39633: LD_INT 3
39635: PUSH
39636: LD_INT 3
39638: PUSH
39639: EMPTY
39640: LIST
39641: LIST
39642: PUSH
39643: LD_INT 3
39645: PUSH
39646: LD_INT 2
39648: PUSH
39649: EMPTY
39650: LIST
39651: LIST
39652: PUSH
39653: LD_INT 4
39655: PUSH
39656: LD_INT 3
39658: PUSH
39659: EMPTY
39660: LIST
39661: LIST
39662: PUSH
39663: LD_INT 4
39665: PUSH
39666: LD_INT 4
39668: PUSH
39669: EMPTY
39670: LIST
39671: LIST
39672: PUSH
39673: LD_INT 3
39675: PUSH
39676: LD_INT 4
39678: PUSH
39679: EMPTY
39680: LIST
39681: LIST
39682: PUSH
39683: LD_INT 2
39685: PUSH
39686: LD_INT 3
39688: PUSH
39689: EMPTY
39690: LIST
39691: LIST
39692: PUSH
39693: LD_INT 2
39695: PUSH
39696: LD_INT 2
39698: PUSH
39699: EMPTY
39700: LIST
39701: LIST
39702: PUSH
39703: LD_INT 4
39705: PUSH
39706: LD_INT 2
39708: PUSH
39709: EMPTY
39710: LIST
39711: LIST
39712: PUSH
39713: LD_INT 2
39715: PUSH
39716: LD_INT 4
39718: PUSH
39719: EMPTY
39720: LIST
39721: LIST
39722: PUSH
39723: LD_INT 0
39725: PUSH
39726: LD_INT 4
39728: PUSH
39729: EMPTY
39730: LIST
39731: LIST
39732: PUSH
39733: LD_INT 0
39735: PUSH
39736: LD_INT 3
39738: PUSH
39739: EMPTY
39740: LIST
39741: LIST
39742: PUSH
39743: LD_INT 1
39745: PUSH
39746: LD_INT 4
39748: PUSH
39749: EMPTY
39750: LIST
39751: LIST
39752: PUSH
39753: LD_INT 1
39755: PUSH
39756: LD_INT 5
39758: PUSH
39759: EMPTY
39760: LIST
39761: LIST
39762: PUSH
39763: LD_INT 0
39765: PUSH
39766: LD_INT 5
39768: PUSH
39769: EMPTY
39770: LIST
39771: LIST
39772: PUSH
39773: LD_INT 1
39775: NEG
39776: PUSH
39777: LD_INT 4
39779: PUSH
39780: EMPTY
39781: LIST
39782: LIST
39783: PUSH
39784: LD_INT 1
39786: NEG
39787: PUSH
39788: LD_INT 3
39790: PUSH
39791: EMPTY
39792: LIST
39793: LIST
39794: PUSH
39795: LD_INT 2
39797: PUSH
39798: LD_INT 5
39800: PUSH
39801: EMPTY
39802: LIST
39803: LIST
39804: PUSH
39805: LD_INT 2
39807: NEG
39808: PUSH
39809: LD_INT 3
39811: PUSH
39812: EMPTY
39813: LIST
39814: LIST
39815: PUSH
39816: LD_INT 3
39818: NEG
39819: PUSH
39820: LD_INT 0
39822: PUSH
39823: EMPTY
39824: LIST
39825: LIST
39826: PUSH
39827: LD_INT 3
39829: NEG
39830: PUSH
39831: LD_INT 1
39833: NEG
39834: PUSH
39835: EMPTY
39836: LIST
39837: LIST
39838: PUSH
39839: LD_INT 2
39841: NEG
39842: PUSH
39843: LD_INT 0
39845: PUSH
39846: EMPTY
39847: LIST
39848: LIST
39849: PUSH
39850: LD_INT 2
39852: NEG
39853: PUSH
39854: LD_INT 1
39856: PUSH
39857: EMPTY
39858: LIST
39859: LIST
39860: PUSH
39861: LD_INT 3
39863: NEG
39864: PUSH
39865: LD_INT 1
39867: PUSH
39868: EMPTY
39869: LIST
39870: LIST
39871: PUSH
39872: LD_INT 4
39874: NEG
39875: PUSH
39876: LD_INT 0
39878: PUSH
39879: EMPTY
39880: LIST
39881: LIST
39882: PUSH
39883: LD_INT 4
39885: NEG
39886: PUSH
39887: LD_INT 1
39889: NEG
39890: PUSH
39891: EMPTY
39892: LIST
39893: LIST
39894: PUSH
39895: LD_INT 4
39897: NEG
39898: PUSH
39899: LD_INT 2
39901: NEG
39902: PUSH
39903: EMPTY
39904: LIST
39905: LIST
39906: PUSH
39907: LD_INT 2
39909: NEG
39910: PUSH
39911: LD_INT 2
39913: PUSH
39914: EMPTY
39915: LIST
39916: LIST
39917: PUSH
39918: LD_INT 4
39920: NEG
39921: PUSH
39922: LD_INT 4
39924: NEG
39925: PUSH
39926: EMPTY
39927: LIST
39928: LIST
39929: PUSH
39930: LD_INT 4
39932: NEG
39933: PUSH
39934: LD_INT 5
39936: NEG
39937: PUSH
39938: EMPTY
39939: LIST
39940: LIST
39941: PUSH
39942: LD_INT 3
39944: NEG
39945: PUSH
39946: LD_INT 4
39948: NEG
39949: PUSH
39950: EMPTY
39951: LIST
39952: LIST
39953: PUSH
39954: LD_INT 3
39956: NEG
39957: PUSH
39958: LD_INT 3
39960: NEG
39961: PUSH
39962: EMPTY
39963: LIST
39964: LIST
39965: PUSH
39966: LD_INT 4
39968: NEG
39969: PUSH
39970: LD_INT 3
39972: NEG
39973: PUSH
39974: EMPTY
39975: LIST
39976: LIST
39977: PUSH
39978: LD_INT 5
39980: NEG
39981: PUSH
39982: LD_INT 4
39984: NEG
39985: PUSH
39986: EMPTY
39987: LIST
39988: LIST
39989: PUSH
39990: LD_INT 5
39992: NEG
39993: PUSH
39994: LD_INT 5
39996: NEG
39997: PUSH
39998: EMPTY
39999: LIST
40000: LIST
40001: PUSH
40002: LD_INT 3
40004: NEG
40005: PUSH
40006: LD_INT 5
40008: NEG
40009: PUSH
40010: EMPTY
40011: LIST
40012: LIST
40013: PUSH
40014: LD_INT 5
40016: NEG
40017: PUSH
40018: LD_INT 3
40020: NEG
40021: PUSH
40022: EMPTY
40023: LIST
40024: LIST
40025: PUSH
40026: EMPTY
40027: LIST
40028: LIST
40029: LIST
40030: LIST
40031: LIST
40032: LIST
40033: LIST
40034: LIST
40035: LIST
40036: LIST
40037: LIST
40038: LIST
40039: LIST
40040: LIST
40041: LIST
40042: LIST
40043: LIST
40044: LIST
40045: LIST
40046: LIST
40047: LIST
40048: LIST
40049: LIST
40050: LIST
40051: LIST
40052: LIST
40053: LIST
40054: LIST
40055: LIST
40056: LIST
40057: LIST
40058: LIST
40059: LIST
40060: LIST
40061: LIST
40062: LIST
40063: LIST
40064: LIST
40065: LIST
40066: LIST
40067: LIST
40068: LIST
40069: LIST
40070: LIST
40071: LIST
40072: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
40073: LD_ADDR_VAR 0 30
40077: PUSH
40078: LD_INT 4
40080: PUSH
40081: LD_INT 4
40083: PUSH
40084: EMPTY
40085: LIST
40086: LIST
40087: PUSH
40088: LD_INT 4
40090: PUSH
40091: LD_INT 3
40093: PUSH
40094: EMPTY
40095: LIST
40096: LIST
40097: PUSH
40098: LD_INT 5
40100: PUSH
40101: LD_INT 4
40103: PUSH
40104: EMPTY
40105: LIST
40106: LIST
40107: PUSH
40108: LD_INT 5
40110: PUSH
40111: LD_INT 5
40113: PUSH
40114: EMPTY
40115: LIST
40116: LIST
40117: PUSH
40118: LD_INT 4
40120: PUSH
40121: LD_INT 5
40123: PUSH
40124: EMPTY
40125: LIST
40126: LIST
40127: PUSH
40128: LD_INT 3
40130: PUSH
40131: LD_INT 4
40133: PUSH
40134: EMPTY
40135: LIST
40136: LIST
40137: PUSH
40138: LD_INT 3
40140: PUSH
40141: LD_INT 3
40143: PUSH
40144: EMPTY
40145: LIST
40146: LIST
40147: PUSH
40148: LD_INT 5
40150: PUSH
40151: LD_INT 3
40153: PUSH
40154: EMPTY
40155: LIST
40156: LIST
40157: PUSH
40158: LD_INT 3
40160: PUSH
40161: LD_INT 5
40163: PUSH
40164: EMPTY
40165: LIST
40166: LIST
40167: PUSH
40168: LD_INT 0
40170: PUSH
40171: LD_INT 3
40173: PUSH
40174: EMPTY
40175: LIST
40176: LIST
40177: PUSH
40178: LD_INT 0
40180: PUSH
40181: LD_INT 2
40183: PUSH
40184: EMPTY
40185: LIST
40186: LIST
40187: PUSH
40188: LD_INT 1
40190: PUSH
40191: LD_INT 3
40193: PUSH
40194: EMPTY
40195: LIST
40196: LIST
40197: PUSH
40198: LD_INT 1
40200: PUSH
40201: LD_INT 4
40203: PUSH
40204: EMPTY
40205: LIST
40206: LIST
40207: PUSH
40208: LD_INT 0
40210: PUSH
40211: LD_INT 4
40213: PUSH
40214: EMPTY
40215: LIST
40216: LIST
40217: PUSH
40218: LD_INT 1
40220: NEG
40221: PUSH
40222: LD_INT 3
40224: PUSH
40225: EMPTY
40226: LIST
40227: LIST
40228: PUSH
40229: LD_INT 1
40231: NEG
40232: PUSH
40233: LD_INT 2
40235: PUSH
40236: EMPTY
40237: LIST
40238: LIST
40239: PUSH
40240: LD_INT 2
40242: PUSH
40243: LD_INT 4
40245: PUSH
40246: EMPTY
40247: LIST
40248: LIST
40249: PUSH
40250: LD_INT 2
40252: NEG
40253: PUSH
40254: LD_INT 2
40256: PUSH
40257: EMPTY
40258: LIST
40259: LIST
40260: PUSH
40261: LD_INT 4
40263: NEG
40264: PUSH
40265: LD_INT 0
40267: PUSH
40268: EMPTY
40269: LIST
40270: LIST
40271: PUSH
40272: LD_INT 4
40274: NEG
40275: PUSH
40276: LD_INT 1
40278: NEG
40279: PUSH
40280: EMPTY
40281: LIST
40282: LIST
40283: PUSH
40284: LD_INT 3
40286: NEG
40287: PUSH
40288: LD_INT 0
40290: PUSH
40291: EMPTY
40292: LIST
40293: LIST
40294: PUSH
40295: LD_INT 3
40297: NEG
40298: PUSH
40299: LD_INT 1
40301: PUSH
40302: EMPTY
40303: LIST
40304: LIST
40305: PUSH
40306: LD_INT 4
40308: NEG
40309: PUSH
40310: LD_INT 1
40312: PUSH
40313: EMPTY
40314: LIST
40315: LIST
40316: PUSH
40317: LD_INT 5
40319: NEG
40320: PUSH
40321: LD_INT 0
40323: PUSH
40324: EMPTY
40325: LIST
40326: LIST
40327: PUSH
40328: LD_INT 5
40330: NEG
40331: PUSH
40332: LD_INT 1
40334: NEG
40335: PUSH
40336: EMPTY
40337: LIST
40338: LIST
40339: PUSH
40340: LD_INT 5
40342: NEG
40343: PUSH
40344: LD_INT 2
40346: NEG
40347: PUSH
40348: EMPTY
40349: LIST
40350: LIST
40351: PUSH
40352: LD_INT 3
40354: NEG
40355: PUSH
40356: LD_INT 2
40358: PUSH
40359: EMPTY
40360: LIST
40361: LIST
40362: PUSH
40363: LD_INT 3
40365: NEG
40366: PUSH
40367: LD_INT 3
40369: NEG
40370: PUSH
40371: EMPTY
40372: LIST
40373: LIST
40374: PUSH
40375: LD_INT 3
40377: NEG
40378: PUSH
40379: LD_INT 4
40381: NEG
40382: PUSH
40383: EMPTY
40384: LIST
40385: LIST
40386: PUSH
40387: LD_INT 2
40389: NEG
40390: PUSH
40391: LD_INT 3
40393: NEG
40394: PUSH
40395: EMPTY
40396: LIST
40397: LIST
40398: PUSH
40399: LD_INT 2
40401: NEG
40402: PUSH
40403: LD_INT 2
40405: NEG
40406: PUSH
40407: EMPTY
40408: LIST
40409: LIST
40410: PUSH
40411: LD_INT 3
40413: NEG
40414: PUSH
40415: LD_INT 2
40417: NEG
40418: PUSH
40419: EMPTY
40420: LIST
40421: LIST
40422: PUSH
40423: LD_INT 4
40425: NEG
40426: PUSH
40427: LD_INT 3
40429: NEG
40430: PUSH
40431: EMPTY
40432: LIST
40433: LIST
40434: PUSH
40435: LD_INT 4
40437: NEG
40438: PUSH
40439: LD_INT 4
40441: NEG
40442: PUSH
40443: EMPTY
40444: LIST
40445: LIST
40446: PUSH
40447: LD_INT 2
40449: NEG
40450: PUSH
40451: LD_INT 4
40453: NEG
40454: PUSH
40455: EMPTY
40456: LIST
40457: LIST
40458: PUSH
40459: LD_INT 4
40461: NEG
40462: PUSH
40463: LD_INT 2
40465: NEG
40466: PUSH
40467: EMPTY
40468: LIST
40469: LIST
40470: PUSH
40471: LD_INT 0
40473: PUSH
40474: LD_INT 4
40476: NEG
40477: PUSH
40478: EMPTY
40479: LIST
40480: LIST
40481: PUSH
40482: LD_INT 0
40484: PUSH
40485: LD_INT 5
40487: NEG
40488: PUSH
40489: EMPTY
40490: LIST
40491: LIST
40492: PUSH
40493: LD_INT 1
40495: PUSH
40496: LD_INT 4
40498: NEG
40499: PUSH
40500: EMPTY
40501: LIST
40502: LIST
40503: PUSH
40504: LD_INT 1
40506: PUSH
40507: LD_INT 3
40509: NEG
40510: PUSH
40511: EMPTY
40512: LIST
40513: LIST
40514: PUSH
40515: LD_INT 0
40517: PUSH
40518: LD_INT 3
40520: NEG
40521: PUSH
40522: EMPTY
40523: LIST
40524: LIST
40525: PUSH
40526: LD_INT 1
40528: NEG
40529: PUSH
40530: LD_INT 4
40532: NEG
40533: PUSH
40534: EMPTY
40535: LIST
40536: LIST
40537: PUSH
40538: LD_INT 1
40540: NEG
40541: PUSH
40542: LD_INT 5
40544: NEG
40545: PUSH
40546: EMPTY
40547: LIST
40548: LIST
40549: PUSH
40550: LD_INT 2
40552: PUSH
40553: LD_INT 3
40555: NEG
40556: PUSH
40557: EMPTY
40558: LIST
40559: LIST
40560: PUSH
40561: LD_INT 2
40563: NEG
40564: PUSH
40565: LD_INT 5
40567: NEG
40568: PUSH
40569: EMPTY
40570: LIST
40571: LIST
40572: PUSH
40573: EMPTY
40574: LIST
40575: LIST
40576: LIST
40577: LIST
40578: LIST
40579: LIST
40580: LIST
40581: LIST
40582: LIST
40583: LIST
40584: LIST
40585: LIST
40586: LIST
40587: LIST
40588: LIST
40589: LIST
40590: LIST
40591: LIST
40592: LIST
40593: LIST
40594: LIST
40595: LIST
40596: LIST
40597: LIST
40598: LIST
40599: LIST
40600: LIST
40601: LIST
40602: LIST
40603: LIST
40604: LIST
40605: LIST
40606: LIST
40607: LIST
40608: LIST
40609: LIST
40610: LIST
40611: LIST
40612: LIST
40613: LIST
40614: LIST
40615: LIST
40616: LIST
40617: LIST
40618: LIST
40619: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
40620: LD_ADDR_VAR 0 31
40624: PUSH
40625: LD_INT 0
40627: PUSH
40628: LD_INT 4
40630: PUSH
40631: EMPTY
40632: LIST
40633: LIST
40634: PUSH
40635: LD_INT 0
40637: PUSH
40638: LD_INT 3
40640: PUSH
40641: EMPTY
40642: LIST
40643: LIST
40644: PUSH
40645: LD_INT 1
40647: PUSH
40648: LD_INT 4
40650: PUSH
40651: EMPTY
40652: LIST
40653: LIST
40654: PUSH
40655: LD_INT 1
40657: PUSH
40658: LD_INT 5
40660: PUSH
40661: EMPTY
40662: LIST
40663: LIST
40664: PUSH
40665: LD_INT 0
40667: PUSH
40668: LD_INT 5
40670: PUSH
40671: EMPTY
40672: LIST
40673: LIST
40674: PUSH
40675: LD_INT 1
40677: NEG
40678: PUSH
40679: LD_INT 4
40681: PUSH
40682: EMPTY
40683: LIST
40684: LIST
40685: PUSH
40686: LD_INT 1
40688: NEG
40689: PUSH
40690: LD_INT 3
40692: PUSH
40693: EMPTY
40694: LIST
40695: LIST
40696: PUSH
40697: LD_INT 2
40699: PUSH
40700: LD_INT 5
40702: PUSH
40703: EMPTY
40704: LIST
40705: LIST
40706: PUSH
40707: LD_INT 2
40709: NEG
40710: PUSH
40711: LD_INT 3
40713: PUSH
40714: EMPTY
40715: LIST
40716: LIST
40717: PUSH
40718: LD_INT 3
40720: NEG
40721: PUSH
40722: LD_INT 0
40724: PUSH
40725: EMPTY
40726: LIST
40727: LIST
40728: PUSH
40729: LD_INT 3
40731: NEG
40732: PUSH
40733: LD_INT 1
40735: NEG
40736: PUSH
40737: EMPTY
40738: LIST
40739: LIST
40740: PUSH
40741: LD_INT 2
40743: NEG
40744: PUSH
40745: LD_INT 0
40747: PUSH
40748: EMPTY
40749: LIST
40750: LIST
40751: PUSH
40752: LD_INT 2
40754: NEG
40755: PUSH
40756: LD_INT 1
40758: PUSH
40759: EMPTY
40760: LIST
40761: LIST
40762: PUSH
40763: LD_INT 3
40765: NEG
40766: PUSH
40767: LD_INT 1
40769: PUSH
40770: EMPTY
40771: LIST
40772: LIST
40773: PUSH
40774: LD_INT 4
40776: NEG
40777: PUSH
40778: LD_INT 0
40780: PUSH
40781: EMPTY
40782: LIST
40783: LIST
40784: PUSH
40785: LD_INT 4
40787: NEG
40788: PUSH
40789: LD_INT 1
40791: NEG
40792: PUSH
40793: EMPTY
40794: LIST
40795: LIST
40796: PUSH
40797: LD_INT 4
40799: NEG
40800: PUSH
40801: LD_INT 2
40803: NEG
40804: PUSH
40805: EMPTY
40806: LIST
40807: LIST
40808: PUSH
40809: LD_INT 2
40811: NEG
40812: PUSH
40813: LD_INT 2
40815: PUSH
40816: EMPTY
40817: LIST
40818: LIST
40819: PUSH
40820: LD_INT 4
40822: NEG
40823: PUSH
40824: LD_INT 4
40826: NEG
40827: PUSH
40828: EMPTY
40829: LIST
40830: LIST
40831: PUSH
40832: LD_INT 4
40834: NEG
40835: PUSH
40836: LD_INT 5
40838: NEG
40839: PUSH
40840: EMPTY
40841: LIST
40842: LIST
40843: PUSH
40844: LD_INT 3
40846: NEG
40847: PUSH
40848: LD_INT 4
40850: NEG
40851: PUSH
40852: EMPTY
40853: LIST
40854: LIST
40855: PUSH
40856: LD_INT 3
40858: NEG
40859: PUSH
40860: LD_INT 3
40862: NEG
40863: PUSH
40864: EMPTY
40865: LIST
40866: LIST
40867: PUSH
40868: LD_INT 4
40870: NEG
40871: PUSH
40872: LD_INT 3
40874: NEG
40875: PUSH
40876: EMPTY
40877: LIST
40878: LIST
40879: PUSH
40880: LD_INT 5
40882: NEG
40883: PUSH
40884: LD_INT 4
40886: NEG
40887: PUSH
40888: EMPTY
40889: LIST
40890: LIST
40891: PUSH
40892: LD_INT 5
40894: NEG
40895: PUSH
40896: LD_INT 5
40898: NEG
40899: PUSH
40900: EMPTY
40901: LIST
40902: LIST
40903: PUSH
40904: LD_INT 3
40906: NEG
40907: PUSH
40908: LD_INT 5
40910: NEG
40911: PUSH
40912: EMPTY
40913: LIST
40914: LIST
40915: PUSH
40916: LD_INT 5
40918: NEG
40919: PUSH
40920: LD_INT 3
40922: NEG
40923: PUSH
40924: EMPTY
40925: LIST
40926: LIST
40927: PUSH
40928: LD_INT 0
40930: PUSH
40931: LD_INT 3
40933: NEG
40934: PUSH
40935: EMPTY
40936: LIST
40937: LIST
40938: PUSH
40939: LD_INT 0
40941: PUSH
40942: LD_INT 4
40944: NEG
40945: PUSH
40946: EMPTY
40947: LIST
40948: LIST
40949: PUSH
40950: LD_INT 1
40952: PUSH
40953: LD_INT 3
40955: NEG
40956: PUSH
40957: EMPTY
40958: LIST
40959: LIST
40960: PUSH
40961: LD_INT 1
40963: PUSH
40964: LD_INT 2
40966: NEG
40967: PUSH
40968: EMPTY
40969: LIST
40970: LIST
40971: PUSH
40972: LD_INT 0
40974: PUSH
40975: LD_INT 2
40977: NEG
40978: PUSH
40979: EMPTY
40980: LIST
40981: LIST
40982: PUSH
40983: LD_INT 1
40985: NEG
40986: PUSH
40987: LD_INT 3
40989: NEG
40990: PUSH
40991: EMPTY
40992: LIST
40993: LIST
40994: PUSH
40995: LD_INT 1
40997: NEG
40998: PUSH
40999: LD_INT 4
41001: NEG
41002: PUSH
41003: EMPTY
41004: LIST
41005: LIST
41006: PUSH
41007: LD_INT 2
41009: PUSH
41010: LD_INT 2
41012: NEG
41013: PUSH
41014: EMPTY
41015: LIST
41016: LIST
41017: PUSH
41018: LD_INT 2
41020: NEG
41021: PUSH
41022: LD_INT 4
41024: NEG
41025: PUSH
41026: EMPTY
41027: LIST
41028: LIST
41029: PUSH
41030: LD_INT 4
41032: PUSH
41033: LD_INT 0
41035: PUSH
41036: EMPTY
41037: LIST
41038: LIST
41039: PUSH
41040: LD_INT 4
41042: PUSH
41043: LD_INT 1
41045: NEG
41046: PUSH
41047: EMPTY
41048: LIST
41049: LIST
41050: PUSH
41051: LD_INT 5
41053: PUSH
41054: LD_INT 0
41056: PUSH
41057: EMPTY
41058: LIST
41059: LIST
41060: PUSH
41061: LD_INT 5
41063: PUSH
41064: LD_INT 1
41066: PUSH
41067: EMPTY
41068: LIST
41069: LIST
41070: PUSH
41071: LD_INT 4
41073: PUSH
41074: LD_INT 1
41076: PUSH
41077: EMPTY
41078: LIST
41079: LIST
41080: PUSH
41081: LD_INT 3
41083: PUSH
41084: LD_INT 0
41086: PUSH
41087: EMPTY
41088: LIST
41089: LIST
41090: PUSH
41091: LD_INT 3
41093: PUSH
41094: LD_INT 1
41096: NEG
41097: PUSH
41098: EMPTY
41099: LIST
41100: LIST
41101: PUSH
41102: LD_INT 3
41104: PUSH
41105: LD_INT 2
41107: NEG
41108: PUSH
41109: EMPTY
41110: LIST
41111: LIST
41112: PUSH
41113: LD_INT 5
41115: PUSH
41116: LD_INT 2
41118: PUSH
41119: EMPTY
41120: LIST
41121: LIST
41122: PUSH
41123: EMPTY
41124: LIST
41125: LIST
41126: LIST
41127: LIST
41128: LIST
41129: LIST
41130: LIST
41131: LIST
41132: LIST
41133: LIST
41134: LIST
41135: LIST
41136: LIST
41137: LIST
41138: LIST
41139: LIST
41140: LIST
41141: LIST
41142: LIST
41143: LIST
41144: LIST
41145: LIST
41146: LIST
41147: LIST
41148: LIST
41149: LIST
41150: LIST
41151: LIST
41152: LIST
41153: LIST
41154: LIST
41155: LIST
41156: LIST
41157: LIST
41158: LIST
41159: LIST
41160: LIST
41161: LIST
41162: LIST
41163: LIST
41164: LIST
41165: LIST
41166: LIST
41167: LIST
41168: LIST
41169: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
41170: LD_ADDR_VAR 0 32
41174: PUSH
41175: LD_INT 4
41177: NEG
41178: PUSH
41179: LD_INT 0
41181: PUSH
41182: EMPTY
41183: LIST
41184: LIST
41185: PUSH
41186: LD_INT 4
41188: NEG
41189: PUSH
41190: LD_INT 1
41192: NEG
41193: PUSH
41194: EMPTY
41195: LIST
41196: LIST
41197: PUSH
41198: LD_INT 3
41200: NEG
41201: PUSH
41202: LD_INT 0
41204: PUSH
41205: EMPTY
41206: LIST
41207: LIST
41208: PUSH
41209: LD_INT 3
41211: NEG
41212: PUSH
41213: LD_INT 1
41215: PUSH
41216: EMPTY
41217: LIST
41218: LIST
41219: PUSH
41220: LD_INT 4
41222: NEG
41223: PUSH
41224: LD_INT 1
41226: PUSH
41227: EMPTY
41228: LIST
41229: LIST
41230: PUSH
41231: LD_INT 5
41233: NEG
41234: PUSH
41235: LD_INT 0
41237: PUSH
41238: EMPTY
41239: LIST
41240: LIST
41241: PUSH
41242: LD_INT 5
41244: NEG
41245: PUSH
41246: LD_INT 1
41248: NEG
41249: PUSH
41250: EMPTY
41251: LIST
41252: LIST
41253: PUSH
41254: LD_INT 5
41256: NEG
41257: PUSH
41258: LD_INT 2
41260: NEG
41261: PUSH
41262: EMPTY
41263: LIST
41264: LIST
41265: PUSH
41266: LD_INT 3
41268: NEG
41269: PUSH
41270: LD_INT 2
41272: PUSH
41273: EMPTY
41274: LIST
41275: LIST
41276: PUSH
41277: LD_INT 3
41279: NEG
41280: PUSH
41281: LD_INT 3
41283: NEG
41284: PUSH
41285: EMPTY
41286: LIST
41287: LIST
41288: PUSH
41289: LD_INT 3
41291: NEG
41292: PUSH
41293: LD_INT 4
41295: NEG
41296: PUSH
41297: EMPTY
41298: LIST
41299: LIST
41300: PUSH
41301: LD_INT 2
41303: NEG
41304: PUSH
41305: LD_INT 3
41307: NEG
41308: PUSH
41309: EMPTY
41310: LIST
41311: LIST
41312: PUSH
41313: LD_INT 2
41315: NEG
41316: PUSH
41317: LD_INT 2
41319: NEG
41320: PUSH
41321: EMPTY
41322: LIST
41323: LIST
41324: PUSH
41325: LD_INT 3
41327: NEG
41328: PUSH
41329: LD_INT 2
41331: NEG
41332: PUSH
41333: EMPTY
41334: LIST
41335: LIST
41336: PUSH
41337: LD_INT 4
41339: NEG
41340: PUSH
41341: LD_INT 3
41343: NEG
41344: PUSH
41345: EMPTY
41346: LIST
41347: LIST
41348: PUSH
41349: LD_INT 4
41351: NEG
41352: PUSH
41353: LD_INT 4
41355: NEG
41356: PUSH
41357: EMPTY
41358: LIST
41359: LIST
41360: PUSH
41361: LD_INT 2
41363: NEG
41364: PUSH
41365: LD_INT 4
41367: NEG
41368: PUSH
41369: EMPTY
41370: LIST
41371: LIST
41372: PUSH
41373: LD_INT 4
41375: NEG
41376: PUSH
41377: LD_INT 2
41379: NEG
41380: PUSH
41381: EMPTY
41382: LIST
41383: LIST
41384: PUSH
41385: LD_INT 0
41387: PUSH
41388: LD_INT 4
41390: NEG
41391: PUSH
41392: EMPTY
41393: LIST
41394: LIST
41395: PUSH
41396: LD_INT 0
41398: PUSH
41399: LD_INT 5
41401: NEG
41402: PUSH
41403: EMPTY
41404: LIST
41405: LIST
41406: PUSH
41407: LD_INT 1
41409: PUSH
41410: LD_INT 4
41412: NEG
41413: PUSH
41414: EMPTY
41415: LIST
41416: LIST
41417: PUSH
41418: LD_INT 1
41420: PUSH
41421: LD_INT 3
41423: NEG
41424: PUSH
41425: EMPTY
41426: LIST
41427: LIST
41428: PUSH
41429: LD_INT 0
41431: PUSH
41432: LD_INT 3
41434: NEG
41435: PUSH
41436: EMPTY
41437: LIST
41438: LIST
41439: PUSH
41440: LD_INT 1
41442: NEG
41443: PUSH
41444: LD_INT 4
41446: NEG
41447: PUSH
41448: EMPTY
41449: LIST
41450: LIST
41451: PUSH
41452: LD_INT 1
41454: NEG
41455: PUSH
41456: LD_INT 5
41458: NEG
41459: PUSH
41460: EMPTY
41461: LIST
41462: LIST
41463: PUSH
41464: LD_INT 2
41466: PUSH
41467: LD_INT 3
41469: NEG
41470: PUSH
41471: EMPTY
41472: LIST
41473: LIST
41474: PUSH
41475: LD_INT 2
41477: NEG
41478: PUSH
41479: LD_INT 5
41481: NEG
41482: PUSH
41483: EMPTY
41484: LIST
41485: LIST
41486: PUSH
41487: LD_INT 3
41489: PUSH
41490: LD_INT 0
41492: PUSH
41493: EMPTY
41494: LIST
41495: LIST
41496: PUSH
41497: LD_INT 3
41499: PUSH
41500: LD_INT 1
41502: NEG
41503: PUSH
41504: EMPTY
41505: LIST
41506: LIST
41507: PUSH
41508: LD_INT 4
41510: PUSH
41511: LD_INT 0
41513: PUSH
41514: EMPTY
41515: LIST
41516: LIST
41517: PUSH
41518: LD_INT 4
41520: PUSH
41521: LD_INT 1
41523: PUSH
41524: EMPTY
41525: LIST
41526: LIST
41527: PUSH
41528: LD_INT 3
41530: PUSH
41531: LD_INT 1
41533: PUSH
41534: EMPTY
41535: LIST
41536: LIST
41537: PUSH
41538: LD_INT 2
41540: PUSH
41541: LD_INT 0
41543: PUSH
41544: EMPTY
41545: LIST
41546: LIST
41547: PUSH
41548: LD_INT 2
41550: PUSH
41551: LD_INT 1
41553: NEG
41554: PUSH
41555: EMPTY
41556: LIST
41557: LIST
41558: PUSH
41559: LD_INT 2
41561: PUSH
41562: LD_INT 2
41564: NEG
41565: PUSH
41566: EMPTY
41567: LIST
41568: LIST
41569: PUSH
41570: LD_INT 4
41572: PUSH
41573: LD_INT 2
41575: PUSH
41576: EMPTY
41577: LIST
41578: LIST
41579: PUSH
41580: LD_INT 4
41582: PUSH
41583: LD_INT 4
41585: PUSH
41586: EMPTY
41587: LIST
41588: LIST
41589: PUSH
41590: LD_INT 4
41592: PUSH
41593: LD_INT 3
41595: PUSH
41596: EMPTY
41597: LIST
41598: LIST
41599: PUSH
41600: LD_INT 5
41602: PUSH
41603: LD_INT 4
41605: PUSH
41606: EMPTY
41607: LIST
41608: LIST
41609: PUSH
41610: LD_INT 5
41612: PUSH
41613: LD_INT 5
41615: PUSH
41616: EMPTY
41617: LIST
41618: LIST
41619: PUSH
41620: LD_INT 4
41622: PUSH
41623: LD_INT 5
41625: PUSH
41626: EMPTY
41627: LIST
41628: LIST
41629: PUSH
41630: LD_INT 3
41632: PUSH
41633: LD_INT 4
41635: PUSH
41636: EMPTY
41637: LIST
41638: LIST
41639: PUSH
41640: LD_INT 3
41642: PUSH
41643: LD_INT 3
41645: PUSH
41646: EMPTY
41647: LIST
41648: LIST
41649: PUSH
41650: LD_INT 5
41652: PUSH
41653: LD_INT 3
41655: PUSH
41656: EMPTY
41657: LIST
41658: LIST
41659: PUSH
41660: LD_INT 3
41662: PUSH
41663: LD_INT 5
41665: PUSH
41666: EMPTY
41667: LIST
41668: LIST
41669: PUSH
41670: EMPTY
41671: LIST
41672: LIST
41673: LIST
41674: LIST
41675: LIST
41676: LIST
41677: LIST
41678: LIST
41679: LIST
41680: LIST
41681: LIST
41682: LIST
41683: LIST
41684: LIST
41685: LIST
41686: LIST
41687: LIST
41688: LIST
41689: LIST
41690: LIST
41691: LIST
41692: LIST
41693: LIST
41694: LIST
41695: LIST
41696: LIST
41697: LIST
41698: LIST
41699: LIST
41700: LIST
41701: LIST
41702: LIST
41703: LIST
41704: LIST
41705: LIST
41706: LIST
41707: LIST
41708: LIST
41709: LIST
41710: LIST
41711: LIST
41712: LIST
41713: LIST
41714: LIST
41715: LIST
41716: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
41717: LD_ADDR_VAR 0 33
41721: PUSH
41722: LD_INT 4
41724: NEG
41725: PUSH
41726: LD_INT 4
41728: NEG
41729: PUSH
41730: EMPTY
41731: LIST
41732: LIST
41733: PUSH
41734: LD_INT 4
41736: NEG
41737: PUSH
41738: LD_INT 5
41740: NEG
41741: PUSH
41742: EMPTY
41743: LIST
41744: LIST
41745: PUSH
41746: LD_INT 3
41748: NEG
41749: PUSH
41750: LD_INT 4
41752: NEG
41753: PUSH
41754: EMPTY
41755: LIST
41756: LIST
41757: PUSH
41758: LD_INT 3
41760: NEG
41761: PUSH
41762: LD_INT 3
41764: NEG
41765: PUSH
41766: EMPTY
41767: LIST
41768: LIST
41769: PUSH
41770: LD_INT 4
41772: NEG
41773: PUSH
41774: LD_INT 3
41776: NEG
41777: PUSH
41778: EMPTY
41779: LIST
41780: LIST
41781: PUSH
41782: LD_INT 5
41784: NEG
41785: PUSH
41786: LD_INT 4
41788: NEG
41789: PUSH
41790: EMPTY
41791: LIST
41792: LIST
41793: PUSH
41794: LD_INT 5
41796: NEG
41797: PUSH
41798: LD_INT 5
41800: NEG
41801: PUSH
41802: EMPTY
41803: LIST
41804: LIST
41805: PUSH
41806: LD_INT 3
41808: NEG
41809: PUSH
41810: LD_INT 5
41812: NEG
41813: PUSH
41814: EMPTY
41815: LIST
41816: LIST
41817: PUSH
41818: LD_INT 5
41820: NEG
41821: PUSH
41822: LD_INT 3
41824: NEG
41825: PUSH
41826: EMPTY
41827: LIST
41828: LIST
41829: PUSH
41830: LD_INT 0
41832: PUSH
41833: LD_INT 3
41835: NEG
41836: PUSH
41837: EMPTY
41838: LIST
41839: LIST
41840: PUSH
41841: LD_INT 0
41843: PUSH
41844: LD_INT 4
41846: NEG
41847: PUSH
41848: EMPTY
41849: LIST
41850: LIST
41851: PUSH
41852: LD_INT 1
41854: PUSH
41855: LD_INT 3
41857: NEG
41858: PUSH
41859: EMPTY
41860: LIST
41861: LIST
41862: PUSH
41863: LD_INT 1
41865: PUSH
41866: LD_INT 2
41868: NEG
41869: PUSH
41870: EMPTY
41871: LIST
41872: LIST
41873: PUSH
41874: LD_INT 0
41876: PUSH
41877: LD_INT 2
41879: NEG
41880: PUSH
41881: EMPTY
41882: LIST
41883: LIST
41884: PUSH
41885: LD_INT 1
41887: NEG
41888: PUSH
41889: LD_INT 3
41891: NEG
41892: PUSH
41893: EMPTY
41894: LIST
41895: LIST
41896: PUSH
41897: LD_INT 1
41899: NEG
41900: PUSH
41901: LD_INT 4
41903: NEG
41904: PUSH
41905: EMPTY
41906: LIST
41907: LIST
41908: PUSH
41909: LD_INT 2
41911: PUSH
41912: LD_INT 2
41914: NEG
41915: PUSH
41916: EMPTY
41917: LIST
41918: LIST
41919: PUSH
41920: LD_INT 2
41922: NEG
41923: PUSH
41924: LD_INT 4
41926: NEG
41927: PUSH
41928: EMPTY
41929: LIST
41930: LIST
41931: PUSH
41932: LD_INT 4
41934: PUSH
41935: LD_INT 0
41937: PUSH
41938: EMPTY
41939: LIST
41940: LIST
41941: PUSH
41942: LD_INT 4
41944: PUSH
41945: LD_INT 1
41947: NEG
41948: PUSH
41949: EMPTY
41950: LIST
41951: LIST
41952: PUSH
41953: LD_INT 5
41955: PUSH
41956: LD_INT 0
41958: PUSH
41959: EMPTY
41960: LIST
41961: LIST
41962: PUSH
41963: LD_INT 5
41965: PUSH
41966: LD_INT 1
41968: PUSH
41969: EMPTY
41970: LIST
41971: LIST
41972: PUSH
41973: LD_INT 4
41975: PUSH
41976: LD_INT 1
41978: PUSH
41979: EMPTY
41980: LIST
41981: LIST
41982: PUSH
41983: LD_INT 3
41985: PUSH
41986: LD_INT 0
41988: PUSH
41989: EMPTY
41990: LIST
41991: LIST
41992: PUSH
41993: LD_INT 3
41995: PUSH
41996: LD_INT 1
41998: NEG
41999: PUSH
42000: EMPTY
42001: LIST
42002: LIST
42003: PUSH
42004: LD_INT 3
42006: PUSH
42007: LD_INT 2
42009: NEG
42010: PUSH
42011: EMPTY
42012: LIST
42013: LIST
42014: PUSH
42015: LD_INT 5
42017: PUSH
42018: LD_INT 2
42020: PUSH
42021: EMPTY
42022: LIST
42023: LIST
42024: PUSH
42025: LD_INT 3
42027: PUSH
42028: LD_INT 3
42030: PUSH
42031: EMPTY
42032: LIST
42033: LIST
42034: PUSH
42035: LD_INT 3
42037: PUSH
42038: LD_INT 2
42040: PUSH
42041: EMPTY
42042: LIST
42043: LIST
42044: PUSH
42045: LD_INT 4
42047: PUSH
42048: LD_INT 3
42050: PUSH
42051: EMPTY
42052: LIST
42053: LIST
42054: PUSH
42055: LD_INT 4
42057: PUSH
42058: LD_INT 4
42060: PUSH
42061: EMPTY
42062: LIST
42063: LIST
42064: PUSH
42065: LD_INT 3
42067: PUSH
42068: LD_INT 4
42070: PUSH
42071: EMPTY
42072: LIST
42073: LIST
42074: PUSH
42075: LD_INT 2
42077: PUSH
42078: LD_INT 3
42080: PUSH
42081: EMPTY
42082: LIST
42083: LIST
42084: PUSH
42085: LD_INT 2
42087: PUSH
42088: LD_INT 2
42090: PUSH
42091: EMPTY
42092: LIST
42093: LIST
42094: PUSH
42095: LD_INT 4
42097: PUSH
42098: LD_INT 2
42100: PUSH
42101: EMPTY
42102: LIST
42103: LIST
42104: PUSH
42105: LD_INT 2
42107: PUSH
42108: LD_INT 4
42110: PUSH
42111: EMPTY
42112: LIST
42113: LIST
42114: PUSH
42115: LD_INT 0
42117: PUSH
42118: LD_INT 4
42120: PUSH
42121: EMPTY
42122: LIST
42123: LIST
42124: PUSH
42125: LD_INT 0
42127: PUSH
42128: LD_INT 3
42130: PUSH
42131: EMPTY
42132: LIST
42133: LIST
42134: PUSH
42135: LD_INT 1
42137: PUSH
42138: LD_INT 4
42140: PUSH
42141: EMPTY
42142: LIST
42143: LIST
42144: PUSH
42145: LD_INT 1
42147: PUSH
42148: LD_INT 5
42150: PUSH
42151: EMPTY
42152: LIST
42153: LIST
42154: PUSH
42155: LD_INT 0
42157: PUSH
42158: LD_INT 5
42160: PUSH
42161: EMPTY
42162: LIST
42163: LIST
42164: PUSH
42165: LD_INT 1
42167: NEG
42168: PUSH
42169: LD_INT 4
42171: PUSH
42172: EMPTY
42173: LIST
42174: LIST
42175: PUSH
42176: LD_INT 1
42178: NEG
42179: PUSH
42180: LD_INT 3
42182: PUSH
42183: EMPTY
42184: LIST
42185: LIST
42186: PUSH
42187: LD_INT 2
42189: PUSH
42190: LD_INT 5
42192: PUSH
42193: EMPTY
42194: LIST
42195: LIST
42196: PUSH
42197: LD_INT 2
42199: NEG
42200: PUSH
42201: LD_INT 3
42203: PUSH
42204: EMPTY
42205: LIST
42206: LIST
42207: PUSH
42208: EMPTY
42209: LIST
42210: LIST
42211: LIST
42212: LIST
42213: LIST
42214: LIST
42215: LIST
42216: LIST
42217: LIST
42218: LIST
42219: LIST
42220: LIST
42221: LIST
42222: LIST
42223: LIST
42224: LIST
42225: LIST
42226: LIST
42227: LIST
42228: LIST
42229: LIST
42230: LIST
42231: LIST
42232: LIST
42233: LIST
42234: LIST
42235: LIST
42236: LIST
42237: LIST
42238: LIST
42239: LIST
42240: LIST
42241: LIST
42242: LIST
42243: LIST
42244: LIST
42245: LIST
42246: LIST
42247: LIST
42248: LIST
42249: LIST
42250: LIST
42251: LIST
42252: LIST
42253: LIST
42254: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
42255: LD_ADDR_VAR 0 34
42259: PUSH
42260: LD_INT 0
42262: PUSH
42263: LD_INT 4
42265: NEG
42266: PUSH
42267: EMPTY
42268: LIST
42269: LIST
42270: PUSH
42271: LD_INT 0
42273: PUSH
42274: LD_INT 5
42276: NEG
42277: PUSH
42278: EMPTY
42279: LIST
42280: LIST
42281: PUSH
42282: LD_INT 1
42284: PUSH
42285: LD_INT 4
42287: NEG
42288: PUSH
42289: EMPTY
42290: LIST
42291: LIST
42292: PUSH
42293: LD_INT 1
42295: PUSH
42296: LD_INT 3
42298: NEG
42299: PUSH
42300: EMPTY
42301: LIST
42302: LIST
42303: PUSH
42304: LD_INT 0
42306: PUSH
42307: LD_INT 3
42309: NEG
42310: PUSH
42311: EMPTY
42312: LIST
42313: LIST
42314: PUSH
42315: LD_INT 1
42317: NEG
42318: PUSH
42319: LD_INT 4
42321: NEG
42322: PUSH
42323: EMPTY
42324: LIST
42325: LIST
42326: PUSH
42327: LD_INT 1
42329: NEG
42330: PUSH
42331: LD_INT 5
42333: NEG
42334: PUSH
42335: EMPTY
42336: LIST
42337: LIST
42338: PUSH
42339: LD_INT 2
42341: PUSH
42342: LD_INT 3
42344: NEG
42345: PUSH
42346: EMPTY
42347: LIST
42348: LIST
42349: PUSH
42350: LD_INT 2
42352: NEG
42353: PUSH
42354: LD_INT 5
42356: NEG
42357: PUSH
42358: EMPTY
42359: LIST
42360: LIST
42361: PUSH
42362: LD_INT 3
42364: PUSH
42365: LD_INT 0
42367: PUSH
42368: EMPTY
42369: LIST
42370: LIST
42371: PUSH
42372: LD_INT 3
42374: PUSH
42375: LD_INT 1
42377: NEG
42378: PUSH
42379: EMPTY
42380: LIST
42381: LIST
42382: PUSH
42383: LD_INT 4
42385: PUSH
42386: LD_INT 0
42388: PUSH
42389: EMPTY
42390: LIST
42391: LIST
42392: PUSH
42393: LD_INT 4
42395: PUSH
42396: LD_INT 1
42398: PUSH
42399: EMPTY
42400: LIST
42401: LIST
42402: PUSH
42403: LD_INT 3
42405: PUSH
42406: LD_INT 1
42408: PUSH
42409: EMPTY
42410: LIST
42411: LIST
42412: PUSH
42413: LD_INT 2
42415: PUSH
42416: LD_INT 0
42418: PUSH
42419: EMPTY
42420: LIST
42421: LIST
42422: PUSH
42423: LD_INT 2
42425: PUSH
42426: LD_INT 1
42428: NEG
42429: PUSH
42430: EMPTY
42431: LIST
42432: LIST
42433: PUSH
42434: LD_INT 2
42436: PUSH
42437: LD_INT 2
42439: NEG
42440: PUSH
42441: EMPTY
42442: LIST
42443: LIST
42444: PUSH
42445: LD_INT 4
42447: PUSH
42448: LD_INT 2
42450: PUSH
42451: EMPTY
42452: LIST
42453: LIST
42454: PUSH
42455: LD_INT 4
42457: PUSH
42458: LD_INT 4
42460: PUSH
42461: EMPTY
42462: LIST
42463: LIST
42464: PUSH
42465: LD_INT 4
42467: PUSH
42468: LD_INT 3
42470: PUSH
42471: EMPTY
42472: LIST
42473: LIST
42474: PUSH
42475: LD_INT 5
42477: PUSH
42478: LD_INT 4
42480: PUSH
42481: EMPTY
42482: LIST
42483: LIST
42484: PUSH
42485: LD_INT 5
42487: PUSH
42488: LD_INT 5
42490: PUSH
42491: EMPTY
42492: LIST
42493: LIST
42494: PUSH
42495: LD_INT 4
42497: PUSH
42498: LD_INT 5
42500: PUSH
42501: EMPTY
42502: LIST
42503: LIST
42504: PUSH
42505: LD_INT 3
42507: PUSH
42508: LD_INT 4
42510: PUSH
42511: EMPTY
42512: LIST
42513: LIST
42514: PUSH
42515: LD_INT 3
42517: PUSH
42518: LD_INT 3
42520: PUSH
42521: EMPTY
42522: LIST
42523: LIST
42524: PUSH
42525: LD_INT 5
42527: PUSH
42528: LD_INT 3
42530: PUSH
42531: EMPTY
42532: LIST
42533: LIST
42534: PUSH
42535: LD_INT 3
42537: PUSH
42538: LD_INT 5
42540: PUSH
42541: EMPTY
42542: LIST
42543: LIST
42544: PUSH
42545: LD_INT 0
42547: PUSH
42548: LD_INT 3
42550: PUSH
42551: EMPTY
42552: LIST
42553: LIST
42554: PUSH
42555: LD_INT 0
42557: PUSH
42558: LD_INT 2
42560: PUSH
42561: EMPTY
42562: LIST
42563: LIST
42564: PUSH
42565: LD_INT 1
42567: PUSH
42568: LD_INT 3
42570: PUSH
42571: EMPTY
42572: LIST
42573: LIST
42574: PUSH
42575: LD_INT 1
42577: PUSH
42578: LD_INT 4
42580: PUSH
42581: EMPTY
42582: LIST
42583: LIST
42584: PUSH
42585: LD_INT 0
42587: PUSH
42588: LD_INT 4
42590: PUSH
42591: EMPTY
42592: LIST
42593: LIST
42594: PUSH
42595: LD_INT 1
42597: NEG
42598: PUSH
42599: LD_INT 3
42601: PUSH
42602: EMPTY
42603: LIST
42604: LIST
42605: PUSH
42606: LD_INT 1
42608: NEG
42609: PUSH
42610: LD_INT 2
42612: PUSH
42613: EMPTY
42614: LIST
42615: LIST
42616: PUSH
42617: LD_INT 2
42619: PUSH
42620: LD_INT 4
42622: PUSH
42623: EMPTY
42624: LIST
42625: LIST
42626: PUSH
42627: LD_INT 2
42629: NEG
42630: PUSH
42631: LD_INT 2
42633: PUSH
42634: EMPTY
42635: LIST
42636: LIST
42637: PUSH
42638: LD_INT 4
42640: NEG
42641: PUSH
42642: LD_INT 0
42644: PUSH
42645: EMPTY
42646: LIST
42647: LIST
42648: PUSH
42649: LD_INT 4
42651: NEG
42652: PUSH
42653: LD_INT 1
42655: NEG
42656: PUSH
42657: EMPTY
42658: LIST
42659: LIST
42660: PUSH
42661: LD_INT 3
42663: NEG
42664: PUSH
42665: LD_INT 0
42667: PUSH
42668: EMPTY
42669: LIST
42670: LIST
42671: PUSH
42672: LD_INT 3
42674: NEG
42675: PUSH
42676: LD_INT 1
42678: PUSH
42679: EMPTY
42680: LIST
42681: LIST
42682: PUSH
42683: LD_INT 4
42685: NEG
42686: PUSH
42687: LD_INT 1
42689: PUSH
42690: EMPTY
42691: LIST
42692: LIST
42693: PUSH
42694: LD_INT 5
42696: NEG
42697: PUSH
42698: LD_INT 0
42700: PUSH
42701: EMPTY
42702: LIST
42703: LIST
42704: PUSH
42705: LD_INT 5
42707: NEG
42708: PUSH
42709: LD_INT 1
42711: NEG
42712: PUSH
42713: EMPTY
42714: LIST
42715: LIST
42716: PUSH
42717: LD_INT 5
42719: NEG
42720: PUSH
42721: LD_INT 2
42723: NEG
42724: PUSH
42725: EMPTY
42726: LIST
42727: LIST
42728: PUSH
42729: LD_INT 3
42731: NEG
42732: PUSH
42733: LD_INT 2
42735: PUSH
42736: EMPTY
42737: LIST
42738: LIST
42739: PUSH
42740: EMPTY
42741: LIST
42742: LIST
42743: LIST
42744: LIST
42745: LIST
42746: LIST
42747: LIST
42748: LIST
42749: LIST
42750: LIST
42751: LIST
42752: LIST
42753: LIST
42754: LIST
42755: LIST
42756: LIST
42757: LIST
42758: LIST
42759: LIST
42760: LIST
42761: LIST
42762: LIST
42763: LIST
42764: LIST
42765: LIST
42766: LIST
42767: LIST
42768: LIST
42769: LIST
42770: LIST
42771: LIST
42772: LIST
42773: LIST
42774: LIST
42775: LIST
42776: LIST
42777: LIST
42778: LIST
42779: LIST
42780: LIST
42781: LIST
42782: LIST
42783: LIST
42784: LIST
42785: LIST
42786: ST_TO_ADDR
// end ; end ;
42787: GO 42790
42789: POP
// case btype of b_depot , b_warehouse :
42790: LD_VAR 0 1
42794: PUSH
42795: LD_INT 0
42797: DOUBLE
42798: EQUAL
42799: IFTRUE 42809
42801: LD_INT 1
42803: DOUBLE
42804: EQUAL
42805: IFTRUE 42809
42807: GO 43010
42809: POP
// case nation of nation_american :
42810: LD_VAR 0 5
42814: PUSH
42815: LD_INT 1
42817: DOUBLE
42818: EQUAL
42819: IFTRUE 42823
42821: GO 42879
42823: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
42824: LD_ADDR_VAR 0 9
42828: PUSH
42829: LD_VAR 0 11
42833: PUSH
42834: LD_VAR 0 12
42838: PUSH
42839: LD_VAR 0 13
42843: PUSH
42844: LD_VAR 0 14
42848: PUSH
42849: LD_VAR 0 15
42853: PUSH
42854: LD_VAR 0 16
42858: PUSH
42859: EMPTY
42860: LIST
42861: LIST
42862: LIST
42863: LIST
42864: LIST
42865: LIST
42866: PUSH
42867: LD_VAR 0 4
42871: PUSH
42872: LD_INT 1
42874: PLUS
42875: ARRAY
42876: ST_TO_ADDR
42877: GO 43008
42879: LD_INT 2
42881: DOUBLE
42882: EQUAL
42883: IFTRUE 42887
42885: GO 42943
42887: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
42888: LD_ADDR_VAR 0 9
42892: PUSH
42893: LD_VAR 0 17
42897: PUSH
42898: LD_VAR 0 18
42902: PUSH
42903: LD_VAR 0 19
42907: PUSH
42908: LD_VAR 0 20
42912: PUSH
42913: LD_VAR 0 21
42917: PUSH
42918: LD_VAR 0 22
42922: PUSH
42923: EMPTY
42924: LIST
42925: LIST
42926: LIST
42927: LIST
42928: LIST
42929: LIST
42930: PUSH
42931: LD_VAR 0 4
42935: PUSH
42936: LD_INT 1
42938: PLUS
42939: ARRAY
42940: ST_TO_ADDR
42941: GO 43008
42943: LD_INT 3
42945: DOUBLE
42946: EQUAL
42947: IFTRUE 42951
42949: GO 43007
42951: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
42952: LD_ADDR_VAR 0 9
42956: PUSH
42957: LD_VAR 0 23
42961: PUSH
42962: LD_VAR 0 24
42966: PUSH
42967: LD_VAR 0 25
42971: PUSH
42972: LD_VAR 0 26
42976: PUSH
42977: LD_VAR 0 27
42981: PUSH
42982: LD_VAR 0 28
42986: PUSH
42987: EMPTY
42988: LIST
42989: LIST
42990: LIST
42991: LIST
42992: LIST
42993: LIST
42994: PUSH
42995: LD_VAR 0 4
42999: PUSH
43000: LD_INT 1
43002: PLUS
43003: ARRAY
43004: ST_TO_ADDR
43005: GO 43008
43007: POP
43008: GO 43563
43010: LD_INT 2
43012: DOUBLE
43013: EQUAL
43014: IFTRUE 43024
43016: LD_INT 3
43018: DOUBLE
43019: EQUAL
43020: IFTRUE 43024
43022: GO 43080
43024: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
43025: LD_ADDR_VAR 0 9
43029: PUSH
43030: LD_VAR 0 29
43034: PUSH
43035: LD_VAR 0 30
43039: PUSH
43040: LD_VAR 0 31
43044: PUSH
43045: LD_VAR 0 32
43049: PUSH
43050: LD_VAR 0 33
43054: PUSH
43055: LD_VAR 0 34
43059: PUSH
43060: EMPTY
43061: LIST
43062: LIST
43063: LIST
43064: LIST
43065: LIST
43066: LIST
43067: PUSH
43068: LD_VAR 0 4
43072: PUSH
43073: LD_INT 1
43075: PLUS
43076: ARRAY
43077: ST_TO_ADDR
43078: GO 43563
43080: LD_INT 16
43082: DOUBLE
43083: EQUAL
43084: IFTRUE 43142
43086: LD_INT 17
43088: DOUBLE
43089: EQUAL
43090: IFTRUE 43142
43092: LD_INT 18
43094: DOUBLE
43095: EQUAL
43096: IFTRUE 43142
43098: LD_INT 19
43100: DOUBLE
43101: EQUAL
43102: IFTRUE 43142
43104: LD_INT 22
43106: DOUBLE
43107: EQUAL
43108: IFTRUE 43142
43110: LD_INT 20
43112: DOUBLE
43113: EQUAL
43114: IFTRUE 43142
43116: LD_INT 21
43118: DOUBLE
43119: EQUAL
43120: IFTRUE 43142
43122: LD_INT 23
43124: DOUBLE
43125: EQUAL
43126: IFTRUE 43142
43128: LD_INT 24
43130: DOUBLE
43131: EQUAL
43132: IFTRUE 43142
43134: LD_INT 25
43136: DOUBLE
43137: EQUAL
43138: IFTRUE 43142
43140: GO 43198
43142: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
43143: LD_ADDR_VAR 0 9
43147: PUSH
43148: LD_VAR 0 35
43152: PUSH
43153: LD_VAR 0 36
43157: PUSH
43158: LD_VAR 0 37
43162: PUSH
43163: LD_VAR 0 38
43167: PUSH
43168: LD_VAR 0 39
43172: PUSH
43173: LD_VAR 0 40
43177: PUSH
43178: EMPTY
43179: LIST
43180: LIST
43181: LIST
43182: LIST
43183: LIST
43184: LIST
43185: PUSH
43186: LD_VAR 0 4
43190: PUSH
43191: LD_INT 1
43193: PLUS
43194: ARRAY
43195: ST_TO_ADDR
43196: GO 43563
43198: LD_INT 6
43200: DOUBLE
43201: EQUAL
43202: IFTRUE 43254
43204: LD_INT 7
43206: DOUBLE
43207: EQUAL
43208: IFTRUE 43254
43210: LD_INT 8
43212: DOUBLE
43213: EQUAL
43214: IFTRUE 43254
43216: LD_INT 13
43218: DOUBLE
43219: EQUAL
43220: IFTRUE 43254
43222: LD_INT 12
43224: DOUBLE
43225: EQUAL
43226: IFTRUE 43254
43228: LD_INT 15
43230: DOUBLE
43231: EQUAL
43232: IFTRUE 43254
43234: LD_INT 11
43236: DOUBLE
43237: EQUAL
43238: IFTRUE 43254
43240: LD_INT 14
43242: DOUBLE
43243: EQUAL
43244: IFTRUE 43254
43246: LD_INT 10
43248: DOUBLE
43249: EQUAL
43250: IFTRUE 43254
43252: GO 43310
43254: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
43255: LD_ADDR_VAR 0 9
43259: PUSH
43260: LD_VAR 0 41
43264: PUSH
43265: LD_VAR 0 42
43269: PUSH
43270: LD_VAR 0 43
43274: PUSH
43275: LD_VAR 0 44
43279: PUSH
43280: LD_VAR 0 45
43284: PUSH
43285: LD_VAR 0 46
43289: PUSH
43290: EMPTY
43291: LIST
43292: LIST
43293: LIST
43294: LIST
43295: LIST
43296: LIST
43297: PUSH
43298: LD_VAR 0 4
43302: PUSH
43303: LD_INT 1
43305: PLUS
43306: ARRAY
43307: ST_TO_ADDR
43308: GO 43563
43310: LD_INT 36
43312: DOUBLE
43313: EQUAL
43314: IFTRUE 43318
43316: GO 43374
43318: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
43319: LD_ADDR_VAR 0 9
43323: PUSH
43324: LD_VAR 0 47
43328: PUSH
43329: LD_VAR 0 48
43333: PUSH
43334: LD_VAR 0 49
43338: PUSH
43339: LD_VAR 0 50
43343: PUSH
43344: LD_VAR 0 51
43348: PUSH
43349: LD_VAR 0 52
43353: PUSH
43354: EMPTY
43355: LIST
43356: LIST
43357: LIST
43358: LIST
43359: LIST
43360: LIST
43361: PUSH
43362: LD_VAR 0 4
43366: PUSH
43367: LD_INT 1
43369: PLUS
43370: ARRAY
43371: ST_TO_ADDR
43372: GO 43563
43374: LD_INT 4
43376: DOUBLE
43377: EQUAL
43378: IFTRUE 43400
43380: LD_INT 5
43382: DOUBLE
43383: EQUAL
43384: IFTRUE 43400
43386: LD_INT 34
43388: DOUBLE
43389: EQUAL
43390: IFTRUE 43400
43392: LD_INT 37
43394: DOUBLE
43395: EQUAL
43396: IFTRUE 43400
43398: GO 43456
43400: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
43401: LD_ADDR_VAR 0 9
43405: PUSH
43406: LD_VAR 0 53
43410: PUSH
43411: LD_VAR 0 54
43415: PUSH
43416: LD_VAR 0 55
43420: PUSH
43421: LD_VAR 0 56
43425: PUSH
43426: LD_VAR 0 57
43430: PUSH
43431: LD_VAR 0 58
43435: PUSH
43436: EMPTY
43437: LIST
43438: LIST
43439: LIST
43440: LIST
43441: LIST
43442: LIST
43443: PUSH
43444: LD_VAR 0 4
43448: PUSH
43449: LD_INT 1
43451: PLUS
43452: ARRAY
43453: ST_TO_ADDR
43454: GO 43563
43456: LD_INT 31
43458: DOUBLE
43459: EQUAL
43460: IFTRUE 43506
43462: LD_INT 32
43464: DOUBLE
43465: EQUAL
43466: IFTRUE 43506
43468: LD_INT 33
43470: DOUBLE
43471: EQUAL
43472: IFTRUE 43506
43474: LD_INT 27
43476: DOUBLE
43477: EQUAL
43478: IFTRUE 43506
43480: LD_INT 26
43482: DOUBLE
43483: EQUAL
43484: IFTRUE 43506
43486: LD_INT 28
43488: DOUBLE
43489: EQUAL
43490: IFTRUE 43506
43492: LD_INT 29
43494: DOUBLE
43495: EQUAL
43496: IFTRUE 43506
43498: LD_INT 30
43500: DOUBLE
43501: EQUAL
43502: IFTRUE 43506
43504: GO 43562
43506: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
43507: LD_ADDR_VAR 0 9
43511: PUSH
43512: LD_VAR 0 59
43516: PUSH
43517: LD_VAR 0 60
43521: PUSH
43522: LD_VAR 0 61
43526: PUSH
43527: LD_VAR 0 62
43531: PUSH
43532: LD_VAR 0 63
43536: PUSH
43537: LD_VAR 0 64
43541: PUSH
43542: EMPTY
43543: LIST
43544: LIST
43545: LIST
43546: LIST
43547: LIST
43548: LIST
43549: PUSH
43550: LD_VAR 0 4
43554: PUSH
43555: LD_INT 1
43557: PLUS
43558: ARRAY
43559: ST_TO_ADDR
43560: GO 43563
43562: POP
// temp_list2 = [ ] ;
43563: LD_ADDR_VAR 0 10
43567: PUSH
43568: EMPTY
43569: ST_TO_ADDR
// for i in temp_list do
43570: LD_ADDR_VAR 0 8
43574: PUSH
43575: LD_VAR 0 9
43579: PUSH
43580: FOR_IN
43581: IFFALSE 43633
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
43583: LD_ADDR_VAR 0 10
43587: PUSH
43588: LD_VAR 0 10
43592: PUSH
43593: LD_VAR 0 8
43597: PUSH
43598: LD_INT 1
43600: ARRAY
43601: PUSH
43602: LD_VAR 0 2
43606: PLUS
43607: PUSH
43608: LD_VAR 0 8
43612: PUSH
43613: LD_INT 2
43615: ARRAY
43616: PUSH
43617: LD_VAR 0 3
43621: PLUS
43622: PUSH
43623: EMPTY
43624: LIST
43625: LIST
43626: PUSH
43627: EMPTY
43628: LIST
43629: ADD
43630: ST_TO_ADDR
43631: GO 43580
43633: POP
43634: POP
// result = temp_list2 ;
43635: LD_ADDR_VAR 0 7
43639: PUSH
43640: LD_VAR 0 10
43644: ST_TO_ADDR
// end ;
43645: LD_VAR 0 7
43649: RET
// export function EnemyInRange ( unit , dist ) ; begin
43650: LD_INT 0
43652: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
43653: LD_ADDR_VAR 0 3
43657: PUSH
43658: LD_VAR 0 1
43662: PPUSH
43663: CALL_OW 255
43667: PPUSH
43668: LD_VAR 0 1
43672: PPUSH
43673: CALL_OW 250
43677: PPUSH
43678: LD_VAR 0 1
43682: PPUSH
43683: CALL_OW 251
43687: PPUSH
43688: LD_VAR 0 2
43692: PPUSH
43693: CALL 17052 0 4
43697: PUSH
43698: LD_INT 4
43700: ARRAY
43701: ST_TO_ADDR
// end ;
43702: LD_VAR 0 3
43706: RET
// export function PlayerSeeMe ( unit ) ; begin
43707: LD_INT 0
43709: PPUSH
// result := See ( your_side , unit ) ;
43710: LD_ADDR_VAR 0 2
43714: PUSH
43715: LD_OWVAR 2
43719: PPUSH
43720: LD_VAR 0 1
43724: PPUSH
43725: CALL_OW 292
43729: ST_TO_ADDR
// end ;
43730: LD_VAR 0 2
43734: RET
// export function ReverseDir ( unit ) ; begin
43735: LD_INT 0
43737: PPUSH
// if not unit then
43738: LD_VAR 0 1
43742: NOT
43743: IFFALSE 43747
// exit ;
43745: GO 43770
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
43747: LD_ADDR_VAR 0 2
43751: PUSH
43752: LD_VAR 0 1
43756: PPUSH
43757: CALL_OW 254
43761: PUSH
43762: LD_INT 3
43764: PLUS
43765: PUSH
43766: LD_INT 6
43768: MOD
43769: ST_TO_ADDR
// end ;
43770: LD_VAR 0 2
43774: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
43775: LD_INT 0
43777: PPUSH
43778: PPUSH
43779: PPUSH
43780: PPUSH
43781: PPUSH
43782: PPUSH
// if not unit or not hexes then
43783: LD_VAR 0 1
43787: NOT
43788: PUSH
43789: LD_VAR 0 2
43793: NOT
43794: OR
43795: IFFALSE 43799
// exit ;
43797: GO 43922
// dist := 9999 ;
43799: LD_ADDR_VAR 0 5
43803: PUSH
43804: LD_INT 9999
43806: ST_TO_ADDR
// for i = 1 to hexes do
43807: LD_ADDR_VAR 0 4
43811: PUSH
43812: DOUBLE
43813: LD_INT 1
43815: DEC
43816: ST_TO_ADDR
43817: LD_VAR 0 2
43821: PUSH
43822: FOR_TO
43823: IFFALSE 43910
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
43825: LD_ADDR_VAR 0 6
43829: PUSH
43830: LD_VAR 0 1
43834: PPUSH
43835: LD_VAR 0 2
43839: PUSH
43840: LD_VAR 0 4
43844: ARRAY
43845: PUSH
43846: LD_INT 1
43848: ARRAY
43849: PPUSH
43850: LD_VAR 0 2
43854: PUSH
43855: LD_VAR 0 4
43859: ARRAY
43860: PUSH
43861: LD_INT 2
43863: ARRAY
43864: PPUSH
43865: CALL_OW 297
43869: ST_TO_ADDR
// if tdist < dist then
43870: LD_VAR 0 6
43874: PUSH
43875: LD_VAR 0 5
43879: LESS
43880: IFFALSE 43908
// begin hex := hexes [ i ] ;
43882: LD_ADDR_VAR 0 8
43886: PUSH
43887: LD_VAR 0 2
43891: PUSH
43892: LD_VAR 0 4
43896: ARRAY
43897: ST_TO_ADDR
// dist := tdist ;
43898: LD_ADDR_VAR 0 5
43902: PUSH
43903: LD_VAR 0 6
43907: ST_TO_ADDR
// end ; end ;
43908: GO 43822
43910: POP
43911: POP
// result := hex ;
43912: LD_ADDR_VAR 0 3
43916: PUSH
43917: LD_VAR 0 8
43921: ST_TO_ADDR
// end ;
43922: LD_VAR 0 3
43926: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
43927: LD_INT 0
43929: PPUSH
43930: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
43931: LD_VAR 0 1
43935: NOT
43936: PUSH
43937: LD_VAR 0 1
43941: PUSH
43942: LD_INT 21
43944: PUSH
43945: LD_INT 2
43947: PUSH
43948: EMPTY
43949: LIST
43950: LIST
43951: PUSH
43952: LD_INT 23
43954: PUSH
43955: LD_INT 2
43957: PUSH
43958: EMPTY
43959: LIST
43960: LIST
43961: PUSH
43962: EMPTY
43963: LIST
43964: LIST
43965: PPUSH
43966: CALL_OW 69
43970: IN
43971: NOT
43972: OR
43973: IFFALSE 43977
// exit ;
43975: GO 44024
// for i = 1 to 3 do
43977: LD_ADDR_VAR 0 3
43981: PUSH
43982: DOUBLE
43983: LD_INT 1
43985: DEC
43986: ST_TO_ADDR
43987: LD_INT 3
43989: PUSH
43990: FOR_TO
43991: IFFALSE 44022
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
43993: LD_VAR 0 1
43997: PPUSH
43998: CALL_OW 250
44002: PPUSH
44003: LD_VAR 0 1
44007: PPUSH
44008: CALL_OW 251
44012: PPUSH
44013: LD_INT 1
44015: PPUSH
44016: CALL_OW 453
44020: GO 43990
44022: POP
44023: POP
// end ;
44024: LD_VAR 0 2
44028: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
44029: LD_INT 0
44031: PPUSH
44032: PPUSH
44033: PPUSH
44034: PPUSH
44035: PPUSH
44036: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
44037: LD_VAR 0 1
44041: NOT
44042: PUSH
44043: LD_VAR 0 2
44047: NOT
44048: OR
44049: PUSH
44050: LD_VAR 0 1
44054: PPUSH
44055: CALL_OW 314
44059: OR
44060: IFFALSE 44064
// exit ;
44062: GO 44505
// x := GetX ( enemy_unit ) ;
44064: LD_ADDR_VAR 0 7
44068: PUSH
44069: LD_VAR 0 2
44073: PPUSH
44074: CALL_OW 250
44078: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
44079: LD_ADDR_VAR 0 8
44083: PUSH
44084: LD_VAR 0 2
44088: PPUSH
44089: CALL_OW 251
44093: ST_TO_ADDR
// if not x or not y then
44094: LD_VAR 0 7
44098: NOT
44099: PUSH
44100: LD_VAR 0 8
44104: NOT
44105: OR
44106: IFFALSE 44110
// exit ;
44108: GO 44505
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
44110: LD_ADDR_VAR 0 6
44114: PUSH
44115: LD_VAR 0 7
44119: PPUSH
44120: LD_INT 0
44122: PPUSH
44123: LD_INT 4
44125: PPUSH
44126: CALL_OW 272
44130: PUSH
44131: LD_VAR 0 8
44135: PPUSH
44136: LD_INT 0
44138: PPUSH
44139: LD_INT 4
44141: PPUSH
44142: CALL_OW 273
44146: PUSH
44147: EMPTY
44148: LIST
44149: LIST
44150: PUSH
44151: LD_VAR 0 7
44155: PPUSH
44156: LD_INT 1
44158: PPUSH
44159: LD_INT 4
44161: PPUSH
44162: CALL_OW 272
44166: PUSH
44167: LD_VAR 0 8
44171: PPUSH
44172: LD_INT 1
44174: PPUSH
44175: LD_INT 4
44177: PPUSH
44178: CALL_OW 273
44182: PUSH
44183: EMPTY
44184: LIST
44185: LIST
44186: PUSH
44187: LD_VAR 0 7
44191: PPUSH
44192: LD_INT 2
44194: PPUSH
44195: LD_INT 4
44197: PPUSH
44198: CALL_OW 272
44202: PUSH
44203: LD_VAR 0 8
44207: PPUSH
44208: LD_INT 2
44210: PPUSH
44211: LD_INT 4
44213: PPUSH
44214: CALL_OW 273
44218: PUSH
44219: EMPTY
44220: LIST
44221: LIST
44222: PUSH
44223: LD_VAR 0 7
44227: PPUSH
44228: LD_INT 3
44230: PPUSH
44231: LD_INT 4
44233: PPUSH
44234: CALL_OW 272
44238: PUSH
44239: LD_VAR 0 8
44243: PPUSH
44244: LD_INT 3
44246: PPUSH
44247: LD_INT 4
44249: PPUSH
44250: CALL_OW 273
44254: PUSH
44255: EMPTY
44256: LIST
44257: LIST
44258: PUSH
44259: LD_VAR 0 7
44263: PPUSH
44264: LD_INT 4
44266: PPUSH
44267: LD_INT 4
44269: PPUSH
44270: CALL_OW 272
44274: PUSH
44275: LD_VAR 0 8
44279: PPUSH
44280: LD_INT 4
44282: PPUSH
44283: LD_INT 4
44285: PPUSH
44286: CALL_OW 273
44290: PUSH
44291: EMPTY
44292: LIST
44293: LIST
44294: PUSH
44295: LD_VAR 0 7
44299: PPUSH
44300: LD_INT 5
44302: PPUSH
44303: LD_INT 4
44305: PPUSH
44306: CALL_OW 272
44310: PUSH
44311: LD_VAR 0 8
44315: PPUSH
44316: LD_INT 5
44318: PPUSH
44319: LD_INT 4
44321: PPUSH
44322: CALL_OW 273
44326: PUSH
44327: EMPTY
44328: LIST
44329: LIST
44330: PUSH
44331: EMPTY
44332: LIST
44333: LIST
44334: LIST
44335: LIST
44336: LIST
44337: LIST
44338: ST_TO_ADDR
// for i = tmp downto 1 do
44339: LD_ADDR_VAR 0 4
44343: PUSH
44344: DOUBLE
44345: LD_VAR 0 6
44349: INC
44350: ST_TO_ADDR
44351: LD_INT 1
44353: PUSH
44354: FOR_DOWNTO
44355: IFFALSE 44456
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
44357: LD_VAR 0 6
44361: PUSH
44362: LD_VAR 0 4
44366: ARRAY
44367: PUSH
44368: LD_INT 1
44370: ARRAY
44371: PPUSH
44372: LD_VAR 0 6
44376: PUSH
44377: LD_VAR 0 4
44381: ARRAY
44382: PUSH
44383: LD_INT 2
44385: ARRAY
44386: PPUSH
44387: CALL_OW 488
44391: NOT
44392: PUSH
44393: LD_VAR 0 6
44397: PUSH
44398: LD_VAR 0 4
44402: ARRAY
44403: PUSH
44404: LD_INT 1
44406: ARRAY
44407: PPUSH
44408: LD_VAR 0 6
44412: PUSH
44413: LD_VAR 0 4
44417: ARRAY
44418: PUSH
44419: LD_INT 2
44421: ARRAY
44422: PPUSH
44423: CALL_OW 428
44427: PUSH
44428: LD_INT 0
44430: NONEQUAL
44431: OR
44432: IFFALSE 44454
// tmp := Delete ( tmp , i ) ;
44434: LD_ADDR_VAR 0 6
44438: PUSH
44439: LD_VAR 0 6
44443: PPUSH
44444: LD_VAR 0 4
44448: PPUSH
44449: CALL_OW 3
44453: ST_TO_ADDR
44454: GO 44354
44456: POP
44457: POP
// j := GetClosestHex ( unit , tmp ) ;
44458: LD_ADDR_VAR 0 5
44462: PUSH
44463: LD_VAR 0 1
44467: PPUSH
44468: LD_VAR 0 6
44472: PPUSH
44473: CALL 43775 0 2
44477: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
44478: LD_VAR 0 1
44482: PPUSH
44483: LD_VAR 0 5
44487: PUSH
44488: LD_INT 1
44490: ARRAY
44491: PPUSH
44492: LD_VAR 0 5
44496: PUSH
44497: LD_INT 2
44499: ARRAY
44500: PPUSH
44501: CALL_OW 111
// end ;
44505: LD_VAR 0 3
44509: RET
// export function PrepareApemanSoldier ( ) ; begin
44510: LD_INT 0
44512: PPUSH
// uc_nation := 0 ;
44513: LD_ADDR_OWVAR 21
44517: PUSH
44518: LD_INT 0
44520: ST_TO_ADDR
// hc_sex := sex_male ;
44521: LD_ADDR_OWVAR 27
44525: PUSH
44526: LD_INT 1
44528: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
44529: LD_ADDR_OWVAR 28
44533: PUSH
44534: LD_INT 15
44536: ST_TO_ADDR
// hc_gallery :=  ;
44537: LD_ADDR_OWVAR 33
44541: PUSH
44542: LD_STRING 
44544: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
44545: LD_ADDR_OWVAR 31
44549: PUSH
44550: LD_INT 0
44552: PPUSH
44553: LD_INT 3
44555: PPUSH
44556: CALL_OW 12
44560: PUSH
44561: LD_INT 0
44563: PPUSH
44564: LD_INT 3
44566: PPUSH
44567: CALL_OW 12
44571: PUSH
44572: LD_INT 0
44574: PUSH
44575: LD_INT 0
44577: PUSH
44578: EMPTY
44579: LIST
44580: LIST
44581: LIST
44582: LIST
44583: ST_TO_ADDR
// end ;
44584: LD_VAR 0 1
44588: RET
// export function PrepareApemanEngineer ( ) ; begin
44589: LD_INT 0
44591: PPUSH
// uc_nation := 0 ;
44592: LD_ADDR_OWVAR 21
44596: PUSH
44597: LD_INT 0
44599: ST_TO_ADDR
// hc_sex := sex_male ;
44600: LD_ADDR_OWVAR 27
44604: PUSH
44605: LD_INT 1
44607: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
44608: LD_ADDR_OWVAR 28
44612: PUSH
44613: LD_INT 16
44615: ST_TO_ADDR
// hc_gallery :=  ;
44616: LD_ADDR_OWVAR 33
44620: PUSH
44621: LD_STRING 
44623: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
44624: LD_ADDR_OWVAR 31
44628: PUSH
44629: LD_INT 0
44631: PPUSH
44632: LD_INT 3
44634: PPUSH
44635: CALL_OW 12
44639: PUSH
44640: LD_INT 0
44642: PPUSH
44643: LD_INT 3
44645: PPUSH
44646: CALL_OW 12
44650: PUSH
44651: LD_INT 0
44653: PUSH
44654: LD_INT 0
44656: PUSH
44657: EMPTY
44658: LIST
44659: LIST
44660: LIST
44661: LIST
44662: ST_TO_ADDR
// end ;
44663: LD_VAR 0 1
44667: RET
// export function PrepareApeman ( agressivity ) ; begin
44668: LD_INT 0
44670: PPUSH
// uc_side := 0 ;
44671: LD_ADDR_OWVAR 20
44675: PUSH
44676: LD_INT 0
44678: ST_TO_ADDR
// uc_nation := 0 ;
44679: LD_ADDR_OWVAR 21
44683: PUSH
44684: LD_INT 0
44686: ST_TO_ADDR
// hc_sex := sex_male ;
44687: LD_ADDR_OWVAR 27
44691: PUSH
44692: LD_INT 1
44694: ST_TO_ADDR
// hc_class := class_apeman ;
44695: LD_ADDR_OWVAR 28
44699: PUSH
44700: LD_INT 12
44702: ST_TO_ADDR
// hc_gallery :=  ;
44703: LD_ADDR_OWVAR 33
44707: PUSH
44708: LD_STRING 
44710: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
44711: LD_ADDR_OWVAR 35
44715: PUSH
44716: LD_VAR 0 1
44720: NEG
44721: PPUSH
44722: LD_VAR 0 1
44726: PPUSH
44727: CALL_OW 12
44731: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
44732: LD_ADDR_OWVAR 31
44736: PUSH
44737: LD_INT 0
44739: PPUSH
44740: LD_INT 3
44742: PPUSH
44743: CALL_OW 12
44747: PUSH
44748: LD_INT 0
44750: PPUSH
44751: LD_INT 3
44753: PPUSH
44754: CALL_OW 12
44758: PUSH
44759: LD_INT 0
44761: PUSH
44762: LD_INT 0
44764: PUSH
44765: EMPTY
44766: LIST
44767: LIST
44768: LIST
44769: LIST
44770: ST_TO_ADDR
// end ;
44771: LD_VAR 0 2
44775: RET
// export function PrepareTiger ( agressivity ) ; begin
44776: LD_INT 0
44778: PPUSH
// uc_side := 0 ;
44779: LD_ADDR_OWVAR 20
44783: PUSH
44784: LD_INT 0
44786: ST_TO_ADDR
// uc_nation := 0 ;
44787: LD_ADDR_OWVAR 21
44791: PUSH
44792: LD_INT 0
44794: ST_TO_ADDR
// hc_class := class_tiger ;
44795: LD_ADDR_OWVAR 28
44799: PUSH
44800: LD_INT 14
44802: ST_TO_ADDR
// hc_gallery :=  ;
44803: LD_ADDR_OWVAR 33
44807: PUSH
44808: LD_STRING 
44810: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
44811: LD_ADDR_OWVAR 35
44815: PUSH
44816: LD_VAR 0 1
44820: NEG
44821: PPUSH
44822: LD_VAR 0 1
44826: PPUSH
44827: CALL_OW 12
44831: ST_TO_ADDR
// end ;
44832: LD_VAR 0 2
44836: RET
// export function PrepareEnchidna ( ) ; begin
44837: LD_INT 0
44839: PPUSH
// uc_side := 0 ;
44840: LD_ADDR_OWVAR 20
44844: PUSH
44845: LD_INT 0
44847: ST_TO_ADDR
// uc_nation := 0 ;
44848: LD_ADDR_OWVAR 21
44852: PUSH
44853: LD_INT 0
44855: ST_TO_ADDR
// hc_class := class_baggie ;
44856: LD_ADDR_OWVAR 28
44860: PUSH
44861: LD_INT 13
44863: ST_TO_ADDR
// hc_gallery :=  ;
44864: LD_ADDR_OWVAR 33
44868: PUSH
44869: LD_STRING 
44871: ST_TO_ADDR
// end ;
44872: LD_VAR 0 1
44876: RET
// export function PrepareFrog ( ) ; begin
44877: LD_INT 0
44879: PPUSH
// uc_side := 0 ;
44880: LD_ADDR_OWVAR 20
44884: PUSH
44885: LD_INT 0
44887: ST_TO_ADDR
// uc_nation := 0 ;
44888: LD_ADDR_OWVAR 21
44892: PUSH
44893: LD_INT 0
44895: ST_TO_ADDR
// hc_class := class_frog ;
44896: LD_ADDR_OWVAR 28
44900: PUSH
44901: LD_INT 19
44903: ST_TO_ADDR
// hc_gallery :=  ;
44904: LD_ADDR_OWVAR 33
44908: PUSH
44909: LD_STRING 
44911: ST_TO_ADDR
// end ;
44912: LD_VAR 0 1
44916: RET
// export function PrepareFish ( ) ; begin
44917: LD_INT 0
44919: PPUSH
// uc_side := 0 ;
44920: LD_ADDR_OWVAR 20
44924: PUSH
44925: LD_INT 0
44927: ST_TO_ADDR
// uc_nation := 0 ;
44928: LD_ADDR_OWVAR 21
44932: PUSH
44933: LD_INT 0
44935: ST_TO_ADDR
// hc_class := class_fish ;
44936: LD_ADDR_OWVAR 28
44940: PUSH
44941: LD_INT 20
44943: ST_TO_ADDR
// hc_gallery :=  ;
44944: LD_ADDR_OWVAR 33
44948: PUSH
44949: LD_STRING 
44951: ST_TO_ADDR
// end ;
44952: LD_VAR 0 1
44956: RET
// export function PrepareBird ( ) ; begin
44957: LD_INT 0
44959: PPUSH
// uc_side := 0 ;
44960: LD_ADDR_OWVAR 20
44964: PUSH
44965: LD_INT 0
44967: ST_TO_ADDR
// uc_nation := 0 ;
44968: LD_ADDR_OWVAR 21
44972: PUSH
44973: LD_INT 0
44975: ST_TO_ADDR
// hc_class := class_phororhacos ;
44976: LD_ADDR_OWVAR 28
44980: PUSH
44981: LD_INT 18
44983: ST_TO_ADDR
// hc_gallery :=  ;
44984: LD_ADDR_OWVAR 33
44988: PUSH
44989: LD_STRING 
44991: ST_TO_ADDR
// end ;
44992: LD_VAR 0 1
44996: RET
// export function PrepareHorse ( ) ; begin
44997: LD_INT 0
44999: PPUSH
// uc_side := 0 ;
45000: LD_ADDR_OWVAR 20
45004: PUSH
45005: LD_INT 0
45007: ST_TO_ADDR
// uc_nation := 0 ;
45008: LD_ADDR_OWVAR 21
45012: PUSH
45013: LD_INT 0
45015: ST_TO_ADDR
// hc_class := class_horse ;
45016: LD_ADDR_OWVAR 28
45020: PUSH
45021: LD_INT 21
45023: ST_TO_ADDR
// hc_gallery :=  ;
45024: LD_ADDR_OWVAR 33
45028: PUSH
45029: LD_STRING 
45031: ST_TO_ADDR
// end ;
45032: LD_VAR 0 1
45036: RET
// export function PrepareMastodont ( ) ; begin
45037: LD_INT 0
45039: PPUSH
// uc_side := 0 ;
45040: LD_ADDR_OWVAR 20
45044: PUSH
45045: LD_INT 0
45047: ST_TO_ADDR
// uc_nation := 0 ;
45048: LD_ADDR_OWVAR 21
45052: PUSH
45053: LD_INT 0
45055: ST_TO_ADDR
// vc_chassis := class_mastodont ;
45056: LD_ADDR_OWVAR 37
45060: PUSH
45061: LD_INT 31
45063: ST_TO_ADDR
// vc_control := control_rider ;
45064: LD_ADDR_OWVAR 38
45068: PUSH
45069: LD_INT 4
45071: ST_TO_ADDR
// end ;
45072: LD_VAR 0 1
45076: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
45077: LD_INT 0
45079: PPUSH
45080: PPUSH
45081: PPUSH
// uc_side = 0 ;
45082: LD_ADDR_OWVAR 20
45086: PUSH
45087: LD_INT 0
45089: ST_TO_ADDR
// uc_nation = 0 ;
45090: LD_ADDR_OWVAR 21
45094: PUSH
45095: LD_INT 0
45097: ST_TO_ADDR
// InitHc_All ( ) ;
45098: CALL_OW 584
// InitVc ;
45102: CALL_OW 20
// if mastodonts then
45106: LD_VAR 0 6
45110: IFFALSE 45177
// for i = 1 to mastodonts do
45112: LD_ADDR_VAR 0 11
45116: PUSH
45117: DOUBLE
45118: LD_INT 1
45120: DEC
45121: ST_TO_ADDR
45122: LD_VAR 0 6
45126: PUSH
45127: FOR_TO
45128: IFFALSE 45175
// begin vc_chassis := 31 ;
45130: LD_ADDR_OWVAR 37
45134: PUSH
45135: LD_INT 31
45137: ST_TO_ADDR
// vc_control := control_rider ;
45138: LD_ADDR_OWVAR 38
45142: PUSH
45143: LD_INT 4
45145: ST_TO_ADDR
// animal := CreateVehicle ;
45146: LD_ADDR_VAR 0 12
45150: PUSH
45151: CALL_OW 45
45155: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45156: LD_VAR 0 12
45160: PPUSH
45161: LD_VAR 0 8
45165: PPUSH
45166: LD_INT 0
45168: PPUSH
45169: CALL 47312 0 3
// end ;
45173: GO 45127
45175: POP
45176: POP
// if horses then
45177: LD_VAR 0 5
45181: IFFALSE 45248
// for i = 1 to horses do
45183: LD_ADDR_VAR 0 11
45187: PUSH
45188: DOUBLE
45189: LD_INT 1
45191: DEC
45192: ST_TO_ADDR
45193: LD_VAR 0 5
45197: PUSH
45198: FOR_TO
45199: IFFALSE 45246
// begin hc_class := 21 ;
45201: LD_ADDR_OWVAR 28
45205: PUSH
45206: LD_INT 21
45208: ST_TO_ADDR
// hc_gallery :=  ;
45209: LD_ADDR_OWVAR 33
45213: PUSH
45214: LD_STRING 
45216: ST_TO_ADDR
// animal := CreateHuman ;
45217: LD_ADDR_VAR 0 12
45221: PUSH
45222: CALL_OW 44
45226: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45227: LD_VAR 0 12
45231: PPUSH
45232: LD_VAR 0 8
45236: PPUSH
45237: LD_INT 0
45239: PPUSH
45240: CALL 47312 0 3
// end ;
45244: GO 45198
45246: POP
45247: POP
// if birds then
45248: LD_VAR 0 1
45252: IFFALSE 45319
// for i = 1 to birds do
45254: LD_ADDR_VAR 0 11
45258: PUSH
45259: DOUBLE
45260: LD_INT 1
45262: DEC
45263: ST_TO_ADDR
45264: LD_VAR 0 1
45268: PUSH
45269: FOR_TO
45270: IFFALSE 45317
// begin hc_class = 18 ;
45272: LD_ADDR_OWVAR 28
45276: PUSH
45277: LD_INT 18
45279: ST_TO_ADDR
// hc_gallery =  ;
45280: LD_ADDR_OWVAR 33
45284: PUSH
45285: LD_STRING 
45287: ST_TO_ADDR
// animal := CreateHuman ;
45288: LD_ADDR_VAR 0 12
45292: PUSH
45293: CALL_OW 44
45297: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45298: LD_VAR 0 12
45302: PPUSH
45303: LD_VAR 0 8
45307: PPUSH
45308: LD_INT 0
45310: PPUSH
45311: CALL 47312 0 3
// end ;
45315: GO 45269
45317: POP
45318: POP
// if tigers then
45319: LD_VAR 0 2
45323: IFFALSE 45407
// for i = 1 to tigers do
45325: LD_ADDR_VAR 0 11
45329: PUSH
45330: DOUBLE
45331: LD_INT 1
45333: DEC
45334: ST_TO_ADDR
45335: LD_VAR 0 2
45339: PUSH
45340: FOR_TO
45341: IFFALSE 45405
// begin hc_class = class_tiger ;
45343: LD_ADDR_OWVAR 28
45347: PUSH
45348: LD_INT 14
45350: ST_TO_ADDR
// hc_gallery =  ;
45351: LD_ADDR_OWVAR 33
45355: PUSH
45356: LD_STRING 
45358: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
45359: LD_ADDR_OWVAR 35
45363: PUSH
45364: LD_INT 7
45366: NEG
45367: PPUSH
45368: LD_INT 7
45370: PPUSH
45371: CALL_OW 12
45375: ST_TO_ADDR
// animal := CreateHuman ;
45376: LD_ADDR_VAR 0 12
45380: PUSH
45381: CALL_OW 44
45385: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45386: LD_VAR 0 12
45390: PPUSH
45391: LD_VAR 0 8
45395: PPUSH
45396: LD_INT 0
45398: PPUSH
45399: CALL 47312 0 3
// end ;
45403: GO 45340
45405: POP
45406: POP
// if apemans then
45407: LD_VAR 0 3
45411: IFFALSE 45534
// for i = 1 to apemans do
45413: LD_ADDR_VAR 0 11
45417: PUSH
45418: DOUBLE
45419: LD_INT 1
45421: DEC
45422: ST_TO_ADDR
45423: LD_VAR 0 3
45427: PUSH
45428: FOR_TO
45429: IFFALSE 45532
// begin hc_class = class_apeman ;
45431: LD_ADDR_OWVAR 28
45435: PUSH
45436: LD_INT 12
45438: ST_TO_ADDR
// hc_gallery =  ;
45439: LD_ADDR_OWVAR 33
45443: PUSH
45444: LD_STRING 
45446: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
45447: LD_ADDR_OWVAR 35
45451: PUSH
45452: LD_INT 2
45454: NEG
45455: PPUSH
45456: LD_INT 2
45458: PPUSH
45459: CALL_OW 12
45463: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
45464: LD_ADDR_OWVAR 31
45468: PUSH
45469: LD_INT 1
45471: PPUSH
45472: LD_INT 3
45474: PPUSH
45475: CALL_OW 12
45479: PUSH
45480: LD_INT 1
45482: PPUSH
45483: LD_INT 3
45485: PPUSH
45486: CALL_OW 12
45490: PUSH
45491: LD_INT 0
45493: PUSH
45494: LD_INT 0
45496: PUSH
45497: EMPTY
45498: LIST
45499: LIST
45500: LIST
45501: LIST
45502: ST_TO_ADDR
// animal := CreateHuman ;
45503: LD_ADDR_VAR 0 12
45507: PUSH
45508: CALL_OW 44
45512: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45513: LD_VAR 0 12
45517: PPUSH
45518: LD_VAR 0 8
45522: PPUSH
45523: LD_INT 0
45525: PPUSH
45526: CALL 47312 0 3
// end ;
45530: GO 45428
45532: POP
45533: POP
// if enchidnas then
45534: LD_VAR 0 4
45538: IFFALSE 45605
// for i = 1 to enchidnas do
45540: LD_ADDR_VAR 0 11
45544: PUSH
45545: DOUBLE
45546: LD_INT 1
45548: DEC
45549: ST_TO_ADDR
45550: LD_VAR 0 4
45554: PUSH
45555: FOR_TO
45556: IFFALSE 45603
// begin hc_class = 13 ;
45558: LD_ADDR_OWVAR 28
45562: PUSH
45563: LD_INT 13
45565: ST_TO_ADDR
// hc_gallery =  ;
45566: LD_ADDR_OWVAR 33
45570: PUSH
45571: LD_STRING 
45573: ST_TO_ADDR
// animal := CreateHuman ;
45574: LD_ADDR_VAR 0 12
45578: PUSH
45579: CALL_OW 44
45583: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45584: LD_VAR 0 12
45588: PPUSH
45589: LD_VAR 0 8
45593: PPUSH
45594: LD_INT 0
45596: PPUSH
45597: CALL 47312 0 3
// end ;
45601: GO 45555
45603: POP
45604: POP
// if fishes then
45605: LD_VAR 0 7
45609: IFFALSE 45676
// for i = 1 to fishes do
45611: LD_ADDR_VAR 0 11
45615: PUSH
45616: DOUBLE
45617: LD_INT 1
45619: DEC
45620: ST_TO_ADDR
45621: LD_VAR 0 7
45625: PUSH
45626: FOR_TO
45627: IFFALSE 45674
// begin hc_class = 20 ;
45629: LD_ADDR_OWVAR 28
45633: PUSH
45634: LD_INT 20
45636: ST_TO_ADDR
// hc_gallery =  ;
45637: LD_ADDR_OWVAR 33
45641: PUSH
45642: LD_STRING 
45644: ST_TO_ADDR
// animal := CreateHuman ;
45645: LD_ADDR_VAR 0 12
45649: PUSH
45650: CALL_OW 44
45654: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
45655: LD_VAR 0 12
45659: PPUSH
45660: LD_VAR 0 9
45664: PPUSH
45665: LD_INT 0
45667: PPUSH
45668: CALL 47312 0 3
// end ;
45672: GO 45626
45674: POP
45675: POP
// end ;
45676: LD_VAR 0 10
45680: RET
// export function WantHeal ( sci , unit ) ; begin
45681: LD_INT 0
45683: PPUSH
// if GetTaskList ( sci ) > 0 then
45684: LD_VAR 0 1
45688: PPUSH
45689: CALL_OW 437
45693: PUSH
45694: LD_INT 0
45696: GREATER
45697: IFFALSE 45767
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
45699: LD_VAR 0 1
45703: PPUSH
45704: CALL_OW 437
45708: PUSH
45709: LD_INT 1
45711: ARRAY
45712: PUSH
45713: LD_INT 1
45715: ARRAY
45716: PUSH
45717: LD_STRING l
45719: EQUAL
45720: PUSH
45721: LD_VAR 0 1
45725: PPUSH
45726: CALL_OW 437
45730: PUSH
45731: LD_INT 1
45733: ARRAY
45734: PUSH
45735: LD_INT 4
45737: ARRAY
45738: PUSH
45739: LD_VAR 0 2
45743: EQUAL
45744: AND
45745: IFFALSE 45757
// result := true else
45747: LD_ADDR_VAR 0 3
45751: PUSH
45752: LD_INT 1
45754: ST_TO_ADDR
45755: GO 45765
// result := false ;
45757: LD_ADDR_VAR 0 3
45761: PUSH
45762: LD_INT 0
45764: ST_TO_ADDR
// end else
45765: GO 45775
// result := false ;
45767: LD_ADDR_VAR 0 3
45771: PUSH
45772: LD_INT 0
45774: ST_TO_ADDR
// end ;
45775: LD_VAR 0 3
45779: RET
// export function HealTarget ( sci ) ; begin
45780: LD_INT 0
45782: PPUSH
// if not sci then
45783: LD_VAR 0 1
45787: NOT
45788: IFFALSE 45792
// exit ;
45790: GO 45857
// result := 0 ;
45792: LD_ADDR_VAR 0 2
45796: PUSH
45797: LD_INT 0
45799: ST_TO_ADDR
// if GetTaskList ( sci ) then
45800: LD_VAR 0 1
45804: PPUSH
45805: CALL_OW 437
45809: IFFALSE 45857
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
45811: LD_VAR 0 1
45815: PPUSH
45816: CALL_OW 437
45820: PUSH
45821: LD_INT 1
45823: ARRAY
45824: PUSH
45825: LD_INT 1
45827: ARRAY
45828: PUSH
45829: LD_STRING l
45831: EQUAL
45832: IFFALSE 45857
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
45834: LD_ADDR_VAR 0 2
45838: PUSH
45839: LD_VAR 0 1
45843: PPUSH
45844: CALL_OW 437
45848: PUSH
45849: LD_INT 1
45851: ARRAY
45852: PUSH
45853: LD_INT 4
45855: ARRAY
45856: ST_TO_ADDR
// end ;
45857: LD_VAR 0 2
45861: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
45862: LD_INT 0
45864: PPUSH
45865: PPUSH
45866: PPUSH
45867: PPUSH
// if not base_units then
45868: LD_VAR 0 1
45872: NOT
45873: IFFALSE 45877
// exit ;
45875: GO 45964
// result := false ;
45877: LD_ADDR_VAR 0 2
45881: PUSH
45882: LD_INT 0
45884: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
45885: LD_ADDR_VAR 0 5
45889: PUSH
45890: LD_VAR 0 1
45894: PPUSH
45895: LD_INT 21
45897: PUSH
45898: LD_INT 3
45900: PUSH
45901: EMPTY
45902: LIST
45903: LIST
45904: PPUSH
45905: CALL_OW 72
45909: ST_TO_ADDR
// if not tmp then
45910: LD_VAR 0 5
45914: NOT
45915: IFFALSE 45919
// exit ;
45917: GO 45964
// for i in tmp do
45919: LD_ADDR_VAR 0 3
45923: PUSH
45924: LD_VAR 0 5
45928: PUSH
45929: FOR_IN
45930: IFFALSE 45962
// begin result := EnemyInRange ( i , 22 ) ;
45932: LD_ADDR_VAR 0 2
45936: PUSH
45937: LD_VAR 0 3
45941: PPUSH
45942: LD_INT 22
45944: PPUSH
45945: CALL 43650 0 2
45949: ST_TO_ADDR
// if result then
45950: LD_VAR 0 2
45954: IFFALSE 45960
// exit ;
45956: POP
45957: POP
45958: GO 45964
// end ;
45960: GO 45929
45962: POP
45963: POP
// end ;
45964: LD_VAR 0 2
45968: RET
// export function FilterByTag ( units , tag ) ; begin
45969: LD_INT 0
45971: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
45972: LD_ADDR_VAR 0 3
45976: PUSH
45977: LD_VAR 0 1
45981: PPUSH
45982: LD_INT 120
45984: PUSH
45985: LD_VAR 0 2
45989: PUSH
45990: EMPTY
45991: LIST
45992: LIST
45993: PPUSH
45994: CALL_OW 72
45998: ST_TO_ADDR
// end ;
45999: LD_VAR 0 3
46003: RET
// export function IsDriver ( un ) ; begin
46004: LD_INT 0
46006: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
46007: LD_ADDR_VAR 0 2
46011: PUSH
46012: LD_VAR 0 1
46016: PUSH
46017: LD_INT 55
46019: PUSH
46020: EMPTY
46021: LIST
46022: PPUSH
46023: CALL_OW 69
46027: IN
46028: ST_TO_ADDR
// end ;
46029: LD_VAR 0 2
46033: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
46034: LD_INT 0
46036: PPUSH
46037: PPUSH
// list := [ ] ;
46038: LD_ADDR_VAR 0 5
46042: PUSH
46043: EMPTY
46044: ST_TO_ADDR
// case d of 0 :
46045: LD_VAR 0 3
46049: PUSH
46050: LD_INT 0
46052: DOUBLE
46053: EQUAL
46054: IFTRUE 46058
46056: GO 46191
46058: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
46059: LD_ADDR_VAR 0 5
46063: PUSH
46064: LD_VAR 0 1
46068: PUSH
46069: LD_INT 4
46071: MINUS
46072: PUSH
46073: LD_VAR 0 2
46077: PUSH
46078: LD_INT 4
46080: MINUS
46081: PUSH
46082: LD_INT 2
46084: PUSH
46085: EMPTY
46086: LIST
46087: LIST
46088: LIST
46089: PUSH
46090: LD_VAR 0 1
46094: PUSH
46095: LD_INT 3
46097: MINUS
46098: PUSH
46099: LD_VAR 0 2
46103: PUSH
46104: LD_INT 1
46106: PUSH
46107: EMPTY
46108: LIST
46109: LIST
46110: LIST
46111: PUSH
46112: LD_VAR 0 1
46116: PUSH
46117: LD_INT 4
46119: PLUS
46120: PUSH
46121: LD_VAR 0 2
46125: PUSH
46126: LD_INT 4
46128: PUSH
46129: EMPTY
46130: LIST
46131: LIST
46132: LIST
46133: PUSH
46134: LD_VAR 0 1
46138: PUSH
46139: LD_INT 3
46141: PLUS
46142: PUSH
46143: LD_VAR 0 2
46147: PUSH
46148: LD_INT 3
46150: PLUS
46151: PUSH
46152: LD_INT 5
46154: PUSH
46155: EMPTY
46156: LIST
46157: LIST
46158: LIST
46159: PUSH
46160: LD_VAR 0 1
46164: PUSH
46165: LD_VAR 0 2
46169: PUSH
46170: LD_INT 4
46172: PLUS
46173: PUSH
46174: LD_INT 0
46176: PUSH
46177: EMPTY
46178: LIST
46179: LIST
46180: LIST
46181: PUSH
46182: EMPTY
46183: LIST
46184: LIST
46185: LIST
46186: LIST
46187: LIST
46188: ST_TO_ADDR
// end ; 1 :
46189: GO 46889
46191: LD_INT 1
46193: DOUBLE
46194: EQUAL
46195: IFTRUE 46199
46197: GO 46332
46199: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
46200: LD_ADDR_VAR 0 5
46204: PUSH
46205: LD_VAR 0 1
46209: PUSH
46210: LD_VAR 0 2
46214: PUSH
46215: LD_INT 4
46217: MINUS
46218: PUSH
46219: LD_INT 3
46221: PUSH
46222: EMPTY
46223: LIST
46224: LIST
46225: LIST
46226: PUSH
46227: LD_VAR 0 1
46231: PUSH
46232: LD_INT 3
46234: MINUS
46235: PUSH
46236: LD_VAR 0 2
46240: PUSH
46241: LD_INT 3
46243: MINUS
46244: PUSH
46245: LD_INT 2
46247: PUSH
46248: EMPTY
46249: LIST
46250: LIST
46251: LIST
46252: PUSH
46253: LD_VAR 0 1
46257: PUSH
46258: LD_INT 4
46260: MINUS
46261: PUSH
46262: LD_VAR 0 2
46266: PUSH
46267: LD_INT 1
46269: PUSH
46270: EMPTY
46271: LIST
46272: LIST
46273: LIST
46274: PUSH
46275: LD_VAR 0 1
46279: PUSH
46280: LD_VAR 0 2
46284: PUSH
46285: LD_INT 3
46287: PLUS
46288: PUSH
46289: LD_INT 0
46291: PUSH
46292: EMPTY
46293: LIST
46294: LIST
46295: LIST
46296: PUSH
46297: LD_VAR 0 1
46301: PUSH
46302: LD_INT 4
46304: PLUS
46305: PUSH
46306: LD_VAR 0 2
46310: PUSH
46311: LD_INT 4
46313: PLUS
46314: PUSH
46315: LD_INT 5
46317: PUSH
46318: EMPTY
46319: LIST
46320: LIST
46321: LIST
46322: PUSH
46323: EMPTY
46324: LIST
46325: LIST
46326: LIST
46327: LIST
46328: LIST
46329: ST_TO_ADDR
// end ; 2 :
46330: GO 46889
46332: LD_INT 2
46334: DOUBLE
46335: EQUAL
46336: IFTRUE 46340
46338: GO 46469
46340: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
46341: LD_ADDR_VAR 0 5
46345: PUSH
46346: LD_VAR 0 1
46350: PUSH
46351: LD_VAR 0 2
46355: PUSH
46356: LD_INT 3
46358: MINUS
46359: PUSH
46360: LD_INT 3
46362: PUSH
46363: EMPTY
46364: LIST
46365: LIST
46366: LIST
46367: PUSH
46368: LD_VAR 0 1
46372: PUSH
46373: LD_INT 4
46375: PLUS
46376: PUSH
46377: LD_VAR 0 2
46381: PUSH
46382: LD_INT 4
46384: PUSH
46385: EMPTY
46386: LIST
46387: LIST
46388: LIST
46389: PUSH
46390: LD_VAR 0 1
46394: PUSH
46395: LD_VAR 0 2
46399: PUSH
46400: LD_INT 4
46402: PLUS
46403: PUSH
46404: LD_INT 0
46406: PUSH
46407: EMPTY
46408: LIST
46409: LIST
46410: LIST
46411: PUSH
46412: LD_VAR 0 1
46416: PUSH
46417: LD_INT 3
46419: MINUS
46420: PUSH
46421: LD_VAR 0 2
46425: PUSH
46426: LD_INT 1
46428: PUSH
46429: EMPTY
46430: LIST
46431: LIST
46432: LIST
46433: PUSH
46434: LD_VAR 0 1
46438: PUSH
46439: LD_INT 4
46441: MINUS
46442: PUSH
46443: LD_VAR 0 2
46447: PUSH
46448: LD_INT 4
46450: MINUS
46451: PUSH
46452: LD_INT 2
46454: PUSH
46455: EMPTY
46456: LIST
46457: LIST
46458: LIST
46459: PUSH
46460: EMPTY
46461: LIST
46462: LIST
46463: LIST
46464: LIST
46465: LIST
46466: ST_TO_ADDR
// end ; 3 :
46467: GO 46889
46469: LD_INT 3
46471: DOUBLE
46472: EQUAL
46473: IFTRUE 46477
46475: GO 46610
46477: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
46478: LD_ADDR_VAR 0 5
46482: PUSH
46483: LD_VAR 0 1
46487: PUSH
46488: LD_INT 3
46490: PLUS
46491: PUSH
46492: LD_VAR 0 2
46496: PUSH
46497: LD_INT 4
46499: PUSH
46500: EMPTY
46501: LIST
46502: LIST
46503: LIST
46504: PUSH
46505: LD_VAR 0 1
46509: PUSH
46510: LD_INT 4
46512: PLUS
46513: PUSH
46514: LD_VAR 0 2
46518: PUSH
46519: LD_INT 4
46521: PLUS
46522: PUSH
46523: LD_INT 5
46525: PUSH
46526: EMPTY
46527: LIST
46528: LIST
46529: LIST
46530: PUSH
46531: LD_VAR 0 1
46535: PUSH
46536: LD_INT 4
46538: MINUS
46539: PUSH
46540: LD_VAR 0 2
46544: PUSH
46545: LD_INT 1
46547: PUSH
46548: EMPTY
46549: LIST
46550: LIST
46551: LIST
46552: PUSH
46553: LD_VAR 0 1
46557: PUSH
46558: LD_VAR 0 2
46562: PUSH
46563: LD_INT 4
46565: MINUS
46566: PUSH
46567: LD_INT 3
46569: PUSH
46570: EMPTY
46571: LIST
46572: LIST
46573: LIST
46574: PUSH
46575: LD_VAR 0 1
46579: PUSH
46580: LD_INT 3
46582: MINUS
46583: PUSH
46584: LD_VAR 0 2
46588: PUSH
46589: LD_INT 3
46591: MINUS
46592: PUSH
46593: LD_INT 2
46595: PUSH
46596: EMPTY
46597: LIST
46598: LIST
46599: LIST
46600: PUSH
46601: EMPTY
46602: LIST
46603: LIST
46604: LIST
46605: LIST
46606: LIST
46607: ST_TO_ADDR
// end ; 4 :
46608: GO 46889
46610: LD_INT 4
46612: DOUBLE
46613: EQUAL
46614: IFTRUE 46618
46616: GO 46751
46618: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
46619: LD_ADDR_VAR 0 5
46623: PUSH
46624: LD_VAR 0 1
46628: PUSH
46629: LD_VAR 0 2
46633: PUSH
46634: LD_INT 4
46636: PLUS
46637: PUSH
46638: LD_INT 0
46640: PUSH
46641: EMPTY
46642: LIST
46643: LIST
46644: LIST
46645: PUSH
46646: LD_VAR 0 1
46650: PUSH
46651: LD_INT 3
46653: PLUS
46654: PUSH
46655: LD_VAR 0 2
46659: PUSH
46660: LD_INT 3
46662: PLUS
46663: PUSH
46664: LD_INT 5
46666: PUSH
46667: EMPTY
46668: LIST
46669: LIST
46670: LIST
46671: PUSH
46672: LD_VAR 0 1
46676: PUSH
46677: LD_INT 4
46679: PLUS
46680: PUSH
46681: LD_VAR 0 2
46685: PUSH
46686: LD_INT 4
46688: PUSH
46689: EMPTY
46690: LIST
46691: LIST
46692: LIST
46693: PUSH
46694: LD_VAR 0 1
46698: PUSH
46699: LD_VAR 0 2
46703: PUSH
46704: LD_INT 3
46706: MINUS
46707: PUSH
46708: LD_INT 3
46710: PUSH
46711: EMPTY
46712: LIST
46713: LIST
46714: LIST
46715: PUSH
46716: LD_VAR 0 1
46720: PUSH
46721: LD_INT 4
46723: MINUS
46724: PUSH
46725: LD_VAR 0 2
46729: PUSH
46730: LD_INT 4
46732: MINUS
46733: PUSH
46734: LD_INT 2
46736: PUSH
46737: EMPTY
46738: LIST
46739: LIST
46740: LIST
46741: PUSH
46742: EMPTY
46743: LIST
46744: LIST
46745: LIST
46746: LIST
46747: LIST
46748: ST_TO_ADDR
// end ; 5 :
46749: GO 46889
46751: LD_INT 5
46753: DOUBLE
46754: EQUAL
46755: IFTRUE 46759
46757: GO 46888
46759: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
46760: LD_ADDR_VAR 0 5
46764: PUSH
46765: LD_VAR 0 1
46769: PUSH
46770: LD_INT 4
46772: MINUS
46773: PUSH
46774: LD_VAR 0 2
46778: PUSH
46779: LD_INT 1
46781: PUSH
46782: EMPTY
46783: LIST
46784: LIST
46785: LIST
46786: PUSH
46787: LD_VAR 0 1
46791: PUSH
46792: LD_VAR 0 2
46796: PUSH
46797: LD_INT 4
46799: MINUS
46800: PUSH
46801: LD_INT 3
46803: PUSH
46804: EMPTY
46805: LIST
46806: LIST
46807: LIST
46808: PUSH
46809: LD_VAR 0 1
46813: PUSH
46814: LD_INT 4
46816: PLUS
46817: PUSH
46818: LD_VAR 0 2
46822: PUSH
46823: LD_INT 4
46825: PLUS
46826: PUSH
46827: LD_INT 5
46829: PUSH
46830: EMPTY
46831: LIST
46832: LIST
46833: LIST
46834: PUSH
46835: LD_VAR 0 1
46839: PUSH
46840: LD_INT 3
46842: PLUS
46843: PUSH
46844: LD_VAR 0 2
46848: PUSH
46849: LD_INT 4
46851: PUSH
46852: EMPTY
46853: LIST
46854: LIST
46855: LIST
46856: PUSH
46857: LD_VAR 0 1
46861: PUSH
46862: LD_VAR 0 2
46866: PUSH
46867: LD_INT 3
46869: PLUS
46870: PUSH
46871: LD_INT 0
46873: PUSH
46874: EMPTY
46875: LIST
46876: LIST
46877: LIST
46878: PUSH
46879: EMPTY
46880: LIST
46881: LIST
46882: LIST
46883: LIST
46884: LIST
46885: ST_TO_ADDR
// end ; end ;
46886: GO 46889
46888: POP
// result := list ;
46889: LD_ADDR_VAR 0 4
46893: PUSH
46894: LD_VAR 0 5
46898: ST_TO_ADDR
// end ;
46899: LD_VAR 0 4
46903: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
46904: LD_INT 0
46906: PPUSH
46907: PPUSH
46908: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
46909: LD_VAR 0 1
46913: NOT
46914: PUSH
46915: LD_VAR 0 2
46919: PUSH
46920: LD_INT 1
46922: PUSH
46923: LD_INT 2
46925: PUSH
46926: LD_INT 3
46928: PUSH
46929: LD_INT 4
46931: PUSH
46932: EMPTY
46933: LIST
46934: LIST
46935: LIST
46936: LIST
46937: IN
46938: NOT
46939: OR
46940: IFFALSE 46944
// exit ;
46942: GO 47036
// tmp := [ ] ;
46944: LD_ADDR_VAR 0 5
46948: PUSH
46949: EMPTY
46950: ST_TO_ADDR
// for i in units do
46951: LD_ADDR_VAR 0 4
46955: PUSH
46956: LD_VAR 0 1
46960: PUSH
46961: FOR_IN
46962: IFFALSE 47005
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
46964: LD_ADDR_VAR 0 5
46968: PUSH
46969: LD_VAR 0 5
46973: PPUSH
46974: LD_VAR 0 5
46978: PUSH
46979: LD_INT 1
46981: PLUS
46982: PPUSH
46983: LD_VAR 0 4
46987: PPUSH
46988: LD_VAR 0 2
46992: PPUSH
46993: CALL_OW 259
46997: PPUSH
46998: CALL_OW 2
47002: ST_TO_ADDR
47003: GO 46961
47005: POP
47006: POP
// if not tmp then
47007: LD_VAR 0 5
47011: NOT
47012: IFFALSE 47016
// exit ;
47014: GO 47036
// result := SortListByListDesc ( units , tmp ) ;
47016: LD_ADDR_VAR 0 3
47020: PUSH
47021: LD_VAR 0 1
47025: PPUSH
47026: LD_VAR 0 5
47030: PPUSH
47031: CALL_OW 77
47035: ST_TO_ADDR
// end ;
47036: LD_VAR 0 3
47040: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
47041: LD_INT 0
47043: PPUSH
47044: PPUSH
47045: PPUSH
// result := false ;
47046: LD_ADDR_VAR 0 3
47050: PUSH
47051: LD_INT 0
47053: ST_TO_ADDR
// x := GetX ( building ) ;
47054: LD_ADDR_VAR 0 4
47058: PUSH
47059: LD_VAR 0 2
47063: PPUSH
47064: CALL_OW 250
47068: ST_TO_ADDR
// y := GetY ( building ) ;
47069: LD_ADDR_VAR 0 5
47073: PUSH
47074: LD_VAR 0 2
47078: PPUSH
47079: CALL_OW 251
47083: ST_TO_ADDR
// if not building or not x or not y then
47084: LD_VAR 0 2
47088: NOT
47089: PUSH
47090: LD_VAR 0 4
47094: NOT
47095: OR
47096: PUSH
47097: LD_VAR 0 5
47101: NOT
47102: OR
47103: IFFALSE 47107
// exit ;
47105: GO 47199
// if GetTaskList ( unit ) then
47107: LD_VAR 0 1
47111: PPUSH
47112: CALL_OW 437
47116: IFFALSE 47199
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
47118: LD_STRING e
47120: PUSH
47121: LD_VAR 0 1
47125: PPUSH
47126: CALL_OW 437
47130: PUSH
47131: LD_INT 1
47133: ARRAY
47134: PUSH
47135: LD_INT 1
47137: ARRAY
47138: EQUAL
47139: PUSH
47140: LD_VAR 0 4
47144: PUSH
47145: LD_VAR 0 1
47149: PPUSH
47150: CALL_OW 437
47154: PUSH
47155: LD_INT 1
47157: ARRAY
47158: PUSH
47159: LD_INT 2
47161: ARRAY
47162: EQUAL
47163: AND
47164: PUSH
47165: LD_VAR 0 5
47169: PUSH
47170: LD_VAR 0 1
47174: PPUSH
47175: CALL_OW 437
47179: PUSH
47180: LD_INT 1
47182: ARRAY
47183: PUSH
47184: LD_INT 3
47186: ARRAY
47187: EQUAL
47188: AND
47189: IFFALSE 47199
// result := true end ;
47191: LD_ADDR_VAR 0 3
47195: PUSH
47196: LD_INT 1
47198: ST_TO_ADDR
// end ;
47199: LD_VAR 0 3
47203: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
47204: LD_INT 0
47206: PPUSH
// result := false ;
47207: LD_ADDR_VAR 0 4
47211: PUSH
47212: LD_INT 0
47214: ST_TO_ADDR
// if GetTaskList ( unit ) then
47215: LD_VAR 0 1
47219: PPUSH
47220: CALL_OW 437
47224: IFFALSE 47307
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
47226: LD_STRING M
47228: PUSH
47229: LD_VAR 0 1
47233: PPUSH
47234: CALL_OW 437
47238: PUSH
47239: LD_INT 1
47241: ARRAY
47242: PUSH
47243: LD_INT 1
47245: ARRAY
47246: EQUAL
47247: PUSH
47248: LD_VAR 0 2
47252: PUSH
47253: LD_VAR 0 1
47257: PPUSH
47258: CALL_OW 437
47262: PUSH
47263: LD_INT 1
47265: ARRAY
47266: PUSH
47267: LD_INT 2
47269: ARRAY
47270: EQUAL
47271: AND
47272: PUSH
47273: LD_VAR 0 3
47277: PUSH
47278: LD_VAR 0 1
47282: PPUSH
47283: CALL_OW 437
47287: PUSH
47288: LD_INT 1
47290: ARRAY
47291: PUSH
47292: LD_INT 3
47294: ARRAY
47295: EQUAL
47296: AND
47297: IFFALSE 47307
// result := true ;
47299: LD_ADDR_VAR 0 4
47303: PUSH
47304: LD_INT 1
47306: ST_TO_ADDR
// end ; end ;
47307: LD_VAR 0 4
47311: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
47312: LD_INT 0
47314: PPUSH
47315: PPUSH
47316: PPUSH
47317: PPUSH
// if not unit or not area then
47318: LD_VAR 0 1
47322: NOT
47323: PUSH
47324: LD_VAR 0 2
47328: NOT
47329: OR
47330: IFFALSE 47334
// exit ;
47332: GO 47498
// tmp := AreaToList ( area , i ) ;
47334: LD_ADDR_VAR 0 6
47338: PUSH
47339: LD_VAR 0 2
47343: PPUSH
47344: LD_VAR 0 5
47348: PPUSH
47349: CALL_OW 517
47353: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
47354: LD_ADDR_VAR 0 5
47358: PUSH
47359: DOUBLE
47360: LD_INT 1
47362: DEC
47363: ST_TO_ADDR
47364: LD_VAR 0 6
47368: PUSH
47369: LD_INT 1
47371: ARRAY
47372: PUSH
47373: FOR_TO
47374: IFFALSE 47496
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
47376: LD_ADDR_VAR 0 7
47380: PUSH
47381: LD_VAR 0 6
47385: PUSH
47386: LD_INT 1
47388: ARRAY
47389: PUSH
47390: LD_VAR 0 5
47394: ARRAY
47395: PUSH
47396: LD_VAR 0 6
47400: PUSH
47401: LD_INT 2
47403: ARRAY
47404: PUSH
47405: LD_VAR 0 5
47409: ARRAY
47410: PUSH
47411: EMPTY
47412: LIST
47413: LIST
47414: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
47415: LD_VAR 0 7
47419: PUSH
47420: LD_INT 1
47422: ARRAY
47423: PPUSH
47424: LD_VAR 0 7
47428: PUSH
47429: LD_INT 2
47431: ARRAY
47432: PPUSH
47433: CALL_OW 428
47437: PUSH
47438: LD_INT 0
47440: EQUAL
47441: IFFALSE 47494
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
47443: LD_VAR 0 1
47447: PPUSH
47448: LD_VAR 0 7
47452: PUSH
47453: LD_INT 1
47455: ARRAY
47456: PPUSH
47457: LD_VAR 0 7
47461: PUSH
47462: LD_INT 2
47464: ARRAY
47465: PPUSH
47466: LD_VAR 0 3
47470: PPUSH
47471: CALL_OW 48
// result := IsPlaced ( unit ) ;
47475: LD_ADDR_VAR 0 4
47479: PUSH
47480: LD_VAR 0 1
47484: PPUSH
47485: CALL_OW 305
47489: ST_TO_ADDR
// exit ;
47490: POP
47491: POP
47492: GO 47498
// end ; end ;
47494: GO 47373
47496: POP
47497: POP
// end ;
47498: LD_VAR 0 4
47502: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
47503: LD_INT 0
47505: PPUSH
47506: PPUSH
47507: PPUSH
// if not side or side > 8 then
47508: LD_VAR 0 1
47512: NOT
47513: PUSH
47514: LD_VAR 0 1
47518: PUSH
47519: LD_INT 8
47521: GREATER
47522: OR
47523: IFFALSE 47527
// exit ;
47525: GO 47714
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
47527: LD_ADDR_VAR 0 4
47531: PUSH
47532: LD_INT 22
47534: PUSH
47535: LD_VAR 0 1
47539: PUSH
47540: EMPTY
47541: LIST
47542: LIST
47543: PUSH
47544: LD_INT 21
47546: PUSH
47547: LD_INT 3
47549: PUSH
47550: EMPTY
47551: LIST
47552: LIST
47553: PUSH
47554: EMPTY
47555: LIST
47556: LIST
47557: PPUSH
47558: CALL_OW 69
47562: ST_TO_ADDR
// if not tmp then
47563: LD_VAR 0 4
47567: NOT
47568: IFFALSE 47572
// exit ;
47570: GO 47714
// enable_addtolog := true ;
47572: LD_ADDR_OWVAR 81
47576: PUSH
47577: LD_INT 1
47579: ST_TO_ADDR
// AddToLog ( [ ) ;
47580: LD_STRING [
47582: PPUSH
47583: CALL_OW 561
// for i in tmp do
47587: LD_ADDR_VAR 0 3
47591: PUSH
47592: LD_VAR 0 4
47596: PUSH
47597: FOR_IN
47598: IFFALSE 47705
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
47600: LD_STRING [
47602: PUSH
47603: LD_VAR 0 3
47607: PPUSH
47608: CALL_OW 266
47612: STR
47613: PUSH
47614: LD_STRING , 
47616: STR
47617: PUSH
47618: LD_VAR 0 3
47622: PPUSH
47623: CALL_OW 250
47627: STR
47628: PUSH
47629: LD_STRING , 
47631: STR
47632: PUSH
47633: LD_VAR 0 3
47637: PPUSH
47638: CALL_OW 251
47642: STR
47643: PUSH
47644: LD_STRING , 
47646: STR
47647: PUSH
47648: LD_VAR 0 3
47652: PPUSH
47653: CALL_OW 254
47657: STR
47658: PUSH
47659: LD_STRING , 
47661: STR
47662: PUSH
47663: LD_VAR 0 3
47667: PPUSH
47668: LD_INT 1
47670: PPUSH
47671: CALL_OW 268
47675: STR
47676: PUSH
47677: LD_STRING , 
47679: STR
47680: PUSH
47681: LD_VAR 0 3
47685: PPUSH
47686: LD_INT 2
47688: PPUSH
47689: CALL_OW 268
47693: STR
47694: PUSH
47695: LD_STRING ],
47697: STR
47698: PPUSH
47699: CALL_OW 561
// end ;
47703: GO 47597
47705: POP
47706: POP
// AddToLog ( ]; ) ;
47707: LD_STRING ];
47709: PPUSH
47710: CALL_OW 561
// end ;
47714: LD_VAR 0 2
47718: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
47719: LD_INT 0
47721: PPUSH
47722: PPUSH
47723: PPUSH
47724: PPUSH
47725: PPUSH
// if not area or not rate or not max then
47726: LD_VAR 0 1
47730: NOT
47731: PUSH
47732: LD_VAR 0 2
47736: NOT
47737: OR
47738: PUSH
47739: LD_VAR 0 4
47743: NOT
47744: OR
47745: IFFALSE 47749
// exit ;
47747: GO 47938
// while 1 do
47749: LD_INT 1
47751: IFFALSE 47938
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
47753: LD_ADDR_VAR 0 9
47757: PUSH
47758: LD_VAR 0 1
47762: PPUSH
47763: LD_INT 1
47765: PPUSH
47766: CALL_OW 287
47770: PUSH
47771: LD_INT 10
47773: MUL
47774: ST_TO_ADDR
// r := rate / 10 ;
47775: LD_ADDR_VAR 0 7
47779: PUSH
47780: LD_VAR 0 2
47784: PUSH
47785: LD_INT 10
47787: DIVREAL
47788: ST_TO_ADDR
// time := 1 1$00 ;
47789: LD_ADDR_VAR 0 8
47793: PUSH
47794: LD_INT 2100
47796: ST_TO_ADDR
// if amount < min then
47797: LD_VAR 0 9
47801: PUSH
47802: LD_VAR 0 3
47806: LESS
47807: IFFALSE 47825
// r := r * 2 else
47809: LD_ADDR_VAR 0 7
47813: PUSH
47814: LD_VAR 0 7
47818: PUSH
47819: LD_INT 2
47821: MUL
47822: ST_TO_ADDR
47823: GO 47851
// if amount > max then
47825: LD_VAR 0 9
47829: PUSH
47830: LD_VAR 0 4
47834: GREATER
47835: IFFALSE 47851
// r := r / 2 ;
47837: LD_ADDR_VAR 0 7
47841: PUSH
47842: LD_VAR 0 7
47846: PUSH
47847: LD_INT 2
47849: DIVREAL
47850: ST_TO_ADDR
// time := time / r ;
47851: LD_ADDR_VAR 0 8
47855: PUSH
47856: LD_VAR 0 8
47860: PUSH
47861: LD_VAR 0 7
47865: DIVREAL
47866: ST_TO_ADDR
// if time < 0 then
47867: LD_VAR 0 8
47871: PUSH
47872: LD_INT 0
47874: LESS
47875: IFFALSE 47892
// time := time * - 1 ;
47877: LD_ADDR_VAR 0 8
47881: PUSH
47882: LD_VAR 0 8
47886: PUSH
47887: LD_INT 1
47889: NEG
47890: MUL
47891: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
47892: LD_VAR 0 8
47896: PUSH
47897: LD_INT 35
47899: PPUSH
47900: LD_INT 875
47902: PPUSH
47903: CALL_OW 12
47907: PLUS
47908: PPUSH
47909: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
47913: LD_INT 1
47915: PPUSH
47916: LD_INT 5
47918: PPUSH
47919: CALL_OW 12
47923: PPUSH
47924: LD_VAR 0 1
47928: PPUSH
47929: LD_INT 1
47931: PPUSH
47932: CALL_OW 55
// end ;
47936: GO 47749
// end ;
47938: LD_VAR 0 5
47942: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
47943: LD_INT 0
47945: PPUSH
47946: PPUSH
47947: PPUSH
47948: PPUSH
47949: PPUSH
47950: PPUSH
47951: PPUSH
47952: PPUSH
// if not turrets or not factories then
47953: LD_VAR 0 1
47957: NOT
47958: PUSH
47959: LD_VAR 0 2
47963: NOT
47964: OR
47965: IFFALSE 47969
// exit ;
47967: GO 48276
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
47969: LD_ADDR_VAR 0 10
47973: PUSH
47974: LD_INT 5
47976: PUSH
47977: LD_INT 6
47979: PUSH
47980: EMPTY
47981: LIST
47982: LIST
47983: PUSH
47984: LD_INT 2
47986: PUSH
47987: LD_INT 4
47989: PUSH
47990: EMPTY
47991: LIST
47992: LIST
47993: PUSH
47994: LD_INT 3
47996: PUSH
47997: LD_INT 5
47999: PUSH
48000: EMPTY
48001: LIST
48002: LIST
48003: PUSH
48004: EMPTY
48005: LIST
48006: LIST
48007: LIST
48008: PUSH
48009: LD_INT 24
48011: PUSH
48012: LD_INT 25
48014: PUSH
48015: EMPTY
48016: LIST
48017: LIST
48018: PUSH
48019: LD_INT 23
48021: PUSH
48022: LD_INT 27
48024: PUSH
48025: EMPTY
48026: LIST
48027: LIST
48028: PUSH
48029: EMPTY
48030: LIST
48031: LIST
48032: PUSH
48033: LD_INT 42
48035: PUSH
48036: LD_INT 43
48038: PUSH
48039: EMPTY
48040: LIST
48041: LIST
48042: PUSH
48043: LD_INT 44
48045: PUSH
48046: LD_INT 46
48048: PUSH
48049: EMPTY
48050: LIST
48051: LIST
48052: PUSH
48053: LD_INT 45
48055: PUSH
48056: LD_INT 47
48058: PUSH
48059: EMPTY
48060: LIST
48061: LIST
48062: PUSH
48063: EMPTY
48064: LIST
48065: LIST
48066: LIST
48067: PUSH
48068: EMPTY
48069: LIST
48070: LIST
48071: LIST
48072: ST_TO_ADDR
// result := [ ] ;
48073: LD_ADDR_VAR 0 3
48077: PUSH
48078: EMPTY
48079: ST_TO_ADDR
// for i in turrets do
48080: LD_ADDR_VAR 0 4
48084: PUSH
48085: LD_VAR 0 1
48089: PUSH
48090: FOR_IN
48091: IFFALSE 48274
// begin nat := GetNation ( i ) ;
48093: LD_ADDR_VAR 0 7
48097: PUSH
48098: LD_VAR 0 4
48102: PPUSH
48103: CALL_OW 248
48107: ST_TO_ADDR
// weapon := 0 ;
48108: LD_ADDR_VAR 0 8
48112: PUSH
48113: LD_INT 0
48115: ST_TO_ADDR
// if not nat then
48116: LD_VAR 0 7
48120: NOT
48121: IFFALSE 48125
// continue ;
48123: GO 48090
// for j in list [ nat ] do
48125: LD_ADDR_VAR 0 5
48129: PUSH
48130: LD_VAR 0 10
48134: PUSH
48135: LD_VAR 0 7
48139: ARRAY
48140: PUSH
48141: FOR_IN
48142: IFFALSE 48183
// if GetBWeapon ( i ) = j [ 1 ] then
48144: LD_VAR 0 4
48148: PPUSH
48149: CALL_OW 269
48153: PUSH
48154: LD_VAR 0 5
48158: PUSH
48159: LD_INT 1
48161: ARRAY
48162: EQUAL
48163: IFFALSE 48181
// begin weapon := j [ 2 ] ;
48165: LD_ADDR_VAR 0 8
48169: PUSH
48170: LD_VAR 0 5
48174: PUSH
48175: LD_INT 2
48177: ARRAY
48178: ST_TO_ADDR
// break ;
48179: GO 48183
// end ;
48181: GO 48141
48183: POP
48184: POP
// if not weapon then
48185: LD_VAR 0 8
48189: NOT
48190: IFFALSE 48194
// continue ;
48192: GO 48090
// for k in factories do
48194: LD_ADDR_VAR 0 6
48198: PUSH
48199: LD_VAR 0 2
48203: PUSH
48204: FOR_IN
48205: IFFALSE 48270
// begin weapons := AvailableWeaponList ( k ) ;
48207: LD_ADDR_VAR 0 9
48211: PUSH
48212: LD_VAR 0 6
48216: PPUSH
48217: CALL_OW 478
48221: ST_TO_ADDR
// if not weapons then
48222: LD_VAR 0 9
48226: NOT
48227: IFFALSE 48231
// continue ;
48229: GO 48204
// if weapon in weapons then
48231: LD_VAR 0 8
48235: PUSH
48236: LD_VAR 0 9
48240: IN
48241: IFFALSE 48268
// begin result := [ i , weapon ] ;
48243: LD_ADDR_VAR 0 3
48247: PUSH
48248: LD_VAR 0 4
48252: PUSH
48253: LD_VAR 0 8
48257: PUSH
48258: EMPTY
48259: LIST
48260: LIST
48261: ST_TO_ADDR
// exit ;
48262: POP
48263: POP
48264: POP
48265: POP
48266: GO 48276
// end ; end ;
48268: GO 48204
48270: POP
48271: POP
// end ;
48272: GO 48090
48274: POP
48275: POP
// end ;
48276: LD_VAR 0 3
48280: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
48281: LD_INT 0
48283: PPUSH
// if not side or side > 8 then
48284: LD_VAR 0 3
48288: NOT
48289: PUSH
48290: LD_VAR 0 3
48294: PUSH
48295: LD_INT 8
48297: GREATER
48298: OR
48299: IFFALSE 48303
// exit ;
48301: GO 48362
// if not range then
48303: LD_VAR 0 4
48307: NOT
48308: IFFALSE 48319
// range := - 12 ;
48310: LD_ADDR_VAR 0 4
48314: PUSH
48315: LD_INT 12
48317: NEG
48318: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
48319: LD_VAR 0 1
48323: PPUSH
48324: LD_VAR 0 2
48328: PPUSH
48329: LD_VAR 0 3
48333: PPUSH
48334: LD_VAR 0 4
48338: PPUSH
48339: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
48343: LD_VAR 0 1
48347: PPUSH
48348: LD_VAR 0 2
48352: PPUSH
48353: LD_VAR 0 3
48357: PPUSH
48358: CALL_OW 331
// end ;
48362: LD_VAR 0 5
48366: RET
// export function Video ( mode ) ; begin
48367: LD_INT 0
48369: PPUSH
// ingame_video = mode ;
48370: LD_ADDR_OWVAR 52
48374: PUSH
48375: LD_VAR 0 1
48379: ST_TO_ADDR
// interface_hidden = mode ;
48380: LD_ADDR_OWVAR 54
48384: PUSH
48385: LD_VAR 0 1
48389: ST_TO_ADDR
// end ;
48390: LD_VAR 0 2
48394: RET
// export function Join ( array , element ) ; begin
48395: LD_INT 0
48397: PPUSH
// result := Replace ( array , array + 1 , element ) ;
48398: LD_ADDR_VAR 0 3
48402: PUSH
48403: LD_VAR 0 1
48407: PPUSH
48408: LD_VAR 0 1
48412: PUSH
48413: LD_INT 1
48415: PLUS
48416: PPUSH
48417: LD_VAR 0 2
48421: PPUSH
48422: CALL_OW 1
48426: ST_TO_ADDR
// end ;
48427: LD_VAR 0 3
48431: RET
// export function JoinUnion ( array , element ) ; begin
48432: LD_INT 0
48434: PPUSH
// result := array union element ;
48435: LD_ADDR_VAR 0 3
48439: PUSH
48440: LD_VAR 0 1
48444: PUSH
48445: LD_VAR 0 2
48449: UNION
48450: ST_TO_ADDR
// end ;
48451: LD_VAR 0 3
48455: RET
// export function GetBehemoths ( side ) ; begin
48456: LD_INT 0
48458: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
48459: LD_ADDR_VAR 0 2
48463: PUSH
48464: LD_INT 22
48466: PUSH
48467: LD_VAR 0 1
48471: PUSH
48472: EMPTY
48473: LIST
48474: LIST
48475: PUSH
48476: LD_INT 31
48478: PUSH
48479: LD_INT 25
48481: PUSH
48482: EMPTY
48483: LIST
48484: LIST
48485: PUSH
48486: EMPTY
48487: LIST
48488: LIST
48489: PPUSH
48490: CALL_OW 69
48494: ST_TO_ADDR
// end ;
48495: LD_VAR 0 2
48499: RET
// export function Shuffle ( array ) ; var i , index ; begin
48500: LD_INT 0
48502: PPUSH
48503: PPUSH
48504: PPUSH
// result := [ ] ;
48505: LD_ADDR_VAR 0 2
48509: PUSH
48510: EMPTY
48511: ST_TO_ADDR
// if not array then
48512: LD_VAR 0 1
48516: NOT
48517: IFFALSE 48521
// exit ;
48519: GO 48620
// Randomize ;
48521: CALL_OW 10
// for i = array downto 1 do
48525: LD_ADDR_VAR 0 3
48529: PUSH
48530: DOUBLE
48531: LD_VAR 0 1
48535: INC
48536: ST_TO_ADDR
48537: LD_INT 1
48539: PUSH
48540: FOR_DOWNTO
48541: IFFALSE 48618
// begin index := rand ( 1 , array ) ;
48543: LD_ADDR_VAR 0 4
48547: PUSH
48548: LD_INT 1
48550: PPUSH
48551: LD_VAR 0 1
48555: PPUSH
48556: CALL_OW 12
48560: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
48561: LD_ADDR_VAR 0 2
48565: PUSH
48566: LD_VAR 0 2
48570: PPUSH
48571: LD_VAR 0 2
48575: PUSH
48576: LD_INT 1
48578: PLUS
48579: PPUSH
48580: LD_VAR 0 1
48584: PUSH
48585: LD_VAR 0 4
48589: ARRAY
48590: PPUSH
48591: CALL_OW 2
48595: ST_TO_ADDR
// array := Delete ( array , index ) ;
48596: LD_ADDR_VAR 0 1
48600: PUSH
48601: LD_VAR 0 1
48605: PPUSH
48606: LD_VAR 0 4
48610: PPUSH
48611: CALL_OW 3
48615: ST_TO_ADDR
// end ;
48616: GO 48540
48618: POP
48619: POP
// end ;
48620: LD_VAR 0 2
48624: RET
// export function GetBaseMaterials ( base ) ; begin
48625: LD_INT 0
48627: PPUSH
// result := [ 0 , 0 , 0 ] ;
48628: LD_ADDR_VAR 0 2
48632: PUSH
48633: LD_INT 0
48635: PUSH
48636: LD_INT 0
48638: PUSH
48639: LD_INT 0
48641: PUSH
48642: EMPTY
48643: LIST
48644: LIST
48645: LIST
48646: ST_TO_ADDR
// if not base then
48647: LD_VAR 0 1
48651: NOT
48652: IFFALSE 48656
// exit ;
48654: GO 48705
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
48656: LD_ADDR_VAR 0 2
48660: PUSH
48661: LD_VAR 0 1
48665: PPUSH
48666: LD_INT 1
48668: PPUSH
48669: CALL_OW 275
48673: PUSH
48674: LD_VAR 0 1
48678: PPUSH
48679: LD_INT 2
48681: PPUSH
48682: CALL_OW 275
48686: PUSH
48687: LD_VAR 0 1
48691: PPUSH
48692: LD_INT 3
48694: PPUSH
48695: CALL_OW 275
48699: PUSH
48700: EMPTY
48701: LIST
48702: LIST
48703: LIST
48704: ST_TO_ADDR
// end ;
48705: LD_VAR 0 2
48709: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
48710: LD_INT 0
48712: PPUSH
48713: PPUSH
// result := array ;
48714: LD_ADDR_VAR 0 3
48718: PUSH
48719: LD_VAR 0 1
48723: ST_TO_ADDR
// if size >= result then
48724: LD_VAR 0 2
48728: PUSH
48729: LD_VAR 0 3
48733: GREATEREQUAL
48734: IFFALSE 48738
// exit ;
48736: GO 48788
// if size then
48738: LD_VAR 0 2
48742: IFFALSE 48788
// for i := array downto size do
48744: LD_ADDR_VAR 0 4
48748: PUSH
48749: DOUBLE
48750: LD_VAR 0 1
48754: INC
48755: ST_TO_ADDR
48756: LD_VAR 0 2
48760: PUSH
48761: FOR_DOWNTO
48762: IFFALSE 48786
// result := Delete ( result , result ) ;
48764: LD_ADDR_VAR 0 3
48768: PUSH
48769: LD_VAR 0 3
48773: PPUSH
48774: LD_VAR 0 3
48778: PPUSH
48779: CALL_OW 3
48783: ST_TO_ADDR
48784: GO 48761
48786: POP
48787: POP
// end ;
48788: LD_VAR 0 3
48792: RET
// export function ComExit ( unit ) ; var tmp ; begin
48793: LD_INT 0
48795: PPUSH
48796: PPUSH
// if not IsInUnit ( unit ) then
48797: LD_VAR 0 1
48801: PPUSH
48802: CALL_OW 310
48806: NOT
48807: IFFALSE 48811
// exit ;
48809: GO 48871
// tmp := IsInUnit ( unit ) ;
48811: LD_ADDR_VAR 0 3
48815: PUSH
48816: LD_VAR 0 1
48820: PPUSH
48821: CALL_OW 310
48825: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
48826: LD_VAR 0 3
48830: PPUSH
48831: CALL_OW 247
48835: PUSH
48836: LD_INT 2
48838: EQUAL
48839: IFFALSE 48852
// ComExitVehicle ( unit ) else
48841: LD_VAR 0 1
48845: PPUSH
48846: CALL_OW 121
48850: GO 48861
// ComExitBuilding ( unit ) ;
48852: LD_VAR 0 1
48856: PPUSH
48857: CALL_OW 122
// result := tmp ;
48861: LD_ADDR_VAR 0 2
48865: PUSH
48866: LD_VAR 0 3
48870: ST_TO_ADDR
// end ;
48871: LD_VAR 0 2
48875: RET
// export function ComExitAll ( units ) ; var i ; begin
48876: LD_INT 0
48878: PPUSH
48879: PPUSH
// if not units then
48880: LD_VAR 0 1
48884: NOT
48885: IFFALSE 48889
// exit ;
48887: GO 48915
// for i in units do
48889: LD_ADDR_VAR 0 3
48893: PUSH
48894: LD_VAR 0 1
48898: PUSH
48899: FOR_IN
48900: IFFALSE 48913
// ComExit ( i ) ;
48902: LD_VAR 0 3
48906: PPUSH
48907: CALL 48793 0 1
48911: GO 48899
48913: POP
48914: POP
// end ;
48915: LD_VAR 0 2
48919: RET
// export function ResetHc ; begin
48920: LD_INT 0
48922: PPUSH
// InitHc ;
48923: CALL_OW 19
// hc_importance := 0 ;
48927: LD_ADDR_OWVAR 32
48931: PUSH
48932: LD_INT 0
48934: ST_TO_ADDR
// end ;
48935: LD_VAR 0 1
48939: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
48940: LD_INT 0
48942: PPUSH
48943: PPUSH
48944: PPUSH
// _x := ( x1 + x2 ) div 2 ;
48945: LD_ADDR_VAR 0 6
48949: PUSH
48950: LD_VAR 0 1
48954: PUSH
48955: LD_VAR 0 3
48959: PLUS
48960: PUSH
48961: LD_INT 2
48963: DIV
48964: ST_TO_ADDR
// if _x < 0 then
48965: LD_VAR 0 6
48969: PUSH
48970: LD_INT 0
48972: LESS
48973: IFFALSE 48990
// _x := _x * - 1 ;
48975: LD_ADDR_VAR 0 6
48979: PUSH
48980: LD_VAR 0 6
48984: PUSH
48985: LD_INT 1
48987: NEG
48988: MUL
48989: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
48990: LD_ADDR_VAR 0 7
48994: PUSH
48995: LD_VAR 0 2
48999: PUSH
49000: LD_VAR 0 4
49004: PLUS
49005: PUSH
49006: LD_INT 2
49008: DIV
49009: ST_TO_ADDR
// if _y < 0 then
49010: LD_VAR 0 7
49014: PUSH
49015: LD_INT 0
49017: LESS
49018: IFFALSE 49035
// _y := _y * - 1 ;
49020: LD_ADDR_VAR 0 7
49024: PUSH
49025: LD_VAR 0 7
49029: PUSH
49030: LD_INT 1
49032: NEG
49033: MUL
49034: ST_TO_ADDR
// result := [ _x , _y ] ;
49035: LD_ADDR_VAR 0 5
49039: PUSH
49040: LD_VAR 0 6
49044: PUSH
49045: LD_VAR 0 7
49049: PUSH
49050: EMPTY
49051: LIST
49052: LIST
49053: ST_TO_ADDR
// end ;
49054: LD_VAR 0 5
49058: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
49059: LD_INT 0
49061: PPUSH
49062: PPUSH
49063: PPUSH
49064: PPUSH
// task := GetTaskList ( unit ) ;
49065: LD_ADDR_VAR 0 7
49069: PUSH
49070: LD_VAR 0 1
49074: PPUSH
49075: CALL_OW 437
49079: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
49080: LD_VAR 0 7
49084: NOT
49085: PUSH
49086: LD_VAR 0 1
49090: PPUSH
49091: LD_VAR 0 2
49095: PPUSH
49096: CALL_OW 308
49100: NOT
49101: AND
49102: IFFALSE 49106
// exit ;
49104: GO 49224
// if IsInArea ( unit , area ) then
49106: LD_VAR 0 1
49110: PPUSH
49111: LD_VAR 0 2
49115: PPUSH
49116: CALL_OW 308
49120: IFFALSE 49138
// begin ComMoveToArea ( unit , goAway ) ;
49122: LD_VAR 0 1
49126: PPUSH
49127: LD_VAR 0 3
49131: PPUSH
49132: CALL_OW 113
// exit ;
49136: GO 49224
// end ; if task [ 1 ] [ 1 ] <> M then
49138: LD_VAR 0 7
49142: PUSH
49143: LD_INT 1
49145: ARRAY
49146: PUSH
49147: LD_INT 1
49149: ARRAY
49150: PUSH
49151: LD_STRING M
49153: NONEQUAL
49154: IFFALSE 49158
// exit ;
49156: GO 49224
// x := task [ 1 ] [ 2 ] ;
49158: LD_ADDR_VAR 0 5
49162: PUSH
49163: LD_VAR 0 7
49167: PUSH
49168: LD_INT 1
49170: ARRAY
49171: PUSH
49172: LD_INT 2
49174: ARRAY
49175: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
49176: LD_ADDR_VAR 0 6
49180: PUSH
49181: LD_VAR 0 7
49185: PUSH
49186: LD_INT 1
49188: ARRAY
49189: PUSH
49190: LD_INT 3
49192: ARRAY
49193: ST_TO_ADDR
// if InArea ( x , y , area ) then
49194: LD_VAR 0 5
49198: PPUSH
49199: LD_VAR 0 6
49203: PPUSH
49204: LD_VAR 0 2
49208: PPUSH
49209: CALL_OW 309
49213: IFFALSE 49224
// ComStop ( unit ) ;
49215: LD_VAR 0 1
49219: PPUSH
49220: CALL_OW 141
// end ;
49224: LD_VAR 0 4
49228: RET
// export function Abs ( value ) ; begin
49229: LD_INT 0
49231: PPUSH
// result := value ;
49232: LD_ADDR_VAR 0 2
49236: PUSH
49237: LD_VAR 0 1
49241: ST_TO_ADDR
// if value < 0 then
49242: LD_VAR 0 1
49246: PUSH
49247: LD_INT 0
49249: LESS
49250: IFFALSE 49267
// result := value * - 1 ;
49252: LD_ADDR_VAR 0 2
49256: PUSH
49257: LD_VAR 0 1
49261: PUSH
49262: LD_INT 1
49264: NEG
49265: MUL
49266: ST_TO_ADDR
// end ;
49267: LD_VAR 0 2
49271: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
49272: LD_INT 0
49274: PPUSH
49275: PPUSH
49276: PPUSH
49277: PPUSH
49278: PPUSH
49279: PPUSH
49280: PPUSH
49281: PPUSH
// if not unit or not building then
49282: LD_VAR 0 1
49286: NOT
49287: PUSH
49288: LD_VAR 0 2
49292: NOT
49293: OR
49294: IFFALSE 49298
// exit ;
49296: GO 49524
// x := GetX ( building ) ;
49298: LD_ADDR_VAR 0 4
49302: PUSH
49303: LD_VAR 0 2
49307: PPUSH
49308: CALL_OW 250
49312: ST_TO_ADDR
// y := GetY ( building ) ;
49313: LD_ADDR_VAR 0 6
49317: PUSH
49318: LD_VAR 0 2
49322: PPUSH
49323: CALL_OW 251
49327: ST_TO_ADDR
// d := GetDir ( building ) ;
49328: LD_ADDR_VAR 0 8
49332: PUSH
49333: LD_VAR 0 2
49337: PPUSH
49338: CALL_OW 254
49342: ST_TO_ADDR
// r := 4 ;
49343: LD_ADDR_VAR 0 9
49347: PUSH
49348: LD_INT 4
49350: ST_TO_ADDR
// for i := 1 to 5 do
49351: LD_ADDR_VAR 0 10
49355: PUSH
49356: DOUBLE
49357: LD_INT 1
49359: DEC
49360: ST_TO_ADDR
49361: LD_INT 5
49363: PUSH
49364: FOR_TO
49365: IFFALSE 49522
// begin _x := ShiftX ( x , d , r + i ) ;
49367: LD_ADDR_VAR 0 5
49371: PUSH
49372: LD_VAR 0 4
49376: PPUSH
49377: LD_VAR 0 8
49381: PPUSH
49382: LD_VAR 0 9
49386: PUSH
49387: LD_VAR 0 10
49391: PLUS
49392: PPUSH
49393: CALL_OW 272
49397: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
49398: LD_ADDR_VAR 0 7
49402: PUSH
49403: LD_VAR 0 6
49407: PPUSH
49408: LD_VAR 0 8
49412: PPUSH
49413: LD_VAR 0 9
49417: PUSH
49418: LD_VAR 0 10
49422: PLUS
49423: PPUSH
49424: CALL_OW 273
49428: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
49429: LD_VAR 0 5
49433: PPUSH
49434: LD_VAR 0 7
49438: PPUSH
49439: CALL_OW 488
49443: PUSH
49444: LD_VAR 0 5
49448: PPUSH
49449: LD_VAR 0 7
49453: PPUSH
49454: CALL_OW 428
49458: PPUSH
49459: CALL_OW 247
49463: PUSH
49464: LD_INT 3
49466: PUSH
49467: LD_INT 2
49469: PUSH
49470: EMPTY
49471: LIST
49472: LIST
49473: IN
49474: NOT
49475: AND
49476: IFFALSE 49520
// begin ComMoveXY ( unit , _x , _y ) ;
49478: LD_VAR 0 1
49482: PPUSH
49483: LD_VAR 0 5
49487: PPUSH
49488: LD_VAR 0 7
49492: PPUSH
49493: CALL_OW 111
// result := [ _x , _y ] ;
49497: LD_ADDR_VAR 0 3
49501: PUSH
49502: LD_VAR 0 5
49506: PUSH
49507: LD_VAR 0 7
49511: PUSH
49512: EMPTY
49513: LIST
49514: LIST
49515: ST_TO_ADDR
// exit ;
49516: POP
49517: POP
49518: GO 49524
// end ; end ;
49520: GO 49364
49522: POP
49523: POP
// end ;
49524: LD_VAR 0 3
49528: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
49529: LD_INT 0
49531: PPUSH
49532: PPUSH
49533: PPUSH
// result := 0 ;
49534: LD_ADDR_VAR 0 3
49538: PUSH
49539: LD_INT 0
49541: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
49542: LD_VAR 0 1
49546: PUSH
49547: LD_INT 0
49549: LESS
49550: PUSH
49551: LD_VAR 0 1
49555: PUSH
49556: LD_INT 8
49558: GREATER
49559: OR
49560: PUSH
49561: LD_VAR 0 2
49565: PUSH
49566: LD_INT 0
49568: LESS
49569: OR
49570: PUSH
49571: LD_VAR 0 2
49575: PUSH
49576: LD_INT 8
49578: GREATER
49579: OR
49580: IFFALSE 49584
// exit ;
49582: GO 49659
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
49584: LD_ADDR_VAR 0 4
49588: PUSH
49589: LD_INT 22
49591: PUSH
49592: LD_VAR 0 2
49596: PUSH
49597: EMPTY
49598: LIST
49599: LIST
49600: PPUSH
49601: CALL_OW 69
49605: PUSH
49606: FOR_IN
49607: IFFALSE 49657
// begin un := UnitShoot ( i ) ;
49609: LD_ADDR_VAR 0 5
49613: PUSH
49614: LD_VAR 0 4
49618: PPUSH
49619: CALL_OW 504
49623: ST_TO_ADDR
// if GetSide ( un ) = side1 then
49624: LD_VAR 0 5
49628: PPUSH
49629: CALL_OW 255
49633: PUSH
49634: LD_VAR 0 1
49638: EQUAL
49639: IFFALSE 49655
// begin result := un ;
49641: LD_ADDR_VAR 0 3
49645: PUSH
49646: LD_VAR 0 5
49650: ST_TO_ADDR
// exit ;
49651: POP
49652: POP
49653: GO 49659
// end ; end ;
49655: GO 49606
49657: POP
49658: POP
// end ;
49659: LD_VAR 0 3
49663: RET
// export function GetCargoBay ( units ) ; begin
49664: LD_INT 0
49666: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
49667: LD_ADDR_VAR 0 2
49671: PUSH
49672: LD_VAR 0 1
49676: PPUSH
49677: LD_INT 2
49679: PUSH
49680: LD_INT 34
49682: PUSH
49683: LD_INT 12
49685: PUSH
49686: EMPTY
49687: LIST
49688: LIST
49689: PUSH
49690: LD_INT 34
49692: PUSH
49693: LD_INT 51
49695: PUSH
49696: EMPTY
49697: LIST
49698: LIST
49699: PUSH
49700: LD_INT 34
49702: PUSH
49703: LD_INT 32
49705: PUSH
49706: EMPTY
49707: LIST
49708: LIST
49709: PUSH
49710: LD_INT 34
49712: PUSH
49713: LD_INT 89
49715: PUSH
49716: EMPTY
49717: LIST
49718: LIST
49719: PUSH
49720: EMPTY
49721: LIST
49722: LIST
49723: LIST
49724: LIST
49725: LIST
49726: PPUSH
49727: CALL_OW 72
49731: ST_TO_ADDR
// end ;
49732: LD_VAR 0 2
49736: RET
// export function Negate ( value ) ; begin
49737: LD_INT 0
49739: PPUSH
// result := not value ;
49740: LD_ADDR_VAR 0 2
49744: PUSH
49745: LD_VAR 0 1
49749: NOT
49750: ST_TO_ADDR
// end ;
49751: LD_VAR 0 2
49755: RET
// export function Inc ( value ) ; begin
49756: LD_INT 0
49758: PPUSH
// result := value + 1 ;
49759: LD_ADDR_VAR 0 2
49763: PUSH
49764: LD_VAR 0 1
49768: PUSH
49769: LD_INT 1
49771: PLUS
49772: ST_TO_ADDR
// end ;
49773: LD_VAR 0 2
49777: RET
// export function Dec ( value ) ; begin
49778: LD_INT 0
49780: PPUSH
// result := value - 1 ;
49781: LD_ADDR_VAR 0 2
49785: PUSH
49786: LD_VAR 0 1
49790: PUSH
49791: LD_INT 1
49793: MINUS
49794: ST_TO_ADDR
// end ;
49795: LD_VAR 0 2
49799: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
49800: LD_INT 0
49802: PPUSH
49803: PPUSH
49804: PPUSH
49805: PPUSH
49806: PPUSH
49807: PPUSH
49808: PPUSH
49809: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
49810: LD_VAR 0 1
49814: PPUSH
49815: LD_VAR 0 2
49819: PPUSH
49820: CALL_OW 488
49824: NOT
49825: PUSH
49826: LD_VAR 0 3
49830: PPUSH
49831: LD_VAR 0 4
49835: PPUSH
49836: CALL_OW 488
49840: NOT
49841: OR
49842: IFFALSE 49855
// begin result := - 1 ;
49844: LD_ADDR_VAR 0 5
49848: PUSH
49849: LD_INT 1
49851: NEG
49852: ST_TO_ADDR
// exit ;
49853: GO 50090
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
49855: LD_ADDR_VAR 0 12
49859: PUSH
49860: LD_VAR 0 1
49864: PPUSH
49865: LD_VAR 0 2
49869: PPUSH
49870: LD_VAR 0 3
49874: PPUSH
49875: LD_VAR 0 4
49879: PPUSH
49880: CALL 48940 0 4
49884: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
49885: LD_ADDR_VAR 0 11
49889: PUSH
49890: LD_VAR 0 1
49894: PPUSH
49895: LD_VAR 0 2
49899: PPUSH
49900: LD_VAR 0 12
49904: PUSH
49905: LD_INT 1
49907: ARRAY
49908: PPUSH
49909: LD_VAR 0 12
49913: PUSH
49914: LD_INT 2
49916: ARRAY
49917: PPUSH
49918: CALL_OW 298
49922: ST_TO_ADDR
// distance := 9999 ;
49923: LD_ADDR_VAR 0 10
49927: PUSH
49928: LD_INT 9999
49930: ST_TO_ADDR
// for i := 0 to 5 do
49931: LD_ADDR_VAR 0 6
49935: PUSH
49936: DOUBLE
49937: LD_INT 0
49939: DEC
49940: ST_TO_ADDR
49941: LD_INT 5
49943: PUSH
49944: FOR_TO
49945: IFFALSE 50088
// begin _x := ShiftX ( x1 , i , centerDist ) ;
49947: LD_ADDR_VAR 0 7
49951: PUSH
49952: LD_VAR 0 1
49956: PPUSH
49957: LD_VAR 0 6
49961: PPUSH
49962: LD_VAR 0 11
49966: PPUSH
49967: CALL_OW 272
49971: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
49972: LD_ADDR_VAR 0 8
49976: PUSH
49977: LD_VAR 0 2
49981: PPUSH
49982: LD_VAR 0 6
49986: PPUSH
49987: LD_VAR 0 11
49991: PPUSH
49992: CALL_OW 273
49996: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
49997: LD_VAR 0 7
50001: PPUSH
50002: LD_VAR 0 8
50006: PPUSH
50007: CALL_OW 488
50011: NOT
50012: IFFALSE 50016
// continue ;
50014: GO 49944
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
50016: LD_ADDR_VAR 0 9
50020: PUSH
50021: LD_VAR 0 12
50025: PUSH
50026: LD_INT 1
50028: ARRAY
50029: PPUSH
50030: LD_VAR 0 12
50034: PUSH
50035: LD_INT 2
50037: ARRAY
50038: PPUSH
50039: LD_VAR 0 7
50043: PPUSH
50044: LD_VAR 0 8
50048: PPUSH
50049: CALL_OW 298
50053: ST_TO_ADDR
// if tmp < distance then
50054: LD_VAR 0 9
50058: PUSH
50059: LD_VAR 0 10
50063: LESS
50064: IFFALSE 50086
// begin result := i ;
50066: LD_ADDR_VAR 0 5
50070: PUSH
50071: LD_VAR 0 6
50075: ST_TO_ADDR
// distance := tmp ;
50076: LD_ADDR_VAR 0 10
50080: PUSH
50081: LD_VAR 0 9
50085: ST_TO_ADDR
// end ; end ;
50086: GO 49944
50088: POP
50089: POP
// end ;
50090: LD_VAR 0 5
50094: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
50095: LD_INT 0
50097: PPUSH
50098: PPUSH
// if not driver or not IsInUnit ( driver ) then
50099: LD_VAR 0 1
50103: NOT
50104: PUSH
50105: LD_VAR 0 1
50109: PPUSH
50110: CALL_OW 310
50114: NOT
50115: OR
50116: IFFALSE 50120
// exit ;
50118: GO 50210
// vehicle := IsInUnit ( driver ) ;
50120: LD_ADDR_VAR 0 3
50124: PUSH
50125: LD_VAR 0 1
50129: PPUSH
50130: CALL_OW 310
50134: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
50135: LD_VAR 0 1
50139: PPUSH
50140: LD_STRING \
50142: PUSH
50143: LD_INT 0
50145: PUSH
50146: LD_INT 0
50148: PUSH
50149: LD_INT 0
50151: PUSH
50152: LD_INT 0
50154: PUSH
50155: LD_INT 0
50157: PUSH
50158: LD_INT 0
50160: PUSH
50161: EMPTY
50162: LIST
50163: LIST
50164: LIST
50165: LIST
50166: LIST
50167: LIST
50168: LIST
50169: PUSH
50170: LD_STRING E
50172: PUSH
50173: LD_INT 0
50175: PUSH
50176: LD_INT 0
50178: PUSH
50179: LD_VAR 0 3
50183: PUSH
50184: LD_INT 0
50186: PUSH
50187: LD_INT 0
50189: PUSH
50190: LD_INT 0
50192: PUSH
50193: EMPTY
50194: LIST
50195: LIST
50196: LIST
50197: LIST
50198: LIST
50199: LIST
50200: LIST
50201: PUSH
50202: EMPTY
50203: LIST
50204: LIST
50205: PPUSH
50206: CALL_OW 446
// end ;
50210: LD_VAR 0 2
50214: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
50215: LD_INT 0
50217: PPUSH
50218: PPUSH
// if not driver or not IsInUnit ( driver ) then
50219: LD_VAR 0 1
50223: NOT
50224: PUSH
50225: LD_VAR 0 1
50229: PPUSH
50230: CALL_OW 310
50234: NOT
50235: OR
50236: IFFALSE 50240
// exit ;
50238: GO 50330
// vehicle := IsInUnit ( driver ) ;
50240: LD_ADDR_VAR 0 3
50244: PUSH
50245: LD_VAR 0 1
50249: PPUSH
50250: CALL_OW 310
50254: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
50255: LD_VAR 0 1
50259: PPUSH
50260: LD_STRING \
50262: PUSH
50263: LD_INT 0
50265: PUSH
50266: LD_INT 0
50268: PUSH
50269: LD_INT 0
50271: PUSH
50272: LD_INT 0
50274: PUSH
50275: LD_INT 0
50277: PUSH
50278: LD_INT 0
50280: PUSH
50281: EMPTY
50282: LIST
50283: LIST
50284: LIST
50285: LIST
50286: LIST
50287: LIST
50288: LIST
50289: PUSH
50290: LD_STRING E
50292: PUSH
50293: LD_INT 0
50295: PUSH
50296: LD_INT 0
50298: PUSH
50299: LD_VAR 0 3
50303: PUSH
50304: LD_INT 0
50306: PUSH
50307: LD_INT 0
50309: PUSH
50310: LD_INT 0
50312: PUSH
50313: EMPTY
50314: LIST
50315: LIST
50316: LIST
50317: LIST
50318: LIST
50319: LIST
50320: LIST
50321: PUSH
50322: EMPTY
50323: LIST
50324: LIST
50325: PPUSH
50326: CALL_OW 447
// end ;
50330: LD_VAR 0 2
50334: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
50335: LD_INT 0
50337: PPUSH
50338: PPUSH
50339: PPUSH
// tmp := [ ] ;
50340: LD_ADDR_VAR 0 5
50344: PUSH
50345: EMPTY
50346: ST_TO_ADDR
// for i in units do
50347: LD_ADDR_VAR 0 4
50351: PUSH
50352: LD_VAR 0 1
50356: PUSH
50357: FOR_IN
50358: IFFALSE 50396
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
50360: LD_ADDR_VAR 0 5
50364: PUSH
50365: LD_VAR 0 5
50369: PPUSH
50370: LD_VAR 0 5
50374: PUSH
50375: LD_INT 1
50377: PLUS
50378: PPUSH
50379: LD_VAR 0 4
50383: PPUSH
50384: CALL_OW 256
50388: PPUSH
50389: CALL_OW 2
50393: ST_TO_ADDR
50394: GO 50357
50396: POP
50397: POP
// if not tmp then
50398: LD_VAR 0 5
50402: NOT
50403: IFFALSE 50407
// exit ;
50405: GO 50455
// if asc then
50407: LD_VAR 0 2
50411: IFFALSE 50435
// result := SortListByListAsc ( units , tmp ) else
50413: LD_ADDR_VAR 0 3
50417: PUSH
50418: LD_VAR 0 1
50422: PPUSH
50423: LD_VAR 0 5
50427: PPUSH
50428: CALL_OW 76
50432: ST_TO_ADDR
50433: GO 50455
// result := SortListByListDesc ( units , tmp ) ;
50435: LD_ADDR_VAR 0 3
50439: PUSH
50440: LD_VAR 0 1
50444: PPUSH
50445: LD_VAR 0 5
50449: PPUSH
50450: CALL_OW 77
50454: ST_TO_ADDR
// end ;
50455: LD_VAR 0 3
50459: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
50460: LD_INT 0
50462: PPUSH
50463: PPUSH
// task := GetTaskList ( mech ) ;
50464: LD_ADDR_VAR 0 4
50468: PUSH
50469: LD_VAR 0 1
50473: PPUSH
50474: CALL_OW 437
50478: ST_TO_ADDR
// if not task then
50479: LD_VAR 0 4
50483: NOT
50484: IFFALSE 50488
// exit ;
50486: GO 50530
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
50488: LD_ADDR_VAR 0 3
50492: PUSH
50493: LD_VAR 0 4
50497: PUSH
50498: LD_INT 1
50500: ARRAY
50501: PUSH
50502: LD_INT 1
50504: ARRAY
50505: PUSH
50506: LD_STRING r
50508: EQUAL
50509: PUSH
50510: LD_VAR 0 4
50514: PUSH
50515: LD_INT 1
50517: ARRAY
50518: PUSH
50519: LD_INT 4
50521: ARRAY
50522: PUSH
50523: LD_VAR 0 2
50527: EQUAL
50528: AND
50529: ST_TO_ADDR
// end ;
50530: LD_VAR 0 3
50534: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
50535: LD_INT 0
50537: PPUSH
// SetDir ( unit , d ) ;
50538: LD_VAR 0 1
50542: PPUSH
50543: LD_VAR 0 4
50547: PPUSH
50548: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
50552: LD_VAR 0 1
50556: PPUSH
50557: LD_VAR 0 2
50561: PPUSH
50562: LD_VAR 0 3
50566: PPUSH
50567: LD_VAR 0 5
50571: PPUSH
50572: CALL_OW 48
// end ;
50576: LD_VAR 0 6
50580: RET
// export function ToNaturalNumber ( number ) ; begin
50581: LD_INT 0
50583: PPUSH
// result := number div 1 ;
50584: LD_ADDR_VAR 0 2
50588: PUSH
50589: LD_VAR 0 1
50593: PUSH
50594: LD_INT 1
50596: DIV
50597: ST_TO_ADDR
// if number < 0 then
50598: LD_VAR 0 1
50602: PUSH
50603: LD_INT 0
50605: LESS
50606: IFFALSE 50616
// result := 0 ;
50608: LD_ADDR_VAR 0 2
50612: PUSH
50613: LD_INT 0
50615: ST_TO_ADDR
// end ;
50616: LD_VAR 0 2
50620: RET
// export function SortByClass ( units , class ) ; var un ; begin
50621: LD_INT 0
50623: PPUSH
50624: PPUSH
// if not units or not class then
50625: LD_VAR 0 1
50629: NOT
50630: PUSH
50631: LD_VAR 0 2
50635: NOT
50636: OR
50637: IFFALSE 50641
// exit ;
50639: GO 50736
// result := [ ] ;
50641: LD_ADDR_VAR 0 3
50645: PUSH
50646: EMPTY
50647: ST_TO_ADDR
// for un in units do
50648: LD_ADDR_VAR 0 4
50652: PUSH
50653: LD_VAR 0 1
50657: PUSH
50658: FOR_IN
50659: IFFALSE 50734
// if GetClass ( un ) = class then
50661: LD_VAR 0 4
50665: PPUSH
50666: CALL_OW 257
50670: PUSH
50671: LD_VAR 0 2
50675: EQUAL
50676: IFFALSE 50703
// result := Insert ( result , 1 , un ) else
50678: LD_ADDR_VAR 0 3
50682: PUSH
50683: LD_VAR 0 3
50687: PPUSH
50688: LD_INT 1
50690: PPUSH
50691: LD_VAR 0 4
50695: PPUSH
50696: CALL_OW 2
50700: ST_TO_ADDR
50701: GO 50732
// result := Replace ( result , result + 1 , un ) ;
50703: LD_ADDR_VAR 0 3
50707: PUSH
50708: LD_VAR 0 3
50712: PPUSH
50713: LD_VAR 0 3
50717: PUSH
50718: LD_INT 1
50720: PLUS
50721: PPUSH
50722: LD_VAR 0 4
50726: PPUSH
50727: CALL_OW 1
50731: ST_TO_ADDR
50732: GO 50658
50734: POP
50735: POP
// end ;
50736: LD_VAR 0 3
50740: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
50741: LD_INT 0
50743: PPUSH
50744: PPUSH
50745: PPUSH
50746: PPUSH
50747: PPUSH
50748: PPUSH
50749: PPUSH
// result := [ ] ;
50750: LD_ADDR_VAR 0 4
50754: PUSH
50755: EMPTY
50756: ST_TO_ADDR
// if x - r < 0 then
50757: LD_VAR 0 1
50761: PUSH
50762: LD_VAR 0 3
50766: MINUS
50767: PUSH
50768: LD_INT 0
50770: LESS
50771: IFFALSE 50783
// min_x := 0 else
50773: LD_ADDR_VAR 0 8
50777: PUSH
50778: LD_INT 0
50780: ST_TO_ADDR
50781: GO 50799
// min_x := x - r ;
50783: LD_ADDR_VAR 0 8
50787: PUSH
50788: LD_VAR 0 1
50792: PUSH
50793: LD_VAR 0 3
50797: MINUS
50798: ST_TO_ADDR
// if y - r < 0 then
50799: LD_VAR 0 2
50803: PUSH
50804: LD_VAR 0 3
50808: MINUS
50809: PUSH
50810: LD_INT 0
50812: LESS
50813: IFFALSE 50825
// min_y := 0 else
50815: LD_ADDR_VAR 0 7
50819: PUSH
50820: LD_INT 0
50822: ST_TO_ADDR
50823: GO 50841
// min_y := y - r ;
50825: LD_ADDR_VAR 0 7
50829: PUSH
50830: LD_VAR 0 2
50834: PUSH
50835: LD_VAR 0 3
50839: MINUS
50840: ST_TO_ADDR
// max_x := x + r ;
50841: LD_ADDR_VAR 0 9
50845: PUSH
50846: LD_VAR 0 1
50850: PUSH
50851: LD_VAR 0 3
50855: PLUS
50856: ST_TO_ADDR
// max_y := y + r ;
50857: LD_ADDR_VAR 0 10
50861: PUSH
50862: LD_VAR 0 2
50866: PUSH
50867: LD_VAR 0 3
50871: PLUS
50872: ST_TO_ADDR
// for _x = min_x to max_x do
50873: LD_ADDR_VAR 0 5
50877: PUSH
50878: DOUBLE
50879: LD_VAR 0 8
50883: DEC
50884: ST_TO_ADDR
50885: LD_VAR 0 9
50889: PUSH
50890: FOR_TO
50891: IFFALSE 50992
// for _y = min_y to max_y do
50893: LD_ADDR_VAR 0 6
50897: PUSH
50898: DOUBLE
50899: LD_VAR 0 7
50903: DEC
50904: ST_TO_ADDR
50905: LD_VAR 0 10
50909: PUSH
50910: FOR_TO
50911: IFFALSE 50988
// begin if not ValidHex ( _x , _y ) then
50913: LD_VAR 0 5
50917: PPUSH
50918: LD_VAR 0 6
50922: PPUSH
50923: CALL_OW 488
50927: NOT
50928: IFFALSE 50932
// continue ;
50930: GO 50910
// if GetResourceTypeXY ( _x , _y ) then
50932: LD_VAR 0 5
50936: PPUSH
50937: LD_VAR 0 6
50941: PPUSH
50942: CALL_OW 283
50946: IFFALSE 50986
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
50948: LD_ADDR_VAR 0 4
50952: PUSH
50953: LD_VAR 0 4
50957: PPUSH
50958: LD_VAR 0 4
50962: PUSH
50963: LD_INT 1
50965: PLUS
50966: PPUSH
50967: LD_VAR 0 5
50971: PUSH
50972: LD_VAR 0 6
50976: PUSH
50977: EMPTY
50978: LIST
50979: LIST
50980: PPUSH
50981: CALL_OW 1
50985: ST_TO_ADDR
// end ;
50986: GO 50910
50988: POP
50989: POP
50990: GO 50890
50992: POP
50993: POP
// end ;
50994: LD_VAR 0 4
50998: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
50999: LD_INT 0
51001: PPUSH
51002: PPUSH
51003: PPUSH
51004: PPUSH
51005: PPUSH
51006: PPUSH
51007: PPUSH
51008: PPUSH
// if not units then
51009: LD_VAR 0 1
51013: NOT
51014: IFFALSE 51018
// exit ;
51016: GO 51542
// result := UnitFilter ( units , [ f_ok ] ) ;
51018: LD_ADDR_VAR 0 3
51022: PUSH
51023: LD_VAR 0 1
51027: PPUSH
51028: LD_INT 50
51030: PUSH
51031: EMPTY
51032: LIST
51033: PPUSH
51034: CALL_OW 72
51038: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
51039: LD_ADDR_VAR 0 8
51043: PUSH
51044: LD_VAR 0 1
51048: PUSH
51049: LD_INT 1
51051: ARRAY
51052: PPUSH
51053: CALL_OW 255
51057: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
51058: LD_ADDR_VAR 0 10
51062: PUSH
51063: LD_INT 29
51065: PUSH
51066: LD_INT 91
51068: PUSH
51069: LD_INT 49
51071: PUSH
51072: EMPTY
51073: LIST
51074: LIST
51075: LIST
51076: ST_TO_ADDR
// if not result then
51077: LD_VAR 0 3
51081: NOT
51082: IFFALSE 51086
// exit ;
51084: GO 51542
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
51086: LD_ADDR_VAR 0 5
51090: PUSH
51091: LD_INT 81
51093: PUSH
51094: LD_VAR 0 8
51098: PUSH
51099: EMPTY
51100: LIST
51101: LIST
51102: PPUSH
51103: CALL_OW 69
51107: ST_TO_ADDR
// for i in result do
51108: LD_ADDR_VAR 0 4
51112: PUSH
51113: LD_VAR 0 3
51117: PUSH
51118: FOR_IN
51119: IFFALSE 51540
// begin tag := GetTag ( i ) + 1 ;
51121: LD_ADDR_VAR 0 9
51125: PUSH
51126: LD_VAR 0 4
51130: PPUSH
51131: CALL_OW 110
51135: PUSH
51136: LD_INT 1
51138: PLUS
51139: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
51140: LD_ADDR_VAR 0 7
51144: PUSH
51145: LD_VAR 0 4
51149: PPUSH
51150: CALL_OW 250
51154: PPUSH
51155: LD_VAR 0 4
51159: PPUSH
51160: CALL_OW 251
51164: PPUSH
51165: LD_INT 6
51167: PPUSH
51168: CALL 50741 0 3
51172: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
51173: LD_VAR 0 4
51177: PPUSH
51178: CALL_OW 247
51182: PUSH
51183: LD_INT 2
51185: EQUAL
51186: PUSH
51187: LD_VAR 0 7
51191: AND
51192: PUSH
51193: LD_VAR 0 4
51197: PPUSH
51198: CALL_OW 264
51202: PUSH
51203: LD_VAR 0 10
51207: IN
51208: NOT
51209: AND
51210: IFFALSE 51249
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
51212: LD_VAR 0 4
51216: PPUSH
51217: LD_VAR 0 7
51221: PUSH
51222: LD_INT 1
51224: ARRAY
51225: PUSH
51226: LD_INT 1
51228: ARRAY
51229: PPUSH
51230: LD_VAR 0 7
51234: PUSH
51235: LD_INT 1
51237: ARRAY
51238: PUSH
51239: LD_INT 2
51241: ARRAY
51242: PPUSH
51243: CALL_OW 116
51247: GO 51538
// if path > tag then
51249: LD_VAR 0 2
51253: PUSH
51254: LD_VAR 0 9
51258: GREATER
51259: IFFALSE 51467
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
51261: LD_ADDR_VAR 0 6
51265: PUSH
51266: LD_VAR 0 5
51270: PPUSH
51271: LD_INT 91
51273: PUSH
51274: LD_VAR 0 4
51278: PUSH
51279: LD_INT 8
51281: PUSH
51282: EMPTY
51283: LIST
51284: LIST
51285: LIST
51286: PPUSH
51287: CALL_OW 72
51291: ST_TO_ADDR
// if nearEnemy then
51292: LD_VAR 0 6
51296: IFFALSE 51365
// begin if GetWeapon ( i ) = ru_time_lapser then
51298: LD_VAR 0 4
51302: PPUSH
51303: CALL_OW 264
51307: PUSH
51308: LD_INT 49
51310: EQUAL
51311: IFFALSE 51339
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
51313: LD_VAR 0 4
51317: PPUSH
51318: LD_VAR 0 6
51322: PPUSH
51323: LD_VAR 0 4
51327: PPUSH
51328: CALL_OW 74
51332: PPUSH
51333: CALL_OW 112
51337: GO 51363
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
51339: LD_VAR 0 4
51343: PPUSH
51344: LD_VAR 0 6
51348: PPUSH
51349: LD_VAR 0 4
51353: PPUSH
51354: CALL_OW 74
51358: PPUSH
51359: CALL_OW 115
// end else
51363: GO 51465
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
51365: LD_VAR 0 4
51369: PPUSH
51370: LD_VAR 0 2
51374: PUSH
51375: LD_VAR 0 9
51379: ARRAY
51380: PUSH
51381: LD_INT 1
51383: ARRAY
51384: PPUSH
51385: LD_VAR 0 2
51389: PUSH
51390: LD_VAR 0 9
51394: ARRAY
51395: PUSH
51396: LD_INT 2
51398: ARRAY
51399: PPUSH
51400: CALL_OW 297
51404: PUSH
51405: LD_INT 6
51407: GREATER
51408: IFFALSE 51451
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
51410: LD_VAR 0 4
51414: PPUSH
51415: LD_VAR 0 2
51419: PUSH
51420: LD_VAR 0 9
51424: ARRAY
51425: PUSH
51426: LD_INT 1
51428: ARRAY
51429: PPUSH
51430: LD_VAR 0 2
51434: PUSH
51435: LD_VAR 0 9
51439: ARRAY
51440: PUSH
51441: LD_INT 2
51443: ARRAY
51444: PPUSH
51445: CALL_OW 114
51449: GO 51465
// SetTag ( i , tag ) ;
51451: LD_VAR 0 4
51455: PPUSH
51456: LD_VAR 0 9
51460: PPUSH
51461: CALL_OW 109
// end else
51465: GO 51538
// if enemy then
51467: LD_VAR 0 5
51471: IFFALSE 51538
// begin if GetWeapon ( i ) = ru_time_lapser then
51473: LD_VAR 0 4
51477: PPUSH
51478: CALL_OW 264
51482: PUSH
51483: LD_INT 49
51485: EQUAL
51486: IFFALSE 51514
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
51488: LD_VAR 0 4
51492: PPUSH
51493: LD_VAR 0 5
51497: PPUSH
51498: LD_VAR 0 4
51502: PPUSH
51503: CALL_OW 74
51507: PPUSH
51508: CALL_OW 112
51512: GO 51538
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
51514: LD_VAR 0 4
51518: PPUSH
51519: LD_VAR 0 5
51523: PPUSH
51524: LD_VAR 0 4
51528: PPUSH
51529: CALL_OW 74
51533: PPUSH
51534: CALL_OW 115
// end ; end ;
51538: GO 51118
51540: POP
51541: POP
// end ;
51542: LD_VAR 0 3
51546: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
51547: LD_INT 0
51549: PPUSH
51550: PPUSH
51551: PPUSH
// if not unit or IsInUnit ( unit ) then
51552: LD_VAR 0 1
51556: NOT
51557: PUSH
51558: LD_VAR 0 1
51562: PPUSH
51563: CALL_OW 310
51567: OR
51568: IFFALSE 51572
// exit ;
51570: GO 51663
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
51572: LD_ADDR_VAR 0 4
51576: PUSH
51577: LD_VAR 0 1
51581: PPUSH
51582: CALL_OW 250
51586: PPUSH
51587: LD_VAR 0 2
51591: PPUSH
51592: LD_INT 1
51594: PPUSH
51595: CALL_OW 272
51599: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
51600: LD_ADDR_VAR 0 5
51604: PUSH
51605: LD_VAR 0 1
51609: PPUSH
51610: CALL_OW 251
51614: PPUSH
51615: LD_VAR 0 2
51619: PPUSH
51620: LD_INT 1
51622: PPUSH
51623: CALL_OW 273
51627: ST_TO_ADDR
// if ValidHex ( x , y ) then
51628: LD_VAR 0 4
51632: PPUSH
51633: LD_VAR 0 5
51637: PPUSH
51638: CALL_OW 488
51642: IFFALSE 51663
// ComTurnXY ( unit , x , y ) ;
51644: LD_VAR 0 1
51648: PPUSH
51649: LD_VAR 0 4
51653: PPUSH
51654: LD_VAR 0 5
51658: PPUSH
51659: CALL_OW 118
// end ;
51663: LD_VAR 0 3
51667: RET
// export function SeeUnits ( side , units ) ; var i ; begin
51668: LD_INT 0
51670: PPUSH
51671: PPUSH
// result := false ;
51672: LD_ADDR_VAR 0 3
51676: PUSH
51677: LD_INT 0
51679: ST_TO_ADDR
// if not units then
51680: LD_VAR 0 2
51684: NOT
51685: IFFALSE 51689
// exit ;
51687: GO 51734
// for i in units do
51689: LD_ADDR_VAR 0 4
51693: PUSH
51694: LD_VAR 0 2
51698: PUSH
51699: FOR_IN
51700: IFFALSE 51732
// if See ( side , i ) then
51702: LD_VAR 0 1
51706: PPUSH
51707: LD_VAR 0 4
51711: PPUSH
51712: CALL_OW 292
51716: IFFALSE 51730
// begin result := true ;
51718: LD_ADDR_VAR 0 3
51722: PUSH
51723: LD_INT 1
51725: ST_TO_ADDR
// exit ;
51726: POP
51727: POP
51728: GO 51734
// end ;
51730: GO 51699
51732: POP
51733: POP
// end ;
51734: LD_VAR 0 3
51738: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
51739: LD_INT 0
51741: PPUSH
51742: PPUSH
51743: PPUSH
51744: PPUSH
// if not unit or not points then
51745: LD_VAR 0 1
51749: NOT
51750: PUSH
51751: LD_VAR 0 2
51755: NOT
51756: OR
51757: IFFALSE 51761
// exit ;
51759: GO 51851
// dist := 99999 ;
51761: LD_ADDR_VAR 0 5
51765: PUSH
51766: LD_INT 99999
51768: ST_TO_ADDR
// for i in points do
51769: LD_ADDR_VAR 0 4
51773: PUSH
51774: LD_VAR 0 2
51778: PUSH
51779: FOR_IN
51780: IFFALSE 51849
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
51782: LD_ADDR_VAR 0 6
51786: PUSH
51787: LD_VAR 0 1
51791: PPUSH
51792: LD_VAR 0 4
51796: PUSH
51797: LD_INT 1
51799: ARRAY
51800: PPUSH
51801: LD_VAR 0 4
51805: PUSH
51806: LD_INT 2
51808: ARRAY
51809: PPUSH
51810: CALL_OW 297
51814: ST_TO_ADDR
// if tmpDist < dist then
51815: LD_VAR 0 6
51819: PUSH
51820: LD_VAR 0 5
51824: LESS
51825: IFFALSE 51847
// begin result := i ;
51827: LD_ADDR_VAR 0 3
51831: PUSH
51832: LD_VAR 0 4
51836: ST_TO_ADDR
// dist := tmpDist ;
51837: LD_ADDR_VAR 0 5
51841: PUSH
51842: LD_VAR 0 6
51846: ST_TO_ADDR
// end ; end ;
51847: GO 51779
51849: POP
51850: POP
// end ;
51851: LD_VAR 0 3
51855: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
51856: LD_INT 0
51858: PPUSH
// uc_side := side ;
51859: LD_ADDR_OWVAR 20
51863: PUSH
51864: LD_VAR 0 1
51868: ST_TO_ADDR
// uc_nation := 3 ;
51869: LD_ADDR_OWVAR 21
51873: PUSH
51874: LD_INT 3
51876: ST_TO_ADDR
// vc_chassis := 25 ;
51877: LD_ADDR_OWVAR 37
51881: PUSH
51882: LD_INT 25
51884: ST_TO_ADDR
// vc_engine := engine_siberite ;
51885: LD_ADDR_OWVAR 39
51889: PUSH
51890: LD_INT 3
51892: ST_TO_ADDR
// vc_control := control_computer ;
51893: LD_ADDR_OWVAR 38
51897: PUSH
51898: LD_INT 3
51900: ST_TO_ADDR
// vc_weapon := 59 ;
51901: LD_ADDR_OWVAR 40
51905: PUSH
51906: LD_INT 59
51908: ST_TO_ADDR
// result := CreateVehicle ;
51909: LD_ADDR_VAR 0 5
51913: PUSH
51914: CALL_OW 45
51918: ST_TO_ADDR
// SetDir ( result , d ) ;
51919: LD_VAR 0 5
51923: PPUSH
51924: LD_VAR 0 4
51928: PPUSH
51929: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
51933: LD_VAR 0 5
51937: PPUSH
51938: LD_VAR 0 2
51942: PPUSH
51943: LD_VAR 0 3
51947: PPUSH
51948: LD_INT 0
51950: PPUSH
51951: CALL_OW 48
// end ;
51955: LD_VAR 0 5
51959: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
51960: LD_INT 0
51962: PPUSH
51963: PPUSH
51964: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
51965: LD_ADDR_VAR 0 2
51969: PUSH
51970: LD_INT 0
51972: PUSH
51973: LD_INT 0
51975: PUSH
51976: LD_INT 0
51978: PUSH
51979: LD_INT 0
51981: PUSH
51982: EMPTY
51983: LIST
51984: LIST
51985: LIST
51986: LIST
51987: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
51988: LD_VAR 0 1
51992: NOT
51993: PUSH
51994: LD_VAR 0 1
51998: PPUSH
51999: CALL_OW 264
52003: PUSH
52004: LD_INT 12
52006: PUSH
52007: LD_INT 51
52009: PUSH
52010: LD_INT 32
52012: PUSH
52013: LD_INT 89
52015: PUSH
52016: EMPTY
52017: LIST
52018: LIST
52019: LIST
52020: LIST
52021: IN
52022: NOT
52023: OR
52024: IFFALSE 52028
// exit ;
52026: GO 52126
// for i := 1 to 3 do
52028: LD_ADDR_VAR 0 3
52032: PUSH
52033: DOUBLE
52034: LD_INT 1
52036: DEC
52037: ST_TO_ADDR
52038: LD_INT 3
52040: PUSH
52041: FOR_TO
52042: IFFALSE 52124
// begin tmp := GetCargo ( cargo , i ) ;
52044: LD_ADDR_VAR 0 4
52048: PUSH
52049: LD_VAR 0 1
52053: PPUSH
52054: LD_VAR 0 3
52058: PPUSH
52059: CALL_OW 289
52063: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
52064: LD_ADDR_VAR 0 2
52068: PUSH
52069: LD_VAR 0 2
52073: PPUSH
52074: LD_VAR 0 3
52078: PPUSH
52079: LD_VAR 0 4
52083: PPUSH
52084: CALL_OW 1
52088: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
52089: LD_ADDR_VAR 0 2
52093: PUSH
52094: LD_VAR 0 2
52098: PPUSH
52099: LD_INT 4
52101: PPUSH
52102: LD_VAR 0 2
52106: PUSH
52107: LD_INT 4
52109: ARRAY
52110: PUSH
52111: LD_VAR 0 4
52115: PLUS
52116: PPUSH
52117: CALL_OW 1
52121: ST_TO_ADDR
// end ;
52122: GO 52041
52124: POP
52125: POP
// end ;
52126: LD_VAR 0 2
52130: RET
// export function Length ( array ) ; begin
52131: LD_INT 0
52133: PPUSH
// result := array + 0 ;
52134: LD_ADDR_VAR 0 2
52138: PUSH
52139: LD_VAR 0 1
52143: PUSH
52144: LD_INT 0
52146: PLUS
52147: ST_TO_ADDR
// end ;
52148: LD_VAR 0 2
52152: RET
// export function PrepareArray ( array ) ; begin
52153: LD_INT 0
52155: PPUSH
// result := array diff 0 ;
52156: LD_ADDR_VAR 0 2
52160: PUSH
52161: LD_VAR 0 1
52165: PUSH
52166: LD_INT 0
52168: DIFF
52169: ST_TO_ADDR
// if not result [ 1 ] then
52170: LD_VAR 0 2
52174: PUSH
52175: LD_INT 1
52177: ARRAY
52178: NOT
52179: IFFALSE 52199
// result := Delete ( result , 1 ) ;
52181: LD_ADDR_VAR 0 2
52185: PUSH
52186: LD_VAR 0 2
52190: PPUSH
52191: LD_INT 1
52193: PPUSH
52194: CALL_OW 3
52198: ST_TO_ADDR
// end ; end_of_file
52199: LD_VAR 0 2
52203: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
52204: LD_INT 0
52206: PPUSH
52207: PPUSH
// skirmish := false ;
52208: LD_ADDR_EXP 21
52212: PUSH
52213: LD_INT 0
52215: ST_TO_ADDR
// debug_mc := false ;
52216: LD_ADDR_EXP 22
52220: PUSH
52221: LD_INT 0
52223: ST_TO_ADDR
// mc_bases := [ ] ;
52224: LD_ADDR_EXP 23
52228: PUSH
52229: EMPTY
52230: ST_TO_ADDR
// mc_sides := [ ] ;
52231: LD_ADDR_EXP 49
52235: PUSH
52236: EMPTY
52237: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
52238: LD_ADDR_EXP 24
52242: PUSH
52243: EMPTY
52244: ST_TO_ADDR
// mc_building_repairs := [ ] ;
52245: LD_ADDR_EXP 25
52249: PUSH
52250: EMPTY
52251: ST_TO_ADDR
// mc_need_heal := [ ] ;
52252: LD_ADDR_EXP 26
52256: PUSH
52257: EMPTY
52258: ST_TO_ADDR
// mc_healers := [ ] ;
52259: LD_ADDR_EXP 27
52263: PUSH
52264: EMPTY
52265: ST_TO_ADDR
// mc_build_list := [ ] ;
52266: LD_ADDR_EXP 28
52270: PUSH
52271: EMPTY
52272: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
52273: LD_ADDR_EXP 55
52277: PUSH
52278: EMPTY
52279: ST_TO_ADDR
// mc_builders := [ ] ;
52280: LD_ADDR_EXP 29
52284: PUSH
52285: EMPTY
52286: ST_TO_ADDR
// mc_construct_list := [ ] ;
52287: LD_ADDR_EXP 30
52291: PUSH
52292: EMPTY
52293: ST_TO_ADDR
// mc_turret_list := [ ] ;
52294: LD_ADDR_EXP 31
52298: PUSH
52299: EMPTY
52300: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
52301: LD_ADDR_EXP 32
52305: PUSH
52306: EMPTY
52307: ST_TO_ADDR
// mc_miners := [ ] ;
52308: LD_ADDR_EXP 37
52312: PUSH
52313: EMPTY
52314: ST_TO_ADDR
// mc_mines := [ ] ;
52315: LD_ADDR_EXP 36
52319: PUSH
52320: EMPTY
52321: ST_TO_ADDR
// mc_minefields := [ ] ;
52322: LD_ADDR_EXP 38
52326: PUSH
52327: EMPTY
52328: ST_TO_ADDR
// mc_crates := [ ] ;
52329: LD_ADDR_EXP 39
52333: PUSH
52334: EMPTY
52335: ST_TO_ADDR
// mc_crates_collector := [ ] ;
52336: LD_ADDR_EXP 40
52340: PUSH
52341: EMPTY
52342: ST_TO_ADDR
// mc_crates_area := [ ] ;
52343: LD_ADDR_EXP 41
52347: PUSH
52348: EMPTY
52349: ST_TO_ADDR
// mc_vehicles := [ ] ;
52350: LD_ADDR_EXP 42
52354: PUSH
52355: EMPTY
52356: ST_TO_ADDR
// mc_attack := [ ] ;
52357: LD_ADDR_EXP 43
52361: PUSH
52362: EMPTY
52363: ST_TO_ADDR
// mc_produce := [ ] ;
52364: LD_ADDR_EXP 44
52368: PUSH
52369: EMPTY
52370: ST_TO_ADDR
// mc_defender := [ ] ;
52371: LD_ADDR_EXP 45
52375: PUSH
52376: EMPTY
52377: ST_TO_ADDR
// mc_parking := [ ] ;
52378: LD_ADDR_EXP 47
52382: PUSH
52383: EMPTY
52384: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
52385: LD_ADDR_EXP 33
52389: PUSH
52390: EMPTY
52391: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
52392: LD_ADDR_EXP 35
52396: PUSH
52397: EMPTY
52398: ST_TO_ADDR
// mc_scan := [ ] ;
52399: LD_ADDR_EXP 46
52403: PUSH
52404: EMPTY
52405: ST_TO_ADDR
// mc_scan_area := [ ] ;
52406: LD_ADDR_EXP 48
52410: PUSH
52411: EMPTY
52412: ST_TO_ADDR
// mc_tech := [ ] ;
52413: LD_ADDR_EXP 50
52417: PUSH
52418: EMPTY
52419: ST_TO_ADDR
// mc_class := [ ] ;
52420: LD_ADDR_EXP 64
52424: PUSH
52425: EMPTY
52426: ST_TO_ADDR
// mc_class_case_use := [ ] ;
52427: LD_ADDR_EXP 65
52431: PUSH
52432: EMPTY
52433: ST_TO_ADDR
// mc_is_defending := [ ] ;
52434: LD_ADDR_EXP 66
52438: PUSH
52439: EMPTY
52440: ST_TO_ADDR
// end ;
52441: LD_VAR 0 1
52445: RET
// export function MC_Kill ( base ) ; begin
52446: LD_INT 0
52448: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
52449: LD_ADDR_EXP 23
52453: PUSH
52454: LD_EXP 23
52458: PPUSH
52459: LD_VAR 0 1
52463: PPUSH
52464: EMPTY
52465: PPUSH
52466: CALL_OW 1
52470: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
52471: LD_ADDR_EXP 24
52475: PUSH
52476: LD_EXP 24
52480: PPUSH
52481: LD_VAR 0 1
52485: PPUSH
52486: EMPTY
52487: PPUSH
52488: CALL_OW 1
52492: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
52493: LD_ADDR_EXP 25
52497: PUSH
52498: LD_EXP 25
52502: PPUSH
52503: LD_VAR 0 1
52507: PPUSH
52508: EMPTY
52509: PPUSH
52510: CALL_OW 1
52514: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
52515: LD_ADDR_EXP 26
52519: PUSH
52520: LD_EXP 26
52524: PPUSH
52525: LD_VAR 0 1
52529: PPUSH
52530: EMPTY
52531: PPUSH
52532: CALL_OW 1
52536: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
52537: LD_ADDR_EXP 27
52541: PUSH
52542: LD_EXP 27
52546: PPUSH
52547: LD_VAR 0 1
52551: PPUSH
52552: EMPTY
52553: PPUSH
52554: CALL_OW 1
52558: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
52559: LD_ADDR_EXP 28
52563: PUSH
52564: LD_EXP 28
52568: PPUSH
52569: LD_VAR 0 1
52573: PPUSH
52574: EMPTY
52575: PPUSH
52576: CALL_OW 1
52580: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
52581: LD_ADDR_EXP 29
52585: PUSH
52586: LD_EXP 29
52590: PPUSH
52591: LD_VAR 0 1
52595: PPUSH
52596: EMPTY
52597: PPUSH
52598: CALL_OW 1
52602: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
52603: LD_ADDR_EXP 30
52607: PUSH
52608: LD_EXP 30
52612: PPUSH
52613: LD_VAR 0 1
52617: PPUSH
52618: EMPTY
52619: PPUSH
52620: CALL_OW 1
52624: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
52625: LD_ADDR_EXP 31
52629: PUSH
52630: LD_EXP 31
52634: PPUSH
52635: LD_VAR 0 1
52639: PPUSH
52640: EMPTY
52641: PPUSH
52642: CALL_OW 1
52646: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
52647: LD_ADDR_EXP 32
52651: PUSH
52652: LD_EXP 32
52656: PPUSH
52657: LD_VAR 0 1
52661: PPUSH
52662: EMPTY
52663: PPUSH
52664: CALL_OW 1
52668: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
52669: LD_ADDR_EXP 33
52673: PUSH
52674: LD_EXP 33
52678: PPUSH
52679: LD_VAR 0 1
52683: PPUSH
52684: EMPTY
52685: PPUSH
52686: CALL_OW 1
52690: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
52691: LD_ADDR_EXP 34
52695: PUSH
52696: LD_EXP 34
52700: PPUSH
52701: LD_VAR 0 1
52705: PPUSH
52706: LD_INT 0
52708: PPUSH
52709: CALL_OW 1
52713: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
52714: LD_ADDR_EXP 35
52718: PUSH
52719: LD_EXP 35
52723: PPUSH
52724: LD_VAR 0 1
52728: PPUSH
52729: EMPTY
52730: PPUSH
52731: CALL_OW 1
52735: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
52736: LD_ADDR_EXP 36
52740: PUSH
52741: LD_EXP 36
52745: PPUSH
52746: LD_VAR 0 1
52750: PPUSH
52751: EMPTY
52752: PPUSH
52753: CALL_OW 1
52757: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
52758: LD_ADDR_EXP 37
52762: PUSH
52763: LD_EXP 37
52767: PPUSH
52768: LD_VAR 0 1
52772: PPUSH
52773: EMPTY
52774: PPUSH
52775: CALL_OW 1
52779: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
52780: LD_ADDR_EXP 38
52784: PUSH
52785: LD_EXP 38
52789: PPUSH
52790: LD_VAR 0 1
52794: PPUSH
52795: EMPTY
52796: PPUSH
52797: CALL_OW 1
52801: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
52802: LD_ADDR_EXP 39
52806: PUSH
52807: LD_EXP 39
52811: PPUSH
52812: LD_VAR 0 1
52816: PPUSH
52817: EMPTY
52818: PPUSH
52819: CALL_OW 1
52823: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
52824: LD_ADDR_EXP 40
52828: PUSH
52829: LD_EXP 40
52833: PPUSH
52834: LD_VAR 0 1
52838: PPUSH
52839: EMPTY
52840: PPUSH
52841: CALL_OW 1
52845: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
52846: LD_ADDR_EXP 41
52850: PUSH
52851: LD_EXP 41
52855: PPUSH
52856: LD_VAR 0 1
52860: PPUSH
52861: EMPTY
52862: PPUSH
52863: CALL_OW 1
52867: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
52868: LD_ADDR_EXP 42
52872: PUSH
52873: LD_EXP 42
52877: PPUSH
52878: LD_VAR 0 1
52882: PPUSH
52883: EMPTY
52884: PPUSH
52885: CALL_OW 1
52889: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
52890: LD_ADDR_EXP 43
52894: PUSH
52895: LD_EXP 43
52899: PPUSH
52900: LD_VAR 0 1
52904: PPUSH
52905: EMPTY
52906: PPUSH
52907: CALL_OW 1
52911: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
52912: LD_ADDR_EXP 44
52916: PUSH
52917: LD_EXP 44
52921: PPUSH
52922: LD_VAR 0 1
52926: PPUSH
52927: EMPTY
52928: PPUSH
52929: CALL_OW 1
52933: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
52934: LD_ADDR_EXP 45
52938: PUSH
52939: LD_EXP 45
52943: PPUSH
52944: LD_VAR 0 1
52948: PPUSH
52949: EMPTY
52950: PPUSH
52951: CALL_OW 1
52955: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
52956: LD_ADDR_EXP 46
52960: PUSH
52961: LD_EXP 46
52965: PPUSH
52966: LD_VAR 0 1
52970: PPUSH
52971: EMPTY
52972: PPUSH
52973: CALL_OW 1
52977: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
52978: LD_ADDR_EXP 47
52982: PUSH
52983: LD_EXP 47
52987: PPUSH
52988: LD_VAR 0 1
52992: PPUSH
52993: EMPTY
52994: PPUSH
52995: CALL_OW 1
52999: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
53000: LD_ADDR_EXP 48
53004: PUSH
53005: LD_EXP 48
53009: PPUSH
53010: LD_VAR 0 1
53014: PPUSH
53015: EMPTY
53016: PPUSH
53017: CALL_OW 1
53021: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
53022: LD_ADDR_EXP 50
53026: PUSH
53027: LD_EXP 50
53031: PPUSH
53032: LD_VAR 0 1
53036: PPUSH
53037: EMPTY
53038: PPUSH
53039: CALL_OW 1
53043: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
53044: LD_ADDR_EXP 52
53048: PUSH
53049: LD_EXP 52
53053: PPUSH
53054: LD_VAR 0 1
53058: PPUSH
53059: EMPTY
53060: PPUSH
53061: CALL_OW 1
53065: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
53066: LD_ADDR_EXP 53
53070: PUSH
53071: LD_EXP 53
53075: PPUSH
53076: LD_VAR 0 1
53080: PPUSH
53081: EMPTY
53082: PPUSH
53083: CALL_OW 1
53087: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
53088: LD_ADDR_EXP 54
53092: PUSH
53093: LD_EXP 54
53097: PPUSH
53098: LD_VAR 0 1
53102: PPUSH
53103: EMPTY
53104: PPUSH
53105: CALL_OW 1
53109: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
53110: LD_ADDR_EXP 55
53114: PUSH
53115: LD_EXP 55
53119: PPUSH
53120: LD_VAR 0 1
53124: PPUSH
53125: EMPTY
53126: PPUSH
53127: CALL_OW 1
53131: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
53132: LD_ADDR_EXP 56
53136: PUSH
53137: LD_EXP 56
53141: PPUSH
53142: LD_VAR 0 1
53146: PPUSH
53147: EMPTY
53148: PPUSH
53149: CALL_OW 1
53153: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
53154: LD_ADDR_EXP 57
53158: PUSH
53159: LD_EXP 57
53163: PPUSH
53164: LD_VAR 0 1
53168: PPUSH
53169: EMPTY
53170: PPUSH
53171: CALL_OW 1
53175: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
53176: LD_ADDR_EXP 58
53180: PUSH
53181: LD_EXP 58
53185: PPUSH
53186: LD_VAR 0 1
53190: PPUSH
53191: EMPTY
53192: PPUSH
53193: CALL_OW 1
53197: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
53198: LD_ADDR_EXP 59
53202: PUSH
53203: LD_EXP 59
53207: PPUSH
53208: LD_VAR 0 1
53212: PPUSH
53213: EMPTY
53214: PPUSH
53215: CALL_OW 1
53219: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
53220: LD_ADDR_EXP 60
53224: PUSH
53225: LD_EXP 60
53229: PPUSH
53230: LD_VAR 0 1
53234: PPUSH
53235: EMPTY
53236: PPUSH
53237: CALL_OW 1
53241: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
53242: LD_ADDR_EXP 61
53246: PUSH
53247: LD_EXP 61
53251: PPUSH
53252: LD_VAR 0 1
53256: PPUSH
53257: EMPTY
53258: PPUSH
53259: CALL_OW 1
53263: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
53264: LD_ADDR_EXP 62
53268: PUSH
53269: LD_EXP 62
53273: PPUSH
53274: LD_VAR 0 1
53278: PPUSH
53279: EMPTY
53280: PPUSH
53281: CALL_OW 1
53285: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
53286: LD_ADDR_EXP 63
53290: PUSH
53291: LD_EXP 63
53295: PPUSH
53296: LD_VAR 0 1
53300: PPUSH
53301: EMPTY
53302: PPUSH
53303: CALL_OW 1
53307: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
53308: LD_ADDR_EXP 64
53312: PUSH
53313: LD_EXP 64
53317: PPUSH
53318: LD_VAR 0 1
53322: PPUSH
53323: EMPTY
53324: PPUSH
53325: CALL_OW 1
53329: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
53330: LD_ADDR_EXP 65
53334: PUSH
53335: LD_EXP 65
53339: PPUSH
53340: LD_VAR 0 1
53344: PPUSH
53345: LD_INT 0
53347: PPUSH
53348: CALL_OW 1
53352: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
53353: LD_ADDR_EXP 66
53357: PUSH
53358: LD_EXP 66
53362: PPUSH
53363: LD_VAR 0 1
53367: PPUSH
53368: LD_INT 0
53370: PPUSH
53371: CALL_OW 1
53375: ST_TO_ADDR
// end ;
53376: LD_VAR 0 2
53380: RET
// export function MC_Add ( side , units ) ; var base ; begin
53381: LD_INT 0
53383: PPUSH
53384: PPUSH
// base := mc_bases + 1 ;
53385: LD_ADDR_VAR 0 4
53389: PUSH
53390: LD_EXP 23
53394: PUSH
53395: LD_INT 1
53397: PLUS
53398: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
53399: LD_ADDR_EXP 49
53403: PUSH
53404: LD_EXP 49
53408: PPUSH
53409: LD_VAR 0 4
53413: PPUSH
53414: LD_VAR 0 1
53418: PPUSH
53419: CALL_OW 1
53423: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
53424: LD_ADDR_EXP 23
53428: PUSH
53429: LD_EXP 23
53433: PPUSH
53434: LD_VAR 0 4
53438: PPUSH
53439: LD_VAR 0 2
53443: PPUSH
53444: CALL_OW 1
53448: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
53449: LD_ADDR_EXP 24
53453: PUSH
53454: LD_EXP 24
53458: PPUSH
53459: LD_VAR 0 4
53463: PPUSH
53464: EMPTY
53465: PPUSH
53466: CALL_OW 1
53470: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
53471: LD_ADDR_EXP 25
53475: PUSH
53476: LD_EXP 25
53480: PPUSH
53481: LD_VAR 0 4
53485: PPUSH
53486: EMPTY
53487: PPUSH
53488: CALL_OW 1
53492: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
53493: LD_ADDR_EXP 26
53497: PUSH
53498: LD_EXP 26
53502: PPUSH
53503: LD_VAR 0 4
53507: PPUSH
53508: EMPTY
53509: PPUSH
53510: CALL_OW 1
53514: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
53515: LD_ADDR_EXP 27
53519: PUSH
53520: LD_EXP 27
53524: PPUSH
53525: LD_VAR 0 4
53529: PPUSH
53530: EMPTY
53531: PPUSH
53532: CALL_OW 1
53536: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
53537: LD_ADDR_EXP 28
53541: PUSH
53542: LD_EXP 28
53546: PPUSH
53547: LD_VAR 0 4
53551: PPUSH
53552: EMPTY
53553: PPUSH
53554: CALL_OW 1
53558: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
53559: LD_ADDR_EXP 29
53563: PUSH
53564: LD_EXP 29
53568: PPUSH
53569: LD_VAR 0 4
53573: PPUSH
53574: EMPTY
53575: PPUSH
53576: CALL_OW 1
53580: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
53581: LD_ADDR_EXP 30
53585: PUSH
53586: LD_EXP 30
53590: PPUSH
53591: LD_VAR 0 4
53595: PPUSH
53596: EMPTY
53597: PPUSH
53598: CALL_OW 1
53602: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
53603: LD_ADDR_EXP 31
53607: PUSH
53608: LD_EXP 31
53612: PPUSH
53613: LD_VAR 0 4
53617: PPUSH
53618: EMPTY
53619: PPUSH
53620: CALL_OW 1
53624: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
53625: LD_ADDR_EXP 32
53629: PUSH
53630: LD_EXP 32
53634: PPUSH
53635: LD_VAR 0 4
53639: PPUSH
53640: EMPTY
53641: PPUSH
53642: CALL_OW 1
53646: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
53647: LD_ADDR_EXP 33
53651: PUSH
53652: LD_EXP 33
53656: PPUSH
53657: LD_VAR 0 4
53661: PPUSH
53662: EMPTY
53663: PPUSH
53664: CALL_OW 1
53668: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
53669: LD_ADDR_EXP 34
53673: PUSH
53674: LD_EXP 34
53678: PPUSH
53679: LD_VAR 0 4
53683: PPUSH
53684: LD_INT 0
53686: PPUSH
53687: CALL_OW 1
53691: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
53692: LD_ADDR_EXP 35
53696: PUSH
53697: LD_EXP 35
53701: PPUSH
53702: LD_VAR 0 4
53706: PPUSH
53707: EMPTY
53708: PPUSH
53709: CALL_OW 1
53713: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
53714: LD_ADDR_EXP 36
53718: PUSH
53719: LD_EXP 36
53723: PPUSH
53724: LD_VAR 0 4
53728: PPUSH
53729: EMPTY
53730: PPUSH
53731: CALL_OW 1
53735: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
53736: LD_ADDR_EXP 37
53740: PUSH
53741: LD_EXP 37
53745: PPUSH
53746: LD_VAR 0 4
53750: PPUSH
53751: EMPTY
53752: PPUSH
53753: CALL_OW 1
53757: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
53758: LD_ADDR_EXP 38
53762: PUSH
53763: LD_EXP 38
53767: PPUSH
53768: LD_VAR 0 4
53772: PPUSH
53773: EMPTY
53774: PPUSH
53775: CALL_OW 1
53779: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
53780: LD_ADDR_EXP 39
53784: PUSH
53785: LD_EXP 39
53789: PPUSH
53790: LD_VAR 0 4
53794: PPUSH
53795: EMPTY
53796: PPUSH
53797: CALL_OW 1
53801: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
53802: LD_ADDR_EXP 40
53806: PUSH
53807: LD_EXP 40
53811: PPUSH
53812: LD_VAR 0 4
53816: PPUSH
53817: EMPTY
53818: PPUSH
53819: CALL_OW 1
53823: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
53824: LD_ADDR_EXP 41
53828: PUSH
53829: LD_EXP 41
53833: PPUSH
53834: LD_VAR 0 4
53838: PPUSH
53839: EMPTY
53840: PPUSH
53841: CALL_OW 1
53845: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
53846: LD_ADDR_EXP 42
53850: PUSH
53851: LD_EXP 42
53855: PPUSH
53856: LD_VAR 0 4
53860: PPUSH
53861: EMPTY
53862: PPUSH
53863: CALL_OW 1
53867: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
53868: LD_ADDR_EXP 43
53872: PUSH
53873: LD_EXP 43
53877: PPUSH
53878: LD_VAR 0 4
53882: PPUSH
53883: EMPTY
53884: PPUSH
53885: CALL_OW 1
53889: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
53890: LD_ADDR_EXP 44
53894: PUSH
53895: LD_EXP 44
53899: PPUSH
53900: LD_VAR 0 4
53904: PPUSH
53905: EMPTY
53906: PPUSH
53907: CALL_OW 1
53911: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
53912: LD_ADDR_EXP 45
53916: PUSH
53917: LD_EXP 45
53921: PPUSH
53922: LD_VAR 0 4
53926: PPUSH
53927: EMPTY
53928: PPUSH
53929: CALL_OW 1
53933: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
53934: LD_ADDR_EXP 46
53938: PUSH
53939: LD_EXP 46
53943: PPUSH
53944: LD_VAR 0 4
53948: PPUSH
53949: EMPTY
53950: PPUSH
53951: CALL_OW 1
53955: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
53956: LD_ADDR_EXP 47
53960: PUSH
53961: LD_EXP 47
53965: PPUSH
53966: LD_VAR 0 4
53970: PPUSH
53971: EMPTY
53972: PPUSH
53973: CALL_OW 1
53977: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
53978: LD_ADDR_EXP 48
53982: PUSH
53983: LD_EXP 48
53987: PPUSH
53988: LD_VAR 0 4
53992: PPUSH
53993: EMPTY
53994: PPUSH
53995: CALL_OW 1
53999: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
54000: LD_ADDR_EXP 50
54004: PUSH
54005: LD_EXP 50
54009: PPUSH
54010: LD_VAR 0 4
54014: PPUSH
54015: EMPTY
54016: PPUSH
54017: CALL_OW 1
54021: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
54022: LD_ADDR_EXP 52
54026: PUSH
54027: LD_EXP 52
54031: PPUSH
54032: LD_VAR 0 4
54036: PPUSH
54037: EMPTY
54038: PPUSH
54039: CALL_OW 1
54043: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
54044: LD_ADDR_EXP 53
54048: PUSH
54049: LD_EXP 53
54053: PPUSH
54054: LD_VAR 0 4
54058: PPUSH
54059: EMPTY
54060: PPUSH
54061: CALL_OW 1
54065: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
54066: LD_ADDR_EXP 54
54070: PUSH
54071: LD_EXP 54
54075: PPUSH
54076: LD_VAR 0 4
54080: PPUSH
54081: EMPTY
54082: PPUSH
54083: CALL_OW 1
54087: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
54088: LD_ADDR_EXP 55
54092: PUSH
54093: LD_EXP 55
54097: PPUSH
54098: LD_VAR 0 4
54102: PPUSH
54103: EMPTY
54104: PPUSH
54105: CALL_OW 1
54109: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
54110: LD_ADDR_EXP 56
54114: PUSH
54115: LD_EXP 56
54119: PPUSH
54120: LD_VAR 0 4
54124: PPUSH
54125: EMPTY
54126: PPUSH
54127: CALL_OW 1
54131: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
54132: LD_ADDR_EXP 57
54136: PUSH
54137: LD_EXP 57
54141: PPUSH
54142: LD_VAR 0 4
54146: PPUSH
54147: EMPTY
54148: PPUSH
54149: CALL_OW 1
54153: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
54154: LD_ADDR_EXP 58
54158: PUSH
54159: LD_EXP 58
54163: PPUSH
54164: LD_VAR 0 4
54168: PPUSH
54169: EMPTY
54170: PPUSH
54171: CALL_OW 1
54175: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
54176: LD_ADDR_EXP 59
54180: PUSH
54181: LD_EXP 59
54185: PPUSH
54186: LD_VAR 0 4
54190: PPUSH
54191: EMPTY
54192: PPUSH
54193: CALL_OW 1
54197: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
54198: LD_ADDR_EXP 60
54202: PUSH
54203: LD_EXP 60
54207: PPUSH
54208: LD_VAR 0 4
54212: PPUSH
54213: EMPTY
54214: PPUSH
54215: CALL_OW 1
54219: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
54220: LD_ADDR_EXP 61
54224: PUSH
54225: LD_EXP 61
54229: PPUSH
54230: LD_VAR 0 4
54234: PPUSH
54235: EMPTY
54236: PPUSH
54237: CALL_OW 1
54241: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
54242: LD_ADDR_EXP 62
54246: PUSH
54247: LD_EXP 62
54251: PPUSH
54252: LD_VAR 0 4
54256: PPUSH
54257: EMPTY
54258: PPUSH
54259: CALL_OW 1
54263: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
54264: LD_ADDR_EXP 63
54268: PUSH
54269: LD_EXP 63
54273: PPUSH
54274: LD_VAR 0 4
54278: PPUSH
54279: EMPTY
54280: PPUSH
54281: CALL_OW 1
54285: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
54286: LD_ADDR_EXP 64
54290: PUSH
54291: LD_EXP 64
54295: PPUSH
54296: LD_VAR 0 4
54300: PPUSH
54301: EMPTY
54302: PPUSH
54303: CALL_OW 1
54307: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
54308: LD_ADDR_EXP 65
54312: PUSH
54313: LD_EXP 65
54317: PPUSH
54318: LD_VAR 0 4
54322: PPUSH
54323: LD_INT 0
54325: PPUSH
54326: CALL_OW 1
54330: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
54331: LD_ADDR_EXP 66
54335: PUSH
54336: LD_EXP 66
54340: PPUSH
54341: LD_VAR 0 4
54345: PPUSH
54346: LD_INT 0
54348: PPUSH
54349: CALL_OW 1
54353: ST_TO_ADDR
// result := base ;
54354: LD_ADDR_VAR 0 3
54358: PUSH
54359: LD_VAR 0 4
54363: ST_TO_ADDR
// end ;
54364: LD_VAR 0 3
54368: RET
// export function MC_Start ( ) ; var i ; begin
54369: LD_INT 0
54371: PPUSH
54372: PPUSH
// for i = 1 to mc_bases do
54373: LD_ADDR_VAR 0 2
54377: PUSH
54378: DOUBLE
54379: LD_INT 1
54381: DEC
54382: ST_TO_ADDR
54383: LD_EXP 23
54387: PUSH
54388: FOR_TO
54389: IFFALSE 55489
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
54391: LD_ADDR_EXP 23
54395: PUSH
54396: LD_EXP 23
54400: PPUSH
54401: LD_VAR 0 2
54405: PPUSH
54406: LD_EXP 23
54410: PUSH
54411: LD_VAR 0 2
54415: ARRAY
54416: PUSH
54417: LD_INT 0
54419: DIFF
54420: PPUSH
54421: CALL_OW 1
54425: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
54426: LD_ADDR_EXP 24
54430: PUSH
54431: LD_EXP 24
54435: PPUSH
54436: LD_VAR 0 2
54440: PPUSH
54441: EMPTY
54442: PPUSH
54443: CALL_OW 1
54447: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
54448: LD_ADDR_EXP 25
54452: PUSH
54453: LD_EXP 25
54457: PPUSH
54458: LD_VAR 0 2
54462: PPUSH
54463: EMPTY
54464: PPUSH
54465: CALL_OW 1
54469: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
54470: LD_ADDR_EXP 26
54474: PUSH
54475: LD_EXP 26
54479: PPUSH
54480: LD_VAR 0 2
54484: PPUSH
54485: EMPTY
54486: PPUSH
54487: CALL_OW 1
54491: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
54492: LD_ADDR_EXP 27
54496: PUSH
54497: LD_EXP 27
54501: PPUSH
54502: LD_VAR 0 2
54506: PPUSH
54507: EMPTY
54508: PUSH
54509: EMPTY
54510: PUSH
54511: EMPTY
54512: LIST
54513: LIST
54514: PPUSH
54515: CALL_OW 1
54519: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
54520: LD_ADDR_EXP 28
54524: PUSH
54525: LD_EXP 28
54529: PPUSH
54530: LD_VAR 0 2
54534: PPUSH
54535: EMPTY
54536: PPUSH
54537: CALL_OW 1
54541: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
54542: LD_ADDR_EXP 55
54546: PUSH
54547: LD_EXP 55
54551: PPUSH
54552: LD_VAR 0 2
54556: PPUSH
54557: EMPTY
54558: PPUSH
54559: CALL_OW 1
54563: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
54564: LD_ADDR_EXP 29
54568: PUSH
54569: LD_EXP 29
54573: PPUSH
54574: LD_VAR 0 2
54578: PPUSH
54579: EMPTY
54580: PPUSH
54581: CALL_OW 1
54585: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
54586: LD_ADDR_EXP 30
54590: PUSH
54591: LD_EXP 30
54595: PPUSH
54596: LD_VAR 0 2
54600: PPUSH
54601: EMPTY
54602: PPUSH
54603: CALL_OW 1
54607: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
54608: LD_ADDR_EXP 31
54612: PUSH
54613: LD_EXP 31
54617: PPUSH
54618: LD_VAR 0 2
54622: PPUSH
54623: LD_EXP 23
54627: PUSH
54628: LD_VAR 0 2
54632: ARRAY
54633: PPUSH
54634: LD_INT 2
54636: PUSH
54637: LD_INT 30
54639: PUSH
54640: LD_INT 32
54642: PUSH
54643: EMPTY
54644: LIST
54645: LIST
54646: PUSH
54647: LD_INT 30
54649: PUSH
54650: LD_INT 33
54652: PUSH
54653: EMPTY
54654: LIST
54655: LIST
54656: PUSH
54657: EMPTY
54658: LIST
54659: LIST
54660: LIST
54661: PPUSH
54662: CALL_OW 72
54666: PPUSH
54667: CALL_OW 1
54671: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
54672: LD_ADDR_EXP 32
54676: PUSH
54677: LD_EXP 32
54681: PPUSH
54682: LD_VAR 0 2
54686: PPUSH
54687: LD_EXP 23
54691: PUSH
54692: LD_VAR 0 2
54696: ARRAY
54697: PPUSH
54698: LD_INT 2
54700: PUSH
54701: LD_INT 30
54703: PUSH
54704: LD_INT 32
54706: PUSH
54707: EMPTY
54708: LIST
54709: LIST
54710: PUSH
54711: LD_INT 30
54713: PUSH
54714: LD_INT 31
54716: PUSH
54717: EMPTY
54718: LIST
54719: LIST
54720: PUSH
54721: EMPTY
54722: LIST
54723: LIST
54724: LIST
54725: PUSH
54726: LD_INT 58
54728: PUSH
54729: EMPTY
54730: LIST
54731: PUSH
54732: EMPTY
54733: LIST
54734: LIST
54735: PPUSH
54736: CALL_OW 72
54740: PPUSH
54741: CALL_OW 1
54745: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
54746: LD_ADDR_EXP 33
54750: PUSH
54751: LD_EXP 33
54755: PPUSH
54756: LD_VAR 0 2
54760: PPUSH
54761: EMPTY
54762: PPUSH
54763: CALL_OW 1
54767: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
54768: LD_ADDR_EXP 37
54772: PUSH
54773: LD_EXP 37
54777: PPUSH
54778: LD_VAR 0 2
54782: PPUSH
54783: EMPTY
54784: PPUSH
54785: CALL_OW 1
54789: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
54790: LD_ADDR_EXP 36
54794: PUSH
54795: LD_EXP 36
54799: PPUSH
54800: LD_VAR 0 2
54804: PPUSH
54805: EMPTY
54806: PPUSH
54807: CALL_OW 1
54811: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
54812: LD_ADDR_EXP 38
54816: PUSH
54817: LD_EXP 38
54821: PPUSH
54822: LD_VAR 0 2
54826: PPUSH
54827: EMPTY
54828: PPUSH
54829: CALL_OW 1
54833: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
54834: LD_ADDR_EXP 39
54838: PUSH
54839: LD_EXP 39
54843: PPUSH
54844: LD_VAR 0 2
54848: PPUSH
54849: EMPTY
54850: PPUSH
54851: CALL_OW 1
54855: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
54856: LD_ADDR_EXP 40
54860: PUSH
54861: LD_EXP 40
54865: PPUSH
54866: LD_VAR 0 2
54870: PPUSH
54871: EMPTY
54872: PPUSH
54873: CALL_OW 1
54877: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
54878: LD_ADDR_EXP 41
54882: PUSH
54883: LD_EXP 41
54887: PPUSH
54888: LD_VAR 0 2
54892: PPUSH
54893: EMPTY
54894: PPUSH
54895: CALL_OW 1
54899: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
54900: LD_ADDR_EXP 42
54904: PUSH
54905: LD_EXP 42
54909: PPUSH
54910: LD_VAR 0 2
54914: PPUSH
54915: EMPTY
54916: PPUSH
54917: CALL_OW 1
54921: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
54922: LD_ADDR_EXP 43
54926: PUSH
54927: LD_EXP 43
54931: PPUSH
54932: LD_VAR 0 2
54936: PPUSH
54937: EMPTY
54938: PPUSH
54939: CALL_OW 1
54943: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
54944: LD_ADDR_EXP 44
54948: PUSH
54949: LD_EXP 44
54953: PPUSH
54954: LD_VAR 0 2
54958: PPUSH
54959: EMPTY
54960: PPUSH
54961: CALL_OW 1
54965: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
54966: LD_ADDR_EXP 45
54970: PUSH
54971: LD_EXP 45
54975: PPUSH
54976: LD_VAR 0 2
54980: PPUSH
54981: EMPTY
54982: PPUSH
54983: CALL_OW 1
54987: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
54988: LD_ADDR_EXP 34
54992: PUSH
54993: LD_EXP 34
54997: PPUSH
54998: LD_VAR 0 2
55002: PPUSH
55003: LD_INT 0
55005: PPUSH
55006: CALL_OW 1
55010: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
55011: LD_ADDR_EXP 47
55015: PUSH
55016: LD_EXP 47
55020: PPUSH
55021: LD_VAR 0 2
55025: PPUSH
55026: LD_INT 0
55028: PPUSH
55029: CALL_OW 1
55033: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
55034: LD_ADDR_EXP 35
55038: PUSH
55039: LD_EXP 35
55043: PPUSH
55044: LD_VAR 0 2
55048: PPUSH
55049: EMPTY
55050: PPUSH
55051: CALL_OW 1
55055: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
55056: LD_ADDR_EXP 46
55060: PUSH
55061: LD_EXP 46
55065: PPUSH
55066: LD_VAR 0 2
55070: PPUSH
55071: LD_INT 0
55073: PPUSH
55074: CALL_OW 1
55078: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
55079: LD_ADDR_EXP 48
55083: PUSH
55084: LD_EXP 48
55088: PPUSH
55089: LD_VAR 0 2
55093: PPUSH
55094: EMPTY
55095: PPUSH
55096: CALL_OW 1
55100: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
55101: LD_ADDR_EXP 51
55105: PUSH
55106: LD_EXP 51
55110: PPUSH
55111: LD_VAR 0 2
55115: PPUSH
55116: LD_INT 0
55118: PPUSH
55119: CALL_OW 1
55123: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
55124: LD_ADDR_EXP 52
55128: PUSH
55129: LD_EXP 52
55133: PPUSH
55134: LD_VAR 0 2
55138: PPUSH
55139: EMPTY
55140: PPUSH
55141: CALL_OW 1
55145: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
55146: LD_ADDR_EXP 53
55150: PUSH
55151: LD_EXP 53
55155: PPUSH
55156: LD_VAR 0 2
55160: PPUSH
55161: EMPTY
55162: PPUSH
55163: CALL_OW 1
55167: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
55168: LD_ADDR_EXP 54
55172: PUSH
55173: LD_EXP 54
55177: PPUSH
55178: LD_VAR 0 2
55182: PPUSH
55183: EMPTY
55184: PPUSH
55185: CALL_OW 1
55189: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
55190: LD_ADDR_EXP 56
55194: PUSH
55195: LD_EXP 56
55199: PPUSH
55200: LD_VAR 0 2
55204: PPUSH
55205: LD_EXP 23
55209: PUSH
55210: LD_VAR 0 2
55214: ARRAY
55215: PPUSH
55216: LD_INT 2
55218: PUSH
55219: LD_INT 30
55221: PUSH
55222: LD_INT 6
55224: PUSH
55225: EMPTY
55226: LIST
55227: LIST
55228: PUSH
55229: LD_INT 30
55231: PUSH
55232: LD_INT 7
55234: PUSH
55235: EMPTY
55236: LIST
55237: LIST
55238: PUSH
55239: LD_INT 30
55241: PUSH
55242: LD_INT 8
55244: PUSH
55245: EMPTY
55246: LIST
55247: LIST
55248: PUSH
55249: EMPTY
55250: LIST
55251: LIST
55252: LIST
55253: LIST
55254: PPUSH
55255: CALL_OW 72
55259: PPUSH
55260: CALL_OW 1
55264: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
55265: LD_ADDR_EXP 57
55269: PUSH
55270: LD_EXP 57
55274: PPUSH
55275: LD_VAR 0 2
55279: PPUSH
55280: EMPTY
55281: PPUSH
55282: CALL_OW 1
55286: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
55287: LD_ADDR_EXP 58
55291: PUSH
55292: LD_EXP 58
55296: PPUSH
55297: LD_VAR 0 2
55301: PPUSH
55302: EMPTY
55303: PPUSH
55304: CALL_OW 1
55308: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
55309: LD_ADDR_EXP 59
55313: PUSH
55314: LD_EXP 59
55318: PPUSH
55319: LD_VAR 0 2
55323: PPUSH
55324: EMPTY
55325: PPUSH
55326: CALL_OW 1
55330: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
55331: LD_ADDR_EXP 60
55335: PUSH
55336: LD_EXP 60
55340: PPUSH
55341: LD_VAR 0 2
55345: PPUSH
55346: EMPTY
55347: PPUSH
55348: CALL_OW 1
55352: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55353: LD_ADDR_EXP 61
55357: PUSH
55358: LD_EXP 61
55362: PPUSH
55363: LD_VAR 0 2
55367: PPUSH
55368: EMPTY
55369: PPUSH
55370: CALL_OW 1
55374: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
55375: LD_ADDR_EXP 62
55379: PUSH
55380: LD_EXP 62
55384: PPUSH
55385: LD_VAR 0 2
55389: PPUSH
55390: EMPTY
55391: PPUSH
55392: CALL_OW 1
55396: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
55397: LD_ADDR_EXP 63
55401: PUSH
55402: LD_EXP 63
55406: PPUSH
55407: LD_VAR 0 2
55411: PPUSH
55412: EMPTY
55413: PPUSH
55414: CALL_OW 1
55418: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
55419: LD_ADDR_EXP 64
55423: PUSH
55424: LD_EXP 64
55428: PPUSH
55429: LD_VAR 0 2
55433: PPUSH
55434: EMPTY
55435: PPUSH
55436: CALL_OW 1
55440: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
55441: LD_ADDR_EXP 65
55445: PUSH
55446: LD_EXP 65
55450: PPUSH
55451: LD_VAR 0 2
55455: PPUSH
55456: LD_INT 0
55458: PPUSH
55459: CALL_OW 1
55463: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
55464: LD_ADDR_EXP 66
55468: PUSH
55469: LD_EXP 66
55473: PPUSH
55474: LD_VAR 0 2
55478: PPUSH
55479: LD_INT 0
55481: PPUSH
55482: CALL_OW 1
55486: ST_TO_ADDR
// end ;
55487: GO 54388
55489: POP
55490: POP
// MC_InitSides ( ) ;
55491: CALL 55777 0 0
// MC_InitResearch ( ) ;
55495: CALL 55516 0 0
// CustomInitMacro ( ) ;
55499: CALL 273 0 0
// skirmish := true ;
55503: LD_ADDR_EXP 21
55507: PUSH
55508: LD_INT 1
55510: ST_TO_ADDR
// end ;
55511: LD_VAR 0 1
55515: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
55516: LD_INT 0
55518: PPUSH
55519: PPUSH
55520: PPUSH
55521: PPUSH
55522: PPUSH
55523: PPUSH
// if not mc_bases then
55524: LD_EXP 23
55528: NOT
55529: IFFALSE 55533
// exit ;
55531: GO 55772
// for i = 1 to 8 do
55533: LD_ADDR_VAR 0 2
55537: PUSH
55538: DOUBLE
55539: LD_INT 1
55541: DEC
55542: ST_TO_ADDR
55543: LD_INT 8
55545: PUSH
55546: FOR_TO
55547: IFFALSE 55573
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
55549: LD_ADDR_EXP 50
55553: PUSH
55554: LD_EXP 50
55558: PPUSH
55559: LD_VAR 0 2
55563: PPUSH
55564: EMPTY
55565: PPUSH
55566: CALL_OW 1
55570: ST_TO_ADDR
55571: GO 55546
55573: POP
55574: POP
// tmp := [ ] ;
55575: LD_ADDR_VAR 0 5
55579: PUSH
55580: EMPTY
55581: ST_TO_ADDR
// for i = 1 to mc_sides do
55582: LD_ADDR_VAR 0 2
55586: PUSH
55587: DOUBLE
55588: LD_INT 1
55590: DEC
55591: ST_TO_ADDR
55592: LD_EXP 49
55596: PUSH
55597: FOR_TO
55598: IFFALSE 55656
// if not mc_sides [ i ] in tmp then
55600: LD_EXP 49
55604: PUSH
55605: LD_VAR 0 2
55609: ARRAY
55610: PUSH
55611: LD_VAR 0 5
55615: IN
55616: NOT
55617: IFFALSE 55654
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
55619: LD_ADDR_VAR 0 5
55623: PUSH
55624: LD_VAR 0 5
55628: PPUSH
55629: LD_VAR 0 5
55633: PUSH
55634: LD_INT 1
55636: PLUS
55637: PPUSH
55638: LD_EXP 49
55642: PUSH
55643: LD_VAR 0 2
55647: ARRAY
55648: PPUSH
55649: CALL_OW 2
55653: ST_TO_ADDR
55654: GO 55597
55656: POP
55657: POP
// if not tmp then
55658: LD_VAR 0 5
55662: NOT
55663: IFFALSE 55667
// exit ;
55665: GO 55772
// for j in tmp do
55667: LD_ADDR_VAR 0 3
55671: PUSH
55672: LD_VAR 0 5
55676: PUSH
55677: FOR_IN
55678: IFFALSE 55770
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
55680: LD_ADDR_VAR 0 6
55684: PUSH
55685: LD_INT 22
55687: PUSH
55688: LD_VAR 0 3
55692: PUSH
55693: EMPTY
55694: LIST
55695: LIST
55696: PPUSH
55697: CALL_OW 69
55701: ST_TO_ADDR
// if not un then
55702: LD_VAR 0 6
55706: NOT
55707: IFFALSE 55711
// continue ;
55709: GO 55677
// nation := GetNation ( un [ 1 ] ) ;
55711: LD_ADDR_VAR 0 4
55715: PUSH
55716: LD_VAR 0 6
55720: PUSH
55721: LD_INT 1
55723: ARRAY
55724: PPUSH
55725: CALL_OW 248
55729: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
55730: LD_ADDR_EXP 50
55734: PUSH
55735: LD_EXP 50
55739: PPUSH
55740: LD_VAR 0 3
55744: PPUSH
55745: LD_VAR 0 3
55749: PPUSH
55750: LD_VAR 0 4
55754: PPUSH
55755: LD_INT 1
55757: PPUSH
55758: CALL 11082 0 3
55762: PPUSH
55763: CALL_OW 1
55767: ST_TO_ADDR
// end ;
55768: GO 55677
55770: POP
55771: POP
// end ;
55772: LD_VAR 0 1
55776: RET
// export function MC_InitSides ( ) ; var i ; begin
55777: LD_INT 0
55779: PPUSH
55780: PPUSH
// if not mc_bases then
55781: LD_EXP 23
55785: NOT
55786: IFFALSE 55790
// exit ;
55788: GO 55864
// for i = 1 to mc_bases do
55790: LD_ADDR_VAR 0 2
55794: PUSH
55795: DOUBLE
55796: LD_INT 1
55798: DEC
55799: ST_TO_ADDR
55800: LD_EXP 23
55804: PUSH
55805: FOR_TO
55806: IFFALSE 55862
// if mc_bases [ i ] then
55808: LD_EXP 23
55812: PUSH
55813: LD_VAR 0 2
55817: ARRAY
55818: IFFALSE 55860
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
55820: LD_ADDR_EXP 49
55824: PUSH
55825: LD_EXP 49
55829: PPUSH
55830: LD_VAR 0 2
55834: PPUSH
55835: LD_EXP 23
55839: PUSH
55840: LD_VAR 0 2
55844: ARRAY
55845: PUSH
55846: LD_INT 1
55848: ARRAY
55849: PPUSH
55850: CALL_OW 255
55854: PPUSH
55855: CALL_OW 1
55859: ST_TO_ADDR
55860: GO 55805
55862: POP
55863: POP
// end ;
55864: LD_VAR 0 1
55868: RET
// every 0 0$03 trigger skirmish do
55869: LD_EXP 21
55873: IFFALSE 56027
55875: GO 55877
55877: DISABLE
// begin enable ;
55878: ENABLE
// MC_CheckBuildings ( ) ;
55879: CALL 60525 0 0
// MC_CheckPeopleLife ( ) ;
55883: CALL 60686 0 0
// RaiseSailEvent ( 100 ) ;
55887: LD_INT 100
55889: PPUSH
55890: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
55894: LD_INT 103
55896: PPUSH
55897: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
55901: LD_INT 104
55903: PPUSH
55904: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
55908: LD_INT 105
55910: PPUSH
55911: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
55915: LD_INT 106
55917: PPUSH
55918: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
55922: LD_INT 107
55924: PPUSH
55925: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
55929: LD_INT 108
55931: PPUSH
55932: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
55936: LD_INT 109
55938: PPUSH
55939: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
55943: LD_INT 110
55945: PPUSH
55946: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
55950: LD_INT 111
55952: PPUSH
55953: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
55957: LD_INT 112
55959: PPUSH
55960: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
55964: LD_INT 113
55966: PPUSH
55967: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
55971: LD_INT 120
55973: PPUSH
55974: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
55978: LD_INT 121
55980: PPUSH
55981: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
55985: LD_INT 122
55987: PPUSH
55988: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
55992: LD_INT 123
55994: PPUSH
55995: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
55999: LD_INT 124
56001: PPUSH
56002: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
56006: LD_INT 125
56008: PPUSH
56009: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
56013: LD_INT 126
56015: PPUSH
56016: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
56020: LD_INT 200
56022: PPUSH
56023: CALL_OW 427
// end ;
56027: END
// on SailEvent ( event ) do begin if event < 100 then
56028: LD_VAR 0 1
56032: PUSH
56033: LD_INT 100
56035: LESS
56036: IFFALSE 56047
// CustomEvent ( event ) ;
56038: LD_VAR 0 1
56042: PPUSH
56043: CALL 10233 0 1
// if event = 100 then
56047: LD_VAR 0 1
56051: PUSH
56052: LD_INT 100
56054: EQUAL
56055: IFFALSE 56061
// MC_ClassManager ( ) ;
56057: CALL 56453 0 0
// if event = 101 then
56061: LD_VAR 0 1
56065: PUSH
56066: LD_INT 101
56068: EQUAL
56069: IFFALSE 56075
// MC_RepairBuildings ( ) ;
56071: CALL 61271 0 0
// if event = 102 then
56075: LD_VAR 0 1
56079: PUSH
56080: LD_INT 102
56082: EQUAL
56083: IFFALSE 56089
// MC_Heal ( ) ;
56085: CALL 62174 0 0
// if event = 103 then
56089: LD_VAR 0 1
56093: PUSH
56094: LD_INT 103
56096: EQUAL
56097: IFFALSE 56103
// MC_Build ( ) ;
56099: CALL 62596 0 0
// if event = 104 then
56103: LD_VAR 0 1
56107: PUSH
56108: LD_INT 104
56110: EQUAL
56111: IFFALSE 56117
// MC_TurretWeapon ( ) ;
56113: CALL 64237 0 0
// if event = 105 then
56117: LD_VAR 0 1
56121: PUSH
56122: LD_INT 105
56124: EQUAL
56125: IFFALSE 56131
// MC_BuildUpgrade ( ) ;
56127: CALL 63788 0 0
// if event = 106 then
56131: LD_VAR 0 1
56135: PUSH
56136: LD_INT 106
56138: EQUAL
56139: IFFALSE 56145
// MC_PlantMines ( ) ;
56141: CALL 64667 0 0
// if event = 107 then
56145: LD_VAR 0 1
56149: PUSH
56150: LD_INT 107
56152: EQUAL
56153: IFFALSE 56159
// MC_CollectCrates ( ) ;
56155: CALL 65458 0 0
// if event = 108 then
56159: LD_VAR 0 1
56163: PUSH
56164: LD_INT 108
56166: EQUAL
56167: IFFALSE 56173
// MC_LinkRemoteControl ( ) ;
56169: CALL 67308 0 0
// if event = 109 then
56173: LD_VAR 0 1
56177: PUSH
56178: LD_INT 109
56180: EQUAL
56181: IFFALSE 56187
// MC_ProduceVehicle ( ) ;
56183: CALL 67489 0 0
// if event = 110 then
56187: LD_VAR 0 1
56191: PUSH
56192: LD_INT 110
56194: EQUAL
56195: IFFALSE 56201
// MC_SendAttack ( ) ;
56197: CALL 67955 0 0
// if event = 111 then
56201: LD_VAR 0 1
56205: PUSH
56206: LD_INT 111
56208: EQUAL
56209: IFFALSE 56215
// MC_Defend ( ) ;
56211: CALL 68063 0 0
// if event = 112 then
56215: LD_VAR 0 1
56219: PUSH
56220: LD_INT 112
56222: EQUAL
56223: IFFALSE 56229
// MC_Research ( ) ;
56225: CALL 68943 0 0
// if event = 113 then
56229: LD_VAR 0 1
56233: PUSH
56234: LD_INT 113
56236: EQUAL
56237: IFFALSE 56243
// MC_MinesTrigger ( ) ;
56239: CALL 70057 0 0
// if event = 120 then
56243: LD_VAR 0 1
56247: PUSH
56248: LD_INT 120
56250: EQUAL
56251: IFFALSE 56257
// MC_RepairVehicle ( ) ;
56253: CALL 70156 0 0
// if event = 121 then
56257: LD_VAR 0 1
56261: PUSH
56262: LD_INT 121
56264: EQUAL
56265: IFFALSE 56271
// MC_TameApe ( ) ;
56267: CALL 70897 0 0
// if event = 122 then
56271: LD_VAR 0 1
56275: PUSH
56276: LD_INT 122
56278: EQUAL
56279: IFFALSE 56285
// MC_ChangeApeClass ( ) ;
56281: CALL 71726 0 0
// if event = 123 then
56285: LD_VAR 0 1
56289: PUSH
56290: LD_INT 123
56292: EQUAL
56293: IFFALSE 56299
// MC_Bazooka ( ) ;
56295: CALL 72376 0 0
// if event = 124 then
56299: LD_VAR 0 1
56303: PUSH
56304: LD_INT 124
56306: EQUAL
56307: IFFALSE 56313
// MC_TeleportExit ( ) ;
56309: CALL 72574 0 0
// if event = 125 then
56313: LD_VAR 0 1
56317: PUSH
56318: LD_INT 125
56320: EQUAL
56321: IFFALSE 56327
// MC_Deposits ( ) ;
56323: CALL 73221 0 0
// if event = 126 then
56327: LD_VAR 0 1
56331: PUSH
56332: LD_INT 126
56334: EQUAL
56335: IFFALSE 56341
// MC_RemoteDriver ( ) ;
56337: CALL 73846 0 0
// if event = 200 then
56341: LD_VAR 0 1
56345: PUSH
56346: LD_INT 200
56348: EQUAL
56349: IFFALSE 56355
// MC_Idle ( ) ;
56351: CALL 75795 0 0
// end ;
56355: PPOPN 1
56357: END
// export function MC_Reset ( base , tag ) ; var i ; begin
56358: LD_INT 0
56360: PPUSH
56361: PPUSH
// if not mc_bases [ base ] or not tag then
56362: LD_EXP 23
56366: PUSH
56367: LD_VAR 0 1
56371: ARRAY
56372: NOT
56373: PUSH
56374: LD_VAR 0 2
56378: NOT
56379: OR
56380: IFFALSE 56384
// exit ;
56382: GO 56448
// for i in mc_bases [ base ] union mc_ape [ base ] do
56384: LD_ADDR_VAR 0 4
56388: PUSH
56389: LD_EXP 23
56393: PUSH
56394: LD_VAR 0 1
56398: ARRAY
56399: PUSH
56400: LD_EXP 52
56404: PUSH
56405: LD_VAR 0 1
56409: ARRAY
56410: UNION
56411: PUSH
56412: FOR_IN
56413: IFFALSE 56446
// if GetTag ( i ) = tag then
56415: LD_VAR 0 4
56419: PPUSH
56420: CALL_OW 110
56424: PUSH
56425: LD_VAR 0 2
56429: EQUAL
56430: IFFALSE 56444
// SetTag ( i , 0 ) ;
56432: LD_VAR 0 4
56436: PPUSH
56437: LD_INT 0
56439: PPUSH
56440: CALL_OW 109
56444: GO 56412
56446: POP
56447: POP
// end ;
56448: LD_VAR 0 3
56452: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
56453: LD_INT 0
56455: PPUSH
56456: PPUSH
56457: PPUSH
56458: PPUSH
56459: PPUSH
56460: PPUSH
56461: PPUSH
56462: PPUSH
// if not mc_bases then
56463: LD_EXP 23
56467: NOT
56468: IFFALSE 56472
// exit ;
56470: GO 56930
// for i = 1 to mc_bases do
56472: LD_ADDR_VAR 0 2
56476: PUSH
56477: DOUBLE
56478: LD_INT 1
56480: DEC
56481: ST_TO_ADDR
56482: LD_EXP 23
56486: PUSH
56487: FOR_TO
56488: IFFALSE 56928
// begin tmp := MC_ClassCheckReq ( i ) ;
56490: LD_ADDR_VAR 0 4
56494: PUSH
56495: LD_VAR 0 2
56499: PPUSH
56500: CALL 56935 0 1
56504: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
56505: LD_ADDR_EXP 64
56509: PUSH
56510: LD_EXP 64
56514: PPUSH
56515: LD_VAR 0 2
56519: PPUSH
56520: LD_VAR 0 4
56524: PPUSH
56525: CALL_OW 1
56529: ST_TO_ADDR
// if not tmp then
56530: LD_VAR 0 4
56534: NOT
56535: IFFALSE 56539
// continue ;
56537: GO 56487
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
56539: LD_ADDR_VAR 0 6
56543: PUSH
56544: LD_EXP 23
56548: PUSH
56549: LD_VAR 0 2
56553: ARRAY
56554: PPUSH
56555: LD_INT 2
56557: PUSH
56558: LD_INT 30
56560: PUSH
56561: LD_INT 4
56563: PUSH
56564: EMPTY
56565: LIST
56566: LIST
56567: PUSH
56568: LD_INT 30
56570: PUSH
56571: LD_INT 5
56573: PUSH
56574: EMPTY
56575: LIST
56576: LIST
56577: PUSH
56578: EMPTY
56579: LIST
56580: LIST
56581: LIST
56582: PPUSH
56583: CALL_OW 72
56587: PUSH
56588: LD_EXP 23
56592: PUSH
56593: LD_VAR 0 2
56597: ARRAY
56598: PPUSH
56599: LD_INT 2
56601: PUSH
56602: LD_INT 30
56604: PUSH
56605: LD_INT 0
56607: PUSH
56608: EMPTY
56609: LIST
56610: LIST
56611: PUSH
56612: LD_INT 30
56614: PUSH
56615: LD_INT 1
56617: PUSH
56618: EMPTY
56619: LIST
56620: LIST
56621: PUSH
56622: EMPTY
56623: LIST
56624: LIST
56625: LIST
56626: PPUSH
56627: CALL_OW 72
56631: PUSH
56632: LD_EXP 23
56636: PUSH
56637: LD_VAR 0 2
56641: ARRAY
56642: PPUSH
56643: LD_INT 30
56645: PUSH
56646: LD_INT 3
56648: PUSH
56649: EMPTY
56650: LIST
56651: LIST
56652: PPUSH
56653: CALL_OW 72
56657: PUSH
56658: LD_EXP 23
56662: PUSH
56663: LD_VAR 0 2
56667: ARRAY
56668: PPUSH
56669: LD_INT 2
56671: PUSH
56672: LD_INT 30
56674: PUSH
56675: LD_INT 6
56677: PUSH
56678: EMPTY
56679: LIST
56680: LIST
56681: PUSH
56682: LD_INT 30
56684: PUSH
56685: LD_INT 7
56687: PUSH
56688: EMPTY
56689: LIST
56690: LIST
56691: PUSH
56692: LD_INT 30
56694: PUSH
56695: LD_INT 8
56697: PUSH
56698: EMPTY
56699: LIST
56700: LIST
56701: PUSH
56702: EMPTY
56703: LIST
56704: LIST
56705: LIST
56706: LIST
56707: PPUSH
56708: CALL_OW 72
56712: PUSH
56713: EMPTY
56714: LIST
56715: LIST
56716: LIST
56717: LIST
56718: ST_TO_ADDR
// for j = 1 to 4 do
56719: LD_ADDR_VAR 0 3
56723: PUSH
56724: DOUBLE
56725: LD_INT 1
56727: DEC
56728: ST_TO_ADDR
56729: LD_INT 4
56731: PUSH
56732: FOR_TO
56733: IFFALSE 56924
// begin if not tmp [ j ] then
56735: LD_VAR 0 4
56739: PUSH
56740: LD_VAR 0 3
56744: ARRAY
56745: NOT
56746: IFFALSE 56750
// continue ;
56748: GO 56732
// for p in tmp [ j ] do
56750: LD_ADDR_VAR 0 5
56754: PUSH
56755: LD_VAR 0 4
56759: PUSH
56760: LD_VAR 0 3
56764: ARRAY
56765: PUSH
56766: FOR_IN
56767: IFFALSE 56920
// begin if not b [ j ] then
56769: LD_VAR 0 6
56773: PUSH
56774: LD_VAR 0 3
56778: ARRAY
56779: NOT
56780: IFFALSE 56784
// break ;
56782: GO 56920
// e := 0 ;
56784: LD_ADDR_VAR 0 7
56788: PUSH
56789: LD_INT 0
56791: ST_TO_ADDR
// for k in b [ j ] do
56792: LD_ADDR_VAR 0 8
56796: PUSH
56797: LD_VAR 0 6
56801: PUSH
56802: LD_VAR 0 3
56806: ARRAY
56807: PUSH
56808: FOR_IN
56809: IFFALSE 56836
// if IsNotFull ( k ) then
56811: LD_VAR 0 8
56815: PPUSH
56816: CALL 13235 0 1
56820: IFFALSE 56834
// begin e := k ;
56822: LD_ADDR_VAR 0 7
56826: PUSH
56827: LD_VAR 0 8
56831: ST_TO_ADDR
// break ;
56832: GO 56836
// end ;
56834: GO 56808
56836: POP
56837: POP
// if e and not UnitGoingToBuilding ( p , e ) then
56838: LD_VAR 0 7
56842: PUSH
56843: LD_VAR 0 5
56847: PPUSH
56848: LD_VAR 0 7
56852: PPUSH
56853: CALL 47041 0 2
56857: NOT
56858: AND
56859: IFFALSE 56918
// begin if IsInUnit ( p ) then
56861: LD_VAR 0 5
56865: PPUSH
56866: CALL_OW 310
56870: IFFALSE 56881
// ComExitBuilding ( p ) ;
56872: LD_VAR 0 5
56876: PPUSH
56877: CALL_OW 122
// ComEnterUnit ( p , e ) ;
56881: LD_VAR 0 5
56885: PPUSH
56886: LD_VAR 0 7
56890: PPUSH
56891: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
56895: LD_VAR 0 5
56899: PPUSH
56900: LD_VAR 0 3
56904: PPUSH
56905: CALL_OW 183
// AddComExitBuilding ( p ) ;
56909: LD_VAR 0 5
56913: PPUSH
56914: CALL_OW 182
// end ; end ;
56918: GO 56766
56920: POP
56921: POP
// end ;
56922: GO 56732
56924: POP
56925: POP
// end ;
56926: GO 56487
56928: POP
56929: POP
// end ;
56930: LD_VAR 0 1
56934: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
56935: LD_INT 0
56937: PPUSH
56938: PPUSH
56939: PPUSH
56940: PPUSH
56941: PPUSH
56942: PPUSH
56943: PPUSH
56944: PPUSH
56945: PPUSH
56946: PPUSH
56947: PPUSH
56948: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
56949: LD_VAR 0 1
56953: NOT
56954: PUSH
56955: LD_EXP 23
56959: PUSH
56960: LD_VAR 0 1
56964: ARRAY
56965: NOT
56966: OR
56967: PUSH
56968: LD_EXP 23
56972: PUSH
56973: LD_VAR 0 1
56977: ARRAY
56978: PPUSH
56979: LD_INT 2
56981: PUSH
56982: LD_INT 30
56984: PUSH
56985: LD_INT 0
56987: PUSH
56988: EMPTY
56989: LIST
56990: LIST
56991: PUSH
56992: LD_INT 30
56994: PUSH
56995: LD_INT 1
56997: PUSH
56998: EMPTY
56999: LIST
57000: LIST
57001: PUSH
57002: EMPTY
57003: LIST
57004: LIST
57005: LIST
57006: PPUSH
57007: CALL_OW 72
57011: NOT
57012: OR
57013: IFFALSE 57017
// exit ;
57015: GO 60520
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
57017: LD_ADDR_VAR 0 4
57021: PUSH
57022: LD_EXP 23
57026: PUSH
57027: LD_VAR 0 1
57031: ARRAY
57032: PPUSH
57033: LD_INT 2
57035: PUSH
57036: LD_INT 25
57038: PUSH
57039: LD_INT 1
57041: PUSH
57042: EMPTY
57043: LIST
57044: LIST
57045: PUSH
57046: LD_INT 25
57048: PUSH
57049: LD_INT 2
57051: PUSH
57052: EMPTY
57053: LIST
57054: LIST
57055: PUSH
57056: LD_INT 25
57058: PUSH
57059: LD_INT 3
57061: PUSH
57062: EMPTY
57063: LIST
57064: LIST
57065: PUSH
57066: LD_INT 25
57068: PUSH
57069: LD_INT 4
57071: PUSH
57072: EMPTY
57073: LIST
57074: LIST
57075: PUSH
57076: LD_INT 25
57078: PUSH
57079: LD_INT 5
57081: PUSH
57082: EMPTY
57083: LIST
57084: LIST
57085: PUSH
57086: LD_INT 25
57088: PUSH
57089: LD_INT 8
57091: PUSH
57092: EMPTY
57093: LIST
57094: LIST
57095: PUSH
57096: LD_INT 25
57098: PUSH
57099: LD_INT 9
57101: PUSH
57102: EMPTY
57103: LIST
57104: LIST
57105: PUSH
57106: EMPTY
57107: LIST
57108: LIST
57109: LIST
57110: LIST
57111: LIST
57112: LIST
57113: LIST
57114: LIST
57115: PPUSH
57116: CALL_OW 72
57120: ST_TO_ADDR
// if not tmp then
57121: LD_VAR 0 4
57125: NOT
57126: IFFALSE 57130
// exit ;
57128: GO 60520
// for i in tmp do
57130: LD_ADDR_VAR 0 3
57134: PUSH
57135: LD_VAR 0 4
57139: PUSH
57140: FOR_IN
57141: IFFALSE 57172
// if GetTag ( i ) then
57143: LD_VAR 0 3
57147: PPUSH
57148: CALL_OW 110
57152: IFFALSE 57170
// tmp := tmp diff i ;
57154: LD_ADDR_VAR 0 4
57158: PUSH
57159: LD_VAR 0 4
57163: PUSH
57164: LD_VAR 0 3
57168: DIFF
57169: ST_TO_ADDR
57170: GO 57140
57172: POP
57173: POP
// if not tmp then
57174: LD_VAR 0 4
57178: NOT
57179: IFFALSE 57183
// exit ;
57181: GO 60520
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
57183: LD_ADDR_VAR 0 5
57187: PUSH
57188: LD_EXP 23
57192: PUSH
57193: LD_VAR 0 1
57197: ARRAY
57198: PPUSH
57199: LD_INT 2
57201: PUSH
57202: LD_INT 25
57204: PUSH
57205: LD_INT 1
57207: PUSH
57208: EMPTY
57209: LIST
57210: LIST
57211: PUSH
57212: LD_INT 25
57214: PUSH
57215: LD_INT 5
57217: PUSH
57218: EMPTY
57219: LIST
57220: LIST
57221: PUSH
57222: LD_INT 25
57224: PUSH
57225: LD_INT 8
57227: PUSH
57228: EMPTY
57229: LIST
57230: LIST
57231: PUSH
57232: LD_INT 25
57234: PUSH
57235: LD_INT 9
57237: PUSH
57238: EMPTY
57239: LIST
57240: LIST
57241: PUSH
57242: EMPTY
57243: LIST
57244: LIST
57245: LIST
57246: LIST
57247: LIST
57248: PPUSH
57249: CALL_OW 72
57253: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
57254: LD_ADDR_VAR 0 6
57258: PUSH
57259: LD_EXP 23
57263: PUSH
57264: LD_VAR 0 1
57268: ARRAY
57269: PPUSH
57270: LD_INT 25
57272: PUSH
57273: LD_INT 2
57275: PUSH
57276: EMPTY
57277: LIST
57278: LIST
57279: PPUSH
57280: CALL_OW 72
57284: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
57285: LD_ADDR_VAR 0 7
57289: PUSH
57290: LD_EXP 23
57294: PUSH
57295: LD_VAR 0 1
57299: ARRAY
57300: PPUSH
57301: LD_INT 25
57303: PUSH
57304: LD_INT 3
57306: PUSH
57307: EMPTY
57308: LIST
57309: LIST
57310: PPUSH
57311: CALL_OW 72
57315: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
57316: LD_ADDR_VAR 0 8
57320: PUSH
57321: LD_EXP 23
57325: PUSH
57326: LD_VAR 0 1
57330: ARRAY
57331: PPUSH
57332: LD_INT 25
57334: PUSH
57335: LD_INT 4
57337: PUSH
57338: EMPTY
57339: LIST
57340: LIST
57341: PUSH
57342: LD_INT 24
57344: PUSH
57345: LD_INT 251
57347: PUSH
57348: EMPTY
57349: LIST
57350: LIST
57351: PUSH
57352: EMPTY
57353: LIST
57354: LIST
57355: PPUSH
57356: CALL_OW 72
57360: ST_TO_ADDR
// if mc_is_defending [ base ] then
57361: LD_EXP 66
57365: PUSH
57366: LD_VAR 0 1
57370: ARRAY
57371: IFFALSE 57832
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
57373: LD_ADDR_EXP 65
57377: PUSH
57378: LD_EXP 65
57382: PPUSH
57383: LD_VAR 0 1
57387: PPUSH
57388: LD_INT 4
57390: PPUSH
57391: CALL_OW 1
57395: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
57396: LD_ADDR_VAR 0 12
57400: PUSH
57401: LD_EXP 23
57405: PUSH
57406: LD_VAR 0 1
57410: ARRAY
57411: PPUSH
57412: LD_INT 2
57414: PUSH
57415: LD_INT 30
57417: PUSH
57418: LD_INT 4
57420: PUSH
57421: EMPTY
57422: LIST
57423: LIST
57424: PUSH
57425: LD_INT 30
57427: PUSH
57428: LD_INT 5
57430: PUSH
57431: EMPTY
57432: LIST
57433: LIST
57434: PUSH
57435: EMPTY
57436: LIST
57437: LIST
57438: LIST
57439: PPUSH
57440: CALL_OW 72
57444: ST_TO_ADDR
// if not b then
57445: LD_VAR 0 12
57449: NOT
57450: IFFALSE 57454
// exit ;
57452: GO 60520
// p := [ ] ;
57454: LD_ADDR_VAR 0 11
57458: PUSH
57459: EMPTY
57460: ST_TO_ADDR
// if sci >= 2 then
57461: LD_VAR 0 8
57465: PUSH
57466: LD_INT 2
57468: GREATEREQUAL
57469: IFFALSE 57500
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
57471: LD_ADDR_VAR 0 8
57475: PUSH
57476: LD_VAR 0 8
57480: PUSH
57481: LD_INT 1
57483: ARRAY
57484: PUSH
57485: LD_VAR 0 8
57489: PUSH
57490: LD_INT 2
57492: ARRAY
57493: PUSH
57494: EMPTY
57495: LIST
57496: LIST
57497: ST_TO_ADDR
57498: GO 57561
// if sci = 1 then
57500: LD_VAR 0 8
57504: PUSH
57505: LD_INT 1
57507: EQUAL
57508: IFFALSE 57529
// sci := [ sci [ 1 ] ] else
57510: LD_ADDR_VAR 0 8
57514: PUSH
57515: LD_VAR 0 8
57519: PUSH
57520: LD_INT 1
57522: ARRAY
57523: PUSH
57524: EMPTY
57525: LIST
57526: ST_TO_ADDR
57527: GO 57561
// if sci = 0 then
57529: LD_VAR 0 8
57533: PUSH
57534: LD_INT 0
57536: EQUAL
57537: IFFALSE 57561
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
57539: LD_ADDR_VAR 0 11
57543: PUSH
57544: LD_VAR 0 4
57548: PPUSH
57549: LD_INT 4
57551: PPUSH
57552: CALL 46904 0 2
57556: PUSH
57557: LD_INT 1
57559: ARRAY
57560: ST_TO_ADDR
// if eng > 4 then
57561: LD_VAR 0 6
57565: PUSH
57566: LD_INT 4
57568: GREATER
57569: IFFALSE 57615
// for i = eng downto 4 do
57571: LD_ADDR_VAR 0 3
57575: PUSH
57576: DOUBLE
57577: LD_VAR 0 6
57581: INC
57582: ST_TO_ADDR
57583: LD_INT 4
57585: PUSH
57586: FOR_DOWNTO
57587: IFFALSE 57613
// eng := eng diff eng [ i ] ;
57589: LD_ADDR_VAR 0 6
57593: PUSH
57594: LD_VAR 0 6
57598: PUSH
57599: LD_VAR 0 6
57603: PUSH
57604: LD_VAR 0 3
57608: ARRAY
57609: DIFF
57610: ST_TO_ADDR
57611: GO 57586
57613: POP
57614: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
57615: LD_ADDR_VAR 0 4
57619: PUSH
57620: LD_VAR 0 4
57624: PUSH
57625: LD_VAR 0 5
57629: PUSH
57630: LD_VAR 0 6
57634: UNION
57635: PUSH
57636: LD_VAR 0 7
57640: UNION
57641: PUSH
57642: LD_VAR 0 8
57646: UNION
57647: DIFF
57648: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
57649: LD_ADDR_VAR 0 13
57653: PUSH
57654: LD_EXP 23
57658: PUSH
57659: LD_VAR 0 1
57663: ARRAY
57664: PPUSH
57665: LD_INT 2
57667: PUSH
57668: LD_INT 30
57670: PUSH
57671: LD_INT 32
57673: PUSH
57674: EMPTY
57675: LIST
57676: LIST
57677: PUSH
57678: LD_INT 30
57680: PUSH
57681: LD_INT 31
57683: PUSH
57684: EMPTY
57685: LIST
57686: LIST
57687: PUSH
57688: EMPTY
57689: LIST
57690: LIST
57691: LIST
57692: PPUSH
57693: CALL_OW 72
57697: PUSH
57698: LD_EXP 23
57702: PUSH
57703: LD_VAR 0 1
57707: ARRAY
57708: PPUSH
57709: LD_INT 2
57711: PUSH
57712: LD_INT 30
57714: PUSH
57715: LD_INT 4
57717: PUSH
57718: EMPTY
57719: LIST
57720: LIST
57721: PUSH
57722: LD_INT 30
57724: PUSH
57725: LD_INT 5
57727: PUSH
57728: EMPTY
57729: LIST
57730: LIST
57731: PUSH
57732: EMPTY
57733: LIST
57734: LIST
57735: LIST
57736: PPUSH
57737: CALL_OW 72
57741: PUSH
57742: LD_INT 6
57744: MUL
57745: PLUS
57746: ST_TO_ADDR
// if bcount < tmp then
57747: LD_VAR 0 13
57751: PUSH
57752: LD_VAR 0 4
57756: LESS
57757: IFFALSE 57803
// for i = tmp downto bcount do
57759: LD_ADDR_VAR 0 3
57763: PUSH
57764: DOUBLE
57765: LD_VAR 0 4
57769: INC
57770: ST_TO_ADDR
57771: LD_VAR 0 13
57775: PUSH
57776: FOR_DOWNTO
57777: IFFALSE 57801
// tmp := Delete ( tmp , tmp ) ;
57779: LD_ADDR_VAR 0 4
57783: PUSH
57784: LD_VAR 0 4
57788: PPUSH
57789: LD_VAR 0 4
57793: PPUSH
57794: CALL_OW 3
57798: ST_TO_ADDR
57799: GO 57776
57801: POP
57802: POP
// result := [ tmp , 0 , 0 , p ] ;
57803: LD_ADDR_VAR 0 2
57807: PUSH
57808: LD_VAR 0 4
57812: PUSH
57813: LD_INT 0
57815: PUSH
57816: LD_INT 0
57818: PUSH
57819: LD_VAR 0 11
57823: PUSH
57824: EMPTY
57825: LIST
57826: LIST
57827: LIST
57828: LIST
57829: ST_TO_ADDR
// exit ;
57830: GO 60520
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
57832: LD_EXP 23
57836: PUSH
57837: LD_VAR 0 1
57841: ARRAY
57842: PPUSH
57843: LD_INT 2
57845: PUSH
57846: LD_INT 30
57848: PUSH
57849: LD_INT 6
57851: PUSH
57852: EMPTY
57853: LIST
57854: LIST
57855: PUSH
57856: LD_INT 30
57858: PUSH
57859: LD_INT 7
57861: PUSH
57862: EMPTY
57863: LIST
57864: LIST
57865: PUSH
57866: LD_INT 30
57868: PUSH
57869: LD_INT 8
57871: PUSH
57872: EMPTY
57873: LIST
57874: LIST
57875: PUSH
57876: EMPTY
57877: LIST
57878: LIST
57879: LIST
57880: LIST
57881: PPUSH
57882: CALL_OW 72
57886: NOT
57887: PUSH
57888: LD_EXP 23
57892: PUSH
57893: LD_VAR 0 1
57897: ARRAY
57898: PPUSH
57899: LD_INT 30
57901: PUSH
57902: LD_INT 3
57904: PUSH
57905: EMPTY
57906: LIST
57907: LIST
57908: PPUSH
57909: CALL_OW 72
57913: NOT
57914: AND
57915: IFFALSE 57987
// begin if eng = tmp then
57917: LD_VAR 0 6
57921: PUSH
57922: LD_VAR 0 4
57926: EQUAL
57927: IFFALSE 57931
// exit ;
57929: GO 60520
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
57931: LD_ADDR_EXP 65
57935: PUSH
57936: LD_EXP 65
57940: PPUSH
57941: LD_VAR 0 1
57945: PPUSH
57946: LD_INT 1
57948: PPUSH
57949: CALL_OW 1
57953: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
57954: LD_ADDR_VAR 0 2
57958: PUSH
57959: LD_INT 0
57961: PUSH
57962: LD_VAR 0 4
57966: PUSH
57967: LD_VAR 0 6
57971: DIFF
57972: PUSH
57973: LD_INT 0
57975: PUSH
57976: LD_INT 0
57978: PUSH
57979: EMPTY
57980: LIST
57981: LIST
57982: LIST
57983: LIST
57984: ST_TO_ADDR
// exit ;
57985: GO 60520
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
57987: LD_EXP 50
57991: PUSH
57992: LD_EXP 49
57996: PUSH
57997: LD_VAR 0 1
58001: ARRAY
58002: ARRAY
58003: PUSH
58004: LD_EXP 23
58008: PUSH
58009: LD_VAR 0 1
58013: ARRAY
58014: PPUSH
58015: LD_INT 2
58017: PUSH
58018: LD_INT 30
58020: PUSH
58021: LD_INT 6
58023: PUSH
58024: EMPTY
58025: LIST
58026: LIST
58027: PUSH
58028: LD_INT 30
58030: PUSH
58031: LD_INT 7
58033: PUSH
58034: EMPTY
58035: LIST
58036: LIST
58037: PUSH
58038: LD_INT 30
58040: PUSH
58041: LD_INT 8
58043: PUSH
58044: EMPTY
58045: LIST
58046: LIST
58047: PUSH
58048: EMPTY
58049: LIST
58050: LIST
58051: LIST
58052: LIST
58053: PPUSH
58054: CALL_OW 72
58058: AND
58059: PUSH
58060: LD_EXP 23
58064: PUSH
58065: LD_VAR 0 1
58069: ARRAY
58070: PPUSH
58071: LD_INT 30
58073: PUSH
58074: LD_INT 3
58076: PUSH
58077: EMPTY
58078: LIST
58079: LIST
58080: PPUSH
58081: CALL_OW 72
58085: NOT
58086: AND
58087: IFFALSE 58301
// begin if sci >= 6 then
58089: LD_VAR 0 8
58093: PUSH
58094: LD_INT 6
58096: GREATEREQUAL
58097: IFFALSE 58101
// exit ;
58099: GO 60520
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
58101: LD_ADDR_EXP 65
58105: PUSH
58106: LD_EXP 65
58110: PPUSH
58111: LD_VAR 0 1
58115: PPUSH
58116: LD_INT 2
58118: PPUSH
58119: CALL_OW 1
58123: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
58124: LD_ADDR_VAR 0 9
58128: PUSH
58129: LD_VAR 0 4
58133: PUSH
58134: LD_VAR 0 8
58138: DIFF
58139: PPUSH
58140: LD_INT 4
58142: PPUSH
58143: CALL 46904 0 2
58147: ST_TO_ADDR
// p := [ ] ;
58148: LD_ADDR_VAR 0 11
58152: PUSH
58153: EMPTY
58154: ST_TO_ADDR
// if sci < 6 and sort > 6 then
58155: LD_VAR 0 8
58159: PUSH
58160: LD_INT 6
58162: LESS
58163: PUSH
58164: LD_VAR 0 9
58168: PUSH
58169: LD_INT 6
58171: GREATER
58172: AND
58173: IFFALSE 58254
// begin for i = 1 to 6 - sci do
58175: LD_ADDR_VAR 0 3
58179: PUSH
58180: DOUBLE
58181: LD_INT 1
58183: DEC
58184: ST_TO_ADDR
58185: LD_INT 6
58187: PUSH
58188: LD_VAR 0 8
58192: MINUS
58193: PUSH
58194: FOR_TO
58195: IFFALSE 58250
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
58197: LD_ADDR_VAR 0 11
58201: PUSH
58202: LD_VAR 0 11
58206: PPUSH
58207: LD_VAR 0 11
58211: PUSH
58212: LD_INT 1
58214: PLUS
58215: PPUSH
58216: LD_VAR 0 9
58220: PUSH
58221: LD_INT 1
58223: ARRAY
58224: PPUSH
58225: CALL_OW 2
58229: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
58230: LD_ADDR_VAR 0 9
58234: PUSH
58235: LD_VAR 0 9
58239: PPUSH
58240: LD_INT 1
58242: PPUSH
58243: CALL_OW 3
58247: ST_TO_ADDR
// end ;
58248: GO 58194
58250: POP
58251: POP
// end else
58252: GO 58274
// if sort then
58254: LD_VAR 0 9
58258: IFFALSE 58274
// p := sort [ 1 ] ;
58260: LD_ADDR_VAR 0 11
58264: PUSH
58265: LD_VAR 0 9
58269: PUSH
58270: LD_INT 1
58272: ARRAY
58273: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
58274: LD_ADDR_VAR 0 2
58278: PUSH
58279: LD_INT 0
58281: PUSH
58282: LD_INT 0
58284: PUSH
58285: LD_INT 0
58287: PUSH
58288: LD_VAR 0 11
58292: PUSH
58293: EMPTY
58294: LIST
58295: LIST
58296: LIST
58297: LIST
58298: ST_TO_ADDR
// exit ;
58299: GO 60520
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
58301: LD_EXP 50
58305: PUSH
58306: LD_EXP 49
58310: PUSH
58311: LD_VAR 0 1
58315: ARRAY
58316: ARRAY
58317: PUSH
58318: LD_EXP 23
58322: PUSH
58323: LD_VAR 0 1
58327: ARRAY
58328: PPUSH
58329: LD_INT 2
58331: PUSH
58332: LD_INT 30
58334: PUSH
58335: LD_INT 6
58337: PUSH
58338: EMPTY
58339: LIST
58340: LIST
58341: PUSH
58342: LD_INT 30
58344: PUSH
58345: LD_INT 7
58347: PUSH
58348: EMPTY
58349: LIST
58350: LIST
58351: PUSH
58352: LD_INT 30
58354: PUSH
58355: LD_INT 8
58357: PUSH
58358: EMPTY
58359: LIST
58360: LIST
58361: PUSH
58362: EMPTY
58363: LIST
58364: LIST
58365: LIST
58366: LIST
58367: PPUSH
58368: CALL_OW 72
58372: AND
58373: PUSH
58374: LD_EXP 23
58378: PUSH
58379: LD_VAR 0 1
58383: ARRAY
58384: PPUSH
58385: LD_INT 30
58387: PUSH
58388: LD_INT 3
58390: PUSH
58391: EMPTY
58392: LIST
58393: LIST
58394: PPUSH
58395: CALL_OW 72
58399: AND
58400: IFFALSE 59134
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
58402: LD_ADDR_EXP 65
58406: PUSH
58407: LD_EXP 65
58411: PPUSH
58412: LD_VAR 0 1
58416: PPUSH
58417: LD_INT 3
58419: PPUSH
58420: CALL_OW 1
58424: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58425: LD_ADDR_VAR 0 2
58429: PUSH
58430: LD_INT 0
58432: PUSH
58433: LD_INT 0
58435: PUSH
58436: LD_INT 0
58438: PUSH
58439: LD_INT 0
58441: PUSH
58442: EMPTY
58443: LIST
58444: LIST
58445: LIST
58446: LIST
58447: ST_TO_ADDR
// if not eng then
58448: LD_VAR 0 6
58452: NOT
58453: IFFALSE 58516
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
58455: LD_ADDR_VAR 0 11
58459: PUSH
58460: LD_VAR 0 4
58464: PPUSH
58465: LD_INT 2
58467: PPUSH
58468: CALL 46904 0 2
58472: PUSH
58473: LD_INT 1
58475: ARRAY
58476: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
58477: LD_ADDR_VAR 0 2
58481: PUSH
58482: LD_VAR 0 2
58486: PPUSH
58487: LD_INT 2
58489: PPUSH
58490: LD_VAR 0 11
58494: PPUSH
58495: CALL_OW 1
58499: ST_TO_ADDR
// tmp := tmp diff p ;
58500: LD_ADDR_VAR 0 4
58504: PUSH
58505: LD_VAR 0 4
58509: PUSH
58510: LD_VAR 0 11
58514: DIFF
58515: ST_TO_ADDR
// end ; if tmp and sci < 6 then
58516: LD_VAR 0 4
58520: PUSH
58521: LD_VAR 0 8
58525: PUSH
58526: LD_INT 6
58528: LESS
58529: AND
58530: IFFALSE 58718
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
58532: LD_ADDR_VAR 0 9
58536: PUSH
58537: LD_VAR 0 4
58541: PUSH
58542: LD_VAR 0 8
58546: PUSH
58547: LD_VAR 0 7
58551: UNION
58552: DIFF
58553: PPUSH
58554: LD_INT 4
58556: PPUSH
58557: CALL 46904 0 2
58561: ST_TO_ADDR
// p := [ ] ;
58562: LD_ADDR_VAR 0 11
58566: PUSH
58567: EMPTY
58568: ST_TO_ADDR
// if sort then
58569: LD_VAR 0 9
58573: IFFALSE 58689
// for i = 1 to 6 - sci do
58575: LD_ADDR_VAR 0 3
58579: PUSH
58580: DOUBLE
58581: LD_INT 1
58583: DEC
58584: ST_TO_ADDR
58585: LD_INT 6
58587: PUSH
58588: LD_VAR 0 8
58592: MINUS
58593: PUSH
58594: FOR_TO
58595: IFFALSE 58687
// begin if i = sort then
58597: LD_VAR 0 3
58601: PUSH
58602: LD_VAR 0 9
58606: EQUAL
58607: IFFALSE 58611
// break ;
58609: GO 58687
// if GetClass ( i ) = 4 then
58611: LD_VAR 0 3
58615: PPUSH
58616: CALL_OW 257
58620: PUSH
58621: LD_INT 4
58623: EQUAL
58624: IFFALSE 58628
// continue ;
58626: GO 58594
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58628: LD_ADDR_VAR 0 11
58632: PUSH
58633: LD_VAR 0 11
58637: PPUSH
58638: LD_VAR 0 11
58642: PUSH
58643: LD_INT 1
58645: PLUS
58646: PPUSH
58647: LD_VAR 0 9
58651: PUSH
58652: LD_VAR 0 3
58656: ARRAY
58657: PPUSH
58658: CALL_OW 2
58662: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58663: LD_ADDR_VAR 0 4
58667: PUSH
58668: LD_VAR 0 4
58672: PUSH
58673: LD_VAR 0 9
58677: PUSH
58678: LD_VAR 0 3
58682: ARRAY
58683: DIFF
58684: ST_TO_ADDR
// end ;
58685: GO 58594
58687: POP
58688: POP
// if p then
58689: LD_VAR 0 11
58693: IFFALSE 58718
// result := Replace ( result , 4 , p ) ;
58695: LD_ADDR_VAR 0 2
58699: PUSH
58700: LD_VAR 0 2
58704: PPUSH
58705: LD_INT 4
58707: PPUSH
58708: LD_VAR 0 11
58712: PPUSH
58713: CALL_OW 1
58717: ST_TO_ADDR
// end ; if tmp and mech < 6 then
58718: LD_VAR 0 4
58722: PUSH
58723: LD_VAR 0 7
58727: PUSH
58728: LD_INT 6
58730: LESS
58731: AND
58732: IFFALSE 58920
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
58734: LD_ADDR_VAR 0 9
58738: PUSH
58739: LD_VAR 0 4
58743: PUSH
58744: LD_VAR 0 8
58748: PUSH
58749: LD_VAR 0 7
58753: UNION
58754: DIFF
58755: PPUSH
58756: LD_INT 3
58758: PPUSH
58759: CALL 46904 0 2
58763: ST_TO_ADDR
// p := [ ] ;
58764: LD_ADDR_VAR 0 11
58768: PUSH
58769: EMPTY
58770: ST_TO_ADDR
// if sort then
58771: LD_VAR 0 9
58775: IFFALSE 58891
// for i = 1 to 6 - mech do
58777: LD_ADDR_VAR 0 3
58781: PUSH
58782: DOUBLE
58783: LD_INT 1
58785: DEC
58786: ST_TO_ADDR
58787: LD_INT 6
58789: PUSH
58790: LD_VAR 0 7
58794: MINUS
58795: PUSH
58796: FOR_TO
58797: IFFALSE 58889
// begin if i = sort then
58799: LD_VAR 0 3
58803: PUSH
58804: LD_VAR 0 9
58808: EQUAL
58809: IFFALSE 58813
// break ;
58811: GO 58889
// if GetClass ( i ) = 3 then
58813: LD_VAR 0 3
58817: PPUSH
58818: CALL_OW 257
58822: PUSH
58823: LD_INT 3
58825: EQUAL
58826: IFFALSE 58830
// continue ;
58828: GO 58796
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58830: LD_ADDR_VAR 0 11
58834: PUSH
58835: LD_VAR 0 11
58839: PPUSH
58840: LD_VAR 0 11
58844: PUSH
58845: LD_INT 1
58847: PLUS
58848: PPUSH
58849: LD_VAR 0 9
58853: PUSH
58854: LD_VAR 0 3
58858: ARRAY
58859: PPUSH
58860: CALL_OW 2
58864: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58865: LD_ADDR_VAR 0 4
58869: PUSH
58870: LD_VAR 0 4
58874: PUSH
58875: LD_VAR 0 9
58879: PUSH
58880: LD_VAR 0 3
58884: ARRAY
58885: DIFF
58886: ST_TO_ADDR
// end ;
58887: GO 58796
58889: POP
58890: POP
// if p then
58891: LD_VAR 0 11
58895: IFFALSE 58920
// result := Replace ( result , 3 , p ) ;
58897: LD_ADDR_VAR 0 2
58901: PUSH
58902: LD_VAR 0 2
58906: PPUSH
58907: LD_INT 3
58909: PPUSH
58910: LD_VAR 0 11
58914: PPUSH
58915: CALL_OW 1
58919: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
58920: LD_VAR 0 4
58924: PUSH
58925: LD_INT 6
58927: GREATER
58928: PUSH
58929: LD_VAR 0 6
58933: PUSH
58934: LD_INT 6
58936: LESS
58937: AND
58938: IFFALSE 59132
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
58940: LD_ADDR_VAR 0 9
58944: PUSH
58945: LD_VAR 0 4
58949: PUSH
58950: LD_VAR 0 8
58954: PUSH
58955: LD_VAR 0 7
58959: UNION
58960: PUSH
58961: LD_VAR 0 6
58965: UNION
58966: DIFF
58967: PPUSH
58968: LD_INT 2
58970: PPUSH
58971: CALL 46904 0 2
58975: ST_TO_ADDR
// p := [ ] ;
58976: LD_ADDR_VAR 0 11
58980: PUSH
58981: EMPTY
58982: ST_TO_ADDR
// if sort then
58983: LD_VAR 0 9
58987: IFFALSE 59103
// for i = 1 to 6 - eng do
58989: LD_ADDR_VAR 0 3
58993: PUSH
58994: DOUBLE
58995: LD_INT 1
58997: DEC
58998: ST_TO_ADDR
58999: LD_INT 6
59001: PUSH
59002: LD_VAR 0 6
59006: MINUS
59007: PUSH
59008: FOR_TO
59009: IFFALSE 59101
// begin if i = sort then
59011: LD_VAR 0 3
59015: PUSH
59016: LD_VAR 0 9
59020: EQUAL
59021: IFFALSE 59025
// break ;
59023: GO 59101
// if GetClass ( i ) = 2 then
59025: LD_VAR 0 3
59029: PPUSH
59030: CALL_OW 257
59034: PUSH
59035: LD_INT 2
59037: EQUAL
59038: IFFALSE 59042
// continue ;
59040: GO 59008
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59042: LD_ADDR_VAR 0 11
59046: PUSH
59047: LD_VAR 0 11
59051: PPUSH
59052: LD_VAR 0 11
59056: PUSH
59057: LD_INT 1
59059: PLUS
59060: PPUSH
59061: LD_VAR 0 9
59065: PUSH
59066: LD_VAR 0 3
59070: ARRAY
59071: PPUSH
59072: CALL_OW 2
59076: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59077: LD_ADDR_VAR 0 4
59081: PUSH
59082: LD_VAR 0 4
59086: PUSH
59087: LD_VAR 0 9
59091: PUSH
59092: LD_VAR 0 3
59096: ARRAY
59097: DIFF
59098: ST_TO_ADDR
// end ;
59099: GO 59008
59101: POP
59102: POP
// if p then
59103: LD_VAR 0 11
59107: IFFALSE 59132
// result := Replace ( result , 2 , p ) ;
59109: LD_ADDR_VAR 0 2
59113: PUSH
59114: LD_VAR 0 2
59118: PPUSH
59119: LD_INT 2
59121: PPUSH
59122: LD_VAR 0 11
59126: PPUSH
59127: CALL_OW 1
59131: ST_TO_ADDR
// end ; exit ;
59132: GO 60520
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
59134: LD_EXP 50
59138: PUSH
59139: LD_EXP 49
59143: PUSH
59144: LD_VAR 0 1
59148: ARRAY
59149: ARRAY
59150: NOT
59151: PUSH
59152: LD_EXP 23
59156: PUSH
59157: LD_VAR 0 1
59161: ARRAY
59162: PPUSH
59163: LD_INT 30
59165: PUSH
59166: LD_INT 3
59168: PUSH
59169: EMPTY
59170: LIST
59171: LIST
59172: PPUSH
59173: CALL_OW 72
59177: AND
59178: PUSH
59179: LD_EXP 28
59183: PUSH
59184: LD_VAR 0 1
59188: ARRAY
59189: AND
59190: IFFALSE 59798
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
59192: LD_ADDR_EXP 65
59196: PUSH
59197: LD_EXP 65
59201: PPUSH
59202: LD_VAR 0 1
59206: PPUSH
59207: LD_INT 5
59209: PPUSH
59210: CALL_OW 1
59214: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
59215: LD_ADDR_VAR 0 2
59219: PUSH
59220: LD_INT 0
59222: PUSH
59223: LD_INT 0
59225: PUSH
59226: LD_INT 0
59228: PUSH
59229: LD_INT 0
59231: PUSH
59232: EMPTY
59233: LIST
59234: LIST
59235: LIST
59236: LIST
59237: ST_TO_ADDR
// if sci > 1 then
59238: LD_VAR 0 8
59242: PUSH
59243: LD_INT 1
59245: GREATER
59246: IFFALSE 59274
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
59248: LD_ADDR_VAR 0 4
59252: PUSH
59253: LD_VAR 0 4
59257: PUSH
59258: LD_VAR 0 8
59262: PUSH
59263: LD_VAR 0 8
59267: PUSH
59268: LD_INT 1
59270: ARRAY
59271: DIFF
59272: DIFF
59273: ST_TO_ADDR
// if tmp and not sci then
59274: LD_VAR 0 4
59278: PUSH
59279: LD_VAR 0 8
59283: NOT
59284: AND
59285: IFFALSE 59354
// begin sort := SortBySkill ( tmp , 4 ) ;
59287: LD_ADDR_VAR 0 9
59291: PUSH
59292: LD_VAR 0 4
59296: PPUSH
59297: LD_INT 4
59299: PPUSH
59300: CALL 46904 0 2
59304: ST_TO_ADDR
// if sort then
59305: LD_VAR 0 9
59309: IFFALSE 59325
// p := sort [ 1 ] ;
59311: LD_ADDR_VAR 0 11
59315: PUSH
59316: LD_VAR 0 9
59320: PUSH
59321: LD_INT 1
59323: ARRAY
59324: ST_TO_ADDR
// if p then
59325: LD_VAR 0 11
59329: IFFALSE 59354
// result := Replace ( result , 4 , p ) ;
59331: LD_ADDR_VAR 0 2
59335: PUSH
59336: LD_VAR 0 2
59340: PPUSH
59341: LD_INT 4
59343: PPUSH
59344: LD_VAR 0 11
59348: PPUSH
59349: CALL_OW 1
59353: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
59354: LD_ADDR_VAR 0 4
59358: PUSH
59359: LD_VAR 0 4
59363: PUSH
59364: LD_VAR 0 7
59368: DIFF
59369: ST_TO_ADDR
// if tmp and mech < 6 then
59370: LD_VAR 0 4
59374: PUSH
59375: LD_VAR 0 7
59379: PUSH
59380: LD_INT 6
59382: LESS
59383: AND
59384: IFFALSE 59572
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
59386: LD_ADDR_VAR 0 9
59390: PUSH
59391: LD_VAR 0 4
59395: PUSH
59396: LD_VAR 0 8
59400: PUSH
59401: LD_VAR 0 7
59405: UNION
59406: DIFF
59407: PPUSH
59408: LD_INT 3
59410: PPUSH
59411: CALL 46904 0 2
59415: ST_TO_ADDR
// p := [ ] ;
59416: LD_ADDR_VAR 0 11
59420: PUSH
59421: EMPTY
59422: ST_TO_ADDR
// if sort then
59423: LD_VAR 0 9
59427: IFFALSE 59543
// for i = 1 to 6 - mech do
59429: LD_ADDR_VAR 0 3
59433: PUSH
59434: DOUBLE
59435: LD_INT 1
59437: DEC
59438: ST_TO_ADDR
59439: LD_INT 6
59441: PUSH
59442: LD_VAR 0 7
59446: MINUS
59447: PUSH
59448: FOR_TO
59449: IFFALSE 59541
// begin if i = sort then
59451: LD_VAR 0 3
59455: PUSH
59456: LD_VAR 0 9
59460: EQUAL
59461: IFFALSE 59465
// break ;
59463: GO 59541
// if GetClass ( i ) = 3 then
59465: LD_VAR 0 3
59469: PPUSH
59470: CALL_OW 257
59474: PUSH
59475: LD_INT 3
59477: EQUAL
59478: IFFALSE 59482
// continue ;
59480: GO 59448
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59482: LD_ADDR_VAR 0 11
59486: PUSH
59487: LD_VAR 0 11
59491: PPUSH
59492: LD_VAR 0 11
59496: PUSH
59497: LD_INT 1
59499: PLUS
59500: PPUSH
59501: LD_VAR 0 9
59505: PUSH
59506: LD_VAR 0 3
59510: ARRAY
59511: PPUSH
59512: CALL_OW 2
59516: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59517: LD_ADDR_VAR 0 4
59521: PUSH
59522: LD_VAR 0 4
59526: PUSH
59527: LD_VAR 0 9
59531: PUSH
59532: LD_VAR 0 3
59536: ARRAY
59537: DIFF
59538: ST_TO_ADDR
// end ;
59539: GO 59448
59541: POP
59542: POP
// if p then
59543: LD_VAR 0 11
59547: IFFALSE 59572
// result := Replace ( result , 3 , p ) ;
59549: LD_ADDR_VAR 0 2
59553: PUSH
59554: LD_VAR 0 2
59558: PPUSH
59559: LD_INT 3
59561: PPUSH
59562: LD_VAR 0 11
59566: PPUSH
59567: CALL_OW 1
59571: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
59572: LD_ADDR_VAR 0 4
59576: PUSH
59577: LD_VAR 0 4
59581: PUSH
59582: LD_VAR 0 6
59586: DIFF
59587: ST_TO_ADDR
// if tmp and eng < 6 then
59588: LD_VAR 0 4
59592: PUSH
59593: LD_VAR 0 6
59597: PUSH
59598: LD_INT 6
59600: LESS
59601: AND
59602: IFFALSE 59796
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
59604: LD_ADDR_VAR 0 9
59608: PUSH
59609: LD_VAR 0 4
59613: PUSH
59614: LD_VAR 0 8
59618: PUSH
59619: LD_VAR 0 7
59623: UNION
59624: PUSH
59625: LD_VAR 0 6
59629: UNION
59630: DIFF
59631: PPUSH
59632: LD_INT 2
59634: PPUSH
59635: CALL 46904 0 2
59639: ST_TO_ADDR
// p := [ ] ;
59640: LD_ADDR_VAR 0 11
59644: PUSH
59645: EMPTY
59646: ST_TO_ADDR
// if sort then
59647: LD_VAR 0 9
59651: IFFALSE 59767
// for i = 1 to 6 - eng do
59653: LD_ADDR_VAR 0 3
59657: PUSH
59658: DOUBLE
59659: LD_INT 1
59661: DEC
59662: ST_TO_ADDR
59663: LD_INT 6
59665: PUSH
59666: LD_VAR 0 6
59670: MINUS
59671: PUSH
59672: FOR_TO
59673: IFFALSE 59765
// begin if i = sort then
59675: LD_VAR 0 3
59679: PUSH
59680: LD_VAR 0 9
59684: EQUAL
59685: IFFALSE 59689
// break ;
59687: GO 59765
// if GetClass ( i ) = 2 then
59689: LD_VAR 0 3
59693: PPUSH
59694: CALL_OW 257
59698: PUSH
59699: LD_INT 2
59701: EQUAL
59702: IFFALSE 59706
// continue ;
59704: GO 59672
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59706: LD_ADDR_VAR 0 11
59710: PUSH
59711: LD_VAR 0 11
59715: PPUSH
59716: LD_VAR 0 11
59720: PUSH
59721: LD_INT 1
59723: PLUS
59724: PPUSH
59725: LD_VAR 0 9
59729: PUSH
59730: LD_VAR 0 3
59734: ARRAY
59735: PPUSH
59736: CALL_OW 2
59740: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59741: LD_ADDR_VAR 0 4
59745: PUSH
59746: LD_VAR 0 4
59750: PUSH
59751: LD_VAR 0 9
59755: PUSH
59756: LD_VAR 0 3
59760: ARRAY
59761: DIFF
59762: ST_TO_ADDR
// end ;
59763: GO 59672
59765: POP
59766: POP
// if p then
59767: LD_VAR 0 11
59771: IFFALSE 59796
// result := Replace ( result , 2 , p ) ;
59773: LD_ADDR_VAR 0 2
59777: PUSH
59778: LD_VAR 0 2
59782: PPUSH
59783: LD_INT 2
59785: PPUSH
59786: LD_VAR 0 11
59790: PPUSH
59791: CALL_OW 1
59795: ST_TO_ADDR
// end ; exit ;
59796: GO 60520
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
59798: LD_EXP 50
59802: PUSH
59803: LD_EXP 49
59807: PUSH
59808: LD_VAR 0 1
59812: ARRAY
59813: ARRAY
59814: NOT
59815: PUSH
59816: LD_EXP 23
59820: PUSH
59821: LD_VAR 0 1
59825: ARRAY
59826: PPUSH
59827: LD_INT 30
59829: PUSH
59830: LD_INT 3
59832: PUSH
59833: EMPTY
59834: LIST
59835: LIST
59836: PPUSH
59837: CALL_OW 72
59841: AND
59842: PUSH
59843: LD_EXP 28
59847: PUSH
59848: LD_VAR 0 1
59852: ARRAY
59853: NOT
59854: AND
59855: IFFALSE 60520
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
59857: LD_ADDR_EXP 65
59861: PUSH
59862: LD_EXP 65
59866: PPUSH
59867: LD_VAR 0 1
59871: PPUSH
59872: LD_INT 6
59874: PPUSH
59875: CALL_OW 1
59879: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
59880: LD_ADDR_VAR 0 2
59884: PUSH
59885: LD_INT 0
59887: PUSH
59888: LD_INT 0
59890: PUSH
59891: LD_INT 0
59893: PUSH
59894: LD_INT 0
59896: PUSH
59897: EMPTY
59898: LIST
59899: LIST
59900: LIST
59901: LIST
59902: ST_TO_ADDR
// if sci >= 1 then
59903: LD_VAR 0 8
59907: PUSH
59908: LD_INT 1
59910: GREATEREQUAL
59911: IFFALSE 59933
// tmp := tmp diff sci [ 1 ] ;
59913: LD_ADDR_VAR 0 4
59917: PUSH
59918: LD_VAR 0 4
59922: PUSH
59923: LD_VAR 0 8
59927: PUSH
59928: LD_INT 1
59930: ARRAY
59931: DIFF
59932: ST_TO_ADDR
// if tmp and not sci then
59933: LD_VAR 0 4
59937: PUSH
59938: LD_VAR 0 8
59942: NOT
59943: AND
59944: IFFALSE 60013
// begin sort := SortBySkill ( tmp , 4 ) ;
59946: LD_ADDR_VAR 0 9
59950: PUSH
59951: LD_VAR 0 4
59955: PPUSH
59956: LD_INT 4
59958: PPUSH
59959: CALL 46904 0 2
59963: ST_TO_ADDR
// if sort then
59964: LD_VAR 0 9
59968: IFFALSE 59984
// p := sort [ 1 ] ;
59970: LD_ADDR_VAR 0 11
59974: PUSH
59975: LD_VAR 0 9
59979: PUSH
59980: LD_INT 1
59982: ARRAY
59983: ST_TO_ADDR
// if p then
59984: LD_VAR 0 11
59988: IFFALSE 60013
// result := Replace ( result , 4 , p ) ;
59990: LD_ADDR_VAR 0 2
59994: PUSH
59995: LD_VAR 0 2
59999: PPUSH
60000: LD_INT 4
60002: PPUSH
60003: LD_VAR 0 11
60007: PPUSH
60008: CALL_OW 1
60012: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
60013: LD_ADDR_VAR 0 4
60017: PUSH
60018: LD_VAR 0 4
60022: PUSH
60023: LD_VAR 0 7
60027: DIFF
60028: ST_TO_ADDR
// if tmp and mech < 6 then
60029: LD_VAR 0 4
60033: PUSH
60034: LD_VAR 0 7
60038: PUSH
60039: LD_INT 6
60041: LESS
60042: AND
60043: IFFALSE 60225
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
60045: LD_ADDR_VAR 0 9
60049: PUSH
60050: LD_VAR 0 4
60054: PUSH
60055: LD_VAR 0 7
60059: DIFF
60060: PPUSH
60061: LD_INT 3
60063: PPUSH
60064: CALL 46904 0 2
60068: ST_TO_ADDR
// p := [ ] ;
60069: LD_ADDR_VAR 0 11
60073: PUSH
60074: EMPTY
60075: ST_TO_ADDR
// if sort then
60076: LD_VAR 0 9
60080: IFFALSE 60196
// for i = 1 to 6 - mech do
60082: LD_ADDR_VAR 0 3
60086: PUSH
60087: DOUBLE
60088: LD_INT 1
60090: DEC
60091: ST_TO_ADDR
60092: LD_INT 6
60094: PUSH
60095: LD_VAR 0 7
60099: MINUS
60100: PUSH
60101: FOR_TO
60102: IFFALSE 60194
// begin if i = sort then
60104: LD_VAR 0 3
60108: PUSH
60109: LD_VAR 0 9
60113: EQUAL
60114: IFFALSE 60118
// break ;
60116: GO 60194
// if GetClass ( i ) = 3 then
60118: LD_VAR 0 3
60122: PPUSH
60123: CALL_OW 257
60127: PUSH
60128: LD_INT 3
60130: EQUAL
60131: IFFALSE 60135
// continue ;
60133: GO 60101
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60135: LD_ADDR_VAR 0 11
60139: PUSH
60140: LD_VAR 0 11
60144: PPUSH
60145: LD_VAR 0 11
60149: PUSH
60150: LD_INT 1
60152: PLUS
60153: PPUSH
60154: LD_VAR 0 9
60158: PUSH
60159: LD_VAR 0 3
60163: ARRAY
60164: PPUSH
60165: CALL_OW 2
60169: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60170: LD_ADDR_VAR 0 4
60174: PUSH
60175: LD_VAR 0 4
60179: PUSH
60180: LD_VAR 0 9
60184: PUSH
60185: LD_VAR 0 3
60189: ARRAY
60190: DIFF
60191: ST_TO_ADDR
// end ;
60192: GO 60101
60194: POP
60195: POP
// if p then
60196: LD_VAR 0 11
60200: IFFALSE 60225
// result := Replace ( result , 3 , p ) ;
60202: LD_ADDR_VAR 0 2
60206: PUSH
60207: LD_VAR 0 2
60211: PPUSH
60212: LD_INT 3
60214: PPUSH
60215: LD_VAR 0 11
60219: PPUSH
60220: CALL_OW 1
60224: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
60225: LD_ADDR_VAR 0 4
60229: PUSH
60230: LD_VAR 0 4
60234: PUSH
60235: LD_VAR 0 6
60239: DIFF
60240: ST_TO_ADDR
// if tmp and eng < 4 then
60241: LD_VAR 0 4
60245: PUSH
60246: LD_VAR 0 6
60250: PUSH
60251: LD_INT 4
60253: LESS
60254: AND
60255: IFFALSE 60445
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
60257: LD_ADDR_VAR 0 9
60261: PUSH
60262: LD_VAR 0 4
60266: PUSH
60267: LD_VAR 0 7
60271: PUSH
60272: LD_VAR 0 6
60276: UNION
60277: DIFF
60278: PPUSH
60279: LD_INT 2
60281: PPUSH
60282: CALL 46904 0 2
60286: ST_TO_ADDR
// p := [ ] ;
60287: LD_ADDR_VAR 0 11
60291: PUSH
60292: EMPTY
60293: ST_TO_ADDR
// if sort then
60294: LD_VAR 0 9
60298: IFFALSE 60414
// for i = 1 to 4 - eng do
60300: LD_ADDR_VAR 0 3
60304: PUSH
60305: DOUBLE
60306: LD_INT 1
60308: DEC
60309: ST_TO_ADDR
60310: LD_INT 4
60312: PUSH
60313: LD_VAR 0 6
60317: MINUS
60318: PUSH
60319: FOR_TO
60320: IFFALSE 60412
// begin if i = sort then
60322: LD_VAR 0 3
60326: PUSH
60327: LD_VAR 0 9
60331: EQUAL
60332: IFFALSE 60336
// break ;
60334: GO 60412
// if GetClass ( i ) = 2 then
60336: LD_VAR 0 3
60340: PPUSH
60341: CALL_OW 257
60345: PUSH
60346: LD_INT 2
60348: EQUAL
60349: IFFALSE 60353
// continue ;
60351: GO 60319
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60353: LD_ADDR_VAR 0 11
60357: PUSH
60358: LD_VAR 0 11
60362: PPUSH
60363: LD_VAR 0 11
60367: PUSH
60368: LD_INT 1
60370: PLUS
60371: PPUSH
60372: LD_VAR 0 9
60376: PUSH
60377: LD_VAR 0 3
60381: ARRAY
60382: PPUSH
60383: CALL_OW 2
60387: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60388: LD_ADDR_VAR 0 4
60392: PUSH
60393: LD_VAR 0 4
60397: PUSH
60398: LD_VAR 0 9
60402: PUSH
60403: LD_VAR 0 3
60407: ARRAY
60408: DIFF
60409: ST_TO_ADDR
// end ;
60410: GO 60319
60412: POP
60413: POP
// if p then
60414: LD_VAR 0 11
60418: IFFALSE 60443
// result := Replace ( result , 2 , p ) ;
60420: LD_ADDR_VAR 0 2
60424: PUSH
60425: LD_VAR 0 2
60429: PPUSH
60430: LD_INT 2
60432: PPUSH
60433: LD_VAR 0 11
60437: PPUSH
60438: CALL_OW 1
60442: ST_TO_ADDR
// end else
60443: GO 60489
// for i = eng downto 5 do
60445: LD_ADDR_VAR 0 3
60449: PUSH
60450: DOUBLE
60451: LD_VAR 0 6
60455: INC
60456: ST_TO_ADDR
60457: LD_INT 5
60459: PUSH
60460: FOR_DOWNTO
60461: IFFALSE 60487
// tmp := tmp union eng [ i ] ;
60463: LD_ADDR_VAR 0 4
60467: PUSH
60468: LD_VAR 0 4
60472: PUSH
60473: LD_VAR 0 6
60477: PUSH
60478: LD_VAR 0 3
60482: ARRAY
60483: UNION
60484: ST_TO_ADDR
60485: GO 60460
60487: POP
60488: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
60489: LD_ADDR_VAR 0 2
60493: PUSH
60494: LD_VAR 0 2
60498: PPUSH
60499: LD_INT 1
60501: PPUSH
60502: LD_VAR 0 4
60506: PUSH
60507: LD_VAR 0 5
60511: DIFF
60512: PPUSH
60513: CALL_OW 1
60517: ST_TO_ADDR
// exit ;
60518: GO 60520
// end ; end ;
60520: LD_VAR 0 2
60524: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
60525: LD_INT 0
60527: PPUSH
60528: PPUSH
60529: PPUSH
// if not mc_bases then
60530: LD_EXP 23
60534: NOT
60535: IFFALSE 60539
// exit ;
60537: GO 60681
// for i = 1 to mc_bases do
60539: LD_ADDR_VAR 0 2
60543: PUSH
60544: DOUBLE
60545: LD_INT 1
60547: DEC
60548: ST_TO_ADDR
60549: LD_EXP 23
60553: PUSH
60554: FOR_TO
60555: IFFALSE 60672
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
60557: LD_ADDR_VAR 0 3
60561: PUSH
60562: LD_EXP 23
60566: PUSH
60567: LD_VAR 0 2
60571: ARRAY
60572: PPUSH
60573: LD_INT 21
60575: PUSH
60576: LD_INT 3
60578: PUSH
60579: EMPTY
60580: LIST
60581: LIST
60582: PUSH
60583: LD_INT 3
60585: PUSH
60586: LD_INT 2
60588: PUSH
60589: LD_INT 30
60591: PUSH
60592: LD_INT 29
60594: PUSH
60595: EMPTY
60596: LIST
60597: LIST
60598: PUSH
60599: LD_INT 30
60601: PUSH
60602: LD_INT 30
60604: PUSH
60605: EMPTY
60606: LIST
60607: LIST
60608: PUSH
60609: EMPTY
60610: LIST
60611: LIST
60612: LIST
60613: PUSH
60614: EMPTY
60615: LIST
60616: LIST
60617: PUSH
60618: LD_INT 3
60620: PUSH
60621: LD_INT 24
60623: PUSH
60624: LD_INT 1000
60626: PUSH
60627: EMPTY
60628: LIST
60629: LIST
60630: PUSH
60631: EMPTY
60632: LIST
60633: LIST
60634: PUSH
60635: EMPTY
60636: LIST
60637: LIST
60638: LIST
60639: PPUSH
60640: CALL_OW 72
60644: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
60645: LD_ADDR_EXP 24
60649: PUSH
60650: LD_EXP 24
60654: PPUSH
60655: LD_VAR 0 2
60659: PPUSH
60660: LD_VAR 0 3
60664: PPUSH
60665: CALL_OW 1
60669: ST_TO_ADDR
// end ;
60670: GO 60554
60672: POP
60673: POP
// RaiseSailEvent ( 101 ) ;
60674: LD_INT 101
60676: PPUSH
60677: CALL_OW 427
// end ;
60681: LD_VAR 0 1
60685: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
60686: LD_INT 0
60688: PPUSH
60689: PPUSH
60690: PPUSH
60691: PPUSH
60692: PPUSH
60693: PPUSH
60694: PPUSH
// if not mc_bases then
60695: LD_EXP 23
60699: NOT
60700: IFFALSE 60704
// exit ;
60702: GO 61266
// for i = 1 to mc_bases do
60704: LD_ADDR_VAR 0 2
60708: PUSH
60709: DOUBLE
60710: LD_INT 1
60712: DEC
60713: ST_TO_ADDR
60714: LD_EXP 23
60718: PUSH
60719: FOR_TO
60720: IFFALSE 61257
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
60722: LD_ADDR_VAR 0 5
60726: PUSH
60727: LD_EXP 23
60731: PUSH
60732: LD_VAR 0 2
60736: ARRAY
60737: PUSH
60738: LD_EXP 52
60742: PUSH
60743: LD_VAR 0 2
60747: ARRAY
60748: UNION
60749: PPUSH
60750: LD_INT 21
60752: PUSH
60753: LD_INT 1
60755: PUSH
60756: EMPTY
60757: LIST
60758: LIST
60759: PUSH
60760: LD_INT 1
60762: PUSH
60763: LD_INT 3
60765: PUSH
60766: LD_INT 54
60768: PUSH
60769: EMPTY
60770: LIST
60771: PUSH
60772: EMPTY
60773: LIST
60774: LIST
60775: PUSH
60776: LD_INT 3
60778: PUSH
60779: LD_INT 24
60781: PUSH
60782: LD_INT 1000
60784: PUSH
60785: EMPTY
60786: LIST
60787: LIST
60788: PUSH
60789: EMPTY
60790: LIST
60791: LIST
60792: PUSH
60793: EMPTY
60794: LIST
60795: LIST
60796: LIST
60797: PUSH
60798: EMPTY
60799: LIST
60800: LIST
60801: PPUSH
60802: CALL_OW 72
60806: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
60807: LD_ADDR_VAR 0 6
60811: PUSH
60812: LD_EXP 23
60816: PUSH
60817: LD_VAR 0 2
60821: ARRAY
60822: PPUSH
60823: LD_INT 21
60825: PUSH
60826: LD_INT 1
60828: PUSH
60829: EMPTY
60830: LIST
60831: LIST
60832: PUSH
60833: LD_INT 1
60835: PUSH
60836: LD_INT 3
60838: PUSH
60839: LD_INT 54
60841: PUSH
60842: EMPTY
60843: LIST
60844: PUSH
60845: EMPTY
60846: LIST
60847: LIST
60848: PUSH
60849: LD_INT 3
60851: PUSH
60852: LD_INT 24
60854: PUSH
60855: LD_INT 250
60857: PUSH
60858: EMPTY
60859: LIST
60860: LIST
60861: PUSH
60862: EMPTY
60863: LIST
60864: LIST
60865: PUSH
60866: EMPTY
60867: LIST
60868: LIST
60869: LIST
60870: PUSH
60871: EMPTY
60872: LIST
60873: LIST
60874: PPUSH
60875: CALL_OW 72
60879: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
60880: LD_ADDR_VAR 0 7
60884: PUSH
60885: LD_VAR 0 5
60889: PUSH
60890: LD_VAR 0 6
60894: DIFF
60895: ST_TO_ADDR
// if not need_heal_1 then
60896: LD_VAR 0 6
60900: NOT
60901: IFFALSE 60934
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
60903: LD_ADDR_EXP 26
60907: PUSH
60908: LD_EXP 26
60912: PPUSH
60913: LD_VAR 0 2
60917: PUSH
60918: LD_INT 1
60920: PUSH
60921: EMPTY
60922: LIST
60923: LIST
60924: PPUSH
60925: EMPTY
60926: PPUSH
60927: CALL 16156 0 3
60931: ST_TO_ADDR
60932: GO 61004
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
60934: LD_ADDR_EXP 26
60938: PUSH
60939: LD_EXP 26
60943: PPUSH
60944: LD_VAR 0 2
60948: PUSH
60949: LD_INT 1
60951: PUSH
60952: EMPTY
60953: LIST
60954: LIST
60955: PPUSH
60956: LD_EXP 26
60960: PUSH
60961: LD_VAR 0 2
60965: ARRAY
60966: PUSH
60967: LD_INT 1
60969: ARRAY
60970: PPUSH
60971: LD_INT 3
60973: PUSH
60974: LD_INT 24
60976: PUSH
60977: LD_INT 1000
60979: PUSH
60980: EMPTY
60981: LIST
60982: LIST
60983: PUSH
60984: EMPTY
60985: LIST
60986: LIST
60987: PPUSH
60988: CALL_OW 72
60992: PUSH
60993: LD_VAR 0 6
60997: UNION
60998: PPUSH
60999: CALL 16156 0 3
61003: ST_TO_ADDR
// if not need_heal_2 then
61004: LD_VAR 0 7
61008: NOT
61009: IFFALSE 61042
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
61011: LD_ADDR_EXP 26
61015: PUSH
61016: LD_EXP 26
61020: PPUSH
61021: LD_VAR 0 2
61025: PUSH
61026: LD_INT 2
61028: PUSH
61029: EMPTY
61030: LIST
61031: LIST
61032: PPUSH
61033: EMPTY
61034: PPUSH
61035: CALL 16156 0 3
61039: ST_TO_ADDR
61040: GO 61074
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
61042: LD_ADDR_EXP 26
61046: PUSH
61047: LD_EXP 26
61051: PPUSH
61052: LD_VAR 0 2
61056: PUSH
61057: LD_INT 2
61059: PUSH
61060: EMPTY
61061: LIST
61062: LIST
61063: PPUSH
61064: LD_VAR 0 7
61068: PPUSH
61069: CALL 16156 0 3
61073: ST_TO_ADDR
// if need_heal_2 then
61074: LD_VAR 0 7
61078: IFFALSE 61239
// for j in need_heal_2 do
61080: LD_ADDR_VAR 0 3
61084: PUSH
61085: LD_VAR 0 7
61089: PUSH
61090: FOR_IN
61091: IFFALSE 61237
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61093: LD_ADDR_VAR 0 5
61097: PUSH
61098: LD_EXP 23
61102: PUSH
61103: LD_VAR 0 2
61107: ARRAY
61108: PPUSH
61109: LD_INT 2
61111: PUSH
61112: LD_INT 30
61114: PUSH
61115: LD_INT 6
61117: PUSH
61118: EMPTY
61119: LIST
61120: LIST
61121: PUSH
61122: LD_INT 30
61124: PUSH
61125: LD_INT 7
61127: PUSH
61128: EMPTY
61129: LIST
61130: LIST
61131: PUSH
61132: LD_INT 30
61134: PUSH
61135: LD_INT 8
61137: PUSH
61138: EMPTY
61139: LIST
61140: LIST
61141: PUSH
61142: LD_INT 30
61144: PUSH
61145: LD_INT 0
61147: PUSH
61148: EMPTY
61149: LIST
61150: LIST
61151: PUSH
61152: LD_INT 30
61154: PUSH
61155: LD_INT 1
61157: PUSH
61158: EMPTY
61159: LIST
61160: LIST
61161: PUSH
61162: EMPTY
61163: LIST
61164: LIST
61165: LIST
61166: LIST
61167: LIST
61168: LIST
61169: PPUSH
61170: CALL_OW 72
61174: ST_TO_ADDR
// if tmp then
61175: LD_VAR 0 5
61179: IFFALSE 61235
// begin k := NearestUnitToUnit ( tmp , j ) ;
61181: LD_ADDR_VAR 0 4
61185: PUSH
61186: LD_VAR 0 5
61190: PPUSH
61191: LD_VAR 0 3
61195: PPUSH
61196: CALL_OW 74
61200: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
61201: LD_VAR 0 3
61205: PPUSH
61206: LD_VAR 0 4
61210: PPUSH
61211: CALL_OW 296
61215: PUSH
61216: LD_INT 5
61218: GREATER
61219: IFFALSE 61235
// ComMoveToNearbyEntrance ( j , k ) ;
61221: LD_VAR 0 3
61225: PPUSH
61226: LD_VAR 0 4
61230: PPUSH
61231: CALL 49272 0 2
// end ; end ;
61235: GO 61090
61237: POP
61238: POP
// if not need_heal_1 and not need_heal_2 then
61239: LD_VAR 0 6
61243: NOT
61244: PUSH
61245: LD_VAR 0 7
61249: NOT
61250: AND
61251: IFFALSE 61255
// continue ;
61253: GO 60719
// end ;
61255: GO 60719
61257: POP
61258: POP
// RaiseSailEvent ( 102 ) ;
61259: LD_INT 102
61261: PPUSH
61262: CALL_OW 427
// end ;
61266: LD_VAR 0 1
61270: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
61271: LD_INT 0
61273: PPUSH
61274: PPUSH
61275: PPUSH
61276: PPUSH
61277: PPUSH
61278: PPUSH
61279: PPUSH
61280: PPUSH
// if not mc_bases then
61281: LD_EXP 23
61285: NOT
61286: IFFALSE 61290
// exit ;
61288: GO 62169
// for i = 1 to mc_bases do
61290: LD_ADDR_VAR 0 2
61294: PUSH
61295: DOUBLE
61296: LD_INT 1
61298: DEC
61299: ST_TO_ADDR
61300: LD_EXP 23
61304: PUSH
61305: FOR_TO
61306: IFFALSE 62167
// begin if not mc_building_need_repair [ i ] then
61308: LD_EXP 24
61312: PUSH
61313: LD_VAR 0 2
61317: ARRAY
61318: NOT
61319: IFFALSE 61504
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
61321: LD_ADDR_VAR 0 6
61325: PUSH
61326: LD_EXP 42
61330: PUSH
61331: LD_VAR 0 2
61335: ARRAY
61336: PPUSH
61337: LD_INT 3
61339: PUSH
61340: LD_INT 24
61342: PUSH
61343: LD_INT 1000
61345: PUSH
61346: EMPTY
61347: LIST
61348: LIST
61349: PUSH
61350: EMPTY
61351: LIST
61352: LIST
61353: PUSH
61354: LD_INT 2
61356: PUSH
61357: LD_INT 34
61359: PUSH
61360: LD_INT 13
61362: PUSH
61363: EMPTY
61364: LIST
61365: LIST
61366: PUSH
61367: LD_INT 34
61369: PUSH
61370: LD_INT 52
61372: PUSH
61373: EMPTY
61374: LIST
61375: LIST
61376: PUSH
61377: LD_INT 34
61379: PUSH
61380: LD_INT 88
61382: PUSH
61383: EMPTY
61384: LIST
61385: LIST
61386: PUSH
61387: EMPTY
61388: LIST
61389: LIST
61390: LIST
61391: LIST
61392: PUSH
61393: EMPTY
61394: LIST
61395: LIST
61396: PPUSH
61397: CALL_OW 72
61401: ST_TO_ADDR
// if cranes then
61402: LD_VAR 0 6
61406: IFFALSE 61468
// for j in cranes do
61408: LD_ADDR_VAR 0 3
61412: PUSH
61413: LD_VAR 0 6
61417: PUSH
61418: FOR_IN
61419: IFFALSE 61466
// if not IsInArea ( j , mc_parking [ i ] ) then
61421: LD_VAR 0 3
61425: PPUSH
61426: LD_EXP 47
61430: PUSH
61431: LD_VAR 0 2
61435: ARRAY
61436: PPUSH
61437: CALL_OW 308
61441: NOT
61442: IFFALSE 61464
// ComMoveToArea ( j , mc_parking [ i ] ) ;
61444: LD_VAR 0 3
61448: PPUSH
61449: LD_EXP 47
61453: PUSH
61454: LD_VAR 0 2
61458: ARRAY
61459: PPUSH
61460: CALL_OW 113
61464: GO 61418
61466: POP
61467: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
61468: LD_ADDR_EXP 25
61472: PUSH
61473: LD_EXP 25
61477: PPUSH
61478: LD_VAR 0 2
61482: PPUSH
61483: EMPTY
61484: PPUSH
61485: CALL_OW 1
61489: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
61490: LD_VAR 0 2
61494: PPUSH
61495: LD_INT 101
61497: PPUSH
61498: CALL 56358 0 2
// continue ;
61502: GO 61305
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
61504: LD_ADDR_EXP 29
61508: PUSH
61509: LD_EXP 29
61513: PPUSH
61514: LD_VAR 0 2
61518: PPUSH
61519: EMPTY
61520: PPUSH
61521: CALL_OW 1
61525: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
61526: LD_VAR 0 2
61530: PPUSH
61531: LD_INT 103
61533: PPUSH
61534: CALL 56358 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
61538: LD_ADDR_VAR 0 5
61542: PUSH
61543: LD_EXP 23
61547: PUSH
61548: LD_VAR 0 2
61552: ARRAY
61553: PUSH
61554: LD_EXP 52
61558: PUSH
61559: LD_VAR 0 2
61563: ARRAY
61564: UNION
61565: PPUSH
61566: LD_INT 2
61568: PUSH
61569: LD_INT 25
61571: PUSH
61572: LD_INT 2
61574: PUSH
61575: EMPTY
61576: LIST
61577: LIST
61578: PUSH
61579: LD_INT 25
61581: PUSH
61582: LD_INT 16
61584: PUSH
61585: EMPTY
61586: LIST
61587: LIST
61588: PUSH
61589: EMPTY
61590: LIST
61591: LIST
61592: LIST
61593: PUSH
61594: EMPTY
61595: LIST
61596: PPUSH
61597: CALL_OW 72
61601: ST_TO_ADDR
// if mc_need_heal [ i ] then
61602: LD_EXP 26
61606: PUSH
61607: LD_VAR 0 2
61611: ARRAY
61612: IFFALSE 61656
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
61614: LD_ADDR_VAR 0 5
61618: PUSH
61619: LD_VAR 0 5
61623: PUSH
61624: LD_EXP 26
61628: PUSH
61629: LD_VAR 0 2
61633: ARRAY
61634: PUSH
61635: LD_INT 1
61637: ARRAY
61638: PUSH
61639: LD_EXP 26
61643: PUSH
61644: LD_VAR 0 2
61648: ARRAY
61649: PUSH
61650: LD_INT 2
61652: ARRAY
61653: UNION
61654: DIFF
61655: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
61656: LD_ADDR_VAR 0 6
61660: PUSH
61661: LD_EXP 42
61665: PUSH
61666: LD_VAR 0 2
61670: ARRAY
61671: PPUSH
61672: LD_INT 2
61674: PUSH
61675: LD_INT 34
61677: PUSH
61678: LD_INT 13
61680: PUSH
61681: EMPTY
61682: LIST
61683: LIST
61684: PUSH
61685: LD_INT 34
61687: PUSH
61688: LD_INT 52
61690: PUSH
61691: EMPTY
61692: LIST
61693: LIST
61694: PUSH
61695: LD_INT 34
61697: PUSH
61698: LD_INT 88
61700: PUSH
61701: EMPTY
61702: LIST
61703: LIST
61704: PUSH
61705: EMPTY
61706: LIST
61707: LIST
61708: LIST
61709: LIST
61710: PPUSH
61711: CALL_OW 72
61715: ST_TO_ADDR
// if cranes then
61716: LD_VAR 0 6
61720: IFFALSE 61856
// begin for j in cranes do
61722: LD_ADDR_VAR 0 3
61726: PUSH
61727: LD_VAR 0 6
61731: PUSH
61732: FOR_IN
61733: IFFALSE 61854
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
61735: LD_VAR 0 3
61739: PPUSH
61740: CALL_OW 256
61744: PUSH
61745: LD_INT 1000
61747: EQUAL
61748: PUSH
61749: LD_VAR 0 3
61753: PPUSH
61754: CALL_OW 314
61758: NOT
61759: AND
61760: IFFALSE 61794
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
61762: LD_VAR 0 3
61766: PPUSH
61767: LD_EXP 24
61771: PUSH
61772: LD_VAR 0 2
61776: ARRAY
61777: PPUSH
61778: LD_VAR 0 3
61782: PPUSH
61783: CALL_OW 74
61787: PPUSH
61788: CALL_OW 130
61792: GO 61852
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
61794: LD_VAR 0 3
61798: PPUSH
61799: CALL_OW 256
61803: PUSH
61804: LD_INT 500
61806: LESS
61807: PUSH
61808: LD_VAR 0 3
61812: PPUSH
61813: LD_EXP 47
61817: PUSH
61818: LD_VAR 0 2
61822: ARRAY
61823: PPUSH
61824: CALL_OW 308
61828: NOT
61829: AND
61830: IFFALSE 61852
// ComMoveToArea ( j , mc_parking [ i ] ) ;
61832: LD_VAR 0 3
61836: PPUSH
61837: LD_EXP 47
61841: PUSH
61842: LD_VAR 0 2
61846: ARRAY
61847: PPUSH
61848: CALL_OW 113
// end ;
61852: GO 61732
61854: POP
61855: POP
// end ; if tmp > 3 then
61856: LD_VAR 0 5
61860: PUSH
61861: LD_INT 3
61863: GREATER
61864: IFFALSE 61884
// tmp := ShrinkArray ( tmp , 4 ) ;
61866: LD_ADDR_VAR 0 5
61870: PUSH
61871: LD_VAR 0 5
61875: PPUSH
61876: LD_INT 4
61878: PPUSH
61879: CALL 48710 0 2
61883: ST_TO_ADDR
// if not tmp then
61884: LD_VAR 0 5
61888: NOT
61889: IFFALSE 61893
// continue ;
61891: GO 61305
// for j in tmp do
61893: LD_ADDR_VAR 0 3
61897: PUSH
61898: LD_VAR 0 5
61902: PUSH
61903: FOR_IN
61904: IFFALSE 62163
// begin if IsInUnit ( j ) then
61906: LD_VAR 0 3
61910: PPUSH
61911: CALL_OW 310
61915: IFFALSE 61926
// ComExitBuilding ( j ) ;
61917: LD_VAR 0 3
61921: PPUSH
61922: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
61926: LD_VAR 0 3
61930: PUSH
61931: LD_EXP 25
61935: PUSH
61936: LD_VAR 0 2
61940: ARRAY
61941: IN
61942: NOT
61943: IFFALSE 62001
// begin SetTag ( j , 101 ) ;
61945: LD_VAR 0 3
61949: PPUSH
61950: LD_INT 101
61952: PPUSH
61953: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
61957: LD_ADDR_EXP 25
61961: PUSH
61962: LD_EXP 25
61966: PPUSH
61967: LD_VAR 0 2
61971: PUSH
61972: LD_EXP 25
61976: PUSH
61977: LD_VAR 0 2
61981: ARRAY
61982: PUSH
61983: LD_INT 1
61985: PLUS
61986: PUSH
61987: EMPTY
61988: LIST
61989: LIST
61990: PPUSH
61991: LD_VAR 0 3
61995: PPUSH
61996: CALL 16156 0 3
62000: ST_TO_ADDR
// end ; wait ( 1 ) ;
62001: LD_INT 1
62003: PPUSH
62004: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
62008: LD_ADDR_VAR 0 7
62012: PUSH
62013: LD_EXP 24
62017: PUSH
62018: LD_VAR 0 2
62022: ARRAY
62023: ST_TO_ADDR
// if mc_scan [ i ] then
62024: LD_EXP 46
62028: PUSH
62029: LD_VAR 0 2
62033: ARRAY
62034: IFFALSE 62096
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
62036: LD_ADDR_VAR 0 7
62040: PUSH
62041: LD_EXP 24
62045: PUSH
62046: LD_VAR 0 2
62050: ARRAY
62051: PPUSH
62052: LD_INT 3
62054: PUSH
62055: LD_INT 30
62057: PUSH
62058: LD_INT 32
62060: PUSH
62061: EMPTY
62062: LIST
62063: LIST
62064: PUSH
62065: LD_INT 30
62067: PUSH
62068: LD_INT 33
62070: PUSH
62071: EMPTY
62072: LIST
62073: LIST
62074: PUSH
62075: LD_INT 30
62077: PUSH
62078: LD_INT 31
62080: PUSH
62081: EMPTY
62082: LIST
62083: LIST
62084: PUSH
62085: EMPTY
62086: LIST
62087: LIST
62088: LIST
62089: LIST
62090: PPUSH
62091: CALL_OW 72
62095: ST_TO_ADDR
// if not to_repair_tmp then
62096: LD_VAR 0 7
62100: NOT
62101: IFFALSE 62105
// continue ;
62103: GO 61903
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
62105: LD_ADDR_VAR 0 8
62109: PUSH
62110: LD_VAR 0 7
62114: PPUSH
62115: LD_VAR 0 3
62119: PPUSH
62120: CALL_OW 74
62124: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
62125: LD_VAR 0 8
62129: PPUSH
62130: LD_INT 16
62132: PPUSH
62133: CALL 18753 0 2
62137: PUSH
62138: LD_INT 4
62140: ARRAY
62141: PUSH
62142: LD_INT 10
62144: LESS
62145: IFFALSE 62161
// ComRepairBuilding ( j , to_repair ) ;
62147: LD_VAR 0 3
62151: PPUSH
62152: LD_VAR 0 8
62156: PPUSH
62157: CALL_OW 130
// end ;
62161: GO 61903
62163: POP
62164: POP
// end ;
62165: GO 61305
62167: POP
62168: POP
// end ;
62169: LD_VAR 0 1
62173: RET
// export function MC_Heal ; var i , j , tmp ; begin
62174: LD_INT 0
62176: PPUSH
62177: PPUSH
62178: PPUSH
62179: PPUSH
// if not mc_bases then
62180: LD_EXP 23
62184: NOT
62185: IFFALSE 62189
// exit ;
62187: GO 62591
// for i = 1 to mc_bases do
62189: LD_ADDR_VAR 0 2
62193: PUSH
62194: DOUBLE
62195: LD_INT 1
62197: DEC
62198: ST_TO_ADDR
62199: LD_EXP 23
62203: PUSH
62204: FOR_TO
62205: IFFALSE 62589
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
62207: LD_EXP 26
62211: PUSH
62212: LD_VAR 0 2
62216: ARRAY
62217: PUSH
62218: LD_INT 1
62220: ARRAY
62221: NOT
62222: PUSH
62223: LD_EXP 26
62227: PUSH
62228: LD_VAR 0 2
62232: ARRAY
62233: PUSH
62234: LD_INT 2
62236: ARRAY
62237: NOT
62238: AND
62239: IFFALSE 62277
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
62241: LD_ADDR_EXP 27
62245: PUSH
62246: LD_EXP 27
62250: PPUSH
62251: LD_VAR 0 2
62255: PPUSH
62256: EMPTY
62257: PPUSH
62258: CALL_OW 1
62262: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
62263: LD_VAR 0 2
62267: PPUSH
62268: LD_INT 102
62270: PPUSH
62271: CALL 56358 0 2
// continue ;
62275: GO 62204
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
62277: LD_ADDR_VAR 0 4
62281: PUSH
62282: LD_EXP 23
62286: PUSH
62287: LD_VAR 0 2
62291: ARRAY
62292: PPUSH
62293: LD_INT 25
62295: PUSH
62296: LD_INT 4
62298: PUSH
62299: EMPTY
62300: LIST
62301: LIST
62302: PPUSH
62303: CALL_OW 72
62307: ST_TO_ADDR
// if not tmp then
62308: LD_VAR 0 4
62312: NOT
62313: IFFALSE 62317
// continue ;
62315: GO 62204
// if mc_taming [ i ] then
62317: LD_EXP 54
62321: PUSH
62322: LD_VAR 0 2
62326: ARRAY
62327: IFFALSE 62351
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
62329: LD_ADDR_EXP 54
62333: PUSH
62334: LD_EXP 54
62338: PPUSH
62339: LD_VAR 0 2
62343: PPUSH
62344: EMPTY
62345: PPUSH
62346: CALL_OW 1
62350: ST_TO_ADDR
// for j in tmp do
62351: LD_ADDR_VAR 0 3
62355: PUSH
62356: LD_VAR 0 4
62360: PUSH
62361: FOR_IN
62362: IFFALSE 62585
// begin if IsInUnit ( j ) then
62364: LD_VAR 0 3
62368: PPUSH
62369: CALL_OW 310
62373: IFFALSE 62384
// ComExitBuilding ( j ) ;
62375: LD_VAR 0 3
62379: PPUSH
62380: CALL_OW 122
// if not j in mc_healers [ i ] then
62384: LD_VAR 0 3
62388: PUSH
62389: LD_EXP 27
62393: PUSH
62394: LD_VAR 0 2
62398: ARRAY
62399: IN
62400: NOT
62401: IFFALSE 62447
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
62403: LD_ADDR_EXP 27
62407: PUSH
62408: LD_EXP 27
62412: PPUSH
62413: LD_VAR 0 2
62417: PUSH
62418: LD_EXP 27
62422: PUSH
62423: LD_VAR 0 2
62427: ARRAY
62428: PUSH
62429: LD_INT 1
62431: PLUS
62432: PUSH
62433: EMPTY
62434: LIST
62435: LIST
62436: PPUSH
62437: LD_VAR 0 3
62441: PPUSH
62442: CALL 16156 0 3
62446: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
62447: LD_VAR 0 3
62451: PPUSH
62452: CALL_OW 110
62456: PUSH
62457: LD_INT 102
62459: NONEQUAL
62460: IFFALSE 62474
// SetTag ( j , 102 ) ;
62462: LD_VAR 0 3
62466: PPUSH
62467: LD_INT 102
62469: PPUSH
62470: CALL_OW 109
// Wait ( 3 ) ;
62474: LD_INT 3
62476: PPUSH
62477: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
62481: LD_EXP 26
62485: PUSH
62486: LD_VAR 0 2
62490: ARRAY
62491: PUSH
62492: LD_INT 1
62494: ARRAY
62495: IFFALSE 62527
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
62497: LD_VAR 0 3
62501: PPUSH
62502: LD_EXP 26
62506: PUSH
62507: LD_VAR 0 2
62511: ARRAY
62512: PUSH
62513: LD_INT 1
62515: ARRAY
62516: PUSH
62517: LD_INT 1
62519: ARRAY
62520: PPUSH
62521: CALL_OW 128
62525: GO 62583
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
62527: LD_VAR 0 3
62531: PPUSH
62532: CALL_OW 314
62536: NOT
62537: PUSH
62538: LD_EXP 26
62542: PUSH
62543: LD_VAR 0 2
62547: ARRAY
62548: PUSH
62549: LD_INT 2
62551: ARRAY
62552: AND
62553: IFFALSE 62583
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
62555: LD_VAR 0 3
62559: PPUSH
62560: LD_EXP 26
62564: PUSH
62565: LD_VAR 0 2
62569: ARRAY
62570: PUSH
62571: LD_INT 2
62573: ARRAY
62574: PUSH
62575: LD_INT 1
62577: ARRAY
62578: PPUSH
62579: CALL_OW 128
// end ;
62583: GO 62361
62585: POP
62586: POP
// end ;
62587: GO 62204
62589: POP
62590: POP
// end ;
62591: LD_VAR 0 1
62595: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
62596: LD_INT 0
62598: PPUSH
62599: PPUSH
62600: PPUSH
62601: PPUSH
62602: PPUSH
// if not mc_bases then
62603: LD_EXP 23
62607: NOT
62608: IFFALSE 62612
// exit ;
62610: GO 63783
// for i = 1 to mc_bases do
62612: LD_ADDR_VAR 0 2
62616: PUSH
62617: DOUBLE
62618: LD_INT 1
62620: DEC
62621: ST_TO_ADDR
62622: LD_EXP 23
62626: PUSH
62627: FOR_TO
62628: IFFALSE 63781
// begin if mc_scan [ i ] then
62630: LD_EXP 46
62634: PUSH
62635: LD_VAR 0 2
62639: ARRAY
62640: IFFALSE 62644
// continue ;
62642: GO 62627
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
62644: LD_EXP 28
62648: PUSH
62649: LD_VAR 0 2
62653: ARRAY
62654: NOT
62655: PUSH
62656: LD_EXP 30
62660: PUSH
62661: LD_VAR 0 2
62665: ARRAY
62666: NOT
62667: AND
62668: PUSH
62669: LD_EXP 29
62673: PUSH
62674: LD_VAR 0 2
62678: ARRAY
62679: AND
62680: IFFALSE 62718
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
62682: LD_ADDR_EXP 29
62686: PUSH
62687: LD_EXP 29
62691: PPUSH
62692: LD_VAR 0 2
62696: PPUSH
62697: EMPTY
62698: PPUSH
62699: CALL_OW 1
62703: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
62704: LD_VAR 0 2
62708: PPUSH
62709: LD_INT 103
62711: PPUSH
62712: CALL 56358 0 2
// continue ;
62716: GO 62627
// end ; if mc_construct_list [ i ] then
62718: LD_EXP 30
62722: PUSH
62723: LD_VAR 0 2
62727: ARRAY
62728: IFFALSE 62948
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
62730: LD_ADDR_VAR 0 4
62734: PUSH
62735: LD_EXP 23
62739: PUSH
62740: LD_VAR 0 2
62744: ARRAY
62745: PPUSH
62746: LD_INT 25
62748: PUSH
62749: LD_INT 2
62751: PUSH
62752: EMPTY
62753: LIST
62754: LIST
62755: PPUSH
62756: CALL_OW 72
62760: PUSH
62761: LD_EXP 25
62765: PUSH
62766: LD_VAR 0 2
62770: ARRAY
62771: DIFF
62772: ST_TO_ADDR
// if not tmp then
62773: LD_VAR 0 4
62777: NOT
62778: IFFALSE 62782
// continue ;
62780: GO 62627
// for j in tmp do
62782: LD_ADDR_VAR 0 3
62786: PUSH
62787: LD_VAR 0 4
62791: PUSH
62792: FOR_IN
62793: IFFALSE 62944
// begin if not mc_builders [ i ] then
62795: LD_EXP 29
62799: PUSH
62800: LD_VAR 0 2
62804: ARRAY
62805: NOT
62806: IFFALSE 62864
// begin SetTag ( j , 103 ) ;
62808: LD_VAR 0 3
62812: PPUSH
62813: LD_INT 103
62815: PPUSH
62816: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
62820: LD_ADDR_EXP 29
62824: PUSH
62825: LD_EXP 29
62829: PPUSH
62830: LD_VAR 0 2
62834: PUSH
62835: LD_EXP 29
62839: PUSH
62840: LD_VAR 0 2
62844: ARRAY
62845: PUSH
62846: LD_INT 1
62848: PLUS
62849: PUSH
62850: EMPTY
62851: LIST
62852: LIST
62853: PPUSH
62854: LD_VAR 0 3
62858: PPUSH
62859: CALL 16156 0 3
62863: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
62864: LD_VAR 0 3
62868: PPUSH
62869: CALL_OW 310
62873: IFFALSE 62884
// ComExitBuilding ( j ) ;
62875: LD_VAR 0 3
62879: PPUSH
62880: CALL_OW 122
// wait ( 3 ) ;
62884: LD_INT 3
62886: PPUSH
62887: CALL_OW 67
// if not mc_construct_list [ i ] then
62891: LD_EXP 30
62895: PUSH
62896: LD_VAR 0 2
62900: ARRAY
62901: NOT
62902: IFFALSE 62906
// break ;
62904: GO 62944
// if not HasTask ( j ) then
62906: LD_VAR 0 3
62910: PPUSH
62911: CALL_OW 314
62915: NOT
62916: IFFALSE 62942
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
62918: LD_VAR 0 3
62922: PPUSH
62923: LD_EXP 30
62927: PUSH
62928: LD_VAR 0 2
62932: ARRAY
62933: PUSH
62934: LD_INT 1
62936: ARRAY
62937: PPUSH
62938: CALL 19017 0 2
// end ;
62942: GO 62792
62944: POP
62945: POP
// end else
62946: GO 63779
// if mc_build_list [ i ] then
62948: LD_EXP 28
62952: PUSH
62953: LD_VAR 0 2
62957: ARRAY
62958: IFFALSE 63779
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
62960: LD_ADDR_VAR 0 5
62964: PUSH
62965: LD_EXP 23
62969: PUSH
62970: LD_VAR 0 2
62974: ARRAY
62975: PPUSH
62976: LD_INT 2
62978: PUSH
62979: LD_INT 30
62981: PUSH
62982: LD_INT 0
62984: PUSH
62985: EMPTY
62986: LIST
62987: LIST
62988: PUSH
62989: LD_INT 30
62991: PUSH
62992: LD_INT 1
62994: PUSH
62995: EMPTY
62996: LIST
62997: LIST
62998: PUSH
62999: EMPTY
63000: LIST
63001: LIST
63002: LIST
63003: PPUSH
63004: CALL_OW 72
63008: ST_TO_ADDR
// if depot then
63009: LD_VAR 0 5
63013: IFFALSE 63031
// depot := depot [ 1 ] else
63015: LD_ADDR_VAR 0 5
63019: PUSH
63020: LD_VAR 0 5
63024: PUSH
63025: LD_INT 1
63027: ARRAY
63028: ST_TO_ADDR
63029: GO 63039
// depot := 0 ;
63031: LD_ADDR_VAR 0 5
63035: PUSH
63036: LD_INT 0
63038: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
63039: LD_EXP 28
63043: PUSH
63044: LD_VAR 0 2
63048: ARRAY
63049: PUSH
63050: LD_INT 1
63052: ARRAY
63053: PUSH
63054: LD_INT 1
63056: ARRAY
63057: PPUSH
63058: CALL 18841 0 1
63062: PUSH
63063: LD_EXP 23
63067: PUSH
63068: LD_VAR 0 2
63072: ARRAY
63073: PPUSH
63074: LD_INT 2
63076: PUSH
63077: LD_INT 30
63079: PUSH
63080: LD_INT 2
63082: PUSH
63083: EMPTY
63084: LIST
63085: LIST
63086: PUSH
63087: LD_INT 30
63089: PUSH
63090: LD_INT 3
63092: PUSH
63093: EMPTY
63094: LIST
63095: LIST
63096: PUSH
63097: EMPTY
63098: LIST
63099: LIST
63100: LIST
63101: PPUSH
63102: CALL_OW 72
63106: NOT
63107: AND
63108: IFFALSE 63213
// begin for j = 1 to mc_build_list [ i ] do
63110: LD_ADDR_VAR 0 3
63114: PUSH
63115: DOUBLE
63116: LD_INT 1
63118: DEC
63119: ST_TO_ADDR
63120: LD_EXP 28
63124: PUSH
63125: LD_VAR 0 2
63129: ARRAY
63130: PUSH
63131: FOR_TO
63132: IFFALSE 63211
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
63134: LD_EXP 28
63138: PUSH
63139: LD_VAR 0 2
63143: ARRAY
63144: PUSH
63145: LD_VAR 0 3
63149: ARRAY
63150: PUSH
63151: LD_INT 1
63153: ARRAY
63154: PUSH
63155: LD_INT 2
63157: EQUAL
63158: IFFALSE 63209
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
63160: LD_ADDR_EXP 28
63164: PUSH
63165: LD_EXP 28
63169: PPUSH
63170: LD_VAR 0 2
63174: PPUSH
63175: LD_EXP 28
63179: PUSH
63180: LD_VAR 0 2
63184: ARRAY
63185: PPUSH
63186: LD_VAR 0 3
63190: PPUSH
63191: LD_INT 1
63193: PPUSH
63194: LD_INT 0
63196: PPUSH
63197: CALL 15574 0 4
63201: PPUSH
63202: CALL_OW 1
63206: ST_TO_ADDR
// break ;
63207: GO 63211
// end ;
63209: GO 63131
63211: POP
63212: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
63213: LD_EXP 28
63217: PUSH
63218: LD_VAR 0 2
63222: ARRAY
63223: PUSH
63224: LD_INT 1
63226: ARRAY
63227: PUSH
63228: LD_INT 1
63230: ARRAY
63231: PUSH
63232: LD_INT 0
63234: EQUAL
63235: PUSH
63236: LD_VAR 0 5
63240: PUSH
63241: LD_VAR 0 5
63245: PPUSH
63246: LD_EXP 28
63250: PUSH
63251: LD_VAR 0 2
63255: ARRAY
63256: PUSH
63257: LD_INT 1
63259: ARRAY
63260: PUSH
63261: LD_INT 1
63263: ARRAY
63264: PPUSH
63265: LD_EXP 28
63269: PUSH
63270: LD_VAR 0 2
63274: ARRAY
63275: PUSH
63276: LD_INT 1
63278: ARRAY
63279: PUSH
63280: LD_INT 2
63282: ARRAY
63283: PPUSH
63284: LD_EXP 28
63288: PUSH
63289: LD_VAR 0 2
63293: ARRAY
63294: PUSH
63295: LD_INT 1
63297: ARRAY
63298: PUSH
63299: LD_INT 3
63301: ARRAY
63302: PPUSH
63303: LD_EXP 28
63307: PUSH
63308: LD_VAR 0 2
63312: ARRAY
63313: PUSH
63314: LD_INT 1
63316: ARRAY
63317: PUSH
63318: LD_INT 4
63320: ARRAY
63321: PPUSH
63322: CALL 24253 0 5
63326: AND
63327: OR
63328: IFFALSE 63609
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
63330: LD_ADDR_VAR 0 4
63334: PUSH
63335: LD_EXP 23
63339: PUSH
63340: LD_VAR 0 2
63344: ARRAY
63345: PPUSH
63346: LD_INT 25
63348: PUSH
63349: LD_INT 2
63351: PUSH
63352: EMPTY
63353: LIST
63354: LIST
63355: PPUSH
63356: CALL_OW 72
63360: PUSH
63361: LD_EXP 25
63365: PUSH
63366: LD_VAR 0 2
63370: ARRAY
63371: DIFF
63372: ST_TO_ADDR
// if not tmp then
63373: LD_VAR 0 4
63377: NOT
63378: IFFALSE 63382
// continue ;
63380: GO 62627
// for j in tmp do
63382: LD_ADDR_VAR 0 3
63386: PUSH
63387: LD_VAR 0 4
63391: PUSH
63392: FOR_IN
63393: IFFALSE 63605
// begin if not mc_builders [ i ] then
63395: LD_EXP 29
63399: PUSH
63400: LD_VAR 0 2
63404: ARRAY
63405: NOT
63406: IFFALSE 63464
// begin SetTag ( j , 103 ) ;
63408: LD_VAR 0 3
63412: PPUSH
63413: LD_INT 103
63415: PPUSH
63416: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
63420: LD_ADDR_EXP 29
63424: PUSH
63425: LD_EXP 29
63429: PPUSH
63430: LD_VAR 0 2
63434: PUSH
63435: LD_EXP 29
63439: PUSH
63440: LD_VAR 0 2
63444: ARRAY
63445: PUSH
63446: LD_INT 1
63448: PLUS
63449: PUSH
63450: EMPTY
63451: LIST
63452: LIST
63453: PPUSH
63454: LD_VAR 0 3
63458: PPUSH
63459: CALL 16156 0 3
63463: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
63464: LD_VAR 0 3
63468: PPUSH
63469: CALL_OW 310
63473: IFFALSE 63484
// ComExitBuilding ( j ) ;
63475: LD_VAR 0 3
63479: PPUSH
63480: CALL_OW 122
// wait ( 3 ) ;
63484: LD_INT 3
63486: PPUSH
63487: CALL_OW 67
// if not mc_build_list [ i ] then
63491: LD_EXP 28
63495: PUSH
63496: LD_VAR 0 2
63500: ARRAY
63501: NOT
63502: IFFALSE 63506
// break ;
63504: GO 63605
// if not HasTask ( j ) then
63506: LD_VAR 0 3
63510: PPUSH
63511: CALL_OW 314
63515: NOT
63516: IFFALSE 63603
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
63518: LD_VAR 0 3
63522: PPUSH
63523: LD_EXP 28
63527: PUSH
63528: LD_VAR 0 2
63532: ARRAY
63533: PUSH
63534: LD_INT 1
63536: ARRAY
63537: PUSH
63538: LD_INT 1
63540: ARRAY
63541: PPUSH
63542: LD_EXP 28
63546: PUSH
63547: LD_VAR 0 2
63551: ARRAY
63552: PUSH
63553: LD_INT 1
63555: ARRAY
63556: PUSH
63557: LD_INT 2
63559: ARRAY
63560: PPUSH
63561: LD_EXP 28
63565: PUSH
63566: LD_VAR 0 2
63570: ARRAY
63571: PUSH
63572: LD_INT 1
63574: ARRAY
63575: PUSH
63576: LD_INT 3
63578: ARRAY
63579: PPUSH
63580: LD_EXP 28
63584: PUSH
63585: LD_VAR 0 2
63589: ARRAY
63590: PUSH
63591: LD_INT 1
63593: ARRAY
63594: PUSH
63595: LD_INT 4
63597: ARRAY
63598: PPUSH
63599: CALL_OW 145
// end ;
63603: GO 63392
63605: POP
63606: POP
// end else
63607: GO 63779
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
63609: LD_EXP 23
63613: PUSH
63614: LD_VAR 0 2
63618: ARRAY
63619: PPUSH
63620: LD_EXP 28
63624: PUSH
63625: LD_VAR 0 2
63629: ARRAY
63630: PUSH
63631: LD_INT 1
63633: ARRAY
63634: PUSH
63635: LD_INT 1
63637: ARRAY
63638: PPUSH
63639: LD_EXP 28
63643: PUSH
63644: LD_VAR 0 2
63648: ARRAY
63649: PUSH
63650: LD_INT 1
63652: ARRAY
63653: PUSH
63654: LD_INT 2
63656: ARRAY
63657: PPUSH
63658: LD_EXP 28
63662: PUSH
63663: LD_VAR 0 2
63667: ARRAY
63668: PUSH
63669: LD_INT 1
63671: ARRAY
63672: PUSH
63673: LD_INT 3
63675: ARRAY
63676: PPUSH
63677: LD_EXP 28
63681: PUSH
63682: LD_VAR 0 2
63686: ARRAY
63687: PUSH
63688: LD_INT 1
63690: ARRAY
63691: PUSH
63692: LD_INT 4
63694: ARRAY
63695: PPUSH
63696: LD_EXP 23
63700: PUSH
63701: LD_VAR 0 2
63705: ARRAY
63706: PPUSH
63707: LD_INT 21
63709: PUSH
63710: LD_INT 3
63712: PUSH
63713: EMPTY
63714: LIST
63715: LIST
63716: PPUSH
63717: CALL_OW 72
63721: PPUSH
63722: EMPTY
63723: PPUSH
63724: CALL 23007 0 7
63728: NOT
63729: IFFALSE 63779
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
63731: LD_ADDR_EXP 28
63735: PUSH
63736: LD_EXP 28
63740: PPUSH
63741: LD_VAR 0 2
63745: PPUSH
63746: LD_EXP 28
63750: PUSH
63751: LD_VAR 0 2
63755: ARRAY
63756: PPUSH
63757: LD_INT 1
63759: PPUSH
63760: LD_INT 1
63762: NEG
63763: PPUSH
63764: LD_INT 0
63766: PPUSH
63767: CALL 15574 0 4
63771: PPUSH
63772: CALL_OW 1
63776: ST_TO_ADDR
// continue ;
63777: GO 62627
// end ; end ; end ;
63779: GO 62627
63781: POP
63782: POP
// end ;
63783: LD_VAR 0 1
63787: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
63788: LD_INT 0
63790: PPUSH
63791: PPUSH
63792: PPUSH
63793: PPUSH
63794: PPUSH
63795: PPUSH
// if not mc_bases then
63796: LD_EXP 23
63800: NOT
63801: IFFALSE 63805
// exit ;
63803: GO 64232
// for i = 1 to mc_bases do
63805: LD_ADDR_VAR 0 2
63809: PUSH
63810: DOUBLE
63811: LD_INT 1
63813: DEC
63814: ST_TO_ADDR
63815: LD_EXP 23
63819: PUSH
63820: FOR_TO
63821: IFFALSE 64230
// begin tmp := mc_build_upgrade [ i ] ;
63823: LD_ADDR_VAR 0 4
63827: PUSH
63828: LD_EXP 55
63832: PUSH
63833: LD_VAR 0 2
63837: ARRAY
63838: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
63839: LD_ADDR_VAR 0 6
63843: PUSH
63844: LD_EXP 56
63848: PUSH
63849: LD_VAR 0 2
63853: ARRAY
63854: PPUSH
63855: LD_INT 2
63857: PUSH
63858: LD_INT 30
63860: PUSH
63861: LD_INT 6
63863: PUSH
63864: EMPTY
63865: LIST
63866: LIST
63867: PUSH
63868: LD_INT 30
63870: PUSH
63871: LD_INT 7
63873: PUSH
63874: EMPTY
63875: LIST
63876: LIST
63877: PUSH
63878: EMPTY
63879: LIST
63880: LIST
63881: LIST
63882: PPUSH
63883: CALL_OW 72
63887: ST_TO_ADDR
// if not tmp and not lab then
63888: LD_VAR 0 4
63892: NOT
63893: PUSH
63894: LD_VAR 0 6
63898: NOT
63899: AND
63900: IFFALSE 63904
// continue ;
63902: GO 63820
// if tmp then
63904: LD_VAR 0 4
63908: IFFALSE 64028
// for j in tmp do
63910: LD_ADDR_VAR 0 3
63914: PUSH
63915: LD_VAR 0 4
63919: PUSH
63920: FOR_IN
63921: IFFALSE 64026
// begin if UpgradeCost ( j ) then
63923: LD_VAR 0 3
63927: PPUSH
63928: CALL 22667 0 1
63932: IFFALSE 64024
// begin ComUpgrade ( j ) ;
63934: LD_VAR 0 3
63938: PPUSH
63939: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
63943: LD_ADDR_EXP 55
63947: PUSH
63948: LD_EXP 55
63952: PPUSH
63953: LD_VAR 0 2
63957: PPUSH
63958: LD_EXP 55
63962: PUSH
63963: LD_VAR 0 2
63967: ARRAY
63968: PUSH
63969: LD_VAR 0 3
63973: DIFF
63974: PPUSH
63975: CALL_OW 1
63979: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
63980: LD_ADDR_EXP 30
63984: PUSH
63985: LD_EXP 30
63989: PPUSH
63990: LD_VAR 0 2
63994: PUSH
63995: LD_EXP 30
63999: PUSH
64000: LD_VAR 0 2
64004: ARRAY
64005: PUSH
64006: LD_INT 1
64008: PLUS
64009: PUSH
64010: EMPTY
64011: LIST
64012: LIST
64013: PPUSH
64014: LD_VAR 0 3
64018: PPUSH
64019: CALL 16156 0 3
64023: ST_TO_ADDR
// end ; end ;
64024: GO 63920
64026: POP
64027: POP
// if not lab or not mc_lab_upgrade [ i ] then
64028: LD_VAR 0 6
64032: NOT
64033: PUSH
64034: LD_EXP 57
64038: PUSH
64039: LD_VAR 0 2
64043: ARRAY
64044: NOT
64045: OR
64046: IFFALSE 64050
// continue ;
64048: GO 63820
// for j in lab do
64050: LD_ADDR_VAR 0 3
64054: PUSH
64055: LD_VAR 0 6
64059: PUSH
64060: FOR_IN
64061: IFFALSE 64226
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
64063: LD_VAR 0 3
64067: PPUSH
64068: CALL_OW 266
64072: PUSH
64073: LD_INT 6
64075: PUSH
64076: LD_INT 7
64078: PUSH
64079: EMPTY
64080: LIST
64081: LIST
64082: IN
64083: PUSH
64084: LD_VAR 0 3
64088: PPUSH
64089: CALL_OW 461
64093: PUSH
64094: LD_INT 1
64096: NONEQUAL
64097: AND
64098: IFFALSE 64224
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
64100: LD_VAR 0 3
64104: PPUSH
64105: LD_EXP 57
64109: PUSH
64110: LD_VAR 0 2
64114: ARRAY
64115: PUSH
64116: LD_INT 1
64118: ARRAY
64119: PPUSH
64120: CALL 22872 0 2
64124: IFFALSE 64224
// begin ComCancel ( j ) ;
64126: LD_VAR 0 3
64130: PPUSH
64131: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
64135: LD_VAR 0 3
64139: PPUSH
64140: LD_EXP 57
64144: PUSH
64145: LD_VAR 0 2
64149: ARRAY
64150: PUSH
64151: LD_INT 1
64153: ARRAY
64154: PPUSH
64155: CALL_OW 207
// if not j in mc_construct_list [ i ] then
64159: LD_VAR 0 3
64163: PUSH
64164: LD_EXP 30
64168: PUSH
64169: LD_VAR 0 2
64173: ARRAY
64174: IN
64175: NOT
64176: IFFALSE 64222
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
64178: LD_ADDR_EXP 30
64182: PUSH
64183: LD_EXP 30
64187: PPUSH
64188: LD_VAR 0 2
64192: PUSH
64193: LD_EXP 30
64197: PUSH
64198: LD_VAR 0 2
64202: ARRAY
64203: PUSH
64204: LD_INT 1
64206: PLUS
64207: PUSH
64208: EMPTY
64209: LIST
64210: LIST
64211: PPUSH
64212: LD_VAR 0 3
64216: PPUSH
64217: CALL 16156 0 3
64221: ST_TO_ADDR
// break ;
64222: GO 64226
// end ; end ; end ;
64224: GO 64060
64226: POP
64227: POP
// end ;
64228: GO 63820
64230: POP
64231: POP
// end ;
64232: LD_VAR 0 1
64236: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
64237: LD_INT 0
64239: PPUSH
64240: PPUSH
64241: PPUSH
64242: PPUSH
64243: PPUSH
64244: PPUSH
64245: PPUSH
64246: PPUSH
64247: PPUSH
// if not mc_bases then
64248: LD_EXP 23
64252: NOT
64253: IFFALSE 64257
// exit ;
64255: GO 64662
// for i = 1 to mc_bases do
64257: LD_ADDR_VAR 0 2
64261: PUSH
64262: DOUBLE
64263: LD_INT 1
64265: DEC
64266: ST_TO_ADDR
64267: LD_EXP 23
64271: PUSH
64272: FOR_TO
64273: IFFALSE 64660
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
64275: LD_EXP 31
64279: PUSH
64280: LD_VAR 0 2
64284: ARRAY
64285: NOT
64286: PUSH
64287: LD_EXP 23
64291: PUSH
64292: LD_VAR 0 2
64296: ARRAY
64297: PPUSH
64298: LD_INT 30
64300: PUSH
64301: LD_INT 3
64303: PUSH
64304: EMPTY
64305: LIST
64306: LIST
64307: PPUSH
64308: CALL_OW 72
64312: NOT
64313: OR
64314: IFFALSE 64318
// continue ;
64316: GO 64272
// busy := false ;
64318: LD_ADDR_VAR 0 8
64322: PUSH
64323: LD_INT 0
64325: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
64326: LD_ADDR_VAR 0 4
64330: PUSH
64331: LD_EXP 23
64335: PUSH
64336: LD_VAR 0 2
64340: ARRAY
64341: PPUSH
64342: LD_INT 30
64344: PUSH
64345: LD_INT 3
64347: PUSH
64348: EMPTY
64349: LIST
64350: LIST
64351: PPUSH
64352: CALL_OW 72
64356: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
64357: LD_ADDR_VAR 0 6
64361: PUSH
64362: LD_EXP 31
64366: PUSH
64367: LD_VAR 0 2
64371: ARRAY
64372: PPUSH
64373: LD_INT 2
64375: PUSH
64376: LD_INT 30
64378: PUSH
64379: LD_INT 32
64381: PUSH
64382: EMPTY
64383: LIST
64384: LIST
64385: PUSH
64386: LD_INT 30
64388: PUSH
64389: LD_INT 33
64391: PUSH
64392: EMPTY
64393: LIST
64394: LIST
64395: PUSH
64396: EMPTY
64397: LIST
64398: LIST
64399: LIST
64400: PPUSH
64401: CALL_OW 72
64405: ST_TO_ADDR
// if not t then
64406: LD_VAR 0 6
64410: NOT
64411: IFFALSE 64415
// continue ;
64413: GO 64272
// for j in tmp do
64415: LD_ADDR_VAR 0 3
64419: PUSH
64420: LD_VAR 0 4
64424: PUSH
64425: FOR_IN
64426: IFFALSE 64456
// if not BuildingStatus ( j ) = bs_idle then
64428: LD_VAR 0 3
64432: PPUSH
64433: CALL_OW 461
64437: PUSH
64438: LD_INT 2
64440: EQUAL
64441: NOT
64442: IFFALSE 64454
// begin busy := true ;
64444: LD_ADDR_VAR 0 8
64448: PUSH
64449: LD_INT 1
64451: ST_TO_ADDR
// break ;
64452: GO 64456
// end ;
64454: GO 64425
64456: POP
64457: POP
// if busy then
64458: LD_VAR 0 8
64462: IFFALSE 64466
// continue ;
64464: GO 64272
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
64466: LD_ADDR_VAR 0 7
64470: PUSH
64471: LD_VAR 0 6
64475: PPUSH
64476: LD_INT 35
64478: PUSH
64479: LD_INT 0
64481: PUSH
64482: EMPTY
64483: LIST
64484: LIST
64485: PPUSH
64486: CALL_OW 72
64490: ST_TO_ADDR
// if tw then
64491: LD_VAR 0 7
64495: IFFALSE 64572
// begin tw := tw [ 1 ] ;
64497: LD_ADDR_VAR 0 7
64501: PUSH
64502: LD_VAR 0 7
64506: PUSH
64507: LD_INT 1
64509: ARRAY
64510: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
64511: LD_ADDR_VAR 0 9
64515: PUSH
64516: LD_VAR 0 7
64520: PPUSH
64521: LD_EXP 48
64525: PUSH
64526: LD_VAR 0 2
64530: ARRAY
64531: PPUSH
64532: CALL 21164 0 2
64536: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
64537: LD_EXP 62
64541: PUSH
64542: LD_VAR 0 2
64546: ARRAY
64547: IFFALSE 64570
// if not weapon in mc_allowed_tower_weapons [ i ] then
64549: LD_VAR 0 9
64553: PUSH
64554: LD_EXP 62
64558: PUSH
64559: LD_VAR 0 2
64563: ARRAY
64564: IN
64565: NOT
64566: IFFALSE 64570
// continue ;
64568: GO 64272
// end else
64570: GO 64635
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
64572: LD_ADDR_VAR 0 5
64576: PUSH
64577: LD_EXP 31
64581: PUSH
64582: LD_VAR 0 2
64586: ARRAY
64587: PPUSH
64588: LD_VAR 0 4
64592: PPUSH
64593: CALL 47943 0 2
64597: ST_TO_ADDR
// if not tmp2 then
64598: LD_VAR 0 5
64602: NOT
64603: IFFALSE 64607
// continue ;
64605: GO 64272
// tw := tmp2 [ 1 ] ;
64607: LD_ADDR_VAR 0 7
64611: PUSH
64612: LD_VAR 0 5
64616: PUSH
64617: LD_INT 1
64619: ARRAY
64620: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
64621: LD_ADDR_VAR 0 9
64625: PUSH
64626: LD_VAR 0 5
64630: PUSH
64631: LD_INT 2
64633: ARRAY
64634: ST_TO_ADDR
// end ; if not weapon then
64635: LD_VAR 0 9
64639: NOT
64640: IFFALSE 64644
// continue ;
64642: GO 64272
// ComPlaceWeapon ( tw , weapon ) ;
64644: LD_VAR 0 7
64648: PPUSH
64649: LD_VAR 0 9
64653: PPUSH
64654: CALL_OW 148
// end ;
64658: GO 64272
64660: POP
64661: POP
// end ;
64662: LD_VAR 0 1
64666: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
64667: LD_INT 0
64669: PPUSH
64670: PPUSH
64671: PPUSH
64672: PPUSH
64673: PPUSH
64674: PPUSH
64675: PPUSH
// if not mc_bases then
64676: LD_EXP 23
64680: NOT
64681: IFFALSE 64685
// exit ;
64683: GO 65453
// for i = 1 to mc_bases do
64685: LD_ADDR_VAR 0 2
64689: PUSH
64690: DOUBLE
64691: LD_INT 1
64693: DEC
64694: ST_TO_ADDR
64695: LD_EXP 23
64699: PUSH
64700: FOR_TO
64701: IFFALSE 65451
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
64703: LD_EXP 36
64707: PUSH
64708: LD_VAR 0 2
64712: ARRAY
64713: NOT
64714: PUSH
64715: LD_EXP 36
64719: PUSH
64720: LD_VAR 0 2
64724: ARRAY
64725: PUSH
64726: LD_EXP 37
64730: PUSH
64731: LD_VAR 0 2
64735: ARRAY
64736: EQUAL
64737: OR
64738: PUSH
64739: LD_EXP 46
64743: PUSH
64744: LD_VAR 0 2
64748: ARRAY
64749: OR
64750: IFFALSE 64754
// continue ;
64752: GO 64700
// if mc_miners [ i ] then
64754: LD_EXP 37
64758: PUSH
64759: LD_VAR 0 2
64763: ARRAY
64764: IFFALSE 65138
// begin for j = mc_miners [ i ] downto 1 do
64766: LD_ADDR_VAR 0 3
64770: PUSH
64771: DOUBLE
64772: LD_EXP 37
64776: PUSH
64777: LD_VAR 0 2
64781: ARRAY
64782: INC
64783: ST_TO_ADDR
64784: LD_INT 1
64786: PUSH
64787: FOR_DOWNTO
64788: IFFALSE 65136
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
64790: LD_EXP 37
64794: PUSH
64795: LD_VAR 0 2
64799: ARRAY
64800: PUSH
64801: LD_VAR 0 3
64805: ARRAY
64806: PPUSH
64807: CALL_OW 301
64811: PUSH
64812: LD_EXP 37
64816: PUSH
64817: LD_VAR 0 2
64821: ARRAY
64822: PUSH
64823: LD_VAR 0 3
64827: ARRAY
64828: PPUSH
64829: CALL_OW 257
64833: PUSH
64834: LD_INT 1
64836: NONEQUAL
64837: OR
64838: IFFALSE 64901
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
64840: LD_ADDR_VAR 0 5
64844: PUSH
64845: LD_EXP 37
64849: PUSH
64850: LD_VAR 0 2
64854: ARRAY
64855: PUSH
64856: LD_EXP 37
64860: PUSH
64861: LD_VAR 0 2
64865: ARRAY
64866: PUSH
64867: LD_VAR 0 3
64871: ARRAY
64872: DIFF
64873: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
64874: LD_ADDR_EXP 37
64878: PUSH
64879: LD_EXP 37
64883: PPUSH
64884: LD_VAR 0 2
64888: PPUSH
64889: LD_VAR 0 5
64893: PPUSH
64894: CALL_OW 1
64898: ST_TO_ADDR
// continue ;
64899: GO 64787
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
64901: LD_EXP 37
64905: PUSH
64906: LD_VAR 0 2
64910: ARRAY
64911: PUSH
64912: LD_VAR 0 3
64916: ARRAY
64917: PPUSH
64918: CALL_OW 257
64922: PUSH
64923: LD_INT 1
64925: EQUAL
64926: PUSH
64927: LD_EXP 37
64931: PUSH
64932: LD_VAR 0 2
64936: ARRAY
64937: PUSH
64938: LD_VAR 0 3
64942: ARRAY
64943: PPUSH
64944: CALL_OW 459
64948: NOT
64949: AND
64950: PUSH
64951: LD_EXP 37
64955: PUSH
64956: LD_VAR 0 2
64960: ARRAY
64961: PUSH
64962: LD_VAR 0 3
64966: ARRAY
64967: PPUSH
64968: CALL_OW 314
64972: NOT
64973: AND
64974: IFFALSE 65134
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
64976: LD_EXP 37
64980: PUSH
64981: LD_VAR 0 2
64985: ARRAY
64986: PUSH
64987: LD_VAR 0 3
64991: ARRAY
64992: PPUSH
64993: CALL_OW 310
64997: IFFALSE 65020
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
64999: LD_EXP 37
65003: PUSH
65004: LD_VAR 0 2
65008: ARRAY
65009: PUSH
65010: LD_VAR 0 3
65014: ARRAY
65015: PPUSH
65016: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
65020: LD_EXP 37
65024: PUSH
65025: LD_VAR 0 2
65029: ARRAY
65030: PUSH
65031: LD_VAR 0 3
65035: ARRAY
65036: PPUSH
65037: CALL_OW 314
65041: NOT
65042: IFFALSE 65134
// begin r := rand ( 1 , mc_mines [ i ] ) ;
65044: LD_ADDR_VAR 0 7
65048: PUSH
65049: LD_INT 1
65051: PPUSH
65052: LD_EXP 36
65056: PUSH
65057: LD_VAR 0 2
65061: ARRAY
65062: PPUSH
65063: CALL_OW 12
65067: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
65068: LD_EXP 37
65072: PUSH
65073: LD_VAR 0 2
65077: ARRAY
65078: PUSH
65079: LD_VAR 0 3
65083: ARRAY
65084: PPUSH
65085: LD_EXP 36
65089: PUSH
65090: LD_VAR 0 2
65094: ARRAY
65095: PUSH
65096: LD_VAR 0 7
65100: ARRAY
65101: PUSH
65102: LD_INT 1
65104: ARRAY
65105: PPUSH
65106: LD_EXP 36
65110: PUSH
65111: LD_VAR 0 2
65115: ARRAY
65116: PUSH
65117: LD_VAR 0 7
65121: ARRAY
65122: PUSH
65123: LD_INT 2
65125: ARRAY
65126: PPUSH
65127: LD_INT 0
65129: PPUSH
65130: CALL_OW 193
// end ; end ; end ;
65134: GO 64787
65136: POP
65137: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
65138: LD_ADDR_VAR 0 5
65142: PUSH
65143: LD_EXP 23
65147: PUSH
65148: LD_VAR 0 2
65152: ARRAY
65153: PPUSH
65154: LD_INT 2
65156: PUSH
65157: LD_INT 30
65159: PUSH
65160: LD_INT 4
65162: PUSH
65163: EMPTY
65164: LIST
65165: LIST
65166: PUSH
65167: LD_INT 30
65169: PUSH
65170: LD_INT 5
65172: PUSH
65173: EMPTY
65174: LIST
65175: LIST
65176: PUSH
65177: LD_INT 30
65179: PUSH
65180: LD_INT 32
65182: PUSH
65183: EMPTY
65184: LIST
65185: LIST
65186: PUSH
65187: EMPTY
65188: LIST
65189: LIST
65190: LIST
65191: LIST
65192: PPUSH
65193: CALL_OW 72
65197: ST_TO_ADDR
// if not tmp then
65198: LD_VAR 0 5
65202: NOT
65203: IFFALSE 65207
// continue ;
65205: GO 64700
// list := [ ] ;
65207: LD_ADDR_VAR 0 6
65211: PUSH
65212: EMPTY
65213: ST_TO_ADDR
// for j in tmp do
65214: LD_ADDR_VAR 0 3
65218: PUSH
65219: LD_VAR 0 5
65223: PUSH
65224: FOR_IN
65225: IFFALSE 65294
// begin for k in UnitsInside ( j ) do
65227: LD_ADDR_VAR 0 4
65231: PUSH
65232: LD_VAR 0 3
65236: PPUSH
65237: CALL_OW 313
65241: PUSH
65242: FOR_IN
65243: IFFALSE 65290
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
65245: LD_VAR 0 4
65249: PPUSH
65250: CALL_OW 257
65254: PUSH
65255: LD_INT 1
65257: EQUAL
65258: PUSH
65259: LD_VAR 0 4
65263: PPUSH
65264: CALL_OW 459
65268: NOT
65269: AND
65270: IFFALSE 65288
// list := list ^ k ;
65272: LD_ADDR_VAR 0 6
65276: PUSH
65277: LD_VAR 0 6
65281: PUSH
65282: LD_VAR 0 4
65286: ADD
65287: ST_TO_ADDR
65288: GO 65242
65290: POP
65291: POP
// end ;
65292: GO 65224
65294: POP
65295: POP
// list := list diff mc_miners [ i ] ;
65296: LD_ADDR_VAR 0 6
65300: PUSH
65301: LD_VAR 0 6
65305: PUSH
65306: LD_EXP 37
65310: PUSH
65311: LD_VAR 0 2
65315: ARRAY
65316: DIFF
65317: ST_TO_ADDR
// if not list then
65318: LD_VAR 0 6
65322: NOT
65323: IFFALSE 65327
// continue ;
65325: GO 64700
// k := mc_mines [ i ] - mc_miners [ i ] ;
65327: LD_ADDR_VAR 0 4
65331: PUSH
65332: LD_EXP 36
65336: PUSH
65337: LD_VAR 0 2
65341: ARRAY
65342: PUSH
65343: LD_EXP 37
65347: PUSH
65348: LD_VAR 0 2
65352: ARRAY
65353: MINUS
65354: ST_TO_ADDR
// if k > list then
65355: LD_VAR 0 4
65359: PUSH
65360: LD_VAR 0 6
65364: GREATER
65365: IFFALSE 65377
// k := list ;
65367: LD_ADDR_VAR 0 4
65371: PUSH
65372: LD_VAR 0 6
65376: ST_TO_ADDR
// for j = 1 to k do
65377: LD_ADDR_VAR 0 3
65381: PUSH
65382: DOUBLE
65383: LD_INT 1
65385: DEC
65386: ST_TO_ADDR
65387: LD_VAR 0 4
65391: PUSH
65392: FOR_TO
65393: IFFALSE 65447
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
65395: LD_ADDR_EXP 37
65399: PUSH
65400: LD_EXP 37
65404: PPUSH
65405: LD_VAR 0 2
65409: PUSH
65410: LD_EXP 37
65414: PUSH
65415: LD_VAR 0 2
65419: ARRAY
65420: PUSH
65421: LD_INT 1
65423: PLUS
65424: PUSH
65425: EMPTY
65426: LIST
65427: LIST
65428: PPUSH
65429: LD_VAR 0 6
65433: PUSH
65434: LD_VAR 0 3
65438: ARRAY
65439: PPUSH
65440: CALL 16156 0 3
65444: ST_TO_ADDR
65445: GO 65392
65447: POP
65448: POP
// end ;
65449: GO 64700
65451: POP
65452: POP
// end ;
65453: LD_VAR 0 1
65457: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
65458: LD_INT 0
65460: PPUSH
65461: PPUSH
65462: PPUSH
65463: PPUSH
65464: PPUSH
65465: PPUSH
65466: PPUSH
65467: PPUSH
65468: PPUSH
65469: PPUSH
65470: PPUSH
// if not mc_bases then
65471: LD_EXP 23
65475: NOT
65476: IFFALSE 65480
// exit ;
65478: GO 67303
// for i = 1 to mc_bases do
65480: LD_ADDR_VAR 0 2
65484: PUSH
65485: DOUBLE
65486: LD_INT 1
65488: DEC
65489: ST_TO_ADDR
65490: LD_EXP 23
65494: PUSH
65495: FOR_TO
65496: IFFALSE 67301
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
65498: LD_EXP 23
65502: PUSH
65503: LD_VAR 0 2
65507: ARRAY
65508: NOT
65509: PUSH
65510: LD_EXP 30
65514: PUSH
65515: LD_VAR 0 2
65519: ARRAY
65520: OR
65521: IFFALSE 65525
// continue ;
65523: GO 65495
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
65525: LD_EXP 39
65529: PUSH
65530: LD_VAR 0 2
65534: ARRAY
65535: NOT
65536: PUSH
65537: LD_EXP 40
65541: PUSH
65542: LD_VAR 0 2
65546: ARRAY
65547: AND
65548: IFFALSE 65586
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
65550: LD_ADDR_EXP 40
65554: PUSH
65555: LD_EXP 40
65559: PPUSH
65560: LD_VAR 0 2
65564: PPUSH
65565: EMPTY
65566: PPUSH
65567: CALL_OW 1
65571: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
65572: LD_VAR 0 2
65576: PPUSH
65577: LD_INT 107
65579: PPUSH
65580: CALL 56358 0 2
// continue ;
65584: GO 65495
// end ; target := [ ] ;
65586: LD_ADDR_VAR 0 7
65590: PUSH
65591: EMPTY
65592: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
65593: LD_ADDR_VAR 0 6
65597: PUSH
65598: LD_EXP 23
65602: PUSH
65603: LD_VAR 0 2
65607: ARRAY
65608: PUSH
65609: LD_INT 1
65611: ARRAY
65612: PPUSH
65613: CALL_OW 255
65617: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65618: LD_ADDR_VAR 0 9
65622: PUSH
65623: LD_EXP 23
65627: PUSH
65628: LD_VAR 0 2
65632: ARRAY
65633: PPUSH
65634: LD_INT 2
65636: PUSH
65637: LD_INT 30
65639: PUSH
65640: LD_INT 0
65642: PUSH
65643: EMPTY
65644: LIST
65645: LIST
65646: PUSH
65647: LD_INT 30
65649: PUSH
65650: LD_INT 1
65652: PUSH
65653: EMPTY
65654: LIST
65655: LIST
65656: PUSH
65657: EMPTY
65658: LIST
65659: LIST
65660: LIST
65661: PPUSH
65662: CALL_OW 72
65666: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
65667: LD_ADDR_VAR 0 3
65671: PUSH
65672: DOUBLE
65673: LD_EXP 39
65677: PUSH
65678: LD_VAR 0 2
65682: ARRAY
65683: INC
65684: ST_TO_ADDR
65685: LD_INT 1
65687: PUSH
65688: FOR_DOWNTO
65689: IFFALSE 65934
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
65691: LD_EXP 39
65695: PUSH
65696: LD_VAR 0 2
65700: ARRAY
65701: PUSH
65702: LD_VAR 0 3
65706: ARRAY
65707: PUSH
65708: LD_INT 2
65710: ARRAY
65711: PPUSH
65712: LD_EXP 39
65716: PUSH
65717: LD_VAR 0 2
65721: ARRAY
65722: PUSH
65723: LD_VAR 0 3
65727: ARRAY
65728: PUSH
65729: LD_INT 3
65731: ARRAY
65732: PPUSH
65733: CALL_OW 488
65737: PUSH
65738: LD_EXP 39
65742: PUSH
65743: LD_VAR 0 2
65747: ARRAY
65748: PUSH
65749: LD_VAR 0 3
65753: ARRAY
65754: PUSH
65755: LD_INT 2
65757: ARRAY
65758: PPUSH
65759: LD_EXP 39
65763: PUSH
65764: LD_VAR 0 2
65768: ARRAY
65769: PUSH
65770: LD_VAR 0 3
65774: ARRAY
65775: PUSH
65776: LD_INT 3
65778: ARRAY
65779: PPUSH
65780: CALL_OW 284
65784: PUSH
65785: LD_INT 0
65787: EQUAL
65788: AND
65789: IFFALSE 65844
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
65791: LD_ADDR_VAR 0 5
65795: PUSH
65796: LD_EXP 39
65800: PUSH
65801: LD_VAR 0 2
65805: ARRAY
65806: PPUSH
65807: LD_VAR 0 3
65811: PPUSH
65812: CALL_OW 3
65816: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
65817: LD_ADDR_EXP 39
65821: PUSH
65822: LD_EXP 39
65826: PPUSH
65827: LD_VAR 0 2
65831: PPUSH
65832: LD_VAR 0 5
65836: PPUSH
65837: CALL_OW 1
65841: ST_TO_ADDR
// continue ;
65842: GO 65688
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
65844: LD_VAR 0 6
65848: PPUSH
65849: LD_EXP 39
65853: PUSH
65854: LD_VAR 0 2
65858: ARRAY
65859: PUSH
65860: LD_VAR 0 3
65864: ARRAY
65865: PUSH
65866: LD_INT 2
65868: ARRAY
65869: PPUSH
65870: LD_EXP 39
65874: PUSH
65875: LD_VAR 0 2
65879: ARRAY
65880: PUSH
65881: LD_VAR 0 3
65885: ARRAY
65886: PUSH
65887: LD_INT 3
65889: ARRAY
65890: PPUSH
65891: LD_INT 30
65893: PPUSH
65894: CALL 17052 0 4
65898: PUSH
65899: LD_INT 4
65901: ARRAY
65902: PUSH
65903: LD_INT 0
65905: EQUAL
65906: IFFALSE 65932
// begin target := mc_crates [ i ] [ j ] ;
65908: LD_ADDR_VAR 0 7
65912: PUSH
65913: LD_EXP 39
65917: PUSH
65918: LD_VAR 0 2
65922: ARRAY
65923: PUSH
65924: LD_VAR 0 3
65928: ARRAY
65929: ST_TO_ADDR
// break ;
65930: GO 65934
// end ; end ;
65932: GO 65688
65934: POP
65935: POP
// if not target then
65936: LD_VAR 0 7
65940: NOT
65941: IFFALSE 65945
// continue ;
65943: GO 65495
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
65945: LD_ADDR_VAR 0 8
65949: PUSH
65950: LD_EXP 42
65954: PUSH
65955: LD_VAR 0 2
65959: ARRAY
65960: PPUSH
65961: LD_INT 2
65963: PUSH
65964: LD_INT 3
65966: PUSH
65967: LD_INT 58
65969: PUSH
65970: EMPTY
65971: LIST
65972: PUSH
65973: EMPTY
65974: LIST
65975: LIST
65976: PUSH
65977: LD_INT 61
65979: PUSH
65980: EMPTY
65981: LIST
65982: PUSH
65983: LD_INT 33
65985: PUSH
65986: LD_INT 5
65988: PUSH
65989: EMPTY
65990: LIST
65991: LIST
65992: PUSH
65993: LD_INT 33
65995: PUSH
65996: LD_INT 3
65998: PUSH
65999: EMPTY
66000: LIST
66001: LIST
66002: PUSH
66003: EMPTY
66004: LIST
66005: LIST
66006: LIST
66007: LIST
66008: LIST
66009: PUSH
66010: LD_INT 2
66012: PUSH
66013: LD_INT 34
66015: PUSH
66016: LD_INT 32
66018: PUSH
66019: EMPTY
66020: LIST
66021: LIST
66022: PUSH
66023: LD_INT 34
66025: PUSH
66026: LD_INT 51
66028: PUSH
66029: EMPTY
66030: LIST
66031: LIST
66032: PUSH
66033: LD_INT 34
66035: PUSH
66036: LD_INT 12
66038: PUSH
66039: EMPTY
66040: LIST
66041: LIST
66042: PUSH
66043: EMPTY
66044: LIST
66045: LIST
66046: LIST
66047: LIST
66048: PUSH
66049: EMPTY
66050: LIST
66051: LIST
66052: PPUSH
66053: CALL_OW 72
66057: ST_TO_ADDR
// if not cargo then
66058: LD_VAR 0 8
66062: NOT
66063: IFFALSE 66769
// begin if mc_crates_collector [ i ] < 5 then
66065: LD_EXP 40
66069: PUSH
66070: LD_VAR 0 2
66074: ARRAY
66075: PUSH
66076: LD_INT 5
66078: LESS
66079: IFFALSE 66445
// begin if mc_ape [ i ] then
66081: LD_EXP 52
66085: PUSH
66086: LD_VAR 0 2
66090: ARRAY
66091: IFFALSE 66138
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
66093: LD_ADDR_VAR 0 5
66097: PUSH
66098: LD_EXP 52
66102: PUSH
66103: LD_VAR 0 2
66107: ARRAY
66108: PPUSH
66109: LD_INT 25
66111: PUSH
66112: LD_INT 16
66114: PUSH
66115: EMPTY
66116: LIST
66117: LIST
66118: PUSH
66119: LD_INT 24
66121: PUSH
66122: LD_INT 750
66124: PUSH
66125: EMPTY
66126: LIST
66127: LIST
66128: PUSH
66129: EMPTY
66130: LIST
66131: LIST
66132: PPUSH
66133: CALL_OW 72
66137: ST_TO_ADDR
// if not tmp then
66138: LD_VAR 0 5
66142: NOT
66143: IFFALSE 66190
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
66145: LD_ADDR_VAR 0 5
66149: PUSH
66150: LD_EXP 23
66154: PUSH
66155: LD_VAR 0 2
66159: ARRAY
66160: PPUSH
66161: LD_INT 25
66163: PUSH
66164: LD_INT 2
66166: PUSH
66167: EMPTY
66168: LIST
66169: LIST
66170: PUSH
66171: LD_INT 24
66173: PUSH
66174: LD_INT 750
66176: PUSH
66177: EMPTY
66178: LIST
66179: LIST
66180: PUSH
66181: EMPTY
66182: LIST
66183: LIST
66184: PPUSH
66185: CALL_OW 72
66189: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
66190: LD_EXP 52
66194: PUSH
66195: LD_VAR 0 2
66199: ARRAY
66200: PUSH
66201: LD_EXP 23
66205: PUSH
66206: LD_VAR 0 2
66210: ARRAY
66211: PPUSH
66212: LD_INT 25
66214: PUSH
66215: LD_INT 2
66217: PUSH
66218: EMPTY
66219: LIST
66220: LIST
66221: PUSH
66222: LD_INT 24
66224: PUSH
66225: LD_INT 750
66227: PUSH
66228: EMPTY
66229: LIST
66230: LIST
66231: PUSH
66232: EMPTY
66233: LIST
66234: LIST
66235: PPUSH
66236: CALL_OW 72
66240: AND
66241: PUSH
66242: LD_VAR 0 5
66246: PUSH
66247: LD_INT 5
66249: LESS
66250: AND
66251: IFFALSE 66333
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
66253: LD_ADDR_VAR 0 3
66257: PUSH
66258: LD_EXP 23
66262: PUSH
66263: LD_VAR 0 2
66267: ARRAY
66268: PPUSH
66269: LD_INT 25
66271: PUSH
66272: LD_INT 2
66274: PUSH
66275: EMPTY
66276: LIST
66277: LIST
66278: PUSH
66279: LD_INT 24
66281: PUSH
66282: LD_INT 750
66284: PUSH
66285: EMPTY
66286: LIST
66287: LIST
66288: PUSH
66289: EMPTY
66290: LIST
66291: LIST
66292: PPUSH
66293: CALL_OW 72
66297: PUSH
66298: FOR_IN
66299: IFFALSE 66331
// begin tmp := tmp union j ;
66301: LD_ADDR_VAR 0 5
66305: PUSH
66306: LD_VAR 0 5
66310: PUSH
66311: LD_VAR 0 3
66315: UNION
66316: ST_TO_ADDR
// if tmp >= 5 then
66317: LD_VAR 0 5
66321: PUSH
66322: LD_INT 5
66324: GREATEREQUAL
66325: IFFALSE 66329
// break ;
66327: GO 66331
// end ;
66329: GO 66298
66331: POP
66332: POP
// end ; if not tmp then
66333: LD_VAR 0 5
66337: NOT
66338: IFFALSE 66342
// continue ;
66340: GO 65495
// for j in tmp do
66342: LD_ADDR_VAR 0 3
66346: PUSH
66347: LD_VAR 0 5
66351: PUSH
66352: FOR_IN
66353: IFFALSE 66443
// if not GetTag ( j ) then
66355: LD_VAR 0 3
66359: PPUSH
66360: CALL_OW 110
66364: NOT
66365: IFFALSE 66441
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
66367: LD_ADDR_EXP 40
66371: PUSH
66372: LD_EXP 40
66376: PPUSH
66377: LD_VAR 0 2
66381: PUSH
66382: LD_EXP 40
66386: PUSH
66387: LD_VAR 0 2
66391: ARRAY
66392: PUSH
66393: LD_INT 1
66395: PLUS
66396: PUSH
66397: EMPTY
66398: LIST
66399: LIST
66400: PPUSH
66401: LD_VAR 0 3
66405: PPUSH
66406: CALL 16156 0 3
66410: ST_TO_ADDR
// SetTag ( j , 107 ) ;
66411: LD_VAR 0 3
66415: PPUSH
66416: LD_INT 107
66418: PPUSH
66419: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
66423: LD_EXP 40
66427: PUSH
66428: LD_VAR 0 2
66432: ARRAY
66433: PUSH
66434: LD_INT 5
66436: GREATEREQUAL
66437: IFFALSE 66441
// break ;
66439: GO 66443
// end ;
66441: GO 66352
66443: POP
66444: POP
// end ; if mc_crates_collector [ i ] and target then
66445: LD_EXP 40
66449: PUSH
66450: LD_VAR 0 2
66454: ARRAY
66455: PUSH
66456: LD_VAR 0 7
66460: AND
66461: IFFALSE 66767
// begin if mc_crates_collector [ i ] < target [ 1 ] then
66463: LD_EXP 40
66467: PUSH
66468: LD_VAR 0 2
66472: ARRAY
66473: PUSH
66474: LD_VAR 0 7
66478: PUSH
66479: LD_INT 1
66481: ARRAY
66482: LESS
66483: IFFALSE 66503
// tmp := mc_crates_collector [ i ] else
66485: LD_ADDR_VAR 0 5
66489: PUSH
66490: LD_EXP 40
66494: PUSH
66495: LD_VAR 0 2
66499: ARRAY
66500: ST_TO_ADDR
66501: GO 66517
// tmp := target [ 1 ] ;
66503: LD_ADDR_VAR 0 5
66507: PUSH
66508: LD_VAR 0 7
66512: PUSH
66513: LD_INT 1
66515: ARRAY
66516: ST_TO_ADDR
// k := 0 ;
66517: LD_ADDR_VAR 0 4
66521: PUSH
66522: LD_INT 0
66524: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
66525: LD_ADDR_VAR 0 3
66529: PUSH
66530: LD_EXP 40
66534: PUSH
66535: LD_VAR 0 2
66539: ARRAY
66540: PUSH
66541: FOR_IN
66542: IFFALSE 66765
// begin k := k + 1 ;
66544: LD_ADDR_VAR 0 4
66548: PUSH
66549: LD_VAR 0 4
66553: PUSH
66554: LD_INT 1
66556: PLUS
66557: ST_TO_ADDR
// if k > tmp then
66558: LD_VAR 0 4
66562: PUSH
66563: LD_VAR 0 5
66567: GREATER
66568: IFFALSE 66572
// break ;
66570: GO 66765
// if not GetClass ( j ) in [ 2 , 16 ] then
66572: LD_VAR 0 3
66576: PPUSH
66577: CALL_OW 257
66581: PUSH
66582: LD_INT 2
66584: PUSH
66585: LD_INT 16
66587: PUSH
66588: EMPTY
66589: LIST
66590: LIST
66591: IN
66592: NOT
66593: IFFALSE 66646
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
66595: LD_ADDR_EXP 40
66599: PUSH
66600: LD_EXP 40
66604: PPUSH
66605: LD_VAR 0 2
66609: PPUSH
66610: LD_EXP 40
66614: PUSH
66615: LD_VAR 0 2
66619: ARRAY
66620: PUSH
66621: LD_VAR 0 3
66625: DIFF
66626: PPUSH
66627: CALL_OW 1
66631: ST_TO_ADDR
// SetTag ( j , 0 ) ;
66632: LD_VAR 0 3
66636: PPUSH
66637: LD_INT 0
66639: PPUSH
66640: CALL_OW 109
// continue ;
66644: GO 66541
// end ; if IsInUnit ( j ) then
66646: LD_VAR 0 3
66650: PPUSH
66651: CALL_OW 310
66655: IFFALSE 66666
// ComExitBuilding ( j ) ;
66657: LD_VAR 0 3
66661: PPUSH
66662: CALL_OW 122
// wait ( 3 ) ;
66666: LD_INT 3
66668: PPUSH
66669: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
66673: LD_VAR 0 3
66677: PPUSH
66678: CALL_OW 314
66682: PUSH
66683: LD_VAR 0 6
66687: PPUSH
66688: LD_VAR 0 7
66692: PUSH
66693: LD_INT 2
66695: ARRAY
66696: PPUSH
66697: LD_VAR 0 7
66701: PUSH
66702: LD_INT 3
66704: ARRAY
66705: PPUSH
66706: LD_INT 30
66708: PPUSH
66709: CALL 17052 0 4
66713: PUSH
66714: LD_INT 4
66716: ARRAY
66717: AND
66718: IFFALSE 66736
// ComStandNearbyBuilding ( j , depot ) else
66720: LD_VAR 0 3
66724: PPUSH
66725: LD_VAR 0 9
66729: PPUSH
66730: CALL 12583 0 2
66734: GO 66763
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
66736: LD_VAR 0 3
66740: PPUSH
66741: LD_VAR 0 7
66745: PUSH
66746: LD_INT 2
66748: ARRAY
66749: PPUSH
66750: LD_VAR 0 7
66754: PUSH
66755: LD_INT 3
66757: ARRAY
66758: PPUSH
66759: CALL_OW 117
// end ;
66763: GO 66541
66765: POP
66766: POP
// end ; end else
66767: GO 67299
// begin for j in cargo do
66769: LD_ADDR_VAR 0 3
66773: PUSH
66774: LD_VAR 0 8
66778: PUSH
66779: FOR_IN
66780: IFFALSE 67297
// begin if GetTag ( j ) <> 0 then
66782: LD_VAR 0 3
66786: PPUSH
66787: CALL_OW 110
66791: PUSH
66792: LD_INT 0
66794: NONEQUAL
66795: IFFALSE 66799
// continue ;
66797: GO 66779
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
66799: LD_VAR 0 3
66803: PPUSH
66804: CALL_OW 256
66808: PUSH
66809: LD_INT 1000
66811: LESS
66812: PUSH
66813: LD_VAR 0 3
66817: PPUSH
66818: LD_EXP 47
66822: PUSH
66823: LD_VAR 0 2
66827: ARRAY
66828: PPUSH
66829: CALL_OW 308
66833: NOT
66834: AND
66835: IFFALSE 66857
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66837: LD_VAR 0 3
66841: PPUSH
66842: LD_EXP 47
66846: PUSH
66847: LD_VAR 0 2
66851: ARRAY
66852: PPUSH
66853: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
66857: LD_VAR 0 3
66861: PPUSH
66862: CALL_OW 256
66866: PUSH
66867: LD_INT 1000
66869: LESS
66870: PUSH
66871: LD_VAR 0 3
66875: PPUSH
66876: LD_EXP 47
66880: PUSH
66881: LD_VAR 0 2
66885: ARRAY
66886: PPUSH
66887: CALL_OW 308
66891: AND
66892: IFFALSE 66896
// continue ;
66894: GO 66779
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
66896: LD_VAR 0 3
66900: PPUSH
66901: CALL_OW 262
66905: PUSH
66906: LD_INT 2
66908: EQUAL
66909: PUSH
66910: LD_VAR 0 3
66914: PPUSH
66915: CALL_OW 261
66919: PUSH
66920: LD_INT 15
66922: LESS
66923: AND
66924: IFFALSE 66928
// continue ;
66926: GO 66779
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
66928: LD_VAR 0 3
66932: PPUSH
66933: CALL_OW 262
66937: PUSH
66938: LD_INT 1
66940: EQUAL
66941: PUSH
66942: LD_VAR 0 3
66946: PPUSH
66947: CALL_OW 261
66951: PUSH
66952: LD_INT 10
66954: LESS
66955: AND
66956: IFFALSE 67236
// begin if not depot then
66958: LD_VAR 0 9
66962: NOT
66963: IFFALSE 66967
// continue ;
66965: GO 66779
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
66967: LD_VAR 0 3
66971: PPUSH
66972: LD_VAR 0 9
66976: PPUSH
66977: LD_VAR 0 3
66981: PPUSH
66982: CALL_OW 74
66986: PPUSH
66987: CALL_OW 296
66991: PUSH
66992: LD_INT 6
66994: LESS
66995: IFFALSE 67011
// SetFuel ( j , 100 ) else
66997: LD_VAR 0 3
67001: PPUSH
67002: LD_INT 100
67004: PPUSH
67005: CALL_OW 240
67009: GO 67236
// if GetFuel ( j ) = 0 then
67011: LD_VAR 0 3
67015: PPUSH
67016: CALL_OW 261
67020: PUSH
67021: LD_INT 0
67023: EQUAL
67024: IFFALSE 67236
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
67026: LD_ADDR_EXP 42
67030: PUSH
67031: LD_EXP 42
67035: PPUSH
67036: LD_VAR 0 2
67040: PPUSH
67041: LD_EXP 42
67045: PUSH
67046: LD_VAR 0 2
67050: ARRAY
67051: PUSH
67052: LD_VAR 0 3
67056: DIFF
67057: PPUSH
67058: CALL_OW 1
67062: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
67063: LD_VAR 0 3
67067: PPUSH
67068: CALL_OW 263
67072: PUSH
67073: LD_INT 1
67075: EQUAL
67076: IFFALSE 67092
// ComExitVehicle ( IsInUnit ( j ) ) ;
67078: LD_VAR 0 3
67082: PPUSH
67083: CALL_OW 310
67087: PPUSH
67088: CALL_OW 121
// if GetControl ( j ) = control_remote then
67092: LD_VAR 0 3
67096: PPUSH
67097: CALL_OW 263
67101: PUSH
67102: LD_INT 2
67104: EQUAL
67105: IFFALSE 67116
// ComUnlink ( j ) ;
67107: LD_VAR 0 3
67111: PPUSH
67112: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
67116: LD_ADDR_VAR 0 10
67120: PUSH
67121: LD_VAR 0 2
67125: PPUSH
67126: LD_INT 3
67128: PPUSH
67129: CALL 76875 0 2
67133: ST_TO_ADDR
// if fac then
67134: LD_VAR 0 10
67138: IFFALSE 67234
// begin for k in fac do
67140: LD_ADDR_VAR 0 4
67144: PUSH
67145: LD_VAR 0 10
67149: PUSH
67150: FOR_IN
67151: IFFALSE 67232
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
67153: LD_ADDR_VAR 0 11
67157: PUSH
67158: LD_VAR 0 10
67162: PPUSH
67163: LD_VAR 0 3
67167: PPUSH
67168: CALL_OW 265
67172: PPUSH
67173: LD_VAR 0 3
67177: PPUSH
67178: CALL_OW 262
67182: PPUSH
67183: LD_VAR 0 3
67187: PPUSH
67188: CALL_OW 263
67192: PPUSH
67193: LD_VAR 0 3
67197: PPUSH
67198: CALL_OW 264
67202: PPUSH
67203: CALL 13654 0 5
67207: ST_TO_ADDR
// if components then
67208: LD_VAR 0 11
67212: IFFALSE 67230
// begin MC_InsertProduceList ( i , components ) ;
67214: LD_VAR 0 2
67218: PPUSH
67219: LD_VAR 0 11
67223: PPUSH
67224: CALL 76420 0 2
// break ;
67228: GO 67232
// end ; end ;
67230: GO 67150
67232: POP
67233: POP
// end ; continue ;
67234: GO 66779
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
67236: LD_VAR 0 3
67240: PPUSH
67241: LD_INT 1
67243: PPUSH
67244: CALL_OW 289
67248: PUSH
67249: LD_INT 100
67251: LESS
67252: PUSH
67253: LD_VAR 0 3
67257: PPUSH
67258: CALL_OW 314
67262: NOT
67263: AND
67264: IFFALSE 67293
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
67266: LD_VAR 0 3
67270: PPUSH
67271: LD_VAR 0 7
67275: PUSH
67276: LD_INT 2
67278: ARRAY
67279: PPUSH
67280: LD_VAR 0 7
67284: PUSH
67285: LD_INT 3
67287: ARRAY
67288: PPUSH
67289: CALL_OW 117
// break ;
67293: GO 67297
// end ;
67295: GO 66779
67297: POP
67298: POP
// end ; end ;
67299: GO 65495
67301: POP
67302: POP
// end ;
67303: LD_VAR 0 1
67307: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
67308: LD_INT 0
67310: PPUSH
67311: PPUSH
67312: PPUSH
67313: PPUSH
// if not mc_bases then
67314: LD_EXP 23
67318: NOT
67319: IFFALSE 67323
// exit ;
67321: GO 67484
// for i = 1 to mc_bases do
67323: LD_ADDR_VAR 0 2
67327: PUSH
67328: DOUBLE
67329: LD_INT 1
67331: DEC
67332: ST_TO_ADDR
67333: LD_EXP 23
67337: PUSH
67338: FOR_TO
67339: IFFALSE 67482
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
67341: LD_ADDR_VAR 0 4
67345: PUSH
67346: LD_EXP 42
67350: PUSH
67351: LD_VAR 0 2
67355: ARRAY
67356: PUSH
67357: LD_EXP 45
67361: PUSH
67362: LD_VAR 0 2
67366: ARRAY
67367: UNION
67368: PPUSH
67369: LD_INT 33
67371: PUSH
67372: LD_INT 2
67374: PUSH
67375: EMPTY
67376: LIST
67377: LIST
67378: PPUSH
67379: CALL_OW 72
67383: ST_TO_ADDR
// if tmp then
67384: LD_VAR 0 4
67388: IFFALSE 67480
// for j in tmp do
67390: LD_ADDR_VAR 0 3
67394: PUSH
67395: LD_VAR 0 4
67399: PUSH
67400: FOR_IN
67401: IFFALSE 67478
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
67403: LD_VAR 0 3
67407: PPUSH
67408: CALL_OW 312
67412: NOT
67413: PUSH
67414: LD_VAR 0 3
67418: PPUSH
67419: CALL_OW 256
67423: PUSH
67424: LD_INT 250
67426: GREATEREQUAL
67427: AND
67428: IFFALSE 67441
// Connect ( j ) else
67430: LD_VAR 0 3
67434: PPUSH
67435: CALL 19125 0 1
67439: GO 67476
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
67441: LD_VAR 0 3
67445: PPUSH
67446: CALL_OW 256
67450: PUSH
67451: LD_INT 250
67453: LESS
67454: PUSH
67455: LD_VAR 0 3
67459: PPUSH
67460: CALL_OW 312
67464: AND
67465: IFFALSE 67476
// ComUnlink ( j ) ;
67467: LD_VAR 0 3
67471: PPUSH
67472: CALL_OW 136
67476: GO 67400
67478: POP
67479: POP
// end ;
67480: GO 67338
67482: POP
67483: POP
// end ;
67484: LD_VAR 0 1
67488: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
67489: LD_INT 0
67491: PPUSH
67492: PPUSH
67493: PPUSH
67494: PPUSH
67495: PPUSH
// if not mc_bases then
67496: LD_EXP 23
67500: NOT
67501: IFFALSE 67505
// exit ;
67503: GO 67950
// for i = 1 to mc_bases do
67505: LD_ADDR_VAR 0 2
67509: PUSH
67510: DOUBLE
67511: LD_INT 1
67513: DEC
67514: ST_TO_ADDR
67515: LD_EXP 23
67519: PUSH
67520: FOR_TO
67521: IFFALSE 67948
// begin if not mc_produce [ i ] then
67523: LD_EXP 44
67527: PUSH
67528: LD_VAR 0 2
67532: ARRAY
67533: NOT
67534: IFFALSE 67538
// continue ;
67536: GO 67520
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
67538: LD_ADDR_VAR 0 5
67542: PUSH
67543: LD_EXP 23
67547: PUSH
67548: LD_VAR 0 2
67552: ARRAY
67553: PPUSH
67554: LD_INT 30
67556: PUSH
67557: LD_INT 3
67559: PUSH
67560: EMPTY
67561: LIST
67562: LIST
67563: PPUSH
67564: CALL_OW 72
67568: ST_TO_ADDR
// if not fac then
67569: LD_VAR 0 5
67573: NOT
67574: IFFALSE 67578
// continue ;
67576: GO 67520
// for j in fac do
67578: LD_ADDR_VAR 0 3
67582: PUSH
67583: LD_VAR 0 5
67587: PUSH
67588: FOR_IN
67589: IFFALSE 67944
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
67591: LD_VAR 0 3
67595: PPUSH
67596: CALL_OW 461
67600: PUSH
67601: LD_INT 2
67603: NONEQUAL
67604: PUSH
67605: LD_VAR 0 3
67609: PPUSH
67610: LD_INT 15
67612: PPUSH
67613: CALL 18753 0 2
67617: PUSH
67618: LD_INT 4
67620: ARRAY
67621: OR
67622: IFFALSE 67626
// continue ;
67624: GO 67588
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
67626: LD_VAR 0 3
67630: PPUSH
67631: LD_EXP 44
67635: PUSH
67636: LD_VAR 0 2
67640: ARRAY
67641: PUSH
67642: LD_INT 1
67644: ARRAY
67645: PUSH
67646: LD_INT 1
67648: ARRAY
67649: PPUSH
67650: LD_EXP 44
67654: PUSH
67655: LD_VAR 0 2
67659: ARRAY
67660: PUSH
67661: LD_INT 1
67663: ARRAY
67664: PUSH
67665: LD_INT 2
67667: ARRAY
67668: PPUSH
67669: LD_EXP 44
67673: PUSH
67674: LD_VAR 0 2
67678: ARRAY
67679: PUSH
67680: LD_INT 1
67682: ARRAY
67683: PUSH
67684: LD_INT 3
67686: ARRAY
67687: PPUSH
67688: LD_EXP 44
67692: PUSH
67693: LD_VAR 0 2
67697: ARRAY
67698: PUSH
67699: LD_INT 1
67701: ARRAY
67702: PUSH
67703: LD_INT 4
67705: ARRAY
67706: PPUSH
67707: CALL_OW 448
67711: PUSH
67712: LD_VAR 0 3
67716: PPUSH
67717: LD_EXP 44
67721: PUSH
67722: LD_VAR 0 2
67726: ARRAY
67727: PUSH
67728: LD_INT 1
67730: ARRAY
67731: PUSH
67732: LD_INT 1
67734: ARRAY
67735: PUSH
67736: LD_EXP 44
67740: PUSH
67741: LD_VAR 0 2
67745: ARRAY
67746: PUSH
67747: LD_INT 1
67749: ARRAY
67750: PUSH
67751: LD_INT 2
67753: ARRAY
67754: PUSH
67755: LD_EXP 44
67759: PUSH
67760: LD_VAR 0 2
67764: ARRAY
67765: PUSH
67766: LD_INT 1
67768: ARRAY
67769: PUSH
67770: LD_INT 3
67772: ARRAY
67773: PUSH
67774: LD_EXP 44
67778: PUSH
67779: LD_VAR 0 2
67783: ARRAY
67784: PUSH
67785: LD_INT 1
67787: ARRAY
67788: PUSH
67789: LD_INT 4
67791: ARRAY
67792: PUSH
67793: EMPTY
67794: LIST
67795: LIST
67796: LIST
67797: LIST
67798: PPUSH
67799: CALL 22520 0 2
67803: AND
67804: IFFALSE 67942
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
67806: LD_VAR 0 3
67810: PPUSH
67811: LD_EXP 44
67815: PUSH
67816: LD_VAR 0 2
67820: ARRAY
67821: PUSH
67822: LD_INT 1
67824: ARRAY
67825: PUSH
67826: LD_INT 1
67828: ARRAY
67829: PPUSH
67830: LD_EXP 44
67834: PUSH
67835: LD_VAR 0 2
67839: ARRAY
67840: PUSH
67841: LD_INT 1
67843: ARRAY
67844: PUSH
67845: LD_INT 2
67847: ARRAY
67848: PPUSH
67849: LD_EXP 44
67853: PUSH
67854: LD_VAR 0 2
67858: ARRAY
67859: PUSH
67860: LD_INT 1
67862: ARRAY
67863: PUSH
67864: LD_INT 3
67866: ARRAY
67867: PPUSH
67868: LD_EXP 44
67872: PUSH
67873: LD_VAR 0 2
67877: ARRAY
67878: PUSH
67879: LD_INT 1
67881: ARRAY
67882: PUSH
67883: LD_INT 4
67885: ARRAY
67886: PPUSH
67887: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
67891: LD_ADDR_VAR 0 4
67895: PUSH
67896: LD_EXP 44
67900: PUSH
67901: LD_VAR 0 2
67905: ARRAY
67906: PPUSH
67907: LD_INT 1
67909: PPUSH
67910: CALL_OW 3
67914: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
67915: LD_ADDR_EXP 44
67919: PUSH
67920: LD_EXP 44
67924: PPUSH
67925: LD_VAR 0 2
67929: PPUSH
67930: LD_VAR 0 4
67934: PPUSH
67935: CALL_OW 1
67939: ST_TO_ADDR
// break ;
67940: GO 67944
// end ; end ;
67942: GO 67588
67944: POP
67945: POP
// end ;
67946: GO 67520
67948: POP
67949: POP
// end ;
67950: LD_VAR 0 1
67954: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
67955: LD_INT 0
67957: PPUSH
67958: PPUSH
67959: PPUSH
// if not mc_bases then
67960: LD_EXP 23
67964: NOT
67965: IFFALSE 67969
// exit ;
67967: GO 68058
// for i = 1 to mc_bases do
67969: LD_ADDR_VAR 0 2
67973: PUSH
67974: DOUBLE
67975: LD_INT 1
67977: DEC
67978: ST_TO_ADDR
67979: LD_EXP 23
67983: PUSH
67984: FOR_TO
67985: IFFALSE 68056
// begin if mc_attack [ i ] then
67987: LD_EXP 43
67991: PUSH
67992: LD_VAR 0 2
67996: ARRAY
67997: IFFALSE 68054
// begin tmp := mc_attack [ i ] [ 1 ] ;
67999: LD_ADDR_VAR 0 3
68003: PUSH
68004: LD_EXP 43
68008: PUSH
68009: LD_VAR 0 2
68013: ARRAY
68014: PUSH
68015: LD_INT 1
68017: ARRAY
68018: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
68019: LD_ADDR_EXP 43
68023: PUSH
68024: LD_EXP 43
68028: PPUSH
68029: LD_VAR 0 2
68033: PPUSH
68034: EMPTY
68035: PPUSH
68036: CALL_OW 1
68040: ST_TO_ADDR
// Attack ( tmp ) ;
68041: LD_VAR 0 3
68045: PPUSH
68046: CALL 82808 0 1
// exit ;
68050: POP
68051: POP
68052: GO 68058
// end ; end ;
68054: GO 67984
68056: POP
68057: POP
// end ;
68058: LD_VAR 0 1
68062: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
68063: LD_INT 0
68065: PPUSH
68066: PPUSH
68067: PPUSH
68068: PPUSH
68069: PPUSH
68070: PPUSH
68071: PPUSH
// if not mc_bases then
68072: LD_EXP 23
68076: NOT
68077: IFFALSE 68081
// exit ;
68079: GO 68938
// for i = 1 to mc_bases do
68081: LD_ADDR_VAR 0 2
68085: PUSH
68086: DOUBLE
68087: LD_INT 1
68089: DEC
68090: ST_TO_ADDR
68091: LD_EXP 23
68095: PUSH
68096: FOR_TO
68097: IFFALSE 68936
// begin if not mc_bases [ i ] then
68099: LD_EXP 23
68103: PUSH
68104: LD_VAR 0 2
68108: ARRAY
68109: NOT
68110: IFFALSE 68114
// continue ;
68112: GO 68096
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
68114: LD_ADDR_VAR 0 7
68118: PUSH
68119: LD_EXP 23
68123: PUSH
68124: LD_VAR 0 2
68128: ARRAY
68129: PUSH
68130: LD_INT 1
68132: ARRAY
68133: PPUSH
68134: CALL 12805 0 1
68138: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
68139: LD_ADDR_EXP 46
68143: PUSH
68144: LD_EXP 46
68148: PPUSH
68149: LD_VAR 0 2
68153: PPUSH
68154: LD_EXP 23
68158: PUSH
68159: LD_VAR 0 2
68163: ARRAY
68164: PUSH
68165: LD_INT 1
68167: ARRAY
68168: PPUSH
68169: CALL_OW 255
68173: PPUSH
68174: LD_EXP 48
68178: PUSH
68179: LD_VAR 0 2
68183: ARRAY
68184: PPUSH
68185: CALL 12770 0 2
68189: PPUSH
68190: CALL_OW 1
68194: ST_TO_ADDR
// if not mc_scan [ i ] then
68195: LD_EXP 46
68199: PUSH
68200: LD_VAR 0 2
68204: ARRAY
68205: NOT
68206: IFFALSE 68384
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
68208: LD_ADDR_EXP 66
68212: PUSH
68213: LD_EXP 66
68217: PPUSH
68218: LD_VAR 0 2
68222: PPUSH
68223: LD_INT 0
68225: PPUSH
68226: CALL_OW 1
68230: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
68231: LD_ADDR_VAR 0 4
68235: PUSH
68236: LD_EXP 23
68240: PUSH
68241: LD_VAR 0 2
68245: ARRAY
68246: PPUSH
68247: LD_INT 2
68249: PUSH
68250: LD_INT 25
68252: PUSH
68253: LD_INT 5
68255: PUSH
68256: EMPTY
68257: LIST
68258: LIST
68259: PUSH
68260: LD_INT 25
68262: PUSH
68263: LD_INT 8
68265: PUSH
68266: EMPTY
68267: LIST
68268: LIST
68269: PUSH
68270: LD_INT 25
68272: PUSH
68273: LD_INT 9
68275: PUSH
68276: EMPTY
68277: LIST
68278: LIST
68279: PUSH
68280: EMPTY
68281: LIST
68282: LIST
68283: LIST
68284: LIST
68285: PPUSH
68286: CALL_OW 72
68290: ST_TO_ADDR
// if not tmp then
68291: LD_VAR 0 4
68295: NOT
68296: IFFALSE 68300
// continue ;
68298: GO 68096
// for j in tmp do
68300: LD_ADDR_VAR 0 3
68304: PUSH
68305: LD_VAR 0 4
68309: PUSH
68310: FOR_IN
68311: IFFALSE 68382
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
68313: LD_VAR 0 3
68317: PPUSH
68318: CALL_OW 310
68322: PPUSH
68323: CALL_OW 266
68327: PUSH
68328: LD_INT 5
68330: EQUAL
68331: PUSH
68332: LD_VAR 0 3
68336: PPUSH
68337: CALL_OW 257
68341: PUSH
68342: LD_INT 1
68344: EQUAL
68345: AND
68346: PUSH
68347: LD_VAR 0 3
68351: PPUSH
68352: CALL_OW 459
68356: NOT
68357: AND
68358: PUSH
68359: LD_VAR 0 7
68363: AND
68364: IFFALSE 68380
// ComChangeProfession ( j , class ) ;
68366: LD_VAR 0 3
68370: PPUSH
68371: LD_VAR 0 7
68375: PPUSH
68376: CALL_OW 123
68380: GO 68310
68382: POP
68383: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
68384: LD_EXP 46
68388: PUSH
68389: LD_VAR 0 2
68393: ARRAY
68394: PUSH
68395: LD_EXP 66
68399: PUSH
68400: LD_VAR 0 2
68404: ARRAY
68405: NOT
68406: AND
68407: PUSH
68408: LD_EXP 45
68412: PUSH
68413: LD_VAR 0 2
68417: ARRAY
68418: NOT
68419: AND
68420: PUSH
68421: LD_EXP 23
68425: PUSH
68426: LD_VAR 0 2
68430: ARRAY
68431: PPUSH
68432: LD_INT 50
68434: PUSH
68435: EMPTY
68436: LIST
68437: PUSH
68438: LD_INT 2
68440: PUSH
68441: LD_INT 30
68443: PUSH
68444: LD_INT 32
68446: PUSH
68447: EMPTY
68448: LIST
68449: LIST
68450: PUSH
68451: LD_INT 30
68453: PUSH
68454: LD_INT 33
68456: PUSH
68457: EMPTY
68458: LIST
68459: LIST
68460: PUSH
68461: LD_INT 30
68463: PUSH
68464: LD_INT 4
68466: PUSH
68467: EMPTY
68468: LIST
68469: LIST
68470: PUSH
68471: LD_INT 30
68473: PUSH
68474: LD_INT 5
68476: PUSH
68477: EMPTY
68478: LIST
68479: LIST
68480: PUSH
68481: EMPTY
68482: LIST
68483: LIST
68484: LIST
68485: LIST
68486: LIST
68487: PUSH
68488: EMPTY
68489: LIST
68490: LIST
68491: PPUSH
68492: CALL_OW 72
68496: PUSH
68497: LD_INT 4
68499: LESS
68500: PUSH
68501: LD_EXP 23
68505: PUSH
68506: LD_VAR 0 2
68510: ARRAY
68511: PPUSH
68512: LD_INT 3
68514: PUSH
68515: LD_INT 24
68517: PUSH
68518: LD_INT 1000
68520: PUSH
68521: EMPTY
68522: LIST
68523: LIST
68524: PUSH
68525: EMPTY
68526: LIST
68527: LIST
68528: PUSH
68529: LD_INT 2
68531: PUSH
68532: LD_INT 30
68534: PUSH
68535: LD_INT 0
68537: PUSH
68538: EMPTY
68539: LIST
68540: LIST
68541: PUSH
68542: LD_INT 30
68544: PUSH
68545: LD_INT 1
68547: PUSH
68548: EMPTY
68549: LIST
68550: LIST
68551: PUSH
68552: EMPTY
68553: LIST
68554: LIST
68555: LIST
68556: PUSH
68557: EMPTY
68558: LIST
68559: LIST
68560: PPUSH
68561: CALL_OW 72
68565: OR
68566: AND
68567: IFFALSE 68818
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
68569: LD_ADDR_EXP 66
68573: PUSH
68574: LD_EXP 66
68578: PPUSH
68579: LD_VAR 0 2
68583: PPUSH
68584: LD_INT 1
68586: PPUSH
68587: CALL_OW 1
68591: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
68592: LD_ADDR_VAR 0 4
68596: PUSH
68597: LD_EXP 23
68601: PUSH
68602: LD_VAR 0 2
68606: ARRAY
68607: PPUSH
68608: LD_INT 2
68610: PUSH
68611: LD_INT 25
68613: PUSH
68614: LD_INT 1
68616: PUSH
68617: EMPTY
68618: LIST
68619: LIST
68620: PUSH
68621: LD_INT 25
68623: PUSH
68624: LD_INT 5
68626: PUSH
68627: EMPTY
68628: LIST
68629: LIST
68630: PUSH
68631: LD_INT 25
68633: PUSH
68634: LD_INT 8
68636: PUSH
68637: EMPTY
68638: LIST
68639: LIST
68640: PUSH
68641: LD_INT 25
68643: PUSH
68644: LD_INT 9
68646: PUSH
68647: EMPTY
68648: LIST
68649: LIST
68650: PUSH
68651: EMPTY
68652: LIST
68653: LIST
68654: LIST
68655: LIST
68656: LIST
68657: PPUSH
68658: CALL_OW 72
68662: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
68663: LD_ADDR_VAR 0 4
68667: PUSH
68668: LD_VAR 0 4
68672: PUSH
68673: LD_VAR 0 4
68677: PPUSH
68678: LD_INT 18
68680: PPUSH
68681: CALL 45969 0 2
68685: DIFF
68686: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
68687: LD_VAR 0 4
68691: NOT
68692: PUSH
68693: LD_EXP 23
68697: PUSH
68698: LD_VAR 0 2
68702: ARRAY
68703: PPUSH
68704: LD_INT 2
68706: PUSH
68707: LD_INT 30
68709: PUSH
68710: LD_INT 4
68712: PUSH
68713: EMPTY
68714: LIST
68715: LIST
68716: PUSH
68717: LD_INT 30
68719: PUSH
68720: LD_INT 5
68722: PUSH
68723: EMPTY
68724: LIST
68725: LIST
68726: PUSH
68727: EMPTY
68728: LIST
68729: LIST
68730: LIST
68731: PPUSH
68732: CALL_OW 72
68736: NOT
68737: AND
68738: IFFALSE 68800
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
68740: LD_ADDR_VAR 0 4
68744: PUSH
68745: LD_EXP 23
68749: PUSH
68750: LD_VAR 0 2
68754: ARRAY
68755: PPUSH
68756: LD_INT 2
68758: PUSH
68759: LD_INT 25
68761: PUSH
68762: LD_INT 2
68764: PUSH
68765: EMPTY
68766: LIST
68767: LIST
68768: PUSH
68769: LD_INT 25
68771: PUSH
68772: LD_INT 3
68774: PUSH
68775: EMPTY
68776: LIST
68777: LIST
68778: PUSH
68779: LD_INT 25
68781: PUSH
68782: LD_INT 4
68784: PUSH
68785: EMPTY
68786: LIST
68787: LIST
68788: PUSH
68789: EMPTY
68790: LIST
68791: LIST
68792: LIST
68793: LIST
68794: PPUSH
68795: CALL_OW 72
68799: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
68800: LD_VAR 0 2
68804: PPUSH
68805: LD_VAR 0 4
68809: PPUSH
68810: CALL 87517 0 2
// exit ;
68814: POP
68815: POP
68816: GO 68938
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
68818: LD_EXP 46
68822: PUSH
68823: LD_VAR 0 2
68827: ARRAY
68828: PUSH
68829: LD_EXP 66
68833: PUSH
68834: LD_VAR 0 2
68838: ARRAY
68839: NOT
68840: AND
68841: PUSH
68842: LD_EXP 45
68846: PUSH
68847: LD_VAR 0 2
68851: ARRAY
68852: AND
68853: IFFALSE 68934
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
68855: LD_ADDR_EXP 66
68859: PUSH
68860: LD_EXP 66
68864: PPUSH
68865: LD_VAR 0 2
68869: PPUSH
68870: LD_INT 1
68872: PPUSH
68873: CALL_OW 1
68877: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
68878: LD_ADDR_VAR 0 4
68882: PUSH
68883: LD_EXP 45
68887: PUSH
68888: LD_VAR 0 2
68892: ARRAY
68893: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
68894: LD_ADDR_EXP 45
68898: PUSH
68899: LD_EXP 45
68903: PPUSH
68904: LD_VAR 0 2
68908: PPUSH
68909: EMPTY
68910: PPUSH
68911: CALL_OW 1
68915: ST_TO_ADDR
// Defend ( i , tmp ) ;
68916: LD_VAR 0 2
68920: PPUSH
68921: LD_VAR 0 4
68925: PPUSH
68926: CALL 88113 0 2
// exit ;
68930: POP
68931: POP
68932: GO 68938
// end ; end ;
68934: GO 68096
68936: POP
68937: POP
// end ;
68938: LD_VAR 0 1
68942: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
68943: LD_INT 0
68945: PPUSH
68946: PPUSH
68947: PPUSH
68948: PPUSH
68949: PPUSH
68950: PPUSH
68951: PPUSH
68952: PPUSH
68953: PPUSH
68954: PPUSH
68955: PPUSH
// if not mc_bases then
68956: LD_EXP 23
68960: NOT
68961: IFFALSE 68965
// exit ;
68963: GO 70052
// for i = 1 to mc_bases do
68965: LD_ADDR_VAR 0 2
68969: PUSH
68970: DOUBLE
68971: LD_INT 1
68973: DEC
68974: ST_TO_ADDR
68975: LD_EXP 23
68979: PUSH
68980: FOR_TO
68981: IFFALSE 70050
// begin tmp := mc_lab [ i ] ;
68983: LD_ADDR_VAR 0 6
68987: PUSH
68988: LD_EXP 56
68992: PUSH
68993: LD_VAR 0 2
68997: ARRAY
68998: ST_TO_ADDR
// if not tmp then
68999: LD_VAR 0 6
69003: NOT
69004: IFFALSE 69008
// continue ;
69006: GO 68980
// idle_lab := 0 ;
69008: LD_ADDR_VAR 0 11
69012: PUSH
69013: LD_INT 0
69015: ST_TO_ADDR
// for j in tmp do
69016: LD_ADDR_VAR 0 3
69020: PUSH
69021: LD_VAR 0 6
69025: PUSH
69026: FOR_IN
69027: IFFALSE 70046
// begin researching := false ;
69029: LD_ADDR_VAR 0 10
69033: PUSH
69034: LD_INT 0
69036: ST_TO_ADDR
// side := GetSide ( j ) ;
69037: LD_ADDR_VAR 0 4
69041: PUSH
69042: LD_VAR 0 3
69046: PPUSH
69047: CALL_OW 255
69051: ST_TO_ADDR
// if not mc_tech [ side ] then
69052: LD_EXP 50
69056: PUSH
69057: LD_VAR 0 4
69061: ARRAY
69062: NOT
69063: IFFALSE 69067
// continue ;
69065: GO 69026
// if BuildingStatus ( j ) = bs_idle then
69067: LD_VAR 0 3
69071: PPUSH
69072: CALL_OW 461
69076: PUSH
69077: LD_INT 2
69079: EQUAL
69080: IFFALSE 69268
// begin if idle_lab and UnitsInside ( j ) < 6 then
69082: LD_VAR 0 11
69086: PUSH
69087: LD_VAR 0 3
69091: PPUSH
69092: CALL_OW 313
69096: PUSH
69097: LD_INT 6
69099: LESS
69100: AND
69101: IFFALSE 69172
// begin tmp2 := UnitsInside ( idle_lab ) ;
69103: LD_ADDR_VAR 0 9
69107: PUSH
69108: LD_VAR 0 11
69112: PPUSH
69113: CALL_OW 313
69117: ST_TO_ADDR
// if tmp2 then
69118: LD_VAR 0 9
69122: IFFALSE 69164
// for x in tmp2 do
69124: LD_ADDR_VAR 0 7
69128: PUSH
69129: LD_VAR 0 9
69133: PUSH
69134: FOR_IN
69135: IFFALSE 69162
// begin ComExitBuilding ( x ) ;
69137: LD_VAR 0 7
69141: PPUSH
69142: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
69146: LD_VAR 0 7
69150: PPUSH
69151: LD_VAR 0 3
69155: PPUSH
69156: CALL_OW 180
// end ;
69160: GO 69134
69162: POP
69163: POP
// idle_lab := 0 ;
69164: LD_ADDR_VAR 0 11
69168: PUSH
69169: LD_INT 0
69171: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
69172: LD_ADDR_VAR 0 5
69176: PUSH
69177: LD_EXP 50
69181: PUSH
69182: LD_VAR 0 4
69186: ARRAY
69187: PUSH
69188: FOR_IN
69189: IFFALSE 69249
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
69191: LD_VAR 0 3
69195: PPUSH
69196: LD_VAR 0 5
69200: PPUSH
69201: CALL_OW 430
69205: PUSH
69206: LD_VAR 0 4
69210: PPUSH
69211: LD_VAR 0 5
69215: PPUSH
69216: CALL 11875 0 2
69220: AND
69221: IFFALSE 69247
// begin researching := true ;
69223: LD_ADDR_VAR 0 10
69227: PUSH
69228: LD_INT 1
69230: ST_TO_ADDR
// ComResearch ( j , t ) ;
69231: LD_VAR 0 3
69235: PPUSH
69236: LD_VAR 0 5
69240: PPUSH
69241: CALL_OW 124
// break ;
69245: GO 69249
// end ;
69247: GO 69188
69249: POP
69250: POP
// if not researching then
69251: LD_VAR 0 10
69255: NOT
69256: IFFALSE 69268
// idle_lab := j ;
69258: LD_ADDR_VAR 0 11
69262: PUSH
69263: LD_VAR 0 3
69267: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
69268: LD_VAR 0 3
69272: PPUSH
69273: CALL_OW 461
69277: PUSH
69278: LD_INT 10
69280: EQUAL
69281: IFFALSE 69869
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
69283: LD_EXP 52
69287: PUSH
69288: LD_VAR 0 2
69292: ARRAY
69293: NOT
69294: PUSH
69295: LD_EXP 53
69299: PUSH
69300: LD_VAR 0 2
69304: ARRAY
69305: NOT
69306: AND
69307: PUSH
69308: LD_EXP 50
69312: PUSH
69313: LD_VAR 0 4
69317: ARRAY
69318: PUSH
69319: LD_INT 1
69321: GREATER
69322: AND
69323: IFFALSE 69454
// begin ComCancel ( j ) ;
69325: LD_VAR 0 3
69329: PPUSH
69330: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
69334: LD_ADDR_EXP 50
69338: PUSH
69339: LD_EXP 50
69343: PPUSH
69344: LD_VAR 0 4
69348: PPUSH
69349: LD_EXP 50
69353: PUSH
69354: LD_VAR 0 4
69358: ARRAY
69359: PPUSH
69360: LD_EXP 50
69364: PUSH
69365: LD_VAR 0 4
69369: ARRAY
69370: PUSH
69371: LD_INT 1
69373: MINUS
69374: PPUSH
69375: LD_EXP 50
69379: PUSH
69380: LD_VAR 0 4
69384: ARRAY
69385: PPUSH
69386: LD_INT 0
69388: PPUSH
69389: CALL 15574 0 4
69393: PPUSH
69394: CALL_OW 1
69398: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
69399: LD_ADDR_EXP 50
69403: PUSH
69404: LD_EXP 50
69408: PPUSH
69409: LD_VAR 0 4
69413: PPUSH
69414: LD_EXP 50
69418: PUSH
69419: LD_VAR 0 4
69423: ARRAY
69424: PPUSH
69425: LD_EXP 50
69429: PUSH
69430: LD_VAR 0 4
69434: ARRAY
69435: PPUSH
69436: LD_INT 1
69438: PPUSH
69439: LD_INT 0
69441: PPUSH
69442: CALL 15574 0 4
69446: PPUSH
69447: CALL_OW 1
69451: ST_TO_ADDR
// continue ;
69452: GO 69026
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
69454: LD_EXP 52
69458: PUSH
69459: LD_VAR 0 2
69463: ARRAY
69464: PUSH
69465: LD_EXP 53
69469: PUSH
69470: LD_VAR 0 2
69474: ARRAY
69475: NOT
69476: AND
69477: IFFALSE 69604
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
69479: LD_ADDR_EXP 53
69483: PUSH
69484: LD_EXP 53
69488: PPUSH
69489: LD_VAR 0 2
69493: PUSH
69494: LD_EXP 53
69498: PUSH
69499: LD_VAR 0 2
69503: ARRAY
69504: PUSH
69505: LD_INT 1
69507: PLUS
69508: PUSH
69509: EMPTY
69510: LIST
69511: LIST
69512: PPUSH
69513: LD_EXP 52
69517: PUSH
69518: LD_VAR 0 2
69522: ARRAY
69523: PUSH
69524: LD_INT 1
69526: ARRAY
69527: PPUSH
69528: CALL 16156 0 3
69532: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
69533: LD_EXP 52
69537: PUSH
69538: LD_VAR 0 2
69542: ARRAY
69543: PUSH
69544: LD_INT 1
69546: ARRAY
69547: PPUSH
69548: LD_INT 112
69550: PPUSH
69551: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
69555: LD_ADDR_VAR 0 9
69559: PUSH
69560: LD_EXP 52
69564: PUSH
69565: LD_VAR 0 2
69569: ARRAY
69570: PPUSH
69571: LD_INT 1
69573: PPUSH
69574: CALL_OW 3
69578: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
69579: LD_ADDR_EXP 52
69583: PUSH
69584: LD_EXP 52
69588: PPUSH
69589: LD_VAR 0 2
69593: PPUSH
69594: LD_VAR 0 9
69598: PPUSH
69599: CALL_OW 1
69603: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
69604: LD_EXP 52
69608: PUSH
69609: LD_VAR 0 2
69613: ARRAY
69614: PUSH
69615: LD_EXP 53
69619: PUSH
69620: LD_VAR 0 2
69624: ARRAY
69625: AND
69626: PUSH
69627: LD_EXP 53
69631: PUSH
69632: LD_VAR 0 2
69636: ARRAY
69637: PUSH
69638: LD_INT 1
69640: ARRAY
69641: PPUSH
69642: CALL_OW 310
69646: NOT
69647: AND
69648: PUSH
69649: LD_VAR 0 3
69653: PPUSH
69654: CALL_OW 313
69658: PUSH
69659: LD_INT 6
69661: EQUAL
69662: AND
69663: IFFALSE 69719
// begin tmp2 := UnitsInside ( j ) ;
69665: LD_ADDR_VAR 0 9
69669: PUSH
69670: LD_VAR 0 3
69674: PPUSH
69675: CALL_OW 313
69679: ST_TO_ADDR
// if tmp2 = 6 then
69680: LD_VAR 0 9
69684: PUSH
69685: LD_INT 6
69687: EQUAL
69688: IFFALSE 69719
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
69690: LD_VAR 0 9
69694: PUSH
69695: LD_INT 1
69697: ARRAY
69698: PPUSH
69699: LD_INT 112
69701: PPUSH
69702: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
69706: LD_VAR 0 9
69710: PUSH
69711: LD_INT 1
69713: ARRAY
69714: PPUSH
69715: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
69719: LD_EXP 53
69723: PUSH
69724: LD_VAR 0 2
69728: ARRAY
69729: PUSH
69730: LD_EXP 53
69734: PUSH
69735: LD_VAR 0 2
69739: ARRAY
69740: PUSH
69741: LD_INT 1
69743: ARRAY
69744: PPUSH
69745: CALL_OW 314
69749: NOT
69750: AND
69751: PUSH
69752: LD_EXP 53
69756: PUSH
69757: LD_VAR 0 2
69761: ARRAY
69762: PUSH
69763: LD_INT 1
69765: ARRAY
69766: PPUSH
69767: CALL_OW 310
69771: NOT
69772: AND
69773: IFFALSE 69799
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
69775: LD_EXP 53
69779: PUSH
69780: LD_VAR 0 2
69784: ARRAY
69785: PUSH
69786: LD_INT 1
69788: ARRAY
69789: PPUSH
69790: LD_VAR 0 3
69794: PPUSH
69795: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
69799: LD_EXP 53
69803: PUSH
69804: LD_VAR 0 2
69808: ARRAY
69809: PUSH
69810: LD_INT 1
69812: ARRAY
69813: PPUSH
69814: CALL_OW 310
69818: PUSH
69819: LD_EXP 53
69823: PUSH
69824: LD_VAR 0 2
69828: ARRAY
69829: PUSH
69830: LD_INT 1
69832: ARRAY
69833: PPUSH
69834: CALL_OW 310
69838: PPUSH
69839: CALL_OW 461
69843: PUSH
69844: LD_INT 3
69846: NONEQUAL
69847: AND
69848: IFFALSE 69869
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
69850: LD_EXP 53
69854: PUSH
69855: LD_VAR 0 2
69859: ARRAY
69860: PUSH
69861: LD_INT 1
69863: ARRAY
69864: PPUSH
69865: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
69869: LD_VAR 0 3
69873: PPUSH
69874: CALL_OW 461
69878: PUSH
69879: LD_INT 6
69881: EQUAL
69882: PUSH
69883: LD_VAR 0 6
69887: PUSH
69888: LD_INT 1
69890: GREATER
69891: AND
69892: IFFALSE 70044
// begin sci := [ ] ;
69894: LD_ADDR_VAR 0 8
69898: PUSH
69899: EMPTY
69900: ST_TO_ADDR
// for x in ( tmp diff j ) do
69901: LD_ADDR_VAR 0 7
69905: PUSH
69906: LD_VAR 0 6
69910: PUSH
69911: LD_VAR 0 3
69915: DIFF
69916: PUSH
69917: FOR_IN
69918: IFFALSE 69970
// begin if sci = 6 then
69920: LD_VAR 0 8
69924: PUSH
69925: LD_INT 6
69927: EQUAL
69928: IFFALSE 69932
// break ;
69930: GO 69970
// if BuildingStatus ( x ) = bs_idle then
69932: LD_VAR 0 7
69936: PPUSH
69937: CALL_OW 461
69941: PUSH
69942: LD_INT 2
69944: EQUAL
69945: IFFALSE 69968
// sci := sci ^ UnitsInside ( x ) ;
69947: LD_ADDR_VAR 0 8
69951: PUSH
69952: LD_VAR 0 8
69956: PUSH
69957: LD_VAR 0 7
69961: PPUSH
69962: CALL_OW 313
69966: ADD
69967: ST_TO_ADDR
// end ;
69968: GO 69917
69970: POP
69971: POP
// if not sci then
69972: LD_VAR 0 8
69976: NOT
69977: IFFALSE 69981
// continue ;
69979: GO 69026
// for x in sci do
69981: LD_ADDR_VAR 0 7
69985: PUSH
69986: LD_VAR 0 8
69990: PUSH
69991: FOR_IN
69992: IFFALSE 70042
// if IsInUnit ( x ) and not HasTask ( x ) then
69994: LD_VAR 0 7
69998: PPUSH
69999: CALL_OW 310
70003: PUSH
70004: LD_VAR 0 7
70008: PPUSH
70009: CALL_OW 314
70013: NOT
70014: AND
70015: IFFALSE 70040
// begin ComExitBuilding ( x ) ;
70017: LD_VAR 0 7
70021: PPUSH
70022: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
70026: LD_VAR 0 7
70030: PPUSH
70031: LD_VAR 0 3
70035: PPUSH
70036: CALL_OW 180
// end ;
70040: GO 69991
70042: POP
70043: POP
// end ; end ;
70044: GO 69026
70046: POP
70047: POP
// end ;
70048: GO 68980
70050: POP
70051: POP
// end ;
70052: LD_VAR 0 1
70056: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
70057: LD_INT 0
70059: PPUSH
70060: PPUSH
// if not mc_bases then
70061: LD_EXP 23
70065: NOT
70066: IFFALSE 70070
// exit ;
70068: GO 70151
// for i = 1 to mc_bases do
70070: LD_ADDR_VAR 0 2
70074: PUSH
70075: DOUBLE
70076: LD_INT 1
70078: DEC
70079: ST_TO_ADDR
70080: LD_EXP 23
70084: PUSH
70085: FOR_TO
70086: IFFALSE 70149
// if mc_mines [ i ] and mc_miners [ i ] then
70088: LD_EXP 36
70092: PUSH
70093: LD_VAR 0 2
70097: ARRAY
70098: PUSH
70099: LD_EXP 37
70103: PUSH
70104: LD_VAR 0 2
70108: ARRAY
70109: AND
70110: IFFALSE 70147
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
70112: LD_EXP 37
70116: PUSH
70117: LD_VAR 0 2
70121: ARRAY
70122: PUSH
70123: LD_INT 1
70125: ARRAY
70126: PPUSH
70127: CALL_OW 255
70131: PPUSH
70132: LD_EXP 36
70136: PUSH
70137: LD_VAR 0 2
70141: ARRAY
70142: PPUSH
70143: CALL 12958 0 2
70147: GO 70085
70149: POP
70150: POP
// end ;
70151: LD_VAR 0 1
70155: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
70156: LD_INT 0
70158: PPUSH
70159: PPUSH
70160: PPUSH
70161: PPUSH
70162: PPUSH
70163: PPUSH
70164: PPUSH
70165: PPUSH
// if not mc_bases or not mc_parking then
70166: LD_EXP 23
70170: NOT
70171: PUSH
70172: LD_EXP 47
70176: NOT
70177: OR
70178: IFFALSE 70182
// exit ;
70180: GO 70892
// for i = 1 to mc_bases do
70182: LD_ADDR_VAR 0 2
70186: PUSH
70187: DOUBLE
70188: LD_INT 1
70190: DEC
70191: ST_TO_ADDR
70192: LD_EXP 23
70196: PUSH
70197: FOR_TO
70198: IFFALSE 70890
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
70200: LD_EXP 23
70204: PUSH
70205: LD_VAR 0 2
70209: ARRAY
70210: NOT
70211: PUSH
70212: LD_EXP 47
70216: PUSH
70217: LD_VAR 0 2
70221: ARRAY
70222: NOT
70223: OR
70224: IFFALSE 70228
// continue ;
70226: GO 70197
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
70228: LD_ADDR_VAR 0 5
70232: PUSH
70233: LD_EXP 23
70237: PUSH
70238: LD_VAR 0 2
70242: ARRAY
70243: PUSH
70244: LD_INT 1
70246: ARRAY
70247: PPUSH
70248: CALL_OW 255
70252: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
70253: LD_ADDR_VAR 0 6
70257: PUSH
70258: LD_EXP 23
70262: PUSH
70263: LD_VAR 0 2
70267: ARRAY
70268: PPUSH
70269: LD_INT 30
70271: PUSH
70272: LD_INT 3
70274: PUSH
70275: EMPTY
70276: LIST
70277: LIST
70278: PPUSH
70279: CALL_OW 72
70283: ST_TO_ADDR
// if not fac then
70284: LD_VAR 0 6
70288: NOT
70289: IFFALSE 70340
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70291: LD_ADDR_VAR 0 6
70295: PUSH
70296: LD_EXP 23
70300: PUSH
70301: LD_VAR 0 2
70305: ARRAY
70306: PPUSH
70307: LD_INT 2
70309: PUSH
70310: LD_INT 30
70312: PUSH
70313: LD_INT 0
70315: PUSH
70316: EMPTY
70317: LIST
70318: LIST
70319: PUSH
70320: LD_INT 30
70322: PUSH
70323: LD_INT 1
70325: PUSH
70326: EMPTY
70327: LIST
70328: LIST
70329: PUSH
70330: EMPTY
70331: LIST
70332: LIST
70333: LIST
70334: PPUSH
70335: CALL_OW 72
70339: ST_TO_ADDR
// if not fac then
70340: LD_VAR 0 6
70344: NOT
70345: IFFALSE 70349
// continue ;
70347: GO 70197
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
70349: LD_ADDR_VAR 0 7
70353: PUSH
70354: LD_EXP 47
70358: PUSH
70359: LD_VAR 0 2
70363: ARRAY
70364: PPUSH
70365: LD_INT 22
70367: PUSH
70368: LD_VAR 0 5
70372: PUSH
70373: EMPTY
70374: LIST
70375: LIST
70376: PUSH
70377: LD_INT 21
70379: PUSH
70380: LD_INT 2
70382: PUSH
70383: EMPTY
70384: LIST
70385: LIST
70386: PUSH
70387: LD_INT 3
70389: PUSH
70390: LD_INT 24
70392: PUSH
70393: LD_INT 1000
70395: PUSH
70396: EMPTY
70397: LIST
70398: LIST
70399: PUSH
70400: EMPTY
70401: LIST
70402: LIST
70403: PUSH
70404: EMPTY
70405: LIST
70406: LIST
70407: LIST
70408: PPUSH
70409: CALL_OW 70
70413: ST_TO_ADDR
// for j in fac do
70414: LD_ADDR_VAR 0 3
70418: PUSH
70419: LD_VAR 0 6
70423: PUSH
70424: FOR_IN
70425: IFFALSE 70506
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
70427: LD_ADDR_VAR 0 7
70431: PUSH
70432: LD_VAR 0 7
70436: PUSH
70437: LD_INT 22
70439: PUSH
70440: LD_VAR 0 5
70444: PUSH
70445: EMPTY
70446: LIST
70447: LIST
70448: PUSH
70449: LD_INT 91
70451: PUSH
70452: LD_VAR 0 3
70456: PUSH
70457: LD_INT 15
70459: PUSH
70460: EMPTY
70461: LIST
70462: LIST
70463: LIST
70464: PUSH
70465: LD_INT 21
70467: PUSH
70468: LD_INT 2
70470: PUSH
70471: EMPTY
70472: LIST
70473: LIST
70474: PUSH
70475: LD_INT 3
70477: PUSH
70478: LD_INT 24
70480: PUSH
70481: LD_INT 1000
70483: PUSH
70484: EMPTY
70485: LIST
70486: LIST
70487: PUSH
70488: EMPTY
70489: LIST
70490: LIST
70491: PUSH
70492: EMPTY
70493: LIST
70494: LIST
70495: LIST
70496: LIST
70497: PPUSH
70498: CALL_OW 69
70502: UNION
70503: ST_TO_ADDR
70504: GO 70424
70506: POP
70507: POP
// if not vehs then
70508: LD_VAR 0 7
70512: NOT
70513: IFFALSE 70539
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
70515: LD_ADDR_EXP 35
70519: PUSH
70520: LD_EXP 35
70524: PPUSH
70525: LD_VAR 0 2
70529: PPUSH
70530: EMPTY
70531: PPUSH
70532: CALL_OW 1
70536: ST_TO_ADDR
// continue ;
70537: GO 70197
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
70539: LD_ADDR_VAR 0 8
70543: PUSH
70544: LD_EXP 23
70548: PUSH
70549: LD_VAR 0 2
70553: ARRAY
70554: PPUSH
70555: LD_INT 30
70557: PUSH
70558: LD_INT 3
70560: PUSH
70561: EMPTY
70562: LIST
70563: LIST
70564: PPUSH
70565: CALL_OW 72
70569: ST_TO_ADDR
// if tmp then
70570: LD_VAR 0 8
70574: IFFALSE 70677
// begin for j in tmp do
70576: LD_ADDR_VAR 0 3
70580: PUSH
70581: LD_VAR 0 8
70585: PUSH
70586: FOR_IN
70587: IFFALSE 70675
// for k in UnitsInside ( j ) do
70589: LD_ADDR_VAR 0 4
70593: PUSH
70594: LD_VAR 0 3
70598: PPUSH
70599: CALL_OW 313
70603: PUSH
70604: FOR_IN
70605: IFFALSE 70671
// if k then
70607: LD_VAR 0 4
70611: IFFALSE 70669
// if not k in mc_repair_vehicle [ i ] then
70613: LD_VAR 0 4
70617: PUSH
70618: LD_EXP 35
70622: PUSH
70623: LD_VAR 0 2
70627: ARRAY
70628: IN
70629: NOT
70630: IFFALSE 70669
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
70632: LD_ADDR_EXP 35
70636: PUSH
70637: LD_EXP 35
70641: PPUSH
70642: LD_VAR 0 2
70646: PPUSH
70647: LD_EXP 35
70651: PUSH
70652: LD_VAR 0 2
70656: ARRAY
70657: PUSH
70658: LD_VAR 0 4
70662: UNION
70663: PPUSH
70664: CALL_OW 1
70668: ST_TO_ADDR
70669: GO 70604
70671: POP
70672: POP
70673: GO 70586
70675: POP
70676: POP
// end ; if not mc_repair_vehicle [ i ] then
70677: LD_EXP 35
70681: PUSH
70682: LD_VAR 0 2
70686: ARRAY
70687: NOT
70688: IFFALSE 70692
// continue ;
70690: GO 70197
// for j in mc_repair_vehicle [ i ] do
70692: LD_ADDR_VAR 0 3
70696: PUSH
70697: LD_EXP 35
70701: PUSH
70702: LD_VAR 0 2
70706: ARRAY
70707: PUSH
70708: FOR_IN
70709: IFFALSE 70886
// begin if GetClass ( j ) <> 3 then
70711: LD_VAR 0 3
70715: PPUSH
70716: CALL_OW 257
70720: PUSH
70721: LD_INT 3
70723: NONEQUAL
70724: IFFALSE 70765
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
70726: LD_ADDR_EXP 35
70730: PUSH
70731: LD_EXP 35
70735: PPUSH
70736: LD_VAR 0 2
70740: PPUSH
70741: LD_EXP 35
70745: PUSH
70746: LD_VAR 0 2
70750: ARRAY
70751: PUSH
70752: LD_VAR 0 3
70756: DIFF
70757: PPUSH
70758: CALL_OW 1
70762: ST_TO_ADDR
// continue ;
70763: GO 70708
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
70765: LD_VAR 0 3
70769: PPUSH
70770: CALL_OW 311
70774: NOT
70775: PUSH
70776: LD_VAR 0 3
70780: PUSH
70781: LD_EXP 26
70785: PUSH
70786: LD_VAR 0 2
70790: ARRAY
70791: PUSH
70792: LD_INT 1
70794: ARRAY
70795: IN
70796: NOT
70797: AND
70798: PUSH
70799: LD_VAR 0 3
70803: PUSH
70804: LD_EXP 26
70808: PUSH
70809: LD_VAR 0 2
70813: ARRAY
70814: PUSH
70815: LD_INT 2
70817: ARRAY
70818: IN
70819: NOT
70820: AND
70821: IFFALSE 70884
// begin if IsInUnit ( j ) then
70823: LD_VAR 0 3
70827: PPUSH
70828: CALL_OW 310
70832: IFFALSE 70845
// ComExitBuilding ( j ) else
70834: LD_VAR 0 3
70838: PPUSH
70839: CALL_OW 122
70843: GO 70884
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
70845: LD_VAR 0 3
70849: PPUSH
70850: LD_VAR 0 7
70854: PUSH
70855: LD_INT 1
70857: ARRAY
70858: PPUSH
70859: CALL 50460 0 2
70863: NOT
70864: IFFALSE 70884
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
70866: LD_VAR 0 3
70870: PPUSH
70871: LD_VAR 0 7
70875: PUSH
70876: LD_INT 1
70878: ARRAY
70879: PPUSH
70880: CALL_OW 129
// end ; end ;
70884: GO 70708
70886: POP
70887: POP
// end ;
70888: GO 70197
70890: POP
70891: POP
// end ;
70892: LD_VAR 0 1
70896: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
70897: LD_INT 0
70899: PPUSH
70900: PPUSH
70901: PPUSH
70902: PPUSH
70903: PPUSH
70904: PPUSH
70905: PPUSH
70906: PPUSH
70907: PPUSH
70908: PPUSH
70909: PPUSH
// if not mc_bases then
70910: LD_EXP 23
70914: NOT
70915: IFFALSE 70919
// exit ;
70917: GO 71721
// for i = 1 to mc_bases do
70919: LD_ADDR_VAR 0 2
70923: PUSH
70924: DOUBLE
70925: LD_INT 1
70927: DEC
70928: ST_TO_ADDR
70929: LD_EXP 23
70933: PUSH
70934: FOR_TO
70935: IFFALSE 71719
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
70937: LD_EXP 51
70941: PUSH
70942: LD_VAR 0 2
70946: ARRAY
70947: NOT
70948: PUSH
70949: LD_EXP 26
70953: PUSH
70954: LD_VAR 0 2
70958: ARRAY
70959: PUSH
70960: LD_INT 1
70962: ARRAY
70963: OR
70964: PUSH
70965: LD_EXP 26
70969: PUSH
70970: LD_VAR 0 2
70974: ARRAY
70975: PUSH
70976: LD_INT 2
70978: ARRAY
70979: OR
70980: PUSH
70981: LD_EXP 49
70985: PUSH
70986: LD_VAR 0 2
70990: ARRAY
70991: PPUSH
70992: LD_INT 1
70994: PPUSH
70995: CALL_OW 325
70999: NOT
71000: OR
71001: PUSH
71002: LD_EXP 46
71006: PUSH
71007: LD_VAR 0 2
71011: ARRAY
71012: OR
71013: IFFALSE 71017
// continue ;
71015: GO 70934
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
71017: LD_ADDR_VAR 0 8
71021: PUSH
71022: LD_EXP 23
71026: PUSH
71027: LD_VAR 0 2
71031: ARRAY
71032: PPUSH
71033: LD_INT 25
71035: PUSH
71036: LD_INT 4
71038: PUSH
71039: EMPTY
71040: LIST
71041: LIST
71042: PUSH
71043: LD_INT 50
71045: PUSH
71046: EMPTY
71047: LIST
71048: PUSH
71049: LD_INT 3
71051: PUSH
71052: LD_INT 60
71054: PUSH
71055: EMPTY
71056: LIST
71057: PUSH
71058: EMPTY
71059: LIST
71060: LIST
71061: PUSH
71062: EMPTY
71063: LIST
71064: LIST
71065: LIST
71066: PPUSH
71067: CALL_OW 72
71071: PUSH
71072: LD_EXP 27
71076: PUSH
71077: LD_VAR 0 2
71081: ARRAY
71082: DIFF
71083: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71084: LD_ADDR_VAR 0 9
71088: PUSH
71089: LD_EXP 23
71093: PUSH
71094: LD_VAR 0 2
71098: ARRAY
71099: PPUSH
71100: LD_INT 2
71102: PUSH
71103: LD_INT 30
71105: PUSH
71106: LD_INT 0
71108: PUSH
71109: EMPTY
71110: LIST
71111: LIST
71112: PUSH
71113: LD_INT 30
71115: PUSH
71116: LD_INT 1
71118: PUSH
71119: EMPTY
71120: LIST
71121: LIST
71122: PUSH
71123: EMPTY
71124: LIST
71125: LIST
71126: LIST
71127: PPUSH
71128: CALL_OW 72
71132: ST_TO_ADDR
// if not tmp or not dep then
71133: LD_VAR 0 8
71137: NOT
71138: PUSH
71139: LD_VAR 0 9
71143: NOT
71144: OR
71145: IFFALSE 71149
// continue ;
71147: GO 70934
// side := GetSide ( tmp [ 1 ] ) ;
71149: LD_ADDR_VAR 0 11
71153: PUSH
71154: LD_VAR 0 8
71158: PUSH
71159: LD_INT 1
71161: ARRAY
71162: PPUSH
71163: CALL_OW 255
71167: ST_TO_ADDR
// dep := dep [ 1 ] ;
71168: LD_ADDR_VAR 0 9
71172: PUSH
71173: LD_VAR 0 9
71177: PUSH
71178: LD_INT 1
71180: ARRAY
71181: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
71182: LD_ADDR_VAR 0 7
71186: PUSH
71187: LD_EXP 51
71191: PUSH
71192: LD_VAR 0 2
71196: ARRAY
71197: PPUSH
71198: LD_INT 22
71200: PUSH
71201: LD_INT 0
71203: PUSH
71204: EMPTY
71205: LIST
71206: LIST
71207: PUSH
71208: LD_INT 25
71210: PUSH
71211: LD_INT 12
71213: PUSH
71214: EMPTY
71215: LIST
71216: LIST
71217: PUSH
71218: EMPTY
71219: LIST
71220: LIST
71221: PPUSH
71222: CALL_OW 70
71226: PUSH
71227: LD_INT 22
71229: PUSH
71230: LD_INT 0
71232: PUSH
71233: EMPTY
71234: LIST
71235: LIST
71236: PUSH
71237: LD_INT 25
71239: PUSH
71240: LD_INT 12
71242: PUSH
71243: EMPTY
71244: LIST
71245: LIST
71246: PUSH
71247: LD_INT 91
71249: PUSH
71250: LD_VAR 0 9
71254: PUSH
71255: LD_INT 20
71257: PUSH
71258: EMPTY
71259: LIST
71260: LIST
71261: LIST
71262: PUSH
71263: EMPTY
71264: LIST
71265: LIST
71266: LIST
71267: PPUSH
71268: CALL_OW 69
71272: UNION
71273: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
71274: LD_ADDR_VAR 0 10
71278: PUSH
71279: LD_EXP 51
71283: PUSH
71284: LD_VAR 0 2
71288: ARRAY
71289: PPUSH
71290: LD_INT 81
71292: PUSH
71293: LD_VAR 0 11
71297: PUSH
71298: EMPTY
71299: LIST
71300: LIST
71301: PPUSH
71302: CALL_OW 70
71306: ST_TO_ADDR
// if not apes or danger_at_area then
71307: LD_VAR 0 7
71311: NOT
71312: PUSH
71313: LD_VAR 0 10
71317: OR
71318: IFFALSE 71368
// begin if mc_taming [ i ] then
71320: LD_EXP 54
71324: PUSH
71325: LD_VAR 0 2
71329: ARRAY
71330: IFFALSE 71366
// begin MC_Reset ( i , 121 ) ;
71332: LD_VAR 0 2
71336: PPUSH
71337: LD_INT 121
71339: PPUSH
71340: CALL 56358 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
71344: LD_ADDR_EXP 54
71348: PUSH
71349: LD_EXP 54
71353: PPUSH
71354: LD_VAR 0 2
71358: PPUSH
71359: EMPTY
71360: PPUSH
71361: CALL_OW 1
71365: ST_TO_ADDR
// end ; continue ;
71366: GO 70934
// end ; for j in tmp do
71368: LD_ADDR_VAR 0 3
71372: PUSH
71373: LD_VAR 0 8
71377: PUSH
71378: FOR_IN
71379: IFFALSE 71715
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
71381: LD_VAR 0 3
71385: PUSH
71386: LD_EXP 54
71390: PUSH
71391: LD_VAR 0 2
71395: ARRAY
71396: IN
71397: NOT
71398: PUSH
71399: LD_EXP 54
71403: PUSH
71404: LD_VAR 0 2
71408: ARRAY
71409: PUSH
71410: LD_INT 3
71412: LESS
71413: AND
71414: IFFALSE 71472
// begin SetTag ( j , 121 ) ;
71416: LD_VAR 0 3
71420: PPUSH
71421: LD_INT 121
71423: PPUSH
71424: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
71428: LD_ADDR_EXP 54
71432: PUSH
71433: LD_EXP 54
71437: PPUSH
71438: LD_VAR 0 2
71442: PUSH
71443: LD_EXP 54
71447: PUSH
71448: LD_VAR 0 2
71452: ARRAY
71453: PUSH
71454: LD_INT 1
71456: PLUS
71457: PUSH
71458: EMPTY
71459: LIST
71460: LIST
71461: PPUSH
71462: LD_VAR 0 3
71466: PPUSH
71467: CALL 16156 0 3
71471: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
71472: LD_VAR 0 3
71476: PUSH
71477: LD_EXP 54
71481: PUSH
71482: LD_VAR 0 2
71486: ARRAY
71487: IN
71488: IFFALSE 71713
// begin if GetClass ( j ) <> 4 then
71490: LD_VAR 0 3
71494: PPUSH
71495: CALL_OW 257
71499: PUSH
71500: LD_INT 4
71502: NONEQUAL
71503: IFFALSE 71556
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
71505: LD_ADDR_EXP 54
71509: PUSH
71510: LD_EXP 54
71514: PPUSH
71515: LD_VAR 0 2
71519: PPUSH
71520: LD_EXP 54
71524: PUSH
71525: LD_VAR 0 2
71529: ARRAY
71530: PUSH
71531: LD_VAR 0 3
71535: DIFF
71536: PPUSH
71537: CALL_OW 1
71541: ST_TO_ADDR
// SetTag ( j , 0 ) ;
71542: LD_VAR 0 3
71546: PPUSH
71547: LD_INT 0
71549: PPUSH
71550: CALL_OW 109
// continue ;
71554: GO 71378
// end ; if IsInUnit ( j ) then
71556: LD_VAR 0 3
71560: PPUSH
71561: CALL_OW 310
71565: IFFALSE 71576
// ComExitBuilding ( j ) ;
71567: LD_VAR 0 3
71571: PPUSH
71572: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
71576: LD_ADDR_VAR 0 6
71580: PUSH
71581: LD_VAR 0 7
71585: PPUSH
71586: LD_VAR 0 3
71590: PPUSH
71591: CALL_OW 74
71595: ST_TO_ADDR
// if not ape then
71596: LD_VAR 0 6
71600: NOT
71601: IFFALSE 71605
// break ;
71603: GO 71715
// x := GetX ( ape ) ;
71605: LD_ADDR_VAR 0 4
71609: PUSH
71610: LD_VAR 0 6
71614: PPUSH
71615: CALL_OW 250
71619: ST_TO_ADDR
// y := GetY ( ape ) ;
71620: LD_ADDR_VAR 0 5
71624: PUSH
71625: LD_VAR 0 6
71629: PPUSH
71630: CALL_OW 251
71634: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
71635: LD_VAR 0 4
71639: PPUSH
71640: LD_VAR 0 5
71644: PPUSH
71645: CALL_OW 488
71649: NOT
71650: PUSH
71651: LD_VAR 0 11
71655: PPUSH
71656: LD_VAR 0 4
71660: PPUSH
71661: LD_VAR 0 5
71665: PPUSH
71666: LD_INT 20
71668: PPUSH
71669: CALL 17052 0 4
71673: PUSH
71674: LD_INT 4
71676: ARRAY
71677: OR
71678: IFFALSE 71682
// break ;
71680: GO 71715
// if not HasTask ( j ) then
71682: LD_VAR 0 3
71686: PPUSH
71687: CALL_OW 314
71691: NOT
71692: IFFALSE 71713
// ComTameXY ( j , x , y ) ;
71694: LD_VAR 0 3
71698: PPUSH
71699: LD_VAR 0 4
71703: PPUSH
71704: LD_VAR 0 5
71708: PPUSH
71709: CALL_OW 131
// end ; end ;
71713: GO 71378
71715: POP
71716: POP
// end ;
71717: GO 70934
71719: POP
71720: POP
// end ;
71721: LD_VAR 0 1
71725: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
71726: LD_INT 0
71728: PPUSH
71729: PPUSH
71730: PPUSH
71731: PPUSH
71732: PPUSH
71733: PPUSH
71734: PPUSH
71735: PPUSH
// if not mc_bases then
71736: LD_EXP 23
71740: NOT
71741: IFFALSE 71745
// exit ;
71743: GO 72371
// for i = 1 to mc_bases do
71745: LD_ADDR_VAR 0 2
71749: PUSH
71750: DOUBLE
71751: LD_INT 1
71753: DEC
71754: ST_TO_ADDR
71755: LD_EXP 23
71759: PUSH
71760: FOR_TO
71761: IFFALSE 72369
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
71763: LD_EXP 52
71767: PUSH
71768: LD_VAR 0 2
71772: ARRAY
71773: NOT
71774: PUSH
71775: LD_EXP 52
71779: PUSH
71780: LD_VAR 0 2
71784: ARRAY
71785: PPUSH
71786: LD_INT 25
71788: PUSH
71789: LD_INT 12
71791: PUSH
71792: EMPTY
71793: LIST
71794: LIST
71795: PPUSH
71796: CALL_OW 72
71800: NOT
71801: OR
71802: IFFALSE 71806
// continue ;
71804: GO 71760
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
71806: LD_ADDR_VAR 0 5
71810: PUSH
71811: LD_EXP 52
71815: PUSH
71816: LD_VAR 0 2
71820: ARRAY
71821: PUSH
71822: LD_INT 1
71824: ARRAY
71825: PPUSH
71826: CALL_OW 255
71830: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
71831: LD_VAR 0 5
71835: PPUSH
71836: LD_INT 2
71838: PPUSH
71839: CALL_OW 325
71843: IFFALSE 72096
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
71845: LD_ADDR_VAR 0 4
71849: PUSH
71850: LD_EXP 52
71854: PUSH
71855: LD_VAR 0 2
71859: ARRAY
71860: PPUSH
71861: LD_INT 25
71863: PUSH
71864: LD_INT 16
71866: PUSH
71867: EMPTY
71868: LIST
71869: LIST
71870: PPUSH
71871: CALL_OW 72
71875: ST_TO_ADDR
// if tmp < 6 then
71876: LD_VAR 0 4
71880: PUSH
71881: LD_INT 6
71883: LESS
71884: IFFALSE 72096
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71886: LD_ADDR_VAR 0 6
71890: PUSH
71891: LD_EXP 23
71895: PUSH
71896: LD_VAR 0 2
71900: ARRAY
71901: PPUSH
71902: LD_INT 2
71904: PUSH
71905: LD_INT 30
71907: PUSH
71908: LD_INT 0
71910: PUSH
71911: EMPTY
71912: LIST
71913: LIST
71914: PUSH
71915: LD_INT 30
71917: PUSH
71918: LD_INT 1
71920: PUSH
71921: EMPTY
71922: LIST
71923: LIST
71924: PUSH
71925: EMPTY
71926: LIST
71927: LIST
71928: LIST
71929: PPUSH
71930: CALL_OW 72
71934: ST_TO_ADDR
// if depot then
71935: LD_VAR 0 6
71939: IFFALSE 72096
// begin selected := 0 ;
71941: LD_ADDR_VAR 0 7
71945: PUSH
71946: LD_INT 0
71948: ST_TO_ADDR
// for j in depot do
71949: LD_ADDR_VAR 0 3
71953: PUSH
71954: LD_VAR 0 6
71958: PUSH
71959: FOR_IN
71960: IFFALSE 71991
// begin if UnitsInside ( j ) < 6 then
71962: LD_VAR 0 3
71966: PPUSH
71967: CALL_OW 313
71971: PUSH
71972: LD_INT 6
71974: LESS
71975: IFFALSE 71989
// begin selected := j ;
71977: LD_ADDR_VAR 0 7
71981: PUSH
71982: LD_VAR 0 3
71986: ST_TO_ADDR
// break ;
71987: GO 71991
// end ; end ;
71989: GO 71959
71991: POP
71992: POP
// if selected then
71993: LD_VAR 0 7
71997: IFFALSE 72096
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
71999: LD_ADDR_VAR 0 3
72003: PUSH
72004: LD_EXP 52
72008: PUSH
72009: LD_VAR 0 2
72013: ARRAY
72014: PPUSH
72015: LD_INT 25
72017: PUSH
72018: LD_INT 12
72020: PUSH
72021: EMPTY
72022: LIST
72023: LIST
72024: PPUSH
72025: CALL_OW 72
72029: PUSH
72030: FOR_IN
72031: IFFALSE 72094
// if not HasTask ( j ) then
72033: LD_VAR 0 3
72037: PPUSH
72038: CALL_OW 314
72042: NOT
72043: IFFALSE 72092
// begin if not IsInUnit ( j ) then
72045: LD_VAR 0 3
72049: PPUSH
72050: CALL_OW 310
72054: NOT
72055: IFFALSE 72071
// ComEnterUnit ( j , selected ) ;
72057: LD_VAR 0 3
72061: PPUSH
72062: LD_VAR 0 7
72066: PPUSH
72067: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
72071: LD_VAR 0 3
72075: PPUSH
72076: LD_INT 16
72078: PPUSH
72079: CALL_OW 183
// AddComExitBuilding ( j ) ;
72083: LD_VAR 0 3
72087: PPUSH
72088: CALL_OW 182
// end ;
72092: GO 72030
72094: POP
72095: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
72096: LD_VAR 0 5
72100: PPUSH
72101: LD_INT 11
72103: PPUSH
72104: CALL_OW 325
72108: IFFALSE 72367
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
72110: LD_ADDR_VAR 0 4
72114: PUSH
72115: LD_EXP 52
72119: PUSH
72120: LD_VAR 0 2
72124: ARRAY
72125: PPUSH
72126: LD_INT 25
72128: PUSH
72129: LD_INT 16
72131: PUSH
72132: EMPTY
72133: LIST
72134: LIST
72135: PPUSH
72136: CALL_OW 72
72140: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
72141: LD_VAR 0 4
72145: PUSH
72146: LD_INT 6
72148: GREATEREQUAL
72149: PUSH
72150: LD_VAR 0 5
72154: PPUSH
72155: LD_INT 2
72157: PPUSH
72158: CALL_OW 325
72162: NOT
72163: OR
72164: IFFALSE 72367
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
72166: LD_ADDR_VAR 0 8
72170: PUSH
72171: LD_EXP 23
72175: PUSH
72176: LD_VAR 0 2
72180: ARRAY
72181: PPUSH
72182: LD_INT 2
72184: PUSH
72185: LD_INT 30
72187: PUSH
72188: LD_INT 4
72190: PUSH
72191: EMPTY
72192: LIST
72193: LIST
72194: PUSH
72195: LD_INT 30
72197: PUSH
72198: LD_INT 5
72200: PUSH
72201: EMPTY
72202: LIST
72203: LIST
72204: PUSH
72205: EMPTY
72206: LIST
72207: LIST
72208: LIST
72209: PPUSH
72210: CALL_OW 72
72214: ST_TO_ADDR
// if barracks then
72215: LD_VAR 0 8
72219: IFFALSE 72367
// begin selected := 0 ;
72221: LD_ADDR_VAR 0 7
72225: PUSH
72226: LD_INT 0
72228: ST_TO_ADDR
// for j in barracks do
72229: LD_ADDR_VAR 0 3
72233: PUSH
72234: LD_VAR 0 8
72238: PUSH
72239: FOR_IN
72240: IFFALSE 72271
// begin if UnitsInside ( j ) < 6 then
72242: LD_VAR 0 3
72246: PPUSH
72247: CALL_OW 313
72251: PUSH
72252: LD_INT 6
72254: LESS
72255: IFFALSE 72269
// begin selected := j ;
72257: LD_ADDR_VAR 0 7
72261: PUSH
72262: LD_VAR 0 3
72266: ST_TO_ADDR
// break ;
72267: GO 72271
// end ; end ;
72269: GO 72239
72271: POP
72272: POP
// if selected then
72273: LD_VAR 0 7
72277: IFFALSE 72367
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
72279: LD_ADDR_VAR 0 3
72283: PUSH
72284: LD_EXP 52
72288: PUSH
72289: LD_VAR 0 2
72293: ARRAY
72294: PPUSH
72295: LD_INT 25
72297: PUSH
72298: LD_INT 12
72300: PUSH
72301: EMPTY
72302: LIST
72303: LIST
72304: PPUSH
72305: CALL_OW 72
72309: PUSH
72310: FOR_IN
72311: IFFALSE 72365
// if not IsInUnit ( j ) and not HasTask ( j ) then
72313: LD_VAR 0 3
72317: PPUSH
72318: CALL_OW 310
72322: NOT
72323: PUSH
72324: LD_VAR 0 3
72328: PPUSH
72329: CALL_OW 314
72333: NOT
72334: AND
72335: IFFALSE 72363
// begin ComEnterUnit ( j , selected ) ;
72337: LD_VAR 0 3
72341: PPUSH
72342: LD_VAR 0 7
72346: PPUSH
72347: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
72351: LD_VAR 0 3
72355: PPUSH
72356: LD_INT 15
72358: PPUSH
72359: CALL_OW 183
// end ;
72363: GO 72310
72365: POP
72366: POP
// end ; end ; end ; end ; end ;
72367: GO 71760
72369: POP
72370: POP
// end ;
72371: LD_VAR 0 1
72375: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
72376: LD_INT 0
72378: PPUSH
72379: PPUSH
72380: PPUSH
72381: PPUSH
// if not mc_bases then
72382: LD_EXP 23
72386: NOT
72387: IFFALSE 72391
// exit ;
72389: GO 72569
// for i = 1 to mc_bases do
72391: LD_ADDR_VAR 0 2
72395: PUSH
72396: DOUBLE
72397: LD_INT 1
72399: DEC
72400: ST_TO_ADDR
72401: LD_EXP 23
72405: PUSH
72406: FOR_TO
72407: IFFALSE 72567
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
72409: LD_ADDR_VAR 0 4
72413: PUSH
72414: LD_EXP 23
72418: PUSH
72419: LD_VAR 0 2
72423: ARRAY
72424: PPUSH
72425: LD_INT 25
72427: PUSH
72428: LD_INT 9
72430: PUSH
72431: EMPTY
72432: LIST
72433: LIST
72434: PPUSH
72435: CALL_OW 72
72439: ST_TO_ADDR
// if not tmp then
72440: LD_VAR 0 4
72444: NOT
72445: IFFALSE 72449
// continue ;
72447: GO 72406
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
72449: LD_EXP 49
72453: PUSH
72454: LD_VAR 0 2
72458: ARRAY
72459: PPUSH
72460: LD_INT 29
72462: PPUSH
72463: CALL_OW 325
72467: NOT
72468: PUSH
72469: LD_EXP 49
72473: PUSH
72474: LD_VAR 0 2
72478: ARRAY
72479: PPUSH
72480: LD_INT 28
72482: PPUSH
72483: CALL_OW 325
72487: NOT
72488: AND
72489: IFFALSE 72493
// continue ;
72491: GO 72406
// for j in tmp do
72493: LD_ADDR_VAR 0 3
72497: PUSH
72498: LD_VAR 0 4
72502: PUSH
72503: FOR_IN
72504: IFFALSE 72563
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
72506: LD_VAR 0 3
72510: PUSH
72511: LD_EXP 26
72515: PUSH
72516: LD_VAR 0 2
72520: ARRAY
72521: PUSH
72522: LD_INT 1
72524: ARRAY
72525: IN
72526: NOT
72527: PUSH
72528: LD_VAR 0 3
72532: PUSH
72533: LD_EXP 26
72537: PUSH
72538: LD_VAR 0 2
72542: ARRAY
72543: PUSH
72544: LD_INT 2
72546: ARRAY
72547: IN
72548: NOT
72549: AND
72550: IFFALSE 72561
// ComSpaceTimeShoot ( j ) ;
72552: LD_VAR 0 3
72556: PPUSH
72557: CALL 11966 0 1
72561: GO 72503
72563: POP
72564: POP
// end ;
72565: GO 72406
72567: POP
72568: POP
// end ;
72569: LD_VAR 0 1
72573: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
72574: LD_INT 0
72576: PPUSH
72577: PPUSH
72578: PPUSH
72579: PPUSH
72580: PPUSH
72581: PPUSH
72582: PPUSH
72583: PPUSH
72584: PPUSH
// if not mc_bases then
72585: LD_EXP 23
72589: NOT
72590: IFFALSE 72594
// exit ;
72592: GO 73216
// for i = 1 to mc_bases do
72594: LD_ADDR_VAR 0 2
72598: PUSH
72599: DOUBLE
72600: LD_INT 1
72602: DEC
72603: ST_TO_ADDR
72604: LD_EXP 23
72608: PUSH
72609: FOR_TO
72610: IFFALSE 73214
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
72612: LD_EXP 58
72616: PUSH
72617: LD_VAR 0 2
72621: ARRAY
72622: NOT
72623: PUSH
72624: LD_INT 38
72626: PPUSH
72627: LD_EXP 49
72631: PUSH
72632: LD_VAR 0 2
72636: ARRAY
72637: PPUSH
72638: CALL_OW 321
72642: PUSH
72643: LD_INT 2
72645: NONEQUAL
72646: OR
72647: IFFALSE 72651
// continue ;
72649: GO 72609
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
72651: LD_ADDR_VAR 0 8
72655: PUSH
72656: LD_EXP 23
72660: PUSH
72661: LD_VAR 0 2
72665: ARRAY
72666: PPUSH
72667: LD_INT 30
72669: PUSH
72670: LD_INT 34
72672: PUSH
72673: EMPTY
72674: LIST
72675: LIST
72676: PPUSH
72677: CALL_OW 72
72681: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
72682: LD_ADDR_VAR 0 9
72686: PUSH
72687: LD_EXP 23
72691: PUSH
72692: LD_VAR 0 2
72696: ARRAY
72697: PPUSH
72698: LD_INT 25
72700: PUSH
72701: LD_INT 4
72703: PUSH
72704: EMPTY
72705: LIST
72706: LIST
72707: PPUSH
72708: CALL_OW 72
72712: PPUSH
72713: LD_INT 0
72715: PPUSH
72716: CALL 45969 0 2
72720: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
72721: LD_VAR 0 9
72725: NOT
72726: PUSH
72727: LD_VAR 0 8
72731: NOT
72732: OR
72733: PUSH
72734: LD_EXP 23
72738: PUSH
72739: LD_VAR 0 2
72743: ARRAY
72744: PPUSH
72745: LD_INT 124
72747: PPUSH
72748: CALL 45969 0 2
72752: OR
72753: IFFALSE 72757
// continue ;
72755: GO 72609
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
72757: LD_EXP 59
72761: PUSH
72762: LD_VAR 0 2
72766: ARRAY
72767: PUSH
72768: LD_EXP 58
72772: PUSH
72773: LD_VAR 0 2
72777: ARRAY
72778: LESS
72779: PUSH
72780: LD_EXP 59
72784: PUSH
72785: LD_VAR 0 2
72789: ARRAY
72790: PUSH
72791: LD_VAR 0 8
72795: LESS
72796: AND
72797: IFFALSE 73212
// begin tmp := sci [ 1 ] ;
72799: LD_ADDR_VAR 0 7
72803: PUSH
72804: LD_VAR 0 9
72808: PUSH
72809: LD_INT 1
72811: ARRAY
72812: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
72813: LD_VAR 0 7
72817: PPUSH
72818: LD_INT 124
72820: PPUSH
72821: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
72825: LD_ADDR_VAR 0 3
72829: PUSH
72830: DOUBLE
72831: LD_EXP 58
72835: PUSH
72836: LD_VAR 0 2
72840: ARRAY
72841: INC
72842: ST_TO_ADDR
72843: LD_EXP 58
72847: PUSH
72848: LD_VAR 0 2
72852: ARRAY
72853: PUSH
72854: FOR_DOWNTO
72855: IFFALSE 73198
// begin if IsInUnit ( tmp ) then
72857: LD_VAR 0 7
72861: PPUSH
72862: CALL_OW 310
72866: IFFALSE 72877
// ComExitBuilding ( tmp ) ;
72868: LD_VAR 0 7
72872: PPUSH
72873: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
72877: LD_INT 35
72879: PPUSH
72880: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
72884: LD_VAR 0 7
72888: PPUSH
72889: CALL_OW 310
72893: NOT
72894: PUSH
72895: LD_VAR 0 7
72899: PPUSH
72900: CALL_OW 314
72904: NOT
72905: AND
72906: IFFALSE 72877
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
72908: LD_ADDR_VAR 0 6
72912: PUSH
72913: LD_VAR 0 7
72917: PPUSH
72918: CALL_OW 250
72922: PUSH
72923: LD_VAR 0 7
72927: PPUSH
72928: CALL_OW 251
72932: PUSH
72933: EMPTY
72934: LIST
72935: LIST
72936: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
72937: LD_INT 35
72939: PPUSH
72940: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
72944: LD_ADDR_VAR 0 4
72948: PUSH
72949: LD_EXP 58
72953: PUSH
72954: LD_VAR 0 2
72958: ARRAY
72959: PUSH
72960: LD_VAR 0 3
72964: ARRAY
72965: PUSH
72966: LD_INT 1
72968: ARRAY
72969: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
72970: LD_ADDR_VAR 0 5
72974: PUSH
72975: LD_EXP 58
72979: PUSH
72980: LD_VAR 0 2
72984: ARRAY
72985: PUSH
72986: LD_VAR 0 3
72990: ARRAY
72991: PUSH
72992: LD_INT 2
72994: ARRAY
72995: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
72996: LD_VAR 0 7
73000: PPUSH
73001: LD_INT 10
73003: PPUSH
73004: CALL 18753 0 2
73008: PUSH
73009: LD_INT 4
73011: ARRAY
73012: IFFALSE 73050
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
73014: LD_VAR 0 7
73018: PPUSH
73019: LD_VAR 0 6
73023: PUSH
73024: LD_INT 1
73026: ARRAY
73027: PPUSH
73028: LD_VAR 0 6
73032: PUSH
73033: LD_INT 2
73035: ARRAY
73036: PPUSH
73037: CALL_OW 111
// wait ( 0 0$10 ) ;
73041: LD_INT 350
73043: PPUSH
73044: CALL_OW 67
// end else
73048: GO 73076
// begin ComMoveXY ( tmp , x , y ) ;
73050: LD_VAR 0 7
73054: PPUSH
73055: LD_VAR 0 4
73059: PPUSH
73060: LD_VAR 0 5
73064: PPUSH
73065: CALL_OW 111
// wait ( 0 0$3 ) ;
73069: LD_INT 105
73071: PPUSH
73072: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
73076: LD_VAR 0 7
73080: PPUSH
73081: LD_VAR 0 4
73085: PPUSH
73086: LD_VAR 0 5
73090: PPUSH
73091: CALL_OW 307
73095: IFFALSE 72937
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
73097: LD_VAR 0 7
73101: PPUSH
73102: LD_VAR 0 4
73106: PPUSH
73107: LD_VAR 0 5
73111: PPUSH
73112: LD_VAR 0 8
73116: PUSH
73117: LD_VAR 0 3
73121: ARRAY
73122: PPUSH
73123: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
73127: LD_INT 35
73129: PPUSH
73130: CALL_OW 67
// until not HasTask ( tmp ) ;
73134: LD_VAR 0 7
73138: PPUSH
73139: CALL_OW 314
73143: NOT
73144: IFFALSE 73127
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
73146: LD_ADDR_EXP 59
73150: PUSH
73151: LD_EXP 59
73155: PPUSH
73156: LD_VAR 0 2
73160: PUSH
73161: LD_EXP 59
73165: PUSH
73166: LD_VAR 0 2
73170: ARRAY
73171: PUSH
73172: LD_INT 1
73174: PLUS
73175: PUSH
73176: EMPTY
73177: LIST
73178: LIST
73179: PPUSH
73180: LD_VAR 0 8
73184: PUSH
73185: LD_VAR 0 3
73189: ARRAY
73190: PPUSH
73191: CALL 16156 0 3
73195: ST_TO_ADDR
// end ;
73196: GO 72854
73198: POP
73199: POP
// MC_Reset ( i , 124 ) ;
73200: LD_VAR 0 2
73204: PPUSH
73205: LD_INT 124
73207: PPUSH
73208: CALL 56358 0 2
// end ; end ;
73212: GO 72609
73214: POP
73215: POP
// end ;
73216: LD_VAR 0 1
73220: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
73221: LD_INT 0
73223: PPUSH
73224: PPUSH
73225: PPUSH
// if not mc_bases then
73226: LD_EXP 23
73230: NOT
73231: IFFALSE 73235
// exit ;
73233: GO 73841
// for i = 1 to mc_bases do
73235: LD_ADDR_VAR 0 2
73239: PUSH
73240: DOUBLE
73241: LD_INT 1
73243: DEC
73244: ST_TO_ADDR
73245: LD_EXP 23
73249: PUSH
73250: FOR_TO
73251: IFFALSE 73839
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
73253: LD_ADDR_VAR 0 3
73257: PUSH
73258: LD_EXP 23
73262: PUSH
73263: LD_VAR 0 2
73267: ARRAY
73268: PPUSH
73269: LD_INT 25
73271: PUSH
73272: LD_INT 4
73274: PUSH
73275: EMPTY
73276: LIST
73277: LIST
73278: PPUSH
73279: CALL_OW 72
73283: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
73284: LD_VAR 0 3
73288: NOT
73289: PUSH
73290: LD_EXP 60
73294: PUSH
73295: LD_VAR 0 2
73299: ARRAY
73300: NOT
73301: OR
73302: PUSH
73303: LD_EXP 23
73307: PUSH
73308: LD_VAR 0 2
73312: ARRAY
73313: PPUSH
73314: LD_INT 2
73316: PUSH
73317: LD_INT 30
73319: PUSH
73320: LD_INT 0
73322: PUSH
73323: EMPTY
73324: LIST
73325: LIST
73326: PUSH
73327: LD_INT 30
73329: PUSH
73330: LD_INT 1
73332: PUSH
73333: EMPTY
73334: LIST
73335: LIST
73336: PUSH
73337: EMPTY
73338: LIST
73339: LIST
73340: LIST
73341: PPUSH
73342: CALL_OW 72
73346: NOT
73347: OR
73348: IFFALSE 73398
// begin if mc_deposits_finder [ i ] then
73350: LD_EXP 61
73354: PUSH
73355: LD_VAR 0 2
73359: ARRAY
73360: IFFALSE 73396
// begin MC_Reset ( i , 125 ) ;
73362: LD_VAR 0 2
73366: PPUSH
73367: LD_INT 125
73369: PPUSH
73370: CALL 56358 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
73374: LD_ADDR_EXP 61
73378: PUSH
73379: LD_EXP 61
73383: PPUSH
73384: LD_VAR 0 2
73388: PPUSH
73389: EMPTY
73390: PPUSH
73391: CALL_OW 1
73395: ST_TO_ADDR
// end ; continue ;
73396: GO 73250
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
73398: LD_EXP 60
73402: PUSH
73403: LD_VAR 0 2
73407: ARRAY
73408: PUSH
73409: LD_INT 1
73411: ARRAY
73412: PUSH
73413: LD_INT 3
73415: ARRAY
73416: PUSH
73417: LD_INT 1
73419: EQUAL
73420: PUSH
73421: LD_INT 20
73423: PPUSH
73424: LD_EXP 49
73428: PUSH
73429: LD_VAR 0 2
73433: ARRAY
73434: PPUSH
73435: CALL_OW 321
73439: PUSH
73440: LD_INT 2
73442: NONEQUAL
73443: AND
73444: IFFALSE 73494
// begin if mc_deposits_finder [ i ] then
73446: LD_EXP 61
73450: PUSH
73451: LD_VAR 0 2
73455: ARRAY
73456: IFFALSE 73492
// begin MC_Reset ( i , 125 ) ;
73458: LD_VAR 0 2
73462: PPUSH
73463: LD_INT 125
73465: PPUSH
73466: CALL 56358 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
73470: LD_ADDR_EXP 61
73474: PUSH
73475: LD_EXP 61
73479: PPUSH
73480: LD_VAR 0 2
73484: PPUSH
73485: EMPTY
73486: PPUSH
73487: CALL_OW 1
73491: ST_TO_ADDR
// end ; continue ;
73492: GO 73250
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
73494: LD_EXP 60
73498: PUSH
73499: LD_VAR 0 2
73503: ARRAY
73504: PUSH
73505: LD_INT 1
73507: ARRAY
73508: PUSH
73509: LD_INT 1
73511: ARRAY
73512: PPUSH
73513: LD_EXP 60
73517: PUSH
73518: LD_VAR 0 2
73522: ARRAY
73523: PUSH
73524: LD_INT 1
73526: ARRAY
73527: PUSH
73528: LD_INT 2
73530: ARRAY
73531: PPUSH
73532: LD_EXP 49
73536: PUSH
73537: LD_VAR 0 2
73541: ARRAY
73542: PPUSH
73543: CALL_OW 440
73547: IFFALSE 73590
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
73549: LD_ADDR_EXP 60
73553: PUSH
73554: LD_EXP 60
73558: PPUSH
73559: LD_VAR 0 2
73563: PPUSH
73564: LD_EXP 60
73568: PUSH
73569: LD_VAR 0 2
73573: ARRAY
73574: PPUSH
73575: LD_INT 1
73577: PPUSH
73578: CALL_OW 3
73582: PPUSH
73583: CALL_OW 1
73587: ST_TO_ADDR
73588: GO 73837
// begin if not mc_deposits_finder [ i ] then
73590: LD_EXP 61
73594: PUSH
73595: LD_VAR 0 2
73599: ARRAY
73600: NOT
73601: IFFALSE 73653
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
73603: LD_ADDR_EXP 61
73607: PUSH
73608: LD_EXP 61
73612: PPUSH
73613: LD_VAR 0 2
73617: PPUSH
73618: LD_VAR 0 3
73622: PUSH
73623: LD_INT 1
73625: ARRAY
73626: PUSH
73627: EMPTY
73628: LIST
73629: PPUSH
73630: CALL_OW 1
73634: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
73635: LD_VAR 0 3
73639: PUSH
73640: LD_INT 1
73642: ARRAY
73643: PPUSH
73644: LD_INT 125
73646: PPUSH
73647: CALL_OW 109
// end else
73651: GO 73837
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
73653: LD_EXP 61
73657: PUSH
73658: LD_VAR 0 2
73662: ARRAY
73663: PUSH
73664: LD_INT 1
73666: ARRAY
73667: PPUSH
73668: CALL_OW 310
73672: IFFALSE 73695
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
73674: LD_EXP 61
73678: PUSH
73679: LD_VAR 0 2
73683: ARRAY
73684: PUSH
73685: LD_INT 1
73687: ARRAY
73688: PPUSH
73689: CALL_OW 122
73693: GO 73837
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
73695: LD_EXP 61
73699: PUSH
73700: LD_VAR 0 2
73704: ARRAY
73705: PUSH
73706: LD_INT 1
73708: ARRAY
73709: PPUSH
73710: CALL_OW 314
73714: NOT
73715: PUSH
73716: LD_EXP 61
73720: PUSH
73721: LD_VAR 0 2
73725: ARRAY
73726: PUSH
73727: LD_INT 1
73729: ARRAY
73730: PPUSH
73731: LD_EXP 60
73735: PUSH
73736: LD_VAR 0 2
73740: ARRAY
73741: PUSH
73742: LD_INT 1
73744: ARRAY
73745: PUSH
73746: LD_INT 1
73748: ARRAY
73749: PPUSH
73750: LD_EXP 60
73754: PUSH
73755: LD_VAR 0 2
73759: ARRAY
73760: PUSH
73761: LD_INT 1
73763: ARRAY
73764: PUSH
73765: LD_INT 2
73767: ARRAY
73768: PPUSH
73769: CALL_OW 297
73773: PUSH
73774: LD_INT 6
73776: GREATER
73777: AND
73778: IFFALSE 73837
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
73780: LD_EXP 61
73784: PUSH
73785: LD_VAR 0 2
73789: ARRAY
73790: PUSH
73791: LD_INT 1
73793: ARRAY
73794: PPUSH
73795: LD_EXP 60
73799: PUSH
73800: LD_VAR 0 2
73804: ARRAY
73805: PUSH
73806: LD_INT 1
73808: ARRAY
73809: PUSH
73810: LD_INT 1
73812: ARRAY
73813: PPUSH
73814: LD_EXP 60
73818: PUSH
73819: LD_VAR 0 2
73823: ARRAY
73824: PUSH
73825: LD_INT 1
73827: ARRAY
73828: PUSH
73829: LD_INT 2
73831: ARRAY
73832: PPUSH
73833: CALL_OW 111
// end ; end ; end ;
73837: GO 73250
73839: POP
73840: POP
// end ;
73841: LD_VAR 0 1
73845: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
73846: LD_INT 0
73848: PPUSH
73849: PPUSH
73850: PPUSH
73851: PPUSH
73852: PPUSH
73853: PPUSH
73854: PPUSH
73855: PPUSH
73856: PPUSH
73857: PPUSH
73858: PPUSH
// if not mc_bases then
73859: LD_EXP 23
73863: NOT
73864: IFFALSE 73868
// exit ;
73866: GO 74808
// for i = 1 to mc_bases do
73868: LD_ADDR_VAR 0 2
73872: PUSH
73873: DOUBLE
73874: LD_INT 1
73876: DEC
73877: ST_TO_ADDR
73878: LD_EXP 23
73882: PUSH
73883: FOR_TO
73884: IFFALSE 74806
// begin if not mc_bases [ i ] or mc_scan [ i ] then
73886: LD_EXP 23
73890: PUSH
73891: LD_VAR 0 2
73895: ARRAY
73896: NOT
73897: PUSH
73898: LD_EXP 46
73902: PUSH
73903: LD_VAR 0 2
73907: ARRAY
73908: OR
73909: IFFALSE 73913
// continue ;
73911: GO 73883
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
73913: LD_ADDR_VAR 0 7
73917: PUSH
73918: LD_EXP 23
73922: PUSH
73923: LD_VAR 0 2
73927: ARRAY
73928: PUSH
73929: LD_INT 1
73931: ARRAY
73932: PPUSH
73933: CALL_OW 248
73937: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
73938: LD_VAR 0 7
73942: PUSH
73943: LD_INT 3
73945: EQUAL
73946: PUSH
73947: LD_EXP 42
73951: PUSH
73952: LD_VAR 0 2
73956: ARRAY
73957: PUSH
73958: LD_EXP 45
73962: PUSH
73963: LD_VAR 0 2
73967: ARRAY
73968: UNION
73969: PPUSH
73970: LD_INT 33
73972: PUSH
73973: LD_INT 2
73975: PUSH
73976: EMPTY
73977: LIST
73978: LIST
73979: PPUSH
73980: CALL_OW 72
73984: NOT
73985: OR
73986: IFFALSE 73990
// continue ;
73988: GO 73883
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
73990: LD_ADDR_VAR 0 9
73994: PUSH
73995: LD_EXP 23
73999: PUSH
74000: LD_VAR 0 2
74004: ARRAY
74005: PPUSH
74006: LD_INT 30
74008: PUSH
74009: LD_INT 36
74011: PUSH
74012: EMPTY
74013: LIST
74014: LIST
74015: PPUSH
74016: CALL_OW 72
74020: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
74021: LD_ADDR_VAR 0 10
74025: PUSH
74026: LD_EXP 42
74030: PUSH
74031: LD_VAR 0 2
74035: ARRAY
74036: PPUSH
74037: LD_INT 34
74039: PUSH
74040: LD_INT 31
74042: PUSH
74043: EMPTY
74044: LIST
74045: LIST
74046: PPUSH
74047: CALL_OW 72
74051: ST_TO_ADDR
// if not cts and not mcts then
74052: LD_VAR 0 9
74056: NOT
74057: PUSH
74058: LD_VAR 0 10
74062: NOT
74063: AND
74064: IFFALSE 74068
// continue ;
74066: GO 73883
// x := cts ;
74068: LD_ADDR_VAR 0 11
74072: PUSH
74073: LD_VAR 0 9
74077: ST_TO_ADDR
// if not x then
74078: LD_VAR 0 11
74082: NOT
74083: IFFALSE 74095
// x := mcts ;
74085: LD_ADDR_VAR 0 11
74089: PUSH
74090: LD_VAR 0 10
74094: ST_TO_ADDR
// if not x then
74095: LD_VAR 0 11
74099: NOT
74100: IFFALSE 74104
// continue ;
74102: GO 73883
// if mc_remote_driver [ i ] then
74104: LD_EXP 63
74108: PUSH
74109: LD_VAR 0 2
74113: ARRAY
74114: IFFALSE 74501
// for j in mc_remote_driver [ i ] do
74116: LD_ADDR_VAR 0 3
74120: PUSH
74121: LD_EXP 63
74125: PUSH
74126: LD_VAR 0 2
74130: ARRAY
74131: PUSH
74132: FOR_IN
74133: IFFALSE 74499
// begin if GetClass ( j ) <> 3 then
74135: LD_VAR 0 3
74139: PPUSH
74140: CALL_OW 257
74144: PUSH
74145: LD_INT 3
74147: NONEQUAL
74148: IFFALSE 74201
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
74150: LD_ADDR_EXP 63
74154: PUSH
74155: LD_EXP 63
74159: PPUSH
74160: LD_VAR 0 2
74164: PPUSH
74165: LD_EXP 63
74169: PUSH
74170: LD_VAR 0 2
74174: ARRAY
74175: PUSH
74176: LD_VAR 0 3
74180: DIFF
74181: PPUSH
74182: CALL_OW 1
74186: ST_TO_ADDR
// SetTag ( j , 0 ) ;
74187: LD_VAR 0 3
74191: PPUSH
74192: LD_INT 0
74194: PPUSH
74195: CALL_OW 109
// continue ;
74199: GO 74132
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
74201: LD_EXP 42
74205: PUSH
74206: LD_VAR 0 2
74210: ARRAY
74211: PPUSH
74212: LD_INT 34
74214: PUSH
74215: LD_INT 31
74217: PUSH
74218: EMPTY
74219: LIST
74220: LIST
74221: PUSH
74222: LD_INT 58
74224: PUSH
74225: EMPTY
74226: LIST
74227: PUSH
74228: EMPTY
74229: LIST
74230: LIST
74231: PPUSH
74232: CALL_OW 72
74236: PUSH
74237: LD_VAR 0 3
74241: PPUSH
74242: CALL 46004 0 1
74246: NOT
74247: AND
74248: IFFALSE 74319
// begin if IsInUnit ( j ) then
74250: LD_VAR 0 3
74254: PPUSH
74255: CALL_OW 310
74259: IFFALSE 74270
// ComExitBuilding ( j ) ;
74261: LD_VAR 0 3
74265: PPUSH
74266: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
74270: LD_VAR 0 3
74274: PPUSH
74275: LD_EXP 42
74279: PUSH
74280: LD_VAR 0 2
74284: ARRAY
74285: PPUSH
74286: LD_INT 34
74288: PUSH
74289: LD_INT 31
74291: PUSH
74292: EMPTY
74293: LIST
74294: LIST
74295: PUSH
74296: LD_INT 58
74298: PUSH
74299: EMPTY
74300: LIST
74301: PUSH
74302: EMPTY
74303: LIST
74304: LIST
74305: PPUSH
74306: CALL_OW 72
74310: PUSH
74311: LD_INT 1
74313: ARRAY
74314: PPUSH
74315: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
74319: LD_VAR 0 3
74323: PPUSH
74324: CALL_OW 310
74328: NOT
74329: PUSH
74330: LD_VAR 0 3
74334: PPUSH
74335: CALL_OW 310
74339: PPUSH
74340: CALL_OW 266
74344: PUSH
74345: LD_INT 36
74347: NONEQUAL
74348: PUSH
74349: LD_VAR 0 3
74353: PPUSH
74354: CALL 46004 0 1
74358: NOT
74359: AND
74360: OR
74361: IFFALSE 74497
// begin if IsInUnit ( j ) then
74363: LD_VAR 0 3
74367: PPUSH
74368: CALL_OW 310
74372: IFFALSE 74383
// ComExitBuilding ( j ) ;
74374: LD_VAR 0 3
74378: PPUSH
74379: CALL_OW 122
// ct := 0 ;
74383: LD_ADDR_VAR 0 8
74387: PUSH
74388: LD_INT 0
74390: ST_TO_ADDR
// for k in x do
74391: LD_ADDR_VAR 0 4
74395: PUSH
74396: LD_VAR 0 11
74400: PUSH
74401: FOR_IN
74402: IFFALSE 74475
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
74404: LD_VAR 0 4
74408: PPUSH
74409: CALL_OW 264
74413: PUSH
74414: LD_INT 31
74416: EQUAL
74417: PUSH
74418: LD_VAR 0 4
74422: PPUSH
74423: CALL_OW 311
74427: NOT
74428: AND
74429: PUSH
74430: LD_VAR 0 4
74434: PPUSH
74435: CALL_OW 266
74439: PUSH
74440: LD_INT 36
74442: EQUAL
74443: PUSH
74444: LD_VAR 0 4
74448: PPUSH
74449: CALL_OW 313
74453: PUSH
74454: LD_INT 3
74456: LESS
74457: AND
74458: OR
74459: IFFALSE 74473
// begin ct := k ;
74461: LD_ADDR_VAR 0 8
74465: PUSH
74466: LD_VAR 0 4
74470: ST_TO_ADDR
// break ;
74471: GO 74475
// end ;
74473: GO 74401
74475: POP
74476: POP
// if ct then
74477: LD_VAR 0 8
74481: IFFALSE 74497
// ComEnterUnit ( j , ct ) ;
74483: LD_VAR 0 3
74487: PPUSH
74488: LD_VAR 0 8
74492: PPUSH
74493: CALL_OW 120
// end ; end ;
74497: GO 74132
74499: POP
74500: POP
// places := 0 ;
74501: LD_ADDR_VAR 0 5
74505: PUSH
74506: LD_INT 0
74508: ST_TO_ADDR
// for j = 1 to x do
74509: LD_ADDR_VAR 0 3
74513: PUSH
74514: DOUBLE
74515: LD_INT 1
74517: DEC
74518: ST_TO_ADDR
74519: LD_VAR 0 11
74523: PUSH
74524: FOR_TO
74525: IFFALSE 74601
// if GetWeapon ( x [ j ] ) = ar_control_tower then
74527: LD_VAR 0 11
74531: PUSH
74532: LD_VAR 0 3
74536: ARRAY
74537: PPUSH
74538: CALL_OW 264
74542: PUSH
74543: LD_INT 31
74545: EQUAL
74546: IFFALSE 74564
// places := places + 1 else
74548: LD_ADDR_VAR 0 5
74552: PUSH
74553: LD_VAR 0 5
74557: PUSH
74558: LD_INT 1
74560: PLUS
74561: ST_TO_ADDR
74562: GO 74599
// if GetBType ( x [ j ] ) = b_control_tower then
74564: LD_VAR 0 11
74568: PUSH
74569: LD_VAR 0 3
74573: ARRAY
74574: PPUSH
74575: CALL_OW 266
74579: PUSH
74580: LD_INT 36
74582: EQUAL
74583: IFFALSE 74599
// places := places + 3 ;
74585: LD_ADDR_VAR 0 5
74589: PUSH
74590: LD_VAR 0 5
74594: PUSH
74595: LD_INT 3
74597: PLUS
74598: ST_TO_ADDR
74599: GO 74524
74601: POP
74602: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
74603: LD_VAR 0 5
74607: PUSH
74608: LD_INT 0
74610: EQUAL
74611: PUSH
74612: LD_VAR 0 5
74616: PUSH
74617: LD_EXP 63
74621: PUSH
74622: LD_VAR 0 2
74626: ARRAY
74627: LESSEQUAL
74628: OR
74629: IFFALSE 74633
// continue ;
74631: GO 73883
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
74633: LD_ADDR_VAR 0 6
74637: PUSH
74638: LD_EXP 23
74642: PUSH
74643: LD_VAR 0 2
74647: ARRAY
74648: PPUSH
74649: LD_INT 25
74651: PUSH
74652: LD_INT 3
74654: PUSH
74655: EMPTY
74656: LIST
74657: LIST
74658: PPUSH
74659: CALL_OW 72
74663: PUSH
74664: LD_EXP 63
74668: PUSH
74669: LD_VAR 0 2
74673: ARRAY
74674: DIFF
74675: PPUSH
74676: LD_INT 3
74678: PPUSH
74679: CALL 46904 0 2
74683: ST_TO_ADDR
// for j in tmp do
74684: LD_ADDR_VAR 0 3
74688: PUSH
74689: LD_VAR 0 6
74693: PUSH
74694: FOR_IN
74695: IFFALSE 74730
// if GetTag ( j ) > 0 then
74697: LD_VAR 0 3
74701: PPUSH
74702: CALL_OW 110
74706: PUSH
74707: LD_INT 0
74709: GREATER
74710: IFFALSE 74728
// tmp := tmp diff j ;
74712: LD_ADDR_VAR 0 6
74716: PUSH
74717: LD_VAR 0 6
74721: PUSH
74722: LD_VAR 0 3
74726: DIFF
74727: ST_TO_ADDR
74728: GO 74694
74730: POP
74731: POP
// if not tmp then
74732: LD_VAR 0 6
74736: NOT
74737: IFFALSE 74741
// continue ;
74739: GO 73883
// if places then
74741: LD_VAR 0 5
74745: IFFALSE 74804
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
74747: LD_ADDR_EXP 63
74751: PUSH
74752: LD_EXP 63
74756: PPUSH
74757: LD_VAR 0 2
74761: PPUSH
74762: LD_EXP 63
74766: PUSH
74767: LD_VAR 0 2
74771: ARRAY
74772: PUSH
74773: LD_VAR 0 6
74777: PUSH
74778: LD_INT 1
74780: ARRAY
74781: UNION
74782: PPUSH
74783: CALL_OW 1
74787: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
74788: LD_VAR 0 6
74792: PUSH
74793: LD_INT 1
74795: ARRAY
74796: PPUSH
74797: LD_INT 126
74799: PPUSH
74800: CALL_OW 109
// end ; end ;
74804: GO 73883
74806: POP
74807: POP
// end ;
74808: LD_VAR 0 1
74812: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
74813: LD_INT 0
74815: PPUSH
74816: PPUSH
74817: PPUSH
74818: PPUSH
74819: PPUSH
74820: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
74821: LD_VAR 0 1
74825: NOT
74826: PUSH
74827: LD_VAR 0 2
74831: NOT
74832: OR
74833: PUSH
74834: LD_VAR 0 3
74838: NOT
74839: OR
74840: PUSH
74841: LD_VAR 0 4
74845: PUSH
74846: LD_INT 1
74848: PUSH
74849: LD_INT 2
74851: PUSH
74852: LD_INT 3
74854: PUSH
74855: LD_INT 4
74857: PUSH
74858: LD_INT 5
74860: PUSH
74861: LD_INT 8
74863: PUSH
74864: LD_INT 9
74866: PUSH
74867: LD_INT 15
74869: PUSH
74870: LD_INT 16
74872: PUSH
74873: EMPTY
74874: LIST
74875: LIST
74876: LIST
74877: LIST
74878: LIST
74879: LIST
74880: LIST
74881: LIST
74882: LIST
74883: IN
74884: NOT
74885: OR
74886: IFFALSE 74890
// exit ;
74888: GO 75790
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
74890: LD_ADDR_VAR 0 2
74894: PUSH
74895: LD_VAR 0 2
74899: PPUSH
74900: LD_INT 21
74902: PUSH
74903: LD_INT 3
74905: PUSH
74906: EMPTY
74907: LIST
74908: LIST
74909: PUSH
74910: LD_INT 24
74912: PUSH
74913: LD_INT 250
74915: PUSH
74916: EMPTY
74917: LIST
74918: LIST
74919: PUSH
74920: EMPTY
74921: LIST
74922: LIST
74923: PPUSH
74924: CALL_OW 72
74928: ST_TO_ADDR
// case class of 1 , 15 :
74929: LD_VAR 0 4
74933: PUSH
74934: LD_INT 1
74936: DOUBLE
74937: EQUAL
74938: IFTRUE 74948
74940: LD_INT 15
74942: DOUBLE
74943: EQUAL
74944: IFTRUE 74948
74946: GO 75033
74948: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
74949: LD_ADDR_VAR 0 8
74953: PUSH
74954: LD_VAR 0 2
74958: PPUSH
74959: LD_INT 2
74961: PUSH
74962: LD_INT 30
74964: PUSH
74965: LD_INT 32
74967: PUSH
74968: EMPTY
74969: LIST
74970: LIST
74971: PUSH
74972: LD_INT 30
74974: PUSH
74975: LD_INT 31
74977: PUSH
74978: EMPTY
74979: LIST
74980: LIST
74981: PUSH
74982: EMPTY
74983: LIST
74984: LIST
74985: LIST
74986: PPUSH
74987: CALL_OW 72
74991: PUSH
74992: LD_VAR 0 2
74996: PPUSH
74997: LD_INT 2
74999: PUSH
75000: LD_INT 30
75002: PUSH
75003: LD_INT 4
75005: PUSH
75006: EMPTY
75007: LIST
75008: LIST
75009: PUSH
75010: LD_INT 30
75012: PUSH
75013: LD_INT 5
75015: PUSH
75016: EMPTY
75017: LIST
75018: LIST
75019: PUSH
75020: EMPTY
75021: LIST
75022: LIST
75023: LIST
75024: PPUSH
75025: CALL_OW 72
75029: ADD
75030: ST_TO_ADDR
75031: GO 75279
75033: LD_INT 2
75035: DOUBLE
75036: EQUAL
75037: IFTRUE 75047
75039: LD_INT 16
75041: DOUBLE
75042: EQUAL
75043: IFTRUE 75047
75045: GO 75093
75047: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
75048: LD_ADDR_VAR 0 8
75052: PUSH
75053: LD_VAR 0 2
75057: PPUSH
75058: LD_INT 2
75060: PUSH
75061: LD_INT 30
75063: PUSH
75064: LD_INT 0
75066: PUSH
75067: EMPTY
75068: LIST
75069: LIST
75070: PUSH
75071: LD_INT 30
75073: PUSH
75074: LD_INT 1
75076: PUSH
75077: EMPTY
75078: LIST
75079: LIST
75080: PUSH
75081: EMPTY
75082: LIST
75083: LIST
75084: LIST
75085: PPUSH
75086: CALL_OW 72
75090: ST_TO_ADDR
75091: GO 75279
75093: LD_INT 3
75095: DOUBLE
75096: EQUAL
75097: IFTRUE 75101
75099: GO 75147
75101: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
75102: LD_ADDR_VAR 0 8
75106: PUSH
75107: LD_VAR 0 2
75111: PPUSH
75112: LD_INT 2
75114: PUSH
75115: LD_INT 30
75117: PUSH
75118: LD_INT 2
75120: PUSH
75121: EMPTY
75122: LIST
75123: LIST
75124: PUSH
75125: LD_INT 30
75127: PUSH
75128: LD_INT 3
75130: PUSH
75131: EMPTY
75132: LIST
75133: LIST
75134: PUSH
75135: EMPTY
75136: LIST
75137: LIST
75138: LIST
75139: PPUSH
75140: CALL_OW 72
75144: ST_TO_ADDR
75145: GO 75279
75147: LD_INT 4
75149: DOUBLE
75150: EQUAL
75151: IFTRUE 75155
75153: GO 75212
75155: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
75156: LD_ADDR_VAR 0 8
75160: PUSH
75161: LD_VAR 0 2
75165: PPUSH
75166: LD_INT 2
75168: PUSH
75169: LD_INT 30
75171: PUSH
75172: LD_INT 6
75174: PUSH
75175: EMPTY
75176: LIST
75177: LIST
75178: PUSH
75179: LD_INT 30
75181: PUSH
75182: LD_INT 7
75184: PUSH
75185: EMPTY
75186: LIST
75187: LIST
75188: PUSH
75189: LD_INT 30
75191: PUSH
75192: LD_INT 8
75194: PUSH
75195: EMPTY
75196: LIST
75197: LIST
75198: PUSH
75199: EMPTY
75200: LIST
75201: LIST
75202: LIST
75203: LIST
75204: PPUSH
75205: CALL_OW 72
75209: ST_TO_ADDR
75210: GO 75279
75212: LD_INT 5
75214: DOUBLE
75215: EQUAL
75216: IFTRUE 75232
75218: LD_INT 8
75220: DOUBLE
75221: EQUAL
75222: IFTRUE 75232
75224: LD_INT 9
75226: DOUBLE
75227: EQUAL
75228: IFTRUE 75232
75230: GO 75278
75232: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
75233: LD_ADDR_VAR 0 8
75237: PUSH
75238: LD_VAR 0 2
75242: PPUSH
75243: LD_INT 2
75245: PUSH
75246: LD_INT 30
75248: PUSH
75249: LD_INT 4
75251: PUSH
75252: EMPTY
75253: LIST
75254: LIST
75255: PUSH
75256: LD_INT 30
75258: PUSH
75259: LD_INT 5
75261: PUSH
75262: EMPTY
75263: LIST
75264: LIST
75265: PUSH
75266: EMPTY
75267: LIST
75268: LIST
75269: LIST
75270: PPUSH
75271: CALL_OW 72
75275: ST_TO_ADDR
75276: GO 75279
75278: POP
// if not tmp then
75279: LD_VAR 0 8
75283: NOT
75284: IFFALSE 75288
// exit ;
75286: GO 75790
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
75288: LD_VAR 0 4
75292: PUSH
75293: LD_INT 1
75295: PUSH
75296: LD_INT 15
75298: PUSH
75299: EMPTY
75300: LIST
75301: LIST
75302: IN
75303: PUSH
75304: LD_EXP 32
75308: PUSH
75309: LD_VAR 0 1
75313: ARRAY
75314: AND
75315: IFFALSE 75471
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
75317: LD_ADDR_VAR 0 9
75321: PUSH
75322: LD_EXP 32
75326: PUSH
75327: LD_VAR 0 1
75331: ARRAY
75332: PUSH
75333: LD_INT 1
75335: ARRAY
75336: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
75337: LD_VAR 0 9
75341: PUSH
75342: LD_EXP 33
75346: PUSH
75347: LD_VAR 0 1
75351: ARRAY
75352: IN
75353: NOT
75354: IFFALSE 75469
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
75356: LD_ADDR_EXP 33
75360: PUSH
75361: LD_EXP 33
75365: PPUSH
75366: LD_VAR 0 1
75370: PUSH
75371: LD_EXP 33
75375: PUSH
75376: LD_VAR 0 1
75380: ARRAY
75381: PUSH
75382: LD_INT 1
75384: PLUS
75385: PUSH
75386: EMPTY
75387: LIST
75388: LIST
75389: PPUSH
75390: LD_VAR 0 9
75394: PPUSH
75395: CALL 16156 0 3
75399: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
75400: LD_ADDR_EXP 32
75404: PUSH
75405: LD_EXP 32
75409: PPUSH
75410: LD_VAR 0 1
75414: PPUSH
75415: LD_EXP 32
75419: PUSH
75420: LD_VAR 0 1
75424: ARRAY
75425: PUSH
75426: LD_VAR 0 9
75430: DIFF
75431: PPUSH
75432: CALL_OW 1
75436: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
75437: LD_VAR 0 3
75441: PPUSH
75442: LD_EXP 33
75446: PUSH
75447: LD_VAR 0 1
75451: ARRAY
75452: PUSH
75453: LD_EXP 33
75457: PUSH
75458: LD_VAR 0 1
75462: ARRAY
75463: ARRAY
75464: PPUSH
75465: CALL_OW 120
// end ; exit ;
75469: GO 75790
// end ; if tmp > 1 then
75471: LD_VAR 0 8
75475: PUSH
75476: LD_INT 1
75478: GREATER
75479: IFFALSE 75583
// for i = 2 to tmp do
75481: LD_ADDR_VAR 0 6
75485: PUSH
75486: DOUBLE
75487: LD_INT 2
75489: DEC
75490: ST_TO_ADDR
75491: LD_VAR 0 8
75495: PUSH
75496: FOR_TO
75497: IFFALSE 75581
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
75499: LD_VAR 0 8
75503: PUSH
75504: LD_VAR 0 6
75508: ARRAY
75509: PPUSH
75510: CALL_OW 461
75514: PUSH
75515: LD_INT 6
75517: EQUAL
75518: IFFALSE 75579
// begin x := tmp [ i ] ;
75520: LD_ADDR_VAR 0 9
75524: PUSH
75525: LD_VAR 0 8
75529: PUSH
75530: LD_VAR 0 6
75534: ARRAY
75535: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
75536: LD_ADDR_VAR 0 8
75540: PUSH
75541: LD_VAR 0 8
75545: PPUSH
75546: LD_VAR 0 6
75550: PPUSH
75551: CALL_OW 3
75555: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
75556: LD_ADDR_VAR 0 8
75560: PUSH
75561: LD_VAR 0 8
75565: PPUSH
75566: LD_INT 1
75568: PPUSH
75569: LD_VAR 0 9
75573: PPUSH
75574: CALL_OW 2
75578: ST_TO_ADDR
// end ;
75579: GO 75496
75581: POP
75582: POP
// for i in tmp do
75583: LD_ADDR_VAR 0 6
75587: PUSH
75588: LD_VAR 0 8
75592: PUSH
75593: FOR_IN
75594: IFFALSE 75663
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
75596: LD_VAR 0 6
75600: PPUSH
75601: CALL_OW 313
75605: PUSH
75606: LD_INT 6
75608: LESS
75609: PUSH
75610: LD_VAR 0 6
75614: PPUSH
75615: CALL_OW 266
75619: PUSH
75620: LD_INT 31
75622: PUSH
75623: LD_INT 32
75625: PUSH
75626: EMPTY
75627: LIST
75628: LIST
75629: IN
75630: NOT
75631: AND
75632: PUSH
75633: LD_VAR 0 6
75637: PPUSH
75638: CALL_OW 313
75642: PUSH
75643: LD_INT 0
75645: EQUAL
75646: OR
75647: IFFALSE 75661
// begin j := i ;
75649: LD_ADDR_VAR 0 7
75653: PUSH
75654: LD_VAR 0 6
75658: ST_TO_ADDR
// break ;
75659: GO 75663
// end ; end ;
75661: GO 75593
75663: POP
75664: POP
// if j then
75665: LD_VAR 0 7
75669: IFFALSE 75687
// ComEnterUnit ( unit , j ) else
75671: LD_VAR 0 3
75675: PPUSH
75676: LD_VAR 0 7
75680: PPUSH
75681: CALL_OW 120
75685: GO 75790
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75687: LD_ADDR_VAR 0 10
75691: PUSH
75692: LD_VAR 0 2
75696: PPUSH
75697: LD_INT 2
75699: PUSH
75700: LD_INT 30
75702: PUSH
75703: LD_INT 0
75705: PUSH
75706: EMPTY
75707: LIST
75708: LIST
75709: PUSH
75710: LD_INT 30
75712: PUSH
75713: LD_INT 1
75715: PUSH
75716: EMPTY
75717: LIST
75718: LIST
75719: PUSH
75720: EMPTY
75721: LIST
75722: LIST
75723: LIST
75724: PPUSH
75725: CALL_OW 72
75729: ST_TO_ADDR
// if depot then
75730: LD_VAR 0 10
75734: IFFALSE 75790
// begin depot := NearestUnitToUnit ( depot , unit ) ;
75736: LD_ADDR_VAR 0 10
75740: PUSH
75741: LD_VAR 0 10
75745: PPUSH
75746: LD_VAR 0 3
75750: PPUSH
75751: CALL_OW 74
75755: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
75756: LD_VAR 0 3
75760: PPUSH
75761: LD_VAR 0 10
75765: PPUSH
75766: CALL_OW 296
75770: PUSH
75771: LD_INT 10
75773: GREATER
75774: IFFALSE 75790
// ComStandNearbyBuilding ( unit , depot ) ;
75776: LD_VAR 0 3
75780: PPUSH
75781: LD_VAR 0 10
75785: PPUSH
75786: CALL 12583 0 2
// end ; end ; end ;
75790: LD_VAR 0 5
75794: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
75795: LD_INT 0
75797: PPUSH
75798: PPUSH
75799: PPUSH
75800: PPUSH
// if not mc_bases then
75801: LD_EXP 23
75805: NOT
75806: IFFALSE 75810
// exit ;
75808: GO 76049
// for i = 1 to mc_bases do
75810: LD_ADDR_VAR 0 2
75814: PUSH
75815: DOUBLE
75816: LD_INT 1
75818: DEC
75819: ST_TO_ADDR
75820: LD_EXP 23
75824: PUSH
75825: FOR_TO
75826: IFFALSE 76047
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
75828: LD_ADDR_VAR 0 4
75832: PUSH
75833: LD_EXP 23
75837: PUSH
75838: LD_VAR 0 2
75842: ARRAY
75843: PPUSH
75844: LD_INT 21
75846: PUSH
75847: LD_INT 1
75849: PUSH
75850: EMPTY
75851: LIST
75852: LIST
75853: PPUSH
75854: CALL_OW 72
75858: PUSH
75859: LD_EXP 52
75863: PUSH
75864: LD_VAR 0 2
75868: ARRAY
75869: UNION
75870: ST_TO_ADDR
// if not tmp then
75871: LD_VAR 0 4
75875: NOT
75876: IFFALSE 75880
// continue ;
75878: GO 75825
// for j in tmp do
75880: LD_ADDR_VAR 0 3
75884: PUSH
75885: LD_VAR 0 4
75889: PUSH
75890: FOR_IN
75891: IFFALSE 76043
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
75893: LD_VAR 0 3
75897: PPUSH
75898: CALL_OW 110
75902: NOT
75903: PUSH
75904: LD_VAR 0 3
75908: PPUSH
75909: CALL_OW 314
75913: NOT
75914: AND
75915: PUSH
75916: LD_VAR 0 3
75920: PPUSH
75921: CALL_OW 311
75925: NOT
75926: AND
75927: PUSH
75928: LD_VAR 0 3
75932: PPUSH
75933: CALL_OW 310
75937: NOT
75938: AND
75939: PUSH
75940: LD_VAR 0 3
75944: PUSH
75945: LD_EXP 26
75949: PUSH
75950: LD_VAR 0 2
75954: ARRAY
75955: PUSH
75956: LD_INT 1
75958: ARRAY
75959: IN
75960: NOT
75961: AND
75962: PUSH
75963: LD_VAR 0 3
75967: PUSH
75968: LD_EXP 26
75972: PUSH
75973: LD_VAR 0 2
75977: ARRAY
75978: PUSH
75979: LD_INT 2
75981: ARRAY
75982: IN
75983: NOT
75984: AND
75985: PUSH
75986: LD_VAR 0 3
75990: PUSH
75991: LD_EXP 35
75995: PUSH
75996: LD_VAR 0 2
76000: ARRAY
76001: IN
76002: NOT
76003: AND
76004: IFFALSE 76041
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
76006: LD_VAR 0 2
76010: PPUSH
76011: LD_EXP 23
76015: PUSH
76016: LD_VAR 0 2
76020: ARRAY
76021: PPUSH
76022: LD_VAR 0 3
76026: PPUSH
76027: LD_VAR 0 3
76031: PPUSH
76032: CALL_OW 257
76036: PPUSH
76037: CALL 74813 0 4
// end ;
76041: GO 75890
76043: POP
76044: POP
// end ;
76045: GO 75825
76047: POP
76048: POP
// end ;
76049: LD_VAR 0 1
76053: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
76054: LD_INT 0
76056: PPUSH
76057: PPUSH
76058: PPUSH
76059: PPUSH
76060: PPUSH
76061: PPUSH
// if not mc_bases [ base ] then
76062: LD_EXP 23
76066: PUSH
76067: LD_VAR 0 1
76071: ARRAY
76072: NOT
76073: IFFALSE 76077
// exit ;
76075: GO 76259
// tmp := [ ] ;
76077: LD_ADDR_VAR 0 6
76081: PUSH
76082: EMPTY
76083: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
76084: LD_ADDR_VAR 0 7
76088: PUSH
76089: LD_VAR 0 3
76093: PPUSH
76094: LD_INT 0
76096: PPUSH
76097: CALL_OW 517
76101: ST_TO_ADDR
// if not list then
76102: LD_VAR 0 7
76106: NOT
76107: IFFALSE 76111
// exit ;
76109: GO 76259
// for i = 1 to amount do
76111: LD_ADDR_VAR 0 5
76115: PUSH
76116: DOUBLE
76117: LD_INT 1
76119: DEC
76120: ST_TO_ADDR
76121: LD_VAR 0 2
76125: PUSH
76126: FOR_TO
76127: IFFALSE 76207
// begin x := rand ( 1 , list [ 1 ] ) ;
76129: LD_ADDR_VAR 0 8
76133: PUSH
76134: LD_INT 1
76136: PPUSH
76137: LD_VAR 0 7
76141: PUSH
76142: LD_INT 1
76144: ARRAY
76145: PPUSH
76146: CALL_OW 12
76150: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
76151: LD_ADDR_VAR 0 6
76155: PUSH
76156: LD_VAR 0 6
76160: PPUSH
76161: LD_VAR 0 5
76165: PPUSH
76166: LD_VAR 0 7
76170: PUSH
76171: LD_INT 1
76173: ARRAY
76174: PUSH
76175: LD_VAR 0 8
76179: ARRAY
76180: PUSH
76181: LD_VAR 0 7
76185: PUSH
76186: LD_INT 2
76188: ARRAY
76189: PUSH
76190: LD_VAR 0 8
76194: ARRAY
76195: PUSH
76196: EMPTY
76197: LIST
76198: LIST
76199: PPUSH
76200: CALL_OW 1
76204: ST_TO_ADDR
// end ;
76205: GO 76126
76207: POP
76208: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
76209: LD_ADDR_EXP 36
76213: PUSH
76214: LD_EXP 36
76218: PPUSH
76219: LD_VAR 0 1
76223: PPUSH
76224: LD_VAR 0 6
76228: PPUSH
76229: CALL_OW 1
76233: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
76234: LD_ADDR_EXP 38
76238: PUSH
76239: LD_EXP 38
76243: PPUSH
76244: LD_VAR 0 1
76248: PPUSH
76249: LD_VAR 0 3
76253: PPUSH
76254: CALL_OW 1
76258: ST_TO_ADDR
// end ;
76259: LD_VAR 0 4
76263: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
76264: LD_INT 0
76266: PPUSH
// if not mc_bases [ base ] then
76267: LD_EXP 23
76271: PUSH
76272: LD_VAR 0 1
76276: ARRAY
76277: NOT
76278: IFFALSE 76282
// exit ;
76280: GO 76307
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
76282: LD_ADDR_EXP 28
76286: PUSH
76287: LD_EXP 28
76291: PPUSH
76292: LD_VAR 0 1
76296: PPUSH
76297: LD_VAR 0 2
76301: PPUSH
76302: CALL_OW 1
76306: ST_TO_ADDR
// end ;
76307: LD_VAR 0 3
76311: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
76312: LD_INT 0
76314: PPUSH
// if not mc_bases [ base ] then
76315: LD_EXP 23
76319: PUSH
76320: LD_VAR 0 1
76324: ARRAY
76325: NOT
76326: IFFALSE 76330
// exit ;
76328: GO 76367
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
76330: LD_ADDR_EXP 28
76334: PUSH
76335: LD_EXP 28
76339: PPUSH
76340: LD_VAR 0 1
76344: PPUSH
76345: LD_EXP 28
76349: PUSH
76350: LD_VAR 0 1
76354: ARRAY
76355: PUSH
76356: LD_VAR 0 2
76360: UNION
76361: PPUSH
76362: CALL_OW 1
76366: ST_TO_ADDR
// end ;
76367: LD_VAR 0 3
76371: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
76372: LD_INT 0
76374: PPUSH
// if not mc_bases [ base ] then
76375: LD_EXP 23
76379: PUSH
76380: LD_VAR 0 1
76384: ARRAY
76385: NOT
76386: IFFALSE 76390
// exit ;
76388: GO 76415
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
76390: LD_ADDR_EXP 44
76394: PUSH
76395: LD_EXP 44
76399: PPUSH
76400: LD_VAR 0 1
76404: PPUSH
76405: LD_VAR 0 2
76409: PPUSH
76410: CALL_OW 1
76414: ST_TO_ADDR
// end ;
76415: LD_VAR 0 3
76419: RET
// export function MC_InsertProduceList ( base , components ) ; begin
76420: LD_INT 0
76422: PPUSH
// if not mc_bases [ base ] then
76423: LD_EXP 23
76427: PUSH
76428: LD_VAR 0 1
76432: ARRAY
76433: NOT
76434: IFFALSE 76438
// exit ;
76436: GO 76475
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
76438: LD_ADDR_EXP 44
76442: PUSH
76443: LD_EXP 44
76447: PPUSH
76448: LD_VAR 0 1
76452: PPUSH
76453: LD_EXP 44
76457: PUSH
76458: LD_VAR 0 1
76462: ARRAY
76463: PUSH
76464: LD_VAR 0 2
76468: ADD
76469: PPUSH
76470: CALL_OW 1
76474: ST_TO_ADDR
// end ;
76475: LD_VAR 0 3
76479: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
76480: LD_INT 0
76482: PPUSH
// if not mc_bases [ base ] then
76483: LD_EXP 23
76487: PUSH
76488: LD_VAR 0 1
76492: ARRAY
76493: NOT
76494: IFFALSE 76498
// exit ;
76496: GO 76552
// mc_defender := Replace ( mc_defender , base , deflist ) ;
76498: LD_ADDR_EXP 45
76502: PUSH
76503: LD_EXP 45
76507: PPUSH
76508: LD_VAR 0 1
76512: PPUSH
76513: LD_VAR 0 2
76517: PPUSH
76518: CALL_OW 1
76522: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
76523: LD_ADDR_EXP 34
76527: PUSH
76528: LD_EXP 34
76532: PPUSH
76533: LD_VAR 0 1
76537: PPUSH
76538: LD_VAR 0 2
76542: PUSH
76543: LD_INT 0
76545: PLUS
76546: PPUSH
76547: CALL_OW 1
76551: ST_TO_ADDR
// end ;
76552: LD_VAR 0 3
76556: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
76557: LD_INT 0
76559: PPUSH
// if not mc_bases [ base ] then
76560: LD_EXP 23
76564: PUSH
76565: LD_VAR 0 1
76569: ARRAY
76570: NOT
76571: IFFALSE 76575
// exit ;
76573: GO 76600
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
76575: LD_ADDR_EXP 34
76579: PUSH
76580: LD_EXP 34
76584: PPUSH
76585: LD_VAR 0 1
76589: PPUSH
76590: LD_VAR 0 2
76594: PPUSH
76595: CALL_OW 1
76599: ST_TO_ADDR
// end ;
76600: LD_VAR 0 3
76604: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
76605: LD_INT 0
76607: PPUSH
76608: PPUSH
76609: PPUSH
76610: PPUSH
// if not mc_bases [ base ] then
76611: LD_EXP 23
76615: PUSH
76616: LD_VAR 0 1
76620: ARRAY
76621: NOT
76622: IFFALSE 76626
// exit ;
76624: GO 76691
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
76626: LD_ADDR_EXP 43
76630: PUSH
76631: LD_EXP 43
76635: PPUSH
76636: LD_VAR 0 1
76640: PUSH
76641: LD_EXP 43
76645: PUSH
76646: LD_VAR 0 1
76650: ARRAY
76651: PUSH
76652: LD_INT 1
76654: PLUS
76655: PUSH
76656: EMPTY
76657: LIST
76658: LIST
76659: PPUSH
76660: LD_VAR 0 1
76664: PUSH
76665: LD_VAR 0 2
76669: PUSH
76670: LD_VAR 0 3
76674: PUSH
76675: LD_VAR 0 4
76679: PUSH
76680: EMPTY
76681: LIST
76682: LIST
76683: LIST
76684: LIST
76685: PPUSH
76686: CALL 16156 0 3
76690: ST_TO_ADDR
// end ;
76691: LD_VAR 0 5
76695: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
76696: LD_INT 0
76698: PPUSH
// if not mc_bases [ base ] then
76699: LD_EXP 23
76703: PUSH
76704: LD_VAR 0 1
76708: ARRAY
76709: NOT
76710: IFFALSE 76714
// exit ;
76712: GO 76739
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
76714: LD_ADDR_EXP 60
76718: PUSH
76719: LD_EXP 60
76723: PPUSH
76724: LD_VAR 0 1
76728: PPUSH
76729: LD_VAR 0 2
76733: PPUSH
76734: CALL_OW 1
76738: ST_TO_ADDR
// end ;
76739: LD_VAR 0 3
76743: RET
// export function MC_GetMinesField ( base ) ; begin
76744: LD_INT 0
76746: PPUSH
// result := mc_mines [ base ] ;
76747: LD_ADDR_VAR 0 2
76751: PUSH
76752: LD_EXP 36
76756: PUSH
76757: LD_VAR 0 1
76761: ARRAY
76762: ST_TO_ADDR
// end ;
76763: LD_VAR 0 2
76767: RET
// export function MC_GetProduceList ( base ) ; begin
76768: LD_INT 0
76770: PPUSH
// result := mc_produce [ base ] ;
76771: LD_ADDR_VAR 0 2
76775: PUSH
76776: LD_EXP 44
76780: PUSH
76781: LD_VAR 0 1
76785: ARRAY
76786: ST_TO_ADDR
// end ;
76787: LD_VAR 0 2
76791: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
76792: LD_INT 0
76794: PPUSH
76795: PPUSH
// if not mc_bases then
76796: LD_EXP 23
76800: NOT
76801: IFFALSE 76805
// exit ;
76803: GO 76870
// if mc_bases [ base ] then
76805: LD_EXP 23
76809: PUSH
76810: LD_VAR 0 1
76814: ARRAY
76815: IFFALSE 76870
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
76817: LD_ADDR_VAR 0 3
76821: PUSH
76822: LD_EXP 23
76826: PUSH
76827: LD_VAR 0 1
76831: ARRAY
76832: PPUSH
76833: LD_INT 30
76835: PUSH
76836: LD_VAR 0 2
76840: PUSH
76841: EMPTY
76842: LIST
76843: LIST
76844: PPUSH
76845: CALL_OW 72
76849: ST_TO_ADDR
// if result then
76850: LD_VAR 0 3
76854: IFFALSE 76870
// result := result [ 1 ] ;
76856: LD_ADDR_VAR 0 3
76860: PUSH
76861: LD_VAR 0 3
76865: PUSH
76866: LD_INT 1
76868: ARRAY
76869: ST_TO_ADDR
// end ; end ;
76870: LD_VAR 0 3
76874: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
76875: LD_INT 0
76877: PPUSH
76878: PPUSH
// if not mc_bases then
76879: LD_EXP 23
76883: NOT
76884: IFFALSE 76888
// exit ;
76886: GO 76933
// if mc_bases [ base ] then
76888: LD_EXP 23
76892: PUSH
76893: LD_VAR 0 1
76897: ARRAY
76898: IFFALSE 76933
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
76900: LD_ADDR_VAR 0 3
76904: PUSH
76905: LD_EXP 23
76909: PUSH
76910: LD_VAR 0 1
76914: ARRAY
76915: PPUSH
76916: LD_INT 30
76918: PUSH
76919: LD_VAR 0 2
76923: PUSH
76924: EMPTY
76925: LIST
76926: LIST
76927: PPUSH
76928: CALL_OW 72
76932: ST_TO_ADDR
// end ;
76933: LD_VAR 0 3
76937: RET
// export function MC_SetTame ( base , area ) ; begin
76938: LD_INT 0
76940: PPUSH
// if not mc_bases or not base then
76941: LD_EXP 23
76945: NOT
76946: PUSH
76947: LD_VAR 0 1
76951: NOT
76952: OR
76953: IFFALSE 76957
// exit ;
76955: GO 76982
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
76957: LD_ADDR_EXP 51
76961: PUSH
76962: LD_EXP 51
76966: PPUSH
76967: LD_VAR 0 1
76971: PPUSH
76972: LD_VAR 0 2
76976: PPUSH
76977: CALL_OW 1
76981: ST_TO_ADDR
// end ;
76982: LD_VAR 0 3
76986: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
76987: LD_INT 0
76989: PPUSH
76990: PPUSH
// if not mc_bases or not base then
76991: LD_EXP 23
76995: NOT
76996: PUSH
76997: LD_VAR 0 1
77001: NOT
77002: OR
77003: IFFALSE 77007
// exit ;
77005: GO 77109
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
77007: LD_ADDR_VAR 0 4
77011: PUSH
77012: LD_EXP 23
77016: PUSH
77017: LD_VAR 0 1
77021: ARRAY
77022: PPUSH
77023: LD_INT 30
77025: PUSH
77026: LD_VAR 0 2
77030: PUSH
77031: EMPTY
77032: LIST
77033: LIST
77034: PPUSH
77035: CALL_OW 72
77039: ST_TO_ADDR
// if not tmp then
77040: LD_VAR 0 4
77044: NOT
77045: IFFALSE 77049
// exit ;
77047: GO 77109
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
77049: LD_ADDR_EXP 55
77053: PUSH
77054: LD_EXP 55
77058: PPUSH
77059: LD_VAR 0 1
77063: PPUSH
77064: LD_EXP 55
77068: PUSH
77069: LD_VAR 0 1
77073: ARRAY
77074: PPUSH
77075: LD_EXP 55
77079: PUSH
77080: LD_VAR 0 1
77084: ARRAY
77085: PUSH
77086: LD_INT 1
77088: PLUS
77089: PPUSH
77090: LD_VAR 0 4
77094: PUSH
77095: LD_INT 1
77097: ARRAY
77098: PPUSH
77099: CALL_OW 2
77103: PPUSH
77104: CALL_OW 1
77108: ST_TO_ADDR
// end ;
77109: LD_VAR 0 3
77113: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
77114: LD_INT 0
77116: PPUSH
77117: PPUSH
// if not mc_bases or not base or not kinds then
77118: LD_EXP 23
77122: NOT
77123: PUSH
77124: LD_VAR 0 1
77128: NOT
77129: OR
77130: PUSH
77131: LD_VAR 0 2
77135: NOT
77136: OR
77137: IFFALSE 77141
// exit ;
77139: GO 77202
// for i in kinds do
77141: LD_ADDR_VAR 0 4
77145: PUSH
77146: LD_VAR 0 2
77150: PUSH
77151: FOR_IN
77152: IFFALSE 77200
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
77154: LD_ADDR_EXP 57
77158: PUSH
77159: LD_EXP 57
77163: PPUSH
77164: LD_VAR 0 1
77168: PUSH
77169: LD_EXP 57
77173: PUSH
77174: LD_VAR 0 1
77178: ARRAY
77179: PUSH
77180: LD_INT 1
77182: PLUS
77183: PUSH
77184: EMPTY
77185: LIST
77186: LIST
77187: PPUSH
77188: LD_VAR 0 4
77192: PPUSH
77193: CALL 16156 0 3
77197: ST_TO_ADDR
77198: GO 77151
77200: POP
77201: POP
// end ;
77202: LD_VAR 0 3
77206: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
77207: LD_INT 0
77209: PPUSH
// if not mc_bases or not base or not areas then
77210: LD_EXP 23
77214: NOT
77215: PUSH
77216: LD_VAR 0 1
77220: NOT
77221: OR
77222: PUSH
77223: LD_VAR 0 2
77227: NOT
77228: OR
77229: IFFALSE 77233
// exit ;
77231: GO 77258
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
77233: LD_ADDR_EXP 41
77237: PUSH
77238: LD_EXP 41
77242: PPUSH
77243: LD_VAR 0 1
77247: PPUSH
77248: LD_VAR 0 2
77252: PPUSH
77253: CALL_OW 1
77257: ST_TO_ADDR
// end ;
77258: LD_VAR 0 3
77262: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
77263: LD_INT 0
77265: PPUSH
// if not mc_bases or not base or not teleports_exit then
77266: LD_EXP 23
77270: NOT
77271: PUSH
77272: LD_VAR 0 1
77276: NOT
77277: OR
77278: PUSH
77279: LD_VAR 0 2
77283: NOT
77284: OR
77285: IFFALSE 77289
// exit ;
77287: GO 77314
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
77289: LD_ADDR_EXP 58
77293: PUSH
77294: LD_EXP 58
77298: PPUSH
77299: LD_VAR 0 1
77303: PPUSH
77304: LD_VAR 0 2
77308: PPUSH
77309: CALL_OW 1
77313: ST_TO_ADDR
// end ;
77314: LD_VAR 0 3
77318: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
77319: LD_INT 0
77321: PPUSH
77322: PPUSH
77323: PPUSH
// if not mc_bases or not base or not ext_list then
77324: LD_EXP 23
77328: NOT
77329: PUSH
77330: LD_VAR 0 1
77334: NOT
77335: OR
77336: PUSH
77337: LD_VAR 0 5
77341: NOT
77342: OR
77343: IFFALSE 77347
// exit ;
77345: GO 77520
// tmp := GetFacExtXYD ( x , y , d ) ;
77347: LD_ADDR_VAR 0 8
77351: PUSH
77352: LD_VAR 0 2
77356: PPUSH
77357: LD_VAR 0 3
77361: PPUSH
77362: LD_VAR 0 4
77366: PPUSH
77367: CALL 46034 0 3
77371: ST_TO_ADDR
// if not tmp then
77372: LD_VAR 0 8
77376: NOT
77377: IFFALSE 77381
// exit ;
77379: GO 77520
// for i in tmp do
77381: LD_ADDR_VAR 0 7
77385: PUSH
77386: LD_VAR 0 8
77390: PUSH
77391: FOR_IN
77392: IFFALSE 77518
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
77394: LD_ADDR_EXP 28
77398: PUSH
77399: LD_EXP 28
77403: PPUSH
77404: LD_VAR 0 1
77408: PPUSH
77409: LD_EXP 28
77413: PUSH
77414: LD_VAR 0 1
77418: ARRAY
77419: PPUSH
77420: LD_EXP 28
77424: PUSH
77425: LD_VAR 0 1
77429: ARRAY
77430: PUSH
77431: LD_INT 1
77433: PLUS
77434: PPUSH
77435: LD_VAR 0 5
77439: PUSH
77440: LD_INT 1
77442: ARRAY
77443: PUSH
77444: LD_VAR 0 7
77448: PUSH
77449: LD_INT 1
77451: ARRAY
77452: PUSH
77453: LD_VAR 0 7
77457: PUSH
77458: LD_INT 2
77460: ARRAY
77461: PUSH
77462: LD_VAR 0 7
77466: PUSH
77467: LD_INT 3
77469: ARRAY
77470: PUSH
77471: EMPTY
77472: LIST
77473: LIST
77474: LIST
77475: LIST
77476: PPUSH
77477: CALL_OW 2
77481: PPUSH
77482: CALL_OW 1
77486: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
77487: LD_ADDR_VAR 0 5
77491: PUSH
77492: LD_VAR 0 5
77496: PPUSH
77497: LD_INT 1
77499: PPUSH
77500: CALL_OW 3
77504: ST_TO_ADDR
// if not ext_list then
77505: LD_VAR 0 5
77509: NOT
77510: IFFALSE 77516
// exit ;
77512: POP
77513: POP
77514: GO 77520
// end ;
77516: GO 77391
77518: POP
77519: POP
// end ;
77520: LD_VAR 0 6
77524: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
77525: LD_INT 0
77527: PPUSH
// if not mc_bases or not base or not weapon_list then
77528: LD_EXP 23
77532: NOT
77533: PUSH
77534: LD_VAR 0 1
77538: NOT
77539: OR
77540: PUSH
77541: LD_VAR 0 2
77545: NOT
77546: OR
77547: IFFALSE 77551
// exit ;
77549: GO 77576
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
77551: LD_ADDR_EXP 62
77555: PUSH
77556: LD_EXP 62
77560: PPUSH
77561: LD_VAR 0 1
77565: PPUSH
77566: LD_VAR 0 2
77570: PPUSH
77571: CALL_OW 1
77575: ST_TO_ADDR
// end ;
77576: LD_VAR 0 3
77580: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
77581: LD_INT 0
77583: PPUSH
// if not mc_bases or not base or not tech_list then
77584: LD_EXP 23
77588: NOT
77589: PUSH
77590: LD_VAR 0 1
77594: NOT
77595: OR
77596: PUSH
77597: LD_VAR 0 2
77601: NOT
77602: OR
77603: IFFALSE 77607
// exit ;
77605: GO 77632
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
77607: LD_ADDR_EXP 50
77611: PUSH
77612: LD_EXP 50
77616: PPUSH
77617: LD_VAR 0 1
77621: PPUSH
77622: LD_VAR 0 2
77626: PPUSH
77627: CALL_OW 1
77631: ST_TO_ADDR
// end ;
77632: LD_VAR 0 3
77636: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
77637: LD_INT 0
77639: PPUSH
// if not mc_bases or not parking_area or not base then
77640: LD_EXP 23
77644: NOT
77645: PUSH
77646: LD_VAR 0 2
77650: NOT
77651: OR
77652: PUSH
77653: LD_VAR 0 1
77657: NOT
77658: OR
77659: IFFALSE 77663
// exit ;
77661: GO 77688
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
77663: LD_ADDR_EXP 47
77667: PUSH
77668: LD_EXP 47
77672: PPUSH
77673: LD_VAR 0 1
77677: PPUSH
77678: LD_VAR 0 2
77682: PPUSH
77683: CALL_OW 1
77687: ST_TO_ADDR
// end ;
77688: LD_VAR 0 3
77692: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
77693: LD_INT 0
77695: PPUSH
// if not mc_bases or not base or not scan_area then
77696: LD_EXP 23
77700: NOT
77701: PUSH
77702: LD_VAR 0 1
77706: NOT
77707: OR
77708: PUSH
77709: LD_VAR 0 2
77713: NOT
77714: OR
77715: IFFALSE 77719
// exit ;
77717: GO 77744
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
77719: LD_ADDR_EXP 48
77723: PUSH
77724: LD_EXP 48
77728: PPUSH
77729: LD_VAR 0 1
77733: PPUSH
77734: LD_VAR 0 2
77738: PPUSH
77739: CALL_OW 1
77743: ST_TO_ADDR
// end ;
77744: LD_VAR 0 3
77748: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
77749: LD_INT 0
77751: PPUSH
77752: PPUSH
// if not mc_bases or not base then
77753: LD_EXP 23
77757: NOT
77758: PUSH
77759: LD_VAR 0 1
77763: NOT
77764: OR
77765: IFFALSE 77769
// exit ;
77767: GO 77833
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
77769: LD_ADDR_VAR 0 3
77773: PUSH
77774: LD_INT 1
77776: PUSH
77777: LD_INT 2
77779: PUSH
77780: LD_INT 3
77782: PUSH
77783: LD_INT 4
77785: PUSH
77786: LD_INT 11
77788: PUSH
77789: EMPTY
77790: LIST
77791: LIST
77792: LIST
77793: LIST
77794: LIST
77795: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
77796: LD_ADDR_EXP 50
77800: PUSH
77801: LD_EXP 50
77805: PPUSH
77806: LD_VAR 0 1
77810: PPUSH
77811: LD_EXP 50
77815: PUSH
77816: LD_VAR 0 1
77820: ARRAY
77821: PUSH
77822: LD_VAR 0 3
77826: DIFF
77827: PPUSH
77828: CALL_OW 1
77832: ST_TO_ADDR
// end ;
77833: LD_VAR 0 2
77837: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
77838: LD_INT 0
77840: PPUSH
// result := mc_vehicles [ base ] ;
77841: LD_ADDR_VAR 0 3
77845: PUSH
77846: LD_EXP 42
77850: PUSH
77851: LD_VAR 0 1
77855: ARRAY
77856: ST_TO_ADDR
// if onlyCombat then
77857: LD_VAR 0 2
77861: IFFALSE 78033
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
77863: LD_ADDR_VAR 0 3
77867: PUSH
77868: LD_VAR 0 3
77872: PUSH
77873: LD_VAR 0 3
77877: PPUSH
77878: LD_INT 2
77880: PUSH
77881: LD_INT 34
77883: PUSH
77884: LD_INT 12
77886: PUSH
77887: EMPTY
77888: LIST
77889: LIST
77890: PUSH
77891: LD_INT 34
77893: PUSH
77894: LD_INT 51
77896: PUSH
77897: EMPTY
77898: LIST
77899: LIST
77900: PUSH
77901: LD_INT 34
77903: PUSH
77904: LD_INT 89
77906: PUSH
77907: EMPTY
77908: LIST
77909: LIST
77910: PUSH
77911: LD_INT 34
77913: PUSH
77914: LD_INT 32
77916: PUSH
77917: EMPTY
77918: LIST
77919: LIST
77920: PUSH
77921: LD_INT 34
77923: PUSH
77924: LD_INT 13
77926: PUSH
77927: EMPTY
77928: LIST
77929: LIST
77930: PUSH
77931: LD_INT 34
77933: PUSH
77934: LD_INT 52
77936: PUSH
77937: EMPTY
77938: LIST
77939: LIST
77940: PUSH
77941: LD_INT 34
77943: PUSH
77944: LD_INT 88
77946: PUSH
77947: EMPTY
77948: LIST
77949: LIST
77950: PUSH
77951: LD_INT 34
77953: PUSH
77954: LD_INT 14
77956: PUSH
77957: EMPTY
77958: LIST
77959: LIST
77960: PUSH
77961: LD_INT 34
77963: PUSH
77964: LD_INT 53
77966: PUSH
77967: EMPTY
77968: LIST
77969: LIST
77970: PUSH
77971: LD_INT 34
77973: PUSH
77974: LD_INT 98
77976: PUSH
77977: EMPTY
77978: LIST
77979: LIST
77980: PUSH
77981: LD_INT 34
77983: PUSH
77984: LD_INT 31
77986: PUSH
77987: EMPTY
77988: LIST
77989: LIST
77990: PUSH
77991: LD_INT 34
77993: PUSH
77994: LD_INT 48
77996: PUSH
77997: EMPTY
77998: LIST
77999: LIST
78000: PUSH
78001: LD_INT 34
78003: PUSH
78004: LD_INT 8
78006: PUSH
78007: EMPTY
78008: LIST
78009: LIST
78010: PUSH
78011: EMPTY
78012: LIST
78013: LIST
78014: LIST
78015: LIST
78016: LIST
78017: LIST
78018: LIST
78019: LIST
78020: LIST
78021: LIST
78022: LIST
78023: LIST
78024: LIST
78025: LIST
78026: PPUSH
78027: CALL_OW 72
78031: DIFF
78032: ST_TO_ADDR
// end ; end_of_file
78033: LD_VAR 0 3
78037: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
78038: LD_INT 0
78040: PPUSH
78041: PPUSH
78042: PPUSH
// if not mc_bases or not skirmish then
78043: LD_EXP 23
78047: NOT
78048: PUSH
78049: LD_EXP 21
78053: NOT
78054: OR
78055: IFFALSE 78059
// exit ;
78057: GO 78224
// for i = 1 to mc_bases do
78059: LD_ADDR_VAR 0 4
78063: PUSH
78064: DOUBLE
78065: LD_INT 1
78067: DEC
78068: ST_TO_ADDR
78069: LD_EXP 23
78073: PUSH
78074: FOR_TO
78075: IFFALSE 78222
// begin if sci in mc_bases [ i ] then
78077: LD_VAR 0 2
78081: PUSH
78082: LD_EXP 23
78086: PUSH
78087: LD_VAR 0 4
78091: ARRAY
78092: IN
78093: IFFALSE 78220
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
78095: LD_ADDR_EXP 52
78099: PUSH
78100: LD_EXP 52
78104: PPUSH
78105: LD_VAR 0 4
78109: PUSH
78110: LD_EXP 52
78114: PUSH
78115: LD_VAR 0 4
78119: ARRAY
78120: PUSH
78121: LD_INT 1
78123: PLUS
78124: PUSH
78125: EMPTY
78126: LIST
78127: LIST
78128: PPUSH
78129: LD_VAR 0 1
78133: PPUSH
78134: CALL 16156 0 3
78138: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
78139: LD_ADDR_VAR 0 5
78143: PUSH
78144: LD_EXP 23
78148: PUSH
78149: LD_VAR 0 4
78153: ARRAY
78154: PPUSH
78155: LD_INT 2
78157: PUSH
78158: LD_INT 30
78160: PUSH
78161: LD_INT 0
78163: PUSH
78164: EMPTY
78165: LIST
78166: LIST
78167: PUSH
78168: LD_INT 30
78170: PUSH
78171: LD_INT 1
78173: PUSH
78174: EMPTY
78175: LIST
78176: LIST
78177: PUSH
78178: EMPTY
78179: LIST
78180: LIST
78181: LIST
78182: PPUSH
78183: CALL_OW 72
78187: PPUSH
78188: LD_VAR 0 1
78192: PPUSH
78193: CALL_OW 74
78197: ST_TO_ADDR
// if tmp then
78198: LD_VAR 0 5
78202: IFFALSE 78218
// ComStandNearbyBuilding ( ape , tmp ) ;
78204: LD_VAR 0 1
78208: PPUSH
78209: LD_VAR 0 5
78213: PPUSH
78214: CALL 12583 0 2
// break ;
78218: GO 78222
// end ; end ;
78220: GO 78074
78222: POP
78223: POP
// end ;
78224: LD_VAR 0 3
78228: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
78229: LD_INT 0
78231: PPUSH
78232: PPUSH
78233: PPUSH
// if not mc_bases or not skirmish then
78234: LD_EXP 23
78238: NOT
78239: PUSH
78240: LD_EXP 21
78244: NOT
78245: OR
78246: IFFALSE 78250
// exit ;
78248: GO 78339
// for i = 1 to mc_bases do
78250: LD_ADDR_VAR 0 4
78254: PUSH
78255: DOUBLE
78256: LD_INT 1
78258: DEC
78259: ST_TO_ADDR
78260: LD_EXP 23
78264: PUSH
78265: FOR_TO
78266: IFFALSE 78337
// begin if building in mc_busy_turret_list [ i ] then
78268: LD_VAR 0 1
78272: PUSH
78273: LD_EXP 33
78277: PUSH
78278: LD_VAR 0 4
78282: ARRAY
78283: IN
78284: IFFALSE 78335
// begin tmp := mc_busy_turret_list [ i ] diff building ;
78286: LD_ADDR_VAR 0 5
78290: PUSH
78291: LD_EXP 33
78295: PUSH
78296: LD_VAR 0 4
78300: ARRAY
78301: PUSH
78302: LD_VAR 0 1
78306: DIFF
78307: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
78308: LD_ADDR_EXP 33
78312: PUSH
78313: LD_EXP 33
78317: PPUSH
78318: LD_VAR 0 4
78322: PPUSH
78323: LD_VAR 0 5
78327: PPUSH
78328: CALL_OW 1
78332: ST_TO_ADDR
// break ;
78333: GO 78337
// end ; end ;
78335: GO 78265
78337: POP
78338: POP
// end ;
78339: LD_VAR 0 3
78343: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
78344: LD_INT 0
78346: PPUSH
78347: PPUSH
78348: PPUSH
// if not mc_bases or not skirmish then
78349: LD_EXP 23
78353: NOT
78354: PUSH
78355: LD_EXP 21
78359: NOT
78360: OR
78361: IFFALSE 78365
// exit ;
78363: GO 78564
// for i = 1 to mc_bases do
78365: LD_ADDR_VAR 0 5
78369: PUSH
78370: DOUBLE
78371: LD_INT 1
78373: DEC
78374: ST_TO_ADDR
78375: LD_EXP 23
78379: PUSH
78380: FOR_TO
78381: IFFALSE 78562
// if building in mc_bases [ i ] then
78383: LD_VAR 0 1
78387: PUSH
78388: LD_EXP 23
78392: PUSH
78393: LD_VAR 0 5
78397: ARRAY
78398: IN
78399: IFFALSE 78560
// begin tmp := mc_bases [ i ] diff building ;
78401: LD_ADDR_VAR 0 6
78405: PUSH
78406: LD_EXP 23
78410: PUSH
78411: LD_VAR 0 5
78415: ARRAY
78416: PUSH
78417: LD_VAR 0 1
78421: DIFF
78422: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
78423: LD_ADDR_EXP 23
78427: PUSH
78428: LD_EXP 23
78432: PPUSH
78433: LD_VAR 0 5
78437: PPUSH
78438: LD_VAR 0 6
78442: PPUSH
78443: CALL_OW 1
78447: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
78448: LD_VAR 0 1
78452: PUSH
78453: LD_EXP 31
78457: PUSH
78458: LD_VAR 0 5
78462: ARRAY
78463: IN
78464: IFFALSE 78503
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
78466: LD_ADDR_EXP 31
78470: PUSH
78471: LD_EXP 31
78475: PPUSH
78476: LD_VAR 0 5
78480: PPUSH
78481: LD_EXP 31
78485: PUSH
78486: LD_VAR 0 5
78490: ARRAY
78491: PUSH
78492: LD_VAR 0 1
78496: DIFF
78497: PPUSH
78498: CALL_OW 1
78502: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
78503: LD_VAR 0 1
78507: PUSH
78508: LD_EXP 32
78512: PUSH
78513: LD_VAR 0 5
78517: ARRAY
78518: IN
78519: IFFALSE 78558
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
78521: LD_ADDR_EXP 32
78525: PUSH
78526: LD_EXP 32
78530: PPUSH
78531: LD_VAR 0 5
78535: PPUSH
78536: LD_EXP 32
78540: PUSH
78541: LD_VAR 0 5
78545: ARRAY
78546: PUSH
78547: LD_VAR 0 1
78551: DIFF
78552: PPUSH
78553: CALL_OW 1
78557: ST_TO_ADDR
// break ;
78558: GO 78562
// end ;
78560: GO 78380
78562: POP
78563: POP
// end ;
78564: LD_VAR 0 4
78568: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
78569: LD_INT 0
78571: PPUSH
78572: PPUSH
78573: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
78574: LD_EXP 23
78578: NOT
78579: PUSH
78580: LD_EXP 21
78584: NOT
78585: OR
78586: PUSH
78587: LD_VAR 0 3
78591: PUSH
78592: LD_EXP 49
78596: IN
78597: NOT
78598: OR
78599: IFFALSE 78603
// exit ;
78601: GO 78726
// for i = 1 to mc_vehicles do
78603: LD_ADDR_VAR 0 6
78607: PUSH
78608: DOUBLE
78609: LD_INT 1
78611: DEC
78612: ST_TO_ADDR
78613: LD_EXP 42
78617: PUSH
78618: FOR_TO
78619: IFFALSE 78724
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
78621: LD_VAR 0 2
78625: PUSH
78626: LD_EXP 42
78630: PUSH
78631: LD_VAR 0 6
78635: ARRAY
78636: IN
78637: PUSH
78638: LD_VAR 0 1
78642: PUSH
78643: LD_EXP 42
78647: PUSH
78648: LD_VAR 0 6
78652: ARRAY
78653: IN
78654: OR
78655: IFFALSE 78722
// begin tmp := mc_vehicles [ i ] diff old ;
78657: LD_ADDR_VAR 0 7
78661: PUSH
78662: LD_EXP 42
78666: PUSH
78667: LD_VAR 0 6
78671: ARRAY
78672: PUSH
78673: LD_VAR 0 2
78677: DIFF
78678: ST_TO_ADDR
// tmp := tmp diff new ;
78679: LD_ADDR_VAR 0 7
78683: PUSH
78684: LD_VAR 0 7
78688: PUSH
78689: LD_VAR 0 1
78693: DIFF
78694: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
78695: LD_ADDR_EXP 42
78699: PUSH
78700: LD_EXP 42
78704: PPUSH
78705: LD_VAR 0 6
78709: PPUSH
78710: LD_VAR 0 7
78714: PPUSH
78715: CALL_OW 1
78719: ST_TO_ADDR
// break ;
78720: GO 78724
// end ;
78722: GO 78618
78724: POP
78725: POP
// end ;
78726: LD_VAR 0 5
78730: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
78731: LD_INT 0
78733: PPUSH
78734: PPUSH
78735: PPUSH
78736: PPUSH
// if not mc_bases or not skirmish then
78737: LD_EXP 23
78741: NOT
78742: PUSH
78743: LD_EXP 21
78747: NOT
78748: OR
78749: IFFALSE 78753
// exit ;
78751: GO 79135
// side := GetSide ( vehicle ) ;
78753: LD_ADDR_VAR 0 5
78757: PUSH
78758: LD_VAR 0 1
78762: PPUSH
78763: CALL_OW 255
78767: ST_TO_ADDR
// for i = 1 to mc_bases do
78768: LD_ADDR_VAR 0 4
78772: PUSH
78773: DOUBLE
78774: LD_INT 1
78776: DEC
78777: ST_TO_ADDR
78778: LD_EXP 23
78782: PUSH
78783: FOR_TO
78784: IFFALSE 79133
// begin if factory in mc_bases [ i ] then
78786: LD_VAR 0 2
78790: PUSH
78791: LD_EXP 23
78795: PUSH
78796: LD_VAR 0 4
78800: ARRAY
78801: IN
78802: IFFALSE 79131
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
78804: LD_EXP 45
78808: PUSH
78809: LD_VAR 0 4
78813: ARRAY
78814: PUSH
78815: LD_EXP 34
78819: PUSH
78820: LD_VAR 0 4
78824: ARRAY
78825: LESS
78826: PUSH
78827: LD_VAR 0 1
78831: PPUSH
78832: CALL_OW 264
78836: PUSH
78837: LD_INT 31
78839: PUSH
78840: LD_INT 32
78842: PUSH
78843: LD_INT 51
78845: PUSH
78846: LD_INT 89
78848: PUSH
78849: LD_INT 12
78851: PUSH
78852: LD_INT 30
78854: PUSH
78855: LD_INT 98
78857: PUSH
78858: LD_INT 11
78860: PUSH
78861: LD_INT 53
78863: PUSH
78864: LD_INT 14
78866: PUSH
78867: LD_INT 91
78869: PUSH
78870: LD_INT 29
78872: PUSH
78873: LD_INT 99
78875: PUSH
78876: LD_INT 13
78878: PUSH
78879: LD_INT 52
78881: PUSH
78882: LD_INT 88
78884: PUSH
78885: LD_INT 48
78887: PUSH
78888: LD_INT 8
78890: PUSH
78891: EMPTY
78892: LIST
78893: LIST
78894: LIST
78895: LIST
78896: LIST
78897: LIST
78898: LIST
78899: LIST
78900: LIST
78901: LIST
78902: LIST
78903: LIST
78904: LIST
78905: LIST
78906: LIST
78907: LIST
78908: LIST
78909: LIST
78910: IN
78911: NOT
78912: AND
78913: IFFALSE 78961
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
78915: LD_ADDR_EXP 45
78919: PUSH
78920: LD_EXP 45
78924: PPUSH
78925: LD_VAR 0 4
78929: PUSH
78930: LD_EXP 45
78934: PUSH
78935: LD_VAR 0 4
78939: ARRAY
78940: PUSH
78941: LD_INT 1
78943: PLUS
78944: PUSH
78945: EMPTY
78946: LIST
78947: LIST
78948: PPUSH
78949: LD_VAR 0 1
78953: PPUSH
78954: CALL 16156 0 3
78958: ST_TO_ADDR
78959: GO 79005
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
78961: LD_ADDR_EXP 42
78965: PUSH
78966: LD_EXP 42
78970: PPUSH
78971: LD_VAR 0 4
78975: PUSH
78976: LD_EXP 42
78980: PUSH
78981: LD_VAR 0 4
78985: ARRAY
78986: PUSH
78987: LD_INT 1
78989: PLUS
78990: PUSH
78991: EMPTY
78992: LIST
78993: LIST
78994: PPUSH
78995: LD_VAR 0 1
78999: PPUSH
79000: CALL 16156 0 3
79004: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
79005: LD_VAR 0 1
79009: PPUSH
79010: CALL_OW 263
79014: PUSH
79015: LD_INT 2
79017: EQUAL
79018: IFFALSE 79047
// begin repeat wait ( 0 0$3 ) ;
79020: LD_INT 105
79022: PPUSH
79023: CALL_OW 67
// Connect ( vehicle ) ;
79027: LD_VAR 0 1
79031: PPUSH
79032: CALL 19125 0 1
// until IsControledBy ( vehicle ) ;
79036: LD_VAR 0 1
79040: PPUSH
79041: CALL_OW 312
79045: IFFALSE 79020
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
79047: LD_VAR 0 1
79051: PPUSH
79052: LD_EXP 47
79056: PUSH
79057: LD_VAR 0 4
79061: ARRAY
79062: PPUSH
79063: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
79067: LD_VAR 0 1
79071: PPUSH
79072: CALL_OW 263
79076: PUSH
79077: LD_INT 1
79079: NONEQUAL
79080: IFFALSE 79084
// break ;
79082: GO 79133
// repeat wait ( 0 0$1 ) ;
79084: LD_INT 35
79086: PPUSH
79087: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
79091: LD_VAR 0 1
79095: PPUSH
79096: LD_EXP 47
79100: PUSH
79101: LD_VAR 0 4
79105: ARRAY
79106: PPUSH
79107: CALL_OW 308
79111: IFFALSE 79084
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
79113: LD_VAR 0 1
79117: PPUSH
79118: CALL_OW 311
79122: PPUSH
79123: CALL_OW 121
// exit ;
79127: POP
79128: POP
79129: GO 79135
// end ; end ;
79131: GO 78783
79133: POP
79134: POP
// end ;
79135: LD_VAR 0 3
79139: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
79140: LD_INT 0
79142: PPUSH
79143: PPUSH
79144: PPUSH
79145: PPUSH
// if not mc_bases or not skirmish then
79146: LD_EXP 23
79150: NOT
79151: PUSH
79152: LD_EXP 21
79156: NOT
79157: OR
79158: IFFALSE 79162
// exit ;
79160: GO 79515
// repeat wait ( 0 0$1 ) ;
79162: LD_INT 35
79164: PPUSH
79165: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
79169: LD_VAR 0 2
79173: PPUSH
79174: LD_VAR 0 3
79178: PPUSH
79179: CALL_OW 284
79183: IFFALSE 79162
// if GetResourceTypeXY ( x , y ) = mat_artefact then
79185: LD_VAR 0 2
79189: PPUSH
79190: LD_VAR 0 3
79194: PPUSH
79195: CALL_OW 283
79199: PUSH
79200: LD_INT 4
79202: EQUAL
79203: IFFALSE 79207
// exit ;
79205: GO 79515
// for i = 1 to mc_bases do
79207: LD_ADDR_VAR 0 7
79211: PUSH
79212: DOUBLE
79213: LD_INT 1
79215: DEC
79216: ST_TO_ADDR
79217: LD_EXP 23
79221: PUSH
79222: FOR_TO
79223: IFFALSE 79513
// begin if mc_crates_area [ i ] then
79225: LD_EXP 41
79229: PUSH
79230: LD_VAR 0 7
79234: ARRAY
79235: IFFALSE 79346
// for j in mc_crates_area [ i ] do
79237: LD_ADDR_VAR 0 8
79241: PUSH
79242: LD_EXP 41
79246: PUSH
79247: LD_VAR 0 7
79251: ARRAY
79252: PUSH
79253: FOR_IN
79254: IFFALSE 79344
// if InArea ( x , y , j ) then
79256: LD_VAR 0 2
79260: PPUSH
79261: LD_VAR 0 3
79265: PPUSH
79266: LD_VAR 0 8
79270: PPUSH
79271: CALL_OW 309
79275: IFFALSE 79342
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
79277: LD_ADDR_EXP 39
79281: PUSH
79282: LD_EXP 39
79286: PPUSH
79287: LD_VAR 0 7
79291: PUSH
79292: LD_EXP 39
79296: PUSH
79297: LD_VAR 0 7
79301: ARRAY
79302: PUSH
79303: LD_INT 1
79305: PLUS
79306: PUSH
79307: EMPTY
79308: LIST
79309: LIST
79310: PPUSH
79311: LD_VAR 0 4
79315: PUSH
79316: LD_VAR 0 2
79320: PUSH
79321: LD_VAR 0 3
79325: PUSH
79326: EMPTY
79327: LIST
79328: LIST
79329: LIST
79330: PPUSH
79331: CALL 16156 0 3
79335: ST_TO_ADDR
// exit ;
79336: POP
79337: POP
79338: POP
79339: POP
79340: GO 79515
// end ;
79342: GO 79253
79344: POP
79345: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79346: LD_ADDR_VAR 0 9
79350: PUSH
79351: LD_EXP 23
79355: PUSH
79356: LD_VAR 0 7
79360: ARRAY
79361: PPUSH
79362: LD_INT 2
79364: PUSH
79365: LD_INT 30
79367: PUSH
79368: LD_INT 0
79370: PUSH
79371: EMPTY
79372: LIST
79373: LIST
79374: PUSH
79375: LD_INT 30
79377: PUSH
79378: LD_INT 1
79380: PUSH
79381: EMPTY
79382: LIST
79383: LIST
79384: PUSH
79385: EMPTY
79386: LIST
79387: LIST
79388: LIST
79389: PPUSH
79390: CALL_OW 72
79394: ST_TO_ADDR
// if not depot then
79395: LD_VAR 0 9
79399: NOT
79400: IFFALSE 79404
// continue ;
79402: GO 79222
// for j in depot do
79404: LD_ADDR_VAR 0 8
79408: PUSH
79409: LD_VAR 0 9
79413: PUSH
79414: FOR_IN
79415: IFFALSE 79509
// if GetDistUnitXY ( j , x , y ) < 30 then
79417: LD_VAR 0 8
79421: PPUSH
79422: LD_VAR 0 2
79426: PPUSH
79427: LD_VAR 0 3
79431: PPUSH
79432: CALL_OW 297
79436: PUSH
79437: LD_INT 30
79439: LESS
79440: IFFALSE 79507
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
79442: LD_ADDR_EXP 39
79446: PUSH
79447: LD_EXP 39
79451: PPUSH
79452: LD_VAR 0 7
79456: PUSH
79457: LD_EXP 39
79461: PUSH
79462: LD_VAR 0 7
79466: ARRAY
79467: PUSH
79468: LD_INT 1
79470: PLUS
79471: PUSH
79472: EMPTY
79473: LIST
79474: LIST
79475: PPUSH
79476: LD_VAR 0 4
79480: PUSH
79481: LD_VAR 0 2
79485: PUSH
79486: LD_VAR 0 3
79490: PUSH
79491: EMPTY
79492: LIST
79493: LIST
79494: LIST
79495: PPUSH
79496: CALL 16156 0 3
79500: ST_TO_ADDR
// exit ;
79501: POP
79502: POP
79503: POP
79504: POP
79505: GO 79515
// end ;
79507: GO 79414
79509: POP
79510: POP
// end ;
79511: GO 79222
79513: POP
79514: POP
// end ;
79515: LD_VAR 0 6
79519: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
79520: LD_INT 0
79522: PPUSH
79523: PPUSH
79524: PPUSH
79525: PPUSH
// if not mc_bases or not skirmish then
79526: LD_EXP 23
79530: NOT
79531: PUSH
79532: LD_EXP 21
79536: NOT
79537: OR
79538: IFFALSE 79542
// exit ;
79540: GO 79819
// side := GetSide ( lab ) ;
79542: LD_ADDR_VAR 0 4
79546: PUSH
79547: LD_VAR 0 2
79551: PPUSH
79552: CALL_OW 255
79556: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
79557: LD_VAR 0 4
79561: PUSH
79562: LD_EXP 49
79566: IN
79567: NOT
79568: PUSH
79569: LD_EXP 50
79573: NOT
79574: OR
79575: PUSH
79576: LD_EXP 23
79580: NOT
79581: OR
79582: IFFALSE 79586
// exit ;
79584: GO 79819
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
79586: LD_ADDR_EXP 50
79590: PUSH
79591: LD_EXP 50
79595: PPUSH
79596: LD_VAR 0 4
79600: PPUSH
79601: LD_EXP 50
79605: PUSH
79606: LD_VAR 0 4
79610: ARRAY
79611: PUSH
79612: LD_VAR 0 1
79616: DIFF
79617: PPUSH
79618: CALL_OW 1
79622: ST_TO_ADDR
// for i = 1 to mc_bases do
79623: LD_ADDR_VAR 0 5
79627: PUSH
79628: DOUBLE
79629: LD_INT 1
79631: DEC
79632: ST_TO_ADDR
79633: LD_EXP 23
79637: PUSH
79638: FOR_TO
79639: IFFALSE 79817
// begin if lab in mc_bases [ i ] then
79641: LD_VAR 0 2
79645: PUSH
79646: LD_EXP 23
79650: PUSH
79651: LD_VAR 0 5
79655: ARRAY
79656: IN
79657: IFFALSE 79815
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
79659: LD_VAR 0 1
79663: PUSH
79664: LD_INT 11
79666: PUSH
79667: LD_INT 4
79669: PUSH
79670: LD_INT 3
79672: PUSH
79673: LD_INT 2
79675: PUSH
79676: EMPTY
79677: LIST
79678: LIST
79679: LIST
79680: LIST
79681: IN
79682: PUSH
79683: LD_EXP 53
79687: PUSH
79688: LD_VAR 0 5
79692: ARRAY
79693: AND
79694: IFFALSE 79815
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
79696: LD_ADDR_VAR 0 6
79700: PUSH
79701: LD_EXP 53
79705: PUSH
79706: LD_VAR 0 5
79710: ARRAY
79711: PUSH
79712: LD_INT 1
79714: ARRAY
79715: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
79716: LD_ADDR_EXP 53
79720: PUSH
79721: LD_EXP 53
79725: PPUSH
79726: LD_VAR 0 5
79730: PPUSH
79731: EMPTY
79732: PPUSH
79733: CALL_OW 1
79737: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
79738: LD_VAR 0 6
79742: PPUSH
79743: LD_INT 0
79745: PPUSH
79746: CALL_OW 109
// ComExitBuilding ( tmp ) ;
79750: LD_VAR 0 6
79754: PPUSH
79755: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
79759: LD_ADDR_EXP 52
79763: PUSH
79764: LD_EXP 52
79768: PPUSH
79769: LD_VAR 0 5
79773: PPUSH
79774: LD_EXP 52
79778: PUSH
79779: LD_VAR 0 5
79783: ARRAY
79784: PPUSH
79785: LD_INT 1
79787: PPUSH
79788: LD_VAR 0 6
79792: PPUSH
79793: CALL_OW 2
79797: PPUSH
79798: CALL_OW 1
79802: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
79803: LD_VAR 0 5
79807: PPUSH
79808: LD_INT 112
79810: PPUSH
79811: CALL 56358 0 2
// end ; end ; end ;
79815: GO 79638
79817: POP
79818: POP
// end ;
79819: LD_VAR 0 3
79823: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
79824: LD_INT 0
79826: PPUSH
79827: PPUSH
79828: PPUSH
79829: PPUSH
79830: PPUSH
79831: PPUSH
79832: PPUSH
79833: PPUSH
// if not mc_bases or not skirmish then
79834: LD_EXP 23
79838: NOT
79839: PUSH
79840: LD_EXP 21
79844: NOT
79845: OR
79846: IFFALSE 79850
// exit ;
79848: GO 81219
// for i = 1 to mc_bases do
79850: LD_ADDR_VAR 0 3
79854: PUSH
79855: DOUBLE
79856: LD_INT 1
79858: DEC
79859: ST_TO_ADDR
79860: LD_EXP 23
79864: PUSH
79865: FOR_TO
79866: IFFALSE 81217
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
79868: LD_VAR 0 1
79872: PUSH
79873: LD_EXP 23
79877: PUSH
79878: LD_VAR 0 3
79882: ARRAY
79883: IN
79884: PUSH
79885: LD_VAR 0 1
79889: PUSH
79890: LD_EXP 30
79894: PUSH
79895: LD_VAR 0 3
79899: ARRAY
79900: IN
79901: OR
79902: PUSH
79903: LD_VAR 0 1
79907: PUSH
79908: LD_EXP 45
79912: PUSH
79913: LD_VAR 0 3
79917: ARRAY
79918: IN
79919: OR
79920: PUSH
79921: LD_VAR 0 1
79925: PUSH
79926: LD_EXP 42
79930: PUSH
79931: LD_VAR 0 3
79935: ARRAY
79936: IN
79937: OR
79938: PUSH
79939: LD_VAR 0 1
79943: PUSH
79944: LD_EXP 52
79948: PUSH
79949: LD_VAR 0 3
79953: ARRAY
79954: IN
79955: OR
79956: PUSH
79957: LD_VAR 0 1
79961: PUSH
79962: LD_EXP 53
79966: PUSH
79967: LD_VAR 0 3
79971: ARRAY
79972: IN
79973: OR
79974: IFFALSE 81215
// begin if un in mc_ape [ i ] then
79976: LD_VAR 0 1
79980: PUSH
79981: LD_EXP 52
79985: PUSH
79986: LD_VAR 0 3
79990: ARRAY
79991: IN
79992: IFFALSE 80031
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
79994: LD_ADDR_EXP 52
79998: PUSH
79999: LD_EXP 52
80003: PPUSH
80004: LD_VAR 0 3
80008: PPUSH
80009: LD_EXP 52
80013: PUSH
80014: LD_VAR 0 3
80018: ARRAY
80019: PUSH
80020: LD_VAR 0 1
80024: DIFF
80025: PPUSH
80026: CALL_OW 1
80030: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
80031: LD_VAR 0 1
80035: PUSH
80036: LD_EXP 53
80040: PUSH
80041: LD_VAR 0 3
80045: ARRAY
80046: IN
80047: IFFALSE 80071
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
80049: LD_ADDR_EXP 53
80053: PUSH
80054: LD_EXP 53
80058: PPUSH
80059: LD_VAR 0 3
80063: PPUSH
80064: EMPTY
80065: PPUSH
80066: CALL_OW 1
80070: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
80071: LD_VAR 0 1
80075: PPUSH
80076: CALL_OW 247
80080: PUSH
80081: LD_INT 2
80083: EQUAL
80084: PUSH
80085: LD_VAR 0 1
80089: PPUSH
80090: CALL_OW 110
80094: PUSH
80095: LD_INT 20
80097: EQUAL
80098: PUSH
80099: LD_VAR 0 1
80103: PUSH
80104: LD_EXP 45
80108: PUSH
80109: LD_VAR 0 3
80113: ARRAY
80114: IN
80115: OR
80116: PUSH
80117: LD_VAR 0 1
80121: PPUSH
80122: CALL_OW 264
80126: PUSH
80127: LD_INT 12
80129: PUSH
80130: LD_INT 51
80132: PUSH
80133: LD_INT 89
80135: PUSH
80136: LD_INT 32
80138: PUSH
80139: LD_INT 13
80141: PUSH
80142: LD_INT 52
80144: PUSH
80145: LD_INT 31
80147: PUSH
80148: EMPTY
80149: LIST
80150: LIST
80151: LIST
80152: LIST
80153: LIST
80154: LIST
80155: LIST
80156: IN
80157: OR
80158: AND
80159: IFFALSE 80467
// begin if un in mc_defender [ i ] then
80161: LD_VAR 0 1
80165: PUSH
80166: LD_EXP 45
80170: PUSH
80171: LD_VAR 0 3
80175: ARRAY
80176: IN
80177: IFFALSE 80216
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
80179: LD_ADDR_EXP 45
80183: PUSH
80184: LD_EXP 45
80188: PPUSH
80189: LD_VAR 0 3
80193: PPUSH
80194: LD_EXP 45
80198: PUSH
80199: LD_VAR 0 3
80203: ARRAY
80204: PUSH
80205: LD_VAR 0 1
80209: DIFF
80210: PPUSH
80211: CALL_OW 1
80215: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
80216: LD_ADDR_VAR 0 8
80220: PUSH
80221: LD_VAR 0 3
80225: PPUSH
80226: LD_INT 3
80228: PPUSH
80229: CALL 76875 0 2
80233: ST_TO_ADDR
// if fac then
80234: LD_VAR 0 8
80238: IFFALSE 80467
// begin for j in fac do
80240: LD_ADDR_VAR 0 4
80244: PUSH
80245: LD_VAR 0 8
80249: PUSH
80250: FOR_IN
80251: IFFALSE 80465
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
80253: LD_ADDR_VAR 0 9
80257: PUSH
80258: LD_VAR 0 8
80262: PPUSH
80263: LD_VAR 0 1
80267: PPUSH
80268: CALL_OW 265
80272: PPUSH
80273: LD_VAR 0 1
80277: PPUSH
80278: CALL_OW 262
80282: PPUSH
80283: LD_VAR 0 1
80287: PPUSH
80288: CALL_OW 263
80292: PPUSH
80293: LD_VAR 0 1
80297: PPUSH
80298: CALL_OW 264
80302: PPUSH
80303: CALL 13654 0 5
80307: ST_TO_ADDR
// if components then
80308: LD_VAR 0 9
80312: IFFALSE 80463
// begin if GetWeapon ( un ) = ar_control_tower then
80314: LD_VAR 0 1
80318: PPUSH
80319: CALL_OW 264
80323: PUSH
80324: LD_INT 31
80326: EQUAL
80327: IFFALSE 80444
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
80329: LD_VAR 0 1
80333: PPUSH
80334: CALL_OW 311
80338: PPUSH
80339: LD_INT 0
80341: PPUSH
80342: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
80346: LD_ADDR_EXP 63
80350: PUSH
80351: LD_EXP 63
80355: PPUSH
80356: LD_VAR 0 3
80360: PPUSH
80361: LD_EXP 63
80365: PUSH
80366: LD_VAR 0 3
80370: ARRAY
80371: PUSH
80372: LD_VAR 0 1
80376: PPUSH
80377: CALL_OW 311
80381: DIFF
80382: PPUSH
80383: CALL_OW 1
80387: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
80388: LD_ADDR_VAR 0 7
80392: PUSH
80393: LD_EXP 44
80397: PUSH
80398: LD_VAR 0 3
80402: ARRAY
80403: PPUSH
80404: LD_INT 1
80406: PPUSH
80407: LD_VAR 0 9
80411: PPUSH
80412: CALL_OW 2
80416: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
80417: LD_ADDR_EXP 44
80421: PUSH
80422: LD_EXP 44
80426: PPUSH
80427: LD_VAR 0 3
80431: PPUSH
80432: LD_VAR 0 7
80436: PPUSH
80437: CALL_OW 1
80441: ST_TO_ADDR
// end else
80442: GO 80461
// MC_InsertProduceList ( i , [ components ] ) ;
80444: LD_VAR 0 3
80448: PPUSH
80449: LD_VAR 0 9
80453: PUSH
80454: EMPTY
80455: LIST
80456: PPUSH
80457: CALL 76420 0 2
// break ;
80461: GO 80465
// end ; end ;
80463: GO 80250
80465: POP
80466: POP
// end ; end ; if GetType ( un ) = unit_building then
80467: LD_VAR 0 1
80471: PPUSH
80472: CALL_OW 247
80476: PUSH
80477: LD_INT 3
80479: EQUAL
80480: IFFALSE 80883
// begin btype := GetBType ( un ) ;
80482: LD_ADDR_VAR 0 5
80486: PUSH
80487: LD_VAR 0 1
80491: PPUSH
80492: CALL_OW 266
80496: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
80497: LD_VAR 0 5
80501: PUSH
80502: LD_INT 29
80504: PUSH
80505: LD_INT 30
80507: PUSH
80508: EMPTY
80509: LIST
80510: LIST
80511: IN
80512: IFFALSE 80585
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
80514: LD_VAR 0 1
80518: PPUSH
80519: CALL_OW 250
80523: PPUSH
80524: LD_VAR 0 1
80528: PPUSH
80529: CALL_OW 251
80533: PPUSH
80534: LD_VAR 0 1
80538: PPUSH
80539: CALL_OW 255
80543: PPUSH
80544: CALL_OW 440
80548: NOT
80549: IFFALSE 80585
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
80551: LD_VAR 0 1
80555: PPUSH
80556: CALL_OW 250
80560: PPUSH
80561: LD_VAR 0 1
80565: PPUSH
80566: CALL_OW 251
80570: PPUSH
80571: LD_VAR 0 1
80575: PPUSH
80576: CALL_OW 255
80580: PPUSH
80581: CALL_OW 441
// end ; if btype = b_warehouse then
80585: LD_VAR 0 5
80589: PUSH
80590: LD_INT 1
80592: EQUAL
80593: IFFALSE 80611
// begin btype := b_depot ;
80595: LD_ADDR_VAR 0 5
80599: PUSH
80600: LD_INT 0
80602: ST_TO_ADDR
// pos := 1 ;
80603: LD_ADDR_VAR 0 6
80607: PUSH
80608: LD_INT 1
80610: ST_TO_ADDR
// end ; if btype = b_factory then
80611: LD_VAR 0 5
80615: PUSH
80616: LD_INT 3
80618: EQUAL
80619: IFFALSE 80637
// begin btype := b_workshop ;
80621: LD_ADDR_VAR 0 5
80625: PUSH
80626: LD_INT 2
80628: ST_TO_ADDR
// pos := 1 ;
80629: LD_ADDR_VAR 0 6
80633: PUSH
80634: LD_INT 1
80636: ST_TO_ADDR
// end ; if btype = b_barracks then
80637: LD_VAR 0 5
80641: PUSH
80642: LD_INT 5
80644: EQUAL
80645: IFFALSE 80655
// btype := b_armoury ;
80647: LD_ADDR_VAR 0 5
80651: PUSH
80652: LD_INT 4
80654: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
80655: LD_VAR 0 5
80659: PUSH
80660: LD_INT 7
80662: PUSH
80663: LD_INT 8
80665: PUSH
80666: EMPTY
80667: LIST
80668: LIST
80669: IN
80670: IFFALSE 80680
// btype := b_lab ;
80672: LD_ADDR_VAR 0 5
80676: PUSH
80677: LD_INT 6
80679: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
80680: LD_ADDR_EXP 28
80684: PUSH
80685: LD_EXP 28
80689: PPUSH
80690: LD_VAR 0 3
80694: PUSH
80695: LD_EXP 28
80699: PUSH
80700: LD_VAR 0 3
80704: ARRAY
80705: PUSH
80706: LD_INT 1
80708: PLUS
80709: PUSH
80710: EMPTY
80711: LIST
80712: LIST
80713: PPUSH
80714: LD_VAR 0 5
80718: PUSH
80719: LD_VAR 0 1
80723: PPUSH
80724: CALL_OW 250
80728: PUSH
80729: LD_VAR 0 1
80733: PPUSH
80734: CALL_OW 251
80738: PUSH
80739: LD_VAR 0 1
80743: PPUSH
80744: CALL_OW 254
80748: PUSH
80749: EMPTY
80750: LIST
80751: LIST
80752: LIST
80753: LIST
80754: PPUSH
80755: CALL 16156 0 3
80759: ST_TO_ADDR
// if pos = 1 then
80760: LD_VAR 0 6
80764: PUSH
80765: LD_INT 1
80767: EQUAL
80768: IFFALSE 80883
// begin tmp := mc_build_list [ i ] ;
80770: LD_ADDR_VAR 0 7
80774: PUSH
80775: LD_EXP 28
80779: PUSH
80780: LD_VAR 0 3
80784: ARRAY
80785: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
80786: LD_VAR 0 7
80790: PPUSH
80791: LD_INT 2
80793: PUSH
80794: LD_INT 30
80796: PUSH
80797: LD_INT 0
80799: PUSH
80800: EMPTY
80801: LIST
80802: LIST
80803: PUSH
80804: LD_INT 30
80806: PUSH
80807: LD_INT 1
80809: PUSH
80810: EMPTY
80811: LIST
80812: LIST
80813: PUSH
80814: EMPTY
80815: LIST
80816: LIST
80817: LIST
80818: PPUSH
80819: CALL_OW 72
80823: IFFALSE 80833
// pos := 2 ;
80825: LD_ADDR_VAR 0 6
80829: PUSH
80830: LD_INT 2
80832: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
80833: LD_ADDR_VAR 0 7
80837: PUSH
80838: LD_VAR 0 7
80842: PPUSH
80843: LD_VAR 0 6
80847: PPUSH
80848: LD_VAR 0 7
80852: PPUSH
80853: CALL 16482 0 3
80857: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
80858: LD_ADDR_EXP 28
80862: PUSH
80863: LD_EXP 28
80867: PPUSH
80868: LD_VAR 0 3
80872: PPUSH
80873: LD_VAR 0 7
80877: PPUSH
80878: CALL_OW 1
80882: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
80883: LD_VAR 0 1
80887: PUSH
80888: LD_EXP 23
80892: PUSH
80893: LD_VAR 0 3
80897: ARRAY
80898: IN
80899: IFFALSE 80938
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
80901: LD_ADDR_EXP 23
80905: PUSH
80906: LD_EXP 23
80910: PPUSH
80911: LD_VAR 0 3
80915: PPUSH
80916: LD_EXP 23
80920: PUSH
80921: LD_VAR 0 3
80925: ARRAY
80926: PUSH
80927: LD_VAR 0 1
80931: DIFF
80932: PPUSH
80933: CALL_OW 1
80937: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
80938: LD_VAR 0 1
80942: PUSH
80943: LD_EXP 30
80947: PUSH
80948: LD_VAR 0 3
80952: ARRAY
80953: IN
80954: IFFALSE 80993
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
80956: LD_ADDR_EXP 30
80960: PUSH
80961: LD_EXP 30
80965: PPUSH
80966: LD_VAR 0 3
80970: PPUSH
80971: LD_EXP 30
80975: PUSH
80976: LD_VAR 0 3
80980: ARRAY
80981: PUSH
80982: LD_VAR 0 1
80986: DIFF
80987: PPUSH
80988: CALL_OW 1
80992: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
80993: LD_VAR 0 1
80997: PUSH
80998: LD_EXP 42
81002: PUSH
81003: LD_VAR 0 3
81007: ARRAY
81008: IN
81009: IFFALSE 81048
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
81011: LD_ADDR_EXP 42
81015: PUSH
81016: LD_EXP 42
81020: PPUSH
81021: LD_VAR 0 3
81025: PPUSH
81026: LD_EXP 42
81030: PUSH
81031: LD_VAR 0 3
81035: ARRAY
81036: PUSH
81037: LD_VAR 0 1
81041: DIFF
81042: PPUSH
81043: CALL_OW 1
81047: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
81048: LD_VAR 0 1
81052: PUSH
81053: LD_EXP 45
81057: PUSH
81058: LD_VAR 0 3
81062: ARRAY
81063: IN
81064: IFFALSE 81103
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
81066: LD_ADDR_EXP 45
81070: PUSH
81071: LD_EXP 45
81075: PPUSH
81076: LD_VAR 0 3
81080: PPUSH
81081: LD_EXP 45
81085: PUSH
81086: LD_VAR 0 3
81090: ARRAY
81091: PUSH
81092: LD_VAR 0 1
81096: DIFF
81097: PPUSH
81098: CALL_OW 1
81102: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
81103: LD_VAR 0 1
81107: PUSH
81108: LD_EXP 32
81112: PUSH
81113: LD_VAR 0 3
81117: ARRAY
81118: IN
81119: IFFALSE 81158
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
81121: LD_ADDR_EXP 32
81125: PUSH
81126: LD_EXP 32
81130: PPUSH
81131: LD_VAR 0 3
81135: PPUSH
81136: LD_EXP 32
81140: PUSH
81141: LD_VAR 0 3
81145: ARRAY
81146: PUSH
81147: LD_VAR 0 1
81151: DIFF
81152: PPUSH
81153: CALL_OW 1
81157: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
81158: LD_VAR 0 1
81162: PUSH
81163: LD_EXP 31
81167: PUSH
81168: LD_VAR 0 3
81172: ARRAY
81173: IN
81174: IFFALSE 81213
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
81176: LD_ADDR_EXP 31
81180: PUSH
81181: LD_EXP 31
81185: PPUSH
81186: LD_VAR 0 3
81190: PPUSH
81191: LD_EXP 31
81195: PUSH
81196: LD_VAR 0 3
81200: ARRAY
81201: PUSH
81202: LD_VAR 0 1
81206: DIFF
81207: PPUSH
81208: CALL_OW 1
81212: ST_TO_ADDR
// end ; break ;
81213: GO 81217
// end ;
81215: GO 79865
81217: POP
81218: POP
// end ;
81219: LD_VAR 0 2
81223: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
81224: LD_INT 0
81226: PPUSH
81227: PPUSH
81228: PPUSH
// if not mc_bases or not skirmish then
81229: LD_EXP 23
81233: NOT
81234: PUSH
81235: LD_EXP 21
81239: NOT
81240: OR
81241: IFFALSE 81245
// exit ;
81243: GO 81460
// for i = 1 to mc_bases do
81245: LD_ADDR_VAR 0 3
81249: PUSH
81250: DOUBLE
81251: LD_INT 1
81253: DEC
81254: ST_TO_ADDR
81255: LD_EXP 23
81259: PUSH
81260: FOR_TO
81261: IFFALSE 81458
// begin if building in mc_construct_list [ i ] then
81263: LD_VAR 0 1
81267: PUSH
81268: LD_EXP 30
81272: PUSH
81273: LD_VAR 0 3
81277: ARRAY
81278: IN
81279: IFFALSE 81456
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
81281: LD_ADDR_EXP 30
81285: PUSH
81286: LD_EXP 30
81290: PPUSH
81291: LD_VAR 0 3
81295: PPUSH
81296: LD_EXP 30
81300: PUSH
81301: LD_VAR 0 3
81305: ARRAY
81306: PUSH
81307: LD_VAR 0 1
81311: DIFF
81312: PPUSH
81313: CALL_OW 1
81317: ST_TO_ADDR
// if building in mc_lab [ i ] then
81318: LD_VAR 0 1
81322: PUSH
81323: LD_EXP 56
81327: PUSH
81328: LD_VAR 0 3
81332: ARRAY
81333: IN
81334: IFFALSE 81389
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
81336: LD_ADDR_EXP 57
81340: PUSH
81341: LD_EXP 57
81345: PPUSH
81346: LD_VAR 0 3
81350: PPUSH
81351: LD_EXP 57
81355: PUSH
81356: LD_VAR 0 3
81360: ARRAY
81361: PPUSH
81362: LD_INT 1
81364: PPUSH
81365: LD_EXP 57
81369: PUSH
81370: LD_VAR 0 3
81374: ARRAY
81375: PPUSH
81376: LD_INT 0
81378: PPUSH
81379: CALL 15574 0 4
81383: PPUSH
81384: CALL_OW 1
81388: ST_TO_ADDR
// if not building in mc_bases [ i ] then
81389: LD_VAR 0 1
81393: PUSH
81394: LD_EXP 23
81398: PUSH
81399: LD_VAR 0 3
81403: ARRAY
81404: IN
81405: NOT
81406: IFFALSE 81452
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
81408: LD_ADDR_EXP 23
81412: PUSH
81413: LD_EXP 23
81417: PPUSH
81418: LD_VAR 0 3
81422: PUSH
81423: LD_EXP 23
81427: PUSH
81428: LD_VAR 0 3
81432: ARRAY
81433: PUSH
81434: LD_INT 1
81436: PLUS
81437: PUSH
81438: EMPTY
81439: LIST
81440: LIST
81441: PPUSH
81442: LD_VAR 0 1
81446: PPUSH
81447: CALL 16156 0 3
81451: ST_TO_ADDR
// exit ;
81452: POP
81453: POP
81454: GO 81460
// end ; end ;
81456: GO 81260
81458: POP
81459: POP
// end ;
81460: LD_VAR 0 2
81464: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
81465: LD_INT 0
81467: PPUSH
81468: PPUSH
81469: PPUSH
81470: PPUSH
81471: PPUSH
81472: PPUSH
81473: PPUSH
// if not mc_bases or not skirmish then
81474: LD_EXP 23
81478: NOT
81479: PUSH
81480: LD_EXP 21
81484: NOT
81485: OR
81486: IFFALSE 81490
// exit ;
81488: GO 82151
// for i = 1 to mc_bases do
81490: LD_ADDR_VAR 0 3
81494: PUSH
81495: DOUBLE
81496: LD_INT 1
81498: DEC
81499: ST_TO_ADDR
81500: LD_EXP 23
81504: PUSH
81505: FOR_TO
81506: IFFALSE 82149
// begin if building in mc_construct_list [ i ] then
81508: LD_VAR 0 1
81512: PUSH
81513: LD_EXP 30
81517: PUSH
81518: LD_VAR 0 3
81522: ARRAY
81523: IN
81524: IFFALSE 82147
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
81526: LD_ADDR_EXP 30
81530: PUSH
81531: LD_EXP 30
81535: PPUSH
81536: LD_VAR 0 3
81540: PPUSH
81541: LD_EXP 30
81545: PUSH
81546: LD_VAR 0 3
81550: ARRAY
81551: PUSH
81552: LD_VAR 0 1
81556: DIFF
81557: PPUSH
81558: CALL_OW 1
81562: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
81563: LD_ADDR_EXP 23
81567: PUSH
81568: LD_EXP 23
81572: PPUSH
81573: LD_VAR 0 3
81577: PUSH
81578: LD_EXP 23
81582: PUSH
81583: LD_VAR 0 3
81587: ARRAY
81588: PUSH
81589: LD_INT 1
81591: PLUS
81592: PUSH
81593: EMPTY
81594: LIST
81595: LIST
81596: PPUSH
81597: LD_VAR 0 1
81601: PPUSH
81602: CALL 16156 0 3
81606: ST_TO_ADDR
// btype := GetBType ( building ) ;
81607: LD_ADDR_VAR 0 5
81611: PUSH
81612: LD_VAR 0 1
81616: PPUSH
81617: CALL_OW 266
81621: ST_TO_ADDR
// side := GetSide ( building ) ;
81622: LD_ADDR_VAR 0 8
81626: PUSH
81627: LD_VAR 0 1
81631: PPUSH
81632: CALL_OW 255
81636: ST_TO_ADDR
// if btype = b_lab then
81637: LD_VAR 0 5
81641: PUSH
81642: LD_INT 6
81644: EQUAL
81645: IFFALSE 81695
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
81647: LD_ADDR_EXP 56
81651: PUSH
81652: LD_EXP 56
81656: PPUSH
81657: LD_VAR 0 3
81661: PUSH
81662: LD_EXP 56
81666: PUSH
81667: LD_VAR 0 3
81671: ARRAY
81672: PUSH
81673: LD_INT 1
81675: PLUS
81676: PUSH
81677: EMPTY
81678: LIST
81679: LIST
81680: PPUSH
81681: LD_VAR 0 1
81685: PPUSH
81686: CALL 16156 0 3
81690: ST_TO_ADDR
// exit ;
81691: POP
81692: POP
81693: GO 82151
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
81695: LD_VAR 0 5
81699: PUSH
81700: LD_INT 0
81702: PUSH
81703: LD_INT 2
81705: PUSH
81706: LD_INT 4
81708: PUSH
81709: EMPTY
81710: LIST
81711: LIST
81712: LIST
81713: IN
81714: IFFALSE 81838
// begin if btype = b_armoury then
81716: LD_VAR 0 5
81720: PUSH
81721: LD_INT 4
81723: EQUAL
81724: IFFALSE 81734
// btype := b_barracks ;
81726: LD_ADDR_VAR 0 5
81730: PUSH
81731: LD_INT 5
81733: ST_TO_ADDR
// if btype = b_depot then
81734: LD_VAR 0 5
81738: PUSH
81739: LD_INT 0
81741: EQUAL
81742: IFFALSE 81752
// btype := b_warehouse ;
81744: LD_ADDR_VAR 0 5
81748: PUSH
81749: LD_INT 1
81751: ST_TO_ADDR
// if btype = b_workshop then
81752: LD_VAR 0 5
81756: PUSH
81757: LD_INT 2
81759: EQUAL
81760: IFFALSE 81770
// btype := b_factory ;
81762: LD_ADDR_VAR 0 5
81766: PUSH
81767: LD_INT 3
81769: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
81770: LD_VAR 0 5
81774: PPUSH
81775: LD_VAR 0 8
81779: PPUSH
81780: CALL_OW 323
81784: PUSH
81785: LD_INT 1
81787: EQUAL
81788: IFFALSE 81834
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
81790: LD_ADDR_EXP 55
81794: PUSH
81795: LD_EXP 55
81799: PPUSH
81800: LD_VAR 0 3
81804: PUSH
81805: LD_EXP 55
81809: PUSH
81810: LD_VAR 0 3
81814: ARRAY
81815: PUSH
81816: LD_INT 1
81818: PLUS
81819: PUSH
81820: EMPTY
81821: LIST
81822: LIST
81823: PPUSH
81824: LD_VAR 0 1
81828: PPUSH
81829: CALL 16156 0 3
81833: ST_TO_ADDR
// exit ;
81834: POP
81835: POP
81836: GO 82151
// end ; if btype in [ b_bunker , b_turret ] then
81838: LD_VAR 0 5
81842: PUSH
81843: LD_INT 32
81845: PUSH
81846: LD_INT 33
81848: PUSH
81849: EMPTY
81850: LIST
81851: LIST
81852: IN
81853: IFFALSE 82143
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
81855: LD_ADDR_EXP 31
81859: PUSH
81860: LD_EXP 31
81864: PPUSH
81865: LD_VAR 0 3
81869: PUSH
81870: LD_EXP 31
81874: PUSH
81875: LD_VAR 0 3
81879: ARRAY
81880: PUSH
81881: LD_INT 1
81883: PLUS
81884: PUSH
81885: EMPTY
81886: LIST
81887: LIST
81888: PPUSH
81889: LD_VAR 0 1
81893: PPUSH
81894: CALL 16156 0 3
81898: ST_TO_ADDR
// if btype = b_bunker then
81899: LD_VAR 0 5
81903: PUSH
81904: LD_INT 32
81906: EQUAL
81907: IFFALSE 82143
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
81909: LD_ADDR_EXP 32
81913: PUSH
81914: LD_EXP 32
81918: PPUSH
81919: LD_VAR 0 3
81923: PUSH
81924: LD_EXP 32
81928: PUSH
81929: LD_VAR 0 3
81933: ARRAY
81934: PUSH
81935: LD_INT 1
81937: PLUS
81938: PUSH
81939: EMPTY
81940: LIST
81941: LIST
81942: PPUSH
81943: LD_VAR 0 1
81947: PPUSH
81948: CALL 16156 0 3
81952: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
81953: LD_ADDR_VAR 0 6
81957: PUSH
81958: LD_EXP 23
81962: PUSH
81963: LD_VAR 0 3
81967: ARRAY
81968: PPUSH
81969: LD_INT 25
81971: PUSH
81972: LD_INT 1
81974: PUSH
81975: EMPTY
81976: LIST
81977: LIST
81978: PUSH
81979: LD_INT 3
81981: PUSH
81982: LD_INT 54
81984: PUSH
81985: EMPTY
81986: LIST
81987: PUSH
81988: EMPTY
81989: LIST
81990: LIST
81991: PUSH
81992: EMPTY
81993: LIST
81994: LIST
81995: PPUSH
81996: CALL_OW 72
82000: ST_TO_ADDR
// if tmp then
82001: LD_VAR 0 6
82005: IFFALSE 82011
// exit ;
82007: POP
82008: POP
82009: GO 82151
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
82011: LD_ADDR_VAR 0 6
82015: PUSH
82016: LD_EXP 23
82020: PUSH
82021: LD_VAR 0 3
82025: ARRAY
82026: PPUSH
82027: LD_INT 2
82029: PUSH
82030: LD_INT 30
82032: PUSH
82033: LD_INT 4
82035: PUSH
82036: EMPTY
82037: LIST
82038: LIST
82039: PUSH
82040: LD_INT 30
82042: PUSH
82043: LD_INT 5
82045: PUSH
82046: EMPTY
82047: LIST
82048: LIST
82049: PUSH
82050: EMPTY
82051: LIST
82052: LIST
82053: LIST
82054: PPUSH
82055: CALL_OW 72
82059: ST_TO_ADDR
// if not tmp then
82060: LD_VAR 0 6
82064: NOT
82065: IFFALSE 82071
// exit ;
82067: POP
82068: POP
82069: GO 82151
// for j in tmp do
82071: LD_ADDR_VAR 0 4
82075: PUSH
82076: LD_VAR 0 6
82080: PUSH
82081: FOR_IN
82082: IFFALSE 82141
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
82084: LD_ADDR_VAR 0 7
82088: PUSH
82089: LD_VAR 0 4
82093: PPUSH
82094: CALL_OW 313
82098: PPUSH
82099: LD_INT 25
82101: PUSH
82102: LD_INT 1
82104: PUSH
82105: EMPTY
82106: LIST
82107: LIST
82108: PPUSH
82109: CALL_OW 72
82113: ST_TO_ADDR
// if units then
82114: LD_VAR 0 7
82118: IFFALSE 82139
// begin ComExitBuilding ( units [ 1 ] ) ;
82120: LD_VAR 0 7
82124: PUSH
82125: LD_INT 1
82127: ARRAY
82128: PPUSH
82129: CALL_OW 122
// exit ;
82133: POP
82134: POP
82135: POP
82136: POP
82137: GO 82151
// end ; end ;
82139: GO 82081
82141: POP
82142: POP
// end ; end ; exit ;
82143: POP
82144: POP
82145: GO 82151
// end ; end ;
82147: GO 81505
82149: POP
82150: POP
// end ;
82151: LD_VAR 0 2
82155: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
82156: LD_INT 0
82158: PPUSH
82159: PPUSH
82160: PPUSH
82161: PPUSH
82162: PPUSH
82163: PPUSH
82164: PPUSH
// if not mc_bases or not skirmish then
82165: LD_EXP 23
82169: NOT
82170: PUSH
82171: LD_EXP 21
82175: NOT
82176: OR
82177: IFFALSE 82181
// exit ;
82179: GO 82446
// btype := GetBType ( building ) ;
82181: LD_ADDR_VAR 0 6
82185: PUSH
82186: LD_VAR 0 1
82190: PPUSH
82191: CALL_OW 266
82195: ST_TO_ADDR
// x := GetX ( building ) ;
82196: LD_ADDR_VAR 0 7
82200: PUSH
82201: LD_VAR 0 1
82205: PPUSH
82206: CALL_OW 250
82210: ST_TO_ADDR
// y := GetY ( building ) ;
82211: LD_ADDR_VAR 0 8
82215: PUSH
82216: LD_VAR 0 1
82220: PPUSH
82221: CALL_OW 251
82225: ST_TO_ADDR
// d := GetDir ( building ) ;
82226: LD_ADDR_VAR 0 9
82230: PUSH
82231: LD_VAR 0 1
82235: PPUSH
82236: CALL_OW 254
82240: ST_TO_ADDR
// for i = 1 to mc_bases do
82241: LD_ADDR_VAR 0 4
82245: PUSH
82246: DOUBLE
82247: LD_INT 1
82249: DEC
82250: ST_TO_ADDR
82251: LD_EXP 23
82255: PUSH
82256: FOR_TO
82257: IFFALSE 82444
// begin if not mc_build_list [ i ] then
82259: LD_EXP 28
82263: PUSH
82264: LD_VAR 0 4
82268: ARRAY
82269: NOT
82270: IFFALSE 82274
// continue ;
82272: GO 82256
// for j := 1 to mc_build_list [ i ] do
82274: LD_ADDR_VAR 0 5
82278: PUSH
82279: DOUBLE
82280: LD_INT 1
82282: DEC
82283: ST_TO_ADDR
82284: LD_EXP 28
82288: PUSH
82289: LD_VAR 0 4
82293: ARRAY
82294: PUSH
82295: FOR_TO
82296: IFFALSE 82440
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
82298: LD_VAR 0 6
82302: PUSH
82303: LD_VAR 0 7
82307: PUSH
82308: LD_VAR 0 8
82312: PUSH
82313: LD_VAR 0 9
82317: PUSH
82318: EMPTY
82319: LIST
82320: LIST
82321: LIST
82322: LIST
82323: PPUSH
82324: LD_EXP 28
82328: PUSH
82329: LD_VAR 0 4
82333: ARRAY
82334: PUSH
82335: LD_VAR 0 5
82339: ARRAY
82340: PPUSH
82341: CALL 22336 0 2
82345: IFFALSE 82438
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
82347: LD_ADDR_EXP 28
82351: PUSH
82352: LD_EXP 28
82356: PPUSH
82357: LD_VAR 0 4
82361: PPUSH
82362: LD_EXP 28
82366: PUSH
82367: LD_VAR 0 4
82371: ARRAY
82372: PPUSH
82373: LD_VAR 0 5
82377: PPUSH
82378: CALL_OW 3
82382: PPUSH
82383: CALL_OW 1
82387: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
82388: LD_ADDR_EXP 30
82392: PUSH
82393: LD_EXP 30
82397: PPUSH
82398: LD_VAR 0 4
82402: PUSH
82403: LD_EXP 30
82407: PUSH
82408: LD_VAR 0 4
82412: ARRAY
82413: PUSH
82414: LD_INT 1
82416: PLUS
82417: PUSH
82418: EMPTY
82419: LIST
82420: LIST
82421: PPUSH
82422: LD_VAR 0 1
82426: PPUSH
82427: CALL 16156 0 3
82431: ST_TO_ADDR
// exit ;
82432: POP
82433: POP
82434: POP
82435: POP
82436: GO 82446
// end ;
82438: GO 82295
82440: POP
82441: POP
// end ;
82442: GO 82256
82444: POP
82445: POP
// end ;
82446: LD_VAR 0 3
82450: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
82451: LD_INT 0
82453: PPUSH
82454: PPUSH
82455: PPUSH
// if not mc_bases or not skirmish then
82456: LD_EXP 23
82460: NOT
82461: PUSH
82462: LD_EXP 21
82466: NOT
82467: OR
82468: IFFALSE 82472
// exit ;
82470: GO 82662
// for i = 1 to mc_bases do
82472: LD_ADDR_VAR 0 4
82476: PUSH
82477: DOUBLE
82478: LD_INT 1
82480: DEC
82481: ST_TO_ADDR
82482: LD_EXP 23
82486: PUSH
82487: FOR_TO
82488: IFFALSE 82575
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
82490: LD_VAR 0 1
82494: PUSH
82495: LD_EXP 31
82499: PUSH
82500: LD_VAR 0 4
82504: ARRAY
82505: IN
82506: PUSH
82507: LD_VAR 0 1
82511: PUSH
82512: LD_EXP 32
82516: PUSH
82517: LD_VAR 0 4
82521: ARRAY
82522: IN
82523: NOT
82524: AND
82525: IFFALSE 82573
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
82527: LD_ADDR_EXP 32
82531: PUSH
82532: LD_EXP 32
82536: PPUSH
82537: LD_VAR 0 4
82541: PUSH
82542: LD_EXP 32
82546: PUSH
82547: LD_VAR 0 4
82551: ARRAY
82552: PUSH
82553: LD_INT 1
82555: PLUS
82556: PUSH
82557: EMPTY
82558: LIST
82559: LIST
82560: PPUSH
82561: LD_VAR 0 1
82565: PPUSH
82566: CALL 16156 0 3
82570: ST_TO_ADDR
// break ;
82571: GO 82575
// end ; end ;
82573: GO 82487
82575: POP
82576: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
82577: LD_VAR 0 1
82581: PPUSH
82582: CALL_OW 257
82586: PUSH
82587: LD_EXP 49
82591: IN
82592: PUSH
82593: LD_VAR 0 1
82597: PPUSH
82598: CALL_OW 266
82602: PUSH
82603: LD_INT 5
82605: EQUAL
82606: AND
82607: PUSH
82608: LD_VAR 0 2
82612: PPUSH
82613: CALL_OW 110
82617: PUSH
82618: LD_INT 18
82620: NONEQUAL
82621: AND
82622: IFFALSE 82662
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
82624: LD_VAR 0 2
82628: PPUSH
82629: CALL_OW 257
82633: PUSH
82634: LD_INT 5
82636: PUSH
82637: LD_INT 8
82639: PUSH
82640: LD_INT 9
82642: PUSH
82643: EMPTY
82644: LIST
82645: LIST
82646: LIST
82647: IN
82648: IFFALSE 82662
// SetClass ( unit , 1 ) ;
82650: LD_VAR 0 2
82654: PPUSH
82655: LD_INT 1
82657: PPUSH
82658: CALL_OW 336
// end ;
82662: LD_VAR 0 3
82666: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
82667: LD_INT 0
82669: PPUSH
82670: PPUSH
// if not mc_bases or not skirmish then
82671: LD_EXP 23
82675: NOT
82676: PUSH
82677: LD_EXP 21
82681: NOT
82682: OR
82683: IFFALSE 82687
// exit ;
82685: GO 82803
// if GetLives ( abandoned_vehicle ) > 250 then
82687: LD_VAR 0 2
82691: PPUSH
82692: CALL_OW 256
82696: PUSH
82697: LD_INT 250
82699: GREATER
82700: IFFALSE 82704
// exit ;
82702: GO 82803
// for i = 1 to mc_bases do
82704: LD_ADDR_VAR 0 6
82708: PUSH
82709: DOUBLE
82710: LD_INT 1
82712: DEC
82713: ST_TO_ADDR
82714: LD_EXP 23
82718: PUSH
82719: FOR_TO
82720: IFFALSE 82801
// begin if driver in mc_bases [ i ] then
82722: LD_VAR 0 1
82726: PUSH
82727: LD_EXP 23
82731: PUSH
82732: LD_VAR 0 6
82736: ARRAY
82737: IN
82738: IFFALSE 82799
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
82740: LD_VAR 0 1
82744: PPUSH
82745: LD_EXP 23
82749: PUSH
82750: LD_VAR 0 6
82754: ARRAY
82755: PPUSH
82756: LD_INT 2
82758: PUSH
82759: LD_INT 30
82761: PUSH
82762: LD_INT 0
82764: PUSH
82765: EMPTY
82766: LIST
82767: LIST
82768: PUSH
82769: LD_INT 30
82771: PUSH
82772: LD_INT 1
82774: PUSH
82775: EMPTY
82776: LIST
82777: LIST
82778: PUSH
82779: EMPTY
82780: LIST
82781: LIST
82782: LIST
82783: PPUSH
82784: CALL_OW 72
82788: PUSH
82789: LD_INT 1
82791: ARRAY
82792: PPUSH
82793: CALL 49272 0 2
// break ;
82797: GO 82801
// end ; end ;
82799: GO 82719
82801: POP
82802: POP
// end ; end_of_file
82803: LD_VAR 0 5
82807: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
82808: LD_INT 0
82810: PPUSH
82811: PPUSH
82812: PPUSH
82813: PPUSH
82814: PPUSH
82815: PPUSH
82816: PPUSH
82817: PPUSH
82818: PPUSH
82819: PPUSH
82820: PPUSH
82821: PPUSH
82822: PPUSH
82823: PPUSH
82824: PPUSH
82825: PPUSH
82826: PPUSH
82827: PPUSH
82828: PPUSH
82829: PPUSH
82830: PPUSH
82831: PPUSH
82832: PPUSH
82833: PPUSH
82834: PPUSH
82835: PPUSH
82836: PPUSH
82837: PPUSH
82838: PPUSH
82839: PPUSH
82840: PPUSH
82841: PPUSH
82842: PPUSH
82843: PPUSH
// if not list then
82844: LD_VAR 0 1
82848: NOT
82849: IFFALSE 82853
// exit ;
82851: GO 87512
// base := list [ 1 ] ;
82853: LD_ADDR_VAR 0 3
82857: PUSH
82858: LD_VAR 0 1
82862: PUSH
82863: LD_INT 1
82865: ARRAY
82866: ST_TO_ADDR
// group := list [ 2 ] ;
82867: LD_ADDR_VAR 0 4
82871: PUSH
82872: LD_VAR 0 1
82876: PUSH
82877: LD_INT 2
82879: ARRAY
82880: ST_TO_ADDR
// path := list [ 3 ] ;
82881: LD_ADDR_VAR 0 5
82885: PUSH
82886: LD_VAR 0 1
82890: PUSH
82891: LD_INT 3
82893: ARRAY
82894: ST_TO_ADDR
// flags := list [ 4 ] ;
82895: LD_ADDR_VAR 0 6
82899: PUSH
82900: LD_VAR 0 1
82904: PUSH
82905: LD_INT 4
82907: ARRAY
82908: ST_TO_ADDR
// mined := [ ] ;
82909: LD_ADDR_VAR 0 27
82913: PUSH
82914: EMPTY
82915: ST_TO_ADDR
// bombed := [ ] ;
82916: LD_ADDR_VAR 0 28
82920: PUSH
82921: EMPTY
82922: ST_TO_ADDR
// healers := [ ] ;
82923: LD_ADDR_VAR 0 31
82927: PUSH
82928: EMPTY
82929: ST_TO_ADDR
// to_heal := [ ] ;
82930: LD_ADDR_VAR 0 30
82934: PUSH
82935: EMPTY
82936: ST_TO_ADDR
// repairs := [ ] ;
82937: LD_ADDR_VAR 0 33
82941: PUSH
82942: EMPTY
82943: ST_TO_ADDR
// to_repair := [ ] ;
82944: LD_ADDR_VAR 0 32
82948: PUSH
82949: EMPTY
82950: ST_TO_ADDR
// if not group or not path then
82951: LD_VAR 0 4
82955: NOT
82956: PUSH
82957: LD_VAR 0 5
82961: NOT
82962: OR
82963: IFFALSE 82967
// exit ;
82965: GO 87512
// side := GetSide ( group [ 1 ] ) ;
82967: LD_ADDR_VAR 0 35
82971: PUSH
82972: LD_VAR 0 4
82976: PUSH
82977: LD_INT 1
82979: ARRAY
82980: PPUSH
82981: CALL_OW 255
82985: ST_TO_ADDR
// if flags then
82986: LD_VAR 0 6
82990: IFFALSE 83134
// begin f_ignore_area := flags [ 1 ] ;
82992: LD_ADDR_VAR 0 17
82996: PUSH
82997: LD_VAR 0 6
83001: PUSH
83002: LD_INT 1
83004: ARRAY
83005: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
83006: LD_ADDR_VAR 0 18
83010: PUSH
83011: LD_VAR 0 6
83015: PUSH
83016: LD_INT 2
83018: ARRAY
83019: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
83020: LD_ADDR_VAR 0 19
83024: PUSH
83025: LD_VAR 0 6
83029: PUSH
83030: LD_INT 3
83032: ARRAY
83033: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
83034: LD_ADDR_VAR 0 20
83038: PUSH
83039: LD_VAR 0 6
83043: PUSH
83044: LD_INT 4
83046: ARRAY
83047: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
83048: LD_ADDR_VAR 0 21
83052: PUSH
83053: LD_VAR 0 6
83057: PUSH
83058: LD_INT 5
83060: ARRAY
83061: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
83062: LD_ADDR_VAR 0 22
83066: PUSH
83067: LD_VAR 0 6
83071: PUSH
83072: LD_INT 6
83074: ARRAY
83075: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
83076: LD_ADDR_VAR 0 23
83080: PUSH
83081: LD_VAR 0 6
83085: PUSH
83086: LD_INT 7
83088: ARRAY
83089: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
83090: LD_ADDR_VAR 0 24
83094: PUSH
83095: LD_VAR 0 6
83099: PUSH
83100: LD_INT 8
83102: ARRAY
83103: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
83104: LD_ADDR_VAR 0 25
83108: PUSH
83109: LD_VAR 0 6
83113: PUSH
83114: LD_INT 9
83116: ARRAY
83117: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
83118: LD_ADDR_VAR 0 26
83122: PUSH
83123: LD_VAR 0 6
83127: PUSH
83128: LD_INT 10
83130: ARRAY
83131: ST_TO_ADDR
// end else
83132: GO 83214
// begin f_ignore_area := false ;
83134: LD_ADDR_VAR 0 17
83138: PUSH
83139: LD_INT 0
83141: ST_TO_ADDR
// f_capture := false ;
83142: LD_ADDR_VAR 0 18
83146: PUSH
83147: LD_INT 0
83149: ST_TO_ADDR
// f_ignore_civ := false ;
83150: LD_ADDR_VAR 0 19
83154: PUSH
83155: LD_INT 0
83157: ST_TO_ADDR
// f_murder := false ;
83158: LD_ADDR_VAR 0 20
83162: PUSH
83163: LD_INT 0
83165: ST_TO_ADDR
// f_mines := false ;
83166: LD_ADDR_VAR 0 21
83170: PUSH
83171: LD_INT 0
83173: ST_TO_ADDR
// f_repair := false ;
83174: LD_ADDR_VAR 0 22
83178: PUSH
83179: LD_INT 0
83181: ST_TO_ADDR
// f_heal := false ;
83182: LD_ADDR_VAR 0 23
83186: PUSH
83187: LD_INT 0
83189: ST_TO_ADDR
// f_spacetime := false ;
83190: LD_ADDR_VAR 0 24
83194: PUSH
83195: LD_INT 0
83197: ST_TO_ADDR
// f_attack_depot := false ;
83198: LD_ADDR_VAR 0 25
83202: PUSH
83203: LD_INT 0
83205: ST_TO_ADDR
// f_crawl := false ;
83206: LD_ADDR_VAR 0 26
83210: PUSH
83211: LD_INT 0
83213: ST_TO_ADDR
// end ; if f_heal then
83214: LD_VAR 0 23
83218: IFFALSE 83245
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
83220: LD_ADDR_VAR 0 31
83224: PUSH
83225: LD_VAR 0 4
83229: PPUSH
83230: LD_INT 25
83232: PUSH
83233: LD_INT 4
83235: PUSH
83236: EMPTY
83237: LIST
83238: LIST
83239: PPUSH
83240: CALL_OW 72
83244: ST_TO_ADDR
// if f_repair then
83245: LD_VAR 0 22
83249: IFFALSE 83276
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
83251: LD_ADDR_VAR 0 33
83255: PUSH
83256: LD_VAR 0 4
83260: PPUSH
83261: LD_INT 25
83263: PUSH
83264: LD_INT 3
83266: PUSH
83267: EMPTY
83268: LIST
83269: LIST
83270: PPUSH
83271: CALL_OW 72
83275: ST_TO_ADDR
// units_path := [ ] ;
83276: LD_ADDR_VAR 0 16
83280: PUSH
83281: EMPTY
83282: ST_TO_ADDR
// for i = 1 to group do
83283: LD_ADDR_VAR 0 7
83287: PUSH
83288: DOUBLE
83289: LD_INT 1
83291: DEC
83292: ST_TO_ADDR
83293: LD_VAR 0 4
83297: PUSH
83298: FOR_TO
83299: IFFALSE 83328
// units_path := Replace ( units_path , i , path ) ;
83301: LD_ADDR_VAR 0 16
83305: PUSH
83306: LD_VAR 0 16
83310: PPUSH
83311: LD_VAR 0 7
83315: PPUSH
83316: LD_VAR 0 5
83320: PPUSH
83321: CALL_OW 1
83325: ST_TO_ADDR
83326: GO 83298
83328: POP
83329: POP
// repeat for i = group downto 1 do
83330: LD_ADDR_VAR 0 7
83334: PUSH
83335: DOUBLE
83336: LD_VAR 0 4
83340: INC
83341: ST_TO_ADDR
83342: LD_INT 1
83344: PUSH
83345: FOR_DOWNTO
83346: IFFALSE 87468
// begin wait ( 5 ) ;
83348: LD_INT 5
83350: PPUSH
83351: CALL_OW 67
// tmp := [ ] ;
83355: LD_ADDR_VAR 0 14
83359: PUSH
83360: EMPTY
83361: ST_TO_ADDR
// attacking := false ;
83362: LD_ADDR_VAR 0 29
83366: PUSH
83367: LD_INT 0
83369: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
83370: LD_VAR 0 4
83374: PUSH
83375: LD_VAR 0 7
83379: ARRAY
83380: PPUSH
83381: CALL_OW 301
83385: PUSH
83386: LD_VAR 0 4
83390: PUSH
83391: LD_VAR 0 7
83395: ARRAY
83396: NOT
83397: OR
83398: IFFALSE 83507
// begin if GetType ( group [ i ] ) = unit_human then
83400: LD_VAR 0 4
83404: PUSH
83405: LD_VAR 0 7
83409: ARRAY
83410: PPUSH
83411: CALL_OW 247
83415: PUSH
83416: LD_INT 1
83418: EQUAL
83419: IFFALSE 83465
// begin to_heal := to_heal diff group [ i ] ;
83421: LD_ADDR_VAR 0 30
83425: PUSH
83426: LD_VAR 0 30
83430: PUSH
83431: LD_VAR 0 4
83435: PUSH
83436: LD_VAR 0 7
83440: ARRAY
83441: DIFF
83442: ST_TO_ADDR
// healers := healers diff group [ i ] ;
83443: LD_ADDR_VAR 0 31
83447: PUSH
83448: LD_VAR 0 31
83452: PUSH
83453: LD_VAR 0 4
83457: PUSH
83458: LD_VAR 0 7
83462: ARRAY
83463: DIFF
83464: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
83465: LD_ADDR_VAR 0 4
83469: PUSH
83470: LD_VAR 0 4
83474: PPUSH
83475: LD_VAR 0 7
83479: PPUSH
83480: CALL_OW 3
83484: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
83485: LD_ADDR_VAR 0 16
83489: PUSH
83490: LD_VAR 0 16
83494: PPUSH
83495: LD_VAR 0 7
83499: PPUSH
83500: CALL_OW 3
83504: ST_TO_ADDR
// continue ;
83505: GO 83345
// end ; if f_repair then
83507: LD_VAR 0 22
83511: IFFALSE 84000
// begin if GetType ( group [ i ] ) = unit_vehicle then
83513: LD_VAR 0 4
83517: PUSH
83518: LD_VAR 0 7
83522: ARRAY
83523: PPUSH
83524: CALL_OW 247
83528: PUSH
83529: LD_INT 2
83531: EQUAL
83532: IFFALSE 83722
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
83534: LD_VAR 0 4
83538: PUSH
83539: LD_VAR 0 7
83543: ARRAY
83544: PPUSH
83545: CALL_OW 256
83549: PUSH
83550: LD_INT 700
83552: LESS
83553: PUSH
83554: LD_VAR 0 4
83558: PUSH
83559: LD_VAR 0 7
83563: ARRAY
83564: PUSH
83565: LD_VAR 0 32
83569: IN
83570: NOT
83571: AND
83572: IFFALSE 83596
// to_repair := to_repair union group [ i ] ;
83574: LD_ADDR_VAR 0 32
83578: PUSH
83579: LD_VAR 0 32
83583: PUSH
83584: LD_VAR 0 4
83588: PUSH
83589: LD_VAR 0 7
83593: ARRAY
83594: UNION
83595: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
83596: LD_VAR 0 4
83600: PUSH
83601: LD_VAR 0 7
83605: ARRAY
83606: PPUSH
83607: CALL_OW 256
83611: PUSH
83612: LD_INT 1000
83614: EQUAL
83615: PUSH
83616: LD_VAR 0 4
83620: PUSH
83621: LD_VAR 0 7
83625: ARRAY
83626: PUSH
83627: LD_VAR 0 32
83631: IN
83632: AND
83633: IFFALSE 83657
// to_repair := to_repair diff group [ i ] ;
83635: LD_ADDR_VAR 0 32
83639: PUSH
83640: LD_VAR 0 32
83644: PUSH
83645: LD_VAR 0 4
83649: PUSH
83650: LD_VAR 0 7
83654: ARRAY
83655: DIFF
83656: ST_TO_ADDR
// if group [ i ] in to_repair then
83657: LD_VAR 0 4
83661: PUSH
83662: LD_VAR 0 7
83666: ARRAY
83667: PUSH
83668: LD_VAR 0 32
83672: IN
83673: IFFALSE 83720
// begin if not IsInArea ( group [ i ] , f_repair ) then
83675: LD_VAR 0 4
83679: PUSH
83680: LD_VAR 0 7
83684: ARRAY
83685: PPUSH
83686: LD_VAR 0 22
83690: PPUSH
83691: CALL_OW 308
83695: NOT
83696: IFFALSE 83718
// ComMoveToArea ( group [ i ] , f_repair ) ;
83698: LD_VAR 0 4
83702: PUSH
83703: LD_VAR 0 7
83707: ARRAY
83708: PPUSH
83709: LD_VAR 0 22
83713: PPUSH
83714: CALL_OW 113
// continue ;
83718: GO 83345
// end ; end else
83720: GO 84000
// if group [ i ] in repairs then
83722: LD_VAR 0 4
83726: PUSH
83727: LD_VAR 0 7
83731: ARRAY
83732: PUSH
83733: LD_VAR 0 33
83737: IN
83738: IFFALSE 84000
// begin if IsInUnit ( group [ i ] ) then
83740: LD_VAR 0 4
83744: PUSH
83745: LD_VAR 0 7
83749: ARRAY
83750: PPUSH
83751: CALL_OW 310
83755: IFFALSE 83823
// begin z := IsInUnit ( group [ i ] ) ;
83757: LD_ADDR_VAR 0 13
83761: PUSH
83762: LD_VAR 0 4
83766: PUSH
83767: LD_VAR 0 7
83771: ARRAY
83772: PPUSH
83773: CALL_OW 310
83777: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
83778: LD_VAR 0 13
83782: PUSH
83783: LD_VAR 0 32
83787: IN
83788: PUSH
83789: LD_VAR 0 13
83793: PPUSH
83794: LD_VAR 0 22
83798: PPUSH
83799: CALL_OW 308
83803: AND
83804: IFFALSE 83821
// ComExitVehicle ( group [ i ] ) ;
83806: LD_VAR 0 4
83810: PUSH
83811: LD_VAR 0 7
83815: ARRAY
83816: PPUSH
83817: CALL_OW 121
// end else
83821: GO 84000
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
83823: LD_ADDR_VAR 0 13
83827: PUSH
83828: LD_VAR 0 4
83832: PPUSH
83833: LD_INT 95
83835: PUSH
83836: LD_VAR 0 22
83840: PUSH
83841: EMPTY
83842: LIST
83843: LIST
83844: PUSH
83845: LD_INT 58
83847: PUSH
83848: EMPTY
83849: LIST
83850: PUSH
83851: EMPTY
83852: LIST
83853: LIST
83854: PPUSH
83855: CALL_OW 72
83859: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
83860: LD_VAR 0 4
83864: PUSH
83865: LD_VAR 0 7
83869: ARRAY
83870: PPUSH
83871: CALL_OW 314
83875: NOT
83876: IFFALSE 83998
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
83878: LD_ADDR_VAR 0 10
83882: PUSH
83883: LD_VAR 0 13
83887: PPUSH
83888: LD_VAR 0 4
83892: PUSH
83893: LD_VAR 0 7
83897: ARRAY
83898: PPUSH
83899: CALL_OW 74
83903: ST_TO_ADDR
// if not x then
83904: LD_VAR 0 10
83908: NOT
83909: IFFALSE 83913
// continue ;
83911: GO 83345
// if GetLives ( x ) < 1000 then
83913: LD_VAR 0 10
83917: PPUSH
83918: CALL_OW 256
83922: PUSH
83923: LD_INT 1000
83925: LESS
83926: IFFALSE 83950
// ComRepairVehicle ( group [ i ] , x ) else
83928: LD_VAR 0 4
83932: PUSH
83933: LD_VAR 0 7
83937: ARRAY
83938: PPUSH
83939: LD_VAR 0 10
83943: PPUSH
83944: CALL_OW 129
83948: GO 83998
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
83950: LD_VAR 0 23
83954: PUSH
83955: LD_VAR 0 4
83959: PUSH
83960: LD_VAR 0 7
83964: ARRAY
83965: PPUSH
83966: CALL_OW 256
83970: PUSH
83971: LD_INT 1000
83973: LESS
83974: AND
83975: NOT
83976: IFFALSE 83998
// ComEnterUnit ( group [ i ] , x ) ;
83978: LD_VAR 0 4
83982: PUSH
83983: LD_VAR 0 7
83987: ARRAY
83988: PPUSH
83989: LD_VAR 0 10
83993: PPUSH
83994: CALL_OW 120
// end ; continue ;
83998: GO 83345
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
84000: LD_VAR 0 23
84004: PUSH
84005: LD_VAR 0 4
84009: PUSH
84010: LD_VAR 0 7
84014: ARRAY
84015: PPUSH
84016: CALL_OW 247
84020: PUSH
84021: LD_INT 1
84023: EQUAL
84024: AND
84025: IFFALSE 84503
// begin if group [ i ] in healers then
84027: LD_VAR 0 4
84031: PUSH
84032: LD_VAR 0 7
84036: ARRAY
84037: PUSH
84038: LD_VAR 0 31
84042: IN
84043: IFFALSE 84316
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
84045: LD_VAR 0 4
84049: PUSH
84050: LD_VAR 0 7
84054: ARRAY
84055: PPUSH
84056: LD_VAR 0 23
84060: PPUSH
84061: CALL_OW 308
84065: NOT
84066: PUSH
84067: LD_VAR 0 4
84071: PUSH
84072: LD_VAR 0 7
84076: ARRAY
84077: PPUSH
84078: CALL_OW 314
84082: NOT
84083: AND
84084: IFFALSE 84108
// ComMoveToArea ( group [ i ] , f_heal ) else
84086: LD_VAR 0 4
84090: PUSH
84091: LD_VAR 0 7
84095: ARRAY
84096: PPUSH
84097: LD_VAR 0 23
84101: PPUSH
84102: CALL_OW 113
84106: GO 84314
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
84108: LD_VAR 0 4
84112: PUSH
84113: LD_VAR 0 7
84117: ARRAY
84118: PPUSH
84119: CALL 45780 0 1
84123: PPUSH
84124: CALL_OW 256
84128: PUSH
84129: LD_INT 1000
84131: EQUAL
84132: IFFALSE 84151
// ComStop ( group [ i ] ) else
84134: LD_VAR 0 4
84138: PUSH
84139: LD_VAR 0 7
84143: ARRAY
84144: PPUSH
84145: CALL_OW 141
84149: GO 84314
// if not HasTask ( group [ i ] ) and to_heal then
84151: LD_VAR 0 4
84155: PUSH
84156: LD_VAR 0 7
84160: ARRAY
84161: PPUSH
84162: CALL_OW 314
84166: NOT
84167: PUSH
84168: LD_VAR 0 30
84172: AND
84173: IFFALSE 84314
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
84175: LD_ADDR_VAR 0 13
84179: PUSH
84180: LD_VAR 0 30
84184: PPUSH
84185: LD_INT 3
84187: PUSH
84188: LD_INT 54
84190: PUSH
84191: EMPTY
84192: LIST
84193: PUSH
84194: EMPTY
84195: LIST
84196: LIST
84197: PPUSH
84198: CALL_OW 72
84202: PPUSH
84203: LD_VAR 0 4
84207: PUSH
84208: LD_VAR 0 7
84212: ARRAY
84213: PPUSH
84214: CALL_OW 74
84218: ST_TO_ADDR
// if z then
84219: LD_VAR 0 13
84223: IFFALSE 84314
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
84225: LD_INT 91
84227: PUSH
84228: LD_VAR 0 13
84232: PUSH
84233: LD_INT 10
84235: PUSH
84236: EMPTY
84237: LIST
84238: LIST
84239: LIST
84240: PUSH
84241: LD_INT 81
84243: PUSH
84244: LD_VAR 0 13
84248: PPUSH
84249: CALL_OW 255
84253: PUSH
84254: EMPTY
84255: LIST
84256: LIST
84257: PUSH
84258: EMPTY
84259: LIST
84260: LIST
84261: PPUSH
84262: CALL_OW 69
84266: PUSH
84267: LD_INT 0
84269: EQUAL
84270: IFFALSE 84294
// ComHeal ( group [ i ] , z ) else
84272: LD_VAR 0 4
84276: PUSH
84277: LD_VAR 0 7
84281: ARRAY
84282: PPUSH
84283: LD_VAR 0 13
84287: PPUSH
84288: CALL_OW 128
84292: GO 84314
// ComMoveToArea ( group [ i ] , f_heal ) ;
84294: LD_VAR 0 4
84298: PUSH
84299: LD_VAR 0 7
84303: ARRAY
84304: PPUSH
84305: LD_VAR 0 23
84309: PPUSH
84310: CALL_OW 113
// end ; continue ;
84314: GO 83345
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
84316: LD_VAR 0 4
84320: PUSH
84321: LD_VAR 0 7
84325: ARRAY
84326: PPUSH
84327: CALL_OW 256
84331: PUSH
84332: LD_INT 700
84334: LESS
84335: PUSH
84336: LD_VAR 0 4
84340: PUSH
84341: LD_VAR 0 7
84345: ARRAY
84346: PUSH
84347: LD_VAR 0 30
84351: IN
84352: NOT
84353: AND
84354: IFFALSE 84378
// to_heal := to_heal union group [ i ] ;
84356: LD_ADDR_VAR 0 30
84360: PUSH
84361: LD_VAR 0 30
84365: PUSH
84366: LD_VAR 0 4
84370: PUSH
84371: LD_VAR 0 7
84375: ARRAY
84376: UNION
84377: ST_TO_ADDR
// if group [ i ] in to_heal then
84378: LD_VAR 0 4
84382: PUSH
84383: LD_VAR 0 7
84387: ARRAY
84388: PUSH
84389: LD_VAR 0 30
84393: IN
84394: IFFALSE 84503
// begin if GetLives ( group [ i ] ) = 1000 then
84396: LD_VAR 0 4
84400: PUSH
84401: LD_VAR 0 7
84405: ARRAY
84406: PPUSH
84407: CALL_OW 256
84411: PUSH
84412: LD_INT 1000
84414: EQUAL
84415: IFFALSE 84441
// to_heal := to_heal diff group [ i ] else
84417: LD_ADDR_VAR 0 30
84421: PUSH
84422: LD_VAR 0 30
84426: PUSH
84427: LD_VAR 0 4
84431: PUSH
84432: LD_VAR 0 7
84436: ARRAY
84437: DIFF
84438: ST_TO_ADDR
84439: GO 84503
// begin if not IsInArea ( group [ i ] , to_heal ) then
84441: LD_VAR 0 4
84445: PUSH
84446: LD_VAR 0 7
84450: ARRAY
84451: PPUSH
84452: LD_VAR 0 30
84456: PPUSH
84457: CALL_OW 308
84461: NOT
84462: IFFALSE 84486
// ComMoveToArea ( group [ i ] , f_heal ) else
84464: LD_VAR 0 4
84468: PUSH
84469: LD_VAR 0 7
84473: ARRAY
84474: PPUSH
84475: LD_VAR 0 23
84479: PPUSH
84480: CALL_OW 113
84484: GO 84501
// ComHold ( group [ i ] ) ;
84486: LD_VAR 0 4
84490: PUSH
84491: LD_VAR 0 7
84495: ARRAY
84496: PPUSH
84497: CALL_OW 140
// continue ;
84501: GO 83345
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
84503: LD_VAR 0 4
84507: PUSH
84508: LD_VAR 0 7
84512: ARRAY
84513: PPUSH
84514: LD_INT 10
84516: PPUSH
84517: CALL 43650 0 2
84521: NOT
84522: PUSH
84523: LD_VAR 0 16
84527: PUSH
84528: LD_VAR 0 7
84532: ARRAY
84533: PUSH
84534: EMPTY
84535: EQUAL
84536: NOT
84537: AND
84538: IFFALSE 84804
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
84540: LD_VAR 0 4
84544: PUSH
84545: LD_VAR 0 7
84549: ARRAY
84550: PPUSH
84551: CALL_OW 262
84555: PUSH
84556: LD_INT 1
84558: PUSH
84559: LD_INT 2
84561: PUSH
84562: EMPTY
84563: LIST
84564: LIST
84565: IN
84566: IFFALSE 84607
// if GetFuel ( group [ i ] ) < 10 then
84568: LD_VAR 0 4
84572: PUSH
84573: LD_VAR 0 7
84577: ARRAY
84578: PPUSH
84579: CALL_OW 261
84583: PUSH
84584: LD_INT 10
84586: LESS
84587: IFFALSE 84607
// SetFuel ( group [ i ] , 12 ) ;
84589: LD_VAR 0 4
84593: PUSH
84594: LD_VAR 0 7
84598: ARRAY
84599: PPUSH
84600: LD_INT 12
84602: PPUSH
84603: CALL_OW 240
// if units_path [ i ] then
84607: LD_VAR 0 16
84611: PUSH
84612: LD_VAR 0 7
84616: ARRAY
84617: IFFALSE 84802
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
84619: LD_VAR 0 4
84623: PUSH
84624: LD_VAR 0 7
84628: ARRAY
84629: PPUSH
84630: LD_VAR 0 16
84634: PUSH
84635: LD_VAR 0 7
84639: ARRAY
84640: PUSH
84641: LD_INT 1
84643: ARRAY
84644: PUSH
84645: LD_INT 1
84647: ARRAY
84648: PPUSH
84649: LD_VAR 0 16
84653: PUSH
84654: LD_VAR 0 7
84658: ARRAY
84659: PUSH
84660: LD_INT 1
84662: ARRAY
84663: PUSH
84664: LD_INT 2
84666: ARRAY
84667: PPUSH
84668: CALL_OW 297
84672: PUSH
84673: LD_INT 6
84675: GREATER
84676: IFFALSE 84751
// begin if not HasTask ( group [ i ] ) then
84678: LD_VAR 0 4
84682: PUSH
84683: LD_VAR 0 7
84687: ARRAY
84688: PPUSH
84689: CALL_OW 314
84693: NOT
84694: IFFALSE 84749
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
84696: LD_VAR 0 4
84700: PUSH
84701: LD_VAR 0 7
84705: ARRAY
84706: PPUSH
84707: LD_VAR 0 16
84711: PUSH
84712: LD_VAR 0 7
84716: ARRAY
84717: PUSH
84718: LD_INT 1
84720: ARRAY
84721: PUSH
84722: LD_INT 1
84724: ARRAY
84725: PPUSH
84726: LD_VAR 0 16
84730: PUSH
84731: LD_VAR 0 7
84735: ARRAY
84736: PUSH
84737: LD_INT 1
84739: ARRAY
84740: PUSH
84741: LD_INT 2
84743: ARRAY
84744: PPUSH
84745: CALL_OW 114
// end else
84749: GO 84802
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
84751: LD_ADDR_VAR 0 15
84755: PUSH
84756: LD_VAR 0 16
84760: PUSH
84761: LD_VAR 0 7
84765: ARRAY
84766: PPUSH
84767: LD_INT 1
84769: PPUSH
84770: CALL_OW 3
84774: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
84775: LD_ADDR_VAR 0 16
84779: PUSH
84780: LD_VAR 0 16
84784: PPUSH
84785: LD_VAR 0 7
84789: PPUSH
84790: LD_VAR 0 15
84794: PPUSH
84795: CALL_OW 1
84799: ST_TO_ADDR
// continue ;
84800: GO 83345
// end ; end ; end else
84802: GO 87466
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
84804: LD_ADDR_VAR 0 14
84808: PUSH
84809: LD_INT 81
84811: PUSH
84812: LD_VAR 0 4
84816: PUSH
84817: LD_VAR 0 7
84821: ARRAY
84822: PPUSH
84823: CALL_OW 255
84827: PUSH
84828: EMPTY
84829: LIST
84830: LIST
84831: PPUSH
84832: CALL_OW 69
84836: ST_TO_ADDR
// if not tmp then
84837: LD_VAR 0 14
84841: NOT
84842: IFFALSE 84846
// continue ;
84844: GO 83345
// if f_ignore_area then
84846: LD_VAR 0 17
84850: IFFALSE 84938
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
84852: LD_ADDR_VAR 0 15
84856: PUSH
84857: LD_VAR 0 14
84861: PPUSH
84862: LD_INT 3
84864: PUSH
84865: LD_INT 92
84867: PUSH
84868: LD_VAR 0 17
84872: PUSH
84873: LD_INT 1
84875: ARRAY
84876: PUSH
84877: LD_VAR 0 17
84881: PUSH
84882: LD_INT 2
84884: ARRAY
84885: PUSH
84886: LD_VAR 0 17
84890: PUSH
84891: LD_INT 3
84893: ARRAY
84894: PUSH
84895: EMPTY
84896: LIST
84897: LIST
84898: LIST
84899: LIST
84900: PUSH
84901: EMPTY
84902: LIST
84903: LIST
84904: PPUSH
84905: CALL_OW 72
84909: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
84910: LD_VAR 0 14
84914: PUSH
84915: LD_VAR 0 15
84919: DIFF
84920: IFFALSE 84938
// tmp := tmp diff tmp2 ;
84922: LD_ADDR_VAR 0 14
84926: PUSH
84927: LD_VAR 0 14
84931: PUSH
84932: LD_VAR 0 15
84936: DIFF
84937: ST_TO_ADDR
// end ; if not f_murder then
84938: LD_VAR 0 20
84942: NOT
84943: IFFALSE 85001
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
84945: LD_ADDR_VAR 0 15
84949: PUSH
84950: LD_VAR 0 14
84954: PPUSH
84955: LD_INT 3
84957: PUSH
84958: LD_INT 50
84960: PUSH
84961: EMPTY
84962: LIST
84963: PUSH
84964: EMPTY
84965: LIST
84966: LIST
84967: PPUSH
84968: CALL_OW 72
84972: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
84973: LD_VAR 0 14
84977: PUSH
84978: LD_VAR 0 15
84982: DIFF
84983: IFFALSE 85001
// tmp := tmp diff tmp2 ;
84985: LD_ADDR_VAR 0 14
84989: PUSH
84990: LD_VAR 0 14
84994: PUSH
84995: LD_VAR 0 15
84999: DIFF
85000: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
85001: LD_ADDR_VAR 0 14
85005: PUSH
85006: LD_VAR 0 4
85010: PUSH
85011: LD_VAR 0 7
85015: ARRAY
85016: PPUSH
85017: LD_VAR 0 14
85021: PPUSH
85022: LD_INT 1
85024: PPUSH
85025: LD_INT 1
85027: PPUSH
85028: CALL 16591 0 4
85032: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
85033: LD_VAR 0 4
85037: PUSH
85038: LD_VAR 0 7
85042: ARRAY
85043: PPUSH
85044: CALL_OW 257
85048: PUSH
85049: LD_INT 1
85051: EQUAL
85052: IFFALSE 85500
// begin if WantPlant ( group [ i ] ) then
85054: LD_VAR 0 4
85058: PUSH
85059: LD_VAR 0 7
85063: ARRAY
85064: PPUSH
85065: CALL 16092 0 1
85069: IFFALSE 85073
// continue ;
85071: GO 83345
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
85073: LD_VAR 0 18
85077: PUSH
85078: LD_VAR 0 4
85082: PUSH
85083: LD_VAR 0 7
85087: ARRAY
85088: PPUSH
85089: CALL_OW 310
85093: NOT
85094: AND
85095: PUSH
85096: LD_VAR 0 14
85100: PUSH
85101: LD_INT 1
85103: ARRAY
85104: PUSH
85105: LD_VAR 0 14
85109: PPUSH
85110: LD_INT 21
85112: PUSH
85113: LD_INT 2
85115: PUSH
85116: EMPTY
85117: LIST
85118: LIST
85119: PUSH
85120: LD_INT 58
85122: PUSH
85123: EMPTY
85124: LIST
85125: PUSH
85126: EMPTY
85127: LIST
85128: LIST
85129: PPUSH
85130: CALL_OW 72
85134: IN
85135: AND
85136: IFFALSE 85172
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
85138: LD_VAR 0 4
85142: PUSH
85143: LD_VAR 0 7
85147: ARRAY
85148: PPUSH
85149: LD_VAR 0 14
85153: PUSH
85154: LD_INT 1
85156: ARRAY
85157: PPUSH
85158: CALL_OW 120
// attacking := true ;
85162: LD_ADDR_VAR 0 29
85166: PUSH
85167: LD_INT 1
85169: ST_TO_ADDR
// continue ;
85170: GO 83345
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
85172: LD_VAR 0 26
85176: PUSH
85177: LD_VAR 0 4
85181: PUSH
85182: LD_VAR 0 7
85186: ARRAY
85187: PPUSH
85188: CALL_OW 257
85192: PUSH
85193: LD_INT 1
85195: EQUAL
85196: AND
85197: PUSH
85198: LD_VAR 0 4
85202: PUSH
85203: LD_VAR 0 7
85207: ARRAY
85208: PPUSH
85209: CALL_OW 256
85213: PUSH
85214: LD_INT 800
85216: LESS
85217: AND
85218: PUSH
85219: LD_VAR 0 4
85223: PUSH
85224: LD_VAR 0 7
85228: ARRAY
85229: PPUSH
85230: CALL_OW 318
85234: NOT
85235: AND
85236: IFFALSE 85253
// ComCrawl ( group [ i ] ) ;
85238: LD_VAR 0 4
85242: PUSH
85243: LD_VAR 0 7
85247: ARRAY
85248: PPUSH
85249: CALL_OW 137
// if f_mines then
85253: LD_VAR 0 21
85257: IFFALSE 85500
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
85259: LD_VAR 0 14
85263: PUSH
85264: LD_INT 1
85266: ARRAY
85267: PPUSH
85268: CALL_OW 247
85272: PUSH
85273: LD_INT 3
85275: EQUAL
85276: PUSH
85277: LD_VAR 0 14
85281: PUSH
85282: LD_INT 1
85284: ARRAY
85285: PUSH
85286: LD_VAR 0 27
85290: IN
85291: NOT
85292: AND
85293: IFFALSE 85500
// begin x := GetX ( tmp [ 1 ] ) ;
85295: LD_ADDR_VAR 0 10
85299: PUSH
85300: LD_VAR 0 14
85304: PUSH
85305: LD_INT 1
85307: ARRAY
85308: PPUSH
85309: CALL_OW 250
85313: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
85314: LD_ADDR_VAR 0 11
85318: PUSH
85319: LD_VAR 0 14
85323: PUSH
85324: LD_INT 1
85326: ARRAY
85327: PPUSH
85328: CALL_OW 251
85332: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
85333: LD_ADDR_VAR 0 12
85337: PUSH
85338: LD_VAR 0 4
85342: PUSH
85343: LD_VAR 0 7
85347: ARRAY
85348: PPUSH
85349: CALL 43735 0 1
85353: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
85354: LD_VAR 0 4
85358: PUSH
85359: LD_VAR 0 7
85363: ARRAY
85364: PPUSH
85365: LD_VAR 0 10
85369: PPUSH
85370: LD_VAR 0 11
85374: PPUSH
85375: LD_VAR 0 14
85379: PUSH
85380: LD_INT 1
85382: ARRAY
85383: PPUSH
85384: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
85388: LD_VAR 0 4
85392: PUSH
85393: LD_VAR 0 7
85397: ARRAY
85398: PPUSH
85399: LD_VAR 0 10
85403: PPUSH
85404: LD_VAR 0 12
85408: PPUSH
85409: LD_INT 7
85411: PPUSH
85412: CALL_OW 272
85416: PPUSH
85417: LD_VAR 0 11
85421: PPUSH
85422: LD_VAR 0 12
85426: PPUSH
85427: LD_INT 7
85429: PPUSH
85430: CALL_OW 273
85434: PPUSH
85435: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
85439: LD_VAR 0 4
85443: PUSH
85444: LD_VAR 0 7
85448: ARRAY
85449: PPUSH
85450: LD_INT 71
85452: PPUSH
85453: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
85457: LD_ADDR_VAR 0 27
85461: PUSH
85462: LD_VAR 0 27
85466: PPUSH
85467: LD_VAR 0 27
85471: PUSH
85472: LD_INT 1
85474: PLUS
85475: PPUSH
85476: LD_VAR 0 14
85480: PUSH
85481: LD_INT 1
85483: ARRAY
85484: PPUSH
85485: CALL_OW 1
85489: ST_TO_ADDR
// attacking := true ;
85490: LD_ADDR_VAR 0 29
85494: PUSH
85495: LD_INT 1
85497: ST_TO_ADDR
// continue ;
85498: GO 83345
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
85500: LD_VAR 0 4
85504: PUSH
85505: LD_VAR 0 7
85509: ARRAY
85510: PPUSH
85511: CALL_OW 257
85515: PUSH
85516: LD_INT 17
85518: EQUAL
85519: PUSH
85520: LD_VAR 0 4
85524: PUSH
85525: LD_VAR 0 7
85529: ARRAY
85530: PPUSH
85531: CALL_OW 110
85535: PUSH
85536: LD_INT 71
85538: EQUAL
85539: NOT
85540: AND
85541: IFFALSE 85687
// begin attacking := false ;
85543: LD_ADDR_VAR 0 29
85547: PUSH
85548: LD_INT 0
85550: ST_TO_ADDR
// k := 5 ;
85551: LD_ADDR_VAR 0 9
85555: PUSH
85556: LD_INT 5
85558: ST_TO_ADDR
// if tmp < k then
85559: LD_VAR 0 14
85563: PUSH
85564: LD_VAR 0 9
85568: LESS
85569: IFFALSE 85581
// k := tmp ;
85571: LD_ADDR_VAR 0 9
85575: PUSH
85576: LD_VAR 0 14
85580: ST_TO_ADDR
// for j = 1 to k do
85581: LD_ADDR_VAR 0 8
85585: PUSH
85586: DOUBLE
85587: LD_INT 1
85589: DEC
85590: ST_TO_ADDR
85591: LD_VAR 0 9
85595: PUSH
85596: FOR_TO
85597: IFFALSE 85685
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
85599: LD_VAR 0 14
85603: PUSH
85604: LD_VAR 0 8
85608: ARRAY
85609: PUSH
85610: LD_VAR 0 14
85614: PPUSH
85615: LD_INT 58
85617: PUSH
85618: EMPTY
85619: LIST
85620: PPUSH
85621: CALL_OW 72
85625: IN
85626: NOT
85627: IFFALSE 85683
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
85629: LD_VAR 0 4
85633: PUSH
85634: LD_VAR 0 7
85638: ARRAY
85639: PPUSH
85640: LD_VAR 0 14
85644: PUSH
85645: LD_VAR 0 8
85649: ARRAY
85650: PPUSH
85651: CALL_OW 115
// attacking := true ;
85655: LD_ADDR_VAR 0 29
85659: PUSH
85660: LD_INT 1
85662: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
85663: LD_VAR 0 4
85667: PUSH
85668: LD_VAR 0 7
85672: ARRAY
85673: PPUSH
85674: LD_INT 71
85676: PPUSH
85677: CALL_OW 109
// continue ;
85681: GO 85596
// end ; end ;
85683: GO 85596
85685: POP
85686: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
85687: LD_VAR 0 4
85691: PUSH
85692: LD_VAR 0 7
85696: ARRAY
85697: PPUSH
85698: CALL_OW 257
85702: PUSH
85703: LD_INT 8
85705: EQUAL
85706: PUSH
85707: LD_VAR 0 4
85711: PUSH
85712: LD_VAR 0 7
85716: ARRAY
85717: PPUSH
85718: CALL_OW 264
85722: PUSH
85723: LD_INT 28
85725: PUSH
85726: LD_INT 45
85728: PUSH
85729: LD_INT 7
85731: PUSH
85732: LD_INT 47
85734: PUSH
85735: EMPTY
85736: LIST
85737: LIST
85738: LIST
85739: LIST
85740: IN
85741: OR
85742: IFFALSE 85998
// begin attacking := false ;
85744: LD_ADDR_VAR 0 29
85748: PUSH
85749: LD_INT 0
85751: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
85752: LD_VAR 0 14
85756: PUSH
85757: LD_INT 1
85759: ARRAY
85760: PPUSH
85761: CALL_OW 266
85765: PUSH
85766: LD_INT 32
85768: PUSH
85769: LD_INT 31
85771: PUSH
85772: LD_INT 33
85774: PUSH
85775: LD_INT 4
85777: PUSH
85778: LD_INT 5
85780: PUSH
85781: EMPTY
85782: LIST
85783: LIST
85784: LIST
85785: LIST
85786: LIST
85787: IN
85788: IFFALSE 85974
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
85790: LD_ADDR_VAR 0 9
85794: PUSH
85795: LD_VAR 0 14
85799: PUSH
85800: LD_INT 1
85802: ARRAY
85803: PPUSH
85804: CALL_OW 266
85808: PPUSH
85809: LD_VAR 0 14
85813: PUSH
85814: LD_INT 1
85816: ARRAY
85817: PPUSH
85818: CALL_OW 250
85822: PPUSH
85823: LD_VAR 0 14
85827: PUSH
85828: LD_INT 1
85830: ARRAY
85831: PPUSH
85832: CALL_OW 251
85836: PPUSH
85837: LD_VAR 0 14
85841: PUSH
85842: LD_INT 1
85844: ARRAY
85845: PPUSH
85846: CALL_OW 254
85850: PPUSH
85851: LD_VAR 0 14
85855: PUSH
85856: LD_INT 1
85858: ARRAY
85859: PPUSH
85860: CALL_OW 248
85864: PPUSH
85865: LD_INT 0
85867: PPUSH
85868: CALL 25105 0 6
85872: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
85873: LD_ADDR_VAR 0 8
85877: PUSH
85878: LD_VAR 0 4
85882: PUSH
85883: LD_VAR 0 7
85887: ARRAY
85888: PPUSH
85889: LD_VAR 0 9
85893: PPUSH
85894: CALL 43775 0 2
85898: ST_TO_ADDR
// if j then
85899: LD_VAR 0 8
85903: IFFALSE 85972
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
85905: LD_VAR 0 8
85909: PUSH
85910: LD_INT 1
85912: ARRAY
85913: PPUSH
85914: LD_VAR 0 8
85918: PUSH
85919: LD_INT 2
85921: ARRAY
85922: PPUSH
85923: CALL_OW 488
85927: IFFALSE 85972
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
85929: LD_VAR 0 4
85933: PUSH
85934: LD_VAR 0 7
85938: ARRAY
85939: PPUSH
85940: LD_VAR 0 8
85944: PUSH
85945: LD_INT 1
85947: ARRAY
85948: PPUSH
85949: LD_VAR 0 8
85953: PUSH
85954: LD_INT 2
85956: ARRAY
85957: PPUSH
85958: CALL_OW 116
// attacking := true ;
85962: LD_ADDR_VAR 0 29
85966: PUSH
85967: LD_INT 1
85969: ST_TO_ADDR
// continue ;
85970: GO 83345
// end ; end else
85972: GO 85998
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85974: LD_VAR 0 4
85978: PUSH
85979: LD_VAR 0 7
85983: ARRAY
85984: PPUSH
85985: LD_VAR 0 14
85989: PUSH
85990: LD_INT 1
85992: ARRAY
85993: PPUSH
85994: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
85998: LD_VAR 0 4
86002: PUSH
86003: LD_VAR 0 7
86007: ARRAY
86008: PPUSH
86009: CALL_OW 265
86013: PUSH
86014: LD_INT 11
86016: EQUAL
86017: IFFALSE 86295
// begin k := 10 ;
86019: LD_ADDR_VAR 0 9
86023: PUSH
86024: LD_INT 10
86026: ST_TO_ADDR
// x := 0 ;
86027: LD_ADDR_VAR 0 10
86031: PUSH
86032: LD_INT 0
86034: ST_TO_ADDR
// if tmp < k then
86035: LD_VAR 0 14
86039: PUSH
86040: LD_VAR 0 9
86044: LESS
86045: IFFALSE 86057
// k := tmp ;
86047: LD_ADDR_VAR 0 9
86051: PUSH
86052: LD_VAR 0 14
86056: ST_TO_ADDR
// for j = k downto 1 do
86057: LD_ADDR_VAR 0 8
86061: PUSH
86062: DOUBLE
86063: LD_VAR 0 9
86067: INC
86068: ST_TO_ADDR
86069: LD_INT 1
86071: PUSH
86072: FOR_DOWNTO
86073: IFFALSE 86148
// begin if GetType ( tmp [ j ] ) = unit_human then
86075: LD_VAR 0 14
86079: PUSH
86080: LD_VAR 0 8
86084: ARRAY
86085: PPUSH
86086: CALL_OW 247
86090: PUSH
86091: LD_INT 1
86093: EQUAL
86094: IFFALSE 86146
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
86096: LD_VAR 0 4
86100: PUSH
86101: LD_VAR 0 7
86105: ARRAY
86106: PPUSH
86107: LD_VAR 0 14
86111: PUSH
86112: LD_VAR 0 8
86116: ARRAY
86117: PPUSH
86118: CALL 44029 0 2
// x := tmp [ j ] ;
86122: LD_ADDR_VAR 0 10
86126: PUSH
86127: LD_VAR 0 14
86131: PUSH
86132: LD_VAR 0 8
86136: ARRAY
86137: ST_TO_ADDR
// attacking := true ;
86138: LD_ADDR_VAR 0 29
86142: PUSH
86143: LD_INT 1
86145: ST_TO_ADDR
// end ; end ;
86146: GO 86072
86148: POP
86149: POP
// if not x then
86150: LD_VAR 0 10
86154: NOT
86155: IFFALSE 86295
// begin attacking := true ;
86157: LD_ADDR_VAR 0 29
86161: PUSH
86162: LD_INT 1
86164: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
86165: LD_VAR 0 4
86169: PUSH
86170: LD_VAR 0 7
86174: ARRAY
86175: PPUSH
86176: CALL_OW 250
86180: PPUSH
86181: LD_VAR 0 4
86185: PUSH
86186: LD_VAR 0 7
86190: ARRAY
86191: PPUSH
86192: CALL_OW 251
86196: PPUSH
86197: CALL_OW 546
86201: PUSH
86202: LD_INT 2
86204: ARRAY
86205: PUSH
86206: LD_VAR 0 14
86210: PUSH
86211: LD_INT 1
86213: ARRAY
86214: PPUSH
86215: CALL_OW 250
86219: PPUSH
86220: LD_VAR 0 14
86224: PUSH
86225: LD_INT 1
86227: ARRAY
86228: PPUSH
86229: CALL_OW 251
86233: PPUSH
86234: CALL_OW 546
86238: PUSH
86239: LD_INT 2
86241: ARRAY
86242: EQUAL
86243: IFFALSE 86271
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
86245: LD_VAR 0 4
86249: PUSH
86250: LD_VAR 0 7
86254: ARRAY
86255: PPUSH
86256: LD_VAR 0 14
86260: PUSH
86261: LD_INT 1
86263: ARRAY
86264: PPUSH
86265: CALL 44029 0 2
86269: GO 86295
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86271: LD_VAR 0 4
86275: PUSH
86276: LD_VAR 0 7
86280: ARRAY
86281: PPUSH
86282: LD_VAR 0 14
86286: PUSH
86287: LD_INT 1
86289: ARRAY
86290: PPUSH
86291: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
86295: LD_VAR 0 4
86299: PUSH
86300: LD_VAR 0 7
86304: ARRAY
86305: PPUSH
86306: CALL_OW 264
86310: PUSH
86311: LD_INT 29
86313: EQUAL
86314: IFFALSE 86680
// begin if WantsToAttack ( group [ i ] ) in bombed then
86316: LD_VAR 0 4
86320: PUSH
86321: LD_VAR 0 7
86325: ARRAY
86326: PPUSH
86327: CALL_OW 319
86331: PUSH
86332: LD_VAR 0 28
86336: IN
86337: IFFALSE 86341
// continue ;
86339: GO 83345
// k := 8 ;
86341: LD_ADDR_VAR 0 9
86345: PUSH
86346: LD_INT 8
86348: ST_TO_ADDR
// x := 0 ;
86349: LD_ADDR_VAR 0 10
86353: PUSH
86354: LD_INT 0
86356: ST_TO_ADDR
// if tmp < k then
86357: LD_VAR 0 14
86361: PUSH
86362: LD_VAR 0 9
86366: LESS
86367: IFFALSE 86379
// k := tmp ;
86369: LD_ADDR_VAR 0 9
86373: PUSH
86374: LD_VAR 0 14
86378: ST_TO_ADDR
// for j = 1 to k do
86379: LD_ADDR_VAR 0 8
86383: PUSH
86384: DOUBLE
86385: LD_INT 1
86387: DEC
86388: ST_TO_ADDR
86389: LD_VAR 0 9
86393: PUSH
86394: FOR_TO
86395: IFFALSE 86527
// begin if GetType ( tmp [ j ] ) = unit_building then
86397: LD_VAR 0 14
86401: PUSH
86402: LD_VAR 0 8
86406: ARRAY
86407: PPUSH
86408: CALL_OW 247
86412: PUSH
86413: LD_INT 3
86415: EQUAL
86416: IFFALSE 86525
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
86418: LD_VAR 0 14
86422: PUSH
86423: LD_VAR 0 8
86427: ARRAY
86428: PUSH
86429: LD_VAR 0 28
86433: IN
86434: NOT
86435: PUSH
86436: LD_VAR 0 14
86440: PUSH
86441: LD_VAR 0 8
86445: ARRAY
86446: PPUSH
86447: CALL_OW 313
86451: AND
86452: IFFALSE 86525
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
86454: LD_VAR 0 4
86458: PUSH
86459: LD_VAR 0 7
86463: ARRAY
86464: PPUSH
86465: LD_VAR 0 14
86469: PUSH
86470: LD_VAR 0 8
86474: ARRAY
86475: PPUSH
86476: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
86480: LD_ADDR_VAR 0 28
86484: PUSH
86485: LD_VAR 0 28
86489: PPUSH
86490: LD_VAR 0 28
86494: PUSH
86495: LD_INT 1
86497: PLUS
86498: PPUSH
86499: LD_VAR 0 14
86503: PUSH
86504: LD_VAR 0 8
86508: ARRAY
86509: PPUSH
86510: CALL_OW 1
86514: ST_TO_ADDR
// attacking := true ;
86515: LD_ADDR_VAR 0 29
86519: PUSH
86520: LD_INT 1
86522: ST_TO_ADDR
// break ;
86523: GO 86527
// end ; end ;
86525: GO 86394
86527: POP
86528: POP
// if not attacking and f_attack_depot then
86529: LD_VAR 0 29
86533: NOT
86534: PUSH
86535: LD_VAR 0 25
86539: AND
86540: IFFALSE 86635
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
86542: LD_ADDR_VAR 0 13
86546: PUSH
86547: LD_VAR 0 14
86551: PPUSH
86552: LD_INT 2
86554: PUSH
86555: LD_INT 30
86557: PUSH
86558: LD_INT 0
86560: PUSH
86561: EMPTY
86562: LIST
86563: LIST
86564: PUSH
86565: LD_INT 30
86567: PUSH
86568: LD_INT 1
86570: PUSH
86571: EMPTY
86572: LIST
86573: LIST
86574: PUSH
86575: EMPTY
86576: LIST
86577: LIST
86578: LIST
86579: PPUSH
86580: CALL_OW 72
86584: ST_TO_ADDR
// if z then
86585: LD_VAR 0 13
86589: IFFALSE 86635
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
86591: LD_VAR 0 4
86595: PUSH
86596: LD_VAR 0 7
86600: ARRAY
86601: PPUSH
86602: LD_VAR 0 13
86606: PPUSH
86607: LD_VAR 0 4
86611: PUSH
86612: LD_VAR 0 7
86616: ARRAY
86617: PPUSH
86618: CALL_OW 74
86622: PPUSH
86623: CALL_OW 115
// attacking := true ;
86627: LD_ADDR_VAR 0 29
86631: PUSH
86632: LD_INT 1
86634: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
86635: LD_VAR 0 4
86639: PUSH
86640: LD_VAR 0 7
86644: ARRAY
86645: PPUSH
86646: CALL_OW 256
86650: PUSH
86651: LD_INT 500
86653: LESS
86654: IFFALSE 86680
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86656: LD_VAR 0 4
86660: PUSH
86661: LD_VAR 0 7
86665: ARRAY
86666: PPUSH
86667: LD_VAR 0 14
86671: PUSH
86672: LD_INT 1
86674: ARRAY
86675: PPUSH
86676: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
86680: LD_VAR 0 4
86684: PUSH
86685: LD_VAR 0 7
86689: ARRAY
86690: PPUSH
86691: CALL_OW 264
86695: PUSH
86696: LD_INT 49
86698: EQUAL
86699: IFFALSE 86820
// begin if not HasTask ( group [ i ] ) then
86701: LD_VAR 0 4
86705: PUSH
86706: LD_VAR 0 7
86710: ARRAY
86711: PPUSH
86712: CALL_OW 314
86716: NOT
86717: IFFALSE 86820
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
86719: LD_ADDR_VAR 0 9
86723: PUSH
86724: LD_INT 81
86726: PUSH
86727: LD_VAR 0 4
86731: PUSH
86732: LD_VAR 0 7
86736: ARRAY
86737: PPUSH
86738: CALL_OW 255
86742: PUSH
86743: EMPTY
86744: LIST
86745: LIST
86746: PPUSH
86747: CALL_OW 69
86751: PPUSH
86752: LD_VAR 0 4
86756: PUSH
86757: LD_VAR 0 7
86761: ARRAY
86762: PPUSH
86763: CALL_OW 74
86767: ST_TO_ADDR
// if k then
86768: LD_VAR 0 9
86772: IFFALSE 86820
// if GetDistUnits ( group [ i ] , k ) > 10 then
86774: LD_VAR 0 4
86778: PUSH
86779: LD_VAR 0 7
86783: ARRAY
86784: PPUSH
86785: LD_VAR 0 9
86789: PPUSH
86790: CALL_OW 296
86794: PUSH
86795: LD_INT 10
86797: GREATER
86798: IFFALSE 86820
// ComMoveUnit ( group [ i ] , k ) ;
86800: LD_VAR 0 4
86804: PUSH
86805: LD_VAR 0 7
86809: ARRAY
86810: PPUSH
86811: LD_VAR 0 9
86815: PPUSH
86816: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
86820: LD_VAR 0 4
86824: PUSH
86825: LD_VAR 0 7
86829: ARRAY
86830: PPUSH
86831: CALL_OW 256
86835: PUSH
86836: LD_INT 250
86838: LESS
86839: PUSH
86840: LD_VAR 0 4
86844: PUSH
86845: LD_VAR 0 7
86849: ARRAY
86850: PUSH
86851: LD_INT 21
86853: PUSH
86854: LD_INT 2
86856: PUSH
86857: EMPTY
86858: LIST
86859: LIST
86860: PUSH
86861: LD_INT 23
86863: PUSH
86864: LD_INT 2
86866: PUSH
86867: EMPTY
86868: LIST
86869: LIST
86870: PUSH
86871: EMPTY
86872: LIST
86873: LIST
86874: PPUSH
86875: CALL_OW 69
86879: IN
86880: AND
86881: IFFALSE 87006
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
86883: LD_ADDR_VAR 0 9
86887: PUSH
86888: LD_OWVAR 3
86892: PUSH
86893: LD_VAR 0 4
86897: PUSH
86898: LD_VAR 0 7
86902: ARRAY
86903: DIFF
86904: PPUSH
86905: LD_VAR 0 4
86909: PUSH
86910: LD_VAR 0 7
86914: ARRAY
86915: PPUSH
86916: CALL_OW 74
86920: ST_TO_ADDR
// if not k then
86921: LD_VAR 0 9
86925: NOT
86926: IFFALSE 86930
// continue ;
86928: GO 83345
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
86930: LD_VAR 0 9
86934: PUSH
86935: LD_INT 81
86937: PUSH
86938: LD_VAR 0 4
86942: PUSH
86943: LD_VAR 0 7
86947: ARRAY
86948: PPUSH
86949: CALL_OW 255
86953: PUSH
86954: EMPTY
86955: LIST
86956: LIST
86957: PPUSH
86958: CALL_OW 69
86962: IN
86963: PUSH
86964: LD_VAR 0 9
86968: PPUSH
86969: LD_VAR 0 4
86973: PUSH
86974: LD_VAR 0 7
86978: ARRAY
86979: PPUSH
86980: CALL_OW 296
86984: PUSH
86985: LD_INT 5
86987: LESS
86988: AND
86989: IFFALSE 87006
// ComAutodestruct ( group [ i ] ) ;
86991: LD_VAR 0 4
86995: PUSH
86996: LD_VAR 0 7
87000: ARRAY
87001: PPUSH
87002: CALL 43927 0 1
// end ; if f_attack_depot then
87006: LD_VAR 0 25
87010: IFFALSE 87122
// begin k := 6 ;
87012: LD_ADDR_VAR 0 9
87016: PUSH
87017: LD_INT 6
87019: ST_TO_ADDR
// if tmp < k then
87020: LD_VAR 0 14
87024: PUSH
87025: LD_VAR 0 9
87029: LESS
87030: IFFALSE 87042
// k := tmp ;
87032: LD_ADDR_VAR 0 9
87036: PUSH
87037: LD_VAR 0 14
87041: ST_TO_ADDR
// for j = 1 to k do
87042: LD_ADDR_VAR 0 8
87046: PUSH
87047: DOUBLE
87048: LD_INT 1
87050: DEC
87051: ST_TO_ADDR
87052: LD_VAR 0 9
87056: PUSH
87057: FOR_TO
87058: IFFALSE 87120
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
87060: LD_VAR 0 8
87064: PPUSH
87065: CALL_OW 266
87069: PUSH
87070: LD_INT 0
87072: PUSH
87073: LD_INT 1
87075: PUSH
87076: EMPTY
87077: LIST
87078: LIST
87079: IN
87080: IFFALSE 87118
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
87082: LD_VAR 0 4
87086: PUSH
87087: LD_VAR 0 7
87091: ARRAY
87092: PPUSH
87093: LD_VAR 0 14
87097: PUSH
87098: LD_VAR 0 8
87102: ARRAY
87103: PPUSH
87104: CALL_OW 115
// attacking := true ;
87108: LD_ADDR_VAR 0 29
87112: PUSH
87113: LD_INT 1
87115: ST_TO_ADDR
// break ;
87116: GO 87120
// end ;
87118: GO 87057
87120: POP
87121: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
87122: LD_VAR 0 4
87126: PUSH
87127: LD_VAR 0 7
87131: ARRAY
87132: PPUSH
87133: CALL_OW 302
87137: PUSH
87138: LD_VAR 0 29
87142: NOT
87143: AND
87144: IFFALSE 87466
// begin if GetTag ( group [ i ] ) = 71 then
87146: LD_VAR 0 4
87150: PUSH
87151: LD_VAR 0 7
87155: ARRAY
87156: PPUSH
87157: CALL_OW 110
87161: PUSH
87162: LD_INT 71
87164: EQUAL
87165: IFFALSE 87206
// begin if HasTask ( group [ i ] ) then
87167: LD_VAR 0 4
87171: PUSH
87172: LD_VAR 0 7
87176: ARRAY
87177: PPUSH
87178: CALL_OW 314
87182: IFFALSE 87188
// continue else
87184: GO 83345
87186: GO 87206
// SetTag ( group [ i ] , 0 ) ;
87188: LD_VAR 0 4
87192: PUSH
87193: LD_VAR 0 7
87197: ARRAY
87198: PPUSH
87199: LD_INT 0
87201: PPUSH
87202: CALL_OW 109
// end ; k := 8 ;
87206: LD_ADDR_VAR 0 9
87210: PUSH
87211: LD_INT 8
87213: ST_TO_ADDR
// x := 0 ;
87214: LD_ADDR_VAR 0 10
87218: PUSH
87219: LD_INT 0
87221: ST_TO_ADDR
// if tmp < k then
87222: LD_VAR 0 14
87226: PUSH
87227: LD_VAR 0 9
87231: LESS
87232: IFFALSE 87244
// k := tmp ;
87234: LD_ADDR_VAR 0 9
87238: PUSH
87239: LD_VAR 0 14
87243: ST_TO_ADDR
// for j = 1 to k do
87244: LD_ADDR_VAR 0 8
87248: PUSH
87249: DOUBLE
87250: LD_INT 1
87252: DEC
87253: ST_TO_ADDR
87254: LD_VAR 0 9
87258: PUSH
87259: FOR_TO
87260: IFFALSE 87358
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
87262: LD_VAR 0 14
87266: PUSH
87267: LD_VAR 0 8
87271: ARRAY
87272: PPUSH
87273: CALL_OW 247
87277: PUSH
87278: LD_INT 1
87280: EQUAL
87281: PUSH
87282: LD_VAR 0 14
87286: PUSH
87287: LD_VAR 0 8
87291: ARRAY
87292: PPUSH
87293: CALL_OW 256
87297: PUSH
87298: LD_INT 250
87300: LESS
87301: PUSH
87302: LD_VAR 0 20
87306: AND
87307: PUSH
87308: LD_VAR 0 20
87312: NOT
87313: PUSH
87314: LD_VAR 0 14
87318: PUSH
87319: LD_VAR 0 8
87323: ARRAY
87324: PPUSH
87325: CALL_OW 256
87329: PUSH
87330: LD_INT 250
87332: GREATEREQUAL
87333: AND
87334: OR
87335: AND
87336: IFFALSE 87356
// begin x := tmp [ j ] ;
87338: LD_ADDR_VAR 0 10
87342: PUSH
87343: LD_VAR 0 14
87347: PUSH
87348: LD_VAR 0 8
87352: ARRAY
87353: ST_TO_ADDR
// break ;
87354: GO 87358
// end ;
87356: GO 87259
87358: POP
87359: POP
// if x then
87360: LD_VAR 0 10
87364: IFFALSE 87388
// ComAttackUnit ( group [ i ] , x ) else
87366: LD_VAR 0 4
87370: PUSH
87371: LD_VAR 0 7
87375: ARRAY
87376: PPUSH
87377: LD_VAR 0 10
87381: PPUSH
87382: CALL_OW 115
87386: GO 87412
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
87388: LD_VAR 0 4
87392: PUSH
87393: LD_VAR 0 7
87397: ARRAY
87398: PPUSH
87399: LD_VAR 0 14
87403: PUSH
87404: LD_INT 1
87406: ARRAY
87407: PPUSH
87408: CALL_OW 115
// if not HasTask ( group [ i ] ) then
87412: LD_VAR 0 4
87416: PUSH
87417: LD_VAR 0 7
87421: ARRAY
87422: PPUSH
87423: CALL_OW 314
87427: NOT
87428: IFFALSE 87466
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
87430: LD_VAR 0 4
87434: PUSH
87435: LD_VAR 0 7
87439: ARRAY
87440: PPUSH
87441: LD_VAR 0 14
87445: PPUSH
87446: LD_VAR 0 4
87450: PUSH
87451: LD_VAR 0 7
87455: ARRAY
87456: PPUSH
87457: CALL_OW 74
87461: PPUSH
87462: CALL_OW 115
// end ; end ; end ;
87466: GO 83345
87468: POP
87469: POP
// wait ( 0 0$2 ) ;
87470: LD_INT 70
87472: PPUSH
87473: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
87477: LD_VAR 0 4
87481: NOT
87482: PUSH
87483: LD_VAR 0 4
87487: PUSH
87488: EMPTY
87489: EQUAL
87490: OR
87491: PUSH
87492: LD_INT 81
87494: PUSH
87495: LD_VAR 0 35
87499: PUSH
87500: EMPTY
87501: LIST
87502: LIST
87503: PPUSH
87504: CALL_OW 69
87508: NOT
87509: OR
87510: IFFALSE 83330
// end ;
87512: LD_VAR 0 2
87516: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
87517: LD_INT 0
87519: PPUSH
87520: PPUSH
87521: PPUSH
87522: PPUSH
87523: PPUSH
87524: PPUSH
// if not base or not mc_bases [ base ] or not solds then
87525: LD_VAR 0 1
87529: NOT
87530: PUSH
87531: LD_EXP 23
87535: PUSH
87536: LD_VAR 0 1
87540: ARRAY
87541: NOT
87542: OR
87543: PUSH
87544: LD_VAR 0 2
87548: NOT
87549: OR
87550: IFFALSE 87554
// exit ;
87552: GO 88108
// side := mc_sides [ base ] ;
87554: LD_ADDR_VAR 0 6
87558: PUSH
87559: LD_EXP 49
87563: PUSH
87564: LD_VAR 0 1
87568: ARRAY
87569: ST_TO_ADDR
// if not side then
87570: LD_VAR 0 6
87574: NOT
87575: IFFALSE 87579
// exit ;
87577: GO 88108
// for i in solds do
87579: LD_ADDR_VAR 0 7
87583: PUSH
87584: LD_VAR 0 2
87588: PUSH
87589: FOR_IN
87590: IFFALSE 87651
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
87592: LD_VAR 0 7
87596: PPUSH
87597: CALL_OW 310
87601: PPUSH
87602: CALL_OW 266
87606: PUSH
87607: LD_INT 32
87609: PUSH
87610: LD_INT 31
87612: PUSH
87613: EMPTY
87614: LIST
87615: LIST
87616: IN
87617: IFFALSE 87637
// solds := solds diff i else
87619: LD_ADDR_VAR 0 2
87623: PUSH
87624: LD_VAR 0 2
87628: PUSH
87629: LD_VAR 0 7
87633: DIFF
87634: ST_TO_ADDR
87635: GO 87649
// SetTag ( i , 18 ) ;
87637: LD_VAR 0 7
87641: PPUSH
87642: LD_INT 18
87644: PPUSH
87645: CALL_OW 109
87649: GO 87589
87651: POP
87652: POP
// if not solds then
87653: LD_VAR 0 2
87657: NOT
87658: IFFALSE 87662
// exit ;
87660: GO 88108
// repeat wait ( 0 0$2 ) ;
87662: LD_INT 70
87664: PPUSH
87665: CALL_OW 67
// enemy := mc_scan [ base ] ;
87669: LD_ADDR_VAR 0 4
87673: PUSH
87674: LD_EXP 46
87678: PUSH
87679: LD_VAR 0 1
87683: ARRAY
87684: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
87685: LD_EXP 23
87689: PUSH
87690: LD_VAR 0 1
87694: ARRAY
87695: NOT
87696: PUSH
87697: LD_EXP 23
87701: PUSH
87702: LD_VAR 0 1
87706: ARRAY
87707: PUSH
87708: EMPTY
87709: EQUAL
87710: OR
87711: IFFALSE 87748
// begin for i in solds do
87713: LD_ADDR_VAR 0 7
87717: PUSH
87718: LD_VAR 0 2
87722: PUSH
87723: FOR_IN
87724: IFFALSE 87737
// ComStop ( i ) ;
87726: LD_VAR 0 7
87730: PPUSH
87731: CALL_OW 141
87735: GO 87723
87737: POP
87738: POP
// solds := [ ] ;
87739: LD_ADDR_VAR 0 2
87743: PUSH
87744: EMPTY
87745: ST_TO_ADDR
// exit ;
87746: GO 88108
// end ; for i in solds do
87748: LD_ADDR_VAR 0 7
87752: PUSH
87753: LD_VAR 0 2
87757: PUSH
87758: FOR_IN
87759: IFFALSE 88080
// begin if IsInUnit ( i ) then
87761: LD_VAR 0 7
87765: PPUSH
87766: CALL_OW 310
87770: IFFALSE 87781
// ComExitBuilding ( i ) ;
87772: LD_VAR 0 7
87776: PPUSH
87777: CALL_OW 122
// if GetLives ( i ) > 500 then
87781: LD_VAR 0 7
87785: PPUSH
87786: CALL_OW 256
87790: PUSH
87791: LD_INT 500
87793: GREATER
87794: IFFALSE 87847
// begin e := NearestUnitToUnit ( enemy , i ) ;
87796: LD_ADDR_VAR 0 5
87800: PUSH
87801: LD_VAR 0 4
87805: PPUSH
87806: LD_VAR 0 7
87810: PPUSH
87811: CALL_OW 74
87815: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
87816: LD_VAR 0 7
87820: PPUSH
87821: LD_VAR 0 5
87825: PPUSH
87826: CALL_OW 250
87830: PPUSH
87831: LD_VAR 0 5
87835: PPUSH
87836: CALL_OW 251
87840: PPUSH
87841: CALL_OW 114
// end else
87845: GO 88078
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
87847: LD_VAR 0 7
87851: PPUSH
87852: LD_EXP 23
87856: PUSH
87857: LD_VAR 0 1
87861: ARRAY
87862: PPUSH
87863: LD_INT 2
87865: PUSH
87866: LD_INT 30
87868: PUSH
87869: LD_INT 0
87871: PUSH
87872: EMPTY
87873: LIST
87874: LIST
87875: PUSH
87876: LD_INT 30
87878: PUSH
87879: LD_INT 1
87881: PUSH
87882: EMPTY
87883: LIST
87884: LIST
87885: PUSH
87886: LD_INT 30
87888: PUSH
87889: LD_INT 6
87891: PUSH
87892: EMPTY
87893: LIST
87894: LIST
87895: PUSH
87896: EMPTY
87897: LIST
87898: LIST
87899: LIST
87900: LIST
87901: PPUSH
87902: CALL_OW 72
87906: PPUSH
87907: LD_VAR 0 7
87911: PPUSH
87912: CALL_OW 74
87916: PPUSH
87917: CALL_OW 296
87921: PUSH
87922: LD_INT 10
87924: GREATER
87925: IFFALSE 88078
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
87927: LD_ADDR_VAR 0 8
87931: PUSH
87932: LD_EXP 23
87936: PUSH
87937: LD_VAR 0 1
87941: ARRAY
87942: PPUSH
87943: LD_INT 2
87945: PUSH
87946: LD_INT 30
87948: PUSH
87949: LD_INT 0
87951: PUSH
87952: EMPTY
87953: LIST
87954: LIST
87955: PUSH
87956: LD_INT 30
87958: PUSH
87959: LD_INT 1
87961: PUSH
87962: EMPTY
87963: LIST
87964: LIST
87965: PUSH
87966: LD_INT 30
87968: PUSH
87969: LD_INT 6
87971: PUSH
87972: EMPTY
87973: LIST
87974: LIST
87975: PUSH
87976: EMPTY
87977: LIST
87978: LIST
87979: LIST
87980: LIST
87981: PPUSH
87982: CALL_OW 72
87986: PPUSH
87987: LD_VAR 0 7
87991: PPUSH
87992: CALL_OW 74
87996: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
87997: LD_VAR 0 7
88001: PPUSH
88002: LD_VAR 0 8
88006: PPUSH
88007: CALL_OW 250
88011: PPUSH
88012: LD_INT 3
88014: PPUSH
88015: LD_INT 5
88017: PPUSH
88018: CALL_OW 272
88022: PPUSH
88023: LD_VAR 0 8
88027: PPUSH
88028: CALL_OW 251
88032: PPUSH
88033: LD_INT 3
88035: PPUSH
88036: LD_INT 5
88038: PPUSH
88039: CALL_OW 273
88043: PPUSH
88044: CALL_OW 111
// SetTag ( i , 0 ) ;
88048: LD_VAR 0 7
88052: PPUSH
88053: LD_INT 0
88055: PPUSH
88056: CALL_OW 109
// solds := solds diff i ;
88060: LD_ADDR_VAR 0 2
88064: PUSH
88065: LD_VAR 0 2
88069: PUSH
88070: LD_VAR 0 7
88074: DIFF
88075: ST_TO_ADDR
// continue ;
88076: GO 87758
// end ; end ;
88078: GO 87758
88080: POP
88081: POP
// until not solds or not enemy ;
88082: LD_VAR 0 2
88086: NOT
88087: PUSH
88088: LD_VAR 0 4
88092: NOT
88093: OR
88094: IFFALSE 87662
// MC_Reset ( base , 18 ) ;
88096: LD_VAR 0 1
88100: PPUSH
88101: LD_INT 18
88103: PPUSH
88104: CALL 56358 0 2
// end ;
88108: LD_VAR 0 3
88112: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
88113: LD_INT 0
88115: PPUSH
88116: PPUSH
88117: PPUSH
88118: PPUSH
88119: PPUSH
88120: PPUSH
88121: PPUSH
88122: PPUSH
88123: PPUSH
88124: PPUSH
88125: PPUSH
88126: PPUSH
88127: PPUSH
88128: PPUSH
88129: PPUSH
88130: PPUSH
88131: PPUSH
88132: PPUSH
88133: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
88134: LD_ADDR_VAR 0 12
88138: PUSH
88139: LD_EXP 23
88143: PUSH
88144: LD_VAR 0 1
88148: ARRAY
88149: PPUSH
88150: LD_INT 25
88152: PUSH
88153: LD_INT 3
88155: PUSH
88156: EMPTY
88157: LIST
88158: LIST
88159: PPUSH
88160: CALL_OW 72
88164: ST_TO_ADDR
// if mc_remote_driver [ base ] then
88165: LD_EXP 63
88169: PUSH
88170: LD_VAR 0 1
88174: ARRAY
88175: IFFALSE 88199
// mechs := mechs diff mc_remote_driver [ base ] ;
88177: LD_ADDR_VAR 0 12
88181: PUSH
88182: LD_VAR 0 12
88186: PUSH
88187: LD_EXP 63
88191: PUSH
88192: LD_VAR 0 1
88196: ARRAY
88197: DIFF
88198: ST_TO_ADDR
// for i in mechs do
88199: LD_ADDR_VAR 0 4
88203: PUSH
88204: LD_VAR 0 12
88208: PUSH
88209: FOR_IN
88210: IFFALSE 88245
// if GetTag ( i ) > 0 then
88212: LD_VAR 0 4
88216: PPUSH
88217: CALL_OW 110
88221: PUSH
88222: LD_INT 0
88224: GREATER
88225: IFFALSE 88243
// mechs := mechs diff i ;
88227: LD_ADDR_VAR 0 12
88231: PUSH
88232: LD_VAR 0 12
88236: PUSH
88237: LD_VAR 0 4
88241: DIFF
88242: ST_TO_ADDR
88243: GO 88209
88245: POP
88246: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
88247: LD_ADDR_VAR 0 8
88251: PUSH
88252: LD_EXP 23
88256: PUSH
88257: LD_VAR 0 1
88261: ARRAY
88262: PPUSH
88263: LD_INT 2
88265: PUSH
88266: LD_INT 25
88268: PUSH
88269: LD_INT 1
88271: PUSH
88272: EMPTY
88273: LIST
88274: LIST
88275: PUSH
88276: LD_INT 25
88278: PUSH
88279: LD_INT 5
88281: PUSH
88282: EMPTY
88283: LIST
88284: LIST
88285: PUSH
88286: LD_INT 25
88288: PUSH
88289: LD_INT 8
88291: PUSH
88292: EMPTY
88293: LIST
88294: LIST
88295: PUSH
88296: LD_INT 25
88298: PUSH
88299: LD_INT 9
88301: PUSH
88302: EMPTY
88303: LIST
88304: LIST
88305: PUSH
88306: EMPTY
88307: LIST
88308: LIST
88309: LIST
88310: LIST
88311: LIST
88312: PPUSH
88313: CALL_OW 72
88317: ST_TO_ADDR
// if not defenders and not solds then
88318: LD_VAR 0 2
88322: NOT
88323: PUSH
88324: LD_VAR 0 8
88328: NOT
88329: AND
88330: IFFALSE 88334
// exit ;
88332: GO 90104
// depot_under_attack := false ;
88334: LD_ADDR_VAR 0 16
88338: PUSH
88339: LD_INT 0
88341: ST_TO_ADDR
// sold_defenders := [ ] ;
88342: LD_ADDR_VAR 0 17
88346: PUSH
88347: EMPTY
88348: ST_TO_ADDR
// if mechs then
88349: LD_VAR 0 12
88353: IFFALSE 88506
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
88355: LD_ADDR_VAR 0 4
88359: PUSH
88360: LD_VAR 0 2
88364: PPUSH
88365: LD_INT 21
88367: PUSH
88368: LD_INT 2
88370: PUSH
88371: EMPTY
88372: LIST
88373: LIST
88374: PPUSH
88375: CALL_OW 72
88379: PUSH
88380: FOR_IN
88381: IFFALSE 88504
// begin if GetTag ( i ) <> 20 then
88383: LD_VAR 0 4
88387: PPUSH
88388: CALL_OW 110
88392: PUSH
88393: LD_INT 20
88395: NONEQUAL
88396: IFFALSE 88410
// SetTag ( i , 20 ) ;
88398: LD_VAR 0 4
88402: PPUSH
88403: LD_INT 20
88405: PPUSH
88406: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
88410: LD_VAR 0 4
88414: PPUSH
88415: CALL_OW 263
88419: PUSH
88420: LD_INT 1
88422: EQUAL
88423: PUSH
88424: LD_VAR 0 4
88428: PPUSH
88429: CALL_OW 311
88433: NOT
88434: AND
88435: IFFALSE 88502
// begin un := mechs [ 1 ] ;
88437: LD_ADDR_VAR 0 10
88441: PUSH
88442: LD_VAR 0 12
88446: PUSH
88447: LD_INT 1
88449: ARRAY
88450: ST_TO_ADDR
// ComExit ( un ) ;
88451: LD_VAR 0 10
88455: PPUSH
88456: CALL 48793 0 1
// AddComEnterUnit ( un , i ) ;
88460: LD_VAR 0 10
88464: PPUSH
88465: LD_VAR 0 4
88469: PPUSH
88470: CALL_OW 180
// SetTag ( un , 19 ) ;
88474: LD_VAR 0 10
88478: PPUSH
88479: LD_INT 19
88481: PPUSH
88482: CALL_OW 109
// mechs := mechs diff un ;
88486: LD_ADDR_VAR 0 12
88490: PUSH
88491: LD_VAR 0 12
88495: PUSH
88496: LD_VAR 0 10
88500: DIFF
88501: ST_TO_ADDR
// end ; end ;
88502: GO 88380
88504: POP
88505: POP
// if solds then
88506: LD_VAR 0 8
88510: IFFALSE 88569
// for i in solds do
88512: LD_ADDR_VAR 0 4
88516: PUSH
88517: LD_VAR 0 8
88521: PUSH
88522: FOR_IN
88523: IFFALSE 88567
// if not GetTag ( i ) then
88525: LD_VAR 0 4
88529: PPUSH
88530: CALL_OW 110
88534: NOT
88535: IFFALSE 88565
// begin defenders := defenders union i ;
88537: LD_ADDR_VAR 0 2
88541: PUSH
88542: LD_VAR 0 2
88546: PUSH
88547: LD_VAR 0 4
88551: UNION
88552: ST_TO_ADDR
// SetTag ( i , 18 ) ;
88553: LD_VAR 0 4
88557: PPUSH
88558: LD_INT 18
88560: PPUSH
88561: CALL_OW 109
// end ;
88565: GO 88522
88567: POP
88568: POP
// repeat wait ( 0 0$2 ) ;
88569: LD_INT 70
88571: PPUSH
88572: CALL_OW 67
// enemy := mc_scan [ base ] ;
88576: LD_ADDR_VAR 0 21
88580: PUSH
88581: LD_EXP 46
88585: PUSH
88586: LD_VAR 0 1
88590: ARRAY
88591: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
88592: LD_EXP 23
88596: PUSH
88597: LD_VAR 0 1
88601: ARRAY
88602: NOT
88603: PUSH
88604: LD_EXP 23
88608: PUSH
88609: LD_VAR 0 1
88613: ARRAY
88614: PUSH
88615: EMPTY
88616: EQUAL
88617: OR
88618: IFFALSE 88655
// begin for i in defenders do
88620: LD_ADDR_VAR 0 4
88624: PUSH
88625: LD_VAR 0 2
88629: PUSH
88630: FOR_IN
88631: IFFALSE 88644
// ComStop ( i ) ;
88633: LD_VAR 0 4
88637: PPUSH
88638: CALL_OW 141
88642: GO 88630
88644: POP
88645: POP
// defenders := [ ] ;
88646: LD_ADDR_VAR 0 2
88650: PUSH
88651: EMPTY
88652: ST_TO_ADDR
// exit ;
88653: GO 90104
// end ; for i in defenders do
88655: LD_ADDR_VAR 0 4
88659: PUSH
88660: LD_VAR 0 2
88664: PUSH
88665: FOR_IN
88666: IFFALSE 89564
// begin e := NearestUnitToUnit ( enemy , i ) ;
88668: LD_ADDR_VAR 0 13
88672: PUSH
88673: LD_VAR 0 21
88677: PPUSH
88678: LD_VAR 0 4
88682: PPUSH
88683: CALL_OW 74
88687: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
88688: LD_ADDR_VAR 0 7
88692: PUSH
88693: LD_EXP 23
88697: PUSH
88698: LD_VAR 0 1
88702: ARRAY
88703: PPUSH
88704: LD_INT 2
88706: PUSH
88707: LD_INT 30
88709: PUSH
88710: LD_INT 0
88712: PUSH
88713: EMPTY
88714: LIST
88715: LIST
88716: PUSH
88717: LD_INT 30
88719: PUSH
88720: LD_INT 1
88722: PUSH
88723: EMPTY
88724: LIST
88725: LIST
88726: PUSH
88727: EMPTY
88728: LIST
88729: LIST
88730: LIST
88731: PPUSH
88732: CALL_OW 72
88736: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
88737: LD_ADDR_VAR 0 16
88741: PUSH
88742: LD_VAR 0 7
88746: NOT
88747: PUSH
88748: LD_VAR 0 7
88752: PPUSH
88753: LD_INT 3
88755: PUSH
88756: LD_INT 24
88758: PUSH
88759: LD_INT 600
88761: PUSH
88762: EMPTY
88763: LIST
88764: LIST
88765: PUSH
88766: EMPTY
88767: LIST
88768: LIST
88769: PPUSH
88770: CALL_OW 72
88774: OR
88775: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
88776: LD_VAR 0 4
88780: PPUSH
88781: CALL_OW 247
88785: PUSH
88786: LD_INT 2
88788: DOUBLE
88789: EQUAL
88790: IFTRUE 88794
88792: GO 89190
88794: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
88795: LD_VAR 0 4
88799: PPUSH
88800: CALL_OW 256
88804: PUSH
88805: LD_INT 1000
88807: EQUAL
88808: PUSH
88809: LD_VAR 0 4
88813: PPUSH
88814: LD_VAR 0 13
88818: PPUSH
88819: CALL_OW 296
88823: PUSH
88824: LD_INT 40
88826: LESS
88827: PUSH
88828: LD_VAR 0 13
88832: PPUSH
88833: LD_EXP 48
88837: PUSH
88838: LD_VAR 0 1
88842: ARRAY
88843: PPUSH
88844: CALL_OW 308
88848: OR
88849: AND
88850: IFFALSE 88972
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
88852: LD_VAR 0 4
88856: PPUSH
88857: CALL_OW 262
88861: PUSH
88862: LD_INT 1
88864: EQUAL
88865: PUSH
88866: LD_VAR 0 4
88870: PPUSH
88871: CALL_OW 261
88875: PUSH
88876: LD_INT 30
88878: LESS
88879: AND
88880: PUSH
88881: LD_VAR 0 7
88885: AND
88886: IFFALSE 88956
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
88888: LD_VAR 0 4
88892: PPUSH
88893: LD_VAR 0 7
88897: PPUSH
88898: LD_VAR 0 4
88902: PPUSH
88903: CALL_OW 74
88907: PPUSH
88908: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
88912: LD_VAR 0 4
88916: PPUSH
88917: LD_VAR 0 7
88921: PPUSH
88922: LD_VAR 0 4
88926: PPUSH
88927: CALL_OW 74
88931: PPUSH
88932: CALL_OW 296
88936: PUSH
88937: LD_INT 6
88939: LESS
88940: IFFALSE 88954
// SetFuel ( i , 100 ) ;
88942: LD_VAR 0 4
88946: PPUSH
88947: LD_INT 100
88949: PPUSH
88950: CALL_OW 240
// end else
88954: GO 88970
// ComAttackUnit ( i , e ) ;
88956: LD_VAR 0 4
88960: PPUSH
88961: LD_VAR 0 13
88965: PPUSH
88966: CALL_OW 115
// end else
88970: GO 89073
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
88972: LD_VAR 0 13
88976: PPUSH
88977: LD_EXP 48
88981: PUSH
88982: LD_VAR 0 1
88986: ARRAY
88987: PPUSH
88988: CALL_OW 308
88992: NOT
88993: PUSH
88994: LD_VAR 0 4
88998: PPUSH
88999: LD_VAR 0 13
89003: PPUSH
89004: CALL_OW 296
89008: PUSH
89009: LD_INT 40
89011: GREATEREQUAL
89012: AND
89013: PUSH
89014: LD_VAR 0 4
89018: PPUSH
89019: CALL_OW 256
89023: PUSH
89024: LD_INT 650
89026: LESSEQUAL
89027: OR
89028: PUSH
89029: LD_VAR 0 4
89033: PPUSH
89034: LD_EXP 47
89038: PUSH
89039: LD_VAR 0 1
89043: ARRAY
89044: PPUSH
89045: CALL_OW 308
89049: NOT
89050: AND
89051: IFFALSE 89073
// ComMoveToArea ( i , mc_parking [ base ] ) ;
89053: LD_VAR 0 4
89057: PPUSH
89058: LD_EXP 47
89062: PUSH
89063: LD_VAR 0 1
89067: ARRAY
89068: PPUSH
89069: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
89073: LD_VAR 0 4
89077: PPUSH
89078: CALL_OW 256
89082: PUSH
89083: LD_INT 1000
89085: LESS
89086: PUSH
89087: LD_VAR 0 4
89091: PPUSH
89092: CALL_OW 263
89096: PUSH
89097: LD_INT 1
89099: EQUAL
89100: AND
89101: PUSH
89102: LD_VAR 0 4
89106: PPUSH
89107: CALL_OW 311
89111: AND
89112: PUSH
89113: LD_VAR 0 4
89117: PPUSH
89118: LD_EXP 47
89122: PUSH
89123: LD_VAR 0 1
89127: ARRAY
89128: PPUSH
89129: CALL_OW 308
89133: AND
89134: IFFALSE 89188
// begin mech := IsDrivenBy ( i ) ;
89136: LD_ADDR_VAR 0 9
89140: PUSH
89141: LD_VAR 0 4
89145: PPUSH
89146: CALL_OW 311
89150: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
89151: LD_VAR 0 9
89155: PPUSH
89156: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
89160: LD_VAR 0 9
89164: PPUSH
89165: LD_VAR 0 4
89169: PPUSH
89170: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
89174: LD_VAR 0 9
89178: PPUSH
89179: LD_VAR 0 4
89183: PPUSH
89184: CALL_OW 180
// end ; end ; unit_human :
89188: GO 89535
89190: LD_INT 1
89192: DOUBLE
89193: EQUAL
89194: IFTRUE 89198
89196: GO 89534
89198: POP
// begin b := IsInUnit ( i ) ;
89199: LD_ADDR_VAR 0 18
89203: PUSH
89204: LD_VAR 0 4
89208: PPUSH
89209: CALL_OW 310
89213: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
89214: LD_ADDR_VAR 0 19
89218: PUSH
89219: LD_VAR 0 18
89223: NOT
89224: PUSH
89225: LD_VAR 0 18
89229: PPUSH
89230: CALL_OW 266
89234: PUSH
89235: LD_INT 32
89237: PUSH
89238: LD_INT 31
89240: PUSH
89241: EMPTY
89242: LIST
89243: LIST
89244: IN
89245: OR
89246: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
89247: LD_VAR 0 18
89251: PPUSH
89252: CALL_OW 266
89256: PUSH
89257: LD_INT 5
89259: EQUAL
89260: PUSH
89261: LD_VAR 0 4
89265: PPUSH
89266: CALL_OW 257
89270: PUSH
89271: LD_INT 1
89273: PUSH
89274: LD_INT 2
89276: PUSH
89277: LD_INT 3
89279: PUSH
89280: LD_INT 4
89282: PUSH
89283: EMPTY
89284: LIST
89285: LIST
89286: LIST
89287: LIST
89288: IN
89289: AND
89290: IFFALSE 89327
// begin class := AllowSpecClass ( i ) ;
89292: LD_ADDR_VAR 0 20
89296: PUSH
89297: LD_VAR 0 4
89301: PPUSH
89302: CALL 12805 0 1
89306: ST_TO_ADDR
// if class then
89307: LD_VAR 0 20
89311: IFFALSE 89327
// ComChangeProfession ( i , class ) ;
89313: LD_VAR 0 4
89317: PPUSH
89318: LD_VAR 0 20
89322: PPUSH
89323: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
89327: LD_VAR 0 16
89331: PUSH
89332: LD_VAR 0 2
89336: PPUSH
89337: LD_INT 21
89339: PUSH
89340: LD_INT 2
89342: PUSH
89343: EMPTY
89344: LIST
89345: LIST
89346: PPUSH
89347: CALL_OW 72
89351: PUSH
89352: LD_INT 1
89354: LESSEQUAL
89355: OR
89356: PUSH
89357: LD_VAR 0 19
89361: AND
89362: PUSH
89363: LD_VAR 0 4
89367: PUSH
89368: LD_VAR 0 17
89372: IN
89373: NOT
89374: AND
89375: IFFALSE 89468
// begin if b then
89377: LD_VAR 0 18
89381: IFFALSE 89430
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
89383: LD_VAR 0 18
89387: PPUSH
89388: LD_VAR 0 21
89392: PPUSH
89393: LD_VAR 0 18
89397: PPUSH
89398: CALL_OW 74
89402: PPUSH
89403: CALL_OW 296
89407: PUSH
89408: LD_INT 10
89410: LESS
89411: PUSH
89412: LD_VAR 0 18
89416: PPUSH
89417: CALL_OW 461
89421: PUSH
89422: LD_INT 7
89424: NONEQUAL
89425: AND
89426: IFFALSE 89430
// continue ;
89428: GO 88665
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
89430: LD_ADDR_VAR 0 17
89434: PUSH
89435: LD_VAR 0 17
89439: PPUSH
89440: LD_VAR 0 17
89444: PUSH
89445: LD_INT 1
89447: PLUS
89448: PPUSH
89449: LD_VAR 0 4
89453: PPUSH
89454: CALL_OW 1
89458: ST_TO_ADDR
// ComExitBuilding ( i ) ;
89459: LD_VAR 0 4
89463: PPUSH
89464: CALL_OW 122
// end ; if sold_defenders then
89468: LD_VAR 0 17
89472: IFFALSE 89532
// if i in sold_defenders then
89474: LD_VAR 0 4
89478: PUSH
89479: LD_VAR 0 17
89483: IN
89484: IFFALSE 89532
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
89486: LD_VAR 0 4
89490: PPUSH
89491: CALL_OW 314
89495: NOT
89496: PUSH
89497: LD_VAR 0 4
89501: PPUSH
89502: LD_VAR 0 13
89506: PPUSH
89507: CALL_OW 296
89511: PUSH
89512: LD_INT 30
89514: LESS
89515: AND
89516: IFFALSE 89532
// ComAttackUnit ( i , e ) ;
89518: LD_VAR 0 4
89522: PPUSH
89523: LD_VAR 0 13
89527: PPUSH
89528: CALL_OW 115
// end ; end ; end ;
89532: GO 89535
89534: POP
// if IsDead ( i ) then
89535: LD_VAR 0 4
89539: PPUSH
89540: CALL_OW 301
89544: IFFALSE 89562
// defenders := defenders diff i ;
89546: LD_ADDR_VAR 0 2
89550: PUSH
89551: LD_VAR 0 2
89555: PUSH
89556: LD_VAR 0 4
89560: DIFF
89561: ST_TO_ADDR
// end ;
89562: GO 88665
89564: POP
89565: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
89566: LD_VAR 0 21
89570: NOT
89571: PUSH
89572: LD_VAR 0 2
89576: NOT
89577: OR
89578: PUSH
89579: LD_EXP 23
89583: PUSH
89584: LD_VAR 0 1
89588: ARRAY
89589: NOT
89590: OR
89591: IFFALSE 88569
// MC_Reset ( base , 18 ) ;
89593: LD_VAR 0 1
89597: PPUSH
89598: LD_INT 18
89600: PPUSH
89601: CALL 56358 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
89605: LD_ADDR_VAR 0 2
89609: PUSH
89610: LD_VAR 0 2
89614: PUSH
89615: LD_VAR 0 2
89619: PPUSH
89620: LD_INT 2
89622: PUSH
89623: LD_INT 25
89625: PUSH
89626: LD_INT 1
89628: PUSH
89629: EMPTY
89630: LIST
89631: LIST
89632: PUSH
89633: LD_INT 25
89635: PUSH
89636: LD_INT 5
89638: PUSH
89639: EMPTY
89640: LIST
89641: LIST
89642: PUSH
89643: LD_INT 25
89645: PUSH
89646: LD_INT 8
89648: PUSH
89649: EMPTY
89650: LIST
89651: LIST
89652: PUSH
89653: LD_INT 25
89655: PUSH
89656: LD_INT 9
89658: PUSH
89659: EMPTY
89660: LIST
89661: LIST
89662: PUSH
89663: EMPTY
89664: LIST
89665: LIST
89666: LIST
89667: LIST
89668: LIST
89669: PPUSH
89670: CALL_OW 72
89674: DIFF
89675: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
89676: LD_VAR 0 21
89680: NOT
89681: PUSH
89682: LD_VAR 0 2
89686: PPUSH
89687: LD_INT 21
89689: PUSH
89690: LD_INT 2
89692: PUSH
89693: EMPTY
89694: LIST
89695: LIST
89696: PPUSH
89697: CALL_OW 72
89701: AND
89702: IFFALSE 90040
// begin tmp := FilterByTag ( defenders , 19 ) ;
89704: LD_ADDR_VAR 0 11
89708: PUSH
89709: LD_VAR 0 2
89713: PPUSH
89714: LD_INT 19
89716: PPUSH
89717: CALL 45969 0 2
89721: ST_TO_ADDR
// if tmp then
89722: LD_VAR 0 11
89726: IFFALSE 89796
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
89728: LD_ADDR_VAR 0 11
89732: PUSH
89733: LD_VAR 0 11
89737: PPUSH
89738: LD_INT 25
89740: PUSH
89741: LD_INT 3
89743: PUSH
89744: EMPTY
89745: LIST
89746: LIST
89747: PPUSH
89748: CALL_OW 72
89752: ST_TO_ADDR
// if tmp then
89753: LD_VAR 0 11
89757: IFFALSE 89796
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
89759: LD_ADDR_EXP 35
89763: PUSH
89764: LD_EXP 35
89768: PPUSH
89769: LD_VAR 0 1
89773: PPUSH
89774: LD_EXP 35
89778: PUSH
89779: LD_VAR 0 1
89783: ARRAY
89784: PUSH
89785: LD_VAR 0 11
89789: UNION
89790: PPUSH
89791: CALL_OW 1
89795: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
89796: LD_VAR 0 1
89800: PPUSH
89801: LD_INT 19
89803: PPUSH
89804: CALL 56358 0 2
// repeat wait ( 0 0$1 ) ;
89808: LD_INT 35
89810: PPUSH
89811: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
89815: LD_EXP 23
89819: PUSH
89820: LD_VAR 0 1
89824: ARRAY
89825: NOT
89826: PUSH
89827: LD_EXP 23
89831: PUSH
89832: LD_VAR 0 1
89836: ARRAY
89837: PUSH
89838: EMPTY
89839: EQUAL
89840: OR
89841: IFFALSE 89878
// begin for i in defenders do
89843: LD_ADDR_VAR 0 4
89847: PUSH
89848: LD_VAR 0 2
89852: PUSH
89853: FOR_IN
89854: IFFALSE 89867
// ComStop ( i ) ;
89856: LD_VAR 0 4
89860: PPUSH
89861: CALL_OW 141
89865: GO 89853
89867: POP
89868: POP
// defenders := [ ] ;
89869: LD_ADDR_VAR 0 2
89873: PUSH
89874: EMPTY
89875: ST_TO_ADDR
// exit ;
89876: GO 90104
// end ; for i in defenders do
89878: LD_ADDR_VAR 0 4
89882: PUSH
89883: LD_VAR 0 2
89887: PUSH
89888: FOR_IN
89889: IFFALSE 89978
// begin if not IsInArea ( i , mc_parking [ base ] ) then
89891: LD_VAR 0 4
89895: PPUSH
89896: LD_EXP 47
89900: PUSH
89901: LD_VAR 0 1
89905: ARRAY
89906: PPUSH
89907: CALL_OW 308
89911: NOT
89912: IFFALSE 89936
// ComMoveToArea ( i , mc_parking [ base ] ) else
89914: LD_VAR 0 4
89918: PPUSH
89919: LD_EXP 47
89923: PUSH
89924: LD_VAR 0 1
89928: ARRAY
89929: PPUSH
89930: CALL_OW 113
89934: GO 89976
// if GetControl ( i ) = control_manual then
89936: LD_VAR 0 4
89940: PPUSH
89941: CALL_OW 263
89945: PUSH
89946: LD_INT 1
89948: EQUAL
89949: IFFALSE 89976
// if IsDrivenBy ( i ) then
89951: LD_VAR 0 4
89955: PPUSH
89956: CALL_OW 311
89960: IFFALSE 89976
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
89962: LD_VAR 0 4
89966: PPUSH
89967: CALL_OW 311
89971: PPUSH
89972: CALL_OW 121
// end ;
89976: GO 89888
89978: POP
89979: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
89980: LD_VAR 0 2
89984: PPUSH
89985: LD_INT 95
89987: PUSH
89988: LD_EXP 47
89992: PUSH
89993: LD_VAR 0 1
89997: ARRAY
89998: PUSH
89999: EMPTY
90000: LIST
90001: LIST
90002: PPUSH
90003: CALL_OW 72
90007: PUSH
90008: LD_VAR 0 2
90012: EQUAL
90013: PUSH
90014: LD_EXP 46
90018: PUSH
90019: LD_VAR 0 1
90023: ARRAY
90024: OR
90025: PUSH
90026: LD_EXP 23
90030: PUSH
90031: LD_VAR 0 1
90035: ARRAY
90036: NOT
90037: OR
90038: IFFALSE 89808
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
90040: LD_ADDR_EXP 45
90044: PUSH
90045: LD_EXP 45
90049: PPUSH
90050: LD_VAR 0 1
90054: PPUSH
90055: LD_VAR 0 2
90059: PPUSH
90060: LD_INT 21
90062: PUSH
90063: LD_INT 2
90065: PUSH
90066: EMPTY
90067: LIST
90068: LIST
90069: PPUSH
90070: CALL_OW 72
90074: PPUSH
90075: CALL_OW 1
90079: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
90080: LD_VAR 0 1
90084: PPUSH
90085: LD_INT 19
90087: PPUSH
90088: CALL 56358 0 2
// MC_Reset ( base , 20 ) ;
90092: LD_VAR 0 1
90096: PPUSH
90097: LD_INT 20
90099: PPUSH
90100: CALL 56358 0 2
// end ; end_of_file
90104: LD_VAR 0 3
90108: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
90109: LD_INT 0
90111: PPUSH
90112: PPUSH
90113: PPUSH
90114: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
90115: LD_VAR 0 1
90119: PPUSH
90120: CALL_OW 264
90124: PUSH
90125: LD_INT 91
90127: EQUAL
90128: IFFALSE 90200
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
90130: LD_INT 68
90132: PPUSH
90133: LD_VAR 0 1
90137: PPUSH
90138: CALL_OW 255
90142: PPUSH
90143: CALL_OW 321
90147: PUSH
90148: LD_INT 2
90150: EQUAL
90151: IFFALSE 90163
// eff := 70 else
90153: LD_ADDR_VAR 0 4
90157: PUSH
90158: LD_INT 70
90160: ST_TO_ADDR
90161: GO 90171
// eff := 30 ;
90163: LD_ADDR_VAR 0 4
90167: PUSH
90168: LD_INT 30
90170: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
90171: LD_VAR 0 1
90175: PPUSH
90176: CALL_OW 250
90180: PPUSH
90181: LD_VAR 0 1
90185: PPUSH
90186: CALL_OW 251
90190: PPUSH
90191: LD_VAR 0 4
90195: PPUSH
90196: CALL_OW 495
// end ; end ;
90200: LD_VAR 0 2
90204: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
90205: LD_INT 0
90207: PPUSH
// end ;
90208: LD_VAR 0 4
90212: RET
// export function SOS_Command ( cmd ) ; begin
90213: LD_INT 0
90215: PPUSH
// end ;
90216: LD_VAR 0 2
90220: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
90221: LD_INT 0
90223: PPUSH
// end ;
90224: LD_VAR 0 6
90228: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
90229: LD_INT 0
90231: PPUSH
90232: PPUSH
// if not vehicle or not factory then
90233: LD_VAR 0 1
90237: NOT
90238: PUSH
90239: LD_VAR 0 2
90243: NOT
90244: OR
90245: IFFALSE 90249
// exit ;
90247: GO 90480
// if factoryWaypoints >= factory then
90249: LD_EXP 135
90253: PUSH
90254: LD_VAR 0 2
90258: GREATEREQUAL
90259: IFFALSE 90480
// if factoryWaypoints [ factory ] then
90261: LD_EXP 135
90265: PUSH
90266: LD_VAR 0 2
90270: ARRAY
90271: IFFALSE 90480
// begin if GetControl ( vehicle ) = control_manual then
90273: LD_VAR 0 1
90277: PPUSH
90278: CALL_OW 263
90282: PUSH
90283: LD_INT 1
90285: EQUAL
90286: IFFALSE 90367
// begin driver := IsDrivenBy ( vehicle ) ;
90288: LD_ADDR_VAR 0 4
90292: PUSH
90293: LD_VAR 0 1
90297: PPUSH
90298: CALL_OW 311
90302: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
90303: LD_VAR 0 4
90307: PPUSH
90308: LD_EXP 135
90312: PUSH
90313: LD_VAR 0 2
90317: ARRAY
90318: PUSH
90319: LD_INT 3
90321: ARRAY
90322: PPUSH
90323: LD_EXP 135
90327: PUSH
90328: LD_VAR 0 2
90332: ARRAY
90333: PUSH
90334: LD_INT 4
90336: ARRAY
90337: PPUSH
90338: CALL_OW 171
// AddComExitVehicle ( driver ) ;
90342: LD_VAR 0 4
90346: PPUSH
90347: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
90351: LD_VAR 0 4
90355: PPUSH
90356: LD_VAR 0 2
90360: PPUSH
90361: CALL_OW 180
// end else
90365: GO 90480
// if GetControl ( vehicle ) = control_remote then
90367: LD_VAR 0 1
90371: PPUSH
90372: CALL_OW 263
90376: PUSH
90377: LD_INT 2
90379: EQUAL
90380: IFFALSE 90441
// begin wait ( 0 0$2 ) ;
90382: LD_INT 70
90384: PPUSH
90385: CALL_OW 67
// if Connect ( vehicle ) then
90389: LD_VAR 0 1
90393: PPUSH
90394: CALL 19125 0 1
90398: IFFALSE 90439
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
90400: LD_VAR 0 1
90404: PPUSH
90405: LD_EXP 135
90409: PUSH
90410: LD_VAR 0 2
90414: ARRAY
90415: PUSH
90416: LD_INT 3
90418: ARRAY
90419: PPUSH
90420: LD_EXP 135
90424: PUSH
90425: LD_VAR 0 2
90429: ARRAY
90430: PUSH
90431: LD_INT 4
90433: ARRAY
90434: PPUSH
90435: CALL_OW 171
// end else
90439: GO 90480
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
90441: LD_VAR 0 1
90445: PPUSH
90446: LD_EXP 135
90450: PUSH
90451: LD_VAR 0 2
90455: ARRAY
90456: PUSH
90457: LD_INT 3
90459: ARRAY
90460: PPUSH
90461: LD_EXP 135
90465: PUSH
90466: LD_VAR 0 2
90470: ARRAY
90471: PUSH
90472: LD_INT 4
90474: ARRAY
90475: PPUSH
90476: CALL_OW 171
// end ; end ;
90480: LD_VAR 0 3
90484: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
90485: LD_INT 0
90487: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
90488: LD_VAR 0 1
90492: PUSH
90493: LD_INT 250
90495: EQUAL
90496: PUSH
90497: LD_VAR 0 2
90501: PPUSH
90502: CALL_OW 264
90506: PUSH
90507: LD_INT 81
90509: EQUAL
90510: AND
90511: IFFALSE 90532
// MinerPlaceMine ( unit , x , y ) ;
90513: LD_VAR 0 2
90517: PPUSH
90518: LD_VAR 0 4
90522: PPUSH
90523: LD_VAR 0 5
90527: PPUSH
90528: CALL 92917 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
90532: LD_VAR 0 1
90536: PUSH
90537: LD_INT 251
90539: EQUAL
90540: PUSH
90541: LD_VAR 0 2
90545: PPUSH
90546: CALL_OW 264
90550: PUSH
90551: LD_INT 81
90553: EQUAL
90554: AND
90555: IFFALSE 90576
// MinerDetonateMine ( unit , x , y ) ;
90557: LD_VAR 0 2
90561: PPUSH
90562: LD_VAR 0 4
90566: PPUSH
90567: LD_VAR 0 5
90571: PPUSH
90572: CALL 93192 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
90576: LD_VAR 0 1
90580: PUSH
90581: LD_INT 252
90583: EQUAL
90584: PUSH
90585: LD_VAR 0 2
90589: PPUSH
90590: CALL_OW 264
90594: PUSH
90595: LD_INT 81
90597: EQUAL
90598: AND
90599: IFFALSE 90620
// MinerCreateMinefield ( unit , x , y ) ;
90601: LD_VAR 0 2
90605: PPUSH
90606: LD_VAR 0 4
90610: PPUSH
90611: LD_VAR 0 5
90615: PPUSH
90616: CALL 93609 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
90620: LD_VAR 0 1
90624: PUSH
90625: LD_INT 253
90627: EQUAL
90628: PUSH
90629: LD_VAR 0 2
90633: PPUSH
90634: CALL_OW 257
90638: PUSH
90639: LD_INT 5
90641: EQUAL
90642: AND
90643: IFFALSE 90664
// ComBinocular ( unit , x , y ) ;
90645: LD_VAR 0 2
90649: PPUSH
90650: LD_VAR 0 4
90654: PPUSH
90655: LD_VAR 0 5
90659: PPUSH
90660: CALL 93978 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
90664: LD_VAR 0 1
90668: PUSH
90669: LD_INT 254
90671: EQUAL
90672: PUSH
90673: LD_VAR 0 2
90677: PPUSH
90678: CALL_OW 264
90682: PUSH
90683: LD_INT 99
90685: EQUAL
90686: AND
90687: PUSH
90688: LD_VAR 0 3
90692: PPUSH
90693: CALL_OW 263
90697: PUSH
90698: LD_INT 3
90700: EQUAL
90701: AND
90702: IFFALSE 90718
// HackDestroyVehicle ( unit , selectedUnit ) ;
90704: LD_VAR 0 2
90708: PPUSH
90709: LD_VAR 0 3
90713: PPUSH
90714: CALL 92281 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
90718: LD_VAR 0 1
90722: PUSH
90723: LD_INT 255
90725: EQUAL
90726: PUSH
90727: LD_VAR 0 2
90731: PPUSH
90732: CALL_OW 264
90736: PUSH
90737: LD_INT 14
90739: PUSH
90740: LD_INT 53
90742: PUSH
90743: EMPTY
90744: LIST
90745: LIST
90746: IN
90747: AND
90748: PUSH
90749: LD_VAR 0 4
90753: PPUSH
90754: LD_VAR 0 5
90758: PPUSH
90759: CALL_OW 488
90763: AND
90764: IFFALSE 90788
// CutTreeXYR ( unit , x , y , 12 ) ;
90766: LD_VAR 0 2
90770: PPUSH
90771: LD_VAR 0 4
90775: PPUSH
90776: LD_VAR 0 5
90780: PPUSH
90781: LD_INT 12
90783: PPUSH
90784: CALL 90851 0 4
// if cmd = 256 then
90788: LD_VAR 0 1
90792: PUSH
90793: LD_INT 256
90795: EQUAL
90796: IFFALSE 90817
// SetFactoryWaypoint ( unit , x , y ) ;
90798: LD_VAR 0 2
90802: PPUSH
90803: LD_VAR 0 4
90807: PPUSH
90808: LD_VAR 0 5
90812: PPUSH
90813: CALL 108899 0 3
// if cmd = 257 then
90817: LD_VAR 0 1
90821: PUSH
90822: LD_INT 257
90824: EQUAL
90825: IFFALSE 90846
// SetWarehouseGatheringPoint ( unit , x , y ) ;
90827: LD_VAR 0 2
90831: PPUSH
90832: LD_VAR 0 4
90836: PPUSH
90837: LD_VAR 0 5
90841: PPUSH
90842: CALL 109261 0 3
// end ;
90846: LD_VAR 0 6
90850: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
90851: LD_INT 0
90853: PPUSH
90854: PPUSH
90855: PPUSH
90856: PPUSH
90857: PPUSH
90858: PPUSH
90859: PPUSH
90860: PPUSH
90861: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
90862: LD_VAR 0 1
90866: NOT
90867: PUSH
90868: LD_VAR 0 2
90872: PPUSH
90873: LD_VAR 0 3
90877: PPUSH
90878: CALL_OW 488
90882: NOT
90883: OR
90884: PUSH
90885: LD_VAR 0 4
90889: NOT
90890: OR
90891: IFFALSE 90895
// exit ;
90893: GO 91235
// list := [ ] ;
90895: LD_ADDR_VAR 0 13
90899: PUSH
90900: EMPTY
90901: ST_TO_ADDR
// if x - r < 0 then
90902: LD_VAR 0 2
90906: PUSH
90907: LD_VAR 0 4
90911: MINUS
90912: PUSH
90913: LD_INT 0
90915: LESS
90916: IFFALSE 90928
// min_x := 0 else
90918: LD_ADDR_VAR 0 7
90922: PUSH
90923: LD_INT 0
90925: ST_TO_ADDR
90926: GO 90944
// min_x := x - r ;
90928: LD_ADDR_VAR 0 7
90932: PUSH
90933: LD_VAR 0 2
90937: PUSH
90938: LD_VAR 0 4
90942: MINUS
90943: ST_TO_ADDR
// if y - r < 0 then
90944: LD_VAR 0 3
90948: PUSH
90949: LD_VAR 0 4
90953: MINUS
90954: PUSH
90955: LD_INT 0
90957: LESS
90958: IFFALSE 90970
// min_y := 0 else
90960: LD_ADDR_VAR 0 8
90964: PUSH
90965: LD_INT 0
90967: ST_TO_ADDR
90968: GO 90986
// min_y := y - r ;
90970: LD_ADDR_VAR 0 8
90974: PUSH
90975: LD_VAR 0 3
90979: PUSH
90980: LD_VAR 0 4
90984: MINUS
90985: ST_TO_ADDR
// max_x := x + r ;
90986: LD_ADDR_VAR 0 9
90990: PUSH
90991: LD_VAR 0 2
90995: PUSH
90996: LD_VAR 0 4
91000: PLUS
91001: ST_TO_ADDR
// max_y := y + r ;
91002: LD_ADDR_VAR 0 10
91006: PUSH
91007: LD_VAR 0 3
91011: PUSH
91012: LD_VAR 0 4
91016: PLUS
91017: ST_TO_ADDR
// for _x = min_x to max_x do
91018: LD_ADDR_VAR 0 11
91022: PUSH
91023: DOUBLE
91024: LD_VAR 0 7
91028: DEC
91029: ST_TO_ADDR
91030: LD_VAR 0 9
91034: PUSH
91035: FOR_TO
91036: IFFALSE 91153
// for _y = min_y to max_y do
91038: LD_ADDR_VAR 0 12
91042: PUSH
91043: DOUBLE
91044: LD_VAR 0 8
91048: DEC
91049: ST_TO_ADDR
91050: LD_VAR 0 10
91054: PUSH
91055: FOR_TO
91056: IFFALSE 91149
// begin if not ValidHex ( _x , _y ) then
91058: LD_VAR 0 11
91062: PPUSH
91063: LD_VAR 0 12
91067: PPUSH
91068: CALL_OW 488
91072: NOT
91073: IFFALSE 91077
// continue ;
91075: GO 91055
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
91077: LD_VAR 0 11
91081: PPUSH
91082: LD_VAR 0 12
91086: PPUSH
91087: CALL_OW 351
91091: PUSH
91092: LD_VAR 0 11
91096: PPUSH
91097: LD_VAR 0 12
91101: PPUSH
91102: CALL_OW 554
91106: AND
91107: IFFALSE 91147
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
91109: LD_ADDR_VAR 0 13
91113: PUSH
91114: LD_VAR 0 13
91118: PPUSH
91119: LD_VAR 0 13
91123: PUSH
91124: LD_INT 1
91126: PLUS
91127: PPUSH
91128: LD_VAR 0 11
91132: PUSH
91133: LD_VAR 0 12
91137: PUSH
91138: EMPTY
91139: LIST
91140: LIST
91141: PPUSH
91142: CALL_OW 2
91146: ST_TO_ADDR
// end ;
91147: GO 91055
91149: POP
91150: POP
91151: GO 91035
91153: POP
91154: POP
// if not list then
91155: LD_VAR 0 13
91159: NOT
91160: IFFALSE 91164
// exit ;
91162: GO 91235
// for i in list do
91164: LD_ADDR_VAR 0 6
91168: PUSH
91169: LD_VAR 0 13
91173: PUSH
91174: FOR_IN
91175: IFFALSE 91233
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
91177: LD_VAR 0 1
91181: PPUSH
91182: LD_STRING M
91184: PUSH
91185: LD_VAR 0 6
91189: PUSH
91190: LD_INT 1
91192: ARRAY
91193: PUSH
91194: LD_VAR 0 6
91198: PUSH
91199: LD_INT 2
91201: ARRAY
91202: PUSH
91203: LD_INT 0
91205: PUSH
91206: LD_INT 0
91208: PUSH
91209: LD_INT 0
91211: PUSH
91212: LD_INT 0
91214: PUSH
91215: EMPTY
91216: LIST
91217: LIST
91218: LIST
91219: LIST
91220: LIST
91221: LIST
91222: LIST
91223: PUSH
91224: EMPTY
91225: LIST
91226: PPUSH
91227: CALL_OW 447
91231: GO 91174
91233: POP
91234: POP
// end ;
91235: LD_VAR 0 5
91239: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
91240: LD_EXP 67
91244: NOT
91245: IFFALSE 91295
91247: GO 91249
91249: DISABLE
// begin initHack := true ;
91250: LD_ADDR_EXP 67
91254: PUSH
91255: LD_INT 1
91257: ST_TO_ADDR
// hackTanks := [ ] ;
91258: LD_ADDR_EXP 68
91262: PUSH
91263: EMPTY
91264: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
91265: LD_ADDR_EXP 69
91269: PUSH
91270: EMPTY
91271: ST_TO_ADDR
// hackLimit := 3 ;
91272: LD_ADDR_EXP 70
91276: PUSH
91277: LD_INT 3
91279: ST_TO_ADDR
// hackDist := 12 ;
91280: LD_ADDR_EXP 71
91284: PUSH
91285: LD_INT 12
91287: ST_TO_ADDR
// hackCounter := [ ] ;
91288: LD_ADDR_EXP 72
91292: PUSH
91293: EMPTY
91294: ST_TO_ADDR
// end ;
91295: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
91296: LD_EXP 67
91300: PUSH
91301: LD_INT 34
91303: PUSH
91304: LD_INT 99
91306: PUSH
91307: EMPTY
91308: LIST
91309: LIST
91310: PPUSH
91311: CALL_OW 69
91315: AND
91316: IFFALSE 91569
91318: GO 91320
91320: DISABLE
91321: LD_INT 0
91323: PPUSH
91324: PPUSH
// begin enable ;
91325: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
91326: LD_ADDR_VAR 0 1
91330: PUSH
91331: LD_INT 34
91333: PUSH
91334: LD_INT 99
91336: PUSH
91337: EMPTY
91338: LIST
91339: LIST
91340: PPUSH
91341: CALL_OW 69
91345: PUSH
91346: FOR_IN
91347: IFFALSE 91567
// begin if not i in hackTanks then
91349: LD_VAR 0 1
91353: PUSH
91354: LD_EXP 68
91358: IN
91359: NOT
91360: IFFALSE 91443
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
91362: LD_ADDR_EXP 68
91366: PUSH
91367: LD_EXP 68
91371: PPUSH
91372: LD_EXP 68
91376: PUSH
91377: LD_INT 1
91379: PLUS
91380: PPUSH
91381: LD_VAR 0 1
91385: PPUSH
91386: CALL_OW 1
91390: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
91391: LD_ADDR_EXP 69
91395: PUSH
91396: LD_EXP 69
91400: PPUSH
91401: LD_EXP 69
91405: PUSH
91406: LD_INT 1
91408: PLUS
91409: PPUSH
91410: EMPTY
91411: PPUSH
91412: CALL_OW 1
91416: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
91417: LD_ADDR_EXP 72
91421: PUSH
91422: LD_EXP 72
91426: PPUSH
91427: LD_EXP 72
91431: PUSH
91432: LD_INT 1
91434: PLUS
91435: PPUSH
91436: EMPTY
91437: PPUSH
91438: CALL_OW 1
91442: ST_TO_ADDR
// end ; if not IsOk ( i ) then
91443: LD_VAR 0 1
91447: PPUSH
91448: CALL_OW 302
91452: NOT
91453: IFFALSE 91466
// begin HackUnlinkAll ( i ) ;
91455: LD_VAR 0 1
91459: PPUSH
91460: CALL 91572 0 1
// continue ;
91464: GO 91346
// end ; HackCheckCapturedStatus ( i ) ;
91466: LD_VAR 0 1
91470: PPUSH
91471: CALL 92015 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
91475: LD_ADDR_VAR 0 2
91479: PUSH
91480: LD_INT 81
91482: PUSH
91483: LD_VAR 0 1
91487: PPUSH
91488: CALL_OW 255
91492: PUSH
91493: EMPTY
91494: LIST
91495: LIST
91496: PUSH
91497: LD_INT 33
91499: PUSH
91500: LD_INT 3
91502: PUSH
91503: EMPTY
91504: LIST
91505: LIST
91506: PUSH
91507: LD_INT 91
91509: PUSH
91510: LD_VAR 0 1
91514: PUSH
91515: LD_EXP 71
91519: PUSH
91520: EMPTY
91521: LIST
91522: LIST
91523: LIST
91524: PUSH
91525: LD_INT 50
91527: PUSH
91528: EMPTY
91529: LIST
91530: PUSH
91531: EMPTY
91532: LIST
91533: LIST
91534: LIST
91535: LIST
91536: PPUSH
91537: CALL_OW 69
91541: ST_TO_ADDR
// if not tmp then
91542: LD_VAR 0 2
91546: NOT
91547: IFFALSE 91551
// continue ;
91549: GO 91346
// HackLink ( i , tmp ) ;
91551: LD_VAR 0 1
91555: PPUSH
91556: LD_VAR 0 2
91560: PPUSH
91561: CALL 91708 0 2
// end ;
91565: GO 91346
91567: POP
91568: POP
// end ;
91569: PPOPN 2
91571: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
91572: LD_INT 0
91574: PPUSH
91575: PPUSH
91576: PPUSH
// if not hack in hackTanks then
91577: LD_VAR 0 1
91581: PUSH
91582: LD_EXP 68
91586: IN
91587: NOT
91588: IFFALSE 91592
// exit ;
91590: GO 91703
// index := GetElementIndex ( hackTanks , hack ) ;
91592: LD_ADDR_VAR 0 4
91596: PUSH
91597: LD_EXP 68
91601: PPUSH
91602: LD_VAR 0 1
91606: PPUSH
91607: CALL 15941 0 2
91611: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
91612: LD_EXP 69
91616: PUSH
91617: LD_VAR 0 4
91621: ARRAY
91622: IFFALSE 91703
// begin for i in hackTanksCaptured [ index ] do
91624: LD_ADDR_VAR 0 3
91628: PUSH
91629: LD_EXP 69
91633: PUSH
91634: LD_VAR 0 4
91638: ARRAY
91639: PUSH
91640: FOR_IN
91641: IFFALSE 91667
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
91643: LD_VAR 0 3
91647: PUSH
91648: LD_INT 1
91650: ARRAY
91651: PPUSH
91652: LD_VAR 0 3
91656: PUSH
91657: LD_INT 2
91659: ARRAY
91660: PPUSH
91661: CALL_OW 235
91665: GO 91640
91667: POP
91668: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
91669: LD_ADDR_EXP 69
91673: PUSH
91674: LD_EXP 69
91678: PPUSH
91679: LD_VAR 0 4
91683: PPUSH
91684: EMPTY
91685: PPUSH
91686: CALL_OW 1
91690: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
91691: LD_VAR 0 1
91695: PPUSH
91696: LD_INT 0
91698: PPUSH
91699: CALL_OW 505
// end ; end ;
91703: LD_VAR 0 2
91707: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
91708: LD_INT 0
91710: PPUSH
91711: PPUSH
91712: PPUSH
// if not hack in hackTanks or not vehicles then
91713: LD_VAR 0 1
91717: PUSH
91718: LD_EXP 68
91722: IN
91723: NOT
91724: PUSH
91725: LD_VAR 0 2
91729: NOT
91730: OR
91731: IFFALSE 91735
// exit ;
91733: GO 92010
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
91735: LD_ADDR_VAR 0 2
91739: PUSH
91740: LD_VAR 0 1
91744: PPUSH
91745: LD_VAR 0 2
91749: PPUSH
91750: LD_INT 1
91752: PPUSH
91753: LD_INT 1
91755: PPUSH
91756: CALL 16591 0 4
91760: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
91761: LD_ADDR_VAR 0 5
91765: PUSH
91766: LD_EXP 68
91770: PPUSH
91771: LD_VAR 0 1
91775: PPUSH
91776: CALL 15941 0 2
91780: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
91781: LD_EXP 69
91785: PUSH
91786: LD_VAR 0 5
91790: ARRAY
91791: PUSH
91792: LD_EXP 70
91796: LESS
91797: IFFALSE 91986
// begin for i := 1 to vehicles do
91799: LD_ADDR_VAR 0 4
91803: PUSH
91804: DOUBLE
91805: LD_INT 1
91807: DEC
91808: ST_TO_ADDR
91809: LD_VAR 0 2
91813: PUSH
91814: FOR_TO
91815: IFFALSE 91984
// begin if hackTanksCaptured [ index ] = hackLimit then
91817: LD_EXP 69
91821: PUSH
91822: LD_VAR 0 5
91826: ARRAY
91827: PUSH
91828: LD_EXP 70
91832: EQUAL
91833: IFFALSE 91837
// break ;
91835: GO 91984
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
91837: LD_ADDR_EXP 72
91841: PUSH
91842: LD_EXP 72
91846: PPUSH
91847: LD_VAR 0 5
91851: PPUSH
91852: LD_EXP 72
91856: PUSH
91857: LD_VAR 0 5
91861: ARRAY
91862: PUSH
91863: LD_INT 1
91865: PLUS
91866: PPUSH
91867: CALL_OW 1
91871: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
91872: LD_ADDR_EXP 69
91876: PUSH
91877: LD_EXP 69
91881: PPUSH
91882: LD_VAR 0 5
91886: PUSH
91887: LD_EXP 69
91891: PUSH
91892: LD_VAR 0 5
91896: ARRAY
91897: PUSH
91898: LD_INT 1
91900: PLUS
91901: PUSH
91902: EMPTY
91903: LIST
91904: LIST
91905: PPUSH
91906: LD_VAR 0 2
91910: PUSH
91911: LD_VAR 0 4
91915: ARRAY
91916: PUSH
91917: LD_VAR 0 2
91921: PUSH
91922: LD_VAR 0 4
91926: ARRAY
91927: PPUSH
91928: CALL_OW 255
91932: PUSH
91933: EMPTY
91934: LIST
91935: LIST
91936: PPUSH
91937: CALL 16156 0 3
91941: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
91942: LD_VAR 0 2
91946: PUSH
91947: LD_VAR 0 4
91951: ARRAY
91952: PPUSH
91953: LD_VAR 0 1
91957: PPUSH
91958: CALL_OW 255
91962: PPUSH
91963: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
91967: LD_VAR 0 2
91971: PUSH
91972: LD_VAR 0 4
91976: ARRAY
91977: PPUSH
91978: CALL_OW 141
// end ;
91982: GO 91814
91984: POP
91985: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
91986: LD_VAR 0 1
91990: PPUSH
91991: LD_EXP 69
91995: PUSH
91996: LD_VAR 0 5
92000: ARRAY
92001: PUSH
92002: LD_INT 0
92004: PLUS
92005: PPUSH
92006: CALL_OW 505
// end ;
92010: LD_VAR 0 3
92014: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
92015: LD_INT 0
92017: PPUSH
92018: PPUSH
92019: PPUSH
92020: PPUSH
// if not hack in hackTanks then
92021: LD_VAR 0 1
92025: PUSH
92026: LD_EXP 68
92030: IN
92031: NOT
92032: IFFALSE 92036
// exit ;
92034: GO 92276
// index := GetElementIndex ( hackTanks , hack ) ;
92036: LD_ADDR_VAR 0 4
92040: PUSH
92041: LD_EXP 68
92045: PPUSH
92046: LD_VAR 0 1
92050: PPUSH
92051: CALL 15941 0 2
92055: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
92056: LD_ADDR_VAR 0 3
92060: PUSH
92061: DOUBLE
92062: LD_EXP 69
92066: PUSH
92067: LD_VAR 0 4
92071: ARRAY
92072: INC
92073: ST_TO_ADDR
92074: LD_INT 1
92076: PUSH
92077: FOR_DOWNTO
92078: IFFALSE 92250
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
92080: LD_ADDR_VAR 0 5
92084: PUSH
92085: LD_EXP 69
92089: PUSH
92090: LD_VAR 0 4
92094: ARRAY
92095: PUSH
92096: LD_VAR 0 3
92100: ARRAY
92101: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
92102: LD_VAR 0 5
92106: PUSH
92107: LD_INT 1
92109: ARRAY
92110: PPUSH
92111: CALL_OW 302
92115: NOT
92116: PUSH
92117: LD_VAR 0 5
92121: PUSH
92122: LD_INT 1
92124: ARRAY
92125: PPUSH
92126: CALL_OW 255
92130: PUSH
92131: LD_VAR 0 1
92135: PPUSH
92136: CALL_OW 255
92140: NONEQUAL
92141: OR
92142: IFFALSE 92248
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
92144: LD_VAR 0 5
92148: PUSH
92149: LD_INT 1
92151: ARRAY
92152: PPUSH
92153: CALL_OW 305
92157: PUSH
92158: LD_VAR 0 5
92162: PUSH
92163: LD_INT 1
92165: ARRAY
92166: PPUSH
92167: CALL_OW 255
92171: PUSH
92172: LD_VAR 0 1
92176: PPUSH
92177: CALL_OW 255
92181: EQUAL
92182: AND
92183: IFFALSE 92207
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
92185: LD_VAR 0 5
92189: PUSH
92190: LD_INT 1
92192: ARRAY
92193: PPUSH
92194: LD_VAR 0 5
92198: PUSH
92199: LD_INT 2
92201: ARRAY
92202: PPUSH
92203: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
92207: LD_ADDR_EXP 69
92211: PUSH
92212: LD_EXP 69
92216: PPUSH
92217: LD_VAR 0 4
92221: PPUSH
92222: LD_EXP 69
92226: PUSH
92227: LD_VAR 0 4
92231: ARRAY
92232: PPUSH
92233: LD_VAR 0 3
92237: PPUSH
92238: CALL_OW 3
92242: PPUSH
92243: CALL_OW 1
92247: ST_TO_ADDR
// end ; end ;
92248: GO 92077
92250: POP
92251: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
92252: LD_VAR 0 1
92256: PPUSH
92257: LD_EXP 69
92261: PUSH
92262: LD_VAR 0 4
92266: ARRAY
92267: PUSH
92268: LD_INT 0
92270: PLUS
92271: PPUSH
92272: CALL_OW 505
// end ;
92276: LD_VAR 0 2
92280: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
92281: LD_INT 0
92283: PPUSH
92284: PPUSH
92285: PPUSH
92286: PPUSH
// if not hack in hackTanks then
92287: LD_VAR 0 1
92291: PUSH
92292: LD_EXP 68
92296: IN
92297: NOT
92298: IFFALSE 92302
// exit ;
92300: GO 92387
// index := GetElementIndex ( hackTanks , hack ) ;
92302: LD_ADDR_VAR 0 5
92306: PUSH
92307: LD_EXP 68
92311: PPUSH
92312: LD_VAR 0 1
92316: PPUSH
92317: CALL 15941 0 2
92321: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
92322: LD_ADDR_VAR 0 4
92326: PUSH
92327: DOUBLE
92328: LD_INT 1
92330: DEC
92331: ST_TO_ADDR
92332: LD_EXP 69
92336: PUSH
92337: LD_VAR 0 5
92341: ARRAY
92342: PUSH
92343: FOR_TO
92344: IFFALSE 92385
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
92346: LD_EXP 69
92350: PUSH
92351: LD_VAR 0 5
92355: ARRAY
92356: PUSH
92357: LD_VAR 0 4
92361: ARRAY
92362: PUSH
92363: LD_INT 1
92365: ARRAY
92366: PUSH
92367: LD_VAR 0 2
92371: EQUAL
92372: IFFALSE 92383
// KillUnit ( vehicle ) ;
92374: LD_VAR 0 2
92378: PPUSH
92379: CALL_OW 66
92383: GO 92343
92385: POP
92386: POP
// end ;
92387: LD_VAR 0 3
92391: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
92392: LD_EXP 73
92396: NOT
92397: IFFALSE 92432
92399: GO 92401
92401: DISABLE
// begin initMiner := true ;
92402: LD_ADDR_EXP 73
92406: PUSH
92407: LD_INT 1
92409: ST_TO_ADDR
// minersList := [ ] ;
92410: LD_ADDR_EXP 74
92414: PUSH
92415: EMPTY
92416: ST_TO_ADDR
// minerMinesList := [ ] ;
92417: LD_ADDR_EXP 75
92421: PUSH
92422: EMPTY
92423: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
92424: LD_ADDR_EXP 76
92428: PUSH
92429: LD_INT 5
92431: ST_TO_ADDR
// end ;
92432: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
92433: LD_EXP 73
92437: PUSH
92438: LD_INT 34
92440: PUSH
92441: LD_INT 81
92443: PUSH
92444: EMPTY
92445: LIST
92446: LIST
92447: PPUSH
92448: CALL_OW 69
92452: AND
92453: IFFALSE 92914
92455: GO 92457
92457: DISABLE
92458: LD_INT 0
92460: PPUSH
92461: PPUSH
92462: PPUSH
92463: PPUSH
// begin enable ;
92464: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
92465: LD_ADDR_VAR 0 1
92469: PUSH
92470: LD_INT 34
92472: PUSH
92473: LD_INT 81
92475: PUSH
92476: EMPTY
92477: LIST
92478: LIST
92479: PPUSH
92480: CALL_OW 69
92484: PUSH
92485: FOR_IN
92486: IFFALSE 92558
// begin if not i in minersList then
92488: LD_VAR 0 1
92492: PUSH
92493: LD_EXP 74
92497: IN
92498: NOT
92499: IFFALSE 92556
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
92501: LD_ADDR_EXP 74
92505: PUSH
92506: LD_EXP 74
92510: PPUSH
92511: LD_EXP 74
92515: PUSH
92516: LD_INT 1
92518: PLUS
92519: PPUSH
92520: LD_VAR 0 1
92524: PPUSH
92525: CALL_OW 1
92529: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
92530: LD_ADDR_EXP 75
92534: PUSH
92535: LD_EXP 75
92539: PPUSH
92540: LD_EXP 75
92544: PUSH
92545: LD_INT 1
92547: PLUS
92548: PPUSH
92549: EMPTY
92550: PPUSH
92551: CALL_OW 1
92555: ST_TO_ADDR
// end end ;
92556: GO 92485
92558: POP
92559: POP
// for i := minerMinesList downto 1 do
92560: LD_ADDR_VAR 0 1
92564: PUSH
92565: DOUBLE
92566: LD_EXP 75
92570: INC
92571: ST_TO_ADDR
92572: LD_INT 1
92574: PUSH
92575: FOR_DOWNTO
92576: IFFALSE 92912
// begin if IsLive ( minersList [ i ] ) then
92578: LD_EXP 74
92582: PUSH
92583: LD_VAR 0 1
92587: ARRAY
92588: PPUSH
92589: CALL_OW 300
92593: IFFALSE 92621
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
92595: LD_EXP 74
92599: PUSH
92600: LD_VAR 0 1
92604: ARRAY
92605: PPUSH
92606: LD_EXP 75
92610: PUSH
92611: LD_VAR 0 1
92615: ARRAY
92616: PPUSH
92617: CALL_OW 505
// if not minerMinesList [ i ] then
92621: LD_EXP 75
92625: PUSH
92626: LD_VAR 0 1
92630: ARRAY
92631: NOT
92632: IFFALSE 92636
// continue ;
92634: GO 92575
// for j := minerMinesList [ i ] downto 1 do
92636: LD_ADDR_VAR 0 2
92640: PUSH
92641: DOUBLE
92642: LD_EXP 75
92646: PUSH
92647: LD_VAR 0 1
92651: ARRAY
92652: INC
92653: ST_TO_ADDR
92654: LD_INT 1
92656: PUSH
92657: FOR_DOWNTO
92658: IFFALSE 92908
// begin side := GetSide ( minersList [ i ] ) ;
92660: LD_ADDR_VAR 0 3
92664: PUSH
92665: LD_EXP 74
92669: PUSH
92670: LD_VAR 0 1
92674: ARRAY
92675: PPUSH
92676: CALL_OW 255
92680: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
92681: LD_ADDR_VAR 0 4
92685: PUSH
92686: LD_EXP 75
92690: PUSH
92691: LD_VAR 0 1
92695: ARRAY
92696: PUSH
92697: LD_VAR 0 2
92701: ARRAY
92702: PUSH
92703: LD_INT 1
92705: ARRAY
92706: PPUSH
92707: LD_EXP 75
92711: PUSH
92712: LD_VAR 0 1
92716: ARRAY
92717: PUSH
92718: LD_VAR 0 2
92722: ARRAY
92723: PUSH
92724: LD_INT 2
92726: ARRAY
92727: PPUSH
92728: CALL_OW 428
92732: ST_TO_ADDR
// if not tmp then
92733: LD_VAR 0 4
92737: NOT
92738: IFFALSE 92742
// continue ;
92740: GO 92657
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
92742: LD_VAR 0 4
92746: PUSH
92747: LD_INT 81
92749: PUSH
92750: LD_VAR 0 3
92754: PUSH
92755: EMPTY
92756: LIST
92757: LIST
92758: PPUSH
92759: CALL_OW 69
92763: IN
92764: PUSH
92765: LD_EXP 75
92769: PUSH
92770: LD_VAR 0 1
92774: ARRAY
92775: PUSH
92776: LD_VAR 0 2
92780: ARRAY
92781: PUSH
92782: LD_INT 1
92784: ARRAY
92785: PPUSH
92786: LD_EXP 75
92790: PUSH
92791: LD_VAR 0 1
92795: ARRAY
92796: PUSH
92797: LD_VAR 0 2
92801: ARRAY
92802: PUSH
92803: LD_INT 2
92805: ARRAY
92806: PPUSH
92807: CALL_OW 458
92811: AND
92812: IFFALSE 92906
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
92814: LD_EXP 75
92818: PUSH
92819: LD_VAR 0 1
92823: ARRAY
92824: PUSH
92825: LD_VAR 0 2
92829: ARRAY
92830: PUSH
92831: LD_INT 1
92833: ARRAY
92834: PPUSH
92835: LD_EXP 75
92839: PUSH
92840: LD_VAR 0 1
92844: ARRAY
92845: PUSH
92846: LD_VAR 0 2
92850: ARRAY
92851: PUSH
92852: LD_INT 2
92854: ARRAY
92855: PPUSH
92856: LD_VAR 0 3
92860: PPUSH
92861: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
92865: LD_ADDR_EXP 75
92869: PUSH
92870: LD_EXP 75
92874: PPUSH
92875: LD_VAR 0 1
92879: PPUSH
92880: LD_EXP 75
92884: PUSH
92885: LD_VAR 0 1
92889: ARRAY
92890: PPUSH
92891: LD_VAR 0 2
92895: PPUSH
92896: CALL_OW 3
92900: PPUSH
92901: CALL_OW 1
92905: ST_TO_ADDR
// end ; end ;
92906: GO 92657
92908: POP
92909: POP
// end ;
92910: GO 92575
92912: POP
92913: POP
// end ;
92914: PPOPN 4
92916: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
92917: LD_INT 0
92919: PPUSH
92920: PPUSH
// result := false ;
92921: LD_ADDR_VAR 0 4
92925: PUSH
92926: LD_INT 0
92928: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
92929: LD_VAR 0 1
92933: PPUSH
92934: CALL_OW 264
92938: PUSH
92939: LD_INT 81
92941: EQUAL
92942: NOT
92943: IFFALSE 92947
// exit ;
92945: GO 93187
// index := GetElementIndex ( minersList , unit ) ;
92947: LD_ADDR_VAR 0 5
92951: PUSH
92952: LD_EXP 74
92956: PPUSH
92957: LD_VAR 0 1
92961: PPUSH
92962: CALL 15941 0 2
92966: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
92967: LD_EXP 75
92971: PUSH
92972: LD_VAR 0 5
92976: ARRAY
92977: PUSH
92978: LD_EXP 76
92982: GREATEREQUAL
92983: IFFALSE 92987
// exit ;
92985: GO 93187
// ComMoveXY ( unit , x , y ) ;
92987: LD_VAR 0 1
92991: PPUSH
92992: LD_VAR 0 2
92996: PPUSH
92997: LD_VAR 0 3
93001: PPUSH
93002: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
93006: LD_INT 35
93008: PPUSH
93009: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
93013: LD_VAR 0 1
93017: PPUSH
93018: LD_VAR 0 2
93022: PPUSH
93023: LD_VAR 0 3
93027: PPUSH
93028: CALL 47204 0 3
93032: NOT
93033: PUSH
93034: LD_VAR 0 1
93038: PPUSH
93039: CALL_OW 314
93043: AND
93044: IFFALSE 93048
// exit ;
93046: GO 93187
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
93048: LD_VAR 0 2
93052: PPUSH
93053: LD_VAR 0 3
93057: PPUSH
93058: CALL_OW 428
93062: PUSH
93063: LD_VAR 0 1
93067: EQUAL
93068: PUSH
93069: LD_VAR 0 1
93073: PPUSH
93074: CALL_OW 314
93078: NOT
93079: AND
93080: IFFALSE 93006
// PlaySoundXY ( x , y , PlantMine ) ;
93082: LD_VAR 0 2
93086: PPUSH
93087: LD_VAR 0 3
93091: PPUSH
93092: LD_STRING PlantMine
93094: PPUSH
93095: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
93099: LD_VAR 0 2
93103: PPUSH
93104: LD_VAR 0 3
93108: PPUSH
93109: LD_VAR 0 1
93113: PPUSH
93114: CALL_OW 255
93118: PPUSH
93119: LD_INT 0
93121: PPUSH
93122: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
93126: LD_ADDR_EXP 75
93130: PUSH
93131: LD_EXP 75
93135: PPUSH
93136: LD_VAR 0 5
93140: PUSH
93141: LD_EXP 75
93145: PUSH
93146: LD_VAR 0 5
93150: ARRAY
93151: PUSH
93152: LD_INT 1
93154: PLUS
93155: PUSH
93156: EMPTY
93157: LIST
93158: LIST
93159: PPUSH
93160: LD_VAR 0 2
93164: PUSH
93165: LD_VAR 0 3
93169: PUSH
93170: EMPTY
93171: LIST
93172: LIST
93173: PPUSH
93174: CALL 16156 0 3
93178: ST_TO_ADDR
// result := true ;
93179: LD_ADDR_VAR 0 4
93183: PUSH
93184: LD_INT 1
93186: ST_TO_ADDR
// end ;
93187: LD_VAR 0 4
93191: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
93192: LD_INT 0
93194: PPUSH
93195: PPUSH
93196: PPUSH
// if not unit in minersList then
93197: LD_VAR 0 1
93201: PUSH
93202: LD_EXP 74
93206: IN
93207: NOT
93208: IFFALSE 93212
// exit ;
93210: GO 93604
// index := GetElementIndex ( minersList , unit ) ;
93212: LD_ADDR_VAR 0 6
93216: PUSH
93217: LD_EXP 74
93221: PPUSH
93222: LD_VAR 0 1
93226: PPUSH
93227: CALL 15941 0 2
93231: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
93232: LD_ADDR_VAR 0 5
93236: PUSH
93237: DOUBLE
93238: LD_EXP 75
93242: PUSH
93243: LD_VAR 0 6
93247: ARRAY
93248: INC
93249: ST_TO_ADDR
93250: LD_INT 1
93252: PUSH
93253: FOR_DOWNTO
93254: IFFALSE 93415
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
93256: LD_EXP 75
93260: PUSH
93261: LD_VAR 0 6
93265: ARRAY
93266: PUSH
93267: LD_VAR 0 5
93271: ARRAY
93272: PUSH
93273: LD_INT 1
93275: ARRAY
93276: PUSH
93277: LD_VAR 0 2
93281: EQUAL
93282: PUSH
93283: LD_EXP 75
93287: PUSH
93288: LD_VAR 0 6
93292: ARRAY
93293: PUSH
93294: LD_VAR 0 5
93298: ARRAY
93299: PUSH
93300: LD_INT 2
93302: ARRAY
93303: PUSH
93304: LD_VAR 0 3
93308: EQUAL
93309: AND
93310: IFFALSE 93413
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
93312: LD_EXP 75
93316: PUSH
93317: LD_VAR 0 6
93321: ARRAY
93322: PUSH
93323: LD_VAR 0 5
93327: ARRAY
93328: PUSH
93329: LD_INT 1
93331: ARRAY
93332: PPUSH
93333: LD_EXP 75
93337: PUSH
93338: LD_VAR 0 6
93342: ARRAY
93343: PUSH
93344: LD_VAR 0 5
93348: ARRAY
93349: PUSH
93350: LD_INT 2
93352: ARRAY
93353: PPUSH
93354: LD_VAR 0 1
93358: PPUSH
93359: CALL_OW 255
93363: PPUSH
93364: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
93368: LD_ADDR_EXP 75
93372: PUSH
93373: LD_EXP 75
93377: PPUSH
93378: LD_VAR 0 6
93382: PPUSH
93383: LD_EXP 75
93387: PUSH
93388: LD_VAR 0 6
93392: ARRAY
93393: PPUSH
93394: LD_VAR 0 5
93398: PPUSH
93399: CALL_OW 3
93403: PPUSH
93404: CALL_OW 1
93408: ST_TO_ADDR
// exit ;
93409: POP
93410: POP
93411: GO 93604
// end ; end ;
93413: GO 93253
93415: POP
93416: POP
// for i := minerMinesList [ index ] downto 1 do
93417: LD_ADDR_VAR 0 5
93421: PUSH
93422: DOUBLE
93423: LD_EXP 75
93427: PUSH
93428: LD_VAR 0 6
93432: ARRAY
93433: INC
93434: ST_TO_ADDR
93435: LD_INT 1
93437: PUSH
93438: FOR_DOWNTO
93439: IFFALSE 93602
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
93441: LD_EXP 75
93445: PUSH
93446: LD_VAR 0 6
93450: ARRAY
93451: PUSH
93452: LD_VAR 0 5
93456: ARRAY
93457: PUSH
93458: LD_INT 1
93460: ARRAY
93461: PPUSH
93462: LD_EXP 75
93466: PUSH
93467: LD_VAR 0 6
93471: ARRAY
93472: PUSH
93473: LD_VAR 0 5
93477: ARRAY
93478: PUSH
93479: LD_INT 2
93481: ARRAY
93482: PPUSH
93483: LD_VAR 0 2
93487: PPUSH
93488: LD_VAR 0 3
93492: PPUSH
93493: CALL_OW 298
93497: PUSH
93498: LD_INT 6
93500: LESS
93501: IFFALSE 93600
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
93503: LD_EXP 75
93507: PUSH
93508: LD_VAR 0 6
93512: ARRAY
93513: PUSH
93514: LD_VAR 0 5
93518: ARRAY
93519: PUSH
93520: LD_INT 1
93522: ARRAY
93523: PPUSH
93524: LD_EXP 75
93528: PUSH
93529: LD_VAR 0 6
93533: ARRAY
93534: PUSH
93535: LD_VAR 0 5
93539: ARRAY
93540: PUSH
93541: LD_INT 2
93543: ARRAY
93544: PPUSH
93545: LD_VAR 0 1
93549: PPUSH
93550: CALL_OW 255
93554: PPUSH
93555: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
93559: LD_ADDR_EXP 75
93563: PUSH
93564: LD_EXP 75
93568: PPUSH
93569: LD_VAR 0 6
93573: PPUSH
93574: LD_EXP 75
93578: PUSH
93579: LD_VAR 0 6
93583: ARRAY
93584: PPUSH
93585: LD_VAR 0 5
93589: PPUSH
93590: CALL_OW 3
93594: PPUSH
93595: CALL_OW 1
93599: ST_TO_ADDR
// end ; end ;
93600: GO 93438
93602: POP
93603: POP
// end ;
93604: LD_VAR 0 4
93608: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
93609: LD_INT 0
93611: PPUSH
93612: PPUSH
93613: PPUSH
93614: PPUSH
93615: PPUSH
93616: PPUSH
93617: PPUSH
93618: PPUSH
93619: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
93620: LD_VAR 0 1
93624: PPUSH
93625: CALL_OW 264
93629: PUSH
93630: LD_INT 81
93632: EQUAL
93633: NOT
93634: PUSH
93635: LD_VAR 0 1
93639: PUSH
93640: LD_EXP 74
93644: IN
93645: NOT
93646: OR
93647: IFFALSE 93651
// exit ;
93649: GO 93973
// index := GetElementIndex ( minersList , unit ) ;
93651: LD_ADDR_VAR 0 6
93655: PUSH
93656: LD_EXP 74
93660: PPUSH
93661: LD_VAR 0 1
93665: PPUSH
93666: CALL 15941 0 2
93670: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
93671: LD_ADDR_VAR 0 8
93675: PUSH
93676: LD_EXP 76
93680: PUSH
93681: LD_EXP 75
93685: PUSH
93686: LD_VAR 0 6
93690: ARRAY
93691: MINUS
93692: ST_TO_ADDR
// if not minesFreeAmount then
93693: LD_VAR 0 8
93697: NOT
93698: IFFALSE 93702
// exit ;
93700: GO 93973
// tmp := [ ] ;
93702: LD_ADDR_VAR 0 7
93706: PUSH
93707: EMPTY
93708: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
93709: LD_ADDR_VAR 0 5
93713: PUSH
93714: DOUBLE
93715: LD_INT 1
93717: DEC
93718: ST_TO_ADDR
93719: LD_VAR 0 8
93723: PUSH
93724: FOR_TO
93725: IFFALSE 93920
// begin _d := rand ( 0 , 5 ) ;
93727: LD_ADDR_VAR 0 11
93731: PUSH
93732: LD_INT 0
93734: PPUSH
93735: LD_INT 5
93737: PPUSH
93738: CALL_OW 12
93742: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
93743: LD_ADDR_VAR 0 12
93747: PUSH
93748: LD_INT 2
93750: PPUSH
93751: LD_INT 6
93753: PPUSH
93754: CALL_OW 12
93758: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
93759: LD_ADDR_VAR 0 9
93763: PUSH
93764: LD_VAR 0 2
93768: PPUSH
93769: LD_VAR 0 11
93773: PPUSH
93774: LD_VAR 0 12
93778: PPUSH
93779: CALL_OW 272
93783: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
93784: LD_ADDR_VAR 0 10
93788: PUSH
93789: LD_VAR 0 3
93793: PPUSH
93794: LD_VAR 0 11
93798: PPUSH
93799: LD_VAR 0 12
93803: PPUSH
93804: CALL_OW 273
93808: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
93809: LD_VAR 0 9
93813: PPUSH
93814: LD_VAR 0 10
93818: PPUSH
93819: CALL_OW 488
93823: PUSH
93824: LD_VAR 0 9
93828: PUSH
93829: LD_VAR 0 10
93833: PUSH
93834: EMPTY
93835: LIST
93836: LIST
93837: PUSH
93838: LD_VAR 0 7
93842: IN
93843: NOT
93844: AND
93845: PUSH
93846: LD_VAR 0 9
93850: PPUSH
93851: LD_VAR 0 10
93855: PPUSH
93856: CALL_OW 458
93860: NOT
93861: AND
93862: IFFALSE 93904
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
93864: LD_ADDR_VAR 0 7
93868: PUSH
93869: LD_VAR 0 7
93873: PPUSH
93874: LD_VAR 0 7
93878: PUSH
93879: LD_INT 1
93881: PLUS
93882: PPUSH
93883: LD_VAR 0 9
93887: PUSH
93888: LD_VAR 0 10
93892: PUSH
93893: EMPTY
93894: LIST
93895: LIST
93896: PPUSH
93897: CALL_OW 1
93901: ST_TO_ADDR
93902: GO 93918
// i := i - 1 ;
93904: LD_ADDR_VAR 0 5
93908: PUSH
93909: LD_VAR 0 5
93913: PUSH
93914: LD_INT 1
93916: MINUS
93917: ST_TO_ADDR
// end ;
93918: GO 93724
93920: POP
93921: POP
// for i in tmp do
93922: LD_ADDR_VAR 0 5
93926: PUSH
93927: LD_VAR 0 7
93931: PUSH
93932: FOR_IN
93933: IFFALSE 93971
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
93935: LD_VAR 0 1
93939: PPUSH
93940: LD_VAR 0 5
93944: PUSH
93945: LD_INT 1
93947: ARRAY
93948: PPUSH
93949: LD_VAR 0 5
93953: PUSH
93954: LD_INT 2
93956: ARRAY
93957: PPUSH
93958: CALL 92917 0 3
93962: NOT
93963: IFFALSE 93969
// exit ;
93965: POP
93966: POP
93967: GO 93973
93969: GO 93932
93971: POP
93972: POP
// end ;
93973: LD_VAR 0 4
93977: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
93978: LD_INT 0
93980: PPUSH
93981: PPUSH
93982: PPUSH
93983: PPUSH
93984: PPUSH
93985: PPUSH
93986: PPUSH
// if not GetClass ( unit ) = class_sniper then
93987: LD_VAR 0 1
93991: PPUSH
93992: CALL_OW 257
93996: PUSH
93997: LD_INT 5
93999: EQUAL
94000: NOT
94001: IFFALSE 94005
// exit ;
94003: GO 94393
// dist := 8 ;
94005: LD_ADDR_VAR 0 5
94009: PUSH
94010: LD_INT 8
94012: ST_TO_ADDR
// viewRange := 12 ;
94013: LD_ADDR_VAR 0 7
94017: PUSH
94018: LD_INT 12
94020: ST_TO_ADDR
// side := GetSide ( unit ) ;
94021: LD_ADDR_VAR 0 6
94025: PUSH
94026: LD_VAR 0 1
94030: PPUSH
94031: CALL_OW 255
94035: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
94036: LD_INT 61
94038: PPUSH
94039: LD_VAR 0 6
94043: PPUSH
94044: CALL_OW 321
94048: PUSH
94049: LD_INT 2
94051: EQUAL
94052: IFFALSE 94062
// viewRange := 16 ;
94054: LD_ADDR_VAR 0 7
94058: PUSH
94059: LD_INT 16
94061: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
94062: LD_VAR 0 1
94066: PPUSH
94067: LD_VAR 0 2
94071: PPUSH
94072: LD_VAR 0 3
94076: PPUSH
94077: CALL_OW 297
94081: PUSH
94082: LD_VAR 0 5
94086: GREATER
94087: IFFALSE 94166
// begin ComMoveXY ( unit , x , y ) ;
94089: LD_VAR 0 1
94093: PPUSH
94094: LD_VAR 0 2
94098: PPUSH
94099: LD_VAR 0 3
94103: PPUSH
94104: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
94108: LD_INT 35
94110: PPUSH
94111: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
94115: LD_VAR 0 1
94119: PPUSH
94120: LD_VAR 0 2
94124: PPUSH
94125: LD_VAR 0 3
94129: PPUSH
94130: CALL 47204 0 3
94134: NOT
94135: IFFALSE 94139
// exit ;
94137: GO 94393
// until GetDistUnitXY ( unit , x , y ) < dist ;
94139: LD_VAR 0 1
94143: PPUSH
94144: LD_VAR 0 2
94148: PPUSH
94149: LD_VAR 0 3
94153: PPUSH
94154: CALL_OW 297
94158: PUSH
94159: LD_VAR 0 5
94163: LESS
94164: IFFALSE 94108
// end ; ComTurnXY ( unit , x , y ) ;
94166: LD_VAR 0 1
94170: PPUSH
94171: LD_VAR 0 2
94175: PPUSH
94176: LD_VAR 0 3
94180: PPUSH
94181: CALL_OW 118
// wait ( 5 ) ;
94185: LD_INT 5
94187: PPUSH
94188: CALL_OW 67
// _d := GetDir ( unit ) ;
94192: LD_ADDR_VAR 0 10
94196: PUSH
94197: LD_VAR 0 1
94201: PPUSH
94202: CALL_OW 254
94206: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
94207: LD_ADDR_VAR 0 8
94211: PUSH
94212: LD_VAR 0 1
94216: PPUSH
94217: CALL_OW 250
94221: PPUSH
94222: LD_VAR 0 10
94226: PPUSH
94227: LD_VAR 0 5
94231: PPUSH
94232: CALL_OW 272
94236: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
94237: LD_ADDR_VAR 0 9
94241: PUSH
94242: LD_VAR 0 1
94246: PPUSH
94247: CALL_OW 251
94251: PPUSH
94252: LD_VAR 0 10
94256: PPUSH
94257: LD_VAR 0 5
94261: PPUSH
94262: CALL_OW 273
94266: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
94267: LD_VAR 0 8
94271: PPUSH
94272: LD_VAR 0 9
94276: PPUSH
94277: CALL_OW 488
94281: NOT
94282: IFFALSE 94286
// exit ;
94284: GO 94393
// ComAnimCustom ( unit , 1 ) ;
94286: LD_VAR 0 1
94290: PPUSH
94291: LD_INT 1
94293: PPUSH
94294: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
94298: LD_VAR 0 8
94302: PPUSH
94303: LD_VAR 0 9
94307: PPUSH
94308: LD_VAR 0 6
94312: PPUSH
94313: LD_VAR 0 7
94317: PPUSH
94318: CALL_OW 330
// repeat wait ( 1 ) ;
94322: LD_INT 1
94324: PPUSH
94325: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
94329: LD_VAR 0 1
94333: PPUSH
94334: CALL_OW 316
94338: PUSH
94339: LD_VAR 0 1
94343: PPUSH
94344: CALL_OW 314
94348: OR
94349: PUSH
94350: LD_VAR 0 1
94354: PPUSH
94355: CALL_OW 302
94359: NOT
94360: OR
94361: PUSH
94362: LD_VAR 0 1
94366: PPUSH
94367: CALL_OW 301
94371: OR
94372: IFFALSE 94322
// RemoveSeeing ( _x , _y , side ) ;
94374: LD_VAR 0 8
94378: PPUSH
94379: LD_VAR 0 9
94383: PPUSH
94384: LD_VAR 0 6
94388: PPUSH
94389: CALL_OW 331
// end ; end_of_file end_of_file
94393: LD_VAR 0 4
94397: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
94398: LD_VAR 0 1
94402: PUSH
94403: LD_INT 200
94405: DOUBLE
94406: GREATEREQUAL
94407: IFFALSE 94415
94409: LD_INT 299
94411: DOUBLE
94412: LESSEQUAL
94413: IFTRUE 94417
94415: GO 94449
94417: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
94418: LD_VAR 0 1
94422: PPUSH
94423: LD_VAR 0 2
94427: PPUSH
94428: LD_VAR 0 3
94432: PPUSH
94433: LD_VAR 0 4
94437: PPUSH
94438: LD_VAR 0 5
94442: PPUSH
94443: CALL 90485 0 5
94447: GO 94526
94449: LD_INT 300
94451: DOUBLE
94452: GREATEREQUAL
94453: IFFALSE 94461
94455: LD_INT 399
94457: DOUBLE
94458: LESSEQUAL
94459: IFTRUE 94463
94461: GO 94525
94463: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
94464: LD_VAR 0 1
94468: PPUSH
94469: LD_VAR 0 2
94473: PPUSH
94474: LD_VAR 0 3
94478: PPUSH
94479: LD_VAR 0 4
94483: PPUSH
94484: LD_VAR 0 5
94488: PPUSH
94489: LD_VAR 0 6
94493: PPUSH
94494: LD_VAR 0 7
94498: PPUSH
94499: LD_VAR 0 8
94503: PPUSH
94504: LD_VAR 0 9
94508: PPUSH
94509: LD_VAR 0 10
94513: PPUSH
94514: LD_VAR 0 11
94518: PPUSH
94519: CALL 106919 0 11
94523: GO 94526
94525: POP
// end ;
94526: PPOPN 11
94528: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
94529: LD_VAR 0 1
94533: PPUSH
94534: LD_VAR 0 2
94538: PPUSH
94539: LD_VAR 0 3
94543: PPUSH
94544: LD_VAR 0 4
94548: PPUSH
94549: LD_VAR 0 5
94553: PPUSH
94554: CALL 90221 0 5
// end ; end_of_file
94558: PPOPN 5
94560: END
// every 0 0$1 do
94561: GO 94563
94563: DISABLE
// begin enable ;
94564: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
94565: LD_STRING updateTimer(
94567: PUSH
94568: LD_OWVAR 1
94572: STR
94573: PUSH
94574: LD_STRING );
94576: STR
94577: PPUSH
94578: CALL_OW 559
// end ;
94582: END
// export function SOS_MapStart ( ) ; begin
94583: LD_INT 0
94585: PPUSH
// if streamModeActive then
94586: LD_EXP 77
94590: IFFALSE 94599
// DefineStreamItems ( true ) ;
94592: LD_INT 1
94594: PPUSH
94595: CALL 96253 0 1
// UpdateFactoryWaypoints ( ) ;
94599: CALL 109114 0 0
// UpdateWarehouseGatheringPoints ( ) ;
94603: CALL 109371 0 0
// end ;
94607: LD_VAR 0 1
94611: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
94612: LD_INT 0
94614: PPUSH
// if p2 = 100 then
94615: LD_VAR 0 2
94619: PUSH
94620: LD_INT 100
94622: EQUAL
94623: IFFALSE 95626
// begin if not StreamModeActive then
94625: LD_EXP 77
94629: NOT
94630: IFFALSE 94640
// StreamModeActive := true ;
94632: LD_ADDR_EXP 77
94636: PUSH
94637: LD_INT 1
94639: ST_TO_ADDR
// if p3 = 0 then
94640: LD_VAR 0 3
94644: PUSH
94645: LD_INT 0
94647: EQUAL
94648: IFFALSE 94654
// InitStreamMode ;
94650: CALL 95789 0 0
// if p3 = 1 then
94654: LD_VAR 0 3
94658: PUSH
94659: LD_INT 1
94661: EQUAL
94662: IFFALSE 94672
// sRocket := true ;
94664: LD_ADDR_EXP 82
94668: PUSH
94669: LD_INT 1
94671: ST_TO_ADDR
// if p3 = 2 then
94672: LD_VAR 0 3
94676: PUSH
94677: LD_INT 2
94679: EQUAL
94680: IFFALSE 94690
// sSpeed := true ;
94682: LD_ADDR_EXP 81
94686: PUSH
94687: LD_INT 1
94689: ST_TO_ADDR
// if p3 = 3 then
94690: LD_VAR 0 3
94694: PUSH
94695: LD_INT 3
94697: EQUAL
94698: IFFALSE 94708
// sEngine := true ;
94700: LD_ADDR_EXP 83
94704: PUSH
94705: LD_INT 1
94707: ST_TO_ADDR
// if p3 = 4 then
94708: LD_VAR 0 3
94712: PUSH
94713: LD_INT 4
94715: EQUAL
94716: IFFALSE 94726
// sSpec := true ;
94718: LD_ADDR_EXP 80
94722: PUSH
94723: LD_INT 1
94725: ST_TO_ADDR
// if p3 = 5 then
94726: LD_VAR 0 3
94730: PUSH
94731: LD_INT 5
94733: EQUAL
94734: IFFALSE 94744
// sLevel := true ;
94736: LD_ADDR_EXP 84
94740: PUSH
94741: LD_INT 1
94743: ST_TO_ADDR
// if p3 = 6 then
94744: LD_VAR 0 3
94748: PUSH
94749: LD_INT 6
94751: EQUAL
94752: IFFALSE 94762
// sArmoury := true ;
94754: LD_ADDR_EXP 85
94758: PUSH
94759: LD_INT 1
94761: ST_TO_ADDR
// if p3 = 7 then
94762: LD_VAR 0 3
94766: PUSH
94767: LD_INT 7
94769: EQUAL
94770: IFFALSE 94780
// sRadar := true ;
94772: LD_ADDR_EXP 86
94776: PUSH
94777: LD_INT 1
94779: ST_TO_ADDR
// if p3 = 8 then
94780: LD_VAR 0 3
94784: PUSH
94785: LD_INT 8
94787: EQUAL
94788: IFFALSE 94798
// sBunker := true ;
94790: LD_ADDR_EXP 87
94794: PUSH
94795: LD_INT 1
94797: ST_TO_ADDR
// if p3 = 9 then
94798: LD_VAR 0 3
94802: PUSH
94803: LD_INT 9
94805: EQUAL
94806: IFFALSE 94816
// sHack := true ;
94808: LD_ADDR_EXP 88
94812: PUSH
94813: LD_INT 1
94815: ST_TO_ADDR
// if p3 = 10 then
94816: LD_VAR 0 3
94820: PUSH
94821: LD_INT 10
94823: EQUAL
94824: IFFALSE 94834
// sFire := true ;
94826: LD_ADDR_EXP 89
94830: PUSH
94831: LD_INT 1
94833: ST_TO_ADDR
// if p3 = 11 then
94834: LD_VAR 0 3
94838: PUSH
94839: LD_INT 11
94841: EQUAL
94842: IFFALSE 94852
// sRefresh := true ;
94844: LD_ADDR_EXP 90
94848: PUSH
94849: LD_INT 1
94851: ST_TO_ADDR
// if p3 = 12 then
94852: LD_VAR 0 3
94856: PUSH
94857: LD_INT 12
94859: EQUAL
94860: IFFALSE 94870
// sExp := true ;
94862: LD_ADDR_EXP 91
94866: PUSH
94867: LD_INT 1
94869: ST_TO_ADDR
// if p3 = 13 then
94870: LD_VAR 0 3
94874: PUSH
94875: LD_INT 13
94877: EQUAL
94878: IFFALSE 94888
// sDepot := true ;
94880: LD_ADDR_EXP 92
94884: PUSH
94885: LD_INT 1
94887: ST_TO_ADDR
// if p3 = 14 then
94888: LD_VAR 0 3
94892: PUSH
94893: LD_INT 14
94895: EQUAL
94896: IFFALSE 94906
// sFlag := true ;
94898: LD_ADDR_EXP 93
94902: PUSH
94903: LD_INT 1
94905: ST_TO_ADDR
// if p3 = 15 then
94906: LD_VAR 0 3
94910: PUSH
94911: LD_INT 15
94913: EQUAL
94914: IFFALSE 94924
// sKamikadze := true ;
94916: LD_ADDR_EXP 101
94920: PUSH
94921: LD_INT 1
94923: ST_TO_ADDR
// if p3 = 16 then
94924: LD_VAR 0 3
94928: PUSH
94929: LD_INT 16
94931: EQUAL
94932: IFFALSE 94942
// sTroll := true ;
94934: LD_ADDR_EXP 102
94938: PUSH
94939: LD_INT 1
94941: ST_TO_ADDR
// if p3 = 17 then
94942: LD_VAR 0 3
94946: PUSH
94947: LD_INT 17
94949: EQUAL
94950: IFFALSE 94960
// sSlow := true ;
94952: LD_ADDR_EXP 103
94956: PUSH
94957: LD_INT 1
94959: ST_TO_ADDR
// if p3 = 18 then
94960: LD_VAR 0 3
94964: PUSH
94965: LD_INT 18
94967: EQUAL
94968: IFFALSE 94978
// sLack := true ;
94970: LD_ADDR_EXP 104
94974: PUSH
94975: LD_INT 1
94977: ST_TO_ADDR
// if p3 = 19 then
94978: LD_VAR 0 3
94982: PUSH
94983: LD_INT 19
94985: EQUAL
94986: IFFALSE 94996
// sTank := true ;
94988: LD_ADDR_EXP 106
94992: PUSH
94993: LD_INT 1
94995: ST_TO_ADDR
// if p3 = 20 then
94996: LD_VAR 0 3
95000: PUSH
95001: LD_INT 20
95003: EQUAL
95004: IFFALSE 95014
// sRemote := true ;
95006: LD_ADDR_EXP 107
95010: PUSH
95011: LD_INT 1
95013: ST_TO_ADDR
// if p3 = 21 then
95014: LD_VAR 0 3
95018: PUSH
95019: LD_INT 21
95021: EQUAL
95022: IFFALSE 95032
// sPowell := true ;
95024: LD_ADDR_EXP 108
95028: PUSH
95029: LD_INT 1
95031: ST_TO_ADDR
// if p3 = 22 then
95032: LD_VAR 0 3
95036: PUSH
95037: LD_INT 22
95039: EQUAL
95040: IFFALSE 95050
// sTeleport := true ;
95042: LD_ADDR_EXP 111
95046: PUSH
95047: LD_INT 1
95049: ST_TO_ADDR
// if p3 = 23 then
95050: LD_VAR 0 3
95054: PUSH
95055: LD_INT 23
95057: EQUAL
95058: IFFALSE 95068
// sOilTower := true ;
95060: LD_ADDR_EXP 113
95064: PUSH
95065: LD_INT 1
95067: ST_TO_ADDR
// if p3 = 24 then
95068: LD_VAR 0 3
95072: PUSH
95073: LD_INT 24
95075: EQUAL
95076: IFFALSE 95086
// sShovel := true ;
95078: LD_ADDR_EXP 114
95082: PUSH
95083: LD_INT 1
95085: ST_TO_ADDR
// if p3 = 25 then
95086: LD_VAR 0 3
95090: PUSH
95091: LD_INT 25
95093: EQUAL
95094: IFFALSE 95104
// sSheik := true ;
95096: LD_ADDR_EXP 115
95100: PUSH
95101: LD_INT 1
95103: ST_TO_ADDR
// if p3 = 26 then
95104: LD_VAR 0 3
95108: PUSH
95109: LD_INT 26
95111: EQUAL
95112: IFFALSE 95122
// sEarthquake := true ;
95114: LD_ADDR_EXP 117
95118: PUSH
95119: LD_INT 1
95121: ST_TO_ADDR
// if p3 = 27 then
95122: LD_VAR 0 3
95126: PUSH
95127: LD_INT 27
95129: EQUAL
95130: IFFALSE 95140
// sAI := true ;
95132: LD_ADDR_EXP 118
95136: PUSH
95137: LD_INT 1
95139: ST_TO_ADDR
// if p3 = 28 then
95140: LD_VAR 0 3
95144: PUSH
95145: LD_INT 28
95147: EQUAL
95148: IFFALSE 95158
// sCargo := true ;
95150: LD_ADDR_EXP 121
95154: PUSH
95155: LD_INT 1
95157: ST_TO_ADDR
// if p3 = 29 then
95158: LD_VAR 0 3
95162: PUSH
95163: LD_INT 29
95165: EQUAL
95166: IFFALSE 95176
// sDLaser := true ;
95168: LD_ADDR_EXP 122
95172: PUSH
95173: LD_INT 1
95175: ST_TO_ADDR
// if p3 = 30 then
95176: LD_VAR 0 3
95180: PUSH
95181: LD_INT 30
95183: EQUAL
95184: IFFALSE 95194
// sExchange := true ;
95186: LD_ADDR_EXP 123
95190: PUSH
95191: LD_INT 1
95193: ST_TO_ADDR
// if p3 = 31 then
95194: LD_VAR 0 3
95198: PUSH
95199: LD_INT 31
95201: EQUAL
95202: IFFALSE 95212
// sFac := true ;
95204: LD_ADDR_EXP 124
95208: PUSH
95209: LD_INT 1
95211: ST_TO_ADDR
// if p3 = 32 then
95212: LD_VAR 0 3
95216: PUSH
95217: LD_INT 32
95219: EQUAL
95220: IFFALSE 95230
// sPower := true ;
95222: LD_ADDR_EXP 125
95226: PUSH
95227: LD_INT 1
95229: ST_TO_ADDR
// if p3 = 33 then
95230: LD_VAR 0 3
95234: PUSH
95235: LD_INT 33
95237: EQUAL
95238: IFFALSE 95248
// sRandom := true ;
95240: LD_ADDR_EXP 126
95244: PUSH
95245: LD_INT 1
95247: ST_TO_ADDR
// if p3 = 34 then
95248: LD_VAR 0 3
95252: PUSH
95253: LD_INT 34
95255: EQUAL
95256: IFFALSE 95266
// sShield := true ;
95258: LD_ADDR_EXP 127
95262: PUSH
95263: LD_INT 1
95265: ST_TO_ADDR
// if p3 = 35 then
95266: LD_VAR 0 3
95270: PUSH
95271: LD_INT 35
95273: EQUAL
95274: IFFALSE 95284
// sTime := true ;
95276: LD_ADDR_EXP 128
95280: PUSH
95281: LD_INT 1
95283: ST_TO_ADDR
// if p3 = 36 then
95284: LD_VAR 0 3
95288: PUSH
95289: LD_INT 36
95291: EQUAL
95292: IFFALSE 95302
// sTools := true ;
95294: LD_ADDR_EXP 129
95298: PUSH
95299: LD_INT 1
95301: ST_TO_ADDR
// if p3 = 101 then
95302: LD_VAR 0 3
95306: PUSH
95307: LD_INT 101
95309: EQUAL
95310: IFFALSE 95320
// sSold := true ;
95312: LD_ADDR_EXP 94
95316: PUSH
95317: LD_INT 1
95319: ST_TO_ADDR
// if p3 = 102 then
95320: LD_VAR 0 3
95324: PUSH
95325: LD_INT 102
95327: EQUAL
95328: IFFALSE 95338
// sDiff := true ;
95330: LD_ADDR_EXP 95
95334: PUSH
95335: LD_INT 1
95337: ST_TO_ADDR
// if p3 = 103 then
95338: LD_VAR 0 3
95342: PUSH
95343: LD_INT 103
95345: EQUAL
95346: IFFALSE 95356
// sFog := true ;
95348: LD_ADDR_EXP 98
95352: PUSH
95353: LD_INT 1
95355: ST_TO_ADDR
// if p3 = 104 then
95356: LD_VAR 0 3
95360: PUSH
95361: LD_INT 104
95363: EQUAL
95364: IFFALSE 95374
// sReset := true ;
95366: LD_ADDR_EXP 99
95370: PUSH
95371: LD_INT 1
95373: ST_TO_ADDR
// if p3 = 105 then
95374: LD_VAR 0 3
95378: PUSH
95379: LD_INT 105
95381: EQUAL
95382: IFFALSE 95392
// sSun := true ;
95384: LD_ADDR_EXP 100
95388: PUSH
95389: LD_INT 1
95391: ST_TO_ADDR
// if p3 = 106 then
95392: LD_VAR 0 3
95396: PUSH
95397: LD_INT 106
95399: EQUAL
95400: IFFALSE 95410
// sTiger := true ;
95402: LD_ADDR_EXP 96
95406: PUSH
95407: LD_INT 1
95409: ST_TO_ADDR
// if p3 = 107 then
95410: LD_VAR 0 3
95414: PUSH
95415: LD_INT 107
95417: EQUAL
95418: IFFALSE 95428
// sBomb := true ;
95420: LD_ADDR_EXP 97
95424: PUSH
95425: LD_INT 1
95427: ST_TO_ADDR
// if p3 = 108 then
95428: LD_VAR 0 3
95432: PUSH
95433: LD_INT 108
95435: EQUAL
95436: IFFALSE 95446
// sWound := true ;
95438: LD_ADDR_EXP 105
95442: PUSH
95443: LD_INT 1
95445: ST_TO_ADDR
// if p3 = 109 then
95446: LD_VAR 0 3
95450: PUSH
95451: LD_INT 109
95453: EQUAL
95454: IFFALSE 95464
// sBetray := true ;
95456: LD_ADDR_EXP 109
95460: PUSH
95461: LD_INT 1
95463: ST_TO_ADDR
// if p3 = 110 then
95464: LD_VAR 0 3
95468: PUSH
95469: LD_INT 110
95471: EQUAL
95472: IFFALSE 95482
// sContamin := true ;
95474: LD_ADDR_EXP 110
95478: PUSH
95479: LD_INT 1
95481: ST_TO_ADDR
// if p3 = 111 then
95482: LD_VAR 0 3
95486: PUSH
95487: LD_INT 111
95489: EQUAL
95490: IFFALSE 95500
// sOil := true ;
95492: LD_ADDR_EXP 112
95496: PUSH
95497: LD_INT 1
95499: ST_TO_ADDR
// if p3 = 112 then
95500: LD_VAR 0 3
95504: PUSH
95505: LD_INT 112
95507: EQUAL
95508: IFFALSE 95518
// sStu := true ;
95510: LD_ADDR_EXP 116
95514: PUSH
95515: LD_INT 1
95517: ST_TO_ADDR
// if p3 = 113 then
95518: LD_VAR 0 3
95522: PUSH
95523: LD_INT 113
95525: EQUAL
95526: IFFALSE 95536
// sBazooka := true ;
95528: LD_ADDR_EXP 119
95532: PUSH
95533: LD_INT 1
95535: ST_TO_ADDR
// if p3 = 114 then
95536: LD_VAR 0 3
95540: PUSH
95541: LD_INT 114
95543: EQUAL
95544: IFFALSE 95554
// sMortar := true ;
95546: LD_ADDR_EXP 120
95550: PUSH
95551: LD_INT 1
95553: ST_TO_ADDR
// if p3 = 115 then
95554: LD_VAR 0 3
95558: PUSH
95559: LD_INT 115
95561: EQUAL
95562: IFFALSE 95572
// sRanger := true ;
95564: LD_ADDR_EXP 130
95568: PUSH
95569: LD_INT 1
95571: ST_TO_ADDR
// if p3 = 116 then
95572: LD_VAR 0 3
95576: PUSH
95577: LD_INT 116
95579: EQUAL
95580: IFFALSE 95590
// sComputer := true ;
95582: LD_ADDR_EXP 131
95586: PUSH
95587: LD_INT 1
95589: ST_TO_ADDR
// if p3 = 117 then
95590: LD_VAR 0 3
95594: PUSH
95595: LD_INT 117
95597: EQUAL
95598: IFFALSE 95608
// s30 := true ;
95600: LD_ADDR_EXP 132
95604: PUSH
95605: LD_INT 1
95607: ST_TO_ADDR
// if p3 = 118 then
95608: LD_VAR 0 3
95612: PUSH
95613: LD_INT 118
95615: EQUAL
95616: IFFALSE 95626
// s60 := true ;
95618: LD_ADDR_EXP 133
95622: PUSH
95623: LD_INT 1
95625: ST_TO_ADDR
// end ; if p2 = 101 then
95626: LD_VAR 0 2
95630: PUSH
95631: LD_INT 101
95633: EQUAL
95634: IFFALSE 95762
// begin case p3 of 1 :
95636: LD_VAR 0 3
95640: PUSH
95641: LD_INT 1
95643: DOUBLE
95644: EQUAL
95645: IFTRUE 95649
95647: GO 95656
95649: POP
// hHackUnlimitedResources ; 2 :
95650: CALL 107860 0 0
95654: GO 95762
95656: LD_INT 2
95658: DOUBLE
95659: EQUAL
95660: IFTRUE 95664
95662: GO 95671
95664: POP
// hHackSetLevel10 ; 3 :
95665: CALL 107993 0 0
95669: GO 95762
95671: LD_INT 3
95673: DOUBLE
95674: EQUAL
95675: IFTRUE 95679
95677: GO 95686
95679: POP
// hHackSetLevel10YourUnits ; 4 :
95680: CALL 108078 0 0
95684: GO 95762
95686: LD_INT 4
95688: DOUBLE
95689: EQUAL
95690: IFTRUE 95694
95692: GO 95701
95694: POP
// hHackInvincible ; 5 :
95695: CALL 108526 0 0
95699: GO 95762
95701: LD_INT 5
95703: DOUBLE
95704: EQUAL
95705: IFTRUE 95709
95707: GO 95716
95709: POP
// hHackInvisible ; 6 :
95710: CALL 108637 0 0
95714: GO 95762
95716: LD_INT 6
95718: DOUBLE
95719: EQUAL
95720: IFTRUE 95724
95722: GO 95731
95724: POP
// hHackChangeYourSide ; 7 :
95725: CALL 108694 0 0
95729: GO 95762
95731: LD_INT 7
95733: DOUBLE
95734: EQUAL
95735: IFTRUE 95739
95737: GO 95746
95739: POP
// hHackChangeUnitSide ; 8 :
95740: CALL 108736 0 0
95744: GO 95762
95746: LD_INT 8
95748: DOUBLE
95749: EQUAL
95750: IFTRUE 95754
95752: GO 95761
95754: POP
// hHackFog ; end ;
95755: CALL 108837 0 0
95759: GO 95762
95761: POP
// end ; end ;
95762: LD_VAR 0 7
95766: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
95767: GO 95769
95769: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
95770: LD_STRING initStreamRollete();
95772: PPUSH
95773: CALL_OW 559
// InitStreamMode ;
95777: CALL 95789 0 0
// DefineStreamItems ( false ) ;
95781: LD_INT 0
95783: PPUSH
95784: CALL 96253 0 1
// end ;
95788: END
// function InitStreamMode ; begin
95789: LD_INT 0
95791: PPUSH
// streamModeActive := false ;
95792: LD_ADDR_EXP 77
95796: PUSH
95797: LD_INT 0
95799: ST_TO_ADDR
// normalCounter := 36 ;
95800: LD_ADDR_EXP 78
95804: PUSH
95805: LD_INT 36
95807: ST_TO_ADDR
// hardcoreCounter := 18 ;
95808: LD_ADDR_EXP 79
95812: PUSH
95813: LD_INT 18
95815: ST_TO_ADDR
// sRocket := false ;
95816: LD_ADDR_EXP 82
95820: PUSH
95821: LD_INT 0
95823: ST_TO_ADDR
// sSpeed := false ;
95824: LD_ADDR_EXP 81
95828: PUSH
95829: LD_INT 0
95831: ST_TO_ADDR
// sEngine := false ;
95832: LD_ADDR_EXP 83
95836: PUSH
95837: LD_INT 0
95839: ST_TO_ADDR
// sSpec := false ;
95840: LD_ADDR_EXP 80
95844: PUSH
95845: LD_INT 0
95847: ST_TO_ADDR
// sLevel := false ;
95848: LD_ADDR_EXP 84
95852: PUSH
95853: LD_INT 0
95855: ST_TO_ADDR
// sArmoury := false ;
95856: LD_ADDR_EXP 85
95860: PUSH
95861: LD_INT 0
95863: ST_TO_ADDR
// sRadar := false ;
95864: LD_ADDR_EXP 86
95868: PUSH
95869: LD_INT 0
95871: ST_TO_ADDR
// sBunker := false ;
95872: LD_ADDR_EXP 87
95876: PUSH
95877: LD_INT 0
95879: ST_TO_ADDR
// sHack := false ;
95880: LD_ADDR_EXP 88
95884: PUSH
95885: LD_INT 0
95887: ST_TO_ADDR
// sFire := false ;
95888: LD_ADDR_EXP 89
95892: PUSH
95893: LD_INT 0
95895: ST_TO_ADDR
// sRefresh := false ;
95896: LD_ADDR_EXP 90
95900: PUSH
95901: LD_INT 0
95903: ST_TO_ADDR
// sExp := false ;
95904: LD_ADDR_EXP 91
95908: PUSH
95909: LD_INT 0
95911: ST_TO_ADDR
// sDepot := false ;
95912: LD_ADDR_EXP 92
95916: PUSH
95917: LD_INT 0
95919: ST_TO_ADDR
// sFlag := false ;
95920: LD_ADDR_EXP 93
95924: PUSH
95925: LD_INT 0
95927: ST_TO_ADDR
// sKamikadze := false ;
95928: LD_ADDR_EXP 101
95932: PUSH
95933: LD_INT 0
95935: ST_TO_ADDR
// sTroll := false ;
95936: LD_ADDR_EXP 102
95940: PUSH
95941: LD_INT 0
95943: ST_TO_ADDR
// sSlow := false ;
95944: LD_ADDR_EXP 103
95948: PUSH
95949: LD_INT 0
95951: ST_TO_ADDR
// sLack := false ;
95952: LD_ADDR_EXP 104
95956: PUSH
95957: LD_INT 0
95959: ST_TO_ADDR
// sTank := false ;
95960: LD_ADDR_EXP 106
95964: PUSH
95965: LD_INT 0
95967: ST_TO_ADDR
// sRemote := false ;
95968: LD_ADDR_EXP 107
95972: PUSH
95973: LD_INT 0
95975: ST_TO_ADDR
// sPowell := false ;
95976: LD_ADDR_EXP 108
95980: PUSH
95981: LD_INT 0
95983: ST_TO_ADDR
// sTeleport := false ;
95984: LD_ADDR_EXP 111
95988: PUSH
95989: LD_INT 0
95991: ST_TO_ADDR
// sOilTower := false ;
95992: LD_ADDR_EXP 113
95996: PUSH
95997: LD_INT 0
95999: ST_TO_ADDR
// sShovel := false ;
96000: LD_ADDR_EXP 114
96004: PUSH
96005: LD_INT 0
96007: ST_TO_ADDR
// sSheik := false ;
96008: LD_ADDR_EXP 115
96012: PUSH
96013: LD_INT 0
96015: ST_TO_ADDR
// sEarthquake := false ;
96016: LD_ADDR_EXP 117
96020: PUSH
96021: LD_INT 0
96023: ST_TO_ADDR
// sAI := false ;
96024: LD_ADDR_EXP 118
96028: PUSH
96029: LD_INT 0
96031: ST_TO_ADDR
// sCargo := false ;
96032: LD_ADDR_EXP 121
96036: PUSH
96037: LD_INT 0
96039: ST_TO_ADDR
// sDLaser := false ;
96040: LD_ADDR_EXP 122
96044: PUSH
96045: LD_INT 0
96047: ST_TO_ADDR
// sExchange := false ;
96048: LD_ADDR_EXP 123
96052: PUSH
96053: LD_INT 0
96055: ST_TO_ADDR
// sFac := false ;
96056: LD_ADDR_EXP 124
96060: PUSH
96061: LD_INT 0
96063: ST_TO_ADDR
// sPower := false ;
96064: LD_ADDR_EXP 125
96068: PUSH
96069: LD_INT 0
96071: ST_TO_ADDR
// sRandom := false ;
96072: LD_ADDR_EXP 126
96076: PUSH
96077: LD_INT 0
96079: ST_TO_ADDR
// sShield := false ;
96080: LD_ADDR_EXP 127
96084: PUSH
96085: LD_INT 0
96087: ST_TO_ADDR
// sTime := false ;
96088: LD_ADDR_EXP 128
96092: PUSH
96093: LD_INT 0
96095: ST_TO_ADDR
// sTools := false ;
96096: LD_ADDR_EXP 129
96100: PUSH
96101: LD_INT 0
96103: ST_TO_ADDR
// sSold := false ;
96104: LD_ADDR_EXP 94
96108: PUSH
96109: LD_INT 0
96111: ST_TO_ADDR
// sDiff := false ;
96112: LD_ADDR_EXP 95
96116: PUSH
96117: LD_INT 0
96119: ST_TO_ADDR
// sFog := false ;
96120: LD_ADDR_EXP 98
96124: PUSH
96125: LD_INT 0
96127: ST_TO_ADDR
// sReset := false ;
96128: LD_ADDR_EXP 99
96132: PUSH
96133: LD_INT 0
96135: ST_TO_ADDR
// sSun := false ;
96136: LD_ADDR_EXP 100
96140: PUSH
96141: LD_INT 0
96143: ST_TO_ADDR
// sTiger := false ;
96144: LD_ADDR_EXP 96
96148: PUSH
96149: LD_INT 0
96151: ST_TO_ADDR
// sBomb := false ;
96152: LD_ADDR_EXP 97
96156: PUSH
96157: LD_INT 0
96159: ST_TO_ADDR
// sWound := false ;
96160: LD_ADDR_EXP 105
96164: PUSH
96165: LD_INT 0
96167: ST_TO_ADDR
// sBetray := false ;
96168: LD_ADDR_EXP 109
96172: PUSH
96173: LD_INT 0
96175: ST_TO_ADDR
// sContamin := false ;
96176: LD_ADDR_EXP 110
96180: PUSH
96181: LD_INT 0
96183: ST_TO_ADDR
// sOil := false ;
96184: LD_ADDR_EXP 112
96188: PUSH
96189: LD_INT 0
96191: ST_TO_ADDR
// sStu := false ;
96192: LD_ADDR_EXP 116
96196: PUSH
96197: LD_INT 0
96199: ST_TO_ADDR
// sBazooka := false ;
96200: LD_ADDR_EXP 119
96204: PUSH
96205: LD_INT 0
96207: ST_TO_ADDR
// sMortar := false ;
96208: LD_ADDR_EXP 120
96212: PUSH
96213: LD_INT 0
96215: ST_TO_ADDR
// sRanger := false ;
96216: LD_ADDR_EXP 130
96220: PUSH
96221: LD_INT 0
96223: ST_TO_ADDR
// sComputer := false ;
96224: LD_ADDR_EXP 131
96228: PUSH
96229: LD_INT 0
96231: ST_TO_ADDR
// s30 := false ;
96232: LD_ADDR_EXP 132
96236: PUSH
96237: LD_INT 0
96239: ST_TO_ADDR
// s60 := false ;
96240: LD_ADDR_EXP 133
96244: PUSH
96245: LD_INT 0
96247: ST_TO_ADDR
// end ;
96248: LD_VAR 0 1
96252: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
96253: LD_INT 0
96255: PPUSH
96256: PPUSH
96257: PPUSH
96258: PPUSH
96259: PPUSH
96260: PPUSH
96261: PPUSH
// result := [ ] ;
96262: LD_ADDR_VAR 0 2
96266: PUSH
96267: EMPTY
96268: ST_TO_ADDR
// if campaign_id = 1 then
96269: LD_OWVAR 69
96273: PUSH
96274: LD_INT 1
96276: EQUAL
96277: IFFALSE 99443
// begin case mission_number of 1 :
96279: LD_OWVAR 70
96283: PUSH
96284: LD_INT 1
96286: DOUBLE
96287: EQUAL
96288: IFTRUE 96292
96290: GO 96368
96292: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
96293: LD_ADDR_VAR 0 2
96297: PUSH
96298: LD_INT 2
96300: PUSH
96301: LD_INT 4
96303: PUSH
96304: LD_INT 11
96306: PUSH
96307: LD_INT 12
96309: PUSH
96310: LD_INT 15
96312: PUSH
96313: LD_INT 16
96315: PUSH
96316: LD_INT 22
96318: PUSH
96319: LD_INT 23
96321: PUSH
96322: LD_INT 26
96324: PUSH
96325: EMPTY
96326: LIST
96327: LIST
96328: LIST
96329: LIST
96330: LIST
96331: LIST
96332: LIST
96333: LIST
96334: LIST
96335: PUSH
96336: LD_INT 101
96338: PUSH
96339: LD_INT 102
96341: PUSH
96342: LD_INT 106
96344: PUSH
96345: LD_INT 116
96347: PUSH
96348: LD_INT 117
96350: PUSH
96351: LD_INT 118
96353: PUSH
96354: EMPTY
96355: LIST
96356: LIST
96357: LIST
96358: LIST
96359: LIST
96360: LIST
96361: PUSH
96362: EMPTY
96363: LIST
96364: LIST
96365: ST_TO_ADDR
96366: GO 99441
96368: LD_INT 2
96370: DOUBLE
96371: EQUAL
96372: IFTRUE 96376
96374: GO 96460
96376: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
96377: LD_ADDR_VAR 0 2
96381: PUSH
96382: LD_INT 2
96384: PUSH
96385: LD_INT 4
96387: PUSH
96388: LD_INT 11
96390: PUSH
96391: LD_INT 12
96393: PUSH
96394: LD_INT 15
96396: PUSH
96397: LD_INT 16
96399: PUSH
96400: LD_INT 22
96402: PUSH
96403: LD_INT 23
96405: PUSH
96406: LD_INT 26
96408: PUSH
96409: EMPTY
96410: LIST
96411: LIST
96412: LIST
96413: LIST
96414: LIST
96415: LIST
96416: LIST
96417: LIST
96418: LIST
96419: PUSH
96420: LD_INT 101
96422: PUSH
96423: LD_INT 102
96425: PUSH
96426: LD_INT 105
96428: PUSH
96429: LD_INT 106
96431: PUSH
96432: LD_INT 108
96434: PUSH
96435: LD_INT 116
96437: PUSH
96438: LD_INT 117
96440: PUSH
96441: LD_INT 118
96443: PUSH
96444: EMPTY
96445: LIST
96446: LIST
96447: LIST
96448: LIST
96449: LIST
96450: LIST
96451: LIST
96452: LIST
96453: PUSH
96454: EMPTY
96455: LIST
96456: LIST
96457: ST_TO_ADDR
96458: GO 99441
96460: LD_INT 3
96462: DOUBLE
96463: EQUAL
96464: IFTRUE 96468
96466: GO 96556
96468: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
96469: LD_ADDR_VAR 0 2
96473: PUSH
96474: LD_INT 2
96476: PUSH
96477: LD_INT 4
96479: PUSH
96480: LD_INT 5
96482: PUSH
96483: LD_INT 11
96485: PUSH
96486: LD_INT 12
96488: PUSH
96489: LD_INT 15
96491: PUSH
96492: LD_INT 16
96494: PUSH
96495: LD_INT 22
96497: PUSH
96498: LD_INT 26
96500: PUSH
96501: LD_INT 36
96503: PUSH
96504: EMPTY
96505: LIST
96506: LIST
96507: LIST
96508: LIST
96509: LIST
96510: LIST
96511: LIST
96512: LIST
96513: LIST
96514: LIST
96515: PUSH
96516: LD_INT 101
96518: PUSH
96519: LD_INT 102
96521: PUSH
96522: LD_INT 105
96524: PUSH
96525: LD_INT 106
96527: PUSH
96528: LD_INT 108
96530: PUSH
96531: LD_INT 116
96533: PUSH
96534: LD_INT 117
96536: PUSH
96537: LD_INT 118
96539: PUSH
96540: EMPTY
96541: LIST
96542: LIST
96543: LIST
96544: LIST
96545: LIST
96546: LIST
96547: LIST
96548: LIST
96549: PUSH
96550: EMPTY
96551: LIST
96552: LIST
96553: ST_TO_ADDR
96554: GO 99441
96556: LD_INT 4
96558: DOUBLE
96559: EQUAL
96560: IFTRUE 96564
96562: GO 96660
96564: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
96565: LD_ADDR_VAR 0 2
96569: PUSH
96570: LD_INT 2
96572: PUSH
96573: LD_INT 4
96575: PUSH
96576: LD_INT 5
96578: PUSH
96579: LD_INT 8
96581: PUSH
96582: LD_INT 11
96584: PUSH
96585: LD_INT 12
96587: PUSH
96588: LD_INT 15
96590: PUSH
96591: LD_INT 16
96593: PUSH
96594: LD_INT 22
96596: PUSH
96597: LD_INT 23
96599: PUSH
96600: LD_INT 26
96602: PUSH
96603: LD_INT 36
96605: PUSH
96606: EMPTY
96607: LIST
96608: LIST
96609: LIST
96610: LIST
96611: LIST
96612: LIST
96613: LIST
96614: LIST
96615: LIST
96616: LIST
96617: LIST
96618: LIST
96619: PUSH
96620: LD_INT 101
96622: PUSH
96623: LD_INT 102
96625: PUSH
96626: LD_INT 105
96628: PUSH
96629: LD_INT 106
96631: PUSH
96632: LD_INT 108
96634: PUSH
96635: LD_INT 116
96637: PUSH
96638: LD_INT 117
96640: PUSH
96641: LD_INT 118
96643: PUSH
96644: EMPTY
96645: LIST
96646: LIST
96647: LIST
96648: LIST
96649: LIST
96650: LIST
96651: LIST
96652: LIST
96653: PUSH
96654: EMPTY
96655: LIST
96656: LIST
96657: ST_TO_ADDR
96658: GO 99441
96660: LD_INT 5
96662: DOUBLE
96663: EQUAL
96664: IFTRUE 96668
96666: GO 96780
96668: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
96669: LD_ADDR_VAR 0 2
96673: PUSH
96674: LD_INT 2
96676: PUSH
96677: LD_INT 4
96679: PUSH
96680: LD_INT 5
96682: PUSH
96683: LD_INT 6
96685: PUSH
96686: LD_INT 8
96688: PUSH
96689: LD_INT 11
96691: PUSH
96692: LD_INT 12
96694: PUSH
96695: LD_INT 15
96697: PUSH
96698: LD_INT 16
96700: PUSH
96701: LD_INT 22
96703: PUSH
96704: LD_INT 23
96706: PUSH
96707: LD_INT 25
96709: PUSH
96710: LD_INT 26
96712: PUSH
96713: LD_INT 36
96715: PUSH
96716: EMPTY
96717: LIST
96718: LIST
96719: LIST
96720: LIST
96721: LIST
96722: LIST
96723: LIST
96724: LIST
96725: LIST
96726: LIST
96727: LIST
96728: LIST
96729: LIST
96730: LIST
96731: PUSH
96732: LD_INT 101
96734: PUSH
96735: LD_INT 102
96737: PUSH
96738: LD_INT 105
96740: PUSH
96741: LD_INT 106
96743: PUSH
96744: LD_INT 108
96746: PUSH
96747: LD_INT 109
96749: PUSH
96750: LD_INT 112
96752: PUSH
96753: LD_INT 116
96755: PUSH
96756: LD_INT 117
96758: PUSH
96759: LD_INT 118
96761: PUSH
96762: EMPTY
96763: LIST
96764: LIST
96765: LIST
96766: LIST
96767: LIST
96768: LIST
96769: LIST
96770: LIST
96771: LIST
96772: LIST
96773: PUSH
96774: EMPTY
96775: LIST
96776: LIST
96777: ST_TO_ADDR
96778: GO 99441
96780: LD_INT 6
96782: DOUBLE
96783: EQUAL
96784: IFTRUE 96788
96786: GO 96920
96788: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
96789: LD_ADDR_VAR 0 2
96793: PUSH
96794: LD_INT 2
96796: PUSH
96797: LD_INT 4
96799: PUSH
96800: LD_INT 5
96802: PUSH
96803: LD_INT 6
96805: PUSH
96806: LD_INT 8
96808: PUSH
96809: LD_INT 11
96811: PUSH
96812: LD_INT 12
96814: PUSH
96815: LD_INT 15
96817: PUSH
96818: LD_INT 16
96820: PUSH
96821: LD_INT 20
96823: PUSH
96824: LD_INT 21
96826: PUSH
96827: LD_INT 22
96829: PUSH
96830: LD_INT 23
96832: PUSH
96833: LD_INT 25
96835: PUSH
96836: LD_INT 26
96838: PUSH
96839: LD_INT 30
96841: PUSH
96842: LD_INT 31
96844: PUSH
96845: LD_INT 32
96847: PUSH
96848: LD_INT 36
96850: PUSH
96851: EMPTY
96852: LIST
96853: LIST
96854: LIST
96855: LIST
96856: LIST
96857: LIST
96858: LIST
96859: LIST
96860: LIST
96861: LIST
96862: LIST
96863: LIST
96864: LIST
96865: LIST
96866: LIST
96867: LIST
96868: LIST
96869: LIST
96870: LIST
96871: PUSH
96872: LD_INT 101
96874: PUSH
96875: LD_INT 102
96877: PUSH
96878: LD_INT 105
96880: PUSH
96881: LD_INT 106
96883: PUSH
96884: LD_INT 108
96886: PUSH
96887: LD_INT 109
96889: PUSH
96890: LD_INT 112
96892: PUSH
96893: LD_INT 116
96895: PUSH
96896: LD_INT 117
96898: PUSH
96899: LD_INT 118
96901: PUSH
96902: EMPTY
96903: LIST
96904: LIST
96905: LIST
96906: LIST
96907: LIST
96908: LIST
96909: LIST
96910: LIST
96911: LIST
96912: LIST
96913: PUSH
96914: EMPTY
96915: LIST
96916: LIST
96917: ST_TO_ADDR
96918: GO 99441
96920: LD_INT 7
96922: DOUBLE
96923: EQUAL
96924: IFTRUE 96928
96926: GO 97040
96928: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
96929: LD_ADDR_VAR 0 2
96933: PUSH
96934: LD_INT 2
96936: PUSH
96937: LD_INT 4
96939: PUSH
96940: LD_INT 5
96942: PUSH
96943: LD_INT 7
96945: PUSH
96946: LD_INT 11
96948: PUSH
96949: LD_INT 12
96951: PUSH
96952: LD_INT 15
96954: PUSH
96955: LD_INT 16
96957: PUSH
96958: LD_INT 20
96960: PUSH
96961: LD_INT 21
96963: PUSH
96964: LD_INT 22
96966: PUSH
96967: LD_INT 23
96969: PUSH
96970: LD_INT 25
96972: PUSH
96973: LD_INT 26
96975: PUSH
96976: EMPTY
96977: LIST
96978: LIST
96979: LIST
96980: LIST
96981: LIST
96982: LIST
96983: LIST
96984: LIST
96985: LIST
96986: LIST
96987: LIST
96988: LIST
96989: LIST
96990: LIST
96991: PUSH
96992: LD_INT 101
96994: PUSH
96995: LD_INT 102
96997: PUSH
96998: LD_INT 103
97000: PUSH
97001: LD_INT 105
97003: PUSH
97004: LD_INT 106
97006: PUSH
97007: LD_INT 108
97009: PUSH
97010: LD_INT 112
97012: PUSH
97013: LD_INT 116
97015: PUSH
97016: LD_INT 117
97018: PUSH
97019: LD_INT 118
97021: PUSH
97022: EMPTY
97023: LIST
97024: LIST
97025: LIST
97026: LIST
97027: LIST
97028: LIST
97029: LIST
97030: LIST
97031: LIST
97032: LIST
97033: PUSH
97034: EMPTY
97035: LIST
97036: LIST
97037: ST_TO_ADDR
97038: GO 99441
97040: LD_INT 8
97042: DOUBLE
97043: EQUAL
97044: IFTRUE 97048
97046: GO 97188
97048: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
97049: LD_ADDR_VAR 0 2
97053: PUSH
97054: LD_INT 2
97056: PUSH
97057: LD_INT 4
97059: PUSH
97060: LD_INT 5
97062: PUSH
97063: LD_INT 6
97065: PUSH
97066: LD_INT 7
97068: PUSH
97069: LD_INT 8
97071: PUSH
97072: LD_INT 11
97074: PUSH
97075: LD_INT 12
97077: PUSH
97078: LD_INT 15
97080: PUSH
97081: LD_INT 16
97083: PUSH
97084: LD_INT 20
97086: PUSH
97087: LD_INT 21
97089: PUSH
97090: LD_INT 22
97092: PUSH
97093: LD_INT 23
97095: PUSH
97096: LD_INT 25
97098: PUSH
97099: LD_INT 26
97101: PUSH
97102: LD_INT 30
97104: PUSH
97105: LD_INT 31
97107: PUSH
97108: LD_INT 32
97110: PUSH
97111: LD_INT 36
97113: PUSH
97114: EMPTY
97115: LIST
97116: LIST
97117: LIST
97118: LIST
97119: LIST
97120: LIST
97121: LIST
97122: LIST
97123: LIST
97124: LIST
97125: LIST
97126: LIST
97127: LIST
97128: LIST
97129: LIST
97130: LIST
97131: LIST
97132: LIST
97133: LIST
97134: LIST
97135: PUSH
97136: LD_INT 101
97138: PUSH
97139: LD_INT 102
97141: PUSH
97142: LD_INT 103
97144: PUSH
97145: LD_INT 105
97147: PUSH
97148: LD_INT 106
97150: PUSH
97151: LD_INT 108
97153: PUSH
97154: LD_INT 109
97156: PUSH
97157: LD_INT 112
97159: PUSH
97160: LD_INT 116
97162: PUSH
97163: LD_INT 117
97165: PUSH
97166: LD_INT 118
97168: PUSH
97169: EMPTY
97170: LIST
97171: LIST
97172: LIST
97173: LIST
97174: LIST
97175: LIST
97176: LIST
97177: LIST
97178: LIST
97179: LIST
97180: LIST
97181: PUSH
97182: EMPTY
97183: LIST
97184: LIST
97185: ST_TO_ADDR
97186: GO 99441
97188: LD_INT 9
97190: DOUBLE
97191: EQUAL
97192: IFTRUE 97196
97194: GO 97344
97196: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
97197: LD_ADDR_VAR 0 2
97201: PUSH
97202: LD_INT 2
97204: PUSH
97205: LD_INT 4
97207: PUSH
97208: LD_INT 5
97210: PUSH
97211: LD_INT 6
97213: PUSH
97214: LD_INT 7
97216: PUSH
97217: LD_INT 8
97219: PUSH
97220: LD_INT 11
97222: PUSH
97223: LD_INT 12
97225: PUSH
97226: LD_INT 15
97228: PUSH
97229: LD_INT 16
97231: PUSH
97232: LD_INT 20
97234: PUSH
97235: LD_INT 21
97237: PUSH
97238: LD_INT 22
97240: PUSH
97241: LD_INT 23
97243: PUSH
97244: LD_INT 25
97246: PUSH
97247: LD_INT 26
97249: PUSH
97250: LD_INT 28
97252: PUSH
97253: LD_INT 30
97255: PUSH
97256: LD_INT 31
97258: PUSH
97259: LD_INT 32
97261: PUSH
97262: LD_INT 36
97264: PUSH
97265: EMPTY
97266: LIST
97267: LIST
97268: LIST
97269: LIST
97270: LIST
97271: LIST
97272: LIST
97273: LIST
97274: LIST
97275: LIST
97276: LIST
97277: LIST
97278: LIST
97279: LIST
97280: LIST
97281: LIST
97282: LIST
97283: LIST
97284: LIST
97285: LIST
97286: LIST
97287: PUSH
97288: LD_INT 101
97290: PUSH
97291: LD_INT 102
97293: PUSH
97294: LD_INT 103
97296: PUSH
97297: LD_INT 105
97299: PUSH
97300: LD_INT 106
97302: PUSH
97303: LD_INT 108
97305: PUSH
97306: LD_INT 109
97308: PUSH
97309: LD_INT 112
97311: PUSH
97312: LD_INT 114
97314: PUSH
97315: LD_INT 116
97317: PUSH
97318: LD_INT 117
97320: PUSH
97321: LD_INT 118
97323: PUSH
97324: EMPTY
97325: LIST
97326: LIST
97327: LIST
97328: LIST
97329: LIST
97330: LIST
97331: LIST
97332: LIST
97333: LIST
97334: LIST
97335: LIST
97336: LIST
97337: PUSH
97338: EMPTY
97339: LIST
97340: LIST
97341: ST_TO_ADDR
97342: GO 99441
97344: LD_INT 10
97346: DOUBLE
97347: EQUAL
97348: IFTRUE 97352
97350: GO 97548
97352: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
97353: LD_ADDR_VAR 0 2
97357: PUSH
97358: LD_INT 2
97360: PUSH
97361: LD_INT 4
97363: PUSH
97364: LD_INT 5
97366: PUSH
97367: LD_INT 6
97369: PUSH
97370: LD_INT 7
97372: PUSH
97373: LD_INT 8
97375: PUSH
97376: LD_INT 9
97378: PUSH
97379: LD_INT 10
97381: PUSH
97382: LD_INT 11
97384: PUSH
97385: LD_INT 12
97387: PUSH
97388: LD_INT 13
97390: PUSH
97391: LD_INT 14
97393: PUSH
97394: LD_INT 15
97396: PUSH
97397: LD_INT 16
97399: PUSH
97400: LD_INT 17
97402: PUSH
97403: LD_INT 18
97405: PUSH
97406: LD_INT 19
97408: PUSH
97409: LD_INT 20
97411: PUSH
97412: LD_INT 21
97414: PUSH
97415: LD_INT 22
97417: PUSH
97418: LD_INT 23
97420: PUSH
97421: LD_INT 24
97423: PUSH
97424: LD_INT 25
97426: PUSH
97427: LD_INT 26
97429: PUSH
97430: LD_INT 28
97432: PUSH
97433: LD_INT 30
97435: PUSH
97436: LD_INT 31
97438: PUSH
97439: LD_INT 32
97441: PUSH
97442: LD_INT 36
97444: PUSH
97445: EMPTY
97446: LIST
97447: LIST
97448: LIST
97449: LIST
97450: LIST
97451: LIST
97452: LIST
97453: LIST
97454: LIST
97455: LIST
97456: LIST
97457: LIST
97458: LIST
97459: LIST
97460: LIST
97461: LIST
97462: LIST
97463: LIST
97464: LIST
97465: LIST
97466: LIST
97467: LIST
97468: LIST
97469: LIST
97470: LIST
97471: LIST
97472: LIST
97473: LIST
97474: LIST
97475: PUSH
97476: LD_INT 101
97478: PUSH
97479: LD_INT 102
97481: PUSH
97482: LD_INT 103
97484: PUSH
97485: LD_INT 104
97487: PUSH
97488: LD_INT 105
97490: PUSH
97491: LD_INT 106
97493: PUSH
97494: LD_INT 107
97496: PUSH
97497: LD_INT 108
97499: PUSH
97500: LD_INT 109
97502: PUSH
97503: LD_INT 110
97505: PUSH
97506: LD_INT 111
97508: PUSH
97509: LD_INT 112
97511: PUSH
97512: LD_INT 114
97514: PUSH
97515: LD_INT 116
97517: PUSH
97518: LD_INT 117
97520: PUSH
97521: LD_INT 118
97523: PUSH
97524: EMPTY
97525: LIST
97526: LIST
97527: LIST
97528: LIST
97529: LIST
97530: LIST
97531: LIST
97532: LIST
97533: LIST
97534: LIST
97535: LIST
97536: LIST
97537: LIST
97538: LIST
97539: LIST
97540: LIST
97541: PUSH
97542: EMPTY
97543: LIST
97544: LIST
97545: ST_TO_ADDR
97546: GO 99441
97548: LD_INT 11
97550: DOUBLE
97551: EQUAL
97552: IFTRUE 97556
97554: GO 97760
97556: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
97557: LD_ADDR_VAR 0 2
97561: PUSH
97562: LD_INT 2
97564: PUSH
97565: LD_INT 3
97567: PUSH
97568: LD_INT 4
97570: PUSH
97571: LD_INT 5
97573: PUSH
97574: LD_INT 6
97576: PUSH
97577: LD_INT 7
97579: PUSH
97580: LD_INT 8
97582: PUSH
97583: LD_INT 9
97585: PUSH
97586: LD_INT 10
97588: PUSH
97589: LD_INT 11
97591: PUSH
97592: LD_INT 12
97594: PUSH
97595: LD_INT 13
97597: PUSH
97598: LD_INT 14
97600: PUSH
97601: LD_INT 15
97603: PUSH
97604: LD_INT 16
97606: PUSH
97607: LD_INT 17
97609: PUSH
97610: LD_INT 18
97612: PUSH
97613: LD_INT 19
97615: PUSH
97616: LD_INT 20
97618: PUSH
97619: LD_INT 21
97621: PUSH
97622: LD_INT 22
97624: PUSH
97625: LD_INT 23
97627: PUSH
97628: LD_INT 24
97630: PUSH
97631: LD_INT 25
97633: PUSH
97634: LD_INT 26
97636: PUSH
97637: LD_INT 28
97639: PUSH
97640: LD_INT 30
97642: PUSH
97643: LD_INT 31
97645: PUSH
97646: LD_INT 32
97648: PUSH
97649: LD_INT 34
97651: PUSH
97652: LD_INT 36
97654: PUSH
97655: EMPTY
97656: LIST
97657: LIST
97658: LIST
97659: LIST
97660: LIST
97661: LIST
97662: LIST
97663: LIST
97664: LIST
97665: LIST
97666: LIST
97667: LIST
97668: LIST
97669: LIST
97670: LIST
97671: LIST
97672: LIST
97673: LIST
97674: LIST
97675: LIST
97676: LIST
97677: LIST
97678: LIST
97679: LIST
97680: LIST
97681: LIST
97682: LIST
97683: LIST
97684: LIST
97685: LIST
97686: LIST
97687: PUSH
97688: LD_INT 101
97690: PUSH
97691: LD_INT 102
97693: PUSH
97694: LD_INT 103
97696: PUSH
97697: LD_INT 104
97699: PUSH
97700: LD_INT 105
97702: PUSH
97703: LD_INT 106
97705: PUSH
97706: LD_INT 107
97708: PUSH
97709: LD_INT 108
97711: PUSH
97712: LD_INT 109
97714: PUSH
97715: LD_INT 110
97717: PUSH
97718: LD_INT 111
97720: PUSH
97721: LD_INT 112
97723: PUSH
97724: LD_INT 114
97726: PUSH
97727: LD_INT 116
97729: PUSH
97730: LD_INT 117
97732: PUSH
97733: LD_INT 118
97735: PUSH
97736: EMPTY
97737: LIST
97738: LIST
97739: LIST
97740: LIST
97741: LIST
97742: LIST
97743: LIST
97744: LIST
97745: LIST
97746: LIST
97747: LIST
97748: LIST
97749: LIST
97750: LIST
97751: LIST
97752: LIST
97753: PUSH
97754: EMPTY
97755: LIST
97756: LIST
97757: ST_TO_ADDR
97758: GO 99441
97760: LD_INT 12
97762: DOUBLE
97763: EQUAL
97764: IFTRUE 97768
97766: GO 97988
97768: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
97769: LD_ADDR_VAR 0 2
97773: PUSH
97774: LD_INT 1
97776: PUSH
97777: LD_INT 2
97779: PUSH
97780: LD_INT 3
97782: PUSH
97783: LD_INT 4
97785: PUSH
97786: LD_INT 5
97788: PUSH
97789: LD_INT 6
97791: PUSH
97792: LD_INT 7
97794: PUSH
97795: LD_INT 8
97797: PUSH
97798: LD_INT 9
97800: PUSH
97801: LD_INT 10
97803: PUSH
97804: LD_INT 11
97806: PUSH
97807: LD_INT 12
97809: PUSH
97810: LD_INT 13
97812: PUSH
97813: LD_INT 14
97815: PUSH
97816: LD_INT 15
97818: PUSH
97819: LD_INT 16
97821: PUSH
97822: LD_INT 17
97824: PUSH
97825: LD_INT 18
97827: PUSH
97828: LD_INT 19
97830: PUSH
97831: LD_INT 20
97833: PUSH
97834: LD_INT 21
97836: PUSH
97837: LD_INT 22
97839: PUSH
97840: LD_INT 23
97842: PUSH
97843: LD_INT 24
97845: PUSH
97846: LD_INT 25
97848: PUSH
97849: LD_INT 26
97851: PUSH
97852: LD_INT 27
97854: PUSH
97855: LD_INT 28
97857: PUSH
97858: LD_INT 30
97860: PUSH
97861: LD_INT 31
97863: PUSH
97864: LD_INT 32
97866: PUSH
97867: LD_INT 33
97869: PUSH
97870: LD_INT 34
97872: PUSH
97873: LD_INT 36
97875: PUSH
97876: EMPTY
97877: LIST
97878: LIST
97879: LIST
97880: LIST
97881: LIST
97882: LIST
97883: LIST
97884: LIST
97885: LIST
97886: LIST
97887: LIST
97888: LIST
97889: LIST
97890: LIST
97891: LIST
97892: LIST
97893: LIST
97894: LIST
97895: LIST
97896: LIST
97897: LIST
97898: LIST
97899: LIST
97900: LIST
97901: LIST
97902: LIST
97903: LIST
97904: LIST
97905: LIST
97906: LIST
97907: LIST
97908: LIST
97909: LIST
97910: LIST
97911: PUSH
97912: LD_INT 101
97914: PUSH
97915: LD_INT 102
97917: PUSH
97918: LD_INT 103
97920: PUSH
97921: LD_INT 104
97923: PUSH
97924: LD_INT 105
97926: PUSH
97927: LD_INT 106
97929: PUSH
97930: LD_INT 107
97932: PUSH
97933: LD_INT 108
97935: PUSH
97936: LD_INT 109
97938: PUSH
97939: LD_INT 110
97941: PUSH
97942: LD_INT 111
97944: PUSH
97945: LD_INT 112
97947: PUSH
97948: LD_INT 113
97950: PUSH
97951: LD_INT 114
97953: PUSH
97954: LD_INT 116
97956: PUSH
97957: LD_INT 117
97959: PUSH
97960: LD_INT 118
97962: PUSH
97963: EMPTY
97964: LIST
97965: LIST
97966: LIST
97967: LIST
97968: LIST
97969: LIST
97970: LIST
97971: LIST
97972: LIST
97973: LIST
97974: LIST
97975: LIST
97976: LIST
97977: LIST
97978: LIST
97979: LIST
97980: LIST
97981: PUSH
97982: EMPTY
97983: LIST
97984: LIST
97985: ST_TO_ADDR
97986: GO 99441
97988: LD_INT 13
97990: DOUBLE
97991: EQUAL
97992: IFTRUE 97996
97994: GO 98204
97996: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
97997: LD_ADDR_VAR 0 2
98001: PUSH
98002: LD_INT 1
98004: PUSH
98005: LD_INT 2
98007: PUSH
98008: LD_INT 3
98010: PUSH
98011: LD_INT 4
98013: PUSH
98014: LD_INT 5
98016: PUSH
98017: LD_INT 8
98019: PUSH
98020: LD_INT 9
98022: PUSH
98023: LD_INT 10
98025: PUSH
98026: LD_INT 11
98028: PUSH
98029: LD_INT 12
98031: PUSH
98032: LD_INT 14
98034: PUSH
98035: LD_INT 15
98037: PUSH
98038: LD_INT 16
98040: PUSH
98041: LD_INT 17
98043: PUSH
98044: LD_INT 18
98046: PUSH
98047: LD_INT 19
98049: PUSH
98050: LD_INT 20
98052: PUSH
98053: LD_INT 21
98055: PUSH
98056: LD_INT 22
98058: PUSH
98059: LD_INT 23
98061: PUSH
98062: LD_INT 24
98064: PUSH
98065: LD_INT 25
98067: PUSH
98068: LD_INT 26
98070: PUSH
98071: LD_INT 27
98073: PUSH
98074: LD_INT 28
98076: PUSH
98077: LD_INT 30
98079: PUSH
98080: LD_INT 31
98082: PUSH
98083: LD_INT 32
98085: PUSH
98086: LD_INT 33
98088: PUSH
98089: LD_INT 34
98091: PUSH
98092: LD_INT 36
98094: PUSH
98095: EMPTY
98096: LIST
98097: LIST
98098: LIST
98099: LIST
98100: LIST
98101: LIST
98102: LIST
98103: LIST
98104: LIST
98105: LIST
98106: LIST
98107: LIST
98108: LIST
98109: LIST
98110: LIST
98111: LIST
98112: LIST
98113: LIST
98114: LIST
98115: LIST
98116: LIST
98117: LIST
98118: LIST
98119: LIST
98120: LIST
98121: LIST
98122: LIST
98123: LIST
98124: LIST
98125: LIST
98126: LIST
98127: PUSH
98128: LD_INT 101
98130: PUSH
98131: LD_INT 102
98133: PUSH
98134: LD_INT 103
98136: PUSH
98137: LD_INT 104
98139: PUSH
98140: LD_INT 105
98142: PUSH
98143: LD_INT 106
98145: PUSH
98146: LD_INT 107
98148: PUSH
98149: LD_INT 108
98151: PUSH
98152: LD_INT 109
98154: PUSH
98155: LD_INT 110
98157: PUSH
98158: LD_INT 111
98160: PUSH
98161: LD_INT 112
98163: PUSH
98164: LD_INT 113
98166: PUSH
98167: LD_INT 114
98169: PUSH
98170: LD_INT 116
98172: PUSH
98173: LD_INT 117
98175: PUSH
98176: LD_INT 118
98178: PUSH
98179: EMPTY
98180: LIST
98181: LIST
98182: LIST
98183: LIST
98184: LIST
98185: LIST
98186: LIST
98187: LIST
98188: LIST
98189: LIST
98190: LIST
98191: LIST
98192: LIST
98193: LIST
98194: LIST
98195: LIST
98196: LIST
98197: PUSH
98198: EMPTY
98199: LIST
98200: LIST
98201: ST_TO_ADDR
98202: GO 99441
98204: LD_INT 14
98206: DOUBLE
98207: EQUAL
98208: IFTRUE 98212
98210: GO 98436
98212: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
98213: LD_ADDR_VAR 0 2
98217: PUSH
98218: LD_INT 1
98220: PUSH
98221: LD_INT 2
98223: PUSH
98224: LD_INT 3
98226: PUSH
98227: LD_INT 4
98229: PUSH
98230: LD_INT 5
98232: PUSH
98233: LD_INT 6
98235: PUSH
98236: LD_INT 7
98238: PUSH
98239: LD_INT 8
98241: PUSH
98242: LD_INT 9
98244: PUSH
98245: LD_INT 10
98247: PUSH
98248: LD_INT 11
98250: PUSH
98251: LD_INT 12
98253: PUSH
98254: LD_INT 13
98256: PUSH
98257: LD_INT 14
98259: PUSH
98260: LD_INT 15
98262: PUSH
98263: LD_INT 16
98265: PUSH
98266: LD_INT 17
98268: PUSH
98269: LD_INT 18
98271: PUSH
98272: LD_INT 19
98274: PUSH
98275: LD_INT 20
98277: PUSH
98278: LD_INT 21
98280: PUSH
98281: LD_INT 22
98283: PUSH
98284: LD_INT 23
98286: PUSH
98287: LD_INT 24
98289: PUSH
98290: LD_INT 25
98292: PUSH
98293: LD_INT 26
98295: PUSH
98296: LD_INT 27
98298: PUSH
98299: LD_INT 28
98301: PUSH
98302: LD_INT 29
98304: PUSH
98305: LD_INT 30
98307: PUSH
98308: LD_INT 31
98310: PUSH
98311: LD_INT 32
98313: PUSH
98314: LD_INT 33
98316: PUSH
98317: LD_INT 34
98319: PUSH
98320: LD_INT 36
98322: PUSH
98323: EMPTY
98324: LIST
98325: LIST
98326: LIST
98327: LIST
98328: LIST
98329: LIST
98330: LIST
98331: LIST
98332: LIST
98333: LIST
98334: LIST
98335: LIST
98336: LIST
98337: LIST
98338: LIST
98339: LIST
98340: LIST
98341: LIST
98342: LIST
98343: LIST
98344: LIST
98345: LIST
98346: LIST
98347: LIST
98348: LIST
98349: LIST
98350: LIST
98351: LIST
98352: LIST
98353: LIST
98354: LIST
98355: LIST
98356: LIST
98357: LIST
98358: LIST
98359: PUSH
98360: LD_INT 101
98362: PUSH
98363: LD_INT 102
98365: PUSH
98366: LD_INT 103
98368: PUSH
98369: LD_INT 104
98371: PUSH
98372: LD_INT 105
98374: PUSH
98375: LD_INT 106
98377: PUSH
98378: LD_INT 107
98380: PUSH
98381: LD_INT 108
98383: PUSH
98384: LD_INT 109
98386: PUSH
98387: LD_INT 110
98389: PUSH
98390: LD_INT 111
98392: PUSH
98393: LD_INT 112
98395: PUSH
98396: LD_INT 113
98398: PUSH
98399: LD_INT 114
98401: PUSH
98402: LD_INT 116
98404: PUSH
98405: LD_INT 117
98407: PUSH
98408: LD_INT 118
98410: PUSH
98411: EMPTY
98412: LIST
98413: LIST
98414: LIST
98415: LIST
98416: LIST
98417: LIST
98418: LIST
98419: LIST
98420: LIST
98421: LIST
98422: LIST
98423: LIST
98424: LIST
98425: LIST
98426: LIST
98427: LIST
98428: LIST
98429: PUSH
98430: EMPTY
98431: LIST
98432: LIST
98433: ST_TO_ADDR
98434: GO 99441
98436: LD_INT 15
98438: DOUBLE
98439: EQUAL
98440: IFTRUE 98444
98442: GO 98668
98444: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
98445: LD_ADDR_VAR 0 2
98449: PUSH
98450: LD_INT 1
98452: PUSH
98453: LD_INT 2
98455: PUSH
98456: LD_INT 3
98458: PUSH
98459: LD_INT 4
98461: PUSH
98462: LD_INT 5
98464: PUSH
98465: LD_INT 6
98467: PUSH
98468: LD_INT 7
98470: PUSH
98471: LD_INT 8
98473: PUSH
98474: LD_INT 9
98476: PUSH
98477: LD_INT 10
98479: PUSH
98480: LD_INT 11
98482: PUSH
98483: LD_INT 12
98485: PUSH
98486: LD_INT 13
98488: PUSH
98489: LD_INT 14
98491: PUSH
98492: LD_INT 15
98494: PUSH
98495: LD_INT 16
98497: PUSH
98498: LD_INT 17
98500: PUSH
98501: LD_INT 18
98503: PUSH
98504: LD_INT 19
98506: PUSH
98507: LD_INT 20
98509: PUSH
98510: LD_INT 21
98512: PUSH
98513: LD_INT 22
98515: PUSH
98516: LD_INT 23
98518: PUSH
98519: LD_INT 24
98521: PUSH
98522: LD_INT 25
98524: PUSH
98525: LD_INT 26
98527: PUSH
98528: LD_INT 27
98530: PUSH
98531: LD_INT 28
98533: PUSH
98534: LD_INT 29
98536: PUSH
98537: LD_INT 30
98539: PUSH
98540: LD_INT 31
98542: PUSH
98543: LD_INT 32
98545: PUSH
98546: LD_INT 33
98548: PUSH
98549: LD_INT 34
98551: PUSH
98552: LD_INT 36
98554: PUSH
98555: EMPTY
98556: LIST
98557: LIST
98558: LIST
98559: LIST
98560: LIST
98561: LIST
98562: LIST
98563: LIST
98564: LIST
98565: LIST
98566: LIST
98567: LIST
98568: LIST
98569: LIST
98570: LIST
98571: LIST
98572: LIST
98573: LIST
98574: LIST
98575: LIST
98576: LIST
98577: LIST
98578: LIST
98579: LIST
98580: LIST
98581: LIST
98582: LIST
98583: LIST
98584: LIST
98585: LIST
98586: LIST
98587: LIST
98588: LIST
98589: LIST
98590: LIST
98591: PUSH
98592: LD_INT 101
98594: PUSH
98595: LD_INT 102
98597: PUSH
98598: LD_INT 103
98600: PUSH
98601: LD_INT 104
98603: PUSH
98604: LD_INT 105
98606: PUSH
98607: LD_INT 106
98609: PUSH
98610: LD_INT 107
98612: PUSH
98613: LD_INT 108
98615: PUSH
98616: LD_INT 109
98618: PUSH
98619: LD_INT 110
98621: PUSH
98622: LD_INT 111
98624: PUSH
98625: LD_INT 112
98627: PUSH
98628: LD_INT 113
98630: PUSH
98631: LD_INT 114
98633: PUSH
98634: LD_INT 116
98636: PUSH
98637: LD_INT 117
98639: PUSH
98640: LD_INT 118
98642: PUSH
98643: EMPTY
98644: LIST
98645: LIST
98646: LIST
98647: LIST
98648: LIST
98649: LIST
98650: LIST
98651: LIST
98652: LIST
98653: LIST
98654: LIST
98655: LIST
98656: LIST
98657: LIST
98658: LIST
98659: LIST
98660: LIST
98661: PUSH
98662: EMPTY
98663: LIST
98664: LIST
98665: ST_TO_ADDR
98666: GO 99441
98668: LD_INT 16
98670: DOUBLE
98671: EQUAL
98672: IFTRUE 98676
98674: GO 98812
98676: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
98677: LD_ADDR_VAR 0 2
98681: PUSH
98682: LD_INT 2
98684: PUSH
98685: LD_INT 4
98687: PUSH
98688: LD_INT 5
98690: PUSH
98691: LD_INT 7
98693: PUSH
98694: LD_INT 11
98696: PUSH
98697: LD_INT 12
98699: PUSH
98700: LD_INT 15
98702: PUSH
98703: LD_INT 16
98705: PUSH
98706: LD_INT 20
98708: PUSH
98709: LD_INT 21
98711: PUSH
98712: LD_INT 22
98714: PUSH
98715: LD_INT 23
98717: PUSH
98718: LD_INT 25
98720: PUSH
98721: LD_INT 26
98723: PUSH
98724: LD_INT 30
98726: PUSH
98727: LD_INT 31
98729: PUSH
98730: LD_INT 32
98732: PUSH
98733: LD_INT 33
98735: PUSH
98736: LD_INT 34
98738: PUSH
98739: EMPTY
98740: LIST
98741: LIST
98742: LIST
98743: LIST
98744: LIST
98745: LIST
98746: LIST
98747: LIST
98748: LIST
98749: LIST
98750: LIST
98751: LIST
98752: LIST
98753: LIST
98754: LIST
98755: LIST
98756: LIST
98757: LIST
98758: LIST
98759: PUSH
98760: LD_INT 101
98762: PUSH
98763: LD_INT 102
98765: PUSH
98766: LD_INT 103
98768: PUSH
98769: LD_INT 106
98771: PUSH
98772: LD_INT 108
98774: PUSH
98775: LD_INT 112
98777: PUSH
98778: LD_INT 113
98780: PUSH
98781: LD_INT 114
98783: PUSH
98784: LD_INT 116
98786: PUSH
98787: LD_INT 117
98789: PUSH
98790: LD_INT 118
98792: PUSH
98793: EMPTY
98794: LIST
98795: LIST
98796: LIST
98797: LIST
98798: LIST
98799: LIST
98800: LIST
98801: LIST
98802: LIST
98803: LIST
98804: LIST
98805: PUSH
98806: EMPTY
98807: LIST
98808: LIST
98809: ST_TO_ADDR
98810: GO 99441
98812: LD_INT 17
98814: DOUBLE
98815: EQUAL
98816: IFTRUE 98820
98818: GO 99044
98820: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
98821: LD_ADDR_VAR 0 2
98825: PUSH
98826: LD_INT 1
98828: PUSH
98829: LD_INT 2
98831: PUSH
98832: LD_INT 3
98834: PUSH
98835: LD_INT 4
98837: PUSH
98838: LD_INT 5
98840: PUSH
98841: LD_INT 6
98843: PUSH
98844: LD_INT 7
98846: PUSH
98847: LD_INT 8
98849: PUSH
98850: LD_INT 9
98852: PUSH
98853: LD_INT 10
98855: PUSH
98856: LD_INT 11
98858: PUSH
98859: LD_INT 12
98861: PUSH
98862: LD_INT 13
98864: PUSH
98865: LD_INT 14
98867: PUSH
98868: LD_INT 15
98870: PUSH
98871: LD_INT 16
98873: PUSH
98874: LD_INT 17
98876: PUSH
98877: LD_INT 18
98879: PUSH
98880: LD_INT 19
98882: PUSH
98883: LD_INT 20
98885: PUSH
98886: LD_INT 21
98888: PUSH
98889: LD_INT 22
98891: PUSH
98892: LD_INT 23
98894: PUSH
98895: LD_INT 24
98897: PUSH
98898: LD_INT 25
98900: PUSH
98901: LD_INT 26
98903: PUSH
98904: LD_INT 27
98906: PUSH
98907: LD_INT 28
98909: PUSH
98910: LD_INT 29
98912: PUSH
98913: LD_INT 30
98915: PUSH
98916: LD_INT 31
98918: PUSH
98919: LD_INT 32
98921: PUSH
98922: LD_INT 33
98924: PUSH
98925: LD_INT 34
98927: PUSH
98928: LD_INT 36
98930: PUSH
98931: EMPTY
98932: LIST
98933: LIST
98934: LIST
98935: LIST
98936: LIST
98937: LIST
98938: LIST
98939: LIST
98940: LIST
98941: LIST
98942: LIST
98943: LIST
98944: LIST
98945: LIST
98946: LIST
98947: LIST
98948: LIST
98949: LIST
98950: LIST
98951: LIST
98952: LIST
98953: LIST
98954: LIST
98955: LIST
98956: LIST
98957: LIST
98958: LIST
98959: LIST
98960: LIST
98961: LIST
98962: LIST
98963: LIST
98964: LIST
98965: LIST
98966: LIST
98967: PUSH
98968: LD_INT 101
98970: PUSH
98971: LD_INT 102
98973: PUSH
98974: LD_INT 103
98976: PUSH
98977: LD_INT 104
98979: PUSH
98980: LD_INT 105
98982: PUSH
98983: LD_INT 106
98985: PUSH
98986: LD_INT 107
98988: PUSH
98989: LD_INT 108
98991: PUSH
98992: LD_INT 109
98994: PUSH
98995: LD_INT 110
98997: PUSH
98998: LD_INT 111
99000: PUSH
99001: LD_INT 112
99003: PUSH
99004: LD_INT 113
99006: PUSH
99007: LD_INT 114
99009: PUSH
99010: LD_INT 116
99012: PUSH
99013: LD_INT 117
99015: PUSH
99016: LD_INT 118
99018: PUSH
99019: EMPTY
99020: LIST
99021: LIST
99022: LIST
99023: LIST
99024: LIST
99025: LIST
99026: LIST
99027: LIST
99028: LIST
99029: LIST
99030: LIST
99031: LIST
99032: LIST
99033: LIST
99034: LIST
99035: LIST
99036: LIST
99037: PUSH
99038: EMPTY
99039: LIST
99040: LIST
99041: ST_TO_ADDR
99042: GO 99441
99044: LD_INT 18
99046: DOUBLE
99047: EQUAL
99048: IFTRUE 99052
99050: GO 99200
99052: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
99053: LD_ADDR_VAR 0 2
99057: PUSH
99058: LD_INT 2
99060: PUSH
99061: LD_INT 4
99063: PUSH
99064: LD_INT 5
99066: PUSH
99067: LD_INT 7
99069: PUSH
99070: LD_INT 11
99072: PUSH
99073: LD_INT 12
99075: PUSH
99076: LD_INT 15
99078: PUSH
99079: LD_INT 16
99081: PUSH
99082: LD_INT 20
99084: PUSH
99085: LD_INT 21
99087: PUSH
99088: LD_INT 22
99090: PUSH
99091: LD_INT 23
99093: PUSH
99094: LD_INT 25
99096: PUSH
99097: LD_INT 26
99099: PUSH
99100: LD_INT 30
99102: PUSH
99103: LD_INT 31
99105: PUSH
99106: LD_INT 32
99108: PUSH
99109: LD_INT 33
99111: PUSH
99112: LD_INT 34
99114: PUSH
99115: LD_INT 35
99117: PUSH
99118: LD_INT 36
99120: PUSH
99121: EMPTY
99122: LIST
99123: LIST
99124: LIST
99125: LIST
99126: LIST
99127: LIST
99128: LIST
99129: LIST
99130: LIST
99131: LIST
99132: LIST
99133: LIST
99134: LIST
99135: LIST
99136: LIST
99137: LIST
99138: LIST
99139: LIST
99140: LIST
99141: LIST
99142: LIST
99143: PUSH
99144: LD_INT 101
99146: PUSH
99147: LD_INT 102
99149: PUSH
99150: LD_INT 103
99152: PUSH
99153: LD_INT 106
99155: PUSH
99156: LD_INT 108
99158: PUSH
99159: LD_INT 112
99161: PUSH
99162: LD_INT 113
99164: PUSH
99165: LD_INT 114
99167: PUSH
99168: LD_INT 115
99170: PUSH
99171: LD_INT 116
99173: PUSH
99174: LD_INT 117
99176: PUSH
99177: LD_INT 118
99179: PUSH
99180: EMPTY
99181: LIST
99182: LIST
99183: LIST
99184: LIST
99185: LIST
99186: LIST
99187: LIST
99188: LIST
99189: LIST
99190: LIST
99191: LIST
99192: LIST
99193: PUSH
99194: EMPTY
99195: LIST
99196: LIST
99197: ST_TO_ADDR
99198: GO 99441
99200: LD_INT 19
99202: DOUBLE
99203: EQUAL
99204: IFTRUE 99208
99206: GO 99440
99208: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
99209: LD_ADDR_VAR 0 2
99213: PUSH
99214: LD_INT 1
99216: PUSH
99217: LD_INT 2
99219: PUSH
99220: LD_INT 3
99222: PUSH
99223: LD_INT 4
99225: PUSH
99226: LD_INT 5
99228: PUSH
99229: LD_INT 6
99231: PUSH
99232: LD_INT 7
99234: PUSH
99235: LD_INT 8
99237: PUSH
99238: LD_INT 9
99240: PUSH
99241: LD_INT 10
99243: PUSH
99244: LD_INT 11
99246: PUSH
99247: LD_INT 12
99249: PUSH
99250: LD_INT 13
99252: PUSH
99253: LD_INT 14
99255: PUSH
99256: LD_INT 15
99258: PUSH
99259: LD_INT 16
99261: PUSH
99262: LD_INT 17
99264: PUSH
99265: LD_INT 18
99267: PUSH
99268: LD_INT 19
99270: PUSH
99271: LD_INT 20
99273: PUSH
99274: LD_INT 21
99276: PUSH
99277: LD_INT 22
99279: PUSH
99280: LD_INT 23
99282: PUSH
99283: LD_INT 24
99285: PUSH
99286: LD_INT 25
99288: PUSH
99289: LD_INT 26
99291: PUSH
99292: LD_INT 27
99294: PUSH
99295: LD_INT 28
99297: PUSH
99298: LD_INT 29
99300: PUSH
99301: LD_INT 30
99303: PUSH
99304: LD_INT 31
99306: PUSH
99307: LD_INT 32
99309: PUSH
99310: LD_INT 33
99312: PUSH
99313: LD_INT 34
99315: PUSH
99316: LD_INT 35
99318: PUSH
99319: LD_INT 36
99321: PUSH
99322: EMPTY
99323: LIST
99324: LIST
99325: LIST
99326: LIST
99327: LIST
99328: LIST
99329: LIST
99330: LIST
99331: LIST
99332: LIST
99333: LIST
99334: LIST
99335: LIST
99336: LIST
99337: LIST
99338: LIST
99339: LIST
99340: LIST
99341: LIST
99342: LIST
99343: LIST
99344: LIST
99345: LIST
99346: LIST
99347: LIST
99348: LIST
99349: LIST
99350: LIST
99351: LIST
99352: LIST
99353: LIST
99354: LIST
99355: LIST
99356: LIST
99357: LIST
99358: LIST
99359: PUSH
99360: LD_INT 101
99362: PUSH
99363: LD_INT 102
99365: PUSH
99366: LD_INT 103
99368: PUSH
99369: LD_INT 104
99371: PUSH
99372: LD_INT 105
99374: PUSH
99375: LD_INT 106
99377: PUSH
99378: LD_INT 107
99380: PUSH
99381: LD_INT 108
99383: PUSH
99384: LD_INT 109
99386: PUSH
99387: LD_INT 110
99389: PUSH
99390: LD_INT 111
99392: PUSH
99393: LD_INT 112
99395: PUSH
99396: LD_INT 113
99398: PUSH
99399: LD_INT 114
99401: PUSH
99402: LD_INT 115
99404: PUSH
99405: LD_INT 116
99407: PUSH
99408: LD_INT 117
99410: PUSH
99411: LD_INT 118
99413: PUSH
99414: EMPTY
99415: LIST
99416: LIST
99417: LIST
99418: LIST
99419: LIST
99420: LIST
99421: LIST
99422: LIST
99423: LIST
99424: LIST
99425: LIST
99426: LIST
99427: LIST
99428: LIST
99429: LIST
99430: LIST
99431: LIST
99432: LIST
99433: PUSH
99434: EMPTY
99435: LIST
99436: LIST
99437: ST_TO_ADDR
99438: GO 99441
99440: POP
// end else
99441: GO 99672
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
99443: LD_ADDR_VAR 0 2
99447: PUSH
99448: LD_INT 1
99450: PUSH
99451: LD_INT 2
99453: PUSH
99454: LD_INT 3
99456: PUSH
99457: LD_INT 4
99459: PUSH
99460: LD_INT 5
99462: PUSH
99463: LD_INT 6
99465: PUSH
99466: LD_INT 7
99468: PUSH
99469: LD_INT 8
99471: PUSH
99472: LD_INT 9
99474: PUSH
99475: LD_INT 10
99477: PUSH
99478: LD_INT 11
99480: PUSH
99481: LD_INT 12
99483: PUSH
99484: LD_INT 13
99486: PUSH
99487: LD_INT 14
99489: PUSH
99490: LD_INT 15
99492: PUSH
99493: LD_INT 16
99495: PUSH
99496: LD_INT 17
99498: PUSH
99499: LD_INT 18
99501: PUSH
99502: LD_INT 19
99504: PUSH
99505: LD_INT 20
99507: PUSH
99508: LD_INT 21
99510: PUSH
99511: LD_INT 22
99513: PUSH
99514: LD_INT 23
99516: PUSH
99517: LD_INT 24
99519: PUSH
99520: LD_INT 25
99522: PUSH
99523: LD_INT 26
99525: PUSH
99526: LD_INT 27
99528: PUSH
99529: LD_INT 28
99531: PUSH
99532: LD_INT 29
99534: PUSH
99535: LD_INT 30
99537: PUSH
99538: LD_INT 31
99540: PUSH
99541: LD_INT 32
99543: PUSH
99544: LD_INT 33
99546: PUSH
99547: LD_INT 34
99549: PUSH
99550: LD_INT 35
99552: PUSH
99553: LD_INT 36
99555: PUSH
99556: EMPTY
99557: LIST
99558: LIST
99559: LIST
99560: LIST
99561: LIST
99562: LIST
99563: LIST
99564: LIST
99565: LIST
99566: LIST
99567: LIST
99568: LIST
99569: LIST
99570: LIST
99571: LIST
99572: LIST
99573: LIST
99574: LIST
99575: LIST
99576: LIST
99577: LIST
99578: LIST
99579: LIST
99580: LIST
99581: LIST
99582: LIST
99583: LIST
99584: LIST
99585: LIST
99586: LIST
99587: LIST
99588: LIST
99589: LIST
99590: LIST
99591: LIST
99592: LIST
99593: PUSH
99594: LD_INT 101
99596: PUSH
99597: LD_INT 102
99599: PUSH
99600: LD_INT 103
99602: PUSH
99603: LD_INT 104
99605: PUSH
99606: LD_INT 105
99608: PUSH
99609: LD_INT 106
99611: PUSH
99612: LD_INT 107
99614: PUSH
99615: LD_INT 108
99617: PUSH
99618: LD_INT 109
99620: PUSH
99621: LD_INT 110
99623: PUSH
99624: LD_INT 111
99626: PUSH
99627: LD_INT 112
99629: PUSH
99630: LD_INT 113
99632: PUSH
99633: LD_INT 114
99635: PUSH
99636: LD_INT 115
99638: PUSH
99639: LD_INT 116
99641: PUSH
99642: LD_INT 117
99644: PUSH
99645: LD_INT 118
99647: PUSH
99648: EMPTY
99649: LIST
99650: LIST
99651: LIST
99652: LIST
99653: LIST
99654: LIST
99655: LIST
99656: LIST
99657: LIST
99658: LIST
99659: LIST
99660: LIST
99661: LIST
99662: LIST
99663: LIST
99664: LIST
99665: LIST
99666: LIST
99667: PUSH
99668: EMPTY
99669: LIST
99670: LIST
99671: ST_TO_ADDR
// if result then
99672: LD_VAR 0 2
99676: IFFALSE 100462
// begin normal :=  ;
99678: LD_ADDR_VAR 0 5
99682: PUSH
99683: LD_STRING 
99685: ST_TO_ADDR
// hardcore :=  ;
99686: LD_ADDR_VAR 0 6
99690: PUSH
99691: LD_STRING 
99693: ST_TO_ADDR
// active :=  ;
99694: LD_ADDR_VAR 0 7
99698: PUSH
99699: LD_STRING 
99701: ST_TO_ADDR
// for i = 1 to normalCounter do
99702: LD_ADDR_VAR 0 8
99706: PUSH
99707: DOUBLE
99708: LD_INT 1
99710: DEC
99711: ST_TO_ADDR
99712: LD_EXP 78
99716: PUSH
99717: FOR_TO
99718: IFFALSE 99819
// begin tmp := 0 ;
99720: LD_ADDR_VAR 0 3
99724: PUSH
99725: LD_STRING 0
99727: ST_TO_ADDR
// if result [ 1 ] then
99728: LD_VAR 0 2
99732: PUSH
99733: LD_INT 1
99735: ARRAY
99736: IFFALSE 99801
// if result [ 1 ] [ 1 ] = i then
99738: LD_VAR 0 2
99742: PUSH
99743: LD_INT 1
99745: ARRAY
99746: PUSH
99747: LD_INT 1
99749: ARRAY
99750: PUSH
99751: LD_VAR 0 8
99755: EQUAL
99756: IFFALSE 99801
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
99758: LD_ADDR_VAR 0 2
99762: PUSH
99763: LD_VAR 0 2
99767: PPUSH
99768: LD_INT 1
99770: PPUSH
99771: LD_VAR 0 2
99775: PUSH
99776: LD_INT 1
99778: ARRAY
99779: PPUSH
99780: LD_INT 1
99782: PPUSH
99783: CALL_OW 3
99787: PPUSH
99788: CALL_OW 1
99792: ST_TO_ADDR
// tmp := 1 ;
99793: LD_ADDR_VAR 0 3
99797: PUSH
99798: LD_STRING 1
99800: ST_TO_ADDR
// end ; normal := normal & tmp ;
99801: LD_ADDR_VAR 0 5
99805: PUSH
99806: LD_VAR 0 5
99810: PUSH
99811: LD_VAR 0 3
99815: STR
99816: ST_TO_ADDR
// end ;
99817: GO 99717
99819: POP
99820: POP
// for i = 1 to hardcoreCounter do
99821: LD_ADDR_VAR 0 8
99825: PUSH
99826: DOUBLE
99827: LD_INT 1
99829: DEC
99830: ST_TO_ADDR
99831: LD_EXP 79
99835: PUSH
99836: FOR_TO
99837: IFFALSE 99942
// begin tmp := 0 ;
99839: LD_ADDR_VAR 0 3
99843: PUSH
99844: LD_STRING 0
99846: ST_TO_ADDR
// if result [ 2 ] then
99847: LD_VAR 0 2
99851: PUSH
99852: LD_INT 2
99854: ARRAY
99855: IFFALSE 99924
// if result [ 2 ] [ 1 ] = 100 + i then
99857: LD_VAR 0 2
99861: PUSH
99862: LD_INT 2
99864: ARRAY
99865: PUSH
99866: LD_INT 1
99868: ARRAY
99869: PUSH
99870: LD_INT 100
99872: PUSH
99873: LD_VAR 0 8
99877: PLUS
99878: EQUAL
99879: IFFALSE 99924
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
99881: LD_ADDR_VAR 0 2
99885: PUSH
99886: LD_VAR 0 2
99890: PPUSH
99891: LD_INT 2
99893: PPUSH
99894: LD_VAR 0 2
99898: PUSH
99899: LD_INT 2
99901: ARRAY
99902: PPUSH
99903: LD_INT 1
99905: PPUSH
99906: CALL_OW 3
99910: PPUSH
99911: CALL_OW 1
99915: ST_TO_ADDR
// tmp := 1 ;
99916: LD_ADDR_VAR 0 3
99920: PUSH
99921: LD_STRING 1
99923: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
99924: LD_ADDR_VAR 0 6
99928: PUSH
99929: LD_VAR 0 6
99933: PUSH
99934: LD_VAR 0 3
99938: STR
99939: ST_TO_ADDR
// end ;
99940: GO 99836
99942: POP
99943: POP
// if isGameLoad then
99944: LD_VAR 0 1
99948: IFFALSE 100423
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
99950: LD_ADDR_VAR 0 4
99954: PUSH
99955: LD_EXP 82
99959: PUSH
99960: LD_EXP 81
99964: PUSH
99965: LD_EXP 83
99969: PUSH
99970: LD_EXP 80
99974: PUSH
99975: LD_EXP 84
99979: PUSH
99980: LD_EXP 85
99984: PUSH
99985: LD_EXP 86
99989: PUSH
99990: LD_EXP 87
99994: PUSH
99995: LD_EXP 88
99999: PUSH
100000: LD_EXP 89
100004: PUSH
100005: LD_EXP 90
100009: PUSH
100010: LD_EXP 91
100014: PUSH
100015: LD_EXP 92
100019: PUSH
100020: LD_EXP 93
100024: PUSH
100025: LD_EXP 101
100029: PUSH
100030: LD_EXP 102
100034: PUSH
100035: LD_EXP 103
100039: PUSH
100040: LD_EXP 104
100044: PUSH
100045: LD_EXP 106
100049: PUSH
100050: LD_EXP 107
100054: PUSH
100055: LD_EXP 108
100059: PUSH
100060: LD_EXP 111
100064: PUSH
100065: LD_EXP 113
100069: PUSH
100070: LD_EXP 114
100074: PUSH
100075: LD_EXP 115
100079: PUSH
100080: LD_EXP 117
100084: PUSH
100085: LD_EXP 118
100089: PUSH
100090: LD_EXP 121
100094: PUSH
100095: LD_EXP 122
100099: PUSH
100100: LD_EXP 123
100104: PUSH
100105: LD_EXP 124
100109: PUSH
100110: LD_EXP 125
100114: PUSH
100115: LD_EXP 126
100119: PUSH
100120: LD_EXP 127
100124: PUSH
100125: LD_EXP 128
100129: PUSH
100130: LD_EXP 129
100134: PUSH
100135: LD_EXP 94
100139: PUSH
100140: LD_EXP 95
100144: PUSH
100145: LD_EXP 98
100149: PUSH
100150: LD_EXP 99
100154: PUSH
100155: LD_EXP 100
100159: PUSH
100160: LD_EXP 96
100164: PUSH
100165: LD_EXP 97
100169: PUSH
100170: LD_EXP 105
100174: PUSH
100175: LD_EXP 109
100179: PUSH
100180: LD_EXP 110
100184: PUSH
100185: LD_EXP 112
100189: PUSH
100190: LD_EXP 116
100194: PUSH
100195: LD_EXP 119
100199: PUSH
100200: LD_EXP 120
100204: PUSH
100205: LD_EXP 130
100209: PUSH
100210: LD_EXP 131
100214: PUSH
100215: LD_EXP 132
100219: PUSH
100220: LD_EXP 133
100224: PUSH
100225: EMPTY
100226: LIST
100227: LIST
100228: LIST
100229: LIST
100230: LIST
100231: LIST
100232: LIST
100233: LIST
100234: LIST
100235: LIST
100236: LIST
100237: LIST
100238: LIST
100239: LIST
100240: LIST
100241: LIST
100242: LIST
100243: LIST
100244: LIST
100245: LIST
100246: LIST
100247: LIST
100248: LIST
100249: LIST
100250: LIST
100251: LIST
100252: LIST
100253: LIST
100254: LIST
100255: LIST
100256: LIST
100257: LIST
100258: LIST
100259: LIST
100260: LIST
100261: LIST
100262: LIST
100263: LIST
100264: LIST
100265: LIST
100266: LIST
100267: LIST
100268: LIST
100269: LIST
100270: LIST
100271: LIST
100272: LIST
100273: LIST
100274: LIST
100275: LIST
100276: LIST
100277: LIST
100278: LIST
100279: LIST
100280: ST_TO_ADDR
// tmp :=  ;
100281: LD_ADDR_VAR 0 3
100285: PUSH
100286: LD_STRING 
100288: ST_TO_ADDR
// for i = 1 to normalCounter do
100289: LD_ADDR_VAR 0 8
100293: PUSH
100294: DOUBLE
100295: LD_INT 1
100297: DEC
100298: ST_TO_ADDR
100299: LD_EXP 78
100303: PUSH
100304: FOR_TO
100305: IFFALSE 100341
// begin if flags [ i ] then
100307: LD_VAR 0 4
100311: PUSH
100312: LD_VAR 0 8
100316: ARRAY
100317: IFFALSE 100339
// tmp := tmp & i & ; ;
100319: LD_ADDR_VAR 0 3
100323: PUSH
100324: LD_VAR 0 3
100328: PUSH
100329: LD_VAR 0 8
100333: STR
100334: PUSH
100335: LD_STRING ;
100337: STR
100338: ST_TO_ADDR
// end ;
100339: GO 100304
100341: POP
100342: POP
// for i = 1 to hardcoreCounter do
100343: LD_ADDR_VAR 0 8
100347: PUSH
100348: DOUBLE
100349: LD_INT 1
100351: DEC
100352: ST_TO_ADDR
100353: LD_EXP 79
100357: PUSH
100358: FOR_TO
100359: IFFALSE 100405
// begin if flags [ normalCounter + i ] then
100361: LD_VAR 0 4
100365: PUSH
100366: LD_EXP 78
100370: PUSH
100371: LD_VAR 0 8
100375: PLUS
100376: ARRAY
100377: IFFALSE 100403
// tmp := tmp & ( 100 + i ) & ; ;
100379: LD_ADDR_VAR 0 3
100383: PUSH
100384: LD_VAR 0 3
100388: PUSH
100389: LD_INT 100
100391: PUSH
100392: LD_VAR 0 8
100396: PLUS
100397: STR
100398: PUSH
100399: LD_STRING ;
100401: STR
100402: ST_TO_ADDR
// end ;
100403: GO 100358
100405: POP
100406: POP
// if tmp then
100407: LD_VAR 0 3
100411: IFFALSE 100423
// active := tmp ;
100413: LD_ADDR_VAR 0 7
100417: PUSH
100418: LD_VAR 0 3
100422: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
100423: LD_STRING getStreamItemsFromMission("
100425: PUSH
100426: LD_VAR 0 5
100430: STR
100431: PUSH
100432: LD_STRING ","
100434: STR
100435: PUSH
100436: LD_VAR 0 6
100440: STR
100441: PUSH
100442: LD_STRING ","
100444: STR
100445: PUSH
100446: LD_VAR 0 7
100450: STR
100451: PUSH
100452: LD_STRING ")
100454: STR
100455: PPUSH
100456: CALL_OW 559
// end else
100460: GO 100469
// ToLua ( getStreamItemsFromMission("","","") ) ;
100462: LD_STRING getStreamItemsFromMission("","","")
100464: PPUSH
100465: CALL_OW 559
// end ;
100469: LD_VAR 0 2
100473: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
100474: LD_EXP 77
100478: PUSH
100479: LD_EXP 82
100483: AND
100484: IFFALSE 100608
100486: GO 100488
100488: DISABLE
100489: LD_INT 0
100491: PPUSH
100492: PPUSH
// begin enable ;
100493: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
100494: LD_ADDR_VAR 0 2
100498: PUSH
100499: LD_INT 22
100501: PUSH
100502: LD_OWVAR 2
100506: PUSH
100507: EMPTY
100508: LIST
100509: LIST
100510: PUSH
100511: LD_INT 2
100513: PUSH
100514: LD_INT 34
100516: PUSH
100517: LD_INT 7
100519: PUSH
100520: EMPTY
100521: LIST
100522: LIST
100523: PUSH
100524: LD_INT 34
100526: PUSH
100527: LD_INT 45
100529: PUSH
100530: EMPTY
100531: LIST
100532: LIST
100533: PUSH
100534: LD_INT 34
100536: PUSH
100537: LD_INT 28
100539: PUSH
100540: EMPTY
100541: LIST
100542: LIST
100543: PUSH
100544: LD_INT 34
100546: PUSH
100547: LD_INT 47
100549: PUSH
100550: EMPTY
100551: LIST
100552: LIST
100553: PUSH
100554: EMPTY
100555: LIST
100556: LIST
100557: LIST
100558: LIST
100559: LIST
100560: PUSH
100561: EMPTY
100562: LIST
100563: LIST
100564: PPUSH
100565: CALL_OW 69
100569: ST_TO_ADDR
// if not tmp then
100570: LD_VAR 0 2
100574: NOT
100575: IFFALSE 100579
// exit ;
100577: GO 100608
// for i in tmp do
100579: LD_ADDR_VAR 0 1
100583: PUSH
100584: LD_VAR 0 2
100588: PUSH
100589: FOR_IN
100590: IFFALSE 100606
// begin SetLives ( i , 0 ) ;
100592: LD_VAR 0 1
100596: PPUSH
100597: LD_INT 0
100599: PPUSH
100600: CALL_OW 234
// end ;
100604: GO 100589
100606: POP
100607: POP
// end ;
100608: PPOPN 2
100610: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
100611: LD_EXP 77
100615: PUSH
100616: LD_EXP 83
100620: AND
100621: IFFALSE 100705
100623: GO 100625
100625: DISABLE
100626: LD_INT 0
100628: PPUSH
100629: PPUSH
// begin enable ;
100630: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
100631: LD_ADDR_VAR 0 2
100635: PUSH
100636: LD_INT 22
100638: PUSH
100639: LD_OWVAR 2
100643: PUSH
100644: EMPTY
100645: LIST
100646: LIST
100647: PUSH
100648: LD_INT 32
100650: PUSH
100651: LD_INT 3
100653: PUSH
100654: EMPTY
100655: LIST
100656: LIST
100657: PUSH
100658: EMPTY
100659: LIST
100660: LIST
100661: PPUSH
100662: CALL_OW 69
100666: ST_TO_ADDR
// if not tmp then
100667: LD_VAR 0 2
100671: NOT
100672: IFFALSE 100676
// exit ;
100674: GO 100705
// for i in tmp do
100676: LD_ADDR_VAR 0 1
100680: PUSH
100681: LD_VAR 0 2
100685: PUSH
100686: FOR_IN
100687: IFFALSE 100703
// begin SetLives ( i , 0 ) ;
100689: LD_VAR 0 1
100693: PPUSH
100694: LD_INT 0
100696: PPUSH
100697: CALL_OW 234
// end ;
100701: GO 100686
100703: POP
100704: POP
// end ;
100705: PPOPN 2
100707: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
100708: LD_EXP 77
100712: PUSH
100713: LD_EXP 80
100717: AND
100718: IFFALSE 100811
100720: GO 100722
100722: DISABLE
100723: LD_INT 0
100725: PPUSH
// begin enable ;
100726: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
100727: LD_ADDR_VAR 0 1
100731: PUSH
100732: LD_INT 22
100734: PUSH
100735: LD_OWVAR 2
100739: PUSH
100740: EMPTY
100741: LIST
100742: LIST
100743: PUSH
100744: LD_INT 2
100746: PUSH
100747: LD_INT 25
100749: PUSH
100750: LD_INT 5
100752: PUSH
100753: EMPTY
100754: LIST
100755: LIST
100756: PUSH
100757: LD_INT 25
100759: PUSH
100760: LD_INT 9
100762: PUSH
100763: EMPTY
100764: LIST
100765: LIST
100766: PUSH
100767: LD_INT 25
100769: PUSH
100770: LD_INT 8
100772: PUSH
100773: EMPTY
100774: LIST
100775: LIST
100776: PUSH
100777: EMPTY
100778: LIST
100779: LIST
100780: LIST
100781: LIST
100782: PUSH
100783: EMPTY
100784: LIST
100785: LIST
100786: PPUSH
100787: CALL_OW 69
100791: PUSH
100792: FOR_IN
100793: IFFALSE 100809
// begin SetClass ( i , 1 ) ;
100795: LD_VAR 0 1
100799: PPUSH
100800: LD_INT 1
100802: PPUSH
100803: CALL_OW 336
// end ;
100807: GO 100792
100809: POP
100810: POP
// end ;
100811: PPOPN 1
100813: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
100814: LD_EXP 77
100818: PUSH
100819: LD_EXP 81
100823: AND
100824: PUSH
100825: LD_OWVAR 65
100829: PUSH
100830: LD_INT 7
100832: LESS
100833: AND
100834: IFFALSE 100848
100836: GO 100838
100838: DISABLE
// begin enable ;
100839: ENABLE
// game_speed := 7 ;
100840: LD_ADDR_OWVAR 65
100844: PUSH
100845: LD_INT 7
100847: ST_TO_ADDR
// end ;
100848: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
100849: LD_EXP 77
100853: PUSH
100854: LD_EXP 84
100858: AND
100859: IFFALSE 101061
100861: GO 100863
100863: DISABLE
100864: LD_INT 0
100866: PPUSH
100867: PPUSH
100868: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
100869: LD_ADDR_VAR 0 3
100873: PUSH
100874: LD_INT 81
100876: PUSH
100877: LD_OWVAR 2
100881: PUSH
100882: EMPTY
100883: LIST
100884: LIST
100885: PUSH
100886: LD_INT 21
100888: PUSH
100889: LD_INT 1
100891: PUSH
100892: EMPTY
100893: LIST
100894: LIST
100895: PUSH
100896: EMPTY
100897: LIST
100898: LIST
100899: PPUSH
100900: CALL_OW 69
100904: ST_TO_ADDR
// if not tmp then
100905: LD_VAR 0 3
100909: NOT
100910: IFFALSE 100914
// exit ;
100912: GO 101061
// if tmp > 5 then
100914: LD_VAR 0 3
100918: PUSH
100919: LD_INT 5
100921: GREATER
100922: IFFALSE 100934
// k := 5 else
100924: LD_ADDR_VAR 0 2
100928: PUSH
100929: LD_INT 5
100931: ST_TO_ADDR
100932: GO 100944
// k := tmp ;
100934: LD_ADDR_VAR 0 2
100938: PUSH
100939: LD_VAR 0 3
100943: ST_TO_ADDR
// for i := 1 to k do
100944: LD_ADDR_VAR 0 1
100948: PUSH
100949: DOUBLE
100950: LD_INT 1
100952: DEC
100953: ST_TO_ADDR
100954: LD_VAR 0 2
100958: PUSH
100959: FOR_TO
100960: IFFALSE 101059
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
100962: LD_VAR 0 3
100966: PUSH
100967: LD_VAR 0 1
100971: ARRAY
100972: PPUSH
100973: LD_VAR 0 1
100977: PUSH
100978: LD_INT 4
100980: MOD
100981: PUSH
100982: LD_INT 1
100984: PLUS
100985: PPUSH
100986: CALL_OW 259
100990: PUSH
100991: LD_INT 10
100993: LESS
100994: IFFALSE 101057
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
100996: LD_VAR 0 3
101000: PUSH
101001: LD_VAR 0 1
101005: ARRAY
101006: PPUSH
101007: LD_VAR 0 1
101011: PUSH
101012: LD_INT 4
101014: MOD
101015: PUSH
101016: LD_INT 1
101018: PLUS
101019: PPUSH
101020: LD_VAR 0 3
101024: PUSH
101025: LD_VAR 0 1
101029: ARRAY
101030: PPUSH
101031: LD_VAR 0 1
101035: PUSH
101036: LD_INT 4
101038: MOD
101039: PUSH
101040: LD_INT 1
101042: PLUS
101043: PPUSH
101044: CALL_OW 259
101048: PUSH
101049: LD_INT 1
101051: PLUS
101052: PPUSH
101053: CALL_OW 237
101057: GO 100959
101059: POP
101060: POP
// end ;
101061: PPOPN 3
101063: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
101064: LD_EXP 77
101068: PUSH
101069: LD_EXP 85
101073: AND
101074: IFFALSE 101094
101076: GO 101078
101078: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
101079: LD_INT 4
101081: PPUSH
101082: LD_OWVAR 2
101086: PPUSH
101087: LD_INT 0
101089: PPUSH
101090: CALL_OW 324
101094: END
// every 0 0$1 trigger StreamModeActive and sShovel do
101095: LD_EXP 77
101099: PUSH
101100: LD_EXP 114
101104: AND
101105: IFFALSE 101125
101107: GO 101109
101109: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
101110: LD_INT 19
101112: PPUSH
101113: LD_OWVAR 2
101117: PPUSH
101118: LD_INT 0
101120: PPUSH
101121: CALL_OW 324
101125: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
101126: LD_EXP 77
101130: PUSH
101131: LD_EXP 86
101135: AND
101136: IFFALSE 101238
101138: GO 101140
101140: DISABLE
101141: LD_INT 0
101143: PPUSH
101144: PPUSH
// begin enable ;
101145: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
101146: LD_ADDR_VAR 0 2
101150: PUSH
101151: LD_INT 22
101153: PUSH
101154: LD_OWVAR 2
101158: PUSH
101159: EMPTY
101160: LIST
101161: LIST
101162: PUSH
101163: LD_INT 2
101165: PUSH
101166: LD_INT 34
101168: PUSH
101169: LD_INT 11
101171: PUSH
101172: EMPTY
101173: LIST
101174: LIST
101175: PUSH
101176: LD_INT 34
101178: PUSH
101179: LD_INT 30
101181: PUSH
101182: EMPTY
101183: LIST
101184: LIST
101185: PUSH
101186: EMPTY
101187: LIST
101188: LIST
101189: LIST
101190: PUSH
101191: EMPTY
101192: LIST
101193: LIST
101194: PPUSH
101195: CALL_OW 69
101199: ST_TO_ADDR
// if not tmp then
101200: LD_VAR 0 2
101204: NOT
101205: IFFALSE 101209
// exit ;
101207: GO 101238
// for i in tmp do
101209: LD_ADDR_VAR 0 1
101213: PUSH
101214: LD_VAR 0 2
101218: PUSH
101219: FOR_IN
101220: IFFALSE 101236
// begin SetLives ( i , 0 ) ;
101222: LD_VAR 0 1
101226: PPUSH
101227: LD_INT 0
101229: PPUSH
101230: CALL_OW 234
// end ;
101234: GO 101219
101236: POP
101237: POP
// end ;
101238: PPOPN 2
101240: END
// every 0 0$1 trigger StreamModeActive and sBunker do
101241: LD_EXP 77
101245: PUSH
101246: LD_EXP 87
101250: AND
101251: IFFALSE 101271
101253: GO 101255
101255: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
101256: LD_INT 32
101258: PPUSH
101259: LD_OWVAR 2
101263: PPUSH
101264: LD_INT 0
101266: PPUSH
101267: CALL_OW 324
101271: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
101272: LD_EXP 77
101276: PUSH
101277: LD_EXP 88
101281: AND
101282: IFFALSE 101463
101284: GO 101286
101286: DISABLE
101287: LD_INT 0
101289: PPUSH
101290: PPUSH
101291: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
101292: LD_ADDR_VAR 0 2
101296: PUSH
101297: LD_INT 22
101299: PUSH
101300: LD_OWVAR 2
101304: PUSH
101305: EMPTY
101306: LIST
101307: LIST
101308: PUSH
101309: LD_INT 33
101311: PUSH
101312: LD_INT 3
101314: PUSH
101315: EMPTY
101316: LIST
101317: LIST
101318: PUSH
101319: EMPTY
101320: LIST
101321: LIST
101322: PPUSH
101323: CALL_OW 69
101327: ST_TO_ADDR
// if not tmp then
101328: LD_VAR 0 2
101332: NOT
101333: IFFALSE 101337
// exit ;
101335: GO 101463
// side := 0 ;
101337: LD_ADDR_VAR 0 3
101341: PUSH
101342: LD_INT 0
101344: ST_TO_ADDR
// for i := 1 to 8 do
101345: LD_ADDR_VAR 0 1
101349: PUSH
101350: DOUBLE
101351: LD_INT 1
101353: DEC
101354: ST_TO_ADDR
101355: LD_INT 8
101357: PUSH
101358: FOR_TO
101359: IFFALSE 101407
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
101361: LD_OWVAR 2
101365: PUSH
101366: LD_VAR 0 1
101370: NONEQUAL
101371: PUSH
101372: LD_OWVAR 2
101376: PPUSH
101377: LD_VAR 0 1
101381: PPUSH
101382: CALL_OW 81
101386: PUSH
101387: LD_INT 2
101389: EQUAL
101390: AND
101391: IFFALSE 101405
// begin side := i ;
101393: LD_ADDR_VAR 0 3
101397: PUSH
101398: LD_VAR 0 1
101402: ST_TO_ADDR
// break ;
101403: GO 101407
// end ;
101405: GO 101358
101407: POP
101408: POP
// if not side then
101409: LD_VAR 0 3
101413: NOT
101414: IFFALSE 101418
// exit ;
101416: GO 101463
// for i := 1 to tmp do
101418: LD_ADDR_VAR 0 1
101422: PUSH
101423: DOUBLE
101424: LD_INT 1
101426: DEC
101427: ST_TO_ADDR
101428: LD_VAR 0 2
101432: PUSH
101433: FOR_TO
101434: IFFALSE 101461
// if Prob ( 60 ) then
101436: LD_INT 60
101438: PPUSH
101439: CALL_OW 13
101443: IFFALSE 101459
// SetSide ( i , side ) ;
101445: LD_VAR 0 1
101449: PPUSH
101450: LD_VAR 0 3
101454: PPUSH
101455: CALL_OW 235
101459: GO 101433
101461: POP
101462: POP
// end ;
101463: PPOPN 3
101465: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
101466: LD_EXP 77
101470: PUSH
101471: LD_EXP 90
101475: AND
101476: IFFALSE 101595
101478: GO 101480
101480: DISABLE
101481: LD_INT 0
101483: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
101484: LD_ADDR_VAR 0 1
101488: PUSH
101489: LD_INT 22
101491: PUSH
101492: LD_OWVAR 2
101496: PUSH
101497: EMPTY
101498: LIST
101499: LIST
101500: PUSH
101501: LD_INT 21
101503: PUSH
101504: LD_INT 1
101506: PUSH
101507: EMPTY
101508: LIST
101509: LIST
101510: PUSH
101511: LD_INT 3
101513: PUSH
101514: LD_INT 23
101516: PUSH
101517: LD_INT 0
101519: PUSH
101520: EMPTY
101521: LIST
101522: LIST
101523: PUSH
101524: EMPTY
101525: LIST
101526: LIST
101527: PUSH
101528: EMPTY
101529: LIST
101530: LIST
101531: LIST
101532: PPUSH
101533: CALL_OW 69
101537: PUSH
101538: FOR_IN
101539: IFFALSE 101593
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
101541: LD_VAR 0 1
101545: PPUSH
101546: CALL_OW 257
101550: PUSH
101551: LD_INT 1
101553: PUSH
101554: LD_INT 2
101556: PUSH
101557: LD_INT 3
101559: PUSH
101560: LD_INT 4
101562: PUSH
101563: EMPTY
101564: LIST
101565: LIST
101566: LIST
101567: LIST
101568: IN
101569: IFFALSE 101591
// SetClass ( un , rand ( 1 , 4 ) ) ;
101571: LD_VAR 0 1
101575: PPUSH
101576: LD_INT 1
101578: PPUSH
101579: LD_INT 4
101581: PPUSH
101582: CALL_OW 12
101586: PPUSH
101587: CALL_OW 336
101591: GO 101538
101593: POP
101594: POP
// end ;
101595: PPOPN 1
101597: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
101598: LD_EXP 77
101602: PUSH
101603: LD_EXP 89
101607: AND
101608: IFFALSE 101687
101610: GO 101612
101612: DISABLE
101613: LD_INT 0
101615: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
101616: LD_ADDR_VAR 0 1
101620: PUSH
101621: LD_INT 22
101623: PUSH
101624: LD_OWVAR 2
101628: PUSH
101629: EMPTY
101630: LIST
101631: LIST
101632: PUSH
101633: LD_INT 21
101635: PUSH
101636: LD_INT 3
101638: PUSH
101639: EMPTY
101640: LIST
101641: LIST
101642: PUSH
101643: EMPTY
101644: LIST
101645: LIST
101646: PPUSH
101647: CALL_OW 69
101651: ST_TO_ADDR
// if not tmp then
101652: LD_VAR 0 1
101656: NOT
101657: IFFALSE 101661
// exit ;
101659: GO 101687
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
101661: LD_VAR 0 1
101665: PUSH
101666: LD_INT 1
101668: PPUSH
101669: LD_VAR 0 1
101673: PPUSH
101674: CALL_OW 12
101678: ARRAY
101679: PPUSH
101680: LD_INT 100
101682: PPUSH
101683: CALL_OW 234
// end ;
101687: PPOPN 1
101689: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
101690: LD_EXP 77
101694: PUSH
101695: LD_EXP 91
101699: AND
101700: IFFALSE 101798
101702: GO 101704
101704: DISABLE
101705: LD_INT 0
101707: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101708: LD_ADDR_VAR 0 1
101712: PUSH
101713: LD_INT 22
101715: PUSH
101716: LD_OWVAR 2
101720: PUSH
101721: EMPTY
101722: LIST
101723: LIST
101724: PUSH
101725: LD_INT 21
101727: PUSH
101728: LD_INT 1
101730: PUSH
101731: EMPTY
101732: LIST
101733: LIST
101734: PUSH
101735: EMPTY
101736: LIST
101737: LIST
101738: PPUSH
101739: CALL_OW 69
101743: ST_TO_ADDR
// if not tmp then
101744: LD_VAR 0 1
101748: NOT
101749: IFFALSE 101753
// exit ;
101751: GO 101798
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
101753: LD_VAR 0 1
101757: PUSH
101758: LD_INT 1
101760: PPUSH
101761: LD_VAR 0 1
101765: PPUSH
101766: CALL_OW 12
101770: ARRAY
101771: PPUSH
101772: LD_INT 1
101774: PPUSH
101775: LD_INT 4
101777: PPUSH
101778: CALL_OW 12
101782: PPUSH
101783: LD_INT 3000
101785: PPUSH
101786: LD_INT 9000
101788: PPUSH
101789: CALL_OW 12
101793: PPUSH
101794: CALL_OW 492
// end ;
101798: PPOPN 1
101800: END
// every 0 0$1 trigger StreamModeActive and sDepot do
101801: LD_EXP 77
101805: PUSH
101806: LD_EXP 92
101810: AND
101811: IFFALSE 101831
101813: GO 101815
101815: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
101816: LD_INT 1
101818: PPUSH
101819: LD_OWVAR 2
101823: PPUSH
101824: LD_INT 0
101826: PPUSH
101827: CALL_OW 324
101831: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
101832: LD_EXP 77
101836: PUSH
101837: LD_EXP 93
101841: AND
101842: IFFALSE 101925
101844: GO 101846
101846: DISABLE
101847: LD_INT 0
101849: PPUSH
101850: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
101851: LD_ADDR_VAR 0 2
101855: PUSH
101856: LD_INT 22
101858: PUSH
101859: LD_OWVAR 2
101863: PUSH
101864: EMPTY
101865: LIST
101866: LIST
101867: PUSH
101868: LD_INT 21
101870: PUSH
101871: LD_INT 3
101873: PUSH
101874: EMPTY
101875: LIST
101876: LIST
101877: PUSH
101878: EMPTY
101879: LIST
101880: LIST
101881: PPUSH
101882: CALL_OW 69
101886: ST_TO_ADDR
// if not tmp then
101887: LD_VAR 0 2
101891: NOT
101892: IFFALSE 101896
// exit ;
101894: GO 101925
// for i in tmp do
101896: LD_ADDR_VAR 0 1
101900: PUSH
101901: LD_VAR 0 2
101905: PUSH
101906: FOR_IN
101907: IFFALSE 101923
// SetBLevel ( i , 10 ) ;
101909: LD_VAR 0 1
101913: PPUSH
101914: LD_INT 10
101916: PPUSH
101917: CALL_OW 241
101921: GO 101906
101923: POP
101924: POP
// end ;
101925: PPOPN 2
101927: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
101928: LD_EXP 77
101932: PUSH
101933: LD_EXP 94
101937: AND
101938: IFFALSE 102049
101940: GO 101942
101942: DISABLE
101943: LD_INT 0
101945: PPUSH
101946: PPUSH
101947: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101948: LD_ADDR_VAR 0 3
101952: PUSH
101953: LD_INT 22
101955: PUSH
101956: LD_OWVAR 2
101960: PUSH
101961: EMPTY
101962: LIST
101963: LIST
101964: PUSH
101965: LD_INT 25
101967: PUSH
101968: LD_INT 1
101970: PUSH
101971: EMPTY
101972: LIST
101973: LIST
101974: PUSH
101975: EMPTY
101976: LIST
101977: LIST
101978: PPUSH
101979: CALL_OW 69
101983: ST_TO_ADDR
// if not tmp then
101984: LD_VAR 0 3
101988: NOT
101989: IFFALSE 101993
// exit ;
101991: GO 102049
// un := tmp [ rand ( 1 , tmp ) ] ;
101993: LD_ADDR_VAR 0 2
101997: PUSH
101998: LD_VAR 0 3
102002: PUSH
102003: LD_INT 1
102005: PPUSH
102006: LD_VAR 0 3
102010: PPUSH
102011: CALL_OW 12
102015: ARRAY
102016: ST_TO_ADDR
// if Crawls ( un ) then
102017: LD_VAR 0 2
102021: PPUSH
102022: CALL_OW 318
102026: IFFALSE 102037
// ComWalk ( un ) ;
102028: LD_VAR 0 2
102032: PPUSH
102033: CALL_OW 138
// SetClass ( un , class_sniper ) ;
102037: LD_VAR 0 2
102041: PPUSH
102042: LD_INT 5
102044: PPUSH
102045: CALL_OW 336
// end ;
102049: PPOPN 3
102051: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
102052: LD_EXP 77
102056: PUSH
102057: LD_EXP 95
102061: AND
102062: PUSH
102063: LD_OWVAR 67
102067: PUSH
102068: LD_INT 4
102070: LESS
102071: AND
102072: IFFALSE 102091
102074: GO 102076
102076: DISABLE
// begin Difficulty := Difficulty + 1 ;
102077: LD_ADDR_OWVAR 67
102081: PUSH
102082: LD_OWVAR 67
102086: PUSH
102087: LD_INT 1
102089: PLUS
102090: ST_TO_ADDR
// end ;
102091: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
102092: LD_EXP 77
102096: PUSH
102097: LD_EXP 96
102101: AND
102102: IFFALSE 102205
102104: GO 102106
102106: DISABLE
102107: LD_INT 0
102109: PPUSH
// begin for i := 1 to 5 do
102110: LD_ADDR_VAR 0 1
102114: PUSH
102115: DOUBLE
102116: LD_INT 1
102118: DEC
102119: ST_TO_ADDR
102120: LD_INT 5
102122: PUSH
102123: FOR_TO
102124: IFFALSE 102203
// begin uc_nation := nation_nature ;
102126: LD_ADDR_OWVAR 21
102130: PUSH
102131: LD_INT 0
102133: ST_TO_ADDR
// uc_side := 0 ;
102134: LD_ADDR_OWVAR 20
102138: PUSH
102139: LD_INT 0
102141: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
102142: LD_ADDR_OWVAR 29
102146: PUSH
102147: LD_INT 12
102149: PUSH
102150: LD_INT 12
102152: PUSH
102153: EMPTY
102154: LIST
102155: LIST
102156: ST_TO_ADDR
// hc_agressivity := 20 ;
102157: LD_ADDR_OWVAR 35
102161: PUSH
102162: LD_INT 20
102164: ST_TO_ADDR
// hc_class := class_tiger ;
102165: LD_ADDR_OWVAR 28
102169: PUSH
102170: LD_INT 14
102172: ST_TO_ADDR
// hc_gallery :=  ;
102173: LD_ADDR_OWVAR 33
102177: PUSH
102178: LD_STRING 
102180: ST_TO_ADDR
// hc_name :=  ;
102181: LD_ADDR_OWVAR 26
102185: PUSH
102186: LD_STRING 
102188: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
102189: CALL_OW 44
102193: PPUSH
102194: LD_INT 0
102196: PPUSH
102197: CALL_OW 51
// end ;
102201: GO 102123
102203: POP
102204: POP
// end ;
102205: PPOPN 1
102207: END
// every 0 0$1 trigger StreamModeActive and sBomb do
102208: LD_EXP 77
102212: PUSH
102213: LD_EXP 97
102217: AND
102218: IFFALSE 102227
102220: GO 102222
102222: DISABLE
// StreamSibBomb ;
102223: CALL 102228 0 0
102227: END
// export function StreamSibBomb ; var i , x , y ; begin
102228: LD_INT 0
102230: PPUSH
102231: PPUSH
102232: PPUSH
102233: PPUSH
// result := false ;
102234: LD_ADDR_VAR 0 1
102238: PUSH
102239: LD_INT 0
102241: ST_TO_ADDR
// for i := 1 to 16 do
102242: LD_ADDR_VAR 0 2
102246: PUSH
102247: DOUBLE
102248: LD_INT 1
102250: DEC
102251: ST_TO_ADDR
102252: LD_INT 16
102254: PUSH
102255: FOR_TO
102256: IFFALSE 102455
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
102258: LD_ADDR_VAR 0 3
102262: PUSH
102263: LD_INT 10
102265: PUSH
102266: LD_INT 20
102268: PUSH
102269: LD_INT 30
102271: PUSH
102272: LD_INT 40
102274: PUSH
102275: LD_INT 50
102277: PUSH
102278: LD_INT 60
102280: PUSH
102281: LD_INT 70
102283: PUSH
102284: LD_INT 80
102286: PUSH
102287: LD_INT 90
102289: PUSH
102290: LD_INT 100
102292: PUSH
102293: LD_INT 110
102295: PUSH
102296: LD_INT 120
102298: PUSH
102299: LD_INT 130
102301: PUSH
102302: LD_INT 140
102304: PUSH
102305: LD_INT 150
102307: PUSH
102308: EMPTY
102309: LIST
102310: LIST
102311: LIST
102312: LIST
102313: LIST
102314: LIST
102315: LIST
102316: LIST
102317: LIST
102318: LIST
102319: LIST
102320: LIST
102321: LIST
102322: LIST
102323: LIST
102324: PUSH
102325: LD_INT 1
102327: PPUSH
102328: LD_INT 15
102330: PPUSH
102331: CALL_OW 12
102335: ARRAY
102336: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
102337: LD_ADDR_VAR 0 4
102341: PUSH
102342: LD_INT 10
102344: PUSH
102345: LD_INT 20
102347: PUSH
102348: LD_INT 30
102350: PUSH
102351: LD_INT 40
102353: PUSH
102354: LD_INT 50
102356: PUSH
102357: LD_INT 60
102359: PUSH
102360: LD_INT 70
102362: PUSH
102363: LD_INT 80
102365: PUSH
102366: LD_INT 90
102368: PUSH
102369: LD_INT 100
102371: PUSH
102372: LD_INT 110
102374: PUSH
102375: LD_INT 120
102377: PUSH
102378: LD_INT 130
102380: PUSH
102381: LD_INT 140
102383: PUSH
102384: LD_INT 150
102386: PUSH
102387: EMPTY
102388: LIST
102389: LIST
102390: LIST
102391: LIST
102392: LIST
102393: LIST
102394: LIST
102395: LIST
102396: LIST
102397: LIST
102398: LIST
102399: LIST
102400: LIST
102401: LIST
102402: LIST
102403: PUSH
102404: LD_INT 1
102406: PPUSH
102407: LD_INT 15
102409: PPUSH
102410: CALL_OW 12
102414: ARRAY
102415: ST_TO_ADDR
// if ValidHex ( x , y ) then
102416: LD_VAR 0 3
102420: PPUSH
102421: LD_VAR 0 4
102425: PPUSH
102426: CALL_OW 488
102430: IFFALSE 102453
// begin result := [ x , y ] ;
102432: LD_ADDR_VAR 0 1
102436: PUSH
102437: LD_VAR 0 3
102441: PUSH
102442: LD_VAR 0 4
102446: PUSH
102447: EMPTY
102448: LIST
102449: LIST
102450: ST_TO_ADDR
// break ;
102451: GO 102455
// end ; end ;
102453: GO 102255
102455: POP
102456: POP
// if result then
102457: LD_VAR 0 1
102461: IFFALSE 102521
// begin ToLua ( playSibBomb() ) ;
102463: LD_STRING playSibBomb()
102465: PPUSH
102466: CALL_OW 559
// wait ( 0 0$14 ) ;
102470: LD_INT 490
102472: PPUSH
102473: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
102477: LD_VAR 0 1
102481: PUSH
102482: LD_INT 1
102484: ARRAY
102485: PPUSH
102486: LD_VAR 0 1
102490: PUSH
102491: LD_INT 2
102493: ARRAY
102494: PPUSH
102495: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
102499: LD_VAR 0 1
102503: PUSH
102504: LD_INT 1
102506: ARRAY
102507: PPUSH
102508: LD_VAR 0 1
102512: PUSH
102513: LD_INT 2
102515: ARRAY
102516: PPUSH
102517: CALL_OW 429
// end ; end ;
102521: LD_VAR 0 1
102525: RET
// every 0 0$1 trigger StreamModeActive and sReset do
102526: LD_EXP 77
102530: PUSH
102531: LD_EXP 99
102535: AND
102536: IFFALSE 102548
102538: GO 102540
102540: DISABLE
// YouLost (  ) ;
102541: LD_STRING 
102543: PPUSH
102544: CALL_OW 104
102548: END
// every 0 0$1 trigger StreamModeActive and sFog do
102549: LD_EXP 77
102553: PUSH
102554: LD_EXP 98
102558: AND
102559: IFFALSE 102573
102561: GO 102563
102563: DISABLE
// FogOff ( your_side ) ;
102564: LD_OWVAR 2
102568: PPUSH
102569: CALL_OW 344
102573: END
// every 0 0$1 trigger StreamModeActive and sSun do
102574: LD_EXP 77
102578: PUSH
102579: LD_EXP 100
102583: AND
102584: IFFALSE 102612
102586: GO 102588
102588: DISABLE
// begin solar_recharge_percent := 0 ;
102589: LD_ADDR_OWVAR 79
102593: PUSH
102594: LD_INT 0
102596: ST_TO_ADDR
// wait ( 5 5$00 ) ;
102597: LD_INT 10500
102599: PPUSH
102600: CALL_OW 67
// solar_recharge_percent := 100 ;
102604: LD_ADDR_OWVAR 79
102608: PUSH
102609: LD_INT 100
102611: ST_TO_ADDR
// end ;
102612: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
102613: LD_EXP 77
102617: PUSH
102618: LD_EXP 101
102622: AND
102623: IFFALSE 102862
102625: GO 102627
102627: DISABLE
102628: LD_INT 0
102630: PPUSH
102631: PPUSH
102632: PPUSH
// begin tmp := [ ] ;
102633: LD_ADDR_VAR 0 3
102637: PUSH
102638: EMPTY
102639: ST_TO_ADDR
// for i := 1 to 6 do
102640: LD_ADDR_VAR 0 1
102644: PUSH
102645: DOUBLE
102646: LD_INT 1
102648: DEC
102649: ST_TO_ADDR
102650: LD_INT 6
102652: PUSH
102653: FOR_TO
102654: IFFALSE 102759
// begin uc_nation := nation_nature ;
102656: LD_ADDR_OWVAR 21
102660: PUSH
102661: LD_INT 0
102663: ST_TO_ADDR
// uc_side := 0 ;
102664: LD_ADDR_OWVAR 20
102668: PUSH
102669: LD_INT 0
102671: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
102672: LD_ADDR_OWVAR 29
102676: PUSH
102677: LD_INT 12
102679: PUSH
102680: LD_INT 12
102682: PUSH
102683: EMPTY
102684: LIST
102685: LIST
102686: ST_TO_ADDR
// hc_agressivity := 20 ;
102687: LD_ADDR_OWVAR 35
102691: PUSH
102692: LD_INT 20
102694: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
102695: LD_ADDR_OWVAR 28
102699: PUSH
102700: LD_INT 17
102702: ST_TO_ADDR
// hc_gallery :=  ;
102703: LD_ADDR_OWVAR 33
102707: PUSH
102708: LD_STRING 
102710: ST_TO_ADDR
// hc_name :=  ;
102711: LD_ADDR_OWVAR 26
102715: PUSH
102716: LD_STRING 
102718: ST_TO_ADDR
// un := CreateHuman ;
102719: LD_ADDR_VAR 0 2
102723: PUSH
102724: CALL_OW 44
102728: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
102729: LD_VAR 0 2
102733: PPUSH
102734: LD_INT 1
102736: PPUSH
102737: CALL_OW 51
// tmp := tmp ^ un ;
102741: LD_ADDR_VAR 0 3
102745: PUSH
102746: LD_VAR 0 3
102750: PUSH
102751: LD_VAR 0 2
102755: ADD
102756: ST_TO_ADDR
// end ;
102757: GO 102653
102759: POP
102760: POP
// repeat wait ( 0 0$1 ) ;
102761: LD_INT 35
102763: PPUSH
102764: CALL_OW 67
// for un in tmp do
102768: LD_ADDR_VAR 0 2
102772: PUSH
102773: LD_VAR 0 3
102777: PUSH
102778: FOR_IN
102779: IFFALSE 102853
// begin if IsDead ( un ) then
102781: LD_VAR 0 2
102785: PPUSH
102786: CALL_OW 301
102790: IFFALSE 102810
// begin tmp := tmp diff un ;
102792: LD_ADDR_VAR 0 3
102796: PUSH
102797: LD_VAR 0 3
102801: PUSH
102802: LD_VAR 0 2
102806: DIFF
102807: ST_TO_ADDR
// continue ;
102808: GO 102778
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
102810: LD_VAR 0 2
102814: PPUSH
102815: LD_INT 3
102817: PUSH
102818: LD_INT 22
102820: PUSH
102821: LD_INT 0
102823: PUSH
102824: EMPTY
102825: LIST
102826: LIST
102827: PUSH
102828: EMPTY
102829: LIST
102830: LIST
102831: PPUSH
102832: CALL_OW 69
102836: PPUSH
102837: LD_VAR 0 2
102841: PPUSH
102842: CALL_OW 74
102846: PPUSH
102847: CALL_OW 115
// end ;
102851: GO 102778
102853: POP
102854: POP
// until not tmp ;
102855: LD_VAR 0 3
102859: NOT
102860: IFFALSE 102761
// end ;
102862: PPOPN 3
102864: END
// every 0 0$1 trigger StreamModeActive and sTroll do
102865: LD_EXP 77
102869: PUSH
102870: LD_EXP 102
102874: AND
102875: IFFALSE 102929
102877: GO 102879
102879: DISABLE
// begin ToLua ( displayTroll(); ) ;
102880: LD_STRING displayTroll();
102882: PPUSH
102883: CALL_OW 559
// wait ( 3 3$00 ) ;
102887: LD_INT 6300
102889: PPUSH
102890: CALL_OW 67
// ToLua ( hideTroll(); ) ;
102894: LD_STRING hideTroll();
102896: PPUSH
102897: CALL_OW 559
// wait ( 1 1$00 ) ;
102901: LD_INT 2100
102903: PPUSH
102904: CALL_OW 67
// ToLua ( displayTroll(); ) ;
102908: LD_STRING displayTroll();
102910: PPUSH
102911: CALL_OW 559
// wait ( 1 1$00 ) ;
102915: LD_INT 2100
102917: PPUSH
102918: CALL_OW 67
// ToLua ( hideTroll(); ) ;
102922: LD_STRING hideTroll();
102924: PPUSH
102925: CALL_OW 559
// end ;
102929: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
102930: LD_EXP 77
102934: PUSH
102935: LD_EXP 103
102939: AND
102940: IFFALSE 103003
102942: GO 102944
102944: DISABLE
102945: LD_INT 0
102947: PPUSH
// begin p := 0 ;
102948: LD_ADDR_VAR 0 1
102952: PUSH
102953: LD_INT 0
102955: ST_TO_ADDR
// repeat game_speed := 1 ;
102956: LD_ADDR_OWVAR 65
102960: PUSH
102961: LD_INT 1
102963: ST_TO_ADDR
// wait ( 0 0$1 ) ;
102964: LD_INT 35
102966: PPUSH
102967: CALL_OW 67
// p := p + 1 ;
102971: LD_ADDR_VAR 0 1
102975: PUSH
102976: LD_VAR 0 1
102980: PUSH
102981: LD_INT 1
102983: PLUS
102984: ST_TO_ADDR
// until p >= 60 ;
102985: LD_VAR 0 1
102989: PUSH
102990: LD_INT 60
102992: GREATEREQUAL
102993: IFFALSE 102956
// game_speed := 4 ;
102995: LD_ADDR_OWVAR 65
102999: PUSH
103000: LD_INT 4
103002: ST_TO_ADDR
// end ;
103003: PPOPN 1
103005: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
103006: LD_EXP 77
103010: PUSH
103011: LD_EXP 104
103015: AND
103016: IFFALSE 103162
103018: GO 103020
103020: DISABLE
103021: LD_INT 0
103023: PPUSH
103024: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
103025: LD_ADDR_VAR 0 1
103029: PUSH
103030: LD_INT 22
103032: PUSH
103033: LD_OWVAR 2
103037: PUSH
103038: EMPTY
103039: LIST
103040: LIST
103041: PUSH
103042: LD_INT 2
103044: PUSH
103045: LD_INT 30
103047: PUSH
103048: LD_INT 0
103050: PUSH
103051: EMPTY
103052: LIST
103053: LIST
103054: PUSH
103055: LD_INT 30
103057: PUSH
103058: LD_INT 1
103060: PUSH
103061: EMPTY
103062: LIST
103063: LIST
103064: PUSH
103065: EMPTY
103066: LIST
103067: LIST
103068: LIST
103069: PUSH
103070: EMPTY
103071: LIST
103072: LIST
103073: PPUSH
103074: CALL_OW 69
103078: ST_TO_ADDR
// if not depot then
103079: LD_VAR 0 1
103083: NOT
103084: IFFALSE 103088
// exit ;
103086: GO 103162
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
103088: LD_ADDR_VAR 0 2
103092: PUSH
103093: LD_VAR 0 1
103097: PUSH
103098: LD_INT 1
103100: PPUSH
103101: LD_VAR 0 1
103105: PPUSH
103106: CALL_OW 12
103110: ARRAY
103111: PPUSH
103112: CALL_OW 274
103116: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
103117: LD_VAR 0 2
103121: PPUSH
103122: LD_INT 1
103124: PPUSH
103125: LD_INT 0
103127: PPUSH
103128: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
103132: LD_VAR 0 2
103136: PPUSH
103137: LD_INT 2
103139: PPUSH
103140: LD_INT 0
103142: PPUSH
103143: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
103147: LD_VAR 0 2
103151: PPUSH
103152: LD_INT 3
103154: PPUSH
103155: LD_INT 0
103157: PPUSH
103158: CALL_OW 277
// end ;
103162: PPOPN 2
103164: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
103165: LD_EXP 77
103169: PUSH
103170: LD_EXP 105
103174: AND
103175: IFFALSE 103272
103177: GO 103179
103179: DISABLE
103180: LD_INT 0
103182: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
103183: LD_ADDR_VAR 0 1
103187: PUSH
103188: LD_INT 22
103190: PUSH
103191: LD_OWVAR 2
103195: PUSH
103196: EMPTY
103197: LIST
103198: LIST
103199: PUSH
103200: LD_INT 21
103202: PUSH
103203: LD_INT 1
103205: PUSH
103206: EMPTY
103207: LIST
103208: LIST
103209: PUSH
103210: LD_INT 3
103212: PUSH
103213: LD_INT 23
103215: PUSH
103216: LD_INT 0
103218: PUSH
103219: EMPTY
103220: LIST
103221: LIST
103222: PUSH
103223: EMPTY
103224: LIST
103225: LIST
103226: PUSH
103227: EMPTY
103228: LIST
103229: LIST
103230: LIST
103231: PPUSH
103232: CALL_OW 69
103236: ST_TO_ADDR
// if not tmp then
103237: LD_VAR 0 1
103241: NOT
103242: IFFALSE 103246
// exit ;
103244: GO 103272
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
103246: LD_VAR 0 1
103250: PUSH
103251: LD_INT 1
103253: PPUSH
103254: LD_VAR 0 1
103258: PPUSH
103259: CALL_OW 12
103263: ARRAY
103264: PPUSH
103265: LD_INT 200
103267: PPUSH
103268: CALL_OW 234
// end ;
103272: PPOPN 1
103274: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
103275: LD_EXP 77
103279: PUSH
103280: LD_EXP 106
103284: AND
103285: IFFALSE 103364
103287: GO 103289
103289: DISABLE
103290: LD_INT 0
103292: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
103293: LD_ADDR_VAR 0 1
103297: PUSH
103298: LD_INT 22
103300: PUSH
103301: LD_OWVAR 2
103305: PUSH
103306: EMPTY
103307: LIST
103308: LIST
103309: PUSH
103310: LD_INT 21
103312: PUSH
103313: LD_INT 2
103315: PUSH
103316: EMPTY
103317: LIST
103318: LIST
103319: PUSH
103320: EMPTY
103321: LIST
103322: LIST
103323: PPUSH
103324: CALL_OW 69
103328: ST_TO_ADDR
// if not tmp then
103329: LD_VAR 0 1
103333: NOT
103334: IFFALSE 103338
// exit ;
103336: GO 103364
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
103338: LD_VAR 0 1
103342: PUSH
103343: LD_INT 1
103345: PPUSH
103346: LD_VAR 0 1
103350: PPUSH
103351: CALL_OW 12
103355: ARRAY
103356: PPUSH
103357: LD_INT 60
103359: PPUSH
103360: CALL_OW 234
// end ;
103364: PPOPN 1
103366: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
103367: LD_EXP 77
103371: PUSH
103372: LD_EXP 107
103376: AND
103377: IFFALSE 103476
103379: GO 103381
103381: DISABLE
103382: LD_INT 0
103384: PPUSH
103385: PPUSH
// begin enable ;
103386: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
103387: LD_ADDR_VAR 0 1
103391: PUSH
103392: LD_INT 22
103394: PUSH
103395: LD_OWVAR 2
103399: PUSH
103400: EMPTY
103401: LIST
103402: LIST
103403: PUSH
103404: LD_INT 61
103406: PUSH
103407: EMPTY
103408: LIST
103409: PUSH
103410: LD_INT 33
103412: PUSH
103413: LD_INT 2
103415: PUSH
103416: EMPTY
103417: LIST
103418: LIST
103419: PUSH
103420: EMPTY
103421: LIST
103422: LIST
103423: LIST
103424: PPUSH
103425: CALL_OW 69
103429: ST_TO_ADDR
// if not tmp then
103430: LD_VAR 0 1
103434: NOT
103435: IFFALSE 103439
// exit ;
103437: GO 103476
// for i in tmp do
103439: LD_ADDR_VAR 0 2
103443: PUSH
103444: LD_VAR 0 1
103448: PUSH
103449: FOR_IN
103450: IFFALSE 103474
// if IsControledBy ( i ) then
103452: LD_VAR 0 2
103456: PPUSH
103457: CALL_OW 312
103461: IFFALSE 103472
// ComUnlink ( i ) ;
103463: LD_VAR 0 2
103467: PPUSH
103468: CALL_OW 136
103472: GO 103449
103474: POP
103475: POP
// end ;
103476: PPOPN 2
103478: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
103479: LD_EXP 77
103483: PUSH
103484: LD_EXP 108
103488: AND
103489: IFFALSE 103629
103491: GO 103493
103493: DISABLE
103494: LD_INT 0
103496: PPUSH
103497: PPUSH
// begin ToLua ( displayPowell(); ) ;
103498: LD_STRING displayPowell();
103500: PPUSH
103501: CALL_OW 559
// uc_side := 0 ;
103505: LD_ADDR_OWVAR 20
103509: PUSH
103510: LD_INT 0
103512: ST_TO_ADDR
// uc_nation := 2 ;
103513: LD_ADDR_OWVAR 21
103517: PUSH
103518: LD_INT 2
103520: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
103521: LD_ADDR_OWVAR 37
103525: PUSH
103526: LD_INT 14
103528: ST_TO_ADDR
// vc_engine := engine_siberite ;
103529: LD_ADDR_OWVAR 39
103533: PUSH
103534: LD_INT 3
103536: ST_TO_ADDR
// vc_control := control_apeman ;
103537: LD_ADDR_OWVAR 38
103541: PUSH
103542: LD_INT 5
103544: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
103545: LD_ADDR_OWVAR 40
103549: PUSH
103550: LD_INT 29
103552: ST_TO_ADDR
// un := CreateVehicle ;
103553: LD_ADDR_VAR 0 2
103557: PUSH
103558: CALL_OW 45
103562: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
103563: LD_VAR 0 2
103567: PPUSH
103568: LD_INT 1
103570: PPUSH
103571: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
103575: LD_INT 35
103577: PPUSH
103578: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
103582: LD_VAR 0 2
103586: PPUSH
103587: LD_INT 22
103589: PUSH
103590: LD_OWVAR 2
103594: PUSH
103595: EMPTY
103596: LIST
103597: LIST
103598: PPUSH
103599: CALL_OW 69
103603: PPUSH
103604: LD_VAR 0 2
103608: PPUSH
103609: CALL_OW 74
103613: PPUSH
103614: CALL_OW 115
// until IsDead ( un ) ;
103618: LD_VAR 0 2
103622: PPUSH
103623: CALL_OW 301
103627: IFFALSE 103575
// end ;
103629: PPOPN 2
103631: END
// every 0 0$1 trigger StreamModeActive and sStu do
103632: LD_EXP 77
103636: PUSH
103637: LD_EXP 116
103641: AND
103642: IFFALSE 103658
103644: GO 103646
103646: DISABLE
// begin ToLua ( displayStucuk(); ) ;
103647: LD_STRING displayStucuk();
103649: PPUSH
103650: CALL_OW 559
// ResetFog ;
103654: CALL_OW 335
// end ;
103658: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
103659: LD_EXP 77
103663: PUSH
103664: LD_EXP 109
103668: AND
103669: IFFALSE 103810
103671: GO 103673
103673: DISABLE
103674: LD_INT 0
103676: PPUSH
103677: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
103678: LD_ADDR_VAR 0 2
103682: PUSH
103683: LD_INT 22
103685: PUSH
103686: LD_OWVAR 2
103690: PUSH
103691: EMPTY
103692: LIST
103693: LIST
103694: PUSH
103695: LD_INT 21
103697: PUSH
103698: LD_INT 1
103700: PUSH
103701: EMPTY
103702: LIST
103703: LIST
103704: PUSH
103705: EMPTY
103706: LIST
103707: LIST
103708: PPUSH
103709: CALL_OW 69
103713: ST_TO_ADDR
// if not tmp then
103714: LD_VAR 0 2
103718: NOT
103719: IFFALSE 103723
// exit ;
103721: GO 103810
// un := tmp [ rand ( 1 , tmp ) ] ;
103723: LD_ADDR_VAR 0 1
103727: PUSH
103728: LD_VAR 0 2
103732: PUSH
103733: LD_INT 1
103735: PPUSH
103736: LD_VAR 0 2
103740: PPUSH
103741: CALL_OW 12
103745: ARRAY
103746: ST_TO_ADDR
// SetSide ( un , 0 ) ;
103747: LD_VAR 0 1
103751: PPUSH
103752: LD_INT 0
103754: PPUSH
103755: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
103759: LD_VAR 0 1
103763: PPUSH
103764: LD_OWVAR 3
103768: PUSH
103769: LD_VAR 0 1
103773: DIFF
103774: PPUSH
103775: LD_VAR 0 1
103779: PPUSH
103780: CALL_OW 74
103784: PPUSH
103785: CALL_OW 115
// wait ( 0 0$20 ) ;
103789: LD_INT 700
103791: PPUSH
103792: CALL_OW 67
// SetSide ( un , your_side ) ;
103796: LD_VAR 0 1
103800: PPUSH
103801: LD_OWVAR 2
103805: PPUSH
103806: CALL_OW 235
// end ;
103810: PPOPN 2
103812: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
103813: LD_EXP 77
103817: PUSH
103818: LD_EXP 110
103822: AND
103823: IFFALSE 103929
103825: GO 103827
103827: DISABLE
103828: LD_INT 0
103830: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
103831: LD_ADDR_VAR 0 1
103835: PUSH
103836: LD_INT 22
103838: PUSH
103839: LD_OWVAR 2
103843: PUSH
103844: EMPTY
103845: LIST
103846: LIST
103847: PUSH
103848: LD_INT 2
103850: PUSH
103851: LD_INT 30
103853: PUSH
103854: LD_INT 0
103856: PUSH
103857: EMPTY
103858: LIST
103859: LIST
103860: PUSH
103861: LD_INT 30
103863: PUSH
103864: LD_INT 1
103866: PUSH
103867: EMPTY
103868: LIST
103869: LIST
103870: PUSH
103871: EMPTY
103872: LIST
103873: LIST
103874: LIST
103875: PUSH
103876: EMPTY
103877: LIST
103878: LIST
103879: PPUSH
103880: CALL_OW 69
103884: ST_TO_ADDR
// if not depot then
103885: LD_VAR 0 1
103889: NOT
103890: IFFALSE 103894
// exit ;
103892: GO 103929
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
103894: LD_VAR 0 1
103898: PUSH
103899: LD_INT 1
103901: ARRAY
103902: PPUSH
103903: CALL_OW 250
103907: PPUSH
103908: LD_VAR 0 1
103912: PUSH
103913: LD_INT 1
103915: ARRAY
103916: PPUSH
103917: CALL_OW 251
103921: PPUSH
103922: LD_INT 70
103924: PPUSH
103925: CALL_OW 495
// end ;
103929: PPOPN 1
103931: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
103932: LD_EXP 77
103936: PUSH
103937: LD_EXP 111
103941: AND
103942: IFFALSE 104153
103944: GO 103946
103946: DISABLE
103947: LD_INT 0
103949: PPUSH
103950: PPUSH
103951: PPUSH
103952: PPUSH
103953: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
103954: LD_ADDR_VAR 0 5
103958: PUSH
103959: LD_INT 22
103961: PUSH
103962: LD_OWVAR 2
103966: PUSH
103967: EMPTY
103968: LIST
103969: LIST
103970: PUSH
103971: LD_INT 21
103973: PUSH
103974: LD_INT 1
103976: PUSH
103977: EMPTY
103978: LIST
103979: LIST
103980: PUSH
103981: EMPTY
103982: LIST
103983: LIST
103984: PPUSH
103985: CALL_OW 69
103989: ST_TO_ADDR
// if not tmp then
103990: LD_VAR 0 5
103994: NOT
103995: IFFALSE 103999
// exit ;
103997: GO 104153
// for i in tmp do
103999: LD_ADDR_VAR 0 1
104003: PUSH
104004: LD_VAR 0 5
104008: PUSH
104009: FOR_IN
104010: IFFALSE 104151
// begin d := rand ( 0 , 5 ) ;
104012: LD_ADDR_VAR 0 4
104016: PUSH
104017: LD_INT 0
104019: PPUSH
104020: LD_INT 5
104022: PPUSH
104023: CALL_OW 12
104027: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
104028: LD_ADDR_VAR 0 2
104032: PUSH
104033: LD_VAR 0 1
104037: PPUSH
104038: CALL_OW 250
104042: PPUSH
104043: LD_VAR 0 4
104047: PPUSH
104048: LD_INT 3
104050: PPUSH
104051: LD_INT 12
104053: PPUSH
104054: CALL_OW 12
104058: PPUSH
104059: CALL_OW 272
104063: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
104064: LD_ADDR_VAR 0 3
104068: PUSH
104069: LD_VAR 0 1
104073: PPUSH
104074: CALL_OW 251
104078: PPUSH
104079: LD_VAR 0 4
104083: PPUSH
104084: LD_INT 3
104086: PPUSH
104087: LD_INT 12
104089: PPUSH
104090: CALL_OW 12
104094: PPUSH
104095: CALL_OW 273
104099: ST_TO_ADDR
// if ValidHex ( x , y ) then
104100: LD_VAR 0 2
104104: PPUSH
104105: LD_VAR 0 3
104109: PPUSH
104110: CALL_OW 488
104114: IFFALSE 104149
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
104116: LD_VAR 0 1
104120: PPUSH
104121: LD_VAR 0 2
104125: PPUSH
104126: LD_VAR 0 3
104130: PPUSH
104131: LD_INT 3
104133: PPUSH
104134: LD_INT 6
104136: PPUSH
104137: CALL_OW 12
104141: PPUSH
104142: LD_INT 1
104144: PPUSH
104145: CALL_OW 483
// end ;
104149: GO 104009
104151: POP
104152: POP
// end ;
104153: PPOPN 5
104155: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
104156: LD_EXP 77
104160: PUSH
104161: LD_EXP 112
104165: AND
104166: IFFALSE 104260
104168: GO 104170
104170: DISABLE
104171: LD_INT 0
104173: PPUSH
104174: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
104175: LD_ADDR_VAR 0 2
104179: PUSH
104180: LD_INT 22
104182: PUSH
104183: LD_OWVAR 2
104187: PUSH
104188: EMPTY
104189: LIST
104190: LIST
104191: PUSH
104192: LD_INT 32
104194: PUSH
104195: LD_INT 1
104197: PUSH
104198: EMPTY
104199: LIST
104200: LIST
104201: PUSH
104202: LD_INT 21
104204: PUSH
104205: LD_INT 2
104207: PUSH
104208: EMPTY
104209: LIST
104210: LIST
104211: PUSH
104212: EMPTY
104213: LIST
104214: LIST
104215: LIST
104216: PPUSH
104217: CALL_OW 69
104221: ST_TO_ADDR
// if not tmp then
104222: LD_VAR 0 2
104226: NOT
104227: IFFALSE 104231
// exit ;
104229: GO 104260
// for i in tmp do
104231: LD_ADDR_VAR 0 1
104235: PUSH
104236: LD_VAR 0 2
104240: PUSH
104241: FOR_IN
104242: IFFALSE 104258
// SetFuel ( i , 0 ) ;
104244: LD_VAR 0 1
104248: PPUSH
104249: LD_INT 0
104251: PPUSH
104252: CALL_OW 240
104256: GO 104241
104258: POP
104259: POP
// end ;
104260: PPOPN 2
104262: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
104263: LD_EXP 77
104267: PUSH
104268: LD_EXP 113
104272: AND
104273: IFFALSE 104339
104275: GO 104277
104277: DISABLE
104278: LD_INT 0
104280: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
104281: LD_ADDR_VAR 0 1
104285: PUSH
104286: LD_INT 22
104288: PUSH
104289: LD_OWVAR 2
104293: PUSH
104294: EMPTY
104295: LIST
104296: LIST
104297: PUSH
104298: LD_INT 30
104300: PUSH
104301: LD_INT 29
104303: PUSH
104304: EMPTY
104305: LIST
104306: LIST
104307: PUSH
104308: EMPTY
104309: LIST
104310: LIST
104311: PPUSH
104312: CALL_OW 69
104316: ST_TO_ADDR
// if not tmp then
104317: LD_VAR 0 1
104321: NOT
104322: IFFALSE 104326
// exit ;
104324: GO 104339
// DestroyUnit ( tmp [ 1 ] ) ;
104326: LD_VAR 0 1
104330: PUSH
104331: LD_INT 1
104333: ARRAY
104334: PPUSH
104335: CALL_OW 65
// end ;
104339: PPOPN 1
104341: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
104342: LD_EXP 77
104346: PUSH
104347: LD_EXP 115
104351: AND
104352: IFFALSE 104481
104354: GO 104356
104356: DISABLE
104357: LD_INT 0
104359: PPUSH
// begin uc_side := 0 ;
104360: LD_ADDR_OWVAR 20
104364: PUSH
104365: LD_INT 0
104367: ST_TO_ADDR
// uc_nation := nation_arabian ;
104368: LD_ADDR_OWVAR 21
104372: PUSH
104373: LD_INT 2
104375: ST_TO_ADDR
// hc_gallery :=  ;
104376: LD_ADDR_OWVAR 33
104380: PUSH
104381: LD_STRING 
104383: ST_TO_ADDR
// hc_name :=  ;
104384: LD_ADDR_OWVAR 26
104388: PUSH
104389: LD_STRING 
104391: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
104392: LD_INT 1
104394: PPUSH
104395: LD_INT 11
104397: PPUSH
104398: LD_INT 10
104400: PPUSH
104401: CALL_OW 380
// un := CreateHuman ;
104405: LD_ADDR_VAR 0 1
104409: PUSH
104410: CALL_OW 44
104414: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
104415: LD_VAR 0 1
104419: PPUSH
104420: LD_INT 1
104422: PPUSH
104423: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
104427: LD_INT 35
104429: PPUSH
104430: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
104434: LD_VAR 0 1
104438: PPUSH
104439: LD_INT 22
104441: PUSH
104442: LD_OWVAR 2
104446: PUSH
104447: EMPTY
104448: LIST
104449: LIST
104450: PPUSH
104451: CALL_OW 69
104455: PPUSH
104456: LD_VAR 0 1
104460: PPUSH
104461: CALL_OW 74
104465: PPUSH
104466: CALL_OW 115
// until IsDead ( un ) ;
104470: LD_VAR 0 1
104474: PPUSH
104475: CALL_OW 301
104479: IFFALSE 104427
// end ;
104481: PPOPN 1
104483: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
104484: LD_EXP 77
104488: PUSH
104489: LD_EXP 117
104493: AND
104494: IFFALSE 104506
104496: GO 104498
104498: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
104499: LD_STRING earthquake(getX(game), 0, 32)
104501: PPUSH
104502: CALL_OW 559
104506: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
104507: LD_EXP 77
104511: PUSH
104512: LD_EXP 118
104516: AND
104517: IFFALSE 104608
104519: GO 104521
104521: DISABLE
104522: LD_INT 0
104524: PPUSH
// begin enable ;
104525: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
104526: LD_ADDR_VAR 0 1
104530: PUSH
104531: LD_INT 22
104533: PUSH
104534: LD_OWVAR 2
104538: PUSH
104539: EMPTY
104540: LIST
104541: LIST
104542: PUSH
104543: LD_INT 21
104545: PUSH
104546: LD_INT 2
104548: PUSH
104549: EMPTY
104550: LIST
104551: LIST
104552: PUSH
104553: LD_INT 33
104555: PUSH
104556: LD_INT 3
104558: PUSH
104559: EMPTY
104560: LIST
104561: LIST
104562: PUSH
104563: EMPTY
104564: LIST
104565: LIST
104566: LIST
104567: PPUSH
104568: CALL_OW 69
104572: ST_TO_ADDR
// if not tmp then
104573: LD_VAR 0 1
104577: NOT
104578: IFFALSE 104582
// exit ;
104580: GO 104608
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
104582: LD_VAR 0 1
104586: PUSH
104587: LD_INT 1
104589: PPUSH
104590: LD_VAR 0 1
104594: PPUSH
104595: CALL_OW 12
104599: ARRAY
104600: PPUSH
104601: LD_INT 1
104603: PPUSH
104604: CALL_OW 234
// end ;
104608: PPOPN 1
104610: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
104611: LD_EXP 77
104615: PUSH
104616: LD_EXP 119
104620: AND
104621: IFFALSE 104762
104623: GO 104625
104625: DISABLE
104626: LD_INT 0
104628: PPUSH
104629: PPUSH
104630: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
104631: LD_ADDR_VAR 0 3
104635: PUSH
104636: LD_INT 22
104638: PUSH
104639: LD_OWVAR 2
104643: PUSH
104644: EMPTY
104645: LIST
104646: LIST
104647: PUSH
104648: LD_INT 25
104650: PUSH
104651: LD_INT 1
104653: PUSH
104654: EMPTY
104655: LIST
104656: LIST
104657: PUSH
104658: EMPTY
104659: LIST
104660: LIST
104661: PPUSH
104662: CALL_OW 69
104666: ST_TO_ADDR
// if not tmp then
104667: LD_VAR 0 3
104671: NOT
104672: IFFALSE 104676
// exit ;
104674: GO 104762
// un := tmp [ rand ( 1 , tmp ) ] ;
104676: LD_ADDR_VAR 0 2
104680: PUSH
104681: LD_VAR 0 3
104685: PUSH
104686: LD_INT 1
104688: PPUSH
104689: LD_VAR 0 3
104693: PPUSH
104694: CALL_OW 12
104698: ARRAY
104699: ST_TO_ADDR
// if Crawls ( un ) then
104700: LD_VAR 0 2
104704: PPUSH
104705: CALL_OW 318
104709: IFFALSE 104720
// ComWalk ( un ) ;
104711: LD_VAR 0 2
104715: PPUSH
104716: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
104720: LD_VAR 0 2
104724: PPUSH
104725: LD_INT 9
104727: PPUSH
104728: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
104732: LD_INT 28
104734: PPUSH
104735: LD_OWVAR 2
104739: PPUSH
104740: LD_INT 2
104742: PPUSH
104743: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
104747: LD_INT 29
104749: PPUSH
104750: LD_OWVAR 2
104754: PPUSH
104755: LD_INT 2
104757: PPUSH
104758: CALL_OW 322
// end ;
104762: PPOPN 3
104764: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
104765: LD_EXP 77
104769: PUSH
104770: LD_EXP 120
104774: AND
104775: IFFALSE 104886
104777: GO 104779
104779: DISABLE
104780: LD_INT 0
104782: PPUSH
104783: PPUSH
104784: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
104785: LD_ADDR_VAR 0 3
104789: PUSH
104790: LD_INT 22
104792: PUSH
104793: LD_OWVAR 2
104797: PUSH
104798: EMPTY
104799: LIST
104800: LIST
104801: PUSH
104802: LD_INT 25
104804: PUSH
104805: LD_INT 1
104807: PUSH
104808: EMPTY
104809: LIST
104810: LIST
104811: PUSH
104812: EMPTY
104813: LIST
104814: LIST
104815: PPUSH
104816: CALL_OW 69
104820: ST_TO_ADDR
// if not tmp then
104821: LD_VAR 0 3
104825: NOT
104826: IFFALSE 104830
// exit ;
104828: GO 104886
// un := tmp [ rand ( 1 , tmp ) ] ;
104830: LD_ADDR_VAR 0 2
104834: PUSH
104835: LD_VAR 0 3
104839: PUSH
104840: LD_INT 1
104842: PPUSH
104843: LD_VAR 0 3
104847: PPUSH
104848: CALL_OW 12
104852: ARRAY
104853: ST_TO_ADDR
// if Crawls ( un ) then
104854: LD_VAR 0 2
104858: PPUSH
104859: CALL_OW 318
104863: IFFALSE 104874
// ComWalk ( un ) ;
104865: LD_VAR 0 2
104869: PPUSH
104870: CALL_OW 138
// SetClass ( un , class_mortar ) ;
104874: LD_VAR 0 2
104878: PPUSH
104879: LD_INT 8
104881: PPUSH
104882: CALL_OW 336
// end ;
104886: PPOPN 3
104888: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
104889: LD_EXP 77
104893: PUSH
104894: LD_EXP 121
104898: AND
104899: IFFALSE 105043
104901: GO 104903
104903: DISABLE
104904: LD_INT 0
104906: PPUSH
104907: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
104908: LD_ADDR_VAR 0 2
104912: PUSH
104913: LD_INT 22
104915: PUSH
104916: LD_OWVAR 2
104920: PUSH
104921: EMPTY
104922: LIST
104923: LIST
104924: PUSH
104925: LD_INT 21
104927: PUSH
104928: LD_INT 2
104930: PUSH
104931: EMPTY
104932: LIST
104933: LIST
104934: PUSH
104935: LD_INT 2
104937: PUSH
104938: LD_INT 34
104940: PUSH
104941: LD_INT 12
104943: PUSH
104944: EMPTY
104945: LIST
104946: LIST
104947: PUSH
104948: LD_INT 34
104950: PUSH
104951: LD_INT 51
104953: PUSH
104954: EMPTY
104955: LIST
104956: LIST
104957: PUSH
104958: LD_INT 34
104960: PUSH
104961: LD_INT 32
104963: PUSH
104964: EMPTY
104965: LIST
104966: LIST
104967: PUSH
104968: EMPTY
104969: LIST
104970: LIST
104971: LIST
104972: LIST
104973: PUSH
104974: EMPTY
104975: LIST
104976: LIST
104977: LIST
104978: PPUSH
104979: CALL_OW 69
104983: ST_TO_ADDR
// if not tmp then
104984: LD_VAR 0 2
104988: NOT
104989: IFFALSE 104993
// exit ;
104991: GO 105043
// for i in tmp do
104993: LD_ADDR_VAR 0 1
104997: PUSH
104998: LD_VAR 0 2
105002: PUSH
105003: FOR_IN
105004: IFFALSE 105041
// if GetCargo ( i , mat_artifact ) = 0 then
105006: LD_VAR 0 1
105010: PPUSH
105011: LD_INT 4
105013: PPUSH
105014: CALL_OW 289
105018: PUSH
105019: LD_INT 0
105021: EQUAL
105022: IFFALSE 105039
// SetCargo ( i , mat_siberit , 100 ) ;
105024: LD_VAR 0 1
105028: PPUSH
105029: LD_INT 3
105031: PPUSH
105032: LD_INT 100
105034: PPUSH
105035: CALL_OW 290
105039: GO 105003
105041: POP
105042: POP
// end ;
105043: PPOPN 2
105045: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
105046: LD_EXP 77
105050: PUSH
105051: LD_EXP 122
105055: AND
105056: IFFALSE 105239
105058: GO 105060
105060: DISABLE
105061: LD_INT 0
105063: PPUSH
105064: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
105065: LD_ADDR_VAR 0 2
105069: PUSH
105070: LD_INT 22
105072: PUSH
105073: LD_OWVAR 2
105077: PUSH
105078: EMPTY
105079: LIST
105080: LIST
105081: PPUSH
105082: CALL_OW 69
105086: ST_TO_ADDR
// if not tmp then
105087: LD_VAR 0 2
105091: NOT
105092: IFFALSE 105096
// exit ;
105094: GO 105239
// for i := 1 to 2 do
105096: LD_ADDR_VAR 0 1
105100: PUSH
105101: DOUBLE
105102: LD_INT 1
105104: DEC
105105: ST_TO_ADDR
105106: LD_INT 2
105108: PUSH
105109: FOR_TO
105110: IFFALSE 105237
// begin uc_side := your_side ;
105112: LD_ADDR_OWVAR 20
105116: PUSH
105117: LD_OWVAR 2
105121: ST_TO_ADDR
// uc_nation := nation_american ;
105122: LD_ADDR_OWVAR 21
105126: PUSH
105127: LD_INT 1
105129: ST_TO_ADDR
// vc_chassis := us_morphling ;
105130: LD_ADDR_OWVAR 37
105134: PUSH
105135: LD_INT 5
105137: ST_TO_ADDR
// vc_engine := engine_siberite ;
105138: LD_ADDR_OWVAR 39
105142: PUSH
105143: LD_INT 3
105145: ST_TO_ADDR
// vc_control := control_computer ;
105146: LD_ADDR_OWVAR 38
105150: PUSH
105151: LD_INT 3
105153: ST_TO_ADDR
// vc_weapon := us_double_laser ;
105154: LD_ADDR_OWVAR 40
105158: PUSH
105159: LD_INT 10
105161: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
105162: LD_VAR 0 2
105166: PUSH
105167: LD_INT 1
105169: ARRAY
105170: PPUSH
105171: CALL_OW 310
105175: NOT
105176: IFFALSE 105223
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
105178: CALL_OW 45
105182: PPUSH
105183: LD_VAR 0 2
105187: PUSH
105188: LD_INT 1
105190: ARRAY
105191: PPUSH
105192: CALL_OW 250
105196: PPUSH
105197: LD_VAR 0 2
105201: PUSH
105202: LD_INT 1
105204: ARRAY
105205: PPUSH
105206: CALL_OW 251
105210: PPUSH
105211: LD_INT 12
105213: PPUSH
105214: LD_INT 1
105216: PPUSH
105217: CALL_OW 50
105221: GO 105235
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
105223: CALL_OW 45
105227: PPUSH
105228: LD_INT 1
105230: PPUSH
105231: CALL_OW 51
// end ;
105235: GO 105109
105237: POP
105238: POP
// end ;
105239: PPOPN 2
105241: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
105242: LD_EXP 77
105246: PUSH
105247: LD_EXP 123
105251: AND
105252: IFFALSE 105474
105254: GO 105256
105256: DISABLE
105257: LD_INT 0
105259: PPUSH
105260: PPUSH
105261: PPUSH
105262: PPUSH
105263: PPUSH
105264: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
105265: LD_ADDR_VAR 0 6
105269: PUSH
105270: LD_INT 22
105272: PUSH
105273: LD_OWVAR 2
105277: PUSH
105278: EMPTY
105279: LIST
105280: LIST
105281: PUSH
105282: LD_INT 21
105284: PUSH
105285: LD_INT 1
105287: PUSH
105288: EMPTY
105289: LIST
105290: LIST
105291: PUSH
105292: LD_INT 3
105294: PUSH
105295: LD_INT 23
105297: PUSH
105298: LD_INT 0
105300: PUSH
105301: EMPTY
105302: LIST
105303: LIST
105304: PUSH
105305: EMPTY
105306: LIST
105307: LIST
105308: PUSH
105309: EMPTY
105310: LIST
105311: LIST
105312: LIST
105313: PPUSH
105314: CALL_OW 69
105318: ST_TO_ADDR
// if not tmp then
105319: LD_VAR 0 6
105323: NOT
105324: IFFALSE 105328
// exit ;
105326: GO 105474
// s1 := rand ( 1 , 4 ) ;
105328: LD_ADDR_VAR 0 2
105332: PUSH
105333: LD_INT 1
105335: PPUSH
105336: LD_INT 4
105338: PPUSH
105339: CALL_OW 12
105343: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
105344: LD_ADDR_VAR 0 4
105348: PUSH
105349: LD_VAR 0 6
105353: PUSH
105354: LD_INT 1
105356: ARRAY
105357: PPUSH
105358: LD_VAR 0 2
105362: PPUSH
105363: CALL_OW 259
105367: ST_TO_ADDR
// if s1 = 1 then
105368: LD_VAR 0 2
105372: PUSH
105373: LD_INT 1
105375: EQUAL
105376: IFFALSE 105396
// s2 := rand ( 2 , 4 ) else
105378: LD_ADDR_VAR 0 3
105382: PUSH
105383: LD_INT 2
105385: PPUSH
105386: LD_INT 4
105388: PPUSH
105389: CALL_OW 12
105393: ST_TO_ADDR
105394: GO 105404
// s2 := 1 ;
105396: LD_ADDR_VAR 0 3
105400: PUSH
105401: LD_INT 1
105403: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
105404: LD_ADDR_VAR 0 5
105408: PUSH
105409: LD_VAR 0 6
105413: PUSH
105414: LD_INT 1
105416: ARRAY
105417: PPUSH
105418: LD_VAR 0 3
105422: PPUSH
105423: CALL_OW 259
105427: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
105428: LD_VAR 0 6
105432: PUSH
105433: LD_INT 1
105435: ARRAY
105436: PPUSH
105437: LD_VAR 0 2
105441: PPUSH
105442: LD_VAR 0 5
105446: PPUSH
105447: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
105451: LD_VAR 0 6
105455: PUSH
105456: LD_INT 1
105458: ARRAY
105459: PPUSH
105460: LD_VAR 0 3
105464: PPUSH
105465: LD_VAR 0 4
105469: PPUSH
105470: CALL_OW 237
// end ;
105474: PPOPN 6
105476: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
105477: LD_EXP 77
105481: PUSH
105482: LD_EXP 124
105486: AND
105487: IFFALSE 105566
105489: GO 105491
105491: DISABLE
105492: LD_INT 0
105494: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
105495: LD_ADDR_VAR 0 1
105499: PUSH
105500: LD_INT 22
105502: PUSH
105503: LD_OWVAR 2
105507: PUSH
105508: EMPTY
105509: LIST
105510: LIST
105511: PUSH
105512: LD_INT 30
105514: PUSH
105515: LD_INT 3
105517: PUSH
105518: EMPTY
105519: LIST
105520: LIST
105521: PUSH
105522: EMPTY
105523: LIST
105524: LIST
105525: PPUSH
105526: CALL_OW 69
105530: ST_TO_ADDR
// if not tmp then
105531: LD_VAR 0 1
105535: NOT
105536: IFFALSE 105540
// exit ;
105538: GO 105566
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
105540: LD_VAR 0 1
105544: PUSH
105545: LD_INT 1
105547: PPUSH
105548: LD_VAR 0 1
105552: PPUSH
105553: CALL_OW 12
105557: ARRAY
105558: PPUSH
105559: LD_INT 1
105561: PPUSH
105562: CALL_OW 234
// end ;
105566: PPOPN 1
105568: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
105569: LD_EXP 77
105573: PUSH
105574: LD_EXP 125
105578: AND
105579: IFFALSE 105691
105581: GO 105583
105583: DISABLE
105584: LD_INT 0
105586: PPUSH
105587: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
105588: LD_ADDR_VAR 0 2
105592: PUSH
105593: LD_INT 22
105595: PUSH
105596: LD_OWVAR 2
105600: PUSH
105601: EMPTY
105602: LIST
105603: LIST
105604: PUSH
105605: LD_INT 2
105607: PUSH
105608: LD_INT 30
105610: PUSH
105611: LD_INT 27
105613: PUSH
105614: EMPTY
105615: LIST
105616: LIST
105617: PUSH
105618: LD_INT 30
105620: PUSH
105621: LD_INT 26
105623: PUSH
105624: EMPTY
105625: LIST
105626: LIST
105627: PUSH
105628: LD_INT 30
105630: PUSH
105631: LD_INT 28
105633: PUSH
105634: EMPTY
105635: LIST
105636: LIST
105637: PUSH
105638: EMPTY
105639: LIST
105640: LIST
105641: LIST
105642: LIST
105643: PUSH
105644: EMPTY
105645: LIST
105646: LIST
105647: PPUSH
105648: CALL_OW 69
105652: ST_TO_ADDR
// if not tmp then
105653: LD_VAR 0 2
105657: NOT
105658: IFFALSE 105662
// exit ;
105660: GO 105691
// for i in tmp do
105662: LD_ADDR_VAR 0 1
105666: PUSH
105667: LD_VAR 0 2
105671: PUSH
105672: FOR_IN
105673: IFFALSE 105689
// SetLives ( i , 1 ) ;
105675: LD_VAR 0 1
105679: PPUSH
105680: LD_INT 1
105682: PPUSH
105683: CALL_OW 234
105687: GO 105672
105689: POP
105690: POP
// end ;
105691: PPOPN 2
105693: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
105694: LD_EXP 77
105698: PUSH
105699: LD_EXP 126
105703: AND
105704: IFFALSE 105991
105706: GO 105708
105708: DISABLE
105709: LD_INT 0
105711: PPUSH
105712: PPUSH
105713: PPUSH
// begin i := rand ( 1 , 7 ) ;
105714: LD_ADDR_VAR 0 1
105718: PUSH
105719: LD_INT 1
105721: PPUSH
105722: LD_INT 7
105724: PPUSH
105725: CALL_OW 12
105729: ST_TO_ADDR
// case i of 1 :
105730: LD_VAR 0 1
105734: PUSH
105735: LD_INT 1
105737: DOUBLE
105738: EQUAL
105739: IFTRUE 105743
105741: GO 105753
105743: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
105744: LD_STRING earthquake(getX(game), 0, 32)
105746: PPUSH
105747: CALL_OW 559
105751: GO 105991
105753: LD_INT 2
105755: DOUBLE
105756: EQUAL
105757: IFTRUE 105761
105759: GO 105775
105761: POP
// begin ToLua ( displayStucuk(); ) ;
105762: LD_STRING displayStucuk();
105764: PPUSH
105765: CALL_OW 559
// ResetFog ;
105769: CALL_OW 335
// end ; 3 :
105773: GO 105991
105775: LD_INT 3
105777: DOUBLE
105778: EQUAL
105779: IFTRUE 105783
105781: GO 105887
105783: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
105784: LD_ADDR_VAR 0 2
105788: PUSH
105789: LD_INT 22
105791: PUSH
105792: LD_OWVAR 2
105796: PUSH
105797: EMPTY
105798: LIST
105799: LIST
105800: PUSH
105801: LD_INT 25
105803: PUSH
105804: LD_INT 1
105806: PUSH
105807: EMPTY
105808: LIST
105809: LIST
105810: PUSH
105811: EMPTY
105812: LIST
105813: LIST
105814: PPUSH
105815: CALL_OW 69
105819: ST_TO_ADDR
// if not tmp then
105820: LD_VAR 0 2
105824: NOT
105825: IFFALSE 105829
// exit ;
105827: GO 105991
// un := tmp [ rand ( 1 , tmp ) ] ;
105829: LD_ADDR_VAR 0 3
105833: PUSH
105834: LD_VAR 0 2
105838: PUSH
105839: LD_INT 1
105841: PPUSH
105842: LD_VAR 0 2
105846: PPUSH
105847: CALL_OW 12
105851: ARRAY
105852: ST_TO_ADDR
// if Crawls ( un ) then
105853: LD_VAR 0 3
105857: PPUSH
105858: CALL_OW 318
105862: IFFALSE 105873
// ComWalk ( un ) ;
105864: LD_VAR 0 3
105868: PPUSH
105869: CALL_OW 138
// SetClass ( un , class_mortar ) ;
105873: LD_VAR 0 3
105877: PPUSH
105878: LD_INT 8
105880: PPUSH
105881: CALL_OW 336
// end ; 4 :
105885: GO 105991
105887: LD_INT 4
105889: DOUBLE
105890: EQUAL
105891: IFTRUE 105895
105893: GO 105969
105895: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
105896: LD_ADDR_VAR 0 2
105900: PUSH
105901: LD_INT 22
105903: PUSH
105904: LD_OWVAR 2
105908: PUSH
105909: EMPTY
105910: LIST
105911: LIST
105912: PUSH
105913: LD_INT 30
105915: PUSH
105916: LD_INT 29
105918: PUSH
105919: EMPTY
105920: LIST
105921: LIST
105922: PUSH
105923: EMPTY
105924: LIST
105925: LIST
105926: PPUSH
105927: CALL_OW 69
105931: ST_TO_ADDR
// if not tmp then
105932: LD_VAR 0 2
105936: NOT
105937: IFFALSE 105941
// exit ;
105939: GO 105991
// CenterNowOnUnits ( tmp [ 1 ] ) ;
105941: LD_VAR 0 2
105945: PUSH
105946: LD_INT 1
105948: ARRAY
105949: PPUSH
105950: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
105954: LD_VAR 0 2
105958: PUSH
105959: LD_INT 1
105961: ARRAY
105962: PPUSH
105963: CALL_OW 65
// end ; 5 .. 7 :
105967: GO 105991
105969: LD_INT 5
105971: DOUBLE
105972: GREATEREQUAL
105973: IFFALSE 105981
105975: LD_INT 7
105977: DOUBLE
105978: LESSEQUAL
105979: IFTRUE 105983
105981: GO 105990
105983: POP
// StreamSibBomb ; end ;
105984: CALL 102228 0 0
105988: GO 105991
105990: POP
// end ;
105991: PPOPN 3
105993: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
105994: LD_EXP 77
105998: PUSH
105999: LD_EXP 127
106003: AND
106004: IFFALSE 106160
106006: GO 106008
106008: DISABLE
106009: LD_INT 0
106011: PPUSH
106012: PPUSH
106013: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
106014: LD_ADDR_VAR 0 2
106018: PUSH
106019: LD_INT 81
106021: PUSH
106022: LD_OWVAR 2
106026: PUSH
106027: EMPTY
106028: LIST
106029: LIST
106030: PUSH
106031: LD_INT 2
106033: PUSH
106034: LD_INT 21
106036: PUSH
106037: LD_INT 1
106039: PUSH
106040: EMPTY
106041: LIST
106042: LIST
106043: PUSH
106044: LD_INT 21
106046: PUSH
106047: LD_INT 2
106049: PUSH
106050: EMPTY
106051: LIST
106052: LIST
106053: PUSH
106054: EMPTY
106055: LIST
106056: LIST
106057: LIST
106058: PUSH
106059: EMPTY
106060: LIST
106061: LIST
106062: PPUSH
106063: CALL_OW 69
106067: ST_TO_ADDR
// if not tmp then
106068: LD_VAR 0 2
106072: NOT
106073: IFFALSE 106077
// exit ;
106075: GO 106160
// p := 0 ;
106077: LD_ADDR_VAR 0 3
106081: PUSH
106082: LD_INT 0
106084: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
106085: LD_INT 35
106087: PPUSH
106088: CALL_OW 67
// p := p + 1 ;
106092: LD_ADDR_VAR 0 3
106096: PUSH
106097: LD_VAR 0 3
106101: PUSH
106102: LD_INT 1
106104: PLUS
106105: ST_TO_ADDR
// for i in tmp do
106106: LD_ADDR_VAR 0 1
106110: PUSH
106111: LD_VAR 0 2
106115: PUSH
106116: FOR_IN
106117: IFFALSE 106148
// if GetLives ( i ) < 1000 then
106119: LD_VAR 0 1
106123: PPUSH
106124: CALL_OW 256
106128: PUSH
106129: LD_INT 1000
106131: LESS
106132: IFFALSE 106146
// SetLives ( i , 1000 ) ;
106134: LD_VAR 0 1
106138: PPUSH
106139: LD_INT 1000
106141: PPUSH
106142: CALL_OW 234
106146: GO 106116
106148: POP
106149: POP
// until p > 20 ;
106150: LD_VAR 0 3
106154: PUSH
106155: LD_INT 20
106157: GREATER
106158: IFFALSE 106085
// end ;
106160: PPOPN 3
106162: END
// every 0 0$1 trigger StreamModeActive and sTime do
106163: LD_EXP 77
106167: PUSH
106168: LD_EXP 128
106172: AND
106173: IFFALSE 106208
106175: GO 106177
106177: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
106178: LD_INT 28
106180: PPUSH
106181: LD_OWVAR 2
106185: PPUSH
106186: LD_INT 2
106188: PPUSH
106189: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
106193: LD_INT 30
106195: PPUSH
106196: LD_OWVAR 2
106200: PPUSH
106201: LD_INT 2
106203: PPUSH
106204: CALL_OW 322
// end ;
106208: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
106209: LD_EXP 77
106213: PUSH
106214: LD_EXP 129
106218: AND
106219: IFFALSE 106340
106221: GO 106223
106223: DISABLE
106224: LD_INT 0
106226: PPUSH
106227: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
106228: LD_ADDR_VAR 0 2
106232: PUSH
106233: LD_INT 22
106235: PUSH
106236: LD_OWVAR 2
106240: PUSH
106241: EMPTY
106242: LIST
106243: LIST
106244: PUSH
106245: LD_INT 21
106247: PUSH
106248: LD_INT 1
106250: PUSH
106251: EMPTY
106252: LIST
106253: LIST
106254: PUSH
106255: LD_INT 3
106257: PUSH
106258: LD_INT 23
106260: PUSH
106261: LD_INT 0
106263: PUSH
106264: EMPTY
106265: LIST
106266: LIST
106267: PUSH
106268: EMPTY
106269: LIST
106270: LIST
106271: PUSH
106272: EMPTY
106273: LIST
106274: LIST
106275: LIST
106276: PPUSH
106277: CALL_OW 69
106281: ST_TO_ADDR
// if not tmp then
106282: LD_VAR 0 2
106286: NOT
106287: IFFALSE 106291
// exit ;
106289: GO 106340
// for i in tmp do
106291: LD_ADDR_VAR 0 1
106295: PUSH
106296: LD_VAR 0 2
106300: PUSH
106301: FOR_IN
106302: IFFALSE 106338
// begin if Crawls ( i ) then
106304: LD_VAR 0 1
106308: PPUSH
106309: CALL_OW 318
106313: IFFALSE 106324
// ComWalk ( i ) ;
106315: LD_VAR 0 1
106319: PPUSH
106320: CALL_OW 138
// SetClass ( i , 2 ) ;
106324: LD_VAR 0 1
106328: PPUSH
106329: LD_INT 2
106331: PPUSH
106332: CALL_OW 336
// end ;
106336: GO 106301
106338: POP
106339: POP
// end ;
106340: PPOPN 2
106342: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
106343: LD_EXP 77
106347: PUSH
106348: LD_EXP 130
106352: AND
106353: IFFALSE 106641
106355: GO 106357
106357: DISABLE
106358: LD_INT 0
106360: PPUSH
106361: PPUSH
106362: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
106363: LD_OWVAR 2
106367: PPUSH
106368: LD_INT 9
106370: PPUSH
106371: LD_INT 1
106373: PPUSH
106374: LD_INT 1
106376: PPUSH
106377: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
106381: LD_INT 9
106383: PPUSH
106384: LD_OWVAR 2
106388: PPUSH
106389: CALL_OW 343
// uc_side := 9 ;
106393: LD_ADDR_OWVAR 20
106397: PUSH
106398: LD_INT 9
106400: ST_TO_ADDR
// uc_nation := 2 ;
106401: LD_ADDR_OWVAR 21
106405: PUSH
106406: LD_INT 2
106408: ST_TO_ADDR
// hc_name := Dark Warrior ;
106409: LD_ADDR_OWVAR 26
106413: PUSH
106414: LD_STRING Dark Warrior
106416: ST_TO_ADDR
// hc_gallery :=  ;
106417: LD_ADDR_OWVAR 33
106421: PUSH
106422: LD_STRING 
106424: ST_TO_ADDR
// hc_noskilllimit := true ;
106425: LD_ADDR_OWVAR 76
106429: PUSH
106430: LD_INT 1
106432: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
106433: LD_ADDR_OWVAR 31
106437: PUSH
106438: LD_INT 30
106440: PUSH
106441: LD_INT 30
106443: PUSH
106444: LD_INT 30
106446: PUSH
106447: LD_INT 30
106449: PUSH
106450: EMPTY
106451: LIST
106452: LIST
106453: LIST
106454: LIST
106455: ST_TO_ADDR
// un := CreateHuman ;
106456: LD_ADDR_VAR 0 3
106460: PUSH
106461: CALL_OW 44
106465: ST_TO_ADDR
// hc_noskilllimit := false ;
106466: LD_ADDR_OWVAR 76
106470: PUSH
106471: LD_INT 0
106473: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
106474: LD_VAR 0 3
106478: PPUSH
106479: LD_INT 1
106481: PPUSH
106482: CALL_OW 51
// ToLua ( playRanger() ) ;
106486: LD_STRING playRanger()
106488: PPUSH
106489: CALL_OW 559
// p := 0 ;
106493: LD_ADDR_VAR 0 2
106497: PUSH
106498: LD_INT 0
106500: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
106501: LD_INT 35
106503: PPUSH
106504: CALL_OW 67
// p := p + 1 ;
106508: LD_ADDR_VAR 0 2
106512: PUSH
106513: LD_VAR 0 2
106517: PUSH
106518: LD_INT 1
106520: PLUS
106521: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
106522: LD_VAR 0 3
106526: PPUSH
106527: CALL_OW 256
106531: PUSH
106532: LD_INT 1000
106534: LESS
106535: IFFALSE 106549
// SetLives ( un , 1000 ) ;
106537: LD_VAR 0 3
106541: PPUSH
106542: LD_INT 1000
106544: PPUSH
106545: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
106549: LD_VAR 0 3
106553: PPUSH
106554: LD_INT 81
106556: PUSH
106557: LD_OWVAR 2
106561: PUSH
106562: EMPTY
106563: LIST
106564: LIST
106565: PUSH
106566: LD_INT 91
106568: PUSH
106569: LD_VAR 0 3
106573: PUSH
106574: LD_INT 30
106576: PUSH
106577: EMPTY
106578: LIST
106579: LIST
106580: LIST
106581: PUSH
106582: EMPTY
106583: LIST
106584: LIST
106585: PPUSH
106586: CALL_OW 69
106590: PPUSH
106591: LD_VAR 0 3
106595: PPUSH
106596: CALL_OW 74
106600: PPUSH
106601: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
106605: LD_VAR 0 2
106609: PUSH
106610: LD_INT 80
106612: GREATER
106613: PUSH
106614: LD_VAR 0 3
106618: PPUSH
106619: CALL_OW 301
106623: OR
106624: IFFALSE 106501
// if un then
106626: LD_VAR 0 3
106630: IFFALSE 106641
// RemoveUnit ( un ) ;
106632: LD_VAR 0 3
106636: PPUSH
106637: CALL_OW 64
// end ;
106641: PPOPN 3
106643: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
106644: LD_EXP 131
106648: IFFALSE 106764
106650: GO 106652
106652: DISABLE
106653: LD_INT 0
106655: PPUSH
106656: PPUSH
106657: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
106658: LD_ADDR_VAR 0 2
106662: PUSH
106663: LD_INT 81
106665: PUSH
106666: LD_OWVAR 2
106670: PUSH
106671: EMPTY
106672: LIST
106673: LIST
106674: PUSH
106675: LD_INT 21
106677: PUSH
106678: LD_INT 1
106680: PUSH
106681: EMPTY
106682: LIST
106683: LIST
106684: PUSH
106685: EMPTY
106686: LIST
106687: LIST
106688: PPUSH
106689: CALL_OW 69
106693: ST_TO_ADDR
// ToLua ( playComputer() ) ;
106694: LD_STRING playComputer()
106696: PPUSH
106697: CALL_OW 559
// if not tmp then
106701: LD_VAR 0 2
106705: NOT
106706: IFFALSE 106710
// exit ;
106708: GO 106764
// for i in tmp do
106710: LD_ADDR_VAR 0 1
106714: PUSH
106715: LD_VAR 0 2
106719: PUSH
106720: FOR_IN
106721: IFFALSE 106762
// for j := 1 to 4 do
106723: LD_ADDR_VAR 0 3
106727: PUSH
106728: DOUBLE
106729: LD_INT 1
106731: DEC
106732: ST_TO_ADDR
106733: LD_INT 4
106735: PUSH
106736: FOR_TO
106737: IFFALSE 106758
// SetSkill ( i , j , 10 ) ;
106739: LD_VAR 0 1
106743: PPUSH
106744: LD_VAR 0 3
106748: PPUSH
106749: LD_INT 10
106751: PPUSH
106752: CALL_OW 237
106756: GO 106736
106758: POP
106759: POP
106760: GO 106720
106762: POP
106763: POP
// end ;
106764: PPOPN 3
106766: END
// every 0 0$1 trigger s30 do var i , tmp ;
106767: LD_EXP 132
106771: IFFALSE 106840
106773: GO 106775
106775: DISABLE
106776: LD_INT 0
106778: PPUSH
106779: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
106780: LD_ADDR_VAR 0 2
106784: PUSH
106785: LD_INT 22
106787: PUSH
106788: LD_OWVAR 2
106792: PUSH
106793: EMPTY
106794: LIST
106795: LIST
106796: PPUSH
106797: CALL_OW 69
106801: ST_TO_ADDR
// if not tmp then
106802: LD_VAR 0 2
106806: NOT
106807: IFFALSE 106811
// exit ;
106809: GO 106840
// for i in tmp do
106811: LD_ADDR_VAR 0 1
106815: PUSH
106816: LD_VAR 0 2
106820: PUSH
106821: FOR_IN
106822: IFFALSE 106838
// SetLives ( i , 300 ) ;
106824: LD_VAR 0 1
106828: PPUSH
106829: LD_INT 300
106831: PPUSH
106832: CALL_OW 234
106836: GO 106821
106838: POP
106839: POP
// end ;
106840: PPOPN 2
106842: END
// every 0 0$1 trigger s60 do var i , tmp ;
106843: LD_EXP 133
106847: IFFALSE 106916
106849: GO 106851
106851: DISABLE
106852: LD_INT 0
106854: PPUSH
106855: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
106856: LD_ADDR_VAR 0 2
106860: PUSH
106861: LD_INT 22
106863: PUSH
106864: LD_OWVAR 2
106868: PUSH
106869: EMPTY
106870: LIST
106871: LIST
106872: PPUSH
106873: CALL_OW 69
106877: ST_TO_ADDR
// if not tmp then
106878: LD_VAR 0 2
106882: NOT
106883: IFFALSE 106887
// exit ;
106885: GO 106916
// for i in tmp do
106887: LD_ADDR_VAR 0 1
106891: PUSH
106892: LD_VAR 0 2
106896: PUSH
106897: FOR_IN
106898: IFFALSE 106914
// SetLives ( i , 600 ) ;
106900: LD_VAR 0 1
106904: PPUSH
106905: LD_INT 600
106907: PPUSH
106908: CALL_OW 234
106912: GO 106897
106914: POP
106915: POP
// end ;
106916: PPOPN 2
106918: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
106919: LD_INT 0
106921: PPUSH
// case cmd of 301 :
106922: LD_VAR 0 1
106926: PUSH
106927: LD_INT 301
106929: DOUBLE
106930: EQUAL
106931: IFTRUE 106935
106933: GO 106967
106935: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
106936: LD_VAR 0 6
106940: PPUSH
106941: LD_VAR 0 7
106945: PPUSH
106946: LD_VAR 0 8
106950: PPUSH
106951: LD_VAR 0 4
106955: PPUSH
106956: LD_VAR 0 5
106960: PPUSH
106961: CALL 108168 0 5
106965: GO 107088
106967: LD_INT 302
106969: DOUBLE
106970: EQUAL
106971: IFTRUE 106975
106973: GO 107012
106975: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
106976: LD_VAR 0 6
106980: PPUSH
106981: LD_VAR 0 7
106985: PPUSH
106986: LD_VAR 0 8
106990: PPUSH
106991: LD_VAR 0 9
106995: PPUSH
106996: LD_VAR 0 4
107000: PPUSH
107001: LD_VAR 0 5
107005: PPUSH
107006: CALL 108259 0 6
107010: GO 107088
107012: LD_INT 303
107014: DOUBLE
107015: EQUAL
107016: IFTRUE 107020
107018: GO 107057
107020: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
107021: LD_VAR 0 6
107025: PPUSH
107026: LD_VAR 0 7
107030: PPUSH
107031: LD_VAR 0 8
107035: PPUSH
107036: LD_VAR 0 9
107040: PPUSH
107041: LD_VAR 0 4
107045: PPUSH
107046: LD_VAR 0 5
107050: PPUSH
107051: CALL 107093 0 6
107055: GO 107088
107057: LD_INT 304
107059: DOUBLE
107060: EQUAL
107061: IFTRUE 107065
107063: GO 107087
107065: POP
// hHackTeleport ( unit , x , y ) ; end ;
107066: LD_VAR 0 2
107070: PPUSH
107071: LD_VAR 0 4
107075: PPUSH
107076: LD_VAR 0 5
107080: PPUSH
107081: CALL 108852 0 3
107085: GO 107088
107087: POP
// end ;
107088: LD_VAR 0 12
107092: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
107093: LD_INT 0
107095: PPUSH
107096: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
107097: LD_VAR 0 1
107101: PUSH
107102: LD_INT 1
107104: LESS
107105: PUSH
107106: LD_VAR 0 1
107110: PUSH
107111: LD_INT 3
107113: GREATER
107114: OR
107115: PUSH
107116: LD_VAR 0 5
107120: PPUSH
107121: LD_VAR 0 6
107125: PPUSH
107126: CALL_OW 428
107130: OR
107131: IFFALSE 107135
// exit ;
107133: GO 107855
// uc_side := your_side ;
107135: LD_ADDR_OWVAR 20
107139: PUSH
107140: LD_OWVAR 2
107144: ST_TO_ADDR
// uc_nation := nation ;
107145: LD_ADDR_OWVAR 21
107149: PUSH
107150: LD_VAR 0 1
107154: ST_TO_ADDR
// bc_level = 1 ;
107155: LD_ADDR_OWVAR 43
107159: PUSH
107160: LD_INT 1
107162: ST_TO_ADDR
// case btype of 1 :
107163: LD_VAR 0 2
107167: PUSH
107168: LD_INT 1
107170: DOUBLE
107171: EQUAL
107172: IFTRUE 107176
107174: GO 107187
107176: POP
// bc_type := b_depot ; 2 :
107177: LD_ADDR_OWVAR 42
107181: PUSH
107182: LD_INT 0
107184: ST_TO_ADDR
107185: GO 107799
107187: LD_INT 2
107189: DOUBLE
107190: EQUAL
107191: IFTRUE 107195
107193: GO 107206
107195: POP
// bc_type := b_warehouse ; 3 :
107196: LD_ADDR_OWVAR 42
107200: PUSH
107201: LD_INT 1
107203: ST_TO_ADDR
107204: GO 107799
107206: LD_INT 3
107208: DOUBLE
107209: EQUAL
107210: IFTRUE 107214
107212: GO 107225
107214: POP
// bc_type := b_lab ; 4 .. 9 :
107215: LD_ADDR_OWVAR 42
107219: PUSH
107220: LD_INT 6
107222: ST_TO_ADDR
107223: GO 107799
107225: LD_INT 4
107227: DOUBLE
107228: GREATEREQUAL
107229: IFFALSE 107237
107231: LD_INT 9
107233: DOUBLE
107234: LESSEQUAL
107235: IFTRUE 107239
107237: GO 107291
107239: POP
// begin bc_type := b_lab_half ;
107240: LD_ADDR_OWVAR 42
107244: PUSH
107245: LD_INT 7
107247: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
107248: LD_ADDR_OWVAR 44
107252: PUSH
107253: LD_INT 10
107255: PUSH
107256: LD_INT 11
107258: PUSH
107259: LD_INT 12
107261: PUSH
107262: LD_INT 15
107264: PUSH
107265: LD_INT 14
107267: PUSH
107268: LD_INT 13
107270: PUSH
107271: EMPTY
107272: LIST
107273: LIST
107274: LIST
107275: LIST
107276: LIST
107277: LIST
107278: PUSH
107279: LD_VAR 0 2
107283: PUSH
107284: LD_INT 3
107286: MINUS
107287: ARRAY
107288: ST_TO_ADDR
// end ; 10 .. 13 :
107289: GO 107799
107291: LD_INT 10
107293: DOUBLE
107294: GREATEREQUAL
107295: IFFALSE 107303
107297: LD_INT 13
107299: DOUBLE
107300: LESSEQUAL
107301: IFTRUE 107305
107303: GO 107382
107305: POP
// begin bc_type := b_lab_full ;
107306: LD_ADDR_OWVAR 42
107310: PUSH
107311: LD_INT 8
107313: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
107314: LD_ADDR_OWVAR 44
107318: PUSH
107319: LD_INT 10
107321: PUSH
107322: LD_INT 12
107324: PUSH
107325: LD_INT 14
107327: PUSH
107328: LD_INT 13
107330: PUSH
107331: EMPTY
107332: LIST
107333: LIST
107334: LIST
107335: LIST
107336: PUSH
107337: LD_VAR 0 2
107341: PUSH
107342: LD_INT 9
107344: MINUS
107345: ARRAY
107346: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
107347: LD_ADDR_OWVAR 45
107351: PUSH
107352: LD_INT 11
107354: PUSH
107355: LD_INT 15
107357: PUSH
107358: LD_INT 12
107360: PUSH
107361: LD_INT 15
107363: PUSH
107364: EMPTY
107365: LIST
107366: LIST
107367: LIST
107368: LIST
107369: PUSH
107370: LD_VAR 0 2
107374: PUSH
107375: LD_INT 9
107377: MINUS
107378: ARRAY
107379: ST_TO_ADDR
// end ; 14 :
107380: GO 107799
107382: LD_INT 14
107384: DOUBLE
107385: EQUAL
107386: IFTRUE 107390
107388: GO 107401
107390: POP
// bc_type := b_workshop ; 15 :
107391: LD_ADDR_OWVAR 42
107395: PUSH
107396: LD_INT 2
107398: ST_TO_ADDR
107399: GO 107799
107401: LD_INT 15
107403: DOUBLE
107404: EQUAL
107405: IFTRUE 107409
107407: GO 107420
107409: POP
// bc_type := b_factory ; 16 :
107410: LD_ADDR_OWVAR 42
107414: PUSH
107415: LD_INT 3
107417: ST_TO_ADDR
107418: GO 107799
107420: LD_INT 16
107422: DOUBLE
107423: EQUAL
107424: IFTRUE 107428
107426: GO 107439
107428: POP
// bc_type := b_ext_gun ; 17 :
107429: LD_ADDR_OWVAR 42
107433: PUSH
107434: LD_INT 17
107436: ST_TO_ADDR
107437: GO 107799
107439: LD_INT 17
107441: DOUBLE
107442: EQUAL
107443: IFTRUE 107447
107445: GO 107475
107447: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
107448: LD_ADDR_OWVAR 42
107452: PUSH
107453: LD_INT 19
107455: PUSH
107456: LD_INT 23
107458: PUSH
107459: LD_INT 19
107461: PUSH
107462: EMPTY
107463: LIST
107464: LIST
107465: LIST
107466: PUSH
107467: LD_VAR 0 1
107471: ARRAY
107472: ST_TO_ADDR
107473: GO 107799
107475: LD_INT 18
107477: DOUBLE
107478: EQUAL
107479: IFTRUE 107483
107481: GO 107494
107483: POP
// bc_type := b_ext_radar ; 19 :
107484: LD_ADDR_OWVAR 42
107488: PUSH
107489: LD_INT 20
107491: ST_TO_ADDR
107492: GO 107799
107494: LD_INT 19
107496: DOUBLE
107497: EQUAL
107498: IFTRUE 107502
107500: GO 107513
107502: POP
// bc_type := b_ext_radio ; 20 :
107503: LD_ADDR_OWVAR 42
107507: PUSH
107508: LD_INT 22
107510: ST_TO_ADDR
107511: GO 107799
107513: LD_INT 20
107515: DOUBLE
107516: EQUAL
107517: IFTRUE 107521
107519: GO 107532
107521: POP
// bc_type := b_ext_siberium ; 21 :
107522: LD_ADDR_OWVAR 42
107526: PUSH
107527: LD_INT 21
107529: ST_TO_ADDR
107530: GO 107799
107532: LD_INT 21
107534: DOUBLE
107535: EQUAL
107536: IFTRUE 107540
107538: GO 107551
107540: POP
// bc_type := b_ext_computer ; 22 :
107541: LD_ADDR_OWVAR 42
107545: PUSH
107546: LD_INT 24
107548: ST_TO_ADDR
107549: GO 107799
107551: LD_INT 22
107553: DOUBLE
107554: EQUAL
107555: IFTRUE 107559
107557: GO 107570
107559: POP
// bc_type := b_ext_track ; 23 :
107560: LD_ADDR_OWVAR 42
107564: PUSH
107565: LD_INT 16
107567: ST_TO_ADDR
107568: GO 107799
107570: LD_INT 23
107572: DOUBLE
107573: EQUAL
107574: IFTRUE 107578
107576: GO 107589
107578: POP
// bc_type := b_ext_laser ; 24 :
107579: LD_ADDR_OWVAR 42
107583: PUSH
107584: LD_INT 25
107586: ST_TO_ADDR
107587: GO 107799
107589: LD_INT 24
107591: DOUBLE
107592: EQUAL
107593: IFTRUE 107597
107595: GO 107608
107597: POP
// bc_type := b_control_tower ; 25 :
107598: LD_ADDR_OWVAR 42
107602: PUSH
107603: LD_INT 36
107605: ST_TO_ADDR
107606: GO 107799
107608: LD_INT 25
107610: DOUBLE
107611: EQUAL
107612: IFTRUE 107616
107614: GO 107627
107616: POP
// bc_type := b_breastwork ; 26 :
107617: LD_ADDR_OWVAR 42
107621: PUSH
107622: LD_INT 31
107624: ST_TO_ADDR
107625: GO 107799
107627: LD_INT 26
107629: DOUBLE
107630: EQUAL
107631: IFTRUE 107635
107633: GO 107646
107635: POP
// bc_type := b_bunker ; 27 :
107636: LD_ADDR_OWVAR 42
107640: PUSH
107641: LD_INT 32
107643: ST_TO_ADDR
107644: GO 107799
107646: LD_INT 27
107648: DOUBLE
107649: EQUAL
107650: IFTRUE 107654
107652: GO 107665
107654: POP
// bc_type := b_turret ; 28 :
107655: LD_ADDR_OWVAR 42
107659: PUSH
107660: LD_INT 33
107662: ST_TO_ADDR
107663: GO 107799
107665: LD_INT 28
107667: DOUBLE
107668: EQUAL
107669: IFTRUE 107673
107671: GO 107684
107673: POP
// bc_type := b_armoury ; 29 :
107674: LD_ADDR_OWVAR 42
107678: PUSH
107679: LD_INT 4
107681: ST_TO_ADDR
107682: GO 107799
107684: LD_INT 29
107686: DOUBLE
107687: EQUAL
107688: IFTRUE 107692
107690: GO 107703
107692: POP
// bc_type := b_barracks ; 30 :
107693: LD_ADDR_OWVAR 42
107697: PUSH
107698: LD_INT 5
107700: ST_TO_ADDR
107701: GO 107799
107703: LD_INT 30
107705: DOUBLE
107706: EQUAL
107707: IFTRUE 107711
107709: GO 107722
107711: POP
// bc_type := b_solar_power ; 31 :
107712: LD_ADDR_OWVAR 42
107716: PUSH
107717: LD_INT 27
107719: ST_TO_ADDR
107720: GO 107799
107722: LD_INT 31
107724: DOUBLE
107725: EQUAL
107726: IFTRUE 107730
107728: GO 107741
107730: POP
// bc_type := b_oil_power ; 32 :
107731: LD_ADDR_OWVAR 42
107735: PUSH
107736: LD_INT 26
107738: ST_TO_ADDR
107739: GO 107799
107741: LD_INT 32
107743: DOUBLE
107744: EQUAL
107745: IFTRUE 107749
107747: GO 107760
107749: POP
// bc_type := b_siberite_power ; 33 :
107750: LD_ADDR_OWVAR 42
107754: PUSH
107755: LD_INT 28
107757: ST_TO_ADDR
107758: GO 107799
107760: LD_INT 33
107762: DOUBLE
107763: EQUAL
107764: IFTRUE 107768
107766: GO 107779
107768: POP
// bc_type := b_oil_mine ; 34 :
107769: LD_ADDR_OWVAR 42
107773: PUSH
107774: LD_INT 29
107776: ST_TO_ADDR
107777: GO 107799
107779: LD_INT 34
107781: DOUBLE
107782: EQUAL
107783: IFTRUE 107787
107785: GO 107798
107787: POP
// bc_type := b_siberite_mine ; end ;
107788: LD_ADDR_OWVAR 42
107792: PUSH
107793: LD_INT 30
107795: ST_TO_ADDR
107796: GO 107799
107798: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
107799: LD_ADDR_VAR 0 8
107803: PUSH
107804: LD_VAR 0 5
107808: PPUSH
107809: LD_VAR 0 6
107813: PPUSH
107814: LD_VAR 0 3
107818: PPUSH
107819: CALL_OW 47
107823: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
107824: LD_OWVAR 42
107828: PUSH
107829: LD_INT 32
107831: PUSH
107832: LD_INT 33
107834: PUSH
107835: EMPTY
107836: LIST
107837: LIST
107838: IN
107839: IFFALSE 107855
// PlaceWeaponTurret ( b , weapon ) ;
107841: LD_VAR 0 8
107845: PPUSH
107846: LD_VAR 0 4
107850: PPUSH
107851: CALL_OW 431
// end ;
107855: LD_VAR 0 7
107859: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
107860: LD_INT 0
107862: PPUSH
107863: PPUSH
107864: PPUSH
107865: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
107866: LD_ADDR_VAR 0 4
107870: PUSH
107871: LD_INT 22
107873: PUSH
107874: LD_OWVAR 2
107878: PUSH
107879: EMPTY
107880: LIST
107881: LIST
107882: PUSH
107883: LD_INT 2
107885: PUSH
107886: LD_INT 30
107888: PUSH
107889: LD_INT 0
107891: PUSH
107892: EMPTY
107893: LIST
107894: LIST
107895: PUSH
107896: LD_INT 30
107898: PUSH
107899: LD_INT 1
107901: PUSH
107902: EMPTY
107903: LIST
107904: LIST
107905: PUSH
107906: EMPTY
107907: LIST
107908: LIST
107909: LIST
107910: PUSH
107911: EMPTY
107912: LIST
107913: LIST
107914: PPUSH
107915: CALL_OW 69
107919: ST_TO_ADDR
// if not tmp then
107920: LD_VAR 0 4
107924: NOT
107925: IFFALSE 107929
// exit ;
107927: GO 107988
// for i in tmp do
107929: LD_ADDR_VAR 0 2
107933: PUSH
107934: LD_VAR 0 4
107938: PUSH
107939: FOR_IN
107940: IFFALSE 107986
// for j = 1 to 3 do
107942: LD_ADDR_VAR 0 3
107946: PUSH
107947: DOUBLE
107948: LD_INT 1
107950: DEC
107951: ST_TO_ADDR
107952: LD_INT 3
107954: PUSH
107955: FOR_TO
107956: IFFALSE 107982
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
107958: LD_VAR 0 2
107962: PPUSH
107963: CALL_OW 274
107967: PPUSH
107968: LD_VAR 0 3
107972: PPUSH
107973: LD_INT 99999
107975: PPUSH
107976: CALL_OW 277
107980: GO 107955
107982: POP
107983: POP
107984: GO 107939
107986: POP
107987: POP
// end ;
107988: LD_VAR 0 1
107992: RET
// export function hHackSetLevel10 ; var i , j ; begin
107993: LD_INT 0
107995: PPUSH
107996: PPUSH
107997: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
107998: LD_ADDR_VAR 0 2
108002: PUSH
108003: LD_INT 21
108005: PUSH
108006: LD_INT 1
108008: PUSH
108009: EMPTY
108010: LIST
108011: LIST
108012: PPUSH
108013: CALL_OW 69
108017: PUSH
108018: FOR_IN
108019: IFFALSE 108071
// if IsSelected ( i ) then
108021: LD_VAR 0 2
108025: PPUSH
108026: CALL_OW 306
108030: IFFALSE 108069
// begin for j := 1 to 4 do
108032: LD_ADDR_VAR 0 3
108036: PUSH
108037: DOUBLE
108038: LD_INT 1
108040: DEC
108041: ST_TO_ADDR
108042: LD_INT 4
108044: PUSH
108045: FOR_TO
108046: IFFALSE 108067
// SetSkill ( i , j , 10 ) ;
108048: LD_VAR 0 2
108052: PPUSH
108053: LD_VAR 0 3
108057: PPUSH
108058: LD_INT 10
108060: PPUSH
108061: CALL_OW 237
108065: GO 108045
108067: POP
108068: POP
// end ;
108069: GO 108018
108071: POP
108072: POP
// end ;
108073: LD_VAR 0 1
108077: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
108078: LD_INT 0
108080: PPUSH
108081: PPUSH
108082: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
108083: LD_ADDR_VAR 0 2
108087: PUSH
108088: LD_INT 22
108090: PUSH
108091: LD_OWVAR 2
108095: PUSH
108096: EMPTY
108097: LIST
108098: LIST
108099: PUSH
108100: LD_INT 21
108102: PUSH
108103: LD_INT 1
108105: PUSH
108106: EMPTY
108107: LIST
108108: LIST
108109: PUSH
108110: EMPTY
108111: LIST
108112: LIST
108113: PPUSH
108114: CALL_OW 69
108118: PUSH
108119: FOR_IN
108120: IFFALSE 108161
// begin for j := 1 to 4 do
108122: LD_ADDR_VAR 0 3
108126: PUSH
108127: DOUBLE
108128: LD_INT 1
108130: DEC
108131: ST_TO_ADDR
108132: LD_INT 4
108134: PUSH
108135: FOR_TO
108136: IFFALSE 108157
// SetSkill ( i , j , 10 ) ;
108138: LD_VAR 0 2
108142: PPUSH
108143: LD_VAR 0 3
108147: PPUSH
108148: LD_INT 10
108150: PPUSH
108151: CALL_OW 237
108155: GO 108135
108157: POP
108158: POP
// end ;
108159: GO 108119
108161: POP
108162: POP
// end ;
108163: LD_VAR 0 1
108167: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
108168: LD_INT 0
108170: PPUSH
// uc_side := your_side ;
108171: LD_ADDR_OWVAR 20
108175: PUSH
108176: LD_OWVAR 2
108180: ST_TO_ADDR
// uc_nation := nation ;
108181: LD_ADDR_OWVAR 21
108185: PUSH
108186: LD_VAR 0 1
108190: ST_TO_ADDR
// InitHc ;
108191: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
108195: LD_INT 0
108197: PPUSH
108198: LD_VAR 0 2
108202: PPUSH
108203: LD_VAR 0 3
108207: PPUSH
108208: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
108212: LD_VAR 0 4
108216: PPUSH
108217: LD_VAR 0 5
108221: PPUSH
108222: CALL_OW 428
108226: PUSH
108227: LD_INT 0
108229: EQUAL
108230: IFFALSE 108254
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
108232: CALL_OW 44
108236: PPUSH
108237: LD_VAR 0 4
108241: PPUSH
108242: LD_VAR 0 5
108246: PPUSH
108247: LD_INT 1
108249: PPUSH
108250: CALL_OW 48
// end ;
108254: LD_VAR 0 6
108258: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
108259: LD_INT 0
108261: PPUSH
108262: PPUSH
// uc_side := your_side ;
108263: LD_ADDR_OWVAR 20
108267: PUSH
108268: LD_OWVAR 2
108272: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
108273: LD_VAR 0 1
108277: PUSH
108278: LD_INT 1
108280: PUSH
108281: LD_INT 2
108283: PUSH
108284: LD_INT 3
108286: PUSH
108287: LD_INT 4
108289: PUSH
108290: LD_INT 5
108292: PUSH
108293: EMPTY
108294: LIST
108295: LIST
108296: LIST
108297: LIST
108298: LIST
108299: IN
108300: IFFALSE 108312
// uc_nation := nation_american else
108302: LD_ADDR_OWVAR 21
108306: PUSH
108307: LD_INT 1
108309: ST_TO_ADDR
108310: GO 108355
// if chassis in [ 11 , 12 , 13 , 14 ] then
108312: LD_VAR 0 1
108316: PUSH
108317: LD_INT 11
108319: PUSH
108320: LD_INT 12
108322: PUSH
108323: LD_INT 13
108325: PUSH
108326: LD_INT 14
108328: PUSH
108329: EMPTY
108330: LIST
108331: LIST
108332: LIST
108333: LIST
108334: IN
108335: IFFALSE 108347
// uc_nation := nation_arabian else
108337: LD_ADDR_OWVAR 21
108341: PUSH
108342: LD_INT 2
108344: ST_TO_ADDR
108345: GO 108355
// uc_nation := nation_russian ;
108347: LD_ADDR_OWVAR 21
108351: PUSH
108352: LD_INT 3
108354: ST_TO_ADDR
// vc_chassis := chassis ;
108355: LD_ADDR_OWVAR 37
108359: PUSH
108360: LD_VAR 0 1
108364: ST_TO_ADDR
// vc_engine := engine ;
108365: LD_ADDR_OWVAR 39
108369: PUSH
108370: LD_VAR 0 2
108374: ST_TO_ADDR
// vc_control := control ;
108375: LD_ADDR_OWVAR 38
108379: PUSH
108380: LD_VAR 0 3
108384: ST_TO_ADDR
// vc_weapon := weapon ;
108385: LD_ADDR_OWVAR 40
108389: PUSH
108390: LD_VAR 0 4
108394: ST_TO_ADDR
// un := CreateVehicle ;
108395: LD_ADDR_VAR 0 8
108399: PUSH
108400: CALL_OW 45
108404: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
108405: LD_VAR 0 8
108409: PPUSH
108410: LD_INT 0
108412: PPUSH
108413: LD_INT 5
108415: PPUSH
108416: CALL_OW 12
108420: PPUSH
108421: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
108425: LD_VAR 0 8
108429: PPUSH
108430: LD_VAR 0 5
108434: PPUSH
108435: LD_VAR 0 6
108439: PPUSH
108440: LD_INT 1
108442: PPUSH
108443: CALL_OW 48
// end ;
108447: LD_VAR 0 7
108451: RET
// export hInvincible ; every 1 do
108452: GO 108454
108454: DISABLE
// hInvincible := [ ] ;
108455: LD_ADDR_EXP 134
108459: PUSH
108460: EMPTY
108461: ST_TO_ADDR
108462: END
// every 10 do var i ;
108463: GO 108465
108465: DISABLE
108466: LD_INT 0
108468: PPUSH
// begin enable ;
108469: ENABLE
// if not hInvincible then
108470: LD_EXP 134
108474: NOT
108475: IFFALSE 108479
// exit ;
108477: GO 108523
// for i in hInvincible do
108479: LD_ADDR_VAR 0 1
108483: PUSH
108484: LD_EXP 134
108488: PUSH
108489: FOR_IN
108490: IFFALSE 108521
// if GetLives ( i ) < 1000 then
108492: LD_VAR 0 1
108496: PPUSH
108497: CALL_OW 256
108501: PUSH
108502: LD_INT 1000
108504: LESS
108505: IFFALSE 108519
// SetLives ( i , 1000 ) ;
108507: LD_VAR 0 1
108511: PPUSH
108512: LD_INT 1000
108514: PPUSH
108515: CALL_OW 234
108519: GO 108489
108521: POP
108522: POP
// end ;
108523: PPOPN 1
108525: END
// export function hHackInvincible ; var i ; begin
108526: LD_INT 0
108528: PPUSH
108529: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
108530: LD_ADDR_VAR 0 2
108534: PUSH
108535: LD_INT 2
108537: PUSH
108538: LD_INT 21
108540: PUSH
108541: LD_INT 1
108543: PUSH
108544: EMPTY
108545: LIST
108546: LIST
108547: PUSH
108548: LD_INT 21
108550: PUSH
108551: LD_INT 2
108553: PUSH
108554: EMPTY
108555: LIST
108556: LIST
108557: PUSH
108558: EMPTY
108559: LIST
108560: LIST
108561: LIST
108562: PPUSH
108563: CALL_OW 69
108567: PUSH
108568: FOR_IN
108569: IFFALSE 108630
// if IsSelected ( i ) then
108571: LD_VAR 0 2
108575: PPUSH
108576: CALL_OW 306
108580: IFFALSE 108628
// begin if i in hInvincible then
108582: LD_VAR 0 2
108586: PUSH
108587: LD_EXP 134
108591: IN
108592: IFFALSE 108612
// hInvincible := hInvincible diff i else
108594: LD_ADDR_EXP 134
108598: PUSH
108599: LD_EXP 134
108603: PUSH
108604: LD_VAR 0 2
108608: DIFF
108609: ST_TO_ADDR
108610: GO 108628
// hInvincible := hInvincible union i ;
108612: LD_ADDR_EXP 134
108616: PUSH
108617: LD_EXP 134
108621: PUSH
108622: LD_VAR 0 2
108626: UNION
108627: ST_TO_ADDR
// end ;
108628: GO 108568
108630: POP
108631: POP
// end ;
108632: LD_VAR 0 1
108636: RET
// export function hHackInvisible ; var i , j ; begin
108637: LD_INT 0
108639: PPUSH
108640: PPUSH
108641: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
108642: LD_ADDR_VAR 0 2
108646: PUSH
108647: LD_INT 21
108649: PUSH
108650: LD_INT 1
108652: PUSH
108653: EMPTY
108654: LIST
108655: LIST
108656: PPUSH
108657: CALL_OW 69
108661: PUSH
108662: FOR_IN
108663: IFFALSE 108687
// if IsSelected ( i ) then
108665: LD_VAR 0 2
108669: PPUSH
108670: CALL_OW 306
108674: IFFALSE 108685
// ComForceInvisible ( i ) ;
108676: LD_VAR 0 2
108680: PPUSH
108681: CALL_OW 496
108685: GO 108662
108687: POP
108688: POP
// end ;
108689: LD_VAR 0 1
108693: RET
// export function hHackChangeYourSide ; begin
108694: LD_INT 0
108696: PPUSH
// if your_side = 8 then
108697: LD_OWVAR 2
108701: PUSH
108702: LD_INT 8
108704: EQUAL
108705: IFFALSE 108717
// your_side := 0 else
108707: LD_ADDR_OWVAR 2
108711: PUSH
108712: LD_INT 0
108714: ST_TO_ADDR
108715: GO 108731
// your_side := your_side + 1 ;
108717: LD_ADDR_OWVAR 2
108721: PUSH
108722: LD_OWVAR 2
108726: PUSH
108727: LD_INT 1
108729: PLUS
108730: ST_TO_ADDR
// end ;
108731: LD_VAR 0 1
108735: RET
// export function hHackChangeUnitSide ; var i , j ; begin
108736: LD_INT 0
108738: PPUSH
108739: PPUSH
108740: PPUSH
// for i in all_units do
108741: LD_ADDR_VAR 0 2
108745: PUSH
108746: LD_OWVAR 3
108750: PUSH
108751: FOR_IN
108752: IFFALSE 108830
// if IsSelected ( i ) then
108754: LD_VAR 0 2
108758: PPUSH
108759: CALL_OW 306
108763: IFFALSE 108828
// begin j := GetSide ( i ) ;
108765: LD_ADDR_VAR 0 3
108769: PUSH
108770: LD_VAR 0 2
108774: PPUSH
108775: CALL_OW 255
108779: ST_TO_ADDR
// if j = 8 then
108780: LD_VAR 0 3
108784: PUSH
108785: LD_INT 8
108787: EQUAL
108788: IFFALSE 108800
// j := 0 else
108790: LD_ADDR_VAR 0 3
108794: PUSH
108795: LD_INT 0
108797: ST_TO_ADDR
108798: GO 108814
// j := j + 1 ;
108800: LD_ADDR_VAR 0 3
108804: PUSH
108805: LD_VAR 0 3
108809: PUSH
108810: LD_INT 1
108812: PLUS
108813: ST_TO_ADDR
// SetSide ( i , j ) ;
108814: LD_VAR 0 2
108818: PPUSH
108819: LD_VAR 0 3
108823: PPUSH
108824: CALL_OW 235
// end ;
108828: GO 108751
108830: POP
108831: POP
// end ;
108832: LD_VAR 0 1
108836: RET
// export function hHackFog ; begin
108837: LD_INT 0
108839: PPUSH
// FogOff ( true ) ;
108840: LD_INT 1
108842: PPUSH
108843: CALL_OW 344
// end ;
108847: LD_VAR 0 1
108851: RET
// export function hHackTeleport ( unit , x , y ) ; begin
108852: LD_INT 0
108854: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
108855: LD_VAR 0 1
108859: PPUSH
108860: LD_VAR 0 2
108864: PPUSH
108865: LD_VAR 0 3
108869: PPUSH
108870: LD_INT 1
108872: PPUSH
108873: LD_INT 1
108875: PPUSH
108876: CALL_OW 483
// CenterOnXY ( x , y ) ;
108880: LD_VAR 0 2
108884: PPUSH
108885: LD_VAR 0 3
108889: PPUSH
108890: CALL_OW 84
// end ;
108894: LD_VAR 0 4
108898: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
108899: LD_INT 0
108901: PPUSH
108902: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
108903: LD_VAR 0 1
108907: NOT
108908: PUSH
108909: LD_VAR 0 2
108913: PPUSH
108914: LD_VAR 0 3
108918: PPUSH
108919: CALL_OW 488
108923: NOT
108924: OR
108925: PUSH
108926: LD_VAR 0 1
108930: PPUSH
108931: CALL_OW 266
108935: PUSH
108936: LD_INT 3
108938: NONEQUAL
108939: PUSH
108940: LD_VAR 0 1
108944: PPUSH
108945: CALL_OW 247
108949: PUSH
108950: LD_INT 1
108952: EQUAL
108953: NOT
108954: AND
108955: OR
108956: IFFALSE 108960
// exit ;
108958: GO 109109
// if GetType ( factory ) = unit_human then
108960: LD_VAR 0 1
108964: PPUSH
108965: CALL_OW 247
108969: PUSH
108970: LD_INT 1
108972: EQUAL
108973: IFFALSE 108990
// factory := IsInUnit ( factory ) ;
108975: LD_ADDR_VAR 0 1
108979: PUSH
108980: LD_VAR 0 1
108984: PPUSH
108985: CALL_OW 310
108989: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
108990: LD_VAR 0 1
108994: PPUSH
108995: CALL_OW 266
108999: PUSH
109000: LD_INT 3
109002: NONEQUAL
109003: IFFALSE 109007
// exit ;
109005: GO 109109
// if HexInfo ( x , y ) = factory then
109007: LD_VAR 0 2
109011: PPUSH
109012: LD_VAR 0 3
109016: PPUSH
109017: CALL_OW 428
109021: PUSH
109022: LD_VAR 0 1
109026: EQUAL
109027: IFFALSE 109054
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
109029: LD_ADDR_EXP 135
109033: PUSH
109034: LD_EXP 135
109038: PPUSH
109039: LD_VAR 0 1
109043: PPUSH
109044: LD_INT 0
109046: PPUSH
109047: CALL_OW 1
109051: ST_TO_ADDR
109052: GO 109105
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
109054: LD_ADDR_EXP 135
109058: PUSH
109059: LD_EXP 135
109063: PPUSH
109064: LD_VAR 0 1
109068: PPUSH
109069: LD_VAR 0 1
109073: PPUSH
109074: CALL_OW 255
109078: PUSH
109079: LD_VAR 0 1
109083: PUSH
109084: LD_VAR 0 2
109088: PUSH
109089: LD_VAR 0 3
109093: PUSH
109094: EMPTY
109095: LIST
109096: LIST
109097: LIST
109098: LIST
109099: PPUSH
109100: CALL_OW 1
109104: ST_TO_ADDR
// UpdateFactoryWaypoints ;
109105: CALL 109114 0 0
// end ;
109109: LD_VAR 0 4
109113: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
109114: LD_INT 0
109116: PPUSH
109117: PPUSH
109118: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
109119: LD_STRING resetFactoryWaypoint();
109121: PPUSH
109122: CALL_OW 559
// if factoryWaypoints then
109126: LD_EXP 135
109130: IFFALSE 109256
// begin list := PrepareArray ( factoryWaypoints ) ;
109132: LD_ADDR_VAR 0 3
109136: PUSH
109137: LD_EXP 135
109141: PPUSH
109142: CALL 52153 0 1
109146: ST_TO_ADDR
// for i := 1 to list do
109147: LD_ADDR_VAR 0 2
109151: PUSH
109152: DOUBLE
109153: LD_INT 1
109155: DEC
109156: ST_TO_ADDR
109157: LD_VAR 0 3
109161: PUSH
109162: FOR_TO
109163: IFFALSE 109254
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
109165: LD_STRING setFactoryWaypointXY(
109167: PUSH
109168: LD_VAR 0 3
109172: PUSH
109173: LD_VAR 0 2
109177: ARRAY
109178: PUSH
109179: LD_INT 1
109181: ARRAY
109182: STR
109183: PUSH
109184: LD_STRING ,
109186: STR
109187: PUSH
109188: LD_VAR 0 3
109192: PUSH
109193: LD_VAR 0 2
109197: ARRAY
109198: PUSH
109199: LD_INT 2
109201: ARRAY
109202: STR
109203: PUSH
109204: LD_STRING ,
109206: STR
109207: PUSH
109208: LD_VAR 0 3
109212: PUSH
109213: LD_VAR 0 2
109217: ARRAY
109218: PUSH
109219: LD_INT 3
109221: ARRAY
109222: STR
109223: PUSH
109224: LD_STRING ,
109226: STR
109227: PUSH
109228: LD_VAR 0 3
109232: PUSH
109233: LD_VAR 0 2
109237: ARRAY
109238: PUSH
109239: LD_INT 4
109241: ARRAY
109242: STR
109243: PUSH
109244: LD_STRING )
109246: STR
109247: PPUSH
109248: CALL_OW 559
109252: GO 109162
109254: POP
109255: POP
// end ; end ;
109256: LD_VAR 0 1
109260: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
109261: LD_INT 0
109263: PPUSH
// if HexInfo ( x , y ) = warehouse then
109264: LD_VAR 0 2
109268: PPUSH
109269: LD_VAR 0 3
109273: PPUSH
109274: CALL_OW 428
109278: PUSH
109279: LD_VAR 0 1
109283: EQUAL
109284: IFFALSE 109311
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
109286: LD_ADDR_EXP 136
109290: PUSH
109291: LD_EXP 136
109295: PPUSH
109296: LD_VAR 0 1
109300: PPUSH
109301: LD_INT 0
109303: PPUSH
109304: CALL_OW 1
109308: ST_TO_ADDR
109309: GO 109362
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
109311: LD_ADDR_EXP 136
109315: PUSH
109316: LD_EXP 136
109320: PPUSH
109321: LD_VAR 0 1
109325: PPUSH
109326: LD_VAR 0 1
109330: PPUSH
109331: CALL_OW 255
109335: PUSH
109336: LD_VAR 0 1
109340: PUSH
109341: LD_VAR 0 2
109345: PUSH
109346: LD_VAR 0 3
109350: PUSH
109351: EMPTY
109352: LIST
109353: LIST
109354: LIST
109355: LIST
109356: PPUSH
109357: CALL_OW 1
109361: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
109362: CALL 109371 0 0
// end ;
109366: LD_VAR 0 4
109370: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
109371: LD_INT 0
109373: PPUSH
109374: PPUSH
109375: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
109376: LD_STRING resetWarehouseGatheringPoints();
109378: PPUSH
109379: CALL_OW 559
// if warehouseGatheringPoints then
109383: LD_EXP 136
109387: IFFALSE 109513
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
109389: LD_ADDR_VAR 0 3
109393: PUSH
109394: LD_EXP 136
109398: PPUSH
109399: CALL 52153 0 1
109403: ST_TO_ADDR
// for i := 1 to list do
109404: LD_ADDR_VAR 0 2
109408: PUSH
109409: DOUBLE
109410: LD_INT 1
109412: DEC
109413: ST_TO_ADDR
109414: LD_VAR 0 3
109418: PUSH
109419: FOR_TO
109420: IFFALSE 109511
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
109422: LD_STRING setWarehouseGatheringPointXY(
109424: PUSH
109425: LD_VAR 0 3
109429: PUSH
109430: LD_VAR 0 2
109434: ARRAY
109435: PUSH
109436: LD_INT 1
109438: ARRAY
109439: STR
109440: PUSH
109441: LD_STRING ,
109443: STR
109444: PUSH
109445: LD_VAR 0 3
109449: PUSH
109450: LD_VAR 0 2
109454: ARRAY
109455: PUSH
109456: LD_INT 2
109458: ARRAY
109459: STR
109460: PUSH
109461: LD_STRING ,
109463: STR
109464: PUSH
109465: LD_VAR 0 3
109469: PUSH
109470: LD_VAR 0 2
109474: ARRAY
109475: PUSH
109476: LD_INT 3
109478: ARRAY
109479: STR
109480: PUSH
109481: LD_STRING ,
109483: STR
109484: PUSH
109485: LD_VAR 0 3
109489: PUSH
109490: LD_VAR 0 2
109494: ARRAY
109495: PUSH
109496: LD_INT 4
109498: ARRAY
109499: STR
109500: PUSH
109501: LD_STRING )
109503: STR
109504: PPUSH
109505: CALL_OW 559
109509: GO 109419
109511: POP
109512: POP
// end ; end ;
109513: LD_VAR 0 1
109517: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
109518: LD_EXP 136
109522: IFFALSE 110207
109524: GO 109526
109526: DISABLE
109527: LD_INT 0
109529: PPUSH
109530: PPUSH
109531: PPUSH
109532: PPUSH
109533: PPUSH
109534: PPUSH
109535: PPUSH
109536: PPUSH
109537: PPUSH
// begin enable ;
109538: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
109539: LD_ADDR_VAR 0 3
109543: PUSH
109544: LD_EXP 136
109548: PPUSH
109549: CALL 52153 0 1
109553: ST_TO_ADDR
// if not list then
109554: LD_VAR 0 3
109558: NOT
109559: IFFALSE 109563
// exit ;
109561: GO 110207
// for i := 1 to list do
109563: LD_ADDR_VAR 0 1
109567: PUSH
109568: DOUBLE
109569: LD_INT 1
109571: DEC
109572: ST_TO_ADDR
109573: LD_VAR 0 3
109577: PUSH
109578: FOR_TO
109579: IFFALSE 110205
// begin depot := list [ i ] [ 2 ] ;
109581: LD_ADDR_VAR 0 8
109585: PUSH
109586: LD_VAR 0 3
109590: PUSH
109591: LD_VAR 0 1
109595: ARRAY
109596: PUSH
109597: LD_INT 2
109599: ARRAY
109600: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
109601: LD_ADDR_VAR 0 5
109605: PUSH
109606: LD_VAR 0 3
109610: PUSH
109611: LD_VAR 0 1
109615: ARRAY
109616: PUSH
109617: LD_INT 1
109619: ARRAY
109620: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
109621: LD_VAR 0 8
109625: PPUSH
109626: CALL_OW 301
109630: PUSH
109631: LD_VAR 0 5
109635: PUSH
109636: LD_VAR 0 8
109640: PPUSH
109641: CALL_OW 255
109645: NONEQUAL
109646: OR
109647: IFFALSE 109676
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
109649: LD_ADDR_EXP 136
109653: PUSH
109654: LD_EXP 136
109658: PPUSH
109659: LD_VAR 0 8
109663: PPUSH
109664: LD_INT 0
109666: PPUSH
109667: CALL_OW 1
109671: ST_TO_ADDR
// exit ;
109672: POP
109673: POP
109674: GO 110207
// end ; x := list [ i ] [ 3 ] ;
109676: LD_ADDR_VAR 0 6
109680: PUSH
109681: LD_VAR 0 3
109685: PUSH
109686: LD_VAR 0 1
109690: ARRAY
109691: PUSH
109692: LD_INT 3
109694: ARRAY
109695: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
109696: LD_ADDR_VAR 0 7
109700: PUSH
109701: LD_VAR 0 3
109705: PUSH
109706: LD_VAR 0 1
109710: ARRAY
109711: PUSH
109712: LD_INT 4
109714: ARRAY
109715: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
109716: LD_ADDR_VAR 0 9
109720: PUSH
109721: LD_VAR 0 6
109725: PPUSH
109726: LD_VAR 0 7
109730: PPUSH
109731: LD_INT 16
109733: PPUSH
109734: CALL 50741 0 3
109738: ST_TO_ADDR
// if not cratesNearbyPoint then
109739: LD_VAR 0 9
109743: NOT
109744: IFFALSE 109750
// exit ;
109746: POP
109747: POP
109748: GO 110207
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
109750: LD_ADDR_VAR 0 4
109754: PUSH
109755: LD_INT 22
109757: PUSH
109758: LD_VAR 0 5
109762: PUSH
109763: EMPTY
109764: LIST
109765: LIST
109766: PUSH
109767: LD_INT 3
109769: PUSH
109770: LD_INT 60
109772: PUSH
109773: EMPTY
109774: LIST
109775: PUSH
109776: EMPTY
109777: LIST
109778: LIST
109779: PUSH
109780: LD_INT 91
109782: PUSH
109783: LD_VAR 0 8
109787: PUSH
109788: LD_INT 6
109790: PUSH
109791: EMPTY
109792: LIST
109793: LIST
109794: LIST
109795: PUSH
109796: LD_INT 2
109798: PUSH
109799: LD_INT 25
109801: PUSH
109802: LD_INT 2
109804: PUSH
109805: EMPTY
109806: LIST
109807: LIST
109808: PUSH
109809: LD_INT 25
109811: PUSH
109812: LD_INT 16
109814: PUSH
109815: EMPTY
109816: LIST
109817: LIST
109818: PUSH
109819: EMPTY
109820: LIST
109821: LIST
109822: LIST
109823: PUSH
109824: EMPTY
109825: LIST
109826: LIST
109827: LIST
109828: LIST
109829: PPUSH
109830: CALL_OW 69
109834: PUSH
109835: LD_VAR 0 8
109839: PPUSH
109840: CALL_OW 313
109844: PPUSH
109845: LD_INT 3
109847: PUSH
109848: LD_INT 60
109850: PUSH
109851: EMPTY
109852: LIST
109853: PUSH
109854: EMPTY
109855: LIST
109856: LIST
109857: PUSH
109858: LD_INT 2
109860: PUSH
109861: LD_INT 25
109863: PUSH
109864: LD_INT 2
109866: PUSH
109867: EMPTY
109868: LIST
109869: LIST
109870: PUSH
109871: LD_INT 25
109873: PUSH
109874: LD_INT 16
109876: PUSH
109877: EMPTY
109878: LIST
109879: LIST
109880: PUSH
109881: EMPTY
109882: LIST
109883: LIST
109884: LIST
109885: PUSH
109886: EMPTY
109887: LIST
109888: LIST
109889: PPUSH
109890: CALL_OW 72
109894: UNION
109895: ST_TO_ADDR
// if tmp then
109896: LD_VAR 0 4
109900: IFFALSE 109980
// begin tmp := ShrinkArray ( tmp , 3 ) ;
109902: LD_ADDR_VAR 0 4
109906: PUSH
109907: LD_VAR 0 4
109911: PPUSH
109912: LD_INT 3
109914: PPUSH
109915: CALL 48710 0 2
109919: ST_TO_ADDR
// for j in tmp do
109920: LD_ADDR_VAR 0 2
109924: PUSH
109925: LD_VAR 0 4
109929: PUSH
109930: FOR_IN
109931: IFFALSE 109974
// begin if IsInUnit ( j ) then
109933: LD_VAR 0 2
109937: PPUSH
109938: CALL_OW 310
109942: IFFALSE 109953
// ComExit ( j ) ;
109944: LD_VAR 0 2
109948: PPUSH
109949: CALL 48793 0 1
// AddComCollect ( j , x , y ) ;
109953: LD_VAR 0 2
109957: PPUSH
109958: LD_VAR 0 6
109962: PPUSH
109963: LD_VAR 0 7
109967: PPUSH
109968: CALL_OW 177
// end ;
109972: GO 109930
109974: POP
109975: POP
// exit ;
109976: POP
109977: POP
109978: GO 110207
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
109980: LD_ADDR_VAR 0 4
109984: PUSH
109985: LD_INT 22
109987: PUSH
109988: LD_VAR 0 5
109992: PUSH
109993: EMPTY
109994: LIST
109995: LIST
109996: PUSH
109997: LD_INT 91
109999: PUSH
110000: LD_VAR 0 8
110004: PUSH
110005: LD_INT 8
110007: PUSH
110008: EMPTY
110009: LIST
110010: LIST
110011: LIST
110012: PUSH
110013: LD_INT 2
110015: PUSH
110016: LD_INT 34
110018: PUSH
110019: LD_INT 12
110021: PUSH
110022: EMPTY
110023: LIST
110024: LIST
110025: PUSH
110026: LD_INT 34
110028: PUSH
110029: LD_INT 51
110031: PUSH
110032: EMPTY
110033: LIST
110034: LIST
110035: PUSH
110036: LD_INT 34
110038: PUSH
110039: LD_INT 32
110041: PUSH
110042: EMPTY
110043: LIST
110044: LIST
110045: PUSH
110046: LD_INT 34
110048: PUSH
110049: LD_INT 89
110051: PUSH
110052: EMPTY
110053: LIST
110054: LIST
110055: PUSH
110056: EMPTY
110057: LIST
110058: LIST
110059: LIST
110060: LIST
110061: LIST
110062: PUSH
110063: EMPTY
110064: LIST
110065: LIST
110066: LIST
110067: PPUSH
110068: CALL_OW 69
110072: ST_TO_ADDR
// if tmp then
110073: LD_VAR 0 4
110077: IFFALSE 110203
// begin for j in tmp do
110079: LD_ADDR_VAR 0 2
110083: PUSH
110084: LD_VAR 0 4
110088: PUSH
110089: FOR_IN
110090: IFFALSE 110201
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
110092: LD_VAR 0 2
110096: PPUSH
110097: CALL_OW 262
110101: PUSH
110102: LD_INT 3
110104: EQUAL
110105: PUSH
110106: LD_VAR 0 2
110110: PPUSH
110111: CALL_OW 261
110115: PUSH
110116: LD_INT 20
110118: GREATER
110119: OR
110120: PUSH
110121: LD_VAR 0 2
110125: PPUSH
110126: CALL_OW 314
110130: NOT
110131: AND
110132: PUSH
110133: LD_VAR 0 2
110137: PPUSH
110138: CALL_OW 263
110142: PUSH
110143: LD_INT 1
110145: NONEQUAL
110146: PUSH
110147: LD_VAR 0 2
110151: PPUSH
110152: CALL_OW 311
110156: OR
110157: AND
110158: IFFALSE 110199
// begin ComCollect ( j , x , y ) ;
110160: LD_VAR 0 2
110164: PPUSH
110165: LD_VAR 0 6
110169: PPUSH
110170: LD_VAR 0 7
110174: PPUSH
110175: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
110179: LD_VAR 0 2
110183: PPUSH
110184: LD_VAR 0 8
110188: PPUSH
110189: CALL_OW 172
// exit ;
110193: POP
110194: POP
110195: POP
110196: POP
110197: GO 110207
// end ;
110199: GO 110089
110201: POP
110202: POP
// end ; end ;
110203: GO 109578
110205: POP
110206: POP
// end ; end_of_file
110207: PPOPN 9
110209: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
110210: LD_VAR 0 1
110214: PPUSH
110215: LD_VAR 0 2
110219: PPUSH
110220: LD_VAR 0 3
110224: PPUSH
110225: LD_VAR 0 4
110229: PPUSH
110230: LD_VAR 0 5
110234: PPUSH
110235: LD_VAR 0 6
110239: PPUSH
110240: CALL 94612 0 6
// end ;
110244: PPOPN 6
110246: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
110247: LD_INT 0
110249: PPUSH
// begin if not units then
110250: LD_VAR 0 1
110254: NOT
110255: IFFALSE 110259
// exit ;
110257: GO 110259
// end ;
110259: PPOPN 7
110261: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
110262: CALL 94583 0 0
// end ;
110266: PPOPN 1
110268: END
