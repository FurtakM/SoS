// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 206 0 0
// if debug then
  15: LD_EXP 1
  19: IFFALSE 38
// begin FogOff ( 1 ) ;
  21: LD_INT 1
  23: PPUSH
  24: CALL_OW 344
// Difficulty := 2 ;
  28: LD_ADDR_OWVAR 67
  32: PUSH
  33: LD_INT 2
  35: ST_TO_ADDR
// end else
  36: GO 51
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  38: LD_ADDR_OWVAR 67
  42: PUSH
  43: LD_INT 0
  45: PPUSH
  46: CALL_OW 426
  50: ST_TO_ADDR
// ChangeSideFog ( 4 , 1 ) ;
  51: LD_INT 4
  53: PPUSH
  54: LD_INT 1
  56: PPUSH
  57: CALL_OW 343
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , gensher_ape , 0 ) ;
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 0
  66: PPUSH
  67: LD_INT 5
  69: PPUSH
  70: LD_INT 0
  72: PPUSH
  73: LD_INT 0
  75: PPUSH
  76: LD_INT 0
  78: PPUSH
  79: LD_INT 0
  81: PPUSH
  82: LD_INT 7
  84: PPUSH
  85: LD_INT 0
  87: PPUSH
  88: CALL 45104 0 9
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , powell_ape , 0 ) ;
  92: LD_INT 0
  94: PPUSH
  95: LD_INT 0
  97: PPUSH
  98: LD_INT 3
 100: PPUSH
 101: LD_INT 0
 103: PPUSH
 104: LD_INT 0
 106: PPUSH
 107: LD_INT 0
 109: PPUSH
 110: LD_INT 0
 112: PPUSH
 113: LD_INT 4
 115: PPUSH
 116: LD_INT 0
 118: PPUSH
 119: CALL 45104 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , popov_ape , 0 ) ;
 123: LD_INT 0
 125: PPUSH
 126: LD_INT 0
 128: PPUSH
 129: LD_INT 5
 131: PPUSH
 132: LD_INT 0
 134: PPUSH
 135: LD_INT 0
 137: PPUSH
 138: LD_INT 0
 140: PPUSH
 141: LD_INT 0
 143: PPUSH
 144: LD_INT 11
 146: PPUSH
 147: LD_INT 0
 149: PPUSH
 150: CALL 45104 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , sikorski_ape , 0 ) ;
 154: LD_INT 0
 156: PPUSH
 157: LD_INT 0
 159: PPUSH
 160: LD_INT 5
 162: PPUSH
 163: LD_INT 0
 165: PPUSH
 166: LD_INT 0
 168: PPUSH
 169: LD_INT 0
 171: PPUSH
 172: LD_INT 0
 174: PPUSH
 175: LD_INT 14
 177: PPUSH
 178: LD_INT 0
 180: PPUSH
 181: CALL 45104 0 9
// PrepareGensher ;
 185: CALL 3138 0 0
// PreparePopov ;
 189: CALL 6331 0 0
// PreparePowell ;
 193: CALL 585 0 0
// PrepareSikorski ;
 197: CALL 9005 0 0
// MC_Start ( ) ;
 201: CALL 54538 0 0
// end ;
 205: END
// export debug , game , staticMines , arDestroyed , ruDestroyed , loseCounter , powellLoseCounter , powellInTrouble , sikorskiInTrouble ; function InitVariables ; begin
 206: LD_INT 0
 208: PPUSH
// debug := 1 ;
 209: LD_ADDR_EXP 1
 213: PUSH
 214: LD_INT 1
 216: ST_TO_ADDR
// game := true ;
 217: LD_ADDR_EXP 2
 221: PUSH
 222: LD_INT 1
 224: ST_TO_ADDR
// staticMines := [ ] ;
 225: LD_ADDR_EXP 3
 229: PUSH
 230: EMPTY
 231: ST_TO_ADDR
// arDestroyed := false ;
 232: LD_ADDR_EXP 4
 236: PUSH
 237: LD_INT 0
 239: ST_TO_ADDR
// ruDestroyed := false ;
 240: LD_ADDR_EXP 5
 244: PUSH
 245: LD_INT 0
 247: ST_TO_ADDR
// powellInTrouble := false ;
 248: LD_ADDR_EXP 8
 252: PUSH
 253: LD_INT 0
 255: ST_TO_ADDR
// sikorskiInTrouble := false ;
 256: LD_ADDR_EXP 9
 260: PUSH
 261: LD_INT 0
 263: ST_TO_ADDR
// end ;
 264: LD_VAR 0 1
 268: RET
// export function CustomInitMacro ; begin
 269: LD_INT 0
 271: PPUSH
// InitMC_Gensher ( ) ;
 272: CALL 4258 0 0
// InitMC_Powell ( ) ;
 276: CALL 1493 0 0
// InitMC_Popov ( ) ;
 280: CALL 7475 0 0
// end ;
 284: LD_VAR 0 1
 288: RET
// every 0 0$10 do var cr , time , i ;
 289: GO 291
 291: DISABLE
 292: LD_INT 0
 294: PPUSH
 295: PPUSH
 296: PPUSH
// begin time := 0 0$20 ;
 297: LD_ADDR_VAR 0 2
 301: PUSH
 302: LD_INT 700
 304: ST_TO_ADDR
// repeat wait ( time ) ;
 305: LD_VAR 0 2
 309: PPUSH
 310: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
 314: LD_ADDR_VAR 0 1
 318: PUSH
 319: LD_INT 1
 321: PPUSH
 322: LD_INT 5
 324: PPUSH
 325: CALL_OW 12
 329: ST_TO_ADDR
// for i in [ powell_crates , gensher_crates , popov_crates , sikorski_crates ] do
 330: LD_ADDR_VAR 0 3
 334: PUSH
 335: LD_INT 5
 337: PUSH
 338: LD_INT 8
 340: PUSH
 341: LD_INT 12
 343: PUSH
 344: LD_INT 13
 346: PUSH
 347: EMPTY
 348: LIST
 349: LIST
 350: LIST
 351: LIST
 352: PUSH
 353: FOR_IN
 354: IFFALSE 408
// begin if GetResourceArea ( i , mat_cans ) < 40 then
 356: LD_VAR 0 3
 360: PPUSH
 361: LD_INT 1
 363: PPUSH
 364: CALL_OW 287
 368: PUSH
 369: LD_INT 40
 371: LESS
 372: IFFALSE 391
// CreateCratesArea ( cr , i , true ) ;
 374: LD_VAR 0 1
 378: PPUSH
 379: LD_VAR 0 3
 383: PPUSH
 384: LD_INT 1
 386: PPUSH
 387: CALL_OW 55
// wait ( rand ( 0 0$5 , 0 0$15 ) ) ;
 391: LD_INT 175
 393: PPUSH
 394: LD_INT 525
 396: PPUSH
 397: CALL_OW 12
 401: PPUSH
 402: CALL_OW 67
// end ;
 406: GO 353
 408: POP
 409: POP
// time := time + 0 0$2 ;
 410: LD_ADDR_VAR 0 2
 414: PUSH
 415: LD_VAR 0 2
 419: PUSH
 420: LD_INT 70
 422: PLUS
 423: ST_TO_ADDR
// if time > 0 0$35 then
 424: LD_VAR 0 2
 428: PUSH
 429: LD_INT 1225
 431: GREATER
 432: IFFALSE 442
// time := 0 0$25 ;
 434: LD_ADDR_VAR 0 2
 438: PUSH
 439: LD_INT 875
 441: ST_TO_ADDR
// until not game ;
 442: LD_EXP 2
 446: NOT
 447: IFFALSE 305
// end ;
 449: PPOPN 3
 451: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
 452: LD_INT 3
 454: PUSH
 455: LD_INT 22
 457: PUSH
 458: LD_INT 1
 460: PUSH
 461: EMPTY
 462: LIST
 463: LIST
 464: PUSH
 465: EMPTY
 466: LIST
 467: LIST
 468: PUSH
 469: LD_INT 32
 471: PUSH
 472: LD_INT 1
 474: PUSH
 475: EMPTY
 476: LIST
 477: LIST
 478: PUSH
 479: EMPTY
 480: LIST
 481: LIST
 482: PPUSH
 483: CALL_OW 69
 487: IFFALSE 582
 489: GO 491
 491: DISABLE
 492: LD_INT 0
 494: PPUSH
 495: PPUSH
// begin enable ;
 496: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
 497: LD_ADDR_VAR 0 2
 501: PUSH
 502: LD_INT 3
 504: PUSH
 505: LD_INT 22
 507: PUSH
 508: LD_INT 1
 510: PUSH
 511: EMPTY
 512: LIST
 513: LIST
 514: PUSH
 515: EMPTY
 516: LIST
 517: LIST
 518: PUSH
 519: LD_INT 32
 521: PUSH
 522: LD_INT 1
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: PUSH
 529: EMPTY
 530: LIST
 531: LIST
 532: PPUSH
 533: CALL_OW 69
 537: ST_TO_ADDR
// for i in tmp do
 538: LD_ADDR_VAR 0 1
 542: PUSH
 543: LD_VAR 0 2
 547: PUSH
 548: FOR_IN
 549: IFFALSE 580
// if GetFuel ( i ) < 5 then
 551: LD_VAR 0 1
 555: PPUSH
 556: CALL_OW 261
 560: PUSH
 561: LD_INT 5
 563: LESS
 564: IFFALSE 578
// SetFuel ( i , 5 ) ;
 566: LD_VAR 0 1
 570: PPUSH
 571: LD_INT 5
 573: PPUSH
 574: CALL_OW 240
 578: GO 548
 580: POP
 581: POP
// end ; end_of_file
 582: PPOPN 2
 584: END
// export Powell , powell_side , powellAttackGroup ; export function PreparePowell ; var i , list , b , tmp ; begin
 585: LD_INT 0
 587: PPUSH
 588: PPUSH
 589: PPUSH
 590: PPUSH
 591: PPUSH
// powell_side := 4 ;
 592: LD_ADDR_EXP 11
 596: PUSH
 597: LD_INT 4
 599: ST_TO_ADDR
// uc_side := powell_side ;
 600: LD_ADDR_OWVAR 20
 604: PUSH
 605: LD_EXP 11
 609: ST_TO_ADDR
// uc_nation := 1 ;
 610: LD_ADDR_OWVAR 21
 614: PUSH
 615: LD_INT 1
 617: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
 618: LD_ADDR_EXP 10
 622: PUSH
 623: LD_STRING Powell
 625: PPUSH
 626: CALL_OW 25
 630: ST_TO_ADDR
// SetSkill ( Powell , 1 , 7 ) ;
 631: LD_EXP 10
 635: PPUSH
 636: LD_INT 1
 638: PPUSH
 639: LD_INT 7
 641: PPUSH
 642: CALL_OW 237
// SetSkill ( Powell , 2 , 5 ) ;
 646: LD_EXP 10
 650: PPUSH
 651: LD_INT 2
 653: PPUSH
 654: LD_INT 5
 656: PPUSH
 657: CALL_OW 237
// SetSkill ( Powell , 3 , 6 ) ;
 661: LD_EXP 10
 665: PPUSH
 666: LD_INT 3
 668: PPUSH
 669: LD_INT 6
 671: PPUSH
 672: CALL_OW 237
// SetSkill ( Powell , 4 , 4 ) ;
 676: LD_EXP 10
 680: PPUSH
 681: LD_INT 4
 683: PPUSH
 684: LD_INT 4
 686: PPUSH
 687: CALL_OW 237
// PlaceHumanInUnit ( Powell , us_depot ) ;
 691: LD_EXP 10
 695: PPUSH
 696: LD_INT 4
 698: PPUSH
 699: CALL_OW 52
// list := [ [ b_barracks , 178 , 117 , 2 ] , [ b_oil_mine , 167 , 102 , 0 ] , [ b_lab , 200 , 111 , 4 , b_lab_weapon , b_lab_siberium ] , [ b_factory , 201 , 140 , 4 ] , [ b_solar_power , 206 , 124 , 3 ] , [ b_solar_power , 209 , 128 , 3 ] , [ b_solar_power , 211 , 132 , 3 ] , [ b_siberite_mine , 173 , 83 , 3 ] , [ b_lab , 186 , 103 , 2 , b_lab_computer , b_lab_opto ] , [ b_turret , 173 , 99 , 2 , us_heavy_gun ] , [ b_bunker , 174 , 102 , 2 , us_heavy_gun ] , [ b_bunker , 178 , 100 , 2 , us_heavy_gun ] , [ b_turret , 174 , 108 , 1 , us_rocket_launcher ] , [ b_turret , 182 , 122 , 1 , us_rocket_launcher ] , [ b_control_tower , 194 , 124 , 5 ] , [ b_turret , 184 , 141 , 1 , us_heavy_gun ] , [ b_turret , 183 , 131 , 2 , us_radar ] , [ b_turret , 194 , 146 , 4 , us_rocket_launcher ] , [ b_turret , 190 , 142 , 4 , us_rocket_launcher ] , [ b_siberite_power , 204 , 133 , 3 ] , [ b_solar_power , 201 , 133 , 3 ] , [ b_siberite_power , 199 , 119 , 5 ] ] ;
 703: LD_ADDR_VAR 0 3
 707: PUSH
 708: LD_INT 5
 710: PUSH
 711: LD_INT 178
 713: PUSH
 714: LD_INT 117
 716: PUSH
 717: LD_INT 2
 719: PUSH
 720: EMPTY
 721: LIST
 722: LIST
 723: LIST
 724: LIST
 725: PUSH
 726: LD_INT 29
 728: PUSH
 729: LD_INT 167
 731: PUSH
 732: LD_INT 102
 734: PUSH
 735: LD_INT 0
 737: PUSH
 738: EMPTY
 739: LIST
 740: LIST
 741: LIST
 742: LIST
 743: PUSH
 744: LD_INT 6
 746: PUSH
 747: LD_INT 200
 749: PUSH
 750: LD_INT 111
 752: PUSH
 753: LD_INT 4
 755: PUSH
 756: LD_INT 10
 758: PUSH
 759: LD_INT 11
 761: PUSH
 762: EMPTY
 763: LIST
 764: LIST
 765: LIST
 766: LIST
 767: LIST
 768: LIST
 769: PUSH
 770: LD_INT 3
 772: PUSH
 773: LD_INT 201
 775: PUSH
 776: LD_INT 140
 778: PUSH
 779: LD_INT 4
 781: PUSH
 782: EMPTY
 783: LIST
 784: LIST
 785: LIST
 786: LIST
 787: PUSH
 788: LD_INT 27
 790: PUSH
 791: LD_INT 206
 793: PUSH
 794: LD_INT 124
 796: PUSH
 797: LD_INT 3
 799: PUSH
 800: EMPTY
 801: LIST
 802: LIST
 803: LIST
 804: LIST
 805: PUSH
 806: LD_INT 27
 808: PUSH
 809: LD_INT 209
 811: PUSH
 812: LD_INT 128
 814: PUSH
 815: LD_INT 3
 817: PUSH
 818: EMPTY
 819: LIST
 820: LIST
 821: LIST
 822: LIST
 823: PUSH
 824: LD_INT 27
 826: PUSH
 827: LD_INT 211
 829: PUSH
 830: LD_INT 132
 832: PUSH
 833: LD_INT 3
 835: PUSH
 836: EMPTY
 837: LIST
 838: LIST
 839: LIST
 840: LIST
 841: PUSH
 842: LD_INT 30
 844: PUSH
 845: LD_INT 173
 847: PUSH
 848: LD_INT 83
 850: PUSH
 851: LD_INT 3
 853: PUSH
 854: EMPTY
 855: LIST
 856: LIST
 857: LIST
 858: LIST
 859: PUSH
 860: LD_INT 6
 862: PUSH
 863: LD_INT 186
 865: PUSH
 866: LD_INT 103
 868: PUSH
 869: LD_INT 2
 871: PUSH
 872: LD_INT 12
 874: PUSH
 875: LD_INT 15
 877: PUSH
 878: EMPTY
 879: LIST
 880: LIST
 881: LIST
 882: LIST
 883: LIST
 884: LIST
 885: PUSH
 886: LD_INT 33
 888: PUSH
 889: LD_INT 173
 891: PUSH
 892: LD_INT 99
 894: PUSH
 895: LD_INT 2
 897: PUSH
 898: LD_INT 6
 900: PUSH
 901: EMPTY
 902: LIST
 903: LIST
 904: LIST
 905: LIST
 906: LIST
 907: PUSH
 908: LD_INT 32
 910: PUSH
 911: LD_INT 174
 913: PUSH
 914: LD_INT 102
 916: PUSH
 917: LD_INT 2
 919: PUSH
 920: LD_INT 6
 922: PUSH
 923: EMPTY
 924: LIST
 925: LIST
 926: LIST
 927: LIST
 928: LIST
 929: PUSH
 930: LD_INT 32
 932: PUSH
 933: LD_INT 178
 935: PUSH
 936: LD_INT 100
 938: PUSH
 939: LD_INT 2
 941: PUSH
 942: LD_INT 6
 944: PUSH
 945: EMPTY
 946: LIST
 947: LIST
 948: LIST
 949: LIST
 950: LIST
 951: PUSH
 952: LD_INT 33
 954: PUSH
 955: LD_INT 174
 957: PUSH
 958: LD_INT 108
 960: PUSH
 961: LD_INT 1
 963: PUSH
 964: LD_INT 7
 966: PUSH
 967: EMPTY
 968: LIST
 969: LIST
 970: LIST
 971: LIST
 972: LIST
 973: PUSH
 974: LD_INT 33
 976: PUSH
 977: LD_INT 182
 979: PUSH
 980: LD_INT 122
 982: PUSH
 983: LD_INT 1
 985: PUSH
 986: LD_INT 7
 988: PUSH
 989: EMPTY
 990: LIST
 991: LIST
 992: LIST
 993: LIST
 994: LIST
 995: PUSH
 996: LD_INT 36
 998: PUSH
 999: LD_INT 194
1001: PUSH
1002: LD_INT 124
1004: PUSH
1005: LD_INT 5
1007: PUSH
1008: EMPTY
1009: LIST
1010: LIST
1011: LIST
1012: LIST
1013: PUSH
1014: LD_INT 33
1016: PUSH
1017: LD_INT 184
1019: PUSH
1020: LD_INT 141
1022: PUSH
1023: LD_INT 1
1025: PUSH
1026: LD_INT 6
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: LIST
1035: PUSH
1036: LD_INT 33
1038: PUSH
1039: LD_INT 183
1041: PUSH
1042: LD_INT 131
1044: PUSH
1045: LD_INT 2
1047: PUSH
1048: LD_INT 11
1050: PUSH
1051: EMPTY
1052: LIST
1053: LIST
1054: LIST
1055: LIST
1056: LIST
1057: PUSH
1058: LD_INT 33
1060: PUSH
1061: LD_INT 194
1063: PUSH
1064: LD_INT 146
1066: PUSH
1067: LD_INT 4
1069: PUSH
1070: LD_INT 7
1072: PUSH
1073: EMPTY
1074: LIST
1075: LIST
1076: LIST
1077: LIST
1078: LIST
1079: PUSH
1080: LD_INT 33
1082: PUSH
1083: LD_INT 190
1085: PUSH
1086: LD_INT 142
1088: PUSH
1089: LD_INT 4
1091: PUSH
1092: LD_INT 7
1094: PUSH
1095: EMPTY
1096: LIST
1097: LIST
1098: LIST
1099: LIST
1100: LIST
1101: PUSH
1102: LD_INT 28
1104: PUSH
1105: LD_INT 204
1107: PUSH
1108: LD_INT 133
1110: PUSH
1111: LD_INT 3
1113: PUSH
1114: EMPTY
1115: LIST
1116: LIST
1117: LIST
1118: LIST
1119: PUSH
1120: LD_INT 27
1122: PUSH
1123: LD_INT 201
1125: PUSH
1126: LD_INT 133
1128: PUSH
1129: LD_INT 3
1131: PUSH
1132: EMPTY
1133: LIST
1134: LIST
1135: LIST
1136: LIST
1137: PUSH
1138: LD_INT 28
1140: PUSH
1141: LD_INT 199
1143: PUSH
1144: LD_INT 119
1146: PUSH
1147: LD_INT 5
1149: PUSH
1150: EMPTY
1151: LIST
1152: LIST
1153: LIST
1154: LIST
1155: PUSH
1156: EMPTY
1157: LIST
1158: LIST
1159: LIST
1160: LIST
1161: LIST
1162: LIST
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: LIST
1168: LIST
1169: LIST
1170: LIST
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: ST_TO_ADDR
// for i in list do
1180: LD_ADDR_VAR 0 2
1184: PUSH
1185: LD_VAR 0 3
1189: PUSH
1190: FOR_IN
1191: IFFALSE 1355
// begin uc_side := 4 ;
1193: LD_ADDR_OWVAR 20
1197: PUSH
1198: LD_INT 4
1200: ST_TO_ADDR
// uc_nation := 1 ;
1201: LD_ADDR_OWVAR 21
1205: PUSH
1206: LD_INT 1
1208: ST_TO_ADDR
// InitBc ;
1209: CALL_OW 21
// bc_type := i [ 1 ] ;
1213: LD_ADDR_OWVAR 42
1217: PUSH
1218: LD_VAR 0 2
1222: PUSH
1223: LD_INT 1
1225: ARRAY
1226: ST_TO_ADDR
// if i [ 1 ] = b_lab then
1227: LD_VAR 0 2
1231: PUSH
1232: LD_INT 1
1234: ARRAY
1235: PUSH
1236: LD_INT 6
1238: EQUAL
1239: IFFALSE 1277
// begin bc_type := b_lab_full ;
1241: LD_ADDR_OWVAR 42
1245: PUSH
1246: LD_INT 8
1248: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
1249: LD_ADDR_OWVAR 44
1253: PUSH
1254: LD_VAR 0 2
1258: PUSH
1259: LD_INT 5
1261: ARRAY
1262: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
1263: LD_ADDR_OWVAR 45
1267: PUSH
1268: LD_VAR 0 2
1272: PUSH
1273: LD_INT 6
1275: ARRAY
1276: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1277: LD_ADDR_VAR 0 4
1281: PUSH
1282: LD_VAR 0 2
1286: PUSH
1287: LD_INT 2
1289: ARRAY
1290: PPUSH
1291: LD_VAR 0 2
1295: PUSH
1296: LD_INT 3
1298: ARRAY
1299: PPUSH
1300: LD_VAR 0 2
1304: PUSH
1305: LD_INT 4
1307: ARRAY
1308: PPUSH
1309: CALL_OW 47
1313: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
1314: LD_VAR 0 2
1318: PUSH
1319: LD_INT 1
1321: ARRAY
1322: PUSH
1323: LD_INT 33
1325: PUSH
1326: LD_INT 32
1328: PUSH
1329: EMPTY
1330: LIST
1331: LIST
1332: IN
1333: IFFALSE 1353
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
1335: LD_VAR 0 4
1339: PPUSH
1340: LD_VAR 0 2
1344: PUSH
1345: LD_INT 5
1347: ARRAY
1348: PPUSH
1349: CALL_OW 431
// end ;
1353: GO 1190
1355: POP
1356: POP
// tmp := PrepareBase ( us_depot , powell_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 5500 , 500 , 0 ] , [ 6 , 6 , 6 , 6 ] ) ;
1357: LD_ADDR_VAR 0 5
1361: PUSH
1362: LD_INT 4
1364: PPUSH
1365: LD_INT 1
1367: PPUSH
1368: LD_STRING 
1370: PPUSH
1371: LD_INT 8
1373: PUSH
1374: LD_INT 7
1376: PUSH
1377: LD_INT 6
1379: PUSH
1380: EMPTY
1381: LIST
1382: LIST
1383: LIST
1384: PUSH
1385: LD_OWVAR 67
1389: ARRAY
1390: PPUSH
1391: LD_INT 5500
1393: PUSH
1394: LD_INT 500
1396: PUSH
1397: LD_INT 0
1399: PUSH
1400: EMPTY
1401: LIST
1402: LIST
1403: LIST
1404: PPUSH
1405: LD_INT 6
1407: PUSH
1408: LD_INT 6
1410: PUSH
1411: LD_INT 6
1413: PUSH
1414: LD_INT 6
1416: PUSH
1417: EMPTY
1418: LIST
1419: LIST
1420: LIST
1421: LIST
1422: PPUSH
1423: CALL 19432 0 6
1427: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , tmp union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) ) ;
1428: LD_ADDR_EXP 23
1432: PUSH
1433: LD_EXP 23
1437: PPUSH
1438: LD_INT 1
1440: PPUSH
1441: LD_VAR 0 5
1445: PUSH
1446: LD_INT 22
1448: PUSH
1449: LD_INT 4
1451: PUSH
1452: EMPTY
1453: LIST
1454: LIST
1455: PUSH
1456: LD_INT 21
1458: PUSH
1459: LD_INT 3
1461: PUSH
1462: EMPTY
1463: LIST
1464: LIST
1465: PUSH
1466: EMPTY
1467: LIST
1468: LIST
1469: PPUSH
1470: CALL_OW 69
1474: UNION
1475: PPUSH
1476: CALL_OW 1
1480: ST_TO_ADDR
// powellAttackGroup := [ ] ;
1481: LD_ADDR_EXP 12
1485: PUSH
1486: EMPTY
1487: ST_TO_ADDR
// end ;
1488: LD_VAR 0 1
1492: RET
// export function InitMC_Powell ( ) ; begin
1493: LD_INT 0
1495: PPUSH
// MC_SetScanArea ( 1 , powell_base ) ;
1496: LD_INT 1
1498: PPUSH
1499: LD_INT 1
1501: PPUSH
1502: CALL 77915 0 2
// MC_SetParkingArea ( 1 , powell_parking ) ;
1506: LD_INT 1
1508: PPUSH
1509: LD_INT 6
1511: PPUSH
1512: CALL 77859 0 2
// MC_SetDepositsXY ( 1 , [ [ 167 , 102 , 0 ] , [ 173 , 83 , 1 ] , [ 171 , 141 , 0 ] , [ 178 , 148 , 1 ] ] ) ;
1516: LD_INT 1
1518: PPUSH
1519: LD_INT 167
1521: PUSH
1522: LD_INT 102
1524: PUSH
1525: LD_INT 0
1527: PUSH
1528: EMPTY
1529: LIST
1530: LIST
1531: LIST
1532: PUSH
1533: LD_INT 173
1535: PUSH
1536: LD_INT 83
1538: PUSH
1539: LD_INT 1
1541: PUSH
1542: EMPTY
1543: LIST
1544: LIST
1545: LIST
1546: PUSH
1547: LD_INT 171
1549: PUSH
1550: LD_INT 141
1552: PUSH
1553: LD_INT 0
1555: PUSH
1556: EMPTY
1557: LIST
1558: LIST
1559: LIST
1560: PUSH
1561: LD_INT 178
1563: PUSH
1564: LD_INT 148
1566: PUSH
1567: LD_INT 1
1569: PUSH
1570: EMPTY
1571: LIST
1572: LIST
1573: LIST
1574: PUSH
1575: EMPTY
1576: LIST
1577: LIST
1578: LIST
1579: LIST
1580: PPUSH
1581: CALL 76918 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ us_radar , us_heavy_gun , us_rocket_launcher ] ) ;
1585: LD_INT 1
1587: PPUSH
1588: LD_INT 11
1590: PUSH
1591: LD_INT 6
1593: PUSH
1594: LD_INT 7
1596: PUSH
1597: EMPTY
1598: LIST
1599: LIST
1600: LIST
1601: PPUSH
1602: CALL 77747 0 2
// MC_SetCratesArea ( 1 , powell_crates ) ;
1606: LD_INT 1
1608: PPUSH
1609: LD_INT 5
1611: PPUSH
1612: CALL 77429 0 2
// MC_SetTame ( 1 , powell_ape ) ;
1616: LD_INT 1
1618: PPUSH
1619: LD_INT 4
1621: PPUSH
1622: CALL 77160 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
1626: LD_INT 1
1628: PPUSH
1629: LD_INT 4
1631: PPUSH
1632: CALL 76779 0 2
// MC_SetProduceList ( 1 , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ] ) ;
1636: LD_INT 1
1638: PPUSH
1639: LD_INT 3
1641: PUSH
1642: LD_INT 1
1644: PUSH
1645: LD_INT 2
1647: PUSH
1648: LD_INT 5
1650: PUSH
1651: EMPTY
1652: LIST
1653: LIST
1654: LIST
1655: LIST
1656: PUSH
1657: LD_INT 4
1659: PUSH
1660: LD_INT 1
1662: PUSH
1663: LD_INT 2
1665: PUSH
1666: LD_INT 6
1668: PUSH
1669: EMPTY
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: PUSH
1675: LD_INT 4
1677: PUSH
1678: LD_INT 1
1680: PUSH
1681: LD_INT 2
1683: PUSH
1684: LD_INT 7
1686: PUSH
1687: EMPTY
1688: LIST
1689: LIST
1690: LIST
1691: LIST
1692: PUSH
1693: LD_INT 4
1695: PUSH
1696: LD_INT 1
1698: PUSH
1699: LD_INT 2
1701: PUSH
1702: LD_INT 6
1704: PUSH
1705: EMPTY
1706: LIST
1707: LIST
1708: LIST
1709: LIST
1710: PUSH
1711: EMPTY
1712: LIST
1713: LIST
1714: LIST
1715: LIST
1716: PPUSH
1717: CALL 76594 0 2
// MC_SetFactoryExtension ( 1 , 201 , 140 , 4 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1721: LD_INT 1
1723: PPUSH
1724: LD_INT 201
1726: PPUSH
1727: LD_INT 140
1729: PPUSH
1730: LD_INT 4
1732: PPUSH
1733: LD_INT 19
1735: PUSH
1736: LD_INT 16
1738: PUSH
1739: LD_INT 17
1741: PUSH
1742: LD_INT 18
1744: PUSH
1745: LD_INT 22
1747: PUSH
1748: EMPTY
1749: LIST
1750: LIST
1751: LIST
1752: LIST
1753: LIST
1754: PPUSH
1755: CALL 77541 0 5
// end ;
1759: LD_VAR 0 1
1763: RET
// every 8 8$00 + 2 2$00 trigger IsOk ( us_depot ) do var i , base , tmp , attackers , amount ;
1764: LD_INT 4
1766: PPUSH
1767: CALL_OW 302
1771: IFFALSE 2431
1773: GO 1775
1775: DISABLE
1776: LD_INT 0
1778: PPUSH
1779: PPUSH
1780: PPUSH
1781: PPUSH
1782: PPUSH
// begin enable ;
1783: ENABLE
// base := 1 ;
1784: LD_ADDR_VAR 0 2
1788: PUSH
1789: LD_INT 1
1791: ST_TO_ADDR
// tmp := [ [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ] ;
1792: LD_ADDR_VAR 0 3
1796: PUSH
1797: LD_INT 4
1799: PUSH
1800: LD_INT 1
1802: PUSH
1803: LD_INT 2
1805: PUSH
1806: LD_INT 6
1808: PUSH
1809: EMPTY
1810: LIST
1811: LIST
1812: LIST
1813: LIST
1814: PUSH
1815: LD_INT 4
1817: PUSH
1818: LD_INT 1
1820: PUSH
1821: LD_INT 2
1823: PUSH
1824: LD_INT 6
1826: PUSH
1827: EMPTY
1828: LIST
1829: LIST
1830: LIST
1831: LIST
1832: PUSH
1833: LD_INT 3
1835: PUSH
1836: LD_INT 1
1838: PUSH
1839: LD_INT 2
1841: PUSH
1842: LD_INT 7
1844: PUSH
1845: EMPTY
1846: LIST
1847: LIST
1848: LIST
1849: LIST
1850: PUSH
1851: LD_INT 3
1853: PUSH
1854: LD_INT 1
1856: PUSH
1857: LD_INT 2
1859: PUSH
1860: LD_INT 7
1862: PUSH
1863: EMPTY
1864: LIST
1865: LIST
1866: LIST
1867: LIST
1868: PUSH
1869: EMPTY
1870: LIST
1871: LIST
1872: LIST
1873: LIST
1874: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
1875: LD_ADDR_VAR 0 5
1879: PUSH
1880: LD_VAR 0 5
1884: PUSH
1885: LD_OWVAR 1
1889: PUSH
1890: LD_INT 21000
1892: DIV
1893: PLUS
1894: ST_TO_ADDR
// if amount > 8 then
1895: LD_VAR 0 5
1899: PUSH
1900: LD_INT 8
1902: GREATER
1903: IFFALSE 1913
// amount := 8 ;
1905: LD_ADDR_VAR 0 5
1909: PUSH
1910: LD_INT 8
1912: ST_TO_ADDR
// for i = 1 to amount do
1913: LD_ADDR_VAR 0 1
1917: PUSH
1918: DOUBLE
1919: LD_INT 1
1921: DEC
1922: ST_TO_ADDR
1923: LD_VAR 0 5
1927: PUSH
1928: FOR_TO
1929: IFFALSE 2013
// tmp := Insert ( tmp , tmp + 1 , [ [ us_medium_tracked , us_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ us_rocket_launcher , us_double_gun ] [ rand ( 1 , 2 ) ] ] ) ;
1931: LD_ADDR_VAR 0 3
1935: PUSH
1936: LD_VAR 0 3
1940: PPUSH
1941: LD_VAR 0 3
1945: PUSH
1946: LD_INT 1
1948: PLUS
1949: PPUSH
1950: LD_INT 3
1952: PUSH
1953: LD_INT 4
1955: PUSH
1956: EMPTY
1957: LIST
1958: LIST
1959: PUSH
1960: LD_INT 1
1962: PPUSH
1963: LD_INT 2
1965: PPUSH
1966: CALL_OW 12
1970: ARRAY
1971: PUSH
1972: LD_INT 1
1974: PUSH
1975: LD_INT 2
1977: PUSH
1978: LD_INT 7
1980: PUSH
1981: LD_INT 5
1983: PUSH
1984: EMPTY
1985: LIST
1986: LIST
1987: PUSH
1988: LD_INT 1
1990: PPUSH
1991: LD_INT 2
1993: PPUSH
1994: CALL_OW 12
1998: ARRAY
1999: PUSH
2000: EMPTY
2001: LIST
2002: LIST
2003: LIST
2004: LIST
2005: PPUSH
2006: CALL_OW 2
2010: ST_TO_ADDR
2011: GO 1928
2013: POP
2014: POP
// MC_InsertProduceList ( base , tmp ) ;
2015: LD_VAR 0 2
2019: PPUSH
2020: LD_VAR 0 3
2024: PPUSH
2025: CALL 76642 0 2
// repeat wait ( 0 0$1 ) ;
2029: LD_INT 35
2031: PPUSH
2032: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
2036: LD_VAR 0 2
2040: PPUSH
2041: LD_INT 1
2043: PPUSH
2044: CALL 78060 0 2
2048: PUSH
2049: LD_VAR 0 5
2053: GREATEREQUAL
2054: IFFALSE 2029
// wait ( 0 0$30 ) ;
2056: LD_INT 1050
2058: PPUSH
2059: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , us_bulldozer ] ] ) ;
2063: LD_ADDR_VAR 0 4
2067: PUSH
2068: LD_EXP 42
2072: PUSH
2073: LD_VAR 0 2
2077: ARRAY
2078: PUSH
2079: LD_EXP 42
2083: PUSH
2084: LD_VAR 0 2
2088: ARRAY
2089: PPUSH
2090: LD_INT 2
2092: PUSH
2093: LD_INT 34
2095: PUSH
2096: LD_INT 12
2098: PUSH
2099: EMPTY
2100: LIST
2101: LIST
2102: PUSH
2103: LD_INT 34
2105: PUSH
2106: LD_INT 13
2108: PUSH
2109: EMPTY
2110: LIST
2111: LIST
2112: PUSH
2113: LD_INT 34
2115: PUSH
2116: LD_INT 14
2118: PUSH
2119: EMPTY
2120: LIST
2121: LIST
2122: PUSH
2123: EMPTY
2124: LIST
2125: LIST
2126: LIST
2127: LIST
2128: PPUSH
2129: CALL_OW 72
2133: DIFF
2134: ST_TO_ADDR
// if not attackers then
2135: LD_VAR 0 4
2139: NOT
2140: IFFALSE 2144
// exit ;
2142: GO 2431
// DialogPowellsAttack ;
2144: CALL 9543 0 0
// powellAttackGroup := attackers ;
2148: LD_ADDR_EXP 12
2152: PUSH
2153: LD_VAR 0 4
2157: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
2158: LD_ADDR_EXP 42
2162: PUSH
2163: LD_EXP 42
2167: PPUSH
2168: LD_VAR 0 2
2172: PPUSH
2173: LD_EXP 42
2177: PUSH
2178: LD_VAR 0 2
2182: ARRAY
2183: PUSH
2184: LD_VAR 0 4
2188: DIFF
2189: PPUSH
2190: CALL_OW 1
2194: ST_TO_ADDR
// if sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 4 ] ) then
2195: LD_EXP 9
2199: PUSH
2200: LD_INT 16
2202: PPUSH
2203: LD_INT 81
2205: PUSH
2206: LD_INT 4
2208: PUSH
2209: EMPTY
2210: LIST
2211: LIST
2212: PPUSH
2213: CALL_OW 70
2217: AND
2218: IFFALSE 2237
// ComAgressiveMove ( attackers , 135 , 21 ) else
2220: LD_VAR 0 4
2224: PPUSH
2225: LD_INT 135
2227: PPUSH
2228: LD_INT 21
2230: PPUSH
2231: CALL_OW 114
2235: GO 2252
// ComAgressiveMove ( attackers , 146 , 103 ) ;
2237: LD_VAR 0 4
2241: PPUSH
2242: LD_INT 146
2244: PPUSH
2245: LD_INT 103
2247: PPUSH
2248: CALL_OW 114
// wait ( 0 0$5 ) ;
2252: LD_INT 175
2254: PPUSH
2255: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
2259: LD_INT 35
2261: PPUSH
2262: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
2266: LD_VAR 0 4
2270: PPUSH
2271: LD_INT 60
2273: PUSH
2274: EMPTY
2275: LIST
2276: PPUSH
2277: CALL_OW 72
2281: NOT
2282: IFFALSE 2259
// if FilterAllUnits ( [ f_side , 3 ] ) then
2284: LD_INT 22
2286: PUSH
2287: LD_INT 3
2289: PUSH
2290: EMPTY
2291: LIST
2292: LIST
2293: PPUSH
2294: CALL_OW 69
2298: IFFALSE 2317
// ComAgressiveMove ( attackers , 102 , 116 ) else
2300: LD_VAR 0 4
2304: PPUSH
2305: LD_INT 102
2307: PPUSH
2308: LD_INT 116
2310: PPUSH
2311: CALL_OW 114
2315: GO 2332
// ComAgressiveMove ( attackers , 66 , 41 ) ;
2317: LD_VAR 0 4
2321: PPUSH
2322: LD_INT 66
2324: PPUSH
2325: LD_INT 41
2327: PPUSH
2328: CALL_OW 114
// wait ( 0 0$10 ) ;
2332: LD_INT 350
2334: PPUSH
2335: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
2339: LD_INT 35
2341: PPUSH
2342: CALL_OW 67
// for i in attackers do
2346: LD_ADDR_VAR 0 1
2350: PUSH
2351: LD_VAR 0 4
2355: PUSH
2356: FOR_IN
2357: IFFALSE 2407
// if not HasTask ( i ) then
2359: LD_VAR 0 1
2363: PPUSH
2364: CALL_OW 314
2368: NOT
2369: IFFALSE 2405
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) ;
2371: LD_VAR 0 1
2375: PPUSH
2376: LD_INT 81
2378: PUSH
2379: LD_INT 4
2381: PUSH
2382: EMPTY
2383: LIST
2384: LIST
2385: PPUSH
2386: CALL_OW 69
2390: PPUSH
2391: LD_VAR 0 1
2395: PPUSH
2396: CALL_OW 74
2400: PPUSH
2401: CALL_OW 115
2405: GO 2356
2407: POP
2408: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
2409: LD_VAR 0 4
2413: PPUSH
2414: LD_INT 50
2416: PUSH
2417: EMPTY
2418: LIST
2419: PPUSH
2420: CALL_OW 72
2424: NOT
2425: IFFALSE 2339
// DialogPowellsAttackFailed ;
2427: CALL 9808 0 0
// end ;
2431: PPOPN 5
2433: END
// every 0 0$2 do var vehicles , mechs , i ;
2434: GO 2436
2436: DISABLE
2437: LD_INT 0
2439: PPUSH
2440: PPUSH
2441: PPUSH
// begin enable ;
2442: ENABLE
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] , [ f_distxy , 191 , 140 , 10 ] ] ) ;
2443: LD_ADDR_VAR 0 1
2447: PUSH
2448: LD_INT 22
2450: PUSH
2451: LD_INT 1
2453: PUSH
2454: EMPTY
2455: LIST
2456: LIST
2457: PUSH
2458: LD_INT 21
2460: PUSH
2461: LD_INT 2
2463: PUSH
2464: EMPTY
2465: LIST
2466: LIST
2467: PUSH
2468: LD_INT 3
2470: PUSH
2471: LD_INT 24
2473: PUSH
2474: LD_INT 1000
2476: PUSH
2477: EMPTY
2478: LIST
2479: LIST
2480: PUSH
2481: EMPTY
2482: LIST
2483: LIST
2484: PUSH
2485: LD_INT 92
2487: PUSH
2488: LD_INT 191
2490: PUSH
2491: LD_INT 140
2493: PUSH
2494: LD_INT 10
2496: PUSH
2497: EMPTY
2498: LIST
2499: LIST
2500: LIST
2501: LIST
2502: PUSH
2503: EMPTY
2504: LIST
2505: LIST
2506: LIST
2507: LIST
2508: PPUSH
2509: CALL_OW 69
2513: ST_TO_ADDR
// mechs := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 3 ] ] ) ;
2514: LD_ADDR_VAR 0 2
2518: PUSH
2519: LD_INT 22
2521: PUSH
2522: LD_INT 4
2524: PUSH
2525: EMPTY
2526: LIST
2527: LIST
2528: PUSH
2529: LD_INT 25
2531: PUSH
2532: LD_INT 3
2534: PUSH
2535: EMPTY
2536: LIST
2537: LIST
2538: PUSH
2539: EMPTY
2540: LIST
2541: LIST
2542: PPUSH
2543: CALL_OW 69
2547: ST_TO_ADDR
// if not mechs then
2548: LD_VAR 0 2
2552: NOT
2553: IFFALSE 2557
// exit ;
2555: GO 2731
// if mc_remote_driver [ 1 ] then
2557: LD_EXP 63
2561: PUSH
2562: LD_INT 1
2564: ARRAY
2565: IFFALSE 2587
// mechs := mechs diff mc_remote_driver [ 1 ] ;
2567: LD_ADDR_VAR 0 2
2571: PUSH
2572: LD_VAR 0 2
2576: PUSH
2577: LD_EXP 63
2581: PUSH
2582: LD_INT 1
2584: ARRAY
2585: DIFF
2586: ST_TO_ADDR
// if not mechs then
2587: LD_VAR 0 2
2591: NOT
2592: IFFALSE 2596
// exit ;
2594: GO 2731
// if vehicles then
2596: LD_VAR 0 1
2600: IFFALSE 2688
// begin for i in mechs do
2602: LD_ADDR_VAR 0 3
2606: PUSH
2607: LD_VAR 0 2
2611: PUSH
2612: FOR_IN
2613: IFFALSE 2684
// begin if GetTag ( i ) <> 120 then
2615: LD_VAR 0 3
2619: PPUSH
2620: CALL_OW 110
2624: PUSH
2625: LD_INT 120
2627: NONEQUAL
2628: IFFALSE 2642
// SetTag ( i , 120 ) ;
2630: LD_VAR 0 3
2634: PPUSH
2635: LD_INT 120
2637: PPUSH
2638: CALL_OW 109
// if IsInUnit ( i ) then
2642: LD_VAR 0 3
2646: PPUSH
2647: CALL_OW 310
2651: IFFALSE 2664
// ComExitBuilding ( i ) else
2653: LD_VAR 0 3
2657: PPUSH
2658: CALL_OW 122
2662: GO 2682
// ComRepairVehicle ( i , vehicles [ 1 ] ) ;
2664: LD_VAR 0 3
2668: PPUSH
2669: LD_VAR 0 1
2673: PUSH
2674: LD_INT 1
2676: ARRAY
2677: PPUSH
2678: CALL_OW 129
// end ;
2682: GO 2612
2684: POP
2685: POP
// end else
2686: GO 2731
// if FilterByTag ( mechs , 120 ) then
2688: LD_VAR 0 2
2692: PPUSH
2693: LD_INT 120
2695: PPUSH
2696: CALL 45996 0 2
2700: IFFALSE 2731
// begin for i in mechs do
2702: LD_ADDR_VAR 0 3
2706: PUSH
2707: LD_VAR 0 2
2711: PUSH
2712: FOR_IN
2713: IFFALSE 2729
// begin SetTag ( i , 0 ) ;
2715: LD_VAR 0 3
2719: PPUSH
2720: LD_INT 0
2722: PPUSH
2723: CALL_OW 109
// end ;
2727: GO 2712
2729: POP
2730: POP
// end ; end ;
2731: PPOPN 3
2733: END
// every 0 0$2 do var people , sci , i ;
2734: GO 2736
2736: DISABLE
2737: LD_INT 0
2739: PPUSH
2740: PPUSH
2741: PPUSH
// begin enable ;
2742: ENABLE
// people := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] , [ f_distxy , 188 , 112 , 10 ] ] ) ;
2743: LD_ADDR_VAR 0 1
2747: PUSH
2748: LD_INT 22
2750: PUSH
2751: LD_INT 1
2753: PUSH
2754: EMPTY
2755: LIST
2756: LIST
2757: PUSH
2758: LD_INT 21
2760: PUSH
2761: LD_INT 1
2763: PUSH
2764: EMPTY
2765: LIST
2766: LIST
2767: PUSH
2768: LD_INT 3
2770: PUSH
2771: LD_INT 24
2773: PUSH
2774: LD_INT 1000
2776: PUSH
2777: EMPTY
2778: LIST
2779: LIST
2780: PUSH
2781: EMPTY
2782: LIST
2783: LIST
2784: PUSH
2785: LD_INT 92
2787: PUSH
2788: LD_INT 188
2790: PUSH
2791: LD_INT 112
2793: PUSH
2794: LD_INT 10
2796: PUSH
2797: EMPTY
2798: LIST
2799: LIST
2800: LIST
2801: LIST
2802: PUSH
2803: EMPTY
2804: LIST
2805: LIST
2806: LIST
2807: LIST
2808: PPUSH
2809: CALL_OW 69
2813: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 4 ] ] ) ;
2814: LD_ADDR_VAR 0 2
2818: PUSH
2819: LD_INT 22
2821: PUSH
2822: LD_INT 4
2824: PUSH
2825: EMPTY
2826: LIST
2827: LIST
2828: PUSH
2829: LD_INT 25
2831: PUSH
2832: LD_INT 4
2834: PUSH
2835: EMPTY
2836: LIST
2837: LIST
2838: PUSH
2839: EMPTY
2840: LIST
2841: LIST
2842: PPUSH
2843: CALL_OW 69
2847: ST_TO_ADDR
// if not sci then
2848: LD_VAR 0 2
2852: NOT
2853: IFFALSE 2857
// exit ;
2855: GO 2992
// if people then
2857: LD_VAR 0 1
2861: IFFALSE 2949
// begin for i in sci do
2863: LD_ADDR_VAR 0 3
2867: PUSH
2868: LD_VAR 0 2
2872: PUSH
2873: FOR_IN
2874: IFFALSE 2945
// begin if GetTag ( i ) <> 102 then
2876: LD_VAR 0 3
2880: PPUSH
2881: CALL_OW 110
2885: PUSH
2886: LD_INT 102
2888: NONEQUAL
2889: IFFALSE 2903
// SetTag ( i , 102 ) ;
2891: LD_VAR 0 3
2895: PPUSH
2896: LD_INT 102
2898: PPUSH
2899: CALL_OW 109
// if IsInUnit ( i ) then
2903: LD_VAR 0 3
2907: PPUSH
2908: CALL_OW 310
2912: IFFALSE 2925
// ComExitBuilding ( i ) else
2914: LD_VAR 0 3
2918: PPUSH
2919: CALL_OW 122
2923: GO 2943
// ComHeal ( i , people [ 1 ] ) ;
2925: LD_VAR 0 3
2929: PPUSH
2930: LD_VAR 0 1
2934: PUSH
2935: LD_INT 1
2937: ARRAY
2938: PPUSH
2939: CALL_OW 128
// end ;
2943: GO 2873
2945: POP
2946: POP
// end else
2947: GO 2992
// if FilterByTag ( sci , 102 ) then
2949: LD_VAR 0 2
2953: PPUSH
2954: LD_INT 102
2956: PPUSH
2957: CALL 45996 0 2
2961: IFFALSE 2992
// begin for i in sci do
2963: LD_ADDR_VAR 0 3
2967: PUSH
2968: LD_VAR 0 2
2972: PUSH
2973: FOR_IN
2974: IFFALSE 2990
// begin SetTag ( i , 0 ) ;
2976: LD_VAR 0 3
2980: PPUSH
2981: LD_INT 0
2983: PPUSH
2984: CALL_OW 109
// end ;
2988: GO 2973
2990: POP
2991: POP
// end ; end ;
2992: PPOPN 3
2994: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 4 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
2995: LD_INT 22
2997: PUSH
2998: LD_INT 4
3000: PUSH
3001: EMPTY
3002: LIST
3003: LIST
3004: PUSH
3005: LD_INT 33
3007: PUSH
3008: LD_INT 2
3010: PUSH
3011: EMPTY
3012: LIST
3013: LIST
3014: PUSH
3015: LD_INT 50
3017: PUSH
3018: EMPTY
3019: LIST
3020: PUSH
3021: LD_INT 3
3023: PUSH
3024: LD_INT 61
3026: PUSH
3027: EMPTY
3028: LIST
3029: PUSH
3030: EMPTY
3031: LIST
3032: LIST
3033: PUSH
3034: EMPTY
3035: LIST
3036: LIST
3037: LIST
3038: LIST
3039: PPUSH
3040: CALL_OW 69
3044: IFFALSE 3135
3046: GO 3048
3048: DISABLE
3049: LD_INT 0
3051: PPUSH
3052: PPUSH
// begin enable ;
3053: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
3054: LD_ADDR_VAR 0 2
3058: PUSH
3059: LD_INT 22
3061: PUSH
3062: LD_INT 4
3064: PUSH
3065: EMPTY
3066: LIST
3067: LIST
3068: PUSH
3069: LD_INT 33
3071: PUSH
3072: LD_INT 2
3074: PUSH
3075: EMPTY
3076: LIST
3077: LIST
3078: PUSH
3079: LD_INT 50
3081: PUSH
3082: EMPTY
3083: LIST
3084: PUSH
3085: LD_INT 3
3087: PUSH
3088: LD_INT 61
3090: PUSH
3091: EMPTY
3092: LIST
3093: PUSH
3094: EMPTY
3095: LIST
3096: LIST
3097: PUSH
3098: EMPTY
3099: LIST
3100: LIST
3101: LIST
3102: LIST
3103: PPUSH
3104: CALL_OW 69
3108: ST_TO_ADDR
// for i in tmp do
3109: LD_ADDR_VAR 0 1
3113: PUSH
3114: LD_VAR 0 2
3118: PUSH
3119: FOR_IN
3120: IFFALSE 3133
// Connect ( i ) ;
3122: LD_VAR 0 1
3126: PPUSH
3127: CALL 19079 0 1
3131: GO 3119
3133: POP
3134: POP
// end ; end_of_file
3135: PPOPN 2
3137: END
// export Gensher , gensher_side , gensherAttackGroup ; export function PrepareGensher ; var i , b , tmp , un , list ; begin
3138: LD_INT 0
3140: PPUSH
3141: PPUSH
3142: PPUSH
3143: PPUSH
3144: PPUSH
3145: PPUSH
// gensher_side := 2 ;
3146: LD_ADDR_EXP 14
3150: PUSH
3151: LD_INT 2
3153: ST_TO_ADDR
// uc_side := gensher_side ;
3154: LD_ADDR_OWVAR 20
3158: PUSH
3159: LD_EXP 14
3163: ST_TO_ADDR
// uc_nation := 2 ;
3164: LD_ADDR_OWVAR 21
3168: PUSH
3169: LD_INT 2
3171: ST_TO_ADDR
// list := [ [ b_barracks , 42 , 29 , 5 ] , [ b_barracks , 36 , 40 , 5 ] , [ b_lab , 13 , 18 , 1 , b_lab_weapon , b_lab_opto ] , [ b_solar_power , 17 , 3 , 0 ] , [ b_oil_mine , 56 , 23 , 0 ] , [ b_factory , 11 , 7 , 2 ] , [ b_solar_power , 20 , 3 , 0 ] , [ b_solar_power , 23 , 3 , 0 ] , [ b_solar_power , 26 , 3 , 0 ] , [ b_lab , 17 , 27 , 1 , b_lab_biological , b_lab_siberium ] , [ b_bunker , 27 , 44 , 5 , ar_gun ] , [ b_bunker , 41 , 41 , 5 , ar_gun ] , [ b_bunker , 45 , 24 , 5 , ar_rocket_launcher ] , [ b_bunker , 48 , 19 , 5 , ar_rocket_launcher ] , [ b_bunker , 41 , 3 , 4 , ar_rocket_launcher ] , [ b_barracks , 44 , 9 , 4 ] , [ b_siberite_mine , 52 , 40 , 3 ] ] ;
3172: LD_ADDR_VAR 0 6
3176: PUSH
3177: LD_INT 5
3179: PUSH
3180: LD_INT 42
3182: PUSH
3183: LD_INT 29
3185: PUSH
3186: LD_INT 5
3188: PUSH
3189: EMPTY
3190: LIST
3191: LIST
3192: LIST
3193: LIST
3194: PUSH
3195: LD_INT 5
3197: PUSH
3198: LD_INT 36
3200: PUSH
3201: LD_INT 40
3203: PUSH
3204: LD_INT 5
3206: PUSH
3207: EMPTY
3208: LIST
3209: LIST
3210: LIST
3211: LIST
3212: PUSH
3213: LD_INT 6
3215: PUSH
3216: LD_INT 13
3218: PUSH
3219: LD_INT 18
3221: PUSH
3222: LD_INT 1
3224: PUSH
3225: LD_INT 10
3227: PUSH
3228: LD_INT 15
3230: PUSH
3231: EMPTY
3232: LIST
3233: LIST
3234: LIST
3235: LIST
3236: LIST
3237: LIST
3238: PUSH
3239: LD_INT 27
3241: PUSH
3242: LD_INT 17
3244: PUSH
3245: LD_INT 3
3247: PUSH
3248: LD_INT 0
3250: PUSH
3251: EMPTY
3252: LIST
3253: LIST
3254: LIST
3255: LIST
3256: PUSH
3257: LD_INT 29
3259: PUSH
3260: LD_INT 56
3262: PUSH
3263: LD_INT 23
3265: PUSH
3266: LD_INT 0
3268: PUSH
3269: EMPTY
3270: LIST
3271: LIST
3272: LIST
3273: LIST
3274: PUSH
3275: LD_INT 3
3277: PUSH
3278: LD_INT 11
3280: PUSH
3281: LD_INT 7
3283: PUSH
3284: LD_INT 2
3286: PUSH
3287: EMPTY
3288: LIST
3289: LIST
3290: LIST
3291: LIST
3292: PUSH
3293: LD_INT 27
3295: PUSH
3296: LD_INT 20
3298: PUSH
3299: LD_INT 3
3301: PUSH
3302: LD_INT 0
3304: PUSH
3305: EMPTY
3306: LIST
3307: LIST
3308: LIST
3309: LIST
3310: PUSH
3311: LD_INT 27
3313: PUSH
3314: LD_INT 23
3316: PUSH
3317: LD_INT 3
3319: PUSH
3320: LD_INT 0
3322: PUSH
3323: EMPTY
3324: LIST
3325: LIST
3326: LIST
3327: LIST
3328: PUSH
3329: LD_INT 27
3331: PUSH
3332: LD_INT 26
3334: PUSH
3335: LD_INT 3
3337: PUSH
3338: LD_INT 0
3340: PUSH
3341: EMPTY
3342: LIST
3343: LIST
3344: LIST
3345: LIST
3346: PUSH
3347: LD_INT 6
3349: PUSH
3350: LD_INT 17
3352: PUSH
3353: LD_INT 27
3355: PUSH
3356: LD_INT 1
3358: PUSH
3359: LD_INT 13
3361: PUSH
3362: LD_INT 11
3364: PUSH
3365: EMPTY
3366: LIST
3367: LIST
3368: LIST
3369: LIST
3370: LIST
3371: LIST
3372: PUSH
3373: LD_INT 32
3375: PUSH
3376: LD_INT 27
3378: PUSH
3379: LD_INT 44
3381: PUSH
3382: LD_INT 5
3384: PUSH
3385: LD_INT 27
3387: PUSH
3388: EMPTY
3389: LIST
3390: LIST
3391: LIST
3392: LIST
3393: LIST
3394: PUSH
3395: LD_INT 32
3397: PUSH
3398: LD_INT 41
3400: PUSH
3401: LD_INT 41
3403: PUSH
3404: LD_INT 5
3406: PUSH
3407: LD_INT 27
3409: PUSH
3410: EMPTY
3411: LIST
3412: LIST
3413: LIST
3414: LIST
3415: LIST
3416: PUSH
3417: LD_INT 32
3419: PUSH
3420: LD_INT 45
3422: PUSH
3423: LD_INT 24
3425: PUSH
3426: LD_INT 5
3428: PUSH
3429: LD_INT 28
3431: PUSH
3432: EMPTY
3433: LIST
3434: LIST
3435: LIST
3436: LIST
3437: LIST
3438: PUSH
3439: LD_INT 32
3441: PUSH
3442: LD_INT 48
3444: PUSH
3445: LD_INT 19
3447: PUSH
3448: LD_INT 5
3450: PUSH
3451: LD_INT 28
3453: PUSH
3454: EMPTY
3455: LIST
3456: LIST
3457: LIST
3458: LIST
3459: LIST
3460: PUSH
3461: LD_INT 32
3463: PUSH
3464: LD_INT 41
3466: PUSH
3467: LD_INT 3
3469: PUSH
3470: LD_INT 4
3472: PUSH
3473: LD_INT 28
3475: PUSH
3476: EMPTY
3477: LIST
3478: LIST
3479: LIST
3480: LIST
3481: LIST
3482: PUSH
3483: LD_INT 5
3485: PUSH
3486: LD_INT 44
3488: PUSH
3489: LD_INT 9
3491: PUSH
3492: LD_INT 4
3494: PUSH
3495: EMPTY
3496: LIST
3497: LIST
3498: LIST
3499: LIST
3500: PUSH
3501: LD_INT 30
3503: PUSH
3504: LD_INT 52
3506: PUSH
3507: LD_INT 40
3509: PUSH
3510: LD_INT 3
3512: PUSH
3513: EMPTY
3514: LIST
3515: LIST
3516: LIST
3517: LIST
3518: PUSH
3519: EMPTY
3520: LIST
3521: LIST
3522: LIST
3523: LIST
3524: LIST
3525: LIST
3526: LIST
3527: LIST
3528: LIST
3529: LIST
3530: LIST
3531: LIST
3532: LIST
3533: LIST
3534: LIST
3535: LIST
3536: LIST
3537: ST_TO_ADDR
// for i in list do
3538: LD_ADDR_VAR 0 2
3542: PUSH
3543: LD_VAR 0 6
3547: PUSH
3548: FOR_IN
3549: IFFALSE 3713
// begin uc_side := 2 ;
3551: LD_ADDR_OWVAR 20
3555: PUSH
3556: LD_INT 2
3558: ST_TO_ADDR
// uc_nation := 2 ;
3559: LD_ADDR_OWVAR 21
3563: PUSH
3564: LD_INT 2
3566: ST_TO_ADDR
// InitBc ;
3567: CALL_OW 21
// bc_type := i [ 1 ] ;
3571: LD_ADDR_OWVAR 42
3575: PUSH
3576: LD_VAR 0 2
3580: PUSH
3581: LD_INT 1
3583: ARRAY
3584: ST_TO_ADDR
// if i [ 1 ] = b_lab then
3585: LD_VAR 0 2
3589: PUSH
3590: LD_INT 1
3592: ARRAY
3593: PUSH
3594: LD_INT 6
3596: EQUAL
3597: IFFALSE 3635
// begin bc_type := b_lab_full ;
3599: LD_ADDR_OWVAR 42
3603: PUSH
3604: LD_INT 8
3606: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
3607: LD_ADDR_OWVAR 44
3611: PUSH
3612: LD_VAR 0 2
3616: PUSH
3617: LD_INT 5
3619: ARRAY
3620: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
3621: LD_ADDR_OWVAR 45
3625: PUSH
3626: LD_VAR 0 2
3630: PUSH
3631: LD_INT 6
3633: ARRAY
3634: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
3635: LD_ADDR_VAR 0 3
3639: PUSH
3640: LD_VAR 0 2
3644: PUSH
3645: LD_INT 2
3647: ARRAY
3648: PPUSH
3649: LD_VAR 0 2
3653: PUSH
3654: LD_INT 3
3656: ARRAY
3657: PPUSH
3658: LD_VAR 0 2
3662: PUSH
3663: LD_INT 4
3665: ARRAY
3666: PPUSH
3667: CALL_OW 47
3671: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
3672: LD_VAR 0 2
3676: PUSH
3677: LD_INT 1
3679: ARRAY
3680: PUSH
3681: LD_INT 33
3683: PUSH
3684: LD_INT 32
3686: PUSH
3687: EMPTY
3688: LIST
3689: LIST
3690: IN
3691: IFFALSE 3711
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
3693: LD_VAR 0 3
3697: PPUSH
3698: LD_VAR 0 2
3702: PUSH
3703: LD_INT 5
3705: ARRAY
3706: PPUSH
3707: CALL_OW 431
// end ;
3711: GO 3548
3713: POP
3714: POP
// tmp := PrepareBase ( ar_depot , gensher_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 11500 , 1100 , 60 ] , [ 6 , 6 , 6 , 6 ] ) ;
3715: LD_ADDR_VAR 0 4
3719: PUSH
3720: LD_INT 7
3722: PPUSH
3723: LD_INT 2
3725: PPUSH
3726: LD_STRING 
3728: PPUSH
3729: LD_INT 8
3731: PUSH
3732: LD_INT 7
3734: PUSH
3735: LD_INT 6
3737: PUSH
3738: EMPTY
3739: LIST
3740: LIST
3741: LIST
3742: PUSH
3743: LD_OWVAR 67
3747: ARRAY
3748: PPUSH
3749: LD_INT 11500
3751: PUSH
3752: LD_INT 1100
3754: PUSH
3755: LD_INT 60
3757: PUSH
3758: EMPTY
3759: LIST
3760: LIST
3761: LIST
3762: PPUSH
3763: LD_INT 6
3765: PUSH
3766: LD_INT 6
3768: PUSH
3769: LD_INT 6
3771: PUSH
3772: LD_INT 6
3774: PUSH
3775: EMPTY
3776: LIST
3777: LIST
3778: LIST
3779: LIST
3780: PPUSH
3781: CALL 19432 0 6
3785: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ) ;
3786: LD_ADDR_EXP 23
3790: PUSH
3791: LD_EXP 23
3795: PPUSH
3796: LD_INT 2
3798: PPUSH
3799: LD_VAR 0 4
3803: PUSH
3804: LD_INT 22
3806: PUSH
3807: LD_INT 2
3809: PUSH
3810: EMPTY
3811: LIST
3812: LIST
3813: PUSH
3814: LD_INT 21
3816: PUSH
3817: LD_INT 3
3819: PUSH
3820: EMPTY
3821: LIST
3822: LIST
3823: PUSH
3824: EMPTY
3825: LIST
3826: LIST
3827: PPUSH
3828: CALL_OW 69
3832: UNION
3833: PPUSH
3834: CALL_OW 1
3838: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] ] ) ;
3839: LD_ADDR_VAR 0 4
3843: PUSH
3844: LD_INT 22
3846: PUSH
3847: LD_INT 2
3849: PUSH
3850: EMPTY
3851: LIST
3852: LIST
3853: PUSH
3854: LD_INT 30
3856: PUSH
3857: LD_INT 31
3859: PUSH
3860: EMPTY
3861: LIST
3862: LIST
3863: PUSH
3864: EMPTY
3865: LIST
3866: LIST
3867: PPUSH
3868: CALL_OW 69
3872: ST_TO_ADDR
// for i in tmp do
3873: LD_ADDR_VAR 0 2
3877: PUSH
3878: LD_VAR 0 4
3882: PUSH
3883: FOR_IN
3884: IFFALSE 3954
// begin PrepareHuman ( false , 1 , [ 4 , 3 , 3 ] [ Difficulty ] ) ;
3886: LD_INT 0
3888: PPUSH
3889: LD_INT 1
3891: PPUSH
3892: LD_INT 4
3894: PUSH
3895: LD_INT 3
3897: PUSH
3898: LD_INT 3
3900: PUSH
3901: EMPTY
3902: LIST
3903: LIST
3904: LIST
3905: PUSH
3906: LD_OWVAR 67
3910: ARRAY
3911: PPUSH
3912: CALL_OW 380
// un := CreateHuman ;
3916: LD_ADDR_VAR 0 5
3920: PUSH
3921: CALL_OW 44
3925: ST_TO_ADDR
// SetDir ( un , 1 ) ;
3926: LD_VAR 0 5
3930: PPUSH
3931: LD_INT 1
3933: PPUSH
3934: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3938: LD_VAR 0 5
3942: PPUSH
3943: LD_VAR 0 2
3947: PPUSH
3948: CALL_OW 52
// end ;
3952: GO 3883
3954: POP
3955: POP
// tmp := AreaToList ( gensher_mines , 0 ) ;
3956: LD_ADDR_VAR 0 4
3960: PUSH
3961: LD_INT 15
3963: PPUSH
3964: LD_INT 0
3966: PPUSH
3967: CALL_OW 517
3971: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
3972: LD_ADDR_VAR 0 2
3976: PUSH
3977: DOUBLE
3978: LD_INT 1
3980: DEC
3981: ST_TO_ADDR
3982: LD_VAR 0 4
3986: PUSH
3987: LD_INT 1
3989: ARRAY
3990: PUSH
3991: FOR_TO
3992: IFFALSE 4094
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
3994: LD_VAR 0 4
3998: PUSH
3999: LD_INT 1
4001: ARRAY
4002: PUSH
4003: LD_VAR 0 2
4007: ARRAY
4008: PPUSH
4009: LD_VAR 0 4
4013: PUSH
4014: LD_INT 2
4016: ARRAY
4017: PUSH
4018: LD_VAR 0 2
4022: ARRAY
4023: PPUSH
4024: LD_INT 2
4026: PPUSH
4027: LD_INT 0
4029: PPUSH
4030: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
4034: LD_ADDR_EXP 3
4038: PUSH
4039: LD_EXP 3
4043: PPUSH
4044: LD_EXP 3
4048: PUSH
4049: LD_INT 1
4051: PLUS
4052: PPUSH
4053: LD_VAR 0 4
4057: PUSH
4058: LD_INT 1
4060: ARRAY
4061: PUSH
4062: LD_VAR 0 2
4066: ARRAY
4067: PUSH
4068: LD_VAR 0 4
4072: PUSH
4073: LD_INT 2
4075: ARRAY
4076: PUSH
4077: LD_VAR 0 2
4081: ARRAY
4082: PUSH
4083: EMPTY
4084: LIST
4085: LIST
4086: PPUSH
4087: CALL_OW 2
4091: ST_TO_ADDR
// end ;
4092: GO 3991
4094: POP
4095: POP
// if Difficulty > 1 then
4096: LD_OWVAR 67
4100: PUSH
4101: LD_INT 1
4103: GREATER
4104: IFFALSE 4246
// begin tmp := AreaToList ( gensher_mines2 , 0 ) ;
4106: LD_ADDR_VAR 0 4
4110: PUSH
4111: LD_INT 19
4113: PPUSH
4114: LD_INT 0
4116: PPUSH
4117: CALL_OW 517
4121: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
4122: LD_ADDR_VAR 0 2
4126: PUSH
4127: DOUBLE
4128: LD_INT 1
4130: DEC
4131: ST_TO_ADDR
4132: LD_VAR 0 4
4136: PUSH
4137: LD_INT 1
4139: ARRAY
4140: PUSH
4141: FOR_TO
4142: IFFALSE 4244
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
4144: LD_VAR 0 4
4148: PUSH
4149: LD_INT 1
4151: ARRAY
4152: PUSH
4153: LD_VAR 0 2
4157: ARRAY
4158: PPUSH
4159: LD_VAR 0 4
4163: PUSH
4164: LD_INT 2
4166: ARRAY
4167: PUSH
4168: LD_VAR 0 2
4172: ARRAY
4173: PPUSH
4174: LD_INT 2
4176: PPUSH
4177: LD_INT 0
4179: PPUSH
4180: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
4184: LD_ADDR_EXP 3
4188: PUSH
4189: LD_EXP 3
4193: PPUSH
4194: LD_EXP 3
4198: PUSH
4199: LD_INT 1
4201: PLUS
4202: PPUSH
4203: LD_VAR 0 4
4207: PUSH
4208: LD_INT 1
4210: ARRAY
4211: PUSH
4212: LD_VAR 0 2
4216: ARRAY
4217: PUSH
4218: LD_VAR 0 4
4222: PUSH
4223: LD_INT 2
4225: ARRAY
4226: PUSH
4227: LD_VAR 0 2
4231: ARRAY
4232: PUSH
4233: EMPTY
4234: LIST
4235: LIST
4236: PPUSH
4237: CALL_OW 2
4241: ST_TO_ADDR
// end ;
4242: GO 4141
4244: POP
4245: POP
// end ; gensherAttackGroup := [ ] ;
4246: LD_ADDR_EXP 15
4250: PUSH
4251: EMPTY
4252: ST_TO_ADDR
// end ;
4253: LD_VAR 0 1
4257: RET
// export function InitMC_Gensher ( ) ; begin
4258: LD_INT 0
4260: PPUSH
// MC_SetScanArea ( 2 , gensher_base ) ;
4261: LD_INT 2
4263: PPUSH
4264: LD_INT 2
4266: PPUSH
4267: CALL 77915 0 2
// MC_SetParkingArea ( 2 , gensher_parking ) ;
4271: LD_INT 2
4273: PPUSH
4274: LD_INT 9
4276: PPUSH
4277: CALL 77859 0 2
// MC_SetDepositsXY ( 2 , [ [ 56 , 23 , 0 ] , [ 52 , 40 , 1 ] ] ) ;
4281: LD_INT 2
4283: PPUSH
4284: LD_INT 56
4286: PUSH
4287: LD_INT 23
4289: PUSH
4290: LD_INT 0
4292: PUSH
4293: EMPTY
4294: LIST
4295: LIST
4296: LIST
4297: PUSH
4298: LD_INT 52
4300: PUSH
4301: LD_INT 40
4303: PUSH
4304: LD_INT 1
4306: PUSH
4307: EMPTY
4308: LIST
4309: LIST
4310: LIST
4311: PUSH
4312: EMPTY
4313: LIST
4314: LIST
4315: PPUSH
4316: CALL 76918 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ar_gun , ar_rocket_launcher ] ) ;
4320: LD_INT 2
4322: PPUSH
4323: LD_INT 27
4325: PUSH
4326: LD_INT 28
4328: PUSH
4329: EMPTY
4330: LIST
4331: LIST
4332: PPUSH
4333: CALL 77747 0 2
// MC_SetCratesArea ( 2 , gensher_crates ) ;
4337: LD_INT 2
4339: PPUSH
4340: LD_INT 8
4342: PPUSH
4343: CALL 77429 0 2
// MC_SetTame ( 2 , gensher_ape ) ;
4347: LD_INT 2
4349: PPUSH
4350: LD_INT 7
4352: PPUSH
4353: CALL 77160 0 2
// MC_SetDefenderLimit ( 2 , 4 ) ;
4357: LD_INT 2
4359: PPUSH
4360: LD_INT 4
4362: PPUSH
4363: CALL 76779 0 2
// MC_SetProduceList ( 2 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ) ;
4367: LD_INT 2
4369: PPUSH
4370: LD_INT 13
4372: PUSH
4373: LD_INT 2
4375: PUSH
4376: LD_INT 1
4378: PUSH
4379: LD_INT 31
4381: PUSH
4382: EMPTY
4383: LIST
4384: LIST
4385: LIST
4386: LIST
4387: PUSH
4388: LD_INT 13
4390: PUSH
4391: LD_INT 2
4393: PUSH
4394: LD_INT 1
4396: PUSH
4397: LD_INT 31
4399: PUSH
4400: EMPTY
4401: LIST
4402: LIST
4403: LIST
4404: LIST
4405: PUSH
4406: LD_INT 14
4408: PUSH
4409: LD_INT 1
4411: PUSH
4412: LD_INT 2
4414: PUSH
4415: LD_INT 27
4417: PUSH
4418: EMPTY
4419: LIST
4420: LIST
4421: LIST
4422: LIST
4423: PUSH
4424: LD_INT 14
4426: PUSH
4427: LD_INT 1
4429: PUSH
4430: LD_INT 2
4432: PUSH
4433: LD_INT 27
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: LIST
4440: LIST
4441: PUSH
4442: LD_INT 14
4444: PUSH
4445: LD_INT 1
4447: PUSH
4448: LD_INT 2
4450: PUSH
4451: LD_INT 28
4453: PUSH
4454: EMPTY
4455: LIST
4456: LIST
4457: LIST
4458: LIST
4459: PUSH
4460: LD_INT 14
4462: PUSH
4463: LD_INT 1
4465: PUSH
4466: LD_INT 2
4468: PUSH
4469: LD_INT 26
4471: PUSH
4472: EMPTY
4473: LIST
4474: LIST
4475: LIST
4476: LIST
4477: PUSH
4478: EMPTY
4479: LIST
4480: LIST
4481: LIST
4482: LIST
4483: LIST
4484: LIST
4485: PPUSH
4486: CALL 76594 0 2
// MC_SetFactoryExtension ( 2 , 11 , 7 , 2 , [ b_ext_stitch , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
4490: LD_INT 2
4492: PPUSH
4493: LD_INT 11
4495: PPUSH
4496: LD_INT 7
4498: PPUSH
4499: LD_INT 2
4501: PPUSH
4502: LD_INT 23
4504: PUSH
4505: LD_INT 16
4507: PUSH
4508: LD_INT 17
4510: PUSH
4511: LD_INT 18
4513: PUSH
4514: LD_INT 22
4516: PUSH
4517: EMPTY
4518: LIST
4519: LIST
4520: LIST
4521: LIST
4522: LIST
4523: PPUSH
4524: CALL 77541 0 5
// end ;
4528: LD_VAR 0 1
4532: RET
// every 2 trigger staticMines and FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) do var i , j , tmp , x , y ;
4533: LD_EXP 3
4537: PUSH
4538: LD_INT 15
4540: PPUSH
4541: LD_INT 81
4543: PUSH
4544: LD_INT 2
4546: PUSH
4547: EMPTY
4548: LIST
4549: LIST
4550: PPUSH
4551: CALL_OW 70
4555: AND
4556: IFFALSE 4769
4558: GO 4560
4560: DISABLE
4561: LD_INT 0
4563: PPUSH
4564: PPUSH
4565: PPUSH
4566: PPUSH
4567: PPUSH
// begin enable ;
4568: ENABLE
// tmp := FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) ;
4569: LD_ADDR_VAR 0 3
4573: PUSH
4574: LD_INT 15
4576: PPUSH
4577: LD_INT 81
4579: PUSH
4580: LD_INT 2
4582: PUSH
4583: EMPTY
4584: LIST
4585: LIST
4586: PPUSH
4587: CALL_OW 70
4591: ST_TO_ADDR
// if not tmp then
4592: LD_VAR 0 3
4596: NOT
4597: IFFALSE 4601
// exit ;
4599: GO 4769
// for i in tmp do
4601: LD_ADDR_VAR 0 1
4605: PUSH
4606: LD_VAR 0 3
4610: PUSH
4611: FOR_IN
4612: IFFALSE 4767
// begin x := GetX ( i ) ;
4614: LD_ADDR_VAR 0 4
4618: PUSH
4619: LD_VAR 0 1
4623: PPUSH
4624: CALL_OW 250
4628: ST_TO_ADDR
// y := GetY ( i ) ;
4629: LD_ADDR_VAR 0 5
4633: PUSH
4634: LD_VAR 0 1
4638: PPUSH
4639: CALL_OW 251
4643: ST_TO_ADDR
// if MineAtPos ( x , y ) then
4644: LD_VAR 0 4
4648: PPUSH
4649: LD_VAR 0 5
4653: PPUSH
4654: CALL_OW 458
4658: IFFALSE 4765
// begin LaunchMineAtPos ( x , y , 2 ) ;
4660: LD_VAR 0 4
4664: PPUSH
4665: LD_VAR 0 5
4669: PPUSH
4670: LD_INT 2
4672: PPUSH
4673: CALL_OW 456
// for j = 1 to staticMines do
4677: LD_ADDR_VAR 0 2
4681: PUSH
4682: DOUBLE
4683: LD_INT 1
4685: DEC
4686: ST_TO_ADDR
4687: LD_EXP 3
4691: PUSH
4692: FOR_TO
4693: IFFALSE 4763
// if staticMines [ j ] [ 1 ] = x and staticMines [ j ] [ 2 ] = y then
4695: LD_EXP 3
4699: PUSH
4700: LD_VAR 0 2
4704: ARRAY
4705: PUSH
4706: LD_INT 1
4708: ARRAY
4709: PUSH
4710: LD_VAR 0 4
4714: EQUAL
4715: PUSH
4716: LD_EXP 3
4720: PUSH
4721: LD_VAR 0 2
4725: ARRAY
4726: PUSH
4727: LD_INT 2
4729: ARRAY
4730: PUSH
4731: LD_VAR 0 5
4735: EQUAL
4736: AND
4737: IFFALSE 4761
// begin staticMines := Delete ( staticMines , j ) ;
4739: LD_ADDR_EXP 3
4743: PUSH
4744: LD_EXP 3
4748: PPUSH
4749: LD_VAR 0 2
4753: PPUSH
4754: CALL_OW 3
4758: ST_TO_ADDR
// break ;
4759: GO 4763
// end ;
4761: GO 4692
4763: POP
4764: POP
// end ; end ;
4765: GO 4611
4767: POP
4768: POP
// end ;
4769: PPOPN 5
4771: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ar_depot ) and not arDestroyed do var i , base , tmp , attackers , amount ;
4772: LD_INT 7
4774: PPUSH
4775: CALL_OW 302
4779: PUSH
4780: LD_EXP 4
4784: NOT
4785: AND
4786: IFFALSE 5386
4788: GO 4790
4790: DISABLE
4791: LD_INT 0
4793: PPUSH
4794: PPUSH
4795: PPUSH
4796: PPUSH
4797: PPUSH
// begin enable ;
4798: ENABLE
// base := 2 ;
4799: LD_ADDR_VAR 0 2
4803: PUSH
4804: LD_INT 2
4806: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_mortar ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ;
4807: LD_ADDR_VAR 0 3
4811: PUSH
4812: LD_INT 14
4814: PUSH
4815: LD_INT 1
4817: PUSH
4818: LD_INT 2
4820: PUSH
4821: LD_INT 27
4823: PUSH
4824: EMPTY
4825: LIST
4826: LIST
4827: LIST
4828: LIST
4829: PUSH
4830: LD_INT 14
4832: PUSH
4833: LD_INT 1
4835: PUSH
4836: LD_INT 2
4838: PUSH
4839: LD_INT 27
4841: PUSH
4842: EMPTY
4843: LIST
4844: LIST
4845: LIST
4846: LIST
4847: PUSH
4848: LD_INT 14
4850: PUSH
4851: LD_INT 1
4853: PUSH
4854: LD_INT 2
4856: PUSH
4857: LD_INT 92
4859: PUSH
4860: EMPTY
4861: LIST
4862: LIST
4863: LIST
4864: LIST
4865: PUSH
4866: LD_INT 14
4868: PUSH
4869: LD_INT 1
4871: PUSH
4872: LD_INT 2
4874: PUSH
4875: LD_INT 26
4877: PUSH
4878: EMPTY
4879: LIST
4880: LIST
4881: LIST
4882: LIST
4883: PUSH
4884: EMPTY
4885: LIST
4886: LIST
4887: LIST
4888: LIST
4889: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
4890: LD_ADDR_VAR 0 5
4894: PUSH
4895: LD_VAR 0 5
4899: PUSH
4900: LD_OWVAR 1
4904: PUSH
4905: LD_INT 21000
4907: DIV
4908: PLUS
4909: ST_TO_ADDR
// if amount > 8 then
4910: LD_VAR 0 5
4914: PUSH
4915: LD_INT 8
4917: GREATER
4918: IFFALSE 4928
// amount := 8 ;
4920: LD_ADDR_VAR 0 5
4924: PUSH
4925: LD_INT 8
4927: ST_TO_ADDR
// for i = 1 to amount do
4928: LD_ADDR_VAR 0 1
4932: PUSH
4933: DOUBLE
4934: LD_INT 1
4936: DEC
4937: ST_TO_ADDR
4938: LD_VAR 0 5
4942: PUSH
4943: FOR_TO
4944: IFFALSE 5032
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_half_tracked , ar_medium_trike ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gatling_gun , ar_gun ] [ rand ( 1 , 3 ) ] ] ) ;
4946: LD_ADDR_VAR 0 3
4950: PUSH
4951: LD_VAR 0 3
4955: PPUSH
4956: LD_VAR 0 3
4960: PUSH
4961: LD_INT 1
4963: PLUS
4964: PPUSH
4965: LD_INT 14
4967: PUSH
4968: LD_INT 13
4970: PUSH
4971: EMPTY
4972: LIST
4973: LIST
4974: PUSH
4975: LD_INT 1
4977: PPUSH
4978: LD_INT 2
4980: PPUSH
4981: CALL_OW 12
4985: ARRAY
4986: PUSH
4987: LD_INT 1
4989: PUSH
4990: LD_INT 2
4992: PUSH
4993: LD_INT 28
4995: PUSH
4996: LD_INT 25
4998: PUSH
4999: LD_INT 27
5001: PUSH
5002: EMPTY
5003: LIST
5004: LIST
5005: LIST
5006: PUSH
5007: LD_INT 1
5009: PPUSH
5010: LD_INT 3
5012: PPUSH
5013: CALL_OW 12
5017: ARRAY
5018: PUSH
5019: EMPTY
5020: LIST
5021: LIST
5022: LIST
5023: LIST
5024: PPUSH
5025: CALL_OW 2
5029: ST_TO_ADDR
5030: GO 4943
5032: POP
5033: POP
// MC_InsertProduceList ( base , tmp ) ;
5034: LD_VAR 0 2
5038: PPUSH
5039: LD_VAR 0 3
5043: PPUSH
5044: CALL 76642 0 2
// repeat wait ( 0 0$1 ) ;
5048: LD_INT 35
5050: PPUSH
5051: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
5055: LD_VAR 0 2
5059: PPUSH
5060: LD_INT 1
5062: PPUSH
5063: CALL 78060 0 2
5067: PUSH
5068: LD_VAR 0 5
5072: GREATEREQUAL
5073: IFFALSE 5048
// wait ( 0 0$30 ) ;
5075: LD_INT 1050
5077: PPUSH
5078: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_control_tower ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
5082: LD_ADDR_VAR 0 4
5086: PUSH
5087: LD_EXP 42
5091: PUSH
5092: LD_VAR 0 2
5096: ARRAY
5097: PUSH
5098: LD_EXP 42
5102: PUSH
5103: LD_VAR 0 2
5107: ARRAY
5108: PPUSH
5109: LD_INT 2
5111: PUSH
5112: LD_INT 34
5114: PUSH
5115: LD_INT 31
5117: PUSH
5118: EMPTY
5119: LIST
5120: LIST
5121: PUSH
5122: LD_INT 34
5124: PUSH
5125: LD_INT 32
5127: PUSH
5128: EMPTY
5129: LIST
5130: LIST
5131: PUSH
5132: LD_INT 34
5134: PUSH
5135: LD_INT 88
5137: PUSH
5138: EMPTY
5139: LIST
5140: LIST
5141: PUSH
5142: EMPTY
5143: LIST
5144: LIST
5145: LIST
5146: LIST
5147: PPUSH
5148: CALL_OW 72
5152: DIFF
5153: ST_TO_ADDR
// if not attackers then
5154: LD_VAR 0 4
5158: NOT
5159: IFFALSE 5163
// exit ;
5161: GO 5386
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
5163: LD_ADDR_EXP 42
5167: PUSH
5168: LD_EXP 42
5172: PPUSH
5173: LD_VAR 0 2
5177: PPUSH
5178: LD_EXP 42
5182: PUSH
5183: LD_VAR 0 2
5187: ARRAY
5188: PUSH
5189: LD_VAR 0 4
5193: DIFF
5194: PPUSH
5195: CALL_OW 1
5199: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
5200: LD_VAR 0 4
5204: PPUSH
5205: LD_INT 107
5207: PPUSH
5208: LD_INT 74
5210: PPUSH
5211: CALL_OW 114
// wait ( 0 0$5 ) ;
5215: LD_INT 175
5217: PPUSH
5218: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
5222: LD_INT 35
5224: PPUSH
5225: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5229: LD_VAR 0 4
5233: PPUSH
5234: LD_INT 60
5236: PUSH
5237: EMPTY
5238: LIST
5239: PPUSH
5240: CALL_OW 72
5244: NOT
5245: IFFALSE 5222
// if rand ( 0 , 1 ) then
5247: LD_INT 0
5249: PPUSH
5250: LD_INT 1
5252: PPUSH
5253: CALL_OW 12
5257: IFFALSE 5276
// ComAgressiveMove ( attackers , 155 , 108 ) else
5259: LD_VAR 0 4
5263: PPUSH
5264: LD_INT 155
5266: PPUSH
5267: LD_INT 108
5269: PPUSH
5270: CALL_OW 114
5274: GO 5291
// ComAgressiveMove ( attackers , 149 , 55 ) ;
5276: LD_VAR 0 4
5280: PPUSH
5281: LD_INT 149
5283: PPUSH
5284: LD_INT 55
5286: PPUSH
5287: CALL_OW 114
// wait ( 0 0$10 ) ;
5291: LD_INT 350
5293: PPUSH
5294: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
5298: LD_INT 35
5300: PPUSH
5301: CALL_OW 67
// for i in attackers do
5305: LD_ADDR_VAR 0 1
5309: PUSH
5310: LD_VAR 0 4
5314: PUSH
5315: FOR_IN
5316: IFFALSE 5366
// if not HasTask ( i ) then
5318: LD_VAR 0 1
5322: PPUSH
5323: CALL_OW 314
5327: NOT
5328: IFFALSE 5364
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
5330: LD_VAR 0 1
5334: PPUSH
5335: LD_INT 81
5337: PUSH
5338: LD_INT 2
5340: PUSH
5341: EMPTY
5342: LIST
5343: LIST
5344: PPUSH
5345: CALL_OW 69
5349: PPUSH
5350: LD_VAR 0 1
5354: PPUSH
5355: CALL_OW 74
5359: PPUSH
5360: CALL_OW 115
5364: GO 5315
5366: POP
5367: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
5368: LD_VAR 0 4
5372: PPUSH
5373: LD_INT 50
5375: PUSH
5376: EMPTY
5377: LIST
5378: PPUSH
5379: CALL_OW 72
5383: NOT
5384: IFFALSE 5298
// end ;
5386: PPOPN 5
5388: END
// every 8 8$00 + 9 9$00 trigger not arDestroyed and tick < 91 91$00 do var i , un , tmp ;
5389: LD_EXP 4
5393: NOT
5394: PUSH
5395: LD_OWVAR 1
5399: PUSH
5400: LD_INT 191100
5402: LESS
5403: AND
5404: IFFALSE 6076
5406: GO 5408
5408: DISABLE
5409: LD_INT 0
5411: PPUSH
5412: PPUSH
5413: PPUSH
// begin enable ;
5414: ENABLE
// tmp := [ ] ;
5415: LD_ADDR_VAR 0 3
5419: PUSH
5420: EMPTY
5421: ST_TO_ADDR
// if tick < 35 35$00 then
5422: LD_OWVAR 1
5426: PUSH
5427: LD_INT 73500
5429: LESS
5430: IFFALSE 5628
// begin for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
5432: LD_ADDR_VAR 0 1
5436: PUSH
5437: DOUBLE
5438: LD_INT 1
5440: DEC
5441: ST_TO_ADDR
5442: LD_INT 4
5444: PUSH
5445: LD_INT 5
5447: PUSH
5448: LD_INT 5
5450: PUSH
5451: EMPTY
5452: LIST
5453: LIST
5454: LIST
5455: PUSH
5456: LD_OWVAR 67
5460: ARRAY
5461: PUSH
5462: FOR_TO
5463: IFFALSE 5624
// begin uc_side := 2 ;
5465: LD_ADDR_OWVAR 20
5469: PUSH
5470: LD_INT 2
5472: ST_TO_ADDR
// uc_nation := 2 ;
5473: LD_ADDR_OWVAR 21
5477: PUSH
5478: LD_INT 2
5480: ST_TO_ADDR
// InitHC_All ( ) ;
5481: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
5485: LD_INT 0
5487: PPUSH
5488: LD_INT 1
5490: PPUSH
5491: LD_INT 5
5493: PUSH
5494: LD_INT 6
5496: PUSH
5497: LD_INT 7
5499: PUSH
5500: EMPTY
5501: LIST
5502: LIST
5503: LIST
5504: PUSH
5505: LD_OWVAR 67
5509: ARRAY
5510: PPUSH
5511: CALL_OW 380
// un := CreateHuman ;
5515: LD_ADDR_VAR 0 2
5519: PUSH
5520: CALL_OW 44
5524: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5525: LD_VAR 0 2
5529: PPUSH
5530: LD_INT 17
5532: PPUSH
5533: LD_INT 0
5535: PPUSH
5536: CALL_OW 49
// SetClass ( un , [ class_soldier , class_mortar ] [ rand ( 1 , 2 ) ] ) ;
5540: LD_VAR 0 2
5544: PPUSH
5545: LD_INT 1
5547: PUSH
5548: LD_INT 8
5550: PUSH
5551: EMPTY
5552: LIST
5553: LIST
5554: PUSH
5555: LD_INT 1
5557: PPUSH
5558: LD_INT 2
5560: PPUSH
5561: CALL_OW 12
5565: ARRAY
5566: PPUSH
5567: CALL_OW 336
// ComAgressiveMove ( un , 111 , 34 ) ;
5571: LD_VAR 0 2
5575: PPUSH
5576: LD_INT 111
5578: PPUSH
5579: LD_INT 34
5581: PPUSH
5582: CALL_OW 114
// wait ( 0 0$2 ) ;
5586: LD_INT 70
5588: PPUSH
5589: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5593: LD_ADDR_VAR 0 3
5597: PUSH
5598: LD_VAR 0 3
5602: PPUSH
5603: LD_VAR 0 3
5607: PUSH
5608: LD_INT 1
5610: PLUS
5611: PPUSH
5612: LD_VAR 0 2
5616: PPUSH
5617: CALL_OW 1
5621: ST_TO_ADDR
// end ;
5622: GO 5462
5624: POP
5625: POP
// end else
5626: GO 5769
// begin for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
5628: LD_ADDR_VAR 0 1
5632: PUSH
5633: DOUBLE
5634: LD_INT 1
5636: DEC
5637: ST_TO_ADDR
5638: LD_INT 4
5640: PUSH
5641: LD_INT 5
5643: PUSH
5644: LD_INT 5
5646: PUSH
5647: EMPTY
5648: LIST
5649: LIST
5650: LIST
5651: PUSH
5652: LD_OWVAR 67
5656: ARRAY
5657: PUSH
5658: FOR_TO
5659: IFFALSE 5767
// begin uc_side := 2 ;
5661: LD_ADDR_OWVAR 20
5665: PUSH
5666: LD_INT 2
5668: ST_TO_ADDR
// uc_nation := 0 ;
5669: LD_ADDR_OWVAR 21
5673: PUSH
5674: LD_INT 0
5676: ST_TO_ADDR
// InitHC_All ( ) ;
5677: CALL_OW 584
// hc_class := class_apeman_kamikaze ;
5681: LD_ADDR_OWVAR 28
5685: PUSH
5686: LD_INT 17
5688: ST_TO_ADDR
// un := CreateHuman ;
5689: LD_ADDR_VAR 0 2
5693: PUSH
5694: CALL_OW 44
5698: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5699: LD_VAR 0 2
5703: PPUSH
5704: LD_INT 17
5706: PPUSH
5707: LD_INT 0
5709: PPUSH
5710: CALL_OW 49
// ComAgressiveMove ( un , 110 , 33 ) ;
5714: LD_VAR 0 2
5718: PPUSH
5719: LD_INT 110
5721: PPUSH
5722: LD_INT 33
5724: PPUSH
5725: CALL_OW 114
// wait ( 0 0$2 ) ;
5729: LD_INT 70
5731: PPUSH
5732: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5736: LD_ADDR_VAR 0 3
5740: PUSH
5741: LD_VAR 0 3
5745: PPUSH
5746: LD_VAR 0 3
5750: PUSH
5751: LD_INT 1
5753: PLUS
5754: PPUSH
5755: LD_VAR 0 2
5759: PPUSH
5760: CALL_OW 1
5764: ST_TO_ADDR
// end ;
5765: GO 5658
5767: POP
5768: POP
// end ; for i := 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
5769: LD_ADDR_VAR 0 1
5773: PUSH
5774: DOUBLE
5775: LD_INT 1
5777: DEC
5778: ST_TO_ADDR
5779: LD_INT 3
5781: PUSH
5782: LD_INT 4
5784: PUSH
5785: LD_INT 5
5787: PUSH
5788: EMPTY
5789: LIST
5790: LIST
5791: LIST
5792: PUSH
5793: LD_OWVAR 67
5797: ARRAY
5798: PUSH
5799: FOR_TO
5800: IFFALSE 5965
// begin uc_side := 2 ;
5802: LD_ADDR_OWVAR 20
5806: PUSH
5807: LD_INT 2
5809: ST_TO_ADDR
// uc_nation := 2 ;
5810: LD_ADDR_OWVAR 21
5814: PUSH
5815: LD_INT 2
5817: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_selfpropelled_bomb , ar_rocket_launcher , ar_gun ] [ rand ( 1 , 3 ) ] , 90 ) ;
5818: LD_INT 14
5820: PPUSH
5821: LD_INT 3
5823: PPUSH
5824: LD_INT 5
5826: PPUSH
5827: LD_INT 29
5829: PUSH
5830: LD_INT 28
5832: PUSH
5833: LD_INT 27
5835: PUSH
5836: EMPTY
5837: LIST
5838: LIST
5839: LIST
5840: PUSH
5841: LD_INT 1
5843: PPUSH
5844: LD_INT 3
5846: PPUSH
5847: CALL_OW 12
5851: ARRAY
5852: PPUSH
5853: LD_INT 90
5855: PPUSH
5856: CALL 15988 0 5
// un := CreateVehicle ;
5860: LD_ADDR_VAR 0 2
5864: PUSH
5865: CALL_OW 45
5869: ST_TO_ADDR
// SetDir ( un , 2 ) ;
5870: LD_VAR 0 2
5874: PPUSH
5875: LD_INT 2
5877: PPUSH
5878: CALL_OW 233
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5882: LD_VAR 0 2
5886: PPUSH
5887: LD_INT 17
5889: PPUSH
5890: LD_INT 0
5892: PPUSH
5893: CALL_OW 49
// ComMoveXY ( un , 66 , 23 ) ;
5897: LD_VAR 0 2
5901: PPUSH
5902: LD_INT 66
5904: PPUSH
5905: LD_INT 23
5907: PPUSH
5908: CALL_OW 111
// wait ( 0 0$3 ) ;
5912: LD_INT 105
5914: PPUSH
5915: CALL_OW 67
// AddComAgressiveMove ( un , 147 , 103 ) ;
5919: LD_VAR 0 2
5923: PPUSH
5924: LD_INT 147
5926: PPUSH
5927: LD_INT 103
5929: PPUSH
5930: CALL_OW 174
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5934: LD_ADDR_VAR 0 3
5938: PUSH
5939: LD_VAR 0 3
5943: PPUSH
5944: LD_VAR 0 3
5948: PUSH
5949: LD_INT 1
5951: PLUS
5952: PPUSH
5953: LD_VAR 0 2
5957: PPUSH
5958: CALL_OW 1
5962: ST_TO_ADDR
// end ;
5963: GO 5799
5965: POP
5966: POP
// if not tmp then
5967: LD_VAR 0 3
5971: NOT
5972: IFFALSE 5976
// exit ;
5974: GO 6076
// wait ( 0 0$5 ) ;
5976: LD_INT 175
5978: PPUSH
5979: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
5983: LD_INT 70
5985: PPUSH
5986: CALL_OW 67
// for i in tmp do
5990: LD_ADDR_VAR 0 1
5994: PUSH
5995: LD_VAR 0 3
5999: PUSH
6000: FOR_IN
6001: IFFALSE 6067
// begin if not IsOk ( i ) then
6003: LD_VAR 0 1
6007: PPUSH
6008: CALL_OW 302
6012: NOT
6013: IFFALSE 6031
// tmp := tmp diff i ;
6015: LD_ADDR_VAR 0 3
6019: PUSH
6020: LD_VAR 0 3
6024: PUSH
6025: LD_VAR 0 1
6029: DIFF
6030: ST_TO_ADDR
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
6031: LD_VAR 0 1
6035: PPUSH
6036: LD_INT 81
6038: PUSH
6039: LD_INT 2
6041: PUSH
6042: EMPTY
6043: LIST
6044: LIST
6045: PPUSH
6046: CALL_OW 69
6050: PPUSH
6051: LD_VAR 0 1
6055: PPUSH
6056: CALL_OW 74
6060: PPUSH
6061: CALL_OW 115
// end ;
6065: GO 6000
6067: POP
6068: POP
// until not tmp ;
6069: LD_VAR 0 3
6073: NOT
6074: IFFALSE 5983
// end ;
6076: PPOPN 3
6078: END
// every 9 9$00 trigger Difficulty > 1 do var un ;
6079: LD_OWVAR 67
6083: PUSH
6084: LD_INT 1
6086: GREATER
6087: IFFALSE 6185
6089: GO 6091
6091: DISABLE
6092: LD_INT 0
6094: PPUSH
// begin uc_side := 2 ;
6095: LD_ADDR_OWVAR 20
6099: PUSH
6100: LD_INT 2
6102: ST_TO_ADDR
// uc_nation := 2 ;
6103: LD_ADDR_OWVAR 21
6107: PUSH
6108: LD_INT 2
6110: ST_TO_ADDR
// PrepareHuman ( false , 4 , 6 ) ;
6111: LD_INT 0
6113: PPUSH
6114: LD_INT 4
6116: PPUSH
6117: LD_INT 6
6119: PPUSH
6120: CALL_OW 380
// un := CreateHuman ;
6124: LD_ADDR_VAR 0 1
6128: PUSH
6129: CALL_OW 44
6133: ST_TO_ADDR
// PlaceUnitXYD ( un , 88 , 1 , 2 , false ) ;
6134: LD_VAR 0 1
6138: PPUSH
6139: LD_INT 88
6141: PPUSH
6142: LD_INT 1
6144: PPUSH
6145: LD_INT 2
6147: PPUSH
6148: LD_INT 0
6150: PPUSH
6151: CALL 50553 0 5
// ComMoveXY ( un , 130 , 35 ) ;
6155: LD_VAR 0 1
6159: PPUSH
6160: LD_INT 130
6162: PPUSH
6163: LD_INT 35
6165: PPUSH
6166: CALL_OW 111
// AddComContaminate ( un , 132 , 39 ) ;
6170: LD_VAR 0 1
6174: PPUSH
6175: LD_INT 132
6177: PPUSH
6178: LD_INT 39
6180: PPUSH
6181: CALL_OW 218
// end ;
6185: PPOPN 1
6187: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
6188: LD_INT 22
6190: PUSH
6191: LD_INT 2
6193: PUSH
6194: EMPTY
6195: LIST
6196: LIST
6197: PUSH
6198: LD_INT 33
6200: PUSH
6201: LD_INT 2
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: PUSH
6208: LD_INT 50
6210: PUSH
6211: EMPTY
6212: LIST
6213: PUSH
6214: LD_INT 3
6216: PUSH
6217: LD_INT 61
6219: PUSH
6220: EMPTY
6221: LIST
6222: PUSH
6223: EMPTY
6224: LIST
6225: LIST
6226: PUSH
6227: EMPTY
6228: LIST
6229: LIST
6230: LIST
6231: LIST
6232: PPUSH
6233: CALL_OW 69
6237: IFFALSE 6328
6239: GO 6241
6241: DISABLE
6242: LD_INT 0
6244: PPUSH
6245: PPUSH
// begin enable ;
6246: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
6247: LD_ADDR_VAR 0 2
6251: PUSH
6252: LD_INT 22
6254: PUSH
6255: LD_INT 2
6257: PUSH
6258: EMPTY
6259: LIST
6260: LIST
6261: PUSH
6262: LD_INT 33
6264: PUSH
6265: LD_INT 2
6267: PUSH
6268: EMPTY
6269: LIST
6270: LIST
6271: PUSH
6272: LD_INT 50
6274: PUSH
6275: EMPTY
6276: LIST
6277: PUSH
6278: LD_INT 3
6280: PUSH
6281: LD_INT 61
6283: PUSH
6284: EMPTY
6285: LIST
6286: PUSH
6287: EMPTY
6288: LIST
6289: LIST
6290: PUSH
6291: EMPTY
6292: LIST
6293: LIST
6294: LIST
6295: LIST
6296: PPUSH
6297: CALL_OW 69
6301: ST_TO_ADDR
// for i in tmp do
6302: LD_ADDR_VAR 0 1
6306: PUSH
6307: LD_VAR 0 2
6311: PUSH
6312: FOR_IN
6313: IFFALSE 6326
// Connect ( i ) ;
6315: LD_VAR 0 1
6319: PPUSH
6320: CALL 19079 0 1
6324: GO 6312
6326: POP
6327: POP
// end ; end_of_file
6328: PPOPN 2
6330: END
// export Popov , popov_side , extraPopovForces , popovAttackGroup ; export function PreparePopov ; var i , un , tmp , b , list ; begin
6331: LD_INT 0
6333: PPUSH
6334: PPUSH
6335: PPUSH
6336: PPUSH
6337: PPUSH
6338: PPUSH
// popov_side := 3 ;
6339: LD_ADDR_EXP 17
6343: PUSH
6344: LD_INT 3
6346: ST_TO_ADDR
// uc_side := popov_side ;
6347: LD_ADDR_OWVAR 20
6351: PUSH
6352: LD_EXP 17
6356: ST_TO_ADDR
// uc_nation := 3 ;
6357: LD_ADDR_OWVAR 21
6361: PUSH
6362: LD_INT 3
6364: ST_TO_ADDR
// list := [ [ b_barracks , 103 , 147 , 3 ] , [ b_barracks , 70 , 117 , 3 ] , [ b_lab , 76 , 145 , 1 , b_lab_weapon , b_lab_siberium ] , [ b_oil_power , 87 , 144 , 0 ] , [ b_oil_mine , 86 , 118 , 0 ] , [ b_oil_mine , 98 , 121 , 0 ] , [ b_oil_power , 87 , 147 , 1 ] , [ b_siberite_mine , 123 , 151 , 1 ] , [ b_factory , 94 , 161 , 0 ] , [ b_lab , 81 , 155 , 1 , b_lab_computer , b_lab_spacetime ] , [ b_oil_power , 96 , 152 , 0 ] , [ b_oil_power , 96 , 149 , 3 ] , [ b_bunker , 109 , 142 , 3 , ru_heavy_gun ] , [ b_bunker , 112 , 148 , 3 , ru_heavy_gun ] , [ b_turret , 120 , 159 , 4 , ru_rocket_launcher ] , [ b_turret , 122 , 163 , 4 , ru_rocket_launcher ] , [ b_turret , 123 , 167 , 4 , ru_rocket_launcher ] , [ b_turret , 59 , 111 , 3 , ru_rocket_launcher ] , [ b_turret , 65 , 111 , 3 , ru_heavy_gun ] , [ b_turret , 76 , 117 , 3 , ru_rocket_launcher ] , [ b_turret , 80 , 119 , 3 , ru_heavy_gun ] , [ b_turret , 87 , 125 , 3 , ru_rocket_launcher ] , [ b_barracks , 92 , 129 , 3 ] , [ b_siberite_power , 85 , 165 , 0 ] , [ b_siberite_power , 83 , 161 , 4 ] , [ b_siberite_power , 91 , 166 , 3 ] , [ b_siberite_power , 102 , 166 , 2 ] ] ;
6365: LD_ADDR_VAR 0 6
6369: PUSH
6370: LD_INT 5
6372: PUSH
6373: LD_INT 103
6375: PUSH
6376: LD_INT 147
6378: PUSH
6379: LD_INT 3
6381: PUSH
6382: EMPTY
6383: LIST
6384: LIST
6385: LIST
6386: LIST
6387: PUSH
6388: LD_INT 5
6390: PUSH
6391: LD_INT 70
6393: PUSH
6394: LD_INT 117
6396: PUSH
6397: LD_INT 3
6399: PUSH
6400: EMPTY
6401: LIST
6402: LIST
6403: LIST
6404: LIST
6405: PUSH
6406: LD_INT 6
6408: PUSH
6409: LD_INT 76
6411: PUSH
6412: LD_INT 145
6414: PUSH
6415: LD_INT 1
6417: PUSH
6418: LD_INT 10
6420: PUSH
6421: LD_INT 11
6423: PUSH
6424: EMPTY
6425: LIST
6426: LIST
6427: LIST
6428: LIST
6429: LIST
6430: LIST
6431: PUSH
6432: LD_INT 26
6434: PUSH
6435: LD_INT 87
6437: PUSH
6438: LD_INT 144
6440: PUSH
6441: LD_INT 0
6443: PUSH
6444: EMPTY
6445: LIST
6446: LIST
6447: LIST
6448: LIST
6449: PUSH
6450: LD_INT 29
6452: PUSH
6453: LD_INT 86
6455: PUSH
6456: LD_INT 118
6458: PUSH
6459: LD_INT 0
6461: PUSH
6462: EMPTY
6463: LIST
6464: LIST
6465: LIST
6466: LIST
6467: PUSH
6468: LD_INT 29
6470: PUSH
6471: LD_INT 98
6473: PUSH
6474: LD_INT 121
6476: PUSH
6477: LD_INT 0
6479: PUSH
6480: EMPTY
6481: LIST
6482: LIST
6483: LIST
6484: LIST
6485: PUSH
6486: LD_INT 26
6488: PUSH
6489: LD_INT 87
6491: PUSH
6492: LD_INT 147
6494: PUSH
6495: LD_INT 1
6497: PUSH
6498: EMPTY
6499: LIST
6500: LIST
6501: LIST
6502: LIST
6503: PUSH
6504: LD_INT 30
6506: PUSH
6507: LD_INT 123
6509: PUSH
6510: LD_INT 151
6512: PUSH
6513: LD_INT 1
6515: PUSH
6516: EMPTY
6517: LIST
6518: LIST
6519: LIST
6520: LIST
6521: PUSH
6522: LD_INT 3
6524: PUSH
6525: LD_INT 94
6527: PUSH
6528: LD_INT 161
6530: PUSH
6531: LD_INT 0
6533: PUSH
6534: EMPTY
6535: LIST
6536: LIST
6537: LIST
6538: LIST
6539: PUSH
6540: LD_INT 6
6542: PUSH
6543: LD_INT 81
6545: PUSH
6546: LD_INT 155
6548: PUSH
6549: LD_INT 1
6551: PUSH
6552: LD_INT 12
6554: PUSH
6555: LD_INT 14
6557: PUSH
6558: EMPTY
6559: LIST
6560: LIST
6561: LIST
6562: LIST
6563: LIST
6564: LIST
6565: PUSH
6566: LD_INT 26
6568: PUSH
6569: LD_INT 96
6571: PUSH
6572: LD_INT 152
6574: PUSH
6575: LD_INT 0
6577: PUSH
6578: EMPTY
6579: LIST
6580: LIST
6581: LIST
6582: LIST
6583: PUSH
6584: LD_INT 26
6586: PUSH
6587: LD_INT 96
6589: PUSH
6590: LD_INT 149
6592: PUSH
6593: LD_INT 3
6595: PUSH
6596: EMPTY
6597: LIST
6598: LIST
6599: LIST
6600: LIST
6601: PUSH
6602: LD_INT 32
6604: PUSH
6605: LD_INT 109
6607: PUSH
6608: LD_INT 142
6610: PUSH
6611: LD_INT 3
6613: PUSH
6614: LD_INT 46
6616: PUSH
6617: EMPTY
6618: LIST
6619: LIST
6620: LIST
6621: LIST
6622: LIST
6623: PUSH
6624: LD_INT 32
6626: PUSH
6627: LD_INT 112
6629: PUSH
6630: LD_INT 148
6632: PUSH
6633: LD_INT 3
6635: PUSH
6636: LD_INT 46
6638: PUSH
6639: EMPTY
6640: LIST
6641: LIST
6642: LIST
6643: LIST
6644: LIST
6645: PUSH
6646: LD_INT 33
6648: PUSH
6649: LD_INT 120
6651: PUSH
6652: LD_INT 159
6654: PUSH
6655: LD_INT 4
6657: PUSH
6658: LD_INT 45
6660: PUSH
6661: EMPTY
6662: LIST
6663: LIST
6664: LIST
6665: LIST
6666: LIST
6667: PUSH
6668: LD_INT 33
6670: PUSH
6671: LD_INT 122
6673: PUSH
6674: LD_INT 163
6676: PUSH
6677: LD_INT 4
6679: PUSH
6680: LD_INT 45
6682: PUSH
6683: EMPTY
6684: LIST
6685: LIST
6686: LIST
6687: LIST
6688: LIST
6689: PUSH
6690: LD_INT 33
6692: PUSH
6693: LD_INT 123
6695: PUSH
6696: LD_INT 167
6698: PUSH
6699: LD_INT 4
6701: PUSH
6702: LD_INT 45
6704: PUSH
6705: EMPTY
6706: LIST
6707: LIST
6708: LIST
6709: LIST
6710: LIST
6711: PUSH
6712: LD_INT 33
6714: PUSH
6715: LD_INT 59
6717: PUSH
6718: LD_INT 111
6720: PUSH
6721: LD_INT 3
6723: PUSH
6724: LD_INT 45
6726: PUSH
6727: EMPTY
6728: LIST
6729: LIST
6730: LIST
6731: LIST
6732: LIST
6733: PUSH
6734: LD_INT 33
6736: PUSH
6737: LD_INT 65
6739: PUSH
6740: LD_INT 111
6742: PUSH
6743: LD_INT 3
6745: PUSH
6746: LD_INT 46
6748: PUSH
6749: EMPTY
6750: LIST
6751: LIST
6752: LIST
6753: LIST
6754: LIST
6755: PUSH
6756: LD_INT 33
6758: PUSH
6759: LD_INT 76
6761: PUSH
6762: LD_INT 117
6764: PUSH
6765: LD_INT 3
6767: PUSH
6768: LD_INT 45
6770: PUSH
6771: EMPTY
6772: LIST
6773: LIST
6774: LIST
6775: LIST
6776: LIST
6777: PUSH
6778: LD_INT 33
6780: PUSH
6781: LD_INT 80
6783: PUSH
6784: LD_INT 119
6786: PUSH
6787: LD_INT 3
6789: PUSH
6790: LD_INT 46
6792: PUSH
6793: EMPTY
6794: LIST
6795: LIST
6796: LIST
6797: LIST
6798: LIST
6799: PUSH
6800: LD_INT 33
6802: PUSH
6803: LD_INT 87
6805: PUSH
6806: LD_INT 125
6808: PUSH
6809: LD_INT 3
6811: PUSH
6812: LD_INT 45
6814: PUSH
6815: EMPTY
6816: LIST
6817: LIST
6818: LIST
6819: LIST
6820: LIST
6821: PUSH
6822: LD_INT 5
6824: PUSH
6825: LD_INT 92
6827: PUSH
6828: LD_INT 129
6830: PUSH
6831: LD_INT 3
6833: PUSH
6834: EMPTY
6835: LIST
6836: LIST
6837: LIST
6838: LIST
6839: PUSH
6840: LD_INT 28
6842: PUSH
6843: LD_INT 85
6845: PUSH
6846: LD_INT 165
6848: PUSH
6849: LD_INT 0
6851: PUSH
6852: EMPTY
6853: LIST
6854: LIST
6855: LIST
6856: LIST
6857: PUSH
6858: LD_INT 28
6860: PUSH
6861: LD_INT 83
6863: PUSH
6864: LD_INT 161
6866: PUSH
6867: LD_INT 4
6869: PUSH
6870: EMPTY
6871: LIST
6872: LIST
6873: LIST
6874: LIST
6875: PUSH
6876: LD_INT 28
6878: PUSH
6879: LD_INT 91
6881: PUSH
6882: LD_INT 166
6884: PUSH
6885: LD_INT 3
6887: PUSH
6888: EMPTY
6889: LIST
6890: LIST
6891: LIST
6892: LIST
6893: PUSH
6894: LD_INT 28
6896: PUSH
6897: LD_INT 102
6899: PUSH
6900: LD_INT 166
6902: PUSH
6903: LD_INT 2
6905: PUSH
6906: EMPTY
6907: LIST
6908: LIST
6909: LIST
6910: LIST
6911: PUSH
6912: EMPTY
6913: LIST
6914: LIST
6915: LIST
6916: LIST
6917: LIST
6918: LIST
6919: LIST
6920: LIST
6921: LIST
6922: LIST
6923: LIST
6924: LIST
6925: LIST
6926: LIST
6927: LIST
6928: LIST
6929: LIST
6930: LIST
6931: LIST
6932: LIST
6933: LIST
6934: LIST
6935: LIST
6936: LIST
6937: LIST
6938: LIST
6939: LIST
6940: ST_TO_ADDR
// for i in list do
6941: LD_ADDR_VAR 0 2
6945: PUSH
6946: LD_VAR 0 6
6950: PUSH
6951: FOR_IN
6952: IFFALSE 7116
// begin uc_side := 3 ;
6954: LD_ADDR_OWVAR 20
6958: PUSH
6959: LD_INT 3
6961: ST_TO_ADDR
// uc_nation := 3 ;
6962: LD_ADDR_OWVAR 21
6966: PUSH
6967: LD_INT 3
6969: ST_TO_ADDR
// InitBc ;
6970: CALL_OW 21
// bc_type := i [ 1 ] ;
6974: LD_ADDR_OWVAR 42
6978: PUSH
6979: LD_VAR 0 2
6983: PUSH
6984: LD_INT 1
6986: ARRAY
6987: ST_TO_ADDR
// if i [ 1 ] = b_lab then
6988: LD_VAR 0 2
6992: PUSH
6993: LD_INT 1
6995: ARRAY
6996: PUSH
6997: LD_INT 6
6999: EQUAL
7000: IFFALSE 7038
// begin bc_type := b_lab_full ;
7002: LD_ADDR_OWVAR 42
7006: PUSH
7007: LD_INT 8
7009: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
7010: LD_ADDR_OWVAR 44
7014: PUSH
7015: LD_VAR 0 2
7019: PUSH
7020: LD_INT 5
7022: ARRAY
7023: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
7024: LD_ADDR_OWVAR 45
7028: PUSH
7029: LD_VAR 0 2
7033: PUSH
7034: LD_INT 6
7036: ARRAY
7037: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
7038: LD_ADDR_VAR 0 5
7042: PUSH
7043: LD_VAR 0 2
7047: PUSH
7048: LD_INT 2
7050: ARRAY
7051: PPUSH
7052: LD_VAR 0 2
7056: PUSH
7057: LD_INT 3
7059: ARRAY
7060: PPUSH
7061: LD_VAR 0 2
7065: PUSH
7066: LD_INT 4
7068: ARRAY
7069: PPUSH
7070: CALL_OW 47
7074: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
7075: LD_VAR 0 2
7079: PUSH
7080: LD_INT 1
7082: ARRAY
7083: PUSH
7084: LD_INT 33
7086: PUSH
7087: LD_INT 32
7089: PUSH
7090: EMPTY
7091: LIST
7092: LIST
7093: IN
7094: IFFALSE 7114
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
7096: LD_VAR 0 5
7100: PPUSH
7101: LD_VAR 0 2
7105: PUSH
7106: LD_INT 5
7108: ARRAY
7109: PPUSH
7110: CALL_OW 431
// end ;
7114: GO 6951
7116: POP
7117: POP
// tmp := PrepareBase ( ru_depot , popov_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 11500 , 1100 , 60 ] , [ 6 , 6 , 6 , 6 ] ) ;
7118: LD_ADDR_VAR 0 4
7122: PUSH
7123: LD_INT 9
7125: PPUSH
7126: LD_INT 3
7128: PPUSH
7129: LD_STRING 
7131: PPUSH
7132: LD_INT 8
7134: PUSH
7135: LD_INT 7
7137: PUSH
7138: LD_INT 6
7140: PUSH
7141: EMPTY
7142: LIST
7143: LIST
7144: LIST
7145: PUSH
7146: LD_OWVAR 67
7150: ARRAY
7151: PPUSH
7152: LD_INT 11500
7154: PUSH
7155: LD_INT 1100
7157: PUSH
7158: LD_INT 60
7160: PUSH
7161: EMPTY
7162: LIST
7163: LIST
7164: LIST
7165: PPUSH
7166: LD_INT 6
7168: PUSH
7169: LD_INT 6
7171: PUSH
7172: LD_INT 6
7174: PUSH
7175: LD_INT 6
7177: PUSH
7178: EMPTY
7179: LIST
7180: LIST
7181: LIST
7182: LIST
7183: PPUSH
7184: CALL 19432 0 6
7188: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 3 , tmp union FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ) ;
7189: LD_ADDR_EXP 23
7193: PUSH
7194: LD_EXP 23
7198: PPUSH
7199: LD_INT 3
7201: PPUSH
7202: LD_VAR 0 4
7206: PUSH
7207: LD_INT 22
7209: PUSH
7210: LD_INT 3
7212: PUSH
7213: EMPTY
7214: LIST
7215: LIST
7216: PUSH
7217: LD_INT 21
7219: PUSH
7220: LD_INT 3
7222: PUSH
7223: EMPTY
7224: LIST
7225: LIST
7226: PUSH
7227: EMPTY
7228: LIST
7229: LIST
7230: PPUSH
7231: CALL_OW 69
7235: UNION
7236: PPUSH
7237: CALL_OW 1
7241: ST_TO_ADDR
// extraPopovForces := [ ] ;
7242: LD_ADDR_EXP 18
7246: PUSH
7247: EMPTY
7248: ST_TO_ADDR
// for i := 1 to [ 8 , 9 , 10 ] [ Difficulty ] do
7249: LD_ADDR_VAR 0 2
7253: PUSH
7254: DOUBLE
7255: LD_INT 1
7257: DEC
7258: ST_TO_ADDR
7259: LD_INT 8
7261: PUSH
7262: LD_INT 9
7264: PUSH
7265: LD_INT 10
7267: PUSH
7268: EMPTY
7269: LIST
7270: LIST
7271: LIST
7272: PUSH
7273: LD_OWVAR 67
7277: ARRAY
7278: PUSH
7279: FOR_TO
7280: IFFALSE 7409
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
7282: LD_INT 0
7284: PPUSH
7285: LD_INT 1
7287: PPUSH
7288: LD_INT 4
7290: PUSH
7291: LD_INT 5
7293: PUSH
7294: LD_INT 6
7296: PUSH
7297: EMPTY
7298: LIST
7299: LIST
7300: LIST
7301: PUSH
7302: LD_OWVAR 67
7306: ARRAY
7307: PPUSH
7308: CALL_OW 380
// un := CreateHuman ;
7312: LD_ADDR_VAR 0 3
7316: PUSH
7317: CALL_OW 44
7321: ST_TO_ADDR
// if rand ( 0 , 1 ) then
7322: LD_INT 0
7324: PPUSH
7325: LD_INT 1
7327: PPUSH
7328: CALL_OW 12
7332: IFFALSE 7357
// PlaceUnitXYR ( un , 131 , 110 , 8 , false ) else
7334: LD_VAR 0 3
7338: PPUSH
7339: LD_INT 131
7341: PPUSH
7342: LD_INT 110
7344: PPUSH
7345: LD_INT 8
7347: PPUSH
7348: LD_INT 0
7350: PPUSH
7351: CALL_OW 50
7355: GO 7378
// PlaceUnitXYR ( un , 100 , 99 , 8 , false ) ;
7357: LD_VAR 0 3
7361: PPUSH
7362: LD_INT 100
7364: PPUSH
7365: LD_INT 99
7367: PPUSH
7368: LD_INT 8
7370: PPUSH
7371: LD_INT 0
7373: PPUSH
7374: CALL_OW 50
// extraPopovForces := Replace ( extraPopovForces , extraPopovForces + 1 , un ) ;
7378: LD_ADDR_EXP 18
7382: PUSH
7383: LD_EXP 18
7387: PPUSH
7388: LD_EXP 18
7392: PUSH
7393: LD_INT 1
7395: PLUS
7396: PPUSH
7397: LD_VAR 0 3
7401: PPUSH
7402: CALL_OW 1
7406: ST_TO_ADDR
// end ;
7407: GO 7279
7409: POP
7410: POP
// PrepareSoldier ( false , 6 ) ;
7411: LD_INT 0
7413: PPUSH
7414: LD_INT 6
7416: PPUSH
7417: CALL_OW 381
// un := CreateHuman ;
7421: LD_ADDR_VAR 0 3
7425: PUSH
7426: CALL_OW 44
7430: ST_TO_ADDR
// SetDir ( un , 1 ) ;
7431: LD_VAR 0 3
7435: PPUSH
7436: LD_INT 1
7438: PPUSH
7439: CALL_OW 233
// PlaceHumanInUnit ( un , HexInfo ( 150 , 158 ) ) ;
7443: LD_VAR 0 3
7447: PPUSH
7448: LD_INT 150
7450: PPUSH
7451: LD_INT 158
7453: PPUSH
7454: CALL_OW 428
7458: PPUSH
7459: CALL_OW 52
// popovAttackGroup := [ ] ;
7463: LD_ADDR_EXP 19
7467: PUSH
7468: EMPTY
7469: ST_TO_ADDR
// end ;
7470: LD_VAR 0 1
7474: RET
// export function InitMC_Popov ( ) ; begin
7475: LD_INT 0
7477: PPUSH
// MC_SetScanArea ( 3 , popov_base ) ;
7478: LD_INT 3
7480: PPUSH
7481: LD_INT 3
7483: PPUSH
7484: CALL 77915 0 2
// MC_SetParkingArea ( 3 , popov_parking ) ;
7488: LD_INT 3
7490: PPUSH
7491: LD_INT 10
7493: PPUSH
7494: CALL 77859 0 2
// MC_SetDepositsXY ( 3 , [ [ 86 , 118 , 0 ] , [ 123 , 151 , 1 ] , [ 98 , 121 , 0 ] ] ) ;
7498: LD_INT 3
7500: PPUSH
7501: LD_INT 86
7503: PUSH
7504: LD_INT 118
7506: PUSH
7507: LD_INT 0
7509: PUSH
7510: EMPTY
7511: LIST
7512: LIST
7513: LIST
7514: PUSH
7515: LD_INT 123
7517: PUSH
7518: LD_INT 151
7520: PUSH
7521: LD_INT 1
7523: PUSH
7524: EMPTY
7525: LIST
7526: LIST
7527: LIST
7528: PUSH
7529: LD_INT 98
7531: PUSH
7532: LD_INT 121
7534: PUSH
7535: LD_INT 0
7537: PUSH
7538: EMPTY
7539: LIST
7540: LIST
7541: LIST
7542: PUSH
7543: EMPTY
7544: LIST
7545: LIST
7546: LIST
7547: PPUSH
7548: CALL 76918 0 2
// MC_SetAllowedTurretWeapons ( 3 , [ ru_heavy_gun , ru_rocket_launcher ] ) ;
7552: LD_INT 3
7554: PPUSH
7555: LD_INT 46
7557: PUSH
7558: LD_INT 45
7560: PUSH
7561: EMPTY
7562: LIST
7563: LIST
7564: PPUSH
7565: CALL 77747 0 2
// MC_SetCratesArea ( 3 , popov_crates ) ;
7569: LD_INT 3
7571: PPUSH
7572: LD_INT 12
7574: PPUSH
7575: CALL 77429 0 2
// MC_SetTame ( 3 , popov_ape ) ;
7579: LD_INT 3
7581: PPUSH
7582: LD_INT 11
7584: PPUSH
7585: CALL 77160 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
7589: LD_INT 3
7591: PPUSH
7592: LD_INT 4
7594: PPUSH
7595: CALL 76779 0 2
// MC_SetProduceList ( 3 , [ [ ru_heavy_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] ] ) ;
7599: LD_INT 3
7601: PPUSH
7602: LD_INT 23
7604: PUSH
7605: LD_INT 1
7607: PUSH
7608: LD_INT 3
7610: PUSH
7611: LD_INT 44
7613: PUSH
7614: EMPTY
7615: LIST
7616: LIST
7617: LIST
7618: LIST
7619: PUSH
7620: LD_INT 23
7622: PUSH
7623: LD_INT 1
7625: PUSH
7626: LD_INT 3
7628: PUSH
7629: LD_INT 45
7631: PUSH
7632: EMPTY
7633: LIST
7634: LIST
7635: LIST
7636: LIST
7637: PUSH
7638: LD_INT 21
7640: PUSH
7641: LD_INT 1
7643: PUSH
7644: LD_INT 3
7646: PUSH
7647: LD_INT 44
7649: PUSH
7650: EMPTY
7651: LIST
7652: LIST
7653: LIST
7654: LIST
7655: PUSH
7656: LD_INT 21
7658: PUSH
7659: LD_INT 1
7661: PUSH
7662: LD_INT 3
7664: PUSH
7665: LD_INT 45
7667: PUSH
7668: EMPTY
7669: LIST
7670: LIST
7671: LIST
7672: LIST
7673: PUSH
7674: EMPTY
7675: LIST
7676: LIST
7677: LIST
7678: LIST
7679: PPUSH
7680: CALL 76594 0 2
// MC_SetFactoryExtension ( 3 , 94 , 161 , 0 , [ b_ext_noncombat , b_ext_gun , b_ext_rocket , b_ext_computer , b_ext_siberium ] ) ;
7684: LD_INT 3
7686: PPUSH
7687: LD_INT 94
7689: PPUSH
7690: LD_INT 161
7692: PPUSH
7693: LD_INT 0
7695: PPUSH
7696: LD_INT 19
7698: PUSH
7699: LD_INT 17
7701: PUSH
7702: LD_INT 18
7704: PUSH
7705: LD_INT 24
7707: PUSH
7708: LD_INT 21
7710: PUSH
7711: EMPTY
7712: LIST
7713: LIST
7714: LIST
7715: LIST
7716: LIST
7717: PPUSH
7718: CALL 77541 0 5
// MC_InsertProduceList ( 3 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] ] ) ;
7722: LD_INT 3
7724: PPUSH
7725: LD_INT 21
7727: PUSH
7728: LD_INT 1
7730: PUSH
7731: LD_INT 3
7733: PUSH
7734: LD_INT 51
7736: PUSH
7737: EMPTY
7738: LIST
7739: LIST
7740: LIST
7741: LIST
7742: PUSH
7743: EMPTY
7744: LIST
7745: PPUSH
7746: CALL 76642 0 2
// end ;
7750: LD_VAR 0 1
7754: RET
// every 9 9$00 trigger extraPopovForces and not ruDestroyed do
7755: LD_EXP 18
7759: PUSH
7760: LD_EXP 5
7764: NOT
7765: AND
7766: IFFALSE 7826
7768: GO 7770
7770: DISABLE
// begin ComMoveXY ( extraPopovForces , 106 , 137 ) ;
7771: LD_EXP 18
7775: PPUSH
7776: LD_INT 106
7778: PPUSH
7779: LD_INT 137
7781: PPUSH
7782: CALL_OW 111
// mc_bases := Replace ( mc_bases , 3 , mc_bases [ 3 ] union extraPopovForces ) ;
7786: LD_ADDR_EXP 23
7790: PUSH
7791: LD_EXP 23
7795: PPUSH
7796: LD_INT 3
7798: PPUSH
7799: LD_EXP 23
7803: PUSH
7804: LD_INT 3
7806: ARRAY
7807: PUSH
7808: LD_EXP 18
7812: UNION
7813: PPUSH
7814: CALL_OW 1
7818: ST_TO_ADDR
// extraPopovForces := [ ] ;
7819: LD_ADDR_EXP 18
7823: PUSH
7824: EMPTY
7825: ST_TO_ADDR
// end ;
7826: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ru_depot ) and not ruDestroyed do var i , base , tmp , attackers , amount ;
7827: LD_INT 9
7829: PPUSH
7830: CALL_OW 302
7834: PUSH
7835: LD_EXP 5
7839: NOT
7840: AND
7841: IFFALSE 8407
7843: GO 7845
7845: DISABLE
7846: LD_INT 0
7848: PPUSH
7849: PPUSH
7850: PPUSH
7851: PPUSH
7852: PPUSH
// begin enable ;
7853: ENABLE
// base := 3 ;
7854: LD_ADDR_VAR 0 2
7858: PUSH
7859: LD_INT 3
7861: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] ] ;
7862: LD_ADDR_VAR 0 3
7866: PUSH
7867: LD_INT 22
7869: PUSH
7870: LD_INT 1
7872: PUSH
7873: LD_INT 3
7875: PUSH
7876: LD_INT 44
7878: PUSH
7879: EMPTY
7880: LIST
7881: LIST
7882: LIST
7883: LIST
7884: PUSH
7885: LD_INT 24
7887: PUSH
7888: LD_INT 1
7890: PUSH
7891: LD_INT 3
7893: PUSH
7894: LD_INT 46
7896: PUSH
7897: EMPTY
7898: LIST
7899: LIST
7900: LIST
7901: LIST
7902: PUSH
7903: LD_INT 24
7905: PUSH
7906: LD_INT 1
7908: PUSH
7909: LD_INT 3
7911: PUSH
7912: LD_INT 46
7914: PUSH
7915: EMPTY
7916: LIST
7917: LIST
7918: LIST
7919: LIST
7920: PUSH
7921: LD_INT 24
7923: PUSH
7924: LD_INT 1
7926: PUSH
7927: LD_INT 3
7929: PUSH
7930: LD_INT 46
7932: PUSH
7933: EMPTY
7934: LIST
7935: LIST
7936: LIST
7937: LIST
7938: PUSH
7939: EMPTY
7940: LIST
7941: LIST
7942: LIST
7943: LIST
7944: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
7945: LD_ADDR_VAR 0 5
7949: PUSH
7950: LD_VAR 0 5
7954: PUSH
7955: LD_OWVAR 1
7959: PUSH
7960: LD_INT 21000
7962: DIV
7963: PLUS
7964: ST_TO_ADDR
// if amount > 8 then
7965: LD_VAR 0 5
7969: PUSH
7970: LD_INT 8
7972: GREATER
7973: IFFALSE 7983
// amount := 8 ;
7975: LD_ADDR_VAR 0 5
7979: PUSH
7980: LD_INT 8
7982: ST_TO_ADDR
// for i = 1 to amount do
7983: LD_ADDR_VAR 0 1
7987: PUSH
7988: DOUBLE
7989: LD_INT 1
7991: DEC
7992: ST_TO_ADDR
7993: LD_VAR 0 5
7997: PUSH
7998: FOR_TO
7999: IFFALSE 8064
// tmp := Insert ( tmp , tmp + 1 , [ ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
8001: LD_ADDR_VAR 0 3
8005: PUSH
8006: LD_VAR 0 3
8010: PPUSH
8011: LD_VAR 0 3
8015: PUSH
8016: LD_INT 1
8018: PLUS
8019: PPUSH
8020: LD_INT 24
8022: PUSH
8023: LD_INT 1
8025: PUSH
8026: LD_INT 3
8028: PUSH
8029: LD_INT 46
8031: PUSH
8032: LD_INT 45
8034: PUSH
8035: EMPTY
8036: LIST
8037: LIST
8038: PUSH
8039: LD_INT 1
8041: PPUSH
8042: LD_INT 2
8044: PPUSH
8045: CALL_OW 12
8049: ARRAY
8050: PUSH
8051: EMPTY
8052: LIST
8053: LIST
8054: LIST
8055: LIST
8056: PPUSH
8057: CALL_OW 2
8061: ST_TO_ADDR
8062: GO 7998
8064: POP
8065: POP
// MC_InsertProduceList ( base , tmp ) ;
8066: LD_VAR 0 2
8070: PPUSH
8071: LD_VAR 0 3
8075: PPUSH
8076: CALL 76642 0 2
// repeat wait ( 0 0$1 ) ;
8080: LD_INT 35
8082: PPUSH
8083: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
8087: LD_VAR 0 2
8091: PPUSH
8092: LD_INT 1
8094: PPUSH
8095: CALL 78060 0 2
8099: PUSH
8100: LD_VAR 0 5
8104: GREATEREQUAL
8105: IFFALSE 8080
// wait ( 0 0$30 ) ;
8107: LD_INT 1050
8109: PPUSH
8110: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
8114: LD_ADDR_VAR 0 4
8118: PUSH
8119: LD_EXP 42
8123: PUSH
8124: LD_VAR 0 2
8128: ARRAY
8129: PUSH
8130: LD_EXP 42
8134: PUSH
8135: LD_VAR 0 2
8139: ARRAY
8140: PPUSH
8141: LD_INT 2
8143: PUSH
8144: LD_INT 34
8146: PUSH
8147: LD_INT 51
8149: PUSH
8150: EMPTY
8151: LIST
8152: LIST
8153: PUSH
8154: LD_INT 34
8156: PUSH
8157: LD_INT 52
8159: PUSH
8160: EMPTY
8161: LIST
8162: LIST
8163: PUSH
8164: EMPTY
8165: LIST
8166: LIST
8167: LIST
8168: PPUSH
8169: CALL_OW 72
8173: DIFF
8174: ST_TO_ADDR
// if not attackers then
8175: LD_VAR 0 4
8179: NOT
8180: IFFALSE 8184
// exit ;
8182: GO 8407
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
8184: LD_ADDR_EXP 42
8188: PUSH
8189: LD_EXP 42
8193: PPUSH
8194: LD_VAR 0 2
8198: PPUSH
8199: LD_EXP 42
8203: PUSH
8204: LD_VAR 0 2
8208: ARRAY
8209: PUSH
8210: LD_VAR 0 4
8214: DIFF
8215: PPUSH
8216: CALL_OW 1
8220: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
8221: LD_VAR 0 4
8225: PPUSH
8226: LD_INT 107
8228: PPUSH
8229: LD_INT 74
8231: PPUSH
8232: CALL_OW 114
// wait ( 0 0$5 ) ;
8236: LD_INT 175
8238: PPUSH
8239: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8243: LD_INT 35
8245: PPUSH
8246: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
8250: LD_VAR 0 4
8254: PPUSH
8255: LD_INT 60
8257: PUSH
8258: EMPTY
8259: LIST
8260: PPUSH
8261: CALL_OW 72
8265: NOT
8266: IFFALSE 8243
// if rand ( 0 , 1 ) then
8268: LD_INT 0
8270: PPUSH
8271: LD_INT 1
8273: PPUSH
8274: CALL_OW 12
8278: IFFALSE 8297
// ComAgressiveMove ( attackers , 155 , 108 ) else
8280: LD_VAR 0 4
8284: PPUSH
8285: LD_INT 155
8287: PPUSH
8288: LD_INT 108
8290: PPUSH
8291: CALL_OW 114
8295: GO 8312
// ComAgressiveMove ( attackers , 149 , 55 ) ;
8297: LD_VAR 0 4
8301: PPUSH
8302: LD_INT 149
8304: PPUSH
8305: LD_INT 55
8307: PPUSH
8308: CALL_OW 114
// wait ( 0 0$10 ) ;
8312: LD_INT 350
8314: PPUSH
8315: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8319: LD_INT 35
8321: PPUSH
8322: CALL_OW 67
// for i in attackers do
8326: LD_ADDR_VAR 0 1
8330: PUSH
8331: LD_VAR 0 4
8335: PUSH
8336: FOR_IN
8337: IFFALSE 8387
// if not HasTask ( i ) then
8339: LD_VAR 0 1
8343: PPUSH
8344: CALL_OW 314
8348: NOT
8349: IFFALSE 8385
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8351: LD_VAR 0 1
8355: PPUSH
8356: LD_INT 81
8358: PUSH
8359: LD_INT 3
8361: PUSH
8362: EMPTY
8363: LIST
8364: LIST
8365: PPUSH
8366: CALL_OW 69
8370: PPUSH
8371: LD_VAR 0 1
8375: PPUSH
8376: CALL_OW 74
8380: PPUSH
8381: CALL_OW 115
8385: GO 8336
8387: POP
8388: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
8389: LD_VAR 0 4
8393: PPUSH
8394: LD_INT 50
8396: PUSH
8397: EMPTY
8398: LIST
8399: PPUSH
8400: CALL_OW 72
8404: NOT
8405: IFFALSE 8319
// end ;
8407: PPOPN 5
8409: END
// every 12 12$00 + 10 10$00 trigger not ruDestroyed do var i , un , tmp , amount ;
8410: LD_EXP 5
8414: NOT
8415: IFFALSE 9002
8417: GO 8419
8419: DISABLE
8420: LD_INT 0
8422: PPUSH
8423: PPUSH
8424: PPUSH
8425: PPUSH
// begin enable ;
8426: ENABLE
// if Difficulty = 1 and tick < 30 30$00 then
8427: LD_OWVAR 67
8431: PUSH
8432: LD_INT 1
8434: EQUAL
8435: PUSH
8436: LD_OWVAR 1
8440: PUSH
8441: LD_INT 63000
8443: LESS
8444: AND
8445: IFFALSE 8449
// exit ;
8447: GO 9002
// tmp := [ ] ;
8449: LD_ADDR_VAR 0 3
8453: PUSH
8454: EMPTY
8455: ST_TO_ADDR
// if tick < 45 45$00 then
8456: LD_OWVAR 1
8460: PUSH
8461: LD_INT 94500
8463: LESS
8464: IFFALSE 8641
// begin for i := 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
8466: LD_ADDR_VAR 0 1
8470: PUSH
8471: DOUBLE
8472: LD_INT 1
8474: DEC
8475: ST_TO_ADDR
8476: LD_INT 2
8478: PUSH
8479: LD_INT 3
8481: PUSH
8482: LD_INT 4
8484: PUSH
8485: EMPTY
8486: LIST
8487: LIST
8488: LIST
8489: PUSH
8490: LD_OWVAR 67
8494: ARRAY
8495: PUSH
8496: FOR_TO
8497: IFFALSE 8639
// begin uc_side := 3 ;
8499: LD_ADDR_OWVAR 20
8503: PUSH
8504: LD_INT 3
8506: ST_TO_ADDR
// uc_nation := 3 ;
8507: LD_ADDR_OWVAR 21
8511: PUSH
8512: LD_INT 3
8514: ST_TO_ADDR
// InitHC_All ( ) ;
8515: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
8519: LD_INT 0
8521: PPUSH
8522: LD_INT 1
8524: PPUSH
8525: LD_INT 5
8527: PUSH
8528: LD_INT 6
8530: PUSH
8531: LD_INT 7
8533: PUSH
8534: EMPTY
8535: LIST
8536: LIST
8537: LIST
8538: PUSH
8539: LD_OWVAR 67
8543: ARRAY
8544: PPUSH
8545: CALL_OW 380
// un := CreateHuman ;
8549: LD_ADDR_VAR 0 2
8553: PUSH
8554: CALL_OW 44
8558: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
8559: LD_VAR 0 2
8563: PPUSH
8564: LD_INT 18
8566: PPUSH
8567: LD_INT 0
8569: PPUSH
8570: CALL_OW 49
// SetClass ( un , class_bazooker ) ;
8574: LD_VAR 0 2
8578: PPUSH
8579: LD_INT 9
8581: PPUSH
8582: CALL_OW 336
// ComMoveXY ( un , 147 , 161 ) ;
8586: LD_VAR 0 2
8590: PPUSH
8591: LD_INT 147
8593: PPUSH
8594: LD_INT 161
8596: PPUSH
8597: CALL_OW 111
// wait ( 0 0$2 ) ;
8601: LD_INT 70
8603: PPUSH
8604: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8608: LD_ADDR_VAR 0 3
8612: PUSH
8613: LD_VAR 0 3
8617: PPUSH
8618: LD_VAR 0 3
8622: PUSH
8623: LD_INT 1
8625: PLUS
8626: PPUSH
8627: LD_VAR 0 2
8631: PPUSH
8632: CALL_OW 1
8636: ST_TO_ADDR
// end ;
8637: GO 8496
8639: POP
8640: POP
// end ; amount := [ 3 , 4 , 5 ] [ Difficulty ] + tick div 10 10$00 ;
8641: LD_ADDR_VAR 0 4
8645: PUSH
8646: LD_INT 3
8648: PUSH
8649: LD_INT 4
8651: PUSH
8652: LD_INT 5
8654: PUSH
8655: EMPTY
8656: LIST
8657: LIST
8658: LIST
8659: PUSH
8660: LD_OWVAR 67
8664: ARRAY
8665: PUSH
8666: LD_OWVAR 1
8670: PUSH
8671: LD_INT 21000
8673: DIV
8674: PLUS
8675: ST_TO_ADDR
// if amount > 15 then
8676: LD_VAR 0 4
8680: PUSH
8681: LD_INT 15
8683: GREATER
8684: IFFALSE 8694
// amount := 15 ;
8686: LD_ADDR_VAR 0 4
8690: PUSH
8691: LD_INT 15
8693: ST_TO_ADDR
// for i := 1 to amount do
8694: LD_ADDR_VAR 0 1
8698: PUSH
8699: DOUBLE
8700: LD_INT 1
8702: DEC
8703: ST_TO_ADDR
8704: LD_VAR 0 4
8708: PUSH
8709: FOR_TO
8710: IFFALSE 8856
// begin uc_side := 3 ;
8712: LD_ADDR_OWVAR 20
8716: PUSH
8717: LD_INT 3
8719: ST_TO_ADDR
// uc_nation := 3 ;
8720: LD_ADDR_OWVAR 21
8724: PUSH
8725: LD_INT 3
8727: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 5 ) ] , 90 ) ;
8728: LD_INT 24
8730: PPUSH
8731: LD_INT 1
8733: PPUSH
8734: LD_INT 3
8736: PPUSH
8737: LD_INT 46
8739: PUSH
8740: LD_INT 45
8742: PUSH
8743: LD_INT 44
8745: PUSH
8746: LD_INT 43
8748: PUSH
8749: LD_INT 42
8751: PUSH
8752: EMPTY
8753: LIST
8754: LIST
8755: LIST
8756: LIST
8757: LIST
8758: PUSH
8759: LD_INT 1
8761: PPUSH
8762: LD_INT 5
8764: PPUSH
8765: CALL_OW 12
8769: ARRAY
8770: PPUSH
8771: LD_INT 90
8773: PPUSH
8774: CALL 15988 0 5
// un := CreateVehicle ;
8778: LD_ADDR_VAR 0 2
8782: PUSH
8783: CALL_OW 45
8787: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
8788: LD_VAR 0 2
8792: PPUSH
8793: LD_INT 18
8795: PPUSH
8796: LD_INT 0
8798: PPUSH
8799: CALL_OW 49
// ComMoveXY ( un , 147 , 161 ) ;
8803: LD_VAR 0 2
8807: PPUSH
8808: LD_INT 147
8810: PPUSH
8811: LD_INT 161
8813: PPUSH
8814: CALL_OW 111
// wait ( 0 0$3 ) ;
8818: LD_INT 105
8820: PPUSH
8821: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8825: LD_ADDR_VAR 0 3
8829: PUSH
8830: LD_VAR 0 3
8834: PPUSH
8835: LD_VAR 0 3
8839: PUSH
8840: LD_INT 1
8842: PLUS
8843: PPUSH
8844: LD_VAR 0 2
8848: PPUSH
8849: CALL_OW 1
8853: ST_TO_ADDR
// end ;
8854: GO 8709
8856: POP
8857: POP
// if not tmp then
8858: LD_VAR 0 3
8862: NOT
8863: IFFALSE 8867
// exit ;
8865: GO 9002
// wait ( 0 0$5 ) ;
8867: LD_INT 175
8869: PPUSH
8870: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
8874: LD_INT 70
8876: PPUSH
8877: CALL_OW 67
// for i in tmp do
8881: LD_ADDR_VAR 0 1
8885: PUSH
8886: LD_VAR 0 3
8890: PUSH
8891: FOR_IN
8892: IFFALSE 8993
// begin if not IsOk ( i ) or IsDead ( i ) then
8894: LD_VAR 0 1
8898: PPUSH
8899: CALL_OW 302
8903: NOT
8904: PUSH
8905: LD_VAR 0 1
8909: PPUSH
8910: CALL_OW 301
8914: OR
8915: IFFALSE 8933
// tmp := tmp diff i ;
8917: LD_ADDR_VAR 0 3
8921: PUSH
8922: LD_VAR 0 3
8926: PUSH
8927: LD_VAR 0 1
8931: DIFF
8932: ST_TO_ADDR
// if GetClass ( i ) = class_bazooker then
8933: LD_VAR 0 1
8937: PPUSH
8938: CALL_OW 257
8942: PUSH
8943: LD_INT 9
8945: EQUAL
8946: IFFALSE 8957
// ComSpaceTimeShoot ( i ) ;
8948: LD_VAR 0 1
8952: PPUSH
8953: CALL 11920 0 1
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8957: LD_VAR 0 1
8961: PPUSH
8962: LD_INT 81
8964: PUSH
8965: LD_INT 3
8967: PUSH
8968: EMPTY
8969: LIST
8970: LIST
8971: PPUSH
8972: CALL_OW 69
8976: PPUSH
8977: LD_VAR 0 1
8981: PPUSH
8982: CALL_OW 74
8986: PPUSH
8987: CALL_OW 115
// end ;
8991: GO 8891
8993: POP
8994: POP
// until not tmp ;
8995: LD_VAR 0 3
8999: NOT
9000: IFFALSE 8874
// end ; end_of_file
9002: PPOPN 4
9004: END
// export Sikorski ; export function PrepareSikorski ; var i , j , un ; begin
9005: LD_INT 0
9007: PPUSH
9008: PPUSH
9009: PPUSH
9010: PPUSH
// uc_side := 1 ;
9011: LD_ADDR_OWVAR 20
9015: PUSH
9016: LD_INT 1
9018: ST_TO_ADDR
// uc_nation := 1 ;
9019: LD_ADDR_OWVAR 21
9023: PUSH
9024: LD_INT 1
9026: ST_TO_ADDR
// hc_importance := 100 ;
9027: LD_ADDR_OWVAR 32
9031: PUSH
9032: LD_INT 100
9034: ST_TO_ADDR
// hc_name := Jeremy Sikorski ;
9035: LD_ADDR_OWVAR 26
9039: PUSH
9040: LD_STRING Jeremy Sikorski
9042: ST_TO_ADDR
// hc_gallery := us ;
9043: LD_ADDR_OWVAR 33
9047: PUSH
9048: LD_STRING us
9050: ST_TO_ADDR
// hc_face_number := 19 ;
9051: LD_ADDR_OWVAR 34
9055: PUSH
9056: LD_INT 19
9058: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , [ 4 , 4 , 3 ] [ Difficulty ] ) ;
9059: LD_INT 1
9061: PPUSH
9062: LD_INT 1
9064: PPUSH
9065: LD_INT 4
9067: PUSH
9068: LD_INT 4
9070: PUSH
9071: LD_INT 3
9073: PUSH
9074: EMPTY
9075: LIST
9076: LIST
9077: LIST
9078: PUSH
9079: LD_OWVAR 67
9083: ARRAY
9084: PPUSH
9085: CALL_OW 380
// hc_attr := [ 10 , 12 ] ;
9089: LD_ADDR_OWVAR 29
9093: PUSH
9094: LD_INT 10
9096: PUSH
9097: LD_INT 12
9099: PUSH
9100: EMPTY
9101: LIST
9102: LIST
9103: ST_TO_ADDR
// Sikorski := CreateHuman ;
9104: LD_ADDR_EXP 20
9108: PUSH
9109: CALL_OW 44
9113: ST_TO_ADDR
// PlaceUnitXYR ( Sikorski , 133 , 19 , 2 , false ) ;
9114: LD_EXP 20
9118: PPUSH
9119: LD_INT 133
9121: PPUSH
9122: LD_INT 19
9124: PPUSH
9125: LD_INT 2
9127: PPUSH
9128: LD_INT 0
9130: PPUSH
9131: CALL_OW 50
// InitHc_All ( ) ;
9135: CALL_OW 584
// for i := 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
9139: LD_ADDR_VAR 0 2
9143: PUSH
9144: DOUBLE
9145: LD_INT 1
9147: DEC
9148: ST_TO_ADDR
9149: LD_INT 4
9151: PUSH
9152: LD_INT 3
9154: PUSH
9155: LD_INT 3
9157: PUSH
9158: EMPTY
9159: LIST
9160: LIST
9161: LIST
9162: PUSH
9163: LD_OWVAR 67
9167: ARRAY
9168: PUSH
9169: FOR_TO
9170: IFFALSE 9286
// for j := 1 to 4 do
9172: LD_ADDR_VAR 0 3
9176: PUSH
9177: DOUBLE
9178: LD_INT 1
9180: DEC
9181: ST_TO_ADDR
9182: LD_INT 4
9184: PUSH
9185: FOR_TO
9186: IFFALSE 9282
// begin PrepareHuman ( false , j , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
9188: LD_INT 0
9190: PPUSH
9191: LD_VAR 0 3
9195: PPUSH
9196: LD_INT 5
9198: PUSH
9199: LD_INT 4
9201: PUSH
9202: LD_INT 3
9204: PUSH
9205: EMPTY
9206: LIST
9207: LIST
9208: LIST
9209: PUSH
9210: LD_OWVAR 67
9214: ARRAY
9215: PPUSH
9216: CALL_OW 380
// un := CreateHuman ;
9220: LD_ADDR_VAR 0 4
9224: PUSH
9225: CALL_OW 44
9229: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
9230: LD_VAR 0 4
9234: PPUSH
9235: LD_INT 0
9237: PPUSH
9238: LD_INT 5
9240: PPUSH
9241: CALL_OW 12
9245: PPUSH
9246: CALL_OW 233
// PlaceUnitXYR ( un , 133 , 19 , 6 , false ) ;
9250: LD_VAR 0 4
9254: PPUSH
9255: LD_INT 133
9257: PPUSH
9258: LD_INT 19
9260: PPUSH
9261: LD_INT 6
9263: PPUSH
9264: LD_INT 0
9266: PPUSH
9267: CALL_OW 50
// ComHold ( un ) ;
9271: LD_VAR 0 4
9275: PPUSH
9276: CALL_OW 140
// end ;
9280: GO 9185
9282: POP
9283: POP
9284: GO 9169
9286: POP
9287: POP
// vc_chassis := us_heavy_tracked ;
9288: LD_ADDR_OWVAR 37
9292: PUSH
9293: LD_INT 4
9295: ST_TO_ADDR
// vc_engine := engine_combustion ;
9296: LD_ADDR_OWVAR 39
9300: PUSH
9301: LD_INT 1
9303: ST_TO_ADDR
// vc_control := control_manual ;
9304: LD_ADDR_OWVAR 38
9308: PUSH
9309: LD_INT 1
9311: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
9312: LD_ADDR_OWVAR 40
9316: PUSH
9317: LD_INT 14
9319: ST_TO_ADDR
// vc_fuel_battery := 60 ;
9320: LD_ADDR_OWVAR 41
9324: PUSH
9325: LD_INT 60
9327: ST_TO_ADDR
// un := CreateVehicle ;
9328: LD_ADDR_VAR 0 4
9332: PUSH
9333: CALL_OW 45
9337: ST_TO_ADDR
// SetDir ( un , 2 ) ;
9338: LD_VAR 0 4
9342: PPUSH
9343: LD_INT 2
9345: PPUSH
9346: CALL_OW 233
// PlaceUnitXY ( un , 128 , 12 , false ) ;
9350: LD_VAR 0 4
9354: PPUSH
9355: LD_INT 128
9357: PPUSH
9358: LD_INT 12
9360: PPUSH
9361: LD_INT 0
9363: PPUSH
9364: CALL_OW 48
// for i := 1 to 3 do
9368: LD_ADDR_VAR 0 2
9372: PUSH
9373: DOUBLE
9374: LD_INT 1
9376: DEC
9377: ST_TO_ADDR
9378: LD_INT 3
9380: PUSH
9381: FOR_TO
9382: IFFALSE 9405
// CreateCratesXYR ( 5 , 133 , 19 , 3 , false ) ;
9384: LD_INT 5
9386: PPUSH
9387: LD_INT 133
9389: PPUSH
9390: LD_INT 19
9392: PPUSH
9393: LD_INT 3
9395: PPUSH
9396: LD_INT 0
9398: PPUSH
9399: CALL_OW 56
9403: GO 9381
9405: POP
9406: POP
// end ; end_of_file
9407: LD_VAR 0 1
9411: RET
// export function Action ; begin
9412: LD_INT 0
9414: PPUSH
// InGameOn ;
9415: CALL_OW 8
// CenterNowOnXY ( 133 , 19 ) ;
9419: LD_INT 133
9421: PPUSH
9422: LD_INT 19
9424: PPUSH
9425: CALL_OW 86
// Say ( Sikorski , WT-DS-1 ) ;
9429: LD_EXP 20
9433: PPUSH
9434: LD_STRING WT-DS-1
9436: PPUSH
9437: CALL_OW 88
// InGameOff ;
9441: CALL_OW 9
// ChangeMissionObjectives ( DestroyEnemy ) ;
9445: LD_STRING DestroyEnemy
9447: PPUSH
9448: CALL_OW 337
// wait ( 0 0$20 ) ;
9452: LD_INT 700
9454: PPUSH
9455: CALL_OW 67
// DialogueOn ;
9459: CALL_OW 6
// PlaceSeeing ( 100 , 37 , 1 , - 30 ) ;
9463: LD_INT 100
9465: PPUSH
9466: LD_INT 37
9468: PPUSH
9469: LD_INT 1
9471: PPUSH
9472: LD_INT 30
9474: NEG
9475: PPUSH
9476: CALL_OW 330
// CenterNowOnXY ( 100 , 37 ) ;
9480: LD_INT 100
9482: PPUSH
9483: LD_INT 37
9485: PPUSH
9486: CALL_OW 86
// SayRadio ( Powell , WT-PL-1 ) ;
9490: LD_EXP 10
9494: PPUSH
9495: LD_STRING WT-PL-1
9497: PPUSH
9498: CALL_OW 94
// Say ( Sikorski , WT-DS-2 ) ;
9502: LD_EXP 20
9506: PPUSH
9507: LD_STRING WT-DS-2
9509: PPUSH
9510: CALL_OW 88
// DialogueOff ;
9514: CALL_OW 7
// wait ( 0 0$2 ) ;
9518: LD_INT 70
9520: PPUSH
9521: CALL_OW 67
// RemoveSeeing ( 100 , 37 , 1 ) ;
9525: LD_INT 100
9527: PPUSH
9528: LD_INT 37
9530: PPUSH
9531: LD_INT 1
9533: PPUSH
9534: CALL_OW 331
// end ;
9538: LD_VAR 0 1
9542: RET
// export function DialogPowellsAttack ; begin
9543: LD_INT 0
9545: PPUSH
// SayRadio ( Powell , WT-PL-8 ) ;
9546: LD_EXP 10
9550: PPUSH
9551: LD_STRING WT-PL-8
9553: PPUSH
9554: CALL_OW 94
// end ;
9558: LD_VAR 0 1
9562: RET
// export function DialogContaminateSib ( x , y ) ; begin
9563: LD_INT 0
9565: PPUSH
// DialogueOn ;
9566: CALL_OW 6
// CenterNowOnXY ( x , y ) ;
9570: LD_VAR 0 1
9574: PPUSH
9575: LD_VAR 0 2
9579: PPUSH
9580: CALL_OW 86
// Say ( Sikorski , WT-DS-3 ) ;
9584: LD_EXP 20
9588: PPUSH
9589: LD_STRING WT-DS-3
9591: PPUSH
9592: CALL_OW 88
// DialogueOff ;
9596: CALL_OW 7
// end ;
9600: LD_VAR 0 3
9604: RET
// every 0 0$3 trigger not powellInTrouble and FilterUnitsInArea ( powell_base , [ f_enemy , 4 ] ) > 3 do
9605: LD_EXP 8
9609: NOT
9610: PUSH
9611: LD_INT 1
9613: PPUSH
9614: LD_INT 81
9616: PUSH
9617: LD_INT 4
9619: PUSH
9620: EMPTY
9621: LIST
9622: LIST
9623: PPUSH
9624: CALL_OW 70
9628: PUSH
9629: LD_INT 3
9631: GREATER
9632: AND
9633: IFFALSE 9705
9635: GO 9637
9637: DISABLE
// begin powellInTrouble := true ;
9638: LD_ADDR_EXP 8
9642: PUSH
9643: LD_INT 1
9645: ST_TO_ADDR
// Say ( Sikorski , WT-DS-6 ) ;
9646: LD_EXP 20
9650: PPUSH
9651: LD_STRING WT-DS-6
9653: PPUSH
9654: CALL_OW 88
// if not FilterUnitsInArea ( powell_base , [ f_side , 1 ] ) then
9658: LD_INT 1
9660: PPUSH
9661: LD_INT 22
9663: PUSH
9664: LD_INT 1
9666: PUSH
9667: EMPTY
9668: LIST
9669: LIST
9670: PPUSH
9671: CALL_OW 70
9675: NOT
9676: IFFALSE 9690
// SayRadio ( Powell , WT-PL-6 ) ;
9678: LD_EXP 10
9682: PPUSH
9683: LD_STRING WT-PL-6
9685: PPUSH
9686: CALL_OW 94
// wait ( 1 1$30 ) ;
9690: LD_INT 3150
9692: PPUSH
9693: CALL_OW 67
// powellInTrouble := false ;
9697: LD_ADDR_EXP 8
9701: PUSH
9702: LD_INT 0
9704: ST_TO_ADDR
// end ;
9705: END
// every 0 0$3 trigger not sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 1 ] ) > 6 do
9706: LD_EXP 9
9710: NOT
9711: PUSH
9712: LD_INT 16
9714: PPUSH
9715: LD_INT 81
9717: PUSH
9718: LD_INT 1
9720: PUSH
9721: EMPTY
9722: LIST
9723: LIST
9724: PPUSH
9725: CALL_OW 70
9729: PUSH
9730: LD_INT 6
9732: GREATER
9733: AND
9734: IFFALSE 9807
9736: GO 9738
9738: DISABLE
// begin sikorskiInTrouble := true ;
9739: LD_ADDR_EXP 9
9743: PUSH
9744: LD_INT 1
9746: ST_TO_ADDR
// Say ( Sikorski , WT-DS-7 ) ;
9747: LD_EXP 20
9751: PPUSH
9752: LD_STRING WT-DS-7
9754: PPUSH
9755: CALL_OW 88
// if not powellAttackGroup then
9759: LD_EXP 12
9763: NOT
9764: IFFALSE 9780
// SayRadio ( Powell , WT-PL-7n ) else
9766: LD_EXP 10
9770: PPUSH
9771: LD_STRING WT-PL-7n
9773: PPUSH
9774: CALL_OW 94
9778: GO 9792
// SayRadio ( Powell , WT-PL-7y ) ;
9780: LD_EXP 10
9784: PPUSH
9785: LD_STRING WT-PL-7y
9787: PPUSH
9788: CALL_OW 94
// wait ( 1 1$30 ) ;
9792: LD_INT 3150
9794: PPUSH
9795: CALL_OW 67
// sikorskiInTrouble := false ;
9799: LD_ADDR_EXP 9
9803: PUSH
9804: LD_INT 0
9806: ST_TO_ADDR
// end ;
9807: END
// export function DialogPowellsAttackFailed ; begin
9808: LD_INT 0
9810: PPUSH
// if not ruDestroyed then
9811: LD_EXP 5
9815: NOT
9816: IFFALSE 9832
// SayRadio ( Powell , WT-PL-9 ) else
9818: LD_EXP 10
9822: PPUSH
9823: LD_STRING WT-PL-9
9825: PPUSH
9826: CALL_OW 94
9830: GO 9844
// SayRadio ( Powell , WT-PL-10 ) ;
9832: LD_EXP 10
9836: PPUSH
9837: LD_STRING WT-PL-10
9839: PPUSH
9840: CALL_OW 94
// end ;
9844: LD_VAR 0 1
9848: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
9849: LD_INT 22
9851: PUSH
9852: LD_INT 2
9854: PUSH
9855: EMPTY
9856: LIST
9857: LIST
9858: PUSH
9859: LD_INT 21
9861: PUSH
9862: LD_INT 1
9864: PUSH
9865: EMPTY
9866: LIST
9867: LIST
9868: PUSH
9869: EMPTY
9870: LIST
9871: LIST
9872: PPUSH
9873: CALL_OW 69
9877: PUSH
9878: LD_INT 0
9880: EQUAL
9881: IFFALSE 9925
9883: GO 9885
9885: DISABLE
// begin arDestroyed := true ;
9886: LD_ADDR_EXP 4
9890: PUSH
9891: LD_INT 1
9893: ST_TO_ADDR
// MC_Kill ( 2 ) ;
9894: LD_INT 2
9896: PPUSH
9897: CALL 52615 0 1
// Say ( Sikorski , WT-DS-4 ) ;
9901: LD_EXP 20
9905: PPUSH
9906: LD_STRING WT-DS-4
9908: PPUSH
9909: CALL_OW 88
// SayRadio ( Powell , WT-PL-4 ) ;
9913: LD_EXP 10
9917: PPUSH
9918: LD_STRING WT-PL-4
9920: PPUSH
9921: CALL_OW 94
// end ;
9925: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
9926: LD_INT 22
9928: PUSH
9929: LD_INT 3
9931: PUSH
9932: EMPTY
9933: LIST
9934: LIST
9935: PUSH
9936: LD_INT 21
9938: PUSH
9939: LD_INT 1
9941: PUSH
9942: EMPTY
9943: LIST
9944: LIST
9945: PUSH
9946: EMPTY
9947: LIST
9948: LIST
9949: PPUSH
9950: CALL_OW 69
9954: PUSH
9955: LD_INT 0
9957: EQUAL
9958: IFFALSE 10002
9960: GO 9962
9962: DISABLE
// begin ruDestroyed := true ;
9963: LD_ADDR_EXP 5
9967: PUSH
9968: LD_INT 1
9970: ST_TO_ADDR
// MC_Kill ( 3 ) ;
9971: LD_INT 3
9973: PPUSH
9974: CALL 52615 0 1
// Say ( Sikorski , WT-DS-5 ) ;
9978: LD_EXP 20
9982: PPUSH
9983: LD_STRING WT-DS-5
9985: PPUSH
9986: CALL_OW 88
// SayRadio ( Powell , WT-PL-5 ) ;
9990: LD_EXP 10
9994: PPUSH
9995: LD_STRING WT-PL-5
9997: PPUSH
9998: CALL_OW 94
// end ;
10002: END
// every 0 0$1 trigger ruDestroyed and arDestroyed do
10003: LD_EXP 5
10007: PUSH
10008: LD_EXP 4
10012: AND
10013: IFFALSE 10186
10015: GO 10017
10017: DISABLE
// begin wait ( 0 0$3 ) ;
10018: LD_INT 105
10020: PPUSH
10021: CALL_OW 67
// if tick >= [ 60 60$00 , 50 50$00 , 45 45$00 ] [ Difficulty ] then
10025: LD_OWVAR 1
10029: PUSH
10030: LD_INT 126000
10032: PUSH
10033: LD_INT 105000
10035: PUSH
10036: LD_INT 94500
10038: PUSH
10039: EMPTY
10040: LIST
10041: LIST
10042: LIST
10043: PUSH
10044: LD_OWVAR 67
10048: ARRAY
10049: GREATEREQUAL
10050: IFFALSE 10065
// AddMedal ( WoT-med-1 , - 1 ) else
10052: LD_STRING WoT-med-1
10054: PPUSH
10055: LD_INT 1
10057: NEG
10058: PPUSH
10059: CALL_OW 101
10063: GO 10075
// AddMedal ( WoT-med-1 , 1 ) ;
10065: LD_STRING WoT-med-1
10067: PPUSH
10068: LD_INT 1
10070: PPUSH
10071: CALL_OW 101
// if loseCounter >= [ 4 , 3 , 2 ] [ Difficulty ] then
10075: LD_EXP 6
10079: PUSH
10080: LD_INT 4
10082: PUSH
10083: LD_INT 3
10085: PUSH
10086: LD_INT 2
10088: PUSH
10089: EMPTY
10090: LIST
10091: LIST
10092: LIST
10093: PUSH
10094: LD_OWVAR 67
10098: ARRAY
10099: GREATEREQUAL
10100: IFFALSE 10115
// AddMedal ( WoT-med-2 , - 1 ) else
10102: LD_STRING WoT-med-2
10104: PPUSH
10105: LD_INT 1
10107: NEG
10108: PPUSH
10109: CALL_OW 101
10113: GO 10125
// AddMedal ( WoT-med-2 , 1 ) ;
10115: LD_STRING WoT-med-2
10117: PPUSH
10118: LD_INT 1
10120: PPUSH
10121: CALL_OW 101
// if powellLoseCounter >= [ 8 , 6 , 5 ] [ Difficulty ] then
10125: LD_EXP 7
10129: PUSH
10130: LD_INT 8
10132: PUSH
10133: LD_INT 6
10135: PUSH
10136: LD_INT 5
10138: PUSH
10139: EMPTY
10140: LIST
10141: LIST
10142: LIST
10143: PUSH
10144: LD_OWVAR 67
10148: ARRAY
10149: GREATEREQUAL
10150: IFFALSE 10165
// AddMedal ( WoT-med-3 , - 1 ) else
10152: LD_STRING WoT-med-3
10154: PPUSH
10155: LD_INT 1
10157: NEG
10158: PPUSH
10159: CALL_OW 101
10163: GO 10175
// AddMedal ( WoT-med-3 , 1 ) ;
10165: LD_STRING WoT-med-3
10167: PPUSH
10168: LD_INT 1
10170: PPUSH
10171: CALL_OW 101
// GiveMedals ( MAIN ) ;
10175: LD_STRING MAIN
10177: PPUSH
10178: CALL_OW 102
// YouWin ;
10182: CALL_OW 103
// end ; end_of_file
10186: END
// export function CustomEvent ( event ) ; begin
10187: LD_INT 0
10189: PPUSH
// end ;
10190: LD_VAR 0 2
10194: RET
// on Command ( com ) do var i , j , temp ;
10195: LD_INT 0
10197: PPUSH
10198: PPUSH
10199: PPUSH
// begin if com = 60 then
10200: LD_VAR 0 1
10204: PUSH
10205: LD_INT 60
10207: EQUAL
10208: IFFALSE 10387
// begin for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_weapon , us_cargo_bay ] ] ] ) do
10210: LD_ADDR_VAR 0 2
10214: PUSH
10215: LD_INT 22
10217: PUSH
10218: LD_INT 1
10220: PUSH
10221: EMPTY
10222: LIST
10223: LIST
10224: PUSH
10225: LD_INT 2
10227: PUSH
10228: LD_INT 21
10230: PUSH
10231: LD_INT 1
10233: PUSH
10234: EMPTY
10235: LIST
10236: LIST
10237: PUSH
10238: LD_INT 34
10240: PUSH
10241: LD_INT 12
10243: PUSH
10244: EMPTY
10245: LIST
10246: LIST
10247: PUSH
10248: EMPTY
10249: LIST
10250: LIST
10251: LIST
10252: PUSH
10253: EMPTY
10254: LIST
10255: LIST
10256: PPUSH
10257: CALL_OW 69
10261: PUSH
10262: FOR_IN
10263: IFFALSE 10385
// begin if GetTaskList ( i ) > 0 then
10265: LD_VAR 0 2
10269: PPUSH
10270: CALL_OW 437
10274: PUSH
10275: LD_INT 0
10277: GREATER
10278: IFFALSE 10383
// for j = 1 to GetTaskList ( i ) do
10280: LD_ADDR_VAR 0 3
10284: PUSH
10285: DOUBLE
10286: LD_INT 1
10288: DEC
10289: ST_TO_ADDR
10290: LD_VAR 0 2
10294: PPUSH
10295: CALL_OW 437
10299: PUSH
10300: FOR_TO
10301: IFFALSE 10381
// begin temp = GetTaskList ( i ) [ j ] [ 4 ] ;
10303: LD_ADDR_VAR 0 4
10307: PUSH
10308: LD_VAR 0 2
10312: PPUSH
10313: CALL_OW 437
10317: PUSH
10318: LD_VAR 0 3
10322: ARRAY
10323: PUSH
10324: LD_INT 4
10326: ARRAY
10327: ST_TO_ADDR
// if GetSide ( temp ) = 4 and GetTaskList ( i ) [ j ] [ 1 ] = < then
10328: LD_VAR 0 4
10332: PPUSH
10333: CALL_OW 255
10337: PUSH
10338: LD_INT 4
10340: EQUAL
10341: PUSH
10342: LD_VAR 0 2
10346: PPUSH
10347: CALL_OW 437
10351: PUSH
10352: LD_VAR 0 3
10356: ARRAY
10357: PUSH
10358: LD_INT 1
10360: ARRAY
10361: PUSH
10362: LD_STRING <
10364: EQUAL
10365: AND
10366: IFFALSE 10379
// SetTaskList ( i , [ ] ) ;
10368: LD_VAR 0 2
10372: PPUSH
10373: EMPTY
10374: PPUSH
10375: CALL_OW 446
// end ;
10379: GO 10300
10381: POP
10382: POP
// end ;
10383: GO 10262
10385: POP
10386: POP
// end ; end ;
10387: PPOPN 4
10389: END
// on SibDepositContaminated ( sci , x , y ) do begin if GetSide ( HexInfo ( x , y ) ) = 1 or ( x = 132 and y = 39 ) then
10390: LD_VAR 0 2
10394: PPUSH
10395: LD_VAR 0 3
10399: PPUSH
10400: CALL_OW 428
10404: PPUSH
10405: CALL_OW 255
10409: PUSH
10410: LD_INT 1
10412: EQUAL
10413: PUSH
10414: LD_VAR 0 2
10418: PUSH
10419: LD_INT 132
10421: EQUAL
10422: PUSH
10423: LD_VAR 0 3
10427: PUSH
10428: LD_INT 39
10430: EQUAL
10431: AND
10432: OR
10433: IFFALSE 10449
// DialogContaminateSib ( x , y ) ;
10435: LD_VAR 0 2
10439: PPUSH
10440: LD_VAR 0 3
10444: PPUSH
10445: CALL 9563 0 2
// end ;
10449: PPOPN 3
10451: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
10452: LD_VAR 0 1
10456: PPUSH
10457: CALL 90331 0 1
// MCE_UnitDestroyed ( un ) ;
10461: LD_VAR 0 1
10465: PPUSH
10466: CALL 80046 0 1
// if un = Powell then
10470: LD_VAR 0 1
10474: PUSH
10475: LD_EXP 10
10479: EQUAL
10480: IFFALSE 10489
// YouLost ( Powell ) ;
10482: LD_STRING Powell
10484: PPUSH
10485: CALL_OW 104
// if un = Sikorski then
10489: LD_VAR 0 1
10493: PUSH
10494: LD_EXP 20
10498: EQUAL
10499: IFFALSE 10508
// YouLost ( Sikorski ) ;
10501: LD_STRING Sikorski
10503: PPUSH
10504: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) then
10508: LD_VAR 0 1
10512: PUSH
10513: LD_INT 22
10515: PUSH
10516: LD_INT 1
10518: PUSH
10519: EMPTY
10520: LIST
10521: LIST
10522: PUSH
10523: LD_INT 21
10525: PUSH
10526: LD_INT 1
10528: PUSH
10529: EMPTY
10530: LIST
10531: LIST
10532: PUSH
10533: EMPTY
10534: LIST
10535: LIST
10536: PPUSH
10537: CALL_OW 69
10541: IN
10542: IFFALSE 10558
// loseCounter := loseCounter + 1 ;
10544: LD_ADDR_EXP 6
10548: PUSH
10549: LD_EXP 6
10553: PUSH
10554: LD_INT 1
10556: PLUS
10557: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) then
10558: LD_VAR 0 1
10562: PUSH
10563: LD_INT 22
10565: PUSH
10566: LD_INT 4
10568: PUSH
10569: EMPTY
10570: LIST
10571: LIST
10572: PUSH
10573: LD_INT 21
10575: PUSH
10576: LD_INT 1
10578: PUSH
10579: EMPTY
10580: LIST
10581: LIST
10582: PUSH
10583: EMPTY
10584: LIST
10585: LIST
10586: PPUSH
10587: CALL_OW 69
10591: IN
10592: IFFALSE 10608
// powellLoseCounter := powellLoseCounter + 1 ;
10594: LD_ADDR_EXP 7
10598: PUSH
10599: LD_EXP 7
10603: PUSH
10604: LD_INT 1
10606: PLUS
10607: ST_TO_ADDR
// if un in powellAttackGroup then
10608: LD_VAR 0 1
10612: PUSH
10613: LD_EXP 12
10617: IN
10618: IFFALSE 10636
// powellAttackGroup := powellAttackGroup diff un ;
10620: LD_ADDR_EXP 12
10624: PUSH
10625: LD_EXP 12
10629: PUSH
10630: LD_VAR 0 1
10634: DIFF
10635: ST_TO_ADDR
// if un in gensherAttackGroup then
10636: LD_VAR 0 1
10640: PUSH
10641: LD_EXP 15
10645: IN
10646: IFFALSE 10664
// gensherAttackGroup := gensherAttackGroup diff un ;
10648: LD_ADDR_EXP 15
10652: PUSH
10653: LD_EXP 15
10657: PUSH
10658: LD_VAR 0 1
10662: DIFF
10663: ST_TO_ADDR
// if un in popovAttackGroup then
10664: LD_VAR 0 1
10668: PUSH
10669: LD_EXP 19
10673: IN
10674: IFFALSE 10692
// popovAttackGroup := popovAttackGroup diff un ;
10676: LD_ADDR_EXP 19
10680: PUSH
10681: LD_EXP 19
10685: PUSH
10686: LD_VAR 0 1
10690: DIFF
10691: ST_TO_ADDR
// end ;
10692: PPOPN 1
10694: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10695: LD_VAR 0 1
10699: PPUSH
10700: LD_VAR 0 2
10704: PPUSH
10705: CALL 82378 0 2
// end ;
10709: PPOPN 2
10711: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10712: LD_VAR 0 1
10716: PPUSH
10717: CALL 81446 0 1
// end ;
10721: PPOPN 1
10723: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
10724: LD_VAR 0 1
10728: PPUSH
10729: CALL 81687 0 1
// end ;
10733: PPOPN 1
10735: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10736: LD_VAR 0 1
10740: PPUSH
10741: LD_VAR 0 2
10745: PPUSH
10746: CALL 79742 0 2
// end ;
10750: PPOPN 2
10752: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10753: LD_VAR 0 1
10757: PPUSH
10758: LD_VAR 0 2
10762: PPUSH
10763: LD_VAR 0 3
10767: PPUSH
10768: LD_VAR 0 4
10772: PPUSH
10773: LD_VAR 0 5
10777: PPUSH
10778: CALL 79362 0 5
// end ;
10782: PPOPN 5
10784: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
10785: LD_VAR 0 1
10789: PPUSH
10790: LD_VAR 0 2
10794: PPUSH
10795: CALL 90451 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
10799: LD_VAR 0 1
10803: PPUSH
10804: LD_VAR 0 2
10808: PPUSH
10809: CALL 78953 0 2
// end ;
10813: PPOPN 2
10815: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10816: LD_VAR 0 1
10820: PPUSH
10821: LD_VAR 0 2
10825: PPUSH
10826: LD_VAR 0 3
10830: PPUSH
10831: LD_VAR 0 4
10835: PPUSH
10836: CALL 78791 0 4
// end ;
10840: PPOPN 4
10842: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10843: LD_VAR 0 1
10847: PPUSH
10848: LD_VAR 0 2
10852: PPUSH
10853: LD_VAR 0 3
10857: PPUSH
10858: CALL 78566 0 3
// end ;
10862: PPOPN 3
10864: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10865: LD_VAR 0 1
10869: PPUSH
10870: LD_VAR 0 2
10874: PPUSH
10875: CALL 78451 0 2
// end ;
10879: PPOPN 2
10881: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10882: LD_VAR 0 1
10886: PPUSH
10887: LD_VAR 0 2
10891: PPUSH
10892: CALL 82673 0 2
// end ;
10896: PPOPN 2
10898: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10899: LD_VAR 0 1
10903: PPUSH
10904: LD_VAR 0 2
10908: PPUSH
10909: LD_VAR 0 3
10913: PPUSH
10914: LD_VAR 0 4
10918: PPUSH
10919: CALL 82889 0 4
// end ;
10923: PPOPN 4
10925: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10926: LD_VAR 0 1
10930: PPUSH
10931: LD_VAR 0 2
10935: PPUSH
10936: CALL 78260 0 2
// end ;
10940: PPOPN 2
10942: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 then
10943: LD_VAR 0 1
10947: PUSH
10948: LD_INT 1
10950: EQUAL
10951: PUSH
10952: LD_VAR 0 2
10956: PUSH
10957: LD_INT 4
10959: EQUAL
10960: AND
10961: IFFALSE 10970
// YouLost ( FriendlyFire ) ;
10963: LD_STRING FriendlyFire
10965: PPUSH
10966: CALL_OW 104
// end ; end_of_file
10970: PPOPN 2
10972: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
10973: LD_INT 0
10975: PPUSH
10976: PPUSH
// if exist_mode then
10977: LD_VAR 0 2
10981: IFFALSE 11006
// unit := CreateCharacter ( prefix & ident ) else
10983: LD_ADDR_VAR 0 5
10987: PUSH
10988: LD_VAR 0 3
10992: PUSH
10993: LD_VAR 0 1
10997: STR
10998: PPUSH
10999: CALL_OW 34
11003: ST_TO_ADDR
11004: GO 11021
// unit := NewCharacter ( ident ) ;
11006: LD_ADDR_VAR 0 5
11010: PUSH
11011: LD_VAR 0 1
11015: PPUSH
11016: CALL_OW 25
11020: ST_TO_ADDR
// result := unit ;
11021: LD_ADDR_VAR 0 4
11025: PUSH
11026: LD_VAR 0 5
11030: ST_TO_ADDR
// end ;
11031: LD_VAR 0 4
11035: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
11036: LD_INT 0
11038: PPUSH
11039: PPUSH
// if not side or not nation then
11040: LD_VAR 0 1
11044: NOT
11045: PUSH
11046: LD_VAR 0 2
11050: NOT
11051: OR
11052: IFFALSE 11056
// exit ;
11054: GO 11824
// case nation of nation_american :
11056: LD_VAR 0 2
11060: PUSH
11061: LD_INT 1
11063: DOUBLE
11064: EQUAL
11065: IFTRUE 11069
11067: GO 11283
11069: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
11070: LD_ADDR_VAR 0 4
11074: PUSH
11075: LD_INT 35
11077: PUSH
11078: LD_INT 45
11080: PUSH
11081: LD_INT 46
11083: PUSH
11084: LD_INT 47
11086: PUSH
11087: LD_INT 82
11089: PUSH
11090: LD_INT 83
11092: PUSH
11093: LD_INT 84
11095: PUSH
11096: LD_INT 85
11098: PUSH
11099: LD_INT 86
11101: PUSH
11102: LD_INT 1
11104: PUSH
11105: LD_INT 2
11107: PUSH
11108: LD_INT 6
11110: PUSH
11111: LD_INT 15
11113: PUSH
11114: LD_INT 16
11116: PUSH
11117: LD_INT 7
11119: PUSH
11120: LD_INT 12
11122: PUSH
11123: LD_INT 13
11125: PUSH
11126: LD_INT 10
11128: PUSH
11129: LD_INT 14
11131: PUSH
11132: LD_INT 20
11134: PUSH
11135: LD_INT 21
11137: PUSH
11138: LD_INT 22
11140: PUSH
11141: LD_INT 25
11143: PUSH
11144: LD_INT 32
11146: PUSH
11147: LD_INT 27
11149: PUSH
11150: LD_INT 36
11152: PUSH
11153: LD_INT 69
11155: PUSH
11156: LD_INT 39
11158: PUSH
11159: LD_INT 34
11161: PUSH
11162: LD_INT 40
11164: PUSH
11165: LD_INT 48
11167: PUSH
11168: LD_INT 49
11170: PUSH
11171: LD_INT 50
11173: PUSH
11174: LD_INT 51
11176: PUSH
11177: LD_INT 52
11179: PUSH
11180: LD_INT 53
11182: PUSH
11183: LD_INT 54
11185: PUSH
11186: LD_INT 55
11188: PUSH
11189: LD_INT 56
11191: PUSH
11192: LD_INT 57
11194: PUSH
11195: LD_INT 58
11197: PUSH
11198: LD_INT 59
11200: PUSH
11201: LD_INT 60
11203: PUSH
11204: LD_INT 61
11206: PUSH
11207: LD_INT 62
11209: PUSH
11210: LD_INT 80
11212: PUSH
11213: LD_INT 82
11215: PUSH
11216: LD_INT 83
11218: PUSH
11219: LD_INT 84
11221: PUSH
11222: LD_INT 85
11224: PUSH
11225: LD_INT 86
11227: PUSH
11228: EMPTY
11229: LIST
11230: LIST
11231: LIST
11232: LIST
11233: LIST
11234: LIST
11235: LIST
11236: LIST
11237: LIST
11238: LIST
11239: LIST
11240: LIST
11241: LIST
11242: LIST
11243: LIST
11244: LIST
11245: LIST
11246: LIST
11247: LIST
11248: LIST
11249: LIST
11250: LIST
11251: LIST
11252: LIST
11253: LIST
11254: LIST
11255: LIST
11256: LIST
11257: LIST
11258: LIST
11259: LIST
11260: LIST
11261: LIST
11262: LIST
11263: LIST
11264: LIST
11265: LIST
11266: LIST
11267: LIST
11268: LIST
11269: LIST
11270: LIST
11271: LIST
11272: LIST
11273: LIST
11274: LIST
11275: LIST
11276: LIST
11277: LIST
11278: LIST
11279: LIST
11280: ST_TO_ADDR
11281: GO 11748
11283: LD_INT 2
11285: DOUBLE
11286: EQUAL
11287: IFTRUE 11291
11289: GO 11517
11291: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
11292: LD_ADDR_VAR 0 4
11296: PUSH
11297: LD_INT 35
11299: PUSH
11300: LD_INT 45
11302: PUSH
11303: LD_INT 46
11305: PUSH
11306: LD_INT 47
11308: PUSH
11309: LD_INT 82
11311: PUSH
11312: LD_INT 83
11314: PUSH
11315: LD_INT 84
11317: PUSH
11318: LD_INT 85
11320: PUSH
11321: LD_INT 87
11323: PUSH
11324: LD_INT 70
11326: PUSH
11327: LD_INT 1
11329: PUSH
11330: LD_INT 11
11332: PUSH
11333: LD_INT 3
11335: PUSH
11336: LD_INT 4
11338: PUSH
11339: LD_INT 5
11341: PUSH
11342: LD_INT 6
11344: PUSH
11345: LD_INT 15
11347: PUSH
11348: LD_INT 18
11350: PUSH
11351: LD_INT 7
11353: PUSH
11354: LD_INT 17
11356: PUSH
11357: LD_INT 8
11359: PUSH
11360: LD_INT 20
11362: PUSH
11363: LD_INT 21
11365: PUSH
11366: LD_INT 22
11368: PUSH
11369: LD_INT 72
11371: PUSH
11372: LD_INT 26
11374: PUSH
11375: LD_INT 69
11377: PUSH
11378: LD_INT 39
11380: PUSH
11381: LD_INT 40
11383: PUSH
11384: LD_INT 41
11386: PUSH
11387: LD_INT 42
11389: PUSH
11390: LD_INT 43
11392: PUSH
11393: LD_INT 48
11395: PUSH
11396: LD_INT 49
11398: PUSH
11399: LD_INT 50
11401: PUSH
11402: LD_INT 51
11404: PUSH
11405: LD_INT 52
11407: PUSH
11408: LD_INT 53
11410: PUSH
11411: LD_INT 54
11413: PUSH
11414: LD_INT 55
11416: PUSH
11417: LD_INT 56
11419: PUSH
11420: LD_INT 60
11422: PUSH
11423: LD_INT 61
11425: PUSH
11426: LD_INT 62
11428: PUSH
11429: LD_INT 66
11431: PUSH
11432: LD_INT 67
11434: PUSH
11435: LD_INT 68
11437: PUSH
11438: LD_INT 81
11440: PUSH
11441: LD_INT 82
11443: PUSH
11444: LD_INT 83
11446: PUSH
11447: LD_INT 84
11449: PUSH
11450: LD_INT 85
11452: PUSH
11453: LD_INT 87
11455: PUSH
11456: LD_INT 88
11458: PUSH
11459: EMPTY
11460: LIST
11461: LIST
11462: LIST
11463: LIST
11464: LIST
11465: LIST
11466: LIST
11467: LIST
11468: LIST
11469: LIST
11470: LIST
11471: LIST
11472: LIST
11473: LIST
11474: LIST
11475: LIST
11476: LIST
11477: LIST
11478: LIST
11479: LIST
11480: LIST
11481: LIST
11482: LIST
11483: LIST
11484: LIST
11485: LIST
11486: LIST
11487: LIST
11488: LIST
11489: LIST
11490: LIST
11491: LIST
11492: LIST
11493: LIST
11494: LIST
11495: LIST
11496: LIST
11497: LIST
11498: LIST
11499: LIST
11500: LIST
11501: LIST
11502: LIST
11503: LIST
11504: LIST
11505: LIST
11506: LIST
11507: LIST
11508: LIST
11509: LIST
11510: LIST
11511: LIST
11512: LIST
11513: LIST
11514: ST_TO_ADDR
11515: GO 11748
11517: LD_INT 3
11519: DOUBLE
11520: EQUAL
11521: IFTRUE 11525
11523: GO 11747
11525: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
11526: LD_ADDR_VAR 0 4
11530: PUSH
11531: LD_INT 46
11533: PUSH
11534: LD_INT 47
11536: PUSH
11537: LD_INT 1
11539: PUSH
11540: LD_INT 2
11542: PUSH
11543: LD_INT 82
11545: PUSH
11546: LD_INT 83
11548: PUSH
11549: LD_INT 84
11551: PUSH
11552: LD_INT 85
11554: PUSH
11555: LD_INT 86
11557: PUSH
11558: LD_INT 11
11560: PUSH
11561: LD_INT 9
11563: PUSH
11564: LD_INT 20
11566: PUSH
11567: LD_INT 19
11569: PUSH
11570: LD_INT 21
11572: PUSH
11573: LD_INT 24
11575: PUSH
11576: LD_INT 22
11578: PUSH
11579: LD_INT 25
11581: PUSH
11582: LD_INT 28
11584: PUSH
11585: LD_INT 29
11587: PUSH
11588: LD_INT 30
11590: PUSH
11591: LD_INT 31
11593: PUSH
11594: LD_INT 37
11596: PUSH
11597: LD_INT 38
11599: PUSH
11600: LD_INT 32
11602: PUSH
11603: LD_INT 27
11605: PUSH
11606: LD_INT 33
11608: PUSH
11609: LD_INT 69
11611: PUSH
11612: LD_INT 39
11614: PUSH
11615: LD_INT 34
11617: PUSH
11618: LD_INT 40
11620: PUSH
11621: LD_INT 71
11623: PUSH
11624: LD_INT 23
11626: PUSH
11627: LD_INT 44
11629: PUSH
11630: LD_INT 48
11632: PUSH
11633: LD_INT 49
11635: PUSH
11636: LD_INT 50
11638: PUSH
11639: LD_INT 51
11641: PUSH
11642: LD_INT 52
11644: PUSH
11645: LD_INT 53
11647: PUSH
11648: LD_INT 54
11650: PUSH
11651: LD_INT 55
11653: PUSH
11654: LD_INT 56
11656: PUSH
11657: LD_INT 57
11659: PUSH
11660: LD_INT 58
11662: PUSH
11663: LD_INT 59
11665: PUSH
11666: LD_INT 63
11668: PUSH
11669: LD_INT 64
11671: PUSH
11672: LD_INT 65
11674: PUSH
11675: LD_INT 82
11677: PUSH
11678: LD_INT 83
11680: PUSH
11681: LD_INT 84
11683: PUSH
11684: LD_INT 85
11686: PUSH
11687: LD_INT 86
11689: PUSH
11690: EMPTY
11691: LIST
11692: LIST
11693: LIST
11694: LIST
11695: LIST
11696: LIST
11697: LIST
11698: LIST
11699: LIST
11700: LIST
11701: LIST
11702: LIST
11703: LIST
11704: LIST
11705: LIST
11706: LIST
11707: LIST
11708: LIST
11709: LIST
11710: LIST
11711: LIST
11712: LIST
11713: LIST
11714: LIST
11715: LIST
11716: LIST
11717: LIST
11718: LIST
11719: LIST
11720: LIST
11721: LIST
11722: LIST
11723: LIST
11724: LIST
11725: LIST
11726: LIST
11727: LIST
11728: LIST
11729: LIST
11730: LIST
11731: LIST
11732: LIST
11733: LIST
11734: LIST
11735: LIST
11736: LIST
11737: LIST
11738: LIST
11739: LIST
11740: LIST
11741: LIST
11742: LIST
11743: LIST
11744: ST_TO_ADDR
11745: GO 11748
11747: POP
// if state > - 1 and state < 3 then
11748: LD_VAR 0 3
11752: PUSH
11753: LD_INT 1
11755: NEG
11756: GREATER
11757: PUSH
11758: LD_VAR 0 3
11762: PUSH
11763: LD_INT 3
11765: LESS
11766: AND
11767: IFFALSE 11824
// for i in result do
11769: LD_ADDR_VAR 0 5
11773: PUSH
11774: LD_VAR 0 4
11778: PUSH
11779: FOR_IN
11780: IFFALSE 11822
// if GetTech ( i , side ) <> state then
11782: LD_VAR 0 5
11786: PPUSH
11787: LD_VAR 0 1
11791: PPUSH
11792: CALL_OW 321
11796: PUSH
11797: LD_VAR 0 3
11801: NONEQUAL
11802: IFFALSE 11820
// result := result diff i ;
11804: LD_ADDR_VAR 0 4
11808: PUSH
11809: LD_VAR 0 4
11813: PUSH
11814: LD_VAR 0 5
11818: DIFF
11819: ST_TO_ADDR
11820: GO 11779
11822: POP
11823: POP
// end ;
11824: LD_VAR 0 4
11828: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
11829: LD_INT 0
11831: PPUSH
11832: PPUSH
11833: PPUSH
// result := true ;
11834: LD_ADDR_VAR 0 3
11838: PUSH
11839: LD_INT 1
11841: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
11842: LD_ADDR_VAR 0 5
11846: PUSH
11847: LD_VAR 0 2
11851: PPUSH
11852: CALL_OW 480
11856: ST_TO_ADDR
// if not tmp then
11857: LD_VAR 0 5
11861: NOT
11862: IFFALSE 11866
// exit ;
11864: GO 11915
// for i in tmp do
11866: LD_ADDR_VAR 0 4
11870: PUSH
11871: LD_VAR 0 5
11875: PUSH
11876: FOR_IN
11877: IFFALSE 11913
// if GetTech ( i , side ) <> state_researched then
11879: LD_VAR 0 4
11883: PPUSH
11884: LD_VAR 0 1
11888: PPUSH
11889: CALL_OW 321
11893: PUSH
11894: LD_INT 2
11896: NONEQUAL
11897: IFFALSE 11911
// begin result := false ;
11899: LD_ADDR_VAR 0 3
11903: PUSH
11904: LD_INT 0
11906: ST_TO_ADDR
// exit ;
11907: POP
11908: POP
11909: GO 11915
// end ;
11911: GO 11876
11913: POP
11914: POP
// end ;
11915: LD_VAR 0 3
11919: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
11920: LD_INT 0
11922: PPUSH
11923: PPUSH
11924: PPUSH
11925: PPUSH
11926: PPUSH
11927: PPUSH
11928: PPUSH
11929: PPUSH
11930: PPUSH
11931: PPUSH
11932: PPUSH
11933: PPUSH
11934: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
11935: LD_VAR 0 1
11939: NOT
11940: PUSH
11941: LD_VAR 0 1
11945: PPUSH
11946: CALL_OW 257
11950: PUSH
11951: LD_INT 9
11953: NONEQUAL
11954: OR
11955: IFFALSE 11959
// exit ;
11957: GO 12532
// side := GetSide ( unit ) ;
11959: LD_ADDR_VAR 0 9
11963: PUSH
11964: LD_VAR 0 1
11968: PPUSH
11969: CALL_OW 255
11973: ST_TO_ADDR
// tech_space := tech_spacanom ;
11974: LD_ADDR_VAR 0 12
11978: PUSH
11979: LD_INT 29
11981: ST_TO_ADDR
// tech_time := tech_taurad ;
11982: LD_ADDR_VAR 0 13
11986: PUSH
11987: LD_INT 28
11989: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
11990: LD_ADDR_VAR 0 11
11994: PUSH
11995: LD_VAR 0 1
11999: PPUSH
12000: CALL_OW 310
12004: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
12005: LD_VAR 0 11
12009: PPUSH
12010: CALL_OW 247
12014: PUSH
12015: LD_INT 2
12017: EQUAL
12018: IFFALSE 12022
// exit ;
12020: GO 12532
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
12022: LD_ADDR_VAR 0 8
12026: PUSH
12027: LD_INT 81
12029: PUSH
12030: LD_VAR 0 9
12034: PUSH
12035: EMPTY
12036: LIST
12037: LIST
12038: PUSH
12039: LD_INT 3
12041: PUSH
12042: LD_INT 21
12044: PUSH
12045: LD_INT 3
12047: PUSH
12048: EMPTY
12049: LIST
12050: LIST
12051: PUSH
12052: EMPTY
12053: LIST
12054: LIST
12055: PUSH
12056: EMPTY
12057: LIST
12058: LIST
12059: PPUSH
12060: CALL_OW 69
12064: ST_TO_ADDR
// if not tmp then
12065: LD_VAR 0 8
12069: NOT
12070: IFFALSE 12074
// exit ;
12072: GO 12532
// if in_unit then
12074: LD_VAR 0 11
12078: IFFALSE 12102
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
12080: LD_ADDR_VAR 0 10
12084: PUSH
12085: LD_VAR 0 8
12089: PPUSH
12090: LD_VAR 0 11
12094: PPUSH
12095: CALL_OW 74
12099: ST_TO_ADDR
12100: GO 12122
// enemy := NearestUnitToUnit ( tmp , unit ) ;
12102: LD_ADDR_VAR 0 10
12106: PUSH
12107: LD_VAR 0 8
12111: PPUSH
12112: LD_VAR 0 1
12116: PPUSH
12117: CALL_OW 74
12121: ST_TO_ADDR
// if not enemy then
12122: LD_VAR 0 10
12126: NOT
12127: IFFALSE 12131
// exit ;
12129: GO 12532
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
12131: LD_VAR 0 11
12135: PUSH
12136: LD_VAR 0 11
12140: PPUSH
12141: LD_VAR 0 10
12145: PPUSH
12146: CALL_OW 296
12150: PUSH
12151: LD_INT 13
12153: GREATER
12154: AND
12155: PUSH
12156: LD_VAR 0 1
12160: PPUSH
12161: LD_VAR 0 10
12165: PPUSH
12166: CALL_OW 296
12170: PUSH
12171: LD_INT 12
12173: GREATER
12174: OR
12175: IFFALSE 12179
// exit ;
12177: GO 12532
// missile := [ 1 ] ;
12179: LD_ADDR_VAR 0 14
12183: PUSH
12184: LD_INT 1
12186: PUSH
12187: EMPTY
12188: LIST
12189: ST_TO_ADDR
// if Researched ( side , tech_space ) then
12190: LD_VAR 0 9
12194: PPUSH
12195: LD_VAR 0 12
12199: PPUSH
12200: CALL_OW 325
12204: IFFALSE 12233
// missile := Replace ( missile , missile + 1 , 2 ) ;
12206: LD_ADDR_VAR 0 14
12210: PUSH
12211: LD_VAR 0 14
12215: PPUSH
12216: LD_VAR 0 14
12220: PUSH
12221: LD_INT 1
12223: PLUS
12224: PPUSH
12225: LD_INT 2
12227: PPUSH
12228: CALL_OW 1
12232: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
12233: LD_VAR 0 9
12237: PPUSH
12238: LD_VAR 0 13
12242: PPUSH
12243: CALL_OW 325
12247: PUSH
12248: LD_VAR 0 10
12252: PPUSH
12253: CALL_OW 255
12257: PPUSH
12258: LD_VAR 0 13
12262: PPUSH
12263: CALL_OW 325
12267: NOT
12268: AND
12269: IFFALSE 12298
// missile := Replace ( missile , missile + 1 , 3 ) ;
12271: LD_ADDR_VAR 0 14
12275: PUSH
12276: LD_VAR 0 14
12280: PPUSH
12281: LD_VAR 0 14
12285: PUSH
12286: LD_INT 1
12288: PLUS
12289: PPUSH
12290: LD_INT 3
12292: PPUSH
12293: CALL_OW 1
12297: ST_TO_ADDR
// if missile < 2 then
12298: LD_VAR 0 14
12302: PUSH
12303: LD_INT 2
12305: LESS
12306: IFFALSE 12310
// exit ;
12308: GO 12532
// x := GetX ( enemy ) ;
12310: LD_ADDR_VAR 0 4
12314: PUSH
12315: LD_VAR 0 10
12319: PPUSH
12320: CALL_OW 250
12324: ST_TO_ADDR
// y := GetY ( enemy ) ;
12325: LD_ADDR_VAR 0 5
12329: PUSH
12330: LD_VAR 0 10
12334: PPUSH
12335: CALL_OW 251
12339: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
12340: LD_ADDR_VAR 0 6
12344: PUSH
12345: LD_VAR 0 4
12349: PUSH
12350: LD_INT 1
12352: NEG
12353: PPUSH
12354: LD_INT 1
12356: PPUSH
12357: CALL_OW 12
12361: PLUS
12362: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
12363: LD_ADDR_VAR 0 7
12367: PUSH
12368: LD_VAR 0 5
12372: PUSH
12373: LD_INT 1
12375: NEG
12376: PPUSH
12377: LD_INT 1
12379: PPUSH
12380: CALL_OW 12
12384: PLUS
12385: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
12386: LD_VAR 0 6
12390: PPUSH
12391: LD_VAR 0 7
12395: PPUSH
12396: CALL_OW 488
12400: NOT
12401: IFFALSE 12423
// begin _x := x ;
12403: LD_ADDR_VAR 0 6
12407: PUSH
12408: LD_VAR 0 4
12412: ST_TO_ADDR
// _y := y ;
12413: LD_ADDR_VAR 0 7
12417: PUSH
12418: LD_VAR 0 5
12422: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
12423: LD_ADDR_VAR 0 3
12427: PUSH
12428: LD_INT 1
12430: PPUSH
12431: LD_VAR 0 14
12435: PPUSH
12436: CALL_OW 12
12440: ST_TO_ADDR
// case i of 1 :
12441: LD_VAR 0 3
12445: PUSH
12446: LD_INT 1
12448: DOUBLE
12449: EQUAL
12450: IFTRUE 12454
12452: GO 12471
12454: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
12455: LD_VAR 0 1
12459: PPUSH
12460: LD_VAR 0 10
12464: PPUSH
12465: CALL_OW 115
12469: GO 12532
12471: LD_INT 2
12473: DOUBLE
12474: EQUAL
12475: IFTRUE 12479
12477: GO 12501
12479: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
12480: LD_VAR 0 1
12484: PPUSH
12485: LD_VAR 0 6
12489: PPUSH
12490: LD_VAR 0 7
12494: PPUSH
12495: CALL_OW 153
12499: GO 12532
12501: LD_INT 3
12503: DOUBLE
12504: EQUAL
12505: IFTRUE 12509
12507: GO 12531
12509: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
12510: LD_VAR 0 1
12514: PPUSH
12515: LD_VAR 0 6
12519: PPUSH
12520: LD_VAR 0 7
12524: PPUSH
12525: CALL_OW 154
12529: GO 12532
12531: POP
// end ;
12532: LD_VAR 0 2
12536: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
12537: LD_INT 0
12539: PPUSH
12540: PPUSH
12541: PPUSH
12542: PPUSH
12543: PPUSH
12544: PPUSH
// if not unit or not building then
12545: LD_VAR 0 1
12549: NOT
12550: PUSH
12551: LD_VAR 0 2
12555: NOT
12556: OR
12557: IFFALSE 12561
// exit ;
12559: GO 12719
// x := GetX ( building ) ;
12561: LD_ADDR_VAR 0 5
12565: PUSH
12566: LD_VAR 0 2
12570: PPUSH
12571: CALL_OW 250
12575: ST_TO_ADDR
// y := GetY ( building ) ;
12576: LD_ADDR_VAR 0 6
12580: PUSH
12581: LD_VAR 0 2
12585: PPUSH
12586: CALL_OW 251
12590: ST_TO_ADDR
// for i = 0 to 5 do
12591: LD_ADDR_VAR 0 4
12595: PUSH
12596: DOUBLE
12597: LD_INT 0
12599: DEC
12600: ST_TO_ADDR
12601: LD_INT 5
12603: PUSH
12604: FOR_TO
12605: IFFALSE 12717
// begin _x := ShiftX ( x , i , 3 ) ;
12607: LD_ADDR_VAR 0 7
12611: PUSH
12612: LD_VAR 0 5
12616: PPUSH
12617: LD_VAR 0 4
12621: PPUSH
12622: LD_INT 3
12624: PPUSH
12625: CALL_OW 272
12629: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
12630: LD_ADDR_VAR 0 8
12634: PUSH
12635: LD_VAR 0 6
12639: PPUSH
12640: LD_VAR 0 4
12644: PPUSH
12645: LD_INT 3
12647: PPUSH
12648: CALL_OW 273
12652: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
12653: LD_VAR 0 7
12657: PPUSH
12658: LD_VAR 0 8
12662: PPUSH
12663: CALL_OW 488
12667: NOT
12668: IFFALSE 12672
// continue ;
12670: GO 12604
// if HexInfo ( _x , _y ) = 0 then
12672: LD_VAR 0 7
12676: PPUSH
12677: LD_VAR 0 8
12681: PPUSH
12682: CALL_OW 428
12686: PUSH
12687: LD_INT 0
12689: EQUAL
12690: IFFALSE 12715
// begin ComMoveXY ( unit , _x , _y ) ;
12692: LD_VAR 0 1
12696: PPUSH
12697: LD_VAR 0 7
12701: PPUSH
12702: LD_VAR 0 8
12706: PPUSH
12707: CALL_OW 111
// exit ;
12711: POP
12712: POP
12713: GO 12719
// end ; end ;
12715: GO 12604
12717: POP
12718: POP
// end ;
12719: LD_VAR 0 3
12723: RET
// export function ScanBase ( side , base_area ) ; begin
12724: LD_INT 0
12726: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
12727: LD_ADDR_VAR 0 3
12731: PUSH
12732: LD_VAR 0 2
12736: PPUSH
12737: LD_INT 81
12739: PUSH
12740: LD_VAR 0 1
12744: PUSH
12745: EMPTY
12746: LIST
12747: LIST
12748: PPUSH
12749: CALL_OW 70
12753: ST_TO_ADDR
// end ;
12754: LD_VAR 0 3
12758: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
12759: LD_INT 0
12761: PPUSH
12762: PPUSH
12763: PPUSH
12764: PPUSH
// result := false ;
12765: LD_ADDR_VAR 0 2
12769: PUSH
12770: LD_INT 0
12772: ST_TO_ADDR
// side := GetSide ( unit ) ;
12773: LD_ADDR_VAR 0 3
12777: PUSH
12778: LD_VAR 0 1
12782: PPUSH
12783: CALL_OW 255
12787: ST_TO_ADDR
// nat := GetNation ( unit ) ;
12788: LD_ADDR_VAR 0 4
12792: PUSH
12793: LD_VAR 0 1
12797: PPUSH
12798: CALL_OW 248
12802: ST_TO_ADDR
// case nat of 1 :
12803: LD_VAR 0 4
12807: PUSH
12808: LD_INT 1
12810: DOUBLE
12811: EQUAL
12812: IFTRUE 12816
12814: GO 12827
12816: POP
// tech := tech_lassight ; 2 :
12817: LD_ADDR_VAR 0 5
12821: PUSH
12822: LD_INT 12
12824: ST_TO_ADDR
12825: GO 12866
12827: LD_INT 2
12829: DOUBLE
12830: EQUAL
12831: IFTRUE 12835
12833: GO 12846
12835: POP
// tech := tech_mortar ; 3 :
12836: LD_ADDR_VAR 0 5
12840: PUSH
12841: LD_INT 41
12843: ST_TO_ADDR
12844: GO 12866
12846: LD_INT 3
12848: DOUBLE
12849: EQUAL
12850: IFTRUE 12854
12852: GO 12865
12854: POP
// tech := tech_bazooka ; end ;
12855: LD_ADDR_VAR 0 5
12859: PUSH
12860: LD_INT 44
12862: ST_TO_ADDR
12863: GO 12866
12865: POP
// if Researched ( side , tech ) then
12866: LD_VAR 0 3
12870: PPUSH
12871: LD_VAR 0 5
12875: PPUSH
12876: CALL_OW 325
12880: IFFALSE 12907
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
12882: LD_ADDR_VAR 0 2
12886: PUSH
12887: LD_INT 5
12889: PUSH
12890: LD_INT 8
12892: PUSH
12893: LD_INT 9
12895: PUSH
12896: EMPTY
12897: LIST
12898: LIST
12899: LIST
12900: PUSH
12901: LD_VAR 0 4
12905: ARRAY
12906: ST_TO_ADDR
// end ;
12907: LD_VAR 0 2
12911: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
12912: LD_INT 0
12914: PPUSH
12915: PPUSH
12916: PPUSH
// if not mines then
12917: LD_VAR 0 2
12921: NOT
12922: IFFALSE 12926
// exit ;
12924: GO 13070
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
12926: LD_ADDR_VAR 0 5
12930: PUSH
12931: LD_INT 81
12933: PUSH
12934: LD_VAR 0 1
12938: PUSH
12939: EMPTY
12940: LIST
12941: LIST
12942: PUSH
12943: LD_INT 3
12945: PUSH
12946: LD_INT 21
12948: PUSH
12949: LD_INT 3
12951: PUSH
12952: EMPTY
12953: LIST
12954: LIST
12955: PUSH
12956: EMPTY
12957: LIST
12958: LIST
12959: PUSH
12960: EMPTY
12961: LIST
12962: LIST
12963: PPUSH
12964: CALL_OW 69
12968: ST_TO_ADDR
// for i in mines do
12969: LD_ADDR_VAR 0 4
12973: PUSH
12974: LD_VAR 0 2
12978: PUSH
12979: FOR_IN
12980: IFFALSE 13068
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
12982: LD_VAR 0 4
12986: PUSH
12987: LD_INT 1
12989: ARRAY
12990: PPUSH
12991: LD_VAR 0 4
12995: PUSH
12996: LD_INT 2
12998: ARRAY
12999: PPUSH
13000: CALL_OW 458
13004: NOT
13005: IFFALSE 13009
// continue ;
13007: GO 12979
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
13009: LD_VAR 0 4
13013: PUSH
13014: LD_INT 1
13016: ARRAY
13017: PPUSH
13018: LD_VAR 0 4
13022: PUSH
13023: LD_INT 2
13025: ARRAY
13026: PPUSH
13027: CALL_OW 428
13031: PUSH
13032: LD_VAR 0 5
13036: IN
13037: IFFALSE 13066
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
13039: LD_VAR 0 4
13043: PUSH
13044: LD_INT 1
13046: ARRAY
13047: PPUSH
13048: LD_VAR 0 4
13052: PUSH
13053: LD_INT 2
13055: ARRAY
13056: PPUSH
13057: LD_VAR 0 1
13061: PPUSH
13062: CALL_OW 456
// end ;
13066: GO 12979
13068: POP
13069: POP
// end ;
13070: LD_VAR 0 3
13074: RET
// export function Count ( array ) ; var i ; begin
13075: LD_INT 0
13077: PPUSH
13078: PPUSH
// result := 0 ;
13079: LD_ADDR_VAR 0 2
13083: PUSH
13084: LD_INT 0
13086: ST_TO_ADDR
// for i in array do
13087: LD_ADDR_VAR 0 3
13091: PUSH
13092: LD_VAR 0 1
13096: PUSH
13097: FOR_IN
13098: IFFALSE 13122
// if i then
13100: LD_VAR 0 3
13104: IFFALSE 13120
// result := result + 1 ;
13106: LD_ADDR_VAR 0 2
13110: PUSH
13111: LD_VAR 0 2
13115: PUSH
13116: LD_INT 1
13118: PLUS
13119: ST_TO_ADDR
13120: GO 13097
13122: POP
13123: POP
// end ;
13124: LD_VAR 0 2
13128: RET
// export function IsEmpty ( building ) ; begin
13129: LD_INT 0
13131: PPUSH
// if not building then
13132: LD_VAR 0 1
13136: NOT
13137: IFFALSE 13141
// exit ;
13139: GO 13184
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
13141: LD_ADDR_VAR 0 2
13145: PUSH
13146: LD_VAR 0 1
13150: PUSH
13151: LD_INT 22
13153: PUSH
13154: LD_VAR 0 1
13158: PPUSH
13159: CALL_OW 255
13163: PUSH
13164: EMPTY
13165: LIST
13166: LIST
13167: PUSH
13168: LD_INT 58
13170: PUSH
13171: EMPTY
13172: LIST
13173: PUSH
13174: EMPTY
13175: LIST
13176: LIST
13177: PPUSH
13178: CALL_OW 69
13182: IN
13183: ST_TO_ADDR
// end ;
13184: LD_VAR 0 2
13188: RET
// export function IsNotFull ( building ) ; var places ; begin
13189: LD_INT 0
13191: PPUSH
13192: PPUSH
// if not building then
13193: LD_VAR 0 1
13197: NOT
13198: IFFALSE 13202
// exit ;
13200: GO 13373
// result := false ;
13202: LD_ADDR_VAR 0 2
13206: PUSH
13207: LD_INT 0
13209: ST_TO_ADDR
// places := 0 ;
13210: LD_ADDR_VAR 0 3
13214: PUSH
13215: LD_INT 0
13217: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
13218: LD_VAR 0 1
13222: PPUSH
13223: CALL_OW 266
13227: PUSH
13228: LD_INT 0
13230: DOUBLE
13231: EQUAL
13232: IFTRUE 13290
13234: LD_INT 1
13236: DOUBLE
13237: EQUAL
13238: IFTRUE 13290
13240: LD_INT 6
13242: DOUBLE
13243: EQUAL
13244: IFTRUE 13290
13246: LD_INT 7
13248: DOUBLE
13249: EQUAL
13250: IFTRUE 13290
13252: LD_INT 8
13254: DOUBLE
13255: EQUAL
13256: IFTRUE 13290
13258: LD_INT 4
13260: DOUBLE
13261: EQUAL
13262: IFTRUE 13290
13264: LD_INT 5
13266: DOUBLE
13267: EQUAL
13268: IFTRUE 13290
13270: LD_INT 2
13272: DOUBLE
13273: EQUAL
13274: IFTRUE 13290
13276: LD_INT 3
13278: DOUBLE
13279: EQUAL
13280: IFTRUE 13290
13282: LD_INT 35
13284: DOUBLE
13285: EQUAL
13286: IFTRUE 13290
13288: GO 13301
13290: POP
// places := 6 ; b_bunker , b_breastwork :
13291: LD_ADDR_VAR 0 3
13295: PUSH
13296: LD_INT 6
13298: ST_TO_ADDR
13299: GO 13346
13301: LD_INT 32
13303: DOUBLE
13304: EQUAL
13305: IFTRUE 13315
13307: LD_INT 31
13309: DOUBLE
13310: EQUAL
13311: IFTRUE 13315
13313: GO 13326
13315: POP
// places := 1 ; b_control_tower :
13316: LD_ADDR_VAR 0 3
13320: PUSH
13321: LD_INT 1
13323: ST_TO_ADDR
13324: GO 13346
13326: LD_INT 36
13328: DOUBLE
13329: EQUAL
13330: IFTRUE 13334
13332: GO 13345
13334: POP
// places := 3 ; end ;
13335: LD_ADDR_VAR 0 3
13339: PUSH
13340: LD_INT 3
13342: ST_TO_ADDR
13343: GO 13346
13345: POP
// if places then
13346: LD_VAR 0 3
13350: IFFALSE 13373
// result := UnitsInside ( building ) < places ;
13352: LD_ADDR_VAR 0 2
13356: PUSH
13357: LD_VAR 0 1
13361: PPUSH
13362: CALL_OW 313
13366: PUSH
13367: LD_VAR 0 3
13371: LESS
13372: ST_TO_ADDR
// end ;
13373: LD_VAR 0 2
13377: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
13378: LD_INT 0
13380: PPUSH
13381: PPUSH
13382: PPUSH
13383: PPUSH
// tmp := [ ] ;
13384: LD_ADDR_VAR 0 3
13388: PUSH
13389: EMPTY
13390: ST_TO_ADDR
// list := [ ] ;
13391: LD_ADDR_VAR 0 5
13395: PUSH
13396: EMPTY
13397: ST_TO_ADDR
// for i = 16 to 25 do
13398: LD_ADDR_VAR 0 4
13402: PUSH
13403: DOUBLE
13404: LD_INT 16
13406: DEC
13407: ST_TO_ADDR
13408: LD_INT 25
13410: PUSH
13411: FOR_TO
13412: IFFALSE 13485
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
13414: LD_ADDR_VAR 0 3
13418: PUSH
13419: LD_VAR 0 3
13423: PUSH
13424: LD_INT 22
13426: PUSH
13427: LD_VAR 0 1
13431: PPUSH
13432: CALL_OW 255
13436: PUSH
13437: EMPTY
13438: LIST
13439: LIST
13440: PUSH
13441: LD_INT 91
13443: PUSH
13444: LD_VAR 0 1
13448: PUSH
13449: LD_INT 6
13451: PUSH
13452: EMPTY
13453: LIST
13454: LIST
13455: LIST
13456: PUSH
13457: LD_INT 30
13459: PUSH
13460: LD_VAR 0 4
13464: PUSH
13465: EMPTY
13466: LIST
13467: LIST
13468: PUSH
13469: EMPTY
13470: LIST
13471: LIST
13472: LIST
13473: PUSH
13474: EMPTY
13475: LIST
13476: PPUSH
13477: CALL_OW 69
13481: ADD
13482: ST_TO_ADDR
13483: GO 13411
13485: POP
13486: POP
// for i = 1 to tmp do
13487: LD_ADDR_VAR 0 4
13491: PUSH
13492: DOUBLE
13493: LD_INT 1
13495: DEC
13496: ST_TO_ADDR
13497: LD_VAR 0 3
13501: PUSH
13502: FOR_TO
13503: IFFALSE 13591
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
13505: LD_ADDR_VAR 0 5
13509: PUSH
13510: LD_VAR 0 5
13514: PUSH
13515: LD_VAR 0 3
13519: PUSH
13520: LD_VAR 0 4
13524: ARRAY
13525: PPUSH
13526: CALL_OW 266
13530: PUSH
13531: LD_VAR 0 3
13535: PUSH
13536: LD_VAR 0 4
13540: ARRAY
13541: PPUSH
13542: CALL_OW 250
13546: PUSH
13547: LD_VAR 0 3
13551: PUSH
13552: LD_VAR 0 4
13556: ARRAY
13557: PPUSH
13558: CALL_OW 251
13562: PUSH
13563: LD_VAR 0 3
13567: PUSH
13568: LD_VAR 0 4
13572: ARRAY
13573: PPUSH
13574: CALL_OW 254
13578: PUSH
13579: EMPTY
13580: LIST
13581: LIST
13582: LIST
13583: LIST
13584: PUSH
13585: EMPTY
13586: LIST
13587: ADD
13588: ST_TO_ADDR
13589: GO 13502
13591: POP
13592: POP
// result := list ;
13593: LD_ADDR_VAR 0 2
13597: PUSH
13598: LD_VAR 0 5
13602: ST_TO_ADDR
// end ;
13603: LD_VAR 0 2
13607: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
13608: LD_INT 0
13610: PPUSH
13611: PPUSH
13612: PPUSH
13613: PPUSH
13614: PPUSH
13615: PPUSH
13616: PPUSH
// if not factory then
13617: LD_VAR 0 1
13621: NOT
13622: IFFALSE 13626
// exit ;
13624: GO 14219
// if control = control_apeman then
13626: LD_VAR 0 4
13630: PUSH
13631: LD_INT 5
13633: EQUAL
13634: IFFALSE 13743
// begin tmp := UnitsInside ( factory ) ;
13636: LD_ADDR_VAR 0 8
13640: PUSH
13641: LD_VAR 0 1
13645: PPUSH
13646: CALL_OW 313
13650: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
13651: LD_VAR 0 8
13655: PPUSH
13656: LD_INT 25
13658: PUSH
13659: LD_INT 12
13661: PUSH
13662: EMPTY
13663: LIST
13664: LIST
13665: PPUSH
13666: CALL_OW 72
13670: NOT
13671: IFFALSE 13681
// control := control_manual ;
13673: LD_ADDR_VAR 0 4
13677: PUSH
13678: LD_INT 1
13680: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
13681: LD_ADDR_VAR 0 8
13685: PUSH
13686: LD_VAR 0 1
13690: PPUSH
13691: CALL 13378 0 1
13695: ST_TO_ADDR
// if tmp then
13696: LD_VAR 0 8
13700: IFFALSE 13743
// begin for i in tmp do
13702: LD_ADDR_VAR 0 7
13706: PUSH
13707: LD_VAR 0 8
13711: PUSH
13712: FOR_IN
13713: IFFALSE 13741
// if i [ 1 ] = b_ext_radio then
13715: LD_VAR 0 7
13719: PUSH
13720: LD_INT 1
13722: ARRAY
13723: PUSH
13724: LD_INT 22
13726: EQUAL
13727: IFFALSE 13739
// begin control := control_remote ;
13729: LD_ADDR_VAR 0 4
13733: PUSH
13734: LD_INT 2
13736: ST_TO_ADDR
// break ;
13737: GO 13741
// end ;
13739: GO 13712
13741: POP
13742: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
13743: LD_VAR 0 1
13747: PPUSH
13748: LD_VAR 0 2
13752: PPUSH
13753: LD_VAR 0 3
13757: PPUSH
13758: LD_VAR 0 4
13762: PPUSH
13763: LD_VAR 0 5
13767: PPUSH
13768: CALL_OW 448
13772: IFFALSE 13807
// begin result := [ chassis , engine , control , weapon ] ;
13774: LD_ADDR_VAR 0 6
13778: PUSH
13779: LD_VAR 0 2
13783: PUSH
13784: LD_VAR 0 3
13788: PUSH
13789: LD_VAR 0 4
13793: PUSH
13794: LD_VAR 0 5
13798: PUSH
13799: EMPTY
13800: LIST
13801: LIST
13802: LIST
13803: LIST
13804: ST_TO_ADDR
// exit ;
13805: GO 14219
// end ; _chassis := AvailableChassisList ( factory ) ;
13807: LD_ADDR_VAR 0 9
13811: PUSH
13812: LD_VAR 0 1
13816: PPUSH
13817: CALL_OW 475
13821: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
13822: LD_ADDR_VAR 0 11
13826: PUSH
13827: LD_VAR 0 1
13831: PPUSH
13832: CALL_OW 476
13836: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
13837: LD_ADDR_VAR 0 12
13841: PUSH
13842: LD_VAR 0 1
13846: PPUSH
13847: CALL_OW 477
13851: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
13852: LD_ADDR_VAR 0 10
13856: PUSH
13857: LD_VAR 0 1
13861: PPUSH
13862: CALL_OW 478
13866: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
13867: LD_VAR 0 9
13871: NOT
13872: PUSH
13873: LD_VAR 0 11
13877: NOT
13878: OR
13879: PUSH
13880: LD_VAR 0 12
13884: NOT
13885: OR
13886: PUSH
13887: LD_VAR 0 10
13891: NOT
13892: OR
13893: IFFALSE 13928
// begin result := [ chassis , engine , control , weapon ] ;
13895: LD_ADDR_VAR 0 6
13899: PUSH
13900: LD_VAR 0 2
13904: PUSH
13905: LD_VAR 0 3
13909: PUSH
13910: LD_VAR 0 4
13914: PUSH
13915: LD_VAR 0 5
13919: PUSH
13920: EMPTY
13921: LIST
13922: LIST
13923: LIST
13924: LIST
13925: ST_TO_ADDR
// exit ;
13926: GO 14219
// end ; if not chassis in _chassis then
13928: LD_VAR 0 2
13932: PUSH
13933: LD_VAR 0 9
13937: IN
13938: NOT
13939: IFFALSE 13965
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
13941: LD_ADDR_VAR 0 2
13945: PUSH
13946: LD_VAR 0 9
13950: PUSH
13951: LD_INT 1
13953: PPUSH
13954: LD_VAR 0 9
13958: PPUSH
13959: CALL_OW 12
13963: ARRAY
13964: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
13965: LD_VAR 0 2
13969: PPUSH
13970: LD_VAR 0 3
13974: PPUSH
13975: CALL 14224 0 2
13979: NOT
13980: IFFALSE 14039
// repeat engine := _engine [ 1 ] ;
13982: LD_ADDR_VAR 0 3
13986: PUSH
13987: LD_VAR 0 11
13991: PUSH
13992: LD_INT 1
13994: ARRAY
13995: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
13996: LD_ADDR_VAR 0 11
14000: PUSH
14001: LD_VAR 0 11
14005: PPUSH
14006: LD_INT 1
14008: PPUSH
14009: CALL_OW 3
14013: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
14014: LD_VAR 0 2
14018: PPUSH
14019: LD_VAR 0 3
14023: PPUSH
14024: CALL 14224 0 2
14028: PUSH
14029: LD_VAR 0 11
14033: PUSH
14034: EMPTY
14035: EQUAL
14036: OR
14037: IFFALSE 13982
// if not control in _control then
14039: LD_VAR 0 4
14043: PUSH
14044: LD_VAR 0 12
14048: IN
14049: NOT
14050: IFFALSE 14076
// control := _control [ rand ( 1 , _control ) ] ;
14052: LD_ADDR_VAR 0 4
14056: PUSH
14057: LD_VAR 0 12
14061: PUSH
14062: LD_INT 1
14064: PPUSH
14065: LD_VAR 0 12
14069: PPUSH
14070: CALL_OW 12
14074: ARRAY
14075: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
14076: LD_VAR 0 2
14080: PPUSH
14081: LD_VAR 0 5
14085: PPUSH
14086: CALL 14444 0 2
14090: NOT
14091: IFFALSE 14150
// repeat weapon := _weapon [ 1 ] ;
14093: LD_ADDR_VAR 0 5
14097: PUSH
14098: LD_VAR 0 10
14102: PUSH
14103: LD_INT 1
14105: ARRAY
14106: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
14107: LD_ADDR_VAR 0 10
14111: PUSH
14112: LD_VAR 0 10
14116: PPUSH
14117: LD_INT 1
14119: PPUSH
14120: CALL_OW 3
14124: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
14125: LD_VAR 0 2
14129: PPUSH
14130: LD_VAR 0 5
14134: PPUSH
14135: CALL 14444 0 2
14139: PUSH
14140: LD_VAR 0 10
14144: PUSH
14145: EMPTY
14146: EQUAL
14147: OR
14148: IFFALSE 14093
// result := [ ] ;
14150: LD_ADDR_VAR 0 6
14154: PUSH
14155: EMPTY
14156: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
14157: LD_VAR 0 1
14161: PPUSH
14162: LD_VAR 0 2
14166: PPUSH
14167: LD_VAR 0 3
14171: PPUSH
14172: LD_VAR 0 4
14176: PPUSH
14177: LD_VAR 0 5
14181: PPUSH
14182: CALL_OW 448
14186: IFFALSE 14219
// result := [ chassis , engine , control , weapon ] ;
14188: LD_ADDR_VAR 0 6
14192: PUSH
14193: LD_VAR 0 2
14197: PUSH
14198: LD_VAR 0 3
14202: PUSH
14203: LD_VAR 0 4
14207: PUSH
14208: LD_VAR 0 5
14212: PUSH
14213: EMPTY
14214: LIST
14215: LIST
14216: LIST
14217: LIST
14218: ST_TO_ADDR
// end ;
14219: LD_VAR 0 6
14223: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
14224: LD_INT 0
14226: PPUSH
// if not chassis or not engine then
14227: LD_VAR 0 1
14231: NOT
14232: PUSH
14233: LD_VAR 0 2
14237: NOT
14238: OR
14239: IFFALSE 14243
// exit ;
14241: GO 14439
// case engine of engine_solar :
14243: LD_VAR 0 2
14247: PUSH
14248: LD_INT 2
14250: DOUBLE
14251: EQUAL
14252: IFTRUE 14256
14254: GO 14294
14256: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
14257: LD_ADDR_VAR 0 3
14261: PUSH
14262: LD_INT 11
14264: PUSH
14265: LD_INT 12
14267: PUSH
14268: LD_INT 13
14270: PUSH
14271: LD_INT 14
14273: PUSH
14274: LD_INT 1
14276: PUSH
14277: LD_INT 2
14279: PUSH
14280: LD_INT 3
14282: PUSH
14283: EMPTY
14284: LIST
14285: LIST
14286: LIST
14287: LIST
14288: LIST
14289: LIST
14290: LIST
14291: ST_TO_ADDR
14292: GO 14423
14294: LD_INT 1
14296: DOUBLE
14297: EQUAL
14298: IFTRUE 14302
14300: GO 14364
14302: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
14303: LD_ADDR_VAR 0 3
14307: PUSH
14308: LD_INT 11
14310: PUSH
14311: LD_INT 12
14313: PUSH
14314: LD_INT 13
14316: PUSH
14317: LD_INT 14
14319: PUSH
14320: LD_INT 1
14322: PUSH
14323: LD_INT 2
14325: PUSH
14326: LD_INT 3
14328: PUSH
14329: LD_INT 4
14331: PUSH
14332: LD_INT 5
14334: PUSH
14335: LD_INT 21
14337: PUSH
14338: LD_INT 23
14340: PUSH
14341: LD_INT 22
14343: PUSH
14344: LD_INT 24
14346: PUSH
14347: EMPTY
14348: LIST
14349: LIST
14350: LIST
14351: LIST
14352: LIST
14353: LIST
14354: LIST
14355: LIST
14356: LIST
14357: LIST
14358: LIST
14359: LIST
14360: LIST
14361: ST_TO_ADDR
14362: GO 14423
14364: LD_INT 3
14366: DOUBLE
14367: EQUAL
14368: IFTRUE 14372
14370: GO 14422
14372: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
14373: LD_ADDR_VAR 0 3
14377: PUSH
14378: LD_INT 13
14380: PUSH
14381: LD_INT 14
14383: PUSH
14384: LD_INT 2
14386: PUSH
14387: LD_INT 3
14389: PUSH
14390: LD_INT 4
14392: PUSH
14393: LD_INT 5
14395: PUSH
14396: LD_INT 21
14398: PUSH
14399: LD_INT 22
14401: PUSH
14402: LD_INT 23
14404: PUSH
14405: LD_INT 24
14407: PUSH
14408: EMPTY
14409: LIST
14410: LIST
14411: LIST
14412: LIST
14413: LIST
14414: LIST
14415: LIST
14416: LIST
14417: LIST
14418: LIST
14419: ST_TO_ADDR
14420: GO 14423
14422: POP
// result := ( chassis in result ) ;
14423: LD_ADDR_VAR 0 3
14427: PUSH
14428: LD_VAR 0 1
14432: PUSH
14433: LD_VAR 0 3
14437: IN
14438: ST_TO_ADDR
// end ;
14439: LD_VAR 0 3
14443: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
14444: LD_INT 0
14446: PPUSH
// if not chassis or not weapon then
14447: LD_VAR 0 1
14451: NOT
14452: PUSH
14453: LD_VAR 0 2
14457: NOT
14458: OR
14459: IFFALSE 14463
// exit ;
14461: GO 15523
// case weapon of us_machine_gun :
14463: LD_VAR 0 2
14467: PUSH
14468: LD_INT 2
14470: DOUBLE
14471: EQUAL
14472: IFTRUE 14476
14474: GO 14506
14476: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
14477: LD_ADDR_VAR 0 3
14481: PUSH
14482: LD_INT 1
14484: PUSH
14485: LD_INT 2
14487: PUSH
14488: LD_INT 3
14490: PUSH
14491: LD_INT 4
14493: PUSH
14494: LD_INT 5
14496: PUSH
14497: EMPTY
14498: LIST
14499: LIST
14500: LIST
14501: LIST
14502: LIST
14503: ST_TO_ADDR
14504: GO 15507
14506: LD_INT 3
14508: DOUBLE
14509: EQUAL
14510: IFTRUE 14514
14512: GO 14544
14514: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
14515: LD_ADDR_VAR 0 3
14519: PUSH
14520: LD_INT 1
14522: PUSH
14523: LD_INT 2
14525: PUSH
14526: LD_INT 3
14528: PUSH
14529: LD_INT 4
14531: PUSH
14532: LD_INT 5
14534: PUSH
14535: EMPTY
14536: LIST
14537: LIST
14538: LIST
14539: LIST
14540: LIST
14541: ST_TO_ADDR
14542: GO 15507
14544: LD_INT 11
14546: DOUBLE
14547: EQUAL
14548: IFTRUE 14552
14550: GO 14582
14552: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
14553: LD_ADDR_VAR 0 3
14557: PUSH
14558: LD_INT 1
14560: PUSH
14561: LD_INT 2
14563: PUSH
14564: LD_INT 3
14566: PUSH
14567: LD_INT 4
14569: PUSH
14570: LD_INT 5
14572: PUSH
14573: EMPTY
14574: LIST
14575: LIST
14576: LIST
14577: LIST
14578: LIST
14579: ST_TO_ADDR
14580: GO 15507
14582: LD_INT 4
14584: DOUBLE
14585: EQUAL
14586: IFTRUE 14590
14588: GO 14616
14590: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
14591: LD_ADDR_VAR 0 3
14595: PUSH
14596: LD_INT 2
14598: PUSH
14599: LD_INT 3
14601: PUSH
14602: LD_INT 4
14604: PUSH
14605: LD_INT 5
14607: PUSH
14608: EMPTY
14609: LIST
14610: LIST
14611: LIST
14612: LIST
14613: ST_TO_ADDR
14614: GO 15507
14616: LD_INT 5
14618: DOUBLE
14619: EQUAL
14620: IFTRUE 14624
14622: GO 14650
14624: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
14625: LD_ADDR_VAR 0 3
14629: PUSH
14630: LD_INT 2
14632: PUSH
14633: LD_INT 3
14635: PUSH
14636: LD_INT 4
14638: PUSH
14639: LD_INT 5
14641: PUSH
14642: EMPTY
14643: LIST
14644: LIST
14645: LIST
14646: LIST
14647: ST_TO_ADDR
14648: GO 15507
14650: LD_INT 9
14652: DOUBLE
14653: EQUAL
14654: IFTRUE 14658
14656: GO 14684
14658: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
14659: LD_ADDR_VAR 0 3
14663: PUSH
14664: LD_INT 2
14666: PUSH
14667: LD_INT 3
14669: PUSH
14670: LD_INT 4
14672: PUSH
14673: LD_INT 5
14675: PUSH
14676: EMPTY
14677: LIST
14678: LIST
14679: LIST
14680: LIST
14681: ST_TO_ADDR
14682: GO 15507
14684: LD_INT 7
14686: DOUBLE
14687: EQUAL
14688: IFTRUE 14692
14690: GO 14718
14692: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
14693: LD_ADDR_VAR 0 3
14697: PUSH
14698: LD_INT 2
14700: PUSH
14701: LD_INT 3
14703: PUSH
14704: LD_INT 4
14706: PUSH
14707: LD_INT 5
14709: PUSH
14710: EMPTY
14711: LIST
14712: LIST
14713: LIST
14714: LIST
14715: ST_TO_ADDR
14716: GO 15507
14718: LD_INT 12
14720: DOUBLE
14721: EQUAL
14722: IFTRUE 14726
14724: GO 14752
14726: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
14727: LD_ADDR_VAR 0 3
14731: PUSH
14732: LD_INT 2
14734: PUSH
14735: LD_INT 3
14737: PUSH
14738: LD_INT 4
14740: PUSH
14741: LD_INT 5
14743: PUSH
14744: EMPTY
14745: LIST
14746: LIST
14747: LIST
14748: LIST
14749: ST_TO_ADDR
14750: GO 15507
14752: LD_INT 13
14754: DOUBLE
14755: EQUAL
14756: IFTRUE 14760
14758: GO 14786
14760: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
14761: LD_ADDR_VAR 0 3
14765: PUSH
14766: LD_INT 2
14768: PUSH
14769: LD_INT 3
14771: PUSH
14772: LD_INT 4
14774: PUSH
14775: LD_INT 5
14777: PUSH
14778: EMPTY
14779: LIST
14780: LIST
14781: LIST
14782: LIST
14783: ST_TO_ADDR
14784: GO 15507
14786: LD_INT 14
14788: DOUBLE
14789: EQUAL
14790: IFTRUE 14794
14792: GO 14812
14794: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
14795: LD_ADDR_VAR 0 3
14799: PUSH
14800: LD_INT 4
14802: PUSH
14803: LD_INT 5
14805: PUSH
14806: EMPTY
14807: LIST
14808: LIST
14809: ST_TO_ADDR
14810: GO 15507
14812: LD_INT 6
14814: DOUBLE
14815: EQUAL
14816: IFTRUE 14820
14818: GO 14838
14820: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
14821: LD_ADDR_VAR 0 3
14825: PUSH
14826: LD_INT 4
14828: PUSH
14829: LD_INT 5
14831: PUSH
14832: EMPTY
14833: LIST
14834: LIST
14835: ST_TO_ADDR
14836: GO 15507
14838: LD_INT 10
14840: DOUBLE
14841: EQUAL
14842: IFTRUE 14846
14844: GO 14864
14846: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
14847: LD_ADDR_VAR 0 3
14851: PUSH
14852: LD_INT 4
14854: PUSH
14855: LD_INT 5
14857: PUSH
14858: EMPTY
14859: LIST
14860: LIST
14861: ST_TO_ADDR
14862: GO 15507
14864: LD_INT 22
14866: DOUBLE
14867: EQUAL
14868: IFTRUE 14872
14870: GO 14898
14872: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
14873: LD_ADDR_VAR 0 3
14877: PUSH
14878: LD_INT 11
14880: PUSH
14881: LD_INT 12
14883: PUSH
14884: LD_INT 13
14886: PUSH
14887: LD_INT 14
14889: PUSH
14890: EMPTY
14891: LIST
14892: LIST
14893: LIST
14894: LIST
14895: ST_TO_ADDR
14896: GO 15507
14898: LD_INT 23
14900: DOUBLE
14901: EQUAL
14902: IFTRUE 14906
14904: GO 14932
14906: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
14907: LD_ADDR_VAR 0 3
14911: PUSH
14912: LD_INT 11
14914: PUSH
14915: LD_INT 12
14917: PUSH
14918: LD_INT 13
14920: PUSH
14921: LD_INT 14
14923: PUSH
14924: EMPTY
14925: LIST
14926: LIST
14927: LIST
14928: LIST
14929: ST_TO_ADDR
14930: GO 15507
14932: LD_INT 24
14934: DOUBLE
14935: EQUAL
14936: IFTRUE 14940
14938: GO 14966
14940: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
14941: LD_ADDR_VAR 0 3
14945: PUSH
14946: LD_INT 11
14948: PUSH
14949: LD_INT 12
14951: PUSH
14952: LD_INT 13
14954: PUSH
14955: LD_INT 14
14957: PUSH
14958: EMPTY
14959: LIST
14960: LIST
14961: LIST
14962: LIST
14963: ST_TO_ADDR
14964: GO 15507
14966: LD_INT 30
14968: DOUBLE
14969: EQUAL
14970: IFTRUE 14974
14972: GO 15000
14974: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
14975: LD_ADDR_VAR 0 3
14979: PUSH
14980: LD_INT 11
14982: PUSH
14983: LD_INT 12
14985: PUSH
14986: LD_INT 13
14988: PUSH
14989: LD_INT 14
14991: PUSH
14992: EMPTY
14993: LIST
14994: LIST
14995: LIST
14996: LIST
14997: ST_TO_ADDR
14998: GO 15507
15000: LD_INT 25
15002: DOUBLE
15003: EQUAL
15004: IFTRUE 15008
15006: GO 15026
15008: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
15009: LD_ADDR_VAR 0 3
15013: PUSH
15014: LD_INT 13
15016: PUSH
15017: LD_INT 14
15019: PUSH
15020: EMPTY
15021: LIST
15022: LIST
15023: ST_TO_ADDR
15024: GO 15507
15026: LD_INT 27
15028: DOUBLE
15029: EQUAL
15030: IFTRUE 15034
15032: GO 15052
15034: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
15035: LD_ADDR_VAR 0 3
15039: PUSH
15040: LD_INT 13
15042: PUSH
15043: LD_INT 14
15045: PUSH
15046: EMPTY
15047: LIST
15048: LIST
15049: ST_TO_ADDR
15050: GO 15507
15052: LD_INT 92
15054: DOUBLE
15055: EQUAL
15056: IFTRUE 15060
15058: GO 15086
15060: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
15061: LD_ADDR_VAR 0 3
15065: PUSH
15066: LD_INT 11
15068: PUSH
15069: LD_INT 12
15071: PUSH
15072: LD_INT 13
15074: PUSH
15075: LD_INT 14
15077: PUSH
15078: EMPTY
15079: LIST
15080: LIST
15081: LIST
15082: LIST
15083: ST_TO_ADDR
15084: GO 15507
15086: LD_INT 28
15088: DOUBLE
15089: EQUAL
15090: IFTRUE 15094
15092: GO 15112
15094: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
15095: LD_ADDR_VAR 0 3
15099: PUSH
15100: LD_INT 13
15102: PUSH
15103: LD_INT 14
15105: PUSH
15106: EMPTY
15107: LIST
15108: LIST
15109: ST_TO_ADDR
15110: GO 15507
15112: LD_INT 29
15114: DOUBLE
15115: EQUAL
15116: IFTRUE 15120
15118: GO 15138
15120: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
15121: LD_ADDR_VAR 0 3
15125: PUSH
15126: LD_INT 13
15128: PUSH
15129: LD_INT 14
15131: PUSH
15132: EMPTY
15133: LIST
15134: LIST
15135: ST_TO_ADDR
15136: GO 15507
15138: LD_INT 31
15140: DOUBLE
15141: EQUAL
15142: IFTRUE 15146
15144: GO 15164
15146: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
15147: LD_ADDR_VAR 0 3
15151: PUSH
15152: LD_INT 13
15154: PUSH
15155: LD_INT 14
15157: PUSH
15158: EMPTY
15159: LIST
15160: LIST
15161: ST_TO_ADDR
15162: GO 15507
15164: LD_INT 26
15166: DOUBLE
15167: EQUAL
15168: IFTRUE 15172
15170: GO 15190
15172: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
15173: LD_ADDR_VAR 0 3
15177: PUSH
15178: LD_INT 13
15180: PUSH
15181: LD_INT 14
15183: PUSH
15184: EMPTY
15185: LIST
15186: LIST
15187: ST_TO_ADDR
15188: GO 15507
15190: LD_INT 42
15192: DOUBLE
15193: EQUAL
15194: IFTRUE 15198
15196: GO 15224
15198: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
15199: LD_ADDR_VAR 0 3
15203: PUSH
15204: LD_INT 21
15206: PUSH
15207: LD_INT 22
15209: PUSH
15210: LD_INT 23
15212: PUSH
15213: LD_INT 24
15215: PUSH
15216: EMPTY
15217: LIST
15218: LIST
15219: LIST
15220: LIST
15221: ST_TO_ADDR
15222: GO 15507
15224: LD_INT 43
15226: DOUBLE
15227: EQUAL
15228: IFTRUE 15232
15230: GO 15258
15232: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
15233: LD_ADDR_VAR 0 3
15237: PUSH
15238: LD_INT 21
15240: PUSH
15241: LD_INT 22
15243: PUSH
15244: LD_INT 23
15246: PUSH
15247: LD_INT 24
15249: PUSH
15250: EMPTY
15251: LIST
15252: LIST
15253: LIST
15254: LIST
15255: ST_TO_ADDR
15256: GO 15507
15258: LD_INT 44
15260: DOUBLE
15261: EQUAL
15262: IFTRUE 15266
15264: GO 15292
15266: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
15267: LD_ADDR_VAR 0 3
15271: PUSH
15272: LD_INT 21
15274: PUSH
15275: LD_INT 22
15277: PUSH
15278: LD_INT 23
15280: PUSH
15281: LD_INT 24
15283: PUSH
15284: EMPTY
15285: LIST
15286: LIST
15287: LIST
15288: LIST
15289: ST_TO_ADDR
15290: GO 15507
15292: LD_INT 45
15294: DOUBLE
15295: EQUAL
15296: IFTRUE 15300
15298: GO 15326
15300: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
15301: LD_ADDR_VAR 0 3
15305: PUSH
15306: LD_INT 21
15308: PUSH
15309: LD_INT 22
15311: PUSH
15312: LD_INT 23
15314: PUSH
15315: LD_INT 24
15317: PUSH
15318: EMPTY
15319: LIST
15320: LIST
15321: LIST
15322: LIST
15323: ST_TO_ADDR
15324: GO 15507
15326: LD_INT 49
15328: DOUBLE
15329: EQUAL
15330: IFTRUE 15334
15332: GO 15360
15334: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
15335: LD_ADDR_VAR 0 3
15339: PUSH
15340: LD_INT 21
15342: PUSH
15343: LD_INT 22
15345: PUSH
15346: LD_INT 23
15348: PUSH
15349: LD_INT 24
15351: PUSH
15352: EMPTY
15353: LIST
15354: LIST
15355: LIST
15356: LIST
15357: ST_TO_ADDR
15358: GO 15507
15360: LD_INT 51
15362: DOUBLE
15363: EQUAL
15364: IFTRUE 15368
15366: GO 15394
15368: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
15369: LD_ADDR_VAR 0 3
15373: PUSH
15374: LD_INT 21
15376: PUSH
15377: LD_INT 22
15379: PUSH
15380: LD_INT 23
15382: PUSH
15383: LD_INT 24
15385: PUSH
15386: EMPTY
15387: LIST
15388: LIST
15389: LIST
15390: LIST
15391: ST_TO_ADDR
15392: GO 15507
15394: LD_INT 52
15396: DOUBLE
15397: EQUAL
15398: IFTRUE 15402
15400: GO 15428
15402: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
15403: LD_ADDR_VAR 0 3
15407: PUSH
15408: LD_INT 21
15410: PUSH
15411: LD_INT 22
15413: PUSH
15414: LD_INT 23
15416: PUSH
15417: LD_INT 24
15419: PUSH
15420: EMPTY
15421: LIST
15422: LIST
15423: LIST
15424: LIST
15425: ST_TO_ADDR
15426: GO 15507
15428: LD_INT 53
15430: DOUBLE
15431: EQUAL
15432: IFTRUE 15436
15434: GO 15454
15436: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
15437: LD_ADDR_VAR 0 3
15441: PUSH
15442: LD_INT 23
15444: PUSH
15445: LD_INT 24
15447: PUSH
15448: EMPTY
15449: LIST
15450: LIST
15451: ST_TO_ADDR
15452: GO 15507
15454: LD_INT 46
15456: DOUBLE
15457: EQUAL
15458: IFTRUE 15462
15460: GO 15480
15462: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
15463: LD_ADDR_VAR 0 3
15467: PUSH
15468: LD_INT 23
15470: PUSH
15471: LD_INT 24
15473: PUSH
15474: EMPTY
15475: LIST
15476: LIST
15477: ST_TO_ADDR
15478: GO 15507
15480: LD_INT 47
15482: DOUBLE
15483: EQUAL
15484: IFTRUE 15488
15486: GO 15506
15488: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
15489: LD_ADDR_VAR 0 3
15493: PUSH
15494: LD_INT 23
15496: PUSH
15497: LD_INT 24
15499: PUSH
15500: EMPTY
15501: LIST
15502: LIST
15503: ST_TO_ADDR
15504: GO 15507
15506: POP
// result := ( chassis in result ) ;
15507: LD_ADDR_VAR 0 3
15511: PUSH
15512: LD_VAR 0 1
15516: PUSH
15517: LD_VAR 0 3
15521: IN
15522: ST_TO_ADDR
// end ;
15523: LD_VAR 0 3
15527: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
15528: LD_INT 0
15530: PPUSH
15531: PPUSH
15532: PPUSH
15533: PPUSH
15534: PPUSH
15535: PPUSH
15536: PPUSH
// result := array ;
15537: LD_ADDR_VAR 0 5
15541: PUSH
15542: LD_VAR 0 1
15546: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
15547: LD_VAR 0 1
15551: NOT
15552: PUSH
15553: LD_VAR 0 2
15557: NOT
15558: OR
15559: PUSH
15560: LD_VAR 0 3
15564: NOT
15565: OR
15566: PUSH
15567: LD_VAR 0 2
15571: PUSH
15572: LD_VAR 0 1
15576: GREATER
15577: OR
15578: PUSH
15579: LD_VAR 0 3
15583: PUSH
15584: LD_VAR 0 1
15588: GREATER
15589: OR
15590: IFFALSE 15594
// exit ;
15592: GO 15890
// if direction then
15594: LD_VAR 0 4
15598: IFFALSE 15662
// begin d := 1 ;
15600: LD_ADDR_VAR 0 9
15604: PUSH
15605: LD_INT 1
15607: ST_TO_ADDR
// if i_from > i_to then
15608: LD_VAR 0 2
15612: PUSH
15613: LD_VAR 0 3
15617: GREATER
15618: IFFALSE 15644
// length := ( array - i_from ) + i_to else
15620: LD_ADDR_VAR 0 11
15624: PUSH
15625: LD_VAR 0 1
15629: PUSH
15630: LD_VAR 0 2
15634: MINUS
15635: PUSH
15636: LD_VAR 0 3
15640: PLUS
15641: ST_TO_ADDR
15642: GO 15660
// length := i_to - i_from ;
15644: LD_ADDR_VAR 0 11
15648: PUSH
15649: LD_VAR 0 3
15653: PUSH
15654: LD_VAR 0 2
15658: MINUS
15659: ST_TO_ADDR
// end else
15660: GO 15723
// begin d := - 1 ;
15662: LD_ADDR_VAR 0 9
15666: PUSH
15667: LD_INT 1
15669: NEG
15670: ST_TO_ADDR
// if i_from > i_to then
15671: LD_VAR 0 2
15675: PUSH
15676: LD_VAR 0 3
15680: GREATER
15681: IFFALSE 15701
// length := i_from - i_to else
15683: LD_ADDR_VAR 0 11
15687: PUSH
15688: LD_VAR 0 2
15692: PUSH
15693: LD_VAR 0 3
15697: MINUS
15698: ST_TO_ADDR
15699: GO 15723
// length := ( array - i_to ) + i_from ;
15701: LD_ADDR_VAR 0 11
15705: PUSH
15706: LD_VAR 0 1
15710: PUSH
15711: LD_VAR 0 3
15715: MINUS
15716: PUSH
15717: LD_VAR 0 2
15721: PLUS
15722: ST_TO_ADDR
// end ; if not length then
15723: LD_VAR 0 11
15727: NOT
15728: IFFALSE 15732
// exit ;
15730: GO 15890
// tmp := array ;
15732: LD_ADDR_VAR 0 10
15736: PUSH
15737: LD_VAR 0 1
15741: ST_TO_ADDR
// for i = 1 to length do
15742: LD_ADDR_VAR 0 6
15746: PUSH
15747: DOUBLE
15748: LD_INT 1
15750: DEC
15751: ST_TO_ADDR
15752: LD_VAR 0 11
15756: PUSH
15757: FOR_TO
15758: IFFALSE 15878
// begin for j = 1 to array do
15760: LD_ADDR_VAR 0 7
15764: PUSH
15765: DOUBLE
15766: LD_INT 1
15768: DEC
15769: ST_TO_ADDR
15770: LD_VAR 0 1
15774: PUSH
15775: FOR_TO
15776: IFFALSE 15864
// begin k := j + d ;
15778: LD_ADDR_VAR 0 8
15782: PUSH
15783: LD_VAR 0 7
15787: PUSH
15788: LD_VAR 0 9
15792: PLUS
15793: ST_TO_ADDR
// if k > array then
15794: LD_VAR 0 8
15798: PUSH
15799: LD_VAR 0 1
15803: GREATER
15804: IFFALSE 15814
// k := 1 ;
15806: LD_ADDR_VAR 0 8
15810: PUSH
15811: LD_INT 1
15813: ST_TO_ADDR
// if not k then
15814: LD_VAR 0 8
15818: NOT
15819: IFFALSE 15831
// k := array ;
15821: LD_ADDR_VAR 0 8
15825: PUSH
15826: LD_VAR 0 1
15830: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
15831: LD_ADDR_VAR 0 10
15835: PUSH
15836: LD_VAR 0 10
15840: PPUSH
15841: LD_VAR 0 8
15845: PPUSH
15846: LD_VAR 0 1
15850: PUSH
15851: LD_VAR 0 7
15855: ARRAY
15856: PPUSH
15857: CALL_OW 1
15861: ST_TO_ADDR
// end ;
15862: GO 15775
15864: POP
15865: POP
// array := tmp ;
15866: LD_ADDR_VAR 0 1
15870: PUSH
15871: LD_VAR 0 10
15875: ST_TO_ADDR
// end ;
15876: GO 15757
15878: POP
15879: POP
// result := array ;
15880: LD_ADDR_VAR 0 5
15884: PUSH
15885: LD_VAR 0 1
15889: ST_TO_ADDR
// end ;
15890: LD_VAR 0 5
15894: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
15895: LD_INT 0
15897: PPUSH
15898: PPUSH
// result := 0 ;
15899: LD_ADDR_VAR 0 3
15903: PUSH
15904: LD_INT 0
15906: ST_TO_ADDR
// if not array or not value in array then
15907: LD_VAR 0 1
15911: NOT
15912: PUSH
15913: LD_VAR 0 2
15917: PUSH
15918: LD_VAR 0 1
15922: IN
15923: NOT
15924: OR
15925: IFFALSE 15929
// exit ;
15927: GO 15983
// for i = 1 to array do
15929: LD_ADDR_VAR 0 4
15933: PUSH
15934: DOUBLE
15935: LD_INT 1
15937: DEC
15938: ST_TO_ADDR
15939: LD_VAR 0 1
15943: PUSH
15944: FOR_TO
15945: IFFALSE 15981
// if value = array [ i ] then
15947: LD_VAR 0 2
15951: PUSH
15952: LD_VAR 0 1
15956: PUSH
15957: LD_VAR 0 4
15961: ARRAY
15962: EQUAL
15963: IFFALSE 15979
// begin result := i ;
15965: LD_ADDR_VAR 0 3
15969: PUSH
15970: LD_VAR 0 4
15974: ST_TO_ADDR
// exit ;
15975: POP
15976: POP
15977: GO 15983
// end ;
15979: GO 15944
15981: POP
15982: POP
// end ;
15983: LD_VAR 0 3
15987: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
15988: LD_INT 0
15990: PPUSH
// vc_chassis := chassis ;
15991: LD_ADDR_OWVAR 37
15995: PUSH
15996: LD_VAR 0 1
16000: ST_TO_ADDR
// vc_engine := engine ;
16001: LD_ADDR_OWVAR 39
16005: PUSH
16006: LD_VAR 0 2
16010: ST_TO_ADDR
// vc_control := control ;
16011: LD_ADDR_OWVAR 38
16015: PUSH
16016: LD_VAR 0 3
16020: ST_TO_ADDR
// vc_weapon := weapon ;
16021: LD_ADDR_OWVAR 40
16025: PUSH
16026: LD_VAR 0 4
16030: ST_TO_ADDR
// vc_fuel_battery := fuel ;
16031: LD_ADDR_OWVAR 41
16035: PUSH
16036: LD_VAR 0 5
16040: ST_TO_ADDR
// end ;
16041: LD_VAR 0 6
16045: RET
// export function WantPlant ( unit ) ; var task ; begin
16046: LD_INT 0
16048: PPUSH
16049: PPUSH
// result := false ;
16050: LD_ADDR_VAR 0 2
16054: PUSH
16055: LD_INT 0
16057: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
16058: LD_ADDR_VAR 0 3
16062: PUSH
16063: LD_VAR 0 1
16067: PPUSH
16068: CALL_OW 437
16072: ST_TO_ADDR
// if task then
16073: LD_VAR 0 3
16077: IFFALSE 16105
// if task [ 1 ] [ 1 ] = p then
16079: LD_VAR 0 3
16083: PUSH
16084: LD_INT 1
16086: ARRAY
16087: PUSH
16088: LD_INT 1
16090: ARRAY
16091: PUSH
16092: LD_STRING p
16094: EQUAL
16095: IFFALSE 16105
// result := true ;
16097: LD_ADDR_VAR 0 2
16101: PUSH
16102: LD_INT 1
16104: ST_TO_ADDR
// end ;
16105: LD_VAR 0 2
16109: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
16110: LD_INT 0
16112: PPUSH
16113: PPUSH
16114: PPUSH
16115: PPUSH
// if pos < 1 then
16116: LD_VAR 0 2
16120: PUSH
16121: LD_INT 1
16123: LESS
16124: IFFALSE 16128
// exit ;
16126: GO 16431
// if pos = 1 then
16128: LD_VAR 0 2
16132: PUSH
16133: LD_INT 1
16135: EQUAL
16136: IFFALSE 16169
// result := Replace ( arr , pos [ 1 ] , value ) else
16138: LD_ADDR_VAR 0 4
16142: PUSH
16143: LD_VAR 0 1
16147: PPUSH
16148: LD_VAR 0 2
16152: PUSH
16153: LD_INT 1
16155: ARRAY
16156: PPUSH
16157: LD_VAR 0 3
16161: PPUSH
16162: CALL_OW 1
16166: ST_TO_ADDR
16167: GO 16431
// begin tmp := arr ;
16169: LD_ADDR_VAR 0 6
16173: PUSH
16174: LD_VAR 0 1
16178: ST_TO_ADDR
// s_arr := [ tmp ] ;
16179: LD_ADDR_VAR 0 7
16183: PUSH
16184: LD_VAR 0 6
16188: PUSH
16189: EMPTY
16190: LIST
16191: ST_TO_ADDR
// for i = 1 to pos - 1 do
16192: LD_ADDR_VAR 0 5
16196: PUSH
16197: DOUBLE
16198: LD_INT 1
16200: DEC
16201: ST_TO_ADDR
16202: LD_VAR 0 2
16206: PUSH
16207: LD_INT 1
16209: MINUS
16210: PUSH
16211: FOR_TO
16212: IFFALSE 16257
// begin tmp := tmp [ pos [ i ] ] ;
16214: LD_ADDR_VAR 0 6
16218: PUSH
16219: LD_VAR 0 6
16223: PUSH
16224: LD_VAR 0 2
16228: PUSH
16229: LD_VAR 0 5
16233: ARRAY
16234: ARRAY
16235: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
16236: LD_ADDR_VAR 0 7
16240: PUSH
16241: LD_VAR 0 7
16245: PUSH
16246: LD_VAR 0 6
16250: PUSH
16251: EMPTY
16252: LIST
16253: ADD
16254: ST_TO_ADDR
// end ;
16255: GO 16211
16257: POP
16258: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
16259: LD_ADDR_VAR 0 6
16263: PUSH
16264: LD_VAR 0 6
16268: PPUSH
16269: LD_VAR 0 2
16273: PUSH
16274: LD_VAR 0 2
16278: ARRAY
16279: PPUSH
16280: LD_VAR 0 3
16284: PPUSH
16285: CALL_OW 1
16289: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
16290: LD_ADDR_VAR 0 7
16294: PUSH
16295: LD_VAR 0 7
16299: PPUSH
16300: LD_VAR 0 7
16304: PPUSH
16305: LD_VAR 0 6
16309: PPUSH
16310: CALL_OW 1
16314: ST_TO_ADDR
// for i = s_arr downto 2 do
16315: LD_ADDR_VAR 0 5
16319: PUSH
16320: DOUBLE
16321: LD_VAR 0 7
16325: INC
16326: ST_TO_ADDR
16327: LD_INT 2
16329: PUSH
16330: FOR_DOWNTO
16331: IFFALSE 16415
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
16333: LD_ADDR_VAR 0 6
16337: PUSH
16338: LD_VAR 0 7
16342: PUSH
16343: LD_VAR 0 5
16347: PUSH
16348: LD_INT 1
16350: MINUS
16351: ARRAY
16352: PPUSH
16353: LD_VAR 0 2
16357: PUSH
16358: LD_VAR 0 5
16362: PUSH
16363: LD_INT 1
16365: MINUS
16366: ARRAY
16367: PPUSH
16368: LD_VAR 0 7
16372: PUSH
16373: LD_VAR 0 5
16377: ARRAY
16378: PPUSH
16379: CALL_OW 1
16383: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
16384: LD_ADDR_VAR 0 7
16388: PUSH
16389: LD_VAR 0 7
16393: PPUSH
16394: LD_VAR 0 5
16398: PUSH
16399: LD_INT 1
16401: MINUS
16402: PPUSH
16403: LD_VAR 0 6
16407: PPUSH
16408: CALL_OW 1
16412: ST_TO_ADDR
// end ;
16413: GO 16330
16415: POP
16416: POP
// result := s_arr [ 1 ] ;
16417: LD_ADDR_VAR 0 4
16421: PUSH
16422: LD_VAR 0 7
16426: PUSH
16427: LD_INT 1
16429: ARRAY
16430: ST_TO_ADDR
// end ; end ;
16431: LD_VAR 0 4
16435: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
16436: LD_INT 0
16438: PPUSH
16439: PPUSH
// if not list then
16440: LD_VAR 0 1
16444: NOT
16445: IFFALSE 16449
// exit ;
16447: GO 16540
// i := list [ pos1 ] ;
16449: LD_ADDR_VAR 0 5
16453: PUSH
16454: LD_VAR 0 1
16458: PUSH
16459: LD_VAR 0 2
16463: ARRAY
16464: ST_TO_ADDR
// if not i then
16465: LD_VAR 0 5
16469: NOT
16470: IFFALSE 16474
// exit ;
16472: GO 16540
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
16474: LD_ADDR_VAR 0 1
16478: PUSH
16479: LD_VAR 0 1
16483: PPUSH
16484: LD_VAR 0 2
16488: PPUSH
16489: LD_VAR 0 1
16493: PUSH
16494: LD_VAR 0 3
16498: ARRAY
16499: PPUSH
16500: CALL_OW 1
16504: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
16505: LD_ADDR_VAR 0 1
16509: PUSH
16510: LD_VAR 0 1
16514: PPUSH
16515: LD_VAR 0 3
16519: PPUSH
16520: LD_VAR 0 5
16524: PPUSH
16525: CALL_OW 1
16529: ST_TO_ADDR
// result := list ;
16530: LD_ADDR_VAR 0 4
16534: PUSH
16535: LD_VAR 0 1
16539: ST_TO_ADDR
// end ;
16540: LD_VAR 0 4
16544: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
16545: LD_INT 0
16547: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
16548: LD_ADDR_VAR 0 5
16552: PUSH
16553: LD_VAR 0 1
16557: PPUSH
16558: CALL_OW 250
16562: PPUSH
16563: LD_VAR 0 1
16567: PPUSH
16568: CALL_OW 251
16572: PPUSH
16573: LD_VAR 0 2
16577: PPUSH
16578: LD_VAR 0 3
16582: PPUSH
16583: LD_VAR 0 4
16587: PPUSH
16588: CALL 16598 0 5
16592: ST_TO_ADDR
// end ;
16593: LD_VAR 0 5
16597: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
16598: LD_INT 0
16600: PPUSH
16601: PPUSH
16602: PPUSH
16603: PPUSH
// if not list then
16604: LD_VAR 0 3
16608: NOT
16609: IFFALSE 16613
// exit ;
16611: GO 17001
// result := [ ] ;
16613: LD_ADDR_VAR 0 6
16617: PUSH
16618: EMPTY
16619: ST_TO_ADDR
// for i in list do
16620: LD_ADDR_VAR 0 7
16624: PUSH
16625: LD_VAR 0 3
16629: PUSH
16630: FOR_IN
16631: IFFALSE 16833
// begin tmp := GetDistUnitXY ( i , x , y ) ;
16633: LD_ADDR_VAR 0 9
16637: PUSH
16638: LD_VAR 0 7
16642: PPUSH
16643: LD_VAR 0 1
16647: PPUSH
16648: LD_VAR 0 2
16652: PPUSH
16653: CALL_OW 297
16657: ST_TO_ADDR
// if not result then
16658: LD_VAR 0 6
16662: NOT
16663: IFFALSE 16689
// result := [ [ i , tmp ] ] else
16665: LD_ADDR_VAR 0 6
16669: PUSH
16670: LD_VAR 0 7
16674: PUSH
16675: LD_VAR 0 9
16679: PUSH
16680: EMPTY
16681: LIST
16682: LIST
16683: PUSH
16684: EMPTY
16685: LIST
16686: ST_TO_ADDR
16687: GO 16831
// begin if result [ result ] [ 2 ] < tmp then
16689: LD_VAR 0 6
16693: PUSH
16694: LD_VAR 0 6
16698: ARRAY
16699: PUSH
16700: LD_INT 2
16702: ARRAY
16703: PUSH
16704: LD_VAR 0 9
16708: LESS
16709: IFFALSE 16751
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
16711: LD_ADDR_VAR 0 6
16715: PUSH
16716: LD_VAR 0 6
16720: PPUSH
16721: LD_VAR 0 6
16725: PUSH
16726: LD_INT 1
16728: PLUS
16729: PPUSH
16730: LD_VAR 0 7
16734: PUSH
16735: LD_VAR 0 9
16739: PUSH
16740: EMPTY
16741: LIST
16742: LIST
16743: PPUSH
16744: CALL_OW 2
16748: ST_TO_ADDR
16749: GO 16831
// for j = 1 to result do
16751: LD_ADDR_VAR 0 8
16755: PUSH
16756: DOUBLE
16757: LD_INT 1
16759: DEC
16760: ST_TO_ADDR
16761: LD_VAR 0 6
16765: PUSH
16766: FOR_TO
16767: IFFALSE 16829
// begin if tmp < result [ j ] [ 2 ] then
16769: LD_VAR 0 9
16773: PUSH
16774: LD_VAR 0 6
16778: PUSH
16779: LD_VAR 0 8
16783: ARRAY
16784: PUSH
16785: LD_INT 2
16787: ARRAY
16788: LESS
16789: IFFALSE 16827
// begin result := Insert ( result , j , [ i , tmp ] ) ;
16791: LD_ADDR_VAR 0 6
16795: PUSH
16796: LD_VAR 0 6
16800: PPUSH
16801: LD_VAR 0 8
16805: PPUSH
16806: LD_VAR 0 7
16810: PUSH
16811: LD_VAR 0 9
16815: PUSH
16816: EMPTY
16817: LIST
16818: LIST
16819: PPUSH
16820: CALL_OW 2
16824: ST_TO_ADDR
// break ;
16825: GO 16829
// end ; end ;
16827: GO 16766
16829: POP
16830: POP
// end ; end ;
16831: GO 16630
16833: POP
16834: POP
// if result and not asc then
16835: LD_VAR 0 6
16839: PUSH
16840: LD_VAR 0 4
16844: NOT
16845: AND
16846: IFFALSE 16921
// begin tmp := result ;
16848: LD_ADDR_VAR 0 9
16852: PUSH
16853: LD_VAR 0 6
16857: ST_TO_ADDR
// for i = tmp downto 1 do
16858: LD_ADDR_VAR 0 7
16862: PUSH
16863: DOUBLE
16864: LD_VAR 0 9
16868: INC
16869: ST_TO_ADDR
16870: LD_INT 1
16872: PUSH
16873: FOR_DOWNTO
16874: IFFALSE 16919
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
16876: LD_ADDR_VAR 0 6
16880: PUSH
16881: LD_VAR 0 6
16885: PPUSH
16886: LD_VAR 0 9
16890: PUSH
16891: LD_VAR 0 7
16895: MINUS
16896: PUSH
16897: LD_INT 1
16899: PLUS
16900: PPUSH
16901: LD_VAR 0 9
16905: PUSH
16906: LD_VAR 0 7
16910: ARRAY
16911: PPUSH
16912: CALL_OW 1
16916: ST_TO_ADDR
16917: GO 16873
16919: POP
16920: POP
// end ; tmp := [ ] ;
16921: LD_ADDR_VAR 0 9
16925: PUSH
16926: EMPTY
16927: ST_TO_ADDR
// if mode then
16928: LD_VAR 0 5
16932: IFFALSE 17001
// begin for i = 1 to result do
16934: LD_ADDR_VAR 0 7
16938: PUSH
16939: DOUBLE
16940: LD_INT 1
16942: DEC
16943: ST_TO_ADDR
16944: LD_VAR 0 6
16948: PUSH
16949: FOR_TO
16950: IFFALSE 16989
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
16952: LD_ADDR_VAR 0 9
16956: PUSH
16957: LD_VAR 0 9
16961: PPUSH
16962: LD_VAR 0 7
16966: PPUSH
16967: LD_VAR 0 6
16971: PUSH
16972: LD_VAR 0 7
16976: ARRAY
16977: PUSH
16978: LD_INT 1
16980: ARRAY
16981: PPUSH
16982: CALL_OW 1
16986: ST_TO_ADDR
16987: GO 16949
16989: POP
16990: POP
// result := tmp ;
16991: LD_ADDR_VAR 0 6
16995: PUSH
16996: LD_VAR 0 9
17000: ST_TO_ADDR
// end ; end ;
17001: LD_VAR 0 6
17005: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
17006: LD_INT 0
17008: PPUSH
17009: PPUSH
17010: PPUSH
17011: PPUSH
17012: PPUSH
17013: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
17014: LD_ADDR_VAR 0 5
17018: PUSH
17019: LD_INT 0
17021: PUSH
17022: LD_INT 0
17024: PUSH
17025: LD_INT 0
17027: PUSH
17028: EMPTY
17029: PUSH
17030: EMPTY
17031: LIST
17032: LIST
17033: LIST
17034: LIST
17035: ST_TO_ADDR
// if not x or not y then
17036: LD_VAR 0 2
17040: NOT
17041: PUSH
17042: LD_VAR 0 3
17046: NOT
17047: OR
17048: IFFALSE 17052
// exit ;
17050: GO 18702
// if not range then
17052: LD_VAR 0 4
17056: NOT
17057: IFFALSE 17067
// range := 10 ;
17059: LD_ADDR_VAR 0 4
17063: PUSH
17064: LD_INT 10
17066: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
17067: LD_ADDR_VAR 0 8
17071: PUSH
17072: LD_INT 81
17074: PUSH
17075: LD_VAR 0 1
17079: PUSH
17080: EMPTY
17081: LIST
17082: LIST
17083: PUSH
17084: LD_INT 92
17086: PUSH
17087: LD_VAR 0 2
17091: PUSH
17092: LD_VAR 0 3
17096: PUSH
17097: LD_VAR 0 4
17101: PUSH
17102: EMPTY
17103: LIST
17104: LIST
17105: LIST
17106: LIST
17107: PUSH
17108: LD_INT 3
17110: PUSH
17111: LD_INT 21
17113: PUSH
17114: LD_INT 3
17116: PUSH
17117: EMPTY
17118: LIST
17119: LIST
17120: PUSH
17121: EMPTY
17122: LIST
17123: LIST
17124: PUSH
17125: EMPTY
17126: LIST
17127: LIST
17128: LIST
17129: PPUSH
17130: CALL_OW 69
17134: ST_TO_ADDR
// if not tmp then
17135: LD_VAR 0 8
17139: NOT
17140: IFFALSE 17144
// exit ;
17142: GO 18702
// for i in tmp do
17144: LD_ADDR_VAR 0 6
17148: PUSH
17149: LD_VAR 0 8
17153: PUSH
17154: FOR_IN
17155: IFFALSE 18677
// begin points := [ 0 , 0 , 0 ] ;
17157: LD_ADDR_VAR 0 9
17161: PUSH
17162: LD_INT 0
17164: PUSH
17165: LD_INT 0
17167: PUSH
17168: LD_INT 0
17170: PUSH
17171: EMPTY
17172: LIST
17173: LIST
17174: LIST
17175: ST_TO_ADDR
// bpoints := 1 ;
17176: LD_ADDR_VAR 0 10
17180: PUSH
17181: LD_INT 1
17183: ST_TO_ADDR
// case GetType ( i ) of unit_human :
17184: LD_VAR 0 6
17188: PPUSH
17189: CALL_OW 247
17193: PUSH
17194: LD_INT 1
17196: DOUBLE
17197: EQUAL
17198: IFTRUE 17202
17200: GO 17780
17202: POP
// begin if GetClass ( i ) = 1 then
17203: LD_VAR 0 6
17207: PPUSH
17208: CALL_OW 257
17212: PUSH
17213: LD_INT 1
17215: EQUAL
17216: IFFALSE 17237
// points := [ 10 , 5 , 3 ] ;
17218: LD_ADDR_VAR 0 9
17222: PUSH
17223: LD_INT 10
17225: PUSH
17226: LD_INT 5
17228: PUSH
17229: LD_INT 3
17231: PUSH
17232: EMPTY
17233: LIST
17234: LIST
17235: LIST
17236: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
17237: LD_VAR 0 6
17241: PPUSH
17242: CALL_OW 257
17246: PUSH
17247: LD_INT 2
17249: PUSH
17250: LD_INT 3
17252: PUSH
17253: LD_INT 4
17255: PUSH
17256: EMPTY
17257: LIST
17258: LIST
17259: LIST
17260: IN
17261: IFFALSE 17282
// points := [ 3 , 2 , 1 ] ;
17263: LD_ADDR_VAR 0 9
17267: PUSH
17268: LD_INT 3
17270: PUSH
17271: LD_INT 2
17273: PUSH
17274: LD_INT 1
17276: PUSH
17277: EMPTY
17278: LIST
17279: LIST
17280: LIST
17281: ST_TO_ADDR
// if GetClass ( i ) = 5 then
17282: LD_VAR 0 6
17286: PPUSH
17287: CALL_OW 257
17291: PUSH
17292: LD_INT 5
17294: EQUAL
17295: IFFALSE 17316
// points := [ 130 , 5 , 2 ] ;
17297: LD_ADDR_VAR 0 9
17301: PUSH
17302: LD_INT 130
17304: PUSH
17305: LD_INT 5
17307: PUSH
17308: LD_INT 2
17310: PUSH
17311: EMPTY
17312: LIST
17313: LIST
17314: LIST
17315: ST_TO_ADDR
// if GetClass ( i ) = 8 then
17316: LD_VAR 0 6
17320: PPUSH
17321: CALL_OW 257
17325: PUSH
17326: LD_INT 8
17328: EQUAL
17329: IFFALSE 17350
// points := [ 35 , 35 , 30 ] ;
17331: LD_ADDR_VAR 0 9
17335: PUSH
17336: LD_INT 35
17338: PUSH
17339: LD_INT 35
17341: PUSH
17342: LD_INT 30
17344: PUSH
17345: EMPTY
17346: LIST
17347: LIST
17348: LIST
17349: ST_TO_ADDR
// if GetClass ( i ) = 9 then
17350: LD_VAR 0 6
17354: PPUSH
17355: CALL_OW 257
17359: PUSH
17360: LD_INT 9
17362: EQUAL
17363: IFFALSE 17384
// points := [ 20 , 55 , 40 ] ;
17365: LD_ADDR_VAR 0 9
17369: PUSH
17370: LD_INT 20
17372: PUSH
17373: LD_INT 55
17375: PUSH
17376: LD_INT 40
17378: PUSH
17379: EMPTY
17380: LIST
17381: LIST
17382: LIST
17383: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
17384: LD_VAR 0 6
17388: PPUSH
17389: CALL_OW 257
17393: PUSH
17394: LD_INT 12
17396: PUSH
17397: LD_INT 16
17399: PUSH
17400: EMPTY
17401: LIST
17402: LIST
17403: IN
17404: IFFALSE 17425
// points := [ 5 , 3 , 2 ] ;
17406: LD_ADDR_VAR 0 9
17410: PUSH
17411: LD_INT 5
17413: PUSH
17414: LD_INT 3
17416: PUSH
17417: LD_INT 2
17419: PUSH
17420: EMPTY
17421: LIST
17422: LIST
17423: LIST
17424: ST_TO_ADDR
// if GetClass ( i ) = 17 then
17425: LD_VAR 0 6
17429: PPUSH
17430: CALL_OW 257
17434: PUSH
17435: LD_INT 17
17437: EQUAL
17438: IFFALSE 17459
// points := [ 100 , 50 , 75 ] ;
17440: LD_ADDR_VAR 0 9
17444: PUSH
17445: LD_INT 100
17447: PUSH
17448: LD_INT 50
17450: PUSH
17451: LD_INT 75
17453: PUSH
17454: EMPTY
17455: LIST
17456: LIST
17457: LIST
17458: ST_TO_ADDR
// if GetClass ( i ) = 15 then
17459: LD_VAR 0 6
17463: PPUSH
17464: CALL_OW 257
17468: PUSH
17469: LD_INT 15
17471: EQUAL
17472: IFFALSE 17493
// points := [ 10 , 5 , 3 ] ;
17474: LD_ADDR_VAR 0 9
17478: PUSH
17479: LD_INT 10
17481: PUSH
17482: LD_INT 5
17484: PUSH
17485: LD_INT 3
17487: PUSH
17488: EMPTY
17489: LIST
17490: LIST
17491: LIST
17492: ST_TO_ADDR
// if GetClass ( i ) = 14 then
17493: LD_VAR 0 6
17497: PPUSH
17498: CALL_OW 257
17502: PUSH
17503: LD_INT 14
17505: EQUAL
17506: IFFALSE 17527
// points := [ 10 , 0 , 0 ] ;
17508: LD_ADDR_VAR 0 9
17512: PUSH
17513: LD_INT 10
17515: PUSH
17516: LD_INT 0
17518: PUSH
17519: LD_INT 0
17521: PUSH
17522: EMPTY
17523: LIST
17524: LIST
17525: LIST
17526: ST_TO_ADDR
// if GetClass ( i ) = 11 then
17527: LD_VAR 0 6
17531: PPUSH
17532: CALL_OW 257
17536: PUSH
17537: LD_INT 11
17539: EQUAL
17540: IFFALSE 17561
// points := [ 30 , 10 , 5 ] ;
17542: LD_ADDR_VAR 0 9
17546: PUSH
17547: LD_INT 30
17549: PUSH
17550: LD_INT 10
17552: PUSH
17553: LD_INT 5
17555: PUSH
17556: EMPTY
17557: LIST
17558: LIST
17559: LIST
17560: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
17561: LD_VAR 0 1
17565: PPUSH
17566: LD_INT 5
17568: PPUSH
17569: CALL_OW 321
17573: PUSH
17574: LD_INT 2
17576: EQUAL
17577: IFFALSE 17594
// bpoints := bpoints * 1.8 ;
17579: LD_ADDR_VAR 0 10
17583: PUSH
17584: LD_VAR 0 10
17588: PUSH
17589: LD_REAL  1.80000000000000E+0000
17592: MUL
17593: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
17594: LD_VAR 0 6
17598: PPUSH
17599: CALL_OW 257
17603: PUSH
17604: LD_INT 1
17606: PUSH
17607: LD_INT 2
17609: PUSH
17610: LD_INT 3
17612: PUSH
17613: LD_INT 4
17615: PUSH
17616: EMPTY
17617: LIST
17618: LIST
17619: LIST
17620: LIST
17621: IN
17622: PUSH
17623: LD_VAR 0 1
17627: PPUSH
17628: LD_INT 51
17630: PPUSH
17631: CALL_OW 321
17635: PUSH
17636: LD_INT 2
17638: EQUAL
17639: AND
17640: IFFALSE 17657
// bpoints := bpoints * 1.2 ;
17642: LD_ADDR_VAR 0 10
17646: PUSH
17647: LD_VAR 0 10
17651: PUSH
17652: LD_REAL  1.20000000000000E+0000
17655: MUL
17656: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
17657: LD_VAR 0 6
17661: PPUSH
17662: CALL_OW 257
17666: PUSH
17667: LD_INT 5
17669: PUSH
17670: LD_INT 7
17672: PUSH
17673: LD_INT 9
17675: PUSH
17676: EMPTY
17677: LIST
17678: LIST
17679: LIST
17680: IN
17681: PUSH
17682: LD_VAR 0 1
17686: PPUSH
17687: LD_INT 52
17689: PPUSH
17690: CALL_OW 321
17694: PUSH
17695: LD_INT 2
17697: EQUAL
17698: AND
17699: IFFALSE 17716
// bpoints := bpoints * 1.5 ;
17701: LD_ADDR_VAR 0 10
17705: PUSH
17706: LD_VAR 0 10
17710: PUSH
17711: LD_REAL  1.50000000000000E+0000
17714: MUL
17715: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
17716: LD_VAR 0 1
17720: PPUSH
17721: LD_INT 66
17723: PPUSH
17724: CALL_OW 321
17728: PUSH
17729: LD_INT 2
17731: EQUAL
17732: IFFALSE 17749
// bpoints := bpoints * 1.1 ;
17734: LD_ADDR_VAR 0 10
17738: PUSH
17739: LD_VAR 0 10
17743: PUSH
17744: LD_REAL  1.10000000000000E+0000
17747: MUL
17748: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
17749: LD_ADDR_VAR 0 10
17753: PUSH
17754: LD_VAR 0 10
17758: PUSH
17759: LD_VAR 0 6
17763: PPUSH
17764: LD_INT 1
17766: PPUSH
17767: CALL_OW 259
17771: PUSH
17772: LD_REAL  1.15000000000000E+0000
17775: MUL
17776: MUL
17777: ST_TO_ADDR
// end ; unit_vehicle :
17778: GO 18606
17780: LD_INT 2
17782: DOUBLE
17783: EQUAL
17784: IFTRUE 17788
17786: GO 18594
17788: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
17789: LD_VAR 0 6
17793: PPUSH
17794: CALL_OW 264
17798: PUSH
17799: LD_INT 2
17801: PUSH
17802: LD_INT 42
17804: PUSH
17805: LD_INT 24
17807: PUSH
17808: EMPTY
17809: LIST
17810: LIST
17811: LIST
17812: IN
17813: IFFALSE 17834
// points := [ 25 , 5 , 3 ] ;
17815: LD_ADDR_VAR 0 9
17819: PUSH
17820: LD_INT 25
17822: PUSH
17823: LD_INT 5
17825: PUSH
17826: LD_INT 3
17828: PUSH
17829: EMPTY
17830: LIST
17831: LIST
17832: LIST
17833: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
17834: LD_VAR 0 6
17838: PPUSH
17839: CALL_OW 264
17843: PUSH
17844: LD_INT 4
17846: PUSH
17847: LD_INT 43
17849: PUSH
17850: LD_INT 25
17852: PUSH
17853: EMPTY
17854: LIST
17855: LIST
17856: LIST
17857: IN
17858: IFFALSE 17879
// points := [ 40 , 15 , 5 ] ;
17860: LD_ADDR_VAR 0 9
17864: PUSH
17865: LD_INT 40
17867: PUSH
17868: LD_INT 15
17870: PUSH
17871: LD_INT 5
17873: PUSH
17874: EMPTY
17875: LIST
17876: LIST
17877: LIST
17878: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
17879: LD_VAR 0 6
17883: PPUSH
17884: CALL_OW 264
17888: PUSH
17889: LD_INT 3
17891: PUSH
17892: LD_INT 23
17894: PUSH
17895: EMPTY
17896: LIST
17897: LIST
17898: IN
17899: IFFALSE 17920
// points := [ 7 , 25 , 8 ] ;
17901: LD_ADDR_VAR 0 9
17905: PUSH
17906: LD_INT 7
17908: PUSH
17909: LD_INT 25
17911: PUSH
17912: LD_INT 8
17914: PUSH
17915: EMPTY
17916: LIST
17917: LIST
17918: LIST
17919: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
17920: LD_VAR 0 6
17924: PPUSH
17925: CALL_OW 264
17929: PUSH
17930: LD_INT 5
17932: PUSH
17933: LD_INT 27
17935: PUSH
17936: LD_INT 44
17938: PUSH
17939: EMPTY
17940: LIST
17941: LIST
17942: LIST
17943: IN
17944: IFFALSE 17965
// points := [ 14 , 50 , 16 ] ;
17946: LD_ADDR_VAR 0 9
17950: PUSH
17951: LD_INT 14
17953: PUSH
17954: LD_INT 50
17956: PUSH
17957: LD_INT 16
17959: PUSH
17960: EMPTY
17961: LIST
17962: LIST
17963: LIST
17964: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
17965: LD_VAR 0 6
17969: PPUSH
17970: CALL_OW 264
17974: PUSH
17975: LD_INT 6
17977: PUSH
17978: LD_INT 46
17980: PUSH
17981: EMPTY
17982: LIST
17983: LIST
17984: IN
17985: IFFALSE 18006
// points := [ 32 , 120 , 70 ] ;
17987: LD_ADDR_VAR 0 9
17991: PUSH
17992: LD_INT 32
17994: PUSH
17995: LD_INT 120
17997: PUSH
17998: LD_INT 70
18000: PUSH
18001: EMPTY
18002: LIST
18003: LIST
18004: LIST
18005: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
18006: LD_VAR 0 6
18010: PPUSH
18011: CALL_OW 264
18015: PUSH
18016: LD_INT 7
18018: PUSH
18019: LD_INT 28
18021: PUSH
18022: LD_INT 45
18024: PUSH
18025: LD_INT 92
18027: PUSH
18028: EMPTY
18029: LIST
18030: LIST
18031: LIST
18032: LIST
18033: IN
18034: IFFALSE 18055
// points := [ 35 , 20 , 45 ] ;
18036: LD_ADDR_VAR 0 9
18040: PUSH
18041: LD_INT 35
18043: PUSH
18044: LD_INT 20
18046: PUSH
18047: LD_INT 45
18049: PUSH
18050: EMPTY
18051: LIST
18052: LIST
18053: LIST
18054: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
18055: LD_VAR 0 6
18059: PPUSH
18060: CALL_OW 264
18064: PUSH
18065: LD_INT 47
18067: PUSH
18068: EMPTY
18069: LIST
18070: IN
18071: IFFALSE 18092
// points := [ 67 , 45 , 75 ] ;
18073: LD_ADDR_VAR 0 9
18077: PUSH
18078: LD_INT 67
18080: PUSH
18081: LD_INT 45
18083: PUSH
18084: LD_INT 75
18086: PUSH
18087: EMPTY
18088: LIST
18089: LIST
18090: LIST
18091: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
18092: LD_VAR 0 6
18096: PPUSH
18097: CALL_OW 264
18101: PUSH
18102: LD_INT 26
18104: PUSH
18105: EMPTY
18106: LIST
18107: IN
18108: IFFALSE 18129
// points := [ 120 , 30 , 80 ] ;
18110: LD_ADDR_VAR 0 9
18114: PUSH
18115: LD_INT 120
18117: PUSH
18118: LD_INT 30
18120: PUSH
18121: LD_INT 80
18123: PUSH
18124: EMPTY
18125: LIST
18126: LIST
18127: LIST
18128: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
18129: LD_VAR 0 6
18133: PPUSH
18134: CALL_OW 264
18138: PUSH
18139: LD_INT 22
18141: PUSH
18142: EMPTY
18143: LIST
18144: IN
18145: IFFALSE 18166
// points := [ 40 , 1 , 1 ] ;
18147: LD_ADDR_VAR 0 9
18151: PUSH
18152: LD_INT 40
18154: PUSH
18155: LD_INT 1
18157: PUSH
18158: LD_INT 1
18160: PUSH
18161: EMPTY
18162: LIST
18163: LIST
18164: LIST
18165: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
18166: LD_VAR 0 6
18170: PPUSH
18171: CALL_OW 264
18175: PUSH
18176: LD_INT 29
18178: PUSH
18179: EMPTY
18180: LIST
18181: IN
18182: IFFALSE 18203
// points := [ 70 , 200 , 400 ] ;
18184: LD_ADDR_VAR 0 9
18188: PUSH
18189: LD_INT 70
18191: PUSH
18192: LD_INT 200
18194: PUSH
18195: LD_INT 400
18197: PUSH
18198: EMPTY
18199: LIST
18200: LIST
18201: LIST
18202: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
18203: LD_VAR 0 6
18207: PPUSH
18208: CALL_OW 264
18212: PUSH
18213: LD_INT 14
18215: PUSH
18216: LD_INT 53
18218: PUSH
18219: EMPTY
18220: LIST
18221: LIST
18222: IN
18223: IFFALSE 18244
// points := [ 40 , 10 , 20 ] ;
18225: LD_ADDR_VAR 0 9
18229: PUSH
18230: LD_INT 40
18232: PUSH
18233: LD_INT 10
18235: PUSH
18236: LD_INT 20
18238: PUSH
18239: EMPTY
18240: LIST
18241: LIST
18242: LIST
18243: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
18244: LD_VAR 0 6
18248: PPUSH
18249: CALL_OW 264
18253: PUSH
18254: LD_INT 9
18256: PUSH
18257: EMPTY
18258: LIST
18259: IN
18260: IFFALSE 18281
// points := [ 5 , 70 , 20 ] ;
18262: LD_ADDR_VAR 0 9
18266: PUSH
18267: LD_INT 5
18269: PUSH
18270: LD_INT 70
18272: PUSH
18273: LD_INT 20
18275: PUSH
18276: EMPTY
18277: LIST
18278: LIST
18279: LIST
18280: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
18281: LD_VAR 0 6
18285: PPUSH
18286: CALL_OW 264
18290: PUSH
18291: LD_INT 10
18293: PUSH
18294: EMPTY
18295: LIST
18296: IN
18297: IFFALSE 18318
// points := [ 35 , 110 , 70 ] ;
18299: LD_ADDR_VAR 0 9
18303: PUSH
18304: LD_INT 35
18306: PUSH
18307: LD_INT 110
18309: PUSH
18310: LD_INT 70
18312: PUSH
18313: EMPTY
18314: LIST
18315: LIST
18316: LIST
18317: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
18318: LD_VAR 0 6
18322: PPUSH
18323: CALL_OW 265
18327: PUSH
18328: LD_INT 25
18330: EQUAL
18331: IFFALSE 18352
// points := [ 80 , 65 , 100 ] ;
18333: LD_ADDR_VAR 0 9
18337: PUSH
18338: LD_INT 80
18340: PUSH
18341: LD_INT 65
18343: PUSH
18344: LD_INT 100
18346: PUSH
18347: EMPTY
18348: LIST
18349: LIST
18350: LIST
18351: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
18352: LD_VAR 0 6
18356: PPUSH
18357: CALL_OW 263
18361: PUSH
18362: LD_INT 1
18364: EQUAL
18365: IFFALSE 18400
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
18367: LD_ADDR_VAR 0 10
18371: PUSH
18372: LD_VAR 0 10
18376: PUSH
18377: LD_VAR 0 6
18381: PPUSH
18382: CALL_OW 311
18386: PPUSH
18387: LD_INT 3
18389: PPUSH
18390: CALL_OW 259
18394: PUSH
18395: LD_INT 4
18397: MUL
18398: MUL
18399: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
18400: LD_VAR 0 6
18404: PPUSH
18405: CALL_OW 263
18409: PUSH
18410: LD_INT 2
18412: EQUAL
18413: IFFALSE 18464
// begin j := IsControledBy ( i ) ;
18415: LD_ADDR_VAR 0 7
18419: PUSH
18420: LD_VAR 0 6
18424: PPUSH
18425: CALL_OW 312
18429: ST_TO_ADDR
// if j then
18430: LD_VAR 0 7
18434: IFFALSE 18464
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
18436: LD_ADDR_VAR 0 10
18440: PUSH
18441: LD_VAR 0 10
18445: PUSH
18446: LD_VAR 0 7
18450: PPUSH
18451: LD_INT 3
18453: PPUSH
18454: CALL_OW 259
18458: PUSH
18459: LD_INT 3
18461: MUL
18462: MUL
18463: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
18464: LD_VAR 0 6
18468: PPUSH
18469: CALL_OW 264
18473: PUSH
18474: LD_INT 5
18476: PUSH
18477: LD_INT 6
18479: PUSH
18480: LD_INT 46
18482: PUSH
18483: LD_INT 44
18485: PUSH
18486: LD_INT 47
18488: PUSH
18489: LD_INT 45
18491: PUSH
18492: LD_INT 28
18494: PUSH
18495: LD_INT 7
18497: PUSH
18498: LD_INT 27
18500: PUSH
18501: LD_INT 29
18503: PUSH
18504: EMPTY
18505: LIST
18506: LIST
18507: LIST
18508: LIST
18509: LIST
18510: LIST
18511: LIST
18512: LIST
18513: LIST
18514: LIST
18515: IN
18516: PUSH
18517: LD_VAR 0 1
18521: PPUSH
18522: LD_INT 52
18524: PPUSH
18525: CALL_OW 321
18529: PUSH
18530: LD_INT 2
18532: EQUAL
18533: AND
18534: IFFALSE 18551
// bpoints := bpoints * 1.2 ;
18536: LD_ADDR_VAR 0 10
18540: PUSH
18541: LD_VAR 0 10
18545: PUSH
18546: LD_REAL  1.20000000000000E+0000
18549: MUL
18550: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
18551: LD_VAR 0 6
18555: PPUSH
18556: CALL_OW 264
18560: PUSH
18561: LD_INT 6
18563: PUSH
18564: LD_INT 46
18566: PUSH
18567: LD_INT 47
18569: PUSH
18570: EMPTY
18571: LIST
18572: LIST
18573: LIST
18574: IN
18575: IFFALSE 18592
// bpoints := bpoints * 1.2 ;
18577: LD_ADDR_VAR 0 10
18581: PUSH
18582: LD_VAR 0 10
18586: PUSH
18587: LD_REAL  1.20000000000000E+0000
18590: MUL
18591: ST_TO_ADDR
// end ; unit_building :
18592: GO 18606
18594: LD_INT 3
18596: DOUBLE
18597: EQUAL
18598: IFTRUE 18602
18600: GO 18605
18602: POP
// ; end ;
18603: GO 18606
18605: POP
// for j = 1 to 3 do
18606: LD_ADDR_VAR 0 7
18610: PUSH
18611: DOUBLE
18612: LD_INT 1
18614: DEC
18615: ST_TO_ADDR
18616: LD_INT 3
18618: PUSH
18619: FOR_TO
18620: IFFALSE 18673
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
18622: LD_ADDR_VAR 0 5
18626: PUSH
18627: LD_VAR 0 5
18631: PPUSH
18632: LD_VAR 0 7
18636: PPUSH
18637: LD_VAR 0 5
18641: PUSH
18642: LD_VAR 0 7
18646: ARRAY
18647: PUSH
18648: LD_VAR 0 9
18652: PUSH
18653: LD_VAR 0 7
18657: ARRAY
18658: PUSH
18659: LD_VAR 0 10
18663: MUL
18664: PLUS
18665: PPUSH
18666: CALL_OW 1
18670: ST_TO_ADDR
18671: GO 18619
18673: POP
18674: POP
// end ;
18675: GO 17154
18677: POP
18678: POP
// result := Replace ( result , 4 , tmp ) ;
18679: LD_ADDR_VAR 0 5
18683: PUSH
18684: LD_VAR 0 5
18688: PPUSH
18689: LD_INT 4
18691: PPUSH
18692: LD_VAR 0 8
18696: PPUSH
18697: CALL_OW 1
18701: ST_TO_ADDR
// end ;
18702: LD_VAR 0 5
18706: RET
// export function DangerAtRange ( unit , range ) ; begin
18707: LD_INT 0
18709: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
18710: LD_ADDR_VAR 0 3
18714: PUSH
18715: LD_VAR 0 1
18719: PPUSH
18720: CALL_OW 255
18724: PPUSH
18725: LD_VAR 0 1
18729: PPUSH
18730: CALL_OW 250
18734: PPUSH
18735: LD_VAR 0 1
18739: PPUSH
18740: CALL_OW 251
18744: PPUSH
18745: LD_VAR 0 2
18749: PPUSH
18750: CALL 17006 0 4
18754: ST_TO_ADDR
// end ;
18755: LD_VAR 0 3
18759: RET
// export function DangerInArea ( side , area ) ; begin
18760: LD_INT 0
18762: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
18763: LD_ADDR_VAR 0 3
18767: PUSH
18768: LD_VAR 0 2
18772: PPUSH
18773: LD_INT 81
18775: PUSH
18776: LD_VAR 0 1
18780: PUSH
18781: EMPTY
18782: LIST
18783: LIST
18784: PPUSH
18785: CALL_OW 70
18789: ST_TO_ADDR
// end ;
18790: LD_VAR 0 3
18794: RET
// export function IsExtension ( b ) ; begin
18795: LD_INT 0
18797: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
18798: LD_ADDR_VAR 0 2
18802: PUSH
18803: LD_VAR 0 1
18807: PUSH
18808: LD_INT 23
18810: PUSH
18811: LD_INT 20
18813: PUSH
18814: LD_INT 22
18816: PUSH
18817: LD_INT 17
18819: PUSH
18820: LD_INT 24
18822: PUSH
18823: LD_INT 21
18825: PUSH
18826: LD_INT 19
18828: PUSH
18829: LD_INT 16
18831: PUSH
18832: LD_INT 25
18834: PUSH
18835: LD_INT 18
18837: PUSH
18838: EMPTY
18839: LIST
18840: LIST
18841: LIST
18842: LIST
18843: LIST
18844: LIST
18845: LIST
18846: LIST
18847: LIST
18848: LIST
18849: IN
18850: ST_TO_ADDR
// end ;
18851: LD_VAR 0 2
18855: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
18856: LD_INT 0
18858: PPUSH
18859: PPUSH
18860: PPUSH
// result := [ ] ;
18861: LD_ADDR_VAR 0 4
18865: PUSH
18866: EMPTY
18867: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
18868: LD_ADDR_VAR 0 5
18872: PUSH
18873: LD_VAR 0 2
18877: PPUSH
18878: LD_INT 21
18880: PUSH
18881: LD_INT 3
18883: PUSH
18884: EMPTY
18885: LIST
18886: LIST
18887: PPUSH
18888: CALL_OW 70
18892: ST_TO_ADDR
// if not tmp then
18893: LD_VAR 0 5
18897: NOT
18898: IFFALSE 18902
// exit ;
18900: GO 18966
// if checkLink then
18902: LD_VAR 0 3
18906: IFFALSE 18956
// begin for i in tmp do
18908: LD_ADDR_VAR 0 6
18912: PUSH
18913: LD_VAR 0 5
18917: PUSH
18918: FOR_IN
18919: IFFALSE 18954
// if GetBase ( i ) <> base then
18921: LD_VAR 0 6
18925: PPUSH
18926: CALL_OW 274
18930: PUSH
18931: LD_VAR 0 1
18935: NONEQUAL
18936: IFFALSE 18952
// ComLinkToBase ( base , i ) ;
18938: LD_VAR 0 1
18942: PPUSH
18943: LD_VAR 0 6
18947: PPUSH
18948: CALL_OW 169
18952: GO 18918
18954: POP
18955: POP
// end ; result := tmp ;
18956: LD_ADDR_VAR 0 4
18960: PUSH
18961: LD_VAR 0 5
18965: ST_TO_ADDR
// end ;
18966: LD_VAR 0 4
18970: RET
// export function ComComplete ( units , b ) ; var i ; begin
18971: LD_INT 0
18973: PPUSH
18974: PPUSH
// if not units then
18975: LD_VAR 0 1
18979: NOT
18980: IFFALSE 18984
// exit ;
18982: GO 19074
// for i in units do
18984: LD_ADDR_VAR 0 4
18988: PUSH
18989: LD_VAR 0 1
18993: PUSH
18994: FOR_IN
18995: IFFALSE 19072
// if BuildingStatus ( b ) = bs_build then
18997: LD_VAR 0 2
19001: PPUSH
19002: CALL_OW 461
19006: PUSH
19007: LD_INT 1
19009: EQUAL
19010: IFFALSE 19070
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
19012: LD_VAR 0 4
19016: PPUSH
19017: LD_STRING h
19019: PUSH
19020: LD_VAR 0 2
19024: PPUSH
19025: CALL_OW 250
19029: PUSH
19030: LD_VAR 0 2
19034: PPUSH
19035: CALL_OW 251
19039: PUSH
19040: LD_VAR 0 2
19044: PUSH
19045: LD_INT 0
19047: PUSH
19048: LD_INT 0
19050: PUSH
19051: LD_INT 0
19053: PUSH
19054: EMPTY
19055: LIST
19056: LIST
19057: LIST
19058: LIST
19059: LIST
19060: LIST
19061: LIST
19062: PUSH
19063: EMPTY
19064: LIST
19065: PPUSH
19066: CALL_OW 446
19070: GO 18994
19072: POP
19073: POP
// end ;
19074: LD_VAR 0 3
19078: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
19079: LD_INT 0
19081: PPUSH
19082: PPUSH
19083: PPUSH
19084: PPUSH
19085: PPUSH
19086: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
19087: LD_VAR 0 1
19091: NOT
19092: PUSH
19093: LD_VAR 0 1
19097: PPUSH
19098: CALL_OW 263
19102: PUSH
19103: LD_INT 2
19105: NONEQUAL
19106: OR
19107: IFFALSE 19111
// exit ;
19109: GO 19427
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
19111: LD_ADDR_VAR 0 6
19115: PUSH
19116: LD_INT 22
19118: PUSH
19119: LD_VAR 0 1
19123: PPUSH
19124: CALL_OW 255
19128: PUSH
19129: EMPTY
19130: LIST
19131: LIST
19132: PUSH
19133: LD_INT 2
19135: PUSH
19136: LD_INT 30
19138: PUSH
19139: LD_INT 36
19141: PUSH
19142: EMPTY
19143: LIST
19144: LIST
19145: PUSH
19146: LD_INT 34
19148: PUSH
19149: LD_INT 31
19151: PUSH
19152: EMPTY
19153: LIST
19154: LIST
19155: PUSH
19156: EMPTY
19157: LIST
19158: LIST
19159: LIST
19160: PUSH
19161: EMPTY
19162: LIST
19163: LIST
19164: PPUSH
19165: CALL_OW 69
19169: ST_TO_ADDR
// if not tmp then
19170: LD_VAR 0 6
19174: NOT
19175: IFFALSE 19179
// exit ;
19177: GO 19427
// result := [ ] ;
19179: LD_ADDR_VAR 0 2
19183: PUSH
19184: EMPTY
19185: ST_TO_ADDR
// for i in tmp do
19186: LD_ADDR_VAR 0 3
19190: PUSH
19191: LD_VAR 0 6
19195: PUSH
19196: FOR_IN
19197: IFFALSE 19268
// begin t := UnitsInside ( i ) ;
19199: LD_ADDR_VAR 0 4
19203: PUSH
19204: LD_VAR 0 3
19208: PPUSH
19209: CALL_OW 313
19213: ST_TO_ADDR
// if t then
19214: LD_VAR 0 4
19218: IFFALSE 19266
// for j in t do
19220: LD_ADDR_VAR 0 7
19224: PUSH
19225: LD_VAR 0 4
19229: PUSH
19230: FOR_IN
19231: IFFALSE 19264
// result := Replace ( result , result + 1 , j ) ;
19233: LD_ADDR_VAR 0 2
19237: PUSH
19238: LD_VAR 0 2
19242: PPUSH
19243: LD_VAR 0 2
19247: PUSH
19248: LD_INT 1
19250: PLUS
19251: PPUSH
19252: LD_VAR 0 7
19256: PPUSH
19257: CALL_OW 1
19261: ST_TO_ADDR
19262: GO 19230
19264: POP
19265: POP
// end ;
19266: GO 19196
19268: POP
19269: POP
// if not result then
19270: LD_VAR 0 2
19274: NOT
19275: IFFALSE 19279
// exit ;
19277: GO 19427
// mech := result [ 1 ] ;
19279: LD_ADDR_VAR 0 5
19283: PUSH
19284: LD_VAR 0 2
19288: PUSH
19289: LD_INT 1
19291: ARRAY
19292: ST_TO_ADDR
// if result > 1 then
19293: LD_VAR 0 2
19297: PUSH
19298: LD_INT 1
19300: GREATER
19301: IFFALSE 19413
// begin for i = 2 to result do
19303: LD_ADDR_VAR 0 3
19307: PUSH
19308: DOUBLE
19309: LD_INT 2
19311: DEC
19312: ST_TO_ADDR
19313: LD_VAR 0 2
19317: PUSH
19318: FOR_TO
19319: IFFALSE 19411
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
19321: LD_ADDR_VAR 0 4
19325: PUSH
19326: LD_VAR 0 2
19330: PUSH
19331: LD_VAR 0 3
19335: ARRAY
19336: PPUSH
19337: LD_INT 3
19339: PPUSH
19340: CALL_OW 259
19344: PUSH
19345: LD_VAR 0 2
19349: PUSH
19350: LD_VAR 0 3
19354: ARRAY
19355: PPUSH
19356: CALL_OW 432
19360: MINUS
19361: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
19362: LD_VAR 0 4
19366: PUSH
19367: LD_VAR 0 5
19371: PPUSH
19372: LD_INT 3
19374: PPUSH
19375: CALL_OW 259
19379: PUSH
19380: LD_VAR 0 5
19384: PPUSH
19385: CALL_OW 432
19389: MINUS
19390: GREATEREQUAL
19391: IFFALSE 19409
// mech := result [ i ] ;
19393: LD_ADDR_VAR 0 5
19397: PUSH
19398: LD_VAR 0 2
19402: PUSH
19403: LD_VAR 0 3
19407: ARRAY
19408: ST_TO_ADDR
// end ;
19409: GO 19318
19411: POP
19412: POP
// end ; ComLinkTo ( vehicle , mech ) ;
19413: LD_VAR 0 1
19417: PPUSH
19418: LD_VAR 0 5
19422: PPUSH
19423: CALL_OW 135
// end ;
19427: LD_VAR 0 2
19431: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
19432: LD_INT 0
19434: PPUSH
19435: PPUSH
19436: PPUSH
19437: PPUSH
19438: PPUSH
19439: PPUSH
19440: PPUSH
19441: PPUSH
19442: PPUSH
19443: PPUSH
19444: PPUSH
19445: PPUSH
19446: PPUSH
// result := [ ] ;
19447: LD_ADDR_VAR 0 7
19451: PUSH
19452: EMPTY
19453: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
19454: LD_VAR 0 1
19458: PPUSH
19459: CALL_OW 266
19463: PUSH
19464: LD_INT 0
19466: PUSH
19467: LD_INT 1
19469: PUSH
19470: EMPTY
19471: LIST
19472: LIST
19473: IN
19474: NOT
19475: IFFALSE 19479
// exit ;
19477: GO 21113
// if name then
19479: LD_VAR 0 3
19483: IFFALSE 19499
// SetBName ( base_dep , name ) ;
19485: LD_VAR 0 1
19489: PPUSH
19490: LD_VAR 0 3
19494: PPUSH
19495: CALL_OW 500
// base := GetBase ( base_dep ) ;
19499: LD_ADDR_VAR 0 15
19503: PUSH
19504: LD_VAR 0 1
19508: PPUSH
19509: CALL_OW 274
19513: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
19514: LD_ADDR_VAR 0 16
19518: PUSH
19519: LD_VAR 0 1
19523: PPUSH
19524: CALL_OW 255
19528: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
19529: LD_ADDR_VAR 0 17
19533: PUSH
19534: LD_VAR 0 1
19538: PPUSH
19539: CALL_OW 248
19543: ST_TO_ADDR
// if sources then
19544: LD_VAR 0 5
19548: IFFALSE 19595
// for i = 1 to 3 do
19550: LD_ADDR_VAR 0 8
19554: PUSH
19555: DOUBLE
19556: LD_INT 1
19558: DEC
19559: ST_TO_ADDR
19560: LD_INT 3
19562: PUSH
19563: FOR_TO
19564: IFFALSE 19593
// AddResourceType ( base , i , sources [ i ] ) ;
19566: LD_VAR 0 15
19570: PPUSH
19571: LD_VAR 0 8
19575: PPUSH
19576: LD_VAR 0 5
19580: PUSH
19581: LD_VAR 0 8
19585: ARRAY
19586: PPUSH
19587: CALL_OW 276
19591: GO 19563
19593: POP
19594: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
19595: LD_ADDR_VAR 0 18
19599: PUSH
19600: LD_VAR 0 15
19604: PPUSH
19605: LD_VAR 0 2
19609: PPUSH
19610: LD_INT 1
19612: PPUSH
19613: CALL 18856 0 3
19617: ST_TO_ADDR
// InitHc ;
19618: CALL_OW 19
// InitUc ;
19622: CALL_OW 18
// uc_side := side ;
19626: LD_ADDR_OWVAR 20
19630: PUSH
19631: LD_VAR 0 16
19635: ST_TO_ADDR
// uc_nation := nation ;
19636: LD_ADDR_OWVAR 21
19640: PUSH
19641: LD_VAR 0 17
19645: ST_TO_ADDR
// if buildings then
19646: LD_VAR 0 18
19650: IFFALSE 20972
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
19652: LD_ADDR_VAR 0 19
19656: PUSH
19657: LD_VAR 0 18
19661: PPUSH
19662: LD_INT 2
19664: PUSH
19665: LD_INT 30
19667: PUSH
19668: LD_INT 29
19670: PUSH
19671: EMPTY
19672: LIST
19673: LIST
19674: PUSH
19675: LD_INT 30
19677: PUSH
19678: LD_INT 30
19680: PUSH
19681: EMPTY
19682: LIST
19683: LIST
19684: PUSH
19685: EMPTY
19686: LIST
19687: LIST
19688: LIST
19689: PPUSH
19690: CALL_OW 72
19694: ST_TO_ADDR
// if tmp then
19695: LD_VAR 0 19
19699: IFFALSE 19747
// for i in tmp do
19701: LD_ADDR_VAR 0 8
19705: PUSH
19706: LD_VAR 0 19
19710: PUSH
19711: FOR_IN
19712: IFFALSE 19745
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
19714: LD_VAR 0 8
19718: PPUSH
19719: CALL_OW 250
19723: PPUSH
19724: LD_VAR 0 8
19728: PPUSH
19729: CALL_OW 251
19733: PPUSH
19734: LD_VAR 0 16
19738: PPUSH
19739: CALL_OW 441
19743: GO 19711
19745: POP
19746: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
19747: LD_VAR 0 18
19751: PPUSH
19752: LD_INT 2
19754: PUSH
19755: LD_INT 30
19757: PUSH
19758: LD_INT 32
19760: PUSH
19761: EMPTY
19762: LIST
19763: LIST
19764: PUSH
19765: LD_INT 30
19767: PUSH
19768: LD_INT 33
19770: PUSH
19771: EMPTY
19772: LIST
19773: LIST
19774: PUSH
19775: EMPTY
19776: LIST
19777: LIST
19778: LIST
19779: PPUSH
19780: CALL_OW 72
19784: IFFALSE 19872
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
19786: LD_ADDR_VAR 0 8
19790: PUSH
19791: LD_VAR 0 18
19795: PPUSH
19796: LD_INT 2
19798: PUSH
19799: LD_INT 30
19801: PUSH
19802: LD_INT 32
19804: PUSH
19805: EMPTY
19806: LIST
19807: LIST
19808: PUSH
19809: LD_INT 30
19811: PUSH
19812: LD_INT 33
19814: PUSH
19815: EMPTY
19816: LIST
19817: LIST
19818: PUSH
19819: EMPTY
19820: LIST
19821: LIST
19822: LIST
19823: PPUSH
19824: CALL_OW 72
19828: PUSH
19829: FOR_IN
19830: IFFALSE 19870
// begin if not GetBWeapon ( i ) then
19832: LD_VAR 0 8
19836: PPUSH
19837: CALL_OW 269
19841: NOT
19842: IFFALSE 19868
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
19844: LD_VAR 0 8
19848: PPUSH
19849: LD_VAR 0 8
19853: PPUSH
19854: LD_VAR 0 2
19858: PPUSH
19859: CALL 21118 0 2
19863: PPUSH
19864: CALL_OW 431
// end ;
19868: GO 19829
19870: POP
19871: POP
// end ; for i = 1 to personel do
19872: LD_ADDR_VAR 0 8
19876: PUSH
19877: DOUBLE
19878: LD_INT 1
19880: DEC
19881: ST_TO_ADDR
19882: LD_VAR 0 6
19886: PUSH
19887: FOR_TO
19888: IFFALSE 20952
// begin if i > 4 then
19890: LD_VAR 0 8
19894: PUSH
19895: LD_INT 4
19897: GREATER
19898: IFFALSE 19902
// break ;
19900: GO 20952
// case i of 1 :
19902: LD_VAR 0 8
19906: PUSH
19907: LD_INT 1
19909: DOUBLE
19910: EQUAL
19911: IFTRUE 19915
19913: GO 19995
19915: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
19916: LD_ADDR_VAR 0 12
19920: PUSH
19921: LD_VAR 0 18
19925: PPUSH
19926: LD_INT 22
19928: PUSH
19929: LD_VAR 0 16
19933: PUSH
19934: EMPTY
19935: LIST
19936: LIST
19937: PUSH
19938: LD_INT 58
19940: PUSH
19941: EMPTY
19942: LIST
19943: PUSH
19944: LD_INT 2
19946: PUSH
19947: LD_INT 30
19949: PUSH
19950: LD_INT 32
19952: PUSH
19953: EMPTY
19954: LIST
19955: LIST
19956: PUSH
19957: LD_INT 30
19959: PUSH
19960: LD_INT 4
19962: PUSH
19963: EMPTY
19964: LIST
19965: LIST
19966: PUSH
19967: LD_INT 30
19969: PUSH
19970: LD_INT 5
19972: PUSH
19973: EMPTY
19974: LIST
19975: LIST
19976: PUSH
19977: EMPTY
19978: LIST
19979: LIST
19980: LIST
19981: LIST
19982: PUSH
19983: EMPTY
19984: LIST
19985: LIST
19986: LIST
19987: PPUSH
19988: CALL_OW 72
19992: ST_TO_ADDR
19993: GO 20217
19995: LD_INT 2
19997: DOUBLE
19998: EQUAL
19999: IFTRUE 20003
20001: GO 20065
20003: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
20004: LD_ADDR_VAR 0 12
20008: PUSH
20009: LD_VAR 0 18
20013: PPUSH
20014: LD_INT 22
20016: PUSH
20017: LD_VAR 0 16
20021: PUSH
20022: EMPTY
20023: LIST
20024: LIST
20025: PUSH
20026: LD_INT 2
20028: PUSH
20029: LD_INT 30
20031: PUSH
20032: LD_INT 0
20034: PUSH
20035: EMPTY
20036: LIST
20037: LIST
20038: PUSH
20039: LD_INT 30
20041: PUSH
20042: LD_INT 1
20044: PUSH
20045: EMPTY
20046: LIST
20047: LIST
20048: PUSH
20049: EMPTY
20050: LIST
20051: LIST
20052: LIST
20053: PUSH
20054: EMPTY
20055: LIST
20056: LIST
20057: PPUSH
20058: CALL_OW 72
20062: ST_TO_ADDR
20063: GO 20217
20065: LD_INT 3
20067: DOUBLE
20068: EQUAL
20069: IFTRUE 20073
20071: GO 20135
20073: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
20074: LD_ADDR_VAR 0 12
20078: PUSH
20079: LD_VAR 0 18
20083: PPUSH
20084: LD_INT 22
20086: PUSH
20087: LD_VAR 0 16
20091: PUSH
20092: EMPTY
20093: LIST
20094: LIST
20095: PUSH
20096: LD_INT 2
20098: PUSH
20099: LD_INT 30
20101: PUSH
20102: LD_INT 2
20104: PUSH
20105: EMPTY
20106: LIST
20107: LIST
20108: PUSH
20109: LD_INT 30
20111: PUSH
20112: LD_INT 3
20114: PUSH
20115: EMPTY
20116: LIST
20117: LIST
20118: PUSH
20119: EMPTY
20120: LIST
20121: LIST
20122: LIST
20123: PUSH
20124: EMPTY
20125: LIST
20126: LIST
20127: PPUSH
20128: CALL_OW 72
20132: ST_TO_ADDR
20133: GO 20217
20135: LD_INT 4
20137: DOUBLE
20138: EQUAL
20139: IFTRUE 20143
20141: GO 20216
20143: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
20144: LD_ADDR_VAR 0 12
20148: PUSH
20149: LD_VAR 0 18
20153: PPUSH
20154: LD_INT 22
20156: PUSH
20157: LD_VAR 0 16
20161: PUSH
20162: EMPTY
20163: LIST
20164: LIST
20165: PUSH
20166: LD_INT 2
20168: PUSH
20169: LD_INT 30
20171: PUSH
20172: LD_INT 6
20174: PUSH
20175: EMPTY
20176: LIST
20177: LIST
20178: PUSH
20179: LD_INT 30
20181: PUSH
20182: LD_INT 7
20184: PUSH
20185: EMPTY
20186: LIST
20187: LIST
20188: PUSH
20189: LD_INT 30
20191: PUSH
20192: LD_INT 8
20194: PUSH
20195: EMPTY
20196: LIST
20197: LIST
20198: PUSH
20199: EMPTY
20200: LIST
20201: LIST
20202: LIST
20203: LIST
20204: PUSH
20205: EMPTY
20206: LIST
20207: LIST
20208: PPUSH
20209: CALL_OW 72
20213: ST_TO_ADDR
20214: GO 20217
20216: POP
// if i = 1 then
20217: LD_VAR 0 8
20221: PUSH
20222: LD_INT 1
20224: EQUAL
20225: IFFALSE 20336
// begin tmp := [ ] ;
20227: LD_ADDR_VAR 0 19
20231: PUSH
20232: EMPTY
20233: ST_TO_ADDR
// for j in f do
20234: LD_ADDR_VAR 0 9
20238: PUSH
20239: LD_VAR 0 12
20243: PUSH
20244: FOR_IN
20245: IFFALSE 20318
// if GetBType ( j ) = b_bunker then
20247: LD_VAR 0 9
20251: PPUSH
20252: CALL_OW 266
20256: PUSH
20257: LD_INT 32
20259: EQUAL
20260: IFFALSE 20287
// tmp := Insert ( tmp , 1 , j ) else
20262: LD_ADDR_VAR 0 19
20266: PUSH
20267: LD_VAR 0 19
20271: PPUSH
20272: LD_INT 1
20274: PPUSH
20275: LD_VAR 0 9
20279: PPUSH
20280: CALL_OW 2
20284: ST_TO_ADDR
20285: GO 20316
// tmp := Insert ( tmp , tmp + 1 , j ) ;
20287: LD_ADDR_VAR 0 19
20291: PUSH
20292: LD_VAR 0 19
20296: PPUSH
20297: LD_VAR 0 19
20301: PUSH
20302: LD_INT 1
20304: PLUS
20305: PPUSH
20306: LD_VAR 0 9
20310: PPUSH
20311: CALL_OW 2
20315: ST_TO_ADDR
20316: GO 20244
20318: POP
20319: POP
// if tmp then
20320: LD_VAR 0 19
20324: IFFALSE 20336
// f := tmp ;
20326: LD_ADDR_VAR 0 12
20330: PUSH
20331: LD_VAR 0 19
20335: ST_TO_ADDR
// end ; x := personel [ i ] ;
20336: LD_ADDR_VAR 0 13
20340: PUSH
20341: LD_VAR 0 6
20345: PUSH
20346: LD_VAR 0 8
20350: ARRAY
20351: ST_TO_ADDR
// if x = - 1 then
20352: LD_VAR 0 13
20356: PUSH
20357: LD_INT 1
20359: NEG
20360: EQUAL
20361: IFFALSE 20570
// begin for j in f do
20363: LD_ADDR_VAR 0 9
20367: PUSH
20368: LD_VAR 0 12
20372: PUSH
20373: FOR_IN
20374: IFFALSE 20566
// repeat InitHc ;
20376: CALL_OW 19
// if GetBType ( j ) = b_barracks then
20380: LD_VAR 0 9
20384: PPUSH
20385: CALL_OW 266
20389: PUSH
20390: LD_INT 5
20392: EQUAL
20393: IFFALSE 20463
// begin if UnitsInside ( j ) < 3 then
20395: LD_VAR 0 9
20399: PPUSH
20400: CALL_OW 313
20404: PUSH
20405: LD_INT 3
20407: LESS
20408: IFFALSE 20444
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
20410: LD_INT 0
20412: PPUSH
20413: LD_INT 5
20415: PUSH
20416: LD_INT 8
20418: PUSH
20419: LD_INT 9
20421: PUSH
20422: EMPTY
20423: LIST
20424: LIST
20425: LIST
20426: PUSH
20427: LD_VAR 0 17
20431: ARRAY
20432: PPUSH
20433: LD_VAR 0 4
20437: PPUSH
20438: CALL_OW 380
20442: GO 20461
// PrepareHuman ( false , i , skill ) ;
20444: LD_INT 0
20446: PPUSH
20447: LD_VAR 0 8
20451: PPUSH
20452: LD_VAR 0 4
20456: PPUSH
20457: CALL_OW 380
// end else
20461: GO 20480
// PrepareHuman ( false , i , skill ) ;
20463: LD_INT 0
20465: PPUSH
20466: LD_VAR 0 8
20470: PPUSH
20471: LD_VAR 0 4
20475: PPUSH
20476: CALL_OW 380
// un := CreateHuman ;
20480: LD_ADDR_VAR 0 14
20484: PUSH
20485: CALL_OW 44
20489: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20490: LD_ADDR_VAR 0 7
20494: PUSH
20495: LD_VAR 0 7
20499: PPUSH
20500: LD_INT 1
20502: PPUSH
20503: LD_VAR 0 14
20507: PPUSH
20508: CALL_OW 2
20512: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
20513: LD_VAR 0 14
20517: PPUSH
20518: LD_VAR 0 9
20522: PPUSH
20523: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
20527: LD_VAR 0 9
20531: PPUSH
20532: CALL_OW 313
20536: PUSH
20537: LD_INT 6
20539: EQUAL
20540: PUSH
20541: LD_VAR 0 9
20545: PPUSH
20546: CALL_OW 266
20550: PUSH
20551: LD_INT 32
20553: PUSH
20554: LD_INT 31
20556: PUSH
20557: EMPTY
20558: LIST
20559: LIST
20560: IN
20561: OR
20562: IFFALSE 20376
20564: GO 20373
20566: POP
20567: POP
// end else
20568: GO 20950
// for j = 1 to x do
20570: LD_ADDR_VAR 0 9
20574: PUSH
20575: DOUBLE
20576: LD_INT 1
20578: DEC
20579: ST_TO_ADDR
20580: LD_VAR 0 13
20584: PUSH
20585: FOR_TO
20586: IFFALSE 20948
// begin InitHc ;
20588: CALL_OW 19
// if not f then
20592: LD_VAR 0 12
20596: NOT
20597: IFFALSE 20686
// begin PrepareHuman ( false , i , skill ) ;
20599: LD_INT 0
20601: PPUSH
20602: LD_VAR 0 8
20606: PPUSH
20607: LD_VAR 0 4
20611: PPUSH
20612: CALL_OW 380
// un := CreateHuman ;
20616: LD_ADDR_VAR 0 14
20620: PUSH
20621: CALL_OW 44
20625: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20626: LD_ADDR_VAR 0 7
20630: PUSH
20631: LD_VAR 0 7
20635: PPUSH
20636: LD_INT 1
20638: PPUSH
20639: LD_VAR 0 14
20643: PPUSH
20644: CALL_OW 2
20648: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
20649: LD_VAR 0 14
20653: PPUSH
20654: LD_VAR 0 1
20658: PPUSH
20659: CALL_OW 250
20663: PPUSH
20664: LD_VAR 0 1
20668: PPUSH
20669: CALL_OW 251
20673: PPUSH
20674: LD_INT 10
20676: PPUSH
20677: LD_INT 0
20679: PPUSH
20680: CALL_OW 50
// continue ;
20684: GO 20585
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
20686: LD_VAR 0 12
20690: PUSH
20691: LD_INT 1
20693: ARRAY
20694: PPUSH
20695: CALL_OW 313
20699: PUSH
20700: LD_VAR 0 12
20704: PUSH
20705: LD_INT 1
20707: ARRAY
20708: PPUSH
20709: CALL_OW 266
20713: PUSH
20714: LD_INT 32
20716: PUSH
20717: LD_INT 31
20719: PUSH
20720: EMPTY
20721: LIST
20722: LIST
20723: IN
20724: AND
20725: PUSH
20726: LD_VAR 0 12
20730: PUSH
20731: LD_INT 1
20733: ARRAY
20734: PPUSH
20735: CALL_OW 313
20739: PUSH
20740: LD_INT 6
20742: EQUAL
20743: OR
20744: IFFALSE 20764
// f := Delete ( f , 1 ) ;
20746: LD_ADDR_VAR 0 12
20750: PUSH
20751: LD_VAR 0 12
20755: PPUSH
20756: LD_INT 1
20758: PPUSH
20759: CALL_OW 3
20763: ST_TO_ADDR
// if not f then
20764: LD_VAR 0 12
20768: NOT
20769: IFFALSE 20787
// begin x := x + 2 ;
20771: LD_ADDR_VAR 0 13
20775: PUSH
20776: LD_VAR 0 13
20780: PUSH
20781: LD_INT 2
20783: PLUS
20784: ST_TO_ADDR
// continue ;
20785: GO 20585
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
20787: LD_VAR 0 12
20791: PUSH
20792: LD_INT 1
20794: ARRAY
20795: PPUSH
20796: CALL_OW 266
20800: PUSH
20801: LD_INT 5
20803: EQUAL
20804: IFFALSE 20878
// begin if UnitsInside ( f [ 1 ] ) < 3 then
20806: LD_VAR 0 12
20810: PUSH
20811: LD_INT 1
20813: ARRAY
20814: PPUSH
20815: CALL_OW 313
20819: PUSH
20820: LD_INT 3
20822: LESS
20823: IFFALSE 20859
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
20825: LD_INT 0
20827: PPUSH
20828: LD_INT 5
20830: PUSH
20831: LD_INT 8
20833: PUSH
20834: LD_INT 9
20836: PUSH
20837: EMPTY
20838: LIST
20839: LIST
20840: LIST
20841: PUSH
20842: LD_VAR 0 17
20846: ARRAY
20847: PPUSH
20848: LD_VAR 0 4
20852: PPUSH
20853: CALL_OW 380
20857: GO 20876
// PrepareHuman ( false , i , skill ) ;
20859: LD_INT 0
20861: PPUSH
20862: LD_VAR 0 8
20866: PPUSH
20867: LD_VAR 0 4
20871: PPUSH
20872: CALL_OW 380
// end else
20876: GO 20895
// PrepareHuman ( false , i , skill ) ;
20878: LD_INT 0
20880: PPUSH
20881: LD_VAR 0 8
20885: PPUSH
20886: LD_VAR 0 4
20890: PPUSH
20891: CALL_OW 380
// un := CreateHuman ;
20895: LD_ADDR_VAR 0 14
20899: PUSH
20900: CALL_OW 44
20904: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20905: LD_ADDR_VAR 0 7
20909: PUSH
20910: LD_VAR 0 7
20914: PPUSH
20915: LD_INT 1
20917: PPUSH
20918: LD_VAR 0 14
20922: PPUSH
20923: CALL_OW 2
20927: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
20928: LD_VAR 0 14
20932: PPUSH
20933: LD_VAR 0 12
20937: PUSH
20938: LD_INT 1
20940: ARRAY
20941: PPUSH
20942: CALL_OW 52
// end ;
20946: GO 20585
20948: POP
20949: POP
// end ;
20950: GO 19887
20952: POP
20953: POP
// result := result ^ buildings ;
20954: LD_ADDR_VAR 0 7
20958: PUSH
20959: LD_VAR 0 7
20963: PUSH
20964: LD_VAR 0 18
20968: ADD
20969: ST_TO_ADDR
// end else
20970: GO 21113
// begin for i = 1 to personel do
20972: LD_ADDR_VAR 0 8
20976: PUSH
20977: DOUBLE
20978: LD_INT 1
20980: DEC
20981: ST_TO_ADDR
20982: LD_VAR 0 6
20986: PUSH
20987: FOR_TO
20988: IFFALSE 21111
// begin if i > 4 then
20990: LD_VAR 0 8
20994: PUSH
20995: LD_INT 4
20997: GREATER
20998: IFFALSE 21002
// break ;
21000: GO 21111
// x := personel [ i ] ;
21002: LD_ADDR_VAR 0 13
21006: PUSH
21007: LD_VAR 0 6
21011: PUSH
21012: LD_VAR 0 8
21016: ARRAY
21017: ST_TO_ADDR
// if x = - 1 then
21018: LD_VAR 0 13
21022: PUSH
21023: LD_INT 1
21025: NEG
21026: EQUAL
21027: IFFALSE 21031
// continue ;
21029: GO 20987
// PrepareHuman ( false , i , skill ) ;
21031: LD_INT 0
21033: PPUSH
21034: LD_VAR 0 8
21038: PPUSH
21039: LD_VAR 0 4
21043: PPUSH
21044: CALL_OW 380
// un := CreateHuman ;
21048: LD_ADDR_VAR 0 14
21052: PUSH
21053: CALL_OW 44
21057: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
21058: LD_VAR 0 14
21062: PPUSH
21063: LD_VAR 0 1
21067: PPUSH
21068: CALL_OW 250
21072: PPUSH
21073: LD_VAR 0 1
21077: PPUSH
21078: CALL_OW 251
21082: PPUSH
21083: LD_INT 10
21085: PPUSH
21086: LD_INT 0
21088: PPUSH
21089: CALL_OW 50
// result := result ^ un ;
21093: LD_ADDR_VAR 0 7
21097: PUSH
21098: LD_VAR 0 7
21102: PUSH
21103: LD_VAR 0 14
21107: ADD
21108: ST_TO_ADDR
// end ;
21109: GO 20987
21111: POP
21112: POP
// end ; end ;
21113: LD_VAR 0 7
21117: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
21118: LD_INT 0
21120: PPUSH
21121: PPUSH
21122: PPUSH
21123: PPUSH
21124: PPUSH
21125: PPUSH
21126: PPUSH
21127: PPUSH
21128: PPUSH
21129: PPUSH
21130: PPUSH
21131: PPUSH
21132: PPUSH
21133: PPUSH
21134: PPUSH
21135: PPUSH
// result := false ;
21136: LD_ADDR_VAR 0 3
21140: PUSH
21141: LD_INT 0
21143: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
21144: LD_VAR 0 1
21148: NOT
21149: PUSH
21150: LD_VAR 0 1
21154: PPUSH
21155: CALL_OW 266
21159: PUSH
21160: LD_INT 32
21162: PUSH
21163: LD_INT 33
21165: PUSH
21166: EMPTY
21167: LIST
21168: LIST
21169: IN
21170: NOT
21171: OR
21172: IFFALSE 21176
// exit ;
21174: GO 22285
// nat := GetNation ( tower ) ;
21176: LD_ADDR_VAR 0 12
21180: PUSH
21181: LD_VAR 0 1
21185: PPUSH
21186: CALL_OW 248
21190: ST_TO_ADDR
// side := GetSide ( tower ) ;
21191: LD_ADDR_VAR 0 16
21195: PUSH
21196: LD_VAR 0 1
21200: PPUSH
21201: CALL_OW 255
21205: ST_TO_ADDR
// x := GetX ( tower ) ;
21206: LD_ADDR_VAR 0 10
21210: PUSH
21211: LD_VAR 0 1
21215: PPUSH
21216: CALL_OW 250
21220: ST_TO_ADDR
// y := GetY ( tower ) ;
21221: LD_ADDR_VAR 0 11
21225: PUSH
21226: LD_VAR 0 1
21230: PPUSH
21231: CALL_OW 251
21235: ST_TO_ADDR
// if not x or not y then
21236: LD_VAR 0 10
21240: NOT
21241: PUSH
21242: LD_VAR 0 11
21246: NOT
21247: OR
21248: IFFALSE 21252
// exit ;
21250: GO 22285
// weapon := 0 ;
21252: LD_ADDR_VAR 0 18
21256: PUSH
21257: LD_INT 0
21259: ST_TO_ADDR
// fac_list := [ ] ;
21260: LD_ADDR_VAR 0 17
21264: PUSH
21265: EMPTY
21266: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
21267: LD_ADDR_VAR 0 6
21271: PUSH
21272: LD_VAR 0 1
21276: PPUSH
21277: CALL_OW 274
21281: PPUSH
21282: LD_VAR 0 2
21286: PPUSH
21287: LD_INT 0
21289: PPUSH
21290: CALL 18856 0 3
21294: PPUSH
21295: LD_INT 30
21297: PUSH
21298: LD_INT 3
21300: PUSH
21301: EMPTY
21302: LIST
21303: LIST
21304: PPUSH
21305: CALL_OW 72
21309: ST_TO_ADDR
// if not factories then
21310: LD_VAR 0 6
21314: NOT
21315: IFFALSE 21319
// exit ;
21317: GO 22285
// for i in factories do
21319: LD_ADDR_VAR 0 8
21323: PUSH
21324: LD_VAR 0 6
21328: PUSH
21329: FOR_IN
21330: IFFALSE 21355
// fac_list := fac_list union AvailableWeaponList ( i ) ;
21332: LD_ADDR_VAR 0 17
21336: PUSH
21337: LD_VAR 0 17
21341: PUSH
21342: LD_VAR 0 8
21346: PPUSH
21347: CALL_OW 478
21351: UNION
21352: ST_TO_ADDR
21353: GO 21329
21355: POP
21356: POP
// if not fac_list then
21357: LD_VAR 0 17
21361: NOT
21362: IFFALSE 21366
// exit ;
21364: GO 22285
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
21366: LD_ADDR_VAR 0 5
21370: PUSH
21371: LD_INT 4
21373: PUSH
21374: LD_INT 5
21376: PUSH
21377: LD_INT 9
21379: PUSH
21380: LD_INT 10
21382: PUSH
21383: LD_INT 6
21385: PUSH
21386: LD_INT 7
21388: PUSH
21389: LD_INT 11
21391: PUSH
21392: EMPTY
21393: LIST
21394: LIST
21395: LIST
21396: LIST
21397: LIST
21398: LIST
21399: LIST
21400: PUSH
21401: LD_INT 27
21403: PUSH
21404: LD_INT 28
21406: PUSH
21407: LD_INT 26
21409: PUSH
21410: LD_INT 30
21412: PUSH
21413: EMPTY
21414: LIST
21415: LIST
21416: LIST
21417: LIST
21418: PUSH
21419: LD_INT 43
21421: PUSH
21422: LD_INT 44
21424: PUSH
21425: LD_INT 46
21427: PUSH
21428: LD_INT 45
21430: PUSH
21431: LD_INT 47
21433: PUSH
21434: LD_INT 49
21436: PUSH
21437: EMPTY
21438: LIST
21439: LIST
21440: LIST
21441: LIST
21442: LIST
21443: LIST
21444: PUSH
21445: EMPTY
21446: LIST
21447: LIST
21448: LIST
21449: PUSH
21450: LD_VAR 0 12
21454: ARRAY
21455: ST_TO_ADDR
// list := list isect fac_list ;
21456: LD_ADDR_VAR 0 5
21460: PUSH
21461: LD_VAR 0 5
21465: PUSH
21466: LD_VAR 0 17
21470: ISECT
21471: ST_TO_ADDR
// if not list then
21472: LD_VAR 0 5
21476: NOT
21477: IFFALSE 21481
// exit ;
21479: GO 22285
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
21481: LD_VAR 0 12
21485: PUSH
21486: LD_INT 3
21488: EQUAL
21489: PUSH
21490: LD_INT 49
21492: PUSH
21493: LD_VAR 0 5
21497: IN
21498: AND
21499: PUSH
21500: LD_INT 31
21502: PPUSH
21503: LD_VAR 0 16
21507: PPUSH
21508: CALL_OW 321
21512: PUSH
21513: LD_INT 2
21515: EQUAL
21516: AND
21517: IFFALSE 21577
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
21519: LD_INT 22
21521: PUSH
21522: LD_VAR 0 16
21526: PUSH
21527: EMPTY
21528: LIST
21529: LIST
21530: PUSH
21531: LD_INT 35
21533: PUSH
21534: LD_INT 49
21536: PUSH
21537: EMPTY
21538: LIST
21539: LIST
21540: PUSH
21541: LD_INT 91
21543: PUSH
21544: LD_VAR 0 1
21548: PUSH
21549: LD_INT 10
21551: PUSH
21552: EMPTY
21553: LIST
21554: LIST
21555: LIST
21556: PUSH
21557: EMPTY
21558: LIST
21559: LIST
21560: LIST
21561: PPUSH
21562: CALL_OW 69
21566: NOT
21567: IFFALSE 21577
// weapon := ru_time_lapser ;
21569: LD_ADDR_VAR 0 18
21573: PUSH
21574: LD_INT 49
21576: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
21577: LD_VAR 0 12
21581: PUSH
21582: LD_INT 1
21584: PUSH
21585: LD_INT 2
21587: PUSH
21588: EMPTY
21589: LIST
21590: LIST
21591: IN
21592: PUSH
21593: LD_INT 11
21595: PUSH
21596: LD_VAR 0 5
21600: IN
21601: PUSH
21602: LD_INT 30
21604: PUSH
21605: LD_VAR 0 5
21609: IN
21610: OR
21611: AND
21612: PUSH
21613: LD_INT 6
21615: PPUSH
21616: LD_VAR 0 16
21620: PPUSH
21621: CALL_OW 321
21625: PUSH
21626: LD_INT 2
21628: EQUAL
21629: AND
21630: IFFALSE 21795
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
21632: LD_INT 22
21634: PUSH
21635: LD_VAR 0 16
21639: PUSH
21640: EMPTY
21641: LIST
21642: LIST
21643: PUSH
21644: LD_INT 2
21646: PUSH
21647: LD_INT 35
21649: PUSH
21650: LD_INT 11
21652: PUSH
21653: EMPTY
21654: LIST
21655: LIST
21656: PUSH
21657: LD_INT 35
21659: PUSH
21660: LD_INT 30
21662: PUSH
21663: EMPTY
21664: LIST
21665: LIST
21666: PUSH
21667: EMPTY
21668: LIST
21669: LIST
21670: LIST
21671: PUSH
21672: LD_INT 91
21674: PUSH
21675: LD_VAR 0 1
21679: PUSH
21680: LD_INT 18
21682: PUSH
21683: EMPTY
21684: LIST
21685: LIST
21686: LIST
21687: PUSH
21688: EMPTY
21689: LIST
21690: LIST
21691: LIST
21692: PPUSH
21693: CALL_OW 69
21697: NOT
21698: PUSH
21699: LD_INT 22
21701: PUSH
21702: LD_VAR 0 16
21706: PUSH
21707: EMPTY
21708: LIST
21709: LIST
21710: PUSH
21711: LD_INT 2
21713: PUSH
21714: LD_INT 30
21716: PUSH
21717: LD_INT 32
21719: PUSH
21720: EMPTY
21721: LIST
21722: LIST
21723: PUSH
21724: LD_INT 30
21726: PUSH
21727: LD_INT 33
21729: PUSH
21730: EMPTY
21731: LIST
21732: LIST
21733: PUSH
21734: EMPTY
21735: LIST
21736: LIST
21737: LIST
21738: PUSH
21739: LD_INT 91
21741: PUSH
21742: LD_VAR 0 1
21746: PUSH
21747: LD_INT 12
21749: PUSH
21750: EMPTY
21751: LIST
21752: LIST
21753: LIST
21754: PUSH
21755: EMPTY
21756: LIST
21757: LIST
21758: LIST
21759: PUSH
21760: EMPTY
21761: LIST
21762: PPUSH
21763: CALL_OW 69
21767: PUSH
21768: LD_INT 2
21770: GREATER
21771: AND
21772: IFFALSE 21795
// weapon := [ us_radar , ar_radar ] [ nat ] ;
21774: LD_ADDR_VAR 0 18
21778: PUSH
21779: LD_INT 11
21781: PUSH
21782: LD_INT 30
21784: PUSH
21785: EMPTY
21786: LIST
21787: LIST
21788: PUSH
21789: LD_VAR 0 12
21793: ARRAY
21794: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
21795: LD_VAR 0 18
21799: NOT
21800: PUSH
21801: LD_INT 40
21803: PPUSH
21804: LD_VAR 0 16
21808: PPUSH
21809: CALL_OW 321
21813: PUSH
21814: LD_INT 2
21816: EQUAL
21817: AND
21818: PUSH
21819: LD_INT 7
21821: PUSH
21822: LD_VAR 0 5
21826: IN
21827: PUSH
21828: LD_INT 28
21830: PUSH
21831: LD_VAR 0 5
21835: IN
21836: OR
21837: PUSH
21838: LD_INT 45
21840: PUSH
21841: LD_VAR 0 5
21845: IN
21846: OR
21847: AND
21848: IFFALSE 22102
// begin hex := GetHexInfo ( x , y ) ;
21850: LD_ADDR_VAR 0 4
21854: PUSH
21855: LD_VAR 0 10
21859: PPUSH
21860: LD_VAR 0 11
21864: PPUSH
21865: CALL_OW 546
21869: ST_TO_ADDR
// if hex [ 1 ] then
21870: LD_VAR 0 4
21874: PUSH
21875: LD_INT 1
21877: ARRAY
21878: IFFALSE 21882
// exit ;
21880: GO 22285
// height := hex [ 2 ] ;
21882: LD_ADDR_VAR 0 15
21886: PUSH
21887: LD_VAR 0 4
21891: PUSH
21892: LD_INT 2
21894: ARRAY
21895: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
21896: LD_ADDR_VAR 0 14
21900: PUSH
21901: LD_INT 0
21903: PUSH
21904: LD_INT 2
21906: PUSH
21907: LD_INT 3
21909: PUSH
21910: LD_INT 5
21912: PUSH
21913: EMPTY
21914: LIST
21915: LIST
21916: LIST
21917: LIST
21918: ST_TO_ADDR
// for i in tmp do
21919: LD_ADDR_VAR 0 8
21923: PUSH
21924: LD_VAR 0 14
21928: PUSH
21929: FOR_IN
21930: IFFALSE 22100
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
21932: LD_ADDR_VAR 0 9
21936: PUSH
21937: LD_VAR 0 10
21941: PPUSH
21942: LD_VAR 0 8
21946: PPUSH
21947: LD_INT 5
21949: PPUSH
21950: CALL_OW 272
21954: PUSH
21955: LD_VAR 0 11
21959: PPUSH
21960: LD_VAR 0 8
21964: PPUSH
21965: LD_INT 5
21967: PPUSH
21968: CALL_OW 273
21972: PUSH
21973: EMPTY
21974: LIST
21975: LIST
21976: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
21977: LD_VAR 0 9
21981: PUSH
21982: LD_INT 1
21984: ARRAY
21985: PPUSH
21986: LD_VAR 0 9
21990: PUSH
21991: LD_INT 2
21993: ARRAY
21994: PPUSH
21995: CALL_OW 488
21999: IFFALSE 22098
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
22001: LD_ADDR_VAR 0 4
22005: PUSH
22006: LD_VAR 0 9
22010: PUSH
22011: LD_INT 1
22013: ARRAY
22014: PPUSH
22015: LD_VAR 0 9
22019: PUSH
22020: LD_INT 2
22022: ARRAY
22023: PPUSH
22024: CALL_OW 546
22028: ST_TO_ADDR
// if hex [ 1 ] then
22029: LD_VAR 0 4
22033: PUSH
22034: LD_INT 1
22036: ARRAY
22037: IFFALSE 22041
// continue ;
22039: GO 21929
// h := hex [ 2 ] ;
22041: LD_ADDR_VAR 0 13
22045: PUSH
22046: LD_VAR 0 4
22050: PUSH
22051: LD_INT 2
22053: ARRAY
22054: ST_TO_ADDR
// if h + 7 < height then
22055: LD_VAR 0 13
22059: PUSH
22060: LD_INT 7
22062: PLUS
22063: PUSH
22064: LD_VAR 0 15
22068: LESS
22069: IFFALSE 22098
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
22071: LD_ADDR_VAR 0 18
22075: PUSH
22076: LD_INT 7
22078: PUSH
22079: LD_INT 28
22081: PUSH
22082: LD_INT 45
22084: PUSH
22085: EMPTY
22086: LIST
22087: LIST
22088: LIST
22089: PUSH
22090: LD_VAR 0 12
22094: ARRAY
22095: ST_TO_ADDR
// break ;
22096: GO 22100
// end ; end ; end ;
22098: GO 21929
22100: POP
22101: POP
// end ; if not weapon then
22102: LD_VAR 0 18
22106: NOT
22107: IFFALSE 22167
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
22109: LD_ADDR_VAR 0 5
22113: PUSH
22114: LD_VAR 0 5
22118: PUSH
22119: LD_INT 11
22121: PUSH
22122: LD_INT 30
22124: PUSH
22125: LD_INT 49
22127: PUSH
22128: EMPTY
22129: LIST
22130: LIST
22131: LIST
22132: DIFF
22133: ST_TO_ADDR
// if not list then
22134: LD_VAR 0 5
22138: NOT
22139: IFFALSE 22143
// exit ;
22141: GO 22285
// weapon := list [ rand ( 1 , list ) ] ;
22143: LD_ADDR_VAR 0 18
22147: PUSH
22148: LD_VAR 0 5
22152: PUSH
22153: LD_INT 1
22155: PPUSH
22156: LD_VAR 0 5
22160: PPUSH
22161: CALL_OW 12
22165: ARRAY
22166: ST_TO_ADDR
// end ; if weapon then
22167: LD_VAR 0 18
22171: IFFALSE 22285
// begin tmp := CostOfWeapon ( weapon ) ;
22173: LD_ADDR_VAR 0 14
22177: PUSH
22178: LD_VAR 0 18
22182: PPUSH
22183: CALL_OW 451
22187: ST_TO_ADDR
// j := GetBase ( tower ) ;
22188: LD_ADDR_VAR 0 9
22192: PUSH
22193: LD_VAR 0 1
22197: PPUSH
22198: CALL_OW 274
22202: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
22203: LD_VAR 0 9
22207: PPUSH
22208: LD_INT 1
22210: PPUSH
22211: CALL_OW 275
22215: PUSH
22216: LD_VAR 0 14
22220: PUSH
22221: LD_INT 1
22223: ARRAY
22224: GREATEREQUAL
22225: PUSH
22226: LD_VAR 0 9
22230: PPUSH
22231: LD_INT 2
22233: PPUSH
22234: CALL_OW 275
22238: PUSH
22239: LD_VAR 0 14
22243: PUSH
22244: LD_INT 2
22246: ARRAY
22247: GREATEREQUAL
22248: AND
22249: PUSH
22250: LD_VAR 0 9
22254: PPUSH
22255: LD_INT 3
22257: PPUSH
22258: CALL_OW 275
22262: PUSH
22263: LD_VAR 0 14
22267: PUSH
22268: LD_INT 3
22270: ARRAY
22271: GREATEREQUAL
22272: AND
22273: IFFALSE 22285
// result := weapon ;
22275: LD_ADDR_VAR 0 3
22279: PUSH
22280: LD_VAR 0 18
22284: ST_TO_ADDR
// end ; end ;
22285: LD_VAR 0 3
22289: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
22290: LD_INT 0
22292: PPUSH
22293: PPUSH
// result := true ;
22294: LD_ADDR_VAR 0 3
22298: PUSH
22299: LD_INT 1
22301: ST_TO_ADDR
// if array1 = array2 then
22302: LD_VAR 0 1
22306: PUSH
22307: LD_VAR 0 2
22311: EQUAL
22312: IFFALSE 22372
// begin for i = 1 to array1 do
22314: LD_ADDR_VAR 0 4
22318: PUSH
22319: DOUBLE
22320: LD_INT 1
22322: DEC
22323: ST_TO_ADDR
22324: LD_VAR 0 1
22328: PUSH
22329: FOR_TO
22330: IFFALSE 22368
// if array1 [ i ] <> array2 [ i ] then
22332: LD_VAR 0 1
22336: PUSH
22337: LD_VAR 0 4
22341: ARRAY
22342: PUSH
22343: LD_VAR 0 2
22347: PUSH
22348: LD_VAR 0 4
22352: ARRAY
22353: NONEQUAL
22354: IFFALSE 22366
// begin result := false ;
22356: LD_ADDR_VAR 0 3
22360: PUSH
22361: LD_INT 0
22363: ST_TO_ADDR
// break ;
22364: GO 22368
// end ;
22366: GO 22329
22368: POP
22369: POP
// end else
22370: GO 22380
// result := false ;
22372: LD_ADDR_VAR 0 3
22376: PUSH
22377: LD_INT 0
22379: ST_TO_ADDR
// end ;
22380: LD_VAR 0 3
22384: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
22385: LD_INT 0
22387: PPUSH
22388: PPUSH
// if not array1 or not array2 then
22389: LD_VAR 0 1
22393: NOT
22394: PUSH
22395: LD_VAR 0 2
22399: NOT
22400: OR
22401: IFFALSE 22405
// exit ;
22403: GO 22469
// result := true ;
22405: LD_ADDR_VAR 0 3
22409: PUSH
22410: LD_INT 1
22412: ST_TO_ADDR
// for i = 1 to array1 do
22413: LD_ADDR_VAR 0 4
22417: PUSH
22418: DOUBLE
22419: LD_INT 1
22421: DEC
22422: ST_TO_ADDR
22423: LD_VAR 0 1
22427: PUSH
22428: FOR_TO
22429: IFFALSE 22467
// if array1 [ i ] <> array2 [ i ] then
22431: LD_VAR 0 1
22435: PUSH
22436: LD_VAR 0 4
22440: ARRAY
22441: PUSH
22442: LD_VAR 0 2
22446: PUSH
22447: LD_VAR 0 4
22451: ARRAY
22452: NONEQUAL
22453: IFFALSE 22465
// begin result := false ;
22455: LD_ADDR_VAR 0 3
22459: PUSH
22460: LD_INT 0
22462: ST_TO_ADDR
// break ;
22463: GO 22467
// end ;
22465: GO 22428
22467: POP
22468: POP
// end ;
22469: LD_VAR 0 3
22473: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
22474: LD_INT 0
22476: PPUSH
22477: PPUSH
22478: PPUSH
// pom := GetBase ( fac ) ;
22479: LD_ADDR_VAR 0 5
22483: PUSH
22484: LD_VAR 0 1
22488: PPUSH
22489: CALL_OW 274
22493: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
22494: LD_ADDR_VAR 0 4
22498: PUSH
22499: LD_VAR 0 2
22503: PUSH
22504: LD_INT 1
22506: ARRAY
22507: PPUSH
22508: LD_VAR 0 2
22512: PUSH
22513: LD_INT 2
22515: ARRAY
22516: PPUSH
22517: LD_VAR 0 2
22521: PUSH
22522: LD_INT 3
22524: ARRAY
22525: PPUSH
22526: LD_VAR 0 2
22530: PUSH
22531: LD_INT 4
22533: ARRAY
22534: PPUSH
22535: CALL_OW 449
22539: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22540: LD_ADDR_VAR 0 3
22544: PUSH
22545: LD_VAR 0 5
22549: PPUSH
22550: LD_INT 1
22552: PPUSH
22553: CALL_OW 275
22557: PUSH
22558: LD_VAR 0 4
22562: PUSH
22563: LD_INT 1
22565: ARRAY
22566: GREATEREQUAL
22567: PUSH
22568: LD_VAR 0 5
22572: PPUSH
22573: LD_INT 2
22575: PPUSH
22576: CALL_OW 275
22580: PUSH
22581: LD_VAR 0 4
22585: PUSH
22586: LD_INT 2
22588: ARRAY
22589: GREATEREQUAL
22590: AND
22591: PUSH
22592: LD_VAR 0 5
22596: PPUSH
22597: LD_INT 3
22599: PPUSH
22600: CALL_OW 275
22604: PUSH
22605: LD_VAR 0 4
22609: PUSH
22610: LD_INT 3
22612: ARRAY
22613: GREATEREQUAL
22614: AND
22615: ST_TO_ADDR
// end ;
22616: LD_VAR 0 3
22620: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
22621: LD_INT 0
22623: PPUSH
22624: PPUSH
22625: PPUSH
22626: PPUSH
// pom := GetBase ( building ) ;
22627: LD_ADDR_VAR 0 3
22631: PUSH
22632: LD_VAR 0 1
22636: PPUSH
22637: CALL_OW 274
22641: ST_TO_ADDR
// if not pom then
22642: LD_VAR 0 3
22646: NOT
22647: IFFALSE 22651
// exit ;
22649: GO 22821
// btype := GetBType ( building ) ;
22651: LD_ADDR_VAR 0 5
22655: PUSH
22656: LD_VAR 0 1
22660: PPUSH
22661: CALL_OW 266
22665: ST_TO_ADDR
// if btype = b_armoury then
22666: LD_VAR 0 5
22670: PUSH
22671: LD_INT 4
22673: EQUAL
22674: IFFALSE 22684
// btype := b_barracks ;
22676: LD_ADDR_VAR 0 5
22680: PUSH
22681: LD_INT 5
22683: ST_TO_ADDR
// if btype = b_depot then
22684: LD_VAR 0 5
22688: PUSH
22689: LD_INT 0
22691: EQUAL
22692: IFFALSE 22702
// btype := b_warehouse ;
22694: LD_ADDR_VAR 0 5
22698: PUSH
22699: LD_INT 1
22701: ST_TO_ADDR
// if btype = b_workshop then
22702: LD_VAR 0 5
22706: PUSH
22707: LD_INT 2
22709: EQUAL
22710: IFFALSE 22720
// btype := b_factory ;
22712: LD_ADDR_VAR 0 5
22716: PUSH
22717: LD_INT 3
22719: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
22720: LD_ADDR_VAR 0 4
22724: PUSH
22725: LD_VAR 0 5
22729: PPUSH
22730: LD_VAR 0 1
22734: PPUSH
22735: CALL_OW 248
22739: PPUSH
22740: CALL_OW 450
22744: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22745: LD_ADDR_VAR 0 2
22749: PUSH
22750: LD_VAR 0 3
22754: PPUSH
22755: LD_INT 1
22757: PPUSH
22758: CALL_OW 275
22762: PUSH
22763: LD_VAR 0 4
22767: PUSH
22768: LD_INT 1
22770: ARRAY
22771: GREATEREQUAL
22772: PUSH
22773: LD_VAR 0 3
22777: PPUSH
22778: LD_INT 2
22780: PPUSH
22781: CALL_OW 275
22785: PUSH
22786: LD_VAR 0 4
22790: PUSH
22791: LD_INT 2
22793: ARRAY
22794: GREATEREQUAL
22795: AND
22796: PUSH
22797: LD_VAR 0 3
22801: PPUSH
22802: LD_INT 3
22804: PPUSH
22805: CALL_OW 275
22809: PUSH
22810: LD_VAR 0 4
22814: PUSH
22815: LD_INT 3
22817: ARRAY
22818: GREATEREQUAL
22819: AND
22820: ST_TO_ADDR
// end ;
22821: LD_VAR 0 2
22825: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
22826: LD_INT 0
22828: PPUSH
22829: PPUSH
22830: PPUSH
// pom := GetBase ( building ) ;
22831: LD_ADDR_VAR 0 4
22835: PUSH
22836: LD_VAR 0 1
22840: PPUSH
22841: CALL_OW 274
22845: ST_TO_ADDR
// if not pom then
22846: LD_VAR 0 4
22850: NOT
22851: IFFALSE 22855
// exit ;
22853: GO 22956
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
22855: LD_ADDR_VAR 0 5
22859: PUSH
22860: LD_VAR 0 2
22864: PPUSH
22865: LD_VAR 0 1
22869: PPUSH
22870: CALL_OW 248
22874: PPUSH
22875: CALL_OW 450
22879: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22880: LD_ADDR_VAR 0 3
22884: PUSH
22885: LD_VAR 0 4
22889: PPUSH
22890: LD_INT 1
22892: PPUSH
22893: CALL_OW 275
22897: PUSH
22898: LD_VAR 0 5
22902: PUSH
22903: LD_INT 1
22905: ARRAY
22906: GREATEREQUAL
22907: PUSH
22908: LD_VAR 0 4
22912: PPUSH
22913: LD_INT 2
22915: PPUSH
22916: CALL_OW 275
22920: PUSH
22921: LD_VAR 0 5
22925: PUSH
22926: LD_INT 2
22928: ARRAY
22929: GREATEREQUAL
22930: AND
22931: PUSH
22932: LD_VAR 0 4
22936: PPUSH
22937: LD_INT 3
22939: PPUSH
22940: CALL_OW 275
22944: PUSH
22945: LD_VAR 0 5
22949: PUSH
22950: LD_INT 3
22952: ARRAY
22953: GREATEREQUAL
22954: AND
22955: ST_TO_ADDR
// end ;
22956: LD_VAR 0 3
22960: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
22961: LD_INT 0
22963: PPUSH
22964: PPUSH
22965: PPUSH
22966: PPUSH
22967: PPUSH
22968: PPUSH
22969: PPUSH
22970: PPUSH
22971: PPUSH
22972: PPUSH
22973: PPUSH
// result := false ;
22974: LD_ADDR_VAR 0 8
22978: PUSH
22979: LD_INT 0
22981: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
22982: LD_VAR 0 5
22986: NOT
22987: PUSH
22988: LD_VAR 0 1
22992: NOT
22993: OR
22994: PUSH
22995: LD_VAR 0 2
22999: NOT
23000: OR
23001: PUSH
23002: LD_VAR 0 3
23006: NOT
23007: OR
23008: IFFALSE 23012
// exit ;
23010: GO 23826
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
23012: LD_ADDR_VAR 0 14
23016: PUSH
23017: LD_VAR 0 1
23021: PPUSH
23022: LD_VAR 0 2
23026: PPUSH
23027: LD_VAR 0 3
23031: PPUSH
23032: LD_VAR 0 4
23036: PPUSH
23037: LD_VAR 0 5
23041: PUSH
23042: LD_INT 1
23044: ARRAY
23045: PPUSH
23046: CALL_OW 248
23050: PPUSH
23051: LD_INT 0
23053: PPUSH
23054: CALL 25059 0 6
23058: ST_TO_ADDR
// if not hexes then
23059: LD_VAR 0 14
23063: NOT
23064: IFFALSE 23068
// exit ;
23066: GO 23826
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
23068: LD_ADDR_VAR 0 17
23072: PUSH
23073: LD_VAR 0 5
23077: PPUSH
23078: LD_INT 22
23080: PUSH
23081: LD_VAR 0 13
23085: PPUSH
23086: CALL_OW 255
23090: PUSH
23091: EMPTY
23092: LIST
23093: LIST
23094: PUSH
23095: LD_INT 2
23097: PUSH
23098: LD_INT 30
23100: PUSH
23101: LD_INT 0
23103: PUSH
23104: EMPTY
23105: LIST
23106: LIST
23107: PUSH
23108: LD_INT 30
23110: PUSH
23111: LD_INT 1
23113: PUSH
23114: EMPTY
23115: LIST
23116: LIST
23117: PUSH
23118: EMPTY
23119: LIST
23120: LIST
23121: LIST
23122: PUSH
23123: EMPTY
23124: LIST
23125: LIST
23126: PPUSH
23127: CALL_OW 72
23131: ST_TO_ADDR
// for i = 1 to hexes do
23132: LD_ADDR_VAR 0 9
23136: PUSH
23137: DOUBLE
23138: LD_INT 1
23140: DEC
23141: ST_TO_ADDR
23142: LD_VAR 0 14
23146: PUSH
23147: FOR_TO
23148: IFFALSE 23824
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
23150: LD_ADDR_VAR 0 13
23154: PUSH
23155: LD_VAR 0 14
23159: PUSH
23160: LD_VAR 0 9
23164: ARRAY
23165: PUSH
23166: LD_INT 1
23168: ARRAY
23169: PPUSH
23170: LD_VAR 0 14
23174: PUSH
23175: LD_VAR 0 9
23179: ARRAY
23180: PUSH
23181: LD_INT 2
23183: ARRAY
23184: PPUSH
23185: CALL_OW 428
23189: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
23190: LD_VAR 0 14
23194: PUSH
23195: LD_VAR 0 9
23199: ARRAY
23200: PUSH
23201: LD_INT 1
23203: ARRAY
23204: PPUSH
23205: LD_VAR 0 14
23209: PUSH
23210: LD_VAR 0 9
23214: ARRAY
23215: PUSH
23216: LD_INT 2
23218: ARRAY
23219: PPUSH
23220: CALL_OW 351
23224: PUSH
23225: LD_VAR 0 14
23229: PUSH
23230: LD_VAR 0 9
23234: ARRAY
23235: PUSH
23236: LD_INT 1
23238: ARRAY
23239: PPUSH
23240: LD_VAR 0 14
23244: PUSH
23245: LD_VAR 0 9
23249: ARRAY
23250: PUSH
23251: LD_INT 2
23253: ARRAY
23254: PPUSH
23255: CALL_OW 488
23259: NOT
23260: OR
23261: PUSH
23262: LD_VAR 0 13
23266: PPUSH
23267: CALL_OW 247
23271: PUSH
23272: LD_INT 3
23274: EQUAL
23275: OR
23276: IFFALSE 23282
// exit ;
23278: POP
23279: POP
23280: GO 23826
// if not tmp then
23282: LD_VAR 0 13
23286: NOT
23287: IFFALSE 23291
// continue ;
23289: GO 23147
// result := true ;
23291: LD_ADDR_VAR 0 8
23295: PUSH
23296: LD_INT 1
23298: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
23299: LD_VAR 0 6
23303: PUSH
23304: LD_VAR 0 13
23308: PPUSH
23309: CALL_OW 247
23313: PUSH
23314: LD_INT 2
23316: EQUAL
23317: AND
23318: PUSH
23319: LD_VAR 0 13
23323: PPUSH
23324: CALL_OW 263
23328: PUSH
23329: LD_INT 1
23331: EQUAL
23332: AND
23333: IFFALSE 23497
// begin if IsDrivenBy ( tmp ) then
23335: LD_VAR 0 13
23339: PPUSH
23340: CALL_OW 311
23344: IFFALSE 23348
// continue ;
23346: GO 23147
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
23348: LD_VAR 0 6
23352: PPUSH
23353: LD_INT 3
23355: PUSH
23356: LD_INT 60
23358: PUSH
23359: EMPTY
23360: LIST
23361: PUSH
23362: EMPTY
23363: LIST
23364: LIST
23365: PUSH
23366: LD_INT 3
23368: PUSH
23369: LD_INT 55
23371: PUSH
23372: EMPTY
23373: LIST
23374: PUSH
23375: EMPTY
23376: LIST
23377: LIST
23378: PUSH
23379: EMPTY
23380: LIST
23381: LIST
23382: PPUSH
23383: CALL_OW 72
23387: IFFALSE 23495
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
23389: LD_ADDR_VAR 0 18
23393: PUSH
23394: LD_VAR 0 6
23398: PPUSH
23399: LD_INT 3
23401: PUSH
23402: LD_INT 60
23404: PUSH
23405: EMPTY
23406: LIST
23407: PUSH
23408: EMPTY
23409: LIST
23410: LIST
23411: PUSH
23412: LD_INT 3
23414: PUSH
23415: LD_INT 55
23417: PUSH
23418: EMPTY
23419: LIST
23420: PUSH
23421: EMPTY
23422: LIST
23423: LIST
23424: PUSH
23425: EMPTY
23426: LIST
23427: LIST
23428: PPUSH
23429: CALL_OW 72
23433: PUSH
23434: LD_INT 1
23436: ARRAY
23437: ST_TO_ADDR
// if IsInUnit ( driver ) then
23438: LD_VAR 0 18
23442: PPUSH
23443: CALL_OW 310
23447: IFFALSE 23458
// ComExit ( driver ) ;
23449: LD_VAR 0 18
23453: PPUSH
23454: CALL 48811 0 1
// AddComEnterUnit ( driver , tmp ) ;
23458: LD_VAR 0 18
23462: PPUSH
23463: LD_VAR 0 13
23467: PPUSH
23468: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
23472: LD_VAR 0 18
23476: PPUSH
23477: LD_VAR 0 7
23481: PPUSH
23482: CALL_OW 173
// AddComExitVehicle ( driver ) ;
23486: LD_VAR 0 18
23490: PPUSH
23491: CALL_OW 181
// end ; continue ;
23495: GO 23147
// end ; if not cleaners or not tmp in cleaners then
23497: LD_VAR 0 6
23501: NOT
23502: PUSH
23503: LD_VAR 0 13
23507: PUSH
23508: LD_VAR 0 6
23512: IN
23513: NOT
23514: OR
23515: IFFALSE 23822
// begin if dep then
23517: LD_VAR 0 17
23521: IFFALSE 23657
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
23523: LD_ADDR_VAR 0 16
23527: PUSH
23528: LD_VAR 0 17
23532: PUSH
23533: LD_INT 1
23535: ARRAY
23536: PPUSH
23537: CALL_OW 250
23541: PPUSH
23542: LD_VAR 0 17
23546: PUSH
23547: LD_INT 1
23549: ARRAY
23550: PPUSH
23551: CALL_OW 254
23555: PPUSH
23556: LD_INT 5
23558: PPUSH
23559: CALL_OW 272
23563: PUSH
23564: LD_VAR 0 17
23568: PUSH
23569: LD_INT 1
23571: ARRAY
23572: PPUSH
23573: CALL_OW 251
23577: PPUSH
23578: LD_VAR 0 17
23582: PUSH
23583: LD_INT 1
23585: ARRAY
23586: PPUSH
23587: CALL_OW 254
23591: PPUSH
23592: LD_INT 5
23594: PPUSH
23595: CALL_OW 273
23599: PUSH
23600: EMPTY
23601: LIST
23602: LIST
23603: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
23604: LD_VAR 0 16
23608: PUSH
23609: LD_INT 1
23611: ARRAY
23612: PPUSH
23613: LD_VAR 0 16
23617: PUSH
23618: LD_INT 2
23620: ARRAY
23621: PPUSH
23622: CALL_OW 488
23626: IFFALSE 23657
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
23628: LD_VAR 0 13
23632: PPUSH
23633: LD_VAR 0 16
23637: PUSH
23638: LD_INT 1
23640: ARRAY
23641: PPUSH
23642: LD_VAR 0 16
23646: PUSH
23647: LD_INT 2
23649: ARRAY
23650: PPUSH
23651: CALL_OW 111
// continue ;
23655: GO 23147
// end ; end ; r := GetDir ( tmp ) ;
23657: LD_ADDR_VAR 0 15
23661: PUSH
23662: LD_VAR 0 13
23666: PPUSH
23667: CALL_OW 254
23671: ST_TO_ADDR
// if r = 5 then
23672: LD_VAR 0 15
23676: PUSH
23677: LD_INT 5
23679: EQUAL
23680: IFFALSE 23690
// r := 0 ;
23682: LD_ADDR_VAR 0 15
23686: PUSH
23687: LD_INT 0
23689: ST_TO_ADDR
// for j = r to 5 do
23690: LD_ADDR_VAR 0 10
23694: PUSH
23695: DOUBLE
23696: LD_VAR 0 15
23700: DEC
23701: ST_TO_ADDR
23702: LD_INT 5
23704: PUSH
23705: FOR_TO
23706: IFFALSE 23820
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
23708: LD_ADDR_VAR 0 11
23712: PUSH
23713: LD_VAR 0 13
23717: PPUSH
23718: CALL_OW 250
23722: PPUSH
23723: LD_VAR 0 10
23727: PPUSH
23728: LD_INT 2
23730: PPUSH
23731: CALL_OW 272
23735: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
23736: LD_ADDR_VAR 0 12
23740: PUSH
23741: LD_VAR 0 13
23745: PPUSH
23746: CALL_OW 251
23750: PPUSH
23751: LD_VAR 0 10
23755: PPUSH
23756: LD_INT 2
23758: PPUSH
23759: CALL_OW 273
23763: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
23764: LD_VAR 0 11
23768: PPUSH
23769: LD_VAR 0 12
23773: PPUSH
23774: CALL_OW 488
23778: PUSH
23779: LD_VAR 0 11
23783: PPUSH
23784: LD_VAR 0 12
23788: PPUSH
23789: CALL_OW 428
23793: NOT
23794: AND
23795: IFFALSE 23818
// begin ComMoveXY ( tmp , _x , _y ) ;
23797: LD_VAR 0 13
23801: PPUSH
23802: LD_VAR 0 11
23806: PPUSH
23807: LD_VAR 0 12
23811: PPUSH
23812: CALL_OW 111
// break ;
23816: GO 23820
// end ; end ;
23818: GO 23705
23820: POP
23821: POP
// end ; end ;
23822: GO 23147
23824: POP
23825: POP
// end ;
23826: LD_VAR 0 8
23830: RET
// export function BuildingTechInvented ( side , btype ) ; begin
23831: LD_INT 0
23833: PPUSH
// result := true ;
23834: LD_ADDR_VAR 0 3
23838: PUSH
23839: LD_INT 1
23841: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
23842: LD_VAR 0 2
23846: PUSH
23847: LD_INT 24
23849: DOUBLE
23850: EQUAL
23851: IFTRUE 23861
23853: LD_INT 33
23855: DOUBLE
23856: EQUAL
23857: IFTRUE 23861
23859: GO 23886
23861: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
23862: LD_ADDR_VAR 0 3
23866: PUSH
23867: LD_INT 32
23869: PPUSH
23870: LD_VAR 0 1
23874: PPUSH
23875: CALL_OW 321
23879: PUSH
23880: LD_INT 2
23882: EQUAL
23883: ST_TO_ADDR
23884: GO 24202
23886: LD_INT 20
23888: DOUBLE
23889: EQUAL
23890: IFTRUE 23894
23892: GO 23919
23894: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
23895: LD_ADDR_VAR 0 3
23899: PUSH
23900: LD_INT 6
23902: PPUSH
23903: LD_VAR 0 1
23907: PPUSH
23908: CALL_OW 321
23912: PUSH
23913: LD_INT 2
23915: EQUAL
23916: ST_TO_ADDR
23917: GO 24202
23919: LD_INT 22
23921: DOUBLE
23922: EQUAL
23923: IFTRUE 23933
23925: LD_INT 36
23927: DOUBLE
23928: EQUAL
23929: IFTRUE 23933
23931: GO 23958
23933: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
23934: LD_ADDR_VAR 0 3
23938: PUSH
23939: LD_INT 15
23941: PPUSH
23942: LD_VAR 0 1
23946: PPUSH
23947: CALL_OW 321
23951: PUSH
23952: LD_INT 2
23954: EQUAL
23955: ST_TO_ADDR
23956: GO 24202
23958: LD_INT 30
23960: DOUBLE
23961: EQUAL
23962: IFTRUE 23966
23964: GO 23991
23966: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
23967: LD_ADDR_VAR 0 3
23971: PUSH
23972: LD_INT 20
23974: PPUSH
23975: LD_VAR 0 1
23979: PPUSH
23980: CALL_OW 321
23984: PUSH
23985: LD_INT 2
23987: EQUAL
23988: ST_TO_ADDR
23989: GO 24202
23991: LD_INT 28
23993: DOUBLE
23994: EQUAL
23995: IFTRUE 24005
23997: LD_INT 21
23999: DOUBLE
24000: EQUAL
24001: IFTRUE 24005
24003: GO 24030
24005: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
24006: LD_ADDR_VAR 0 3
24010: PUSH
24011: LD_INT 21
24013: PPUSH
24014: LD_VAR 0 1
24018: PPUSH
24019: CALL_OW 321
24023: PUSH
24024: LD_INT 2
24026: EQUAL
24027: ST_TO_ADDR
24028: GO 24202
24030: LD_INT 16
24032: DOUBLE
24033: EQUAL
24034: IFTRUE 24038
24036: GO 24063
24038: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
24039: LD_ADDR_VAR 0 3
24043: PUSH
24044: LD_INT 84
24046: PPUSH
24047: LD_VAR 0 1
24051: PPUSH
24052: CALL_OW 321
24056: PUSH
24057: LD_INT 2
24059: EQUAL
24060: ST_TO_ADDR
24061: GO 24202
24063: LD_INT 19
24065: DOUBLE
24066: EQUAL
24067: IFTRUE 24077
24069: LD_INT 23
24071: DOUBLE
24072: EQUAL
24073: IFTRUE 24077
24075: GO 24102
24077: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
24078: LD_ADDR_VAR 0 3
24082: PUSH
24083: LD_INT 83
24085: PPUSH
24086: LD_VAR 0 1
24090: PPUSH
24091: CALL_OW 321
24095: PUSH
24096: LD_INT 2
24098: EQUAL
24099: ST_TO_ADDR
24100: GO 24202
24102: LD_INT 17
24104: DOUBLE
24105: EQUAL
24106: IFTRUE 24110
24108: GO 24135
24110: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
24111: LD_ADDR_VAR 0 3
24115: PUSH
24116: LD_INT 39
24118: PPUSH
24119: LD_VAR 0 1
24123: PPUSH
24124: CALL_OW 321
24128: PUSH
24129: LD_INT 2
24131: EQUAL
24132: ST_TO_ADDR
24133: GO 24202
24135: LD_INT 18
24137: DOUBLE
24138: EQUAL
24139: IFTRUE 24143
24141: GO 24168
24143: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
24144: LD_ADDR_VAR 0 3
24148: PUSH
24149: LD_INT 40
24151: PPUSH
24152: LD_VAR 0 1
24156: PPUSH
24157: CALL_OW 321
24161: PUSH
24162: LD_INT 2
24164: EQUAL
24165: ST_TO_ADDR
24166: GO 24202
24168: LD_INT 27
24170: DOUBLE
24171: EQUAL
24172: IFTRUE 24176
24174: GO 24201
24176: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
24177: LD_ADDR_VAR 0 3
24181: PUSH
24182: LD_INT 35
24184: PPUSH
24185: LD_VAR 0 1
24189: PPUSH
24190: CALL_OW 321
24194: PUSH
24195: LD_INT 2
24197: EQUAL
24198: ST_TO_ADDR
24199: GO 24202
24201: POP
// end ;
24202: LD_VAR 0 3
24206: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
24207: LD_INT 0
24209: PPUSH
24210: PPUSH
24211: PPUSH
24212: PPUSH
24213: PPUSH
24214: PPUSH
24215: PPUSH
24216: PPUSH
24217: PPUSH
24218: PPUSH
24219: PPUSH
// result := false ;
24220: LD_ADDR_VAR 0 6
24224: PUSH
24225: LD_INT 0
24227: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
24228: LD_VAR 0 1
24232: NOT
24233: PUSH
24234: LD_VAR 0 1
24238: PPUSH
24239: CALL_OW 266
24243: PUSH
24244: LD_INT 0
24246: PUSH
24247: LD_INT 1
24249: PUSH
24250: EMPTY
24251: LIST
24252: LIST
24253: IN
24254: NOT
24255: OR
24256: PUSH
24257: LD_VAR 0 2
24261: NOT
24262: OR
24263: PUSH
24264: LD_VAR 0 5
24268: PUSH
24269: LD_INT 0
24271: PUSH
24272: LD_INT 1
24274: PUSH
24275: LD_INT 2
24277: PUSH
24278: LD_INT 3
24280: PUSH
24281: LD_INT 4
24283: PUSH
24284: LD_INT 5
24286: PUSH
24287: EMPTY
24288: LIST
24289: LIST
24290: LIST
24291: LIST
24292: LIST
24293: LIST
24294: IN
24295: NOT
24296: OR
24297: PUSH
24298: LD_VAR 0 3
24302: PPUSH
24303: LD_VAR 0 4
24307: PPUSH
24308: CALL_OW 488
24312: NOT
24313: OR
24314: IFFALSE 24318
// exit ;
24316: GO 25054
// side := GetSide ( depot ) ;
24318: LD_ADDR_VAR 0 9
24322: PUSH
24323: LD_VAR 0 1
24327: PPUSH
24328: CALL_OW 255
24332: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
24333: LD_VAR 0 9
24337: PPUSH
24338: LD_VAR 0 2
24342: PPUSH
24343: CALL 23831 0 2
24347: NOT
24348: IFFALSE 24352
// exit ;
24350: GO 25054
// pom := GetBase ( depot ) ;
24352: LD_ADDR_VAR 0 10
24356: PUSH
24357: LD_VAR 0 1
24361: PPUSH
24362: CALL_OW 274
24366: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
24367: LD_ADDR_VAR 0 11
24371: PUSH
24372: LD_VAR 0 2
24376: PPUSH
24377: LD_VAR 0 1
24381: PPUSH
24382: CALL_OW 248
24386: PPUSH
24387: CALL_OW 450
24391: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
24392: LD_VAR 0 10
24396: PPUSH
24397: LD_INT 1
24399: PPUSH
24400: CALL_OW 275
24404: PUSH
24405: LD_VAR 0 11
24409: PUSH
24410: LD_INT 1
24412: ARRAY
24413: GREATEREQUAL
24414: PUSH
24415: LD_VAR 0 10
24419: PPUSH
24420: LD_INT 2
24422: PPUSH
24423: CALL_OW 275
24427: PUSH
24428: LD_VAR 0 11
24432: PUSH
24433: LD_INT 2
24435: ARRAY
24436: GREATEREQUAL
24437: AND
24438: PUSH
24439: LD_VAR 0 10
24443: PPUSH
24444: LD_INT 3
24446: PPUSH
24447: CALL_OW 275
24451: PUSH
24452: LD_VAR 0 11
24456: PUSH
24457: LD_INT 3
24459: ARRAY
24460: GREATEREQUAL
24461: AND
24462: NOT
24463: IFFALSE 24467
// exit ;
24465: GO 25054
// if GetBType ( depot ) = b_depot then
24467: LD_VAR 0 1
24471: PPUSH
24472: CALL_OW 266
24476: PUSH
24477: LD_INT 0
24479: EQUAL
24480: IFFALSE 24492
// dist := 28 else
24482: LD_ADDR_VAR 0 14
24486: PUSH
24487: LD_INT 28
24489: ST_TO_ADDR
24490: GO 24500
// dist := 36 ;
24492: LD_ADDR_VAR 0 14
24496: PUSH
24497: LD_INT 36
24499: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
24500: LD_VAR 0 1
24504: PPUSH
24505: LD_VAR 0 3
24509: PPUSH
24510: LD_VAR 0 4
24514: PPUSH
24515: CALL_OW 297
24519: PUSH
24520: LD_VAR 0 14
24524: GREATER
24525: IFFALSE 24529
// exit ;
24527: GO 25054
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
24529: LD_ADDR_VAR 0 12
24533: PUSH
24534: LD_VAR 0 2
24538: PPUSH
24539: LD_VAR 0 3
24543: PPUSH
24544: LD_VAR 0 4
24548: PPUSH
24549: LD_VAR 0 5
24553: PPUSH
24554: LD_VAR 0 1
24558: PPUSH
24559: CALL_OW 248
24563: PPUSH
24564: LD_INT 0
24566: PPUSH
24567: CALL 25059 0 6
24571: ST_TO_ADDR
// if not hexes then
24572: LD_VAR 0 12
24576: NOT
24577: IFFALSE 24581
// exit ;
24579: GO 25054
// hex := GetHexInfo ( x , y ) ;
24581: LD_ADDR_VAR 0 15
24585: PUSH
24586: LD_VAR 0 3
24590: PPUSH
24591: LD_VAR 0 4
24595: PPUSH
24596: CALL_OW 546
24600: ST_TO_ADDR
// if hex [ 1 ] then
24601: LD_VAR 0 15
24605: PUSH
24606: LD_INT 1
24608: ARRAY
24609: IFFALSE 24613
// exit ;
24611: GO 25054
// height := hex [ 2 ] ;
24613: LD_ADDR_VAR 0 13
24617: PUSH
24618: LD_VAR 0 15
24622: PUSH
24623: LD_INT 2
24625: ARRAY
24626: ST_TO_ADDR
// for i = 1 to hexes do
24627: LD_ADDR_VAR 0 7
24631: PUSH
24632: DOUBLE
24633: LD_INT 1
24635: DEC
24636: ST_TO_ADDR
24637: LD_VAR 0 12
24641: PUSH
24642: FOR_TO
24643: IFFALSE 24973
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
24645: LD_VAR 0 12
24649: PUSH
24650: LD_VAR 0 7
24654: ARRAY
24655: PUSH
24656: LD_INT 1
24658: ARRAY
24659: PPUSH
24660: LD_VAR 0 12
24664: PUSH
24665: LD_VAR 0 7
24669: ARRAY
24670: PUSH
24671: LD_INT 2
24673: ARRAY
24674: PPUSH
24675: CALL_OW 488
24679: NOT
24680: PUSH
24681: LD_VAR 0 12
24685: PUSH
24686: LD_VAR 0 7
24690: ARRAY
24691: PUSH
24692: LD_INT 1
24694: ARRAY
24695: PPUSH
24696: LD_VAR 0 12
24700: PUSH
24701: LD_VAR 0 7
24705: ARRAY
24706: PUSH
24707: LD_INT 2
24709: ARRAY
24710: PPUSH
24711: CALL_OW 428
24715: PUSH
24716: LD_INT 0
24718: GREATER
24719: OR
24720: PUSH
24721: LD_VAR 0 12
24725: PUSH
24726: LD_VAR 0 7
24730: ARRAY
24731: PUSH
24732: LD_INT 1
24734: ARRAY
24735: PPUSH
24736: LD_VAR 0 12
24740: PUSH
24741: LD_VAR 0 7
24745: ARRAY
24746: PUSH
24747: LD_INT 2
24749: ARRAY
24750: PPUSH
24751: CALL_OW 351
24755: OR
24756: IFFALSE 24762
// exit ;
24758: POP
24759: POP
24760: GO 25054
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
24762: LD_ADDR_VAR 0 8
24766: PUSH
24767: LD_VAR 0 12
24771: PUSH
24772: LD_VAR 0 7
24776: ARRAY
24777: PUSH
24778: LD_INT 1
24780: ARRAY
24781: PPUSH
24782: LD_VAR 0 12
24786: PUSH
24787: LD_VAR 0 7
24791: ARRAY
24792: PUSH
24793: LD_INT 2
24795: ARRAY
24796: PPUSH
24797: CALL_OW 546
24801: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
24802: LD_VAR 0 8
24806: PUSH
24807: LD_INT 1
24809: ARRAY
24810: PUSH
24811: LD_VAR 0 8
24815: PUSH
24816: LD_INT 2
24818: ARRAY
24819: PUSH
24820: LD_VAR 0 13
24824: PUSH
24825: LD_INT 2
24827: PLUS
24828: GREATER
24829: OR
24830: PUSH
24831: LD_VAR 0 8
24835: PUSH
24836: LD_INT 2
24838: ARRAY
24839: PUSH
24840: LD_VAR 0 13
24844: PUSH
24845: LD_INT 2
24847: MINUS
24848: LESS
24849: OR
24850: PUSH
24851: LD_VAR 0 8
24855: PUSH
24856: LD_INT 3
24858: ARRAY
24859: PUSH
24860: LD_INT 0
24862: PUSH
24863: LD_INT 8
24865: PUSH
24866: LD_INT 9
24868: PUSH
24869: LD_INT 10
24871: PUSH
24872: LD_INT 11
24874: PUSH
24875: LD_INT 12
24877: PUSH
24878: LD_INT 13
24880: PUSH
24881: LD_INT 16
24883: PUSH
24884: LD_INT 17
24886: PUSH
24887: LD_INT 18
24889: PUSH
24890: LD_INT 19
24892: PUSH
24893: LD_INT 20
24895: PUSH
24896: LD_INT 21
24898: PUSH
24899: EMPTY
24900: LIST
24901: LIST
24902: LIST
24903: LIST
24904: LIST
24905: LIST
24906: LIST
24907: LIST
24908: LIST
24909: LIST
24910: LIST
24911: LIST
24912: LIST
24913: IN
24914: NOT
24915: OR
24916: PUSH
24917: LD_VAR 0 8
24921: PUSH
24922: LD_INT 5
24924: ARRAY
24925: NOT
24926: OR
24927: PUSH
24928: LD_VAR 0 8
24932: PUSH
24933: LD_INT 6
24935: ARRAY
24936: PUSH
24937: LD_INT 1
24939: PUSH
24940: LD_INT 2
24942: PUSH
24943: LD_INT 7
24945: PUSH
24946: LD_INT 9
24948: PUSH
24949: LD_INT 10
24951: PUSH
24952: LD_INT 11
24954: PUSH
24955: EMPTY
24956: LIST
24957: LIST
24958: LIST
24959: LIST
24960: LIST
24961: LIST
24962: IN
24963: NOT
24964: OR
24965: IFFALSE 24971
// exit ;
24967: POP
24968: POP
24969: GO 25054
// end ;
24971: GO 24642
24973: POP
24974: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
24975: LD_VAR 0 9
24979: PPUSH
24980: LD_VAR 0 3
24984: PPUSH
24985: LD_VAR 0 4
24989: PPUSH
24990: LD_INT 20
24992: PPUSH
24993: CALL 17006 0 4
24997: PUSH
24998: LD_INT 4
25000: ARRAY
25001: IFFALSE 25005
// exit ;
25003: GO 25054
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
25005: LD_VAR 0 2
25009: PUSH
25010: LD_INT 29
25012: PUSH
25013: LD_INT 30
25015: PUSH
25016: EMPTY
25017: LIST
25018: LIST
25019: IN
25020: PUSH
25021: LD_VAR 0 3
25025: PPUSH
25026: LD_VAR 0 4
25030: PPUSH
25031: LD_VAR 0 9
25035: PPUSH
25036: CALL_OW 440
25040: NOT
25041: AND
25042: IFFALSE 25046
// exit ;
25044: GO 25054
// result := true ;
25046: LD_ADDR_VAR 0 6
25050: PUSH
25051: LD_INT 1
25053: ST_TO_ADDR
// end ;
25054: LD_VAR 0 6
25058: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
25059: LD_INT 0
25061: PPUSH
25062: PPUSH
25063: PPUSH
25064: PPUSH
25065: PPUSH
25066: PPUSH
25067: PPUSH
25068: PPUSH
25069: PPUSH
25070: PPUSH
25071: PPUSH
25072: PPUSH
25073: PPUSH
25074: PPUSH
25075: PPUSH
25076: PPUSH
25077: PPUSH
25078: PPUSH
25079: PPUSH
25080: PPUSH
25081: PPUSH
25082: PPUSH
25083: PPUSH
25084: PPUSH
25085: PPUSH
25086: PPUSH
25087: PPUSH
25088: PPUSH
25089: PPUSH
25090: PPUSH
25091: PPUSH
25092: PPUSH
25093: PPUSH
25094: PPUSH
25095: PPUSH
25096: PPUSH
25097: PPUSH
25098: PPUSH
25099: PPUSH
25100: PPUSH
25101: PPUSH
25102: PPUSH
25103: PPUSH
25104: PPUSH
25105: PPUSH
25106: PPUSH
25107: PPUSH
25108: PPUSH
25109: PPUSH
25110: PPUSH
25111: PPUSH
25112: PPUSH
25113: PPUSH
25114: PPUSH
25115: PPUSH
25116: PPUSH
25117: PPUSH
25118: PPUSH
// result = [ ] ;
25119: LD_ADDR_VAR 0 7
25123: PUSH
25124: EMPTY
25125: ST_TO_ADDR
// temp_list = [ ] ;
25126: LD_ADDR_VAR 0 9
25130: PUSH
25131: EMPTY
25132: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
25133: LD_VAR 0 4
25137: PUSH
25138: LD_INT 0
25140: PUSH
25141: LD_INT 1
25143: PUSH
25144: LD_INT 2
25146: PUSH
25147: LD_INT 3
25149: PUSH
25150: LD_INT 4
25152: PUSH
25153: LD_INT 5
25155: PUSH
25156: EMPTY
25157: LIST
25158: LIST
25159: LIST
25160: LIST
25161: LIST
25162: LIST
25163: IN
25164: NOT
25165: PUSH
25166: LD_VAR 0 1
25170: PUSH
25171: LD_INT 0
25173: PUSH
25174: LD_INT 1
25176: PUSH
25177: EMPTY
25178: LIST
25179: LIST
25180: IN
25181: PUSH
25182: LD_VAR 0 5
25186: PUSH
25187: LD_INT 1
25189: PUSH
25190: LD_INT 2
25192: PUSH
25193: LD_INT 3
25195: PUSH
25196: EMPTY
25197: LIST
25198: LIST
25199: LIST
25200: IN
25201: NOT
25202: AND
25203: OR
25204: IFFALSE 25208
// exit ;
25206: GO 43599
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
25208: LD_VAR 0 1
25212: PUSH
25213: LD_INT 6
25215: PUSH
25216: LD_INT 7
25218: PUSH
25219: LD_INT 8
25221: PUSH
25222: LD_INT 13
25224: PUSH
25225: LD_INT 12
25227: PUSH
25228: LD_INT 15
25230: PUSH
25231: LD_INT 11
25233: PUSH
25234: LD_INT 14
25236: PUSH
25237: LD_INT 10
25239: PUSH
25240: EMPTY
25241: LIST
25242: LIST
25243: LIST
25244: LIST
25245: LIST
25246: LIST
25247: LIST
25248: LIST
25249: LIST
25250: IN
25251: IFFALSE 25261
// btype = b_lab ;
25253: LD_ADDR_VAR 0 1
25257: PUSH
25258: LD_INT 6
25260: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
25261: LD_VAR 0 6
25265: PUSH
25266: LD_INT 0
25268: PUSH
25269: LD_INT 1
25271: PUSH
25272: LD_INT 2
25274: PUSH
25275: EMPTY
25276: LIST
25277: LIST
25278: LIST
25279: IN
25280: NOT
25281: PUSH
25282: LD_VAR 0 1
25286: PUSH
25287: LD_INT 0
25289: PUSH
25290: LD_INT 1
25292: PUSH
25293: LD_INT 2
25295: PUSH
25296: LD_INT 3
25298: PUSH
25299: LD_INT 6
25301: PUSH
25302: LD_INT 36
25304: PUSH
25305: LD_INT 4
25307: PUSH
25308: LD_INT 5
25310: PUSH
25311: LD_INT 31
25313: PUSH
25314: LD_INT 32
25316: PUSH
25317: LD_INT 33
25319: PUSH
25320: EMPTY
25321: LIST
25322: LIST
25323: LIST
25324: LIST
25325: LIST
25326: LIST
25327: LIST
25328: LIST
25329: LIST
25330: LIST
25331: LIST
25332: IN
25333: NOT
25334: PUSH
25335: LD_VAR 0 6
25339: PUSH
25340: LD_INT 1
25342: EQUAL
25343: AND
25344: OR
25345: PUSH
25346: LD_VAR 0 1
25350: PUSH
25351: LD_INT 2
25353: PUSH
25354: LD_INT 3
25356: PUSH
25357: EMPTY
25358: LIST
25359: LIST
25360: IN
25361: NOT
25362: PUSH
25363: LD_VAR 0 6
25367: PUSH
25368: LD_INT 2
25370: EQUAL
25371: AND
25372: OR
25373: IFFALSE 25383
// mode = 0 ;
25375: LD_ADDR_VAR 0 6
25379: PUSH
25380: LD_INT 0
25382: ST_TO_ADDR
// case mode of 0 :
25383: LD_VAR 0 6
25387: PUSH
25388: LD_INT 0
25390: DOUBLE
25391: EQUAL
25392: IFTRUE 25396
25394: GO 36849
25396: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
25397: LD_ADDR_VAR 0 11
25401: PUSH
25402: LD_INT 0
25404: PUSH
25405: LD_INT 0
25407: PUSH
25408: EMPTY
25409: LIST
25410: LIST
25411: PUSH
25412: LD_INT 0
25414: PUSH
25415: LD_INT 1
25417: NEG
25418: PUSH
25419: EMPTY
25420: LIST
25421: LIST
25422: PUSH
25423: LD_INT 1
25425: PUSH
25426: LD_INT 0
25428: PUSH
25429: EMPTY
25430: LIST
25431: LIST
25432: PUSH
25433: LD_INT 1
25435: PUSH
25436: LD_INT 1
25438: PUSH
25439: EMPTY
25440: LIST
25441: LIST
25442: PUSH
25443: LD_INT 0
25445: PUSH
25446: LD_INT 1
25448: PUSH
25449: EMPTY
25450: LIST
25451: LIST
25452: PUSH
25453: LD_INT 1
25455: NEG
25456: PUSH
25457: LD_INT 0
25459: PUSH
25460: EMPTY
25461: LIST
25462: LIST
25463: PUSH
25464: LD_INT 1
25466: NEG
25467: PUSH
25468: LD_INT 1
25470: NEG
25471: PUSH
25472: EMPTY
25473: LIST
25474: LIST
25475: PUSH
25476: LD_INT 1
25478: NEG
25479: PUSH
25480: LD_INT 2
25482: NEG
25483: PUSH
25484: EMPTY
25485: LIST
25486: LIST
25487: PUSH
25488: LD_INT 0
25490: PUSH
25491: LD_INT 2
25493: NEG
25494: PUSH
25495: EMPTY
25496: LIST
25497: LIST
25498: PUSH
25499: LD_INT 1
25501: PUSH
25502: LD_INT 1
25504: NEG
25505: PUSH
25506: EMPTY
25507: LIST
25508: LIST
25509: PUSH
25510: LD_INT 1
25512: PUSH
25513: LD_INT 2
25515: PUSH
25516: EMPTY
25517: LIST
25518: LIST
25519: PUSH
25520: LD_INT 0
25522: PUSH
25523: LD_INT 2
25525: PUSH
25526: EMPTY
25527: LIST
25528: LIST
25529: PUSH
25530: LD_INT 1
25532: NEG
25533: PUSH
25534: LD_INT 1
25536: PUSH
25537: EMPTY
25538: LIST
25539: LIST
25540: PUSH
25541: LD_INT 1
25543: PUSH
25544: LD_INT 3
25546: PUSH
25547: EMPTY
25548: LIST
25549: LIST
25550: PUSH
25551: LD_INT 0
25553: PUSH
25554: LD_INT 3
25556: PUSH
25557: EMPTY
25558: LIST
25559: LIST
25560: PUSH
25561: LD_INT 1
25563: NEG
25564: PUSH
25565: LD_INT 2
25567: PUSH
25568: EMPTY
25569: LIST
25570: LIST
25571: PUSH
25572: EMPTY
25573: LIST
25574: LIST
25575: LIST
25576: LIST
25577: LIST
25578: LIST
25579: LIST
25580: LIST
25581: LIST
25582: LIST
25583: LIST
25584: LIST
25585: LIST
25586: LIST
25587: LIST
25588: LIST
25589: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
25590: LD_ADDR_VAR 0 12
25594: PUSH
25595: LD_INT 0
25597: PUSH
25598: LD_INT 0
25600: PUSH
25601: EMPTY
25602: LIST
25603: LIST
25604: PUSH
25605: LD_INT 0
25607: PUSH
25608: LD_INT 1
25610: NEG
25611: PUSH
25612: EMPTY
25613: LIST
25614: LIST
25615: PUSH
25616: LD_INT 1
25618: PUSH
25619: LD_INT 0
25621: PUSH
25622: EMPTY
25623: LIST
25624: LIST
25625: PUSH
25626: LD_INT 1
25628: PUSH
25629: LD_INT 1
25631: PUSH
25632: EMPTY
25633: LIST
25634: LIST
25635: PUSH
25636: LD_INT 0
25638: PUSH
25639: LD_INT 1
25641: PUSH
25642: EMPTY
25643: LIST
25644: LIST
25645: PUSH
25646: LD_INT 1
25648: NEG
25649: PUSH
25650: LD_INT 0
25652: PUSH
25653: EMPTY
25654: LIST
25655: LIST
25656: PUSH
25657: LD_INT 1
25659: NEG
25660: PUSH
25661: LD_INT 1
25663: NEG
25664: PUSH
25665: EMPTY
25666: LIST
25667: LIST
25668: PUSH
25669: LD_INT 1
25671: PUSH
25672: LD_INT 1
25674: NEG
25675: PUSH
25676: EMPTY
25677: LIST
25678: LIST
25679: PUSH
25680: LD_INT 2
25682: PUSH
25683: LD_INT 0
25685: PUSH
25686: EMPTY
25687: LIST
25688: LIST
25689: PUSH
25690: LD_INT 2
25692: PUSH
25693: LD_INT 1
25695: PUSH
25696: EMPTY
25697: LIST
25698: LIST
25699: PUSH
25700: LD_INT 1
25702: NEG
25703: PUSH
25704: LD_INT 1
25706: PUSH
25707: EMPTY
25708: LIST
25709: LIST
25710: PUSH
25711: LD_INT 2
25713: NEG
25714: PUSH
25715: LD_INT 0
25717: PUSH
25718: EMPTY
25719: LIST
25720: LIST
25721: PUSH
25722: LD_INT 2
25724: NEG
25725: PUSH
25726: LD_INT 1
25728: NEG
25729: PUSH
25730: EMPTY
25731: LIST
25732: LIST
25733: PUSH
25734: LD_INT 2
25736: NEG
25737: PUSH
25738: LD_INT 1
25740: PUSH
25741: EMPTY
25742: LIST
25743: LIST
25744: PUSH
25745: LD_INT 3
25747: NEG
25748: PUSH
25749: LD_INT 0
25751: PUSH
25752: EMPTY
25753: LIST
25754: LIST
25755: PUSH
25756: LD_INT 3
25758: NEG
25759: PUSH
25760: LD_INT 1
25762: NEG
25763: PUSH
25764: EMPTY
25765: LIST
25766: LIST
25767: PUSH
25768: EMPTY
25769: LIST
25770: LIST
25771: LIST
25772: LIST
25773: LIST
25774: LIST
25775: LIST
25776: LIST
25777: LIST
25778: LIST
25779: LIST
25780: LIST
25781: LIST
25782: LIST
25783: LIST
25784: LIST
25785: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
25786: LD_ADDR_VAR 0 13
25790: PUSH
25791: LD_INT 0
25793: PUSH
25794: LD_INT 0
25796: PUSH
25797: EMPTY
25798: LIST
25799: LIST
25800: PUSH
25801: LD_INT 0
25803: PUSH
25804: LD_INT 1
25806: NEG
25807: PUSH
25808: EMPTY
25809: LIST
25810: LIST
25811: PUSH
25812: LD_INT 1
25814: PUSH
25815: LD_INT 0
25817: PUSH
25818: EMPTY
25819: LIST
25820: LIST
25821: PUSH
25822: LD_INT 1
25824: PUSH
25825: LD_INT 1
25827: PUSH
25828: EMPTY
25829: LIST
25830: LIST
25831: PUSH
25832: LD_INT 0
25834: PUSH
25835: LD_INT 1
25837: PUSH
25838: EMPTY
25839: LIST
25840: LIST
25841: PUSH
25842: LD_INT 1
25844: NEG
25845: PUSH
25846: LD_INT 0
25848: PUSH
25849: EMPTY
25850: LIST
25851: LIST
25852: PUSH
25853: LD_INT 1
25855: NEG
25856: PUSH
25857: LD_INT 1
25859: NEG
25860: PUSH
25861: EMPTY
25862: LIST
25863: LIST
25864: PUSH
25865: LD_INT 1
25867: NEG
25868: PUSH
25869: LD_INT 2
25871: NEG
25872: PUSH
25873: EMPTY
25874: LIST
25875: LIST
25876: PUSH
25877: LD_INT 2
25879: PUSH
25880: LD_INT 1
25882: PUSH
25883: EMPTY
25884: LIST
25885: LIST
25886: PUSH
25887: LD_INT 2
25889: PUSH
25890: LD_INT 2
25892: PUSH
25893: EMPTY
25894: LIST
25895: LIST
25896: PUSH
25897: LD_INT 1
25899: PUSH
25900: LD_INT 2
25902: PUSH
25903: EMPTY
25904: LIST
25905: LIST
25906: PUSH
25907: LD_INT 2
25909: NEG
25910: PUSH
25911: LD_INT 1
25913: NEG
25914: PUSH
25915: EMPTY
25916: LIST
25917: LIST
25918: PUSH
25919: LD_INT 2
25921: NEG
25922: PUSH
25923: LD_INT 2
25925: NEG
25926: PUSH
25927: EMPTY
25928: LIST
25929: LIST
25930: PUSH
25931: LD_INT 2
25933: NEG
25934: PUSH
25935: LD_INT 3
25937: NEG
25938: PUSH
25939: EMPTY
25940: LIST
25941: LIST
25942: PUSH
25943: LD_INT 3
25945: NEG
25946: PUSH
25947: LD_INT 2
25949: NEG
25950: PUSH
25951: EMPTY
25952: LIST
25953: LIST
25954: PUSH
25955: LD_INT 3
25957: NEG
25958: PUSH
25959: LD_INT 3
25961: NEG
25962: PUSH
25963: EMPTY
25964: LIST
25965: LIST
25966: PUSH
25967: EMPTY
25968: LIST
25969: LIST
25970: LIST
25971: LIST
25972: LIST
25973: LIST
25974: LIST
25975: LIST
25976: LIST
25977: LIST
25978: LIST
25979: LIST
25980: LIST
25981: LIST
25982: LIST
25983: LIST
25984: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
25985: LD_ADDR_VAR 0 14
25989: PUSH
25990: LD_INT 0
25992: PUSH
25993: LD_INT 0
25995: PUSH
25996: EMPTY
25997: LIST
25998: LIST
25999: PUSH
26000: LD_INT 0
26002: PUSH
26003: LD_INT 1
26005: NEG
26006: PUSH
26007: EMPTY
26008: LIST
26009: LIST
26010: PUSH
26011: LD_INT 1
26013: PUSH
26014: LD_INT 0
26016: PUSH
26017: EMPTY
26018: LIST
26019: LIST
26020: PUSH
26021: LD_INT 1
26023: PUSH
26024: LD_INT 1
26026: PUSH
26027: EMPTY
26028: LIST
26029: LIST
26030: PUSH
26031: LD_INT 0
26033: PUSH
26034: LD_INT 1
26036: PUSH
26037: EMPTY
26038: LIST
26039: LIST
26040: PUSH
26041: LD_INT 1
26043: NEG
26044: PUSH
26045: LD_INT 0
26047: PUSH
26048: EMPTY
26049: LIST
26050: LIST
26051: PUSH
26052: LD_INT 1
26054: NEG
26055: PUSH
26056: LD_INT 1
26058: NEG
26059: PUSH
26060: EMPTY
26061: LIST
26062: LIST
26063: PUSH
26064: LD_INT 1
26066: NEG
26067: PUSH
26068: LD_INT 2
26070: NEG
26071: PUSH
26072: EMPTY
26073: LIST
26074: LIST
26075: PUSH
26076: LD_INT 0
26078: PUSH
26079: LD_INT 2
26081: NEG
26082: PUSH
26083: EMPTY
26084: LIST
26085: LIST
26086: PUSH
26087: LD_INT 1
26089: PUSH
26090: LD_INT 1
26092: NEG
26093: PUSH
26094: EMPTY
26095: LIST
26096: LIST
26097: PUSH
26098: LD_INT 1
26100: PUSH
26101: LD_INT 2
26103: PUSH
26104: EMPTY
26105: LIST
26106: LIST
26107: PUSH
26108: LD_INT 0
26110: PUSH
26111: LD_INT 2
26113: PUSH
26114: EMPTY
26115: LIST
26116: LIST
26117: PUSH
26118: LD_INT 1
26120: NEG
26121: PUSH
26122: LD_INT 1
26124: PUSH
26125: EMPTY
26126: LIST
26127: LIST
26128: PUSH
26129: LD_INT 1
26131: NEG
26132: PUSH
26133: LD_INT 3
26135: NEG
26136: PUSH
26137: EMPTY
26138: LIST
26139: LIST
26140: PUSH
26141: LD_INT 0
26143: PUSH
26144: LD_INT 3
26146: NEG
26147: PUSH
26148: EMPTY
26149: LIST
26150: LIST
26151: PUSH
26152: LD_INT 1
26154: PUSH
26155: LD_INT 2
26157: NEG
26158: PUSH
26159: EMPTY
26160: LIST
26161: LIST
26162: PUSH
26163: EMPTY
26164: LIST
26165: LIST
26166: LIST
26167: LIST
26168: LIST
26169: LIST
26170: LIST
26171: LIST
26172: LIST
26173: LIST
26174: LIST
26175: LIST
26176: LIST
26177: LIST
26178: LIST
26179: LIST
26180: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
26181: LD_ADDR_VAR 0 15
26185: PUSH
26186: LD_INT 0
26188: PUSH
26189: LD_INT 0
26191: PUSH
26192: EMPTY
26193: LIST
26194: LIST
26195: PUSH
26196: LD_INT 0
26198: PUSH
26199: LD_INT 1
26201: NEG
26202: PUSH
26203: EMPTY
26204: LIST
26205: LIST
26206: PUSH
26207: LD_INT 1
26209: PUSH
26210: LD_INT 0
26212: PUSH
26213: EMPTY
26214: LIST
26215: LIST
26216: PUSH
26217: LD_INT 1
26219: PUSH
26220: LD_INT 1
26222: PUSH
26223: EMPTY
26224: LIST
26225: LIST
26226: PUSH
26227: LD_INT 0
26229: PUSH
26230: LD_INT 1
26232: PUSH
26233: EMPTY
26234: LIST
26235: LIST
26236: PUSH
26237: LD_INT 1
26239: NEG
26240: PUSH
26241: LD_INT 0
26243: PUSH
26244: EMPTY
26245: LIST
26246: LIST
26247: PUSH
26248: LD_INT 1
26250: NEG
26251: PUSH
26252: LD_INT 1
26254: NEG
26255: PUSH
26256: EMPTY
26257: LIST
26258: LIST
26259: PUSH
26260: LD_INT 1
26262: PUSH
26263: LD_INT 1
26265: NEG
26266: PUSH
26267: EMPTY
26268: LIST
26269: LIST
26270: PUSH
26271: LD_INT 2
26273: PUSH
26274: LD_INT 0
26276: PUSH
26277: EMPTY
26278: LIST
26279: LIST
26280: PUSH
26281: LD_INT 2
26283: PUSH
26284: LD_INT 1
26286: PUSH
26287: EMPTY
26288: LIST
26289: LIST
26290: PUSH
26291: LD_INT 1
26293: NEG
26294: PUSH
26295: LD_INT 1
26297: PUSH
26298: EMPTY
26299: LIST
26300: LIST
26301: PUSH
26302: LD_INT 2
26304: NEG
26305: PUSH
26306: LD_INT 0
26308: PUSH
26309: EMPTY
26310: LIST
26311: LIST
26312: PUSH
26313: LD_INT 2
26315: NEG
26316: PUSH
26317: LD_INT 1
26319: NEG
26320: PUSH
26321: EMPTY
26322: LIST
26323: LIST
26324: PUSH
26325: LD_INT 2
26327: PUSH
26328: LD_INT 1
26330: NEG
26331: PUSH
26332: EMPTY
26333: LIST
26334: LIST
26335: PUSH
26336: LD_INT 3
26338: PUSH
26339: LD_INT 0
26341: PUSH
26342: EMPTY
26343: LIST
26344: LIST
26345: PUSH
26346: LD_INT 3
26348: PUSH
26349: LD_INT 1
26351: PUSH
26352: EMPTY
26353: LIST
26354: LIST
26355: PUSH
26356: EMPTY
26357: LIST
26358: LIST
26359: LIST
26360: LIST
26361: LIST
26362: LIST
26363: LIST
26364: LIST
26365: LIST
26366: LIST
26367: LIST
26368: LIST
26369: LIST
26370: LIST
26371: LIST
26372: LIST
26373: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
26374: LD_ADDR_VAR 0 16
26378: PUSH
26379: LD_INT 0
26381: PUSH
26382: LD_INT 0
26384: PUSH
26385: EMPTY
26386: LIST
26387: LIST
26388: PUSH
26389: LD_INT 0
26391: PUSH
26392: LD_INT 1
26394: NEG
26395: PUSH
26396: EMPTY
26397: LIST
26398: LIST
26399: PUSH
26400: LD_INT 1
26402: PUSH
26403: LD_INT 0
26405: PUSH
26406: EMPTY
26407: LIST
26408: LIST
26409: PUSH
26410: LD_INT 1
26412: PUSH
26413: LD_INT 1
26415: PUSH
26416: EMPTY
26417: LIST
26418: LIST
26419: PUSH
26420: LD_INT 0
26422: PUSH
26423: LD_INT 1
26425: PUSH
26426: EMPTY
26427: LIST
26428: LIST
26429: PUSH
26430: LD_INT 1
26432: NEG
26433: PUSH
26434: LD_INT 0
26436: PUSH
26437: EMPTY
26438: LIST
26439: LIST
26440: PUSH
26441: LD_INT 1
26443: NEG
26444: PUSH
26445: LD_INT 1
26447: NEG
26448: PUSH
26449: EMPTY
26450: LIST
26451: LIST
26452: PUSH
26453: LD_INT 1
26455: NEG
26456: PUSH
26457: LD_INT 2
26459: NEG
26460: PUSH
26461: EMPTY
26462: LIST
26463: LIST
26464: PUSH
26465: LD_INT 2
26467: PUSH
26468: LD_INT 1
26470: PUSH
26471: EMPTY
26472: LIST
26473: LIST
26474: PUSH
26475: LD_INT 2
26477: PUSH
26478: LD_INT 2
26480: PUSH
26481: EMPTY
26482: LIST
26483: LIST
26484: PUSH
26485: LD_INT 1
26487: PUSH
26488: LD_INT 2
26490: PUSH
26491: EMPTY
26492: LIST
26493: LIST
26494: PUSH
26495: LD_INT 2
26497: NEG
26498: PUSH
26499: LD_INT 1
26501: NEG
26502: PUSH
26503: EMPTY
26504: LIST
26505: LIST
26506: PUSH
26507: LD_INT 2
26509: NEG
26510: PUSH
26511: LD_INT 2
26513: NEG
26514: PUSH
26515: EMPTY
26516: LIST
26517: LIST
26518: PUSH
26519: LD_INT 3
26521: PUSH
26522: LD_INT 2
26524: PUSH
26525: EMPTY
26526: LIST
26527: LIST
26528: PUSH
26529: LD_INT 3
26531: PUSH
26532: LD_INT 3
26534: PUSH
26535: EMPTY
26536: LIST
26537: LIST
26538: PUSH
26539: LD_INT 2
26541: PUSH
26542: LD_INT 3
26544: PUSH
26545: EMPTY
26546: LIST
26547: LIST
26548: PUSH
26549: EMPTY
26550: LIST
26551: LIST
26552: LIST
26553: LIST
26554: LIST
26555: LIST
26556: LIST
26557: LIST
26558: LIST
26559: LIST
26560: LIST
26561: LIST
26562: LIST
26563: LIST
26564: LIST
26565: LIST
26566: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26567: LD_ADDR_VAR 0 17
26571: PUSH
26572: LD_INT 0
26574: PUSH
26575: LD_INT 0
26577: PUSH
26578: EMPTY
26579: LIST
26580: LIST
26581: PUSH
26582: LD_INT 0
26584: PUSH
26585: LD_INT 1
26587: NEG
26588: PUSH
26589: EMPTY
26590: LIST
26591: LIST
26592: PUSH
26593: LD_INT 1
26595: PUSH
26596: LD_INT 0
26598: PUSH
26599: EMPTY
26600: LIST
26601: LIST
26602: PUSH
26603: LD_INT 1
26605: PUSH
26606: LD_INT 1
26608: PUSH
26609: EMPTY
26610: LIST
26611: LIST
26612: PUSH
26613: LD_INT 0
26615: PUSH
26616: LD_INT 1
26618: PUSH
26619: EMPTY
26620: LIST
26621: LIST
26622: PUSH
26623: LD_INT 1
26625: NEG
26626: PUSH
26627: LD_INT 0
26629: PUSH
26630: EMPTY
26631: LIST
26632: LIST
26633: PUSH
26634: LD_INT 1
26636: NEG
26637: PUSH
26638: LD_INT 1
26640: NEG
26641: PUSH
26642: EMPTY
26643: LIST
26644: LIST
26645: PUSH
26646: LD_INT 1
26648: NEG
26649: PUSH
26650: LD_INT 2
26652: NEG
26653: PUSH
26654: EMPTY
26655: LIST
26656: LIST
26657: PUSH
26658: LD_INT 0
26660: PUSH
26661: LD_INT 2
26663: NEG
26664: PUSH
26665: EMPTY
26666: LIST
26667: LIST
26668: PUSH
26669: LD_INT 1
26671: PUSH
26672: LD_INT 1
26674: NEG
26675: PUSH
26676: EMPTY
26677: LIST
26678: LIST
26679: PUSH
26680: LD_INT 2
26682: PUSH
26683: LD_INT 0
26685: PUSH
26686: EMPTY
26687: LIST
26688: LIST
26689: PUSH
26690: LD_INT 2
26692: PUSH
26693: LD_INT 1
26695: PUSH
26696: EMPTY
26697: LIST
26698: LIST
26699: PUSH
26700: LD_INT 2
26702: PUSH
26703: LD_INT 2
26705: PUSH
26706: EMPTY
26707: LIST
26708: LIST
26709: PUSH
26710: LD_INT 1
26712: PUSH
26713: LD_INT 2
26715: PUSH
26716: EMPTY
26717: LIST
26718: LIST
26719: PUSH
26720: LD_INT 0
26722: PUSH
26723: LD_INT 2
26725: PUSH
26726: EMPTY
26727: LIST
26728: LIST
26729: PUSH
26730: LD_INT 1
26732: NEG
26733: PUSH
26734: LD_INT 1
26736: PUSH
26737: EMPTY
26738: LIST
26739: LIST
26740: PUSH
26741: LD_INT 2
26743: NEG
26744: PUSH
26745: LD_INT 0
26747: PUSH
26748: EMPTY
26749: LIST
26750: LIST
26751: PUSH
26752: LD_INT 2
26754: NEG
26755: PUSH
26756: LD_INT 1
26758: NEG
26759: PUSH
26760: EMPTY
26761: LIST
26762: LIST
26763: PUSH
26764: LD_INT 2
26766: NEG
26767: PUSH
26768: LD_INT 2
26770: NEG
26771: PUSH
26772: EMPTY
26773: LIST
26774: LIST
26775: PUSH
26776: EMPTY
26777: LIST
26778: LIST
26779: LIST
26780: LIST
26781: LIST
26782: LIST
26783: LIST
26784: LIST
26785: LIST
26786: LIST
26787: LIST
26788: LIST
26789: LIST
26790: LIST
26791: LIST
26792: LIST
26793: LIST
26794: LIST
26795: LIST
26796: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26797: LD_ADDR_VAR 0 18
26801: PUSH
26802: LD_INT 0
26804: PUSH
26805: LD_INT 0
26807: PUSH
26808: EMPTY
26809: LIST
26810: LIST
26811: PUSH
26812: LD_INT 0
26814: PUSH
26815: LD_INT 1
26817: NEG
26818: PUSH
26819: EMPTY
26820: LIST
26821: LIST
26822: PUSH
26823: LD_INT 1
26825: PUSH
26826: LD_INT 0
26828: PUSH
26829: EMPTY
26830: LIST
26831: LIST
26832: PUSH
26833: LD_INT 1
26835: PUSH
26836: LD_INT 1
26838: PUSH
26839: EMPTY
26840: LIST
26841: LIST
26842: PUSH
26843: LD_INT 0
26845: PUSH
26846: LD_INT 1
26848: PUSH
26849: EMPTY
26850: LIST
26851: LIST
26852: PUSH
26853: LD_INT 1
26855: NEG
26856: PUSH
26857: LD_INT 0
26859: PUSH
26860: EMPTY
26861: LIST
26862: LIST
26863: PUSH
26864: LD_INT 1
26866: NEG
26867: PUSH
26868: LD_INT 1
26870: NEG
26871: PUSH
26872: EMPTY
26873: LIST
26874: LIST
26875: PUSH
26876: LD_INT 1
26878: NEG
26879: PUSH
26880: LD_INT 2
26882: NEG
26883: PUSH
26884: EMPTY
26885: LIST
26886: LIST
26887: PUSH
26888: LD_INT 0
26890: PUSH
26891: LD_INT 2
26893: NEG
26894: PUSH
26895: EMPTY
26896: LIST
26897: LIST
26898: PUSH
26899: LD_INT 1
26901: PUSH
26902: LD_INT 1
26904: NEG
26905: PUSH
26906: EMPTY
26907: LIST
26908: LIST
26909: PUSH
26910: LD_INT 2
26912: PUSH
26913: LD_INT 0
26915: PUSH
26916: EMPTY
26917: LIST
26918: LIST
26919: PUSH
26920: LD_INT 2
26922: PUSH
26923: LD_INT 1
26925: PUSH
26926: EMPTY
26927: LIST
26928: LIST
26929: PUSH
26930: LD_INT 2
26932: PUSH
26933: LD_INT 2
26935: PUSH
26936: EMPTY
26937: LIST
26938: LIST
26939: PUSH
26940: LD_INT 1
26942: PUSH
26943: LD_INT 2
26945: PUSH
26946: EMPTY
26947: LIST
26948: LIST
26949: PUSH
26950: LD_INT 0
26952: PUSH
26953: LD_INT 2
26955: PUSH
26956: EMPTY
26957: LIST
26958: LIST
26959: PUSH
26960: LD_INT 1
26962: NEG
26963: PUSH
26964: LD_INT 1
26966: PUSH
26967: EMPTY
26968: LIST
26969: LIST
26970: PUSH
26971: LD_INT 2
26973: NEG
26974: PUSH
26975: LD_INT 0
26977: PUSH
26978: EMPTY
26979: LIST
26980: LIST
26981: PUSH
26982: LD_INT 2
26984: NEG
26985: PUSH
26986: LD_INT 1
26988: NEG
26989: PUSH
26990: EMPTY
26991: LIST
26992: LIST
26993: PUSH
26994: LD_INT 2
26996: NEG
26997: PUSH
26998: LD_INT 2
27000: NEG
27001: PUSH
27002: EMPTY
27003: LIST
27004: LIST
27005: PUSH
27006: EMPTY
27007: LIST
27008: LIST
27009: LIST
27010: LIST
27011: LIST
27012: LIST
27013: LIST
27014: LIST
27015: LIST
27016: LIST
27017: LIST
27018: LIST
27019: LIST
27020: LIST
27021: LIST
27022: LIST
27023: LIST
27024: LIST
27025: LIST
27026: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27027: LD_ADDR_VAR 0 19
27031: PUSH
27032: LD_INT 0
27034: PUSH
27035: LD_INT 0
27037: PUSH
27038: EMPTY
27039: LIST
27040: LIST
27041: PUSH
27042: LD_INT 0
27044: PUSH
27045: LD_INT 1
27047: NEG
27048: PUSH
27049: EMPTY
27050: LIST
27051: LIST
27052: PUSH
27053: LD_INT 1
27055: PUSH
27056: LD_INT 0
27058: PUSH
27059: EMPTY
27060: LIST
27061: LIST
27062: PUSH
27063: LD_INT 1
27065: PUSH
27066: LD_INT 1
27068: PUSH
27069: EMPTY
27070: LIST
27071: LIST
27072: PUSH
27073: LD_INT 0
27075: PUSH
27076: LD_INT 1
27078: PUSH
27079: EMPTY
27080: LIST
27081: LIST
27082: PUSH
27083: LD_INT 1
27085: NEG
27086: PUSH
27087: LD_INT 0
27089: PUSH
27090: EMPTY
27091: LIST
27092: LIST
27093: PUSH
27094: LD_INT 1
27096: NEG
27097: PUSH
27098: LD_INT 1
27100: NEG
27101: PUSH
27102: EMPTY
27103: LIST
27104: LIST
27105: PUSH
27106: LD_INT 1
27108: NEG
27109: PUSH
27110: LD_INT 2
27112: NEG
27113: PUSH
27114: EMPTY
27115: LIST
27116: LIST
27117: PUSH
27118: LD_INT 0
27120: PUSH
27121: LD_INT 2
27123: NEG
27124: PUSH
27125: EMPTY
27126: LIST
27127: LIST
27128: PUSH
27129: LD_INT 1
27131: PUSH
27132: LD_INT 1
27134: NEG
27135: PUSH
27136: EMPTY
27137: LIST
27138: LIST
27139: PUSH
27140: LD_INT 2
27142: PUSH
27143: LD_INT 0
27145: PUSH
27146: EMPTY
27147: LIST
27148: LIST
27149: PUSH
27150: LD_INT 2
27152: PUSH
27153: LD_INT 1
27155: PUSH
27156: EMPTY
27157: LIST
27158: LIST
27159: PUSH
27160: LD_INT 2
27162: PUSH
27163: LD_INT 2
27165: PUSH
27166: EMPTY
27167: LIST
27168: LIST
27169: PUSH
27170: LD_INT 1
27172: PUSH
27173: LD_INT 2
27175: PUSH
27176: EMPTY
27177: LIST
27178: LIST
27179: PUSH
27180: LD_INT 0
27182: PUSH
27183: LD_INT 2
27185: PUSH
27186: EMPTY
27187: LIST
27188: LIST
27189: PUSH
27190: LD_INT 1
27192: NEG
27193: PUSH
27194: LD_INT 1
27196: PUSH
27197: EMPTY
27198: LIST
27199: LIST
27200: PUSH
27201: LD_INT 2
27203: NEG
27204: PUSH
27205: LD_INT 0
27207: PUSH
27208: EMPTY
27209: LIST
27210: LIST
27211: PUSH
27212: LD_INT 2
27214: NEG
27215: PUSH
27216: LD_INT 1
27218: NEG
27219: PUSH
27220: EMPTY
27221: LIST
27222: LIST
27223: PUSH
27224: LD_INT 2
27226: NEG
27227: PUSH
27228: LD_INT 2
27230: NEG
27231: PUSH
27232: EMPTY
27233: LIST
27234: LIST
27235: PUSH
27236: EMPTY
27237: LIST
27238: LIST
27239: LIST
27240: LIST
27241: LIST
27242: LIST
27243: LIST
27244: LIST
27245: LIST
27246: LIST
27247: LIST
27248: LIST
27249: LIST
27250: LIST
27251: LIST
27252: LIST
27253: LIST
27254: LIST
27255: LIST
27256: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27257: LD_ADDR_VAR 0 20
27261: PUSH
27262: LD_INT 0
27264: PUSH
27265: LD_INT 0
27267: PUSH
27268: EMPTY
27269: LIST
27270: LIST
27271: PUSH
27272: LD_INT 0
27274: PUSH
27275: LD_INT 1
27277: NEG
27278: PUSH
27279: EMPTY
27280: LIST
27281: LIST
27282: PUSH
27283: LD_INT 1
27285: PUSH
27286: LD_INT 0
27288: PUSH
27289: EMPTY
27290: LIST
27291: LIST
27292: PUSH
27293: LD_INT 1
27295: PUSH
27296: LD_INT 1
27298: PUSH
27299: EMPTY
27300: LIST
27301: LIST
27302: PUSH
27303: LD_INT 0
27305: PUSH
27306: LD_INT 1
27308: PUSH
27309: EMPTY
27310: LIST
27311: LIST
27312: PUSH
27313: LD_INT 1
27315: NEG
27316: PUSH
27317: LD_INT 0
27319: PUSH
27320: EMPTY
27321: LIST
27322: LIST
27323: PUSH
27324: LD_INT 1
27326: NEG
27327: PUSH
27328: LD_INT 1
27330: NEG
27331: PUSH
27332: EMPTY
27333: LIST
27334: LIST
27335: PUSH
27336: LD_INT 1
27338: NEG
27339: PUSH
27340: LD_INT 2
27342: NEG
27343: PUSH
27344: EMPTY
27345: LIST
27346: LIST
27347: PUSH
27348: LD_INT 0
27350: PUSH
27351: LD_INT 2
27353: NEG
27354: PUSH
27355: EMPTY
27356: LIST
27357: LIST
27358: PUSH
27359: LD_INT 1
27361: PUSH
27362: LD_INT 1
27364: NEG
27365: PUSH
27366: EMPTY
27367: LIST
27368: LIST
27369: PUSH
27370: LD_INT 2
27372: PUSH
27373: LD_INT 0
27375: PUSH
27376: EMPTY
27377: LIST
27378: LIST
27379: PUSH
27380: LD_INT 2
27382: PUSH
27383: LD_INT 1
27385: PUSH
27386: EMPTY
27387: LIST
27388: LIST
27389: PUSH
27390: LD_INT 2
27392: PUSH
27393: LD_INT 2
27395: PUSH
27396: EMPTY
27397: LIST
27398: LIST
27399: PUSH
27400: LD_INT 1
27402: PUSH
27403: LD_INT 2
27405: PUSH
27406: EMPTY
27407: LIST
27408: LIST
27409: PUSH
27410: LD_INT 0
27412: PUSH
27413: LD_INT 2
27415: PUSH
27416: EMPTY
27417: LIST
27418: LIST
27419: PUSH
27420: LD_INT 1
27422: NEG
27423: PUSH
27424: LD_INT 1
27426: PUSH
27427: EMPTY
27428: LIST
27429: LIST
27430: PUSH
27431: LD_INT 2
27433: NEG
27434: PUSH
27435: LD_INT 0
27437: PUSH
27438: EMPTY
27439: LIST
27440: LIST
27441: PUSH
27442: LD_INT 2
27444: NEG
27445: PUSH
27446: LD_INT 1
27448: NEG
27449: PUSH
27450: EMPTY
27451: LIST
27452: LIST
27453: PUSH
27454: LD_INT 2
27456: NEG
27457: PUSH
27458: LD_INT 2
27460: NEG
27461: PUSH
27462: EMPTY
27463: LIST
27464: LIST
27465: PUSH
27466: EMPTY
27467: LIST
27468: LIST
27469: LIST
27470: LIST
27471: LIST
27472: LIST
27473: LIST
27474: LIST
27475: LIST
27476: LIST
27477: LIST
27478: LIST
27479: LIST
27480: LIST
27481: LIST
27482: LIST
27483: LIST
27484: LIST
27485: LIST
27486: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27487: LD_ADDR_VAR 0 21
27491: PUSH
27492: LD_INT 0
27494: PUSH
27495: LD_INT 0
27497: PUSH
27498: EMPTY
27499: LIST
27500: LIST
27501: PUSH
27502: LD_INT 0
27504: PUSH
27505: LD_INT 1
27507: NEG
27508: PUSH
27509: EMPTY
27510: LIST
27511: LIST
27512: PUSH
27513: LD_INT 1
27515: PUSH
27516: LD_INT 0
27518: PUSH
27519: EMPTY
27520: LIST
27521: LIST
27522: PUSH
27523: LD_INT 1
27525: PUSH
27526: LD_INT 1
27528: PUSH
27529: EMPTY
27530: LIST
27531: LIST
27532: PUSH
27533: LD_INT 0
27535: PUSH
27536: LD_INT 1
27538: PUSH
27539: EMPTY
27540: LIST
27541: LIST
27542: PUSH
27543: LD_INT 1
27545: NEG
27546: PUSH
27547: LD_INT 0
27549: PUSH
27550: EMPTY
27551: LIST
27552: LIST
27553: PUSH
27554: LD_INT 1
27556: NEG
27557: PUSH
27558: LD_INT 1
27560: NEG
27561: PUSH
27562: EMPTY
27563: LIST
27564: LIST
27565: PUSH
27566: LD_INT 1
27568: NEG
27569: PUSH
27570: LD_INT 2
27572: NEG
27573: PUSH
27574: EMPTY
27575: LIST
27576: LIST
27577: PUSH
27578: LD_INT 0
27580: PUSH
27581: LD_INT 2
27583: NEG
27584: PUSH
27585: EMPTY
27586: LIST
27587: LIST
27588: PUSH
27589: LD_INT 1
27591: PUSH
27592: LD_INT 1
27594: NEG
27595: PUSH
27596: EMPTY
27597: LIST
27598: LIST
27599: PUSH
27600: LD_INT 2
27602: PUSH
27603: LD_INT 0
27605: PUSH
27606: EMPTY
27607: LIST
27608: LIST
27609: PUSH
27610: LD_INT 2
27612: PUSH
27613: LD_INT 1
27615: PUSH
27616: EMPTY
27617: LIST
27618: LIST
27619: PUSH
27620: LD_INT 2
27622: PUSH
27623: LD_INT 2
27625: PUSH
27626: EMPTY
27627: LIST
27628: LIST
27629: PUSH
27630: LD_INT 1
27632: PUSH
27633: LD_INT 2
27635: PUSH
27636: EMPTY
27637: LIST
27638: LIST
27639: PUSH
27640: LD_INT 0
27642: PUSH
27643: LD_INT 2
27645: PUSH
27646: EMPTY
27647: LIST
27648: LIST
27649: PUSH
27650: LD_INT 1
27652: NEG
27653: PUSH
27654: LD_INT 1
27656: PUSH
27657: EMPTY
27658: LIST
27659: LIST
27660: PUSH
27661: LD_INT 2
27663: NEG
27664: PUSH
27665: LD_INT 0
27667: PUSH
27668: EMPTY
27669: LIST
27670: LIST
27671: PUSH
27672: LD_INT 2
27674: NEG
27675: PUSH
27676: LD_INT 1
27678: NEG
27679: PUSH
27680: EMPTY
27681: LIST
27682: LIST
27683: PUSH
27684: LD_INT 2
27686: NEG
27687: PUSH
27688: LD_INT 2
27690: NEG
27691: PUSH
27692: EMPTY
27693: LIST
27694: LIST
27695: PUSH
27696: EMPTY
27697: LIST
27698: LIST
27699: LIST
27700: LIST
27701: LIST
27702: LIST
27703: LIST
27704: LIST
27705: LIST
27706: LIST
27707: LIST
27708: LIST
27709: LIST
27710: LIST
27711: LIST
27712: LIST
27713: LIST
27714: LIST
27715: LIST
27716: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27717: LD_ADDR_VAR 0 22
27721: PUSH
27722: LD_INT 0
27724: PUSH
27725: LD_INT 0
27727: PUSH
27728: EMPTY
27729: LIST
27730: LIST
27731: PUSH
27732: LD_INT 0
27734: PUSH
27735: LD_INT 1
27737: NEG
27738: PUSH
27739: EMPTY
27740: LIST
27741: LIST
27742: PUSH
27743: LD_INT 1
27745: PUSH
27746: LD_INT 0
27748: PUSH
27749: EMPTY
27750: LIST
27751: LIST
27752: PUSH
27753: LD_INT 1
27755: PUSH
27756: LD_INT 1
27758: PUSH
27759: EMPTY
27760: LIST
27761: LIST
27762: PUSH
27763: LD_INT 0
27765: PUSH
27766: LD_INT 1
27768: PUSH
27769: EMPTY
27770: LIST
27771: LIST
27772: PUSH
27773: LD_INT 1
27775: NEG
27776: PUSH
27777: LD_INT 0
27779: PUSH
27780: EMPTY
27781: LIST
27782: LIST
27783: PUSH
27784: LD_INT 1
27786: NEG
27787: PUSH
27788: LD_INT 1
27790: NEG
27791: PUSH
27792: EMPTY
27793: LIST
27794: LIST
27795: PUSH
27796: LD_INT 1
27798: NEG
27799: PUSH
27800: LD_INT 2
27802: NEG
27803: PUSH
27804: EMPTY
27805: LIST
27806: LIST
27807: PUSH
27808: LD_INT 0
27810: PUSH
27811: LD_INT 2
27813: NEG
27814: PUSH
27815: EMPTY
27816: LIST
27817: LIST
27818: PUSH
27819: LD_INT 1
27821: PUSH
27822: LD_INT 1
27824: NEG
27825: PUSH
27826: EMPTY
27827: LIST
27828: LIST
27829: PUSH
27830: LD_INT 2
27832: PUSH
27833: LD_INT 0
27835: PUSH
27836: EMPTY
27837: LIST
27838: LIST
27839: PUSH
27840: LD_INT 2
27842: PUSH
27843: LD_INT 1
27845: PUSH
27846: EMPTY
27847: LIST
27848: LIST
27849: PUSH
27850: LD_INT 2
27852: PUSH
27853: LD_INT 2
27855: PUSH
27856: EMPTY
27857: LIST
27858: LIST
27859: PUSH
27860: LD_INT 1
27862: PUSH
27863: LD_INT 2
27865: PUSH
27866: EMPTY
27867: LIST
27868: LIST
27869: PUSH
27870: LD_INT 0
27872: PUSH
27873: LD_INT 2
27875: PUSH
27876: EMPTY
27877: LIST
27878: LIST
27879: PUSH
27880: LD_INT 1
27882: NEG
27883: PUSH
27884: LD_INT 1
27886: PUSH
27887: EMPTY
27888: LIST
27889: LIST
27890: PUSH
27891: LD_INT 2
27893: NEG
27894: PUSH
27895: LD_INT 0
27897: PUSH
27898: EMPTY
27899: LIST
27900: LIST
27901: PUSH
27902: LD_INT 2
27904: NEG
27905: PUSH
27906: LD_INT 1
27908: NEG
27909: PUSH
27910: EMPTY
27911: LIST
27912: LIST
27913: PUSH
27914: LD_INT 2
27916: NEG
27917: PUSH
27918: LD_INT 2
27920: NEG
27921: PUSH
27922: EMPTY
27923: LIST
27924: LIST
27925: PUSH
27926: EMPTY
27927: LIST
27928: LIST
27929: LIST
27930: LIST
27931: LIST
27932: LIST
27933: LIST
27934: LIST
27935: LIST
27936: LIST
27937: LIST
27938: LIST
27939: LIST
27940: LIST
27941: LIST
27942: LIST
27943: LIST
27944: LIST
27945: LIST
27946: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
27947: LD_ADDR_VAR 0 23
27951: PUSH
27952: LD_INT 0
27954: PUSH
27955: LD_INT 0
27957: PUSH
27958: EMPTY
27959: LIST
27960: LIST
27961: PUSH
27962: LD_INT 0
27964: PUSH
27965: LD_INT 1
27967: NEG
27968: PUSH
27969: EMPTY
27970: LIST
27971: LIST
27972: PUSH
27973: LD_INT 1
27975: PUSH
27976: LD_INT 0
27978: PUSH
27979: EMPTY
27980: LIST
27981: LIST
27982: PUSH
27983: LD_INT 1
27985: PUSH
27986: LD_INT 1
27988: PUSH
27989: EMPTY
27990: LIST
27991: LIST
27992: PUSH
27993: LD_INT 0
27995: PUSH
27996: LD_INT 1
27998: PUSH
27999: EMPTY
28000: LIST
28001: LIST
28002: PUSH
28003: LD_INT 1
28005: NEG
28006: PUSH
28007: LD_INT 0
28009: PUSH
28010: EMPTY
28011: LIST
28012: LIST
28013: PUSH
28014: LD_INT 1
28016: NEG
28017: PUSH
28018: LD_INT 1
28020: NEG
28021: PUSH
28022: EMPTY
28023: LIST
28024: LIST
28025: PUSH
28026: LD_INT 1
28028: NEG
28029: PUSH
28030: LD_INT 2
28032: NEG
28033: PUSH
28034: EMPTY
28035: LIST
28036: LIST
28037: PUSH
28038: LD_INT 0
28040: PUSH
28041: LD_INT 2
28043: NEG
28044: PUSH
28045: EMPTY
28046: LIST
28047: LIST
28048: PUSH
28049: LD_INT 1
28051: PUSH
28052: LD_INT 1
28054: NEG
28055: PUSH
28056: EMPTY
28057: LIST
28058: LIST
28059: PUSH
28060: LD_INT 2
28062: PUSH
28063: LD_INT 0
28065: PUSH
28066: EMPTY
28067: LIST
28068: LIST
28069: PUSH
28070: LD_INT 2
28072: PUSH
28073: LD_INT 1
28075: PUSH
28076: EMPTY
28077: LIST
28078: LIST
28079: PUSH
28080: LD_INT 2
28082: PUSH
28083: LD_INT 2
28085: PUSH
28086: EMPTY
28087: LIST
28088: LIST
28089: PUSH
28090: LD_INT 1
28092: PUSH
28093: LD_INT 2
28095: PUSH
28096: EMPTY
28097: LIST
28098: LIST
28099: PUSH
28100: LD_INT 0
28102: PUSH
28103: LD_INT 2
28105: PUSH
28106: EMPTY
28107: LIST
28108: LIST
28109: PUSH
28110: LD_INT 1
28112: NEG
28113: PUSH
28114: LD_INT 1
28116: PUSH
28117: EMPTY
28118: LIST
28119: LIST
28120: PUSH
28121: LD_INT 2
28123: NEG
28124: PUSH
28125: LD_INT 0
28127: PUSH
28128: EMPTY
28129: LIST
28130: LIST
28131: PUSH
28132: LD_INT 2
28134: NEG
28135: PUSH
28136: LD_INT 1
28138: NEG
28139: PUSH
28140: EMPTY
28141: LIST
28142: LIST
28143: PUSH
28144: LD_INT 2
28146: NEG
28147: PUSH
28148: LD_INT 2
28150: NEG
28151: PUSH
28152: EMPTY
28153: LIST
28154: LIST
28155: PUSH
28156: LD_INT 2
28158: NEG
28159: PUSH
28160: LD_INT 3
28162: NEG
28163: PUSH
28164: EMPTY
28165: LIST
28166: LIST
28167: PUSH
28168: LD_INT 1
28170: NEG
28171: PUSH
28172: LD_INT 3
28174: NEG
28175: PUSH
28176: EMPTY
28177: LIST
28178: LIST
28179: PUSH
28180: LD_INT 1
28182: PUSH
28183: LD_INT 2
28185: NEG
28186: PUSH
28187: EMPTY
28188: LIST
28189: LIST
28190: PUSH
28191: LD_INT 2
28193: PUSH
28194: LD_INT 1
28196: NEG
28197: PUSH
28198: EMPTY
28199: LIST
28200: LIST
28201: PUSH
28202: EMPTY
28203: LIST
28204: LIST
28205: LIST
28206: LIST
28207: LIST
28208: LIST
28209: LIST
28210: LIST
28211: LIST
28212: LIST
28213: LIST
28214: LIST
28215: LIST
28216: LIST
28217: LIST
28218: LIST
28219: LIST
28220: LIST
28221: LIST
28222: LIST
28223: LIST
28224: LIST
28225: LIST
28226: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
28227: LD_ADDR_VAR 0 24
28231: PUSH
28232: LD_INT 0
28234: PUSH
28235: LD_INT 0
28237: PUSH
28238: EMPTY
28239: LIST
28240: LIST
28241: PUSH
28242: LD_INT 0
28244: PUSH
28245: LD_INT 1
28247: NEG
28248: PUSH
28249: EMPTY
28250: LIST
28251: LIST
28252: PUSH
28253: LD_INT 1
28255: PUSH
28256: LD_INT 0
28258: PUSH
28259: EMPTY
28260: LIST
28261: LIST
28262: PUSH
28263: LD_INT 1
28265: PUSH
28266: LD_INT 1
28268: PUSH
28269: EMPTY
28270: LIST
28271: LIST
28272: PUSH
28273: LD_INT 0
28275: PUSH
28276: LD_INT 1
28278: PUSH
28279: EMPTY
28280: LIST
28281: LIST
28282: PUSH
28283: LD_INT 1
28285: NEG
28286: PUSH
28287: LD_INT 0
28289: PUSH
28290: EMPTY
28291: LIST
28292: LIST
28293: PUSH
28294: LD_INT 1
28296: NEG
28297: PUSH
28298: LD_INT 1
28300: NEG
28301: PUSH
28302: EMPTY
28303: LIST
28304: LIST
28305: PUSH
28306: LD_INT 1
28308: NEG
28309: PUSH
28310: LD_INT 2
28312: NEG
28313: PUSH
28314: EMPTY
28315: LIST
28316: LIST
28317: PUSH
28318: LD_INT 0
28320: PUSH
28321: LD_INT 2
28323: NEG
28324: PUSH
28325: EMPTY
28326: LIST
28327: LIST
28328: PUSH
28329: LD_INT 1
28331: PUSH
28332: LD_INT 1
28334: NEG
28335: PUSH
28336: EMPTY
28337: LIST
28338: LIST
28339: PUSH
28340: LD_INT 2
28342: PUSH
28343: LD_INT 0
28345: PUSH
28346: EMPTY
28347: LIST
28348: LIST
28349: PUSH
28350: LD_INT 2
28352: PUSH
28353: LD_INT 1
28355: PUSH
28356: EMPTY
28357: LIST
28358: LIST
28359: PUSH
28360: LD_INT 2
28362: PUSH
28363: LD_INT 2
28365: PUSH
28366: EMPTY
28367: LIST
28368: LIST
28369: PUSH
28370: LD_INT 1
28372: PUSH
28373: LD_INT 2
28375: PUSH
28376: EMPTY
28377: LIST
28378: LIST
28379: PUSH
28380: LD_INT 0
28382: PUSH
28383: LD_INT 2
28385: PUSH
28386: EMPTY
28387: LIST
28388: LIST
28389: PUSH
28390: LD_INT 1
28392: NEG
28393: PUSH
28394: LD_INT 1
28396: PUSH
28397: EMPTY
28398: LIST
28399: LIST
28400: PUSH
28401: LD_INT 2
28403: NEG
28404: PUSH
28405: LD_INT 0
28407: PUSH
28408: EMPTY
28409: LIST
28410: LIST
28411: PUSH
28412: LD_INT 2
28414: NEG
28415: PUSH
28416: LD_INT 1
28418: NEG
28419: PUSH
28420: EMPTY
28421: LIST
28422: LIST
28423: PUSH
28424: LD_INT 2
28426: NEG
28427: PUSH
28428: LD_INT 2
28430: NEG
28431: PUSH
28432: EMPTY
28433: LIST
28434: LIST
28435: PUSH
28436: LD_INT 1
28438: PUSH
28439: LD_INT 2
28441: NEG
28442: PUSH
28443: EMPTY
28444: LIST
28445: LIST
28446: PUSH
28447: LD_INT 2
28449: PUSH
28450: LD_INT 1
28452: NEG
28453: PUSH
28454: EMPTY
28455: LIST
28456: LIST
28457: PUSH
28458: LD_INT 3
28460: PUSH
28461: LD_INT 1
28463: PUSH
28464: EMPTY
28465: LIST
28466: LIST
28467: PUSH
28468: LD_INT 3
28470: PUSH
28471: LD_INT 2
28473: PUSH
28474: EMPTY
28475: LIST
28476: LIST
28477: PUSH
28478: EMPTY
28479: LIST
28480: LIST
28481: LIST
28482: LIST
28483: LIST
28484: LIST
28485: LIST
28486: LIST
28487: LIST
28488: LIST
28489: LIST
28490: LIST
28491: LIST
28492: LIST
28493: LIST
28494: LIST
28495: LIST
28496: LIST
28497: LIST
28498: LIST
28499: LIST
28500: LIST
28501: LIST
28502: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
28503: LD_ADDR_VAR 0 25
28507: PUSH
28508: LD_INT 0
28510: PUSH
28511: LD_INT 0
28513: PUSH
28514: EMPTY
28515: LIST
28516: LIST
28517: PUSH
28518: LD_INT 0
28520: PUSH
28521: LD_INT 1
28523: NEG
28524: PUSH
28525: EMPTY
28526: LIST
28527: LIST
28528: PUSH
28529: LD_INT 1
28531: PUSH
28532: LD_INT 0
28534: PUSH
28535: EMPTY
28536: LIST
28537: LIST
28538: PUSH
28539: LD_INT 1
28541: PUSH
28542: LD_INT 1
28544: PUSH
28545: EMPTY
28546: LIST
28547: LIST
28548: PUSH
28549: LD_INT 0
28551: PUSH
28552: LD_INT 1
28554: PUSH
28555: EMPTY
28556: LIST
28557: LIST
28558: PUSH
28559: LD_INT 1
28561: NEG
28562: PUSH
28563: LD_INT 0
28565: PUSH
28566: EMPTY
28567: LIST
28568: LIST
28569: PUSH
28570: LD_INT 1
28572: NEG
28573: PUSH
28574: LD_INT 1
28576: NEG
28577: PUSH
28578: EMPTY
28579: LIST
28580: LIST
28581: PUSH
28582: LD_INT 1
28584: NEG
28585: PUSH
28586: LD_INT 2
28588: NEG
28589: PUSH
28590: EMPTY
28591: LIST
28592: LIST
28593: PUSH
28594: LD_INT 0
28596: PUSH
28597: LD_INT 2
28599: NEG
28600: PUSH
28601: EMPTY
28602: LIST
28603: LIST
28604: PUSH
28605: LD_INT 1
28607: PUSH
28608: LD_INT 1
28610: NEG
28611: PUSH
28612: EMPTY
28613: LIST
28614: LIST
28615: PUSH
28616: LD_INT 2
28618: PUSH
28619: LD_INT 0
28621: PUSH
28622: EMPTY
28623: LIST
28624: LIST
28625: PUSH
28626: LD_INT 2
28628: PUSH
28629: LD_INT 1
28631: PUSH
28632: EMPTY
28633: LIST
28634: LIST
28635: PUSH
28636: LD_INT 2
28638: PUSH
28639: LD_INT 2
28641: PUSH
28642: EMPTY
28643: LIST
28644: LIST
28645: PUSH
28646: LD_INT 1
28648: PUSH
28649: LD_INT 2
28651: PUSH
28652: EMPTY
28653: LIST
28654: LIST
28655: PUSH
28656: LD_INT 0
28658: PUSH
28659: LD_INT 2
28661: PUSH
28662: EMPTY
28663: LIST
28664: LIST
28665: PUSH
28666: LD_INT 1
28668: NEG
28669: PUSH
28670: LD_INT 1
28672: PUSH
28673: EMPTY
28674: LIST
28675: LIST
28676: PUSH
28677: LD_INT 2
28679: NEG
28680: PUSH
28681: LD_INT 0
28683: PUSH
28684: EMPTY
28685: LIST
28686: LIST
28687: PUSH
28688: LD_INT 2
28690: NEG
28691: PUSH
28692: LD_INT 1
28694: NEG
28695: PUSH
28696: EMPTY
28697: LIST
28698: LIST
28699: PUSH
28700: LD_INT 2
28702: NEG
28703: PUSH
28704: LD_INT 2
28706: NEG
28707: PUSH
28708: EMPTY
28709: LIST
28710: LIST
28711: PUSH
28712: LD_INT 3
28714: PUSH
28715: LD_INT 1
28717: PUSH
28718: EMPTY
28719: LIST
28720: LIST
28721: PUSH
28722: LD_INT 3
28724: PUSH
28725: LD_INT 2
28727: PUSH
28728: EMPTY
28729: LIST
28730: LIST
28731: PUSH
28732: LD_INT 2
28734: PUSH
28735: LD_INT 3
28737: PUSH
28738: EMPTY
28739: LIST
28740: LIST
28741: PUSH
28742: LD_INT 1
28744: PUSH
28745: LD_INT 3
28747: PUSH
28748: EMPTY
28749: LIST
28750: LIST
28751: PUSH
28752: EMPTY
28753: LIST
28754: LIST
28755: LIST
28756: LIST
28757: LIST
28758: LIST
28759: LIST
28760: LIST
28761: LIST
28762: LIST
28763: LIST
28764: LIST
28765: LIST
28766: LIST
28767: LIST
28768: LIST
28769: LIST
28770: LIST
28771: LIST
28772: LIST
28773: LIST
28774: LIST
28775: LIST
28776: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
28777: LD_ADDR_VAR 0 26
28781: PUSH
28782: LD_INT 0
28784: PUSH
28785: LD_INT 0
28787: PUSH
28788: EMPTY
28789: LIST
28790: LIST
28791: PUSH
28792: LD_INT 0
28794: PUSH
28795: LD_INT 1
28797: NEG
28798: PUSH
28799: EMPTY
28800: LIST
28801: LIST
28802: PUSH
28803: LD_INT 1
28805: PUSH
28806: LD_INT 0
28808: PUSH
28809: EMPTY
28810: LIST
28811: LIST
28812: PUSH
28813: LD_INT 1
28815: PUSH
28816: LD_INT 1
28818: PUSH
28819: EMPTY
28820: LIST
28821: LIST
28822: PUSH
28823: LD_INT 0
28825: PUSH
28826: LD_INT 1
28828: PUSH
28829: EMPTY
28830: LIST
28831: LIST
28832: PUSH
28833: LD_INT 1
28835: NEG
28836: PUSH
28837: LD_INT 0
28839: PUSH
28840: EMPTY
28841: LIST
28842: LIST
28843: PUSH
28844: LD_INT 1
28846: NEG
28847: PUSH
28848: LD_INT 1
28850: NEG
28851: PUSH
28852: EMPTY
28853: LIST
28854: LIST
28855: PUSH
28856: LD_INT 1
28858: NEG
28859: PUSH
28860: LD_INT 2
28862: NEG
28863: PUSH
28864: EMPTY
28865: LIST
28866: LIST
28867: PUSH
28868: LD_INT 0
28870: PUSH
28871: LD_INT 2
28873: NEG
28874: PUSH
28875: EMPTY
28876: LIST
28877: LIST
28878: PUSH
28879: LD_INT 1
28881: PUSH
28882: LD_INT 1
28884: NEG
28885: PUSH
28886: EMPTY
28887: LIST
28888: LIST
28889: PUSH
28890: LD_INT 2
28892: PUSH
28893: LD_INT 0
28895: PUSH
28896: EMPTY
28897: LIST
28898: LIST
28899: PUSH
28900: LD_INT 2
28902: PUSH
28903: LD_INT 1
28905: PUSH
28906: EMPTY
28907: LIST
28908: LIST
28909: PUSH
28910: LD_INT 2
28912: PUSH
28913: LD_INT 2
28915: PUSH
28916: EMPTY
28917: LIST
28918: LIST
28919: PUSH
28920: LD_INT 1
28922: PUSH
28923: LD_INT 2
28925: PUSH
28926: EMPTY
28927: LIST
28928: LIST
28929: PUSH
28930: LD_INT 0
28932: PUSH
28933: LD_INT 2
28935: PUSH
28936: EMPTY
28937: LIST
28938: LIST
28939: PUSH
28940: LD_INT 1
28942: NEG
28943: PUSH
28944: LD_INT 1
28946: PUSH
28947: EMPTY
28948: LIST
28949: LIST
28950: PUSH
28951: LD_INT 2
28953: NEG
28954: PUSH
28955: LD_INT 0
28957: PUSH
28958: EMPTY
28959: LIST
28960: LIST
28961: PUSH
28962: LD_INT 2
28964: NEG
28965: PUSH
28966: LD_INT 1
28968: NEG
28969: PUSH
28970: EMPTY
28971: LIST
28972: LIST
28973: PUSH
28974: LD_INT 2
28976: NEG
28977: PUSH
28978: LD_INT 2
28980: NEG
28981: PUSH
28982: EMPTY
28983: LIST
28984: LIST
28985: PUSH
28986: LD_INT 2
28988: PUSH
28989: LD_INT 3
28991: PUSH
28992: EMPTY
28993: LIST
28994: LIST
28995: PUSH
28996: LD_INT 1
28998: PUSH
28999: LD_INT 3
29001: PUSH
29002: EMPTY
29003: LIST
29004: LIST
29005: PUSH
29006: LD_INT 1
29008: NEG
29009: PUSH
29010: LD_INT 2
29012: PUSH
29013: EMPTY
29014: LIST
29015: LIST
29016: PUSH
29017: LD_INT 2
29019: NEG
29020: PUSH
29021: LD_INT 1
29023: PUSH
29024: EMPTY
29025: LIST
29026: LIST
29027: PUSH
29028: EMPTY
29029: LIST
29030: LIST
29031: LIST
29032: LIST
29033: LIST
29034: LIST
29035: LIST
29036: LIST
29037: LIST
29038: LIST
29039: LIST
29040: LIST
29041: LIST
29042: LIST
29043: LIST
29044: LIST
29045: LIST
29046: LIST
29047: LIST
29048: LIST
29049: LIST
29050: LIST
29051: LIST
29052: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
29053: LD_ADDR_VAR 0 27
29057: PUSH
29058: LD_INT 0
29060: PUSH
29061: LD_INT 0
29063: PUSH
29064: EMPTY
29065: LIST
29066: LIST
29067: PUSH
29068: LD_INT 0
29070: PUSH
29071: LD_INT 1
29073: NEG
29074: PUSH
29075: EMPTY
29076: LIST
29077: LIST
29078: PUSH
29079: LD_INT 1
29081: PUSH
29082: LD_INT 0
29084: PUSH
29085: EMPTY
29086: LIST
29087: LIST
29088: PUSH
29089: LD_INT 1
29091: PUSH
29092: LD_INT 1
29094: PUSH
29095: EMPTY
29096: LIST
29097: LIST
29098: PUSH
29099: LD_INT 0
29101: PUSH
29102: LD_INT 1
29104: PUSH
29105: EMPTY
29106: LIST
29107: LIST
29108: PUSH
29109: LD_INT 1
29111: NEG
29112: PUSH
29113: LD_INT 0
29115: PUSH
29116: EMPTY
29117: LIST
29118: LIST
29119: PUSH
29120: LD_INT 1
29122: NEG
29123: PUSH
29124: LD_INT 1
29126: NEG
29127: PUSH
29128: EMPTY
29129: LIST
29130: LIST
29131: PUSH
29132: LD_INT 1
29134: NEG
29135: PUSH
29136: LD_INT 2
29138: NEG
29139: PUSH
29140: EMPTY
29141: LIST
29142: LIST
29143: PUSH
29144: LD_INT 0
29146: PUSH
29147: LD_INT 2
29149: NEG
29150: PUSH
29151: EMPTY
29152: LIST
29153: LIST
29154: PUSH
29155: LD_INT 1
29157: PUSH
29158: LD_INT 1
29160: NEG
29161: PUSH
29162: EMPTY
29163: LIST
29164: LIST
29165: PUSH
29166: LD_INT 2
29168: PUSH
29169: LD_INT 0
29171: PUSH
29172: EMPTY
29173: LIST
29174: LIST
29175: PUSH
29176: LD_INT 2
29178: PUSH
29179: LD_INT 1
29181: PUSH
29182: EMPTY
29183: LIST
29184: LIST
29185: PUSH
29186: LD_INT 2
29188: PUSH
29189: LD_INT 2
29191: PUSH
29192: EMPTY
29193: LIST
29194: LIST
29195: PUSH
29196: LD_INT 1
29198: PUSH
29199: LD_INT 2
29201: PUSH
29202: EMPTY
29203: LIST
29204: LIST
29205: PUSH
29206: LD_INT 0
29208: PUSH
29209: LD_INT 2
29211: PUSH
29212: EMPTY
29213: LIST
29214: LIST
29215: PUSH
29216: LD_INT 1
29218: NEG
29219: PUSH
29220: LD_INT 1
29222: PUSH
29223: EMPTY
29224: LIST
29225: LIST
29226: PUSH
29227: LD_INT 2
29229: NEG
29230: PUSH
29231: LD_INT 0
29233: PUSH
29234: EMPTY
29235: LIST
29236: LIST
29237: PUSH
29238: LD_INT 2
29240: NEG
29241: PUSH
29242: LD_INT 1
29244: NEG
29245: PUSH
29246: EMPTY
29247: LIST
29248: LIST
29249: PUSH
29250: LD_INT 2
29252: NEG
29253: PUSH
29254: LD_INT 2
29256: NEG
29257: PUSH
29258: EMPTY
29259: LIST
29260: LIST
29261: PUSH
29262: LD_INT 1
29264: NEG
29265: PUSH
29266: LD_INT 2
29268: PUSH
29269: EMPTY
29270: LIST
29271: LIST
29272: PUSH
29273: LD_INT 2
29275: NEG
29276: PUSH
29277: LD_INT 1
29279: PUSH
29280: EMPTY
29281: LIST
29282: LIST
29283: PUSH
29284: LD_INT 3
29286: NEG
29287: PUSH
29288: LD_INT 1
29290: NEG
29291: PUSH
29292: EMPTY
29293: LIST
29294: LIST
29295: PUSH
29296: LD_INT 3
29298: NEG
29299: PUSH
29300: LD_INT 2
29302: NEG
29303: PUSH
29304: EMPTY
29305: LIST
29306: LIST
29307: PUSH
29308: EMPTY
29309: LIST
29310: LIST
29311: LIST
29312: LIST
29313: LIST
29314: LIST
29315: LIST
29316: LIST
29317: LIST
29318: LIST
29319: LIST
29320: LIST
29321: LIST
29322: LIST
29323: LIST
29324: LIST
29325: LIST
29326: LIST
29327: LIST
29328: LIST
29329: LIST
29330: LIST
29331: LIST
29332: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
29333: LD_ADDR_VAR 0 28
29337: PUSH
29338: LD_INT 0
29340: PUSH
29341: LD_INT 0
29343: PUSH
29344: EMPTY
29345: LIST
29346: LIST
29347: PUSH
29348: LD_INT 0
29350: PUSH
29351: LD_INT 1
29353: NEG
29354: PUSH
29355: EMPTY
29356: LIST
29357: LIST
29358: PUSH
29359: LD_INT 1
29361: PUSH
29362: LD_INT 0
29364: PUSH
29365: EMPTY
29366: LIST
29367: LIST
29368: PUSH
29369: LD_INT 1
29371: PUSH
29372: LD_INT 1
29374: PUSH
29375: EMPTY
29376: LIST
29377: LIST
29378: PUSH
29379: LD_INT 0
29381: PUSH
29382: LD_INT 1
29384: PUSH
29385: EMPTY
29386: LIST
29387: LIST
29388: PUSH
29389: LD_INT 1
29391: NEG
29392: PUSH
29393: LD_INT 0
29395: PUSH
29396: EMPTY
29397: LIST
29398: LIST
29399: PUSH
29400: LD_INT 1
29402: NEG
29403: PUSH
29404: LD_INT 1
29406: NEG
29407: PUSH
29408: EMPTY
29409: LIST
29410: LIST
29411: PUSH
29412: LD_INT 1
29414: NEG
29415: PUSH
29416: LD_INT 2
29418: NEG
29419: PUSH
29420: EMPTY
29421: LIST
29422: LIST
29423: PUSH
29424: LD_INT 0
29426: PUSH
29427: LD_INT 2
29429: NEG
29430: PUSH
29431: EMPTY
29432: LIST
29433: LIST
29434: PUSH
29435: LD_INT 1
29437: PUSH
29438: LD_INT 1
29440: NEG
29441: PUSH
29442: EMPTY
29443: LIST
29444: LIST
29445: PUSH
29446: LD_INT 2
29448: PUSH
29449: LD_INT 0
29451: PUSH
29452: EMPTY
29453: LIST
29454: LIST
29455: PUSH
29456: LD_INT 2
29458: PUSH
29459: LD_INT 1
29461: PUSH
29462: EMPTY
29463: LIST
29464: LIST
29465: PUSH
29466: LD_INT 2
29468: PUSH
29469: LD_INT 2
29471: PUSH
29472: EMPTY
29473: LIST
29474: LIST
29475: PUSH
29476: LD_INT 1
29478: PUSH
29479: LD_INT 2
29481: PUSH
29482: EMPTY
29483: LIST
29484: LIST
29485: PUSH
29486: LD_INT 0
29488: PUSH
29489: LD_INT 2
29491: PUSH
29492: EMPTY
29493: LIST
29494: LIST
29495: PUSH
29496: LD_INT 1
29498: NEG
29499: PUSH
29500: LD_INT 1
29502: PUSH
29503: EMPTY
29504: LIST
29505: LIST
29506: PUSH
29507: LD_INT 2
29509: NEG
29510: PUSH
29511: LD_INT 0
29513: PUSH
29514: EMPTY
29515: LIST
29516: LIST
29517: PUSH
29518: LD_INT 2
29520: NEG
29521: PUSH
29522: LD_INT 1
29524: NEG
29525: PUSH
29526: EMPTY
29527: LIST
29528: LIST
29529: PUSH
29530: LD_INT 2
29532: NEG
29533: PUSH
29534: LD_INT 2
29536: NEG
29537: PUSH
29538: EMPTY
29539: LIST
29540: LIST
29541: PUSH
29542: LD_INT 2
29544: NEG
29545: PUSH
29546: LD_INT 3
29548: NEG
29549: PUSH
29550: EMPTY
29551: LIST
29552: LIST
29553: PUSH
29554: LD_INT 1
29556: NEG
29557: PUSH
29558: LD_INT 3
29560: NEG
29561: PUSH
29562: EMPTY
29563: LIST
29564: LIST
29565: PUSH
29566: LD_INT 3
29568: NEG
29569: PUSH
29570: LD_INT 1
29572: NEG
29573: PUSH
29574: EMPTY
29575: LIST
29576: LIST
29577: PUSH
29578: LD_INT 3
29580: NEG
29581: PUSH
29582: LD_INT 2
29584: NEG
29585: PUSH
29586: EMPTY
29587: LIST
29588: LIST
29589: PUSH
29590: EMPTY
29591: LIST
29592: LIST
29593: LIST
29594: LIST
29595: LIST
29596: LIST
29597: LIST
29598: LIST
29599: LIST
29600: LIST
29601: LIST
29602: LIST
29603: LIST
29604: LIST
29605: LIST
29606: LIST
29607: LIST
29608: LIST
29609: LIST
29610: LIST
29611: LIST
29612: LIST
29613: LIST
29614: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
29615: LD_ADDR_VAR 0 29
29619: PUSH
29620: LD_INT 0
29622: PUSH
29623: LD_INT 0
29625: PUSH
29626: EMPTY
29627: LIST
29628: LIST
29629: PUSH
29630: LD_INT 0
29632: PUSH
29633: LD_INT 1
29635: NEG
29636: PUSH
29637: EMPTY
29638: LIST
29639: LIST
29640: PUSH
29641: LD_INT 1
29643: PUSH
29644: LD_INT 0
29646: PUSH
29647: EMPTY
29648: LIST
29649: LIST
29650: PUSH
29651: LD_INT 1
29653: PUSH
29654: LD_INT 1
29656: PUSH
29657: EMPTY
29658: LIST
29659: LIST
29660: PUSH
29661: LD_INT 0
29663: PUSH
29664: LD_INT 1
29666: PUSH
29667: EMPTY
29668: LIST
29669: LIST
29670: PUSH
29671: LD_INT 1
29673: NEG
29674: PUSH
29675: LD_INT 0
29677: PUSH
29678: EMPTY
29679: LIST
29680: LIST
29681: PUSH
29682: LD_INT 1
29684: NEG
29685: PUSH
29686: LD_INT 1
29688: NEG
29689: PUSH
29690: EMPTY
29691: LIST
29692: LIST
29693: PUSH
29694: LD_INT 1
29696: NEG
29697: PUSH
29698: LD_INT 2
29700: NEG
29701: PUSH
29702: EMPTY
29703: LIST
29704: LIST
29705: PUSH
29706: LD_INT 0
29708: PUSH
29709: LD_INT 2
29711: NEG
29712: PUSH
29713: EMPTY
29714: LIST
29715: LIST
29716: PUSH
29717: LD_INT 1
29719: PUSH
29720: LD_INT 1
29722: NEG
29723: PUSH
29724: EMPTY
29725: LIST
29726: LIST
29727: PUSH
29728: LD_INT 2
29730: PUSH
29731: LD_INT 0
29733: PUSH
29734: EMPTY
29735: LIST
29736: LIST
29737: PUSH
29738: LD_INT 2
29740: PUSH
29741: LD_INT 1
29743: PUSH
29744: EMPTY
29745: LIST
29746: LIST
29747: PUSH
29748: LD_INT 1
29750: PUSH
29751: LD_INT 2
29753: PUSH
29754: EMPTY
29755: LIST
29756: LIST
29757: PUSH
29758: LD_INT 0
29760: PUSH
29761: LD_INT 2
29763: PUSH
29764: EMPTY
29765: LIST
29766: LIST
29767: PUSH
29768: LD_INT 1
29770: NEG
29771: PUSH
29772: LD_INT 1
29774: PUSH
29775: EMPTY
29776: LIST
29777: LIST
29778: PUSH
29779: LD_INT 2
29781: NEG
29782: PUSH
29783: LD_INT 1
29785: NEG
29786: PUSH
29787: EMPTY
29788: LIST
29789: LIST
29790: PUSH
29791: LD_INT 2
29793: NEG
29794: PUSH
29795: LD_INT 2
29797: NEG
29798: PUSH
29799: EMPTY
29800: LIST
29801: LIST
29802: PUSH
29803: LD_INT 2
29805: NEG
29806: PUSH
29807: LD_INT 3
29809: NEG
29810: PUSH
29811: EMPTY
29812: LIST
29813: LIST
29814: PUSH
29815: LD_INT 2
29817: PUSH
29818: LD_INT 1
29820: NEG
29821: PUSH
29822: EMPTY
29823: LIST
29824: LIST
29825: PUSH
29826: LD_INT 3
29828: PUSH
29829: LD_INT 1
29831: PUSH
29832: EMPTY
29833: LIST
29834: LIST
29835: PUSH
29836: LD_INT 1
29838: PUSH
29839: LD_INT 3
29841: PUSH
29842: EMPTY
29843: LIST
29844: LIST
29845: PUSH
29846: LD_INT 1
29848: NEG
29849: PUSH
29850: LD_INT 2
29852: PUSH
29853: EMPTY
29854: LIST
29855: LIST
29856: PUSH
29857: LD_INT 3
29859: NEG
29860: PUSH
29861: LD_INT 2
29863: NEG
29864: PUSH
29865: EMPTY
29866: LIST
29867: LIST
29868: PUSH
29869: EMPTY
29870: LIST
29871: LIST
29872: LIST
29873: LIST
29874: LIST
29875: LIST
29876: LIST
29877: LIST
29878: LIST
29879: LIST
29880: LIST
29881: LIST
29882: LIST
29883: LIST
29884: LIST
29885: LIST
29886: LIST
29887: LIST
29888: LIST
29889: LIST
29890: LIST
29891: LIST
29892: LIST
29893: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
29894: LD_ADDR_VAR 0 30
29898: PUSH
29899: LD_INT 0
29901: PUSH
29902: LD_INT 0
29904: PUSH
29905: EMPTY
29906: LIST
29907: LIST
29908: PUSH
29909: LD_INT 0
29911: PUSH
29912: LD_INT 1
29914: NEG
29915: PUSH
29916: EMPTY
29917: LIST
29918: LIST
29919: PUSH
29920: LD_INT 1
29922: PUSH
29923: LD_INT 0
29925: PUSH
29926: EMPTY
29927: LIST
29928: LIST
29929: PUSH
29930: LD_INT 1
29932: PUSH
29933: LD_INT 1
29935: PUSH
29936: EMPTY
29937: LIST
29938: LIST
29939: PUSH
29940: LD_INT 0
29942: PUSH
29943: LD_INT 1
29945: PUSH
29946: EMPTY
29947: LIST
29948: LIST
29949: PUSH
29950: LD_INT 1
29952: NEG
29953: PUSH
29954: LD_INT 0
29956: PUSH
29957: EMPTY
29958: LIST
29959: LIST
29960: PUSH
29961: LD_INT 1
29963: NEG
29964: PUSH
29965: LD_INT 1
29967: NEG
29968: PUSH
29969: EMPTY
29970: LIST
29971: LIST
29972: PUSH
29973: LD_INT 1
29975: NEG
29976: PUSH
29977: LD_INT 2
29979: NEG
29980: PUSH
29981: EMPTY
29982: LIST
29983: LIST
29984: PUSH
29985: LD_INT 0
29987: PUSH
29988: LD_INT 2
29990: NEG
29991: PUSH
29992: EMPTY
29993: LIST
29994: LIST
29995: PUSH
29996: LD_INT 1
29998: PUSH
29999: LD_INT 1
30001: NEG
30002: PUSH
30003: EMPTY
30004: LIST
30005: LIST
30006: PUSH
30007: LD_INT 2
30009: PUSH
30010: LD_INT 0
30012: PUSH
30013: EMPTY
30014: LIST
30015: LIST
30016: PUSH
30017: LD_INT 2
30019: PUSH
30020: LD_INT 1
30022: PUSH
30023: EMPTY
30024: LIST
30025: LIST
30026: PUSH
30027: LD_INT 2
30029: PUSH
30030: LD_INT 2
30032: PUSH
30033: EMPTY
30034: LIST
30035: LIST
30036: PUSH
30037: LD_INT 1
30039: PUSH
30040: LD_INT 2
30042: PUSH
30043: EMPTY
30044: LIST
30045: LIST
30046: PUSH
30047: LD_INT 1
30049: NEG
30050: PUSH
30051: LD_INT 1
30053: PUSH
30054: EMPTY
30055: LIST
30056: LIST
30057: PUSH
30058: LD_INT 2
30060: NEG
30061: PUSH
30062: LD_INT 0
30064: PUSH
30065: EMPTY
30066: LIST
30067: LIST
30068: PUSH
30069: LD_INT 2
30071: NEG
30072: PUSH
30073: LD_INT 1
30075: NEG
30076: PUSH
30077: EMPTY
30078: LIST
30079: LIST
30080: PUSH
30081: LD_INT 1
30083: NEG
30084: PUSH
30085: LD_INT 3
30087: NEG
30088: PUSH
30089: EMPTY
30090: LIST
30091: LIST
30092: PUSH
30093: LD_INT 1
30095: PUSH
30096: LD_INT 2
30098: NEG
30099: PUSH
30100: EMPTY
30101: LIST
30102: LIST
30103: PUSH
30104: LD_INT 3
30106: PUSH
30107: LD_INT 2
30109: PUSH
30110: EMPTY
30111: LIST
30112: LIST
30113: PUSH
30114: LD_INT 2
30116: PUSH
30117: LD_INT 3
30119: PUSH
30120: EMPTY
30121: LIST
30122: LIST
30123: PUSH
30124: LD_INT 2
30126: NEG
30127: PUSH
30128: LD_INT 1
30130: PUSH
30131: EMPTY
30132: LIST
30133: LIST
30134: PUSH
30135: LD_INT 3
30137: NEG
30138: PUSH
30139: LD_INT 1
30141: NEG
30142: PUSH
30143: EMPTY
30144: LIST
30145: LIST
30146: PUSH
30147: EMPTY
30148: LIST
30149: LIST
30150: LIST
30151: LIST
30152: LIST
30153: LIST
30154: LIST
30155: LIST
30156: LIST
30157: LIST
30158: LIST
30159: LIST
30160: LIST
30161: LIST
30162: LIST
30163: LIST
30164: LIST
30165: LIST
30166: LIST
30167: LIST
30168: LIST
30169: LIST
30170: LIST
30171: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
30172: LD_ADDR_VAR 0 31
30176: PUSH
30177: LD_INT 0
30179: PUSH
30180: LD_INT 0
30182: PUSH
30183: EMPTY
30184: LIST
30185: LIST
30186: PUSH
30187: LD_INT 0
30189: PUSH
30190: LD_INT 1
30192: NEG
30193: PUSH
30194: EMPTY
30195: LIST
30196: LIST
30197: PUSH
30198: LD_INT 1
30200: PUSH
30201: LD_INT 0
30203: PUSH
30204: EMPTY
30205: LIST
30206: LIST
30207: PUSH
30208: LD_INT 1
30210: PUSH
30211: LD_INT 1
30213: PUSH
30214: EMPTY
30215: LIST
30216: LIST
30217: PUSH
30218: LD_INT 0
30220: PUSH
30221: LD_INT 1
30223: PUSH
30224: EMPTY
30225: LIST
30226: LIST
30227: PUSH
30228: LD_INT 1
30230: NEG
30231: PUSH
30232: LD_INT 0
30234: PUSH
30235: EMPTY
30236: LIST
30237: LIST
30238: PUSH
30239: LD_INT 1
30241: NEG
30242: PUSH
30243: LD_INT 1
30245: NEG
30246: PUSH
30247: EMPTY
30248: LIST
30249: LIST
30250: PUSH
30251: LD_INT 1
30253: NEG
30254: PUSH
30255: LD_INT 2
30257: NEG
30258: PUSH
30259: EMPTY
30260: LIST
30261: LIST
30262: PUSH
30263: LD_INT 1
30265: PUSH
30266: LD_INT 1
30268: NEG
30269: PUSH
30270: EMPTY
30271: LIST
30272: LIST
30273: PUSH
30274: LD_INT 2
30276: PUSH
30277: LD_INT 0
30279: PUSH
30280: EMPTY
30281: LIST
30282: LIST
30283: PUSH
30284: LD_INT 2
30286: PUSH
30287: LD_INT 1
30289: PUSH
30290: EMPTY
30291: LIST
30292: LIST
30293: PUSH
30294: LD_INT 2
30296: PUSH
30297: LD_INT 2
30299: PUSH
30300: EMPTY
30301: LIST
30302: LIST
30303: PUSH
30304: LD_INT 1
30306: PUSH
30307: LD_INT 2
30309: PUSH
30310: EMPTY
30311: LIST
30312: LIST
30313: PUSH
30314: LD_INT 0
30316: PUSH
30317: LD_INT 2
30319: PUSH
30320: EMPTY
30321: LIST
30322: LIST
30323: PUSH
30324: LD_INT 1
30326: NEG
30327: PUSH
30328: LD_INT 1
30330: PUSH
30331: EMPTY
30332: LIST
30333: LIST
30334: PUSH
30335: LD_INT 2
30337: NEG
30338: PUSH
30339: LD_INT 1
30341: NEG
30342: PUSH
30343: EMPTY
30344: LIST
30345: LIST
30346: PUSH
30347: LD_INT 2
30349: NEG
30350: PUSH
30351: LD_INT 2
30353: NEG
30354: PUSH
30355: EMPTY
30356: LIST
30357: LIST
30358: PUSH
30359: LD_INT 2
30361: NEG
30362: PUSH
30363: LD_INT 3
30365: NEG
30366: PUSH
30367: EMPTY
30368: LIST
30369: LIST
30370: PUSH
30371: LD_INT 2
30373: PUSH
30374: LD_INT 1
30376: NEG
30377: PUSH
30378: EMPTY
30379: LIST
30380: LIST
30381: PUSH
30382: LD_INT 3
30384: PUSH
30385: LD_INT 1
30387: PUSH
30388: EMPTY
30389: LIST
30390: LIST
30391: PUSH
30392: LD_INT 1
30394: PUSH
30395: LD_INT 3
30397: PUSH
30398: EMPTY
30399: LIST
30400: LIST
30401: PUSH
30402: LD_INT 1
30404: NEG
30405: PUSH
30406: LD_INT 2
30408: PUSH
30409: EMPTY
30410: LIST
30411: LIST
30412: PUSH
30413: LD_INT 3
30415: NEG
30416: PUSH
30417: LD_INT 2
30419: NEG
30420: PUSH
30421: EMPTY
30422: LIST
30423: LIST
30424: PUSH
30425: EMPTY
30426: LIST
30427: LIST
30428: LIST
30429: LIST
30430: LIST
30431: LIST
30432: LIST
30433: LIST
30434: LIST
30435: LIST
30436: LIST
30437: LIST
30438: LIST
30439: LIST
30440: LIST
30441: LIST
30442: LIST
30443: LIST
30444: LIST
30445: LIST
30446: LIST
30447: LIST
30448: LIST
30449: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
30450: LD_ADDR_VAR 0 32
30454: PUSH
30455: LD_INT 0
30457: PUSH
30458: LD_INT 0
30460: PUSH
30461: EMPTY
30462: LIST
30463: LIST
30464: PUSH
30465: LD_INT 0
30467: PUSH
30468: LD_INT 1
30470: NEG
30471: PUSH
30472: EMPTY
30473: LIST
30474: LIST
30475: PUSH
30476: LD_INT 1
30478: PUSH
30479: LD_INT 0
30481: PUSH
30482: EMPTY
30483: LIST
30484: LIST
30485: PUSH
30486: LD_INT 1
30488: PUSH
30489: LD_INT 1
30491: PUSH
30492: EMPTY
30493: LIST
30494: LIST
30495: PUSH
30496: LD_INT 0
30498: PUSH
30499: LD_INT 1
30501: PUSH
30502: EMPTY
30503: LIST
30504: LIST
30505: PUSH
30506: LD_INT 1
30508: NEG
30509: PUSH
30510: LD_INT 0
30512: PUSH
30513: EMPTY
30514: LIST
30515: LIST
30516: PUSH
30517: LD_INT 1
30519: NEG
30520: PUSH
30521: LD_INT 1
30523: NEG
30524: PUSH
30525: EMPTY
30526: LIST
30527: LIST
30528: PUSH
30529: LD_INT 1
30531: NEG
30532: PUSH
30533: LD_INT 2
30535: NEG
30536: PUSH
30537: EMPTY
30538: LIST
30539: LIST
30540: PUSH
30541: LD_INT 0
30543: PUSH
30544: LD_INT 2
30546: NEG
30547: PUSH
30548: EMPTY
30549: LIST
30550: LIST
30551: PUSH
30552: LD_INT 1
30554: PUSH
30555: LD_INT 1
30557: NEG
30558: PUSH
30559: EMPTY
30560: LIST
30561: LIST
30562: PUSH
30563: LD_INT 2
30565: PUSH
30566: LD_INT 1
30568: PUSH
30569: EMPTY
30570: LIST
30571: LIST
30572: PUSH
30573: LD_INT 2
30575: PUSH
30576: LD_INT 2
30578: PUSH
30579: EMPTY
30580: LIST
30581: LIST
30582: PUSH
30583: LD_INT 1
30585: PUSH
30586: LD_INT 2
30588: PUSH
30589: EMPTY
30590: LIST
30591: LIST
30592: PUSH
30593: LD_INT 0
30595: PUSH
30596: LD_INT 2
30598: PUSH
30599: EMPTY
30600: LIST
30601: LIST
30602: PUSH
30603: LD_INT 1
30605: NEG
30606: PUSH
30607: LD_INT 1
30609: PUSH
30610: EMPTY
30611: LIST
30612: LIST
30613: PUSH
30614: LD_INT 2
30616: NEG
30617: PUSH
30618: LD_INT 0
30620: PUSH
30621: EMPTY
30622: LIST
30623: LIST
30624: PUSH
30625: LD_INT 2
30627: NEG
30628: PUSH
30629: LD_INT 1
30631: NEG
30632: PUSH
30633: EMPTY
30634: LIST
30635: LIST
30636: PUSH
30637: LD_INT 1
30639: NEG
30640: PUSH
30641: LD_INT 3
30643: NEG
30644: PUSH
30645: EMPTY
30646: LIST
30647: LIST
30648: PUSH
30649: LD_INT 1
30651: PUSH
30652: LD_INT 2
30654: NEG
30655: PUSH
30656: EMPTY
30657: LIST
30658: LIST
30659: PUSH
30660: LD_INT 3
30662: PUSH
30663: LD_INT 2
30665: PUSH
30666: EMPTY
30667: LIST
30668: LIST
30669: PUSH
30670: LD_INT 2
30672: PUSH
30673: LD_INT 3
30675: PUSH
30676: EMPTY
30677: LIST
30678: LIST
30679: PUSH
30680: LD_INT 2
30682: NEG
30683: PUSH
30684: LD_INT 1
30686: PUSH
30687: EMPTY
30688: LIST
30689: LIST
30690: PUSH
30691: LD_INT 3
30693: NEG
30694: PUSH
30695: LD_INT 1
30697: NEG
30698: PUSH
30699: EMPTY
30700: LIST
30701: LIST
30702: PUSH
30703: EMPTY
30704: LIST
30705: LIST
30706: LIST
30707: LIST
30708: LIST
30709: LIST
30710: LIST
30711: LIST
30712: LIST
30713: LIST
30714: LIST
30715: LIST
30716: LIST
30717: LIST
30718: LIST
30719: LIST
30720: LIST
30721: LIST
30722: LIST
30723: LIST
30724: LIST
30725: LIST
30726: LIST
30727: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
30728: LD_ADDR_VAR 0 33
30732: PUSH
30733: LD_INT 0
30735: PUSH
30736: LD_INT 0
30738: PUSH
30739: EMPTY
30740: LIST
30741: LIST
30742: PUSH
30743: LD_INT 0
30745: PUSH
30746: LD_INT 1
30748: NEG
30749: PUSH
30750: EMPTY
30751: LIST
30752: LIST
30753: PUSH
30754: LD_INT 1
30756: PUSH
30757: LD_INT 0
30759: PUSH
30760: EMPTY
30761: LIST
30762: LIST
30763: PUSH
30764: LD_INT 1
30766: PUSH
30767: LD_INT 1
30769: PUSH
30770: EMPTY
30771: LIST
30772: LIST
30773: PUSH
30774: LD_INT 0
30776: PUSH
30777: LD_INT 1
30779: PUSH
30780: EMPTY
30781: LIST
30782: LIST
30783: PUSH
30784: LD_INT 1
30786: NEG
30787: PUSH
30788: LD_INT 0
30790: PUSH
30791: EMPTY
30792: LIST
30793: LIST
30794: PUSH
30795: LD_INT 1
30797: NEG
30798: PUSH
30799: LD_INT 1
30801: NEG
30802: PUSH
30803: EMPTY
30804: LIST
30805: LIST
30806: PUSH
30807: LD_INT 1
30809: NEG
30810: PUSH
30811: LD_INT 2
30813: NEG
30814: PUSH
30815: EMPTY
30816: LIST
30817: LIST
30818: PUSH
30819: LD_INT 1
30821: PUSH
30822: LD_INT 1
30824: NEG
30825: PUSH
30826: EMPTY
30827: LIST
30828: LIST
30829: PUSH
30830: LD_INT 2
30832: PUSH
30833: LD_INT 0
30835: PUSH
30836: EMPTY
30837: LIST
30838: LIST
30839: PUSH
30840: LD_INT 2
30842: PUSH
30843: LD_INT 1
30845: PUSH
30846: EMPTY
30847: LIST
30848: LIST
30849: PUSH
30850: LD_INT 1
30852: PUSH
30853: LD_INT 2
30855: PUSH
30856: EMPTY
30857: LIST
30858: LIST
30859: PUSH
30860: LD_INT 0
30862: PUSH
30863: LD_INT 2
30865: PUSH
30866: EMPTY
30867: LIST
30868: LIST
30869: PUSH
30870: LD_INT 1
30872: NEG
30873: PUSH
30874: LD_INT 1
30876: PUSH
30877: EMPTY
30878: LIST
30879: LIST
30880: PUSH
30881: LD_INT 2
30883: NEG
30884: PUSH
30885: LD_INT 0
30887: PUSH
30888: EMPTY
30889: LIST
30890: LIST
30891: PUSH
30892: LD_INT 2
30894: NEG
30895: PUSH
30896: LD_INT 1
30898: NEG
30899: PUSH
30900: EMPTY
30901: LIST
30902: LIST
30903: PUSH
30904: LD_INT 2
30906: NEG
30907: PUSH
30908: LD_INT 2
30910: NEG
30911: PUSH
30912: EMPTY
30913: LIST
30914: LIST
30915: PUSH
30916: LD_INT 2
30918: NEG
30919: PUSH
30920: LD_INT 3
30922: NEG
30923: PUSH
30924: EMPTY
30925: LIST
30926: LIST
30927: PUSH
30928: LD_INT 2
30930: PUSH
30931: LD_INT 1
30933: NEG
30934: PUSH
30935: EMPTY
30936: LIST
30937: LIST
30938: PUSH
30939: LD_INT 3
30941: PUSH
30942: LD_INT 1
30944: PUSH
30945: EMPTY
30946: LIST
30947: LIST
30948: PUSH
30949: LD_INT 1
30951: PUSH
30952: LD_INT 3
30954: PUSH
30955: EMPTY
30956: LIST
30957: LIST
30958: PUSH
30959: LD_INT 1
30961: NEG
30962: PUSH
30963: LD_INT 2
30965: PUSH
30966: EMPTY
30967: LIST
30968: LIST
30969: PUSH
30970: LD_INT 3
30972: NEG
30973: PUSH
30974: LD_INT 2
30976: NEG
30977: PUSH
30978: EMPTY
30979: LIST
30980: LIST
30981: PUSH
30982: EMPTY
30983: LIST
30984: LIST
30985: LIST
30986: LIST
30987: LIST
30988: LIST
30989: LIST
30990: LIST
30991: LIST
30992: LIST
30993: LIST
30994: LIST
30995: LIST
30996: LIST
30997: LIST
30998: LIST
30999: LIST
31000: LIST
31001: LIST
31002: LIST
31003: LIST
31004: LIST
31005: LIST
31006: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
31007: LD_ADDR_VAR 0 34
31011: PUSH
31012: LD_INT 0
31014: PUSH
31015: LD_INT 0
31017: PUSH
31018: EMPTY
31019: LIST
31020: LIST
31021: PUSH
31022: LD_INT 0
31024: PUSH
31025: LD_INT 1
31027: NEG
31028: PUSH
31029: EMPTY
31030: LIST
31031: LIST
31032: PUSH
31033: LD_INT 1
31035: PUSH
31036: LD_INT 0
31038: PUSH
31039: EMPTY
31040: LIST
31041: LIST
31042: PUSH
31043: LD_INT 1
31045: PUSH
31046: LD_INT 1
31048: PUSH
31049: EMPTY
31050: LIST
31051: LIST
31052: PUSH
31053: LD_INT 0
31055: PUSH
31056: LD_INT 1
31058: PUSH
31059: EMPTY
31060: LIST
31061: LIST
31062: PUSH
31063: LD_INT 1
31065: NEG
31066: PUSH
31067: LD_INT 0
31069: PUSH
31070: EMPTY
31071: LIST
31072: LIST
31073: PUSH
31074: LD_INT 1
31076: NEG
31077: PUSH
31078: LD_INT 1
31080: NEG
31081: PUSH
31082: EMPTY
31083: LIST
31084: LIST
31085: PUSH
31086: LD_INT 1
31088: NEG
31089: PUSH
31090: LD_INT 2
31092: NEG
31093: PUSH
31094: EMPTY
31095: LIST
31096: LIST
31097: PUSH
31098: LD_INT 0
31100: PUSH
31101: LD_INT 2
31103: NEG
31104: PUSH
31105: EMPTY
31106: LIST
31107: LIST
31108: PUSH
31109: LD_INT 1
31111: PUSH
31112: LD_INT 1
31114: NEG
31115: PUSH
31116: EMPTY
31117: LIST
31118: LIST
31119: PUSH
31120: LD_INT 2
31122: PUSH
31123: LD_INT 1
31125: PUSH
31126: EMPTY
31127: LIST
31128: LIST
31129: PUSH
31130: LD_INT 2
31132: PUSH
31133: LD_INT 2
31135: PUSH
31136: EMPTY
31137: LIST
31138: LIST
31139: PUSH
31140: LD_INT 1
31142: PUSH
31143: LD_INT 2
31145: PUSH
31146: EMPTY
31147: LIST
31148: LIST
31149: PUSH
31150: LD_INT 1
31152: NEG
31153: PUSH
31154: LD_INT 1
31156: PUSH
31157: EMPTY
31158: LIST
31159: LIST
31160: PUSH
31161: LD_INT 2
31163: NEG
31164: PUSH
31165: LD_INT 0
31167: PUSH
31168: EMPTY
31169: LIST
31170: LIST
31171: PUSH
31172: LD_INT 2
31174: NEG
31175: PUSH
31176: LD_INT 1
31178: NEG
31179: PUSH
31180: EMPTY
31181: LIST
31182: LIST
31183: PUSH
31184: LD_INT 2
31186: NEG
31187: PUSH
31188: LD_INT 2
31190: NEG
31191: PUSH
31192: EMPTY
31193: LIST
31194: LIST
31195: PUSH
31196: LD_INT 1
31198: NEG
31199: PUSH
31200: LD_INT 3
31202: NEG
31203: PUSH
31204: EMPTY
31205: LIST
31206: LIST
31207: PUSH
31208: LD_INT 1
31210: PUSH
31211: LD_INT 2
31213: NEG
31214: PUSH
31215: EMPTY
31216: LIST
31217: LIST
31218: PUSH
31219: LD_INT 3
31221: PUSH
31222: LD_INT 2
31224: PUSH
31225: EMPTY
31226: LIST
31227: LIST
31228: PUSH
31229: LD_INT 2
31231: PUSH
31232: LD_INT 3
31234: PUSH
31235: EMPTY
31236: LIST
31237: LIST
31238: PUSH
31239: LD_INT 2
31241: NEG
31242: PUSH
31243: LD_INT 1
31245: PUSH
31246: EMPTY
31247: LIST
31248: LIST
31249: PUSH
31250: LD_INT 3
31252: NEG
31253: PUSH
31254: LD_INT 1
31256: NEG
31257: PUSH
31258: EMPTY
31259: LIST
31260: LIST
31261: PUSH
31262: EMPTY
31263: LIST
31264: LIST
31265: LIST
31266: LIST
31267: LIST
31268: LIST
31269: LIST
31270: LIST
31271: LIST
31272: LIST
31273: LIST
31274: LIST
31275: LIST
31276: LIST
31277: LIST
31278: LIST
31279: LIST
31280: LIST
31281: LIST
31282: LIST
31283: LIST
31284: LIST
31285: LIST
31286: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
31287: LD_ADDR_VAR 0 35
31291: PUSH
31292: LD_INT 0
31294: PUSH
31295: LD_INT 0
31297: PUSH
31298: EMPTY
31299: LIST
31300: LIST
31301: PUSH
31302: LD_INT 0
31304: PUSH
31305: LD_INT 1
31307: NEG
31308: PUSH
31309: EMPTY
31310: LIST
31311: LIST
31312: PUSH
31313: LD_INT 1
31315: PUSH
31316: LD_INT 0
31318: PUSH
31319: EMPTY
31320: LIST
31321: LIST
31322: PUSH
31323: LD_INT 1
31325: PUSH
31326: LD_INT 1
31328: PUSH
31329: EMPTY
31330: LIST
31331: LIST
31332: PUSH
31333: LD_INT 0
31335: PUSH
31336: LD_INT 1
31338: PUSH
31339: EMPTY
31340: LIST
31341: LIST
31342: PUSH
31343: LD_INT 1
31345: NEG
31346: PUSH
31347: LD_INT 0
31349: PUSH
31350: EMPTY
31351: LIST
31352: LIST
31353: PUSH
31354: LD_INT 1
31356: NEG
31357: PUSH
31358: LD_INT 1
31360: NEG
31361: PUSH
31362: EMPTY
31363: LIST
31364: LIST
31365: PUSH
31366: LD_INT 2
31368: PUSH
31369: LD_INT 1
31371: PUSH
31372: EMPTY
31373: LIST
31374: LIST
31375: PUSH
31376: LD_INT 2
31378: NEG
31379: PUSH
31380: LD_INT 1
31382: NEG
31383: PUSH
31384: EMPTY
31385: LIST
31386: LIST
31387: PUSH
31388: EMPTY
31389: LIST
31390: LIST
31391: LIST
31392: LIST
31393: LIST
31394: LIST
31395: LIST
31396: LIST
31397: LIST
31398: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
31399: LD_ADDR_VAR 0 36
31403: PUSH
31404: LD_INT 0
31406: PUSH
31407: LD_INT 0
31409: PUSH
31410: EMPTY
31411: LIST
31412: LIST
31413: PUSH
31414: LD_INT 0
31416: PUSH
31417: LD_INT 1
31419: NEG
31420: PUSH
31421: EMPTY
31422: LIST
31423: LIST
31424: PUSH
31425: LD_INT 1
31427: PUSH
31428: LD_INT 0
31430: PUSH
31431: EMPTY
31432: LIST
31433: LIST
31434: PUSH
31435: LD_INT 1
31437: PUSH
31438: LD_INT 1
31440: PUSH
31441: EMPTY
31442: LIST
31443: LIST
31444: PUSH
31445: LD_INT 0
31447: PUSH
31448: LD_INT 1
31450: PUSH
31451: EMPTY
31452: LIST
31453: LIST
31454: PUSH
31455: LD_INT 1
31457: NEG
31458: PUSH
31459: LD_INT 0
31461: PUSH
31462: EMPTY
31463: LIST
31464: LIST
31465: PUSH
31466: LD_INT 1
31468: NEG
31469: PUSH
31470: LD_INT 1
31472: NEG
31473: PUSH
31474: EMPTY
31475: LIST
31476: LIST
31477: PUSH
31478: LD_INT 1
31480: NEG
31481: PUSH
31482: LD_INT 2
31484: NEG
31485: PUSH
31486: EMPTY
31487: LIST
31488: LIST
31489: PUSH
31490: LD_INT 1
31492: PUSH
31493: LD_INT 2
31495: PUSH
31496: EMPTY
31497: LIST
31498: LIST
31499: PUSH
31500: EMPTY
31501: LIST
31502: LIST
31503: LIST
31504: LIST
31505: LIST
31506: LIST
31507: LIST
31508: LIST
31509: LIST
31510: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
31511: LD_ADDR_VAR 0 37
31515: PUSH
31516: LD_INT 0
31518: PUSH
31519: LD_INT 0
31521: PUSH
31522: EMPTY
31523: LIST
31524: LIST
31525: PUSH
31526: LD_INT 0
31528: PUSH
31529: LD_INT 1
31531: NEG
31532: PUSH
31533: EMPTY
31534: LIST
31535: LIST
31536: PUSH
31537: LD_INT 1
31539: PUSH
31540: LD_INT 0
31542: PUSH
31543: EMPTY
31544: LIST
31545: LIST
31546: PUSH
31547: LD_INT 1
31549: PUSH
31550: LD_INT 1
31552: PUSH
31553: EMPTY
31554: LIST
31555: LIST
31556: PUSH
31557: LD_INT 0
31559: PUSH
31560: LD_INT 1
31562: PUSH
31563: EMPTY
31564: LIST
31565: LIST
31566: PUSH
31567: LD_INT 1
31569: NEG
31570: PUSH
31571: LD_INT 0
31573: PUSH
31574: EMPTY
31575: LIST
31576: LIST
31577: PUSH
31578: LD_INT 1
31580: NEG
31581: PUSH
31582: LD_INT 1
31584: NEG
31585: PUSH
31586: EMPTY
31587: LIST
31588: LIST
31589: PUSH
31590: LD_INT 1
31592: PUSH
31593: LD_INT 1
31595: NEG
31596: PUSH
31597: EMPTY
31598: LIST
31599: LIST
31600: PUSH
31601: LD_INT 1
31603: NEG
31604: PUSH
31605: LD_INT 1
31607: PUSH
31608: EMPTY
31609: LIST
31610: LIST
31611: PUSH
31612: EMPTY
31613: LIST
31614: LIST
31615: LIST
31616: LIST
31617: LIST
31618: LIST
31619: LIST
31620: LIST
31621: LIST
31622: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
31623: LD_ADDR_VAR 0 38
31627: PUSH
31628: LD_INT 0
31630: PUSH
31631: LD_INT 0
31633: PUSH
31634: EMPTY
31635: LIST
31636: LIST
31637: PUSH
31638: LD_INT 0
31640: PUSH
31641: LD_INT 1
31643: NEG
31644: PUSH
31645: EMPTY
31646: LIST
31647: LIST
31648: PUSH
31649: LD_INT 1
31651: PUSH
31652: LD_INT 0
31654: PUSH
31655: EMPTY
31656: LIST
31657: LIST
31658: PUSH
31659: LD_INT 1
31661: PUSH
31662: LD_INT 1
31664: PUSH
31665: EMPTY
31666: LIST
31667: LIST
31668: PUSH
31669: LD_INT 0
31671: PUSH
31672: LD_INT 1
31674: PUSH
31675: EMPTY
31676: LIST
31677: LIST
31678: PUSH
31679: LD_INT 1
31681: NEG
31682: PUSH
31683: LD_INT 0
31685: PUSH
31686: EMPTY
31687: LIST
31688: LIST
31689: PUSH
31690: LD_INT 1
31692: NEG
31693: PUSH
31694: LD_INT 1
31696: NEG
31697: PUSH
31698: EMPTY
31699: LIST
31700: LIST
31701: PUSH
31702: LD_INT 2
31704: PUSH
31705: LD_INT 1
31707: PUSH
31708: EMPTY
31709: LIST
31710: LIST
31711: PUSH
31712: LD_INT 2
31714: NEG
31715: PUSH
31716: LD_INT 1
31718: NEG
31719: PUSH
31720: EMPTY
31721: LIST
31722: LIST
31723: PUSH
31724: EMPTY
31725: LIST
31726: LIST
31727: LIST
31728: LIST
31729: LIST
31730: LIST
31731: LIST
31732: LIST
31733: LIST
31734: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
31735: LD_ADDR_VAR 0 39
31739: PUSH
31740: LD_INT 0
31742: PUSH
31743: LD_INT 0
31745: PUSH
31746: EMPTY
31747: LIST
31748: LIST
31749: PUSH
31750: LD_INT 0
31752: PUSH
31753: LD_INT 1
31755: NEG
31756: PUSH
31757: EMPTY
31758: LIST
31759: LIST
31760: PUSH
31761: LD_INT 1
31763: PUSH
31764: LD_INT 0
31766: PUSH
31767: EMPTY
31768: LIST
31769: LIST
31770: PUSH
31771: LD_INT 1
31773: PUSH
31774: LD_INT 1
31776: PUSH
31777: EMPTY
31778: LIST
31779: LIST
31780: PUSH
31781: LD_INT 0
31783: PUSH
31784: LD_INT 1
31786: PUSH
31787: EMPTY
31788: LIST
31789: LIST
31790: PUSH
31791: LD_INT 1
31793: NEG
31794: PUSH
31795: LD_INT 0
31797: PUSH
31798: EMPTY
31799: LIST
31800: LIST
31801: PUSH
31802: LD_INT 1
31804: NEG
31805: PUSH
31806: LD_INT 1
31808: NEG
31809: PUSH
31810: EMPTY
31811: LIST
31812: LIST
31813: PUSH
31814: LD_INT 1
31816: NEG
31817: PUSH
31818: LD_INT 2
31820: NEG
31821: PUSH
31822: EMPTY
31823: LIST
31824: LIST
31825: PUSH
31826: LD_INT 1
31828: PUSH
31829: LD_INT 2
31831: PUSH
31832: EMPTY
31833: LIST
31834: LIST
31835: PUSH
31836: EMPTY
31837: LIST
31838: LIST
31839: LIST
31840: LIST
31841: LIST
31842: LIST
31843: LIST
31844: LIST
31845: LIST
31846: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
31847: LD_ADDR_VAR 0 40
31851: PUSH
31852: LD_INT 0
31854: PUSH
31855: LD_INT 0
31857: PUSH
31858: EMPTY
31859: LIST
31860: LIST
31861: PUSH
31862: LD_INT 0
31864: PUSH
31865: LD_INT 1
31867: NEG
31868: PUSH
31869: EMPTY
31870: LIST
31871: LIST
31872: PUSH
31873: LD_INT 1
31875: PUSH
31876: LD_INT 0
31878: PUSH
31879: EMPTY
31880: LIST
31881: LIST
31882: PUSH
31883: LD_INT 1
31885: PUSH
31886: LD_INT 1
31888: PUSH
31889: EMPTY
31890: LIST
31891: LIST
31892: PUSH
31893: LD_INT 0
31895: PUSH
31896: LD_INT 1
31898: PUSH
31899: EMPTY
31900: LIST
31901: LIST
31902: PUSH
31903: LD_INT 1
31905: NEG
31906: PUSH
31907: LD_INT 0
31909: PUSH
31910: EMPTY
31911: LIST
31912: LIST
31913: PUSH
31914: LD_INT 1
31916: NEG
31917: PUSH
31918: LD_INT 1
31920: NEG
31921: PUSH
31922: EMPTY
31923: LIST
31924: LIST
31925: PUSH
31926: LD_INT 1
31928: PUSH
31929: LD_INT 1
31931: NEG
31932: PUSH
31933: EMPTY
31934: LIST
31935: LIST
31936: PUSH
31937: LD_INT 1
31939: NEG
31940: PUSH
31941: LD_INT 1
31943: PUSH
31944: EMPTY
31945: LIST
31946: LIST
31947: PUSH
31948: EMPTY
31949: LIST
31950: LIST
31951: LIST
31952: LIST
31953: LIST
31954: LIST
31955: LIST
31956: LIST
31957: LIST
31958: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31959: LD_ADDR_VAR 0 41
31963: PUSH
31964: LD_INT 0
31966: PUSH
31967: LD_INT 0
31969: PUSH
31970: EMPTY
31971: LIST
31972: LIST
31973: PUSH
31974: LD_INT 0
31976: PUSH
31977: LD_INT 1
31979: NEG
31980: PUSH
31981: EMPTY
31982: LIST
31983: LIST
31984: PUSH
31985: LD_INT 1
31987: PUSH
31988: LD_INT 0
31990: PUSH
31991: EMPTY
31992: LIST
31993: LIST
31994: PUSH
31995: LD_INT 1
31997: PUSH
31998: LD_INT 1
32000: PUSH
32001: EMPTY
32002: LIST
32003: LIST
32004: PUSH
32005: LD_INT 0
32007: PUSH
32008: LD_INT 1
32010: PUSH
32011: EMPTY
32012: LIST
32013: LIST
32014: PUSH
32015: LD_INT 1
32017: NEG
32018: PUSH
32019: LD_INT 0
32021: PUSH
32022: EMPTY
32023: LIST
32024: LIST
32025: PUSH
32026: LD_INT 1
32028: NEG
32029: PUSH
32030: LD_INT 1
32032: NEG
32033: PUSH
32034: EMPTY
32035: LIST
32036: LIST
32037: PUSH
32038: LD_INT 1
32040: NEG
32041: PUSH
32042: LD_INT 2
32044: NEG
32045: PUSH
32046: EMPTY
32047: LIST
32048: LIST
32049: PUSH
32050: LD_INT 1
32052: PUSH
32053: LD_INT 1
32055: NEG
32056: PUSH
32057: EMPTY
32058: LIST
32059: LIST
32060: PUSH
32061: LD_INT 2
32063: PUSH
32064: LD_INT 0
32066: PUSH
32067: EMPTY
32068: LIST
32069: LIST
32070: PUSH
32071: LD_INT 2
32073: PUSH
32074: LD_INT 1
32076: PUSH
32077: EMPTY
32078: LIST
32079: LIST
32080: PUSH
32081: LD_INT 2
32083: PUSH
32084: LD_INT 2
32086: PUSH
32087: EMPTY
32088: LIST
32089: LIST
32090: PUSH
32091: LD_INT 1
32093: PUSH
32094: LD_INT 2
32096: PUSH
32097: EMPTY
32098: LIST
32099: LIST
32100: PUSH
32101: LD_INT 1
32103: NEG
32104: PUSH
32105: LD_INT 1
32107: PUSH
32108: EMPTY
32109: LIST
32110: LIST
32111: PUSH
32112: LD_INT 2
32114: NEG
32115: PUSH
32116: LD_INT 0
32118: PUSH
32119: EMPTY
32120: LIST
32121: LIST
32122: PUSH
32123: LD_INT 2
32125: NEG
32126: PUSH
32127: LD_INT 1
32129: NEG
32130: PUSH
32131: EMPTY
32132: LIST
32133: LIST
32134: PUSH
32135: LD_INT 2
32137: NEG
32138: PUSH
32139: LD_INT 2
32141: NEG
32142: PUSH
32143: EMPTY
32144: LIST
32145: LIST
32146: PUSH
32147: LD_INT 2
32149: NEG
32150: PUSH
32151: LD_INT 3
32153: NEG
32154: PUSH
32155: EMPTY
32156: LIST
32157: LIST
32158: PUSH
32159: LD_INT 2
32161: PUSH
32162: LD_INT 1
32164: NEG
32165: PUSH
32166: EMPTY
32167: LIST
32168: LIST
32169: PUSH
32170: LD_INT 3
32172: PUSH
32173: LD_INT 0
32175: PUSH
32176: EMPTY
32177: LIST
32178: LIST
32179: PUSH
32180: LD_INT 3
32182: PUSH
32183: LD_INT 1
32185: PUSH
32186: EMPTY
32187: LIST
32188: LIST
32189: PUSH
32190: LD_INT 3
32192: PUSH
32193: LD_INT 2
32195: PUSH
32196: EMPTY
32197: LIST
32198: LIST
32199: PUSH
32200: LD_INT 3
32202: PUSH
32203: LD_INT 3
32205: PUSH
32206: EMPTY
32207: LIST
32208: LIST
32209: PUSH
32210: LD_INT 2
32212: PUSH
32213: LD_INT 3
32215: PUSH
32216: EMPTY
32217: LIST
32218: LIST
32219: PUSH
32220: LD_INT 2
32222: NEG
32223: PUSH
32224: LD_INT 1
32226: PUSH
32227: EMPTY
32228: LIST
32229: LIST
32230: PUSH
32231: LD_INT 3
32233: NEG
32234: PUSH
32235: LD_INT 0
32237: PUSH
32238: EMPTY
32239: LIST
32240: LIST
32241: PUSH
32242: LD_INT 3
32244: NEG
32245: PUSH
32246: LD_INT 1
32248: NEG
32249: PUSH
32250: EMPTY
32251: LIST
32252: LIST
32253: PUSH
32254: LD_INT 3
32256: NEG
32257: PUSH
32258: LD_INT 2
32260: NEG
32261: PUSH
32262: EMPTY
32263: LIST
32264: LIST
32265: PUSH
32266: LD_INT 3
32268: NEG
32269: PUSH
32270: LD_INT 3
32272: NEG
32273: PUSH
32274: EMPTY
32275: LIST
32276: LIST
32277: PUSH
32278: EMPTY
32279: LIST
32280: LIST
32281: LIST
32282: LIST
32283: LIST
32284: LIST
32285: LIST
32286: LIST
32287: LIST
32288: LIST
32289: LIST
32290: LIST
32291: LIST
32292: LIST
32293: LIST
32294: LIST
32295: LIST
32296: LIST
32297: LIST
32298: LIST
32299: LIST
32300: LIST
32301: LIST
32302: LIST
32303: LIST
32304: LIST
32305: LIST
32306: LIST
32307: LIST
32308: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32309: LD_ADDR_VAR 0 42
32313: PUSH
32314: LD_INT 0
32316: PUSH
32317: LD_INT 0
32319: PUSH
32320: EMPTY
32321: LIST
32322: LIST
32323: PUSH
32324: LD_INT 0
32326: PUSH
32327: LD_INT 1
32329: NEG
32330: PUSH
32331: EMPTY
32332: LIST
32333: LIST
32334: PUSH
32335: LD_INT 1
32337: PUSH
32338: LD_INT 0
32340: PUSH
32341: EMPTY
32342: LIST
32343: LIST
32344: PUSH
32345: LD_INT 1
32347: PUSH
32348: LD_INT 1
32350: PUSH
32351: EMPTY
32352: LIST
32353: LIST
32354: PUSH
32355: LD_INT 0
32357: PUSH
32358: LD_INT 1
32360: PUSH
32361: EMPTY
32362: LIST
32363: LIST
32364: PUSH
32365: LD_INT 1
32367: NEG
32368: PUSH
32369: LD_INT 0
32371: PUSH
32372: EMPTY
32373: LIST
32374: LIST
32375: PUSH
32376: LD_INT 1
32378: NEG
32379: PUSH
32380: LD_INT 1
32382: NEG
32383: PUSH
32384: EMPTY
32385: LIST
32386: LIST
32387: PUSH
32388: LD_INT 1
32390: NEG
32391: PUSH
32392: LD_INT 2
32394: NEG
32395: PUSH
32396: EMPTY
32397: LIST
32398: LIST
32399: PUSH
32400: LD_INT 0
32402: PUSH
32403: LD_INT 2
32405: NEG
32406: PUSH
32407: EMPTY
32408: LIST
32409: LIST
32410: PUSH
32411: LD_INT 1
32413: PUSH
32414: LD_INT 1
32416: NEG
32417: PUSH
32418: EMPTY
32419: LIST
32420: LIST
32421: PUSH
32422: LD_INT 2
32424: PUSH
32425: LD_INT 1
32427: PUSH
32428: EMPTY
32429: LIST
32430: LIST
32431: PUSH
32432: LD_INT 2
32434: PUSH
32435: LD_INT 2
32437: PUSH
32438: EMPTY
32439: LIST
32440: LIST
32441: PUSH
32442: LD_INT 1
32444: PUSH
32445: LD_INT 2
32447: PUSH
32448: EMPTY
32449: LIST
32450: LIST
32451: PUSH
32452: LD_INT 0
32454: PUSH
32455: LD_INT 2
32457: PUSH
32458: EMPTY
32459: LIST
32460: LIST
32461: PUSH
32462: LD_INT 1
32464: NEG
32465: PUSH
32466: LD_INT 1
32468: PUSH
32469: EMPTY
32470: LIST
32471: LIST
32472: PUSH
32473: LD_INT 2
32475: NEG
32476: PUSH
32477: LD_INT 1
32479: NEG
32480: PUSH
32481: EMPTY
32482: LIST
32483: LIST
32484: PUSH
32485: LD_INT 2
32487: NEG
32488: PUSH
32489: LD_INT 2
32491: NEG
32492: PUSH
32493: EMPTY
32494: LIST
32495: LIST
32496: PUSH
32497: LD_INT 2
32499: NEG
32500: PUSH
32501: LD_INT 3
32503: NEG
32504: PUSH
32505: EMPTY
32506: LIST
32507: LIST
32508: PUSH
32509: LD_INT 1
32511: NEG
32512: PUSH
32513: LD_INT 3
32515: NEG
32516: PUSH
32517: EMPTY
32518: LIST
32519: LIST
32520: PUSH
32521: LD_INT 0
32523: PUSH
32524: LD_INT 3
32526: NEG
32527: PUSH
32528: EMPTY
32529: LIST
32530: LIST
32531: PUSH
32532: LD_INT 1
32534: PUSH
32535: LD_INT 2
32537: NEG
32538: PUSH
32539: EMPTY
32540: LIST
32541: LIST
32542: PUSH
32543: LD_INT 3
32545: PUSH
32546: LD_INT 2
32548: PUSH
32549: EMPTY
32550: LIST
32551: LIST
32552: PUSH
32553: LD_INT 3
32555: PUSH
32556: LD_INT 3
32558: PUSH
32559: EMPTY
32560: LIST
32561: LIST
32562: PUSH
32563: LD_INT 2
32565: PUSH
32566: LD_INT 3
32568: PUSH
32569: EMPTY
32570: LIST
32571: LIST
32572: PUSH
32573: LD_INT 1
32575: PUSH
32576: LD_INT 3
32578: PUSH
32579: EMPTY
32580: LIST
32581: LIST
32582: PUSH
32583: LD_INT 0
32585: PUSH
32586: LD_INT 3
32588: PUSH
32589: EMPTY
32590: LIST
32591: LIST
32592: PUSH
32593: LD_INT 1
32595: NEG
32596: PUSH
32597: LD_INT 2
32599: PUSH
32600: EMPTY
32601: LIST
32602: LIST
32603: PUSH
32604: LD_INT 3
32606: NEG
32607: PUSH
32608: LD_INT 2
32610: NEG
32611: PUSH
32612: EMPTY
32613: LIST
32614: LIST
32615: PUSH
32616: LD_INT 3
32618: NEG
32619: PUSH
32620: LD_INT 3
32622: NEG
32623: PUSH
32624: EMPTY
32625: LIST
32626: LIST
32627: PUSH
32628: EMPTY
32629: LIST
32630: LIST
32631: LIST
32632: LIST
32633: LIST
32634: LIST
32635: LIST
32636: LIST
32637: LIST
32638: LIST
32639: LIST
32640: LIST
32641: LIST
32642: LIST
32643: LIST
32644: LIST
32645: LIST
32646: LIST
32647: LIST
32648: LIST
32649: LIST
32650: LIST
32651: LIST
32652: LIST
32653: LIST
32654: LIST
32655: LIST
32656: LIST
32657: LIST
32658: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
32659: LD_ADDR_VAR 0 43
32663: PUSH
32664: LD_INT 0
32666: PUSH
32667: LD_INT 0
32669: PUSH
32670: EMPTY
32671: LIST
32672: LIST
32673: PUSH
32674: LD_INT 0
32676: PUSH
32677: LD_INT 1
32679: NEG
32680: PUSH
32681: EMPTY
32682: LIST
32683: LIST
32684: PUSH
32685: LD_INT 1
32687: PUSH
32688: LD_INT 0
32690: PUSH
32691: EMPTY
32692: LIST
32693: LIST
32694: PUSH
32695: LD_INT 1
32697: PUSH
32698: LD_INT 1
32700: PUSH
32701: EMPTY
32702: LIST
32703: LIST
32704: PUSH
32705: LD_INT 0
32707: PUSH
32708: LD_INT 1
32710: PUSH
32711: EMPTY
32712: LIST
32713: LIST
32714: PUSH
32715: LD_INT 1
32717: NEG
32718: PUSH
32719: LD_INT 0
32721: PUSH
32722: EMPTY
32723: LIST
32724: LIST
32725: PUSH
32726: LD_INT 1
32728: NEG
32729: PUSH
32730: LD_INT 1
32732: NEG
32733: PUSH
32734: EMPTY
32735: LIST
32736: LIST
32737: PUSH
32738: LD_INT 1
32740: NEG
32741: PUSH
32742: LD_INT 2
32744: NEG
32745: PUSH
32746: EMPTY
32747: LIST
32748: LIST
32749: PUSH
32750: LD_INT 0
32752: PUSH
32753: LD_INT 2
32755: NEG
32756: PUSH
32757: EMPTY
32758: LIST
32759: LIST
32760: PUSH
32761: LD_INT 1
32763: PUSH
32764: LD_INT 1
32766: NEG
32767: PUSH
32768: EMPTY
32769: LIST
32770: LIST
32771: PUSH
32772: LD_INT 2
32774: PUSH
32775: LD_INT 0
32777: PUSH
32778: EMPTY
32779: LIST
32780: LIST
32781: PUSH
32782: LD_INT 2
32784: PUSH
32785: LD_INT 1
32787: PUSH
32788: EMPTY
32789: LIST
32790: LIST
32791: PUSH
32792: LD_INT 1
32794: PUSH
32795: LD_INT 2
32797: PUSH
32798: EMPTY
32799: LIST
32800: LIST
32801: PUSH
32802: LD_INT 0
32804: PUSH
32805: LD_INT 2
32807: PUSH
32808: EMPTY
32809: LIST
32810: LIST
32811: PUSH
32812: LD_INT 1
32814: NEG
32815: PUSH
32816: LD_INT 1
32818: PUSH
32819: EMPTY
32820: LIST
32821: LIST
32822: PUSH
32823: LD_INT 2
32825: NEG
32826: PUSH
32827: LD_INT 0
32829: PUSH
32830: EMPTY
32831: LIST
32832: LIST
32833: PUSH
32834: LD_INT 2
32836: NEG
32837: PUSH
32838: LD_INT 1
32840: NEG
32841: PUSH
32842: EMPTY
32843: LIST
32844: LIST
32845: PUSH
32846: LD_INT 1
32848: NEG
32849: PUSH
32850: LD_INT 3
32852: NEG
32853: PUSH
32854: EMPTY
32855: LIST
32856: LIST
32857: PUSH
32858: LD_INT 0
32860: PUSH
32861: LD_INT 3
32863: NEG
32864: PUSH
32865: EMPTY
32866: LIST
32867: LIST
32868: PUSH
32869: LD_INT 1
32871: PUSH
32872: LD_INT 2
32874: NEG
32875: PUSH
32876: EMPTY
32877: LIST
32878: LIST
32879: PUSH
32880: LD_INT 2
32882: PUSH
32883: LD_INT 1
32885: NEG
32886: PUSH
32887: EMPTY
32888: LIST
32889: LIST
32890: PUSH
32891: LD_INT 3
32893: PUSH
32894: LD_INT 0
32896: PUSH
32897: EMPTY
32898: LIST
32899: LIST
32900: PUSH
32901: LD_INT 3
32903: PUSH
32904: LD_INT 1
32906: PUSH
32907: EMPTY
32908: LIST
32909: LIST
32910: PUSH
32911: LD_INT 1
32913: PUSH
32914: LD_INT 3
32916: PUSH
32917: EMPTY
32918: LIST
32919: LIST
32920: PUSH
32921: LD_INT 0
32923: PUSH
32924: LD_INT 3
32926: PUSH
32927: EMPTY
32928: LIST
32929: LIST
32930: PUSH
32931: LD_INT 1
32933: NEG
32934: PUSH
32935: LD_INT 2
32937: PUSH
32938: EMPTY
32939: LIST
32940: LIST
32941: PUSH
32942: LD_INT 2
32944: NEG
32945: PUSH
32946: LD_INT 1
32948: PUSH
32949: EMPTY
32950: LIST
32951: LIST
32952: PUSH
32953: LD_INT 3
32955: NEG
32956: PUSH
32957: LD_INT 0
32959: PUSH
32960: EMPTY
32961: LIST
32962: LIST
32963: PUSH
32964: LD_INT 3
32966: NEG
32967: PUSH
32968: LD_INT 1
32970: NEG
32971: PUSH
32972: EMPTY
32973: LIST
32974: LIST
32975: PUSH
32976: EMPTY
32977: LIST
32978: LIST
32979: LIST
32980: LIST
32981: LIST
32982: LIST
32983: LIST
32984: LIST
32985: LIST
32986: LIST
32987: LIST
32988: LIST
32989: LIST
32990: LIST
32991: LIST
32992: LIST
32993: LIST
32994: LIST
32995: LIST
32996: LIST
32997: LIST
32998: LIST
32999: LIST
33000: LIST
33001: LIST
33002: LIST
33003: LIST
33004: LIST
33005: LIST
33006: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33007: LD_ADDR_VAR 0 44
33011: PUSH
33012: LD_INT 0
33014: PUSH
33015: LD_INT 0
33017: PUSH
33018: EMPTY
33019: LIST
33020: LIST
33021: PUSH
33022: LD_INT 0
33024: PUSH
33025: LD_INT 1
33027: NEG
33028: PUSH
33029: EMPTY
33030: LIST
33031: LIST
33032: PUSH
33033: LD_INT 1
33035: PUSH
33036: LD_INT 0
33038: PUSH
33039: EMPTY
33040: LIST
33041: LIST
33042: PUSH
33043: LD_INT 1
33045: PUSH
33046: LD_INT 1
33048: PUSH
33049: EMPTY
33050: LIST
33051: LIST
33052: PUSH
33053: LD_INT 0
33055: PUSH
33056: LD_INT 1
33058: PUSH
33059: EMPTY
33060: LIST
33061: LIST
33062: PUSH
33063: LD_INT 1
33065: NEG
33066: PUSH
33067: LD_INT 0
33069: PUSH
33070: EMPTY
33071: LIST
33072: LIST
33073: PUSH
33074: LD_INT 1
33076: NEG
33077: PUSH
33078: LD_INT 1
33080: NEG
33081: PUSH
33082: EMPTY
33083: LIST
33084: LIST
33085: PUSH
33086: LD_INT 1
33088: NEG
33089: PUSH
33090: LD_INT 2
33092: NEG
33093: PUSH
33094: EMPTY
33095: LIST
33096: LIST
33097: PUSH
33098: LD_INT 1
33100: PUSH
33101: LD_INT 1
33103: NEG
33104: PUSH
33105: EMPTY
33106: LIST
33107: LIST
33108: PUSH
33109: LD_INT 2
33111: PUSH
33112: LD_INT 0
33114: PUSH
33115: EMPTY
33116: LIST
33117: LIST
33118: PUSH
33119: LD_INT 2
33121: PUSH
33122: LD_INT 1
33124: PUSH
33125: EMPTY
33126: LIST
33127: LIST
33128: PUSH
33129: LD_INT 2
33131: PUSH
33132: LD_INT 2
33134: PUSH
33135: EMPTY
33136: LIST
33137: LIST
33138: PUSH
33139: LD_INT 1
33141: PUSH
33142: LD_INT 2
33144: PUSH
33145: EMPTY
33146: LIST
33147: LIST
33148: PUSH
33149: LD_INT 1
33151: NEG
33152: PUSH
33153: LD_INT 1
33155: PUSH
33156: EMPTY
33157: LIST
33158: LIST
33159: PUSH
33160: LD_INT 2
33162: NEG
33163: PUSH
33164: LD_INT 0
33166: PUSH
33167: EMPTY
33168: LIST
33169: LIST
33170: PUSH
33171: LD_INT 2
33173: NEG
33174: PUSH
33175: LD_INT 1
33177: NEG
33178: PUSH
33179: EMPTY
33180: LIST
33181: LIST
33182: PUSH
33183: LD_INT 2
33185: NEG
33186: PUSH
33187: LD_INT 2
33189: NEG
33190: PUSH
33191: EMPTY
33192: LIST
33193: LIST
33194: PUSH
33195: LD_INT 2
33197: NEG
33198: PUSH
33199: LD_INT 3
33201: NEG
33202: PUSH
33203: EMPTY
33204: LIST
33205: LIST
33206: PUSH
33207: LD_INT 2
33209: PUSH
33210: LD_INT 1
33212: NEG
33213: PUSH
33214: EMPTY
33215: LIST
33216: LIST
33217: PUSH
33218: LD_INT 3
33220: PUSH
33221: LD_INT 0
33223: PUSH
33224: EMPTY
33225: LIST
33226: LIST
33227: PUSH
33228: LD_INT 3
33230: PUSH
33231: LD_INT 1
33233: PUSH
33234: EMPTY
33235: LIST
33236: LIST
33237: PUSH
33238: LD_INT 3
33240: PUSH
33241: LD_INT 2
33243: PUSH
33244: EMPTY
33245: LIST
33246: LIST
33247: PUSH
33248: LD_INT 3
33250: PUSH
33251: LD_INT 3
33253: PUSH
33254: EMPTY
33255: LIST
33256: LIST
33257: PUSH
33258: LD_INT 2
33260: PUSH
33261: LD_INT 3
33263: PUSH
33264: EMPTY
33265: LIST
33266: LIST
33267: PUSH
33268: LD_INT 2
33270: NEG
33271: PUSH
33272: LD_INT 1
33274: PUSH
33275: EMPTY
33276: LIST
33277: LIST
33278: PUSH
33279: LD_INT 3
33281: NEG
33282: PUSH
33283: LD_INT 0
33285: PUSH
33286: EMPTY
33287: LIST
33288: LIST
33289: PUSH
33290: LD_INT 3
33292: NEG
33293: PUSH
33294: LD_INT 1
33296: NEG
33297: PUSH
33298: EMPTY
33299: LIST
33300: LIST
33301: PUSH
33302: LD_INT 3
33304: NEG
33305: PUSH
33306: LD_INT 2
33308: NEG
33309: PUSH
33310: EMPTY
33311: LIST
33312: LIST
33313: PUSH
33314: LD_INT 3
33316: NEG
33317: PUSH
33318: LD_INT 3
33320: NEG
33321: PUSH
33322: EMPTY
33323: LIST
33324: LIST
33325: PUSH
33326: EMPTY
33327: LIST
33328: LIST
33329: LIST
33330: LIST
33331: LIST
33332: LIST
33333: LIST
33334: LIST
33335: LIST
33336: LIST
33337: LIST
33338: LIST
33339: LIST
33340: LIST
33341: LIST
33342: LIST
33343: LIST
33344: LIST
33345: LIST
33346: LIST
33347: LIST
33348: LIST
33349: LIST
33350: LIST
33351: LIST
33352: LIST
33353: LIST
33354: LIST
33355: LIST
33356: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33357: LD_ADDR_VAR 0 45
33361: PUSH
33362: LD_INT 0
33364: PUSH
33365: LD_INT 0
33367: PUSH
33368: EMPTY
33369: LIST
33370: LIST
33371: PUSH
33372: LD_INT 0
33374: PUSH
33375: LD_INT 1
33377: NEG
33378: PUSH
33379: EMPTY
33380: LIST
33381: LIST
33382: PUSH
33383: LD_INT 1
33385: PUSH
33386: LD_INT 0
33388: PUSH
33389: EMPTY
33390: LIST
33391: LIST
33392: PUSH
33393: LD_INT 1
33395: PUSH
33396: LD_INT 1
33398: PUSH
33399: EMPTY
33400: LIST
33401: LIST
33402: PUSH
33403: LD_INT 0
33405: PUSH
33406: LD_INT 1
33408: PUSH
33409: EMPTY
33410: LIST
33411: LIST
33412: PUSH
33413: LD_INT 1
33415: NEG
33416: PUSH
33417: LD_INT 0
33419: PUSH
33420: EMPTY
33421: LIST
33422: LIST
33423: PUSH
33424: LD_INT 1
33426: NEG
33427: PUSH
33428: LD_INT 1
33430: NEG
33431: PUSH
33432: EMPTY
33433: LIST
33434: LIST
33435: PUSH
33436: LD_INT 1
33438: NEG
33439: PUSH
33440: LD_INT 2
33442: NEG
33443: PUSH
33444: EMPTY
33445: LIST
33446: LIST
33447: PUSH
33448: LD_INT 0
33450: PUSH
33451: LD_INT 2
33453: NEG
33454: PUSH
33455: EMPTY
33456: LIST
33457: LIST
33458: PUSH
33459: LD_INT 1
33461: PUSH
33462: LD_INT 1
33464: NEG
33465: PUSH
33466: EMPTY
33467: LIST
33468: LIST
33469: PUSH
33470: LD_INT 2
33472: PUSH
33473: LD_INT 1
33475: PUSH
33476: EMPTY
33477: LIST
33478: LIST
33479: PUSH
33480: LD_INT 2
33482: PUSH
33483: LD_INT 2
33485: PUSH
33486: EMPTY
33487: LIST
33488: LIST
33489: PUSH
33490: LD_INT 1
33492: PUSH
33493: LD_INT 2
33495: PUSH
33496: EMPTY
33497: LIST
33498: LIST
33499: PUSH
33500: LD_INT 0
33502: PUSH
33503: LD_INT 2
33505: PUSH
33506: EMPTY
33507: LIST
33508: LIST
33509: PUSH
33510: LD_INT 1
33512: NEG
33513: PUSH
33514: LD_INT 1
33516: PUSH
33517: EMPTY
33518: LIST
33519: LIST
33520: PUSH
33521: LD_INT 2
33523: NEG
33524: PUSH
33525: LD_INT 1
33527: NEG
33528: PUSH
33529: EMPTY
33530: LIST
33531: LIST
33532: PUSH
33533: LD_INT 2
33535: NEG
33536: PUSH
33537: LD_INT 2
33539: NEG
33540: PUSH
33541: EMPTY
33542: LIST
33543: LIST
33544: PUSH
33545: LD_INT 2
33547: NEG
33548: PUSH
33549: LD_INT 3
33551: NEG
33552: PUSH
33553: EMPTY
33554: LIST
33555: LIST
33556: PUSH
33557: LD_INT 1
33559: NEG
33560: PUSH
33561: LD_INT 3
33563: NEG
33564: PUSH
33565: EMPTY
33566: LIST
33567: LIST
33568: PUSH
33569: LD_INT 0
33571: PUSH
33572: LD_INT 3
33574: NEG
33575: PUSH
33576: EMPTY
33577: LIST
33578: LIST
33579: PUSH
33580: LD_INT 1
33582: PUSH
33583: LD_INT 2
33585: NEG
33586: PUSH
33587: EMPTY
33588: LIST
33589: LIST
33590: PUSH
33591: LD_INT 3
33593: PUSH
33594: LD_INT 2
33596: PUSH
33597: EMPTY
33598: LIST
33599: LIST
33600: PUSH
33601: LD_INT 3
33603: PUSH
33604: LD_INT 3
33606: PUSH
33607: EMPTY
33608: LIST
33609: LIST
33610: PUSH
33611: LD_INT 2
33613: PUSH
33614: LD_INT 3
33616: PUSH
33617: EMPTY
33618: LIST
33619: LIST
33620: PUSH
33621: LD_INT 1
33623: PUSH
33624: LD_INT 3
33626: PUSH
33627: EMPTY
33628: LIST
33629: LIST
33630: PUSH
33631: LD_INT 0
33633: PUSH
33634: LD_INT 3
33636: PUSH
33637: EMPTY
33638: LIST
33639: LIST
33640: PUSH
33641: LD_INT 1
33643: NEG
33644: PUSH
33645: LD_INT 2
33647: PUSH
33648: EMPTY
33649: LIST
33650: LIST
33651: PUSH
33652: LD_INT 3
33654: NEG
33655: PUSH
33656: LD_INT 2
33658: NEG
33659: PUSH
33660: EMPTY
33661: LIST
33662: LIST
33663: PUSH
33664: LD_INT 3
33666: NEG
33667: PUSH
33668: LD_INT 3
33670: NEG
33671: PUSH
33672: EMPTY
33673: LIST
33674: LIST
33675: PUSH
33676: EMPTY
33677: LIST
33678: LIST
33679: LIST
33680: LIST
33681: LIST
33682: LIST
33683: LIST
33684: LIST
33685: LIST
33686: LIST
33687: LIST
33688: LIST
33689: LIST
33690: LIST
33691: LIST
33692: LIST
33693: LIST
33694: LIST
33695: LIST
33696: LIST
33697: LIST
33698: LIST
33699: LIST
33700: LIST
33701: LIST
33702: LIST
33703: LIST
33704: LIST
33705: LIST
33706: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
33707: LD_ADDR_VAR 0 46
33711: PUSH
33712: LD_INT 0
33714: PUSH
33715: LD_INT 0
33717: PUSH
33718: EMPTY
33719: LIST
33720: LIST
33721: PUSH
33722: LD_INT 0
33724: PUSH
33725: LD_INT 1
33727: NEG
33728: PUSH
33729: EMPTY
33730: LIST
33731: LIST
33732: PUSH
33733: LD_INT 1
33735: PUSH
33736: LD_INT 0
33738: PUSH
33739: EMPTY
33740: LIST
33741: LIST
33742: PUSH
33743: LD_INT 1
33745: PUSH
33746: LD_INT 1
33748: PUSH
33749: EMPTY
33750: LIST
33751: LIST
33752: PUSH
33753: LD_INT 0
33755: PUSH
33756: LD_INT 1
33758: PUSH
33759: EMPTY
33760: LIST
33761: LIST
33762: PUSH
33763: LD_INT 1
33765: NEG
33766: PUSH
33767: LD_INT 0
33769: PUSH
33770: EMPTY
33771: LIST
33772: LIST
33773: PUSH
33774: LD_INT 1
33776: NEG
33777: PUSH
33778: LD_INT 1
33780: NEG
33781: PUSH
33782: EMPTY
33783: LIST
33784: LIST
33785: PUSH
33786: LD_INT 1
33788: NEG
33789: PUSH
33790: LD_INT 2
33792: NEG
33793: PUSH
33794: EMPTY
33795: LIST
33796: LIST
33797: PUSH
33798: LD_INT 0
33800: PUSH
33801: LD_INT 2
33803: NEG
33804: PUSH
33805: EMPTY
33806: LIST
33807: LIST
33808: PUSH
33809: LD_INT 1
33811: PUSH
33812: LD_INT 1
33814: NEG
33815: PUSH
33816: EMPTY
33817: LIST
33818: LIST
33819: PUSH
33820: LD_INT 2
33822: PUSH
33823: LD_INT 0
33825: PUSH
33826: EMPTY
33827: LIST
33828: LIST
33829: PUSH
33830: LD_INT 2
33832: PUSH
33833: LD_INT 1
33835: PUSH
33836: EMPTY
33837: LIST
33838: LIST
33839: PUSH
33840: LD_INT 1
33842: PUSH
33843: LD_INT 2
33845: PUSH
33846: EMPTY
33847: LIST
33848: LIST
33849: PUSH
33850: LD_INT 0
33852: PUSH
33853: LD_INT 2
33855: PUSH
33856: EMPTY
33857: LIST
33858: LIST
33859: PUSH
33860: LD_INT 1
33862: NEG
33863: PUSH
33864: LD_INT 1
33866: PUSH
33867: EMPTY
33868: LIST
33869: LIST
33870: PUSH
33871: LD_INT 2
33873: NEG
33874: PUSH
33875: LD_INT 0
33877: PUSH
33878: EMPTY
33879: LIST
33880: LIST
33881: PUSH
33882: LD_INT 2
33884: NEG
33885: PUSH
33886: LD_INT 1
33888: NEG
33889: PUSH
33890: EMPTY
33891: LIST
33892: LIST
33893: PUSH
33894: LD_INT 1
33896: NEG
33897: PUSH
33898: LD_INT 3
33900: NEG
33901: PUSH
33902: EMPTY
33903: LIST
33904: LIST
33905: PUSH
33906: LD_INT 0
33908: PUSH
33909: LD_INT 3
33911: NEG
33912: PUSH
33913: EMPTY
33914: LIST
33915: LIST
33916: PUSH
33917: LD_INT 1
33919: PUSH
33920: LD_INT 2
33922: NEG
33923: PUSH
33924: EMPTY
33925: LIST
33926: LIST
33927: PUSH
33928: LD_INT 2
33930: PUSH
33931: LD_INT 1
33933: NEG
33934: PUSH
33935: EMPTY
33936: LIST
33937: LIST
33938: PUSH
33939: LD_INT 3
33941: PUSH
33942: LD_INT 0
33944: PUSH
33945: EMPTY
33946: LIST
33947: LIST
33948: PUSH
33949: LD_INT 3
33951: PUSH
33952: LD_INT 1
33954: PUSH
33955: EMPTY
33956: LIST
33957: LIST
33958: PUSH
33959: LD_INT 1
33961: PUSH
33962: LD_INT 3
33964: PUSH
33965: EMPTY
33966: LIST
33967: LIST
33968: PUSH
33969: LD_INT 0
33971: PUSH
33972: LD_INT 3
33974: PUSH
33975: EMPTY
33976: LIST
33977: LIST
33978: PUSH
33979: LD_INT 1
33981: NEG
33982: PUSH
33983: LD_INT 2
33985: PUSH
33986: EMPTY
33987: LIST
33988: LIST
33989: PUSH
33990: LD_INT 2
33992: NEG
33993: PUSH
33994: LD_INT 1
33996: PUSH
33997: EMPTY
33998: LIST
33999: LIST
34000: PUSH
34001: LD_INT 3
34003: NEG
34004: PUSH
34005: LD_INT 0
34007: PUSH
34008: EMPTY
34009: LIST
34010: LIST
34011: PUSH
34012: LD_INT 3
34014: NEG
34015: PUSH
34016: LD_INT 1
34018: NEG
34019: PUSH
34020: EMPTY
34021: LIST
34022: LIST
34023: PUSH
34024: EMPTY
34025: LIST
34026: LIST
34027: LIST
34028: LIST
34029: LIST
34030: LIST
34031: LIST
34032: LIST
34033: LIST
34034: LIST
34035: LIST
34036: LIST
34037: LIST
34038: LIST
34039: LIST
34040: LIST
34041: LIST
34042: LIST
34043: LIST
34044: LIST
34045: LIST
34046: LIST
34047: LIST
34048: LIST
34049: LIST
34050: LIST
34051: LIST
34052: LIST
34053: LIST
34054: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34055: LD_ADDR_VAR 0 47
34059: PUSH
34060: LD_INT 0
34062: PUSH
34063: LD_INT 0
34065: PUSH
34066: EMPTY
34067: LIST
34068: LIST
34069: PUSH
34070: LD_INT 0
34072: PUSH
34073: LD_INT 1
34075: NEG
34076: PUSH
34077: EMPTY
34078: LIST
34079: LIST
34080: PUSH
34081: LD_INT 1
34083: PUSH
34084: LD_INT 0
34086: PUSH
34087: EMPTY
34088: LIST
34089: LIST
34090: PUSH
34091: LD_INT 1
34093: PUSH
34094: LD_INT 1
34096: PUSH
34097: EMPTY
34098: LIST
34099: LIST
34100: PUSH
34101: LD_INT 0
34103: PUSH
34104: LD_INT 1
34106: PUSH
34107: EMPTY
34108: LIST
34109: LIST
34110: PUSH
34111: LD_INT 1
34113: NEG
34114: PUSH
34115: LD_INT 0
34117: PUSH
34118: EMPTY
34119: LIST
34120: LIST
34121: PUSH
34122: LD_INT 1
34124: NEG
34125: PUSH
34126: LD_INT 1
34128: NEG
34129: PUSH
34130: EMPTY
34131: LIST
34132: LIST
34133: PUSH
34134: LD_INT 1
34136: NEG
34137: PUSH
34138: LD_INT 2
34140: NEG
34141: PUSH
34142: EMPTY
34143: LIST
34144: LIST
34145: PUSH
34146: LD_INT 0
34148: PUSH
34149: LD_INT 2
34151: NEG
34152: PUSH
34153: EMPTY
34154: LIST
34155: LIST
34156: PUSH
34157: LD_INT 1
34159: PUSH
34160: LD_INT 1
34162: NEG
34163: PUSH
34164: EMPTY
34165: LIST
34166: LIST
34167: PUSH
34168: LD_INT 2
34170: NEG
34171: PUSH
34172: LD_INT 1
34174: NEG
34175: PUSH
34176: EMPTY
34177: LIST
34178: LIST
34179: PUSH
34180: LD_INT 2
34182: NEG
34183: PUSH
34184: LD_INT 2
34186: NEG
34187: PUSH
34188: EMPTY
34189: LIST
34190: LIST
34191: PUSH
34192: EMPTY
34193: LIST
34194: LIST
34195: LIST
34196: LIST
34197: LIST
34198: LIST
34199: LIST
34200: LIST
34201: LIST
34202: LIST
34203: LIST
34204: LIST
34205: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
34206: LD_ADDR_VAR 0 48
34210: PUSH
34211: LD_INT 0
34213: PUSH
34214: LD_INT 0
34216: PUSH
34217: EMPTY
34218: LIST
34219: LIST
34220: PUSH
34221: LD_INT 0
34223: PUSH
34224: LD_INT 1
34226: NEG
34227: PUSH
34228: EMPTY
34229: LIST
34230: LIST
34231: PUSH
34232: LD_INT 1
34234: PUSH
34235: LD_INT 0
34237: PUSH
34238: EMPTY
34239: LIST
34240: LIST
34241: PUSH
34242: LD_INT 1
34244: PUSH
34245: LD_INT 1
34247: PUSH
34248: EMPTY
34249: LIST
34250: LIST
34251: PUSH
34252: LD_INT 0
34254: PUSH
34255: LD_INT 1
34257: PUSH
34258: EMPTY
34259: LIST
34260: LIST
34261: PUSH
34262: LD_INT 1
34264: NEG
34265: PUSH
34266: LD_INT 0
34268: PUSH
34269: EMPTY
34270: LIST
34271: LIST
34272: PUSH
34273: LD_INT 1
34275: NEG
34276: PUSH
34277: LD_INT 1
34279: NEG
34280: PUSH
34281: EMPTY
34282: LIST
34283: LIST
34284: PUSH
34285: LD_INT 1
34287: NEG
34288: PUSH
34289: LD_INT 2
34291: NEG
34292: PUSH
34293: EMPTY
34294: LIST
34295: LIST
34296: PUSH
34297: LD_INT 0
34299: PUSH
34300: LD_INT 2
34302: NEG
34303: PUSH
34304: EMPTY
34305: LIST
34306: LIST
34307: PUSH
34308: LD_INT 1
34310: PUSH
34311: LD_INT 1
34313: NEG
34314: PUSH
34315: EMPTY
34316: LIST
34317: LIST
34318: PUSH
34319: LD_INT 2
34321: PUSH
34322: LD_INT 0
34324: PUSH
34325: EMPTY
34326: LIST
34327: LIST
34328: PUSH
34329: LD_INT 2
34331: PUSH
34332: LD_INT 1
34334: PUSH
34335: EMPTY
34336: LIST
34337: LIST
34338: PUSH
34339: EMPTY
34340: LIST
34341: LIST
34342: LIST
34343: LIST
34344: LIST
34345: LIST
34346: LIST
34347: LIST
34348: LIST
34349: LIST
34350: LIST
34351: LIST
34352: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
34353: LD_ADDR_VAR 0 49
34357: PUSH
34358: LD_INT 0
34360: PUSH
34361: LD_INT 0
34363: PUSH
34364: EMPTY
34365: LIST
34366: LIST
34367: PUSH
34368: LD_INT 0
34370: PUSH
34371: LD_INT 1
34373: NEG
34374: PUSH
34375: EMPTY
34376: LIST
34377: LIST
34378: PUSH
34379: LD_INT 1
34381: PUSH
34382: LD_INT 0
34384: PUSH
34385: EMPTY
34386: LIST
34387: LIST
34388: PUSH
34389: LD_INT 1
34391: PUSH
34392: LD_INT 1
34394: PUSH
34395: EMPTY
34396: LIST
34397: LIST
34398: PUSH
34399: LD_INT 0
34401: PUSH
34402: LD_INT 1
34404: PUSH
34405: EMPTY
34406: LIST
34407: LIST
34408: PUSH
34409: LD_INT 1
34411: NEG
34412: PUSH
34413: LD_INT 0
34415: PUSH
34416: EMPTY
34417: LIST
34418: LIST
34419: PUSH
34420: LD_INT 1
34422: NEG
34423: PUSH
34424: LD_INT 1
34426: NEG
34427: PUSH
34428: EMPTY
34429: LIST
34430: LIST
34431: PUSH
34432: LD_INT 1
34434: PUSH
34435: LD_INT 1
34437: NEG
34438: PUSH
34439: EMPTY
34440: LIST
34441: LIST
34442: PUSH
34443: LD_INT 2
34445: PUSH
34446: LD_INT 0
34448: PUSH
34449: EMPTY
34450: LIST
34451: LIST
34452: PUSH
34453: LD_INT 2
34455: PUSH
34456: LD_INT 1
34458: PUSH
34459: EMPTY
34460: LIST
34461: LIST
34462: PUSH
34463: LD_INT 2
34465: PUSH
34466: LD_INT 2
34468: PUSH
34469: EMPTY
34470: LIST
34471: LIST
34472: PUSH
34473: LD_INT 1
34475: PUSH
34476: LD_INT 2
34478: PUSH
34479: EMPTY
34480: LIST
34481: LIST
34482: PUSH
34483: EMPTY
34484: LIST
34485: LIST
34486: LIST
34487: LIST
34488: LIST
34489: LIST
34490: LIST
34491: LIST
34492: LIST
34493: LIST
34494: LIST
34495: LIST
34496: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
34497: LD_ADDR_VAR 0 50
34501: PUSH
34502: LD_INT 0
34504: PUSH
34505: LD_INT 0
34507: PUSH
34508: EMPTY
34509: LIST
34510: LIST
34511: PUSH
34512: LD_INT 0
34514: PUSH
34515: LD_INT 1
34517: NEG
34518: PUSH
34519: EMPTY
34520: LIST
34521: LIST
34522: PUSH
34523: LD_INT 1
34525: PUSH
34526: LD_INT 0
34528: PUSH
34529: EMPTY
34530: LIST
34531: LIST
34532: PUSH
34533: LD_INT 1
34535: PUSH
34536: LD_INT 1
34538: PUSH
34539: EMPTY
34540: LIST
34541: LIST
34542: PUSH
34543: LD_INT 0
34545: PUSH
34546: LD_INT 1
34548: PUSH
34549: EMPTY
34550: LIST
34551: LIST
34552: PUSH
34553: LD_INT 1
34555: NEG
34556: PUSH
34557: LD_INT 0
34559: PUSH
34560: EMPTY
34561: LIST
34562: LIST
34563: PUSH
34564: LD_INT 1
34566: NEG
34567: PUSH
34568: LD_INT 1
34570: NEG
34571: PUSH
34572: EMPTY
34573: LIST
34574: LIST
34575: PUSH
34576: LD_INT 2
34578: PUSH
34579: LD_INT 1
34581: PUSH
34582: EMPTY
34583: LIST
34584: LIST
34585: PUSH
34586: LD_INT 2
34588: PUSH
34589: LD_INT 2
34591: PUSH
34592: EMPTY
34593: LIST
34594: LIST
34595: PUSH
34596: LD_INT 1
34598: PUSH
34599: LD_INT 2
34601: PUSH
34602: EMPTY
34603: LIST
34604: LIST
34605: PUSH
34606: LD_INT 0
34608: PUSH
34609: LD_INT 2
34611: PUSH
34612: EMPTY
34613: LIST
34614: LIST
34615: PUSH
34616: LD_INT 1
34618: NEG
34619: PUSH
34620: LD_INT 1
34622: PUSH
34623: EMPTY
34624: LIST
34625: LIST
34626: PUSH
34627: EMPTY
34628: LIST
34629: LIST
34630: LIST
34631: LIST
34632: LIST
34633: LIST
34634: LIST
34635: LIST
34636: LIST
34637: LIST
34638: LIST
34639: LIST
34640: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
34641: LD_ADDR_VAR 0 51
34645: PUSH
34646: LD_INT 0
34648: PUSH
34649: LD_INT 0
34651: PUSH
34652: EMPTY
34653: LIST
34654: LIST
34655: PUSH
34656: LD_INT 0
34658: PUSH
34659: LD_INT 1
34661: NEG
34662: PUSH
34663: EMPTY
34664: LIST
34665: LIST
34666: PUSH
34667: LD_INT 1
34669: PUSH
34670: LD_INT 0
34672: PUSH
34673: EMPTY
34674: LIST
34675: LIST
34676: PUSH
34677: LD_INT 1
34679: PUSH
34680: LD_INT 1
34682: PUSH
34683: EMPTY
34684: LIST
34685: LIST
34686: PUSH
34687: LD_INT 0
34689: PUSH
34690: LD_INT 1
34692: PUSH
34693: EMPTY
34694: LIST
34695: LIST
34696: PUSH
34697: LD_INT 1
34699: NEG
34700: PUSH
34701: LD_INT 0
34703: PUSH
34704: EMPTY
34705: LIST
34706: LIST
34707: PUSH
34708: LD_INT 1
34710: NEG
34711: PUSH
34712: LD_INT 1
34714: NEG
34715: PUSH
34716: EMPTY
34717: LIST
34718: LIST
34719: PUSH
34720: LD_INT 1
34722: PUSH
34723: LD_INT 2
34725: PUSH
34726: EMPTY
34727: LIST
34728: LIST
34729: PUSH
34730: LD_INT 0
34732: PUSH
34733: LD_INT 2
34735: PUSH
34736: EMPTY
34737: LIST
34738: LIST
34739: PUSH
34740: LD_INT 1
34742: NEG
34743: PUSH
34744: LD_INT 1
34746: PUSH
34747: EMPTY
34748: LIST
34749: LIST
34750: PUSH
34751: LD_INT 2
34753: NEG
34754: PUSH
34755: LD_INT 0
34757: PUSH
34758: EMPTY
34759: LIST
34760: LIST
34761: PUSH
34762: LD_INT 2
34764: NEG
34765: PUSH
34766: LD_INT 1
34768: NEG
34769: PUSH
34770: EMPTY
34771: LIST
34772: LIST
34773: PUSH
34774: EMPTY
34775: LIST
34776: LIST
34777: LIST
34778: LIST
34779: LIST
34780: LIST
34781: LIST
34782: LIST
34783: LIST
34784: LIST
34785: LIST
34786: LIST
34787: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34788: LD_ADDR_VAR 0 52
34792: PUSH
34793: LD_INT 0
34795: PUSH
34796: LD_INT 0
34798: PUSH
34799: EMPTY
34800: LIST
34801: LIST
34802: PUSH
34803: LD_INT 0
34805: PUSH
34806: LD_INT 1
34808: NEG
34809: PUSH
34810: EMPTY
34811: LIST
34812: LIST
34813: PUSH
34814: LD_INT 1
34816: PUSH
34817: LD_INT 0
34819: PUSH
34820: EMPTY
34821: LIST
34822: LIST
34823: PUSH
34824: LD_INT 1
34826: PUSH
34827: LD_INT 1
34829: PUSH
34830: EMPTY
34831: LIST
34832: LIST
34833: PUSH
34834: LD_INT 0
34836: PUSH
34837: LD_INT 1
34839: PUSH
34840: EMPTY
34841: LIST
34842: LIST
34843: PUSH
34844: LD_INT 1
34846: NEG
34847: PUSH
34848: LD_INT 0
34850: PUSH
34851: EMPTY
34852: LIST
34853: LIST
34854: PUSH
34855: LD_INT 1
34857: NEG
34858: PUSH
34859: LD_INT 1
34861: NEG
34862: PUSH
34863: EMPTY
34864: LIST
34865: LIST
34866: PUSH
34867: LD_INT 1
34869: NEG
34870: PUSH
34871: LD_INT 2
34873: NEG
34874: PUSH
34875: EMPTY
34876: LIST
34877: LIST
34878: PUSH
34879: LD_INT 1
34881: NEG
34882: PUSH
34883: LD_INT 1
34885: PUSH
34886: EMPTY
34887: LIST
34888: LIST
34889: PUSH
34890: LD_INT 2
34892: NEG
34893: PUSH
34894: LD_INT 0
34896: PUSH
34897: EMPTY
34898: LIST
34899: LIST
34900: PUSH
34901: LD_INT 2
34903: NEG
34904: PUSH
34905: LD_INT 1
34907: NEG
34908: PUSH
34909: EMPTY
34910: LIST
34911: LIST
34912: PUSH
34913: LD_INT 2
34915: NEG
34916: PUSH
34917: LD_INT 2
34919: NEG
34920: PUSH
34921: EMPTY
34922: LIST
34923: LIST
34924: PUSH
34925: EMPTY
34926: LIST
34927: LIST
34928: LIST
34929: LIST
34930: LIST
34931: LIST
34932: LIST
34933: LIST
34934: LIST
34935: LIST
34936: LIST
34937: LIST
34938: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34939: LD_ADDR_VAR 0 53
34943: PUSH
34944: LD_INT 0
34946: PUSH
34947: LD_INT 0
34949: PUSH
34950: EMPTY
34951: LIST
34952: LIST
34953: PUSH
34954: LD_INT 0
34956: PUSH
34957: LD_INT 1
34959: NEG
34960: PUSH
34961: EMPTY
34962: LIST
34963: LIST
34964: PUSH
34965: LD_INT 1
34967: PUSH
34968: LD_INT 0
34970: PUSH
34971: EMPTY
34972: LIST
34973: LIST
34974: PUSH
34975: LD_INT 1
34977: PUSH
34978: LD_INT 1
34980: PUSH
34981: EMPTY
34982: LIST
34983: LIST
34984: PUSH
34985: LD_INT 0
34987: PUSH
34988: LD_INT 1
34990: PUSH
34991: EMPTY
34992: LIST
34993: LIST
34994: PUSH
34995: LD_INT 1
34997: NEG
34998: PUSH
34999: LD_INT 0
35001: PUSH
35002: EMPTY
35003: LIST
35004: LIST
35005: PUSH
35006: LD_INT 1
35008: NEG
35009: PUSH
35010: LD_INT 1
35012: NEG
35013: PUSH
35014: EMPTY
35015: LIST
35016: LIST
35017: PUSH
35018: LD_INT 1
35020: NEG
35021: PUSH
35022: LD_INT 2
35024: NEG
35025: PUSH
35026: EMPTY
35027: LIST
35028: LIST
35029: PUSH
35030: LD_INT 0
35032: PUSH
35033: LD_INT 2
35035: NEG
35036: PUSH
35037: EMPTY
35038: LIST
35039: LIST
35040: PUSH
35041: LD_INT 1
35043: PUSH
35044: LD_INT 1
35046: NEG
35047: PUSH
35048: EMPTY
35049: LIST
35050: LIST
35051: PUSH
35052: LD_INT 2
35054: PUSH
35055: LD_INT 0
35057: PUSH
35058: EMPTY
35059: LIST
35060: LIST
35061: PUSH
35062: LD_INT 2
35064: PUSH
35065: LD_INT 1
35067: PUSH
35068: EMPTY
35069: LIST
35070: LIST
35071: PUSH
35072: LD_INT 2
35074: PUSH
35075: LD_INT 2
35077: PUSH
35078: EMPTY
35079: LIST
35080: LIST
35081: PUSH
35082: LD_INT 1
35084: PUSH
35085: LD_INT 2
35087: PUSH
35088: EMPTY
35089: LIST
35090: LIST
35091: PUSH
35092: LD_INT 0
35094: PUSH
35095: LD_INT 2
35097: PUSH
35098: EMPTY
35099: LIST
35100: LIST
35101: PUSH
35102: LD_INT 1
35104: NEG
35105: PUSH
35106: LD_INT 1
35108: PUSH
35109: EMPTY
35110: LIST
35111: LIST
35112: PUSH
35113: LD_INT 2
35115: NEG
35116: PUSH
35117: LD_INT 0
35119: PUSH
35120: EMPTY
35121: LIST
35122: LIST
35123: PUSH
35124: LD_INT 2
35126: NEG
35127: PUSH
35128: LD_INT 1
35130: NEG
35131: PUSH
35132: EMPTY
35133: LIST
35134: LIST
35135: PUSH
35136: LD_INT 2
35138: NEG
35139: PUSH
35140: LD_INT 2
35142: NEG
35143: PUSH
35144: EMPTY
35145: LIST
35146: LIST
35147: PUSH
35148: EMPTY
35149: LIST
35150: LIST
35151: LIST
35152: LIST
35153: LIST
35154: LIST
35155: LIST
35156: LIST
35157: LIST
35158: LIST
35159: LIST
35160: LIST
35161: LIST
35162: LIST
35163: LIST
35164: LIST
35165: LIST
35166: LIST
35167: LIST
35168: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35169: LD_ADDR_VAR 0 54
35173: PUSH
35174: LD_INT 0
35176: PUSH
35177: LD_INT 0
35179: PUSH
35180: EMPTY
35181: LIST
35182: LIST
35183: PUSH
35184: LD_INT 0
35186: PUSH
35187: LD_INT 1
35189: NEG
35190: PUSH
35191: EMPTY
35192: LIST
35193: LIST
35194: PUSH
35195: LD_INT 1
35197: PUSH
35198: LD_INT 0
35200: PUSH
35201: EMPTY
35202: LIST
35203: LIST
35204: PUSH
35205: LD_INT 1
35207: PUSH
35208: LD_INT 1
35210: PUSH
35211: EMPTY
35212: LIST
35213: LIST
35214: PUSH
35215: LD_INT 0
35217: PUSH
35218: LD_INT 1
35220: PUSH
35221: EMPTY
35222: LIST
35223: LIST
35224: PUSH
35225: LD_INT 1
35227: NEG
35228: PUSH
35229: LD_INT 0
35231: PUSH
35232: EMPTY
35233: LIST
35234: LIST
35235: PUSH
35236: LD_INT 1
35238: NEG
35239: PUSH
35240: LD_INT 1
35242: NEG
35243: PUSH
35244: EMPTY
35245: LIST
35246: LIST
35247: PUSH
35248: LD_INT 1
35250: NEG
35251: PUSH
35252: LD_INT 2
35254: NEG
35255: PUSH
35256: EMPTY
35257: LIST
35258: LIST
35259: PUSH
35260: LD_INT 0
35262: PUSH
35263: LD_INT 2
35265: NEG
35266: PUSH
35267: EMPTY
35268: LIST
35269: LIST
35270: PUSH
35271: LD_INT 1
35273: PUSH
35274: LD_INT 1
35276: NEG
35277: PUSH
35278: EMPTY
35279: LIST
35280: LIST
35281: PUSH
35282: LD_INT 2
35284: PUSH
35285: LD_INT 0
35287: PUSH
35288: EMPTY
35289: LIST
35290: LIST
35291: PUSH
35292: LD_INT 2
35294: PUSH
35295: LD_INT 1
35297: PUSH
35298: EMPTY
35299: LIST
35300: LIST
35301: PUSH
35302: LD_INT 2
35304: PUSH
35305: LD_INT 2
35307: PUSH
35308: EMPTY
35309: LIST
35310: LIST
35311: PUSH
35312: LD_INT 1
35314: PUSH
35315: LD_INT 2
35317: PUSH
35318: EMPTY
35319: LIST
35320: LIST
35321: PUSH
35322: LD_INT 0
35324: PUSH
35325: LD_INT 2
35327: PUSH
35328: EMPTY
35329: LIST
35330: LIST
35331: PUSH
35332: LD_INT 1
35334: NEG
35335: PUSH
35336: LD_INT 1
35338: PUSH
35339: EMPTY
35340: LIST
35341: LIST
35342: PUSH
35343: LD_INT 2
35345: NEG
35346: PUSH
35347: LD_INT 0
35349: PUSH
35350: EMPTY
35351: LIST
35352: LIST
35353: PUSH
35354: LD_INT 2
35356: NEG
35357: PUSH
35358: LD_INT 1
35360: NEG
35361: PUSH
35362: EMPTY
35363: LIST
35364: LIST
35365: PUSH
35366: LD_INT 2
35368: NEG
35369: PUSH
35370: LD_INT 2
35372: NEG
35373: PUSH
35374: EMPTY
35375: LIST
35376: LIST
35377: PUSH
35378: EMPTY
35379: LIST
35380: LIST
35381: LIST
35382: LIST
35383: LIST
35384: LIST
35385: LIST
35386: LIST
35387: LIST
35388: LIST
35389: LIST
35390: LIST
35391: LIST
35392: LIST
35393: LIST
35394: LIST
35395: LIST
35396: LIST
35397: LIST
35398: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35399: LD_ADDR_VAR 0 55
35403: PUSH
35404: LD_INT 0
35406: PUSH
35407: LD_INT 0
35409: PUSH
35410: EMPTY
35411: LIST
35412: LIST
35413: PUSH
35414: LD_INT 0
35416: PUSH
35417: LD_INT 1
35419: NEG
35420: PUSH
35421: EMPTY
35422: LIST
35423: LIST
35424: PUSH
35425: LD_INT 1
35427: PUSH
35428: LD_INT 0
35430: PUSH
35431: EMPTY
35432: LIST
35433: LIST
35434: PUSH
35435: LD_INT 1
35437: PUSH
35438: LD_INT 1
35440: PUSH
35441: EMPTY
35442: LIST
35443: LIST
35444: PUSH
35445: LD_INT 0
35447: PUSH
35448: LD_INT 1
35450: PUSH
35451: EMPTY
35452: LIST
35453: LIST
35454: PUSH
35455: LD_INT 1
35457: NEG
35458: PUSH
35459: LD_INT 0
35461: PUSH
35462: EMPTY
35463: LIST
35464: LIST
35465: PUSH
35466: LD_INT 1
35468: NEG
35469: PUSH
35470: LD_INT 1
35472: NEG
35473: PUSH
35474: EMPTY
35475: LIST
35476: LIST
35477: PUSH
35478: LD_INT 1
35480: NEG
35481: PUSH
35482: LD_INT 2
35484: NEG
35485: PUSH
35486: EMPTY
35487: LIST
35488: LIST
35489: PUSH
35490: LD_INT 0
35492: PUSH
35493: LD_INT 2
35495: NEG
35496: PUSH
35497: EMPTY
35498: LIST
35499: LIST
35500: PUSH
35501: LD_INT 1
35503: PUSH
35504: LD_INT 1
35506: NEG
35507: PUSH
35508: EMPTY
35509: LIST
35510: LIST
35511: PUSH
35512: LD_INT 2
35514: PUSH
35515: LD_INT 0
35517: PUSH
35518: EMPTY
35519: LIST
35520: LIST
35521: PUSH
35522: LD_INT 2
35524: PUSH
35525: LD_INT 1
35527: PUSH
35528: EMPTY
35529: LIST
35530: LIST
35531: PUSH
35532: LD_INT 2
35534: PUSH
35535: LD_INT 2
35537: PUSH
35538: EMPTY
35539: LIST
35540: LIST
35541: PUSH
35542: LD_INT 1
35544: PUSH
35545: LD_INT 2
35547: PUSH
35548: EMPTY
35549: LIST
35550: LIST
35551: PUSH
35552: LD_INT 0
35554: PUSH
35555: LD_INT 2
35557: PUSH
35558: EMPTY
35559: LIST
35560: LIST
35561: PUSH
35562: LD_INT 1
35564: NEG
35565: PUSH
35566: LD_INT 1
35568: PUSH
35569: EMPTY
35570: LIST
35571: LIST
35572: PUSH
35573: LD_INT 2
35575: NEG
35576: PUSH
35577: LD_INT 0
35579: PUSH
35580: EMPTY
35581: LIST
35582: LIST
35583: PUSH
35584: LD_INT 2
35586: NEG
35587: PUSH
35588: LD_INT 1
35590: NEG
35591: PUSH
35592: EMPTY
35593: LIST
35594: LIST
35595: PUSH
35596: LD_INT 2
35598: NEG
35599: PUSH
35600: LD_INT 2
35602: NEG
35603: PUSH
35604: EMPTY
35605: LIST
35606: LIST
35607: PUSH
35608: EMPTY
35609: LIST
35610: LIST
35611: LIST
35612: LIST
35613: LIST
35614: LIST
35615: LIST
35616: LIST
35617: LIST
35618: LIST
35619: LIST
35620: LIST
35621: LIST
35622: LIST
35623: LIST
35624: LIST
35625: LIST
35626: LIST
35627: LIST
35628: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35629: LD_ADDR_VAR 0 56
35633: PUSH
35634: LD_INT 0
35636: PUSH
35637: LD_INT 0
35639: PUSH
35640: EMPTY
35641: LIST
35642: LIST
35643: PUSH
35644: LD_INT 0
35646: PUSH
35647: LD_INT 1
35649: NEG
35650: PUSH
35651: EMPTY
35652: LIST
35653: LIST
35654: PUSH
35655: LD_INT 1
35657: PUSH
35658: LD_INT 0
35660: PUSH
35661: EMPTY
35662: LIST
35663: LIST
35664: PUSH
35665: LD_INT 1
35667: PUSH
35668: LD_INT 1
35670: PUSH
35671: EMPTY
35672: LIST
35673: LIST
35674: PUSH
35675: LD_INT 0
35677: PUSH
35678: LD_INT 1
35680: PUSH
35681: EMPTY
35682: LIST
35683: LIST
35684: PUSH
35685: LD_INT 1
35687: NEG
35688: PUSH
35689: LD_INT 0
35691: PUSH
35692: EMPTY
35693: LIST
35694: LIST
35695: PUSH
35696: LD_INT 1
35698: NEG
35699: PUSH
35700: LD_INT 1
35702: NEG
35703: PUSH
35704: EMPTY
35705: LIST
35706: LIST
35707: PUSH
35708: LD_INT 1
35710: NEG
35711: PUSH
35712: LD_INT 2
35714: NEG
35715: PUSH
35716: EMPTY
35717: LIST
35718: LIST
35719: PUSH
35720: LD_INT 0
35722: PUSH
35723: LD_INT 2
35725: NEG
35726: PUSH
35727: EMPTY
35728: LIST
35729: LIST
35730: PUSH
35731: LD_INT 1
35733: PUSH
35734: LD_INT 1
35736: NEG
35737: PUSH
35738: EMPTY
35739: LIST
35740: LIST
35741: PUSH
35742: LD_INT 2
35744: PUSH
35745: LD_INT 0
35747: PUSH
35748: EMPTY
35749: LIST
35750: LIST
35751: PUSH
35752: LD_INT 2
35754: PUSH
35755: LD_INT 1
35757: PUSH
35758: EMPTY
35759: LIST
35760: LIST
35761: PUSH
35762: LD_INT 2
35764: PUSH
35765: LD_INT 2
35767: PUSH
35768: EMPTY
35769: LIST
35770: LIST
35771: PUSH
35772: LD_INT 1
35774: PUSH
35775: LD_INT 2
35777: PUSH
35778: EMPTY
35779: LIST
35780: LIST
35781: PUSH
35782: LD_INT 0
35784: PUSH
35785: LD_INT 2
35787: PUSH
35788: EMPTY
35789: LIST
35790: LIST
35791: PUSH
35792: LD_INT 1
35794: NEG
35795: PUSH
35796: LD_INT 1
35798: PUSH
35799: EMPTY
35800: LIST
35801: LIST
35802: PUSH
35803: LD_INT 2
35805: NEG
35806: PUSH
35807: LD_INT 0
35809: PUSH
35810: EMPTY
35811: LIST
35812: LIST
35813: PUSH
35814: LD_INT 2
35816: NEG
35817: PUSH
35818: LD_INT 1
35820: NEG
35821: PUSH
35822: EMPTY
35823: LIST
35824: LIST
35825: PUSH
35826: LD_INT 2
35828: NEG
35829: PUSH
35830: LD_INT 2
35832: NEG
35833: PUSH
35834: EMPTY
35835: LIST
35836: LIST
35837: PUSH
35838: EMPTY
35839: LIST
35840: LIST
35841: LIST
35842: LIST
35843: LIST
35844: LIST
35845: LIST
35846: LIST
35847: LIST
35848: LIST
35849: LIST
35850: LIST
35851: LIST
35852: LIST
35853: LIST
35854: LIST
35855: LIST
35856: LIST
35857: LIST
35858: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35859: LD_ADDR_VAR 0 57
35863: PUSH
35864: LD_INT 0
35866: PUSH
35867: LD_INT 0
35869: PUSH
35870: EMPTY
35871: LIST
35872: LIST
35873: PUSH
35874: LD_INT 0
35876: PUSH
35877: LD_INT 1
35879: NEG
35880: PUSH
35881: EMPTY
35882: LIST
35883: LIST
35884: PUSH
35885: LD_INT 1
35887: PUSH
35888: LD_INT 0
35890: PUSH
35891: EMPTY
35892: LIST
35893: LIST
35894: PUSH
35895: LD_INT 1
35897: PUSH
35898: LD_INT 1
35900: PUSH
35901: EMPTY
35902: LIST
35903: LIST
35904: PUSH
35905: LD_INT 0
35907: PUSH
35908: LD_INT 1
35910: PUSH
35911: EMPTY
35912: LIST
35913: LIST
35914: PUSH
35915: LD_INT 1
35917: NEG
35918: PUSH
35919: LD_INT 0
35921: PUSH
35922: EMPTY
35923: LIST
35924: LIST
35925: PUSH
35926: LD_INT 1
35928: NEG
35929: PUSH
35930: LD_INT 1
35932: NEG
35933: PUSH
35934: EMPTY
35935: LIST
35936: LIST
35937: PUSH
35938: LD_INT 1
35940: NEG
35941: PUSH
35942: LD_INT 2
35944: NEG
35945: PUSH
35946: EMPTY
35947: LIST
35948: LIST
35949: PUSH
35950: LD_INT 0
35952: PUSH
35953: LD_INT 2
35955: NEG
35956: PUSH
35957: EMPTY
35958: LIST
35959: LIST
35960: PUSH
35961: LD_INT 1
35963: PUSH
35964: LD_INT 1
35966: NEG
35967: PUSH
35968: EMPTY
35969: LIST
35970: LIST
35971: PUSH
35972: LD_INT 2
35974: PUSH
35975: LD_INT 0
35977: PUSH
35978: EMPTY
35979: LIST
35980: LIST
35981: PUSH
35982: LD_INT 2
35984: PUSH
35985: LD_INT 1
35987: PUSH
35988: EMPTY
35989: LIST
35990: LIST
35991: PUSH
35992: LD_INT 2
35994: PUSH
35995: LD_INT 2
35997: PUSH
35998: EMPTY
35999: LIST
36000: LIST
36001: PUSH
36002: LD_INT 1
36004: PUSH
36005: LD_INT 2
36007: PUSH
36008: EMPTY
36009: LIST
36010: LIST
36011: PUSH
36012: LD_INT 0
36014: PUSH
36015: LD_INT 2
36017: PUSH
36018: EMPTY
36019: LIST
36020: LIST
36021: PUSH
36022: LD_INT 1
36024: NEG
36025: PUSH
36026: LD_INT 1
36028: PUSH
36029: EMPTY
36030: LIST
36031: LIST
36032: PUSH
36033: LD_INT 2
36035: NEG
36036: PUSH
36037: LD_INT 0
36039: PUSH
36040: EMPTY
36041: LIST
36042: LIST
36043: PUSH
36044: LD_INT 2
36046: NEG
36047: PUSH
36048: LD_INT 1
36050: NEG
36051: PUSH
36052: EMPTY
36053: LIST
36054: LIST
36055: PUSH
36056: LD_INT 2
36058: NEG
36059: PUSH
36060: LD_INT 2
36062: NEG
36063: PUSH
36064: EMPTY
36065: LIST
36066: LIST
36067: PUSH
36068: EMPTY
36069: LIST
36070: LIST
36071: LIST
36072: LIST
36073: LIST
36074: LIST
36075: LIST
36076: LIST
36077: LIST
36078: LIST
36079: LIST
36080: LIST
36081: LIST
36082: LIST
36083: LIST
36084: LIST
36085: LIST
36086: LIST
36087: LIST
36088: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36089: LD_ADDR_VAR 0 58
36093: PUSH
36094: LD_INT 0
36096: PUSH
36097: LD_INT 0
36099: PUSH
36100: EMPTY
36101: LIST
36102: LIST
36103: PUSH
36104: LD_INT 0
36106: PUSH
36107: LD_INT 1
36109: NEG
36110: PUSH
36111: EMPTY
36112: LIST
36113: LIST
36114: PUSH
36115: LD_INT 1
36117: PUSH
36118: LD_INT 0
36120: PUSH
36121: EMPTY
36122: LIST
36123: LIST
36124: PUSH
36125: LD_INT 1
36127: PUSH
36128: LD_INT 1
36130: PUSH
36131: EMPTY
36132: LIST
36133: LIST
36134: PUSH
36135: LD_INT 0
36137: PUSH
36138: LD_INT 1
36140: PUSH
36141: EMPTY
36142: LIST
36143: LIST
36144: PUSH
36145: LD_INT 1
36147: NEG
36148: PUSH
36149: LD_INT 0
36151: PUSH
36152: EMPTY
36153: LIST
36154: LIST
36155: PUSH
36156: LD_INT 1
36158: NEG
36159: PUSH
36160: LD_INT 1
36162: NEG
36163: PUSH
36164: EMPTY
36165: LIST
36166: LIST
36167: PUSH
36168: LD_INT 1
36170: NEG
36171: PUSH
36172: LD_INT 2
36174: NEG
36175: PUSH
36176: EMPTY
36177: LIST
36178: LIST
36179: PUSH
36180: LD_INT 0
36182: PUSH
36183: LD_INT 2
36185: NEG
36186: PUSH
36187: EMPTY
36188: LIST
36189: LIST
36190: PUSH
36191: LD_INT 1
36193: PUSH
36194: LD_INT 1
36196: NEG
36197: PUSH
36198: EMPTY
36199: LIST
36200: LIST
36201: PUSH
36202: LD_INT 2
36204: PUSH
36205: LD_INT 0
36207: PUSH
36208: EMPTY
36209: LIST
36210: LIST
36211: PUSH
36212: LD_INT 2
36214: PUSH
36215: LD_INT 1
36217: PUSH
36218: EMPTY
36219: LIST
36220: LIST
36221: PUSH
36222: LD_INT 2
36224: PUSH
36225: LD_INT 2
36227: PUSH
36228: EMPTY
36229: LIST
36230: LIST
36231: PUSH
36232: LD_INT 1
36234: PUSH
36235: LD_INT 2
36237: PUSH
36238: EMPTY
36239: LIST
36240: LIST
36241: PUSH
36242: LD_INT 0
36244: PUSH
36245: LD_INT 2
36247: PUSH
36248: EMPTY
36249: LIST
36250: LIST
36251: PUSH
36252: LD_INT 1
36254: NEG
36255: PUSH
36256: LD_INT 1
36258: PUSH
36259: EMPTY
36260: LIST
36261: LIST
36262: PUSH
36263: LD_INT 2
36265: NEG
36266: PUSH
36267: LD_INT 0
36269: PUSH
36270: EMPTY
36271: LIST
36272: LIST
36273: PUSH
36274: LD_INT 2
36276: NEG
36277: PUSH
36278: LD_INT 1
36280: NEG
36281: PUSH
36282: EMPTY
36283: LIST
36284: LIST
36285: PUSH
36286: LD_INT 2
36288: NEG
36289: PUSH
36290: LD_INT 2
36292: NEG
36293: PUSH
36294: EMPTY
36295: LIST
36296: LIST
36297: PUSH
36298: EMPTY
36299: LIST
36300: LIST
36301: LIST
36302: LIST
36303: LIST
36304: LIST
36305: LIST
36306: LIST
36307: LIST
36308: LIST
36309: LIST
36310: LIST
36311: LIST
36312: LIST
36313: LIST
36314: LIST
36315: LIST
36316: LIST
36317: LIST
36318: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36319: LD_ADDR_VAR 0 59
36323: PUSH
36324: LD_INT 0
36326: PUSH
36327: LD_INT 0
36329: PUSH
36330: EMPTY
36331: LIST
36332: LIST
36333: PUSH
36334: LD_INT 0
36336: PUSH
36337: LD_INT 1
36339: NEG
36340: PUSH
36341: EMPTY
36342: LIST
36343: LIST
36344: PUSH
36345: LD_INT 1
36347: PUSH
36348: LD_INT 0
36350: PUSH
36351: EMPTY
36352: LIST
36353: LIST
36354: PUSH
36355: LD_INT 1
36357: PUSH
36358: LD_INT 1
36360: PUSH
36361: EMPTY
36362: LIST
36363: LIST
36364: PUSH
36365: LD_INT 0
36367: PUSH
36368: LD_INT 1
36370: PUSH
36371: EMPTY
36372: LIST
36373: LIST
36374: PUSH
36375: LD_INT 1
36377: NEG
36378: PUSH
36379: LD_INT 0
36381: PUSH
36382: EMPTY
36383: LIST
36384: LIST
36385: PUSH
36386: LD_INT 1
36388: NEG
36389: PUSH
36390: LD_INT 1
36392: NEG
36393: PUSH
36394: EMPTY
36395: LIST
36396: LIST
36397: PUSH
36398: EMPTY
36399: LIST
36400: LIST
36401: LIST
36402: LIST
36403: LIST
36404: LIST
36405: LIST
36406: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36407: LD_ADDR_VAR 0 60
36411: PUSH
36412: LD_INT 0
36414: PUSH
36415: LD_INT 0
36417: PUSH
36418: EMPTY
36419: LIST
36420: LIST
36421: PUSH
36422: LD_INT 0
36424: PUSH
36425: LD_INT 1
36427: NEG
36428: PUSH
36429: EMPTY
36430: LIST
36431: LIST
36432: PUSH
36433: LD_INT 1
36435: PUSH
36436: LD_INT 0
36438: PUSH
36439: EMPTY
36440: LIST
36441: LIST
36442: PUSH
36443: LD_INT 1
36445: PUSH
36446: LD_INT 1
36448: PUSH
36449: EMPTY
36450: LIST
36451: LIST
36452: PUSH
36453: LD_INT 0
36455: PUSH
36456: LD_INT 1
36458: PUSH
36459: EMPTY
36460: LIST
36461: LIST
36462: PUSH
36463: LD_INT 1
36465: NEG
36466: PUSH
36467: LD_INT 0
36469: PUSH
36470: EMPTY
36471: LIST
36472: LIST
36473: PUSH
36474: LD_INT 1
36476: NEG
36477: PUSH
36478: LD_INT 1
36480: NEG
36481: PUSH
36482: EMPTY
36483: LIST
36484: LIST
36485: PUSH
36486: EMPTY
36487: LIST
36488: LIST
36489: LIST
36490: LIST
36491: LIST
36492: LIST
36493: LIST
36494: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36495: LD_ADDR_VAR 0 61
36499: PUSH
36500: LD_INT 0
36502: PUSH
36503: LD_INT 0
36505: PUSH
36506: EMPTY
36507: LIST
36508: LIST
36509: PUSH
36510: LD_INT 0
36512: PUSH
36513: LD_INT 1
36515: NEG
36516: PUSH
36517: EMPTY
36518: LIST
36519: LIST
36520: PUSH
36521: LD_INT 1
36523: PUSH
36524: LD_INT 0
36526: PUSH
36527: EMPTY
36528: LIST
36529: LIST
36530: PUSH
36531: LD_INT 1
36533: PUSH
36534: LD_INT 1
36536: PUSH
36537: EMPTY
36538: LIST
36539: LIST
36540: PUSH
36541: LD_INT 0
36543: PUSH
36544: LD_INT 1
36546: PUSH
36547: EMPTY
36548: LIST
36549: LIST
36550: PUSH
36551: LD_INT 1
36553: NEG
36554: PUSH
36555: LD_INT 0
36557: PUSH
36558: EMPTY
36559: LIST
36560: LIST
36561: PUSH
36562: LD_INT 1
36564: NEG
36565: PUSH
36566: LD_INT 1
36568: NEG
36569: PUSH
36570: EMPTY
36571: LIST
36572: LIST
36573: PUSH
36574: EMPTY
36575: LIST
36576: LIST
36577: LIST
36578: LIST
36579: LIST
36580: LIST
36581: LIST
36582: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36583: LD_ADDR_VAR 0 62
36587: PUSH
36588: LD_INT 0
36590: PUSH
36591: LD_INT 0
36593: PUSH
36594: EMPTY
36595: LIST
36596: LIST
36597: PUSH
36598: LD_INT 0
36600: PUSH
36601: LD_INT 1
36603: NEG
36604: PUSH
36605: EMPTY
36606: LIST
36607: LIST
36608: PUSH
36609: LD_INT 1
36611: PUSH
36612: LD_INT 0
36614: PUSH
36615: EMPTY
36616: LIST
36617: LIST
36618: PUSH
36619: LD_INT 1
36621: PUSH
36622: LD_INT 1
36624: PUSH
36625: EMPTY
36626: LIST
36627: LIST
36628: PUSH
36629: LD_INT 0
36631: PUSH
36632: LD_INT 1
36634: PUSH
36635: EMPTY
36636: LIST
36637: LIST
36638: PUSH
36639: LD_INT 1
36641: NEG
36642: PUSH
36643: LD_INT 0
36645: PUSH
36646: EMPTY
36647: LIST
36648: LIST
36649: PUSH
36650: LD_INT 1
36652: NEG
36653: PUSH
36654: LD_INT 1
36656: NEG
36657: PUSH
36658: EMPTY
36659: LIST
36660: LIST
36661: PUSH
36662: EMPTY
36663: LIST
36664: LIST
36665: LIST
36666: LIST
36667: LIST
36668: LIST
36669: LIST
36670: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36671: LD_ADDR_VAR 0 63
36675: PUSH
36676: LD_INT 0
36678: PUSH
36679: LD_INT 0
36681: PUSH
36682: EMPTY
36683: LIST
36684: LIST
36685: PUSH
36686: LD_INT 0
36688: PUSH
36689: LD_INT 1
36691: NEG
36692: PUSH
36693: EMPTY
36694: LIST
36695: LIST
36696: PUSH
36697: LD_INT 1
36699: PUSH
36700: LD_INT 0
36702: PUSH
36703: EMPTY
36704: LIST
36705: LIST
36706: PUSH
36707: LD_INT 1
36709: PUSH
36710: LD_INT 1
36712: PUSH
36713: EMPTY
36714: LIST
36715: LIST
36716: PUSH
36717: LD_INT 0
36719: PUSH
36720: LD_INT 1
36722: PUSH
36723: EMPTY
36724: LIST
36725: LIST
36726: PUSH
36727: LD_INT 1
36729: NEG
36730: PUSH
36731: LD_INT 0
36733: PUSH
36734: EMPTY
36735: LIST
36736: LIST
36737: PUSH
36738: LD_INT 1
36740: NEG
36741: PUSH
36742: LD_INT 1
36744: NEG
36745: PUSH
36746: EMPTY
36747: LIST
36748: LIST
36749: PUSH
36750: EMPTY
36751: LIST
36752: LIST
36753: LIST
36754: LIST
36755: LIST
36756: LIST
36757: LIST
36758: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36759: LD_ADDR_VAR 0 64
36763: PUSH
36764: LD_INT 0
36766: PUSH
36767: LD_INT 0
36769: PUSH
36770: EMPTY
36771: LIST
36772: LIST
36773: PUSH
36774: LD_INT 0
36776: PUSH
36777: LD_INT 1
36779: NEG
36780: PUSH
36781: EMPTY
36782: LIST
36783: LIST
36784: PUSH
36785: LD_INT 1
36787: PUSH
36788: LD_INT 0
36790: PUSH
36791: EMPTY
36792: LIST
36793: LIST
36794: PUSH
36795: LD_INT 1
36797: PUSH
36798: LD_INT 1
36800: PUSH
36801: EMPTY
36802: LIST
36803: LIST
36804: PUSH
36805: LD_INT 0
36807: PUSH
36808: LD_INT 1
36810: PUSH
36811: EMPTY
36812: LIST
36813: LIST
36814: PUSH
36815: LD_INT 1
36817: NEG
36818: PUSH
36819: LD_INT 0
36821: PUSH
36822: EMPTY
36823: LIST
36824: LIST
36825: PUSH
36826: LD_INT 1
36828: NEG
36829: PUSH
36830: LD_INT 1
36832: NEG
36833: PUSH
36834: EMPTY
36835: LIST
36836: LIST
36837: PUSH
36838: EMPTY
36839: LIST
36840: LIST
36841: LIST
36842: LIST
36843: LIST
36844: LIST
36845: LIST
36846: ST_TO_ADDR
// end ; 1 :
36847: GO 42744
36849: LD_INT 1
36851: DOUBLE
36852: EQUAL
36853: IFTRUE 36857
36855: GO 39480
36857: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
36858: LD_ADDR_VAR 0 11
36862: PUSH
36863: LD_INT 1
36865: NEG
36866: PUSH
36867: LD_INT 3
36869: NEG
36870: PUSH
36871: EMPTY
36872: LIST
36873: LIST
36874: PUSH
36875: LD_INT 0
36877: PUSH
36878: LD_INT 3
36880: NEG
36881: PUSH
36882: EMPTY
36883: LIST
36884: LIST
36885: PUSH
36886: LD_INT 1
36888: PUSH
36889: LD_INT 2
36891: NEG
36892: PUSH
36893: EMPTY
36894: LIST
36895: LIST
36896: PUSH
36897: EMPTY
36898: LIST
36899: LIST
36900: LIST
36901: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
36902: LD_ADDR_VAR 0 12
36906: PUSH
36907: LD_INT 2
36909: PUSH
36910: LD_INT 1
36912: NEG
36913: PUSH
36914: EMPTY
36915: LIST
36916: LIST
36917: PUSH
36918: LD_INT 3
36920: PUSH
36921: LD_INT 0
36923: PUSH
36924: EMPTY
36925: LIST
36926: LIST
36927: PUSH
36928: LD_INT 3
36930: PUSH
36931: LD_INT 1
36933: PUSH
36934: EMPTY
36935: LIST
36936: LIST
36937: PUSH
36938: EMPTY
36939: LIST
36940: LIST
36941: LIST
36942: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
36943: LD_ADDR_VAR 0 13
36947: PUSH
36948: LD_INT 3
36950: PUSH
36951: LD_INT 2
36953: PUSH
36954: EMPTY
36955: LIST
36956: LIST
36957: PUSH
36958: LD_INT 3
36960: PUSH
36961: LD_INT 3
36963: PUSH
36964: EMPTY
36965: LIST
36966: LIST
36967: PUSH
36968: LD_INT 2
36970: PUSH
36971: LD_INT 3
36973: PUSH
36974: EMPTY
36975: LIST
36976: LIST
36977: PUSH
36978: EMPTY
36979: LIST
36980: LIST
36981: LIST
36982: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
36983: LD_ADDR_VAR 0 14
36987: PUSH
36988: LD_INT 1
36990: PUSH
36991: LD_INT 3
36993: PUSH
36994: EMPTY
36995: LIST
36996: LIST
36997: PUSH
36998: LD_INT 0
37000: PUSH
37001: LD_INT 3
37003: PUSH
37004: EMPTY
37005: LIST
37006: LIST
37007: PUSH
37008: LD_INT 1
37010: NEG
37011: PUSH
37012: LD_INT 2
37014: PUSH
37015: EMPTY
37016: LIST
37017: LIST
37018: PUSH
37019: EMPTY
37020: LIST
37021: LIST
37022: LIST
37023: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37024: LD_ADDR_VAR 0 15
37028: PUSH
37029: LD_INT 2
37031: NEG
37032: PUSH
37033: LD_INT 1
37035: PUSH
37036: EMPTY
37037: LIST
37038: LIST
37039: PUSH
37040: LD_INT 3
37042: NEG
37043: PUSH
37044: LD_INT 0
37046: PUSH
37047: EMPTY
37048: LIST
37049: LIST
37050: PUSH
37051: LD_INT 3
37053: NEG
37054: PUSH
37055: LD_INT 1
37057: NEG
37058: PUSH
37059: EMPTY
37060: LIST
37061: LIST
37062: PUSH
37063: EMPTY
37064: LIST
37065: LIST
37066: LIST
37067: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37068: LD_ADDR_VAR 0 16
37072: PUSH
37073: LD_INT 2
37075: NEG
37076: PUSH
37077: LD_INT 3
37079: NEG
37080: PUSH
37081: EMPTY
37082: LIST
37083: LIST
37084: PUSH
37085: LD_INT 3
37087: NEG
37088: PUSH
37089: LD_INT 2
37091: NEG
37092: PUSH
37093: EMPTY
37094: LIST
37095: LIST
37096: PUSH
37097: LD_INT 3
37099: NEG
37100: PUSH
37101: LD_INT 3
37103: NEG
37104: PUSH
37105: EMPTY
37106: LIST
37107: LIST
37108: PUSH
37109: EMPTY
37110: LIST
37111: LIST
37112: LIST
37113: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
37114: LD_ADDR_VAR 0 17
37118: PUSH
37119: LD_INT 1
37121: NEG
37122: PUSH
37123: LD_INT 3
37125: NEG
37126: PUSH
37127: EMPTY
37128: LIST
37129: LIST
37130: PUSH
37131: LD_INT 0
37133: PUSH
37134: LD_INT 3
37136: NEG
37137: PUSH
37138: EMPTY
37139: LIST
37140: LIST
37141: PUSH
37142: LD_INT 1
37144: PUSH
37145: LD_INT 2
37147: NEG
37148: PUSH
37149: EMPTY
37150: LIST
37151: LIST
37152: PUSH
37153: EMPTY
37154: LIST
37155: LIST
37156: LIST
37157: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
37158: LD_ADDR_VAR 0 18
37162: PUSH
37163: LD_INT 2
37165: PUSH
37166: LD_INT 1
37168: NEG
37169: PUSH
37170: EMPTY
37171: LIST
37172: LIST
37173: PUSH
37174: LD_INT 3
37176: PUSH
37177: LD_INT 0
37179: PUSH
37180: EMPTY
37181: LIST
37182: LIST
37183: PUSH
37184: LD_INT 3
37186: PUSH
37187: LD_INT 1
37189: PUSH
37190: EMPTY
37191: LIST
37192: LIST
37193: PUSH
37194: EMPTY
37195: LIST
37196: LIST
37197: LIST
37198: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
37199: LD_ADDR_VAR 0 19
37203: PUSH
37204: LD_INT 3
37206: PUSH
37207: LD_INT 2
37209: PUSH
37210: EMPTY
37211: LIST
37212: LIST
37213: PUSH
37214: LD_INT 3
37216: PUSH
37217: LD_INT 3
37219: PUSH
37220: EMPTY
37221: LIST
37222: LIST
37223: PUSH
37224: LD_INT 2
37226: PUSH
37227: LD_INT 3
37229: PUSH
37230: EMPTY
37231: LIST
37232: LIST
37233: PUSH
37234: EMPTY
37235: LIST
37236: LIST
37237: LIST
37238: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37239: LD_ADDR_VAR 0 20
37243: PUSH
37244: LD_INT 1
37246: PUSH
37247: LD_INT 3
37249: PUSH
37250: EMPTY
37251: LIST
37252: LIST
37253: PUSH
37254: LD_INT 0
37256: PUSH
37257: LD_INT 3
37259: PUSH
37260: EMPTY
37261: LIST
37262: LIST
37263: PUSH
37264: LD_INT 1
37266: NEG
37267: PUSH
37268: LD_INT 2
37270: PUSH
37271: EMPTY
37272: LIST
37273: LIST
37274: PUSH
37275: EMPTY
37276: LIST
37277: LIST
37278: LIST
37279: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37280: LD_ADDR_VAR 0 21
37284: PUSH
37285: LD_INT 2
37287: NEG
37288: PUSH
37289: LD_INT 1
37291: PUSH
37292: EMPTY
37293: LIST
37294: LIST
37295: PUSH
37296: LD_INT 3
37298: NEG
37299: PUSH
37300: LD_INT 0
37302: PUSH
37303: EMPTY
37304: LIST
37305: LIST
37306: PUSH
37307: LD_INT 3
37309: NEG
37310: PUSH
37311: LD_INT 1
37313: NEG
37314: PUSH
37315: EMPTY
37316: LIST
37317: LIST
37318: PUSH
37319: EMPTY
37320: LIST
37321: LIST
37322: LIST
37323: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37324: LD_ADDR_VAR 0 22
37328: PUSH
37329: LD_INT 2
37331: NEG
37332: PUSH
37333: LD_INT 3
37335: NEG
37336: PUSH
37337: EMPTY
37338: LIST
37339: LIST
37340: PUSH
37341: LD_INT 3
37343: NEG
37344: PUSH
37345: LD_INT 2
37347: NEG
37348: PUSH
37349: EMPTY
37350: LIST
37351: LIST
37352: PUSH
37353: LD_INT 3
37355: NEG
37356: PUSH
37357: LD_INT 3
37359: NEG
37360: PUSH
37361: EMPTY
37362: LIST
37363: LIST
37364: PUSH
37365: EMPTY
37366: LIST
37367: LIST
37368: LIST
37369: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
37370: LD_ADDR_VAR 0 23
37374: PUSH
37375: LD_INT 0
37377: PUSH
37378: LD_INT 3
37380: NEG
37381: PUSH
37382: EMPTY
37383: LIST
37384: LIST
37385: PUSH
37386: LD_INT 1
37388: NEG
37389: PUSH
37390: LD_INT 4
37392: NEG
37393: PUSH
37394: EMPTY
37395: LIST
37396: LIST
37397: PUSH
37398: LD_INT 1
37400: PUSH
37401: LD_INT 3
37403: NEG
37404: PUSH
37405: EMPTY
37406: LIST
37407: LIST
37408: PUSH
37409: EMPTY
37410: LIST
37411: LIST
37412: LIST
37413: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
37414: LD_ADDR_VAR 0 24
37418: PUSH
37419: LD_INT 3
37421: PUSH
37422: LD_INT 0
37424: PUSH
37425: EMPTY
37426: LIST
37427: LIST
37428: PUSH
37429: LD_INT 3
37431: PUSH
37432: LD_INT 1
37434: NEG
37435: PUSH
37436: EMPTY
37437: LIST
37438: LIST
37439: PUSH
37440: LD_INT 4
37442: PUSH
37443: LD_INT 1
37445: PUSH
37446: EMPTY
37447: LIST
37448: LIST
37449: PUSH
37450: EMPTY
37451: LIST
37452: LIST
37453: LIST
37454: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
37455: LD_ADDR_VAR 0 25
37459: PUSH
37460: LD_INT 3
37462: PUSH
37463: LD_INT 3
37465: PUSH
37466: EMPTY
37467: LIST
37468: LIST
37469: PUSH
37470: LD_INT 4
37472: PUSH
37473: LD_INT 3
37475: PUSH
37476: EMPTY
37477: LIST
37478: LIST
37479: PUSH
37480: LD_INT 3
37482: PUSH
37483: LD_INT 4
37485: PUSH
37486: EMPTY
37487: LIST
37488: LIST
37489: PUSH
37490: EMPTY
37491: LIST
37492: LIST
37493: LIST
37494: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
37495: LD_ADDR_VAR 0 26
37499: PUSH
37500: LD_INT 0
37502: PUSH
37503: LD_INT 3
37505: PUSH
37506: EMPTY
37507: LIST
37508: LIST
37509: PUSH
37510: LD_INT 1
37512: PUSH
37513: LD_INT 4
37515: PUSH
37516: EMPTY
37517: LIST
37518: LIST
37519: PUSH
37520: LD_INT 1
37522: NEG
37523: PUSH
37524: LD_INT 3
37526: PUSH
37527: EMPTY
37528: LIST
37529: LIST
37530: PUSH
37531: EMPTY
37532: LIST
37533: LIST
37534: LIST
37535: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
37536: LD_ADDR_VAR 0 27
37540: PUSH
37541: LD_INT 3
37543: NEG
37544: PUSH
37545: LD_INT 0
37547: PUSH
37548: EMPTY
37549: LIST
37550: LIST
37551: PUSH
37552: LD_INT 3
37554: NEG
37555: PUSH
37556: LD_INT 1
37558: PUSH
37559: EMPTY
37560: LIST
37561: LIST
37562: PUSH
37563: LD_INT 4
37565: NEG
37566: PUSH
37567: LD_INT 1
37569: NEG
37570: PUSH
37571: EMPTY
37572: LIST
37573: LIST
37574: PUSH
37575: EMPTY
37576: LIST
37577: LIST
37578: LIST
37579: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
37580: LD_ADDR_VAR 0 28
37584: PUSH
37585: LD_INT 3
37587: NEG
37588: PUSH
37589: LD_INT 3
37591: NEG
37592: PUSH
37593: EMPTY
37594: LIST
37595: LIST
37596: PUSH
37597: LD_INT 3
37599: NEG
37600: PUSH
37601: LD_INT 4
37603: NEG
37604: PUSH
37605: EMPTY
37606: LIST
37607: LIST
37608: PUSH
37609: LD_INT 4
37611: NEG
37612: PUSH
37613: LD_INT 3
37615: NEG
37616: PUSH
37617: EMPTY
37618: LIST
37619: LIST
37620: PUSH
37621: EMPTY
37622: LIST
37623: LIST
37624: LIST
37625: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
37626: LD_ADDR_VAR 0 29
37630: PUSH
37631: LD_INT 1
37633: NEG
37634: PUSH
37635: LD_INT 3
37637: NEG
37638: PUSH
37639: EMPTY
37640: LIST
37641: LIST
37642: PUSH
37643: LD_INT 0
37645: PUSH
37646: LD_INT 3
37648: NEG
37649: PUSH
37650: EMPTY
37651: LIST
37652: LIST
37653: PUSH
37654: LD_INT 1
37656: PUSH
37657: LD_INT 2
37659: NEG
37660: PUSH
37661: EMPTY
37662: LIST
37663: LIST
37664: PUSH
37665: LD_INT 1
37667: NEG
37668: PUSH
37669: LD_INT 4
37671: NEG
37672: PUSH
37673: EMPTY
37674: LIST
37675: LIST
37676: PUSH
37677: LD_INT 0
37679: PUSH
37680: LD_INT 4
37682: NEG
37683: PUSH
37684: EMPTY
37685: LIST
37686: LIST
37687: PUSH
37688: LD_INT 1
37690: PUSH
37691: LD_INT 3
37693: NEG
37694: PUSH
37695: EMPTY
37696: LIST
37697: LIST
37698: PUSH
37699: LD_INT 1
37701: NEG
37702: PUSH
37703: LD_INT 5
37705: NEG
37706: PUSH
37707: EMPTY
37708: LIST
37709: LIST
37710: PUSH
37711: LD_INT 0
37713: PUSH
37714: LD_INT 5
37716: NEG
37717: PUSH
37718: EMPTY
37719: LIST
37720: LIST
37721: PUSH
37722: LD_INT 1
37724: PUSH
37725: LD_INT 4
37727: NEG
37728: PUSH
37729: EMPTY
37730: LIST
37731: LIST
37732: PUSH
37733: LD_INT 1
37735: NEG
37736: PUSH
37737: LD_INT 6
37739: NEG
37740: PUSH
37741: EMPTY
37742: LIST
37743: LIST
37744: PUSH
37745: LD_INT 0
37747: PUSH
37748: LD_INT 6
37750: NEG
37751: PUSH
37752: EMPTY
37753: LIST
37754: LIST
37755: PUSH
37756: LD_INT 1
37758: PUSH
37759: LD_INT 5
37761: NEG
37762: PUSH
37763: EMPTY
37764: LIST
37765: LIST
37766: PUSH
37767: EMPTY
37768: LIST
37769: LIST
37770: LIST
37771: LIST
37772: LIST
37773: LIST
37774: LIST
37775: LIST
37776: LIST
37777: LIST
37778: LIST
37779: LIST
37780: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
37781: LD_ADDR_VAR 0 30
37785: PUSH
37786: LD_INT 2
37788: PUSH
37789: LD_INT 1
37791: NEG
37792: PUSH
37793: EMPTY
37794: LIST
37795: LIST
37796: PUSH
37797: LD_INT 3
37799: PUSH
37800: LD_INT 0
37802: PUSH
37803: EMPTY
37804: LIST
37805: LIST
37806: PUSH
37807: LD_INT 3
37809: PUSH
37810: LD_INT 1
37812: PUSH
37813: EMPTY
37814: LIST
37815: LIST
37816: PUSH
37817: LD_INT 3
37819: PUSH
37820: LD_INT 1
37822: NEG
37823: PUSH
37824: EMPTY
37825: LIST
37826: LIST
37827: PUSH
37828: LD_INT 4
37830: PUSH
37831: LD_INT 0
37833: PUSH
37834: EMPTY
37835: LIST
37836: LIST
37837: PUSH
37838: LD_INT 4
37840: PUSH
37841: LD_INT 1
37843: PUSH
37844: EMPTY
37845: LIST
37846: LIST
37847: PUSH
37848: LD_INT 4
37850: PUSH
37851: LD_INT 1
37853: NEG
37854: PUSH
37855: EMPTY
37856: LIST
37857: LIST
37858: PUSH
37859: LD_INT 5
37861: PUSH
37862: LD_INT 0
37864: PUSH
37865: EMPTY
37866: LIST
37867: LIST
37868: PUSH
37869: LD_INT 5
37871: PUSH
37872: LD_INT 1
37874: PUSH
37875: EMPTY
37876: LIST
37877: LIST
37878: PUSH
37879: LD_INT 5
37881: PUSH
37882: LD_INT 1
37884: NEG
37885: PUSH
37886: EMPTY
37887: LIST
37888: LIST
37889: PUSH
37890: LD_INT 6
37892: PUSH
37893: LD_INT 0
37895: PUSH
37896: EMPTY
37897: LIST
37898: LIST
37899: PUSH
37900: LD_INT 6
37902: PUSH
37903: LD_INT 1
37905: PUSH
37906: EMPTY
37907: LIST
37908: LIST
37909: PUSH
37910: EMPTY
37911: LIST
37912: LIST
37913: LIST
37914: LIST
37915: LIST
37916: LIST
37917: LIST
37918: LIST
37919: LIST
37920: LIST
37921: LIST
37922: LIST
37923: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
37924: LD_ADDR_VAR 0 31
37928: PUSH
37929: LD_INT 3
37931: PUSH
37932: LD_INT 2
37934: PUSH
37935: EMPTY
37936: LIST
37937: LIST
37938: PUSH
37939: LD_INT 3
37941: PUSH
37942: LD_INT 3
37944: PUSH
37945: EMPTY
37946: LIST
37947: LIST
37948: PUSH
37949: LD_INT 2
37951: PUSH
37952: LD_INT 3
37954: PUSH
37955: EMPTY
37956: LIST
37957: LIST
37958: PUSH
37959: LD_INT 4
37961: PUSH
37962: LD_INT 3
37964: PUSH
37965: EMPTY
37966: LIST
37967: LIST
37968: PUSH
37969: LD_INT 4
37971: PUSH
37972: LD_INT 4
37974: PUSH
37975: EMPTY
37976: LIST
37977: LIST
37978: PUSH
37979: LD_INT 3
37981: PUSH
37982: LD_INT 4
37984: PUSH
37985: EMPTY
37986: LIST
37987: LIST
37988: PUSH
37989: LD_INT 5
37991: PUSH
37992: LD_INT 4
37994: PUSH
37995: EMPTY
37996: LIST
37997: LIST
37998: PUSH
37999: LD_INT 5
38001: PUSH
38002: LD_INT 5
38004: PUSH
38005: EMPTY
38006: LIST
38007: LIST
38008: PUSH
38009: LD_INT 4
38011: PUSH
38012: LD_INT 5
38014: PUSH
38015: EMPTY
38016: LIST
38017: LIST
38018: PUSH
38019: LD_INT 6
38021: PUSH
38022: LD_INT 5
38024: PUSH
38025: EMPTY
38026: LIST
38027: LIST
38028: PUSH
38029: LD_INT 6
38031: PUSH
38032: LD_INT 6
38034: PUSH
38035: EMPTY
38036: LIST
38037: LIST
38038: PUSH
38039: LD_INT 5
38041: PUSH
38042: LD_INT 6
38044: PUSH
38045: EMPTY
38046: LIST
38047: LIST
38048: PUSH
38049: EMPTY
38050: LIST
38051: LIST
38052: LIST
38053: LIST
38054: LIST
38055: LIST
38056: LIST
38057: LIST
38058: LIST
38059: LIST
38060: LIST
38061: LIST
38062: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
38063: LD_ADDR_VAR 0 32
38067: PUSH
38068: LD_INT 1
38070: PUSH
38071: LD_INT 3
38073: PUSH
38074: EMPTY
38075: LIST
38076: LIST
38077: PUSH
38078: LD_INT 0
38080: PUSH
38081: LD_INT 3
38083: PUSH
38084: EMPTY
38085: LIST
38086: LIST
38087: PUSH
38088: LD_INT 1
38090: NEG
38091: PUSH
38092: LD_INT 2
38094: PUSH
38095: EMPTY
38096: LIST
38097: LIST
38098: PUSH
38099: LD_INT 1
38101: PUSH
38102: LD_INT 4
38104: PUSH
38105: EMPTY
38106: LIST
38107: LIST
38108: PUSH
38109: LD_INT 0
38111: PUSH
38112: LD_INT 4
38114: PUSH
38115: EMPTY
38116: LIST
38117: LIST
38118: PUSH
38119: LD_INT 1
38121: NEG
38122: PUSH
38123: LD_INT 3
38125: PUSH
38126: EMPTY
38127: LIST
38128: LIST
38129: PUSH
38130: LD_INT 1
38132: PUSH
38133: LD_INT 5
38135: PUSH
38136: EMPTY
38137: LIST
38138: LIST
38139: PUSH
38140: LD_INT 0
38142: PUSH
38143: LD_INT 5
38145: PUSH
38146: EMPTY
38147: LIST
38148: LIST
38149: PUSH
38150: LD_INT 1
38152: NEG
38153: PUSH
38154: LD_INT 4
38156: PUSH
38157: EMPTY
38158: LIST
38159: LIST
38160: PUSH
38161: LD_INT 1
38163: PUSH
38164: LD_INT 6
38166: PUSH
38167: EMPTY
38168: LIST
38169: LIST
38170: PUSH
38171: LD_INT 0
38173: PUSH
38174: LD_INT 6
38176: PUSH
38177: EMPTY
38178: LIST
38179: LIST
38180: PUSH
38181: LD_INT 1
38183: NEG
38184: PUSH
38185: LD_INT 5
38187: PUSH
38188: EMPTY
38189: LIST
38190: LIST
38191: PUSH
38192: EMPTY
38193: LIST
38194: LIST
38195: LIST
38196: LIST
38197: LIST
38198: LIST
38199: LIST
38200: LIST
38201: LIST
38202: LIST
38203: LIST
38204: LIST
38205: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
38206: LD_ADDR_VAR 0 33
38210: PUSH
38211: LD_INT 2
38213: NEG
38214: PUSH
38215: LD_INT 1
38217: PUSH
38218: EMPTY
38219: LIST
38220: LIST
38221: PUSH
38222: LD_INT 3
38224: NEG
38225: PUSH
38226: LD_INT 0
38228: PUSH
38229: EMPTY
38230: LIST
38231: LIST
38232: PUSH
38233: LD_INT 3
38235: NEG
38236: PUSH
38237: LD_INT 1
38239: NEG
38240: PUSH
38241: EMPTY
38242: LIST
38243: LIST
38244: PUSH
38245: LD_INT 3
38247: NEG
38248: PUSH
38249: LD_INT 1
38251: PUSH
38252: EMPTY
38253: LIST
38254: LIST
38255: PUSH
38256: LD_INT 4
38258: NEG
38259: PUSH
38260: LD_INT 0
38262: PUSH
38263: EMPTY
38264: LIST
38265: LIST
38266: PUSH
38267: LD_INT 4
38269: NEG
38270: PUSH
38271: LD_INT 1
38273: NEG
38274: PUSH
38275: EMPTY
38276: LIST
38277: LIST
38278: PUSH
38279: LD_INT 4
38281: NEG
38282: PUSH
38283: LD_INT 1
38285: PUSH
38286: EMPTY
38287: LIST
38288: LIST
38289: PUSH
38290: LD_INT 5
38292: NEG
38293: PUSH
38294: LD_INT 0
38296: PUSH
38297: EMPTY
38298: LIST
38299: LIST
38300: PUSH
38301: LD_INT 5
38303: NEG
38304: PUSH
38305: LD_INT 1
38307: NEG
38308: PUSH
38309: EMPTY
38310: LIST
38311: LIST
38312: PUSH
38313: LD_INT 5
38315: NEG
38316: PUSH
38317: LD_INT 1
38319: PUSH
38320: EMPTY
38321: LIST
38322: LIST
38323: PUSH
38324: LD_INT 6
38326: NEG
38327: PUSH
38328: LD_INT 0
38330: PUSH
38331: EMPTY
38332: LIST
38333: LIST
38334: PUSH
38335: LD_INT 6
38337: NEG
38338: PUSH
38339: LD_INT 1
38341: NEG
38342: PUSH
38343: EMPTY
38344: LIST
38345: LIST
38346: PUSH
38347: EMPTY
38348: LIST
38349: LIST
38350: LIST
38351: LIST
38352: LIST
38353: LIST
38354: LIST
38355: LIST
38356: LIST
38357: LIST
38358: LIST
38359: LIST
38360: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
38361: LD_ADDR_VAR 0 34
38365: PUSH
38366: LD_INT 2
38368: NEG
38369: PUSH
38370: LD_INT 3
38372: NEG
38373: PUSH
38374: EMPTY
38375: LIST
38376: LIST
38377: PUSH
38378: LD_INT 3
38380: NEG
38381: PUSH
38382: LD_INT 2
38384: NEG
38385: PUSH
38386: EMPTY
38387: LIST
38388: LIST
38389: PUSH
38390: LD_INT 3
38392: NEG
38393: PUSH
38394: LD_INT 3
38396: NEG
38397: PUSH
38398: EMPTY
38399: LIST
38400: LIST
38401: PUSH
38402: LD_INT 3
38404: NEG
38405: PUSH
38406: LD_INT 4
38408: NEG
38409: PUSH
38410: EMPTY
38411: LIST
38412: LIST
38413: PUSH
38414: LD_INT 4
38416: NEG
38417: PUSH
38418: LD_INT 3
38420: NEG
38421: PUSH
38422: EMPTY
38423: LIST
38424: LIST
38425: PUSH
38426: LD_INT 4
38428: NEG
38429: PUSH
38430: LD_INT 4
38432: NEG
38433: PUSH
38434: EMPTY
38435: LIST
38436: LIST
38437: PUSH
38438: LD_INT 4
38440: NEG
38441: PUSH
38442: LD_INT 5
38444: NEG
38445: PUSH
38446: EMPTY
38447: LIST
38448: LIST
38449: PUSH
38450: LD_INT 5
38452: NEG
38453: PUSH
38454: LD_INT 4
38456: NEG
38457: PUSH
38458: EMPTY
38459: LIST
38460: LIST
38461: PUSH
38462: LD_INT 5
38464: NEG
38465: PUSH
38466: LD_INT 5
38468: NEG
38469: PUSH
38470: EMPTY
38471: LIST
38472: LIST
38473: PUSH
38474: LD_INT 5
38476: NEG
38477: PUSH
38478: LD_INT 6
38480: NEG
38481: PUSH
38482: EMPTY
38483: LIST
38484: LIST
38485: PUSH
38486: LD_INT 6
38488: NEG
38489: PUSH
38490: LD_INT 5
38492: NEG
38493: PUSH
38494: EMPTY
38495: LIST
38496: LIST
38497: PUSH
38498: LD_INT 6
38500: NEG
38501: PUSH
38502: LD_INT 6
38504: NEG
38505: PUSH
38506: EMPTY
38507: LIST
38508: LIST
38509: PUSH
38510: EMPTY
38511: LIST
38512: LIST
38513: LIST
38514: LIST
38515: LIST
38516: LIST
38517: LIST
38518: LIST
38519: LIST
38520: LIST
38521: LIST
38522: LIST
38523: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
38524: LD_ADDR_VAR 0 41
38528: PUSH
38529: LD_INT 0
38531: PUSH
38532: LD_INT 2
38534: NEG
38535: PUSH
38536: EMPTY
38537: LIST
38538: LIST
38539: PUSH
38540: LD_INT 1
38542: NEG
38543: PUSH
38544: LD_INT 3
38546: NEG
38547: PUSH
38548: EMPTY
38549: LIST
38550: LIST
38551: PUSH
38552: LD_INT 1
38554: PUSH
38555: LD_INT 2
38557: NEG
38558: PUSH
38559: EMPTY
38560: LIST
38561: LIST
38562: PUSH
38563: EMPTY
38564: LIST
38565: LIST
38566: LIST
38567: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
38568: LD_ADDR_VAR 0 42
38572: PUSH
38573: LD_INT 2
38575: PUSH
38576: LD_INT 0
38578: PUSH
38579: EMPTY
38580: LIST
38581: LIST
38582: PUSH
38583: LD_INT 2
38585: PUSH
38586: LD_INT 1
38588: NEG
38589: PUSH
38590: EMPTY
38591: LIST
38592: LIST
38593: PUSH
38594: LD_INT 3
38596: PUSH
38597: LD_INT 1
38599: PUSH
38600: EMPTY
38601: LIST
38602: LIST
38603: PUSH
38604: EMPTY
38605: LIST
38606: LIST
38607: LIST
38608: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
38609: LD_ADDR_VAR 0 43
38613: PUSH
38614: LD_INT 2
38616: PUSH
38617: LD_INT 2
38619: PUSH
38620: EMPTY
38621: LIST
38622: LIST
38623: PUSH
38624: LD_INT 3
38626: PUSH
38627: LD_INT 2
38629: PUSH
38630: EMPTY
38631: LIST
38632: LIST
38633: PUSH
38634: LD_INT 2
38636: PUSH
38637: LD_INT 3
38639: PUSH
38640: EMPTY
38641: LIST
38642: LIST
38643: PUSH
38644: EMPTY
38645: LIST
38646: LIST
38647: LIST
38648: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
38649: LD_ADDR_VAR 0 44
38653: PUSH
38654: LD_INT 0
38656: PUSH
38657: LD_INT 2
38659: PUSH
38660: EMPTY
38661: LIST
38662: LIST
38663: PUSH
38664: LD_INT 1
38666: PUSH
38667: LD_INT 3
38669: PUSH
38670: EMPTY
38671: LIST
38672: LIST
38673: PUSH
38674: LD_INT 1
38676: NEG
38677: PUSH
38678: LD_INT 2
38680: PUSH
38681: EMPTY
38682: LIST
38683: LIST
38684: PUSH
38685: EMPTY
38686: LIST
38687: LIST
38688: LIST
38689: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38690: LD_ADDR_VAR 0 45
38694: PUSH
38695: LD_INT 2
38697: NEG
38698: PUSH
38699: LD_INT 0
38701: PUSH
38702: EMPTY
38703: LIST
38704: LIST
38705: PUSH
38706: LD_INT 2
38708: NEG
38709: PUSH
38710: LD_INT 1
38712: PUSH
38713: EMPTY
38714: LIST
38715: LIST
38716: PUSH
38717: LD_INT 3
38719: NEG
38720: PUSH
38721: LD_INT 1
38723: NEG
38724: PUSH
38725: EMPTY
38726: LIST
38727: LIST
38728: PUSH
38729: EMPTY
38730: LIST
38731: LIST
38732: LIST
38733: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
38734: LD_ADDR_VAR 0 46
38738: PUSH
38739: LD_INT 2
38741: NEG
38742: PUSH
38743: LD_INT 2
38745: NEG
38746: PUSH
38747: EMPTY
38748: LIST
38749: LIST
38750: PUSH
38751: LD_INT 2
38753: NEG
38754: PUSH
38755: LD_INT 3
38757: NEG
38758: PUSH
38759: EMPTY
38760: LIST
38761: LIST
38762: PUSH
38763: LD_INT 3
38765: NEG
38766: PUSH
38767: LD_INT 2
38769: NEG
38770: PUSH
38771: EMPTY
38772: LIST
38773: LIST
38774: PUSH
38775: EMPTY
38776: LIST
38777: LIST
38778: LIST
38779: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
38780: LD_ADDR_VAR 0 47
38784: PUSH
38785: LD_INT 2
38787: NEG
38788: PUSH
38789: LD_INT 3
38791: NEG
38792: PUSH
38793: EMPTY
38794: LIST
38795: LIST
38796: PUSH
38797: LD_INT 1
38799: NEG
38800: PUSH
38801: LD_INT 3
38803: NEG
38804: PUSH
38805: EMPTY
38806: LIST
38807: LIST
38808: PUSH
38809: EMPTY
38810: LIST
38811: LIST
38812: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
38813: LD_ADDR_VAR 0 48
38817: PUSH
38818: LD_INT 1
38820: PUSH
38821: LD_INT 2
38823: NEG
38824: PUSH
38825: EMPTY
38826: LIST
38827: LIST
38828: PUSH
38829: LD_INT 2
38831: PUSH
38832: LD_INT 1
38834: NEG
38835: PUSH
38836: EMPTY
38837: LIST
38838: LIST
38839: PUSH
38840: EMPTY
38841: LIST
38842: LIST
38843: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
38844: LD_ADDR_VAR 0 49
38848: PUSH
38849: LD_INT 3
38851: PUSH
38852: LD_INT 1
38854: PUSH
38855: EMPTY
38856: LIST
38857: LIST
38858: PUSH
38859: LD_INT 3
38861: PUSH
38862: LD_INT 2
38864: PUSH
38865: EMPTY
38866: LIST
38867: LIST
38868: PUSH
38869: EMPTY
38870: LIST
38871: LIST
38872: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
38873: LD_ADDR_VAR 0 50
38877: PUSH
38878: LD_INT 2
38880: PUSH
38881: LD_INT 3
38883: PUSH
38884: EMPTY
38885: LIST
38886: LIST
38887: PUSH
38888: LD_INT 1
38890: PUSH
38891: LD_INT 3
38893: PUSH
38894: EMPTY
38895: LIST
38896: LIST
38897: PUSH
38898: EMPTY
38899: LIST
38900: LIST
38901: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
38902: LD_ADDR_VAR 0 51
38906: PUSH
38907: LD_INT 1
38909: NEG
38910: PUSH
38911: LD_INT 2
38913: PUSH
38914: EMPTY
38915: LIST
38916: LIST
38917: PUSH
38918: LD_INT 2
38920: NEG
38921: PUSH
38922: LD_INT 1
38924: PUSH
38925: EMPTY
38926: LIST
38927: LIST
38928: PUSH
38929: EMPTY
38930: LIST
38931: LIST
38932: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
38933: LD_ADDR_VAR 0 52
38937: PUSH
38938: LD_INT 3
38940: NEG
38941: PUSH
38942: LD_INT 1
38944: NEG
38945: PUSH
38946: EMPTY
38947: LIST
38948: LIST
38949: PUSH
38950: LD_INT 3
38952: NEG
38953: PUSH
38954: LD_INT 2
38956: NEG
38957: PUSH
38958: EMPTY
38959: LIST
38960: LIST
38961: PUSH
38962: EMPTY
38963: LIST
38964: LIST
38965: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
38966: LD_ADDR_VAR 0 53
38970: PUSH
38971: LD_INT 1
38973: NEG
38974: PUSH
38975: LD_INT 3
38977: NEG
38978: PUSH
38979: EMPTY
38980: LIST
38981: LIST
38982: PUSH
38983: LD_INT 0
38985: PUSH
38986: LD_INT 3
38988: NEG
38989: PUSH
38990: EMPTY
38991: LIST
38992: LIST
38993: PUSH
38994: LD_INT 1
38996: PUSH
38997: LD_INT 2
38999: NEG
39000: PUSH
39001: EMPTY
39002: LIST
39003: LIST
39004: PUSH
39005: EMPTY
39006: LIST
39007: LIST
39008: LIST
39009: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39010: LD_ADDR_VAR 0 54
39014: PUSH
39015: LD_INT 2
39017: PUSH
39018: LD_INT 1
39020: NEG
39021: PUSH
39022: EMPTY
39023: LIST
39024: LIST
39025: PUSH
39026: LD_INT 3
39028: PUSH
39029: LD_INT 0
39031: PUSH
39032: EMPTY
39033: LIST
39034: LIST
39035: PUSH
39036: LD_INT 3
39038: PUSH
39039: LD_INT 1
39041: PUSH
39042: EMPTY
39043: LIST
39044: LIST
39045: PUSH
39046: EMPTY
39047: LIST
39048: LIST
39049: LIST
39050: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39051: LD_ADDR_VAR 0 55
39055: PUSH
39056: LD_INT 3
39058: PUSH
39059: LD_INT 2
39061: PUSH
39062: EMPTY
39063: LIST
39064: LIST
39065: PUSH
39066: LD_INT 3
39068: PUSH
39069: LD_INT 3
39071: PUSH
39072: EMPTY
39073: LIST
39074: LIST
39075: PUSH
39076: LD_INT 2
39078: PUSH
39079: LD_INT 3
39081: PUSH
39082: EMPTY
39083: LIST
39084: LIST
39085: PUSH
39086: EMPTY
39087: LIST
39088: LIST
39089: LIST
39090: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39091: LD_ADDR_VAR 0 56
39095: PUSH
39096: LD_INT 1
39098: PUSH
39099: LD_INT 3
39101: PUSH
39102: EMPTY
39103: LIST
39104: LIST
39105: PUSH
39106: LD_INT 0
39108: PUSH
39109: LD_INT 3
39111: PUSH
39112: EMPTY
39113: LIST
39114: LIST
39115: PUSH
39116: LD_INT 1
39118: NEG
39119: PUSH
39120: LD_INT 2
39122: PUSH
39123: EMPTY
39124: LIST
39125: LIST
39126: PUSH
39127: EMPTY
39128: LIST
39129: LIST
39130: LIST
39131: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39132: LD_ADDR_VAR 0 57
39136: PUSH
39137: LD_INT 2
39139: NEG
39140: PUSH
39141: LD_INT 1
39143: PUSH
39144: EMPTY
39145: LIST
39146: LIST
39147: PUSH
39148: LD_INT 3
39150: NEG
39151: PUSH
39152: LD_INT 0
39154: PUSH
39155: EMPTY
39156: LIST
39157: LIST
39158: PUSH
39159: LD_INT 3
39161: NEG
39162: PUSH
39163: LD_INT 1
39165: NEG
39166: PUSH
39167: EMPTY
39168: LIST
39169: LIST
39170: PUSH
39171: EMPTY
39172: LIST
39173: LIST
39174: LIST
39175: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39176: LD_ADDR_VAR 0 58
39180: PUSH
39181: LD_INT 2
39183: NEG
39184: PUSH
39185: LD_INT 3
39187: NEG
39188: PUSH
39189: EMPTY
39190: LIST
39191: LIST
39192: PUSH
39193: LD_INT 3
39195: NEG
39196: PUSH
39197: LD_INT 2
39199: NEG
39200: PUSH
39201: EMPTY
39202: LIST
39203: LIST
39204: PUSH
39205: LD_INT 3
39207: NEG
39208: PUSH
39209: LD_INT 3
39211: NEG
39212: PUSH
39213: EMPTY
39214: LIST
39215: LIST
39216: PUSH
39217: EMPTY
39218: LIST
39219: LIST
39220: LIST
39221: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
39222: LD_ADDR_VAR 0 59
39226: PUSH
39227: LD_INT 1
39229: NEG
39230: PUSH
39231: LD_INT 2
39233: NEG
39234: PUSH
39235: EMPTY
39236: LIST
39237: LIST
39238: PUSH
39239: LD_INT 0
39241: PUSH
39242: LD_INT 2
39244: NEG
39245: PUSH
39246: EMPTY
39247: LIST
39248: LIST
39249: PUSH
39250: LD_INT 1
39252: PUSH
39253: LD_INT 1
39255: NEG
39256: PUSH
39257: EMPTY
39258: LIST
39259: LIST
39260: PUSH
39261: EMPTY
39262: LIST
39263: LIST
39264: LIST
39265: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
39266: LD_ADDR_VAR 0 60
39270: PUSH
39271: LD_INT 1
39273: PUSH
39274: LD_INT 1
39276: NEG
39277: PUSH
39278: EMPTY
39279: LIST
39280: LIST
39281: PUSH
39282: LD_INT 2
39284: PUSH
39285: LD_INT 0
39287: PUSH
39288: EMPTY
39289: LIST
39290: LIST
39291: PUSH
39292: LD_INT 2
39294: PUSH
39295: LD_INT 1
39297: PUSH
39298: EMPTY
39299: LIST
39300: LIST
39301: PUSH
39302: EMPTY
39303: LIST
39304: LIST
39305: LIST
39306: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
39307: LD_ADDR_VAR 0 61
39311: PUSH
39312: LD_INT 2
39314: PUSH
39315: LD_INT 1
39317: PUSH
39318: EMPTY
39319: LIST
39320: LIST
39321: PUSH
39322: LD_INT 2
39324: PUSH
39325: LD_INT 2
39327: PUSH
39328: EMPTY
39329: LIST
39330: LIST
39331: PUSH
39332: LD_INT 1
39334: PUSH
39335: LD_INT 2
39337: PUSH
39338: EMPTY
39339: LIST
39340: LIST
39341: PUSH
39342: EMPTY
39343: LIST
39344: LIST
39345: LIST
39346: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
39347: LD_ADDR_VAR 0 62
39351: PUSH
39352: LD_INT 1
39354: PUSH
39355: LD_INT 2
39357: PUSH
39358: EMPTY
39359: LIST
39360: LIST
39361: PUSH
39362: LD_INT 0
39364: PUSH
39365: LD_INT 2
39367: PUSH
39368: EMPTY
39369: LIST
39370: LIST
39371: PUSH
39372: LD_INT 1
39374: NEG
39375: PUSH
39376: LD_INT 1
39378: PUSH
39379: EMPTY
39380: LIST
39381: LIST
39382: PUSH
39383: EMPTY
39384: LIST
39385: LIST
39386: LIST
39387: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
39388: LD_ADDR_VAR 0 63
39392: PUSH
39393: LD_INT 1
39395: NEG
39396: PUSH
39397: LD_INT 1
39399: PUSH
39400: EMPTY
39401: LIST
39402: LIST
39403: PUSH
39404: LD_INT 2
39406: NEG
39407: PUSH
39408: LD_INT 0
39410: PUSH
39411: EMPTY
39412: LIST
39413: LIST
39414: PUSH
39415: LD_INT 2
39417: NEG
39418: PUSH
39419: LD_INT 1
39421: NEG
39422: PUSH
39423: EMPTY
39424: LIST
39425: LIST
39426: PUSH
39427: EMPTY
39428: LIST
39429: LIST
39430: LIST
39431: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39432: LD_ADDR_VAR 0 64
39436: PUSH
39437: LD_INT 1
39439: NEG
39440: PUSH
39441: LD_INT 2
39443: NEG
39444: PUSH
39445: EMPTY
39446: LIST
39447: LIST
39448: PUSH
39449: LD_INT 2
39451: NEG
39452: PUSH
39453: LD_INT 1
39455: NEG
39456: PUSH
39457: EMPTY
39458: LIST
39459: LIST
39460: PUSH
39461: LD_INT 2
39463: NEG
39464: PUSH
39465: LD_INT 2
39467: NEG
39468: PUSH
39469: EMPTY
39470: LIST
39471: LIST
39472: PUSH
39473: EMPTY
39474: LIST
39475: LIST
39476: LIST
39477: ST_TO_ADDR
// end ; 2 :
39478: GO 42744
39480: LD_INT 2
39482: DOUBLE
39483: EQUAL
39484: IFTRUE 39488
39486: GO 42743
39488: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
39489: LD_ADDR_VAR 0 29
39493: PUSH
39494: LD_INT 4
39496: PUSH
39497: LD_INT 0
39499: PUSH
39500: EMPTY
39501: LIST
39502: LIST
39503: PUSH
39504: LD_INT 4
39506: PUSH
39507: LD_INT 1
39509: NEG
39510: PUSH
39511: EMPTY
39512: LIST
39513: LIST
39514: PUSH
39515: LD_INT 5
39517: PUSH
39518: LD_INT 0
39520: PUSH
39521: EMPTY
39522: LIST
39523: LIST
39524: PUSH
39525: LD_INT 5
39527: PUSH
39528: LD_INT 1
39530: PUSH
39531: EMPTY
39532: LIST
39533: LIST
39534: PUSH
39535: LD_INT 4
39537: PUSH
39538: LD_INT 1
39540: PUSH
39541: EMPTY
39542: LIST
39543: LIST
39544: PUSH
39545: LD_INT 3
39547: PUSH
39548: LD_INT 0
39550: PUSH
39551: EMPTY
39552: LIST
39553: LIST
39554: PUSH
39555: LD_INT 3
39557: PUSH
39558: LD_INT 1
39560: NEG
39561: PUSH
39562: EMPTY
39563: LIST
39564: LIST
39565: PUSH
39566: LD_INT 3
39568: PUSH
39569: LD_INT 2
39571: NEG
39572: PUSH
39573: EMPTY
39574: LIST
39575: LIST
39576: PUSH
39577: LD_INT 5
39579: PUSH
39580: LD_INT 2
39582: PUSH
39583: EMPTY
39584: LIST
39585: LIST
39586: PUSH
39587: LD_INT 3
39589: PUSH
39590: LD_INT 3
39592: PUSH
39593: EMPTY
39594: LIST
39595: LIST
39596: PUSH
39597: LD_INT 3
39599: PUSH
39600: LD_INT 2
39602: PUSH
39603: EMPTY
39604: LIST
39605: LIST
39606: PUSH
39607: LD_INT 4
39609: PUSH
39610: LD_INT 3
39612: PUSH
39613: EMPTY
39614: LIST
39615: LIST
39616: PUSH
39617: LD_INT 4
39619: PUSH
39620: LD_INT 4
39622: PUSH
39623: EMPTY
39624: LIST
39625: LIST
39626: PUSH
39627: LD_INT 3
39629: PUSH
39630: LD_INT 4
39632: PUSH
39633: EMPTY
39634: LIST
39635: LIST
39636: PUSH
39637: LD_INT 2
39639: PUSH
39640: LD_INT 3
39642: PUSH
39643: EMPTY
39644: LIST
39645: LIST
39646: PUSH
39647: LD_INT 2
39649: PUSH
39650: LD_INT 2
39652: PUSH
39653: EMPTY
39654: LIST
39655: LIST
39656: PUSH
39657: LD_INT 4
39659: PUSH
39660: LD_INT 2
39662: PUSH
39663: EMPTY
39664: LIST
39665: LIST
39666: PUSH
39667: LD_INT 2
39669: PUSH
39670: LD_INT 4
39672: PUSH
39673: EMPTY
39674: LIST
39675: LIST
39676: PUSH
39677: LD_INT 0
39679: PUSH
39680: LD_INT 4
39682: PUSH
39683: EMPTY
39684: LIST
39685: LIST
39686: PUSH
39687: LD_INT 0
39689: PUSH
39690: LD_INT 3
39692: PUSH
39693: EMPTY
39694: LIST
39695: LIST
39696: PUSH
39697: LD_INT 1
39699: PUSH
39700: LD_INT 4
39702: PUSH
39703: EMPTY
39704: LIST
39705: LIST
39706: PUSH
39707: LD_INT 1
39709: PUSH
39710: LD_INT 5
39712: PUSH
39713: EMPTY
39714: LIST
39715: LIST
39716: PUSH
39717: LD_INT 0
39719: PUSH
39720: LD_INT 5
39722: PUSH
39723: EMPTY
39724: LIST
39725: LIST
39726: PUSH
39727: LD_INT 1
39729: NEG
39730: PUSH
39731: LD_INT 4
39733: PUSH
39734: EMPTY
39735: LIST
39736: LIST
39737: PUSH
39738: LD_INT 1
39740: NEG
39741: PUSH
39742: LD_INT 3
39744: PUSH
39745: EMPTY
39746: LIST
39747: LIST
39748: PUSH
39749: LD_INT 2
39751: PUSH
39752: LD_INT 5
39754: PUSH
39755: EMPTY
39756: LIST
39757: LIST
39758: PUSH
39759: LD_INT 2
39761: NEG
39762: PUSH
39763: LD_INT 3
39765: PUSH
39766: EMPTY
39767: LIST
39768: LIST
39769: PUSH
39770: LD_INT 3
39772: NEG
39773: PUSH
39774: LD_INT 0
39776: PUSH
39777: EMPTY
39778: LIST
39779: LIST
39780: PUSH
39781: LD_INT 3
39783: NEG
39784: PUSH
39785: LD_INT 1
39787: NEG
39788: PUSH
39789: EMPTY
39790: LIST
39791: LIST
39792: PUSH
39793: LD_INT 2
39795: NEG
39796: PUSH
39797: LD_INT 0
39799: PUSH
39800: EMPTY
39801: LIST
39802: LIST
39803: PUSH
39804: LD_INT 2
39806: NEG
39807: PUSH
39808: LD_INT 1
39810: PUSH
39811: EMPTY
39812: LIST
39813: LIST
39814: PUSH
39815: LD_INT 3
39817: NEG
39818: PUSH
39819: LD_INT 1
39821: PUSH
39822: EMPTY
39823: LIST
39824: LIST
39825: PUSH
39826: LD_INT 4
39828: NEG
39829: PUSH
39830: LD_INT 0
39832: PUSH
39833: EMPTY
39834: LIST
39835: LIST
39836: PUSH
39837: LD_INT 4
39839: NEG
39840: PUSH
39841: LD_INT 1
39843: NEG
39844: PUSH
39845: EMPTY
39846: LIST
39847: LIST
39848: PUSH
39849: LD_INT 4
39851: NEG
39852: PUSH
39853: LD_INT 2
39855: NEG
39856: PUSH
39857: EMPTY
39858: LIST
39859: LIST
39860: PUSH
39861: LD_INT 2
39863: NEG
39864: PUSH
39865: LD_INT 2
39867: PUSH
39868: EMPTY
39869: LIST
39870: LIST
39871: PUSH
39872: LD_INT 4
39874: NEG
39875: PUSH
39876: LD_INT 4
39878: NEG
39879: PUSH
39880: EMPTY
39881: LIST
39882: LIST
39883: PUSH
39884: LD_INT 4
39886: NEG
39887: PUSH
39888: LD_INT 5
39890: NEG
39891: PUSH
39892: EMPTY
39893: LIST
39894: LIST
39895: PUSH
39896: LD_INT 3
39898: NEG
39899: PUSH
39900: LD_INT 4
39902: NEG
39903: PUSH
39904: EMPTY
39905: LIST
39906: LIST
39907: PUSH
39908: LD_INT 3
39910: NEG
39911: PUSH
39912: LD_INT 3
39914: NEG
39915: PUSH
39916: EMPTY
39917: LIST
39918: LIST
39919: PUSH
39920: LD_INT 4
39922: NEG
39923: PUSH
39924: LD_INT 3
39926: NEG
39927: PUSH
39928: EMPTY
39929: LIST
39930: LIST
39931: PUSH
39932: LD_INT 5
39934: NEG
39935: PUSH
39936: LD_INT 4
39938: NEG
39939: PUSH
39940: EMPTY
39941: LIST
39942: LIST
39943: PUSH
39944: LD_INT 5
39946: NEG
39947: PUSH
39948: LD_INT 5
39950: NEG
39951: PUSH
39952: EMPTY
39953: LIST
39954: LIST
39955: PUSH
39956: LD_INT 3
39958: NEG
39959: PUSH
39960: LD_INT 5
39962: NEG
39963: PUSH
39964: EMPTY
39965: LIST
39966: LIST
39967: PUSH
39968: LD_INT 5
39970: NEG
39971: PUSH
39972: LD_INT 3
39974: NEG
39975: PUSH
39976: EMPTY
39977: LIST
39978: LIST
39979: PUSH
39980: EMPTY
39981: LIST
39982: LIST
39983: LIST
39984: LIST
39985: LIST
39986: LIST
39987: LIST
39988: LIST
39989: LIST
39990: LIST
39991: LIST
39992: LIST
39993: LIST
39994: LIST
39995: LIST
39996: LIST
39997: LIST
39998: LIST
39999: LIST
40000: LIST
40001: LIST
40002: LIST
40003: LIST
40004: LIST
40005: LIST
40006: LIST
40007: LIST
40008: LIST
40009: LIST
40010: LIST
40011: LIST
40012: LIST
40013: LIST
40014: LIST
40015: LIST
40016: LIST
40017: LIST
40018: LIST
40019: LIST
40020: LIST
40021: LIST
40022: LIST
40023: LIST
40024: LIST
40025: LIST
40026: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
40027: LD_ADDR_VAR 0 30
40031: PUSH
40032: LD_INT 4
40034: PUSH
40035: LD_INT 4
40037: PUSH
40038: EMPTY
40039: LIST
40040: LIST
40041: PUSH
40042: LD_INT 4
40044: PUSH
40045: LD_INT 3
40047: PUSH
40048: EMPTY
40049: LIST
40050: LIST
40051: PUSH
40052: LD_INT 5
40054: PUSH
40055: LD_INT 4
40057: PUSH
40058: EMPTY
40059: LIST
40060: LIST
40061: PUSH
40062: LD_INT 5
40064: PUSH
40065: LD_INT 5
40067: PUSH
40068: EMPTY
40069: LIST
40070: LIST
40071: PUSH
40072: LD_INT 4
40074: PUSH
40075: LD_INT 5
40077: PUSH
40078: EMPTY
40079: LIST
40080: LIST
40081: PUSH
40082: LD_INT 3
40084: PUSH
40085: LD_INT 4
40087: PUSH
40088: EMPTY
40089: LIST
40090: LIST
40091: PUSH
40092: LD_INT 3
40094: PUSH
40095: LD_INT 3
40097: PUSH
40098: EMPTY
40099: LIST
40100: LIST
40101: PUSH
40102: LD_INT 5
40104: PUSH
40105: LD_INT 3
40107: PUSH
40108: EMPTY
40109: LIST
40110: LIST
40111: PUSH
40112: LD_INT 3
40114: PUSH
40115: LD_INT 5
40117: PUSH
40118: EMPTY
40119: LIST
40120: LIST
40121: PUSH
40122: LD_INT 0
40124: PUSH
40125: LD_INT 3
40127: PUSH
40128: EMPTY
40129: LIST
40130: LIST
40131: PUSH
40132: LD_INT 0
40134: PUSH
40135: LD_INT 2
40137: PUSH
40138: EMPTY
40139: LIST
40140: LIST
40141: PUSH
40142: LD_INT 1
40144: PUSH
40145: LD_INT 3
40147: PUSH
40148: EMPTY
40149: LIST
40150: LIST
40151: PUSH
40152: LD_INT 1
40154: PUSH
40155: LD_INT 4
40157: PUSH
40158: EMPTY
40159: LIST
40160: LIST
40161: PUSH
40162: LD_INT 0
40164: PUSH
40165: LD_INT 4
40167: PUSH
40168: EMPTY
40169: LIST
40170: LIST
40171: PUSH
40172: LD_INT 1
40174: NEG
40175: PUSH
40176: LD_INT 3
40178: PUSH
40179: EMPTY
40180: LIST
40181: LIST
40182: PUSH
40183: LD_INT 1
40185: NEG
40186: PUSH
40187: LD_INT 2
40189: PUSH
40190: EMPTY
40191: LIST
40192: LIST
40193: PUSH
40194: LD_INT 2
40196: PUSH
40197: LD_INT 4
40199: PUSH
40200: EMPTY
40201: LIST
40202: LIST
40203: PUSH
40204: LD_INT 2
40206: NEG
40207: PUSH
40208: LD_INT 2
40210: PUSH
40211: EMPTY
40212: LIST
40213: LIST
40214: PUSH
40215: LD_INT 4
40217: NEG
40218: PUSH
40219: LD_INT 0
40221: PUSH
40222: EMPTY
40223: LIST
40224: LIST
40225: PUSH
40226: LD_INT 4
40228: NEG
40229: PUSH
40230: LD_INT 1
40232: NEG
40233: PUSH
40234: EMPTY
40235: LIST
40236: LIST
40237: PUSH
40238: LD_INT 3
40240: NEG
40241: PUSH
40242: LD_INT 0
40244: PUSH
40245: EMPTY
40246: LIST
40247: LIST
40248: PUSH
40249: LD_INT 3
40251: NEG
40252: PUSH
40253: LD_INT 1
40255: PUSH
40256: EMPTY
40257: LIST
40258: LIST
40259: PUSH
40260: LD_INT 4
40262: NEG
40263: PUSH
40264: LD_INT 1
40266: PUSH
40267: EMPTY
40268: LIST
40269: LIST
40270: PUSH
40271: LD_INT 5
40273: NEG
40274: PUSH
40275: LD_INT 0
40277: PUSH
40278: EMPTY
40279: LIST
40280: LIST
40281: PUSH
40282: LD_INT 5
40284: NEG
40285: PUSH
40286: LD_INT 1
40288: NEG
40289: PUSH
40290: EMPTY
40291: LIST
40292: LIST
40293: PUSH
40294: LD_INT 5
40296: NEG
40297: PUSH
40298: LD_INT 2
40300: NEG
40301: PUSH
40302: EMPTY
40303: LIST
40304: LIST
40305: PUSH
40306: LD_INT 3
40308: NEG
40309: PUSH
40310: LD_INT 2
40312: PUSH
40313: EMPTY
40314: LIST
40315: LIST
40316: PUSH
40317: LD_INT 3
40319: NEG
40320: PUSH
40321: LD_INT 3
40323: NEG
40324: PUSH
40325: EMPTY
40326: LIST
40327: LIST
40328: PUSH
40329: LD_INT 3
40331: NEG
40332: PUSH
40333: LD_INT 4
40335: NEG
40336: PUSH
40337: EMPTY
40338: LIST
40339: LIST
40340: PUSH
40341: LD_INT 2
40343: NEG
40344: PUSH
40345: LD_INT 3
40347: NEG
40348: PUSH
40349: EMPTY
40350: LIST
40351: LIST
40352: PUSH
40353: LD_INT 2
40355: NEG
40356: PUSH
40357: LD_INT 2
40359: NEG
40360: PUSH
40361: EMPTY
40362: LIST
40363: LIST
40364: PUSH
40365: LD_INT 3
40367: NEG
40368: PUSH
40369: LD_INT 2
40371: NEG
40372: PUSH
40373: EMPTY
40374: LIST
40375: LIST
40376: PUSH
40377: LD_INT 4
40379: NEG
40380: PUSH
40381: LD_INT 3
40383: NEG
40384: PUSH
40385: EMPTY
40386: LIST
40387: LIST
40388: PUSH
40389: LD_INT 4
40391: NEG
40392: PUSH
40393: LD_INT 4
40395: NEG
40396: PUSH
40397: EMPTY
40398: LIST
40399: LIST
40400: PUSH
40401: LD_INT 2
40403: NEG
40404: PUSH
40405: LD_INT 4
40407: NEG
40408: PUSH
40409: EMPTY
40410: LIST
40411: LIST
40412: PUSH
40413: LD_INT 4
40415: NEG
40416: PUSH
40417: LD_INT 2
40419: NEG
40420: PUSH
40421: EMPTY
40422: LIST
40423: LIST
40424: PUSH
40425: LD_INT 0
40427: PUSH
40428: LD_INT 4
40430: NEG
40431: PUSH
40432: EMPTY
40433: LIST
40434: LIST
40435: PUSH
40436: LD_INT 0
40438: PUSH
40439: LD_INT 5
40441: NEG
40442: PUSH
40443: EMPTY
40444: LIST
40445: LIST
40446: PUSH
40447: LD_INT 1
40449: PUSH
40450: LD_INT 4
40452: NEG
40453: PUSH
40454: EMPTY
40455: LIST
40456: LIST
40457: PUSH
40458: LD_INT 1
40460: PUSH
40461: LD_INT 3
40463: NEG
40464: PUSH
40465: EMPTY
40466: LIST
40467: LIST
40468: PUSH
40469: LD_INT 0
40471: PUSH
40472: LD_INT 3
40474: NEG
40475: PUSH
40476: EMPTY
40477: LIST
40478: LIST
40479: PUSH
40480: LD_INT 1
40482: NEG
40483: PUSH
40484: LD_INT 4
40486: NEG
40487: PUSH
40488: EMPTY
40489: LIST
40490: LIST
40491: PUSH
40492: LD_INT 1
40494: NEG
40495: PUSH
40496: LD_INT 5
40498: NEG
40499: PUSH
40500: EMPTY
40501: LIST
40502: LIST
40503: PUSH
40504: LD_INT 2
40506: PUSH
40507: LD_INT 3
40509: NEG
40510: PUSH
40511: EMPTY
40512: LIST
40513: LIST
40514: PUSH
40515: LD_INT 2
40517: NEG
40518: PUSH
40519: LD_INT 5
40521: NEG
40522: PUSH
40523: EMPTY
40524: LIST
40525: LIST
40526: PUSH
40527: EMPTY
40528: LIST
40529: LIST
40530: LIST
40531: LIST
40532: LIST
40533: LIST
40534: LIST
40535: LIST
40536: LIST
40537: LIST
40538: LIST
40539: LIST
40540: LIST
40541: LIST
40542: LIST
40543: LIST
40544: LIST
40545: LIST
40546: LIST
40547: LIST
40548: LIST
40549: LIST
40550: LIST
40551: LIST
40552: LIST
40553: LIST
40554: LIST
40555: LIST
40556: LIST
40557: LIST
40558: LIST
40559: LIST
40560: LIST
40561: LIST
40562: LIST
40563: LIST
40564: LIST
40565: LIST
40566: LIST
40567: LIST
40568: LIST
40569: LIST
40570: LIST
40571: LIST
40572: LIST
40573: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
40574: LD_ADDR_VAR 0 31
40578: PUSH
40579: LD_INT 0
40581: PUSH
40582: LD_INT 4
40584: PUSH
40585: EMPTY
40586: LIST
40587: LIST
40588: PUSH
40589: LD_INT 0
40591: PUSH
40592: LD_INT 3
40594: PUSH
40595: EMPTY
40596: LIST
40597: LIST
40598: PUSH
40599: LD_INT 1
40601: PUSH
40602: LD_INT 4
40604: PUSH
40605: EMPTY
40606: LIST
40607: LIST
40608: PUSH
40609: LD_INT 1
40611: PUSH
40612: LD_INT 5
40614: PUSH
40615: EMPTY
40616: LIST
40617: LIST
40618: PUSH
40619: LD_INT 0
40621: PUSH
40622: LD_INT 5
40624: PUSH
40625: EMPTY
40626: LIST
40627: LIST
40628: PUSH
40629: LD_INT 1
40631: NEG
40632: PUSH
40633: LD_INT 4
40635: PUSH
40636: EMPTY
40637: LIST
40638: LIST
40639: PUSH
40640: LD_INT 1
40642: NEG
40643: PUSH
40644: LD_INT 3
40646: PUSH
40647: EMPTY
40648: LIST
40649: LIST
40650: PUSH
40651: LD_INT 2
40653: PUSH
40654: LD_INT 5
40656: PUSH
40657: EMPTY
40658: LIST
40659: LIST
40660: PUSH
40661: LD_INT 2
40663: NEG
40664: PUSH
40665: LD_INT 3
40667: PUSH
40668: EMPTY
40669: LIST
40670: LIST
40671: PUSH
40672: LD_INT 3
40674: NEG
40675: PUSH
40676: LD_INT 0
40678: PUSH
40679: EMPTY
40680: LIST
40681: LIST
40682: PUSH
40683: LD_INT 3
40685: NEG
40686: PUSH
40687: LD_INT 1
40689: NEG
40690: PUSH
40691: EMPTY
40692: LIST
40693: LIST
40694: PUSH
40695: LD_INT 2
40697: NEG
40698: PUSH
40699: LD_INT 0
40701: PUSH
40702: EMPTY
40703: LIST
40704: LIST
40705: PUSH
40706: LD_INT 2
40708: NEG
40709: PUSH
40710: LD_INT 1
40712: PUSH
40713: EMPTY
40714: LIST
40715: LIST
40716: PUSH
40717: LD_INT 3
40719: NEG
40720: PUSH
40721: LD_INT 1
40723: PUSH
40724: EMPTY
40725: LIST
40726: LIST
40727: PUSH
40728: LD_INT 4
40730: NEG
40731: PUSH
40732: LD_INT 0
40734: PUSH
40735: EMPTY
40736: LIST
40737: LIST
40738: PUSH
40739: LD_INT 4
40741: NEG
40742: PUSH
40743: LD_INT 1
40745: NEG
40746: PUSH
40747: EMPTY
40748: LIST
40749: LIST
40750: PUSH
40751: LD_INT 4
40753: NEG
40754: PUSH
40755: LD_INT 2
40757: NEG
40758: PUSH
40759: EMPTY
40760: LIST
40761: LIST
40762: PUSH
40763: LD_INT 2
40765: NEG
40766: PUSH
40767: LD_INT 2
40769: PUSH
40770: EMPTY
40771: LIST
40772: LIST
40773: PUSH
40774: LD_INT 4
40776: NEG
40777: PUSH
40778: LD_INT 4
40780: NEG
40781: PUSH
40782: EMPTY
40783: LIST
40784: LIST
40785: PUSH
40786: LD_INT 4
40788: NEG
40789: PUSH
40790: LD_INT 5
40792: NEG
40793: PUSH
40794: EMPTY
40795: LIST
40796: LIST
40797: PUSH
40798: LD_INT 3
40800: NEG
40801: PUSH
40802: LD_INT 4
40804: NEG
40805: PUSH
40806: EMPTY
40807: LIST
40808: LIST
40809: PUSH
40810: LD_INT 3
40812: NEG
40813: PUSH
40814: LD_INT 3
40816: NEG
40817: PUSH
40818: EMPTY
40819: LIST
40820: LIST
40821: PUSH
40822: LD_INT 4
40824: NEG
40825: PUSH
40826: LD_INT 3
40828: NEG
40829: PUSH
40830: EMPTY
40831: LIST
40832: LIST
40833: PUSH
40834: LD_INT 5
40836: NEG
40837: PUSH
40838: LD_INT 4
40840: NEG
40841: PUSH
40842: EMPTY
40843: LIST
40844: LIST
40845: PUSH
40846: LD_INT 5
40848: NEG
40849: PUSH
40850: LD_INT 5
40852: NEG
40853: PUSH
40854: EMPTY
40855: LIST
40856: LIST
40857: PUSH
40858: LD_INT 3
40860: NEG
40861: PUSH
40862: LD_INT 5
40864: NEG
40865: PUSH
40866: EMPTY
40867: LIST
40868: LIST
40869: PUSH
40870: LD_INT 5
40872: NEG
40873: PUSH
40874: LD_INT 3
40876: NEG
40877: PUSH
40878: EMPTY
40879: LIST
40880: LIST
40881: PUSH
40882: LD_INT 0
40884: PUSH
40885: LD_INT 3
40887: NEG
40888: PUSH
40889: EMPTY
40890: LIST
40891: LIST
40892: PUSH
40893: LD_INT 0
40895: PUSH
40896: LD_INT 4
40898: NEG
40899: PUSH
40900: EMPTY
40901: LIST
40902: LIST
40903: PUSH
40904: LD_INT 1
40906: PUSH
40907: LD_INT 3
40909: NEG
40910: PUSH
40911: EMPTY
40912: LIST
40913: LIST
40914: PUSH
40915: LD_INT 1
40917: PUSH
40918: LD_INT 2
40920: NEG
40921: PUSH
40922: EMPTY
40923: LIST
40924: LIST
40925: PUSH
40926: LD_INT 0
40928: PUSH
40929: LD_INT 2
40931: NEG
40932: PUSH
40933: EMPTY
40934: LIST
40935: LIST
40936: PUSH
40937: LD_INT 1
40939: NEG
40940: PUSH
40941: LD_INT 3
40943: NEG
40944: PUSH
40945: EMPTY
40946: LIST
40947: LIST
40948: PUSH
40949: LD_INT 1
40951: NEG
40952: PUSH
40953: LD_INT 4
40955: NEG
40956: PUSH
40957: EMPTY
40958: LIST
40959: LIST
40960: PUSH
40961: LD_INT 2
40963: PUSH
40964: LD_INT 2
40966: NEG
40967: PUSH
40968: EMPTY
40969: LIST
40970: LIST
40971: PUSH
40972: LD_INT 2
40974: NEG
40975: PUSH
40976: LD_INT 4
40978: NEG
40979: PUSH
40980: EMPTY
40981: LIST
40982: LIST
40983: PUSH
40984: LD_INT 4
40986: PUSH
40987: LD_INT 0
40989: PUSH
40990: EMPTY
40991: LIST
40992: LIST
40993: PUSH
40994: LD_INT 4
40996: PUSH
40997: LD_INT 1
40999: NEG
41000: PUSH
41001: EMPTY
41002: LIST
41003: LIST
41004: PUSH
41005: LD_INT 5
41007: PUSH
41008: LD_INT 0
41010: PUSH
41011: EMPTY
41012: LIST
41013: LIST
41014: PUSH
41015: LD_INT 5
41017: PUSH
41018: LD_INT 1
41020: PUSH
41021: EMPTY
41022: LIST
41023: LIST
41024: PUSH
41025: LD_INT 4
41027: PUSH
41028: LD_INT 1
41030: PUSH
41031: EMPTY
41032: LIST
41033: LIST
41034: PUSH
41035: LD_INT 3
41037: PUSH
41038: LD_INT 0
41040: PUSH
41041: EMPTY
41042: LIST
41043: LIST
41044: PUSH
41045: LD_INT 3
41047: PUSH
41048: LD_INT 1
41050: NEG
41051: PUSH
41052: EMPTY
41053: LIST
41054: LIST
41055: PUSH
41056: LD_INT 3
41058: PUSH
41059: LD_INT 2
41061: NEG
41062: PUSH
41063: EMPTY
41064: LIST
41065: LIST
41066: PUSH
41067: LD_INT 5
41069: PUSH
41070: LD_INT 2
41072: PUSH
41073: EMPTY
41074: LIST
41075: LIST
41076: PUSH
41077: EMPTY
41078: LIST
41079: LIST
41080: LIST
41081: LIST
41082: LIST
41083: LIST
41084: LIST
41085: LIST
41086: LIST
41087: LIST
41088: LIST
41089: LIST
41090: LIST
41091: LIST
41092: LIST
41093: LIST
41094: LIST
41095: LIST
41096: LIST
41097: LIST
41098: LIST
41099: LIST
41100: LIST
41101: LIST
41102: LIST
41103: LIST
41104: LIST
41105: LIST
41106: LIST
41107: LIST
41108: LIST
41109: LIST
41110: LIST
41111: LIST
41112: LIST
41113: LIST
41114: LIST
41115: LIST
41116: LIST
41117: LIST
41118: LIST
41119: LIST
41120: LIST
41121: LIST
41122: LIST
41123: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
41124: LD_ADDR_VAR 0 32
41128: PUSH
41129: LD_INT 4
41131: NEG
41132: PUSH
41133: LD_INT 0
41135: PUSH
41136: EMPTY
41137: LIST
41138: LIST
41139: PUSH
41140: LD_INT 4
41142: NEG
41143: PUSH
41144: LD_INT 1
41146: NEG
41147: PUSH
41148: EMPTY
41149: LIST
41150: LIST
41151: PUSH
41152: LD_INT 3
41154: NEG
41155: PUSH
41156: LD_INT 0
41158: PUSH
41159: EMPTY
41160: LIST
41161: LIST
41162: PUSH
41163: LD_INT 3
41165: NEG
41166: PUSH
41167: LD_INT 1
41169: PUSH
41170: EMPTY
41171: LIST
41172: LIST
41173: PUSH
41174: LD_INT 4
41176: NEG
41177: PUSH
41178: LD_INT 1
41180: PUSH
41181: EMPTY
41182: LIST
41183: LIST
41184: PUSH
41185: LD_INT 5
41187: NEG
41188: PUSH
41189: LD_INT 0
41191: PUSH
41192: EMPTY
41193: LIST
41194: LIST
41195: PUSH
41196: LD_INT 5
41198: NEG
41199: PUSH
41200: LD_INT 1
41202: NEG
41203: PUSH
41204: EMPTY
41205: LIST
41206: LIST
41207: PUSH
41208: LD_INT 5
41210: NEG
41211: PUSH
41212: LD_INT 2
41214: NEG
41215: PUSH
41216: EMPTY
41217: LIST
41218: LIST
41219: PUSH
41220: LD_INT 3
41222: NEG
41223: PUSH
41224: LD_INT 2
41226: PUSH
41227: EMPTY
41228: LIST
41229: LIST
41230: PUSH
41231: LD_INT 3
41233: NEG
41234: PUSH
41235: LD_INT 3
41237: NEG
41238: PUSH
41239: EMPTY
41240: LIST
41241: LIST
41242: PUSH
41243: LD_INT 3
41245: NEG
41246: PUSH
41247: LD_INT 4
41249: NEG
41250: PUSH
41251: EMPTY
41252: LIST
41253: LIST
41254: PUSH
41255: LD_INT 2
41257: NEG
41258: PUSH
41259: LD_INT 3
41261: NEG
41262: PUSH
41263: EMPTY
41264: LIST
41265: LIST
41266: PUSH
41267: LD_INT 2
41269: NEG
41270: PUSH
41271: LD_INT 2
41273: NEG
41274: PUSH
41275: EMPTY
41276: LIST
41277: LIST
41278: PUSH
41279: LD_INT 3
41281: NEG
41282: PUSH
41283: LD_INT 2
41285: NEG
41286: PUSH
41287: EMPTY
41288: LIST
41289: LIST
41290: PUSH
41291: LD_INT 4
41293: NEG
41294: PUSH
41295: LD_INT 3
41297: NEG
41298: PUSH
41299: EMPTY
41300: LIST
41301: LIST
41302: PUSH
41303: LD_INT 4
41305: NEG
41306: PUSH
41307: LD_INT 4
41309: NEG
41310: PUSH
41311: EMPTY
41312: LIST
41313: LIST
41314: PUSH
41315: LD_INT 2
41317: NEG
41318: PUSH
41319: LD_INT 4
41321: NEG
41322: PUSH
41323: EMPTY
41324: LIST
41325: LIST
41326: PUSH
41327: LD_INT 4
41329: NEG
41330: PUSH
41331: LD_INT 2
41333: NEG
41334: PUSH
41335: EMPTY
41336: LIST
41337: LIST
41338: PUSH
41339: LD_INT 0
41341: PUSH
41342: LD_INT 4
41344: NEG
41345: PUSH
41346: EMPTY
41347: LIST
41348: LIST
41349: PUSH
41350: LD_INT 0
41352: PUSH
41353: LD_INT 5
41355: NEG
41356: PUSH
41357: EMPTY
41358: LIST
41359: LIST
41360: PUSH
41361: LD_INT 1
41363: PUSH
41364: LD_INT 4
41366: NEG
41367: PUSH
41368: EMPTY
41369: LIST
41370: LIST
41371: PUSH
41372: LD_INT 1
41374: PUSH
41375: LD_INT 3
41377: NEG
41378: PUSH
41379: EMPTY
41380: LIST
41381: LIST
41382: PUSH
41383: LD_INT 0
41385: PUSH
41386: LD_INT 3
41388: NEG
41389: PUSH
41390: EMPTY
41391: LIST
41392: LIST
41393: PUSH
41394: LD_INT 1
41396: NEG
41397: PUSH
41398: LD_INT 4
41400: NEG
41401: PUSH
41402: EMPTY
41403: LIST
41404: LIST
41405: PUSH
41406: LD_INT 1
41408: NEG
41409: PUSH
41410: LD_INT 5
41412: NEG
41413: PUSH
41414: EMPTY
41415: LIST
41416: LIST
41417: PUSH
41418: LD_INT 2
41420: PUSH
41421: LD_INT 3
41423: NEG
41424: PUSH
41425: EMPTY
41426: LIST
41427: LIST
41428: PUSH
41429: LD_INT 2
41431: NEG
41432: PUSH
41433: LD_INT 5
41435: NEG
41436: PUSH
41437: EMPTY
41438: LIST
41439: LIST
41440: PUSH
41441: LD_INT 3
41443: PUSH
41444: LD_INT 0
41446: PUSH
41447: EMPTY
41448: LIST
41449: LIST
41450: PUSH
41451: LD_INT 3
41453: PUSH
41454: LD_INT 1
41456: NEG
41457: PUSH
41458: EMPTY
41459: LIST
41460: LIST
41461: PUSH
41462: LD_INT 4
41464: PUSH
41465: LD_INT 0
41467: PUSH
41468: EMPTY
41469: LIST
41470: LIST
41471: PUSH
41472: LD_INT 4
41474: PUSH
41475: LD_INT 1
41477: PUSH
41478: EMPTY
41479: LIST
41480: LIST
41481: PUSH
41482: LD_INT 3
41484: PUSH
41485: LD_INT 1
41487: PUSH
41488: EMPTY
41489: LIST
41490: LIST
41491: PUSH
41492: LD_INT 2
41494: PUSH
41495: LD_INT 0
41497: PUSH
41498: EMPTY
41499: LIST
41500: LIST
41501: PUSH
41502: LD_INT 2
41504: PUSH
41505: LD_INT 1
41507: NEG
41508: PUSH
41509: EMPTY
41510: LIST
41511: LIST
41512: PUSH
41513: LD_INT 2
41515: PUSH
41516: LD_INT 2
41518: NEG
41519: PUSH
41520: EMPTY
41521: LIST
41522: LIST
41523: PUSH
41524: LD_INT 4
41526: PUSH
41527: LD_INT 2
41529: PUSH
41530: EMPTY
41531: LIST
41532: LIST
41533: PUSH
41534: LD_INT 4
41536: PUSH
41537: LD_INT 4
41539: PUSH
41540: EMPTY
41541: LIST
41542: LIST
41543: PUSH
41544: LD_INT 4
41546: PUSH
41547: LD_INT 3
41549: PUSH
41550: EMPTY
41551: LIST
41552: LIST
41553: PUSH
41554: LD_INT 5
41556: PUSH
41557: LD_INT 4
41559: PUSH
41560: EMPTY
41561: LIST
41562: LIST
41563: PUSH
41564: LD_INT 5
41566: PUSH
41567: LD_INT 5
41569: PUSH
41570: EMPTY
41571: LIST
41572: LIST
41573: PUSH
41574: LD_INT 4
41576: PUSH
41577: LD_INT 5
41579: PUSH
41580: EMPTY
41581: LIST
41582: LIST
41583: PUSH
41584: LD_INT 3
41586: PUSH
41587: LD_INT 4
41589: PUSH
41590: EMPTY
41591: LIST
41592: LIST
41593: PUSH
41594: LD_INT 3
41596: PUSH
41597: LD_INT 3
41599: PUSH
41600: EMPTY
41601: LIST
41602: LIST
41603: PUSH
41604: LD_INT 5
41606: PUSH
41607: LD_INT 3
41609: PUSH
41610: EMPTY
41611: LIST
41612: LIST
41613: PUSH
41614: LD_INT 3
41616: PUSH
41617: LD_INT 5
41619: PUSH
41620: EMPTY
41621: LIST
41622: LIST
41623: PUSH
41624: EMPTY
41625: LIST
41626: LIST
41627: LIST
41628: LIST
41629: LIST
41630: LIST
41631: LIST
41632: LIST
41633: LIST
41634: LIST
41635: LIST
41636: LIST
41637: LIST
41638: LIST
41639: LIST
41640: LIST
41641: LIST
41642: LIST
41643: LIST
41644: LIST
41645: LIST
41646: LIST
41647: LIST
41648: LIST
41649: LIST
41650: LIST
41651: LIST
41652: LIST
41653: LIST
41654: LIST
41655: LIST
41656: LIST
41657: LIST
41658: LIST
41659: LIST
41660: LIST
41661: LIST
41662: LIST
41663: LIST
41664: LIST
41665: LIST
41666: LIST
41667: LIST
41668: LIST
41669: LIST
41670: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
41671: LD_ADDR_VAR 0 33
41675: PUSH
41676: LD_INT 4
41678: NEG
41679: PUSH
41680: LD_INT 4
41682: NEG
41683: PUSH
41684: EMPTY
41685: LIST
41686: LIST
41687: PUSH
41688: LD_INT 4
41690: NEG
41691: PUSH
41692: LD_INT 5
41694: NEG
41695: PUSH
41696: EMPTY
41697: LIST
41698: LIST
41699: PUSH
41700: LD_INT 3
41702: NEG
41703: PUSH
41704: LD_INT 4
41706: NEG
41707: PUSH
41708: EMPTY
41709: LIST
41710: LIST
41711: PUSH
41712: LD_INT 3
41714: NEG
41715: PUSH
41716: LD_INT 3
41718: NEG
41719: PUSH
41720: EMPTY
41721: LIST
41722: LIST
41723: PUSH
41724: LD_INT 4
41726: NEG
41727: PUSH
41728: LD_INT 3
41730: NEG
41731: PUSH
41732: EMPTY
41733: LIST
41734: LIST
41735: PUSH
41736: LD_INT 5
41738: NEG
41739: PUSH
41740: LD_INT 4
41742: NEG
41743: PUSH
41744: EMPTY
41745: LIST
41746: LIST
41747: PUSH
41748: LD_INT 5
41750: NEG
41751: PUSH
41752: LD_INT 5
41754: NEG
41755: PUSH
41756: EMPTY
41757: LIST
41758: LIST
41759: PUSH
41760: LD_INT 3
41762: NEG
41763: PUSH
41764: LD_INT 5
41766: NEG
41767: PUSH
41768: EMPTY
41769: LIST
41770: LIST
41771: PUSH
41772: LD_INT 5
41774: NEG
41775: PUSH
41776: LD_INT 3
41778: NEG
41779: PUSH
41780: EMPTY
41781: LIST
41782: LIST
41783: PUSH
41784: LD_INT 0
41786: PUSH
41787: LD_INT 3
41789: NEG
41790: PUSH
41791: EMPTY
41792: LIST
41793: LIST
41794: PUSH
41795: LD_INT 0
41797: PUSH
41798: LD_INT 4
41800: NEG
41801: PUSH
41802: EMPTY
41803: LIST
41804: LIST
41805: PUSH
41806: LD_INT 1
41808: PUSH
41809: LD_INT 3
41811: NEG
41812: PUSH
41813: EMPTY
41814: LIST
41815: LIST
41816: PUSH
41817: LD_INT 1
41819: PUSH
41820: LD_INT 2
41822: NEG
41823: PUSH
41824: EMPTY
41825: LIST
41826: LIST
41827: PUSH
41828: LD_INT 0
41830: PUSH
41831: LD_INT 2
41833: NEG
41834: PUSH
41835: EMPTY
41836: LIST
41837: LIST
41838: PUSH
41839: LD_INT 1
41841: NEG
41842: PUSH
41843: LD_INT 3
41845: NEG
41846: PUSH
41847: EMPTY
41848: LIST
41849: LIST
41850: PUSH
41851: LD_INT 1
41853: NEG
41854: PUSH
41855: LD_INT 4
41857: NEG
41858: PUSH
41859: EMPTY
41860: LIST
41861: LIST
41862: PUSH
41863: LD_INT 2
41865: PUSH
41866: LD_INT 2
41868: NEG
41869: PUSH
41870: EMPTY
41871: LIST
41872: LIST
41873: PUSH
41874: LD_INT 2
41876: NEG
41877: PUSH
41878: LD_INT 4
41880: NEG
41881: PUSH
41882: EMPTY
41883: LIST
41884: LIST
41885: PUSH
41886: LD_INT 4
41888: PUSH
41889: LD_INT 0
41891: PUSH
41892: EMPTY
41893: LIST
41894: LIST
41895: PUSH
41896: LD_INT 4
41898: PUSH
41899: LD_INT 1
41901: NEG
41902: PUSH
41903: EMPTY
41904: LIST
41905: LIST
41906: PUSH
41907: LD_INT 5
41909: PUSH
41910: LD_INT 0
41912: PUSH
41913: EMPTY
41914: LIST
41915: LIST
41916: PUSH
41917: LD_INT 5
41919: PUSH
41920: LD_INT 1
41922: PUSH
41923: EMPTY
41924: LIST
41925: LIST
41926: PUSH
41927: LD_INT 4
41929: PUSH
41930: LD_INT 1
41932: PUSH
41933: EMPTY
41934: LIST
41935: LIST
41936: PUSH
41937: LD_INT 3
41939: PUSH
41940: LD_INT 0
41942: PUSH
41943: EMPTY
41944: LIST
41945: LIST
41946: PUSH
41947: LD_INT 3
41949: PUSH
41950: LD_INT 1
41952: NEG
41953: PUSH
41954: EMPTY
41955: LIST
41956: LIST
41957: PUSH
41958: LD_INT 3
41960: PUSH
41961: LD_INT 2
41963: NEG
41964: PUSH
41965: EMPTY
41966: LIST
41967: LIST
41968: PUSH
41969: LD_INT 5
41971: PUSH
41972: LD_INT 2
41974: PUSH
41975: EMPTY
41976: LIST
41977: LIST
41978: PUSH
41979: LD_INT 3
41981: PUSH
41982: LD_INT 3
41984: PUSH
41985: EMPTY
41986: LIST
41987: LIST
41988: PUSH
41989: LD_INT 3
41991: PUSH
41992: LD_INT 2
41994: PUSH
41995: EMPTY
41996: LIST
41997: LIST
41998: PUSH
41999: LD_INT 4
42001: PUSH
42002: LD_INT 3
42004: PUSH
42005: EMPTY
42006: LIST
42007: LIST
42008: PUSH
42009: LD_INT 4
42011: PUSH
42012: LD_INT 4
42014: PUSH
42015: EMPTY
42016: LIST
42017: LIST
42018: PUSH
42019: LD_INT 3
42021: PUSH
42022: LD_INT 4
42024: PUSH
42025: EMPTY
42026: LIST
42027: LIST
42028: PUSH
42029: LD_INT 2
42031: PUSH
42032: LD_INT 3
42034: PUSH
42035: EMPTY
42036: LIST
42037: LIST
42038: PUSH
42039: LD_INT 2
42041: PUSH
42042: LD_INT 2
42044: PUSH
42045: EMPTY
42046: LIST
42047: LIST
42048: PUSH
42049: LD_INT 4
42051: PUSH
42052: LD_INT 2
42054: PUSH
42055: EMPTY
42056: LIST
42057: LIST
42058: PUSH
42059: LD_INT 2
42061: PUSH
42062: LD_INT 4
42064: PUSH
42065: EMPTY
42066: LIST
42067: LIST
42068: PUSH
42069: LD_INT 0
42071: PUSH
42072: LD_INT 4
42074: PUSH
42075: EMPTY
42076: LIST
42077: LIST
42078: PUSH
42079: LD_INT 0
42081: PUSH
42082: LD_INT 3
42084: PUSH
42085: EMPTY
42086: LIST
42087: LIST
42088: PUSH
42089: LD_INT 1
42091: PUSH
42092: LD_INT 4
42094: PUSH
42095: EMPTY
42096: LIST
42097: LIST
42098: PUSH
42099: LD_INT 1
42101: PUSH
42102: LD_INT 5
42104: PUSH
42105: EMPTY
42106: LIST
42107: LIST
42108: PUSH
42109: LD_INT 0
42111: PUSH
42112: LD_INT 5
42114: PUSH
42115: EMPTY
42116: LIST
42117: LIST
42118: PUSH
42119: LD_INT 1
42121: NEG
42122: PUSH
42123: LD_INT 4
42125: PUSH
42126: EMPTY
42127: LIST
42128: LIST
42129: PUSH
42130: LD_INT 1
42132: NEG
42133: PUSH
42134: LD_INT 3
42136: PUSH
42137: EMPTY
42138: LIST
42139: LIST
42140: PUSH
42141: LD_INT 2
42143: PUSH
42144: LD_INT 5
42146: PUSH
42147: EMPTY
42148: LIST
42149: LIST
42150: PUSH
42151: LD_INT 2
42153: NEG
42154: PUSH
42155: LD_INT 3
42157: PUSH
42158: EMPTY
42159: LIST
42160: LIST
42161: PUSH
42162: EMPTY
42163: LIST
42164: LIST
42165: LIST
42166: LIST
42167: LIST
42168: LIST
42169: LIST
42170: LIST
42171: LIST
42172: LIST
42173: LIST
42174: LIST
42175: LIST
42176: LIST
42177: LIST
42178: LIST
42179: LIST
42180: LIST
42181: LIST
42182: LIST
42183: LIST
42184: LIST
42185: LIST
42186: LIST
42187: LIST
42188: LIST
42189: LIST
42190: LIST
42191: LIST
42192: LIST
42193: LIST
42194: LIST
42195: LIST
42196: LIST
42197: LIST
42198: LIST
42199: LIST
42200: LIST
42201: LIST
42202: LIST
42203: LIST
42204: LIST
42205: LIST
42206: LIST
42207: LIST
42208: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
42209: LD_ADDR_VAR 0 34
42213: PUSH
42214: LD_INT 0
42216: PUSH
42217: LD_INT 4
42219: NEG
42220: PUSH
42221: EMPTY
42222: LIST
42223: LIST
42224: PUSH
42225: LD_INT 0
42227: PUSH
42228: LD_INT 5
42230: NEG
42231: PUSH
42232: EMPTY
42233: LIST
42234: LIST
42235: PUSH
42236: LD_INT 1
42238: PUSH
42239: LD_INT 4
42241: NEG
42242: PUSH
42243: EMPTY
42244: LIST
42245: LIST
42246: PUSH
42247: LD_INT 1
42249: PUSH
42250: LD_INT 3
42252: NEG
42253: PUSH
42254: EMPTY
42255: LIST
42256: LIST
42257: PUSH
42258: LD_INT 0
42260: PUSH
42261: LD_INT 3
42263: NEG
42264: PUSH
42265: EMPTY
42266: LIST
42267: LIST
42268: PUSH
42269: LD_INT 1
42271: NEG
42272: PUSH
42273: LD_INT 4
42275: NEG
42276: PUSH
42277: EMPTY
42278: LIST
42279: LIST
42280: PUSH
42281: LD_INT 1
42283: NEG
42284: PUSH
42285: LD_INT 5
42287: NEG
42288: PUSH
42289: EMPTY
42290: LIST
42291: LIST
42292: PUSH
42293: LD_INT 2
42295: PUSH
42296: LD_INT 3
42298: NEG
42299: PUSH
42300: EMPTY
42301: LIST
42302: LIST
42303: PUSH
42304: LD_INT 2
42306: NEG
42307: PUSH
42308: LD_INT 5
42310: NEG
42311: PUSH
42312: EMPTY
42313: LIST
42314: LIST
42315: PUSH
42316: LD_INT 3
42318: PUSH
42319: LD_INT 0
42321: PUSH
42322: EMPTY
42323: LIST
42324: LIST
42325: PUSH
42326: LD_INT 3
42328: PUSH
42329: LD_INT 1
42331: NEG
42332: PUSH
42333: EMPTY
42334: LIST
42335: LIST
42336: PUSH
42337: LD_INT 4
42339: PUSH
42340: LD_INT 0
42342: PUSH
42343: EMPTY
42344: LIST
42345: LIST
42346: PUSH
42347: LD_INT 4
42349: PUSH
42350: LD_INT 1
42352: PUSH
42353: EMPTY
42354: LIST
42355: LIST
42356: PUSH
42357: LD_INT 3
42359: PUSH
42360: LD_INT 1
42362: PUSH
42363: EMPTY
42364: LIST
42365: LIST
42366: PUSH
42367: LD_INT 2
42369: PUSH
42370: LD_INT 0
42372: PUSH
42373: EMPTY
42374: LIST
42375: LIST
42376: PUSH
42377: LD_INT 2
42379: PUSH
42380: LD_INT 1
42382: NEG
42383: PUSH
42384: EMPTY
42385: LIST
42386: LIST
42387: PUSH
42388: LD_INT 2
42390: PUSH
42391: LD_INT 2
42393: NEG
42394: PUSH
42395: EMPTY
42396: LIST
42397: LIST
42398: PUSH
42399: LD_INT 4
42401: PUSH
42402: LD_INT 2
42404: PUSH
42405: EMPTY
42406: LIST
42407: LIST
42408: PUSH
42409: LD_INT 4
42411: PUSH
42412: LD_INT 4
42414: PUSH
42415: EMPTY
42416: LIST
42417: LIST
42418: PUSH
42419: LD_INT 4
42421: PUSH
42422: LD_INT 3
42424: PUSH
42425: EMPTY
42426: LIST
42427: LIST
42428: PUSH
42429: LD_INT 5
42431: PUSH
42432: LD_INT 4
42434: PUSH
42435: EMPTY
42436: LIST
42437: LIST
42438: PUSH
42439: LD_INT 5
42441: PUSH
42442: LD_INT 5
42444: PUSH
42445: EMPTY
42446: LIST
42447: LIST
42448: PUSH
42449: LD_INT 4
42451: PUSH
42452: LD_INT 5
42454: PUSH
42455: EMPTY
42456: LIST
42457: LIST
42458: PUSH
42459: LD_INT 3
42461: PUSH
42462: LD_INT 4
42464: PUSH
42465: EMPTY
42466: LIST
42467: LIST
42468: PUSH
42469: LD_INT 3
42471: PUSH
42472: LD_INT 3
42474: PUSH
42475: EMPTY
42476: LIST
42477: LIST
42478: PUSH
42479: LD_INT 5
42481: PUSH
42482: LD_INT 3
42484: PUSH
42485: EMPTY
42486: LIST
42487: LIST
42488: PUSH
42489: LD_INT 3
42491: PUSH
42492: LD_INT 5
42494: PUSH
42495: EMPTY
42496: LIST
42497: LIST
42498: PUSH
42499: LD_INT 0
42501: PUSH
42502: LD_INT 3
42504: PUSH
42505: EMPTY
42506: LIST
42507: LIST
42508: PUSH
42509: LD_INT 0
42511: PUSH
42512: LD_INT 2
42514: PUSH
42515: EMPTY
42516: LIST
42517: LIST
42518: PUSH
42519: LD_INT 1
42521: PUSH
42522: LD_INT 3
42524: PUSH
42525: EMPTY
42526: LIST
42527: LIST
42528: PUSH
42529: LD_INT 1
42531: PUSH
42532: LD_INT 4
42534: PUSH
42535: EMPTY
42536: LIST
42537: LIST
42538: PUSH
42539: LD_INT 0
42541: PUSH
42542: LD_INT 4
42544: PUSH
42545: EMPTY
42546: LIST
42547: LIST
42548: PUSH
42549: LD_INT 1
42551: NEG
42552: PUSH
42553: LD_INT 3
42555: PUSH
42556: EMPTY
42557: LIST
42558: LIST
42559: PUSH
42560: LD_INT 1
42562: NEG
42563: PUSH
42564: LD_INT 2
42566: PUSH
42567: EMPTY
42568: LIST
42569: LIST
42570: PUSH
42571: LD_INT 2
42573: PUSH
42574: LD_INT 4
42576: PUSH
42577: EMPTY
42578: LIST
42579: LIST
42580: PUSH
42581: LD_INT 2
42583: NEG
42584: PUSH
42585: LD_INT 2
42587: PUSH
42588: EMPTY
42589: LIST
42590: LIST
42591: PUSH
42592: LD_INT 4
42594: NEG
42595: PUSH
42596: LD_INT 0
42598: PUSH
42599: EMPTY
42600: LIST
42601: LIST
42602: PUSH
42603: LD_INT 4
42605: NEG
42606: PUSH
42607: LD_INT 1
42609: NEG
42610: PUSH
42611: EMPTY
42612: LIST
42613: LIST
42614: PUSH
42615: LD_INT 3
42617: NEG
42618: PUSH
42619: LD_INT 0
42621: PUSH
42622: EMPTY
42623: LIST
42624: LIST
42625: PUSH
42626: LD_INT 3
42628: NEG
42629: PUSH
42630: LD_INT 1
42632: PUSH
42633: EMPTY
42634: LIST
42635: LIST
42636: PUSH
42637: LD_INT 4
42639: NEG
42640: PUSH
42641: LD_INT 1
42643: PUSH
42644: EMPTY
42645: LIST
42646: LIST
42647: PUSH
42648: LD_INT 5
42650: NEG
42651: PUSH
42652: LD_INT 0
42654: PUSH
42655: EMPTY
42656: LIST
42657: LIST
42658: PUSH
42659: LD_INT 5
42661: NEG
42662: PUSH
42663: LD_INT 1
42665: NEG
42666: PUSH
42667: EMPTY
42668: LIST
42669: LIST
42670: PUSH
42671: LD_INT 5
42673: NEG
42674: PUSH
42675: LD_INT 2
42677: NEG
42678: PUSH
42679: EMPTY
42680: LIST
42681: LIST
42682: PUSH
42683: LD_INT 3
42685: NEG
42686: PUSH
42687: LD_INT 2
42689: PUSH
42690: EMPTY
42691: LIST
42692: LIST
42693: PUSH
42694: EMPTY
42695: LIST
42696: LIST
42697: LIST
42698: LIST
42699: LIST
42700: LIST
42701: LIST
42702: LIST
42703: LIST
42704: LIST
42705: LIST
42706: LIST
42707: LIST
42708: LIST
42709: LIST
42710: LIST
42711: LIST
42712: LIST
42713: LIST
42714: LIST
42715: LIST
42716: LIST
42717: LIST
42718: LIST
42719: LIST
42720: LIST
42721: LIST
42722: LIST
42723: LIST
42724: LIST
42725: LIST
42726: LIST
42727: LIST
42728: LIST
42729: LIST
42730: LIST
42731: LIST
42732: LIST
42733: LIST
42734: LIST
42735: LIST
42736: LIST
42737: LIST
42738: LIST
42739: LIST
42740: ST_TO_ADDR
// end ; end ;
42741: GO 42744
42743: POP
// case btype of b_depot , b_warehouse :
42744: LD_VAR 0 1
42748: PUSH
42749: LD_INT 0
42751: DOUBLE
42752: EQUAL
42753: IFTRUE 42763
42755: LD_INT 1
42757: DOUBLE
42758: EQUAL
42759: IFTRUE 42763
42761: GO 42964
42763: POP
// case nation of nation_american :
42764: LD_VAR 0 5
42768: PUSH
42769: LD_INT 1
42771: DOUBLE
42772: EQUAL
42773: IFTRUE 42777
42775: GO 42833
42777: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
42778: LD_ADDR_VAR 0 9
42782: PUSH
42783: LD_VAR 0 11
42787: PUSH
42788: LD_VAR 0 12
42792: PUSH
42793: LD_VAR 0 13
42797: PUSH
42798: LD_VAR 0 14
42802: PUSH
42803: LD_VAR 0 15
42807: PUSH
42808: LD_VAR 0 16
42812: PUSH
42813: EMPTY
42814: LIST
42815: LIST
42816: LIST
42817: LIST
42818: LIST
42819: LIST
42820: PUSH
42821: LD_VAR 0 4
42825: PUSH
42826: LD_INT 1
42828: PLUS
42829: ARRAY
42830: ST_TO_ADDR
42831: GO 42962
42833: LD_INT 2
42835: DOUBLE
42836: EQUAL
42837: IFTRUE 42841
42839: GO 42897
42841: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
42842: LD_ADDR_VAR 0 9
42846: PUSH
42847: LD_VAR 0 17
42851: PUSH
42852: LD_VAR 0 18
42856: PUSH
42857: LD_VAR 0 19
42861: PUSH
42862: LD_VAR 0 20
42866: PUSH
42867: LD_VAR 0 21
42871: PUSH
42872: LD_VAR 0 22
42876: PUSH
42877: EMPTY
42878: LIST
42879: LIST
42880: LIST
42881: LIST
42882: LIST
42883: LIST
42884: PUSH
42885: LD_VAR 0 4
42889: PUSH
42890: LD_INT 1
42892: PLUS
42893: ARRAY
42894: ST_TO_ADDR
42895: GO 42962
42897: LD_INT 3
42899: DOUBLE
42900: EQUAL
42901: IFTRUE 42905
42903: GO 42961
42905: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
42906: LD_ADDR_VAR 0 9
42910: PUSH
42911: LD_VAR 0 23
42915: PUSH
42916: LD_VAR 0 24
42920: PUSH
42921: LD_VAR 0 25
42925: PUSH
42926: LD_VAR 0 26
42930: PUSH
42931: LD_VAR 0 27
42935: PUSH
42936: LD_VAR 0 28
42940: PUSH
42941: EMPTY
42942: LIST
42943: LIST
42944: LIST
42945: LIST
42946: LIST
42947: LIST
42948: PUSH
42949: LD_VAR 0 4
42953: PUSH
42954: LD_INT 1
42956: PLUS
42957: ARRAY
42958: ST_TO_ADDR
42959: GO 42962
42961: POP
42962: GO 43517
42964: LD_INT 2
42966: DOUBLE
42967: EQUAL
42968: IFTRUE 42978
42970: LD_INT 3
42972: DOUBLE
42973: EQUAL
42974: IFTRUE 42978
42976: GO 43034
42978: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
42979: LD_ADDR_VAR 0 9
42983: PUSH
42984: LD_VAR 0 29
42988: PUSH
42989: LD_VAR 0 30
42993: PUSH
42994: LD_VAR 0 31
42998: PUSH
42999: LD_VAR 0 32
43003: PUSH
43004: LD_VAR 0 33
43008: PUSH
43009: LD_VAR 0 34
43013: PUSH
43014: EMPTY
43015: LIST
43016: LIST
43017: LIST
43018: LIST
43019: LIST
43020: LIST
43021: PUSH
43022: LD_VAR 0 4
43026: PUSH
43027: LD_INT 1
43029: PLUS
43030: ARRAY
43031: ST_TO_ADDR
43032: GO 43517
43034: LD_INT 16
43036: DOUBLE
43037: EQUAL
43038: IFTRUE 43096
43040: LD_INT 17
43042: DOUBLE
43043: EQUAL
43044: IFTRUE 43096
43046: LD_INT 18
43048: DOUBLE
43049: EQUAL
43050: IFTRUE 43096
43052: LD_INT 19
43054: DOUBLE
43055: EQUAL
43056: IFTRUE 43096
43058: LD_INT 22
43060: DOUBLE
43061: EQUAL
43062: IFTRUE 43096
43064: LD_INT 20
43066: DOUBLE
43067: EQUAL
43068: IFTRUE 43096
43070: LD_INT 21
43072: DOUBLE
43073: EQUAL
43074: IFTRUE 43096
43076: LD_INT 23
43078: DOUBLE
43079: EQUAL
43080: IFTRUE 43096
43082: LD_INT 24
43084: DOUBLE
43085: EQUAL
43086: IFTRUE 43096
43088: LD_INT 25
43090: DOUBLE
43091: EQUAL
43092: IFTRUE 43096
43094: GO 43152
43096: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
43097: LD_ADDR_VAR 0 9
43101: PUSH
43102: LD_VAR 0 35
43106: PUSH
43107: LD_VAR 0 36
43111: PUSH
43112: LD_VAR 0 37
43116: PUSH
43117: LD_VAR 0 38
43121: PUSH
43122: LD_VAR 0 39
43126: PUSH
43127: LD_VAR 0 40
43131: PUSH
43132: EMPTY
43133: LIST
43134: LIST
43135: LIST
43136: LIST
43137: LIST
43138: LIST
43139: PUSH
43140: LD_VAR 0 4
43144: PUSH
43145: LD_INT 1
43147: PLUS
43148: ARRAY
43149: ST_TO_ADDR
43150: GO 43517
43152: LD_INT 6
43154: DOUBLE
43155: EQUAL
43156: IFTRUE 43208
43158: LD_INT 7
43160: DOUBLE
43161: EQUAL
43162: IFTRUE 43208
43164: LD_INT 8
43166: DOUBLE
43167: EQUAL
43168: IFTRUE 43208
43170: LD_INT 13
43172: DOUBLE
43173: EQUAL
43174: IFTRUE 43208
43176: LD_INT 12
43178: DOUBLE
43179: EQUAL
43180: IFTRUE 43208
43182: LD_INT 15
43184: DOUBLE
43185: EQUAL
43186: IFTRUE 43208
43188: LD_INT 11
43190: DOUBLE
43191: EQUAL
43192: IFTRUE 43208
43194: LD_INT 14
43196: DOUBLE
43197: EQUAL
43198: IFTRUE 43208
43200: LD_INT 10
43202: DOUBLE
43203: EQUAL
43204: IFTRUE 43208
43206: GO 43264
43208: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
43209: LD_ADDR_VAR 0 9
43213: PUSH
43214: LD_VAR 0 41
43218: PUSH
43219: LD_VAR 0 42
43223: PUSH
43224: LD_VAR 0 43
43228: PUSH
43229: LD_VAR 0 44
43233: PUSH
43234: LD_VAR 0 45
43238: PUSH
43239: LD_VAR 0 46
43243: PUSH
43244: EMPTY
43245: LIST
43246: LIST
43247: LIST
43248: LIST
43249: LIST
43250: LIST
43251: PUSH
43252: LD_VAR 0 4
43256: PUSH
43257: LD_INT 1
43259: PLUS
43260: ARRAY
43261: ST_TO_ADDR
43262: GO 43517
43264: LD_INT 36
43266: DOUBLE
43267: EQUAL
43268: IFTRUE 43272
43270: GO 43328
43272: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
43273: LD_ADDR_VAR 0 9
43277: PUSH
43278: LD_VAR 0 47
43282: PUSH
43283: LD_VAR 0 48
43287: PUSH
43288: LD_VAR 0 49
43292: PUSH
43293: LD_VAR 0 50
43297: PUSH
43298: LD_VAR 0 51
43302: PUSH
43303: LD_VAR 0 52
43307: PUSH
43308: EMPTY
43309: LIST
43310: LIST
43311: LIST
43312: LIST
43313: LIST
43314: LIST
43315: PUSH
43316: LD_VAR 0 4
43320: PUSH
43321: LD_INT 1
43323: PLUS
43324: ARRAY
43325: ST_TO_ADDR
43326: GO 43517
43328: LD_INT 4
43330: DOUBLE
43331: EQUAL
43332: IFTRUE 43354
43334: LD_INT 5
43336: DOUBLE
43337: EQUAL
43338: IFTRUE 43354
43340: LD_INT 34
43342: DOUBLE
43343: EQUAL
43344: IFTRUE 43354
43346: LD_INT 37
43348: DOUBLE
43349: EQUAL
43350: IFTRUE 43354
43352: GO 43410
43354: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
43355: LD_ADDR_VAR 0 9
43359: PUSH
43360: LD_VAR 0 53
43364: PUSH
43365: LD_VAR 0 54
43369: PUSH
43370: LD_VAR 0 55
43374: PUSH
43375: LD_VAR 0 56
43379: PUSH
43380: LD_VAR 0 57
43384: PUSH
43385: LD_VAR 0 58
43389: PUSH
43390: EMPTY
43391: LIST
43392: LIST
43393: LIST
43394: LIST
43395: LIST
43396: LIST
43397: PUSH
43398: LD_VAR 0 4
43402: PUSH
43403: LD_INT 1
43405: PLUS
43406: ARRAY
43407: ST_TO_ADDR
43408: GO 43517
43410: LD_INT 31
43412: DOUBLE
43413: EQUAL
43414: IFTRUE 43460
43416: LD_INT 32
43418: DOUBLE
43419: EQUAL
43420: IFTRUE 43460
43422: LD_INT 33
43424: DOUBLE
43425: EQUAL
43426: IFTRUE 43460
43428: LD_INT 27
43430: DOUBLE
43431: EQUAL
43432: IFTRUE 43460
43434: LD_INT 26
43436: DOUBLE
43437: EQUAL
43438: IFTRUE 43460
43440: LD_INT 28
43442: DOUBLE
43443: EQUAL
43444: IFTRUE 43460
43446: LD_INT 29
43448: DOUBLE
43449: EQUAL
43450: IFTRUE 43460
43452: LD_INT 30
43454: DOUBLE
43455: EQUAL
43456: IFTRUE 43460
43458: GO 43516
43460: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
43461: LD_ADDR_VAR 0 9
43465: PUSH
43466: LD_VAR 0 59
43470: PUSH
43471: LD_VAR 0 60
43475: PUSH
43476: LD_VAR 0 61
43480: PUSH
43481: LD_VAR 0 62
43485: PUSH
43486: LD_VAR 0 63
43490: PUSH
43491: LD_VAR 0 64
43495: PUSH
43496: EMPTY
43497: LIST
43498: LIST
43499: LIST
43500: LIST
43501: LIST
43502: LIST
43503: PUSH
43504: LD_VAR 0 4
43508: PUSH
43509: LD_INT 1
43511: PLUS
43512: ARRAY
43513: ST_TO_ADDR
43514: GO 43517
43516: POP
// temp_list2 = [ ] ;
43517: LD_ADDR_VAR 0 10
43521: PUSH
43522: EMPTY
43523: ST_TO_ADDR
// for i in temp_list do
43524: LD_ADDR_VAR 0 8
43528: PUSH
43529: LD_VAR 0 9
43533: PUSH
43534: FOR_IN
43535: IFFALSE 43587
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
43537: LD_ADDR_VAR 0 10
43541: PUSH
43542: LD_VAR 0 10
43546: PUSH
43547: LD_VAR 0 8
43551: PUSH
43552: LD_INT 1
43554: ARRAY
43555: PUSH
43556: LD_VAR 0 2
43560: PLUS
43561: PUSH
43562: LD_VAR 0 8
43566: PUSH
43567: LD_INT 2
43569: ARRAY
43570: PUSH
43571: LD_VAR 0 3
43575: PLUS
43576: PUSH
43577: EMPTY
43578: LIST
43579: LIST
43580: PUSH
43581: EMPTY
43582: LIST
43583: ADD
43584: ST_TO_ADDR
43585: GO 43534
43587: POP
43588: POP
// result = temp_list2 ;
43589: LD_ADDR_VAR 0 7
43593: PUSH
43594: LD_VAR 0 10
43598: ST_TO_ADDR
// end ;
43599: LD_VAR 0 7
43603: RET
// export function EnemyInRange ( unit , dist ) ; begin
43604: LD_INT 0
43606: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
43607: LD_ADDR_VAR 0 3
43611: PUSH
43612: LD_VAR 0 1
43616: PPUSH
43617: CALL_OW 255
43621: PPUSH
43622: LD_VAR 0 1
43626: PPUSH
43627: CALL_OW 250
43631: PPUSH
43632: LD_VAR 0 1
43636: PPUSH
43637: CALL_OW 251
43641: PPUSH
43642: LD_VAR 0 2
43646: PPUSH
43647: CALL 17006 0 4
43651: PUSH
43652: LD_INT 4
43654: ARRAY
43655: ST_TO_ADDR
// end ;
43656: LD_VAR 0 3
43660: RET
// export function PlayerSeeMe ( unit ) ; begin
43661: LD_INT 0
43663: PPUSH
// result := See ( your_side , unit ) ;
43664: LD_ADDR_VAR 0 2
43668: PUSH
43669: LD_OWVAR 2
43673: PPUSH
43674: LD_VAR 0 1
43678: PPUSH
43679: CALL_OW 292
43683: ST_TO_ADDR
// end ;
43684: LD_VAR 0 2
43688: RET
// export function ReverseDir ( unit ) ; begin
43689: LD_INT 0
43691: PPUSH
// if not unit then
43692: LD_VAR 0 1
43696: NOT
43697: IFFALSE 43701
// exit ;
43699: GO 43724
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
43701: LD_ADDR_VAR 0 2
43705: PUSH
43706: LD_VAR 0 1
43710: PPUSH
43711: CALL_OW 254
43715: PUSH
43716: LD_INT 3
43718: PLUS
43719: PUSH
43720: LD_INT 6
43722: MOD
43723: ST_TO_ADDR
// end ;
43724: LD_VAR 0 2
43728: RET
// export function ReverseArray ( array ) ; var i ; begin
43729: LD_INT 0
43731: PPUSH
43732: PPUSH
// if not array then
43733: LD_VAR 0 1
43737: NOT
43738: IFFALSE 43742
// exit ;
43740: GO 43797
// result := [ ] ;
43742: LD_ADDR_VAR 0 2
43746: PUSH
43747: EMPTY
43748: ST_TO_ADDR
// for i := array downto 1 do
43749: LD_ADDR_VAR 0 3
43753: PUSH
43754: DOUBLE
43755: LD_VAR 0 1
43759: INC
43760: ST_TO_ADDR
43761: LD_INT 1
43763: PUSH
43764: FOR_DOWNTO
43765: IFFALSE 43795
// result := Join ( result , array [ i ] ) ;
43767: LD_ADDR_VAR 0 2
43771: PUSH
43772: LD_VAR 0 2
43776: PPUSH
43777: LD_VAR 0 1
43781: PUSH
43782: LD_VAR 0 3
43786: ARRAY
43787: PPUSH
43788: CALL 48413 0 2
43792: ST_TO_ADDR
43793: GO 43764
43795: POP
43796: POP
// end ;
43797: LD_VAR 0 2
43801: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
43802: LD_INT 0
43804: PPUSH
43805: PPUSH
43806: PPUSH
43807: PPUSH
43808: PPUSH
43809: PPUSH
// if not unit or not hexes then
43810: LD_VAR 0 1
43814: NOT
43815: PUSH
43816: LD_VAR 0 2
43820: NOT
43821: OR
43822: IFFALSE 43826
// exit ;
43824: GO 43949
// dist := 9999 ;
43826: LD_ADDR_VAR 0 5
43830: PUSH
43831: LD_INT 9999
43833: ST_TO_ADDR
// for i = 1 to hexes do
43834: LD_ADDR_VAR 0 4
43838: PUSH
43839: DOUBLE
43840: LD_INT 1
43842: DEC
43843: ST_TO_ADDR
43844: LD_VAR 0 2
43848: PUSH
43849: FOR_TO
43850: IFFALSE 43937
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
43852: LD_ADDR_VAR 0 6
43856: PUSH
43857: LD_VAR 0 1
43861: PPUSH
43862: LD_VAR 0 2
43866: PUSH
43867: LD_VAR 0 4
43871: ARRAY
43872: PUSH
43873: LD_INT 1
43875: ARRAY
43876: PPUSH
43877: LD_VAR 0 2
43881: PUSH
43882: LD_VAR 0 4
43886: ARRAY
43887: PUSH
43888: LD_INT 2
43890: ARRAY
43891: PPUSH
43892: CALL_OW 297
43896: ST_TO_ADDR
// if tdist < dist then
43897: LD_VAR 0 6
43901: PUSH
43902: LD_VAR 0 5
43906: LESS
43907: IFFALSE 43935
// begin hex := hexes [ i ] ;
43909: LD_ADDR_VAR 0 8
43913: PUSH
43914: LD_VAR 0 2
43918: PUSH
43919: LD_VAR 0 4
43923: ARRAY
43924: ST_TO_ADDR
// dist := tdist ;
43925: LD_ADDR_VAR 0 5
43929: PUSH
43930: LD_VAR 0 6
43934: ST_TO_ADDR
// end ; end ;
43935: GO 43849
43937: POP
43938: POP
// result := hex ;
43939: LD_ADDR_VAR 0 3
43943: PUSH
43944: LD_VAR 0 8
43948: ST_TO_ADDR
// end ;
43949: LD_VAR 0 3
43953: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
43954: LD_INT 0
43956: PPUSH
43957: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
43958: LD_VAR 0 1
43962: NOT
43963: PUSH
43964: LD_VAR 0 1
43968: PUSH
43969: LD_INT 21
43971: PUSH
43972: LD_INT 2
43974: PUSH
43975: EMPTY
43976: LIST
43977: LIST
43978: PUSH
43979: LD_INT 23
43981: PUSH
43982: LD_INT 2
43984: PUSH
43985: EMPTY
43986: LIST
43987: LIST
43988: PUSH
43989: EMPTY
43990: LIST
43991: LIST
43992: PPUSH
43993: CALL_OW 69
43997: IN
43998: NOT
43999: OR
44000: IFFALSE 44004
// exit ;
44002: GO 44051
// for i = 1 to 3 do
44004: LD_ADDR_VAR 0 3
44008: PUSH
44009: DOUBLE
44010: LD_INT 1
44012: DEC
44013: ST_TO_ADDR
44014: LD_INT 3
44016: PUSH
44017: FOR_TO
44018: IFFALSE 44049
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
44020: LD_VAR 0 1
44024: PPUSH
44025: CALL_OW 250
44029: PPUSH
44030: LD_VAR 0 1
44034: PPUSH
44035: CALL_OW 251
44039: PPUSH
44040: LD_INT 1
44042: PPUSH
44043: CALL_OW 453
44047: GO 44017
44049: POP
44050: POP
// end ;
44051: LD_VAR 0 2
44055: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
44056: LD_INT 0
44058: PPUSH
44059: PPUSH
44060: PPUSH
44061: PPUSH
44062: PPUSH
44063: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
44064: LD_VAR 0 1
44068: NOT
44069: PUSH
44070: LD_VAR 0 2
44074: NOT
44075: OR
44076: PUSH
44077: LD_VAR 0 1
44081: PPUSH
44082: CALL_OW 314
44086: OR
44087: IFFALSE 44091
// exit ;
44089: GO 44532
// x := GetX ( enemy_unit ) ;
44091: LD_ADDR_VAR 0 7
44095: PUSH
44096: LD_VAR 0 2
44100: PPUSH
44101: CALL_OW 250
44105: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
44106: LD_ADDR_VAR 0 8
44110: PUSH
44111: LD_VAR 0 2
44115: PPUSH
44116: CALL_OW 251
44120: ST_TO_ADDR
// if not x or not y then
44121: LD_VAR 0 7
44125: NOT
44126: PUSH
44127: LD_VAR 0 8
44131: NOT
44132: OR
44133: IFFALSE 44137
// exit ;
44135: GO 44532
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
44137: LD_ADDR_VAR 0 6
44141: PUSH
44142: LD_VAR 0 7
44146: PPUSH
44147: LD_INT 0
44149: PPUSH
44150: LD_INT 4
44152: PPUSH
44153: CALL_OW 272
44157: PUSH
44158: LD_VAR 0 8
44162: PPUSH
44163: LD_INT 0
44165: PPUSH
44166: LD_INT 4
44168: PPUSH
44169: CALL_OW 273
44173: PUSH
44174: EMPTY
44175: LIST
44176: LIST
44177: PUSH
44178: LD_VAR 0 7
44182: PPUSH
44183: LD_INT 1
44185: PPUSH
44186: LD_INT 4
44188: PPUSH
44189: CALL_OW 272
44193: PUSH
44194: LD_VAR 0 8
44198: PPUSH
44199: LD_INT 1
44201: PPUSH
44202: LD_INT 4
44204: PPUSH
44205: CALL_OW 273
44209: PUSH
44210: EMPTY
44211: LIST
44212: LIST
44213: PUSH
44214: LD_VAR 0 7
44218: PPUSH
44219: LD_INT 2
44221: PPUSH
44222: LD_INT 4
44224: PPUSH
44225: CALL_OW 272
44229: PUSH
44230: LD_VAR 0 8
44234: PPUSH
44235: LD_INT 2
44237: PPUSH
44238: LD_INT 4
44240: PPUSH
44241: CALL_OW 273
44245: PUSH
44246: EMPTY
44247: LIST
44248: LIST
44249: PUSH
44250: LD_VAR 0 7
44254: PPUSH
44255: LD_INT 3
44257: PPUSH
44258: LD_INT 4
44260: PPUSH
44261: CALL_OW 272
44265: PUSH
44266: LD_VAR 0 8
44270: PPUSH
44271: LD_INT 3
44273: PPUSH
44274: LD_INT 4
44276: PPUSH
44277: CALL_OW 273
44281: PUSH
44282: EMPTY
44283: LIST
44284: LIST
44285: PUSH
44286: LD_VAR 0 7
44290: PPUSH
44291: LD_INT 4
44293: PPUSH
44294: LD_INT 4
44296: PPUSH
44297: CALL_OW 272
44301: PUSH
44302: LD_VAR 0 8
44306: PPUSH
44307: LD_INT 4
44309: PPUSH
44310: LD_INT 4
44312: PPUSH
44313: CALL_OW 273
44317: PUSH
44318: EMPTY
44319: LIST
44320: LIST
44321: PUSH
44322: LD_VAR 0 7
44326: PPUSH
44327: LD_INT 5
44329: PPUSH
44330: LD_INT 4
44332: PPUSH
44333: CALL_OW 272
44337: PUSH
44338: LD_VAR 0 8
44342: PPUSH
44343: LD_INT 5
44345: PPUSH
44346: LD_INT 4
44348: PPUSH
44349: CALL_OW 273
44353: PUSH
44354: EMPTY
44355: LIST
44356: LIST
44357: PUSH
44358: EMPTY
44359: LIST
44360: LIST
44361: LIST
44362: LIST
44363: LIST
44364: LIST
44365: ST_TO_ADDR
// for i = tmp downto 1 do
44366: LD_ADDR_VAR 0 4
44370: PUSH
44371: DOUBLE
44372: LD_VAR 0 6
44376: INC
44377: ST_TO_ADDR
44378: LD_INT 1
44380: PUSH
44381: FOR_DOWNTO
44382: IFFALSE 44483
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
44384: LD_VAR 0 6
44388: PUSH
44389: LD_VAR 0 4
44393: ARRAY
44394: PUSH
44395: LD_INT 1
44397: ARRAY
44398: PPUSH
44399: LD_VAR 0 6
44403: PUSH
44404: LD_VAR 0 4
44408: ARRAY
44409: PUSH
44410: LD_INT 2
44412: ARRAY
44413: PPUSH
44414: CALL_OW 488
44418: NOT
44419: PUSH
44420: LD_VAR 0 6
44424: PUSH
44425: LD_VAR 0 4
44429: ARRAY
44430: PUSH
44431: LD_INT 1
44433: ARRAY
44434: PPUSH
44435: LD_VAR 0 6
44439: PUSH
44440: LD_VAR 0 4
44444: ARRAY
44445: PUSH
44446: LD_INT 2
44448: ARRAY
44449: PPUSH
44450: CALL_OW 428
44454: PUSH
44455: LD_INT 0
44457: NONEQUAL
44458: OR
44459: IFFALSE 44481
// tmp := Delete ( tmp , i ) ;
44461: LD_ADDR_VAR 0 6
44465: PUSH
44466: LD_VAR 0 6
44470: PPUSH
44471: LD_VAR 0 4
44475: PPUSH
44476: CALL_OW 3
44480: ST_TO_ADDR
44481: GO 44381
44483: POP
44484: POP
// j := GetClosestHex ( unit , tmp ) ;
44485: LD_ADDR_VAR 0 5
44489: PUSH
44490: LD_VAR 0 1
44494: PPUSH
44495: LD_VAR 0 6
44499: PPUSH
44500: CALL 43802 0 2
44504: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
44505: LD_VAR 0 1
44509: PPUSH
44510: LD_VAR 0 5
44514: PUSH
44515: LD_INT 1
44517: ARRAY
44518: PPUSH
44519: LD_VAR 0 5
44523: PUSH
44524: LD_INT 2
44526: ARRAY
44527: PPUSH
44528: CALL_OW 111
// end ;
44532: LD_VAR 0 3
44536: RET
// export function PrepareApemanSoldier ( ) ; begin
44537: LD_INT 0
44539: PPUSH
// uc_nation := 0 ;
44540: LD_ADDR_OWVAR 21
44544: PUSH
44545: LD_INT 0
44547: ST_TO_ADDR
// hc_sex := sex_male ;
44548: LD_ADDR_OWVAR 27
44552: PUSH
44553: LD_INT 1
44555: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
44556: LD_ADDR_OWVAR 28
44560: PUSH
44561: LD_INT 15
44563: ST_TO_ADDR
// hc_gallery :=  ;
44564: LD_ADDR_OWVAR 33
44568: PUSH
44569: LD_STRING 
44571: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
44572: LD_ADDR_OWVAR 31
44576: PUSH
44577: LD_INT 0
44579: PPUSH
44580: LD_INT 3
44582: PPUSH
44583: CALL_OW 12
44587: PUSH
44588: LD_INT 0
44590: PPUSH
44591: LD_INT 3
44593: PPUSH
44594: CALL_OW 12
44598: PUSH
44599: LD_INT 0
44601: PUSH
44602: LD_INT 0
44604: PUSH
44605: EMPTY
44606: LIST
44607: LIST
44608: LIST
44609: LIST
44610: ST_TO_ADDR
// end ;
44611: LD_VAR 0 1
44615: RET
// export function PrepareApemanEngineer ( ) ; begin
44616: LD_INT 0
44618: PPUSH
// uc_nation := 0 ;
44619: LD_ADDR_OWVAR 21
44623: PUSH
44624: LD_INT 0
44626: ST_TO_ADDR
// hc_sex := sex_male ;
44627: LD_ADDR_OWVAR 27
44631: PUSH
44632: LD_INT 1
44634: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
44635: LD_ADDR_OWVAR 28
44639: PUSH
44640: LD_INT 16
44642: ST_TO_ADDR
// hc_gallery :=  ;
44643: LD_ADDR_OWVAR 33
44647: PUSH
44648: LD_STRING 
44650: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
44651: LD_ADDR_OWVAR 31
44655: PUSH
44656: LD_INT 0
44658: PPUSH
44659: LD_INT 3
44661: PPUSH
44662: CALL_OW 12
44666: PUSH
44667: LD_INT 0
44669: PPUSH
44670: LD_INT 3
44672: PPUSH
44673: CALL_OW 12
44677: PUSH
44678: LD_INT 0
44680: PUSH
44681: LD_INT 0
44683: PUSH
44684: EMPTY
44685: LIST
44686: LIST
44687: LIST
44688: LIST
44689: ST_TO_ADDR
// end ;
44690: LD_VAR 0 1
44694: RET
// export function PrepareApeman ( agressivity ) ; begin
44695: LD_INT 0
44697: PPUSH
// uc_side := 0 ;
44698: LD_ADDR_OWVAR 20
44702: PUSH
44703: LD_INT 0
44705: ST_TO_ADDR
// uc_nation := 0 ;
44706: LD_ADDR_OWVAR 21
44710: PUSH
44711: LD_INT 0
44713: ST_TO_ADDR
// hc_sex := sex_male ;
44714: LD_ADDR_OWVAR 27
44718: PUSH
44719: LD_INT 1
44721: ST_TO_ADDR
// hc_class := class_apeman ;
44722: LD_ADDR_OWVAR 28
44726: PUSH
44727: LD_INT 12
44729: ST_TO_ADDR
// hc_gallery :=  ;
44730: LD_ADDR_OWVAR 33
44734: PUSH
44735: LD_STRING 
44737: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
44738: LD_ADDR_OWVAR 35
44742: PUSH
44743: LD_VAR 0 1
44747: NEG
44748: PPUSH
44749: LD_VAR 0 1
44753: PPUSH
44754: CALL_OW 12
44758: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
44759: LD_ADDR_OWVAR 31
44763: PUSH
44764: LD_INT 0
44766: PPUSH
44767: LD_INT 3
44769: PPUSH
44770: CALL_OW 12
44774: PUSH
44775: LD_INT 0
44777: PPUSH
44778: LD_INT 3
44780: PPUSH
44781: CALL_OW 12
44785: PUSH
44786: LD_INT 0
44788: PUSH
44789: LD_INT 0
44791: PUSH
44792: EMPTY
44793: LIST
44794: LIST
44795: LIST
44796: LIST
44797: ST_TO_ADDR
// end ;
44798: LD_VAR 0 2
44802: RET
// export function PrepareTiger ( agressivity ) ; begin
44803: LD_INT 0
44805: PPUSH
// uc_side := 0 ;
44806: LD_ADDR_OWVAR 20
44810: PUSH
44811: LD_INT 0
44813: ST_TO_ADDR
// uc_nation := 0 ;
44814: LD_ADDR_OWVAR 21
44818: PUSH
44819: LD_INT 0
44821: ST_TO_ADDR
// hc_class := class_tiger ;
44822: LD_ADDR_OWVAR 28
44826: PUSH
44827: LD_INT 14
44829: ST_TO_ADDR
// hc_gallery :=  ;
44830: LD_ADDR_OWVAR 33
44834: PUSH
44835: LD_STRING 
44837: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
44838: LD_ADDR_OWVAR 35
44842: PUSH
44843: LD_VAR 0 1
44847: NEG
44848: PPUSH
44849: LD_VAR 0 1
44853: PPUSH
44854: CALL_OW 12
44858: ST_TO_ADDR
// end ;
44859: LD_VAR 0 2
44863: RET
// export function PrepareEnchidna ( ) ; begin
44864: LD_INT 0
44866: PPUSH
// uc_side := 0 ;
44867: LD_ADDR_OWVAR 20
44871: PUSH
44872: LD_INT 0
44874: ST_TO_ADDR
// uc_nation := 0 ;
44875: LD_ADDR_OWVAR 21
44879: PUSH
44880: LD_INT 0
44882: ST_TO_ADDR
// hc_class := class_baggie ;
44883: LD_ADDR_OWVAR 28
44887: PUSH
44888: LD_INT 13
44890: ST_TO_ADDR
// hc_gallery :=  ;
44891: LD_ADDR_OWVAR 33
44895: PUSH
44896: LD_STRING 
44898: ST_TO_ADDR
// end ;
44899: LD_VAR 0 1
44903: RET
// export function PrepareFrog ( ) ; begin
44904: LD_INT 0
44906: PPUSH
// uc_side := 0 ;
44907: LD_ADDR_OWVAR 20
44911: PUSH
44912: LD_INT 0
44914: ST_TO_ADDR
// uc_nation := 0 ;
44915: LD_ADDR_OWVAR 21
44919: PUSH
44920: LD_INT 0
44922: ST_TO_ADDR
// hc_class := class_frog ;
44923: LD_ADDR_OWVAR 28
44927: PUSH
44928: LD_INT 19
44930: ST_TO_ADDR
// hc_gallery :=  ;
44931: LD_ADDR_OWVAR 33
44935: PUSH
44936: LD_STRING 
44938: ST_TO_ADDR
// end ;
44939: LD_VAR 0 1
44943: RET
// export function PrepareFish ( ) ; begin
44944: LD_INT 0
44946: PPUSH
// uc_side := 0 ;
44947: LD_ADDR_OWVAR 20
44951: PUSH
44952: LD_INT 0
44954: ST_TO_ADDR
// uc_nation := 0 ;
44955: LD_ADDR_OWVAR 21
44959: PUSH
44960: LD_INT 0
44962: ST_TO_ADDR
// hc_class := class_fish ;
44963: LD_ADDR_OWVAR 28
44967: PUSH
44968: LD_INT 20
44970: ST_TO_ADDR
// hc_gallery :=  ;
44971: LD_ADDR_OWVAR 33
44975: PUSH
44976: LD_STRING 
44978: ST_TO_ADDR
// end ;
44979: LD_VAR 0 1
44983: RET
// export function PrepareBird ( ) ; begin
44984: LD_INT 0
44986: PPUSH
// uc_side := 0 ;
44987: LD_ADDR_OWVAR 20
44991: PUSH
44992: LD_INT 0
44994: ST_TO_ADDR
// uc_nation := 0 ;
44995: LD_ADDR_OWVAR 21
44999: PUSH
45000: LD_INT 0
45002: ST_TO_ADDR
// hc_class := class_phororhacos ;
45003: LD_ADDR_OWVAR 28
45007: PUSH
45008: LD_INT 18
45010: ST_TO_ADDR
// hc_gallery :=  ;
45011: LD_ADDR_OWVAR 33
45015: PUSH
45016: LD_STRING 
45018: ST_TO_ADDR
// end ;
45019: LD_VAR 0 1
45023: RET
// export function PrepareHorse ( ) ; begin
45024: LD_INT 0
45026: PPUSH
// uc_side := 0 ;
45027: LD_ADDR_OWVAR 20
45031: PUSH
45032: LD_INT 0
45034: ST_TO_ADDR
// uc_nation := 0 ;
45035: LD_ADDR_OWVAR 21
45039: PUSH
45040: LD_INT 0
45042: ST_TO_ADDR
// hc_class := class_horse ;
45043: LD_ADDR_OWVAR 28
45047: PUSH
45048: LD_INT 21
45050: ST_TO_ADDR
// hc_gallery :=  ;
45051: LD_ADDR_OWVAR 33
45055: PUSH
45056: LD_STRING 
45058: ST_TO_ADDR
// end ;
45059: LD_VAR 0 1
45063: RET
// export function PrepareMastodont ( ) ; begin
45064: LD_INT 0
45066: PPUSH
// uc_side := 0 ;
45067: LD_ADDR_OWVAR 20
45071: PUSH
45072: LD_INT 0
45074: ST_TO_ADDR
// uc_nation := 0 ;
45075: LD_ADDR_OWVAR 21
45079: PUSH
45080: LD_INT 0
45082: ST_TO_ADDR
// vc_chassis := class_mastodont ;
45083: LD_ADDR_OWVAR 37
45087: PUSH
45088: LD_INT 31
45090: ST_TO_ADDR
// vc_control := control_rider ;
45091: LD_ADDR_OWVAR 38
45095: PUSH
45096: LD_INT 4
45098: ST_TO_ADDR
// end ;
45099: LD_VAR 0 1
45103: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
45104: LD_INT 0
45106: PPUSH
45107: PPUSH
45108: PPUSH
// uc_side = 0 ;
45109: LD_ADDR_OWVAR 20
45113: PUSH
45114: LD_INT 0
45116: ST_TO_ADDR
// uc_nation = 0 ;
45117: LD_ADDR_OWVAR 21
45121: PUSH
45122: LD_INT 0
45124: ST_TO_ADDR
// InitHc_All ( ) ;
45125: CALL_OW 584
// InitVc ;
45129: CALL_OW 20
// if mastodonts then
45133: LD_VAR 0 6
45137: IFFALSE 45204
// for i = 1 to mastodonts do
45139: LD_ADDR_VAR 0 11
45143: PUSH
45144: DOUBLE
45145: LD_INT 1
45147: DEC
45148: ST_TO_ADDR
45149: LD_VAR 0 6
45153: PUSH
45154: FOR_TO
45155: IFFALSE 45202
// begin vc_chassis := 31 ;
45157: LD_ADDR_OWVAR 37
45161: PUSH
45162: LD_INT 31
45164: ST_TO_ADDR
// vc_control := control_rider ;
45165: LD_ADDR_OWVAR 38
45169: PUSH
45170: LD_INT 4
45172: ST_TO_ADDR
// animal := CreateVehicle ;
45173: LD_ADDR_VAR 0 12
45177: PUSH
45178: CALL_OW 45
45182: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45183: LD_VAR 0 12
45187: PPUSH
45188: LD_VAR 0 8
45192: PPUSH
45193: LD_INT 0
45195: PPUSH
45196: CALL 47330 0 3
// end ;
45200: GO 45154
45202: POP
45203: POP
// if horses then
45204: LD_VAR 0 5
45208: IFFALSE 45275
// for i = 1 to horses do
45210: LD_ADDR_VAR 0 11
45214: PUSH
45215: DOUBLE
45216: LD_INT 1
45218: DEC
45219: ST_TO_ADDR
45220: LD_VAR 0 5
45224: PUSH
45225: FOR_TO
45226: IFFALSE 45273
// begin hc_class := 21 ;
45228: LD_ADDR_OWVAR 28
45232: PUSH
45233: LD_INT 21
45235: ST_TO_ADDR
// hc_gallery :=  ;
45236: LD_ADDR_OWVAR 33
45240: PUSH
45241: LD_STRING 
45243: ST_TO_ADDR
// animal := CreateHuman ;
45244: LD_ADDR_VAR 0 12
45248: PUSH
45249: CALL_OW 44
45253: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45254: LD_VAR 0 12
45258: PPUSH
45259: LD_VAR 0 8
45263: PPUSH
45264: LD_INT 0
45266: PPUSH
45267: CALL 47330 0 3
// end ;
45271: GO 45225
45273: POP
45274: POP
// if birds then
45275: LD_VAR 0 1
45279: IFFALSE 45346
// for i = 1 to birds do
45281: LD_ADDR_VAR 0 11
45285: PUSH
45286: DOUBLE
45287: LD_INT 1
45289: DEC
45290: ST_TO_ADDR
45291: LD_VAR 0 1
45295: PUSH
45296: FOR_TO
45297: IFFALSE 45344
// begin hc_class = 18 ;
45299: LD_ADDR_OWVAR 28
45303: PUSH
45304: LD_INT 18
45306: ST_TO_ADDR
// hc_gallery =  ;
45307: LD_ADDR_OWVAR 33
45311: PUSH
45312: LD_STRING 
45314: ST_TO_ADDR
// animal := CreateHuman ;
45315: LD_ADDR_VAR 0 12
45319: PUSH
45320: CALL_OW 44
45324: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45325: LD_VAR 0 12
45329: PPUSH
45330: LD_VAR 0 8
45334: PPUSH
45335: LD_INT 0
45337: PPUSH
45338: CALL 47330 0 3
// end ;
45342: GO 45296
45344: POP
45345: POP
// if tigers then
45346: LD_VAR 0 2
45350: IFFALSE 45434
// for i = 1 to tigers do
45352: LD_ADDR_VAR 0 11
45356: PUSH
45357: DOUBLE
45358: LD_INT 1
45360: DEC
45361: ST_TO_ADDR
45362: LD_VAR 0 2
45366: PUSH
45367: FOR_TO
45368: IFFALSE 45432
// begin hc_class = class_tiger ;
45370: LD_ADDR_OWVAR 28
45374: PUSH
45375: LD_INT 14
45377: ST_TO_ADDR
// hc_gallery =  ;
45378: LD_ADDR_OWVAR 33
45382: PUSH
45383: LD_STRING 
45385: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
45386: LD_ADDR_OWVAR 35
45390: PUSH
45391: LD_INT 7
45393: NEG
45394: PPUSH
45395: LD_INT 7
45397: PPUSH
45398: CALL_OW 12
45402: ST_TO_ADDR
// animal := CreateHuman ;
45403: LD_ADDR_VAR 0 12
45407: PUSH
45408: CALL_OW 44
45412: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45413: LD_VAR 0 12
45417: PPUSH
45418: LD_VAR 0 8
45422: PPUSH
45423: LD_INT 0
45425: PPUSH
45426: CALL 47330 0 3
// end ;
45430: GO 45367
45432: POP
45433: POP
// if apemans then
45434: LD_VAR 0 3
45438: IFFALSE 45561
// for i = 1 to apemans do
45440: LD_ADDR_VAR 0 11
45444: PUSH
45445: DOUBLE
45446: LD_INT 1
45448: DEC
45449: ST_TO_ADDR
45450: LD_VAR 0 3
45454: PUSH
45455: FOR_TO
45456: IFFALSE 45559
// begin hc_class = class_apeman ;
45458: LD_ADDR_OWVAR 28
45462: PUSH
45463: LD_INT 12
45465: ST_TO_ADDR
// hc_gallery =  ;
45466: LD_ADDR_OWVAR 33
45470: PUSH
45471: LD_STRING 
45473: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
45474: LD_ADDR_OWVAR 35
45478: PUSH
45479: LD_INT 2
45481: NEG
45482: PPUSH
45483: LD_INT 2
45485: PPUSH
45486: CALL_OW 12
45490: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
45491: LD_ADDR_OWVAR 31
45495: PUSH
45496: LD_INT 1
45498: PPUSH
45499: LD_INT 3
45501: PPUSH
45502: CALL_OW 12
45506: PUSH
45507: LD_INT 1
45509: PPUSH
45510: LD_INT 3
45512: PPUSH
45513: CALL_OW 12
45517: PUSH
45518: LD_INT 0
45520: PUSH
45521: LD_INT 0
45523: PUSH
45524: EMPTY
45525: LIST
45526: LIST
45527: LIST
45528: LIST
45529: ST_TO_ADDR
// animal := CreateHuman ;
45530: LD_ADDR_VAR 0 12
45534: PUSH
45535: CALL_OW 44
45539: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45540: LD_VAR 0 12
45544: PPUSH
45545: LD_VAR 0 8
45549: PPUSH
45550: LD_INT 0
45552: PPUSH
45553: CALL 47330 0 3
// end ;
45557: GO 45455
45559: POP
45560: POP
// if enchidnas then
45561: LD_VAR 0 4
45565: IFFALSE 45632
// for i = 1 to enchidnas do
45567: LD_ADDR_VAR 0 11
45571: PUSH
45572: DOUBLE
45573: LD_INT 1
45575: DEC
45576: ST_TO_ADDR
45577: LD_VAR 0 4
45581: PUSH
45582: FOR_TO
45583: IFFALSE 45630
// begin hc_class = 13 ;
45585: LD_ADDR_OWVAR 28
45589: PUSH
45590: LD_INT 13
45592: ST_TO_ADDR
// hc_gallery =  ;
45593: LD_ADDR_OWVAR 33
45597: PUSH
45598: LD_STRING 
45600: ST_TO_ADDR
// animal := CreateHuman ;
45601: LD_ADDR_VAR 0 12
45605: PUSH
45606: CALL_OW 44
45610: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45611: LD_VAR 0 12
45615: PPUSH
45616: LD_VAR 0 8
45620: PPUSH
45621: LD_INT 0
45623: PPUSH
45624: CALL 47330 0 3
// end ;
45628: GO 45582
45630: POP
45631: POP
// if fishes then
45632: LD_VAR 0 7
45636: IFFALSE 45703
// for i = 1 to fishes do
45638: LD_ADDR_VAR 0 11
45642: PUSH
45643: DOUBLE
45644: LD_INT 1
45646: DEC
45647: ST_TO_ADDR
45648: LD_VAR 0 7
45652: PUSH
45653: FOR_TO
45654: IFFALSE 45701
// begin hc_class = 20 ;
45656: LD_ADDR_OWVAR 28
45660: PUSH
45661: LD_INT 20
45663: ST_TO_ADDR
// hc_gallery =  ;
45664: LD_ADDR_OWVAR 33
45668: PUSH
45669: LD_STRING 
45671: ST_TO_ADDR
// animal := CreateHuman ;
45672: LD_ADDR_VAR 0 12
45676: PUSH
45677: CALL_OW 44
45681: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
45682: LD_VAR 0 12
45686: PPUSH
45687: LD_VAR 0 9
45691: PPUSH
45692: LD_INT 0
45694: PPUSH
45695: CALL 47330 0 3
// end ;
45699: GO 45653
45701: POP
45702: POP
// end ;
45703: LD_VAR 0 10
45707: RET
// export function WantHeal ( sci , unit ) ; begin
45708: LD_INT 0
45710: PPUSH
// if GetTaskList ( sci ) > 0 then
45711: LD_VAR 0 1
45715: PPUSH
45716: CALL_OW 437
45720: PUSH
45721: LD_INT 0
45723: GREATER
45724: IFFALSE 45794
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
45726: LD_VAR 0 1
45730: PPUSH
45731: CALL_OW 437
45735: PUSH
45736: LD_INT 1
45738: ARRAY
45739: PUSH
45740: LD_INT 1
45742: ARRAY
45743: PUSH
45744: LD_STRING l
45746: EQUAL
45747: PUSH
45748: LD_VAR 0 1
45752: PPUSH
45753: CALL_OW 437
45757: PUSH
45758: LD_INT 1
45760: ARRAY
45761: PUSH
45762: LD_INT 4
45764: ARRAY
45765: PUSH
45766: LD_VAR 0 2
45770: EQUAL
45771: AND
45772: IFFALSE 45784
// result := true else
45774: LD_ADDR_VAR 0 3
45778: PUSH
45779: LD_INT 1
45781: ST_TO_ADDR
45782: GO 45792
// result := false ;
45784: LD_ADDR_VAR 0 3
45788: PUSH
45789: LD_INT 0
45791: ST_TO_ADDR
// end else
45792: GO 45802
// result := false ;
45794: LD_ADDR_VAR 0 3
45798: PUSH
45799: LD_INT 0
45801: ST_TO_ADDR
// end ;
45802: LD_VAR 0 3
45806: RET
// export function HealTarget ( sci ) ; begin
45807: LD_INT 0
45809: PPUSH
// if not sci then
45810: LD_VAR 0 1
45814: NOT
45815: IFFALSE 45819
// exit ;
45817: GO 45884
// result := 0 ;
45819: LD_ADDR_VAR 0 2
45823: PUSH
45824: LD_INT 0
45826: ST_TO_ADDR
// if GetTaskList ( sci ) then
45827: LD_VAR 0 1
45831: PPUSH
45832: CALL_OW 437
45836: IFFALSE 45884
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
45838: LD_VAR 0 1
45842: PPUSH
45843: CALL_OW 437
45847: PUSH
45848: LD_INT 1
45850: ARRAY
45851: PUSH
45852: LD_INT 1
45854: ARRAY
45855: PUSH
45856: LD_STRING l
45858: EQUAL
45859: IFFALSE 45884
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
45861: LD_ADDR_VAR 0 2
45865: PUSH
45866: LD_VAR 0 1
45870: PPUSH
45871: CALL_OW 437
45875: PUSH
45876: LD_INT 1
45878: ARRAY
45879: PUSH
45880: LD_INT 4
45882: ARRAY
45883: ST_TO_ADDR
// end ;
45884: LD_VAR 0 2
45888: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
45889: LD_INT 0
45891: PPUSH
45892: PPUSH
45893: PPUSH
45894: PPUSH
// if not base_units then
45895: LD_VAR 0 1
45899: NOT
45900: IFFALSE 45904
// exit ;
45902: GO 45991
// result := false ;
45904: LD_ADDR_VAR 0 2
45908: PUSH
45909: LD_INT 0
45911: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
45912: LD_ADDR_VAR 0 5
45916: PUSH
45917: LD_VAR 0 1
45921: PPUSH
45922: LD_INT 21
45924: PUSH
45925: LD_INT 3
45927: PUSH
45928: EMPTY
45929: LIST
45930: LIST
45931: PPUSH
45932: CALL_OW 72
45936: ST_TO_ADDR
// if not tmp then
45937: LD_VAR 0 5
45941: NOT
45942: IFFALSE 45946
// exit ;
45944: GO 45991
// for i in tmp do
45946: LD_ADDR_VAR 0 3
45950: PUSH
45951: LD_VAR 0 5
45955: PUSH
45956: FOR_IN
45957: IFFALSE 45989
// begin result := EnemyInRange ( i , 22 ) ;
45959: LD_ADDR_VAR 0 2
45963: PUSH
45964: LD_VAR 0 3
45968: PPUSH
45969: LD_INT 22
45971: PPUSH
45972: CALL 43604 0 2
45976: ST_TO_ADDR
// if result then
45977: LD_VAR 0 2
45981: IFFALSE 45987
// exit ;
45983: POP
45984: POP
45985: GO 45991
// end ;
45987: GO 45956
45989: POP
45990: POP
// end ;
45991: LD_VAR 0 2
45995: RET
// export function FilterByTag ( units , tag ) ; begin
45996: LD_INT 0
45998: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
45999: LD_ADDR_VAR 0 3
46003: PUSH
46004: LD_VAR 0 1
46008: PPUSH
46009: LD_INT 120
46011: PUSH
46012: LD_VAR 0 2
46016: PUSH
46017: EMPTY
46018: LIST
46019: LIST
46020: PPUSH
46021: CALL_OW 72
46025: ST_TO_ADDR
// end ;
46026: LD_VAR 0 3
46030: RET
// export function IsDriver ( un ) ; begin
46031: LD_INT 0
46033: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
46034: LD_ADDR_VAR 0 2
46038: PUSH
46039: LD_VAR 0 1
46043: PUSH
46044: LD_INT 55
46046: PUSH
46047: EMPTY
46048: LIST
46049: PPUSH
46050: CALL_OW 69
46054: IN
46055: ST_TO_ADDR
// end ;
46056: LD_VAR 0 2
46060: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
46061: LD_INT 0
46063: PPUSH
46064: PPUSH
// list := [ ] ;
46065: LD_ADDR_VAR 0 5
46069: PUSH
46070: EMPTY
46071: ST_TO_ADDR
// case d of 0 :
46072: LD_VAR 0 3
46076: PUSH
46077: LD_INT 0
46079: DOUBLE
46080: EQUAL
46081: IFTRUE 46085
46083: GO 46218
46085: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
46086: LD_ADDR_VAR 0 5
46090: PUSH
46091: LD_VAR 0 1
46095: PUSH
46096: LD_INT 4
46098: MINUS
46099: PUSH
46100: LD_VAR 0 2
46104: PUSH
46105: LD_INT 4
46107: MINUS
46108: PUSH
46109: LD_INT 2
46111: PUSH
46112: EMPTY
46113: LIST
46114: LIST
46115: LIST
46116: PUSH
46117: LD_VAR 0 1
46121: PUSH
46122: LD_INT 3
46124: MINUS
46125: PUSH
46126: LD_VAR 0 2
46130: PUSH
46131: LD_INT 1
46133: PUSH
46134: EMPTY
46135: LIST
46136: LIST
46137: LIST
46138: PUSH
46139: LD_VAR 0 1
46143: PUSH
46144: LD_INT 4
46146: PLUS
46147: PUSH
46148: LD_VAR 0 2
46152: PUSH
46153: LD_INT 4
46155: PUSH
46156: EMPTY
46157: LIST
46158: LIST
46159: LIST
46160: PUSH
46161: LD_VAR 0 1
46165: PUSH
46166: LD_INT 3
46168: PLUS
46169: PUSH
46170: LD_VAR 0 2
46174: PUSH
46175: LD_INT 3
46177: PLUS
46178: PUSH
46179: LD_INT 5
46181: PUSH
46182: EMPTY
46183: LIST
46184: LIST
46185: LIST
46186: PUSH
46187: LD_VAR 0 1
46191: PUSH
46192: LD_VAR 0 2
46196: PUSH
46197: LD_INT 4
46199: PLUS
46200: PUSH
46201: LD_INT 0
46203: PUSH
46204: EMPTY
46205: LIST
46206: LIST
46207: LIST
46208: PUSH
46209: EMPTY
46210: LIST
46211: LIST
46212: LIST
46213: LIST
46214: LIST
46215: ST_TO_ADDR
// end ; 1 :
46216: GO 46916
46218: LD_INT 1
46220: DOUBLE
46221: EQUAL
46222: IFTRUE 46226
46224: GO 46359
46226: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
46227: LD_ADDR_VAR 0 5
46231: PUSH
46232: LD_VAR 0 1
46236: PUSH
46237: LD_VAR 0 2
46241: PUSH
46242: LD_INT 4
46244: MINUS
46245: PUSH
46246: LD_INT 3
46248: PUSH
46249: EMPTY
46250: LIST
46251: LIST
46252: LIST
46253: PUSH
46254: LD_VAR 0 1
46258: PUSH
46259: LD_INT 3
46261: MINUS
46262: PUSH
46263: LD_VAR 0 2
46267: PUSH
46268: LD_INT 3
46270: MINUS
46271: PUSH
46272: LD_INT 2
46274: PUSH
46275: EMPTY
46276: LIST
46277: LIST
46278: LIST
46279: PUSH
46280: LD_VAR 0 1
46284: PUSH
46285: LD_INT 4
46287: MINUS
46288: PUSH
46289: LD_VAR 0 2
46293: PUSH
46294: LD_INT 1
46296: PUSH
46297: EMPTY
46298: LIST
46299: LIST
46300: LIST
46301: PUSH
46302: LD_VAR 0 1
46306: PUSH
46307: LD_VAR 0 2
46311: PUSH
46312: LD_INT 3
46314: PLUS
46315: PUSH
46316: LD_INT 0
46318: PUSH
46319: EMPTY
46320: LIST
46321: LIST
46322: LIST
46323: PUSH
46324: LD_VAR 0 1
46328: PUSH
46329: LD_INT 4
46331: PLUS
46332: PUSH
46333: LD_VAR 0 2
46337: PUSH
46338: LD_INT 4
46340: PLUS
46341: PUSH
46342: LD_INT 5
46344: PUSH
46345: EMPTY
46346: LIST
46347: LIST
46348: LIST
46349: PUSH
46350: EMPTY
46351: LIST
46352: LIST
46353: LIST
46354: LIST
46355: LIST
46356: ST_TO_ADDR
// end ; 2 :
46357: GO 46916
46359: LD_INT 2
46361: DOUBLE
46362: EQUAL
46363: IFTRUE 46367
46365: GO 46496
46367: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
46368: LD_ADDR_VAR 0 5
46372: PUSH
46373: LD_VAR 0 1
46377: PUSH
46378: LD_VAR 0 2
46382: PUSH
46383: LD_INT 3
46385: MINUS
46386: PUSH
46387: LD_INT 3
46389: PUSH
46390: EMPTY
46391: LIST
46392: LIST
46393: LIST
46394: PUSH
46395: LD_VAR 0 1
46399: PUSH
46400: LD_INT 4
46402: PLUS
46403: PUSH
46404: LD_VAR 0 2
46408: PUSH
46409: LD_INT 4
46411: PUSH
46412: EMPTY
46413: LIST
46414: LIST
46415: LIST
46416: PUSH
46417: LD_VAR 0 1
46421: PUSH
46422: LD_VAR 0 2
46426: PUSH
46427: LD_INT 4
46429: PLUS
46430: PUSH
46431: LD_INT 0
46433: PUSH
46434: EMPTY
46435: LIST
46436: LIST
46437: LIST
46438: PUSH
46439: LD_VAR 0 1
46443: PUSH
46444: LD_INT 3
46446: MINUS
46447: PUSH
46448: LD_VAR 0 2
46452: PUSH
46453: LD_INT 1
46455: PUSH
46456: EMPTY
46457: LIST
46458: LIST
46459: LIST
46460: PUSH
46461: LD_VAR 0 1
46465: PUSH
46466: LD_INT 4
46468: MINUS
46469: PUSH
46470: LD_VAR 0 2
46474: PUSH
46475: LD_INT 4
46477: MINUS
46478: PUSH
46479: LD_INT 2
46481: PUSH
46482: EMPTY
46483: LIST
46484: LIST
46485: LIST
46486: PUSH
46487: EMPTY
46488: LIST
46489: LIST
46490: LIST
46491: LIST
46492: LIST
46493: ST_TO_ADDR
// end ; 3 :
46494: GO 46916
46496: LD_INT 3
46498: DOUBLE
46499: EQUAL
46500: IFTRUE 46504
46502: GO 46637
46504: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
46505: LD_ADDR_VAR 0 5
46509: PUSH
46510: LD_VAR 0 1
46514: PUSH
46515: LD_INT 3
46517: PLUS
46518: PUSH
46519: LD_VAR 0 2
46523: PUSH
46524: LD_INT 4
46526: PUSH
46527: EMPTY
46528: LIST
46529: LIST
46530: LIST
46531: PUSH
46532: LD_VAR 0 1
46536: PUSH
46537: LD_INT 4
46539: PLUS
46540: PUSH
46541: LD_VAR 0 2
46545: PUSH
46546: LD_INT 4
46548: PLUS
46549: PUSH
46550: LD_INT 5
46552: PUSH
46553: EMPTY
46554: LIST
46555: LIST
46556: LIST
46557: PUSH
46558: LD_VAR 0 1
46562: PUSH
46563: LD_INT 4
46565: MINUS
46566: PUSH
46567: LD_VAR 0 2
46571: PUSH
46572: LD_INT 1
46574: PUSH
46575: EMPTY
46576: LIST
46577: LIST
46578: LIST
46579: PUSH
46580: LD_VAR 0 1
46584: PUSH
46585: LD_VAR 0 2
46589: PUSH
46590: LD_INT 4
46592: MINUS
46593: PUSH
46594: LD_INT 3
46596: PUSH
46597: EMPTY
46598: LIST
46599: LIST
46600: LIST
46601: PUSH
46602: LD_VAR 0 1
46606: PUSH
46607: LD_INT 3
46609: MINUS
46610: PUSH
46611: LD_VAR 0 2
46615: PUSH
46616: LD_INT 3
46618: MINUS
46619: PUSH
46620: LD_INT 2
46622: PUSH
46623: EMPTY
46624: LIST
46625: LIST
46626: LIST
46627: PUSH
46628: EMPTY
46629: LIST
46630: LIST
46631: LIST
46632: LIST
46633: LIST
46634: ST_TO_ADDR
// end ; 4 :
46635: GO 46916
46637: LD_INT 4
46639: DOUBLE
46640: EQUAL
46641: IFTRUE 46645
46643: GO 46778
46645: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
46646: LD_ADDR_VAR 0 5
46650: PUSH
46651: LD_VAR 0 1
46655: PUSH
46656: LD_VAR 0 2
46660: PUSH
46661: LD_INT 4
46663: PLUS
46664: PUSH
46665: LD_INT 0
46667: PUSH
46668: EMPTY
46669: LIST
46670: LIST
46671: LIST
46672: PUSH
46673: LD_VAR 0 1
46677: PUSH
46678: LD_INT 3
46680: PLUS
46681: PUSH
46682: LD_VAR 0 2
46686: PUSH
46687: LD_INT 3
46689: PLUS
46690: PUSH
46691: LD_INT 5
46693: PUSH
46694: EMPTY
46695: LIST
46696: LIST
46697: LIST
46698: PUSH
46699: LD_VAR 0 1
46703: PUSH
46704: LD_INT 4
46706: PLUS
46707: PUSH
46708: LD_VAR 0 2
46712: PUSH
46713: LD_INT 4
46715: PUSH
46716: EMPTY
46717: LIST
46718: LIST
46719: LIST
46720: PUSH
46721: LD_VAR 0 1
46725: PUSH
46726: LD_VAR 0 2
46730: PUSH
46731: LD_INT 3
46733: MINUS
46734: PUSH
46735: LD_INT 3
46737: PUSH
46738: EMPTY
46739: LIST
46740: LIST
46741: LIST
46742: PUSH
46743: LD_VAR 0 1
46747: PUSH
46748: LD_INT 4
46750: MINUS
46751: PUSH
46752: LD_VAR 0 2
46756: PUSH
46757: LD_INT 4
46759: MINUS
46760: PUSH
46761: LD_INT 2
46763: PUSH
46764: EMPTY
46765: LIST
46766: LIST
46767: LIST
46768: PUSH
46769: EMPTY
46770: LIST
46771: LIST
46772: LIST
46773: LIST
46774: LIST
46775: ST_TO_ADDR
// end ; 5 :
46776: GO 46916
46778: LD_INT 5
46780: DOUBLE
46781: EQUAL
46782: IFTRUE 46786
46784: GO 46915
46786: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
46787: LD_ADDR_VAR 0 5
46791: PUSH
46792: LD_VAR 0 1
46796: PUSH
46797: LD_INT 4
46799: MINUS
46800: PUSH
46801: LD_VAR 0 2
46805: PUSH
46806: LD_INT 1
46808: PUSH
46809: EMPTY
46810: LIST
46811: LIST
46812: LIST
46813: PUSH
46814: LD_VAR 0 1
46818: PUSH
46819: LD_VAR 0 2
46823: PUSH
46824: LD_INT 4
46826: MINUS
46827: PUSH
46828: LD_INT 3
46830: PUSH
46831: EMPTY
46832: LIST
46833: LIST
46834: LIST
46835: PUSH
46836: LD_VAR 0 1
46840: PUSH
46841: LD_INT 4
46843: PLUS
46844: PUSH
46845: LD_VAR 0 2
46849: PUSH
46850: LD_INT 4
46852: PLUS
46853: PUSH
46854: LD_INT 5
46856: PUSH
46857: EMPTY
46858: LIST
46859: LIST
46860: LIST
46861: PUSH
46862: LD_VAR 0 1
46866: PUSH
46867: LD_INT 3
46869: PLUS
46870: PUSH
46871: LD_VAR 0 2
46875: PUSH
46876: LD_INT 4
46878: PUSH
46879: EMPTY
46880: LIST
46881: LIST
46882: LIST
46883: PUSH
46884: LD_VAR 0 1
46888: PUSH
46889: LD_VAR 0 2
46893: PUSH
46894: LD_INT 3
46896: PLUS
46897: PUSH
46898: LD_INT 0
46900: PUSH
46901: EMPTY
46902: LIST
46903: LIST
46904: LIST
46905: PUSH
46906: EMPTY
46907: LIST
46908: LIST
46909: LIST
46910: LIST
46911: LIST
46912: ST_TO_ADDR
// end ; end ;
46913: GO 46916
46915: POP
// result := list ;
46916: LD_ADDR_VAR 0 4
46920: PUSH
46921: LD_VAR 0 5
46925: ST_TO_ADDR
// end ;
46926: LD_VAR 0 4
46930: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
46931: LD_INT 0
46933: PPUSH
46934: PPUSH
46935: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
46936: LD_VAR 0 1
46940: NOT
46941: PUSH
46942: LD_VAR 0 2
46946: PUSH
46947: LD_INT 1
46949: PUSH
46950: LD_INT 2
46952: PUSH
46953: LD_INT 3
46955: PUSH
46956: LD_INT 4
46958: PUSH
46959: EMPTY
46960: LIST
46961: LIST
46962: LIST
46963: LIST
46964: IN
46965: NOT
46966: OR
46967: IFFALSE 46971
// exit ;
46969: GO 47054
// tmp := [ ] ;
46971: LD_ADDR_VAR 0 5
46975: PUSH
46976: EMPTY
46977: ST_TO_ADDR
// for i in units do
46978: LD_ADDR_VAR 0 4
46982: PUSH
46983: LD_VAR 0 1
46987: PUSH
46988: FOR_IN
46989: IFFALSE 47023
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
46991: LD_ADDR_VAR 0 5
46995: PUSH
46996: LD_VAR 0 5
47000: PPUSH
47001: LD_VAR 0 4
47005: PPUSH
47006: LD_VAR 0 2
47010: PPUSH
47011: CALL_OW 259
47015: PPUSH
47016: CALL 48413 0 2
47020: ST_TO_ADDR
47021: GO 46988
47023: POP
47024: POP
// if not tmp then
47025: LD_VAR 0 5
47029: NOT
47030: IFFALSE 47034
// exit ;
47032: GO 47054
// result := SortListByListDesc ( units , tmp ) ;
47034: LD_ADDR_VAR 0 3
47038: PUSH
47039: LD_VAR 0 1
47043: PPUSH
47044: LD_VAR 0 5
47048: PPUSH
47049: CALL_OW 77
47053: ST_TO_ADDR
// end ;
47054: LD_VAR 0 3
47058: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
47059: LD_INT 0
47061: PPUSH
47062: PPUSH
47063: PPUSH
// result := false ;
47064: LD_ADDR_VAR 0 3
47068: PUSH
47069: LD_INT 0
47071: ST_TO_ADDR
// x := GetX ( building ) ;
47072: LD_ADDR_VAR 0 4
47076: PUSH
47077: LD_VAR 0 2
47081: PPUSH
47082: CALL_OW 250
47086: ST_TO_ADDR
// y := GetY ( building ) ;
47087: LD_ADDR_VAR 0 5
47091: PUSH
47092: LD_VAR 0 2
47096: PPUSH
47097: CALL_OW 251
47101: ST_TO_ADDR
// if not building or not x or not y then
47102: LD_VAR 0 2
47106: NOT
47107: PUSH
47108: LD_VAR 0 4
47112: NOT
47113: OR
47114: PUSH
47115: LD_VAR 0 5
47119: NOT
47120: OR
47121: IFFALSE 47125
// exit ;
47123: GO 47217
// if GetTaskList ( unit ) then
47125: LD_VAR 0 1
47129: PPUSH
47130: CALL_OW 437
47134: IFFALSE 47217
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
47136: LD_STRING e
47138: PUSH
47139: LD_VAR 0 1
47143: PPUSH
47144: CALL_OW 437
47148: PUSH
47149: LD_INT 1
47151: ARRAY
47152: PUSH
47153: LD_INT 1
47155: ARRAY
47156: EQUAL
47157: PUSH
47158: LD_VAR 0 4
47162: PUSH
47163: LD_VAR 0 1
47167: PPUSH
47168: CALL_OW 437
47172: PUSH
47173: LD_INT 1
47175: ARRAY
47176: PUSH
47177: LD_INT 2
47179: ARRAY
47180: EQUAL
47181: AND
47182: PUSH
47183: LD_VAR 0 5
47187: PUSH
47188: LD_VAR 0 1
47192: PPUSH
47193: CALL_OW 437
47197: PUSH
47198: LD_INT 1
47200: ARRAY
47201: PUSH
47202: LD_INT 3
47204: ARRAY
47205: EQUAL
47206: AND
47207: IFFALSE 47217
// result := true end ;
47209: LD_ADDR_VAR 0 3
47213: PUSH
47214: LD_INT 1
47216: ST_TO_ADDR
// end ;
47217: LD_VAR 0 3
47221: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
47222: LD_INT 0
47224: PPUSH
// result := false ;
47225: LD_ADDR_VAR 0 4
47229: PUSH
47230: LD_INT 0
47232: ST_TO_ADDR
// if GetTaskList ( unit ) then
47233: LD_VAR 0 1
47237: PPUSH
47238: CALL_OW 437
47242: IFFALSE 47325
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
47244: LD_STRING M
47246: PUSH
47247: LD_VAR 0 1
47251: PPUSH
47252: CALL_OW 437
47256: PUSH
47257: LD_INT 1
47259: ARRAY
47260: PUSH
47261: LD_INT 1
47263: ARRAY
47264: EQUAL
47265: PUSH
47266: LD_VAR 0 2
47270: PUSH
47271: LD_VAR 0 1
47275: PPUSH
47276: CALL_OW 437
47280: PUSH
47281: LD_INT 1
47283: ARRAY
47284: PUSH
47285: LD_INT 2
47287: ARRAY
47288: EQUAL
47289: AND
47290: PUSH
47291: LD_VAR 0 3
47295: PUSH
47296: LD_VAR 0 1
47300: PPUSH
47301: CALL_OW 437
47305: PUSH
47306: LD_INT 1
47308: ARRAY
47309: PUSH
47310: LD_INT 3
47312: ARRAY
47313: EQUAL
47314: AND
47315: IFFALSE 47325
// result := true ;
47317: LD_ADDR_VAR 0 4
47321: PUSH
47322: LD_INT 1
47324: ST_TO_ADDR
// end ; end ;
47325: LD_VAR 0 4
47329: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
47330: LD_INT 0
47332: PPUSH
47333: PPUSH
47334: PPUSH
47335: PPUSH
// if not unit or not area then
47336: LD_VAR 0 1
47340: NOT
47341: PUSH
47342: LD_VAR 0 2
47346: NOT
47347: OR
47348: IFFALSE 47352
// exit ;
47350: GO 47516
// tmp := AreaToList ( area , i ) ;
47352: LD_ADDR_VAR 0 6
47356: PUSH
47357: LD_VAR 0 2
47361: PPUSH
47362: LD_VAR 0 5
47366: PPUSH
47367: CALL_OW 517
47371: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
47372: LD_ADDR_VAR 0 5
47376: PUSH
47377: DOUBLE
47378: LD_INT 1
47380: DEC
47381: ST_TO_ADDR
47382: LD_VAR 0 6
47386: PUSH
47387: LD_INT 1
47389: ARRAY
47390: PUSH
47391: FOR_TO
47392: IFFALSE 47514
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
47394: LD_ADDR_VAR 0 7
47398: PUSH
47399: LD_VAR 0 6
47403: PUSH
47404: LD_INT 1
47406: ARRAY
47407: PUSH
47408: LD_VAR 0 5
47412: ARRAY
47413: PUSH
47414: LD_VAR 0 6
47418: PUSH
47419: LD_INT 2
47421: ARRAY
47422: PUSH
47423: LD_VAR 0 5
47427: ARRAY
47428: PUSH
47429: EMPTY
47430: LIST
47431: LIST
47432: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
47433: LD_VAR 0 7
47437: PUSH
47438: LD_INT 1
47440: ARRAY
47441: PPUSH
47442: LD_VAR 0 7
47446: PUSH
47447: LD_INT 2
47449: ARRAY
47450: PPUSH
47451: CALL_OW 428
47455: PUSH
47456: LD_INT 0
47458: EQUAL
47459: IFFALSE 47512
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
47461: LD_VAR 0 1
47465: PPUSH
47466: LD_VAR 0 7
47470: PUSH
47471: LD_INT 1
47473: ARRAY
47474: PPUSH
47475: LD_VAR 0 7
47479: PUSH
47480: LD_INT 2
47482: ARRAY
47483: PPUSH
47484: LD_VAR 0 3
47488: PPUSH
47489: CALL_OW 48
// result := IsPlaced ( unit ) ;
47493: LD_ADDR_VAR 0 4
47497: PUSH
47498: LD_VAR 0 1
47502: PPUSH
47503: CALL_OW 305
47507: ST_TO_ADDR
// exit ;
47508: POP
47509: POP
47510: GO 47516
// end ; end ;
47512: GO 47391
47514: POP
47515: POP
// end ;
47516: LD_VAR 0 4
47520: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
47521: LD_INT 0
47523: PPUSH
47524: PPUSH
47525: PPUSH
// if not side or side > 8 then
47526: LD_VAR 0 1
47530: NOT
47531: PUSH
47532: LD_VAR 0 1
47536: PUSH
47537: LD_INT 8
47539: GREATER
47540: OR
47541: IFFALSE 47545
// exit ;
47543: GO 47732
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
47545: LD_ADDR_VAR 0 4
47549: PUSH
47550: LD_INT 22
47552: PUSH
47553: LD_VAR 0 1
47557: PUSH
47558: EMPTY
47559: LIST
47560: LIST
47561: PUSH
47562: LD_INT 21
47564: PUSH
47565: LD_INT 3
47567: PUSH
47568: EMPTY
47569: LIST
47570: LIST
47571: PUSH
47572: EMPTY
47573: LIST
47574: LIST
47575: PPUSH
47576: CALL_OW 69
47580: ST_TO_ADDR
// if not tmp then
47581: LD_VAR 0 4
47585: NOT
47586: IFFALSE 47590
// exit ;
47588: GO 47732
// enable_addtolog := true ;
47590: LD_ADDR_OWVAR 81
47594: PUSH
47595: LD_INT 1
47597: ST_TO_ADDR
// AddToLog ( [ ) ;
47598: LD_STRING [
47600: PPUSH
47601: CALL_OW 561
// for i in tmp do
47605: LD_ADDR_VAR 0 3
47609: PUSH
47610: LD_VAR 0 4
47614: PUSH
47615: FOR_IN
47616: IFFALSE 47723
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
47618: LD_STRING [
47620: PUSH
47621: LD_VAR 0 3
47625: PPUSH
47626: CALL_OW 266
47630: STR
47631: PUSH
47632: LD_STRING , 
47634: STR
47635: PUSH
47636: LD_VAR 0 3
47640: PPUSH
47641: CALL_OW 250
47645: STR
47646: PUSH
47647: LD_STRING , 
47649: STR
47650: PUSH
47651: LD_VAR 0 3
47655: PPUSH
47656: CALL_OW 251
47660: STR
47661: PUSH
47662: LD_STRING , 
47664: STR
47665: PUSH
47666: LD_VAR 0 3
47670: PPUSH
47671: CALL_OW 254
47675: STR
47676: PUSH
47677: LD_STRING , 
47679: STR
47680: PUSH
47681: LD_VAR 0 3
47685: PPUSH
47686: LD_INT 1
47688: PPUSH
47689: CALL_OW 268
47693: STR
47694: PUSH
47695: LD_STRING , 
47697: STR
47698: PUSH
47699: LD_VAR 0 3
47703: PPUSH
47704: LD_INT 2
47706: PPUSH
47707: CALL_OW 268
47711: STR
47712: PUSH
47713: LD_STRING ],
47715: STR
47716: PPUSH
47717: CALL_OW 561
// end ;
47721: GO 47615
47723: POP
47724: POP
// AddToLog ( ]; ) ;
47725: LD_STRING ];
47727: PPUSH
47728: CALL_OW 561
// end ;
47732: LD_VAR 0 2
47736: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
47737: LD_INT 0
47739: PPUSH
47740: PPUSH
47741: PPUSH
47742: PPUSH
47743: PPUSH
// if not area or not rate or not max then
47744: LD_VAR 0 1
47748: NOT
47749: PUSH
47750: LD_VAR 0 2
47754: NOT
47755: OR
47756: PUSH
47757: LD_VAR 0 4
47761: NOT
47762: OR
47763: IFFALSE 47767
// exit ;
47765: GO 47956
// while 1 do
47767: LD_INT 1
47769: IFFALSE 47956
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
47771: LD_ADDR_VAR 0 9
47775: PUSH
47776: LD_VAR 0 1
47780: PPUSH
47781: LD_INT 1
47783: PPUSH
47784: CALL_OW 287
47788: PUSH
47789: LD_INT 10
47791: MUL
47792: ST_TO_ADDR
// r := rate / 10 ;
47793: LD_ADDR_VAR 0 7
47797: PUSH
47798: LD_VAR 0 2
47802: PUSH
47803: LD_INT 10
47805: DIVREAL
47806: ST_TO_ADDR
// time := 1 1$00 ;
47807: LD_ADDR_VAR 0 8
47811: PUSH
47812: LD_INT 2100
47814: ST_TO_ADDR
// if amount < min then
47815: LD_VAR 0 9
47819: PUSH
47820: LD_VAR 0 3
47824: LESS
47825: IFFALSE 47843
// r := r * 2 else
47827: LD_ADDR_VAR 0 7
47831: PUSH
47832: LD_VAR 0 7
47836: PUSH
47837: LD_INT 2
47839: MUL
47840: ST_TO_ADDR
47841: GO 47869
// if amount > max then
47843: LD_VAR 0 9
47847: PUSH
47848: LD_VAR 0 4
47852: GREATER
47853: IFFALSE 47869
// r := r / 2 ;
47855: LD_ADDR_VAR 0 7
47859: PUSH
47860: LD_VAR 0 7
47864: PUSH
47865: LD_INT 2
47867: DIVREAL
47868: ST_TO_ADDR
// time := time / r ;
47869: LD_ADDR_VAR 0 8
47873: PUSH
47874: LD_VAR 0 8
47878: PUSH
47879: LD_VAR 0 7
47883: DIVREAL
47884: ST_TO_ADDR
// if time < 0 then
47885: LD_VAR 0 8
47889: PUSH
47890: LD_INT 0
47892: LESS
47893: IFFALSE 47910
// time := time * - 1 ;
47895: LD_ADDR_VAR 0 8
47899: PUSH
47900: LD_VAR 0 8
47904: PUSH
47905: LD_INT 1
47907: NEG
47908: MUL
47909: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
47910: LD_VAR 0 8
47914: PUSH
47915: LD_INT 35
47917: PPUSH
47918: LD_INT 875
47920: PPUSH
47921: CALL_OW 12
47925: PLUS
47926: PPUSH
47927: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
47931: LD_INT 1
47933: PPUSH
47934: LD_INT 5
47936: PPUSH
47937: CALL_OW 12
47941: PPUSH
47942: LD_VAR 0 1
47946: PPUSH
47947: LD_INT 1
47949: PPUSH
47950: CALL_OW 55
// end ;
47954: GO 47767
// end ;
47956: LD_VAR 0 5
47960: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
47961: LD_INT 0
47963: PPUSH
47964: PPUSH
47965: PPUSH
47966: PPUSH
47967: PPUSH
47968: PPUSH
47969: PPUSH
47970: PPUSH
// if not turrets or not factories then
47971: LD_VAR 0 1
47975: NOT
47976: PUSH
47977: LD_VAR 0 2
47981: NOT
47982: OR
47983: IFFALSE 47987
// exit ;
47985: GO 48294
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
47987: LD_ADDR_VAR 0 10
47991: PUSH
47992: LD_INT 5
47994: PUSH
47995: LD_INT 6
47997: PUSH
47998: EMPTY
47999: LIST
48000: LIST
48001: PUSH
48002: LD_INT 2
48004: PUSH
48005: LD_INT 4
48007: PUSH
48008: EMPTY
48009: LIST
48010: LIST
48011: PUSH
48012: LD_INT 3
48014: PUSH
48015: LD_INT 5
48017: PUSH
48018: EMPTY
48019: LIST
48020: LIST
48021: PUSH
48022: EMPTY
48023: LIST
48024: LIST
48025: LIST
48026: PUSH
48027: LD_INT 24
48029: PUSH
48030: LD_INT 25
48032: PUSH
48033: EMPTY
48034: LIST
48035: LIST
48036: PUSH
48037: LD_INT 23
48039: PUSH
48040: LD_INT 27
48042: PUSH
48043: EMPTY
48044: LIST
48045: LIST
48046: PUSH
48047: EMPTY
48048: LIST
48049: LIST
48050: PUSH
48051: LD_INT 42
48053: PUSH
48054: LD_INT 43
48056: PUSH
48057: EMPTY
48058: LIST
48059: LIST
48060: PUSH
48061: LD_INT 44
48063: PUSH
48064: LD_INT 46
48066: PUSH
48067: EMPTY
48068: LIST
48069: LIST
48070: PUSH
48071: LD_INT 45
48073: PUSH
48074: LD_INT 47
48076: PUSH
48077: EMPTY
48078: LIST
48079: LIST
48080: PUSH
48081: EMPTY
48082: LIST
48083: LIST
48084: LIST
48085: PUSH
48086: EMPTY
48087: LIST
48088: LIST
48089: LIST
48090: ST_TO_ADDR
// result := [ ] ;
48091: LD_ADDR_VAR 0 3
48095: PUSH
48096: EMPTY
48097: ST_TO_ADDR
// for i in turrets do
48098: LD_ADDR_VAR 0 4
48102: PUSH
48103: LD_VAR 0 1
48107: PUSH
48108: FOR_IN
48109: IFFALSE 48292
// begin nat := GetNation ( i ) ;
48111: LD_ADDR_VAR 0 7
48115: PUSH
48116: LD_VAR 0 4
48120: PPUSH
48121: CALL_OW 248
48125: ST_TO_ADDR
// weapon := 0 ;
48126: LD_ADDR_VAR 0 8
48130: PUSH
48131: LD_INT 0
48133: ST_TO_ADDR
// if not nat then
48134: LD_VAR 0 7
48138: NOT
48139: IFFALSE 48143
// continue ;
48141: GO 48108
// for j in list [ nat ] do
48143: LD_ADDR_VAR 0 5
48147: PUSH
48148: LD_VAR 0 10
48152: PUSH
48153: LD_VAR 0 7
48157: ARRAY
48158: PUSH
48159: FOR_IN
48160: IFFALSE 48201
// if GetBWeapon ( i ) = j [ 1 ] then
48162: LD_VAR 0 4
48166: PPUSH
48167: CALL_OW 269
48171: PUSH
48172: LD_VAR 0 5
48176: PUSH
48177: LD_INT 1
48179: ARRAY
48180: EQUAL
48181: IFFALSE 48199
// begin weapon := j [ 2 ] ;
48183: LD_ADDR_VAR 0 8
48187: PUSH
48188: LD_VAR 0 5
48192: PUSH
48193: LD_INT 2
48195: ARRAY
48196: ST_TO_ADDR
// break ;
48197: GO 48201
// end ;
48199: GO 48159
48201: POP
48202: POP
// if not weapon then
48203: LD_VAR 0 8
48207: NOT
48208: IFFALSE 48212
// continue ;
48210: GO 48108
// for k in factories do
48212: LD_ADDR_VAR 0 6
48216: PUSH
48217: LD_VAR 0 2
48221: PUSH
48222: FOR_IN
48223: IFFALSE 48288
// begin weapons := AvailableWeaponList ( k ) ;
48225: LD_ADDR_VAR 0 9
48229: PUSH
48230: LD_VAR 0 6
48234: PPUSH
48235: CALL_OW 478
48239: ST_TO_ADDR
// if not weapons then
48240: LD_VAR 0 9
48244: NOT
48245: IFFALSE 48249
// continue ;
48247: GO 48222
// if weapon in weapons then
48249: LD_VAR 0 8
48253: PUSH
48254: LD_VAR 0 9
48258: IN
48259: IFFALSE 48286
// begin result := [ i , weapon ] ;
48261: LD_ADDR_VAR 0 3
48265: PUSH
48266: LD_VAR 0 4
48270: PUSH
48271: LD_VAR 0 8
48275: PUSH
48276: EMPTY
48277: LIST
48278: LIST
48279: ST_TO_ADDR
// exit ;
48280: POP
48281: POP
48282: POP
48283: POP
48284: GO 48294
// end ; end ;
48286: GO 48222
48288: POP
48289: POP
// end ;
48290: GO 48108
48292: POP
48293: POP
// end ;
48294: LD_VAR 0 3
48298: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
48299: LD_INT 0
48301: PPUSH
// if not side or side > 8 then
48302: LD_VAR 0 3
48306: NOT
48307: PUSH
48308: LD_VAR 0 3
48312: PUSH
48313: LD_INT 8
48315: GREATER
48316: OR
48317: IFFALSE 48321
// exit ;
48319: GO 48380
// if not range then
48321: LD_VAR 0 4
48325: NOT
48326: IFFALSE 48337
// range := - 12 ;
48328: LD_ADDR_VAR 0 4
48332: PUSH
48333: LD_INT 12
48335: NEG
48336: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
48337: LD_VAR 0 1
48341: PPUSH
48342: LD_VAR 0 2
48346: PPUSH
48347: LD_VAR 0 3
48351: PPUSH
48352: LD_VAR 0 4
48356: PPUSH
48357: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
48361: LD_VAR 0 1
48365: PPUSH
48366: LD_VAR 0 2
48370: PPUSH
48371: LD_VAR 0 3
48375: PPUSH
48376: CALL_OW 331
// end ;
48380: LD_VAR 0 5
48384: RET
// export function Video ( mode ) ; begin
48385: LD_INT 0
48387: PPUSH
// ingame_video = mode ;
48388: LD_ADDR_OWVAR 52
48392: PUSH
48393: LD_VAR 0 1
48397: ST_TO_ADDR
// interface_hidden = mode ;
48398: LD_ADDR_OWVAR 54
48402: PUSH
48403: LD_VAR 0 1
48407: ST_TO_ADDR
// end ;
48408: LD_VAR 0 2
48412: RET
// export function Join ( array , element ) ; begin
48413: LD_INT 0
48415: PPUSH
// result := Replace ( array , array + 1 , element ) ;
48416: LD_ADDR_VAR 0 3
48420: PUSH
48421: LD_VAR 0 1
48425: PPUSH
48426: LD_VAR 0 1
48430: PUSH
48431: LD_INT 1
48433: PLUS
48434: PPUSH
48435: LD_VAR 0 2
48439: PPUSH
48440: CALL_OW 1
48444: ST_TO_ADDR
// end ;
48445: LD_VAR 0 3
48449: RET
// export function JoinUnion ( array , element ) ; begin
48450: LD_INT 0
48452: PPUSH
// result := array union element ;
48453: LD_ADDR_VAR 0 3
48457: PUSH
48458: LD_VAR 0 1
48462: PUSH
48463: LD_VAR 0 2
48467: UNION
48468: ST_TO_ADDR
// end ;
48469: LD_VAR 0 3
48473: RET
// export function GetBehemoths ( side ) ; begin
48474: LD_INT 0
48476: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
48477: LD_ADDR_VAR 0 2
48481: PUSH
48482: LD_INT 22
48484: PUSH
48485: LD_VAR 0 1
48489: PUSH
48490: EMPTY
48491: LIST
48492: LIST
48493: PUSH
48494: LD_INT 31
48496: PUSH
48497: LD_INT 25
48499: PUSH
48500: EMPTY
48501: LIST
48502: LIST
48503: PUSH
48504: EMPTY
48505: LIST
48506: LIST
48507: PPUSH
48508: CALL_OW 69
48512: ST_TO_ADDR
// end ;
48513: LD_VAR 0 2
48517: RET
// export function Shuffle ( array ) ; var i , index ; begin
48518: LD_INT 0
48520: PPUSH
48521: PPUSH
48522: PPUSH
// result := [ ] ;
48523: LD_ADDR_VAR 0 2
48527: PUSH
48528: EMPTY
48529: ST_TO_ADDR
// if not array then
48530: LD_VAR 0 1
48534: NOT
48535: IFFALSE 48539
// exit ;
48537: GO 48638
// Randomize ;
48539: CALL_OW 10
// for i = array downto 1 do
48543: LD_ADDR_VAR 0 3
48547: PUSH
48548: DOUBLE
48549: LD_VAR 0 1
48553: INC
48554: ST_TO_ADDR
48555: LD_INT 1
48557: PUSH
48558: FOR_DOWNTO
48559: IFFALSE 48636
// begin index := rand ( 1 , array ) ;
48561: LD_ADDR_VAR 0 4
48565: PUSH
48566: LD_INT 1
48568: PPUSH
48569: LD_VAR 0 1
48573: PPUSH
48574: CALL_OW 12
48578: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
48579: LD_ADDR_VAR 0 2
48583: PUSH
48584: LD_VAR 0 2
48588: PPUSH
48589: LD_VAR 0 2
48593: PUSH
48594: LD_INT 1
48596: PLUS
48597: PPUSH
48598: LD_VAR 0 1
48602: PUSH
48603: LD_VAR 0 4
48607: ARRAY
48608: PPUSH
48609: CALL_OW 2
48613: ST_TO_ADDR
// array := Delete ( array , index ) ;
48614: LD_ADDR_VAR 0 1
48618: PUSH
48619: LD_VAR 0 1
48623: PPUSH
48624: LD_VAR 0 4
48628: PPUSH
48629: CALL_OW 3
48633: ST_TO_ADDR
// end ;
48634: GO 48558
48636: POP
48637: POP
// end ;
48638: LD_VAR 0 2
48642: RET
// export function GetBaseMaterials ( base ) ; begin
48643: LD_INT 0
48645: PPUSH
// result := [ 0 , 0 , 0 ] ;
48646: LD_ADDR_VAR 0 2
48650: PUSH
48651: LD_INT 0
48653: PUSH
48654: LD_INT 0
48656: PUSH
48657: LD_INT 0
48659: PUSH
48660: EMPTY
48661: LIST
48662: LIST
48663: LIST
48664: ST_TO_ADDR
// if not base then
48665: LD_VAR 0 1
48669: NOT
48670: IFFALSE 48674
// exit ;
48672: GO 48723
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
48674: LD_ADDR_VAR 0 2
48678: PUSH
48679: LD_VAR 0 1
48683: PPUSH
48684: LD_INT 1
48686: PPUSH
48687: CALL_OW 275
48691: PUSH
48692: LD_VAR 0 1
48696: PPUSH
48697: LD_INT 2
48699: PPUSH
48700: CALL_OW 275
48704: PUSH
48705: LD_VAR 0 1
48709: PPUSH
48710: LD_INT 3
48712: PPUSH
48713: CALL_OW 275
48717: PUSH
48718: EMPTY
48719: LIST
48720: LIST
48721: LIST
48722: ST_TO_ADDR
// end ;
48723: LD_VAR 0 2
48727: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
48728: LD_INT 0
48730: PPUSH
48731: PPUSH
// result := array ;
48732: LD_ADDR_VAR 0 3
48736: PUSH
48737: LD_VAR 0 1
48741: ST_TO_ADDR
// if size >= result then
48742: LD_VAR 0 2
48746: PUSH
48747: LD_VAR 0 3
48751: GREATEREQUAL
48752: IFFALSE 48756
// exit ;
48754: GO 48806
// if size then
48756: LD_VAR 0 2
48760: IFFALSE 48806
// for i := array downto size do
48762: LD_ADDR_VAR 0 4
48766: PUSH
48767: DOUBLE
48768: LD_VAR 0 1
48772: INC
48773: ST_TO_ADDR
48774: LD_VAR 0 2
48778: PUSH
48779: FOR_DOWNTO
48780: IFFALSE 48804
// result := Delete ( result , result ) ;
48782: LD_ADDR_VAR 0 3
48786: PUSH
48787: LD_VAR 0 3
48791: PPUSH
48792: LD_VAR 0 3
48796: PPUSH
48797: CALL_OW 3
48801: ST_TO_ADDR
48802: GO 48779
48804: POP
48805: POP
// end ;
48806: LD_VAR 0 3
48810: RET
// export function ComExit ( unit ) ; var tmp ; begin
48811: LD_INT 0
48813: PPUSH
48814: PPUSH
// if not IsInUnit ( unit ) then
48815: LD_VAR 0 1
48819: PPUSH
48820: CALL_OW 310
48824: NOT
48825: IFFALSE 48829
// exit ;
48827: GO 48889
// tmp := IsInUnit ( unit ) ;
48829: LD_ADDR_VAR 0 3
48833: PUSH
48834: LD_VAR 0 1
48838: PPUSH
48839: CALL_OW 310
48843: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
48844: LD_VAR 0 3
48848: PPUSH
48849: CALL_OW 247
48853: PUSH
48854: LD_INT 2
48856: EQUAL
48857: IFFALSE 48870
// ComExitVehicle ( unit ) else
48859: LD_VAR 0 1
48863: PPUSH
48864: CALL_OW 121
48868: GO 48879
// ComExitBuilding ( unit ) ;
48870: LD_VAR 0 1
48874: PPUSH
48875: CALL_OW 122
// result := tmp ;
48879: LD_ADDR_VAR 0 2
48883: PUSH
48884: LD_VAR 0 3
48888: ST_TO_ADDR
// end ;
48889: LD_VAR 0 2
48893: RET
// export function ComExitAll ( units ) ; var i ; begin
48894: LD_INT 0
48896: PPUSH
48897: PPUSH
// if not units then
48898: LD_VAR 0 1
48902: NOT
48903: IFFALSE 48907
// exit ;
48905: GO 48933
// for i in units do
48907: LD_ADDR_VAR 0 3
48911: PUSH
48912: LD_VAR 0 1
48916: PUSH
48917: FOR_IN
48918: IFFALSE 48931
// ComExit ( i ) ;
48920: LD_VAR 0 3
48924: PPUSH
48925: CALL 48811 0 1
48929: GO 48917
48931: POP
48932: POP
// end ;
48933: LD_VAR 0 2
48937: RET
// export function ResetHc ; begin
48938: LD_INT 0
48940: PPUSH
// InitHc ;
48941: CALL_OW 19
// hc_importance := 0 ;
48945: LD_ADDR_OWVAR 32
48949: PUSH
48950: LD_INT 0
48952: ST_TO_ADDR
// end ;
48953: LD_VAR 0 1
48957: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
48958: LD_INT 0
48960: PPUSH
48961: PPUSH
48962: PPUSH
// _x := ( x1 + x2 ) div 2 ;
48963: LD_ADDR_VAR 0 6
48967: PUSH
48968: LD_VAR 0 1
48972: PUSH
48973: LD_VAR 0 3
48977: PLUS
48978: PUSH
48979: LD_INT 2
48981: DIV
48982: ST_TO_ADDR
// if _x < 0 then
48983: LD_VAR 0 6
48987: PUSH
48988: LD_INT 0
48990: LESS
48991: IFFALSE 49008
// _x := _x * - 1 ;
48993: LD_ADDR_VAR 0 6
48997: PUSH
48998: LD_VAR 0 6
49002: PUSH
49003: LD_INT 1
49005: NEG
49006: MUL
49007: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
49008: LD_ADDR_VAR 0 7
49012: PUSH
49013: LD_VAR 0 2
49017: PUSH
49018: LD_VAR 0 4
49022: PLUS
49023: PUSH
49024: LD_INT 2
49026: DIV
49027: ST_TO_ADDR
// if _y < 0 then
49028: LD_VAR 0 7
49032: PUSH
49033: LD_INT 0
49035: LESS
49036: IFFALSE 49053
// _y := _y * - 1 ;
49038: LD_ADDR_VAR 0 7
49042: PUSH
49043: LD_VAR 0 7
49047: PUSH
49048: LD_INT 1
49050: NEG
49051: MUL
49052: ST_TO_ADDR
// result := [ _x , _y ] ;
49053: LD_ADDR_VAR 0 5
49057: PUSH
49058: LD_VAR 0 6
49062: PUSH
49063: LD_VAR 0 7
49067: PUSH
49068: EMPTY
49069: LIST
49070: LIST
49071: ST_TO_ADDR
// end ;
49072: LD_VAR 0 5
49076: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
49077: LD_INT 0
49079: PPUSH
49080: PPUSH
49081: PPUSH
49082: PPUSH
// task := GetTaskList ( unit ) ;
49083: LD_ADDR_VAR 0 7
49087: PUSH
49088: LD_VAR 0 1
49092: PPUSH
49093: CALL_OW 437
49097: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
49098: LD_VAR 0 7
49102: NOT
49103: PUSH
49104: LD_VAR 0 1
49108: PPUSH
49109: LD_VAR 0 2
49113: PPUSH
49114: CALL_OW 308
49118: NOT
49119: AND
49120: IFFALSE 49124
// exit ;
49122: GO 49242
// if IsInArea ( unit , area ) then
49124: LD_VAR 0 1
49128: PPUSH
49129: LD_VAR 0 2
49133: PPUSH
49134: CALL_OW 308
49138: IFFALSE 49156
// begin ComMoveToArea ( unit , goAway ) ;
49140: LD_VAR 0 1
49144: PPUSH
49145: LD_VAR 0 3
49149: PPUSH
49150: CALL_OW 113
// exit ;
49154: GO 49242
// end ; if task [ 1 ] [ 1 ] <> M then
49156: LD_VAR 0 7
49160: PUSH
49161: LD_INT 1
49163: ARRAY
49164: PUSH
49165: LD_INT 1
49167: ARRAY
49168: PUSH
49169: LD_STRING M
49171: NONEQUAL
49172: IFFALSE 49176
// exit ;
49174: GO 49242
// x := task [ 1 ] [ 2 ] ;
49176: LD_ADDR_VAR 0 5
49180: PUSH
49181: LD_VAR 0 7
49185: PUSH
49186: LD_INT 1
49188: ARRAY
49189: PUSH
49190: LD_INT 2
49192: ARRAY
49193: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
49194: LD_ADDR_VAR 0 6
49198: PUSH
49199: LD_VAR 0 7
49203: PUSH
49204: LD_INT 1
49206: ARRAY
49207: PUSH
49208: LD_INT 3
49210: ARRAY
49211: ST_TO_ADDR
// if InArea ( x , y , area ) then
49212: LD_VAR 0 5
49216: PPUSH
49217: LD_VAR 0 6
49221: PPUSH
49222: LD_VAR 0 2
49226: PPUSH
49227: CALL_OW 309
49231: IFFALSE 49242
// ComStop ( unit ) ;
49233: LD_VAR 0 1
49237: PPUSH
49238: CALL_OW 141
// end ;
49242: LD_VAR 0 4
49246: RET
// export function Abs ( value ) ; begin
49247: LD_INT 0
49249: PPUSH
// result := value ;
49250: LD_ADDR_VAR 0 2
49254: PUSH
49255: LD_VAR 0 1
49259: ST_TO_ADDR
// if value < 0 then
49260: LD_VAR 0 1
49264: PUSH
49265: LD_INT 0
49267: LESS
49268: IFFALSE 49285
// result := value * - 1 ;
49270: LD_ADDR_VAR 0 2
49274: PUSH
49275: LD_VAR 0 1
49279: PUSH
49280: LD_INT 1
49282: NEG
49283: MUL
49284: ST_TO_ADDR
// end ;
49285: LD_VAR 0 2
49289: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
49290: LD_INT 0
49292: PPUSH
49293: PPUSH
49294: PPUSH
49295: PPUSH
49296: PPUSH
49297: PPUSH
49298: PPUSH
49299: PPUSH
// if not unit or not building then
49300: LD_VAR 0 1
49304: NOT
49305: PUSH
49306: LD_VAR 0 2
49310: NOT
49311: OR
49312: IFFALSE 49316
// exit ;
49314: GO 49542
// x := GetX ( building ) ;
49316: LD_ADDR_VAR 0 4
49320: PUSH
49321: LD_VAR 0 2
49325: PPUSH
49326: CALL_OW 250
49330: ST_TO_ADDR
// y := GetY ( building ) ;
49331: LD_ADDR_VAR 0 6
49335: PUSH
49336: LD_VAR 0 2
49340: PPUSH
49341: CALL_OW 251
49345: ST_TO_ADDR
// d := GetDir ( building ) ;
49346: LD_ADDR_VAR 0 8
49350: PUSH
49351: LD_VAR 0 2
49355: PPUSH
49356: CALL_OW 254
49360: ST_TO_ADDR
// r := 4 ;
49361: LD_ADDR_VAR 0 9
49365: PUSH
49366: LD_INT 4
49368: ST_TO_ADDR
// for i := 1 to 5 do
49369: LD_ADDR_VAR 0 10
49373: PUSH
49374: DOUBLE
49375: LD_INT 1
49377: DEC
49378: ST_TO_ADDR
49379: LD_INT 5
49381: PUSH
49382: FOR_TO
49383: IFFALSE 49540
// begin _x := ShiftX ( x , d , r + i ) ;
49385: LD_ADDR_VAR 0 5
49389: PUSH
49390: LD_VAR 0 4
49394: PPUSH
49395: LD_VAR 0 8
49399: PPUSH
49400: LD_VAR 0 9
49404: PUSH
49405: LD_VAR 0 10
49409: PLUS
49410: PPUSH
49411: CALL_OW 272
49415: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
49416: LD_ADDR_VAR 0 7
49420: PUSH
49421: LD_VAR 0 6
49425: PPUSH
49426: LD_VAR 0 8
49430: PPUSH
49431: LD_VAR 0 9
49435: PUSH
49436: LD_VAR 0 10
49440: PLUS
49441: PPUSH
49442: CALL_OW 273
49446: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
49447: LD_VAR 0 5
49451: PPUSH
49452: LD_VAR 0 7
49456: PPUSH
49457: CALL_OW 488
49461: PUSH
49462: LD_VAR 0 5
49466: PPUSH
49467: LD_VAR 0 7
49471: PPUSH
49472: CALL_OW 428
49476: PPUSH
49477: CALL_OW 247
49481: PUSH
49482: LD_INT 3
49484: PUSH
49485: LD_INT 2
49487: PUSH
49488: EMPTY
49489: LIST
49490: LIST
49491: IN
49492: NOT
49493: AND
49494: IFFALSE 49538
// begin ComMoveXY ( unit , _x , _y ) ;
49496: LD_VAR 0 1
49500: PPUSH
49501: LD_VAR 0 5
49505: PPUSH
49506: LD_VAR 0 7
49510: PPUSH
49511: CALL_OW 111
// result := [ _x , _y ] ;
49515: LD_ADDR_VAR 0 3
49519: PUSH
49520: LD_VAR 0 5
49524: PUSH
49525: LD_VAR 0 7
49529: PUSH
49530: EMPTY
49531: LIST
49532: LIST
49533: ST_TO_ADDR
// exit ;
49534: POP
49535: POP
49536: GO 49542
// end ; end ;
49538: GO 49382
49540: POP
49541: POP
// end ;
49542: LD_VAR 0 3
49546: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
49547: LD_INT 0
49549: PPUSH
49550: PPUSH
49551: PPUSH
// result := 0 ;
49552: LD_ADDR_VAR 0 3
49556: PUSH
49557: LD_INT 0
49559: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
49560: LD_VAR 0 1
49564: PUSH
49565: LD_INT 0
49567: LESS
49568: PUSH
49569: LD_VAR 0 1
49573: PUSH
49574: LD_INT 8
49576: GREATER
49577: OR
49578: PUSH
49579: LD_VAR 0 2
49583: PUSH
49584: LD_INT 0
49586: LESS
49587: OR
49588: PUSH
49589: LD_VAR 0 2
49593: PUSH
49594: LD_INT 8
49596: GREATER
49597: OR
49598: IFFALSE 49602
// exit ;
49600: GO 49677
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
49602: LD_ADDR_VAR 0 4
49606: PUSH
49607: LD_INT 22
49609: PUSH
49610: LD_VAR 0 2
49614: PUSH
49615: EMPTY
49616: LIST
49617: LIST
49618: PPUSH
49619: CALL_OW 69
49623: PUSH
49624: FOR_IN
49625: IFFALSE 49675
// begin un := UnitShoot ( i ) ;
49627: LD_ADDR_VAR 0 5
49631: PUSH
49632: LD_VAR 0 4
49636: PPUSH
49637: CALL_OW 504
49641: ST_TO_ADDR
// if GetSide ( un ) = side1 then
49642: LD_VAR 0 5
49646: PPUSH
49647: CALL_OW 255
49651: PUSH
49652: LD_VAR 0 1
49656: EQUAL
49657: IFFALSE 49673
// begin result := un ;
49659: LD_ADDR_VAR 0 3
49663: PUSH
49664: LD_VAR 0 5
49668: ST_TO_ADDR
// exit ;
49669: POP
49670: POP
49671: GO 49677
// end ; end ;
49673: GO 49624
49675: POP
49676: POP
// end ;
49677: LD_VAR 0 3
49681: RET
// export function GetCargoBay ( units ) ; begin
49682: LD_INT 0
49684: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
49685: LD_ADDR_VAR 0 2
49689: PUSH
49690: LD_VAR 0 1
49694: PPUSH
49695: LD_INT 2
49697: PUSH
49698: LD_INT 34
49700: PUSH
49701: LD_INT 12
49703: PUSH
49704: EMPTY
49705: LIST
49706: LIST
49707: PUSH
49708: LD_INT 34
49710: PUSH
49711: LD_INT 51
49713: PUSH
49714: EMPTY
49715: LIST
49716: LIST
49717: PUSH
49718: LD_INT 34
49720: PUSH
49721: LD_INT 32
49723: PUSH
49724: EMPTY
49725: LIST
49726: LIST
49727: PUSH
49728: LD_INT 34
49730: PUSH
49731: LD_INT 89
49733: PUSH
49734: EMPTY
49735: LIST
49736: LIST
49737: PUSH
49738: EMPTY
49739: LIST
49740: LIST
49741: LIST
49742: LIST
49743: LIST
49744: PPUSH
49745: CALL_OW 72
49749: ST_TO_ADDR
// end ;
49750: LD_VAR 0 2
49754: RET
// export function Negate ( value ) ; begin
49755: LD_INT 0
49757: PPUSH
// result := not value ;
49758: LD_ADDR_VAR 0 2
49762: PUSH
49763: LD_VAR 0 1
49767: NOT
49768: ST_TO_ADDR
// end ;
49769: LD_VAR 0 2
49773: RET
// export function Inc ( value ) ; begin
49774: LD_INT 0
49776: PPUSH
// result := value + 1 ;
49777: LD_ADDR_VAR 0 2
49781: PUSH
49782: LD_VAR 0 1
49786: PUSH
49787: LD_INT 1
49789: PLUS
49790: ST_TO_ADDR
// end ;
49791: LD_VAR 0 2
49795: RET
// export function Dec ( value ) ; begin
49796: LD_INT 0
49798: PPUSH
// result := value - 1 ;
49799: LD_ADDR_VAR 0 2
49803: PUSH
49804: LD_VAR 0 1
49808: PUSH
49809: LD_INT 1
49811: MINUS
49812: ST_TO_ADDR
// end ;
49813: LD_VAR 0 2
49817: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
49818: LD_INT 0
49820: PPUSH
49821: PPUSH
49822: PPUSH
49823: PPUSH
49824: PPUSH
49825: PPUSH
49826: PPUSH
49827: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
49828: LD_VAR 0 1
49832: PPUSH
49833: LD_VAR 0 2
49837: PPUSH
49838: CALL_OW 488
49842: NOT
49843: PUSH
49844: LD_VAR 0 3
49848: PPUSH
49849: LD_VAR 0 4
49853: PPUSH
49854: CALL_OW 488
49858: NOT
49859: OR
49860: IFFALSE 49873
// begin result := - 1 ;
49862: LD_ADDR_VAR 0 5
49866: PUSH
49867: LD_INT 1
49869: NEG
49870: ST_TO_ADDR
// exit ;
49871: GO 50108
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
49873: LD_ADDR_VAR 0 12
49877: PUSH
49878: LD_VAR 0 1
49882: PPUSH
49883: LD_VAR 0 2
49887: PPUSH
49888: LD_VAR 0 3
49892: PPUSH
49893: LD_VAR 0 4
49897: PPUSH
49898: CALL 48958 0 4
49902: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
49903: LD_ADDR_VAR 0 11
49907: PUSH
49908: LD_VAR 0 1
49912: PPUSH
49913: LD_VAR 0 2
49917: PPUSH
49918: LD_VAR 0 12
49922: PUSH
49923: LD_INT 1
49925: ARRAY
49926: PPUSH
49927: LD_VAR 0 12
49931: PUSH
49932: LD_INT 2
49934: ARRAY
49935: PPUSH
49936: CALL_OW 298
49940: ST_TO_ADDR
// distance := 9999 ;
49941: LD_ADDR_VAR 0 10
49945: PUSH
49946: LD_INT 9999
49948: ST_TO_ADDR
// for i := 0 to 5 do
49949: LD_ADDR_VAR 0 6
49953: PUSH
49954: DOUBLE
49955: LD_INT 0
49957: DEC
49958: ST_TO_ADDR
49959: LD_INT 5
49961: PUSH
49962: FOR_TO
49963: IFFALSE 50106
// begin _x := ShiftX ( x1 , i , centerDist ) ;
49965: LD_ADDR_VAR 0 7
49969: PUSH
49970: LD_VAR 0 1
49974: PPUSH
49975: LD_VAR 0 6
49979: PPUSH
49980: LD_VAR 0 11
49984: PPUSH
49985: CALL_OW 272
49989: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
49990: LD_ADDR_VAR 0 8
49994: PUSH
49995: LD_VAR 0 2
49999: PPUSH
50000: LD_VAR 0 6
50004: PPUSH
50005: LD_VAR 0 11
50009: PPUSH
50010: CALL_OW 273
50014: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50015: LD_VAR 0 7
50019: PPUSH
50020: LD_VAR 0 8
50024: PPUSH
50025: CALL_OW 488
50029: NOT
50030: IFFALSE 50034
// continue ;
50032: GO 49962
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
50034: LD_ADDR_VAR 0 9
50038: PUSH
50039: LD_VAR 0 12
50043: PUSH
50044: LD_INT 1
50046: ARRAY
50047: PPUSH
50048: LD_VAR 0 12
50052: PUSH
50053: LD_INT 2
50055: ARRAY
50056: PPUSH
50057: LD_VAR 0 7
50061: PPUSH
50062: LD_VAR 0 8
50066: PPUSH
50067: CALL_OW 298
50071: ST_TO_ADDR
// if tmp < distance then
50072: LD_VAR 0 9
50076: PUSH
50077: LD_VAR 0 10
50081: LESS
50082: IFFALSE 50104
// begin result := i ;
50084: LD_ADDR_VAR 0 5
50088: PUSH
50089: LD_VAR 0 6
50093: ST_TO_ADDR
// distance := tmp ;
50094: LD_ADDR_VAR 0 10
50098: PUSH
50099: LD_VAR 0 9
50103: ST_TO_ADDR
// end ; end ;
50104: GO 49962
50106: POP
50107: POP
// end ;
50108: LD_VAR 0 5
50112: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
50113: LD_INT 0
50115: PPUSH
50116: PPUSH
// if not driver or not IsInUnit ( driver ) then
50117: LD_VAR 0 1
50121: NOT
50122: PUSH
50123: LD_VAR 0 1
50127: PPUSH
50128: CALL_OW 310
50132: NOT
50133: OR
50134: IFFALSE 50138
// exit ;
50136: GO 50228
// vehicle := IsInUnit ( driver ) ;
50138: LD_ADDR_VAR 0 3
50142: PUSH
50143: LD_VAR 0 1
50147: PPUSH
50148: CALL_OW 310
50152: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
50153: LD_VAR 0 1
50157: PPUSH
50158: LD_STRING \
50160: PUSH
50161: LD_INT 0
50163: PUSH
50164: LD_INT 0
50166: PUSH
50167: LD_INT 0
50169: PUSH
50170: LD_INT 0
50172: PUSH
50173: LD_INT 0
50175: PUSH
50176: LD_INT 0
50178: PUSH
50179: EMPTY
50180: LIST
50181: LIST
50182: LIST
50183: LIST
50184: LIST
50185: LIST
50186: LIST
50187: PUSH
50188: LD_STRING E
50190: PUSH
50191: LD_INT 0
50193: PUSH
50194: LD_INT 0
50196: PUSH
50197: LD_VAR 0 3
50201: PUSH
50202: LD_INT 0
50204: PUSH
50205: LD_INT 0
50207: PUSH
50208: LD_INT 0
50210: PUSH
50211: EMPTY
50212: LIST
50213: LIST
50214: LIST
50215: LIST
50216: LIST
50217: LIST
50218: LIST
50219: PUSH
50220: EMPTY
50221: LIST
50222: LIST
50223: PPUSH
50224: CALL_OW 446
// end ;
50228: LD_VAR 0 2
50232: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
50233: LD_INT 0
50235: PPUSH
50236: PPUSH
// if not driver or not IsInUnit ( driver ) then
50237: LD_VAR 0 1
50241: NOT
50242: PUSH
50243: LD_VAR 0 1
50247: PPUSH
50248: CALL_OW 310
50252: NOT
50253: OR
50254: IFFALSE 50258
// exit ;
50256: GO 50348
// vehicle := IsInUnit ( driver ) ;
50258: LD_ADDR_VAR 0 3
50262: PUSH
50263: LD_VAR 0 1
50267: PPUSH
50268: CALL_OW 310
50272: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
50273: LD_VAR 0 1
50277: PPUSH
50278: LD_STRING \
50280: PUSH
50281: LD_INT 0
50283: PUSH
50284: LD_INT 0
50286: PUSH
50287: LD_INT 0
50289: PUSH
50290: LD_INT 0
50292: PUSH
50293: LD_INT 0
50295: PUSH
50296: LD_INT 0
50298: PUSH
50299: EMPTY
50300: LIST
50301: LIST
50302: LIST
50303: LIST
50304: LIST
50305: LIST
50306: LIST
50307: PUSH
50308: LD_STRING E
50310: PUSH
50311: LD_INT 0
50313: PUSH
50314: LD_INT 0
50316: PUSH
50317: LD_VAR 0 3
50321: PUSH
50322: LD_INT 0
50324: PUSH
50325: LD_INT 0
50327: PUSH
50328: LD_INT 0
50330: PUSH
50331: EMPTY
50332: LIST
50333: LIST
50334: LIST
50335: LIST
50336: LIST
50337: LIST
50338: LIST
50339: PUSH
50340: EMPTY
50341: LIST
50342: LIST
50343: PPUSH
50344: CALL_OW 447
// end ;
50348: LD_VAR 0 2
50352: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
50353: LD_INT 0
50355: PPUSH
50356: PPUSH
50357: PPUSH
// tmp := [ ] ;
50358: LD_ADDR_VAR 0 5
50362: PUSH
50363: EMPTY
50364: ST_TO_ADDR
// for i in units do
50365: LD_ADDR_VAR 0 4
50369: PUSH
50370: LD_VAR 0 1
50374: PUSH
50375: FOR_IN
50376: IFFALSE 50414
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
50378: LD_ADDR_VAR 0 5
50382: PUSH
50383: LD_VAR 0 5
50387: PPUSH
50388: LD_VAR 0 5
50392: PUSH
50393: LD_INT 1
50395: PLUS
50396: PPUSH
50397: LD_VAR 0 4
50401: PPUSH
50402: CALL_OW 256
50406: PPUSH
50407: CALL_OW 2
50411: ST_TO_ADDR
50412: GO 50375
50414: POP
50415: POP
// if not tmp then
50416: LD_VAR 0 5
50420: NOT
50421: IFFALSE 50425
// exit ;
50423: GO 50473
// if asc then
50425: LD_VAR 0 2
50429: IFFALSE 50453
// result := SortListByListAsc ( units , tmp ) else
50431: LD_ADDR_VAR 0 3
50435: PUSH
50436: LD_VAR 0 1
50440: PPUSH
50441: LD_VAR 0 5
50445: PPUSH
50446: CALL_OW 76
50450: ST_TO_ADDR
50451: GO 50473
// result := SortListByListDesc ( units , tmp ) ;
50453: LD_ADDR_VAR 0 3
50457: PUSH
50458: LD_VAR 0 1
50462: PPUSH
50463: LD_VAR 0 5
50467: PPUSH
50468: CALL_OW 77
50472: ST_TO_ADDR
// end ;
50473: LD_VAR 0 3
50477: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
50478: LD_INT 0
50480: PPUSH
50481: PPUSH
// task := GetTaskList ( mech ) ;
50482: LD_ADDR_VAR 0 4
50486: PUSH
50487: LD_VAR 0 1
50491: PPUSH
50492: CALL_OW 437
50496: ST_TO_ADDR
// if not task then
50497: LD_VAR 0 4
50501: NOT
50502: IFFALSE 50506
// exit ;
50504: GO 50548
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
50506: LD_ADDR_VAR 0 3
50510: PUSH
50511: LD_VAR 0 4
50515: PUSH
50516: LD_INT 1
50518: ARRAY
50519: PUSH
50520: LD_INT 1
50522: ARRAY
50523: PUSH
50524: LD_STRING r
50526: EQUAL
50527: PUSH
50528: LD_VAR 0 4
50532: PUSH
50533: LD_INT 1
50535: ARRAY
50536: PUSH
50537: LD_INT 4
50539: ARRAY
50540: PUSH
50541: LD_VAR 0 2
50545: EQUAL
50546: AND
50547: ST_TO_ADDR
// end ;
50548: LD_VAR 0 3
50552: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
50553: LD_INT 0
50555: PPUSH
// SetDir ( unit , d ) ;
50556: LD_VAR 0 1
50560: PPUSH
50561: LD_VAR 0 4
50565: PPUSH
50566: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
50570: LD_VAR 0 1
50574: PPUSH
50575: LD_VAR 0 2
50579: PPUSH
50580: LD_VAR 0 3
50584: PPUSH
50585: LD_VAR 0 5
50589: PPUSH
50590: CALL_OW 48
// end ;
50594: LD_VAR 0 6
50598: RET
// export function ToNaturalNumber ( number ) ; begin
50599: LD_INT 0
50601: PPUSH
// result := number div 1 ;
50602: LD_ADDR_VAR 0 2
50606: PUSH
50607: LD_VAR 0 1
50611: PUSH
50612: LD_INT 1
50614: DIV
50615: ST_TO_ADDR
// if number < 0 then
50616: LD_VAR 0 1
50620: PUSH
50621: LD_INT 0
50623: LESS
50624: IFFALSE 50634
// result := 0 ;
50626: LD_ADDR_VAR 0 2
50630: PUSH
50631: LD_INT 0
50633: ST_TO_ADDR
// end ;
50634: LD_VAR 0 2
50638: RET
// export function SortByClass ( units , class ) ; var un ; begin
50639: LD_INT 0
50641: PPUSH
50642: PPUSH
// if not units or not class then
50643: LD_VAR 0 1
50647: NOT
50648: PUSH
50649: LD_VAR 0 2
50653: NOT
50654: OR
50655: IFFALSE 50659
// exit ;
50657: GO 50754
// result := [ ] ;
50659: LD_ADDR_VAR 0 3
50663: PUSH
50664: EMPTY
50665: ST_TO_ADDR
// for un in units do
50666: LD_ADDR_VAR 0 4
50670: PUSH
50671: LD_VAR 0 1
50675: PUSH
50676: FOR_IN
50677: IFFALSE 50752
// if GetClass ( un ) = class then
50679: LD_VAR 0 4
50683: PPUSH
50684: CALL_OW 257
50688: PUSH
50689: LD_VAR 0 2
50693: EQUAL
50694: IFFALSE 50721
// result := Insert ( result , 1 , un ) else
50696: LD_ADDR_VAR 0 3
50700: PUSH
50701: LD_VAR 0 3
50705: PPUSH
50706: LD_INT 1
50708: PPUSH
50709: LD_VAR 0 4
50713: PPUSH
50714: CALL_OW 2
50718: ST_TO_ADDR
50719: GO 50750
// result := Replace ( result , result + 1 , un ) ;
50721: LD_ADDR_VAR 0 3
50725: PUSH
50726: LD_VAR 0 3
50730: PPUSH
50731: LD_VAR 0 3
50735: PUSH
50736: LD_INT 1
50738: PLUS
50739: PPUSH
50740: LD_VAR 0 4
50744: PPUSH
50745: CALL_OW 1
50749: ST_TO_ADDR
50750: GO 50676
50752: POP
50753: POP
// end ;
50754: LD_VAR 0 3
50758: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
50759: LD_INT 0
50761: PPUSH
50762: PPUSH
50763: PPUSH
50764: PPUSH
50765: PPUSH
50766: PPUSH
50767: PPUSH
// result := [ ] ;
50768: LD_ADDR_VAR 0 4
50772: PUSH
50773: EMPTY
50774: ST_TO_ADDR
// if x - r < 0 then
50775: LD_VAR 0 1
50779: PUSH
50780: LD_VAR 0 3
50784: MINUS
50785: PUSH
50786: LD_INT 0
50788: LESS
50789: IFFALSE 50801
// min_x := 0 else
50791: LD_ADDR_VAR 0 8
50795: PUSH
50796: LD_INT 0
50798: ST_TO_ADDR
50799: GO 50817
// min_x := x - r ;
50801: LD_ADDR_VAR 0 8
50805: PUSH
50806: LD_VAR 0 1
50810: PUSH
50811: LD_VAR 0 3
50815: MINUS
50816: ST_TO_ADDR
// if y - r < 0 then
50817: LD_VAR 0 2
50821: PUSH
50822: LD_VAR 0 3
50826: MINUS
50827: PUSH
50828: LD_INT 0
50830: LESS
50831: IFFALSE 50843
// min_y := 0 else
50833: LD_ADDR_VAR 0 7
50837: PUSH
50838: LD_INT 0
50840: ST_TO_ADDR
50841: GO 50859
// min_y := y - r ;
50843: LD_ADDR_VAR 0 7
50847: PUSH
50848: LD_VAR 0 2
50852: PUSH
50853: LD_VAR 0 3
50857: MINUS
50858: ST_TO_ADDR
// max_x := x + r ;
50859: LD_ADDR_VAR 0 9
50863: PUSH
50864: LD_VAR 0 1
50868: PUSH
50869: LD_VAR 0 3
50873: PLUS
50874: ST_TO_ADDR
// max_y := y + r ;
50875: LD_ADDR_VAR 0 10
50879: PUSH
50880: LD_VAR 0 2
50884: PUSH
50885: LD_VAR 0 3
50889: PLUS
50890: ST_TO_ADDR
// for _x = min_x to max_x do
50891: LD_ADDR_VAR 0 5
50895: PUSH
50896: DOUBLE
50897: LD_VAR 0 8
50901: DEC
50902: ST_TO_ADDR
50903: LD_VAR 0 9
50907: PUSH
50908: FOR_TO
50909: IFFALSE 51010
// for _y = min_y to max_y do
50911: LD_ADDR_VAR 0 6
50915: PUSH
50916: DOUBLE
50917: LD_VAR 0 7
50921: DEC
50922: ST_TO_ADDR
50923: LD_VAR 0 10
50927: PUSH
50928: FOR_TO
50929: IFFALSE 51006
// begin if not ValidHex ( _x , _y ) then
50931: LD_VAR 0 5
50935: PPUSH
50936: LD_VAR 0 6
50940: PPUSH
50941: CALL_OW 488
50945: NOT
50946: IFFALSE 50950
// continue ;
50948: GO 50928
// if GetResourceTypeXY ( _x , _y ) then
50950: LD_VAR 0 5
50954: PPUSH
50955: LD_VAR 0 6
50959: PPUSH
50960: CALL_OW 283
50964: IFFALSE 51004
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
50966: LD_ADDR_VAR 0 4
50970: PUSH
50971: LD_VAR 0 4
50975: PPUSH
50976: LD_VAR 0 4
50980: PUSH
50981: LD_INT 1
50983: PLUS
50984: PPUSH
50985: LD_VAR 0 5
50989: PUSH
50990: LD_VAR 0 6
50994: PUSH
50995: EMPTY
50996: LIST
50997: LIST
50998: PPUSH
50999: CALL_OW 1
51003: ST_TO_ADDR
// end ;
51004: GO 50928
51006: POP
51007: POP
51008: GO 50908
51010: POP
51011: POP
// end ;
51012: LD_VAR 0 4
51016: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
51017: LD_INT 0
51019: PPUSH
51020: PPUSH
51021: PPUSH
51022: PPUSH
51023: PPUSH
51024: PPUSH
51025: PPUSH
51026: PPUSH
// if not units then
51027: LD_VAR 0 1
51031: NOT
51032: IFFALSE 51036
// exit ;
51034: GO 51560
// result := UnitFilter ( units , [ f_ok ] ) ;
51036: LD_ADDR_VAR 0 3
51040: PUSH
51041: LD_VAR 0 1
51045: PPUSH
51046: LD_INT 50
51048: PUSH
51049: EMPTY
51050: LIST
51051: PPUSH
51052: CALL_OW 72
51056: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
51057: LD_ADDR_VAR 0 8
51061: PUSH
51062: LD_VAR 0 1
51066: PUSH
51067: LD_INT 1
51069: ARRAY
51070: PPUSH
51071: CALL_OW 255
51075: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
51076: LD_ADDR_VAR 0 10
51080: PUSH
51081: LD_INT 29
51083: PUSH
51084: LD_INT 91
51086: PUSH
51087: LD_INT 49
51089: PUSH
51090: EMPTY
51091: LIST
51092: LIST
51093: LIST
51094: ST_TO_ADDR
// if not result then
51095: LD_VAR 0 3
51099: NOT
51100: IFFALSE 51104
// exit ;
51102: GO 51560
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
51104: LD_ADDR_VAR 0 5
51108: PUSH
51109: LD_INT 81
51111: PUSH
51112: LD_VAR 0 8
51116: PUSH
51117: EMPTY
51118: LIST
51119: LIST
51120: PPUSH
51121: CALL_OW 69
51125: ST_TO_ADDR
// for i in result do
51126: LD_ADDR_VAR 0 4
51130: PUSH
51131: LD_VAR 0 3
51135: PUSH
51136: FOR_IN
51137: IFFALSE 51558
// begin tag := GetTag ( i ) + 1 ;
51139: LD_ADDR_VAR 0 9
51143: PUSH
51144: LD_VAR 0 4
51148: PPUSH
51149: CALL_OW 110
51153: PUSH
51154: LD_INT 1
51156: PLUS
51157: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
51158: LD_ADDR_VAR 0 7
51162: PUSH
51163: LD_VAR 0 4
51167: PPUSH
51168: CALL_OW 250
51172: PPUSH
51173: LD_VAR 0 4
51177: PPUSH
51178: CALL_OW 251
51182: PPUSH
51183: LD_INT 6
51185: PPUSH
51186: CALL 50759 0 3
51190: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
51191: LD_VAR 0 4
51195: PPUSH
51196: CALL_OW 247
51200: PUSH
51201: LD_INT 2
51203: EQUAL
51204: PUSH
51205: LD_VAR 0 7
51209: AND
51210: PUSH
51211: LD_VAR 0 4
51215: PPUSH
51216: CALL_OW 264
51220: PUSH
51221: LD_VAR 0 10
51225: IN
51226: NOT
51227: AND
51228: IFFALSE 51267
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
51230: LD_VAR 0 4
51234: PPUSH
51235: LD_VAR 0 7
51239: PUSH
51240: LD_INT 1
51242: ARRAY
51243: PUSH
51244: LD_INT 1
51246: ARRAY
51247: PPUSH
51248: LD_VAR 0 7
51252: PUSH
51253: LD_INT 1
51255: ARRAY
51256: PUSH
51257: LD_INT 2
51259: ARRAY
51260: PPUSH
51261: CALL_OW 116
51265: GO 51556
// if path > tag then
51267: LD_VAR 0 2
51271: PUSH
51272: LD_VAR 0 9
51276: GREATER
51277: IFFALSE 51485
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
51279: LD_ADDR_VAR 0 6
51283: PUSH
51284: LD_VAR 0 5
51288: PPUSH
51289: LD_INT 91
51291: PUSH
51292: LD_VAR 0 4
51296: PUSH
51297: LD_INT 8
51299: PUSH
51300: EMPTY
51301: LIST
51302: LIST
51303: LIST
51304: PPUSH
51305: CALL_OW 72
51309: ST_TO_ADDR
// if nearEnemy then
51310: LD_VAR 0 6
51314: IFFALSE 51383
// begin if GetWeapon ( i ) = ru_time_lapser then
51316: LD_VAR 0 4
51320: PPUSH
51321: CALL_OW 264
51325: PUSH
51326: LD_INT 49
51328: EQUAL
51329: IFFALSE 51357
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
51331: LD_VAR 0 4
51335: PPUSH
51336: LD_VAR 0 6
51340: PPUSH
51341: LD_VAR 0 4
51345: PPUSH
51346: CALL_OW 74
51350: PPUSH
51351: CALL_OW 112
51355: GO 51381
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
51357: LD_VAR 0 4
51361: PPUSH
51362: LD_VAR 0 6
51366: PPUSH
51367: LD_VAR 0 4
51371: PPUSH
51372: CALL_OW 74
51376: PPUSH
51377: CALL_OW 115
// end else
51381: GO 51483
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
51383: LD_VAR 0 4
51387: PPUSH
51388: LD_VAR 0 2
51392: PUSH
51393: LD_VAR 0 9
51397: ARRAY
51398: PUSH
51399: LD_INT 1
51401: ARRAY
51402: PPUSH
51403: LD_VAR 0 2
51407: PUSH
51408: LD_VAR 0 9
51412: ARRAY
51413: PUSH
51414: LD_INT 2
51416: ARRAY
51417: PPUSH
51418: CALL_OW 297
51422: PUSH
51423: LD_INT 6
51425: GREATER
51426: IFFALSE 51469
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
51428: LD_VAR 0 4
51432: PPUSH
51433: LD_VAR 0 2
51437: PUSH
51438: LD_VAR 0 9
51442: ARRAY
51443: PUSH
51444: LD_INT 1
51446: ARRAY
51447: PPUSH
51448: LD_VAR 0 2
51452: PUSH
51453: LD_VAR 0 9
51457: ARRAY
51458: PUSH
51459: LD_INT 2
51461: ARRAY
51462: PPUSH
51463: CALL_OW 114
51467: GO 51483
// SetTag ( i , tag ) ;
51469: LD_VAR 0 4
51473: PPUSH
51474: LD_VAR 0 9
51478: PPUSH
51479: CALL_OW 109
// end else
51483: GO 51556
// if enemy then
51485: LD_VAR 0 5
51489: IFFALSE 51556
// begin if GetWeapon ( i ) = ru_time_lapser then
51491: LD_VAR 0 4
51495: PPUSH
51496: CALL_OW 264
51500: PUSH
51501: LD_INT 49
51503: EQUAL
51504: IFFALSE 51532
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
51506: LD_VAR 0 4
51510: PPUSH
51511: LD_VAR 0 5
51515: PPUSH
51516: LD_VAR 0 4
51520: PPUSH
51521: CALL_OW 74
51525: PPUSH
51526: CALL_OW 112
51530: GO 51556
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
51532: LD_VAR 0 4
51536: PPUSH
51537: LD_VAR 0 5
51541: PPUSH
51542: LD_VAR 0 4
51546: PPUSH
51547: CALL_OW 74
51551: PPUSH
51552: CALL_OW 115
// end ; end ;
51556: GO 51136
51558: POP
51559: POP
// end ;
51560: LD_VAR 0 3
51564: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
51565: LD_INT 0
51567: PPUSH
51568: PPUSH
51569: PPUSH
// if not unit or IsInUnit ( unit ) then
51570: LD_VAR 0 1
51574: NOT
51575: PUSH
51576: LD_VAR 0 1
51580: PPUSH
51581: CALL_OW 310
51585: OR
51586: IFFALSE 51590
// exit ;
51588: GO 51681
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
51590: LD_ADDR_VAR 0 4
51594: PUSH
51595: LD_VAR 0 1
51599: PPUSH
51600: CALL_OW 250
51604: PPUSH
51605: LD_VAR 0 2
51609: PPUSH
51610: LD_INT 1
51612: PPUSH
51613: CALL_OW 272
51617: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
51618: LD_ADDR_VAR 0 5
51622: PUSH
51623: LD_VAR 0 1
51627: PPUSH
51628: CALL_OW 251
51632: PPUSH
51633: LD_VAR 0 2
51637: PPUSH
51638: LD_INT 1
51640: PPUSH
51641: CALL_OW 273
51645: ST_TO_ADDR
// if ValidHex ( x , y ) then
51646: LD_VAR 0 4
51650: PPUSH
51651: LD_VAR 0 5
51655: PPUSH
51656: CALL_OW 488
51660: IFFALSE 51681
// ComTurnXY ( unit , x , y ) ;
51662: LD_VAR 0 1
51666: PPUSH
51667: LD_VAR 0 4
51671: PPUSH
51672: LD_VAR 0 5
51676: PPUSH
51677: CALL_OW 118
// end ;
51681: LD_VAR 0 3
51685: RET
// export function SeeUnits ( side , units ) ; var i ; begin
51686: LD_INT 0
51688: PPUSH
51689: PPUSH
// result := false ;
51690: LD_ADDR_VAR 0 3
51694: PUSH
51695: LD_INT 0
51697: ST_TO_ADDR
// if not units then
51698: LD_VAR 0 2
51702: NOT
51703: IFFALSE 51707
// exit ;
51705: GO 51752
// for i in units do
51707: LD_ADDR_VAR 0 4
51711: PUSH
51712: LD_VAR 0 2
51716: PUSH
51717: FOR_IN
51718: IFFALSE 51750
// if See ( side , i ) then
51720: LD_VAR 0 1
51724: PPUSH
51725: LD_VAR 0 4
51729: PPUSH
51730: CALL_OW 292
51734: IFFALSE 51748
// begin result := true ;
51736: LD_ADDR_VAR 0 3
51740: PUSH
51741: LD_INT 1
51743: ST_TO_ADDR
// exit ;
51744: POP
51745: POP
51746: GO 51752
// end ;
51748: GO 51717
51750: POP
51751: POP
// end ;
51752: LD_VAR 0 3
51756: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
51757: LD_INT 0
51759: PPUSH
51760: PPUSH
51761: PPUSH
51762: PPUSH
// if not unit or not points then
51763: LD_VAR 0 1
51767: NOT
51768: PUSH
51769: LD_VAR 0 2
51773: NOT
51774: OR
51775: IFFALSE 51779
// exit ;
51777: GO 51869
// dist := 99999 ;
51779: LD_ADDR_VAR 0 5
51783: PUSH
51784: LD_INT 99999
51786: ST_TO_ADDR
// for i in points do
51787: LD_ADDR_VAR 0 4
51791: PUSH
51792: LD_VAR 0 2
51796: PUSH
51797: FOR_IN
51798: IFFALSE 51867
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
51800: LD_ADDR_VAR 0 6
51804: PUSH
51805: LD_VAR 0 1
51809: PPUSH
51810: LD_VAR 0 4
51814: PUSH
51815: LD_INT 1
51817: ARRAY
51818: PPUSH
51819: LD_VAR 0 4
51823: PUSH
51824: LD_INT 2
51826: ARRAY
51827: PPUSH
51828: CALL_OW 297
51832: ST_TO_ADDR
// if tmpDist < dist then
51833: LD_VAR 0 6
51837: PUSH
51838: LD_VAR 0 5
51842: LESS
51843: IFFALSE 51865
// begin result := i ;
51845: LD_ADDR_VAR 0 3
51849: PUSH
51850: LD_VAR 0 4
51854: ST_TO_ADDR
// dist := tmpDist ;
51855: LD_ADDR_VAR 0 5
51859: PUSH
51860: LD_VAR 0 6
51864: ST_TO_ADDR
// end ; end ;
51865: GO 51797
51867: POP
51868: POP
// end ;
51869: LD_VAR 0 3
51873: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
51874: LD_INT 0
51876: PPUSH
// uc_side := side ;
51877: LD_ADDR_OWVAR 20
51881: PUSH
51882: LD_VAR 0 1
51886: ST_TO_ADDR
// uc_nation := 3 ;
51887: LD_ADDR_OWVAR 21
51891: PUSH
51892: LD_INT 3
51894: ST_TO_ADDR
// vc_chassis := 25 ;
51895: LD_ADDR_OWVAR 37
51899: PUSH
51900: LD_INT 25
51902: ST_TO_ADDR
// vc_engine := engine_siberite ;
51903: LD_ADDR_OWVAR 39
51907: PUSH
51908: LD_INT 3
51910: ST_TO_ADDR
// vc_control := control_computer ;
51911: LD_ADDR_OWVAR 38
51915: PUSH
51916: LD_INT 3
51918: ST_TO_ADDR
// vc_weapon := 59 ;
51919: LD_ADDR_OWVAR 40
51923: PUSH
51924: LD_INT 59
51926: ST_TO_ADDR
// result := CreateVehicle ;
51927: LD_ADDR_VAR 0 5
51931: PUSH
51932: CALL_OW 45
51936: ST_TO_ADDR
// SetDir ( result , d ) ;
51937: LD_VAR 0 5
51941: PPUSH
51942: LD_VAR 0 4
51946: PPUSH
51947: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
51951: LD_VAR 0 5
51955: PPUSH
51956: LD_VAR 0 2
51960: PPUSH
51961: LD_VAR 0 3
51965: PPUSH
51966: LD_INT 0
51968: PPUSH
51969: CALL_OW 48
// end ;
51973: LD_VAR 0 5
51977: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
51978: LD_INT 0
51980: PPUSH
51981: PPUSH
51982: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
51983: LD_ADDR_VAR 0 2
51987: PUSH
51988: LD_INT 0
51990: PUSH
51991: LD_INT 0
51993: PUSH
51994: LD_INT 0
51996: PUSH
51997: LD_INT 0
51999: PUSH
52000: EMPTY
52001: LIST
52002: LIST
52003: LIST
52004: LIST
52005: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
52006: LD_VAR 0 1
52010: NOT
52011: PUSH
52012: LD_VAR 0 1
52016: PPUSH
52017: CALL_OW 264
52021: PUSH
52022: LD_INT 12
52024: PUSH
52025: LD_INT 51
52027: PUSH
52028: LD_INT 32
52030: PUSH
52031: LD_INT 89
52033: PUSH
52034: EMPTY
52035: LIST
52036: LIST
52037: LIST
52038: LIST
52039: IN
52040: NOT
52041: OR
52042: IFFALSE 52046
// exit ;
52044: GO 52144
// for i := 1 to 3 do
52046: LD_ADDR_VAR 0 3
52050: PUSH
52051: DOUBLE
52052: LD_INT 1
52054: DEC
52055: ST_TO_ADDR
52056: LD_INT 3
52058: PUSH
52059: FOR_TO
52060: IFFALSE 52142
// begin tmp := GetCargo ( cargo , i ) ;
52062: LD_ADDR_VAR 0 4
52066: PUSH
52067: LD_VAR 0 1
52071: PPUSH
52072: LD_VAR 0 3
52076: PPUSH
52077: CALL_OW 289
52081: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
52082: LD_ADDR_VAR 0 2
52086: PUSH
52087: LD_VAR 0 2
52091: PPUSH
52092: LD_VAR 0 3
52096: PPUSH
52097: LD_VAR 0 4
52101: PPUSH
52102: CALL_OW 1
52106: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
52107: LD_ADDR_VAR 0 2
52111: PUSH
52112: LD_VAR 0 2
52116: PPUSH
52117: LD_INT 4
52119: PPUSH
52120: LD_VAR 0 2
52124: PUSH
52125: LD_INT 4
52127: ARRAY
52128: PUSH
52129: LD_VAR 0 4
52133: PLUS
52134: PPUSH
52135: CALL_OW 1
52139: ST_TO_ADDR
// end ;
52140: GO 52059
52142: POP
52143: POP
// end ;
52144: LD_VAR 0 2
52148: RET
// export function Length ( array ) ; begin
52149: LD_INT 0
52151: PPUSH
// result := array + 0 ;
52152: LD_ADDR_VAR 0 2
52156: PUSH
52157: LD_VAR 0 1
52161: PUSH
52162: LD_INT 0
52164: PLUS
52165: ST_TO_ADDR
// end ;
52166: LD_VAR 0 2
52170: RET
// export function PrepareArray ( array ) ; begin
52171: LD_INT 0
52173: PPUSH
// result := array diff 0 ;
52174: LD_ADDR_VAR 0 2
52178: PUSH
52179: LD_VAR 0 1
52183: PUSH
52184: LD_INT 0
52186: DIFF
52187: ST_TO_ADDR
// if not result [ 1 ] then
52188: LD_VAR 0 2
52192: PUSH
52193: LD_INT 1
52195: ARRAY
52196: NOT
52197: IFFALSE 52217
// result := Delete ( result , 1 ) ;
52199: LD_ADDR_VAR 0 2
52203: PUSH
52204: LD_VAR 0 2
52208: PPUSH
52209: LD_INT 1
52211: PPUSH
52212: CALL_OW 3
52216: ST_TO_ADDR
// end ;
52217: LD_VAR 0 2
52221: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
52222: LD_INT 0
52224: PPUSH
52225: PPUSH
52226: PPUSH
52227: PPUSH
// sibRocketRange := 25 ;
52228: LD_ADDR_VAR 0 6
52232: PUSH
52233: LD_INT 25
52235: ST_TO_ADDR
// result := false ;
52236: LD_ADDR_VAR 0 4
52240: PUSH
52241: LD_INT 0
52243: ST_TO_ADDR
// for i := 0 to 5 do
52244: LD_ADDR_VAR 0 5
52248: PUSH
52249: DOUBLE
52250: LD_INT 0
52252: DEC
52253: ST_TO_ADDR
52254: LD_INT 5
52256: PUSH
52257: FOR_TO
52258: IFFALSE 52325
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
52260: LD_VAR 0 1
52264: PPUSH
52265: LD_VAR 0 5
52269: PPUSH
52270: LD_VAR 0 6
52274: PPUSH
52275: CALL_OW 272
52279: PPUSH
52280: LD_VAR 0 2
52284: PPUSH
52285: LD_VAR 0 5
52289: PPUSH
52290: LD_VAR 0 6
52294: PPUSH
52295: CALL_OW 273
52299: PPUSH
52300: LD_VAR 0 3
52304: PPUSH
52305: CALL_OW 309
52309: IFFALSE 52323
// begin result := true ;
52311: LD_ADDR_VAR 0 4
52315: PUSH
52316: LD_INT 1
52318: ST_TO_ADDR
// exit ;
52319: POP
52320: POP
52321: GO 52327
// end ;
52323: GO 52257
52325: POP
52326: POP
// end ;
52327: LD_VAR 0 4
52331: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
52332: LD_INT 0
52334: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
52335: LD_VAR 0 1
52339: PPUSH
52340: LD_VAR 0 2
52344: PPUSH
52345: LD_INT 0
52347: PPUSH
52348: LD_INT 0
52350: PPUSH
52351: LD_INT 1
52353: PPUSH
52354: LD_INT 0
52356: PPUSH
52357: CALL_OW 587
// end ; end_of_file
52361: LD_VAR 0 3
52365: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
52366: LD_INT 0
52368: PPUSH
52369: PPUSH
// skirmish := false ;
52370: LD_ADDR_EXP 21
52374: PUSH
52375: LD_INT 0
52377: ST_TO_ADDR
// debug_mc := false ;
52378: LD_ADDR_EXP 22
52382: PUSH
52383: LD_INT 0
52385: ST_TO_ADDR
// mc_bases := [ ] ;
52386: LD_ADDR_EXP 23
52390: PUSH
52391: EMPTY
52392: ST_TO_ADDR
// mc_sides := [ ] ;
52393: LD_ADDR_EXP 49
52397: PUSH
52398: EMPTY
52399: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
52400: LD_ADDR_EXP 24
52404: PUSH
52405: EMPTY
52406: ST_TO_ADDR
// mc_building_repairs := [ ] ;
52407: LD_ADDR_EXP 25
52411: PUSH
52412: EMPTY
52413: ST_TO_ADDR
// mc_need_heal := [ ] ;
52414: LD_ADDR_EXP 26
52418: PUSH
52419: EMPTY
52420: ST_TO_ADDR
// mc_healers := [ ] ;
52421: LD_ADDR_EXP 27
52425: PUSH
52426: EMPTY
52427: ST_TO_ADDR
// mc_build_list := [ ] ;
52428: LD_ADDR_EXP 28
52432: PUSH
52433: EMPTY
52434: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
52435: LD_ADDR_EXP 55
52439: PUSH
52440: EMPTY
52441: ST_TO_ADDR
// mc_builders := [ ] ;
52442: LD_ADDR_EXP 29
52446: PUSH
52447: EMPTY
52448: ST_TO_ADDR
// mc_construct_list := [ ] ;
52449: LD_ADDR_EXP 30
52453: PUSH
52454: EMPTY
52455: ST_TO_ADDR
// mc_turret_list := [ ] ;
52456: LD_ADDR_EXP 31
52460: PUSH
52461: EMPTY
52462: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
52463: LD_ADDR_EXP 32
52467: PUSH
52468: EMPTY
52469: ST_TO_ADDR
// mc_miners := [ ] ;
52470: LD_ADDR_EXP 37
52474: PUSH
52475: EMPTY
52476: ST_TO_ADDR
// mc_mines := [ ] ;
52477: LD_ADDR_EXP 36
52481: PUSH
52482: EMPTY
52483: ST_TO_ADDR
// mc_minefields := [ ] ;
52484: LD_ADDR_EXP 38
52488: PUSH
52489: EMPTY
52490: ST_TO_ADDR
// mc_crates := [ ] ;
52491: LD_ADDR_EXP 39
52495: PUSH
52496: EMPTY
52497: ST_TO_ADDR
// mc_crates_collector := [ ] ;
52498: LD_ADDR_EXP 40
52502: PUSH
52503: EMPTY
52504: ST_TO_ADDR
// mc_crates_area := [ ] ;
52505: LD_ADDR_EXP 41
52509: PUSH
52510: EMPTY
52511: ST_TO_ADDR
// mc_vehicles := [ ] ;
52512: LD_ADDR_EXP 42
52516: PUSH
52517: EMPTY
52518: ST_TO_ADDR
// mc_attack := [ ] ;
52519: LD_ADDR_EXP 43
52523: PUSH
52524: EMPTY
52525: ST_TO_ADDR
// mc_produce := [ ] ;
52526: LD_ADDR_EXP 44
52530: PUSH
52531: EMPTY
52532: ST_TO_ADDR
// mc_defender := [ ] ;
52533: LD_ADDR_EXP 45
52537: PUSH
52538: EMPTY
52539: ST_TO_ADDR
// mc_parking := [ ] ;
52540: LD_ADDR_EXP 47
52544: PUSH
52545: EMPTY
52546: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
52547: LD_ADDR_EXP 33
52551: PUSH
52552: EMPTY
52553: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
52554: LD_ADDR_EXP 35
52558: PUSH
52559: EMPTY
52560: ST_TO_ADDR
// mc_scan := [ ] ;
52561: LD_ADDR_EXP 46
52565: PUSH
52566: EMPTY
52567: ST_TO_ADDR
// mc_scan_area := [ ] ;
52568: LD_ADDR_EXP 48
52572: PUSH
52573: EMPTY
52574: ST_TO_ADDR
// mc_tech := [ ] ;
52575: LD_ADDR_EXP 50
52579: PUSH
52580: EMPTY
52581: ST_TO_ADDR
// mc_class := [ ] ;
52582: LD_ADDR_EXP 64
52586: PUSH
52587: EMPTY
52588: ST_TO_ADDR
// mc_class_case_use := [ ] ;
52589: LD_ADDR_EXP 65
52593: PUSH
52594: EMPTY
52595: ST_TO_ADDR
// mc_is_defending := [ ] ;
52596: LD_ADDR_EXP 66
52600: PUSH
52601: EMPTY
52602: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
52603: LD_ADDR_EXP 57
52607: PUSH
52608: EMPTY
52609: ST_TO_ADDR
// end ;
52610: LD_VAR 0 1
52614: RET
// export function MC_Kill ( base ) ; begin
52615: LD_INT 0
52617: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
52618: LD_ADDR_EXP 23
52622: PUSH
52623: LD_EXP 23
52627: PPUSH
52628: LD_VAR 0 1
52632: PPUSH
52633: EMPTY
52634: PPUSH
52635: CALL_OW 1
52639: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
52640: LD_ADDR_EXP 24
52644: PUSH
52645: LD_EXP 24
52649: PPUSH
52650: LD_VAR 0 1
52654: PPUSH
52655: EMPTY
52656: PPUSH
52657: CALL_OW 1
52661: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
52662: LD_ADDR_EXP 25
52666: PUSH
52667: LD_EXP 25
52671: PPUSH
52672: LD_VAR 0 1
52676: PPUSH
52677: EMPTY
52678: PPUSH
52679: CALL_OW 1
52683: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
52684: LD_ADDR_EXP 26
52688: PUSH
52689: LD_EXP 26
52693: PPUSH
52694: LD_VAR 0 1
52698: PPUSH
52699: EMPTY
52700: PPUSH
52701: CALL_OW 1
52705: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
52706: LD_ADDR_EXP 27
52710: PUSH
52711: LD_EXP 27
52715: PPUSH
52716: LD_VAR 0 1
52720: PPUSH
52721: EMPTY
52722: PPUSH
52723: CALL_OW 1
52727: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
52728: LD_ADDR_EXP 28
52732: PUSH
52733: LD_EXP 28
52737: PPUSH
52738: LD_VAR 0 1
52742: PPUSH
52743: EMPTY
52744: PPUSH
52745: CALL_OW 1
52749: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
52750: LD_ADDR_EXP 29
52754: PUSH
52755: LD_EXP 29
52759: PPUSH
52760: LD_VAR 0 1
52764: PPUSH
52765: EMPTY
52766: PPUSH
52767: CALL_OW 1
52771: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
52772: LD_ADDR_EXP 30
52776: PUSH
52777: LD_EXP 30
52781: PPUSH
52782: LD_VAR 0 1
52786: PPUSH
52787: EMPTY
52788: PPUSH
52789: CALL_OW 1
52793: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
52794: LD_ADDR_EXP 31
52798: PUSH
52799: LD_EXP 31
52803: PPUSH
52804: LD_VAR 0 1
52808: PPUSH
52809: EMPTY
52810: PPUSH
52811: CALL_OW 1
52815: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
52816: LD_ADDR_EXP 32
52820: PUSH
52821: LD_EXP 32
52825: PPUSH
52826: LD_VAR 0 1
52830: PPUSH
52831: EMPTY
52832: PPUSH
52833: CALL_OW 1
52837: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
52838: LD_ADDR_EXP 33
52842: PUSH
52843: LD_EXP 33
52847: PPUSH
52848: LD_VAR 0 1
52852: PPUSH
52853: EMPTY
52854: PPUSH
52855: CALL_OW 1
52859: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
52860: LD_ADDR_EXP 34
52864: PUSH
52865: LD_EXP 34
52869: PPUSH
52870: LD_VAR 0 1
52874: PPUSH
52875: LD_INT 0
52877: PPUSH
52878: CALL_OW 1
52882: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
52883: LD_ADDR_EXP 35
52887: PUSH
52888: LD_EXP 35
52892: PPUSH
52893: LD_VAR 0 1
52897: PPUSH
52898: EMPTY
52899: PPUSH
52900: CALL_OW 1
52904: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
52905: LD_ADDR_EXP 36
52909: PUSH
52910: LD_EXP 36
52914: PPUSH
52915: LD_VAR 0 1
52919: PPUSH
52920: EMPTY
52921: PPUSH
52922: CALL_OW 1
52926: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
52927: LD_ADDR_EXP 37
52931: PUSH
52932: LD_EXP 37
52936: PPUSH
52937: LD_VAR 0 1
52941: PPUSH
52942: EMPTY
52943: PPUSH
52944: CALL_OW 1
52948: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
52949: LD_ADDR_EXP 38
52953: PUSH
52954: LD_EXP 38
52958: PPUSH
52959: LD_VAR 0 1
52963: PPUSH
52964: EMPTY
52965: PPUSH
52966: CALL_OW 1
52970: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
52971: LD_ADDR_EXP 39
52975: PUSH
52976: LD_EXP 39
52980: PPUSH
52981: LD_VAR 0 1
52985: PPUSH
52986: EMPTY
52987: PPUSH
52988: CALL_OW 1
52992: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
52993: LD_ADDR_EXP 40
52997: PUSH
52998: LD_EXP 40
53002: PPUSH
53003: LD_VAR 0 1
53007: PPUSH
53008: EMPTY
53009: PPUSH
53010: CALL_OW 1
53014: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
53015: LD_ADDR_EXP 41
53019: PUSH
53020: LD_EXP 41
53024: PPUSH
53025: LD_VAR 0 1
53029: PPUSH
53030: EMPTY
53031: PPUSH
53032: CALL_OW 1
53036: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
53037: LD_ADDR_EXP 42
53041: PUSH
53042: LD_EXP 42
53046: PPUSH
53047: LD_VAR 0 1
53051: PPUSH
53052: EMPTY
53053: PPUSH
53054: CALL_OW 1
53058: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
53059: LD_ADDR_EXP 43
53063: PUSH
53064: LD_EXP 43
53068: PPUSH
53069: LD_VAR 0 1
53073: PPUSH
53074: EMPTY
53075: PPUSH
53076: CALL_OW 1
53080: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
53081: LD_ADDR_EXP 44
53085: PUSH
53086: LD_EXP 44
53090: PPUSH
53091: LD_VAR 0 1
53095: PPUSH
53096: EMPTY
53097: PPUSH
53098: CALL_OW 1
53102: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
53103: LD_ADDR_EXP 45
53107: PUSH
53108: LD_EXP 45
53112: PPUSH
53113: LD_VAR 0 1
53117: PPUSH
53118: EMPTY
53119: PPUSH
53120: CALL_OW 1
53124: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
53125: LD_ADDR_EXP 46
53129: PUSH
53130: LD_EXP 46
53134: PPUSH
53135: LD_VAR 0 1
53139: PPUSH
53140: EMPTY
53141: PPUSH
53142: CALL_OW 1
53146: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
53147: LD_ADDR_EXP 47
53151: PUSH
53152: LD_EXP 47
53156: PPUSH
53157: LD_VAR 0 1
53161: PPUSH
53162: EMPTY
53163: PPUSH
53164: CALL_OW 1
53168: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
53169: LD_ADDR_EXP 48
53173: PUSH
53174: LD_EXP 48
53178: PPUSH
53179: LD_VAR 0 1
53183: PPUSH
53184: EMPTY
53185: PPUSH
53186: CALL_OW 1
53190: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
53191: LD_ADDR_EXP 50
53195: PUSH
53196: LD_EXP 50
53200: PPUSH
53201: LD_VAR 0 1
53205: PPUSH
53206: EMPTY
53207: PPUSH
53208: CALL_OW 1
53212: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
53213: LD_ADDR_EXP 52
53217: PUSH
53218: LD_EXP 52
53222: PPUSH
53223: LD_VAR 0 1
53227: PPUSH
53228: EMPTY
53229: PPUSH
53230: CALL_OW 1
53234: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
53235: LD_ADDR_EXP 53
53239: PUSH
53240: LD_EXP 53
53244: PPUSH
53245: LD_VAR 0 1
53249: PPUSH
53250: EMPTY
53251: PPUSH
53252: CALL_OW 1
53256: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
53257: LD_ADDR_EXP 54
53261: PUSH
53262: LD_EXP 54
53266: PPUSH
53267: LD_VAR 0 1
53271: PPUSH
53272: EMPTY
53273: PPUSH
53274: CALL_OW 1
53278: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
53279: LD_ADDR_EXP 55
53283: PUSH
53284: LD_EXP 55
53288: PPUSH
53289: LD_VAR 0 1
53293: PPUSH
53294: EMPTY
53295: PPUSH
53296: CALL_OW 1
53300: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
53301: LD_ADDR_EXP 56
53305: PUSH
53306: LD_EXP 56
53310: PPUSH
53311: LD_VAR 0 1
53315: PPUSH
53316: EMPTY
53317: PPUSH
53318: CALL_OW 1
53322: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
53323: LD_ADDR_EXP 57
53327: PUSH
53328: LD_EXP 57
53332: PPUSH
53333: LD_VAR 0 1
53337: PPUSH
53338: EMPTY
53339: PPUSH
53340: CALL_OW 1
53344: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
53345: LD_ADDR_EXP 58
53349: PUSH
53350: LD_EXP 58
53354: PPUSH
53355: LD_VAR 0 1
53359: PPUSH
53360: EMPTY
53361: PPUSH
53362: CALL_OW 1
53366: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
53367: LD_ADDR_EXP 59
53371: PUSH
53372: LD_EXP 59
53376: PPUSH
53377: LD_VAR 0 1
53381: PPUSH
53382: EMPTY
53383: PPUSH
53384: CALL_OW 1
53388: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
53389: LD_ADDR_EXP 60
53393: PUSH
53394: LD_EXP 60
53398: PPUSH
53399: LD_VAR 0 1
53403: PPUSH
53404: EMPTY
53405: PPUSH
53406: CALL_OW 1
53410: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
53411: LD_ADDR_EXP 61
53415: PUSH
53416: LD_EXP 61
53420: PPUSH
53421: LD_VAR 0 1
53425: PPUSH
53426: EMPTY
53427: PPUSH
53428: CALL_OW 1
53432: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
53433: LD_ADDR_EXP 62
53437: PUSH
53438: LD_EXP 62
53442: PPUSH
53443: LD_VAR 0 1
53447: PPUSH
53448: EMPTY
53449: PPUSH
53450: CALL_OW 1
53454: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
53455: LD_ADDR_EXP 63
53459: PUSH
53460: LD_EXP 63
53464: PPUSH
53465: LD_VAR 0 1
53469: PPUSH
53470: EMPTY
53471: PPUSH
53472: CALL_OW 1
53476: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
53477: LD_ADDR_EXP 64
53481: PUSH
53482: LD_EXP 64
53486: PPUSH
53487: LD_VAR 0 1
53491: PPUSH
53492: EMPTY
53493: PPUSH
53494: CALL_OW 1
53498: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
53499: LD_ADDR_EXP 65
53503: PUSH
53504: LD_EXP 65
53508: PPUSH
53509: LD_VAR 0 1
53513: PPUSH
53514: LD_INT 0
53516: PPUSH
53517: CALL_OW 1
53521: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
53522: LD_ADDR_EXP 66
53526: PUSH
53527: LD_EXP 66
53531: PPUSH
53532: LD_VAR 0 1
53536: PPUSH
53537: LD_INT 0
53539: PPUSH
53540: CALL_OW 1
53544: ST_TO_ADDR
// end ;
53545: LD_VAR 0 2
53549: RET
// export function MC_Add ( side , units ) ; var base ; begin
53550: LD_INT 0
53552: PPUSH
53553: PPUSH
// base := mc_bases + 1 ;
53554: LD_ADDR_VAR 0 4
53558: PUSH
53559: LD_EXP 23
53563: PUSH
53564: LD_INT 1
53566: PLUS
53567: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
53568: LD_ADDR_EXP 49
53572: PUSH
53573: LD_EXP 49
53577: PPUSH
53578: LD_VAR 0 4
53582: PPUSH
53583: LD_VAR 0 1
53587: PPUSH
53588: CALL_OW 1
53592: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
53593: LD_ADDR_EXP 23
53597: PUSH
53598: LD_EXP 23
53602: PPUSH
53603: LD_VAR 0 4
53607: PPUSH
53608: LD_VAR 0 2
53612: PPUSH
53613: CALL_OW 1
53617: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
53618: LD_ADDR_EXP 24
53622: PUSH
53623: LD_EXP 24
53627: PPUSH
53628: LD_VAR 0 4
53632: PPUSH
53633: EMPTY
53634: PPUSH
53635: CALL_OW 1
53639: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
53640: LD_ADDR_EXP 25
53644: PUSH
53645: LD_EXP 25
53649: PPUSH
53650: LD_VAR 0 4
53654: PPUSH
53655: EMPTY
53656: PPUSH
53657: CALL_OW 1
53661: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
53662: LD_ADDR_EXP 26
53666: PUSH
53667: LD_EXP 26
53671: PPUSH
53672: LD_VAR 0 4
53676: PPUSH
53677: EMPTY
53678: PPUSH
53679: CALL_OW 1
53683: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
53684: LD_ADDR_EXP 27
53688: PUSH
53689: LD_EXP 27
53693: PPUSH
53694: LD_VAR 0 4
53698: PPUSH
53699: EMPTY
53700: PPUSH
53701: CALL_OW 1
53705: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
53706: LD_ADDR_EXP 28
53710: PUSH
53711: LD_EXP 28
53715: PPUSH
53716: LD_VAR 0 4
53720: PPUSH
53721: EMPTY
53722: PPUSH
53723: CALL_OW 1
53727: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
53728: LD_ADDR_EXP 29
53732: PUSH
53733: LD_EXP 29
53737: PPUSH
53738: LD_VAR 0 4
53742: PPUSH
53743: EMPTY
53744: PPUSH
53745: CALL_OW 1
53749: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
53750: LD_ADDR_EXP 30
53754: PUSH
53755: LD_EXP 30
53759: PPUSH
53760: LD_VAR 0 4
53764: PPUSH
53765: EMPTY
53766: PPUSH
53767: CALL_OW 1
53771: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
53772: LD_ADDR_EXP 31
53776: PUSH
53777: LD_EXP 31
53781: PPUSH
53782: LD_VAR 0 4
53786: PPUSH
53787: EMPTY
53788: PPUSH
53789: CALL_OW 1
53793: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
53794: LD_ADDR_EXP 32
53798: PUSH
53799: LD_EXP 32
53803: PPUSH
53804: LD_VAR 0 4
53808: PPUSH
53809: EMPTY
53810: PPUSH
53811: CALL_OW 1
53815: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
53816: LD_ADDR_EXP 33
53820: PUSH
53821: LD_EXP 33
53825: PPUSH
53826: LD_VAR 0 4
53830: PPUSH
53831: EMPTY
53832: PPUSH
53833: CALL_OW 1
53837: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
53838: LD_ADDR_EXP 34
53842: PUSH
53843: LD_EXP 34
53847: PPUSH
53848: LD_VAR 0 4
53852: PPUSH
53853: LD_INT 0
53855: PPUSH
53856: CALL_OW 1
53860: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
53861: LD_ADDR_EXP 35
53865: PUSH
53866: LD_EXP 35
53870: PPUSH
53871: LD_VAR 0 4
53875: PPUSH
53876: EMPTY
53877: PPUSH
53878: CALL_OW 1
53882: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
53883: LD_ADDR_EXP 36
53887: PUSH
53888: LD_EXP 36
53892: PPUSH
53893: LD_VAR 0 4
53897: PPUSH
53898: EMPTY
53899: PPUSH
53900: CALL_OW 1
53904: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
53905: LD_ADDR_EXP 37
53909: PUSH
53910: LD_EXP 37
53914: PPUSH
53915: LD_VAR 0 4
53919: PPUSH
53920: EMPTY
53921: PPUSH
53922: CALL_OW 1
53926: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
53927: LD_ADDR_EXP 38
53931: PUSH
53932: LD_EXP 38
53936: PPUSH
53937: LD_VAR 0 4
53941: PPUSH
53942: EMPTY
53943: PPUSH
53944: CALL_OW 1
53948: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
53949: LD_ADDR_EXP 39
53953: PUSH
53954: LD_EXP 39
53958: PPUSH
53959: LD_VAR 0 4
53963: PPUSH
53964: EMPTY
53965: PPUSH
53966: CALL_OW 1
53970: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
53971: LD_ADDR_EXP 40
53975: PUSH
53976: LD_EXP 40
53980: PPUSH
53981: LD_VAR 0 4
53985: PPUSH
53986: EMPTY
53987: PPUSH
53988: CALL_OW 1
53992: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
53993: LD_ADDR_EXP 41
53997: PUSH
53998: LD_EXP 41
54002: PPUSH
54003: LD_VAR 0 4
54007: PPUSH
54008: EMPTY
54009: PPUSH
54010: CALL_OW 1
54014: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
54015: LD_ADDR_EXP 42
54019: PUSH
54020: LD_EXP 42
54024: PPUSH
54025: LD_VAR 0 4
54029: PPUSH
54030: EMPTY
54031: PPUSH
54032: CALL_OW 1
54036: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
54037: LD_ADDR_EXP 43
54041: PUSH
54042: LD_EXP 43
54046: PPUSH
54047: LD_VAR 0 4
54051: PPUSH
54052: EMPTY
54053: PPUSH
54054: CALL_OW 1
54058: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
54059: LD_ADDR_EXP 44
54063: PUSH
54064: LD_EXP 44
54068: PPUSH
54069: LD_VAR 0 4
54073: PPUSH
54074: EMPTY
54075: PPUSH
54076: CALL_OW 1
54080: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
54081: LD_ADDR_EXP 45
54085: PUSH
54086: LD_EXP 45
54090: PPUSH
54091: LD_VAR 0 4
54095: PPUSH
54096: EMPTY
54097: PPUSH
54098: CALL_OW 1
54102: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
54103: LD_ADDR_EXP 46
54107: PUSH
54108: LD_EXP 46
54112: PPUSH
54113: LD_VAR 0 4
54117: PPUSH
54118: EMPTY
54119: PPUSH
54120: CALL_OW 1
54124: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
54125: LD_ADDR_EXP 47
54129: PUSH
54130: LD_EXP 47
54134: PPUSH
54135: LD_VAR 0 4
54139: PPUSH
54140: EMPTY
54141: PPUSH
54142: CALL_OW 1
54146: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
54147: LD_ADDR_EXP 48
54151: PUSH
54152: LD_EXP 48
54156: PPUSH
54157: LD_VAR 0 4
54161: PPUSH
54162: EMPTY
54163: PPUSH
54164: CALL_OW 1
54168: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
54169: LD_ADDR_EXP 50
54173: PUSH
54174: LD_EXP 50
54178: PPUSH
54179: LD_VAR 0 4
54183: PPUSH
54184: EMPTY
54185: PPUSH
54186: CALL_OW 1
54190: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
54191: LD_ADDR_EXP 52
54195: PUSH
54196: LD_EXP 52
54200: PPUSH
54201: LD_VAR 0 4
54205: PPUSH
54206: EMPTY
54207: PPUSH
54208: CALL_OW 1
54212: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
54213: LD_ADDR_EXP 53
54217: PUSH
54218: LD_EXP 53
54222: PPUSH
54223: LD_VAR 0 4
54227: PPUSH
54228: EMPTY
54229: PPUSH
54230: CALL_OW 1
54234: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
54235: LD_ADDR_EXP 54
54239: PUSH
54240: LD_EXP 54
54244: PPUSH
54245: LD_VAR 0 4
54249: PPUSH
54250: EMPTY
54251: PPUSH
54252: CALL_OW 1
54256: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
54257: LD_ADDR_EXP 55
54261: PUSH
54262: LD_EXP 55
54266: PPUSH
54267: LD_VAR 0 4
54271: PPUSH
54272: EMPTY
54273: PPUSH
54274: CALL_OW 1
54278: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
54279: LD_ADDR_EXP 56
54283: PUSH
54284: LD_EXP 56
54288: PPUSH
54289: LD_VAR 0 4
54293: PPUSH
54294: EMPTY
54295: PPUSH
54296: CALL_OW 1
54300: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
54301: LD_ADDR_EXP 57
54305: PUSH
54306: LD_EXP 57
54310: PPUSH
54311: LD_VAR 0 4
54315: PPUSH
54316: EMPTY
54317: PPUSH
54318: CALL_OW 1
54322: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
54323: LD_ADDR_EXP 58
54327: PUSH
54328: LD_EXP 58
54332: PPUSH
54333: LD_VAR 0 4
54337: PPUSH
54338: EMPTY
54339: PPUSH
54340: CALL_OW 1
54344: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
54345: LD_ADDR_EXP 59
54349: PUSH
54350: LD_EXP 59
54354: PPUSH
54355: LD_VAR 0 4
54359: PPUSH
54360: EMPTY
54361: PPUSH
54362: CALL_OW 1
54366: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
54367: LD_ADDR_EXP 60
54371: PUSH
54372: LD_EXP 60
54376: PPUSH
54377: LD_VAR 0 4
54381: PPUSH
54382: EMPTY
54383: PPUSH
54384: CALL_OW 1
54388: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
54389: LD_ADDR_EXP 61
54393: PUSH
54394: LD_EXP 61
54398: PPUSH
54399: LD_VAR 0 4
54403: PPUSH
54404: EMPTY
54405: PPUSH
54406: CALL_OW 1
54410: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
54411: LD_ADDR_EXP 62
54415: PUSH
54416: LD_EXP 62
54420: PPUSH
54421: LD_VAR 0 4
54425: PPUSH
54426: EMPTY
54427: PPUSH
54428: CALL_OW 1
54432: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
54433: LD_ADDR_EXP 63
54437: PUSH
54438: LD_EXP 63
54442: PPUSH
54443: LD_VAR 0 4
54447: PPUSH
54448: EMPTY
54449: PPUSH
54450: CALL_OW 1
54454: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
54455: LD_ADDR_EXP 64
54459: PUSH
54460: LD_EXP 64
54464: PPUSH
54465: LD_VAR 0 4
54469: PPUSH
54470: EMPTY
54471: PPUSH
54472: CALL_OW 1
54476: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
54477: LD_ADDR_EXP 65
54481: PUSH
54482: LD_EXP 65
54486: PPUSH
54487: LD_VAR 0 4
54491: PPUSH
54492: LD_INT 0
54494: PPUSH
54495: CALL_OW 1
54499: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
54500: LD_ADDR_EXP 66
54504: PUSH
54505: LD_EXP 66
54509: PPUSH
54510: LD_VAR 0 4
54514: PPUSH
54515: LD_INT 0
54517: PPUSH
54518: CALL_OW 1
54522: ST_TO_ADDR
// result := base ;
54523: LD_ADDR_VAR 0 3
54527: PUSH
54528: LD_VAR 0 4
54532: ST_TO_ADDR
// end ;
54533: LD_VAR 0 3
54537: RET
// export function MC_Start ( ) ; var i ; begin
54538: LD_INT 0
54540: PPUSH
54541: PPUSH
// for i = 1 to mc_bases do
54542: LD_ADDR_VAR 0 2
54546: PUSH
54547: DOUBLE
54548: LD_INT 1
54550: DEC
54551: ST_TO_ADDR
54552: LD_EXP 23
54556: PUSH
54557: FOR_TO
54558: IFFALSE 55658
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
54560: LD_ADDR_EXP 23
54564: PUSH
54565: LD_EXP 23
54569: PPUSH
54570: LD_VAR 0 2
54574: PPUSH
54575: LD_EXP 23
54579: PUSH
54580: LD_VAR 0 2
54584: ARRAY
54585: PUSH
54586: LD_INT 0
54588: DIFF
54589: PPUSH
54590: CALL_OW 1
54594: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
54595: LD_ADDR_EXP 24
54599: PUSH
54600: LD_EXP 24
54604: PPUSH
54605: LD_VAR 0 2
54609: PPUSH
54610: EMPTY
54611: PPUSH
54612: CALL_OW 1
54616: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
54617: LD_ADDR_EXP 25
54621: PUSH
54622: LD_EXP 25
54626: PPUSH
54627: LD_VAR 0 2
54631: PPUSH
54632: EMPTY
54633: PPUSH
54634: CALL_OW 1
54638: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
54639: LD_ADDR_EXP 26
54643: PUSH
54644: LD_EXP 26
54648: PPUSH
54649: LD_VAR 0 2
54653: PPUSH
54654: EMPTY
54655: PPUSH
54656: CALL_OW 1
54660: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
54661: LD_ADDR_EXP 27
54665: PUSH
54666: LD_EXP 27
54670: PPUSH
54671: LD_VAR 0 2
54675: PPUSH
54676: EMPTY
54677: PUSH
54678: EMPTY
54679: PUSH
54680: EMPTY
54681: LIST
54682: LIST
54683: PPUSH
54684: CALL_OW 1
54688: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
54689: LD_ADDR_EXP 28
54693: PUSH
54694: LD_EXP 28
54698: PPUSH
54699: LD_VAR 0 2
54703: PPUSH
54704: EMPTY
54705: PPUSH
54706: CALL_OW 1
54710: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
54711: LD_ADDR_EXP 55
54715: PUSH
54716: LD_EXP 55
54720: PPUSH
54721: LD_VAR 0 2
54725: PPUSH
54726: EMPTY
54727: PPUSH
54728: CALL_OW 1
54732: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
54733: LD_ADDR_EXP 29
54737: PUSH
54738: LD_EXP 29
54742: PPUSH
54743: LD_VAR 0 2
54747: PPUSH
54748: EMPTY
54749: PPUSH
54750: CALL_OW 1
54754: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
54755: LD_ADDR_EXP 30
54759: PUSH
54760: LD_EXP 30
54764: PPUSH
54765: LD_VAR 0 2
54769: PPUSH
54770: EMPTY
54771: PPUSH
54772: CALL_OW 1
54776: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
54777: LD_ADDR_EXP 31
54781: PUSH
54782: LD_EXP 31
54786: PPUSH
54787: LD_VAR 0 2
54791: PPUSH
54792: LD_EXP 23
54796: PUSH
54797: LD_VAR 0 2
54801: ARRAY
54802: PPUSH
54803: LD_INT 2
54805: PUSH
54806: LD_INT 30
54808: PUSH
54809: LD_INT 32
54811: PUSH
54812: EMPTY
54813: LIST
54814: LIST
54815: PUSH
54816: LD_INT 30
54818: PUSH
54819: LD_INT 33
54821: PUSH
54822: EMPTY
54823: LIST
54824: LIST
54825: PUSH
54826: EMPTY
54827: LIST
54828: LIST
54829: LIST
54830: PPUSH
54831: CALL_OW 72
54835: PPUSH
54836: CALL_OW 1
54840: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
54841: LD_ADDR_EXP 32
54845: PUSH
54846: LD_EXP 32
54850: PPUSH
54851: LD_VAR 0 2
54855: PPUSH
54856: LD_EXP 23
54860: PUSH
54861: LD_VAR 0 2
54865: ARRAY
54866: PPUSH
54867: LD_INT 2
54869: PUSH
54870: LD_INT 30
54872: PUSH
54873: LD_INT 32
54875: PUSH
54876: EMPTY
54877: LIST
54878: LIST
54879: PUSH
54880: LD_INT 30
54882: PUSH
54883: LD_INT 31
54885: PUSH
54886: EMPTY
54887: LIST
54888: LIST
54889: PUSH
54890: EMPTY
54891: LIST
54892: LIST
54893: LIST
54894: PUSH
54895: LD_INT 58
54897: PUSH
54898: EMPTY
54899: LIST
54900: PUSH
54901: EMPTY
54902: LIST
54903: LIST
54904: PPUSH
54905: CALL_OW 72
54909: PPUSH
54910: CALL_OW 1
54914: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
54915: LD_ADDR_EXP 33
54919: PUSH
54920: LD_EXP 33
54924: PPUSH
54925: LD_VAR 0 2
54929: PPUSH
54930: EMPTY
54931: PPUSH
54932: CALL_OW 1
54936: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
54937: LD_ADDR_EXP 37
54941: PUSH
54942: LD_EXP 37
54946: PPUSH
54947: LD_VAR 0 2
54951: PPUSH
54952: EMPTY
54953: PPUSH
54954: CALL_OW 1
54958: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
54959: LD_ADDR_EXP 36
54963: PUSH
54964: LD_EXP 36
54968: PPUSH
54969: LD_VAR 0 2
54973: PPUSH
54974: EMPTY
54975: PPUSH
54976: CALL_OW 1
54980: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
54981: LD_ADDR_EXP 38
54985: PUSH
54986: LD_EXP 38
54990: PPUSH
54991: LD_VAR 0 2
54995: PPUSH
54996: EMPTY
54997: PPUSH
54998: CALL_OW 1
55002: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
55003: LD_ADDR_EXP 39
55007: PUSH
55008: LD_EXP 39
55012: PPUSH
55013: LD_VAR 0 2
55017: PPUSH
55018: EMPTY
55019: PPUSH
55020: CALL_OW 1
55024: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
55025: LD_ADDR_EXP 40
55029: PUSH
55030: LD_EXP 40
55034: PPUSH
55035: LD_VAR 0 2
55039: PPUSH
55040: EMPTY
55041: PPUSH
55042: CALL_OW 1
55046: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
55047: LD_ADDR_EXP 41
55051: PUSH
55052: LD_EXP 41
55056: PPUSH
55057: LD_VAR 0 2
55061: PPUSH
55062: EMPTY
55063: PPUSH
55064: CALL_OW 1
55068: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
55069: LD_ADDR_EXP 42
55073: PUSH
55074: LD_EXP 42
55078: PPUSH
55079: LD_VAR 0 2
55083: PPUSH
55084: EMPTY
55085: PPUSH
55086: CALL_OW 1
55090: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
55091: LD_ADDR_EXP 43
55095: PUSH
55096: LD_EXP 43
55100: PPUSH
55101: LD_VAR 0 2
55105: PPUSH
55106: EMPTY
55107: PPUSH
55108: CALL_OW 1
55112: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
55113: LD_ADDR_EXP 44
55117: PUSH
55118: LD_EXP 44
55122: PPUSH
55123: LD_VAR 0 2
55127: PPUSH
55128: EMPTY
55129: PPUSH
55130: CALL_OW 1
55134: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
55135: LD_ADDR_EXP 45
55139: PUSH
55140: LD_EXP 45
55144: PPUSH
55145: LD_VAR 0 2
55149: PPUSH
55150: EMPTY
55151: PPUSH
55152: CALL_OW 1
55156: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
55157: LD_ADDR_EXP 34
55161: PUSH
55162: LD_EXP 34
55166: PPUSH
55167: LD_VAR 0 2
55171: PPUSH
55172: LD_INT 0
55174: PPUSH
55175: CALL_OW 1
55179: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
55180: LD_ADDR_EXP 47
55184: PUSH
55185: LD_EXP 47
55189: PPUSH
55190: LD_VAR 0 2
55194: PPUSH
55195: LD_INT 0
55197: PPUSH
55198: CALL_OW 1
55202: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
55203: LD_ADDR_EXP 35
55207: PUSH
55208: LD_EXP 35
55212: PPUSH
55213: LD_VAR 0 2
55217: PPUSH
55218: EMPTY
55219: PPUSH
55220: CALL_OW 1
55224: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
55225: LD_ADDR_EXP 46
55229: PUSH
55230: LD_EXP 46
55234: PPUSH
55235: LD_VAR 0 2
55239: PPUSH
55240: LD_INT 0
55242: PPUSH
55243: CALL_OW 1
55247: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
55248: LD_ADDR_EXP 48
55252: PUSH
55253: LD_EXP 48
55257: PPUSH
55258: LD_VAR 0 2
55262: PPUSH
55263: EMPTY
55264: PPUSH
55265: CALL_OW 1
55269: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
55270: LD_ADDR_EXP 51
55274: PUSH
55275: LD_EXP 51
55279: PPUSH
55280: LD_VAR 0 2
55284: PPUSH
55285: LD_INT 0
55287: PPUSH
55288: CALL_OW 1
55292: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
55293: LD_ADDR_EXP 52
55297: PUSH
55298: LD_EXP 52
55302: PPUSH
55303: LD_VAR 0 2
55307: PPUSH
55308: EMPTY
55309: PPUSH
55310: CALL_OW 1
55314: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
55315: LD_ADDR_EXP 53
55319: PUSH
55320: LD_EXP 53
55324: PPUSH
55325: LD_VAR 0 2
55329: PPUSH
55330: EMPTY
55331: PPUSH
55332: CALL_OW 1
55336: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
55337: LD_ADDR_EXP 54
55341: PUSH
55342: LD_EXP 54
55346: PPUSH
55347: LD_VAR 0 2
55351: PPUSH
55352: EMPTY
55353: PPUSH
55354: CALL_OW 1
55358: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
55359: LD_ADDR_EXP 56
55363: PUSH
55364: LD_EXP 56
55368: PPUSH
55369: LD_VAR 0 2
55373: PPUSH
55374: LD_EXP 23
55378: PUSH
55379: LD_VAR 0 2
55383: ARRAY
55384: PPUSH
55385: LD_INT 2
55387: PUSH
55388: LD_INT 30
55390: PUSH
55391: LD_INT 6
55393: PUSH
55394: EMPTY
55395: LIST
55396: LIST
55397: PUSH
55398: LD_INT 30
55400: PUSH
55401: LD_INT 7
55403: PUSH
55404: EMPTY
55405: LIST
55406: LIST
55407: PUSH
55408: LD_INT 30
55410: PUSH
55411: LD_INT 8
55413: PUSH
55414: EMPTY
55415: LIST
55416: LIST
55417: PUSH
55418: EMPTY
55419: LIST
55420: LIST
55421: LIST
55422: LIST
55423: PPUSH
55424: CALL_OW 72
55428: PPUSH
55429: CALL_OW 1
55433: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
55434: LD_ADDR_EXP 57
55438: PUSH
55439: LD_EXP 57
55443: PPUSH
55444: LD_VAR 0 2
55448: PPUSH
55449: EMPTY
55450: PPUSH
55451: CALL_OW 1
55455: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
55456: LD_ADDR_EXP 58
55460: PUSH
55461: LD_EXP 58
55465: PPUSH
55466: LD_VAR 0 2
55470: PPUSH
55471: EMPTY
55472: PPUSH
55473: CALL_OW 1
55477: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
55478: LD_ADDR_EXP 59
55482: PUSH
55483: LD_EXP 59
55487: PPUSH
55488: LD_VAR 0 2
55492: PPUSH
55493: EMPTY
55494: PPUSH
55495: CALL_OW 1
55499: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
55500: LD_ADDR_EXP 60
55504: PUSH
55505: LD_EXP 60
55509: PPUSH
55510: LD_VAR 0 2
55514: PPUSH
55515: EMPTY
55516: PPUSH
55517: CALL_OW 1
55521: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55522: LD_ADDR_EXP 61
55526: PUSH
55527: LD_EXP 61
55531: PPUSH
55532: LD_VAR 0 2
55536: PPUSH
55537: EMPTY
55538: PPUSH
55539: CALL_OW 1
55543: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
55544: LD_ADDR_EXP 62
55548: PUSH
55549: LD_EXP 62
55553: PPUSH
55554: LD_VAR 0 2
55558: PPUSH
55559: EMPTY
55560: PPUSH
55561: CALL_OW 1
55565: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
55566: LD_ADDR_EXP 63
55570: PUSH
55571: LD_EXP 63
55575: PPUSH
55576: LD_VAR 0 2
55580: PPUSH
55581: EMPTY
55582: PPUSH
55583: CALL_OW 1
55587: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
55588: LD_ADDR_EXP 64
55592: PUSH
55593: LD_EXP 64
55597: PPUSH
55598: LD_VAR 0 2
55602: PPUSH
55603: EMPTY
55604: PPUSH
55605: CALL_OW 1
55609: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
55610: LD_ADDR_EXP 65
55614: PUSH
55615: LD_EXP 65
55619: PPUSH
55620: LD_VAR 0 2
55624: PPUSH
55625: LD_INT 0
55627: PPUSH
55628: CALL_OW 1
55632: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
55633: LD_ADDR_EXP 66
55637: PUSH
55638: LD_EXP 66
55642: PPUSH
55643: LD_VAR 0 2
55647: PPUSH
55648: LD_INT 0
55650: PPUSH
55651: CALL_OW 1
55655: ST_TO_ADDR
// end ;
55656: GO 54557
55658: POP
55659: POP
// MC_InitSides ( ) ;
55660: CALL 55946 0 0
// MC_InitResearch ( ) ;
55664: CALL 55685 0 0
// CustomInitMacro ( ) ;
55668: CALL 269 0 0
// skirmish := true ;
55672: LD_ADDR_EXP 21
55676: PUSH
55677: LD_INT 1
55679: ST_TO_ADDR
// end ;
55680: LD_VAR 0 1
55684: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
55685: LD_INT 0
55687: PPUSH
55688: PPUSH
55689: PPUSH
55690: PPUSH
55691: PPUSH
55692: PPUSH
// if not mc_bases then
55693: LD_EXP 23
55697: NOT
55698: IFFALSE 55702
// exit ;
55700: GO 55941
// for i = 1 to 8 do
55702: LD_ADDR_VAR 0 2
55706: PUSH
55707: DOUBLE
55708: LD_INT 1
55710: DEC
55711: ST_TO_ADDR
55712: LD_INT 8
55714: PUSH
55715: FOR_TO
55716: IFFALSE 55742
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
55718: LD_ADDR_EXP 50
55722: PUSH
55723: LD_EXP 50
55727: PPUSH
55728: LD_VAR 0 2
55732: PPUSH
55733: EMPTY
55734: PPUSH
55735: CALL_OW 1
55739: ST_TO_ADDR
55740: GO 55715
55742: POP
55743: POP
// tmp := [ ] ;
55744: LD_ADDR_VAR 0 5
55748: PUSH
55749: EMPTY
55750: ST_TO_ADDR
// for i = 1 to mc_sides do
55751: LD_ADDR_VAR 0 2
55755: PUSH
55756: DOUBLE
55757: LD_INT 1
55759: DEC
55760: ST_TO_ADDR
55761: LD_EXP 49
55765: PUSH
55766: FOR_TO
55767: IFFALSE 55825
// if not mc_sides [ i ] in tmp then
55769: LD_EXP 49
55773: PUSH
55774: LD_VAR 0 2
55778: ARRAY
55779: PUSH
55780: LD_VAR 0 5
55784: IN
55785: NOT
55786: IFFALSE 55823
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
55788: LD_ADDR_VAR 0 5
55792: PUSH
55793: LD_VAR 0 5
55797: PPUSH
55798: LD_VAR 0 5
55802: PUSH
55803: LD_INT 1
55805: PLUS
55806: PPUSH
55807: LD_EXP 49
55811: PUSH
55812: LD_VAR 0 2
55816: ARRAY
55817: PPUSH
55818: CALL_OW 2
55822: ST_TO_ADDR
55823: GO 55766
55825: POP
55826: POP
// if not tmp then
55827: LD_VAR 0 5
55831: NOT
55832: IFFALSE 55836
// exit ;
55834: GO 55941
// for j in tmp do
55836: LD_ADDR_VAR 0 3
55840: PUSH
55841: LD_VAR 0 5
55845: PUSH
55846: FOR_IN
55847: IFFALSE 55939
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
55849: LD_ADDR_VAR 0 6
55853: PUSH
55854: LD_INT 22
55856: PUSH
55857: LD_VAR 0 3
55861: PUSH
55862: EMPTY
55863: LIST
55864: LIST
55865: PPUSH
55866: CALL_OW 69
55870: ST_TO_ADDR
// if not un then
55871: LD_VAR 0 6
55875: NOT
55876: IFFALSE 55880
// continue ;
55878: GO 55846
// nation := GetNation ( un [ 1 ] ) ;
55880: LD_ADDR_VAR 0 4
55884: PUSH
55885: LD_VAR 0 6
55889: PUSH
55890: LD_INT 1
55892: ARRAY
55893: PPUSH
55894: CALL_OW 248
55898: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
55899: LD_ADDR_EXP 50
55903: PUSH
55904: LD_EXP 50
55908: PPUSH
55909: LD_VAR 0 3
55913: PPUSH
55914: LD_VAR 0 3
55918: PPUSH
55919: LD_VAR 0 4
55923: PPUSH
55924: LD_INT 1
55926: PPUSH
55927: CALL 11036 0 3
55931: PPUSH
55932: CALL_OW 1
55936: ST_TO_ADDR
// end ;
55937: GO 55846
55939: POP
55940: POP
// end ;
55941: LD_VAR 0 1
55945: RET
// export function MC_InitSides ( ) ; var i ; begin
55946: LD_INT 0
55948: PPUSH
55949: PPUSH
// if not mc_bases then
55950: LD_EXP 23
55954: NOT
55955: IFFALSE 55959
// exit ;
55957: GO 56033
// for i = 1 to mc_bases do
55959: LD_ADDR_VAR 0 2
55963: PUSH
55964: DOUBLE
55965: LD_INT 1
55967: DEC
55968: ST_TO_ADDR
55969: LD_EXP 23
55973: PUSH
55974: FOR_TO
55975: IFFALSE 56031
// if mc_bases [ i ] then
55977: LD_EXP 23
55981: PUSH
55982: LD_VAR 0 2
55986: ARRAY
55987: IFFALSE 56029
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
55989: LD_ADDR_EXP 49
55993: PUSH
55994: LD_EXP 49
55998: PPUSH
55999: LD_VAR 0 2
56003: PPUSH
56004: LD_EXP 23
56008: PUSH
56009: LD_VAR 0 2
56013: ARRAY
56014: PUSH
56015: LD_INT 1
56017: ARRAY
56018: PPUSH
56019: CALL_OW 255
56023: PPUSH
56024: CALL_OW 1
56028: ST_TO_ADDR
56029: GO 55974
56031: POP
56032: POP
// end ;
56033: LD_VAR 0 1
56037: RET
// every 0 0$03 trigger skirmish do
56038: LD_EXP 21
56042: IFFALSE 56196
56044: GO 56046
56046: DISABLE
// begin enable ;
56047: ENABLE
// MC_CheckBuildings ( ) ;
56048: CALL 60694 0 0
// MC_CheckPeopleLife ( ) ;
56052: CALL 60855 0 0
// RaiseSailEvent ( 100 ) ;
56056: LD_INT 100
56058: PPUSH
56059: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
56063: LD_INT 103
56065: PPUSH
56066: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
56070: LD_INT 104
56072: PPUSH
56073: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
56077: LD_INT 105
56079: PPUSH
56080: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
56084: LD_INT 106
56086: PPUSH
56087: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
56091: LD_INT 107
56093: PPUSH
56094: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
56098: LD_INT 108
56100: PPUSH
56101: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
56105: LD_INT 109
56107: PPUSH
56108: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
56112: LD_INT 110
56114: PPUSH
56115: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
56119: LD_INT 111
56121: PPUSH
56122: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
56126: LD_INT 112
56128: PPUSH
56129: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
56133: LD_INT 113
56135: PPUSH
56136: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
56140: LD_INT 120
56142: PPUSH
56143: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
56147: LD_INT 121
56149: PPUSH
56150: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
56154: LD_INT 122
56156: PPUSH
56157: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
56161: LD_INT 123
56163: PPUSH
56164: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
56168: LD_INT 124
56170: PPUSH
56171: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
56175: LD_INT 125
56177: PPUSH
56178: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
56182: LD_INT 126
56184: PPUSH
56185: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
56189: LD_INT 200
56191: PPUSH
56192: CALL_OW 427
// end ;
56196: END
// on SailEvent ( event ) do begin if event < 100 then
56197: LD_VAR 0 1
56201: PUSH
56202: LD_INT 100
56204: LESS
56205: IFFALSE 56216
// CustomEvent ( event ) ;
56207: LD_VAR 0 1
56211: PPUSH
56212: CALL 10187 0 1
// if event = 100 then
56216: LD_VAR 0 1
56220: PUSH
56221: LD_INT 100
56223: EQUAL
56224: IFFALSE 56230
// MC_ClassManager ( ) ;
56226: CALL 56622 0 0
// if event = 101 then
56230: LD_VAR 0 1
56234: PUSH
56235: LD_INT 101
56237: EQUAL
56238: IFFALSE 56244
// MC_RepairBuildings ( ) ;
56240: CALL 61440 0 0
// if event = 102 then
56244: LD_VAR 0 1
56248: PUSH
56249: LD_INT 102
56251: EQUAL
56252: IFFALSE 56258
// MC_Heal ( ) ;
56254: CALL 62375 0 0
// if event = 103 then
56258: LD_VAR 0 1
56262: PUSH
56263: LD_INT 103
56265: EQUAL
56266: IFFALSE 56272
// MC_Build ( ) ;
56268: CALL 62797 0 0
// if event = 104 then
56272: LD_VAR 0 1
56276: PUSH
56277: LD_INT 104
56279: EQUAL
56280: IFFALSE 56286
// MC_TurretWeapon ( ) ;
56282: CALL 64431 0 0
// if event = 105 then
56286: LD_VAR 0 1
56290: PUSH
56291: LD_INT 105
56293: EQUAL
56294: IFFALSE 56300
// MC_BuildUpgrade ( ) ;
56296: CALL 63982 0 0
// if event = 106 then
56300: LD_VAR 0 1
56304: PUSH
56305: LD_INT 106
56307: EQUAL
56308: IFFALSE 56314
// MC_PlantMines ( ) ;
56310: CALL 64861 0 0
// if event = 107 then
56314: LD_VAR 0 1
56318: PUSH
56319: LD_INT 107
56321: EQUAL
56322: IFFALSE 56328
// MC_CollectCrates ( ) ;
56324: CALL 65652 0 0
// if event = 108 then
56328: LD_VAR 0 1
56332: PUSH
56333: LD_INT 108
56335: EQUAL
56336: IFFALSE 56342
// MC_LinkRemoteControl ( ) ;
56338: CALL 67502 0 0
// if event = 109 then
56342: LD_VAR 0 1
56346: PUSH
56347: LD_INT 109
56349: EQUAL
56350: IFFALSE 56356
// MC_ProduceVehicle ( ) ;
56352: CALL 67683 0 0
// if event = 110 then
56356: LD_VAR 0 1
56360: PUSH
56361: LD_INT 110
56363: EQUAL
56364: IFFALSE 56370
// MC_SendAttack ( ) ;
56366: CALL 68149 0 0
// if event = 111 then
56370: LD_VAR 0 1
56374: PUSH
56375: LD_INT 111
56377: EQUAL
56378: IFFALSE 56384
// MC_Defend ( ) ;
56380: CALL 68257 0 0
// if event = 112 then
56384: LD_VAR 0 1
56388: PUSH
56389: LD_INT 112
56391: EQUAL
56392: IFFALSE 56398
// MC_Research ( ) ;
56394: CALL 69137 0 0
// if event = 113 then
56398: LD_VAR 0 1
56402: PUSH
56403: LD_INT 113
56405: EQUAL
56406: IFFALSE 56412
// MC_MinesTrigger ( ) ;
56408: CALL 70251 0 0
// if event = 120 then
56412: LD_VAR 0 1
56416: PUSH
56417: LD_INT 120
56419: EQUAL
56420: IFFALSE 56426
// MC_RepairVehicle ( ) ;
56422: CALL 70350 0 0
// if event = 121 then
56426: LD_VAR 0 1
56430: PUSH
56431: LD_INT 121
56433: EQUAL
56434: IFFALSE 56440
// MC_TameApe ( ) ;
56436: CALL 71119 0 0
// if event = 122 then
56440: LD_VAR 0 1
56444: PUSH
56445: LD_INT 122
56447: EQUAL
56448: IFFALSE 56454
// MC_ChangeApeClass ( ) ;
56450: CALL 71948 0 0
// if event = 123 then
56454: LD_VAR 0 1
56458: PUSH
56459: LD_INT 123
56461: EQUAL
56462: IFFALSE 56468
// MC_Bazooka ( ) ;
56464: CALL 72598 0 0
// if event = 124 then
56468: LD_VAR 0 1
56472: PUSH
56473: LD_INT 124
56475: EQUAL
56476: IFFALSE 56482
// MC_TeleportExit ( ) ;
56478: CALL 72796 0 0
// if event = 125 then
56482: LD_VAR 0 1
56486: PUSH
56487: LD_INT 125
56489: EQUAL
56490: IFFALSE 56496
// MC_Deposits ( ) ;
56492: CALL 73443 0 0
// if event = 126 then
56496: LD_VAR 0 1
56500: PUSH
56501: LD_INT 126
56503: EQUAL
56504: IFFALSE 56510
// MC_RemoteDriver ( ) ;
56506: CALL 74068 0 0
// if event = 200 then
56510: LD_VAR 0 1
56514: PUSH
56515: LD_INT 200
56517: EQUAL
56518: IFFALSE 56524
// MC_Idle ( ) ;
56520: CALL 76017 0 0
// end ;
56524: PPOPN 1
56526: END
// export function MC_Reset ( base , tag ) ; var i ; begin
56527: LD_INT 0
56529: PPUSH
56530: PPUSH
// if not mc_bases [ base ] or not tag then
56531: LD_EXP 23
56535: PUSH
56536: LD_VAR 0 1
56540: ARRAY
56541: NOT
56542: PUSH
56543: LD_VAR 0 2
56547: NOT
56548: OR
56549: IFFALSE 56553
// exit ;
56551: GO 56617
// for i in mc_bases [ base ] union mc_ape [ base ] do
56553: LD_ADDR_VAR 0 4
56557: PUSH
56558: LD_EXP 23
56562: PUSH
56563: LD_VAR 0 1
56567: ARRAY
56568: PUSH
56569: LD_EXP 52
56573: PUSH
56574: LD_VAR 0 1
56578: ARRAY
56579: UNION
56580: PUSH
56581: FOR_IN
56582: IFFALSE 56615
// if GetTag ( i ) = tag then
56584: LD_VAR 0 4
56588: PPUSH
56589: CALL_OW 110
56593: PUSH
56594: LD_VAR 0 2
56598: EQUAL
56599: IFFALSE 56613
// SetTag ( i , 0 ) ;
56601: LD_VAR 0 4
56605: PPUSH
56606: LD_INT 0
56608: PPUSH
56609: CALL_OW 109
56613: GO 56581
56615: POP
56616: POP
// end ;
56617: LD_VAR 0 3
56621: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
56622: LD_INT 0
56624: PPUSH
56625: PPUSH
56626: PPUSH
56627: PPUSH
56628: PPUSH
56629: PPUSH
56630: PPUSH
56631: PPUSH
// if not mc_bases then
56632: LD_EXP 23
56636: NOT
56637: IFFALSE 56641
// exit ;
56639: GO 57099
// for i = 1 to mc_bases do
56641: LD_ADDR_VAR 0 2
56645: PUSH
56646: DOUBLE
56647: LD_INT 1
56649: DEC
56650: ST_TO_ADDR
56651: LD_EXP 23
56655: PUSH
56656: FOR_TO
56657: IFFALSE 57097
// begin tmp := MC_ClassCheckReq ( i ) ;
56659: LD_ADDR_VAR 0 4
56663: PUSH
56664: LD_VAR 0 2
56668: PPUSH
56669: CALL 57104 0 1
56673: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
56674: LD_ADDR_EXP 64
56678: PUSH
56679: LD_EXP 64
56683: PPUSH
56684: LD_VAR 0 2
56688: PPUSH
56689: LD_VAR 0 4
56693: PPUSH
56694: CALL_OW 1
56698: ST_TO_ADDR
// if not tmp then
56699: LD_VAR 0 4
56703: NOT
56704: IFFALSE 56708
// continue ;
56706: GO 56656
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
56708: LD_ADDR_VAR 0 6
56712: PUSH
56713: LD_EXP 23
56717: PUSH
56718: LD_VAR 0 2
56722: ARRAY
56723: PPUSH
56724: LD_INT 2
56726: PUSH
56727: LD_INT 30
56729: PUSH
56730: LD_INT 4
56732: PUSH
56733: EMPTY
56734: LIST
56735: LIST
56736: PUSH
56737: LD_INT 30
56739: PUSH
56740: LD_INT 5
56742: PUSH
56743: EMPTY
56744: LIST
56745: LIST
56746: PUSH
56747: EMPTY
56748: LIST
56749: LIST
56750: LIST
56751: PPUSH
56752: CALL_OW 72
56756: PUSH
56757: LD_EXP 23
56761: PUSH
56762: LD_VAR 0 2
56766: ARRAY
56767: PPUSH
56768: LD_INT 2
56770: PUSH
56771: LD_INT 30
56773: PUSH
56774: LD_INT 0
56776: PUSH
56777: EMPTY
56778: LIST
56779: LIST
56780: PUSH
56781: LD_INT 30
56783: PUSH
56784: LD_INT 1
56786: PUSH
56787: EMPTY
56788: LIST
56789: LIST
56790: PUSH
56791: EMPTY
56792: LIST
56793: LIST
56794: LIST
56795: PPUSH
56796: CALL_OW 72
56800: PUSH
56801: LD_EXP 23
56805: PUSH
56806: LD_VAR 0 2
56810: ARRAY
56811: PPUSH
56812: LD_INT 30
56814: PUSH
56815: LD_INT 3
56817: PUSH
56818: EMPTY
56819: LIST
56820: LIST
56821: PPUSH
56822: CALL_OW 72
56826: PUSH
56827: LD_EXP 23
56831: PUSH
56832: LD_VAR 0 2
56836: ARRAY
56837: PPUSH
56838: LD_INT 2
56840: PUSH
56841: LD_INT 30
56843: PUSH
56844: LD_INT 6
56846: PUSH
56847: EMPTY
56848: LIST
56849: LIST
56850: PUSH
56851: LD_INT 30
56853: PUSH
56854: LD_INT 7
56856: PUSH
56857: EMPTY
56858: LIST
56859: LIST
56860: PUSH
56861: LD_INT 30
56863: PUSH
56864: LD_INT 8
56866: PUSH
56867: EMPTY
56868: LIST
56869: LIST
56870: PUSH
56871: EMPTY
56872: LIST
56873: LIST
56874: LIST
56875: LIST
56876: PPUSH
56877: CALL_OW 72
56881: PUSH
56882: EMPTY
56883: LIST
56884: LIST
56885: LIST
56886: LIST
56887: ST_TO_ADDR
// for j = 1 to 4 do
56888: LD_ADDR_VAR 0 3
56892: PUSH
56893: DOUBLE
56894: LD_INT 1
56896: DEC
56897: ST_TO_ADDR
56898: LD_INT 4
56900: PUSH
56901: FOR_TO
56902: IFFALSE 57093
// begin if not tmp [ j ] then
56904: LD_VAR 0 4
56908: PUSH
56909: LD_VAR 0 3
56913: ARRAY
56914: NOT
56915: IFFALSE 56919
// continue ;
56917: GO 56901
// for p in tmp [ j ] do
56919: LD_ADDR_VAR 0 5
56923: PUSH
56924: LD_VAR 0 4
56928: PUSH
56929: LD_VAR 0 3
56933: ARRAY
56934: PUSH
56935: FOR_IN
56936: IFFALSE 57089
// begin if not b [ j ] then
56938: LD_VAR 0 6
56942: PUSH
56943: LD_VAR 0 3
56947: ARRAY
56948: NOT
56949: IFFALSE 56953
// break ;
56951: GO 57089
// e := 0 ;
56953: LD_ADDR_VAR 0 7
56957: PUSH
56958: LD_INT 0
56960: ST_TO_ADDR
// for k in b [ j ] do
56961: LD_ADDR_VAR 0 8
56965: PUSH
56966: LD_VAR 0 6
56970: PUSH
56971: LD_VAR 0 3
56975: ARRAY
56976: PUSH
56977: FOR_IN
56978: IFFALSE 57005
// if IsNotFull ( k ) then
56980: LD_VAR 0 8
56984: PPUSH
56985: CALL 13189 0 1
56989: IFFALSE 57003
// begin e := k ;
56991: LD_ADDR_VAR 0 7
56995: PUSH
56996: LD_VAR 0 8
57000: ST_TO_ADDR
// break ;
57001: GO 57005
// end ;
57003: GO 56977
57005: POP
57006: POP
// if e and not UnitGoingToBuilding ( p , e ) then
57007: LD_VAR 0 7
57011: PUSH
57012: LD_VAR 0 5
57016: PPUSH
57017: LD_VAR 0 7
57021: PPUSH
57022: CALL 47059 0 2
57026: NOT
57027: AND
57028: IFFALSE 57087
// begin if IsInUnit ( p ) then
57030: LD_VAR 0 5
57034: PPUSH
57035: CALL_OW 310
57039: IFFALSE 57050
// ComExitBuilding ( p ) ;
57041: LD_VAR 0 5
57045: PPUSH
57046: CALL_OW 122
// ComEnterUnit ( p , e ) ;
57050: LD_VAR 0 5
57054: PPUSH
57055: LD_VAR 0 7
57059: PPUSH
57060: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
57064: LD_VAR 0 5
57068: PPUSH
57069: LD_VAR 0 3
57073: PPUSH
57074: CALL_OW 183
// AddComExitBuilding ( p ) ;
57078: LD_VAR 0 5
57082: PPUSH
57083: CALL_OW 182
// end ; end ;
57087: GO 56935
57089: POP
57090: POP
// end ;
57091: GO 56901
57093: POP
57094: POP
// end ;
57095: GO 56656
57097: POP
57098: POP
// end ;
57099: LD_VAR 0 1
57103: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
57104: LD_INT 0
57106: PPUSH
57107: PPUSH
57108: PPUSH
57109: PPUSH
57110: PPUSH
57111: PPUSH
57112: PPUSH
57113: PPUSH
57114: PPUSH
57115: PPUSH
57116: PPUSH
57117: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
57118: LD_VAR 0 1
57122: NOT
57123: PUSH
57124: LD_EXP 23
57128: PUSH
57129: LD_VAR 0 1
57133: ARRAY
57134: NOT
57135: OR
57136: PUSH
57137: LD_EXP 23
57141: PUSH
57142: LD_VAR 0 1
57146: ARRAY
57147: PPUSH
57148: LD_INT 2
57150: PUSH
57151: LD_INT 30
57153: PUSH
57154: LD_INT 0
57156: PUSH
57157: EMPTY
57158: LIST
57159: LIST
57160: PUSH
57161: LD_INT 30
57163: PUSH
57164: LD_INT 1
57166: PUSH
57167: EMPTY
57168: LIST
57169: LIST
57170: PUSH
57171: EMPTY
57172: LIST
57173: LIST
57174: LIST
57175: PPUSH
57176: CALL_OW 72
57180: NOT
57181: OR
57182: IFFALSE 57186
// exit ;
57184: GO 60689
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
57186: LD_ADDR_VAR 0 4
57190: PUSH
57191: LD_EXP 23
57195: PUSH
57196: LD_VAR 0 1
57200: ARRAY
57201: PPUSH
57202: LD_INT 2
57204: PUSH
57205: LD_INT 25
57207: PUSH
57208: LD_INT 1
57210: PUSH
57211: EMPTY
57212: LIST
57213: LIST
57214: PUSH
57215: LD_INT 25
57217: PUSH
57218: LD_INT 2
57220: PUSH
57221: EMPTY
57222: LIST
57223: LIST
57224: PUSH
57225: LD_INT 25
57227: PUSH
57228: LD_INT 3
57230: PUSH
57231: EMPTY
57232: LIST
57233: LIST
57234: PUSH
57235: LD_INT 25
57237: PUSH
57238: LD_INT 4
57240: PUSH
57241: EMPTY
57242: LIST
57243: LIST
57244: PUSH
57245: LD_INT 25
57247: PUSH
57248: LD_INT 5
57250: PUSH
57251: EMPTY
57252: LIST
57253: LIST
57254: PUSH
57255: LD_INT 25
57257: PUSH
57258: LD_INT 8
57260: PUSH
57261: EMPTY
57262: LIST
57263: LIST
57264: PUSH
57265: LD_INT 25
57267: PUSH
57268: LD_INT 9
57270: PUSH
57271: EMPTY
57272: LIST
57273: LIST
57274: PUSH
57275: EMPTY
57276: LIST
57277: LIST
57278: LIST
57279: LIST
57280: LIST
57281: LIST
57282: LIST
57283: LIST
57284: PPUSH
57285: CALL_OW 72
57289: ST_TO_ADDR
// if not tmp then
57290: LD_VAR 0 4
57294: NOT
57295: IFFALSE 57299
// exit ;
57297: GO 60689
// for i in tmp do
57299: LD_ADDR_VAR 0 3
57303: PUSH
57304: LD_VAR 0 4
57308: PUSH
57309: FOR_IN
57310: IFFALSE 57341
// if GetTag ( i ) then
57312: LD_VAR 0 3
57316: PPUSH
57317: CALL_OW 110
57321: IFFALSE 57339
// tmp := tmp diff i ;
57323: LD_ADDR_VAR 0 4
57327: PUSH
57328: LD_VAR 0 4
57332: PUSH
57333: LD_VAR 0 3
57337: DIFF
57338: ST_TO_ADDR
57339: GO 57309
57341: POP
57342: POP
// if not tmp then
57343: LD_VAR 0 4
57347: NOT
57348: IFFALSE 57352
// exit ;
57350: GO 60689
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
57352: LD_ADDR_VAR 0 5
57356: PUSH
57357: LD_EXP 23
57361: PUSH
57362: LD_VAR 0 1
57366: ARRAY
57367: PPUSH
57368: LD_INT 2
57370: PUSH
57371: LD_INT 25
57373: PUSH
57374: LD_INT 1
57376: PUSH
57377: EMPTY
57378: LIST
57379: LIST
57380: PUSH
57381: LD_INT 25
57383: PUSH
57384: LD_INT 5
57386: PUSH
57387: EMPTY
57388: LIST
57389: LIST
57390: PUSH
57391: LD_INT 25
57393: PUSH
57394: LD_INT 8
57396: PUSH
57397: EMPTY
57398: LIST
57399: LIST
57400: PUSH
57401: LD_INT 25
57403: PUSH
57404: LD_INT 9
57406: PUSH
57407: EMPTY
57408: LIST
57409: LIST
57410: PUSH
57411: EMPTY
57412: LIST
57413: LIST
57414: LIST
57415: LIST
57416: LIST
57417: PPUSH
57418: CALL_OW 72
57422: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
57423: LD_ADDR_VAR 0 6
57427: PUSH
57428: LD_EXP 23
57432: PUSH
57433: LD_VAR 0 1
57437: ARRAY
57438: PPUSH
57439: LD_INT 25
57441: PUSH
57442: LD_INT 2
57444: PUSH
57445: EMPTY
57446: LIST
57447: LIST
57448: PPUSH
57449: CALL_OW 72
57453: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
57454: LD_ADDR_VAR 0 7
57458: PUSH
57459: LD_EXP 23
57463: PUSH
57464: LD_VAR 0 1
57468: ARRAY
57469: PPUSH
57470: LD_INT 25
57472: PUSH
57473: LD_INT 3
57475: PUSH
57476: EMPTY
57477: LIST
57478: LIST
57479: PPUSH
57480: CALL_OW 72
57484: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
57485: LD_ADDR_VAR 0 8
57489: PUSH
57490: LD_EXP 23
57494: PUSH
57495: LD_VAR 0 1
57499: ARRAY
57500: PPUSH
57501: LD_INT 25
57503: PUSH
57504: LD_INT 4
57506: PUSH
57507: EMPTY
57508: LIST
57509: LIST
57510: PUSH
57511: LD_INT 24
57513: PUSH
57514: LD_INT 251
57516: PUSH
57517: EMPTY
57518: LIST
57519: LIST
57520: PUSH
57521: EMPTY
57522: LIST
57523: LIST
57524: PPUSH
57525: CALL_OW 72
57529: ST_TO_ADDR
// if mc_is_defending [ base ] then
57530: LD_EXP 66
57534: PUSH
57535: LD_VAR 0 1
57539: ARRAY
57540: IFFALSE 58001
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
57542: LD_ADDR_EXP 65
57546: PUSH
57547: LD_EXP 65
57551: PPUSH
57552: LD_VAR 0 1
57556: PPUSH
57557: LD_INT 4
57559: PPUSH
57560: CALL_OW 1
57564: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
57565: LD_ADDR_VAR 0 12
57569: PUSH
57570: LD_EXP 23
57574: PUSH
57575: LD_VAR 0 1
57579: ARRAY
57580: PPUSH
57581: LD_INT 2
57583: PUSH
57584: LD_INT 30
57586: PUSH
57587: LD_INT 4
57589: PUSH
57590: EMPTY
57591: LIST
57592: LIST
57593: PUSH
57594: LD_INT 30
57596: PUSH
57597: LD_INT 5
57599: PUSH
57600: EMPTY
57601: LIST
57602: LIST
57603: PUSH
57604: EMPTY
57605: LIST
57606: LIST
57607: LIST
57608: PPUSH
57609: CALL_OW 72
57613: ST_TO_ADDR
// if not b then
57614: LD_VAR 0 12
57618: NOT
57619: IFFALSE 57623
// exit ;
57621: GO 60689
// p := [ ] ;
57623: LD_ADDR_VAR 0 11
57627: PUSH
57628: EMPTY
57629: ST_TO_ADDR
// if sci >= 2 then
57630: LD_VAR 0 8
57634: PUSH
57635: LD_INT 2
57637: GREATEREQUAL
57638: IFFALSE 57669
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
57640: LD_ADDR_VAR 0 8
57644: PUSH
57645: LD_VAR 0 8
57649: PUSH
57650: LD_INT 1
57652: ARRAY
57653: PUSH
57654: LD_VAR 0 8
57658: PUSH
57659: LD_INT 2
57661: ARRAY
57662: PUSH
57663: EMPTY
57664: LIST
57665: LIST
57666: ST_TO_ADDR
57667: GO 57730
// if sci = 1 then
57669: LD_VAR 0 8
57673: PUSH
57674: LD_INT 1
57676: EQUAL
57677: IFFALSE 57698
// sci := [ sci [ 1 ] ] else
57679: LD_ADDR_VAR 0 8
57683: PUSH
57684: LD_VAR 0 8
57688: PUSH
57689: LD_INT 1
57691: ARRAY
57692: PUSH
57693: EMPTY
57694: LIST
57695: ST_TO_ADDR
57696: GO 57730
// if sci = 0 then
57698: LD_VAR 0 8
57702: PUSH
57703: LD_INT 0
57705: EQUAL
57706: IFFALSE 57730
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
57708: LD_ADDR_VAR 0 11
57712: PUSH
57713: LD_VAR 0 4
57717: PPUSH
57718: LD_INT 4
57720: PPUSH
57721: CALL 46931 0 2
57725: PUSH
57726: LD_INT 1
57728: ARRAY
57729: ST_TO_ADDR
// if eng > 4 then
57730: LD_VAR 0 6
57734: PUSH
57735: LD_INT 4
57737: GREATER
57738: IFFALSE 57784
// for i = eng downto 4 do
57740: LD_ADDR_VAR 0 3
57744: PUSH
57745: DOUBLE
57746: LD_VAR 0 6
57750: INC
57751: ST_TO_ADDR
57752: LD_INT 4
57754: PUSH
57755: FOR_DOWNTO
57756: IFFALSE 57782
// eng := eng diff eng [ i ] ;
57758: LD_ADDR_VAR 0 6
57762: PUSH
57763: LD_VAR 0 6
57767: PUSH
57768: LD_VAR 0 6
57772: PUSH
57773: LD_VAR 0 3
57777: ARRAY
57778: DIFF
57779: ST_TO_ADDR
57780: GO 57755
57782: POP
57783: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
57784: LD_ADDR_VAR 0 4
57788: PUSH
57789: LD_VAR 0 4
57793: PUSH
57794: LD_VAR 0 5
57798: PUSH
57799: LD_VAR 0 6
57803: UNION
57804: PUSH
57805: LD_VAR 0 7
57809: UNION
57810: PUSH
57811: LD_VAR 0 8
57815: UNION
57816: DIFF
57817: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
57818: LD_ADDR_VAR 0 13
57822: PUSH
57823: LD_EXP 23
57827: PUSH
57828: LD_VAR 0 1
57832: ARRAY
57833: PPUSH
57834: LD_INT 2
57836: PUSH
57837: LD_INT 30
57839: PUSH
57840: LD_INT 32
57842: PUSH
57843: EMPTY
57844: LIST
57845: LIST
57846: PUSH
57847: LD_INT 30
57849: PUSH
57850: LD_INT 31
57852: PUSH
57853: EMPTY
57854: LIST
57855: LIST
57856: PUSH
57857: EMPTY
57858: LIST
57859: LIST
57860: LIST
57861: PPUSH
57862: CALL_OW 72
57866: PUSH
57867: LD_EXP 23
57871: PUSH
57872: LD_VAR 0 1
57876: ARRAY
57877: PPUSH
57878: LD_INT 2
57880: PUSH
57881: LD_INT 30
57883: PUSH
57884: LD_INT 4
57886: PUSH
57887: EMPTY
57888: LIST
57889: LIST
57890: PUSH
57891: LD_INT 30
57893: PUSH
57894: LD_INT 5
57896: PUSH
57897: EMPTY
57898: LIST
57899: LIST
57900: PUSH
57901: EMPTY
57902: LIST
57903: LIST
57904: LIST
57905: PPUSH
57906: CALL_OW 72
57910: PUSH
57911: LD_INT 6
57913: MUL
57914: PLUS
57915: ST_TO_ADDR
// if bcount < tmp then
57916: LD_VAR 0 13
57920: PUSH
57921: LD_VAR 0 4
57925: LESS
57926: IFFALSE 57972
// for i = tmp downto bcount do
57928: LD_ADDR_VAR 0 3
57932: PUSH
57933: DOUBLE
57934: LD_VAR 0 4
57938: INC
57939: ST_TO_ADDR
57940: LD_VAR 0 13
57944: PUSH
57945: FOR_DOWNTO
57946: IFFALSE 57970
// tmp := Delete ( tmp , tmp ) ;
57948: LD_ADDR_VAR 0 4
57952: PUSH
57953: LD_VAR 0 4
57957: PPUSH
57958: LD_VAR 0 4
57962: PPUSH
57963: CALL_OW 3
57967: ST_TO_ADDR
57968: GO 57945
57970: POP
57971: POP
// result := [ tmp , 0 , 0 , p ] ;
57972: LD_ADDR_VAR 0 2
57976: PUSH
57977: LD_VAR 0 4
57981: PUSH
57982: LD_INT 0
57984: PUSH
57985: LD_INT 0
57987: PUSH
57988: LD_VAR 0 11
57992: PUSH
57993: EMPTY
57994: LIST
57995: LIST
57996: LIST
57997: LIST
57998: ST_TO_ADDR
// exit ;
57999: GO 60689
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
58001: LD_EXP 23
58005: PUSH
58006: LD_VAR 0 1
58010: ARRAY
58011: PPUSH
58012: LD_INT 2
58014: PUSH
58015: LD_INT 30
58017: PUSH
58018: LD_INT 6
58020: PUSH
58021: EMPTY
58022: LIST
58023: LIST
58024: PUSH
58025: LD_INT 30
58027: PUSH
58028: LD_INT 7
58030: PUSH
58031: EMPTY
58032: LIST
58033: LIST
58034: PUSH
58035: LD_INT 30
58037: PUSH
58038: LD_INT 8
58040: PUSH
58041: EMPTY
58042: LIST
58043: LIST
58044: PUSH
58045: EMPTY
58046: LIST
58047: LIST
58048: LIST
58049: LIST
58050: PPUSH
58051: CALL_OW 72
58055: NOT
58056: PUSH
58057: LD_EXP 23
58061: PUSH
58062: LD_VAR 0 1
58066: ARRAY
58067: PPUSH
58068: LD_INT 30
58070: PUSH
58071: LD_INT 3
58073: PUSH
58074: EMPTY
58075: LIST
58076: LIST
58077: PPUSH
58078: CALL_OW 72
58082: NOT
58083: AND
58084: IFFALSE 58156
// begin if eng = tmp then
58086: LD_VAR 0 6
58090: PUSH
58091: LD_VAR 0 4
58095: EQUAL
58096: IFFALSE 58100
// exit ;
58098: GO 60689
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
58100: LD_ADDR_EXP 65
58104: PUSH
58105: LD_EXP 65
58109: PPUSH
58110: LD_VAR 0 1
58114: PPUSH
58115: LD_INT 1
58117: PPUSH
58118: CALL_OW 1
58122: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
58123: LD_ADDR_VAR 0 2
58127: PUSH
58128: LD_INT 0
58130: PUSH
58131: LD_VAR 0 4
58135: PUSH
58136: LD_VAR 0 6
58140: DIFF
58141: PUSH
58142: LD_INT 0
58144: PUSH
58145: LD_INT 0
58147: PUSH
58148: EMPTY
58149: LIST
58150: LIST
58151: LIST
58152: LIST
58153: ST_TO_ADDR
// exit ;
58154: GO 60689
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
58156: LD_EXP 50
58160: PUSH
58161: LD_EXP 49
58165: PUSH
58166: LD_VAR 0 1
58170: ARRAY
58171: ARRAY
58172: PUSH
58173: LD_EXP 23
58177: PUSH
58178: LD_VAR 0 1
58182: ARRAY
58183: PPUSH
58184: LD_INT 2
58186: PUSH
58187: LD_INT 30
58189: PUSH
58190: LD_INT 6
58192: PUSH
58193: EMPTY
58194: LIST
58195: LIST
58196: PUSH
58197: LD_INT 30
58199: PUSH
58200: LD_INT 7
58202: PUSH
58203: EMPTY
58204: LIST
58205: LIST
58206: PUSH
58207: LD_INT 30
58209: PUSH
58210: LD_INT 8
58212: PUSH
58213: EMPTY
58214: LIST
58215: LIST
58216: PUSH
58217: EMPTY
58218: LIST
58219: LIST
58220: LIST
58221: LIST
58222: PPUSH
58223: CALL_OW 72
58227: AND
58228: PUSH
58229: LD_EXP 23
58233: PUSH
58234: LD_VAR 0 1
58238: ARRAY
58239: PPUSH
58240: LD_INT 30
58242: PUSH
58243: LD_INT 3
58245: PUSH
58246: EMPTY
58247: LIST
58248: LIST
58249: PPUSH
58250: CALL_OW 72
58254: NOT
58255: AND
58256: IFFALSE 58470
// begin if sci >= 6 then
58258: LD_VAR 0 8
58262: PUSH
58263: LD_INT 6
58265: GREATEREQUAL
58266: IFFALSE 58270
// exit ;
58268: GO 60689
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
58270: LD_ADDR_EXP 65
58274: PUSH
58275: LD_EXP 65
58279: PPUSH
58280: LD_VAR 0 1
58284: PPUSH
58285: LD_INT 2
58287: PPUSH
58288: CALL_OW 1
58292: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
58293: LD_ADDR_VAR 0 9
58297: PUSH
58298: LD_VAR 0 4
58302: PUSH
58303: LD_VAR 0 8
58307: DIFF
58308: PPUSH
58309: LD_INT 4
58311: PPUSH
58312: CALL 46931 0 2
58316: ST_TO_ADDR
// p := [ ] ;
58317: LD_ADDR_VAR 0 11
58321: PUSH
58322: EMPTY
58323: ST_TO_ADDR
// if sci < 6 and sort > 6 then
58324: LD_VAR 0 8
58328: PUSH
58329: LD_INT 6
58331: LESS
58332: PUSH
58333: LD_VAR 0 9
58337: PUSH
58338: LD_INT 6
58340: GREATER
58341: AND
58342: IFFALSE 58423
// begin for i = 1 to 6 - sci do
58344: LD_ADDR_VAR 0 3
58348: PUSH
58349: DOUBLE
58350: LD_INT 1
58352: DEC
58353: ST_TO_ADDR
58354: LD_INT 6
58356: PUSH
58357: LD_VAR 0 8
58361: MINUS
58362: PUSH
58363: FOR_TO
58364: IFFALSE 58419
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
58366: LD_ADDR_VAR 0 11
58370: PUSH
58371: LD_VAR 0 11
58375: PPUSH
58376: LD_VAR 0 11
58380: PUSH
58381: LD_INT 1
58383: PLUS
58384: PPUSH
58385: LD_VAR 0 9
58389: PUSH
58390: LD_INT 1
58392: ARRAY
58393: PPUSH
58394: CALL_OW 2
58398: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
58399: LD_ADDR_VAR 0 9
58403: PUSH
58404: LD_VAR 0 9
58408: PPUSH
58409: LD_INT 1
58411: PPUSH
58412: CALL_OW 3
58416: ST_TO_ADDR
// end ;
58417: GO 58363
58419: POP
58420: POP
// end else
58421: GO 58443
// if sort then
58423: LD_VAR 0 9
58427: IFFALSE 58443
// p := sort [ 1 ] ;
58429: LD_ADDR_VAR 0 11
58433: PUSH
58434: LD_VAR 0 9
58438: PUSH
58439: LD_INT 1
58441: ARRAY
58442: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
58443: LD_ADDR_VAR 0 2
58447: PUSH
58448: LD_INT 0
58450: PUSH
58451: LD_INT 0
58453: PUSH
58454: LD_INT 0
58456: PUSH
58457: LD_VAR 0 11
58461: PUSH
58462: EMPTY
58463: LIST
58464: LIST
58465: LIST
58466: LIST
58467: ST_TO_ADDR
// exit ;
58468: GO 60689
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
58470: LD_EXP 50
58474: PUSH
58475: LD_EXP 49
58479: PUSH
58480: LD_VAR 0 1
58484: ARRAY
58485: ARRAY
58486: PUSH
58487: LD_EXP 23
58491: PUSH
58492: LD_VAR 0 1
58496: ARRAY
58497: PPUSH
58498: LD_INT 2
58500: PUSH
58501: LD_INT 30
58503: PUSH
58504: LD_INT 6
58506: PUSH
58507: EMPTY
58508: LIST
58509: LIST
58510: PUSH
58511: LD_INT 30
58513: PUSH
58514: LD_INT 7
58516: PUSH
58517: EMPTY
58518: LIST
58519: LIST
58520: PUSH
58521: LD_INT 30
58523: PUSH
58524: LD_INT 8
58526: PUSH
58527: EMPTY
58528: LIST
58529: LIST
58530: PUSH
58531: EMPTY
58532: LIST
58533: LIST
58534: LIST
58535: LIST
58536: PPUSH
58537: CALL_OW 72
58541: AND
58542: PUSH
58543: LD_EXP 23
58547: PUSH
58548: LD_VAR 0 1
58552: ARRAY
58553: PPUSH
58554: LD_INT 30
58556: PUSH
58557: LD_INT 3
58559: PUSH
58560: EMPTY
58561: LIST
58562: LIST
58563: PPUSH
58564: CALL_OW 72
58568: AND
58569: IFFALSE 59303
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
58571: LD_ADDR_EXP 65
58575: PUSH
58576: LD_EXP 65
58580: PPUSH
58581: LD_VAR 0 1
58585: PPUSH
58586: LD_INT 3
58588: PPUSH
58589: CALL_OW 1
58593: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58594: LD_ADDR_VAR 0 2
58598: PUSH
58599: LD_INT 0
58601: PUSH
58602: LD_INT 0
58604: PUSH
58605: LD_INT 0
58607: PUSH
58608: LD_INT 0
58610: PUSH
58611: EMPTY
58612: LIST
58613: LIST
58614: LIST
58615: LIST
58616: ST_TO_ADDR
// if not eng then
58617: LD_VAR 0 6
58621: NOT
58622: IFFALSE 58685
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
58624: LD_ADDR_VAR 0 11
58628: PUSH
58629: LD_VAR 0 4
58633: PPUSH
58634: LD_INT 2
58636: PPUSH
58637: CALL 46931 0 2
58641: PUSH
58642: LD_INT 1
58644: ARRAY
58645: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
58646: LD_ADDR_VAR 0 2
58650: PUSH
58651: LD_VAR 0 2
58655: PPUSH
58656: LD_INT 2
58658: PPUSH
58659: LD_VAR 0 11
58663: PPUSH
58664: CALL_OW 1
58668: ST_TO_ADDR
// tmp := tmp diff p ;
58669: LD_ADDR_VAR 0 4
58673: PUSH
58674: LD_VAR 0 4
58678: PUSH
58679: LD_VAR 0 11
58683: DIFF
58684: ST_TO_ADDR
// end ; if tmp and sci < 6 then
58685: LD_VAR 0 4
58689: PUSH
58690: LD_VAR 0 8
58694: PUSH
58695: LD_INT 6
58697: LESS
58698: AND
58699: IFFALSE 58887
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
58701: LD_ADDR_VAR 0 9
58705: PUSH
58706: LD_VAR 0 4
58710: PUSH
58711: LD_VAR 0 8
58715: PUSH
58716: LD_VAR 0 7
58720: UNION
58721: DIFF
58722: PPUSH
58723: LD_INT 4
58725: PPUSH
58726: CALL 46931 0 2
58730: ST_TO_ADDR
// p := [ ] ;
58731: LD_ADDR_VAR 0 11
58735: PUSH
58736: EMPTY
58737: ST_TO_ADDR
// if sort then
58738: LD_VAR 0 9
58742: IFFALSE 58858
// for i = 1 to 6 - sci do
58744: LD_ADDR_VAR 0 3
58748: PUSH
58749: DOUBLE
58750: LD_INT 1
58752: DEC
58753: ST_TO_ADDR
58754: LD_INT 6
58756: PUSH
58757: LD_VAR 0 8
58761: MINUS
58762: PUSH
58763: FOR_TO
58764: IFFALSE 58856
// begin if i = sort then
58766: LD_VAR 0 3
58770: PUSH
58771: LD_VAR 0 9
58775: EQUAL
58776: IFFALSE 58780
// break ;
58778: GO 58856
// if GetClass ( i ) = 4 then
58780: LD_VAR 0 3
58784: PPUSH
58785: CALL_OW 257
58789: PUSH
58790: LD_INT 4
58792: EQUAL
58793: IFFALSE 58797
// continue ;
58795: GO 58763
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58797: LD_ADDR_VAR 0 11
58801: PUSH
58802: LD_VAR 0 11
58806: PPUSH
58807: LD_VAR 0 11
58811: PUSH
58812: LD_INT 1
58814: PLUS
58815: PPUSH
58816: LD_VAR 0 9
58820: PUSH
58821: LD_VAR 0 3
58825: ARRAY
58826: PPUSH
58827: CALL_OW 2
58831: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58832: LD_ADDR_VAR 0 4
58836: PUSH
58837: LD_VAR 0 4
58841: PUSH
58842: LD_VAR 0 9
58846: PUSH
58847: LD_VAR 0 3
58851: ARRAY
58852: DIFF
58853: ST_TO_ADDR
// end ;
58854: GO 58763
58856: POP
58857: POP
// if p then
58858: LD_VAR 0 11
58862: IFFALSE 58887
// result := Replace ( result , 4 , p ) ;
58864: LD_ADDR_VAR 0 2
58868: PUSH
58869: LD_VAR 0 2
58873: PPUSH
58874: LD_INT 4
58876: PPUSH
58877: LD_VAR 0 11
58881: PPUSH
58882: CALL_OW 1
58886: ST_TO_ADDR
// end ; if tmp and mech < 6 then
58887: LD_VAR 0 4
58891: PUSH
58892: LD_VAR 0 7
58896: PUSH
58897: LD_INT 6
58899: LESS
58900: AND
58901: IFFALSE 59089
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
58903: LD_ADDR_VAR 0 9
58907: PUSH
58908: LD_VAR 0 4
58912: PUSH
58913: LD_VAR 0 8
58917: PUSH
58918: LD_VAR 0 7
58922: UNION
58923: DIFF
58924: PPUSH
58925: LD_INT 3
58927: PPUSH
58928: CALL 46931 0 2
58932: ST_TO_ADDR
// p := [ ] ;
58933: LD_ADDR_VAR 0 11
58937: PUSH
58938: EMPTY
58939: ST_TO_ADDR
// if sort then
58940: LD_VAR 0 9
58944: IFFALSE 59060
// for i = 1 to 6 - mech do
58946: LD_ADDR_VAR 0 3
58950: PUSH
58951: DOUBLE
58952: LD_INT 1
58954: DEC
58955: ST_TO_ADDR
58956: LD_INT 6
58958: PUSH
58959: LD_VAR 0 7
58963: MINUS
58964: PUSH
58965: FOR_TO
58966: IFFALSE 59058
// begin if i = sort then
58968: LD_VAR 0 3
58972: PUSH
58973: LD_VAR 0 9
58977: EQUAL
58978: IFFALSE 58982
// break ;
58980: GO 59058
// if GetClass ( i ) = 3 then
58982: LD_VAR 0 3
58986: PPUSH
58987: CALL_OW 257
58991: PUSH
58992: LD_INT 3
58994: EQUAL
58995: IFFALSE 58999
// continue ;
58997: GO 58965
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58999: LD_ADDR_VAR 0 11
59003: PUSH
59004: LD_VAR 0 11
59008: PPUSH
59009: LD_VAR 0 11
59013: PUSH
59014: LD_INT 1
59016: PLUS
59017: PPUSH
59018: LD_VAR 0 9
59022: PUSH
59023: LD_VAR 0 3
59027: ARRAY
59028: PPUSH
59029: CALL_OW 2
59033: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59034: LD_ADDR_VAR 0 4
59038: PUSH
59039: LD_VAR 0 4
59043: PUSH
59044: LD_VAR 0 9
59048: PUSH
59049: LD_VAR 0 3
59053: ARRAY
59054: DIFF
59055: ST_TO_ADDR
// end ;
59056: GO 58965
59058: POP
59059: POP
// if p then
59060: LD_VAR 0 11
59064: IFFALSE 59089
// result := Replace ( result , 3 , p ) ;
59066: LD_ADDR_VAR 0 2
59070: PUSH
59071: LD_VAR 0 2
59075: PPUSH
59076: LD_INT 3
59078: PPUSH
59079: LD_VAR 0 11
59083: PPUSH
59084: CALL_OW 1
59088: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
59089: LD_VAR 0 4
59093: PUSH
59094: LD_INT 6
59096: GREATER
59097: PUSH
59098: LD_VAR 0 6
59102: PUSH
59103: LD_INT 6
59105: LESS
59106: AND
59107: IFFALSE 59301
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
59109: LD_ADDR_VAR 0 9
59113: PUSH
59114: LD_VAR 0 4
59118: PUSH
59119: LD_VAR 0 8
59123: PUSH
59124: LD_VAR 0 7
59128: UNION
59129: PUSH
59130: LD_VAR 0 6
59134: UNION
59135: DIFF
59136: PPUSH
59137: LD_INT 2
59139: PPUSH
59140: CALL 46931 0 2
59144: ST_TO_ADDR
// p := [ ] ;
59145: LD_ADDR_VAR 0 11
59149: PUSH
59150: EMPTY
59151: ST_TO_ADDR
// if sort then
59152: LD_VAR 0 9
59156: IFFALSE 59272
// for i = 1 to 6 - eng do
59158: LD_ADDR_VAR 0 3
59162: PUSH
59163: DOUBLE
59164: LD_INT 1
59166: DEC
59167: ST_TO_ADDR
59168: LD_INT 6
59170: PUSH
59171: LD_VAR 0 6
59175: MINUS
59176: PUSH
59177: FOR_TO
59178: IFFALSE 59270
// begin if i = sort then
59180: LD_VAR 0 3
59184: PUSH
59185: LD_VAR 0 9
59189: EQUAL
59190: IFFALSE 59194
// break ;
59192: GO 59270
// if GetClass ( i ) = 2 then
59194: LD_VAR 0 3
59198: PPUSH
59199: CALL_OW 257
59203: PUSH
59204: LD_INT 2
59206: EQUAL
59207: IFFALSE 59211
// continue ;
59209: GO 59177
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59211: LD_ADDR_VAR 0 11
59215: PUSH
59216: LD_VAR 0 11
59220: PPUSH
59221: LD_VAR 0 11
59225: PUSH
59226: LD_INT 1
59228: PLUS
59229: PPUSH
59230: LD_VAR 0 9
59234: PUSH
59235: LD_VAR 0 3
59239: ARRAY
59240: PPUSH
59241: CALL_OW 2
59245: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59246: LD_ADDR_VAR 0 4
59250: PUSH
59251: LD_VAR 0 4
59255: PUSH
59256: LD_VAR 0 9
59260: PUSH
59261: LD_VAR 0 3
59265: ARRAY
59266: DIFF
59267: ST_TO_ADDR
// end ;
59268: GO 59177
59270: POP
59271: POP
// if p then
59272: LD_VAR 0 11
59276: IFFALSE 59301
// result := Replace ( result , 2 , p ) ;
59278: LD_ADDR_VAR 0 2
59282: PUSH
59283: LD_VAR 0 2
59287: PPUSH
59288: LD_INT 2
59290: PPUSH
59291: LD_VAR 0 11
59295: PPUSH
59296: CALL_OW 1
59300: ST_TO_ADDR
// end ; exit ;
59301: GO 60689
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
59303: LD_EXP 50
59307: PUSH
59308: LD_EXP 49
59312: PUSH
59313: LD_VAR 0 1
59317: ARRAY
59318: ARRAY
59319: NOT
59320: PUSH
59321: LD_EXP 23
59325: PUSH
59326: LD_VAR 0 1
59330: ARRAY
59331: PPUSH
59332: LD_INT 30
59334: PUSH
59335: LD_INT 3
59337: PUSH
59338: EMPTY
59339: LIST
59340: LIST
59341: PPUSH
59342: CALL_OW 72
59346: AND
59347: PUSH
59348: LD_EXP 28
59352: PUSH
59353: LD_VAR 0 1
59357: ARRAY
59358: AND
59359: IFFALSE 59967
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
59361: LD_ADDR_EXP 65
59365: PUSH
59366: LD_EXP 65
59370: PPUSH
59371: LD_VAR 0 1
59375: PPUSH
59376: LD_INT 5
59378: PPUSH
59379: CALL_OW 1
59383: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
59384: LD_ADDR_VAR 0 2
59388: PUSH
59389: LD_INT 0
59391: PUSH
59392: LD_INT 0
59394: PUSH
59395: LD_INT 0
59397: PUSH
59398: LD_INT 0
59400: PUSH
59401: EMPTY
59402: LIST
59403: LIST
59404: LIST
59405: LIST
59406: ST_TO_ADDR
// if sci > 1 then
59407: LD_VAR 0 8
59411: PUSH
59412: LD_INT 1
59414: GREATER
59415: IFFALSE 59443
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
59417: LD_ADDR_VAR 0 4
59421: PUSH
59422: LD_VAR 0 4
59426: PUSH
59427: LD_VAR 0 8
59431: PUSH
59432: LD_VAR 0 8
59436: PUSH
59437: LD_INT 1
59439: ARRAY
59440: DIFF
59441: DIFF
59442: ST_TO_ADDR
// if tmp and not sci then
59443: LD_VAR 0 4
59447: PUSH
59448: LD_VAR 0 8
59452: NOT
59453: AND
59454: IFFALSE 59523
// begin sort := SortBySkill ( tmp , 4 ) ;
59456: LD_ADDR_VAR 0 9
59460: PUSH
59461: LD_VAR 0 4
59465: PPUSH
59466: LD_INT 4
59468: PPUSH
59469: CALL 46931 0 2
59473: ST_TO_ADDR
// if sort then
59474: LD_VAR 0 9
59478: IFFALSE 59494
// p := sort [ 1 ] ;
59480: LD_ADDR_VAR 0 11
59484: PUSH
59485: LD_VAR 0 9
59489: PUSH
59490: LD_INT 1
59492: ARRAY
59493: ST_TO_ADDR
// if p then
59494: LD_VAR 0 11
59498: IFFALSE 59523
// result := Replace ( result , 4 , p ) ;
59500: LD_ADDR_VAR 0 2
59504: PUSH
59505: LD_VAR 0 2
59509: PPUSH
59510: LD_INT 4
59512: PPUSH
59513: LD_VAR 0 11
59517: PPUSH
59518: CALL_OW 1
59522: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
59523: LD_ADDR_VAR 0 4
59527: PUSH
59528: LD_VAR 0 4
59532: PUSH
59533: LD_VAR 0 7
59537: DIFF
59538: ST_TO_ADDR
// if tmp and mech < 6 then
59539: LD_VAR 0 4
59543: PUSH
59544: LD_VAR 0 7
59548: PUSH
59549: LD_INT 6
59551: LESS
59552: AND
59553: IFFALSE 59741
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
59555: LD_ADDR_VAR 0 9
59559: PUSH
59560: LD_VAR 0 4
59564: PUSH
59565: LD_VAR 0 8
59569: PUSH
59570: LD_VAR 0 7
59574: UNION
59575: DIFF
59576: PPUSH
59577: LD_INT 3
59579: PPUSH
59580: CALL 46931 0 2
59584: ST_TO_ADDR
// p := [ ] ;
59585: LD_ADDR_VAR 0 11
59589: PUSH
59590: EMPTY
59591: ST_TO_ADDR
// if sort then
59592: LD_VAR 0 9
59596: IFFALSE 59712
// for i = 1 to 6 - mech do
59598: LD_ADDR_VAR 0 3
59602: PUSH
59603: DOUBLE
59604: LD_INT 1
59606: DEC
59607: ST_TO_ADDR
59608: LD_INT 6
59610: PUSH
59611: LD_VAR 0 7
59615: MINUS
59616: PUSH
59617: FOR_TO
59618: IFFALSE 59710
// begin if i = sort then
59620: LD_VAR 0 3
59624: PUSH
59625: LD_VAR 0 9
59629: EQUAL
59630: IFFALSE 59634
// break ;
59632: GO 59710
// if GetClass ( i ) = 3 then
59634: LD_VAR 0 3
59638: PPUSH
59639: CALL_OW 257
59643: PUSH
59644: LD_INT 3
59646: EQUAL
59647: IFFALSE 59651
// continue ;
59649: GO 59617
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59651: LD_ADDR_VAR 0 11
59655: PUSH
59656: LD_VAR 0 11
59660: PPUSH
59661: LD_VAR 0 11
59665: PUSH
59666: LD_INT 1
59668: PLUS
59669: PPUSH
59670: LD_VAR 0 9
59674: PUSH
59675: LD_VAR 0 3
59679: ARRAY
59680: PPUSH
59681: CALL_OW 2
59685: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59686: LD_ADDR_VAR 0 4
59690: PUSH
59691: LD_VAR 0 4
59695: PUSH
59696: LD_VAR 0 9
59700: PUSH
59701: LD_VAR 0 3
59705: ARRAY
59706: DIFF
59707: ST_TO_ADDR
// end ;
59708: GO 59617
59710: POP
59711: POP
// if p then
59712: LD_VAR 0 11
59716: IFFALSE 59741
// result := Replace ( result , 3 , p ) ;
59718: LD_ADDR_VAR 0 2
59722: PUSH
59723: LD_VAR 0 2
59727: PPUSH
59728: LD_INT 3
59730: PPUSH
59731: LD_VAR 0 11
59735: PPUSH
59736: CALL_OW 1
59740: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
59741: LD_ADDR_VAR 0 4
59745: PUSH
59746: LD_VAR 0 4
59750: PUSH
59751: LD_VAR 0 6
59755: DIFF
59756: ST_TO_ADDR
// if tmp and eng < 6 then
59757: LD_VAR 0 4
59761: PUSH
59762: LD_VAR 0 6
59766: PUSH
59767: LD_INT 6
59769: LESS
59770: AND
59771: IFFALSE 59965
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
59773: LD_ADDR_VAR 0 9
59777: PUSH
59778: LD_VAR 0 4
59782: PUSH
59783: LD_VAR 0 8
59787: PUSH
59788: LD_VAR 0 7
59792: UNION
59793: PUSH
59794: LD_VAR 0 6
59798: UNION
59799: DIFF
59800: PPUSH
59801: LD_INT 2
59803: PPUSH
59804: CALL 46931 0 2
59808: ST_TO_ADDR
// p := [ ] ;
59809: LD_ADDR_VAR 0 11
59813: PUSH
59814: EMPTY
59815: ST_TO_ADDR
// if sort then
59816: LD_VAR 0 9
59820: IFFALSE 59936
// for i = 1 to 6 - eng do
59822: LD_ADDR_VAR 0 3
59826: PUSH
59827: DOUBLE
59828: LD_INT 1
59830: DEC
59831: ST_TO_ADDR
59832: LD_INT 6
59834: PUSH
59835: LD_VAR 0 6
59839: MINUS
59840: PUSH
59841: FOR_TO
59842: IFFALSE 59934
// begin if i = sort then
59844: LD_VAR 0 3
59848: PUSH
59849: LD_VAR 0 9
59853: EQUAL
59854: IFFALSE 59858
// break ;
59856: GO 59934
// if GetClass ( i ) = 2 then
59858: LD_VAR 0 3
59862: PPUSH
59863: CALL_OW 257
59867: PUSH
59868: LD_INT 2
59870: EQUAL
59871: IFFALSE 59875
// continue ;
59873: GO 59841
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59875: LD_ADDR_VAR 0 11
59879: PUSH
59880: LD_VAR 0 11
59884: PPUSH
59885: LD_VAR 0 11
59889: PUSH
59890: LD_INT 1
59892: PLUS
59893: PPUSH
59894: LD_VAR 0 9
59898: PUSH
59899: LD_VAR 0 3
59903: ARRAY
59904: PPUSH
59905: CALL_OW 2
59909: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59910: LD_ADDR_VAR 0 4
59914: PUSH
59915: LD_VAR 0 4
59919: PUSH
59920: LD_VAR 0 9
59924: PUSH
59925: LD_VAR 0 3
59929: ARRAY
59930: DIFF
59931: ST_TO_ADDR
// end ;
59932: GO 59841
59934: POP
59935: POP
// if p then
59936: LD_VAR 0 11
59940: IFFALSE 59965
// result := Replace ( result , 2 , p ) ;
59942: LD_ADDR_VAR 0 2
59946: PUSH
59947: LD_VAR 0 2
59951: PPUSH
59952: LD_INT 2
59954: PPUSH
59955: LD_VAR 0 11
59959: PPUSH
59960: CALL_OW 1
59964: ST_TO_ADDR
// end ; exit ;
59965: GO 60689
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
59967: LD_EXP 50
59971: PUSH
59972: LD_EXP 49
59976: PUSH
59977: LD_VAR 0 1
59981: ARRAY
59982: ARRAY
59983: NOT
59984: PUSH
59985: LD_EXP 23
59989: PUSH
59990: LD_VAR 0 1
59994: ARRAY
59995: PPUSH
59996: LD_INT 30
59998: PUSH
59999: LD_INT 3
60001: PUSH
60002: EMPTY
60003: LIST
60004: LIST
60005: PPUSH
60006: CALL_OW 72
60010: AND
60011: PUSH
60012: LD_EXP 28
60016: PUSH
60017: LD_VAR 0 1
60021: ARRAY
60022: NOT
60023: AND
60024: IFFALSE 60689
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
60026: LD_ADDR_EXP 65
60030: PUSH
60031: LD_EXP 65
60035: PPUSH
60036: LD_VAR 0 1
60040: PPUSH
60041: LD_INT 6
60043: PPUSH
60044: CALL_OW 1
60048: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
60049: LD_ADDR_VAR 0 2
60053: PUSH
60054: LD_INT 0
60056: PUSH
60057: LD_INT 0
60059: PUSH
60060: LD_INT 0
60062: PUSH
60063: LD_INT 0
60065: PUSH
60066: EMPTY
60067: LIST
60068: LIST
60069: LIST
60070: LIST
60071: ST_TO_ADDR
// if sci >= 1 then
60072: LD_VAR 0 8
60076: PUSH
60077: LD_INT 1
60079: GREATEREQUAL
60080: IFFALSE 60102
// tmp := tmp diff sci [ 1 ] ;
60082: LD_ADDR_VAR 0 4
60086: PUSH
60087: LD_VAR 0 4
60091: PUSH
60092: LD_VAR 0 8
60096: PUSH
60097: LD_INT 1
60099: ARRAY
60100: DIFF
60101: ST_TO_ADDR
// if tmp and not sci then
60102: LD_VAR 0 4
60106: PUSH
60107: LD_VAR 0 8
60111: NOT
60112: AND
60113: IFFALSE 60182
// begin sort := SortBySkill ( tmp , 4 ) ;
60115: LD_ADDR_VAR 0 9
60119: PUSH
60120: LD_VAR 0 4
60124: PPUSH
60125: LD_INT 4
60127: PPUSH
60128: CALL 46931 0 2
60132: ST_TO_ADDR
// if sort then
60133: LD_VAR 0 9
60137: IFFALSE 60153
// p := sort [ 1 ] ;
60139: LD_ADDR_VAR 0 11
60143: PUSH
60144: LD_VAR 0 9
60148: PUSH
60149: LD_INT 1
60151: ARRAY
60152: ST_TO_ADDR
// if p then
60153: LD_VAR 0 11
60157: IFFALSE 60182
// result := Replace ( result , 4 , p ) ;
60159: LD_ADDR_VAR 0 2
60163: PUSH
60164: LD_VAR 0 2
60168: PPUSH
60169: LD_INT 4
60171: PPUSH
60172: LD_VAR 0 11
60176: PPUSH
60177: CALL_OW 1
60181: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
60182: LD_ADDR_VAR 0 4
60186: PUSH
60187: LD_VAR 0 4
60191: PUSH
60192: LD_VAR 0 7
60196: DIFF
60197: ST_TO_ADDR
// if tmp and mech < 6 then
60198: LD_VAR 0 4
60202: PUSH
60203: LD_VAR 0 7
60207: PUSH
60208: LD_INT 6
60210: LESS
60211: AND
60212: IFFALSE 60394
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
60214: LD_ADDR_VAR 0 9
60218: PUSH
60219: LD_VAR 0 4
60223: PUSH
60224: LD_VAR 0 7
60228: DIFF
60229: PPUSH
60230: LD_INT 3
60232: PPUSH
60233: CALL 46931 0 2
60237: ST_TO_ADDR
// p := [ ] ;
60238: LD_ADDR_VAR 0 11
60242: PUSH
60243: EMPTY
60244: ST_TO_ADDR
// if sort then
60245: LD_VAR 0 9
60249: IFFALSE 60365
// for i = 1 to 6 - mech do
60251: LD_ADDR_VAR 0 3
60255: PUSH
60256: DOUBLE
60257: LD_INT 1
60259: DEC
60260: ST_TO_ADDR
60261: LD_INT 6
60263: PUSH
60264: LD_VAR 0 7
60268: MINUS
60269: PUSH
60270: FOR_TO
60271: IFFALSE 60363
// begin if i = sort then
60273: LD_VAR 0 3
60277: PUSH
60278: LD_VAR 0 9
60282: EQUAL
60283: IFFALSE 60287
// break ;
60285: GO 60363
// if GetClass ( i ) = 3 then
60287: LD_VAR 0 3
60291: PPUSH
60292: CALL_OW 257
60296: PUSH
60297: LD_INT 3
60299: EQUAL
60300: IFFALSE 60304
// continue ;
60302: GO 60270
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60304: LD_ADDR_VAR 0 11
60308: PUSH
60309: LD_VAR 0 11
60313: PPUSH
60314: LD_VAR 0 11
60318: PUSH
60319: LD_INT 1
60321: PLUS
60322: PPUSH
60323: LD_VAR 0 9
60327: PUSH
60328: LD_VAR 0 3
60332: ARRAY
60333: PPUSH
60334: CALL_OW 2
60338: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60339: LD_ADDR_VAR 0 4
60343: PUSH
60344: LD_VAR 0 4
60348: PUSH
60349: LD_VAR 0 9
60353: PUSH
60354: LD_VAR 0 3
60358: ARRAY
60359: DIFF
60360: ST_TO_ADDR
// end ;
60361: GO 60270
60363: POP
60364: POP
// if p then
60365: LD_VAR 0 11
60369: IFFALSE 60394
// result := Replace ( result , 3 , p ) ;
60371: LD_ADDR_VAR 0 2
60375: PUSH
60376: LD_VAR 0 2
60380: PPUSH
60381: LD_INT 3
60383: PPUSH
60384: LD_VAR 0 11
60388: PPUSH
60389: CALL_OW 1
60393: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
60394: LD_ADDR_VAR 0 4
60398: PUSH
60399: LD_VAR 0 4
60403: PUSH
60404: LD_VAR 0 6
60408: DIFF
60409: ST_TO_ADDR
// if tmp and eng < 4 then
60410: LD_VAR 0 4
60414: PUSH
60415: LD_VAR 0 6
60419: PUSH
60420: LD_INT 4
60422: LESS
60423: AND
60424: IFFALSE 60614
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
60426: LD_ADDR_VAR 0 9
60430: PUSH
60431: LD_VAR 0 4
60435: PUSH
60436: LD_VAR 0 7
60440: PUSH
60441: LD_VAR 0 6
60445: UNION
60446: DIFF
60447: PPUSH
60448: LD_INT 2
60450: PPUSH
60451: CALL 46931 0 2
60455: ST_TO_ADDR
// p := [ ] ;
60456: LD_ADDR_VAR 0 11
60460: PUSH
60461: EMPTY
60462: ST_TO_ADDR
// if sort then
60463: LD_VAR 0 9
60467: IFFALSE 60583
// for i = 1 to 4 - eng do
60469: LD_ADDR_VAR 0 3
60473: PUSH
60474: DOUBLE
60475: LD_INT 1
60477: DEC
60478: ST_TO_ADDR
60479: LD_INT 4
60481: PUSH
60482: LD_VAR 0 6
60486: MINUS
60487: PUSH
60488: FOR_TO
60489: IFFALSE 60581
// begin if i = sort then
60491: LD_VAR 0 3
60495: PUSH
60496: LD_VAR 0 9
60500: EQUAL
60501: IFFALSE 60505
// break ;
60503: GO 60581
// if GetClass ( i ) = 2 then
60505: LD_VAR 0 3
60509: PPUSH
60510: CALL_OW 257
60514: PUSH
60515: LD_INT 2
60517: EQUAL
60518: IFFALSE 60522
// continue ;
60520: GO 60488
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60522: LD_ADDR_VAR 0 11
60526: PUSH
60527: LD_VAR 0 11
60531: PPUSH
60532: LD_VAR 0 11
60536: PUSH
60537: LD_INT 1
60539: PLUS
60540: PPUSH
60541: LD_VAR 0 9
60545: PUSH
60546: LD_VAR 0 3
60550: ARRAY
60551: PPUSH
60552: CALL_OW 2
60556: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60557: LD_ADDR_VAR 0 4
60561: PUSH
60562: LD_VAR 0 4
60566: PUSH
60567: LD_VAR 0 9
60571: PUSH
60572: LD_VAR 0 3
60576: ARRAY
60577: DIFF
60578: ST_TO_ADDR
// end ;
60579: GO 60488
60581: POP
60582: POP
// if p then
60583: LD_VAR 0 11
60587: IFFALSE 60612
// result := Replace ( result , 2 , p ) ;
60589: LD_ADDR_VAR 0 2
60593: PUSH
60594: LD_VAR 0 2
60598: PPUSH
60599: LD_INT 2
60601: PPUSH
60602: LD_VAR 0 11
60606: PPUSH
60607: CALL_OW 1
60611: ST_TO_ADDR
// end else
60612: GO 60658
// for i = eng downto 5 do
60614: LD_ADDR_VAR 0 3
60618: PUSH
60619: DOUBLE
60620: LD_VAR 0 6
60624: INC
60625: ST_TO_ADDR
60626: LD_INT 5
60628: PUSH
60629: FOR_DOWNTO
60630: IFFALSE 60656
// tmp := tmp union eng [ i ] ;
60632: LD_ADDR_VAR 0 4
60636: PUSH
60637: LD_VAR 0 4
60641: PUSH
60642: LD_VAR 0 6
60646: PUSH
60647: LD_VAR 0 3
60651: ARRAY
60652: UNION
60653: ST_TO_ADDR
60654: GO 60629
60656: POP
60657: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
60658: LD_ADDR_VAR 0 2
60662: PUSH
60663: LD_VAR 0 2
60667: PPUSH
60668: LD_INT 1
60670: PPUSH
60671: LD_VAR 0 4
60675: PUSH
60676: LD_VAR 0 5
60680: DIFF
60681: PPUSH
60682: CALL_OW 1
60686: ST_TO_ADDR
// exit ;
60687: GO 60689
// end ; end ;
60689: LD_VAR 0 2
60693: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
60694: LD_INT 0
60696: PPUSH
60697: PPUSH
60698: PPUSH
// if not mc_bases then
60699: LD_EXP 23
60703: NOT
60704: IFFALSE 60708
// exit ;
60706: GO 60850
// for i = 1 to mc_bases do
60708: LD_ADDR_VAR 0 2
60712: PUSH
60713: DOUBLE
60714: LD_INT 1
60716: DEC
60717: ST_TO_ADDR
60718: LD_EXP 23
60722: PUSH
60723: FOR_TO
60724: IFFALSE 60841
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
60726: LD_ADDR_VAR 0 3
60730: PUSH
60731: LD_EXP 23
60735: PUSH
60736: LD_VAR 0 2
60740: ARRAY
60741: PPUSH
60742: LD_INT 21
60744: PUSH
60745: LD_INT 3
60747: PUSH
60748: EMPTY
60749: LIST
60750: LIST
60751: PUSH
60752: LD_INT 3
60754: PUSH
60755: LD_INT 2
60757: PUSH
60758: LD_INT 30
60760: PUSH
60761: LD_INT 29
60763: PUSH
60764: EMPTY
60765: LIST
60766: LIST
60767: PUSH
60768: LD_INT 30
60770: PUSH
60771: LD_INT 30
60773: PUSH
60774: EMPTY
60775: LIST
60776: LIST
60777: PUSH
60778: EMPTY
60779: LIST
60780: LIST
60781: LIST
60782: PUSH
60783: EMPTY
60784: LIST
60785: LIST
60786: PUSH
60787: LD_INT 3
60789: PUSH
60790: LD_INT 24
60792: PUSH
60793: LD_INT 1000
60795: PUSH
60796: EMPTY
60797: LIST
60798: LIST
60799: PUSH
60800: EMPTY
60801: LIST
60802: LIST
60803: PUSH
60804: EMPTY
60805: LIST
60806: LIST
60807: LIST
60808: PPUSH
60809: CALL_OW 72
60813: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
60814: LD_ADDR_EXP 24
60818: PUSH
60819: LD_EXP 24
60823: PPUSH
60824: LD_VAR 0 2
60828: PPUSH
60829: LD_VAR 0 3
60833: PPUSH
60834: CALL_OW 1
60838: ST_TO_ADDR
// end ;
60839: GO 60723
60841: POP
60842: POP
// RaiseSailEvent ( 101 ) ;
60843: LD_INT 101
60845: PPUSH
60846: CALL_OW 427
// end ;
60850: LD_VAR 0 1
60854: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
60855: LD_INT 0
60857: PPUSH
60858: PPUSH
60859: PPUSH
60860: PPUSH
60861: PPUSH
60862: PPUSH
60863: PPUSH
// if not mc_bases then
60864: LD_EXP 23
60868: NOT
60869: IFFALSE 60873
// exit ;
60871: GO 61435
// for i = 1 to mc_bases do
60873: LD_ADDR_VAR 0 2
60877: PUSH
60878: DOUBLE
60879: LD_INT 1
60881: DEC
60882: ST_TO_ADDR
60883: LD_EXP 23
60887: PUSH
60888: FOR_TO
60889: IFFALSE 61426
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
60891: LD_ADDR_VAR 0 5
60895: PUSH
60896: LD_EXP 23
60900: PUSH
60901: LD_VAR 0 2
60905: ARRAY
60906: PUSH
60907: LD_EXP 52
60911: PUSH
60912: LD_VAR 0 2
60916: ARRAY
60917: UNION
60918: PPUSH
60919: LD_INT 21
60921: PUSH
60922: LD_INT 1
60924: PUSH
60925: EMPTY
60926: LIST
60927: LIST
60928: PUSH
60929: LD_INT 1
60931: PUSH
60932: LD_INT 3
60934: PUSH
60935: LD_INT 54
60937: PUSH
60938: EMPTY
60939: LIST
60940: PUSH
60941: EMPTY
60942: LIST
60943: LIST
60944: PUSH
60945: LD_INT 3
60947: PUSH
60948: LD_INT 24
60950: PUSH
60951: LD_INT 1000
60953: PUSH
60954: EMPTY
60955: LIST
60956: LIST
60957: PUSH
60958: EMPTY
60959: LIST
60960: LIST
60961: PUSH
60962: EMPTY
60963: LIST
60964: LIST
60965: LIST
60966: PUSH
60967: EMPTY
60968: LIST
60969: LIST
60970: PPUSH
60971: CALL_OW 72
60975: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
60976: LD_ADDR_VAR 0 6
60980: PUSH
60981: LD_EXP 23
60985: PUSH
60986: LD_VAR 0 2
60990: ARRAY
60991: PPUSH
60992: LD_INT 21
60994: PUSH
60995: LD_INT 1
60997: PUSH
60998: EMPTY
60999: LIST
61000: LIST
61001: PUSH
61002: LD_INT 1
61004: PUSH
61005: LD_INT 3
61007: PUSH
61008: LD_INT 54
61010: PUSH
61011: EMPTY
61012: LIST
61013: PUSH
61014: EMPTY
61015: LIST
61016: LIST
61017: PUSH
61018: LD_INT 3
61020: PUSH
61021: LD_INT 24
61023: PUSH
61024: LD_INT 250
61026: PUSH
61027: EMPTY
61028: LIST
61029: LIST
61030: PUSH
61031: EMPTY
61032: LIST
61033: LIST
61034: PUSH
61035: EMPTY
61036: LIST
61037: LIST
61038: LIST
61039: PUSH
61040: EMPTY
61041: LIST
61042: LIST
61043: PPUSH
61044: CALL_OW 72
61048: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
61049: LD_ADDR_VAR 0 7
61053: PUSH
61054: LD_VAR 0 5
61058: PUSH
61059: LD_VAR 0 6
61063: DIFF
61064: ST_TO_ADDR
// if not need_heal_1 then
61065: LD_VAR 0 6
61069: NOT
61070: IFFALSE 61103
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
61072: LD_ADDR_EXP 26
61076: PUSH
61077: LD_EXP 26
61081: PPUSH
61082: LD_VAR 0 2
61086: PUSH
61087: LD_INT 1
61089: PUSH
61090: EMPTY
61091: LIST
61092: LIST
61093: PPUSH
61094: EMPTY
61095: PPUSH
61096: CALL 16110 0 3
61100: ST_TO_ADDR
61101: GO 61173
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
61103: LD_ADDR_EXP 26
61107: PUSH
61108: LD_EXP 26
61112: PPUSH
61113: LD_VAR 0 2
61117: PUSH
61118: LD_INT 1
61120: PUSH
61121: EMPTY
61122: LIST
61123: LIST
61124: PPUSH
61125: LD_EXP 26
61129: PUSH
61130: LD_VAR 0 2
61134: ARRAY
61135: PUSH
61136: LD_INT 1
61138: ARRAY
61139: PPUSH
61140: LD_INT 3
61142: PUSH
61143: LD_INT 24
61145: PUSH
61146: LD_INT 1000
61148: PUSH
61149: EMPTY
61150: LIST
61151: LIST
61152: PUSH
61153: EMPTY
61154: LIST
61155: LIST
61156: PPUSH
61157: CALL_OW 72
61161: PUSH
61162: LD_VAR 0 6
61166: UNION
61167: PPUSH
61168: CALL 16110 0 3
61172: ST_TO_ADDR
// if not need_heal_2 then
61173: LD_VAR 0 7
61177: NOT
61178: IFFALSE 61211
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
61180: LD_ADDR_EXP 26
61184: PUSH
61185: LD_EXP 26
61189: PPUSH
61190: LD_VAR 0 2
61194: PUSH
61195: LD_INT 2
61197: PUSH
61198: EMPTY
61199: LIST
61200: LIST
61201: PPUSH
61202: EMPTY
61203: PPUSH
61204: CALL 16110 0 3
61208: ST_TO_ADDR
61209: GO 61243
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
61211: LD_ADDR_EXP 26
61215: PUSH
61216: LD_EXP 26
61220: PPUSH
61221: LD_VAR 0 2
61225: PUSH
61226: LD_INT 2
61228: PUSH
61229: EMPTY
61230: LIST
61231: LIST
61232: PPUSH
61233: LD_VAR 0 7
61237: PPUSH
61238: CALL 16110 0 3
61242: ST_TO_ADDR
// if need_heal_2 then
61243: LD_VAR 0 7
61247: IFFALSE 61408
// for j in need_heal_2 do
61249: LD_ADDR_VAR 0 3
61253: PUSH
61254: LD_VAR 0 7
61258: PUSH
61259: FOR_IN
61260: IFFALSE 61406
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61262: LD_ADDR_VAR 0 5
61266: PUSH
61267: LD_EXP 23
61271: PUSH
61272: LD_VAR 0 2
61276: ARRAY
61277: PPUSH
61278: LD_INT 2
61280: PUSH
61281: LD_INT 30
61283: PUSH
61284: LD_INT 6
61286: PUSH
61287: EMPTY
61288: LIST
61289: LIST
61290: PUSH
61291: LD_INT 30
61293: PUSH
61294: LD_INT 7
61296: PUSH
61297: EMPTY
61298: LIST
61299: LIST
61300: PUSH
61301: LD_INT 30
61303: PUSH
61304: LD_INT 8
61306: PUSH
61307: EMPTY
61308: LIST
61309: LIST
61310: PUSH
61311: LD_INT 30
61313: PUSH
61314: LD_INT 0
61316: PUSH
61317: EMPTY
61318: LIST
61319: LIST
61320: PUSH
61321: LD_INT 30
61323: PUSH
61324: LD_INT 1
61326: PUSH
61327: EMPTY
61328: LIST
61329: LIST
61330: PUSH
61331: EMPTY
61332: LIST
61333: LIST
61334: LIST
61335: LIST
61336: LIST
61337: LIST
61338: PPUSH
61339: CALL_OW 72
61343: ST_TO_ADDR
// if tmp then
61344: LD_VAR 0 5
61348: IFFALSE 61404
// begin k := NearestUnitToUnit ( tmp , j ) ;
61350: LD_ADDR_VAR 0 4
61354: PUSH
61355: LD_VAR 0 5
61359: PPUSH
61360: LD_VAR 0 3
61364: PPUSH
61365: CALL_OW 74
61369: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
61370: LD_VAR 0 3
61374: PPUSH
61375: LD_VAR 0 4
61379: PPUSH
61380: CALL_OW 296
61384: PUSH
61385: LD_INT 5
61387: GREATER
61388: IFFALSE 61404
// ComMoveToNearbyEntrance ( j , k ) ;
61390: LD_VAR 0 3
61394: PPUSH
61395: LD_VAR 0 4
61399: PPUSH
61400: CALL 49290 0 2
// end ; end ;
61404: GO 61259
61406: POP
61407: POP
// if not need_heal_1 and not need_heal_2 then
61408: LD_VAR 0 6
61412: NOT
61413: PUSH
61414: LD_VAR 0 7
61418: NOT
61419: AND
61420: IFFALSE 61424
// continue ;
61422: GO 60888
// end ;
61424: GO 60888
61426: POP
61427: POP
// RaiseSailEvent ( 102 ) ;
61428: LD_INT 102
61430: PPUSH
61431: CALL_OW 427
// end ;
61435: LD_VAR 0 1
61439: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
61440: LD_INT 0
61442: PPUSH
61443: PPUSH
61444: PPUSH
61445: PPUSH
61446: PPUSH
61447: PPUSH
61448: PPUSH
61449: PPUSH
// if not mc_bases then
61450: LD_EXP 23
61454: NOT
61455: IFFALSE 61459
// exit ;
61457: GO 62370
// for i = 1 to mc_bases do
61459: LD_ADDR_VAR 0 2
61463: PUSH
61464: DOUBLE
61465: LD_INT 1
61467: DEC
61468: ST_TO_ADDR
61469: LD_EXP 23
61473: PUSH
61474: FOR_TO
61475: IFFALSE 62368
// begin if not mc_building_need_repair [ i ] then
61477: LD_EXP 24
61481: PUSH
61482: LD_VAR 0 2
61486: ARRAY
61487: NOT
61488: IFFALSE 61673
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
61490: LD_ADDR_VAR 0 6
61494: PUSH
61495: LD_EXP 42
61499: PUSH
61500: LD_VAR 0 2
61504: ARRAY
61505: PPUSH
61506: LD_INT 3
61508: PUSH
61509: LD_INT 24
61511: PUSH
61512: LD_INT 1000
61514: PUSH
61515: EMPTY
61516: LIST
61517: LIST
61518: PUSH
61519: EMPTY
61520: LIST
61521: LIST
61522: PUSH
61523: LD_INT 2
61525: PUSH
61526: LD_INT 34
61528: PUSH
61529: LD_INT 13
61531: PUSH
61532: EMPTY
61533: LIST
61534: LIST
61535: PUSH
61536: LD_INT 34
61538: PUSH
61539: LD_INT 52
61541: PUSH
61542: EMPTY
61543: LIST
61544: LIST
61545: PUSH
61546: LD_INT 34
61548: PUSH
61549: LD_INT 88
61551: PUSH
61552: EMPTY
61553: LIST
61554: LIST
61555: PUSH
61556: EMPTY
61557: LIST
61558: LIST
61559: LIST
61560: LIST
61561: PUSH
61562: EMPTY
61563: LIST
61564: LIST
61565: PPUSH
61566: CALL_OW 72
61570: ST_TO_ADDR
// if cranes then
61571: LD_VAR 0 6
61575: IFFALSE 61637
// for j in cranes do
61577: LD_ADDR_VAR 0 3
61581: PUSH
61582: LD_VAR 0 6
61586: PUSH
61587: FOR_IN
61588: IFFALSE 61635
// if not IsInArea ( j , mc_parking [ i ] ) then
61590: LD_VAR 0 3
61594: PPUSH
61595: LD_EXP 47
61599: PUSH
61600: LD_VAR 0 2
61604: ARRAY
61605: PPUSH
61606: CALL_OW 308
61610: NOT
61611: IFFALSE 61633
// ComMoveToArea ( j , mc_parking [ i ] ) ;
61613: LD_VAR 0 3
61617: PPUSH
61618: LD_EXP 47
61622: PUSH
61623: LD_VAR 0 2
61627: ARRAY
61628: PPUSH
61629: CALL_OW 113
61633: GO 61587
61635: POP
61636: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
61637: LD_ADDR_EXP 25
61641: PUSH
61642: LD_EXP 25
61646: PPUSH
61647: LD_VAR 0 2
61651: PPUSH
61652: EMPTY
61653: PPUSH
61654: CALL_OW 1
61658: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
61659: LD_VAR 0 2
61663: PPUSH
61664: LD_INT 101
61666: PPUSH
61667: CALL 56527 0 2
// continue ;
61671: GO 61474
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
61673: LD_ADDR_EXP 29
61677: PUSH
61678: LD_EXP 29
61682: PPUSH
61683: LD_VAR 0 2
61687: PPUSH
61688: EMPTY
61689: PPUSH
61690: CALL_OW 1
61694: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
61695: LD_VAR 0 2
61699: PPUSH
61700: LD_INT 103
61702: PPUSH
61703: CALL 56527 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
61707: LD_ADDR_VAR 0 5
61711: PUSH
61712: LD_EXP 23
61716: PUSH
61717: LD_VAR 0 2
61721: ARRAY
61722: PUSH
61723: LD_EXP 52
61727: PUSH
61728: LD_VAR 0 2
61732: ARRAY
61733: UNION
61734: PPUSH
61735: LD_INT 2
61737: PUSH
61738: LD_INT 25
61740: PUSH
61741: LD_INT 2
61743: PUSH
61744: EMPTY
61745: LIST
61746: LIST
61747: PUSH
61748: LD_INT 25
61750: PUSH
61751: LD_INT 16
61753: PUSH
61754: EMPTY
61755: LIST
61756: LIST
61757: PUSH
61758: EMPTY
61759: LIST
61760: LIST
61761: LIST
61762: PUSH
61763: EMPTY
61764: LIST
61765: PPUSH
61766: CALL_OW 72
61770: ST_TO_ADDR
// if mc_need_heal [ i ] then
61771: LD_EXP 26
61775: PUSH
61776: LD_VAR 0 2
61780: ARRAY
61781: IFFALSE 61825
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
61783: LD_ADDR_VAR 0 5
61787: PUSH
61788: LD_VAR 0 5
61792: PUSH
61793: LD_EXP 26
61797: PUSH
61798: LD_VAR 0 2
61802: ARRAY
61803: PUSH
61804: LD_INT 1
61806: ARRAY
61807: PUSH
61808: LD_EXP 26
61812: PUSH
61813: LD_VAR 0 2
61817: ARRAY
61818: PUSH
61819: LD_INT 2
61821: ARRAY
61822: UNION
61823: DIFF
61824: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
61825: LD_ADDR_VAR 0 6
61829: PUSH
61830: LD_EXP 42
61834: PUSH
61835: LD_VAR 0 2
61839: ARRAY
61840: PPUSH
61841: LD_INT 2
61843: PUSH
61844: LD_INT 34
61846: PUSH
61847: LD_INT 13
61849: PUSH
61850: EMPTY
61851: LIST
61852: LIST
61853: PUSH
61854: LD_INT 34
61856: PUSH
61857: LD_INT 52
61859: PUSH
61860: EMPTY
61861: LIST
61862: LIST
61863: PUSH
61864: LD_INT 34
61866: PUSH
61867: LD_INT 88
61869: PUSH
61870: EMPTY
61871: LIST
61872: LIST
61873: PUSH
61874: EMPTY
61875: LIST
61876: LIST
61877: LIST
61878: LIST
61879: PPUSH
61880: CALL_OW 72
61884: ST_TO_ADDR
// if cranes then
61885: LD_VAR 0 6
61889: IFFALSE 62057
// begin for j in cranes do
61891: LD_ADDR_VAR 0 3
61895: PUSH
61896: LD_VAR 0 6
61900: PUSH
61901: FOR_IN
61902: IFFALSE 62055
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
61904: LD_VAR 0 3
61908: PPUSH
61909: CALL_OW 256
61913: PUSH
61914: LD_INT 1000
61916: EQUAL
61917: PUSH
61918: LD_VAR 0 3
61922: PPUSH
61923: CALL_OW 314
61927: NOT
61928: AND
61929: IFFALSE 61995
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
61931: LD_ADDR_VAR 0 8
61935: PUSH
61936: LD_EXP 24
61940: PUSH
61941: LD_VAR 0 2
61945: ARRAY
61946: PPUSH
61947: LD_VAR 0 3
61951: PPUSH
61952: CALL_OW 74
61956: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
61957: LD_VAR 0 8
61961: PPUSH
61962: LD_INT 16
61964: PPUSH
61965: CALL 18707 0 2
61969: PUSH
61970: LD_INT 4
61972: ARRAY
61973: PUSH
61974: LD_INT 10
61976: LESS
61977: IFFALSE 61993
// ComRepairBuilding ( j , to_repair ) ;
61979: LD_VAR 0 3
61983: PPUSH
61984: LD_VAR 0 8
61988: PPUSH
61989: CALL_OW 130
// end else
61993: GO 62053
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
61995: LD_VAR 0 3
61999: PPUSH
62000: CALL_OW 256
62004: PUSH
62005: LD_INT 500
62007: LESS
62008: PUSH
62009: LD_VAR 0 3
62013: PPUSH
62014: LD_EXP 47
62018: PUSH
62019: LD_VAR 0 2
62023: ARRAY
62024: PPUSH
62025: CALL_OW 308
62029: NOT
62030: AND
62031: IFFALSE 62053
// ComMoveToArea ( j , mc_parking [ i ] ) ;
62033: LD_VAR 0 3
62037: PPUSH
62038: LD_EXP 47
62042: PUSH
62043: LD_VAR 0 2
62047: ARRAY
62048: PPUSH
62049: CALL_OW 113
// end ;
62053: GO 61901
62055: POP
62056: POP
// end ; if tmp > 3 then
62057: LD_VAR 0 5
62061: PUSH
62062: LD_INT 3
62064: GREATER
62065: IFFALSE 62085
// tmp := ShrinkArray ( tmp , 4 ) ;
62067: LD_ADDR_VAR 0 5
62071: PUSH
62072: LD_VAR 0 5
62076: PPUSH
62077: LD_INT 4
62079: PPUSH
62080: CALL 48728 0 2
62084: ST_TO_ADDR
// if not tmp then
62085: LD_VAR 0 5
62089: NOT
62090: IFFALSE 62094
// continue ;
62092: GO 61474
// for j in tmp do
62094: LD_ADDR_VAR 0 3
62098: PUSH
62099: LD_VAR 0 5
62103: PUSH
62104: FOR_IN
62105: IFFALSE 62364
// begin if IsInUnit ( j ) then
62107: LD_VAR 0 3
62111: PPUSH
62112: CALL_OW 310
62116: IFFALSE 62127
// ComExitBuilding ( j ) ;
62118: LD_VAR 0 3
62122: PPUSH
62123: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
62127: LD_VAR 0 3
62131: PUSH
62132: LD_EXP 25
62136: PUSH
62137: LD_VAR 0 2
62141: ARRAY
62142: IN
62143: NOT
62144: IFFALSE 62202
// begin SetTag ( j , 101 ) ;
62146: LD_VAR 0 3
62150: PPUSH
62151: LD_INT 101
62153: PPUSH
62154: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
62158: LD_ADDR_EXP 25
62162: PUSH
62163: LD_EXP 25
62167: PPUSH
62168: LD_VAR 0 2
62172: PUSH
62173: LD_EXP 25
62177: PUSH
62178: LD_VAR 0 2
62182: ARRAY
62183: PUSH
62184: LD_INT 1
62186: PLUS
62187: PUSH
62188: EMPTY
62189: LIST
62190: LIST
62191: PPUSH
62192: LD_VAR 0 3
62196: PPUSH
62197: CALL 16110 0 3
62201: ST_TO_ADDR
// end ; wait ( 1 ) ;
62202: LD_INT 1
62204: PPUSH
62205: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
62209: LD_ADDR_VAR 0 7
62213: PUSH
62214: LD_EXP 24
62218: PUSH
62219: LD_VAR 0 2
62223: ARRAY
62224: ST_TO_ADDR
// if mc_scan [ i ] then
62225: LD_EXP 46
62229: PUSH
62230: LD_VAR 0 2
62234: ARRAY
62235: IFFALSE 62297
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
62237: LD_ADDR_VAR 0 7
62241: PUSH
62242: LD_EXP 24
62246: PUSH
62247: LD_VAR 0 2
62251: ARRAY
62252: PPUSH
62253: LD_INT 3
62255: PUSH
62256: LD_INT 30
62258: PUSH
62259: LD_INT 32
62261: PUSH
62262: EMPTY
62263: LIST
62264: LIST
62265: PUSH
62266: LD_INT 30
62268: PUSH
62269: LD_INT 33
62271: PUSH
62272: EMPTY
62273: LIST
62274: LIST
62275: PUSH
62276: LD_INT 30
62278: PUSH
62279: LD_INT 31
62281: PUSH
62282: EMPTY
62283: LIST
62284: LIST
62285: PUSH
62286: EMPTY
62287: LIST
62288: LIST
62289: LIST
62290: LIST
62291: PPUSH
62292: CALL_OW 72
62296: ST_TO_ADDR
// if not to_repair_tmp then
62297: LD_VAR 0 7
62301: NOT
62302: IFFALSE 62306
// continue ;
62304: GO 62104
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
62306: LD_ADDR_VAR 0 8
62310: PUSH
62311: LD_VAR 0 7
62315: PPUSH
62316: LD_VAR 0 3
62320: PPUSH
62321: CALL_OW 74
62325: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
62326: LD_VAR 0 8
62330: PPUSH
62331: LD_INT 16
62333: PPUSH
62334: CALL 18707 0 2
62338: PUSH
62339: LD_INT 4
62341: ARRAY
62342: PUSH
62343: LD_INT 14
62345: LESS
62346: IFFALSE 62362
// ComRepairBuilding ( j , to_repair ) ;
62348: LD_VAR 0 3
62352: PPUSH
62353: LD_VAR 0 8
62357: PPUSH
62358: CALL_OW 130
// end ;
62362: GO 62104
62364: POP
62365: POP
// end ;
62366: GO 61474
62368: POP
62369: POP
// end ;
62370: LD_VAR 0 1
62374: RET
// export function MC_Heal ; var i , j , tmp ; begin
62375: LD_INT 0
62377: PPUSH
62378: PPUSH
62379: PPUSH
62380: PPUSH
// if not mc_bases then
62381: LD_EXP 23
62385: NOT
62386: IFFALSE 62390
// exit ;
62388: GO 62792
// for i = 1 to mc_bases do
62390: LD_ADDR_VAR 0 2
62394: PUSH
62395: DOUBLE
62396: LD_INT 1
62398: DEC
62399: ST_TO_ADDR
62400: LD_EXP 23
62404: PUSH
62405: FOR_TO
62406: IFFALSE 62790
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
62408: LD_EXP 26
62412: PUSH
62413: LD_VAR 0 2
62417: ARRAY
62418: PUSH
62419: LD_INT 1
62421: ARRAY
62422: NOT
62423: PUSH
62424: LD_EXP 26
62428: PUSH
62429: LD_VAR 0 2
62433: ARRAY
62434: PUSH
62435: LD_INT 2
62437: ARRAY
62438: NOT
62439: AND
62440: IFFALSE 62478
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
62442: LD_ADDR_EXP 27
62446: PUSH
62447: LD_EXP 27
62451: PPUSH
62452: LD_VAR 0 2
62456: PPUSH
62457: EMPTY
62458: PPUSH
62459: CALL_OW 1
62463: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
62464: LD_VAR 0 2
62468: PPUSH
62469: LD_INT 102
62471: PPUSH
62472: CALL 56527 0 2
// continue ;
62476: GO 62405
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
62478: LD_ADDR_VAR 0 4
62482: PUSH
62483: LD_EXP 23
62487: PUSH
62488: LD_VAR 0 2
62492: ARRAY
62493: PPUSH
62494: LD_INT 25
62496: PUSH
62497: LD_INT 4
62499: PUSH
62500: EMPTY
62501: LIST
62502: LIST
62503: PPUSH
62504: CALL_OW 72
62508: ST_TO_ADDR
// if not tmp then
62509: LD_VAR 0 4
62513: NOT
62514: IFFALSE 62518
// continue ;
62516: GO 62405
// if mc_taming [ i ] then
62518: LD_EXP 54
62522: PUSH
62523: LD_VAR 0 2
62527: ARRAY
62528: IFFALSE 62552
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
62530: LD_ADDR_EXP 54
62534: PUSH
62535: LD_EXP 54
62539: PPUSH
62540: LD_VAR 0 2
62544: PPUSH
62545: EMPTY
62546: PPUSH
62547: CALL_OW 1
62551: ST_TO_ADDR
// for j in tmp do
62552: LD_ADDR_VAR 0 3
62556: PUSH
62557: LD_VAR 0 4
62561: PUSH
62562: FOR_IN
62563: IFFALSE 62786
// begin if IsInUnit ( j ) then
62565: LD_VAR 0 3
62569: PPUSH
62570: CALL_OW 310
62574: IFFALSE 62585
// ComExitBuilding ( j ) ;
62576: LD_VAR 0 3
62580: PPUSH
62581: CALL_OW 122
// if not j in mc_healers [ i ] then
62585: LD_VAR 0 3
62589: PUSH
62590: LD_EXP 27
62594: PUSH
62595: LD_VAR 0 2
62599: ARRAY
62600: IN
62601: NOT
62602: IFFALSE 62648
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
62604: LD_ADDR_EXP 27
62608: PUSH
62609: LD_EXP 27
62613: PPUSH
62614: LD_VAR 0 2
62618: PUSH
62619: LD_EXP 27
62623: PUSH
62624: LD_VAR 0 2
62628: ARRAY
62629: PUSH
62630: LD_INT 1
62632: PLUS
62633: PUSH
62634: EMPTY
62635: LIST
62636: LIST
62637: PPUSH
62638: LD_VAR 0 3
62642: PPUSH
62643: CALL 16110 0 3
62647: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
62648: LD_VAR 0 3
62652: PPUSH
62653: CALL_OW 110
62657: PUSH
62658: LD_INT 102
62660: NONEQUAL
62661: IFFALSE 62675
// SetTag ( j , 102 ) ;
62663: LD_VAR 0 3
62667: PPUSH
62668: LD_INT 102
62670: PPUSH
62671: CALL_OW 109
// Wait ( 3 ) ;
62675: LD_INT 3
62677: PPUSH
62678: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
62682: LD_EXP 26
62686: PUSH
62687: LD_VAR 0 2
62691: ARRAY
62692: PUSH
62693: LD_INT 1
62695: ARRAY
62696: IFFALSE 62728
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
62698: LD_VAR 0 3
62702: PPUSH
62703: LD_EXP 26
62707: PUSH
62708: LD_VAR 0 2
62712: ARRAY
62713: PUSH
62714: LD_INT 1
62716: ARRAY
62717: PUSH
62718: LD_INT 1
62720: ARRAY
62721: PPUSH
62722: CALL_OW 128
62726: GO 62784
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
62728: LD_VAR 0 3
62732: PPUSH
62733: CALL_OW 314
62737: NOT
62738: PUSH
62739: LD_EXP 26
62743: PUSH
62744: LD_VAR 0 2
62748: ARRAY
62749: PUSH
62750: LD_INT 2
62752: ARRAY
62753: AND
62754: IFFALSE 62784
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
62756: LD_VAR 0 3
62760: PPUSH
62761: LD_EXP 26
62765: PUSH
62766: LD_VAR 0 2
62770: ARRAY
62771: PUSH
62772: LD_INT 2
62774: ARRAY
62775: PUSH
62776: LD_INT 1
62778: ARRAY
62779: PPUSH
62780: CALL_OW 128
// end ;
62784: GO 62562
62786: POP
62787: POP
// end ;
62788: GO 62405
62790: POP
62791: POP
// end ;
62792: LD_VAR 0 1
62796: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
62797: LD_INT 0
62799: PPUSH
62800: PPUSH
62801: PPUSH
62802: PPUSH
62803: PPUSH
62804: PPUSH
// if not mc_bases then
62805: LD_EXP 23
62809: NOT
62810: IFFALSE 62814
// exit ;
62812: GO 63977
// for i = 1 to mc_bases do
62814: LD_ADDR_VAR 0 2
62818: PUSH
62819: DOUBLE
62820: LD_INT 1
62822: DEC
62823: ST_TO_ADDR
62824: LD_EXP 23
62828: PUSH
62829: FOR_TO
62830: IFFALSE 63975
// begin if mc_scan [ i ] then
62832: LD_EXP 46
62836: PUSH
62837: LD_VAR 0 2
62841: ARRAY
62842: IFFALSE 62846
// continue ;
62844: GO 62829
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
62846: LD_EXP 28
62850: PUSH
62851: LD_VAR 0 2
62855: ARRAY
62856: NOT
62857: PUSH
62858: LD_EXP 30
62862: PUSH
62863: LD_VAR 0 2
62867: ARRAY
62868: NOT
62869: AND
62870: PUSH
62871: LD_EXP 29
62875: PUSH
62876: LD_VAR 0 2
62880: ARRAY
62881: AND
62882: IFFALSE 62920
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
62884: LD_ADDR_EXP 29
62888: PUSH
62889: LD_EXP 29
62893: PPUSH
62894: LD_VAR 0 2
62898: PPUSH
62899: EMPTY
62900: PPUSH
62901: CALL_OW 1
62905: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
62906: LD_VAR 0 2
62910: PPUSH
62911: LD_INT 103
62913: PPUSH
62914: CALL 56527 0 2
// continue ;
62918: GO 62829
// end ; if mc_construct_list [ i ] then
62920: LD_EXP 30
62924: PUSH
62925: LD_VAR 0 2
62929: ARRAY
62930: IFFALSE 63150
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
62932: LD_ADDR_VAR 0 5
62936: PUSH
62937: LD_EXP 23
62941: PUSH
62942: LD_VAR 0 2
62946: ARRAY
62947: PPUSH
62948: LD_INT 25
62950: PUSH
62951: LD_INT 2
62953: PUSH
62954: EMPTY
62955: LIST
62956: LIST
62957: PPUSH
62958: CALL_OW 72
62962: PUSH
62963: LD_EXP 25
62967: PUSH
62968: LD_VAR 0 2
62972: ARRAY
62973: DIFF
62974: ST_TO_ADDR
// if not tmp then
62975: LD_VAR 0 5
62979: NOT
62980: IFFALSE 62984
// continue ;
62982: GO 62829
// for j in tmp do
62984: LD_ADDR_VAR 0 3
62988: PUSH
62989: LD_VAR 0 5
62993: PUSH
62994: FOR_IN
62995: IFFALSE 63146
// begin if not mc_builders [ i ] then
62997: LD_EXP 29
63001: PUSH
63002: LD_VAR 0 2
63006: ARRAY
63007: NOT
63008: IFFALSE 63066
// begin SetTag ( j , 103 ) ;
63010: LD_VAR 0 3
63014: PPUSH
63015: LD_INT 103
63017: PPUSH
63018: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
63022: LD_ADDR_EXP 29
63026: PUSH
63027: LD_EXP 29
63031: PPUSH
63032: LD_VAR 0 2
63036: PUSH
63037: LD_EXP 29
63041: PUSH
63042: LD_VAR 0 2
63046: ARRAY
63047: PUSH
63048: LD_INT 1
63050: PLUS
63051: PUSH
63052: EMPTY
63053: LIST
63054: LIST
63055: PPUSH
63056: LD_VAR 0 3
63060: PPUSH
63061: CALL 16110 0 3
63065: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
63066: LD_VAR 0 3
63070: PPUSH
63071: CALL_OW 310
63075: IFFALSE 63086
// ComExitBuilding ( j ) ;
63077: LD_VAR 0 3
63081: PPUSH
63082: CALL_OW 122
// wait ( 3 ) ;
63086: LD_INT 3
63088: PPUSH
63089: CALL_OW 67
// if not mc_construct_list [ i ] then
63093: LD_EXP 30
63097: PUSH
63098: LD_VAR 0 2
63102: ARRAY
63103: NOT
63104: IFFALSE 63108
// break ;
63106: GO 63146
// if not HasTask ( j ) then
63108: LD_VAR 0 3
63112: PPUSH
63113: CALL_OW 314
63117: NOT
63118: IFFALSE 63144
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
63120: LD_VAR 0 3
63124: PPUSH
63125: LD_EXP 30
63129: PUSH
63130: LD_VAR 0 2
63134: ARRAY
63135: PUSH
63136: LD_INT 1
63138: ARRAY
63139: PPUSH
63140: CALL 18971 0 2
// end ;
63144: GO 62994
63146: POP
63147: POP
// end else
63148: GO 63973
// if mc_build_list [ i ] then
63150: LD_EXP 28
63154: PUSH
63155: LD_VAR 0 2
63159: ARRAY
63160: IFFALSE 63973
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
63162: LD_EXP 28
63166: PUSH
63167: LD_VAR 0 2
63171: ARRAY
63172: PUSH
63173: LD_INT 1
63175: ARRAY
63176: PUSH
63177: LD_INT 1
63179: ARRAY
63180: PPUSH
63181: CALL 18795 0 1
63185: PUSH
63186: LD_EXP 23
63190: PUSH
63191: LD_VAR 0 2
63195: ARRAY
63196: PPUSH
63197: LD_INT 2
63199: PUSH
63200: LD_INT 30
63202: PUSH
63203: LD_INT 2
63205: PUSH
63206: EMPTY
63207: LIST
63208: LIST
63209: PUSH
63210: LD_INT 30
63212: PUSH
63213: LD_INT 3
63215: PUSH
63216: EMPTY
63217: LIST
63218: LIST
63219: PUSH
63220: EMPTY
63221: LIST
63222: LIST
63223: LIST
63224: PPUSH
63225: CALL_OW 72
63229: NOT
63230: AND
63231: IFFALSE 63336
// begin for j = 1 to mc_build_list [ i ] do
63233: LD_ADDR_VAR 0 3
63237: PUSH
63238: DOUBLE
63239: LD_INT 1
63241: DEC
63242: ST_TO_ADDR
63243: LD_EXP 28
63247: PUSH
63248: LD_VAR 0 2
63252: ARRAY
63253: PUSH
63254: FOR_TO
63255: IFFALSE 63334
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
63257: LD_EXP 28
63261: PUSH
63262: LD_VAR 0 2
63266: ARRAY
63267: PUSH
63268: LD_VAR 0 3
63272: ARRAY
63273: PUSH
63274: LD_INT 1
63276: ARRAY
63277: PUSH
63278: LD_INT 2
63280: EQUAL
63281: IFFALSE 63332
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
63283: LD_ADDR_EXP 28
63287: PUSH
63288: LD_EXP 28
63292: PPUSH
63293: LD_VAR 0 2
63297: PPUSH
63298: LD_EXP 28
63302: PUSH
63303: LD_VAR 0 2
63307: ARRAY
63308: PPUSH
63309: LD_VAR 0 3
63313: PPUSH
63314: LD_INT 1
63316: PPUSH
63317: LD_INT 0
63319: PPUSH
63320: CALL 15528 0 4
63324: PPUSH
63325: CALL_OW 1
63329: ST_TO_ADDR
// break ;
63330: GO 63334
// end ;
63332: GO 63254
63334: POP
63335: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
63336: LD_ADDR_VAR 0 6
63340: PUSH
63341: LD_EXP 23
63345: PUSH
63346: LD_VAR 0 2
63350: ARRAY
63351: PPUSH
63352: LD_INT 2
63354: PUSH
63355: LD_INT 30
63357: PUSH
63358: LD_INT 0
63360: PUSH
63361: EMPTY
63362: LIST
63363: LIST
63364: PUSH
63365: LD_INT 30
63367: PUSH
63368: LD_INT 1
63370: PUSH
63371: EMPTY
63372: LIST
63373: LIST
63374: PUSH
63375: EMPTY
63376: LIST
63377: LIST
63378: LIST
63379: PPUSH
63380: CALL_OW 72
63384: ST_TO_ADDR
// for k := 1 to depot do
63385: LD_ADDR_VAR 0 4
63389: PUSH
63390: DOUBLE
63391: LD_INT 1
63393: DEC
63394: ST_TO_ADDR
63395: LD_VAR 0 6
63399: PUSH
63400: FOR_TO
63401: IFFALSE 63971
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
63403: LD_EXP 28
63407: PUSH
63408: LD_VAR 0 2
63412: ARRAY
63413: PUSH
63414: LD_INT 1
63416: ARRAY
63417: PUSH
63418: LD_INT 1
63420: ARRAY
63421: PUSH
63422: LD_INT 0
63424: EQUAL
63425: PUSH
63426: LD_VAR 0 6
63430: PUSH
63431: LD_VAR 0 4
63435: ARRAY
63436: PPUSH
63437: LD_EXP 28
63441: PUSH
63442: LD_VAR 0 2
63446: ARRAY
63447: PUSH
63448: LD_INT 1
63450: ARRAY
63451: PUSH
63452: LD_INT 1
63454: ARRAY
63455: PPUSH
63456: LD_EXP 28
63460: PUSH
63461: LD_VAR 0 2
63465: ARRAY
63466: PUSH
63467: LD_INT 1
63469: ARRAY
63470: PUSH
63471: LD_INT 2
63473: ARRAY
63474: PPUSH
63475: LD_EXP 28
63479: PUSH
63480: LD_VAR 0 2
63484: ARRAY
63485: PUSH
63486: LD_INT 1
63488: ARRAY
63489: PUSH
63490: LD_INT 3
63492: ARRAY
63493: PPUSH
63494: LD_EXP 28
63498: PUSH
63499: LD_VAR 0 2
63503: ARRAY
63504: PUSH
63505: LD_INT 1
63507: ARRAY
63508: PUSH
63509: LD_INT 4
63511: ARRAY
63512: PPUSH
63513: CALL 24207 0 5
63517: OR
63518: IFFALSE 63799
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
63520: LD_ADDR_VAR 0 5
63524: PUSH
63525: LD_EXP 23
63529: PUSH
63530: LD_VAR 0 2
63534: ARRAY
63535: PPUSH
63536: LD_INT 25
63538: PUSH
63539: LD_INT 2
63541: PUSH
63542: EMPTY
63543: LIST
63544: LIST
63545: PPUSH
63546: CALL_OW 72
63550: PUSH
63551: LD_EXP 25
63555: PUSH
63556: LD_VAR 0 2
63560: ARRAY
63561: DIFF
63562: ST_TO_ADDR
// if not tmp then
63563: LD_VAR 0 5
63567: NOT
63568: IFFALSE 63572
// continue ;
63570: GO 63400
// for j in tmp do
63572: LD_ADDR_VAR 0 3
63576: PUSH
63577: LD_VAR 0 5
63581: PUSH
63582: FOR_IN
63583: IFFALSE 63795
// begin if not mc_builders [ i ] then
63585: LD_EXP 29
63589: PUSH
63590: LD_VAR 0 2
63594: ARRAY
63595: NOT
63596: IFFALSE 63654
// begin SetTag ( j , 103 ) ;
63598: LD_VAR 0 3
63602: PPUSH
63603: LD_INT 103
63605: PPUSH
63606: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
63610: LD_ADDR_EXP 29
63614: PUSH
63615: LD_EXP 29
63619: PPUSH
63620: LD_VAR 0 2
63624: PUSH
63625: LD_EXP 29
63629: PUSH
63630: LD_VAR 0 2
63634: ARRAY
63635: PUSH
63636: LD_INT 1
63638: PLUS
63639: PUSH
63640: EMPTY
63641: LIST
63642: LIST
63643: PPUSH
63644: LD_VAR 0 3
63648: PPUSH
63649: CALL 16110 0 3
63653: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
63654: LD_VAR 0 3
63658: PPUSH
63659: CALL_OW 310
63663: IFFALSE 63674
// ComExitBuilding ( j ) ;
63665: LD_VAR 0 3
63669: PPUSH
63670: CALL_OW 122
// wait ( 3 ) ;
63674: LD_INT 3
63676: PPUSH
63677: CALL_OW 67
// if not mc_build_list [ i ] then
63681: LD_EXP 28
63685: PUSH
63686: LD_VAR 0 2
63690: ARRAY
63691: NOT
63692: IFFALSE 63696
// break ;
63694: GO 63795
// if not HasTask ( j ) then
63696: LD_VAR 0 3
63700: PPUSH
63701: CALL_OW 314
63705: NOT
63706: IFFALSE 63793
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
63708: LD_VAR 0 3
63712: PPUSH
63713: LD_EXP 28
63717: PUSH
63718: LD_VAR 0 2
63722: ARRAY
63723: PUSH
63724: LD_INT 1
63726: ARRAY
63727: PUSH
63728: LD_INT 1
63730: ARRAY
63731: PPUSH
63732: LD_EXP 28
63736: PUSH
63737: LD_VAR 0 2
63741: ARRAY
63742: PUSH
63743: LD_INT 1
63745: ARRAY
63746: PUSH
63747: LD_INT 2
63749: ARRAY
63750: PPUSH
63751: LD_EXP 28
63755: PUSH
63756: LD_VAR 0 2
63760: ARRAY
63761: PUSH
63762: LD_INT 1
63764: ARRAY
63765: PUSH
63766: LD_INT 3
63768: ARRAY
63769: PPUSH
63770: LD_EXP 28
63774: PUSH
63775: LD_VAR 0 2
63779: ARRAY
63780: PUSH
63781: LD_INT 1
63783: ARRAY
63784: PUSH
63785: LD_INT 4
63787: ARRAY
63788: PPUSH
63789: CALL_OW 145
// end ;
63793: GO 63582
63795: POP
63796: POP
// end else
63797: GO 63969
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
63799: LD_EXP 23
63803: PUSH
63804: LD_VAR 0 2
63808: ARRAY
63809: PPUSH
63810: LD_EXP 28
63814: PUSH
63815: LD_VAR 0 2
63819: ARRAY
63820: PUSH
63821: LD_INT 1
63823: ARRAY
63824: PUSH
63825: LD_INT 1
63827: ARRAY
63828: PPUSH
63829: LD_EXP 28
63833: PUSH
63834: LD_VAR 0 2
63838: ARRAY
63839: PUSH
63840: LD_INT 1
63842: ARRAY
63843: PUSH
63844: LD_INT 2
63846: ARRAY
63847: PPUSH
63848: LD_EXP 28
63852: PUSH
63853: LD_VAR 0 2
63857: ARRAY
63858: PUSH
63859: LD_INT 1
63861: ARRAY
63862: PUSH
63863: LD_INT 3
63865: ARRAY
63866: PPUSH
63867: LD_EXP 28
63871: PUSH
63872: LD_VAR 0 2
63876: ARRAY
63877: PUSH
63878: LD_INT 1
63880: ARRAY
63881: PUSH
63882: LD_INT 4
63884: ARRAY
63885: PPUSH
63886: LD_EXP 23
63890: PUSH
63891: LD_VAR 0 2
63895: ARRAY
63896: PPUSH
63897: LD_INT 21
63899: PUSH
63900: LD_INT 3
63902: PUSH
63903: EMPTY
63904: LIST
63905: LIST
63906: PPUSH
63907: CALL_OW 72
63911: PPUSH
63912: EMPTY
63913: PPUSH
63914: CALL 22961 0 7
63918: NOT
63919: IFFALSE 63969
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
63921: LD_ADDR_EXP 28
63925: PUSH
63926: LD_EXP 28
63930: PPUSH
63931: LD_VAR 0 2
63935: PPUSH
63936: LD_EXP 28
63940: PUSH
63941: LD_VAR 0 2
63945: ARRAY
63946: PPUSH
63947: LD_INT 1
63949: PPUSH
63950: LD_INT 1
63952: NEG
63953: PPUSH
63954: LD_INT 0
63956: PPUSH
63957: CALL 15528 0 4
63961: PPUSH
63962: CALL_OW 1
63966: ST_TO_ADDR
// continue ;
63967: GO 63400
// end ; end ;
63969: GO 63400
63971: POP
63972: POP
// end ; end ;
63973: GO 62829
63975: POP
63976: POP
// end ;
63977: LD_VAR 0 1
63981: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
63982: LD_INT 0
63984: PPUSH
63985: PPUSH
63986: PPUSH
63987: PPUSH
63988: PPUSH
63989: PPUSH
// if not mc_bases then
63990: LD_EXP 23
63994: NOT
63995: IFFALSE 63999
// exit ;
63997: GO 64426
// for i = 1 to mc_bases do
63999: LD_ADDR_VAR 0 2
64003: PUSH
64004: DOUBLE
64005: LD_INT 1
64007: DEC
64008: ST_TO_ADDR
64009: LD_EXP 23
64013: PUSH
64014: FOR_TO
64015: IFFALSE 64424
// begin tmp := mc_build_upgrade [ i ] ;
64017: LD_ADDR_VAR 0 4
64021: PUSH
64022: LD_EXP 55
64026: PUSH
64027: LD_VAR 0 2
64031: ARRAY
64032: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
64033: LD_ADDR_VAR 0 6
64037: PUSH
64038: LD_EXP 56
64042: PUSH
64043: LD_VAR 0 2
64047: ARRAY
64048: PPUSH
64049: LD_INT 2
64051: PUSH
64052: LD_INT 30
64054: PUSH
64055: LD_INT 6
64057: PUSH
64058: EMPTY
64059: LIST
64060: LIST
64061: PUSH
64062: LD_INT 30
64064: PUSH
64065: LD_INT 7
64067: PUSH
64068: EMPTY
64069: LIST
64070: LIST
64071: PUSH
64072: EMPTY
64073: LIST
64074: LIST
64075: LIST
64076: PPUSH
64077: CALL_OW 72
64081: ST_TO_ADDR
// if not tmp and not lab then
64082: LD_VAR 0 4
64086: NOT
64087: PUSH
64088: LD_VAR 0 6
64092: NOT
64093: AND
64094: IFFALSE 64098
// continue ;
64096: GO 64014
// if tmp then
64098: LD_VAR 0 4
64102: IFFALSE 64222
// for j in tmp do
64104: LD_ADDR_VAR 0 3
64108: PUSH
64109: LD_VAR 0 4
64113: PUSH
64114: FOR_IN
64115: IFFALSE 64220
// begin if UpgradeCost ( j ) then
64117: LD_VAR 0 3
64121: PPUSH
64122: CALL 22621 0 1
64126: IFFALSE 64218
// begin ComUpgrade ( j ) ;
64128: LD_VAR 0 3
64132: PPUSH
64133: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
64137: LD_ADDR_EXP 55
64141: PUSH
64142: LD_EXP 55
64146: PPUSH
64147: LD_VAR 0 2
64151: PPUSH
64152: LD_EXP 55
64156: PUSH
64157: LD_VAR 0 2
64161: ARRAY
64162: PUSH
64163: LD_VAR 0 3
64167: DIFF
64168: PPUSH
64169: CALL_OW 1
64173: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
64174: LD_ADDR_EXP 30
64178: PUSH
64179: LD_EXP 30
64183: PPUSH
64184: LD_VAR 0 2
64188: PUSH
64189: LD_EXP 30
64193: PUSH
64194: LD_VAR 0 2
64198: ARRAY
64199: PUSH
64200: LD_INT 1
64202: PLUS
64203: PUSH
64204: EMPTY
64205: LIST
64206: LIST
64207: PPUSH
64208: LD_VAR 0 3
64212: PPUSH
64213: CALL 16110 0 3
64217: ST_TO_ADDR
// end ; end ;
64218: GO 64114
64220: POP
64221: POP
// if not lab or not mc_lab_upgrade [ i ] then
64222: LD_VAR 0 6
64226: NOT
64227: PUSH
64228: LD_EXP 57
64232: PUSH
64233: LD_VAR 0 2
64237: ARRAY
64238: NOT
64239: OR
64240: IFFALSE 64244
// continue ;
64242: GO 64014
// for j in lab do
64244: LD_ADDR_VAR 0 3
64248: PUSH
64249: LD_VAR 0 6
64253: PUSH
64254: FOR_IN
64255: IFFALSE 64420
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
64257: LD_VAR 0 3
64261: PPUSH
64262: CALL_OW 266
64266: PUSH
64267: LD_INT 6
64269: PUSH
64270: LD_INT 7
64272: PUSH
64273: EMPTY
64274: LIST
64275: LIST
64276: IN
64277: PUSH
64278: LD_VAR 0 3
64282: PPUSH
64283: CALL_OW 461
64287: PUSH
64288: LD_INT 1
64290: NONEQUAL
64291: AND
64292: IFFALSE 64418
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
64294: LD_VAR 0 3
64298: PPUSH
64299: LD_EXP 57
64303: PUSH
64304: LD_VAR 0 2
64308: ARRAY
64309: PUSH
64310: LD_INT 1
64312: ARRAY
64313: PPUSH
64314: CALL 22826 0 2
64318: IFFALSE 64418
// begin ComCancel ( j ) ;
64320: LD_VAR 0 3
64324: PPUSH
64325: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
64329: LD_VAR 0 3
64333: PPUSH
64334: LD_EXP 57
64338: PUSH
64339: LD_VAR 0 2
64343: ARRAY
64344: PUSH
64345: LD_INT 1
64347: ARRAY
64348: PPUSH
64349: CALL_OW 207
// if not j in mc_construct_list [ i ] then
64353: LD_VAR 0 3
64357: PUSH
64358: LD_EXP 30
64362: PUSH
64363: LD_VAR 0 2
64367: ARRAY
64368: IN
64369: NOT
64370: IFFALSE 64416
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
64372: LD_ADDR_EXP 30
64376: PUSH
64377: LD_EXP 30
64381: PPUSH
64382: LD_VAR 0 2
64386: PUSH
64387: LD_EXP 30
64391: PUSH
64392: LD_VAR 0 2
64396: ARRAY
64397: PUSH
64398: LD_INT 1
64400: PLUS
64401: PUSH
64402: EMPTY
64403: LIST
64404: LIST
64405: PPUSH
64406: LD_VAR 0 3
64410: PPUSH
64411: CALL 16110 0 3
64415: ST_TO_ADDR
// break ;
64416: GO 64420
// end ; end ; end ;
64418: GO 64254
64420: POP
64421: POP
// end ;
64422: GO 64014
64424: POP
64425: POP
// end ;
64426: LD_VAR 0 1
64430: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
64431: LD_INT 0
64433: PPUSH
64434: PPUSH
64435: PPUSH
64436: PPUSH
64437: PPUSH
64438: PPUSH
64439: PPUSH
64440: PPUSH
64441: PPUSH
// if not mc_bases then
64442: LD_EXP 23
64446: NOT
64447: IFFALSE 64451
// exit ;
64449: GO 64856
// for i = 1 to mc_bases do
64451: LD_ADDR_VAR 0 2
64455: PUSH
64456: DOUBLE
64457: LD_INT 1
64459: DEC
64460: ST_TO_ADDR
64461: LD_EXP 23
64465: PUSH
64466: FOR_TO
64467: IFFALSE 64854
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
64469: LD_EXP 31
64473: PUSH
64474: LD_VAR 0 2
64478: ARRAY
64479: NOT
64480: PUSH
64481: LD_EXP 23
64485: PUSH
64486: LD_VAR 0 2
64490: ARRAY
64491: PPUSH
64492: LD_INT 30
64494: PUSH
64495: LD_INT 3
64497: PUSH
64498: EMPTY
64499: LIST
64500: LIST
64501: PPUSH
64502: CALL_OW 72
64506: NOT
64507: OR
64508: IFFALSE 64512
// continue ;
64510: GO 64466
// busy := false ;
64512: LD_ADDR_VAR 0 8
64516: PUSH
64517: LD_INT 0
64519: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
64520: LD_ADDR_VAR 0 4
64524: PUSH
64525: LD_EXP 23
64529: PUSH
64530: LD_VAR 0 2
64534: ARRAY
64535: PPUSH
64536: LD_INT 30
64538: PUSH
64539: LD_INT 3
64541: PUSH
64542: EMPTY
64543: LIST
64544: LIST
64545: PPUSH
64546: CALL_OW 72
64550: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
64551: LD_ADDR_VAR 0 6
64555: PUSH
64556: LD_EXP 31
64560: PUSH
64561: LD_VAR 0 2
64565: ARRAY
64566: PPUSH
64567: LD_INT 2
64569: PUSH
64570: LD_INT 30
64572: PUSH
64573: LD_INT 32
64575: PUSH
64576: EMPTY
64577: LIST
64578: LIST
64579: PUSH
64580: LD_INT 30
64582: PUSH
64583: LD_INT 33
64585: PUSH
64586: EMPTY
64587: LIST
64588: LIST
64589: PUSH
64590: EMPTY
64591: LIST
64592: LIST
64593: LIST
64594: PPUSH
64595: CALL_OW 72
64599: ST_TO_ADDR
// if not t then
64600: LD_VAR 0 6
64604: NOT
64605: IFFALSE 64609
// continue ;
64607: GO 64466
// for j in tmp do
64609: LD_ADDR_VAR 0 3
64613: PUSH
64614: LD_VAR 0 4
64618: PUSH
64619: FOR_IN
64620: IFFALSE 64650
// if not BuildingStatus ( j ) = bs_idle then
64622: LD_VAR 0 3
64626: PPUSH
64627: CALL_OW 461
64631: PUSH
64632: LD_INT 2
64634: EQUAL
64635: NOT
64636: IFFALSE 64648
// begin busy := true ;
64638: LD_ADDR_VAR 0 8
64642: PUSH
64643: LD_INT 1
64645: ST_TO_ADDR
// break ;
64646: GO 64650
// end ;
64648: GO 64619
64650: POP
64651: POP
// if busy then
64652: LD_VAR 0 8
64656: IFFALSE 64660
// continue ;
64658: GO 64466
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
64660: LD_ADDR_VAR 0 7
64664: PUSH
64665: LD_VAR 0 6
64669: PPUSH
64670: LD_INT 35
64672: PUSH
64673: LD_INT 0
64675: PUSH
64676: EMPTY
64677: LIST
64678: LIST
64679: PPUSH
64680: CALL_OW 72
64684: ST_TO_ADDR
// if tw then
64685: LD_VAR 0 7
64689: IFFALSE 64766
// begin tw := tw [ 1 ] ;
64691: LD_ADDR_VAR 0 7
64695: PUSH
64696: LD_VAR 0 7
64700: PUSH
64701: LD_INT 1
64703: ARRAY
64704: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
64705: LD_ADDR_VAR 0 9
64709: PUSH
64710: LD_VAR 0 7
64714: PPUSH
64715: LD_EXP 48
64719: PUSH
64720: LD_VAR 0 2
64724: ARRAY
64725: PPUSH
64726: CALL 21118 0 2
64730: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
64731: LD_EXP 62
64735: PUSH
64736: LD_VAR 0 2
64740: ARRAY
64741: IFFALSE 64764
// if not weapon in mc_allowed_tower_weapons [ i ] then
64743: LD_VAR 0 9
64747: PUSH
64748: LD_EXP 62
64752: PUSH
64753: LD_VAR 0 2
64757: ARRAY
64758: IN
64759: NOT
64760: IFFALSE 64764
// continue ;
64762: GO 64466
// end else
64764: GO 64829
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
64766: LD_ADDR_VAR 0 5
64770: PUSH
64771: LD_EXP 31
64775: PUSH
64776: LD_VAR 0 2
64780: ARRAY
64781: PPUSH
64782: LD_VAR 0 4
64786: PPUSH
64787: CALL 47961 0 2
64791: ST_TO_ADDR
// if not tmp2 then
64792: LD_VAR 0 5
64796: NOT
64797: IFFALSE 64801
// continue ;
64799: GO 64466
// tw := tmp2 [ 1 ] ;
64801: LD_ADDR_VAR 0 7
64805: PUSH
64806: LD_VAR 0 5
64810: PUSH
64811: LD_INT 1
64813: ARRAY
64814: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
64815: LD_ADDR_VAR 0 9
64819: PUSH
64820: LD_VAR 0 5
64824: PUSH
64825: LD_INT 2
64827: ARRAY
64828: ST_TO_ADDR
// end ; if not weapon then
64829: LD_VAR 0 9
64833: NOT
64834: IFFALSE 64838
// continue ;
64836: GO 64466
// ComPlaceWeapon ( tw , weapon ) ;
64838: LD_VAR 0 7
64842: PPUSH
64843: LD_VAR 0 9
64847: PPUSH
64848: CALL_OW 148
// end ;
64852: GO 64466
64854: POP
64855: POP
// end ;
64856: LD_VAR 0 1
64860: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
64861: LD_INT 0
64863: PPUSH
64864: PPUSH
64865: PPUSH
64866: PPUSH
64867: PPUSH
64868: PPUSH
64869: PPUSH
// if not mc_bases then
64870: LD_EXP 23
64874: NOT
64875: IFFALSE 64879
// exit ;
64877: GO 65647
// for i = 1 to mc_bases do
64879: LD_ADDR_VAR 0 2
64883: PUSH
64884: DOUBLE
64885: LD_INT 1
64887: DEC
64888: ST_TO_ADDR
64889: LD_EXP 23
64893: PUSH
64894: FOR_TO
64895: IFFALSE 65645
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
64897: LD_EXP 36
64901: PUSH
64902: LD_VAR 0 2
64906: ARRAY
64907: NOT
64908: PUSH
64909: LD_EXP 36
64913: PUSH
64914: LD_VAR 0 2
64918: ARRAY
64919: PUSH
64920: LD_EXP 37
64924: PUSH
64925: LD_VAR 0 2
64929: ARRAY
64930: EQUAL
64931: OR
64932: PUSH
64933: LD_EXP 46
64937: PUSH
64938: LD_VAR 0 2
64942: ARRAY
64943: OR
64944: IFFALSE 64948
// continue ;
64946: GO 64894
// if mc_miners [ i ] then
64948: LD_EXP 37
64952: PUSH
64953: LD_VAR 0 2
64957: ARRAY
64958: IFFALSE 65332
// begin for j = mc_miners [ i ] downto 1 do
64960: LD_ADDR_VAR 0 3
64964: PUSH
64965: DOUBLE
64966: LD_EXP 37
64970: PUSH
64971: LD_VAR 0 2
64975: ARRAY
64976: INC
64977: ST_TO_ADDR
64978: LD_INT 1
64980: PUSH
64981: FOR_DOWNTO
64982: IFFALSE 65330
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
64984: LD_EXP 37
64988: PUSH
64989: LD_VAR 0 2
64993: ARRAY
64994: PUSH
64995: LD_VAR 0 3
64999: ARRAY
65000: PPUSH
65001: CALL_OW 301
65005: PUSH
65006: LD_EXP 37
65010: PUSH
65011: LD_VAR 0 2
65015: ARRAY
65016: PUSH
65017: LD_VAR 0 3
65021: ARRAY
65022: PPUSH
65023: CALL_OW 257
65027: PUSH
65028: LD_INT 1
65030: NONEQUAL
65031: OR
65032: IFFALSE 65095
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
65034: LD_ADDR_VAR 0 5
65038: PUSH
65039: LD_EXP 37
65043: PUSH
65044: LD_VAR 0 2
65048: ARRAY
65049: PUSH
65050: LD_EXP 37
65054: PUSH
65055: LD_VAR 0 2
65059: ARRAY
65060: PUSH
65061: LD_VAR 0 3
65065: ARRAY
65066: DIFF
65067: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
65068: LD_ADDR_EXP 37
65072: PUSH
65073: LD_EXP 37
65077: PPUSH
65078: LD_VAR 0 2
65082: PPUSH
65083: LD_VAR 0 5
65087: PPUSH
65088: CALL_OW 1
65092: ST_TO_ADDR
// continue ;
65093: GO 64981
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
65095: LD_EXP 37
65099: PUSH
65100: LD_VAR 0 2
65104: ARRAY
65105: PUSH
65106: LD_VAR 0 3
65110: ARRAY
65111: PPUSH
65112: CALL_OW 257
65116: PUSH
65117: LD_INT 1
65119: EQUAL
65120: PUSH
65121: LD_EXP 37
65125: PUSH
65126: LD_VAR 0 2
65130: ARRAY
65131: PUSH
65132: LD_VAR 0 3
65136: ARRAY
65137: PPUSH
65138: CALL_OW 459
65142: NOT
65143: AND
65144: PUSH
65145: LD_EXP 37
65149: PUSH
65150: LD_VAR 0 2
65154: ARRAY
65155: PUSH
65156: LD_VAR 0 3
65160: ARRAY
65161: PPUSH
65162: CALL_OW 314
65166: NOT
65167: AND
65168: IFFALSE 65328
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
65170: LD_EXP 37
65174: PUSH
65175: LD_VAR 0 2
65179: ARRAY
65180: PUSH
65181: LD_VAR 0 3
65185: ARRAY
65186: PPUSH
65187: CALL_OW 310
65191: IFFALSE 65214
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
65193: LD_EXP 37
65197: PUSH
65198: LD_VAR 0 2
65202: ARRAY
65203: PUSH
65204: LD_VAR 0 3
65208: ARRAY
65209: PPUSH
65210: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
65214: LD_EXP 37
65218: PUSH
65219: LD_VAR 0 2
65223: ARRAY
65224: PUSH
65225: LD_VAR 0 3
65229: ARRAY
65230: PPUSH
65231: CALL_OW 314
65235: NOT
65236: IFFALSE 65328
// begin r := rand ( 1 , mc_mines [ i ] ) ;
65238: LD_ADDR_VAR 0 7
65242: PUSH
65243: LD_INT 1
65245: PPUSH
65246: LD_EXP 36
65250: PUSH
65251: LD_VAR 0 2
65255: ARRAY
65256: PPUSH
65257: CALL_OW 12
65261: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
65262: LD_EXP 37
65266: PUSH
65267: LD_VAR 0 2
65271: ARRAY
65272: PUSH
65273: LD_VAR 0 3
65277: ARRAY
65278: PPUSH
65279: LD_EXP 36
65283: PUSH
65284: LD_VAR 0 2
65288: ARRAY
65289: PUSH
65290: LD_VAR 0 7
65294: ARRAY
65295: PUSH
65296: LD_INT 1
65298: ARRAY
65299: PPUSH
65300: LD_EXP 36
65304: PUSH
65305: LD_VAR 0 2
65309: ARRAY
65310: PUSH
65311: LD_VAR 0 7
65315: ARRAY
65316: PUSH
65317: LD_INT 2
65319: ARRAY
65320: PPUSH
65321: LD_INT 0
65323: PPUSH
65324: CALL_OW 193
// end ; end ; end ;
65328: GO 64981
65330: POP
65331: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
65332: LD_ADDR_VAR 0 5
65336: PUSH
65337: LD_EXP 23
65341: PUSH
65342: LD_VAR 0 2
65346: ARRAY
65347: PPUSH
65348: LD_INT 2
65350: PUSH
65351: LD_INT 30
65353: PUSH
65354: LD_INT 4
65356: PUSH
65357: EMPTY
65358: LIST
65359: LIST
65360: PUSH
65361: LD_INT 30
65363: PUSH
65364: LD_INT 5
65366: PUSH
65367: EMPTY
65368: LIST
65369: LIST
65370: PUSH
65371: LD_INT 30
65373: PUSH
65374: LD_INT 32
65376: PUSH
65377: EMPTY
65378: LIST
65379: LIST
65380: PUSH
65381: EMPTY
65382: LIST
65383: LIST
65384: LIST
65385: LIST
65386: PPUSH
65387: CALL_OW 72
65391: ST_TO_ADDR
// if not tmp then
65392: LD_VAR 0 5
65396: NOT
65397: IFFALSE 65401
// continue ;
65399: GO 64894
// list := [ ] ;
65401: LD_ADDR_VAR 0 6
65405: PUSH
65406: EMPTY
65407: ST_TO_ADDR
// for j in tmp do
65408: LD_ADDR_VAR 0 3
65412: PUSH
65413: LD_VAR 0 5
65417: PUSH
65418: FOR_IN
65419: IFFALSE 65488
// begin for k in UnitsInside ( j ) do
65421: LD_ADDR_VAR 0 4
65425: PUSH
65426: LD_VAR 0 3
65430: PPUSH
65431: CALL_OW 313
65435: PUSH
65436: FOR_IN
65437: IFFALSE 65484
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
65439: LD_VAR 0 4
65443: PPUSH
65444: CALL_OW 257
65448: PUSH
65449: LD_INT 1
65451: EQUAL
65452: PUSH
65453: LD_VAR 0 4
65457: PPUSH
65458: CALL_OW 459
65462: NOT
65463: AND
65464: IFFALSE 65482
// list := list ^ k ;
65466: LD_ADDR_VAR 0 6
65470: PUSH
65471: LD_VAR 0 6
65475: PUSH
65476: LD_VAR 0 4
65480: ADD
65481: ST_TO_ADDR
65482: GO 65436
65484: POP
65485: POP
// end ;
65486: GO 65418
65488: POP
65489: POP
// list := list diff mc_miners [ i ] ;
65490: LD_ADDR_VAR 0 6
65494: PUSH
65495: LD_VAR 0 6
65499: PUSH
65500: LD_EXP 37
65504: PUSH
65505: LD_VAR 0 2
65509: ARRAY
65510: DIFF
65511: ST_TO_ADDR
// if not list then
65512: LD_VAR 0 6
65516: NOT
65517: IFFALSE 65521
// continue ;
65519: GO 64894
// k := mc_mines [ i ] - mc_miners [ i ] ;
65521: LD_ADDR_VAR 0 4
65525: PUSH
65526: LD_EXP 36
65530: PUSH
65531: LD_VAR 0 2
65535: ARRAY
65536: PUSH
65537: LD_EXP 37
65541: PUSH
65542: LD_VAR 0 2
65546: ARRAY
65547: MINUS
65548: ST_TO_ADDR
// if k > list then
65549: LD_VAR 0 4
65553: PUSH
65554: LD_VAR 0 6
65558: GREATER
65559: IFFALSE 65571
// k := list ;
65561: LD_ADDR_VAR 0 4
65565: PUSH
65566: LD_VAR 0 6
65570: ST_TO_ADDR
// for j = 1 to k do
65571: LD_ADDR_VAR 0 3
65575: PUSH
65576: DOUBLE
65577: LD_INT 1
65579: DEC
65580: ST_TO_ADDR
65581: LD_VAR 0 4
65585: PUSH
65586: FOR_TO
65587: IFFALSE 65641
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
65589: LD_ADDR_EXP 37
65593: PUSH
65594: LD_EXP 37
65598: PPUSH
65599: LD_VAR 0 2
65603: PUSH
65604: LD_EXP 37
65608: PUSH
65609: LD_VAR 0 2
65613: ARRAY
65614: PUSH
65615: LD_INT 1
65617: PLUS
65618: PUSH
65619: EMPTY
65620: LIST
65621: LIST
65622: PPUSH
65623: LD_VAR 0 6
65627: PUSH
65628: LD_VAR 0 3
65632: ARRAY
65633: PPUSH
65634: CALL 16110 0 3
65638: ST_TO_ADDR
65639: GO 65586
65641: POP
65642: POP
// end ;
65643: GO 64894
65645: POP
65646: POP
// end ;
65647: LD_VAR 0 1
65651: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
65652: LD_INT 0
65654: PPUSH
65655: PPUSH
65656: PPUSH
65657: PPUSH
65658: PPUSH
65659: PPUSH
65660: PPUSH
65661: PPUSH
65662: PPUSH
65663: PPUSH
65664: PPUSH
// if not mc_bases then
65665: LD_EXP 23
65669: NOT
65670: IFFALSE 65674
// exit ;
65672: GO 67497
// for i = 1 to mc_bases do
65674: LD_ADDR_VAR 0 2
65678: PUSH
65679: DOUBLE
65680: LD_INT 1
65682: DEC
65683: ST_TO_ADDR
65684: LD_EXP 23
65688: PUSH
65689: FOR_TO
65690: IFFALSE 67495
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
65692: LD_EXP 23
65696: PUSH
65697: LD_VAR 0 2
65701: ARRAY
65702: NOT
65703: PUSH
65704: LD_EXP 30
65708: PUSH
65709: LD_VAR 0 2
65713: ARRAY
65714: OR
65715: IFFALSE 65719
// continue ;
65717: GO 65689
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
65719: LD_EXP 39
65723: PUSH
65724: LD_VAR 0 2
65728: ARRAY
65729: NOT
65730: PUSH
65731: LD_EXP 40
65735: PUSH
65736: LD_VAR 0 2
65740: ARRAY
65741: AND
65742: IFFALSE 65780
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
65744: LD_ADDR_EXP 40
65748: PUSH
65749: LD_EXP 40
65753: PPUSH
65754: LD_VAR 0 2
65758: PPUSH
65759: EMPTY
65760: PPUSH
65761: CALL_OW 1
65765: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
65766: LD_VAR 0 2
65770: PPUSH
65771: LD_INT 107
65773: PPUSH
65774: CALL 56527 0 2
// continue ;
65778: GO 65689
// end ; target := [ ] ;
65780: LD_ADDR_VAR 0 7
65784: PUSH
65785: EMPTY
65786: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
65787: LD_ADDR_VAR 0 6
65791: PUSH
65792: LD_EXP 23
65796: PUSH
65797: LD_VAR 0 2
65801: ARRAY
65802: PUSH
65803: LD_INT 1
65805: ARRAY
65806: PPUSH
65807: CALL_OW 255
65811: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65812: LD_ADDR_VAR 0 9
65816: PUSH
65817: LD_EXP 23
65821: PUSH
65822: LD_VAR 0 2
65826: ARRAY
65827: PPUSH
65828: LD_INT 2
65830: PUSH
65831: LD_INT 30
65833: PUSH
65834: LD_INT 0
65836: PUSH
65837: EMPTY
65838: LIST
65839: LIST
65840: PUSH
65841: LD_INT 30
65843: PUSH
65844: LD_INT 1
65846: PUSH
65847: EMPTY
65848: LIST
65849: LIST
65850: PUSH
65851: EMPTY
65852: LIST
65853: LIST
65854: LIST
65855: PPUSH
65856: CALL_OW 72
65860: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
65861: LD_ADDR_VAR 0 3
65865: PUSH
65866: DOUBLE
65867: LD_EXP 39
65871: PUSH
65872: LD_VAR 0 2
65876: ARRAY
65877: INC
65878: ST_TO_ADDR
65879: LD_INT 1
65881: PUSH
65882: FOR_DOWNTO
65883: IFFALSE 66128
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
65885: LD_EXP 39
65889: PUSH
65890: LD_VAR 0 2
65894: ARRAY
65895: PUSH
65896: LD_VAR 0 3
65900: ARRAY
65901: PUSH
65902: LD_INT 2
65904: ARRAY
65905: PPUSH
65906: LD_EXP 39
65910: PUSH
65911: LD_VAR 0 2
65915: ARRAY
65916: PUSH
65917: LD_VAR 0 3
65921: ARRAY
65922: PUSH
65923: LD_INT 3
65925: ARRAY
65926: PPUSH
65927: CALL_OW 488
65931: PUSH
65932: LD_EXP 39
65936: PUSH
65937: LD_VAR 0 2
65941: ARRAY
65942: PUSH
65943: LD_VAR 0 3
65947: ARRAY
65948: PUSH
65949: LD_INT 2
65951: ARRAY
65952: PPUSH
65953: LD_EXP 39
65957: PUSH
65958: LD_VAR 0 2
65962: ARRAY
65963: PUSH
65964: LD_VAR 0 3
65968: ARRAY
65969: PUSH
65970: LD_INT 3
65972: ARRAY
65973: PPUSH
65974: CALL_OW 284
65978: PUSH
65979: LD_INT 0
65981: EQUAL
65982: AND
65983: IFFALSE 66038
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
65985: LD_ADDR_VAR 0 5
65989: PUSH
65990: LD_EXP 39
65994: PUSH
65995: LD_VAR 0 2
65999: ARRAY
66000: PPUSH
66001: LD_VAR 0 3
66005: PPUSH
66006: CALL_OW 3
66010: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
66011: LD_ADDR_EXP 39
66015: PUSH
66016: LD_EXP 39
66020: PPUSH
66021: LD_VAR 0 2
66025: PPUSH
66026: LD_VAR 0 5
66030: PPUSH
66031: CALL_OW 1
66035: ST_TO_ADDR
// continue ;
66036: GO 65882
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
66038: LD_VAR 0 6
66042: PPUSH
66043: LD_EXP 39
66047: PUSH
66048: LD_VAR 0 2
66052: ARRAY
66053: PUSH
66054: LD_VAR 0 3
66058: ARRAY
66059: PUSH
66060: LD_INT 2
66062: ARRAY
66063: PPUSH
66064: LD_EXP 39
66068: PUSH
66069: LD_VAR 0 2
66073: ARRAY
66074: PUSH
66075: LD_VAR 0 3
66079: ARRAY
66080: PUSH
66081: LD_INT 3
66083: ARRAY
66084: PPUSH
66085: LD_INT 30
66087: PPUSH
66088: CALL 17006 0 4
66092: PUSH
66093: LD_INT 4
66095: ARRAY
66096: PUSH
66097: LD_INT 0
66099: EQUAL
66100: IFFALSE 66126
// begin target := mc_crates [ i ] [ j ] ;
66102: LD_ADDR_VAR 0 7
66106: PUSH
66107: LD_EXP 39
66111: PUSH
66112: LD_VAR 0 2
66116: ARRAY
66117: PUSH
66118: LD_VAR 0 3
66122: ARRAY
66123: ST_TO_ADDR
// break ;
66124: GO 66128
// end ; end ;
66126: GO 65882
66128: POP
66129: POP
// if not target then
66130: LD_VAR 0 7
66134: NOT
66135: IFFALSE 66139
// continue ;
66137: GO 65689
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
66139: LD_ADDR_VAR 0 8
66143: PUSH
66144: LD_EXP 42
66148: PUSH
66149: LD_VAR 0 2
66153: ARRAY
66154: PPUSH
66155: LD_INT 2
66157: PUSH
66158: LD_INT 3
66160: PUSH
66161: LD_INT 58
66163: PUSH
66164: EMPTY
66165: LIST
66166: PUSH
66167: EMPTY
66168: LIST
66169: LIST
66170: PUSH
66171: LD_INT 61
66173: PUSH
66174: EMPTY
66175: LIST
66176: PUSH
66177: LD_INT 33
66179: PUSH
66180: LD_INT 5
66182: PUSH
66183: EMPTY
66184: LIST
66185: LIST
66186: PUSH
66187: LD_INT 33
66189: PUSH
66190: LD_INT 3
66192: PUSH
66193: EMPTY
66194: LIST
66195: LIST
66196: PUSH
66197: EMPTY
66198: LIST
66199: LIST
66200: LIST
66201: LIST
66202: LIST
66203: PUSH
66204: LD_INT 2
66206: PUSH
66207: LD_INT 34
66209: PUSH
66210: LD_INT 32
66212: PUSH
66213: EMPTY
66214: LIST
66215: LIST
66216: PUSH
66217: LD_INT 34
66219: PUSH
66220: LD_INT 51
66222: PUSH
66223: EMPTY
66224: LIST
66225: LIST
66226: PUSH
66227: LD_INT 34
66229: PUSH
66230: LD_INT 12
66232: PUSH
66233: EMPTY
66234: LIST
66235: LIST
66236: PUSH
66237: EMPTY
66238: LIST
66239: LIST
66240: LIST
66241: LIST
66242: PUSH
66243: EMPTY
66244: LIST
66245: LIST
66246: PPUSH
66247: CALL_OW 72
66251: ST_TO_ADDR
// if not cargo then
66252: LD_VAR 0 8
66256: NOT
66257: IFFALSE 66963
// begin if mc_crates_collector [ i ] < 5 then
66259: LD_EXP 40
66263: PUSH
66264: LD_VAR 0 2
66268: ARRAY
66269: PUSH
66270: LD_INT 5
66272: LESS
66273: IFFALSE 66639
// begin if mc_ape [ i ] then
66275: LD_EXP 52
66279: PUSH
66280: LD_VAR 0 2
66284: ARRAY
66285: IFFALSE 66332
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
66287: LD_ADDR_VAR 0 5
66291: PUSH
66292: LD_EXP 52
66296: PUSH
66297: LD_VAR 0 2
66301: ARRAY
66302: PPUSH
66303: LD_INT 25
66305: PUSH
66306: LD_INT 16
66308: PUSH
66309: EMPTY
66310: LIST
66311: LIST
66312: PUSH
66313: LD_INT 24
66315: PUSH
66316: LD_INT 750
66318: PUSH
66319: EMPTY
66320: LIST
66321: LIST
66322: PUSH
66323: EMPTY
66324: LIST
66325: LIST
66326: PPUSH
66327: CALL_OW 72
66331: ST_TO_ADDR
// if not tmp then
66332: LD_VAR 0 5
66336: NOT
66337: IFFALSE 66384
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
66339: LD_ADDR_VAR 0 5
66343: PUSH
66344: LD_EXP 23
66348: PUSH
66349: LD_VAR 0 2
66353: ARRAY
66354: PPUSH
66355: LD_INT 25
66357: PUSH
66358: LD_INT 2
66360: PUSH
66361: EMPTY
66362: LIST
66363: LIST
66364: PUSH
66365: LD_INT 24
66367: PUSH
66368: LD_INT 750
66370: PUSH
66371: EMPTY
66372: LIST
66373: LIST
66374: PUSH
66375: EMPTY
66376: LIST
66377: LIST
66378: PPUSH
66379: CALL_OW 72
66383: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
66384: LD_EXP 52
66388: PUSH
66389: LD_VAR 0 2
66393: ARRAY
66394: PUSH
66395: LD_EXP 23
66399: PUSH
66400: LD_VAR 0 2
66404: ARRAY
66405: PPUSH
66406: LD_INT 25
66408: PUSH
66409: LD_INT 2
66411: PUSH
66412: EMPTY
66413: LIST
66414: LIST
66415: PUSH
66416: LD_INT 24
66418: PUSH
66419: LD_INT 750
66421: PUSH
66422: EMPTY
66423: LIST
66424: LIST
66425: PUSH
66426: EMPTY
66427: LIST
66428: LIST
66429: PPUSH
66430: CALL_OW 72
66434: AND
66435: PUSH
66436: LD_VAR 0 5
66440: PUSH
66441: LD_INT 5
66443: LESS
66444: AND
66445: IFFALSE 66527
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
66447: LD_ADDR_VAR 0 3
66451: PUSH
66452: LD_EXP 23
66456: PUSH
66457: LD_VAR 0 2
66461: ARRAY
66462: PPUSH
66463: LD_INT 25
66465: PUSH
66466: LD_INT 2
66468: PUSH
66469: EMPTY
66470: LIST
66471: LIST
66472: PUSH
66473: LD_INT 24
66475: PUSH
66476: LD_INT 750
66478: PUSH
66479: EMPTY
66480: LIST
66481: LIST
66482: PUSH
66483: EMPTY
66484: LIST
66485: LIST
66486: PPUSH
66487: CALL_OW 72
66491: PUSH
66492: FOR_IN
66493: IFFALSE 66525
// begin tmp := tmp union j ;
66495: LD_ADDR_VAR 0 5
66499: PUSH
66500: LD_VAR 0 5
66504: PUSH
66505: LD_VAR 0 3
66509: UNION
66510: ST_TO_ADDR
// if tmp >= 5 then
66511: LD_VAR 0 5
66515: PUSH
66516: LD_INT 5
66518: GREATEREQUAL
66519: IFFALSE 66523
// break ;
66521: GO 66525
// end ;
66523: GO 66492
66525: POP
66526: POP
// end ; if not tmp then
66527: LD_VAR 0 5
66531: NOT
66532: IFFALSE 66536
// continue ;
66534: GO 65689
// for j in tmp do
66536: LD_ADDR_VAR 0 3
66540: PUSH
66541: LD_VAR 0 5
66545: PUSH
66546: FOR_IN
66547: IFFALSE 66637
// if not GetTag ( j ) then
66549: LD_VAR 0 3
66553: PPUSH
66554: CALL_OW 110
66558: NOT
66559: IFFALSE 66635
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
66561: LD_ADDR_EXP 40
66565: PUSH
66566: LD_EXP 40
66570: PPUSH
66571: LD_VAR 0 2
66575: PUSH
66576: LD_EXP 40
66580: PUSH
66581: LD_VAR 0 2
66585: ARRAY
66586: PUSH
66587: LD_INT 1
66589: PLUS
66590: PUSH
66591: EMPTY
66592: LIST
66593: LIST
66594: PPUSH
66595: LD_VAR 0 3
66599: PPUSH
66600: CALL 16110 0 3
66604: ST_TO_ADDR
// SetTag ( j , 107 ) ;
66605: LD_VAR 0 3
66609: PPUSH
66610: LD_INT 107
66612: PPUSH
66613: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
66617: LD_EXP 40
66621: PUSH
66622: LD_VAR 0 2
66626: ARRAY
66627: PUSH
66628: LD_INT 5
66630: GREATEREQUAL
66631: IFFALSE 66635
// break ;
66633: GO 66637
// end ;
66635: GO 66546
66637: POP
66638: POP
// end ; if mc_crates_collector [ i ] and target then
66639: LD_EXP 40
66643: PUSH
66644: LD_VAR 0 2
66648: ARRAY
66649: PUSH
66650: LD_VAR 0 7
66654: AND
66655: IFFALSE 66961
// begin if mc_crates_collector [ i ] < target [ 1 ] then
66657: LD_EXP 40
66661: PUSH
66662: LD_VAR 0 2
66666: ARRAY
66667: PUSH
66668: LD_VAR 0 7
66672: PUSH
66673: LD_INT 1
66675: ARRAY
66676: LESS
66677: IFFALSE 66697
// tmp := mc_crates_collector [ i ] else
66679: LD_ADDR_VAR 0 5
66683: PUSH
66684: LD_EXP 40
66688: PUSH
66689: LD_VAR 0 2
66693: ARRAY
66694: ST_TO_ADDR
66695: GO 66711
// tmp := target [ 1 ] ;
66697: LD_ADDR_VAR 0 5
66701: PUSH
66702: LD_VAR 0 7
66706: PUSH
66707: LD_INT 1
66709: ARRAY
66710: ST_TO_ADDR
// k := 0 ;
66711: LD_ADDR_VAR 0 4
66715: PUSH
66716: LD_INT 0
66718: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
66719: LD_ADDR_VAR 0 3
66723: PUSH
66724: LD_EXP 40
66728: PUSH
66729: LD_VAR 0 2
66733: ARRAY
66734: PUSH
66735: FOR_IN
66736: IFFALSE 66959
// begin k := k + 1 ;
66738: LD_ADDR_VAR 0 4
66742: PUSH
66743: LD_VAR 0 4
66747: PUSH
66748: LD_INT 1
66750: PLUS
66751: ST_TO_ADDR
// if k > tmp then
66752: LD_VAR 0 4
66756: PUSH
66757: LD_VAR 0 5
66761: GREATER
66762: IFFALSE 66766
// break ;
66764: GO 66959
// if not GetClass ( j ) in [ 2 , 16 ] then
66766: LD_VAR 0 3
66770: PPUSH
66771: CALL_OW 257
66775: PUSH
66776: LD_INT 2
66778: PUSH
66779: LD_INT 16
66781: PUSH
66782: EMPTY
66783: LIST
66784: LIST
66785: IN
66786: NOT
66787: IFFALSE 66840
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
66789: LD_ADDR_EXP 40
66793: PUSH
66794: LD_EXP 40
66798: PPUSH
66799: LD_VAR 0 2
66803: PPUSH
66804: LD_EXP 40
66808: PUSH
66809: LD_VAR 0 2
66813: ARRAY
66814: PUSH
66815: LD_VAR 0 3
66819: DIFF
66820: PPUSH
66821: CALL_OW 1
66825: ST_TO_ADDR
// SetTag ( j , 0 ) ;
66826: LD_VAR 0 3
66830: PPUSH
66831: LD_INT 0
66833: PPUSH
66834: CALL_OW 109
// continue ;
66838: GO 66735
// end ; if IsInUnit ( j ) then
66840: LD_VAR 0 3
66844: PPUSH
66845: CALL_OW 310
66849: IFFALSE 66860
// ComExitBuilding ( j ) ;
66851: LD_VAR 0 3
66855: PPUSH
66856: CALL_OW 122
// wait ( 3 ) ;
66860: LD_INT 3
66862: PPUSH
66863: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
66867: LD_VAR 0 3
66871: PPUSH
66872: CALL_OW 314
66876: PUSH
66877: LD_VAR 0 6
66881: PPUSH
66882: LD_VAR 0 7
66886: PUSH
66887: LD_INT 2
66889: ARRAY
66890: PPUSH
66891: LD_VAR 0 7
66895: PUSH
66896: LD_INT 3
66898: ARRAY
66899: PPUSH
66900: LD_INT 30
66902: PPUSH
66903: CALL 17006 0 4
66907: PUSH
66908: LD_INT 4
66910: ARRAY
66911: AND
66912: IFFALSE 66930
// ComStandNearbyBuilding ( j , depot ) else
66914: LD_VAR 0 3
66918: PPUSH
66919: LD_VAR 0 9
66923: PPUSH
66924: CALL 12537 0 2
66928: GO 66957
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
66930: LD_VAR 0 3
66934: PPUSH
66935: LD_VAR 0 7
66939: PUSH
66940: LD_INT 2
66942: ARRAY
66943: PPUSH
66944: LD_VAR 0 7
66948: PUSH
66949: LD_INT 3
66951: ARRAY
66952: PPUSH
66953: CALL_OW 117
// end ;
66957: GO 66735
66959: POP
66960: POP
// end ; end else
66961: GO 67493
// begin for j in cargo do
66963: LD_ADDR_VAR 0 3
66967: PUSH
66968: LD_VAR 0 8
66972: PUSH
66973: FOR_IN
66974: IFFALSE 67491
// begin if GetTag ( j ) <> 0 then
66976: LD_VAR 0 3
66980: PPUSH
66981: CALL_OW 110
66985: PUSH
66986: LD_INT 0
66988: NONEQUAL
66989: IFFALSE 66993
// continue ;
66991: GO 66973
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
66993: LD_VAR 0 3
66997: PPUSH
66998: CALL_OW 256
67002: PUSH
67003: LD_INT 1000
67005: LESS
67006: PUSH
67007: LD_VAR 0 3
67011: PPUSH
67012: LD_EXP 47
67016: PUSH
67017: LD_VAR 0 2
67021: ARRAY
67022: PPUSH
67023: CALL_OW 308
67027: NOT
67028: AND
67029: IFFALSE 67051
// ComMoveToArea ( j , mc_parking [ i ] ) ;
67031: LD_VAR 0 3
67035: PPUSH
67036: LD_EXP 47
67040: PUSH
67041: LD_VAR 0 2
67045: ARRAY
67046: PPUSH
67047: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
67051: LD_VAR 0 3
67055: PPUSH
67056: CALL_OW 256
67060: PUSH
67061: LD_INT 1000
67063: LESS
67064: PUSH
67065: LD_VAR 0 3
67069: PPUSH
67070: LD_EXP 47
67074: PUSH
67075: LD_VAR 0 2
67079: ARRAY
67080: PPUSH
67081: CALL_OW 308
67085: AND
67086: IFFALSE 67090
// continue ;
67088: GO 66973
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
67090: LD_VAR 0 3
67094: PPUSH
67095: CALL_OW 262
67099: PUSH
67100: LD_INT 2
67102: EQUAL
67103: PUSH
67104: LD_VAR 0 3
67108: PPUSH
67109: CALL_OW 261
67113: PUSH
67114: LD_INT 15
67116: LESS
67117: AND
67118: IFFALSE 67122
// continue ;
67120: GO 66973
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
67122: LD_VAR 0 3
67126: PPUSH
67127: CALL_OW 262
67131: PUSH
67132: LD_INT 1
67134: EQUAL
67135: PUSH
67136: LD_VAR 0 3
67140: PPUSH
67141: CALL_OW 261
67145: PUSH
67146: LD_INT 10
67148: LESS
67149: AND
67150: IFFALSE 67430
// begin if not depot then
67152: LD_VAR 0 9
67156: NOT
67157: IFFALSE 67161
// continue ;
67159: GO 66973
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
67161: LD_VAR 0 3
67165: PPUSH
67166: LD_VAR 0 9
67170: PPUSH
67171: LD_VAR 0 3
67175: PPUSH
67176: CALL_OW 74
67180: PPUSH
67181: CALL_OW 296
67185: PUSH
67186: LD_INT 6
67188: LESS
67189: IFFALSE 67205
// SetFuel ( j , 100 ) else
67191: LD_VAR 0 3
67195: PPUSH
67196: LD_INT 100
67198: PPUSH
67199: CALL_OW 240
67203: GO 67430
// if GetFuel ( j ) = 0 then
67205: LD_VAR 0 3
67209: PPUSH
67210: CALL_OW 261
67214: PUSH
67215: LD_INT 0
67217: EQUAL
67218: IFFALSE 67430
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
67220: LD_ADDR_EXP 42
67224: PUSH
67225: LD_EXP 42
67229: PPUSH
67230: LD_VAR 0 2
67234: PPUSH
67235: LD_EXP 42
67239: PUSH
67240: LD_VAR 0 2
67244: ARRAY
67245: PUSH
67246: LD_VAR 0 3
67250: DIFF
67251: PPUSH
67252: CALL_OW 1
67256: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
67257: LD_VAR 0 3
67261: PPUSH
67262: CALL_OW 263
67266: PUSH
67267: LD_INT 1
67269: EQUAL
67270: IFFALSE 67286
// ComExitVehicle ( IsInUnit ( j ) ) ;
67272: LD_VAR 0 3
67276: PPUSH
67277: CALL_OW 310
67281: PPUSH
67282: CALL_OW 121
// if GetControl ( j ) = control_remote then
67286: LD_VAR 0 3
67290: PPUSH
67291: CALL_OW 263
67295: PUSH
67296: LD_INT 2
67298: EQUAL
67299: IFFALSE 67310
// ComUnlink ( j ) ;
67301: LD_VAR 0 3
67305: PPUSH
67306: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
67310: LD_ADDR_VAR 0 10
67314: PUSH
67315: LD_VAR 0 2
67319: PPUSH
67320: LD_INT 3
67322: PPUSH
67323: CALL 77097 0 2
67327: ST_TO_ADDR
// if fac then
67328: LD_VAR 0 10
67332: IFFALSE 67428
// begin for k in fac do
67334: LD_ADDR_VAR 0 4
67338: PUSH
67339: LD_VAR 0 10
67343: PUSH
67344: FOR_IN
67345: IFFALSE 67426
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
67347: LD_ADDR_VAR 0 11
67351: PUSH
67352: LD_VAR 0 10
67356: PPUSH
67357: LD_VAR 0 3
67361: PPUSH
67362: CALL_OW 265
67366: PPUSH
67367: LD_VAR 0 3
67371: PPUSH
67372: CALL_OW 262
67376: PPUSH
67377: LD_VAR 0 3
67381: PPUSH
67382: CALL_OW 263
67386: PPUSH
67387: LD_VAR 0 3
67391: PPUSH
67392: CALL_OW 264
67396: PPUSH
67397: CALL 13608 0 5
67401: ST_TO_ADDR
// if components then
67402: LD_VAR 0 11
67406: IFFALSE 67424
// begin MC_InsertProduceList ( i , components ) ;
67408: LD_VAR 0 2
67412: PPUSH
67413: LD_VAR 0 11
67417: PPUSH
67418: CALL 76642 0 2
// break ;
67422: GO 67426
// end ; end ;
67424: GO 67344
67426: POP
67427: POP
// end ; continue ;
67428: GO 66973
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
67430: LD_VAR 0 3
67434: PPUSH
67435: LD_INT 1
67437: PPUSH
67438: CALL_OW 289
67442: PUSH
67443: LD_INT 100
67445: LESS
67446: PUSH
67447: LD_VAR 0 3
67451: PPUSH
67452: CALL_OW 314
67456: NOT
67457: AND
67458: IFFALSE 67487
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
67460: LD_VAR 0 3
67464: PPUSH
67465: LD_VAR 0 7
67469: PUSH
67470: LD_INT 2
67472: ARRAY
67473: PPUSH
67474: LD_VAR 0 7
67478: PUSH
67479: LD_INT 3
67481: ARRAY
67482: PPUSH
67483: CALL_OW 117
// break ;
67487: GO 67491
// end ;
67489: GO 66973
67491: POP
67492: POP
// end ; end ;
67493: GO 65689
67495: POP
67496: POP
// end ;
67497: LD_VAR 0 1
67501: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
67502: LD_INT 0
67504: PPUSH
67505: PPUSH
67506: PPUSH
67507: PPUSH
// if not mc_bases then
67508: LD_EXP 23
67512: NOT
67513: IFFALSE 67517
// exit ;
67515: GO 67678
// for i = 1 to mc_bases do
67517: LD_ADDR_VAR 0 2
67521: PUSH
67522: DOUBLE
67523: LD_INT 1
67525: DEC
67526: ST_TO_ADDR
67527: LD_EXP 23
67531: PUSH
67532: FOR_TO
67533: IFFALSE 67676
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
67535: LD_ADDR_VAR 0 4
67539: PUSH
67540: LD_EXP 42
67544: PUSH
67545: LD_VAR 0 2
67549: ARRAY
67550: PUSH
67551: LD_EXP 45
67555: PUSH
67556: LD_VAR 0 2
67560: ARRAY
67561: UNION
67562: PPUSH
67563: LD_INT 33
67565: PUSH
67566: LD_INT 2
67568: PUSH
67569: EMPTY
67570: LIST
67571: LIST
67572: PPUSH
67573: CALL_OW 72
67577: ST_TO_ADDR
// if tmp then
67578: LD_VAR 0 4
67582: IFFALSE 67674
// for j in tmp do
67584: LD_ADDR_VAR 0 3
67588: PUSH
67589: LD_VAR 0 4
67593: PUSH
67594: FOR_IN
67595: IFFALSE 67672
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
67597: LD_VAR 0 3
67601: PPUSH
67602: CALL_OW 312
67606: NOT
67607: PUSH
67608: LD_VAR 0 3
67612: PPUSH
67613: CALL_OW 256
67617: PUSH
67618: LD_INT 250
67620: GREATEREQUAL
67621: AND
67622: IFFALSE 67635
// Connect ( j ) else
67624: LD_VAR 0 3
67628: PPUSH
67629: CALL 19079 0 1
67633: GO 67670
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
67635: LD_VAR 0 3
67639: PPUSH
67640: CALL_OW 256
67644: PUSH
67645: LD_INT 250
67647: LESS
67648: PUSH
67649: LD_VAR 0 3
67653: PPUSH
67654: CALL_OW 312
67658: AND
67659: IFFALSE 67670
// ComUnlink ( j ) ;
67661: LD_VAR 0 3
67665: PPUSH
67666: CALL_OW 136
67670: GO 67594
67672: POP
67673: POP
// end ;
67674: GO 67532
67676: POP
67677: POP
// end ;
67678: LD_VAR 0 1
67682: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
67683: LD_INT 0
67685: PPUSH
67686: PPUSH
67687: PPUSH
67688: PPUSH
67689: PPUSH
// if not mc_bases then
67690: LD_EXP 23
67694: NOT
67695: IFFALSE 67699
// exit ;
67697: GO 68144
// for i = 1 to mc_bases do
67699: LD_ADDR_VAR 0 2
67703: PUSH
67704: DOUBLE
67705: LD_INT 1
67707: DEC
67708: ST_TO_ADDR
67709: LD_EXP 23
67713: PUSH
67714: FOR_TO
67715: IFFALSE 68142
// begin if not mc_produce [ i ] then
67717: LD_EXP 44
67721: PUSH
67722: LD_VAR 0 2
67726: ARRAY
67727: NOT
67728: IFFALSE 67732
// continue ;
67730: GO 67714
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
67732: LD_ADDR_VAR 0 5
67736: PUSH
67737: LD_EXP 23
67741: PUSH
67742: LD_VAR 0 2
67746: ARRAY
67747: PPUSH
67748: LD_INT 30
67750: PUSH
67751: LD_INT 3
67753: PUSH
67754: EMPTY
67755: LIST
67756: LIST
67757: PPUSH
67758: CALL_OW 72
67762: ST_TO_ADDR
// if not fac then
67763: LD_VAR 0 5
67767: NOT
67768: IFFALSE 67772
// continue ;
67770: GO 67714
// for j in fac do
67772: LD_ADDR_VAR 0 3
67776: PUSH
67777: LD_VAR 0 5
67781: PUSH
67782: FOR_IN
67783: IFFALSE 68138
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
67785: LD_VAR 0 3
67789: PPUSH
67790: CALL_OW 461
67794: PUSH
67795: LD_INT 2
67797: NONEQUAL
67798: PUSH
67799: LD_VAR 0 3
67803: PPUSH
67804: LD_INT 15
67806: PPUSH
67807: CALL 18707 0 2
67811: PUSH
67812: LD_INT 4
67814: ARRAY
67815: OR
67816: IFFALSE 67820
// continue ;
67818: GO 67782
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
67820: LD_VAR 0 3
67824: PPUSH
67825: LD_EXP 44
67829: PUSH
67830: LD_VAR 0 2
67834: ARRAY
67835: PUSH
67836: LD_INT 1
67838: ARRAY
67839: PUSH
67840: LD_INT 1
67842: ARRAY
67843: PPUSH
67844: LD_EXP 44
67848: PUSH
67849: LD_VAR 0 2
67853: ARRAY
67854: PUSH
67855: LD_INT 1
67857: ARRAY
67858: PUSH
67859: LD_INT 2
67861: ARRAY
67862: PPUSH
67863: LD_EXP 44
67867: PUSH
67868: LD_VAR 0 2
67872: ARRAY
67873: PUSH
67874: LD_INT 1
67876: ARRAY
67877: PUSH
67878: LD_INT 3
67880: ARRAY
67881: PPUSH
67882: LD_EXP 44
67886: PUSH
67887: LD_VAR 0 2
67891: ARRAY
67892: PUSH
67893: LD_INT 1
67895: ARRAY
67896: PUSH
67897: LD_INT 4
67899: ARRAY
67900: PPUSH
67901: CALL_OW 448
67905: PUSH
67906: LD_VAR 0 3
67910: PPUSH
67911: LD_EXP 44
67915: PUSH
67916: LD_VAR 0 2
67920: ARRAY
67921: PUSH
67922: LD_INT 1
67924: ARRAY
67925: PUSH
67926: LD_INT 1
67928: ARRAY
67929: PUSH
67930: LD_EXP 44
67934: PUSH
67935: LD_VAR 0 2
67939: ARRAY
67940: PUSH
67941: LD_INT 1
67943: ARRAY
67944: PUSH
67945: LD_INT 2
67947: ARRAY
67948: PUSH
67949: LD_EXP 44
67953: PUSH
67954: LD_VAR 0 2
67958: ARRAY
67959: PUSH
67960: LD_INT 1
67962: ARRAY
67963: PUSH
67964: LD_INT 3
67966: ARRAY
67967: PUSH
67968: LD_EXP 44
67972: PUSH
67973: LD_VAR 0 2
67977: ARRAY
67978: PUSH
67979: LD_INT 1
67981: ARRAY
67982: PUSH
67983: LD_INT 4
67985: ARRAY
67986: PUSH
67987: EMPTY
67988: LIST
67989: LIST
67990: LIST
67991: LIST
67992: PPUSH
67993: CALL 22474 0 2
67997: AND
67998: IFFALSE 68136
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
68000: LD_VAR 0 3
68004: PPUSH
68005: LD_EXP 44
68009: PUSH
68010: LD_VAR 0 2
68014: ARRAY
68015: PUSH
68016: LD_INT 1
68018: ARRAY
68019: PUSH
68020: LD_INT 1
68022: ARRAY
68023: PPUSH
68024: LD_EXP 44
68028: PUSH
68029: LD_VAR 0 2
68033: ARRAY
68034: PUSH
68035: LD_INT 1
68037: ARRAY
68038: PUSH
68039: LD_INT 2
68041: ARRAY
68042: PPUSH
68043: LD_EXP 44
68047: PUSH
68048: LD_VAR 0 2
68052: ARRAY
68053: PUSH
68054: LD_INT 1
68056: ARRAY
68057: PUSH
68058: LD_INT 3
68060: ARRAY
68061: PPUSH
68062: LD_EXP 44
68066: PUSH
68067: LD_VAR 0 2
68071: ARRAY
68072: PUSH
68073: LD_INT 1
68075: ARRAY
68076: PUSH
68077: LD_INT 4
68079: ARRAY
68080: PPUSH
68081: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
68085: LD_ADDR_VAR 0 4
68089: PUSH
68090: LD_EXP 44
68094: PUSH
68095: LD_VAR 0 2
68099: ARRAY
68100: PPUSH
68101: LD_INT 1
68103: PPUSH
68104: CALL_OW 3
68108: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
68109: LD_ADDR_EXP 44
68113: PUSH
68114: LD_EXP 44
68118: PPUSH
68119: LD_VAR 0 2
68123: PPUSH
68124: LD_VAR 0 4
68128: PPUSH
68129: CALL_OW 1
68133: ST_TO_ADDR
// break ;
68134: GO 68138
// end ; end ;
68136: GO 67782
68138: POP
68139: POP
// end ;
68140: GO 67714
68142: POP
68143: POP
// end ;
68144: LD_VAR 0 1
68148: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
68149: LD_INT 0
68151: PPUSH
68152: PPUSH
68153: PPUSH
// if not mc_bases then
68154: LD_EXP 23
68158: NOT
68159: IFFALSE 68163
// exit ;
68161: GO 68252
// for i = 1 to mc_bases do
68163: LD_ADDR_VAR 0 2
68167: PUSH
68168: DOUBLE
68169: LD_INT 1
68171: DEC
68172: ST_TO_ADDR
68173: LD_EXP 23
68177: PUSH
68178: FOR_TO
68179: IFFALSE 68250
// begin if mc_attack [ i ] then
68181: LD_EXP 43
68185: PUSH
68186: LD_VAR 0 2
68190: ARRAY
68191: IFFALSE 68248
// begin tmp := mc_attack [ i ] [ 1 ] ;
68193: LD_ADDR_VAR 0 3
68197: PUSH
68198: LD_EXP 43
68202: PUSH
68203: LD_VAR 0 2
68207: ARRAY
68208: PUSH
68209: LD_INT 1
68211: ARRAY
68212: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
68213: LD_ADDR_EXP 43
68217: PUSH
68218: LD_EXP 43
68222: PPUSH
68223: LD_VAR 0 2
68227: PPUSH
68228: EMPTY
68229: PPUSH
68230: CALL_OW 1
68234: ST_TO_ADDR
// Attack ( tmp ) ;
68235: LD_VAR 0 3
68239: PPUSH
68240: CALL 83030 0 1
// exit ;
68244: POP
68245: POP
68246: GO 68252
// end ; end ;
68248: GO 68178
68250: POP
68251: POP
// end ;
68252: LD_VAR 0 1
68256: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
68257: LD_INT 0
68259: PPUSH
68260: PPUSH
68261: PPUSH
68262: PPUSH
68263: PPUSH
68264: PPUSH
68265: PPUSH
// if not mc_bases then
68266: LD_EXP 23
68270: NOT
68271: IFFALSE 68275
// exit ;
68273: GO 69132
// for i = 1 to mc_bases do
68275: LD_ADDR_VAR 0 2
68279: PUSH
68280: DOUBLE
68281: LD_INT 1
68283: DEC
68284: ST_TO_ADDR
68285: LD_EXP 23
68289: PUSH
68290: FOR_TO
68291: IFFALSE 69130
// begin if not mc_bases [ i ] then
68293: LD_EXP 23
68297: PUSH
68298: LD_VAR 0 2
68302: ARRAY
68303: NOT
68304: IFFALSE 68308
// continue ;
68306: GO 68290
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
68308: LD_ADDR_VAR 0 7
68312: PUSH
68313: LD_EXP 23
68317: PUSH
68318: LD_VAR 0 2
68322: ARRAY
68323: PUSH
68324: LD_INT 1
68326: ARRAY
68327: PPUSH
68328: CALL 12759 0 1
68332: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
68333: LD_ADDR_EXP 46
68337: PUSH
68338: LD_EXP 46
68342: PPUSH
68343: LD_VAR 0 2
68347: PPUSH
68348: LD_EXP 23
68352: PUSH
68353: LD_VAR 0 2
68357: ARRAY
68358: PUSH
68359: LD_INT 1
68361: ARRAY
68362: PPUSH
68363: CALL_OW 255
68367: PPUSH
68368: LD_EXP 48
68372: PUSH
68373: LD_VAR 0 2
68377: ARRAY
68378: PPUSH
68379: CALL 12724 0 2
68383: PPUSH
68384: CALL_OW 1
68388: ST_TO_ADDR
// if not mc_scan [ i ] then
68389: LD_EXP 46
68393: PUSH
68394: LD_VAR 0 2
68398: ARRAY
68399: NOT
68400: IFFALSE 68578
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
68402: LD_ADDR_EXP 66
68406: PUSH
68407: LD_EXP 66
68411: PPUSH
68412: LD_VAR 0 2
68416: PPUSH
68417: LD_INT 0
68419: PPUSH
68420: CALL_OW 1
68424: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
68425: LD_ADDR_VAR 0 4
68429: PUSH
68430: LD_EXP 23
68434: PUSH
68435: LD_VAR 0 2
68439: ARRAY
68440: PPUSH
68441: LD_INT 2
68443: PUSH
68444: LD_INT 25
68446: PUSH
68447: LD_INT 5
68449: PUSH
68450: EMPTY
68451: LIST
68452: LIST
68453: PUSH
68454: LD_INT 25
68456: PUSH
68457: LD_INT 8
68459: PUSH
68460: EMPTY
68461: LIST
68462: LIST
68463: PUSH
68464: LD_INT 25
68466: PUSH
68467: LD_INT 9
68469: PUSH
68470: EMPTY
68471: LIST
68472: LIST
68473: PUSH
68474: EMPTY
68475: LIST
68476: LIST
68477: LIST
68478: LIST
68479: PPUSH
68480: CALL_OW 72
68484: ST_TO_ADDR
// if not tmp then
68485: LD_VAR 0 4
68489: NOT
68490: IFFALSE 68494
// continue ;
68492: GO 68290
// for j in tmp do
68494: LD_ADDR_VAR 0 3
68498: PUSH
68499: LD_VAR 0 4
68503: PUSH
68504: FOR_IN
68505: IFFALSE 68576
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
68507: LD_VAR 0 3
68511: PPUSH
68512: CALL_OW 310
68516: PPUSH
68517: CALL_OW 266
68521: PUSH
68522: LD_INT 5
68524: EQUAL
68525: PUSH
68526: LD_VAR 0 3
68530: PPUSH
68531: CALL_OW 257
68535: PUSH
68536: LD_INT 1
68538: EQUAL
68539: AND
68540: PUSH
68541: LD_VAR 0 3
68545: PPUSH
68546: CALL_OW 459
68550: NOT
68551: AND
68552: PUSH
68553: LD_VAR 0 7
68557: AND
68558: IFFALSE 68574
// ComChangeProfession ( j , class ) ;
68560: LD_VAR 0 3
68564: PPUSH
68565: LD_VAR 0 7
68569: PPUSH
68570: CALL_OW 123
68574: GO 68504
68576: POP
68577: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
68578: LD_EXP 46
68582: PUSH
68583: LD_VAR 0 2
68587: ARRAY
68588: PUSH
68589: LD_EXP 66
68593: PUSH
68594: LD_VAR 0 2
68598: ARRAY
68599: NOT
68600: AND
68601: PUSH
68602: LD_EXP 45
68606: PUSH
68607: LD_VAR 0 2
68611: ARRAY
68612: NOT
68613: AND
68614: PUSH
68615: LD_EXP 23
68619: PUSH
68620: LD_VAR 0 2
68624: ARRAY
68625: PPUSH
68626: LD_INT 50
68628: PUSH
68629: EMPTY
68630: LIST
68631: PUSH
68632: LD_INT 2
68634: PUSH
68635: LD_INT 30
68637: PUSH
68638: LD_INT 32
68640: PUSH
68641: EMPTY
68642: LIST
68643: LIST
68644: PUSH
68645: LD_INT 30
68647: PUSH
68648: LD_INT 33
68650: PUSH
68651: EMPTY
68652: LIST
68653: LIST
68654: PUSH
68655: LD_INT 30
68657: PUSH
68658: LD_INT 4
68660: PUSH
68661: EMPTY
68662: LIST
68663: LIST
68664: PUSH
68665: LD_INT 30
68667: PUSH
68668: LD_INT 5
68670: PUSH
68671: EMPTY
68672: LIST
68673: LIST
68674: PUSH
68675: EMPTY
68676: LIST
68677: LIST
68678: LIST
68679: LIST
68680: LIST
68681: PUSH
68682: EMPTY
68683: LIST
68684: LIST
68685: PPUSH
68686: CALL_OW 72
68690: PUSH
68691: LD_INT 4
68693: LESS
68694: PUSH
68695: LD_EXP 23
68699: PUSH
68700: LD_VAR 0 2
68704: ARRAY
68705: PPUSH
68706: LD_INT 3
68708: PUSH
68709: LD_INT 24
68711: PUSH
68712: LD_INT 1000
68714: PUSH
68715: EMPTY
68716: LIST
68717: LIST
68718: PUSH
68719: EMPTY
68720: LIST
68721: LIST
68722: PUSH
68723: LD_INT 2
68725: PUSH
68726: LD_INT 30
68728: PUSH
68729: LD_INT 0
68731: PUSH
68732: EMPTY
68733: LIST
68734: LIST
68735: PUSH
68736: LD_INT 30
68738: PUSH
68739: LD_INT 1
68741: PUSH
68742: EMPTY
68743: LIST
68744: LIST
68745: PUSH
68746: EMPTY
68747: LIST
68748: LIST
68749: LIST
68750: PUSH
68751: EMPTY
68752: LIST
68753: LIST
68754: PPUSH
68755: CALL_OW 72
68759: OR
68760: AND
68761: IFFALSE 69012
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
68763: LD_ADDR_EXP 66
68767: PUSH
68768: LD_EXP 66
68772: PPUSH
68773: LD_VAR 0 2
68777: PPUSH
68778: LD_INT 1
68780: PPUSH
68781: CALL_OW 1
68785: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
68786: LD_ADDR_VAR 0 4
68790: PUSH
68791: LD_EXP 23
68795: PUSH
68796: LD_VAR 0 2
68800: ARRAY
68801: PPUSH
68802: LD_INT 2
68804: PUSH
68805: LD_INT 25
68807: PUSH
68808: LD_INT 1
68810: PUSH
68811: EMPTY
68812: LIST
68813: LIST
68814: PUSH
68815: LD_INT 25
68817: PUSH
68818: LD_INT 5
68820: PUSH
68821: EMPTY
68822: LIST
68823: LIST
68824: PUSH
68825: LD_INT 25
68827: PUSH
68828: LD_INT 8
68830: PUSH
68831: EMPTY
68832: LIST
68833: LIST
68834: PUSH
68835: LD_INT 25
68837: PUSH
68838: LD_INT 9
68840: PUSH
68841: EMPTY
68842: LIST
68843: LIST
68844: PUSH
68845: EMPTY
68846: LIST
68847: LIST
68848: LIST
68849: LIST
68850: LIST
68851: PPUSH
68852: CALL_OW 72
68856: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
68857: LD_ADDR_VAR 0 4
68861: PUSH
68862: LD_VAR 0 4
68866: PUSH
68867: LD_VAR 0 4
68871: PPUSH
68872: LD_INT 18
68874: PPUSH
68875: CALL 45996 0 2
68879: DIFF
68880: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
68881: LD_VAR 0 4
68885: NOT
68886: PUSH
68887: LD_EXP 23
68891: PUSH
68892: LD_VAR 0 2
68896: ARRAY
68897: PPUSH
68898: LD_INT 2
68900: PUSH
68901: LD_INT 30
68903: PUSH
68904: LD_INT 4
68906: PUSH
68907: EMPTY
68908: LIST
68909: LIST
68910: PUSH
68911: LD_INT 30
68913: PUSH
68914: LD_INT 5
68916: PUSH
68917: EMPTY
68918: LIST
68919: LIST
68920: PUSH
68921: EMPTY
68922: LIST
68923: LIST
68924: LIST
68925: PPUSH
68926: CALL_OW 72
68930: NOT
68931: AND
68932: IFFALSE 68994
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
68934: LD_ADDR_VAR 0 4
68938: PUSH
68939: LD_EXP 23
68943: PUSH
68944: LD_VAR 0 2
68948: ARRAY
68949: PPUSH
68950: LD_INT 2
68952: PUSH
68953: LD_INT 25
68955: PUSH
68956: LD_INT 2
68958: PUSH
68959: EMPTY
68960: LIST
68961: LIST
68962: PUSH
68963: LD_INT 25
68965: PUSH
68966: LD_INT 3
68968: PUSH
68969: EMPTY
68970: LIST
68971: LIST
68972: PUSH
68973: LD_INT 25
68975: PUSH
68976: LD_INT 4
68978: PUSH
68979: EMPTY
68980: LIST
68981: LIST
68982: PUSH
68983: EMPTY
68984: LIST
68985: LIST
68986: LIST
68987: LIST
68988: PPUSH
68989: CALL_OW 72
68993: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
68994: LD_VAR 0 2
68998: PPUSH
68999: LD_VAR 0 4
69003: PPUSH
69004: CALL 87739 0 2
// exit ;
69008: POP
69009: POP
69010: GO 69132
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
69012: LD_EXP 46
69016: PUSH
69017: LD_VAR 0 2
69021: ARRAY
69022: PUSH
69023: LD_EXP 66
69027: PUSH
69028: LD_VAR 0 2
69032: ARRAY
69033: NOT
69034: AND
69035: PUSH
69036: LD_EXP 45
69040: PUSH
69041: LD_VAR 0 2
69045: ARRAY
69046: AND
69047: IFFALSE 69128
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
69049: LD_ADDR_EXP 66
69053: PUSH
69054: LD_EXP 66
69058: PPUSH
69059: LD_VAR 0 2
69063: PPUSH
69064: LD_INT 1
69066: PPUSH
69067: CALL_OW 1
69071: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
69072: LD_ADDR_VAR 0 4
69076: PUSH
69077: LD_EXP 45
69081: PUSH
69082: LD_VAR 0 2
69086: ARRAY
69087: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
69088: LD_ADDR_EXP 45
69092: PUSH
69093: LD_EXP 45
69097: PPUSH
69098: LD_VAR 0 2
69102: PPUSH
69103: EMPTY
69104: PPUSH
69105: CALL_OW 1
69109: ST_TO_ADDR
// Defend ( i , tmp ) ;
69110: LD_VAR 0 2
69114: PPUSH
69115: LD_VAR 0 4
69119: PPUSH
69120: CALL 88335 0 2
// exit ;
69124: POP
69125: POP
69126: GO 69132
// end ; end ;
69128: GO 68290
69130: POP
69131: POP
// end ;
69132: LD_VAR 0 1
69136: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
69137: LD_INT 0
69139: PPUSH
69140: PPUSH
69141: PPUSH
69142: PPUSH
69143: PPUSH
69144: PPUSH
69145: PPUSH
69146: PPUSH
69147: PPUSH
69148: PPUSH
69149: PPUSH
// if not mc_bases then
69150: LD_EXP 23
69154: NOT
69155: IFFALSE 69159
// exit ;
69157: GO 70246
// for i = 1 to mc_bases do
69159: LD_ADDR_VAR 0 2
69163: PUSH
69164: DOUBLE
69165: LD_INT 1
69167: DEC
69168: ST_TO_ADDR
69169: LD_EXP 23
69173: PUSH
69174: FOR_TO
69175: IFFALSE 70244
// begin tmp := mc_lab [ i ] ;
69177: LD_ADDR_VAR 0 6
69181: PUSH
69182: LD_EXP 56
69186: PUSH
69187: LD_VAR 0 2
69191: ARRAY
69192: ST_TO_ADDR
// if not tmp then
69193: LD_VAR 0 6
69197: NOT
69198: IFFALSE 69202
// continue ;
69200: GO 69174
// idle_lab := 0 ;
69202: LD_ADDR_VAR 0 11
69206: PUSH
69207: LD_INT 0
69209: ST_TO_ADDR
// for j in tmp do
69210: LD_ADDR_VAR 0 3
69214: PUSH
69215: LD_VAR 0 6
69219: PUSH
69220: FOR_IN
69221: IFFALSE 70240
// begin researching := false ;
69223: LD_ADDR_VAR 0 10
69227: PUSH
69228: LD_INT 0
69230: ST_TO_ADDR
// side := GetSide ( j ) ;
69231: LD_ADDR_VAR 0 4
69235: PUSH
69236: LD_VAR 0 3
69240: PPUSH
69241: CALL_OW 255
69245: ST_TO_ADDR
// if not mc_tech [ side ] then
69246: LD_EXP 50
69250: PUSH
69251: LD_VAR 0 4
69255: ARRAY
69256: NOT
69257: IFFALSE 69261
// continue ;
69259: GO 69220
// if BuildingStatus ( j ) = bs_idle then
69261: LD_VAR 0 3
69265: PPUSH
69266: CALL_OW 461
69270: PUSH
69271: LD_INT 2
69273: EQUAL
69274: IFFALSE 69462
// begin if idle_lab and UnitsInside ( j ) < 6 then
69276: LD_VAR 0 11
69280: PUSH
69281: LD_VAR 0 3
69285: PPUSH
69286: CALL_OW 313
69290: PUSH
69291: LD_INT 6
69293: LESS
69294: AND
69295: IFFALSE 69366
// begin tmp2 := UnitsInside ( idle_lab ) ;
69297: LD_ADDR_VAR 0 9
69301: PUSH
69302: LD_VAR 0 11
69306: PPUSH
69307: CALL_OW 313
69311: ST_TO_ADDR
// if tmp2 then
69312: LD_VAR 0 9
69316: IFFALSE 69358
// for x in tmp2 do
69318: LD_ADDR_VAR 0 7
69322: PUSH
69323: LD_VAR 0 9
69327: PUSH
69328: FOR_IN
69329: IFFALSE 69356
// begin ComExitBuilding ( x ) ;
69331: LD_VAR 0 7
69335: PPUSH
69336: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
69340: LD_VAR 0 7
69344: PPUSH
69345: LD_VAR 0 3
69349: PPUSH
69350: CALL_OW 180
// end ;
69354: GO 69328
69356: POP
69357: POP
// idle_lab := 0 ;
69358: LD_ADDR_VAR 0 11
69362: PUSH
69363: LD_INT 0
69365: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
69366: LD_ADDR_VAR 0 5
69370: PUSH
69371: LD_EXP 50
69375: PUSH
69376: LD_VAR 0 4
69380: ARRAY
69381: PUSH
69382: FOR_IN
69383: IFFALSE 69443
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
69385: LD_VAR 0 3
69389: PPUSH
69390: LD_VAR 0 5
69394: PPUSH
69395: CALL_OW 430
69399: PUSH
69400: LD_VAR 0 4
69404: PPUSH
69405: LD_VAR 0 5
69409: PPUSH
69410: CALL 11829 0 2
69414: AND
69415: IFFALSE 69441
// begin researching := true ;
69417: LD_ADDR_VAR 0 10
69421: PUSH
69422: LD_INT 1
69424: ST_TO_ADDR
// ComResearch ( j , t ) ;
69425: LD_VAR 0 3
69429: PPUSH
69430: LD_VAR 0 5
69434: PPUSH
69435: CALL_OW 124
// break ;
69439: GO 69443
// end ;
69441: GO 69382
69443: POP
69444: POP
// if not researching then
69445: LD_VAR 0 10
69449: NOT
69450: IFFALSE 69462
// idle_lab := j ;
69452: LD_ADDR_VAR 0 11
69456: PUSH
69457: LD_VAR 0 3
69461: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
69462: LD_VAR 0 3
69466: PPUSH
69467: CALL_OW 461
69471: PUSH
69472: LD_INT 10
69474: EQUAL
69475: IFFALSE 70063
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
69477: LD_EXP 52
69481: PUSH
69482: LD_VAR 0 2
69486: ARRAY
69487: NOT
69488: PUSH
69489: LD_EXP 53
69493: PUSH
69494: LD_VAR 0 2
69498: ARRAY
69499: NOT
69500: AND
69501: PUSH
69502: LD_EXP 50
69506: PUSH
69507: LD_VAR 0 4
69511: ARRAY
69512: PUSH
69513: LD_INT 1
69515: GREATER
69516: AND
69517: IFFALSE 69648
// begin ComCancel ( j ) ;
69519: LD_VAR 0 3
69523: PPUSH
69524: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
69528: LD_ADDR_EXP 50
69532: PUSH
69533: LD_EXP 50
69537: PPUSH
69538: LD_VAR 0 4
69542: PPUSH
69543: LD_EXP 50
69547: PUSH
69548: LD_VAR 0 4
69552: ARRAY
69553: PPUSH
69554: LD_EXP 50
69558: PUSH
69559: LD_VAR 0 4
69563: ARRAY
69564: PUSH
69565: LD_INT 1
69567: MINUS
69568: PPUSH
69569: LD_EXP 50
69573: PUSH
69574: LD_VAR 0 4
69578: ARRAY
69579: PPUSH
69580: LD_INT 0
69582: PPUSH
69583: CALL 15528 0 4
69587: PPUSH
69588: CALL_OW 1
69592: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
69593: LD_ADDR_EXP 50
69597: PUSH
69598: LD_EXP 50
69602: PPUSH
69603: LD_VAR 0 4
69607: PPUSH
69608: LD_EXP 50
69612: PUSH
69613: LD_VAR 0 4
69617: ARRAY
69618: PPUSH
69619: LD_EXP 50
69623: PUSH
69624: LD_VAR 0 4
69628: ARRAY
69629: PPUSH
69630: LD_INT 1
69632: PPUSH
69633: LD_INT 0
69635: PPUSH
69636: CALL 15528 0 4
69640: PPUSH
69641: CALL_OW 1
69645: ST_TO_ADDR
// continue ;
69646: GO 69220
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
69648: LD_EXP 52
69652: PUSH
69653: LD_VAR 0 2
69657: ARRAY
69658: PUSH
69659: LD_EXP 53
69663: PUSH
69664: LD_VAR 0 2
69668: ARRAY
69669: NOT
69670: AND
69671: IFFALSE 69798
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
69673: LD_ADDR_EXP 53
69677: PUSH
69678: LD_EXP 53
69682: PPUSH
69683: LD_VAR 0 2
69687: PUSH
69688: LD_EXP 53
69692: PUSH
69693: LD_VAR 0 2
69697: ARRAY
69698: PUSH
69699: LD_INT 1
69701: PLUS
69702: PUSH
69703: EMPTY
69704: LIST
69705: LIST
69706: PPUSH
69707: LD_EXP 52
69711: PUSH
69712: LD_VAR 0 2
69716: ARRAY
69717: PUSH
69718: LD_INT 1
69720: ARRAY
69721: PPUSH
69722: CALL 16110 0 3
69726: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
69727: LD_EXP 52
69731: PUSH
69732: LD_VAR 0 2
69736: ARRAY
69737: PUSH
69738: LD_INT 1
69740: ARRAY
69741: PPUSH
69742: LD_INT 112
69744: PPUSH
69745: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
69749: LD_ADDR_VAR 0 9
69753: PUSH
69754: LD_EXP 52
69758: PUSH
69759: LD_VAR 0 2
69763: ARRAY
69764: PPUSH
69765: LD_INT 1
69767: PPUSH
69768: CALL_OW 3
69772: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
69773: LD_ADDR_EXP 52
69777: PUSH
69778: LD_EXP 52
69782: PPUSH
69783: LD_VAR 0 2
69787: PPUSH
69788: LD_VAR 0 9
69792: PPUSH
69793: CALL_OW 1
69797: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
69798: LD_EXP 52
69802: PUSH
69803: LD_VAR 0 2
69807: ARRAY
69808: PUSH
69809: LD_EXP 53
69813: PUSH
69814: LD_VAR 0 2
69818: ARRAY
69819: AND
69820: PUSH
69821: LD_EXP 53
69825: PUSH
69826: LD_VAR 0 2
69830: ARRAY
69831: PUSH
69832: LD_INT 1
69834: ARRAY
69835: PPUSH
69836: CALL_OW 310
69840: NOT
69841: AND
69842: PUSH
69843: LD_VAR 0 3
69847: PPUSH
69848: CALL_OW 313
69852: PUSH
69853: LD_INT 6
69855: EQUAL
69856: AND
69857: IFFALSE 69913
// begin tmp2 := UnitsInside ( j ) ;
69859: LD_ADDR_VAR 0 9
69863: PUSH
69864: LD_VAR 0 3
69868: PPUSH
69869: CALL_OW 313
69873: ST_TO_ADDR
// if tmp2 = 6 then
69874: LD_VAR 0 9
69878: PUSH
69879: LD_INT 6
69881: EQUAL
69882: IFFALSE 69913
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
69884: LD_VAR 0 9
69888: PUSH
69889: LD_INT 1
69891: ARRAY
69892: PPUSH
69893: LD_INT 112
69895: PPUSH
69896: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
69900: LD_VAR 0 9
69904: PUSH
69905: LD_INT 1
69907: ARRAY
69908: PPUSH
69909: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
69913: LD_EXP 53
69917: PUSH
69918: LD_VAR 0 2
69922: ARRAY
69923: PUSH
69924: LD_EXP 53
69928: PUSH
69929: LD_VAR 0 2
69933: ARRAY
69934: PUSH
69935: LD_INT 1
69937: ARRAY
69938: PPUSH
69939: CALL_OW 314
69943: NOT
69944: AND
69945: PUSH
69946: LD_EXP 53
69950: PUSH
69951: LD_VAR 0 2
69955: ARRAY
69956: PUSH
69957: LD_INT 1
69959: ARRAY
69960: PPUSH
69961: CALL_OW 310
69965: NOT
69966: AND
69967: IFFALSE 69993
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
69969: LD_EXP 53
69973: PUSH
69974: LD_VAR 0 2
69978: ARRAY
69979: PUSH
69980: LD_INT 1
69982: ARRAY
69983: PPUSH
69984: LD_VAR 0 3
69988: PPUSH
69989: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
69993: LD_EXP 53
69997: PUSH
69998: LD_VAR 0 2
70002: ARRAY
70003: PUSH
70004: LD_INT 1
70006: ARRAY
70007: PPUSH
70008: CALL_OW 310
70012: PUSH
70013: LD_EXP 53
70017: PUSH
70018: LD_VAR 0 2
70022: ARRAY
70023: PUSH
70024: LD_INT 1
70026: ARRAY
70027: PPUSH
70028: CALL_OW 310
70032: PPUSH
70033: CALL_OW 461
70037: PUSH
70038: LD_INT 3
70040: NONEQUAL
70041: AND
70042: IFFALSE 70063
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
70044: LD_EXP 53
70048: PUSH
70049: LD_VAR 0 2
70053: ARRAY
70054: PUSH
70055: LD_INT 1
70057: ARRAY
70058: PPUSH
70059: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
70063: LD_VAR 0 3
70067: PPUSH
70068: CALL_OW 461
70072: PUSH
70073: LD_INT 6
70075: EQUAL
70076: PUSH
70077: LD_VAR 0 6
70081: PUSH
70082: LD_INT 1
70084: GREATER
70085: AND
70086: IFFALSE 70238
// begin sci := [ ] ;
70088: LD_ADDR_VAR 0 8
70092: PUSH
70093: EMPTY
70094: ST_TO_ADDR
// for x in ( tmp diff j ) do
70095: LD_ADDR_VAR 0 7
70099: PUSH
70100: LD_VAR 0 6
70104: PUSH
70105: LD_VAR 0 3
70109: DIFF
70110: PUSH
70111: FOR_IN
70112: IFFALSE 70164
// begin if sci = 6 then
70114: LD_VAR 0 8
70118: PUSH
70119: LD_INT 6
70121: EQUAL
70122: IFFALSE 70126
// break ;
70124: GO 70164
// if BuildingStatus ( x ) = bs_idle then
70126: LD_VAR 0 7
70130: PPUSH
70131: CALL_OW 461
70135: PUSH
70136: LD_INT 2
70138: EQUAL
70139: IFFALSE 70162
// sci := sci ^ UnitsInside ( x ) ;
70141: LD_ADDR_VAR 0 8
70145: PUSH
70146: LD_VAR 0 8
70150: PUSH
70151: LD_VAR 0 7
70155: PPUSH
70156: CALL_OW 313
70160: ADD
70161: ST_TO_ADDR
// end ;
70162: GO 70111
70164: POP
70165: POP
// if not sci then
70166: LD_VAR 0 8
70170: NOT
70171: IFFALSE 70175
// continue ;
70173: GO 69220
// for x in sci do
70175: LD_ADDR_VAR 0 7
70179: PUSH
70180: LD_VAR 0 8
70184: PUSH
70185: FOR_IN
70186: IFFALSE 70236
// if IsInUnit ( x ) and not HasTask ( x ) then
70188: LD_VAR 0 7
70192: PPUSH
70193: CALL_OW 310
70197: PUSH
70198: LD_VAR 0 7
70202: PPUSH
70203: CALL_OW 314
70207: NOT
70208: AND
70209: IFFALSE 70234
// begin ComExitBuilding ( x ) ;
70211: LD_VAR 0 7
70215: PPUSH
70216: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
70220: LD_VAR 0 7
70224: PPUSH
70225: LD_VAR 0 3
70229: PPUSH
70230: CALL_OW 180
// end ;
70234: GO 70185
70236: POP
70237: POP
// end ; end ;
70238: GO 69220
70240: POP
70241: POP
// end ;
70242: GO 69174
70244: POP
70245: POP
// end ;
70246: LD_VAR 0 1
70250: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
70251: LD_INT 0
70253: PPUSH
70254: PPUSH
// if not mc_bases then
70255: LD_EXP 23
70259: NOT
70260: IFFALSE 70264
// exit ;
70262: GO 70345
// for i = 1 to mc_bases do
70264: LD_ADDR_VAR 0 2
70268: PUSH
70269: DOUBLE
70270: LD_INT 1
70272: DEC
70273: ST_TO_ADDR
70274: LD_EXP 23
70278: PUSH
70279: FOR_TO
70280: IFFALSE 70343
// if mc_mines [ i ] and mc_miners [ i ] then
70282: LD_EXP 36
70286: PUSH
70287: LD_VAR 0 2
70291: ARRAY
70292: PUSH
70293: LD_EXP 37
70297: PUSH
70298: LD_VAR 0 2
70302: ARRAY
70303: AND
70304: IFFALSE 70341
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
70306: LD_EXP 37
70310: PUSH
70311: LD_VAR 0 2
70315: ARRAY
70316: PUSH
70317: LD_INT 1
70319: ARRAY
70320: PPUSH
70321: CALL_OW 255
70325: PPUSH
70326: LD_EXP 36
70330: PUSH
70331: LD_VAR 0 2
70335: ARRAY
70336: PPUSH
70337: CALL 12912 0 2
70341: GO 70279
70343: POP
70344: POP
// end ;
70345: LD_VAR 0 1
70349: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
70350: LD_INT 0
70352: PPUSH
70353: PPUSH
70354: PPUSH
70355: PPUSH
70356: PPUSH
70357: PPUSH
70358: PPUSH
70359: PPUSH
// if not mc_bases or not mc_parking then
70360: LD_EXP 23
70364: NOT
70365: PUSH
70366: LD_EXP 47
70370: NOT
70371: OR
70372: IFFALSE 70376
// exit ;
70374: GO 71114
// for i = 1 to mc_bases do
70376: LD_ADDR_VAR 0 2
70380: PUSH
70381: DOUBLE
70382: LD_INT 1
70384: DEC
70385: ST_TO_ADDR
70386: LD_EXP 23
70390: PUSH
70391: FOR_TO
70392: IFFALSE 71112
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
70394: LD_EXP 23
70398: PUSH
70399: LD_VAR 0 2
70403: ARRAY
70404: NOT
70405: PUSH
70406: LD_EXP 47
70410: PUSH
70411: LD_VAR 0 2
70415: ARRAY
70416: NOT
70417: OR
70418: IFFALSE 70422
// continue ;
70420: GO 70391
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
70422: LD_ADDR_VAR 0 5
70426: PUSH
70427: LD_EXP 23
70431: PUSH
70432: LD_VAR 0 2
70436: ARRAY
70437: PUSH
70438: LD_INT 1
70440: ARRAY
70441: PPUSH
70442: CALL_OW 255
70446: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
70447: LD_ADDR_VAR 0 6
70451: PUSH
70452: LD_EXP 23
70456: PUSH
70457: LD_VAR 0 2
70461: ARRAY
70462: PPUSH
70463: LD_INT 30
70465: PUSH
70466: LD_INT 3
70468: PUSH
70469: EMPTY
70470: LIST
70471: LIST
70472: PPUSH
70473: CALL_OW 72
70477: ST_TO_ADDR
// if not fac then
70478: LD_VAR 0 6
70482: NOT
70483: IFFALSE 70534
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70485: LD_ADDR_VAR 0 6
70489: PUSH
70490: LD_EXP 23
70494: PUSH
70495: LD_VAR 0 2
70499: ARRAY
70500: PPUSH
70501: LD_INT 2
70503: PUSH
70504: LD_INT 30
70506: PUSH
70507: LD_INT 0
70509: PUSH
70510: EMPTY
70511: LIST
70512: LIST
70513: PUSH
70514: LD_INT 30
70516: PUSH
70517: LD_INT 1
70519: PUSH
70520: EMPTY
70521: LIST
70522: LIST
70523: PUSH
70524: EMPTY
70525: LIST
70526: LIST
70527: LIST
70528: PPUSH
70529: CALL_OW 72
70533: ST_TO_ADDR
// if not fac then
70534: LD_VAR 0 6
70538: NOT
70539: IFFALSE 70543
// continue ;
70541: GO 70391
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
70543: LD_ADDR_VAR 0 7
70547: PUSH
70548: LD_EXP 47
70552: PUSH
70553: LD_VAR 0 2
70557: ARRAY
70558: PPUSH
70559: LD_INT 22
70561: PUSH
70562: LD_VAR 0 5
70566: PUSH
70567: EMPTY
70568: LIST
70569: LIST
70570: PUSH
70571: LD_INT 21
70573: PUSH
70574: LD_INT 2
70576: PUSH
70577: EMPTY
70578: LIST
70579: LIST
70580: PUSH
70581: LD_INT 3
70583: PUSH
70584: LD_INT 60
70586: PUSH
70587: EMPTY
70588: LIST
70589: PUSH
70590: EMPTY
70591: LIST
70592: LIST
70593: PUSH
70594: LD_INT 3
70596: PUSH
70597: LD_INT 24
70599: PUSH
70600: LD_INT 1000
70602: PUSH
70603: EMPTY
70604: LIST
70605: LIST
70606: PUSH
70607: EMPTY
70608: LIST
70609: LIST
70610: PUSH
70611: EMPTY
70612: LIST
70613: LIST
70614: LIST
70615: LIST
70616: PPUSH
70617: CALL_OW 70
70621: ST_TO_ADDR
// for j in fac do
70622: LD_ADDR_VAR 0 3
70626: PUSH
70627: LD_VAR 0 6
70631: PUSH
70632: FOR_IN
70633: IFFALSE 70728
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
70635: LD_ADDR_VAR 0 7
70639: PUSH
70640: LD_VAR 0 7
70644: PUSH
70645: LD_INT 22
70647: PUSH
70648: LD_VAR 0 5
70652: PUSH
70653: EMPTY
70654: LIST
70655: LIST
70656: PUSH
70657: LD_INT 91
70659: PUSH
70660: LD_VAR 0 3
70664: PUSH
70665: LD_INT 15
70667: PUSH
70668: EMPTY
70669: LIST
70670: LIST
70671: LIST
70672: PUSH
70673: LD_INT 21
70675: PUSH
70676: LD_INT 2
70678: PUSH
70679: EMPTY
70680: LIST
70681: LIST
70682: PUSH
70683: LD_INT 3
70685: PUSH
70686: LD_INT 60
70688: PUSH
70689: EMPTY
70690: LIST
70691: PUSH
70692: EMPTY
70693: LIST
70694: LIST
70695: PUSH
70696: LD_INT 3
70698: PUSH
70699: LD_INT 24
70701: PUSH
70702: LD_INT 1000
70704: PUSH
70705: EMPTY
70706: LIST
70707: LIST
70708: PUSH
70709: EMPTY
70710: LIST
70711: LIST
70712: PUSH
70713: EMPTY
70714: LIST
70715: LIST
70716: LIST
70717: LIST
70718: LIST
70719: PPUSH
70720: CALL_OW 69
70724: UNION
70725: ST_TO_ADDR
70726: GO 70632
70728: POP
70729: POP
// if not vehs then
70730: LD_VAR 0 7
70734: NOT
70735: IFFALSE 70761
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
70737: LD_ADDR_EXP 35
70741: PUSH
70742: LD_EXP 35
70746: PPUSH
70747: LD_VAR 0 2
70751: PPUSH
70752: EMPTY
70753: PPUSH
70754: CALL_OW 1
70758: ST_TO_ADDR
// continue ;
70759: GO 70391
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
70761: LD_ADDR_VAR 0 8
70765: PUSH
70766: LD_EXP 23
70770: PUSH
70771: LD_VAR 0 2
70775: ARRAY
70776: PPUSH
70777: LD_INT 30
70779: PUSH
70780: LD_INT 3
70782: PUSH
70783: EMPTY
70784: LIST
70785: LIST
70786: PPUSH
70787: CALL_OW 72
70791: ST_TO_ADDR
// if tmp then
70792: LD_VAR 0 8
70796: IFFALSE 70899
// begin for j in tmp do
70798: LD_ADDR_VAR 0 3
70802: PUSH
70803: LD_VAR 0 8
70807: PUSH
70808: FOR_IN
70809: IFFALSE 70897
// for k in UnitsInside ( j ) do
70811: LD_ADDR_VAR 0 4
70815: PUSH
70816: LD_VAR 0 3
70820: PPUSH
70821: CALL_OW 313
70825: PUSH
70826: FOR_IN
70827: IFFALSE 70893
// if k then
70829: LD_VAR 0 4
70833: IFFALSE 70891
// if not k in mc_repair_vehicle [ i ] then
70835: LD_VAR 0 4
70839: PUSH
70840: LD_EXP 35
70844: PUSH
70845: LD_VAR 0 2
70849: ARRAY
70850: IN
70851: NOT
70852: IFFALSE 70891
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
70854: LD_ADDR_EXP 35
70858: PUSH
70859: LD_EXP 35
70863: PPUSH
70864: LD_VAR 0 2
70868: PPUSH
70869: LD_EXP 35
70873: PUSH
70874: LD_VAR 0 2
70878: ARRAY
70879: PUSH
70880: LD_VAR 0 4
70884: UNION
70885: PPUSH
70886: CALL_OW 1
70890: ST_TO_ADDR
70891: GO 70826
70893: POP
70894: POP
70895: GO 70808
70897: POP
70898: POP
// end ; if not mc_repair_vehicle [ i ] then
70899: LD_EXP 35
70903: PUSH
70904: LD_VAR 0 2
70908: ARRAY
70909: NOT
70910: IFFALSE 70914
// continue ;
70912: GO 70391
// for j in mc_repair_vehicle [ i ] do
70914: LD_ADDR_VAR 0 3
70918: PUSH
70919: LD_EXP 35
70923: PUSH
70924: LD_VAR 0 2
70928: ARRAY
70929: PUSH
70930: FOR_IN
70931: IFFALSE 71108
// begin if GetClass ( j ) <> 3 then
70933: LD_VAR 0 3
70937: PPUSH
70938: CALL_OW 257
70942: PUSH
70943: LD_INT 3
70945: NONEQUAL
70946: IFFALSE 70987
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
70948: LD_ADDR_EXP 35
70952: PUSH
70953: LD_EXP 35
70957: PPUSH
70958: LD_VAR 0 2
70962: PPUSH
70963: LD_EXP 35
70967: PUSH
70968: LD_VAR 0 2
70972: ARRAY
70973: PUSH
70974: LD_VAR 0 3
70978: DIFF
70979: PPUSH
70980: CALL_OW 1
70984: ST_TO_ADDR
// continue ;
70985: GO 70930
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
70987: LD_VAR 0 3
70991: PPUSH
70992: CALL_OW 311
70996: NOT
70997: PUSH
70998: LD_VAR 0 3
71002: PUSH
71003: LD_EXP 26
71007: PUSH
71008: LD_VAR 0 2
71012: ARRAY
71013: PUSH
71014: LD_INT 1
71016: ARRAY
71017: IN
71018: NOT
71019: AND
71020: PUSH
71021: LD_VAR 0 3
71025: PUSH
71026: LD_EXP 26
71030: PUSH
71031: LD_VAR 0 2
71035: ARRAY
71036: PUSH
71037: LD_INT 2
71039: ARRAY
71040: IN
71041: NOT
71042: AND
71043: IFFALSE 71106
// begin if IsInUnit ( j ) then
71045: LD_VAR 0 3
71049: PPUSH
71050: CALL_OW 310
71054: IFFALSE 71067
// ComExitBuilding ( j ) else
71056: LD_VAR 0 3
71060: PPUSH
71061: CALL_OW 122
71065: GO 71106
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
71067: LD_VAR 0 3
71071: PPUSH
71072: LD_VAR 0 7
71076: PUSH
71077: LD_INT 1
71079: ARRAY
71080: PPUSH
71081: CALL 50478 0 2
71085: NOT
71086: IFFALSE 71106
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
71088: LD_VAR 0 3
71092: PPUSH
71093: LD_VAR 0 7
71097: PUSH
71098: LD_INT 1
71100: ARRAY
71101: PPUSH
71102: CALL_OW 129
// end ; end ;
71106: GO 70930
71108: POP
71109: POP
// end ;
71110: GO 70391
71112: POP
71113: POP
// end ;
71114: LD_VAR 0 1
71118: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
71119: LD_INT 0
71121: PPUSH
71122: PPUSH
71123: PPUSH
71124: PPUSH
71125: PPUSH
71126: PPUSH
71127: PPUSH
71128: PPUSH
71129: PPUSH
71130: PPUSH
71131: PPUSH
// if not mc_bases then
71132: LD_EXP 23
71136: NOT
71137: IFFALSE 71141
// exit ;
71139: GO 71943
// for i = 1 to mc_bases do
71141: LD_ADDR_VAR 0 2
71145: PUSH
71146: DOUBLE
71147: LD_INT 1
71149: DEC
71150: ST_TO_ADDR
71151: LD_EXP 23
71155: PUSH
71156: FOR_TO
71157: IFFALSE 71941
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
71159: LD_EXP 51
71163: PUSH
71164: LD_VAR 0 2
71168: ARRAY
71169: NOT
71170: PUSH
71171: LD_EXP 26
71175: PUSH
71176: LD_VAR 0 2
71180: ARRAY
71181: PUSH
71182: LD_INT 1
71184: ARRAY
71185: OR
71186: PUSH
71187: LD_EXP 26
71191: PUSH
71192: LD_VAR 0 2
71196: ARRAY
71197: PUSH
71198: LD_INT 2
71200: ARRAY
71201: OR
71202: PUSH
71203: LD_EXP 49
71207: PUSH
71208: LD_VAR 0 2
71212: ARRAY
71213: PPUSH
71214: LD_INT 1
71216: PPUSH
71217: CALL_OW 325
71221: NOT
71222: OR
71223: PUSH
71224: LD_EXP 46
71228: PUSH
71229: LD_VAR 0 2
71233: ARRAY
71234: OR
71235: IFFALSE 71239
// continue ;
71237: GO 71156
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
71239: LD_ADDR_VAR 0 8
71243: PUSH
71244: LD_EXP 23
71248: PUSH
71249: LD_VAR 0 2
71253: ARRAY
71254: PPUSH
71255: LD_INT 25
71257: PUSH
71258: LD_INT 4
71260: PUSH
71261: EMPTY
71262: LIST
71263: LIST
71264: PUSH
71265: LD_INT 50
71267: PUSH
71268: EMPTY
71269: LIST
71270: PUSH
71271: LD_INT 3
71273: PUSH
71274: LD_INT 60
71276: PUSH
71277: EMPTY
71278: LIST
71279: PUSH
71280: EMPTY
71281: LIST
71282: LIST
71283: PUSH
71284: EMPTY
71285: LIST
71286: LIST
71287: LIST
71288: PPUSH
71289: CALL_OW 72
71293: PUSH
71294: LD_EXP 27
71298: PUSH
71299: LD_VAR 0 2
71303: ARRAY
71304: DIFF
71305: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71306: LD_ADDR_VAR 0 9
71310: PUSH
71311: LD_EXP 23
71315: PUSH
71316: LD_VAR 0 2
71320: ARRAY
71321: PPUSH
71322: LD_INT 2
71324: PUSH
71325: LD_INT 30
71327: PUSH
71328: LD_INT 0
71330: PUSH
71331: EMPTY
71332: LIST
71333: LIST
71334: PUSH
71335: LD_INT 30
71337: PUSH
71338: LD_INT 1
71340: PUSH
71341: EMPTY
71342: LIST
71343: LIST
71344: PUSH
71345: EMPTY
71346: LIST
71347: LIST
71348: LIST
71349: PPUSH
71350: CALL_OW 72
71354: ST_TO_ADDR
// if not tmp or not dep then
71355: LD_VAR 0 8
71359: NOT
71360: PUSH
71361: LD_VAR 0 9
71365: NOT
71366: OR
71367: IFFALSE 71371
// continue ;
71369: GO 71156
// side := GetSide ( tmp [ 1 ] ) ;
71371: LD_ADDR_VAR 0 11
71375: PUSH
71376: LD_VAR 0 8
71380: PUSH
71381: LD_INT 1
71383: ARRAY
71384: PPUSH
71385: CALL_OW 255
71389: ST_TO_ADDR
// dep := dep [ 1 ] ;
71390: LD_ADDR_VAR 0 9
71394: PUSH
71395: LD_VAR 0 9
71399: PUSH
71400: LD_INT 1
71402: ARRAY
71403: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
71404: LD_ADDR_VAR 0 7
71408: PUSH
71409: LD_EXP 51
71413: PUSH
71414: LD_VAR 0 2
71418: ARRAY
71419: PPUSH
71420: LD_INT 22
71422: PUSH
71423: LD_INT 0
71425: PUSH
71426: EMPTY
71427: LIST
71428: LIST
71429: PUSH
71430: LD_INT 25
71432: PUSH
71433: LD_INT 12
71435: PUSH
71436: EMPTY
71437: LIST
71438: LIST
71439: PUSH
71440: EMPTY
71441: LIST
71442: LIST
71443: PPUSH
71444: CALL_OW 70
71448: PUSH
71449: LD_INT 22
71451: PUSH
71452: LD_INT 0
71454: PUSH
71455: EMPTY
71456: LIST
71457: LIST
71458: PUSH
71459: LD_INT 25
71461: PUSH
71462: LD_INT 12
71464: PUSH
71465: EMPTY
71466: LIST
71467: LIST
71468: PUSH
71469: LD_INT 91
71471: PUSH
71472: LD_VAR 0 9
71476: PUSH
71477: LD_INT 20
71479: PUSH
71480: EMPTY
71481: LIST
71482: LIST
71483: LIST
71484: PUSH
71485: EMPTY
71486: LIST
71487: LIST
71488: LIST
71489: PPUSH
71490: CALL_OW 69
71494: UNION
71495: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
71496: LD_ADDR_VAR 0 10
71500: PUSH
71501: LD_EXP 51
71505: PUSH
71506: LD_VAR 0 2
71510: ARRAY
71511: PPUSH
71512: LD_INT 81
71514: PUSH
71515: LD_VAR 0 11
71519: PUSH
71520: EMPTY
71521: LIST
71522: LIST
71523: PPUSH
71524: CALL_OW 70
71528: ST_TO_ADDR
// if not apes or danger_at_area then
71529: LD_VAR 0 7
71533: NOT
71534: PUSH
71535: LD_VAR 0 10
71539: OR
71540: IFFALSE 71590
// begin if mc_taming [ i ] then
71542: LD_EXP 54
71546: PUSH
71547: LD_VAR 0 2
71551: ARRAY
71552: IFFALSE 71588
// begin MC_Reset ( i , 121 ) ;
71554: LD_VAR 0 2
71558: PPUSH
71559: LD_INT 121
71561: PPUSH
71562: CALL 56527 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
71566: LD_ADDR_EXP 54
71570: PUSH
71571: LD_EXP 54
71575: PPUSH
71576: LD_VAR 0 2
71580: PPUSH
71581: EMPTY
71582: PPUSH
71583: CALL_OW 1
71587: ST_TO_ADDR
// end ; continue ;
71588: GO 71156
// end ; for j in tmp do
71590: LD_ADDR_VAR 0 3
71594: PUSH
71595: LD_VAR 0 8
71599: PUSH
71600: FOR_IN
71601: IFFALSE 71937
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
71603: LD_VAR 0 3
71607: PUSH
71608: LD_EXP 54
71612: PUSH
71613: LD_VAR 0 2
71617: ARRAY
71618: IN
71619: NOT
71620: PUSH
71621: LD_EXP 54
71625: PUSH
71626: LD_VAR 0 2
71630: ARRAY
71631: PUSH
71632: LD_INT 3
71634: LESS
71635: AND
71636: IFFALSE 71694
// begin SetTag ( j , 121 ) ;
71638: LD_VAR 0 3
71642: PPUSH
71643: LD_INT 121
71645: PPUSH
71646: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
71650: LD_ADDR_EXP 54
71654: PUSH
71655: LD_EXP 54
71659: PPUSH
71660: LD_VAR 0 2
71664: PUSH
71665: LD_EXP 54
71669: PUSH
71670: LD_VAR 0 2
71674: ARRAY
71675: PUSH
71676: LD_INT 1
71678: PLUS
71679: PUSH
71680: EMPTY
71681: LIST
71682: LIST
71683: PPUSH
71684: LD_VAR 0 3
71688: PPUSH
71689: CALL 16110 0 3
71693: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
71694: LD_VAR 0 3
71698: PUSH
71699: LD_EXP 54
71703: PUSH
71704: LD_VAR 0 2
71708: ARRAY
71709: IN
71710: IFFALSE 71935
// begin if GetClass ( j ) <> 4 then
71712: LD_VAR 0 3
71716: PPUSH
71717: CALL_OW 257
71721: PUSH
71722: LD_INT 4
71724: NONEQUAL
71725: IFFALSE 71778
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
71727: LD_ADDR_EXP 54
71731: PUSH
71732: LD_EXP 54
71736: PPUSH
71737: LD_VAR 0 2
71741: PPUSH
71742: LD_EXP 54
71746: PUSH
71747: LD_VAR 0 2
71751: ARRAY
71752: PUSH
71753: LD_VAR 0 3
71757: DIFF
71758: PPUSH
71759: CALL_OW 1
71763: ST_TO_ADDR
// SetTag ( j , 0 ) ;
71764: LD_VAR 0 3
71768: PPUSH
71769: LD_INT 0
71771: PPUSH
71772: CALL_OW 109
// continue ;
71776: GO 71600
// end ; if IsInUnit ( j ) then
71778: LD_VAR 0 3
71782: PPUSH
71783: CALL_OW 310
71787: IFFALSE 71798
// ComExitBuilding ( j ) ;
71789: LD_VAR 0 3
71793: PPUSH
71794: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
71798: LD_ADDR_VAR 0 6
71802: PUSH
71803: LD_VAR 0 7
71807: PPUSH
71808: LD_VAR 0 3
71812: PPUSH
71813: CALL_OW 74
71817: ST_TO_ADDR
// if not ape then
71818: LD_VAR 0 6
71822: NOT
71823: IFFALSE 71827
// break ;
71825: GO 71937
// x := GetX ( ape ) ;
71827: LD_ADDR_VAR 0 4
71831: PUSH
71832: LD_VAR 0 6
71836: PPUSH
71837: CALL_OW 250
71841: ST_TO_ADDR
// y := GetY ( ape ) ;
71842: LD_ADDR_VAR 0 5
71846: PUSH
71847: LD_VAR 0 6
71851: PPUSH
71852: CALL_OW 251
71856: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
71857: LD_VAR 0 4
71861: PPUSH
71862: LD_VAR 0 5
71866: PPUSH
71867: CALL_OW 488
71871: NOT
71872: PUSH
71873: LD_VAR 0 11
71877: PPUSH
71878: LD_VAR 0 4
71882: PPUSH
71883: LD_VAR 0 5
71887: PPUSH
71888: LD_INT 20
71890: PPUSH
71891: CALL 17006 0 4
71895: PUSH
71896: LD_INT 4
71898: ARRAY
71899: OR
71900: IFFALSE 71904
// break ;
71902: GO 71937
// if not HasTask ( j ) then
71904: LD_VAR 0 3
71908: PPUSH
71909: CALL_OW 314
71913: NOT
71914: IFFALSE 71935
// ComTameXY ( j , x , y ) ;
71916: LD_VAR 0 3
71920: PPUSH
71921: LD_VAR 0 4
71925: PPUSH
71926: LD_VAR 0 5
71930: PPUSH
71931: CALL_OW 131
// end ; end ;
71935: GO 71600
71937: POP
71938: POP
// end ;
71939: GO 71156
71941: POP
71942: POP
// end ;
71943: LD_VAR 0 1
71947: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
71948: LD_INT 0
71950: PPUSH
71951: PPUSH
71952: PPUSH
71953: PPUSH
71954: PPUSH
71955: PPUSH
71956: PPUSH
71957: PPUSH
// if not mc_bases then
71958: LD_EXP 23
71962: NOT
71963: IFFALSE 71967
// exit ;
71965: GO 72593
// for i = 1 to mc_bases do
71967: LD_ADDR_VAR 0 2
71971: PUSH
71972: DOUBLE
71973: LD_INT 1
71975: DEC
71976: ST_TO_ADDR
71977: LD_EXP 23
71981: PUSH
71982: FOR_TO
71983: IFFALSE 72591
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
71985: LD_EXP 52
71989: PUSH
71990: LD_VAR 0 2
71994: ARRAY
71995: NOT
71996: PUSH
71997: LD_EXP 52
72001: PUSH
72002: LD_VAR 0 2
72006: ARRAY
72007: PPUSH
72008: LD_INT 25
72010: PUSH
72011: LD_INT 12
72013: PUSH
72014: EMPTY
72015: LIST
72016: LIST
72017: PPUSH
72018: CALL_OW 72
72022: NOT
72023: OR
72024: IFFALSE 72028
// continue ;
72026: GO 71982
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
72028: LD_ADDR_VAR 0 5
72032: PUSH
72033: LD_EXP 52
72037: PUSH
72038: LD_VAR 0 2
72042: ARRAY
72043: PUSH
72044: LD_INT 1
72046: ARRAY
72047: PPUSH
72048: CALL_OW 255
72052: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
72053: LD_VAR 0 5
72057: PPUSH
72058: LD_INT 2
72060: PPUSH
72061: CALL_OW 325
72065: IFFALSE 72318
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
72067: LD_ADDR_VAR 0 4
72071: PUSH
72072: LD_EXP 52
72076: PUSH
72077: LD_VAR 0 2
72081: ARRAY
72082: PPUSH
72083: LD_INT 25
72085: PUSH
72086: LD_INT 16
72088: PUSH
72089: EMPTY
72090: LIST
72091: LIST
72092: PPUSH
72093: CALL_OW 72
72097: ST_TO_ADDR
// if tmp < 6 then
72098: LD_VAR 0 4
72102: PUSH
72103: LD_INT 6
72105: LESS
72106: IFFALSE 72318
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72108: LD_ADDR_VAR 0 6
72112: PUSH
72113: LD_EXP 23
72117: PUSH
72118: LD_VAR 0 2
72122: ARRAY
72123: PPUSH
72124: LD_INT 2
72126: PUSH
72127: LD_INT 30
72129: PUSH
72130: LD_INT 0
72132: PUSH
72133: EMPTY
72134: LIST
72135: LIST
72136: PUSH
72137: LD_INT 30
72139: PUSH
72140: LD_INT 1
72142: PUSH
72143: EMPTY
72144: LIST
72145: LIST
72146: PUSH
72147: EMPTY
72148: LIST
72149: LIST
72150: LIST
72151: PPUSH
72152: CALL_OW 72
72156: ST_TO_ADDR
// if depot then
72157: LD_VAR 0 6
72161: IFFALSE 72318
// begin selected := 0 ;
72163: LD_ADDR_VAR 0 7
72167: PUSH
72168: LD_INT 0
72170: ST_TO_ADDR
// for j in depot do
72171: LD_ADDR_VAR 0 3
72175: PUSH
72176: LD_VAR 0 6
72180: PUSH
72181: FOR_IN
72182: IFFALSE 72213
// begin if UnitsInside ( j ) < 6 then
72184: LD_VAR 0 3
72188: PPUSH
72189: CALL_OW 313
72193: PUSH
72194: LD_INT 6
72196: LESS
72197: IFFALSE 72211
// begin selected := j ;
72199: LD_ADDR_VAR 0 7
72203: PUSH
72204: LD_VAR 0 3
72208: ST_TO_ADDR
// break ;
72209: GO 72213
// end ; end ;
72211: GO 72181
72213: POP
72214: POP
// if selected then
72215: LD_VAR 0 7
72219: IFFALSE 72318
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
72221: LD_ADDR_VAR 0 3
72225: PUSH
72226: LD_EXP 52
72230: PUSH
72231: LD_VAR 0 2
72235: ARRAY
72236: PPUSH
72237: LD_INT 25
72239: PUSH
72240: LD_INT 12
72242: PUSH
72243: EMPTY
72244: LIST
72245: LIST
72246: PPUSH
72247: CALL_OW 72
72251: PUSH
72252: FOR_IN
72253: IFFALSE 72316
// if not HasTask ( j ) then
72255: LD_VAR 0 3
72259: PPUSH
72260: CALL_OW 314
72264: NOT
72265: IFFALSE 72314
// begin if not IsInUnit ( j ) then
72267: LD_VAR 0 3
72271: PPUSH
72272: CALL_OW 310
72276: NOT
72277: IFFALSE 72293
// ComEnterUnit ( j , selected ) ;
72279: LD_VAR 0 3
72283: PPUSH
72284: LD_VAR 0 7
72288: PPUSH
72289: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
72293: LD_VAR 0 3
72297: PPUSH
72298: LD_INT 16
72300: PPUSH
72301: CALL_OW 183
// AddComExitBuilding ( j ) ;
72305: LD_VAR 0 3
72309: PPUSH
72310: CALL_OW 182
// end ;
72314: GO 72252
72316: POP
72317: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
72318: LD_VAR 0 5
72322: PPUSH
72323: LD_INT 11
72325: PPUSH
72326: CALL_OW 325
72330: IFFALSE 72589
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
72332: LD_ADDR_VAR 0 4
72336: PUSH
72337: LD_EXP 52
72341: PUSH
72342: LD_VAR 0 2
72346: ARRAY
72347: PPUSH
72348: LD_INT 25
72350: PUSH
72351: LD_INT 16
72353: PUSH
72354: EMPTY
72355: LIST
72356: LIST
72357: PPUSH
72358: CALL_OW 72
72362: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
72363: LD_VAR 0 4
72367: PUSH
72368: LD_INT 6
72370: GREATEREQUAL
72371: PUSH
72372: LD_VAR 0 5
72376: PPUSH
72377: LD_INT 2
72379: PPUSH
72380: CALL_OW 325
72384: NOT
72385: OR
72386: IFFALSE 72589
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
72388: LD_ADDR_VAR 0 8
72392: PUSH
72393: LD_EXP 23
72397: PUSH
72398: LD_VAR 0 2
72402: ARRAY
72403: PPUSH
72404: LD_INT 2
72406: PUSH
72407: LD_INT 30
72409: PUSH
72410: LD_INT 4
72412: PUSH
72413: EMPTY
72414: LIST
72415: LIST
72416: PUSH
72417: LD_INT 30
72419: PUSH
72420: LD_INT 5
72422: PUSH
72423: EMPTY
72424: LIST
72425: LIST
72426: PUSH
72427: EMPTY
72428: LIST
72429: LIST
72430: LIST
72431: PPUSH
72432: CALL_OW 72
72436: ST_TO_ADDR
// if barracks then
72437: LD_VAR 0 8
72441: IFFALSE 72589
// begin selected := 0 ;
72443: LD_ADDR_VAR 0 7
72447: PUSH
72448: LD_INT 0
72450: ST_TO_ADDR
// for j in barracks do
72451: LD_ADDR_VAR 0 3
72455: PUSH
72456: LD_VAR 0 8
72460: PUSH
72461: FOR_IN
72462: IFFALSE 72493
// begin if UnitsInside ( j ) < 6 then
72464: LD_VAR 0 3
72468: PPUSH
72469: CALL_OW 313
72473: PUSH
72474: LD_INT 6
72476: LESS
72477: IFFALSE 72491
// begin selected := j ;
72479: LD_ADDR_VAR 0 7
72483: PUSH
72484: LD_VAR 0 3
72488: ST_TO_ADDR
// break ;
72489: GO 72493
// end ; end ;
72491: GO 72461
72493: POP
72494: POP
// if selected then
72495: LD_VAR 0 7
72499: IFFALSE 72589
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
72501: LD_ADDR_VAR 0 3
72505: PUSH
72506: LD_EXP 52
72510: PUSH
72511: LD_VAR 0 2
72515: ARRAY
72516: PPUSH
72517: LD_INT 25
72519: PUSH
72520: LD_INT 12
72522: PUSH
72523: EMPTY
72524: LIST
72525: LIST
72526: PPUSH
72527: CALL_OW 72
72531: PUSH
72532: FOR_IN
72533: IFFALSE 72587
// if not IsInUnit ( j ) and not HasTask ( j ) then
72535: LD_VAR 0 3
72539: PPUSH
72540: CALL_OW 310
72544: NOT
72545: PUSH
72546: LD_VAR 0 3
72550: PPUSH
72551: CALL_OW 314
72555: NOT
72556: AND
72557: IFFALSE 72585
// begin ComEnterUnit ( j , selected ) ;
72559: LD_VAR 0 3
72563: PPUSH
72564: LD_VAR 0 7
72568: PPUSH
72569: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
72573: LD_VAR 0 3
72577: PPUSH
72578: LD_INT 15
72580: PPUSH
72581: CALL_OW 183
// end ;
72585: GO 72532
72587: POP
72588: POP
// end ; end ; end ; end ; end ;
72589: GO 71982
72591: POP
72592: POP
// end ;
72593: LD_VAR 0 1
72597: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
72598: LD_INT 0
72600: PPUSH
72601: PPUSH
72602: PPUSH
72603: PPUSH
// if not mc_bases then
72604: LD_EXP 23
72608: NOT
72609: IFFALSE 72613
// exit ;
72611: GO 72791
// for i = 1 to mc_bases do
72613: LD_ADDR_VAR 0 2
72617: PUSH
72618: DOUBLE
72619: LD_INT 1
72621: DEC
72622: ST_TO_ADDR
72623: LD_EXP 23
72627: PUSH
72628: FOR_TO
72629: IFFALSE 72789
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
72631: LD_ADDR_VAR 0 4
72635: PUSH
72636: LD_EXP 23
72640: PUSH
72641: LD_VAR 0 2
72645: ARRAY
72646: PPUSH
72647: LD_INT 25
72649: PUSH
72650: LD_INT 9
72652: PUSH
72653: EMPTY
72654: LIST
72655: LIST
72656: PPUSH
72657: CALL_OW 72
72661: ST_TO_ADDR
// if not tmp then
72662: LD_VAR 0 4
72666: NOT
72667: IFFALSE 72671
// continue ;
72669: GO 72628
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
72671: LD_EXP 49
72675: PUSH
72676: LD_VAR 0 2
72680: ARRAY
72681: PPUSH
72682: LD_INT 29
72684: PPUSH
72685: CALL_OW 325
72689: NOT
72690: PUSH
72691: LD_EXP 49
72695: PUSH
72696: LD_VAR 0 2
72700: ARRAY
72701: PPUSH
72702: LD_INT 28
72704: PPUSH
72705: CALL_OW 325
72709: NOT
72710: AND
72711: IFFALSE 72715
// continue ;
72713: GO 72628
// for j in tmp do
72715: LD_ADDR_VAR 0 3
72719: PUSH
72720: LD_VAR 0 4
72724: PUSH
72725: FOR_IN
72726: IFFALSE 72785
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
72728: LD_VAR 0 3
72732: PUSH
72733: LD_EXP 26
72737: PUSH
72738: LD_VAR 0 2
72742: ARRAY
72743: PUSH
72744: LD_INT 1
72746: ARRAY
72747: IN
72748: NOT
72749: PUSH
72750: LD_VAR 0 3
72754: PUSH
72755: LD_EXP 26
72759: PUSH
72760: LD_VAR 0 2
72764: ARRAY
72765: PUSH
72766: LD_INT 2
72768: ARRAY
72769: IN
72770: NOT
72771: AND
72772: IFFALSE 72783
// ComSpaceTimeShoot ( j ) ;
72774: LD_VAR 0 3
72778: PPUSH
72779: CALL 11920 0 1
72783: GO 72725
72785: POP
72786: POP
// end ;
72787: GO 72628
72789: POP
72790: POP
// end ;
72791: LD_VAR 0 1
72795: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
72796: LD_INT 0
72798: PPUSH
72799: PPUSH
72800: PPUSH
72801: PPUSH
72802: PPUSH
72803: PPUSH
72804: PPUSH
72805: PPUSH
72806: PPUSH
// if not mc_bases then
72807: LD_EXP 23
72811: NOT
72812: IFFALSE 72816
// exit ;
72814: GO 73438
// for i = 1 to mc_bases do
72816: LD_ADDR_VAR 0 2
72820: PUSH
72821: DOUBLE
72822: LD_INT 1
72824: DEC
72825: ST_TO_ADDR
72826: LD_EXP 23
72830: PUSH
72831: FOR_TO
72832: IFFALSE 73436
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
72834: LD_EXP 58
72838: PUSH
72839: LD_VAR 0 2
72843: ARRAY
72844: NOT
72845: PUSH
72846: LD_INT 38
72848: PPUSH
72849: LD_EXP 49
72853: PUSH
72854: LD_VAR 0 2
72858: ARRAY
72859: PPUSH
72860: CALL_OW 321
72864: PUSH
72865: LD_INT 2
72867: NONEQUAL
72868: OR
72869: IFFALSE 72873
// continue ;
72871: GO 72831
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
72873: LD_ADDR_VAR 0 8
72877: PUSH
72878: LD_EXP 23
72882: PUSH
72883: LD_VAR 0 2
72887: ARRAY
72888: PPUSH
72889: LD_INT 30
72891: PUSH
72892: LD_INT 34
72894: PUSH
72895: EMPTY
72896: LIST
72897: LIST
72898: PPUSH
72899: CALL_OW 72
72903: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
72904: LD_ADDR_VAR 0 9
72908: PUSH
72909: LD_EXP 23
72913: PUSH
72914: LD_VAR 0 2
72918: ARRAY
72919: PPUSH
72920: LD_INT 25
72922: PUSH
72923: LD_INT 4
72925: PUSH
72926: EMPTY
72927: LIST
72928: LIST
72929: PPUSH
72930: CALL_OW 72
72934: PPUSH
72935: LD_INT 0
72937: PPUSH
72938: CALL 45996 0 2
72942: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
72943: LD_VAR 0 9
72947: NOT
72948: PUSH
72949: LD_VAR 0 8
72953: NOT
72954: OR
72955: PUSH
72956: LD_EXP 23
72960: PUSH
72961: LD_VAR 0 2
72965: ARRAY
72966: PPUSH
72967: LD_INT 124
72969: PPUSH
72970: CALL 45996 0 2
72974: OR
72975: IFFALSE 72979
// continue ;
72977: GO 72831
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
72979: LD_EXP 59
72983: PUSH
72984: LD_VAR 0 2
72988: ARRAY
72989: PUSH
72990: LD_EXP 58
72994: PUSH
72995: LD_VAR 0 2
72999: ARRAY
73000: LESS
73001: PUSH
73002: LD_EXP 59
73006: PUSH
73007: LD_VAR 0 2
73011: ARRAY
73012: PUSH
73013: LD_VAR 0 8
73017: LESS
73018: AND
73019: IFFALSE 73434
// begin tmp := sci [ 1 ] ;
73021: LD_ADDR_VAR 0 7
73025: PUSH
73026: LD_VAR 0 9
73030: PUSH
73031: LD_INT 1
73033: ARRAY
73034: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
73035: LD_VAR 0 7
73039: PPUSH
73040: LD_INT 124
73042: PPUSH
73043: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
73047: LD_ADDR_VAR 0 3
73051: PUSH
73052: DOUBLE
73053: LD_EXP 58
73057: PUSH
73058: LD_VAR 0 2
73062: ARRAY
73063: INC
73064: ST_TO_ADDR
73065: LD_EXP 58
73069: PUSH
73070: LD_VAR 0 2
73074: ARRAY
73075: PUSH
73076: FOR_DOWNTO
73077: IFFALSE 73420
// begin if IsInUnit ( tmp ) then
73079: LD_VAR 0 7
73083: PPUSH
73084: CALL_OW 310
73088: IFFALSE 73099
// ComExitBuilding ( tmp ) ;
73090: LD_VAR 0 7
73094: PPUSH
73095: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
73099: LD_INT 35
73101: PPUSH
73102: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
73106: LD_VAR 0 7
73110: PPUSH
73111: CALL_OW 310
73115: NOT
73116: PUSH
73117: LD_VAR 0 7
73121: PPUSH
73122: CALL_OW 314
73126: NOT
73127: AND
73128: IFFALSE 73099
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
73130: LD_ADDR_VAR 0 6
73134: PUSH
73135: LD_VAR 0 7
73139: PPUSH
73140: CALL_OW 250
73144: PUSH
73145: LD_VAR 0 7
73149: PPUSH
73150: CALL_OW 251
73154: PUSH
73155: EMPTY
73156: LIST
73157: LIST
73158: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
73159: LD_INT 35
73161: PPUSH
73162: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
73166: LD_ADDR_VAR 0 4
73170: PUSH
73171: LD_EXP 58
73175: PUSH
73176: LD_VAR 0 2
73180: ARRAY
73181: PUSH
73182: LD_VAR 0 3
73186: ARRAY
73187: PUSH
73188: LD_INT 1
73190: ARRAY
73191: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
73192: LD_ADDR_VAR 0 5
73196: PUSH
73197: LD_EXP 58
73201: PUSH
73202: LD_VAR 0 2
73206: ARRAY
73207: PUSH
73208: LD_VAR 0 3
73212: ARRAY
73213: PUSH
73214: LD_INT 2
73216: ARRAY
73217: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
73218: LD_VAR 0 7
73222: PPUSH
73223: LD_INT 10
73225: PPUSH
73226: CALL 18707 0 2
73230: PUSH
73231: LD_INT 4
73233: ARRAY
73234: IFFALSE 73272
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
73236: LD_VAR 0 7
73240: PPUSH
73241: LD_VAR 0 6
73245: PUSH
73246: LD_INT 1
73248: ARRAY
73249: PPUSH
73250: LD_VAR 0 6
73254: PUSH
73255: LD_INT 2
73257: ARRAY
73258: PPUSH
73259: CALL_OW 111
// wait ( 0 0$10 ) ;
73263: LD_INT 350
73265: PPUSH
73266: CALL_OW 67
// end else
73270: GO 73298
// begin ComMoveXY ( tmp , x , y ) ;
73272: LD_VAR 0 7
73276: PPUSH
73277: LD_VAR 0 4
73281: PPUSH
73282: LD_VAR 0 5
73286: PPUSH
73287: CALL_OW 111
// wait ( 0 0$3 ) ;
73291: LD_INT 105
73293: PPUSH
73294: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
73298: LD_VAR 0 7
73302: PPUSH
73303: LD_VAR 0 4
73307: PPUSH
73308: LD_VAR 0 5
73312: PPUSH
73313: CALL_OW 307
73317: IFFALSE 73159
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
73319: LD_VAR 0 7
73323: PPUSH
73324: LD_VAR 0 4
73328: PPUSH
73329: LD_VAR 0 5
73333: PPUSH
73334: LD_VAR 0 8
73338: PUSH
73339: LD_VAR 0 3
73343: ARRAY
73344: PPUSH
73345: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
73349: LD_INT 35
73351: PPUSH
73352: CALL_OW 67
// until not HasTask ( tmp ) ;
73356: LD_VAR 0 7
73360: PPUSH
73361: CALL_OW 314
73365: NOT
73366: IFFALSE 73349
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
73368: LD_ADDR_EXP 59
73372: PUSH
73373: LD_EXP 59
73377: PPUSH
73378: LD_VAR 0 2
73382: PUSH
73383: LD_EXP 59
73387: PUSH
73388: LD_VAR 0 2
73392: ARRAY
73393: PUSH
73394: LD_INT 1
73396: PLUS
73397: PUSH
73398: EMPTY
73399: LIST
73400: LIST
73401: PPUSH
73402: LD_VAR 0 8
73406: PUSH
73407: LD_VAR 0 3
73411: ARRAY
73412: PPUSH
73413: CALL 16110 0 3
73417: ST_TO_ADDR
// end ;
73418: GO 73076
73420: POP
73421: POP
// MC_Reset ( i , 124 ) ;
73422: LD_VAR 0 2
73426: PPUSH
73427: LD_INT 124
73429: PPUSH
73430: CALL 56527 0 2
// end ; end ;
73434: GO 72831
73436: POP
73437: POP
// end ;
73438: LD_VAR 0 1
73442: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
73443: LD_INT 0
73445: PPUSH
73446: PPUSH
73447: PPUSH
// if not mc_bases then
73448: LD_EXP 23
73452: NOT
73453: IFFALSE 73457
// exit ;
73455: GO 74063
// for i = 1 to mc_bases do
73457: LD_ADDR_VAR 0 2
73461: PUSH
73462: DOUBLE
73463: LD_INT 1
73465: DEC
73466: ST_TO_ADDR
73467: LD_EXP 23
73471: PUSH
73472: FOR_TO
73473: IFFALSE 74061
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
73475: LD_ADDR_VAR 0 3
73479: PUSH
73480: LD_EXP 23
73484: PUSH
73485: LD_VAR 0 2
73489: ARRAY
73490: PPUSH
73491: LD_INT 25
73493: PUSH
73494: LD_INT 4
73496: PUSH
73497: EMPTY
73498: LIST
73499: LIST
73500: PPUSH
73501: CALL_OW 72
73505: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
73506: LD_VAR 0 3
73510: NOT
73511: PUSH
73512: LD_EXP 60
73516: PUSH
73517: LD_VAR 0 2
73521: ARRAY
73522: NOT
73523: OR
73524: PUSH
73525: LD_EXP 23
73529: PUSH
73530: LD_VAR 0 2
73534: ARRAY
73535: PPUSH
73536: LD_INT 2
73538: PUSH
73539: LD_INT 30
73541: PUSH
73542: LD_INT 0
73544: PUSH
73545: EMPTY
73546: LIST
73547: LIST
73548: PUSH
73549: LD_INT 30
73551: PUSH
73552: LD_INT 1
73554: PUSH
73555: EMPTY
73556: LIST
73557: LIST
73558: PUSH
73559: EMPTY
73560: LIST
73561: LIST
73562: LIST
73563: PPUSH
73564: CALL_OW 72
73568: NOT
73569: OR
73570: IFFALSE 73620
// begin if mc_deposits_finder [ i ] then
73572: LD_EXP 61
73576: PUSH
73577: LD_VAR 0 2
73581: ARRAY
73582: IFFALSE 73618
// begin MC_Reset ( i , 125 ) ;
73584: LD_VAR 0 2
73588: PPUSH
73589: LD_INT 125
73591: PPUSH
73592: CALL 56527 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
73596: LD_ADDR_EXP 61
73600: PUSH
73601: LD_EXP 61
73605: PPUSH
73606: LD_VAR 0 2
73610: PPUSH
73611: EMPTY
73612: PPUSH
73613: CALL_OW 1
73617: ST_TO_ADDR
// end ; continue ;
73618: GO 73472
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
73620: LD_EXP 60
73624: PUSH
73625: LD_VAR 0 2
73629: ARRAY
73630: PUSH
73631: LD_INT 1
73633: ARRAY
73634: PUSH
73635: LD_INT 3
73637: ARRAY
73638: PUSH
73639: LD_INT 1
73641: EQUAL
73642: PUSH
73643: LD_INT 20
73645: PPUSH
73646: LD_EXP 49
73650: PUSH
73651: LD_VAR 0 2
73655: ARRAY
73656: PPUSH
73657: CALL_OW 321
73661: PUSH
73662: LD_INT 2
73664: NONEQUAL
73665: AND
73666: IFFALSE 73716
// begin if mc_deposits_finder [ i ] then
73668: LD_EXP 61
73672: PUSH
73673: LD_VAR 0 2
73677: ARRAY
73678: IFFALSE 73714
// begin MC_Reset ( i , 125 ) ;
73680: LD_VAR 0 2
73684: PPUSH
73685: LD_INT 125
73687: PPUSH
73688: CALL 56527 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
73692: LD_ADDR_EXP 61
73696: PUSH
73697: LD_EXP 61
73701: PPUSH
73702: LD_VAR 0 2
73706: PPUSH
73707: EMPTY
73708: PPUSH
73709: CALL_OW 1
73713: ST_TO_ADDR
// end ; continue ;
73714: GO 73472
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
73716: LD_EXP 60
73720: PUSH
73721: LD_VAR 0 2
73725: ARRAY
73726: PUSH
73727: LD_INT 1
73729: ARRAY
73730: PUSH
73731: LD_INT 1
73733: ARRAY
73734: PPUSH
73735: LD_EXP 60
73739: PUSH
73740: LD_VAR 0 2
73744: ARRAY
73745: PUSH
73746: LD_INT 1
73748: ARRAY
73749: PUSH
73750: LD_INT 2
73752: ARRAY
73753: PPUSH
73754: LD_EXP 49
73758: PUSH
73759: LD_VAR 0 2
73763: ARRAY
73764: PPUSH
73765: CALL_OW 440
73769: IFFALSE 73812
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
73771: LD_ADDR_EXP 60
73775: PUSH
73776: LD_EXP 60
73780: PPUSH
73781: LD_VAR 0 2
73785: PPUSH
73786: LD_EXP 60
73790: PUSH
73791: LD_VAR 0 2
73795: ARRAY
73796: PPUSH
73797: LD_INT 1
73799: PPUSH
73800: CALL_OW 3
73804: PPUSH
73805: CALL_OW 1
73809: ST_TO_ADDR
73810: GO 74059
// begin if not mc_deposits_finder [ i ] then
73812: LD_EXP 61
73816: PUSH
73817: LD_VAR 0 2
73821: ARRAY
73822: NOT
73823: IFFALSE 73875
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
73825: LD_ADDR_EXP 61
73829: PUSH
73830: LD_EXP 61
73834: PPUSH
73835: LD_VAR 0 2
73839: PPUSH
73840: LD_VAR 0 3
73844: PUSH
73845: LD_INT 1
73847: ARRAY
73848: PUSH
73849: EMPTY
73850: LIST
73851: PPUSH
73852: CALL_OW 1
73856: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
73857: LD_VAR 0 3
73861: PUSH
73862: LD_INT 1
73864: ARRAY
73865: PPUSH
73866: LD_INT 125
73868: PPUSH
73869: CALL_OW 109
// end else
73873: GO 74059
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
73875: LD_EXP 61
73879: PUSH
73880: LD_VAR 0 2
73884: ARRAY
73885: PUSH
73886: LD_INT 1
73888: ARRAY
73889: PPUSH
73890: CALL_OW 310
73894: IFFALSE 73917
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
73896: LD_EXP 61
73900: PUSH
73901: LD_VAR 0 2
73905: ARRAY
73906: PUSH
73907: LD_INT 1
73909: ARRAY
73910: PPUSH
73911: CALL_OW 122
73915: GO 74059
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
73917: LD_EXP 61
73921: PUSH
73922: LD_VAR 0 2
73926: ARRAY
73927: PUSH
73928: LD_INT 1
73930: ARRAY
73931: PPUSH
73932: CALL_OW 314
73936: NOT
73937: PUSH
73938: LD_EXP 61
73942: PUSH
73943: LD_VAR 0 2
73947: ARRAY
73948: PUSH
73949: LD_INT 1
73951: ARRAY
73952: PPUSH
73953: LD_EXP 60
73957: PUSH
73958: LD_VAR 0 2
73962: ARRAY
73963: PUSH
73964: LD_INT 1
73966: ARRAY
73967: PUSH
73968: LD_INT 1
73970: ARRAY
73971: PPUSH
73972: LD_EXP 60
73976: PUSH
73977: LD_VAR 0 2
73981: ARRAY
73982: PUSH
73983: LD_INT 1
73985: ARRAY
73986: PUSH
73987: LD_INT 2
73989: ARRAY
73990: PPUSH
73991: CALL_OW 297
73995: PUSH
73996: LD_INT 6
73998: GREATER
73999: AND
74000: IFFALSE 74059
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
74002: LD_EXP 61
74006: PUSH
74007: LD_VAR 0 2
74011: ARRAY
74012: PUSH
74013: LD_INT 1
74015: ARRAY
74016: PPUSH
74017: LD_EXP 60
74021: PUSH
74022: LD_VAR 0 2
74026: ARRAY
74027: PUSH
74028: LD_INT 1
74030: ARRAY
74031: PUSH
74032: LD_INT 1
74034: ARRAY
74035: PPUSH
74036: LD_EXP 60
74040: PUSH
74041: LD_VAR 0 2
74045: ARRAY
74046: PUSH
74047: LD_INT 1
74049: ARRAY
74050: PUSH
74051: LD_INT 2
74053: ARRAY
74054: PPUSH
74055: CALL_OW 111
// end ; end ; end ;
74059: GO 73472
74061: POP
74062: POP
// end ;
74063: LD_VAR 0 1
74067: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
74068: LD_INT 0
74070: PPUSH
74071: PPUSH
74072: PPUSH
74073: PPUSH
74074: PPUSH
74075: PPUSH
74076: PPUSH
74077: PPUSH
74078: PPUSH
74079: PPUSH
74080: PPUSH
// if not mc_bases then
74081: LD_EXP 23
74085: NOT
74086: IFFALSE 74090
// exit ;
74088: GO 75030
// for i = 1 to mc_bases do
74090: LD_ADDR_VAR 0 2
74094: PUSH
74095: DOUBLE
74096: LD_INT 1
74098: DEC
74099: ST_TO_ADDR
74100: LD_EXP 23
74104: PUSH
74105: FOR_TO
74106: IFFALSE 75028
// begin if not mc_bases [ i ] or mc_scan [ i ] then
74108: LD_EXP 23
74112: PUSH
74113: LD_VAR 0 2
74117: ARRAY
74118: NOT
74119: PUSH
74120: LD_EXP 46
74124: PUSH
74125: LD_VAR 0 2
74129: ARRAY
74130: OR
74131: IFFALSE 74135
// continue ;
74133: GO 74105
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
74135: LD_ADDR_VAR 0 7
74139: PUSH
74140: LD_EXP 23
74144: PUSH
74145: LD_VAR 0 2
74149: ARRAY
74150: PUSH
74151: LD_INT 1
74153: ARRAY
74154: PPUSH
74155: CALL_OW 248
74159: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
74160: LD_VAR 0 7
74164: PUSH
74165: LD_INT 3
74167: EQUAL
74168: PUSH
74169: LD_EXP 42
74173: PUSH
74174: LD_VAR 0 2
74178: ARRAY
74179: PUSH
74180: LD_EXP 45
74184: PUSH
74185: LD_VAR 0 2
74189: ARRAY
74190: UNION
74191: PPUSH
74192: LD_INT 33
74194: PUSH
74195: LD_INT 2
74197: PUSH
74198: EMPTY
74199: LIST
74200: LIST
74201: PPUSH
74202: CALL_OW 72
74206: NOT
74207: OR
74208: IFFALSE 74212
// continue ;
74210: GO 74105
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
74212: LD_ADDR_VAR 0 9
74216: PUSH
74217: LD_EXP 23
74221: PUSH
74222: LD_VAR 0 2
74226: ARRAY
74227: PPUSH
74228: LD_INT 30
74230: PUSH
74231: LD_INT 36
74233: PUSH
74234: EMPTY
74235: LIST
74236: LIST
74237: PPUSH
74238: CALL_OW 72
74242: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
74243: LD_ADDR_VAR 0 10
74247: PUSH
74248: LD_EXP 42
74252: PUSH
74253: LD_VAR 0 2
74257: ARRAY
74258: PPUSH
74259: LD_INT 34
74261: PUSH
74262: LD_INT 31
74264: PUSH
74265: EMPTY
74266: LIST
74267: LIST
74268: PPUSH
74269: CALL_OW 72
74273: ST_TO_ADDR
// if not cts and not mcts then
74274: LD_VAR 0 9
74278: NOT
74279: PUSH
74280: LD_VAR 0 10
74284: NOT
74285: AND
74286: IFFALSE 74290
// continue ;
74288: GO 74105
// x := cts ;
74290: LD_ADDR_VAR 0 11
74294: PUSH
74295: LD_VAR 0 9
74299: ST_TO_ADDR
// if not x then
74300: LD_VAR 0 11
74304: NOT
74305: IFFALSE 74317
// x := mcts ;
74307: LD_ADDR_VAR 0 11
74311: PUSH
74312: LD_VAR 0 10
74316: ST_TO_ADDR
// if not x then
74317: LD_VAR 0 11
74321: NOT
74322: IFFALSE 74326
// continue ;
74324: GO 74105
// if mc_remote_driver [ i ] then
74326: LD_EXP 63
74330: PUSH
74331: LD_VAR 0 2
74335: ARRAY
74336: IFFALSE 74723
// for j in mc_remote_driver [ i ] do
74338: LD_ADDR_VAR 0 3
74342: PUSH
74343: LD_EXP 63
74347: PUSH
74348: LD_VAR 0 2
74352: ARRAY
74353: PUSH
74354: FOR_IN
74355: IFFALSE 74721
// begin if GetClass ( j ) <> 3 then
74357: LD_VAR 0 3
74361: PPUSH
74362: CALL_OW 257
74366: PUSH
74367: LD_INT 3
74369: NONEQUAL
74370: IFFALSE 74423
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
74372: LD_ADDR_EXP 63
74376: PUSH
74377: LD_EXP 63
74381: PPUSH
74382: LD_VAR 0 2
74386: PPUSH
74387: LD_EXP 63
74391: PUSH
74392: LD_VAR 0 2
74396: ARRAY
74397: PUSH
74398: LD_VAR 0 3
74402: DIFF
74403: PPUSH
74404: CALL_OW 1
74408: ST_TO_ADDR
// SetTag ( j , 0 ) ;
74409: LD_VAR 0 3
74413: PPUSH
74414: LD_INT 0
74416: PPUSH
74417: CALL_OW 109
// continue ;
74421: GO 74354
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
74423: LD_EXP 42
74427: PUSH
74428: LD_VAR 0 2
74432: ARRAY
74433: PPUSH
74434: LD_INT 34
74436: PUSH
74437: LD_INT 31
74439: PUSH
74440: EMPTY
74441: LIST
74442: LIST
74443: PUSH
74444: LD_INT 58
74446: PUSH
74447: EMPTY
74448: LIST
74449: PUSH
74450: EMPTY
74451: LIST
74452: LIST
74453: PPUSH
74454: CALL_OW 72
74458: PUSH
74459: LD_VAR 0 3
74463: PPUSH
74464: CALL 46031 0 1
74468: NOT
74469: AND
74470: IFFALSE 74541
// begin if IsInUnit ( j ) then
74472: LD_VAR 0 3
74476: PPUSH
74477: CALL_OW 310
74481: IFFALSE 74492
// ComExitBuilding ( j ) ;
74483: LD_VAR 0 3
74487: PPUSH
74488: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
74492: LD_VAR 0 3
74496: PPUSH
74497: LD_EXP 42
74501: PUSH
74502: LD_VAR 0 2
74506: ARRAY
74507: PPUSH
74508: LD_INT 34
74510: PUSH
74511: LD_INT 31
74513: PUSH
74514: EMPTY
74515: LIST
74516: LIST
74517: PUSH
74518: LD_INT 58
74520: PUSH
74521: EMPTY
74522: LIST
74523: PUSH
74524: EMPTY
74525: LIST
74526: LIST
74527: PPUSH
74528: CALL_OW 72
74532: PUSH
74533: LD_INT 1
74535: ARRAY
74536: PPUSH
74537: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
74541: LD_VAR 0 3
74545: PPUSH
74546: CALL_OW 310
74550: NOT
74551: PUSH
74552: LD_VAR 0 3
74556: PPUSH
74557: CALL_OW 310
74561: PPUSH
74562: CALL_OW 266
74566: PUSH
74567: LD_INT 36
74569: NONEQUAL
74570: PUSH
74571: LD_VAR 0 3
74575: PPUSH
74576: CALL 46031 0 1
74580: NOT
74581: AND
74582: OR
74583: IFFALSE 74719
// begin if IsInUnit ( j ) then
74585: LD_VAR 0 3
74589: PPUSH
74590: CALL_OW 310
74594: IFFALSE 74605
// ComExitBuilding ( j ) ;
74596: LD_VAR 0 3
74600: PPUSH
74601: CALL_OW 122
// ct := 0 ;
74605: LD_ADDR_VAR 0 8
74609: PUSH
74610: LD_INT 0
74612: ST_TO_ADDR
// for k in x do
74613: LD_ADDR_VAR 0 4
74617: PUSH
74618: LD_VAR 0 11
74622: PUSH
74623: FOR_IN
74624: IFFALSE 74697
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
74626: LD_VAR 0 4
74630: PPUSH
74631: CALL_OW 264
74635: PUSH
74636: LD_INT 31
74638: EQUAL
74639: PUSH
74640: LD_VAR 0 4
74644: PPUSH
74645: CALL_OW 311
74649: NOT
74650: AND
74651: PUSH
74652: LD_VAR 0 4
74656: PPUSH
74657: CALL_OW 266
74661: PUSH
74662: LD_INT 36
74664: EQUAL
74665: PUSH
74666: LD_VAR 0 4
74670: PPUSH
74671: CALL_OW 313
74675: PUSH
74676: LD_INT 3
74678: LESS
74679: AND
74680: OR
74681: IFFALSE 74695
// begin ct := k ;
74683: LD_ADDR_VAR 0 8
74687: PUSH
74688: LD_VAR 0 4
74692: ST_TO_ADDR
// break ;
74693: GO 74697
// end ;
74695: GO 74623
74697: POP
74698: POP
// if ct then
74699: LD_VAR 0 8
74703: IFFALSE 74719
// ComEnterUnit ( j , ct ) ;
74705: LD_VAR 0 3
74709: PPUSH
74710: LD_VAR 0 8
74714: PPUSH
74715: CALL_OW 120
// end ; end ;
74719: GO 74354
74721: POP
74722: POP
// places := 0 ;
74723: LD_ADDR_VAR 0 5
74727: PUSH
74728: LD_INT 0
74730: ST_TO_ADDR
// for j = 1 to x do
74731: LD_ADDR_VAR 0 3
74735: PUSH
74736: DOUBLE
74737: LD_INT 1
74739: DEC
74740: ST_TO_ADDR
74741: LD_VAR 0 11
74745: PUSH
74746: FOR_TO
74747: IFFALSE 74823
// if GetWeapon ( x [ j ] ) = ar_control_tower then
74749: LD_VAR 0 11
74753: PUSH
74754: LD_VAR 0 3
74758: ARRAY
74759: PPUSH
74760: CALL_OW 264
74764: PUSH
74765: LD_INT 31
74767: EQUAL
74768: IFFALSE 74786
// places := places + 1 else
74770: LD_ADDR_VAR 0 5
74774: PUSH
74775: LD_VAR 0 5
74779: PUSH
74780: LD_INT 1
74782: PLUS
74783: ST_TO_ADDR
74784: GO 74821
// if GetBType ( x [ j ] ) = b_control_tower then
74786: LD_VAR 0 11
74790: PUSH
74791: LD_VAR 0 3
74795: ARRAY
74796: PPUSH
74797: CALL_OW 266
74801: PUSH
74802: LD_INT 36
74804: EQUAL
74805: IFFALSE 74821
// places := places + 3 ;
74807: LD_ADDR_VAR 0 5
74811: PUSH
74812: LD_VAR 0 5
74816: PUSH
74817: LD_INT 3
74819: PLUS
74820: ST_TO_ADDR
74821: GO 74746
74823: POP
74824: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
74825: LD_VAR 0 5
74829: PUSH
74830: LD_INT 0
74832: EQUAL
74833: PUSH
74834: LD_VAR 0 5
74838: PUSH
74839: LD_EXP 63
74843: PUSH
74844: LD_VAR 0 2
74848: ARRAY
74849: LESSEQUAL
74850: OR
74851: IFFALSE 74855
// continue ;
74853: GO 74105
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
74855: LD_ADDR_VAR 0 6
74859: PUSH
74860: LD_EXP 23
74864: PUSH
74865: LD_VAR 0 2
74869: ARRAY
74870: PPUSH
74871: LD_INT 25
74873: PUSH
74874: LD_INT 3
74876: PUSH
74877: EMPTY
74878: LIST
74879: LIST
74880: PPUSH
74881: CALL_OW 72
74885: PUSH
74886: LD_EXP 63
74890: PUSH
74891: LD_VAR 0 2
74895: ARRAY
74896: DIFF
74897: PPUSH
74898: LD_INT 3
74900: PPUSH
74901: CALL 46931 0 2
74905: ST_TO_ADDR
// for j in tmp do
74906: LD_ADDR_VAR 0 3
74910: PUSH
74911: LD_VAR 0 6
74915: PUSH
74916: FOR_IN
74917: IFFALSE 74952
// if GetTag ( j ) > 0 then
74919: LD_VAR 0 3
74923: PPUSH
74924: CALL_OW 110
74928: PUSH
74929: LD_INT 0
74931: GREATER
74932: IFFALSE 74950
// tmp := tmp diff j ;
74934: LD_ADDR_VAR 0 6
74938: PUSH
74939: LD_VAR 0 6
74943: PUSH
74944: LD_VAR 0 3
74948: DIFF
74949: ST_TO_ADDR
74950: GO 74916
74952: POP
74953: POP
// if not tmp then
74954: LD_VAR 0 6
74958: NOT
74959: IFFALSE 74963
// continue ;
74961: GO 74105
// if places then
74963: LD_VAR 0 5
74967: IFFALSE 75026
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
74969: LD_ADDR_EXP 63
74973: PUSH
74974: LD_EXP 63
74978: PPUSH
74979: LD_VAR 0 2
74983: PPUSH
74984: LD_EXP 63
74988: PUSH
74989: LD_VAR 0 2
74993: ARRAY
74994: PUSH
74995: LD_VAR 0 6
74999: PUSH
75000: LD_INT 1
75002: ARRAY
75003: UNION
75004: PPUSH
75005: CALL_OW 1
75009: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
75010: LD_VAR 0 6
75014: PUSH
75015: LD_INT 1
75017: ARRAY
75018: PPUSH
75019: LD_INT 126
75021: PPUSH
75022: CALL_OW 109
// end ; end ;
75026: GO 74105
75028: POP
75029: POP
// end ;
75030: LD_VAR 0 1
75034: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
75035: LD_INT 0
75037: PPUSH
75038: PPUSH
75039: PPUSH
75040: PPUSH
75041: PPUSH
75042: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
75043: LD_VAR 0 1
75047: NOT
75048: PUSH
75049: LD_VAR 0 2
75053: NOT
75054: OR
75055: PUSH
75056: LD_VAR 0 3
75060: NOT
75061: OR
75062: PUSH
75063: LD_VAR 0 4
75067: PUSH
75068: LD_INT 1
75070: PUSH
75071: LD_INT 2
75073: PUSH
75074: LD_INT 3
75076: PUSH
75077: LD_INT 4
75079: PUSH
75080: LD_INT 5
75082: PUSH
75083: LD_INT 8
75085: PUSH
75086: LD_INT 9
75088: PUSH
75089: LD_INT 15
75091: PUSH
75092: LD_INT 16
75094: PUSH
75095: EMPTY
75096: LIST
75097: LIST
75098: LIST
75099: LIST
75100: LIST
75101: LIST
75102: LIST
75103: LIST
75104: LIST
75105: IN
75106: NOT
75107: OR
75108: IFFALSE 75112
// exit ;
75110: GO 76012
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
75112: LD_ADDR_VAR 0 2
75116: PUSH
75117: LD_VAR 0 2
75121: PPUSH
75122: LD_INT 21
75124: PUSH
75125: LD_INT 3
75127: PUSH
75128: EMPTY
75129: LIST
75130: LIST
75131: PUSH
75132: LD_INT 24
75134: PUSH
75135: LD_INT 250
75137: PUSH
75138: EMPTY
75139: LIST
75140: LIST
75141: PUSH
75142: EMPTY
75143: LIST
75144: LIST
75145: PPUSH
75146: CALL_OW 72
75150: ST_TO_ADDR
// case class of 1 , 15 :
75151: LD_VAR 0 4
75155: PUSH
75156: LD_INT 1
75158: DOUBLE
75159: EQUAL
75160: IFTRUE 75170
75162: LD_INT 15
75164: DOUBLE
75165: EQUAL
75166: IFTRUE 75170
75168: GO 75255
75170: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
75171: LD_ADDR_VAR 0 8
75175: PUSH
75176: LD_VAR 0 2
75180: PPUSH
75181: LD_INT 2
75183: PUSH
75184: LD_INT 30
75186: PUSH
75187: LD_INT 32
75189: PUSH
75190: EMPTY
75191: LIST
75192: LIST
75193: PUSH
75194: LD_INT 30
75196: PUSH
75197: LD_INT 31
75199: PUSH
75200: EMPTY
75201: LIST
75202: LIST
75203: PUSH
75204: EMPTY
75205: LIST
75206: LIST
75207: LIST
75208: PPUSH
75209: CALL_OW 72
75213: PUSH
75214: LD_VAR 0 2
75218: PPUSH
75219: LD_INT 2
75221: PUSH
75222: LD_INT 30
75224: PUSH
75225: LD_INT 4
75227: PUSH
75228: EMPTY
75229: LIST
75230: LIST
75231: PUSH
75232: LD_INT 30
75234: PUSH
75235: LD_INT 5
75237: PUSH
75238: EMPTY
75239: LIST
75240: LIST
75241: PUSH
75242: EMPTY
75243: LIST
75244: LIST
75245: LIST
75246: PPUSH
75247: CALL_OW 72
75251: ADD
75252: ST_TO_ADDR
75253: GO 75501
75255: LD_INT 2
75257: DOUBLE
75258: EQUAL
75259: IFTRUE 75269
75261: LD_INT 16
75263: DOUBLE
75264: EQUAL
75265: IFTRUE 75269
75267: GO 75315
75269: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
75270: LD_ADDR_VAR 0 8
75274: PUSH
75275: LD_VAR 0 2
75279: PPUSH
75280: LD_INT 2
75282: PUSH
75283: LD_INT 30
75285: PUSH
75286: LD_INT 0
75288: PUSH
75289: EMPTY
75290: LIST
75291: LIST
75292: PUSH
75293: LD_INT 30
75295: PUSH
75296: LD_INT 1
75298: PUSH
75299: EMPTY
75300: LIST
75301: LIST
75302: PUSH
75303: EMPTY
75304: LIST
75305: LIST
75306: LIST
75307: PPUSH
75308: CALL_OW 72
75312: ST_TO_ADDR
75313: GO 75501
75315: LD_INT 3
75317: DOUBLE
75318: EQUAL
75319: IFTRUE 75323
75321: GO 75369
75323: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
75324: LD_ADDR_VAR 0 8
75328: PUSH
75329: LD_VAR 0 2
75333: PPUSH
75334: LD_INT 2
75336: PUSH
75337: LD_INT 30
75339: PUSH
75340: LD_INT 2
75342: PUSH
75343: EMPTY
75344: LIST
75345: LIST
75346: PUSH
75347: LD_INT 30
75349: PUSH
75350: LD_INT 3
75352: PUSH
75353: EMPTY
75354: LIST
75355: LIST
75356: PUSH
75357: EMPTY
75358: LIST
75359: LIST
75360: LIST
75361: PPUSH
75362: CALL_OW 72
75366: ST_TO_ADDR
75367: GO 75501
75369: LD_INT 4
75371: DOUBLE
75372: EQUAL
75373: IFTRUE 75377
75375: GO 75434
75377: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
75378: LD_ADDR_VAR 0 8
75382: PUSH
75383: LD_VAR 0 2
75387: PPUSH
75388: LD_INT 2
75390: PUSH
75391: LD_INT 30
75393: PUSH
75394: LD_INT 6
75396: PUSH
75397: EMPTY
75398: LIST
75399: LIST
75400: PUSH
75401: LD_INT 30
75403: PUSH
75404: LD_INT 7
75406: PUSH
75407: EMPTY
75408: LIST
75409: LIST
75410: PUSH
75411: LD_INT 30
75413: PUSH
75414: LD_INT 8
75416: PUSH
75417: EMPTY
75418: LIST
75419: LIST
75420: PUSH
75421: EMPTY
75422: LIST
75423: LIST
75424: LIST
75425: LIST
75426: PPUSH
75427: CALL_OW 72
75431: ST_TO_ADDR
75432: GO 75501
75434: LD_INT 5
75436: DOUBLE
75437: EQUAL
75438: IFTRUE 75454
75440: LD_INT 8
75442: DOUBLE
75443: EQUAL
75444: IFTRUE 75454
75446: LD_INT 9
75448: DOUBLE
75449: EQUAL
75450: IFTRUE 75454
75452: GO 75500
75454: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
75455: LD_ADDR_VAR 0 8
75459: PUSH
75460: LD_VAR 0 2
75464: PPUSH
75465: LD_INT 2
75467: PUSH
75468: LD_INT 30
75470: PUSH
75471: LD_INT 4
75473: PUSH
75474: EMPTY
75475: LIST
75476: LIST
75477: PUSH
75478: LD_INT 30
75480: PUSH
75481: LD_INT 5
75483: PUSH
75484: EMPTY
75485: LIST
75486: LIST
75487: PUSH
75488: EMPTY
75489: LIST
75490: LIST
75491: LIST
75492: PPUSH
75493: CALL_OW 72
75497: ST_TO_ADDR
75498: GO 75501
75500: POP
// if not tmp then
75501: LD_VAR 0 8
75505: NOT
75506: IFFALSE 75510
// exit ;
75508: GO 76012
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
75510: LD_VAR 0 4
75514: PUSH
75515: LD_INT 1
75517: PUSH
75518: LD_INT 15
75520: PUSH
75521: EMPTY
75522: LIST
75523: LIST
75524: IN
75525: PUSH
75526: LD_EXP 32
75530: PUSH
75531: LD_VAR 0 1
75535: ARRAY
75536: AND
75537: IFFALSE 75693
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
75539: LD_ADDR_VAR 0 9
75543: PUSH
75544: LD_EXP 32
75548: PUSH
75549: LD_VAR 0 1
75553: ARRAY
75554: PUSH
75555: LD_INT 1
75557: ARRAY
75558: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
75559: LD_VAR 0 9
75563: PUSH
75564: LD_EXP 33
75568: PUSH
75569: LD_VAR 0 1
75573: ARRAY
75574: IN
75575: NOT
75576: IFFALSE 75691
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
75578: LD_ADDR_EXP 33
75582: PUSH
75583: LD_EXP 33
75587: PPUSH
75588: LD_VAR 0 1
75592: PUSH
75593: LD_EXP 33
75597: PUSH
75598: LD_VAR 0 1
75602: ARRAY
75603: PUSH
75604: LD_INT 1
75606: PLUS
75607: PUSH
75608: EMPTY
75609: LIST
75610: LIST
75611: PPUSH
75612: LD_VAR 0 9
75616: PPUSH
75617: CALL 16110 0 3
75621: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
75622: LD_ADDR_EXP 32
75626: PUSH
75627: LD_EXP 32
75631: PPUSH
75632: LD_VAR 0 1
75636: PPUSH
75637: LD_EXP 32
75641: PUSH
75642: LD_VAR 0 1
75646: ARRAY
75647: PUSH
75648: LD_VAR 0 9
75652: DIFF
75653: PPUSH
75654: CALL_OW 1
75658: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
75659: LD_VAR 0 3
75663: PPUSH
75664: LD_EXP 33
75668: PUSH
75669: LD_VAR 0 1
75673: ARRAY
75674: PUSH
75675: LD_EXP 33
75679: PUSH
75680: LD_VAR 0 1
75684: ARRAY
75685: ARRAY
75686: PPUSH
75687: CALL_OW 120
// end ; exit ;
75691: GO 76012
// end ; if tmp > 1 then
75693: LD_VAR 0 8
75697: PUSH
75698: LD_INT 1
75700: GREATER
75701: IFFALSE 75805
// for i = 2 to tmp do
75703: LD_ADDR_VAR 0 6
75707: PUSH
75708: DOUBLE
75709: LD_INT 2
75711: DEC
75712: ST_TO_ADDR
75713: LD_VAR 0 8
75717: PUSH
75718: FOR_TO
75719: IFFALSE 75803
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
75721: LD_VAR 0 8
75725: PUSH
75726: LD_VAR 0 6
75730: ARRAY
75731: PPUSH
75732: CALL_OW 461
75736: PUSH
75737: LD_INT 6
75739: EQUAL
75740: IFFALSE 75801
// begin x := tmp [ i ] ;
75742: LD_ADDR_VAR 0 9
75746: PUSH
75747: LD_VAR 0 8
75751: PUSH
75752: LD_VAR 0 6
75756: ARRAY
75757: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
75758: LD_ADDR_VAR 0 8
75762: PUSH
75763: LD_VAR 0 8
75767: PPUSH
75768: LD_VAR 0 6
75772: PPUSH
75773: CALL_OW 3
75777: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
75778: LD_ADDR_VAR 0 8
75782: PUSH
75783: LD_VAR 0 8
75787: PPUSH
75788: LD_INT 1
75790: PPUSH
75791: LD_VAR 0 9
75795: PPUSH
75796: CALL_OW 2
75800: ST_TO_ADDR
// end ;
75801: GO 75718
75803: POP
75804: POP
// for i in tmp do
75805: LD_ADDR_VAR 0 6
75809: PUSH
75810: LD_VAR 0 8
75814: PUSH
75815: FOR_IN
75816: IFFALSE 75885
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
75818: LD_VAR 0 6
75822: PPUSH
75823: CALL_OW 313
75827: PUSH
75828: LD_INT 6
75830: LESS
75831: PUSH
75832: LD_VAR 0 6
75836: PPUSH
75837: CALL_OW 266
75841: PUSH
75842: LD_INT 31
75844: PUSH
75845: LD_INT 32
75847: PUSH
75848: EMPTY
75849: LIST
75850: LIST
75851: IN
75852: NOT
75853: AND
75854: PUSH
75855: LD_VAR 0 6
75859: PPUSH
75860: CALL_OW 313
75864: PUSH
75865: LD_INT 0
75867: EQUAL
75868: OR
75869: IFFALSE 75883
// begin j := i ;
75871: LD_ADDR_VAR 0 7
75875: PUSH
75876: LD_VAR 0 6
75880: ST_TO_ADDR
// break ;
75881: GO 75885
// end ; end ;
75883: GO 75815
75885: POP
75886: POP
// if j then
75887: LD_VAR 0 7
75891: IFFALSE 75909
// ComEnterUnit ( unit , j ) else
75893: LD_VAR 0 3
75897: PPUSH
75898: LD_VAR 0 7
75902: PPUSH
75903: CALL_OW 120
75907: GO 76012
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75909: LD_ADDR_VAR 0 10
75913: PUSH
75914: LD_VAR 0 2
75918: PPUSH
75919: LD_INT 2
75921: PUSH
75922: LD_INT 30
75924: PUSH
75925: LD_INT 0
75927: PUSH
75928: EMPTY
75929: LIST
75930: LIST
75931: PUSH
75932: LD_INT 30
75934: PUSH
75935: LD_INT 1
75937: PUSH
75938: EMPTY
75939: LIST
75940: LIST
75941: PUSH
75942: EMPTY
75943: LIST
75944: LIST
75945: LIST
75946: PPUSH
75947: CALL_OW 72
75951: ST_TO_ADDR
// if depot then
75952: LD_VAR 0 10
75956: IFFALSE 76012
// begin depot := NearestUnitToUnit ( depot , unit ) ;
75958: LD_ADDR_VAR 0 10
75962: PUSH
75963: LD_VAR 0 10
75967: PPUSH
75968: LD_VAR 0 3
75972: PPUSH
75973: CALL_OW 74
75977: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
75978: LD_VAR 0 3
75982: PPUSH
75983: LD_VAR 0 10
75987: PPUSH
75988: CALL_OW 296
75992: PUSH
75993: LD_INT 10
75995: GREATER
75996: IFFALSE 76012
// ComStandNearbyBuilding ( unit , depot ) ;
75998: LD_VAR 0 3
76002: PPUSH
76003: LD_VAR 0 10
76007: PPUSH
76008: CALL 12537 0 2
// end ; end ; end ;
76012: LD_VAR 0 5
76016: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
76017: LD_INT 0
76019: PPUSH
76020: PPUSH
76021: PPUSH
76022: PPUSH
// if not mc_bases then
76023: LD_EXP 23
76027: NOT
76028: IFFALSE 76032
// exit ;
76030: GO 76271
// for i = 1 to mc_bases do
76032: LD_ADDR_VAR 0 2
76036: PUSH
76037: DOUBLE
76038: LD_INT 1
76040: DEC
76041: ST_TO_ADDR
76042: LD_EXP 23
76046: PUSH
76047: FOR_TO
76048: IFFALSE 76269
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
76050: LD_ADDR_VAR 0 4
76054: PUSH
76055: LD_EXP 23
76059: PUSH
76060: LD_VAR 0 2
76064: ARRAY
76065: PPUSH
76066: LD_INT 21
76068: PUSH
76069: LD_INT 1
76071: PUSH
76072: EMPTY
76073: LIST
76074: LIST
76075: PPUSH
76076: CALL_OW 72
76080: PUSH
76081: LD_EXP 52
76085: PUSH
76086: LD_VAR 0 2
76090: ARRAY
76091: UNION
76092: ST_TO_ADDR
// if not tmp then
76093: LD_VAR 0 4
76097: NOT
76098: IFFALSE 76102
// continue ;
76100: GO 76047
// for j in tmp do
76102: LD_ADDR_VAR 0 3
76106: PUSH
76107: LD_VAR 0 4
76111: PUSH
76112: FOR_IN
76113: IFFALSE 76265
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
76115: LD_VAR 0 3
76119: PPUSH
76120: CALL_OW 110
76124: NOT
76125: PUSH
76126: LD_VAR 0 3
76130: PPUSH
76131: CALL_OW 314
76135: NOT
76136: AND
76137: PUSH
76138: LD_VAR 0 3
76142: PPUSH
76143: CALL_OW 311
76147: NOT
76148: AND
76149: PUSH
76150: LD_VAR 0 3
76154: PPUSH
76155: CALL_OW 310
76159: NOT
76160: AND
76161: PUSH
76162: LD_VAR 0 3
76166: PUSH
76167: LD_EXP 26
76171: PUSH
76172: LD_VAR 0 2
76176: ARRAY
76177: PUSH
76178: LD_INT 1
76180: ARRAY
76181: IN
76182: NOT
76183: AND
76184: PUSH
76185: LD_VAR 0 3
76189: PUSH
76190: LD_EXP 26
76194: PUSH
76195: LD_VAR 0 2
76199: ARRAY
76200: PUSH
76201: LD_INT 2
76203: ARRAY
76204: IN
76205: NOT
76206: AND
76207: PUSH
76208: LD_VAR 0 3
76212: PUSH
76213: LD_EXP 35
76217: PUSH
76218: LD_VAR 0 2
76222: ARRAY
76223: IN
76224: NOT
76225: AND
76226: IFFALSE 76263
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
76228: LD_VAR 0 2
76232: PPUSH
76233: LD_EXP 23
76237: PUSH
76238: LD_VAR 0 2
76242: ARRAY
76243: PPUSH
76244: LD_VAR 0 3
76248: PPUSH
76249: LD_VAR 0 3
76253: PPUSH
76254: CALL_OW 257
76258: PPUSH
76259: CALL 75035 0 4
// end ;
76263: GO 76112
76265: POP
76266: POP
// end ;
76267: GO 76047
76269: POP
76270: POP
// end ;
76271: LD_VAR 0 1
76275: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
76276: LD_INT 0
76278: PPUSH
76279: PPUSH
76280: PPUSH
76281: PPUSH
76282: PPUSH
76283: PPUSH
// if not mc_bases [ base ] then
76284: LD_EXP 23
76288: PUSH
76289: LD_VAR 0 1
76293: ARRAY
76294: NOT
76295: IFFALSE 76299
// exit ;
76297: GO 76481
// tmp := [ ] ;
76299: LD_ADDR_VAR 0 6
76303: PUSH
76304: EMPTY
76305: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
76306: LD_ADDR_VAR 0 7
76310: PUSH
76311: LD_VAR 0 3
76315: PPUSH
76316: LD_INT 0
76318: PPUSH
76319: CALL_OW 517
76323: ST_TO_ADDR
// if not list then
76324: LD_VAR 0 7
76328: NOT
76329: IFFALSE 76333
// exit ;
76331: GO 76481
// for i = 1 to amount do
76333: LD_ADDR_VAR 0 5
76337: PUSH
76338: DOUBLE
76339: LD_INT 1
76341: DEC
76342: ST_TO_ADDR
76343: LD_VAR 0 2
76347: PUSH
76348: FOR_TO
76349: IFFALSE 76429
// begin x := rand ( 1 , list [ 1 ] ) ;
76351: LD_ADDR_VAR 0 8
76355: PUSH
76356: LD_INT 1
76358: PPUSH
76359: LD_VAR 0 7
76363: PUSH
76364: LD_INT 1
76366: ARRAY
76367: PPUSH
76368: CALL_OW 12
76372: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
76373: LD_ADDR_VAR 0 6
76377: PUSH
76378: LD_VAR 0 6
76382: PPUSH
76383: LD_VAR 0 5
76387: PPUSH
76388: LD_VAR 0 7
76392: PUSH
76393: LD_INT 1
76395: ARRAY
76396: PUSH
76397: LD_VAR 0 8
76401: ARRAY
76402: PUSH
76403: LD_VAR 0 7
76407: PUSH
76408: LD_INT 2
76410: ARRAY
76411: PUSH
76412: LD_VAR 0 8
76416: ARRAY
76417: PUSH
76418: EMPTY
76419: LIST
76420: LIST
76421: PPUSH
76422: CALL_OW 1
76426: ST_TO_ADDR
// end ;
76427: GO 76348
76429: POP
76430: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
76431: LD_ADDR_EXP 36
76435: PUSH
76436: LD_EXP 36
76440: PPUSH
76441: LD_VAR 0 1
76445: PPUSH
76446: LD_VAR 0 6
76450: PPUSH
76451: CALL_OW 1
76455: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
76456: LD_ADDR_EXP 38
76460: PUSH
76461: LD_EXP 38
76465: PPUSH
76466: LD_VAR 0 1
76470: PPUSH
76471: LD_VAR 0 3
76475: PPUSH
76476: CALL_OW 1
76480: ST_TO_ADDR
// end ;
76481: LD_VAR 0 4
76485: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
76486: LD_INT 0
76488: PPUSH
// if not mc_bases [ base ] then
76489: LD_EXP 23
76493: PUSH
76494: LD_VAR 0 1
76498: ARRAY
76499: NOT
76500: IFFALSE 76504
// exit ;
76502: GO 76529
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
76504: LD_ADDR_EXP 28
76508: PUSH
76509: LD_EXP 28
76513: PPUSH
76514: LD_VAR 0 1
76518: PPUSH
76519: LD_VAR 0 2
76523: PPUSH
76524: CALL_OW 1
76528: ST_TO_ADDR
// end ;
76529: LD_VAR 0 3
76533: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
76534: LD_INT 0
76536: PPUSH
// if not mc_bases [ base ] then
76537: LD_EXP 23
76541: PUSH
76542: LD_VAR 0 1
76546: ARRAY
76547: NOT
76548: IFFALSE 76552
// exit ;
76550: GO 76589
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
76552: LD_ADDR_EXP 28
76556: PUSH
76557: LD_EXP 28
76561: PPUSH
76562: LD_VAR 0 1
76566: PPUSH
76567: LD_EXP 28
76571: PUSH
76572: LD_VAR 0 1
76576: ARRAY
76577: PUSH
76578: LD_VAR 0 2
76582: UNION
76583: PPUSH
76584: CALL_OW 1
76588: ST_TO_ADDR
// end ;
76589: LD_VAR 0 3
76593: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
76594: LD_INT 0
76596: PPUSH
// if not mc_bases [ base ] then
76597: LD_EXP 23
76601: PUSH
76602: LD_VAR 0 1
76606: ARRAY
76607: NOT
76608: IFFALSE 76612
// exit ;
76610: GO 76637
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
76612: LD_ADDR_EXP 44
76616: PUSH
76617: LD_EXP 44
76621: PPUSH
76622: LD_VAR 0 1
76626: PPUSH
76627: LD_VAR 0 2
76631: PPUSH
76632: CALL_OW 1
76636: ST_TO_ADDR
// end ;
76637: LD_VAR 0 3
76641: RET
// export function MC_InsertProduceList ( base , components ) ; begin
76642: LD_INT 0
76644: PPUSH
// if not mc_bases [ base ] then
76645: LD_EXP 23
76649: PUSH
76650: LD_VAR 0 1
76654: ARRAY
76655: NOT
76656: IFFALSE 76660
// exit ;
76658: GO 76697
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
76660: LD_ADDR_EXP 44
76664: PUSH
76665: LD_EXP 44
76669: PPUSH
76670: LD_VAR 0 1
76674: PPUSH
76675: LD_EXP 44
76679: PUSH
76680: LD_VAR 0 1
76684: ARRAY
76685: PUSH
76686: LD_VAR 0 2
76690: ADD
76691: PPUSH
76692: CALL_OW 1
76696: ST_TO_ADDR
// end ;
76697: LD_VAR 0 3
76701: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
76702: LD_INT 0
76704: PPUSH
// if not mc_bases [ base ] then
76705: LD_EXP 23
76709: PUSH
76710: LD_VAR 0 1
76714: ARRAY
76715: NOT
76716: IFFALSE 76720
// exit ;
76718: GO 76774
// mc_defender := Replace ( mc_defender , base , deflist ) ;
76720: LD_ADDR_EXP 45
76724: PUSH
76725: LD_EXP 45
76729: PPUSH
76730: LD_VAR 0 1
76734: PPUSH
76735: LD_VAR 0 2
76739: PPUSH
76740: CALL_OW 1
76744: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
76745: LD_ADDR_EXP 34
76749: PUSH
76750: LD_EXP 34
76754: PPUSH
76755: LD_VAR 0 1
76759: PPUSH
76760: LD_VAR 0 2
76764: PUSH
76765: LD_INT 0
76767: PLUS
76768: PPUSH
76769: CALL_OW 1
76773: ST_TO_ADDR
// end ;
76774: LD_VAR 0 3
76778: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
76779: LD_INT 0
76781: PPUSH
// if not mc_bases [ base ] then
76782: LD_EXP 23
76786: PUSH
76787: LD_VAR 0 1
76791: ARRAY
76792: NOT
76793: IFFALSE 76797
// exit ;
76795: GO 76822
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
76797: LD_ADDR_EXP 34
76801: PUSH
76802: LD_EXP 34
76806: PPUSH
76807: LD_VAR 0 1
76811: PPUSH
76812: LD_VAR 0 2
76816: PPUSH
76817: CALL_OW 1
76821: ST_TO_ADDR
// end ;
76822: LD_VAR 0 3
76826: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
76827: LD_INT 0
76829: PPUSH
76830: PPUSH
76831: PPUSH
76832: PPUSH
// if not mc_bases [ base ] then
76833: LD_EXP 23
76837: PUSH
76838: LD_VAR 0 1
76842: ARRAY
76843: NOT
76844: IFFALSE 76848
// exit ;
76846: GO 76913
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
76848: LD_ADDR_EXP 43
76852: PUSH
76853: LD_EXP 43
76857: PPUSH
76858: LD_VAR 0 1
76862: PUSH
76863: LD_EXP 43
76867: PUSH
76868: LD_VAR 0 1
76872: ARRAY
76873: PUSH
76874: LD_INT 1
76876: PLUS
76877: PUSH
76878: EMPTY
76879: LIST
76880: LIST
76881: PPUSH
76882: LD_VAR 0 1
76886: PUSH
76887: LD_VAR 0 2
76891: PUSH
76892: LD_VAR 0 3
76896: PUSH
76897: LD_VAR 0 4
76901: PUSH
76902: EMPTY
76903: LIST
76904: LIST
76905: LIST
76906: LIST
76907: PPUSH
76908: CALL 16110 0 3
76912: ST_TO_ADDR
// end ;
76913: LD_VAR 0 5
76917: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
76918: LD_INT 0
76920: PPUSH
// if not mc_bases [ base ] then
76921: LD_EXP 23
76925: PUSH
76926: LD_VAR 0 1
76930: ARRAY
76931: NOT
76932: IFFALSE 76936
// exit ;
76934: GO 76961
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
76936: LD_ADDR_EXP 60
76940: PUSH
76941: LD_EXP 60
76945: PPUSH
76946: LD_VAR 0 1
76950: PPUSH
76951: LD_VAR 0 2
76955: PPUSH
76956: CALL_OW 1
76960: ST_TO_ADDR
// end ;
76961: LD_VAR 0 3
76965: RET
// export function MC_GetMinesField ( base ) ; begin
76966: LD_INT 0
76968: PPUSH
// result := mc_mines [ base ] ;
76969: LD_ADDR_VAR 0 2
76973: PUSH
76974: LD_EXP 36
76978: PUSH
76979: LD_VAR 0 1
76983: ARRAY
76984: ST_TO_ADDR
// end ;
76985: LD_VAR 0 2
76989: RET
// export function MC_GetProduceList ( base ) ; begin
76990: LD_INT 0
76992: PPUSH
// result := mc_produce [ base ] ;
76993: LD_ADDR_VAR 0 2
76997: PUSH
76998: LD_EXP 44
77002: PUSH
77003: LD_VAR 0 1
77007: ARRAY
77008: ST_TO_ADDR
// end ;
77009: LD_VAR 0 2
77013: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
77014: LD_INT 0
77016: PPUSH
77017: PPUSH
// if not mc_bases then
77018: LD_EXP 23
77022: NOT
77023: IFFALSE 77027
// exit ;
77025: GO 77092
// if mc_bases [ base ] then
77027: LD_EXP 23
77031: PUSH
77032: LD_VAR 0 1
77036: ARRAY
77037: IFFALSE 77092
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
77039: LD_ADDR_VAR 0 3
77043: PUSH
77044: LD_EXP 23
77048: PUSH
77049: LD_VAR 0 1
77053: ARRAY
77054: PPUSH
77055: LD_INT 30
77057: PUSH
77058: LD_VAR 0 2
77062: PUSH
77063: EMPTY
77064: LIST
77065: LIST
77066: PPUSH
77067: CALL_OW 72
77071: ST_TO_ADDR
// if result then
77072: LD_VAR 0 3
77076: IFFALSE 77092
// result := result [ 1 ] ;
77078: LD_ADDR_VAR 0 3
77082: PUSH
77083: LD_VAR 0 3
77087: PUSH
77088: LD_INT 1
77090: ARRAY
77091: ST_TO_ADDR
// end ; end ;
77092: LD_VAR 0 3
77096: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
77097: LD_INT 0
77099: PPUSH
77100: PPUSH
// if not mc_bases then
77101: LD_EXP 23
77105: NOT
77106: IFFALSE 77110
// exit ;
77108: GO 77155
// if mc_bases [ base ] then
77110: LD_EXP 23
77114: PUSH
77115: LD_VAR 0 1
77119: ARRAY
77120: IFFALSE 77155
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
77122: LD_ADDR_VAR 0 3
77126: PUSH
77127: LD_EXP 23
77131: PUSH
77132: LD_VAR 0 1
77136: ARRAY
77137: PPUSH
77138: LD_INT 30
77140: PUSH
77141: LD_VAR 0 2
77145: PUSH
77146: EMPTY
77147: LIST
77148: LIST
77149: PPUSH
77150: CALL_OW 72
77154: ST_TO_ADDR
// end ;
77155: LD_VAR 0 3
77159: RET
// export function MC_SetTame ( base , area ) ; begin
77160: LD_INT 0
77162: PPUSH
// if not mc_bases or not base then
77163: LD_EXP 23
77167: NOT
77168: PUSH
77169: LD_VAR 0 1
77173: NOT
77174: OR
77175: IFFALSE 77179
// exit ;
77177: GO 77204
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
77179: LD_ADDR_EXP 51
77183: PUSH
77184: LD_EXP 51
77188: PPUSH
77189: LD_VAR 0 1
77193: PPUSH
77194: LD_VAR 0 2
77198: PPUSH
77199: CALL_OW 1
77203: ST_TO_ADDR
// end ;
77204: LD_VAR 0 3
77208: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
77209: LD_INT 0
77211: PPUSH
77212: PPUSH
// if not mc_bases or not base then
77213: LD_EXP 23
77217: NOT
77218: PUSH
77219: LD_VAR 0 1
77223: NOT
77224: OR
77225: IFFALSE 77229
// exit ;
77227: GO 77331
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
77229: LD_ADDR_VAR 0 4
77233: PUSH
77234: LD_EXP 23
77238: PUSH
77239: LD_VAR 0 1
77243: ARRAY
77244: PPUSH
77245: LD_INT 30
77247: PUSH
77248: LD_VAR 0 2
77252: PUSH
77253: EMPTY
77254: LIST
77255: LIST
77256: PPUSH
77257: CALL_OW 72
77261: ST_TO_ADDR
// if not tmp then
77262: LD_VAR 0 4
77266: NOT
77267: IFFALSE 77271
// exit ;
77269: GO 77331
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
77271: LD_ADDR_EXP 55
77275: PUSH
77276: LD_EXP 55
77280: PPUSH
77281: LD_VAR 0 1
77285: PPUSH
77286: LD_EXP 55
77290: PUSH
77291: LD_VAR 0 1
77295: ARRAY
77296: PPUSH
77297: LD_EXP 55
77301: PUSH
77302: LD_VAR 0 1
77306: ARRAY
77307: PUSH
77308: LD_INT 1
77310: PLUS
77311: PPUSH
77312: LD_VAR 0 4
77316: PUSH
77317: LD_INT 1
77319: ARRAY
77320: PPUSH
77321: CALL_OW 2
77325: PPUSH
77326: CALL_OW 1
77330: ST_TO_ADDR
// end ;
77331: LD_VAR 0 3
77335: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
77336: LD_INT 0
77338: PPUSH
77339: PPUSH
// if not mc_bases or not base or not kinds then
77340: LD_EXP 23
77344: NOT
77345: PUSH
77346: LD_VAR 0 1
77350: NOT
77351: OR
77352: PUSH
77353: LD_VAR 0 2
77357: NOT
77358: OR
77359: IFFALSE 77363
// exit ;
77361: GO 77424
// for i in kinds do
77363: LD_ADDR_VAR 0 4
77367: PUSH
77368: LD_VAR 0 2
77372: PUSH
77373: FOR_IN
77374: IFFALSE 77422
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
77376: LD_ADDR_EXP 57
77380: PUSH
77381: LD_EXP 57
77385: PPUSH
77386: LD_VAR 0 1
77390: PUSH
77391: LD_EXP 57
77395: PUSH
77396: LD_VAR 0 1
77400: ARRAY
77401: PUSH
77402: LD_INT 1
77404: PLUS
77405: PUSH
77406: EMPTY
77407: LIST
77408: LIST
77409: PPUSH
77410: LD_VAR 0 4
77414: PPUSH
77415: CALL 16110 0 3
77419: ST_TO_ADDR
77420: GO 77373
77422: POP
77423: POP
// end ;
77424: LD_VAR 0 3
77428: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
77429: LD_INT 0
77431: PPUSH
// if not mc_bases or not base or not areas then
77432: LD_EXP 23
77436: NOT
77437: PUSH
77438: LD_VAR 0 1
77442: NOT
77443: OR
77444: PUSH
77445: LD_VAR 0 2
77449: NOT
77450: OR
77451: IFFALSE 77455
// exit ;
77453: GO 77480
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
77455: LD_ADDR_EXP 41
77459: PUSH
77460: LD_EXP 41
77464: PPUSH
77465: LD_VAR 0 1
77469: PPUSH
77470: LD_VAR 0 2
77474: PPUSH
77475: CALL_OW 1
77479: ST_TO_ADDR
// end ;
77480: LD_VAR 0 3
77484: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
77485: LD_INT 0
77487: PPUSH
// if not mc_bases or not base or not teleports_exit then
77488: LD_EXP 23
77492: NOT
77493: PUSH
77494: LD_VAR 0 1
77498: NOT
77499: OR
77500: PUSH
77501: LD_VAR 0 2
77505: NOT
77506: OR
77507: IFFALSE 77511
// exit ;
77509: GO 77536
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
77511: LD_ADDR_EXP 58
77515: PUSH
77516: LD_EXP 58
77520: PPUSH
77521: LD_VAR 0 1
77525: PPUSH
77526: LD_VAR 0 2
77530: PPUSH
77531: CALL_OW 1
77535: ST_TO_ADDR
// end ;
77536: LD_VAR 0 3
77540: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
77541: LD_INT 0
77543: PPUSH
77544: PPUSH
77545: PPUSH
// if not mc_bases or not base or not ext_list then
77546: LD_EXP 23
77550: NOT
77551: PUSH
77552: LD_VAR 0 1
77556: NOT
77557: OR
77558: PUSH
77559: LD_VAR 0 5
77563: NOT
77564: OR
77565: IFFALSE 77569
// exit ;
77567: GO 77742
// tmp := GetFacExtXYD ( x , y , d ) ;
77569: LD_ADDR_VAR 0 8
77573: PUSH
77574: LD_VAR 0 2
77578: PPUSH
77579: LD_VAR 0 3
77583: PPUSH
77584: LD_VAR 0 4
77588: PPUSH
77589: CALL 46061 0 3
77593: ST_TO_ADDR
// if not tmp then
77594: LD_VAR 0 8
77598: NOT
77599: IFFALSE 77603
// exit ;
77601: GO 77742
// for i in tmp do
77603: LD_ADDR_VAR 0 7
77607: PUSH
77608: LD_VAR 0 8
77612: PUSH
77613: FOR_IN
77614: IFFALSE 77740
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
77616: LD_ADDR_EXP 28
77620: PUSH
77621: LD_EXP 28
77625: PPUSH
77626: LD_VAR 0 1
77630: PPUSH
77631: LD_EXP 28
77635: PUSH
77636: LD_VAR 0 1
77640: ARRAY
77641: PPUSH
77642: LD_EXP 28
77646: PUSH
77647: LD_VAR 0 1
77651: ARRAY
77652: PUSH
77653: LD_INT 1
77655: PLUS
77656: PPUSH
77657: LD_VAR 0 5
77661: PUSH
77662: LD_INT 1
77664: ARRAY
77665: PUSH
77666: LD_VAR 0 7
77670: PUSH
77671: LD_INT 1
77673: ARRAY
77674: PUSH
77675: LD_VAR 0 7
77679: PUSH
77680: LD_INT 2
77682: ARRAY
77683: PUSH
77684: LD_VAR 0 7
77688: PUSH
77689: LD_INT 3
77691: ARRAY
77692: PUSH
77693: EMPTY
77694: LIST
77695: LIST
77696: LIST
77697: LIST
77698: PPUSH
77699: CALL_OW 2
77703: PPUSH
77704: CALL_OW 1
77708: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
77709: LD_ADDR_VAR 0 5
77713: PUSH
77714: LD_VAR 0 5
77718: PPUSH
77719: LD_INT 1
77721: PPUSH
77722: CALL_OW 3
77726: ST_TO_ADDR
// if not ext_list then
77727: LD_VAR 0 5
77731: NOT
77732: IFFALSE 77738
// exit ;
77734: POP
77735: POP
77736: GO 77742
// end ;
77738: GO 77613
77740: POP
77741: POP
// end ;
77742: LD_VAR 0 6
77746: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
77747: LD_INT 0
77749: PPUSH
// if not mc_bases or not base or not weapon_list then
77750: LD_EXP 23
77754: NOT
77755: PUSH
77756: LD_VAR 0 1
77760: NOT
77761: OR
77762: PUSH
77763: LD_VAR 0 2
77767: NOT
77768: OR
77769: IFFALSE 77773
// exit ;
77771: GO 77798
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
77773: LD_ADDR_EXP 62
77777: PUSH
77778: LD_EXP 62
77782: PPUSH
77783: LD_VAR 0 1
77787: PPUSH
77788: LD_VAR 0 2
77792: PPUSH
77793: CALL_OW 1
77797: ST_TO_ADDR
// end ;
77798: LD_VAR 0 3
77802: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
77803: LD_INT 0
77805: PPUSH
// if not mc_bases or not base or not tech_list then
77806: LD_EXP 23
77810: NOT
77811: PUSH
77812: LD_VAR 0 1
77816: NOT
77817: OR
77818: PUSH
77819: LD_VAR 0 2
77823: NOT
77824: OR
77825: IFFALSE 77829
// exit ;
77827: GO 77854
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
77829: LD_ADDR_EXP 50
77833: PUSH
77834: LD_EXP 50
77838: PPUSH
77839: LD_VAR 0 1
77843: PPUSH
77844: LD_VAR 0 2
77848: PPUSH
77849: CALL_OW 1
77853: ST_TO_ADDR
// end ;
77854: LD_VAR 0 3
77858: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
77859: LD_INT 0
77861: PPUSH
// if not mc_bases or not parking_area or not base then
77862: LD_EXP 23
77866: NOT
77867: PUSH
77868: LD_VAR 0 2
77872: NOT
77873: OR
77874: PUSH
77875: LD_VAR 0 1
77879: NOT
77880: OR
77881: IFFALSE 77885
// exit ;
77883: GO 77910
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
77885: LD_ADDR_EXP 47
77889: PUSH
77890: LD_EXP 47
77894: PPUSH
77895: LD_VAR 0 1
77899: PPUSH
77900: LD_VAR 0 2
77904: PPUSH
77905: CALL_OW 1
77909: ST_TO_ADDR
// end ;
77910: LD_VAR 0 3
77914: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
77915: LD_INT 0
77917: PPUSH
// if not mc_bases or not base or not scan_area then
77918: LD_EXP 23
77922: NOT
77923: PUSH
77924: LD_VAR 0 1
77928: NOT
77929: OR
77930: PUSH
77931: LD_VAR 0 2
77935: NOT
77936: OR
77937: IFFALSE 77941
// exit ;
77939: GO 77966
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
77941: LD_ADDR_EXP 48
77945: PUSH
77946: LD_EXP 48
77950: PPUSH
77951: LD_VAR 0 1
77955: PPUSH
77956: LD_VAR 0 2
77960: PPUSH
77961: CALL_OW 1
77965: ST_TO_ADDR
// end ;
77966: LD_VAR 0 3
77970: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
77971: LD_INT 0
77973: PPUSH
77974: PPUSH
// if not mc_bases or not base then
77975: LD_EXP 23
77979: NOT
77980: PUSH
77981: LD_VAR 0 1
77985: NOT
77986: OR
77987: IFFALSE 77991
// exit ;
77989: GO 78055
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
77991: LD_ADDR_VAR 0 3
77995: PUSH
77996: LD_INT 1
77998: PUSH
77999: LD_INT 2
78001: PUSH
78002: LD_INT 3
78004: PUSH
78005: LD_INT 4
78007: PUSH
78008: LD_INT 11
78010: PUSH
78011: EMPTY
78012: LIST
78013: LIST
78014: LIST
78015: LIST
78016: LIST
78017: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
78018: LD_ADDR_EXP 50
78022: PUSH
78023: LD_EXP 50
78027: PPUSH
78028: LD_VAR 0 1
78032: PPUSH
78033: LD_EXP 50
78037: PUSH
78038: LD_VAR 0 1
78042: ARRAY
78043: PUSH
78044: LD_VAR 0 3
78048: DIFF
78049: PPUSH
78050: CALL_OW 1
78054: ST_TO_ADDR
// end ;
78055: LD_VAR 0 2
78059: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
78060: LD_INT 0
78062: PPUSH
// result := mc_vehicles [ base ] ;
78063: LD_ADDR_VAR 0 3
78067: PUSH
78068: LD_EXP 42
78072: PUSH
78073: LD_VAR 0 1
78077: ARRAY
78078: ST_TO_ADDR
// if onlyCombat then
78079: LD_VAR 0 2
78083: IFFALSE 78255
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
78085: LD_ADDR_VAR 0 3
78089: PUSH
78090: LD_VAR 0 3
78094: PUSH
78095: LD_VAR 0 3
78099: PPUSH
78100: LD_INT 2
78102: PUSH
78103: LD_INT 34
78105: PUSH
78106: LD_INT 12
78108: PUSH
78109: EMPTY
78110: LIST
78111: LIST
78112: PUSH
78113: LD_INT 34
78115: PUSH
78116: LD_INT 51
78118: PUSH
78119: EMPTY
78120: LIST
78121: LIST
78122: PUSH
78123: LD_INT 34
78125: PUSH
78126: LD_INT 89
78128: PUSH
78129: EMPTY
78130: LIST
78131: LIST
78132: PUSH
78133: LD_INT 34
78135: PUSH
78136: LD_INT 32
78138: PUSH
78139: EMPTY
78140: LIST
78141: LIST
78142: PUSH
78143: LD_INT 34
78145: PUSH
78146: LD_INT 13
78148: PUSH
78149: EMPTY
78150: LIST
78151: LIST
78152: PUSH
78153: LD_INT 34
78155: PUSH
78156: LD_INT 52
78158: PUSH
78159: EMPTY
78160: LIST
78161: LIST
78162: PUSH
78163: LD_INT 34
78165: PUSH
78166: LD_INT 88
78168: PUSH
78169: EMPTY
78170: LIST
78171: LIST
78172: PUSH
78173: LD_INT 34
78175: PUSH
78176: LD_INT 14
78178: PUSH
78179: EMPTY
78180: LIST
78181: LIST
78182: PUSH
78183: LD_INT 34
78185: PUSH
78186: LD_INT 53
78188: PUSH
78189: EMPTY
78190: LIST
78191: LIST
78192: PUSH
78193: LD_INT 34
78195: PUSH
78196: LD_INT 98
78198: PUSH
78199: EMPTY
78200: LIST
78201: LIST
78202: PUSH
78203: LD_INT 34
78205: PUSH
78206: LD_INT 31
78208: PUSH
78209: EMPTY
78210: LIST
78211: LIST
78212: PUSH
78213: LD_INT 34
78215: PUSH
78216: LD_INT 48
78218: PUSH
78219: EMPTY
78220: LIST
78221: LIST
78222: PUSH
78223: LD_INT 34
78225: PUSH
78226: LD_INT 8
78228: PUSH
78229: EMPTY
78230: LIST
78231: LIST
78232: PUSH
78233: EMPTY
78234: LIST
78235: LIST
78236: LIST
78237: LIST
78238: LIST
78239: LIST
78240: LIST
78241: LIST
78242: LIST
78243: LIST
78244: LIST
78245: LIST
78246: LIST
78247: LIST
78248: PPUSH
78249: CALL_OW 72
78253: DIFF
78254: ST_TO_ADDR
// end ; end_of_file
78255: LD_VAR 0 3
78259: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
78260: LD_INT 0
78262: PPUSH
78263: PPUSH
78264: PPUSH
// if not mc_bases or not skirmish then
78265: LD_EXP 23
78269: NOT
78270: PUSH
78271: LD_EXP 21
78275: NOT
78276: OR
78277: IFFALSE 78281
// exit ;
78279: GO 78446
// for i = 1 to mc_bases do
78281: LD_ADDR_VAR 0 4
78285: PUSH
78286: DOUBLE
78287: LD_INT 1
78289: DEC
78290: ST_TO_ADDR
78291: LD_EXP 23
78295: PUSH
78296: FOR_TO
78297: IFFALSE 78444
// begin if sci in mc_bases [ i ] then
78299: LD_VAR 0 2
78303: PUSH
78304: LD_EXP 23
78308: PUSH
78309: LD_VAR 0 4
78313: ARRAY
78314: IN
78315: IFFALSE 78442
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
78317: LD_ADDR_EXP 52
78321: PUSH
78322: LD_EXP 52
78326: PPUSH
78327: LD_VAR 0 4
78331: PUSH
78332: LD_EXP 52
78336: PUSH
78337: LD_VAR 0 4
78341: ARRAY
78342: PUSH
78343: LD_INT 1
78345: PLUS
78346: PUSH
78347: EMPTY
78348: LIST
78349: LIST
78350: PPUSH
78351: LD_VAR 0 1
78355: PPUSH
78356: CALL 16110 0 3
78360: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
78361: LD_ADDR_VAR 0 5
78365: PUSH
78366: LD_EXP 23
78370: PUSH
78371: LD_VAR 0 4
78375: ARRAY
78376: PPUSH
78377: LD_INT 2
78379: PUSH
78380: LD_INT 30
78382: PUSH
78383: LD_INT 0
78385: PUSH
78386: EMPTY
78387: LIST
78388: LIST
78389: PUSH
78390: LD_INT 30
78392: PUSH
78393: LD_INT 1
78395: PUSH
78396: EMPTY
78397: LIST
78398: LIST
78399: PUSH
78400: EMPTY
78401: LIST
78402: LIST
78403: LIST
78404: PPUSH
78405: CALL_OW 72
78409: PPUSH
78410: LD_VAR 0 1
78414: PPUSH
78415: CALL_OW 74
78419: ST_TO_ADDR
// if tmp then
78420: LD_VAR 0 5
78424: IFFALSE 78440
// ComStandNearbyBuilding ( ape , tmp ) ;
78426: LD_VAR 0 1
78430: PPUSH
78431: LD_VAR 0 5
78435: PPUSH
78436: CALL 12537 0 2
// break ;
78440: GO 78444
// end ; end ;
78442: GO 78296
78444: POP
78445: POP
// end ;
78446: LD_VAR 0 3
78450: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
78451: LD_INT 0
78453: PPUSH
78454: PPUSH
78455: PPUSH
// if not mc_bases or not skirmish then
78456: LD_EXP 23
78460: NOT
78461: PUSH
78462: LD_EXP 21
78466: NOT
78467: OR
78468: IFFALSE 78472
// exit ;
78470: GO 78561
// for i = 1 to mc_bases do
78472: LD_ADDR_VAR 0 4
78476: PUSH
78477: DOUBLE
78478: LD_INT 1
78480: DEC
78481: ST_TO_ADDR
78482: LD_EXP 23
78486: PUSH
78487: FOR_TO
78488: IFFALSE 78559
// begin if building in mc_busy_turret_list [ i ] then
78490: LD_VAR 0 1
78494: PUSH
78495: LD_EXP 33
78499: PUSH
78500: LD_VAR 0 4
78504: ARRAY
78505: IN
78506: IFFALSE 78557
// begin tmp := mc_busy_turret_list [ i ] diff building ;
78508: LD_ADDR_VAR 0 5
78512: PUSH
78513: LD_EXP 33
78517: PUSH
78518: LD_VAR 0 4
78522: ARRAY
78523: PUSH
78524: LD_VAR 0 1
78528: DIFF
78529: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
78530: LD_ADDR_EXP 33
78534: PUSH
78535: LD_EXP 33
78539: PPUSH
78540: LD_VAR 0 4
78544: PPUSH
78545: LD_VAR 0 5
78549: PPUSH
78550: CALL_OW 1
78554: ST_TO_ADDR
// break ;
78555: GO 78559
// end ; end ;
78557: GO 78487
78559: POP
78560: POP
// end ;
78561: LD_VAR 0 3
78565: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
78566: LD_INT 0
78568: PPUSH
78569: PPUSH
78570: PPUSH
// if not mc_bases or not skirmish then
78571: LD_EXP 23
78575: NOT
78576: PUSH
78577: LD_EXP 21
78581: NOT
78582: OR
78583: IFFALSE 78587
// exit ;
78585: GO 78786
// for i = 1 to mc_bases do
78587: LD_ADDR_VAR 0 5
78591: PUSH
78592: DOUBLE
78593: LD_INT 1
78595: DEC
78596: ST_TO_ADDR
78597: LD_EXP 23
78601: PUSH
78602: FOR_TO
78603: IFFALSE 78784
// if building in mc_bases [ i ] then
78605: LD_VAR 0 1
78609: PUSH
78610: LD_EXP 23
78614: PUSH
78615: LD_VAR 0 5
78619: ARRAY
78620: IN
78621: IFFALSE 78782
// begin tmp := mc_bases [ i ] diff building ;
78623: LD_ADDR_VAR 0 6
78627: PUSH
78628: LD_EXP 23
78632: PUSH
78633: LD_VAR 0 5
78637: ARRAY
78638: PUSH
78639: LD_VAR 0 1
78643: DIFF
78644: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
78645: LD_ADDR_EXP 23
78649: PUSH
78650: LD_EXP 23
78654: PPUSH
78655: LD_VAR 0 5
78659: PPUSH
78660: LD_VAR 0 6
78664: PPUSH
78665: CALL_OW 1
78669: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
78670: LD_VAR 0 1
78674: PUSH
78675: LD_EXP 31
78679: PUSH
78680: LD_VAR 0 5
78684: ARRAY
78685: IN
78686: IFFALSE 78725
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
78688: LD_ADDR_EXP 31
78692: PUSH
78693: LD_EXP 31
78697: PPUSH
78698: LD_VAR 0 5
78702: PPUSH
78703: LD_EXP 31
78707: PUSH
78708: LD_VAR 0 5
78712: ARRAY
78713: PUSH
78714: LD_VAR 0 1
78718: DIFF
78719: PPUSH
78720: CALL_OW 1
78724: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
78725: LD_VAR 0 1
78729: PUSH
78730: LD_EXP 32
78734: PUSH
78735: LD_VAR 0 5
78739: ARRAY
78740: IN
78741: IFFALSE 78780
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
78743: LD_ADDR_EXP 32
78747: PUSH
78748: LD_EXP 32
78752: PPUSH
78753: LD_VAR 0 5
78757: PPUSH
78758: LD_EXP 32
78762: PUSH
78763: LD_VAR 0 5
78767: ARRAY
78768: PUSH
78769: LD_VAR 0 1
78773: DIFF
78774: PPUSH
78775: CALL_OW 1
78779: ST_TO_ADDR
// break ;
78780: GO 78784
// end ;
78782: GO 78602
78784: POP
78785: POP
// end ;
78786: LD_VAR 0 4
78790: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
78791: LD_INT 0
78793: PPUSH
78794: PPUSH
78795: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
78796: LD_EXP 23
78800: NOT
78801: PUSH
78802: LD_EXP 21
78806: NOT
78807: OR
78808: PUSH
78809: LD_VAR 0 3
78813: PUSH
78814: LD_EXP 49
78818: IN
78819: NOT
78820: OR
78821: IFFALSE 78825
// exit ;
78823: GO 78948
// for i = 1 to mc_vehicles do
78825: LD_ADDR_VAR 0 6
78829: PUSH
78830: DOUBLE
78831: LD_INT 1
78833: DEC
78834: ST_TO_ADDR
78835: LD_EXP 42
78839: PUSH
78840: FOR_TO
78841: IFFALSE 78946
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
78843: LD_VAR 0 2
78847: PUSH
78848: LD_EXP 42
78852: PUSH
78853: LD_VAR 0 6
78857: ARRAY
78858: IN
78859: PUSH
78860: LD_VAR 0 1
78864: PUSH
78865: LD_EXP 42
78869: PUSH
78870: LD_VAR 0 6
78874: ARRAY
78875: IN
78876: OR
78877: IFFALSE 78944
// begin tmp := mc_vehicles [ i ] diff old ;
78879: LD_ADDR_VAR 0 7
78883: PUSH
78884: LD_EXP 42
78888: PUSH
78889: LD_VAR 0 6
78893: ARRAY
78894: PUSH
78895: LD_VAR 0 2
78899: DIFF
78900: ST_TO_ADDR
// tmp := tmp diff new ;
78901: LD_ADDR_VAR 0 7
78905: PUSH
78906: LD_VAR 0 7
78910: PUSH
78911: LD_VAR 0 1
78915: DIFF
78916: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
78917: LD_ADDR_EXP 42
78921: PUSH
78922: LD_EXP 42
78926: PPUSH
78927: LD_VAR 0 6
78931: PPUSH
78932: LD_VAR 0 7
78936: PPUSH
78937: CALL_OW 1
78941: ST_TO_ADDR
// break ;
78942: GO 78946
// end ;
78944: GO 78840
78946: POP
78947: POP
// end ;
78948: LD_VAR 0 5
78952: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
78953: LD_INT 0
78955: PPUSH
78956: PPUSH
78957: PPUSH
78958: PPUSH
// if not mc_bases or not skirmish then
78959: LD_EXP 23
78963: NOT
78964: PUSH
78965: LD_EXP 21
78969: NOT
78970: OR
78971: IFFALSE 78975
// exit ;
78973: GO 79357
// side := GetSide ( vehicle ) ;
78975: LD_ADDR_VAR 0 5
78979: PUSH
78980: LD_VAR 0 1
78984: PPUSH
78985: CALL_OW 255
78989: ST_TO_ADDR
// for i = 1 to mc_bases do
78990: LD_ADDR_VAR 0 4
78994: PUSH
78995: DOUBLE
78996: LD_INT 1
78998: DEC
78999: ST_TO_ADDR
79000: LD_EXP 23
79004: PUSH
79005: FOR_TO
79006: IFFALSE 79355
// begin if factory in mc_bases [ i ] then
79008: LD_VAR 0 2
79012: PUSH
79013: LD_EXP 23
79017: PUSH
79018: LD_VAR 0 4
79022: ARRAY
79023: IN
79024: IFFALSE 79353
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
79026: LD_EXP 45
79030: PUSH
79031: LD_VAR 0 4
79035: ARRAY
79036: PUSH
79037: LD_EXP 34
79041: PUSH
79042: LD_VAR 0 4
79046: ARRAY
79047: LESS
79048: PUSH
79049: LD_VAR 0 1
79053: PPUSH
79054: CALL_OW 264
79058: PUSH
79059: LD_INT 31
79061: PUSH
79062: LD_INT 32
79064: PUSH
79065: LD_INT 51
79067: PUSH
79068: LD_INT 89
79070: PUSH
79071: LD_INT 12
79073: PUSH
79074: LD_INT 30
79076: PUSH
79077: LD_INT 98
79079: PUSH
79080: LD_INT 11
79082: PUSH
79083: LD_INT 53
79085: PUSH
79086: LD_INT 14
79088: PUSH
79089: LD_INT 91
79091: PUSH
79092: LD_INT 29
79094: PUSH
79095: LD_INT 99
79097: PUSH
79098: LD_INT 13
79100: PUSH
79101: LD_INT 52
79103: PUSH
79104: LD_INT 88
79106: PUSH
79107: LD_INT 48
79109: PUSH
79110: LD_INT 8
79112: PUSH
79113: EMPTY
79114: LIST
79115: LIST
79116: LIST
79117: LIST
79118: LIST
79119: LIST
79120: LIST
79121: LIST
79122: LIST
79123: LIST
79124: LIST
79125: LIST
79126: LIST
79127: LIST
79128: LIST
79129: LIST
79130: LIST
79131: LIST
79132: IN
79133: NOT
79134: AND
79135: IFFALSE 79183
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
79137: LD_ADDR_EXP 45
79141: PUSH
79142: LD_EXP 45
79146: PPUSH
79147: LD_VAR 0 4
79151: PUSH
79152: LD_EXP 45
79156: PUSH
79157: LD_VAR 0 4
79161: ARRAY
79162: PUSH
79163: LD_INT 1
79165: PLUS
79166: PUSH
79167: EMPTY
79168: LIST
79169: LIST
79170: PPUSH
79171: LD_VAR 0 1
79175: PPUSH
79176: CALL 16110 0 3
79180: ST_TO_ADDR
79181: GO 79227
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
79183: LD_ADDR_EXP 42
79187: PUSH
79188: LD_EXP 42
79192: PPUSH
79193: LD_VAR 0 4
79197: PUSH
79198: LD_EXP 42
79202: PUSH
79203: LD_VAR 0 4
79207: ARRAY
79208: PUSH
79209: LD_INT 1
79211: PLUS
79212: PUSH
79213: EMPTY
79214: LIST
79215: LIST
79216: PPUSH
79217: LD_VAR 0 1
79221: PPUSH
79222: CALL 16110 0 3
79226: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
79227: LD_VAR 0 1
79231: PPUSH
79232: CALL_OW 263
79236: PUSH
79237: LD_INT 2
79239: EQUAL
79240: IFFALSE 79269
// begin repeat wait ( 0 0$3 ) ;
79242: LD_INT 105
79244: PPUSH
79245: CALL_OW 67
// Connect ( vehicle ) ;
79249: LD_VAR 0 1
79253: PPUSH
79254: CALL 19079 0 1
// until IsControledBy ( vehicle ) ;
79258: LD_VAR 0 1
79262: PPUSH
79263: CALL_OW 312
79267: IFFALSE 79242
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
79269: LD_VAR 0 1
79273: PPUSH
79274: LD_EXP 47
79278: PUSH
79279: LD_VAR 0 4
79283: ARRAY
79284: PPUSH
79285: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
79289: LD_VAR 0 1
79293: PPUSH
79294: CALL_OW 263
79298: PUSH
79299: LD_INT 1
79301: NONEQUAL
79302: IFFALSE 79306
// break ;
79304: GO 79355
// repeat wait ( 0 0$1 ) ;
79306: LD_INT 35
79308: PPUSH
79309: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
79313: LD_VAR 0 1
79317: PPUSH
79318: LD_EXP 47
79322: PUSH
79323: LD_VAR 0 4
79327: ARRAY
79328: PPUSH
79329: CALL_OW 308
79333: IFFALSE 79306
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
79335: LD_VAR 0 1
79339: PPUSH
79340: CALL_OW 311
79344: PPUSH
79345: CALL_OW 121
// exit ;
79349: POP
79350: POP
79351: GO 79357
// end ; end ;
79353: GO 79005
79355: POP
79356: POP
// end ;
79357: LD_VAR 0 3
79361: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
79362: LD_INT 0
79364: PPUSH
79365: PPUSH
79366: PPUSH
79367: PPUSH
// if not mc_bases or not skirmish then
79368: LD_EXP 23
79372: NOT
79373: PUSH
79374: LD_EXP 21
79378: NOT
79379: OR
79380: IFFALSE 79384
// exit ;
79382: GO 79737
// repeat wait ( 0 0$1 ) ;
79384: LD_INT 35
79386: PPUSH
79387: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
79391: LD_VAR 0 2
79395: PPUSH
79396: LD_VAR 0 3
79400: PPUSH
79401: CALL_OW 284
79405: IFFALSE 79384
// if GetResourceTypeXY ( x , y ) = mat_artefact then
79407: LD_VAR 0 2
79411: PPUSH
79412: LD_VAR 0 3
79416: PPUSH
79417: CALL_OW 283
79421: PUSH
79422: LD_INT 4
79424: EQUAL
79425: IFFALSE 79429
// exit ;
79427: GO 79737
// for i = 1 to mc_bases do
79429: LD_ADDR_VAR 0 7
79433: PUSH
79434: DOUBLE
79435: LD_INT 1
79437: DEC
79438: ST_TO_ADDR
79439: LD_EXP 23
79443: PUSH
79444: FOR_TO
79445: IFFALSE 79735
// begin if mc_crates_area [ i ] then
79447: LD_EXP 41
79451: PUSH
79452: LD_VAR 0 7
79456: ARRAY
79457: IFFALSE 79568
// for j in mc_crates_area [ i ] do
79459: LD_ADDR_VAR 0 8
79463: PUSH
79464: LD_EXP 41
79468: PUSH
79469: LD_VAR 0 7
79473: ARRAY
79474: PUSH
79475: FOR_IN
79476: IFFALSE 79566
// if InArea ( x , y , j ) then
79478: LD_VAR 0 2
79482: PPUSH
79483: LD_VAR 0 3
79487: PPUSH
79488: LD_VAR 0 8
79492: PPUSH
79493: CALL_OW 309
79497: IFFALSE 79564
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
79499: LD_ADDR_EXP 39
79503: PUSH
79504: LD_EXP 39
79508: PPUSH
79509: LD_VAR 0 7
79513: PUSH
79514: LD_EXP 39
79518: PUSH
79519: LD_VAR 0 7
79523: ARRAY
79524: PUSH
79525: LD_INT 1
79527: PLUS
79528: PUSH
79529: EMPTY
79530: LIST
79531: LIST
79532: PPUSH
79533: LD_VAR 0 4
79537: PUSH
79538: LD_VAR 0 2
79542: PUSH
79543: LD_VAR 0 3
79547: PUSH
79548: EMPTY
79549: LIST
79550: LIST
79551: LIST
79552: PPUSH
79553: CALL 16110 0 3
79557: ST_TO_ADDR
// exit ;
79558: POP
79559: POP
79560: POP
79561: POP
79562: GO 79737
// end ;
79564: GO 79475
79566: POP
79567: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79568: LD_ADDR_VAR 0 9
79572: PUSH
79573: LD_EXP 23
79577: PUSH
79578: LD_VAR 0 7
79582: ARRAY
79583: PPUSH
79584: LD_INT 2
79586: PUSH
79587: LD_INT 30
79589: PUSH
79590: LD_INT 0
79592: PUSH
79593: EMPTY
79594: LIST
79595: LIST
79596: PUSH
79597: LD_INT 30
79599: PUSH
79600: LD_INT 1
79602: PUSH
79603: EMPTY
79604: LIST
79605: LIST
79606: PUSH
79607: EMPTY
79608: LIST
79609: LIST
79610: LIST
79611: PPUSH
79612: CALL_OW 72
79616: ST_TO_ADDR
// if not depot then
79617: LD_VAR 0 9
79621: NOT
79622: IFFALSE 79626
// continue ;
79624: GO 79444
// for j in depot do
79626: LD_ADDR_VAR 0 8
79630: PUSH
79631: LD_VAR 0 9
79635: PUSH
79636: FOR_IN
79637: IFFALSE 79731
// if GetDistUnitXY ( j , x , y ) < 30 then
79639: LD_VAR 0 8
79643: PPUSH
79644: LD_VAR 0 2
79648: PPUSH
79649: LD_VAR 0 3
79653: PPUSH
79654: CALL_OW 297
79658: PUSH
79659: LD_INT 30
79661: LESS
79662: IFFALSE 79729
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
79664: LD_ADDR_EXP 39
79668: PUSH
79669: LD_EXP 39
79673: PPUSH
79674: LD_VAR 0 7
79678: PUSH
79679: LD_EXP 39
79683: PUSH
79684: LD_VAR 0 7
79688: ARRAY
79689: PUSH
79690: LD_INT 1
79692: PLUS
79693: PUSH
79694: EMPTY
79695: LIST
79696: LIST
79697: PPUSH
79698: LD_VAR 0 4
79702: PUSH
79703: LD_VAR 0 2
79707: PUSH
79708: LD_VAR 0 3
79712: PUSH
79713: EMPTY
79714: LIST
79715: LIST
79716: LIST
79717: PPUSH
79718: CALL 16110 0 3
79722: ST_TO_ADDR
// exit ;
79723: POP
79724: POP
79725: POP
79726: POP
79727: GO 79737
// end ;
79729: GO 79636
79731: POP
79732: POP
// end ;
79733: GO 79444
79735: POP
79736: POP
// end ;
79737: LD_VAR 0 6
79741: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
79742: LD_INT 0
79744: PPUSH
79745: PPUSH
79746: PPUSH
79747: PPUSH
// if not mc_bases or not skirmish then
79748: LD_EXP 23
79752: NOT
79753: PUSH
79754: LD_EXP 21
79758: NOT
79759: OR
79760: IFFALSE 79764
// exit ;
79762: GO 80041
// side := GetSide ( lab ) ;
79764: LD_ADDR_VAR 0 4
79768: PUSH
79769: LD_VAR 0 2
79773: PPUSH
79774: CALL_OW 255
79778: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
79779: LD_VAR 0 4
79783: PUSH
79784: LD_EXP 49
79788: IN
79789: NOT
79790: PUSH
79791: LD_EXP 50
79795: NOT
79796: OR
79797: PUSH
79798: LD_EXP 23
79802: NOT
79803: OR
79804: IFFALSE 79808
// exit ;
79806: GO 80041
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
79808: LD_ADDR_EXP 50
79812: PUSH
79813: LD_EXP 50
79817: PPUSH
79818: LD_VAR 0 4
79822: PPUSH
79823: LD_EXP 50
79827: PUSH
79828: LD_VAR 0 4
79832: ARRAY
79833: PUSH
79834: LD_VAR 0 1
79838: DIFF
79839: PPUSH
79840: CALL_OW 1
79844: ST_TO_ADDR
// for i = 1 to mc_bases do
79845: LD_ADDR_VAR 0 5
79849: PUSH
79850: DOUBLE
79851: LD_INT 1
79853: DEC
79854: ST_TO_ADDR
79855: LD_EXP 23
79859: PUSH
79860: FOR_TO
79861: IFFALSE 80039
// begin if lab in mc_bases [ i ] then
79863: LD_VAR 0 2
79867: PUSH
79868: LD_EXP 23
79872: PUSH
79873: LD_VAR 0 5
79877: ARRAY
79878: IN
79879: IFFALSE 80037
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
79881: LD_VAR 0 1
79885: PUSH
79886: LD_INT 11
79888: PUSH
79889: LD_INT 4
79891: PUSH
79892: LD_INT 3
79894: PUSH
79895: LD_INT 2
79897: PUSH
79898: EMPTY
79899: LIST
79900: LIST
79901: LIST
79902: LIST
79903: IN
79904: PUSH
79905: LD_EXP 53
79909: PUSH
79910: LD_VAR 0 5
79914: ARRAY
79915: AND
79916: IFFALSE 80037
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
79918: LD_ADDR_VAR 0 6
79922: PUSH
79923: LD_EXP 53
79927: PUSH
79928: LD_VAR 0 5
79932: ARRAY
79933: PUSH
79934: LD_INT 1
79936: ARRAY
79937: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
79938: LD_ADDR_EXP 53
79942: PUSH
79943: LD_EXP 53
79947: PPUSH
79948: LD_VAR 0 5
79952: PPUSH
79953: EMPTY
79954: PPUSH
79955: CALL_OW 1
79959: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
79960: LD_VAR 0 6
79964: PPUSH
79965: LD_INT 0
79967: PPUSH
79968: CALL_OW 109
// ComExitBuilding ( tmp ) ;
79972: LD_VAR 0 6
79976: PPUSH
79977: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
79981: LD_ADDR_EXP 52
79985: PUSH
79986: LD_EXP 52
79990: PPUSH
79991: LD_VAR 0 5
79995: PPUSH
79996: LD_EXP 52
80000: PUSH
80001: LD_VAR 0 5
80005: ARRAY
80006: PPUSH
80007: LD_INT 1
80009: PPUSH
80010: LD_VAR 0 6
80014: PPUSH
80015: CALL_OW 2
80019: PPUSH
80020: CALL_OW 1
80024: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
80025: LD_VAR 0 5
80029: PPUSH
80030: LD_INT 112
80032: PPUSH
80033: CALL 56527 0 2
// end ; end ; end ;
80037: GO 79860
80039: POP
80040: POP
// end ;
80041: LD_VAR 0 3
80045: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
80046: LD_INT 0
80048: PPUSH
80049: PPUSH
80050: PPUSH
80051: PPUSH
80052: PPUSH
80053: PPUSH
80054: PPUSH
80055: PPUSH
// if not mc_bases or not skirmish then
80056: LD_EXP 23
80060: NOT
80061: PUSH
80062: LD_EXP 21
80066: NOT
80067: OR
80068: IFFALSE 80072
// exit ;
80070: GO 81441
// for i = 1 to mc_bases do
80072: LD_ADDR_VAR 0 3
80076: PUSH
80077: DOUBLE
80078: LD_INT 1
80080: DEC
80081: ST_TO_ADDR
80082: LD_EXP 23
80086: PUSH
80087: FOR_TO
80088: IFFALSE 81439
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
80090: LD_VAR 0 1
80094: PUSH
80095: LD_EXP 23
80099: PUSH
80100: LD_VAR 0 3
80104: ARRAY
80105: IN
80106: PUSH
80107: LD_VAR 0 1
80111: PUSH
80112: LD_EXP 30
80116: PUSH
80117: LD_VAR 0 3
80121: ARRAY
80122: IN
80123: OR
80124: PUSH
80125: LD_VAR 0 1
80129: PUSH
80130: LD_EXP 45
80134: PUSH
80135: LD_VAR 0 3
80139: ARRAY
80140: IN
80141: OR
80142: PUSH
80143: LD_VAR 0 1
80147: PUSH
80148: LD_EXP 42
80152: PUSH
80153: LD_VAR 0 3
80157: ARRAY
80158: IN
80159: OR
80160: PUSH
80161: LD_VAR 0 1
80165: PUSH
80166: LD_EXP 52
80170: PUSH
80171: LD_VAR 0 3
80175: ARRAY
80176: IN
80177: OR
80178: PUSH
80179: LD_VAR 0 1
80183: PUSH
80184: LD_EXP 53
80188: PUSH
80189: LD_VAR 0 3
80193: ARRAY
80194: IN
80195: OR
80196: IFFALSE 81437
// begin if un in mc_ape [ i ] then
80198: LD_VAR 0 1
80202: PUSH
80203: LD_EXP 52
80207: PUSH
80208: LD_VAR 0 3
80212: ARRAY
80213: IN
80214: IFFALSE 80253
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
80216: LD_ADDR_EXP 52
80220: PUSH
80221: LD_EXP 52
80225: PPUSH
80226: LD_VAR 0 3
80230: PPUSH
80231: LD_EXP 52
80235: PUSH
80236: LD_VAR 0 3
80240: ARRAY
80241: PUSH
80242: LD_VAR 0 1
80246: DIFF
80247: PPUSH
80248: CALL_OW 1
80252: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
80253: LD_VAR 0 1
80257: PUSH
80258: LD_EXP 53
80262: PUSH
80263: LD_VAR 0 3
80267: ARRAY
80268: IN
80269: IFFALSE 80293
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
80271: LD_ADDR_EXP 53
80275: PUSH
80276: LD_EXP 53
80280: PPUSH
80281: LD_VAR 0 3
80285: PPUSH
80286: EMPTY
80287: PPUSH
80288: CALL_OW 1
80292: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
80293: LD_VAR 0 1
80297: PPUSH
80298: CALL_OW 247
80302: PUSH
80303: LD_INT 2
80305: EQUAL
80306: PUSH
80307: LD_VAR 0 1
80311: PPUSH
80312: CALL_OW 110
80316: PUSH
80317: LD_INT 20
80319: EQUAL
80320: PUSH
80321: LD_VAR 0 1
80325: PUSH
80326: LD_EXP 45
80330: PUSH
80331: LD_VAR 0 3
80335: ARRAY
80336: IN
80337: OR
80338: PUSH
80339: LD_VAR 0 1
80343: PPUSH
80344: CALL_OW 264
80348: PUSH
80349: LD_INT 12
80351: PUSH
80352: LD_INT 51
80354: PUSH
80355: LD_INT 89
80357: PUSH
80358: LD_INT 32
80360: PUSH
80361: LD_INT 13
80363: PUSH
80364: LD_INT 52
80366: PUSH
80367: LD_INT 31
80369: PUSH
80370: EMPTY
80371: LIST
80372: LIST
80373: LIST
80374: LIST
80375: LIST
80376: LIST
80377: LIST
80378: IN
80379: OR
80380: AND
80381: IFFALSE 80689
// begin if un in mc_defender [ i ] then
80383: LD_VAR 0 1
80387: PUSH
80388: LD_EXP 45
80392: PUSH
80393: LD_VAR 0 3
80397: ARRAY
80398: IN
80399: IFFALSE 80438
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
80401: LD_ADDR_EXP 45
80405: PUSH
80406: LD_EXP 45
80410: PPUSH
80411: LD_VAR 0 3
80415: PPUSH
80416: LD_EXP 45
80420: PUSH
80421: LD_VAR 0 3
80425: ARRAY
80426: PUSH
80427: LD_VAR 0 1
80431: DIFF
80432: PPUSH
80433: CALL_OW 1
80437: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
80438: LD_ADDR_VAR 0 8
80442: PUSH
80443: LD_VAR 0 3
80447: PPUSH
80448: LD_INT 3
80450: PPUSH
80451: CALL 77097 0 2
80455: ST_TO_ADDR
// if fac then
80456: LD_VAR 0 8
80460: IFFALSE 80689
// begin for j in fac do
80462: LD_ADDR_VAR 0 4
80466: PUSH
80467: LD_VAR 0 8
80471: PUSH
80472: FOR_IN
80473: IFFALSE 80687
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
80475: LD_ADDR_VAR 0 9
80479: PUSH
80480: LD_VAR 0 8
80484: PPUSH
80485: LD_VAR 0 1
80489: PPUSH
80490: CALL_OW 265
80494: PPUSH
80495: LD_VAR 0 1
80499: PPUSH
80500: CALL_OW 262
80504: PPUSH
80505: LD_VAR 0 1
80509: PPUSH
80510: CALL_OW 263
80514: PPUSH
80515: LD_VAR 0 1
80519: PPUSH
80520: CALL_OW 264
80524: PPUSH
80525: CALL 13608 0 5
80529: ST_TO_ADDR
// if components then
80530: LD_VAR 0 9
80534: IFFALSE 80685
// begin if GetWeapon ( un ) = ar_control_tower then
80536: LD_VAR 0 1
80540: PPUSH
80541: CALL_OW 264
80545: PUSH
80546: LD_INT 31
80548: EQUAL
80549: IFFALSE 80666
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
80551: LD_VAR 0 1
80555: PPUSH
80556: CALL_OW 311
80560: PPUSH
80561: LD_INT 0
80563: PPUSH
80564: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
80568: LD_ADDR_EXP 63
80572: PUSH
80573: LD_EXP 63
80577: PPUSH
80578: LD_VAR 0 3
80582: PPUSH
80583: LD_EXP 63
80587: PUSH
80588: LD_VAR 0 3
80592: ARRAY
80593: PUSH
80594: LD_VAR 0 1
80598: PPUSH
80599: CALL_OW 311
80603: DIFF
80604: PPUSH
80605: CALL_OW 1
80609: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
80610: LD_ADDR_VAR 0 7
80614: PUSH
80615: LD_EXP 44
80619: PUSH
80620: LD_VAR 0 3
80624: ARRAY
80625: PPUSH
80626: LD_INT 1
80628: PPUSH
80629: LD_VAR 0 9
80633: PPUSH
80634: CALL_OW 2
80638: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
80639: LD_ADDR_EXP 44
80643: PUSH
80644: LD_EXP 44
80648: PPUSH
80649: LD_VAR 0 3
80653: PPUSH
80654: LD_VAR 0 7
80658: PPUSH
80659: CALL_OW 1
80663: ST_TO_ADDR
// end else
80664: GO 80683
// MC_InsertProduceList ( i , [ components ] ) ;
80666: LD_VAR 0 3
80670: PPUSH
80671: LD_VAR 0 9
80675: PUSH
80676: EMPTY
80677: LIST
80678: PPUSH
80679: CALL 76642 0 2
// break ;
80683: GO 80687
// end ; end ;
80685: GO 80472
80687: POP
80688: POP
// end ; end ; if GetType ( un ) = unit_building then
80689: LD_VAR 0 1
80693: PPUSH
80694: CALL_OW 247
80698: PUSH
80699: LD_INT 3
80701: EQUAL
80702: IFFALSE 81105
// begin btype := GetBType ( un ) ;
80704: LD_ADDR_VAR 0 5
80708: PUSH
80709: LD_VAR 0 1
80713: PPUSH
80714: CALL_OW 266
80718: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
80719: LD_VAR 0 5
80723: PUSH
80724: LD_INT 29
80726: PUSH
80727: LD_INT 30
80729: PUSH
80730: EMPTY
80731: LIST
80732: LIST
80733: IN
80734: IFFALSE 80807
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
80736: LD_VAR 0 1
80740: PPUSH
80741: CALL_OW 250
80745: PPUSH
80746: LD_VAR 0 1
80750: PPUSH
80751: CALL_OW 251
80755: PPUSH
80756: LD_VAR 0 1
80760: PPUSH
80761: CALL_OW 255
80765: PPUSH
80766: CALL_OW 440
80770: NOT
80771: IFFALSE 80807
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
80773: LD_VAR 0 1
80777: PPUSH
80778: CALL_OW 250
80782: PPUSH
80783: LD_VAR 0 1
80787: PPUSH
80788: CALL_OW 251
80792: PPUSH
80793: LD_VAR 0 1
80797: PPUSH
80798: CALL_OW 255
80802: PPUSH
80803: CALL_OW 441
// end ; if btype = b_warehouse then
80807: LD_VAR 0 5
80811: PUSH
80812: LD_INT 1
80814: EQUAL
80815: IFFALSE 80833
// begin btype := b_depot ;
80817: LD_ADDR_VAR 0 5
80821: PUSH
80822: LD_INT 0
80824: ST_TO_ADDR
// pos := 1 ;
80825: LD_ADDR_VAR 0 6
80829: PUSH
80830: LD_INT 1
80832: ST_TO_ADDR
// end ; if btype = b_factory then
80833: LD_VAR 0 5
80837: PUSH
80838: LD_INT 3
80840: EQUAL
80841: IFFALSE 80859
// begin btype := b_workshop ;
80843: LD_ADDR_VAR 0 5
80847: PUSH
80848: LD_INT 2
80850: ST_TO_ADDR
// pos := 1 ;
80851: LD_ADDR_VAR 0 6
80855: PUSH
80856: LD_INT 1
80858: ST_TO_ADDR
// end ; if btype = b_barracks then
80859: LD_VAR 0 5
80863: PUSH
80864: LD_INT 5
80866: EQUAL
80867: IFFALSE 80877
// btype := b_armoury ;
80869: LD_ADDR_VAR 0 5
80873: PUSH
80874: LD_INT 4
80876: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
80877: LD_VAR 0 5
80881: PUSH
80882: LD_INT 7
80884: PUSH
80885: LD_INT 8
80887: PUSH
80888: EMPTY
80889: LIST
80890: LIST
80891: IN
80892: IFFALSE 80902
// btype := b_lab ;
80894: LD_ADDR_VAR 0 5
80898: PUSH
80899: LD_INT 6
80901: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
80902: LD_ADDR_EXP 28
80906: PUSH
80907: LD_EXP 28
80911: PPUSH
80912: LD_VAR 0 3
80916: PUSH
80917: LD_EXP 28
80921: PUSH
80922: LD_VAR 0 3
80926: ARRAY
80927: PUSH
80928: LD_INT 1
80930: PLUS
80931: PUSH
80932: EMPTY
80933: LIST
80934: LIST
80935: PPUSH
80936: LD_VAR 0 5
80940: PUSH
80941: LD_VAR 0 1
80945: PPUSH
80946: CALL_OW 250
80950: PUSH
80951: LD_VAR 0 1
80955: PPUSH
80956: CALL_OW 251
80960: PUSH
80961: LD_VAR 0 1
80965: PPUSH
80966: CALL_OW 254
80970: PUSH
80971: EMPTY
80972: LIST
80973: LIST
80974: LIST
80975: LIST
80976: PPUSH
80977: CALL 16110 0 3
80981: ST_TO_ADDR
// if pos = 1 then
80982: LD_VAR 0 6
80986: PUSH
80987: LD_INT 1
80989: EQUAL
80990: IFFALSE 81105
// begin tmp := mc_build_list [ i ] ;
80992: LD_ADDR_VAR 0 7
80996: PUSH
80997: LD_EXP 28
81001: PUSH
81002: LD_VAR 0 3
81006: ARRAY
81007: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
81008: LD_VAR 0 7
81012: PPUSH
81013: LD_INT 2
81015: PUSH
81016: LD_INT 30
81018: PUSH
81019: LD_INT 0
81021: PUSH
81022: EMPTY
81023: LIST
81024: LIST
81025: PUSH
81026: LD_INT 30
81028: PUSH
81029: LD_INT 1
81031: PUSH
81032: EMPTY
81033: LIST
81034: LIST
81035: PUSH
81036: EMPTY
81037: LIST
81038: LIST
81039: LIST
81040: PPUSH
81041: CALL_OW 72
81045: IFFALSE 81055
// pos := 2 ;
81047: LD_ADDR_VAR 0 6
81051: PUSH
81052: LD_INT 2
81054: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
81055: LD_ADDR_VAR 0 7
81059: PUSH
81060: LD_VAR 0 7
81064: PPUSH
81065: LD_VAR 0 6
81069: PPUSH
81070: LD_VAR 0 7
81074: PPUSH
81075: CALL 16436 0 3
81079: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
81080: LD_ADDR_EXP 28
81084: PUSH
81085: LD_EXP 28
81089: PPUSH
81090: LD_VAR 0 3
81094: PPUSH
81095: LD_VAR 0 7
81099: PPUSH
81100: CALL_OW 1
81104: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
81105: LD_VAR 0 1
81109: PUSH
81110: LD_EXP 23
81114: PUSH
81115: LD_VAR 0 3
81119: ARRAY
81120: IN
81121: IFFALSE 81160
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
81123: LD_ADDR_EXP 23
81127: PUSH
81128: LD_EXP 23
81132: PPUSH
81133: LD_VAR 0 3
81137: PPUSH
81138: LD_EXP 23
81142: PUSH
81143: LD_VAR 0 3
81147: ARRAY
81148: PUSH
81149: LD_VAR 0 1
81153: DIFF
81154: PPUSH
81155: CALL_OW 1
81159: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
81160: LD_VAR 0 1
81164: PUSH
81165: LD_EXP 30
81169: PUSH
81170: LD_VAR 0 3
81174: ARRAY
81175: IN
81176: IFFALSE 81215
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
81178: LD_ADDR_EXP 30
81182: PUSH
81183: LD_EXP 30
81187: PPUSH
81188: LD_VAR 0 3
81192: PPUSH
81193: LD_EXP 30
81197: PUSH
81198: LD_VAR 0 3
81202: ARRAY
81203: PUSH
81204: LD_VAR 0 1
81208: DIFF
81209: PPUSH
81210: CALL_OW 1
81214: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
81215: LD_VAR 0 1
81219: PUSH
81220: LD_EXP 42
81224: PUSH
81225: LD_VAR 0 3
81229: ARRAY
81230: IN
81231: IFFALSE 81270
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
81233: LD_ADDR_EXP 42
81237: PUSH
81238: LD_EXP 42
81242: PPUSH
81243: LD_VAR 0 3
81247: PPUSH
81248: LD_EXP 42
81252: PUSH
81253: LD_VAR 0 3
81257: ARRAY
81258: PUSH
81259: LD_VAR 0 1
81263: DIFF
81264: PPUSH
81265: CALL_OW 1
81269: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
81270: LD_VAR 0 1
81274: PUSH
81275: LD_EXP 45
81279: PUSH
81280: LD_VAR 0 3
81284: ARRAY
81285: IN
81286: IFFALSE 81325
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
81288: LD_ADDR_EXP 45
81292: PUSH
81293: LD_EXP 45
81297: PPUSH
81298: LD_VAR 0 3
81302: PPUSH
81303: LD_EXP 45
81307: PUSH
81308: LD_VAR 0 3
81312: ARRAY
81313: PUSH
81314: LD_VAR 0 1
81318: DIFF
81319: PPUSH
81320: CALL_OW 1
81324: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
81325: LD_VAR 0 1
81329: PUSH
81330: LD_EXP 32
81334: PUSH
81335: LD_VAR 0 3
81339: ARRAY
81340: IN
81341: IFFALSE 81380
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
81343: LD_ADDR_EXP 32
81347: PUSH
81348: LD_EXP 32
81352: PPUSH
81353: LD_VAR 0 3
81357: PPUSH
81358: LD_EXP 32
81362: PUSH
81363: LD_VAR 0 3
81367: ARRAY
81368: PUSH
81369: LD_VAR 0 1
81373: DIFF
81374: PPUSH
81375: CALL_OW 1
81379: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
81380: LD_VAR 0 1
81384: PUSH
81385: LD_EXP 31
81389: PUSH
81390: LD_VAR 0 3
81394: ARRAY
81395: IN
81396: IFFALSE 81435
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
81398: LD_ADDR_EXP 31
81402: PUSH
81403: LD_EXP 31
81407: PPUSH
81408: LD_VAR 0 3
81412: PPUSH
81413: LD_EXP 31
81417: PUSH
81418: LD_VAR 0 3
81422: ARRAY
81423: PUSH
81424: LD_VAR 0 1
81428: DIFF
81429: PPUSH
81430: CALL_OW 1
81434: ST_TO_ADDR
// end ; break ;
81435: GO 81439
// end ;
81437: GO 80087
81439: POP
81440: POP
// end ;
81441: LD_VAR 0 2
81445: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
81446: LD_INT 0
81448: PPUSH
81449: PPUSH
81450: PPUSH
// if not mc_bases or not skirmish then
81451: LD_EXP 23
81455: NOT
81456: PUSH
81457: LD_EXP 21
81461: NOT
81462: OR
81463: IFFALSE 81467
// exit ;
81465: GO 81682
// for i = 1 to mc_bases do
81467: LD_ADDR_VAR 0 3
81471: PUSH
81472: DOUBLE
81473: LD_INT 1
81475: DEC
81476: ST_TO_ADDR
81477: LD_EXP 23
81481: PUSH
81482: FOR_TO
81483: IFFALSE 81680
// begin if building in mc_construct_list [ i ] then
81485: LD_VAR 0 1
81489: PUSH
81490: LD_EXP 30
81494: PUSH
81495: LD_VAR 0 3
81499: ARRAY
81500: IN
81501: IFFALSE 81678
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
81503: LD_ADDR_EXP 30
81507: PUSH
81508: LD_EXP 30
81512: PPUSH
81513: LD_VAR 0 3
81517: PPUSH
81518: LD_EXP 30
81522: PUSH
81523: LD_VAR 0 3
81527: ARRAY
81528: PUSH
81529: LD_VAR 0 1
81533: DIFF
81534: PPUSH
81535: CALL_OW 1
81539: ST_TO_ADDR
// if building in mc_lab [ i ] then
81540: LD_VAR 0 1
81544: PUSH
81545: LD_EXP 56
81549: PUSH
81550: LD_VAR 0 3
81554: ARRAY
81555: IN
81556: IFFALSE 81611
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
81558: LD_ADDR_EXP 57
81562: PUSH
81563: LD_EXP 57
81567: PPUSH
81568: LD_VAR 0 3
81572: PPUSH
81573: LD_EXP 57
81577: PUSH
81578: LD_VAR 0 3
81582: ARRAY
81583: PPUSH
81584: LD_INT 1
81586: PPUSH
81587: LD_EXP 57
81591: PUSH
81592: LD_VAR 0 3
81596: ARRAY
81597: PPUSH
81598: LD_INT 0
81600: PPUSH
81601: CALL 15528 0 4
81605: PPUSH
81606: CALL_OW 1
81610: ST_TO_ADDR
// if not building in mc_bases [ i ] then
81611: LD_VAR 0 1
81615: PUSH
81616: LD_EXP 23
81620: PUSH
81621: LD_VAR 0 3
81625: ARRAY
81626: IN
81627: NOT
81628: IFFALSE 81674
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
81630: LD_ADDR_EXP 23
81634: PUSH
81635: LD_EXP 23
81639: PPUSH
81640: LD_VAR 0 3
81644: PUSH
81645: LD_EXP 23
81649: PUSH
81650: LD_VAR 0 3
81654: ARRAY
81655: PUSH
81656: LD_INT 1
81658: PLUS
81659: PUSH
81660: EMPTY
81661: LIST
81662: LIST
81663: PPUSH
81664: LD_VAR 0 1
81668: PPUSH
81669: CALL 16110 0 3
81673: ST_TO_ADDR
// exit ;
81674: POP
81675: POP
81676: GO 81682
// end ; end ;
81678: GO 81482
81680: POP
81681: POP
// end ;
81682: LD_VAR 0 2
81686: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
81687: LD_INT 0
81689: PPUSH
81690: PPUSH
81691: PPUSH
81692: PPUSH
81693: PPUSH
81694: PPUSH
81695: PPUSH
// if not mc_bases or not skirmish then
81696: LD_EXP 23
81700: NOT
81701: PUSH
81702: LD_EXP 21
81706: NOT
81707: OR
81708: IFFALSE 81712
// exit ;
81710: GO 82373
// for i = 1 to mc_bases do
81712: LD_ADDR_VAR 0 3
81716: PUSH
81717: DOUBLE
81718: LD_INT 1
81720: DEC
81721: ST_TO_ADDR
81722: LD_EXP 23
81726: PUSH
81727: FOR_TO
81728: IFFALSE 82371
// begin if building in mc_construct_list [ i ] then
81730: LD_VAR 0 1
81734: PUSH
81735: LD_EXP 30
81739: PUSH
81740: LD_VAR 0 3
81744: ARRAY
81745: IN
81746: IFFALSE 82369
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
81748: LD_ADDR_EXP 30
81752: PUSH
81753: LD_EXP 30
81757: PPUSH
81758: LD_VAR 0 3
81762: PPUSH
81763: LD_EXP 30
81767: PUSH
81768: LD_VAR 0 3
81772: ARRAY
81773: PUSH
81774: LD_VAR 0 1
81778: DIFF
81779: PPUSH
81780: CALL_OW 1
81784: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
81785: LD_ADDR_EXP 23
81789: PUSH
81790: LD_EXP 23
81794: PPUSH
81795: LD_VAR 0 3
81799: PUSH
81800: LD_EXP 23
81804: PUSH
81805: LD_VAR 0 3
81809: ARRAY
81810: PUSH
81811: LD_INT 1
81813: PLUS
81814: PUSH
81815: EMPTY
81816: LIST
81817: LIST
81818: PPUSH
81819: LD_VAR 0 1
81823: PPUSH
81824: CALL 16110 0 3
81828: ST_TO_ADDR
// btype := GetBType ( building ) ;
81829: LD_ADDR_VAR 0 5
81833: PUSH
81834: LD_VAR 0 1
81838: PPUSH
81839: CALL_OW 266
81843: ST_TO_ADDR
// side := GetSide ( building ) ;
81844: LD_ADDR_VAR 0 8
81848: PUSH
81849: LD_VAR 0 1
81853: PPUSH
81854: CALL_OW 255
81858: ST_TO_ADDR
// if btype = b_lab then
81859: LD_VAR 0 5
81863: PUSH
81864: LD_INT 6
81866: EQUAL
81867: IFFALSE 81917
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
81869: LD_ADDR_EXP 56
81873: PUSH
81874: LD_EXP 56
81878: PPUSH
81879: LD_VAR 0 3
81883: PUSH
81884: LD_EXP 56
81888: PUSH
81889: LD_VAR 0 3
81893: ARRAY
81894: PUSH
81895: LD_INT 1
81897: PLUS
81898: PUSH
81899: EMPTY
81900: LIST
81901: LIST
81902: PPUSH
81903: LD_VAR 0 1
81907: PPUSH
81908: CALL 16110 0 3
81912: ST_TO_ADDR
// exit ;
81913: POP
81914: POP
81915: GO 82373
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
81917: LD_VAR 0 5
81921: PUSH
81922: LD_INT 0
81924: PUSH
81925: LD_INT 2
81927: PUSH
81928: LD_INT 4
81930: PUSH
81931: EMPTY
81932: LIST
81933: LIST
81934: LIST
81935: IN
81936: IFFALSE 82060
// begin if btype = b_armoury then
81938: LD_VAR 0 5
81942: PUSH
81943: LD_INT 4
81945: EQUAL
81946: IFFALSE 81956
// btype := b_barracks ;
81948: LD_ADDR_VAR 0 5
81952: PUSH
81953: LD_INT 5
81955: ST_TO_ADDR
// if btype = b_depot then
81956: LD_VAR 0 5
81960: PUSH
81961: LD_INT 0
81963: EQUAL
81964: IFFALSE 81974
// btype := b_warehouse ;
81966: LD_ADDR_VAR 0 5
81970: PUSH
81971: LD_INT 1
81973: ST_TO_ADDR
// if btype = b_workshop then
81974: LD_VAR 0 5
81978: PUSH
81979: LD_INT 2
81981: EQUAL
81982: IFFALSE 81992
// btype := b_factory ;
81984: LD_ADDR_VAR 0 5
81988: PUSH
81989: LD_INT 3
81991: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
81992: LD_VAR 0 5
81996: PPUSH
81997: LD_VAR 0 8
82001: PPUSH
82002: CALL_OW 323
82006: PUSH
82007: LD_INT 1
82009: EQUAL
82010: IFFALSE 82056
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
82012: LD_ADDR_EXP 55
82016: PUSH
82017: LD_EXP 55
82021: PPUSH
82022: LD_VAR 0 3
82026: PUSH
82027: LD_EXP 55
82031: PUSH
82032: LD_VAR 0 3
82036: ARRAY
82037: PUSH
82038: LD_INT 1
82040: PLUS
82041: PUSH
82042: EMPTY
82043: LIST
82044: LIST
82045: PPUSH
82046: LD_VAR 0 1
82050: PPUSH
82051: CALL 16110 0 3
82055: ST_TO_ADDR
// exit ;
82056: POP
82057: POP
82058: GO 82373
// end ; if btype in [ b_bunker , b_turret ] then
82060: LD_VAR 0 5
82064: PUSH
82065: LD_INT 32
82067: PUSH
82068: LD_INT 33
82070: PUSH
82071: EMPTY
82072: LIST
82073: LIST
82074: IN
82075: IFFALSE 82365
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
82077: LD_ADDR_EXP 31
82081: PUSH
82082: LD_EXP 31
82086: PPUSH
82087: LD_VAR 0 3
82091: PUSH
82092: LD_EXP 31
82096: PUSH
82097: LD_VAR 0 3
82101: ARRAY
82102: PUSH
82103: LD_INT 1
82105: PLUS
82106: PUSH
82107: EMPTY
82108: LIST
82109: LIST
82110: PPUSH
82111: LD_VAR 0 1
82115: PPUSH
82116: CALL 16110 0 3
82120: ST_TO_ADDR
// if btype = b_bunker then
82121: LD_VAR 0 5
82125: PUSH
82126: LD_INT 32
82128: EQUAL
82129: IFFALSE 82365
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
82131: LD_ADDR_EXP 32
82135: PUSH
82136: LD_EXP 32
82140: PPUSH
82141: LD_VAR 0 3
82145: PUSH
82146: LD_EXP 32
82150: PUSH
82151: LD_VAR 0 3
82155: ARRAY
82156: PUSH
82157: LD_INT 1
82159: PLUS
82160: PUSH
82161: EMPTY
82162: LIST
82163: LIST
82164: PPUSH
82165: LD_VAR 0 1
82169: PPUSH
82170: CALL 16110 0 3
82174: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
82175: LD_ADDR_VAR 0 6
82179: PUSH
82180: LD_EXP 23
82184: PUSH
82185: LD_VAR 0 3
82189: ARRAY
82190: PPUSH
82191: LD_INT 25
82193: PUSH
82194: LD_INT 1
82196: PUSH
82197: EMPTY
82198: LIST
82199: LIST
82200: PUSH
82201: LD_INT 3
82203: PUSH
82204: LD_INT 54
82206: PUSH
82207: EMPTY
82208: LIST
82209: PUSH
82210: EMPTY
82211: LIST
82212: LIST
82213: PUSH
82214: EMPTY
82215: LIST
82216: LIST
82217: PPUSH
82218: CALL_OW 72
82222: ST_TO_ADDR
// if tmp then
82223: LD_VAR 0 6
82227: IFFALSE 82233
// exit ;
82229: POP
82230: POP
82231: GO 82373
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
82233: LD_ADDR_VAR 0 6
82237: PUSH
82238: LD_EXP 23
82242: PUSH
82243: LD_VAR 0 3
82247: ARRAY
82248: PPUSH
82249: LD_INT 2
82251: PUSH
82252: LD_INT 30
82254: PUSH
82255: LD_INT 4
82257: PUSH
82258: EMPTY
82259: LIST
82260: LIST
82261: PUSH
82262: LD_INT 30
82264: PUSH
82265: LD_INT 5
82267: PUSH
82268: EMPTY
82269: LIST
82270: LIST
82271: PUSH
82272: EMPTY
82273: LIST
82274: LIST
82275: LIST
82276: PPUSH
82277: CALL_OW 72
82281: ST_TO_ADDR
// if not tmp then
82282: LD_VAR 0 6
82286: NOT
82287: IFFALSE 82293
// exit ;
82289: POP
82290: POP
82291: GO 82373
// for j in tmp do
82293: LD_ADDR_VAR 0 4
82297: PUSH
82298: LD_VAR 0 6
82302: PUSH
82303: FOR_IN
82304: IFFALSE 82363
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
82306: LD_ADDR_VAR 0 7
82310: PUSH
82311: LD_VAR 0 4
82315: PPUSH
82316: CALL_OW 313
82320: PPUSH
82321: LD_INT 25
82323: PUSH
82324: LD_INT 1
82326: PUSH
82327: EMPTY
82328: LIST
82329: LIST
82330: PPUSH
82331: CALL_OW 72
82335: ST_TO_ADDR
// if units then
82336: LD_VAR 0 7
82340: IFFALSE 82361
// begin ComExitBuilding ( units [ 1 ] ) ;
82342: LD_VAR 0 7
82346: PUSH
82347: LD_INT 1
82349: ARRAY
82350: PPUSH
82351: CALL_OW 122
// exit ;
82355: POP
82356: POP
82357: POP
82358: POP
82359: GO 82373
// end ; end ;
82361: GO 82303
82363: POP
82364: POP
// end ; end ; exit ;
82365: POP
82366: POP
82367: GO 82373
// end ; end ;
82369: GO 81727
82371: POP
82372: POP
// end ;
82373: LD_VAR 0 2
82377: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
82378: LD_INT 0
82380: PPUSH
82381: PPUSH
82382: PPUSH
82383: PPUSH
82384: PPUSH
82385: PPUSH
82386: PPUSH
// if not mc_bases or not skirmish then
82387: LD_EXP 23
82391: NOT
82392: PUSH
82393: LD_EXP 21
82397: NOT
82398: OR
82399: IFFALSE 82403
// exit ;
82401: GO 82668
// btype := GetBType ( building ) ;
82403: LD_ADDR_VAR 0 6
82407: PUSH
82408: LD_VAR 0 1
82412: PPUSH
82413: CALL_OW 266
82417: ST_TO_ADDR
// x := GetX ( building ) ;
82418: LD_ADDR_VAR 0 7
82422: PUSH
82423: LD_VAR 0 1
82427: PPUSH
82428: CALL_OW 250
82432: ST_TO_ADDR
// y := GetY ( building ) ;
82433: LD_ADDR_VAR 0 8
82437: PUSH
82438: LD_VAR 0 1
82442: PPUSH
82443: CALL_OW 251
82447: ST_TO_ADDR
// d := GetDir ( building ) ;
82448: LD_ADDR_VAR 0 9
82452: PUSH
82453: LD_VAR 0 1
82457: PPUSH
82458: CALL_OW 254
82462: ST_TO_ADDR
// for i = 1 to mc_bases do
82463: LD_ADDR_VAR 0 4
82467: PUSH
82468: DOUBLE
82469: LD_INT 1
82471: DEC
82472: ST_TO_ADDR
82473: LD_EXP 23
82477: PUSH
82478: FOR_TO
82479: IFFALSE 82666
// begin if not mc_build_list [ i ] then
82481: LD_EXP 28
82485: PUSH
82486: LD_VAR 0 4
82490: ARRAY
82491: NOT
82492: IFFALSE 82496
// continue ;
82494: GO 82478
// for j := 1 to mc_build_list [ i ] do
82496: LD_ADDR_VAR 0 5
82500: PUSH
82501: DOUBLE
82502: LD_INT 1
82504: DEC
82505: ST_TO_ADDR
82506: LD_EXP 28
82510: PUSH
82511: LD_VAR 0 4
82515: ARRAY
82516: PUSH
82517: FOR_TO
82518: IFFALSE 82662
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
82520: LD_VAR 0 6
82524: PUSH
82525: LD_VAR 0 7
82529: PUSH
82530: LD_VAR 0 8
82534: PUSH
82535: LD_VAR 0 9
82539: PUSH
82540: EMPTY
82541: LIST
82542: LIST
82543: LIST
82544: LIST
82545: PPUSH
82546: LD_EXP 28
82550: PUSH
82551: LD_VAR 0 4
82555: ARRAY
82556: PUSH
82557: LD_VAR 0 5
82561: ARRAY
82562: PPUSH
82563: CALL 22290 0 2
82567: IFFALSE 82660
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
82569: LD_ADDR_EXP 28
82573: PUSH
82574: LD_EXP 28
82578: PPUSH
82579: LD_VAR 0 4
82583: PPUSH
82584: LD_EXP 28
82588: PUSH
82589: LD_VAR 0 4
82593: ARRAY
82594: PPUSH
82595: LD_VAR 0 5
82599: PPUSH
82600: CALL_OW 3
82604: PPUSH
82605: CALL_OW 1
82609: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
82610: LD_ADDR_EXP 30
82614: PUSH
82615: LD_EXP 30
82619: PPUSH
82620: LD_VAR 0 4
82624: PUSH
82625: LD_EXP 30
82629: PUSH
82630: LD_VAR 0 4
82634: ARRAY
82635: PUSH
82636: LD_INT 1
82638: PLUS
82639: PUSH
82640: EMPTY
82641: LIST
82642: LIST
82643: PPUSH
82644: LD_VAR 0 1
82648: PPUSH
82649: CALL 16110 0 3
82653: ST_TO_ADDR
// exit ;
82654: POP
82655: POP
82656: POP
82657: POP
82658: GO 82668
// end ;
82660: GO 82517
82662: POP
82663: POP
// end ;
82664: GO 82478
82666: POP
82667: POP
// end ;
82668: LD_VAR 0 3
82672: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
82673: LD_INT 0
82675: PPUSH
82676: PPUSH
82677: PPUSH
// if not mc_bases or not skirmish then
82678: LD_EXP 23
82682: NOT
82683: PUSH
82684: LD_EXP 21
82688: NOT
82689: OR
82690: IFFALSE 82694
// exit ;
82692: GO 82884
// for i = 1 to mc_bases do
82694: LD_ADDR_VAR 0 4
82698: PUSH
82699: DOUBLE
82700: LD_INT 1
82702: DEC
82703: ST_TO_ADDR
82704: LD_EXP 23
82708: PUSH
82709: FOR_TO
82710: IFFALSE 82797
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
82712: LD_VAR 0 1
82716: PUSH
82717: LD_EXP 31
82721: PUSH
82722: LD_VAR 0 4
82726: ARRAY
82727: IN
82728: PUSH
82729: LD_VAR 0 1
82733: PUSH
82734: LD_EXP 32
82738: PUSH
82739: LD_VAR 0 4
82743: ARRAY
82744: IN
82745: NOT
82746: AND
82747: IFFALSE 82795
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
82749: LD_ADDR_EXP 32
82753: PUSH
82754: LD_EXP 32
82758: PPUSH
82759: LD_VAR 0 4
82763: PUSH
82764: LD_EXP 32
82768: PUSH
82769: LD_VAR 0 4
82773: ARRAY
82774: PUSH
82775: LD_INT 1
82777: PLUS
82778: PUSH
82779: EMPTY
82780: LIST
82781: LIST
82782: PPUSH
82783: LD_VAR 0 1
82787: PPUSH
82788: CALL 16110 0 3
82792: ST_TO_ADDR
// break ;
82793: GO 82797
// end ; end ;
82795: GO 82709
82797: POP
82798: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
82799: LD_VAR 0 1
82803: PPUSH
82804: CALL_OW 257
82808: PUSH
82809: LD_EXP 49
82813: IN
82814: PUSH
82815: LD_VAR 0 1
82819: PPUSH
82820: CALL_OW 266
82824: PUSH
82825: LD_INT 5
82827: EQUAL
82828: AND
82829: PUSH
82830: LD_VAR 0 2
82834: PPUSH
82835: CALL_OW 110
82839: PUSH
82840: LD_INT 18
82842: NONEQUAL
82843: AND
82844: IFFALSE 82884
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
82846: LD_VAR 0 2
82850: PPUSH
82851: CALL_OW 257
82855: PUSH
82856: LD_INT 5
82858: PUSH
82859: LD_INT 8
82861: PUSH
82862: LD_INT 9
82864: PUSH
82865: EMPTY
82866: LIST
82867: LIST
82868: LIST
82869: IN
82870: IFFALSE 82884
// SetClass ( unit , 1 ) ;
82872: LD_VAR 0 2
82876: PPUSH
82877: LD_INT 1
82879: PPUSH
82880: CALL_OW 336
// end ;
82884: LD_VAR 0 3
82888: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
82889: LD_INT 0
82891: PPUSH
82892: PPUSH
// if not mc_bases or not skirmish then
82893: LD_EXP 23
82897: NOT
82898: PUSH
82899: LD_EXP 21
82903: NOT
82904: OR
82905: IFFALSE 82909
// exit ;
82907: GO 83025
// if GetLives ( abandoned_vehicle ) > 250 then
82909: LD_VAR 0 2
82913: PPUSH
82914: CALL_OW 256
82918: PUSH
82919: LD_INT 250
82921: GREATER
82922: IFFALSE 82926
// exit ;
82924: GO 83025
// for i = 1 to mc_bases do
82926: LD_ADDR_VAR 0 6
82930: PUSH
82931: DOUBLE
82932: LD_INT 1
82934: DEC
82935: ST_TO_ADDR
82936: LD_EXP 23
82940: PUSH
82941: FOR_TO
82942: IFFALSE 83023
// begin if driver in mc_bases [ i ] then
82944: LD_VAR 0 1
82948: PUSH
82949: LD_EXP 23
82953: PUSH
82954: LD_VAR 0 6
82958: ARRAY
82959: IN
82960: IFFALSE 83021
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
82962: LD_VAR 0 1
82966: PPUSH
82967: LD_EXP 23
82971: PUSH
82972: LD_VAR 0 6
82976: ARRAY
82977: PPUSH
82978: LD_INT 2
82980: PUSH
82981: LD_INT 30
82983: PUSH
82984: LD_INT 0
82986: PUSH
82987: EMPTY
82988: LIST
82989: LIST
82990: PUSH
82991: LD_INT 30
82993: PUSH
82994: LD_INT 1
82996: PUSH
82997: EMPTY
82998: LIST
82999: LIST
83000: PUSH
83001: EMPTY
83002: LIST
83003: LIST
83004: LIST
83005: PPUSH
83006: CALL_OW 72
83010: PUSH
83011: LD_INT 1
83013: ARRAY
83014: PPUSH
83015: CALL 49290 0 2
// break ;
83019: GO 83023
// end ; end ;
83021: GO 82941
83023: POP
83024: POP
// end ; end_of_file
83025: LD_VAR 0 5
83029: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
83030: LD_INT 0
83032: PPUSH
83033: PPUSH
83034: PPUSH
83035: PPUSH
83036: PPUSH
83037: PPUSH
83038: PPUSH
83039: PPUSH
83040: PPUSH
83041: PPUSH
83042: PPUSH
83043: PPUSH
83044: PPUSH
83045: PPUSH
83046: PPUSH
83047: PPUSH
83048: PPUSH
83049: PPUSH
83050: PPUSH
83051: PPUSH
83052: PPUSH
83053: PPUSH
83054: PPUSH
83055: PPUSH
83056: PPUSH
83057: PPUSH
83058: PPUSH
83059: PPUSH
83060: PPUSH
83061: PPUSH
83062: PPUSH
83063: PPUSH
83064: PPUSH
83065: PPUSH
// if not list then
83066: LD_VAR 0 1
83070: NOT
83071: IFFALSE 83075
// exit ;
83073: GO 87734
// base := list [ 1 ] ;
83075: LD_ADDR_VAR 0 3
83079: PUSH
83080: LD_VAR 0 1
83084: PUSH
83085: LD_INT 1
83087: ARRAY
83088: ST_TO_ADDR
// group := list [ 2 ] ;
83089: LD_ADDR_VAR 0 4
83093: PUSH
83094: LD_VAR 0 1
83098: PUSH
83099: LD_INT 2
83101: ARRAY
83102: ST_TO_ADDR
// path := list [ 3 ] ;
83103: LD_ADDR_VAR 0 5
83107: PUSH
83108: LD_VAR 0 1
83112: PUSH
83113: LD_INT 3
83115: ARRAY
83116: ST_TO_ADDR
// flags := list [ 4 ] ;
83117: LD_ADDR_VAR 0 6
83121: PUSH
83122: LD_VAR 0 1
83126: PUSH
83127: LD_INT 4
83129: ARRAY
83130: ST_TO_ADDR
// mined := [ ] ;
83131: LD_ADDR_VAR 0 27
83135: PUSH
83136: EMPTY
83137: ST_TO_ADDR
// bombed := [ ] ;
83138: LD_ADDR_VAR 0 28
83142: PUSH
83143: EMPTY
83144: ST_TO_ADDR
// healers := [ ] ;
83145: LD_ADDR_VAR 0 31
83149: PUSH
83150: EMPTY
83151: ST_TO_ADDR
// to_heal := [ ] ;
83152: LD_ADDR_VAR 0 30
83156: PUSH
83157: EMPTY
83158: ST_TO_ADDR
// repairs := [ ] ;
83159: LD_ADDR_VAR 0 33
83163: PUSH
83164: EMPTY
83165: ST_TO_ADDR
// to_repair := [ ] ;
83166: LD_ADDR_VAR 0 32
83170: PUSH
83171: EMPTY
83172: ST_TO_ADDR
// if not group or not path then
83173: LD_VAR 0 4
83177: NOT
83178: PUSH
83179: LD_VAR 0 5
83183: NOT
83184: OR
83185: IFFALSE 83189
// exit ;
83187: GO 87734
// side := GetSide ( group [ 1 ] ) ;
83189: LD_ADDR_VAR 0 35
83193: PUSH
83194: LD_VAR 0 4
83198: PUSH
83199: LD_INT 1
83201: ARRAY
83202: PPUSH
83203: CALL_OW 255
83207: ST_TO_ADDR
// if flags then
83208: LD_VAR 0 6
83212: IFFALSE 83356
// begin f_ignore_area := flags [ 1 ] ;
83214: LD_ADDR_VAR 0 17
83218: PUSH
83219: LD_VAR 0 6
83223: PUSH
83224: LD_INT 1
83226: ARRAY
83227: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
83228: LD_ADDR_VAR 0 18
83232: PUSH
83233: LD_VAR 0 6
83237: PUSH
83238: LD_INT 2
83240: ARRAY
83241: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
83242: LD_ADDR_VAR 0 19
83246: PUSH
83247: LD_VAR 0 6
83251: PUSH
83252: LD_INT 3
83254: ARRAY
83255: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
83256: LD_ADDR_VAR 0 20
83260: PUSH
83261: LD_VAR 0 6
83265: PUSH
83266: LD_INT 4
83268: ARRAY
83269: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
83270: LD_ADDR_VAR 0 21
83274: PUSH
83275: LD_VAR 0 6
83279: PUSH
83280: LD_INT 5
83282: ARRAY
83283: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
83284: LD_ADDR_VAR 0 22
83288: PUSH
83289: LD_VAR 0 6
83293: PUSH
83294: LD_INT 6
83296: ARRAY
83297: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
83298: LD_ADDR_VAR 0 23
83302: PUSH
83303: LD_VAR 0 6
83307: PUSH
83308: LD_INT 7
83310: ARRAY
83311: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
83312: LD_ADDR_VAR 0 24
83316: PUSH
83317: LD_VAR 0 6
83321: PUSH
83322: LD_INT 8
83324: ARRAY
83325: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
83326: LD_ADDR_VAR 0 25
83330: PUSH
83331: LD_VAR 0 6
83335: PUSH
83336: LD_INT 9
83338: ARRAY
83339: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
83340: LD_ADDR_VAR 0 26
83344: PUSH
83345: LD_VAR 0 6
83349: PUSH
83350: LD_INT 10
83352: ARRAY
83353: ST_TO_ADDR
// end else
83354: GO 83436
// begin f_ignore_area := false ;
83356: LD_ADDR_VAR 0 17
83360: PUSH
83361: LD_INT 0
83363: ST_TO_ADDR
// f_capture := false ;
83364: LD_ADDR_VAR 0 18
83368: PUSH
83369: LD_INT 0
83371: ST_TO_ADDR
// f_ignore_civ := false ;
83372: LD_ADDR_VAR 0 19
83376: PUSH
83377: LD_INT 0
83379: ST_TO_ADDR
// f_murder := false ;
83380: LD_ADDR_VAR 0 20
83384: PUSH
83385: LD_INT 0
83387: ST_TO_ADDR
// f_mines := false ;
83388: LD_ADDR_VAR 0 21
83392: PUSH
83393: LD_INT 0
83395: ST_TO_ADDR
// f_repair := false ;
83396: LD_ADDR_VAR 0 22
83400: PUSH
83401: LD_INT 0
83403: ST_TO_ADDR
// f_heal := false ;
83404: LD_ADDR_VAR 0 23
83408: PUSH
83409: LD_INT 0
83411: ST_TO_ADDR
// f_spacetime := false ;
83412: LD_ADDR_VAR 0 24
83416: PUSH
83417: LD_INT 0
83419: ST_TO_ADDR
// f_attack_depot := false ;
83420: LD_ADDR_VAR 0 25
83424: PUSH
83425: LD_INT 0
83427: ST_TO_ADDR
// f_crawl := false ;
83428: LD_ADDR_VAR 0 26
83432: PUSH
83433: LD_INT 0
83435: ST_TO_ADDR
// end ; if f_heal then
83436: LD_VAR 0 23
83440: IFFALSE 83467
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
83442: LD_ADDR_VAR 0 31
83446: PUSH
83447: LD_VAR 0 4
83451: PPUSH
83452: LD_INT 25
83454: PUSH
83455: LD_INT 4
83457: PUSH
83458: EMPTY
83459: LIST
83460: LIST
83461: PPUSH
83462: CALL_OW 72
83466: ST_TO_ADDR
// if f_repair then
83467: LD_VAR 0 22
83471: IFFALSE 83498
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
83473: LD_ADDR_VAR 0 33
83477: PUSH
83478: LD_VAR 0 4
83482: PPUSH
83483: LD_INT 25
83485: PUSH
83486: LD_INT 3
83488: PUSH
83489: EMPTY
83490: LIST
83491: LIST
83492: PPUSH
83493: CALL_OW 72
83497: ST_TO_ADDR
// units_path := [ ] ;
83498: LD_ADDR_VAR 0 16
83502: PUSH
83503: EMPTY
83504: ST_TO_ADDR
// for i = 1 to group do
83505: LD_ADDR_VAR 0 7
83509: PUSH
83510: DOUBLE
83511: LD_INT 1
83513: DEC
83514: ST_TO_ADDR
83515: LD_VAR 0 4
83519: PUSH
83520: FOR_TO
83521: IFFALSE 83550
// units_path := Replace ( units_path , i , path ) ;
83523: LD_ADDR_VAR 0 16
83527: PUSH
83528: LD_VAR 0 16
83532: PPUSH
83533: LD_VAR 0 7
83537: PPUSH
83538: LD_VAR 0 5
83542: PPUSH
83543: CALL_OW 1
83547: ST_TO_ADDR
83548: GO 83520
83550: POP
83551: POP
// repeat for i = group downto 1 do
83552: LD_ADDR_VAR 0 7
83556: PUSH
83557: DOUBLE
83558: LD_VAR 0 4
83562: INC
83563: ST_TO_ADDR
83564: LD_INT 1
83566: PUSH
83567: FOR_DOWNTO
83568: IFFALSE 87690
// begin wait ( 5 ) ;
83570: LD_INT 5
83572: PPUSH
83573: CALL_OW 67
// tmp := [ ] ;
83577: LD_ADDR_VAR 0 14
83581: PUSH
83582: EMPTY
83583: ST_TO_ADDR
// attacking := false ;
83584: LD_ADDR_VAR 0 29
83588: PUSH
83589: LD_INT 0
83591: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
83592: LD_VAR 0 4
83596: PUSH
83597: LD_VAR 0 7
83601: ARRAY
83602: PPUSH
83603: CALL_OW 301
83607: PUSH
83608: LD_VAR 0 4
83612: PUSH
83613: LD_VAR 0 7
83617: ARRAY
83618: NOT
83619: OR
83620: IFFALSE 83729
// begin if GetType ( group [ i ] ) = unit_human then
83622: LD_VAR 0 4
83626: PUSH
83627: LD_VAR 0 7
83631: ARRAY
83632: PPUSH
83633: CALL_OW 247
83637: PUSH
83638: LD_INT 1
83640: EQUAL
83641: IFFALSE 83687
// begin to_heal := to_heal diff group [ i ] ;
83643: LD_ADDR_VAR 0 30
83647: PUSH
83648: LD_VAR 0 30
83652: PUSH
83653: LD_VAR 0 4
83657: PUSH
83658: LD_VAR 0 7
83662: ARRAY
83663: DIFF
83664: ST_TO_ADDR
// healers := healers diff group [ i ] ;
83665: LD_ADDR_VAR 0 31
83669: PUSH
83670: LD_VAR 0 31
83674: PUSH
83675: LD_VAR 0 4
83679: PUSH
83680: LD_VAR 0 7
83684: ARRAY
83685: DIFF
83686: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
83687: LD_ADDR_VAR 0 4
83691: PUSH
83692: LD_VAR 0 4
83696: PPUSH
83697: LD_VAR 0 7
83701: PPUSH
83702: CALL_OW 3
83706: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
83707: LD_ADDR_VAR 0 16
83711: PUSH
83712: LD_VAR 0 16
83716: PPUSH
83717: LD_VAR 0 7
83721: PPUSH
83722: CALL_OW 3
83726: ST_TO_ADDR
// continue ;
83727: GO 83567
// end ; if f_repair then
83729: LD_VAR 0 22
83733: IFFALSE 84222
// begin if GetType ( group [ i ] ) = unit_vehicle then
83735: LD_VAR 0 4
83739: PUSH
83740: LD_VAR 0 7
83744: ARRAY
83745: PPUSH
83746: CALL_OW 247
83750: PUSH
83751: LD_INT 2
83753: EQUAL
83754: IFFALSE 83944
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
83756: LD_VAR 0 4
83760: PUSH
83761: LD_VAR 0 7
83765: ARRAY
83766: PPUSH
83767: CALL_OW 256
83771: PUSH
83772: LD_INT 700
83774: LESS
83775: PUSH
83776: LD_VAR 0 4
83780: PUSH
83781: LD_VAR 0 7
83785: ARRAY
83786: PUSH
83787: LD_VAR 0 32
83791: IN
83792: NOT
83793: AND
83794: IFFALSE 83818
// to_repair := to_repair union group [ i ] ;
83796: LD_ADDR_VAR 0 32
83800: PUSH
83801: LD_VAR 0 32
83805: PUSH
83806: LD_VAR 0 4
83810: PUSH
83811: LD_VAR 0 7
83815: ARRAY
83816: UNION
83817: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
83818: LD_VAR 0 4
83822: PUSH
83823: LD_VAR 0 7
83827: ARRAY
83828: PPUSH
83829: CALL_OW 256
83833: PUSH
83834: LD_INT 1000
83836: EQUAL
83837: PUSH
83838: LD_VAR 0 4
83842: PUSH
83843: LD_VAR 0 7
83847: ARRAY
83848: PUSH
83849: LD_VAR 0 32
83853: IN
83854: AND
83855: IFFALSE 83879
// to_repair := to_repair diff group [ i ] ;
83857: LD_ADDR_VAR 0 32
83861: PUSH
83862: LD_VAR 0 32
83866: PUSH
83867: LD_VAR 0 4
83871: PUSH
83872: LD_VAR 0 7
83876: ARRAY
83877: DIFF
83878: ST_TO_ADDR
// if group [ i ] in to_repair then
83879: LD_VAR 0 4
83883: PUSH
83884: LD_VAR 0 7
83888: ARRAY
83889: PUSH
83890: LD_VAR 0 32
83894: IN
83895: IFFALSE 83942
// begin if not IsInArea ( group [ i ] , f_repair ) then
83897: LD_VAR 0 4
83901: PUSH
83902: LD_VAR 0 7
83906: ARRAY
83907: PPUSH
83908: LD_VAR 0 22
83912: PPUSH
83913: CALL_OW 308
83917: NOT
83918: IFFALSE 83940
// ComMoveToArea ( group [ i ] , f_repair ) ;
83920: LD_VAR 0 4
83924: PUSH
83925: LD_VAR 0 7
83929: ARRAY
83930: PPUSH
83931: LD_VAR 0 22
83935: PPUSH
83936: CALL_OW 113
// continue ;
83940: GO 83567
// end ; end else
83942: GO 84222
// if group [ i ] in repairs then
83944: LD_VAR 0 4
83948: PUSH
83949: LD_VAR 0 7
83953: ARRAY
83954: PUSH
83955: LD_VAR 0 33
83959: IN
83960: IFFALSE 84222
// begin if IsInUnit ( group [ i ] ) then
83962: LD_VAR 0 4
83966: PUSH
83967: LD_VAR 0 7
83971: ARRAY
83972: PPUSH
83973: CALL_OW 310
83977: IFFALSE 84045
// begin z := IsInUnit ( group [ i ] ) ;
83979: LD_ADDR_VAR 0 13
83983: PUSH
83984: LD_VAR 0 4
83988: PUSH
83989: LD_VAR 0 7
83993: ARRAY
83994: PPUSH
83995: CALL_OW 310
83999: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
84000: LD_VAR 0 13
84004: PUSH
84005: LD_VAR 0 32
84009: IN
84010: PUSH
84011: LD_VAR 0 13
84015: PPUSH
84016: LD_VAR 0 22
84020: PPUSH
84021: CALL_OW 308
84025: AND
84026: IFFALSE 84043
// ComExitVehicle ( group [ i ] ) ;
84028: LD_VAR 0 4
84032: PUSH
84033: LD_VAR 0 7
84037: ARRAY
84038: PPUSH
84039: CALL_OW 121
// end else
84043: GO 84222
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
84045: LD_ADDR_VAR 0 13
84049: PUSH
84050: LD_VAR 0 4
84054: PPUSH
84055: LD_INT 95
84057: PUSH
84058: LD_VAR 0 22
84062: PUSH
84063: EMPTY
84064: LIST
84065: LIST
84066: PUSH
84067: LD_INT 58
84069: PUSH
84070: EMPTY
84071: LIST
84072: PUSH
84073: EMPTY
84074: LIST
84075: LIST
84076: PPUSH
84077: CALL_OW 72
84081: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
84082: LD_VAR 0 4
84086: PUSH
84087: LD_VAR 0 7
84091: ARRAY
84092: PPUSH
84093: CALL_OW 314
84097: NOT
84098: IFFALSE 84220
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
84100: LD_ADDR_VAR 0 10
84104: PUSH
84105: LD_VAR 0 13
84109: PPUSH
84110: LD_VAR 0 4
84114: PUSH
84115: LD_VAR 0 7
84119: ARRAY
84120: PPUSH
84121: CALL_OW 74
84125: ST_TO_ADDR
// if not x then
84126: LD_VAR 0 10
84130: NOT
84131: IFFALSE 84135
// continue ;
84133: GO 83567
// if GetLives ( x ) < 1000 then
84135: LD_VAR 0 10
84139: PPUSH
84140: CALL_OW 256
84144: PUSH
84145: LD_INT 1000
84147: LESS
84148: IFFALSE 84172
// ComRepairVehicle ( group [ i ] , x ) else
84150: LD_VAR 0 4
84154: PUSH
84155: LD_VAR 0 7
84159: ARRAY
84160: PPUSH
84161: LD_VAR 0 10
84165: PPUSH
84166: CALL_OW 129
84170: GO 84220
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
84172: LD_VAR 0 23
84176: PUSH
84177: LD_VAR 0 4
84181: PUSH
84182: LD_VAR 0 7
84186: ARRAY
84187: PPUSH
84188: CALL_OW 256
84192: PUSH
84193: LD_INT 1000
84195: LESS
84196: AND
84197: NOT
84198: IFFALSE 84220
// ComEnterUnit ( group [ i ] , x ) ;
84200: LD_VAR 0 4
84204: PUSH
84205: LD_VAR 0 7
84209: ARRAY
84210: PPUSH
84211: LD_VAR 0 10
84215: PPUSH
84216: CALL_OW 120
// end ; continue ;
84220: GO 83567
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
84222: LD_VAR 0 23
84226: PUSH
84227: LD_VAR 0 4
84231: PUSH
84232: LD_VAR 0 7
84236: ARRAY
84237: PPUSH
84238: CALL_OW 247
84242: PUSH
84243: LD_INT 1
84245: EQUAL
84246: AND
84247: IFFALSE 84725
// begin if group [ i ] in healers then
84249: LD_VAR 0 4
84253: PUSH
84254: LD_VAR 0 7
84258: ARRAY
84259: PUSH
84260: LD_VAR 0 31
84264: IN
84265: IFFALSE 84538
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
84267: LD_VAR 0 4
84271: PUSH
84272: LD_VAR 0 7
84276: ARRAY
84277: PPUSH
84278: LD_VAR 0 23
84282: PPUSH
84283: CALL_OW 308
84287: NOT
84288: PUSH
84289: LD_VAR 0 4
84293: PUSH
84294: LD_VAR 0 7
84298: ARRAY
84299: PPUSH
84300: CALL_OW 314
84304: NOT
84305: AND
84306: IFFALSE 84330
// ComMoveToArea ( group [ i ] , f_heal ) else
84308: LD_VAR 0 4
84312: PUSH
84313: LD_VAR 0 7
84317: ARRAY
84318: PPUSH
84319: LD_VAR 0 23
84323: PPUSH
84324: CALL_OW 113
84328: GO 84536
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
84330: LD_VAR 0 4
84334: PUSH
84335: LD_VAR 0 7
84339: ARRAY
84340: PPUSH
84341: CALL 45807 0 1
84345: PPUSH
84346: CALL_OW 256
84350: PUSH
84351: LD_INT 1000
84353: EQUAL
84354: IFFALSE 84373
// ComStop ( group [ i ] ) else
84356: LD_VAR 0 4
84360: PUSH
84361: LD_VAR 0 7
84365: ARRAY
84366: PPUSH
84367: CALL_OW 141
84371: GO 84536
// if not HasTask ( group [ i ] ) and to_heal then
84373: LD_VAR 0 4
84377: PUSH
84378: LD_VAR 0 7
84382: ARRAY
84383: PPUSH
84384: CALL_OW 314
84388: NOT
84389: PUSH
84390: LD_VAR 0 30
84394: AND
84395: IFFALSE 84536
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
84397: LD_ADDR_VAR 0 13
84401: PUSH
84402: LD_VAR 0 30
84406: PPUSH
84407: LD_INT 3
84409: PUSH
84410: LD_INT 54
84412: PUSH
84413: EMPTY
84414: LIST
84415: PUSH
84416: EMPTY
84417: LIST
84418: LIST
84419: PPUSH
84420: CALL_OW 72
84424: PPUSH
84425: LD_VAR 0 4
84429: PUSH
84430: LD_VAR 0 7
84434: ARRAY
84435: PPUSH
84436: CALL_OW 74
84440: ST_TO_ADDR
// if z then
84441: LD_VAR 0 13
84445: IFFALSE 84536
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
84447: LD_INT 91
84449: PUSH
84450: LD_VAR 0 13
84454: PUSH
84455: LD_INT 10
84457: PUSH
84458: EMPTY
84459: LIST
84460: LIST
84461: LIST
84462: PUSH
84463: LD_INT 81
84465: PUSH
84466: LD_VAR 0 13
84470: PPUSH
84471: CALL_OW 255
84475: PUSH
84476: EMPTY
84477: LIST
84478: LIST
84479: PUSH
84480: EMPTY
84481: LIST
84482: LIST
84483: PPUSH
84484: CALL_OW 69
84488: PUSH
84489: LD_INT 0
84491: EQUAL
84492: IFFALSE 84516
// ComHeal ( group [ i ] , z ) else
84494: LD_VAR 0 4
84498: PUSH
84499: LD_VAR 0 7
84503: ARRAY
84504: PPUSH
84505: LD_VAR 0 13
84509: PPUSH
84510: CALL_OW 128
84514: GO 84536
// ComMoveToArea ( group [ i ] , f_heal ) ;
84516: LD_VAR 0 4
84520: PUSH
84521: LD_VAR 0 7
84525: ARRAY
84526: PPUSH
84527: LD_VAR 0 23
84531: PPUSH
84532: CALL_OW 113
// end ; continue ;
84536: GO 83567
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
84538: LD_VAR 0 4
84542: PUSH
84543: LD_VAR 0 7
84547: ARRAY
84548: PPUSH
84549: CALL_OW 256
84553: PUSH
84554: LD_INT 700
84556: LESS
84557: PUSH
84558: LD_VAR 0 4
84562: PUSH
84563: LD_VAR 0 7
84567: ARRAY
84568: PUSH
84569: LD_VAR 0 30
84573: IN
84574: NOT
84575: AND
84576: IFFALSE 84600
// to_heal := to_heal union group [ i ] ;
84578: LD_ADDR_VAR 0 30
84582: PUSH
84583: LD_VAR 0 30
84587: PUSH
84588: LD_VAR 0 4
84592: PUSH
84593: LD_VAR 0 7
84597: ARRAY
84598: UNION
84599: ST_TO_ADDR
// if group [ i ] in to_heal then
84600: LD_VAR 0 4
84604: PUSH
84605: LD_VAR 0 7
84609: ARRAY
84610: PUSH
84611: LD_VAR 0 30
84615: IN
84616: IFFALSE 84725
// begin if GetLives ( group [ i ] ) = 1000 then
84618: LD_VAR 0 4
84622: PUSH
84623: LD_VAR 0 7
84627: ARRAY
84628: PPUSH
84629: CALL_OW 256
84633: PUSH
84634: LD_INT 1000
84636: EQUAL
84637: IFFALSE 84663
// to_heal := to_heal diff group [ i ] else
84639: LD_ADDR_VAR 0 30
84643: PUSH
84644: LD_VAR 0 30
84648: PUSH
84649: LD_VAR 0 4
84653: PUSH
84654: LD_VAR 0 7
84658: ARRAY
84659: DIFF
84660: ST_TO_ADDR
84661: GO 84725
// begin if not IsInArea ( group [ i ] , to_heal ) then
84663: LD_VAR 0 4
84667: PUSH
84668: LD_VAR 0 7
84672: ARRAY
84673: PPUSH
84674: LD_VAR 0 30
84678: PPUSH
84679: CALL_OW 308
84683: NOT
84684: IFFALSE 84708
// ComMoveToArea ( group [ i ] , f_heal ) else
84686: LD_VAR 0 4
84690: PUSH
84691: LD_VAR 0 7
84695: ARRAY
84696: PPUSH
84697: LD_VAR 0 23
84701: PPUSH
84702: CALL_OW 113
84706: GO 84723
// ComHold ( group [ i ] ) ;
84708: LD_VAR 0 4
84712: PUSH
84713: LD_VAR 0 7
84717: ARRAY
84718: PPUSH
84719: CALL_OW 140
// continue ;
84723: GO 83567
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
84725: LD_VAR 0 4
84729: PUSH
84730: LD_VAR 0 7
84734: ARRAY
84735: PPUSH
84736: LD_INT 10
84738: PPUSH
84739: CALL 43604 0 2
84743: NOT
84744: PUSH
84745: LD_VAR 0 16
84749: PUSH
84750: LD_VAR 0 7
84754: ARRAY
84755: PUSH
84756: EMPTY
84757: EQUAL
84758: NOT
84759: AND
84760: IFFALSE 85026
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
84762: LD_VAR 0 4
84766: PUSH
84767: LD_VAR 0 7
84771: ARRAY
84772: PPUSH
84773: CALL_OW 262
84777: PUSH
84778: LD_INT 1
84780: PUSH
84781: LD_INT 2
84783: PUSH
84784: EMPTY
84785: LIST
84786: LIST
84787: IN
84788: IFFALSE 84829
// if GetFuel ( group [ i ] ) < 10 then
84790: LD_VAR 0 4
84794: PUSH
84795: LD_VAR 0 7
84799: ARRAY
84800: PPUSH
84801: CALL_OW 261
84805: PUSH
84806: LD_INT 10
84808: LESS
84809: IFFALSE 84829
// SetFuel ( group [ i ] , 12 ) ;
84811: LD_VAR 0 4
84815: PUSH
84816: LD_VAR 0 7
84820: ARRAY
84821: PPUSH
84822: LD_INT 12
84824: PPUSH
84825: CALL_OW 240
// if units_path [ i ] then
84829: LD_VAR 0 16
84833: PUSH
84834: LD_VAR 0 7
84838: ARRAY
84839: IFFALSE 85024
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
84841: LD_VAR 0 4
84845: PUSH
84846: LD_VAR 0 7
84850: ARRAY
84851: PPUSH
84852: LD_VAR 0 16
84856: PUSH
84857: LD_VAR 0 7
84861: ARRAY
84862: PUSH
84863: LD_INT 1
84865: ARRAY
84866: PUSH
84867: LD_INT 1
84869: ARRAY
84870: PPUSH
84871: LD_VAR 0 16
84875: PUSH
84876: LD_VAR 0 7
84880: ARRAY
84881: PUSH
84882: LD_INT 1
84884: ARRAY
84885: PUSH
84886: LD_INT 2
84888: ARRAY
84889: PPUSH
84890: CALL_OW 297
84894: PUSH
84895: LD_INT 6
84897: GREATER
84898: IFFALSE 84973
// begin if not HasTask ( group [ i ] ) then
84900: LD_VAR 0 4
84904: PUSH
84905: LD_VAR 0 7
84909: ARRAY
84910: PPUSH
84911: CALL_OW 314
84915: NOT
84916: IFFALSE 84971
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
84918: LD_VAR 0 4
84922: PUSH
84923: LD_VAR 0 7
84927: ARRAY
84928: PPUSH
84929: LD_VAR 0 16
84933: PUSH
84934: LD_VAR 0 7
84938: ARRAY
84939: PUSH
84940: LD_INT 1
84942: ARRAY
84943: PUSH
84944: LD_INT 1
84946: ARRAY
84947: PPUSH
84948: LD_VAR 0 16
84952: PUSH
84953: LD_VAR 0 7
84957: ARRAY
84958: PUSH
84959: LD_INT 1
84961: ARRAY
84962: PUSH
84963: LD_INT 2
84965: ARRAY
84966: PPUSH
84967: CALL_OW 114
// end else
84971: GO 85024
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
84973: LD_ADDR_VAR 0 15
84977: PUSH
84978: LD_VAR 0 16
84982: PUSH
84983: LD_VAR 0 7
84987: ARRAY
84988: PPUSH
84989: LD_INT 1
84991: PPUSH
84992: CALL_OW 3
84996: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
84997: LD_ADDR_VAR 0 16
85001: PUSH
85002: LD_VAR 0 16
85006: PPUSH
85007: LD_VAR 0 7
85011: PPUSH
85012: LD_VAR 0 15
85016: PPUSH
85017: CALL_OW 1
85021: ST_TO_ADDR
// continue ;
85022: GO 83567
// end ; end ; end else
85024: GO 87688
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
85026: LD_ADDR_VAR 0 14
85030: PUSH
85031: LD_INT 81
85033: PUSH
85034: LD_VAR 0 4
85038: PUSH
85039: LD_VAR 0 7
85043: ARRAY
85044: PPUSH
85045: CALL_OW 255
85049: PUSH
85050: EMPTY
85051: LIST
85052: LIST
85053: PPUSH
85054: CALL_OW 69
85058: ST_TO_ADDR
// if not tmp then
85059: LD_VAR 0 14
85063: NOT
85064: IFFALSE 85068
// continue ;
85066: GO 83567
// if f_ignore_area then
85068: LD_VAR 0 17
85072: IFFALSE 85160
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
85074: LD_ADDR_VAR 0 15
85078: PUSH
85079: LD_VAR 0 14
85083: PPUSH
85084: LD_INT 3
85086: PUSH
85087: LD_INT 92
85089: PUSH
85090: LD_VAR 0 17
85094: PUSH
85095: LD_INT 1
85097: ARRAY
85098: PUSH
85099: LD_VAR 0 17
85103: PUSH
85104: LD_INT 2
85106: ARRAY
85107: PUSH
85108: LD_VAR 0 17
85112: PUSH
85113: LD_INT 3
85115: ARRAY
85116: PUSH
85117: EMPTY
85118: LIST
85119: LIST
85120: LIST
85121: LIST
85122: PUSH
85123: EMPTY
85124: LIST
85125: LIST
85126: PPUSH
85127: CALL_OW 72
85131: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
85132: LD_VAR 0 14
85136: PUSH
85137: LD_VAR 0 15
85141: DIFF
85142: IFFALSE 85160
// tmp := tmp diff tmp2 ;
85144: LD_ADDR_VAR 0 14
85148: PUSH
85149: LD_VAR 0 14
85153: PUSH
85154: LD_VAR 0 15
85158: DIFF
85159: ST_TO_ADDR
// end ; if not f_murder then
85160: LD_VAR 0 20
85164: NOT
85165: IFFALSE 85223
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
85167: LD_ADDR_VAR 0 15
85171: PUSH
85172: LD_VAR 0 14
85176: PPUSH
85177: LD_INT 3
85179: PUSH
85180: LD_INT 50
85182: PUSH
85183: EMPTY
85184: LIST
85185: PUSH
85186: EMPTY
85187: LIST
85188: LIST
85189: PPUSH
85190: CALL_OW 72
85194: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
85195: LD_VAR 0 14
85199: PUSH
85200: LD_VAR 0 15
85204: DIFF
85205: IFFALSE 85223
// tmp := tmp diff tmp2 ;
85207: LD_ADDR_VAR 0 14
85211: PUSH
85212: LD_VAR 0 14
85216: PUSH
85217: LD_VAR 0 15
85221: DIFF
85222: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
85223: LD_ADDR_VAR 0 14
85227: PUSH
85228: LD_VAR 0 4
85232: PUSH
85233: LD_VAR 0 7
85237: ARRAY
85238: PPUSH
85239: LD_VAR 0 14
85243: PPUSH
85244: LD_INT 1
85246: PPUSH
85247: LD_INT 1
85249: PPUSH
85250: CALL 16545 0 4
85254: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
85255: LD_VAR 0 4
85259: PUSH
85260: LD_VAR 0 7
85264: ARRAY
85265: PPUSH
85266: CALL_OW 257
85270: PUSH
85271: LD_INT 1
85273: EQUAL
85274: IFFALSE 85722
// begin if WantPlant ( group [ i ] ) then
85276: LD_VAR 0 4
85280: PUSH
85281: LD_VAR 0 7
85285: ARRAY
85286: PPUSH
85287: CALL 16046 0 1
85291: IFFALSE 85295
// continue ;
85293: GO 83567
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
85295: LD_VAR 0 18
85299: PUSH
85300: LD_VAR 0 4
85304: PUSH
85305: LD_VAR 0 7
85309: ARRAY
85310: PPUSH
85311: CALL_OW 310
85315: NOT
85316: AND
85317: PUSH
85318: LD_VAR 0 14
85322: PUSH
85323: LD_INT 1
85325: ARRAY
85326: PUSH
85327: LD_VAR 0 14
85331: PPUSH
85332: LD_INT 21
85334: PUSH
85335: LD_INT 2
85337: PUSH
85338: EMPTY
85339: LIST
85340: LIST
85341: PUSH
85342: LD_INT 58
85344: PUSH
85345: EMPTY
85346: LIST
85347: PUSH
85348: EMPTY
85349: LIST
85350: LIST
85351: PPUSH
85352: CALL_OW 72
85356: IN
85357: AND
85358: IFFALSE 85394
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
85360: LD_VAR 0 4
85364: PUSH
85365: LD_VAR 0 7
85369: ARRAY
85370: PPUSH
85371: LD_VAR 0 14
85375: PUSH
85376: LD_INT 1
85378: ARRAY
85379: PPUSH
85380: CALL_OW 120
// attacking := true ;
85384: LD_ADDR_VAR 0 29
85388: PUSH
85389: LD_INT 1
85391: ST_TO_ADDR
// continue ;
85392: GO 83567
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
85394: LD_VAR 0 26
85398: PUSH
85399: LD_VAR 0 4
85403: PUSH
85404: LD_VAR 0 7
85408: ARRAY
85409: PPUSH
85410: CALL_OW 257
85414: PUSH
85415: LD_INT 1
85417: EQUAL
85418: AND
85419: PUSH
85420: LD_VAR 0 4
85424: PUSH
85425: LD_VAR 0 7
85429: ARRAY
85430: PPUSH
85431: CALL_OW 256
85435: PUSH
85436: LD_INT 800
85438: LESS
85439: AND
85440: PUSH
85441: LD_VAR 0 4
85445: PUSH
85446: LD_VAR 0 7
85450: ARRAY
85451: PPUSH
85452: CALL_OW 318
85456: NOT
85457: AND
85458: IFFALSE 85475
// ComCrawl ( group [ i ] ) ;
85460: LD_VAR 0 4
85464: PUSH
85465: LD_VAR 0 7
85469: ARRAY
85470: PPUSH
85471: CALL_OW 137
// if f_mines then
85475: LD_VAR 0 21
85479: IFFALSE 85722
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
85481: LD_VAR 0 14
85485: PUSH
85486: LD_INT 1
85488: ARRAY
85489: PPUSH
85490: CALL_OW 247
85494: PUSH
85495: LD_INT 3
85497: EQUAL
85498: PUSH
85499: LD_VAR 0 14
85503: PUSH
85504: LD_INT 1
85506: ARRAY
85507: PUSH
85508: LD_VAR 0 27
85512: IN
85513: NOT
85514: AND
85515: IFFALSE 85722
// begin x := GetX ( tmp [ 1 ] ) ;
85517: LD_ADDR_VAR 0 10
85521: PUSH
85522: LD_VAR 0 14
85526: PUSH
85527: LD_INT 1
85529: ARRAY
85530: PPUSH
85531: CALL_OW 250
85535: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
85536: LD_ADDR_VAR 0 11
85540: PUSH
85541: LD_VAR 0 14
85545: PUSH
85546: LD_INT 1
85548: ARRAY
85549: PPUSH
85550: CALL_OW 251
85554: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
85555: LD_ADDR_VAR 0 12
85559: PUSH
85560: LD_VAR 0 4
85564: PUSH
85565: LD_VAR 0 7
85569: ARRAY
85570: PPUSH
85571: CALL 43689 0 1
85575: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
85576: LD_VAR 0 4
85580: PUSH
85581: LD_VAR 0 7
85585: ARRAY
85586: PPUSH
85587: LD_VAR 0 10
85591: PPUSH
85592: LD_VAR 0 11
85596: PPUSH
85597: LD_VAR 0 14
85601: PUSH
85602: LD_INT 1
85604: ARRAY
85605: PPUSH
85606: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
85610: LD_VAR 0 4
85614: PUSH
85615: LD_VAR 0 7
85619: ARRAY
85620: PPUSH
85621: LD_VAR 0 10
85625: PPUSH
85626: LD_VAR 0 12
85630: PPUSH
85631: LD_INT 7
85633: PPUSH
85634: CALL_OW 272
85638: PPUSH
85639: LD_VAR 0 11
85643: PPUSH
85644: LD_VAR 0 12
85648: PPUSH
85649: LD_INT 7
85651: PPUSH
85652: CALL_OW 273
85656: PPUSH
85657: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
85661: LD_VAR 0 4
85665: PUSH
85666: LD_VAR 0 7
85670: ARRAY
85671: PPUSH
85672: LD_INT 71
85674: PPUSH
85675: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
85679: LD_ADDR_VAR 0 27
85683: PUSH
85684: LD_VAR 0 27
85688: PPUSH
85689: LD_VAR 0 27
85693: PUSH
85694: LD_INT 1
85696: PLUS
85697: PPUSH
85698: LD_VAR 0 14
85702: PUSH
85703: LD_INT 1
85705: ARRAY
85706: PPUSH
85707: CALL_OW 1
85711: ST_TO_ADDR
// attacking := true ;
85712: LD_ADDR_VAR 0 29
85716: PUSH
85717: LD_INT 1
85719: ST_TO_ADDR
// continue ;
85720: GO 83567
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
85722: LD_VAR 0 4
85726: PUSH
85727: LD_VAR 0 7
85731: ARRAY
85732: PPUSH
85733: CALL_OW 257
85737: PUSH
85738: LD_INT 17
85740: EQUAL
85741: PUSH
85742: LD_VAR 0 4
85746: PUSH
85747: LD_VAR 0 7
85751: ARRAY
85752: PPUSH
85753: CALL_OW 110
85757: PUSH
85758: LD_INT 71
85760: EQUAL
85761: NOT
85762: AND
85763: IFFALSE 85909
// begin attacking := false ;
85765: LD_ADDR_VAR 0 29
85769: PUSH
85770: LD_INT 0
85772: ST_TO_ADDR
// k := 5 ;
85773: LD_ADDR_VAR 0 9
85777: PUSH
85778: LD_INT 5
85780: ST_TO_ADDR
// if tmp < k then
85781: LD_VAR 0 14
85785: PUSH
85786: LD_VAR 0 9
85790: LESS
85791: IFFALSE 85803
// k := tmp ;
85793: LD_ADDR_VAR 0 9
85797: PUSH
85798: LD_VAR 0 14
85802: ST_TO_ADDR
// for j = 1 to k do
85803: LD_ADDR_VAR 0 8
85807: PUSH
85808: DOUBLE
85809: LD_INT 1
85811: DEC
85812: ST_TO_ADDR
85813: LD_VAR 0 9
85817: PUSH
85818: FOR_TO
85819: IFFALSE 85907
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
85821: LD_VAR 0 14
85825: PUSH
85826: LD_VAR 0 8
85830: ARRAY
85831: PUSH
85832: LD_VAR 0 14
85836: PPUSH
85837: LD_INT 58
85839: PUSH
85840: EMPTY
85841: LIST
85842: PPUSH
85843: CALL_OW 72
85847: IN
85848: NOT
85849: IFFALSE 85905
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
85851: LD_VAR 0 4
85855: PUSH
85856: LD_VAR 0 7
85860: ARRAY
85861: PPUSH
85862: LD_VAR 0 14
85866: PUSH
85867: LD_VAR 0 8
85871: ARRAY
85872: PPUSH
85873: CALL_OW 115
// attacking := true ;
85877: LD_ADDR_VAR 0 29
85881: PUSH
85882: LD_INT 1
85884: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
85885: LD_VAR 0 4
85889: PUSH
85890: LD_VAR 0 7
85894: ARRAY
85895: PPUSH
85896: LD_INT 71
85898: PPUSH
85899: CALL_OW 109
// continue ;
85903: GO 85818
// end ; end ;
85905: GO 85818
85907: POP
85908: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
85909: LD_VAR 0 4
85913: PUSH
85914: LD_VAR 0 7
85918: ARRAY
85919: PPUSH
85920: CALL_OW 257
85924: PUSH
85925: LD_INT 8
85927: EQUAL
85928: PUSH
85929: LD_VAR 0 4
85933: PUSH
85934: LD_VAR 0 7
85938: ARRAY
85939: PPUSH
85940: CALL_OW 264
85944: PUSH
85945: LD_INT 28
85947: PUSH
85948: LD_INT 45
85950: PUSH
85951: LD_INT 7
85953: PUSH
85954: LD_INT 47
85956: PUSH
85957: EMPTY
85958: LIST
85959: LIST
85960: LIST
85961: LIST
85962: IN
85963: OR
85964: IFFALSE 86220
// begin attacking := false ;
85966: LD_ADDR_VAR 0 29
85970: PUSH
85971: LD_INT 0
85973: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
85974: LD_VAR 0 14
85978: PUSH
85979: LD_INT 1
85981: ARRAY
85982: PPUSH
85983: CALL_OW 266
85987: PUSH
85988: LD_INT 32
85990: PUSH
85991: LD_INT 31
85993: PUSH
85994: LD_INT 33
85996: PUSH
85997: LD_INT 4
85999: PUSH
86000: LD_INT 5
86002: PUSH
86003: EMPTY
86004: LIST
86005: LIST
86006: LIST
86007: LIST
86008: LIST
86009: IN
86010: IFFALSE 86196
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
86012: LD_ADDR_VAR 0 9
86016: PUSH
86017: LD_VAR 0 14
86021: PUSH
86022: LD_INT 1
86024: ARRAY
86025: PPUSH
86026: CALL_OW 266
86030: PPUSH
86031: LD_VAR 0 14
86035: PUSH
86036: LD_INT 1
86038: ARRAY
86039: PPUSH
86040: CALL_OW 250
86044: PPUSH
86045: LD_VAR 0 14
86049: PUSH
86050: LD_INT 1
86052: ARRAY
86053: PPUSH
86054: CALL_OW 251
86058: PPUSH
86059: LD_VAR 0 14
86063: PUSH
86064: LD_INT 1
86066: ARRAY
86067: PPUSH
86068: CALL_OW 254
86072: PPUSH
86073: LD_VAR 0 14
86077: PUSH
86078: LD_INT 1
86080: ARRAY
86081: PPUSH
86082: CALL_OW 248
86086: PPUSH
86087: LD_INT 0
86089: PPUSH
86090: CALL 25059 0 6
86094: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
86095: LD_ADDR_VAR 0 8
86099: PUSH
86100: LD_VAR 0 4
86104: PUSH
86105: LD_VAR 0 7
86109: ARRAY
86110: PPUSH
86111: LD_VAR 0 9
86115: PPUSH
86116: CALL 43802 0 2
86120: ST_TO_ADDR
// if j then
86121: LD_VAR 0 8
86125: IFFALSE 86194
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
86127: LD_VAR 0 8
86131: PUSH
86132: LD_INT 1
86134: ARRAY
86135: PPUSH
86136: LD_VAR 0 8
86140: PUSH
86141: LD_INT 2
86143: ARRAY
86144: PPUSH
86145: CALL_OW 488
86149: IFFALSE 86194
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
86151: LD_VAR 0 4
86155: PUSH
86156: LD_VAR 0 7
86160: ARRAY
86161: PPUSH
86162: LD_VAR 0 8
86166: PUSH
86167: LD_INT 1
86169: ARRAY
86170: PPUSH
86171: LD_VAR 0 8
86175: PUSH
86176: LD_INT 2
86178: ARRAY
86179: PPUSH
86180: CALL_OW 116
// attacking := true ;
86184: LD_ADDR_VAR 0 29
86188: PUSH
86189: LD_INT 1
86191: ST_TO_ADDR
// continue ;
86192: GO 83567
// end ; end else
86194: GO 86220
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86196: LD_VAR 0 4
86200: PUSH
86201: LD_VAR 0 7
86205: ARRAY
86206: PPUSH
86207: LD_VAR 0 14
86211: PUSH
86212: LD_INT 1
86214: ARRAY
86215: PPUSH
86216: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
86220: LD_VAR 0 4
86224: PUSH
86225: LD_VAR 0 7
86229: ARRAY
86230: PPUSH
86231: CALL_OW 265
86235: PUSH
86236: LD_INT 11
86238: EQUAL
86239: IFFALSE 86517
// begin k := 10 ;
86241: LD_ADDR_VAR 0 9
86245: PUSH
86246: LD_INT 10
86248: ST_TO_ADDR
// x := 0 ;
86249: LD_ADDR_VAR 0 10
86253: PUSH
86254: LD_INT 0
86256: ST_TO_ADDR
// if tmp < k then
86257: LD_VAR 0 14
86261: PUSH
86262: LD_VAR 0 9
86266: LESS
86267: IFFALSE 86279
// k := tmp ;
86269: LD_ADDR_VAR 0 9
86273: PUSH
86274: LD_VAR 0 14
86278: ST_TO_ADDR
// for j = k downto 1 do
86279: LD_ADDR_VAR 0 8
86283: PUSH
86284: DOUBLE
86285: LD_VAR 0 9
86289: INC
86290: ST_TO_ADDR
86291: LD_INT 1
86293: PUSH
86294: FOR_DOWNTO
86295: IFFALSE 86370
// begin if GetType ( tmp [ j ] ) = unit_human then
86297: LD_VAR 0 14
86301: PUSH
86302: LD_VAR 0 8
86306: ARRAY
86307: PPUSH
86308: CALL_OW 247
86312: PUSH
86313: LD_INT 1
86315: EQUAL
86316: IFFALSE 86368
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
86318: LD_VAR 0 4
86322: PUSH
86323: LD_VAR 0 7
86327: ARRAY
86328: PPUSH
86329: LD_VAR 0 14
86333: PUSH
86334: LD_VAR 0 8
86338: ARRAY
86339: PPUSH
86340: CALL 44056 0 2
// x := tmp [ j ] ;
86344: LD_ADDR_VAR 0 10
86348: PUSH
86349: LD_VAR 0 14
86353: PUSH
86354: LD_VAR 0 8
86358: ARRAY
86359: ST_TO_ADDR
// attacking := true ;
86360: LD_ADDR_VAR 0 29
86364: PUSH
86365: LD_INT 1
86367: ST_TO_ADDR
// end ; end ;
86368: GO 86294
86370: POP
86371: POP
// if not x then
86372: LD_VAR 0 10
86376: NOT
86377: IFFALSE 86517
// begin attacking := true ;
86379: LD_ADDR_VAR 0 29
86383: PUSH
86384: LD_INT 1
86386: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
86387: LD_VAR 0 4
86391: PUSH
86392: LD_VAR 0 7
86396: ARRAY
86397: PPUSH
86398: CALL_OW 250
86402: PPUSH
86403: LD_VAR 0 4
86407: PUSH
86408: LD_VAR 0 7
86412: ARRAY
86413: PPUSH
86414: CALL_OW 251
86418: PPUSH
86419: CALL_OW 546
86423: PUSH
86424: LD_INT 2
86426: ARRAY
86427: PUSH
86428: LD_VAR 0 14
86432: PUSH
86433: LD_INT 1
86435: ARRAY
86436: PPUSH
86437: CALL_OW 250
86441: PPUSH
86442: LD_VAR 0 14
86446: PUSH
86447: LD_INT 1
86449: ARRAY
86450: PPUSH
86451: CALL_OW 251
86455: PPUSH
86456: CALL_OW 546
86460: PUSH
86461: LD_INT 2
86463: ARRAY
86464: EQUAL
86465: IFFALSE 86493
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
86467: LD_VAR 0 4
86471: PUSH
86472: LD_VAR 0 7
86476: ARRAY
86477: PPUSH
86478: LD_VAR 0 14
86482: PUSH
86483: LD_INT 1
86485: ARRAY
86486: PPUSH
86487: CALL 44056 0 2
86491: GO 86517
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86493: LD_VAR 0 4
86497: PUSH
86498: LD_VAR 0 7
86502: ARRAY
86503: PPUSH
86504: LD_VAR 0 14
86508: PUSH
86509: LD_INT 1
86511: ARRAY
86512: PPUSH
86513: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
86517: LD_VAR 0 4
86521: PUSH
86522: LD_VAR 0 7
86526: ARRAY
86527: PPUSH
86528: CALL_OW 264
86532: PUSH
86533: LD_INT 29
86535: EQUAL
86536: IFFALSE 86902
// begin if WantsToAttack ( group [ i ] ) in bombed then
86538: LD_VAR 0 4
86542: PUSH
86543: LD_VAR 0 7
86547: ARRAY
86548: PPUSH
86549: CALL_OW 319
86553: PUSH
86554: LD_VAR 0 28
86558: IN
86559: IFFALSE 86563
// continue ;
86561: GO 83567
// k := 8 ;
86563: LD_ADDR_VAR 0 9
86567: PUSH
86568: LD_INT 8
86570: ST_TO_ADDR
// x := 0 ;
86571: LD_ADDR_VAR 0 10
86575: PUSH
86576: LD_INT 0
86578: ST_TO_ADDR
// if tmp < k then
86579: LD_VAR 0 14
86583: PUSH
86584: LD_VAR 0 9
86588: LESS
86589: IFFALSE 86601
// k := tmp ;
86591: LD_ADDR_VAR 0 9
86595: PUSH
86596: LD_VAR 0 14
86600: ST_TO_ADDR
// for j = 1 to k do
86601: LD_ADDR_VAR 0 8
86605: PUSH
86606: DOUBLE
86607: LD_INT 1
86609: DEC
86610: ST_TO_ADDR
86611: LD_VAR 0 9
86615: PUSH
86616: FOR_TO
86617: IFFALSE 86749
// begin if GetType ( tmp [ j ] ) = unit_building then
86619: LD_VAR 0 14
86623: PUSH
86624: LD_VAR 0 8
86628: ARRAY
86629: PPUSH
86630: CALL_OW 247
86634: PUSH
86635: LD_INT 3
86637: EQUAL
86638: IFFALSE 86747
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
86640: LD_VAR 0 14
86644: PUSH
86645: LD_VAR 0 8
86649: ARRAY
86650: PUSH
86651: LD_VAR 0 28
86655: IN
86656: NOT
86657: PUSH
86658: LD_VAR 0 14
86662: PUSH
86663: LD_VAR 0 8
86667: ARRAY
86668: PPUSH
86669: CALL_OW 313
86673: AND
86674: IFFALSE 86747
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
86676: LD_VAR 0 4
86680: PUSH
86681: LD_VAR 0 7
86685: ARRAY
86686: PPUSH
86687: LD_VAR 0 14
86691: PUSH
86692: LD_VAR 0 8
86696: ARRAY
86697: PPUSH
86698: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
86702: LD_ADDR_VAR 0 28
86706: PUSH
86707: LD_VAR 0 28
86711: PPUSH
86712: LD_VAR 0 28
86716: PUSH
86717: LD_INT 1
86719: PLUS
86720: PPUSH
86721: LD_VAR 0 14
86725: PUSH
86726: LD_VAR 0 8
86730: ARRAY
86731: PPUSH
86732: CALL_OW 1
86736: ST_TO_ADDR
// attacking := true ;
86737: LD_ADDR_VAR 0 29
86741: PUSH
86742: LD_INT 1
86744: ST_TO_ADDR
// break ;
86745: GO 86749
// end ; end ;
86747: GO 86616
86749: POP
86750: POP
// if not attacking and f_attack_depot then
86751: LD_VAR 0 29
86755: NOT
86756: PUSH
86757: LD_VAR 0 25
86761: AND
86762: IFFALSE 86857
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
86764: LD_ADDR_VAR 0 13
86768: PUSH
86769: LD_VAR 0 14
86773: PPUSH
86774: LD_INT 2
86776: PUSH
86777: LD_INT 30
86779: PUSH
86780: LD_INT 0
86782: PUSH
86783: EMPTY
86784: LIST
86785: LIST
86786: PUSH
86787: LD_INT 30
86789: PUSH
86790: LD_INT 1
86792: PUSH
86793: EMPTY
86794: LIST
86795: LIST
86796: PUSH
86797: EMPTY
86798: LIST
86799: LIST
86800: LIST
86801: PPUSH
86802: CALL_OW 72
86806: ST_TO_ADDR
// if z then
86807: LD_VAR 0 13
86811: IFFALSE 86857
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
86813: LD_VAR 0 4
86817: PUSH
86818: LD_VAR 0 7
86822: ARRAY
86823: PPUSH
86824: LD_VAR 0 13
86828: PPUSH
86829: LD_VAR 0 4
86833: PUSH
86834: LD_VAR 0 7
86838: ARRAY
86839: PPUSH
86840: CALL_OW 74
86844: PPUSH
86845: CALL_OW 115
// attacking := true ;
86849: LD_ADDR_VAR 0 29
86853: PUSH
86854: LD_INT 1
86856: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
86857: LD_VAR 0 4
86861: PUSH
86862: LD_VAR 0 7
86866: ARRAY
86867: PPUSH
86868: CALL_OW 256
86872: PUSH
86873: LD_INT 500
86875: LESS
86876: IFFALSE 86902
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86878: LD_VAR 0 4
86882: PUSH
86883: LD_VAR 0 7
86887: ARRAY
86888: PPUSH
86889: LD_VAR 0 14
86893: PUSH
86894: LD_INT 1
86896: ARRAY
86897: PPUSH
86898: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
86902: LD_VAR 0 4
86906: PUSH
86907: LD_VAR 0 7
86911: ARRAY
86912: PPUSH
86913: CALL_OW 264
86917: PUSH
86918: LD_INT 49
86920: EQUAL
86921: IFFALSE 87042
// begin if not HasTask ( group [ i ] ) then
86923: LD_VAR 0 4
86927: PUSH
86928: LD_VAR 0 7
86932: ARRAY
86933: PPUSH
86934: CALL_OW 314
86938: NOT
86939: IFFALSE 87042
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
86941: LD_ADDR_VAR 0 9
86945: PUSH
86946: LD_INT 81
86948: PUSH
86949: LD_VAR 0 4
86953: PUSH
86954: LD_VAR 0 7
86958: ARRAY
86959: PPUSH
86960: CALL_OW 255
86964: PUSH
86965: EMPTY
86966: LIST
86967: LIST
86968: PPUSH
86969: CALL_OW 69
86973: PPUSH
86974: LD_VAR 0 4
86978: PUSH
86979: LD_VAR 0 7
86983: ARRAY
86984: PPUSH
86985: CALL_OW 74
86989: ST_TO_ADDR
// if k then
86990: LD_VAR 0 9
86994: IFFALSE 87042
// if GetDistUnits ( group [ i ] , k ) > 10 then
86996: LD_VAR 0 4
87000: PUSH
87001: LD_VAR 0 7
87005: ARRAY
87006: PPUSH
87007: LD_VAR 0 9
87011: PPUSH
87012: CALL_OW 296
87016: PUSH
87017: LD_INT 10
87019: GREATER
87020: IFFALSE 87042
// ComMoveUnit ( group [ i ] , k ) ;
87022: LD_VAR 0 4
87026: PUSH
87027: LD_VAR 0 7
87031: ARRAY
87032: PPUSH
87033: LD_VAR 0 9
87037: PPUSH
87038: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
87042: LD_VAR 0 4
87046: PUSH
87047: LD_VAR 0 7
87051: ARRAY
87052: PPUSH
87053: CALL_OW 256
87057: PUSH
87058: LD_INT 250
87060: LESS
87061: PUSH
87062: LD_VAR 0 4
87066: PUSH
87067: LD_VAR 0 7
87071: ARRAY
87072: PUSH
87073: LD_INT 21
87075: PUSH
87076: LD_INT 2
87078: PUSH
87079: EMPTY
87080: LIST
87081: LIST
87082: PUSH
87083: LD_INT 23
87085: PUSH
87086: LD_INT 2
87088: PUSH
87089: EMPTY
87090: LIST
87091: LIST
87092: PUSH
87093: EMPTY
87094: LIST
87095: LIST
87096: PPUSH
87097: CALL_OW 69
87101: IN
87102: AND
87103: IFFALSE 87228
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
87105: LD_ADDR_VAR 0 9
87109: PUSH
87110: LD_OWVAR 3
87114: PUSH
87115: LD_VAR 0 4
87119: PUSH
87120: LD_VAR 0 7
87124: ARRAY
87125: DIFF
87126: PPUSH
87127: LD_VAR 0 4
87131: PUSH
87132: LD_VAR 0 7
87136: ARRAY
87137: PPUSH
87138: CALL_OW 74
87142: ST_TO_ADDR
// if not k then
87143: LD_VAR 0 9
87147: NOT
87148: IFFALSE 87152
// continue ;
87150: GO 83567
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
87152: LD_VAR 0 9
87156: PUSH
87157: LD_INT 81
87159: PUSH
87160: LD_VAR 0 4
87164: PUSH
87165: LD_VAR 0 7
87169: ARRAY
87170: PPUSH
87171: CALL_OW 255
87175: PUSH
87176: EMPTY
87177: LIST
87178: LIST
87179: PPUSH
87180: CALL_OW 69
87184: IN
87185: PUSH
87186: LD_VAR 0 9
87190: PPUSH
87191: LD_VAR 0 4
87195: PUSH
87196: LD_VAR 0 7
87200: ARRAY
87201: PPUSH
87202: CALL_OW 296
87206: PUSH
87207: LD_INT 5
87209: LESS
87210: AND
87211: IFFALSE 87228
// ComAutodestruct ( group [ i ] ) ;
87213: LD_VAR 0 4
87217: PUSH
87218: LD_VAR 0 7
87222: ARRAY
87223: PPUSH
87224: CALL 43954 0 1
// end ; if f_attack_depot then
87228: LD_VAR 0 25
87232: IFFALSE 87344
// begin k := 6 ;
87234: LD_ADDR_VAR 0 9
87238: PUSH
87239: LD_INT 6
87241: ST_TO_ADDR
// if tmp < k then
87242: LD_VAR 0 14
87246: PUSH
87247: LD_VAR 0 9
87251: LESS
87252: IFFALSE 87264
// k := tmp ;
87254: LD_ADDR_VAR 0 9
87258: PUSH
87259: LD_VAR 0 14
87263: ST_TO_ADDR
// for j = 1 to k do
87264: LD_ADDR_VAR 0 8
87268: PUSH
87269: DOUBLE
87270: LD_INT 1
87272: DEC
87273: ST_TO_ADDR
87274: LD_VAR 0 9
87278: PUSH
87279: FOR_TO
87280: IFFALSE 87342
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
87282: LD_VAR 0 8
87286: PPUSH
87287: CALL_OW 266
87291: PUSH
87292: LD_INT 0
87294: PUSH
87295: LD_INT 1
87297: PUSH
87298: EMPTY
87299: LIST
87300: LIST
87301: IN
87302: IFFALSE 87340
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
87304: LD_VAR 0 4
87308: PUSH
87309: LD_VAR 0 7
87313: ARRAY
87314: PPUSH
87315: LD_VAR 0 14
87319: PUSH
87320: LD_VAR 0 8
87324: ARRAY
87325: PPUSH
87326: CALL_OW 115
// attacking := true ;
87330: LD_ADDR_VAR 0 29
87334: PUSH
87335: LD_INT 1
87337: ST_TO_ADDR
// break ;
87338: GO 87342
// end ;
87340: GO 87279
87342: POP
87343: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
87344: LD_VAR 0 4
87348: PUSH
87349: LD_VAR 0 7
87353: ARRAY
87354: PPUSH
87355: CALL_OW 302
87359: PUSH
87360: LD_VAR 0 29
87364: NOT
87365: AND
87366: IFFALSE 87688
// begin if GetTag ( group [ i ] ) = 71 then
87368: LD_VAR 0 4
87372: PUSH
87373: LD_VAR 0 7
87377: ARRAY
87378: PPUSH
87379: CALL_OW 110
87383: PUSH
87384: LD_INT 71
87386: EQUAL
87387: IFFALSE 87428
// begin if HasTask ( group [ i ] ) then
87389: LD_VAR 0 4
87393: PUSH
87394: LD_VAR 0 7
87398: ARRAY
87399: PPUSH
87400: CALL_OW 314
87404: IFFALSE 87410
// continue else
87406: GO 83567
87408: GO 87428
// SetTag ( group [ i ] , 0 ) ;
87410: LD_VAR 0 4
87414: PUSH
87415: LD_VAR 0 7
87419: ARRAY
87420: PPUSH
87421: LD_INT 0
87423: PPUSH
87424: CALL_OW 109
// end ; k := 8 ;
87428: LD_ADDR_VAR 0 9
87432: PUSH
87433: LD_INT 8
87435: ST_TO_ADDR
// x := 0 ;
87436: LD_ADDR_VAR 0 10
87440: PUSH
87441: LD_INT 0
87443: ST_TO_ADDR
// if tmp < k then
87444: LD_VAR 0 14
87448: PUSH
87449: LD_VAR 0 9
87453: LESS
87454: IFFALSE 87466
// k := tmp ;
87456: LD_ADDR_VAR 0 9
87460: PUSH
87461: LD_VAR 0 14
87465: ST_TO_ADDR
// for j = 1 to k do
87466: LD_ADDR_VAR 0 8
87470: PUSH
87471: DOUBLE
87472: LD_INT 1
87474: DEC
87475: ST_TO_ADDR
87476: LD_VAR 0 9
87480: PUSH
87481: FOR_TO
87482: IFFALSE 87580
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
87484: LD_VAR 0 14
87488: PUSH
87489: LD_VAR 0 8
87493: ARRAY
87494: PPUSH
87495: CALL_OW 247
87499: PUSH
87500: LD_INT 1
87502: EQUAL
87503: PUSH
87504: LD_VAR 0 14
87508: PUSH
87509: LD_VAR 0 8
87513: ARRAY
87514: PPUSH
87515: CALL_OW 256
87519: PUSH
87520: LD_INT 250
87522: LESS
87523: PUSH
87524: LD_VAR 0 20
87528: AND
87529: PUSH
87530: LD_VAR 0 20
87534: NOT
87535: PUSH
87536: LD_VAR 0 14
87540: PUSH
87541: LD_VAR 0 8
87545: ARRAY
87546: PPUSH
87547: CALL_OW 256
87551: PUSH
87552: LD_INT 250
87554: GREATEREQUAL
87555: AND
87556: OR
87557: AND
87558: IFFALSE 87578
// begin x := tmp [ j ] ;
87560: LD_ADDR_VAR 0 10
87564: PUSH
87565: LD_VAR 0 14
87569: PUSH
87570: LD_VAR 0 8
87574: ARRAY
87575: ST_TO_ADDR
// break ;
87576: GO 87580
// end ;
87578: GO 87481
87580: POP
87581: POP
// if x then
87582: LD_VAR 0 10
87586: IFFALSE 87610
// ComAttackUnit ( group [ i ] , x ) else
87588: LD_VAR 0 4
87592: PUSH
87593: LD_VAR 0 7
87597: ARRAY
87598: PPUSH
87599: LD_VAR 0 10
87603: PPUSH
87604: CALL_OW 115
87608: GO 87634
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
87610: LD_VAR 0 4
87614: PUSH
87615: LD_VAR 0 7
87619: ARRAY
87620: PPUSH
87621: LD_VAR 0 14
87625: PUSH
87626: LD_INT 1
87628: ARRAY
87629: PPUSH
87630: CALL_OW 115
// if not HasTask ( group [ i ] ) then
87634: LD_VAR 0 4
87638: PUSH
87639: LD_VAR 0 7
87643: ARRAY
87644: PPUSH
87645: CALL_OW 314
87649: NOT
87650: IFFALSE 87688
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
87652: LD_VAR 0 4
87656: PUSH
87657: LD_VAR 0 7
87661: ARRAY
87662: PPUSH
87663: LD_VAR 0 14
87667: PPUSH
87668: LD_VAR 0 4
87672: PUSH
87673: LD_VAR 0 7
87677: ARRAY
87678: PPUSH
87679: CALL_OW 74
87683: PPUSH
87684: CALL_OW 115
// end ; end ; end ;
87688: GO 83567
87690: POP
87691: POP
// wait ( 0 0$2 ) ;
87692: LD_INT 70
87694: PPUSH
87695: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
87699: LD_VAR 0 4
87703: NOT
87704: PUSH
87705: LD_VAR 0 4
87709: PUSH
87710: EMPTY
87711: EQUAL
87712: OR
87713: PUSH
87714: LD_INT 81
87716: PUSH
87717: LD_VAR 0 35
87721: PUSH
87722: EMPTY
87723: LIST
87724: LIST
87725: PPUSH
87726: CALL_OW 69
87730: NOT
87731: OR
87732: IFFALSE 83552
// end ;
87734: LD_VAR 0 2
87738: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
87739: LD_INT 0
87741: PPUSH
87742: PPUSH
87743: PPUSH
87744: PPUSH
87745: PPUSH
87746: PPUSH
// if not base or not mc_bases [ base ] or not solds then
87747: LD_VAR 0 1
87751: NOT
87752: PUSH
87753: LD_EXP 23
87757: PUSH
87758: LD_VAR 0 1
87762: ARRAY
87763: NOT
87764: OR
87765: PUSH
87766: LD_VAR 0 2
87770: NOT
87771: OR
87772: IFFALSE 87776
// exit ;
87774: GO 88330
// side := mc_sides [ base ] ;
87776: LD_ADDR_VAR 0 6
87780: PUSH
87781: LD_EXP 49
87785: PUSH
87786: LD_VAR 0 1
87790: ARRAY
87791: ST_TO_ADDR
// if not side then
87792: LD_VAR 0 6
87796: NOT
87797: IFFALSE 87801
// exit ;
87799: GO 88330
// for i in solds do
87801: LD_ADDR_VAR 0 7
87805: PUSH
87806: LD_VAR 0 2
87810: PUSH
87811: FOR_IN
87812: IFFALSE 87873
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
87814: LD_VAR 0 7
87818: PPUSH
87819: CALL_OW 310
87823: PPUSH
87824: CALL_OW 266
87828: PUSH
87829: LD_INT 32
87831: PUSH
87832: LD_INT 31
87834: PUSH
87835: EMPTY
87836: LIST
87837: LIST
87838: IN
87839: IFFALSE 87859
// solds := solds diff i else
87841: LD_ADDR_VAR 0 2
87845: PUSH
87846: LD_VAR 0 2
87850: PUSH
87851: LD_VAR 0 7
87855: DIFF
87856: ST_TO_ADDR
87857: GO 87871
// SetTag ( i , 18 ) ;
87859: LD_VAR 0 7
87863: PPUSH
87864: LD_INT 18
87866: PPUSH
87867: CALL_OW 109
87871: GO 87811
87873: POP
87874: POP
// if not solds then
87875: LD_VAR 0 2
87879: NOT
87880: IFFALSE 87884
// exit ;
87882: GO 88330
// repeat wait ( 0 0$2 ) ;
87884: LD_INT 70
87886: PPUSH
87887: CALL_OW 67
// enemy := mc_scan [ base ] ;
87891: LD_ADDR_VAR 0 4
87895: PUSH
87896: LD_EXP 46
87900: PUSH
87901: LD_VAR 0 1
87905: ARRAY
87906: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
87907: LD_EXP 23
87911: PUSH
87912: LD_VAR 0 1
87916: ARRAY
87917: NOT
87918: PUSH
87919: LD_EXP 23
87923: PUSH
87924: LD_VAR 0 1
87928: ARRAY
87929: PUSH
87930: EMPTY
87931: EQUAL
87932: OR
87933: IFFALSE 87970
// begin for i in solds do
87935: LD_ADDR_VAR 0 7
87939: PUSH
87940: LD_VAR 0 2
87944: PUSH
87945: FOR_IN
87946: IFFALSE 87959
// ComStop ( i ) ;
87948: LD_VAR 0 7
87952: PPUSH
87953: CALL_OW 141
87957: GO 87945
87959: POP
87960: POP
// solds := [ ] ;
87961: LD_ADDR_VAR 0 2
87965: PUSH
87966: EMPTY
87967: ST_TO_ADDR
// exit ;
87968: GO 88330
// end ; for i in solds do
87970: LD_ADDR_VAR 0 7
87974: PUSH
87975: LD_VAR 0 2
87979: PUSH
87980: FOR_IN
87981: IFFALSE 88302
// begin if IsInUnit ( i ) then
87983: LD_VAR 0 7
87987: PPUSH
87988: CALL_OW 310
87992: IFFALSE 88003
// ComExitBuilding ( i ) ;
87994: LD_VAR 0 7
87998: PPUSH
87999: CALL_OW 122
// if GetLives ( i ) > 500 then
88003: LD_VAR 0 7
88007: PPUSH
88008: CALL_OW 256
88012: PUSH
88013: LD_INT 500
88015: GREATER
88016: IFFALSE 88069
// begin e := NearestUnitToUnit ( enemy , i ) ;
88018: LD_ADDR_VAR 0 5
88022: PUSH
88023: LD_VAR 0 4
88027: PPUSH
88028: LD_VAR 0 7
88032: PPUSH
88033: CALL_OW 74
88037: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
88038: LD_VAR 0 7
88042: PPUSH
88043: LD_VAR 0 5
88047: PPUSH
88048: CALL_OW 250
88052: PPUSH
88053: LD_VAR 0 5
88057: PPUSH
88058: CALL_OW 251
88062: PPUSH
88063: CALL_OW 114
// end else
88067: GO 88300
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
88069: LD_VAR 0 7
88073: PPUSH
88074: LD_EXP 23
88078: PUSH
88079: LD_VAR 0 1
88083: ARRAY
88084: PPUSH
88085: LD_INT 2
88087: PUSH
88088: LD_INT 30
88090: PUSH
88091: LD_INT 0
88093: PUSH
88094: EMPTY
88095: LIST
88096: LIST
88097: PUSH
88098: LD_INT 30
88100: PUSH
88101: LD_INT 1
88103: PUSH
88104: EMPTY
88105: LIST
88106: LIST
88107: PUSH
88108: LD_INT 30
88110: PUSH
88111: LD_INT 6
88113: PUSH
88114: EMPTY
88115: LIST
88116: LIST
88117: PUSH
88118: EMPTY
88119: LIST
88120: LIST
88121: LIST
88122: LIST
88123: PPUSH
88124: CALL_OW 72
88128: PPUSH
88129: LD_VAR 0 7
88133: PPUSH
88134: CALL_OW 74
88138: PPUSH
88139: CALL_OW 296
88143: PUSH
88144: LD_INT 10
88146: GREATER
88147: IFFALSE 88300
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
88149: LD_ADDR_VAR 0 8
88153: PUSH
88154: LD_EXP 23
88158: PUSH
88159: LD_VAR 0 1
88163: ARRAY
88164: PPUSH
88165: LD_INT 2
88167: PUSH
88168: LD_INT 30
88170: PUSH
88171: LD_INT 0
88173: PUSH
88174: EMPTY
88175: LIST
88176: LIST
88177: PUSH
88178: LD_INT 30
88180: PUSH
88181: LD_INT 1
88183: PUSH
88184: EMPTY
88185: LIST
88186: LIST
88187: PUSH
88188: LD_INT 30
88190: PUSH
88191: LD_INT 6
88193: PUSH
88194: EMPTY
88195: LIST
88196: LIST
88197: PUSH
88198: EMPTY
88199: LIST
88200: LIST
88201: LIST
88202: LIST
88203: PPUSH
88204: CALL_OW 72
88208: PPUSH
88209: LD_VAR 0 7
88213: PPUSH
88214: CALL_OW 74
88218: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
88219: LD_VAR 0 7
88223: PPUSH
88224: LD_VAR 0 8
88228: PPUSH
88229: CALL_OW 250
88233: PPUSH
88234: LD_INT 3
88236: PPUSH
88237: LD_INT 5
88239: PPUSH
88240: CALL_OW 272
88244: PPUSH
88245: LD_VAR 0 8
88249: PPUSH
88250: CALL_OW 251
88254: PPUSH
88255: LD_INT 3
88257: PPUSH
88258: LD_INT 5
88260: PPUSH
88261: CALL_OW 273
88265: PPUSH
88266: CALL_OW 111
// SetTag ( i , 0 ) ;
88270: LD_VAR 0 7
88274: PPUSH
88275: LD_INT 0
88277: PPUSH
88278: CALL_OW 109
// solds := solds diff i ;
88282: LD_ADDR_VAR 0 2
88286: PUSH
88287: LD_VAR 0 2
88291: PUSH
88292: LD_VAR 0 7
88296: DIFF
88297: ST_TO_ADDR
// continue ;
88298: GO 87980
// end ; end ;
88300: GO 87980
88302: POP
88303: POP
// until not solds or not enemy ;
88304: LD_VAR 0 2
88308: NOT
88309: PUSH
88310: LD_VAR 0 4
88314: NOT
88315: OR
88316: IFFALSE 87884
// MC_Reset ( base , 18 ) ;
88318: LD_VAR 0 1
88322: PPUSH
88323: LD_INT 18
88325: PPUSH
88326: CALL 56527 0 2
// end ;
88330: LD_VAR 0 3
88334: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
88335: LD_INT 0
88337: PPUSH
88338: PPUSH
88339: PPUSH
88340: PPUSH
88341: PPUSH
88342: PPUSH
88343: PPUSH
88344: PPUSH
88345: PPUSH
88346: PPUSH
88347: PPUSH
88348: PPUSH
88349: PPUSH
88350: PPUSH
88351: PPUSH
88352: PPUSH
88353: PPUSH
88354: PPUSH
88355: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
88356: LD_ADDR_VAR 0 12
88360: PUSH
88361: LD_EXP 23
88365: PUSH
88366: LD_VAR 0 1
88370: ARRAY
88371: PPUSH
88372: LD_INT 25
88374: PUSH
88375: LD_INT 3
88377: PUSH
88378: EMPTY
88379: LIST
88380: LIST
88381: PPUSH
88382: CALL_OW 72
88386: ST_TO_ADDR
// if mc_remote_driver [ base ] then
88387: LD_EXP 63
88391: PUSH
88392: LD_VAR 0 1
88396: ARRAY
88397: IFFALSE 88421
// mechs := mechs diff mc_remote_driver [ base ] ;
88399: LD_ADDR_VAR 0 12
88403: PUSH
88404: LD_VAR 0 12
88408: PUSH
88409: LD_EXP 63
88413: PUSH
88414: LD_VAR 0 1
88418: ARRAY
88419: DIFF
88420: ST_TO_ADDR
// for i in mechs do
88421: LD_ADDR_VAR 0 4
88425: PUSH
88426: LD_VAR 0 12
88430: PUSH
88431: FOR_IN
88432: IFFALSE 88467
// if GetTag ( i ) > 0 then
88434: LD_VAR 0 4
88438: PPUSH
88439: CALL_OW 110
88443: PUSH
88444: LD_INT 0
88446: GREATER
88447: IFFALSE 88465
// mechs := mechs diff i ;
88449: LD_ADDR_VAR 0 12
88453: PUSH
88454: LD_VAR 0 12
88458: PUSH
88459: LD_VAR 0 4
88463: DIFF
88464: ST_TO_ADDR
88465: GO 88431
88467: POP
88468: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
88469: LD_ADDR_VAR 0 8
88473: PUSH
88474: LD_EXP 23
88478: PUSH
88479: LD_VAR 0 1
88483: ARRAY
88484: PPUSH
88485: LD_INT 2
88487: PUSH
88488: LD_INT 25
88490: PUSH
88491: LD_INT 1
88493: PUSH
88494: EMPTY
88495: LIST
88496: LIST
88497: PUSH
88498: LD_INT 25
88500: PUSH
88501: LD_INT 5
88503: PUSH
88504: EMPTY
88505: LIST
88506: LIST
88507: PUSH
88508: LD_INT 25
88510: PUSH
88511: LD_INT 8
88513: PUSH
88514: EMPTY
88515: LIST
88516: LIST
88517: PUSH
88518: LD_INT 25
88520: PUSH
88521: LD_INT 9
88523: PUSH
88524: EMPTY
88525: LIST
88526: LIST
88527: PUSH
88528: EMPTY
88529: LIST
88530: LIST
88531: LIST
88532: LIST
88533: LIST
88534: PPUSH
88535: CALL_OW 72
88539: ST_TO_ADDR
// if not defenders and not solds then
88540: LD_VAR 0 2
88544: NOT
88545: PUSH
88546: LD_VAR 0 8
88550: NOT
88551: AND
88552: IFFALSE 88556
// exit ;
88554: GO 90326
// depot_under_attack := false ;
88556: LD_ADDR_VAR 0 16
88560: PUSH
88561: LD_INT 0
88563: ST_TO_ADDR
// sold_defenders := [ ] ;
88564: LD_ADDR_VAR 0 17
88568: PUSH
88569: EMPTY
88570: ST_TO_ADDR
// if mechs then
88571: LD_VAR 0 12
88575: IFFALSE 88728
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
88577: LD_ADDR_VAR 0 4
88581: PUSH
88582: LD_VAR 0 2
88586: PPUSH
88587: LD_INT 21
88589: PUSH
88590: LD_INT 2
88592: PUSH
88593: EMPTY
88594: LIST
88595: LIST
88596: PPUSH
88597: CALL_OW 72
88601: PUSH
88602: FOR_IN
88603: IFFALSE 88726
// begin if GetTag ( i ) <> 20 then
88605: LD_VAR 0 4
88609: PPUSH
88610: CALL_OW 110
88614: PUSH
88615: LD_INT 20
88617: NONEQUAL
88618: IFFALSE 88632
// SetTag ( i , 20 ) ;
88620: LD_VAR 0 4
88624: PPUSH
88625: LD_INT 20
88627: PPUSH
88628: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
88632: LD_VAR 0 4
88636: PPUSH
88637: CALL_OW 263
88641: PUSH
88642: LD_INT 1
88644: EQUAL
88645: PUSH
88646: LD_VAR 0 4
88650: PPUSH
88651: CALL_OW 311
88655: NOT
88656: AND
88657: IFFALSE 88724
// begin un := mechs [ 1 ] ;
88659: LD_ADDR_VAR 0 10
88663: PUSH
88664: LD_VAR 0 12
88668: PUSH
88669: LD_INT 1
88671: ARRAY
88672: ST_TO_ADDR
// ComExit ( un ) ;
88673: LD_VAR 0 10
88677: PPUSH
88678: CALL 48811 0 1
// AddComEnterUnit ( un , i ) ;
88682: LD_VAR 0 10
88686: PPUSH
88687: LD_VAR 0 4
88691: PPUSH
88692: CALL_OW 180
// SetTag ( un , 19 ) ;
88696: LD_VAR 0 10
88700: PPUSH
88701: LD_INT 19
88703: PPUSH
88704: CALL_OW 109
// mechs := mechs diff un ;
88708: LD_ADDR_VAR 0 12
88712: PUSH
88713: LD_VAR 0 12
88717: PUSH
88718: LD_VAR 0 10
88722: DIFF
88723: ST_TO_ADDR
// end ; end ;
88724: GO 88602
88726: POP
88727: POP
// if solds then
88728: LD_VAR 0 8
88732: IFFALSE 88791
// for i in solds do
88734: LD_ADDR_VAR 0 4
88738: PUSH
88739: LD_VAR 0 8
88743: PUSH
88744: FOR_IN
88745: IFFALSE 88789
// if not GetTag ( i ) then
88747: LD_VAR 0 4
88751: PPUSH
88752: CALL_OW 110
88756: NOT
88757: IFFALSE 88787
// begin defenders := defenders union i ;
88759: LD_ADDR_VAR 0 2
88763: PUSH
88764: LD_VAR 0 2
88768: PUSH
88769: LD_VAR 0 4
88773: UNION
88774: ST_TO_ADDR
// SetTag ( i , 18 ) ;
88775: LD_VAR 0 4
88779: PPUSH
88780: LD_INT 18
88782: PPUSH
88783: CALL_OW 109
// end ;
88787: GO 88744
88789: POP
88790: POP
// repeat wait ( 0 0$2 ) ;
88791: LD_INT 70
88793: PPUSH
88794: CALL_OW 67
// enemy := mc_scan [ base ] ;
88798: LD_ADDR_VAR 0 21
88802: PUSH
88803: LD_EXP 46
88807: PUSH
88808: LD_VAR 0 1
88812: ARRAY
88813: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
88814: LD_EXP 23
88818: PUSH
88819: LD_VAR 0 1
88823: ARRAY
88824: NOT
88825: PUSH
88826: LD_EXP 23
88830: PUSH
88831: LD_VAR 0 1
88835: ARRAY
88836: PUSH
88837: EMPTY
88838: EQUAL
88839: OR
88840: IFFALSE 88877
// begin for i in defenders do
88842: LD_ADDR_VAR 0 4
88846: PUSH
88847: LD_VAR 0 2
88851: PUSH
88852: FOR_IN
88853: IFFALSE 88866
// ComStop ( i ) ;
88855: LD_VAR 0 4
88859: PPUSH
88860: CALL_OW 141
88864: GO 88852
88866: POP
88867: POP
// defenders := [ ] ;
88868: LD_ADDR_VAR 0 2
88872: PUSH
88873: EMPTY
88874: ST_TO_ADDR
// exit ;
88875: GO 90326
// end ; for i in defenders do
88877: LD_ADDR_VAR 0 4
88881: PUSH
88882: LD_VAR 0 2
88886: PUSH
88887: FOR_IN
88888: IFFALSE 89786
// begin e := NearestUnitToUnit ( enemy , i ) ;
88890: LD_ADDR_VAR 0 13
88894: PUSH
88895: LD_VAR 0 21
88899: PPUSH
88900: LD_VAR 0 4
88904: PPUSH
88905: CALL_OW 74
88909: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
88910: LD_ADDR_VAR 0 7
88914: PUSH
88915: LD_EXP 23
88919: PUSH
88920: LD_VAR 0 1
88924: ARRAY
88925: PPUSH
88926: LD_INT 2
88928: PUSH
88929: LD_INT 30
88931: PUSH
88932: LD_INT 0
88934: PUSH
88935: EMPTY
88936: LIST
88937: LIST
88938: PUSH
88939: LD_INT 30
88941: PUSH
88942: LD_INT 1
88944: PUSH
88945: EMPTY
88946: LIST
88947: LIST
88948: PUSH
88949: EMPTY
88950: LIST
88951: LIST
88952: LIST
88953: PPUSH
88954: CALL_OW 72
88958: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
88959: LD_ADDR_VAR 0 16
88963: PUSH
88964: LD_VAR 0 7
88968: NOT
88969: PUSH
88970: LD_VAR 0 7
88974: PPUSH
88975: LD_INT 3
88977: PUSH
88978: LD_INT 24
88980: PUSH
88981: LD_INT 600
88983: PUSH
88984: EMPTY
88985: LIST
88986: LIST
88987: PUSH
88988: EMPTY
88989: LIST
88990: LIST
88991: PPUSH
88992: CALL_OW 72
88996: OR
88997: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
88998: LD_VAR 0 4
89002: PPUSH
89003: CALL_OW 247
89007: PUSH
89008: LD_INT 2
89010: DOUBLE
89011: EQUAL
89012: IFTRUE 89016
89014: GO 89412
89016: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
89017: LD_VAR 0 4
89021: PPUSH
89022: CALL_OW 256
89026: PUSH
89027: LD_INT 1000
89029: EQUAL
89030: PUSH
89031: LD_VAR 0 4
89035: PPUSH
89036: LD_VAR 0 13
89040: PPUSH
89041: CALL_OW 296
89045: PUSH
89046: LD_INT 40
89048: LESS
89049: PUSH
89050: LD_VAR 0 13
89054: PPUSH
89055: LD_EXP 48
89059: PUSH
89060: LD_VAR 0 1
89064: ARRAY
89065: PPUSH
89066: CALL_OW 308
89070: OR
89071: AND
89072: IFFALSE 89194
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
89074: LD_VAR 0 4
89078: PPUSH
89079: CALL_OW 262
89083: PUSH
89084: LD_INT 1
89086: EQUAL
89087: PUSH
89088: LD_VAR 0 4
89092: PPUSH
89093: CALL_OW 261
89097: PUSH
89098: LD_INT 30
89100: LESS
89101: AND
89102: PUSH
89103: LD_VAR 0 7
89107: AND
89108: IFFALSE 89178
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
89110: LD_VAR 0 4
89114: PPUSH
89115: LD_VAR 0 7
89119: PPUSH
89120: LD_VAR 0 4
89124: PPUSH
89125: CALL_OW 74
89129: PPUSH
89130: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
89134: LD_VAR 0 4
89138: PPUSH
89139: LD_VAR 0 7
89143: PPUSH
89144: LD_VAR 0 4
89148: PPUSH
89149: CALL_OW 74
89153: PPUSH
89154: CALL_OW 296
89158: PUSH
89159: LD_INT 6
89161: LESS
89162: IFFALSE 89176
// SetFuel ( i , 100 ) ;
89164: LD_VAR 0 4
89168: PPUSH
89169: LD_INT 100
89171: PPUSH
89172: CALL_OW 240
// end else
89176: GO 89192
// ComAttackUnit ( i , e ) ;
89178: LD_VAR 0 4
89182: PPUSH
89183: LD_VAR 0 13
89187: PPUSH
89188: CALL_OW 115
// end else
89192: GO 89295
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
89194: LD_VAR 0 13
89198: PPUSH
89199: LD_EXP 48
89203: PUSH
89204: LD_VAR 0 1
89208: ARRAY
89209: PPUSH
89210: CALL_OW 308
89214: NOT
89215: PUSH
89216: LD_VAR 0 4
89220: PPUSH
89221: LD_VAR 0 13
89225: PPUSH
89226: CALL_OW 296
89230: PUSH
89231: LD_INT 40
89233: GREATEREQUAL
89234: AND
89235: PUSH
89236: LD_VAR 0 4
89240: PPUSH
89241: CALL_OW 256
89245: PUSH
89246: LD_INT 650
89248: LESSEQUAL
89249: OR
89250: PUSH
89251: LD_VAR 0 4
89255: PPUSH
89256: LD_EXP 47
89260: PUSH
89261: LD_VAR 0 1
89265: ARRAY
89266: PPUSH
89267: CALL_OW 308
89271: NOT
89272: AND
89273: IFFALSE 89295
// ComMoveToArea ( i , mc_parking [ base ] ) ;
89275: LD_VAR 0 4
89279: PPUSH
89280: LD_EXP 47
89284: PUSH
89285: LD_VAR 0 1
89289: ARRAY
89290: PPUSH
89291: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
89295: LD_VAR 0 4
89299: PPUSH
89300: CALL_OW 256
89304: PUSH
89305: LD_INT 1000
89307: LESS
89308: PUSH
89309: LD_VAR 0 4
89313: PPUSH
89314: CALL_OW 263
89318: PUSH
89319: LD_INT 1
89321: EQUAL
89322: AND
89323: PUSH
89324: LD_VAR 0 4
89328: PPUSH
89329: CALL_OW 311
89333: AND
89334: PUSH
89335: LD_VAR 0 4
89339: PPUSH
89340: LD_EXP 47
89344: PUSH
89345: LD_VAR 0 1
89349: ARRAY
89350: PPUSH
89351: CALL_OW 308
89355: AND
89356: IFFALSE 89410
// begin mech := IsDrivenBy ( i ) ;
89358: LD_ADDR_VAR 0 9
89362: PUSH
89363: LD_VAR 0 4
89367: PPUSH
89368: CALL_OW 311
89372: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
89373: LD_VAR 0 9
89377: PPUSH
89378: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
89382: LD_VAR 0 9
89386: PPUSH
89387: LD_VAR 0 4
89391: PPUSH
89392: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
89396: LD_VAR 0 9
89400: PPUSH
89401: LD_VAR 0 4
89405: PPUSH
89406: CALL_OW 180
// end ; end ; unit_human :
89410: GO 89757
89412: LD_INT 1
89414: DOUBLE
89415: EQUAL
89416: IFTRUE 89420
89418: GO 89756
89420: POP
// begin b := IsInUnit ( i ) ;
89421: LD_ADDR_VAR 0 18
89425: PUSH
89426: LD_VAR 0 4
89430: PPUSH
89431: CALL_OW 310
89435: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
89436: LD_ADDR_VAR 0 19
89440: PUSH
89441: LD_VAR 0 18
89445: NOT
89446: PUSH
89447: LD_VAR 0 18
89451: PPUSH
89452: CALL_OW 266
89456: PUSH
89457: LD_INT 32
89459: PUSH
89460: LD_INT 31
89462: PUSH
89463: EMPTY
89464: LIST
89465: LIST
89466: IN
89467: OR
89468: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
89469: LD_VAR 0 18
89473: PPUSH
89474: CALL_OW 266
89478: PUSH
89479: LD_INT 5
89481: EQUAL
89482: PUSH
89483: LD_VAR 0 4
89487: PPUSH
89488: CALL_OW 257
89492: PUSH
89493: LD_INT 1
89495: PUSH
89496: LD_INT 2
89498: PUSH
89499: LD_INT 3
89501: PUSH
89502: LD_INT 4
89504: PUSH
89505: EMPTY
89506: LIST
89507: LIST
89508: LIST
89509: LIST
89510: IN
89511: AND
89512: IFFALSE 89549
// begin class := AllowSpecClass ( i ) ;
89514: LD_ADDR_VAR 0 20
89518: PUSH
89519: LD_VAR 0 4
89523: PPUSH
89524: CALL 12759 0 1
89528: ST_TO_ADDR
// if class then
89529: LD_VAR 0 20
89533: IFFALSE 89549
// ComChangeProfession ( i , class ) ;
89535: LD_VAR 0 4
89539: PPUSH
89540: LD_VAR 0 20
89544: PPUSH
89545: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
89549: LD_VAR 0 16
89553: PUSH
89554: LD_VAR 0 2
89558: PPUSH
89559: LD_INT 21
89561: PUSH
89562: LD_INT 2
89564: PUSH
89565: EMPTY
89566: LIST
89567: LIST
89568: PPUSH
89569: CALL_OW 72
89573: PUSH
89574: LD_INT 1
89576: LESSEQUAL
89577: OR
89578: PUSH
89579: LD_VAR 0 19
89583: AND
89584: PUSH
89585: LD_VAR 0 4
89589: PUSH
89590: LD_VAR 0 17
89594: IN
89595: NOT
89596: AND
89597: IFFALSE 89690
// begin if b then
89599: LD_VAR 0 18
89603: IFFALSE 89652
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
89605: LD_VAR 0 18
89609: PPUSH
89610: LD_VAR 0 21
89614: PPUSH
89615: LD_VAR 0 18
89619: PPUSH
89620: CALL_OW 74
89624: PPUSH
89625: CALL_OW 296
89629: PUSH
89630: LD_INT 10
89632: LESS
89633: PUSH
89634: LD_VAR 0 18
89638: PPUSH
89639: CALL_OW 461
89643: PUSH
89644: LD_INT 7
89646: NONEQUAL
89647: AND
89648: IFFALSE 89652
// continue ;
89650: GO 88887
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
89652: LD_ADDR_VAR 0 17
89656: PUSH
89657: LD_VAR 0 17
89661: PPUSH
89662: LD_VAR 0 17
89666: PUSH
89667: LD_INT 1
89669: PLUS
89670: PPUSH
89671: LD_VAR 0 4
89675: PPUSH
89676: CALL_OW 1
89680: ST_TO_ADDR
// ComExitBuilding ( i ) ;
89681: LD_VAR 0 4
89685: PPUSH
89686: CALL_OW 122
// end ; if sold_defenders then
89690: LD_VAR 0 17
89694: IFFALSE 89754
// if i in sold_defenders then
89696: LD_VAR 0 4
89700: PUSH
89701: LD_VAR 0 17
89705: IN
89706: IFFALSE 89754
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
89708: LD_VAR 0 4
89712: PPUSH
89713: CALL_OW 314
89717: NOT
89718: PUSH
89719: LD_VAR 0 4
89723: PPUSH
89724: LD_VAR 0 13
89728: PPUSH
89729: CALL_OW 296
89733: PUSH
89734: LD_INT 30
89736: LESS
89737: AND
89738: IFFALSE 89754
// ComAttackUnit ( i , e ) ;
89740: LD_VAR 0 4
89744: PPUSH
89745: LD_VAR 0 13
89749: PPUSH
89750: CALL_OW 115
// end ; end ; end ;
89754: GO 89757
89756: POP
// if IsDead ( i ) then
89757: LD_VAR 0 4
89761: PPUSH
89762: CALL_OW 301
89766: IFFALSE 89784
// defenders := defenders diff i ;
89768: LD_ADDR_VAR 0 2
89772: PUSH
89773: LD_VAR 0 2
89777: PUSH
89778: LD_VAR 0 4
89782: DIFF
89783: ST_TO_ADDR
// end ;
89784: GO 88887
89786: POP
89787: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
89788: LD_VAR 0 21
89792: NOT
89793: PUSH
89794: LD_VAR 0 2
89798: NOT
89799: OR
89800: PUSH
89801: LD_EXP 23
89805: PUSH
89806: LD_VAR 0 1
89810: ARRAY
89811: NOT
89812: OR
89813: IFFALSE 88791
// MC_Reset ( base , 18 ) ;
89815: LD_VAR 0 1
89819: PPUSH
89820: LD_INT 18
89822: PPUSH
89823: CALL 56527 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
89827: LD_ADDR_VAR 0 2
89831: PUSH
89832: LD_VAR 0 2
89836: PUSH
89837: LD_VAR 0 2
89841: PPUSH
89842: LD_INT 2
89844: PUSH
89845: LD_INT 25
89847: PUSH
89848: LD_INT 1
89850: PUSH
89851: EMPTY
89852: LIST
89853: LIST
89854: PUSH
89855: LD_INT 25
89857: PUSH
89858: LD_INT 5
89860: PUSH
89861: EMPTY
89862: LIST
89863: LIST
89864: PUSH
89865: LD_INT 25
89867: PUSH
89868: LD_INT 8
89870: PUSH
89871: EMPTY
89872: LIST
89873: LIST
89874: PUSH
89875: LD_INT 25
89877: PUSH
89878: LD_INT 9
89880: PUSH
89881: EMPTY
89882: LIST
89883: LIST
89884: PUSH
89885: EMPTY
89886: LIST
89887: LIST
89888: LIST
89889: LIST
89890: LIST
89891: PPUSH
89892: CALL_OW 72
89896: DIFF
89897: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
89898: LD_VAR 0 21
89902: NOT
89903: PUSH
89904: LD_VAR 0 2
89908: PPUSH
89909: LD_INT 21
89911: PUSH
89912: LD_INT 2
89914: PUSH
89915: EMPTY
89916: LIST
89917: LIST
89918: PPUSH
89919: CALL_OW 72
89923: AND
89924: IFFALSE 90262
// begin tmp := FilterByTag ( defenders , 19 ) ;
89926: LD_ADDR_VAR 0 11
89930: PUSH
89931: LD_VAR 0 2
89935: PPUSH
89936: LD_INT 19
89938: PPUSH
89939: CALL 45996 0 2
89943: ST_TO_ADDR
// if tmp then
89944: LD_VAR 0 11
89948: IFFALSE 90018
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
89950: LD_ADDR_VAR 0 11
89954: PUSH
89955: LD_VAR 0 11
89959: PPUSH
89960: LD_INT 25
89962: PUSH
89963: LD_INT 3
89965: PUSH
89966: EMPTY
89967: LIST
89968: LIST
89969: PPUSH
89970: CALL_OW 72
89974: ST_TO_ADDR
// if tmp then
89975: LD_VAR 0 11
89979: IFFALSE 90018
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
89981: LD_ADDR_EXP 35
89985: PUSH
89986: LD_EXP 35
89990: PPUSH
89991: LD_VAR 0 1
89995: PPUSH
89996: LD_EXP 35
90000: PUSH
90001: LD_VAR 0 1
90005: ARRAY
90006: PUSH
90007: LD_VAR 0 11
90011: UNION
90012: PPUSH
90013: CALL_OW 1
90017: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
90018: LD_VAR 0 1
90022: PPUSH
90023: LD_INT 19
90025: PPUSH
90026: CALL 56527 0 2
// repeat wait ( 0 0$1 ) ;
90030: LD_INT 35
90032: PPUSH
90033: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
90037: LD_EXP 23
90041: PUSH
90042: LD_VAR 0 1
90046: ARRAY
90047: NOT
90048: PUSH
90049: LD_EXP 23
90053: PUSH
90054: LD_VAR 0 1
90058: ARRAY
90059: PUSH
90060: EMPTY
90061: EQUAL
90062: OR
90063: IFFALSE 90100
// begin for i in defenders do
90065: LD_ADDR_VAR 0 4
90069: PUSH
90070: LD_VAR 0 2
90074: PUSH
90075: FOR_IN
90076: IFFALSE 90089
// ComStop ( i ) ;
90078: LD_VAR 0 4
90082: PPUSH
90083: CALL_OW 141
90087: GO 90075
90089: POP
90090: POP
// defenders := [ ] ;
90091: LD_ADDR_VAR 0 2
90095: PUSH
90096: EMPTY
90097: ST_TO_ADDR
// exit ;
90098: GO 90326
// end ; for i in defenders do
90100: LD_ADDR_VAR 0 4
90104: PUSH
90105: LD_VAR 0 2
90109: PUSH
90110: FOR_IN
90111: IFFALSE 90200
// begin if not IsInArea ( i , mc_parking [ base ] ) then
90113: LD_VAR 0 4
90117: PPUSH
90118: LD_EXP 47
90122: PUSH
90123: LD_VAR 0 1
90127: ARRAY
90128: PPUSH
90129: CALL_OW 308
90133: NOT
90134: IFFALSE 90158
// ComMoveToArea ( i , mc_parking [ base ] ) else
90136: LD_VAR 0 4
90140: PPUSH
90141: LD_EXP 47
90145: PUSH
90146: LD_VAR 0 1
90150: ARRAY
90151: PPUSH
90152: CALL_OW 113
90156: GO 90198
// if GetControl ( i ) = control_manual then
90158: LD_VAR 0 4
90162: PPUSH
90163: CALL_OW 263
90167: PUSH
90168: LD_INT 1
90170: EQUAL
90171: IFFALSE 90198
// if IsDrivenBy ( i ) then
90173: LD_VAR 0 4
90177: PPUSH
90178: CALL_OW 311
90182: IFFALSE 90198
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
90184: LD_VAR 0 4
90188: PPUSH
90189: CALL_OW 311
90193: PPUSH
90194: CALL_OW 121
// end ;
90198: GO 90110
90200: POP
90201: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
90202: LD_VAR 0 2
90206: PPUSH
90207: LD_INT 95
90209: PUSH
90210: LD_EXP 47
90214: PUSH
90215: LD_VAR 0 1
90219: ARRAY
90220: PUSH
90221: EMPTY
90222: LIST
90223: LIST
90224: PPUSH
90225: CALL_OW 72
90229: PUSH
90230: LD_VAR 0 2
90234: EQUAL
90235: PUSH
90236: LD_EXP 46
90240: PUSH
90241: LD_VAR 0 1
90245: ARRAY
90246: OR
90247: PUSH
90248: LD_EXP 23
90252: PUSH
90253: LD_VAR 0 1
90257: ARRAY
90258: NOT
90259: OR
90260: IFFALSE 90030
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
90262: LD_ADDR_EXP 45
90266: PUSH
90267: LD_EXP 45
90271: PPUSH
90272: LD_VAR 0 1
90276: PPUSH
90277: LD_VAR 0 2
90281: PPUSH
90282: LD_INT 21
90284: PUSH
90285: LD_INT 2
90287: PUSH
90288: EMPTY
90289: LIST
90290: LIST
90291: PPUSH
90292: CALL_OW 72
90296: PPUSH
90297: CALL_OW 1
90301: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
90302: LD_VAR 0 1
90306: PPUSH
90307: LD_INT 19
90309: PPUSH
90310: CALL 56527 0 2
// MC_Reset ( base , 20 ) ;
90314: LD_VAR 0 1
90318: PPUSH
90319: LD_INT 20
90321: PPUSH
90322: CALL 56527 0 2
// end ; end_of_file
90326: LD_VAR 0 3
90330: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
90331: LD_INT 0
90333: PPUSH
90334: PPUSH
90335: PPUSH
90336: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
90337: LD_VAR 0 1
90341: PPUSH
90342: CALL_OW 264
90346: PUSH
90347: LD_INT 91
90349: EQUAL
90350: IFFALSE 90422
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
90352: LD_INT 68
90354: PPUSH
90355: LD_VAR 0 1
90359: PPUSH
90360: CALL_OW 255
90364: PPUSH
90365: CALL_OW 321
90369: PUSH
90370: LD_INT 2
90372: EQUAL
90373: IFFALSE 90385
// eff := 70 else
90375: LD_ADDR_VAR 0 4
90379: PUSH
90380: LD_INT 70
90382: ST_TO_ADDR
90383: GO 90393
// eff := 30 ;
90385: LD_ADDR_VAR 0 4
90389: PUSH
90390: LD_INT 30
90392: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
90393: LD_VAR 0 1
90397: PPUSH
90398: CALL_OW 250
90402: PPUSH
90403: LD_VAR 0 1
90407: PPUSH
90408: CALL_OW 251
90412: PPUSH
90413: LD_VAR 0 4
90417: PPUSH
90418: CALL_OW 495
// end ; end ;
90422: LD_VAR 0 2
90426: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
90427: LD_INT 0
90429: PPUSH
// end ;
90430: LD_VAR 0 4
90434: RET
// export function SOS_Command ( cmd ) ; begin
90435: LD_INT 0
90437: PPUSH
// end ;
90438: LD_VAR 0 2
90442: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
90443: LD_INT 0
90445: PPUSH
// end ;
90446: LD_VAR 0 6
90450: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
90451: LD_INT 0
90453: PPUSH
90454: PPUSH
// if not vehicle or not factory then
90455: LD_VAR 0 1
90459: NOT
90460: PUSH
90461: LD_VAR 0 2
90465: NOT
90466: OR
90467: IFFALSE 90471
// exit ;
90469: GO 90702
// if factoryWaypoints >= factory then
90471: LD_EXP 135
90475: PUSH
90476: LD_VAR 0 2
90480: GREATEREQUAL
90481: IFFALSE 90702
// if factoryWaypoints [ factory ] then
90483: LD_EXP 135
90487: PUSH
90488: LD_VAR 0 2
90492: ARRAY
90493: IFFALSE 90702
// begin if GetControl ( vehicle ) = control_manual then
90495: LD_VAR 0 1
90499: PPUSH
90500: CALL_OW 263
90504: PUSH
90505: LD_INT 1
90507: EQUAL
90508: IFFALSE 90589
// begin driver := IsDrivenBy ( vehicle ) ;
90510: LD_ADDR_VAR 0 4
90514: PUSH
90515: LD_VAR 0 1
90519: PPUSH
90520: CALL_OW 311
90524: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
90525: LD_VAR 0 4
90529: PPUSH
90530: LD_EXP 135
90534: PUSH
90535: LD_VAR 0 2
90539: ARRAY
90540: PUSH
90541: LD_INT 3
90543: ARRAY
90544: PPUSH
90545: LD_EXP 135
90549: PUSH
90550: LD_VAR 0 2
90554: ARRAY
90555: PUSH
90556: LD_INT 4
90558: ARRAY
90559: PPUSH
90560: CALL_OW 171
// AddComExitVehicle ( driver ) ;
90564: LD_VAR 0 4
90568: PPUSH
90569: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
90573: LD_VAR 0 4
90577: PPUSH
90578: LD_VAR 0 2
90582: PPUSH
90583: CALL_OW 180
// end else
90587: GO 90702
// if GetControl ( vehicle ) = control_remote then
90589: LD_VAR 0 1
90593: PPUSH
90594: CALL_OW 263
90598: PUSH
90599: LD_INT 2
90601: EQUAL
90602: IFFALSE 90663
// begin wait ( 0 0$2 ) ;
90604: LD_INT 70
90606: PPUSH
90607: CALL_OW 67
// if Connect ( vehicle ) then
90611: LD_VAR 0 1
90615: PPUSH
90616: CALL 19079 0 1
90620: IFFALSE 90661
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
90622: LD_VAR 0 1
90626: PPUSH
90627: LD_EXP 135
90631: PUSH
90632: LD_VAR 0 2
90636: ARRAY
90637: PUSH
90638: LD_INT 3
90640: ARRAY
90641: PPUSH
90642: LD_EXP 135
90646: PUSH
90647: LD_VAR 0 2
90651: ARRAY
90652: PUSH
90653: LD_INT 4
90655: ARRAY
90656: PPUSH
90657: CALL_OW 171
// end else
90661: GO 90702
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
90663: LD_VAR 0 1
90667: PPUSH
90668: LD_EXP 135
90672: PUSH
90673: LD_VAR 0 2
90677: ARRAY
90678: PUSH
90679: LD_INT 3
90681: ARRAY
90682: PPUSH
90683: LD_EXP 135
90687: PUSH
90688: LD_VAR 0 2
90692: ARRAY
90693: PUSH
90694: LD_INT 4
90696: ARRAY
90697: PPUSH
90698: CALL_OW 171
// end ; end ;
90702: LD_VAR 0 3
90706: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
90707: LD_INT 0
90709: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
90710: LD_VAR 0 1
90714: PUSH
90715: LD_INT 250
90717: EQUAL
90718: PUSH
90719: LD_VAR 0 2
90723: PPUSH
90724: CALL_OW 264
90728: PUSH
90729: LD_INT 81
90731: EQUAL
90732: AND
90733: IFFALSE 90754
// MinerPlaceMine ( unit , x , y ) ;
90735: LD_VAR 0 2
90739: PPUSH
90740: LD_VAR 0 4
90744: PPUSH
90745: LD_VAR 0 5
90749: PPUSH
90750: CALL 93139 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
90754: LD_VAR 0 1
90758: PUSH
90759: LD_INT 251
90761: EQUAL
90762: PUSH
90763: LD_VAR 0 2
90767: PPUSH
90768: CALL_OW 264
90772: PUSH
90773: LD_INT 81
90775: EQUAL
90776: AND
90777: IFFALSE 90798
// MinerDetonateMine ( unit , x , y ) ;
90779: LD_VAR 0 2
90783: PPUSH
90784: LD_VAR 0 4
90788: PPUSH
90789: LD_VAR 0 5
90793: PPUSH
90794: CALL 93414 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
90798: LD_VAR 0 1
90802: PUSH
90803: LD_INT 252
90805: EQUAL
90806: PUSH
90807: LD_VAR 0 2
90811: PPUSH
90812: CALL_OW 264
90816: PUSH
90817: LD_INT 81
90819: EQUAL
90820: AND
90821: IFFALSE 90842
// MinerCreateMinefield ( unit , x , y ) ;
90823: LD_VAR 0 2
90827: PPUSH
90828: LD_VAR 0 4
90832: PPUSH
90833: LD_VAR 0 5
90837: PPUSH
90838: CALL 93831 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
90842: LD_VAR 0 1
90846: PUSH
90847: LD_INT 253
90849: EQUAL
90850: PUSH
90851: LD_VAR 0 2
90855: PPUSH
90856: CALL_OW 257
90860: PUSH
90861: LD_INT 5
90863: EQUAL
90864: AND
90865: IFFALSE 90886
// ComBinocular ( unit , x , y ) ;
90867: LD_VAR 0 2
90871: PPUSH
90872: LD_VAR 0 4
90876: PPUSH
90877: LD_VAR 0 5
90881: PPUSH
90882: CALL 94200 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
90886: LD_VAR 0 1
90890: PUSH
90891: LD_INT 254
90893: EQUAL
90894: PUSH
90895: LD_VAR 0 2
90899: PPUSH
90900: CALL_OW 264
90904: PUSH
90905: LD_INT 99
90907: EQUAL
90908: AND
90909: PUSH
90910: LD_VAR 0 3
90914: PPUSH
90915: CALL_OW 263
90919: PUSH
90920: LD_INT 3
90922: EQUAL
90923: AND
90924: IFFALSE 90940
// HackDestroyVehicle ( unit , selectedUnit ) ;
90926: LD_VAR 0 2
90930: PPUSH
90931: LD_VAR 0 3
90935: PPUSH
90936: CALL 92503 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
90940: LD_VAR 0 1
90944: PUSH
90945: LD_INT 255
90947: EQUAL
90948: PUSH
90949: LD_VAR 0 2
90953: PPUSH
90954: CALL_OW 264
90958: PUSH
90959: LD_INT 14
90961: PUSH
90962: LD_INT 53
90964: PUSH
90965: EMPTY
90966: LIST
90967: LIST
90968: IN
90969: AND
90970: PUSH
90971: LD_VAR 0 4
90975: PPUSH
90976: LD_VAR 0 5
90980: PPUSH
90981: CALL_OW 488
90985: AND
90986: IFFALSE 91010
// CutTreeXYR ( unit , x , y , 12 ) ;
90988: LD_VAR 0 2
90992: PPUSH
90993: LD_VAR 0 4
90997: PPUSH
90998: LD_VAR 0 5
91002: PPUSH
91003: LD_INT 12
91005: PPUSH
91006: CALL 91073 0 4
// if cmd = 256 then
91010: LD_VAR 0 1
91014: PUSH
91015: LD_INT 256
91017: EQUAL
91018: IFFALSE 91039
// SetFactoryWaypoint ( unit , x , y ) ;
91020: LD_VAR 0 2
91024: PPUSH
91025: LD_VAR 0 4
91029: PPUSH
91030: LD_VAR 0 5
91034: PPUSH
91035: CALL 109121 0 3
// if cmd = 257 then
91039: LD_VAR 0 1
91043: PUSH
91044: LD_INT 257
91046: EQUAL
91047: IFFALSE 91068
// SetWarehouseGatheringPoint ( unit , x , y ) ;
91049: LD_VAR 0 2
91053: PPUSH
91054: LD_VAR 0 4
91058: PPUSH
91059: LD_VAR 0 5
91063: PPUSH
91064: CALL 109483 0 3
// end ;
91068: LD_VAR 0 6
91072: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
91073: LD_INT 0
91075: PPUSH
91076: PPUSH
91077: PPUSH
91078: PPUSH
91079: PPUSH
91080: PPUSH
91081: PPUSH
91082: PPUSH
91083: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
91084: LD_VAR 0 1
91088: NOT
91089: PUSH
91090: LD_VAR 0 2
91094: PPUSH
91095: LD_VAR 0 3
91099: PPUSH
91100: CALL_OW 488
91104: NOT
91105: OR
91106: PUSH
91107: LD_VAR 0 4
91111: NOT
91112: OR
91113: IFFALSE 91117
// exit ;
91115: GO 91457
// list := [ ] ;
91117: LD_ADDR_VAR 0 13
91121: PUSH
91122: EMPTY
91123: ST_TO_ADDR
// if x - r < 0 then
91124: LD_VAR 0 2
91128: PUSH
91129: LD_VAR 0 4
91133: MINUS
91134: PUSH
91135: LD_INT 0
91137: LESS
91138: IFFALSE 91150
// min_x := 0 else
91140: LD_ADDR_VAR 0 7
91144: PUSH
91145: LD_INT 0
91147: ST_TO_ADDR
91148: GO 91166
// min_x := x - r ;
91150: LD_ADDR_VAR 0 7
91154: PUSH
91155: LD_VAR 0 2
91159: PUSH
91160: LD_VAR 0 4
91164: MINUS
91165: ST_TO_ADDR
// if y - r < 0 then
91166: LD_VAR 0 3
91170: PUSH
91171: LD_VAR 0 4
91175: MINUS
91176: PUSH
91177: LD_INT 0
91179: LESS
91180: IFFALSE 91192
// min_y := 0 else
91182: LD_ADDR_VAR 0 8
91186: PUSH
91187: LD_INT 0
91189: ST_TO_ADDR
91190: GO 91208
// min_y := y - r ;
91192: LD_ADDR_VAR 0 8
91196: PUSH
91197: LD_VAR 0 3
91201: PUSH
91202: LD_VAR 0 4
91206: MINUS
91207: ST_TO_ADDR
// max_x := x + r ;
91208: LD_ADDR_VAR 0 9
91212: PUSH
91213: LD_VAR 0 2
91217: PUSH
91218: LD_VAR 0 4
91222: PLUS
91223: ST_TO_ADDR
// max_y := y + r ;
91224: LD_ADDR_VAR 0 10
91228: PUSH
91229: LD_VAR 0 3
91233: PUSH
91234: LD_VAR 0 4
91238: PLUS
91239: ST_TO_ADDR
// for _x = min_x to max_x do
91240: LD_ADDR_VAR 0 11
91244: PUSH
91245: DOUBLE
91246: LD_VAR 0 7
91250: DEC
91251: ST_TO_ADDR
91252: LD_VAR 0 9
91256: PUSH
91257: FOR_TO
91258: IFFALSE 91375
// for _y = min_y to max_y do
91260: LD_ADDR_VAR 0 12
91264: PUSH
91265: DOUBLE
91266: LD_VAR 0 8
91270: DEC
91271: ST_TO_ADDR
91272: LD_VAR 0 10
91276: PUSH
91277: FOR_TO
91278: IFFALSE 91371
// begin if not ValidHex ( _x , _y ) then
91280: LD_VAR 0 11
91284: PPUSH
91285: LD_VAR 0 12
91289: PPUSH
91290: CALL_OW 488
91294: NOT
91295: IFFALSE 91299
// continue ;
91297: GO 91277
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
91299: LD_VAR 0 11
91303: PPUSH
91304: LD_VAR 0 12
91308: PPUSH
91309: CALL_OW 351
91313: PUSH
91314: LD_VAR 0 11
91318: PPUSH
91319: LD_VAR 0 12
91323: PPUSH
91324: CALL_OW 554
91328: AND
91329: IFFALSE 91369
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
91331: LD_ADDR_VAR 0 13
91335: PUSH
91336: LD_VAR 0 13
91340: PPUSH
91341: LD_VAR 0 13
91345: PUSH
91346: LD_INT 1
91348: PLUS
91349: PPUSH
91350: LD_VAR 0 11
91354: PUSH
91355: LD_VAR 0 12
91359: PUSH
91360: EMPTY
91361: LIST
91362: LIST
91363: PPUSH
91364: CALL_OW 2
91368: ST_TO_ADDR
// end ;
91369: GO 91277
91371: POP
91372: POP
91373: GO 91257
91375: POP
91376: POP
// if not list then
91377: LD_VAR 0 13
91381: NOT
91382: IFFALSE 91386
// exit ;
91384: GO 91457
// for i in list do
91386: LD_ADDR_VAR 0 6
91390: PUSH
91391: LD_VAR 0 13
91395: PUSH
91396: FOR_IN
91397: IFFALSE 91455
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
91399: LD_VAR 0 1
91403: PPUSH
91404: LD_STRING M
91406: PUSH
91407: LD_VAR 0 6
91411: PUSH
91412: LD_INT 1
91414: ARRAY
91415: PUSH
91416: LD_VAR 0 6
91420: PUSH
91421: LD_INT 2
91423: ARRAY
91424: PUSH
91425: LD_INT 0
91427: PUSH
91428: LD_INT 0
91430: PUSH
91431: LD_INT 0
91433: PUSH
91434: LD_INT 0
91436: PUSH
91437: EMPTY
91438: LIST
91439: LIST
91440: LIST
91441: LIST
91442: LIST
91443: LIST
91444: LIST
91445: PUSH
91446: EMPTY
91447: LIST
91448: PPUSH
91449: CALL_OW 447
91453: GO 91396
91455: POP
91456: POP
// end ;
91457: LD_VAR 0 5
91461: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
91462: LD_EXP 67
91466: NOT
91467: IFFALSE 91517
91469: GO 91471
91471: DISABLE
// begin initHack := true ;
91472: LD_ADDR_EXP 67
91476: PUSH
91477: LD_INT 1
91479: ST_TO_ADDR
// hackTanks := [ ] ;
91480: LD_ADDR_EXP 68
91484: PUSH
91485: EMPTY
91486: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
91487: LD_ADDR_EXP 69
91491: PUSH
91492: EMPTY
91493: ST_TO_ADDR
// hackLimit := 3 ;
91494: LD_ADDR_EXP 70
91498: PUSH
91499: LD_INT 3
91501: ST_TO_ADDR
// hackDist := 12 ;
91502: LD_ADDR_EXP 71
91506: PUSH
91507: LD_INT 12
91509: ST_TO_ADDR
// hackCounter := [ ] ;
91510: LD_ADDR_EXP 72
91514: PUSH
91515: EMPTY
91516: ST_TO_ADDR
// end ;
91517: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
91518: LD_EXP 67
91522: PUSH
91523: LD_INT 34
91525: PUSH
91526: LD_INT 99
91528: PUSH
91529: EMPTY
91530: LIST
91531: LIST
91532: PPUSH
91533: CALL_OW 69
91537: AND
91538: IFFALSE 91791
91540: GO 91542
91542: DISABLE
91543: LD_INT 0
91545: PPUSH
91546: PPUSH
// begin enable ;
91547: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
91548: LD_ADDR_VAR 0 1
91552: PUSH
91553: LD_INT 34
91555: PUSH
91556: LD_INT 99
91558: PUSH
91559: EMPTY
91560: LIST
91561: LIST
91562: PPUSH
91563: CALL_OW 69
91567: PUSH
91568: FOR_IN
91569: IFFALSE 91789
// begin if not i in hackTanks then
91571: LD_VAR 0 1
91575: PUSH
91576: LD_EXP 68
91580: IN
91581: NOT
91582: IFFALSE 91665
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
91584: LD_ADDR_EXP 68
91588: PUSH
91589: LD_EXP 68
91593: PPUSH
91594: LD_EXP 68
91598: PUSH
91599: LD_INT 1
91601: PLUS
91602: PPUSH
91603: LD_VAR 0 1
91607: PPUSH
91608: CALL_OW 1
91612: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
91613: LD_ADDR_EXP 69
91617: PUSH
91618: LD_EXP 69
91622: PPUSH
91623: LD_EXP 69
91627: PUSH
91628: LD_INT 1
91630: PLUS
91631: PPUSH
91632: EMPTY
91633: PPUSH
91634: CALL_OW 1
91638: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
91639: LD_ADDR_EXP 72
91643: PUSH
91644: LD_EXP 72
91648: PPUSH
91649: LD_EXP 72
91653: PUSH
91654: LD_INT 1
91656: PLUS
91657: PPUSH
91658: EMPTY
91659: PPUSH
91660: CALL_OW 1
91664: ST_TO_ADDR
// end ; if not IsOk ( i ) then
91665: LD_VAR 0 1
91669: PPUSH
91670: CALL_OW 302
91674: NOT
91675: IFFALSE 91688
// begin HackUnlinkAll ( i ) ;
91677: LD_VAR 0 1
91681: PPUSH
91682: CALL 91794 0 1
// continue ;
91686: GO 91568
// end ; HackCheckCapturedStatus ( i ) ;
91688: LD_VAR 0 1
91692: PPUSH
91693: CALL 92237 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
91697: LD_ADDR_VAR 0 2
91701: PUSH
91702: LD_INT 81
91704: PUSH
91705: LD_VAR 0 1
91709: PPUSH
91710: CALL_OW 255
91714: PUSH
91715: EMPTY
91716: LIST
91717: LIST
91718: PUSH
91719: LD_INT 33
91721: PUSH
91722: LD_INT 3
91724: PUSH
91725: EMPTY
91726: LIST
91727: LIST
91728: PUSH
91729: LD_INT 91
91731: PUSH
91732: LD_VAR 0 1
91736: PUSH
91737: LD_EXP 71
91741: PUSH
91742: EMPTY
91743: LIST
91744: LIST
91745: LIST
91746: PUSH
91747: LD_INT 50
91749: PUSH
91750: EMPTY
91751: LIST
91752: PUSH
91753: EMPTY
91754: LIST
91755: LIST
91756: LIST
91757: LIST
91758: PPUSH
91759: CALL_OW 69
91763: ST_TO_ADDR
// if not tmp then
91764: LD_VAR 0 2
91768: NOT
91769: IFFALSE 91773
// continue ;
91771: GO 91568
// HackLink ( i , tmp ) ;
91773: LD_VAR 0 1
91777: PPUSH
91778: LD_VAR 0 2
91782: PPUSH
91783: CALL 91930 0 2
// end ;
91787: GO 91568
91789: POP
91790: POP
// end ;
91791: PPOPN 2
91793: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
91794: LD_INT 0
91796: PPUSH
91797: PPUSH
91798: PPUSH
// if not hack in hackTanks then
91799: LD_VAR 0 1
91803: PUSH
91804: LD_EXP 68
91808: IN
91809: NOT
91810: IFFALSE 91814
// exit ;
91812: GO 91925
// index := GetElementIndex ( hackTanks , hack ) ;
91814: LD_ADDR_VAR 0 4
91818: PUSH
91819: LD_EXP 68
91823: PPUSH
91824: LD_VAR 0 1
91828: PPUSH
91829: CALL 15895 0 2
91833: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
91834: LD_EXP 69
91838: PUSH
91839: LD_VAR 0 4
91843: ARRAY
91844: IFFALSE 91925
// begin for i in hackTanksCaptured [ index ] do
91846: LD_ADDR_VAR 0 3
91850: PUSH
91851: LD_EXP 69
91855: PUSH
91856: LD_VAR 0 4
91860: ARRAY
91861: PUSH
91862: FOR_IN
91863: IFFALSE 91889
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
91865: LD_VAR 0 3
91869: PUSH
91870: LD_INT 1
91872: ARRAY
91873: PPUSH
91874: LD_VAR 0 3
91878: PUSH
91879: LD_INT 2
91881: ARRAY
91882: PPUSH
91883: CALL_OW 235
91887: GO 91862
91889: POP
91890: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
91891: LD_ADDR_EXP 69
91895: PUSH
91896: LD_EXP 69
91900: PPUSH
91901: LD_VAR 0 4
91905: PPUSH
91906: EMPTY
91907: PPUSH
91908: CALL_OW 1
91912: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
91913: LD_VAR 0 1
91917: PPUSH
91918: LD_INT 0
91920: PPUSH
91921: CALL_OW 505
// end ; end ;
91925: LD_VAR 0 2
91929: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
91930: LD_INT 0
91932: PPUSH
91933: PPUSH
91934: PPUSH
// if not hack in hackTanks or not vehicles then
91935: LD_VAR 0 1
91939: PUSH
91940: LD_EXP 68
91944: IN
91945: NOT
91946: PUSH
91947: LD_VAR 0 2
91951: NOT
91952: OR
91953: IFFALSE 91957
// exit ;
91955: GO 92232
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
91957: LD_ADDR_VAR 0 2
91961: PUSH
91962: LD_VAR 0 1
91966: PPUSH
91967: LD_VAR 0 2
91971: PPUSH
91972: LD_INT 1
91974: PPUSH
91975: LD_INT 1
91977: PPUSH
91978: CALL 16545 0 4
91982: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
91983: LD_ADDR_VAR 0 5
91987: PUSH
91988: LD_EXP 68
91992: PPUSH
91993: LD_VAR 0 1
91997: PPUSH
91998: CALL 15895 0 2
92002: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
92003: LD_EXP 69
92007: PUSH
92008: LD_VAR 0 5
92012: ARRAY
92013: PUSH
92014: LD_EXP 70
92018: LESS
92019: IFFALSE 92208
// begin for i := 1 to vehicles do
92021: LD_ADDR_VAR 0 4
92025: PUSH
92026: DOUBLE
92027: LD_INT 1
92029: DEC
92030: ST_TO_ADDR
92031: LD_VAR 0 2
92035: PUSH
92036: FOR_TO
92037: IFFALSE 92206
// begin if hackTanksCaptured [ index ] = hackLimit then
92039: LD_EXP 69
92043: PUSH
92044: LD_VAR 0 5
92048: ARRAY
92049: PUSH
92050: LD_EXP 70
92054: EQUAL
92055: IFFALSE 92059
// break ;
92057: GO 92206
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
92059: LD_ADDR_EXP 72
92063: PUSH
92064: LD_EXP 72
92068: PPUSH
92069: LD_VAR 0 5
92073: PPUSH
92074: LD_EXP 72
92078: PUSH
92079: LD_VAR 0 5
92083: ARRAY
92084: PUSH
92085: LD_INT 1
92087: PLUS
92088: PPUSH
92089: CALL_OW 1
92093: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
92094: LD_ADDR_EXP 69
92098: PUSH
92099: LD_EXP 69
92103: PPUSH
92104: LD_VAR 0 5
92108: PUSH
92109: LD_EXP 69
92113: PUSH
92114: LD_VAR 0 5
92118: ARRAY
92119: PUSH
92120: LD_INT 1
92122: PLUS
92123: PUSH
92124: EMPTY
92125: LIST
92126: LIST
92127: PPUSH
92128: LD_VAR 0 2
92132: PUSH
92133: LD_VAR 0 4
92137: ARRAY
92138: PUSH
92139: LD_VAR 0 2
92143: PUSH
92144: LD_VAR 0 4
92148: ARRAY
92149: PPUSH
92150: CALL_OW 255
92154: PUSH
92155: EMPTY
92156: LIST
92157: LIST
92158: PPUSH
92159: CALL 16110 0 3
92163: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
92164: LD_VAR 0 2
92168: PUSH
92169: LD_VAR 0 4
92173: ARRAY
92174: PPUSH
92175: LD_VAR 0 1
92179: PPUSH
92180: CALL_OW 255
92184: PPUSH
92185: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
92189: LD_VAR 0 2
92193: PUSH
92194: LD_VAR 0 4
92198: ARRAY
92199: PPUSH
92200: CALL_OW 141
// end ;
92204: GO 92036
92206: POP
92207: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
92208: LD_VAR 0 1
92212: PPUSH
92213: LD_EXP 69
92217: PUSH
92218: LD_VAR 0 5
92222: ARRAY
92223: PUSH
92224: LD_INT 0
92226: PLUS
92227: PPUSH
92228: CALL_OW 505
// end ;
92232: LD_VAR 0 3
92236: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
92237: LD_INT 0
92239: PPUSH
92240: PPUSH
92241: PPUSH
92242: PPUSH
// if not hack in hackTanks then
92243: LD_VAR 0 1
92247: PUSH
92248: LD_EXP 68
92252: IN
92253: NOT
92254: IFFALSE 92258
// exit ;
92256: GO 92498
// index := GetElementIndex ( hackTanks , hack ) ;
92258: LD_ADDR_VAR 0 4
92262: PUSH
92263: LD_EXP 68
92267: PPUSH
92268: LD_VAR 0 1
92272: PPUSH
92273: CALL 15895 0 2
92277: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
92278: LD_ADDR_VAR 0 3
92282: PUSH
92283: DOUBLE
92284: LD_EXP 69
92288: PUSH
92289: LD_VAR 0 4
92293: ARRAY
92294: INC
92295: ST_TO_ADDR
92296: LD_INT 1
92298: PUSH
92299: FOR_DOWNTO
92300: IFFALSE 92472
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
92302: LD_ADDR_VAR 0 5
92306: PUSH
92307: LD_EXP 69
92311: PUSH
92312: LD_VAR 0 4
92316: ARRAY
92317: PUSH
92318: LD_VAR 0 3
92322: ARRAY
92323: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
92324: LD_VAR 0 5
92328: PUSH
92329: LD_INT 1
92331: ARRAY
92332: PPUSH
92333: CALL_OW 302
92337: NOT
92338: PUSH
92339: LD_VAR 0 5
92343: PUSH
92344: LD_INT 1
92346: ARRAY
92347: PPUSH
92348: CALL_OW 255
92352: PUSH
92353: LD_VAR 0 1
92357: PPUSH
92358: CALL_OW 255
92362: NONEQUAL
92363: OR
92364: IFFALSE 92470
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
92366: LD_VAR 0 5
92370: PUSH
92371: LD_INT 1
92373: ARRAY
92374: PPUSH
92375: CALL_OW 305
92379: PUSH
92380: LD_VAR 0 5
92384: PUSH
92385: LD_INT 1
92387: ARRAY
92388: PPUSH
92389: CALL_OW 255
92393: PUSH
92394: LD_VAR 0 1
92398: PPUSH
92399: CALL_OW 255
92403: EQUAL
92404: AND
92405: IFFALSE 92429
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
92407: LD_VAR 0 5
92411: PUSH
92412: LD_INT 1
92414: ARRAY
92415: PPUSH
92416: LD_VAR 0 5
92420: PUSH
92421: LD_INT 2
92423: ARRAY
92424: PPUSH
92425: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
92429: LD_ADDR_EXP 69
92433: PUSH
92434: LD_EXP 69
92438: PPUSH
92439: LD_VAR 0 4
92443: PPUSH
92444: LD_EXP 69
92448: PUSH
92449: LD_VAR 0 4
92453: ARRAY
92454: PPUSH
92455: LD_VAR 0 3
92459: PPUSH
92460: CALL_OW 3
92464: PPUSH
92465: CALL_OW 1
92469: ST_TO_ADDR
// end ; end ;
92470: GO 92299
92472: POP
92473: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
92474: LD_VAR 0 1
92478: PPUSH
92479: LD_EXP 69
92483: PUSH
92484: LD_VAR 0 4
92488: ARRAY
92489: PUSH
92490: LD_INT 0
92492: PLUS
92493: PPUSH
92494: CALL_OW 505
// end ;
92498: LD_VAR 0 2
92502: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
92503: LD_INT 0
92505: PPUSH
92506: PPUSH
92507: PPUSH
92508: PPUSH
// if not hack in hackTanks then
92509: LD_VAR 0 1
92513: PUSH
92514: LD_EXP 68
92518: IN
92519: NOT
92520: IFFALSE 92524
// exit ;
92522: GO 92609
// index := GetElementIndex ( hackTanks , hack ) ;
92524: LD_ADDR_VAR 0 5
92528: PUSH
92529: LD_EXP 68
92533: PPUSH
92534: LD_VAR 0 1
92538: PPUSH
92539: CALL 15895 0 2
92543: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
92544: LD_ADDR_VAR 0 4
92548: PUSH
92549: DOUBLE
92550: LD_INT 1
92552: DEC
92553: ST_TO_ADDR
92554: LD_EXP 69
92558: PUSH
92559: LD_VAR 0 5
92563: ARRAY
92564: PUSH
92565: FOR_TO
92566: IFFALSE 92607
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
92568: LD_EXP 69
92572: PUSH
92573: LD_VAR 0 5
92577: ARRAY
92578: PUSH
92579: LD_VAR 0 4
92583: ARRAY
92584: PUSH
92585: LD_INT 1
92587: ARRAY
92588: PUSH
92589: LD_VAR 0 2
92593: EQUAL
92594: IFFALSE 92605
// KillUnit ( vehicle ) ;
92596: LD_VAR 0 2
92600: PPUSH
92601: CALL_OW 66
92605: GO 92565
92607: POP
92608: POP
// end ;
92609: LD_VAR 0 3
92613: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
92614: LD_EXP 73
92618: NOT
92619: IFFALSE 92654
92621: GO 92623
92623: DISABLE
// begin initMiner := true ;
92624: LD_ADDR_EXP 73
92628: PUSH
92629: LD_INT 1
92631: ST_TO_ADDR
// minersList := [ ] ;
92632: LD_ADDR_EXP 74
92636: PUSH
92637: EMPTY
92638: ST_TO_ADDR
// minerMinesList := [ ] ;
92639: LD_ADDR_EXP 75
92643: PUSH
92644: EMPTY
92645: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
92646: LD_ADDR_EXP 76
92650: PUSH
92651: LD_INT 5
92653: ST_TO_ADDR
// end ;
92654: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
92655: LD_EXP 73
92659: PUSH
92660: LD_INT 34
92662: PUSH
92663: LD_INT 81
92665: PUSH
92666: EMPTY
92667: LIST
92668: LIST
92669: PPUSH
92670: CALL_OW 69
92674: AND
92675: IFFALSE 93136
92677: GO 92679
92679: DISABLE
92680: LD_INT 0
92682: PPUSH
92683: PPUSH
92684: PPUSH
92685: PPUSH
// begin enable ;
92686: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
92687: LD_ADDR_VAR 0 1
92691: PUSH
92692: LD_INT 34
92694: PUSH
92695: LD_INT 81
92697: PUSH
92698: EMPTY
92699: LIST
92700: LIST
92701: PPUSH
92702: CALL_OW 69
92706: PUSH
92707: FOR_IN
92708: IFFALSE 92780
// begin if not i in minersList then
92710: LD_VAR 0 1
92714: PUSH
92715: LD_EXP 74
92719: IN
92720: NOT
92721: IFFALSE 92778
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
92723: LD_ADDR_EXP 74
92727: PUSH
92728: LD_EXP 74
92732: PPUSH
92733: LD_EXP 74
92737: PUSH
92738: LD_INT 1
92740: PLUS
92741: PPUSH
92742: LD_VAR 0 1
92746: PPUSH
92747: CALL_OW 1
92751: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
92752: LD_ADDR_EXP 75
92756: PUSH
92757: LD_EXP 75
92761: PPUSH
92762: LD_EXP 75
92766: PUSH
92767: LD_INT 1
92769: PLUS
92770: PPUSH
92771: EMPTY
92772: PPUSH
92773: CALL_OW 1
92777: ST_TO_ADDR
// end end ;
92778: GO 92707
92780: POP
92781: POP
// for i := minerMinesList downto 1 do
92782: LD_ADDR_VAR 0 1
92786: PUSH
92787: DOUBLE
92788: LD_EXP 75
92792: INC
92793: ST_TO_ADDR
92794: LD_INT 1
92796: PUSH
92797: FOR_DOWNTO
92798: IFFALSE 93134
// begin if IsLive ( minersList [ i ] ) then
92800: LD_EXP 74
92804: PUSH
92805: LD_VAR 0 1
92809: ARRAY
92810: PPUSH
92811: CALL_OW 300
92815: IFFALSE 92843
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
92817: LD_EXP 74
92821: PUSH
92822: LD_VAR 0 1
92826: ARRAY
92827: PPUSH
92828: LD_EXP 75
92832: PUSH
92833: LD_VAR 0 1
92837: ARRAY
92838: PPUSH
92839: CALL_OW 505
// if not minerMinesList [ i ] then
92843: LD_EXP 75
92847: PUSH
92848: LD_VAR 0 1
92852: ARRAY
92853: NOT
92854: IFFALSE 92858
// continue ;
92856: GO 92797
// for j := minerMinesList [ i ] downto 1 do
92858: LD_ADDR_VAR 0 2
92862: PUSH
92863: DOUBLE
92864: LD_EXP 75
92868: PUSH
92869: LD_VAR 0 1
92873: ARRAY
92874: INC
92875: ST_TO_ADDR
92876: LD_INT 1
92878: PUSH
92879: FOR_DOWNTO
92880: IFFALSE 93130
// begin side := GetSide ( minersList [ i ] ) ;
92882: LD_ADDR_VAR 0 3
92886: PUSH
92887: LD_EXP 74
92891: PUSH
92892: LD_VAR 0 1
92896: ARRAY
92897: PPUSH
92898: CALL_OW 255
92902: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
92903: LD_ADDR_VAR 0 4
92907: PUSH
92908: LD_EXP 75
92912: PUSH
92913: LD_VAR 0 1
92917: ARRAY
92918: PUSH
92919: LD_VAR 0 2
92923: ARRAY
92924: PUSH
92925: LD_INT 1
92927: ARRAY
92928: PPUSH
92929: LD_EXP 75
92933: PUSH
92934: LD_VAR 0 1
92938: ARRAY
92939: PUSH
92940: LD_VAR 0 2
92944: ARRAY
92945: PUSH
92946: LD_INT 2
92948: ARRAY
92949: PPUSH
92950: CALL_OW 428
92954: ST_TO_ADDR
// if not tmp then
92955: LD_VAR 0 4
92959: NOT
92960: IFFALSE 92964
// continue ;
92962: GO 92879
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
92964: LD_VAR 0 4
92968: PUSH
92969: LD_INT 81
92971: PUSH
92972: LD_VAR 0 3
92976: PUSH
92977: EMPTY
92978: LIST
92979: LIST
92980: PPUSH
92981: CALL_OW 69
92985: IN
92986: PUSH
92987: LD_EXP 75
92991: PUSH
92992: LD_VAR 0 1
92996: ARRAY
92997: PUSH
92998: LD_VAR 0 2
93002: ARRAY
93003: PUSH
93004: LD_INT 1
93006: ARRAY
93007: PPUSH
93008: LD_EXP 75
93012: PUSH
93013: LD_VAR 0 1
93017: ARRAY
93018: PUSH
93019: LD_VAR 0 2
93023: ARRAY
93024: PUSH
93025: LD_INT 2
93027: ARRAY
93028: PPUSH
93029: CALL_OW 458
93033: AND
93034: IFFALSE 93128
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
93036: LD_EXP 75
93040: PUSH
93041: LD_VAR 0 1
93045: ARRAY
93046: PUSH
93047: LD_VAR 0 2
93051: ARRAY
93052: PUSH
93053: LD_INT 1
93055: ARRAY
93056: PPUSH
93057: LD_EXP 75
93061: PUSH
93062: LD_VAR 0 1
93066: ARRAY
93067: PUSH
93068: LD_VAR 0 2
93072: ARRAY
93073: PUSH
93074: LD_INT 2
93076: ARRAY
93077: PPUSH
93078: LD_VAR 0 3
93082: PPUSH
93083: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
93087: LD_ADDR_EXP 75
93091: PUSH
93092: LD_EXP 75
93096: PPUSH
93097: LD_VAR 0 1
93101: PPUSH
93102: LD_EXP 75
93106: PUSH
93107: LD_VAR 0 1
93111: ARRAY
93112: PPUSH
93113: LD_VAR 0 2
93117: PPUSH
93118: CALL_OW 3
93122: PPUSH
93123: CALL_OW 1
93127: ST_TO_ADDR
// end ; end ;
93128: GO 92879
93130: POP
93131: POP
// end ;
93132: GO 92797
93134: POP
93135: POP
// end ;
93136: PPOPN 4
93138: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
93139: LD_INT 0
93141: PPUSH
93142: PPUSH
// result := false ;
93143: LD_ADDR_VAR 0 4
93147: PUSH
93148: LD_INT 0
93150: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
93151: LD_VAR 0 1
93155: PPUSH
93156: CALL_OW 264
93160: PUSH
93161: LD_INT 81
93163: EQUAL
93164: NOT
93165: IFFALSE 93169
// exit ;
93167: GO 93409
// index := GetElementIndex ( minersList , unit ) ;
93169: LD_ADDR_VAR 0 5
93173: PUSH
93174: LD_EXP 74
93178: PPUSH
93179: LD_VAR 0 1
93183: PPUSH
93184: CALL 15895 0 2
93188: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
93189: LD_EXP 75
93193: PUSH
93194: LD_VAR 0 5
93198: ARRAY
93199: PUSH
93200: LD_EXP 76
93204: GREATEREQUAL
93205: IFFALSE 93209
// exit ;
93207: GO 93409
// ComMoveXY ( unit , x , y ) ;
93209: LD_VAR 0 1
93213: PPUSH
93214: LD_VAR 0 2
93218: PPUSH
93219: LD_VAR 0 3
93223: PPUSH
93224: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
93228: LD_INT 35
93230: PPUSH
93231: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
93235: LD_VAR 0 1
93239: PPUSH
93240: LD_VAR 0 2
93244: PPUSH
93245: LD_VAR 0 3
93249: PPUSH
93250: CALL 47222 0 3
93254: NOT
93255: PUSH
93256: LD_VAR 0 1
93260: PPUSH
93261: CALL_OW 314
93265: AND
93266: IFFALSE 93270
// exit ;
93268: GO 93409
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
93270: LD_VAR 0 2
93274: PPUSH
93275: LD_VAR 0 3
93279: PPUSH
93280: CALL_OW 428
93284: PUSH
93285: LD_VAR 0 1
93289: EQUAL
93290: PUSH
93291: LD_VAR 0 1
93295: PPUSH
93296: CALL_OW 314
93300: NOT
93301: AND
93302: IFFALSE 93228
// PlaySoundXY ( x , y , PlantMine ) ;
93304: LD_VAR 0 2
93308: PPUSH
93309: LD_VAR 0 3
93313: PPUSH
93314: LD_STRING PlantMine
93316: PPUSH
93317: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
93321: LD_VAR 0 2
93325: PPUSH
93326: LD_VAR 0 3
93330: PPUSH
93331: LD_VAR 0 1
93335: PPUSH
93336: CALL_OW 255
93340: PPUSH
93341: LD_INT 0
93343: PPUSH
93344: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
93348: LD_ADDR_EXP 75
93352: PUSH
93353: LD_EXP 75
93357: PPUSH
93358: LD_VAR 0 5
93362: PUSH
93363: LD_EXP 75
93367: PUSH
93368: LD_VAR 0 5
93372: ARRAY
93373: PUSH
93374: LD_INT 1
93376: PLUS
93377: PUSH
93378: EMPTY
93379: LIST
93380: LIST
93381: PPUSH
93382: LD_VAR 0 2
93386: PUSH
93387: LD_VAR 0 3
93391: PUSH
93392: EMPTY
93393: LIST
93394: LIST
93395: PPUSH
93396: CALL 16110 0 3
93400: ST_TO_ADDR
// result := true ;
93401: LD_ADDR_VAR 0 4
93405: PUSH
93406: LD_INT 1
93408: ST_TO_ADDR
// end ;
93409: LD_VAR 0 4
93413: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
93414: LD_INT 0
93416: PPUSH
93417: PPUSH
93418: PPUSH
// if not unit in minersList then
93419: LD_VAR 0 1
93423: PUSH
93424: LD_EXP 74
93428: IN
93429: NOT
93430: IFFALSE 93434
// exit ;
93432: GO 93826
// index := GetElementIndex ( minersList , unit ) ;
93434: LD_ADDR_VAR 0 6
93438: PUSH
93439: LD_EXP 74
93443: PPUSH
93444: LD_VAR 0 1
93448: PPUSH
93449: CALL 15895 0 2
93453: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
93454: LD_ADDR_VAR 0 5
93458: PUSH
93459: DOUBLE
93460: LD_EXP 75
93464: PUSH
93465: LD_VAR 0 6
93469: ARRAY
93470: INC
93471: ST_TO_ADDR
93472: LD_INT 1
93474: PUSH
93475: FOR_DOWNTO
93476: IFFALSE 93637
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
93478: LD_EXP 75
93482: PUSH
93483: LD_VAR 0 6
93487: ARRAY
93488: PUSH
93489: LD_VAR 0 5
93493: ARRAY
93494: PUSH
93495: LD_INT 1
93497: ARRAY
93498: PUSH
93499: LD_VAR 0 2
93503: EQUAL
93504: PUSH
93505: LD_EXP 75
93509: PUSH
93510: LD_VAR 0 6
93514: ARRAY
93515: PUSH
93516: LD_VAR 0 5
93520: ARRAY
93521: PUSH
93522: LD_INT 2
93524: ARRAY
93525: PUSH
93526: LD_VAR 0 3
93530: EQUAL
93531: AND
93532: IFFALSE 93635
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
93534: LD_EXP 75
93538: PUSH
93539: LD_VAR 0 6
93543: ARRAY
93544: PUSH
93545: LD_VAR 0 5
93549: ARRAY
93550: PUSH
93551: LD_INT 1
93553: ARRAY
93554: PPUSH
93555: LD_EXP 75
93559: PUSH
93560: LD_VAR 0 6
93564: ARRAY
93565: PUSH
93566: LD_VAR 0 5
93570: ARRAY
93571: PUSH
93572: LD_INT 2
93574: ARRAY
93575: PPUSH
93576: LD_VAR 0 1
93580: PPUSH
93581: CALL_OW 255
93585: PPUSH
93586: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
93590: LD_ADDR_EXP 75
93594: PUSH
93595: LD_EXP 75
93599: PPUSH
93600: LD_VAR 0 6
93604: PPUSH
93605: LD_EXP 75
93609: PUSH
93610: LD_VAR 0 6
93614: ARRAY
93615: PPUSH
93616: LD_VAR 0 5
93620: PPUSH
93621: CALL_OW 3
93625: PPUSH
93626: CALL_OW 1
93630: ST_TO_ADDR
// exit ;
93631: POP
93632: POP
93633: GO 93826
// end ; end ;
93635: GO 93475
93637: POP
93638: POP
// for i := minerMinesList [ index ] downto 1 do
93639: LD_ADDR_VAR 0 5
93643: PUSH
93644: DOUBLE
93645: LD_EXP 75
93649: PUSH
93650: LD_VAR 0 6
93654: ARRAY
93655: INC
93656: ST_TO_ADDR
93657: LD_INT 1
93659: PUSH
93660: FOR_DOWNTO
93661: IFFALSE 93824
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
93663: LD_EXP 75
93667: PUSH
93668: LD_VAR 0 6
93672: ARRAY
93673: PUSH
93674: LD_VAR 0 5
93678: ARRAY
93679: PUSH
93680: LD_INT 1
93682: ARRAY
93683: PPUSH
93684: LD_EXP 75
93688: PUSH
93689: LD_VAR 0 6
93693: ARRAY
93694: PUSH
93695: LD_VAR 0 5
93699: ARRAY
93700: PUSH
93701: LD_INT 2
93703: ARRAY
93704: PPUSH
93705: LD_VAR 0 2
93709: PPUSH
93710: LD_VAR 0 3
93714: PPUSH
93715: CALL_OW 298
93719: PUSH
93720: LD_INT 6
93722: LESS
93723: IFFALSE 93822
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
93725: LD_EXP 75
93729: PUSH
93730: LD_VAR 0 6
93734: ARRAY
93735: PUSH
93736: LD_VAR 0 5
93740: ARRAY
93741: PUSH
93742: LD_INT 1
93744: ARRAY
93745: PPUSH
93746: LD_EXP 75
93750: PUSH
93751: LD_VAR 0 6
93755: ARRAY
93756: PUSH
93757: LD_VAR 0 5
93761: ARRAY
93762: PUSH
93763: LD_INT 2
93765: ARRAY
93766: PPUSH
93767: LD_VAR 0 1
93771: PPUSH
93772: CALL_OW 255
93776: PPUSH
93777: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
93781: LD_ADDR_EXP 75
93785: PUSH
93786: LD_EXP 75
93790: PPUSH
93791: LD_VAR 0 6
93795: PPUSH
93796: LD_EXP 75
93800: PUSH
93801: LD_VAR 0 6
93805: ARRAY
93806: PPUSH
93807: LD_VAR 0 5
93811: PPUSH
93812: CALL_OW 3
93816: PPUSH
93817: CALL_OW 1
93821: ST_TO_ADDR
// end ; end ;
93822: GO 93660
93824: POP
93825: POP
// end ;
93826: LD_VAR 0 4
93830: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
93831: LD_INT 0
93833: PPUSH
93834: PPUSH
93835: PPUSH
93836: PPUSH
93837: PPUSH
93838: PPUSH
93839: PPUSH
93840: PPUSH
93841: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
93842: LD_VAR 0 1
93846: PPUSH
93847: CALL_OW 264
93851: PUSH
93852: LD_INT 81
93854: EQUAL
93855: NOT
93856: PUSH
93857: LD_VAR 0 1
93861: PUSH
93862: LD_EXP 74
93866: IN
93867: NOT
93868: OR
93869: IFFALSE 93873
// exit ;
93871: GO 94195
// index := GetElementIndex ( minersList , unit ) ;
93873: LD_ADDR_VAR 0 6
93877: PUSH
93878: LD_EXP 74
93882: PPUSH
93883: LD_VAR 0 1
93887: PPUSH
93888: CALL 15895 0 2
93892: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
93893: LD_ADDR_VAR 0 8
93897: PUSH
93898: LD_EXP 76
93902: PUSH
93903: LD_EXP 75
93907: PUSH
93908: LD_VAR 0 6
93912: ARRAY
93913: MINUS
93914: ST_TO_ADDR
// if not minesFreeAmount then
93915: LD_VAR 0 8
93919: NOT
93920: IFFALSE 93924
// exit ;
93922: GO 94195
// tmp := [ ] ;
93924: LD_ADDR_VAR 0 7
93928: PUSH
93929: EMPTY
93930: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
93931: LD_ADDR_VAR 0 5
93935: PUSH
93936: DOUBLE
93937: LD_INT 1
93939: DEC
93940: ST_TO_ADDR
93941: LD_VAR 0 8
93945: PUSH
93946: FOR_TO
93947: IFFALSE 94142
// begin _d := rand ( 0 , 5 ) ;
93949: LD_ADDR_VAR 0 11
93953: PUSH
93954: LD_INT 0
93956: PPUSH
93957: LD_INT 5
93959: PPUSH
93960: CALL_OW 12
93964: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
93965: LD_ADDR_VAR 0 12
93969: PUSH
93970: LD_INT 2
93972: PPUSH
93973: LD_INT 6
93975: PPUSH
93976: CALL_OW 12
93980: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
93981: LD_ADDR_VAR 0 9
93985: PUSH
93986: LD_VAR 0 2
93990: PPUSH
93991: LD_VAR 0 11
93995: PPUSH
93996: LD_VAR 0 12
94000: PPUSH
94001: CALL_OW 272
94005: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
94006: LD_ADDR_VAR 0 10
94010: PUSH
94011: LD_VAR 0 3
94015: PPUSH
94016: LD_VAR 0 11
94020: PPUSH
94021: LD_VAR 0 12
94025: PPUSH
94026: CALL_OW 273
94030: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
94031: LD_VAR 0 9
94035: PPUSH
94036: LD_VAR 0 10
94040: PPUSH
94041: CALL_OW 488
94045: PUSH
94046: LD_VAR 0 9
94050: PUSH
94051: LD_VAR 0 10
94055: PUSH
94056: EMPTY
94057: LIST
94058: LIST
94059: PUSH
94060: LD_VAR 0 7
94064: IN
94065: NOT
94066: AND
94067: PUSH
94068: LD_VAR 0 9
94072: PPUSH
94073: LD_VAR 0 10
94077: PPUSH
94078: CALL_OW 458
94082: NOT
94083: AND
94084: IFFALSE 94126
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
94086: LD_ADDR_VAR 0 7
94090: PUSH
94091: LD_VAR 0 7
94095: PPUSH
94096: LD_VAR 0 7
94100: PUSH
94101: LD_INT 1
94103: PLUS
94104: PPUSH
94105: LD_VAR 0 9
94109: PUSH
94110: LD_VAR 0 10
94114: PUSH
94115: EMPTY
94116: LIST
94117: LIST
94118: PPUSH
94119: CALL_OW 1
94123: ST_TO_ADDR
94124: GO 94140
// i := i - 1 ;
94126: LD_ADDR_VAR 0 5
94130: PUSH
94131: LD_VAR 0 5
94135: PUSH
94136: LD_INT 1
94138: MINUS
94139: ST_TO_ADDR
// end ;
94140: GO 93946
94142: POP
94143: POP
// for i in tmp do
94144: LD_ADDR_VAR 0 5
94148: PUSH
94149: LD_VAR 0 7
94153: PUSH
94154: FOR_IN
94155: IFFALSE 94193
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
94157: LD_VAR 0 1
94161: PPUSH
94162: LD_VAR 0 5
94166: PUSH
94167: LD_INT 1
94169: ARRAY
94170: PPUSH
94171: LD_VAR 0 5
94175: PUSH
94176: LD_INT 2
94178: ARRAY
94179: PPUSH
94180: CALL 93139 0 3
94184: NOT
94185: IFFALSE 94191
// exit ;
94187: POP
94188: POP
94189: GO 94195
94191: GO 94154
94193: POP
94194: POP
// end ;
94195: LD_VAR 0 4
94199: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
94200: LD_INT 0
94202: PPUSH
94203: PPUSH
94204: PPUSH
94205: PPUSH
94206: PPUSH
94207: PPUSH
94208: PPUSH
// if not GetClass ( unit ) = class_sniper then
94209: LD_VAR 0 1
94213: PPUSH
94214: CALL_OW 257
94218: PUSH
94219: LD_INT 5
94221: EQUAL
94222: NOT
94223: IFFALSE 94227
// exit ;
94225: GO 94615
// dist := 8 ;
94227: LD_ADDR_VAR 0 5
94231: PUSH
94232: LD_INT 8
94234: ST_TO_ADDR
// viewRange := 12 ;
94235: LD_ADDR_VAR 0 7
94239: PUSH
94240: LD_INT 12
94242: ST_TO_ADDR
// side := GetSide ( unit ) ;
94243: LD_ADDR_VAR 0 6
94247: PUSH
94248: LD_VAR 0 1
94252: PPUSH
94253: CALL_OW 255
94257: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
94258: LD_INT 61
94260: PPUSH
94261: LD_VAR 0 6
94265: PPUSH
94266: CALL_OW 321
94270: PUSH
94271: LD_INT 2
94273: EQUAL
94274: IFFALSE 94284
// viewRange := 16 ;
94276: LD_ADDR_VAR 0 7
94280: PUSH
94281: LD_INT 16
94283: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
94284: LD_VAR 0 1
94288: PPUSH
94289: LD_VAR 0 2
94293: PPUSH
94294: LD_VAR 0 3
94298: PPUSH
94299: CALL_OW 297
94303: PUSH
94304: LD_VAR 0 5
94308: GREATER
94309: IFFALSE 94388
// begin ComMoveXY ( unit , x , y ) ;
94311: LD_VAR 0 1
94315: PPUSH
94316: LD_VAR 0 2
94320: PPUSH
94321: LD_VAR 0 3
94325: PPUSH
94326: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
94330: LD_INT 35
94332: PPUSH
94333: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
94337: LD_VAR 0 1
94341: PPUSH
94342: LD_VAR 0 2
94346: PPUSH
94347: LD_VAR 0 3
94351: PPUSH
94352: CALL 47222 0 3
94356: NOT
94357: IFFALSE 94361
// exit ;
94359: GO 94615
// until GetDistUnitXY ( unit , x , y ) < dist ;
94361: LD_VAR 0 1
94365: PPUSH
94366: LD_VAR 0 2
94370: PPUSH
94371: LD_VAR 0 3
94375: PPUSH
94376: CALL_OW 297
94380: PUSH
94381: LD_VAR 0 5
94385: LESS
94386: IFFALSE 94330
// end ; ComTurnXY ( unit , x , y ) ;
94388: LD_VAR 0 1
94392: PPUSH
94393: LD_VAR 0 2
94397: PPUSH
94398: LD_VAR 0 3
94402: PPUSH
94403: CALL_OW 118
// wait ( 5 ) ;
94407: LD_INT 5
94409: PPUSH
94410: CALL_OW 67
// _d := GetDir ( unit ) ;
94414: LD_ADDR_VAR 0 10
94418: PUSH
94419: LD_VAR 0 1
94423: PPUSH
94424: CALL_OW 254
94428: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
94429: LD_ADDR_VAR 0 8
94433: PUSH
94434: LD_VAR 0 1
94438: PPUSH
94439: CALL_OW 250
94443: PPUSH
94444: LD_VAR 0 10
94448: PPUSH
94449: LD_VAR 0 5
94453: PPUSH
94454: CALL_OW 272
94458: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
94459: LD_ADDR_VAR 0 9
94463: PUSH
94464: LD_VAR 0 1
94468: PPUSH
94469: CALL_OW 251
94473: PPUSH
94474: LD_VAR 0 10
94478: PPUSH
94479: LD_VAR 0 5
94483: PPUSH
94484: CALL_OW 273
94488: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
94489: LD_VAR 0 8
94493: PPUSH
94494: LD_VAR 0 9
94498: PPUSH
94499: CALL_OW 488
94503: NOT
94504: IFFALSE 94508
// exit ;
94506: GO 94615
// ComAnimCustom ( unit , 1 ) ;
94508: LD_VAR 0 1
94512: PPUSH
94513: LD_INT 1
94515: PPUSH
94516: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
94520: LD_VAR 0 8
94524: PPUSH
94525: LD_VAR 0 9
94529: PPUSH
94530: LD_VAR 0 6
94534: PPUSH
94535: LD_VAR 0 7
94539: PPUSH
94540: CALL_OW 330
// repeat wait ( 1 ) ;
94544: LD_INT 1
94546: PPUSH
94547: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
94551: LD_VAR 0 1
94555: PPUSH
94556: CALL_OW 316
94560: PUSH
94561: LD_VAR 0 1
94565: PPUSH
94566: CALL_OW 314
94570: OR
94571: PUSH
94572: LD_VAR 0 1
94576: PPUSH
94577: CALL_OW 302
94581: NOT
94582: OR
94583: PUSH
94584: LD_VAR 0 1
94588: PPUSH
94589: CALL_OW 301
94593: OR
94594: IFFALSE 94544
// RemoveSeeing ( _x , _y , side ) ;
94596: LD_VAR 0 8
94600: PPUSH
94601: LD_VAR 0 9
94605: PPUSH
94606: LD_VAR 0 6
94610: PPUSH
94611: CALL_OW 331
// end ; end_of_file end_of_file
94615: LD_VAR 0 4
94619: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
94620: LD_VAR 0 1
94624: PUSH
94625: LD_INT 200
94627: DOUBLE
94628: GREATEREQUAL
94629: IFFALSE 94637
94631: LD_INT 299
94633: DOUBLE
94634: LESSEQUAL
94635: IFTRUE 94639
94637: GO 94671
94639: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
94640: LD_VAR 0 1
94644: PPUSH
94645: LD_VAR 0 2
94649: PPUSH
94650: LD_VAR 0 3
94654: PPUSH
94655: LD_VAR 0 4
94659: PPUSH
94660: LD_VAR 0 5
94664: PPUSH
94665: CALL 90707 0 5
94669: GO 94748
94671: LD_INT 300
94673: DOUBLE
94674: GREATEREQUAL
94675: IFFALSE 94683
94677: LD_INT 399
94679: DOUBLE
94680: LESSEQUAL
94681: IFTRUE 94685
94683: GO 94747
94685: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
94686: LD_VAR 0 1
94690: PPUSH
94691: LD_VAR 0 2
94695: PPUSH
94696: LD_VAR 0 3
94700: PPUSH
94701: LD_VAR 0 4
94705: PPUSH
94706: LD_VAR 0 5
94710: PPUSH
94711: LD_VAR 0 6
94715: PPUSH
94716: LD_VAR 0 7
94720: PPUSH
94721: LD_VAR 0 8
94725: PPUSH
94726: LD_VAR 0 9
94730: PPUSH
94731: LD_VAR 0 10
94735: PPUSH
94736: LD_VAR 0 11
94740: PPUSH
94741: CALL 107141 0 11
94745: GO 94748
94747: POP
// end ;
94748: PPOPN 11
94750: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
94751: LD_VAR 0 1
94755: PPUSH
94756: LD_VAR 0 2
94760: PPUSH
94761: LD_VAR 0 3
94765: PPUSH
94766: LD_VAR 0 4
94770: PPUSH
94771: LD_VAR 0 5
94775: PPUSH
94776: CALL 90443 0 5
// end ; end_of_file
94780: PPOPN 5
94782: END
// every 0 0$1 do
94783: GO 94785
94785: DISABLE
// begin enable ;
94786: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
94787: LD_STRING updateTimer(
94789: PUSH
94790: LD_OWVAR 1
94794: STR
94795: PUSH
94796: LD_STRING );
94798: STR
94799: PPUSH
94800: CALL_OW 559
// end ;
94804: END
// export function SOS_MapStart ( ) ; begin
94805: LD_INT 0
94807: PPUSH
// if streamModeActive then
94808: LD_EXP 77
94812: IFFALSE 94821
// DefineStreamItems ( true ) ;
94814: LD_INT 1
94816: PPUSH
94817: CALL 96475 0 1
// UpdateFactoryWaypoints ( ) ;
94821: CALL 109336 0 0
// UpdateWarehouseGatheringPoints ( ) ;
94825: CALL 109593 0 0
// end ;
94829: LD_VAR 0 1
94833: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
94834: LD_INT 0
94836: PPUSH
// if p2 = hack_mode then
94837: LD_VAR 0 2
94841: PUSH
94842: LD_INT 100
94844: EQUAL
94845: IFFALSE 95848
// begin if not StreamModeActive then
94847: LD_EXP 77
94851: NOT
94852: IFFALSE 94862
// StreamModeActive := true ;
94854: LD_ADDR_EXP 77
94858: PUSH
94859: LD_INT 1
94861: ST_TO_ADDR
// if p3 = 0 then
94862: LD_VAR 0 3
94866: PUSH
94867: LD_INT 0
94869: EQUAL
94870: IFFALSE 94876
// InitStreamMode ;
94872: CALL 96011 0 0
// if p3 = 1 then
94876: LD_VAR 0 3
94880: PUSH
94881: LD_INT 1
94883: EQUAL
94884: IFFALSE 94894
// sRocket := true ;
94886: LD_ADDR_EXP 82
94890: PUSH
94891: LD_INT 1
94893: ST_TO_ADDR
// if p3 = 2 then
94894: LD_VAR 0 3
94898: PUSH
94899: LD_INT 2
94901: EQUAL
94902: IFFALSE 94912
// sSpeed := true ;
94904: LD_ADDR_EXP 81
94908: PUSH
94909: LD_INT 1
94911: ST_TO_ADDR
// if p3 = 3 then
94912: LD_VAR 0 3
94916: PUSH
94917: LD_INT 3
94919: EQUAL
94920: IFFALSE 94930
// sEngine := true ;
94922: LD_ADDR_EXP 83
94926: PUSH
94927: LD_INT 1
94929: ST_TO_ADDR
// if p3 = 4 then
94930: LD_VAR 0 3
94934: PUSH
94935: LD_INT 4
94937: EQUAL
94938: IFFALSE 94948
// sSpec := true ;
94940: LD_ADDR_EXP 80
94944: PUSH
94945: LD_INT 1
94947: ST_TO_ADDR
// if p3 = 5 then
94948: LD_VAR 0 3
94952: PUSH
94953: LD_INT 5
94955: EQUAL
94956: IFFALSE 94966
// sLevel := true ;
94958: LD_ADDR_EXP 84
94962: PUSH
94963: LD_INT 1
94965: ST_TO_ADDR
// if p3 = 6 then
94966: LD_VAR 0 3
94970: PUSH
94971: LD_INT 6
94973: EQUAL
94974: IFFALSE 94984
// sArmoury := true ;
94976: LD_ADDR_EXP 85
94980: PUSH
94981: LD_INT 1
94983: ST_TO_ADDR
// if p3 = 7 then
94984: LD_VAR 0 3
94988: PUSH
94989: LD_INT 7
94991: EQUAL
94992: IFFALSE 95002
// sRadar := true ;
94994: LD_ADDR_EXP 86
94998: PUSH
94999: LD_INT 1
95001: ST_TO_ADDR
// if p3 = 8 then
95002: LD_VAR 0 3
95006: PUSH
95007: LD_INT 8
95009: EQUAL
95010: IFFALSE 95020
// sBunker := true ;
95012: LD_ADDR_EXP 87
95016: PUSH
95017: LD_INT 1
95019: ST_TO_ADDR
// if p3 = 9 then
95020: LD_VAR 0 3
95024: PUSH
95025: LD_INT 9
95027: EQUAL
95028: IFFALSE 95038
// sHack := true ;
95030: LD_ADDR_EXP 88
95034: PUSH
95035: LD_INT 1
95037: ST_TO_ADDR
// if p3 = 10 then
95038: LD_VAR 0 3
95042: PUSH
95043: LD_INT 10
95045: EQUAL
95046: IFFALSE 95056
// sFire := true ;
95048: LD_ADDR_EXP 89
95052: PUSH
95053: LD_INT 1
95055: ST_TO_ADDR
// if p3 = 11 then
95056: LD_VAR 0 3
95060: PUSH
95061: LD_INT 11
95063: EQUAL
95064: IFFALSE 95074
// sRefresh := true ;
95066: LD_ADDR_EXP 90
95070: PUSH
95071: LD_INT 1
95073: ST_TO_ADDR
// if p3 = 12 then
95074: LD_VAR 0 3
95078: PUSH
95079: LD_INT 12
95081: EQUAL
95082: IFFALSE 95092
// sExp := true ;
95084: LD_ADDR_EXP 91
95088: PUSH
95089: LD_INT 1
95091: ST_TO_ADDR
// if p3 = 13 then
95092: LD_VAR 0 3
95096: PUSH
95097: LD_INT 13
95099: EQUAL
95100: IFFALSE 95110
// sDepot := true ;
95102: LD_ADDR_EXP 92
95106: PUSH
95107: LD_INT 1
95109: ST_TO_ADDR
// if p3 = 14 then
95110: LD_VAR 0 3
95114: PUSH
95115: LD_INT 14
95117: EQUAL
95118: IFFALSE 95128
// sFlag := true ;
95120: LD_ADDR_EXP 93
95124: PUSH
95125: LD_INT 1
95127: ST_TO_ADDR
// if p3 = 15 then
95128: LD_VAR 0 3
95132: PUSH
95133: LD_INT 15
95135: EQUAL
95136: IFFALSE 95146
// sKamikadze := true ;
95138: LD_ADDR_EXP 101
95142: PUSH
95143: LD_INT 1
95145: ST_TO_ADDR
// if p3 = 16 then
95146: LD_VAR 0 3
95150: PUSH
95151: LD_INT 16
95153: EQUAL
95154: IFFALSE 95164
// sTroll := true ;
95156: LD_ADDR_EXP 102
95160: PUSH
95161: LD_INT 1
95163: ST_TO_ADDR
// if p3 = 17 then
95164: LD_VAR 0 3
95168: PUSH
95169: LD_INT 17
95171: EQUAL
95172: IFFALSE 95182
// sSlow := true ;
95174: LD_ADDR_EXP 103
95178: PUSH
95179: LD_INT 1
95181: ST_TO_ADDR
// if p3 = 18 then
95182: LD_VAR 0 3
95186: PUSH
95187: LD_INT 18
95189: EQUAL
95190: IFFALSE 95200
// sLack := true ;
95192: LD_ADDR_EXP 104
95196: PUSH
95197: LD_INT 1
95199: ST_TO_ADDR
// if p3 = 19 then
95200: LD_VAR 0 3
95204: PUSH
95205: LD_INT 19
95207: EQUAL
95208: IFFALSE 95218
// sTank := true ;
95210: LD_ADDR_EXP 106
95214: PUSH
95215: LD_INT 1
95217: ST_TO_ADDR
// if p3 = 20 then
95218: LD_VAR 0 3
95222: PUSH
95223: LD_INT 20
95225: EQUAL
95226: IFFALSE 95236
// sRemote := true ;
95228: LD_ADDR_EXP 107
95232: PUSH
95233: LD_INT 1
95235: ST_TO_ADDR
// if p3 = 21 then
95236: LD_VAR 0 3
95240: PUSH
95241: LD_INT 21
95243: EQUAL
95244: IFFALSE 95254
// sPowell := true ;
95246: LD_ADDR_EXP 108
95250: PUSH
95251: LD_INT 1
95253: ST_TO_ADDR
// if p3 = 22 then
95254: LD_VAR 0 3
95258: PUSH
95259: LD_INT 22
95261: EQUAL
95262: IFFALSE 95272
// sTeleport := true ;
95264: LD_ADDR_EXP 111
95268: PUSH
95269: LD_INT 1
95271: ST_TO_ADDR
// if p3 = 23 then
95272: LD_VAR 0 3
95276: PUSH
95277: LD_INT 23
95279: EQUAL
95280: IFFALSE 95290
// sOilTower := true ;
95282: LD_ADDR_EXP 113
95286: PUSH
95287: LD_INT 1
95289: ST_TO_ADDR
// if p3 = 24 then
95290: LD_VAR 0 3
95294: PUSH
95295: LD_INT 24
95297: EQUAL
95298: IFFALSE 95308
// sShovel := true ;
95300: LD_ADDR_EXP 114
95304: PUSH
95305: LD_INT 1
95307: ST_TO_ADDR
// if p3 = 25 then
95308: LD_VAR 0 3
95312: PUSH
95313: LD_INT 25
95315: EQUAL
95316: IFFALSE 95326
// sSheik := true ;
95318: LD_ADDR_EXP 115
95322: PUSH
95323: LD_INT 1
95325: ST_TO_ADDR
// if p3 = 26 then
95326: LD_VAR 0 3
95330: PUSH
95331: LD_INT 26
95333: EQUAL
95334: IFFALSE 95344
// sEarthquake := true ;
95336: LD_ADDR_EXP 117
95340: PUSH
95341: LD_INT 1
95343: ST_TO_ADDR
// if p3 = 27 then
95344: LD_VAR 0 3
95348: PUSH
95349: LD_INT 27
95351: EQUAL
95352: IFFALSE 95362
// sAI := true ;
95354: LD_ADDR_EXP 118
95358: PUSH
95359: LD_INT 1
95361: ST_TO_ADDR
// if p3 = 28 then
95362: LD_VAR 0 3
95366: PUSH
95367: LD_INT 28
95369: EQUAL
95370: IFFALSE 95380
// sCargo := true ;
95372: LD_ADDR_EXP 121
95376: PUSH
95377: LD_INT 1
95379: ST_TO_ADDR
// if p3 = 29 then
95380: LD_VAR 0 3
95384: PUSH
95385: LD_INT 29
95387: EQUAL
95388: IFFALSE 95398
// sDLaser := true ;
95390: LD_ADDR_EXP 122
95394: PUSH
95395: LD_INT 1
95397: ST_TO_ADDR
// if p3 = 30 then
95398: LD_VAR 0 3
95402: PUSH
95403: LD_INT 30
95405: EQUAL
95406: IFFALSE 95416
// sExchange := true ;
95408: LD_ADDR_EXP 123
95412: PUSH
95413: LD_INT 1
95415: ST_TO_ADDR
// if p3 = 31 then
95416: LD_VAR 0 3
95420: PUSH
95421: LD_INT 31
95423: EQUAL
95424: IFFALSE 95434
// sFac := true ;
95426: LD_ADDR_EXP 124
95430: PUSH
95431: LD_INT 1
95433: ST_TO_ADDR
// if p3 = 32 then
95434: LD_VAR 0 3
95438: PUSH
95439: LD_INT 32
95441: EQUAL
95442: IFFALSE 95452
// sPower := true ;
95444: LD_ADDR_EXP 125
95448: PUSH
95449: LD_INT 1
95451: ST_TO_ADDR
// if p3 = 33 then
95452: LD_VAR 0 3
95456: PUSH
95457: LD_INT 33
95459: EQUAL
95460: IFFALSE 95470
// sRandom := true ;
95462: LD_ADDR_EXP 126
95466: PUSH
95467: LD_INT 1
95469: ST_TO_ADDR
// if p3 = 34 then
95470: LD_VAR 0 3
95474: PUSH
95475: LD_INT 34
95477: EQUAL
95478: IFFALSE 95488
// sShield := true ;
95480: LD_ADDR_EXP 127
95484: PUSH
95485: LD_INT 1
95487: ST_TO_ADDR
// if p3 = 35 then
95488: LD_VAR 0 3
95492: PUSH
95493: LD_INT 35
95495: EQUAL
95496: IFFALSE 95506
// sTime := true ;
95498: LD_ADDR_EXP 128
95502: PUSH
95503: LD_INT 1
95505: ST_TO_ADDR
// if p3 = 36 then
95506: LD_VAR 0 3
95510: PUSH
95511: LD_INT 36
95513: EQUAL
95514: IFFALSE 95524
// sTools := true ;
95516: LD_ADDR_EXP 129
95520: PUSH
95521: LD_INT 1
95523: ST_TO_ADDR
// if p3 = 101 then
95524: LD_VAR 0 3
95528: PUSH
95529: LD_INT 101
95531: EQUAL
95532: IFFALSE 95542
// sSold := true ;
95534: LD_ADDR_EXP 94
95538: PUSH
95539: LD_INT 1
95541: ST_TO_ADDR
// if p3 = 102 then
95542: LD_VAR 0 3
95546: PUSH
95547: LD_INT 102
95549: EQUAL
95550: IFFALSE 95560
// sDiff := true ;
95552: LD_ADDR_EXP 95
95556: PUSH
95557: LD_INT 1
95559: ST_TO_ADDR
// if p3 = 103 then
95560: LD_VAR 0 3
95564: PUSH
95565: LD_INT 103
95567: EQUAL
95568: IFFALSE 95578
// sFog := true ;
95570: LD_ADDR_EXP 98
95574: PUSH
95575: LD_INT 1
95577: ST_TO_ADDR
// if p3 = 104 then
95578: LD_VAR 0 3
95582: PUSH
95583: LD_INT 104
95585: EQUAL
95586: IFFALSE 95596
// sReset := true ;
95588: LD_ADDR_EXP 99
95592: PUSH
95593: LD_INT 1
95595: ST_TO_ADDR
// if p3 = 105 then
95596: LD_VAR 0 3
95600: PUSH
95601: LD_INT 105
95603: EQUAL
95604: IFFALSE 95614
// sSun := true ;
95606: LD_ADDR_EXP 100
95610: PUSH
95611: LD_INT 1
95613: ST_TO_ADDR
// if p3 = 106 then
95614: LD_VAR 0 3
95618: PUSH
95619: LD_INT 106
95621: EQUAL
95622: IFFALSE 95632
// sTiger := true ;
95624: LD_ADDR_EXP 96
95628: PUSH
95629: LD_INT 1
95631: ST_TO_ADDR
// if p3 = 107 then
95632: LD_VAR 0 3
95636: PUSH
95637: LD_INT 107
95639: EQUAL
95640: IFFALSE 95650
// sBomb := true ;
95642: LD_ADDR_EXP 97
95646: PUSH
95647: LD_INT 1
95649: ST_TO_ADDR
// if p3 = 108 then
95650: LD_VAR 0 3
95654: PUSH
95655: LD_INT 108
95657: EQUAL
95658: IFFALSE 95668
// sWound := true ;
95660: LD_ADDR_EXP 105
95664: PUSH
95665: LD_INT 1
95667: ST_TO_ADDR
// if p3 = 109 then
95668: LD_VAR 0 3
95672: PUSH
95673: LD_INT 109
95675: EQUAL
95676: IFFALSE 95686
// sBetray := true ;
95678: LD_ADDR_EXP 109
95682: PUSH
95683: LD_INT 1
95685: ST_TO_ADDR
// if p3 = 110 then
95686: LD_VAR 0 3
95690: PUSH
95691: LD_INT 110
95693: EQUAL
95694: IFFALSE 95704
// sContamin := true ;
95696: LD_ADDR_EXP 110
95700: PUSH
95701: LD_INT 1
95703: ST_TO_ADDR
// if p3 = 111 then
95704: LD_VAR 0 3
95708: PUSH
95709: LD_INT 111
95711: EQUAL
95712: IFFALSE 95722
// sOil := true ;
95714: LD_ADDR_EXP 112
95718: PUSH
95719: LD_INT 1
95721: ST_TO_ADDR
// if p3 = 112 then
95722: LD_VAR 0 3
95726: PUSH
95727: LD_INT 112
95729: EQUAL
95730: IFFALSE 95740
// sStu := true ;
95732: LD_ADDR_EXP 116
95736: PUSH
95737: LD_INT 1
95739: ST_TO_ADDR
// if p3 = 113 then
95740: LD_VAR 0 3
95744: PUSH
95745: LD_INT 113
95747: EQUAL
95748: IFFALSE 95758
// sBazooka := true ;
95750: LD_ADDR_EXP 119
95754: PUSH
95755: LD_INT 1
95757: ST_TO_ADDR
// if p3 = 114 then
95758: LD_VAR 0 3
95762: PUSH
95763: LD_INT 114
95765: EQUAL
95766: IFFALSE 95776
// sMortar := true ;
95768: LD_ADDR_EXP 120
95772: PUSH
95773: LD_INT 1
95775: ST_TO_ADDR
// if p3 = 115 then
95776: LD_VAR 0 3
95780: PUSH
95781: LD_INT 115
95783: EQUAL
95784: IFFALSE 95794
// sRanger := true ;
95786: LD_ADDR_EXP 130
95790: PUSH
95791: LD_INT 1
95793: ST_TO_ADDR
// if p3 = 116 then
95794: LD_VAR 0 3
95798: PUSH
95799: LD_INT 116
95801: EQUAL
95802: IFFALSE 95812
// sComputer := true ;
95804: LD_ADDR_EXP 131
95808: PUSH
95809: LD_INT 1
95811: ST_TO_ADDR
// if p3 = 117 then
95812: LD_VAR 0 3
95816: PUSH
95817: LD_INT 117
95819: EQUAL
95820: IFFALSE 95830
// s30 := true ;
95822: LD_ADDR_EXP 132
95826: PUSH
95827: LD_INT 1
95829: ST_TO_ADDR
// if p3 = 118 then
95830: LD_VAR 0 3
95834: PUSH
95835: LD_INT 118
95837: EQUAL
95838: IFFALSE 95848
// s60 := true ;
95840: LD_ADDR_EXP 133
95844: PUSH
95845: LD_INT 1
95847: ST_TO_ADDR
// end ; if p2 = stream_mode then
95848: LD_VAR 0 2
95852: PUSH
95853: LD_INT 101
95855: EQUAL
95856: IFFALSE 95984
// begin case p3 of 1 :
95858: LD_VAR 0 3
95862: PUSH
95863: LD_INT 1
95865: DOUBLE
95866: EQUAL
95867: IFTRUE 95871
95869: GO 95878
95871: POP
// hHackUnlimitedResources ; 2 :
95872: CALL 108082 0 0
95876: GO 95984
95878: LD_INT 2
95880: DOUBLE
95881: EQUAL
95882: IFTRUE 95886
95884: GO 95893
95886: POP
// hHackSetLevel10 ; 3 :
95887: CALL 108215 0 0
95891: GO 95984
95893: LD_INT 3
95895: DOUBLE
95896: EQUAL
95897: IFTRUE 95901
95899: GO 95908
95901: POP
// hHackSetLevel10YourUnits ; 4 :
95902: CALL 108300 0 0
95906: GO 95984
95908: LD_INT 4
95910: DOUBLE
95911: EQUAL
95912: IFTRUE 95916
95914: GO 95923
95916: POP
// hHackInvincible ; 5 :
95917: CALL 108748 0 0
95921: GO 95984
95923: LD_INT 5
95925: DOUBLE
95926: EQUAL
95927: IFTRUE 95931
95929: GO 95938
95931: POP
// hHackInvisible ; 6 :
95932: CALL 108859 0 0
95936: GO 95984
95938: LD_INT 6
95940: DOUBLE
95941: EQUAL
95942: IFTRUE 95946
95944: GO 95953
95946: POP
// hHackChangeYourSide ; 7 :
95947: CALL 108916 0 0
95951: GO 95984
95953: LD_INT 7
95955: DOUBLE
95956: EQUAL
95957: IFTRUE 95961
95959: GO 95968
95961: POP
// hHackChangeUnitSide ; 8 :
95962: CALL 108958 0 0
95966: GO 95984
95968: LD_INT 8
95970: DOUBLE
95971: EQUAL
95972: IFTRUE 95976
95974: GO 95983
95976: POP
// hHackFog ; end ;
95977: CALL 109059 0 0
95981: GO 95984
95983: POP
// end ; end ;
95984: LD_VAR 0 7
95988: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
95989: GO 95991
95991: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
95992: LD_STRING initStreamRollete();
95994: PPUSH
95995: CALL_OW 559
// InitStreamMode ;
95999: CALL 96011 0 0
// DefineStreamItems ( false ) ;
96003: LD_INT 0
96005: PPUSH
96006: CALL 96475 0 1
// end ;
96010: END
// function InitStreamMode ; begin
96011: LD_INT 0
96013: PPUSH
// streamModeActive := false ;
96014: LD_ADDR_EXP 77
96018: PUSH
96019: LD_INT 0
96021: ST_TO_ADDR
// normalCounter := 36 ;
96022: LD_ADDR_EXP 78
96026: PUSH
96027: LD_INT 36
96029: ST_TO_ADDR
// hardcoreCounter := 18 ;
96030: LD_ADDR_EXP 79
96034: PUSH
96035: LD_INT 18
96037: ST_TO_ADDR
// sRocket := false ;
96038: LD_ADDR_EXP 82
96042: PUSH
96043: LD_INT 0
96045: ST_TO_ADDR
// sSpeed := false ;
96046: LD_ADDR_EXP 81
96050: PUSH
96051: LD_INT 0
96053: ST_TO_ADDR
// sEngine := false ;
96054: LD_ADDR_EXP 83
96058: PUSH
96059: LD_INT 0
96061: ST_TO_ADDR
// sSpec := false ;
96062: LD_ADDR_EXP 80
96066: PUSH
96067: LD_INT 0
96069: ST_TO_ADDR
// sLevel := false ;
96070: LD_ADDR_EXP 84
96074: PUSH
96075: LD_INT 0
96077: ST_TO_ADDR
// sArmoury := false ;
96078: LD_ADDR_EXP 85
96082: PUSH
96083: LD_INT 0
96085: ST_TO_ADDR
// sRadar := false ;
96086: LD_ADDR_EXP 86
96090: PUSH
96091: LD_INT 0
96093: ST_TO_ADDR
// sBunker := false ;
96094: LD_ADDR_EXP 87
96098: PUSH
96099: LD_INT 0
96101: ST_TO_ADDR
// sHack := false ;
96102: LD_ADDR_EXP 88
96106: PUSH
96107: LD_INT 0
96109: ST_TO_ADDR
// sFire := false ;
96110: LD_ADDR_EXP 89
96114: PUSH
96115: LD_INT 0
96117: ST_TO_ADDR
// sRefresh := false ;
96118: LD_ADDR_EXP 90
96122: PUSH
96123: LD_INT 0
96125: ST_TO_ADDR
// sExp := false ;
96126: LD_ADDR_EXP 91
96130: PUSH
96131: LD_INT 0
96133: ST_TO_ADDR
// sDepot := false ;
96134: LD_ADDR_EXP 92
96138: PUSH
96139: LD_INT 0
96141: ST_TO_ADDR
// sFlag := false ;
96142: LD_ADDR_EXP 93
96146: PUSH
96147: LD_INT 0
96149: ST_TO_ADDR
// sKamikadze := false ;
96150: LD_ADDR_EXP 101
96154: PUSH
96155: LD_INT 0
96157: ST_TO_ADDR
// sTroll := false ;
96158: LD_ADDR_EXP 102
96162: PUSH
96163: LD_INT 0
96165: ST_TO_ADDR
// sSlow := false ;
96166: LD_ADDR_EXP 103
96170: PUSH
96171: LD_INT 0
96173: ST_TO_ADDR
// sLack := false ;
96174: LD_ADDR_EXP 104
96178: PUSH
96179: LD_INT 0
96181: ST_TO_ADDR
// sTank := false ;
96182: LD_ADDR_EXP 106
96186: PUSH
96187: LD_INT 0
96189: ST_TO_ADDR
// sRemote := false ;
96190: LD_ADDR_EXP 107
96194: PUSH
96195: LD_INT 0
96197: ST_TO_ADDR
// sPowell := false ;
96198: LD_ADDR_EXP 108
96202: PUSH
96203: LD_INT 0
96205: ST_TO_ADDR
// sTeleport := false ;
96206: LD_ADDR_EXP 111
96210: PUSH
96211: LD_INT 0
96213: ST_TO_ADDR
// sOilTower := false ;
96214: LD_ADDR_EXP 113
96218: PUSH
96219: LD_INT 0
96221: ST_TO_ADDR
// sShovel := false ;
96222: LD_ADDR_EXP 114
96226: PUSH
96227: LD_INT 0
96229: ST_TO_ADDR
// sSheik := false ;
96230: LD_ADDR_EXP 115
96234: PUSH
96235: LD_INT 0
96237: ST_TO_ADDR
// sEarthquake := false ;
96238: LD_ADDR_EXP 117
96242: PUSH
96243: LD_INT 0
96245: ST_TO_ADDR
// sAI := false ;
96246: LD_ADDR_EXP 118
96250: PUSH
96251: LD_INT 0
96253: ST_TO_ADDR
// sCargo := false ;
96254: LD_ADDR_EXP 121
96258: PUSH
96259: LD_INT 0
96261: ST_TO_ADDR
// sDLaser := false ;
96262: LD_ADDR_EXP 122
96266: PUSH
96267: LD_INT 0
96269: ST_TO_ADDR
// sExchange := false ;
96270: LD_ADDR_EXP 123
96274: PUSH
96275: LD_INT 0
96277: ST_TO_ADDR
// sFac := false ;
96278: LD_ADDR_EXP 124
96282: PUSH
96283: LD_INT 0
96285: ST_TO_ADDR
// sPower := false ;
96286: LD_ADDR_EXP 125
96290: PUSH
96291: LD_INT 0
96293: ST_TO_ADDR
// sRandom := false ;
96294: LD_ADDR_EXP 126
96298: PUSH
96299: LD_INT 0
96301: ST_TO_ADDR
// sShield := false ;
96302: LD_ADDR_EXP 127
96306: PUSH
96307: LD_INT 0
96309: ST_TO_ADDR
// sTime := false ;
96310: LD_ADDR_EXP 128
96314: PUSH
96315: LD_INT 0
96317: ST_TO_ADDR
// sTools := false ;
96318: LD_ADDR_EXP 129
96322: PUSH
96323: LD_INT 0
96325: ST_TO_ADDR
// sSold := false ;
96326: LD_ADDR_EXP 94
96330: PUSH
96331: LD_INT 0
96333: ST_TO_ADDR
// sDiff := false ;
96334: LD_ADDR_EXP 95
96338: PUSH
96339: LD_INT 0
96341: ST_TO_ADDR
// sFog := false ;
96342: LD_ADDR_EXP 98
96346: PUSH
96347: LD_INT 0
96349: ST_TO_ADDR
// sReset := false ;
96350: LD_ADDR_EXP 99
96354: PUSH
96355: LD_INT 0
96357: ST_TO_ADDR
// sSun := false ;
96358: LD_ADDR_EXP 100
96362: PUSH
96363: LD_INT 0
96365: ST_TO_ADDR
// sTiger := false ;
96366: LD_ADDR_EXP 96
96370: PUSH
96371: LD_INT 0
96373: ST_TO_ADDR
// sBomb := false ;
96374: LD_ADDR_EXP 97
96378: PUSH
96379: LD_INT 0
96381: ST_TO_ADDR
// sWound := false ;
96382: LD_ADDR_EXP 105
96386: PUSH
96387: LD_INT 0
96389: ST_TO_ADDR
// sBetray := false ;
96390: LD_ADDR_EXP 109
96394: PUSH
96395: LD_INT 0
96397: ST_TO_ADDR
// sContamin := false ;
96398: LD_ADDR_EXP 110
96402: PUSH
96403: LD_INT 0
96405: ST_TO_ADDR
// sOil := false ;
96406: LD_ADDR_EXP 112
96410: PUSH
96411: LD_INT 0
96413: ST_TO_ADDR
// sStu := false ;
96414: LD_ADDR_EXP 116
96418: PUSH
96419: LD_INT 0
96421: ST_TO_ADDR
// sBazooka := false ;
96422: LD_ADDR_EXP 119
96426: PUSH
96427: LD_INT 0
96429: ST_TO_ADDR
// sMortar := false ;
96430: LD_ADDR_EXP 120
96434: PUSH
96435: LD_INT 0
96437: ST_TO_ADDR
// sRanger := false ;
96438: LD_ADDR_EXP 130
96442: PUSH
96443: LD_INT 0
96445: ST_TO_ADDR
// sComputer := false ;
96446: LD_ADDR_EXP 131
96450: PUSH
96451: LD_INT 0
96453: ST_TO_ADDR
// s30 := false ;
96454: LD_ADDR_EXP 132
96458: PUSH
96459: LD_INT 0
96461: ST_TO_ADDR
// s60 := false ;
96462: LD_ADDR_EXP 133
96466: PUSH
96467: LD_INT 0
96469: ST_TO_ADDR
// end ;
96470: LD_VAR 0 1
96474: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
96475: LD_INT 0
96477: PPUSH
96478: PPUSH
96479: PPUSH
96480: PPUSH
96481: PPUSH
96482: PPUSH
96483: PPUSH
// result := [ ] ;
96484: LD_ADDR_VAR 0 2
96488: PUSH
96489: EMPTY
96490: ST_TO_ADDR
// if campaign_id = 1 then
96491: LD_OWVAR 69
96495: PUSH
96496: LD_INT 1
96498: EQUAL
96499: IFFALSE 99665
// begin case mission_number of 1 :
96501: LD_OWVAR 70
96505: PUSH
96506: LD_INT 1
96508: DOUBLE
96509: EQUAL
96510: IFTRUE 96514
96512: GO 96590
96514: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
96515: LD_ADDR_VAR 0 2
96519: PUSH
96520: LD_INT 2
96522: PUSH
96523: LD_INT 4
96525: PUSH
96526: LD_INT 11
96528: PUSH
96529: LD_INT 12
96531: PUSH
96532: LD_INT 15
96534: PUSH
96535: LD_INT 16
96537: PUSH
96538: LD_INT 22
96540: PUSH
96541: LD_INT 23
96543: PUSH
96544: LD_INT 26
96546: PUSH
96547: EMPTY
96548: LIST
96549: LIST
96550: LIST
96551: LIST
96552: LIST
96553: LIST
96554: LIST
96555: LIST
96556: LIST
96557: PUSH
96558: LD_INT 101
96560: PUSH
96561: LD_INT 102
96563: PUSH
96564: LD_INT 106
96566: PUSH
96567: LD_INT 116
96569: PUSH
96570: LD_INT 117
96572: PUSH
96573: LD_INT 118
96575: PUSH
96576: EMPTY
96577: LIST
96578: LIST
96579: LIST
96580: LIST
96581: LIST
96582: LIST
96583: PUSH
96584: EMPTY
96585: LIST
96586: LIST
96587: ST_TO_ADDR
96588: GO 99663
96590: LD_INT 2
96592: DOUBLE
96593: EQUAL
96594: IFTRUE 96598
96596: GO 96682
96598: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
96599: LD_ADDR_VAR 0 2
96603: PUSH
96604: LD_INT 2
96606: PUSH
96607: LD_INT 4
96609: PUSH
96610: LD_INT 11
96612: PUSH
96613: LD_INT 12
96615: PUSH
96616: LD_INT 15
96618: PUSH
96619: LD_INT 16
96621: PUSH
96622: LD_INT 22
96624: PUSH
96625: LD_INT 23
96627: PUSH
96628: LD_INT 26
96630: PUSH
96631: EMPTY
96632: LIST
96633: LIST
96634: LIST
96635: LIST
96636: LIST
96637: LIST
96638: LIST
96639: LIST
96640: LIST
96641: PUSH
96642: LD_INT 101
96644: PUSH
96645: LD_INT 102
96647: PUSH
96648: LD_INT 105
96650: PUSH
96651: LD_INT 106
96653: PUSH
96654: LD_INT 108
96656: PUSH
96657: LD_INT 116
96659: PUSH
96660: LD_INT 117
96662: PUSH
96663: LD_INT 118
96665: PUSH
96666: EMPTY
96667: LIST
96668: LIST
96669: LIST
96670: LIST
96671: LIST
96672: LIST
96673: LIST
96674: LIST
96675: PUSH
96676: EMPTY
96677: LIST
96678: LIST
96679: ST_TO_ADDR
96680: GO 99663
96682: LD_INT 3
96684: DOUBLE
96685: EQUAL
96686: IFTRUE 96690
96688: GO 96778
96690: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
96691: LD_ADDR_VAR 0 2
96695: PUSH
96696: LD_INT 2
96698: PUSH
96699: LD_INT 4
96701: PUSH
96702: LD_INT 5
96704: PUSH
96705: LD_INT 11
96707: PUSH
96708: LD_INT 12
96710: PUSH
96711: LD_INT 15
96713: PUSH
96714: LD_INT 16
96716: PUSH
96717: LD_INT 22
96719: PUSH
96720: LD_INT 26
96722: PUSH
96723: LD_INT 36
96725: PUSH
96726: EMPTY
96727: LIST
96728: LIST
96729: LIST
96730: LIST
96731: LIST
96732: LIST
96733: LIST
96734: LIST
96735: LIST
96736: LIST
96737: PUSH
96738: LD_INT 101
96740: PUSH
96741: LD_INT 102
96743: PUSH
96744: LD_INT 105
96746: PUSH
96747: LD_INT 106
96749: PUSH
96750: LD_INT 108
96752: PUSH
96753: LD_INT 116
96755: PUSH
96756: LD_INT 117
96758: PUSH
96759: LD_INT 118
96761: PUSH
96762: EMPTY
96763: LIST
96764: LIST
96765: LIST
96766: LIST
96767: LIST
96768: LIST
96769: LIST
96770: LIST
96771: PUSH
96772: EMPTY
96773: LIST
96774: LIST
96775: ST_TO_ADDR
96776: GO 99663
96778: LD_INT 4
96780: DOUBLE
96781: EQUAL
96782: IFTRUE 96786
96784: GO 96882
96786: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
96787: LD_ADDR_VAR 0 2
96791: PUSH
96792: LD_INT 2
96794: PUSH
96795: LD_INT 4
96797: PUSH
96798: LD_INT 5
96800: PUSH
96801: LD_INT 8
96803: PUSH
96804: LD_INT 11
96806: PUSH
96807: LD_INT 12
96809: PUSH
96810: LD_INT 15
96812: PUSH
96813: LD_INT 16
96815: PUSH
96816: LD_INT 22
96818: PUSH
96819: LD_INT 23
96821: PUSH
96822: LD_INT 26
96824: PUSH
96825: LD_INT 36
96827: PUSH
96828: EMPTY
96829: LIST
96830: LIST
96831: LIST
96832: LIST
96833: LIST
96834: LIST
96835: LIST
96836: LIST
96837: LIST
96838: LIST
96839: LIST
96840: LIST
96841: PUSH
96842: LD_INT 101
96844: PUSH
96845: LD_INT 102
96847: PUSH
96848: LD_INT 105
96850: PUSH
96851: LD_INT 106
96853: PUSH
96854: LD_INT 108
96856: PUSH
96857: LD_INT 116
96859: PUSH
96860: LD_INT 117
96862: PUSH
96863: LD_INT 118
96865: PUSH
96866: EMPTY
96867: LIST
96868: LIST
96869: LIST
96870: LIST
96871: LIST
96872: LIST
96873: LIST
96874: LIST
96875: PUSH
96876: EMPTY
96877: LIST
96878: LIST
96879: ST_TO_ADDR
96880: GO 99663
96882: LD_INT 5
96884: DOUBLE
96885: EQUAL
96886: IFTRUE 96890
96888: GO 97002
96890: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
96891: LD_ADDR_VAR 0 2
96895: PUSH
96896: LD_INT 2
96898: PUSH
96899: LD_INT 4
96901: PUSH
96902: LD_INT 5
96904: PUSH
96905: LD_INT 6
96907: PUSH
96908: LD_INT 8
96910: PUSH
96911: LD_INT 11
96913: PUSH
96914: LD_INT 12
96916: PUSH
96917: LD_INT 15
96919: PUSH
96920: LD_INT 16
96922: PUSH
96923: LD_INT 22
96925: PUSH
96926: LD_INT 23
96928: PUSH
96929: LD_INT 25
96931: PUSH
96932: LD_INT 26
96934: PUSH
96935: LD_INT 36
96937: PUSH
96938: EMPTY
96939: LIST
96940: LIST
96941: LIST
96942: LIST
96943: LIST
96944: LIST
96945: LIST
96946: LIST
96947: LIST
96948: LIST
96949: LIST
96950: LIST
96951: LIST
96952: LIST
96953: PUSH
96954: LD_INT 101
96956: PUSH
96957: LD_INT 102
96959: PUSH
96960: LD_INT 105
96962: PUSH
96963: LD_INT 106
96965: PUSH
96966: LD_INT 108
96968: PUSH
96969: LD_INT 109
96971: PUSH
96972: LD_INT 112
96974: PUSH
96975: LD_INT 116
96977: PUSH
96978: LD_INT 117
96980: PUSH
96981: LD_INT 118
96983: PUSH
96984: EMPTY
96985: LIST
96986: LIST
96987: LIST
96988: LIST
96989: LIST
96990: LIST
96991: LIST
96992: LIST
96993: LIST
96994: LIST
96995: PUSH
96996: EMPTY
96997: LIST
96998: LIST
96999: ST_TO_ADDR
97000: GO 99663
97002: LD_INT 6
97004: DOUBLE
97005: EQUAL
97006: IFTRUE 97010
97008: GO 97142
97010: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
97011: LD_ADDR_VAR 0 2
97015: PUSH
97016: LD_INT 2
97018: PUSH
97019: LD_INT 4
97021: PUSH
97022: LD_INT 5
97024: PUSH
97025: LD_INT 6
97027: PUSH
97028: LD_INT 8
97030: PUSH
97031: LD_INT 11
97033: PUSH
97034: LD_INT 12
97036: PUSH
97037: LD_INT 15
97039: PUSH
97040: LD_INT 16
97042: PUSH
97043: LD_INT 20
97045: PUSH
97046: LD_INT 21
97048: PUSH
97049: LD_INT 22
97051: PUSH
97052: LD_INT 23
97054: PUSH
97055: LD_INT 25
97057: PUSH
97058: LD_INT 26
97060: PUSH
97061: LD_INT 30
97063: PUSH
97064: LD_INT 31
97066: PUSH
97067: LD_INT 32
97069: PUSH
97070: LD_INT 36
97072: PUSH
97073: EMPTY
97074: LIST
97075: LIST
97076: LIST
97077: LIST
97078: LIST
97079: LIST
97080: LIST
97081: LIST
97082: LIST
97083: LIST
97084: LIST
97085: LIST
97086: LIST
97087: LIST
97088: LIST
97089: LIST
97090: LIST
97091: LIST
97092: LIST
97093: PUSH
97094: LD_INT 101
97096: PUSH
97097: LD_INT 102
97099: PUSH
97100: LD_INT 105
97102: PUSH
97103: LD_INT 106
97105: PUSH
97106: LD_INT 108
97108: PUSH
97109: LD_INT 109
97111: PUSH
97112: LD_INT 112
97114: PUSH
97115: LD_INT 116
97117: PUSH
97118: LD_INT 117
97120: PUSH
97121: LD_INT 118
97123: PUSH
97124: EMPTY
97125: LIST
97126: LIST
97127: LIST
97128: LIST
97129: LIST
97130: LIST
97131: LIST
97132: LIST
97133: LIST
97134: LIST
97135: PUSH
97136: EMPTY
97137: LIST
97138: LIST
97139: ST_TO_ADDR
97140: GO 99663
97142: LD_INT 7
97144: DOUBLE
97145: EQUAL
97146: IFTRUE 97150
97148: GO 97262
97150: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
97151: LD_ADDR_VAR 0 2
97155: PUSH
97156: LD_INT 2
97158: PUSH
97159: LD_INT 4
97161: PUSH
97162: LD_INT 5
97164: PUSH
97165: LD_INT 7
97167: PUSH
97168: LD_INT 11
97170: PUSH
97171: LD_INT 12
97173: PUSH
97174: LD_INT 15
97176: PUSH
97177: LD_INT 16
97179: PUSH
97180: LD_INT 20
97182: PUSH
97183: LD_INT 21
97185: PUSH
97186: LD_INT 22
97188: PUSH
97189: LD_INT 23
97191: PUSH
97192: LD_INT 25
97194: PUSH
97195: LD_INT 26
97197: PUSH
97198: EMPTY
97199: LIST
97200: LIST
97201: LIST
97202: LIST
97203: LIST
97204: LIST
97205: LIST
97206: LIST
97207: LIST
97208: LIST
97209: LIST
97210: LIST
97211: LIST
97212: LIST
97213: PUSH
97214: LD_INT 101
97216: PUSH
97217: LD_INT 102
97219: PUSH
97220: LD_INT 103
97222: PUSH
97223: LD_INT 105
97225: PUSH
97226: LD_INT 106
97228: PUSH
97229: LD_INT 108
97231: PUSH
97232: LD_INT 112
97234: PUSH
97235: LD_INT 116
97237: PUSH
97238: LD_INT 117
97240: PUSH
97241: LD_INT 118
97243: PUSH
97244: EMPTY
97245: LIST
97246: LIST
97247: LIST
97248: LIST
97249: LIST
97250: LIST
97251: LIST
97252: LIST
97253: LIST
97254: LIST
97255: PUSH
97256: EMPTY
97257: LIST
97258: LIST
97259: ST_TO_ADDR
97260: GO 99663
97262: LD_INT 8
97264: DOUBLE
97265: EQUAL
97266: IFTRUE 97270
97268: GO 97410
97270: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
97271: LD_ADDR_VAR 0 2
97275: PUSH
97276: LD_INT 2
97278: PUSH
97279: LD_INT 4
97281: PUSH
97282: LD_INT 5
97284: PUSH
97285: LD_INT 6
97287: PUSH
97288: LD_INT 7
97290: PUSH
97291: LD_INT 8
97293: PUSH
97294: LD_INT 11
97296: PUSH
97297: LD_INT 12
97299: PUSH
97300: LD_INT 15
97302: PUSH
97303: LD_INT 16
97305: PUSH
97306: LD_INT 20
97308: PUSH
97309: LD_INT 21
97311: PUSH
97312: LD_INT 22
97314: PUSH
97315: LD_INT 23
97317: PUSH
97318: LD_INT 25
97320: PUSH
97321: LD_INT 26
97323: PUSH
97324: LD_INT 30
97326: PUSH
97327: LD_INT 31
97329: PUSH
97330: LD_INT 32
97332: PUSH
97333: LD_INT 36
97335: PUSH
97336: EMPTY
97337: LIST
97338: LIST
97339: LIST
97340: LIST
97341: LIST
97342: LIST
97343: LIST
97344: LIST
97345: LIST
97346: LIST
97347: LIST
97348: LIST
97349: LIST
97350: LIST
97351: LIST
97352: LIST
97353: LIST
97354: LIST
97355: LIST
97356: LIST
97357: PUSH
97358: LD_INT 101
97360: PUSH
97361: LD_INT 102
97363: PUSH
97364: LD_INT 103
97366: PUSH
97367: LD_INT 105
97369: PUSH
97370: LD_INT 106
97372: PUSH
97373: LD_INT 108
97375: PUSH
97376: LD_INT 109
97378: PUSH
97379: LD_INT 112
97381: PUSH
97382: LD_INT 116
97384: PUSH
97385: LD_INT 117
97387: PUSH
97388: LD_INT 118
97390: PUSH
97391: EMPTY
97392: LIST
97393: LIST
97394: LIST
97395: LIST
97396: LIST
97397: LIST
97398: LIST
97399: LIST
97400: LIST
97401: LIST
97402: LIST
97403: PUSH
97404: EMPTY
97405: LIST
97406: LIST
97407: ST_TO_ADDR
97408: GO 99663
97410: LD_INT 9
97412: DOUBLE
97413: EQUAL
97414: IFTRUE 97418
97416: GO 97566
97418: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
97419: LD_ADDR_VAR 0 2
97423: PUSH
97424: LD_INT 2
97426: PUSH
97427: LD_INT 4
97429: PUSH
97430: LD_INT 5
97432: PUSH
97433: LD_INT 6
97435: PUSH
97436: LD_INT 7
97438: PUSH
97439: LD_INT 8
97441: PUSH
97442: LD_INT 11
97444: PUSH
97445: LD_INT 12
97447: PUSH
97448: LD_INT 15
97450: PUSH
97451: LD_INT 16
97453: PUSH
97454: LD_INT 20
97456: PUSH
97457: LD_INT 21
97459: PUSH
97460: LD_INT 22
97462: PUSH
97463: LD_INT 23
97465: PUSH
97466: LD_INT 25
97468: PUSH
97469: LD_INT 26
97471: PUSH
97472: LD_INT 28
97474: PUSH
97475: LD_INT 30
97477: PUSH
97478: LD_INT 31
97480: PUSH
97481: LD_INT 32
97483: PUSH
97484: LD_INT 36
97486: PUSH
97487: EMPTY
97488: LIST
97489: LIST
97490: LIST
97491: LIST
97492: LIST
97493: LIST
97494: LIST
97495: LIST
97496: LIST
97497: LIST
97498: LIST
97499: LIST
97500: LIST
97501: LIST
97502: LIST
97503: LIST
97504: LIST
97505: LIST
97506: LIST
97507: LIST
97508: LIST
97509: PUSH
97510: LD_INT 101
97512: PUSH
97513: LD_INT 102
97515: PUSH
97516: LD_INT 103
97518: PUSH
97519: LD_INT 105
97521: PUSH
97522: LD_INT 106
97524: PUSH
97525: LD_INT 108
97527: PUSH
97528: LD_INT 109
97530: PUSH
97531: LD_INT 112
97533: PUSH
97534: LD_INT 114
97536: PUSH
97537: LD_INT 116
97539: PUSH
97540: LD_INT 117
97542: PUSH
97543: LD_INT 118
97545: PUSH
97546: EMPTY
97547: LIST
97548: LIST
97549: LIST
97550: LIST
97551: LIST
97552: LIST
97553: LIST
97554: LIST
97555: LIST
97556: LIST
97557: LIST
97558: LIST
97559: PUSH
97560: EMPTY
97561: LIST
97562: LIST
97563: ST_TO_ADDR
97564: GO 99663
97566: LD_INT 10
97568: DOUBLE
97569: EQUAL
97570: IFTRUE 97574
97572: GO 97770
97574: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
97575: LD_ADDR_VAR 0 2
97579: PUSH
97580: LD_INT 2
97582: PUSH
97583: LD_INT 4
97585: PUSH
97586: LD_INT 5
97588: PUSH
97589: LD_INT 6
97591: PUSH
97592: LD_INT 7
97594: PUSH
97595: LD_INT 8
97597: PUSH
97598: LD_INT 9
97600: PUSH
97601: LD_INT 10
97603: PUSH
97604: LD_INT 11
97606: PUSH
97607: LD_INT 12
97609: PUSH
97610: LD_INT 13
97612: PUSH
97613: LD_INT 14
97615: PUSH
97616: LD_INT 15
97618: PUSH
97619: LD_INT 16
97621: PUSH
97622: LD_INT 17
97624: PUSH
97625: LD_INT 18
97627: PUSH
97628: LD_INT 19
97630: PUSH
97631: LD_INT 20
97633: PUSH
97634: LD_INT 21
97636: PUSH
97637: LD_INT 22
97639: PUSH
97640: LD_INT 23
97642: PUSH
97643: LD_INT 24
97645: PUSH
97646: LD_INT 25
97648: PUSH
97649: LD_INT 26
97651: PUSH
97652: LD_INT 28
97654: PUSH
97655: LD_INT 30
97657: PUSH
97658: LD_INT 31
97660: PUSH
97661: LD_INT 32
97663: PUSH
97664: LD_INT 36
97666: PUSH
97667: EMPTY
97668: LIST
97669: LIST
97670: LIST
97671: LIST
97672: LIST
97673: LIST
97674: LIST
97675: LIST
97676: LIST
97677: LIST
97678: LIST
97679: LIST
97680: LIST
97681: LIST
97682: LIST
97683: LIST
97684: LIST
97685: LIST
97686: LIST
97687: LIST
97688: LIST
97689: LIST
97690: LIST
97691: LIST
97692: LIST
97693: LIST
97694: LIST
97695: LIST
97696: LIST
97697: PUSH
97698: LD_INT 101
97700: PUSH
97701: LD_INT 102
97703: PUSH
97704: LD_INT 103
97706: PUSH
97707: LD_INT 104
97709: PUSH
97710: LD_INT 105
97712: PUSH
97713: LD_INT 106
97715: PUSH
97716: LD_INT 107
97718: PUSH
97719: LD_INT 108
97721: PUSH
97722: LD_INT 109
97724: PUSH
97725: LD_INT 110
97727: PUSH
97728: LD_INT 111
97730: PUSH
97731: LD_INT 112
97733: PUSH
97734: LD_INT 114
97736: PUSH
97737: LD_INT 116
97739: PUSH
97740: LD_INT 117
97742: PUSH
97743: LD_INT 118
97745: PUSH
97746: EMPTY
97747: LIST
97748: LIST
97749: LIST
97750: LIST
97751: LIST
97752: LIST
97753: LIST
97754: LIST
97755: LIST
97756: LIST
97757: LIST
97758: LIST
97759: LIST
97760: LIST
97761: LIST
97762: LIST
97763: PUSH
97764: EMPTY
97765: LIST
97766: LIST
97767: ST_TO_ADDR
97768: GO 99663
97770: LD_INT 11
97772: DOUBLE
97773: EQUAL
97774: IFTRUE 97778
97776: GO 97982
97778: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
97779: LD_ADDR_VAR 0 2
97783: PUSH
97784: LD_INT 2
97786: PUSH
97787: LD_INT 3
97789: PUSH
97790: LD_INT 4
97792: PUSH
97793: LD_INT 5
97795: PUSH
97796: LD_INT 6
97798: PUSH
97799: LD_INT 7
97801: PUSH
97802: LD_INT 8
97804: PUSH
97805: LD_INT 9
97807: PUSH
97808: LD_INT 10
97810: PUSH
97811: LD_INT 11
97813: PUSH
97814: LD_INT 12
97816: PUSH
97817: LD_INT 13
97819: PUSH
97820: LD_INT 14
97822: PUSH
97823: LD_INT 15
97825: PUSH
97826: LD_INT 16
97828: PUSH
97829: LD_INT 17
97831: PUSH
97832: LD_INT 18
97834: PUSH
97835: LD_INT 19
97837: PUSH
97838: LD_INT 20
97840: PUSH
97841: LD_INT 21
97843: PUSH
97844: LD_INT 22
97846: PUSH
97847: LD_INT 23
97849: PUSH
97850: LD_INT 24
97852: PUSH
97853: LD_INT 25
97855: PUSH
97856: LD_INT 26
97858: PUSH
97859: LD_INT 28
97861: PUSH
97862: LD_INT 30
97864: PUSH
97865: LD_INT 31
97867: PUSH
97868: LD_INT 32
97870: PUSH
97871: LD_INT 34
97873: PUSH
97874: LD_INT 36
97876: PUSH
97877: EMPTY
97878: LIST
97879: LIST
97880: LIST
97881: LIST
97882: LIST
97883: LIST
97884: LIST
97885: LIST
97886: LIST
97887: LIST
97888: LIST
97889: LIST
97890: LIST
97891: LIST
97892: LIST
97893: LIST
97894: LIST
97895: LIST
97896: LIST
97897: LIST
97898: LIST
97899: LIST
97900: LIST
97901: LIST
97902: LIST
97903: LIST
97904: LIST
97905: LIST
97906: LIST
97907: LIST
97908: LIST
97909: PUSH
97910: LD_INT 101
97912: PUSH
97913: LD_INT 102
97915: PUSH
97916: LD_INT 103
97918: PUSH
97919: LD_INT 104
97921: PUSH
97922: LD_INT 105
97924: PUSH
97925: LD_INT 106
97927: PUSH
97928: LD_INT 107
97930: PUSH
97931: LD_INT 108
97933: PUSH
97934: LD_INT 109
97936: PUSH
97937: LD_INT 110
97939: PUSH
97940: LD_INT 111
97942: PUSH
97943: LD_INT 112
97945: PUSH
97946: LD_INT 114
97948: PUSH
97949: LD_INT 116
97951: PUSH
97952: LD_INT 117
97954: PUSH
97955: LD_INT 118
97957: PUSH
97958: EMPTY
97959: LIST
97960: LIST
97961: LIST
97962: LIST
97963: LIST
97964: LIST
97965: LIST
97966: LIST
97967: LIST
97968: LIST
97969: LIST
97970: LIST
97971: LIST
97972: LIST
97973: LIST
97974: LIST
97975: PUSH
97976: EMPTY
97977: LIST
97978: LIST
97979: ST_TO_ADDR
97980: GO 99663
97982: LD_INT 12
97984: DOUBLE
97985: EQUAL
97986: IFTRUE 97990
97988: GO 98210
97990: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
97991: LD_ADDR_VAR 0 2
97995: PUSH
97996: LD_INT 1
97998: PUSH
97999: LD_INT 2
98001: PUSH
98002: LD_INT 3
98004: PUSH
98005: LD_INT 4
98007: PUSH
98008: LD_INT 5
98010: PUSH
98011: LD_INT 6
98013: PUSH
98014: LD_INT 7
98016: PUSH
98017: LD_INT 8
98019: PUSH
98020: LD_INT 9
98022: PUSH
98023: LD_INT 10
98025: PUSH
98026: LD_INT 11
98028: PUSH
98029: LD_INT 12
98031: PUSH
98032: LD_INT 13
98034: PUSH
98035: LD_INT 14
98037: PUSH
98038: LD_INT 15
98040: PUSH
98041: LD_INT 16
98043: PUSH
98044: LD_INT 17
98046: PUSH
98047: LD_INT 18
98049: PUSH
98050: LD_INT 19
98052: PUSH
98053: LD_INT 20
98055: PUSH
98056: LD_INT 21
98058: PUSH
98059: LD_INT 22
98061: PUSH
98062: LD_INT 23
98064: PUSH
98065: LD_INT 24
98067: PUSH
98068: LD_INT 25
98070: PUSH
98071: LD_INT 26
98073: PUSH
98074: LD_INT 27
98076: PUSH
98077: LD_INT 28
98079: PUSH
98080: LD_INT 30
98082: PUSH
98083: LD_INT 31
98085: PUSH
98086: LD_INT 32
98088: PUSH
98089: LD_INT 33
98091: PUSH
98092: LD_INT 34
98094: PUSH
98095: LD_INT 36
98097: PUSH
98098: EMPTY
98099: LIST
98100: LIST
98101: LIST
98102: LIST
98103: LIST
98104: LIST
98105: LIST
98106: LIST
98107: LIST
98108: LIST
98109: LIST
98110: LIST
98111: LIST
98112: LIST
98113: LIST
98114: LIST
98115: LIST
98116: LIST
98117: LIST
98118: LIST
98119: LIST
98120: LIST
98121: LIST
98122: LIST
98123: LIST
98124: LIST
98125: LIST
98126: LIST
98127: LIST
98128: LIST
98129: LIST
98130: LIST
98131: LIST
98132: LIST
98133: PUSH
98134: LD_INT 101
98136: PUSH
98137: LD_INT 102
98139: PUSH
98140: LD_INT 103
98142: PUSH
98143: LD_INT 104
98145: PUSH
98146: LD_INT 105
98148: PUSH
98149: LD_INT 106
98151: PUSH
98152: LD_INT 107
98154: PUSH
98155: LD_INT 108
98157: PUSH
98158: LD_INT 109
98160: PUSH
98161: LD_INT 110
98163: PUSH
98164: LD_INT 111
98166: PUSH
98167: LD_INT 112
98169: PUSH
98170: LD_INT 113
98172: PUSH
98173: LD_INT 114
98175: PUSH
98176: LD_INT 116
98178: PUSH
98179: LD_INT 117
98181: PUSH
98182: LD_INT 118
98184: PUSH
98185: EMPTY
98186: LIST
98187: LIST
98188: LIST
98189: LIST
98190: LIST
98191: LIST
98192: LIST
98193: LIST
98194: LIST
98195: LIST
98196: LIST
98197: LIST
98198: LIST
98199: LIST
98200: LIST
98201: LIST
98202: LIST
98203: PUSH
98204: EMPTY
98205: LIST
98206: LIST
98207: ST_TO_ADDR
98208: GO 99663
98210: LD_INT 13
98212: DOUBLE
98213: EQUAL
98214: IFTRUE 98218
98216: GO 98426
98218: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
98219: LD_ADDR_VAR 0 2
98223: PUSH
98224: LD_INT 1
98226: PUSH
98227: LD_INT 2
98229: PUSH
98230: LD_INT 3
98232: PUSH
98233: LD_INT 4
98235: PUSH
98236: LD_INT 5
98238: PUSH
98239: LD_INT 8
98241: PUSH
98242: LD_INT 9
98244: PUSH
98245: LD_INT 10
98247: PUSH
98248: LD_INT 11
98250: PUSH
98251: LD_INT 12
98253: PUSH
98254: LD_INT 14
98256: PUSH
98257: LD_INT 15
98259: PUSH
98260: LD_INT 16
98262: PUSH
98263: LD_INT 17
98265: PUSH
98266: LD_INT 18
98268: PUSH
98269: LD_INT 19
98271: PUSH
98272: LD_INT 20
98274: PUSH
98275: LD_INT 21
98277: PUSH
98278: LD_INT 22
98280: PUSH
98281: LD_INT 23
98283: PUSH
98284: LD_INT 24
98286: PUSH
98287: LD_INT 25
98289: PUSH
98290: LD_INT 26
98292: PUSH
98293: LD_INT 27
98295: PUSH
98296: LD_INT 28
98298: PUSH
98299: LD_INT 30
98301: PUSH
98302: LD_INT 31
98304: PUSH
98305: LD_INT 32
98307: PUSH
98308: LD_INT 33
98310: PUSH
98311: LD_INT 34
98313: PUSH
98314: LD_INT 36
98316: PUSH
98317: EMPTY
98318: LIST
98319: LIST
98320: LIST
98321: LIST
98322: LIST
98323: LIST
98324: LIST
98325: LIST
98326: LIST
98327: LIST
98328: LIST
98329: LIST
98330: LIST
98331: LIST
98332: LIST
98333: LIST
98334: LIST
98335: LIST
98336: LIST
98337: LIST
98338: LIST
98339: LIST
98340: LIST
98341: LIST
98342: LIST
98343: LIST
98344: LIST
98345: LIST
98346: LIST
98347: LIST
98348: LIST
98349: PUSH
98350: LD_INT 101
98352: PUSH
98353: LD_INT 102
98355: PUSH
98356: LD_INT 103
98358: PUSH
98359: LD_INT 104
98361: PUSH
98362: LD_INT 105
98364: PUSH
98365: LD_INT 106
98367: PUSH
98368: LD_INT 107
98370: PUSH
98371: LD_INT 108
98373: PUSH
98374: LD_INT 109
98376: PUSH
98377: LD_INT 110
98379: PUSH
98380: LD_INT 111
98382: PUSH
98383: LD_INT 112
98385: PUSH
98386: LD_INT 113
98388: PUSH
98389: LD_INT 114
98391: PUSH
98392: LD_INT 116
98394: PUSH
98395: LD_INT 117
98397: PUSH
98398: LD_INT 118
98400: PUSH
98401: EMPTY
98402: LIST
98403: LIST
98404: LIST
98405: LIST
98406: LIST
98407: LIST
98408: LIST
98409: LIST
98410: LIST
98411: LIST
98412: LIST
98413: LIST
98414: LIST
98415: LIST
98416: LIST
98417: LIST
98418: LIST
98419: PUSH
98420: EMPTY
98421: LIST
98422: LIST
98423: ST_TO_ADDR
98424: GO 99663
98426: LD_INT 14
98428: DOUBLE
98429: EQUAL
98430: IFTRUE 98434
98432: GO 98658
98434: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
98435: LD_ADDR_VAR 0 2
98439: PUSH
98440: LD_INT 1
98442: PUSH
98443: LD_INT 2
98445: PUSH
98446: LD_INT 3
98448: PUSH
98449: LD_INT 4
98451: PUSH
98452: LD_INT 5
98454: PUSH
98455: LD_INT 6
98457: PUSH
98458: LD_INT 7
98460: PUSH
98461: LD_INT 8
98463: PUSH
98464: LD_INT 9
98466: PUSH
98467: LD_INT 10
98469: PUSH
98470: LD_INT 11
98472: PUSH
98473: LD_INT 12
98475: PUSH
98476: LD_INT 13
98478: PUSH
98479: LD_INT 14
98481: PUSH
98482: LD_INT 15
98484: PUSH
98485: LD_INT 16
98487: PUSH
98488: LD_INT 17
98490: PUSH
98491: LD_INT 18
98493: PUSH
98494: LD_INT 19
98496: PUSH
98497: LD_INT 20
98499: PUSH
98500: LD_INT 21
98502: PUSH
98503: LD_INT 22
98505: PUSH
98506: LD_INT 23
98508: PUSH
98509: LD_INT 24
98511: PUSH
98512: LD_INT 25
98514: PUSH
98515: LD_INT 26
98517: PUSH
98518: LD_INT 27
98520: PUSH
98521: LD_INT 28
98523: PUSH
98524: LD_INT 29
98526: PUSH
98527: LD_INT 30
98529: PUSH
98530: LD_INT 31
98532: PUSH
98533: LD_INT 32
98535: PUSH
98536: LD_INT 33
98538: PUSH
98539: LD_INT 34
98541: PUSH
98542: LD_INT 36
98544: PUSH
98545: EMPTY
98546: LIST
98547: LIST
98548: LIST
98549: LIST
98550: LIST
98551: LIST
98552: LIST
98553: LIST
98554: LIST
98555: LIST
98556: LIST
98557: LIST
98558: LIST
98559: LIST
98560: LIST
98561: LIST
98562: LIST
98563: LIST
98564: LIST
98565: LIST
98566: LIST
98567: LIST
98568: LIST
98569: LIST
98570: LIST
98571: LIST
98572: LIST
98573: LIST
98574: LIST
98575: LIST
98576: LIST
98577: LIST
98578: LIST
98579: LIST
98580: LIST
98581: PUSH
98582: LD_INT 101
98584: PUSH
98585: LD_INT 102
98587: PUSH
98588: LD_INT 103
98590: PUSH
98591: LD_INT 104
98593: PUSH
98594: LD_INT 105
98596: PUSH
98597: LD_INT 106
98599: PUSH
98600: LD_INT 107
98602: PUSH
98603: LD_INT 108
98605: PUSH
98606: LD_INT 109
98608: PUSH
98609: LD_INT 110
98611: PUSH
98612: LD_INT 111
98614: PUSH
98615: LD_INT 112
98617: PUSH
98618: LD_INT 113
98620: PUSH
98621: LD_INT 114
98623: PUSH
98624: LD_INT 116
98626: PUSH
98627: LD_INT 117
98629: PUSH
98630: LD_INT 118
98632: PUSH
98633: EMPTY
98634: LIST
98635: LIST
98636: LIST
98637: LIST
98638: LIST
98639: LIST
98640: LIST
98641: LIST
98642: LIST
98643: LIST
98644: LIST
98645: LIST
98646: LIST
98647: LIST
98648: LIST
98649: LIST
98650: LIST
98651: PUSH
98652: EMPTY
98653: LIST
98654: LIST
98655: ST_TO_ADDR
98656: GO 99663
98658: LD_INT 15
98660: DOUBLE
98661: EQUAL
98662: IFTRUE 98666
98664: GO 98890
98666: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
98667: LD_ADDR_VAR 0 2
98671: PUSH
98672: LD_INT 1
98674: PUSH
98675: LD_INT 2
98677: PUSH
98678: LD_INT 3
98680: PUSH
98681: LD_INT 4
98683: PUSH
98684: LD_INT 5
98686: PUSH
98687: LD_INT 6
98689: PUSH
98690: LD_INT 7
98692: PUSH
98693: LD_INT 8
98695: PUSH
98696: LD_INT 9
98698: PUSH
98699: LD_INT 10
98701: PUSH
98702: LD_INT 11
98704: PUSH
98705: LD_INT 12
98707: PUSH
98708: LD_INT 13
98710: PUSH
98711: LD_INT 14
98713: PUSH
98714: LD_INT 15
98716: PUSH
98717: LD_INT 16
98719: PUSH
98720: LD_INT 17
98722: PUSH
98723: LD_INT 18
98725: PUSH
98726: LD_INT 19
98728: PUSH
98729: LD_INT 20
98731: PUSH
98732: LD_INT 21
98734: PUSH
98735: LD_INT 22
98737: PUSH
98738: LD_INT 23
98740: PUSH
98741: LD_INT 24
98743: PUSH
98744: LD_INT 25
98746: PUSH
98747: LD_INT 26
98749: PUSH
98750: LD_INT 27
98752: PUSH
98753: LD_INT 28
98755: PUSH
98756: LD_INT 29
98758: PUSH
98759: LD_INT 30
98761: PUSH
98762: LD_INT 31
98764: PUSH
98765: LD_INT 32
98767: PUSH
98768: LD_INT 33
98770: PUSH
98771: LD_INT 34
98773: PUSH
98774: LD_INT 36
98776: PUSH
98777: EMPTY
98778: LIST
98779: LIST
98780: LIST
98781: LIST
98782: LIST
98783: LIST
98784: LIST
98785: LIST
98786: LIST
98787: LIST
98788: LIST
98789: LIST
98790: LIST
98791: LIST
98792: LIST
98793: LIST
98794: LIST
98795: LIST
98796: LIST
98797: LIST
98798: LIST
98799: LIST
98800: LIST
98801: LIST
98802: LIST
98803: LIST
98804: LIST
98805: LIST
98806: LIST
98807: LIST
98808: LIST
98809: LIST
98810: LIST
98811: LIST
98812: LIST
98813: PUSH
98814: LD_INT 101
98816: PUSH
98817: LD_INT 102
98819: PUSH
98820: LD_INT 103
98822: PUSH
98823: LD_INT 104
98825: PUSH
98826: LD_INT 105
98828: PUSH
98829: LD_INT 106
98831: PUSH
98832: LD_INT 107
98834: PUSH
98835: LD_INT 108
98837: PUSH
98838: LD_INT 109
98840: PUSH
98841: LD_INT 110
98843: PUSH
98844: LD_INT 111
98846: PUSH
98847: LD_INT 112
98849: PUSH
98850: LD_INT 113
98852: PUSH
98853: LD_INT 114
98855: PUSH
98856: LD_INT 116
98858: PUSH
98859: LD_INT 117
98861: PUSH
98862: LD_INT 118
98864: PUSH
98865: EMPTY
98866: LIST
98867: LIST
98868: LIST
98869: LIST
98870: LIST
98871: LIST
98872: LIST
98873: LIST
98874: LIST
98875: LIST
98876: LIST
98877: LIST
98878: LIST
98879: LIST
98880: LIST
98881: LIST
98882: LIST
98883: PUSH
98884: EMPTY
98885: LIST
98886: LIST
98887: ST_TO_ADDR
98888: GO 99663
98890: LD_INT 16
98892: DOUBLE
98893: EQUAL
98894: IFTRUE 98898
98896: GO 99034
98898: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
98899: LD_ADDR_VAR 0 2
98903: PUSH
98904: LD_INT 2
98906: PUSH
98907: LD_INT 4
98909: PUSH
98910: LD_INT 5
98912: PUSH
98913: LD_INT 7
98915: PUSH
98916: LD_INT 11
98918: PUSH
98919: LD_INT 12
98921: PUSH
98922: LD_INT 15
98924: PUSH
98925: LD_INT 16
98927: PUSH
98928: LD_INT 20
98930: PUSH
98931: LD_INT 21
98933: PUSH
98934: LD_INT 22
98936: PUSH
98937: LD_INT 23
98939: PUSH
98940: LD_INT 25
98942: PUSH
98943: LD_INT 26
98945: PUSH
98946: LD_INT 30
98948: PUSH
98949: LD_INT 31
98951: PUSH
98952: LD_INT 32
98954: PUSH
98955: LD_INT 33
98957: PUSH
98958: LD_INT 34
98960: PUSH
98961: EMPTY
98962: LIST
98963: LIST
98964: LIST
98965: LIST
98966: LIST
98967: LIST
98968: LIST
98969: LIST
98970: LIST
98971: LIST
98972: LIST
98973: LIST
98974: LIST
98975: LIST
98976: LIST
98977: LIST
98978: LIST
98979: LIST
98980: LIST
98981: PUSH
98982: LD_INT 101
98984: PUSH
98985: LD_INT 102
98987: PUSH
98988: LD_INT 103
98990: PUSH
98991: LD_INT 106
98993: PUSH
98994: LD_INT 108
98996: PUSH
98997: LD_INT 112
98999: PUSH
99000: LD_INT 113
99002: PUSH
99003: LD_INT 114
99005: PUSH
99006: LD_INT 116
99008: PUSH
99009: LD_INT 117
99011: PUSH
99012: LD_INT 118
99014: PUSH
99015: EMPTY
99016: LIST
99017: LIST
99018: LIST
99019: LIST
99020: LIST
99021: LIST
99022: LIST
99023: LIST
99024: LIST
99025: LIST
99026: LIST
99027: PUSH
99028: EMPTY
99029: LIST
99030: LIST
99031: ST_TO_ADDR
99032: GO 99663
99034: LD_INT 17
99036: DOUBLE
99037: EQUAL
99038: IFTRUE 99042
99040: GO 99266
99042: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
99043: LD_ADDR_VAR 0 2
99047: PUSH
99048: LD_INT 1
99050: PUSH
99051: LD_INT 2
99053: PUSH
99054: LD_INT 3
99056: PUSH
99057: LD_INT 4
99059: PUSH
99060: LD_INT 5
99062: PUSH
99063: LD_INT 6
99065: PUSH
99066: LD_INT 7
99068: PUSH
99069: LD_INT 8
99071: PUSH
99072: LD_INT 9
99074: PUSH
99075: LD_INT 10
99077: PUSH
99078: LD_INT 11
99080: PUSH
99081: LD_INT 12
99083: PUSH
99084: LD_INT 13
99086: PUSH
99087: LD_INT 14
99089: PUSH
99090: LD_INT 15
99092: PUSH
99093: LD_INT 16
99095: PUSH
99096: LD_INT 17
99098: PUSH
99099: LD_INT 18
99101: PUSH
99102: LD_INT 19
99104: PUSH
99105: LD_INT 20
99107: PUSH
99108: LD_INT 21
99110: PUSH
99111: LD_INT 22
99113: PUSH
99114: LD_INT 23
99116: PUSH
99117: LD_INT 24
99119: PUSH
99120: LD_INT 25
99122: PUSH
99123: LD_INT 26
99125: PUSH
99126: LD_INT 27
99128: PUSH
99129: LD_INT 28
99131: PUSH
99132: LD_INT 29
99134: PUSH
99135: LD_INT 30
99137: PUSH
99138: LD_INT 31
99140: PUSH
99141: LD_INT 32
99143: PUSH
99144: LD_INT 33
99146: PUSH
99147: LD_INT 34
99149: PUSH
99150: LD_INT 36
99152: PUSH
99153: EMPTY
99154: LIST
99155: LIST
99156: LIST
99157: LIST
99158: LIST
99159: LIST
99160: LIST
99161: LIST
99162: LIST
99163: LIST
99164: LIST
99165: LIST
99166: LIST
99167: LIST
99168: LIST
99169: LIST
99170: LIST
99171: LIST
99172: LIST
99173: LIST
99174: LIST
99175: LIST
99176: LIST
99177: LIST
99178: LIST
99179: LIST
99180: LIST
99181: LIST
99182: LIST
99183: LIST
99184: LIST
99185: LIST
99186: LIST
99187: LIST
99188: LIST
99189: PUSH
99190: LD_INT 101
99192: PUSH
99193: LD_INT 102
99195: PUSH
99196: LD_INT 103
99198: PUSH
99199: LD_INT 104
99201: PUSH
99202: LD_INT 105
99204: PUSH
99205: LD_INT 106
99207: PUSH
99208: LD_INT 107
99210: PUSH
99211: LD_INT 108
99213: PUSH
99214: LD_INT 109
99216: PUSH
99217: LD_INT 110
99219: PUSH
99220: LD_INT 111
99222: PUSH
99223: LD_INT 112
99225: PUSH
99226: LD_INT 113
99228: PUSH
99229: LD_INT 114
99231: PUSH
99232: LD_INT 116
99234: PUSH
99235: LD_INT 117
99237: PUSH
99238: LD_INT 118
99240: PUSH
99241: EMPTY
99242: LIST
99243: LIST
99244: LIST
99245: LIST
99246: LIST
99247: LIST
99248: LIST
99249: LIST
99250: LIST
99251: LIST
99252: LIST
99253: LIST
99254: LIST
99255: LIST
99256: LIST
99257: LIST
99258: LIST
99259: PUSH
99260: EMPTY
99261: LIST
99262: LIST
99263: ST_TO_ADDR
99264: GO 99663
99266: LD_INT 18
99268: DOUBLE
99269: EQUAL
99270: IFTRUE 99274
99272: GO 99422
99274: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
99275: LD_ADDR_VAR 0 2
99279: PUSH
99280: LD_INT 2
99282: PUSH
99283: LD_INT 4
99285: PUSH
99286: LD_INT 5
99288: PUSH
99289: LD_INT 7
99291: PUSH
99292: LD_INT 11
99294: PUSH
99295: LD_INT 12
99297: PUSH
99298: LD_INT 15
99300: PUSH
99301: LD_INT 16
99303: PUSH
99304: LD_INT 20
99306: PUSH
99307: LD_INT 21
99309: PUSH
99310: LD_INT 22
99312: PUSH
99313: LD_INT 23
99315: PUSH
99316: LD_INT 25
99318: PUSH
99319: LD_INT 26
99321: PUSH
99322: LD_INT 30
99324: PUSH
99325: LD_INT 31
99327: PUSH
99328: LD_INT 32
99330: PUSH
99331: LD_INT 33
99333: PUSH
99334: LD_INT 34
99336: PUSH
99337: LD_INT 35
99339: PUSH
99340: LD_INT 36
99342: PUSH
99343: EMPTY
99344: LIST
99345: LIST
99346: LIST
99347: LIST
99348: LIST
99349: LIST
99350: LIST
99351: LIST
99352: LIST
99353: LIST
99354: LIST
99355: LIST
99356: LIST
99357: LIST
99358: LIST
99359: LIST
99360: LIST
99361: LIST
99362: LIST
99363: LIST
99364: LIST
99365: PUSH
99366: LD_INT 101
99368: PUSH
99369: LD_INT 102
99371: PUSH
99372: LD_INT 103
99374: PUSH
99375: LD_INT 106
99377: PUSH
99378: LD_INT 108
99380: PUSH
99381: LD_INT 112
99383: PUSH
99384: LD_INT 113
99386: PUSH
99387: LD_INT 114
99389: PUSH
99390: LD_INT 115
99392: PUSH
99393: LD_INT 116
99395: PUSH
99396: LD_INT 117
99398: PUSH
99399: LD_INT 118
99401: PUSH
99402: EMPTY
99403: LIST
99404: LIST
99405: LIST
99406: LIST
99407: LIST
99408: LIST
99409: LIST
99410: LIST
99411: LIST
99412: LIST
99413: LIST
99414: LIST
99415: PUSH
99416: EMPTY
99417: LIST
99418: LIST
99419: ST_TO_ADDR
99420: GO 99663
99422: LD_INT 19
99424: DOUBLE
99425: EQUAL
99426: IFTRUE 99430
99428: GO 99662
99430: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
99431: LD_ADDR_VAR 0 2
99435: PUSH
99436: LD_INT 1
99438: PUSH
99439: LD_INT 2
99441: PUSH
99442: LD_INT 3
99444: PUSH
99445: LD_INT 4
99447: PUSH
99448: LD_INT 5
99450: PUSH
99451: LD_INT 6
99453: PUSH
99454: LD_INT 7
99456: PUSH
99457: LD_INT 8
99459: PUSH
99460: LD_INT 9
99462: PUSH
99463: LD_INT 10
99465: PUSH
99466: LD_INT 11
99468: PUSH
99469: LD_INT 12
99471: PUSH
99472: LD_INT 13
99474: PUSH
99475: LD_INT 14
99477: PUSH
99478: LD_INT 15
99480: PUSH
99481: LD_INT 16
99483: PUSH
99484: LD_INT 17
99486: PUSH
99487: LD_INT 18
99489: PUSH
99490: LD_INT 19
99492: PUSH
99493: LD_INT 20
99495: PUSH
99496: LD_INT 21
99498: PUSH
99499: LD_INT 22
99501: PUSH
99502: LD_INT 23
99504: PUSH
99505: LD_INT 24
99507: PUSH
99508: LD_INT 25
99510: PUSH
99511: LD_INT 26
99513: PUSH
99514: LD_INT 27
99516: PUSH
99517: LD_INT 28
99519: PUSH
99520: LD_INT 29
99522: PUSH
99523: LD_INT 30
99525: PUSH
99526: LD_INT 31
99528: PUSH
99529: LD_INT 32
99531: PUSH
99532: LD_INT 33
99534: PUSH
99535: LD_INT 34
99537: PUSH
99538: LD_INT 35
99540: PUSH
99541: LD_INT 36
99543: PUSH
99544: EMPTY
99545: LIST
99546: LIST
99547: LIST
99548: LIST
99549: LIST
99550: LIST
99551: LIST
99552: LIST
99553: LIST
99554: LIST
99555: LIST
99556: LIST
99557: LIST
99558: LIST
99559: LIST
99560: LIST
99561: LIST
99562: LIST
99563: LIST
99564: LIST
99565: LIST
99566: LIST
99567: LIST
99568: LIST
99569: LIST
99570: LIST
99571: LIST
99572: LIST
99573: LIST
99574: LIST
99575: LIST
99576: LIST
99577: LIST
99578: LIST
99579: LIST
99580: LIST
99581: PUSH
99582: LD_INT 101
99584: PUSH
99585: LD_INT 102
99587: PUSH
99588: LD_INT 103
99590: PUSH
99591: LD_INT 104
99593: PUSH
99594: LD_INT 105
99596: PUSH
99597: LD_INT 106
99599: PUSH
99600: LD_INT 107
99602: PUSH
99603: LD_INT 108
99605: PUSH
99606: LD_INT 109
99608: PUSH
99609: LD_INT 110
99611: PUSH
99612: LD_INT 111
99614: PUSH
99615: LD_INT 112
99617: PUSH
99618: LD_INT 113
99620: PUSH
99621: LD_INT 114
99623: PUSH
99624: LD_INT 115
99626: PUSH
99627: LD_INT 116
99629: PUSH
99630: LD_INT 117
99632: PUSH
99633: LD_INT 118
99635: PUSH
99636: EMPTY
99637: LIST
99638: LIST
99639: LIST
99640: LIST
99641: LIST
99642: LIST
99643: LIST
99644: LIST
99645: LIST
99646: LIST
99647: LIST
99648: LIST
99649: LIST
99650: LIST
99651: LIST
99652: LIST
99653: LIST
99654: LIST
99655: PUSH
99656: EMPTY
99657: LIST
99658: LIST
99659: ST_TO_ADDR
99660: GO 99663
99662: POP
// end else
99663: GO 99894
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
99665: LD_ADDR_VAR 0 2
99669: PUSH
99670: LD_INT 1
99672: PUSH
99673: LD_INT 2
99675: PUSH
99676: LD_INT 3
99678: PUSH
99679: LD_INT 4
99681: PUSH
99682: LD_INT 5
99684: PUSH
99685: LD_INT 6
99687: PUSH
99688: LD_INT 7
99690: PUSH
99691: LD_INT 8
99693: PUSH
99694: LD_INT 9
99696: PUSH
99697: LD_INT 10
99699: PUSH
99700: LD_INT 11
99702: PUSH
99703: LD_INT 12
99705: PUSH
99706: LD_INT 13
99708: PUSH
99709: LD_INT 14
99711: PUSH
99712: LD_INT 15
99714: PUSH
99715: LD_INT 16
99717: PUSH
99718: LD_INT 17
99720: PUSH
99721: LD_INT 18
99723: PUSH
99724: LD_INT 19
99726: PUSH
99727: LD_INT 20
99729: PUSH
99730: LD_INT 21
99732: PUSH
99733: LD_INT 22
99735: PUSH
99736: LD_INT 23
99738: PUSH
99739: LD_INT 24
99741: PUSH
99742: LD_INT 25
99744: PUSH
99745: LD_INT 26
99747: PUSH
99748: LD_INT 27
99750: PUSH
99751: LD_INT 28
99753: PUSH
99754: LD_INT 29
99756: PUSH
99757: LD_INT 30
99759: PUSH
99760: LD_INT 31
99762: PUSH
99763: LD_INT 32
99765: PUSH
99766: LD_INT 33
99768: PUSH
99769: LD_INT 34
99771: PUSH
99772: LD_INT 35
99774: PUSH
99775: LD_INT 36
99777: PUSH
99778: EMPTY
99779: LIST
99780: LIST
99781: LIST
99782: LIST
99783: LIST
99784: LIST
99785: LIST
99786: LIST
99787: LIST
99788: LIST
99789: LIST
99790: LIST
99791: LIST
99792: LIST
99793: LIST
99794: LIST
99795: LIST
99796: LIST
99797: LIST
99798: LIST
99799: LIST
99800: LIST
99801: LIST
99802: LIST
99803: LIST
99804: LIST
99805: LIST
99806: LIST
99807: LIST
99808: LIST
99809: LIST
99810: LIST
99811: LIST
99812: LIST
99813: LIST
99814: LIST
99815: PUSH
99816: LD_INT 101
99818: PUSH
99819: LD_INT 102
99821: PUSH
99822: LD_INT 103
99824: PUSH
99825: LD_INT 104
99827: PUSH
99828: LD_INT 105
99830: PUSH
99831: LD_INT 106
99833: PUSH
99834: LD_INT 107
99836: PUSH
99837: LD_INT 108
99839: PUSH
99840: LD_INT 109
99842: PUSH
99843: LD_INT 110
99845: PUSH
99846: LD_INT 111
99848: PUSH
99849: LD_INT 112
99851: PUSH
99852: LD_INT 113
99854: PUSH
99855: LD_INT 114
99857: PUSH
99858: LD_INT 115
99860: PUSH
99861: LD_INT 116
99863: PUSH
99864: LD_INT 117
99866: PUSH
99867: LD_INT 118
99869: PUSH
99870: EMPTY
99871: LIST
99872: LIST
99873: LIST
99874: LIST
99875: LIST
99876: LIST
99877: LIST
99878: LIST
99879: LIST
99880: LIST
99881: LIST
99882: LIST
99883: LIST
99884: LIST
99885: LIST
99886: LIST
99887: LIST
99888: LIST
99889: PUSH
99890: EMPTY
99891: LIST
99892: LIST
99893: ST_TO_ADDR
// if result then
99894: LD_VAR 0 2
99898: IFFALSE 100684
// begin normal :=  ;
99900: LD_ADDR_VAR 0 5
99904: PUSH
99905: LD_STRING 
99907: ST_TO_ADDR
// hardcore :=  ;
99908: LD_ADDR_VAR 0 6
99912: PUSH
99913: LD_STRING 
99915: ST_TO_ADDR
// active :=  ;
99916: LD_ADDR_VAR 0 7
99920: PUSH
99921: LD_STRING 
99923: ST_TO_ADDR
// for i = 1 to normalCounter do
99924: LD_ADDR_VAR 0 8
99928: PUSH
99929: DOUBLE
99930: LD_INT 1
99932: DEC
99933: ST_TO_ADDR
99934: LD_EXP 78
99938: PUSH
99939: FOR_TO
99940: IFFALSE 100041
// begin tmp := 0 ;
99942: LD_ADDR_VAR 0 3
99946: PUSH
99947: LD_STRING 0
99949: ST_TO_ADDR
// if result [ 1 ] then
99950: LD_VAR 0 2
99954: PUSH
99955: LD_INT 1
99957: ARRAY
99958: IFFALSE 100023
// if result [ 1 ] [ 1 ] = i then
99960: LD_VAR 0 2
99964: PUSH
99965: LD_INT 1
99967: ARRAY
99968: PUSH
99969: LD_INT 1
99971: ARRAY
99972: PUSH
99973: LD_VAR 0 8
99977: EQUAL
99978: IFFALSE 100023
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
99980: LD_ADDR_VAR 0 2
99984: PUSH
99985: LD_VAR 0 2
99989: PPUSH
99990: LD_INT 1
99992: PPUSH
99993: LD_VAR 0 2
99997: PUSH
99998: LD_INT 1
100000: ARRAY
100001: PPUSH
100002: LD_INT 1
100004: PPUSH
100005: CALL_OW 3
100009: PPUSH
100010: CALL_OW 1
100014: ST_TO_ADDR
// tmp := 1 ;
100015: LD_ADDR_VAR 0 3
100019: PUSH
100020: LD_STRING 1
100022: ST_TO_ADDR
// end ; normal := normal & tmp ;
100023: LD_ADDR_VAR 0 5
100027: PUSH
100028: LD_VAR 0 5
100032: PUSH
100033: LD_VAR 0 3
100037: STR
100038: ST_TO_ADDR
// end ;
100039: GO 99939
100041: POP
100042: POP
// for i = 1 to hardcoreCounter do
100043: LD_ADDR_VAR 0 8
100047: PUSH
100048: DOUBLE
100049: LD_INT 1
100051: DEC
100052: ST_TO_ADDR
100053: LD_EXP 79
100057: PUSH
100058: FOR_TO
100059: IFFALSE 100164
// begin tmp := 0 ;
100061: LD_ADDR_VAR 0 3
100065: PUSH
100066: LD_STRING 0
100068: ST_TO_ADDR
// if result [ 2 ] then
100069: LD_VAR 0 2
100073: PUSH
100074: LD_INT 2
100076: ARRAY
100077: IFFALSE 100146
// if result [ 2 ] [ 1 ] = 100 + i then
100079: LD_VAR 0 2
100083: PUSH
100084: LD_INT 2
100086: ARRAY
100087: PUSH
100088: LD_INT 1
100090: ARRAY
100091: PUSH
100092: LD_INT 100
100094: PUSH
100095: LD_VAR 0 8
100099: PLUS
100100: EQUAL
100101: IFFALSE 100146
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
100103: LD_ADDR_VAR 0 2
100107: PUSH
100108: LD_VAR 0 2
100112: PPUSH
100113: LD_INT 2
100115: PPUSH
100116: LD_VAR 0 2
100120: PUSH
100121: LD_INT 2
100123: ARRAY
100124: PPUSH
100125: LD_INT 1
100127: PPUSH
100128: CALL_OW 3
100132: PPUSH
100133: CALL_OW 1
100137: ST_TO_ADDR
// tmp := 1 ;
100138: LD_ADDR_VAR 0 3
100142: PUSH
100143: LD_STRING 1
100145: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
100146: LD_ADDR_VAR 0 6
100150: PUSH
100151: LD_VAR 0 6
100155: PUSH
100156: LD_VAR 0 3
100160: STR
100161: ST_TO_ADDR
// end ;
100162: GO 100058
100164: POP
100165: POP
// if isGameLoad then
100166: LD_VAR 0 1
100170: IFFALSE 100645
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
100172: LD_ADDR_VAR 0 4
100176: PUSH
100177: LD_EXP 82
100181: PUSH
100182: LD_EXP 81
100186: PUSH
100187: LD_EXP 83
100191: PUSH
100192: LD_EXP 80
100196: PUSH
100197: LD_EXP 84
100201: PUSH
100202: LD_EXP 85
100206: PUSH
100207: LD_EXP 86
100211: PUSH
100212: LD_EXP 87
100216: PUSH
100217: LD_EXP 88
100221: PUSH
100222: LD_EXP 89
100226: PUSH
100227: LD_EXP 90
100231: PUSH
100232: LD_EXP 91
100236: PUSH
100237: LD_EXP 92
100241: PUSH
100242: LD_EXP 93
100246: PUSH
100247: LD_EXP 101
100251: PUSH
100252: LD_EXP 102
100256: PUSH
100257: LD_EXP 103
100261: PUSH
100262: LD_EXP 104
100266: PUSH
100267: LD_EXP 106
100271: PUSH
100272: LD_EXP 107
100276: PUSH
100277: LD_EXP 108
100281: PUSH
100282: LD_EXP 111
100286: PUSH
100287: LD_EXP 113
100291: PUSH
100292: LD_EXP 114
100296: PUSH
100297: LD_EXP 115
100301: PUSH
100302: LD_EXP 117
100306: PUSH
100307: LD_EXP 118
100311: PUSH
100312: LD_EXP 121
100316: PUSH
100317: LD_EXP 122
100321: PUSH
100322: LD_EXP 123
100326: PUSH
100327: LD_EXP 124
100331: PUSH
100332: LD_EXP 125
100336: PUSH
100337: LD_EXP 126
100341: PUSH
100342: LD_EXP 127
100346: PUSH
100347: LD_EXP 128
100351: PUSH
100352: LD_EXP 129
100356: PUSH
100357: LD_EXP 94
100361: PUSH
100362: LD_EXP 95
100366: PUSH
100367: LD_EXP 98
100371: PUSH
100372: LD_EXP 99
100376: PUSH
100377: LD_EXP 100
100381: PUSH
100382: LD_EXP 96
100386: PUSH
100387: LD_EXP 97
100391: PUSH
100392: LD_EXP 105
100396: PUSH
100397: LD_EXP 109
100401: PUSH
100402: LD_EXP 110
100406: PUSH
100407: LD_EXP 112
100411: PUSH
100412: LD_EXP 116
100416: PUSH
100417: LD_EXP 119
100421: PUSH
100422: LD_EXP 120
100426: PUSH
100427: LD_EXP 130
100431: PUSH
100432: LD_EXP 131
100436: PUSH
100437: LD_EXP 132
100441: PUSH
100442: LD_EXP 133
100446: PUSH
100447: EMPTY
100448: LIST
100449: LIST
100450: LIST
100451: LIST
100452: LIST
100453: LIST
100454: LIST
100455: LIST
100456: LIST
100457: LIST
100458: LIST
100459: LIST
100460: LIST
100461: LIST
100462: LIST
100463: LIST
100464: LIST
100465: LIST
100466: LIST
100467: LIST
100468: LIST
100469: LIST
100470: LIST
100471: LIST
100472: LIST
100473: LIST
100474: LIST
100475: LIST
100476: LIST
100477: LIST
100478: LIST
100479: LIST
100480: LIST
100481: LIST
100482: LIST
100483: LIST
100484: LIST
100485: LIST
100486: LIST
100487: LIST
100488: LIST
100489: LIST
100490: LIST
100491: LIST
100492: LIST
100493: LIST
100494: LIST
100495: LIST
100496: LIST
100497: LIST
100498: LIST
100499: LIST
100500: LIST
100501: LIST
100502: ST_TO_ADDR
// tmp :=  ;
100503: LD_ADDR_VAR 0 3
100507: PUSH
100508: LD_STRING 
100510: ST_TO_ADDR
// for i = 1 to normalCounter do
100511: LD_ADDR_VAR 0 8
100515: PUSH
100516: DOUBLE
100517: LD_INT 1
100519: DEC
100520: ST_TO_ADDR
100521: LD_EXP 78
100525: PUSH
100526: FOR_TO
100527: IFFALSE 100563
// begin if flags [ i ] then
100529: LD_VAR 0 4
100533: PUSH
100534: LD_VAR 0 8
100538: ARRAY
100539: IFFALSE 100561
// tmp := tmp & i & ; ;
100541: LD_ADDR_VAR 0 3
100545: PUSH
100546: LD_VAR 0 3
100550: PUSH
100551: LD_VAR 0 8
100555: STR
100556: PUSH
100557: LD_STRING ;
100559: STR
100560: ST_TO_ADDR
// end ;
100561: GO 100526
100563: POP
100564: POP
// for i = 1 to hardcoreCounter do
100565: LD_ADDR_VAR 0 8
100569: PUSH
100570: DOUBLE
100571: LD_INT 1
100573: DEC
100574: ST_TO_ADDR
100575: LD_EXP 79
100579: PUSH
100580: FOR_TO
100581: IFFALSE 100627
// begin if flags [ normalCounter + i ] then
100583: LD_VAR 0 4
100587: PUSH
100588: LD_EXP 78
100592: PUSH
100593: LD_VAR 0 8
100597: PLUS
100598: ARRAY
100599: IFFALSE 100625
// tmp := tmp & ( 100 + i ) & ; ;
100601: LD_ADDR_VAR 0 3
100605: PUSH
100606: LD_VAR 0 3
100610: PUSH
100611: LD_INT 100
100613: PUSH
100614: LD_VAR 0 8
100618: PLUS
100619: STR
100620: PUSH
100621: LD_STRING ;
100623: STR
100624: ST_TO_ADDR
// end ;
100625: GO 100580
100627: POP
100628: POP
// if tmp then
100629: LD_VAR 0 3
100633: IFFALSE 100645
// active := tmp ;
100635: LD_ADDR_VAR 0 7
100639: PUSH
100640: LD_VAR 0 3
100644: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
100645: LD_STRING getStreamItemsFromMission("
100647: PUSH
100648: LD_VAR 0 5
100652: STR
100653: PUSH
100654: LD_STRING ","
100656: STR
100657: PUSH
100658: LD_VAR 0 6
100662: STR
100663: PUSH
100664: LD_STRING ","
100666: STR
100667: PUSH
100668: LD_VAR 0 7
100672: STR
100673: PUSH
100674: LD_STRING ")
100676: STR
100677: PPUSH
100678: CALL_OW 559
// end else
100682: GO 100691
// ToLua ( getStreamItemsFromMission("","","") ) ;
100684: LD_STRING getStreamItemsFromMission("","","")
100686: PPUSH
100687: CALL_OW 559
// end ;
100691: LD_VAR 0 2
100695: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
100696: LD_EXP 77
100700: PUSH
100701: LD_EXP 82
100705: AND
100706: IFFALSE 100830
100708: GO 100710
100710: DISABLE
100711: LD_INT 0
100713: PPUSH
100714: PPUSH
// begin enable ;
100715: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
100716: LD_ADDR_VAR 0 2
100720: PUSH
100721: LD_INT 22
100723: PUSH
100724: LD_OWVAR 2
100728: PUSH
100729: EMPTY
100730: LIST
100731: LIST
100732: PUSH
100733: LD_INT 2
100735: PUSH
100736: LD_INT 34
100738: PUSH
100739: LD_INT 7
100741: PUSH
100742: EMPTY
100743: LIST
100744: LIST
100745: PUSH
100746: LD_INT 34
100748: PUSH
100749: LD_INT 45
100751: PUSH
100752: EMPTY
100753: LIST
100754: LIST
100755: PUSH
100756: LD_INT 34
100758: PUSH
100759: LD_INT 28
100761: PUSH
100762: EMPTY
100763: LIST
100764: LIST
100765: PUSH
100766: LD_INT 34
100768: PUSH
100769: LD_INT 47
100771: PUSH
100772: EMPTY
100773: LIST
100774: LIST
100775: PUSH
100776: EMPTY
100777: LIST
100778: LIST
100779: LIST
100780: LIST
100781: LIST
100782: PUSH
100783: EMPTY
100784: LIST
100785: LIST
100786: PPUSH
100787: CALL_OW 69
100791: ST_TO_ADDR
// if not tmp then
100792: LD_VAR 0 2
100796: NOT
100797: IFFALSE 100801
// exit ;
100799: GO 100830
// for i in tmp do
100801: LD_ADDR_VAR 0 1
100805: PUSH
100806: LD_VAR 0 2
100810: PUSH
100811: FOR_IN
100812: IFFALSE 100828
// begin SetLives ( i , 0 ) ;
100814: LD_VAR 0 1
100818: PPUSH
100819: LD_INT 0
100821: PPUSH
100822: CALL_OW 234
// end ;
100826: GO 100811
100828: POP
100829: POP
// end ;
100830: PPOPN 2
100832: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
100833: LD_EXP 77
100837: PUSH
100838: LD_EXP 83
100842: AND
100843: IFFALSE 100927
100845: GO 100847
100847: DISABLE
100848: LD_INT 0
100850: PPUSH
100851: PPUSH
// begin enable ;
100852: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
100853: LD_ADDR_VAR 0 2
100857: PUSH
100858: LD_INT 22
100860: PUSH
100861: LD_OWVAR 2
100865: PUSH
100866: EMPTY
100867: LIST
100868: LIST
100869: PUSH
100870: LD_INT 32
100872: PUSH
100873: LD_INT 3
100875: PUSH
100876: EMPTY
100877: LIST
100878: LIST
100879: PUSH
100880: EMPTY
100881: LIST
100882: LIST
100883: PPUSH
100884: CALL_OW 69
100888: ST_TO_ADDR
// if not tmp then
100889: LD_VAR 0 2
100893: NOT
100894: IFFALSE 100898
// exit ;
100896: GO 100927
// for i in tmp do
100898: LD_ADDR_VAR 0 1
100902: PUSH
100903: LD_VAR 0 2
100907: PUSH
100908: FOR_IN
100909: IFFALSE 100925
// begin SetLives ( i , 0 ) ;
100911: LD_VAR 0 1
100915: PPUSH
100916: LD_INT 0
100918: PPUSH
100919: CALL_OW 234
// end ;
100923: GO 100908
100925: POP
100926: POP
// end ;
100927: PPOPN 2
100929: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
100930: LD_EXP 77
100934: PUSH
100935: LD_EXP 80
100939: AND
100940: IFFALSE 101033
100942: GO 100944
100944: DISABLE
100945: LD_INT 0
100947: PPUSH
// begin enable ;
100948: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
100949: LD_ADDR_VAR 0 1
100953: PUSH
100954: LD_INT 22
100956: PUSH
100957: LD_OWVAR 2
100961: PUSH
100962: EMPTY
100963: LIST
100964: LIST
100965: PUSH
100966: LD_INT 2
100968: PUSH
100969: LD_INT 25
100971: PUSH
100972: LD_INT 5
100974: PUSH
100975: EMPTY
100976: LIST
100977: LIST
100978: PUSH
100979: LD_INT 25
100981: PUSH
100982: LD_INT 9
100984: PUSH
100985: EMPTY
100986: LIST
100987: LIST
100988: PUSH
100989: LD_INT 25
100991: PUSH
100992: LD_INT 8
100994: PUSH
100995: EMPTY
100996: LIST
100997: LIST
100998: PUSH
100999: EMPTY
101000: LIST
101001: LIST
101002: LIST
101003: LIST
101004: PUSH
101005: EMPTY
101006: LIST
101007: LIST
101008: PPUSH
101009: CALL_OW 69
101013: PUSH
101014: FOR_IN
101015: IFFALSE 101031
// begin SetClass ( i , 1 ) ;
101017: LD_VAR 0 1
101021: PPUSH
101022: LD_INT 1
101024: PPUSH
101025: CALL_OW 336
// end ;
101029: GO 101014
101031: POP
101032: POP
// end ;
101033: PPOPN 1
101035: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
101036: LD_EXP 77
101040: PUSH
101041: LD_EXP 81
101045: AND
101046: PUSH
101047: LD_OWVAR 65
101051: PUSH
101052: LD_INT 7
101054: LESS
101055: AND
101056: IFFALSE 101070
101058: GO 101060
101060: DISABLE
// begin enable ;
101061: ENABLE
// game_speed := 7 ;
101062: LD_ADDR_OWVAR 65
101066: PUSH
101067: LD_INT 7
101069: ST_TO_ADDR
// end ;
101070: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
101071: LD_EXP 77
101075: PUSH
101076: LD_EXP 84
101080: AND
101081: IFFALSE 101283
101083: GO 101085
101085: DISABLE
101086: LD_INT 0
101088: PPUSH
101089: PPUSH
101090: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
101091: LD_ADDR_VAR 0 3
101095: PUSH
101096: LD_INT 81
101098: PUSH
101099: LD_OWVAR 2
101103: PUSH
101104: EMPTY
101105: LIST
101106: LIST
101107: PUSH
101108: LD_INT 21
101110: PUSH
101111: LD_INT 1
101113: PUSH
101114: EMPTY
101115: LIST
101116: LIST
101117: PUSH
101118: EMPTY
101119: LIST
101120: LIST
101121: PPUSH
101122: CALL_OW 69
101126: ST_TO_ADDR
// if not tmp then
101127: LD_VAR 0 3
101131: NOT
101132: IFFALSE 101136
// exit ;
101134: GO 101283
// if tmp > 5 then
101136: LD_VAR 0 3
101140: PUSH
101141: LD_INT 5
101143: GREATER
101144: IFFALSE 101156
// k := 5 else
101146: LD_ADDR_VAR 0 2
101150: PUSH
101151: LD_INT 5
101153: ST_TO_ADDR
101154: GO 101166
// k := tmp ;
101156: LD_ADDR_VAR 0 2
101160: PUSH
101161: LD_VAR 0 3
101165: ST_TO_ADDR
// for i := 1 to k do
101166: LD_ADDR_VAR 0 1
101170: PUSH
101171: DOUBLE
101172: LD_INT 1
101174: DEC
101175: ST_TO_ADDR
101176: LD_VAR 0 2
101180: PUSH
101181: FOR_TO
101182: IFFALSE 101281
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
101184: LD_VAR 0 3
101188: PUSH
101189: LD_VAR 0 1
101193: ARRAY
101194: PPUSH
101195: LD_VAR 0 1
101199: PUSH
101200: LD_INT 4
101202: MOD
101203: PUSH
101204: LD_INT 1
101206: PLUS
101207: PPUSH
101208: CALL_OW 259
101212: PUSH
101213: LD_INT 10
101215: LESS
101216: IFFALSE 101279
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
101218: LD_VAR 0 3
101222: PUSH
101223: LD_VAR 0 1
101227: ARRAY
101228: PPUSH
101229: LD_VAR 0 1
101233: PUSH
101234: LD_INT 4
101236: MOD
101237: PUSH
101238: LD_INT 1
101240: PLUS
101241: PPUSH
101242: LD_VAR 0 3
101246: PUSH
101247: LD_VAR 0 1
101251: ARRAY
101252: PPUSH
101253: LD_VAR 0 1
101257: PUSH
101258: LD_INT 4
101260: MOD
101261: PUSH
101262: LD_INT 1
101264: PLUS
101265: PPUSH
101266: CALL_OW 259
101270: PUSH
101271: LD_INT 1
101273: PLUS
101274: PPUSH
101275: CALL_OW 237
101279: GO 101181
101281: POP
101282: POP
// end ;
101283: PPOPN 3
101285: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
101286: LD_EXP 77
101290: PUSH
101291: LD_EXP 85
101295: AND
101296: IFFALSE 101316
101298: GO 101300
101300: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
101301: LD_INT 4
101303: PPUSH
101304: LD_OWVAR 2
101308: PPUSH
101309: LD_INT 0
101311: PPUSH
101312: CALL_OW 324
101316: END
// every 0 0$1 trigger StreamModeActive and sShovel do
101317: LD_EXP 77
101321: PUSH
101322: LD_EXP 114
101326: AND
101327: IFFALSE 101347
101329: GO 101331
101331: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
101332: LD_INT 19
101334: PPUSH
101335: LD_OWVAR 2
101339: PPUSH
101340: LD_INT 0
101342: PPUSH
101343: CALL_OW 324
101347: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
101348: LD_EXP 77
101352: PUSH
101353: LD_EXP 86
101357: AND
101358: IFFALSE 101460
101360: GO 101362
101362: DISABLE
101363: LD_INT 0
101365: PPUSH
101366: PPUSH
// begin enable ;
101367: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
101368: LD_ADDR_VAR 0 2
101372: PUSH
101373: LD_INT 22
101375: PUSH
101376: LD_OWVAR 2
101380: PUSH
101381: EMPTY
101382: LIST
101383: LIST
101384: PUSH
101385: LD_INT 2
101387: PUSH
101388: LD_INT 34
101390: PUSH
101391: LD_INT 11
101393: PUSH
101394: EMPTY
101395: LIST
101396: LIST
101397: PUSH
101398: LD_INT 34
101400: PUSH
101401: LD_INT 30
101403: PUSH
101404: EMPTY
101405: LIST
101406: LIST
101407: PUSH
101408: EMPTY
101409: LIST
101410: LIST
101411: LIST
101412: PUSH
101413: EMPTY
101414: LIST
101415: LIST
101416: PPUSH
101417: CALL_OW 69
101421: ST_TO_ADDR
// if not tmp then
101422: LD_VAR 0 2
101426: NOT
101427: IFFALSE 101431
// exit ;
101429: GO 101460
// for i in tmp do
101431: LD_ADDR_VAR 0 1
101435: PUSH
101436: LD_VAR 0 2
101440: PUSH
101441: FOR_IN
101442: IFFALSE 101458
// begin SetLives ( i , 0 ) ;
101444: LD_VAR 0 1
101448: PPUSH
101449: LD_INT 0
101451: PPUSH
101452: CALL_OW 234
// end ;
101456: GO 101441
101458: POP
101459: POP
// end ;
101460: PPOPN 2
101462: END
// every 0 0$1 trigger StreamModeActive and sBunker do
101463: LD_EXP 77
101467: PUSH
101468: LD_EXP 87
101472: AND
101473: IFFALSE 101493
101475: GO 101477
101477: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
101478: LD_INT 32
101480: PPUSH
101481: LD_OWVAR 2
101485: PPUSH
101486: LD_INT 0
101488: PPUSH
101489: CALL_OW 324
101493: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
101494: LD_EXP 77
101498: PUSH
101499: LD_EXP 88
101503: AND
101504: IFFALSE 101685
101506: GO 101508
101508: DISABLE
101509: LD_INT 0
101511: PPUSH
101512: PPUSH
101513: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
101514: LD_ADDR_VAR 0 2
101518: PUSH
101519: LD_INT 22
101521: PUSH
101522: LD_OWVAR 2
101526: PUSH
101527: EMPTY
101528: LIST
101529: LIST
101530: PUSH
101531: LD_INT 33
101533: PUSH
101534: LD_INT 3
101536: PUSH
101537: EMPTY
101538: LIST
101539: LIST
101540: PUSH
101541: EMPTY
101542: LIST
101543: LIST
101544: PPUSH
101545: CALL_OW 69
101549: ST_TO_ADDR
// if not tmp then
101550: LD_VAR 0 2
101554: NOT
101555: IFFALSE 101559
// exit ;
101557: GO 101685
// side := 0 ;
101559: LD_ADDR_VAR 0 3
101563: PUSH
101564: LD_INT 0
101566: ST_TO_ADDR
// for i := 1 to 8 do
101567: LD_ADDR_VAR 0 1
101571: PUSH
101572: DOUBLE
101573: LD_INT 1
101575: DEC
101576: ST_TO_ADDR
101577: LD_INT 8
101579: PUSH
101580: FOR_TO
101581: IFFALSE 101629
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
101583: LD_OWVAR 2
101587: PUSH
101588: LD_VAR 0 1
101592: NONEQUAL
101593: PUSH
101594: LD_OWVAR 2
101598: PPUSH
101599: LD_VAR 0 1
101603: PPUSH
101604: CALL_OW 81
101608: PUSH
101609: LD_INT 2
101611: EQUAL
101612: AND
101613: IFFALSE 101627
// begin side := i ;
101615: LD_ADDR_VAR 0 3
101619: PUSH
101620: LD_VAR 0 1
101624: ST_TO_ADDR
// break ;
101625: GO 101629
// end ;
101627: GO 101580
101629: POP
101630: POP
// if not side then
101631: LD_VAR 0 3
101635: NOT
101636: IFFALSE 101640
// exit ;
101638: GO 101685
// for i := 1 to tmp do
101640: LD_ADDR_VAR 0 1
101644: PUSH
101645: DOUBLE
101646: LD_INT 1
101648: DEC
101649: ST_TO_ADDR
101650: LD_VAR 0 2
101654: PUSH
101655: FOR_TO
101656: IFFALSE 101683
// if Prob ( 60 ) then
101658: LD_INT 60
101660: PPUSH
101661: CALL_OW 13
101665: IFFALSE 101681
// SetSide ( i , side ) ;
101667: LD_VAR 0 1
101671: PPUSH
101672: LD_VAR 0 3
101676: PPUSH
101677: CALL_OW 235
101681: GO 101655
101683: POP
101684: POP
// end ;
101685: PPOPN 3
101687: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
101688: LD_EXP 77
101692: PUSH
101693: LD_EXP 90
101697: AND
101698: IFFALSE 101817
101700: GO 101702
101702: DISABLE
101703: LD_INT 0
101705: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
101706: LD_ADDR_VAR 0 1
101710: PUSH
101711: LD_INT 22
101713: PUSH
101714: LD_OWVAR 2
101718: PUSH
101719: EMPTY
101720: LIST
101721: LIST
101722: PUSH
101723: LD_INT 21
101725: PUSH
101726: LD_INT 1
101728: PUSH
101729: EMPTY
101730: LIST
101731: LIST
101732: PUSH
101733: LD_INT 3
101735: PUSH
101736: LD_INT 23
101738: PUSH
101739: LD_INT 0
101741: PUSH
101742: EMPTY
101743: LIST
101744: LIST
101745: PUSH
101746: EMPTY
101747: LIST
101748: LIST
101749: PUSH
101750: EMPTY
101751: LIST
101752: LIST
101753: LIST
101754: PPUSH
101755: CALL_OW 69
101759: PUSH
101760: FOR_IN
101761: IFFALSE 101815
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
101763: LD_VAR 0 1
101767: PPUSH
101768: CALL_OW 257
101772: PUSH
101773: LD_INT 1
101775: PUSH
101776: LD_INT 2
101778: PUSH
101779: LD_INT 3
101781: PUSH
101782: LD_INT 4
101784: PUSH
101785: EMPTY
101786: LIST
101787: LIST
101788: LIST
101789: LIST
101790: IN
101791: IFFALSE 101813
// SetClass ( un , rand ( 1 , 4 ) ) ;
101793: LD_VAR 0 1
101797: PPUSH
101798: LD_INT 1
101800: PPUSH
101801: LD_INT 4
101803: PPUSH
101804: CALL_OW 12
101808: PPUSH
101809: CALL_OW 336
101813: GO 101760
101815: POP
101816: POP
// end ;
101817: PPOPN 1
101819: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
101820: LD_EXP 77
101824: PUSH
101825: LD_EXP 89
101829: AND
101830: IFFALSE 101909
101832: GO 101834
101834: DISABLE
101835: LD_INT 0
101837: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
101838: LD_ADDR_VAR 0 1
101842: PUSH
101843: LD_INT 22
101845: PUSH
101846: LD_OWVAR 2
101850: PUSH
101851: EMPTY
101852: LIST
101853: LIST
101854: PUSH
101855: LD_INT 21
101857: PUSH
101858: LD_INT 3
101860: PUSH
101861: EMPTY
101862: LIST
101863: LIST
101864: PUSH
101865: EMPTY
101866: LIST
101867: LIST
101868: PPUSH
101869: CALL_OW 69
101873: ST_TO_ADDR
// if not tmp then
101874: LD_VAR 0 1
101878: NOT
101879: IFFALSE 101883
// exit ;
101881: GO 101909
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
101883: LD_VAR 0 1
101887: PUSH
101888: LD_INT 1
101890: PPUSH
101891: LD_VAR 0 1
101895: PPUSH
101896: CALL_OW 12
101900: ARRAY
101901: PPUSH
101902: LD_INT 100
101904: PPUSH
101905: CALL_OW 234
// end ;
101909: PPOPN 1
101911: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
101912: LD_EXP 77
101916: PUSH
101917: LD_EXP 91
101921: AND
101922: IFFALSE 102020
101924: GO 101926
101926: DISABLE
101927: LD_INT 0
101929: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101930: LD_ADDR_VAR 0 1
101934: PUSH
101935: LD_INT 22
101937: PUSH
101938: LD_OWVAR 2
101942: PUSH
101943: EMPTY
101944: LIST
101945: LIST
101946: PUSH
101947: LD_INT 21
101949: PUSH
101950: LD_INT 1
101952: PUSH
101953: EMPTY
101954: LIST
101955: LIST
101956: PUSH
101957: EMPTY
101958: LIST
101959: LIST
101960: PPUSH
101961: CALL_OW 69
101965: ST_TO_ADDR
// if not tmp then
101966: LD_VAR 0 1
101970: NOT
101971: IFFALSE 101975
// exit ;
101973: GO 102020
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
101975: LD_VAR 0 1
101979: PUSH
101980: LD_INT 1
101982: PPUSH
101983: LD_VAR 0 1
101987: PPUSH
101988: CALL_OW 12
101992: ARRAY
101993: PPUSH
101994: LD_INT 1
101996: PPUSH
101997: LD_INT 4
101999: PPUSH
102000: CALL_OW 12
102004: PPUSH
102005: LD_INT 3000
102007: PPUSH
102008: LD_INT 9000
102010: PPUSH
102011: CALL_OW 12
102015: PPUSH
102016: CALL_OW 492
// end ;
102020: PPOPN 1
102022: END
// every 0 0$1 trigger StreamModeActive and sDepot do
102023: LD_EXP 77
102027: PUSH
102028: LD_EXP 92
102032: AND
102033: IFFALSE 102053
102035: GO 102037
102037: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
102038: LD_INT 1
102040: PPUSH
102041: LD_OWVAR 2
102045: PPUSH
102046: LD_INT 0
102048: PPUSH
102049: CALL_OW 324
102053: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
102054: LD_EXP 77
102058: PUSH
102059: LD_EXP 93
102063: AND
102064: IFFALSE 102147
102066: GO 102068
102068: DISABLE
102069: LD_INT 0
102071: PPUSH
102072: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
102073: LD_ADDR_VAR 0 2
102077: PUSH
102078: LD_INT 22
102080: PUSH
102081: LD_OWVAR 2
102085: PUSH
102086: EMPTY
102087: LIST
102088: LIST
102089: PUSH
102090: LD_INT 21
102092: PUSH
102093: LD_INT 3
102095: PUSH
102096: EMPTY
102097: LIST
102098: LIST
102099: PUSH
102100: EMPTY
102101: LIST
102102: LIST
102103: PPUSH
102104: CALL_OW 69
102108: ST_TO_ADDR
// if not tmp then
102109: LD_VAR 0 2
102113: NOT
102114: IFFALSE 102118
// exit ;
102116: GO 102147
// for i in tmp do
102118: LD_ADDR_VAR 0 1
102122: PUSH
102123: LD_VAR 0 2
102127: PUSH
102128: FOR_IN
102129: IFFALSE 102145
// SetBLevel ( i , 10 ) ;
102131: LD_VAR 0 1
102135: PPUSH
102136: LD_INT 10
102138: PPUSH
102139: CALL_OW 241
102143: GO 102128
102145: POP
102146: POP
// end ;
102147: PPOPN 2
102149: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
102150: LD_EXP 77
102154: PUSH
102155: LD_EXP 94
102159: AND
102160: IFFALSE 102271
102162: GO 102164
102164: DISABLE
102165: LD_INT 0
102167: PPUSH
102168: PPUSH
102169: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102170: LD_ADDR_VAR 0 3
102174: PUSH
102175: LD_INT 22
102177: PUSH
102178: LD_OWVAR 2
102182: PUSH
102183: EMPTY
102184: LIST
102185: LIST
102186: PUSH
102187: LD_INT 25
102189: PUSH
102190: LD_INT 1
102192: PUSH
102193: EMPTY
102194: LIST
102195: LIST
102196: PUSH
102197: EMPTY
102198: LIST
102199: LIST
102200: PPUSH
102201: CALL_OW 69
102205: ST_TO_ADDR
// if not tmp then
102206: LD_VAR 0 3
102210: NOT
102211: IFFALSE 102215
// exit ;
102213: GO 102271
// un := tmp [ rand ( 1 , tmp ) ] ;
102215: LD_ADDR_VAR 0 2
102219: PUSH
102220: LD_VAR 0 3
102224: PUSH
102225: LD_INT 1
102227: PPUSH
102228: LD_VAR 0 3
102232: PPUSH
102233: CALL_OW 12
102237: ARRAY
102238: ST_TO_ADDR
// if Crawls ( un ) then
102239: LD_VAR 0 2
102243: PPUSH
102244: CALL_OW 318
102248: IFFALSE 102259
// ComWalk ( un ) ;
102250: LD_VAR 0 2
102254: PPUSH
102255: CALL_OW 138
// SetClass ( un , class_sniper ) ;
102259: LD_VAR 0 2
102263: PPUSH
102264: LD_INT 5
102266: PPUSH
102267: CALL_OW 336
// end ;
102271: PPOPN 3
102273: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
102274: LD_EXP 77
102278: PUSH
102279: LD_EXP 95
102283: AND
102284: PUSH
102285: LD_OWVAR 67
102289: PUSH
102290: LD_INT 4
102292: LESS
102293: AND
102294: IFFALSE 102313
102296: GO 102298
102298: DISABLE
// begin Difficulty := Difficulty + 1 ;
102299: LD_ADDR_OWVAR 67
102303: PUSH
102304: LD_OWVAR 67
102308: PUSH
102309: LD_INT 1
102311: PLUS
102312: ST_TO_ADDR
// end ;
102313: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
102314: LD_EXP 77
102318: PUSH
102319: LD_EXP 96
102323: AND
102324: IFFALSE 102427
102326: GO 102328
102328: DISABLE
102329: LD_INT 0
102331: PPUSH
// begin for i := 1 to 5 do
102332: LD_ADDR_VAR 0 1
102336: PUSH
102337: DOUBLE
102338: LD_INT 1
102340: DEC
102341: ST_TO_ADDR
102342: LD_INT 5
102344: PUSH
102345: FOR_TO
102346: IFFALSE 102425
// begin uc_nation := nation_nature ;
102348: LD_ADDR_OWVAR 21
102352: PUSH
102353: LD_INT 0
102355: ST_TO_ADDR
// uc_side := 0 ;
102356: LD_ADDR_OWVAR 20
102360: PUSH
102361: LD_INT 0
102363: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
102364: LD_ADDR_OWVAR 29
102368: PUSH
102369: LD_INT 12
102371: PUSH
102372: LD_INT 12
102374: PUSH
102375: EMPTY
102376: LIST
102377: LIST
102378: ST_TO_ADDR
// hc_agressivity := 20 ;
102379: LD_ADDR_OWVAR 35
102383: PUSH
102384: LD_INT 20
102386: ST_TO_ADDR
// hc_class := class_tiger ;
102387: LD_ADDR_OWVAR 28
102391: PUSH
102392: LD_INT 14
102394: ST_TO_ADDR
// hc_gallery :=  ;
102395: LD_ADDR_OWVAR 33
102399: PUSH
102400: LD_STRING 
102402: ST_TO_ADDR
// hc_name :=  ;
102403: LD_ADDR_OWVAR 26
102407: PUSH
102408: LD_STRING 
102410: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
102411: CALL_OW 44
102415: PPUSH
102416: LD_INT 0
102418: PPUSH
102419: CALL_OW 51
// end ;
102423: GO 102345
102425: POP
102426: POP
// end ;
102427: PPOPN 1
102429: END
// every 0 0$1 trigger StreamModeActive and sBomb do
102430: LD_EXP 77
102434: PUSH
102435: LD_EXP 97
102439: AND
102440: IFFALSE 102449
102442: GO 102444
102444: DISABLE
// StreamSibBomb ;
102445: CALL 102450 0 0
102449: END
// export function StreamSibBomb ; var i , x , y ; begin
102450: LD_INT 0
102452: PPUSH
102453: PPUSH
102454: PPUSH
102455: PPUSH
// result := false ;
102456: LD_ADDR_VAR 0 1
102460: PUSH
102461: LD_INT 0
102463: ST_TO_ADDR
// for i := 1 to 16 do
102464: LD_ADDR_VAR 0 2
102468: PUSH
102469: DOUBLE
102470: LD_INT 1
102472: DEC
102473: ST_TO_ADDR
102474: LD_INT 16
102476: PUSH
102477: FOR_TO
102478: IFFALSE 102677
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
102480: LD_ADDR_VAR 0 3
102484: PUSH
102485: LD_INT 10
102487: PUSH
102488: LD_INT 20
102490: PUSH
102491: LD_INT 30
102493: PUSH
102494: LD_INT 40
102496: PUSH
102497: LD_INT 50
102499: PUSH
102500: LD_INT 60
102502: PUSH
102503: LD_INT 70
102505: PUSH
102506: LD_INT 80
102508: PUSH
102509: LD_INT 90
102511: PUSH
102512: LD_INT 100
102514: PUSH
102515: LD_INT 110
102517: PUSH
102518: LD_INT 120
102520: PUSH
102521: LD_INT 130
102523: PUSH
102524: LD_INT 140
102526: PUSH
102527: LD_INT 150
102529: PUSH
102530: EMPTY
102531: LIST
102532: LIST
102533: LIST
102534: LIST
102535: LIST
102536: LIST
102537: LIST
102538: LIST
102539: LIST
102540: LIST
102541: LIST
102542: LIST
102543: LIST
102544: LIST
102545: LIST
102546: PUSH
102547: LD_INT 1
102549: PPUSH
102550: LD_INT 15
102552: PPUSH
102553: CALL_OW 12
102557: ARRAY
102558: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
102559: LD_ADDR_VAR 0 4
102563: PUSH
102564: LD_INT 10
102566: PUSH
102567: LD_INT 20
102569: PUSH
102570: LD_INT 30
102572: PUSH
102573: LD_INT 40
102575: PUSH
102576: LD_INT 50
102578: PUSH
102579: LD_INT 60
102581: PUSH
102582: LD_INT 70
102584: PUSH
102585: LD_INT 80
102587: PUSH
102588: LD_INT 90
102590: PUSH
102591: LD_INT 100
102593: PUSH
102594: LD_INT 110
102596: PUSH
102597: LD_INT 120
102599: PUSH
102600: LD_INT 130
102602: PUSH
102603: LD_INT 140
102605: PUSH
102606: LD_INT 150
102608: PUSH
102609: EMPTY
102610: LIST
102611: LIST
102612: LIST
102613: LIST
102614: LIST
102615: LIST
102616: LIST
102617: LIST
102618: LIST
102619: LIST
102620: LIST
102621: LIST
102622: LIST
102623: LIST
102624: LIST
102625: PUSH
102626: LD_INT 1
102628: PPUSH
102629: LD_INT 15
102631: PPUSH
102632: CALL_OW 12
102636: ARRAY
102637: ST_TO_ADDR
// if ValidHex ( x , y ) then
102638: LD_VAR 0 3
102642: PPUSH
102643: LD_VAR 0 4
102647: PPUSH
102648: CALL_OW 488
102652: IFFALSE 102675
// begin result := [ x , y ] ;
102654: LD_ADDR_VAR 0 1
102658: PUSH
102659: LD_VAR 0 3
102663: PUSH
102664: LD_VAR 0 4
102668: PUSH
102669: EMPTY
102670: LIST
102671: LIST
102672: ST_TO_ADDR
// break ;
102673: GO 102677
// end ; end ;
102675: GO 102477
102677: POP
102678: POP
// if result then
102679: LD_VAR 0 1
102683: IFFALSE 102743
// begin ToLua ( playSibBomb() ) ;
102685: LD_STRING playSibBomb()
102687: PPUSH
102688: CALL_OW 559
// wait ( 0 0$14 ) ;
102692: LD_INT 490
102694: PPUSH
102695: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
102699: LD_VAR 0 1
102703: PUSH
102704: LD_INT 1
102706: ARRAY
102707: PPUSH
102708: LD_VAR 0 1
102712: PUSH
102713: LD_INT 2
102715: ARRAY
102716: PPUSH
102717: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
102721: LD_VAR 0 1
102725: PUSH
102726: LD_INT 1
102728: ARRAY
102729: PPUSH
102730: LD_VAR 0 1
102734: PUSH
102735: LD_INT 2
102737: ARRAY
102738: PPUSH
102739: CALL_OW 429
// end ; end ;
102743: LD_VAR 0 1
102747: RET
// every 0 0$1 trigger StreamModeActive and sReset do
102748: LD_EXP 77
102752: PUSH
102753: LD_EXP 99
102757: AND
102758: IFFALSE 102770
102760: GO 102762
102762: DISABLE
// YouLost (  ) ;
102763: LD_STRING 
102765: PPUSH
102766: CALL_OW 104
102770: END
// every 0 0$1 trigger StreamModeActive and sFog do
102771: LD_EXP 77
102775: PUSH
102776: LD_EXP 98
102780: AND
102781: IFFALSE 102795
102783: GO 102785
102785: DISABLE
// FogOff ( your_side ) ;
102786: LD_OWVAR 2
102790: PPUSH
102791: CALL_OW 344
102795: END
// every 0 0$1 trigger StreamModeActive and sSun do
102796: LD_EXP 77
102800: PUSH
102801: LD_EXP 100
102805: AND
102806: IFFALSE 102834
102808: GO 102810
102810: DISABLE
// begin solar_recharge_percent := 0 ;
102811: LD_ADDR_OWVAR 79
102815: PUSH
102816: LD_INT 0
102818: ST_TO_ADDR
// wait ( 5 5$00 ) ;
102819: LD_INT 10500
102821: PPUSH
102822: CALL_OW 67
// solar_recharge_percent := 100 ;
102826: LD_ADDR_OWVAR 79
102830: PUSH
102831: LD_INT 100
102833: ST_TO_ADDR
// end ;
102834: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
102835: LD_EXP 77
102839: PUSH
102840: LD_EXP 101
102844: AND
102845: IFFALSE 103084
102847: GO 102849
102849: DISABLE
102850: LD_INT 0
102852: PPUSH
102853: PPUSH
102854: PPUSH
// begin tmp := [ ] ;
102855: LD_ADDR_VAR 0 3
102859: PUSH
102860: EMPTY
102861: ST_TO_ADDR
// for i := 1 to 6 do
102862: LD_ADDR_VAR 0 1
102866: PUSH
102867: DOUBLE
102868: LD_INT 1
102870: DEC
102871: ST_TO_ADDR
102872: LD_INT 6
102874: PUSH
102875: FOR_TO
102876: IFFALSE 102981
// begin uc_nation := nation_nature ;
102878: LD_ADDR_OWVAR 21
102882: PUSH
102883: LD_INT 0
102885: ST_TO_ADDR
// uc_side := 0 ;
102886: LD_ADDR_OWVAR 20
102890: PUSH
102891: LD_INT 0
102893: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
102894: LD_ADDR_OWVAR 29
102898: PUSH
102899: LD_INT 12
102901: PUSH
102902: LD_INT 12
102904: PUSH
102905: EMPTY
102906: LIST
102907: LIST
102908: ST_TO_ADDR
// hc_agressivity := 20 ;
102909: LD_ADDR_OWVAR 35
102913: PUSH
102914: LD_INT 20
102916: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
102917: LD_ADDR_OWVAR 28
102921: PUSH
102922: LD_INT 17
102924: ST_TO_ADDR
// hc_gallery :=  ;
102925: LD_ADDR_OWVAR 33
102929: PUSH
102930: LD_STRING 
102932: ST_TO_ADDR
// hc_name :=  ;
102933: LD_ADDR_OWVAR 26
102937: PUSH
102938: LD_STRING 
102940: ST_TO_ADDR
// un := CreateHuman ;
102941: LD_ADDR_VAR 0 2
102945: PUSH
102946: CALL_OW 44
102950: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
102951: LD_VAR 0 2
102955: PPUSH
102956: LD_INT 1
102958: PPUSH
102959: CALL_OW 51
// tmp := tmp ^ un ;
102963: LD_ADDR_VAR 0 3
102967: PUSH
102968: LD_VAR 0 3
102972: PUSH
102973: LD_VAR 0 2
102977: ADD
102978: ST_TO_ADDR
// end ;
102979: GO 102875
102981: POP
102982: POP
// repeat wait ( 0 0$1 ) ;
102983: LD_INT 35
102985: PPUSH
102986: CALL_OW 67
// for un in tmp do
102990: LD_ADDR_VAR 0 2
102994: PUSH
102995: LD_VAR 0 3
102999: PUSH
103000: FOR_IN
103001: IFFALSE 103075
// begin if IsDead ( un ) then
103003: LD_VAR 0 2
103007: PPUSH
103008: CALL_OW 301
103012: IFFALSE 103032
// begin tmp := tmp diff un ;
103014: LD_ADDR_VAR 0 3
103018: PUSH
103019: LD_VAR 0 3
103023: PUSH
103024: LD_VAR 0 2
103028: DIFF
103029: ST_TO_ADDR
// continue ;
103030: GO 103000
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
103032: LD_VAR 0 2
103036: PPUSH
103037: LD_INT 3
103039: PUSH
103040: LD_INT 22
103042: PUSH
103043: LD_INT 0
103045: PUSH
103046: EMPTY
103047: LIST
103048: LIST
103049: PUSH
103050: EMPTY
103051: LIST
103052: LIST
103053: PPUSH
103054: CALL_OW 69
103058: PPUSH
103059: LD_VAR 0 2
103063: PPUSH
103064: CALL_OW 74
103068: PPUSH
103069: CALL_OW 115
// end ;
103073: GO 103000
103075: POP
103076: POP
// until not tmp ;
103077: LD_VAR 0 3
103081: NOT
103082: IFFALSE 102983
// end ;
103084: PPOPN 3
103086: END
// every 0 0$1 trigger StreamModeActive and sTroll do
103087: LD_EXP 77
103091: PUSH
103092: LD_EXP 102
103096: AND
103097: IFFALSE 103151
103099: GO 103101
103101: DISABLE
// begin ToLua ( displayTroll(); ) ;
103102: LD_STRING displayTroll();
103104: PPUSH
103105: CALL_OW 559
// wait ( 3 3$00 ) ;
103109: LD_INT 6300
103111: PPUSH
103112: CALL_OW 67
// ToLua ( hideTroll(); ) ;
103116: LD_STRING hideTroll();
103118: PPUSH
103119: CALL_OW 559
// wait ( 1 1$00 ) ;
103123: LD_INT 2100
103125: PPUSH
103126: CALL_OW 67
// ToLua ( displayTroll(); ) ;
103130: LD_STRING displayTroll();
103132: PPUSH
103133: CALL_OW 559
// wait ( 1 1$00 ) ;
103137: LD_INT 2100
103139: PPUSH
103140: CALL_OW 67
// ToLua ( hideTroll(); ) ;
103144: LD_STRING hideTroll();
103146: PPUSH
103147: CALL_OW 559
// end ;
103151: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
103152: LD_EXP 77
103156: PUSH
103157: LD_EXP 103
103161: AND
103162: IFFALSE 103225
103164: GO 103166
103166: DISABLE
103167: LD_INT 0
103169: PPUSH
// begin p := 0 ;
103170: LD_ADDR_VAR 0 1
103174: PUSH
103175: LD_INT 0
103177: ST_TO_ADDR
// repeat game_speed := 1 ;
103178: LD_ADDR_OWVAR 65
103182: PUSH
103183: LD_INT 1
103185: ST_TO_ADDR
// wait ( 0 0$1 ) ;
103186: LD_INT 35
103188: PPUSH
103189: CALL_OW 67
// p := p + 1 ;
103193: LD_ADDR_VAR 0 1
103197: PUSH
103198: LD_VAR 0 1
103202: PUSH
103203: LD_INT 1
103205: PLUS
103206: ST_TO_ADDR
// until p >= 60 ;
103207: LD_VAR 0 1
103211: PUSH
103212: LD_INT 60
103214: GREATEREQUAL
103215: IFFALSE 103178
// game_speed := 4 ;
103217: LD_ADDR_OWVAR 65
103221: PUSH
103222: LD_INT 4
103224: ST_TO_ADDR
// end ;
103225: PPOPN 1
103227: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
103228: LD_EXP 77
103232: PUSH
103233: LD_EXP 104
103237: AND
103238: IFFALSE 103384
103240: GO 103242
103242: DISABLE
103243: LD_INT 0
103245: PPUSH
103246: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
103247: LD_ADDR_VAR 0 1
103251: PUSH
103252: LD_INT 22
103254: PUSH
103255: LD_OWVAR 2
103259: PUSH
103260: EMPTY
103261: LIST
103262: LIST
103263: PUSH
103264: LD_INT 2
103266: PUSH
103267: LD_INT 30
103269: PUSH
103270: LD_INT 0
103272: PUSH
103273: EMPTY
103274: LIST
103275: LIST
103276: PUSH
103277: LD_INT 30
103279: PUSH
103280: LD_INT 1
103282: PUSH
103283: EMPTY
103284: LIST
103285: LIST
103286: PUSH
103287: EMPTY
103288: LIST
103289: LIST
103290: LIST
103291: PUSH
103292: EMPTY
103293: LIST
103294: LIST
103295: PPUSH
103296: CALL_OW 69
103300: ST_TO_ADDR
// if not depot then
103301: LD_VAR 0 1
103305: NOT
103306: IFFALSE 103310
// exit ;
103308: GO 103384
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
103310: LD_ADDR_VAR 0 2
103314: PUSH
103315: LD_VAR 0 1
103319: PUSH
103320: LD_INT 1
103322: PPUSH
103323: LD_VAR 0 1
103327: PPUSH
103328: CALL_OW 12
103332: ARRAY
103333: PPUSH
103334: CALL_OW 274
103338: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
103339: LD_VAR 0 2
103343: PPUSH
103344: LD_INT 1
103346: PPUSH
103347: LD_INT 0
103349: PPUSH
103350: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
103354: LD_VAR 0 2
103358: PPUSH
103359: LD_INT 2
103361: PPUSH
103362: LD_INT 0
103364: PPUSH
103365: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
103369: LD_VAR 0 2
103373: PPUSH
103374: LD_INT 3
103376: PPUSH
103377: LD_INT 0
103379: PPUSH
103380: CALL_OW 277
// end ;
103384: PPOPN 2
103386: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
103387: LD_EXP 77
103391: PUSH
103392: LD_EXP 105
103396: AND
103397: IFFALSE 103494
103399: GO 103401
103401: DISABLE
103402: LD_INT 0
103404: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
103405: LD_ADDR_VAR 0 1
103409: PUSH
103410: LD_INT 22
103412: PUSH
103413: LD_OWVAR 2
103417: PUSH
103418: EMPTY
103419: LIST
103420: LIST
103421: PUSH
103422: LD_INT 21
103424: PUSH
103425: LD_INT 1
103427: PUSH
103428: EMPTY
103429: LIST
103430: LIST
103431: PUSH
103432: LD_INT 3
103434: PUSH
103435: LD_INT 23
103437: PUSH
103438: LD_INT 0
103440: PUSH
103441: EMPTY
103442: LIST
103443: LIST
103444: PUSH
103445: EMPTY
103446: LIST
103447: LIST
103448: PUSH
103449: EMPTY
103450: LIST
103451: LIST
103452: LIST
103453: PPUSH
103454: CALL_OW 69
103458: ST_TO_ADDR
// if not tmp then
103459: LD_VAR 0 1
103463: NOT
103464: IFFALSE 103468
// exit ;
103466: GO 103494
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
103468: LD_VAR 0 1
103472: PUSH
103473: LD_INT 1
103475: PPUSH
103476: LD_VAR 0 1
103480: PPUSH
103481: CALL_OW 12
103485: ARRAY
103486: PPUSH
103487: LD_INT 200
103489: PPUSH
103490: CALL_OW 234
// end ;
103494: PPOPN 1
103496: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
103497: LD_EXP 77
103501: PUSH
103502: LD_EXP 106
103506: AND
103507: IFFALSE 103586
103509: GO 103511
103511: DISABLE
103512: LD_INT 0
103514: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
103515: LD_ADDR_VAR 0 1
103519: PUSH
103520: LD_INT 22
103522: PUSH
103523: LD_OWVAR 2
103527: PUSH
103528: EMPTY
103529: LIST
103530: LIST
103531: PUSH
103532: LD_INT 21
103534: PUSH
103535: LD_INT 2
103537: PUSH
103538: EMPTY
103539: LIST
103540: LIST
103541: PUSH
103542: EMPTY
103543: LIST
103544: LIST
103545: PPUSH
103546: CALL_OW 69
103550: ST_TO_ADDR
// if not tmp then
103551: LD_VAR 0 1
103555: NOT
103556: IFFALSE 103560
// exit ;
103558: GO 103586
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
103560: LD_VAR 0 1
103564: PUSH
103565: LD_INT 1
103567: PPUSH
103568: LD_VAR 0 1
103572: PPUSH
103573: CALL_OW 12
103577: ARRAY
103578: PPUSH
103579: LD_INT 60
103581: PPUSH
103582: CALL_OW 234
// end ;
103586: PPOPN 1
103588: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
103589: LD_EXP 77
103593: PUSH
103594: LD_EXP 107
103598: AND
103599: IFFALSE 103698
103601: GO 103603
103603: DISABLE
103604: LD_INT 0
103606: PPUSH
103607: PPUSH
// begin enable ;
103608: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
103609: LD_ADDR_VAR 0 1
103613: PUSH
103614: LD_INT 22
103616: PUSH
103617: LD_OWVAR 2
103621: PUSH
103622: EMPTY
103623: LIST
103624: LIST
103625: PUSH
103626: LD_INT 61
103628: PUSH
103629: EMPTY
103630: LIST
103631: PUSH
103632: LD_INT 33
103634: PUSH
103635: LD_INT 2
103637: PUSH
103638: EMPTY
103639: LIST
103640: LIST
103641: PUSH
103642: EMPTY
103643: LIST
103644: LIST
103645: LIST
103646: PPUSH
103647: CALL_OW 69
103651: ST_TO_ADDR
// if not tmp then
103652: LD_VAR 0 1
103656: NOT
103657: IFFALSE 103661
// exit ;
103659: GO 103698
// for i in tmp do
103661: LD_ADDR_VAR 0 2
103665: PUSH
103666: LD_VAR 0 1
103670: PUSH
103671: FOR_IN
103672: IFFALSE 103696
// if IsControledBy ( i ) then
103674: LD_VAR 0 2
103678: PPUSH
103679: CALL_OW 312
103683: IFFALSE 103694
// ComUnlink ( i ) ;
103685: LD_VAR 0 2
103689: PPUSH
103690: CALL_OW 136
103694: GO 103671
103696: POP
103697: POP
// end ;
103698: PPOPN 2
103700: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
103701: LD_EXP 77
103705: PUSH
103706: LD_EXP 108
103710: AND
103711: IFFALSE 103851
103713: GO 103715
103715: DISABLE
103716: LD_INT 0
103718: PPUSH
103719: PPUSH
// begin ToLua ( displayPowell(); ) ;
103720: LD_STRING displayPowell();
103722: PPUSH
103723: CALL_OW 559
// uc_side := 0 ;
103727: LD_ADDR_OWVAR 20
103731: PUSH
103732: LD_INT 0
103734: ST_TO_ADDR
// uc_nation := 2 ;
103735: LD_ADDR_OWVAR 21
103739: PUSH
103740: LD_INT 2
103742: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
103743: LD_ADDR_OWVAR 37
103747: PUSH
103748: LD_INT 14
103750: ST_TO_ADDR
// vc_engine := engine_siberite ;
103751: LD_ADDR_OWVAR 39
103755: PUSH
103756: LD_INT 3
103758: ST_TO_ADDR
// vc_control := control_apeman ;
103759: LD_ADDR_OWVAR 38
103763: PUSH
103764: LD_INT 5
103766: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
103767: LD_ADDR_OWVAR 40
103771: PUSH
103772: LD_INT 29
103774: ST_TO_ADDR
// un := CreateVehicle ;
103775: LD_ADDR_VAR 0 2
103779: PUSH
103780: CALL_OW 45
103784: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
103785: LD_VAR 0 2
103789: PPUSH
103790: LD_INT 1
103792: PPUSH
103793: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
103797: LD_INT 35
103799: PPUSH
103800: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
103804: LD_VAR 0 2
103808: PPUSH
103809: LD_INT 22
103811: PUSH
103812: LD_OWVAR 2
103816: PUSH
103817: EMPTY
103818: LIST
103819: LIST
103820: PPUSH
103821: CALL_OW 69
103825: PPUSH
103826: LD_VAR 0 2
103830: PPUSH
103831: CALL_OW 74
103835: PPUSH
103836: CALL_OW 115
// until IsDead ( un ) ;
103840: LD_VAR 0 2
103844: PPUSH
103845: CALL_OW 301
103849: IFFALSE 103797
// end ;
103851: PPOPN 2
103853: END
// every 0 0$1 trigger StreamModeActive and sStu do
103854: LD_EXP 77
103858: PUSH
103859: LD_EXP 116
103863: AND
103864: IFFALSE 103880
103866: GO 103868
103868: DISABLE
// begin ToLua ( displayStucuk(); ) ;
103869: LD_STRING displayStucuk();
103871: PPUSH
103872: CALL_OW 559
// ResetFog ;
103876: CALL_OW 335
// end ;
103880: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
103881: LD_EXP 77
103885: PUSH
103886: LD_EXP 109
103890: AND
103891: IFFALSE 104032
103893: GO 103895
103895: DISABLE
103896: LD_INT 0
103898: PPUSH
103899: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
103900: LD_ADDR_VAR 0 2
103904: PUSH
103905: LD_INT 22
103907: PUSH
103908: LD_OWVAR 2
103912: PUSH
103913: EMPTY
103914: LIST
103915: LIST
103916: PUSH
103917: LD_INT 21
103919: PUSH
103920: LD_INT 1
103922: PUSH
103923: EMPTY
103924: LIST
103925: LIST
103926: PUSH
103927: EMPTY
103928: LIST
103929: LIST
103930: PPUSH
103931: CALL_OW 69
103935: ST_TO_ADDR
// if not tmp then
103936: LD_VAR 0 2
103940: NOT
103941: IFFALSE 103945
// exit ;
103943: GO 104032
// un := tmp [ rand ( 1 , tmp ) ] ;
103945: LD_ADDR_VAR 0 1
103949: PUSH
103950: LD_VAR 0 2
103954: PUSH
103955: LD_INT 1
103957: PPUSH
103958: LD_VAR 0 2
103962: PPUSH
103963: CALL_OW 12
103967: ARRAY
103968: ST_TO_ADDR
// SetSide ( un , 0 ) ;
103969: LD_VAR 0 1
103973: PPUSH
103974: LD_INT 0
103976: PPUSH
103977: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
103981: LD_VAR 0 1
103985: PPUSH
103986: LD_OWVAR 3
103990: PUSH
103991: LD_VAR 0 1
103995: DIFF
103996: PPUSH
103997: LD_VAR 0 1
104001: PPUSH
104002: CALL_OW 74
104006: PPUSH
104007: CALL_OW 115
// wait ( 0 0$20 ) ;
104011: LD_INT 700
104013: PPUSH
104014: CALL_OW 67
// SetSide ( un , your_side ) ;
104018: LD_VAR 0 1
104022: PPUSH
104023: LD_OWVAR 2
104027: PPUSH
104028: CALL_OW 235
// end ;
104032: PPOPN 2
104034: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
104035: LD_EXP 77
104039: PUSH
104040: LD_EXP 110
104044: AND
104045: IFFALSE 104151
104047: GO 104049
104049: DISABLE
104050: LD_INT 0
104052: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
104053: LD_ADDR_VAR 0 1
104057: PUSH
104058: LD_INT 22
104060: PUSH
104061: LD_OWVAR 2
104065: PUSH
104066: EMPTY
104067: LIST
104068: LIST
104069: PUSH
104070: LD_INT 2
104072: PUSH
104073: LD_INT 30
104075: PUSH
104076: LD_INT 0
104078: PUSH
104079: EMPTY
104080: LIST
104081: LIST
104082: PUSH
104083: LD_INT 30
104085: PUSH
104086: LD_INT 1
104088: PUSH
104089: EMPTY
104090: LIST
104091: LIST
104092: PUSH
104093: EMPTY
104094: LIST
104095: LIST
104096: LIST
104097: PUSH
104098: EMPTY
104099: LIST
104100: LIST
104101: PPUSH
104102: CALL_OW 69
104106: ST_TO_ADDR
// if not depot then
104107: LD_VAR 0 1
104111: NOT
104112: IFFALSE 104116
// exit ;
104114: GO 104151
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
104116: LD_VAR 0 1
104120: PUSH
104121: LD_INT 1
104123: ARRAY
104124: PPUSH
104125: CALL_OW 250
104129: PPUSH
104130: LD_VAR 0 1
104134: PUSH
104135: LD_INT 1
104137: ARRAY
104138: PPUSH
104139: CALL_OW 251
104143: PPUSH
104144: LD_INT 70
104146: PPUSH
104147: CALL_OW 495
// end ;
104151: PPOPN 1
104153: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
104154: LD_EXP 77
104158: PUSH
104159: LD_EXP 111
104163: AND
104164: IFFALSE 104375
104166: GO 104168
104168: DISABLE
104169: LD_INT 0
104171: PPUSH
104172: PPUSH
104173: PPUSH
104174: PPUSH
104175: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
104176: LD_ADDR_VAR 0 5
104180: PUSH
104181: LD_INT 22
104183: PUSH
104184: LD_OWVAR 2
104188: PUSH
104189: EMPTY
104190: LIST
104191: LIST
104192: PUSH
104193: LD_INT 21
104195: PUSH
104196: LD_INT 1
104198: PUSH
104199: EMPTY
104200: LIST
104201: LIST
104202: PUSH
104203: EMPTY
104204: LIST
104205: LIST
104206: PPUSH
104207: CALL_OW 69
104211: ST_TO_ADDR
// if not tmp then
104212: LD_VAR 0 5
104216: NOT
104217: IFFALSE 104221
// exit ;
104219: GO 104375
// for i in tmp do
104221: LD_ADDR_VAR 0 1
104225: PUSH
104226: LD_VAR 0 5
104230: PUSH
104231: FOR_IN
104232: IFFALSE 104373
// begin d := rand ( 0 , 5 ) ;
104234: LD_ADDR_VAR 0 4
104238: PUSH
104239: LD_INT 0
104241: PPUSH
104242: LD_INT 5
104244: PPUSH
104245: CALL_OW 12
104249: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
104250: LD_ADDR_VAR 0 2
104254: PUSH
104255: LD_VAR 0 1
104259: PPUSH
104260: CALL_OW 250
104264: PPUSH
104265: LD_VAR 0 4
104269: PPUSH
104270: LD_INT 3
104272: PPUSH
104273: LD_INT 12
104275: PPUSH
104276: CALL_OW 12
104280: PPUSH
104281: CALL_OW 272
104285: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
104286: LD_ADDR_VAR 0 3
104290: PUSH
104291: LD_VAR 0 1
104295: PPUSH
104296: CALL_OW 251
104300: PPUSH
104301: LD_VAR 0 4
104305: PPUSH
104306: LD_INT 3
104308: PPUSH
104309: LD_INT 12
104311: PPUSH
104312: CALL_OW 12
104316: PPUSH
104317: CALL_OW 273
104321: ST_TO_ADDR
// if ValidHex ( x , y ) then
104322: LD_VAR 0 2
104326: PPUSH
104327: LD_VAR 0 3
104331: PPUSH
104332: CALL_OW 488
104336: IFFALSE 104371
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
104338: LD_VAR 0 1
104342: PPUSH
104343: LD_VAR 0 2
104347: PPUSH
104348: LD_VAR 0 3
104352: PPUSH
104353: LD_INT 3
104355: PPUSH
104356: LD_INT 6
104358: PPUSH
104359: CALL_OW 12
104363: PPUSH
104364: LD_INT 1
104366: PPUSH
104367: CALL_OW 483
// end ;
104371: GO 104231
104373: POP
104374: POP
// end ;
104375: PPOPN 5
104377: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
104378: LD_EXP 77
104382: PUSH
104383: LD_EXP 112
104387: AND
104388: IFFALSE 104482
104390: GO 104392
104392: DISABLE
104393: LD_INT 0
104395: PPUSH
104396: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
104397: LD_ADDR_VAR 0 2
104401: PUSH
104402: LD_INT 22
104404: PUSH
104405: LD_OWVAR 2
104409: PUSH
104410: EMPTY
104411: LIST
104412: LIST
104413: PUSH
104414: LD_INT 32
104416: PUSH
104417: LD_INT 1
104419: PUSH
104420: EMPTY
104421: LIST
104422: LIST
104423: PUSH
104424: LD_INT 21
104426: PUSH
104427: LD_INT 2
104429: PUSH
104430: EMPTY
104431: LIST
104432: LIST
104433: PUSH
104434: EMPTY
104435: LIST
104436: LIST
104437: LIST
104438: PPUSH
104439: CALL_OW 69
104443: ST_TO_ADDR
// if not tmp then
104444: LD_VAR 0 2
104448: NOT
104449: IFFALSE 104453
// exit ;
104451: GO 104482
// for i in tmp do
104453: LD_ADDR_VAR 0 1
104457: PUSH
104458: LD_VAR 0 2
104462: PUSH
104463: FOR_IN
104464: IFFALSE 104480
// SetFuel ( i , 0 ) ;
104466: LD_VAR 0 1
104470: PPUSH
104471: LD_INT 0
104473: PPUSH
104474: CALL_OW 240
104478: GO 104463
104480: POP
104481: POP
// end ;
104482: PPOPN 2
104484: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
104485: LD_EXP 77
104489: PUSH
104490: LD_EXP 113
104494: AND
104495: IFFALSE 104561
104497: GO 104499
104499: DISABLE
104500: LD_INT 0
104502: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
104503: LD_ADDR_VAR 0 1
104507: PUSH
104508: LD_INT 22
104510: PUSH
104511: LD_OWVAR 2
104515: PUSH
104516: EMPTY
104517: LIST
104518: LIST
104519: PUSH
104520: LD_INT 30
104522: PUSH
104523: LD_INT 29
104525: PUSH
104526: EMPTY
104527: LIST
104528: LIST
104529: PUSH
104530: EMPTY
104531: LIST
104532: LIST
104533: PPUSH
104534: CALL_OW 69
104538: ST_TO_ADDR
// if not tmp then
104539: LD_VAR 0 1
104543: NOT
104544: IFFALSE 104548
// exit ;
104546: GO 104561
// DestroyUnit ( tmp [ 1 ] ) ;
104548: LD_VAR 0 1
104552: PUSH
104553: LD_INT 1
104555: ARRAY
104556: PPUSH
104557: CALL_OW 65
// end ;
104561: PPOPN 1
104563: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
104564: LD_EXP 77
104568: PUSH
104569: LD_EXP 115
104573: AND
104574: IFFALSE 104703
104576: GO 104578
104578: DISABLE
104579: LD_INT 0
104581: PPUSH
// begin uc_side := 0 ;
104582: LD_ADDR_OWVAR 20
104586: PUSH
104587: LD_INT 0
104589: ST_TO_ADDR
// uc_nation := nation_arabian ;
104590: LD_ADDR_OWVAR 21
104594: PUSH
104595: LD_INT 2
104597: ST_TO_ADDR
// hc_gallery :=  ;
104598: LD_ADDR_OWVAR 33
104602: PUSH
104603: LD_STRING 
104605: ST_TO_ADDR
// hc_name :=  ;
104606: LD_ADDR_OWVAR 26
104610: PUSH
104611: LD_STRING 
104613: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
104614: LD_INT 1
104616: PPUSH
104617: LD_INT 11
104619: PPUSH
104620: LD_INT 10
104622: PPUSH
104623: CALL_OW 380
// un := CreateHuman ;
104627: LD_ADDR_VAR 0 1
104631: PUSH
104632: CALL_OW 44
104636: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
104637: LD_VAR 0 1
104641: PPUSH
104642: LD_INT 1
104644: PPUSH
104645: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
104649: LD_INT 35
104651: PPUSH
104652: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
104656: LD_VAR 0 1
104660: PPUSH
104661: LD_INT 22
104663: PUSH
104664: LD_OWVAR 2
104668: PUSH
104669: EMPTY
104670: LIST
104671: LIST
104672: PPUSH
104673: CALL_OW 69
104677: PPUSH
104678: LD_VAR 0 1
104682: PPUSH
104683: CALL_OW 74
104687: PPUSH
104688: CALL_OW 115
// until IsDead ( un ) ;
104692: LD_VAR 0 1
104696: PPUSH
104697: CALL_OW 301
104701: IFFALSE 104649
// end ;
104703: PPOPN 1
104705: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
104706: LD_EXP 77
104710: PUSH
104711: LD_EXP 117
104715: AND
104716: IFFALSE 104728
104718: GO 104720
104720: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
104721: LD_STRING earthquake(getX(game), 0, 32)
104723: PPUSH
104724: CALL_OW 559
104728: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
104729: LD_EXP 77
104733: PUSH
104734: LD_EXP 118
104738: AND
104739: IFFALSE 104830
104741: GO 104743
104743: DISABLE
104744: LD_INT 0
104746: PPUSH
// begin enable ;
104747: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
104748: LD_ADDR_VAR 0 1
104752: PUSH
104753: LD_INT 22
104755: PUSH
104756: LD_OWVAR 2
104760: PUSH
104761: EMPTY
104762: LIST
104763: LIST
104764: PUSH
104765: LD_INT 21
104767: PUSH
104768: LD_INT 2
104770: PUSH
104771: EMPTY
104772: LIST
104773: LIST
104774: PUSH
104775: LD_INT 33
104777: PUSH
104778: LD_INT 3
104780: PUSH
104781: EMPTY
104782: LIST
104783: LIST
104784: PUSH
104785: EMPTY
104786: LIST
104787: LIST
104788: LIST
104789: PPUSH
104790: CALL_OW 69
104794: ST_TO_ADDR
// if not tmp then
104795: LD_VAR 0 1
104799: NOT
104800: IFFALSE 104804
// exit ;
104802: GO 104830
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
104804: LD_VAR 0 1
104808: PUSH
104809: LD_INT 1
104811: PPUSH
104812: LD_VAR 0 1
104816: PPUSH
104817: CALL_OW 12
104821: ARRAY
104822: PPUSH
104823: LD_INT 1
104825: PPUSH
104826: CALL_OW 234
// end ;
104830: PPOPN 1
104832: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
104833: LD_EXP 77
104837: PUSH
104838: LD_EXP 119
104842: AND
104843: IFFALSE 104984
104845: GO 104847
104847: DISABLE
104848: LD_INT 0
104850: PPUSH
104851: PPUSH
104852: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
104853: LD_ADDR_VAR 0 3
104857: PUSH
104858: LD_INT 22
104860: PUSH
104861: LD_OWVAR 2
104865: PUSH
104866: EMPTY
104867: LIST
104868: LIST
104869: PUSH
104870: LD_INT 25
104872: PUSH
104873: LD_INT 1
104875: PUSH
104876: EMPTY
104877: LIST
104878: LIST
104879: PUSH
104880: EMPTY
104881: LIST
104882: LIST
104883: PPUSH
104884: CALL_OW 69
104888: ST_TO_ADDR
// if not tmp then
104889: LD_VAR 0 3
104893: NOT
104894: IFFALSE 104898
// exit ;
104896: GO 104984
// un := tmp [ rand ( 1 , tmp ) ] ;
104898: LD_ADDR_VAR 0 2
104902: PUSH
104903: LD_VAR 0 3
104907: PUSH
104908: LD_INT 1
104910: PPUSH
104911: LD_VAR 0 3
104915: PPUSH
104916: CALL_OW 12
104920: ARRAY
104921: ST_TO_ADDR
// if Crawls ( un ) then
104922: LD_VAR 0 2
104926: PPUSH
104927: CALL_OW 318
104931: IFFALSE 104942
// ComWalk ( un ) ;
104933: LD_VAR 0 2
104937: PPUSH
104938: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
104942: LD_VAR 0 2
104946: PPUSH
104947: LD_INT 9
104949: PPUSH
104950: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
104954: LD_INT 28
104956: PPUSH
104957: LD_OWVAR 2
104961: PPUSH
104962: LD_INT 2
104964: PPUSH
104965: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
104969: LD_INT 29
104971: PPUSH
104972: LD_OWVAR 2
104976: PPUSH
104977: LD_INT 2
104979: PPUSH
104980: CALL_OW 322
// end ;
104984: PPOPN 3
104986: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
104987: LD_EXP 77
104991: PUSH
104992: LD_EXP 120
104996: AND
104997: IFFALSE 105108
104999: GO 105001
105001: DISABLE
105002: LD_INT 0
105004: PPUSH
105005: PPUSH
105006: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
105007: LD_ADDR_VAR 0 3
105011: PUSH
105012: LD_INT 22
105014: PUSH
105015: LD_OWVAR 2
105019: PUSH
105020: EMPTY
105021: LIST
105022: LIST
105023: PUSH
105024: LD_INT 25
105026: PUSH
105027: LD_INT 1
105029: PUSH
105030: EMPTY
105031: LIST
105032: LIST
105033: PUSH
105034: EMPTY
105035: LIST
105036: LIST
105037: PPUSH
105038: CALL_OW 69
105042: ST_TO_ADDR
// if not tmp then
105043: LD_VAR 0 3
105047: NOT
105048: IFFALSE 105052
// exit ;
105050: GO 105108
// un := tmp [ rand ( 1 , tmp ) ] ;
105052: LD_ADDR_VAR 0 2
105056: PUSH
105057: LD_VAR 0 3
105061: PUSH
105062: LD_INT 1
105064: PPUSH
105065: LD_VAR 0 3
105069: PPUSH
105070: CALL_OW 12
105074: ARRAY
105075: ST_TO_ADDR
// if Crawls ( un ) then
105076: LD_VAR 0 2
105080: PPUSH
105081: CALL_OW 318
105085: IFFALSE 105096
// ComWalk ( un ) ;
105087: LD_VAR 0 2
105091: PPUSH
105092: CALL_OW 138
// SetClass ( un , class_mortar ) ;
105096: LD_VAR 0 2
105100: PPUSH
105101: LD_INT 8
105103: PPUSH
105104: CALL_OW 336
// end ;
105108: PPOPN 3
105110: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
105111: LD_EXP 77
105115: PUSH
105116: LD_EXP 121
105120: AND
105121: IFFALSE 105265
105123: GO 105125
105125: DISABLE
105126: LD_INT 0
105128: PPUSH
105129: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
105130: LD_ADDR_VAR 0 2
105134: PUSH
105135: LD_INT 22
105137: PUSH
105138: LD_OWVAR 2
105142: PUSH
105143: EMPTY
105144: LIST
105145: LIST
105146: PUSH
105147: LD_INT 21
105149: PUSH
105150: LD_INT 2
105152: PUSH
105153: EMPTY
105154: LIST
105155: LIST
105156: PUSH
105157: LD_INT 2
105159: PUSH
105160: LD_INT 34
105162: PUSH
105163: LD_INT 12
105165: PUSH
105166: EMPTY
105167: LIST
105168: LIST
105169: PUSH
105170: LD_INT 34
105172: PUSH
105173: LD_INT 51
105175: PUSH
105176: EMPTY
105177: LIST
105178: LIST
105179: PUSH
105180: LD_INT 34
105182: PUSH
105183: LD_INT 32
105185: PUSH
105186: EMPTY
105187: LIST
105188: LIST
105189: PUSH
105190: EMPTY
105191: LIST
105192: LIST
105193: LIST
105194: LIST
105195: PUSH
105196: EMPTY
105197: LIST
105198: LIST
105199: LIST
105200: PPUSH
105201: CALL_OW 69
105205: ST_TO_ADDR
// if not tmp then
105206: LD_VAR 0 2
105210: NOT
105211: IFFALSE 105215
// exit ;
105213: GO 105265
// for i in tmp do
105215: LD_ADDR_VAR 0 1
105219: PUSH
105220: LD_VAR 0 2
105224: PUSH
105225: FOR_IN
105226: IFFALSE 105263
// if GetCargo ( i , mat_artifact ) = 0 then
105228: LD_VAR 0 1
105232: PPUSH
105233: LD_INT 4
105235: PPUSH
105236: CALL_OW 289
105240: PUSH
105241: LD_INT 0
105243: EQUAL
105244: IFFALSE 105261
// SetCargo ( i , mat_siberit , 100 ) ;
105246: LD_VAR 0 1
105250: PPUSH
105251: LD_INT 3
105253: PPUSH
105254: LD_INT 100
105256: PPUSH
105257: CALL_OW 290
105261: GO 105225
105263: POP
105264: POP
// end ;
105265: PPOPN 2
105267: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
105268: LD_EXP 77
105272: PUSH
105273: LD_EXP 122
105277: AND
105278: IFFALSE 105461
105280: GO 105282
105282: DISABLE
105283: LD_INT 0
105285: PPUSH
105286: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
105287: LD_ADDR_VAR 0 2
105291: PUSH
105292: LD_INT 22
105294: PUSH
105295: LD_OWVAR 2
105299: PUSH
105300: EMPTY
105301: LIST
105302: LIST
105303: PPUSH
105304: CALL_OW 69
105308: ST_TO_ADDR
// if not tmp then
105309: LD_VAR 0 2
105313: NOT
105314: IFFALSE 105318
// exit ;
105316: GO 105461
// for i := 1 to 2 do
105318: LD_ADDR_VAR 0 1
105322: PUSH
105323: DOUBLE
105324: LD_INT 1
105326: DEC
105327: ST_TO_ADDR
105328: LD_INT 2
105330: PUSH
105331: FOR_TO
105332: IFFALSE 105459
// begin uc_side := your_side ;
105334: LD_ADDR_OWVAR 20
105338: PUSH
105339: LD_OWVAR 2
105343: ST_TO_ADDR
// uc_nation := nation_american ;
105344: LD_ADDR_OWVAR 21
105348: PUSH
105349: LD_INT 1
105351: ST_TO_ADDR
// vc_chassis := us_morphling ;
105352: LD_ADDR_OWVAR 37
105356: PUSH
105357: LD_INT 5
105359: ST_TO_ADDR
// vc_engine := engine_siberite ;
105360: LD_ADDR_OWVAR 39
105364: PUSH
105365: LD_INT 3
105367: ST_TO_ADDR
// vc_control := control_computer ;
105368: LD_ADDR_OWVAR 38
105372: PUSH
105373: LD_INT 3
105375: ST_TO_ADDR
// vc_weapon := us_double_laser ;
105376: LD_ADDR_OWVAR 40
105380: PUSH
105381: LD_INT 10
105383: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
105384: LD_VAR 0 2
105388: PUSH
105389: LD_INT 1
105391: ARRAY
105392: PPUSH
105393: CALL_OW 310
105397: NOT
105398: IFFALSE 105445
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
105400: CALL_OW 45
105404: PPUSH
105405: LD_VAR 0 2
105409: PUSH
105410: LD_INT 1
105412: ARRAY
105413: PPUSH
105414: CALL_OW 250
105418: PPUSH
105419: LD_VAR 0 2
105423: PUSH
105424: LD_INT 1
105426: ARRAY
105427: PPUSH
105428: CALL_OW 251
105432: PPUSH
105433: LD_INT 12
105435: PPUSH
105436: LD_INT 1
105438: PPUSH
105439: CALL_OW 50
105443: GO 105457
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
105445: CALL_OW 45
105449: PPUSH
105450: LD_INT 1
105452: PPUSH
105453: CALL_OW 51
// end ;
105457: GO 105331
105459: POP
105460: POP
// end ;
105461: PPOPN 2
105463: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
105464: LD_EXP 77
105468: PUSH
105469: LD_EXP 123
105473: AND
105474: IFFALSE 105696
105476: GO 105478
105478: DISABLE
105479: LD_INT 0
105481: PPUSH
105482: PPUSH
105483: PPUSH
105484: PPUSH
105485: PPUSH
105486: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
105487: LD_ADDR_VAR 0 6
105491: PUSH
105492: LD_INT 22
105494: PUSH
105495: LD_OWVAR 2
105499: PUSH
105500: EMPTY
105501: LIST
105502: LIST
105503: PUSH
105504: LD_INT 21
105506: PUSH
105507: LD_INT 1
105509: PUSH
105510: EMPTY
105511: LIST
105512: LIST
105513: PUSH
105514: LD_INT 3
105516: PUSH
105517: LD_INT 23
105519: PUSH
105520: LD_INT 0
105522: PUSH
105523: EMPTY
105524: LIST
105525: LIST
105526: PUSH
105527: EMPTY
105528: LIST
105529: LIST
105530: PUSH
105531: EMPTY
105532: LIST
105533: LIST
105534: LIST
105535: PPUSH
105536: CALL_OW 69
105540: ST_TO_ADDR
// if not tmp then
105541: LD_VAR 0 6
105545: NOT
105546: IFFALSE 105550
// exit ;
105548: GO 105696
// s1 := rand ( 1 , 4 ) ;
105550: LD_ADDR_VAR 0 2
105554: PUSH
105555: LD_INT 1
105557: PPUSH
105558: LD_INT 4
105560: PPUSH
105561: CALL_OW 12
105565: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
105566: LD_ADDR_VAR 0 4
105570: PUSH
105571: LD_VAR 0 6
105575: PUSH
105576: LD_INT 1
105578: ARRAY
105579: PPUSH
105580: LD_VAR 0 2
105584: PPUSH
105585: CALL_OW 259
105589: ST_TO_ADDR
// if s1 = 1 then
105590: LD_VAR 0 2
105594: PUSH
105595: LD_INT 1
105597: EQUAL
105598: IFFALSE 105618
// s2 := rand ( 2 , 4 ) else
105600: LD_ADDR_VAR 0 3
105604: PUSH
105605: LD_INT 2
105607: PPUSH
105608: LD_INT 4
105610: PPUSH
105611: CALL_OW 12
105615: ST_TO_ADDR
105616: GO 105626
// s2 := 1 ;
105618: LD_ADDR_VAR 0 3
105622: PUSH
105623: LD_INT 1
105625: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
105626: LD_ADDR_VAR 0 5
105630: PUSH
105631: LD_VAR 0 6
105635: PUSH
105636: LD_INT 1
105638: ARRAY
105639: PPUSH
105640: LD_VAR 0 3
105644: PPUSH
105645: CALL_OW 259
105649: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
105650: LD_VAR 0 6
105654: PUSH
105655: LD_INT 1
105657: ARRAY
105658: PPUSH
105659: LD_VAR 0 2
105663: PPUSH
105664: LD_VAR 0 5
105668: PPUSH
105669: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
105673: LD_VAR 0 6
105677: PUSH
105678: LD_INT 1
105680: ARRAY
105681: PPUSH
105682: LD_VAR 0 3
105686: PPUSH
105687: LD_VAR 0 4
105691: PPUSH
105692: CALL_OW 237
// end ;
105696: PPOPN 6
105698: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
105699: LD_EXP 77
105703: PUSH
105704: LD_EXP 124
105708: AND
105709: IFFALSE 105788
105711: GO 105713
105713: DISABLE
105714: LD_INT 0
105716: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
105717: LD_ADDR_VAR 0 1
105721: PUSH
105722: LD_INT 22
105724: PUSH
105725: LD_OWVAR 2
105729: PUSH
105730: EMPTY
105731: LIST
105732: LIST
105733: PUSH
105734: LD_INT 30
105736: PUSH
105737: LD_INT 3
105739: PUSH
105740: EMPTY
105741: LIST
105742: LIST
105743: PUSH
105744: EMPTY
105745: LIST
105746: LIST
105747: PPUSH
105748: CALL_OW 69
105752: ST_TO_ADDR
// if not tmp then
105753: LD_VAR 0 1
105757: NOT
105758: IFFALSE 105762
// exit ;
105760: GO 105788
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
105762: LD_VAR 0 1
105766: PUSH
105767: LD_INT 1
105769: PPUSH
105770: LD_VAR 0 1
105774: PPUSH
105775: CALL_OW 12
105779: ARRAY
105780: PPUSH
105781: LD_INT 1
105783: PPUSH
105784: CALL_OW 234
// end ;
105788: PPOPN 1
105790: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
105791: LD_EXP 77
105795: PUSH
105796: LD_EXP 125
105800: AND
105801: IFFALSE 105913
105803: GO 105805
105805: DISABLE
105806: LD_INT 0
105808: PPUSH
105809: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
105810: LD_ADDR_VAR 0 2
105814: PUSH
105815: LD_INT 22
105817: PUSH
105818: LD_OWVAR 2
105822: PUSH
105823: EMPTY
105824: LIST
105825: LIST
105826: PUSH
105827: LD_INT 2
105829: PUSH
105830: LD_INT 30
105832: PUSH
105833: LD_INT 27
105835: PUSH
105836: EMPTY
105837: LIST
105838: LIST
105839: PUSH
105840: LD_INT 30
105842: PUSH
105843: LD_INT 26
105845: PUSH
105846: EMPTY
105847: LIST
105848: LIST
105849: PUSH
105850: LD_INT 30
105852: PUSH
105853: LD_INT 28
105855: PUSH
105856: EMPTY
105857: LIST
105858: LIST
105859: PUSH
105860: EMPTY
105861: LIST
105862: LIST
105863: LIST
105864: LIST
105865: PUSH
105866: EMPTY
105867: LIST
105868: LIST
105869: PPUSH
105870: CALL_OW 69
105874: ST_TO_ADDR
// if not tmp then
105875: LD_VAR 0 2
105879: NOT
105880: IFFALSE 105884
// exit ;
105882: GO 105913
// for i in tmp do
105884: LD_ADDR_VAR 0 1
105888: PUSH
105889: LD_VAR 0 2
105893: PUSH
105894: FOR_IN
105895: IFFALSE 105911
// SetLives ( i , 1 ) ;
105897: LD_VAR 0 1
105901: PPUSH
105902: LD_INT 1
105904: PPUSH
105905: CALL_OW 234
105909: GO 105894
105911: POP
105912: POP
// end ;
105913: PPOPN 2
105915: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
105916: LD_EXP 77
105920: PUSH
105921: LD_EXP 126
105925: AND
105926: IFFALSE 106213
105928: GO 105930
105930: DISABLE
105931: LD_INT 0
105933: PPUSH
105934: PPUSH
105935: PPUSH
// begin i := rand ( 1 , 7 ) ;
105936: LD_ADDR_VAR 0 1
105940: PUSH
105941: LD_INT 1
105943: PPUSH
105944: LD_INT 7
105946: PPUSH
105947: CALL_OW 12
105951: ST_TO_ADDR
// case i of 1 :
105952: LD_VAR 0 1
105956: PUSH
105957: LD_INT 1
105959: DOUBLE
105960: EQUAL
105961: IFTRUE 105965
105963: GO 105975
105965: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
105966: LD_STRING earthquake(getX(game), 0, 32)
105968: PPUSH
105969: CALL_OW 559
105973: GO 106213
105975: LD_INT 2
105977: DOUBLE
105978: EQUAL
105979: IFTRUE 105983
105981: GO 105997
105983: POP
// begin ToLua ( displayStucuk(); ) ;
105984: LD_STRING displayStucuk();
105986: PPUSH
105987: CALL_OW 559
// ResetFog ;
105991: CALL_OW 335
// end ; 3 :
105995: GO 106213
105997: LD_INT 3
105999: DOUBLE
106000: EQUAL
106001: IFTRUE 106005
106003: GO 106109
106005: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
106006: LD_ADDR_VAR 0 2
106010: PUSH
106011: LD_INT 22
106013: PUSH
106014: LD_OWVAR 2
106018: PUSH
106019: EMPTY
106020: LIST
106021: LIST
106022: PUSH
106023: LD_INT 25
106025: PUSH
106026: LD_INT 1
106028: PUSH
106029: EMPTY
106030: LIST
106031: LIST
106032: PUSH
106033: EMPTY
106034: LIST
106035: LIST
106036: PPUSH
106037: CALL_OW 69
106041: ST_TO_ADDR
// if not tmp then
106042: LD_VAR 0 2
106046: NOT
106047: IFFALSE 106051
// exit ;
106049: GO 106213
// un := tmp [ rand ( 1 , tmp ) ] ;
106051: LD_ADDR_VAR 0 3
106055: PUSH
106056: LD_VAR 0 2
106060: PUSH
106061: LD_INT 1
106063: PPUSH
106064: LD_VAR 0 2
106068: PPUSH
106069: CALL_OW 12
106073: ARRAY
106074: ST_TO_ADDR
// if Crawls ( un ) then
106075: LD_VAR 0 3
106079: PPUSH
106080: CALL_OW 318
106084: IFFALSE 106095
// ComWalk ( un ) ;
106086: LD_VAR 0 3
106090: PPUSH
106091: CALL_OW 138
// SetClass ( un , class_mortar ) ;
106095: LD_VAR 0 3
106099: PPUSH
106100: LD_INT 8
106102: PPUSH
106103: CALL_OW 336
// end ; 4 :
106107: GO 106213
106109: LD_INT 4
106111: DOUBLE
106112: EQUAL
106113: IFTRUE 106117
106115: GO 106191
106117: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
106118: LD_ADDR_VAR 0 2
106122: PUSH
106123: LD_INT 22
106125: PUSH
106126: LD_OWVAR 2
106130: PUSH
106131: EMPTY
106132: LIST
106133: LIST
106134: PUSH
106135: LD_INT 30
106137: PUSH
106138: LD_INT 29
106140: PUSH
106141: EMPTY
106142: LIST
106143: LIST
106144: PUSH
106145: EMPTY
106146: LIST
106147: LIST
106148: PPUSH
106149: CALL_OW 69
106153: ST_TO_ADDR
// if not tmp then
106154: LD_VAR 0 2
106158: NOT
106159: IFFALSE 106163
// exit ;
106161: GO 106213
// CenterNowOnUnits ( tmp [ 1 ] ) ;
106163: LD_VAR 0 2
106167: PUSH
106168: LD_INT 1
106170: ARRAY
106171: PPUSH
106172: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
106176: LD_VAR 0 2
106180: PUSH
106181: LD_INT 1
106183: ARRAY
106184: PPUSH
106185: CALL_OW 65
// end ; 5 .. 7 :
106189: GO 106213
106191: LD_INT 5
106193: DOUBLE
106194: GREATEREQUAL
106195: IFFALSE 106203
106197: LD_INT 7
106199: DOUBLE
106200: LESSEQUAL
106201: IFTRUE 106205
106203: GO 106212
106205: POP
// StreamSibBomb ; end ;
106206: CALL 102450 0 0
106210: GO 106213
106212: POP
// end ;
106213: PPOPN 3
106215: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
106216: LD_EXP 77
106220: PUSH
106221: LD_EXP 127
106225: AND
106226: IFFALSE 106382
106228: GO 106230
106230: DISABLE
106231: LD_INT 0
106233: PPUSH
106234: PPUSH
106235: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
106236: LD_ADDR_VAR 0 2
106240: PUSH
106241: LD_INT 81
106243: PUSH
106244: LD_OWVAR 2
106248: PUSH
106249: EMPTY
106250: LIST
106251: LIST
106252: PUSH
106253: LD_INT 2
106255: PUSH
106256: LD_INT 21
106258: PUSH
106259: LD_INT 1
106261: PUSH
106262: EMPTY
106263: LIST
106264: LIST
106265: PUSH
106266: LD_INT 21
106268: PUSH
106269: LD_INT 2
106271: PUSH
106272: EMPTY
106273: LIST
106274: LIST
106275: PUSH
106276: EMPTY
106277: LIST
106278: LIST
106279: LIST
106280: PUSH
106281: EMPTY
106282: LIST
106283: LIST
106284: PPUSH
106285: CALL_OW 69
106289: ST_TO_ADDR
// if not tmp then
106290: LD_VAR 0 2
106294: NOT
106295: IFFALSE 106299
// exit ;
106297: GO 106382
// p := 0 ;
106299: LD_ADDR_VAR 0 3
106303: PUSH
106304: LD_INT 0
106306: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
106307: LD_INT 35
106309: PPUSH
106310: CALL_OW 67
// p := p + 1 ;
106314: LD_ADDR_VAR 0 3
106318: PUSH
106319: LD_VAR 0 3
106323: PUSH
106324: LD_INT 1
106326: PLUS
106327: ST_TO_ADDR
// for i in tmp do
106328: LD_ADDR_VAR 0 1
106332: PUSH
106333: LD_VAR 0 2
106337: PUSH
106338: FOR_IN
106339: IFFALSE 106370
// if GetLives ( i ) < 1000 then
106341: LD_VAR 0 1
106345: PPUSH
106346: CALL_OW 256
106350: PUSH
106351: LD_INT 1000
106353: LESS
106354: IFFALSE 106368
// SetLives ( i , 1000 ) ;
106356: LD_VAR 0 1
106360: PPUSH
106361: LD_INT 1000
106363: PPUSH
106364: CALL_OW 234
106368: GO 106338
106370: POP
106371: POP
// until p > 20 ;
106372: LD_VAR 0 3
106376: PUSH
106377: LD_INT 20
106379: GREATER
106380: IFFALSE 106307
// end ;
106382: PPOPN 3
106384: END
// every 0 0$1 trigger StreamModeActive and sTime do
106385: LD_EXP 77
106389: PUSH
106390: LD_EXP 128
106394: AND
106395: IFFALSE 106430
106397: GO 106399
106399: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
106400: LD_INT 28
106402: PPUSH
106403: LD_OWVAR 2
106407: PPUSH
106408: LD_INT 2
106410: PPUSH
106411: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
106415: LD_INT 30
106417: PPUSH
106418: LD_OWVAR 2
106422: PPUSH
106423: LD_INT 2
106425: PPUSH
106426: CALL_OW 322
// end ;
106430: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
106431: LD_EXP 77
106435: PUSH
106436: LD_EXP 129
106440: AND
106441: IFFALSE 106562
106443: GO 106445
106445: DISABLE
106446: LD_INT 0
106448: PPUSH
106449: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
106450: LD_ADDR_VAR 0 2
106454: PUSH
106455: LD_INT 22
106457: PUSH
106458: LD_OWVAR 2
106462: PUSH
106463: EMPTY
106464: LIST
106465: LIST
106466: PUSH
106467: LD_INT 21
106469: PUSH
106470: LD_INT 1
106472: PUSH
106473: EMPTY
106474: LIST
106475: LIST
106476: PUSH
106477: LD_INT 3
106479: PUSH
106480: LD_INT 23
106482: PUSH
106483: LD_INT 0
106485: PUSH
106486: EMPTY
106487: LIST
106488: LIST
106489: PUSH
106490: EMPTY
106491: LIST
106492: LIST
106493: PUSH
106494: EMPTY
106495: LIST
106496: LIST
106497: LIST
106498: PPUSH
106499: CALL_OW 69
106503: ST_TO_ADDR
// if not tmp then
106504: LD_VAR 0 2
106508: NOT
106509: IFFALSE 106513
// exit ;
106511: GO 106562
// for i in tmp do
106513: LD_ADDR_VAR 0 1
106517: PUSH
106518: LD_VAR 0 2
106522: PUSH
106523: FOR_IN
106524: IFFALSE 106560
// begin if Crawls ( i ) then
106526: LD_VAR 0 1
106530: PPUSH
106531: CALL_OW 318
106535: IFFALSE 106546
// ComWalk ( i ) ;
106537: LD_VAR 0 1
106541: PPUSH
106542: CALL_OW 138
// SetClass ( i , 2 ) ;
106546: LD_VAR 0 1
106550: PPUSH
106551: LD_INT 2
106553: PPUSH
106554: CALL_OW 336
// end ;
106558: GO 106523
106560: POP
106561: POP
// end ;
106562: PPOPN 2
106564: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
106565: LD_EXP 77
106569: PUSH
106570: LD_EXP 130
106574: AND
106575: IFFALSE 106863
106577: GO 106579
106579: DISABLE
106580: LD_INT 0
106582: PPUSH
106583: PPUSH
106584: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
106585: LD_OWVAR 2
106589: PPUSH
106590: LD_INT 9
106592: PPUSH
106593: LD_INT 1
106595: PPUSH
106596: LD_INT 1
106598: PPUSH
106599: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
106603: LD_INT 9
106605: PPUSH
106606: LD_OWVAR 2
106610: PPUSH
106611: CALL_OW 343
// uc_side := 9 ;
106615: LD_ADDR_OWVAR 20
106619: PUSH
106620: LD_INT 9
106622: ST_TO_ADDR
// uc_nation := 2 ;
106623: LD_ADDR_OWVAR 21
106627: PUSH
106628: LD_INT 2
106630: ST_TO_ADDR
// hc_name := Dark Warrior ;
106631: LD_ADDR_OWVAR 26
106635: PUSH
106636: LD_STRING Dark Warrior
106638: ST_TO_ADDR
// hc_gallery :=  ;
106639: LD_ADDR_OWVAR 33
106643: PUSH
106644: LD_STRING 
106646: ST_TO_ADDR
// hc_noskilllimit := true ;
106647: LD_ADDR_OWVAR 76
106651: PUSH
106652: LD_INT 1
106654: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
106655: LD_ADDR_OWVAR 31
106659: PUSH
106660: LD_INT 30
106662: PUSH
106663: LD_INT 30
106665: PUSH
106666: LD_INT 30
106668: PUSH
106669: LD_INT 30
106671: PUSH
106672: EMPTY
106673: LIST
106674: LIST
106675: LIST
106676: LIST
106677: ST_TO_ADDR
// un := CreateHuman ;
106678: LD_ADDR_VAR 0 3
106682: PUSH
106683: CALL_OW 44
106687: ST_TO_ADDR
// hc_noskilllimit := false ;
106688: LD_ADDR_OWVAR 76
106692: PUSH
106693: LD_INT 0
106695: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
106696: LD_VAR 0 3
106700: PPUSH
106701: LD_INT 1
106703: PPUSH
106704: CALL_OW 51
// ToLua ( playRanger() ) ;
106708: LD_STRING playRanger()
106710: PPUSH
106711: CALL_OW 559
// p := 0 ;
106715: LD_ADDR_VAR 0 2
106719: PUSH
106720: LD_INT 0
106722: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
106723: LD_INT 35
106725: PPUSH
106726: CALL_OW 67
// p := p + 1 ;
106730: LD_ADDR_VAR 0 2
106734: PUSH
106735: LD_VAR 0 2
106739: PUSH
106740: LD_INT 1
106742: PLUS
106743: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
106744: LD_VAR 0 3
106748: PPUSH
106749: CALL_OW 256
106753: PUSH
106754: LD_INT 1000
106756: LESS
106757: IFFALSE 106771
// SetLives ( un , 1000 ) ;
106759: LD_VAR 0 3
106763: PPUSH
106764: LD_INT 1000
106766: PPUSH
106767: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
106771: LD_VAR 0 3
106775: PPUSH
106776: LD_INT 81
106778: PUSH
106779: LD_OWVAR 2
106783: PUSH
106784: EMPTY
106785: LIST
106786: LIST
106787: PUSH
106788: LD_INT 91
106790: PUSH
106791: LD_VAR 0 3
106795: PUSH
106796: LD_INT 30
106798: PUSH
106799: EMPTY
106800: LIST
106801: LIST
106802: LIST
106803: PUSH
106804: EMPTY
106805: LIST
106806: LIST
106807: PPUSH
106808: CALL_OW 69
106812: PPUSH
106813: LD_VAR 0 3
106817: PPUSH
106818: CALL_OW 74
106822: PPUSH
106823: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
106827: LD_VAR 0 2
106831: PUSH
106832: LD_INT 80
106834: GREATER
106835: PUSH
106836: LD_VAR 0 3
106840: PPUSH
106841: CALL_OW 301
106845: OR
106846: IFFALSE 106723
// if un then
106848: LD_VAR 0 3
106852: IFFALSE 106863
// RemoveUnit ( un ) ;
106854: LD_VAR 0 3
106858: PPUSH
106859: CALL_OW 64
// end ;
106863: PPOPN 3
106865: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
106866: LD_EXP 131
106870: IFFALSE 106986
106872: GO 106874
106874: DISABLE
106875: LD_INT 0
106877: PPUSH
106878: PPUSH
106879: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
106880: LD_ADDR_VAR 0 2
106884: PUSH
106885: LD_INT 81
106887: PUSH
106888: LD_OWVAR 2
106892: PUSH
106893: EMPTY
106894: LIST
106895: LIST
106896: PUSH
106897: LD_INT 21
106899: PUSH
106900: LD_INT 1
106902: PUSH
106903: EMPTY
106904: LIST
106905: LIST
106906: PUSH
106907: EMPTY
106908: LIST
106909: LIST
106910: PPUSH
106911: CALL_OW 69
106915: ST_TO_ADDR
// ToLua ( playComputer() ) ;
106916: LD_STRING playComputer()
106918: PPUSH
106919: CALL_OW 559
// if not tmp then
106923: LD_VAR 0 2
106927: NOT
106928: IFFALSE 106932
// exit ;
106930: GO 106986
// for i in tmp do
106932: LD_ADDR_VAR 0 1
106936: PUSH
106937: LD_VAR 0 2
106941: PUSH
106942: FOR_IN
106943: IFFALSE 106984
// for j := 1 to 4 do
106945: LD_ADDR_VAR 0 3
106949: PUSH
106950: DOUBLE
106951: LD_INT 1
106953: DEC
106954: ST_TO_ADDR
106955: LD_INT 4
106957: PUSH
106958: FOR_TO
106959: IFFALSE 106980
// SetSkill ( i , j , 10 ) ;
106961: LD_VAR 0 1
106965: PPUSH
106966: LD_VAR 0 3
106970: PPUSH
106971: LD_INT 10
106973: PPUSH
106974: CALL_OW 237
106978: GO 106958
106980: POP
106981: POP
106982: GO 106942
106984: POP
106985: POP
// end ;
106986: PPOPN 3
106988: END
// every 0 0$1 trigger s30 do var i , tmp ;
106989: LD_EXP 132
106993: IFFALSE 107062
106995: GO 106997
106997: DISABLE
106998: LD_INT 0
107000: PPUSH
107001: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
107002: LD_ADDR_VAR 0 2
107006: PUSH
107007: LD_INT 22
107009: PUSH
107010: LD_OWVAR 2
107014: PUSH
107015: EMPTY
107016: LIST
107017: LIST
107018: PPUSH
107019: CALL_OW 69
107023: ST_TO_ADDR
// if not tmp then
107024: LD_VAR 0 2
107028: NOT
107029: IFFALSE 107033
// exit ;
107031: GO 107062
// for i in tmp do
107033: LD_ADDR_VAR 0 1
107037: PUSH
107038: LD_VAR 0 2
107042: PUSH
107043: FOR_IN
107044: IFFALSE 107060
// SetLives ( i , 300 ) ;
107046: LD_VAR 0 1
107050: PPUSH
107051: LD_INT 300
107053: PPUSH
107054: CALL_OW 234
107058: GO 107043
107060: POP
107061: POP
// end ;
107062: PPOPN 2
107064: END
// every 0 0$1 trigger s60 do var i , tmp ;
107065: LD_EXP 133
107069: IFFALSE 107138
107071: GO 107073
107073: DISABLE
107074: LD_INT 0
107076: PPUSH
107077: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
107078: LD_ADDR_VAR 0 2
107082: PUSH
107083: LD_INT 22
107085: PUSH
107086: LD_OWVAR 2
107090: PUSH
107091: EMPTY
107092: LIST
107093: LIST
107094: PPUSH
107095: CALL_OW 69
107099: ST_TO_ADDR
// if not tmp then
107100: LD_VAR 0 2
107104: NOT
107105: IFFALSE 107109
// exit ;
107107: GO 107138
// for i in tmp do
107109: LD_ADDR_VAR 0 1
107113: PUSH
107114: LD_VAR 0 2
107118: PUSH
107119: FOR_IN
107120: IFFALSE 107136
// SetLives ( i , 600 ) ;
107122: LD_VAR 0 1
107126: PPUSH
107127: LD_INT 600
107129: PPUSH
107130: CALL_OW 234
107134: GO 107119
107136: POP
107137: POP
// end ;
107138: PPOPN 2
107140: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
107141: LD_INT 0
107143: PPUSH
// case cmd of 301 :
107144: LD_VAR 0 1
107148: PUSH
107149: LD_INT 301
107151: DOUBLE
107152: EQUAL
107153: IFTRUE 107157
107155: GO 107189
107157: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
107158: LD_VAR 0 6
107162: PPUSH
107163: LD_VAR 0 7
107167: PPUSH
107168: LD_VAR 0 8
107172: PPUSH
107173: LD_VAR 0 4
107177: PPUSH
107178: LD_VAR 0 5
107182: PPUSH
107183: CALL 108390 0 5
107187: GO 107310
107189: LD_INT 302
107191: DOUBLE
107192: EQUAL
107193: IFTRUE 107197
107195: GO 107234
107197: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
107198: LD_VAR 0 6
107202: PPUSH
107203: LD_VAR 0 7
107207: PPUSH
107208: LD_VAR 0 8
107212: PPUSH
107213: LD_VAR 0 9
107217: PPUSH
107218: LD_VAR 0 4
107222: PPUSH
107223: LD_VAR 0 5
107227: PPUSH
107228: CALL 108481 0 6
107232: GO 107310
107234: LD_INT 303
107236: DOUBLE
107237: EQUAL
107238: IFTRUE 107242
107240: GO 107279
107242: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
107243: LD_VAR 0 6
107247: PPUSH
107248: LD_VAR 0 7
107252: PPUSH
107253: LD_VAR 0 8
107257: PPUSH
107258: LD_VAR 0 9
107262: PPUSH
107263: LD_VAR 0 4
107267: PPUSH
107268: LD_VAR 0 5
107272: PPUSH
107273: CALL 107315 0 6
107277: GO 107310
107279: LD_INT 304
107281: DOUBLE
107282: EQUAL
107283: IFTRUE 107287
107285: GO 107309
107287: POP
// hHackTeleport ( unit , x , y ) ; end ;
107288: LD_VAR 0 2
107292: PPUSH
107293: LD_VAR 0 4
107297: PPUSH
107298: LD_VAR 0 5
107302: PPUSH
107303: CALL 109074 0 3
107307: GO 107310
107309: POP
// end ;
107310: LD_VAR 0 12
107314: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
107315: LD_INT 0
107317: PPUSH
107318: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
107319: LD_VAR 0 1
107323: PUSH
107324: LD_INT 1
107326: LESS
107327: PUSH
107328: LD_VAR 0 1
107332: PUSH
107333: LD_INT 3
107335: GREATER
107336: OR
107337: PUSH
107338: LD_VAR 0 5
107342: PPUSH
107343: LD_VAR 0 6
107347: PPUSH
107348: CALL_OW 428
107352: OR
107353: IFFALSE 107357
// exit ;
107355: GO 108077
// uc_side := your_side ;
107357: LD_ADDR_OWVAR 20
107361: PUSH
107362: LD_OWVAR 2
107366: ST_TO_ADDR
// uc_nation := nation ;
107367: LD_ADDR_OWVAR 21
107371: PUSH
107372: LD_VAR 0 1
107376: ST_TO_ADDR
// bc_level = 1 ;
107377: LD_ADDR_OWVAR 43
107381: PUSH
107382: LD_INT 1
107384: ST_TO_ADDR
// case btype of 1 :
107385: LD_VAR 0 2
107389: PUSH
107390: LD_INT 1
107392: DOUBLE
107393: EQUAL
107394: IFTRUE 107398
107396: GO 107409
107398: POP
// bc_type := b_depot ; 2 :
107399: LD_ADDR_OWVAR 42
107403: PUSH
107404: LD_INT 0
107406: ST_TO_ADDR
107407: GO 108021
107409: LD_INT 2
107411: DOUBLE
107412: EQUAL
107413: IFTRUE 107417
107415: GO 107428
107417: POP
// bc_type := b_warehouse ; 3 :
107418: LD_ADDR_OWVAR 42
107422: PUSH
107423: LD_INT 1
107425: ST_TO_ADDR
107426: GO 108021
107428: LD_INT 3
107430: DOUBLE
107431: EQUAL
107432: IFTRUE 107436
107434: GO 107447
107436: POP
// bc_type := b_lab ; 4 .. 9 :
107437: LD_ADDR_OWVAR 42
107441: PUSH
107442: LD_INT 6
107444: ST_TO_ADDR
107445: GO 108021
107447: LD_INT 4
107449: DOUBLE
107450: GREATEREQUAL
107451: IFFALSE 107459
107453: LD_INT 9
107455: DOUBLE
107456: LESSEQUAL
107457: IFTRUE 107461
107459: GO 107513
107461: POP
// begin bc_type := b_lab_half ;
107462: LD_ADDR_OWVAR 42
107466: PUSH
107467: LD_INT 7
107469: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
107470: LD_ADDR_OWVAR 44
107474: PUSH
107475: LD_INT 10
107477: PUSH
107478: LD_INT 11
107480: PUSH
107481: LD_INT 12
107483: PUSH
107484: LD_INT 15
107486: PUSH
107487: LD_INT 14
107489: PUSH
107490: LD_INT 13
107492: PUSH
107493: EMPTY
107494: LIST
107495: LIST
107496: LIST
107497: LIST
107498: LIST
107499: LIST
107500: PUSH
107501: LD_VAR 0 2
107505: PUSH
107506: LD_INT 3
107508: MINUS
107509: ARRAY
107510: ST_TO_ADDR
// end ; 10 .. 13 :
107511: GO 108021
107513: LD_INT 10
107515: DOUBLE
107516: GREATEREQUAL
107517: IFFALSE 107525
107519: LD_INT 13
107521: DOUBLE
107522: LESSEQUAL
107523: IFTRUE 107527
107525: GO 107604
107527: POP
// begin bc_type := b_lab_full ;
107528: LD_ADDR_OWVAR 42
107532: PUSH
107533: LD_INT 8
107535: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
107536: LD_ADDR_OWVAR 44
107540: PUSH
107541: LD_INT 10
107543: PUSH
107544: LD_INT 12
107546: PUSH
107547: LD_INT 14
107549: PUSH
107550: LD_INT 13
107552: PUSH
107553: EMPTY
107554: LIST
107555: LIST
107556: LIST
107557: LIST
107558: PUSH
107559: LD_VAR 0 2
107563: PUSH
107564: LD_INT 9
107566: MINUS
107567: ARRAY
107568: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
107569: LD_ADDR_OWVAR 45
107573: PUSH
107574: LD_INT 11
107576: PUSH
107577: LD_INT 15
107579: PUSH
107580: LD_INT 12
107582: PUSH
107583: LD_INT 15
107585: PUSH
107586: EMPTY
107587: LIST
107588: LIST
107589: LIST
107590: LIST
107591: PUSH
107592: LD_VAR 0 2
107596: PUSH
107597: LD_INT 9
107599: MINUS
107600: ARRAY
107601: ST_TO_ADDR
// end ; 14 :
107602: GO 108021
107604: LD_INT 14
107606: DOUBLE
107607: EQUAL
107608: IFTRUE 107612
107610: GO 107623
107612: POP
// bc_type := b_workshop ; 15 :
107613: LD_ADDR_OWVAR 42
107617: PUSH
107618: LD_INT 2
107620: ST_TO_ADDR
107621: GO 108021
107623: LD_INT 15
107625: DOUBLE
107626: EQUAL
107627: IFTRUE 107631
107629: GO 107642
107631: POP
// bc_type := b_factory ; 16 :
107632: LD_ADDR_OWVAR 42
107636: PUSH
107637: LD_INT 3
107639: ST_TO_ADDR
107640: GO 108021
107642: LD_INT 16
107644: DOUBLE
107645: EQUAL
107646: IFTRUE 107650
107648: GO 107661
107650: POP
// bc_type := b_ext_gun ; 17 :
107651: LD_ADDR_OWVAR 42
107655: PUSH
107656: LD_INT 17
107658: ST_TO_ADDR
107659: GO 108021
107661: LD_INT 17
107663: DOUBLE
107664: EQUAL
107665: IFTRUE 107669
107667: GO 107697
107669: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
107670: LD_ADDR_OWVAR 42
107674: PUSH
107675: LD_INT 19
107677: PUSH
107678: LD_INT 23
107680: PUSH
107681: LD_INT 19
107683: PUSH
107684: EMPTY
107685: LIST
107686: LIST
107687: LIST
107688: PUSH
107689: LD_VAR 0 1
107693: ARRAY
107694: ST_TO_ADDR
107695: GO 108021
107697: LD_INT 18
107699: DOUBLE
107700: EQUAL
107701: IFTRUE 107705
107703: GO 107716
107705: POP
// bc_type := b_ext_radar ; 19 :
107706: LD_ADDR_OWVAR 42
107710: PUSH
107711: LD_INT 20
107713: ST_TO_ADDR
107714: GO 108021
107716: LD_INT 19
107718: DOUBLE
107719: EQUAL
107720: IFTRUE 107724
107722: GO 107735
107724: POP
// bc_type := b_ext_radio ; 20 :
107725: LD_ADDR_OWVAR 42
107729: PUSH
107730: LD_INT 22
107732: ST_TO_ADDR
107733: GO 108021
107735: LD_INT 20
107737: DOUBLE
107738: EQUAL
107739: IFTRUE 107743
107741: GO 107754
107743: POP
// bc_type := b_ext_siberium ; 21 :
107744: LD_ADDR_OWVAR 42
107748: PUSH
107749: LD_INT 21
107751: ST_TO_ADDR
107752: GO 108021
107754: LD_INT 21
107756: DOUBLE
107757: EQUAL
107758: IFTRUE 107762
107760: GO 107773
107762: POP
// bc_type := b_ext_computer ; 22 :
107763: LD_ADDR_OWVAR 42
107767: PUSH
107768: LD_INT 24
107770: ST_TO_ADDR
107771: GO 108021
107773: LD_INT 22
107775: DOUBLE
107776: EQUAL
107777: IFTRUE 107781
107779: GO 107792
107781: POP
// bc_type := b_ext_track ; 23 :
107782: LD_ADDR_OWVAR 42
107786: PUSH
107787: LD_INT 16
107789: ST_TO_ADDR
107790: GO 108021
107792: LD_INT 23
107794: DOUBLE
107795: EQUAL
107796: IFTRUE 107800
107798: GO 107811
107800: POP
// bc_type := b_ext_laser ; 24 :
107801: LD_ADDR_OWVAR 42
107805: PUSH
107806: LD_INT 25
107808: ST_TO_ADDR
107809: GO 108021
107811: LD_INT 24
107813: DOUBLE
107814: EQUAL
107815: IFTRUE 107819
107817: GO 107830
107819: POP
// bc_type := b_control_tower ; 25 :
107820: LD_ADDR_OWVAR 42
107824: PUSH
107825: LD_INT 36
107827: ST_TO_ADDR
107828: GO 108021
107830: LD_INT 25
107832: DOUBLE
107833: EQUAL
107834: IFTRUE 107838
107836: GO 107849
107838: POP
// bc_type := b_breastwork ; 26 :
107839: LD_ADDR_OWVAR 42
107843: PUSH
107844: LD_INT 31
107846: ST_TO_ADDR
107847: GO 108021
107849: LD_INT 26
107851: DOUBLE
107852: EQUAL
107853: IFTRUE 107857
107855: GO 107868
107857: POP
// bc_type := b_bunker ; 27 :
107858: LD_ADDR_OWVAR 42
107862: PUSH
107863: LD_INT 32
107865: ST_TO_ADDR
107866: GO 108021
107868: LD_INT 27
107870: DOUBLE
107871: EQUAL
107872: IFTRUE 107876
107874: GO 107887
107876: POP
// bc_type := b_turret ; 28 :
107877: LD_ADDR_OWVAR 42
107881: PUSH
107882: LD_INT 33
107884: ST_TO_ADDR
107885: GO 108021
107887: LD_INT 28
107889: DOUBLE
107890: EQUAL
107891: IFTRUE 107895
107893: GO 107906
107895: POP
// bc_type := b_armoury ; 29 :
107896: LD_ADDR_OWVAR 42
107900: PUSH
107901: LD_INT 4
107903: ST_TO_ADDR
107904: GO 108021
107906: LD_INT 29
107908: DOUBLE
107909: EQUAL
107910: IFTRUE 107914
107912: GO 107925
107914: POP
// bc_type := b_barracks ; 30 :
107915: LD_ADDR_OWVAR 42
107919: PUSH
107920: LD_INT 5
107922: ST_TO_ADDR
107923: GO 108021
107925: LD_INT 30
107927: DOUBLE
107928: EQUAL
107929: IFTRUE 107933
107931: GO 107944
107933: POP
// bc_type := b_solar_power ; 31 :
107934: LD_ADDR_OWVAR 42
107938: PUSH
107939: LD_INT 27
107941: ST_TO_ADDR
107942: GO 108021
107944: LD_INT 31
107946: DOUBLE
107947: EQUAL
107948: IFTRUE 107952
107950: GO 107963
107952: POP
// bc_type := b_oil_power ; 32 :
107953: LD_ADDR_OWVAR 42
107957: PUSH
107958: LD_INT 26
107960: ST_TO_ADDR
107961: GO 108021
107963: LD_INT 32
107965: DOUBLE
107966: EQUAL
107967: IFTRUE 107971
107969: GO 107982
107971: POP
// bc_type := b_siberite_power ; 33 :
107972: LD_ADDR_OWVAR 42
107976: PUSH
107977: LD_INT 28
107979: ST_TO_ADDR
107980: GO 108021
107982: LD_INT 33
107984: DOUBLE
107985: EQUAL
107986: IFTRUE 107990
107988: GO 108001
107990: POP
// bc_type := b_oil_mine ; 34 :
107991: LD_ADDR_OWVAR 42
107995: PUSH
107996: LD_INT 29
107998: ST_TO_ADDR
107999: GO 108021
108001: LD_INT 34
108003: DOUBLE
108004: EQUAL
108005: IFTRUE 108009
108007: GO 108020
108009: POP
// bc_type := b_siberite_mine ; end ;
108010: LD_ADDR_OWVAR 42
108014: PUSH
108015: LD_INT 30
108017: ST_TO_ADDR
108018: GO 108021
108020: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
108021: LD_ADDR_VAR 0 8
108025: PUSH
108026: LD_VAR 0 5
108030: PPUSH
108031: LD_VAR 0 6
108035: PPUSH
108036: LD_VAR 0 3
108040: PPUSH
108041: CALL_OW 47
108045: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
108046: LD_OWVAR 42
108050: PUSH
108051: LD_INT 32
108053: PUSH
108054: LD_INT 33
108056: PUSH
108057: EMPTY
108058: LIST
108059: LIST
108060: IN
108061: IFFALSE 108077
// PlaceWeaponTurret ( b , weapon ) ;
108063: LD_VAR 0 8
108067: PPUSH
108068: LD_VAR 0 4
108072: PPUSH
108073: CALL_OW 431
// end ;
108077: LD_VAR 0 7
108081: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
108082: LD_INT 0
108084: PPUSH
108085: PPUSH
108086: PPUSH
108087: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
108088: LD_ADDR_VAR 0 4
108092: PUSH
108093: LD_INT 22
108095: PUSH
108096: LD_OWVAR 2
108100: PUSH
108101: EMPTY
108102: LIST
108103: LIST
108104: PUSH
108105: LD_INT 2
108107: PUSH
108108: LD_INT 30
108110: PUSH
108111: LD_INT 0
108113: PUSH
108114: EMPTY
108115: LIST
108116: LIST
108117: PUSH
108118: LD_INT 30
108120: PUSH
108121: LD_INT 1
108123: PUSH
108124: EMPTY
108125: LIST
108126: LIST
108127: PUSH
108128: EMPTY
108129: LIST
108130: LIST
108131: LIST
108132: PUSH
108133: EMPTY
108134: LIST
108135: LIST
108136: PPUSH
108137: CALL_OW 69
108141: ST_TO_ADDR
// if not tmp then
108142: LD_VAR 0 4
108146: NOT
108147: IFFALSE 108151
// exit ;
108149: GO 108210
// for i in tmp do
108151: LD_ADDR_VAR 0 2
108155: PUSH
108156: LD_VAR 0 4
108160: PUSH
108161: FOR_IN
108162: IFFALSE 108208
// for j = 1 to 3 do
108164: LD_ADDR_VAR 0 3
108168: PUSH
108169: DOUBLE
108170: LD_INT 1
108172: DEC
108173: ST_TO_ADDR
108174: LD_INT 3
108176: PUSH
108177: FOR_TO
108178: IFFALSE 108204
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
108180: LD_VAR 0 2
108184: PPUSH
108185: CALL_OW 274
108189: PPUSH
108190: LD_VAR 0 3
108194: PPUSH
108195: LD_INT 99999
108197: PPUSH
108198: CALL_OW 277
108202: GO 108177
108204: POP
108205: POP
108206: GO 108161
108208: POP
108209: POP
// end ;
108210: LD_VAR 0 1
108214: RET
// export function hHackSetLevel10 ; var i , j ; begin
108215: LD_INT 0
108217: PPUSH
108218: PPUSH
108219: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
108220: LD_ADDR_VAR 0 2
108224: PUSH
108225: LD_INT 21
108227: PUSH
108228: LD_INT 1
108230: PUSH
108231: EMPTY
108232: LIST
108233: LIST
108234: PPUSH
108235: CALL_OW 69
108239: PUSH
108240: FOR_IN
108241: IFFALSE 108293
// if IsSelected ( i ) then
108243: LD_VAR 0 2
108247: PPUSH
108248: CALL_OW 306
108252: IFFALSE 108291
// begin for j := 1 to 4 do
108254: LD_ADDR_VAR 0 3
108258: PUSH
108259: DOUBLE
108260: LD_INT 1
108262: DEC
108263: ST_TO_ADDR
108264: LD_INT 4
108266: PUSH
108267: FOR_TO
108268: IFFALSE 108289
// SetSkill ( i , j , 10 ) ;
108270: LD_VAR 0 2
108274: PPUSH
108275: LD_VAR 0 3
108279: PPUSH
108280: LD_INT 10
108282: PPUSH
108283: CALL_OW 237
108287: GO 108267
108289: POP
108290: POP
// end ;
108291: GO 108240
108293: POP
108294: POP
// end ;
108295: LD_VAR 0 1
108299: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
108300: LD_INT 0
108302: PPUSH
108303: PPUSH
108304: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
108305: LD_ADDR_VAR 0 2
108309: PUSH
108310: LD_INT 22
108312: PUSH
108313: LD_OWVAR 2
108317: PUSH
108318: EMPTY
108319: LIST
108320: LIST
108321: PUSH
108322: LD_INT 21
108324: PUSH
108325: LD_INT 1
108327: PUSH
108328: EMPTY
108329: LIST
108330: LIST
108331: PUSH
108332: EMPTY
108333: LIST
108334: LIST
108335: PPUSH
108336: CALL_OW 69
108340: PUSH
108341: FOR_IN
108342: IFFALSE 108383
// begin for j := 1 to 4 do
108344: LD_ADDR_VAR 0 3
108348: PUSH
108349: DOUBLE
108350: LD_INT 1
108352: DEC
108353: ST_TO_ADDR
108354: LD_INT 4
108356: PUSH
108357: FOR_TO
108358: IFFALSE 108379
// SetSkill ( i , j , 10 ) ;
108360: LD_VAR 0 2
108364: PPUSH
108365: LD_VAR 0 3
108369: PPUSH
108370: LD_INT 10
108372: PPUSH
108373: CALL_OW 237
108377: GO 108357
108379: POP
108380: POP
// end ;
108381: GO 108341
108383: POP
108384: POP
// end ;
108385: LD_VAR 0 1
108389: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
108390: LD_INT 0
108392: PPUSH
// uc_side := your_side ;
108393: LD_ADDR_OWVAR 20
108397: PUSH
108398: LD_OWVAR 2
108402: ST_TO_ADDR
// uc_nation := nation ;
108403: LD_ADDR_OWVAR 21
108407: PUSH
108408: LD_VAR 0 1
108412: ST_TO_ADDR
// InitHc ;
108413: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
108417: LD_INT 0
108419: PPUSH
108420: LD_VAR 0 2
108424: PPUSH
108425: LD_VAR 0 3
108429: PPUSH
108430: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
108434: LD_VAR 0 4
108438: PPUSH
108439: LD_VAR 0 5
108443: PPUSH
108444: CALL_OW 428
108448: PUSH
108449: LD_INT 0
108451: EQUAL
108452: IFFALSE 108476
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
108454: CALL_OW 44
108458: PPUSH
108459: LD_VAR 0 4
108463: PPUSH
108464: LD_VAR 0 5
108468: PPUSH
108469: LD_INT 1
108471: PPUSH
108472: CALL_OW 48
// end ;
108476: LD_VAR 0 6
108480: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
108481: LD_INT 0
108483: PPUSH
108484: PPUSH
// uc_side := your_side ;
108485: LD_ADDR_OWVAR 20
108489: PUSH
108490: LD_OWVAR 2
108494: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
108495: LD_VAR 0 1
108499: PUSH
108500: LD_INT 1
108502: PUSH
108503: LD_INT 2
108505: PUSH
108506: LD_INT 3
108508: PUSH
108509: LD_INT 4
108511: PUSH
108512: LD_INT 5
108514: PUSH
108515: EMPTY
108516: LIST
108517: LIST
108518: LIST
108519: LIST
108520: LIST
108521: IN
108522: IFFALSE 108534
// uc_nation := nation_american else
108524: LD_ADDR_OWVAR 21
108528: PUSH
108529: LD_INT 1
108531: ST_TO_ADDR
108532: GO 108577
// if chassis in [ 11 , 12 , 13 , 14 ] then
108534: LD_VAR 0 1
108538: PUSH
108539: LD_INT 11
108541: PUSH
108542: LD_INT 12
108544: PUSH
108545: LD_INT 13
108547: PUSH
108548: LD_INT 14
108550: PUSH
108551: EMPTY
108552: LIST
108553: LIST
108554: LIST
108555: LIST
108556: IN
108557: IFFALSE 108569
// uc_nation := nation_arabian else
108559: LD_ADDR_OWVAR 21
108563: PUSH
108564: LD_INT 2
108566: ST_TO_ADDR
108567: GO 108577
// uc_nation := nation_russian ;
108569: LD_ADDR_OWVAR 21
108573: PUSH
108574: LD_INT 3
108576: ST_TO_ADDR
// vc_chassis := chassis ;
108577: LD_ADDR_OWVAR 37
108581: PUSH
108582: LD_VAR 0 1
108586: ST_TO_ADDR
// vc_engine := engine ;
108587: LD_ADDR_OWVAR 39
108591: PUSH
108592: LD_VAR 0 2
108596: ST_TO_ADDR
// vc_control := control ;
108597: LD_ADDR_OWVAR 38
108601: PUSH
108602: LD_VAR 0 3
108606: ST_TO_ADDR
// vc_weapon := weapon ;
108607: LD_ADDR_OWVAR 40
108611: PUSH
108612: LD_VAR 0 4
108616: ST_TO_ADDR
// un := CreateVehicle ;
108617: LD_ADDR_VAR 0 8
108621: PUSH
108622: CALL_OW 45
108626: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
108627: LD_VAR 0 8
108631: PPUSH
108632: LD_INT 0
108634: PPUSH
108635: LD_INT 5
108637: PPUSH
108638: CALL_OW 12
108642: PPUSH
108643: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
108647: LD_VAR 0 8
108651: PPUSH
108652: LD_VAR 0 5
108656: PPUSH
108657: LD_VAR 0 6
108661: PPUSH
108662: LD_INT 1
108664: PPUSH
108665: CALL_OW 48
// end ;
108669: LD_VAR 0 7
108673: RET
// export hInvincible ; every 1 do
108674: GO 108676
108676: DISABLE
// hInvincible := [ ] ;
108677: LD_ADDR_EXP 134
108681: PUSH
108682: EMPTY
108683: ST_TO_ADDR
108684: END
// every 10 do var i ;
108685: GO 108687
108687: DISABLE
108688: LD_INT 0
108690: PPUSH
// begin enable ;
108691: ENABLE
// if not hInvincible then
108692: LD_EXP 134
108696: NOT
108697: IFFALSE 108701
// exit ;
108699: GO 108745
// for i in hInvincible do
108701: LD_ADDR_VAR 0 1
108705: PUSH
108706: LD_EXP 134
108710: PUSH
108711: FOR_IN
108712: IFFALSE 108743
// if GetLives ( i ) < 1000 then
108714: LD_VAR 0 1
108718: PPUSH
108719: CALL_OW 256
108723: PUSH
108724: LD_INT 1000
108726: LESS
108727: IFFALSE 108741
// SetLives ( i , 1000 ) ;
108729: LD_VAR 0 1
108733: PPUSH
108734: LD_INT 1000
108736: PPUSH
108737: CALL_OW 234
108741: GO 108711
108743: POP
108744: POP
// end ;
108745: PPOPN 1
108747: END
// export function hHackInvincible ; var i ; begin
108748: LD_INT 0
108750: PPUSH
108751: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
108752: LD_ADDR_VAR 0 2
108756: PUSH
108757: LD_INT 2
108759: PUSH
108760: LD_INT 21
108762: PUSH
108763: LD_INT 1
108765: PUSH
108766: EMPTY
108767: LIST
108768: LIST
108769: PUSH
108770: LD_INT 21
108772: PUSH
108773: LD_INT 2
108775: PUSH
108776: EMPTY
108777: LIST
108778: LIST
108779: PUSH
108780: EMPTY
108781: LIST
108782: LIST
108783: LIST
108784: PPUSH
108785: CALL_OW 69
108789: PUSH
108790: FOR_IN
108791: IFFALSE 108852
// if IsSelected ( i ) then
108793: LD_VAR 0 2
108797: PPUSH
108798: CALL_OW 306
108802: IFFALSE 108850
// begin if i in hInvincible then
108804: LD_VAR 0 2
108808: PUSH
108809: LD_EXP 134
108813: IN
108814: IFFALSE 108834
// hInvincible := hInvincible diff i else
108816: LD_ADDR_EXP 134
108820: PUSH
108821: LD_EXP 134
108825: PUSH
108826: LD_VAR 0 2
108830: DIFF
108831: ST_TO_ADDR
108832: GO 108850
// hInvincible := hInvincible union i ;
108834: LD_ADDR_EXP 134
108838: PUSH
108839: LD_EXP 134
108843: PUSH
108844: LD_VAR 0 2
108848: UNION
108849: ST_TO_ADDR
// end ;
108850: GO 108790
108852: POP
108853: POP
// end ;
108854: LD_VAR 0 1
108858: RET
// export function hHackInvisible ; var i , j ; begin
108859: LD_INT 0
108861: PPUSH
108862: PPUSH
108863: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
108864: LD_ADDR_VAR 0 2
108868: PUSH
108869: LD_INT 21
108871: PUSH
108872: LD_INT 1
108874: PUSH
108875: EMPTY
108876: LIST
108877: LIST
108878: PPUSH
108879: CALL_OW 69
108883: PUSH
108884: FOR_IN
108885: IFFALSE 108909
// if IsSelected ( i ) then
108887: LD_VAR 0 2
108891: PPUSH
108892: CALL_OW 306
108896: IFFALSE 108907
// ComForceInvisible ( i ) ;
108898: LD_VAR 0 2
108902: PPUSH
108903: CALL_OW 496
108907: GO 108884
108909: POP
108910: POP
// end ;
108911: LD_VAR 0 1
108915: RET
// export function hHackChangeYourSide ; begin
108916: LD_INT 0
108918: PPUSH
// if your_side = 8 then
108919: LD_OWVAR 2
108923: PUSH
108924: LD_INT 8
108926: EQUAL
108927: IFFALSE 108939
// your_side := 0 else
108929: LD_ADDR_OWVAR 2
108933: PUSH
108934: LD_INT 0
108936: ST_TO_ADDR
108937: GO 108953
// your_side := your_side + 1 ;
108939: LD_ADDR_OWVAR 2
108943: PUSH
108944: LD_OWVAR 2
108948: PUSH
108949: LD_INT 1
108951: PLUS
108952: ST_TO_ADDR
// end ;
108953: LD_VAR 0 1
108957: RET
// export function hHackChangeUnitSide ; var i , j ; begin
108958: LD_INT 0
108960: PPUSH
108961: PPUSH
108962: PPUSH
// for i in all_units do
108963: LD_ADDR_VAR 0 2
108967: PUSH
108968: LD_OWVAR 3
108972: PUSH
108973: FOR_IN
108974: IFFALSE 109052
// if IsSelected ( i ) then
108976: LD_VAR 0 2
108980: PPUSH
108981: CALL_OW 306
108985: IFFALSE 109050
// begin j := GetSide ( i ) ;
108987: LD_ADDR_VAR 0 3
108991: PUSH
108992: LD_VAR 0 2
108996: PPUSH
108997: CALL_OW 255
109001: ST_TO_ADDR
// if j = 8 then
109002: LD_VAR 0 3
109006: PUSH
109007: LD_INT 8
109009: EQUAL
109010: IFFALSE 109022
// j := 0 else
109012: LD_ADDR_VAR 0 3
109016: PUSH
109017: LD_INT 0
109019: ST_TO_ADDR
109020: GO 109036
// j := j + 1 ;
109022: LD_ADDR_VAR 0 3
109026: PUSH
109027: LD_VAR 0 3
109031: PUSH
109032: LD_INT 1
109034: PLUS
109035: ST_TO_ADDR
// SetSide ( i , j ) ;
109036: LD_VAR 0 2
109040: PPUSH
109041: LD_VAR 0 3
109045: PPUSH
109046: CALL_OW 235
// end ;
109050: GO 108973
109052: POP
109053: POP
// end ;
109054: LD_VAR 0 1
109058: RET
// export function hHackFog ; begin
109059: LD_INT 0
109061: PPUSH
// FogOff ( true ) ;
109062: LD_INT 1
109064: PPUSH
109065: CALL_OW 344
// end ;
109069: LD_VAR 0 1
109073: RET
// export function hHackTeleport ( unit , x , y ) ; begin
109074: LD_INT 0
109076: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
109077: LD_VAR 0 1
109081: PPUSH
109082: LD_VAR 0 2
109086: PPUSH
109087: LD_VAR 0 3
109091: PPUSH
109092: LD_INT 1
109094: PPUSH
109095: LD_INT 1
109097: PPUSH
109098: CALL_OW 483
// CenterOnXY ( x , y ) ;
109102: LD_VAR 0 2
109106: PPUSH
109107: LD_VAR 0 3
109111: PPUSH
109112: CALL_OW 84
// end ;
109116: LD_VAR 0 4
109120: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
109121: LD_INT 0
109123: PPUSH
109124: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
109125: LD_VAR 0 1
109129: NOT
109130: PUSH
109131: LD_VAR 0 2
109135: PPUSH
109136: LD_VAR 0 3
109140: PPUSH
109141: CALL_OW 488
109145: NOT
109146: OR
109147: PUSH
109148: LD_VAR 0 1
109152: PPUSH
109153: CALL_OW 266
109157: PUSH
109158: LD_INT 3
109160: NONEQUAL
109161: PUSH
109162: LD_VAR 0 1
109166: PPUSH
109167: CALL_OW 247
109171: PUSH
109172: LD_INT 1
109174: EQUAL
109175: NOT
109176: AND
109177: OR
109178: IFFALSE 109182
// exit ;
109180: GO 109331
// if GetType ( factory ) = unit_human then
109182: LD_VAR 0 1
109186: PPUSH
109187: CALL_OW 247
109191: PUSH
109192: LD_INT 1
109194: EQUAL
109195: IFFALSE 109212
// factory := IsInUnit ( factory ) ;
109197: LD_ADDR_VAR 0 1
109201: PUSH
109202: LD_VAR 0 1
109206: PPUSH
109207: CALL_OW 310
109211: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
109212: LD_VAR 0 1
109216: PPUSH
109217: CALL_OW 266
109221: PUSH
109222: LD_INT 3
109224: NONEQUAL
109225: IFFALSE 109229
// exit ;
109227: GO 109331
// if HexInfo ( x , y ) = factory then
109229: LD_VAR 0 2
109233: PPUSH
109234: LD_VAR 0 3
109238: PPUSH
109239: CALL_OW 428
109243: PUSH
109244: LD_VAR 0 1
109248: EQUAL
109249: IFFALSE 109276
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
109251: LD_ADDR_EXP 135
109255: PUSH
109256: LD_EXP 135
109260: PPUSH
109261: LD_VAR 0 1
109265: PPUSH
109266: LD_INT 0
109268: PPUSH
109269: CALL_OW 1
109273: ST_TO_ADDR
109274: GO 109327
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
109276: LD_ADDR_EXP 135
109280: PUSH
109281: LD_EXP 135
109285: PPUSH
109286: LD_VAR 0 1
109290: PPUSH
109291: LD_VAR 0 1
109295: PPUSH
109296: CALL_OW 255
109300: PUSH
109301: LD_VAR 0 1
109305: PUSH
109306: LD_VAR 0 2
109310: PUSH
109311: LD_VAR 0 3
109315: PUSH
109316: EMPTY
109317: LIST
109318: LIST
109319: LIST
109320: LIST
109321: PPUSH
109322: CALL_OW 1
109326: ST_TO_ADDR
// UpdateFactoryWaypoints ;
109327: CALL 109336 0 0
// end ;
109331: LD_VAR 0 4
109335: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
109336: LD_INT 0
109338: PPUSH
109339: PPUSH
109340: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
109341: LD_STRING resetFactoryWaypoint();
109343: PPUSH
109344: CALL_OW 559
// if factoryWaypoints then
109348: LD_EXP 135
109352: IFFALSE 109478
// begin list := PrepareArray ( factoryWaypoints ) ;
109354: LD_ADDR_VAR 0 3
109358: PUSH
109359: LD_EXP 135
109363: PPUSH
109364: CALL 52171 0 1
109368: ST_TO_ADDR
// for i := 1 to list do
109369: LD_ADDR_VAR 0 2
109373: PUSH
109374: DOUBLE
109375: LD_INT 1
109377: DEC
109378: ST_TO_ADDR
109379: LD_VAR 0 3
109383: PUSH
109384: FOR_TO
109385: IFFALSE 109476
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
109387: LD_STRING setFactoryWaypointXY(
109389: PUSH
109390: LD_VAR 0 3
109394: PUSH
109395: LD_VAR 0 2
109399: ARRAY
109400: PUSH
109401: LD_INT 1
109403: ARRAY
109404: STR
109405: PUSH
109406: LD_STRING ,
109408: STR
109409: PUSH
109410: LD_VAR 0 3
109414: PUSH
109415: LD_VAR 0 2
109419: ARRAY
109420: PUSH
109421: LD_INT 2
109423: ARRAY
109424: STR
109425: PUSH
109426: LD_STRING ,
109428: STR
109429: PUSH
109430: LD_VAR 0 3
109434: PUSH
109435: LD_VAR 0 2
109439: ARRAY
109440: PUSH
109441: LD_INT 3
109443: ARRAY
109444: STR
109445: PUSH
109446: LD_STRING ,
109448: STR
109449: PUSH
109450: LD_VAR 0 3
109454: PUSH
109455: LD_VAR 0 2
109459: ARRAY
109460: PUSH
109461: LD_INT 4
109463: ARRAY
109464: STR
109465: PUSH
109466: LD_STRING )
109468: STR
109469: PPUSH
109470: CALL_OW 559
109474: GO 109384
109476: POP
109477: POP
// end ; end ;
109478: LD_VAR 0 1
109482: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
109483: LD_INT 0
109485: PPUSH
// if HexInfo ( x , y ) = warehouse then
109486: LD_VAR 0 2
109490: PPUSH
109491: LD_VAR 0 3
109495: PPUSH
109496: CALL_OW 428
109500: PUSH
109501: LD_VAR 0 1
109505: EQUAL
109506: IFFALSE 109533
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
109508: LD_ADDR_EXP 136
109512: PUSH
109513: LD_EXP 136
109517: PPUSH
109518: LD_VAR 0 1
109522: PPUSH
109523: LD_INT 0
109525: PPUSH
109526: CALL_OW 1
109530: ST_TO_ADDR
109531: GO 109584
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
109533: LD_ADDR_EXP 136
109537: PUSH
109538: LD_EXP 136
109542: PPUSH
109543: LD_VAR 0 1
109547: PPUSH
109548: LD_VAR 0 1
109552: PPUSH
109553: CALL_OW 255
109557: PUSH
109558: LD_VAR 0 1
109562: PUSH
109563: LD_VAR 0 2
109567: PUSH
109568: LD_VAR 0 3
109572: PUSH
109573: EMPTY
109574: LIST
109575: LIST
109576: LIST
109577: LIST
109578: PPUSH
109579: CALL_OW 1
109583: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
109584: CALL 109593 0 0
// end ;
109588: LD_VAR 0 4
109592: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
109593: LD_INT 0
109595: PPUSH
109596: PPUSH
109597: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
109598: LD_STRING resetWarehouseGatheringPoints();
109600: PPUSH
109601: CALL_OW 559
// if warehouseGatheringPoints then
109605: LD_EXP 136
109609: IFFALSE 109735
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
109611: LD_ADDR_VAR 0 3
109615: PUSH
109616: LD_EXP 136
109620: PPUSH
109621: CALL 52171 0 1
109625: ST_TO_ADDR
// for i := 1 to list do
109626: LD_ADDR_VAR 0 2
109630: PUSH
109631: DOUBLE
109632: LD_INT 1
109634: DEC
109635: ST_TO_ADDR
109636: LD_VAR 0 3
109640: PUSH
109641: FOR_TO
109642: IFFALSE 109733
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
109644: LD_STRING setWarehouseGatheringPointXY(
109646: PUSH
109647: LD_VAR 0 3
109651: PUSH
109652: LD_VAR 0 2
109656: ARRAY
109657: PUSH
109658: LD_INT 1
109660: ARRAY
109661: STR
109662: PUSH
109663: LD_STRING ,
109665: STR
109666: PUSH
109667: LD_VAR 0 3
109671: PUSH
109672: LD_VAR 0 2
109676: ARRAY
109677: PUSH
109678: LD_INT 2
109680: ARRAY
109681: STR
109682: PUSH
109683: LD_STRING ,
109685: STR
109686: PUSH
109687: LD_VAR 0 3
109691: PUSH
109692: LD_VAR 0 2
109696: ARRAY
109697: PUSH
109698: LD_INT 3
109700: ARRAY
109701: STR
109702: PUSH
109703: LD_STRING ,
109705: STR
109706: PUSH
109707: LD_VAR 0 3
109711: PUSH
109712: LD_VAR 0 2
109716: ARRAY
109717: PUSH
109718: LD_INT 4
109720: ARRAY
109721: STR
109722: PUSH
109723: LD_STRING )
109725: STR
109726: PPUSH
109727: CALL_OW 559
109731: GO 109641
109733: POP
109734: POP
// end ; end ;
109735: LD_VAR 0 1
109739: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
109740: LD_EXP 136
109744: IFFALSE 110429
109746: GO 109748
109748: DISABLE
109749: LD_INT 0
109751: PPUSH
109752: PPUSH
109753: PPUSH
109754: PPUSH
109755: PPUSH
109756: PPUSH
109757: PPUSH
109758: PPUSH
109759: PPUSH
// begin enable ;
109760: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
109761: LD_ADDR_VAR 0 3
109765: PUSH
109766: LD_EXP 136
109770: PPUSH
109771: CALL 52171 0 1
109775: ST_TO_ADDR
// if not list then
109776: LD_VAR 0 3
109780: NOT
109781: IFFALSE 109785
// exit ;
109783: GO 110429
// for i := 1 to list do
109785: LD_ADDR_VAR 0 1
109789: PUSH
109790: DOUBLE
109791: LD_INT 1
109793: DEC
109794: ST_TO_ADDR
109795: LD_VAR 0 3
109799: PUSH
109800: FOR_TO
109801: IFFALSE 110427
// begin depot := list [ i ] [ 2 ] ;
109803: LD_ADDR_VAR 0 8
109807: PUSH
109808: LD_VAR 0 3
109812: PUSH
109813: LD_VAR 0 1
109817: ARRAY
109818: PUSH
109819: LD_INT 2
109821: ARRAY
109822: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
109823: LD_ADDR_VAR 0 5
109827: PUSH
109828: LD_VAR 0 3
109832: PUSH
109833: LD_VAR 0 1
109837: ARRAY
109838: PUSH
109839: LD_INT 1
109841: ARRAY
109842: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
109843: LD_VAR 0 8
109847: PPUSH
109848: CALL_OW 301
109852: PUSH
109853: LD_VAR 0 5
109857: PUSH
109858: LD_VAR 0 8
109862: PPUSH
109863: CALL_OW 255
109867: NONEQUAL
109868: OR
109869: IFFALSE 109898
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
109871: LD_ADDR_EXP 136
109875: PUSH
109876: LD_EXP 136
109880: PPUSH
109881: LD_VAR 0 8
109885: PPUSH
109886: LD_INT 0
109888: PPUSH
109889: CALL_OW 1
109893: ST_TO_ADDR
// exit ;
109894: POP
109895: POP
109896: GO 110429
// end ; x := list [ i ] [ 3 ] ;
109898: LD_ADDR_VAR 0 6
109902: PUSH
109903: LD_VAR 0 3
109907: PUSH
109908: LD_VAR 0 1
109912: ARRAY
109913: PUSH
109914: LD_INT 3
109916: ARRAY
109917: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
109918: LD_ADDR_VAR 0 7
109922: PUSH
109923: LD_VAR 0 3
109927: PUSH
109928: LD_VAR 0 1
109932: ARRAY
109933: PUSH
109934: LD_INT 4
109936: ARRAY
109937: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
109938: LD_ADDR_VAR 0 9
109942: PUSH
109943: LD_VAR 0 6
109947: PPUSH
109948: LD_VAR 0 7
109952: PPUSH
109953: LD_INT 16
109955: PPUSH
109956: CALL 50759 0 3
109960: ST_TO_ADDR
// if not cratesNearbyPoint then
109961: LD_VAR 0 9
109965: NOT
109966: IFFALSE 109972
// exit ;
109968: POP
109969: POP
109970: GO 110429
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
109972: LD_ADDR_VAR 0 4
109976: PUSH
109977: LD_INT 22
109979: PUSH
109980: LD_VAR 0 5
109984: PUSH
109985: EMPTY
109986: LIST
109987: LIST
109988: PUSH
109989: LD_INT 3
109991: PUSH
109992: LD_INT 60
109994: PUSH
109995: EMPTY
109996: LIST
109997: PUSH
109998: EMPTY
109999: LIST
110000: LIST
110001: PUSH
110002: LD_INT 91
110004: PUSH
110005: LD_VAR 0 8
110009: PUSH
110010: LD_INT 6
110012: PUSH
110013: EMPTY
110014: LIST
110015: LIST
110016: LIST
110017: PUSH
110018: LD_INT 2
110020: PUSH
110021: LD_INT 25
110023: PUSH
110024: LD_INT 2
110026: PUSH
110027: EMPTY
110028: LIST
110029: LIST
110030: PUSH
110031: LD_INT 25
110033: PUSH
110034: LD_INT 16
110036: PUSH
110037: EMPTY
110038: LIST
110039: LIST
110040: PUSH
110041: EMPTY
110042: LIST
110043: LIST
110044: LIST
110045: PUSH
110046: EMPTY
110047: LIST
110048: LIST
110049: LIST
110050: LIST
110051: PPUSH
110052: CALL_OW 69
110056: PUSH
110057: LD_VAR 0 8
110061: PPUSH
110062: CALL_OW 313
110066: PPUSH
110067: LD_INT 3
110069: PUSH
110070: LD_INT 60
110072: PUSH
110073: EMPTY
110074: LIST
110075: PUSH
110076: EMPTY
110077: LIST
110078: LIST
110079: PUSH
110080: LD_INT 2
110082: PUSH
110083: LD_INT 25
110085: PUSH
110086: LD_INT 2
110088: PUSH
110089: EMPTY
110090: LIST
110091: LIST
110092: PUSH
110093: LD_INT 25
110095: PUSH
110096: LD_INT 16
110098: PUSH
110099: EMPTY
110100: LIST
110101: LIST
110102: PUSH
110103: EMPTY
110104: LIST
110105: LIST
110106: LIST
110107: PUSH
110108: EMPTY
110109: LIST
110110: LIST
110111: PPUSH
110112: CALL_OW 72
110116: UNION
110117: ST_TO_ADDR
// if tmp then
110118: LD_VAR 0 4
110122: IFFALSE 110202
// begin tmp := ShrinkArray ( tmp , 3 ) ;
110124: LD_ADDR_VAR 0 4
110128: PUSH
110129: LD_VAR 0 4
110133: PPUSH
110134: LD_INT 3
110136: PPUSH
110137: CALL 48728 0 2
110141: ST_TO_ADDR
// for j in tmp do
110142: LD_ADDR_VAR 0 2
110146: PUSH
110147: LD_VAR 0 4
110151: PUSH
110152: FOR_IN
110153: IFFALSE 110196
// begin if IsInUnit ( j ) then
110155: LD_VAR 0 2
110159: PPUSH
110160: CALL_OW 310
110164: IFFALSE 110175
// ComExit ( j ) ;
110166: LD_VAR 0 2
110170: PPUSH
110171: CALL 48811 0 1
// AddComCollect ( j , x , y ) ;
110175: LD_VAR 0 2
110179: PPUSH
110180: LD_VAR 0 6
110184: PPUSH
110185: LD_VAR 0 7
110189: PPUSH
110190: CALL_OW 177
// end ;
110194: GO 110152
110196: POP
110197: POP
// exit ;
110198: POP
110199: POP
110200: GO 110429
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
110202: LD_ADDR_VAR 0 4
110206: PUSH
110207: LD_INT 22
110209: PUSH
110210: LD_VAR 0 5
110214: PUSH
110215: EMPTY
110216: LIST
110217: LIST
110218: PUSH
110219: LD_INT 91
110221: PUSH
110222: LD_VAR 0 8
110226: PUSH
110227: LD_INT 8
110229: PUSH
110230: EMPTY
110231: LIST
110232: LIST
110233: LIST
110234: PUSH
110235: LD_INT 2
110237: PUSH
110238: LD_INT 34
110240: PUSH
110241: LD_INT 12
110243: PUSH
110244: EMPTY
110245: LIST
110246: LIST
110247: PUSH
110248: LD_INT 34
110250: PUSH
110251: LD_INT 51
110253: PUSH
110254: EMPTY
110255: LIST
110256: LIST
110257: PUSH
110258: LD_INT 34
110260: PUSH
110261: LD_INT 32
110263: PUSH
110264: EMPTY
110265: LIST
110266: LIST
110267: PUSH
110268: LD_INT 34
110270: PUSH
110271: LD_INT 89
110273: PUSH
110274: EMPTY
110275: LIST
110276: LIST
110277: PUSH
110278: EMPTY
110279: LIST
110280: LIST
110281: LIST
110282: LIST
110283: LIST
110284: PUSH
110285: EMPTY
110286: LIST
110287: LIST
110288: LIST
110289: PPUSH
110290: CALL_OW 69
110294: ST_TO_ADDR
// if tmp then
110295: LD_VAR 0 4
110299: IFFALSE 110425
// begin for j in tmp do
110301: LD_ADDR_VAR 0 2
110305: PUSH
110306: LD_VAR 0 4
110310: PUSH
110311: FOR_IN
110312: IFFALSE 110423
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
110314: LD_VAR 0 2
110318: PPUSH
110319: CALL_OW 262
110323: PUSH
110324: LD_INT 3
110326: EQUAL
110327: PUSH
110328: LD_VAR 0 2
110332: PPUSH
110333: CALL_OW 261
110337: PUSH
110338: LD_INT 20
110340: GREATER
110341: OR
110342: PUSH
110343: LD_VAR 0 2
110347: PPUSH
110348: CALL_OW 314
110352: NOT
110353: AND
110354: PUSH
110355: LD_VAR 0 2
110359: PPUSH
110360: CALL_OW 263
110364: PUSH
110365: LD_INT 1
110367: NONEQUAL
110368: PUSH
110369: LD_VAR 0 2
110373: PPUSH
110374: CALL_OW 311
110378: OR
110379: AND
110380: IFFALSE 110421
// begin ComCollect ( j , x , y ) ;
110382: LD_VAR 0 2
110386: PPUSH
110387: LD_VAR 0 6
110391: PPUSH
110392: LD_VAR 0 7
110396: PPUSH
110397: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
110401: LD_VAR 0 2
110405: PPUSH
110406: LD_VAR 0 8
110410: PPUSH
110411: CALL_OW 172
// exit ;
110415: POP
110416: POP
110417: POP
110418: POP
110419: GO 110429
// end ;
110421: GO 110311
110423: POP
110424: POP
// end ; end ;
110425: GO 109800
110427: POP
110428: POP
// end ; end_of_file
110429: PPOPN 9
110431: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
110432: LD_VAR 0 1
110436: PPUSH
110437: LD_VAR 0 2
110441: PPUSH
110442: LD_VAR 0 3
110446: PPUSH
110447: LD_VAR 0 4
110451: PPUSH
110452: LD_VAR 0 5
110456: PPUSH
110457: LD_VAR 0 6
110461: PPUSH
110462: CALL 94834 0 6
// end ;
110466: PPOPN 6
110468: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
110469: LD_INT 0
110471: PPUSH
// begin if not units then
110472: LD_VAR 0 1
110476: NOT
110477: IFFALSE 110481
// exit ;
110479: GO 110481
// end ;
110481: PPOPN 7
110483: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
110484: CALL 94805 0 0
// end ;
110488: PPOPN 1
110490: END
