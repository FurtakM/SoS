// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 210 0 0
// if debug then
  15: LD_EXP 1
  19: IFFALSE 38
// begin FogOff ( 1 ) ;
  21: LD_INT 1
  23: PPUSH
  24: CALL_OW 344
// Difficulty := 2 ;
  28: LD_ADDR_OWVAR 67
  32: PUSH
  33: LD_INT 2
  35: ST_TO_ADDR
// end else
  36: GO 51
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  38: LD_ADDR_OWVAR 67
  42: PUSH
  43: LD_INT 0
  45: PPUSH
  46: CALL_OW 426
  50: ST_TO_ADDR
// ChangeSideFog ( 4 , 1 ) ;
  51: LD_INT 4
  53: PPUSH
  54: LD_INT 1
  56: PPUSH
  57: CALL_OW 343
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , gensher_ape , 0 ) ;
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 0
  66: PPUSH
  67: LD_INT 5
  69: PPUSH
  70: LD_INT 0
  72: PPUSH
  73: LD_INT 0
  75: PPUSH
  76: LD_INT 0
  78: PPUSH
  79: LD_INT 0
  81: PPUSH
  82: LD_INT 7
  84: PPUSH
  85: LD_INT 0
  87: PPUSH
  88: CALL 45494 0 9
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , powell_ape , 0 ) ;
  92: LD_INT 0
  94: PPUSH
  95: LD_INT 0
  97: PPUSH
  98: LD_INT 3
 100: PPUSH
 101: LD_INT 0
 103: PPUSH
 104: LD_INT 0
 106: PPUSH
 107: LD_INT 0
 109: PPUSH
 110: LD_INT 0
 112: PPUSH
 113: LD_INT 4
 115: PPUSH
 116: LD_INT 0
 118: PPUSH
 119: CALL 45494 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , popov_ape , 0 ) ;
 123: LD_INT 0
 125: PPUSH
 126: LD_INT 0
 128: PPUSH
 129: LD_INT 5
 131: PPUSH
 132: LD_INT 0
 134: PPUSH
 135: LD_INT 0
 137: PPUSH
 138: LD_INT 0
 140: PPUSH
 141: LD_INT 0
 143: PPUSH
 144: LD_INT 11
 146: PPUSH
 147: LD_INT 0
 149: PPUSH
 150: CALL 45494 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , sikorski_ape , 0 ) ;
 154: LD_INT 0
 156: PPUSH
 157: LD_INT 0
 159: PPUSH
 160: LD_INT 5
 162: PPUSH
 163: LD_INT 0
 165: PPUSH
 166: LD_INT 0
 168: PPUSH
 169: LD_INT 0
 171: PPUSH
 172: LD_INT 0
 174: PPUSH
 175: LD_INT 14
 177: PPUSH
 178: LD_INT 0
 180: PPUSH
 181: CALL 45494 0 9
// PrepareGensher ;
 185: CALL 3188 0 0
// PreparePopov ;
 189: CALL 6427 0 0
// PreparePowell ;
 193: CALL 589 0 0
// PrepareSikorski ;
 197: CALL 9147 0 0
// MC_Start ( ) ;
 201: CALL 55219 0 0
// Action ;
 205: CALL 9554 0 0
// end ;
 209: END
// export debug , game , staticMines , arDestroyed , ruDestroyed , loseCounter , powellLoseCounter , powellInTrouble , sikorskiInTrouble ; function InitVariables ; begin
 210: LD_INT 0
 212: PPUSH
// debug := false ;
 213: LD_ADDR_EXP 1
 217: PUSH
 218: LD_INT 0
 220: ST_TO_ADDR
// game := true ;
 221: LD_ADDR_EXP 2
 225: PUSH
 226: LD_INT 1
 228: ST_TO_ADDR
// staticMines := [ ] ;
 229: LD_ADDR_EXP 3
 233: PUSH
 234: EMPTY
 235: ST_TO_ADDR
// arDestroyed := false ;
 236: LD_ADDR_EXP 4
 240: PUSH
 241: LD_INT 0
 243: ST_TO_ADDR
// ruDestroyed := false ;
 244: LD_ADDR_EXP 5
 248: PUSH
 249: LD_INT 0
 251: ST_TO_ADDR
// powellInTrouble := false ;
 252: LD_ADDR_EXP 8
 256: PUSH
 257: LD_INT 0
 259: ST_TO_ADDR
// sikorskiInTrouble := false ;
 260: LD_ADDR_EXP 9
 264: PUSH
 265: LD_INT 0
 267: ST_TO_ADDR
// end ;
 268: LD_VAR 0 1
 272: RET
// export function CustomInitMacro ; begin
 273: LD_INT 0
 275: PPUSH
// InitMC_Gensher ( ) ;
 276: CALL 4354 0 0
// InitMC_Powell ( ) ;
 280: CALL 1543 0 0
// InitMC_Popov ( ) ;
 284: CALL 7617 0 0
// end ;
 288: LD_VAR 0 1
 292: RET
// every 0 0$10 do var cr , time , i ;
 293: GO 295
 295: DISABLE
 296: LD_INT 0
 298: PPUSH
 299: PPUSH
 300: PPUSH
// begin time := 0 0$20 ;
 301: LD_ADDR_VAR 0 2
 305: PUSH
 306: LD_INT 700
 308: ST_TO_ADDR
// repeat wait ( time ) ;
 309: LD_VAR 0 2
 313: PPUSH
 314: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
 318: LD_ADDR_VAR 0 1
 322: PUSH
 323: LD_INT 1
 325: PPUSH
 326: LD_INT 5
 328: PPUSH
 329: CALL_OW 12
 333: ST_TO_ADDR
// for i in [ powell_crates , gensher_crates , popov_crates , sikorski_crates ] do
 334: LD_ADDR_VAR 0 3
 338: PUSH
 339: LD_INT 5
 341: PUSH
 342: LD_INT 8
 344: PUSH
 345: LD_INT 12
 347: PUSH
 348: LD_INT 13
 350: PUSH
 351: EMPTY
 352: LIST
 353: LIST
 354: LIST
 355: LIST
 356: PUSH
 357: FOR_IN
 358: IFFALSE 412
// begin if GetResourceArea ( i , mat_cans ) < 40 then
 360: LD_VAR 0 3
 364: PPUSH
 365: LD_INT 1
 367: PPUSH
 368: CALL_OW 287
 372: PUSH
 373: LD_INT 40
 375: LESS
 376: IFFALSE 395
// CreateCratesArea ( cr , i , true ) ;
 378: LD_VAR 0 1
 382: PPUSH
 383: LD_VAR 0 3
 387: PPUSH
 388: LD_INT 1
 390: PPUSH
 391: CALL_OW 55
// wait ( rand ( 0 0$5 , 0 0$15 ) ) ;
 395: LD_INT 175
 397: PPUSH
 398: LD_INT 525
 400: PPUSH
 401: CALL_OW 12
 405: PPUSH
 406: CALL_OW 67
// end ;
 410: GO 357
 412: POP
 413: POP
// time := time + 0 0$2 ;
 414: LD_ADDR_VAR 0 2
 418: PUSH
 419: LD_VAR 0 2
 423: PUSH
 424: LD_INT 70
 426: PLUS
 427: ST_TO_ADDR
// if time > 0 0$35 then
 428: LD_VAR 0 2
 432: PUSH
 433: LD_INT 1225
 435: GREATER
 436: IFFALSE 446
// time := 0 0$25 ;
 438: LD_ADDR_VAR 0 2
 442: PUSH
 443: LD_INT 875
 445: ST_TO_ADDR
// until not game ;
 446: LD_EXP 2
 450: NOT
 451: IFFALSE 309
// end ;
 453: PPOPN 3
 455: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
 456: LD_INT 3
 458: PUSH
 459: LD_INT 22
 461: PUSH
 462: LD_INT 1
 464: PUSH
 465: EMPTY
 466: LIST
 467: LIST
 468: PUSH
 469: EMPTY
 470: LIST
 471: LIST
 472: PUSH
 473: LD_INT 32
 475: PUSH
 476: LD_INT 1
 478: PUSH
 479: EMPTY
 480: LIST
 481: LIST
 482: PUSH
 483: EMPTY
 484: LIST
 485: LIST
 486: PPUSH
 487: CALL_OW 69
 491: IFFALSE 586
 493: GO 495
 495: DISABLE
 496: LD_INT 0
 498: PPUSH
 499: PPUSH
// begin enable ;
 500: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
 501: LD_ADDR_VAR 0 2
 505: PUSH
 506: LD_INT 3
 508: PUSH
 509: LD_INT 22
 511: PUSH
 512: LD_INT 1
 514: PUSH
 515: EMPTY
 516: LIST
 517: LIST
 518: PUSH
 519: EMPTY
 520: LIST
 521: LIST
 522: PUSH
 523: LD_INT 32
 525: PUSH
 526: LD_INT 1
 528: PUSH
 529: EMPTY
 530: LIST
 531: LIST
 532: PUSH
 533: EMPTY
 534: LIST
 535: LIST
 536: PPUSH
 537: CALL_OW 69
 541: ST_TO_ADDR
// for i in tmp do
 542: LD_ADDR_VAR 0 1
 546: PUSH
 547: LD_VAR 0 2
 551: PUSH
 552: FOR_IN
 553: IFFALSE 584
// if GetFuel ( i ) < 5 then
 555: LD_VAR 0 1
 559: PPUSH
 560: CALL_OW 261
 564: PUSH
 565: LD_INT 5
 567: LESS
 568: IFFALSE 582
// SetFuel ( i , 5 ) ;
 570: LD_VAR 0 1
 574: PPUSH
 575: LD_INT 5
 577: PPUSH
 578: CALL_OW 240
 582: GO 552
 584: POP
 585: POP
// end ; end_of_file
 586: PPOPN 2
 588: END
// export Powell , powell_side , powellAttackGroup ; export function PreparePowell ; var i , list , b , tmp ; begin
 589: LD_INT 0
 591: PPUSH
 592: PPUSH
 593: PPUSH
 594: PPUSH
 595: PPUSH
// powell_side := 4 ;
 596: LD_ADDR_EXP 11
 600: PUSH
 601: LD_INT 4
 603: ST_TO_ADDR
// uc_side := powell_side ;
 604: LD_ADDR_OWVAR 20
 608: PUSH
 609: LD_EXP 11
 613: ST_TO_ADDR
// uc_nation := 1 ;
 614: LD_ADDR_OWVAR 21
 618: PUSH
 619: LD_INT 1
 621: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
 622: LD_ADDR_EXP 10
 626: PUSH
 627: LD_STRING Powell
 629: PPUSH
 630: CALL_OW 25
 634: ST_TO_ADDR
// SetSkill ( Powell , 1 , 7 ) ;
 635: LD_EXP 10
 639: PPUSH
 640: LD_INT 1
 642: PPUSH
 643: LD_INT 7
 645: PPUSH
 646: CALL_OW 237
// SetSkill ( Powell , 2 , 5 ) ;
 650: LD_EXP 10
 654: PPUSH
 655: LD_INT 2
 657: PPUSH
 658: LD_INT 5
 660: PPUSH
 661: CALL_OW 237
// SetSkill ( Powell , 3 , 6 ) ;
 665: LD_EXP 10
 669: PPUSH
 670: LD_INT 3
 672: PPUSH
 673: LD_INT 6
 675: PPUSH
 676: CALL_OW 237
// SetSkill ( Powell , 4 , 4 ) ;
 680: LD_EXP 10
 684: PPUSH
 685: LD_INT 4
 687: PPUSH
 688: LD_INT 4
 690: PPUSH
 691: CALL_OW 237
// PlaceHumanInUnit ( Powell , us_depot ) ;
 695: LD_EXP 10
 699: PPUSH
 700: LD_INT 4
 702: PPUSH
 703: CALL_OW 52
// list := [ [ b_barracks , 178 , 117 , 2 ] , [ b_oil_mine , 167 , 102 , 0 ] , [ b_lab , 200 , 111 , 4 , b_lab_weapon , b_lab_siberium ] , [ b_factory , 201 , 140 , 4 ] , [ b_solar_power , 206 , 124 , 3 ] , [ b_solar_power , 209 , 128 , 3 ] , [ b_solar_power , 211 , 132 , 3 ] , [ b_siberite_mine , 173 , 83 , 3 ] , [ b_lab , 186 , 103 , 2 , b_lab_computer , b_lab_opto ] , [ b_turret , 173 , 99 , 2 , us_heavy_gun ] , [ b_bunker , 174 , 102 , 2 , us_heavy_gun ] , [ b_bunker , 178 , 100 , 2 , us_heavy_gun ] , [ b_turret , 174 , 108 , 1 , us_rocket_launcher ] , [ b_turret , 182 , 122 , 1 , us_rocket_launcher ] , [ b_control_tower , 194 , 124 , 5 ] , [ b_turret , 184 , 141 , 1 , us_heavy_gun ] , [ b_turret , 183 , 131 , 2 , us_radar ] , [ b_turret , 194 , 146 , 4 , us_rocket_launcher ] , [ b_turret , 190 , 142 , 4 , us_rocket_launcher ] , [ b_siberite_power , 204 , 133 , 3 ] , [ b_solar_power , 201 , 133 , 3 ] , [ b_siberite_power , 199 , 119 , 5 ] ] ;
 707: LD_ADDR_VAR 0 3
 711: PUSH
 712: LD_INT 5
 714: PUSH
 715: LD_INT 178
 717: PUSH
 718: LD_INT 117
 720: PUSH
 721: LD_INT 2
 723: PUSH
 724: EMPTY
 725: LIST
 726: LIST
 727: LIST
 728: LIST
 729: PUSH
 730: LD_INT 29
 732: PUSH
 733: LD_INT 167
 735: PUSH
 736: LD_INT 102
 738: PUSH
 739: LD_INT 0
 741: PUSH
 742: EMPTY
 743: LIST
 744: LIST
 745: LIST
 746: LIST
 747: PUSH
 748: LD_INT 6
 750: PUSH
 751: LD_INT 200
 753: PUSH
 754: LD_INT 111
 756: PUSH
 757: LD_INT 4
 759: PUSH
 760: LD_INT 10
 762: PUSH
 763: LD_INT 11
 765: PUSH
 766: EMPTY
 767: LIST
 768: LIST
 769: LIST
 770: LIST
 771: LIST
 772: LIST
 773: PUSH
 774: LD_INT 3
 776: PUSH
 777: LD_INT 201
 779: PUSH
 780: LD_INT 140
 782: PUSH
 783: LD_INT 4
 785: PUSH
 786: EMPTY
 787: LIST
 788: LIST
 789: LIST
 790: LIST
 791: PUSH
 792: LD_INT 27
 794: PUSH
 795: LD_INT 206
 797: PUSH
 798: LD_INT 124
 800: PUSH
 801: LD_INT 3
 803: PUSH
 804: EMPTY
 805: LIST
 806: LIST
 807: LIST
 808: LIST
 809: PUSH
 810: LD_INT 27
 812: PUSH
 813: LD_INT 209
 815: PUSH
 816: LD_INT 128
 818: PUSH
 819: LD_INT 3
 821: PUSH
 822: EMPTY
 823: LIST
 824: LIST
 825: LIST
 826: LIST
 827: PUSH
 828: LD_INT 27
 830: PUSH
 831: LD_INT 211
 833: PUSH
 834: LD_INT 132
 836: PUSH
 837: LD_INT 3
 839: PUSH
 840: EMPTY
 841: LIST
 842: LIST
 843: LIST
 844: LIST
 845: PUSH
 846: LD_INT 30
 848: PUSH
 849: LD_INT 173
 851: PUSH
 852: LD_INT 83
 854: PUSH
 855: LD_INT 3
 857: PUSH
 858: EMPTY
 859: LIST
 860: LIST
 861: LIST
 862: LIST
 863: PUSH
 864: LD_INT 6
 866: PUSH
 867: LD_INT 186
 869: PUSH
 870: LD_INT 103
 872: PUSH
 873: LD_INT 2
 875: PUSH
 876: LD_INT 12
 878: PUSH
 879: LD_INT 15
 881: PUSH
 882: EMPTY
 883: LIST
 884: LIST
 885: LIST
 886: LIST
 887: LIST
 888: LIST
 889: PUSH
 890: LD_INT 33
 892: PUSH
 893: LD_INT 173
 895: PUSH
 896: LD_INT 99
 898: PUSH
 899: LD_INT 2
 901: PUSH
 902: LD_INT 6
 904: PUSH
 905: EMPTY
 906: LIST
 907: LIST
 908: LIST
 909: LIST
 910: LIST
 911: PUSH
 912: LD_INT 32
 914: PUSH
 915: LD_INT 174
 917: PUSH
 918: LD_INT 102
 920: PUSH
 921: LD_INT 2
 923: PUSH
 924: LD_INT 6
 926: PUSH
 927: EMPTY
 928: LIST
 929: LIST
 930: LIST
 931: LIST
 932: LIST
 933: PUSH
 934: LD_INT 32
 936: PUSH
 937: LD_INT 178
 939: PUSH
 940: LD_INT 100
 942: PUSH
 943: LD_INT 2
 945: PUSH
 946: LD_INT 6
 948: PUSH
 949: EMPTY
 950: LIST
 951: LIST
 952: LIST
 953: LIST
 954: LIST
 955: PUSH
 956: LD_INT 33
 958: PUSH
 959: LD_INT 174
 961: PUSH
 962: LD_INT 108
 964: PUSH
 965: LD_INT 1
 967: PUSH
 968: LD_INT 7
 970: PUSH
 971: EMPTY
 972: LIST
 973: LIST
 974: LIST
 975: LIST
 976: LIST
 977: PUSH
 978: LD_INT 33
 980: PUSH
 981: LD_INT 182
 983: PUSH
 984: LD_INT 122
 986: PUSH
 987: LD_INT 1
 989: PUSH
 990: LD_INT 7
 992: PUSH
 993: EMPTY
 994: LIST
 995: LIST
 996: LIST
 997: LIST
 998: LIST
 999: PUSH
1000: LD_INT 36
1002: PUSH
1003: LD_INT 194
1005: PUSH
1006: LD_INT 124
1008: PUSH
1009: LD_INT 5
1011: PUSH
1012: EMPTY
1013: LIST
1014: LIST
1015: LIST
1016: LIST
1017: PUSH
1018: LD_INT 33
1020: PUSH
1021: LD_INT 184
1023: PUSH
1024: LD_INT 141
1026: PUSH
1027: LD_INT 1
1029: PUSH
1030: LD_INT 6
1032: PUSH
1033: EMPTY
1034: LIST
1035: LIST
1036: LIST
1037: LIST
1038: LIST
1039: PUSH
1040: LD_INT 33
1042: PUSH
1043: LD_INT 183
1045: PUSH
1046: LD_INT 131
1048: PUSH
1049: LD_INT 2
1051: PUSH
1052: LD_INT 11
1054: PUSH
1055: EMPTY
1056: LIST
1057: LIST
1058: LIST
1059: LIST
1060: LIST
1061: PUSH
1062: LD_INT 33
1064: PUSH
1065: LD_INT 194
1067: PUSH
1068: LD_INT 146
1070: PUSH
1071: LD_INT 4
1073: PUSH
1074: LD_INT 7
1076: PUSH
1077: EMPTY
1078: LIST
1079: LIST
1080: LIST
1081: LIST
1082: LIST
1083: PUSH
1084: LD_INT 33
1086: PUSH
1087: LD_INT 190
1089: PUSH
1090: LD_INT 142
1092: PUSH
1093: LD_INT 4
1095: PUSH
1096: LD_INT 7
1098: PUSH
1099: EMPTY
1100: LIST
1101: LIST
1102: LIST
1103: LIST
1104: LIST
1105: PUSH
1106: LD_INT 28
1108: PUSH
1109: LD_INT 204
1111: PUSH
1112: LD_INT 133
1114: PUSH
1115: LD_INT 3
1117: PUSH
1118: EMPTY
1119: LIST
1120: LIST
1121: LIST
1122: LIST
1123: PUSH
1124: LD_INT 27
1126: PUSH
1127: LD_INT 201
1129: PUSH
1130: LD_INT 133
1132: PUSH
1133: LD_INT 3
1135: PUSH
1136: EMPTY
1137: LIST
1138: LIST
1139: LIST
1140: LIST
1141: PUSH
1142: LD_INT 28
1144: PUSH
1145: LD_INT 199
1147: PUSH
1148: LD_INT 119
1150: PUSH
1151: LD_INT 5
1153: PUSH
1154: EMPTY
1155: LIST
1156: LIST
1157: LIST
1158: LIST
1159: PUSH
1160: EMPTY
1161: LIST
1162: LIST
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: LIST
1168: LIST
1169: LIST
1170: LIST
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: LIST
1180: LIST
1181: LIST
1182: LIST
1183: ST_TO_ADDR
// for i in list do
1184: LD_ADDR_VAR 0 2
1188: PUSH
1189: LD_VAR 0 3
1193: PUSH
1194: FOR_IN
1195: IFFALSE 1405
// begin uc_side := 4 ;
1197: LD_ADDR_OWVAR 20
1201: PUSH
1202: LD_INT 4
1204: ST_TO_ADDR
// uc_nation := 1 ;
1205: LD_ADDR_OWVAR 21
1209: PUSH
1210: LD_INT 1
1212: ST_TO_ADDR
// InitBc ;
1213: CALL_OW 21
// bc_type := i [ 1 ] ;
1217: LD_ADDR_OWVAR 42
1221: PUSH
1222: LD_VAR 0 2
1226: PUSH
1227: LD_INT 1
1229: ARRAY
1230: ST_TO_ADDR
// if i [ 1 ] in [ b_oil_mine , b_siberite_mine ] then
1231: LD_VAR 0 2
1235: PUSH
1236: LD_INT 1
1238: ARRAY
1239: PUSH
1240: LD_INT 29
1242: PUSH
1243: LD_INT 30
1245: PUSH
1246: EMPTY
1247: LIST
1248: LIST
1249: IN
1250: IFFALSE 1277
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , 4 ) ;
1252: LD_VAR 0 2
1256: PUSH
1257: LD_INT 2
1259: ARRAY
1260: PPUSH
1261: LD_VAR 0 2
1265: PUSH
1266: LD_INT 3
1268: ARRAY
1269: PPUSH
1270: LD_INT 4
1272: PPUSH
1273: CALL_OW 441
// if i [ 1 ] = b_lab then
1277: LD_VAR 0 2
1281: PUSH
1282: LD_INT 1
1284: ARRAY
1285: PUSH
1286: LD_INT 6
1288: EQUAL
1289: IFFALSE 1327
// begin bc_type := b_lab_full ;
1291: LD_ADDR_OWVAR 42
1295: PUSH
1296: LD_INT 8
1298: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
1299: LD_ADDR_OWVAR 44
1303: PUSH
1304: LD_VAR 0 2
1308: PUSH
1309: LD_INT 5
1311: ARRAY
1312: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
1313: LD_ADDR_OWVAR 45
1317: PUSH
1318: LD_VAR 0 2
1322: PUSH
1323: LD_INT 6
1325: ARRAY
1326: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1327: LD_ADDR_VAR 0 4
1331: PUSH
1332: LD_VAR 0 2
1336: PUSH
1337: LD_INT 2
1339: ARRAY
1340: PPUSH
1341: LD_VAR 0 2
1345: PUSH
1346: LD_INT 3
1348: ARRAY
1349: PPUSH
1350: LD_VAR 0 2
1354: PUSH
1355: LD_INT 4
1357: ARRAY
1358: PPUSH
1359: CALL_OW 47
1363: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
1364: LD_VAR 0 2
1368: PUSH
1369: LD_INT 1
1371: ARRAY
1372: PUSH
1373: LD_INT 33
1375: PUSH
1376: LD_INT 32
1378: PUSH
1379: EMPTY
1380: LIST
1381: LIST
1382: IN
1383: IFFALSE 1403
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
1385: LD_VAR 0 4
1389: PPUSH
1390: LD_VAR 0 2
1394: PUSH
1395: LD_INT 5
1397: ARRAY
1398: PPUSH
1399: CALL_OW 431
// end ;
1403: GO 1194
1405: POP
1406: POP
// tmp := PrepareBase ( us_depot , powell_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 5500 , 500 , 0 ] , [ 6 , 6 , 6 , 6 ] ) ;
1407: LD_ADDR_VAR 0 5
1411: PUSH
1412: LD_INT 4
1414: PPUSH
1415: LD_INT 1
1417: PPUSH
1418: LD_STRING 
1420: PPUSH
1421: LD_INT 8
1423: PUSH
1424: LD_INT 7
1426: PUSH
1427: LD_INT 6
1429: PUSH
1430: EMPTY
1431: LIST
1432: LIST
1433: LIST
1434: PUSH
1435: LD_OWVAR 67
1439: ARRAY
1440: PPUSH
1441: LD_INT 5500
1443: PUSH
1444: LD_INT 500
1446: PUSH
1447: LD_INT 0
1449: PUSH
1450: EMPTY
1451: LIST
1452: LIST
1453: LIST
1454: PPUSH
1455: LD_INT 6
1457: PUSH
1458: LD_INT 6
1460: PUSH
1461: LD_INT 6
1463: PUSH
1464: LD_INT 6
1466: PUSH
1467: EMPTY
1468: LIST
1469: LIST
1470: LIST
1471: LIST
1472: PPUSH
1473: CALL 19776 0 6
1477: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , tmp union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) ) ;
1478: LD_ADDR_EXP 23
1482: PUSH
1483: LD_EXP 23
1487: PPUSH
1488: LD_INT 1
1490: PPUSH
1491: LD_VAR 0 5
1495: PUSH
1496: LD_INT 22
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: EMPTY
1503: LIST
1504: LIST
1505: PUSH
1506: LD_INT 21
1508: PUSH
1509: LD_INT 3
1511: PUSH
1512: EMPTY
1513: LIST
1514: LIST
1515: PUSH
1516: EMPTY
1517: LIST
1518: LIST
1519: PPUSH
1520: CALL_OW 69
1524: UNION
1525: PPUSH
1526: CALL_OW 1
1530: ST_TO_ADDR
// powellAttackGroup := [ ] ;
1531: LD_ADDR_EXP 12
1535: PUSH
1536: EMPTY
1537: ST_TO_ADDR
// end ;
1538: LD_VAR 0 1
1542: RET
// export function InitMC_Powell ( ) ; begin
1543: LD_INT 0
1545: PPUSH
// MC_SetScanArea ( 1 , powell_base ) ;
1546: LD_INT 1
1548: PPUSH
1549: LD_INT 1
1551: PPUSH
1552: CALL 78594 0 2
// MC_SetParkingArea ( 1 , powell_parking ) ;
1556: LD_INT 1
1558: PPUSH
1559: LD_INT 6
1561: PPUSH
1562: CALL 78538 0 2
// MC_SetDepositsXY ( 1 , [ [ 167 , 102 , 0 ] , [ 173 , 83 , 1 ] , [ 171 , 141 , 0 ] , [ 178 , 148 , 1 ] ] ) ;
1566: LD_INT 1
1568: PPUSH
1569: LD_INT 167
1571: PUSH
1572: LD_INT 102
1574: PUSH
1575: LD_INT 0
1577: PUSH
1578: EMPTY
1579: LIST
1580: LIST
1581: LIST
1582: PUSH
1583: LD_INT 173
1585: PUSH
1586: LD_INT 83
1588: PUSH
1589: LD_INT 1
1591: PUSH
1592: EMPTY
1593: LIST
1594: LIST
1595: LIST
1596: PUSH
1597: LD_INT 171
1599: PUSH
1600: LD_INT 141
1602: PUSH
1603: LD_INT 0
1605: PUSH
1606: EMPTY
1607: LIST
1608: LIST
1609: LIST
1610: PUSH
1611: LD_INT 178
1613: PUSH
1614: LD_INT 148
1616: PUSH
1617: LD_INT 1
1619: PUSH
1620: EMPTY
1621: LIST
1622: LIST
1623: LIST
1624: PUSH
1625: EMPTY
1626: LIST
1627: LIST
1628: LIST
1629: LIST
1630: PPUSH
1631: CALL 77597 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ us_radar , us_heavy_gun , us_rocket_launcher ] ) ;
1635: LD_INT 1
1637: PPUSH
1638: LD_INT 11
1640: PUSH
1641: LD_INT 6
1643: PUSH
1644: LD_INT 7
1646: PUSH
1647: EMPTY
1648: LIST
1649: LIST
1650: LIST
1651: PPUSH
1652: CALL 78426 0 2
// MC_SetCratesArea ( 1 , powell_crates ) ;
1656: LD_INT 1
1658: PPUSH
1659: LD_INT 5
1661: PPUSH
1662: CALL 78108 0 2
// MC_SetTame ( 1 , powell_ape ) ;
1666: LD_INT 1
1668: PPUSH
1669: LD_INT 4
1671: PPUSH
1672: CALL 77839 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
1676: LD_INT 1
1678: PPUSH
1679: LD_INT 4
1681: PPUSH
1682: CALL 77458 0 2
// MC_SetProduceList ( 1 , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ] ) ;
1686: LD_INT 1
1688: PPUSH
1689: LD_INT 3
1691: PUSH
1692: LD_INT 1
1694: PUSH
1695: LD_INT 2
1697: PUSH
1698: LD_INT 5
1700: PUSH
1701: EMPTY
1702: LIST
1703: LIST
1704: LIST
1705: LIST
1706: PUSH
1707: LD_INT 4
1709: PUSH
1710: LD_INT 1
1712: PUSH
1713: LD_INT 2
1715: PUSH
1716: LD_INT 6
1718: PUSH
1719: EMPTY
1720: LIST
1721: LIST
1722: LIST
1723: LIST
1724: PUSH
1725: LD_INT 4
1727: PUSH
1728: LD_INT 1
1730: PUSH
1731: LD_INT 2
1733: PUSH
1734: LD_INT 7
1736: PUSH
1737: EMPTY
1738: LIST
1739: LIST
1740: LIST
1741: LIST
1742: PUSH
1743: LD_INT 4
1745: PUSH
1746: LD_INT 1
1748: PUSH
1749: LD_INT 2
1751: PUSH
1752: LD_INT 6
1754: PUSH
1755: EMPTY
1756: LIST
1757: LIST
1758: LIST
1759: LIST
1760: PUSH
1761: EMPTY
1762: LIST
1763: LIST
1764: LIST
1765: LIST
1766: PPUSH
1767: CALL 77273 0 2
// MC_SetFactoryExtension ( 1 , 201 , 140 , 4 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1771: LD_INT 1
1773: PPUSH
1774: LD_INT 201
1776: PPUSH
1777: LD_INT 140
1779: PPUSH
1780: LD_INT 4
1782: PPUSH
1783: LD_INT 19
1785: PUSH
1786: LD_INT 16
1788: PUSH
1789: LD_INT 17
1791: PUSH
1792: LD_INT 18
1794: PUSH
1795: LD_INT 22
1797: PUSH
1798: EMPTY
1799: LIST
1800: LIST
1801: LIST
1802: LIST
1803: LIST
1804: PPUSH
1805: CALL 78220 0 5
// end ;
1809: LD_VAR 0 1
1813: RET
// every 8 8$00 + 2 2$00 trigger IsOk ( us_depot ) do var i , base , tmp , attackers , amount ;
1814: LD_INT 4
1816: PPUSH
1817: CALL_OW 302
1821: IFFALSE 2481
1823: GO 1825
1825: DISABLE
1826: LD_INT 0
1828: PPUSH
1829: PPUSH
1830: PPUSH
1831: PPUSH
1832: PPUSH
// begin enable ;
1833: ENABLE
// base := 1 ;
1834: LD_ADDR_VAR 0 2
1838: PUSH
1839: LD_INT 1
1841: ST_TO_ADDR
// tmp := [ [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ] ;
1842: LD_ADDR_VAR 0 3
1846: PUSH
1847: LD_INT 4
1849: PUSH
1850: LD_INT 1
1852: PUSH
1853: LD_INT 2
1855: PUSH
1856: LD_INT 6
1858: PUSH
1859: EMPTY
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: PUSH
1865: LD_INT 4
1867: PUSH
1868: LD_INT 1
1870: PUSH
1871: LD_INT 2
1873: PUSH
1874: LD_INT 6
1876: PUSH
1877: EMPTY
1878: LIST
1879: LIST
1880: LIST
1881: LIST
1882: PUSH
1883: LD_INT 3
1885: PUSH
1886: LD_INT 1
1888: PUSH
1889: LD_INT 2
1891: PUSH
1892: LD_INT 7
1894: PUSH
1895: EMPTY
1896: LIST
1897: LIST
1898: LIST
1899: LIST
1900: PUSH
1901: LD_INT 3
1903: PUSH
1904: LD_INT 1
1906: PUSH
1907: LD_INT 2
1909: PUSH
1910: LD_INT 7
1912: PUSH
1913: EMPTY
1914: LIST
1915: LIST
1916: LIST
1917: LIST
1918: PUSH
1919: EMPTY
1920: LIST
1921: LIST
1922: LIST
1923: LIST
1924: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
1925: LD_ADDR_VAR 0 5
1929: PUSH
1930: LD_VAR 0 5
1934: PUSH
1935: LD_OWVAR 1
1939: PUSH
1940: LD_INT 21000
1942: DIV
1943: PLUS
1944: ST_TO_ADDR
// if amount > 8 then
1945: LD_VAR 0 5
1949: PUSH
1950: LD_INT 8
1952: GREATER
1953: IFFALSE 1963
// amount := 8 ;
1955: LD_ADDR_VAR 0 5
1959: PUSH
1960: LD_INT 8
1962: ST_TO_ADDR
// for i = 1 to amount do
1963: LD_ADDR_VAR 0 1
1967: PUSH
1968: DOUBLE
1969: LD_INT 1
1971: DEC
1972: ST_TO_ADDR
1973: LD_VAR 0 5
1977: PUSH
1978: FOR_TO
1979: IFFALSE 2063
// tmp := Insert ( tmp , tmp + 1 , [ [ us_medium_tracked , us_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ us_rocket_launcher , us_double_gun ] [ rand ( 1 , 2 ) ] ] ) ;
1981: LD_ADDR_VAR 0 3
1985: PUSH
1986: LD_VAR 0 3
1990: PPUSH
1991: LD_VAR 0 3
1995: PUSH
1996: LD_INT 1
1998: PLUS
1999: PPUSH
2000: LD_INT 3
2002: PUSH
2003: LD_INT 4
2005: PUSH
2006: EMPTY
2007: LIST
2008: LIST
2009: PUSH
2010: LD_INT 1
2012: PPUSH
2013: LD_INT 2
2015: PPUSH
2016: CALL_OW 12
2020: ARRAY
2021: PUSH
2022: LD_INT 1
2024: PUSH
2025: LD_INT 2
2027: PUSH
2028: LD_INT 7
2030: PUSH
2031: LD_INT 5
2033: PUSH
2034: EMPTY
2035: LIST
2036: LIST
2037: PUSH
2038: LD_INT 1
2040: PPUSH
2041: LD_INT 2
2043: PPUSH
2044: CALL_OW 12
2048: ARRAY
2049: PUSH
2050: EMPTY
2051: LIST
2052: LIST
2053: LIST
2054: LIST
2055: PPUSH
2056: CALL_OW 2
2060: ST_TO_ADDR
2061: GO 1978
2063: POP
2064: POP
// MC_InsertProduceList ( base , tmp ) ;
2065: LD_VAR 0 2
2069: PPUSH
2070: LD_VAR 0 3
2074: PPUSH
2075: CALL 77321 0 2
// repeat wait ( 0 0$1 ) ;
2079: LD_INT 35
2081: PPUSH
2082: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
2086: LD_VAR 0 2
2090: PPUSH
2091: LD_INT 1
2093: PPUSH
2094: CALL 78739 0 2
2098: PUSH
2099: LD_VAR 0 5
2103: GREATEREQUAL
2104: IFFALSE 2079
// wait ( 0 0$30 ) ;
2106: LD_INT 1050
2108: PPUSH
2109: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , us_bulldozer ] ] ) ;
2113: LD_ADDR_VAR 0 4
2117: PUSH
2118: LD_EXP 42
2122: PUSH
2123: LD_VAR 0 2
2127: ARRAY
2128: PUSH
2129: LD_EXP 42
2133: PUSH
2134: LD_VAR 0 2
2138: ARRAY
2139: PPUSH
2140: LD_INT 2
2142: PUSH
2143: LD_INT 34
2145: PUSH
2146: LD_INT 12
2148: PUSH
2149: EMPTY
2150: LIST
2151: LIST
2152: PUSH
2153: LD_INT 34
2155: PUSH
2156: LD_INT 13
2158: PUSH
2159: EMPTY
2160: LIST
2161: LIST
2162: PUSH
2163: LD_INT 34
2165: PUSH
2166: LD_INT 14
2168: PUSH
2169: EMPTY
2170: LIST
2171: LIST
2172: PUSH
2173: EMPTY
2174: LIST
2175: LIST
2176: LIST
2177: LIST
2178: PPUSH
2179: CALL_OW 72
2183: DIFF
2184: ST_TO_ADDR
// if not attackers then
2185: LD_VAR 0 4
2189: NOT
2190: IFFALSE 2194
// exit ;
2192: GO 2481
// DialogPowellsAttack ;
2194: CALL 9685 0 0
// powellAttackGroup := attackers ;
2198: LD_ADDR_EXP 12
2202: PUSH
2203: LD_VAR 0 4
2207: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
2208: LD_ADDR_EXP 42
2212: PUSH
2213: LD_EXP 42
2217: PPUSH
2218: LD_VAR 0 2
2222: PPUSH
2223: LD_EXP 42
2227: PUSH
2228: LD_VAR 0 2
2232: ARRAY
2233: PUSH
2234: LD_VAR 0 4
2238: DIFF
2239: PPUSH
2240: CALL_OW 1
2244: ST_TO_ADDR
// if sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 4 ] ) then
2245: LD_EXP 9
2249: PUSH
2250: LD_INT 16
2252: PPUSH
2253: LD_INT 81
2255: PUSH
2256: LD_INT 4
2258: PUSH
2259: EMPTY
2260: LIST
2261: LIST
2262: PPUSH
2263: CALL_OW 70
2267: AND
2268: IFFALSE 2287
// ComAgressiveMove ( attackers , 135 , 21 ) else
2270: LD_VAR 0 4
2274: PPUSH
2275: LD_INT 135
2277: PPUSH
2278: LD_INT 21
2280: PPUSH
2281: CALL_OW 114
2285: GO 2302
// ComAgressiveMove ( attackers , 146 , 103 ) ;
2287: LD_VAR 0 4
2291: PPUSH
2292: LD_INT 146
2294: PPUSH
2295: LD_INT 103
2297: PPUSH
2298: CALL_OW 114
// wait ( 0 0$5 ) ;
2302: LD_INT 175
2304: PPUSH
2305: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
2309: LD_INT 35
2311: PPUSH
2312: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
2316: LD_VAR 0 4
2320: PPUSH
2321: LD_INT 60
2323: PUSH
2324: EMPTY
2325: LIST
2326: PPUSH
2327: CALL_OW 72
2331: NOT
2332: IFFALSE 2309
// if FilterAllUnits ( [ f_side , 3 ] ) then
2334: LD_INT 22
2336: PUSH
2337: LD_INT 3
2339: PUSH
2340: EMPTY
2341: LIST
2342: LIST
2343: PPUSH
2344: CALL_OW 69
2348: IFFALSE 2367
// ComAgressiveMove ( attackers , 102 , 116 ) else
2350: LD_VAR 0 4
2354: PPUSH
2355: LD_INT 102
2357: PPUSH
2358: LD_INT 116
2360: PPUSH
2361: CALL_OW 114
2365: GO 2382
// ComAgressiveMove ( attackers , 66 , 41 ) ;
2367: LD_VAR 0 4
2371: PPUSH
2372: LD_INT 66
2374: PPUSH
2375: LD_INT 41
2377: PPUSH
2378: CALL_OW 114
// wait ( 0 0$10 ) ;
2382: LD_INT 350
2384: PPUSH
2385: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
2389: LD_INT 35
2391: PPUSH
2392: CALL_OW 67
// for i in attackers do
2396: LD_ADDR_VAR 0 1
2400: PUSH
2401: LD_VAR 0 4
2405: PUSH
2406: FOR_IN
2407: IFFALSE 2457
// if not HasTask ( i ) then
2409: LD_VAR 0 1
2413: PPUSH
2414: CALL_OW 314
2418: NOT
2419: IFFALSE 2455
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) ;
2421: LD_VAR 0 1
2425: PPUSH
2426: LD_INT 81
2428: PUSH
2429: LD_INT 4
2431: PUSH
2432: EMPTY
2433: LIST
2434: LIST
2435: PPUSH
2436: CALL_OW 69
2440: PPUSH
2441: LD_VAR 0 1
2445: PPUSH
2446: CALL_OW 74
2450: PPUSH
2451: CALL_OW 115
2455: GO 2406
2457: POP
2458: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
2459: LD_VAR 0 4
2463: PPUSH
2464: LD_INT 50
2466: PUSH
2467: EMPTY
2468: LIST
2469: PPUSH
2470: CALL_OW 72
2474: NOT
2475: IFFALSE 2389
// DialogPowellsAttackFailed ;
2477: CALL 9950 0 0
// end ;
2481: PPOPN 5
2483: END
// every 0 0$2 do var vehicles , mechs , i ;
2484: GO 2486
2486: DISABLE
2487: LD_INT 0
2489: PPUSH
2490: PPUSH
2491: PPUSH
// begin enable ;
2492: ENABLE
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] , [ f_distxy , 191 , 140 , 10 ] ] ) ;
2493: LD_ADDR_VAR 0 1
2497: PUSH
2498: LD_INT 22
2500: PUSH
2501: LD_INT 1
2503: PUSH
2504: EMPTY
2505: LIST
2506: LIST
2507: PUSH
2508: LD_INT 21
2510: PUSH
2511: LD_INT 2
2513: PUSH
2514: EMPTY
2515: LIST
2516: LIST
2517: PUSH
2518: LD_INT 3
2520: PUSH
2521: LD_INT 24
2523: PUSH
2524: LD_INT 1000
2526: PUSH
2527: EMPTY
2528: LIST
2529: LIST
2530: PUSH
2531: EMPTY
2532: LIST
2533: LIST
2534: PUSH
2535: LD_INT 92
2537: PUSH
2538: LD_INT 191
2540: PUSH
2541: LD_INT 140
2543: PUSH
2544: LD_INT 10
2546: PUSH
2547: EMPTY
2548: LIST
2549: LIST
2550: LIST
2551: LIST
2552: PUSH
2553: EMPTY
2554: LIST
2555: LIST
2556: LIST
2557: LIST
2558: PPUSH
2559: CALL_OW 69
2563: ST_TO_ADDR
// mechs := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 3 ] ] ) ;
2564: LD_ADDR_VAR 0 2
2568: PUSH
2569: LD_INT 22
2571: PUSH
2572: LD_INT 4
2574: PUSH
2575: EMPTY
2576: LIST
2577: LIST
2578: PUSH
2579: LD_INT 25
2581: PUSH
2582: LD_INT 3
2584: PUSH
2585: EMPTY
2586: LIST
2587: LIST
2588: PUSH
2589: EMPTY
2590: LIST
2591: LIST
2592: PPUSH
2593: CALL_OW 69
2597: ST_TO_ADDR
// if not mechs then
2598: LD_VAR 0 2
2602: NOT
2603: IFFALSE 2607
// exit ;
2605: GO 2781
// if mc_remote_driver [ 1 ] then
2607: LD_EXP 63
2611: PUSH
2612: LD_INT 1
2614: ARRAY
2615: IFFALSE 2637
// mechs := mechs diff mc_remote_driver [ 1 ] ;
2617: LD_ADDR_VAR 0 2
2621: PUSH
2622: LD_VAR 0 2
2626: PUSH
2627: LD_EXP 63
2631: PUSH
2632: LD_INT 1
2634: ARRAY
2635: DIFF
2636: ST_TO_ADDR
// if not mechs then
2637: LD_VAR 0 2
2641: NOT
2642: IFFALSE 2646
// exit ;
2644: GO 2781
// if vehicles then
2646: LD_VAR 0 1
2650: IFFALSE 2738
// begin for i in mechs do
2652: LD_ADDR_VAR 0 3
2656: PUSH
2657: LD_VAR 0 2
2661: PUSH
2662: FOR_IN
2663: IFFALSE 2734
// begin if GetTag ( i ) <> 120 then
2665: LD_VAR 0 3
2669: PPUSH
2670: CALL_OW 110
2674: PUSH
2675: LD_INT 120
2677: NONEQUAL
2678: IFFALSE 2692
// SetTag ( i , 120 ) ;
2680: LD_VAR 0 3
2684: PPUSH
2685: LD_INT 120
2687: PPUSH
2688: CALL_OW 109
// if IsInUnit ( i ) then
2692: LD_VAR 0 3
2696: PPUSH
2697: CALL_OW 310
2701: IFFALSE 2714
// ComExitBuilding ( i ) else
2703: LD_VAR 0 3
2707: PPUSH
2708: CALL_OW 122
2712: GO 2732
// ComRepairVehicle ( i , vehicles [ 1 ] ) ;
2714: LD_VAR 0 3
2718: PPUSH
2719: LD_VAR 0 1
2723: PUSH
2724: LD_INT 1
2726: ARRAY
2727: PPUSH
2728: CALL_OW 129
// end ;
2732: GO 2662
2734: POP
2735: POP
// end else
2736: GO 2781
// if FilterByTag ( mechs , 120 ) then
2738: LD_VAR 0 2
2742: PPUSH
2743: LD_INT 120
2745: PPUSH
2746: CALL 46386 0 2
2750: IFFALSE 2781
// begin for i in mechs do
2752: LD_ADDR_VAR 0 3
2756: PUSH
2757: LD_VAR 0 2
2761: PUSH
2762: FOR_IN
2763: IFFALSE 2779
// begin SetTag ( i , 0 ) ;
2765: LD_VAR 0 3
2769: PPUSH
2770: LD_INT 0
2772: PPUSH
2773: CALL_OW 109
// end ;
2777: GO 2762
2779: POP
2780: POP
// end ; end ;
2781: PPOPN 3
2783: END
// every 0 0$2 do var people , sci , i ;
2784: GO 2786
2786: DISABLE
2787: LD_INT 0
2789: PPUSH
2790: PPUSH
2791: PPUSH
// begin enable ;
2792: ENABLE
// people := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] , [ f_distxy , 188 , 112 , 10 ] ] ) ;
2793: LD_ADDR_VAR 0 1
2797: PUSH
2798: LD_INT 22
2800: PUSH
2801: LD_INT 1
2803: PUSH
2804: EMPTY
2805: LIST
2806: LIST
2807: PUSH
2808: LD_INT 21
2810: PUSH
2811: LD_INT 1
2813: PUSH
2814: EMPTY
2815: LIST
2816: LIST
2817: PUSH
2818: LD_INT 3
2820: PUSH
2821: LD_INT 24
2823: PUSH
2824: LD_INT 1000
2826: PUSH
2827: EMPTY
2828: LIST
2829: LIST
2830: PUSH
2831: EMPTY
2832: LIST
2833: LIST
2834: PUSH
2835: LD_INT 92
2837: PUSH
2838: LD_INT 188
2840: PUSH
2841: LD_INT 112
2843: PUSH
2844: LD_INT 10
2846: PUSH
2847: EMPTY
2848: LIST
2849: LIST
2850: LIST
2851: LIST
2852: PUSH
2853: EMPTY
2854: LIST
2855: LIST
2856: LIST
2857: LIST
2858: PPUSH
2859: CALL_OW 69
2863: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 4 ] ] ) ;
2864: LD_ADDR_VAR 0 2
2868: PUSH
2869: LD_INT 22
2871: PUSH
2872: LD_INT 4
2874: PUSH
2875: EMPTY
2876: LIST
2877: LIST
2878: PUSH
2879: LD_INT 25
2881: PUSH
2882: LD_INT 4
2884: PUSH
2885: EMPTY
2886: LIST
2887: LIST
2888: PUSH
2889: EMPTY
2890: LIST
2891: LIST
2892: PPUSH
2893: CALL_OW 69
2897: ST_TO_ADDR
// if not sci then
2898: LD_VAR 0 2
2902: NOT
2903: IFFALSE 2907
// exit ;
2905: GO 3042
// if people then
2907: LD_VAR 0 1
2911: IFFALSE 2999
// begin for i in sci do
2913: LD_ADDR_VAR 0 3
2917: PUSH
2918: LD_VAR 0 2
2922: PUSH
2923: FOR_IN
2924: IFFALSE 2995
// begin if GetTag ( i ) <> 102 then
2926: LD_VAR 0 3
2930: PPUSH
2931: CALL_OW 110
2935: PUSH
2936: LD_INT 102
2938: NONEQUAL
2939: IFFALSE 2953
// SetTag ( i , 102 ) ;
2941: LD_VAR 0 3
2945: PPUSH
2946: LD_INT 102
2948: PPUSH
2949: CALL_OW 109
// if IsInUnit ( i ) then
2953: LD_VAR 0 3
2957: PPUSH
2958: CALL_OW 310
2962: IFFALSE 2975
// ComExitBuilding ( i ) else
2964: LD_VAR 0 3
2968: PPUSH
2969: CALL_OW 122
2973: GO 2993
// ComHeal ( i , people [ 1 ] ) ;
2975: LD_VAR 0 3
2979: PPUSH
2980: LD_VAR 0 1
2984: PUSH
2985: LD_INT 1
2987: ARRAY
2988: PPUSH
2989: CALL_OW 128
// end ;
2993: GO 2923
2995: POP
2996: POP
// end else
2997: GO 3042
// if FilterByTag ( sci , 102 ) then
2999: LD_VAR 0 2
3003: PPUSH
3004: LD_INT 102
3006: PPUSH
3007: CALL 46386 0 2
3011: IFFALSE 3042
// begin for i in sci do
3013: LD_ADDR_VAR 0 3
3017: PUSH
3018: LD_VAR 0 2
3022: PUSH
3023: FOR_IN
3024: IFFALSE 3040
// begin SetTag ( i , 0 ) ;
3026: LD_VAR 0 3
3030: PPUSH
3031: LD_INT 0
3033: PPUSH
3034: CALL_OW 109
// end ;
3038: GO 3023
3040: POP
3041: POP
// end ; end ;
3042: PPOPN 3
3044: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 4 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
3045: LD_INT 22
3047: PUSH
3048: LD_INT 4
3050: PUSH
3051: EMPTY
3052: LIST
3053: LIST
3054: PUSH
3055: LD_INT 33
3057: PUSH
3058: LD_INT 2
3060: PUSH
3061: EMPTY
3062: LIST
3063: LIST
3064: PUSH
3065: LD_INT 50
3067: PUSH
3068: EMPTY
3069: LIST
3070: PUSH
3071: LD_INT 3
3073: PUSH
3074: LD_INT 61
3076: PUSH
3077: EMPTY
3078: LIST
3079: PUSH
3080: EMPTY
3081: LIST
3082: LIST
3083: PUSH
3084: EMPTY
3085: LIST
3086: LIST
3087: LIST
3088: LIST
3089: PPUSH
3090: CALL_OW 69
3094: IFFALSE 3185
3096: GO 3098
3098: DISABLE
3099: LD_INT 0
3101: PPUSH
3102: PPUSH
// begin enable ;
3103: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
3104: LD_ADDR_VAR 0 2
3108: PUSH
3109: LD_INT 22
3111: PUSH
3112: LD_INT 4
3114: PUSH
3115: EMPTY
3116: LIST
3117: LIST
3118: PUSH
3119: LD_INT 33
3121: PUSH
3122: LD_INT 2
3124: PUSH
3125: EMPTY
3126: LIST
3127: LIST
3128: PUSH
3129: LD_INT 50
3131: PUSH
3132: EMPTY
3133: LIST
3134: PUSH
3135: LD_INT 3
3137: PUSH
3138: LD_INT 61
3140: PUSH
3141: EMPTY
3142: LIST
3143: PUSH
3144: EMPTY
3145: LIST
3146: LIST
3147: PUSH
3148: EMPTY
3149: LIST
3150: LIST
3151: LIST
3152: LIST
3153: PPUSH
3154: CALL_OW 69
3158: ST_TO_ADDR
// for i in tmp do
3159: LD_ADDR_VAR 0 1
3163: PUSH
3164: LD_VAR 0 2
3168: PUSH
3169: FOR_IN
3170: IFFALSE 3183
// Connect ( i ) ;
3172: LD_VAR 0 1
3176: PPUSH
3177: CALL 19423 0 1
3181: GO 3169
3183: POP
3184: POP
// end ; end_of_file
3185: PPOPN 2
3187: END
// export Gensher , gensher_side , gensherAttackGroup ; export function PrepareGensher ; var i , b , tmp , un , list ; begin
3188: LD_INT 0
3190: PPUSH
3191: PPUSH
3192: PPUSH
3193: PPUSH
3194: PPUSH
3195: PPUSH
// gensher_side := 2 ;
3196: LD_ADDR_EXP 14
3200: PUSH
3201: LD_INT 2
3203: ST_TO_ADDR
// uc_side := gensher_side ;
3204: LD_ADDR_OWVAR 20
3208: PUSH
3209: LD_EXP 14
3213: ST_TO_ADDR
// uc_nation := 2 ;
3214: LD_ADDR_OWVAR 21
3218: PUSH
3219: LD_INT 2
3221: ST_TO_ADDR
// list := [ [ b_barracks , 42 , 29 , 5 ] , [ b_barracks , 36 , 40 , 5 ] , [ b_lab , 13 , 18 , 1 , b_lab_weapon , b_lab_opto ] , [ b_solar_power , 17 , 3 , 0 ] , [ b_oil_mine , 56 , 23 , 0 ] , [ b_factory , 11 , 7 , 2 ] , [ b_solar_power , 20 , 3 , 0 ] , [ b_solar_power , 23 , 3 , 0 ] , [ b_solar_power , 26 , 3 , 0 ] , [ b_lab , 17 , 27 , 1 , b_lab_biological , b_lab_siberium ] , [ b_bunker , 27 , 44 , 5 , ar_gun ] , [ b_bunker , 41 , 41 , 5 , ar_gun ] , [ b_bunker , 45 , 24 , 5 , ar_rocket_launcher ] , [ b_bunker , 48 , 19 , 5 , ar_rocket_launcher ] , [ b_bunker , 41 , 3 , 4 , ar_rocket_launcher ] , [ b_barracks , 44 , 9 , 4 ] , [ b_siberite_mine , 52 , 40 , 3 ] ] ;
3222: LD_ADDR_VAR 0 6
3226: PUSH
3227: LD_INT 5
3229: PUSH
3230: LD_INT 42
3232: PUSH
3233: LD_INT 29
3235: PUSH
3236: LD_INT 5
3238: PUSH
3239: EMPTY
3240: LIST
3241: LIST
3242: LIST
3243: LIST
3244: PUSH
3245: LD_INT 5
3247: PUSH
3248: LD_INT 36
3250: PUSH
3251: LD_INT 40
3253: PUSH
3254: LD_INT 5
3256: PUSH
3257: EMPTY
3258: LIST
3259: LIST
3260: LIST
3261: LIST
3262: PUSH
3263: LD_INT 6
3265: PUSH
3266: LD_INT 13
3268: PUSH
3269: LD_INT 18
3271: PUSH
3272: LD_INT 1
3274: PUSH
3275: LD_INT 10
3277: PUSH
3278: LD_INT 15
3280: PUSH
3281: EMPTY
3282: LIST
3283: LIST
3284: LIST
3285: LIST
3286: LIST
3287: LIST
3288: PUSH
3289: LD_INT 27
3291: PUSH
3292: LD_INT 17
3294: PUSH
3295: LD_INT 3
3297: PUSH
3298: LD_INT 0
3300: PUSH
3301: EMPTY
3302: LIST
3303: LIST
3304: LIST
3305: LIST
3306: PUSH
3307: LD_INT 29
3309: PUSH
3310: LD_INT 56
3312: PUSH
3313: LD_INT 23
3315: PUSH
3316: LD_INT 0
3318: PUSH
3319: EMPTY
3320: LIST
3321: LIST
3322: LIST
3323: LIST
3324: PUSH
3325: LD_INT 3
3327: PUSH
3328: LD_INT 11
3330: PUSH
3331: LD_INT 7
3333: PUSH
3334: LD_INT 2
3336: PUSH
3337: EMPTY
3338: LIST
3339: LIST
3340: LIST
3341: LIST
3342: PUSH
3343: LD_INT 27
3345: PUSH
3346: LD_INT 20
3348: PUSH
3349: LD_INT 3
3351: PUSH
3352: LD_INT 0
3354: PUSH
3355: EMPTY
3356: LIST
3357: LIST
3358: LIST
3359: LIST
3360: PUSH
3361: LD_INT 27
3363: PUSH
3364: LD_INT 23
3366: PUSH
3367: LD_INT 3
3369: PUSH
3370: LD_INT 0
3372: PUSH
3373: EMPTY
3374: LIST
3375: LIST
3376: LIST
3377: LIST
3378: PUSH
3379: LD_INT 27
3381: PUSH
3382: LD_INT 26
3384: PUSH
3385: LD_INT 3
3387: PUSH
3388: LD_INT 0
3390: PUSH
3391: EMPTY
3392: LIST
3393: LIST
3394: LIST
3395: LIST
3396: PUSH
3397: LD_INT 6
3399: PUSH
3400: LD_INT 17
3402: PUSH
3403: LD_INT 27
3405: PUSH
3406: LD_INT 1
3408: PUSH
3409: LD_INT 13
3411: PUSH
3412: LD_INT 11
3414: PUSH
3415: EMPTY
3416: LIST
3417: LIST
3418: LIST
3419: LIST
3420: LIST
3421: LIST
3422: PUSH
3423: LD_INT 32
3425: PUSH
3426: LD_INT 27
3428: PUSH
3429: LD_INT 44
3431: PUSH
3432: LD_INT 5
3434: PUSH
3435: LD_INT 27
3437: PUSH
3438: EMPTY
3439: LIST
3440: LIST
3441: LIST
3442: LIST
3443: LIST
3444: PUSH
3445: LD_INT 32
3447: PUSH
3448: LD_INT 41
3450: PUSH
3451: LD_INT 41
3453: PUSH
3454: LD_INT 5
3456: PUSH
3457: LD_INT 27
3459: PUSH
3460: EMPTY
3461: LIST
3462: LIST
3463: LIST
3464: LIST
3465: LIST
3466: PUSH
3467: LD_INT 32
3469: PUSH
3470: LD_INT 45
3472: PUSH
3473: LD_INT 24
3475: PUSH
3476: LD_INT 5
3478: PUSH
3479: LD_INT 28
3481: PUSH
3482: EMPTY
3483: LIST
3484: LIST
3485: LIST
3486: LIST
3487: LIST
3488: PUSH
3489: LD_INT 32
3491: PUSH
3492: LD_INT 48
3494: PUSH
3495: LD_INT 19
3497: PUSH
3498: LD_INT 5
3500: PUSH
3501: LD_INT 28
3503: PUSH
3504: EMPTY
3505: LIST
3506: LIST
3507: LIST
3508: LIST
3509: LIST
3510: PUSH
3511: LD_INT 32
3513: PUSH
3514: LD_INT 41
3516: PUSH
3517: LD_INT 3
3519: PUSH
3520: LD_INT 4
3522: PUSH
3523: LD_INT 28
3525: PUSH
3526: EMPTY
3527: LIST
3528: LIST
3529: LIST
3530: LIST
3531: LIST
3532: PUSH
3533: LD_INT 5
3535: PUSH
3536: LD_INT 44
3538: PUSH
3539: LD_INT 9
3541: PUSH
3542: LD_INT 4
3544: PUSH
3545: EMPTY
3546: LIST
3547: LIST
3548: LIST
3549: LIST
3550: PUSH
3551: LD_INT 30
3553: PUSH
3554: LD_INT 52
3556: PUSH
3557: LD_INT 40
3559: PUSH
3560: LD_INT 3
3562: PUSH
3563: EMPTY
3564: LIST
3565: LIST
3566: LIST
3567: LIST
3568: PUSH
3569: EMPTY
3570: LIST
3571: LIST
3572: LIST
3573: LIST
3574: LIST
3575: LIST
3576: LIST
3577: LIST
3578: LIST
3579: LIST
3580: LIST
3581: LIST
3582: LIST
3583: LIST
3584: LIST
3585: LIST
3586: LIST
3587: ST_TO_ADDR
// for i in list do
3588: LD_ADDR_VAR 0 2
3592: PUSH
3593: LD_VAR 0 6
3597: PUSH
3598: FOR_IN
3599: IFFALSE 3809
// begin uc_side := 2 ;
3601: LD_ADDR_OWVAR 20
3605: PUSH
3606: LD_INT 2
3608: ST_TO_ADDR
// uc_nation := 2 ;
3609: LD_ADDR_OWVAR 21
3613: PUSH
3614: LD_INT 2
3616: ST_TO_ADDR
// InitBc ;
3617: CALL_OW 21
// bc_type := i [ 1 ] ;
3621: LD_ADDR_OWVAR 42
3625: PUSH
3626: LD_VAR 0 2
3630: PUSH
3631: LD_INT 1
3633: ARRAY
3634: ST_TO_ADDR
// if i [ 1 ] in [ b_oil_mine , b_siberite_mine ] then
3635: LD_VAR 0 2
3639: PUSH
3640: LD_INT 1
3642: ARRAY
3643: PUSH
3644: LD_INT 29
3646: PUSH
3647: LD_INT 30
3649: PUSH
3650: EMPTY
3651: LIST
3652: LIST
3653: IN
3654: IFFALSE 3681
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , 2 ) ;
3656: LD_VAR 0 2
3660: PUSH
3661: LD_INT 2
3663: ARRAY
3664: PPUSH
3665: LD_VAR 0 2
3669: PUSH
3670: LD_INT 3
3672: ARRAY
3673: PPUSH
3674: LD_INT 2
3676: PPUSH
3677: CALL_OW 441
// if i [ 1 ] = b_lab then
3681: LD_VAR 0 2
3685: PUSH
3686: LD_INT 1
3688: ARRAY
3689: PUSH
3690: LD_INT 6
3692: EQUAL
3693: IFFALSE 3731
// begin bc_type := b_lab_full ;
3695: LD_ADDR_OWVAR 42
3699: PUSH
3700: LD_INT 8
3702: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
3703: LD_ADDR_OWVAR 44
3707: PUSH
3708: LD_VAR 0 2
3712: PUSH
3713: LD_INT 5
3715: ARRAY
3716: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
3717: LD_ADDR_OWVAR 45
3721: PUSH
3722: LD_VAR 0 2
3726: PUSH
3727: LD_INT 6
3729: ARRAY
3730: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
3731: LD_ADDR_VAR 0 3
3735: PUSH
3736: LD_VAR 0 2
3740: PUSH
3741: LD_INT 2
3743: ARRAY
3744: PPUSH
3745: LD_VAR 0 2
3749: PUSH
3750: LD_INT 3
3752: ARRAY
3753: PPUSH
3754: LD_VAR 0 2
3758: PUSH
3759: LD_INT 4
3761: ARRAY
3762: PPUSH
3763: CALL_OW 47
3767: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
3768: LD_VAR 0 2
3772: PUSH
3773: LD_INT 1
3775: ARRAY
3776: PUSH
3777: LD_INT 33
3779: PUSH
3780: LD_INT 32
3782: PUSH
3783: EMPTY
3784: LIST
3785: LIST
3786: IN
3787: IFFALSE 3807
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
3789: LD_VAR 0 3
3793: PPUSH
3794: LD_VAR 0 2
3798: PUSH
3799: LD_INT 5
3801: ARRAY
3802: PPUSH
3803: CALL_OW 431
// end ;
3807: GO 3598
3809: POP
3810: POP
// tmp := PrepareBase ( ar_depot , gensher_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 11500 , 1100 , 60 ] , [ 6 , 6 , 6 , 6 ] ) ;
3811: LD_ADDR_VAR 0 4
3815: PUSH
3816: LD_INT 7
3818: PPUSH
3819: LD_INT 2
3821: PPUSH
3822: LD_STRING 
3824: PPUSH
3825: LD_INT 8
3827: PUSH
3828: LD_INT 7
3830: PUSH
3831: LD_INT 6
3833: PUSH
3834: EMPTY
3835: LIST
3836: LIST
3837: LIST
3838: PUSH
3839: LD_OWVAR 67
3843: ARRAY
3844: PPUSH
3845: LD_INT 11500
3847: PUSH
3848: LD_INT 1100
3850: PUSH
3851: LD_INT 60
3853: PUSH
3854: EMPTY
3855: LIST
3856: LIST
3857: LIST
3858: PPUSH
3859: LD_INT 6
3861: PUSH
3862: LD_INT 6
3864: PUSH
3865: LD_INT 6
3867: PUSH
3868: LD_INT 6
3870: PUSH
3871: EMPTY
3872: LIST
3873: LIST
3874: LIST
3875: LIST
3876: PPUSH
3877: CALL 19776 0 6
3881: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ) ;
3882: LD_ADDR_EXP 23
3886: PUSH
3887: LD_EXP 23
3891: PPUSH
3892: LD_INT 2
3894: PPUSH
3895: LD_VAR 0 4
3899: PUSH
3900: LD_INT 22
3902: PUSH
3903: LD_INT 2
3905: PUSH
3906: EMPTY
3907: LIST
3908: LIST
3909: PUSH
3910: LD_INT 21
3912: PUSH
3913: LD_INT 3
3915: PUSH
3916: EMPTY
3917: LIST
3918: LIST
3919: PUSH
3920: EMPTY
3921: LIST
3922: LIST
3923: PPUSH
3924: CALL_OW 69
3928: UNION
3929: PPUSH
3930: CALL_OW 1
3934: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] ] ) ;
3935: LD_ADDR_VAR 0 4
3939: PUSH
3940: LD_INT 22
3942: PUSH
3943: LD_INT 2
3945: PUSH
3946: EMPTY
3947: LIST
3948: LIST
3949: PUSH
3950: LD_INT 30
3952: PUSH
3953: LD_INT 31
3955: PUSH
3956: EMPTY
3957: LIST
3958: LIST
3959: PUSH
3960: EMPTY
3961: LIST
3962: LIST
3963: PPUSH
3964: CALL_OW 69
3968: ST_TO_ADDR
// for i in tmp do
3969: LD_ADDR_VAR 0 2
3973: PUSH
3974: LD_VAR 0 4
3978: PUSH
3979: FOR_IN
3980: IFFALSE 4050
// begin PrepareHuman ( false , 1 , [ 4 , 3 , 3 ] [ Difficulty ] ) ;
3982: LD_INT 0
3984: PPUSH
3985: LD_INT 1
3987: PPUSH
3988: LD_INT 4
3990: PUSH
3991: LD_INT 3
3993: PUSH
3994: LD_INT 3
3996: PUSH
3997: EMPTY
3998: LIST
3999: LIST
4000: LIST
4001: PUSH
4002: LD_OWVAR 67
4006: ARRAY
4007: PPUSH
4008: CALL_OW 380
// un := CreateHuman ;
4012: LD_ADDR_VAR 0 5
4016: PUSH
4017: CALL_OW 44
4021: ST_TO_ADDR
// SetDir ( un , 1 ) ;
4022: LD_VAR 0 5
4026: PPUSH
4027: LD_INT 1
4029: PPUSH
4030: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
4034: LD_VAR 0 5
4038: PPUSH
4039: LD_VAR 0 2
4043: PPUSH
4044: CALL_OW 52
// end ;
4048: GO 3979
4050: POP
4051: POP
// tmp := AreaToList ( gensher_mines , 0 ) ;
4052: LD_ADDR_VAR 0 4
4056: PUSH
4057: LD_INT 15
4059: PPUSH
4060: LD_INT 0
4062: PPUSH
4063: CALL_OW 517
4067: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
4068: LD_ADDR_VAR 0 2
4072: PUSH
4073: DOUBLE
4074: LD_INT 1
4076: DEC
4077: ST_TO_ADDR
4078: LD_VAR 0 4
4082: PUSH
4083: LD_INT 1
4085: ARRAY
4086: PUSH
4087: FOR_TO
4088: IFFALSE 4190
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
4090: LD_VAR 0 4
4094: PUSH
4095: LD_INT 1
4097: ARRAY
4098: PUSH
4099: LD_VAR 0 2
4103: ARRAY
4104: PPUSH
4105: LD_VAR 0 4
4109: PUSH
4110: LD_INT 2
4112: ARRAY
4113: PUSH
4114: LD_VAR 0 2
4118: ARRAY
4119: PPUSH
4120: LD_INT 2
4122: PPUSH
4123: LD_INT 0
4125: PPUSH
4126: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
4130: LD_ADDR_EXP 3
4134: PUSH
4135: LD_EXP 3
4139: PPUSH
4140: LD_EXP 3
4144: PUSH
4145: LD_INT 1
4147: PLUS
4148: PPUSH
4149: LD_VAR 0 4
4153: PUSH
4154: LD_INT 1
4156: ARRAY
4157: PUSH
4158: LD_VAR 0 2
4162: ARRAY
4163: PUSH
4164: LD_VAR 0 4
4168: PUSH
4169: LD_INT 2
4171: ARRAY
4172: PUSH
4173: LD_VAR 0 2
4177: ARRAY
4178: PUSH
4179: EMPTY
4180: LIST
4181: LIST
4182: PPUSH
4183: CALL_OW 2
4187: ST_TO_ADDR
// end ;
4188: GO 4087
4190: POP
4191: POP
// if Difficulty > 1 then
4192: LD_OWVAR 67
4196: PUSH
4197: LD_INT 1
4199: GREATER
4200: IFFALSE 4342
// begin tmp := AreaToList ( gensher_mines2 , 0 ) ;
4202: LD_ADDR_VAR 0 4
4206: PUSH
4207: LD_INT 19
4209: PPUSH
4210: LD_INT 0
4212: PPUSH
4213: CALL_OW 517
4217: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
4218: LD_ADDR_VAR 0 2
4222: PUSH
4223: DOUBLE
4224: LD_INT 1
4226: DEC
4227: ST_TO_ADDR
4228: LD_VAR 0 4
4232: PUSH
4233: LD_INT 1
4235: ARRAY
4236: PUSH
4237: FOR_TO
4238: IFFALSE 4340
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
4240: LD_VAR 0 4
4244: PUSH
4245: LD_INT 1
4247: ARRAY
4248: PUSH
4249: LD_VAR 0 2
4253: ARRAY
4254: PPUSH
4255: LD_VAR 0 4
4259: PUSH
4260: LD_INT 2
4262: ARRAY
4263: PUSH
4264: LD_VAR 0 2
4268: ARRAY
4269: PPUSH
4270: LD_INT 2
4272: PPUSH
4273: LD_INT 0
4275: PPUSH
4276: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
4280: LD_ADDR_EXP 3
4284: PUSH
4285: LD_EXP 3
4289: PPUSH
4290: LD_EXP 3
4294: PUSH
4295: LD_INT 1
4297: PLUS
4298: PPUSH
4299: LD_VAR 0 4
4303: PUSH
4304: LD_INT 1
4306: ARRAY
4307: PUSH
4308: LD_VAR 0 2
4312: ARRAY
4313: PUSH
4314: LD_VAR 0 4
4318: PUSH
4319: LD_INT 2
4321: ARRAY
4322: PUSH
4323: LD_VAR 0 2
4327: ARRAY
4328: PUSH
4329: EMPTY
4330: LIST
4331: LIST
4332: PPUSH
4333: CALL_OW 2
4337: ST_TO_ADDR
// end ;
4338: GO 4237
4340: POP
4341: POP
// end ; gensherAttackGroup := [ ] ;
4342: LD_ADDR_EXP 15
4346: PUSH
4347: EMPTY
4348: ST_TO_ADDR
// end ;
4349: LD_VAR 0 1
4353: RET
// export function InitMC_Gensher ( ) ; begin
4354: LD_INT 0
4356: PPUSH
// MC_SetScanArea ( 2 , gensher_base ) ;
4357: LD_INT 2
4359: PPUSH
4360: LD_INT 2
4362: PPUSH
4363: CALL 78594 0 2
// MC_SetParkingArea ( 2 , gensher_parking ) ;
4367: LD_INT 2
4369: PPUSH
4370: LD_INT 9
4372: PPUSH
4373: CALL 78538 0 2
// MC_SetDepositsXY ( 2 , [ [ 56 , 23 , 0 ] , [ 52 , 40 , 1 ] ] ) ;
4377: LD_INT 2
4379: PPUSH
4380: LD_INT 56
4382: PUSH
4383: LD_INT 23
4385: PUSH
4386: LD_INT 0
4388: PUSH
4389: EMPTY
4390: LIST
4391: LIST
4392: LIST
4393: PUSH
4394: LD_INT 52
4396: PUSH
4397: LD_INT 40
4399: PUSH
4400: LD_INT 1
4402: PUSH
4403: EMPTY
4404: LIST
4405: LIST
4406: LIST
4407: PUSH
4408: EMPTY
4409: LIST
4410: LIST
4411: PPUSH
4412: CALL 77597 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ar_gun , ar_rocket_launcher ] ) ;
4416: LD_INT 2
4418: PPUSH
4419: LD_INT 27
4421: PUSH
4422: LD_INT 28
4424: PUSH
4425: EMPTY
4426: LIST
4427: LIST
4428: PPUSH
4429: CALL 78426 0 2
// MC_SetCratesArea ( 2 , gensher_crates ) ;
4433: LD_INT 2
4435: PPUSH
4436: LD_INT 8
4438: PPUSH
4439: CALL 78108 0 2
// MC_SetTame ( 2 , gensher_ape ) ;
4443: LD_INT 2
4445: PPUSH
4446: LD_INT 7
4448: PPUSH
4449: CALL 77839 0 2
// MC_SetDefenderLimit ( 2 , 4 ) ;
4453: LD_INT 2
4455: PPUSH
4456: LD_INT 4
4458: PPUSH
4459: CALL 77458 0 2
// MC_SetProduceList ( 2 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ) ;
4463: LD_INT 2
4465: PPUSH
4466: LD_INT 13
4468: PUSH
4469: LD_INT 2
4471: PUSH
4472: LD_INT 1
4474: PUSH
4475: LD_INT 31
4477: PUSH
4478: EMPTY
4479: LIST
4480: LIST
4481: LIST
4482: LIST
4483: PUSH
4484: LD_INT 13
4486: PUSH
4487: LD_INT 2
4489: PUSH
4490: LD_INT 1
4492: PUSH
4493: LD_INT 31
4495: PUSH
4496: EMPTY
4497: LIST
4498: LIST
4499: LIST
4500: LIST
4501: PUSH
4502: LD_INT 14
4504: PUSH
4505: LD_INT 1
4507: PUSH
4508: LD_INT 2
4510: PUSH
4511: LD_INT 27
4513: PUSH
4514: EMPTY
4515: LIST
4516: LIST
4517: LIST
4518: LIST
4519: PUSH
4520: LD_INT 14
4522: PUSH
4523: LD_INT 1
4525: PUSH
4526: LD_INT 2
4528: PUSH
4529: LD_INT 27
4531: PUSH
4532: EMPTY
4533: LIST
4534: LIST
4535: LIST
4536: LIST
4537: PUSH
4538: LD_INT 14
4540: PUSH
4541: LD_INT 1
4543: PUSH
4544: LD_INT 2
4546: PUSH
4547: LD_INT 28
4549: PUSH
4550: EMPTY
4551: LIST
4552: LIST
4553: LIST
4554: LIST
4555: PUSH
4556: LD_INT 14
4558: PUSH
4559: LD_INT 1
4561: PUSH
4562: LD_INT 2
4564: PUSH
4565: LD_INT 26
4567: PUSH
4568: EMPTY
4569: LIST
4570: LIST
4571: LIST
4572: LIST
4573: PUSH
4574: EMPTY
4575: LIST
4576: LIST
4577: LIST
4578: LIST
4579: LIST
4580: LIST
4581: PPUSH
4582: CALL 77273 0 2
// MC_SetFactoryExtension ( 2 , 11 , 7 , 2 , [ b_ext_stitch , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
4586: LD_INT 2
4588: PPUSH
4589: LD_INT 11
4591: PPUSH
4592: LD_INT 7
4594: PPUSH
4595: LD_INT 2
4597: PPUSH
4598: LD_INT 23
4600: PUSH
4601: LD_INT 16
4603: PUSH
4604: LD_INT 17
4606: PUSH
4607: LD_INT 18
4609: PUSH
4610: LD_INT 22
4612: PUSH
4613: EMPTY
4614: LIST
4615: LIST
4616: LIST
4617: LIST
4618: LIST
4619: PPUSH
4620: CALL 78220 0 5
// end ;
4624: LD_VAR 0 1
4628: RET
// every 2 trigger staticMines and FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) do var i , j , tmp , x , y ;
4629: LD_EXP 3
4633: PUSH
4634: LD_INT 15
4636: PPUSH
4637: LD_INT 81
4639: PUSH
4640: LD_INT 2
4642: PUSH
4643: EMPTY
4644: LIST
4645: LIST
4646: PPUSH
4647: CALL_OW 70
4651: AND
4652: IFFALSE 4865
4654: GO 4656
4656: DISABLE
4657: LD_INT 0
4659: PPUSH
4660: PPUSH
4661: PPUSH
4662: PPUSH
4663: PPUSH
// begin enable ;
4664: ENABLE
// tmp := FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) ;
4665: LD_ADDR_VAR 0 3
4669: PUSH
4670: LD_INT 15
4672: PPUSH
4673: LD_INT 81
4675: PUSH
4676: LD_INT 2
4678: PUSH
4679: EMPTY
4680: LIST
4681: LIST
4682: PPUSH
4683: CALL_OW 70
4687: ST_TO_ADDR
// if not tmp then
4688: LD_VAR 0 3
4692: NOT
4693: IFFALSE 4697
// exit ;
4695: GO 4865
// for i in tmp do
4697: LD_ADDR_VAR 0 1
4701: PUSH
4702: LD_VAR 0 3
4706: PUSH
4707: FOR_IN
4708: IFFALSE 4863
// begin x := GetX ( i ) ;
4710: LD_ADDR_VAR 0 4
4714: PUSH
4715: LD_VAR 0 1
4719: PPUSH
4720: CALL_OW 250
4724: ST_TO_ADDR
// y := GetY ( i ) ;
4725: LD_ADDR_VAR 0 5
4729: PUSH
4730: LD_VAR 0 1
4734: PPUSH
4735: CALL_OW 251
4739: ST_TO_ADDR
// if MineAtPos ( x , y ) then
4740: LD_VAR 0 4
4744: PPUSH
4745: LD_VAR 0 5
4749: PPUSH
4750: CALL_OW 458
4754: IFFALSE 4861
// begin LaunchMineAtPos ( x , y , 2 ) ;
4756: LD_VAR 0 4
4760: PPUSH
4761: LD_VAR 0 5
4765: PPUSH
4766: LD_INT 2
4768: PPUSH
4769: CALL_OW 456
// for j = 1 to staticMines do
4773: LD_ADDR_VAR 0 2
4777: PUSH
4778: DOUBLE
4779: LD_INT 1
4781: DEC
4782: ST_TO_ADDR
4783: LD_EXP 3
4787: PUSH
4788: FOR_TO
4789: IFFALSE 4859
// if staticMines [ j ] [ 1 ] = x and staticMines [ j ] [ 2 ] = y then
4791: LD_EXP 3
4795: PUSH
4796: LD_VAR 0 2
4800: ARRAY
4801: PUSH
4802: LD_INT 1
4804: ARRAY
4805: PUSH
4806: LD_VAR 0 4
4810: EQUAL
4811: PUSH
4812: LD_EXP 3
4816: PUSH
4817: LD_VAR 0 2
4821: ARRAY
4822: PUSH
4823: LD_INT 2
4825: ARRAY
4826: PUSH
4827: LD_VAR 0 5
4831: EQUAL
4832: AND
4833: IFFALSE 4857
// begin staticMines := Delete ( staticMines , j ) ;
4835: LD_ADDR_EXP 3
4839: PUSH
4840: LD_EXP 3
4844: PPUSH
4845: LD_VAR 0 2
4849: PPUSH
4850: CALL_OW 3
4854: ST_TO_ADDR
// break ;
4855: GO 4859
// end ;
4857: GO 4788
4859: POP
4860: POP
// end ; end ;
4861: GO 4707
4863: POP
4864: POP
// end ;
4865: PPOPN 5
4867: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ar_depot ) and not arDestroyed do var i , base , tmp , attackers , amount ;
4868: LD_INT 7
4870: PPUSH
4871: CALL_OW 302
4875: PUSH
4876: LD_EXP 4
4880: NOT
4881: AND
4882: IFFALSE 5482
4884: GO 4886
4886: DISABLE
4887: LD_INT 0
4889: PPUSH
4890: PPUSH
4891: PPUSH
4892: PPUSH
4893: PPUSH
// begin enable ;
4894: ENABLE
// base := 2 ;
4895: LD_ADDR_VAR 0 2
4899: PUSH
4900: LD_INT 2
4902: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ;
4903: LD_ADDR_VAR 0 3
4907: PUSH
4908: LD_INT 14
4910: PUSH
4911: LD_INT 1
4913: PUSH
4914: LD_INT 2
4916: PUSH
4917: LD_INT 27
4919: PUSH
4920: EMPTY
4921: LIST
4922: LIST
4923: LIST
4924: LIST
4925: PUSH
4926: LD_INT 14
4928: PUSH
4929: LD_INT 1
4931: PUSH
4932: LD_INT 2
4934: PUSH
4935: LD_INT 27
4937: PUSH
4938: EMPTY
4939: LIST
4940: LIST
4941: LIST
4942: LIST
4943: PUSH
4944: LD_INT 14
4946: PUSH
4947: LD_INT 1
4949: PUSH
4950: LD_INT 2
4952: PUSH
4953: LD_INT 28
4955: PUSH
4956: EMPTY
4957: LIST
4958: LIST
4959: LIST
4960: LIST
4961: PUSH
4962: LD_INT 14
4964: PUSH
4965: LD_INT 1
4967: PUSH
4968: LD_INT 2
4970: PUSH
4971: LD_INT 26
4973: PUSH
4974: EMPTY
4975: LIST
4976: LIST
4977: LIST
4978: LIST
4979: PUSH
4980: EMPTY
4981: LIST
4982: LIST
4983: LIST
4984: LIST
4985: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
4986: LD_ADDR_VAR 0 5
4990: PUSH
4991: LD_VAR 0 5
4995: PUSH
4996: LD_OWVAR 1
5000: PUSH
5001: LD_INT 21000
5003: DIV
5004: PLUS
5005: ST_TO_ADDR
// if amount > 8 then
5006: LD_VAR 0 5
5010: PUSH
5011: LD_INT 8
5013: GREATER
5014: IFFALSE 5024
// amount := 8 ;
5016: LD_ADDR_VAR 0 5
5020: PUSH
5021: LD_INT 8
5023: ST_TO_ADDR
// for i = 1 to amount do
5024: LD_ADDR_VAR 0 1
5028: PUSH
5029: DOUBLE
5030: LD_INT 1
5032: DEC
5033: ST_TO_ADDR
5034: LD_VAR 0 5
5038: PUSH
5039: FOR_TO
5040: IFFALSE 5128
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_half_tracked , ar_medium_trike ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gatling_gun , ar_gun ] [ rand ( 1 , 3 ) ] ] ) ;
5042: LD_ADDR_VAR 0 3
5046: PUSH
5047: LD_VAR 0 3
5051: PPUSH
5052: LD_VAR 0 3
5056: PUSH
5057: LD_INT 1
5059: PLUS
5060: PPUSH
5061: LD_INT 14
5063: PUSH
5064: LD_INT 13
5066: PUSH
5067: EMPTY
5068: LIST
5069: LIST
5070: PUSH
5071: LD_INT 1
5073: PPUSH
5074: LD_INT 2
5076: PPUSH
5077: CALL_OW 12
5081: ARRAY
5082: PUSH
5083: LD_INT 1
5085: PUSH
5086: LD_INT 2
5088: PUSH
5089: LD_INT 28
5091: PUSH
5092: LD_INT 25
5094: PUSH
5095: LD_INT 27
5097: PUSH
5098: EMPTY
5099: LIST
5100: LIST
5101: LIST
5102: PUSH
5103: LD_INT 1
5105: PPUSH
5106: LD_INT 3
5108: PPUSH
5109: CALL_OW 12
5113: ARRAY
5114: PUSH
5115: EMPTY
5116: LIST
5117: LIST
5118: LIST
5119: LIST
5120: PPUSH
5121: CALL_OW 2
5125: ST_TO_ADDR
5126: GO 5039
5128: POP
5129: POP
// MC_InsertProduceList ( base , tmp ) ;
5130: LD_VAR 0 2
5134: PPUSH
5135: LD_VAR 0 3
5139: PPUSH
5140: CALL 77321 0 2
// repeat wait ( 0 0$1 ) ;
5144: LD_INT 35
5146: PPUSH
5147: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
5151: LD_VAR 0 2
5155: PPUSH
5156: LD_INT 1
5158: PPUSH
5159: CALL 78739 0 2
5163: PUSH
5164: LD_VAR 0 5
5168: GREATEREQUAL
5169: IFFALSE 5144
// wait ( 0 0$30 ) ;
5171: LD_INT 1050
5173: PPUSH
5174: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_control_tower ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
5178: LD_ADDR_VAR 0 4
5182: PUSH
5183: LD_EXP 42
5187: PUSH
5188: LD_VAR 0 2
5192: ARRAY
5193: PUSH
5194: LD_EXP 42
5198: PUSH
5199: LD_VAR 0 2
5203: ARRAY
5204: PPUSH
5205: LD_INT 2
5207: PUSH
5208: LD_INT 34
5210: PUSH
5211: LD_INT 31
5213: PUSH
5214: EMPTY
5215: LIST
5216: LIST
5217: PUSH
5218: LD_INT 34
5220: PUSH
5221: LD_INT 32
5223: PUSH
5224: EMPTY
5225: LIST
5226: LIST
5227: PUSH
5228: LD_INT 34
5230: PUSH
5231: LD_INT 88
5233: PUSH
5234: EMPTY
5235: LIST
5236: LIST
5237: PUSH
5238: EMPTY
5239: LIST
5240: LIST
5241: LIST
5242: LIST
5243: PPUSH
5244: CALL_OW 72
5248: DIFF
5249: ST_TO_ADDR
// if not attackers then
5250: LD_VAR 0 4
5254: NOT
5255: IFFALSE 5259
// exit ;
5257: GO 5482
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
5259: LD_ADDR_EXP 42
5263: PUSH
5264: LD_EXP 42
5268: PPUSH
5269: LD_VAR 0 2
5273: PPUSH
5274: LD_EXP 42
5278: PUSH
5279: LD_VAR 0 2
5283: ARRAY
5284: PUSH
5285: LD_VAR 0 4
5289: DIFF
5290: PPUSH
5291: CALL_OW 1
5295: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
5296: LD_VAR 0 4
5300: PPUSH
5301: LD_INT 107
5303: PPUSH
5304: LD_INT 74
5306: PPUSH
5307: CALL_OW 114
// wait ( 0 0$5 ) ;
5311: LD_INT 175
5313: PPUSH
5314: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
5318: LD_INT 35
5320: PPUSH
5321: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5325: LD_VAR 0 4
5329: PPUSH
5330: LD_INT 60
5332: PUSH
5333: EMPTY
5334: LIST
5335: PPUSH
5336: CALL_OW 72
5340: NOT
5341: IFFALSE 5318
// if rand ( 0 , 1 ) then
5343: LD_INT 0
5345: PPUSH
5346: LD_INT 1
5348: PPUSH
5349: CALL_OW 12
5353: IFFALSE 5372
// ComAgressiveMove ( attackers , 155 , 108 ) else
5355: LD_VAR 0 4
5359: PPUSH
5360: LD_INT 155
5362: PPUSH
5363: LD_INT 108
5365: PPUSH
5366: CALL_OW 114
5370: GO 5387
// ComAgressiveMove ( attackers , 149 , 55 ) ;
5372: LD_VAR 0 4
5376: PPUSH
5377: LD_INT 149
5379: PPUSH
5380: LD_INT 55
5382: PPUSH
5383: CALL_OW 114
// wait ( 0 0$10 ) ;
5387: LD_INT 350
5389: PPUSH
5390: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
5394: LD_INT 35
5396: PPUSH
5397: CALL_OW 67
// for i in attackers do
5401: LD_ADDR_VAR 0 1
5405: PUSH
5406: LD_VAR 0 4
5410: PUSH
5411: FOR_IN
5412: IFFALSE 5462
// if not HasTask ( i ) then
5414: LD_VAR 0 1
5418: PPUSH
5419: CALL_OW 314
5423: NOT
5424: IFFALSE 5460
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
5426: LD_VAR 0 1
5430: PPUSH
5431: LD_INT 81
5433: PUSH
5434: LD_INT 2
5436: PUSH
5437: EMPTY
5438: LIST
5439: LIST
5440: PPUSH
5441: CALL_OW 69
5445: PPUSH
5446: LD_VAR 0 1
5450: PPUSH
5451: CALL_OW 74
5455: PPUSH
5456: CALL_OW 115
5460: GO 5411
5462: POP
5463: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
5464: LD_VAR 0 4
5468: PPUSH
5469: LD_INT 50
5471: PUSH
5472: EMPTY
5473: LIST
5474: PPUSH
5475: CALL_OW 72
5479: NOT
5480: IFFALSE 5394
// end ;
5482: PPOPN 5
5484: END
// every 8 8$00 + 9 9$00 trigger not arDestroyed and tick < 91 91$00 do var i , un , tmp ;
5485: LD_EXP 4
5489: NOT
5490: PUSH
5491: LD_OWVAR 1
5495: PUSH
5496: LD_INT 191100
5498: LESS
5499: AND
5500: IFFALSE 6172
5502: GO 5504
5504: DISABLE
5505: LD_INT 0
5507: PPUSH
5508: PPUSH
5509: PPUSH
// begin enable ;
5510: ENABLE
// tmp := [ ] ;
5511: LD_ADDR_VAR 0 3
5515: PUSH
5516: EMPTY
5517: ST_TO_ADDR
// if tick < 35 35$00 then
5518: LD_OWVAR 1
5522: PUSH
5523: LD_INT 73500
5525: LESS
5526: IFFALSE 5724
// begin for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
5528: LD_ADDR_VAR 0 1
5532: PUSH
5533: DOUBLE
5534: LD_INT 1
5536: DEC
5537: ST_TO_ADDR
5538: LD_INT 4
5540: PUSH
5541: LD_INT 5
5543: PUSH
5544: LD_INT 5
5546: PUSH
5547: EMPTY
5548: LIST
5549: LIST
5550: LIST
5551: PUSH
5552: LD_OWVAR 67
5556: ARRAY
5557: PUSH
5558: FOR_TO
5559: IFFALSE 5720
// begin uc_side := 2 ;
5561: LD_ADDR_OWVAR 20
5565: PUSH
5566: LD_INT 2
5568: ST_TO_ADDR
// uc_nation := 2 ;
5569: LD_ADDR_OWVAR 21
5573: PUSH
5574: LD_INT 2
5576: ST_TO_ADDR
// InitHC_All ( ) ;
5577: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
5581: LD_INT 0
5583: PPUSH
5584: LD_INT 1
5586: PPUSH
5587: LD_INT 5
5589: PUSH
5590: LD_INT 6
5592: PUSH
5593: LD_INT 7
5595: PUSH
5596: EMPTY
5597: LIST
5598: LIST
5599: LIST
5600: PUSH
5601: LD_OWVAR 67
5605: ARRAY
5606: PPUSH
5607: CALL_OW 380
// un := CreateHuman ;
5611: LD_ADDR_VAR 0 2
5615: PUSH
5616: CALL_OW 44
5620: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5621: LD_VAR 0 2
5625: PPUSH
5626: LD_INT 17
5628: PPUSH
5629: LD_INT 0
5631: PPUSH
5632: CALL_OW 49
// SetClass ( un , [ class_soldier , class_mortar ] [ rand ( 1 , 2 ) ] ) ;
5636: LD_VAR 0 2
5640: PPUSH
5641: LD_INT 1
5643: PUSH
5644: LD_INT 8
5646: PUSH
5647: EMPTY
5648: LIST
5649: LIST
5650: PUSH
5651: LD_INT 1
5653: PPUSH
5654: LD_INT 2
5656: PPUSH
5657: CALL_OW 12
5661: ARRAY
5662: PPUSH
5663: CALL_OW 336
// ComAgressiveMove ( un , 111 , 34 ) ;
5667: LD_VAR 0 2
5671: PPUSH
5672: LD_INT 111
5674: PPUSH
5675: LD_INT 34
5677: PPUSH
5678: CALL_OW 114
// wait ( 0 0$2 ) ;
5682: LD_INT 70
5684: PPUSH
5685: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5689: LD_ADDR_VAR 0 3
5693: PUSH
5694: LD_VAR 0 3
5698: PPUSH
5699: LD_VAR 0 3
5703: PUSH
5704: LD_INT 1
5706: PLUS
5707: PPUSH
5708: LD_VAR 0 2
5712: PPUSH
5713: CALL_OW 1
5717: ST_TO_ADDR
// end ;
5718: GO 5558
5720: POP
5721: POP
// end else
5722: GO 5865
// begin for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
5724: LD_ADDR_VAR 0 1
5728: PUSH
5729: DOUBLE
5730: LD_INT 1
5732: DEC
5733: ST_TO_ADDR
5734: LD_INT 4
5736: PUSH
5737: LD_INT 5
5739: PUSH
5740: LD_INT 5
5742: PUSH
5743: EMPTY
5744: LIST
5745: LIST
5746: LIST
5747: PUSH
5748: LD_OWVAR 67
5752: ARRAY
5753: PUSH
5754: FOR_TO
5755: IFFALSE 5863
// begin uc_side := 2 ;
5757: LD_ADDR_OWVAR 20
5761: PUSH
5762: LD_INT 2
5764: ST_TO_ADDR
// uc_nation := 0 ;
5765: LD_ADDR_OWVAR 21
5769: PUSH
5770: LD_INT 0
5772: ST_TO_ADDR
// InitHC_All ( ) ;
5773: CALL_OW 584
// hc_class := class_apeman_kamikaze ;
5777: LD_ADDR_OWVAR 28
5781: PUSH
5782: LD_INT 17
5784: ST_TO_ADDR
// un := CreateHuman ;
5785: LD_ADDR_VAR 0 2
5789: PUSH
5790: CALL_OW 44
5794: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5795: LD_VAR 0 2
5799: PPUSH
5800: LD_INT 17
5802: PPUSH
5803: LD_INT 0
5805: PPUSH
5806: CALL_OW 49
// ComAgressiveMove ( un , 110 , 33 ) ;
5810: LD_VAR 0 2
5814: PPUSH
5815: LD_INT 110
5817: PPUSH
5818: LD_INT 33
5820: PPUSH
5821: CALL_OW 114
// wait ( 0 0$2 ) ;
5825: LD_INT 70
5827: PPUSH
5828: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5832: LD_ADDR_VAR 0 3
5836: PUSH
5837: LD_VAR 0 3
5841: PPUSH
5842: LD_VAR 0 3
5846: PUSH
5847: LD_INT 1
5849: PLUS
5850: PPUSH
5851: LD_VAR 0 2
5855: PPUSH
5856: CALL_OW 1
5860: ST_TO_ADDR
// end ;
5861: GO 5754
5863: POP
5864: POP
// end ; for i := 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
5865: LD_ADDR_VAR 0 1
5869: PUSH
5870: DOUBLE
5871: LD_INT 1
5873: DEC
5874: ST_TO_ADDR
5875: LD_INT 3
5877: PUSH
5878: LD_INT 4
5880: PUSH
5881: LD_INT 5
5883: PUSH
5884: EMPTY
5885: LIST
5886: LIST
5887: LIST
5888: PUSH
5889: LD_OWVAR 67
5893: ARRAY
5894: PUSH
5895: FOR_TO
5896: IFFALSE 6061
// begin uc_side := 2 ;
5898: LD_ADDR_OWVAR 20
5902: PUSH
5903: LD_INT 2
5905: ST_TO_ADDR
// uc_nation := 2 ;
5906: LD_ADDR_OWVAR 21
5910: PUSH
5911: LD_INT 2
5913: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_selfpropelled_bomb , ar_rocket_launcher , ar_gun ] [ rand ( 1 , 3 ) ] , 90 ) ;
5914: LD_INT 14
5916: PPUSH
5917: LD_INT 3
5919: PPUSH
5920: LD_INT 5
5922: PPUSH
5923: LD_INT 29
5925: PUSH
5926: LD_INT 28
5928: PUSH
5929: LD_INT 27
5931: PUSH
5932: EMPTY
5933: LIST
5934: LIST
5935: LIST
5936: PUSH
5937: LD_INT 1
5939: PPUSH
5940: LD_INT 3
5942: PPUSH
5943: CALL_OW 12
5947: ARRAY
5948: PPUSH
5949: LD_INT 90
5951: PPUSH
5952: CALL 15955 0 5
// un := CreateVehicle ;
5956: LD_ADDR_VAR 0 2
5960: PUSH
5961: CALL_OW 45
5965: ST_TO_ADDR
// SetDir ( un , 2 ) ;
5966: LD_VAR 0 2
5970: PPUSH
5971: LD_INT 2
5973: PPUSH
5974: CALL_OW 233
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5978: LD_VAR 0 2
5982: PPUSH
5983: LD_INT 17
5985: PPUSH
5986: LD_INT 0
5988: PPUSH
5989: CALL_OW 49
// ComMoveXY ( un , 66 , 23 ) ;
5993: LD_VAR 0 2
5997: PPUSH
5998: LD_INT 66
6000: PPUSH
6001: LD_INT 23
6003: PPUSH
6004: CALL_OW 111
// wait ( 0 0$3 ) ;
6008: LD_INT 105
6010: PPUSH
6011: CALL_OW 67
// AddComAgressiveMove ( un , 147 , 103 ) ;
6015: LD_VAR 0 2
6019: PPUSH
6020: LD_INT 147
6022: PPUSH
6023: LD_INT 103
6025: PPUSH
6026: CALL_OW 174
// tmp := Replace ( tmp , tmp + 1 , un ) ;
6030: LD_ADDR_VAR 0 3
6034: PUSH
6035: LD_VAR 0 3
6039: PPUSH
6040: LD_VAR 0 3
6044: PUSH
6045: LD_INT 1
6047: PLUS
6048: PPUSH
6049: LD_VAR 0 2
6053: PPUSH
6054: CALL_OW 1
6058: ST_TO_ADDR
// end ;
6059: GO 5895
6061: POP
6062: POP
// if not tmp then
6063: LD_VAR 0 3
6067: NOT
6068: IFFALSE 6072
// exit ;
6070: GO 6172
// wait ( 0 0$5 ) ;
6072: LD_INT 175
6074: PPUSH
6075: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
6079: LD_INT 70
6081: PPUSH
6082: CALL_OW 67
// for i in tmp do
6086: LD_ADDR_VAR 0 1
6090: PUSH
6091: LD_VAR 0 3
6095: PUSH
6096: FOR_IN
6097: IFFALSE 6163
// begin if not IsOk ( i ) then
6099: LD_VAR 0 1
6103: PPUSH
6104: CALL_OW 302
6108: NOT
6109: IFFALSE 6127
// tmp := tmp diff i ;
6111: LD_ADDR_VAR 0 3
6115: PUSH
6116: LD_VAR 0 3
6120: PUSH
6121: LD_VAR 0 1
6125: DIFF
6126: ST_TO_ADDR
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
6127: LD_VAR 0 1
6131: PPUSH
6132: LD_INT 81
6134: PUSH
6135: LD_INT 2
6137: PUSH
6138: EMPTY
6139: LIST
6140: LIST
6141: PPUSH
6142: CALL_OW 69
6146: PPUSH
6147: LD_VAR 0 1
6151: PPUSH
6152: CALL_OW 74
6156: PPUSH
6157: CALL_OW 115
// end ;
6161: GO 6096
6163: POP
6164: POP
// until not tmp ;
6165: LD_VAR 0 3
6169: NOT
6170: IFFALSE 6079
// end ;
6172: PPOPN 3
6174: END
// every 9 9$00 trigger Difficulty > 1 do var un ;
6175: LD_OWVAR 67
6179: PUSH
6180: LD_INT 1
6182: GREATER
6183: IFFALSE 6281
6185: GO 6187
6187: DISABLE
6188: LD_INT 0
6190: PPUSH
// begin uc_side := 2 ;
6191: LD_ADDR_OWVAR 20
6195: PUSH
6196: LD_INT 2
6198: ST_TO_ADDR
// uc_nation := 2 ;
6199: LD_ADDR_OWVAR 21
6203: PUSH
6204: LD_INT 2
6206: ST_TO_ADDR
// PrepareHuman ( false , 4 , 6 ) ;
6207: LD_INT 0
6209: PPUSH
6210: LD_INT 4
6212: PPUSH
6213: LD_INT 6
6215: PPUSH
6216: CALL_OW 380
// un := CreateHuman ;
6220: LD_ADDR_VAR 0 1
6224: PUSH
6225: CALL_OW 44
6229: ST_TO_ADDR
// PlaceUnitXYD ( un , 88 , 1 , 2 , false ) ;
6230: LD_VAR 0 1
6234: PPUSH
6235: LD_INT 88
6237: PPUSH
6238: LD_INT 1
6240: PPUSH
6241: LD_INT 2
6243: PPUSH
6244: LD_INT 0
6246: PPUSH
6247: CALL 50957 0 5
// ComMoveXY ( un , 130 , 35 ) ;
6251: LD_VAR 0 1
6255: PPUSH
6256: LD_INT 130
6258: PPUSH
6259: LD_INT 35
6261: PPUSH
6262: CALL_OW 111
// AddComContaminate ( un , 132 , 39 ) ;
6266: LD_VAR 0 1
6270: PPUSH
6271: LD_INT 132
6273: PPUSH
6274: LD_INT 39
6276: PPUSH
6277: CALL_OW 218
// end ;
6281: PPOPN 1
6283: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
6284: LD_INT 22
6286: PUSH
6287: LD_INT 2
6289: PUSH
6290: EMPTY
6291: LIST
6292: LIST
6293: PUSH
6294: LD_INT 33
6296: PUSH
6297: LD_INT 2
6299: PUSH
6300: EMPTY
6301: LIST
6302: LIST
6303: PUSH
6304: LD_INT 50
6306: PUSH
6307: EMPTY
6308: LIST
6309: PUSH
6310: LD_INT 3
6312: PUSH
6313: LD_INT 61
6315: PUSH
6316: EMPTY
6317: LIST
6318: PUSH
6319: EMPTY
6320: LIST
6321: LIST
6322: PUSH
6323: EMPTY
6324: LIST
6325: LIST
6326: LIST
6327: LIST
6328: PPUSH
6329: CALL_OW 69
6333: IFFALSE 6424
6335: GO 6337
6337: DISABLE
6338: LD_INT 0
6340: PPUSH
6341: PPUSH
// begin enable ;
6342: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
6343: LD_ADDR_VAR 0 2
6347: PUSH
6348: LD_INT 22
6350: PUSH
6351: LD_INT 2
6353: PUSH
6354: EMPTY
6355: LIST
6356: LIST
6357: PUSH
6358: LD_INT 33
6360: PUSH
6361: LD_INT 2
6363: PUSH
6364: EMPTY
6365: LIST
6366: LIST
6367: PUSH
6368: LD_INT 50
6370: PUSH
6371: EMPTY
6372: LIST
6373: PUSH
6374: LD_INT 3
6376: PUSH
6377: LD_INT 61
6379: PUSH
6380: EMPTY
6381: LIST
6382: PUSH
6383: EMPTY
6384: LIST
6385: LIST
6386: PUSH
6387: EMPTY
6388: LIST
6389: LIST
6390: LIST
6391: LIST
6392: PPUSH
6393: CALL_OW 69
6397: ST_TO_ADDR
// for i in tmp do
6398: LD_ADDR_VAR 0 1
6402: PUSH
6403: LD_VAR 0 2
6407: PUSH
6408: FOR_IN
6409: IFFALSE 6422
// Connect ( i ) ;
6411: LD_VAR 0 1
6415: PPUSH
6416: CALL 19423 0 1
6420: GO 6408
6422: POP
6423: POP
// end ; end_of_file
6424: PPOPN 2
6426: END
// export Popov , popov_side , extraPopovForces , popovAttackGroup ; export function PreparePopov ; var i , un , tmp , b , list ; begin
6427: LD_INT 0
6429: PPUSH
6430: PPUSH
6431: PPUSH
6432: PPUSH
6433: PPUSH
6434: PPUSH
// popov_side := 3 ;
6435: LD_ADDR_EXP 17
6439: PUSH
6440: LD_INT 3
6442: ST_TO_ADDR
// uc_side := popov_side ;
6443: LD_ADDR_OWVAR 20
6447: PUSH
6448: LD_EXP 17
6452: ST_TO_ADDR
// uc_nation := 3 ;
6453: LD_ADDR_OWVAR 21
6457: PUSH
6458: LD_INT 3
6460: ST_TO_ADDR
// list := [ [ b_barracks , 103 , 147 , 3 ] , [ b_barracks , 70 , 117 , 3 ] , [ b_lab , 76 , 145 , 1 , b_lab_weapon , b_lab_siberium ] , [ b_oil_power , 87 , 144 , 0 ] , [ b_oil_mine , 86 , 118 , 0 ] , [ b_oil_mine , 98 , 121 , 0 ] , [ b_oil_power , 87 , 147 , 1 ] , [ b_siberite_mine , 123 , 151 , 1 ] , [ b_factory , 94 , 161 , 0 ] , [ b_lab , 81 , 155 , 1 , b_lab_computer , b_lab_spacetime ] , [ b_oil_power , 96 , 152 , 0 ] , [ b_oil_power , 96 , 149 , 3 ] , [ b_bunker , 109 , 142 , 3 , ru_heavy_gun ] , [ b_bunker , 112 , 148 , 3 , ru_heavy_gun ] , [ b_turret , 120 , 159 , 4 , ru_rocket_launcher ] , [ b_turret , 122 , 163 , 4 , ru_rocket_launcher ] , [ b_turret , 123 , 167 , 4 , ru_rocket_launcher ] , [ b_turret , 59 , 111 , 3 , ru_rocket_launcher ] , [ b_turret , 65 , 111 , 3 , ru_heavy_gun ] , [ b_turret , 76 , 117 , 3 , ru_rocket_launcher ] , [ b_turret , 80 , 119 , 3 , ru_heavy_gun ] , [ b_turret , 87 , 125 , 3 , ru_rocket_launcher ] , [ b_barracks , 92 , 129 , 3 ] , [ b_siberite_power , 85 , 165 , 0 ] , [ b_siberite_power , 83 , 161 , 4 ] , [ b_siberite_power , 91 , 166 , 3 ] , [ b_siberite_power , 102 , 166 , 2 ] ] ;
6461: LD_ADDR_VAR 0 6
6465: PUSH
6466: LD_INT 5
6468: PUSH
6469: LD_INT 103
6471: PUSH
6472: LD_INT 147
6474: PUSH
6475: LD_INT 3
6477: PUSH
6478: EMPTY
6479: LIST
6480: LIST
6481: LIST
6482: LIST
6483: PUSH
6484: LD_INT 5
6486: PUSH
6487: LD_INT 70
6489: PUSH
6490: LD_INT 117
6492: PUSH
6493: LD_INT 3
6495: PUSH
6496: EMPTY
6497: LIST
6498: LIST
6499: LIST
6500: LIST
6501: PUSH
6502: LD_INT 6
6504: PUSH
6505: LD_INT 76
6507: PUSH
6508: LD_INT 145
6510: PUSH
6511: LD_INT 1
6513: PUSH
6514: LD_INT 10
6516: PUSH
6517: LD_INT 11
6519: PUSH
6520: EMPTY
6521: LIST
6522: LIST
6523: LIST
6524: LIST
6525: LIST
6526: LIST
6527: PUSH
6528: LD_INT 26
6530: PUSH
6531: LD_INT 87
6533: PUSH
6534: LD_INT 144
6536: PUSH
6537: LD_INT 0
6539: PUSH
6540: EMPTY
6541: LIST
6542: LIST
6543: LIST
6544: LIST
6545: PUSH
6546: LD_INT 29
6548: PUSH
6549: LD_INT 86
6551: PUSH
6552: LD_INT 118
6554: PUSH
6555: LD_INT 0
6557: PUSH
6558: EMPTY
6559: LIST
6560: LIST
6561: LIST
6562: LIST
6563: PUSH
6564: LD_INT 29
6566: PUSH
6567: LD_INT 98
6569: PUSH
6570: LD_INT 121
6572: PUSH
6573: LD_INT 0
6575: PUSH
6576: EMPTY
6577: LIST
6578: LIST
6579: LIST
6580: LIST
6581: PUSH
6582: LD_INT 26
6584: PUSH
6585: LD_INT 87
6587: PUSH
6588: LD_INT 147
6590: PUSH
6591: LD_INT 1
6593: PUSH
6594: EMPTY
6595: LIST
6596: LIST
6597: LIST
6598: LIST
6599: PUSH
6600: LD_INT 30
6602: PUSH
6603: LD_INT 123
6605: PUSH
6606: LD_INT 151
6608: PUSH
6609: LD_INT 1
6611: PUSH
6612: EMPTY
6613: LIST
6614: LIST
6615: LIST
6616: LIST
6617: PUSH
6618: LD_INT 3
6620: PUSH
6621: LD_INT 94
6623: PUSH
6624: LD_INT 161
6626: PUSH
6627: LD_INT 0
6629: PUSH
6630: EMPTY
6631: LIST
6632: LIST
6633: LIST
6634: LIST
6635: PUSH
6636: LD_INT 6
6638: PUSH
6639: LD_INT 81
6641: PUSH
6642: LD_INT 155
6644: PUSH
6645: LD_INT 1
6647: PUSH
6648: LD_INT 12
6650: PUSH
6651: LD_INT 14
6653: PUSH
6654: EMPTY
6655: LIST
6656: LIST
6657: LIST
6658: LIST
6659: LIST
6660: LIST
6661: PUSH
6662: LD_INT 26
6664: PUSH
6665: LD_INT 96
6667: PUSH
6668: LD_INT 152
6670: PUSH
6671: LD_INT 0
6673: PUSH
6674: EMPTY
6675: LIST
6676: LIST
6677: LIST
6678: LIST
6679: PUSH
6680: LD_INT 26
6682: PUSH
6683: LD_INT 96
6685: PUSH
6686: LD_INT 149
6688: PUSH
6689: LD_INT 3
6691: PUSH
6692: EMPTY
6693: LIST
6694: LIST
6695: LIST
6696: LIST
6697: PUSH
6698: LD_INT 32
6700: PUSH
6701: LD_INT 109
6703: PUSH
6704: LD_INT 142
6706: PUSH
6707: LD_INT 3
6709: PUSH
6710: LD_INT 46
6712: PUSH
6713: EMPTY
6714: LIST
6715: LIST
6716: LIST
6717: LIST
6718: LIST
6719: PUSH
6720: LD_INT 32
6722: PUSH
6723: LD_INT 112
6725: PUSH
6726: LD_INT 148
6728: PUSH
6729: LD_INT 3
6731: PUSH
6732: LD_INT 46
6734: PUSH
6735: EMPTY
6736: LIST
6737: LIST
6738: LIST
6739: LIST
6740: LIST
6741: PUSH
6742: LD_INT 33
6744: PUSH
6745: LD_INT 120
6747: PUSH
6748: LD_INT 159
6750: PUSH
6751: LD_INT 4
6753: PUSH
6754: LD_INT 45
6756: PUSH
6757: EMPTY
6758: LIST
6759: LIST
6760: LIST
6761: LIST
6762: LIST
6763: PUSH
6764: LD_INT 33
6766: PUSH
6767: LD_INT 122
6769: PUSH
6770: LD_INT 163
6772: PUSH
6773: LD_INT 4
6775: PUSH
6776: LD_INT 45
6778: PUSH
6779: EMPTY
6780: LIST
6781: LIST
6782: LIST
6783: LIST
6784: LIST
6785: PUSH
6786: LD_INT 33
6788: PUSH
6789: LD_INT 123
6791: PUSH
6792: LD_INT 167
6794: PUSH
6795: LD_INT 4
6797: PUSH
6798: LD_INT 45
6800: PUSH
6801: EMPTY
6802: LIST
6803: LIST
6804: LIST
6805: LIST
6806: LIST
6807: PUSH
6808: LD_INT 33
6810: PUSH
6811: LD_INT 59
6813: PUSH
6814: LD_INT 111
6816: PUSH
6817: LD_INT 3
6819: PUSH
6820: LD_INT 45
6822: PUSH
6823: EMPTY
6824: LIST
6825: LIST
6826: LIST
6827: LIST
6828: LIST
6829: PUSH
6830: LD_INT 33
6832: PUSH
6833: LD_INT 65
6835: PUSH
6836: LD_INT 111
6838: PUSH
6839: LD_INT 3
6841: PUSH
6842: LD_INT 46
6844: PUSH
6845: EMPTY
6846: LIST
6847: LIST
6848: LIST
6849: LIST
6850: LIST
6851: PUSH
6852: LD_INT 33
6854: PUSH
6855: LD_INT 76
6857: PUSH
6858: LD_INT 117
6860: PUSH
6861: LD_INT 3
6863: PUSH
6864: LD_INT 45
6866: PUSH
6867: EMPTY
6868: LIST
6869: LIST
6870: LIST
6871: LIST
6872: LIST
6873: PUSH
6874: LD_INT 33
6876: PUSH
6877: LD_INT 80
6879: PUSH
6880: LD_INT 119
6882: PUSH
6883: LD_INT 3
6885: PUSH
6886: LD_INT 46
6888: PUSH
6889: EMPTY
6890: LIST
6891: LIST
6892: LIST
6893: LIST
6894: LIST
6895: PUSH
6896: LD_INT 33
6898: PUSH
6899: LD_INT 87
6901: PUSH
6902: LD_INT 125
6904: PUSH
6905: LD_INT 3
6907: PUSH
6908: LD_INT 45
6910: PUSH
6911: EMPTY
6912: LIST
6913: LIST
6914: LIST
6915: LIST
6916: LIST
6917: PUSH
6918: LD_INT 5
6920: PUSH
6921: LD_INT 92
6923: PUSH
6924: LD_INT 129
6926: PUSH
6927: LD_INT 3
6929: PUSH
6930: EMPTY
6931: LIST
6932: LIST
6933: LIST
6934: LIST
6935: PUSH
6936: LD_INT 28
6938: PUSH
6939: LD_INT 85
6941: PUSH
6942: LD_INT 165
6944: PUSH
6945: LD_INT 0
6947: PUSH
6948: EMPTY
6949: LIST
6950: LIST
6951: LIST
6952: LIST
6953: PUSH
6954: LD_INT 28
6956: PUSH
6957: LD_INT 83
6959: PUSH
6960: LD_INT 161
6962: PUSH
6963: LD_INT 4
6965: PUSH
6966: EMPTY
6967: LIST
6968: LIST
6969: LIST
6970: LIST
6971: PUSH
6972: LD_INT 28
6974: PUSH
6975: LD_INT 91
6977: PUSH
6978: LD_INT 166
6980: PUSH
6981: LD_INT 3
6983: PUSH
6984: EMPTY
6985: LIST
6986: LIST
6987: LIST
6988: LIST
6989: PUSH
6990: LD_INT 28
6992: PUSH
6993: LD_INT 102
6995: PUSH
6996: LD_INT 166
6998: PUSH
6999: LD_INT 2
7001: PUSH
7002: EMPTY
7003: LIST
7004: LIST
7005: LIST
7006: LIST
7007: PUSH
7008: EMPTY
7009: LIST
7010: LIST
7011: LIST
7012: LIST
7013: LIST
7014: LIST
7015: LIST
7016: LIST
7017: LIST
7018: LIST
7019: LIST
7020: LIST
7021: LIST
7022: LIST
7023: LIST
7024: LIST
7025: LIST
7026: LIST
7027: LIST
7028: LIST
7029: LIST
7030: LIST
7031: LIST
7032: LIST
7033: LIST
7034: LIST
7035: LIST
7036: ST_TO_ADDR
// for i in list do
7037: LD_ADDR_VAR 0 2
7041: PUSH
7042: LD_VAR 0 6
7046: PUSH
7047: FOR_IN
7048: IFFALSE 7258
// begin uc_side := 3 ;
7050: LD_ADDR_OWVAR 20
7054: PUSH
7055: LD_INT 3
7057: ST_TO_ADDR
// uc_nation := 3 ;
7058: LD_ADDR_OWVAR 21
7062: PUSH
7063: LD_INT 3
7065: ST_TO_ADDR
// InitBc ;
7066: CALL_OW 21
// bc_type := i [ 1 ] ;
7070: LD_ADDR_OWVAR 42
7074: PUSH
7075: LD_VAR 0 2
7079: PUSH
7080: LD_INT 1
7082: ARRAY
7083: ST_TO_ADDR
// if i [ 1 ] in [ b_oil_mine , b_siberite_mine ] then
7084: LD_VAR 0 2
7088: PUSH
7089: LD_INT 1
7091: ARRAY
7092: PUSH
7093: LD_INT 29
7095: PUSH
7096: LD_INT 30
7098: PUSH
7099: EMPTY
7100: LIST
7101: LIST
7102: IN
7103: IFFALSE 7130
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , 3 ) ;
7105: LD_VAR 0 2
7109: PUSH
7110: LD_INT 2
7112: ARRAY
7113: PPUSH
7114: LD_VAR 0 2
7118: PUSH
7119: LD_INT 3
7121: ARRAY
7122: PPUSH
7123: LD_INT 3
7125: PPUSH
7126: CALL_OW 441
// if i [ 1 ] = b_lab then
7130: LD_VAR 0 2
7134: PUSH
7135: LD_INT 1
7137: ARRAY
7138: PUSH
7139: LD_INT 6
7141: EQUAL
7142: IFFALSE 7180
// begin bc_type := b_lab_full ;
7144: LD_ADDR_OWVAR 42
7148: PUSH
7149: LD_INT 8
7151: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
7152: LD_ADDR_OWVAR 44
7156: PUSH
7157: LD_VAR 0 2
7161: PUSH
7162: LD_INT 5
7164: ARRAY
7165: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
7166: LD_ADDR_OWVAR 45
7170: PUSH
7171: LD_VAR 0 2
7175: PUSH
7176: LD_INT 6
7178: ARRAY
7179: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
7180: LD_ADDR_VAR 0 5
7184: PUSH
7185: LD_VAR 0 2
7189: PUSH
7190: LD_INT 2
7192: ARRAY
7193: PPUSH
7194: LD_VAR 0 2
7198: PUSH
7199: LD_INT 3
7201: ARRAY
7202: PPUSH
7203: LD_VAR 0 2
7207: PUSH
7208: LD_INT 4
7210: ARRAY
7211: PPUSH
7212: CALL_OW 47
7216: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
7217: LD_VAR 0 2
7221: PUSH
7222: LD_INT 1
7224: ARRAY
7225: PUSH
7226: LD_INT 33
7228: PUSH
7229: LD_INT 32
7231: PUSH
7232: EMPTY
7233: LIST
7234: LIST
7235: IN
7236: IFFALSE 7256
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
7238: LD_VAR 0 5
7242: PPUSH
7243: LD_VAR 0 2
7247: PUSH
7248: LD_INT 5
7250: ARRAY
7251: PPUSH
7252: CALL_OW 431
// end ;
7256: GO 7047
7258: POP
7259: POP
// tmp := PrepareBase ( ru_depot , popov_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 11500 , 1100 , 60 ] , [ 6 , 6 , 6 , 6 ] ) ;
7260: LD_ADDR_VAR 0 4
7264: PUSH
7265: LD_INT 9
7267: PPUSH
7268: LD_INT 3
7270: PPUSH
7271: LD_STRING 
7273: PPUSH
7274: LD_INT 8
7276: PUSH
7277: LD_INT 7
7279: PUSH
7280: LD_INT 6
7282: PUSH
7283: EMPTY
7284: LIST
7285: LIST
7286: LIST
7287: PUSH
7288: LD_OWVAR 67
7292: ARRAY
7293: PPUSH
7294: LD_INT 11500
7296: PUSH
7297: LD_INT 1100
7299: PUSH
7300: LD_INT 60
7302: PUSH
7303: EMPTY
7304: LIST
7305: LIST
7306: LIST
7307: PPUSH
7308: LD_INT 6
7310: PUSH
7311: LD_INT 6
7313: PUSH
7314: LD_INT 6
7316: PUSH
7317: LD_INT 6
7319: PUSH
7320: EMPTY
7321: LIST
7322: LIST
7323: LIST
7324: LIST
7325: PPUSH
7326: CALL 19776 0 6
7330: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 3 , tmp union FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ) ;
7331: LD_ADDR_EXP 23
7335: PUSH
7336: LD_EXP 23
7340: PPUSH
7341: LD_INT 3
7343: PPUSH
7344: LD_VAR 0 4
7348: PUSH
7349: LD_INT 22
7351: PUSH
7352: LD_INT 3
7354: PUSH
7355: EMPTY
7356: LIST
7357: LIST
7358: PUSH
7359: LD_INT 21
7361: PUSH
7362: LD_INT 3
7364: PUSH
7365: EMPTY
7366: LIST
7367: LIST
7368: PUSH
7369: EMPTY
7370: LIST
7371: LIST
7372: PPUSH
7373: CALL_OW 69
7377: UNION
7378: PPUSH
7379: CALL_OW 1
7383: ST_TO_ADDR
// extraPopovForces := [ ] ;
7384: LD_ADDR_EXP 18
7388: PUSH
7389: EMPTY
7390: ST_TO_ADDR
// for i := 1 to [ 8 , 9 , 10 ] [ Difficulty ] do
7391: LD_ADDR_VAR 0 2
7395: PUSH
7396: DOUBLE
7397: LD_INT 1
7399: DEC
7400: ST_TO_ADDR
7401: LD_INT 8
7403: PUSH
7404: LD_INT 9
7406: PUSH
7407: LD_INT 10
7409: PUSH
7410: EMPTY
7411: LIST
7412: LIST
7413: LIST
7414: PUSH
7415: LD_OWVAR 67
7419: ARRAY
7420: PUSH
7421: FOR_TO
7422: IFFALSE 7551
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
7424: LD_INT 0
7426: PPUSH
7427: LD_INT 1
7429: PPUSH
7430: LD_INT 4
7432: PUSH
7433: LD_INT 5
7435: PUSH
7436: LD_INT 6
7438: PUSH
7439: EMPTY
7440: LIST
7441: LIST
7442: LIST
7443: PUSH
7444: LD_OWVAR 67
7448: ARRAY
7449: PPUSH
7450: CALL_OW 380
// un := CreateHuman ;
7454: LD_ADDR_VAR 0 3
7458: PUSH
7459: CALL_OW 44
7463: ST_TO_ADDR
// if rand ( 0 , 1 ) then
7464: LD_INT 0
7466: PPUSH
7467: LD_INT 1
7469: PPUSH
7470: CALL_OW 12
7474: IFFALSE 7499
// PlaceUnitXYR ( un , 131 , 110 , 8 , false ) else
7476: LD_VAR 0 3
7480: PPUSH
7481: LD_INT 131
7483: PPUSH
7484: LD_INT 110
7486: PPUSH
7487: LD_INT 8
7489: PPUSH
7490: LD_INT 0
7492: PPUSH
7493: CALL_OW 50
7497: GO 7520
// PlaceUnitXYR ( un , 100 , 99 , 8 , false ) ;
7499: LD_VAR 0 3
7503: PPUSH
7504: LD_INT 100
7506: PPUSH
7507: LD_INT 99
7509: PPUSH
7510: LD_INT 8
7512: PPUSH
7513: LD_INT 0
7515: PPUSH
7516: CALL_OW 50
// extraPopovForces := Replace ( extraPopovForces , extraPopovForces + 1 , un ) ;
7520: LD_ADDR_EXP 18
7524: PUSH
7525: LD_EXP 18
7529: PPUSH
7530: LD_EXP 18
7534: PUSH
7535: LD_INT 1
7537: PLUS
7538: PPUSH
7539: LD_VAR 0 3
7543: PPUSH
7544: CALL_OW 1
7548: ST_TO_ADDR
// end ;
7549: GO 7421
7551: POP
7552: POP
// PrepareSoldier ( false , 6 ) ;
7553: LD_INT 0
7555: PPUSH
7556: LD_INT 6
7558: PPUSH
7559: CALL_OW 381
// un := CreateHuman ;
7563: LD_ADDR_VAR 0 3
7567: PUSH
7568: CALL_OW 44
7572: ST_TO_ADDR
// SetDir ( un , 1 ) ;
7573: LD_VAR 0 3
7577: PPUSH
7578: LD_INT 1
7580: PPUSH
7581: CALL_OW 233
// PlaceHumanInUnit ( un , HexInfo ( 150 , 158 ) ) ;
7585: LD_VAR 0 3
7589: PPUSH
7590: LD_INT 150
7592: PPUSH
7593: LD_INT 158
7595: PPUSH
7596: CALL_OW 428
7600: PPUSH
7601: CALL_OW 52
// popovAttackGroup := [ ] ;
7605: LD_ADDR_EXP 19
7609: PUSH
7610: EMPTY
7611: ST_TO_ADDR
// end ;
7612: LD_VAR 0 1
7616: RET
// export function InitMC_Popov ( ) ; begin
7617: LD_INT 0
7619: PPUSH
// MC_SetScanArea ( 3 , popov_base ) ;
7620: LD_INT 3
7622: PPUSH
7623: LD_INT 3
7625: PPUSH
7626: CALL 78594 0 2
// MC_SetParkingArea ( 3 , popov_parking ) ;
7630: LD_INT 3
7632: PPUSH
7633: LD_INT 10
7635: PPUSH
7636: CALL 78538 0 2
// MC_SetDepositsXY ( 3 , [ [ 86 , 118 , 0 ] , [ 123 , 151 , 1 ] , [ 98 , 121 , 0 ] ] ) ;
7640: LD_INT 3
7642: PPUSH
7643: LD_INT 86
7645: PUSH
7646: LD_INT 118
7648: PUSH
7649: LD_INT 0
7651: PUSH
7652: EMPTY
7653: LIST
7654: LIST
7655: LIST
7656: PUSH
7657: LD_INT 123
7659: PUSH
7660: LD_INT 151
7662: PUSH
7663: LD_INT 1
7665: PUSH
7666: EMPTY
7667: LIST
7668: LIST
7669: LIST
7670: PUSH
7671: LD_INT 98
7673: PUSH
7674: LD_INT 121
7676: PUSH
7677: LD_INT 0
7679: PUSH
7680: EMPTY
7681: LIST
7682: LIST
7683: LIST
7684: PUSH
7685: EMPTY
7686: LIST
7687: LIST
7688: LIST
7689: PPUSH
7690: CALL 77597 0 2
// MC_SetAllowedTurretWeapons ( 3 , [ ru_heavy_gun , ru_rocket_launcher ] ) ;
7694: LD_INT 3
7696: PPUSH
7697: LD_INT 46
7699: PUSH
7700: LD_INT 45
7702: PUSH
7703: EMPTY
7704: LIST
7705: LIST
7706: PPUSH
7707: CALL 78426 0 2
// MC_SetCratesArea ( 3 , popov_crates ) ;
7711: LD_INT 3
7713: PPUSH
7714: LD_INT 12
7716: PPUSH
7717: CALL 78108 0 2
// MC_SetTame ( 3 , popov_ape ) ;
7721: LD_INT 3
7723: PPUSH
7724: LD_INT 11
7726: PPUSH
7727: CALL 77839 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
7731: LD_INT 3
7733: PPUSH
7734: LD_INT 4
7736: PPUSH
7737: CALL 77458 0 2
// MC_SetProduceList ( 3 , [ [ ru_heavy_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] ] ) ;
7741: LD_INT 3
7743: PPUSH
7744: LD_INT 23
7746: PUSH
7747: LD_INT 1
7749: PUSH
7750: LD_INT 3
7752: PUSH
7753: LD_INT 44
7755: PUSH
7756: EMPTY
7757: LIST
7758: LIST
7759: LIST
7760: LIST
7761: PUSH
7762: LD_INT 23
7764: PUSH
7765: LD_INT 1
7767: PUSH
7768: LD_INT 3
7770: PUSH
7771: LD_INT 45
7773: PUSH
7774: EMPTY
7775: LIST
7776: LIST
7777: LIST
7778: LIST
7779: PUSH
7780: LD_INT 21
7782: PUSH
7783: LD_INT 1
7785: PUSH
7786: LD_INT 3
7788: PUSH
7789: LD_INT 44
7791: PUSH
7792: EMPTY
7793: LIST
7794: LIST
7795: LIST
7796: LIST
7797: PUSH
7798: LD_INT 21
7800: PUSH
7801: LD_INT 1
7803: PUSH
7804: LD_INT 3
7806: PUSH
7807: LD_INT 45
7809: PUSH
7810: EMPTY
7811: LIST
7812: LIST
7813: LIST
7814: LIST
7815: PUSH
7816: EMPTY
7817: LIST
7818: LIST
7819: LIST
7820: LIST
7821: PPUSH
7822: CALL 77273 0 2
// MC_SetFactoryExtension ( 3 , 94 , 161 , 0 , [ b_ext_noncombat , b_ext_gun , b_ext_rocket , b_ext_computer , b_ext_siberium ] ) ;
7826: LD_INT 3
7828: PPUSH
7829: LD_INT 94
7831: PPUSH
7832: LD_INT 161
7834: PPUSH
7835: LD_INT 0
7837: PPUSH
7838: LD_INT 19
7840: PUSH
7841: LD_INT 17
7843: PUSH
7844: LD_INT 18
7846: PUSH
7847: LD_INT 24
7849: PUSH
7850: LD_INT 21
7852: PUSH
7853: EMPTY
7854: LIST
7855: LIST
7856: LIST
7857: LIST
7858: LIST
7859: PPUSH
7860: CALL 78220 0 5
// MC_InsertProduceList ( 3 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] ] ) ;
7864: LD_INT 3
7866: PPUSH
7867: LD_INT 21
7869: PUSH
7870: LD_INT 1
7872: PUSH
7873: LD_INT 3
7875: PUSH
7876: LD_INT 51
7878: PUSH
7879: EMPTY
7880: LIST
7881: LIST
7882: LIST
7883: LIST
7884: PUSH
7885: EMPTY
7886: LIST
7887: PPUSH
7888: CALL 77321 0 2
// end ;
7892: LD_VAR 0 1
7896: RET
// every 9 9$00 trigger extraPopovForces and not ruDestroyed do
7897: LD_EXP 18
7901: PUSH
7902: LD_EXP 5
7906: NOT
7907: AND
7908: IFFALSE 7968
7910: GO 7912
7912: DISABLE
// begin ComMoveXY ( extraPopovForces , 106 , 137 ) ;
7913: LD_EXP 18
7917: PPUSH
7918: LD_INT 106
7920: PPUSH
7921: LD_INT 137
7923: PPUSH
7924: CALL_OW 111
// mc_bases := Replace ( mc_bases , 3 , mc_bases [ 3 ] union extraPopovForces ) ;
7928: LD_ADDR_EXP 23
7932: PUSH
7933: LD_EXP 23
7937: PPUSH
7938: LD_INT 3
7940: PPUSH
7941: LD_EXP 23
7945: PUSH
7946: LD_INT 3
7948: ARRAY
7949: PUSH
7950: LD_EXP 18
7954: UNION
7955: PPUSH
7956: CALL_OW 1
7960: ST_TO_ADDR
// extraPopovForces := [ ] ;
7961: LD_ADDR_EXP 18
7965: PUSH
7966: EMPTY
7967: ST_TO_ADDR
// end ;
7968: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ru_depot ) and not ruDestroyed do var i , base , tmp , attackers , amount ;
7969: LD_INT 9
7971: PPUSH
7972: CALL_OW 302
7976: PUSH
7977: LD_EXP 5
7981: NOT
7982: AND
7983: IFFALSE 8549
7985: GO 7987
7987: DISABLE
7988: LD_INT 0
7990: PPUSH
7991: PPUSH
7992: PPUSH
7993: PPUSH
7994: PPUSH
// begin enable ;
7995: ENABLE
// base := 3 ;
7996: LD_ADDR_VAR 0 2
8000: PUSH
8001: LD_INT 3
8003: ST_TO_ADDR
// tmp := [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
8004: LD_ADDR_VAR 0 3
8008: PUSH
8009: LD_INT 21
8011: PUSH
8012: LD_INT 1
8014: PUSH
8015: LD_INT 3
8017: PUSH
8018: LD_INT 44
8020: PUSH
8021: EMPTY
8022: LIST
8023: LIST
8024: LIST
8025: LIST
8026: PUSH
8027: LD_INT 23
8029: PUSH
8030: LD_INT 1
8032: PUSH
8033: LD_INT 3
8035: PUSH
8036: LD_INT 46
8038: PUSH
8039: EMPTY
8040: LIST
8041: LIST
8042: LIST
8043: LIST
8044: PUSH
8045: LD_INT 23
8047: PUSH
8048: LD_INT 1
8050: PUSH
8051: LD_INT 3
8053: PUSH
8054: LD_INT 46
8056: PUSH
8057: EMPTY
8058: LIST
8059: LIST
8060: LIST
8061: LIST
8062: PUSH
8063: LD_INT 23
8065: PUSH
8066: LD_INT 1
8068: PUSH
8069: LD_INT 3
8071: PUSH
8072: LD_INT 46
8074: PUSH
8075: EMPTY
8076: LIST
8077: LIST
8078: LIST
8079: LIST
8080: PUSH
8081: EMPTY
8082: LIST
8083: LIST
8084: LIST
8085: LIST
8086: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
8087: LD_ADDR_VAR 0 5
8091: PUSH
8092: LD_VAR 0 5
8096: PUSH
8097: LD_OWVAR 1
8101: PUSH
8102: LD_INT 21000
8104: DIV
8105: PLUS
8106: ST_TO_ADDR
// if amount > 8 then
8107: LD_VAR 0 5
8111: PUSH
8112: LD_INT 8
8114: GREATER
8115: IFFALSE 8125
// amount := 8 ;
8117: LD_ADDR_VAR 0 5
8121: PUSH
8122: LD_INT 8
8124: ST_TO_ADDR
// for i = 1 to amount do
8125: LD_ADDR_VAR 0 1
8129: PUSH
8130: DOUBLE
8131: LD_INT 1
8133: DEC
8134: ST_TO_ADDR
8135: LD_VAR 0 5
8139: PUSH
8140: FOR_TO
8141: IFFALSE 8206
// tmp := Insert ( tmp , tmp + 1 , [ ru_heavy_wheeled , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
8143: LD_ADDR_VAR 0 3
8147: PUSH
8148: LD_VAR 0 3
8152: PPUSH
8153: LD_VAR 0 3
8157: PUSH
8158: LD_INT 1
8160: PLUS
8161: PPUSH
8162: LD_INT 23
8164: PUSH
8165: LD_INT 1
8167: PUSH
8168: LD_INT 3
8170: PUSH
8171: LD_INT 46
8173: PUSH
8174: LD_INT 45
8176: PUSH
8177: EMPTY
8178: LIST
8179: LIST
8180: PUSH
8181: LD_INT 1
8183: PPUSH
8184: LD_INT 2
8186: PPUSH
8187: CALL_OW 12
8191: ARRAY
8192: PUSH
8193: EMPTY
8194: LIST
8195: LIST
8196: LIST
8197: LIST
8198: PPUSH
8199: CALL_OW 2
8203: ST_TO_ADDR
8204: GO 8140
8206: POP
8207: POP
// MC_InsertProduceList ( base , tmp ) ;
8208: LD_VAR 0 2
8212: PPUSH
8213: LD_VAR 0 3
8217: PPUSH
8218: CALL 77321 0 2
// repeat wait ( 0 0$1 ) ;
8222: LD_INT 35
8224: PPUSH
8225: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
8229: LD_VAR 0 2
8233: PPUSH
8234: LD_INT 1
8236: PPUSH
8237: CALL 78739 0 2
8241: PUSH
8242: LD_VAR 0 5
8246: GREATEREQUAL
8247: IFFALSE 8222
// wait ( 0 0$30 ) ;
8249: LD_INT 1050
8251: PPUSH
8252: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
8256: LD_ADDR_VAR 0 4
8260: PUSH
8261: LD_EXP 42
8265: PUSH
8266: LD_VAR 0 2
8270: ARRAY
8271: PUSH
8272: LD_EXP 42
8276: PUSH
8277: LD_VAR 0 2
8281: ARRAY
8282: PPUSH
8283: LD_INT 2
8285: PUSH
8286: LD_INT 34
8288: PUSH
8289: LD_INT 51
8291: PUSH
8292: EMPTY
8293: LIST
8294: LIST
8295: PUSH
8296: LD_INT 34
8298: PUSH
8299: LD_INT 52
8301: PUSH
8302: EMPTY
8303: LIST
8304: LIST
8305: PUSH
8306: EMPTY
8307: LIST
8308: LIST
8309: LIST
8310: PPUSH
8311: CALL_OW 72
8315: DIFF
8316: ST_TO_ADDR
// if not attackers then
8317: LD_VAR 0 4
8321: NOT
8322: IFFALSE 8326
// exit ;
8324: GO 8549
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
8326: LD_ADDR_EXP 42
8330: PUSH
8331: LD_EXP 42
8335: PPUSH
8336: LD_VAR 0 2
8340: PPUSH
8341: LD_EXP 42
8345: PUSH
8346: LD_VAR 0 2
8350: ARRAY
8351: PUSH
8352: LD_VAR 0 4
8356: DIFF
8357: PPUSH
8358: CALL_OW 1
8362: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
8363: LD_VAR 0 4
8367: PPUSH
8368: LD_INT 107
8370: PPUSH
8371: LD_INT 74
8373: PPUSH
8374: CALL_OW 114
// wait ( 0 0$5 ) ;
8378: LD_INT 175
8380: PPUSH
8381: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8385: LD_INT 35
8387: PPUSH
8388: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
8392: LD_VAR 0 4
8396: PPUSH
8397: LD_INT 60
8399: PUSH
8400: EMPTY
8401: LIST
8402: PPUSH
8403: CALL_OW 72
8407: NOT
8408: IFFALSE 8385
// if rand ( 0 , 1 ) then
8410: LD_INT 0
8412: PPUSH
8413: LD_INT 1
8415: PPUSH
8416: CALL_OW 12
8420: IFFALSE 8439
// ComAgressiveMove ( attackers , 155 , 108 ) else
8422: LD_VAR 0 4
8426: PPUSH
8427: LD_INT 155
8429: PPUSH
8430: LD_INT 108
8432: PPUSH
8433: CALL_OW 114
8437: GO 8454
// ComAgressiveMove ( attackers , 149 , 55 ) ;
8439: LD_VAR 0 4
8443: PPUSH
8444: LD_INT 149
8446: PPUSH
8447: LD_INT 55
8449: PPUSH
8450: CALL_OW 114
// wait ( 0 0$10 ) ;
8454: LD_INT 350
8456: PPUSH
8457: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8461: LD_INT 35
8463: PPUSH
8464: CALL_OW 67
// for i in attackers do
8468: LD_ADDR_VAR 0 1
8472: PUSH
8473: LD_VAR 0 4
8477: PUSH
8478: FOR_IN
8479: IFFALSE 8529
// if not HasTask ( i ) then
8481: LD_VAR 0 1
8485: PPUSH
8486: CALL_OW 314
8490: NOT
8491: IFFALSE 8527
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8493: LD_VAR 0 1
8497: PPUSH
8498: LD_INT 81
8500: PUSH
8501: LD_INT 3
8503: PUSH
8504: EMPTY
8505: LIST
8506: LIST
8507: PPUSH
8508: CALL_OW 69
8512: PPUSH
8513: LD_VAR 0 1
8517: PPUSH
8518: CALL_OW 74
8522: PPUSH
8523: CALL_OW 115
8527: GO 8478
8529: POP
8530: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
8531: LD_VAR 0 4
8535: PPUSH
8536: LD_INT 50
8538: PUSH
8539: EMPTY
8540: LIST
8541: PPUSH
8542: CALL_OW 72
8546: NOT
8547: IFFALSE 8461
// end ;
8549: PPOPN 5
8551: END
// every 12 12$00 + 10 10$00 trigger not ruDestroyed do var i , un , tmp , amount ;
8552: LD_EXP 5
8556: NOT
8557: IFFALSE 9144
8559: GO 8561
8561: DISABLE
8562: LD_INT 0
8564: PPUSH
8565: PPUSH
8566: PPUSH
8567: PPUSH
// begin enable ;
8568: ENABLE
// if Difficulty = 1 and tick < 30 30$00 then
8569: LD_OWVAR 67
8573: PUSH
8574: LD_INT 1
8576: EQUAL
8577: PUSH
8578: LD_OWVAR 1
8582: PUSH
8583: LD_INT 63000
8585: LESS
8586: AND
8587: IFFALSE 8591
// exit ;
8589: GO 9144
// tmp := [ ] ;
8591: LD_ADDR_VAR 0 3
8595: PUSH
8596: EMPTY
8597: ST_TO_ADDR
// if tick < 45 45$00 then
8598: LD_OWVAR 1
8602: PUSH
8603: LD_INT 94500
8605: LESS
8606: IFFALSE 8783
// begin for i := 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
8608: LD_ADDR_VAR 0 1
8612: PUSH
8613: DOUBLE
8614: LD_INT 1
8616: DEC
8617: ST_TO_ADDR
8618: LD_INT 2
8620: PUSH
8621: LD_INT 3
8623: PUSH
8624: LD_INT 4
8626: PUSH
8627: EMPTY
8628: LIST
8629: LIST
8630: LIST
8631: PUSH
8632: LD_OWVAR 67
8636: ARRAY
8637: PUSH
8638: FOR_TO
8639: IFFALSE 8781
// begin uc_side := 3 ;
8641: LD_ADDR_OWVAR 20
8645: PUSH
8646: LD_INT 3
8648: ST_TO_ADDR
// uc_nation := 3 ;
8649: LD_ADDR_OWVAR 21
8653: PUSH
8654: LD_INT 3
8656: ST_TO_ADDR
// InitHC_All ( ) ;
8657: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
8661: LD_INT 0
8663: PPUSH
8664: LD_INT 1
8666: PPUSH
8667: LD_INT 5
8669: PUSH
8670: LD_INT 6
8672: PUSH
8673: LD_INT 7
8675: PUSH
8676: EMPTY
8677: LIST
8678: LIST
8679: LIST
8680: PUSH
8681: LD_OWVAR 67
8685: ARRAY
8686: PPUSH
8687: CALL_OW 380
// un := CreateHuman ;
8691: LD_ADDR_VAR 0 2
8695: PUSH
8696: CALL_OW 44
8700: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
8701: LD_VAR 0 2
8705: PPUSH
8706: LD_INT 18
8708: PPUSH
8709: LD_INT 0
8711: PPUSH
8712: CALL_OW 49
// SetClass ( un , class_bazooker ) ;
8716: LD_VAR 0 2
8720: PPUSH
8721: LD_INT 9
8723: PPUSH
8724: CALL_OW 336
// ComMoveXY ( un , 147 , 161 ) ;
8728: LD_VAR 0 2
8732: PPUSH
8733: LD_INT 147
8735: PPUSH
8736: LD_INT 161
8738: PPUSH
8739: CALL_OW 111
// wait ( 0 0$2 ) ;
8743: LD_INT 70
8745: PPUSH
8746: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8750: LD_ADDR_VAR 0 3
8754: PUSH
8755: LD_VAR 0 3
8759: PPUSH
8760: LD_VAR 0 3
8764: PUSH
8765: LD_INT 1
8767: PLUS
8768: PPUSH
8769: LD_VAR 0 2
8773: PPUSH
8774: CALL_OW 1
8778: ST_TO_ADDR
// end ;
8779: GO 8638
8781: POP
8782: POP
// end ; amount := [ 3 , 4 , 5 ] [ Difficulty ] + tick div 10 10$00 ;
8783: LD_ADDR_VAR 0 4
8787: PUSH
8788: LD_INT 3
8790: PUSH
8791: LD_INT 4
8793: PUSH
8794: LD_INT 5
8796: PUSH
8797: EMPTY
8798: LIST
8799: LIST
8800: LIST
8801: PUSH
8802: LD_OWVAR 67
8806: ARRAY
8807: PUSH
8808: LD_OWVAR 1
8812: PUSH
8813: LD_INT 21000
8815: DIV
8816: PLUS
8817: ST_TO_ADDR
// if amount > 15 then
8818: LD_VAR 0 4
8822: PUSH
8823: LD_INT 15
8825: GREATER
8826: IFFALSE 8836
// amount := 15 ;
8828: LD_ADDR_VAR 0 4
8832: PUSH
8833: LD_INT 15
8835: ST_TO_ADDR
// for i := 1 to amount do
8836: LD_ADDR_VAR 0 1
8840: PUSH
8841: DOUBLE
8842: LD_INT 1
8844: DEC
8845: ST_TO_ADDR
8846: LD_VAR 0 4
8850: PUSH
8851: FOR_TO
8852: IFFALSE 8998
// begin uc_side := 3 ;
8854: LD_ADDR_OWVAR 20
8858: PUSH
8859: LD_INT 3
8861: ST_TO_ADDR
// uc_nation := 3 ;
8862: LD_ADDR_OWVAR 21
8866: PUSH
8867: LD_INT 3
8869: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 5 ) ] , 90 ) ;
8870: LD_INT 24
8872: PPUSH
8873: LD_INT 1
8875: PPUSH
8876: LD_INT 3
8878: PPUSH
8879: LD_INT 46
8881: PUSH
8882: LD_INT 45
8884: PUSH
8885: LD_INT 44
8887: PUSH
8888: LD_INT 43
8890: PUSH
8891: LD_INT 42
8893: PUSH
8894: EMPTY
8895: LIST
8896: LIST
8897: LIST
8898: LIST
8899: LIST
8900: PUSH
8901: LD_INT 1
8903: PPUSH
8904: LD_INT 5
8906: PPUSH
8907: CALL_OW 12
8911: ARRAY
8912: PPUSH
8913: LD_INT 90
8915: PPUSH
8916: CALL 15955 0 5
// un := CreateVehicle ;
8920: LD_ADDR_VAR 0 2
8924: PUSH
8925: CALL_OW 45
8929: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
8930: LD_VAR 0 2
8934: PPUSH
8935: LD_INT 18
8937: PPUSH
8938: LD_INT 0
8940: PPUSH
8941: CALL_OW 49
// ComMoveXY ( un , 147 , 161 ) ;
8945: LD_VAR 0 2
8949: PPUSH
8950: LD_INT 147
8952: PPUSH
8953: LD_INT 161
8955: PPUSH
8956: CALL_OW 111
// wait ( 0 0$3 ) ;
8960: LD_INT 105
8962: PPUSH
8963: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8967: LD_ADDR_VAR 0 3
8971: PUSH
8972: LD_VAR 0 3
8976: PPUSH
8977: LD_VAR 0 3
8981: PUSH
8982: LD_INT 1
8984: PLUS
8985: PPUSH
8986: LD_VAR 0 2
8990: PPUSH
8991: CALL_OW 1
8995: ST_TO_ADDR
// end ;
8996: GO 8851
8998: POP
8999: POP
// if not tmp then
9000: LD_VAR 0 3
9004: NOT
9005: IFFALSE 9009
// exit ;
9007: GO 9144
// wait ( 0 0$5 ) ;
9009: LD_INT 175
9011: PPUSH
9012: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
9016: LD_INT 70
9018: PPUSH
9019: CALL_OW 67
// for i in tmp do
9023: LD_ADDR_VAR 0 1
9027: PUSH
9028: LD_VAR 0 3
9032: PUSH
9033: FOR_IN
9034: IFFALSE 9135
// begin if not IsOk ( i ) or IsDead ( i ) then
9036: LD_VAR 0 1
9040: PPUSH
9041: CALL_OW 302
9045: NOT
9046: PUSH
9047: LD_VAR 0 1
9051: PPUSH
9052: CALL_OW 301
9056: OR
9057: IFFALSE 9075
// tmp := tmp diff i ;
9059: LD_ADDR_VAR 0 3
9063: PUSH
9064: LD_VAR 0 3
9068: PUSH
9069: LD_VAR 0 1
9073: DIFF
9074: ST_TO_ADDR
// if GetClass ( i ) = class_bazooker then
9075: LD_VAR 0 1
9079: PPUSH
9080: CALL_OW 257
9084: PUSH
9085: LD_INT 9
9087: EQUAL
9088: IFFALSE 9099
// ComSpaceTimeShoot ( i ) ;
9090: LD_VAR 0 1
9094: PPUSH
9095: CALL 12062 0 1
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9099: LD_VAR 0 1
9103: PPUSH
9104: LD_INT 81
9106: PUSH
9107: LD_INT 3
9109: PUSH
9110: EMPTY
9111: LIST
9112: LIST
9113: PPUSH
9114: CALL_OW 69
9118: PPUSH
9119: LD_VAR 0 1
9123: PPUSH
9124: CALL_OW 74
9128: PPUSH
9129: CALL_OW 115
// end ;
9133: GO 9033
9135: POP
9136: POP
// until not tmp ;
9137: LD_VAR 0 3
9141: NOT
9142: IFFALSE 9016
// end ; end_of_file
9144: PPOPN 4
9146: END
// export Sikorski ; export function PrepareSikorski ; var i , j , un ; begin
9147: LD_INT 0
9149: PPUSH
9150: PPUSH
9151: PPUSH
9152: PPUSH
// uc_side := 1 ;
9153: LD_ADDR_OWVAR 20
9157: PUSH
9158: LD_INT 1
9160: ST_TO_ADDR
// uc_nation := 1 ;
9161: LD_ADDR_OWVAR 21
9165: PUSH
9166: LD_INT 1
9168: ST_TO_ADDR
// hc_importance := 100 ;
9169: LD_ADDR_OWVAR 32
9173: PUSH
9174: LD_INT 100
9176: ST_TO_ADDR
// hc_name := Jeremy Sikorski ;
9177: LD_ADDR_OWVAR 26
9181: PUSH
9182: LD_STRING Jeremy Sikorski
9184: ST_TO_ADDR
// hc_gallery := us ;
9185: LD_ADDR_OWVAR 33
9189: PUSH
9190: LD_STRING us
9192: ST_TO_ADDR
// hc_face_number := 19 ;
9193: LD_ADDR_OWVAR 34
9197: PUSH
9198: LD_INT 19
9200: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , [ 4 , 4 , 3 ] [ Difficulty ] ) ;
9201: LD_INT 1
9203: PPUSH
9204: LD_INT 1
9206: PPUSH
9207: LD_INT 4
9209: PUSH
9210: LD_INT 4
9212: PUSH
9213: LD_INT 3
9215: PUSH
9216: EMPTY
9217: LIST
9218: LIST
9219: LIST
9220: PUSH
9221: LD_OWVAR 67
9225: ARRAY
9226: PPUSH
9227: CALL_OW 380
// hc_attr := [ 10 , 12 ] ;
9231: LD_ADDR_OWVAR 29
9235: PUSH
9236: LD_INT 10
9238: PUSH
9239: LD_INT 12
9241: PUSH
9242: EMPTY
9243: LIST
9244: LIST
9245: ST_TO_ADDR
// Sikorski := CreateHuman ;
9246: LD_ADDR_EXP 20
9250: PUSH
9251: CALL_OW 44
9255: ST_TO_ADDR
// PlaceUnitXYR ( Sikorski , 133 , 19 , 2 , false ) ;
9256: LD_EXP 20
9260: PPUSH
9261: LD_INT 133
9263: PPUSH
9264: LD_INT 19
9266: PPUSH
9267: LD_INT 2
9269: PPUSH
9270: LD_INT 0
9272: PPUSH
9273: CALL_OW 50
// InitHc_All ( ) ;
9277: CALL_OW 584
// for i := 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
9281: LD_ADDR_VAR 0 2
9285: PUSH
9286: DOUBLE
9287: LD_INT 1
9289: DEC
9290: ST_TO_ADDR
9291: LD_INT 4
9293: PUSH
9294: LD_INT 3
9296: PUSH
9297: LD_INT 3
9299: PUSH
9300: EMPTY
9301: LIST
9302: LIST
9303: LIST
9304: PUSH
9305: LD_OWVAR 67
9309: ARRAY
9310: PUSH
9311: FOR_TO
9312: IFFALSE 9428
// for j := 1 to 4 do
9314: LD_ADDR_VAR 0 3
9318: PUSH
9319: DOUBLE
9320: LD_INT 1
9322: DEC
9323: ST_TO_ADDR
9324: LD_INT 4
9326: PUSH
9327: FOR_TO
9328: IFFALSE 9424
// begin PrepareHuman ( false , j , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
9330: LD_INT 0
9332: PPUSH
9333: LD_VAR 0 3
9337: PPUSH
9338: LD_INT 5
9340: PUSH
9341: LD_INT 4
9343: PUSH
9344: LD_INT 3
9346: PUSH
9347: EMPTY
9348: LIST
9349: LIST
9350: LIST
9351: PUSH
9352: LD_OWVAR 67
9356: ARRAY
9357: PPUSH
9358: CALL_OW 380
// un := CreateHuman ;
9362: LD_ADDR_VAR 0 4
9366: PUSH
9367: CALL_OW 44
9371: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
9372: LD_VAR 0 4
9376: PPUSH
9377: LD_INT 0
9379: PPUSH
9380: LD_INT 5
9382: PPUSH
9383: CALL_OW 12
9387: PPUSH
9388: CALL_OW 233
// PlaceUnitXYR ( un , 133 , 19 , 6 , false ) ;
9392: LD_VAR 0 4
9396: PPUSH
9397: LD_INT 133
9399: PPUSH
9400: LD_INT 19
9402: PPUSH
9403: LD_INT 6
9405: PPUSH
9406: LD_INT 0
9408: PPUSH
9409: CALL_OW 50
// ComHold ( un ) ;
9413: LD_VAR 0 4
9417: PPUSH
9418: CALL_OW 140
// end ;
9422: GO 9327
9424: POP
9425: POP
9426: GO 9311
9428: POP
9429: POP
// vc_chassis := us_heavy_tracked ;
9430: LD_ADDR_OWVAR 37
9434: PUSH
9435: LD_INT 4
9437: ST_TO_ADDR
// vc_engine := engine_combustion ;
9438: LD_ADDR_OWVAR 39
9442: PUSH
9443: LD_INT 1
9445: ST_TO_ADDR
// vc_control := control_manual ;
9446: LD_ADDR_OWVAR 38
9450: PUSH
9451: LD_INT 1
9453: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
9454: LD_ADDR_OWVAR 40
9458: PUSH
9459: LD_INT 14
9461: ST_TO_ADDR
// vc_fuel_battery := 60 ;
9462: LD_ADDR_OWVAR 41
9466: PUSH
9467: LD_INT 60
9469: ST_TO_ADDR
// un := CreateVehicle ;
9470: LD_ADDR_VAR 0 4
9474: PUSH
9475: CALL_OW 45
9479: ST_TO_ADDR
// SetDir ( un , 2 ) ;
9480: LD_VAR 0 4
9484: PPUSH
9485: LD_INT 2
9487: PPUSH
9488: CALL_OW 233
// PlaceUnitXY ( un , 128 , 12 , false ) ;
9492: LD_VAR 0 4
9496: PPUSH
9497: LD_INT 128
9499: PPUSH
9500: LD_INT 12
9502: PPUSH
9503: LD_INT 0
9505: PPUSH
9506: CALL_OW 48
// for i := 1 to 3 do
9510: LD_ADDR_VAR 0 2
9514: PUSH
9515: DOUBLE
9516: LD_INT 1
9518: DEC
9519: ST_TO_ADDR
9520: LD_INT 3
9522: PUSH
9523: FOR_TO
9524: IFFALSE 9547
// CreateCratesXYR ( 5 , 133 , 19 , 3 , false ) ;
9526: LD_INT 5
9528: PPUSH
9529: LD_INT 133
9531: PPUSH
9532: LD_INT 19
9534: PPUSH
9535: LD_INT 3
9537: PPUSH
9538: LD_INT 0
9540: PPUSH
9541: CALL_OW 56
9545: GO 9523
9547: POP
9548: POP
// end ; end_of_file
9549: LD_VAR 0 1
9553: RET
// export function Action ; begin
9554: LD_INT 0
9556: PPUSH
// InGameOn ;
9557: CALL_OW 8
// CenterNowOnXY ( 133 , 19 ) ;
9561: LD_INT 133
9563: PPUSH
9564: LD_INT 19
9566: PPUSH
9567: CALL_OW 86
// Say ( Sikorski , WT-DS-1 ) ;
9571: LD_EXP 20
9575: PPUSH
9576: LD_STRING WT-DS-1
9578: PPUSH
9579: CALL_OW 88
// InGameOff ;
9583: CALL_OW 9
// ChangeMissionObjectives ( DestroyEnemy ) ;
9587: LD_STRING DestroyEnemy
9589: PPUSH
9590: CALL_OW 337
// wait ( 0 0$20 ) ;
9594: LD_INT 700
9596: PPUSH
9597: CALL_OW 67
// DialogueOn ;
9601: CALL_OW 6
// PlaceSeeing ( 100 , 37 , 1 , - 30 ) ;
9605: LD_INT 100
9607: PPUSH
9608: LD_INT 37
9610: PPUSH
9611: LD_INT 1
9613: PPUSH
9614: LD_INT 30
9616: NEG
9617: PPUSH
9618: CALL_OW 330
// CenterNowOnXY ( 100 , 37 ) ;
9622: LD_INT 100
9624: PPUSH
9625: LD_INT 37
9627: PPUSH
9628: CALL_OW 86
// SayRadio ( Powell , WT-PL-1 ) ;
9632: LD_EXP 10
9636: PPUSH
9637: LD_STRING WT-PL-1
9639: PPUSH
9640: CALL_OW 94
// Say ( Sikorski , WT-DS-2 ) ;
9644: LD_EXP 20
9648: PPUSH
9649: LD_STRING WT-DS-2
9651: PPUSH
9652: CALL_OW 88
// DialogueOff ;
9656: CALL_OW 7
// wait ( 0 0$2 ) ;
9660: LD_INT 70
9662: PPUSH
9663: CALL_OW 67
// RemoveSeeing ( 100 , 37 , 1 ) ;
9667: LD_INT 100
9669: PPUSH
9670: LD_INT 37
9672: PPUSH
9673: LD_INT 1
9675: PPUSH
9676: CALL_OW 331
// end ;
9680: LD_VAR 0 1
9684: RET
// export function DialogPowellsAttack ; begin
9685: LD_INT 0
9687: PPUSH
// SayRadio ( Powell , WT-PL-8 ) ;
9688: LD_EXP 10
9692: PPUSH
9693: LD_STRING WT-PL-8
9695: PPUSH
9696: CALL_OW 94
// end ;
9700: LD_VAR 0 1
9704: RET
// export function DialogContaminateSib ( x , y ) ; begin
9705: LD_INT 0
9707: PPUSH
// DialogueOn ;
9708: CALL_OW 6
// CenterNowOnXY ( x , y ) ;
9712: LD_VAR 0 1
9716: PPUSH
9717: LD_VAR 0 2
9721: PPUSH
9722: CALL_OW 86
// Say ( Sikorski , WT-DS-3 ) ;
9726: LD_EXP 20
9730: PPUSH
9731: LD_STRING WT-DS-3
9733: PPUSH
9734: CALL_OW 88
// DialogueOff ;
9738: CALL_OW 7
// end ;
9742: LD_VAR 0 3
9746: RET
// every 0 0$3 trigger not powellInTrouble and FilterUnitsInArea ( powell_base , [ f_enemy , 4 ] ) > 3 do
9747: LD_EXP 8
9751: NOT
9752: PUSH
9753: LD_INT 1
9755: PPUSH
9756: LD_INT 81
9758: PUSH
9759: LD_INT 4
9761: PUSH
9762: EMPTY
9763: LIST
9764: LIST
9765: PPUSH
9766: CALL_OW 70
9770: PUSH
9771: LD_INT 3
9773: GREATER
9774: AND
9775: IFFALSE 9847
9777: GO 9779
9779: DISABLE
// begin powellInTrouble := true ;
9780: LD_ADDR_EXP 8
9784: PUSH
9785: LD_INT 1
9787: ST_TO_ADDR
// Say ( Sikorski , WT-DS-6 ) ;
9788: LD_EXP 20
9792: PPUSH
9793: LD_STRING WT-DS-6
9795: PPUSH
9796: CALL_OW 88
// if not FilterUnitsInArea ( powell_base , [ f_side , 1 ] ) then
9800: LD_INT 1
9802: PPUSH
9803: LD_INT 22
9805: PUSH
9806: LD_INT 1
9808: PUSH
9809: EMPTY
9810: LIST
9811: LIST
9812: PPUSH
9813: CALL_OW 70
9817: NOT
9818: IFFALSE 9832
// SayRadio ( Powell , WT-PL-6 ) ;
9820: LD_EXP 10
9824: PPUSH
9825: LD_STRING WT-PL-6
9827: PPUSH
9828: CALL_OW 94
// wait ( 1 1$30 ) ;
9832: LD_INT 3150
9834: PPUSH
9835: CALL_OW 67
// powellInTrouble := false ;
9839: LD_ADDR_EXP 8
9843: PUSH
9844: LD_INT 0
9846: ST_TO_ADDR
// end ;
9847: END
// every 0 0$3 trigger not sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 1 ] ) > 6 do
9848: LD_EXP 9
9852: NOT
9853: PUSH
9854: LD_INT 16
9856: PPUSH
9857: LD_INT 81
9859: PUSH
9860: LD_INT 1
9862: PUSH
9863: EMPTY
9864: LIST
9865: LIST
9866: PPUSH
9867: CALL_OW 70
9871: PUSH
9872: LD_INT 6
9874: GREATER
9875: AND
9876: IFFALSE 9949
9878: GO 9880
9880: DISABLE
// begin sikorskiInTrouble := true ;
9881: LD_ADDR_EXP 9
9885: PUSH
9886: LD_INT 1
9888: ST_TO_ADDR
// Say ( Sikorski , WT-DS-7 ) ;
9889: LD_EXP 20
9893: PPUSH
9894: LD_STRING WT-DS-7
9896: PPUSH
9897: CALL_OW 88
// if not powellAttackGroup then
9901: LD_EXP 12
9905: NOT
9906: IFFALSE 9922
// SayRadio ( Powell , WT-PL-7n ) else
9908: LD_EXP 10
9912: PPUSH
9913: LD_STRING WT-PL-7n
9915: PPUSH
9916: CALL_OW 94
9920: GO 9934
// SayRadio ( Powell , WT-PL-7y ) ;
9922: LD_EXP 10
9926: PPUSH
9927: LD_STRING WT-PL-7y
9929: PPUSH
9930: CALL_OW 94
// wait ( 1 1$30 ) ;
9934: LD_INT 3150
9936: PPUSH
9937: CALL_OW 67
// sikorskiInTrouble := false ;
9941: LD_ADDR_EXP 9
9945: PUSH
9946: LD_INT 0
9948: ST_TO_ADDR
// end ;
9949: END
// export function DialogPowellsAttackFailed ; begin
9950: LD_INT 0
9952: PPUSH
// if not ruDestroyed then
9953: LD_EXP 5
9957: NOT
9958: IFFALSE 9974
// SayRadio ( Powell , WT-PL-9 ) else
9960: LD_EXP 10
9964: PPUSH
9965: LD_STRING WT-PL-9
9967: PPUSH
9968: CALL_OW 94
9972: GO 9986
// SayRadio ( Powell , WT-PL-10 ) ;
9974: LD_EXP 10
9978: PPUSH
9979: LD_STRING WT-PL-10
9981: PPUSH
9982: CALL_OW 94
// end ;
9986: LD_VAR 0 1
9990: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
9991: LD_INT 22
9993: PUSH
9994: LD_INT 2
9996: PUSH
9997: EMPTY
9998: LIST
9999: LIST
10000: PUSH
10001: LD_INT 21
10003: PUSH
10004: LD_INT 1
10006: PUSH
10007: EMPTY
10008: LIST
10009: LIST
10010: PUSH
10011: EMPTY
10012: LIST
10013: LIST
10014: PPUSH
10015: CALL_OW 69
10019: PUSH
10020: LD_INT 0
10022: EQUAL
10023: IFFALSE 10067
10025: GO 10027
10027: DISABLE
// begin arDestroyed := true ;
10028: LD_ADDR_EXP 4
10032: PUSH
10033: LD_INT 1
10035: ST_TO_ADDR
// MC_Kill ( 2 ) ;
10036: LD_INT 2
10038: PPUSH
10039: CALL 53296 0 1
// Say ( Sikorski , WT-DS-4 ) ;
10043: LD_EXP 20
10047: PPUSH
10048: LD_STRING WT-DS-4
10050: PPUSH
10051: CALL_OW 88
// SayRadio ( Powell , WT-PL-4 ) ;
10055: LD_EXP 10
10059: PPUSH
10060: LD_STRING WT-PL-4
10062: PPUSH
10063: CALL_OW 94
// end ;
10067: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
10068: LD_INT 22
10070: PUSH
10071: LD_INT 3
10073: PUSH
10074: EMPTY
10075: LIST
10076: LIST
10077: PUSH
10078: LD_INT 21
10080: PUSH
10081: LD_INT 1
10083: PUSH
10084: EMPTY
10085: LIST
10086: LIST
10087: PUSH
10088: EMPTY
10089: LIST
10090: LIST
10091: PPUSH
10092: CALL_OW 69
10096: PUSH
10097: LD_INT 0
10099: EQUAL
10100: IFFALSE 10144
10102: GO 10104
10104: DISABLE
// begin ruDestroyed := true ;
10105: LD_ADDR_EXP 5
10109: PUSH
10110: LD_INT 1
10112: ST_TO_ADDR
// MC_Kill ( 3 ) ;
10113: LD_INT 3
10115: PPUSH
10116: CALL 53296 0 1
// Say ( Sikorski , WT-DS-5 ) ;
10120: LD_EXP 20
10124: PPUSH
10125: LD_STRING WT-DS-5
10127: PPUSH
10128: CALL_OW 88
// SayRadio ( Powell , WT-PL-5 ) ;
10132: LD_EXP 10
10136: PPUSH
10137: LD_STRING WT-PL-5
10139: PPUSH
10140: CALL_OW 94
// end ;
10144: END
// every 0 0$1 trigger ruDestroyed and arDestroyed do
10145: LD_EXP 5
10149: PUSH
10150: LD_EXP 4
10154: AND
10155: IFFALSE 10328
10157: GO 10159
10159: DISABLE
// begin wait ( 0 0$3 ) ;
10160: LD_INT 105
10162: PPUSH
10163: CALL_OW 67
// if tick >= [ 60 60$00 , 50 50$00 , 45 45$00 ] [ Difficulty ] then
10167: LD_OWVAR 1
10171: PUSH
10172: LD_INT 126000
10174: PUSH
10175: LD_INT 105000
10177: PUSH
10178: LD_INT 94500
10180: PUSH
10181: EMPTY
10182: LIST
10183: LIST
10184: LIST
10185: PUSH
10186: LD_OWVAR 67
10190: ARRAY
10191: GREATEREQUAL
10192: IFFALSE 10207
// AddMedal ( WoT-med-1 , - 1 ) else
10194: LD_STRING WoT-med-1
10196: PPUSH
10197: LD_INT 1
10199: NEG
10200: PPUSH
10201: CALL_OW 101
10205: GO 10217
// AddMedal ( WoT-med-1 , 1 ) ;
10207: LD_STRING WoT-med-1
10209: PPUSH
10210: LD_INT 1
10212: PPUSH
10213: CALL_OW 101
// if loseCounter >= [ 4 , 3 , 2 ] [ Difficulty ] then
10217: LD_EXP 6
10221: PUSH
10222: LD_INT 4
10224: PUSH
10225: LD_INT 3
10227: PUSH
10228: LD_INT 2
10230: PUSH
10231: EMPTY
10232: LIST
10233: LIST
10234: LIST
10235: PUSH
10236: LD_OWVAR 67
10240: ARRAY
10241: GREATEREQUAL
10242: IFFALSE 10257
// AddMedal ( WoT-med-2 , - 1 ) else
10244: LD_STRING WoT-med-2
10246: PPUSH
10247: LD_INT 1
10249: NEG
10250: PPUSH
10251: CALL_OW 101
10255: GO 10267
// AddMedal ( WoT-med-2 , 1 ) ;
10257: LD_STRING WoT-med-2
10259: PPUSH
10260: LD_INT 1
10262: PPUSH
10263: CALL_OW 101
// if powellLoseCounter >= [ 8 , 6 , 5 ] [ Difficulty ] then
10267: LD_EXP 7
10271: PUSH
10272: LD_INT 8
10274: PUSH
10275: LD_INT 6
10277: PUSH
10278: LD_INT 5
10280: PUSH
10281: EMPTY
10282: LIST
10283: LIST
10284: LIST
10285: PUSH
10286: LD_OWVAR 67
10290: ARRAY
10291: GREATEREQUAL
10292: IFFALSE 10307
// AddMedal ( WoT-med-3 , - 1 ) else
10294: LD_STRING WoT-med-3
10296: PPUSH
10297: LD_INT 1
10299: NEG
10300: PPUSH
10301: CALL_OW 101
10305: GO 10317
// AddMedal ( WoT-med-3 , 1 ) ;
10307: LD_STRING WoT-med-3
10309: PPUSH
10310: LD_INT 1
10312: PPUSH
10313: CALL_OW 101
// GiveMedals ( MAIN ) ;
10317: LD_STRING MAIN
10319: PPUSH
10320: CALL_OW 102
// YouWin ;
10324: CALL_OW 103
// end ; end_of_file
10328: END
// export function CustomEvent ( event ) ; begin
10329: LD_INT 0
10331: PPUSH
// end ;
10332: LD_VAR 0 2
10336: RET
// on Command ( com ) do var i , j , temp ;
10337: LD_INT 0
10339: PPUSH
10340: PPUSH
10341: PPUSH
// begin if com = 60 then
10342: LD_VAR 0 1
10346: PUSH
10347: LD_INT 60
10349: EQUAL
10350: IFFALSE 10529
// begin for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_weapon , us_cargo_bay ] ] ] ) do
10352: LD_ADDR_VAR 0 2
10356: PUSH
10357: LD_INT 22
10359: PUSH
10360: LD_INT 1
10362: PUSH
10363: EMPTY
10364: LIST
10365: LIST
10366: PUSH
10367: LD_INT 2
10369: PUSH
10370: LD_INT 21
10372: PUSH
10373: LD_INT 1
10375: PUSH
10376: EMPTY
10377: LIST
10378: LIST
10379: PUSH
10380: LD_INT 34
10382: PUSH
10383: LD_INT 12
10385: PUSH
10386: EMPTY
10387: LIST
10388: LIST
10389: PUSH
10390: EMPTY
10391: LIST
10392: LIST
10393: LIST
10394: PUSH
10395: EMPTY
10396: LIST
10397: LIST
10398: PPUSH
10399: CALL_OW 69
10403: PUSH
10404: FOR_IN
10405: IFFALSE 10527
// begin if GetTaskList ( i ) > 0 then
10407: LD_VAR 0 2
10411: PPUSH
10412: CALL_OW 437
10416: PUSH
10417: LD_INT 0
10419: GREATER
10420: IFFALSE 10525
// for j = 1 to GetTaskList ( i ) do
10422: LD_ADDR_VAR 0 3
10426: PUSH
10427: DOUBLE
10428: LD_INT 1
10430: DEC
10431: ST_TO_ADDR
10432: LD_VAR 0 2
10436: PPUSH
10437: CALL_OW 437
10441: PUSH
10442: FOR_TO
10443: IFFALSE 10523
// begin temp = GetTaskList ( i ) [ j ] [ 4 ] ;
10445: LD_ADDR_VAR 0 4
10449: PUSH
10450: LD_VAR 0 2
10454: PPUSH
10455: CALL_OW 437
10459: PUSH
10460: LD_VAR 0 3
10464: ARRAY
10465: PUSH
10466: LD_INT 4
10468: ARRAY
10469: ST_TO_ADDR
// if GetSide ( temp ) = 4 and GetTaskList ( i ) [ j ] [ 1 ] = < then
10470: LD_VAR 0 4
10474: PPUSH
10475: CALL_OW 255
10479: PUSH
10480: LD_INT 4
10482: EQUAL
10483: PUSH
10484: LD_VAR 0 2
10488: PPUSH
10489: CALL_OW 437
10493: PUSH
10494: LD_VAR 0 3
10498: ARRAY
10499: PUSH
10500: LD_INT 1
10502: ARRAY
10503: PUSH
10504: LD_STRING <
10506: EQUAL
10507: AND
10508: IFFALSE 10521
// SetTaskList ( i , [ ] ) ;
10510: LD_VAR 0 2
10514: PPUSH
10515: EMPTY
10516: PPUSH
10517: CALL_OW 446
// end ;
10521: GO 10442
10523: POP
10524: POP
// end ;
10525: GO 10404
10527: POP
10528: POP
// end ; end ;
10529: PPOPN 4
10531: END
// on SibDepositContaminated ( sci , x , y ) do begin if GetSide ( HexInfo ( x , y ) ) = 1 or ( x = 132 and y = 39 ) then
10532: LD_VAR 0 2
10536: PPUSH
10537: LD_VAR 0 3
10541: PPUSH
10542: CALL_OW 428
10546: PPUSH
10547: CALL_OW 255
10551: PUSH
10552: LD_INT 1
10554: EQUAL
10555: PUSH
10556: LD_VAR 0 2
10560: PUSH
10561: LD_INT 132
10563: EQUAL
10564: PUSH
10565: LD_VAR 0 3
10569: PUSH
10570: LD_INT 39
10572: EQUAL
10573: AND
10574: OR
10575: IFFALSE 10591
// DialogContaminateSib ( x , y ) ;
10577: LD_VAR 0 2
10581: PPUSH
10582: LD_VAR 0 3
10586: PPUSH
10587: CALL 9705 0 2
// end ;
10591: PPOPN 3
10593: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
10594: LD_VAR 0 1
10598: PPUSH
10599: CALL 91048 0 1
// MCE_UnitDestroyed ( un ) ;
10603: LD_VAR 0 1
10607: PPUSH
10608: CALL 80763 0 1
// if un = Powell then
10612: LD_VAR 0 1
10616: PUSH
10617: LD_EXP 10
10621: EQUAL
10622: IFFALSE 10631
// YouLost ( Powell ) ;
10624: LD_STRING Powell
10626: PPUSH
10627: CALL_OW 104
// if un = Sikorski then
10631: LD_VAR 0 1
10635: PUSH
10636: LD_EXP 20
10640: EQUAL
10641: IFFALSE 10650
// YouLost ( Sikorski ) ;
10643: LD_STRING Sikorski
10645: PPUSH
10646: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) then
10650: LD_VAR 0 1
10654: PUSH
10655: LD_INT 22
10657: PUSH
10658: LD_INT 1
10660: PUSH
10661: EMPTY
10662: LIST
10663: LIST
10664: PUSH
10665: LD_INT 21
10667: PUSH
10668: LD_INT 1
10670: PUSH
10671: EMPTY
10672: LIST
10673: LIST
10674: PUSH
10675: EMPTY
10676: LIST
10677: LIST
10678: PPUSH
10679: CALL_OW 69
10683: IN
10684: IFFALSE 10700
// loseCounter := loseCounter + 1 ;
10686: LD_ADDR_EXP 6
10690: PUSH
10691: LD_EXP 6
10695: PUSH
10696: LD_INT 1
10698: PLUS
10699: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) then
10700: LD_VAR 0 1
10704: PUSH
10705: LD_INT 22
10707: PUSH
10708: LD_INT 4
10710: PUSH
10711: EMPTY
10712: LIST
10713: LIST
10714: PUSH
10715: LD_INT 21
10717: PUSH
10718: LD_INT 1
10720: PUSH
10721: EMPTY
10722: LIST
10723: LIST
10724: PUSH
10725: EMPTY
10726: LIST
10727: LIST
10728: PPUSH
10729: CALL_OW 69
10733: IN
10734: IFFALSE 10750
// powellLoseCounter := powellLoseCounter + 1 ;
10736: LD_ADDR_EXP 7
10740: PUSH
10741: LD_EXP 7
10745: PUSH
10746: LD_INT 1
10748: PLUS
10749: ST_TO_ADDR
// if un in powellAttackGroup then
10750: LD_VAR 0 1
10754: PUSH
10755: LD_EXP 12
10759: IN
10760: IFFALSE 10778
// powellAttackGroup := powellAttackGroup diff un ;
10762: LD_ADDR_EXP 12
10766: PUSH
10767: LD_EXP 12
10771: PUSH
10772: LD_VAR 0 1
10776: DIFF
10777: ST_TO_ADDR
// if un in gensherAttackGroup then
10778: LD_VAR 0 1
10782: PUSH
10783: LD_EXP 15
10787: IN
10788: IFFALSE 10806
// gensherAttackGroup := gensherAttackGroup diff un ;
10790: LD_ADDR_EXP 15
10794: PUSH
10795: LD_EXP 15
10799: PUSH
10800: LD_VAR 0 1
10804: DIFF
10805: ST_TO_ADDR
// if un in popovAttackGroup then
10806: LD_VAR 0 1
10810: PUSH
10811: LD_EXP 19
10815: IN
10816: IFFALSE 10834
// popovAttackGroup := popovAttackGroup diff un ;
10818: LD_ADDR_EXP 19
10822: PUSH
10823: LD_EXP 19
10827: PUSH
10828: LD_VAR 0 1
10832: DIFF
10833: ST_TO_ADDR
// end ;
10834: PPOPN 1
10836: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10837: LD_VAR 0 1
10841: PPUSH
10842: LD_VAR 0 2
10846: PPUSH
10847: CALL 83095 0 2
// end ;
10851: PPOPN 2
10853: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10854: LD_VAR 0 1
10858: PPUSH
10859: CALL 82163 0 1
// end ;
10863: PPOPN 1
10865: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
10866: LD_VAR 0 1
10870: PPUSH
10871: CALL 82404 0 1
// end ;
10875: PPOPN 1
10877: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10878: LD_VAR 0 1
10882: PPUSH
10883: LD_VAR 0 2
10887: PPUSH
10888: CALL 80459 0 2
// end ;
10892: PPOPN 2
10894: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10895: LD_VAR 0 1
10899: PPUSH
10900: LD_VAR 0 2
10904: PPUSH
10905: LD_VAR 0 3
10909: PPUSH
10910: LD_VAR 0 4
10914: PPUSH
10915: LD_VAR 0 5
10919: PPUSH
10920: CALL 80079 0 5
// end ;
10924: PPOPN 5
10926: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
10927: LD_VAR 0 1
10931: PPUSH
10932: LD_VAR 0 2
10936: PPUSH
10937: CALL 91168 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
10941: LD_VAR 0 1
10945: PPUSH
10946: LD_VAR 0 2
10950: PPUSH
10951: CALL 79632 0 2
// end ;
10955: PPOPN 2
10957: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10958: LD_VAR 0 1
10962: PPUSH
10963: LD_VAR 0 2
10967: PPUSH
10968: LD_VAR 0 3
10972: PPUSH
10973: LD_VAR 0 4
10977: PPUSH
10978: CALL 79470 0 4
// end ;
10982: PPOPN 4
10984: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10985: LD_VAR 0 1
10989: PPUSH
10990: LD_VAR 0 2
10994: PPUSH
10995: LD_VAR 0 3
10999: PPUSH
11000: CALL 79245 0 3
// end ;
11004: PPOPN 3
11006: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
11007: LD_VAR 0 1
11011: PPUSH
11012: LD_VAR 0 2
11016: PPUSH
11017: CALL 79130 0 2
// end ;
11021: PPOPN 2
11023: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
11024: LD_VAR 0 1
11028: PPUSH
11029: LD_VAR 0 2
11033: PPUSH
11034: CALL 83390 0 2
// end ;
11038: PPOPN 2
11040: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
11041: LD_VAR 0 1
11045: PPUSH
11046: LD_VAR 0 2
11050: PPUSH
11051: LD_VAR 0 3
11055: PPUSH
11056: LD_VAR 0 4
11060: PPUSH
11061: CALL 83606 0 4
// end ;
11065: PPOPN 4
11067: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
11068: LD_VAR 0 1
11072: PPUSH
11073: LD_VAR 0 2
11077: PPUSH
11078: CALL 78939 0 2
// end ;
11082: PPOPN 2
11084: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 then
11085: LD_VAR 0 1
11089: PUSH
11090: LD_INT 1
11092: EQUAL
11093: PUSH
11094: LD_VAR 0 2
11098: PUSH
11099: LD_INT 4
11101: EQUAL
11102: AND
11103: IFFALSE 11112
// YouLost ( FriendlyFire ) ;
11105: LD_STRING FriendlyFire
11107: PPUSH
11108: CALL_OW 104
// end ; end_of_file
11112: PPOPN 2
11114: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
11115: LD_INT 0
11117: PPUSH
11118: PPUSH
// if exist_mode then
11119: LD_VAR 0 2
11123: IFFALSE 11148
// unit := CreateCharacter ( prefix & ident ) else
11125: LD_ADDR_VAR 0 5
11129: PUSH
11130: LD_VAR 0 3
11134: PUSH
11135: LD_VAR 0 1
11139: STR
11140: PPUSH
11141: CALL_OW 34
11145: ST_TO_ADDR
11146: GO 11163
// unit := NewCharacter ( ident ) ;
11148: LD_ADDR_VAR 0 5
11152: PUSH
11153: LD_VAR 0 1
11157: PPUSH
11158: CALL_OW 25
11162: ST_TO_ADDR
// result := unit ;
11163: LD_ADDR_VAR 0 4
11167: PUSH
11168: LD_VAR 0 5
11172: ST_TO_ADDR
// end ;
11173: LD_VAR 0 4
11177: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
11178: LD_INT 0
11180: PPUSH
11181: PPUSH
// if not side or not nation then
11182: LD_VAR 0 1
11186: NOT
11187: PUSH
11188: LD_VAR 0 2
11192: NOT
11193: OR
11194: IFFALSE 11198
// exit ;
11196: GO 11966
// case nation of nation_american :
11198: LD_VAR 0 2
11202: PUSH
11203: LD_INT 1
11205: DOUBLE
11206: EQUAL
11207: IFTRUE 11211
11209: GO 11425
11211: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
11212: LD_ADDR_VAR 0 4
11216: PUSH
11217: LD_INT 35
11219: PUSH
11220: LD_INT 45
11222: PUSH
11223: LD_INT 46
11225: PUSH
11226: LD_INT 47
11228: PUSH
11229: LD_INT 82
11231: PUSH
11232: LD_INT 83
11234: PUSH
11235: LD_INT 84
11237: PUSH
11238: LD_INT 85
11240: PUSH
11241: LD_INT 86
11243: PUSH
11244: LD_INT 1
11246: PUSH
11247: LD_INT 2
11249: PUSH
11250: LD_INT 6
11252: PUSH
11253: LD_INT 15
11255: PUSH
11256: LD_INT 16
11258: PUSH
11259: LD_INT 7
11261: PUSH
11262: LD_INT 12
11264: PUSH
11265: LD_INT 13
11267: PUSH
11268: LD_INT 10
11270: PUSH
11271: LD_INT 14
11273: PUSH
11274: LD_INT 20
11276: PUSH
11277: LD_INT 21
11279: PUSH
11280: LD_INT 22
11282: PUSH
11283: LD_INT 25
11285: PUSH
11286: LD_INT 32
11288: PUSH
11289: LD_INT 27
11291: PUSH
11292: LD_INT 36
11294: PUSH
11295: LD_INT 69
11297: PUSH
11298: LD_INT 39
11300: PUSH
11301: LD_INT 34
11303: PUSH
11304: LD_INT 40
11306: PUSH
11307: LD_INT 48
11309: PUSH
11310: LD_INT 49
11312: PUSH
11313: LD_INT 50
11315: PUSH
11316: LD_INT 51
11318: PUSH
11319: LD_INT 52
11321: PUSH
11322: LD_INT 53
11324: PUSH
11325: LD_INT 54
11327: PUSH
11328: LD_INT 55
11330: PUSH
11331: LD_INT 56
11333: PUSH
11334: LD_INT 57
11336: PUSH
11337: LD_INT 58
11339: PUSH
11340: LD_INT 59
11342: PUSH
11343: LD_INT 60
11345: PUSH
11346: LD_INT 61
11348: PUSH
11349: LD_INT 62
11351: PUSH
11352: LD_INT 80
11354: PUSH
11355: LD_INT 82
11357: PUSH
11358: LD_INT 83
11360: PUSH
11361: LD_INT 84
11363: PUSH
11364: LD_INT 85
11366: PUSH
11367: LD_INT 86
11369: PUSH
11370: EMPTY
11371: LIST
11372: LIST
11373: LIST
11374: LIST
11375: LIST
11376: LIST
11377: LIST
11378: LIST
11379: LIST
11380: LIST
11381: LIST
11382: LIST
11383: LIST
11384: LIST
11385: LIST
11386: LIST
11387: LIST
11388: LIST
11389: LIST
11390: LIST
11391: LIST
11392: LIST
11393: LIST
11394: LIST
11395: LIST
11396: LIST
11397: LIST
11398: LIST
11399: LIST
11400: LIST
11401: LIST
11402: LIST
11403: LIST
11404: LIST
11405: LIST
11406: LIST
11407: LIST
11408: LIST
11409: LIST
11410: LIST
11411: LIST
11412: LIST
11413: LIST
11414: LIST
11415: LIST
11416: LIST
11417: LIST
11418: LIST
11419: LIST
11420: LIST
11421: LIST
11422: ST_TO_ADDR
11423: GO 11890
11425: LD_INT 2
11427: DOUBLE
11428: EQUAL
11429: IFTRUE 11433
11431: GO 11659
11433: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
11434: LD_ADDR_VAR 0 4
11438: PUSH
11439: LD_INT 35
11441: PUSH
11442: LD_INT 45
11444: PUSH
11445: LD_INT 46
11447: PUSH
11448: LD_INT 47
11450: PUSH
11451: LD_INT 82
11453: PUSH
11454: LD_INT 83
11456: PUSH
11457: LD_INT 84
11459: PUSH
11460: LD_INT 85
11462: PUSH
11463: LD_INT 87
11465: PUSH
11466: LD_INT 70
11468: PUSH
11469: LD_INT 1
11471: PUSH
11472: LD_INT 11
11474: PUSH
11475: LD_INT 3
11477: PUSH
11478: LD_INT 4
11480: PUSH
11481: LD_INT 5
11483: PUSH
11484: LD_INT 6
11486: PUSH
11487: LD_INT 15
11489: PUSH
11490: LD_INT 18
11492: PUSH
11493: LD_INT 7
11495: PUSH
11496: LD_INT 17
11498: PUSH
11499: LD_INT 8
11501: PUSH
11502: LD_INT 20
11504: PUSH
11505: LD_INT 21
11507: PUSH
11508: LD_INT 22
11510: PUSH
11511: LD_INT 72
11513: PUSH
11514: LD_INT 26
11516: PUSH
11517: LD_INT 69
11519: PUSH
11520: LD_INT 39
11522: PUSH
11523: LD_INT 40
11525: PUSH
11526: LD_INT 41
11528: PUSH
11529: LD_INT 42
11531: PUSH
11532: LD_INT 43
11534: PUSH
11535: LD_INT 48
11537: PUSH
11538: LD_INT 49
11540: PUSH
11541: LD_INT 50
11543: PUSH
11544: LD_INT 51
11546: PUSH
11547: LD_INT 52
11549: PUSH
11550: LD_INT 53
11552: PUSH
11553: LD_INT 54
11555: PUSH
11556: LD_INT 55
11558: PUSH
11559: LD_INT 56
11561: PUSH
11562: LD_INT 60
11564: PUSH
11565: LD_INT 61
11567: PUSH
11568: LD_INT 62
11570: PUSH
11571: LD_INT 66
11573: PUSH
11574: LD_INT 67
11576: PUSH
11577: LD_INT 68
11579: PUSH
11580: LD_INT 81
11582: PUSH
11583: LD_INT 82
11585: PUSH
11586: LD_INT 83
11588: PUSH
11589: LD_INT 84
11591: PUSH
11592: LD_INT 85
11594: PUSH
11595: LD_INT 87
11597: PUSH
11598: LD_INT 88
11600: PUSH
11601: EMPTY
11602: LIST
11603: LIST
11604: LIST
11605: LIST
11606: LIST
11607: LIST
11608: LIST
11609: LIST
11610: LIST
11611: LIST
11612: LIST
11613: LIST
11614: LIST
11615: LIST
11616: LIST
11617: LIST
11618: LIST
11619: LIST
11620: LIST
11621: LIST
11622: LIST
11623: LIST
11624: LIST
11625: LIST
11626: LIST
11627: LIST
11628: LIST
11629: LIST
11630: LIST
11631: LIST
11632: LIST
11633: LIST
11634: LIST
11635: LIST
11636: LIST
11637: LIST
11638: LIST
11639: LIST
11640: LIST
11641: LIST
11642: LIST
11643: LIST
11644: LIST
11645: LIST
11646: LIST
11647: LIST
11648: LIST
11649: LIST
11650: LIST
11651: LIST
11652: LIST
11653: LIST
11654: LIST
11655: LIST
11656: ST_TO_ADDR
11657: GO 11890
11659: LD_INT 3
11661: DOUBLE
11662: EQUAL
11663: IFTRUE 11667
11665: GO 11889
11667: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
11668: LD_ADDR_VAR 0 4
11672: PUSH
11673: LD_INT 46
11675: PUSH
11676: LD_INT 47
11678: PUSH
11679: LD_INT 1
11681: PUSH
11682: LD_INT 2
11684: PUSH
11685: LD_INT 82
11687: PUSH
11688: LD_INT 83
11690: PUSH
11691: LD_INT 84
11693: PUSH
11694: LD_INT 85
11696: PUSH
11697: LD_INT 86
11699: PUSH
11700: LD_INT 11
11702: PUSH
11703: LD_INT 9
11705: PUSH
11706: LD_INT 20
11708: PUSH
11709: LD_INT 19
11711: PUSH
11712: LD_INT 21
11714: PUSH
11715: LD_INT 24
11717: PUSH
11718: LD_INT 22
11720: PUSH
11721: LD_INT 25
11723: PUSH
11724: LD_INT 28
11726: PUSH
11727: LD_INT 29
11729: PUSH
11730: LD_INT 30
11732: PUSH
11733: LD_INT 31
11735: PUSH
11736: LD_INT 37
11738: PUSH
11739: LD_INT 38
11741: PUSH
11742: LD_INT 32
11744: PUSH
11745: LD_INT 27
11747: PUSH
11748: LD_INT 33
11750: PUSH
11751: LD_INT 69
11753: PUSH
11754: LD_INT 39
11756: PUSH
11757: LD_INT 34
11759: PUSH
11760: LD_INT 40
11762: PUSH
11763: LD_INT 71
11765: PUSH
11766: LD_INT 23
11768: PUSH
11769: LD_INT 44
11771: PUSH
11772: LD_INT 48
11774: PUSH
11775: LD_INT 49
11777: PUSH
11778: LD_INT 50
11780: PUSH
11781: LD_INT 51
11783: PUSH
11784: LD_INT 52
11786: PUSH
11787: LD_INT 53
11789: PUSH
11790: LD_INT 54
11792: PUSH
11793: LD_INT 55
11795: PUSH
11796: LD_INT 56
11798: PUSH
11799: LD_INT 57
11801: PUSH
11802: LD_INT 58
11804: PUSH
11805: LD_INT 59
11807: PUSH
11808: LD_INT 63
11810: PUSH
11811: LD_INT 64
11813: PUSH
11814: LD_INT 65
11816: PUSH
11817: LD_INT 82
11819: PUSH
11820: LD_INT 83
11822: PUSH
11823: LD_INT 84
11825: PUSH
11826: LD_INT 85
11828: PUSH
11829: LD_INT 86
11831: PUSH
11832: EMPTY
11833: LIST
11834: LIST
11835: LIST
11836: LIST
11837: LIST
11838: LIST
11839: LIST
11840: LIST
11841: LIST
11842: LIST
11843: LIST
11844: LIST
11845: LIST
11846: LIST
11847: LIST
11848: LIST
11849: LIST
11850: LIST
11851: LIST
11852: LIST
11853: LIST
11854: LIST
11855: LIST
11856: LIST
11857: LIST
11858: LIST
11859: LIST
11860: LIST
11861: LIST
11862: LIST
11863: LIST
11864: LIST
11865: LIST
11866: LIST
11867: LIST
11868: LIST
11869: LIST
11870: LIST
11871: LIST
11872: LIST
11873: LIST
11874: LIST
11875: LIST
11876: LIST
11877: LIST
11878: LIST
11879: LIST
11880: LIST
11881: LIST
11882: LIST
11883: LIST
11884: LIST
11885: LIST
11886: ST_TO_ADDR
11887: GO 11890
11889: POP
// if state > - 1 and state < 3 then
11890: LD_VAR 0 3
11894: PUSH
11895: LD_INT 1
11897: NEG
11898: GREATER
11899: PUSH
11900: LD_VAR 0 3
11904: PUSH
11905: LD_INT 3
11907: LESS
11908: AND
11909: IFFALSE 11966
// for i in result do
11911: LD_ADDR_VAR 0 5
11915: PUSH
11916: LD_VAR 0 4
11920: PUSH
11921: FOR_IN
11922: IFFALSE 11964
// if GetTech ( i , side ) <> state then
11924: LD_VAR 0 5
11928: PPUSH
11929: LD_VAR 0 1
11933: PPUSH
11934: CALL_OW 321
11938: PUSH
11939: LD_VAR 0 3
11943: NONEQUAL
11944: IFFALSE 11962
// result := result diff i ;
11946: LD_ADDR_VAR 0 4
11950: PUSH
11951: LD_VAR 0 4
11955: PUSH
11956: LD_VAR 0 5
11960: DIFF
11961: ST_TO_ADDR
11962: GO 11921
11964: POP
11965: POP
// end ;
11966: LD_VAR 0 4
11970: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
11971: LD_INT 0
11973: PPUSH
11974: PPUSH
11975: PPUSH
// result := true ;
11976: LD_ADDR_VAR 0 3
11980: PUSH
11981: LD_INT 1
11983: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
11984: LD_ADDR_VAR 0 5
11988: PUSH
11989: LD_VAR 0 2
11993: PPUSH
11994: CALL_OW 480
11998: ST_TO_ADDR
// if not tmp then
11999: LD_VAR 0 5
12003: NOT
12004: IFFALSE 12008
// exit ;
12006: GO 12057
// for i in tmp do
12008: LD_ADDR_VAR 0 4
12012: PUSH
12013: LD_VAR 0 5
12017: PUSH
12018: FOR_IN
12019: IFFALSE 12055
// if GetTech ( i , side ) <> state_researched then
12021: LD_VAR 0 4
12025: PPUSH
12026: LD_VAR 0 1
12030: PPUSH
12031: CALL_OW 321
12035: PUSH
12036: LD_INT 2
12038: NONEQUAL
12039: IFFALSE 12053
// begin result := false ;
12041: LD_ADDR_VAR 0 3
12045: PUSH
12046: LD_INT 0
12048: ST_TO_ADDR
// exit ;
12049: POP
12050: POP
12051: GO 12057
// end ;
12053: GO 12018
12055: POP
12056: POP
// end ;
12057: LD_VAR 0 3
12061: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
12062: LD_INT 0
12064: PPUSH
12065: PPUSH
12066: PPUSH
12067: PPUSH
12068: PPUSH
12069: PPUSH
12070: PPUSH
12071: PPUSH
12072: PPUSH
12073: PPUSH
12074: PPUSH
12075: PPUSH
12076: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
12077: LD_VAR 0 1
12081: NOT
12082: PUSH
12083: LD_VAR 0 1
12087: PPUSH
12088: CALL_OW 257
12092: PUSH
12093: LD_INT 9
12095: NONEQUAL
12096: OR
12097: IFFALSE 12101
// exit ;
12099: GO 12674
// side := GetSide ( unit ) ;
12101: LD_ADDR_VAR 0 9
12105: PUSH
12106: LD_VAR 0 1
12110: PPUSH
12111: CALL_OW 255
12115: ST_TO_ADDR
// tech_space := tech_spacanom ;
12116: LD_ADDR_VAR 0 12
12120: PUSH
12121: LD_INT 29
12123: ST_TO_ADDR
// tech_time := tech_taurad ;
12124: LD_ADDR_VAR 0 13
12128: PUSH
12129: LD_INT 28
12131: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
12132: LD_ADDR_VAR 0 11
12136: PUSH
12137: LD_VAR 0 1
12141: PPUSH
12142: CALL_OW 310
12146: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
12147: LD_VAR 0 11
12151: PPUSH
12152: CALL_OW 247
12156: PUSH
12157: LD_INT 2
12159: EQUAL
12160: IFFALSE 12164
// exit ;
12162: GO 12674
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
12164: LD_ADDR_VAR 0 8
12168: PUSH
12169: LD_INT 81
12171: PUSH
12172: LD_VAR 0 9
12176: PUSH
12177: EMPTY
12178: LIST
12179: LIST
12180: PUSH
12181: LD_INT 3
12183: PUSH
12184: LD_INT 21
12186: PUSH
12187: LD_INT 3
12189: PUSH
12190: EMPTY
12191: LIST
12192: LIST
12193: PUSH
12194: EMPTY
12195: LIST
12196: LIST
12197: PUSH
12198: EMPTY
12199: LIST
12200: LIST
12201: PPUSH
12202: CALL_OW 69
12206: ST_TO_ADDR
// if not tmp then
12207: LD_VAR 0 8
12211: NOT
12212: IFFALSE 12216
// exit ;
12214: GO 12674
// if in_unit then
12216: LD_VAR 0 11
12220: IFFALSE 12244
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
12222: LD_ADDR_VAR 0 10
12226: PUSH
12227: LD_VAR 0 8
12231: PPUSH
12232: LD_VAR 0 11
12236: PPUSH
12237: CALL_OW 74
12241: ST_TO_ADDR
12242: GO 12264
// enemy := NearestUnitToUnit ( tmp , unit ) ;
12244: LD_ADDR_VAR 0 10
12248: PUSH
12249: LD_VAR 0 8
12253: PPUSH
12254: LD_VAR 0 1
12258: PPUSH
12259: CALL_OW 74
12263: ST_TO_ADDR
// if not enemy then
12264: LD_VAR 0 10
12268: NOT
12269: IFFALSE 12273
// exit ;
12271: GO 12674
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
12273: LD_VAR 0 11
12277: PUSH
12278: LD_VAR 0 11
12282: PPUSH
12283: LD_VAR 0 10
12287: PPUSH
12288: CALL_OW 296
12292: PUSH
12293: LD_INT 13
12295: GREATER
12296: AND
12297: PUSH
12298: LD_VAR 0 1
12302: PPUSH
12303: LD_VAR 0 10
12307: PPUSH
12308: CALL_OW 296
12312: PUSH
12313: LD_INT 12
12315: GREATER
12316: OR
12317: IFFALSE 12321
// exit ;
12319: GO 12674
// missile := [ 1 ] ;
12321: LD_ADDR_VAR 0 14
12325: PUSH
12326: LD_INT 1
12328: PUSH
12329: EMPTY
12330: LIST
12331: ST_TO_ADDR
// if Researched ( side , tech_space ) then
12332: LD_VAR 0 9
12336: PPUSH
12337: LD_VAR 0 12
12341: PPUSH
12342: CALL_OW 325
12346: IFFALSE 12375
// missile := Replace ( missile , missile + 1 , 2 ) ;
12348: LD_ADDR_VAR 0 14
12352: PUSH
12353: LD_VAR 0 14
12357: PPUSH
12358: LD_VAR 0 14
12362: PUSH
12363: LD_INT 1
12365: PLUS
12366: PPUSH
12367: LD_INT 2
12369: PPUSH
12370: CALL_OW 1
12374: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
12375: LD_VAR 0 9
12379: PPUSH
12380: LD_VAR 0 13
12384: PPUSH
12385: CALL_OW 325
12389: PUSH
12390: LD_VAR 0 10
12394: PPUSH
12395: CALL_OW 255
12399: PPUSH
12400: LD_VAR 0 13
12404: PPUSH
12405: CALL_OW 325
12409: NOT
12410: AND
12411: IFFALSE 12440
// missile := Replace ( missile , missile + 1 , 3 ) ;
12413: LD_ADDR_VAR 0 14
12417: PUSH
12418: LD_VAR 0 14
12422: PPUSH
12423: LD_VAR 0 14
12427: PUSH
12428: LD_INT 1
12430: PLUS
12431: PPUSH
12432: LD_INT 3
12434: PPUSH
12435: CALL_OW 1
12439: ST_TO_ADDR
// if missile < 2 then
12440: LD_VAR 0 14
12444: PUSH
12445: LD_INT 2
12447: LESS
12448: IFFALSE 12452
// exit ;
12450: GO 12674
// x := GetX ( enemy ) ;
12452: LD_ADDR_VAR 0 4
12456: PUSH
12457: LD_VAR 0 10
12461: PPUSH
12462: CALL_OW 250
12466: ST_TO_ADDR
// y := GetY ( enemy ) ;
12467: LD_ADDR_VAR 0 5
12471: PUSH
12472: LD_VAR 0 10
12476: PPUSH
12477: CALL_OW 251
12481: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
12482: LD_ADDR_VAR 0 6
12486: PUSH
12487: LD_VAR 0 4
12491: PUSH
12492: LD_INT 1
12494: NEG
12495: PPUSH
12496: LD_INT 1
12498: PPUSH
12499: CALL_OW 12
12503: PLUS
12504: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
12505: LD_ADDR_VAR 0 7
12509: PUSH
12510: LD_VAR 0 5
12514: PUSH
12515: LD_INT 1
12517: NEG
12518: PPUSH
12519: LD_INT 1
12521: PPUSH
12522: CALL_OW 12
12526: PLUS
12527: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
12528: LD_VAR 0 6
12532: PPUSH
12533: LD_VAR 0 7
12537: PPUSH
12538: CALL_OW 488
12542: NOT
12543: IFFALSE 12565
// begin _x := x ;
12545: LD_ADDR_VAR 0 6
12549: PUSH
12550: LD_VAR 0 4
12554: ST_TO_ADDR
// _y := y ;
12555: LD_ADDR_VAR 0 7
12559: PUSH
12560: LD_VAR 0 5
12564: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
12565: LD_ADDR_VAR 0 3
12569: PUSH
12570: LD_INT 1
12572: PPUSH
12573: LD_VAR 0 14
12577: PPUSH
12578: CALL_OW 12
12582: ST_TO_ADDR
// case i of 1 :
12583: LD_VAR 0 3
12587: PUSH
12588: LD_INT 1
12590: DOUBLE
12591: EQUAL
12592: IFTRUE 12596
12594: GO 12613
12596: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
12597: LD_VAR 0 1
12601: PPUSH
12602: LD_VAR 0 10
12606: PPUSH
12607: CALL_OW 115
12611: GO 12674
12613: LD_INT 2
12615: DOUBLE
12616: EQUAL
12617: IFTRUE 12621
12619: GO 12643
12621: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
12622: LD_VAR 0 1
12626: PPUSH
12627: LD_VAR 0 6
12631: PPUSH
12632: LD_VAR 0 7
12636: PPUSH
12637: CALL_OW 153
12641: GO 12674
12643: LD_INT 3
12645: DOUBLE
12646: EQUAL
12647: IFTRUE 12651
12649: GO 12673
12651: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
12652: LD_VAR 0 1
12656: PPUSH
12657: LD_VAR 0 6
12661: PPUSH
12662: LD_VAR 0 7
12666: PPUSH
12667: CALL_OW 154
12671: GO 12674
12673: POP
// end ;
12674: LD_VAR 0 2
12678: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
12679: LD_INT 0
12681: PPUSH
12682: PPUSH
12683: PPUSH
12684: PPUSH
12685: PPUSH
12686: PPUSH
// if not unit or not building then
12687: LD_VAR 0 1
12691: NOT
12692: PUSH
12693: LD_VAR 0 2
12697: NOT
12698: OR
12699: IFFALSE 12703
// exit ;
12701: GO 12861
// x := GetX ( building ) ;
12703: LD_ADDR_VAR 0 5
12707: PUSH
12708: LD_VAR 0 2
12712: PPUSH
12713: CALL_OW 250
12717: ST_TO_ADDR
// y := GetY ( building ) ;
12718: LD_ADDR_VAR 0 6
12722: PUSH
12723: LD_VAR 0 2
12727: PPUSH
12728: CALL_OW 251
12732: ST_TO_ADDR
// for i = 0 to 5 do
12733: LD_ADDR_VAR 0 4
12737: PUSH
12738: DOUBLE
12739: LD_INT 0
12741: DEC
12742: ST_TO_ADDR
12743: LD_INT 5
12745: PUSH
12746: FOR_TO
12747: IFFALSE 12859
// begin _x := ShiftX ( x , i , 3 ) ;
12749: LD_ADDR_VAR 0 7
12753: PUSH
12754: LD_VAR 0 5
12758: PPUSH
12759: LD_VAR 0 4
12763: PPUSH
12764: LD_INT 3
12766: PPUSH
12767: CALL_OW 272
12771: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
12772: LD_ADDR_VAR 0 8
12776: PUSH
12777: LD_VAR 0 6
12781: PPUSH
12782: LD_VAR 0 4
12786: PPUSH
12787: LD_INT 3
12789: PPUSH
12790: CALL_OW 273
12794: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
12795: LD_VAR 0 7
12799: PPUSH
12800: LD_VAR 0 8
12804: PPUSH
12805: CALL_OW 488
12809: NOT
12810: IFFALSE 12814
// continue ;
12812: GO 12746
// if HexInfo ( _x , _y ) = 0 then
12814: LD_VAR 0 7
12818: PPUSH
12819: LD_VAR 0 8
12823: PPUSH
12824: CALL_OW 428
12828: PUSH
12829: LD_INT 0
12831: EQUAL
12832: IFFALSE 12857
// begin ComMoveXY ( unit , _x , _y ) ;
12834: LD_VAR 0 1
12838: PPUSH
12839: LD_VAR 0 7
12843: PPUSH
12844: LD_VAR 0 8
12848: PPUSH
12849: CALL_OW 111
// exit ;
12853: POP
12854: POP
12855: GO 12861
// end ; end ;
12857: GO 12746
12859: POP
12860: POP
// end ;
12861: LD_VAR 0 3
12865: RET
// export function ScanBase ( side , base_area ) ; begin
12866: LD_INT 0
12868: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
12869: LD_ADDR_VAR 0 3
12873: PUSH
12874: LD_VAR 0 2
12878: PPUSH
12879: LD_INT 81
12881: PUSH
12882: LD_VAR 0 1
12886: PUSH
12887: EMPTY
12888: LIST
12889: LIST
12890: PPUSH
12891: CALL_OW 70
12895: ST_TO_ADDR
// end ;
12896: LD_VAR 0 3
12900: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
12901: LD_INT 0
12903: PPUSH
12904: PPUSH
12905: PPUSH
12906: PPUSH
// result := false ;
12907: LD_ADDR_VAR 0 2
12911: PUSH
12912: LD_INT 0
12914: ST_TO_ADDR
// side := GetSide ( unit ) ;
12915: LD_ADDR_VAR 0 3
12919: PUSH
12920: LD_VAR 0 1
12924: PPUSH
12925: CALL_OW 255
12929: ST_TO_ADDR
// nat := GetNation ( unit ) ;
12930: LD_ADDR_VAR 0 4
12934: PUSH
12935: LD_VAR 0 1
12939: PPUSH
12940: CALL_OW 248
12944: ST_TO_ADDR
// case nat of 1 :
12945: LD_VAR 0 4
12949: PUSH
12950: LD_INT 1
12952: DOUBLE
12953: EQUAL
12954: IFTRUE 12958
12956: GO 12969
12958: POP
// tech := tech_lassight ; 2 :
12959: LD_ADDR_VAR 0 5
12963: PUSH
12964: LD_INT 12
12966: ST_TO_ADDR
12967: GO 13008
12969: LD_INT 2
12971: DOUBLE
12972: EQUAL
12973: IFTRUE 12977
12975: GO 12988
12977: POP
// tech := tech_mortar ; 3 :
12978: LD_ADDR_VAR 0 5
12982: PUSH
12983: LD_INT 41
12985: ST_TO_ADDR
12986: GO 13008
12988: LD_INT 3
12990: DOUBLE
12991: EQUAL
12992: IFTRUE 12996
12994: GO 13007
12996: POP
// tech := tech_bazooka ; end ;
12997: LD_ADDR_VAR 0 5
13001: PUSH
13002: LD_INT 44
13004: ST_TO_ADDR
13005: GO 13008
13007: POP
// if Researched ( side , tech ) then
13008: LD_VAR 0 3
13012: PPUSH
13013: LD_VAR 0 5
13017: PPUSH
13018: CALL_OW 325
13022: IFFALSE 13049
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
13024: LD_ADDR_VAR 0 2
13028: PUSH
13029: LD_INT 5
13031: PUSH
13032: LD_INT 8
13034: PUSH
13035: LD_INT 9
13037: PUSH
13038: EMPTY
13039: LIST
13040: LIST
13041: LIST
13042: PUSH
13043: LD_VAR 0 4
13047: ARRAY
13048: ST_TO_ADDR
// end ;
13049: LD_VAR 0 2
13053: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
13054: LD_INT 0
13056: PPUSH
13057: PPUSH
13058: PPUSH
// if not mines then
13059: LD_VAR 0 2
13063: NOT
13064: IFFALSE 13068
// exit ;
13066: GO 13212
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
13068: LD_ADDR_VAR 0 5
13072: PUSH
13073: LD_INT 81
13075: PUSH
13076: LD_VAR 0 1
13080: PUSH
13081: EMPTY
13082: LIST
13083: LIST
13084: PUSH
13085: LD_INT 3
13087: PUSH
13088: LD_INT 21
13090: PUSH
13091: LD_INT 3
13093: PUSH
13094: EMPTY
13095: LIST
13096: LIST
13097: PUSH
13098: EMPTY
13099: LIST
13100: LIST
13101: PUSH
13102: EMPTY
13103: LIST
13104: LIST
13105: PPUSH
13106: CALL_OW 69
13110: ST_TO_ADDR
// for i in mines do
13111: LD_ADDR_VAR 0 4
13115: PUSH
13116: LD_VAR 0 2
13120: PUSH
13121: FOR_IN
13122: IFFALSE 13210
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
13124: LD_VAR 0 4
13128: PUSH
13129: LD_INT 1
13131: ARRAY
13132: PPUSH
13133: LD_VAR 0 4
13137: PUSH
13138: LD_INT 2
13140: ARRAY
13141: PPUSH
13142: CALL_OW 458
13146: NOT
13147: IFFALSE 13151
// continue ;
13149: GO 13121
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
13151: LD_VAR 0 4
13155: PUSH
13156: LD_INT 1
13158: ARRAY
13159: PPUSH
13160: LD_VAR 0 4
13164: PUSH
13165: LD_INT 2
13167: ARRAY
13168: PPUSH
13169: CALL_OW 428
13173: PUSH
13174: LD_VAR 0 5
13178: IN
13179: IFFALSE 13208
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
13181: LD_VAR 0 4
13185: PUSH
13186: LD_INT 1
13188: ARRAY
13189: PPUSH
13190: LD_VAR 0 4
13194: PUSH
13195: LD_INT 2
13197: ARRAY
13198: PPUSH
13199: LD_VAR 0 1
13203: PPUSH
13204: CALL_OW 456
// end ;
13208: GO 13121
13210: POP
13211: POP
// end ;
13212: LD_VAR 0 3
13216: RET
// export function Count ( array ) ; begin
13217: LD_INT 0
13219: PPUSH
// result := array + 0 ;
13220: LD_ADDR_VAR 0 2
13224: PUSH
13225: LD_VAR 0 1
13229: PUSH
13230: LD_INT 0
13232: PLUS
13233: ST_TO_ADDR
// end ;
13234: LD_VAR 0 2
13238: RET
// export function IsEmpty ( building ) ; begin
13239: LD_INT 0
13241: PPUSH
// if not building then
13242: LD_VAR 0 1
13246: NOT
13247: IFFALSE 13251
// exit ;
13249: GO 13294
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
13251: LD_ADDR_VAR 0 2
13255: PUSH
13256: LD_VAR 0 1
13260: PUSH
13261: LD_INT 22
13263: PUSH
13264: LD_VAR 0 1
13268: PPUSH
13269: CALL_OW 255
13273: PUSH
13274: EMPTY
13275: LIST
13276: LIST
13277: PUSH
13278: LD_INT 58
13280: PUSH
13281: EMPTY
13282: LIST
13283: PUSH
13284: EMPTY
13285: LIST
13286: LIST
13287: PPUSH
13288: CALL_OW 69
13292: IN
13293: ST_TO_ADDR
// end ;
13294: LD_VAR 0 2
13298: RET
// export function IsNotFull ( building ) ; var places ; begin
13299: LD_INT 0
13301: PPUSH
13302: PPUSH
// if not building then
13303: LD_VAR 0 1
13307: NOT
13308: IFFALSE 13312
// exit ;
13310: GO 13340
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
13312: LD_ADDR_VAR 0 2
13316: PUSH
13317: LD_VAR 0 1
13321: PPUSH
13322: LD_INT 3
13324: PUSH
13325: LD_INT 62
13327: PUSH
13328: EMPTY
13329: LIST
13330: PUSH
13331: EMPTY
13332: LIST
13333: LIST
13334: PPUSH
13335: CALL_OW 72
13339: ST_TO_ADDR
// end ;
13340: LD_VAR 0 2
13344: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
13345: LD_INT 0
13347: PPUSH
13348: PPUSH
13349: PPUSH
13350: PPUSH
// tmp := [ ] ;
13351: LD_ADDR_VAR 0 3
13355: PUSH
13356: EMPTY
13357: ST_TO_ADDR
// list := [ ] ;
13358: LD_ADDR_VAR 0 5
13362: PUSH
13363: EMPTY
13364: ST_TO_ADDR
// for i = 16 to 25 do
13365: LD_ADDR_VAR 0 4
13369: PUSH
13370: DOUBLE
13371: LD_INT 16
13373: DEC
13374: ST_TO_ADDR
13375: LD_INT 25
13377: PUSH
13378: FOR_TO
13379: IFFALSE 13452
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
13381: LD_ADDR_VAR 0 3
13385: PUSH
13386: LD_VAR 0 3
13390: PUSH
13391: LD_INT 22
13393: PUSH
13394: LD_VAR 0 1
13398: PPUSH
13399: CALL_OW 255
13403: PUSH
13404: EMPTY
13405: LIST
13406: LIST
13407: PUSH
13408: LD_INT 91
13410: PUSH
13411: LD_VAR 0 1
13415: PUSH
13416: LD_INT 6
13418: PUSH
13419: EMPTY
13420: LIST
13421: LIST
13422: LIST
13423: PUSH
13424: LD_INT 30
13426: PUSH
13427: LD_VAR 0 4
13431: PUSH
13432: EMPTY
13433: LIST
13434: LIST
13435: PUSH
13436: EMPTY
13437: LIST
13438: LIST
13439: LIST
13440: PUSH
13441: EMPTY
13442: LIST
13443: PPUSH
13444: CALL_OW 69
13448: ADD
13449: ST_TO_ADDR
13450: GO 13378
13452: POP
13453: POP
// for i = 1 to tmp do
13454: LD_ADDR_VAR 0 4
13458: PUSH
13459: DOUBLE
13460: LD_INT 1
13462: DEC
13463: ST_TO_ADDR
13464: LD_VAR 0 3
13468: PUSH
13469: FOR_TO
13470: IFFALSE 13558
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
13472: LD_ADDR_VAR 0 5
13476: PUSH
13477: LD_VAR 0 5
13481: PUSH
13482: LD_VAR 0 3
13486: PUSH
13487: LD_VAR 0 4
13491: ARRAY
13492: PPUSH
13493: CALL_OW 266
13497: PUSH
13498: LD_VAR 0 3
13502: PUSH
13503: LD_VAR 0 4
13507: ARRAY
13508: PPUSH
13509: CALL_OW 250
13513: PUSH
13514: LD_VAR 0 3
13518: PUSH
13519: LD_VAR 0 4
13523: ARRAY
13524: PPUSH
13525: CALL_OW 251
13529: PUSH
13530: LD_VAR 0 3
13534: PUSH
13535: LD_VAR 0 4
13539: ARRAY
13540: PPUSH
13541: CALL_OW 254
13545: PUSH
13546: EMPTY
13547: LIST
13548: LIST
13549: LIST
13550: LIST
13551: PUSH
13552: EMPTY
13553: LIST
13554: ADD
13555: ST_TO_ADDR
13556: GO 13469
13558: POP
13559: POP
// result := list ;
13560: LD_ADDR_VAR 0 2
13564: PUSH
13565: LD_VAR 0 5
13569: ST_TO_ADDR
// end ;
13570: LD_VAR 0 2
13574: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
13575: LD_INT 0
13577: PPUSH
13578: PPUSH
13579: PPUSH
13580: PPUSH
13581: PPUSH
13582: PPUSH
13583: PPUSH
// if not factory then
13584: LD_VAR 0 1
13588: NOT
13589: IFFALSE 13593
// exit ;
13591: GO 14186
// if control = control_apeman then
13593: LD_VAR 0 4
13597: PUSH
13598: LD_INT 5
13600: EQUAL
13601: IFFALSE 13710
// begin tmp := UnitsInside ( factory ) ;
13603: LD_ADDR_VAR 0 8
13607: PUSH
13608: LD_VAR 0 1
13612: PPUSH
13613: CALL_OW 313
13617: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
13618: LD_VAR 0 8
13622: PPUSH
13623: LD_INT 25
13625: PUSH
13626: LD_INT 12
13628: PUSH
13629: EMPTY
13630: LIST
13631: LIST
13632: PPUSH
13633: CALL_OW 72
13637: NOT
13638: IFFALSE 13648
// control := control_manual ;
13640: LD_ADDR_VAR 0 4
13644: PUSH
13645: LD_INT 1
13647: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
13648: LD_ADDR_VAR 0 8
13652: PUSH
13653: LD_VAR 0 1
13657: PPUSH
13658: CALL 13345 0 1
13662: ST_TO_ADDR
// if tmp then
13663: LD_VAR 0 8
13667: IFFALSE 13710
// begin for i in tmp do
13669: LD_ADDR_VAR 0 7
13673: PUSH
13674: LD_VAR 0 8
13678: PUSH
13679: FOR_IN
13680: IFFALSE 13708
// if i [ 1 ] = b_ext_radio then
13682: LD_VAR 0 7
13686: PUSH
13687: LD_INT 1
13689: ARRAY
13690: PUSH
13691: LD_INT 22
13693: EQUAL
13694: IFFALSE 13706
// begin control := control_remote ;
13696: LD_ADDR_VAR 0 4
13700: PUSH
13701: LD_INT 2
13703: ST_TO_ADDR
// break ;
13704: GO 13708
// end ;
13706: GO 13679
13708: POP
13709: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
13710: LD_VAR 0 1
13714: PPUSH
13715: LD_VAR 0 2
13719: PPUSH
13720: LD_VAR 0 3
13724: PPUSH
13725: LD_VAR 0 4
13729: PPUSH
13730: LD_VAR 0 5
13734: PPUSH
13735: CALL_OW 448
13739: IFFALSE 13774
// begin result := [ chassis , engine , control , weapon ] ;
13741: LD_ADDR_VAR 0 6
13745: PUSH
13746: LD_VAR 0 2
13750: PUSH
13751: LD_VAR 0 3
13755: PUSH
13756: LD_VAR 0 4
13760: PUSH
13761: LD_VAR 0 5
13765: PUSH
13766: EMPTY
13767: LIST
13768: LIST
13769: LIST
13770: LIST
13771: ST_TO_ADDR
// exit ;
13772: GO 14186
// end ; _chassis := AvailableChassisList ( factory ) ;
13774: LD_ADDR_VAR 0 9
13778: PUSH
13779: LD_VAR 0 1
13783: PPUSH
13784: CALL_OW 475
13788: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
13789: LD_ADDR_VAR 0 11
13793: PUSH
13794: LD_VAR 0 1
13798: PPUSH
13799: CALL_OW 476
13803: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
13804: LD_ADDR_VAR 0 12
13808: PUSH
13809: LD_VAR 0 1
13813: PPUSH
13814: CALL_OW 477
13818: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
13819: LD_ADDR_VAR 0 10
13823: PUSH
13824: LD_VAR 0 1
13828: PPUSH
13829: CALL_OW 478
13833: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
13834: LD_VAR 0 9
13838: NOT
13839: PUSH
13840: LD_VAR 0 11
13844: NOT
13845: OR
13846: PUSH
13847: LD_VAR 0 12
13851: NOT
13852: OR
13853: PUSH
13854: LD_VAR 0 10
13858: NOT
13859: OR
13860: IFFALSE 13895
// begin result := [ chassis , engine , control , weapon ] ;
13862: LD_ADDR_VAR 0 6
13866: PUSH
13867: LD_VAR 0 2
13871: PUSH
13872: LD_VAR 0 3
13876: PUSH
13877: LD_VAR 0 4
13881: PUSH
13882: LD_VAR 0 5
13886: PUSH
13887: EMPTY
13888: LIST
13889: LIST
13890: LIST
13891: LIST
13892: ST_TO_ADDR
// exit ;
13893: GO 14186
// end ; if not chassis in _chassis then
13895: LD_VAR 0 2
13899: PUSH
13900: LD_VAR 0 9
13904: IN
13905: NOT
13906: IFFALSE 13932
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
13908: LD_ADDR_VAR 0 2
13912: PUSH
13913: LD_VAR 0 9
13917: PUSH
13918: LD_INT 1
13920: PPUSH
13921: LD_VAR 0 9
13925: PPUSH
13926: CALL_OW 12
13930: ARRAY
13931: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
13932: LD_VAR 0 2
13936: PPUSH
13937: LD_VAR 0 3
13941: PPUSH
13942: CALL 14191 0 2
13946: NOT
13947: IFFALSE 14006
// repeat engine := _engine [ 1 ] ;
13949: LD_ADDR_VAR 0 3
13953: PUSH
13954: LD_VAR 0 11
13958: PUSH
13959: LD_INT 1
13961: ARRAY
13962: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
13963: LD_ADDR_VAR 0 11
13967: PUSH
13968: LD_VAR 0 11
13972: PPUSH
13973: LD_INT 1
13975: PPUSH
13976: CALL_OW 3
13980: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
13981: LD_VAR 0 2
13985: PPUSH
13986: LD_VAR 0 3
13990: PPUSH
13991: CALL 14191 0 2
13995: PUSH
13996: LD_VAR 0 11
14000: PUSH
14001: EMPTY
14002: EQUAL
14003: OR
14004: IFFALSE 13949
// if not control in _control then
14006: LD_VAR 0 4
14010: PUSH
14011: LD_VAR 0 12
14015: IN
14016: NOT
14017: IFFALSE 14043
// control := _control [ rand ( 1 , _control ) ] ;
14019: LD_ADDR_VAR 0 4
14023: PUSH
14024: LD_VAR 0 12
14028: PUSH
14029: LD_INT 1
14031: PPUSH
14032: LD_VAR 0 12
14036: PPUSH
14037: CALL_OW 12
14041: ARRAY
14042: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
14043: LD_VAR 0 2
14047: PPUSH
14048: LD_VAR 0 5
14052: PPUSH
14053: CALL 14411 0 2
14057: NOT
14058: IFFALSE 14117
// repeat weapon := _weapon [ 1 ] ;
14060: LD_ADDR_VAR 0 5
14064: PUSH
14065: LD_VAR 0 10
14069: PUSH
14070: LD_INT 1
14072: ARRAY
14073: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
14074: LD_ADDR_VAR 0 10
14078: PUSH
14079: LD_VAR 0 10
14083: PPUSH
14084: LD_INT 1
14086: PPUSH
14087: CALL_OW 3
14091: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
14092: LD_VAR 0 2
14096: PPUSH
14097: LD_VAR 0 5
14101: PPUSH
14102: CALL 14411 0 2
14106: PUSH
14107: LD_VAR 0 10
14111: PUSH
14112: EMPTY
14113: EQUAL
14114: OR
14115: IFFALSE 14060
// result := [ ] ;
14117: LD_ADDR_VAR 0 6
14121: PUSH
14122: EMPTY
14123: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
14124: LD_VAR 0 1
14128: PPUSH
14129: LD_VAR 0 2
14133: PPUSH
14134: LD_VAR 0 3
14138: PPUSH
14139: LD_VAR 0 4
14143: PPUSH
14144: LD_VAR 0 5
14148: PPUSH
14149: CALL_OW 448
14153: IFFALSE 14186
// result := [ chassis , engine , control , weapon ] ;
14155: LD_ADDR_VAR 0 6
14159: PUSH
14160: LD_VAR 0 2
14164: PUSH
14165: LD_VAR 0 3
14169: PUSH
14170: LD_VAR 0 4
14174: PUSH
14175: LD_VAR 0 5
14179: PUSH
14180: EMPTY
14181: LIST
14182: LIST
14183: LIST
14184: LIST
14185: ST_TO_ADDR
// end ;
14186: LD_VAR 0 6
14190: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
14191: LD_INT 0
14193: PPUSH
// if not chassis or not engine then
14194: LD_VAR 0 1
14198: NOT
14199: PUSH
14200: LD_VAR 0 2
14204: NOT
14205: OR
14206: IFFALSE 14210
// exit ;
14208: GO 14406
// case engine of engine_solar :
14210: LD_VAR 0 2
14214: PUSH
14215: LD_INT 2
14217: DOUBLE
14218: EQUAL
14219: IFTRUE 14223
14221: GO 14261
14223: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
14224: LD_ADDR_VAR 0 3
14228: PUSH
14229: LD_INT 11
14231: PUSH
14232: LD_INT 12
14234: PUSH
14235: LD_INT 13
14237: PUSH
14238: LD_INT 14
14240: PUSH
14241: LD_INT 1
14243: PUSH
14244: LD_INT 2
14246: PUSH
14247: LD_INT 3
14249: PUSH
14250: EMPTY
14251: LIST
14252: LIST
14253: LIST
14254: LIST
14255: LIST
14256: LIST
14257: LIST
14258: ST_TO_ADDR
14259: GO 14390
14261: LD_INT 1
14263: DOUBLE
14264: EQUAL
14265: IFTRUE 14269
14267: GO 14331
14269: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
14270: LD_ADDR_VAR 0 3
14274: PUSH
14275: LD_INT 11
14277: PUSH
14278: LD_INT 12
14280: PUSH
14281: LD_INT 13
14283: PUSH
14284: LD_INT 14
14286: PUSH
14287: LD_INT 1
14289: PUSH
14290: LD_INT 2
14292: PUSH
14293: LD_INT 3
14295: PUSH
14296: LD_INT 4
14298: PUSH
14299: LD_INT 5
14301: PUSH
14302: LD_INT 21
14304: PUSH
14305: LD_INT 23
14307: PUSH
14308: LD_INT 22
14310: PUSH
14311: LD_INT 24
14313: PUSH
14314: EMPTY
14315: LIST
14316: LIST
14317: LIST
14318: LIST
14319: LIST
14320: LIST
14321: LIST
14322: LIST
14323: LIST
14324: LIST
14325: LIST
14326: LIST
14327: LIST
14328: ST_TO_ADDR
14329: GO 14390
14331: LD_INT 3
14333: DOUBLE
14334: EQUAL
14335: IFTRUE 14339
14337: GO 14389
14339: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
14340: LD_ADDR_VAR 0 3
14344: PUSH
14345: LD_INT 13
14347: PUSH
14348: LD_INT 14
14350: PUSH
14351: LD_INT 2
14353: PUSH
14354: LD_INT 3
14356: PUSH
14357: LD_INT 4
14359: PUSH
14360: LD_INT 5
14362: PUSH
14363: LD_INT 21
14365: PUSH
14366: LD_INT 22
14368: PUSH
14369: LD_INT 23
14371: PUSH
14372: LD_INT 24
14374: PUSH
14375: EMPTY
14376: LIST
14377: LIST
14378: LIST
14379: LIST
14380: LIST
14381: LIST
14382: LIST
14383: LIST
14384: LIST
14385: LIST
14386: ST_TO_ADDR
14387: GO 14390
14389: POP
// result := ( chassis in result ) ;
14390: LD_ADDR_VAR 0 3
14394: PUSH
14395: LD_VAR 0 1
14399: PUSH
14400: LD_VAR 0 3
14404: IN
14405: ST_TO_ADDR
// end ;
14406: LD_VAR 0 3
14410: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
14411: LD_INT 0
14413: PPUSH
// if not chassis or not weapon then
14414: LD_VAR 0 1
14418: NOT
14419: PUSH
14420: LD_VAR 0 2
14424: NOT
14425: OR
14426: IFFALSE 14430
// exit ;
14428: GO 15490
// case weapon of us_machine_gun :
14430: LD_VAR 0 2
14434: PUSH
14435: LD_INT 2
14437: DOUBLE
14438: EQUAL
14439: IFTRUE 14443
14441: GO 14473
14443: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
14444: LD_ADDR_VAR 0 3
14448: PUSH
14449: LD_INT 1
14451: PUSH
14452: LD_INT 2
14454: PUSH
14455: LD_INT 3
14457: PUSH
14458: LD_INT 4
14460: PUSH
14461: LD_INT 5
14463: PUSH
14464: EMPTY
14465: LIST
14466: LIST
14467: LIST
14468: LIST
14469: LIST
14470: ST_TO_ADDR
14471: GO 15474
14473: LD_INT 3
14475: DOUBLE
14476: EQUAL
14477: IFTRUE 14481
14479: GO 14511
14481: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
14482: LD_ADDR_VAR 0 3
14486: PUSH
14487: LD_INT 1
14489: PUSH
14490: LD_INT 2
14492: PUSH
14493: LD_INT 3
14495: PUSH
14496: LD_INT 4
14498: PUSH
14499: LD_INT 5
14501: PUSH
14502: EMPTY
14503: LIST
14504: LIST
14505: LIST
14506: LIST
14507: LIST
14508: ST_TO_ADDR
14509: GO 15474
14511: LD_INT 11
14513: DOUBLE
14514: EQUAL
14515: IFTRUE 14519
14517: GO 14549
14519: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
14520: LD_ADDR_VAR 0 3
14524: PUSH
14525: LD_INT 1
14527: PUSH
14528: LD_INT 2
14530: PUSH
14531: LD_INT 3
14533: PUSH
14534: LD_INT 4
14536: PUSH
14537: LD_INT 5
14539: PUSH
14540: EMPTY
14541: LIST
14542: LIST
14543: LIST
14544: LIST
14545: LIST
14546: ST_TO_ADDR
14547: GO 15474
14549: LD_INT 4
14551: DOUBLE
14552: EQUAL
14553: IFTRUE 14557
14555: GO 14583
14557: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
14558: LD_ADDR_VAR 0 3
14562: PUSH
14563: LD_INT 2
14565: PUSH
14566: LD_INT 3
14568: PUSH
14569: LD_INT 4
14571: PUSH
14572: LD_INT 5
14574: PUSH
14575: EMPTY
14576: LIST
14577: LIST
14578: LIST
14579: LIST
14580: ST_TO_ADDR
14581: GO 15474
14583: LD_INT 5
14585: DOUBLE
14586: EQUAL
14587: IFTRUE 14591
14589: GO 14617
14591: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
14592: LD_ADDR_VAR 0 3
14596: PUSH
14597: LD_INT 2
14599: PUSH
14600: LD_INT 3
14602: PUSH
14603: LD_INT 4
14605: PUSH
14606: LD_INT 5
14608: PUSH
14609: EMPTY
14610: LIST
14611: LIST
14612: LIST
14613: LIST
14614: ST_TO_ADDR
14615: GO 15474
14617: LD_INT 9
14619: DOUBLE
14620: EQUAL
14621: IFTRUE 14625
14623: GO 14651
14625: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
14626: LD_ADDR_VAR 0 3
14630: PUSH
14631: LD_INT 2
14633: PUSH
14634: LD_INT 3
14636: PUSH
14637: LD_INT 4
14639: PUSH
14640: LD_INT 5
14642: PUSH
14643: EMPTY
14644: LIST
14645: LIST
14646: LIST
14647: LIST
14648: ST_TO_ADDR
14649: GO 15474
14651: LD_INT 7
14653: DOUBLE
14654: EQUAL
14655: IFTRUE 14659
14657: GO 14685
14659: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
14660: LD_ADDR_VAR 0 3
14664: PUSH
14665: LD_INT 2
14667: PUSH
14668: LD_INT 3
14670: PUSH
14671: LD_INT 4
14673: PUSH
14674: LD_INT 5
14676: PUSH
14677: EMPTY
14678: LIST
14679: LIST
14680: LIST
14681: LIST
14682: ST_TO_ADDR
14683: GO 15474
14685: LD_INT 12
14687: DOUBLE
14688: EQUAL
14689: IFTRUE 14693
14691: GO 14719
14693: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
14694: LD_ADDR_VAR 0 3
14698: PUSH
14699: LD_INT 2
14701: PUSH
14702: LD_INT 3
14704: PUSH
14705: LD_INT 4
14707: PUSH
14708: LD_INT 5
14710: PUSH
14711: EMPTY
14712: LIST
14713: LIST
14714: LIST
14715: LIST
14716: ST_TO_ADDR
14717: GO 15474
14719: LD_INT 13
14721: DOUBLE
14722: EQUAL
14723: IFTRUE 14727
14725: GO 14753
14727: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
14728: LD_ADDR_VAR 0 3
14732: PUSH
14733: LD_INT 2
14735: PUSH
14736: LD_INT 3
14738: PUSH
14739: LD_INT 4
14741: PUSH
14742: LD_INT 5
14744: PUSH
14745: EMPTY
14746: LIST
14747: LIST
14748: LIST
14749: LIST
14750: ST_TO_ADDR
14751: GO 15474
14753: LD_INT 14
14755: DOUBLE
14756: EQUAL
14757: IFTRUE 14761
14759: GO 14779
14761: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
14762: LD_ADDR_VAR 0 3
14766: PUSH
14767: LD_INT 4
14769: PUSH
14770: LD_INT 5
14772: PUSH
14773: EMPTY
14774: LIST
14775: LIST
14776: ST_TO_ADDR
14777: GO 15474
14779: LD_INT 6
14781: DOUBLE
14782: EQUAL
14783: IFTRUE 14787
14785: GO 14805
14787: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
14788: LD_ADDR_VAR 0 3
14792: PUSH
14793: LD_INT 4
14795: PUSH
14796: LD_INT 5
14798: PUSH
14799: EMPTY
14800: LIST
14801: LIST
14802: ST_TO_ADDR
14803: GO 15474
14805: LD_INT 10
14807: DOUBLE
14808: EQUAL
14809: IFTRUE 14813
14811: GO 14831
14813: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
14814: LD_ADDR_VAR 0 3
14818: PUSH
14819: LD_INT 4
14821: PUSH
14822: LD_INT 5
14824: PUSH
14825: EMPTY
14826: LIST
14827: LIST
14828: ST_TO_ADDR
14829: GO 15474
14831: LD_INT 22
14833: DOUBLE
14834: EQUAL
14835: IFTRUE 14839
14837: GO 14865
14839: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
14840: LD_ADDR_VAR 0 3
14844: PUSH
14845: LD_INT 11
14847: PUSH
14848: LD_INT 12
14850: PUSH
14851: LD_INT 13
14853: PUSH
14854: LD_INT 14
14856: PUSH
14857: EMPTY
14858: LIST
14859: LIST
14860: LIST
14861: LIST
14862: ST_TO_ADDR
14863: GO 15474
14865: LD_INT 23
14867: DOUBLE
14868: EQUAL
14869: IFTRUE 14873
14871: GO 14899
14873: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
14874: LD_ADDR_VAR 0 3
14878: PUSH
14879: LD_INT 11
14881: PUSH
14882: LD_INT 12
14884: PUSH
14885: LD_INT 13
14887: PUSH
14888: LD_INT 14
14890: PUSH
14891: EMPTY
14892: LIST
14893: LIST
14894: LIST
14895: LIST
14896: ST_TO_ADDR
14897: GO 15474
14899: LD_INT 24
14901: DOUBLE
14902: EQUAL
14903: IFTRUE 14907
14905: GO 14933
14907: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
14908: LD_ADDR_VAR 0 3
14912: PUSH
14913: LD_INT 11
14915: PUSH
14916: LD_INT 12
14918: PUSH
14919: LD_INT 13
14921: PUSH
14922: LD_INT 14
14924: PUSH
14925: EMPTY
14926: LIST
14927: LIST
14928: LIST
14929: LIST
14930: ST_TO_ADDR
14931: GO 15474
14933: LD_INT 30
14935: DOUBLE
14936: EQUAL
14937: IFTRUE 14941
14939: GO 14967
14941: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
14942: LD_ADDR_VAR 0 3
14946: PUSH
14947: LD_INT 11
14949: PUSH
14950: LD_INT 12
14952: PUSH
14953: LD_INT 13
14955: PUSH
14956: LD_INT 14
14958: PUSH
14959: EMPTY
14960: LIST
14961: LIST
14962: LIST
14963: LIST
14964: ST_TO_ADDR
14965: GO 15474
14967: LD_INT 25
14969: DOUBLE
14970: EQUAL
14971: IFTRUE 14975
14973: GO 14993
14975: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
14976: LD_ADDR_VAR 0 3
14980: PUSH
14981: LD_INT 13
14983: PUSH
14984: LD_INT 14
14986: PUSH
14987: EMPTY
14988: LIST
14989: LIST
14990: ST_TO_ADDR
14991: GO 15474
14993: LD_INT 27
14995: DOUBLE
14996: EQUAL
14997: IFTRUE 15001
14999: GO 15019
15001: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
15002: LD_ADDR_VAR 0 3
15006: PUSH
15007: LD_INT 13
15009: PUSH
15010: LD_INT 14
15012: PUSH
15013: EMPTY
15014: LIST
15015: LIST
15016: ST_TO_ADDR
15017: GO 15474
15019: LD_INT 92
15021: DOUBLE
15022: EQUAL
15023: IFTRUE 15027
15025: GO 15053
15027: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
15028: LD_ADDR_VAR 0 3
15032: PUSH
15033: LD_INT 11
15035: PUSH
15036: LD_INT 12
15038: PUSH
15039: LD_INT 13
15041: PUSH
15042: LD_INT 14
15044: PUSH
15045: EMPTY
15046: LIST
15047: LIST
15048: LIST
15049: LIST
15050: ST_TO_ADDR
15051: GO 15474
15053: LD_INT 28
15055: DOUBLE
15056: EQUAL
15057: IFTRUE 15061
15059: GO 15079
15061: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
15062: LD_ADDR_VAR 0 3
15066: PUSH
15067: LD_INT 13
15069: PUSH
15070: LD_INT 14
15072: PUSH
15073: EMPTY
15074: LIST
15075: LIST
15076: ST_TO_ADDR
15077: GO 15474
15079: LD_INT 29
15081: DOUBLE
15082: EQUAL
15083: IFTRUE 15087
15085: GO 15105
15087: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
15088: LD_ADDR_VAR 0 3
15092: PUSH
15093: LD_INT 13
15095: PUSH
15096: LD_INT 14
15098: PUSH
15099: EMPTY
15100: LIST
15101: LIST
15102: ST_TO_ADDR
15103: GO 15474
15105: LD_INT 31
15107: DOUBLE
15108: EQUAL
15109: IFTRUE 15113
15111: GO 15131
15113: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
15114: LD_ADDR_VAR 0 3
15118: PUSH
15119: LD_INT 13
15121: PUSH
15122: LD_INT 14
15124: PUSH
15125: EMPTY
15126: LIST
15127: LIST
15128: ST_TO_ADDR
15129: GO 15474
15131: LD_INT 26
15133: DOUBLE
15134: EQUAL
15135: IFTRUE 15139
15137: GO 15157
15139: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
15140: LD_ADDR_VAR 0 3
15144: PUSH
15145: LD_INT 13
15147: PUSH
15148: LD_INT 14
15150: PUSH
15151: EMPTY
15152: LIST
15153: LIST
15154: ST_TO_ADDR
15155: GO 15474
15157: LD_INT 42
15159: DOUBLE
15160: EQUAL
15161: IFTRUE 15165
15163: GO 15191
15165: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
15166: LD_ADDR_VAR 0 3
15170: PUSH
15171: LD_INT 21
15173: PUSH
15174: LD_INT 22
15176: PUSH
15177: LD_INT 23
15179: PUSH
15180: LD_INT 24
15182: PUSH
15183: EMPTY
15184: LIST
15185: LIST
15186: LIST
15187: LIST
15188: ST_TO_ADDR
15189: GO 15474
15191: LD_INT 43
15193: DOUBLE
15194: EQUAL
15195: IFTRUE 15199
15197: GO 15225
15199: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
15200: LD_ADDR_VAR 0 3
15204: PUSH
15205: LD_INT 21
15207: PUSH
15208: LD_INT 22
15210: PUSH
15211: LD_INT 23
15213: PUSH
15214: LD_INT 24
15216: PUSH
15217: EMPTY
15218: LIST
15219: LIST
15220: LIST
15221: LIST
15222: ST_TO_ADDR
15223: GO 15474
15225: LD_INT 44
15227: DOUBLE
15228: EQUAL
15229: IFTRUE 15233
15231: GO 15259
15233: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
15234: LD_ADDR_VAR 0 3
15238: PUSH
15239: LD_INT 21
15241: PUSH
15242: LD_INT 22
15244: PUSH
15245: LD_INT 23
15247: PUSH
15248: LD_INT 24
15250: PUSH
15251: EMPTY
15252: LIST
15253: LIST
15254: LIST
15255: LIST
15256: ST_TO_ADDR
15257: GO 15474
15259: LD_INT 45
15261: DOUBLE
15262: EQUAL
15263: IFTRUE 15267
15265: GO 15293
15267: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
15268: LD_ADDR_VAR 0 3
15272: PUSH
15273: LD_INT 21
15275: PUSH
15276: LD_INT 22
15278: PUSH
15279: LD_INT 23
15281: PUSH
15282: LD_INT 24
15284: PUSH
15285: EMPTY
15286: LIST
15287: LIST
15288: LIST
15289: LIST
15290: ST_TO_ADDR
15291: GO 15474
15293: LD_INT 49
15295: DOUBLE
15296: EQUAL
15297: IFTRUE 15301
15299: GO 15327
15301: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
15302: LD_ADDR_VAR 0 3
15306: PUSH
15307: LD_INT 21
15309: PUSH
15310: LD_INT 22
15312: PUSH
15313: LD_INT 23
15315: PUSH
15316: LD_INT 24
15318: PUSH
15319: EMPTY
15320: LIST
15321: LIST
15322: LIST
15323: LIST
15324: ST_TO_ADDR
15325: GO 15474
15327: LD_INT 51
15329: DOUBLE
15330: EQUAL
15331: IFTRUE 15335
15333: GO 15361
15335: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
15336: LD_ADDR_VAR 0 3
15340: PUSH
15341: LD_INT 21
15343: PUSH
15344: LD_INT 22
15346: PUSH
15347: LD_INT 23
15349: PUSH
15350: LD_INT 24
15352: PUSH
15353: EMPTY
15354: LIST
15355: LIST
15356: LIST
15357: LIST
15358: ST_TO_ADDR
15359: GO 15474
15361: LD_INT 52
15363: DOUBLE
15364: EQUAL
15365: IFTRUE 15369
15367: GO 15395
15369: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
15370: LD_ADDR_VAR 0 3
15374: PUSH
15375: LD_INT 21
15377: PUSH
15378: LD_INT 22
15380: PUSH
15381: LD_INT 23
15383: PUSH
15384: LD_INT 24
15386: PUSH
15387: EMPTY
15388: LIST
15389: LIST
15390: LIST
15391: LIST
15392: ST_TO_ADDR
15393: GO 15474
15395: LD_INT 53
15397: DOUBLE
15398: EQUAL
15399: IFTRUE 15403
15401: GO 15421
15403: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
15404: LD_ADDR_VAR 0 3
15408: PUSH
15409: LD_INT 23
15411: PUSH
15412: LD_INT 24
15414: PUSH
15415: EMPTY
15416: LIST
15417: LIST
15418: ST_TO_ADDR
15419: GO 15474
15421: LD_INT 46
15423: DOUBLE
15424: EQUAL
15425: IFTRUE 15429
15427: GO 15447
15429: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
15430: LD_ADDR_VAR 0 3
15434: PUSH
15435: LD_INT 23
15437: PUSH
15438: LD_INT 24
15440: PUSH
15441: EMPTY
15442: LIST
15443: LIST
15444: ST_TO_ADDR
15445: GO 15474
15447: LD_INT 47
15449: DOUBLE
15450: EQUAL
15451: IFTRUE 15455
15453: GO 15473
15455: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
15456: LD_ADDR_VAR 0 3
15460: PUSH
15461: LD_INT 23
15463: PUSH
15464: LD_INT 24
15466: PUSH
15467: EMPTY
15468: LIST
15469: LIST
15470: ST_TO_ADDR
15471: GO 15474
15473: POP
// result := ( chassis in result ) ;
15474: LD_ADDR_VAR 0 3
15478: PUSH
15479: LD_VAR 0 1
15483: PUSH
15484: LD_VAR 0 3
15488: IN
15489: ST_TO_ADDR
// end ;
15490: LD_VAR 0 3
15494: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
15495: LD_INT 0
15497: PPUSH
15498: PPUSH
15499: PPUSH
15500: PPUSH
15501: PPUSH
15502: PPUSH
15503: PPUSH
// result := array ;
15504: LD_ADDR_VAR 0 5
15508: PUSH
15509: LD_VAR 0 1
15513: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
15514: LD_VAR 0 1
15518: NOT
15519: PUSH
15520: LD_VAR 0 2
15524: NOT
15525: OR
15526: PUSH
15527: LD_VAR 0 3
15531: NOT
15532: OR
15533: PUSH
15534: LD_VAR 0 2
15538: PUSH
15539: LD_VAR 0 1
15543: GREATER
15544: OR
15545: PUSH
15546: LD_VAR 0 3
15550: PUSH
15551: LD_VAR 0 1
15555: GREATER
15556: OR
15557: IFFALSE 15561
// exit ;
15559: GO 15857
// if direction then
15561: LD_VAR 0 4
15565: IFFALSE 15629
// begin d := 1 ;
15567: LD_ADDR_VAR 0 9
15571: PUSH
15572: LD_INT 1
15574: ST_TO_ADDR
// if i_from > i_to then
15575: LD_VAR 0 2
15579: PUSH
15580: LD_VAR 0 3
15584: GREATER
15585: IFFALSE 15611
// length := ( array - i_from ) + i_to else
15587: LD_ADDR_VAR 0 11
15591: PUSH
15592: LD_VAR 0 1
15596: PUSH
15597: LD_VAR 0 2
15601: MINUS
15602: PUSH
15603: LD_VAR 0 3
15607: PLUS
15608: ST_TO_ADDR
15609: GO 15627
// length := i_to - i_from ;
15611: LD_ADDR_VAR 0 11
15615: PUSH
15616: LD_VAR 0 3
15620: PUSH
15621: LD_VAR 0 2
15625: MINUS
15626: ST_TO_ADDR
// end else
15627: GO 15690
// begin d := - 1 ;
15629: LD_ADDR_VAR 0 9
15633: PUSH
15634: LD_INT 1
15636: NEG
15637: ST_TO_ADDR
// if i_from > i_to then
15638: LD_VAR 0 2
15642: PUSH
15643: LD_VAR 0 3
15647: GREATER
15648: IFFALSE 15668
// length := i_from - i_to else
15650: LD_ADDR_VAR 0 11
15654: PUSH
15655: LD_VAR 0 2
15659: PUSH
15660: LD_VAR 0 3
15664: MINUS
15665: ST_TO_ADDR
15666: GO 15690
// length := ( array - i_to ) + i_from ;
15668: LD_ADDR_VAR 0 11
15672: PUSH
15673: LD_VAR 0 1
15677: PUSH
15678: LD_VAR 0 3
15682: MINUS
15683: PUSH
15684: LD_VAR 0 2
15688: PLUS
15689: ST_TO_ADDR
// end ; if not length then
15690: LD_VAR 0 11
15694: NOT
15695: IFFALSE 15699
// exit ;
15697: GO 15857
// tmp := array ;
15699: LD_ADDR_VAR 0 10
15703: PUSH
15704: LD_VAR 0 1
15708: ST_TO_ADDR
// for i = 1 to length do
15709: LD_ADDR_VAR 0 6
15713: PUSH
15714: DOUBLE
15715: LD_INT 1
15717: DEC
15718: ST_TO_ADDR
15719: LD_VAR 0 11
15723: PUSH
15724: FOR_TO
15725: IFFALSE 15845
// begin for j = 1 to array do
15727: LD_ADDR_VAR 0 7
15731: PUSH
15732: DOUBLE
15733: LD_INT 1
15735: DEC
15736: ST_TO_ADDR
15737: LD_VAR 0 1
15741: PUSH
15742: FOR_TO
15743: IFFALSE 15831
// begin k := j + d ;
15745: LD_ADDR_VAR 0 8
15749: PUSH
15750: LD_VAR 0 7
15754: PUSH
15755: LD_VAR 0 9
15759: PLUS
15760: ST_TO_ADDR
// if k > array then
15761: LD_VAR 0 8
15765: PUSH
15766: LD_VAR 0 1
15770: GREATER
15771: IFFALSE 15781
// k := 1 ;
15773: LD_ADDR_VAR 0 8
15777: PUSH
15778: LD_INT 1
15780: ST_TO_ADDR
// if not k then
15781: LD_VAR 0 8
15785: NOT
15786: IFFALSE 15798
// k := array ;
15788: LD_ADDR_VAR 0 8
15792: PUSH
15793: LD_VAR 0 1
15797: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
15798: LD_ADDR_VAR 0 10
15802: PUSH
15803: LD_VAR 0 10
15807: PPUSH
15808: LD_VAR 0 8
15812: PPUSH
15813: LD_VAR 0 1
15817: PUSH
15818: LD_VAR 0 7
15822: ARRAY
15823: PPUSH
15824: CALL_OW 1
15828: ST_TO_ADDR
// end ;
15829: GO 15742
15831: POP
15832: POP
// array := tmp ;
15833: LD_ADDR_VAR 0 1
15837: PUSH
15838: LD_VAR 0 10
15842: ST_TO_ADDR
// end ;
15843: GO 15724
15845: POP
15846: POP
// result := array ;
15847: LD_ADDR_VAR 0 5
15851: PUSH
15852: LD_VAR 0 1
15856: ST_TO_ADDR
// end ;
15857: LD_VAR 0 5
15861: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
15862: LD_INT 0
15864: PPUSH
15865: PPUSH
// result := 0 ;
15866: LD_ADDR_VAR 0 3
15870: PUSH
15871: LD_INT 0
15873: ST_TO_ADDR
// if not array or not value in array then
15874: LD_VAR 0 1
15878: NOT
15879: PUSH
15880: LD_VAR 0 2
15884: PUSH
15885: LD_VAR 0 1
15889: IN
15890: NOT
15891: OR
15892: IFFALSE 15896
// exit ;
15894: GO 15950
// for i = 1 to array do
15896: LD_ADDR_VAR 0 4
15900: PUSH
15901: DOUBLE
15902: LD_INT 1
15904: DEC
15905: ST_TO_ADDR
15906: LD_VAR 0 1
15910: PUSH
15911: FOR_TO
15912: IFFALSE 15948
// if value = array [ i ] then
15914: LD_VAR 0 2
15918: PUSH
15919: LD_VAR 0 1
15923: PUSH
15924: LD_VAR 0 4
15928: ARRAY
15929: EQUAL
15930: IFFALSE 15946
// begin result := i ;
15932: LD_ADDR_VAR 0 3
15936: PUSH
15937: LD_VAR 0 4
15941: ST_TO_ADDR
// exit ;
15942: POP
15943: POP
15944: GO 15950
// end ;
15946: GO 15911
15948: POP
15949: POP
// end ;
15950: LD_VAR 0 3
15954: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
15955: LD_INT 0
15957: PPUSH
// vc_chassis := chassis ;
15958: LD_ADDR_OWVAR 37
15962: PUSH
15963: LD_VAR 0 1
15967: ST_TO_ADDR
// vc_engine := engine ;
15968: LD_ADDR_OWVAR 39
15972: PUSH
15973: LD_VAR 0 2
15977: ST_TO_ADDR
// vc_control := control ;
15978: LD_ADDR_OWVAR 38
15982: PUSH
15983: LD_VAR 0 3
15987: ST_TO_ADDR
// vc_weapon := weapon ;
15988: LD_ADDR_OWVAR 40
15992: PUSH
15993: LD_VAR 0 4
15997: ST_TO_ADDR
// vc_fuel_battery := fuel ;
15998: LD_ADDR_OWVAR 41
16002: PUSH
16003: LD_VAR 0 5
16007: ST_TO_ADDR
// end ;
16008: LD_VAR 0 6
16012: RET
// export function WantPlant ( unit ) ; var task ; begin
16013: LD_INT 0
16015: PPUSH
16016: PPUSH
// result := false ;
16017: LD_ADDR_VAR 0 2
16021: PUSH
16022: LD_INT 0
16024: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
16025: LD_ADDR_VAR 0 3
16029: PUSH
16030: LD_VAR 0 1
16034: PPUSH
16035: CALL_OW 437
16039: ST_TO_ADDR
// if task then
16040: LD_VAR 0 3
16044: IFFALSE 16072
// if task [ 1 ] [ 1 ] = p then
16046: LD_VAR 0 3
16050: PUSH
16051: LD_INT 1
16053: ARRAY
16054: PUSH
16055: LD_INT 1
16057: ARRAY
16058: PUSH
16059: LD_STRING p
16061: EQUAL
16062: IFFALSE 16072
// result := true ;
16064: LD_ADDR_VAR 0 2
16068: PUSH
16069: LD_INT 1
16071: ST_TO_ADDR
// end ;
16072: LD_VAR 0 2
16076: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
16077: LD_INT 0
16079: PPUSH
16080: PPUSH
16081: PPUSH
16082: PPUSH
// if pos < 1 then
16083: LD_VAR 0 2
16087: PUSH
16088: LD_INT 1
16090: LESS
16091: IFFALSE 16095
// exit ;
16093: GO 16398
// if pos = 1 then
16095: LD_VAR 0 2
16099: PUSH
16100: LD_INT 1
16102: EQUAL
16103: IFFALSE 16136
// result := Replace ( arr , pos [ 1 ] , value ) else
16105: LD_ADDR_VAR 0 4
16109: PUSH
16110: LD_VAR 0 1
16114: PPUSH
16115: LD_VAR 0 2
16119: PUSH
16120: LD_INT 1
16122: ARRAY
16123: PPUSH
16124: LD_VAR 0 3
16128: PPUSH
16129: CALL_OW 1
16133: ST_TO_ADDR
16134: GO 16398
// begin tmp := arr ;
16136: LD_ADDR_VAR 0 6
16140: PUSH
16141: LD_VAR 0 1
16145: ST_TO_ADDR
// s_arr := [ tmp ] ;
16146: LD_ADDR_VAR 0 7
16150: PUSH
16151: LD_VAR 0 6
16155: PUSH
16156: EMPTY
16157: LIST
16158: ST_TO_ADDR
// for i = 1 to pos - 1 do
16159: LD_ADDR_VAR 0 5
16163: PUSH
16164: DOUBLE
16165: LD_INT 1
16167: DEC
16168: ST_TO_ADDR
16169: LD_VAR 0 2
16173: PUSH
16174: LD_INT 1
16176: MINUS
16177: PUSH
16178: FOR_TO
16179: IFFALSE 16224
// begin tmp := tmp [ pos [ i ] ] ;
16181: LD_ADDR_VAR 0 6
16185: PUSH
16186: LD_VAR 0 6
16190: PUSH
16191: LD_VAR 0 2
16195: PUSH
16196: LD_VAR 0 5
16200: ARRAY
16201: ARRAY
16202: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
16203: LD_ADDR_VAR 0 7
16207: PUSH
16208: LD_VAR 0 7
16212: PUSH
16213: LD_VAR 0 6
16217: PUSH
16218: EMPTY
16219: LIST
16220: ADD
16221: ST_TO_ADDR
// end ;
16222: GO 16178
16224: POP
16225: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
16226: LD_ADDR_VAR 0 6
16230: PUSH
16231: LD_VAR 0 6
16235: PPUSH
16236: LD_VAR 0 2
16240: PUSH
16241: LD_VAR 0 2
16245: ARRAY
16246: PPUSH
16247: LD_VAR 0 3
16251: PPUSH
16252: CALL_OW 1
16256: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
16257: LD_ADDR_VAR 0 7
16261: PUSH
16262: LD_VAR 0 7
16266: PPUSH
16267: LD_VAR 0 7
16271: PPUSH
16272: LD_VAR 0 6
16276: PPUSH
16277: CALL_OW 1
16281: ST_TO_ADDR
// for i = s_arr downto 2 do
16282: LD_ADDR_VAR 0 5
16286: PUSH
16287: DOUBLE
16288: LD_VAR 0 7
16292: INC
16293: ST_TO_ADDR
16294: LD_INT 2
16296: PUSH
16297: FOR_DOWNTO
16298: IFFALSE 16382
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
16300: LD_ADDR_VAR 0 6
16304: PUSH
16305: LD_VAR 0 7
16309: PUSH
16310: LD_VAR 0 5
16314: PUSH
16315: LD_INT 1
16317: MINUS
16318: ARRAY
16319: PPUSH
16320: LD_VAR 0 2
16324: PUSH
16325: LD_VAR 0 5
16329: PUSH
16330: LD_INT 1
16332: MINUS
16333: ARRAY
16334: PPUSH
16335: LD_VAR 0 7
16339: PUSH
16340: LD_VAR 0 5
16344: ARRAY
16345: PPUSH
16346: CALL_OW 1
16350: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
16351: LD_ADDR_VAR 0 7
16355: PUSH
16356: LD_VAR 0 7
16360: PPUSH
16361: LD_VAR 0 5
16365: PUSH
16366: LD_INT 1
16368: MINUS
16369: PPUSH
16370: LD_VAR 0 6
16374: PPUSH
16375: CALL_OW 1
16379: ST_TO_ADDR
// end ;
16380: GO 16297
16382: POP
16383: POP
// result := s_arr [ 1 ] ;
16384: LD_ADDR_VAR 0 4
16388: PUSH
16389: LD_VAR 0 7
16393: PUSH
16394: LD_INT 1
16396: ARRAY
16397: ST_TO_ADDR
// end ; end ;
16398: LD_VAR 0 4
16402: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
16403: LD_INT 0
16405: PPUSH
16406: PPUSH
// if not list then
16407: LD_VAR 0 1
16411: NOT
16412: IFFALSE 16416
// exit ;
16414: GO 16507
// i := list [ pos1 ] ;
16416: LD_ADDR_VAR 0 5
16420: PUSH
16421: LD_VAR 0 1
16425: PUSH
16426: LD_VAR 0 2
16430: ARRAY
16431: ST_TO_ADDR
// if not i then
16432: LD_VAR 0 5
16436: NOT
16437: IFFALSE 16441
// exit ;
16439: GO 16507
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
16441: LD_ADDR_VAR 0 1
16445: PUSH
16446: LD_VAR 0 1
16450: PPUSH
16451: LD_VAR 0 2
16455: PPUSH
16456: LD_VAR 0 1
16460: PUSH
16461: LD_VAR 0 3
16465: ARRAY
16466: PPUSH
16467: CALL_OW 1
16471: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
16472: LD_ADDR_VAR 0 1
16476: PUSH
16477: LD_VAR 0 1
16481: PPUSH
16482: LD_VAR 0 3
16486: PPUSH
16487: LD_VAR 0 5
16491: PPUSH
16492: CALL_OW 1
16496: ST_TO_ADDR
// result := list ;
16497: LD_ADDR_VAR 0 4
16501: PUSH
16502: LD_VAR 0 1
16506: ST_TO_ADDR
// end ;
16507: LD_VAR 0 4
16511: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
16512: LD_INT 0
16514: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
16515: LD_ADDR_VAR 0 5
16519: PUSH
16520: LD_VAR 0 1
16524: PPUSH
16525: CALL_OW 250
16529: PPUSH
16530: LD_VAR 0 1
16534: PPUSH
16535: CALL_OW 251
16539: PPUSH
16540: LD_VAR 0 2
16544: PPUSH
16545: LD_VAR 0 3
16549: PPUSH
16550: LD_VAR 0 4
16554: PPUSH
16555: CALL 16933 0 5
16559: ST_TO_ADDR
// end ;
16560: LD_VAR 0 5
16564: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
16565: LD_INT 0
16567: PPUSH
16568: PPUSH
16569: PPUSH
16570: PPUSH
// if not list or not unit then
16571: LD_VAR 0 2
16575: NOT
16576: PUSH
16577: LD_VAR 0 1
16581: NOT
16582: OR
16583: IFFALSE 16587
// exit ;
16585: GO 16928
// result := [ ] ;
16587: LD_ADDR_VAR 0 5
16591: PUSH
16592: EMPTY
16593: ST_TO_ADDR
// for i in list do
16594: LD_ADDR_VAR 0 6
16598: PUSH
16599: LD_VAR 0 2
16603: PUSH
16604: FOR_IN
16605: IFFALSE 16823
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
16607: LD_ADDR_VAR 0 8
16611: PUSH
16612: LD_VAR 0 1
16616: PPUSH
16617: LD_VAR 0 6
16621: PUSH
16622: LD_INT 1
16624: ARRAY
16625: PPUSH
16626: LD_VAR 0 6
16630: PUSH
16631: LD_INT 2
16633: ARRAY
16634: PPUSH
16635: CALL_OW 297
16639: ST_TO_ADDR
// if not Count ( result ) then
16640: LD_VAR 0 5
16644: PPUSH
16645: CALL 13217 0 1
16649: NOT
16650: IFFALSE 16683
// begin result := Join ( result , [ i , tmp ] ) ;
16652: LD_ADDR_VAR 0 5
16656: PUSH
16657: LD_VAR 0 5
16661: PPUSH
16662: LD_VAR 0 6
16666: PUSH
16667: LD_VAR 0 8
16671: PUSH
16672: EMPTY
16673: LIST
16674: LIST
16675: PPUSH
16676: CALL 48817 0 2
16680: ST_TO_ADDR
// continue ;
16681: GO 16604
// end ; if result [ result ] [ 2 ] <= tmp then
16683: LD_VAR 0 5
16687: PUSH
16688: LD_VAR 0 5
16692: ARRAY
16693: PUSH
16694: LD_INT 2
16696: ARRAY
16697: PUSH
16698: LD_VAR 0 8
16702: LESSEQUAL
16703: IFFALSE 16736
// result := Join ( result , [ i , tmp ] ) else
16705: LD_ADDR_VAR 0 5
16709: PUSH
16710: LD_VAR 0 5
16714: PPUSH
16715: LD_VAR 0 6
16719: PUSH
16720: LD_VAR 0 8
16724: PUSH
16725: EMPTY
16726: LIST
16727: LIST
16728: PPUSH
16729: CALL 48817 0 2
16733: ST_TO_ADDR
16734: GO 16821
// begin for j := 1 to Count ( result ) do
16736: LD_ADDR_VAR 0 7
16740: PUSH
16741: DOUBLE
16742: LD_INT 1
16744: DEC
16745: ST_TO_ADDR
16746: LD_VAR 0 5
16750: PPUSH
16751: CALL 13217 0 1
16755: PUSH
16756: FOR_TO
16757: IFFALSE 16819
// begin if tmp < result [ j ] [ 2 ] then
16759: LD_VAR 0 8
16763: PUSH
16764: LD_VAR 0 5
16768: PUSH
16769: LD_VAR 0 7
16773: ARRAY
16774: PUSH
16775: LD_INT 2
16777: ARRAY
16778: LESS
16779: IFFALSE 16817
// begin result := Insert ( result , j , [ i , tmp ] ) ;
16781: LD_ADDR_VAR 0 5
16785: PUSH
16786: LD_VAR 0 5
16790: PPUSH
16791: LD_VAR 0 7
16795: PPUSH
16796: LD_VAR 0 6
16800: PUSH
16801: LD_VAR 0 8
16805: PUSH
16806: EMPTY
16807: LIST
16808: LIST
16809: PPUSH
16810: CALL_OW 2
16814: ST_TO_ADDR
// break ;
16815: GO 16819
// end ; end ;
16817: GO 16756
16819: POP
16820: POP
// end ; end ;
16821: GO 16604
16823: POP
16824: POP
// if result and not asc then
16825: LD_VAR 0 5
16829: PUSH
16830: LD_VAR 0 3
16834: NOT
16835: AND
16836: IFFALSE 16853
// result := ReverseArray ( result ) ;
16838: LD_ADDR_VAR 0 5
16842: PUSH
16843: LD_VAR 0 5
16847: PPUSH
16848: CALL 44093 0 1
16852: ST_TO_ADDR
// tmp := [ ] ;
16853: LD_ADDR_VAR 0 8
16857: PUSH
16858: EMPTY
16859: ST_TO_ADDR
// if mode then
16860: LD_VAR 0 4
16864: IFFALSE 16928
// begin for i := 1 to result do
16866: LD_ADDR_VAR 0 6
16870: PUSH
16871: DOUBLE
16872: LD_INT 1
16874: DEC
16875: ST_TO_ADDR
16876: LD_VAR 0 5
16880: PUSH
16881: FOR_TO
16882: IFFALSE 16916
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
16884: LD_ADDR_VAR 0 8
16888: PUSH
16889: LD_VAR 0 8
16893: PPUSH
16894: LD_VAR 0 5
16898: PUSH
16899: LD_VAR 0 6
16903: ARRAY
16904: PUSH
16905: LD_INT 1
16907: ARRAY
16908: PPUSH
16909: CALL 48817 0 2
16913: ST_TO_ADDR
16914: GO 16881
16916: POP
16917: POP
// result := tmp ;
16918: LD_ADDR_VAR 0 5
16922: PUSH
16923: LD_VAR 0 8
16927: ST_TO_ADDR
// end ; end ;
16928: LD_VAR 0 5
16932: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
16933: LD_INT 0
16935: PPUSH
16936: PPUSH
16937: PPUSH
16938: PPUSH
// if not list then
16939: LD_VAR 0 3
16943: NOT
16944: IFFALSE 16948
// exit ;
16946: GO 17336
// result := [ ] ;
16948: LD_ADDR_VAR 0 6
16952: PUSH
16953: EMPTY
16954: ST_TO_ADDR
// for i in list do
16955: LD_ADDR_VAR 0 7
16959: PUSH
16960: LD_VAR 0 3
16964: PUSH
16965: FOR_IN
16966: IFFALSE 17168
// begin tmp := GetDistUnitXY ( i , x , y ) ;
16968: LD_ADDR_VAR 0 9
16972: PUSH
16973: LD_VAR 0 7
16977: PPUSH
16978: LD_VAR 0 1
16982: PPUSH
16983: LD_VAR 0 2
16987: PPUSH
16988: CALL_OW 297
16992: ST_TO_ADDR
// if not result then
16993: LD_VAR 0 6
16997: NOT
16998: IFFALSE 17024
// result := [ [ i , tmp ] ] else
17000: LD_ADDR_VAR 0 6
17004: PUSH
17005: LD_VAR 0 7
17009: PUSH
17010: LD_VAR 0 9
17014: PUSH
17015: EMPTY
17016: LIST
17017: LIST
17018: PUSH
17019: EMPTY
17020: LIST
17021: ST_TO_ADDR
17022: GO 17166
// begin if result [ result ] [ 2 ] < tmp then
17024: LD_VAR 0 6
17028: PUSH
17029: LD_VAR 0 6
17033: ARRAY
17034: PUSH
17035: LD_INT 2
17037: ARRAY
17038: PUSH
17039: LD_VAR 0 9
17043: LESS
17044: IFFALSE 17086
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
17046: LD_ADDR_VAR 0 6
17050: PUSH
17051: LD_VAR 0 6
17055: PPUSH
17056: LD_VAR 0 6
17060: PUSH
17061: LD_INT 1
17063: PLUS
17064: PPUSH
17065: LD_VAR 0 7
17069: PUSH
17070: LD_VAR 0 9
17074: PUSH
17075: EMPTY
17076: LIST
17077: LIST
17078: PPUSH
17079: CALL_OW 2
17083: ST_TO_ADDR
17084: GO 17166
// for j = 1 to result do
17086: LD_ADDR_VAR 0 8
17090: PUSH
17091: DOUBLE
17092: LD_INT 1
17094: DEC
17095: ST_TO_ADDR
17096: LD_VAR 0 6
17100: PUSH
17101: FOR_TO
17102: IFFALSE 17164
// begin if tmp < result [ j ] [ 2 ] then
17104: LD_VAR 0 9
17108: PUSH
17109: LD_VAR 0 6
17113: PUSH
17114: LD_VAR 0 8
17118: ARRAY
17119: PUSH
17120: LD_INT 2
17122: ARRAY
17123: LESS
17124: IFFALSE 17162
// begin result := Insert ( result , j , [ i , tmp ] ) ;
17126: LD_ADDR_VAR 0 6
17130: PUSH
17131: LD_VAR 0 6
17135: PPUSH
17136: LD_VAR 0 8
17140: PPUSH
17141: LD_VAR 0 7
17145: PUSH
17146: LD_VAR 0 9
17150: PUSH
17151: EMPTY
17152: LIST
17153: LIST
17154: PPUSH
17155: CALL_OW 2
17159: ST_TO_ADDR
// break ;
17160: GO 17164
// end ; end ;
17162: GO 17101
17164: POP
17165: POP
// end ; end ;
17166: GO 16965
17168: POP
17169: POP
// if result and not asc then
17170: LD_VAR 0 6
17174: PUSH
17175: LD_VAR 0 4
17179: NOT
17180: AND
17181: IFFALSE 17256
// begin tmp := result ;
17183: LD_ADDR_VAR 0 9
17187: PUSH
17188: LD_VAR 0 6
17192: ST_TO_ADDR
// for i = tmp downto 1 do
17193: LD_ADDR_VAR 0 7
17197: PUSH
17198: DOUBLE
17199: LD_VAR 0 9
17203: INC
17204: ST_TO_ADDR
17205: LD_INT 1
17207: PUSH
17208: FOR_DOWNTO
17209: IFFALSE 17254
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
17211: LD_ADDR_VAR 0 6
17215: PUSH
17216: LD_VAR 0 6
17220: PPUSH
17221: LD_VAR 0 9
17225: PUSH
17226: LD_VAR 0 7
17230: MINUS
17231: PUSH
17232: LD_INT 1
17234: PLUS
17235: PPUSH
17236: LD_VAR 0 9
17240: PUSH
17241: LD_VAR 0 7
17245: ARRAY
17246: PPUSH
17247: CALL_OW 1
17251: ST_TO_ADDR
17252: GO 17208
17254: POP
17255: POP
// end ; tmp := [ ] ;
17256: LD_ADDR_VAR 0 9
17260: PUSH
17261: EMPTY
17262: ST_TO_ADDR
// if mode then
17263: LD_VAR 0 5
17267: IFFALSE 17336
// begin for i = 1 to result do
17269: LD_ADDR_VAR 0 7
17273: PUSH
17274: DOUBLE
17275: LD_INT 1
17277: DEC
17278: ST_TO_ADDR
17279: LD_VAR 0 6
17283: PUSH
17284: FOR_TO
17285: IFFALSE 17324
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
17287: LD_ADDR_VAR 0 9
17291: PUSH
17292: LD_VAR 0 9
17296: PPUSH
17297: LD_VAR 0 7
17301: PPUSH
17302: LD_VAR 0 6
17306: PUSH
17307: LD_VAR 0 7
17311: ARRAY
17312: PUSH
17313: LD_INT 1
17315: ARRAY
17316: PPUSH
17317: CALL_OW 1
17321: ST_TO_ADDR
17322: GO 17284
17324: POP
17325: POP
// result := tmp ;
17326: LD_ADDR_VAR 0 6
17330: PUSH
17331: LD_VAR 0 9
17335: ST_TO_ADDR
// end ; end ;
17336: LD_VAR 0 6
17340: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
17341: LD_INT 0
17343: PPUSH
17344: PPUSH
17345: PPUSH
17346: PPUSH
17347: PPUSH
17348: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
17349: LD_ADDR_VAR 0 5
17353: PUSH
17354: LD_INT 0
17356: PUSH
17357: LD_INT 0
17359: PUSH
17360: LD_INT 0
17362: PUSH
17363: EMPTY
17364: PUSH
17365: EMPTY
17366: LIST
17367: LIST
17368: LIST
17369: LIST
17370: ST_TO_ADDR
// if not x or not y then
17371: LD_VAR 0 2
17375: NOT
17376: PUSH
17377: LD_VAR 0 3
17381: NOT
17382: OR
17383: IFFALSE 17387
// exit ;
17385: GO 19037
// if not range then
17387: LD_VAR 0 4
17391: NOT
17392: IFFALSE 17402
// range := 10 ;
17394: LD_ADDR_VAR 0 4
17398: PUSH
17399: LD_INT 10
17401: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
17402: LD_ADDR_VAR 0 8
17406: PUSH
17407: LD_INT 81
17409: PUSH
17410: LD_VAR 0 1
17414: PUSH
17415: EMPTY
17416: LIST
17417: LIST
17418: PUSH
17419: LD_INT 92
17421: PUSH
17422: LD_VAR 0 2
17426: PUSH
17427: LD_VAR 0 3
17431: PUSH
17432: LD_VAR 0 4
17436: PUSH
17437: EMPTY
17438: LIST
17439: LIST
17440: LIST
17441: LIST
17442: PUSH
17443: LD_INT 3
17445: PUSH
17446: LD_INT 21
17448: PUSH
17449: LD_INT 3
17451: PUSH
17452: EMPTY
17453: LIST
17454: LIST
17455: PUSH
17456: EMPTY
17457: LIST
17458: LIST
17459: PUSH
17460: EMPTY
17461: LIST
17462: LIST
17463: LIST
17464: PPUSH
17465: CALL_OW 69
17469: ST_TO_ADDR
// if not tmp then
17470: LD_VAR 0 8
17474: NOT
17475: IFFALSE 17479
// exit ;
17477: GO 19037
// for i in tmp do
17479: LD_ADDR_VAR 0 6
17483: PUSH
17484: LD_VAR 0 8
17488: PUSH
17489: FOR_IN
17490: IFFALSE 19012
// begin points := [ 0 , 0 , 0 ] ;
17492: LD_ADDR_VAR 0 9
17496: PUSH
17497: LD_INT 0
17499: PUSH
17500: LD_INT 0
17502: PUSH
17503: LD_INT 0
17505: PUSH
17506: EMPTY
17507: LIST
17508: LIST
17509: LIST
17510: ST_TO_ADDR
// bpoints := 1 ;
17511: LD_ADDR_VAR 0 10
17515: PUSH
17516: LD_INT 1
17518: ST_TO_ADDR
// case GetType ( i ) of unit_human :
17519: LD_VAR 0 6
17523: PPUSH
17524: CALL_OW 247
17528: PUSH
17529: LD_INT 1
17531: DOUBLE
17532: EQUAL
17533: IFTRUE 17537
17535: GO 18115
17537: POP
// begin if GetClass ( i ) = 1 then
17538: LD_VAR 0 6
17542: PPUSH
17543: CALL_OW 257
17547: PUSH
17548: LD_INT 1
17550: EQUAL
17551: IFFALSE 17572
// points := [ 10 , 5 , 3 ] ;
17553: LD_ADDR_VAR 0 9
17557: PUSH
17558: LD_INT 10
17560: PUSH
17561: LD_INT 5
17563: PUSH
17564: LD_INT 3
17566: PUSH
17567: EMPTY
17568: LIST
17569: LIST
17570: LIST
17571: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
17572: LD_VAR 0 6
17576: PPUSH
17577: CALL_OW 257
17581: PUSH
17582: LD_INT 2
17584: PUSH
17585: LD_INT 3
17587: PUSH
17588: LD_INT 4
17590: PUSH
17591: EMPTY
17592: LIST
17593: LIST
17594: LIST
17595: IN
17596: IFFALSE 17617
// points := [ 3 , 2 , 1 ] ;
17598: LD_ADDR_VAR 0 9
17602: PUSH
17603: LD_INT 3
17605: PUSH
17606: LD_INT 2
17608: PUSH
17609: LD_INT 1
17611: PUSH
17612: EMPTY
17613: LIST
17614: LIST
17615: LIST
17616: ST_TO_ADDR
// if GetClass ( i ) = 5 then
17617: LD_VAR 0 6
17621: PPUSH
17622: CALL_OW 257
17626: PUSH
17627: LD_INT 5
17629: EQUAL
17630: IFFALSE 17651
// points := [ 130 , 5 , 2 ] ;
17632: LD_ADDR_VAR 0 9
17636: PUSH
17637: LD_INT 130
17639: PUSH
17640: LD_INT 5
17642: PUSH
17643: LD_INT 2
17645: PUSH
17646: EMPTY
17647: LIST
17648: LIST
17649: LIST
17650: ST_TO_ADDR
// if GetClass ( i ) = 8 then
17651: LD_VAR 0 6
17655: PPUSH
17656: CALL_OW 257
17660: PUSH
17661: LD_INT 8
17663: EQUAL
17664: IFFALSE 17685
// points := [ 35 , 35 , 30 ] ;
17666: LD_ADDR_VAR 0 9
17670: PUSH
17671: LD_INT 35
17673: PUSH
17674: LD_INT 35
17676: PUSH
17677: LD_INT 30
17679: PUSH
17680: EMPTY
17681: LIST
17682: LIST
17683: LIST
17684: ST_TO_ADDR
// if GetClass ( i ) = 9 then
17685: LD_VAR 0 6
17689: PPUSH
17690: CALL_OW 257
17694: PUSH
17695: LD_INT 9
17697: EQUAL
17698: IFFALSE 17719
// points := [ 20 , 55 , 40 ] ;
17700: LD_ADDR_VAR 0 9
17704: PUSH
17705: LD_INT 20
17707: PUSH
17708: LD_INT 55
17710: PUSH
17711: LD_INT 40
17713: PUSH
17714: EMPTY
17715: LIST
17716: LIST
17717: LIST
17718: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
17719: LD_VAR 0 6
17723: PPUSH
17724: CALL_OW 257
17728: PUSH
17729: LD_INT 12
17731: PUSH
17732: LD_INT 16
17734: PUSH
17735: EMPTY
17736: LIST
17737: LIST
17738: IN
17739: IFFALSE 17760
// points := [ 5 , 3 , 2 ] ;
17741: LD_ADDR_VAR 0 9
17745: PUSH
17746: LD_INT 5
17748: PUSH
17749: LD_INT 3
17751: PUSH
17752: LD_INT 2
17754: PUSH
17755: EMPTY
17756: LIST
17757: LIST
17758: LIST
17759: ST_TO_ADDR
// if GetClass ( i ) = 17 then
17760: LD_VAR 0 6
17764: PPUSH
17765: CALL_OW 257
17769: PUSH
17770: LD_INT 17
17772: EQUAL
17773: IFFALSE 17794
// points := [ 100 , 50 , 75 ] ;
17775: LD_ADDR_VAR 0 9
17779: PUSH
17780: LD_INT 100
17782: PUSH
17783: LD_INT 50
17785: PUSH
17786: LD_INT 75
17788: PUSH
17789: EMPTY
17790: LIST
17791: LIST
17792: LIST
17793: ST_TO_ADDR
// if GetClass ( i ) = 15 then
17794: LD_VAR 0 6
17798: PPUSH
17799: CALL_OW 257
17803: PUSH
17804: LD_INT 15
17806: EQUAL
17807: IFFALSE 17828
// points := [ 10 , 5 , 3 ] ;
17809: LD_ADDR_VAR 0 9
17813: PUSH
17814: LD_INT 10
17816: PUSH
17817: LD_INT 5
17819: PUSH
17820: LD_INT 3
17822: PUSH
17823: EMPTY
17824: LIST
17825: LIST
17826: LIST
17827: ST_TO_ADDR
// if GetClass ( i ) = 14 then
17828: LD_VAR 0 6
17832: PPUSH
17833: CALL_OW 257
17837: PUSH
17838: LD_INT 14
17840: EQUAL
17841: IFFALSE 17862
// points := [ 10 , 0 , 0 ] ;
17843: LD_ADDR_VAR 0 9
17847: PUSH
17848: LD_INT 10
17850: PUSH
17851: LD_INT 0
17853: PUSH
17854: LD_INT 0
17856: PUSH
17857: EMPTY
17858: LIST
17859: LIST
17860: LIST
17861: ST_TO_ADDR
// if GetClass ( i ) = 11 then
17862: LD_VAR 0 6
17866: PPUSH
17867: CALL_OW 257
17871: PUSH
17872: LD_INT 11
17874: EQUAL
17875: IFFALSE 17896
// points := [ 30 , 10 , 5 ] ;
17877: LD_ADDR_VAR 0 9
17881: PUSH
17882: LD_INT 30
17884: PUSH
17885: LD_INT 10
17887: PUSH
17888: LD_INT 5
17890: PUSH
17891: EMPTY
17892: LIST
17893: LIST
17894: LIST
17895: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
17896: LD_VAR 0 1
17900: PPUSH
17901: LD_INT 5
17903: PPUSH
17904: CALL_OW 321
17908: PUSH
17909: LD_INT 2
17911: EQUAL
17912: IFFALSE 17929
// bpoints := bpoints * 1.8 ;
17914: LD_ADDR_VAR 0 10
17918: PUSH
17919: LD_VAR 0 10
17923: PUSH
17924: LD_REAL  1.80000000000000E+0000
17927: MUL
17928: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
17929: LD_VAR 0 6
17933: PPUSH
17934: CALL_OW 257
17938: PUSH
17939: LD_INT 1
17941: PUSH
17942: LD_INT 2
17944: PUSH
17945: LD_INT 3
17947: PUSH
17948: LD_INT 4
17950: PUSH
17951: EMPTY
17952: LIST
17953: LIST
17954: LIST
17955: LIST
17956: IN
17957: PUSH
17958: LD_VAR 0 1
17962: PPUSH
17963: LD_INT 51
17965: PPUSH
17966: CALL_OW 321
17970: PUSH
17971: LD_INT 2
17973: EQUAL
17974: AND
17975: IFFALSE 17992
// bpoints := bpoints * 1.2 ;
17977: LD_ADDR_VAR 0 10
17981: PUSH
17982: LD_VAR 0 10
17986: PUSH
17987: LD_REAL  1.20000000000000E+0000
17990: MUL
17991: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
17992: LD_VAR 0 6
17996: PPUSH
17997: CALL_OW 257
18001: PUSH
18002: LD_INT 5
18004: PUSH
18005: LD_INT 7
18007: PUSH
18008: LD_INT 9
18010: PUSH
18011: EMPTY
18012: LIST
18013: LIST
18014: LIST
18015: IN
18016: PUSH
18017: LD_VAR 0 1
18021: PPUSH
18022: LD_INT 52
18024: PPUSH
18025: CALL_OW 321
18029: PUSH
18030: LD_INT 2
18032: EQUAL
18033: AND
18034: IFFALSE 18051
// bpoints := bpoints * 1.5 ;
18036: LD_ADDR_VAR 0 10
18040: PUSH
18041: LD_VAR 0 10
18045: PUSH
18046: LD_REAL  1.50000000000000E+0000
18049: MUL
18050: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
18051: LD_VAR 0 1
18055: PPUSH
18056: LD_INT 66
18058: PPUSH
18059: CALL_OW 321
18063: PUSH
18064: LD_INT 2
18066: EQUAL
18067: IFFALSE 18084
// bpoints := bpoints * 1.1 ;
18069: LD_ADDR_VAR 0 10
18073: PUSH
18074: LD_VAR 0 10
18078: PUSH
18079: LD_REAL  1.10000000000000E+0000
18082: MUL
18083: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
18084: LD_ADDR_VAR 0 10
18088: PUSH
18089: LD_VAR 0 10
18093: PUSH
18094: LD_VAR 0 6
18098: PPUSH
18099: LD_INT 1
18101: PPUSH
18102: CALL_OW 259
18106: PUSH
18107: LD_REAL  1.15000000000000E+0000
18110: MUL
18111: MUL
18112: ST_TO_ADDR
// end ; unit_vehicle :
18113: GO 18941
18115: LD_INT 2
18117: DOUBLE
18118: EQUAL
18119: IFTRUE 18123
18121: GO 18929
18123: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
18124: LD_VAR 0 6
18128: PPUSH
18129: CALL_OW 264
18133: PUSH
18134: LD_INT 2
18136: PUSH
18137: LD_INT 42
18139: PUSH
18140: LD_INT 24
18142: PUSH
18143: EMPTY
18144: LIST
18145: LIST
18146: LIST
18147: IN
18148: IFFALSE 18169
// points := [ 25 , 5 , 3 ] ;
18150: LD_ADDR_VAR 0 9
18154: PUSH
18155: LD_INT 25
18157: PUSH
18158: LD_INT 5
18160: PUSH
18161: LD_INT 3
18163: PUSH
18164: EMPTY
18165: LIST
18166: LIST
18167: LIST
18168: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
18169: LD_VAR 0 6
18173: PPUSH
18174: CALL_OW 264
18178: PUSH
18179: LD_INT 4
18181: PUSH
18182: LD_INT 43
18184: PUSH
18185: LD_INT 25
18187: PUSH
18188: EMPTY
18189: LIST
18190: LIST
18191: LIST
18192: IN
18193: IFFALSE 18214
// points := [ 40 , 15 , 5 ] ;
18195: LD_ADDR_VAR 0 9
18199: PUSH
18200: LD_INT 40
18202: PUSH
18203: LD_INT 15
18205: PUSH
18206: LD_INT 5
18208: PUSH
18209: EMPTY
18210: LIST
18211: LIST
18212: LIST
18213: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
18214: LD_VAR 0 6
18218: PPUSH
18219: CALL_OW 264
18223: PUSH
18224: LD_INT 3
18226: PUSH
18227: LD_INT 23
18229: PUSH
18230: EMPTY
18231: LIST
18232: LIST
18233: IN
18234: IFFALSE 18255
// points := [ 7 , 25 , 8 ] ;
18236: LD_ADDR_VAR 0 9
18240: PUSH
18241: LD_INT 7
18243: PUSH
18244: LD_INT 25
18246: PUSH
18247: LD_INT 8
18249: PUSH
18250: EMPTY
18251: LIST
18252: LIST
18253: LIST
18254: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
18255: LD_VAR 0 6
18259: PPUSH
18260: CALL_OW 264
18264: PUSH
18265: LD_INT 5
18267: PUSH
18268: LD_INT 27
18270: PUSH
18271: LD_INT 44
18273: PUSH
18274: EMPTY
18275: LIST
18276: LIST
18277: LIST
18278: IN
18279: IFFALSE 18300
// points := [ 14 , 50 , 16 ] ;
18281: LD_ADDR_VAR 0 9
18285: PUSH
18286: LD_INT 14
18288: PUSH
18289: LD_INT 50
18291: PUSH
18292: LD_INT 16
18294: PUSH
18295: EMPTY
18296: LIST
18297: LIST
18298: LIST
18299: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
18300: LD_VAR 0 6
18304: PPUSH
18305: CALL_OW 264
18309: PUSH
18310: LD_INT 6
18312: PUSH
18313: LD_INT 46
18315: PUSH
18316: EMPTY
18317: LIST
18318: LIST
18319: IN
18320: IFFALSE 18341
// points := [ 32 , 120 , 70 ] ;
18322: LD_ADDR_VAR 0 9
18326: PUSH
18327: LD_INT 32
18329: PUSH
18330: LD_INT 120
18332: PUSH
18333: LD_INT 70
18335: PUSH
18336: EMPTY
18337: LIST
18338: LIST
18339: LIST
18340: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
18341: LD_VAR 0 6
18345: PPUSH
18346: CALL_OW 264
18350: PUSH
18351: LD_INT 7
18353: PUSH
18354: LD_INT 28
18356: PUSH
18357: LD_INT 45
18359: PUSH
18360: LD_INT 92
18362: PUSH
18363: EMPTY
18364: LIST
18365: LIST
18366: LIST
18367: LIST
18368: IN
18369: IFFALSE 18390
// points := [ 35 , 20 , 45 ] ;
18371: LD_ADDR_VAR 0 9
18375: PUSH
18376: LD_INT 35
18378: PUSH
18379: LD_INT 20
18381: PUSH
18382: LD_INT 45
18384: PUSH
18385: EMPTY
18386: LIST
18387: LIST
18388: LIST
18389: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
18390: LD_VAR 0 6
18394: PPUSH
18395: CALL_OW 264
18399: PUSH
18400: LD_INT 47
18402: PUSH
18403: EMPTY
18404: LIST
18405: IN
18406: IFFALSE 18427
// points := [ 67 , 45 , 75 ] ;
18408: LD_ADDR_VAR 0 9
18412: PUSH
18413: LD_INT 67
18415: PUSH
18416: LD_INT 45
18418: PUSH
18419: LD_INT 75
18421: PUSH
18422: EMPTY
18423: LIST
18424: LIST
18425: LIST
18426: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
18427: LD_VAR 0 6
18431: PPUSH
18432: CALL_OW 264
18436: PUSH
18437: LD_INT 26
18439: PUSH
18440: EMPTY
18441: LIST
18442: IN
18443: IFFALSE 18464
// points := [ 120 , 30 , 80 ] ;
18445: LD_ADDR_VAR 0 9
18449: PUSH
18450: LD_INT 120
18452: PUSH
18453: LD_INT 30
18455: PUSH
18456: LD_INT 80
18458: PUSH
18459: EMPTY
18460: LIST
18461: LIST
18462: LIST
18463: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
18464: LD_VAR 0 6
18468: PPUSH
18469: CALL_OW 264
18473: PUSH
18474: LD_INT 22
18476: PUSH
18477: EMPTY
18478: LIST
18479: IN
18480: IFFALSE 18501
// points := [ 40 , 1 , 1 ] ;
18482: LD_ADDR_VAR 0 9
18486: PUSH
18487: LD_INT 40
18489: PUSH
18490: LD_INT 1
18492: PUSH
18493: LD_INT 1
18495: PUSH
18496: EMPTY
18497: LIST
18498: LIST
18499: LIST
18500: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
18501: LD_VAR 0 6
18505: PPUSH
18506: CALL_OW 264
18510: PUSH
18511: LD_INT 29
18513: PUSH
18514: EMPTY
18515: LIST
18516: IN
18517: IFFALSE 18538
// points := [ 70 , 200 , 400 ] ;
18519: LD_ADDR_VAR 0 9
18523: PUSH
18524: LD_INT 70
18526: PUSH
18527: LD_INT 200
18529: PUSH
18530: LD_INT 400
18532: PUSH
18533: EMPTY
18534: LIST
18535: LIST
18536: LIST
18537: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
18538: LD_VAR 0 6
18542: PPUSH
18543: CALL_OW 264
18547: PUSH
18548: LD_INT 14
18550: PUSH
18551: LD_INT 53
18553: PUSH
18554: EMPTY
18555: LIST
18556: LIST
18557: IN
18558: IFFALSE 18579
// points := [ 40 , 10 , 20 ] ;
18560: LD_ADDR_VAR 0 9
18564: PUSH
18565: LD_INT 40
18567: PUSH
18568: LD_INT 10
18570: PUSH
18571: LD_INT 20
18573: PUSH
18574: EMPTY
18575: LIST
18576: LIST
18577: LIST
18578: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
18579: LD_VAR 0 6
18583: PPUSH
18584: CALL_OW 264
18588: PUSH
18589: LD_INT 9
18591: PUSH
18592: EMPTY
18593: LIST
18594: IN
18595: IFFALSE 18616
// points := [ 5 , 70 , 20 ] ;
18597: LD_ADDR_VAR 0 9
18601: PUSH
18602: LD_INT 5
18604: PUSH
18605: LD_INT 70
18607: PUSH
18608: LD_INT 20
18610: PUSH
18611: EMPTY
18612: LIST
18613: LIST
18614: LIST
18615: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
18616: LD_VAR 0 6
18620: PPUSH
18621: CALL_OW 264
18625: PUSH
18626: LD_INT 10
18628: PUSH
18629: EMPTY
18630: LIST
18631: IN
18632: IFFALSE 18653
// points := [ 35 , 110 , 70 ] ;
18634: LD_ADDR_VAR 0 9
18638: PUSH
18639: LD_INT 35
18641: PUSH
18642: LD_INT 110
18644: PUSH
18645: LD_INT 70
18647: PUSH
18648: EMPTY
18649: LIST
18650: LIST
18651: LIST
18652: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
18653: LD_VAR 0 6
18657: PPUSH
18658: CALL_OW 265
18662: PUSH
18663: LD_INT 25
18665: EQUAL
18666: IFFALSE 18687
// points := [ 80 , 65 , 100 ] ;
18668: LD_ADDR_VAR 0 9
18672: PUSH
18673: LD_INT 80
18675: PUSH
18676: LD_INT 65
18678: PUSH
18679: LD_INT 100
18681: PUSH
18682: EMPTY
18683: LIST
18684: LIST
18685: LIST
18686: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
18687: LD_VAR 0 6
18691: PPUSH
18692: CALL_OW 263
18696: PUSH
18697: LD_INT 1
18699: EQUAL
18700: IFFALSE 18735
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
18702: LD_ADDR_VAR 0 10
18706: PUSH
18707: LD_VAR 0 10
18711: PUSH
18712: LD_VAR 0 6
18716: PPUSH
18717: CALL_OW 311
18721: PPUSH
18722: LD_INT 3
18724: PPUSH
18725: CALL_OW 259
18729: PUSH
18730: LD_INT 4
18732: MUL
18733: MUL
18734: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
18735: LD_VAR 0 6
18739: PPUSH
18740: CALL_OW 263
18744: PUSH
18745: LD_INT 2
18747: EQUAL
18748: IFFALSE 18799
// begin j := IsControledBy ( i ) ;
18750: LD_ADDR_VAR 0 7
18754: PUSH
18755: LD_VAR 0 6
18759: PPUSH
18760: CALL_OW 312
18764: ST_TO_ADDR
// if j then
18765: LD_VAR 0 7
18769: IFFALSE 18799
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
18771: LD_ADDR_VAR 0 10
18775: PUSH
18776: LD_VAR 0 10
18780: PUSH
18781: LD_VAR 0 7
18785: PPUSH
18786: LD_INT 3
18788: PPUSH
18789: CALL_OW 259
18793: PUSH
18794: LD_INT 3
18796: MUL
18797: MUL
18798: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
18799: LD_VAR 0 6
18803: PPUSH
18804: CALL_OW 264
18808: PUSH
18809: LD_INT 5
18811: PUSH
18812: LD_INT 6
18814: PUSH
18815: LD_INT 46
18817: PUSH
18818: LD_INT 44
18820: PUSH
18821: LD_INT 47
18823: PUSH
18824: LD_INT 45
18826: PUSH
18827: LD_INT 28
18829: PUSH
18830: LD_INT 7
18832: PUSH
18833: LD_INT 27
18835: PUSH
18836: LD_INT 29
18838: PUSH
18839: EMPTY
18840: LIST
18841: LIST
18842: LIST
18843: LIST
18844: LIST
18845: LIST
18846: LIST
18847: LIST
18848: LIST
18849: LIST
18850: IN
18851: PUSH
18852: LD_VAR 0 1
18856: PPUSH
18857: LD_INT 52
18859: PPUSH
18860: CALL_OW 321
18864: PUSH
18865: LD_INT 2
18867: EQUAL
18868: AND
18869: IFFALSE 18886
// bpoints := bpoints * 1.2 ;
18871: LD_ADDR_VAR 0 10
18875: PUSH
18876: LD_VAR 0 10
18880: PUSH
18881: LD_REAL  1.20000000000000E+0000
18884: MUL
18885: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
18886: LD_VAR 0 6
18890: PPUSH
18891: CALL_OW 264
18895: PUSH
18896: LD_INT 6
18898: PUSH
18899: LD_INT 46
18901: PUSH
18902: LD_INT 47
18904: PUSH
18905: EMPTY
18906: LIST
18907: LIST
18908: LIST
18909: IN
18910: IFFALSE 18927
// bpoints := bpoints * 1.2 ;
18912: LD_ADDR_VAR 0 10
18916: PUSH
18917: LD_VAR 0 10
18921: PUSH
18922: LD_REAL  1.20000000000000E+0000
18925: MUL
18926: ST_TO_ADDR
// end ; unit_building :
18927: GO 18941
18929: LD_INT 3
18931: DOUBLE
18932: EQUAL
18933: IFTRUE 18937
18935: GO 18940
18937: POP
// ; end ;
18938: GO 18941
18940: POP
// for j = 1 to 3 do
18941: LD_ADDR_VAR 0 7
18945: PUSH
18946: DOUBLE
18947: LD_INT 1
18949: DEC
18950: ST_TO_ADDR
18951: LD_INT 3
18953: PUSH
18954: FOR_TO
18955: IFFALSE 19008
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
18957: LD_ADDR_VAR 0 5
18961: PUSH
18962: LD_VAR 0 5
18966: PPUSH
18967: LD_VAR 0 7
18971: PPUSH
18972: LD_VAR 0 5
18976: PUSH
18977: LD_VAR 0 7
18981: ARRAY
18982: PUSH
18983: LD_VAR 0 9
18987: PUSH
18988: LD_VAR 0 7
18992: ARRAY
18993: PUSH
18994: LD_VAR 0 10
18998: MUL
18999: PLUS
19000: PPUSH
19001: CALL_OW 1
19005: ST_TO_ADDR
19006: GO 18954
19008: POP
19009: POP
// end ;
19010: GO 17489
19012: POP
19013: POP
// result := Replace ( result , 4 , tmp ) ;
19014: LD_ADDR_VAR 0 5
19018: PUSH
19019: LD_VAR 0 5
19023: PPUSH
19024: LD_INT 4
19026: PPUSH
19027: LD_VAR 0 8
19031: PPUSH
19032: CALL_OW 1
19036: ST_TO_ADDR
// end ;
19037: LD_VAR 0 5
19041: RET
// export function DangerAtRange ( unit , range ) ; begin
19042: LD_INT 0
19044: PPUSH
// if not unit then
19045: LD_VAR 0 1
19049: NOT
19050: IFFALSE 19054
// exit ;
19052: GO 19099
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
19054: LD_ADDR_VAR 0 3
19058: PUSH
19059: LD_VAR 0 1
19063: PPUSH
19064: CALL_OW 255
19068: PPUSH
19069: LD_VAR 0 1
19073: PPUSH
19074: CALL_OW 250
19078: PPUSH
19079: LD_VAR 0 1
19083: PPUSH
19084: CALL_OW 251
19088: PPUSH
19089: LD_VAR 0 2
19093: PPUSH
19094: CALL 17341 0 4
19098: ST_TO_ADDR
// end ;
19099: LD_VAR 0 3
19103: RET
// export function DangerInArea ( side , area ) ; begin
19104: LD_INT 0
19106: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
19107: LD_ADDR_VAR 0 3
19111: PUSH
19112: LD_VAR 0 2
19116: PPUSH
19117: LD_INT 81
19119: PUSH
19120: LD_VAR 0 1
19124: PUSH
19125: EMPTY
19126: LIST
19127: LIST
19128: PPUSH
19129: CALL_OW 70
19133: ST_TO_ADDR
// end ;
19134: LD_VAR 0 3
19138: RET
// export function IsExtension ( b ) ; begin
19139: LD_INT 0
19141: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
19142: LD_ADDR_VAR 0 2
19146: PUSH
19147: LD_VAR 0 1
19151: PUSH
19152: LD_INT 23
19154: PUSH
19155: LD_INT 20
19157: PUSH
19158: LD_INT 22
19160: PUSH
19161: LD_INT 17
19163: PUSH
19164: LD_INT 24
19166: PUSH
19167: LD_INT 21
19169: PUSH
19170: LD_INT 19
19172: PUSH
19173: LD_INT 16
19175: PUSH
19176: LD_INT 25
19178: PUSH
19179: LD_INT 18
19181: PUSH
19182: EMPTY
19183: LIST
19184: LIST
19185: LIST
19186: LIST
19187: LIST
19188: LIST
19189: LIST
19190: LIST
19191: LIST
19192: LIST
19193: IN
19194: ST_TO_ADDR
// end ;
19195: LD_VAR 0 2
19199: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
19200: LD_INT 0
19202: PPUSH
19203: PPUSH
19204: PPUSH
// result := [ ] ;
19205: LD_ADDR_VAR 0 4
19209: PUSH
19210: EMPTY
19211: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
19212: LD_ADDR_VAR 0 5
19216: PUSH
19217: LD_VAR 0 2
19221: PPUSH
19222: LD_INT 21
19224: PUSH
19225: LD_INT 3
19227: PUSH
19228: EMPTY
19229: LIST
19230: LIST
19231: PPUSH
19232: CALL_OW 70
19236: ST_TO_ADDR
// if not tmp then
19237: LD_VAR 0 5
19241: NOT
19242: IFFALSE 19246
// exit ;
19244: GO 19310
// if checkLink then
19246: LD_VAR 0 3
19250: IFFALSE 19300
// begin for i in tmp do
19252: LD_ADDR_VAR 0 6
19256: PUSH
19257: LD_VAR 0 5
19261: PUSH
19262: FOR_IN
19263: IFFALSE 19298
// if GetBase ( i ) <> base then
19265: LD_VAR 0 6
19269: PPUSH
19270: CALL_OW 274
19274: PUSH
19275: LD_VAR 0 1
19279: NONEQUAL
19280: IFFALSE 19296
// ComLinkToBase ( base , i ) ;
19282: LD_VAR 0 1
19286: PPUSH
19287: LD_VAR 0 6
19291: PPUSH
19292: CALL_OW 169
19296: GO 19262
19298: POP
19299: POP
// end ; result := tmp ;
19300: LD_ADDR_VAR 0 4
19304: PUSH
19305: LD_VAR 0 5
19309: ST_TO_ADDR
// end ;
19310: LD_VAR 0 4
19314: RET
// export function ComComplete ( units , b ) ; var i ; begin
19315: LD_INT 0
19317: PPUSH
19318: PPUSH
// if not units then
19319: LD_VAR 0 1
19323: NOT
19324: IFFALSE 19328
// exit ;
19326: GO 19418
// for i in units do
19328: LD_ADDR_VAR 0 4
19332: PUSH
19333: LD_VAR 0 1
19337: PUSH
19338: FOR_IN
19339: IFFALSE 19416
// if BuildingStatus ( b ) = bs_build then
19341: LD_VAR 0 2
19345: PPUSH
19346: CALL_OW 461
19350: PUSH
19351: LD_INT 1
19353: EQUAL
19354: IFFALSE 19414
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
19356: LD_VAR 0 4
19360: PPUSH
19361: LD_STRING h
19363: PUSH
19364: LD_VAR 0 2
19368: PPUSH
19369: CALL_OW 250
19373: PUSH
19374: LD_VAR 0 2
19378: PPUSH
19379: CALL_OW 251
19383: PUSH
19384: LD_VAR 0 2
19388: PUSH
19389: LD_INT 0
19391: PUSH
19392: LD_INT 0
19394: PUSH
19395: LD_INT 0
19397: PUSH
19398: EMPTY
19399: LIST
19400: LIST
19401: LIST
19402: LIST
19403: LIST
19404: LIST
19405: LIST
19406: PUSH
19407: EMPTY
19408: LIST
19409: PPUSH
19410: CALL_OW 446
19414: GO 19338
19416: POP
19417: POP
// end ;
19418: LD_VAR 0 3
19422: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
19423: LD_INT 0
19425: PPUSH
19426: PPUSH
19427: PPUSH
19428: PPUSH
19429: PPUSH
19430: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
19431: LD_VAR 0 1
19435: NOT
19436: PUSH
19437: LD_VAR 0 1
19441: PPUSH
19442: CALL_OW 263
19446: PUSH
19447: LD_INT 2
19449: NONEQUAL
19450: OR
19451: IFFALSE 19455
// exit ;
19453: GO 19771
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
19455: LD_ADDR_VAR 0 6
19459: PUSH
19460: LD_INT 22
19462: PUSH
19463: LD_VAR 0 1
19467: PPUSH
19468: CALL_OW 255
19472: PUSH
19473: EMPTY
19474: LIST
19475: LIST
19476: PUSH
19477: LD_INT 2
19479: PUSH
19480: LD_INT 30
19482: PUSH
19483: LD_INT 36
19485: PUSH
19486: EMPTY
19487: LIST
19488: LIST
19489: PUSH
19490: LD_INT 34
19492: PUSH
19493: LD_INT 31
19495: PUSH
19496: EMPTY
19497: LIST
19498: LIST
19499: PUSH
19500: EMPTY
19501: LIST
19502: LIST
19503: LIST
19504: PUSH
19505: EMPTY
19506: LIST
19507: LIST
19508: PPUSH
19509: CALL_OW 69
19513: ST_TO_ADDR
// if not tmp then
19514: LD_VAR 0 6
19518: NOT
19519: IFFALSE 19523
// exit ;
19521: GO 19771
// result := [ ] ;
19523: LD_ADDR_VAR 0 2
19527: PUSH
19528: EMPTY
19529: ST_TO_ADDR
// for i in tmp do
19530: LD_ADDR_VAR 0 3
19534: PUSH
19535: LD_VAR 0 6
19539: PUSH
19540: FOR_IN
19541: IFFALSE 19612
// begin t := UnitsInside ( i ) ;
19543: LD_ADDR_VAR 0 4
19547: PUSH
19548: LD_VAR 0 3
19552: PPUSH
19553: CALL_OW 313
19557: ST_TO_ADDR
// if t then
19558: LD_VAR 0 4
19562: IFFALSE 19610
// for j in t do
19564: LD_ADDR_VAR 0 7
19568: PUSH
19569: LD_VAR 0 4
19573: PUSH
19574: FOR_IN
19575: IFFALSE 19608
// result := Replace ( result , result + 1 , j ) ;
19577: LD_ADDR_VAR 0 2
19581: PUSH
19582: LD_VAR 0 2
19586: PPUSH
19587: LD_VAR 0 2
19591: PUSH
19592: LD_INT 1
19594: PLUS
19595: PPUSH
19596: LD_VAR 0 7
19600: PPUSH
19601: CALL_OW 1
19605: ST_TO_ADDR
19606: GO 19574
19608: POP
19609: POP
// end ;
19610: GO 19540
19612: POP
19613: POP
// if not result then
19614: LD_VAR 0 2
19618: NOT
19619: IFFALSE 19623
// exit ;
19621: GO 19771
// mech := result [ 1 ] ;
19623: LD_ADDR_VAR 0 5
19627: PUSH
19628: LD_VAR 0 2
19632: PUSH
19633: LD_INT 1
19635: ARRAY
19636: ST_TO_ADDR
// if result > 1 then
19637: LD_VAR 0 2
19641: PUSH
19642: LD_INT 1
19644: GREATER
19645: IFFALSE 19757
// begin for i = 2 to result do
19647: LD_ADDR_VAR 0 3
19651: PUSH
19652: DOUBLE
19653: LD_INT 2
19655: DEC
19656: ST_TO_ADDR
19657: LD_VAR 0 2
19661: PUSH
19662: FOR_TO
19663: IFFALSE 19755
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
19665: LD_ADDR_VAR 0 4
19669: PUSH
19670: LD_VAR 0 2
19674: PUSH
19675: LD_VAR 0 3
19679: ARRAY
19680: PPUSH
19681: LD_INT 3
19683: PPUSH
19684: CALL_OW 259
19688: PUSH
19689: LD_VAR 0 2
19693: PUSH
19694: LD_VAR 0 3
19698: ARRAY
19699: PPUSH
19700: CALL_OW 432
19704: MINUS
19705: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
19706: LD_VAR 0 4
19710: PUSH
19711: LD_VAR 0 5
19715: PPUSH
19716: LD_INT 3
19718: PPUSH
19719: CALL_OW 259
19723: PUSH
19724: LD_VAR 0 5
19728: PPUSH
19729: CALL_OW 432
19733: MINUS
19734: GREATEREQUAL
19735: IFFALSE 19753
// mech := result [ i ] ;
19737: LD_ADDR_VAR 0 5
19741: PUSH
19742: LD_VAR 0 2
19746: PUSH
19747: LD_VAR 0 3
19751: ARRAY
19752: ST_TO_ADDR
// end ;
19753: GO 19662
19755: POP
19756: POP
// end ; ComLinkTo ( vehicle , mech ) ;
19757: LD_VAR 0 1
19761: PPUSH
19762: LD_VAR 0 5
19766: PPUSH
19767: CALL_OW 135
// end ;
19771: LD_VAR 0 2
19775: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
19776: LD_INT 0
19778: PPUSH
19779: PPUSH
19780: PPUSH
19781: PPUSH
19782: PPUSH
19783: PPUSH
19784: PPUSH
19785: PPUSH
19786: PPUSH
19787: PPUSH
19788: PPUSH
19789: PPUSH
19790: PPUSH
// result := [ ] ;
19791: LD_ADDR_VAR 0 7
19795: PUSH
19796: EMPTY
19797: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
19798: LD_VAR 0 1
19802: PPUSH
19803: CALL_OW 266
19807: PUSH
19808: LD_INT 0
19810: PUSH
19811: LD_INT 1
19813: PUSH
19814: EMPTY
19815: LIST
19816: LIST
19817: IN
19818: NOT
19819: IFFALSE 19823
// exit ;
19821: GO 21457
// if name then
19823: LD_VAR 0 3
19827: IFFALSE 19843
// SetBName ( base_dep , name ) ;
19829: LD_VAR 0 1
19833: PPUSH
19834: LD_VAR 0 3
19838: PPUSH
19839: CALL_OW 500
// base := GetBase ( base_dep ) ;
19843: LD_ADDR_VAR 0 15
19847: PUSH
19848: LD_VAR 0 1
19852: PPUSH
19853: CALL_OW 274
19857: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
19858: LD_ADDR_VAR 0 16
19862: PUSH
19863: LD_VAR 0 1
19867: PPUSH
19868: CALL_OW 255
19872: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
19873: LD_ADDR_VAR 0 17
19877: PUSH
19878: LD_VAR 0 1
19882: PPUSH
19883: CALL_OW 248
19887: ST_TO_ADDR
// if sources then
19888: LD_VAR 0 5
19892: IFFALSE 19939
// for i = 1 to 3 do
19894: LD_ADDR_VAR 0 8
19898: PUSH
19899: DOUBLE
19900: LD_INT 1
19902: DEC
19903: ST_TO_ADDR
19904: LD_INT 3
19906: PUSH
19907: FOR_TO
19908: IFFALSE 19937
// AddResourceType ( base , i , sources [ i ] ) ;
19910: LD_VAR 0 15
19914: PPUSH
19915: LD_VAR 0 8
19919: PPUSH
19920: LD_VAR 0 5
19924: PUSH
19925: LD_VAR 0 8
19929: ARRAY
19930: PPUSH
19931: CALL_OW 276
19935: GO 19907
19937: POP
19938: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
19939: LD_ADDR_VAR 0 18
19943: PUSH
19944: LD_VAR 0 15
19948: PPUSH
19949: LD_VAR 0 2
19953: PPUSH
19954: LD_INT 1
19956: PPUSH
19957: CALL 19200 0 3
19961: ST_TO_ADDR
// InitHc ;
19962: CALL_OW 19
// InitUc ;
19966: CALL_OW 18
// uc_side := side ;
19970: LD_ADDR_OWVAR 20
19974: PUSH
19975: LD_VAR 0 16
19979: ST_TO_ADDR
// uc_nation := nation ;
19980: LD_ADDR_OWVAR 21
19984: PUSH
19985: LD_VAR 0 17
19989: ST_TO_ADDR
// if buildings then
19990: LD_VAR 0 18
19994: IFFALSE 21316
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
19996: LD_ADDR_VAR 0 19
20000: PUSH
20001: LD_VAR 0 18
20005: PPUSH
20006: LD_INT 2
20008: PUSH
20009: LD_INT 30
20011: PUSH
20012: LD_INT 29
20014: PUSH
20015: EMPTY
20016: LIST
20017: LIST
20018: PUSH
20019: LD_INT 30
20021: PUSH
20022: LD_INT 30
20024: PUSH
20025: EMPTY
20026: LIST
20027: LIST
20028: PUSH
20029: EMPTY
20030: LIST
20031: LIST
20032: LIST
20033: PPUSH
20034: CALL_OW 72
20038: ST_TO_ADDR
// if tmp then
20039: LD_VAR 0 19
20043: IFFALSE 20091
// for i in tmp do
20045: LD_ADDR_VAR 0 8
20049: PUSH
20050: LD_VAR 0 19
20054: PUSH
20055: FOR_IN
20056: IFFALSE 20089
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
20058: LD_VAR 0 8
20062: PPUSH
20063: CALL_OW 250
20067: PPUSH
20068: LD_VAR 0 8
20072: PPUSH
20073: CALL_OW 251
20077: PPUSH
20078: LD_VAR 0 16
20082: PPUSH
20083: CALL_OW 441
20087: GO 20055
20089: POP
20090: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
20091: LD_VAR 0 18
20095: PPUSH
20096: LD_INT 2
20098: PUSH
20099: LD_INT 30
20101: PUSH
20102: LD_INT 32
20104: PUSH
20105: EMPTY
20106: LIST
20107: LIST
20108: PUSH
20109: LD_INT 30
20111: PUSH
20112: LD_INT 33
20114: PUSH
20115: EMPTY
20116: LIST
20117: LIST
20118: PUSH
20119: EMPTY
20120: LIST
20121: LIST
20122: LIST
20123: PPUSH
20124: CALL_OW 72
20128: IFFALSE 20216
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
20130: LD_ADDR_VAR 0 8
20134: PUSH
20135: LD_VAR 0 18
20139: PPUSH
20140: LD_INT 2
20142: PUSH
20143: LD_INT 30
20145: PUSH
20146: LD_INT 32
20148: PUSH
20149: EMPTY
20150: LIST
20151: LIST
20152: PUSH
20153: LD_INT 30
20155: PUSH
20156: LD_INT 33
20158: PUSH
20159: EMPTY
20160: LIST
20161: LIST
20162: PUSH
20163: EMPTY
20164: LIST
20165: LIST
20166: LIST
20167: PPUSH
20168: CALL_OW 72
20172: PUSH
20173: FOR_IN
20174: IFFALSE 20214
// begin if not GetBWeapon ( i ) then
20176: LD_VAR 0 8
20180: PPUSH
20181: CALL_OW 269
20185: NOT
20186: IFFALSE 20212
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
20188: LD_VAR 0 8
20192: PPUSH
20193: LD_VAR 0 8
20197: PPUSH
20198: LD_VAR 0 2
20202: PPUSH
20203: CALL 21462 0 2
20207: PPUSH
20208: CALL_OW 431
// end ;
20212: GO 20173
20214: POP
20215: POP
// end ; for i = 1 to personel do
20216: LD_ADDR_VAR 0 8
20220: PUSH
20221: DOUBLE
20222: LD_INT 1
20224: DEC
20225: ST_TO_ADDR
20226: LD_VAR 0 6
20230: PUSH
20231: FOR_TO
20232: IFFALSE 21296
// begin if i > 4 then
20234: LD_VAR 0 8
20238: PUSH
20239: LD_INT 4
20241: GREATER
20242: IFFALSE 20246
// break ;
20244: GO 21296
// case i of 1 :
20246: LD_VAR 0 8
20250: PUSH
20251: LD_INT 1
20253: DOUBLE
20254: EQUAL
20255: IFTRUE 20259
20257: GO 20339
20259: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
20260: LD_ADDR_VAR 0 12
20264: PUSH
20265: LD_VAR 0 18
20269: PPUSH
20270: LD_INT 22
20272: PUSH
20273: LD_VAR 0 16
20277: PUSH
20278: EMPTY
20279: LIST
20280: LIST
20281: PUSH
20282: LD_INT 58
20284: PUSH
20285: EMPTY
20286: LIST
20287: PUSH
20288: LD_INT 2
20290: PUSH
20291: LD_INT 30
20293: PUSH
20294: LD_INT 32
20296: PUSH
20297: EMPTY
20298: LIST
20299: LIST
20300: PUSH
20301: LD_INT 30
20303: PUSH
20304: LD_INT 4
20306: PUSH
20307: EMPTY
20308: LIST
20309: LIST
20310: PUSH
20311: LD_INT 30
20313: PUSH
20314: LD_INT 5
20316: PUSH
20317: EMPTY
20318: LIST
20319: LIST
20320: PUSH
20321: EMPTY
20322: LIST
20323: LIST
20324: LIST
20325: LIST
20326: PUSH
20327: EMPTY
20328: LIST
20329: LIST
20330: LIST
20331: PPUSH
20332: CALL_OW 72
20336: ST_TO_ADDR
20337: GO 20561
20339: LD_INT 2
20341: DOUBLE
20342: EQUAL
20343: IFTRUE 20347
20345: GO 20409
20347: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
20348: LD_ADDR_VAR 0 12
20352: PUSH
20353: LD_VAR 0 18
20357: PPUSH
20358: LD_INT 22
20360: PUSH
20361: LD_VAR 0 16
20365: PUSH
20366: EMPTY
20367: LIST
20368: LIST
20369: PUSH
20370: LD_INT 2
20372: PUSH
20373: LD_INT 30
20375: PUSH
20376: LD_INT 0
20378: PUSH
20379: EMPTY
20380: LIST
20381: LIST
20382: PUSH
20383: LD_INT 30
20385: PUSH
20386: LD_INT 1
20388: PUSH
20389: EMPTY
20390: LIST
20391: LIST
20392: PUSH
20393: EMPTY
20394: LIST
20395: LIST
20396: LIST
20397: PUSH
20398: EMPTY
20399: LIST
20400: LIST
20401: PPUSH
20402: CALL_OW 72
20406: ST_TO_ADDR
20407: GO 20561
20409: LD_INT 3
20411: DOUBLE
20412: EQUAL
20413: IFTRUE 20417
20415: GO 20479
20417: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
20418: LD_ADDR_VAR 0 12
20422: PUSH
20423: LD_VAR 0 18
20427: PPUSH
20428: LD_INT 22
20430: PUSH
20431: LD_VAR 0 16
20435: PUSH
20436: EMPTY
20437: LIST
20438: LIST
20439: PUSH
20440: LD_INT 2
20442: PUSH
20443: LD_INT 30
20445: PUSH
20446: LD_INT 2
20448: PUSH
20449: EMPTY
20450: LIST
20451: LIST
20452: PUSH
20453: LD_INT 30
20455: PUSH
20456: LD_INT 3
20458: PUSH
20459: EMPTY
20460: LIST
20461: LIST
20462: PUSH
20463: EMPTY
20464: LIST
20465: LIST
20466: LIST
20467: PUSH
20468: EMPTY
20469: LIST
20470: LIST
20471: PPUSH
20472: CALL_OW 72
20476: ST_TO_ADDR
20477: GO 20561
20479: LD_INT 4
20481: DOUBLE
20482: EQUAL
20483: IFTRUE 20487
20485: GO 20560
20487: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
20488: LD_ADDR_VAR 0 12
20492: PUSH
20493: LD_VAR 0 18
20497: PPUSH
20498: LD_INT 22
20500: PUSH
20501: LD_VAR 0 16
20505: PUSH
20506: EMPTY
20507: LIST
20508: LIST
20509: PUSH
20510: LD_INT 2
20512: PUSH
20513: LD_INT 30
20515: PUSH
20516: LD_INT 6
20518: PUSH
20519: EMPTY
20520: LIST
20521: LIST
20522: PUSH
20523: LD_INT 30
20525: PUSH
20526: LD_INT 7
20528: PUSH
20529: EMPTY
20530: LIST
20531: LIST
20532: PUSH
20533: LD_INT 30
20535: PUSH
20536: LD_INT 8
20538: PUSH
20539: EMPTY
20540: LIST
20541: LIST
20542: PUSH
20543: EMPTY
20544: LIST
20545: LIST
20546: LIST
20547: LIST
20548: PUSH
20549: EMPTY
20550: LIST
20551: LIST
20552: PPUSH
20553: CALL_OW 72
20557: ST_TO_ADDR
20558: GO 20561
20560: POP
// if i = 1 then
20561: LD_VAR 0 8
20565: PUSH
20566: LD_INT 1
20568: EQUAL
20569: IFFALSE 20680
// begin tmp := [ ] ;
20571: LD_ADDR_VAR 0 19
20575: PUSH
20576: EMPTY
20577: ST_TO_ADDR
// for j in f do
20578: LD_ADDR_VAR 0 9
20582: PUSH
20583: LD_VAR 0 12
20587: PUSH
20588: FOR_IN
20589: IFFALSE 20662
// if GetBType ( j ) = b_bunker then
20591: LD_VAR 0 9
20595: PPUSH
20596: CALL_OW 266
20600: PUSH
20601: LD_INT 32
20603: EQUAL
20604: IFFALSE 20631
// tmp := Insert ( tmp , 1 , j ) else
20606: LD_ADDR_VAR 0 19
20610: PUSH
20611: LD_VAR 0 19
20615: PPUSH
20616: LD_INT 1
20618: PPUSH
20619: LD_VAR 0 9
20623: PPUSH
20624: CALL_OW 2
20628: ST_TO_ADDR
20629: GO 20660
// tmp := Insert ( tmp , tmp + 1 , j ) ;
20631: LD_ADDR_VAR 0 19
20635: PUSH
20636: LD_VAR 0 19
20640: PPUSH
20641: LD_VAR 0 19
20645: PUSH
20646: LD_INT 1
20648: PLUS
20649: PPUSH
20650: LD_VAR 0 9
20654: PPUSH
20655: CALL_OW 2
20659: ST_TO_ADDR
20660: GO 20588
20662: POP
20663: POP
// if tmp then
20664: LD_VAR 0 19
20668: IFFALSE 20680
// f := tmp ;
20670: LD_ADDR_VAR 0 12
20674: PUSH
20675: LD_VAR 0 19
20679: ST_TO_ADDR
// end ; x := personel [ i ] ;
20680: LD_ADDR_VAR 0 13
20684: PUSH
20685: LD_VAR 0 6
20689: PUSH
20690: LD_VAR 0 8
20694: ARRAY
20695: ST_TO_ADDR
// if x = - 1 then
20696: LD_VAR 0 13
20700: PUSH
20701: LD_INT 1
20703: NEG
20704: EQUAL
20705: IFFALSE 20914
// begin for j in f do
20707: LD_ADDR_VAR 0 9
20711: PUSH
20712: LD_VAR 0 12
20716: PUSH
20717: FOR_IN
20718: IFFALSE 20910
// repeat InitHc ;
20720: CALL_OW 19
// if GetBType ( j ) = b_barracks then
20724: LD_VAR 0 9
20728: PPUSH
20729: CALL_OW 266
20733: PUSH
20734: LD_INT 5
20736: EQUAL
20737: IFFALSE 20807
// begin if UnitsInside ( j ) < 3 then
20739: LD_VAR 0 9
20743: PPUSH
20744: CALL_OW 313
20748: PUSH
20749: LD_INT 3
20751: LESS
20752: IFFALSE 20788
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
20754: LD_INT 0
20756: PPUSH
20757: LD_INT 5
20759: PUSH
20760: LD_INT 8
20762: PUSH
20763: LD_INT 9
20765: PUSH
20766: EMPTY
20767: LIST
20768: LIST
20769: LIST
20770: PUSH
20771: LD_VAR 0 17
20775: ARRAY
20776: PPUSH
20777: LD_VAR 0 4
20781: PPUSH
20782: CALL_OW 380
20786: GO 20805
// PrepareHuman ( false , i , skill ) ;
20788: LD_INT 0
20790: PPUSH
20791: LD_VAR 0 8
20795: PPUSH
20796: LD_VAR 0 4
20800: PPUSH
20801: CALL_OW 380
// end else
20805: GO 20824
// PrepareHuman ( false , i , skill ) ;
20807: LD_INT 0
20809: PPUSH
20810: LD_VAR 0 8
20814: PPUSH
20815: LD_VAR 0 4
20819: PPUSH
20820: CALL_OW 380
// un := CreateHuman ;
20824: LD_ADDR_VAR 0 14
20828: PUSH
20829: CALL_OW 44
20833: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20834: LD_ADDR_VAR 0 7
20838: PUSH
20839: LD_VAR 0 7
20843: PPUSH
20844: LD_INT 1
20846: PPUSH
20847: LD_VAR 0 14
20851: PPUSH
20852: CALL_OW 2
20856: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
20857: LD_VAR 0 14
20861: PPUSH
20862: LD_VAR 0 9
20866: PPUSH
20867: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
20871: LD_VAR 0 9
20875: PPUSH
20876: CALL_OW 313
20880: PUSH
20881: LD_INT 6
20883: EQUAL
20884: PUSH
20885: LD_VAR 0 9
20889: PPUSH
20890: CALL_OW 266
20894: PUSH
20895: LD_INT 32
20897: PUSH
20898: LD_INT 31
20900: PUSH
20901: EMPTY
20902: LIST
20903: LIST
20904: IN
20905: OR
20906: IFFALSE 20720
20908: GO 20717
20910: POP
20911: POP
// end else
20912: GO 21294
// for j = 1 to x do
20914: LD_ADDR_VAR 0 9
20918: PUSH
20919: DOUBLE
20920: LD_INT 1
20922: DEC
20923: ST_TO_ADDR
20924: LD_VAR 0 13
20928: PUSH
20929: FOR_TO
20930: IFFALSE 21292
// begin InitHc ;
20932: CALL_OW 19
// if not f then
20936: LD_VAR 0 12
20940: NOT
20941: IFFALSE 21030
// begin PrepareHuman ( false , i , skill ) ;
20943: LD_INT 0
20945: PPUSH
20946: LD_VAR 0 8
20950: PPUSH
20951: LD_VAR 0 4
20955: PPUSH
20956: CALL_OW 380
// un := CreateHuman ;
20960: LD_ADDR_VAR 0 14
20964: PUSH
20965: CALL_OW 44
20969: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20970: LD_ADDR_VAR 0 7
20974: PUSH
20975: LD_VAR 0 7
20979: PPUSH
20980: LD_INT 1
20982: PPUSH
20983: LD_VAR 0 14
20987: PPUSH
20988: CALL_OW 2
20992: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
20993: LD_VAR 0 14
20997: PPUSH
20998: LD_VAR 0 1
21002: PPUSH
21003: CALL_OW 250
21007: PPUSH
21008: LD_VAR 0 1
21012: PPUSH
21013: CALL_OW 251
21017: PPUSH
21018: LD_INT 10
21020: PPUSH
21021: LD_INT 0
21023: PPUSH
21024: CALL_OW 50
// continue ;
21028: GO 20929
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
21030: LD_VAR 0 12
21034: PUSH
21035: LD_INT 1
21037: ARRAY
21038: PPUSH
21039: CALL_OW 313
21043: PUSH
21044: LD_VAR 0 12
21048: PUSH
21049: LD_INT 1
21051: ARRAY
21052: PPUSH
21053: CALL_OW 266
21057: PUSH
21058: LD_INT 32
21060: PUSH
21061: LD_INT 31
21063: PUSH
21064: EMPTY
21065: LIST
21066: LIST
21067: IN
21068: AND
21069: PUSH
21070: LD_VAR 0 12
21074: PUSH
21075: LD_INT 1
21077: ARRAY
21078: PPUSH
21079: CALL_OW 313
21083: PUSH
21084: LD_INT 6
21086: EQUAL
21087: OR
21088: IFFALSE 21108
// f := Delete ( f , 1 ) ;
21090: LD_ADDR_VAR 0 12
21094: PUSH
21095: LD_VAR 0 12
21099: PPUSH
21100: LD_INT 1
21102: PPUSH
21103: CALL_OW 3
21107: ST_TO_ADDR
// if not f then
21108: LD_VAR 0 12
21112: NOT
21113: IFFALSE 21131
// begin x := x + 2 ;
21115: LD_ADDR_VAR 0 13
21119: PUSH
21120: LD_VAR 0 13
21124: PUSH
21125: LD_INT 2
21127: PLUS
21128: ST_TO_ADDR
// continue ;
21129: GO 20929
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
21131: LD_VAR 0 12
21135: PUSH
21136: LD_INT 1
21138: ARRAY
21139: PPUSH
21140: CALL_OW 266
21144: PUSH
21145: LD_INT 5
21147: EQUAL
21148: IFFALSE 21222
// begin if UnitsInside ( f [ 1 ] ) < 3 then
21150: LD_VAR 0 12
21154: PUSH
21155: LD_INT 1
21157: ARRAY
21158: PPUSH
21159: CALL_OW 313
21163: PUSH
21164: LD_INT 3
21166: LESS
21167: IFFALSE 21203
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
21169: LD_INT 0
21171: PPUSH
21172: LD_INT 5
21174: PUSH
21175: LD_INT 8
21177: PUSH
21178: LD_INT 9
21180: PUSH
21181: EMPTY
21182: LIST
21183: LIST
21184: LIST
21185: PUSH
21186: LD_VAR 0 17
21190: ARRAY
21191: PPUSH
21192: LD_VAR 0 4
21196: PPUSH
21197: CALL_OW 380
21201: GO 21220
// PrepareHuman ( false , i , skill ) ;
21203: LD_INT 0
21205: PPUSH
21206: LD_VAR 0 8
21210: PPUSH
21211: LD_VAR 0 4
21215: PPUSH
21216: CALL_OW 380
// end else
21220: GO 21239
// PrepareHuman ( false , i , skill ) ;
21222: LD_INT 0
21224: PPUSH
21225: LD_VAR 0 8
21229: PPUSH
21230: LD_VAR 0 4
21234: PPUSH
21235: CALL_OW 380
// un := CreateHuman ;
21239: LD_ADDR_VAR 0 14
21243: PUSH
21244: CALL_OW 44
21248: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
21249: LD_ADDR_VAR 0 7
21253: PUSH
21254: LD_VAR 0 7
21258: PPUSH
21259: LD_INT 1
21261: PPUSH
21262: LD_VAR 0 14
21266: PPUSH
21267: CALL_OW 2
21271: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
21272: LD_VAR 0 14
21276: PPUSH
21277: LD_VAR 0 12
21281: PUSH
21282: LD_INT 1
21284: ARRAY
21285: PPUSH
21286: CALL_OW 52
// end ;
21290: GO 20929
21292: POP
21293: POP
// end ;
21294: GO 20231
21296: POP
21297: POP
// result := result ^ buildings ;
21298: LD_ADDR_VAR 0 7
21302: PUSH
21303: LD_VAR 0 7
21307: PUSH
21308: LD_VAR 0 18
21312: ADD
21313: ST_TO_ADDR
// end else
21314: GO 21457
// begin for i = 1 to personel do
21316: LD_ADDR_VAR 0 8
21320: PUSH
21321: DOUBLE
21322: LD_INT 1
21324: DEC
21325: ST_TO_ADDR
21326: LD_VAR 0 6
21330: PUSH
21331: FOR_TO
21332: IFFALSE 21455
// begin if i > 4 then
21334: LD_VAR 0 8
21338: PUSH
21339: LD_INT 4
21341: GREATER
21342: IFFALSE 21346
// break ;
21344: GO 21455
// x := personel [ i ] ;
21346: LD_ADDR_VAR 0 13
21350: PUSH
21351: LD_VAR 0 6
21355: PUSH
21356: LD_VAR 0 8
21360: ARRAY
21361: ST_TO_ADDR
// if x = - 1 then
21362: LD_VAR 0 13
21366: PUSH
21367: LD_INT 1
21369: NEG
21370: EQUAL
21371: IFFALSE 21375
// continue ;
21373: GO 21331
// PrepareHuman ( false , i , skill ) ;
21375: LD_INT 0
21377: PPUSH
21378: LD_VAR 0 8
21382: PPUSH
21383: LD_VAR 0 4
21387: PPUSH
21388: CALL_OW 380
// un := CreateHuman ;
21392: LD_ADDR_VAR 0 14
21396: PUSH
21397: CALL_OW 44
21401: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
21402: LD_VAR 0 14
21406: PPUSH
21407: LD_VAR 0 1
21411: PPUSH
21412: CALL_OW 250
21416: PPUSH
21417: LD_VAR 0 1
21421: PPUSH
21422: CALL_OW 251
21426: PPUSH
21427: LD_INT 10
21429: PPUSH
21430: LD_INT 0
21432: PPUSH
21433: CALL_OW 50
// result := result ^ un ;
21437: LD_ADDR_VAR 0 7
21441: PUSH
21442: LD_VAR 0 7
21446: PUSH
21447: LD_VAR 0 14
21451: ADD
21452: ST_TO_ADDR
// end ;
21453: GO 21331
21455: POP
21456: POP
// end ; end ;
21457: LD_VAR 0 7
21461: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
21462: LD_INT 0
21464: PPUSH
21465: PPUSH
21466: PPUSH
21467: PPUSH
21468: PPUSH
21469: PPUSH
21470: PPUSH
21471: PPUSH
21472: PPUSH
21473: PPUSH
21474: PPUSH
21475: PPUSH
21476: PPUSH
21477: PPUSH
21478: PPUSH
21479: PPUSH
// result := false ;
21480: LD_ADDR_VAR 0 3
21484: PUSH
21485: LD_INT 0
21487: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
21488: LD_VAR 0 1
21492: NOT
21493: PUSH
21494: LD_VAR 0 1
21498: PPUSH
21499: CALL_OW 266
21503: PUSH
21504: LD_INT 32
21506: PUSH
21507: LD_INT 33
21509: PUSH
21510: EMPTY
21511: LIST
21512: LIST
21513: IN
21514: NOT
21515: OR
21516: IFFALSE 21520
// exit ;
21518: GO 22629
// nat := GetNation ( tower ) ;
21520: LD_ADDR_VAR 0 12
21524: PUSH
21525: LD_VAR 0 1
21529: PPUSH
21530: CALL_OW 248
21534: ST_TO_ADDR
// side := GetSide ( tower ) ;
21535: LD_ADDR_VAR 0 16
21539: PUSH
21540: LD_VAR 0 1
21544: PPUSH
21545: CALL_OW 255
21549: ST_TO_ADDR
// x := GetX ( tower ) ;
21550: LD_ADDR_VAR 0 10
21554: PUSH
21555: LD_VAR 0 1
21559: PPUSH
21560: CALL_OW 250
21564: ST_TO_ADDR
// y := GetY ( tower ) ;
21565: LD_ADDR_VAR 0 11
21569: PUSH
21570: LD_VAR 0 1
21574: PPUSH
21575: CALL_OW 251
21579: ST_TO_ADDR
// if not x or not y then
21580: LD_VAR 0 10
21584: NOT
21585: PUSH
21586: LD_VAR 0 11
21590: NOT
21591: OR
21592: IFFALSE 21596
// exit ;
21594: GO 22629
// weapon := 0 ;
21596: LD_ADDR_VAR 0 18
21600: PUSH
21601: LD_INT 0
21603: ST_TO_ADDR
// fac_list := [ ] ;
21604: LD_ADDR_VAR 0 17
21608: PUSH
21609: EMPTY
21610: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
21611: LD_ADDR_VAR 0 6
21615: PUSH
21616: LD_VAR 0 1
21620: PPUSH
21621: CALL_OW 274
21625: PPUSH
21626: LD_VAR 0 2
21630: PPUSH
21631: LD_INT 0
21633: PPUSH
21634: CALL 19200 0 3
21638: PPUSH
21639: LD_INT 30
21641: PUSH
21642: LD_INT 3
21644: PUSH
21645: EMPTY
21646: LIST
21647: LIST
21648: PPUSH
21649: CALL_OW 72
21653: ST_TO_ADDR
// if not factories then
21654: LD_VAR 0 6
21658: NOT
21659: IFFALSE 21663
// exit ;
21661: GO 22629
// for i in factories do
21663: LD_ADDR_VAR 0 8
21667: PUSH
21668: LD_VAR 0 6
21672: PUSH
21673: FOR_IN
21674: IFFALSE 21699
// fac_list := fac_list union AvailableWeaponList ( i ) ;
21676: LD_ADDR_VAR 0 17
21680: PUSH
21681: LD_VAR 0 17
21685: PUSH
21686: LD_VAR 0 8
21690: PPUSH
21691: CALL_OW 478
21695: UNION
21696: ST_TO_ADDR
21697: GO 21673
21699: POP
21700: POP
// if not fac_list then
21701: LD_VAR 0 17
21705: NOT
21706: IFFALSE 21710
// exit ;
21708: GO 22629
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
21710: LD_ADDR_VAR 0 5
21714: PUSH
21715: LD_INT 4
21717: PUSH
21718: LD_INT 5
21720: PUSH
21721: LD_INT 9
21723: PUSH
21724: LD_INT 10
21726: PUSH
21727: LD_INT 6
21729: PUSH
21730: LD_INT 7
21732: PUSH
21733: LD_INT 11
21735: PUSH
21736: EMPTY
21737: LIST
21738: LIST
21739: LIST
21740: LIST
21741: LIST
21742: LIST
21743: LIST
21744: PUSH
21745: LD_INT 27
21747: PUSH
21748: LD_INT 28
21750: PUSH
21751: LD_INT 26
21753: PUSH
21754: LD_INT 30
21756: PUSH
21757: EMPTY
21758: LIST
21759: LIST
21760: LIST
21761: LIST
21762: PUSH
21763: LD_INT 43
21765: PUSH
21766: LD_INT 44
21768: PUSH
21769: LD_INT 46
21771: PUSH
21772: LD_INT 45
21774: PUSH
21775: LD_INT 47
21777: PUSH
21778: LD_INT 49
21780: PUSH
21781: EMPTY
21782: LIST
21783: LIST
21784: LIST
21785: LIST
21786: LIST
21787: LIST
21788: PUSH
21789: EMPTY
21790: LIST
21791: LIST
21792: LIST
21793: PUSH
21794: LD_VAR 0 12
21798: ARRAY
21799: ST_TO_ADDR
// list := list isect fac_list ;
21800: LD_ADDR_VAR 0 5
21804: PUSH
21805: LD_VAR 0 5
21809: PUSH
21810: LD_VAR 0 17
21814: ISECT
21815: ST_TO_ADDR
// if not list then
21816: LD_VAR 0 5
21820: NOT
21821: IFFALSE 21825
// exit ;
21823: GO 22629
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
21825: LD_VAR 0 12
21829: PUSH
21830: LD_INT 3
21832: EQUAL
21833: PUSH
21834: LD_INT 49
21836: PUSH
21837: LD_VAR 0 5
21841: IN
21842: AND
21843: PUSH
21844: LD_INT 31
21846: PPUSH
21847: LD_VAR 0 16
21851: PPUSH
21852: CALL_OW 321
21856: PUSH
21857: LD_INT 2
21859: EQUAL
21860: AND
21861: IFFALSE 21921
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
21863: LD_INT 22
21865: PUSH
21866: LD_VAR 0 16
21870: PUSH
21871: EMPTY
21872: LIST
21873: LIST
21874: PUSH
21875: LD_INT 35
21877: PUSH
21878: LD_INT 49
21880: PUSH
21881: EMPTY
21882: LIST
21883: LIST
21884: PUSH
21885: LD_INT 91
21887: PUSH
21888: LD_VAR 0 1
21892: PUSH
21893: LD_INT 10
21895: PUSH
21896: EMPTY
21897: LIST
21898: LIST
21899: LIST
21900: PUSH
21901: EMPTY
21902: LIST
21903: LIST
21904: LIST
21905: PPUSH
21906: CALL_OW 69
21910: NOT
21911: IFFALSE 21921
// weapon := ru_time_lapser ;
21913: LD_ADDR_VAR 0 18
21917: PUSH
21918: LD_INT 49
21920: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
21921: LD_VAR 0 12
21925: PUSH
21926: LD_INT 1
21928: PUSH
21929: LD_INT 2
21931: PUSH
21932: EMPTY
21933: LIST
21934: LIST
21935: IN
21936: PUSH
21937: LD_INT 11
21939: PUSH
21940: LD_VAR 0 5
21944: IN
21945: PUSH
21946: LD_INT 30
21948: PUSH
21949: LD_VAR 0 5
21953: IN
21954: OR
21955: AND
21956: PUSH
21957: LD_INT 6
21959: PPUSH
21960: LD_VAR 0 16
21964: PPUSH
21965: CALL_OW 321
21969: PUSH
21970: LD_INT 2
21972: EQUAL
21973: AND
21974: IFFALSE 22139
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
21976: LD_INT 22
21978: PUSH
21979: LD_VAR 0 16
21983: PUSH
21984: EMPTY
21985: LIST
21986: LIST
21987: PUSH
21988: LD_INT 2
21990: PUSH
21991: LD_INT 35
21993: PUSH
21994: LD_INT 11
21996: PUSH
21997: EMPTY
21998: LIST
21999: LIST
22000: PUSH
22001: LD_INT 35
22003: PUSH
22004: LD_INT 30
22006: PUSH
22007: EMPTY
22008: LIST
22009: LIST
22010: PUSH
22011: EMPTY
22012: LIST
22013: LIST
22014: LIST
22015: PUSH
22016: LD_INT 91
22018: PUSH
22019: LD_VAR 0 1
22023: PUSH
22024: LD_INT 18
22026: PUSH
22027: EMPTY
22028: LIST
22029: LIST
22030: LIST
22031: PUSH
22032: EMPTY
22033: LIST
22034: LIST
22035: LIST
22036: PPUSH
22037: CALL_OW 69
22041: NOT
22042: PUSH
22043: LD_INT 22
22045: PUSH
22046: LD_VAR 0 16
22050: PUSH
22051: EMPTY
22052: LIST
22053: LIST
22054: PUSH
22055: LD_INT 2
22057: PUSH
22058: LD_INT 30
22060: PUSH
22061: LD_INT 32
22063: PUSH
22064: EMPTY
22065: LIST
22066: LIST
22067: PUSH
22068: LD_INT 30
22070: PUSH
22071: LD_INT 33
22073: PUSH
22074: EMPTY
22075: LIST
22076: LIST
22077: PUSH
22078: EMPTY
22079: LIST
22080: LIST
22081: LIST
22082: PUSH
22083: LD_INT 91
22085: PUSH
22086: LD_VAR 0 1
22090: PUSH
22091: LD_INT 12
22093: PUSH
22094: EMPTY
22095: LIST
22096: LIST
22097: LIST
22098: PUSH
22099: EMPTY
22100: LIST
22101: LIST
22102: LIST
22103: PUSH
22104: EMPTY
22105: LIST
22106: PPUSH
22107: CALL_OW 69
22111: PUSH
22112: LD_INT 2
22114: GREATER
22115: AND
22116: IFFALSE 22139
// weapon := [ us_radar , ar_radar ] [ nat ] ;
22118: LD_ADDR_VAR 0 18
22122: PUSH
22123: LD_INT 11
22125: PUSH
22126: LD_INT 30
22128: PUSH
22129: EMPTY
22130: LIST
22131: LIST
22132: PUSH
22133: LD_VAR 0 12
22137: ARRAY
22138: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
22139: LD_VAR 0 18
22143: NOT
22144: PUSH
22145: LD_INT 40
22147: PPUSH
22148: LD_VAR 0 16
22152: PPUSH
22153: CALL_OW 321
22157: PUSH
22158: LD_INT 2
22160: EQUAL
22161: AND
22162: PUSH
22163: LD_INT 7
22165: PUSH
22166: LD_VAR 0 5
22170: IN
22171: PUSH
22172: LD_INT 28
22174: PUSH
22175: LD_VAR 0 5
22179: IN
22180: OR
22181: PUSH
22182: LD_INT 45
22184: PUSH
22185: LD_VAR 0 5
22189: IN
22190: OR
22191: AND
22192: IFFALSE 22446
// begin hex := GetHexInfo ( x , y ) ;
22194: LD_ADDR_VAR 0 4
22198: PUSH
22199: LD_VAR 0 10
22203: PPUSH
22204: LD_VAR 0 11
22208: PPUSH
22209: CALL_OW 546
22213: ST_TO_ADDR
// if hex [ 1 ] then
22214: LD_VAR 0 4
22218: PUSH
22219: LD_INT 1
22221: ARRAY
22222: IFFALSE 22226
// exit ;
22224: GO 22629
// height := hex [ 2 ] ;
22226: LD_ADDR_VAR 0 15
22230: PUSH
22231: LD_VAR 0 4
22235: PUSH
22236: LD_INT 2
22238: ARRAY
22239: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
22240: LD_ADDR_VAR 0 14
22244: PUSH
22245: LD_INT 0
22247: PUSH
22248: LD_INT 2
22250: PUSH
22251: LD_INT 3
22253: PUSH
22254: LD_INT 5
22256: PUSH
22257: EMPTY
22258: LIST
22259: LIST
22260: LIST
22261: LIST
22262: ST_TO_ADDR
// for i in tmp do
22263: LD_ADDR_VAR 0 8
22267: PUSH
22268: LD_VAR 0 14
22272: PUSH
22273: FOR_IN
22274: IFFALSE 22444
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
22276: LD_ADDR_VAR 0 9
22280: PUSH
22281: LD_VAR 0 10
22285: PPUSH
22286: LD_VAR 0 8
22290: PPUSH
22291: LD_INT 5
22293: PPUSH
22294: CALL_OW 272
22298: PUSH
22299: LD_VAR 0 11
22303: PPUSH
22304: LD_VAR 0 8
22308: PPUSH
22309: LD_INT 5
22311: PPUSH
22312: CALL_OW 273
22316: PUSH
22317: EMPTY
22318: LIST
22319: LIST
22320: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
22321: LD_VAR 0 9
22325: PUSH
22326: LD_INT 1
22328: ARRAY
22329: PPUSH
22330: LD_VAR 0 9
22334: PUSH
22335: LD_INT 2
22337: ARRAY
22338: PPUSH
22339: CALL_OW 488
22343: IFFALSE 22442
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
22345: LD_ADDR_VAR 0 4
22349: PUSH
22350: LD_VAR 0 9
22354: PUSH
22355: LD_INT 1
22357: ARRAY
22358: PPUSH
22359: LD_VAR 0 9
22363: PUSH
22364: LD_INT 2
22366: ARRAY
22367: PPUSH
22368: CALL_OW 546
22372: ST_TO_ADDR
// if hex [ 1 ] then
22373: LD_VAR 0 4
22377: PUSH
22378: LD_INT 1
22380: ARRAY
22381: IFFALSE 22385
// continue ;
22383: GO 22273
// h := hex [ 2 ] ;
22385: LD_ADDR_VAR 0 13
22389: PUSH
22390: LD_VAR 0 4
22394: PUSH
22395: LD_INT 2
22397: ARRAY
22398: ST_TO_ADDR
// if h + 7 < height then
22399: LD_VAR 0 13
22403: PUSH
22404: LD_INT 7
22406: PLUS
22407: PUSH
22408: LD_VAR 0 15
22412: LESS
22413: IFFALSE 22442
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
22415: LD_ADDR_VAR 0 18
22419: PUSH
22420: LD_INT 7
22422: PUSH
22423: LD_INT 28
22425: PUSH
22426: LD_INT 45
22428: PUSH
22429: EMPTY
22430: LIST
22431: LIST
22432: LIST
22433: PUSH
22434: LD_VAR 0 12
22438: ARRAY
22439: ST_TO_ADDR
// break ;
22440: GO 22444
// end ; end ; end ;
22442: GO 22273
22444: POP
22445: POP
// end ; if not weapon then
22446: LD_VAR 0 18
22450: NOT
22451: IFFALSE 22511
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
22453: LD_ADDR_VAR 0 5
22457: PUSH
22458: LD_VAR 0 5
22462: PUSH
22463: LD_INT 11
22465: PUSH
22466: LD_INT 30
22468: PUSH
22469: LD_INT 49
22471: PUSH
22472: EMPTY
22473: LIST
22474: LIST
22475: LIST
22476: DIFF
22477: ST_TO_ADDR
// if not list then
22478: LD_VAR 0 5
22482: NOT
22483: IFFALSE 22487
// exit ;
22485: GO 22629
// weapon := list [ rand ( 1 , list ) ] ;
22487: LD_ADDR_VAR 0 18
22491: PUSH
22492: LD_VAR 0 5
22496: PUSH
22497: LD_INT 1
22499: PPUSH
22500: LD_VAR 0 5
22504: PPUSH
22505: CALL_OW 12
22509: ARRAY
22510: ST_TO_ADDR
// end ; if weapon then
22511: LD_VAR 0 18
22515: IFFALSE 22629
// begin tmp := CostOfWeapon ( weapon ) ;
22517: LD_ADDR_VAR 0 14
22521: PUSH
22522: LD_VAR 0 18
22526: PPUSH
22527: CALL_OW 451
22531: ST_TO_ADDR
// j := GetBase ( tower ) ;
22532: LD_ADDR_VAR 0 9
22536: PUSH
22537: LD_VAR 0 1
22541: PPUSH
22542: CALL_OW 274
22546: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
22547: LD_VAR 0 9
22551: PPUSH
22552: LD_INT 1
22554: PPUSH
22555: CALL_OW 275
22559: PUSH
22560: LD_VAR 0 14
22564: PUSH
22565: LD_INT 1
22567: ARRAY
22568: GREATEREQUAL
22569: PUSH
22570: LD_VAR 0 9
22574: PPUSH
22575: LD_INT 2
22577: PPUSH
22578: CALL_OW 275
22582: PUSH
22583: LD_VAR 0 14
22587: PUSH
22588: LD_INT 2
22590: ARRAY
22591: GREATEREQUAL
22592: AND
22593: PUSH
22594: LD_VAR 0 9
22598: PPUSH
22599: LD_INT 3
22601: PPUSH
22602: CALL_OW 275
22606: PUSH
22607: LD_VAR 0 14
22611: PUSH
22612: LD_INT 3
22614: ARRAY
22615: GREATEREQUAL
22616: AND
22617: IFFALSE 22629
// result := weapon ;
22619: LD_ADDR_VAR 0 3
22623: PUSH
22624: LD_VAR 0 18
22628: ST_TO_ADDR
// end ; end ;
22629: LD_VAR 0 3
22633: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
22634: LD_INT 0
22636: PPUSH
22637: PPUSH
// result := true ;
22638: LD_ADDR_VAR 0 3
22642: PUSH
22643: LD_INT 1
22645: ST_TO_ADDR
// if array1 = array2 then
22646: LD_VAR 0 1
22650: PUSH
22651: LD_VAR 0 2
22655: EQUAL
22656: IFFALSE 22716
// begin for i = 1 to array1 do
22658: LD_ADDR_VAR 0 4
22662: PUSH
22663: DOUBLE
22664: LD_INT 1
22666: DEC
22667: ST_TO_ADDR
22668: LD_VAR 0 1
22672: PUSH
22673: FOR_TO
22674: IFFALSE 22712
// if array1 [ i ] <> array2 [ i ] then
22676: LD_VAR 0 1
22680: PUSH
22681: LD_VAR 0 4
22685: ARRAY
22686: PUSH
22687: LD_VAR 0 2
22691: PUSH
22692: LD_VAR 0 4
22696: ARRAY
22697: NONEQUAL
22698: IFFALSE 22710
// begin result := false ;
22700: LD_ADDR_VAR 0 3
22704: PUSH
22705: LD_INT 0
22707: ST_TO_ADDR
// break ;
22708: GO 22712
// end ;
22710: GO 22673
22712: POP
22713: POP
// end else
22714: GO 22724
// result := false ;
22716: LD_ADDR_VAR 0 3
22720: PUSH
22721: LD_INT 0
22723: ST_TO_ADDR
// end ;
22724: LD_VAR 0 3
22728: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
22729: LD_INT 0
22731: PPUSH
22732: PPUSH
// if not array1 or not array2 then
22733: LD_VAR 0 1
22737: NOT
22738: PUSH
22739: LD_VAR 0 2
22743: NOT
22744: OR
22745: IFFALSE 22749
// exit ;
22747: GO 22813
// result := true ;
22749: LD_ADDR_VAR 0 3
22753: PUSH
22754: LD_INT 1
22756: ST_TO_ADDR
// for i = 1 to array1 do
22757: LD_ADDR_VAR 0 4
22761: PUSH
22762: DOUBLE
22763: LD_INT 1
22765: DEC
22766: ST_TO_ADDR
22767: LD_VAR 0 1
22771: PUSH
22772: FOR_TO
22773: IFFALSE 22811
// if array1 [ i ] <> array2 [ i ] then
22775: LD_VAR 0 1
22779: PUSH
22780: LD_VAR 0 4
22784: ARRAY
22785: PUSH
22786: LD_VAR 0 2
22790: PUSH
22791: LD_VAR 0 4
22795: ARRAY
22796: NONEQUAL
22797: IFFALSE 22809
// begin result := false ;
22799: LD_ADDR_VAR 0 3
22803: PUSH
22804: LD_INT 0
22806: ST_TO_ADDR
// break ;
22807: GO 22811
// end ;
22809: GO 22772
22811: POP
22812: POP
// end ;
22813: LD_VAR 0 3
22817: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
22818: LD_INT 0
22820: PPUSH
22821: PPUSH
22822: PPUSH
// pom := GetBase ( fac ) ;
22823: LD_ADDR_VAR 0 5
22827: PUSH
22828: LD_VAR 0 1
22832: PPUSH
22833: CALL_OW 274
22837: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
22838: LD_ADDR_VAR 0 4
22842: PUSH
22843: LD_VAR 0 2
22847: PUSH
22848: LD_INT 1
22850: ARRAY
22851: PPUSH
22852: LD_VAR 0 2
22856: PUSH
22857: LD_INT 2
22859: ARRAY
22860: PPUSH
22861: LD_VAR 0 2
22865: PUSH
22866: LD_INT 3
22868: ARRAY
22869: PPUSH
22870: LD_VAR 0 2
22874: PUSH
22875: LD_INT 4
22877: ARRAY
22878: PPUSH
22879: CALL_OW 449
22883: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22884: LD_ADDR_VAR 0 3
22888: PUSH
22889: LD_VAR 0 5
22893: PPUSH
22894: LD_INT 1
22896: PPUSH
22897: CALL_OW 275
22901: PUSH
22902: LD_VAR 0 4
22906: PUSH
22907: LD_INT 1
22909: ARRAY
22910: GREATEREQUAL
22911: PUSH
22912: LD_VAR 0 5
22916: PPUSH
22917: LD_INT 2
22919: PPUSH
22920: CALL_OW 275
22924: PUSH
22925: LD_VAR 0 4
22929: PUSH
22930: LD_INT 2
22932: ARRAY
22933: GREATEREQUAL
22934: AND
22935: PUSH
22936: LD_VAR 0 5
22940: PPUSH
22941: LD_INT 3
22943: PPUSH
22944: CALL_OW 275
22948: PUSH
22949: LD_VAR 0 4
22953: PUSH
22954: LD_INT 3
22956: ARRAY
22957: GREATEREQUAL
22958: AND
22959: ST_TO_ADDR
// end ;
22960: LD_VAR 0 3
22964: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
22965: LD_INT 0
22967: PPUSH
22968: PPUSH
22969: PPUSH
22970: PPUSH
// pom := GetBase ( building ) ;
22971: LD_ADDR_VAR 0 3
22975: PUSH
22976: LD_VAR 0 1
22980: PPUSH
22981: CALL_OW 274
22985: ST_TO_ADDR
// if not pom then
22986: LD_VAR 0 3
22990: NOT
22991: IFFALSE 22995
// exit ;
22993: GO 23165
// btype := GetBType ( building ) ;
22995: LD_ADDR_VAR 0 5
22999: PUSH
23000: LD_VAR 0 1
23004: PPUSH
23005: CALL_OW 266
23009: ST_TO_ADDR
// if btype = b_armoury then
23010: LD_VAR 0 5
23014: PUSH
23015: LD_INT 4
23017: EQUAL
23018: IFFALSE 23028
// btype := b_barracks ;
23020: LD_ADDR_VAR 0 5
23024: PUSH
23025: LD_INT 5
23027: ST_TO_ADDR
// if btype = b_depot then
23028: LD_VAR 0 5
23032: PUSH
23033: LD_INT 0
23035: EQUAL
23036: IFFALSE 23046
// btype := b_warehouse ;
23038: LD_ADDR_VAR 0 5
23042: PUSH
23043: LD_INT 1
23045: ST_TO_ADDR
// if btype = b_workshop then
23046: LD_VAR 0 5
23050: PUSH
23051: LD_INT 2
23053: EQUAL
23054: IFFALSE 23064
// btype := b_factory ;
23056: LD_ADDR_VAR 0 5
23060: PUSH
23061: LD_INT 3
23063: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
23064: LD_ADDR_VAR 0 4
23068: PUSH
23069: LD_VAR 0 5
23073: PPUSH
23074: LD_VAR 0 1
23078: PPUSH
23079: CALL_OW 248
23083: PPUSH
23084: CALL_OW 450
23088: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
23089: LD_ADDR_VAR 0 2
23093: PUSH
23094: LD_VAR 0 3
23098: PPUSH
23099: LD_INT 1
23101: PPUSH
23102: CALL_OW 275
23106: PUSH
23107: LD_VAR 0 4
23111: PUSH
23112: LD_INT 1
23114: ARRAY
23115: GREATEREQUAL
23116: PUSH
23117: LD_VAR 0 3
23121: PPUSH
23122: LD_INT 2
23124: PPUSH
23125: CALL_OW 275
23129: PUSH
23130: LD_VAR 0 4
23134: PUSH
23135: LD_INT 2
23137: ARRAY
23138: GREATEREQUAL
23139: AND
23140: PUSH
23141: LD_VAR 0 3
23145: PPUSH
23146: LD_INT 3
23148: PPUSH
23149: CALL_OW 275
23153: PUSH
23154: LD_VAR 0 4
23158: PUSH
23159: LD_INT 3
23161: ARRAY
23162: GREATEREQUAL
23163: AND
23164: ST_TO_ADDR
// end ;
23165: LD_VAR 0 2
23169: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
23170: LD_INT 0
23172: PPUSH
23173: PPUSH
23174: PPUSH
// pom := GetBase ( building ) ;
23175: LD_ADDR_VAR 0 4
23179: PUSH
23180: LD_VAR 0 1
23184: PPUSH
23185: CALL_OW 274
23189: ST_TO_ADDR
// if not pom then
23190: LD_VAR 0 4
23194: NOT
23195: IFFALSE 23199
// exit ;
23197: GO 23300
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
23199: LD_ADDR_VAR 0 5
23203: PUSH
23204: LD_VAR 0 2
23208: PPUSH
23209: LD_VAR 0 1
23213: PPUSH
23214: CALL_OW 248
23218: PPUSH
23219: CALL_OW 450
23223: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
23224: LD_ADDR_VAR 0 3
23228: PUSH
23229: LD_VAR 0 4
23233: PPUSH
23234: LD_INT 1
23236: PPUSH
23237: CALL_OW 275
23241: PUSH
23242: LD_VAR 0 5
23246: PUSH
23247: LD_INT 1
23249: ARRAY
23250: GREATEREQUAL
23251: PUSH
23252: LD_VAR 0 4
23256: PPUSH
23257: LD_INT 2
23259: PPUSH
23260: CALL_OW 275
23264: PUSH
23265: LD_VAR 0 5
23269: PUSH
23270: LD_INT 2
23272: ARRAY
23273: GREATEREQUAL
23274: AND
23275: PUSH
23276: LD_VAR 0 4
23280: PPUSH
23281: LD_INT 3
23283: PPUSH
23284: CALL_OW 275
23288: PUSH
23289: LD_VAR 0 5
23293: PUSH
23294: LD_INT 3
23296: ARRAY
23297: GREATEREQUAL
23298: AND
23299: ST_TO_ADDR
// end ;
23300: LD_VAR 0 3
23304: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
23305: LD_INT 0
23307: PPUSH
23308: PPUSH
23309: PPUSH
23310: PPUSH
23311: PPUSH
23312: PPUSH
23313: PPUSH
23314: PPUSH
23315: PPUSH
23316: PPUSH
23317: PPUSH
// result := false ;
23318: LD_ADDR_VAR 0 8
23322: PUSH
23323: LD_INT 0
23325: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
23326: LD_VAR 0 5
23330: NOT
23331: PUSH
23332: LD_VAR 0 1
23336: NOT
23337: OR
23338: PUSH
23339: LD_VAR 0 2
23343: NOT
23344: OR
23345: PUSH
23346: LD_VAR 0 3
23350: NOT
23351: OR
23352: IFFALSE 23356
// exit ;
23354: GO 24170
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
23356: LD_ADDR_VAR 0 14
23360: PUSH
23361: LD_VAR 0 1
23365: PPUSH
23366: LD_VAR 0 2
23370: PPUSH
23371: LD_VAR 0 3
23375: PPUSH
23376: LD_VAR 0 4
23380: PPUSH
23381: LD_VAR 0 5
23385: PUSH
23386: LD_INT 1
23388: ARRAY
23389: PPUSH
23390: CALL_OW 248
23394: PPUSH
23395: LD_INT 0
23397: PPUSH
23398: CALL 25423 0 6
23402: ST_TO_ADDR
// if not hexes then
23403: LD_VAR 0 14
23407: NOT
23408: IFFALSE 23412
// exit ;
23410: GO 24170
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
23412: LD_ADDR_VAR 0 17
23416: PUSH
23417: LD_VAR 0 5
23421: PPUSH
23422: LD_INT 22
23424: PUSH
23425: LD_VAR 0 13
23429: PPUSH
23430: CALL_OW 255
23434: PUSH
23435: EMPTY
23436: LIST
23437: LIST
23438: PUSH
23439: LD_INT 2
23441: PUSH
23442: LD_INT 30
23444: PUSH
23445: LD_INT 0
23447: PUSH
23448: EMPTY
23449: LIST
23450: LIST
23451: PUSH
23452: LD_INT 30
23454: PUSH
23455: LD_INT 1
23457: PUSH
23458: EMPTY
23459: LIST
23460: LIST
23461: PUSH
23462: EMPTY
23463: LIST
23464: LIST
23465: LIST
23466: PUSH
23467: EMPTY
23468: LIST
23469: LIST
23470: PPUSH
23471: CALL_OW 72
23475: ST_TO_ADDR
// for i = 1 to hexes do
23476: LD_ADDR_VAR 0 9
23480: PUSH
23481: DOUBLE
23482: LD_INT 1
23484: DEC
23485: ST_TO_ADDR
23486: LD_VAR 0 14
23490: PUSH
23491: FOR_TO
23492: IFFALSE 24168
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
23494: LD_ADDR_VAR 0 13
23498: PUSH
23499: LD_VAR 0 14
23503: PUSH
23504: LD_VAR 0 9
23508: ARRAY
23509: PUSH
23510: LD_INT 1
23512: ARRAY
23513: PPUSH
23514: LD_VAR 0 14
23518: PUSH
23519: LD_VAR 0 9
23523: ARRAY
23524: PUSH
23525: LD_INT 2
23527: ARRAY
23528: PPUSH
23529: CALL_OW 428
23533: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
23534: LD_VAR 0 14
23538: PUSH
23539: LD_VAR 0 9
23543: ARRAY
23544: PUSH
23545: LD_INT 1
23547: ARRAY
23548: PPUSH
23549: LD_VAR 0 14
23553: PUSH
23554: LD_VAR 0 9
23558: ARRAY
23559: PUSH
23560: LD_INT 2
23562: ARRAY
23563: PPUSH
23564: CALL_OW 351
23568: PUSH
23569: LD_VAR 0 14
23573: PUSH
23574: LD_VAR 0 9
23578: ARRAY
23579: PUSH
23580: LD_INT 1
23582: ARRAY
23583: PPUSH
23584: LD_VAR 0 14
23588: PUSH
23589: LD_VAR 0 9
23593: ARRAY
23594: PUSH
23595: LD_INT 2
23597: ARRAY
23598: PPUSH
23599: CALL_OW 488
23603: NOT
23604: OR
23605: PUSH
23606: LD_VAR 0 13
23610: PPUSH
23611: CALL_OW 247
23615: PUSH
23616: LD_INT 3
23618: EQUAL
23619: OR
23620: IFFALSE 23626
// exit ;
23622: POP
23623: POP
23624: GO 24170
// if not tmp then
23626: LD_VAR 0 13
23630: NOT
23631: IFFALSE 23635
// continue ;
23633: GO 23491
// result := true ;
23635: LD_ADDR_VAR 0 8
23639: PUSH
23640: LD_INT 1
23642: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
23643: LD_VAR 0 6
23647: PUSH
23648: LD_VAR 0 13
23652: PPUSH
23653: CALL_OW 247
23657: PUSH
23658: LD_INT 2
23660: EQUAL
23661: AND
23662: PUSH
23663: LD_VAR 0 13
23667: PPUSH
23668: CALL_OW 263
23672: PUSH
23673: LD_INT 1
23675: EQUAL
23676: AND
23677: IFFALSE 23841
// begin if IsDrivenBy ( tmp ) then
23679: LD_VAR 0 13
23683: PPUSH
23684: CALL_OW 311
23688: IFFALSE 23692
// continue ;
23690: GO 23491
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
23692: LD_VAR 0 6
23696: PPUSH
23697: LD_INT 3
23699: PUSH
23700: LD_INT 60
23702: PUSH
23703: EMPTY
23704: LIST
23705: PUSH
23706: EMPTY
23707: LIST
23708: LIST
23709: PUSH
23710: LD_INT 3
23712: PUSH
23713: LD_INT 55
23715: PUSH
23716: EMPTY
23717: LIST
23718: PUSH
23719: EMPTY
23720: LIST
23721: LIST
23722: PUSH
23723: EMPTY
23724: LIST
23725: LIST
23726: PPUSH
23727: CALL_OW 72
23731: IFFALSE 23839
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
23733: LD_ADDR_VAR 0 18
23737: PUSH
23738: LD_VAR 0 6
23742: PPUSH
23743: LD_INT 3
23745: PUSH
23746: LD_INT 60
23748: PUSH
23749: EMPTY
23750: LIST
23751: PUSH
23752: EMPTY
23753: LIST
23754: LIST
23755: PUSH
23756: LD_INT 3
23758: PUSH
23759: LD_INT 55
23761: PUSH
23762: EMPTY
23763: LIST
23764: PUSH
23765: EMPTY
23766: LIST
23767: LIST
23768: PUSH
23769: EMPTY
23770: LIST
23771: LIST
23772: PPUSH
23773: CALL_OW 72
23777: PUSH
23778: LD_INT 1
23780: ARRAY
23781: ST_TO_ADDR
// if IsInUnit ( driver ) then
23782: LD_VAR 0 18
23786: PPUSH
23787: CALL_OW 310
23791: IFFALSE 23802
// ComExit ( driver ) ;
23793: LD_VAR 0 18
23797: PPUSH
23798: CALL 49215 0 1
// AddComEnterUnit ( driver , tmp ) ;
23802: LD_VAR 0 18
23806: PPUSH
23807: LD_VAR 0 13
23811: PPUSH
23812: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
23816: LD_VAR 0 18
23820: PPUSH
23821: LD_VAR 0 7
23825: PPUSH
23826: CALL_OW 173
// AddComExitVehicle ( driver ) ;
23830: LD_VAR 0 18
23834: PPUSH
23835: CALL_OW 181
// end ; continue ;
23839: GO 23491
// end ; if not cleaners or not tmp in cleaners then
23841: LD_VAR 0 6
23845: NOT
23846: PUSH
23847: LD_VAR 0 13
23851: PUSH
23852: LD_VAR 0 6
23856: IN
23857: NOT
23858: OR
23859: IFFALSE 24166
// begin if dep then
23861: LD_VAR 0 17
23865: IFFALSE 24001
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
23867: LD_ADDR_VAR 0 16
23871: PUSH
23872: LD_VAR 0 17
23876: PUSH
23877: LD_INT 1
23879: ARRAY
23880: PPUSH
23881: CALL_OW 250
23885: PPUSH
23886: LD_VAR 0 17
23890: PUSH
23891: LD_INT 1
23893: ARRAY
23894: PPUSH
23895: CALL_OW 254
23899: PPUSH
23900: LD_INT 5
23902: PPUSH
23903: CALL_OW 272
23907: PUSH
23908: LD_VAR 0 17
23912: PUSH
23913: LD_INT 1
23915: ARRAY
23916: PPUSH
23917: CALL_OW 251
23921: PPUSH
23922: LD_VAR 0 17
23926: PUSH
23927: LD_INT 1
23929: ARRAY
23930: PPUSH
23931: CALL_OW 254
23935: PPUSH
23936: LD_INT 5
23938: PPUSH
23939: CALL_OW 273
23943: PUSH
23944: EMPTY
23945: LIST
23946: LIST
23947: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
23948: LD_VAR 0 16
23952: PUSH
23953: LD_INT 1
23955: ARRAY
23956: PPUSH
23957: LD_VAR 0 16
23961: PUSH
23962: LD_INT 2
23964: ARRAY
23965: PPUSH
23966: CALL_OW 488
23970: IFFALSE 24001
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
23972: LD_VAR 0 13
23976: PPUSH
23977: LD_VAR 0 16
23981: PUSH
23982: LD_INT 1
23984: ARRAY
23985: PPUSH
23986: LD_VAR 0 16
23990: PUSH
23991: LD_INT 2
23993: ARRAY
23994: PPUSH
23995: CALL_OW 111
// continue ;
23999: GO 23491
// end ; end ; r := GetDir ( tmp ) ;
24001: LD_ADDR_VAR 0 15
24005: PUSH
24006: LD_VAR 0 13
24010: PPUSH
24011: CALL_OW 254
24015: ST_TO_ADDR
// if r = 5 then
24016: LD_VAR 0 15
24020: PUSH
24021: LD_INT 5
24023: EQUAL
24024: IFFALSE 24034
// r := 0 ;
24026: LD_ADDR_VAR 0 15
24030: PUSH
24031: LD_INT 0
24033: ST_TO_ADDR
// for j = r to 5 do
24034: LD_ADDR_VAR 0 10
24038: PUSH
24039: DOUBLE
24040: LD_VAR 0 15
24044: DEC
24045: ST_TO_ADDR
24046: LD_INT 5
24048: PUSH
24049: FOR_TO
24050: IFFALSE 24164
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
24052: LD_ADDR_VAR 0 11
24056: PUSH
24057: LD_VAR 0 13
24061: PPUSH
24062: CALL_OW 250
24066: PPUSH
24067: LD_VAR 0 10
24071: PPUSH
24072: LD_INT 2
24074: PPUSH
24075: CALL_OW 272
24079: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
24080: LD_ADDR_VAR 0 12
24084: PUSH
24085: LD_VAR 0 13
24089: PPUSH
24090: CALL_OW 251
24094: PPUSH
24095: LD_VAR 0 10
24099: PPUSH
24100: LD_INT 2
24102: PPUSH
24103: CALL_OW 273
24107: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
24108: LD_VAR 0 11
24112: PPUSH
24113: LD_VAR 0 12
24117: PPUSH
24118: CALL_OW 488
24122: PUSH
24123: LD_VAR 0 11
24127: PPUSH
24128: LD_VAR 0 12
24132: PPUSH
24133: CALL_OW 428
24137: NOT
24138: AND
24139: IFFALSE 24162
// begin ComMoveXY ( tmp , _x , _y ) ;
24141: LD_VAR 0 13
24145: PPUSH
24146: LD_VAR 0 11
24150: PPUSH
24151: LD_VAR 0 12
24155: PPUSH
24156: CALL_OW 111
// break ;
24160: GO 24164
// end ; end ;
24162: GO 24049
24164: POP
24165: POP
// end ; end ;
24166: GO 23491
24168: POP
24169: POP
// end ;
24170: LD_VAR 0 8
24174: RET
// export function BuildingTechInvented ( side , btype ) ; begin
24175: LD_INT 0
24177: PPUSH
// result := true ;
24178: LD_ADDR_VAR 0 3
24182: PUSH
24183: LD_INT 1
24185: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
24186: LD_VAR 0 2
24190: PUSH
24191: LD_INT 24
24193: DOUBLE
24194: EQUAL
24195: IFTRUE 24205
24197: LD_INT 33
24199: DOUBLE
24200: EQUAL
24201: IFTRUE 24205
24203: GO 24230
24205: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
24206: LD_ADDR_VAR 0 3
24210: PUSH
24211: LD_INT 32
24213: PPUSH
24214: LD_VAR 0 1
24218: PPUSH
24219: CALL_OW 321
24223: PUSH
24224: LD_INT 2
24226: EQUAL
24227: ST_TO_ADDR
24228: GO 24546
24230: LD_INT 20
24232: DOUBLE
24233: EQUAL
24234: IFTRUE 24238
24236: GO 24263
24238: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
24239: LD_ADDR_VAR 0 3
24243: PUSH
24244: LD_INT 6
24246: PPUSH
24247: LD_VAR 0 1
24251: PPUSH
24252: CALL_OW 321
24256: PUSH
24257: LD_INT 2
24259: EQUAL
24260: ST_TO_ADDR
24261: GO 24546
24263: LD_INT 22
24265: DOUBLE
24266: EQUAL
24267: IFTRUE 24277
24269: LD_INT 36
24271: DOUBLE
24272: EQUAL
24273: IFTRUE 24277
24275: GO 24302
24277: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
24278: LD_ADDR_VAR 0 3
24282: PUSH
24283: LD_INT 15
24285: PPUSH
24286: LD_VAR 0 1
24290: PPUSH
24291: CALL_OW 321
24295: PUSH
24296: LD_INT 2
24298: EQUAL
24299: ST_TO_ADDR
24300: GO 24546
24302: LD_INT 30
24304: DOUBLE
24305: EQUAL
24306: IFTRUE 24310
24308: GO 24335
24310: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
24311: LD_ADDR_VAR 0 3
24315: PUSH
24316: LD_INT 20
24318: PPUSH
24319: LD_VAR 0 1
24323: PPUSH
24324: CALL_OW 321
24328: PUSH
24329: LD_INT 2
24331: EQUAL
24332: ST_TO_ADDR
24333: GO 24546
24335: LD_INT 28
24337: DOUBLE
24338: EQUAL
24339: IFTRUE 24349
24341: LD_INT 21
24343: DOUBLE
24344: EQUAL
24345: IFTRUE 24349
24347: GO 24374
24349: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
24350: LD_ADDR_VAR 0 3
24354: PUSH
24355: LD_INT 21
24357: PPUSH
24358: LD_VAR 0 1
24362: PPUSH
24363: CALL_OW 321
24367: PUSH
24368: LD_INT 2
24370: EQUAL
24371: ST_TO_ADDR
24372: GO 24546
24374: LD_INT 16
24376: DOUBLE
24377: EQUAL
24378: IFTRUE 24382
24380: GO 24407
24382: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
24383: LD_ADDR_VAR 0 3
24387: PUSH
24388: LD_INT 84
24390: PPUSH
24391: LD_VAR 0 1
24395: PPUSH
24396: CALL_OW 321
24400: PUSH
24401: LD_INT 2
24403: EQUAL
24404: ST_TO_ADDR
24405: GO 24546
24407: LD_INT 19
24409: DOUBLE
24410: EQUAL
24411: IFTRUE 24421
24413: LD_INT 23
24415: DOUBLE
24416: EQUAL
24417: IFTRUE 24421
24419: GO 24446
24421: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
24422: LD_ADDR_VAR 0 3
24426: PUSH
24427: LD_INT 83
24429: PPUSH
24430: LD_VAR 0 1
24434: PPUSH
24435: CALL_OW 321
24439: PUSH
24440: LD_INT 2
24442: EQUAL
24443: ST_TO_ADDR
24444: GO 24546
24446: LD_INT 17
24448: DOUBLE
24449: EQUAL
24450: IFTRUE 24454
24452: GO 24479
24454: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
24455: LD_ADDR_VAR 0 3
24459: PUSH
24460: LD_INT 39
24462: PPUSH
24463: LD_VAR 0 1
24467: PPUSH
24468: CALL_OW 321
24472: PUSH
24473: LD_INT 2
24475: EQUAL
24476: ST_TO_ADDR
24477: GO 24546
24479: LD_INT 18
24481: DOUBLE
24482: EQUAL
24483: IFTRUE 24487
24485: GO 24512
24487: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
24488: LD_ADDR_VAR 0 3
24492: PUSH
24493: LD_INT 40
24495: PPUSH
24496: LD_VAR 0 1
24500: PPUSH
24501: CALL_OW 321
24505: PUSH
24506: LD_INT 2
24508: EQUAL
24509: ST_TO_ADDR
24510: GO 24546
24512: LD_INT 27
24514: DOUBLE
24515: EQUAL
24516: IFTRUE 24520
24518: GO 24545
24520: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
24521: LD_ADDR_VAR 0 3
24525: PUSH
24526: LD_INT 35
24528: PPUSH
24529: LD_VAR 0 1
24533: PPUSH
24534: CALL_OW 321
24538: PUSH
24539: LD_INT 2
24541: EQUAL
24542: ST_TO_ADDR
24543: GO 24546
24545: POP
// end ;
24546: LD_VAR 0 3
24550: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
24551: LD_INT 0
24553: PPUSH
24554: PPUSH
24555: PPUSH
24556: PPUSH
24557: PPUSH
24558: PPUSH
24559: PPUSH
24560: PPUSH
24561: PPUSH
24562: PPUSH
24563: PPUSH
// result := false ;
24564: LD_ADDR_VAR 0 6
24568: PUSH
24569: LD_INT 0
24571: ST_TO_ADDR
// if btype = b_depot then
24572: LD_VAR 0 2
24576: PUSH
24577: LD_INT 0
24579: EQUAL
24580: IFFALSE 24592
// begin result := true ;
24582: LD_ADDR_VAR 0 6
24586: PUSH
24587: LD_INT 1
24589: ST_TO_ADDR
// exit ;
24590: GO 25418
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
24592: LD_VAR 0 1
24596: NOT
24597: PUSH
24598: LD_VAR 0 1
24602: PPUSH
24603: CALL_OW 266
24607: PUSH
24608: LD_INT 0
24610: PUSH
24611: LD_INT 1
24613: PUSH
24614: EMPTY
24615: LIST
24616: LIST
24617: IN
24618: NOT
24619: OR
24620: PUSH
24621: LD_VAR 0 2
24625: NOT
24626: OR
24627: PUSH
24628: LD_VAR 0 5
24632: PUSH
24633: LD_INT 0
24635: PUSH
24636: LD_INT 1
24638: PUSH
24639: LD_INT 2
24641: PUSH
24642: LD_INT 3
24644: PUSH
24645: LD_INT 4
24647: PUSH
24648: LD_INT 5
24650: PUSH
24651: EMPTY
24652: LIST
24653: LIST
24654: LIST
24655: LIST
24656: LIST
24657: LIST
24658: IN
24659: NOT
24660: OR
24661: PUSH
24662: LD_VAR 0 3
24666: PPUSH
24667: LD_VAR 0 4
24671: PPUSH
24672: CALL_OW 488
24676: NOT
24677: OR
24678: IFFALSE 24682
// exit ;
24680: GO 25418
// side := GetSide ( depot ) ;
24682: LD_ADDR_VAR 0 9
24686: PUSH
24687: LD_VAR 0 1
24691: PPUSH
24692: CALL_OW 255
24696: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
24697: LD_VAR 0 9
24701: PPUSH
24702: LD_VAR 0 2
24706: PPUSH
24707: CALL 24175 0 2
24711: NOT
24712: IFFALSE 24716
// exit ;
24714: GO 25418
// pom := GetBase ( depot ) ;
24716: LD_ADDR_VAR 0 10
24720: PUSH
24721: LD_VAR 0 1
24725: PPUSH
24726: CALL_OW 274
24730: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
24731: LD_ADDR_VAR 0 11
24735: PUSH
24736: LD_VAR 0 2
24740: PPUSH
24741: LD_VAR 0 1
24745: PPUSH
24746: CALL_OW 248
24750: PPUSH
24751: CALL_OW 450
24755: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
24756: LD_VAR 0 10
24760: PPUSH
24761: LD_INT 1
24763: PPUSH
24764: CALL_OW 275
24768: PUSH
24769: LD_VAR 0 11
24773: PUSH
24774: LD_INT 1
24776: ARRAY
24777: GREATEREQUAL
24778: PUSH
24779: LD_VAR 0 10
24783: PPUSH
24784: LD_INT 2
24786: PPUSH
24787: CALL_OW 275
24791: PUSH
24792: LD_VAR 0 11
24796: PUSH
24797: LD_INT 2
24799: ARRAY
24800: GREATEREQUAL
24801: AND
24802: PUSH
24803: LD_VAR 0 10
24807: PPUSH
24808: LD_INT 3
24810: PPUSH
24811: CALL_OW 275
24815: PUSH
24816: LD_VAR 0 11
24820: PUSH
24821: LD_INT 3
24823: ARRAY
24824: GREATEREQUAL
24825: AND
24826: NOT
24827: IFFALSE 24831
// exit ;
24829: GO 25418
// if GetBType ( depot ) = b_depot then
24831: LD_VAR 0 1
24835: PPUSH
24836: CALL_OW 266
24840: PUSH
24841: LD_INT 0
24843: EQUAL
24844: IFFALSE 24856
// dist := 28 else
24846: LD_ADDR_VAR 0 14
24850: PUSH
24851: LD_INT 28
24853: ST_TO_ADDR
24854: GO 24864
// dist := 36 ;
24856: LD_ADDR_VAR 0 14
24860: PUSH
24861: LD_INT 36
24863: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
24864: LD_VAR 0 1
24868: PPUSH
24869: LD_VAR 0 3
24873: PPUSH
24874: LD_VAR 0 4
24878: PPUSH
24879: CALL_OW 297
24883: PUSH
24884: LD_VAR 0 14
24888: GREATER
24889: IFFALSE 24893
// exit ;
24891: GO 25418
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
24893: LD_ADDR_VAR 0 12
24897: PUSH
24898: LD_VAR 0 2
24902: PPUSH
24903: LD_VAR 0 3
24907: PPUSH
24908: LD_VAR 0 4
24912: PPUSH
24913: LD_VAR 0 5
24917: PPUSH
24918: LD_VAR 0 1
24922: PPUSH
24923: CALL_OW 248
24927: PPUSH
24928: LD_INT 0
24930: PPUSH
24931: CALL 25423 0 6
24935: ST_TO_ADDR
// if not hexes then
24936: LD_VAR 0 12
24940: NOT
24941: IFFALSE 24945
// exit ;
24943: GO 25418
// hex := GetHexInfo ( x , y ) ;
24945: LD_ADDR_VAR 0 15
24949: PUSH
24950: LD_VAR 0 3
24954: PPUSH
24955: LD_VAR 0 4
24959: PPUSH
24960: CALL_OW 546
24964: ST_TO_ADDR
// if hex [ 1 ] then
24965: LD_VAR 0 15
24969: PUSH
24970: LD_INT 1
24972: ARRAY
24973: IFFALSE 24977
// exit ;
24975: GO 25418
// height := hex [ 2 ] ;
24977: LD_ADDR_VAR 0 13
24981: PUSH
24982: LD_VAR 0 15
24986: PUSH
24987: LD_INT 2
24989: ARRAY
24990: ST_TO_ADDR
// for i = 1 to hexes do
24991: LD_ADDR_VAR 0 7
24995: PUSH
24996: DOUBLE
24997: LD_INT 1
24999: DEC
25000: ST_TO_ADDR
25001: LD_VAR 0 12
25005: PUSH
25006: FOR_TO
25007: IFFALSE 25337
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
25009: LD_VAR 0 12
25013: PUSH
25014: LD_VAR 0 7
25018: ARRAY
25019: PUSH
25020: LD_INT 1
25022: ARRAY
25023: PPUSH
25024: LD_VAR 0 12
25028: PUSH
25029: LD_VAR 0 7
25033: ARRAY
25034: PUSH
25035: LD_INT 2
25037: ARRAY
25038: PPUSH
25039: CALL_OW 488
25043: NOT
25044: PUSH
25045: LD_VAR 0 12
25049: PUSH
25050: LD_VAR 0 7
25054: ARRAY
25055: PUSH
25056: LD_INT 1
25058: ARRAY
25059: PPUSH
25060: LD_VAR 0 12
25064: PUSH
25065: LD_VAR 0 7
25069: ARRAY
25070: PUSH
25071: LD_INT 2
25073: ARRAY
25074: PPUSH
25075: CALL_OW 428
25079: PUSH
25080: LD_INT 0
25082: GREATER
25083: OR
25084: PUSH
25085: LD_VAR 0 12
25089: PUSH
25090: LD_VAR 0 7
25094: ARRAY
25095: PUSH
25096: LD_INT 1
25098: ARRAY
25099: PPUSH
25100: LD_VAR 0 12
25104: PUSH
25105: LD_VAR 0 7
25109: ARRAY
25110: PUSH
25111: LD_INT 2
25113: ARRAY
25114: PPUSH
25115: CALL_OW 351
25119: OR
25120: IFFALSE 25126
// exit ;
25122: POP
25123: POP
25124: GO 25418
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
25126: LD_ADDR_VAR 0 8
25130: PUSH
25131: LD_VAR 0 12
25135: PUSH
25136: LD_VAR 0 7
25140: ARRAY
25141: PUSH
25142: LD_INT 1
25144: ARRAY
25145: PPUSH
25146: LD_VAR 0 12
25150: PUSH
25151: LD_VAR 0 7
25155: ARRAY
25156: PUSH
25157: LD_INT 2
25159: ARRAY
25160: PPUSH
25161: CALL_OW 546
25165: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
25166: LD_VAR 0 8
25170: PUSH
25171: LD_INT 1
25173: ARRAY
25174: PUSH
25175: LD_VAR 0 8
25179: PUSH
25180: LD_INT 2
25182: ARRAY
25183: PUSH
25184: LD_VAR 0 13
25188: PUSH
25189: LD_INT 2
25191: PLUS
25192: GREATER
25193: OR
25194: PUSH
25195: LD_VAR 0 8
25199: PUSH
25200: LD_INT 2
25202: ARRAY
25203: PUSH
25204: LD_VAR 0 13
25208: PUSH
25209: LD_INT 2
25211: MINUS
25212: LESS
25213: OR
25214: PUSH
25215: LD_VAR 0 8
25219: PUSH
25220: LD_INT 3
25222: ARRAY
25223: PUSH
25224: LD_INT 0
25226: PUSH
25227: LD_INT 8
25229: PUSH
25230: LD_INT 9
25232: PUSH
25233: LD_INT 10
25235: PUSH
25236: LD_INT 11
25238: PUSH
25239: LD_INT 12
25241: PUSH
25242: LD_INT 13
25244: PUSH
25245: LD_INT 16
25247: PUSH
25248: LD_INT 17
25250: PUSH
25251: LD_INT 18
25253: PUSH
25254: LD_INT 19
25256: PUSH
25257: LD_INT 20
25259: PUSH
25260: LD_INT 21
25262: PUSH
25263: EMPTY
25264: LIST
25265: LIST
25266: LIST
25267: LIST
25268: LIST
25269: LIST
25270: LIST
25271: LIST
25272: LIST
25273: LIST
25274: LIST
25275: LIST
25276: LIST
25277: IN
25278: NOT
25279: OR
25280: PUSH
25281: LD_VAR 0 8
25285: PUSH
25286: LD_INT 5
25288: ARRAY
25289: NOT
25290: OR
25291: PUSH
25292: LD_VAR 0 8
25296: PUSH
25297: LD_INT 6
25299: ARRAY
25300: PUSH
25301: LD_INT 1
25303: PUSH
25304: LD_INT 2
25306: PUSH
25307: LD_INT 7
25309: PUSH
25310: LD_INT 9
25312: PUSH
25313: LD_INT 10
25315: PUSH
25316: LD_INT 11
25318: PUSH
25319: EMPTY
25320: LIST
25321: LIST
25322: LIST
25323: LIST
25324: LIST
25325: LIST
25326: IN
25327: NOT
25328: OR
25329: IFFALSE 25335
// exit ;
25331: POP
25332: POP
25333: GO 25418
// end ;
25335: GO 25006
25337: POP
25338: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
25339: LD_VAR 0 9
25343: PPUSH
25344: LD_VAR 0 3
25348: PPUSH
25349: LD_VAR 0 4
25353: PPUSH
25354: LD_INT 20
25356: PPUSH
25357: CALL 17341 0 4
25361: PUSH
25362: LD_INT 4
25364: ARRAY
25365: IFFALSE 25369
// exit ;
25367: GO 25418
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
25369: LD_VAR 0 2
25373: PUSH
25374: LD_INT 29
25376: PUSH
25377: LD_INT 30
25379: PUSH
25380: EMPTY
25381: LIST
25382: LIST
25383: IN
25384: PUSH
25385: LD_VAR 0 3
25389: PPUSH
25390: LD_VAR 0 4
25394: PPUSH
25395: LD_VAR 0 9
25399: PPUSH
25400: CALL_OW 440
25404: NOT
25405: AND
25406: IFFALSE 25410
// exit ;
25408: GO 25418
// result := true ;
25410: LD_ADDR_VAR 0 6
25414: PUSH
25415: LD_INT 1
25417: ST_TO_ADDR
// end ;
25418: LD_VAR 0 6
25422: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
25423: LD_INT 0
25425: PPUSH
25426: PPUSH
25427: PPUSH
25428: PPUSH
25429: PPUSH
25430: PPUSH
25431: PPUSH
25432: PPUSH
25433: PPUSH
25434: PPUSH
25435: PPUSH
25436: PPUSH
25437: PPUSH
25438: PPUSH
25439: PPUSH
25440: PPUSH
25441: PPUSH
25442: PPUSH
25443: PPUSH
25444: PPUSH
25445: PPUSH
25446: PPUSH
25447: PPUSH
25448: PPUSH
25449: PPUSH
25450: PPUSH
25451: PPUSH
25452: PPUSH
25453: PPUSH
25454: PPUSH
25455: PPUSH
25456: PPUSH
25457: PPUSH
25458: PPUSH
25459: PPUSH
25460: PPUSH
25461: PPUSH
25462: PPUSH
25463: PPUSH
25464: PPUSH
25465: PPUSH
25466: PPUSH
25467: PPUSH
25468: PPUSH
25469: PPUSH
25470: PPUSH
25471: PPUSH
25472: PPUSH
25473: PPUSH
25474: PPUSH
25475: PPUSH
25476: PPUSH
25477: PPUSH
25478: PPUSH
25479: PPUSH
25480: PPUSH
25481: PPUSH
25482: PPUSH
// result = [ ] ;
25483: LD_ADDR_VAR 0 7
25487: PUSH
25488: EMPTY
25489: ST_TO_ADDR
// temp_list = [ ] ;
25490: LD_ADDR_VAR 0 9
25494: PUSH
25495: EMPTY
25496: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
25497: LD_VAR 0 4
25501: PUSH
25502: LD_INT 0
25504: PUSH
25505: LD_INT 1
25507: PUSH
25508: LD_INT 2
25510: PUSH
25511: LD_INT 3
25513: PUSH
25514: LD_INT 4
25516: PUSH
25517: LD_INT 5
25519: PUSH
25520: EMPTY
25521: LIST
25522: LIST
25523: LIST
25524: LIST
25525: LIST
25526: LIST
25527: IN
25528: NOT
25529: PUSH
25530: LD_VAR 0 1
25534: PUSH
25535: LD_INT 0
25537: PUSH
25538: LD_INT 1
25540: PUSH
25541: EMPTY
25542: LIST
25543: LIST
25544: IN
25545: PUSH
25546: LD_VAR 0 5
25550: PUSH
25551: LD_INT 1
25553: PUSH
25554: LD_INT 2
25556: PUSH
25557: LD_INT 3
25559: PUSH
25560: EMPTY
25561: LIST
25562: LIST
25563: LIST
25564: IN
25565: NOT
25566: AND
25567: OR
25568: IFFALSE 25572
// exit ;
25570: GO 43963
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
25572: LD_VAR 0 1
25576: PUSH
25577: LD_INT 6
25579: PUSH
25580: LD_INT 7
25582: PUSH
25583: LD_INT 8
25585: PUSH
25586: LD_INT 13
25588: PUSH
25589: LD_INT 12
25591: PUSH
25592: LD_INT 15
25594: PUSH
25595: LD_INT 11
25597: PUSH
25598: LD_INT 14
25600: PUSH
25601: LD_INT 10
25603: PUSH
25604: EMPTY
25605: LIST
25606: LIST
25607: LIST
25608: LIST
25609: LIST
25610: LIST
25611: LIST
25612: LIST
25613: LIST
25614: IN
25615: IFFALSE 25625
// btype = b_lab ;
25617: LD_ADDR_VAR 0 1
25621: PUSH
25622: LD_INT 6
25624: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
25625: LD_VAR 0 6
25629: PUSH
25630: LD_INT 0
25632: PUSH
25633: LD_INT 1
25635: PUSH
25636: LD_INT 2
25638: PUSH
25639: EMPTY
25640: LIST
25641: LIST
25642: LIST
25643: IN
25644: NOT
25645: PUSH
25646: LD_VAR 0 1
25650: PUSH
25651: LD_INT 0
25653: PUSH
25654: LD_INT 1
25656: PUSH
25657: LD_INT 2
25659: PUSH
25660: LD_INT 3
25662: PUSH
25663: LD_INT 6
25665: PUSH
25666: LD_INT 36
25668: PUSH
25669: LD_INT 4
25671: PUSH
25672: LD_INT 5
25674: PUSH
25675: LD_INT 31
25677: PUSH
25678: LD_INT 32
25680: PUSH
25681: LD_INT 33
25683: PUSH
25684: EMPTY
25685: LIST
25686: LIST
25687: LIST
25688: LIST
25689: LIST
25690: LIST
25691: LIST
25692: LIST
25693: LIST
25694: LIST
25695: LIST
25696: IN
25697: NOT
25698: PUSH
25699: LD_VAR 0 6
25703: PUSH
25704: LD_INT 1
25706: EQUAL
25707: AND
25708: OR
25709: PUSH
25710: LD_VAR 0 1
25714: PUSH
25715: LD_INT 2
25717: PUSH
25718: LD_INT 3
25720: PUSH
25721: EMPTY
25722: LIST
25723: LIST
25724: IN
25725: NOT
25726: PUSH
25727: LD_VAR 0 6
25731: PUSH
25732: LD_INT 2
25734: EQUAL
25735: AND
25736: OR
25737: IFFALSE 25747
// mode = 0 ;
25739: LD_ADDR_VAR 0 6
25743: PUSH
25744: LD_INT 0
25746: ST_TO_ADDR
// case mode of 0 :
25747: LD_VAR 0 6
25751: PUSH
25752: LD_INT 0
25754: DOUBLE
25755: EQUAL
25756: IFTRUE 25760
25758: GO 37213
25760: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
25761: LD_ADDR_VAR 0 11
25765: PUSH
25766: LD_INT 0
25768: PUSH
25769: LD_INT 0
25771: PUSH
25772: EMPTY
25773: LIST
25774: LIST
25775: PUSH
25776: LD_INT 0
25778: PUSH
25779: LD_INT 1
25781: NEG
25782: PUSH
25783: EMPTY
25784: LIST
25785: LIST
25786: PUSH
25787: LD_INT 1
25789: PUSH
25790: LD_INT 0
25792: PUSH
25793: EMPTY
25794: LIST
25795: LIST
25796: PUSH
25797: LD_INT 1
25799: PUSH
25800: LD_INT 1
25802: PUSH
25803: EMPTY
25804: LIST
25805: LIST
25806: PUSH
25807: LD_INT 0
25809: PUSH
25810: LD_INT 1
25812: PUSH
25813: EMPTY
25814: LIST
25815: LIST
25816: PUSH
25817: LD_INT 1
25819: NEG
25820: PUSH
25821: LD_INT 0
25823: PUSH
25824: EMPTY
25825: LIST
25826: LIST
25827: PUSH
25828: LD_INT 1
25830: NEG
25831: PUSH
25832: LD_INT 1
25834: NEG
25835: PUSH
25836: EMPTY
25837: LIST
25838: LIST
25839: PUSH
25840: LD_INT 1
25842: NEG
25843: PUSH
25844: LD_INT 2
25846: NEG
25847: PUSH
25848: EMPTY
25849: LIST
25850: LIST
25851: PUSH
25852: LD_INT 0
25854: PUSH
25855: LD_INT 2
25857: NEG
25858: PUSH
25859: EMPTY
25860: LIST
25861: LIST
25862: PUSH
25863: LD_INT 1
25865: PUSH
25866: LD_INT 1
25868: NEG
25869: PUSH
25870: EMPTY
25871: LIST
25872: LIST
25873: PUSH
25874: LD_INT 1
25876: PUSH
25877: LD_INT 2
25879: PUSH
25880: EMPTY
25881: LIST
25882: LIST
25883: PUSH
25884: LD_INT 0
25886: PUSH
25887: LD_INT 2
25889: PUSH
25890: EMPTY
25891: LIST
25892: LIST
25893: PUSH
25894: LD_INT 1
25896: NEG
25897: PUSH
25898: LD_INT 1
25900: PUSH
25901: EMPTY
25902: LIST
25903: LIST
25904: PUSH
25905: LD_INT 1
25907: PUSH
25908: LD_INT 3
25910: PUSH
25911: EMPTY
25912: LIST
25913: LIST
25914: PUSH
25915: LD_INT 0
25917: PUSH
25918: LD_INT 3
25920: PUSH
25921: EMPTY
25922: LIST
25923: LIST
25924: PUSH
25925: LD_INT 1
25927: NEG
25928: PUSH
25929: LD_INT 2
25931: PUSH
25932: EMPTY
25933: LIST
25934: LIST
25935: PUSH
25936: EMPTY
25937: LIST
25938: LIST
25939: LIST
25940: LIST
25941: LIST
25942: LIST
25943: LIST
25944: LIST
25945: LIST
25946: LIST
25947: LIST
25948: LIST
25949: LIST
25950: LIST
25951: LIST
25952: LIST
25953: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
25954: LD_ADDR_VAR 0 12
25958: PUSH
25959: LD_INT 0
25961: PUSH
25962: LD_INT 0
25964: PUSH
25965: EMPTY
25966: LIST
25967: LIST
25968: PUSH
25969: LD_INT 0
25971: PUSH
25972: LD_INT 1
25974: NEG
25975: PUSH
25976: EMPTY
25977: LIST
25978: LIST
25979: PUSH
25980: LD_INT 1
25982: PUSH
25983: LD_INT 0
25985: PUSH
25986: EMPTY
25987: LIST
25988: LIST
25989: PUSH
25990: LD_INT 1
25992: PUSH
25993: LD_INT 1
25995: PUSH
25996: EMPTY
25997: LIST
25998: LIST
25999: PUSH
26000: LD_INT 0
26002: PUSH
26003: LD_INT 1
26005: PUSH
26006: EMPTY
26007: LIST
26008: LIST
26009: PUSH
26010: LD_INT 1
26012: NEG
26013: PUSH
26014: LD_INT 0
26016: PUSH
26017: EMPTY
26018: LIST
26019: LIST
26020: PUSH
26021: LD_INT 1
26023: NEG
26024: PUSH
26025: LD_INT 1
26027: NEG
26028: PUSH
26029: EMPTY
26030: LIST
26031: LIST
26032: PUSH
26033: LD_INT 1
26035: PUSH
26036: LD_INT 1
26038: NEG
26039: PUSH
26040: EMPTY
26041: LIST
26042: LIST
26043: PUSH
26044: LD_INT 2
26046: PUSH
26047: LD_INT 0
26049: PUSH
26050: EMPTY
26051: LIST
26052: LIST
26053: PUSH
26054: LD_INT 2
26056: PUSH
26057: LD_INT 1
26059: PUSH
26060: EMPTY
26061: LIST
26062: LIST
26063: PUSH
26064: LD_INT 1
26066: NEG
26067: PUSH
26068: LD_INT 1
26070: PUSH
26071: EMPTY
26072: LIST
26073: LIST
26074: PUSH
26075: LD_INT 2
26077: NEG
26078: PUSH
26079: LD_INT 0
26081: PUSH
26082: EMPTY
26083: LIST
26084: LIST
26085: PUSH
26086: LD_INT 2
26088: NEG
26089: PUSH
26090: LD_INT 1
26092: NEG
26093: PUSH
26094: EMPTY
26095: LIST
26096: LIST
26097: PUSH
26098: LD_INT 2
26100: NEG
26101: PUSH
26102: LD_INT 1
26104: PUSH
26105: EMPTY
26106: LIST
26107: LIST
26108: PUSH
26109: LD_INT 3
26111: NEG
26112: PUSH
26113: LD_INT 0
26115: PUSH
26116: EMPTY
26117: LIST
26118: LIST
26119: PUSH
26120: LD_INT 3
26122: NEG
26123: PUSH
26124: LD_INT 1
26126: NEG
26127: PUSH
26128: EMPTY
26129: LIST
26130: LIST
26131: PUSH
26132: EMPTY
26133: LIST
26134: LIST
26135: LIST
26136: LIST
26137: LIST
26138: LIST
26139: LIST
26140: LIST
26141: LIST
26142: LIST
26143: LIST
26144: LIST
26145: LIST
26146: LIST
26147: LIST
26148: LIST
26149: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
26150: LD_ADDR_VAR 0 13
26154: PUSH
26155: LD_INT 0
26157: PUSH
26158: LD_INT 0
26160: PUSH
26161: EMPTY
26162: LIST
26163: LIST
26164: PUSH
26165: LD_INT 0
26167: PUSH
26168: LD_INT 1
26170: NEG
26171: PUSH
26172: EMPTY
26173: LIST
26174: LIST
26175: PUSH
26176: LD_INT 1
26178: PUSH
26179: LD_INT 0
26181: PUSH
26182: EMPTY
26183: LIST
26184: LIST
26185: PUSH
26186: LD_INT 1
26188: PUSH
26189: LD_INT 1
26191: PUSH
26192: EMPTY
26193: LIST
26194: LIST
26195: PUSH
26196: LD_INT 0
26198: PUSH
26199: LD_INT 1
26201: PUSH
26202: EMPTY
26203: LIST
26204: LIST
26205: PUSH
26206: LD_INT 1
26208: NEG
26209: PUSH
26210: LD_INT 0
26212: PUSH
26213: EMPTY
26214: LIST
26215: LIST
26216: PUSH
26217: LD_INT 1
26219: NEG
26220: PUSH
26221: LD_INT 1
26223: NEG
26224: PUSH
26225: EMPTY
26226: LIST
26227: LIST
26228: PUSH
26229: LD_INT 1
26231: NEG
26232: PUSH
26233: LD_INT 2
26235: NEG
26236: PUSH
26237: EMPTY
26238: LIST
26239: LIST
26240: PUSH
26241: LD_INT 2
26243: PUSH
26244: LD_INT 1
26246: PUSH
26247: EMPTY
26248: LIST
26249: LIST
26250: PUSH
26251: LD_INT 2
26253: PUSH
26254: LD_INT 2
26256: PUSH
26257: EMPTY
26258: LIST
26259: LIST
26260: PUSH
26261: LD_INT 1
26263: PUSH
26264: LD_INT 2
26266: PUSH
26267: EMPTY
26268: LIST
26269: LIST
26270: PUSH
26271: LD_INT 2
26273: NEG
26274: PUSH
26275: LD_INT 1
26277: NEG
26278: PUSH
26279: EMPTY
26280: LIST
26281: LIST
26282: PUSH
26283: LD_INT 2
26285: NEG
26286: PUSH
26287: LD_INT 2
26289: NEG
26290: PUSH
26291: EMPTY
26292: LIST
26293: LIST
26294: PUSH
26295: LD_INT 2
26297: NEG
26298: PUSH
26299: LD_INT 3
26301: NEG
26302: PUSH
26303: EMPTY
26304: LIST
26305: LIST
26306: PUSH
26307: LD_INT 3
26309: NEG
26310: PUSH
26311: LD_INT 2
26313: NEG
26314: PUSH
26315: EMPTY
26316: LIST
26317: LIST
26318: PUSH
26319: LD_INT 3
26321: NEG
26322: PUSH
26323: LD_INT 3
26325: NEG
26326: PUSH
26327: EMPTY
26328: LIST
26329: LIST
26330: PUSH
26331: EMPTY
26332: LIST
26333: LIST
26334: LIST
26335: LIST
26336: LIST
26337: LIST
26338: LIST
26339: LIST
26340: LIST
26341: LIST
26342: LIST
26343: LIST
26344: LIST
26345: LIST
26346: LIST
26347: LIST
26348: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
26349: LD_ADDR_VAR 0 14
26353: PUSH
26354: LD_INT 0
26356: PUSH
26357: LD_INT 0
26359: PUSH
26360: EMPTY
26361: LIST
26362: LIST
26363: PUSH
26364: LD_INT 0
26366: PUSH
26367: LD_INT 1
26369: NEG
26370: PUSH
26371: EMPTY
26372: LIST
26373: LIST
26374: PUSH
26375: LD_INT 1
26377: PUSH
26378: LD_INT 0
26380: PUSH
26381: EMPTY
26382: LIST
26383: LIST
26384: PUSH
26385: LD_INT 1
26387: PUSH
26388: LD_INT 1
26390: PUSH
26391: EMPTY
26392: LIST
26393: LIST
26394: PUSH
26395: LD_INT 0
26397: PUSH
26398: LD_INT 1
26400: PUSH
26401: EMPTY
26402: LIST
26403: LIST
26404: PUSH
26405: LD_INT 1
26407: NEG
26408: PUSH
26409: LD_INT 0
26411: PUSH
26412: EMPTY
26413: LIST
26414: LIST
26415: PUSH
26416: LD_INT 1
26418: NEG
26419: PUSH
26420: LD_INT 1
26422: NEG
26423: PUSH
26424: EMPTY
26425: LIST
26426: LIST
26427: PUSH
26428: LD_INT 1
26430: NEG
26431: PUSH
26432: LD_INT 2
26434: NEG
26435: PUSH
26436: EMPTY
26437: LIST
26438: LIST
26439: PUSH
26440: LD_INT 0
26442: PUSH
26443: LD_INT 2
26445: NEG
26446: PUSH
26447: EMPTY
26448: LIST
26449: LIST
26450: PUSH
26451: LD_INT 1
26453: PUSH
26454: LD_INT 1
26456: NEG
26457: PUSH
26458: EMPTY
26459: LIST
26460: LIST
26461: PUSH
26462: LD_INT 1
26464: PUSH
26465: LD_INT 2
26467: PUSH
26468: EMPTY
26469: LIST
26470: LIST
26471: PUSH
26472: LD_INT 0
26474: PUSH
26475: LD_INT 2
26477: PUSH
26478: EMPTY
26479: LIST
26480: LIST
26481: PUSH
26482: LD_INT 1
26484: NEG
26485: PUSH
26486: LD_INT 1
26488: PUSH
26489: EMPTY
26490: LIST
26491: LIST
26492: PUSH
26493: LD_INT 1
26495: NEG
26496: PUSH
26497: LD_INT 3
26499: NEG
26500: PUSH
26501: EMPTY
26502: LIST
26503: LIST
26504: PUSH
26505: LD_INT 0
26507: PUSH
26508: LD_INT 3
26510: NEG
26511: PUSH
26512: EMPTY
26513: LIST
26514: LIST
26515: PUSH
26516: LD_INT 1
26518: PUSH
26519: LD_INT 2
26521: NEG
26522: PUSH
26523: EMPTY
26524: LIST
26525: LIST
26526: PUSH
26527: EMPTY
26528: LIST
26529: LIST
26530: LIST
26531: LIST
26532: LIST
26533: LIST
26534: LIST
26535: LIST
26536: LIST
26537: LIST
26538: LIST
26539: LIST
26540: LIST
26541: LIST
26542: LIST
26543: LIST
26544: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
26545: LD_ADDR_VAR 0 15
26549: PUSH
26550: LD_INT 0
26552: PUSH
26553: LD_INT 0
26555: PUSH
26556: EMPTY
26557: LIST
26558: LIST
26559: PUSH
26560: LD_INT 0
26562: PUSH
26563: LD_INT 1
26565: NEG
26566: PUSH
26567: EMPTY
26568: LIST
26569: LIST
26570: PUSH
26571: LD_INT 1
26573: PUSH
26574: LD_INT 0
26576: PUSH
26577: EMPTY
26578: LIST
26579: LIST
26580: PUSH
26581: LD_INT 1
26583: PUSH
26584: LD_INT 1
26586: PUSH
26587: EMPTY
26588: LIST
26589: LIST
26590: PUSH
26591: LD_INT 0
26593: PUSH
26594: LD_INT 1
26596: PUSH
26597: EMPTY
26598: LIST
26599: LIST
26600: PUSH
26601: LD_INT 1
26603: NEG
26604: PUSH
26605: LD_INT 0
26607: PUSH
26608: EMPTY
26609: LIST
26610: LIST
26611: PUSH
26612: LD_INT 1
26614: NEG
26615: PUSH
26616: LD_INT 1
26618: NEG
26619: PUSH
26620: EMPTY
26621: LIST
26622: LIST
26623: PUSH
26624: LD_INT 1
26626: PUSH
26627: LD_INT 1
26629: NEG
26630: PUSH
26631: EMPTY
26632: LIST
26633: LIST
26634: PUSH
26635: LD_INT 2
26637: PUSH
26638: LD_INT 0
26640: PUSH
26641: EMPTY
26642: LIST
26643: LIST
26644: PUSH
26645: LD_INT 2
26647: PUSH
26648: LD_INT 1
26650: PUSH
26651: EMPTY
26652: LIST
26653: LIST
26654: PUSH
26655: LD_INT 1
26657: NEG
26658: PUSH
26659: LD_INT 1
26661: PUSH
26662: EMPTY
26663: LIST
26664: LIST
26665: PUSH
26666: LD_INT 2
26668: NEG
26669: PUSH
26670: LD_INT 0
26672: PUSH
26673: EMPTY
26674: LIST
26675: LIST
26676: PUSH
26677: LD_INT 2
26679: NEG
26680: PUSH
26681: LD_INT 1
26683: NEG
26684: PUSH
26685: EMPTY
26686: LIST
26687: LIST
26688: PUSH
26689: LD_INT 2
26691: PUSH
26692: LD_INT 1
26694: NEG
26695: PUSH
26696: EMPTY
26697: LIST
26698: LIST
26699: PUSH
26700: LD_INT 3
26702: PUSH
26703: LD_INT 0
26705: PUSH
26706: EMPTY
26707: LIST
26708: LIST
26709: PUSH
26710: LD_INT 3
26712: PUSH
26713: LD_INT 1
26715: PUSH
26716: EMPTY
26717: LIST
26718: LIST
26719: PUSH
26720: EMPTY
26721: LIST
26722: LIST
26723: LIST
26724: LIST
26725: LIST
26726: LIST
26727: LIST
26728: LIST
26729: LIST
26730: LIST
26731: LIST
26732: LIST
26733: LIST
26734: LIST
26735: LIST
26736: LIST
26737: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
26738: LD_ADDR_VAR 0 16
26742: PUSH
26743: LD_INT 0
26745: PUSH
26746: LD_INT 0
26748: PUSH
26749: EMPTY
26750: LIST
26751: LIST
26752: PUSH
26753: LD_INT 0
26755: PUSH
26756: LD_INT 1
26758: NEG
26759: PUSH
26760: EMPTY
26761: LIST
26762: LIST
26763: PUSH
26764: LD_INT 1
26766: PUSH
26767: LD_INT 0
26769: PUSH
26770: EMPTY
26771: LIST
26772: LIST
26773: PUSH
26774: LD_INT 1
26776: PUSH
26777: LD_INT 1
26779: PUSH
26780: EMPTY
26781: LIST
26782: LIST
26783: PUSH
26784: LD_INT 0
26786: PUSH
26787: LD_INT 1
26789: PUSH
26790: EMPTY
26791: LIST
26792: LIST
26793: PUSH
26794: LD_INT 1
26796: NEG
26797: PUSH
26798: LD_INT 0
26800: PUSH
26801: EMPTY
26802: LIST
26803: LIST
26804: PUSH
26805: LD_INT 1
26807: NEG
26808: PUSH
26809: LD_INT 1
26811: NEG
26812: PUSH
26813: EMPTY
26814: LIST
26815: LIST
26816: PUSH
26817: LD_INT 1
26819: NEG
26820: PUSH
26821: LD_INT 2
26823: NEG
26824: PUSH
26825: EMPTY
26826: LIST
26827: LIST
26828: PUSH
26829: LD_INT 2
26831: PUSH
26832: LD_INT 1
26834: PUSH
26835: EMPTY
26836: LIST
26837: LIST
26838: PUSH
26839: LD_INT 2
26841: PUSH
26842: LD_INT 2
26844: PUSH
26845: EMPTY
26846: LIST
26847: LIST
26848: PUSH
26849: LD_INT 1
26851: PUSH
26852: LD_INT 2
26854: PUSH
26855: EMPTY
26856: LIST
26857: LIST
26858: PUSH
26859: LD_INT 2
26861: NEG
26862: PUSH
26863: LD_INT 1
26865: NEG
26866: PUSH
26867: EMPTY
26868: LIST
26869: LIST
26870: PUSH
26871: LD_INT 2
26873: NEG
26874: PUSH
26875: LD_INT 2
26877: NEG
26878: PUSH
26879: EMPTY
26880: LIST
26881: LIST
26882: PUSH
26883: LD_INT 3
26885: PUSH
26886: LD_INT 2
26888: PUSH
26889: EMPTY
26890: LIST
26891: LIST
26892: PUSH
26893: LD_INT 3
26895: PUSH
26896: LD_INT 3
26898: PUSH
26899: EMPTY
26900: LIST
26901: LIST
26902: PUSH
26903: LD_INT 2
26905: PUSH
26906: LD_INT 3
26908: PUSH
26909: EMPTY
26910: LIST
26911: LIST
26912: PUSH
26913: EMPTY
26914: LIST
26915: LIST
26916: LIST
26917: LIST
26918: LIST
26919: LIST
26920: LIST
26921: LIST
26922: LIST
26923: LIST
26924: LIST
26925: LIST
26926: LIST
26927: LIST
26928: LIST
26929: LIST
26930: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26931: LD_ADDR_VAR 0 17
26935: PUSH
26936: LD_INT 0
26938: PUSH
26939: LD_INT 0
26941: PUSH
26942: EMPTY
26943: LIST
26944: LIST
26945: PUSH
26946: LD_INT 0
26948: PUSH
26949: LD_INT 1
26951: NEG
26952: PUSH
26953: EMPTY
26954: LIST
26955: LIST
26956: PUSH
26957: LD_INT 1
26959: PUSH
26960: LD_INT 0
26962: PUSH
26963: EMPTY
26964: LIST
26965: LIST
26966: PUSH
26967: LD_INT 1
26969: PUSH
26970: LD_INT 1
26972: PUSH
26973: EMPTY
26974: LIST
26975: LIST
26976: PUSH
26977: LD_INT 0
26979: PUSH
26980: LD_INT 1
26982: PUSH
26983: EMPTY
26984: LIST
26985: LIST
26986: PUSH
26987: LD_INT 1
26989: NEG
26990: PUSH
26991: LD_INT 0
26993: PUSH
26994: EMPTY
26995: LIST
26996: LIST
26997: PUSH
26998: LD_INT 1
27000: NEG
27001: PUSH
27002: LD_INT 1
27004: NEG
27005: PUSH
27006: EMPTY
27007: LIST
27008: LIST
27009: PUSH
27010: LD_INT 1
27012: NEG
27013: PUSH
27014: LD_INT 2
27016: NEG
27017: PUSH
27018: EMPTY
27019: LIST
27020: LIST
27021: PUSH
27022: LD_INT 0
27024: PUSH
27025: LD_INT 2
27027: NEG
27028: PUSH
27029: EMPTY
27030: LIST
27031: LIST
27032: PUSH
27033: LD_INT 1
27035: PUSH
27036: LD_INT 1
27038: NEG
27039: PUSH
27040: EMPTY
27041: LIST
27042: LIST
27043: PUSH
27044: LD_INT 2
27046: PUSH
27047: LD_INT 0
27049: PUSH
27050: EMPTY
27051: LIST
27052: LIST
27053: PUSH
27054: LD_INT 2
27056: PUSH
27057: LD_INT 1
27059: PUSH
27060: EMPTY
27061: LIST
27062: LIST
27063: PUSH
27064: LD_INT 2
27066: PUSH
27067: LD_INT 2
27069: PUSH
27070: EMPTY
27071: LIST
27072: LIST
27073: PUSH
27074: LD_INT 1
27076: PUSH
27077: LD_INT 2
27079: PUSH
27080: EMPTY
27081: LIST
27082: LIST
27083: PUSH
27084: LD_INT 0
27086: PUSH
27087: LD_INT 2
27089: PUSH
27090: EMPTY
27091: LIST
27092: LIST
27093: PUSH
27094: LD_INT 1
27096: NEG
27097: PUSH
27098: LD_INT 1
27100: PUSH
27101: EMPTY
27102: LIST
27103: LIST
27104: PUSH
27105: LD_INT 2
27107: NEG
27108: PUSH
27109: LD_INT 0
27111: PUSH
27112: EMPTY
27113: LIST
27114: LIST
27115: PUSH
27116: LD_INT 2
27118: NEG
27119: PUSH
27120: LD_INT 1
27122: NEG
27123: PUSH
27124: EMPTY
27125: LIST
27126: LIST
27127: PUSH
27128: LD_INT 2
27130: NEG
27131: PUSH
27132: LD_INT 2
27134: NEG
27135: PUSH
27136: EMPTY
27137: LIST
27138: LIST
27139: PUSH
27140: EMPTY
27141: LIST
27142: LIST
27143: LIST
27144: LIST
27145: LIST
27146: LIST
27147: LIST
27148: LIST
27149: LIST
27150: LIST
27151: LIST
27152: LIST
27153: LIST
27154: LIST
27155: LIST
27156: LIST
27157: LIST
27158: LIST
27159: LIST
27160: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27161: LD_ADDR_VAR 0 18
27165: PUSH
27166: LD_INT 0
27168: PUSH
27169: LD_INT 0
27171: PUSH
27172: EMPTY
27173: LIST
27174: LIST
27175: PUSH
27176: LD_INT 0
27178: PUSH
27179: LD_INT 1
27181: NEG
27182: PUSH
27183: EMPTY
27184: LIST
27185: LIST
27186: PUSH
27187: LD_INT 1
27189: PUSH
27190: LD_INT 0
27192: PUSH
27193: EMPTY
27194: LIST
27195: LIST
27196: PUSH
27197: LD_INT 1
27199: PUSH
27200: LD_INT 1
27202: PUSH
27203: EMPTY
27204: LIST
27205: LIST
27206: PUSH
27207: LD_INT 0
27209: PUSH
27210: LD_INT 1
27212: PUSH
27213: EMPTY
27214: LIST
27215: LIST
27216: PUSH
27217: LD_INT 1
27219: NEG
27220: PUSH
27221: LD_INT 0
27223: PUSH
27224: EMPTY
27225: LIST
27226: LIST
27227: PUSH
27228: LD_INT 1
27230: NEG
27231: PUSH
27232: LD_INT 1
27234: NEG
27235: PUSH
27236: EMPTY
27237: LIST
27238: LIST
27239: PUSH
27240: LD_INT 1
27242: NEG
27243: PUSH
27244: LD_INT 2
27246: NEG
27247: PUSH
27248: EMPTY
27249: LIST
27250: LIST
27251: PUSH
27252: LD_INT 0
27254: PUSH
27255: LD_INT 2
27257: NEG
27258: PUSH
27259: EMPTY
27260: LIST
27261: LIST
27262: PUSH
27263: LD_INT 1
27265: PUSH
27266: LD_INT 1
27268: NEG
27269: PUSH
27270: EMPTY
27271: LIST
27272: LIST
27273: PUSH
27274: LD_INT 2
27276: PUSH
27277: LD_INT 0
27279: PUSH
27280: EMPTY
27281: LIST
27282: LIST
27283: PUSH
27284: LD_INT 2
27286: PUSH
27287: LD_INT 1
27289: PUSH
27290: EMPTY
27291: LIST
27292: LIST
27293: PUSH
27294: LD_INT 2
27296: PUSH
27297: LD_INT 2
27299: PUSH
27300: EMPTY
27301: LIST
27302: LIST
27303: PUSH
27304: LD_INT 1
27306: PUSH
27307: LD_INT 2
27309: PUSH
27310: EMPTY
27311: LIST
27312: LIST
27313: PUSH
27314: LD_INT 0
27316: PUSH
27317: LD_INT 2
27319: PUSH
27320: EMPTY
27321: LIST
27322: LIST
27323: PUSH
27324: LD_INT 1
27326: NEG
27327: PUSH
27328: LD_INT 1
27330: PUSH
27331: EMPTY
27332: LIST
27333: LIST
27334: PUSH
27335: LD_INT 2
27337: NEG
27338: PUSH
27339: LD_INT 0
27341: PUSH
27342: EMPTY
27343: LIST
27344: LIST
27345: PUSH
27346: LD_INT 2
27348: NEG
27349: PUSH
27350: LD_INT 1
27352: NEG
27353: PUSH
27354: EMPTY
27355: LIST
27356: LIST
27357: PUSH
27358: LD_INT 2
27360: NEG
27361: PUSH
27362: LD_INT 2
27364: NEG
27365: PUSH
27366: EMPTY
27367: LIST
27368: LIST
27369: PUSH
27370: EMPTY
27371: LIST
27372: LIST
27373: LIST
27374: LIST
27375: LIST
27376: LIST
27377: LIST
27378: LIST
27379: LIST
27380: LIST
27381: LIST
27382: LIST
27383: LIST
27384: LIST
27385: LIST
27386: LIST
27387: LIST
27388: LIST
27389: LIST
27390: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27391: LD_ADDR_VAR 0 19
27395: PUSH
27396: LD_INT 0
27398: PUSH
27399: LD_INT 0
27401: PUSH
27402: EMPTY
27403: LIST
27404: LIST
27405: PUSH
27406: LD_INT 0
27408: PUSH
27409: LD_INT 1
27411: NEG
27412: PUSH
27413: EMPTY
27414: LIST
27415: LIST
27416: PUSH
27417: LD_INT 1
27419: PUSH
27420: LD_INT 0
27422: PUSH
27423: EMPTY
27424: LIST
27425: LIST
27426: PUSH
27427: LD_INT 1
27429: PUSH
27430: LD_INT 1
27432: PUSH
27433: EMPTY
27434: LIST
27435: LIST
27436: PUSH
27437: LD_INT 0
27439: PUSH
27440: LD_INT 1
27442: PUSH
27443: EMPTY
27444: LIST
27445: LIST
27446: PUSH
27447: LD_INT 1
27449: NEG
27450: PUSH
27451: LD_INT 0
27453: PUSH
27454: EMPTY
27455: LIST
27456: LIST
27457: PUSH
27458: LD_INT 1
27460: NEG
27461: PUSH
27462: LD_INT 1
27464: NEG
27465: PUSH
27466: EMPTY
27467: LIST
27468: LIST
27469: PUSH
27470: LD_INT 1
27472: NEG
27473: PUSH
27474: LD_INT 2
27476: NEG
27477: PUSH
27478: EMPTY
27479: LIST
27480: LIST
27481: PUSH
27482: LD_INT 0
27484: PUSH
27485: LD_INT 2
27487: NEG
27488: PUSH
27489: EMPTY
27490: LIST
27491: LIST
27492: PUSH
27493: LD_INT 1
27495: PUSH
27496: LD_INT 1
27498: NEG
27499: PUSH
27500: EMPTY
27501: LIST
27502: LIST
27503: PUSH
27504: LD_INT 2
27506: PUSH
27507: LD_INT 0
27509: PUSH
27510: EMPTY
27511: LIST
27512: LIST
27513: PUSH
27514: LD_INT 2
27516: PUSH
27517: LD_INT 1
27519: PUSH
27520: EMPTY
27521: LIST
27522: LIST
27523: PUSH
27524: LD_INT 2
27526: PUSH
27527: LD_INT 2
27529: PUSH
27530: EMPTY
27531: LIST
27532: LIST
27533: PUSH
27534: LD_INT 1
27536: PUSH
27537: LD_INT 2
27539: PUSH
27540: EMPTY
27541: LIST
27542: LIST
27543: PUSH
27544: LD_INT 0
27546: PUSH
27547: LD_INT 2
27549: PUSH
27550: EMPTY
27551: LIST
27552: LIST
27553: PUSH
27554: LD_INT 1
27556: NEG
27557: PUSH
27558: LD_INT 1
27560: PUSH
27561: EMPTY
27562: LIST
27563: LIST
27564: PUSH
27565: LD_INT 2
27567: NEG
27568: PUSH
27569: LD_INT 0
27571: PUSH
27572: EMPTY
27573: LIST
27574: LIST
27575: PUSH
27576: LD_INT 2
27578: NEG
27579: PUSH
27580: LD_INT 1
27582: NEG
27583: PUSH
27584: EMPTY
27585: LIST
27586: LIST
27587: PUSH
27588: LD_INT 2
27590: NEG
27591: PUSH
27592: LD_INT 2
27594: NEG
27595: PUSH
27596: EMPTY
27597: LIST
27598: LIST
27599: PUSH
27600: EMPTY
27601: LIST
27602: LIST
27603: LIST
27604: LIST
27605: LIST
27606: LIST
27607: LIST
27608: LIST
27609: LIST
27610: LIST
27611: LIST
27612: LIST
27613: LIST
27614: LIST
27615: LIST
27616: LIST
27617: LIST
27618: LIST
27619: LIST
27620: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27621: LD_ADDR_VAR 0 20
27625: PUSH
27626: LD_INT 0
27628: PUSH
27629: LD_INT 0
27631: PUSH
27632: EMPTY
27633: LIST
27634: LIST
27635: PUSH
27636: LD_INT 0
27638: PUSH
27639: LD_INT 1
27641: NEG
27642: PUSH
27643: EMPTY
27644: LIST
27645: LIST
27646: PUSH
27647: LD_INT 1
27649: PUSH
27650: LD_INT 0
27652: PUSH
27653: EMPTY
27654: LIST
27655: LIST
27656: PUSH
27657: LD_INT 1
27659: PUSH
27660: LD_INT 1
27662: PUSH
27663: EMPTY
27664: LIST
27665: LIST
27666: PUSH
27667: LD_INT 0
27669: PUSH
27670: LD_INT 1
27672: PUSH
27673: EMPTY
27674: LIST
27675: LIST
27676: PUSH
27677: LD_INT 1
27679: NEG
27680: PUSH
27681: LD_INT 0
27683: PUSH
27684: EMPTY
27685: LIST
27686: LIST
27687: PUSH
27688: LD_INT 1
27690: NEG
27691: PUSH
27692: LD_INT 1
27694: NEG
27695: PUSH
27696: EMPTY
27697: LIST
27698: LIST
27699: PUSH
27700: LD_INT 1
27702: NEG
27703: PUSH
27704: LD_INT 2
27706: NEG
27707: PUSH
27708: EMPTY
27709: LIST
27710: LIST
27711: PUSH
27712: LD_INT 0
27714: PUSH
27715: LD_INT 2
27717: NEG
27718: PUSH
27719: EMPTY
27720: LIST
27721: LIST
27722: PUSH
27723: LD_INT 1
27725: PUSH
27726: LD_INT 1
27728: NEG
27729: PUSH
27730: EMPTY
27731: LIST
27732: LIST
27733: PUSH
27734: LD_INT 2
27736: PUSH
27737: LD_INT 0
27739: PUSH
27740: EMPTY
27741: LIST
27742: LIST
27743: PUSH
27744: LD_INT 2
27746: PUSH
27747: LD_INT 1
27749: PUSH
27750: EMPTY
27751: LIST
27752: LIST
27753: PUSH
27754: LD_INT 2
27756: PUSH
27757: LD_INT 2
27759: PUSH
27760: EMPTY
27761: LIST
27762: LIST
27763: PUSH
27764: LD_INT 1
27766: PUSH
27767: LD_INT 2
27769: PUSH
27770: EMPTY
27771: LIST
27772: LIST
27773: PUSH
27774: LD_INT 0
27776: PUSH
27777: LD_INT 2
27779: PUSH
27780: EMPTY
27781: LIST
27782: LIST
27783: PUSH
27784: LD_INT 1
27786: NEG
27787: PUSH
27788: LD_INT 1
27790: PUSH
27791: EMPTY
27792: LIST
27793: LIST
27794: PUSH
27795: LD_INT 2
27797: NEG
27798: PUSH
27799: LD_INT 0
27801: PUSH
27802: EMPTY
27803: LIST
27804: LIST
27805: PUSH
27806: LD_INT 2
27808: NEG
27809: PUSH
27810: LD_INT 1
27812: NEG
27813: PUSH
27814: EMPTY
27815: LIST
27816: LIST
27817: PUSH
27818: LD_INT 2
27820: NEG
27821: PUSH
27822: LD_INT 2
27824: NEG
27825: PUSH
27826: EMPTY
27827: LIST
27828: LIST
27829: PUSH
27830: EMPTY
27831: LIST
27832: LIST
27833: LIST
27834: LIST
27835: LIST
27836: LIST
27837: LIST
27838: LIST
27839: LIST
27840: LIST
27841: LIST
27842: LIST
27843: LIST
27844: LIST
27845: LIST
27846: LIST
27847: LIST
27848: LIST
27849: LIST
27850: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27851: LD_ADDR_VAR 0 21
27855: PUSH
27856: LD_INT 0
27858: PUSH
27859: LD_INT 0
27861: PUSH
27862: EMPTY
27863: LIST
27864: LIST
27865: PUSH
27866: LD_INT 0
27868: PUSH
27869: LD_INT 1
27871: NEG
27872: PUSH
27873: EMPTY
27874: LIST
27875: LIST
27876: PUSH
27877: LD_INT 1
27879: PUSH
27880: LD_INT 0
27882: PUSH
27883: EMPTY
27884: LIST
27885: LIST
27886: PUSH
27887: LD_INT 1
27889: PUSH
27890: LD_INT 1
27892: PUSH
27893: EMPTY
27894: LIST
27895: LIST
27896: PUSH
27897: LD_INT 0
27899: PUSH
27900: LD_INT 1
27902: PUSH
27903: EMPTY
27904: LIST
27905: LIST
27906: PUSH
27907: LD_INT 1
27909: NEG
27910: PUSH
27911: LD_INT 0
27913: PUSH
27914: EMPTY
27915: LIST
27916: LIST
27917: PUSH
27918: LD_INT 1
27920: NEG
27921: PUSH
27922: LD_INT 1
27924: NEG
27925: PUSH
27926: EMPTY
27927: LIST
27928: LIST
27929: PUSH
27930: LD_INT 1
27932: NEG
27933: PUSH
27934: LD_INT 2
27936: NEG
27937: PUSH
27938: EMPTY
27939: LIST
27940: LIST
27941: PUSH
27942: LD_INT 0
27944: PUSH
27945: LD_INT 2
27947: NEG
27948: PUSH
27949: EMPTY
27950: LIST
27951: LIST
27952: PUSH
27953: LD_INT 1
27955: PUSH
27956: LD_INT 1
27958: NEG
27959: PUSH
27960: EMPTY
27961: LIST
27962: LIST
27963: PUSH
27964: LD_INT 2
27966: PUSH
27967: LD_INT 0
27969: PUSH
27970: EMPTY
27971: LIST
27972: LIST
27973: PUSH
27974: LD_INT 2
27976: PUSH
27977: LD_INT 1
27979: PUSH
27980: EMPTY
27981: LIST
27982: LIST
27983: PUSH
27984: LD_INT 2
27986: PUSH
27987: LD_INT 2
27989: PUSH
27990: EMPTY
27991: LIST
27992: LIST
27993: PUSH
27994: LD_INT 1
27996: PUSH
27997: LD_INT 2
27999: PUSH
28000: EMPTY
28001: LIST
28002: LIST
28003: PUSH
28004: LD_INT 0
28006: PUSH
28007: LD_INT 2
28009: PUSH
28010: EMPTY
28011: LIST
28012: LIST
28013: PUSH
28014: LD_INT 1
28016: NEG
28017: PUSH
28018: LD_INT 1
28020: PUSH
28021: EMPTY
28022: LIST
28023: LIST
28024: PUSH
28025: LD_INT 2
28027: NEG
28028: PUSH
28029: LD_INT 0
28031: PUSH
28032: EMPTY
28033: LIST
28034: LIST
28035: PUSH
28036: LD_INT 2
28038: NEG
28039: PUSH
28040: LD_INT 1
28042: NEG
28043: PUSH
28044: EMPTY
28045: LIST
28046: LIST
28047: PUSH
28048: LD_INT 2
28050: NEG
28051: PUSH
28052: LD_INT 2
28054: NEG
28055: PUSH
28056: EMPTY
28057: LIST
28058: LIST
28059: PUSH
28060: EMPTY
28061: LIST
28062: LIST
28063: LIST
28064: LIST
28065: LIST
28066: LIST
28067: LIST
28068: LIST
28069: LIST
28070: LIST
28071: LIST
28072: LIST
28073: LIST
28074: LIST
28075: LIST
28076: LIST
28077: LIST
28078: LIST
28079: LIST
28080: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28081: LD_ADDR_VAR 0 22
28085: PUSH
28086: LD_INT 0
28088: PUSH
28089: LD_INT 0
28091: PUSH
28092: EMPTY
28093: LIST
28094: LIST
28095: PUSH
28096: LD_INT 0
28098: PUSH
28099: LD_INT 1
28101: NEG
28102: PUSH
28103: EMPTY
28104: LIST
28105: LIST
28106: PUSH
28107: LD_INT 1
28109: PUSH
28110: LD_INT 0
28112: PUSH
28113: EMPTY
28114: LIST
28115: LIST
28116: PUSH
28117: LD_INT 1
28119: PUSH
28120: LD_INT 1
28122: PUSH
28123: EMPTY
28124: LIST
28125: LIST
28126: PUSH
28127: LD_INT 0
28129: PUSH
28130: LD_INT 1
28132: PUSH
28133: EMPTY
28134: LIST
28135: LIST
28136: PUSH
28137: LD_INT 1
28139: NEG
28140: PUSH
28141: LD_INT 0
28143: PUSH
28144: EMPTY
28145: LIST
28146: LIST
28147: PUSH
28148: LD_INT 1
28150: NEG
28151: PUSH
28152: LD_INT 1
28154: NEG
28155: PUSH
28156: EMPTY
28157: LIST
28158: LIST
28159: PUSH
28160: LD_INT 1
28162: NEG
28163: PUSH
28164: LD_INT 2
28166: NEG
28167: PUSH
28168: EMPTY
28169: LIST
28170: LIST
28171: PUSH
28172: LD_INT 0
28174: PUSH
28175: LD_INT 2
28177: NEG
28178: PUSH
28179: EMPTY
28180: LIST
28181: LIST
28182: PUSH
28183: LD_INT 1
28185: PUSH
28186: LD_INT 1
28188: NEG
28189: PUSH
28190: EMPTY
28191: LIST
28192: LIST
28193: PUSH
28194: LD_INT 2
28196: PUSH
28197: LD_INT 0
28199: PUSH
28200: EMPTY
28201: LIST
28202: LIST
28203: PUSH
28204: LD_INT 2
28206: PUSH
28207: LD_INT 1
28209: PUSH
28210: EMPTY
28211: LIST
28212: LIST
28213: PUSH
28214: LD_INT 2
28216: PUSH
28217: LD_INT 2
28219: PUSH
28220: EMPTY
28221: LIST
28222: LIST
28223: PUSH
28224: LD_INT 1
28226: PUSH
28227: LD_INT 2
28229: PUSH
28230: EMPTY
28231: LIST
28232: LIST
28233: PUSH
28234: LD_INT 0
28236: PUSH
28237: LD_INT 2
28239: PUSH
28240: EMPTY
28241: LIST
28242: LIST
28243: PUSH
28244: LD_INT 1
28246: NEG
28247: PUSH
28248: LD_INT 1
28250: PUSH
28251: EMPTY
28252: LIST
28253: LIST
28254: PUSH
28255: LD_INT 2
28257: NEG
28258: PUSH
28259: LD_INT 0
28261: PUSH
28262: EMPTY
28263: LIST
28264: LIST
28265: PUSH
28266: LD_INT 2
28268: NEG
28269: PUSH
28270: LD_INT 1
28272: NEG
28273: PUSH
28274: EMPTY
28275: LIST
28276: LIST
28277: PUSH
28278: LD_INT 2
28280: NEG
28281: PUSH
28282: LD_INT 2
28284: NEG
28285: PUSH
28286: EMPTY
28287: LIST
28288: LIST
28289: PUSH
28290: EMPTY
28291: LIST
28292: LIST
28293: LIST
28294: LIST
28295: LIST
28296: LIST
28297: LIST
28298: LIST
28299: LIST
28300: LIST
28301: LIST
28302: LIST
28303: LIST
28304: LIST
28305: LIST
28306: LIST
28307: LIST
28308: LIST
28309: LIST
28310: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
28311: LD_ADDR_VAR 0 23
28315: PUSH
28316: LD_INT 0
28318: PUSH
28319: LD_INT 0
28321: PUSH
28322: EMPTY
28323: LIST
28324: LIST
28325: PUSH
28326: LD_INT 0
28328: PUSH
28329: LD_INT 1
28331: NEG
28332: PUSH
28333: EMPTY
28334: LIST
28335: LIST
28336: PUSH
28337: LD_INT 1
28339: PUSH
28340: LD_INT 0
28342: PUSH
28343: EMPTY
28344: LIST
28345: LIST
28346: PUSH
28347: LD_INT 1
28349: PUSH
28350: LD_INT 1
28352: PUSH
28353: EMPTY
28354: LIST
28355: LIST
28356: PUSH
28357: LD_INT 0
28359: PUSH
28360: LD_INT 1
28362: PUSH
28363: EMPTY
28364: LIST
28365: LIST
28366: PUSH
28367: LD_INT 1
28369: NEG
28370: PUSH
28371: LD_INT 0
28373: PUSH
28374: EMPTY
28375: LIST
28376: LIST
28377: PUSH
28378: LD_INT 1
28380: NEG
28381: PUSH
28382: LD_INT 1
28384: NEG
28385: PUSH
28386: EMPTY
28387: LIST
28388: LIST
28389: PUSH
28390: LD_INT 1
28392: NEG
28393: PUSH
28394: LD_INT 2
28396: NEG
28397: PUSH
28398: EMPTY
28399: LIST
28400: LIST
28401: PUSH
28402: LD_INT 0
28404: PUSH
28405: LD_INT 2
28407: NEG
28408: PUSH
28409: EMPTY
28410: LIST
28411: LIST
28412: PUSH
28413: LD_INT 1
28415: PUSH
28416: LD_INT 1
28418: NEG
28419: PUSH
28420: EMPTY
28421: LIST
28422: LIST
28423: PUSH
28424: LD_INT 2
28426: PUSH
28427: LD_INT 0
28429: PUSH
28430: EMPTY
28431: LIST
28432: LIST
28433: PUSH
28434: LD_INT 2
28436: PUSH
28437: LD_INT 1
28439: PUSH
28440: EMPTY
28441: LIST
28442: LIST
28443: PUSH
28444: LD_INT 2
28446: PUSH
28447: LD_INT 2
28449: PUSH
28450: EMPTY
28451: LIST
28452: LIST
28453: PUSH
28454: LD_INT 1
28456: PUSH
28457: LD_INT 2
28459: PUSH
28460: EMPTY
28461: LIST
28462: LIST
28463: PUSH
28464: LD_INT 0
28466: PUSH
28467: LD_INT 2
28469: PUSH
28470: EMPTY
28471: LIST
28472: LIST
28473: PUSH
28474: LD_INT 1
28476: NEG
28477: PUSH
28478: LD_INT 1
28480: PUSH
28481: EMPTY
28482: LIST
28483: LIST
28484: PUSH
28485: LD_INT 2
28487: NEG
28488: PUSH
28489: LD_INT 0
28491: PUSH
28492: EMPTY
28493: LIST
28494: LIST
28495: PUSH
28496: LD_INT 2
28498: NEG
28499: PUSH
28500: LD_INT 1
28502: NEG
28503: PUSH
28504: EMPTY
28505: LIST
28506: LIST
28507: PUSH
28508: LD_INT 2
28510: NEG
28511: PUSH
28512: LD_INT 2
28514: NEG
28515: PUSH
28516: EMPTY
28517: LIST
28518: LIST
28519: PUSH
28520: LD_INT 2
28522: NEG
28523: PUSH
28524: LD_INT 3
28526: NEG
28527: PUSH
28528: EMPTY
28529: LIST
28530: LIST
28531: PUSH
28532: LD_INT 1
28534: NEG
28535: PUSH
28536: LD_INT 3
28538: NEG
28539: PUSH
28540: EMPTY
28541: LIST
28542: LIST
28543: PUSH
28544: LD_INT 1
28546: PUSH
28547: LD_INT 2
28549: NEG
28550: PUSH
28551: EMPTY
28552: LIST
28553: LIST
28554: PUSH
28555: LD_INT 2
28557: PUSH
28558: LD_INT 1
28560: NEG
28561: PUSH
28562: EMPTY
28563: LIST
28564: LIST
28565: PUSH
28566: EMPTY
28567: LIST
28568: LIST
28569: LIST
28570: LIST
28571: LIST
28572: LIST
28573: LIST
28574: LIST
28575: LIST
28576: LIST
28577: LIST
28578: LIST
28579: LIST
28580: LIST
28581: LIST
28582: LIST
28583: LIST
28584: LIST
28585: LIST
28586: LIST
28587: LIST
28588: LIST
28589: LIST
28590: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
28591: LD_ADDR_VAR 0 24
28595: PUSH
28596: LD_INT 0
28598: PUSH
28599: LD_INT 0
28601: PUSH
28602: EMPTY
28603: LIST
28604: LIST
28605: PUSH
28606: LD_INT 0
28608: PUSH
28609: LD_INT 1
28611: NEG
28612: PUSH
28613: EMPTY
28614: LIST
28615: LIST
28616: PUSH
28617: LD_INT 1
28619: PUSH
28620: LD_INT 0
28622: PUSH
28623: EMPTY
28624: LIST
28625: LIST
28626: PUSH
28627: LD_INT 1
28629: PUSH
28630: LD_INT 1
28632: PUSH
28633: EMPTY
28634: LIST
28635: LIST
28636: PUSH
28637: LD_INT 0
28639: PUSH
28640: LD_INT 1
28642: PUSH
28643: EMPTY
28644: LIST
28645: LIST
28646: PUSH
28647: LD_INT 1
28649: NEG
28650: PUSH
28651: LD_INT 0
28653: PUSH
28654: EMPTY
28655: LIST
28656: LIST
28657: PUSH
28658: LD_INT 1
28660: NEG
28661: PUSH
28662: LD_INT 1
28664: NEG
28665: PUSH
28666: EMPTY
28667: LIST
28668: LIST
28669: PUSH
28670: LD_INT 1
28672: NEG
28673: PUSH
28674: LD_INT 2
28676: NEG
28677: PUSH
28678: EMPTY
28679: LIST
28680: LIST
28681: PUSH
28682: LD_INT 0
28684: PUSH
28685: LD_INT 2
28687: NEG
28688: PUSH
28689: EMPTY
28690: LIST
28691: LIST
28692: PUSH
28693: LD_INT 1
28695: PUSH
28696: LD_INT 1
28698: NEG
28699: PUSH
28700: EMPTY
28701: LIST
28702: LIST
28703: PUSH
28704: LD_INT 2
28706: PUSH
28707: LD_INT 0
28709: PUSH
28710: EMPTY
28711: LIST
28712: LIST
28713: PUSH
28714: LD_INT 2
28716: PUSH
28717: LD_INT 1
28719: PUSH
28720: EMPTY
28721: LIST
28722: LIST
28723: PUSH
28724: LD_INT 2
28726: PUSH
28727: LD_INT 2
28729: PUSH
28730: EMPTY
28731: LIST
28732: LIST
28733: PUSH
28734: LD_INT 1
28736: PUSH
28737: LD_INT 2
28739: PUSH
28740: EMPTY
28741: LIST
28742: LIST
28743: PUSH
28744: LD_INT 0
28746: PUSH
28747: LD_INT 2
28749: PUSH
28750: EMPTY
28751: LIST
28752: LIST
28753: PUSH
28754: LD_INT 1
28756: NEG
28757: PUSH
28758: LD_INT 1
28760: PUSH
28761: EMPTY
28762: LIST
28763: LIST
28764: PUSH
28765: LD_INT 2
28767: NEG
28768: PUSH
28769: LD_INT 0
28771: PUSH
28772: EMPTY
28773: LIST
28774: LIST
28775: PUSH
28776: LD_INT 2
28778: NEG
28779: PUSH
28780: LD_INT 1
28782: NEG
28783: PUSH
28784: EMPTY
28785: LIST
28786: LIST
28787: PUSH
28788: LD_INT 2
28790: NEG
28791: PUSH
28792: LD_INT 2
28794: NEG
28795: PUSH
28796: EMPTY
28797: LIST
28798: LIST
28799: PUSH
28800: LD_INT 1
28802: PUSH
28803: LD_INT 2
28805: NEG
28806: PUSH
28807: EMPTY
28808: LIST
28809: LIST
28810: PUSH
28811: LD_INT 2
28813: PUSH
28814: LD_INT 1
28816: NEG
28817: PUSH
28818: EMPTY
28819: LIST
28820: LIST
28821: PUSH
28822: LD_INT 3
28824: PUSH
28825: LD_INT 1
28827: PUSH
28828: EMPTY
28829: LIST
28830: LIST
28831: PUSH
28832: LD_INT 3
28834: PUSH
28835: LD_INT 2
28837: PUSH
28838: EMPTY
28839: LIST
28840: LIST
28841: PUSH
28842: EMPTY
28843: LIST
28844: LIST
28845: LIST
28846: LIST
28847: LIST
28848: LIST
28849: LIST
28850: LIST
28851: LIST
28852: LIST
28853: LIST
28854: LIST
28855: LIST
28856: LIST
28857: LIST
28858: LIST
28859: LIST
28860: LIST
28861: LIST
28862: LIST
28863: LIST
28864: LIST
28865: LIST
28866: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
28867: LD_ADDR_VAR 0 25
28871: PUSH
28872: LD_INT 0
28874: PUSH
28875: LD_INT 0
28877: PUSH
28878: EMPTY
28879: LIST
28880: LIST
28881: PUSH
28882: LD_INT 0
28884: PUSH
28885: LD_INT 1
28887: NEG
28888: PUSH
28889: EMPTY
28890: LIST
28891: LIST
28892: PUSH
28893: LD_INT 1
28895: PUSH
28896: LD_INT 0
28898: PUSH
28899: EMPTY
28900: LIST
28901: LIST
28902: PUSH
28903: LD_INT 1
28905: PUSH
28906: LD_INT 1
28908: PUSH
28909: EMPTY
28910: LIST
28911: LIST
28912: PUSH
28913: LD_INT 0
28915: PUSH
28916: LD_INT 1
28918: PUSH
28919: EMPTY
28920: LIST
28921: LIST
28922: PUSH
28923: LD_INT 1
28925: NEG
28926: PUSH
28927: LD_INT 0
28929: PUSH
28930: EMPTY
28931: LIST
28932: LIST
28933: PUSH
28934: LD_INT 1
28936: NEG
28937: PUSH
28938: LD_INT 1
28940: NEG
28941: PUSH
28942: EMPTY
28943: LIST
28944: LIST
28945: PUSH
28946: LD_INT 1
28948: NEG
28949: PUSH
28950: LD_INT 2
28952: NEG
28953: PUSH
28954: EMPTY
28955: LIST
28956: LIST
28957: PUSH
28958: LD_INT 0
28960: PUSH
28961: LD_INT 2
28963: NEG
28964: PUSH
28965: EMPTY
28966: LIST
28967: LIST
28968: PUSH
28969: LD_INT 1
28971: PUSH
28972: LD_INT 1
28974: NEG
28975: PUSH
28976: EMPTY
28977: LIST
28978: LIST
28979: PUSH
28980: LD_INT 2
28982: PUSH
28983: LD_INT 0
28985: PUSH
28986: EMPTY
28987: LIST
28988: LIST
28989: PUSH
28990: LD_INT 2
28992: PUSH
28993: LD_INT 1
28995: PUSH
28996: EMPTY
28997: LIST
28998: LIST
28999: PUSH
29000: LD_INT 2
29002: PUSH
29003: LD_INT 2
29005: PUSH
29006: EMPTY
29007: LIST
29008: LIST
29009: PUSH
29010: LD_INT 1
29012: PUSH
29013: LD_INT 2
29015: PUSH
29016: EMPTY
29017: LIST
29018: LIST
29019: PUSH
29020: LD_INT 0
29022: PUSH
29023: LD_INT 2
29025: PUSH
29026: EMPTY
29027: LIST
29028: LIST
29029: PUSH
29030: LD_INT 1
29032: NEG
29033: PUSH
29034: LD_INT 1
29036: PUSH
29037: EMPTY
29038: LIST
29039: LIST
29040: PUSH
29041: LD_INT 2
29043: NEG
29044: PUSH
29045: LD_INT 0
29047: PUSH
29048: EMPTY
29049: LIST
29050: LIST
29051: PUSH
29052: LD_INT 2
29054: NEG
29055: PUSH
29056: LD_INT 1
29058: NEG
29059: PUSH
29060: EMPTY
29061: LIST
29062: LIST
29063: PUSH
29064: LD_INT 2
29066: NEG
29067: PUSH
29068: LD_INT 2
29070: NEG
29071: PUSH
29072: EMPTY
29073: LIST
29074: LIST
29075: PUSH
29076: LD_INT 3
29078: PUSH
29079: LD_INT 1
29081: PUSH
29082: EMPTY
29083: LIST
29084: LIST
29085: PUSH
29086: LD_INT 3
29088: PUSH
29089: LD_INT 2
29091: PUSH
29092: EMPTY
29093: LIST
29094: LIST
29095: PUSH
29096: LD_INT 2
29098: PUSH
29099: LD_INT 3
29101: PUSH
29102: EMPTY
29103: LIST
29104: LIST
29105: PUSH
29106: LD_INT 1
29108: PUSH
29109: LD_INT 3
29111: PUSH
29112: EMPTY
29113: LIST
29114: LIST
29115: PUSH
29116: EMPTY
29117: LIST
29118: LIST
29119: LIST
29120: LIST
29121: LIST
29122: LIST
29123: LIST
29124: LIST
29125: LIST
29126: LIST
29127: LIST
29128: LIST
29129: LIST
29130: LIST
29131: LIST
29132: LIST
29133: LIST
29134: LIST
29135: LIST
29136: LIST
29137: LIST
29138: LIST
29139: LIST
29140: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
29141: LD_ADDR_VAR 0 26
29145: PUSH
29146: LD_INT 0
29148: PUSH
29149: LD_INT 0
29151: PUSH
29152: EMPTY
29153: LIST
29154: LIST
29155: PUSH
29156: LD_INT 0
29158: PUSH
29159: LD_INT 1
29161: NEG
29162: PUSH
29163: EMPTY
29164: LIST
29165: LIST
29166: PUSH
29167: LD_INT 1
29169: PUSH
29170: LD_INT 0
29172: PUSH
29173: EMPTY
29174: LIST
29175: LIST
29176: PUSH
29177: LD_INT 1
29179: PUSH
29180: LD_INT 1
29182: PUSH
29183: EMPTY
29184: LIST
29185: LIST
29186: PUSH
29187: LD_INT 0
29189: PUSH
29190: LD_INT 1
29192: PUSH
29193: EMPTY
29194: LIST
29195: LIST
29196: PUSH
29197: LD_INT 1
29199: NEG
29200: PUSH
29201: LD_INT 0
29203: PUSH
29204: EMPTY
29205: LIST
29206: LIST
29207: PUSH
29208: LD_INT 1
29210: NEG
29211: PUSH
29212: LD_INT 1
29214: NEG
29215: PUSH
29216: EMPTY
29217: LIST
29218: LIST
29219: PUSH
29220: LD_INT 1
29222: NEG
29223: PUSH
29224: LD_INT 2
29226: NEG
29227: PUSH
29228: EMPTY
29229: LIST
29230: LIST
29231: PUSH
29232: LD_INT 0
29234: PUSH
29235: LD_INT 2
29237: NEG
29238: PUSH
29239: EMPTY
29240: LIST
29241: LIST
29242: PUSH
29243: LD_INT 1
29245: PUSH
29246: LD_INT 1
29248: NEG
29249: PUSH
29250: EMPTY
29251: LIST
29252: LIST
29253: PUSH
29254: LD_INT 2
29256: PUSH
29257: LD_INT 0
29259: PUSH
29260: EMPTY
29261: LIST
29262: LIST
29263: PUSH
29264: LD_INT 2
29266: PUSH
29267: LD_INT 1
29269: PUSH
29270: EMPTY
29271: LIST
29272: LIST
29273: PUSH
29274: LD_INT 2
29276: PUSH
29277: LD_INT 2
29279: PUSH
29280: EMPTY
29281: LIST
29282: LIST
29283: PUSH
29284: LD_INT 1
29286: PUSH
29287: LD_INT 2
29289: PUSH
29290: EMPTY
29291: LIST
29292: LIST
29293: PUSH
29294: LD_INT 0
29296: PUSH
29297: LD_INT 2
29299: PUSH
29300: EMPTY
29301: LIST
29302: LIST
29303: PUSH
29304: LD_INT 1
29306: NEG
29307: PUSH
29308: LD_INT 1
29310: PUSH
29311: EMPTY
29312: LIST
29313: LIST
29314: PUSH
29315: LD_INT 2
29317: NEG
29318: PUSH
29319: LD_INT 0
29321: PUSH
29322: EMPTY
29323: LIST
29324: LIST
29325: PUSH
29326: LD_INT 2
29328: NEG
29329: PUSH
29330: LD_INT 1
29332: NEG
29333: PUSH
29334: EMPTY
29335: LIST
29336: LIST
29337: PUSH
29338: LD_INT 2
29340: NEG
29341: PUSH
29342: LD_INT 2
29344: NEG
29345: PUSH
29346: EMPTY
29347: LIST
29348: LIST
29349: PUSH
29350: LD_INT 2
29352: PUSH
29353: LD_INT 3
29355: PUSH
29356: EMPTY
29357: LIST
29358: LIST
29359: PUSH
29360: LD_INT 1
29362: PUSH
29363: LD_INT 3
29365: PUSH
29366: EMPTY
29367: LIST
29368: LIST
29369: PUSH
29370: LD_INT 1
29372: NEG
29373: PUSH
29374: LD_INT 2
29376: PUSH
29377: EMPTY
29378: LIST
29379: LIST
29380: PUSH
29381: LD_INT 2
29383: NEG
29384: PUSH
29385: LD_INT 1
29387: PUSH
29388: EMPTY
29389: LIST
29390: LIST
29391: PUSH
29392: EMPTY
29393: LIST
29394: LIST
29395: LIST
29396: LIST
29397: LIST
29398: LIST
29399: LIST
29400: LIST
29401: LIST
29402: LIST
29403: LIST
29404: LIST
29405: LIST
29406: LIST
29407: LIST
29408: LIST
29409: LIST
29410: LIST
29411: LIST
29412: LIST
29413: LIST
29414: LIST
29415: LIST
29416: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
29417: LD_ADDR_VAR 0 27
29421: PUSH
29422: LD_INT 0
29424: PUSH
29425: LD_INT 0
29427: PUSH
29428: EMPTY
29429: LIST
29430: LIST
29431: PUSH
29432: LD_INT 0
29434: PUSH
29435: LD_INT 1
29437: NEG
29438: PUSH
29439: EMPTY
29440: LIST
29441: LIST
29442: PUSH
29443: LD_INT 1
29445: PUSH
29446: LD_INT 0
29448: PUSH
29449: EMPTY
29450: LIST
29451: LIST
29452: PUSH
29453: LD_INT 1
29455: PUSH
29456: LD_INT 1
29458: PUSH
29459: EMPTY
29460: LIST
29461: LIST
29462: PUSH
29463: LD_INT 0
29465: PUSH
29466: LD_INT 1
29468: PUSH
29469: EMPTY
29470: LIST
29471: LIST
29472: PUSH
29473: LD_INT 1
29475: NEG
29476: PUSH
29477: LD_INT 0
29479: PUSH
29480: EMPTY
29481: LIST
29482: LIST
29483: PUSH
29484: LD_INT 1
29486: NEG
29487: PUSH
29488: LD_INT 1
29490: NEG
29491: PUSH
29492: EMPTY
29493: LIST
29494: LIST
29495: PUSH
29496: LD_INT 1
29498: NEG
29499: PUSH
29500: LD_INT 2
29502: NEG
29503: PUSH
29504: EMPTY
29505: LIST
29506: LIST
29507: PUSH
29508: LD_INT 0
29510: PUSH
29511: LD_INT 2
29513: NEG
29514: PUSH
29515: EMPTY
29516: LIST
29517: LIST
29518: PUSH
29519: LD_INT 1
29521: PUSH
29522: LD_INT 1
29524: NEG
29525: PUSH
29526: EMPTY
29527: LIST
29528: LIST
29529: PUSH
29530: LD_INT 2
29532: PUSH
29533: LD_INT 0
29535: PUSH
29536: EMPTY
29537: LIST
29538: LIST
29539: PUSH
29540: LD_INT 2
29542: PUSH
29543: LD_INT 1
29545: PUSH
29546: EMPTY
29547: LIST
29548: LIST
29549: PUSH
29550: LD_INT 2
29552: PUSH
29553: LD_INT 2
29555: PUSH
29556: EMPTY
29557: LIST
29558: LIST
29559: PUSH
29560: LD_INT 1
29562: PUSH
29563: LD_INT 2
29565: PUSH
29566: EMPTY
29567: LIST
29568: LIST
29569: PUSH
29570: LD_INT 0
29572: PUSH
29573: LD_INT 2
29575: PUSH
29576: EMPTY
29577: LIST
29578: LIST
29579: PUSH
29580: LD_INT 1
29582: NEG
29583: PUSH
29584: LD_INT 1
29586: PUSH
29587: EMPTY
29588: LIST
29589: LIST
29590: PUSH
29591: LD_INT 2
29593: NEG
29594: PUSH
29595: LD_INT 0
29597: PUSH
29598: EMPTY
29599: LIST
29600: LIST
29601: PUSH
29602: LD_INT 2
29604: NEG
29605: PUSH
29606: LD_INT 1
29608: NEG
29609: PUSH
29610: EMPTY
29611: LIST
29612: LIST
29613: PUSH
29614: LD_INT 2
29616: NEG
29617: PUSH
29618: LD_INT 2
29620: NEG
29621: PUSH
29622: EMPTY
29623: LIST
29624: LIST
29625: PUSH
29626: LD_INT 1
29628: NEG
29629: PUSH
29630: LD_INT 2
29632: PUSH
29633: EMPTY
29634: LIST
29635: LIST
29636: PUSH
29637: LD_INT 2
29639: NEG
29640: PUSH
29641: LD_INT 1
29643: PUSH
29644: EMPTY
29645: LIST
29646: LIST
29647: PUSH
29648: LD_INT 3
29650: NEG
29651: PUSH
29652: LD_INT 1
29654: NEG
29655: PUSH
29656: EMPTY
29657: LIST
29658: LIST
29659: PUSH
29660: LD_INT 3
29662: NEG
29663: PUSH
29664: LD_INT 2
29666: NEG
29667: PUSH
29668: EMPTY
29669: LIST
29670: LIST
29671: PUSH
29672: EMPTY
29673: LIST
29674: LIST
29675: LIST
29676: LIST
29677: LIST
29678: LIST
29679: LIST
29680: LIST
29681: LIST
29682: LIST
29683: LIST
29684: LIST
29685: LIST
29686: LIST
29687: LIST
29688: LIST
29689: LIST
29690: LIST
29691: LIST
29692: LIST
29693: LIST
29694: LIST
29695: LIST
29696: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
29697: LD_ADDR_VAR 0 28
29701: PUSH
29702: LD_INT 0
29704: PUSH
29705: LD_INT 0
29707: PUSH
29708: EMPTY
29709: LIST
29710: LIST
29711: PUSH
29712: LD_INT 0
29714: PUSH
29715: LD_INT 1
29717: NEG
29718: PUSH
29719: EMPTY
29720: LIST
29721: LIST
29722: PUSH
29723: LD_INT 1
29725: PUSH
29726: LD_INT 0
29728: PUSH
29729: EMPTY
29730: LIST
29731: LIST
29732: PUSH
29733: LD_INT 1
29735: PUSH
29736: LD_INT 1
29738: PUSH
29739: EMPTY
29740: LIST
29741: LIST
29742: PUSH
29743: LD_INT 0
29745: PUSH
29746: LD_INT 1
29748: PUSH
29749: EMPTY
29750: LIST
29751: LIST
29752: PUSH
29753: LD_INT 1
29755: NEG
29756: PUSH
29757: LD_INT 0
29759: PUSH
29760: EMPTY
29761: LIST
29762: LIST
29763: PUSH
29764: LD_INT 1
29766: NEG
29767: PUSH
29768: LD_INT 1
29770: NEG
29771: PUSH
29772: EMPTY
29773: LIST
29774: LIST
29775: PUSH
29776: LD_INT 1
29778: NEG
29779: PUSH
29780: LD_INT 2
29782: NEG
29783: PUSH
29784: EMPTY
29785: LIST
29786: LIST
29787: PUSH
29788: LD_INT 0
29790: PUSH
29791: LD_INT 2
29793: NEG
29794: PUSH
29795: EMPTY
29796: LIST
29797: LIST
29798: PUSH
29799: LD_INT 1
29801: PUSH
29802: LD_INT 1
29804: NEG
29805: PUSH
29806: EMPTY
29807: LIST
29808: LIST
29809: PUSH
29810: LD_INT 2
29812: PUSH
29813: LD_INT 0
29815: PUSH
29816: EMPTY
29817: LIST
29818: LIST
29819: PUSH
29820: LD_INT 2
29822: PUSH
29823: LD_INT 1
29825: PUSH
29826: EMPTY
29827: LIST
29828: LIST
29829: PUSH
29830: LD_INT 2
29832: PUSH
29833: LD_INT 2
29835: PUSH
29836: EMPTY
29837: LIST
29838: LIST
29839: PUSH
29840: LD_INT 1
29842: PUSH
29843: LD_INT 2
29845: PUSH
29846: EMPTY
29847: LIST
29848: LIST
29849: PUSH
29850: LD_INT 0
29852: PUSH
29853: LD_INT 2
29855: PUSH
29856: EMPTY
29857: LIST
29858: LIST
29859: PUSH
29860: LD_INT 1
29862: NEG
29863: PUSH
29864: LD_INT 1
29866: PUSH
29867: EMPTY
29868: LIST
29869: LIST
29870: PUSH
29871: LD_INT 2
29873: NEG
29874: PUSH
29875: LD_INT 0
29877: PUSH
29878: EMPTY
29879: LIST
29880: LIST
29881: PUSH
29882: LD_INT 2
29884: NEG
29885: PUSH
29886: LD_INT 1
29888: NEG
29889: PUSH
29890: EMPTY
29891: LIST
29892: LIST
29893: PUSH
29894: LD_INT 2
29896: NEG
29897: PUSH
29898: LD_INT 2
29900: NEG
29901: PUSH
29902: EMPTY
29903: LIST
29904: LIST
29905: PUSH
29906: LD_INT 2
29908: NEG
29909: PUSH
29910: LD_INT 3
29912: NEG
29913: PUSH
29914: EMPTY
29915: LIST
29916: LIST
29917: PUSH
29918: LD_INT 1
29920: NEG
29921: PUSH
29922: LD_INT 3
29924: NEG
29925: PUSH
29926: EMPTY
29927: LIST
29928: LIST
29929: PUSH
29930: LD_INT 3
29932: NEG
29933: PUSH
29934: LD_INT 1
29936: NEG
29937: PUSH
29938: EMPTY
29939: LIST
29940: LIST
29941: PUSH
29942: LD_INT 3
29944: NEG
29945: PUSH
29946: LD_INT 2
29948: NEG
29949: PUSH
29950: EMPTY
29951: LIST
29952: LIST
29953: PUSH
29954: EMPTY
29955: LIST
29956: LIST
29957: LIST
29958: LIST
29959: LIST
29960: LIST
29961: LIST
29962: LIST
29963: LIST
29964: LIST
29965: LIST
29966: LIST
29967: LIST
29968: LIST
29969: LIST
29970: LIST
29971: LIST
29972: LIST
29973: LIST
29974: LIST
29975: LIST
29976: LIST
29977: LIST
29978: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
29979: LD_ADDR_VAR 0 29
29983: PUSH
29984: LD_INT 0
29986: PUSH
29987: LD_INT 0
29989: PUSH
29990: EMPTY
29991: LIST
29992: LIST
29993: PUSH
29994: LD_INT 0
29996: PUSH
29997: LD_INT 1
29999: NEG
30000: PUSH
30001: EMPTY
30002: LIST
30003: LIST
30004: PUSH
30005: LD_INT 1
30007: PUSH
30008: LD_INT 0
30010: PUSH
30011: EMPTY
30012: LIST
30013: LIST
30014: PUSH
30015: LD_INT 1
30017: PUSH
30018: LD_INT 1
30020: PUSH
30021: EMPTY
30022: LIST
30023: LIST
30024: PUSH
30025: LD_INT 0
30027: PUSH
30028: LD_INT 1
30030: PUSH
30031: EMPTY
30032: LIST
30033: LIST
30034: PUSH
30035: LD_INT 1
30037: NEG
30038: PUSH
30039: LD_INT 0
30041: PUSH
30042: EMPTY
30043: LIST
30044: LIST
30045: PUSH
30046: LD_INT 1
30048: NEG
30049: PUSH
30050: LD_INT 1
30052: NEG
30053: PUSH
30054: EMPTY
30055: LIST
30056: LIST
30057: PUSH
30058: LD_INT 1
30060: NEG
30061: PUSH
30062: LD_INT 2
30064: NEG
30065: PUSH
30066: EMPTY
30067: LIST
30068: LIST
30069: PUSH
30070: LD_INT 0
30072: PUSH
30073: LD_INT 2
30075: NEG
30076: PUSH
30077: EMPTY
30078: LIST
30079: LIST
30080: PUSH
30081: LD_INT 1
30083: PUSH
30084: LD_INT 1
30086: NEG
30087: PUSH
30088: EMPTY
30089: LIST
30090: LIST
30091: PUSH
30092: LD_INT 2
30094: PUSH
30095: LD_INT 0
30097: PUSH
30098: EMPTY
30099: LIST
30100: LIST
30101: PUSH
30102: LD_INT 2
30104: PUSH
30105: LD_INT 1
30107: PUSH
30108: EMPTY
30109: LIST
30110: LIST
30111: PUSH
30112: LD_INT 1
30114: PUSH
30115: LD_INT 2
30117: PUSH
30118: EMPTY
30119: LIST
30120: LIST
30121: PUSH
30122: LD_INT 0
30124: PUSH
30125: LD_INT 2
30127: PUSH
30128: EMPTY
30129: LIST
30130: LIST
30131: PUSH
30132: LD_INT 1
30134: NEG
30135: PUSH
30136: LD_INT 1
30138: PUSH
30139: EMPTY
30140: LIST
30141: LIST
30142: PUSH
30143: LD_INT 2
30145: NEG
30146: PUSH
30147: LD_INT 1
30149: NEG
30150: PUSH
30151: EMPTY
30152: LIST
30153: LIST
30154: PUSH
30155: LD_INT 2
30157: NEG
30158: PUSH
30159: LD_INT 2
30161: NEG
30162: PUSH
30163: EMPTY
30164: LIST
30165: LIST
30166: PUSH
30167: LD_INT 2
30169: NEG
30170: PUSH
30171: LD_INT 3
30173: NEG
30174: PUSH
30175: EMPTY
30176: LIST
30177: LIST
30178: PUSH
30179: LD_INT 2
30181: PUSH
30182: LD_INT 1
30184: NEG
30185: PUSH
30186: EMPTY
30187: LIST
30188: LIST
30189: PUSH
30190: LD_INT 3
30192: PUSH
30193: LD_INT 1
30195: PUSH
30196: EMPTY
30197: LIST
30198: LIST
30199: PUSH
30200: LD_INT 1
30202: PUSH
30203: LD_INT 3
30205: PUSH
30206: EMPTY
30207: LIST
30208: LIST
30209: PUSH
30210: LD_INT 1
30212: NEG
30213: PUSH
30214: LD_INT 2
30216: PUSH
30217: EMPTY
30218: LIST
30219: LIST
30220: PUSH
30221: LD_INT 3
30223: NEG
30224: PUSH
30225: LD_INT 2
30227: NEG
30228: PUSH
30229: EMPTY
30230: LIST
30231: LIST
30232: PUSH
30233: EMPTY
30234: LIST
30235: LIST
30236: LIST
30237: LIST
30238: LIST
30239: LIST
30240: LIST
30241: LIST
30242: LIST
30243: LIST
30244: LIST
30245: LIST
30246: LIST
30247: LIST
30248: LIST
30249: LIST
30250: LIST
30251: LIST
30252: LIST
30253: LIST
30254: LIST
30255: LIST
30256: LIST
30257: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
30258: LD_ADDR_VAR 0 30
30262: PUSH
30263: LD_INT 0
30265: PUSH
30266: LD_INT 0
30268: PUSH
30269: EMPTY
30270: LIST
30271: LIST
30272: PUSH
30273: LD_INT 0
30275: PUSH
30276: LD_INT 1
30278: NEG
30279: PUSH
30280: EMPTY
30281: LIST
30282: LIST
30283: PUSH
30284: LD_INT 1
30286: PUSH
30287: LD_INT 0
30289: PUSH
30290: EMPTY
30291: LIST
30292: LIST
30293: PUSH
30294: LD_INT 1
30296: PUSH
30297: LD_INT 1
30299: PUSH
30300: EMPTY
30301: LIST
30302: LIST
30303: PUSH
30304: LD_INT 0
30306: PUSH
30307: LD_INT 1
30309: PUSH
30310: EMPTY
30311: LIST
30312: LIST
30313: PUSH
30314: LD_INT 1
30316: NEG
30317: PUSH
30318: LD_INT 0
30320: PUSH
30321: EMPTY
30322: LIST
30323: LIST
30324: PUSH
30325: LD_INT 1
30327: NEG
30328: PUSH
30329: LD_INT 1
30331: NEG
30332: PUSH
30333: EMPTY
30334: LIST
30335: LIST
30336: PUSH
30337: LD_INT 1
30339: NEG
30340: PUSH
30341: LD_INT 2
30343: NEG
30344: PUSH
30345: EMPTY
30346: LIST
30347: LIST
30348: PUSH
30349: LD_INT 0
30351: PUSH
30352: LD_INT 2
30354: NEG
30355: PUSH
30356: EMPTY
30357: LIST
30358: LIST
30359: PUSH
30360: LD_INT 1
30362: PUSH
30363: LD_INT 1
30365: NEG
30366: PUSH
30367: EMPTY
30368: LIST
30369: LIST
30370: PUSH
30371: LD_INT 2
30373: PUSH
30374: LD_INT 0
30376: PUSH
30377: EMPTY
30378: LIST
30379: LIST
30380: PUSH
30381: LD_INT 2
30383: PUSH
30384: LD_INT 1
30386: PUSH
30387: EMPTY
30388: LIST
30389: LIST
30390: PUSH
30391: LD_INT 2
30393: PUSH
30394: LD_INT 2
30396: PUSH
30397: EMPTY
30398: LIST
30399: LIST
30400: PUSH
30401: LD_INT 1
30403: PUSH
30404: LD_INT 2
30406: PUSH
30407: EMPTY
30408: LIST
30409: LIST
30410: PUSH
30411: LD_INT 1
30413: NEG
30414: PUSH
30415: LD_INT 1
30417: PUSH
30418: EMPTY
30419: LIST
30420: LIST
30421: PUSH
30422: LD_INT 2
30424: NEG
30425: PUSH
30426: LD_INT 0
30428: PUSH
30429: EMPTY
30430: LIST
30431: LIST
30432: PUSH
30433: LD_INT 2
30435: NEG
30436: PUSH
30437: LD_INT 1
30439: NEG
30440: PUSH
30441: EMPTY
30442: LIST
30443: LIST
30444: PUSH
30445: LD_INT 1
30447: NEG
30448: PUSH
30449: LD_INT 3
30451: NEG
30452: PUSH
30453: EMPTY
30454: LIST
30455: LIST
30456: PUSH
30457: LD_INT 1
30459: PUSH
30460: LD_INT 2
30462: NEG
30463: PUSH
30464: EMPTY
30465: LIST
30466: LIST
30467: PUSH
30468: LD_INT 3
30470: PUSH
30471: LD_INT 2
30473: PUSH
30474: EMPTY
30475: LIST
30476: LIST
30477: PUSH
30478: LD_INT 2
30480: PUSH
30481: LD_INT 3
30483: PUSH
30484: EMPTY
30485: LIST
30486: LIST
30487: PUSH
30488: LD_INT 2
30490: NEG
30491: PUSH
30492: LD_INT 1
30494: PUSH
30495: EMPTY
30496: LIST
30497: LIST
30498: PUSH
30499: LD_INT 3
30501: NEG
30502: PUSH
30503: LD_INT 1
30505: NEG
30506: PUSH
30507: EMPTY
30508: LIST
30509: LIST
30510: PUSH
30511: EMPTY
30512: LIST
30513: LIST
30514: LIST
30515: LIST
30516: LIST
30517: LIST
30518: LIST
30519: LIST
30520: LIST
30521: LIST
30522: LIST
30523: LIST
30524: LIST
30525: LIST
30526: LIST
30527: LIST
30528: LIST
30529: LIST
30530: LIST
30531: LIST
30532: LIST
30533: LIST
30534: LIST
30535: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
30536: LD_ADDR_VAR 0 31
30540: PUSH
30541: LD_INT 0
30543: PUSH
30544: LD_INT 0
30546: PUSH
30547: EMPTY
30548: LIST
30549: LIST
30550: PUSH
30551: LD_INT 0
30553: PUSH
30554: LD_INT 1
30556: NEG
30557: PUSH
30558: EMPTY
30559: LIST
30560: LIST
30561: PUSH
30562: LD_INT 1
30564: PUSH
30565: LD_INT 0
30567: PUSH
30568: EMPTY
30569: LIST
30570: LIST
30571: PUSH
30572: LD_INT 1
30574: PUSH
30575: LD_INT 1
30577: PUSH
30578: EMPTY
30579: LIST
30580: LIST
30581: PUSH
30582: LD_INT 0
30584: PUSH
30585: LD_INT 1
30587: PUSH
30588: EMPTY
30589: LIST
30590: LIST
30591: PUSH
30592: LD_INT 1
30594: NEG
30595: PUSH
30596: LD_INT 0
30598: PUSH
30599: EMPTY
30600: LIST
30601: LIST
30602: PUSH
30603: LD_INT 1
30605: NEG
30606: PUSH
30607: LD_INT 1
30609: NEG
30610: PUSH
30611: EMPTY
30612: LIST
30613: LIST
30614: PUSH
30615: LD_INT 1
30617: NEG
30618: PUSH
30619: LD_INT 2
30621: NEG
30622: PUSH
30623: EMPTY
30624: LIST
30625: LIST
30626: PUSH
30627: LD_INT 1
30629: PUSH
30630: LD_INT 1
30632: NEG
30633: PUSH
30634: EMPTY
30635: LIST
30636: LIST
30637: PUSH
30638: LD_INT 2
30640: PUSH
30641: LD_INT 0
30643: PUSH
30644: EMPTY
30645: LIST
30646: LIST
30647: PUSH
30648: LD_INT 2
30650: PUSH
30651: LD_INT 1
30653: PUSH
30654: EMPTY
30655: LIST
30656: LIST
30657: PUSH
30658: LD_INT 2
30660: PUSH
30661: LD_INT 2
30663: PUSH
30664: EMPTY
30665: LIST
30666: LIST
30667: PUSH
30668: LD_INT 1
30670: PUSH
30671: LD_INT 2
30673: PUSH
30674: EMPTY
30675: LIST
30676: LIST
30677: PUSH
30678: LD_INT 0
30680: PUSH
30681: LD_INT 2
30683: PUSH
30684: EMPTY
30685: LIST
30686: LIST
30687: PUSH
30688: LD_INT 1
30690: NEG
30691: PUSH
30692: LD_INT 1
30694: PUSH
30695: EMPTY
30696: LIST
30697: LIST
30698: PUSH
30699: LD_INT 2
30701: NEG
30702: PUSH
30703: LD_INT 1
30705: NEG
30706: PUSH
30707: EMPTY
30708: LIST
30709: LIST
30710: PUSH
30711: LD_INT 2
30713: NEG
30714: PUSH
30715: LD_INT 2
30717: NEG
30718: PUSH
30719: EMPTY
30720: LIST
30721: LIST
30722: PUSH
30723: LD_INT 2
30725: NEG
30726: PUSH
30727: LD_INT 3
30729: NEG
30730: PUSH
30731: EMPTY
30732: LIST
30733: LIST
30734: PUSH
30735: LD_INT 2
30737: PUSH
30738: LD_INT 1
30740: NEG
30741: PUSH
30742: EMPTY
30743: LIST
30744: LIST
30745: PUSH
30746: LD_INT 3
30748: PUSH
30749: LD_INT 1
30751: PUSH
30752: EMPTY
30753: LIST
30754: LIST
30755: PUSH
30756: LD_INT 1
30758: PUSH
30759: LD_INT 3
30761: PUSH
30762: EMPTY
30763: LIST
30764: LIST
30765: PUSH
30766: LD_INT 1
30768: NEG
30769: PUSH
30770: LD_INT 2
30772: PUSH
30773: EMPTY
30774: LIST
30775: LIST
30776: PUSH
30777: LD_INT 3
30779: NEG
30780: PUSH
30781: LD_INT 2
30783: NEG
30784: PUSH
30785: EMPTY
30786: LIST
30787: LIST
30788: PUSH
30789: EMPTY
30790: LIST
30791: LIST
30792: LIST
30793: LIST
30794: LIST
30795: LIST
30796: LIST
30797: LIST
30798: LIST
30799: LIST
30800: LIST
30801: LIST
30802: LIST
30803: LIST
30804: LIST
30805: LIST
30806: LIST
30807: LIST
30808: LIST
30809: LIST
30810: LIST
30811: LIST
30812: LIST
30813: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
30814: LD_ADDR_VAR 0 32
30818: PUSH
30819: LD_INT 0
30821: PUSH
30822: LD_INT 0
30824: PUSH
30825: EMPTY
30826: LIST
30827: LIST
30828: PUSH
30829: LD_INT 0
30831: PUSH
30832: LD_INT 1
30834: NEG
30835: PUSH
30836: EMPTY
30837: LIST
30838: LIST
30839: PUSH
30840: LD_INT 1
30842: PUSH
30843: LD_INT 0
30845: PUSH
30846: EMPTY
30847: LIST
30848: LIST
30849: PUSH
30850: LD_INT 1
30852: PUSH
30853: LD_INT 1
30855: PUSH
30856: EMPTY
30857: LIST
30858: LIST
30859: PUSH
30860: LD_INT 0
30862: PUSH
30863: LD_INT 1
30865: PUSH
30866: EMPTY
30867: LIST
30868: LIST
30869: PUSH
30870: LD_INT 1
30872: NEG
30873: PUSH
30874: LD_INT 0
30876: PUSH
30877: EMPTY
30878: LIST
30879: LIST
30880: PUSH
30881: LD_INT 1
30883: NEG
30884: PUSH
30885: LD_INT 1
30887: NEG
30888: PUSH
30889: EMPTY
30890: LIST
30891: LIST
30892: PUSH
30893: LD_INT 1
30895: NEG
30896: PUSH
30897: LD_INT 2
30899: NEG
30900: PUSH
30901: EMPTY
30902: LIST
30903: LIST
30904: PUSH
30905: LD_INT 0
30907: PUSH
30908: LD_INT 2
30910: NEG
30911: PUSH
30912: EMPTY
30913: LIST
30914: LIST
30915: PUSH
30916: LD_INT 1
30918: PUSH
30919: LD_INT 1
30921: NEG
30922: PUSH
30923: EMPTY
30924: LIST
30925: LIST
30926: PUSH
30927: LD_INT 2
30929: PUSH
30930: LD_INT 1
30932: PUSH
30933: EMPTY
30934: LIST
30935: LIST
30936: PUSH
30937: LD_INT 2
30939: PUSH
30940: LD_INT 2
30942: PUSH
30943: EMPTY
30944: LIST
30945: LIST
30946: PUSH
30947: LD_INT 1
30949: PUSH
30950: LD_INT 2
30952: PUSH
30953: EMPTY
30954: LIST
30955: LIST
30956: PUSH
30957: LD_INT 0
30959: PUSH
30960: LD_INT 2
30962: PUSH
30963: EMPTY
30964: LIST
30965: LIST
30966: PUSH
30967: LD_INT 1
30969: NEG
30970: PUSH
30971: LD_INT 1
30973: PUSH
30974: EMPTY
30975: LIST
30976: LIST
30977: PUSH
30978: LD_INT 2
30980: NEG
30981: PUSH
30982: LD_INT 0
30984: PUSH
30985: EMPTY
30986: LIST
30987: LIST
30988: PUSH
30989: LD_INT 2
30991: NEG
30992: PUSH
30993: LD_INT 1
30995: NEG
30996: PUSH
30997: EMPTY
30998: LIST
30999: LIST
31000: PUSH
31001: LD_INT 1
31003: NEG
31004: PUSH
31005: LD_INT 3
31007: NEG
31008: PUSH
31009: EMPTY
31010: LIST
31011: LIST
31012: PUSH
31013: LD_INT 1
31015: PUSH
31016: LD_INT 2
31018: NEG
31019: PUSH
31020: EMPTY
31021: LIST
31022: LIST
31023: PUSH
31024: LD_INT 3
31026: PUSH
31027: LD_INT 2
31029: PUSH
31030: EMPTY
31031: LIST
31032: LIST
31033: PUSH
31034: LD_INT 2
31036: PUSH
31037: LD_INT 3
31039: PUSH
31040: EMPTY
31041: LIST
31042: LIST
31043: PUSH
31044: LD_INT 2
31046: NEG
31047: PUSH
31048: LD_INT 1
31050: PUSH
31051: EMPTY
31052: LIST
31053: LIST
31054: PUSH
31055: LD_INT 3
31057: NEG
31058: PUSH
31059: LD_INT 1
31061: NEG
31062: PUSH
31063: EMPTY
31064: LIST
31065: LIST
31066: PUSH
31067: EMPTY
31068: LIST
31069: LIST
31070: LIST
31071: LIST
31072: LIST
31073: LIST
31074: LIST
31075: LIST
31076: LIST
31077: LIST
31078: LIST
31079: LIST
31080: LIST
31081: LIST
31082: LIST
31083: LIST
31084: LIST
31085: LIST
31086: LIST
31087: LIST
31088: LIST
31089: LIST
31090: LIST
31091: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
31092: LD_ADDR_VAR 0 33
31096: PUSH
31097: LD_INT 0
31099: PUSH
31100: LD_INT 0
31102: PUSH
31103: EMPTY
31104: LIST
31105: LIST
31106: PUSH
31107: LD_INT 0
31109: PUSH
31110: LD_INT 1
31112: NEG
31113: PUSH
31114: EMPTY
31115: LIST
31116: LIST
31117: PUSH
31118: LD_INT 1
31120: PUSH
31121: LD_INT 0
31123: PUSH
31124: EMPTY
31125: LIST
31126: LIST
31127: PUSH
31128: LD_INT 1
31130: PUSH
31131: LD_INT 1
31133: PUSH
31134: EMPTY
31135: LIST
31136: LIST
31137: PUSH
31138: LD_INT 0
31140: PUSH
31141: LD_INT 1
31143: PUSH
31144: EMPTY
31145: LIST
31146: LIST
31147: PUSH
31148: LD_INT 1
31150: NEG
31151: PUSH
31152: LD_INT 0
31154: PUSH
31155: EMPTY
31156: LIST
31157: LIST
31158: PUSH
31159: LD_INT 1
31161: NEG
31162: PUSH
31163: LD_INT 1
31165: NEG
31166: PUSH
31167: EMPTY
31168: LIST
31169: LIST
31170: PUSH
31171: LD_INT 1
31173: NEG
31174: PUSH
31175: LD_INT 2
31177: NEG
31178: PUSH
31179: EMPTY
31180: LIST
31181: LIST
31182: PUSH
31183: LD_INT 1
31185: PUSH
31186: LD_INT 1
31188: NEG
31189: PUSH
31190: EMPTY
31191: LIST
31192: LIST
31193: PUSH
31194: LD_INT 2
31196: PUSH
31197: LD_INT 0
31199: PUSH
31200: EMPTY
31201: LIST
31202: LIST
31203: PUSH
31204: LD_INT 2
31206: PUSH
31207: LD_INT 1
31209: PUSH
31210: EMPTY
31211: LIST
31212: LIST
31213: PUSH
31214: LD_INT 1
31216: PUSH
31217: LD_INT 2
31219: PUSH
31220: EMPTY
31221: LIST
31222: LIST
31223: PUSH
31224: LD_INT 0
31226: PUSH
31227: LD_INT 2
31229: PUSH
31230: EMPTY
31231: LIST
31232: LIST
31233: PUSH
31234: LD_INT 1
31236: NEG
31237: PUSH
31238: LD_INT 1
31240: PUSH
31241: EMPTY
31242: LIST
31243: LIST
31244: PUSH
31245: LD_INT 2
31247: NEG
31248: PUSH
31249: LD_INT 0
31251: PUSH
31252: EMPTY
31253: LIST
31254: LIST
31255: PUSH
31256: LD_INT 2
31258: NEG
31259: PUSH
31260: LD_INT 1
31262: NEG
31263: PUSH
31264: EMPTY
31265: LIST
31266: LIST
31267: PUSH
31268: LD_INT 2
31270: NEG
31271: PUSH
31272: LD_INT 2
31274: NEG
31275: PUSH
31276: EMPTY
31277: LIST
31278: LIST
31279: PUSH
31280: LD_INT 2
31282: NEG
31283: PUSH
31284: LD_INT 3
31286: NEG
31287: PUSH
31288: EMPTY
31289: LIST
31290: LIST
31291: PUSH
31292: LD_INT 2
31294: PUSH
31295: LD_INT 1
31297: NEG
31298: PUSH
31299: EMPTY
31300: LIST
31301: LIST
31302: PUSH
31303: LD_INT 3
31305: PUSH
31306: LD_INT 1
31308: PUSH
31309: EMPTY
31310: LIST
31311: LIST
31312: PUSH
31313: LD_INT 1
31315: PUSH
31316: LD_INT 3
31318: PUSH
31319: EMPTY
31320: LIST
31321: LIST
31322: PUSH
31323: LD_INT 1
31325: NEG
31326: PUSH
31327: LD_INT 2
31329: PUSH
31330: EMPTY
31331: LIST
31332: LIST
31333: PUSH
31334: LD_INT 3
31336: NEG
31337: PUSH
31338: LD_INT 2
31340: NEG
31341: PUSH
31342: EMPTY
31343: LIST
31344: LIST
31345: PUSH
31346: EMPTY
31347: LIST
31348: LIST
31349: LIST
31350: LIST
31351: LIST
31352: LIST
31353: LIST
31354: LIST
31355: LIST
31356: LIST
31357: LIST
31358: LIST
31359: LIST
31360: LIST
31361: LIST
31362: LIST
31363: LIST
31364: LIST
31365: LIST
31366: LIST
31367: LIST
31368: LIST
31369: LIST
31370: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
31371: LD_ADDR_VAR 0 34
31375: PUSH
31376: LD_INT 0
31378: PUSH
31379: LD_INT 0
31381: PUSH
31382: EMPTY
31383: LIST
31384: LIST
31385: PUSH
31386: LD_INT 0
31388: PUSH
31389: LD_INT 1
31391: NEG
31392: PUSH
31393: EMPTY
31394: LIST
31395: LIST
31396: PUSH
31397: LD_INT 1
31399: PUSH
31400: LD_INT 0
31402: PUSH
31403: EMPTY
31404: LIST
31405: LIST
31406: PUSH
31407: LD_INT 1
31409: PUSH
31410: LD_INT 1
31412: PUSH
31413: EMPTY
31414: LIST
31415: LIST
31416: PUSH
31417: LD_INT 0
31419: PUSH
31420: LD_INT 1
31422: PUSH
31423: EMPTY
31424: LIST
31425: LIST
31426: PUSH
31427: LD_INT 1
31429: NEG
31430: PUSH
31431: LD_INT 0
31433: PUSH
31434: EMPTY
31435: LIST
31436: LIST
31437: PUSH
31438: LD_INT 1
31440: NEG
31441: PUSH
31442: LD_INT 1
31444: NEG
31445: PUSH
31446: EMPTY
31447: LIST
31448: LIST
31449: PUSH
31450: LD_INT 1
31452: NEG
31453: PUSH
31454: LD_INT 2
31456: NEG
31457: PUSH
31458: EMPTY
31459: LIST
31460: LIST
31461: PUSH
31462: LD_INT 0
31464: PUSH
31465: LD_INT 2
31467: NEG
31468: PUSH
31469: EMPTY
31470: LIST
31471: LIST
31472: PUSH
31473: LD_INT 1
31475: PUSH
31476: LD_INT 1
31478: NEG
31479: PUSH
31480: EMPTY
31481: LIST
31482: LIST
31483: PUSH
31484: LD_INT 2
31486: PUSH
31487: LD_INT 1
31489: PUSH
31490: EMPTY
31491: LIST
31492: LIST
31493: PUSH
31494: LD_INT 2
31496: PUSH
31497: LD_INT 2
31499: PUSH
31500: EMPTY
31501: LIST
31502: LIST
31503: PUSH
31504: LD_INT 1
31506: PUSH
31507: LD_INT 2
31509: PUSH
31510: EMPTY
31511: LIST
31512: LIST
31513: PUSH
31514: LD_INT 1
31516: NEG
31517: PUSH
31518: LD_INT 1
31520: PUSH
31521: EMPTY
31522: LIST
31523: LIST
31524: PUSH
31525: LD_INT 2
31527: NEG
31528: PUSH
31529: LD_INT 0
31531: PUSH
31532: EMPTY
31533: LIST
31534: LIST
31535: PUSH
31536: LD_INT 2
31538: NEG
31539: PUSH
31540: LD_INT 1
31542: NEG
31543: PUSH
31544: EMPTY
31545: LIST
31546: LIST
31547: PUSH
31548: LD_INT 2
31550: NEG
31551: PUSH
31552: LD_INT 2
31554: NEG
31555: PUSH
31556: EMPTY
31557: LIST
31558: LIST
31559: PUSH
31560: LD_INT 1
31562: NEG
31563: PUSH
31564: LD_INT 3
31566: NEG
31567: PUSH
31568: EMPTY
31569: LIST
31570: LIST
31571: PUSH
31572: LD_INT 1
31574: PUSH
31575: LD_INT 2
31577: NEG
31578: PUSH
31579: EMPTY
31580: LIST
31581: LIST
31582: PUSH
31583: LD_INT 3
31585: PUSH
31586: LD_INT 2
31588: PUSH
31589: EMPTY
31590: LIST
31591: LIST
31592: PUSH
31593: LD_INT 2
31595: PUSH
31596: LD_INT 3
31598: PUSH
31599: EMPTY
31600: LIST
31601: LIST
31602: PUSH
31603: LD_INT 2
31605: NEG
31606: PUSH
31607: LD_INT 1
31609: PUSH
31610: EMPTY
31611: LIST
31612: LIST
31613: PUSH
31614: LD_INT 3
31616: NEG
31617: PUSH
31618: LD_INT 1
31620: NEG
31621: PUSH
31622: EMPTY
31623: LIST
31624: LIST
31625: PUSH
31626: EMPTY
31627: LIST
31628: LIST
31629: LIST
31630: LIST
31631: LIST
31632: LIST
31633: LIST
31634: LIST
31635: LIST
31636: LIST
31637: LIST
31638: LIST
31639: LIST
31640: LIST
31641: LIST
31642: LIST
31643: LIST
31644: LIST
31645: LIST
31646: LIST
31647: LIST
31648: LIST
31649: LIST
31650: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
31651: LD_ADDR_VAR 0 35
31655: PUSH
31656: LD_INT 0
31658: PUSH
31659: LD_INT 0
31661: PUSH
31662: EMPTY
31663: LIST
31664: LIST
31665: PUSH
31666: LD_INT 0
31668: PUSH
31669: LD_INT 1
31671: NEG
31672: PUSH
31673: EMPTY
31674: LIST
31675: LIST
31676: PUSH
31677: LD_INT 1
31679: PUSH
31680: LD_INT 0
31682: PUSH
31683: EMPTY
31684: LIST
31685: LIST
31686: PUSH
31687: LD_INT 1
31689: PUSH
31690: LD_INT 1
31692: PUSH
31693: EMPTY
31694: LIST
31695: LIST
31696: PUSH
31697: LD_INT 0
31699: PUSH
31700: LD_INT 1
31702: PUSH
31703: EMPTY
31704: LIST
31705: LIST
31706: PUSH
31707: LD_INT 1
31709: NEG
31710: PUSH
31711: LD_INT 0
31713: PUSH
31714: EMPTY
31715: LIST
31716: LIST
31717: PUSH
31718: LD_INT 1
31720: NEG
31721: PUSH
31722: LD_INT 1
31724: NEG
31725: PUSH
31726: EMPTY
31727: LIST
31728: LIST
31729: PUSH
31730: LD_INT 2
31732: PUSH
31733: LD_INT 1
31735: PUSH
31736: EMPTY
31737: LIST
31738: LIST
31739: PUSH
31740: LD_INT 2
31742: NEG
31743: PUSH
31744: LD_INT 1
31746: NEG
31747: PUSH
31748: EMPTY
31749: LIST
31750: LIST
31751: PUSH
31752: EMPTY
31753: LIST
31754: LIST
31755: LIST
31756: LIST
31757: LIST
31758: LIST
31759: LIST
31760: LIST
31761: LIST
31762: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
31763: LD_ADDR_VAR 0 36
31767: PUSH
31768: LD_INT 0
31770: PUSH
31771: LD_INT 0
31773: PUSH
31774: EMPTY
31775: LIST
31776: LIST
31777: PUSH
31778: LD_INT 0
31780: PUSH
31781: LD_INT 1
31783: NEG
31784: PUSH
31785: EMPTY
31786: LIST
31787: LIST
31788: PUSH
31789: LD_INT 1
31791: PUSH
31792: LD_INT 0
31794: PUSH
31795: EMPTY
31796: LIST
31797: LIST
31798: PUSH
31799: LD_INT 1
31801: PUSH
31802: LD_INT 1
31804: PUSH
31805: EMPTY
31806: LIST
31807: LIST
31808: PUSH
31809: LD_INT 0
31811: PUSH
31812: LD_INT 1
31814: PUSH
31815: EMPTY
31816: LIST
31817: LIST
31818: PUSH
31819: LD_INT 1
31821: NEG
31822: PUSH
31823: LD_INT 0
31825: PUSH
31826: EMPTY
31827: LIST
31828: LIST
31829: PUSH
31830: LD_INT 1
31832: NEG
31833: PUSH
31834: LD_INT 1
31836: NEG
31837: PUSH
31838: EMPTY
31839: LIST
31840: LIST
31841: PUSH
31842: LD_INT 1
31844: NEG
31845: PUSH
31846: LD_INT 2
31848: NEG
31849: PUSH
31850: EMPTY
31851: LIST
31852: LIST
31853: PUSH
31854: LD_INT 1
31856: PUSH
31857: LD_INT 2
31859: PUSH
31860: EMPTY
31861: LIST
31862: LIST
31863: PUSH
31864: EMPTY
31865: LIST
31866: LIST
31867: LIST
31868: LIST
31869: LIST
31870: LIST
31871: LIST
31872: LIST
31873: LIST
31874: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
31875: LD_ADDR_VAR 0 37
31879: PUSH
31880: LD_INT 0
31882: PUSH
31883: LD_INT 0
31885: PUSH
31886: EMPTY
31887: LIST
31888: LIST
31889: PUSH
31890: LD_INT 0
31892: PUSH
31893: LD_INT 1
31895: NEG
31896: PUSH
31897: EMPTY
31898: LIST
31899: LIST
31900: PUSH
31901: LD_INT 1
31903: PUSH
31904: LD_INT 0
31906: PUSH
31907: EMPTY
31908: LIST
31909: LIST
31910: PUSH
31911: LD_INT 1
31913: PUSH
31914: LD_INT 1
31916: PUSH
31917: EMPTY
31918: LIST
31919: LIST
31920: PUSH
31921: LD_INT 0
31923: PUSH
31924: LD_INT 1
31926: PUSH
31927: EMPTY
31928: LIST
31929: LIST
31930: PUSH
31931: LD_INT 1
31933: NEG
31934: PUSH
31935: LD_INT 0
31937: PUSH
31938: EMPTY
31939: LIST
31940: LIST
31941: PUSH
31942: LD_INT 1
31944: NEG
31945: PUSH
31946: LD_INT 1
31948: NEG
31949: PUSH
31950: EMPTY
31951: LIST
31952: LIST
31953: PUSH
31954: LD_INT 1
31956: PUSH
31957: LD_INT 1
31959: NEG
31960: PUSH
31961: EMPTY
31962: LIST
31963: LIST
31964: PUSH
31965: LD_INT 1
31967: NEG
31968: PUSH
31969: LD_INT 1
31971: PUSH
31972: EMPTY
31973: LIST
31974: LIST
31975: PUSH
31976: EMPTY
31977: LIST
31978: LIST
31979: LIST
31980: LIST
31981: LIST
31982: LIST
31983: LIST
31984: LIST
31985: LIST
31986: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
31987: LD_ADDR_VAR 0 38
31991: PUSH
31992: LD_INT 0
31994: PUSH
31995: LD_INT 0
31997: PUSH
31998: EMPTY
31999: LIST
32000: LIST
32001: PUSH
32002: LD_INT 0
32004: PUSH
32005: LD_INT 1
32007: NEG
32008: PUSH
32009: EMPTY
32010: LIST
32011: LIST
32012: PUSH
32013: LD_INT 1
32015: PUSH
32016: LD_INT 0
32018: PUSH
32019: EMPTY
32020: LIST
32021: LIST
32022: PUSH
32023: LD_INT 1
32025: PUSH
32026: LD_INT 1
32028: PUSH
32029: EMPTY
32030: LIST
32031: LIST
32032: PUSH
32033: LD_INT 0
32035: PUSH
32036: LD_INT 1
32038: PUSH
32039: EMPTY
32040: LIST
32041: LIST
32042: PUSH
32043: LD_INT 1
32045: NEG
32046: PUSH
32047: LD_INT 0
32049: PUSH
32050: EMPTY
32051: LIST
32052: LIST
32053: PUSH
32054: LD_INT 1
32056: NEG
32057: PUSH
32058: LD_INT 1
32060: NEG
32061: PUSH
32062: EMPTY
32063: LIST
32064: LIST
32065: PUSH
32066: LD_INT 2
32068: PUSH
32069: LD_INT 1
32071: PUSH
32072: EMPTY
32073: LIST
32074: LIST
32075: PUSH
32076: LD_INT 2
32078: NEG
32079: PUSH
32080: LD_INT 1
32082: NEG
32083: PUSH
32084: EMPTY
32085: LIST
32086: LIST
32087: PUSH
32088: EMPTY
32089: LIST
32090: LIST
32091: LIST
32092: LIST
32093: LIST
32094: LIST
32095: LIST
32096: LIST
32097: LIST
32098: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
32099: LD_ADDR_VAR 0 39
32103: PUSH
32104: LD_INT 0
32106: PUSH
32107: LD_INT 0
32109: PUSH
32110: EMPTY
32111: LIST
32112: LIST
32113: PUSH
32114: LD_INT 0
32116: PUSH
32117: LD_INT 1
32119: NEG
32120: PUSH
32121: EMPTY
32122: LIST
32123: LIST
32124: PUSH
32125: LD_INT 1
32127: PUSH
32128: LD_INT 0
32130: PUSH
32131: EMPTY
32132: LIST
32133: LIST
32134: PUSH
32135: LD_INT 1
32137: PUSH
32138: LD_INT 1
32140: PUSH
32141: EMPTY
32142: LIST
32143: LIST
32144: PUSH
32145: LD_INT 0
32147: PUSH
32148: LD_INT 1
32150: PUSH
32151: EMPTY
32152: LIST
32153: LIST
32154: PUSH
32155: LD_INT 1
32157: NEG
32158: PUSH
32159: LD_INT 0
32161: PUSH
32162: EMPTY
32163: LIST
32164: LIST
32165: PUSH
32166: LD_INT 1
32168: NEG
32169: PUSH
32170: LD_INT 1
32172: NEG
32173: PUSH
32174: EMPTY
32175: LIST
32176: LIST
32177: PUSH
32178: LD_INT 1
32180: NEG
32181: PUSH
32182: LD_INT 2
32184: NEG
32185: PUSH
32186: EMPTY
32187: LIST
32188: LIST
32189: PUSH
32190: LD_INT 1
32192: PUSH
32193: LD_INT 2
32195: PUSH
32196: EMPTY
32197: LIST
32198: LIST
32199: PUSH
32200: EMPTY
32201: LIST
32202: LIST
32203: LIST
32204: LIST
32205: LIST
32206: LIST
32207: LIST
32208: LIST
32209: LIST
32210: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
32211: LD_ADDR_VAR 0 40
32215: PUSH
32216: LD_INT 0
32218: PUSH
32219: LD_INT 0
32221: PUSH
32222: EMPTY
32223: LIST
32224: LIST
32225: PUSH
32226: LD_INT 0
32228: PUSH
32229: LD_INT 1
32231: NEG
32232: PUSH
32233: EMPTY
32234: LIST
32235: LIST
32236: PUSH
32237: LD_INT 1
32239: PUSH
32240: LD_INT 0
32242: PUSH
32243: EMPTY
32244: LIST
32245: LIST
32246: PUSH
32247: LD_INT 1
32249: PUSH
32250: LD_INT 1
32252: PUSH
32253: EMPTY
32254: LIST
32255: LIST
32256: PUSH
32257: LD_INT 0
32259: PUSH
32260: LD_INT 1
32262: PUSH
32263: EMPTY
32264: LIST
32265: LIST
32266: PUSH
32267: LD_INT 1
32269: NEG
32270: PUSH
32271: LD_INT 0
32273: PUSH
32274: EMPTY
32275: LIST
32276: LIST
32277: PUSH
32278: LD_INT 1
32280: NEG
32281: PUSH
32282: LD_INT 1
32284: NEG
32285: PUSH
32286: EMPTY
32287: LIST
32288: LIST
32289: PUSH
32290: LD_INT 1
32292: PUSH
32293: LD_INT 1
32295: NEG
32296: PUSH
32297: EMPTY
32298: LIST
32299: LIST
32300: PUSH
32301: LD_INT 1
32303: NEG
32304: PUSH
32305: LD_INT 1
32307: PUSH
32308: EMPTY
32309: LIST
32310: LIST
32311: PUSH
32312: EMPTY
32313: LIST
32314: LIST
32315: LIST
32316: LIST
32317: LIST
32318: LIST
32319: LIST
32320: LIST
32321: LIST
32322: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32323: LD_ADDR_VAR 0 41
32327: PUSH
32328: LD_INT 0
32330: PUSH
32331: LD_INT 0
32333: PUSH
32334: EMPTY
32335: LIST
32336: LIST
32337: PUSH
32338: LD_INT 0
32340: PUSH
32341: LD_INT 1
32343: NEG
32344: PUSH
32345: EMPTY
32346: LIST
32347: LIST
32348: PUSH
32349: LD_INT 1
32351: PUSH
32352: LD_INT 0
32354: PUSH
32355: EMPTY
32356: LIST
32357: LIST
32358: PUSH
32359: LD_INT 1
32361: PUSH
32362: LD_INT 1
32364: PUSH
32365: EMPTY
32366: LIST
32367: LIST
32368: PUSH
32369: LD_INT 0
32371: PUSH
32372: LD_INT 1
32374: PUSH
32375: EMPTY
32376: LIST
32377: LIST
32378: PUSH
32379: LD_INT 1
32381: NEG
32382: PUSH
32383: LD_INT 0
32385: PUSH
32386: EMPTY
32387: LIST
32388: LIST
32389: PUSH
32390: LD_INT 1
32392: NEG
32393: PUSH
32394: LD_INT 1
32396: NEG
32397: PUSH
32398: EMPTY
32399: LIST
32400: LIST
32401: PUSH
32402: LD_INT 1
32404: NEG
32405: PUSH
32406: LD_INT 2
32408: NEG
32409: PUSH
32410: EMPTY
32411: LIST
32412: LIST
32413: PUSH
32414: LD_INT 1
32416: PUSH
32417: LD_INT 1
32419: NEG
32420: PUSH
32421: EMPTY
32422: LIST
32423: LIST
32424: PUSH
32425: LD_INT 2
32427: PUSH
32428: LD_INT 0
32430: PUSH
32431: EMPTY
32432: LIST
32433: LIST
32434: PUSH
32435: LD_INT 2
32437: PUSH
32438: LD_INT 1
32440: PUSH
32441: EMPTY
32442: LIST
32443: LIST
32444: PUSH
32445: LD_INT 2
32447: PUSH
32448: LD_INT 2
32450: PUSH
32451: EMPTY
32452: LIST
32453: LIST
32454: PUSH
32455: LD_INT 1
32457: PUSH
32458: LD_INT 2
32460: PUSH
32461: EMPTY
32462: LIST
32463: LIST
32464: PUSH
32465: LD_INT 1
32467: NEG
32468: PUSH
32469: LD_INT 1
32471: PUSH
32472: EMPTY
32473: LIST
32474: LIST
32475: PUSH
32476: LD_INT 2
32478: NEG
32479: PUSH
32480: LD_INT 0
32482: PUSH
32483: EMPTY
32484: LIST
32485: LIST
32486: PUSH
32487: LD_INT 2
32489: NEG
32490: PUSH
32491: LD_INT 1
32493: NEG
32494: PUSH
32495: EMPTY
32496: LIST
32497: LIST
32498: PUSH
32499: LD_INT 2
32501: NEG
32502: PUSH
32503: LD_INT 2
32505: NEG
32506: PUSH
32507: EMPTY
32508: LIST
32509: LIST
32510: PUSH
32511: LD_INT 2
32513: NEG
32514: PUSH
32515: LD_INT 3
32517: NEG
32518: PUSH
32519: EMPTY
32520: LIST
32521: LIST
32522: PUSH
32523: LD_INT 2
32525: PUSH
32526: LD_INT 1
32528: NEG
32529: PUSH
32530: EMPTY
32531: LIST
32532: LIST
32533: PUSH
32534: LD_INT 3
32536: PUSH
32537: LD_INT 0
32539: PUSH
32540: EMPTY
32541: LIST
32542: LIST
32543: PUSH
32544: LD_INT 3
32546: PUSH
32547: LD_INT 1
32549: PUSH
32550: EMPTY
32551: LIST
32552: LIST
32553: PUSH
32554: LD_INT 3
32556: PUSH
32557: LD_INT 2
32559: PUSH
32560: EMPTY
32561: LIST
32562: LIST
32563: PUSH
32564: LD_INT 3
32566: PUSH
32567: LD_INT 3
32569: PUSH
32570: EMPTY
32571: LIST
32572: LIST
32573: PUSH
32574: LD_INT 2
32576: PUSH
32577: LD_INT 3
32579: PUSH
32580: EMPTY
32581: LIST
32582: LIST
32583: PUSH
32584: LD_INT 2
32586: NEG
32587: PUSH
32588: LD_INT 1
32590: PUSH
32591: EMPTY
32592: LIST
32593: LIST
32594: PUSH
32595: LD_INT 3
32597: NEG
32598: PUSH
32599: LD_INT 0
32601: PUSH
32602: EMPTY
32603: LIST
32604: LIST
32605: PUSH
32606: LD_INT 3
32608: NEG
32609: PUSH
32610: LD_INT 1
32612: NEG
32613: PUSH
32614: EMPTY
32615: LIST
32616: LIST
32617: PUSH
32618: LD_INT 3
32620: NEG
32621: PUSH
32622: LD_INT 2
32624: NEG
32625: PUSH
32626: EMPTY
32627: LIST
32628: LIST
32629: PUSH
32630: LD_INT 3
32632: NEG
32633: PUSH
32634: LD_INT 3
32636: NEG
32637: PUSH
32638: EMPTY
32639: LIST
32640: LIST
32641: PUSH
32642: EMPTY
32643: LIST
32644: LIST
32645: LIST
32646: LIST
32647: LIST
32648: LIST
32649: LIST
32650: LIST
32651: LIST
32652: LIST
32653: LIST
32654: LIST
32655: LIST
32656: LIST
32657: LIST
32658: LIST
32659: LIST
32660: LIST
32661: LIST
32662: LIST
32663: LIST
32664: LIST
32665: LIST
32666: LIST
32667: LIST
32668: LIST
32669: LIST
32670: LIST
32671: LIST
32672: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32673: LD_ADDR_VAR 0 42
32677: PUSH
32678: LD_INT 0
32680: PUSH
32681: LD_INT 0
32683: PUSH
32684: EMPTY
32685: LIST
32686: LIST
32687: PUSH
32688: LD_INT 0
32690: PUSH
32691: LD_INT 1
32693: NEG
32694: PUSH
32695: EMPTY
32696: LIST
32697: LIST
32698: PUSH
32699: LD_INT 1
32701: PUSH
32702: LD_INT 0
32704: PUSH
32705: EMPTY
32706: LIST
32707: LIST
32708: PUSH
32709: LD_INT 1
32711: PUSH
32712: LD_INT 1
32714: PUSH
32715: EMPTY
32716: LIST
32717: LIST
32718: PUSH
32719: LD_INT 0
32721: PUSH
32722: LD_INT 1
32724: PUSH
32725: EMPTY
32726: LIST
32727: LIST
32728: PUSH
32729: LD_INT 1
32731: NEG
32732: PUSH
32733: LD_INT 0
32735: PUSH
32736: EMPTY
32737: LIST
32738: LIST
32739: PUSH
32740: LD_INT 1
32742: NEG
32743: PUSH
32744: LD_INT 1
32746: NEG
32747: PUSH
32748: EMPTY
32749: LIST
32750: LIST
32751: PUSH
32752: LD_INT 1
32754: NEG
32755: PUSH
32756: LD_INT 2
32758: NEG
32759: PUSH
32760: EMPTY
32761: LIST
32762: LIST
32763: PUSH
32764: LD_INT 0
32766: PUSH
32767: LD_INT 2
32769: NEG
32770: PUSH
32771: EMPTY
32772: LIST
32773: LIST
32774: PUSH
32775: LD_INT 1
32777: PUSH
32778: LD_INT 1
32780: NEG
32781: PUSH
32782: EMPTY
32783: LIST
32784: LIST
32785: PUSH
32786: LD_INT 2
32788: PUSH
32789: LD_INT 1
32791: PUSH
32792: EMPTY
32793: LIST
32794: LIST
32795: PUSH
32796: LD_INT 2
32798: PUSH
32799: LD_INT 2
32801: PUSH
32802: EMPTY
32803: LIST
32804: LIST
32805: PUSH
32806: LD_INT 1
32808: PUSH
32809: LD_INT 2
32811: PUSH
32812: EMPTY
32813: LIST
32814: LIST
32815: PUSH
32816: LD_INT 0
32818: PUSH
32819: LD_INT 2
32821: PUSH
32822: EMPTY
32823: LIST
32824: LIST
32825: PUSH
32826: LD_INT 1
32828: NEG
32829: PUSH
32830: LD_INT 1
32832: PUSH
32833: EMPTY
32834: LIST
32835: LIST
32836: PUSH
32837: LD_INT 2
32839: NEG
32840: PUSH
32841: LD_INT 1
32843: NEG
32844: PUSH
32845: EMPTY
32846: LIST
32847: LIST
32848: PUSH
32849: LD_INT 2
32851: NEG
32852: PUSH
32853: LD_INT 2
32855: NEG
32856: PUSH
32857: EMPTY
32858: LIST
32859: LIST
32860: PUSH
32861: LD_INT 2
32863: NEG
32864: PUSH
32865: LD_INT 3
32867: NEG
32868: PUSH
32869: EMPTY
32870: LIST
32871: LIST
32872: PUSH
32873: LD_INT 1
32875: NEG
32876: PUSH
32877: LD_INT 3
32879: NEG
32880: PUSH
32881: EMPTY
32882: LIST
32883: LIST
32884: PUSH
32885: LD_INT 0
32887: PUSH
32888: LD_INT 3
32890: NEG
32891: PUSH
32892: EMPTY
32893: LIST
32894: LIST
32895: PUSH
32896: LD_INT 1
32898: PUSH
32899: LD_INT 2
32901: NEG
32902: PUSH
32903: EMPTY
32904: LIST
32905: LIST
32906: PUSH
32907: LD_INT 3
32909: PUSH
32910: LD_INT 2
32912: PUSH
32913: EMPTY
32914: LIST
32915: LIST
32916: PUSH
32917: LD_INT 3
32919: PUSH
32920: LD_INT 3
32922: PUSH
32923: EMPTY
32924: LIST
32925: LIST
32926: PUSH
32927: LD_INT 2
32929: PUSH
32930: LD_INT 3
32932: PUSH
32933: EMPTY
32934: LIST
32935: LIST
32936: PUSH
32937: LD_INT 1
32939: PUSH
32940: LD_INT 3
32942: PUSH
32943: EMPTY
32944: LIST
32945: LIST
32946: PUSH
32947: LD_INT 0
32949: PUSH
32950: LD_INT 3
32952: PUSH
32953: EMPTY
32954: LIST
32955: LIST
32956: PUSH
32957: LD_INT 1
32959: NEG
32960: PUSH
32961: LD_INT 2
32963: PUSH
32964: EMPTY
32965: LIST
32966: LIST
32967: PUSH
32968: LD_INT 3
32970: NEG
32971: PUSH
32972: LD_INT 2
32974: NEG
32975: PUSH
32976: EMPTY
32977: LIST
32978: LIST
32979: PUSH
32980: LD_INT 3
32982: NEG
32983: PUSH
32984: LD_INT 3
32986: NEG
32987: PUSH
32988: EMPTY
32989: LIST
32990: LIST
32991: PUSH
32992: EMPTY
32993: LIST
32994: LIST
32995: LIST
32996: LIST
32997: LIST
32998: LIST
32999: LIST
33000: LIST
33001: LIST
33002: LIST
33003: LIST
33004: LIST
33005: LIST
33006: LIST
33007: LIST
33008: LIST
33009: LIST
33010: LIST
33011: LIST
33012: LIST
33013: LIST
33014: LIST
33015: LIST
33016: LIST
33017: LIST
33018: LIST
33019: LIST
33020: LIST
33021: LIST
33022: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
33023: LD_ADDR_VAR 0 43
33027: PUSH
33028: LD_INT 0
33030: PUSH
33031: LD_INT 0
33033: PUSH
33034: EMPTY
33035: LIST
33036: LIST
33037: PUSH
33038: LD_INT 0
33040: PUSH
33041: LD_INT 1
33043: NEG
33044: PUSH
33045: EMPTY
33046: LIST
33047: LIST
33048: PUSH
33049: LD_INT 1
33051: PUSH
33052: LD_INT 0
33054: PUSH
33055: EMPTY
33056: LIST
33057: LIST
33058: PUSH
33059: LD_INT 1
33061: PUSH
33062: LD_INT 1
33064: PUSH
33065: EMPTY
33066: LIST
33067: LIST
33068: PUSH
33069: LD_INT 0
33071: PUSH
33072: LD_INT 1
33074: PUSH
33075: EMPTY
33076: LIST
33077: LIST
33078: PUSH
33079: LD_INT 1
33081: NEG
33082: PUSH
33083: LD_INT 0
33085: PUSH
33086: EMPTY
33087: LIST
33088: LIST
33089: PUSH
33090: LD_INT 1
33092: NEG
33093: PUSH
33094: LD_INT 1
33096: NEG
33097: PUSH
33098: EMPTY
33099: LIST
33100: LIST
33101: PUSH
33102: LD_INT 1
33104: NEG
33105: PUSH
33106: LD_INT 2
33108: NEG
33109: PUSH
33110: EMPTY
33111: LIST
33112: LIST
33113: PUSH
33114: LD_INT 0
33116: PUSH
33117: LD_INT 2
33119: NEG
33120: PUSH
33121: EMPTY
33122: LIST
33123: LIST
33124: PUSH
33125: LD_INT 1
33127: PUSH
33128: LD_INT 1
33130: NEG
33131: PUSH
33132: EMPTY
33133: LIST
33134: LIST
33135: PUSH
33136: LD_INT 2
33138: PUSH
33139: LD_INT 0
33141: PUSH
33142: EMPTY
33143: LIST
33144: LIST
33145: PUSH
33146: LD_INT 2
33148: PUSH
33149: LD_INT 1
33151: PUSH
33152: EMPTY
33153: LIST
33154: LIST
33155: PUSH
33156: LD_INT 1
33158: PUSH
33159: LD_INT 2
33161: PUSH
33162: EMPTY
33163: LIST
33164: LIST
33165: PUSH
33166: LD_INT 0
33168: PUSH
33169: LD_INT 2
33171: PUSH
33172: EMPTY
33173: LIST
33174: LIST
33175: PUSH
33176: LD_INT 1
33178: NEG
33179: PUSH
33180: LD_INT 1
33182: PUSH
33183: EMPTY
33184: LIST
33185: LIST
33186: PUSH
33187: LD_INT 2
33189: NEG
33190: PUSH
33191: LD_INT 0
33193: PUSH
33194: EMPTY
33195: LIST
33196: LIST
33197: PUSH
33198: LD_INT 2
33200: NEG
33201: PUSH
33202: LD_INT 1
33204: NEG
33205: PUSH
33206: EMPTY
33207: LIST
33208: LIST
33209: PUSH
33210: LD_INT 1
33212: NEG
33213: PUSH
33214: LD_INT 3
33216: NEG
33217: PUSH
33218: EMPTY
33219: LIST
33220: LIST
33221: PUSH
33222: LD_INT 0
33224: PUSH
33225: LD_INT 3
33227: NEG
33228: PUSH
33229: EMPTY
33230: LIST
33231: LIST
33232: PUSH
33233: LD_INT 1
33235: PUSH
33236: LD_INT 2
33238: NEG
33239: PUSH
33240: EMPTY
33241: LIST
33242: LIST
33243: PUSH
33244: LD_INT 2
33246: PUSH
33247: LD_INT 1
33249: NEG
33250: PUSH
33251: EMPTY
33252: LIST
33253: LIST
33254: PUSH
33255: LD_INT 3
33257: PUSH
33258: LD_INT 0
33260: PUSH
33261: EMPTY
33262: LIST
33263: LIST
33264: PUSH
33265: LD_INT 3
33267: PUSH
33268: LD_INT 1
33270: PUSH
33271: EMPTY
33272: LIST
33273: LIST
33274: PUSH
33275: LD_INT 1
33277: PUSH
33278: LD_INT 3
33280: PUSH
33281: EMPTY
33282: LIST
33283: LIST
33284: PUSH
33285: LD_INT 0
33287: PUSH
33288: LD_INT 3
33290: PUSH
33291: EMPTY
33292: LIST
33293: LIST
33294: PUSH
33295: LD_INT 1
33297: NEG
33298: PUSH
33299: LD_INT 2
33301: PUSH
33302: EMPTY
33303: LIST
33304: LIST
33305: PUSH
33306: LD_INT 2
33308: NEG
33309: PUSH
33310: LD_INT 1
33312: PUSH
33313: EMPTY
33314: LIST
33315: LIST
33316: PUSH
33317: LD_INT 3
33319: NEG
33320: PUSH
33321: LD_INT 0
33323: PUSH
33324: EMPTY
33325: LIST
33326: LIST
33327: PUSH
33328: LD_INT 3
33330: NEG
33331: PUSH
33332: LD_INT 1
33334: NEG
33335: PUSH
33336: EMPTY
33337: LIST
33338: LIST
33339: PUSH
33340: EMPTY
33341: LIST
33342: LIST
33343: LIST
33344: LIST
33345: LIST
33346: LIST
33347: LIST
33348: LIST
33349: LIST
33350: LIST
33351: LIST
33352: LIST
33353: LIST
33354: LIST
33355: LIST
33356: LIST
33357: LIST
33358: LIST
33359: LIST
33360: LIST
33361: LIST
33362: LIST
33363: LIST
33364: LIST
33365: LIST
33366: LIST
33367: LIST
33368: LIST
33369: LIST
33370: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33371: LD_ADDR_VAR 0 44
33375: PUSH
33376: LD_INT 0
33378: PUSH
33379: LD_INT 0
33381: PUSH
33382: EMPTY
33383: LIST
33384: LIST
33385: PUSH
33386: LD_INT 0
33388: PUSH
33389: LD_INT 1
33391: NEG
33392: PUSH
33393: EMPTY
33394: LIST
33395: LIST
33396: PUSH
33397: LD_INT 1
33399: PUSH
33400: LD_INT 0
33402: PUSH
33403: EMPTY
33404: LIST
33405: LIST
33406: PUSH
33407: LD_INT 1
33409: PUSH
33410: LD_INT 1
33412: PUSH
33413: EMPTY
33414: LIST
33415: LIST
33416: PUSH
33417: LD_INT 0
33419: PUSH
33420: LD_INT 1
33422: PUSH
33423: EMPTY
33424: LIST
33425: LIST
33426: PUSH
33427: LD_INT 1
33429: NEG
33430: PUSH
33431: LD_INT 0
33433: PUSH
33434: EMPTY
33435: LIST
33436: LIST
33437: PUSH
33438: LD_INT 1
33440: NEG
33441: PUSH
33442: LD_INT 1
33444: NEG
33445: PUSH
33446: EMPTY
33447: LIST
33448: LIST
33449: PUSH
33450: LD_INT 1
33452: NEG
33453: PUSH
33454: LD_INT 2
33456: NEG
33457: PUSH
33458: EMPTY
33459: LIST
33460: LIST
33461: PUSH
33462: LD_INT 1
33464: PUSH
33465: LD_INT 1
33467: NEG
33468: PUSH
33469: EMPTY
33470: LIST
33471: LIST
33472: PUSH
33473: LD_INT 2
33475: PUSH
33476: LD_INT 0
33478: PUSH
33479: EMPTY
33480: LIST
33481: LIST
33482: PUSH
33483: LD_INT 2
33485: PUSH
33486: LD_INT 1
33488: PUSH
33489: EMPTY
33490: LIST
33491: LIST
33492: PUSH
33493: LD_INT 2
33495: PUSH
33496: LD_INT 2
33498: PUSH
33499: EMPTY
33500: LIST
33501: LIST
33502: PUSH
33503: LD_INT 1
33505: PUSH
33506: LD_INT 2
33508: PUSH
33509: EMPTY
33510: LIST
33511: LIST
33512: PUSH
33513: LD_INT 1
33515: NEG
33516: PUSH
33517: LD_INT 1
33519: PUSH
33520: EMPTY
33521: LIST
33522: LIST
33523: PUSH
33524: LD_INT 2
33526: NEG
33527: PUSH
33528: LD_INT 0
33530: PUSH
33531: EMPTY
33532: LIST
33533: LIST
33534: PUSH
33535: LD_INT 2
33537: NEG
33538: PUSH
33539: LD_INT 1
33541: NEG
33542: PUSH
33543: EMPTY
33544: LIST
33545: LIST
33546: PUSH
33547: LD_INT 2
33549: NEG
33550: PUSH
33551: LD_INT 2
33553: NEG
33554: PUSH
33555: EMPTY
33556: LIST
33557: LIST
33558: PUSH
33559: LD_INT 2
33561: NEG
33562: PUSH
33563: LD_INT 3
33565: NEG
33566: PUSH
33567: EMPTY
33568: LIST
33569: LIST
33570: PUSH
33571: LD_INT 2
33573: PUSH
33574: LD_INT 1
33576: NEG
33577: PUSH
33578: EMPTY
33579: LIST
33580: LIST
33581: PUSH
33582: LD_INT 3
33584: PUSH
33585: LD_INT 0
33587: PUSH
33588: EMPTY
33589: LIST
33590: LIST
33591: PUSH
33592: LD_INT 3
33594: PUSH
33595: LD_INT 1
33597: PUSH
33598: EMPTY
33599: LIST
33600: LIST
33601: PUSH
33602: LD_INT 3
33604: PUSH
33605: LD_INT 2
33607: PUSH
33608: EMPTY
33609: LIST
33610: LIST
33611: PUSH
33612: LD_INT 3
33614: PUSH
33615: LD_INT 3
33617: PUSH
33618: EMPTY
33619: LIST
33620: LIST
33621: PUSH
33622: LD_INT 2
33624: PUSH
33625: LD_INT 3
33627: PUSH
33628: EMPTY
33629: LIST
33630: LIST
33631: PUSH
33632: LD_INT 2
33634: NEG
33635: PUSH
33636: LD_INT 1
33638: PUSH
33639: EMPTY
33640: LIST
33641: LIST
33642: PUSH
33643: LD_INT 3
33645: NEG
33646: PUSH
33647: LD_INT 0
33649: PUSH
33650: EMPTY
33651: LIST
33652: LIST
33653: PUSH
33654: LD_INT 3
33656: NEG
33657: PUSH
33658: LD_INT 1
33660: NEG
33661: PUSH
33662: EMPTY
33663: LIST
33664: LIST
33665: PUSH
33666: LD_INT 3
33668: NEG
33669: PUSH
33670: LD_INT 2
33672: NEG
33673: PUSH
33674: EMPTY
33675: LIST
33676: LIST
33677: PUSH
33678: LD_INT 3
33680: NEG
33681: PUSH
33682: LD_INT 3
33684: NEG
33685: PUSH
33686: EMPTY
33687: LIST
33688: LIST
33689: PUSH
33690: EMPTY
33691: LIST
33692: LIST
33693: LIST
33694: LIST
33695: LIST
33696: LIST
33697: LIST
33698: LIST
33699: LIST
33700: LIST
33701: LIST
33702: LIST
33703: LIST
33704: LIST
33705: LIST
33706: LIST
33707: LIST
33708: LIST
33709: LIST
33710: LIST
33711: LIST
33712: LIST
33713: LIST
33714: LIST
33715: LIST
33716: LIST
33717: LIST
33718: LIST
33719: LIST
33720: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33721: LD_ADDR_VAR 0 45
33725: PUSH
33726: LD_INT 0
33728: PUSH
33729: LD_INT 0
33731: PUSH
33732: EMPTY
33733: LIST
33734: LIST
33735: PUSH
33736: LD_INT 0
33738: PUSH
33739: LD_INT 1
33741: NEG
33742: PUSH
33743: EMPTY
33744: LIST
33745: LIST
33746: PUSH
33747: LD_INT 1
33749: PUSH
33750: LD_INT 0
33752: PUSH
33753: EMPTY
33754: LIST
33755: LIST
33756: PUSH
33757: LD_INT 1
33759: PUSH
33760: LD_INT 1
33762: PUSH
33763: EMPTY
33764: LIST
33765: LIST
33766: PUSH
33767: LD_INT 0
33769: PUSH
33770: LD_INT 1
33772: PUSH
33773: EMPTY
33774: LIST
33775: LIST
33776: PUSH
33777: LD_INT 1
33779: NEG
33780: PUSH
33781: LD_INT 0
33783: PUSH
33784: EMPTY
33785: LIST
33786: LIST
33787: PUSH
33788: LD_INT 1
33790: NEG
33791: PUSH
33792: LD_INT 1
33794: NEG
33795: PUSH
33796: EMPTY
33797: LIST
33798: LIST
33799: PUSH
33800: LD_INT 1
33802: NEG
33803: PUSH
33804: LD_INT 2
33806: NEG
33807: PUSH
33808: EMPTY
33809: LIST
33810: LIST
33811: PUSH
33812: LD_INT 0
33814: PUSH
33815: LD_INT 2
33817: NEG
33818: PUSH
33819: EMPTY
33820: LIST
33821: LIST
33822: PUSH
33823: LD_INT 1
33825: PUSH
33826: LD_INT 1
33828: NEG
33829: PUSH
33830: EMPTY
33831: LIST
33832: LIST
33833: PUSH
33834: LD_INT 2
33836: PUSH
33837: LD_INT 1
33839: PUSH
33840: EMPTY
33841: LIST
33842: LIST
33843: PUSH
33844: LD_INT 2
33846: PUSH
33847: LD_INT 2
33849: PUSH
33850: EMPTY
33851: LIST
33852: LIST
33853: PUSH
33854: LD_INT 1
33856: PUSH
33857: LD_INT 2
33859: PUSH
33860: EMPTY
33861: LIST
33862: LIST
33863: PUSH
33864: LD_INT 0
33866: PUSH
33867: LD_INT 2
33869: PUSH
33870: EMPTY
33871: LIST
33872: LIST
33873: PUSH
33874: LD_INT 1
33876: NEG
33877: PUSH
33878: LD_INT 1
33880: PUSH
33881: EMPTY
33882: LIST
33883: LIST
33884: PUSH
33885: LD_INT 2
33887: NEG
33888: PUSH
33889: LD_INT 1
33891: NEG
33892: PUSH
33893: EMPTY
33894: LIST
33895: LIST
33896: PUSH
33897: LD_INT 2
33899: NEG
33900: PUSH
33901: LD_INT 2
33903: NEG
33904: PUSH
33905: EMPTY
33906: LIST
33907: LIST
33908: PUSH
33909: LD_INT 2
33911: NEG
33912: PUSH
33913: LD_INT 3
33915: NEG
33916: PUSH
33917: EMPTY
33918: LIST
33919: LIST
33920: PUSH
33921: LD_INT 1
33923: NEG
33924: PUSH
33925: LD_INT 3
33927: NEG
33928: PUSH
33929: EMPTY
33930: LIST
33931: LIST
33932: PUSH
33933: LD_INT 0
33935: PUSH
33936: LD_INT 3
33938: NEG
33939: PUSH
33940: EMPTY
33941: LIST
33942: LIST
33943: PUSH
33944: LD_INT 1
33946: PUSH
33947: LD_INT 2
33949: NEG
33950: PUSH
33951: EMPTY
33952: LIST
33953: LIST
33954: PUSH
33955: LD_INT 3
33957: PUSH
33958: LD_INT 2
33960: PUSH
33961: EMPTY
33962: LIST
33963: LIST
33964: PUSH
33965: LD_INT 3
33967: PUSH
33968: LD_INT 3
33970: PUSH
33971: EMPTY
33972: LIST
33973: LIST
33974: PUSH
33975: LD_INT 2
33977: PUSH
33978: LD_INT 3
33980: PUSH
33981: EMPTY
33982: LIST
33983: LIST
33984: PUSH
33985: LD_INT 1
33987: PUSH
33988: LD_INT 3
33990: PUSH
33991: EMPTY
33992: LIST
33993: LIST
33994: PUSH
33995: LD_INT 0
33997: PUSH
33998: LD_INT 3
34000: PUSH
34001: EMPTY
34002: LIST
34003: LIST
34004: PUSH
34005: LD_INT 1
34007: NEG
34008: PUSH
34009: LD_INT 2
34011: PUSH
34012: EMPTY
34013: LIST
34014: LIST
34015: PUSH
34016: LD_INT 3
34018: NEG
34019: PUSH
34020: LD_INT 2
34022: NEG
34023: PUSH
34024: EMPTY
34025: LIST
34026: LIST
34027: PUSH
34028: LD_INT 3
34030: NEG
34031: PUSH
34032: LD_INT 3
34034: NEG
34035: PUSH
34036: EMPTY
34037: LIST
34038: LIST
34039: PUSH
34040: EMPTY
34041: LIST
34042: LIST
34043: LIST
34044: LIST
34045: LIST
34046: LIST
34047: LIST
34048: LIST
34049: LIST
34050: LIST
34051: LIST
34052: LIST
34053: LIST
34054: LIST
34055: LIST
34056: LIST
34057: LIST
34058: LIST
34059: LIST
34060: LIST
34061: LIST
34062: LIST
34063: LIST
34064: LIST
34065: LIST
34066: LIST
34067: LIST
34068: LIST
34069: LIST
34070: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
34071: LD_ADDR_VAR 0 46
34075: PUSH
34076: LD_INT 0
34078: PUSH
34079: LD_INT 0
34081: PUSH
34082: EMPTY
34083: LIST
34084: LIST
34085: PUSH
34086: LD_INT 0
34088: PUSH
34089: LD_INT 1
34091: NEG
34092: PUSH
34093: EMPTY
34094: LIST
34095: LIST
34096: PUSH
34097: LD_INT 1
34099: PUSH
34100: LD_INT 0
34102: PUSH
34103: EMPTY
34104: LIST
34105: LIST
34106: PUSH
34107: LD_INT 1
34109: PUSH
34110: LD_INT 1
34112: PUSH
34113: EMPTY
34114: LIST
34115: LIST
34116: PUSH
34117: LD_INT 0
34119: PUSH
34120: LD_INT 1
34122: PUSH
34123: EMPTY
34124: LIST
34125: LIST
34126: PUSH
34127: LD_INT 1
34129: NEG
34130: PUSH
34131: LD_INT 0
34133: PUSH
34134: EMPTY
34135: LIST
34136: LIST
34137: PUSH
34138: LD_INT 1
34140: NEG
34141: PUSH
34142: LD_INT 1
34144: NEG
34145: PUSH
34146: EMPTY
34147: LIST
34148: LIST
34149: PUSH
34150: LD_INT 1
34152: NEG
34153: PUSH
34154: LD_INT 2
34156: NEG
34157: PUSH
34158: EMPTY
34159: LIST
34160: LIST
34161: PUSH
34162: LD_INT 0
34164: PUSH
34165: LD_INT 2
34167: NEG
34168: PUSH
34169: EMPTY
34170: LIST
34171: LIST
34172: PUSH
34173: LD_INT 1
34175: PUSH
34176: LD_INT 1
34178: NEG
34179: PUSH
34180: EMPTY
34181: LIST
34182: LIST
34183: PUSH
34184: LD_INT 2
34186: PUSH
34187: LD_INT 0
34189: PUSH
34190: EMPTY
34191: LIST
34192: LIST
34193: PUSH
34194: LD_INT 2
34196: PUSH
34197: LD_INT 1
34199: PUSH
34200: EMPTY
34201: LIST
34202: LIST
34203: PUSH
34204: LD_INT 1
34206: PUSH
34207: LD_INT 2
34209: PUSH
34210: EMPTY
34211: LIST
34212: LIST
34213: PUSH
34214: LD_INT 0
34216: PUSH
34217: LD_INT 2
34219: PUSH
34220: EMPTY
34221: LIST
34222: LIST
34223: PUSH
34224: LD_INT 1
34226: NEG
34227: PUSH
34228: LD_INT 1
34230: PUSH
34231: EMPTY
34232: LIST
34233: LIST
34234: PUSH
34235: LD_INT 2
34237: NEG
34238: PUSH
34239: LD_INT 0
34241: PUSH
34242: EMPTY
34243: LIST
34244: LIST
34245: PUSH
34246: LD_INT 2
34248: NEG
34249: PUSH
34250: LD_INT 1
34252: NEG
34253: PUSH
34254: EMPTY
34255: LIST
34256: LIST
34257: PUSH
34258: LD_INT 1
34260: NEG
34261: PUSH
34262: LD_INT 3
34264: NEG
34265: PUSH
34266: EMPTY
34267: LIST
34268: LIST
34269: PUSH
34270: LD_INT 0
34272: PUSH
34273: LD_INT 3
34275: NEG
34276: PUSH
34277: EMPTY
34278: LIST
34279: LIST
34280: PUSH
34281: LD_INT 1
34283: PUSH
34284: LD_INT 2
34286: NEG
34287: PUSH
34288: EMPTY
34289: LIST
34290: LIST
34291: PUSH
34292: LD_INT 2
34294: PUSH
34295: LD_INT 1
34297: NEG
34298: PUSH
34299: EMPTY
34300: LIST
34301: LIST
34302: PUSH
34303: LD_INT 3
34305: PUSH
34306: LD_INT 0
34308: PUSH
34309: EMPTY
34310: LIST
34311: LIST
34312: PUSH
34313: LD_INT 3
34315: PUSH
34316: LD_INT 1
34318: PUSH
34319: EMPTY
34320: LIST
34321: LIST
34322: PUSH
34323: LD_INT 1
34325: PUSH
34326: LD_INT 3
34328: PUSH
34329: EMPTY
34330: LIST
34331: LIST
34332: PUSH
34333: LD_INT 0
34335: PUSH
34336: LD_INT 3
34338: PUSH
34339: EMPTY
34340: LIST
34341: LIST
34342: PUSH
34343: LD_INT 1
34345: NEG
34346: PUSH
34347: LD_INT 2
34349: PUSH
34350: EMPTY
34351: LIST
34352: LIST
34353: PUSH
34354: LD_INT 2
34356: NEG
34357: PUSH
34358: LD_INT 1
34360: PUSH
34361: EMPTY
34362: LIST
34363: LIST
34364: PUSH
34365: LD_INT 3
34367: NEG
34368: PUSH
34369: LD_INT 0
34371: PUSH
34372: EMPTY
34373: LIST
34374: LIST
34375: PUSH
34376: LD_INT 3
34378: NEG
34379: PUSH
34380: LD_INT 1
34382: NEG
34383: PUSH
34384: EMPTY
34385: LIST
34386: LIST
34387: PUSH
34388: EMPTY
34389: LIST
34390: LIST
34391: LIST
34392: LIST
34393: LIST
34394: LIST
34395: LIST
34396: LIST
34397: LIST
34398: LIST
34399: LIST
34400: LIST
34401: LIST
34402: LIST
34403: LIST
34404: LIST
34405: LIST
34406: LIST
34407: LIST
34408: LIST
34409: LIST
34410: LIST
34411: LIST
34412: LIST
34413: LIST
34414: LIST
34415: LIST
34416: LIST
34417: LIST
34418: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34419: LD_ADDR_VAR 0 47
34423: PUSH
34424: LD_INT 0
34426: PUSH
34427: LD_INT 0
34429: PUSH
34430: EMPTY
34431: LIST
34432: LIST
34433: PUSH
34434: LD_INT 0
34436: PUSH
34437: LD_INT 1
34439: NEG
34440: PUSH
34441: EMPTY
34442: LIST
34443: LIST
34444: PUSH
34445: LD_INT 1
34447: PUSH
34448: LD_INT 0
34450: PUSH
34451: EMPTY
34452: LIST
34453: LIST
34454: PUSH
34455: LD_INT 1
34457: PUSH
34458: LD_INT 1
34460: PUSH
34461: EMPTY
34462: LIST
34463: LIST
34464: PUSH
34465: LD_INT 0
34467: PUSH
34468: LD_INT 1
34470: PUSH
34471: EMPTY
34472: LIST
34473: LIST
34474: PUSH
34475: LD_INT 1
34477: NEG
34478: PUSH
34479: LD_INT 0
34481: PUSH
34482: EMPTY
34483: LIST
34484: LIST
34485: PUSH
34486: LD_INT 1
34488: NEG
34489: PUSH
34490: LD_INT 1
34492: NEG
34493: PUSH
34494: EMPTY
34495: LIST
34496: LIST
34497: PUSH
34498: LD_INT 1
34500: NEG
34501: PUSH
34502: LD_INT 2
34504: NEG
34505: PUSH
34506: EMPTY
34507: LIST
34508: LIST
34509: PUSH
34510: LD_INT 0
34512: PUSH
34513: LD_INT 2
34515: NEG
34516: PUSH
34517: EMPTY
34518: LIST
34519: LIST
34520: PUSH
34521: LD_INT 1
34523: PUSH
34524: LD_INT 1
34526: NEG
34527: PUSH
34528: EMPTY
34529: LIST
34530: LIST
34531: PUSH
34532: LD_INT 2
34534: NEG
34535: PUSH
34536: LD_INT 1
34538: NEG
34539: PUSH
34540: EMPTY
34541: LIST
34542: LIST
34543: PUSH
34544: LD_INT 2
34546: NEG
34547: PUSH
34548: LD_INT 2
34550: NEG
34551: PUSH
34552: EMPTY
34553: LIST
34554: LIST
34555: PUSH
34556: EMPTY
34557: LIST
34558: LIST
34559: LIST
34560: LIST
34561: LIST
34562: LIST
34563: LIST
34564: LIST
34565: LIST
34566: LIST
34567: LIST
34568: LIST
34569: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
34570: LD_ADDR_VAR 0 48
34574: PUSH
34575: LD_INT 0
34577: PUSH
34578: LD_INT 0
34580: PUSH
34581: EMPTY
34582: LIST
34583: LIST
34584: PUSH
34585: LD_INT 0
34587: PUSH
34588: LD_INT 1
34590: NEG
34591: PUSH
34592: EMPTY
34593: LIST
34594: LIST
34595: PUSH
34596: LD_INT 1
34598: PUSH
34599: LD_INT 0
34601: PUSH
34602: EMPTY
34603: LIST
34604: LIST
34605: PUSH
34606: LD_INT 1
34608: PUSH
34609: LD_INT 1
34611: PUSH
34612: EMPTY
34613: LIST
34614: LIST
34615: PUSH
34616: LD_INT 0
34618: PUSH
34619: LD_INT 1
34621: PUSH
34622: EMPTY
34623: LIST
34624: LIST
34625: PUSH
34626: LD_INT 1
34628: NEG
34629: PUSH
34630: LD_INT 0
34632: PUSH
34633: EMPTY
34634: LIST
34635: LIST
34636: PUSH
34637: LD_INT 1
34639: NEG
34640: PUSH
34641: LD_INT 1
34643: NEG
34644: PUSH
34645: EMPTY
34646: LIST
34647: LIST
34648: PUSH
34649: LD_INT 1
34651: NEG
34652: PUSH
34653: LD_INT 2
34655: NEG
34656: PUSH
34657: EMPTY
34658: LIST
34659: LIST
34660: PUSH
34661: LD_INT 0
34663: PUSH
34664: LD_INT 2
34666: NEG
34667: PUSH
34668: EMPTY
34669: LIST
34670: LIST
34671: PUSH
34672: LD_INT 1
34674: PUSH
34675: LD_INT 1
34677: NEG
34678: PUSH
34679: EMPTY
34680: LIST
34681: LIST
34682: PUSH
34683: LD_INT 2
34685: PUSH
34686: LD_INT 0
34688: PUSH
34689: EMPTY
34690: LIST
34691: LIST
34692: PUSH
34693: LD_INT 2
34695: PUSH
34696: LD_INT 1
34698: PUSH
34699: EMPTY
34700: LIST
34701: LIST
34702: PUSH
34703: EMPTY
34704: LIST
34705: LIST
34706: LIST
34707: LIST
34708: LIST
34709: LIST
34710: LIST
34711: LIST
34712: LIST
34713: LIST
34714: LIST
34715: LIST
34716: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
34717: LD_ADDR_VAR 0 49
34721: PUSH
34722: LD_INT 0
34724: PUSH
34725: LD_INT 0
34727: PUSH
34728: EMPTY
34729: LIST
34730: LIST
34731: PUSH
34732: LD_INT 0
34734: PUSH
34735: LD_INT 1
34737: NEG
34738: PUSH
34739: EMPTY
34740: LIST
34741: LIST
34742: PUSH
34743: LD_INT 1
34745: PUSH
34746: LD_INT 0
34748: PUSH
34749: EMPTY
34750: LIST
34751: LIST
34752: PUSH
34753: LD_INT 1
34755: PUSH
34756: LD_INT 1
34758: PUSH
34759: EMPTY
34760: LIST
34761: LIST
34762: PUSH
34763: LD_INT 0
34765: PUSH
34766: LD_INT 1
34768: PUSH
34769: EMPTY
34770: LIST
34771: LIST
34772: PUSH
34773: LD_INT 1
34775: NEG
34776: PUSH
34777: LD_INT 0
34779: PUSH
34780: EMPTY
34781: LIST
34782: LIST
34783: PUSH
34784: LD_INT 1
34786: NEG
34787: PUSH
34788: LD_INT 1
34790: NEG
34791: PUSH
34792: EMPTY
34793: LIST
34794: LIST
34795: PUSH
34796: LD_INT 1
34798: PUSH
34799: LD_INT 1
34801: NEG
34802: PUSH
34803: EMPTY
34804: LIST
34805: LIST
34806: PUSH
34807: LD_INT 2
34809: PUSH
34810: LD_INT 0
34812: PUSH
34813: EMPTY
34814: LIST
34815: LIST
34816: PUSH
34817: LD_INT 2
34819: PUSH
34820: LD_INT 1
34822: PUSH
34823: EMPTY
34824: LIST
34825: LIST
34826: PUSH
34827: LD_INT 2
34829: PUSH
34830: LD_INT 2
34832: PUSH
34833: EMPTY
34834: LIST
34835: LIST
34836: PUSH
34837: LD_INT 1
34839: PUSH
34840: LD_INT 2
34842: PUSH
34843: EMPTY
34844: LIST
34845: LIST
34846: PUSH
34847: EMPTY
34848: LIST
34849: LIST
34850: LIST
34851: LIST
34852: LIST
34853: LIST
34854: LIST
34855: LIST
34856: LIST
34857: LIST
34858: LIST
34859: LIST
34860: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
34861: LD_ADDR_VAR 0 50
34865: PUSH
34866: LD_INT 0
34868: PUSH
34869: LD_INT 0
34871: PUSH
34872: EMPTY
34873: LIST
34874: LIST
34875: PUSH
34876: LD_INT 0
34878: PUSH
34879: LD_INT 1
34881: NEG
34882: PUSH
34883: EMPTY
34884: LIST
34885: LIST
34886: PUSH
34887: LD_INT 1
34889: PUSH
34890: LD_INT 0
34892: PUSH
34893: EMPTY
34894: LIST
34895: LIST
34896: PUSH
34897: LD_INT 1
34899: PUSH
34900: LD_INT 1
34902: PUSH
34903: EMPTY
34904: LIST
34905: LIST
34906: PUSH
34907: LD_INT 0
34909: PUSH
34910: LD_INT 1
34912: PUSH
34913: EMPTY
34914: LIST
34915: LIST
34916: PUSH
34917: LD_INT 1
34919: NEG
34920: PUSH
34921: LD_INT 0
34923: PUSH
34924: EMPTY
34925: LIST
34926: LIST
34927: PUSH
34928: LD_INT 1
34930: NEG
34931: PUSH
34932: LD_INT 1
34934: NEG
34935: PUSH
34936: EMPTY
34937: LIST
34938: LIST
34939: PUSH
34940: LD_INT 2
34942: PUSH
34943: LD_INT 1
34945: PUSH
34946: EMPTY
34947: LIST
34948: LIST
34949: PUSH
34950: LD_INT 2
34952: PUSH
34953: LD_INT 2
34955: PUSH
34956: EMPTY
34957: LIST
34958: LIST
34959: PUSH
34960: LD_INT 1
34962: PUSH
34963: LD_INT 2
34965: PUSH
34966: EMPTY
34967: LIST
34968: LIST
34969: PUSH
34970: LD_INT 0
34972: PUSH
34973: LD_INT 2
34975: PUSH
34976: EMPTY
34977: LIST
34978: LIST
34979: PUSH
34980: LD_INT 1
34982: NEG
34983: PUSH
34984: LD_INT 1
34986: PUSH
34987: EMPTY
34988: LIST
34989: LIST
34990: PUSH
34991: EMPTY
34992: LIST
34993: LIST
34994: LIST
34995: LIST
34996: LIST
34997: LIST
34998: LIST
34999: LIST
35000: LIST
35001: LIST
35002: LIST
35003: LIST
35004: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
35005: LD_ADDR_VAR 0 51
35009: PUSH
35010: LD_INT 0
35012: PUSH
35013: LD_INT 0
35015: PUSH
35016: EMPTY
35017: LIST
35018: LIST
35019: PUSH
35020: LD_INT 0
35022: PUSH
35023: LD_INT 1
35025: NEG
35026: PUSH
35027: EMPTY
35028: LIST
35029: LIST
35030: PUSH
35031: LD_INT 1
35033: PUSH
35034: LD_INT 0
35036: PUSH
35037: EMPTY
35038: LIST
35039: LIST
35040: PUSH
35041: LD_INT 1
35043: PUSH
35044: LD_INT 1
35046: PUSH
35047: EMPTY
35048: LIST
35049: LIST
35050: PUSH
35051: LD_INT 0
35053: PUSH
35054: LD_INT 1
35056: PUSH
35057: EMPTY
35058: LIST
35059: LIST
35060: PUSH
35061: LD_INT 1
35063: NEG
35064: PUSH
35065: LD_INT 0
35067: PUSH
35068: EMPTY
35069: LIST
35070: LIST
35071: PUSH
35072: LD_INT 1
35074: NEG
35075: PUSH
35076: LD_INT 1
35078: NEG
35079: PUSH
35080: EMPTY
35081: LIST
35082: LIST
35083: PUSH
35084: LD_INT 1
35086: PUSH
35087: LD_INT 2
35089: PUSH
35090: EMPTY
35091: LIST
35092: LIST
35093: PUSH
35094: LD_INT 0
35096: PUSH
35097: LD_INT 2
35099: PUSH
35100: EMPTY
35101: LIST
35102: LIST
35103: PUSH
35104: LD_INT 1
35106: NEG
35107: PUSH
35108: LD_INT 1
35110: PUSH
35111: EMPTY
35112: LIST
35113: LIST
35114: PUSH
35115: LD_INT 2
35117: NEG
35118: PUSH
35119: LD_INT 0
35121: PUSH
35122: EMPTY
35123: LIST
35124: LIST
35125: PUSH
35126: LD_INT 2
35128: NEG
35129: PUSH
35130: LD_INT 1
35132: NEG
35133: PUSH
35134: EMPTY
35135: LIST
35136: LIST
35137: PUSH
35138: EMPTY
35139: LIST
35140: LIST
35141: LIST
35142: LIST
35143: LIST
35144: LIST
35145: LIST
35146: LIST
35147: LIST
35148: LIST
35149: LIST
35150: LIST
35151: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35152: LD_ADDR_VAR 0 52
35156: PUSH
35157: LD_INT 0
35159: PUSH
35160: LD_INT 0
35162: PUSH
35163: EMPTY
35164: LIST
35165: LIST
35166: PUSH
35167: LD_INT 0
35169: PUSH
35170: LD_INT 1
35172: NEG
35173: PUSH
35174: EMPTY
35175: LIST
35176: LIST
35177: PUSH
35178: LD_INT 1
35180: PUSH
35181: LD_INT 0
35183: PUSH
35184: EMPTY
35185: LIST
35186: LIST
35187: PUSH
35188: LD_INT 1
35190: PUSH
35191: LD_INT 1
35193: PUSH
35194: EMPTY
35195: LIST
35196: LIST
35197: PUSH
35198: LD_INT 0
35200: PUSH
35201: LD_INT 1
35203: PUSH
35204: EMPTY
35205: LIST
35206: LIST
35207: PUSH
35208: LD_INT 1
35210: NEG
35211: PUSH
35212: LD_INT 0
35214: PUSH
35215: EMPTY
35216: LIST
35217: LIST
35218: PUSH
35219: LD_INT 1
35221: NEG
35222: PUSH
35223: LD_INT 1
35225: NEG
35226: PUSH
35227: EMPTY
35228: LIST
35229: LIST
35230: PUSH
35231: LD_INT 1
35233: NEG
35234: PUSH
35235: LD_INT 2
35237: NEG
35238: PUSH
35239: EMPTY
35240: LIST
35241: LIST
35242: PUSH
35243: LD_INT 1
35245: NEG
35246: PUSH
35247: LD_INT 1
35249: PUSH
35250: EMPTY
35251: LIST
35252: LIST
35253: PUSH
35254: LD_INT 2
35256: NEG
35257: PUSH
35258: LD_INT 0
35260: PUSH
35261: EMPTY
35262: LIST
35263: LIST
35264: PUSH
35265: LD_INT 2
35267: NEG
35268: PUSH
35269: LD_INT 1
35271: NEG
35272: PUSH
35273: EMPTY
35274: LIST
35275: LIST
35276: PUSH
35277: LD_INT 2
35279: NEG
35280: PUSH
35281: LD_INT 2
35283: NEG
35284: PUSH
35285: EMPTY
35286: LIST
35287: LIST
35288: PUSH
35289: EMPTY
35290: LIST
35291: LIST
35292: LIST
35293: LIST
35294: LIST
35295: LIST
35296: LIST
35297: LIST
35298: LIST
35299: LIST
35300: LIST
35301: LIST
35302: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35303: LD_ADDR_VAR 0 53
35307: PUSH
35308: LD_INT 0
35310: PUSH
35311: LD_INT 0
35313: PUSH
35314: EMPTY
35315: LIST
35316: LIST
35317: PUSH
35318: LD_INT 0
35320: PUSH
35321: LD_INT 1
35323: NEG
35324: PUSH
35325: EMPTY
35326: LIST
35327: LIST
35328: PUSH
35329: LD_INT 1
35331: PUSH
35332: LD_INT 0
35334: PUSH
35335: EMPTY
35336: LIST
35337: LIST
35338: PUSH
35339: LD_INT 1
35341: PUSH
35342: LD_INT 1
35344: PUSH
35345: EMPTY
35346: LIST
35347: LIST
35348: PUSH
35349: LD_INT 0
35351: PUSH
35352: LD_INT 1
35354: PUSH
35355: EMPTY
35356: LIST
35357: LIST
35358: PUSH
35359: LD_INT 1
35361: NEG
35362: PUSH
35363: LD_INT 0
35365: PUSH
35366: EMPTY
35367: LIST
35368: LIST
35369: PUSH
35370: LD_INT 1
35372: NEG
35373: PUSH
35374: LD_INT 1
35376: NEG
35377: PUSH
35378: EMPTY
35379: LIST
35380: LIST
35381: PUSH
35382: LD_INT 1
35384: NEG
35385: PUSH
35386: LD_INT 2
35388: NEG
35389: PUSH
35390: EMPTY
35391: LIST
35392: LIST
35393: PUSH
35394: LD_INT 0
35396: PUSH
35397: LD_INT 2
35399: NEG
35400: PUSH
35401: EMPTY
35402: LIST
35403: LIST
35404: PUSH
35405: LD_INT 1
35407: PUSH
35408: LD_INT 1
35410: NEG
35411: PUSH
35412: EMPTY
35413: LIST
35414: LIST
35415: PUSH
35416: LD_INT 2
35418: PUSH
35419: LD_INT 0
35421: PUSH
35422: EMPTY
35423: LIST
35424: LIST
35425: PUSH
35426: LD_INT 2
35428: PUSH
35429: LD_INT 1
35431: PUSH
35432: EMPTY
35433: LIST
35434: LIST
35435: PUSH
35436: LD_INT 2
35438: PUSH
35439: LD_INT 2
35441: PUSH
35442: EMPTY
35443: LIST
35444: LIST
35445: PUSH
35446: LD_INT 1
35448: PUSH
35449: LD_INT 2
35451: PUSH
35452: EMPTY
35453: LIST
35454: LIST
35455: PUSH
35456: LD_INT 0
35458: PUSH
35459: LD_INT 2
35461: PUSH
35462: EMPTY
35463: LIST
35464: LIST
35465: PUSH
35466: LD_INT 1
35468: NEG
35469: PUSH
35470: LD_INT 1
35472: PUSH
35473: EMPTY
35474: LIST
35475: LIST
35476: PUSH
35477: LD_INT 2
35479: NEG
35480: PUSH
35481: LD_INT 0
35483: PUSH
35484: EMPTY
35485: LIST
35486: LIST
35487: PUSH
35488: LD_INT 2
35490: NEG
35491: PUSH
35492: LD_INT 1
35494: NEG
35495: PUSH
35496: EMPTY
35497: LIST
35498: LIST
35499: PUSH
35500: LD_INT 2
35502: NEG
35503: PUSH
35504: LD_INT 2
35506: NEG
35507: PUSH
35508: EMPTY
35509: LIST
35510: LIST
35511: PUSH
35512: EMPTY
35513: LIST
35514: LIST
35515: LIST
35516: LIST
35517: LIST
35518: LIST
35519: LIST
35520: LIST
35521: LIST
35522: LIST
35523: LIST
35524: LIST
35525: LIST
35526: LIST
35527: LIST
35528: LIST
35529: LIST
35530: LIST
35531: LIST
35532: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35533: LD_ADDR_VAR 0 54
35537: PUSH
35538: LD_INT 0
35540: PUSH
35541: LD_INT 0
35543: PUSH
35544: EMPTY
35545: LIST
35546: LIST
35547: PUSH
35548: LD_INT 0
35550: PUSH
35551: LD_INT 1
35553: NEG
35554: PUSH
35555: EMPTY
35556: LIST
35557: LIST
35558: PUSH
35559: LD_INT 1
35561: PUSH
35562: LD_INT 0
35564: PUSH
35565: EMPTY
35566: LIST
35567: LIST
35568: PUSH
35569: LD_INT 1
35571: PUSH
35572: LD_INT 1
35574: PUSH
35575: EMPTY
35576: LIST
35577: LIST
35578: PUSH
35579: LD_INT 0
35581: PUSH
35582: LD_INT 1
35584: PUSH
35585: EMPTY
35586: LIST
35587: LIST
35588: PUSH
35589: LD_INT 1
35591: NEG
35592: PUSH
35593: LD_INT 0
35595: PUSH
35596: EMPTY
35597: LIST
35598: LIST
35599: PUSH
35600: LD_INT 1
35602: NEG
35603: PUSH
35604: LD_INT 1
35606: NEG
35607: PUSH
35608: EMPTY
35609: LIST
35610: LIST
35611: PUSH
35612: LD_INT 1
35614: NEG
35615: PUSH
35616: LD_INT 2
35618: NEG
35619: PUSH
35620: EMPTY
35621: LIST
35622: LIST
35623: PUSH
35624: LD_INT 0
35626: PUSH
35627: LD_INT 2
35629: NEG
35630: PUSH
35631: EMPTY
35632: LIST
35633: LIST
35634: PUSH
35635: LD_INT 1
35637: PUSH
35638: LD_INT 1
35640: NEG
35641: PUSH
35642: EMPTY
35643: LIST
35644: LIST
35645: PUSH
35646: LD_INT 2
35648: PUSH
35649: LD_INT 0
35651: PUSH
35652: EMPTY
35653: LIST
35654: LIST
35655: PUSH
35656: LD_INT 2
35658: PUSH
35659: LD_INT 1
35661: PUSH
35662: EMPTY
35663: LIST
35664: LIST
35665: PUSH
35666: LD_INT 2
35668: PUSH
35669: LD_INT 2
35671: PUSH
35672: EMPTY
35673: LIST
35674: LIST
35675: PUSH
35676: LD_INT 1
35678: PUSH
35679: LD_INT 2
35681: PUSH
35682: EMPTY
35683: LIST
35684: LIST
35685: PUSH
35686: LD_INT 0
35688: PUSH
35689: LD_INT 2
35691: PUSH
35692: EMPTY
35693: LIST
35694: LIST
35695: PUSH
35696: LD_INT 1
35698: NEG
35699: PUSH
35700: LD_INT 1
35702: PUSH
35703: EMPTY
35704: LIST
35705: LIST
35706: PUSH
35707: LD_INT 2
35709: NEG
35710: PUSH
35711: LD_INT 0
35713: PUSH
35714: EMPTY
35715: LIST
35716: LIST
35717: PUSH
35718: LD_INT 2
35720: NEG
35721: PUSH
35722: LD_INT 1
35724: NEG
35725: PUSH
35726: EMPTY
35727: LIST
35728: LIST
35729: PUSH
35730: LD_INT 2
35732: NEG
35733: PUSH
35734: LD_INT 2
35736: NEG
35737: PUSH
35738: EMPTY
35739: LIST
35740: LIST
35741: PUSH
35742: EMPTY
35743: LIST
35744: LIST
35745: LIST
35746: LIST
35747: LIST
35748: LIST
35749: LIST
35750: LIST
35751: LIST
35752: LIST
35753: LIST
35754: LIST
35755: LIST
35756: LIST
35757: LIST
35758: LIST
35759: LIST
35760: LIST
35761: LIST
35762: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35763: LD_ADDR_VAR 0 55
35767: PUSH
35768: LD_INT 0
35770: PUSH
35771: LD_INT 0
35773: PUSH
35774: EMPTY
35775: LIST
35776: LIST
35777: PUSH
35778: LD_INT 0
35780: PUSH
35781: LD_INT 1
35783: NEG
35784: PUSH
35785: EMPTY
35786: LIST
35787: LIST
35788: PUSH
35789: LD_INT 1
35791: PUSH
35792: LD_INT 0
35794: PUSH
35795: EMPTY
35796: LIST
35797: LIST
35798: PUSH
35799: LD_INT 1
35801: PUSH
35802: LD_INT 1
35804: PUSH
35805: EMPTY
35806: LIST
35807: LIST
35808: PUSH
35809: LD_INT 0
35811: PUSH
35812: LD_INT 1
35814: PUSH
35815: EMPTY
35816: LIST
35817: LIST
35818: PUSH
35819: LD_INT 1
35821: NEG
35822: PUSH
35823: LD_INT 0
35825: PUSH
35826: EMPTY
35827: LIST
35828: LIST
35829: PUSH
35830: LD_INT 1
35832: NEG
35833: PUSH
35834: LD_INT 1
35836: NEG
35837: PUSH
35838: EMPTY
35839: LIST
35840: LIST
35841: PUSH
35842: LD_INT 1
35844: NEG
35845: PUSH
35846: LD_INT 2
35848: NEG
35849: PUSH
35850: EMPTY
35851: LIST
35852: LIST
35853: PUSH
35854: LD_INT 0
35856: PUSH
35857: LD_INT 2
35859: NEG
35860: PUSH
35861: EMPTY
35862: LIST
35863: LIST
35864: PUSH
35865: LD_INT 1
35867: PUSH
35868: LD_INT 1
35870: NEG
35871: PUSH
35872: EMPTY
35873: LIST
35874: LIST
35875: PUSH
35876: LD_INT 2
35878: PUSH
35879: LD_INT 0
35881: PUSH
35882: EMPTY
35883: LIST
35884: LIST
35885: PUSH
35886: LD_INT 2
35888: PUSH
35889: LD_INT 1
35891: PUSH
35892: EMPTY
35893: LIST
35894: LIST
35895: PUSH
35896: LD_INT 2
35898: PUSH
35899: LD_INT 2
35901: PUSH
35902: EMPTY
35903: LIST
35904: LIST
35905: PUSH
35906: LD_INT 1
35908: PUSH
35909: LD_INT 2
35911: PUSH
35912: EMPTY
35913: LIST
35914: LIST
35915: PUSH
35916: LD_INT 0
35918: PUSH
35919: LD_INT 2
35921: PUSH
35922: EMPTY
35923: LIST
35924: LIST
35925: PUSH
35926: LD_INT 1
35928: NEG
35929: PUSH
35930: LD_INT 1
35932: PUSH
35933: EMPTY
35934: LIST
35935: LIST
35936: PUSH
35937: LD_INT 2
35939: NEG
35940: PUSH
35941: LD_INT 0
35943: PUSH
35944: EMPTY
35945: LIST
35946: LIST
35947: PUSH
35948: LD_INT 2
35950: NEG
35951: PUSH
35952: LD_INT 1
35954: NEG
35955: PUSH
35956: EMPTY
35957: LIST
35958: LIST
35959: PUSH
35960: LD_INT 2
35962: NEG
35963: PUSH
35964: LD_INT 2
35966: NEG
35967: PUSH
35968: EMPTY
35969: LIST
35970: LIST
35971: PUSH
35972: EMPTY
35973: LIST
35974: LIST
35975: LIST
35976: LIST
35977: LIST
35978: LIST
35979: LIST
35980: LIST
35981: LIST
35982: LIST
35983: LIST
35984: LIST
35985: LIST
35986: LIST
35987: LIST
35988: LIST
35989: LIST
35990: LIST
35991: LIST
35992: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35993: LD_ADDR_VAR 0 56
35997: PUSH
35998: LD_INT 0
36000: PUSH
36001: LD_INT 0
36003: PUSH
36004: EMPTY
36005: LIST
36006: LIST
36007: PUSH
36008: LD_INT 0
36010: PUSH
36011: LD_INT 1
36013: NEG
36014: PUSH
36015: EMPTY
36016: LIST
36017: LIST
36018: PUSH
36019: LD_INT 1
36021: PUSH
36022: LD_INT 0
36024: PUSH
36025: EMPTY
36026: LIST
36027: LIST
36028: PUSH
36029: LD_INT 1
36031: PUSH
36032: LD_INT 1
36034: PUSH
36035: EMPTY
36036: LIST
36037: LIST
36038: PUSH
36039: LD_INT 0
36041: PUSH
36042: LD_INT 1
36044: PUSH
36045: EMPTY
36046: LIST
36047: LIST
36048: PUSH
36049: LD_INT 1
36051: NEG
36052: PUSH
36053: LD_INT 0
36055: PUSH
36056: EMPTY
36057: LIST
36058: LIST
36059: PUSH
36060: LD_INT 1
36062: NEG
36063: PUSH
36064: LD_INT 1
36066: NEG
36067: PUSH
36068: EMPTY
36069: LIST
36070: LIST
36071: PUSH
36072: LD_INT 1
36074: NEG
36075: PUSH
36076: LD_INT 2
36078: NEG
36079: PUSH
36080: EMPTY
36081: LIST
36082: LIST
36083: PUSH
36084: LD_INT 0
36086: PUSH
36087: LD_INT 2
36089: NEG
36090: PUSH
36091: EMPTY
36092: LIST
36093: LIST
36094: PUSH
36095: LD_INT 1
36097: PUSH
36098: LD_INT 1
36100: NEG
36101: PUSH
36102: EMPTY
36103: LIST
36104: LIST
36105: PUSH
36106: LD_INT 2
36108: PUSH
36109: LD_INT 0
36111: PUSH
36112: EMPTY
36113: LIST
36114: LIST
36115: PUSH
36116: LD_INT 2
36118: PUSH
36119: LD_INT 1
36121: PUSH
36122: EMPTY
36123: LIST
36124: LIST
36125: PUSH
36126: LD_INT 2
36128: PUSH
36129: LD_INT 2
36131: PUSH
36132: EMPTY
36133: LIST
36134: LIST
36135: PUSH
36136: LD_INT 1
36138: PUSH
36139: LD_INT 2
36141: PUSH
36142: EMPTY
36143: LIST
36144: LIST
36145: PUSH
36146: LD_INT 0
36148: PUSH
36149: LD_INT 2
36151: PUSH
36152: EMPTY
36153: LIST
36154: LIST
36155: PUSH
36156: LD_INT 1
36158: NEG
36159: PUSH
36160: LD_INT 1
36162: PUSH
36163: EMPTY
36164: LIST
36165: LIST
36166: PUSH
36167: LD_INT 2
36169: NEG
36170: PUSH
36171: LD_INT 0
36173: PUSH
36174: EMPTY
36175: LIST
36176: LIST
36177: PUSH
36178: LD_INT 2
36180: NEG
36181: PUSH
36182: LD_INT 1
36184: NEG
36185: PUSH
36186: EMPTY
36187: LIST
36188: LIST
36189: PUSH
36190: LD_INT 2
36192: NEG
36193: PUSH
36194: LD_INT 2
36196: NEG
36197: PUSH
36198: EMPTY
36199: LIST
36200: LIST
36201: PUSH
36202: EMPTY
36203: LIST
36204: LIST
36205: LIST
36206: LIST
36207: LIST
36208: LIST
36209: LIST
36210: LIST
36211: LIST
36212: LIST
36213: LIST
36214: LIST
36215: LIST
36216: LIST
36217: LIST
36218: LIST
36219: LIST
36220: LIST
36221: LIST
36222: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36223: LD_ADDR_VAR 0 57
36227: PUSH
36228: LD_INT 0
36230: PUSH
36231: LD_INT 0
36233: PUSH
36234: EMPTY
36235: LIST
36236: LIST
36237: PUSH
36238: LD_INT 0
36240: PUSH
36241: LD_INT 1
36243: NEG
36244: PUSH
36245: EMPTY
36246: LIST
36247: LIST
36248: PUSH
36249: LD_INT 1
36251: PUSH
36252: LD_INT 0
36254: PUSH
36255: EMPTY
36256: LIST
36257: LIST
36258: PUSH
36259: LD_INT 1
36261: PUSH
36262: LD_INT 1
36264: PUSH
36265: EMPTY
36266: LIST
36267: LIST
36268: PUSH
36269: LD_INT 0
36271: PUSH
36272: LD_INT 1
36274: PUSH
36275: EMPTY
36276: LIST
36277: LIST
36278: PUSH
36279: LD_INT 1
36281: NEG
36282: PUSH
36283: LD_INT 0
36285: PUSH
36286: EMPTY
36287: LIST
36288: LIST
36289: PUSH
36290: LD_INT 1
36292: NEG
36293: PUSH
36294: LD_INT 1
36296: NEG
36297: PUSH
36298: EMPTY
36299: LIST
36300: LIST
36301: PUSH
36302: LD_INT 1
36304: NEG
36305: PUSH
36306: LD_INT 2
36308: NEG
36309: PUSH
36310: EMPTY
36311: LIST
36312: LIST
36313: PUSH
36314: LD_INT 0
36316: PUSH
36317: LD_INT 2
36319: NEG
36320: PUSH
36321: EMPTY
36322: LIST
36323: LIST
36324: PUSH
36325: LD_INT 1
36327: PUSH
36328: LD_INT 1
36330: NEG
36331: PUSH
36332: EMPTY
36333: LIST
36334: LIST
36335: PUSH
36336: LD_INT 2
36338: PUSH
36339: LD_INT 0
36341: PUSH
36342: EMPTY
36343: LIST
36344: LIST
36345: PUSH
36346: LD_INT 2
36348: PUSH
36349: LD_INT 1
36351: PUSH
36352: EMPTY
36353: LIST
36354: LIST
36355: PUSH
36356: LD_INT 2
36358: PUSH
36359: LD_INT 2
36361: PUSH
36362: EMPTY
36363: LIST
36364: LIST
36365: PUSH
36366: LD_INT 1
36368: PUSH
36369: LD_INT 2
36371: PUSH
36372: EMPTY
36373: LIST
36374: LIST
36375: PUSH
36376: LD_INT 0
36378: PUSH
36379: LD_INT 2
36381: PUSH
36382: EMPTY
36383: LIST
36384: LIST
36385: PUSH
36386: LD_INT 1
36388: NEG
36389: PUSH
36390: LD_INT 1
36392: PUSH
36393: EMPTY
36394: LIST
36395: LIST
36396: PUSH
36397: LD_INT 2
36399: NEG
36400: PUSH
36401: LD_INT 0
36403: PUSH
36404: EMPTY
36405: LIST
36406: LIST
36407: PUSH
36408: LD_INT 2
36410: NEG
36411: PUSH
36412: LD_INT 1
36414: NEG
36415: PUSH
36416: EMPTY
36417: LIST
36418: LIST
36419: PUSH
36420: LD_INT 2
36422: NEG
36423: PUSH
36424: LD_INT 2
36426: NEG
36427: PUSH
36428: EMPTY
36429: LIST
36430: LIST
36431: PUSH
36432: EMPTY
36433: LIST
36434: LIST
36435: LIST
36436: LIST
36437: LIST
36438: LIST
36439: LIST
36440: LIST
36441: LIST
36442: LIST
36443: LIST
36444: LIST
36445: LIST
36446: LIST
36447: LIST
36448: LIST
36449: LIST
36450: LIST
36451: LIST
36452: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36453: LD_ADDR_VAR 0 58
36457: PUSH
36458: LD_INT 0
36460: PUSH
36461: LD_INT 0
36463: PUSH
36464: EMPTY
36465: LIST
36466: LIST
36467: PUSH
36468: LD_INT 0
36470: PUSH
36471: LD_INT 1
36473: NEG
36474: PUSH
36475: EMPTY
36476: LIST
36477: LIST
36478: PUSH
36479: LD_INT 1
36481: PUSH
36482: LD_INT 0
36484: PUSH
36485: EMPTY
36486: LIST
36487: LIST
36488: PUSH
36489: LD_INT 1
36491: PUSH
36492: LD_INT 1
36494: PUSH
36495: EMPTY
36496: LIST
36497: LIST
36498: PUSH
36499: LD_INT 0
36501: PUSH
36502: LD_INT 1
36504: PUSH
36505: EMPTY
36506: LIST
36507: LIST
36508: PUSH
36509: LD_INT 1
36511: NEG
36512: PUSH
36513: LD_INT 0
36515: PUSH
36516: EMPTY
36517: LIST
36518: LIST
36519: PUSH
36520: LD_INT 1
36522: NEG
36523: PUSH
36524: LD_INT 1
36526: NEG
36527: PUSH
36528: EMPTY
36529: LIST
36530: LIST
36531: PUSH
36532: LD_INT 1
36534: NEG
36535: PUSH
36536: LD_INT 2
36538: NEG
36539: PUSH
36540: EMPTY
36541: LIST
36542: LIST
36543: PUSH
36544: LD_INT 0
36546: PUSH
36547: LD_INT 2
36549: NEG
36550: PUSH
36551: EMPTY
36552: LIST
36553: LIST
36554: PUSH
36555: LD_INT 1
36557: PUSH
36558: LD_INT 1
36560: NEG
36561: PUSH
36562: EMPTY
36563: LIST
36564: LIST
36565: PUSH
36566: LD_INT 2
36568: PUSH
36569: LD_INT 0
36571: PUSH
36572: EMPTY
36573: LIST
36574: LIST
36575: PUSH
36576: LD_INT 2
36578: PUSH
36579: LD_INT 1
36581: PUSH
36582: EMPTY
36583: LIST
36584: LIST
36585: PUSH
36586: LD_INT 2
36588: PUSH
36589: LD_INT 2
36591: PUSH
36592: EMPTY
36593: LIST
36594: LIST
36595: PUSH
36596: LD_INT 1
36598: PUSH
36599: LD_INT 2
36601: PUSH
36602: EMPTY
36603: LIST
36604: LIST
36605: PUSH
36606: LD_INT 0
36608: PUSH
36609: LD_INT 2
36611: PUSH
36612: EMPTY
36613: LIST
36614: LIST
36615: PUSH
36616: LD_INT 1
36618: NEG
36619: PUSH
36620: LD_INT 1
36622: PUSH
36623: EMPTY
36624: LIST
36625: LIST
36626: PUSH
36627: LD_INT 2
36629: NEG
36630: PUSH
36631: LD_INT 0
36633: PUSH
36634: EMPTY
36635: LIST
36636: LIST
36637: PUSH
36638: LD_INT 2
36640: NEG
36641: PUSH
36642: LD_INT 1
36644: NEG
36645: PUSH
36646: EMPTY
36647: LIST
36648: LIST
36649: PUSH
36650: LD_INT 2
36652: NEG
36653: PUSH
36654: LD_INT 2
36656: NEG
36657: PUSH
36658: EMPTY
36659: LIST
36660: LIST
36661: PUSH
36662: EMPTY
36663: LIST
36664: LIST
36665: LIST
36666: LIST
36667: LIST
36668: LIST
36669: LIST
36670: LIST
36671: LIST
36672: LIST
36673: LIST
36674: LIST
36675: LIST
36676: LIST
36677: LIST
36678: LIST
36679: LIST
36680: LIST
36681: LIST
36682: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36683: LD_ADDR_VAR 0 59
36687: PUSH
36688: LD_INT 0
36690: PUSH
36691: LD_INT 0
36693: PUSH
36694: EMPTY
36695: LIST
36696: LIST
36697: PUSH
36698: LD_INT 0
36700: PUSH
36701: LD_INT 1
36703: NEG
36704: PUSH
36705: EMPTY
36706: LIST
36707: LIST
36708: PUSH
36709: LD_INT 1
36711: PUSH
36712: LD_INT 0
36714: PUSH
36715: EMPTY
36716: LIST
36717: LIST
36718: PUSH
36719: LD_INT 1
36721: PUSH
36722: LD_INT 1
36724: PUSH
36725: EMPTY
36726: LIST
36727: LIST
36728: PUSH
36729: LD_INT 0
36731: PUSH
36732: LD_INT 1
36734: PUSH
36735: EMPTY
36736: LIST
36737: LIST
36738: PUSH
36739: LD_INT 1
36741: NEG
36742: PUSH
36743: LD_INT 0
36745: PUSH
36746: EMPTY
36747: LIST
36748: LIST
36749: PUSH
36750: LD_INT 1
36752: NEG
36753: PUSH
36754: LD_INT 1
36756: NEG
36757: PUSH
36758: EMPTY
36759: LIST
36760: LIST
36761: PUSH
36762: EMPTY
36763: LIST
36764: LIST
36765: LIST
36766: LIST
36767: LIST
36768: LIST
36769: LIST
36770: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36771: LD_ADDR_VAR 0 60
36775: PUSH
36776: LD_INT 0
36778: PUSH
36779: LD_INT 0
36781: PUSH
36782: EMPTY
36783: LIST
36784: LIST
36785: PUSH
36786: LD_INT 0
36788: PUSH
36789: LD_INT 1
36791: NEG
36792: PUSH
36793: EMPTY
36794: LIST
36795: LIST
36796: PUSH
36797: LD_INT 1
36799: PUSH
36800: LD_INT 0
36802: PUSH
36803: EMPTY
36804: LIST
36805: LIST
36806: PUSH
36807: LD_INT 1
36809: PUSH
36810: LD_INT 1
36812: PUSH
36813: EMPTY
36814: LIST
36815: LIST
36816: PUSH
36817: LD_INT 0
36819: PUSH
36820: LD_INT 1
36822: PUSH
36823: EMPTY
36824: LIST
36825: LIST
36826: PUSH
36827: LD_INT 1
36829: NEG
36830: PUSH
36831: LD_INT 0
36833: PUSH
36834: EMPTY
36835: LIST
36836: LIST
36837: PUSH
36838: LD_INT 1
36840: NEG
36841: PUSH
36842: LD_INT 1
36844: NEG
36845: PUSH
36846: EMPTY
36847: LIST
36848: LIST
36849: PUSH
36850: EMPTY
36851: LIST
36852: LIST
36853: LIST
36854: LIST
36855: LIST
36856: LIST
36857: LIST
36858: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36859: LD_ADDR_VAR 0 61
36863: PUSH
36864: LD_INT 0
36866: PUSH
36867: LD_INT 0
36869: PUSH
36870: EMPTY
36871: LIST
36872: LIST
36873: PUSH
36874: LD_INT 0
36876: PUSH
36877: LD_INT 1
36879: NEG
36880: PUSH
36881: EMPTY
36882: LIST
36883: LIST
36884: PUSH
36885: LD_INT 1
36887: PUSH
36888: LD_INT 0
36890: PUSH
36891: EMPTY
36892: LIST
36893: LIST
36894: PUSH
36895: LD_INT 1
36897: PUSH
36898: LD_INT 1
36900: PUSH
36901: EMPTY
36902: LIST
36903: LIST
36904: PUSH
36905: LD_INT 0
36907: PUSH
36908: LD_INT 1
36910: PUSH
36911: EMPTY
36912: LIST
36913: LIST
36914: PUSH
36915: LD_INT 1
36917: NEG
36918: PUSH
36919: LD_INT 0
36921: PUSH
36922: EMPTY
36923: LIST
36924: LIST
36925: PUSH
36926: LD_INT 1
36928: NEG
36929: PUSH
36930: LD_INT 1
36932: NEG
36933: PUSH
36934: EMPTY
36935: LIST
36936: LIST
36937: PUSH
36938: EMPTY
36939: LIST
36940: LIST
36941: LIST
36942: LIST
36943: LIST
36944: LIST
36945: LIST
36946: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36947: LD_ADDR_VAR 0 62
36951: PUSH
36952: LD_INT 0
36954: PUSH
36955: LD_INT 0
36957: PUSH
36958: EMPTY
36959: LIST
36960: LIST
36961: PUSH
36962: LD_INT 0
36964: PUSH
36965: LD_INT 1
36967: NEG
36968: PUSH
36969: EMPTY
36970: LIST
36971: LIST
36972: PUSH
36973: LD_INT 1
36975: PUSH
36976: LD_INT 0
36978: PUSH
36979: EMPTY
36980: LIST
36981: LIST
36982: PUSH
36983: LD_INT 1
36985: PUSH
36986: LD_INT 1
36988: PUSH
36989: EMPTY
36990: LIST
36991: LIST
36992: PUSH
36993: LD_INT 0
36995: PUSH
36996: LD_INT 1
36998: PUSH
36999: EMPTY
37000: LIST
37001: LIST
37002: PUSH
37003: LD_INT 1
37005: NEG
37006: PUSH
37007: LD_INT 0
37009: PUSH
37010: EMPTY
37011: LIST
37012: LIST
37013: PUSH
37014: LD_INT 1
37016: NEG
37017: PUSH
37018: LD_INT 1
37020: NEG
37021: PUSH
37022: EMPTY
37023: LIST
37024: LIST
37025: PUSH
37026: EMPTY
37027: LIST
37028: LIST
37029: LIST
37030: LIST
37031: LIST
37032: LIST
37033: LIST
37034: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
37035: LD_ADDR_VAR 0 63
37039: PUSH
37040: LD_INT 0
37042: PUSH
37043: LD_INT 0
37045: PUSH
37046: EMPTY
37047: LIST
37048: LIST
37049: PUSH
37050: LD_INT 0
37052: PUSH
37053: LD_INT 1
37055: NEG
37056: PUSH
37057: EMPTY
37058: LIST
37059: LIST
37060: PUSH
37061: LD_INT 1
37063: PUSH
37064: LD_INT 0
37066: PUSH
37067: EMPTY
37068: LIST
37069: LIST
37070: PUSH
37071: LD_INT 1
37073: PUSH
37074: LD_INT 1
37076: PUSH
37077: EMPTY
37078: LIST
37079: LIST
37080: PUSH
37081: LD_INT 0
37083: PUSH
37084: LD_INT 1
37086: PUSH
37087: EMPTY
37088: LIST
37089: LIST
37090: PUSH
37091: LD_INT 1
37093: NEG
37094: PUSH
37095: LD_INT 0
37097: PUSH
37098: EMPTY
37099: LIST
37100: LIST
37101: PUSH
37102: LD_INT 1
37104: NEG
37105: PUSH
37106: LD_INT 1
37108: NEG
37109: PUSH
37110: EMPTY
37111: LIST
37112: LIST
37113: PUSH
37114: EMPTY
37115: LIST
37116: LIST
37117: LIST
37118: LIST
37119: LIST
37120: LIST
37121: LIST
37122: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
37123: LD_ADDR_VAR 0 64
37127: PUSH
37128: LD_INT 0
37130: PUSH
37131: LD_INT 0
37133: PUSH
37134: EMPTY
37135: LIST
37136: LIST
37137: PUSH
37138: LD_INT 0
37140: PUSH
37141: LD_INT 1
37143: NEG
37144: PUSH
37145: EMPTY
37146: LIST
37147: LIST
37148: PUSH
37149: LD_INT 1
37151: PUSH
37152: LD_INT 0
37154: PUSH
37155: EMPTY
37156: LIST
37157: LIST
37158: PUSH
37159: LD_INT 1
37161: PUSH
37162: LD_INT 1
37164: PUSH
37165: EMPTY
37166: LIST
37167: LIST
37168: PUSH
37169: LD_INT 0
37171: PUSH
37172: LD_INT 1
37174: PUSH
37175: EMPTY
37176: LIST
37177: LIST
37178: PUSH
37179: LD_INT 1
37181: NEG
37182: PUSH
37183: LD_INT 0
37185: PUSH
37186: EMPTY
37187: LIST
37188: LIST
37189: PUSH
37190: LD_INT 1
37192: NEG
37193: PUSH
37194: LD_INT 1
37196: NEG
37197: PUSH
37198: EMPTY
37199: LIST
37200: LIST
37201: PUSH
37202: EMPTY
37203: LIST
37204: LIST
37205: LIST
37206: LIST
37207: LIST
37208: LIST
37209: LIST
37210: ST_TO_ADDR
// end ; 1 :
37211: GO 43108
37213: LD_INT 1
37215: DOUBLE
37216: EQUAL
37217: IFTRUE 37221
37219: GO 39844
37221: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
37222: LD_ADDR_VAR 0 11
37226: PUSH
37227: LD_INT 1
37229: NEG
37230: PUSH
37231: LD_INT 3
37233: NEG
37234: PUSH
37235: EMPTY
37236: LIST
37237: LIST
37238: PUSH
37239: LD_INT 0
37241: PUSH
37242: LD_INT 3
37244: NEG
37245: PUSH
37246: EMPTY
37247: LIST
37248: LIST
37249: PUSH
37250: LD_INT 1
37252: PUSH
37253: LD_INT 2
37255: NEG
37256: PUSH
37257: EMPTY
37258: LIST
37259: LIST
37260: PUSH
37261: EMPTY
37262: LIST
37263: LIST
37264: LIST
37265: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
37266: LD_ADDR_VAR 0 12
37270: PUSH
37271: LD_INT 2
37273: PUSH
37274: LD_INT 1
37276: NEG
37277: PUSH
37278: EMPTY
37279: LIST
37280: LIST
37281: PUSH
37282: LD_INT 3
37284: PUSH
37285: LD_INT 0
37287: PUSH
37288: EMPTY
37289: LIST
37290: LIST
37291: PUSH
37292: LD_INT 3
37294: PUSH
37295: LD_INT 1
37297: PUSH
37298: EMPTY
37299: LIST
37300: LIST
37301: PUSH
37302: EMPTY
37303: LIST
37304: LIST
37305: LIST
37306: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
37307: LD_ADDR_VAR 0 13
37311: PUSH
37312: LD_INT 3
37314: PUSH
37315: LD_INT 2
37317: PUSH
37318: EMPTY
37319: LIST
37320: LIST
37321: PUSH
37322: LD_INT 3
37324: PUSH
37325: LD_INT 3
37327: PUSH
37328: EMPTY
37329: LIST
37330: LIST
37331: PUSH
37332: LD_INT 2
37334: PUSH
37335: LD_INT 3
37337: PUSH
37338: EMPTY
37339: LIST
37340: LIST
37341: PUSH
37342: EMPTY
37343: LIST
37344: LIST
37345: LIST
37346: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37347: LD_ADDR_VAR 0 14
37351: PUSH
37352: LD_INT 1
37354: PUSH
37355: LD_INT 3
37357: PUSH
37358: EMPTY
37359: LIST
37360: LIST
37361: PUSH
37362: LD_INT 0
37364: PUSH
37365: LD_INT 3
37367: PUSH
37368: EMPTY
37369: LIST
37370: LIST
37371: PUSH
37372: LD_INT 1
37374: NEG
37375: PUSH
37376: LD_INT 2
37378: PUSH
37379: EMPTY
37380: LIST
37381: LIST
37382: PUSH
37383: EMPTY
37384: LIST
37385: LIST
37386: LIST
37387: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37388: LD_ADDR_VAR 0 15
37392: PUSH
37393: LD_INT 2
37395: NEG
37396: PUSH
37397: LD_INT 1
37399: PUSH
37400: EMPTY
37401: LIST
37402: LIST
37403: PUSH
37404: LD_INT 3
37406: NEG
37407: PUSH
37408: LD_INT 0
37410: PUSH
37411: EMPTY
37412: LIST
37413: LIST
37414: PUSH
37415: LD_INT 3
37417: NEG
37418: PUSH
37419: LD_INT 1
37421: NEG
37422: PUSH
37423: EMPTY
37424: LIST
37425: LIST
37426: PUSH
37427: EMPTY
37428: LIST
37429: LIST
37430: LIST
37431: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37432: LD_ADDR_VAR 0 16
37436: PUSH
37437: LD_INT 2
37439: NEG
37440: PUSH
37441: LD_INT 3
37443: NEG
37444: PUSH
37445: EMPTY
37446: LIST
37447: LIST
37448: PUSH
37449: LD_INT 3
37451: NEG
37452: PUSH
37453: LD_INT 2
37455: NEG
37456: PUSH
37457: EMPTY
37458: LIST
37459: LIST
37460: PUSH
37461: LD_INT 3
37463: NEG
37464: PUSH
37465: LD_INT 3
37467: NEG
37468: PUSH
37469: EMPTY
37470: LIST
37471: LIST
37472: PUSH
37473: EMPTY
37474: LIST
37475: LIST
37476: LIST
37477: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
37478: LD_ADDR_VAR 0 17
37482: PUSH
37483: LD_INT 1
37485: NEG
37486: PUSH
37487: LD_INT 3
37489: NEG
37490: PUSH
37491: EMPTY
37492: LIST
37493: LIST
37494: PUSH
37495: LD_INT 0
37497: PUSH
37498: LD_INT 3
37500: NEG
37501: PUSH
37502: EMPTY
37503: LIST
37504: LIST
37505: PUSH
37506: LD_INT 1
37508: PUSH
37509: LD_INT 2
37511: NEG
37512: PUSH
37513: EMPTY
37514: LIST
37515: LIST
37516: PUSH
37517: EMPTY
37518: LIST
37519: LIST
37520: LIST
37521: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
37522: LD_ADDR_VAR 0 18
37526: PUSH
37527: LD_INT 2
37529: PUSH
37530: LD_INT 1
37532: NEG
37533: PUSH
37534: EMPTY
37535: LIST
37536: LIST
37537: PUSH
37538: LD_INT 3
37540: PUSH
37541: LD_INT 0
37543: PUSH
37544: EMPTY
37545: LIST
37546: LIST
37547: PUSH
37548: LD_INT 3
37550: PUSH
37551: LD_INT 1
37553: PUSH
37554: EMPTY
37555: LIST
37556: LIST
37557: PUSH
37558: EMPTY
37559: LIST
37560: LIST
37561: LIST
37562: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
37563: LD_ADDR_VAR 0 19
37567: PUSH
37568: LD_INT 3
37570: PUSH
37571: LD_INT 2
37573: PUSH
37574: EMPTY
37575: LIST
37576: LIST
37577: PUSH
37578: LD_INT 3
37580: PUSH
37581: LD_INT 3
37583: PUSH
37584: EMPTY
37585: LIST
37586: LIST
37587: PUSH
37588: LD_INT 2
37590: PUSH
37591: LD_INT 3
37593: PUSH
37594: EMPTY
37595: LIST
37596: LIST
37597: PUSH
37598: EMPTY
37599: LIST
37600: LIST
37601: LIST
37602: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37603: LD_ADDR_VAR 0 20
37607: PUSH
37608: LD_INT 1
37610: PUSH
37611: LD_INT 3
37613: PUSH
37614: EMPTY
37615: LIST
37616: LIST
37617: PUSH
37618: LD_INT 0
37620: PUSH
37621: LD_INT 3
37623: PUSH
37624: EMPTY
37625: LIST
37626: LIST
37627: PUSH
37628: LD_INT 1
37630: NEG
37631: PUSH
37632: LD_INT 2
37634: PUSH
37635: EMPTY
37636: LIST
37637: LIST
37638: PUSH
37639: EMPTY
37640: LIST
37641: LIST
37642: LIST
37643: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37644: LD_ADDR_VAR 0 21
37648: PUSH
37649: LD_INT 2
37651: NEG
37652: PUSH
37653: LD_INT 1
37655: PUSH
37656: EMPTY
37657: LIST
37658: LIST
37659: PUSH
37660: LD_INT 3
37662: NEG
37663: PUSH
37664: LD_INT 0
37666: PUSH
37667: EMPTY
37668: LIST
37669: LIST
37670: PUSH
37671: LD_INT 3
37673: NEG
37674: PUSH
37675: LD_INT 1
37677: NEG
37678: PUSH
37679: EMPTY
37680: LIST
37681: LIST
37682: PUSH
37683: EMPTY
37684: LIST
37685: LIST
37686: LIST
37687: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37688: LD_ADDR_VAR 0 22
37692: PUSH
37693: LD_INT 2
37695: NEG
37696: PUSH
37697: LD_INT 3
37699: NEG
37700: PUSH
37701: EMPTY
37702: LIST
37703: LIST
37704: PUSH
37705: LD_INT 3
37707: NEG
37708: PUSH
37709: LD_INT 2
37711: NEG
37712: PUSH
37713: EMPTY
37714: LIST
37715: LIST
37716: PUSH
37717: LD_INT 3
37719: NEG
37720: PUSH
37721: LD_INT 3
37723: NEG
37724: PUSH
37725: EMPTY
37726: LIST
37727: LIST
37728: PUSH
37729: EMPTY
37730: LIST
37731: LIST
37732: LIST
37733: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
37734: LD_ADDR_VAR 0 23
37738: PUSH
37739: LD_INT 0
37741: PUSH
37742: LD_INT 3
37744: NEG
37745: PUSH
37746: EMPTY
37747: LIST
37748: LIST
37749: PUSH
37750: LD_INT 1
37752: NEG
37753: PUSH
37754: LD_INT 4
37756: NEG
37757: PUSH
37758: EMPTY
37759: LIST
37760: LIST
37761: PUSH
37762: LD_INT 1
37764: PUSH
37765: LD_INT 3
37767: NEG
37768: PUSH
37769: EMPTY
37770: LIST
37771: LIST
37772: PUSH
37773: EMPTY
37774: LIST
37775: LIST
37776: LIST
37777: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
37778: LD_ADDR_VAR 0 24
37782: PUSH
37783: LD_INT 3
37785: PUSH
37786: LD_INT 0
37788: PUSH
37789: EMPTY
37790: LIST
37791: LIST
37792: PUSH
37793: LD_INT 3
37795: PUSH
37796: LD_INT 1
37798: NEG
37799: PUSH
37800: EMPTY
37801: LIST
37802: LIST
37803: PUSH
37804: LD_INT 4
37806: PUSH
37807: LD_INT 1
37809: PUSH
37810: EMPTY
37811: LIST
37812: LIST
37813: PUSH
37814: EMPTY
37815: LIST
37816: LIST
37817: LIST
37818: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
37819: LD_ADDR_VAR 0 25
37823: PUSH
37824: LD_INT 3
37826: PUSH
37827: LD_INT 3
37829: PUSH
37830: EMPTY
37831: LIST
37832: LIST
37833: PUSH
37834: LD_INT 4
37836: PUSH
37837: LD_INT 3
37839: PUSH
37840: EMPTY
37841: LIST
37842: LIST
37843: PUSH
37844: LD_INT 3
37846: PUSH
37847: LD_INT 4
37849: PUSH
37850: EMPTY
37851: LIST
37852: LIST
37853: PUSH
37854: EMPTY
37855: LIST
37856: LIST
37857: LIST
37858: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
37859: LD_ADDR_VAR 0 26
37863: PUSH
37864: LD_INT 0
37866: PUSH
37867: LD_INT 3
37869: PUSH
37870: EMPTY
37871: LIST
37872: LIST
37873: PUSH
37874: LD_INT 1
37876: PUSH
37877: LD_INT 4
37879: PUSH
37880: EMPTY
37881: LIST
37882: LIST
37883: PUSH
37884: LD_INT 1
37886: NEG
37887: PUSH
37888: LD_INT 3
37890: PUSH
37891: EMPTY
37892: LIST
37893: LIST
37894: PUSH
37895: EMPTY
37896: LIST
37897: LIST
37898: LIST
37899: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
37900: LD_ADDR_VAR 0 27
37904: PUSH
37905: LD_INT 3
37907: NEG
37908: PUSH
37909: LD_INT 0
37911: PUSH
37912: EMPTY
37913: LIST
37914: LIST
37915: PUSH
37916: LD_INT 3
37918: NEG
37919: PUSH
37920: LD_INT 1
37922: PUSH
37923: EMPTY
37924: LIST
37925: LIST
37926: PUSH
37927: LD_INT 4
37929: NEG
37930: PUSH
37931: LD_INT 1
37933: NEG
37934: PUSH
37935: EMPTY
37936: LIST
37937: LIST
37938: PUSH
37939: EMPTY
37940: LIST
37941: LIST
37942: LIST
37943: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
37944: LD_ADDR_VAR 0 28
37948: PUSH
37949: LD_INT 3
37951: NEG
37952: PUSH
37953: LD_INT 3
37955: NEG
37956: PUSH
37957: EMPTY
37958: LIST
37959: LIST
37960: PUSH
37961: LD_INT 3
37963: NEG
37964: PUSH
37965: LD_INT 4
37967: NEG
37968: PUSH
37969: EMPTY
37970: LIST
37971: LIST
37972: PUSH
37973: LD_INT 4
37975: NEG
37976: PUSH
37977: LD_INT 3
37979: NEG
37980: PUSH
37981: EMPTY
37982: LIST
37983: LIST
37984: PUSH
37985: EMPTY
37986: LIST
37987: LIST
37988: LIST
37989: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
37990: LD_ADDR_VAR 0 29
37994: PUSH
37995: LD_INT 1
37997: NEG
37998: PUSH
37999: LD_INT 3
38001: NEG
38002: PUSH
38003: EMPTY
38004: LIST
38005: LIST
38006: PUSH
38007: LD_INT 0
38009: PUSH
38010: LD_INT 3
38012: NEG
38013: PUSH
38014: EMPTY
38015: LIST
38016: LIST
38017: PUSH
38018: LD_INT 1
38020: PUSH
38021: LD_INT 2
38023: NEG
38024: PUSH
38025: EMPTY
38026: LIST
38027: LIST
38028: PUSH
38029: LD_INT 1
38031: NEG
38032: PUSH
38033: LD_INT 4
38035: NEG
38036: PUSH
38037: EMPTY
38038: LIST
38039: LIST
38040: PUSH
38041: LD_INT 0
38043: PUSH
38044: LD_INT 4
38046: NEG
38047: PUSH
38048: EMPTY
38049: LIST
38050: LIST
38051: PUSH
38052: LD_INT 1
38054: PUSH
38055: LD_INT 3
38057: NEG
38058: PUSH
38059: EMPTY
38060: LIST
38061: LIST
38062: PUSH
38063: LD_INT 1
38065: NEG
38066: PUSH
38067: LD_INT 5
38069: NEG
38070: PUSH
38071: EMPTY
38072: LIST
38073: LIST
38074: PUSH
38075: LD_INT 0
38077: PUSH
38078: LD_INT 5
38080: NEG
38081: PUSH
38082: EMPTY
38083: LIST
38084: LIST
38085: PUSH
38086: LD_INT 1
38088: PUSH
38089: LD_INT 4
38091: NEG
38092: PUSH
38093: EMPTY
38094: LIST
38095: LIST
38096: PUSH
38097: LD_INT 1
38099: NEG
38100: PUSH
38101: LD_INT 6
38103: NEG
38104: PUSH
38105: EMPTY
38106: LIST
38107: LIST
38108: PUSH
38109: LD_INT 0
38111: PUSH
38112: LD_INT 6
38114: NEG
38115: PUSH
38116: EMPTY
38117: LIST
38118: LIST
38119: PUSH
38120: LD_INT 1
38122: PUSH
38123: LD_INT 5
38125: NEG
38126: PUSH
38127: EMPTY
38128: LIST
38129: LIST
38130: PUSH
38131: EMPTY
38132: LIST
38133: LIST
38134: LIST
38135: LIST
38136: LIST
38137: LIST
38138: LIST
38139: LIST
38140: LIST
38141: LIST
38142: LIST
38143: LIST
38144: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
38145: LD_ADDR_VAR 0 30
38149: PUSH
38150: LD_INT 2
38152: PUSH
38153: LD_INT 1
38155: NEG
38156: PUSH
38157: EMPTY
38158: LIST
38159: LIST
38160: PUSH
38161: LD_INT 3
38163: PUSH
38164: LD_INT 0
38166: PUSH
38167: EMPTY
38168: LIST
38169: LIST
38170: PUSH
38171: LD_INT 3
38173: PUSH
38174: LD_INT 1
38176: PUSH
38177: EMPTY
38178: LIST
38179: LIST
38180: PUSH
38181: LD_INT 3
38183: PUSH
38184: LD_INT 1
38186: NEG
38187: PUSH
38188: EMPTY
38189: LIST
38190: LIST
38191: PUSH
38192: LD_INT 4
38194: PUSH
38195: LD_INT 0
38197: PUSH
38198: EMPTY
38199: LIST
38200: LIST
38201: PUSH
38202: LD_INT 4
38204: PUSH
38205: LD_INT 1
38207: PUSH
38208: EMPTY
38209: LIST
38210: LIST
38211: PUSH
38212: LD_INT 4
38214: PUSH
38215: LD_INT 1
38217: NEG
38218: PUSH
38219: EMPTY
38220: LIST
38221: LIST
38222: PUSH
38223: LD_INT 5
38225: PUSH
38226: LD_INT 0
38228: PUSH
38229: EMPTY
38230: LIST
38231: LIST
38232: PUSH
38233: LD_INT 5
38235: PUSH
38236: LD_INT 1
38238: PUSH
38239: EMPTY
38240: LIST
38241: LIST
38242: PUSH
38243: LD_INT 5
38245: PUSH
38246: LD_INT 1
38248: NEG
38249: PUSH
38250: EMPTY
38251: LIST
38252: LIST
38253: PUSH
38254: LD_INT 6
38256: PUSH
38257: LD_INT 0
38259: PUSH
38260: EMPTY
38261: LIST
38262: LIST
38263: PUSH
38264: LD_INT 6
38266: PUSH
38267: LD_INT 1
38269: PUSH
38270: EMPTY
38271: LIST
38272: LIST
38273: PUSH
38274: EMPTY
38275: LIST
38276: LIST
38277: LIST
38278: LIST
38279: LIST
38280: LIST
38281: LIST
38282: LIST
38283: LIST
38284: LIST
38285: LIST
38286: LIST
38287: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
38288: LD_ADDR_VAR 0 31
38292: PUSH
38293: LD_INT 3
38295: PUSH
38296: LD_INT 2
38298: PUSH
38299: EMPTY
38300: LIST
38301: LIST
38302: PUSH
38303: LD_INT 3
38305: PUSH
38306: LD_INT 3
38308: PUSH
38309: EMPTY
38310: LIST
38311: LIST
38312: PUSH
38313: LD_INT 2
38315: PUSH
38316: LD_INT 3
38318: PUSH
38319: EMPTY
38320: LIST
38321: LIST
38322: PUSH
38323: LD_INT 4
38325: PUSH
38326: LD_INT 3
38328: PUSH
38329: EMPTY
38330: LIST
38331: LIST
38332: PUSH
38333: LD_INT 4
38335: PUSH
38336: LD_INT 4
38338: PUSH
38339: EMPTY
38340: LIST
38341: LIST
38342: PUSH
38343: LD_INT 3
38345: PUSH
38346: LD_INT 4
38348: PUSH
38349: EMPTY
38350: LIST
38351: LIST
38352: PUSH
38353: LD_INT 5
38355: PUSH
38356: LD_INT 4
38358: PUSH
38359: EMPTY
38360: LIST
38361: LIST
38362: PUSH
38363: LD_INT 5
38365: PUSH
38366: LD_INT 5
38368: PUSH
38369: EMPTY
38370: LIST
38371: LIST
38372: PUSH
38373: LD_INT 4
38375: PUSH
38376: LD_INT 5
38378: PUSH
38379: EMPTY
38380: LIST
38381: LIST
38382: PUSH
38383: LD_INT 6
38385: PUSH
38386: LD_INT 5
38388: PUSH
38389: EMPTY
38390: LIST
38391: LIST
38392: PUSH
38393: LD_INT 6
38395: PUSH
38396: LD_INT 6
38398: PUSH
38399: EMPTY
38400: LIST
38401: LIST
38402: PUSH
38403: LD_INT 5
38405: PUSH
38406: LD_INT 6
38408: PUSH
38409: EMPTY
38410: LIST
38411: LIST
38412: PUSH
38413: EMPTY
38414: LIST
38415: LIST
38416: LIST
38417: LIST
38418: LIST
38419: LIST
38420: LIST
38421: LIST
38422: LIST
38423: LIST
38424: LIST
38425: LIST
38426: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
38427: LD_ADDR_VAR 0 32
38431: PUSH
38432: LD_INT 1
38434: PUSH
38435: LD_INT 3
38437: PUSH
38438: EMPTY
38439: LIST
38440: LIST
38441: PUSH
38442: LD_INT 0
38444: PUSH
38445: LD_INT 3
38447: PUSH
38448: EMPTY
38449: LIST
38450: LIST
38451: PUSH
38452: LD_INT 1
38454: NEG
38455: PUSH
38456: LD_INT 2
38458: PUSH
38459: EMPTY
38460: LIST
38461: LIST
38462: PUSH
38463: LD_INT 1
38465: PUSH
38466: LD_INT 4
38468: PUSH
38469: EMPTY
38470: LIST
38471: LIST
38472: PUSH
38473: LD_INT 0
38475: PUSH
38476: LD_INT 4
38478: PUSH
38479: EMPTY
38480: LIST
38481: LIST
38482: PUSH
38483: LD_INT 1
38485: NEG
38486: PUSH
38487: LD_INT 3
38489: PUSH
38490: EMPTY
38491: LIST
38492: LIST
38493: PUSH
38494: LD_INT 1
38496: PUSH
38497: LD_INT 5
38499: PUSH
38500: EMPTY
38501: LIST
38502: LIST
38503: PUSH
38504: LD_INT 0
38506: PUSH
38507: LD_INT 5
38509: PUSH
38510: EMPTY
38511: LIST
38512: LIST
38513: PUSH
38514: LD_INT 1
38516: NEG
38517: PUSH
38518: LD_INT 4
38520: PUSH
38521: EMPTY
38522: LIST
38523: LIST
38524: PUSH
38525: LD_INT 1
38527: PUSH
38528: LD_INT 6
38530: PUSH
38531: EMPTY
38532: LIST
38533: LIST
38534: PUSH
38535: LD_INT 0
38537: PUSH
38538: LD_INT 6
38540: PUSH
38541: EMPTY
38542: LIST
38543: LIST
38544: PUSH
38545: LD_INT 1
38547: NEG
38548: PUSH
38549: LD_INT 5
38551: PUSH
38552: EMPTY
38553: LIST
38554: LIST
38555: PUSH
38556: EMPTY
38557: LIST
38558: LIST
38559: LIST
38560: LIST
38561: LIST
38562: LIST
38563: LIST
38564: LIST
38565: LIST
38566: LIST
38567: LIST
38568: LIST
38569: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
38570: LD_ADDR_VAR 0 33
38574: PUSH
38575: LD_INT 2
38577: NEG
38578: PUSH
38579: LD_INT 1
38581: PUSH
38582: EMPTY
38583: LIST
38584: LIST
38585: PUSH
38586: LD_INT 3
38588: NEG
38589: PUSH
38590: LD_INT 0
38592: PUSH
38593: EMPTY
38594: LIST
38595: LIST
38596: PUSH
38597: LD_INT 3
38599: NEG
38600: PUSH
38601: LD_INT 1
38603: NEG
38604: PUSH
38605: EMPTY
38606: LIST
38607: LIST
38608: PUSH
38609: LD_INT 3
38611: NEG
38612: PUSH
38613: LD_INT 1
38615: PUSH
38616: EMPTY
38617: LIST
38618: LIST
38619: PUSH
38620: LD_INT 4
38622: NEG
38623: PUSH
38624: LD_INT 0
38626: PUSH
38627: EMPTY
38628: LIST
38629: LIST
38630: PUSH
38631: LD_INT 4
38633: NEG
38634: PUSH
38635: LD_INT 1
38637: NEG
38638: PUSH
38639: EMPTY
38640: LIST
38641: LIST
38642: PUSH
38643: LD_INT 4
38645: NEG
38646: PUSH
38647: LD_INT 1
38649: PUSH
38650: EMPTY
38651: LIST
38652: LIST
38653: PUSH
38654: LD_INT 5
38656: NEG
38657: PUSH
38658: LD_INT 0
38660: PUSH
38661: EMPTY
38662: LIST
38663: LIST
38664: PUSH
38665: LD_INT 5
38667: NEG
38668: PUSH
38669: LD_INT 1
38671: NEG
38672: PUSH
38673: EMPTY
38674: LIST
38675: LIST
38676: PUSH
38677: LD_INT 5
38679: NEG
38680: PUSH
38681: LD_INT 1
38683: PUSH
38684: EMPTY
38685: LIST
38686: LIST
38687: PUSH
38688: LD_INT 6
38690: NEG
38691: PUSH
38692: LD_INT 0
38694: PUSH
38695: EMPTY
38696: LIST
38697: LIST
38698: PUSH
38699: LD_INT 6
38701: NEG
38702: PUSH
38703: LD_INT 1
38705: NEG
38706: PUSH
38707: EMPTY
38708: LIST
38709: LIST
38710: PUSH
38711: EMPTY
38712: LIST
38713: LIST
38714: LIST
38715: LIST
38716: LIST
38717: LIST
38718: LIST
38719: LIST
38720: LIST
38721: LIST
38722: LIST
38723: LIST
38724: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
38725: LD_ADDR_VAR 0 34
38729: PUSH
38730: LD_INT 2
38732: NEG
38733: PUSH
38734: LD_INT 3
38736: NEG
38737: PUSH
38738: EMPTY
38739: LIST
38740: LIST
38741: PUSH
38742: LD_INT 3
38744: NEG
38745: PUSH
38746: LD_INT 2
38748: NEG
38749: PUSH
38750: EMPTY
38751: LIST
38752: LIST
38753: PUSH
38754: LD_INT 3
38756: NEG
38757: PUSH
38758: LD_INT 3
38760: NEG
38761: PUSH
38762: EMPTY
38763: LIST
38764: LIST
38765: PUSH
38766: LD_INT 3
38768: NEG
38769: PUSH
38770: LD_INT 4
38772: NEG
38773: PUSH
38774: EMPTY
38775: LIST
38776: LIST
38777: PUSH
38778: LD_INT 4
38780: NEG
38781: PUSH
38782: LD_INT 3
38784: NEG
38785: PUSH
38786: EMPTY
38787: LIST
38788: LIST
38789: PUSH
38790: LD_INT 4
38792: NEG
38793: PUSH
38794: LD_INT 4
38796: NEG
38797: PUSH
38798: EMPTY
38799: LIST
38800: LIST
38801: PUSH
38802: LD_INT 4
38804: NEG
38805: PUSH
38806: LD_INT 5
38808: NEG
38809: PUSH
38810: EMPTY
38811: LIST
38812: LIST
38813: PUSH
38814: LD_INT 5
38816: NEG
38817: PUSH
38818: LD_INT 4
38820: NEG
38821: PUSH
38822: EMPTY
38823: LIST
38824: LIST
38825: PUSH
38826: LD_INT 5
38828: NEG
38829: PUSH
38830: LD_INT 5
38832: NEG
38833: PUSH
38834: EMPTY
38835: LIST
38836: LIST
38837: PUSH
38838: LD_INT 5
38840: NEG
38841: PUSH
38842: LD_INT 6
38844: NEG
38845: PUSH
38846: EMPTY
38847: LIST
38848: LIST
38849: PUSH
38850: LD_INT 6
38852: NEG
38853: PUSH
38854: LD_INT 5
38856: NEG
38857: PUSH
38858: EMPTY
38859: LIST
38860: LIST
38861: PUSH
38862: LD_INT 6
38864: NEG
38865: PUSH
38866: LD_INT 6
38868: NEG
38869: PUSH
38870: EMPTY
38871: LIST
38872: LIST
38873: PUSH
38874: EMPTY
38875: LIST
38876: LIST
38877: LIST
38878: LIST
38879: LIST
38880: LIST
38881: LIST
38882: LIST
38883: LIST
38884: LIST
38885: LIST
38886: LIST
38887: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
38888: LD_ADDR_VAR 0 41
38892: PUSH
38893: LD_INT 0
38895: PUSH
38896: LD_INT 2
38898: NEG
38899: PUSH
38900: EMPTY
38901: LIST
38902: LIST
38903: PUSH
38904: LD_INT 1
38906: NEG
38907: PUSH
38908: LD_INT 3
38910: NEG
38911: PUSH
38912: EMPTY
38913: LIST
38914: LIST
38915: PUSH
38916: LD_INT 1
38918: PUSH
38919: LD_INT 2
38921: NEG
38922: PUSH
38923: EMPTY
38924: LIST
38925: LIST
38926: PUSH
38927: EMPTY
38928: LIST
38929: LIST
38930: LIST
38931: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
38932: LD_ADDR_VAR 0 42
38936: PUSH
38937: LD_INT 2
38939: PUSH
38940: LD_INT 0
38942: PUSH
38943: EMPTY
38944: LIST
38945: LIST
38946: PUSH
38947: LD_INT 2
38949: PUSH
38950: LD_INT 1
38952: NEG
38953: PUSH
38954: EMPTY
38955: LIST
38956: LIST
38957: PUSH
38958: LD_INT 3
38960: PUSH
38961: LD_INT 1
38963: PUSH
38964: EMPTY
38965: LIST
38966: LIST
38967: PUSH
38968: EMPTY
38969: LIST
38970: LIST
38971: LIST
38972: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
38973: LD_ADDR_VAR 0 43
38977: PUSH
38978: LD_INT 2
38980: PUSH
38981: LD_INT 2
38983: PUSH
38984: EMPTY
38985: LIST
38986: LIST
38987: PUSH
38988: LD_INT 3
38990: PUSH
38991: LD_INT 2
38993: PUSH
38994: EMPTY
38995: LIST
38996: LIST
38997: PUSH
38998: LD_INT 2
39000: PUSH
39001: LD_INT 3
39003: PUSH
39004: EMPTY
39005: LIST
39006: LIST
39007: PUSH
39008: EMPTY
39009: LIST
39010: LIST
39011: LIST
39012: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
39013: LD_ADDR_VAR 0 44
39017: PUSH
39018: LD_INT 0
39020: PUSH
39021: LD_INT 2
39023: PUSH
39024: EMPTY
39025: LIST
39026: LIST
39027: PUSH
39028: LD_INT 1
39030: PUSH
39031: LD_INT 3
39033: PUSH
39034: EMPTY
39035: LIST
39036: LIST
39037: PUSH
39038: LD_INT 1
39040: NEG
39041: PUSH
39042: LD_INT 2
39044: PUSH
39045: EMPTY
39046: LIST
39047: LIST
39048: PUSH
39049: EMPTY
39050: LIST
39051: LIST
39052: LIST
39053: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
39054: LD_ADDR_VAR 0 45
39058: PUSH
39059: LD_INT 2
39061: NEG
39062: PUSH
39063: LD_INT 0
39065: PUSH
39066: EMPTY
39067: LIST
39068: LIST
39069: PUSH
39070: LD_INT 2
39072: NEG
39073: PUSH
39074: LD_INT 1
39076: PUSH
39077: EMPTY
39078: LIST
39079: LIST
39080: PUSH
39081: LD_INT 3
39083: NEG
39084: PUSH
39085: LD_INT 1
39087: NEG
39088: PUSH
39089: EMPTY
39090: LIST
39091: LIST
39092: PUSH
39093: EMPTY
39094: LIST
39095: LIST
39096: LIST
39097: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
39098: LD_ADDR_VAR 0 46
39102: PUSH
39103: LD_INT 2
39105: NEG
39106: PUSH
39107: LD_INT 2
39109: NEG
39110: PUSH
39111: EMPTY
39112: LIST
39113: LIST
39114: PUSH
39115: LD_INT 2
39117: NEG
39118: PUSH
39119: LD_INT 3
39121: NEG
39122: PUSH
39123: EMPTY
39124: LIST
39125: LIST
39126: PUSH
39127: LD_INT 3
39129: NEG
39130: PUSH
39131: LD_INT 2
39133: NEG
39134: PUSH
39135: EMPTY
39136: LIST
39137: LIST
39138: PUSH
39139: EMPTY
39140: LIST
39141: LIST
39142: LIST
39143: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
39144: LD_ADDR_VAR 0 47
39148: PUSH
39149: LD_INT 2
39151: NEG
39152: PUSH
39153: LD_INT 3
39155: NEG
39156: PUSH
39157: EMPTY
39158: LIST
39159: LIST
39160: PUSH
39161: LD_INT 1
39163: NEG
39164: PUSH
39165: LD_INT 3
39167: NEG
39168: PUSH
39169: EMPTY
39170: LIST
39171: LIST
39172: PUSH
39173: EMPTY
39174: LIST
39175: LIST
39176: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
39177: LD_ADDR_VAR 0 48
39181: PUSH
39182: LD_INT 1
39184: PUSH
39185: LD_INT 2
39187: NEG
39188: PUSH
39189: EMPTY
39190: LIST
39191: LIST
39192: PUSH
39193: LD_INT 2
39195: PUSH
39196: LD_INT 1
39198: NEG
39199: PUSH
39200: EMPTY
39201: LIST
39202: LIST
39203: PUSH
39204: EMPTY
39205: LIST
39206: LIST
39207: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
39208: LD_ADDR_VAR 0 49
39212: PUSH
39213: LD_INT 3
39215: PUSH
39216: LD_INT 1
39218: PUSH
39219: EMPTY
39220: LIST
39221: LIST
39222: PUSH
39223: LD_INT 3
39225: PUSH
39226: LD_INT 2
39228: PUSH
39229: EMPTY
39230: LIST
39231: LIST
39232: PUSH
39233: EMPTY
39234: LIST
39235: LIST
39236: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
39237: LD_ADDR_VAR 0 50
39241: PUSH
39242: LD_INT 2
39244: PUSH
39245: LD_INT 3
39247: PUSH
39248: EMPTY
39249: LIST
39250: LIST
39251: PUSH
39252: LD_INT 1
39254: PUSH
39255: LD_INT 3
39257: PUSH
39258: EMPTY
39259: LIST
39260: LIST
39261: PUSH
39262: EMPTY
39263: LIST
39264: LIST
39265: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
39266: LD_ADDR_VAR 0 51
39270: PUSH
39271: LD_INT 1
39273: NEG
39274: PUSH
39275: LD_INT 2
39277: PUSH
39278: EMPTY
39279: LIST
39280: LIST
39281: PUSH
39282: LD_INT 2
39284: NEG
39285: PUSH
39286: LD_INT 1
39288: PUSH
39289: EMPTY
39290: LIST
39291: LIST
39292: PUSH
39293: EMPTY
39294: LIST
39295: LIST
39296: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
39297: LD_ADDR_VAR 0 52
39301: PUSH
39302: LD_INT 3
39304: NEG
39305: PUSH
39306: LD_INT 1
39308: NEG
39309: PUSH
39310: EMPTY
39311: LIST
39312: LIST
39313: PUSH
39314: LD_INT 3
39316: NEG
39317: PUSH
39318: LD_INT 2
39320: NEG
39321: PUSH
39322: EMPTY
39323: LIST
39324: LIST
39325: PUSH
39326: EMPTY
39327: LIST
39328: LIST
39329: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39330: LD_ADDR_VAR 0 53
39334: PUSH
39335: LD_INT 1
39337: NEG
39338: PUSH
39339: LD_INT 3
39341: NEG
39342: PUSH
39343: EMPTY
39344: LIST
39345: LIST
39346: PUSH
39347: LD_INT 0
39349: PUSH
39350: LD_INT 3
39352: NEG
39353: PUSH
39354: EMPTY
39355: LIST
39356: LIST
39357: PUSH
39358: LD_INT 1
39360: PUSH
39361: LD_INT 2
39363: NEG
39364: PUSH
39365: EMPTY
39366: LIST
39367: LIST
39368: PUSH
39369: EMPTY
39370: LIST
39371: LIST
39372: LIST
39373: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39374: LD_ADDR_VAR 0 54
39378: PUSH
39379: LD_INT 2
39381: PUSH
39382: LD_INT 1
39384: NEG
39385: PUSH
39386: EMPTY
39387: LIST
39388: LIST
39389: PUSH
39390: LD_INT 3
39392: PUSH
39393: LD_INT 0
39395: PUSH
39396: EMPTY
39397: LIST
39398: LIST
39399: PUSH
39400: LD_INT 3
39402: PUSH
39403: LD_INT 1
39405: PUSH
39406: EMPTY
39407: LIST
39408: LIST
39409: PUSH
39410: EMPTY
39411: LIST
39412: LIST
39413: LIST
39414: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39415: LD_ADDR_VAR 0 55
39419: PUSH
39420: LD_INT 3
39422: PUSH
39423: LD_INT 2
39425: PUSH
39426: EMPTY
39427: LIST
39428: LIST
39429: PUSH
39430: LD_INT 3
39432: PUSH
39433: LD_INT 3
39435: PUSH
39436: EMPTY
39437: LIST
39438: LIST
39439: PUSH
39440: LD_INT 2
39442: PUSH
39443: LD_INT 3
39445: PUSH
39446: EMPTY
39447: LIST
39448: LIST
39449: PUSH
39450: EMPTY
39451: LIST
39452: LIST
39453: LIST
39454: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39455: LD_ADDR_VAR 0 56
39459: PUSH
39460: LD_INT 1
39462: PUSH
39463: LD_INT 3
39465: PUSH
39466: EMPTY
39467: LIST
39468: LIST
39469: PUSH
39470: LD_INT 0
39472: PUSH
39473: LD_INT 3
39475: PUSH
39476: EMPTY
39477: LIST
39478: LIST
39479: PUSH
39480: LD_INT 1
39482: NEG
39483: PUSH
39484: LD_INT 2
39486: PUSH
39487: EMPTY
39488: LIST
39489: LIST
39490: PUSH
39491: EMPTY
39492: LIST
39493: LIST
39494: LIST
39495: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39496: LD_ADDR_VAR 0 57
39500: PUSH
39501: LD_INT 2
39503: NEG
39504: PUSH
39505: LD_INT 1
39507: PUSH
39508: EMPTY
39509: LIST
39510: LIST
39511: PUSH
39512: LD_INT 3
39514: NEG
39515: PUSH
39516: LD_INT 0
39518: PUSH
39519: EMPTY
39520: LIST
39521: LIST
39522: PUSH
39523: LD_INT 3
39525: NEG
39526: PUSH
39527: LD_INT 1
39529: NEG
39530: PUSH
39531: EMPTY
39532: LIST
39533: LIST
39534: PUSH
39535: EMPTY
39536: LIST
39537: LIST
39538: LIST
39539: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39540: LD_ADDR_VAR 0 58
39544: PUSH
39545: LD_INT 2
39547: NEG
39548: PUSH
39549: LD_INT 3
39551: NEG
39552: PUSH
39553: EMPTY
39554: LIST
39555: LIST
39556: PUSH
39557: LD_INT 3
39559: NEG
39560: PUSH
39561: LD_INT 2
39563: NEG
39564: PUSH
39565: EMPTY
39566: LIST
39567: LIST
39568: PUSH
39569: LD_INT 3
39571: NEG
39572: PUSH
39573: LD_INT 3
39575: NEG
39576: PUSH
39577: EMPTY
39578: LIST
39579: LIST
39580: PUSH
39581: EMPTY
39582: LIST
39583: LIST
39584: LIST
39585: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
39586: LD_ADDR_VAR 0 59
39590: PUSH
39591: LD_INT 1
39593: NEG
39594: PUSH
39595: LD_INT 2
39597: NEG
39598: PUSH
39599: EMPTY
39600: LIST
39601: LIST
39602: PUSH
39603: LD_INT 0
39605: PUSH
39606: LD_INT 2
39608: NEG
39609: PUSH
39610: EMPTY
39611: LIST
39612: LIST
39613: PUSH
39614: LD_INT 1
39616: PUSH
39617: LD_INT 1
39619: NEG
39620: PUSH
39621: EMPTY
39622: LIST
39623: LIST
39624: PUSH
39625: EMPTY
39626: LIST
39627: LIST
39628: LIST
39629: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
39630: LD_ADDR_VAR 0 60
39634: PUSH
39635: LD_INT 1
39637: PUSH
39638: LD_INT 1
39640: NEG
39641: PUSH
39642: EMPTY
39643: LIST
39644: LIST
39645: PUSH
39646: LD_INT 2
39648: PUSH
39649: LD_INT 0
39651: PUSH
39652: EMPTY
39653: LIST
39654: LIST
39655: PUSH
39656: LD_INT 2
39658: PUSH
39659: LD_INT 1
39661: PUSH
39662: EMPTY
39663: LIST
39664: LIST
39665: PUSH
39666: EMPTY
39667: LIST
39668: LIST
39669: LIST
39670: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
39671: LD_ADDR_VAR 0 61
39675: PUSH
39676: LD_INT 2
39678: PUSH
39679: LD_INT 1
39681: PUSH
39682: EMPTY
39683: LIST
39684: LIST
39685: PUSH
39686: LD_INT 2
39688: PUSH
39689: LD_INT 2
39691: PUSH
39692: EMPTY
39693: LIST
39694: LIST
39695: PUSH
39696: LD_INT 1
39698: PUSH
39699: LD_INT 2
39701: PUSH
39702: EMPTY
39703: LIST
39704: LIST
39705: PUSH
39706: EMPTY
39707: LIST
39708: LIST
39709: LIST
39710: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
39711: LD_ADDR_VAR 0 62
39715: PUSH
39716: LD_INT 1
39718: PUSH
39719: LD_INT 2
39721: PUSH
39722: EMPTY
39723: LIST
39724: LIST
39725: PUSH
39726: LD_INT 0
39728: PUSH
39729: LD_INT 2
39731: PUSH
39732: EMPTY
39733: LIST
39734: LIST
39735: PUSH
39736: LD_INT 1
39738: NEG
39739: PUSH
39740: LD_INT 1
39742: PUSH
39743: EMPTY
39744: LIST
39745: LIST
39746: PUSH
39747: EMPTY
39748: LIST
39749: LIST
39750: LIST
39751: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
39752: LD_ADDR_VAR 0 63
39756: PUSH
39757: LD_INT 1
39759: NEG
39760: PUSH
39761: LD_INT 1
39763: PUSH
39764: EMPTY
39765: LIST
39766: LIST
39767: PUSH
39768: LD_INT 2
39770: NEG
39771: PUSH
39772: LD_INT 0
39774: PUSH
39775: EMPTY
39776: LIST
39777: LIST
39778: PUSH
39779: LD_INT 2
39781: NEG
39782: PUSH
39783: LD_INT 1
39785: NEG
39786: PUSH
39787: EMPTY
39788: LIST
39789: LIST
39790: PUSH
39791: EMPTY
39792: LIST
39793: LIST
39794: LIST
39795: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39796: LD_ADDR_VAR 0 64
39800: PUSH
39801: LD_INT 1
39803: NEG
39804: PUSH
39805: LD_INT 2
39807: NEG
39808: PUSH
39809: EMPTY
39810: LIST
39811: LIST
39812: PUSH
39813: LD_INT 2
39815: NEG
39816: PUSH
39817: LD_INT 1
39819: NEG
39820: PUSH
39821: EMPTY
39822: LIST
39823: LIST
39824: PUSH
39825: LD_INT 2
39827: NEG
39828: PUSH
39829: LD_INT 2
39831: NEG
39832: PUSH
39833: EMPTY
39834: LIST
39835: LIST
39836: PUSH
39837: EMPTY
39838: LIST
39839: LIST
39840: LIST
39841: ST_TO_ADDR
// end ; 2 :
39842: GO 43108
39844: LD_INT 2
39846: DOUBLE
39847: EQUAL
39848: IFTRUE 39852
39850: GO 43107
39852: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
39853: LD_ADDR_VAR 0 29
39857: PUSH
39858: LD_INT 4
39860: PUSH
39861: LD_INT 0
39863: PUSH
39864: EMPTY
39865: LIST
39866: LIST
39867: PUSH
39868: LD_INT 4
39870: PUSH
39871: LD_INT 1
39873: NEG
39874: PUSH
39875: EMPTY
39876: LIST
39877: LIST
39878: PUSH
39879: LD_INT 5
39881: PUSH
39882: LD_INT 0
39884: PUSH
39885: EMPTY
39886: LIST
39887: LIST
39888: PUSH
39889: LD_INT 5
39891: PUSH
39892: LD_INT 1
39894: PUSH
39895: EMPTY
39896: LIST
39897: LIST
39898: PUSH
39899: LD_INT 4
39901: PUSH
39902: LD_INT 1
39904: PUSH
39905: EMPTY
39906: LIST
39907: LIST
39908: PUSH
39909: LD_INT 3
39911: PUSH
39912: LD_INT 0
39914: PUSH
39915: EMPTY
39916: LIST
39917: LIST
39918: PUSH
39919: LD_INT 3
39921: PUSH
39922: LD_INT 1
39924: NEG
39925: PUSH
39926: EMPTY
39927: LIST
39928: LIST
39929: PUSH
39930: LD_INT 3
39932: PUSH
39933: LD_INT 2
39935: NEG
39936: PUSH
39937: EMPTY
39938: LIST
39939: LIST
39940: PUSH
39941: LD_INT 5
39943: PUSH
39944: LD_INT 2
39946: PUSH
39947: EMPTY
39948: LIST
39949: LIST
39950: PUSH
39951: LD_INT 3
39953: PUSH
39954: LD_INT 3
39956: PUSH
39957: EMPTY
39958: LIST
39959: LIST
39960: PUSH
39961: LD_INT 3
39963: PUSH
39964: LD_INT 2
39966: PUSH
39967: EMPTY
39968: LIST
39969: LIST
39970: PUSH
39971: LD_INT 4
39973: PUSH
39974: LD_INT 3
39976: PUSH
39977: EMPTY
39978: LIST
39979: LIST
39980: PUSH
39981: LD_INT 4
39983: PUSH
39984: LD_INT 4
39986: PUSH
39987: EMPTY
39988: LIST
39989: LIST
39990: PUSH
39991: LD_INT 3
39993: PUSH
39994: LD_INT 4
39996: PUSH
39997: EMPTY
39998: LIST
39999: LIST
40000: PUSH
40001: LD_INT 2
40003: PUSH
40004: LD_INT 3
40006: PUSH
40007: EMPTY
40008: LIST
40009: LIST
40010: PUSH
40011: LD_INT 2
40013: PUSH
40014: LD_INT 2
40016: PUSH
40017: EMPTY
40018: LIST
40019: LIST
40020: PUSH
40021: LD_INT 4
40023: PUSH
40024: LD_INT 2
40026: PUSH
40027: EMPTY
40028: LIST
40029: LIST
40030: PUSH
40031: LD_INT 2
40033: PUSH
40034: LD_INT 4
40036: PUSH
40037: EMPTY
40038: LIST
40039: LIST
40040: PUSH
40041: LD_INT 0
40043: PUSH
40044: LD_INT 4
40046: PUSH
40047: EMPTY
40048: LIST
40049: LIST
40050: PUSH
40051: LD_INT 0
40053: PUSH
40054: LD_INT 3
40056: PUSH
40057: EMPTY
40058: LIST
40059: LIST
40060: PUSH
40061: LD_INT 1
40063: PUSH
40064: LD_INT 4
40066: PUSH
40067: EMPTY
40068: LIST
40069: LIST
40070: PUSH
40071: LD_INT 1
40073: PUSH
40074: LD_INT 5
40076: PUSH
40077: EMPTY
40078: LIST
40079: LIST
40080: PUSH
40081: LD_INT 0
40083: PUSH
40084: LD_INT 5
40086: PUSH
40087: EMPTY
40088: LIST
40089: LIST
40090: PUSH
40091: LD_INT 1
40093: NEG
40094: PUSH
40095: LD_INT 4
40097: PUSH
40098: EMPTY
40099: LIST
40100: LIST
40101: PUSH
40102: LD_INT 1
40104: NEG
40105: PUSH
40106: LD_INT 3
40108: PUSH
40109: EMPTY
40110: LIST
40111: LIST
40112: PUSH
40113: LD_INT 2
40115: PUSH
40116: LD_INT 5
40118: PUSH
40119: EMPTY
40120: LIST
40121: LIST
40122: PUSH
40123: LD_INT 2
40125: NEG
40126: PUSH
40127: LD_INT 3
40129: PUSH
40130: EMPTY
40131: LIST
40132: LIST
40133: PUSH
40134: LD_INT 3
40136: NEG
40137: PUSH
40138: LD_INT 0
40140: PUSH
40141: EMPTY
40142: LIST
40143: LIST
40144: PUSH
40145: LD_INT 3
40147: NEG
40148: PUSH
40149: LD_INT 1
40151: NEG
40152: PUSH
40153: EMPTY
40154: LIST
40155: LIST
40156: PUSH
40157: LD_INT 2
40159: NEG
40160: PUSH
40161: LD_INT 0
40163: PUSH
40164: EMPTY
40165: LIST
40166: LIST
40167: PUSH
40168: LD_INT 2
40170: NEG
40171: PUSH
40172: LD_INT 1
40174: PUSH
40175: EMPTY
40176: LIST
40177: LIST
40178: PUSH
40179: LD_INT 3
40181: NEG
40182: PUSH
40183: LD_INT 1
40185: PUSH
40186: EMPTY
40187: LIST
40188: LIST
40189: PUSH
40190: LD_INT 4
40192: NEG
40193: PUSH
40194: LD_INT 0
40196: PUSH
40197: EMPTY
40198: LIST
40199: LIST
40200: PUSH
40201: LD_INT 4
40203: NEG
40204: PUSH
40205: LD_INT 1
40207: NEG
40208: PUSH
40209: EMPTY
40210: LIST
40211: LIST
40212: PUSH
40213: LD_INT 4
40215: NEG
40216: PUSH
40217: LD_INT 2
40219: NEG
40220: PUSH
40221: EMPTY
40222: LIST
40223: LIST
40224: PUSH
40225: LD_INT 2
40227: NEG
40228: PUSH
40229: LD_INT 2
40231: PUSH
40232: EMPTY
40233: LIST
40234: LIST
40235: PUSH
40236: LD_INT 4
40238: NEG
40239: PUSH
40240: LD_INT 4
40242: NEG
40243: PUSH
40244: EMPTY
40245: LIST
40246: LIST
40247: PUSH
40248: LD_INT 4
40250: NEG
40251: PUSH
40252: LD_INT 5
40254: NEG
40255: PUSH
40256: EMPTY
40257: LIST
40258: LIST
40259: PUSH
40260: LD_INT 3
40262: NEG
40263: PUSH
40264: LD_INT 4
40266: NEG
40267: PUSH
40268: EMPTY
40269: LIST
40270: LIST
40271: PUSH
40272: LD_INT 3
40274: NEG
40275: PUSH
40276: LD_INT 3
40278: NEG
40279: PUSH
40280: EMPTY
40281: LIST
40282: LIST
40283: PUSH
40284: LD_INT 4
40286: NEG
40287: PUSH
40288: LD_INT 3
40290: NEG
40291: PUSH
40292: EMPTY
40293: LIST
40294: LIST
40295: PUSH
40296: LD_INT 5
40298: NEG
40299: PUSH
40300: LD_INT 4
40302: NEG
40303: PUSH
40304: EMPTY
40305: LIST
40306: LIST
40307: PUSH
40308: LD_INT 5
40310: NEG
40311: PUSH
40312: LD_INT 5
40314: NEG
40315: PUSH
40316: EMPTY
40317: LIST
40318: LIST
40319: PUSH
40320: LD_INT 3
40322: NEG
40323: PUSH
40324: LD_INT 5
40326: NEG
40327: PUSH
40328: EMPTY
40329: LIST
40330: LIST
40331: PUSH
40332: LD_INT 5
40334: NEG
40335: PUSH
40336: LD_INT 3
40338: NEG
40339: PUSH
40340: EMPTY
40341: LIST
40342: LIST
40343: PUSH
40344: EMPTY
40345: LIST
40346: LIST
40347: LIST
40348: LIST
40349: LIST
40350: LIST
40351: LIST
40352: LIST
40353: LIST
40354: LIST
40355: LIST
40356: LIST
40357: LIST
40358: LIST
40359: LIST
40360: LIST
40361: LIST
40362: LIST
40363: LIST
40364: LIST
40365: LIST
40366: LIST
40367: LIST
40368: LIST
40369: LIST
40370: LIST
40371: LIST
40372: LIST
40373: LIST
40374: LIST
40375: LIST
40376: LIST
40377: LIST
40378: LIST
40379: LIST
40380: LIST
40381: LIST
40382: LIST
40383: LIST
40384: LIST
40385: LIST
40386: LIST
40387: LIST
40388: LIST
40389: LIST
40390: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
40391: LD_ADDR_VAR 0 30
40395: PUSH
40396: LD_INT 4
40398: PUSH
40399: LD_INT 4
40401: PUSH
40402: EMPTY
40403: LIST
40404: LIST
40405: PUSH
40406: LD_INT 4
40408: PUSH
40409: LD_INT 3
40411: PUSH
40412: EMPTY
40413: LIST
40414: LIST
40415: PUSH
40416: LD_INT 5
40418: PUSH
40419: LD_INT 4
40421: PUSH
40422: EMPTY
40423: LIST
40424: LIST
40425: PUSH
40426: LD_INT 5
40428: PUSH
40429: LD_INT 5
40431: PUSH
40432: EMPTY
40433: LIST
40434: LIST
40435: PUSH
40436: LD_INT 4
40438: PUSH
40439: LD_INT 5
40441: PUSH
40442: EMPTY
40443: LIST
40444: LIST
40445: PUSH
40446: LD_INT 3
40448: PUSH
40449: LD_INT 4
40451: PUSH
40452: EMPTY
40453: LIST
40454: LIST
40455: PUSH
40456: LD_INT 3
40458: PUSH
40459: LD_INT 3
40461: PUSH
40462: EMPTY
40463: LIST
40464: LIST
40465: PUSH
40466: LD_INT 5
40468: PUSH
40469: LD_INT 3
40471: PUSH
40472: EMPTY
40473: LIST
40474: LIST
40475: PUSH
40476: LD_INT 3
40478: PUSH
40479: LD_INT 5
40481: PUSH
40482: EMPTY
40483: LIST
40484: LIST
40485: PUSH
40486: LD_INT 0
40488: PUSH
40489: LD_INT 3
40491: PUSH
40492: EMPTY
40493: LIST
40494: LIST
40495: PUSH
40496: LD_INT 0
40498: PUSH
40499: LD_INT 2
40501: PUSH
40502: EMPTY
40503: LIST
40504: LIST
40505: PUSH
40506: LD_INT 1
40508: PUSH
40509: LD_INT 3
40511: PUSH
40512: EMPTY
40513: LIST
40514: LIST
40515: PUSH
40516: LD_INT 1
40518: PUSH
40519: LD_INT 4
40521: PUSH
40522: EMPTY
40523: LIST
40524: LIST
40525: PUSH
40526: LD_INT 0
40528: PUSH
40529: LD_INT 4
40531: PUSH
40532: EMPTY
40533: LIST
40534: LIST
40535: PUSH
40536: LD_INT 1
40538: NEG
40539: PUSH
40540: LD_INT 3
40542: PUSH
40543: EMPTY
40544: LIST
40545: LIST
40546: PUSH
40547: LD_INT 1
40549: NEG
40550: PUSH
40551: LD_INT 2
40553: PUSH
40554: EMPTY
40555: LIST
40556: LIST
40557: PUSH
40558: LD_INT 2
40560: PUSH
40561: LD_INT 4
40563: PUSH
40564: EMPTY
40565: LIST
40566: LIST
40567: PUSH
40568: LD_INT 2
40570: NEG
40571: PUSH
40572: LD_INT 2
40574: PUSH
40575: EMPTY
40576: LIST
40577: LIST
40578: PUSH
40579: LD_INT 4
40581: NEG
40582: PUSH
40583: LD_INT 0
40585: PUSH
40586: EMPTY
40587: LIST
40588: LIST
40589: PUSH
40590: LD_INT 4
40592: NEG
40593: PUSH
40594: LD_INT 1
40596: NEG
40597: PUSH
40598: EMPTY
40599: LIST
40600: LIST
40601: PUSH
40602: LD_INT 3
40604: NEG
40605: PUSH
40606: LD_INT 0
40608: PUSH
40609: EMPTY
40610: LIST
40611: LIST
40612: PUSH
40613: LD_INT 3
40615: NEG
40616: PUSH
40617: LD_INT 1
40619: PUSH
40620: EMPTY
40621: LIST
40622: LIST
40623: PUSH
40624: LD_INT 4
40626: NEG
40627: PUSH
40628: LD_INT 1
40630: PUSH
40631: EMPTY
40632: LIST
40633: LIST
40634: PUSH
40635: LD_INT 5
40637: NEG
40638: PUSH
40639: LD_INT 0
40641: PUSH
40642: EMPTY
40643: LIST
40644: LIST
40645: PUSH
40646: LD_INT 5
40648: NEG
40649: PUSH
40650: LD_INT 1
40652: NEG
40653: PUSH
40654: EMPTY
40655: LIST
40656: LIST
40657: PUSH
40658: LD_INT 5
40660: NEG
40661: PUSH
40662: LD_INT 2
40664: NEG
40665: PUSH
40666: EMPTY
40667: LIST
40668: LIST
40669: PUSH
40670: LD_INT 3
40672: NEG
40673: PUSH
40674: LD_INT 2
40676: PUSH
40677: EMPTY
40678: LIST
40679: LIST
40680: PUSH
40681: LD_INT 3
40683: NEG
40684: PUSH
40685: LD_INT 3
40687: NEG
40688: PUSH
40689: EMPTY
40690: LIST
40691: LIST
40692: PUSH
40693: LD_INT 3
40695: NEG
40696: PUSH
40697: LD_INT 4
40699: NEG
40700: PUSH
40701: EMPTY
40702: LIST
40703: LIST
40704: PUSH
40705: LD_INT 2
40707: NEG
40708: PUSH
40709: LD_INT 3
40711: NEG
40712: PUSH
40713: EMPTY
40714: LIST
40715: LIST
40716: PUSH
40717: LD_INT 2
40719: NEG
40720: PUSH
40721: LD_INT 2
40723: NEG
40724: PUSH
40725: EMPTY
40726: LIST
40727: LIST
40728: PUSH
40729: LD_INT 3
40731: NEG
40732: PUSH
40733: LD_INT 2
40735: NEG
40736: PUSH
40737: EMPTY
40738: LIST
40739: LIST
40740: PUSH
40741: LD_INT 4
40743: NEG
40744: PUSH
40745: LD_INT 3
40747: NEG
40748: PUSH
40749: EMPTY
40750: LIST
40751: LIST
40752: PUSH
40753: LD_INT 4
40755: NEG
40756: PUSH
40757: LD_INT 4
40759: NEG
40760: PUSH
40761: EMPTY
40762: LIST
40763: LIST
40764: PUSH
40765: LD_INT 2
40767: NEG
40768: PUSH
40769: LD_INT 4
40771: NEG
40772: PUSH
40773: EMPTY
40774: LIST
40775: LIST
40776: PUSH
40777: LD_INT 4
40779: NEG
40780: PUSH
40781: LD_INT 2
40783: NEG
40784: PUSH
40785: EMPTY
40786: LIST
40787: LIST
40788: PUSH
40789: LD_INT 0
40791: PUSH
40792: LD_INT 4
40794: NEG
40795: PUSH
40796: EMPTY
40797: LIST
40798: LIST
40799: PUSH
40800: LD_INT 0
40802: PUSH
40803: LD_INT 5
40805: NEG
40806: PUSH
40807: EMPTY
40808: LIST
40809: LIST
40810: PUSH
40811: LD_INT 1
40813: PUSH
40814: LD_INT 4
40816: NEG
40817: PUSH
40818: EMPTY
40819: LIST
40820: LIST
40821: PUSH
40822: LD_INT 1
40824: PUSH
40825: LD_INT 3
40827: NEG
40828: PUSH
40829: EMPTY
40830: LIST
40831: LIST
40832: PUSH
40833: LD_INT 0
40835: PUSH
40836: LD_INT 3
40838: NEG
40839: PUSH
40840: EMPTY
40841: LIST
40842: LIST
40843: PUSH
40844: LD_INT 1
40846: NEG
40847: PUSH
40848: LD_INT 4
40850: NEG
40851: PUSH
40852: EMPTY
40853: LIST
40854: LIST
40855: PUSH
40856: LD_INT 1
40858: NEG
40859: PUSH
40860: LD_INT 5
40862: NEG
40863: PUSH
40864: EMPTY
40865: LIST
40866: LIST
40867: PUSH
40868: LD_INT 2
40870: PUSH
40871: LD_INT 3
40873: NEG
40874: PUSH
40875: EMPTY
40876: LIST
40877: LIST
40878: PUSH
40879: LD_INT 2
40881: NEG
40882: PUSH
40883: LD_INT 5
40885: NEG
40886: PUSH
40887: EMPTY
40888: LIST
40889: LIST
40890: PUSH
40891: EMPTY
40892: LIST
40893: LIST
40894: LIST
40895: LIST
40896: LIST
40897: LIST
40898: LIST
40899: LIST
40900: LIST
40901: LIST
40902: LIST
40903: LIST
40904: LIST
40905: LIST
40906: LIST
40907: LIST
40908: LIST
40909: LIST
40910: LIST
40911: LIST
40912: LIST
40913: LIST
40914: LIST
40915: LIST
40916: LIST
40917: LIST
40918: LIST
40919: LIST
40920: LIST
40921: LIST
40922: LIST
40923: LIST
40924: LIST
40925: LIST
40926: LIST
40927: LIST
40928: LIST
40929: LIST
40930: LIST
40931: LIST
40932: LIST
40933: LIST
40934: LIST
40935: LIST
40936: LIST
40937: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
40938: LD_ADDR_VAR 0 31
40942: PUSH
40943: LD_INT 0
40945: PUSH
40946: LD_INT 4
40948: PUSH
40949: EMPTY
40950: LIST
40951: LIST
40952: PUSH
40953: LD_INT 0
40955: PUSH
40956: LD_INT 3
40958: PUSH
40959: EMPTY
40960: LIST
40961: LIST
40962: PUSH
40963: LD_INT 1
40965: PUSH
40966: LD_INT 4
40968: PUSH
40969: EMPTY
40970: LIST
40971: LIST
40972: PUSH
40973: LD_INT 1
40975: PUSH
40976: LD_INT 5
40978: PUSH
40979: EMPTY
40980: LIST
40981: LIST
40982: PUSH
40983: LD_INT 0
40985: PUSH
40986: LD_INT 5
40988: PUSH
40989: EMPTY
40990: LIST
40991: LIST
40992: PUSH
40993: LD_INT 1
40995: NEG
40996: PUSH
40997: LD_INT 4
40999: PUSH
41000: EMPTY
41001: LIST
41002: LIST
41003: PUSH
41004: LD_INT 1
41006: NEG
41007: PUSH
41008: LD_INT 3
41010: PUSH
41011: EMPTY
41012: LIST
41013: LIST
41014: PUSH
41015: LD_INT 2
41017: PUSH
41018: LD_INT 5
41020: PUSH
41021: EMPTY
41022: LIST
41023: LIST
41024: PUSH
41025: LD_INT 2
41027: NEG
41028: PUSH
41029: LD_INT 3
41031: PUSH
41032: EMPTY
41033: LIST
41034: LIST
41035: PUSH
41036: LD_INT 3
41038: NEG
41039: PUSH
41040: LD_INT 0
41042: PUSH
41043: EMPTY
41044: LIST
41045: LIST
41046: PUSH
41047: LD_INT 3
41049: NEG
41050: PUSH
41051: LD_INT 1
41053: NEG
41054: PUSH
41055: EMPTY
41056: LIST
41057: LIST
41058: PUSH
41059: LD_INT 2
41061: NEG
41062: PUSH
41063: LD_INT 0
41065: PUSH
41066: EMPTY
41067: LIST
41068: LIST
41069: PUSH
41070: LD_INT 2
41072: NEG
41073: PUSH
41074: LD_INT 1
41076: PUSH
41077: EMPTY
41078: LIST
41079: LIST
41080: PUSH
41081: LD_INT 3
41083: NEG
41084: PUSH
41085: LD_INT 1
41087: PUSH
41088: EMPTY
41089: LIST
41090: LIST
41091: PUSH
41092: LD_INT 4
41094: NEG
41095: PUSH
41096: LD_INT 0
41098: PUSH
41099: EMPTY
41100: LIST
41101: LIST
41102: PUSH
41103: LD_INT 4
41105: NEG
41106: PUSH
41107: LD_INT 1
41109: NEG
41110: PUSH
41111: EMPTY
41112: LIST
41113: LIST
41114: PUSH
41115: LD_INT 4
41117: NEG
41118: PUSH
41119: LD_INT 2
41121: NEG
41122: PUSH
41123: EMPTY
41124: LIST
41125: LIST
41126: PUSH
41127: LD_INT 2
41129: NEG
41130: PUSH
41131: LD_INT 2
41133: PUSH
41134: EMPTY
41135: LIST
41136: LIST
41137: PUSH
41138: LD_INT 4
41140: NEG
41141: PUSH
41142: LD_INT 4
41144: NEG
41145: PUSH
41146: EMPTY
41147: LIST
41148: LIST
41149: PUSH
41150: LD_INT 4
41152: NEG
41153: PUSH
41154: LD_INT 5
41156: NEG
41157: PUSH
41158: EMPTY
41159: LIST
41160: LIST
41161: PUSH
41162: LD_INT 3
41164: NEG
41165: PUSH
41166: LD_INT 4
41168: NEG
41169: PUSH
41170: EMPTY
41171: LIST
41172: LIST
41173: PUSH
41174: LD_INT 3
41176: NEG
41177: PUSH
41178: LD_INT 3
41180: NEG
41181: PUSH
41182: EMPTY
41183: LIST
41184: LIST
41185: PUSH
41186: LD_INT 4
41188: NEG
41189: PUSH
41190: LD_INT 3
41192: NEG
41193: PUSH
41194: EMPTY
41195: LIST
41196: LIST
41197: PUSH
41198: LD_INT 5
41200: NEG
41201: PUSH
41202: LD_INT 4
41204: NEG
41205: PUSH
41206: EMPTY
41207: LIST
41208: LIST
41209: PUSH
41210: LD_INT 5
41212: NEG
41213: PUSH
41214: LD_INT 5
41216: NEG
41217: PUSH
41218: EMPTY
41219: LIST
41220: LIST
41221: PUSH
41222: LD_INT 3
41224: NEG
41225: PUSH
41226: LD_INT 5
41228: NEG
41229: PUSH
41230: EMPTY
41231: LIST
41232: LIST
41233: PUSH
41234: LD_INT 5
41236: NEG
41237: PUSH
41238: LD_INT 3
41240: NEG
41241: PUSH
41242: EMPTY
41243: LIST
41244: LIST
41245: PUSH
41246: LD_INT 0
41248: PUSH
41249: LD_INT 3
41251: NEG
41252: PUSH
41253: EMPTY
41254: LIST
41255: LIST
41256: PUSH
41257: LD_INT 0
41259: PUSH
41260: LD_INT 4
41262: NEG
41263: PUSH
41264: EMPTY
41265: LIST
41266: LIST
41267: PUSH
41268: LD_INT 1
41270: PUSH
41271: LD_INT 3
41273: NEG
41274: PUSH
41275: EMPTY
41276: LIST
41277: LIST
41278: PUSH
41279: LD_INT 1
41281: PUSH
41282: LD_INT 2
41284: NEG
41285: PUSH
41286: EMPTY
41287: LIST
41288: LIST
41289: PUSH
41290: LD_INT 0
41292: PUSH
41293: LD_INT 2
41295: NEG
41296: PUSH
41297: EMPTY
41298: LIST
41299: LIST
41300: PUSH
41301: LD_INT 1
41303: NEG
41304: PUSH
41305: LD_INT 3
41307: NEG
41308: PUSH
41309: EMPTY
41310: LIST
41311: LIST
41312: PUSH
41313: LD_INT 1
41315: NEG
41316: PUSH
41317: LD_INT 4
41319: NEG
41320: PUSH
41321: EMPTY
41322: LIST
41323: LIST
41324: PUSH
41325: LD_INT 2
41327: PUSH
41328: LD_INT 2
41330: NEG
41331: PUSH
41332: EMPTY
41333: LIST
41334: LIST
41335: PUSH
41336: LD_INT 2
41338: NEG
41339: PUSH
41340: LD_INT 4
41342: NEG
41343: PUSH
41344: EMPTY
41345: LIST
41346: LIST
41347: PUSH
41348: LD_INT 4
41350: PUSH
41351: LD_INT 0
41353: PUSH
41354: EMPTY
41355: LIST
41356: LIST
41357: PUSH
41358: LD_INT 4
41360: PUSH
41361: LD_INT 1
41363: NEG
41364: PUSH
41365: EMPTY
41366: LIST
41367: LIST
41368: PUSH
41369: LD_INT 5
41371: PUSH
41372: LD_INT 0
41374: PUSH
41375: EMPTY
41376: LIST
41377: LIST
41378: PUSH
41379: LD_INT 5
41381: PUSH
41382: LD_INT 1
41384: PUSH
41385: EMPTY
41386: LIST
41387: LIST
41388: PUSH
41389: LD_INT 4
41391: PUSH
41392: LD_INT 1
41394: PUSH
41395: EMPTY
41396: LIST
41397: LIST
41398: PUSH
41399: LD_INT 3
41401: PUSH
41402: LD_INT 0
41404: PUSH
41405: EMPTY
41406: LIST
41407: LIST
41408: PUSH
41409: LD_INT 3
41411: PUSH
41412: LD_INT 1
41414: NEG
41415: PUSH
41416: EMPTY
41417: LIST
41418: LIST
41419: PUSH
41420: LD_INT 3
41422: PUSH
41423: LD_INT 2
41425: NEG
41426: PUSH
41427: EMPTY
41428: LIST
41429: LIST
41430: PUSH
41431: LD_INT 5
41433: PUSH
41434: LD_INT 2
41436: PUSH
41437: EMPTY
41438: LIST
41439: LIST
41440: PUSH
41441: EMPTY
41442: LIST
41443: LIST
41444: LIST
41445: LIST
41446: LIST
41447: LIST
41448: LIST
41449: LIST
41450: LIST
41451: LIST
41452: LIST
41453: LIST
41454: LIST
41455: LIST
41456: LIST
41457: LIST
41458: LIST
41459: LIST
41460: LIST
41461: LIST
41462: LIST
41463: LIST
41464: LIST
41465: LIST
41466: LIST
41467: LIST
41468: LIST
41469: LIST
41470: LIST
41471: LIST
41472: LIST
41473: LIST
41474: LIST
41475: LIST
41476: LIST
41477: LIST
41478: LIST
41479: LIST
41480: LIST
41481: LIST
41482: LIST
41483: LIST
41484: LIST
41485: LIST
41486: LIST
41487: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
41488: LD_ADDR_VAR 0 32
41492: PUSH
41493: LD_INT 4
41495: NEG
41496: PUSH
41497: LD_INT 0
41499: PUSH
41500: EMPTY
41501: LIST
41502: LIST
41503: PUSH
41504: LD_INT 4
41506: NEG
41507: PUSH
41508: LD_INT 1
41510: NEG
41511: PUSH
41512: EMPTY
41513: LIST
41514: LIST
41515: PUSH
41516: LD_INT 3
41518: NEG
41519: PUSH
41520: LD_INT 0
41522: PUSH
41523: EMPTY
41524: LIST
41525: LIST
41526: PUSH
41527: LD_INT 3
41529: NEG
41530: PUSH
41531: LD_INT 1
41533: PUSH
41534: EMPTY
41535: LIST
41536: LIST
41537: PUSH
41538: LD_INT 4
41540: NEG
41541: PUSH
41542: LD_INT 1
41544: PUSH
41545: EMPTY
41546: LIST
41547: LIST
41548: PUSH
41549: LD_INT 5
41551: NEG
41552: PUSH
41553: LD_INT 0
41555: PUSH
41556: EMPTY
41557: LIST
41558: LIST
41559: PUSH
41560: LD_INT 5
41562: NEG
41563: PUSH
41564: LD_INT 1
41566: NEG
41567: PUSH
41568: EMPTY
41569: LIST
41570: LIST
41571: PUSH
41572: LD_INT 5
41574: NEG
41575: PUSH
41576: LD_INT 2
41578: NEG
41579: PUSH
41580: EMPTY
41581: LIST
41582: LIST
41583: PUSH
41584: LD_INT 3
41586: NEG
41587: PUSH
41588: LD_INT 2
41590: PUSH
41591: EMPTY
41592: LIST
41593: LIST
41594: PUSH
41595: LD_INT 3
41597: NEG
41598: PUSH
41599: LD_INT 3
41601: NEG
41602: PUSH
41603: EMPTY
41604: LIST
41605: LIST
41606: PUSH
41607: LD_INT 3
41609: NEG
41610: PUSH
41611: LD_INT 4
41613: NEG
41614: PUSH
41615: EMPTY
41616: LIST
41617: LIST
41618: PUSH
41619: LD_INT 2
41621: NEG
41622: PUSH
41623: LD_INT 3
41625: NEG
41626: PUSH
41627: EMPTY
41628: LIST
41629: LIST
41630: PUSH
41631: LD_INT 2
41633: NEG
41634: PUSH
41635: LD_INT 2
41637: NEG
41638: PUSH
41639: EMPTY
41640: LIST
41641: LIST
41642: PUSH
41643: LD_INT 3
41645: NEG
41646: PUSH
41647: LD_INT 2
41649: NEG
41650: PUSH
41651: EMPTY
41652: LIST
41653: LIST
41654: PUSH
41655: LD_INT 4
41657: NEG
41658: PUSH
41659: LD_INT 3
41661: NEG
41662: PUSH
41663: EMPTY
41664: LIST
41665: LIST
41666: PUSH
41667: LD_INT 4
41669: NEG
41670: PUSH
41671: LD_INT 4
41673: NEG
41674: PUSH
41675: EMPTY
41676: LIST
41677: LIST
41678: PUSH
41679: LD_INT 2
41681: NEG
41682: PUSH
41683: LD_INT 4
41685: NEG
41686: PUSH
41687: EMPTY
41688: LIST
41689: LIST
41690: PUSH
41691: LD_INT 4
41693: NEG
41694: PUSH
41695: LD_INT 2
41697: NEG
41698: PUSH
41699: EMPTY
41700: LIST
41701: LIST
41702: PUSH
41703: LD_INT 0
41705: PUSH
41706: LD_INT 4
41708: NEG
41709: PUSH
41710: EMPTY
41711: LIST
41712: LIST
41713: PUSH
41714: LD_INT 0
41716: PUSH
41717: LD_INT 5
41719: NEG
41720: PUSH
41721: EMPTY
41722: LIST
41723: LIST
41724: PUSH
41725: LD_INT 1
41727: PUSH
41728: LD_INT 4
41730: NEG
41731: PUSH
41732: EMPTY
41733: LIST
41734: LIST
41735: PUSH
41736: LD_INT 1
41738: PUSH
41739: LD_INT 3
41741: NEG
41742: PUSH
41743: EMPTY
41744: LIST
41745: LIST
41746: PUSH
41747: LD_INT 0
41749: PUSH
41750: LD_INT 3
41752: NEG
41753: PUSH
41754: EMPTY
41755: LIST
41756: LIST
41757: PUSH
41758: LD_INT 1
41760: NEG
41761: PUSH
41762: LD_INT 4
41764: NEG
41765: PUSH
41766: EMPTY
41767: LIST
41768: LIST
41769: PUSH
41770: LD_INT 1
41772: NEG
41773: PUSH
41774: LD_INT 5
41776: NEG
41777: PUSH
41778: EMPTY
41779: LIST
41780: LIST
41781: PUSH
41782: LD_INT 2
41784: PUSH
41785: LD_INT 3
41787: NEG
41788: PUSH
41789: EMPTY
41790: LIST
41791: LIST
41792: PUSH
41793: LD_INT 2
41795: NEG
41796: PUSH
41797: LD_INT 5
41799: NEG
41800: PUSH
41801: EMPTY
41802: LIST
41803: LIST
41804: PUSH
41805: LD_INT 3
41807: PUSH
41808: LD_INT 0
41810: PUSH
41811: EMPTY
41812: LIST
41813: LIST
41814: PUSH
41815: LD_INT 3
41817: PUSH
41818: LD_INT 1
41820: NEG
41821: PUSH
41822: EMPTY
41823: LIST
41824: LIST
41825: PUSH
41826: LD_INT 4
41828: PUSH
41829: LD_INT 0
41831: PUSH
41832: EMPTY
41833: LIST
41834: LIST
41835: PUSH
41836: LD_INT 4
41838: PUSH
41839: LD_INT 1
41841: PUSH
41842: EMPTY
41843: LIST
41844: LIST
41845: PUSH
41846: LD_INT 3
41848: PUSH
41849: LD_INT 1
41851: PUSH
41852: EMPTY
41853: LIST
41854: LIST
41855: PUSH
41856: LD_INT 2
41858: PUSH
41859: LD_INT 0
41861: PUSH
41862: EMPTY
41863: LIST
41864: LIST
41865: PUSH
41866: LD_INT 2
41868: PUSH
41869: LD_INT 1
41871: NEG
41872: PUSH
41873: EMPTY
41874: LIST
41875: LIST
41876: PUSH
41877: LD_INT 2
41879: PUSH
41880: LD_INT 2
41882: NEG
41883: PUSH
41884: EMPTY
41885: LIST
41886: LIST
41887: PUSH
41888: LD_INT 4
41890: PUSH
41891: LD_INT 2
41893: PUSH
41894: EMPTY
41895: LIST
41896: LIST
41897: PUSH
41898: LD_INT 4
41900: PUSH
41901: LD_INT 4
41903: PUSH
41904: EMPTY
41905: LIST
41906: LIST
41907: PUSH
41908: LD_INT 4
41910: PUSH
41911: LD_INT 3
41913: PUSH
41914: EMPTY
41915: LIST
41916: LIST
41917: PUSH
41918: LD_INT 5
41920: PUSH
41921: LD_INT 4
41923: PUSH
41924: EMPTY
41925: LIST
41926: LIST
41927: PUSH
41928: LD_INT 5
41930: PUSH
41931: LD_INT 5
41933: PUSH
41934: EMPTY
41935: LIST
41936: LIST
41937: PUSH
41938: LD_INT 4
41940: PUSH
41941: LD_INT 5
41943: PUSH
41944: EMPTY
41945: LIST
41946: LIST
41947: PUSH
41948: LD_INT 3
41950: PUSH
41951: LD_INT 4
41953: PUSH
41954: EMPTY
41955: LIST
41956: LIST
41957: PUSH
41958: LD_INT 3
41960: PUSH
41961: LD_INT 3
41963: PUSH
41964: EMPTY
41965: LIST
41966: LIST
41967: PUSH
41968: LD_INT 5
41970: PUSH
41971: LD_INT 3
41973: PUSH
41974: EMPTY
41975: LIST
41976: LIST
41977: PUSH
41978: LD_INT 3
41980: PUSH
41981: LD_INT 5
41983: PUSH
41984: EMPTY
41985: LIST
41986: LIST
41987: PUSH
41988: EMPTY
41989: LIST
41990: LIST
41991: LIST
41992: LIST
41993: LIST
41994: LIST
41995: LIST
41996: LIST
41997: LIST
41998: LIST
41999: LIST
42000: LIST
42001: LIST
42002: LIST
42003: LIST
42004: LIST
42005: LIST
42006: LIST
42007: LIST
42008: LIST
42009: LIST
42010: LIST
42011: LIST
42012: LIST
42013: LIST
42014: LIST
42015: LIST
42016: LIST
42017: LIST
42018: LIST
42019: LIST
42020: LIST
42021: LIST
42022: LIST
42023: LIST
42024: LIST
42025: LIST
42026: LIST
42027: LIST
42028: LIST
42029: LIST
42030: LIST
42031: LIST
42032: LIST
42033: LIST
42034: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
42035: LD_ADDR_VAR 0 33
42039: PUSH
42040: LD_INT 4
42042: NEG
42043: PUSH
42044: LD_INT 4
42046: NEG
42047: PUSH
42048: EMPTY
42049: LIST
42050: LIST
42051: PUSH
42052: LD_INT 4
42054: NEG
42055: PUSH
42056: LD_INT 5
42058: NEG
42059: PUSH
42060: EMPTY
42061: LIST
42062: LIST
42063: PUSH
42064: LD_INT 3
42066: NEG
42067: PUSH
42068: LD_INT 4
42070: NEG
42071: PUSH
42072: EMPTY
42073: LIST
42074: LIST
42075: PUSH
42076: LD_INT 3
42078: NEG
42079: PUSH
42080: LD_INT 3
42082: NEG
42083: PUSH
42084: EMPTY
42085: LIST
42086: LIST
42087: PUSH
42088: LD_INT 4
42090: NEG
42091: PUSH
42092: LD_INT 3
42094: NEG
42095: PUSH
42096: EMPTY
42097: LIST
42098: LIST
42099: PUSH
42100: LD_INT 5
42102: NEG
42103: PUSH
42104: LD_INT 4
42106: NEG
42107: PUSH
42108: EMPTY
42109: LIST
42110: LIST
42111: PUSH
42112: LD_INT 5
42114: NEG
42115: PUSH
42116: LD_INT 5
42118: NEG
42119: PUSH
42120: EMPTY
42121: LIST
42122: LIST
42123: PUSH
42124: LD_INT 3
42126: NEG
42127: PUSH
42128: LD_INT 5
42130: NEG
42131: PUSH
42132: EMPTY
42133: LIST
42134: LIST
42135: PUSH
42136: LD_INT 5
42138: NEG
42139: PUSH
42140: LD_INT 3
42142: NEG
42143: PUSH
42144: EMPTY
42145: LIST
42146: LIST
42147: PUSH
42148: LD_INT 0
42150: PUSH
42151: LD_INT 3
42153: NEG
42154: PUSH
42155: EMPTY
42156: LIST
42157: LIST
42158: PUSH
42159: LD_INT 0
42161: PUSH
42162: LD_INT 4
42164: NEG
42165: PUSH
42166: EMPTY
42167: LIST
42168: LIST
42169: PUSH
42170: LD_INT 1
42172: PUSH
42173: LD_INT 3
42175: NEG
42176: PUSH
42177: EMPTY
42178: LIST
42179: LIST
42180: PUSH
42181: LD_INT 1
42183: PUSH
42184: LD_INT 2
42186: NEG
42187: PUSH
42188: EMPTY
42189: LIST
42190: LIST
42191: PUSH
42192: LD_INT 0
42194: PUSH
42195: LD_INT 2
42197: NEG
42198: PUSH
42199: EMPTY
42200: LIST
42201: LIST
42202: PUSH
42203: LD_INT 1
42205: NEG
42206: PUSH
42207: LD_INT 3
42209: NEG
42210: PUSH
42211: EMPTY
42212: LIST
42213: LIST
42214: PUSH
42215: LD_INT 1
42217: NEG
42218: PUSH
42219: LD_INT 4
42221: NEG
42222: PUSH
42223: EMPTY
42224: LIST
42225: LIST
42226: PUSH
42227: LD_INT 2
42229: PUSH
42230: LD_INT 2
42232: NEG
42233: PUSH
42234: EMPTY
42235: LIST
42236: LIST
42237: PUSH
42238: LD_INT 2
42240: NEG
42241: PUSH
42242: LD_INT 4
42244: NEG
42245: PUSH
42246: EMPTY
42247: LIST
42248: LIST
42249: PUSH
42250: LD_INT 4
42252: PUSH
42253: LD_INT 0
42255: PUSH
42256: EMPTY
42257: LIST
42258: LIST
42259: PUSH
42260: LD_INT 4
42262: PUSH
42263: LD_INT 1
42265: NEG
42266: PUSH
42267: EMPTY
42268: LIST
42269: LIST
42270: PUSH
42271: LD_INT 5
42273: PUSH
42274: LD_INT 0
42276: PUSH
42277: EMPTY
42278: LIST
42279: LIST
42280: PUSH
42281: LD_INT 5
42283: PUSH
42284: LD_INT 1
42286: PUSH
42287: EMPTY
42288: LIST
42289: LIST
42290: PUSH
42291: LD_INT 4
42293: PUSH
42294: LD_INT 1
42296: PUSH
42297: EMPTY
42298: LIST
42299: LIST
42300: PUSH
42301: LD_INT 3
42303: PUSH
42304: LD_INT 0
42306: PUSH
42307: EMPTY
42308: LIST
42309: LIST
42310: PUSH
42311: LD_INT 3
42313: PUSH
42314: LD_INT 1
42316: NEG
42317: PUSH
42318: EMPTY
42319: LIST
42320: LIST
42321: PUSH
42322: LD_INT 3
42324: PUSH
42325: LD_INT 2
42327: NEG
42328: PUSH
42329: EMPTY
42330: LIST
42331: LIST
42332: PUSH
42333: LD_INT 5
42335: PUSH
42336: LD_INT 2
42338: PUSH
42339: EMPTY
42340: LIST
42341: LIST
42342: PUSH
42343: LD_INT 3
42345: PUSH
42346: LD_INT 3
42348: PUSH
42349: EMPTY
42350: LIST
42351: LIST
42352: PUSH
42353: LD_INT 3
42355: PUSH
42356: LD_INT 2
42358: PUSH
42359: EMPTY
42360: LIST
42361: LIST
42362: PUSH
42363: LD_INT 4
42365: PUSH
42366: LD_INT 3
42368: PUSH
42369: EMPTY
42370: LIST
42371: LIST
42372: PUSH
42373: LD_INT 4
42375: PUSH
42376: LD_INT 4
42378: PUSH
42379: EMPTY
42380: LIST
42381: LIST
42382: PUSH
42383: LD_INT 3
42385: PUSH
42386: LD_INT 4
42388: PUSH
42389: EMPTY
42390: LIST
42391: LIST
42392: PUSH
42393: LD_INT 2
42395: PUSH
42396: LD_INT 3
42398: PUSH
42399: EMPTY
42400: LIST
42401: LIST
42402: PUSH
42403: LD_INT 2
42405: PUSH
42406: LD_INT 2
42408: PUSH
42409: EMPTY
42410: LIST
42411: LIST
42412: PUSH
42413: LD_INT 4
42415: PUSH
42416: LD_INT 2
42418: PUSH
42419: EMPTY
42420: LIST
42421: LIST
42422: PUSH
42423: LD_INT 2
42425: PUSH
42426: LD_INT 4
42428: PUSH
42429: EMPTY
42430: LIST
42431: LIST
42432: PUSH
42433: LD_INT 0
42435: PUSH
42436: LD_INT 4
42438: PUSH
42439: EMPTY
42440: LIST
42441: LIST
42442: PUSH
42443: LD_INT 0
42445: PUSH
42446: LD_INT 3
42448: PUSH
42449: EMPTY
42450: LIST
42451: LIST
42452: PUSH
42453: LD_INT 1
42455: PUSH
42456: LD_INT 4
42458: PUSH
42459: EMPTY
42460: LIST
42461: LIST
42462: PUSH
42463: LD_INT 1
42465: PUSH
42466: LD_INT 5
42468: PUSH
42469: EMPTY
42470: LIST
42471: LIST
42472: PUSH
42473: LD_INT 0
42475: PUSH
42476: LD_INT 5
42478: PUSH
42479: EMPTY
42480: LIST
42481: LIST
42482: PUSH
42483: LD_INT 1
42485: NEG
42486: PUSH
42487: LD_INT 4
42489: PUSH
42490: EMPTY
42491: LIST
42492: LIST
42493: PUSH
42494: LD_INT 1
42496: NEG
42497: PUSH
42498: LD_INT 3
42500: PUSH
42501: EMPTY
42502: LIST
42503: LIST
42504: PUSH
42505: LD_INT 2
42507: PUSH
42508: LD_INT 5
42510: PUSH
42511: EMPTY
42512: LIST
42513: LIST
42514: PUSH
42515: LD_INT 2
42517: NEG
42518: PUSH
42519: LD_INT 3
42521: PUSH
42522: EMPTY
42523: LIST
42524: LIST
42525: PUSH
42526: EMPTY
42527: LIST
42528: LIST
42529: LIST
42530: LIST
42531: LIST
42532: LIST
42533: LIST
42534: LIST
42535: LIST
42536: LIST
42537: LIST
42538: LIST
42539: LIST
42540: LIST
42541: LIST
42542: LIST
42543: LIST
42544: LIST
42545: LIST
42546: LIST
42547: LIST
42548: LIST
42549: LIST
42550: LIST
42551: LIST
42552: LIST
42553: LIST
42554: LIST
42555: LIST
42556: LIST
42557: LIST
42558: LIST
42559: LIST
42560: LIST
42561: LIST
42562: LIST
42563: LIST
42564: LIST
42565: LIST
42566: LIST
42567: LIST
42568: LIST
42569: LIST
42570: LIST
42571: LIST
42572: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
42573: LD_ADDR_VAR 0 34
42577: PUSH
42578: LD_INT 0
42580: PUSH
42581: LD_INT 4
42583: NEG
42584: PUSH
42585: EMPTY
42586: LIST
42587: LIST
42588: PUSH
42589: LD_INT 0
42591: PUSH
42592: LD_INT 5
42594: NEG
42595: PUSH
42596: EMPTY
42597: LIST
42598: LIST
42599: PUSH
42600: LD_INT 1
42602: PUSH
42603: LD_INT 4
42605: NEG
42606: PUSH
42607: EMPTY
42608: LIST
42609: LIST
42610: PUSH
42611: LD_INT 1
42613: PUSH
42614: LD_INT 3
42616: NEG
42617: PUSH
42618: EMPTY
42619: LIST
42620: LIST
42621: PUSH
42622: LD_INT 0
42624: PUSH
42625: LD_INT 3
42627: NEG
42628: PUSH
42629: EMPTY
42630: LIST
42631: LIST
42632: PUSH
42633: LD_INT 1
42635: NEG
42636: PUSH
42637: LD_INT 4
42639: NEG
42640: PUSH
42641: EMPTY
42642: LIST
42643: LIST
42644: PUSH
42645: LD_INT 1
42647: NEG
42648: PUSH
42649: LD_INT 5
42651: NEG
42652: PUSH
42653: EMPTY
42654: LIST
42655: LIST
42656: PUSH
42657: LD_INT 2
42659: PUSH
42660: LD_INT 3
42662: NEG
42663: PUSH
42664: EMPTY
42665: LIST
42666: LIST
42667: PUSH
42668: LD_INT 2
42670: NEG
42671: PUSH
42672: LD_INT 5
42674: NEG
42675: PUSH
42676: EMPTY
42677: LIST
42678: LIST
42679: PUSH
42680: LD_INT 3
42682: PUSH
42683: LD_INT 0
42685: PUSH
42686: EMPTY
42687: LIST
42688: LIST
42689: PUSH
42690: LD_INT 3
42692: PUSH
42693: LD_INT 1
42695: NEG
42696: PUSH
42697: EMPTY
42698: LIST
42699: LIST
42700: PUSH
42701: LD_INT 4
42703: PUSH
42704: LD_INT 0
42706: PUSH
42707: EMPTY
42708: LIST
42709: LIST
42710: PUSH
42711: LD_INT 4
42713: PUSH
42714: LD_INT 1
42716: PUSH
42717: EMPTY
42718: LIST
42719: LIST
42720: PUSH
42721: LD_INT 3
42723: PUSH
42724: LD_INT 1
42726: PUSH
42727: EMPTY
42728: LIST
42729: LIST
42730: PUSH
42731: LD_INT 2
42733: PUSH
42734: LD_INT 0
42736: PUSH
42737: EMPTY
42738: LIST
42739: LIST
42740: PUSH
42741: LD_INT 2
42743: PUSH
42744: LD_INT 1
42746: NEG
42747: PUSH
42748: EMPTY
42749: LIST
42750: LIST
42751: PUSH
42752: LD_INT 2
42754: PUSH
42755: LD_INT 2
42757: NEG
42758: PUSH
42759: EMPTY
42760: LIST
42761: LIST
42762: PUSH
42763: LD_INT 4
42765: PUSH
42766: LD_INT 2
42768: PUSH
42769: EMPTY
42770: LIST
42771: LIST
42772: PUSH
42773: LD_INT 4
42775: PUSH
42776: LD_INT 4
42778: PUSH
42779: EMPTY
42780: LIST
42781: LIST
42782: PUSH
42783: LD_INT 4
42785: PUSH
42786: LD_INT 3
42788: PUSH
42789: EMPTY
42790: LIST
42791: LIST
42792: PUSH
42793: LD_INT 5
42795: PUSH
42796: LD_INT 4
42798: PUSH
42799: EMPTY
42800: LIST
42801: LIST
42802: PUSH
42803: LD_INT 5
42805: PUSH
42806: LD_INT 5
42808: PUSH
42809: EMPTY
42810: LIST
42811: LIST
42812: PUSH
42813: LD_INT 4
42815: PUSH
42816: LD_INT 5
42818: PUSH
42819: EMPTY
42820: LIST
42821: LIST
42822: PUSH
42823: LD_INT 3
42825: PUSH
42826: LD_INT 4
42828: PUSH
42829: EMPTY
42830: LIST
42831: LIST
42832: PUSH
42833: LD_INT 3
42835: PUSH
42836: LD_INT 3
42838: PUSH
42839: EMPTY
42840: LIST
42841: LIST
42842: PUSH
42843: LD_INT 5
42845: PUSH
42846: LD_INT 3
42848: PUSH
42849: EMPTY
42850: LIST
42851: LIST
42852: PUSH
42853: LD_INT 3
42855: PUSH
42856: LD_INT 5
42858: PUSH
42859: EMPTY
42860: LIST
42861: LIST
42862: PUSH
42863: LD_INT 0
42865: PUSH
42866: LD_INT 3
42868: PUSH
42869: EMPTY
42870: LIST
42871: LIST
42872: PUSH
42873: LD_INT 0
42875: PUSH
42876: LD_INT 2
42878: PUSH
42879: EMPTY
42880: LIST
42881: LIST
42882: PUSH
42883: LD_INT 1
42885: PUSH
42886: LD_INT 3
42888: PUSH
42889: EMPTY
42890: LIST
42891: LIST
42892: PUSH
42893: LD_INT 1
42895: PUSH
42896: LD_INT 4
42898: PUSH
42899: EMPTY
42900: LIST
42901: LIST
42902: PUSH
42903: LD_INT 0
42905: PUSH
42906: LD_INT 4
42908: PUSH
42909: EMPTY
42910: LIST
42911: LIST
42912: PUSH
42913: LD_INT 1
42915: NEG
42916: PUSH
42917: LD_INT 3
42919: PUSH
42920: EMPTY
42921: LIST
42922: LIST
42923: PUSH
42924: LD_INT 1
42926: NEG
42927: PUSH
42928: LD_INT 2
42930: PUSH
42931: EMPTY
42932: LIST
42933: LIST
42934: PUSH
42935: LD_INT 2
42937: PUSH
42938: LD_INT 4
42940: PUSH
42941: EMPTY
42942: LIST
42943: LIST
42944: PUSH
42945: LD_INT 2
42947: NEG
42948: PUSH
42949: LD_INT 2
42951: PUSH
42952: EMPTY
42953: LIST
42954: LIST
42955: PUSH
42956: LD_INT 4
42958: NEG
42959: PUSH
42960: LD_INT 0
42962: PUSH
42963: EMPTY
42964: LIST
42965: LIST
42966: PUSH
42967: LD_INT 4
42969: NEG
42970: PUSH
42971: LD_INT 1
42973: NEG
42974: PUSH
42975: EMPTY
42976: LIST
42977: LIST
42978: PUSH
42979: LD_INT 3
42981: NEG
42982: PUSH
42983: LD_INT 0
42985: PUSH
42986: EMPTY
42987: LIST
42988: LIST
42989: PUSH
42990: LD_INT 3
42992: NEG
42993: PUSH
42994: LD_INT 1
42996: PUSH
42997: EMPTY
42998: LIST
42999: LIST
43000: PUSH
43001: LD_INT 4
43003: NEG
43004: PUSH
43005: LD_INT 1
43007: PUSH
43008: EMPTY
43009: LIST
43010: LIST
43011: PUSH
43012: LD_INT 5
43014: NEG
43015: PUSH
43016: LD_INT 0
43018: PUSH
43019: EMPTY
43020: LIST
43021: LIST
43022: PUSH
43023: LD_INT 5
43025: NEG
43026: PUSH
43027: LD_INT 1
43029: NEG
43030: PUSH
43031: EMPTY
43032: LIST
43033: LIST
43034: PUSH
43035: LD_INT 5
43037: NEG
43038: PUSH
43039: LD_INT 2
43041: NEG
43042: PUSH
43043: EMPTY
43044: LIST
43045: LIST
43046: PUSH
43047: LD_INT 3
43049: NEG
43050: PUSH
43051: LD_INT 2
43053: PUSH
43054: EMPTY
43055: LIST
43056: LIST
43057: PUSH
43058: EMPTY
43059: LIST
43060: LIST
43061: LIST
43062: LIST
43063: LIST
43064: LIST
43065: LIST
43066: LIST
43067: LIST
43068: LIST
43069: LIST
43070: LIST
43071: LIST
43072: LIST
43073: LIST
43074: LIST
43075: LIST
43076: LIST
43077: LIST
43078: LIST
43079: LIST
43080: LIST
43081: LIST
43082: LIST
43083: LIST
43084: LIST
43085: LIST
43086: LIST
43087: LIST
43088: LIST
43089: LIST
43090: LIST
43091: LIST
43092: LIST
43093: LIST
43094: LIST
43095: LIST
43096: LIST
43097: LIST
43098: LIST
43099: LIST
43100: LIST
43101: LIST
43102: LIST
43103: LIST
43104: ST_TO_ADDR
// end ; end ;
43105: GO 43108
43107: POP
// case btype of b_depot , b_warehouse :
43108: LD_VAR 0 1
43112: PUSH
43113: LD_INT 0
43115: DOUBLE
43116: EQUAL
43117: IFTRUE 43127
43119: LD_INT 1
43121: DOUBLE
43122: EQUAL
43123: IFTRUE 43127
43125: GO 43328
43127: POP
// case nation of nation_american :
43128: LD_VAR 0 5
43132: PUSH
43133: LD_INT 1
43135: DOUBLE
43136: EQUAL
43137: IFTRUE 43141
43139: GO 43197
43141: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
43142: LD_ADDR_VAR 0 9
43146: PUSH
43147: LD_VAR 0 11
43151: PUSH
43152: LD_VAR 0 12
43156: PUSH
43157: LD_VAR 0 13
43161: PUSH
43162: LD_VAR 0 14
43166: PUSH
43167: LD_VAR 0 15
43171: PUSH
43172: LD_VAR 0 16
43176: PUSH
43177: EMPTY
43178: LIST
43179: LIST
43180: LIST
43181: LIST
43182: LIST
43183: LIST
43184: PUSH
43185: LD_VAR 0 4
43189: PUSH
43190: LD_INT 1
43192: PLUS
43193: ARRAY
43194: ST_TO_ADDR
43195: GO 43326
43197: LD_INT 2
43199: DOUBLE
43200: EQUAL
43201: IFTRUE 43205
43203: GO 43261
43205: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
43206: LD_ADDR_VAR 0 9
43210: PUSH
43211: LD_VAR 0 17
43215: PUSH
43216: LD_VAR 0 18
43220: PUSH
43221: LD_VAR 0 19
43225: PUSH
43226: LD_VAR 0 20
43230: PUSH
43231: LD_VAR 0 21
43235: PUSH
43236: LD_VAR 0 22
43240: PUSH
43241: EMPTY
43242: LIST
43243: LIST
43244: LIST
43245: LIST
43246: LIST
43247: LIST
43248: PUSH
43249: LD_VAR 0 4
43253: PUSH
43254: LD_INT 1
43256: PLUS
43257: ARRAY
43258: ST_TO_ADDR
43259: GO 43326
43261: LD_INT 3
43263: DOUBLE
43264: EQUAL
43265: IFTRUE 43269
43267: GO 43325
43269: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
43270: LD_ADDR_VAR 0 9
43274: PUSH
43275: LD_VAR 0 23
43279: PUSH
43280: LD_VAR 0 24
43284: PUSH
43285: LD_VAR 0 25
43289: PUSH
43290: LD_VAR 0 26
43294: PUSH
43295: LD_VAR 0 27
43299: PUSH
43300: LD_VAR 0 28
43304: PUSH
43305: EMPTY
43306: LIST
43307: LIST
43308: LIST
43309: LIST
43310: LIST
43311: LIST
43312: PUSH
43313: LD_VAR 0 4
43317: PUSH
43318: LD_INT 1
43320: PLUS
43321: ARRAY
43322: ST_TO_ADDR
43323: GO 43326
43325: POP
43326: GO 43881
43328: LD_INT 2
43330: DOUBLE
43331: EQUAL
43332: IFTRUE 43342
43334: LD_INT 3
43336: DOUBLE
43337: EQUAL
43338: IFTRUE 43342
43340: GO 43398
43342: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
43343: LD_ADDR_VAR 0 9
43347: PUSH
43348: LD_VAR 0 29
43352: PUSH
43353: LD_VAR 0 30
43357: PUSH
43358: LD_VAR 0 31
43362: PUSH
43363: LD_VAR 0 32
43367: PUSH
43368: LD_VAR 0 33
43372: PUSH
43373: LD_VAR 0 34
43377: PUSH
43378: EMPTY
43379: LIST
43380: LIST
43381: LIST
43382: LIST
43383: LIST
43384: LIST
43385: PUSH
43386: LD_VAR 0 4
43390: PUSH
43391: LD_INT 1
43393: PLUS
43394: ARRAY
43395: ST_TO_ADDR
43396: GO 43881
43398: LD_INT 16
43400: DOUBLE
43401: EQUAL
43402: IFTRUE 43460
43404: LD_INT 17
43406: DOUBLE
43407: EQUAL
43408: IFTRUE 43460
43410: LD_INT 18
43412: DOUBLE
43413: EQUAL
43414: IFTRUE 43460
43416: LD_INT 19
43418: DOUBLE
43419: EQUAL
43420: IFTRUE 43460
43422: LD_INT 22
43424: DOUBLE
43425: EQUAL
43426: IFTRUE 43460
43428: LD_INT 20
43430: DOUBLE
43431: EQUAL
43432: IFTRUE 43460
43434: LD_INT 21
43436: DOUBLE
43437: EQUAL
43438: IFTRUE 43460
43440: LD_INT 23
43442: DOUBLE
43443: EQUAL
43444: IFTRUE 43460
43446: LD_INT 24
43448: DOUBLE
43449: EQUAL
43450: IFTRUE 43460
43452: LD_INT 25
43454: DOUBLE
43455: EQUAL
43456: IFTRUE 43460
43458: GO 43516
43460: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
43461: LD_ADDR_VAR 0 9
43465: PUSH
43466: LD_VAR 0 35
43470: PUSH
43471: LD_VAR 0 36
43475: PUSH
43476: LD_VAR 0 37
43480: PUSH
43481: LD_VAR 0 38
43485: PUSH
43486: LD_VAR 0 39
43490: PUSH
43491: LD_VAR 0 40
43495: PUSH
43496: EMPTY
43497: LIST
43498: LIST
43499: LIST
43500: LIST
43501: LIST
43502: LIST
43503: PUSH
43504: LD_VAR 0 4
43508: PUSH
43509: LD_INT 1
43511: PLUS
43512: ARRAY
43513: ST_TO_ADDR
43514: GO 43881
43516: LD_INT 6
43518: DOUBLE
43519: EQUAL
43520: IFTRUE 43572
43522: LD_INT 7
43524: DOUBLE
43525: EQUAL
43526: IFTRUE 43572
43528: LD_INT 8
43530: DOUBLE
43531: EQUAL
43532: IFTRUE 43572
43534: LD_INT 13
43536: DOUBLE
43537: EQUAL
43538: IFTRUE 43572
43540: LD_INT 12
43542: DOUBLE
43543: EQUAL
43544: IFTRUE 43572
43546: LD_INT 15
43548: DOUBLE
43549: EQUAL
43550: IFTRUE 43572
43552: LD_INT 11
43554: DOUBLE
43555: EQUAL
43556: IFTRUE 43572
43558: LD_INT 14
43560: DOUBLE
43561: EQUAL
43562: IFTRUE 43572
43564: LD_INT 10
43566: DOUBLE
43567: EQUAL
43568: IFTRUE 43572
43570: GO 43628
43572: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
43573: LD_ADDR_VAR 0 9
43577: PUSH
43578: LD_VAR 0 41
43582: PUSH
43583: LD_VAR 0 42
43587: PUSH
43588: LD_VAR 0 43
43592: PUSH
43593: LD_VAR 0 44
43597: PUSH
43598: LD_VAR 0 45
43602: PUSH
43603: LD_VAR 0 46
43607: PUSH
43608: EMPTY
43609: LIST
43610: LIST
43611: LIST
43612: LIST
43613: LIST
43614: LIST
43615: PUSH
43616: LD_VAR 0 4
43620: PUSH
43621: LD_INT 1
43623: PLUS
43624: ARRAY
43625: ST_TO_ADDR
43626: GO 43881
43628: LD_INT 36
43630: DOUBLE
43631: EQUAL
43632: IFTRUE 43636
43634: GO 43692
43636: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
43637: LD_ADDR_VAR 0 9
43641: PUSH
43642: LD_VAR 0 47
43646: PUSH
43647: LD_VAR 0 48
43651: PUSH
43652: LD_VAR 0 49
43656: PUSH
43657: LD_VAR 0 50
43661: PUSH
43662: LD_VAR 0 51
43666: PUSH
43667: LD_VAR 0 52
43671: PUSH
43672: EMPTY
43673: LIST
43674: LIST
43675: LIST
43676: LIST
43677: LIST
43678: LIST
43679: PUSH
43680: LD_VAR 0 4
43684: PUSH
43685: LD_INT 1
43687: PLUS
43688: ARRAY
43689: ST_TO_ADDR
43690: GO 43881
43692: LD_INT 4
43694: DOUBLE
43695: EQUAL
43696: IFTRUE 43718
43698: LD_INT 5
43700: DOUBLE
43701: EQUAL
43702: IFTRUE 43718
43704: LD_INT 34
43706: DOUBLE
43707: EQUAL
43708: IFTRUE 43718
43710: LD_INT 37
43712: DOUBLE
43713: EQUAL
43714: IFTRUE 43718
43716: GO 43774
43718: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
43719: LD_ADDR_VAR 0 9
43723: PUSH
43724: LD_VAR 0 53
43728: PUSH
43729: LD_VAR 0 54
43733: PUSH
43734: LD_VAR 0 55
43738: PUSH
43739: LD_VAR 0 56
43743: PUSH
43744: LD_VAR 0 57
43748: PUSH
43749: LD_VAR 0 58
43753: PUSH
43754: EMPTY
43755: LIST
43756: LIST
43757: LIST
43758: LIST
43759: LIST
43760: LIST
43761: PUSH
43762: LD_VAR 0 4
43766: PUSH
43767: LD_INT 1
43769: PLUS
43770: ARRAY
43771: ST_TO_ADDR
43772: GO 43881
43774: LD_INT 31
43776: DOUBLE
43777: EQUAL
43778: IFTRUE 43824
43780: LD_INT 32
43782: DOUBLE
43783: EQUAL
43784: IFTRUE 43824
43786: LD_INT 33
43788: DOUBLE
43789: EQUAL
43790: IFTRUE 43824
43792: LD_INT 27
43794: DOUBLE
43795: EQUAL
43796: IFTRUE 43824
43798: LD_INT 26
43800: DOUBLE
43801: EQUAL
43802: IFTRUE 43824
43804: LD_INT 28
43806: DOUBLE
43807: EQUAL
43808: IFTRUE 43824
43810: LD_INT 29
43812: DOUBLE
43813: EQUAL
43814: IFTRUE 43824
43816: LD_INT 30
43818: DOUBLE
43819: EQUAL
43820: IFTRUE 43824
43822: GO 43880
43824: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
43825: LD_ADDR_VAR 0 9
43829: PUSH
43830: LD_VAR 0 59
43834: PUSH
43835: LD_VAR 0 60
43839: PUSH
43840: LD_VAR 0 61
43844: PUSH
43845: LD_VAR 0 62
43849: PUSH
43850: LD_VAR 0 63
43854: PUSH
43855: LD_VAR 0 64
43859: PUSH
43860: EMPTY
43861: LIST
43862: LIST
43863: LIST
43864: LIST
43865: LIST
43866: LIST
43867: PUSH
43868: LD_VAR 0 4
43872: PUSH
43873: LD_INT 1
43875: PLUS
43876: ARRAY
43877: ST_TO_ADDR
43878: GO 43881
43880: POP
// temp_list2 = [ ] ;
43881: LD_ADDR_VAR 0 10
43885: PUSH
43886: EMPTY
43887: ST_TO_ADDR
// for i in temp_list do
43888: LD_ADDR_VAR 0 8
43892: PUSH
43893: LD_VAR 0 9
43897: PUSH
43898: FOR_IN
43899: IFFALSE 43951
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
43901: LD_ADDR_VAR 0 10
43905: PUSH
43906: LD_VAR 0 10
43910: PUSH
43911: LD_VAR 0 8
43915: PUSH
43916: LD_INT 1
43918: ARRAY
43919: PUSH
43920: LD_VAR 0 2
43924: PLUS
43925: PUSH
43926: LD_VAR 0 8
43930: PUSH
43931: LD_INT 2
43933: ARRAY
43934: PUSH
43935: LD_VAR 0 3
43939: PLUS
43940: PUSH
43941: EMPTY
43942: LIST
43943: LIST
43944: PUSH
43945: EMPTY
43946: LIST
43947: ADD
43948: ST_TO_ADDR
43949: GO 43898
43951: POP
43952: POP
// result = temp_list2 ;
43953: LD_ADDR_VAR 0 7
43957: PUSH
43958: LD_VAR 0 10
43962: ST_TO_ADDR
// end ;
43963: LD_VAR 0 7
43967: RET
// export function EnemyInRange ( unit , dist ) ; begin
43968: LD_INT 0
43970: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
43971: LD_ADDR_VAR 0 3
43975: PUSH
43976: LD_VAR 0 1
43980: PPUSH
43981: CALL_OW 255
43985: PPUSH
43986: LD_VAR 0 1
43990: PPUSH
43991: CALL_OW 250
43995: PPUSH
43996: LD_VAR 0 1
44000: PPUSH
44001: CALL_OW 251
44005: PPUSH
44006: LD_VAR 0 2
44010: PPUSH
44011: CALL 17341 0 4
44015: PUSH
44016: LD_INT 4
44018: ARRAY
44019: ST_TO_ADDR
// end ;
44020: LD_VAR 0 3
44024: RET
// export function PlayerSeeMe ( unit ) ; begin
44025: LD_INT 0
44027: PPUSH
// result := See ( your_side , unit ) ;
44028: LD_ADDR_VAR 0 2
44032: PUSH
44033: LD_OWVAR 2
44037: PPUSH
44038: LD_VAR 0 1
44042: PPUSH
44043: CALL_OW 292
44047: ST_TO_ADDR
// end ;
44048: LD_VAR 0 2
44052: RET
// export function ReverseDir ( unit ) ; begin
44053: LD_INT 0
44055: PPUSH
// if not unit then
44056: LD_VAR 0 1
44060: NOT
44061: IFFALSE 44065
// exit ;
44063: GO 44088
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
44065: LD_ADDR_VAR 0 2
44069: PUSH
44070: LD_VAR 0 1
44074: PPUSH
44075: CALL_OW 254
44079: PUSH
44080: LD_INT 3
44082: PLUS
44083: PUSH
44084: LD_INT 6
44086: MOD
44087: ST_TO_ADDR
// end ;
44088: LD_VAR 0 2
44092: RET
// export function ReverseArray ( array ) ; var i ; begin
44093: LD_INT 0
44095: PPUSH
44096: PPUSH
// if not array then
44097: LD_VAR 0 1
44101: NOT
44102: IFFALSE 44106
// exit ;
44104: GO 44161
// result := [ ] ;
44106: LD_ADDR_VAR 0 2
44110: PUSH
44111: EMPTY
44112: ST_TO_ADDR
// for i := array downto 1 do
44113: LD_ADDR_VAR 0 3
44117: PUSH
44118: DOUBLE
44119: LD_VAR 0 1
44123: INC
44124: ST_TO_ADDR
44125: LD_INT 1
44127: PUSH
44128: FOR_DOWNTO
44129: IFFALSE 44159
// result := Join ( result , array [ i ] ) ;
44131: LD_ADDR_VAR 0 2
44135: PUSH
44136: LD_VAR 0 2
44140: PPUSH
44141: LD_VAR 0 1
44145: PUSH
44146: LD_VAR 0 3
44150: ARRAY
44151: PPUSH
44152: CALL 48817 0 2
44156: ST_TO_ADDR
44157: GO 44128
44159: POP
44160: POP
// end ;
44161: LD_VAR 0 2
44165: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
44166: LD_INT 0
44168: PPUSH
44169: PPUSH
44170: PPUSH
44171: PPUSH
44172: PPUSH
44173: PPUSH
// if not unit or not hexes then
44174: LD_VAR 0 1
44178: NOT
44179: PUSH
44180: LD_VAR 0 2
44184: NOT
44185: OR
44186: IFFALSE 44190
// exit ;
44188: GO 44313
// dist := 9999 ;
44190: LD_ADDR_VAR 0 5
44194: PUSH
44195: LD_INT 9999
44197: ST_TO_ADDR
// for i = 1 to hexes do
44198: LD_ADDR_VAR 0 4
44202: PUSH
44203: DOUBLE
44204: LD_INT 1
44206: DEC
44207: ST_TO_ADDR
44208: LD_VAR 0 2
44212: PUSH
44213: FOR_TO
44214: IFFALSE 44301
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
44216: LD_ADDR_VAR 0 6
44220: PUSH
44221: LD_VAR 0 1
44225: PPUSH
44226: LD_VAR 0 2
44230: PUSH
44231: LD_VAR 0 4
44235: ARRAY
44236: PUSH
44237: LD_INT 1
44239: ARRAY
44240: PPUSH
44241: LD_VAR 0 2
44245: PUSH
44246: LD_VAR 0 4
44250: ARRAY
44251: PUSH
44252: LD_INT 2
44254: ARRAY
44255: PPUSH
44256: CALL_OW 297
44260: ST_TO_ADDR
// if tdist < dist then
44261: LD_VAR 0 6
44265: PUSH
44266: LD_VAR 0 5
44270: LESS
44271: IFFALSE 44299
// begin hex := hexes [ i ] ;
44273: LD_ADDR_VAR 0 8
44277: PUSH
44278: LD_VAR 0 2
44282: PUSH
44283: LD_VAR 0 4
44287: ARRAY
44288: ST_TO_ADDR
// dist := tdist ;
44289: LD_ADDR_VAR 0 5
44293: PUSH
44294: LD_VAR 0 6
44298: ST_TO_ADDR
// end ; end ;
44299: GO 44213
44301: POP
44302: POP
// result := hex ;
44303: LD_ADDR_VAR 0 3
44307: PUSH
44308: LD_VAR 0 8
44312: ST_TO_ADDR
// end ;
44313: LD_VAR 0 3
44317: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
44318: LD_INT 0
44320: PPUSH
44321: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
44322: LD_VAR 0 1
44326: NOT
44327: PUSH
44328: LD_VAR 0 1
44332: PUSH
44333: LD_INT 21
44335: PUSH
44336: LD_INT 2
44338: PUSH
44339: EMPTY
44340: LIST
44341: LIST
44342: PUSH
44343: LD_INT 23
44345: PUSH
44346: LD_INT 2
44348: PUSH
44349: EMPTY
44350: LIST
44351: LIST
44352: PUSH
44353: EMPTY
44354: LIST
44355: LIST
44356: PPUSH
44357: CALL_OW 69
44361: IN
44362: NOT
44363: OR
44364: IFFALSE 44368
// exit ;
44366: GO 44415
// for i = 1 to 3 do
44368: LD_ADDR_VAR 0 3
44372: PUSH
44373: DOUBLE
44374: LD_INT 1
44376: DEC
44377: ST_TO_ADDR
44378: LD_INT 3
44380: PUSH
44381: FOR_TO
44382: IFFALSE 44413
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
44384: LD_VAR 0 1
44388: PPUSH
44389: CALL_OW 250
44393: PPUSH
44394: LD_VAR 0 1
44398: PPUSH
44399: CALL_OW 251
44403: PPUSH
44404: LD_INT 1
44406: PPUSH
44407: CALL_OW 453
44411: GO 44381
44413: POP
44414: POP
// end ;
44415: LD_VAR 0 2
44419: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
44420: LD_INT 0
44422: PPUSH
44423: PPUSH
44424: PPUSH
44425: PPUSH
44426: PPUSH
44427: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
44428: LD_VAR 0 1
44432: NOT
44433: PUSH
44434: LD_VAR 0 2
44438: NOT
44439: OR
44440: PUSH
44441: LD_VAR 0 1
44445: PPUSH
44446: CALL_OW 314
44450: OR
44451: IFFALSE 44455
// exit ;
44453: GO 44922
// if GetLives ( i ) < 250 then
44455: LD_VAR 0 4
44459: PPUSH
44460: CALL_OW 256
44464: PUSH
44465: LD_INT 250
44467: LESS
44468: IFFALSE 44481
// begin ComAutodestruct ( i ) ;
44470: LD_VAR 0 4
44474: PPUSH
44475: CALL 44318 0 1
// exit ;
44479: GO 44922
// end ; x := GetX ( enemy_unit ) ;
44481: LD_ADDR_VAR 0 7
44485: PUSH
44486: LD_VAR 0 2
44490: PPUSH
44491: CALL_OW 250
44495: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
44496: LD_ADDR_VAR 0 8
44500: PUSH
44501: LD_VAR 0 2
44505: PPUSH
44506: CALL_OW 251
44510: ST_TO_ADDR
// if not x or not y then
44511: LD_VAR 0 7
44515: NOT
44516: PUSH
44517: LD_VAR 0 8
44521: NOT
44522: OR
44523: IFFALSE 44527
// exit ;
44525: GO 44922
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
44527: LD_ADDR_VAR 0 6
44531: PUSH
44532: LD_VAR 0 7
44536: PPUSH
44537: LD_INT 0
44539: PPUSH
44540: LD_INT 4
44542: PPUSH
44543: CALL_OW 272
44547: PUSH
44548: LD_VAR 0 8
44552: PPUSH
44553: LD_INT 0
44555: PPUSH
44556: LD_INT 4
44558: PPUSH
44559: CALL_OW 273
44563: PUSH
44564: EMPTY
44565: LIST
44566: LIST
44567: PUSH
44568: LD_VAR 0 7
44572: PPUSH
44573: LD_INT 1
44575: PPUSH
44576: LD_INT 4
44578: PPUSH
44579: CALL_OW 272
44583: PUSH
44584: LD_VAR 0 8
44588: PPUSH
44589: LD_INT 1
44591: PPUSH
44592: LD_INT 4
44594: PPUSH
44595: CALL_OW 273
44599: PUSH
44600: EMPTY
44601: LIST
44602: LIST
44603: PUSH
44604: LD_VAR 0 7
44608: PPUSH
44609: LD_INT 2
44611: PPUSH
44612: LD_INT 4
44614: PPUSH
44615: CALL_OW 272
44619: PUSH
44620: LD_VAR 0 8
44624: PPUSH
44625: LD_INT 2
44627: PPUSH
44628: LD_INT 4
44630: PPUSH
44631: CALL_OW 273
44635: PUSH
44636: EMPTY
44637: LIST
44638: LIST
44639: PUSH
44640: LD_VAR 0 7
44644: PPUSH
44645: LD_INT 3
44647: PPUSH
44648: LD_INT 4
44650: PPUSH
44651: CALL_OW 272
44655: PUSH
44656: LD_VAR 0 8
44660: PPUSH
44661: LD_INT 3
44663: PPUSH
44664: LD_INT 4
44666: PPUSH
44667: CALL_OW 273
44671: PUSH
44672: EMPTY
44673: LIST
44674: LIST
44675: PUSH
44676: LD_VAR 0 7
44680: PPUSH
44681: LD_INT 4
44683: PPUSH
44684: LD_INT 4
44686: PPUSH
44687: CALL_OW 272
44691: PUSH
44692: LD_VAR 0 8
44696: PPUSH
44697: LD_INT 4
44699: PPUSH
44700: LD_INT 4
44702: PPUSH
44703: CALL_OW 273
44707: PUSH
44708: EMPTY
44709: LIST
44710: LIST
44711: PUSH
44712: LD_VAR 0 7
44716: PPUSH
44717: LD_INT 5
44719: PPUSH
44720: LD_INT 4
44722: PPUSH
44723: CALL_OW 272
44727: PUSH
44728: LD_VAR 0 8
44732: PPUSH
44733: LD_INT 5
44735: PPUSH
44736: LD_INT 4
44738: PPUSH
44739: CALL_OW 273
44743: PUSH
44744: EMPTY
44745: LIST
44746: LIST
44747: PUSH
44748: EMPTY
44749: LIST
44750: LIST
44751: LIST
44752: LIST
44753: LIST
44754: LIST
44755: ST_TO_ADDR
// for i = tmp downto 1 do
44756: LD_ADDR_VAR 0 4
44760: PUSH
44761: DOUBLE
44762: LD_VAR 0 6
44766: INC
44767: ST_TO_ADDR
44768: LD_INT 1
44770: PUSH
44771: FOR_DOWNTO
44772: IFFALSE 44873
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
44774: LD_VAR 0 6
44778: PUSH
44779: LD_VAR 0 4
44783: ARRAY
44784: PUSH
44785: LD_INT 1
44787: ARRAY
44788: PPUSH
44789: LD_VAR 0 6
44793: PUSH
44794: LD_VAR 0 4
44798: ARRAY
44799: PUSH
44800: LD_INT 2
44802: ARRAY
44803: PPUSH
44804: CALL_OW 488
44808: NOT
44809: PUSH
44810: LD_VAR 0 6
44814: PUSH
44815: LD_VAR 0 4
44819: ARRAY
44820: PUSH
44821: LD_INT 1
44823: ARRAY
44824: PPUSH
44825: LD_VAR 0 6
44829: PUSH
44830: LD_VAR 0 4
44834: ARRAY
44835: PUSH
44836: LD_INT 2
44838: ARRAY
44839: PPUSH
44840: CALL_OW 428
44844: PUSH
44845: LD_INT 0
44847: NONEQUAL
44848: OR
44849: IFFALSE 44871
// tmp := Delete ( tmp , i ) ;
44851: LD_ADDR_VAR 0 6
44855: PUSH
44856: LD_VAR 0 6
44860: PPUSH
44861: LD_VAR 0 4
44865: PPUSH
44866: CALL_OW 3
44870: ST_TO_ADDR
44871: GO 44771
44873: POP
44874: POP
// j := GetClosestHex ( unit , tmp ) ;
44875: LD_ADDR_VAR 0 5
44879: PUSH
44880: LD_VAR 0 1
44884: PPUSH
44885: LD_VAR 0 6
44889: PPUSH
44890: CALL 44166 0 2
44894: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
44895: LD_VAR 0 1
44899: PPUSH
44900: LD_VAR 0 5
44904: PUSH
44905: LD_INT 1
44907: ARRAY
44908: PPUSH
44909: LD_VAR 0 5
44913: PUSH
44914: LD_INT 2
44916: ARRAY
44917: PPUSH
44918: CALL_OW 111
// end ;
44922: LD_VAR 0 3
44926: RET
// export function PrepareApemanSoldier ( ) ; begin
44927: LD_INT 0
44929: PPUSH
// uc_nation := 0 ;
44930: LD_ADDR_OWVAR 21
44934: PUSH
44935: LD_INT 0
44937: ST_TO_ADDR
// hc_sex := sex_male ;
44938: LD_ADDR_OWVAR 27
44942: PUSH
44943: LD_INT 1
44945: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
44946: LD_ADDR_OWVAR 28
44950: PUSH
44951: LD_INT 15
44953: ST_TO_ADDR
// hc_gallery :=  ;
44954: LD_ADDR_OWVAR 33
44958: PUSH
44959: LD_STRING 
44961: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
44962: LD_ADDR_OWVAR 31
44966: PUSH
44967: LD_INT 0
44969: PPUSH
44970: LD_INT 3
44972: PPUSH
44973: CALL_OW 12
44977: PUSH
44978: LD_INT 0
44980: PPUSH
44981: LD_INT 3
44983: PPUSH
44984: CALL_OW 12
44988: PUSH
44989: LD_INT 0
44991: PUSH
44992: LD_INT 0
44994: PUSH
44995: EMPTY
44996: LIST
44997: LIST
44998: LIST
44999: LIST
45000: ST_TO_ADDR
// end ;
45001: LD_VAR 0 1
45005: RET
// export function PrepareApemanEngineer ( ) ; begin
45006: LD_INT 0
45008: PPUSH
// uc_nation := 0 ;
45009: LD_ADDR_OWVAR 21
45013: PUSH
45014: LD_INT 0
45016: ST_TO_ADDR
// hc_sex := sex_male ;
45017: LD_ADDR_OWVAR 27
45021: PUSH
45022: LD_INT 1
45024: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
45025: LD_ADDR_OWVAR 28
45029: PUSH
45030: LD_INT 16
45032: ST_TO_ADDR
// hc_gallery :=  ;
45033: LD_ADDR_OWVAR 33
45037: PUSH
45038: LD_STRING 
45040: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
45041: LD_ADDR_OWVAR 31
45045: PUSH
45046: LD_INT 0
45048: PPUSH
45049: LD_INT 3
45051: PPUSH
45052: CALL_OW 12
45056: PUSH
45057: LD_INT 0
45059: PPUSH
45060: LD_INT 3
45062: PPUSH
45063: CALL_OW 12
45067: PUSH
45068: LD_INT 0
45070: PUSH
45071: LD_INT 0
45073: PUSH
45074: EMPTY
45075: LIST
45076: LIST
45077: LIST
45078: LIST
45079: ST_TO_ADDR
// end ;
45080: LD_VAR 0 1
45084: RET
// export function PrepareApeman ( agressivity ) ; begin
45085: LD_INT 0
45087: PPUSH
// uc_side := 0 ;
45088: LD_ADDR_OWVAR 20
45092: PUSH
45093: LD_INT 0
45095: ST_TO_ADDR
// uc_nation := 0 ;
45096: LD_ADDR_OWVAR 21
45100: PUSH
45101: LD_INT 0
45103: ST_TO_ADDR
// hc_sex := sex_male ;
45104: LD_ADDR_OWVAR 27
45108: PUSH
45109: LD_INT 1
45111: ST_TO_ADDR
// hc_class := class_apeman ;
45112: LD_ADDR_OWVAR 28
45116: PUSH
45117: LD_INT 12
45119: ST_TO_ADDR
// hc_gallery :=  ;
45120: LD_ADDR_OWVAR 33
45124: PUSH
45125: LD_STRING 
45127: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
45128: LD_ADDR_OWVAR 35
45132: PUSH
45133: LD_VAR 0 1
45137: NEG
45138: PPUSH
45139: LD_VAR 0 1
45143: PPUSH
45144: CALL_OW 12
45148: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
45149: LD_ADDR_OWVAR 31
45153: PUSH
45154: LD_INT 0
45156: PPUSH
45157: LD_INT 3
45159: PPUSH
45160: CALL_OW 12
45164: PUSH
45165: LD_INT 0
45167: PPUSH
45168: LD_INT 3
45170: PPUSH
45171: CALL_OW 12
45175: PUSH
45176: LD_INT 0
45178: PUSH
45179: LD_INT 0
45181: PUSH
45182: EMPTY
45183: LIST
45184: LIST
45185: LIST
45186: LIST
45187: ST_TO_ADDR
// end ;
45188: LD_VAR 0 2
45192: RET
// export function PrepareTiger ( agressivity ) ; begin
45193: LD_INT 0
45195: PPUSH
// uc_side := 0 ;
45196: LD_ADDR_OWVAR 20
45200: PUSH
45201: LD_INT 0
45203: ST_TO_ADDR
// uc_nation := 0 ;
45204: LD_ADDR_OWVAR 21
45208: PUSH
45209: LD_INT 0
45211: ST_TO_ADDR
// hc_class := class_tiger ;
45212: LD_ADDR_OWVAR 28
45216: PUSH
45217: LD_INT 14
45219: ST_TO_ADDR
// hc_gallery :=  ;
45220: LD_ADDR_OWVAR 33
45224: PUSH
45225: LD_STRING 
45227: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
45228: LD_ADDR_OWVAR 35
45232: PUSH
45233: LD_VAR 0 1
45237: NEG
45238: PPUSH
45239: LD_VAR 0 1
45243: PPUSH
45244: CALL_OW 12
45248: ST_TO_ADDR
// end ;
45249: LD_VAR 0 2
45253: RET
// export function PrepareEnchidna ( ) ; begin
45254: LD_INT 0
45256: PPUSH
// uc_side := 0 ;
45257: LD_ADDR_OWVAR 20
45261: PUSH
45262: LD_INT 0
45264: ST_TO_ADDR
// uc_nation := 0 ;
45265: LD_ADDR_OWVAR 21
45269: PUSH
45270: LD_INT 0
45272: ST_TO_ADDR
// hc_class := class_baggie ;
45273: LD_ADDR_OWVAR 28
45277: PUSH
45278: LD_INT 13
45280: ST_TO_ADDR
// hc_gallery :=  ;
45281: LD_ADDR_OWVAR 33
45285: PUSH
45286: LD_STRING 
45288: ST_TO_ADDR
// end ;
45289: LD_VAR 0 1
45293: RET
// export function PrepareFrog ( ) ; begin
45294: LD_INT 0
45296: PPUSH
// uc_side := 0 ;
45297: LD_ADDR_OWVAR 20
45301: PUSH
45302: LD_INT 0
45304: ST_TO_ADDR
// uc_nation := 0 ;
45305: LD_ADDR_OWVAR 21
45309: PUSH
45310: LD_INT 0
45312: ST_TO_ADDR
// hc_class := class_frog ;
45313: LD_ADDR_OWVAR 28
45317: PUSH
45318: LD_INT 19
45320: ST_TO_ADDR
// hc_gallery :=  ;
45321: LD_ADDR_OWVAR 33
45325: PUSH
45326: LD_STRING 
45328: ST_TO_ADDR
// end ;
45329: LD_VAR 0 1
45333: RET
// export function PrepareFish ( ) ; begin
45334: LD_INT 0
45336: PPUSH
// uc_side := 0 ;
45337: LD_ADDR_OWVAR 20
45341: PUSH
45342: LD_INT 0
45344: ST_TO_ADDR
// uc_nation := 0 ;
45345: LD_ADDR_OWVAR 21
45349: PUSH
45350: LD_INT 0
45352: ST_TO_ADDR
// hc_class := class_fish ;
45353: LD_ADDR_OWVAR 28
45357: PUSH
45358: LD_INT 20
45360: ST_TO_ADDR
// hc_gallery :=  ;
45361: LD_ADDR_OWVAR 33
45365: PUSH
45366: LD_STRING 
45368: ST_TO_ADDR
// end ;
45369: LD_VAR 0 1
45373: RET
// export function PrepareBird ( ) ; begin
45374: LD_INT 0
45376: PPUSH
// uc_side := 0 ;
45377: LD_ADDR_OWVAR 20
45381: PUSH
45382: LD_INT 0
45384: ST_TO_ADDR
// uc_nation := 0 ;
45385: LD_ADDR_OWVAR 21
45389: PUSH
45390: LD_INT 0
45392: ST_TO_ADDR
// hc_class := class_phororhacos ;
45393: LD_ADDR_OWVAR 28
45397: PUSH
45398: LD_INT 18
45400: ST_TO_ADDR
// hc_gallery :=  ;
45401: LD_ADDR_OWVAR 33
45405: PUSH
45406: LD_STRING 
45408: ST_TO_ADDR
// end ;
45409: LD_VAR 0 1
45413: RET
// export function PrepareHorse ( ) ; begin
45414: LD_INT 0
45416: PPUSH
// uc_side := 0 ;
45417: LD_ADDR_OWVAR 20
45421: PUSH
45422: LD_INT 0
45424: ST_TO_ADDR
// uc_nation := 0 ;
45425: LD_ADDR_OWVAR 21
45429: PUSH
45430: LD_INT 0
45432: ST_TO_ADDR
// hc_class := class_horse ;
45433: LD_ADDR_OWVAR 28
45437: PUSH
45438: LD_INT 21
45440: ST_TO_ADDR
// hc_gallery :=  ;
45441: LD_ADDR_OWVAR 33
45445: PUSH
45446: LD_STRING 
45448: ST_TO_ADDR
// end ;
45449: LD_VAR 0 1
45453: RET
// export function PrepareMastodont ( ) ; begin
45454: LD_INT 0
45456: PPUSH
// uc_side := 0 ;
45457: LD_ADDR_OWVAR 20
45461: PUSH
45462: LD_INT 0
45464: ST_TO_ADDR
// uc_nation := 0 ;
45465: LD_ADDR_OWVAR 21
45469: PUSH
45470: LD_INT 0
45472: ST_TO_ADDR
// vc_chassis := class_mastodont ;
45473: LD_ADDR_OWVAR 37
45477: PUSH
45478: LD_INT 31
45480: ST_TO_ADDR
// vc_control := control_rider ;
45481: LD_ADDR_OWVAR 38
45485: PUSH
45486: LD_INT 4
45488: ST_TO_ADDR
// end ;
45489: LD_VAR 0 1
45493: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
45494: LD_INT 0
45496: PPUSH
45497: PPUSH
45498: PPUSH
// uc_side = 0 ;
45499: LD_ADDR_OWVAR 20
45503: PUSH
45504: LD_INT 0
45506: ST_TO_ADDR
// uc_nation = 0 ;
45507: LD_ADDR_OWVAR 21
45511: PUSH
45512: LD_INT 0
45514: ST_TO_ADDR
// InitHc_All ( ) ;
45515: CALL_OW 584
// InitVc ;
45519: CALL_OW 20
// if mastodonts then
45523: LD_VAR 0 6
45527: IFFALSE 45594
// for i = 1 to mastodonts do
45529: LD_ADDR_VAR 0 11
45533: PUSH
45534: DOUBLE
45535: LD_INT 1
45537: DEC
45538: ST_TO_ADDR
45539: LD_VAR 0 6
45543: PUSH
45544: FOR_TO
45545: IFFALSE 45592
// begin vc_chassis := 31 ;
45547: LD_ADDR_OWVAR 37
45551: PUSH
45552: LD_INT 31
45554: ST_TO_ADDR
// vc_control := control_rider ;
45555: LD_ADDR_OWVAR 38
45559: PUSH
45560: LD_INT 4
45562: ST_TO_ADDR
// animal := CreateVehicle ;
45563: LD_ADDR_VAR 0 12
45567: PUSH
45568: CALL_OW 45
45572: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45573: LD_VAR 0 12
45577: PPUSH
45578: LD_VAR 0 8
45582: PPUSH
45583: LD_INT 0
45585: PPUSH
45586: CALL 47722 0 3
// end ;
45590: GO 45544
45592: POP
45593: POP
// if horses then
45594: LD_VAR 0 5
45598: IFFALSE 45665
// for i = 1 to horses do
45600: LD_ADDR_VAR 0 11
45604: PUSH
45605: DOUBLE
45606: LD_INT 1
45608: DEC
45609: ST_TO_ADDR
45610: LD_VAR 0 5
45614: PUSH
45615: FOR_TO
45616: IFFALSE 45663
// begin hc_class := 21 ;
45618: LD_ADDR_OWVAR 28
45622: PUSH
45623: LD_INT 21
45625: ST_TO_ADDR
// hc_gallery :=  ;
45626: LD_ADDR_OWVAR 33
45630: PUSH
45631: LD_STRING 
45633: ST_TO_ADDR
// animal := CreateHuman ;
45634: LD_ADDR_VAR 0 12
45638: PUSH
45639: CALL_OW 44
45643: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45644: LD_VAR 0 12
45648: PPUSH
45649: LD_VAR 0 8
45653: PPUSH
45654: LD_INT 0
45656: PPUSH
45657: CALL 47722 0 3
// end ;
45661: GO 45615
45663: POP
45664: POP
// if birds then
45665: LD_VAR 0 1
45669: IFFALSE 45736
// for i = 1 to birds do
45671: LD_ADDR_VAR 0 11
45675: PUSH
45676: DOUBLE
45677: LD_INT 1
45679: DEC
45680: ST_TO_ADDR
45681: LD_VAR 0 1
45685: PUSH
45686: FOR_TO
45687: IFFALSE 45734
// begin hc_class := 18 ;
45689: LD_ADDR_OWVAR 28
45693: PUSH
45694: LD_INT 18
45696: ST_TO_ADDR
// hc_gallery =  ;
45697: LD_ADDR_OWVAR 33
45701: PUSH
45702: LD_STRING 
45704: ST_TO_ADDR
// animal := CreateHuman ;
45705: LD_ADDR_VAR 0 12
45709: PUSH
45710: CALL_OW 44
45714: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45715: LD_VAR 0 12
45719: PPUSH
45720: LD_VAR 0 8
45724: PPUSH
45725: LD_INT 0
45727: PPUSH
45728: CALL 47722 0 3
// end ;
45732: GO 45686
45734: POP
45735: POP
// if tigers then
45736: LD_VAR 0 2
45740: IFFALSE 45824
// for i = 1 to tigers do
45742: LD_ADDR_VAR 0 11
45746: PUSH
45747: DOUBLE
45748: LD_INT 1
45750: DEC
45751: ST_TO_ADDR
45752: LD_VAR 0 2
45756: PUSH
45757: FOR_TO
45758: IFFALSE 45822
// begin hc_class = class_tiger ;
45760: LD_ADDR_OWVAR 28
45764: PUSH
45765: LD_INT 14
45767: ST_TO_ADDR
// hc_gallery =  ;
45768: LD_ADDR_OWVAR 33
45772: PUSH
45773: LD_STRING 
45775: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
45776: LD_ADDR_OWVAR 35
45780: PUSH
45781: LD_INT 7
45783: NEG
45784: PPUSH
45785: LD_INT 7
45787: PPUSH
45788: CALL_OW 12
45792: ST_TO_ADDR
// animal := CreateHuman ;
45793: LD_ADDR_VAR 0 12
45797: PUSH
45798: CALL_OW 44
45802: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45803: LD_VAR 0 12
45807: PPUSH
45808: LD_VAR 0 8
45812: PPUSH
45813: LD_INT 0
45815: PPUSH
45816: CALL 47722 0 3
// end ;
45820: GO 45757
45822: POP
45823: POP
// if apemans then
45824: LD_VAR 0 3
45828: IFFALSE 45951
// for i = 1 to apemans do
45830: LD_ADDR_VAR 0 11
45834: PUSH
45835: DOUBLE
45836: LD_INT 1
45838: DEC
45839: ST_TO_ADDR
45840: LD_VAR 0 3
45844: PUSH
45845: FOR_TO
45846: IFFALSE 45949
// begin hc_class = class_apeman ;
45848: LD_ADDR_OWVAR 28
45852: PUSH
45853: LD_INT 12
45855: ST_TO_ADDR
// hc_gallery =  ;
45856: LD_ADDR_OWVAR 33
45860: PUSH
45861: LD_STRING 
45863: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
45864: LD_ADDR_OWVAR 35
45868: PUSH
45869: LD_INT 2
45871: NEG
45872: PPUSH
45873: LD_INT 2
45875: PPUSH
45876: CALL_OW 12
45880: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
45881: LD_ADDR_OWVAR 31
45885: PUSH
45886: LD_INT 1
45888: PPUSH
45889: LD_INT 3
45891: PPUSH
45892: CALL_OW 12
45896: PUSH
45897: LD_INT 1
45899: PPUSH
45900: LD_INT 3
45902: PPUSH
45903: CALL_OW 12
45907: PUSH
45908: LD_INT 0
45910: PUSH
45911: LD_INT 0
45913: PUSH
45914: EMPTY
45915: LIST
45916: LIST
45917: LIST
45918: LIST
45919: ST_TO_ADDR
// animal := CreateHuman ;
45920: LD_ADDR_VAR 0 12
45924: PUSH
45925: CALL_OW 44
45929: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45930: LD_VAR 0 12
45934: PPUSH
45935: LD_VAR 0 8
45939: PPUSH
45940: LD_INT 0
45942: PPUSH
45943: CALL 47722 0 3
// end ;
45947: GO 45845
45949: POP
45950: POP
// if enchidnas then
45951: LD_VAR 0 4
45955: IFFALSE 46022
// for i = 1 to enchidnas do
45957: LD_ADDR_VAR 0 11
45961: PUSH
45962: DOUBLE
45963: LD_INT 1
45965: DEC
45966: ST_TO_ADDR
45967: LD_VAR 0 4
45971: PUSH
45972: FOR_TO
45973: IFFALSE 46020
// begin hc_class = 13 ;
45975: LD_ADDR_OWVAR 28
45979: PUSH
45980: LD_INT 13
45982: ST_TO_ADDR
// hc_gallery =  ;
45983: LD_ADDR_OWVAR 33
45987: PUSH
45988: LD_STRING 
45990: ST_TO_ADDR
// animal := CreateHuman ;
45991: LD_ADDR_VAR 0 12
45995: PUSH
45996: CALL_OW 44
46000: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46001: LD_VAR 0 12
46005: PPUSH
46006: LD_VAR 0 8
46010: PPUSH
46011: LD_INT 0
46013: PPUSH
46014: CALL 47722 0 3
// end ;
46018: GO 45972
46020: POP
46021: POP
// if fishes then
46022: LD_VAR 0 7
46026: IFFALSE 46093
// for i = 1 to fishes do
46028: LD_ADDR_VAR 0 11
46032: PUSH
46033: DOUBLE
46034: LD_INT 1
46036: DEC
46037: ST_TO_ADDR
46038: LD_VAR 0 7
46042: PUSH
46043: FOR_TO
46044: IFFALSE 46091
// begin hc_class = 20 ;
46046: LD_ADDR_OWVAR 28
46050: PUSH
46051: LD_INT 20
46053: ST_TO_ADDR
// hc_gallery =  ;
46054: LD_ADDR_OWVAR 33
46058: PUSH
46059: LD_STRING 
46061: ST_TO_ADDR
// animal := CreateHuman ;
46062: LD_ADDR_VAR 0 12
46066: PUSH
46067: CALL_OW 44
46071: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
46072: LD_VAR 0 12
46076: PPUSH
46077: LD_VAR 0 9
46081: PPUSH
46082: LD_INT 0
46084: PPUSH
46085: CALL 47722 0 3
// end ;
46089: GO 46043
46091: POP
46092: POP
// end ;
46093: LD_VAR 0 10
46097: RET
// export function WantHeal ( sci , unit ) ; begin
46098: LD_INT 0
46100: PPUSH
// if GetTaskList ( sci ) > 0 then
46101: LD_VAR 0 1
46105: PPUSH
46106: CALL_OW 437
46110: PUSH
46111: LD_INT 0
46113: GREATER
46114: IFFALSE 46184
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
46116: LD_VAR 0 1
46120: PPUSH
46121: CALL_OW 437
46125: PUSH
46126: LD_INT 1
46128: ARRAY
46129: PUSH
46130: LD_INT 1
46132: ARRAY
46133: PUSH
46134: LD_STRING l
46136: EQUAL
46137: PUSH
46138: LD_VAR 0 1
46142: PPUSH
46143: CALL_OW 437
46147: PUSH
46148: LD_INT 1
46150: ARRAY
46151: PUSH
46152: LD_INT 4
46154: ARRAY
46155: PUSH
46156: LD_VAR 0 2
46160: EQUAL
46161: AND
46162: IFFALSE 46174
// result := true else
46164: LD_ADDR_VAR 0 3
46168: PUSH
46169: LD_INT 1
46171: ST_TO_ADDR
46172: GO 46182
// result := false ;
46174: LD_ADDR_VAR 0 3
46178: PUSH
46179: LD_INT 0
46181: ST_TO_ADDR
// end else
46182: GO 46192
// result := false ;
46184: LD_ADDR_VAR 0 3
46188: PUSH
46189: LD_INT 0
46191: ST_TO_ADDR
// end ;
46192: LD_VAR 0 3
46196: RET
// export function HealTarget ( sci ) ; begin
46197: LD_INT 0
46199: PPUSH
// if not sci then
46200: LD_VAR 0 1
46204: NOT
46205: IFFALSE 46209
// exit ;
46207: GO 46274
// result := 0 ;
46209: LD_ADDR_VAR 0 2
46213: PUSH
46214: LD_INT 0
46216: ST_TO_ADDR
// if GetTaskList ( sci ) then
46217: LD_VAR 0 1
46221: PPUSH
46222: CALL_OW 437
46226: IFFALSE 46274
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
46228: LD_VAR 0 1
46232: PPUSH
46233: CALL_OW 437
46237: PUSH
46238: LD_INT 1
46240: ARRAY
46241: PUSH
46242: LD_INT 1
46244: ARRAY
46245: PUSH
46246: LD_STRING l
46248: EQUAL
46249: IFFALSE 46274
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
46251: LD_ADDR_VAR 0 2
46255: PUSH
46256: LD_VAR 0 1
46260: PPUSH
46261: CALL_OW 437
46265: PUSH
46266: LD_INT 1
46268: ARRAY
46269: PUSH
46270: LD_INT 4
46272: ARRAY
46273: ST_TO_ADDR
// end ;
46274: LD_VAR 0 2
46278: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
46279: LD_INT 0
46281: PPUSH
46282: PPUSH
46283: PPUSH
46284: PPUSH
// if not base_units then
46285: LD_VAR 0 1
46289: NOT
46290: IFFALSE 46294
// exit ;
46292: GO 46381
// result := false ;
46294: LD_ADDR_VAR 0 2
46298: PUSH
46299: LD_INT 0
46301: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
46302: LD_ADDR_VAR 0 5
46306: PUSH
46307: LD_VAR 0 1
46311: PPUSH
46312: LD_INT 21
46314: PUSH
46315: LD_INT 3
46317: PUSH
46318: EMPTY
46319: LIST
46320: LIST
46321: PPUSH
46322: CALL_OW 72
46326: ST_TO_ADDR
// if not tmp then
46327: LD_VAR 0 5
46331: NOT
46332: IFFALSE 46336
// exit ;
46334: GO 46381
// for i in tmp do
46336: LD_ADDR_VAR 0 3
46340: PUSH
46341: LD_VAR 0 5
46345: PUSH
46346: FOR_IN
46347: IFFALSE 46379
// begin result := EnemyInRange ( i , 22 ) ;
46349: LD_ADDR_VAR 0 2
46353: PUSH
46354: LD_VAR 0 3
46358: PPUSH
46359: LD_INT 22
46361: PPUSH
46362: CALL 43968 0 2
46366: ST_TO_ADDR
// if result then
46367: LD_VAR 0 2
46371: IFFALSE 46377
// exit ;
46373: POP
46374: POP
46375: GO 46381
// end ;
46377: GO 46346
46379: POP
46380: POP
// end ;
46381: LD_VAR 0 2
46385: RET
// export function FilterByTag ( units , tag ) ; begin
46386: LD_INT 0
46388: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
46389: LD_ADDR_VAR 0 3
46393: PUSH
46394: LD_VAR 0 1
46398: PPUSH
46399: LD_INT 120
46401: PUSH
46402: LD_VAR 0 2
46406: PUSH
46407: EMPTY
46408: LIST
46409: LIST
46410: PPUSH
46411: CALL_OW 72
46415: ST_TO_ADDR
// end ;
46416: LD_VAR 0 3
46420: RET
// export function IsDriver ( un ) ; begin
46421: LD_INT 0
46423: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
46424: LD_ADDR_VAR 0 2
46428: PUSH
46429: LD_VAR 0 1
46433: PUSH
46434: LD_INT 55
46436: PUSH
46437: EMPTY
46438: LIST
46439: PPUSH
46440: CALL_OW 69
46444: IN
46445: ST_TO_ADDR
// end ;
46446: LD_VAR 0 2
46450: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
46451: LD_INT 0
46453: PPUSH
46454: PPUSH
// list := [ ] ;
46455: LD_ADDR_VAR 0 5
46459: PUSH
46460: EMPTY
46461: ST_TO_ADDR
// case d of 0 :
46462: LD_VAR 0 3
46466: PUSH
46467: LD_INT 0
46469: DOUBLE
46470: EQUAL
46471: IFTRUE 46475
46473: GO 46608
46475: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
46476: LD_ADDR_VAR 0 5
46480: PUSH
46481: LD_VAR 0 1
46485: PUSH
46486: LD_INT 4
46488: MINUS
46489: PUSH
46490: LD_VAR 0 2
46494: PUSH
46495: LD_INT 4
46497: MINUS
46498: PUSH
46499: LD_INT 2
46501: PUSH
46502: EMPTY
46503: LIST
46504: LIST
46505: LIST
46506: PUSH
46507: LD_VAR 0 1
46511: PUSH
46512: LD_INT 3
46514: MINUS
46515: PUSH
46516: LD_VAR 0 2
46520: PUSH
46521: LD_INT 1
46523: PUSH
46524: EMPTY
46525: LIST
46526: LIST
46527: LIST
46528: PUSH
46529: LD_VAR 0 1
46533: PUSH
46534: LD_INT 4
46536: PLUS
46537: PUSH
46538: LD_VAR 0 2
46542: PUSH
46543: LD_INT 4
46545: PUSH
46546: EMPTY
46547: LIST
46548: LIST
46549: LIST
46550: PUSH
46551: LD_VAR 0 1
46555: PUSH
46556: LD_INT 3
46558: PLUS
46559: PUSH
46560: LD_VAR 0 2
46564: PUSH
46565: LD_INT 3
46567: PLUS
46568: PUSH
46569: LD_INT 5
46571: PUSH
46572: EMPTY
46573: LIST
46574: LIST
46575: LIST
46576: PUSH
46577: LD_VAR 0 1
46581: PUSH
46582: LD_VAR 0 2
46586: PUSH
46587: LD_INT 4
46589: PLUS
46590: PUSH
46591: LD_INT 0
46593: PUSH
46594: EMPTY
46595: LIST
46596: LIST
46597: LIST
46598: PUSH
46599: EMPTY
46600: LIST
46601: LIST
46602: LIST
46603: LIST
46604: LIST
46605: ST_TO_ADDR
// end ; 1 :
46606: GO 47306
46608: LD_INT 1
46610: DOUBLE
46611: EQUAL
46612: IFTRUE 46616
46614: GO 46749
46616: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
46617: LD_ADDR_VAR 0 5
46621: PUSH
46622: LD_VAR 0 1
46626: PUSH
46627: LD_VAR 0 2
46631: PUSH
46632: LD_INT 4
46634: MINUS
46635: PUSH
46636: LD_INT 3
46638: PUSH
46639: EMPTY
46640: LIST
46641: LIST
46642: LIST
46643: PUSH
46644: LD_VAR 0 1
46648: PUSH
46649: LD_INT 3
46651: MINUS
46652: PUSH
46653: LD_VAR 0 2
46657: PUSH
46658: LD_INT 3
46660: MINUS
46661: PUSH
46662: LD_INT 2
46664: PUSH
46665: EMPTY
46666: LIST
46667: LIST
46668: LIST
46669: PUSH
46670: LD_VAR 0 1
46674: PUSH
46675: LD_INT 4
46677: MINUS
46678: PUSH
46679: LD_VAR 0 2
46683: PUSH
46684: LD_INT 1
46686: PUSH
46687: EMPTY
46688: LIST
46689: LIST
46690: LIST
46691: PUSH
46692: LD_VAR 0 1
46696: PUSH
46697: LD_VAR 0 2
46701: PUSH
46702: LD_INT 3
46704: PLUS
46705: PUSH
46706: LD_INT 0
46708: PUSH
46709: EMPTY
46710: LIST
46711: LIST
46712: LIST
46713: PUSH
46714: LD_VAR 0 1
46718: PUSH
46719: LD_INT 4
46721: PLUS
46722: PUSH
46723: LD_VAR 0 2
46727: PUSH
46728: LD_INT 4
46730: PLUS
46731: PUSH
46732: LD_INT 5
46734: PUSH
46735: EMPTY
46736: LIST
46737: LIST
46738: LIST
46739: PUSH
46740: EMPTY
46741: LIST
46742: LIST
46743: LIST
46744: LIST
46745: LIST
46746: ST_TO_ADDR
// end ; 2 :
46747: GO 47306
46749: LD_INT 2
46751: DOUBLE
46752: EQUAL
46753: IFTRUE 46757
46755: GO 46886
46757: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
46758: LD_ADDR_VAR 0 5
46762: PUSH
46763: LD_VAR 0 1
46767: PUSH
46768: LD_VAR 0 2
46772: PUSH
46773: LD_INT 3
46775: MINUS
46776: PUSH
46777: LD_INT 3
46779: PUSH
46780: EMPTY
46781: LIST
46782: LIST
46783: LIST
46784: PUSH
46785: LD_VAR 0 1
46789: PUSH
46790: LD_INT 4
46792: PLUS
46793: PUSH
46794: LD_VAR 0 2
46798: PUSH
46799: LD_INT 4
46801: PUSH
46802: EMPTY
46803: LIST
46804: LIST
46805: LIST
46806: PUSH
46807: LD_VAR 0 1
46811: PUSH
46812: LD_VAR 0 2
46816: PUSH
46817: LD_INT 4
46819: PLUS
46820: PUSH
46821: LD_INT 0
46823: PUSH
46824: EMPTY
46825: LIST
46826: LIST
46827: LIST
46828: PUSH
46829: LD_VAR 0 1
46833: PUSH
46834: LD_INT 3
46836: MINUS
46837: PUSH
46838: LD_VAR 0 2
46842: PUSH
46843: LD_INT 1
46845: PUSH
46846: EMPTY
46847: LIST
46848: LIST
46849: LIST
46850: PUSH
46851: LD_VAR 0 1
46855: PUSH
46856: LD_INT 4
46858: MINUS
46859: PUSH
46860: LD_VAR 0 2
46864: PUSH
46865: LD_INT 4
46867: MINUS
46868: PUSH
46869: LD_INT 2
46871: PUSH
46872: EMPTY
46873: LIST
46874: LIST
46875: LIST
46876: PUSH
46877: EMPTY
46878: LIST
46879: LIST
46880: LIST
46881: LIST
46882: LIST
46883: ST_TO_ADDR
// end ; 3 :
46884: GO 47306
46886: LD_INT 3
46888: DOUBLE
46889: EQUAL
46890: IFTRUE 46894
46892: GO 47027
46894: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
46895: LD_ADDR_VAR 0 5
46899: PUSH
46900: LD_VAR 0 1
46904: PUSH
46905: LD_INT 3
46907: PLUS
46908: PUSH
46909: LD_VAR 0 2
46913: PUSH
46914: LD_INT 4
46916: PUSH
46917: EMPTY
46918: LIST
46919: LIST
46920: LIST
46921: PUSH
46922: LD_VAR 0 1
46926: PUSH
46927: LD_INT 4
46929: PLUS
46930: PUSH
46931: LD_VAR 0 2
46935: PUSH
46936: LD_INT 4
46938: PLUS
46939: PUSH
46940: LD_INT 5
46942: PUSH
46943: EMPTY
46944: LIST
46945: LIST
46946: LIST
46947: PUSH
46948: LD_VAR 0 1
46952: PUSH
46953: LD_INT 4
46955: MINUS
46956: PUSH
46957: LD_VAR 0 2
46961: PUSH
46962: LD_INT 1
46964: PUSH
46965: EMPTY
46966: LIST
46967: LIST
46968: LIST
46969: PUSH
46970: LD_VAR 0 1
46974: PUSH
46975: LD_VAR 0 2
46979: PUSH
46980: LD_INT 4
46982: MINUS
46983: PUSH
46984: LD_INT 3
46986: PUSH
46987: EMPTY
46988: LIST
46989: LIST
46990: LIST
46991: PUSH
46992: LD_VAR 0 1
46996: PUSH
46997: LD_INT 3
46999: MINUS
47000: PUSH
47001: LD_VAR 0 2
47005: PUSH
47006: LD_INT 3
47008: MINUS
47009: PUSH
47010: LD_INT 2
47012: PUSH
47013: EMPTY
47014: LIST
47015: LIST
47016: LIST
47017: PUSH
47018: EMPTY
47019: LIST
47020: LIST
47021: LIST
47022: LIST
47023: LIST
47024: ST_TO_ADDR
// end ; 4 :
47025: GO 47306
47027: LD_INT 4
47029: DOUBLE
47030: EQUAL
47031: IFTRUE 47035
47033: GO 47168
47035: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
47036: LD_ADDR_VAR 0 5
47040: PUSH
47041: LD_VAR 0 1
47045: PUSH
47046: LD_VAR 0 2
47050: PUSH
47051: LD_INT 4
47053: PLUS
47054: PUSH
47055: LD_INT 0
47057: PUSH
47058: EMPTY
47059: LIST
47060: LIST
47061: LIST
47062: PUSH
47063: LD_VAR 0 1
47067: PUSH
47068: LD_INT 3
47070: PLUS
47071: PUSH
47072: LD_VAR 0 2
47076: PUSH
47077: LD_INT 3
47079: PLUS
47080: PUSH
47081: LD_INT 5
47083: PUSH
47084: EMPTY
47085: LIST
47086: LIST
47087: LIST
47088: PUSH
47089: LD_VAR 0 1
47093: PUSH
47094: LD_INT 4
47096: PLUS
47097: PUSH
47098: LD_VAR 0 2
47102: PUSH
47103: LD_INT 4
47105: PUSH
47106: EMPTY
47107: LIST
47108: LIST
47109: LIST
47110: PUSH
47111: LD_VAR 0 1
47115: PUSH
47116: LD_VAR 0 2
47120: PUSH
47121: LD_INT 3
47123: MINUS
47124: PUSH
47125: LD_INT 3
47127: PUSH
47128: EMPTY
47129: LIST
47130: LIST
47131: LIST
47132: PUSH
47133: LD_VAR 0 1
47137: PUSH
47138: LD_INT 4
47140: MINUS
47141: PUSH
47142: LD_VAR 0 2
47146: PUSH
47147: LD_INT 4
47149: MINUS
47150: PUSH
47151: LD_INT 2
47153: PUSH
47154: EMPTY
47155: LIST
47156: LIST
47157: LIST
47158: PUSH
47159: EMPTY
47160: LIST
47161: LIST
47162: LIST
47163: LIST
47164: LIST
47165: ST_TO_ADDR
// end ; 5 :
47166: GO 47306
47168: LD_INT 5
47170: DOUBLE
47171: EQUAL
47172: IFTRUE 47176
47174: GO 47305
47176: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
47177: LD_ADDR_VAR 0 5
47181: PUSH
47182: LD_VAR 0 1
47186: PUSH
47187: LD_INT 4
47189: MINUS
47190: PUSH
47191: LD_VAR 0 2
47195: PUSH
47196: LD_INT 1
47198: PUSH
47199: EMPTY
47200: LIST
47201: LIST
47202: LIST
47203: PUSH
47204: LD_VAR 0 1
47208: PUSH
47209: LD_VAR 0 2
47213: PUSH
47214: LD_INT 4
47216: MINUS
47217: PUSH
47218: LD_INT 3
47220: PUSH
47221: EMPTY
47222: LIST
47223: LIST
47224: LIST
47225: PUSH
47226: LD_VAR 0 1
47230: PUSH
47231: LD_INT 4
47233: PLUS
47234: PUSH
47235: LD_VAR 0 2
47239: PUSH
47240: LD_INT 4
47242: PLUS
47243: PUSH
47244: LD_INT 5
47246: PUSH
47247: EMPTY
47248: LIST
47249: LIST
47250: LIST
47251: PUSH
47252: LD_VAR 0 1
47256: PUSH
47257: LD_INT 3
47259: PLUS
47260: PUSH
47261: LD_VAR 0 2
47265: PUSH
47266: LD_INT 4
47268: PUSH
47269: EMPTY
47270: LIST
47271: LIST
47272: LIST
47273: PUSH
47274: LD_VAR 0 1
47278: PUSH
47279: LD_VAR 0 2
47283: PUSH
47284: LD_INT 3
47286: PLUS
47287: PUSH
47288: LD_INT 0
47290: PUSH
47291: EMPTY
47292: LIST
47293: LIST
47294: LIST
47295: PUSH
47296: EMPTY
47297: LIST
47298: LIST
47299: LIST
47300: LIST
47301: LIST
47302: ST_TO_ADDR
// end ; end ;
47303: GO 47306
47305: POP
// result := list ;
47306: LD_ADDR_VAR 0 4
47310: PUSH
47311: LD_VAR 0 5
47315: ST_TO_ADDR
// end ;
47316: LD_VAR 0 4
47320: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
47321: LD_INT 0
47323: PPUSH
47324: PPUSH
47325: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
47326: LD_VAR 0 1
47330: NOT
47331: PUSH
47332: LD_VAR 0 2
47336: PUSH
47337: LD_INT 1
47339: PUSH
47340: LD_INT 2
47342: PUSH
47343: LD_INT 3
47345: PUSH
47346: LD_INT 4
47348: PUSH
47349: EMPTY
47350: LIST
47351: LIST
47352: LIST
47353: LIST
47354: IN
47355: NOT
47356: OR
47357: IFFALSE 47361
// exit ;
47359: GO 47444
// tmp := [ ] ;
47361: LD_ADDR_VAR 0 5
47365: PUSH
47366: EMPTY
47367: ST_TO_ADDR
// for i in units do
47368: LD_ADDR_VAR 0 4
47372: PUSH
47373: LD_VAR 0 1
47377: PUSH
47378: FOR_IN
47379: IFFALSE 47413
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
47381: LD_ADDR_VAR 0 5
47385: PUSH
47386: LD_VAR 0 5
47390: PPUSH
47391: LD_VAR 0 4
47395: PPUSH
47396: LD_VAR 0 2
47400: PPUSH
47401: CALL_OW 259
47405: PPUSH
47406: CALL 48817 0 2
47410: ST_TO_ADDR
47411: GO 47378
47413: POP
47414: POP
// if not tmp then
47415: LD_VAR 0 5
47419: NOT
47420: IFFALSE 47424
// exit ;
47422: GO 47444
// result := SortListByListDesc ( units , tmp ) ;
47424: LD_ADDR_VAR 0 3
47428: PUSH
47429: LD_VAR 0 1
47433: PPUSH
47434: LD_VAR 0 5
47438: PPUSH
47439: CALL_OW 77
47443: ST_TO_ADDR
// end ;
47444: LD_VAR 0 3
47448: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
47449: LD_INT 0
47451: PPUSH
47452: PPUSH
47453: PPUSH
// result := false ;
47454: LD_ADDR_VAR 0 3
47458: PUSH
47459: LD_INT 0
47461: ST_TO_ADDR
// if not building then
47462: LD_VAR 0 2
47466: NOT
47467: IFFALSE 47471
// exit ;
47469: GO 47609
// x := GetX ( building ) ;
47471: LD_ADDR_VAR 0 4
47475: PUSH
47476: LD_VAR 0 2
47480: PPUSH
47481: CALL_OW 250
47485: ST_TO_ADDR
// y := GetY ( building ) ;
47486: LD_ADDR_VAR 0 5
47490: PUSH
47491: LD_VAR 0 2
47495: PPUSH
47496: CALL_OW 251
47500: ST_TO_ADDR
// if not x or not y then
47501: LD_VAR 0 4
47505: NOT
47506: PUSH
47507: LD_VAR 0 5
47511: NOT
47512: OR
47513: IFFALSE 47517
// exit ;
47515: GO 47609
// if GetTaskList ( unit ) then
47517: LD_VAR 0 1
47521: PPUSH
47522: CALL_OW 437
47526: IFFALSE 47609
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
47528: LD_STRING e
47530: PUSH
47531: LD_VAR 0 1
47535: PPUSH
47536: CALL_OW 437
47540: PUSH
47541: LD_INT 1
47543: ARRAY
47544: PUSH
47545: LD_INT 1
47547: ARRAY
47548: EQUAL
47549: PUSH
47550: LD_VAR 0 4
47554: PUSH
47555: LD_VAR 0 1
47559: PPUSH
47560: CALL_OW 437
47564: PUSH
47565: LD_INT 1
47567: ARRAY
47568: PUSH
47569: LD_INT 2
47571: ARRAY
47572: EQUAL
47573: AND
47574: PUSH
47575: LD_VAR 0 5
47579: PUSH
47580: LD_VAR 0 1
47584: PPUSH
47585: CALL_OW 437
47589: PUSH
47590: LD_INT 1
47592: ARRAY
47593: PUSH
47594: LD_INT 3
47596: ARRAY
47597: EQUAL
47598: AND
47599: IFFALSE 47609
// result := true end ;
47601: LD_ADDR_VAR 0 3
47605: PUSH
47606: LD_INT 1
47608: ST_TO_ADDR
// end ;
47609: LD_VAR 0 3
47613: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
47614: LD_INT 0
47616: PPUSH
// result := false ;
47617: LD_ADDR_VAR 0 4
47621: PUSH
47622: LD_INT 0
47624: ST_TO_ADDR
// if GetTaskList ( unit ) then
47625: LD_VAR 0 1
47629: PPUSH
47630: CALL_OW 437
47634: IFFALSE 47717
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
47636: LD_STRING M
47638: PUSH
47639: LD_VAR 0 1
47643: PPUSH
47644: CALL_OW 437
47648: PUSH
47649: LD_INT 1
47651: ARRAY
47652: PUSH
47653: LD_INT 1
47655: ARRAY
47656: EQUAL
47657: PUSH
47658: LD_VAR 0 2
47662: PUSH
47663: LD_VAR 0 1
47667: PPUSH
47668: CALL_OW 437
47672: PUSH
47673: LD_INT 1
47675: ARRAY
47676: PUSH
47677: LD_INT 2
47679: ARRAY
47680: EQUAL
47681: AND
47682: PUSH
47683: LD_VAR 0 3
47687: PUSH
47688: LD_VAR 0 1
47692: PPUSH
47693: CALL_OW 437
47697: PUSH
47698: LD_INT 1
47700: ARRAY
47701: PUSH
47702: LD_INT 3
47704: ARRAY
47705: EQUAL
47706: AND
47707: IFFALSE 47717
// result := true ;
47709: LD_ADDR_VAR 0 4
47713: PUSH
47714: LD_INT 1
47716: ST_TO_ADDR
// end ; end ;
47717: LD_VAR 0 4
47721: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
47722: LD_INT 0
47724: PPUSH
47725: PPUSH
47726: PPUSH
47727: PPUSH
// if not unit or not area then
47728: LD_VAR 0 1
47732: NOT
47733: PUSH
47734: LD_VAR 0 2
47738: NOT
47739: OR
47740: IFFALSE 47744
// exit ;
47742: GO 47920
// tmp := AreaToList ( area , i ) ;
47744: LD_ADDR_VAR 0 6
47748: PUSH
47749: LD_VAR 0 2
47753: PPUSH
47754: LD_VAR 0 5
47758: PPUSH
47759: CALL_OW 517
47763: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
47764: LD_ADDR_VAR 0 5
47768: PUSH
47769: DOUBLE
47770: LD_INT 1
47772: DEC
47773: ST_TO_ADDR
47774: LD_VAR 0 6
47778: PUSH
47779: LD_INT 1
47781: ARRAY
47782: PUSH
47783: FOR_TO
47784: IFFALSE 47918
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
47786: LD_ADDR_VAR 0 7
47790: PUSH
47791: LD_VAR 0 6
47795: PUSH
47796: LD_INT 1
47798: ARRAY
47799: PUSH
47800: LD_VAR 0 5
47804: ARRAY
47805: PUSH
47806: LD_VAR 0 6
47810: PUSH
47811: LD_INT 2
47813: ARRAY
47814: PUSH
47815: LD_VAR 0 5
47819: ARRAY
47820: PUSH
47821: EMPTY
47822: LIST
47823: LIST
47824: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
47825: LD_INT 92
47827: PUSH
47828: LD_VAR 0 7
47832: PUSH
47833: LD_INT 1
47835: ARRAY
47836: PUSH
47837: LD_VAR 0 7
47841: PUSH
47842: LD_INT 2
47844: ARRAY
47845: PUSH
47846: LD_INT 2
47848: PUSH
47849: EMPTY
47850: LIST
47851: LIST
47852: LIST
47853: LIST
47854: PPUSH
47855: CALL_OW 69
47859: PUSH
47860: LD_INT 0
47862: EQUAL
47863: IFFALSE 47916
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
47865: LD_VAR 0 1
47869: PPUSH
47870: LD_VAR 0 7
47874: PUSH
47875: LD_INT 1
47877: ARRAY
47878: PPUSH
47879: LD_VAR 0 7
47883: PUSH
47884: LD_INT 2
47886: ARRAY
47887: PPUSH
47888: LD_VAR 0 3
47892: PPUSH
47893: CALL_OW 48
// result := IsPlaced ( unit ) ;
47897: LD_ADDR_VAR 0 4
47901: PUSH
47902: LD_VAR 0 1
47906: PPUSH
47907: CALL_OW 305
47911: ST_TO_ADDR
// exit ;
47912: POP
47913: POP
47914: GO 47920
// end ; end ;
47916: GO 47783
47918: POP
47919: POP
// end ;
47920: LD_VAR 0 4
47924: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
47925: LD_INT 0
47927: PPUSH
47928: PPUSH
47929: PPUSH
// if not side or side > 8 then
47930: LD_VAR 0 1
47934: NOT
47935: PUSH
47936: LD_VAR 0 1
47940: PUSH
47941: LD_INT 8
47943: GREATER
47944: OR
47945: IFFALSE 47949
// exit ;
47947: GO 48136
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
47949: LD_ADDR_VAR 0 4
47953: PUSH
47954: LD_INT 22
47956: PUSH
47957: LD_VAR 0 1
47961: PUSH
47962: EMPTY
47963: LIST
47964: LIST
47965: PUSH
47966: LD_INT 21
47968: PUSH
47969: LD_INT 3
47971: PUSH
47972: EMPTY
47973: LIST
47974: LIST
47975: PUSH
47976: EMPTY
47977: LIST
47978: LIST
47979: PPUSH
47980: CALL_OW 69
47984: ST_TO_ADDR
// if not tmp then
47985: LD_VAR 0 4
47989: NOT
47990: IFFALSE 47994
// exit ;
47992: GO 48136
// enable_addtolog := true ;
47994: LD_ADDR_OWVAR 81
47998: PUSH
47999: LD_INT 1
48001: ST_TO_ADDR
// AddToLog ( [ ) ;
48002: LD_STRING [
48004: PPUSH
48005: CALL_OW 561
// for i in tmp do
48009: LD_ADDR_VAR 0 3
48013: PUSH
48014: LD_VAR 0 4
48018: PUSH
48019: FOR_IN
48020: IFFALSE 48127
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
48022: LD_STRING [
48024: PUSH
48025: LD_VAR 0 3
48029: PPUSH
48030: CALL_OW 266
48034: STR
48035: PUSH
48036: LD_STRING , 
48038: STR
48039: PUSH
48040: LD_VAR 0 3
48044: PPUSH
48045: CALL_OW 250
48049: STR
48050: PUSH
48051: LD_STRING , 
48053: STR
48054: PUSH
48055: LD_VAR 0 3
48059: PPUSH
48060: CALL_OW 251
48064: STR
48065: PUSH
48066: LD_STRING , 
48068: STR
48069: PUSH
48070: LD_VAR 0 3
48074: PPUSH
48075: CALL_OW 254
48079: STR
48080: PUSH
48081: LD_STRING , 
48083: STR
48084: PUSH
48085: LD_VAR 0 3
48089: PPUSH
48090: LD_INT 1
48092: PPUSH
48093: CALL_OW 268
48097: STR
48098: PUSH
48099: LD_STRING , 
48101: STR
48102: PUSH
48103: LD_VAR 0 3
48107: PPUSH
48108: LD_INT 2
48110: PPUSH
48111: CALL_OW 268
48115: STR
48116: PUSH
48117: LD_STRING ],
48119: STR
48120: PPUSH
48121: CALL_OW 561
// end ;
48125: GO 48019
48127: POP
48128: POP
// AddToLog ( ]; ) ;
48129: LD_STRING ];
48131: PPUSH
48132: CALL_OW 561
// end ;
48136: LD_VAR 0 2
48140: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
48141: LD_INT 0
48143: PPUSH
48144: PPUSH
48145: PPUSH
48146: PPUSH
48147: PPUSH
// if not area or not rate or not max then
48148: LD_VAR 0 1
48152: NOT
48153: PUSH
48154: LD_VAR 0 2
48158: NOT
48159: OR
48160: PUSH
48161: LD_VAR 0 4
48165: NOT
48166: OR
48167: IFFALSE 48171
// exit ;
48169: GO 48360
// while 1 do
48171: LD_INT 1
48173: IFFALSE 48360
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
48175: LD_ADDR_VAR 0 9
48179: PUSH
48180: LD_VAR 0 1
48184: PPUSH
48185: LD_INT 1
48187: PPUSH
48188: CALL_OW 287
48192: PUSH
48193: LD_INT 10
48195: MUL
48196: ST_TO_ADDR
// r := rate / 10 ;
48197: LD_ADDR_VAR 0 7
48201: PUSH
48202: LD_VAR 0 2
48206: PUSH
48207: LD_INT 10
48209: DIVREAL
48210: ST_TO_ADDR
// time := 1 1$00 ;
48211: LD_ADDR_VAR 0 8
48215: PUSH
48216: LD_INT 2100
48218: ST_TO_ADDR
// if amount < min then
48219: LD_VAR 0 9
48223: PUSH
48224: LD_VAR 0 3
48228: LESS
48229: IFFALSE 48247
// r := r * 2 else
48231: LD_ADDR_VAR 0 7
48235: PUSH
48236: LD_VAR 0 7
48240: PUSH
48241: LD_INT 2
48243: MUL
48244: ST_TO_ADDR
48245: GO 48273
// if amount > max then
48247: LD_VAR 0 9
48251: PUSH
48252: LD_VAR 0 4
48256: GREATER
48257: IFFALSE 48273
// r := r / 2 ;
48259: LD_ADDR_VAR 0 7
48263: PUSH
48264: LD_VAR 0 7
48268: PUSH
48269: LD_INT 2
48271: DIVREAL
48272: ST_TO_ADDR
// time := time / r ;
48273: LD_ADDR_VAR 0 8
48277: PUSH
48278: LD_VAR 0 8
48282: PUSH
48283: LD_VAR 0 7
48287: DIVREAL
48288: ST_TO_ADDR
// if time < 0 then
48289: LD_VAR 0 8
48293: PUSH
48294: LD_INT 0
48296: LESS
48297: IFFALSE 48314
// time := time * - 1 ;
48299: LD_ADDR_VAR 0 8
48303: PUSH
48304: LD_VAR 0 8
48308: PUSH
48309: LD_INT 1
48311: NEG
48312: MUL
48313: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
48314: LD_VAR 0 8
48318: PUSH
48319: LD_INT 35
48321: PPUSH
48322: LD_INT 875
48324: PPUSH
48325: CALL_OW 12
48329: PLUS
48330: PPUSH
48331: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
48335: LD_INT 1
48337: PPUSH
48338: LD_INT 5
48340: PPUSH
48341: CALL_OW 12
48345: PPUSH
48346: LD_VAR 0 1
48350: PPUSH
48351: LD_INT 1
48353: PPUSH
48354: CALL_OW 55
// end ;
48358: GO 48171
// end ;
48360: LD_VAR 0 5
48364: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
48365: LD_INT 0
48367: PPUSH
48368: PPUSH
48369: PPUSH
48370: PPUSH
48371: PPUSH
48372: PPUSH
48373: PPUSH
48374: PPUSH
// if not turrets or not factories then
48375: LD_VAR 0 1
48379: NOT
48380: PUSH
48381: LD_VAR 0 2
48385: NOT
48386: OR
48387: IFFALSE 48391
// exit ;
48389: GO 48698
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
48391: LD_ADDR_VAR 0 10
48395: PUSH
48396: LD_INT 5
48398: PUSH
48399: LD_INT 6
48401: PUSH
48402: EMPTY
48403: LIST
48404: LIST
48405: PUSH
48406: LD_INT 2
48408: PUSH
48409: LD_INT 4
48411: PUSH
48412: EMPTY
48413: LIST
48414: LIST
48415: PUSH
48416: LD_INT 3
48418: PUSH
48419: LD_INT 5
48421: PUSH
48422: EMPTY
48423: LIST
48424: LIST
48425: PUSH
48426: EMPTY
48427: LIST
48428: LIST
48429: LIST
48430: PUSH
48431: LD_INT 24
48433: PUSH
48434: LD_INT 25
48436: PUSH
48437: EMPTY
48438: LIST
48439: LIST
48440: PUSH
48441: LD_INT 23
48443: PUSH
48444: LD_INT 27
48446: PUSH
48447: EMPTY
48448: LIST
48449: LIST
48450: PUSH
48451: EMPTY
48452: LIST
48453: LIST
48454: PUSH
48455: LD_INT 42
48457: PUSH
48458: LD_INT 43
48460: PUSH
48461: EMPTY
48462: LIST
48463: LIST
48464: PUSH
48465: LD_INT 44
48467: PUSH
48468: LD_INT 46
48470: PUSH
48471: EMPTY
48472: LIST
48473: LIST
48474: PUSH
48475: LD_INT 45
48477: PUSH
48478: LD_INT 47
48480: PUSH
48481: EMPTY
48482: LIST
48483: LIST
48484: PUSH
48485: EMPTY
48486: LIST
48487: LIST
48488: LIST
48489: PUSH
48490: EMPTY
48491: LIST
48492: LIST
48493: LIST
48494: ST_TO_ADDR
// result := [ ] ;
48495: LD_ADDR_VAR 0 3
48499: PUSH
48500: EMPTY
48501: ST_TO_ADDR
// for i in turrets do
48502: LD_ADDR_VAR 0 4
48506: PUSH
48507: LD_VAR 0 1
48511: PUSH
48512: FOR_IN
48513: IFFALSE 48696
// begin nat := GetNation ( i ) ;
48515: LD_ADDR_VAR 0 7
48519: PUSH
48520: LD_VAR 0 4
48524: PPUSH
48525: CALL_OW 248
48529: ST_TO_ADDR
// weapon := 0 ;
48530: LD_ADDR_VAR 0 8
48534: PUSH
48535: LD_INT 0
48537: ST_TO_ADDR
// if not nat then
48538: LD_VAR 0 7
48542: NOT
48543: IFFALSE 48547
// continue ;
48545: GO 48512
// for j in list [ nat ] do
48547: LD_ADDR_VAR 0 5
48551: PUSH
48552: LD_VAR 0 10
48556: PUSH
48557: LD_VAR 0 7
48561: ARRAY
48562: PUSH
48563: FOR_IN
48564: IFFALSE 48605
// if GetBWeapon ( i ) = j [ 1 ] then
48566: LD_VAR 0 4
48570: PPUSH
48571: CALL_OW 269
48575: PUSH
48576: LD_VAR 0 5
48580: PUSH
48581: LD_INT 1
48583: ARRAY
48584: EQUAL
48585: IFFALSE 48603
// begin weapon := j [ 2 ] ;
48587: LD_ADDR_VAR 0 8
48591: PUSH
48592: LD_VAR 0 5
48596: PUSH
48597: LD_INT 2
48599: ARRAY
48600: ST_TO_ADDR
// break ;
48601: GO 48605
// end ;
48603: GO 48563
48605: POP
48606: POP
// if not weapon then
48607: LD_VAR 0 8
48611: NOT
48612: IFFALSE 48616
// continue ;
48614: GO 48512
// for k in factories do
48616: LD_ADDR_VAR 0 6
48620: PUSH
48621: LD_VAR 0 2
48625: PUSH
48626: FOR_IN
48627: IFFALSE 48692
// begin weapons := AvailableWeaponList ( k ) ;
48629: LD_ADDR_VAR 0 9
48633: PUSH
48634: LD_VAR 0 6
48638: PPUSH
48639: CALL_OW 478
48643: ST_TO_ADDR
// if not weapons then
48644: LD_VAR 0 9
48648: NOT
48649: IFFALSE 48653
// continue ;
48651: GO 48626
// if weapon in weapons then
48653: LD_VAR 0 8
48657: PUSH
48658: LD_VAR 0 9
48662: IN
48663: IFFALSE 48690
// begin result := [ i , weapon ] ;
48665: LD_ADDR_VAR 0 3
48669: PUSH
48670: LD_VAR 0 4
48674: PUSH
48675: LD_VAR 0 8
48679: PUSH
48680: EMPTY
48681: LIST
48682: LIST
48683: ST_TO_ADDR
// exit ;
48684: POP
48685: POP
48686: POP
48687: POP
48688: GO 48698
// end ; end ;
48690: GO 48626
48692: POP
48693: POP
// end ;
48694: GO 48512
48696: POP
48697: POP
// end ;
48698: LD_VAR 0 3
48702: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
48703: LD_INT 0
48705: PPUSH
// if not side or side > 8 then
48706: LD_VAR 0 3
48710: NOT
48711: PUSH
48712: LD_VAR 0 3
48716: PUSH
48717: LD_INT 8
48719: GREATER
48720: OR
48721: IFFALSE 48725
// exit ;
48723: GO 48784
// if not range then
48725: LD_VAR 0 4
48729: NOT
48730: IFFALSE 48741
// range := - 12 ;
48732: LD_ADDR_VAR 0 4
48736: PUSH
48737: LD_INT 12
48739: NEG
48740: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
48741: LD_VAR 0 1
48745: PPUSH
48746: LD_VAR 0 2
48750: PPUSH
48751: LD_VAR 0 3
48755: PPUSH
48756: LD_VAR 0 4
48760: PPUSH
48761: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
48765: LD_VAR 0 1
48769: PPUSH
48770: LD_VAR 0 2
48774: PPUSH
48775: LD_VAR 0 3
48779: PPUSH
48780: CALL_OW 331
// end ;
48784: LD_VAR 0 5
48788: RET
// export function Video ( mode ) ; begin
48789: LD_INT 0
48791: PPUSH
// ingame_video = mode ;
48792: LD_ADDR_OWVAR 52
48796: PUSH
48797: LD_VAR 0 1
48801: ST_TO_ADDR
// interface_hidden = mode ;
48802: LD_ADDR_OWVAR 54
48806: PUSH
48807: LD_VAR 0 1
48811: ST_TO_ADDR
// end ;
48812: LD_VAR 0 2
48816: RET
// export function Join ( array , element ) ; begin
48817: LD_INT 0
48819: PPUSH
// result := Replace ( array , array + 1 , element ) ;
48820: LD_ADDR_VAR 0 3
48824: PUSH
48825: LD_VAR 0 1
48829: PPUSH
48830: LD_VAR 0 1
48834: PUSH
48835: LD_INT 1
48837: PLUS
48838: PPUSH
48839: LD_VAR 0 2
48843: PPUSH
48844: CALL_OW 1
48848: ST_TO_ADDR
// end ;
48849: LD_VAR 0 3
48853: RET
// export function JoinUnion ( array , element ) ; begin
48854: LD_INT 0
48856: PPUSH
// result := array union element ;
48857: LD_ADDR_VAR 0 3
48861: PUSH
48862: LD_VAR 0 1
48866: PUSH
48867: LD_VAR 0 2
48871: UNION
48872: ST_TO_ADDR
// end ;
48873: LD_VAR 0 3
48877: RET
// export function GetBehemoths ( side ) ; begin
48878: LD_INT 0
48880: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
48881: LD_ADDR_VAR 0 2
48885: PUSH
48886: LD_INT 22
48888: PUSH
48889: LD_VAR 0 1
48893: PUSH
48894: EMPTY
48895: LIST
48896: LIST
48897: PUSH
48898: LD_INT 31
48900: PUSH
48901: LD_INT 25
48903: PUSH
48904: EMPTY
48905: LIST
48906: LIST
48907: PUSH
48908: EMPTY
48909: LIST
48910: LIST
48911: PPUSH
48912: CALL_OW 69
48916: ST_TO_ADDR
// end ;
48917: LD_VAR 0 2
48921: RET
// export function Shuffle ( array ) ; var i , index ; begin
48922: LD_INT 0
48924: PPUSH
48925: PPUSH
48926: PPUSH
// result := [ ] ;
48927: LD_ADDR_VAR 0 2
48931: PUSH
48932: EMPTY
48933: ST_TO_ADDR
// if not array then
48934: LD_VAR 0 1
48938: NOT
48939: IFFALSE 48943
// exit ;
48941: GO 49042
// Randomize ;
48943: CALL_OW 10
// for i = array downto 1 do
48947: LD_ADDR_VAR 0 3
48951: PUSH
48952: DOUBLE
48953: LD_VAR 0 1
48957: INC
48958: ST_TO_ADDR
48959: LD_INT 1
48961: PUSH
48962: FOR_DOWNTO
48963: IFFALSE 49040
// begin index := rand ( 1 , array ) ;
48965: LD_ADDR_VAR 0 4
48969: PUSH
48970: LD_INT 1
48972: PPUSH
48973: LD_VAR 0 1
48977: PPUSH
48978: CALL_OW 12
48982: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
48983: LD_ADDR_VAR 0 2
48987: PUSH
48988: LD_VAR 0 2
48992: PPUSH
48993: LD_VAR 0 2
48997: PUSH
48998: LD_INT 1
49000: PLUS
49001: PPUSH
49002: LD_VAR 0 1
49006: PUSH
49007: LD_VAR 0 4
49011: ARRAY
49012: PPUSH
49013: CALL_OW 2
49017: ST_TO_ADDR
// array := Delete ( array , index ) ;
49018: LD_ADDR_VAR 0 1
49022: PUSH
49023: LD_VAR 0 1
49027: PPUSH
49028: LD_VAR 0 4
49032: PPUSH
49033: CALL_OW 3
49037: ST_TO_ADDR
// end ;
49038: GO 48962
49040: POP
49041: POP
// end ;
49042: LD_VAR 0 2
49046: RET
// export function GetBaseMaterials ( base ) ; begin
49047: LD_INT 0
49049: PPUSH
// result := [ 0 , 0 , 0 ] ;
49050: LD_ADDR_VAR 0 2
49054: PUSH
49055: LD_INT 0
49057: PUSH
49058: LD_INT 0
49060: PUSH
49061: LD_INT 0
49063: PUSH
49064: EMPTY
49065: LIST
49066: LIST
49067: LIST
49068: ST_TO_ADDR
// if not base then
49069: LD_VAR 0 1
49073: NOT
49074: IFFALSE 49078
// exit ;
49076: GO 49127
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
49078: LD_ADDR_VAR 0 2
49082: PUSH
49083: LD_VAR 0 1
49087: PPUSH
49088: LD_INT 1
49090: PPUSH
49091: CALL_OW 275
49095: PUSH
49096: LD_VAR 0 1
49100: PPUSH
49101: LD_INT 2
49103: PPUSH
49104: CALL_OW 275
49108: PUSH
49109: LD_VAR 0 1
49113: PPUSH
49114: LD_INT 3
49116: PPUSH
49117: CALL_OW 275
49121: PUSH
49122: EMPTY
49123: LIST
49124: LIST
49125: LIST
49126: ST_TO_ADDR
// end ;
49127: LD_VAR 0 2
49131: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
49132: LD_INT 0
49134: PPUSH
49135: PPUSH
// result := array ;
49136: LD_ADDR_VAR 0 3
49140: PUSH
49141: LD_VAR 0 1
49145: ST_TO_ADDR
// if size >= result then
49146: LD_VAR 0 2
49150: PUSH
49151: LD_VAR 0 3
49155: GREATEREQUAL
49156: IFFALSE 49160
// exit ;
49158: GO 49210
// if size then
49160: LD_VAR 0 2
49164: IFFALSE 49210
// for i := array downto size do
49166: LD_ADDR_VAR 0 4
49170: PUSH
49171: DOUBLE
49172: LD_VAR 0 1
49176: INC
49177: ST_TO_ADDR
49178: LD_VAR 0 2
49182: PUSH
49183: FOR_DOWNTO
49184: IFFALSE 49208
// result := Delete ( result , result ) ;
49186: LD_ADDR_VAR 0 3
49190: PUSH
49191: LD_VAR 0 3
49195: PPUSH
49196: LD_VAR 0 3
49200: PPUSH
49201: CALL_OW 3
49205: ST_TO_ADDR
49206: GO 49183
49208: POP
49209: POP
// end ;
49210: LD_VAR 0 3
49214: RET
// export function ComExit ( unit ) ; var tmp ; begin
49215: LD_INT 0
49217: PPUSH
49218: PPUSH
// if not IsInUnit ( unit ) then
49219: LD_VAR 0 1
49223: PPUSH
49224: CALL_OW 310
49228: NOT
49229: IFFALSE 49233
// exit ;
49231: GO 49293
// tmp := IsInUnit ( unit ) ;
49233: LD_ADDR_VAR 0 3
49237: PUSH
49238: LD_VAR 0 1
49242: PPUSH
49243: CALL_OW 310
49247: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
49248: LD_VAR 0 3
49252: PPUSH
49253: CALL_OW 247
49257: PUSH
49258: LD_INT 2
49260: EQUAL
49261: IFFALSE 49274
// ComExitVehicle ( unit ) else
49263: LD_VAR 0 1
49267: PPUSH
49268: CALL_OW 121
49272: GO 49283
// ComExitBuilding ( unit ) ;
49274: LD_VAR 0 1
49278: PPUSH
49279: CALL_OW 122
// result := tmp ;
49283: LD_ADDR_VAR 0 2
49287: PUSH
49288: LD_VAR 0 3
49292: ST_TO_ADDR
// end ;
49293: LD_VAR 0 2
49297: RET
// export function ComExitAll ( units ) ; var i ; begin
49298: LD_INT 0
49300: PPUSH
49301: PPUSH
// if not units then
49302: LD_VAR 0 1
49306: NOT
49307: IFFALSE 49311
// exit ;
49309: GO 49337
// for i in units do
49311: LD_ADDR_VAR 0 3
49315: PUSH
49316: LD_VAR 0 1
49320: PUSH
49321: FOR_IN
49322: IFFALSE 49335
// ComExit ( i ) ;
49324: LD_VAR 0 3
49328: PPUSH
49329: CALL 49215 0 1
49333: GO 49321
49335: POP
49336: POP
// end ;
49337: LD_VAR 0 2
49341: RET
// export function ResetHc ; begin
49342: LD_INT 0
49344: PPUSH
// InitHc ;
49345: CALL_OW 19
// hc_importance := 0 ;
49349: LD_ADDR_OWVAR 32
49353: PUSH
49354: LD_INT 0
49356: ST_TO_ADDR
// end ;
49357: LD_VAR 0 1
49361: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
49362: LD_INT 0
49364: PPUSH
49365: PPUSH
49366: PPUSH
// _x := ( x1 + x2 ) div 2 ;
49367: LD_ADDR_VAR 0 6
49371: PUSH
49372: LD_VAR 0 1
49376: PUSH
49377: LD_VAR 0 3
49381: PLUS
49382: PUSH
49383: LD_INT 2
49385: DIV
49386: ST_TO_ADDR
// if _x < 0 then
49387: LD_VAR 0 6
49391: PUSH
49392: LD_INT 0
49394: LESS
49395: IFFALSE 49412
// _x := _x * - 1 ;
49397: LD_ADDR_VAR 0 6
49401: PUSH
49402: LD_VAR 0 6
49406: PUSH
49407: LD_INT 1
49409: NEG
49410: MUL
49411: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
49412: LD_ADDR_VAR 0 7
49416: PUSH
49417: LD_VAR 0 2
49421: PUSH
49422: LD_VAR 0 4
49426: PLUS
49427: PUSH
49428: LD_INT 2
49430: DIV
49431: ST_TO_ADDR
// if _y < 0 then
49432: LD_VAR 0 7
49436: PUSH
49437: LD_INT 0
49439: LESS
49440: IFFALSE 49457
// _y := _y * - 1 ;
49442: LD_ADDR_VAR 0 7
49446: PUSH
49447: LD_VAR 0 7
49451: PUSH
49452: LD_INT 1
49454: NEG
49455: MUL
49456: ST_TO_ADDR
// result := [ _x , _y ] ;
49457: LD_ADDR_VAR 0 5
49461: PUSH
49462: LD_VAR 0 6
49466: PUSH
49467: LD_VAR 0 7
49471: PUSH
49472: EMPTY
49473: LIST
49474: LIST
49475: ST_TO_ADDR
// end ;
49476: LD_VAR 0 5
49480: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
49481: LD_INT 0
49483: PPUSH
49484: PPUSH
49485: PPUSH
49486: PPUSH
// task := GetTaskList ( unit ) ;
49487: LD_ADDR_VAR 0 7
49491: PUSH
49492: LD_VAR 0 1
49496: PPUSH
49497: CALL_OW 437
49501: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
49502: LD_VAR 0 7
49506: NOT
49507: PUSH
49508: LD_VAR 0 1
49512: PPUSH
49513: LD_VAR 0 2
49517: PPUSH
49518: CALL_OW 308
49522: NOT
49523: AND
49524: IFFALSE 49528
// exit ;
49526: GO 49646
// if IsInArea ( unit , area ) then
49528: LD_VAR 0 1
49532: PPUSH
49533: LD_VAR 0 2
49537: PPUSH
49538: CALL_OW 308
49542: IFFALSE 49560
// begin ComMoveToArea ( unit , goAway ) ;
49544: LD_VAR 0 1
49548: PPUSH
49549: LD_VAR 0 3
49553: PPUSH
49554: CALL_OW 113
// exit ;
49558: GO 49646
// end ; if task [ 1 ] [ 1 ] <> M then
49560: LD_VAR 0 7
49564: PUSH
49565: LD_INT 1
49567: ARRAY
49568: PUSH
49569: LD_INT 1
49571: ARRAY
49572: PUSH
49573: LD_STRING M
49575: NONEQUAL
49576: IFFALSE 49580
// exit ;
49578: GO 49646
// x := task [ 1 ] [ 2 ] ;
49580: LD_ADDR_VAR 0 5
49584: PUSH
49585: LD_VAR 0 7
49589: PUSH
49590: LD_INT 1
49592: ARRAY
49593: PUSH
49594: LD_INT 2
49596: ARRAY
49597: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
49598: LD_ADDR_VAR 0 6
49602: PUSH
49603: LD_VAR 0 7
49607: PUSH
49608: LD_INT 1
49610: ARRAY
49611: PUSH
49612: LD_INT 3
49614: ARRAY
49615: ST_TO_ADDR
// if InArea ( x , y , area ) then
49616: LD_VAR 0 5
49620: PPUSH
49621: LD_VAR 0 6
49625: PPUSH
49626: LD_VAR 0 2
49630: PPUSH
49631: CALL_OW 309
49635: IFFALSE 49646
// ComStop ( unit ) ;
49637: LD_VAR 0 1
49641: PPUSH
49642: CALL_OW 141
// end ;
49646: LD_VAR 0 4
49650: RET
// export function Abs ( value ) ; begin
49651: LD_INT 0
49653: PPUSH
// result := value ;
49654: LD_ADDR_VAR 0 2
49658: PUSH
49659: LD_VAR 0 1
49663: ST_TO_ADDR
// if value < 0 then
49664: LD_VAR 0 1
49668: PUSH
49669: LD_INT 0
49671: LESS
49672: IFFALSE 49689
// result := value * - 1 ;
49674: LD_ADDR_VAR 0 2
49678: PUSH
49679: LD_VAR 0 1
49683: PUSH
49684: LD_INT 1
49686: NEG
49687: MUL
49688: ST_TO_ADDR
// end ;
49689: LD_VAR 0 2
49693: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
49694: LD_INT 0
49696: PPUSH
49697: PPUSH
49698: PPUSH
49699: PPUSH
49700: PPUSH
49701: PPUSH
49702: PPUSH
49703: PPUSH
// if not unit or not building then
49704: LD_VAR 0 1
49708: NOT
49709: PUSH
49710: LD_VAR 0 2
49714: NOT
49715: OR
49716: IFFALSE 49720
// exit ;
49718: GO 49946
// x := GetX ( building ) ;
49720: LD_ADDR_VAR 0 4
49724: PUSH
49725: LD_VAR 0 2
49729: PPUSH
49730: CALL_OW 250
49734: ST_TO_ADDR
// y := GetY ( building ) ;
49735: LD_ADDR_VAR 0 6
49739: PUSH
49740: LD_VAR 0 2
49744: PPUSH
49745: CALL_OW 251
49749: ST_TO_ADDR
// d := GetDir ( building ) ;
49750: LD_ADDR_VAR 0 8
49754: PUSH
49755: LD_VAR 0 2
49759: PPUSH
49760: CALL_OW 254
49764: ST_TO_ADDR
// r := 4 ;
49765: LD_ADDR_VAR 0 9
49769: PUSH
49770: LD_INT 4
49772: ST_TO_ADDR
// for i := 1 to 5 do
49773: LD_ADDR_VAR 0 10
49777: PUSH
49778: DOUBLE
49779: LD_INT 1
49781: DEC
49782: ST_TO_ADDR
49783: LD_INT 5
49785: PUSH
49786: FOR_TO
49787: IFFALSE 49944
// begin _x := ShiftX ( x , d , r + i ) ;
49789: LD_ADDR_VAR 0 5
49793: PUSH
49794: LD_VAR 0 4
49798: PPUSH
49799: LD_VAR 0 8
49803: PPUSH
49804: LD_VAR 0 9
49808: PUSH
49809: LD_VAR 0 10
49813: PLUS
49814: PPUSH
49815: CALL_OW 272
49819: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
49820: LD_ADDR_VAR 0 7
49824: PUSH
49825: LD_VAR 0 6
49829: PPUSH
49830: LD_VAR 0 8
49834: PPUSH
49835: LD_VAR 0 9
49839: PUSH
49840: LD_VAR 0 10
49844: PLUS
49845: PPUSH
49846: CALL_OW 273
49850: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
49851: LD_VAR 0 5
49855: PPUSH
49856: LD_VAR 0 7
49860: PPUSH
49861: CALL_OW 488
49865: PUSH
49866: LD_VAR 0 5
49870: PPUSH
49871: LD_VAR 0 7
49875: PPUSH
49876: CALL_OW 428
49880: PPUSH
49881: CALL_OW 247
49885: PUSH
49886: LD_INT 3
49888: PUSH
49889: LD_INT 2
49891: PUSH
49892: EMPTY
49893: LIST
49894: LIST
49895: IN
49896: NOT
49897: AND
49898: IFFALSE 49942
// begin ComMoveXY ( unit , _x , _y ) ;
49900: LD_VAR 0 1
49904: PPUSH
49905: LD_VAR 0 5
49909: PPUSH
49910: LD_VAR 0 7
49914: PPUSH
49915: CALL_OW 111
// result := [ _x , _y ] ;
49919: LD_ADDR_VAR 0 3
49923: PUSH
49924: LD_VAR 0 5
49928: PUSH
49929: LD_VAR 0 7
49933: PUSH
49934: EMPTY
49935: LIST
49936: LIST
49937: ST_TO_ADDR
// exit ;
49938: POP
49939: POP
49940: GO 49946
// end ; end ;
49942: GO 49786
49944: POP
49945: POP
// end ;
49946: LD_VAR 0 3
49950: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
49951: LD_INT 0
49953: PPUSH
49954: PPUSH
49955: PPUSH
// result := 0 ;
49956: LD_ADDR_VAR 0 3
49960: PUSH
49961: LD_INT 0
49963: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
49964: LD_VAR 0 1
49968: PUSH
49969: LD_INT 0
49971: LESS
49972: PUSH
49973: LD_VAR 0 1
49977: PUSH
49978: LD_INT 8
49980: GREATER
49981: OR
49982: PUSH
49983: LD_VAR 0 2
49987: PUSH
49988: LD_INT 0
49990: LESS
49991: OR
49992: PUSH
49993: LD_VAR 0 2
49997: PUSH
49998: LD_INT 8
50000: GREATER
50001: OR
50002: IFFALSE 50006
// exit ;
50004: GO 50081
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
50006: LD_ADDR_VAR 0 4
50010: PUSH
50011: LD_INT 22
50013: PUSH
50014: LD_VAR 0 2
50018: PUSH
50019: EMPTY
50020: LIST
50021: LIST
50022: PPUSH
50023: CALL_OW 69
50027: PUSH
50028: FOR_IN
50029: IFFALSE 50079
// begin un := UnitShoot ( i ) ;
50031: LD_ADDR_VAR 0 5
50035: PUSH
50036: LD_VAR 0 4
50040: PPUSH
50041: CALL_OW 504
50045: ST_TO_ADDR
// if GetSide ( un ) = side1 then
50046: LD_VAR 0 5
50050: PPUSH
50051: CALL_OW 255
50055: PUSH
50056: LD_VAR 0 1
50060: EQUAL
50061: IFFALSE 50077
// begin result := un ;
50063: LD_ADDR_VAR 0 3
50067: PUSH
50068: LD_VAR 0 5
50072: ST_TO_ADDR
// exit ;
50073: POP
50074: POP
50075: GO 50081
// end ; end ;
50077: GO 50028
50079: POP
50080: POP
// end ;
50081: LD_VAR 0 3
50085: RET
// export function GetCargoBay ( units ) ; begin
50086: LD_INT 0
50088: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
50089: LD_ADDR_VAR 0 2
50093: PUSH
50094: LD_VAR 0 1
50098: PPUSH
50099: LD_INT 2
50101: PUSH
50102: LD_INT 34
50104: PUSH
50105: LD_INT 12
50107: PUSH
50108: EMPTY
50109: LIST
50110: LIST
50111: PUSH
50112: LD_INT 34
50114: PUSH
50115: LD_INT 51
50117: PUSH
50118: EMPTY
50119: LIST
50120: LIST
50121: PUSH
50122: LD_INT 34
50124: PUSH
50125: LD_INT 32
50127: PUSH
50128: EMPTY
50129: LIST
50130: LIST
50131: PUSH
50132: LD_INT 34
50134: PUSH
50135: LD_INT 89
50137: PUSH
50138: EMPTY
50139: LIST
50140: LIST
50141: PUSH
50142: EMPTY
50143: LIST
50144: LIST
50145: LIST
50146: LIST
50147: LIST
50148: PPUSH
50149: CALL_OW 72
50153: ST_TO_ADDR
// end ;
50154: LD_VAR 0 2
50158: RET
// export function Negate ( value ) ; begin
50159: LD_INT 0
50161: PPUSH
// result := not value ;
50162: LD_ADDR_VAR 0 2
50166: PUSH
50167: LD_VAR 0 1
50171: NOT
50172: ST_TO_ADDR
// end ;
50173: LD_VAR 0 2
50177: RET
// export function Inc ( value ) ; begin
50178: LD_INT 0
50180: PPUSH
// result := value + 1 ;
50181: LD_ADDR_VAR 0 2
50185: PUSH
50186: LD_VAR 0 1
50190: PUSH
50191: LD_INT 1
50193: PLUS
50194: ST_TO_ADDR
// end ;
50195: LD_VAR 0 2
50199: RET
// export function Dec ( value ) ; begin
50200: LD_INT 0
50202: PPUSH
// result := value - 1 ;
50203: LD_ADDR_VAR 0 2
50207: PUSH
50208: LD_VAR 0 1
50212: PUSH
50213: LD_INT 1
50215: MINUS
50216: ST_TO_ADDR
// end ;
50217: LD_VAR 0 2
50221: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
50222: LD_INT 0
50224: PPUSH
50225: PPUSH
50226: PPUSH
50227: PPUSH
50228: PPUSH
50229: PPUSH
50230: PPUSH
50231: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
50232: LD_VAR 0 1
50236: PPUSH
50237: LD_VAR 0 2
50241: PPUSH
50242: CALL_OW 488
50246: NOT
50247: PUSH
50248: LD_VAR 0 3
50252: PPUSH
50253: LD_VAR 0 4
50257: PPUSH
50258: CALL_OW 488
50262: NOT
50263: OR
50264: IFFALSE 50277
// begin result := - 1 ;
50266: LD_ADDR_VAR 0 5
50270: PUSH
50271: LD_INT 1
50273: NEG
50274: ST_TO_ADDR
// exit ;
50275: GO 50512
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
50277: LD_ADDR_VAR 0 12
50281: PUSH
50282: LD_VAR 0 1
50286: PPUSH
50287: LD_VAR 0 2
50291: PPUSH
50292: LD_VAR 0 3
50296: PPUSH
50297: LD_VAR 0 4
50301: PPUSH
50302: CALL 49362 0 4
50306: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
50307: LD_ADDR_VAR 0 11
50311: PUSH
50312: LD_VAR 0 1
50316: PPUSH
50317: LD_VAR 0 2
50321: PPUSH
50322: LD_VAR 0 12
50326: PUSH
50327: LD_INT 1
50329: ARRAY
50330: PPUSH
50331: LD_VAR 0 12
50335: PUSH
50336: LD_INT 2
50338: ARRAY
50339: PPUSH
50340: CALL_OW 298
50344: ST_TO_ADDR
// distance := 9999 ;
50345: LD_ADDR_VAR 0 10
50349: PUSH
50350: LD_INT 9999
50352: ST_TO_ADDR
// for i := 0 to 5 do
50353: LD_ADDR_VAR 0 6
50357: PUSH
50358: DOUBLE
50359: LD_INT 0
50361: DEC
50362: ST_TO_ADDR
50363: LD_INT 5
50365: PUSH
50366: FOR_TO
50367: IFFALSE 50510
// begin _x := ShiftX ( x1 , i , centerDist ) ;
50369: LD_ADDR_VAR 0 7
50373: PUSH
50374: LD_VAR 0 1
50378: PPUSH
50379: LD_VAR 0 6
50383: PPUSH
50384: LD_VAR 0 11
50388: PPUSH
50389: CALL_OW 272
50393: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
50394: LD_ADDR_VAR 0 8
50398: PUSH
50399: LD_VAR 0 2
50403: PPUSH
50404: LD_VAR 0 6
50408: PPUSH
50409: LD_VAR 0 11
50413: PPUSH
50414: CALL_OW 273
50418: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50419: LD_VAR 0 7
50423: PPUSH
50424: LD_VAR 0 8
50428: PPUSH
50429: CALL_OW 488
50433: NOT
50434: IFFALSE 50438
// continue ;
50436: GO 50366
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
50438: LD_ADDR_VAR 0 9
50442: PUSH
50443: LD_VAR 0 12
50447: PUSH
50448: LD_INT 1
50450: ARRAY
50451: PPUSH
50452: LD_VAR 0 12
50456: PUSH
50457: LD_INT 2
50459: ARRAY
50460: PPUSH
50461: LD_VAR 0 7
50465: PPUSH
50466: LD_VAR 0 8
50470: PPUSH
50471: CALL_OW 298
50475: ST_TO_ADDR
// if tmp < distance then
50476: LD_VAR 0 9
50480: PUSH
50481: LD_VAR 0 10
50485: LESS
50486: IFFALSE 50508
// begin result := i ;
50488: LD_ADDR_VAR 0 5
50492: PUSH
50493: LD_VAR 0 6
50497: ST_TO_ADDR
// distance := tmp ;
50498: LD_ADDR_VAR 0 10
50502: PUSH
50503: LD_VAR 0 9
50507: ST_TO_ADDR
// end ; end ;
50508: GO 50366
50510: POP
50511: POP
// end ;
50512: LD_VAR 0 5
50516: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
50517: LD_INT 0
50519: PPUSH
50520: PPUSH
// if not driver or not IsInUnit ( driver ) then
50521: LD_VAR 0 1
50525: NOT
50526: PUSH
50527: LD_VAR 0 1
50531: PPUSH
50532: CALL_OW 310
50536: NOT
50537: OR
50538: IFFALSE 50542
// exit ;
50540: GO 50632
// vehicle := IsInUnit ( driver ) ;
50542: LD_ADDR_VAR 0 3
50546: PUSH
50547: LD_VAR 0 1
50551: PPUSH
50552: CALL_OW 310
50556: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
50557: LD_VAR 0 1
50561: PPUSH
50562: LD_STRING \
50564: PUSH
50565: LD_INT 0
50567: PUSH
50568: LD_INT 0
50570: PUSH
50571: LD_INT 0
50573: PUSH
50574: LD_INT 0
50576: PUSH
50577: LD_INT 0
50579: PUSH
50580: LD_INT 0
50582: PUSH
50583: EMPTY
50584: LIST
50585: LIST
50586: LIST
50587: LIST
50588: LIST
50589: LIST
50590: LIST
50591: PUSH
50592: LD_STRING E
50594: PUSH
50595: LD_INT 0
50597: PUSH
50598: LD_INT 0
50600: PUSH
50601: LD_VAR 0 3
50605: PUSH
50606: LD_INT 0
50608: PUSH
50609: LD_INT 0
50611: PUSH
50612: LD_INT 0
50614: PUSH
50615: EMPTY
50616: LIST
50617: LIST
50618: LIST
50619: LIST
50620: LIST
50621: LIST
50622: LIST
50623: PUSH
50624: EMPTY
50625: LIST
50626: LIST
50627: PPUSH
50628: CALL_OW 446
// end ;
50632: LD_VAR 0 2
50636: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
50637: LD_INT 0
50639: PPUSH
50640: PPUSH
// if not driver or not IsInUnit ( driver ) then
50641: LD_VAR 0 1
50645: NOT
50646: PUSH
50647: LD_VAR 0 1
50651: PPUSH
50652: CALL_OW 310
50656: NOT
50657: OR
50658: IFFALSE 50662
// exit ;
50660: GO 50752
// vehicle := IsInUnit ( driver ) ;
50662: LD_ADDR_VAR 0 3
50666: PUSH
50667: LD_VAR 0 1
50671: PPUSH
50672: CALL_OW 310
50676: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
50677: LD_VAR 0 1
50681: PPUSH
50682: LD_STRING \
50684: PUSH
50685: LD_INT 0
50687: PUSH
50688: LD_INT 0
50690: PUSH
50691: LD_INT 0
50693: PUSH
50694: LD_INT 0
50696: PUSH
50697: LD_INT 0
50699: PUSH
50700: LD_INT 0
50702: PUSH
50703: EMPTY
50704: LIST
50705: LIST
50706: LIST
50707: LIST
50708: LIST
50709: LIST
50710: LIST
50711: PUSH
50712: LD_STRING E
50714: PUSH
50715: LD_INT 0
50717: PUSH
50718: LD_INT 0
50720: PUSH
50721: LD_VAR 0 3
50725: PUSH
50726: LD_INT 0
50728: PUSH
50729: LD_INT 0
50731: PUSH
50732: LD_INT 0
50734: PUSH
50735: EMPTY
50736: LIST
50737: LIST
50738: LIST
50739: LIST
50740: LIST
50741: LIST
50742: LIST
50743: PUSH
50744: EMPTY
50745: LIST
50746: LIST
50747: PPUSH
50748: CALL_OW 447
// end ;
50752: LD_VAR 0 2
50756: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
50757: LD_INT 0
50759: PPUSH
50760: PPUSH
50761: PPUSH
// tmp := [ ] ;
50762: LD_ADDR_VAR 0 5
50766: PUSH
50767: EMPTY
50768: ST_TO_ADDR
// for i in units do
50769: LD_ADDR_VAR 0 4
50773: PUSH
50774: LD_VAR 0 1
50778: PUSH
50779: FOR_IN
50780: IFFALSE 50818
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
50782: LD_ADDR_VAR 0 5
50786: PUSH
50787: LD_VAR 0 5
50791: PPUSH
50792: LD_VAR 0 5
50796: PUSH
50797: LD_INT 1
50799: PLUS
50800: PPUSH
50801: LD_VAR 0 4
50805: PPUSH
50806: CALL_OW 256
50810: PPUSH
50811: CALL_OW 2
50815: ST_TO_ADDR
50816: GO 50779
50818: POP
50819: POP
// if not tmp then
50820: LD_VAR 0 5
50824: NOT
50825: IFFALSE 50829
// exit ;
50827: GO 50877
// if asc then
50829: LD_VAR 0 2
50833: IFFALSE 50857
// result := SortListByListAsc ( units , tmp ) else
50835: LD_ADDR_VAR 0 3
50839: PUSH
50840: LD_VAR 0 1
50844: PPUSH
50845: LD_VAR 0 5
50849: PPUSH
50850: CALL_OW 76
50854: ST_TO_ADDR
50855: GO 50877
// result := SortListByListDesc ( units , tmp ) ;
50857: LD_ADDR_VAR 0 3
50861: PUSH
50862: LD_VAR 0 1
50866: PPUSH
50867: LD_VAR 0 5
50871: PPUSH
50872: CALL_OW 77
50876: ST_TO_ADDR
// end ;
50877: LD_VAR 0 3
50881: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
50882: LD_INT 0
50884: PPUSH
50885: PPUSH
// task := GetTaskList ( mech ) ;
50886: LD_ADDR_VAR 0 4
50890: PUSH
50891: LD_VAR 0 1
50895: PPUSH
50896: CALL_OW 437
50900: ST_TO_ADDR
// if not task then
50901: LD_VAR 0 4
50905: NOT
50906: IFFALSE 50910
// exit ;
50908: GO 50952
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
50910: LD_ADDR_VAR 0 3
50914: PUSH
50915: LD_VAR 0 4
50919: PUSH
50920: LD_INT 1
50922: ARRAY
50923: PUSH
50924: LD_INT 1
50926: ARRAY
50927: PUSH
50928: LD_STRING r
50930: EQUAL
50931: PUSH
50932: LD_VAR 0 4
50936: PUSH
50937: LD_INT 1
50939: ARRAY
50940: PUSH
50941: LD_INT 4
50943: ARRAY
50944: PUSH
50945: LD_VAR 0 2
50949: EQUAL
50950: AND
50951: ST_TO_ADDR
// end ;
50952: LD_VAR 0 3
50956: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
50957: LD_INT 0
50959: PPUSH
// SetDir ( unit , d ) ;
50960: LD_VAR 0 1
50964: PPUSH
50965: LD_VAR 0 4
50969: PPUSH
50970: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
50974: LD_VAR 0 1
50978: PPUSH
50979: LD_VAR 0 2
50983: PPUSH
50984: LD_VAR 0 3
50988: PPUSH
50989: LD_VAR 0 5
50993: PPUSH
50994: CALL_OW 48
// end ;
50998: LD_VAR 0 6
51002: RET
// export function ToNaturalNumber ( number ) ; begin
51003: LD_INT 0
51005: PPUSH
// result := number div 1 ;
51006: LD_ADDR_VAR 0 2
51010: PUSH
51011: LD_VAR 0 1
51015: PUSH
51016: LD_INT 1
51018: DIV
51019: ST_TO_ADDR
// if number < 0 then
51020: LD_VAR 0 1
51024: PUSH
51025: LD_INT 0
51027: LESS
51028: IFFALSE 51038
// result := 0 ;
51030: LD_ADDR_VAR 0 2
51034: PUSH
51035: LD_INT 0
51037: ST_TO_ADDR
// end ;
51038: LD_VAR 0 2
51042: RET
// export function SortByClass ( units , class ) ; var un ; begin
51043: LD_INT 0
51045: PPUSH
51046: PPUSH
// if not units or not class then
51047: LD_VAR 0 1
51051: NOT
51052: PUSH
51053: LD_VAR 0 2
51057: NOT
51058: OR
51059: IFFALSE 51063
// exit ;
51061: GO 51158
// result := [ ] ;
51063: LD_ADDR_VAR 0 3
51067: PUSH
51068: EMPTY
51069: ST_TO_ADDR
// for un in units do
51070: LD_ADDR_VAR 0 4
51074: PUSH
51075: LD_VAR 0 1
51079: PUSH
51080: FOR_IN
51081: IFFALSE 51156
// if GetClass ( un ) = class then
51083: LD_VAR 0 4
51087: PPUSH
51088: CALL_OW 257
51092: PUSH
51093: LD_VAR 0 2
51097: EQUAL
51098: IFFALSE 51125
// result := Insert ( result , 1 , un ) else
51100: LD_ADDR_VAR 0 3
51104: PUSH
51105: LD_VAR 0 3
51109: PPUSH
51110: LD_INT 1
51112: PPUSH
51113: LD_VAR 0 4
51117: PPUSH
51118: CALL_OW 2
51122: ST_TO_ADDR
51123: GO 51154
// result := Replace ( result , result + 1 , un ) ;
51125: LD_ADDR_VAR 0 3
51129: PUSH
51130: LD_VAR 0 3
51134: PPUSH
51135: LD_VAR 0 3
51139: PUSH
51140: LD_INT 1
51142: PLUS
51143: PPUSH
51144: LD_VAR 0 4
51148: PPUSH
51149: CALL_OW 1
51153: ST_TO_ADDR
51154: GO 51080
51156: POP
51157: POP
// end ;
51158: LD_VAR 0 3
51162: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
51163: LD_INT 0
51165: PPUSH
51166: PPUSH
51167: PPUSH
51168: PPUSH
51169: PPUSH
51170: PPUSH
51171: PPUSH
// result := [ ] ;
51172: LD_ADDR_VAR 0 4
51176: PUSH
51177: EMPTY
51178: ST_TO_ADDR
// if x - r < 0 then
51179: LD_VAR 0 1
51183: PUSH
51184: LD_VAR 0 3
51188: MINUS
51189: PUSH
51190: LD_INT 0
51192: LESS
51193: IFFALSE 51205
// min_x := 0 else
51195: LD_ADDR_VAR 0 8
51199: PUSH
51200: LD_INT 0
51202: ST_TO_ADDR
51203: GO 51221
// min_x := x - r ;
51205: LD_ADDR_VAR 0 8
51209: PUSH
51210: LD_VAR 0 1
51214: PUSH
51215: LD_VAR 0 3
51219: MINUS
51220: ST_TO_ADDR
// if y - r < 0 then
51221: LD_VAR 0 2
51225: PUSH
51226: LD_VAR 0 3
51230: MINUS
51231: PUSH
51232: LD_INT 0
51234: LESS
51235: IFFALSE 51247
// min_y := 0 else
51237: LD_ADDR_VAR 0 7
51241: PUSH
51242: LD_INT 0
51244: ST_TO_ADDR
51245: GO 51263
// min_y := y - r ;
51247: LD_ADDR_VAR 0 7
51251: PUSH
51252: LD_VAR 0 2
51256: PUSH
51257: LD_VAR 0 3
51261: MINUS
51262: ST_TO_ADDR
// max_x := x + r ;
51263: LD_ADDR_VAR 0 9
51267: PUSH
51268: LD_VAR 0 1
51272: PUSH
51273: LD_VAR 0 3
51277: PLUS
51278: ST_TO_ADDR
// max_y := y + r ;
51279: LD_ADDR_VAR 0 10
51283: PUSH
51284: LD_VAR 0 2
51288: PUSH
51289: LD_VAR 0 3
51293: PLUS
51294: ST_TO_ADDR
// for _x = min_x to max_x do
51295: LD_ADDR_VAR 0 5
51299: PUSH
51300: DOUBLE
51301: LD_VAR 0 8
51305: DEC
51306: ST_TO_ADDR
51307: LD_VAR 0 9
51311: PUSH
51312: FOR_TO
51313: IFFALSE 51414
// for _y = min_y to max_y do
51315: LD_ADDR_VAR 0 6
51319: PUSH
51320: DOUBLE
51321: LD_VAR 0 7
51325: DEC
51326: ST_TO_ADDR
51327: LD_VAR 0 10
51331: PUSH
51332: FOR_TO
51333: IFFALSE 51410
// begin if not ValidHex ( _x , _y ) then
51335: LD_VAR 0 5
51339: PPUSH
51340: LD_VAR 0 6
51344: PPUSH
51345: CALL_OW 488
51349: NOT
51350: IFFALSE 51354
// continue ;
51352: GO 51332
// if GetResourceTypeXY ( _x , _y ) then
51354: LD_VAR 0 5
51358: PPUSH
51359: LD_VAR 0 6
51363: PPUSH
51364: CALL_OW 283
51368: IFFALSE 51408
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
51370: LD_ADDR_VAR 0 4
51374: PUSH
51375: LD_VAR 0 4
51379: PPUSH
51380: LD_VAR 0 4
51384: PUSH
51385: LD_INT 1
51387: PLUS
51388: PPUSH
51389: LD_VAR 0 5
51393: PUSH
51394: LD_VAR 0 6
51398: PUSH
51399: EMPTY
51400: LIST
51401: LIST
51402: PPUSH
51403: CALL_OW 1
51407: ST_TO_ADDR
// end ;
51408: GO 51332
51410: POP
51411: POP
51412: GO 51312
51414: POP
51415: POP
// end ;
51416: LD_VAR 0 4
51420: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
51421: LD_INT 0
51423: PPUSH
51424: PPUSH
51425: PPUSH
51426: PPUSH
51427: PPUSH
51428: PPUSH
51429: PPUSH
51430: PPUSH
// if not units then
51431: LD_VAR 0 1
51435: NOT
51436: IFFALSE 51440
// exit ;
51438: GO 51964
// result := UnitFilter ( units , [ f_ok ] ) ;
51440: LD_ADDR_VAR 0 3
51444: PUSH
51445: LD_VAR 0 1
51449: PPUSH
51450: LD_INT 50
51452: PUSH
51453: EMPTY
51454: LIST
51455: PPUSH
51456: CALL_OW 72
51460: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
51461: LD_ADDR_VAR 0 8
51465: PUSH
51466: LD_VAR 0 1
51470: PUSH
51471: LD_INT 1
51473: ARRAY
51474: PPUSH
51475: CALL_OW 255
51479: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
51480: LD_ADDR_VAR 0 10
51484: PUSH
51485: LD_INT 29
51487: PUSH
51488: LD_INT 91
51490: PUSH
51491: LD_INT 49
51493: PUSH
51494: EMPTY
51495: LIST
51496: LIST
51497: LIST
51498: ST_TO_ADDR
// if not result then
51499: LD_VAR 0 3
51503: NOT
51504: IFFALSE 51508
// exit ;
51506: GO 51964
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
51508: LD_ADDR_VAR 0 5
51512: PUSH
51513: LD_INT 81
51515: PUSH
51516: LD_VAR 0 8
51520: PUSH
51521: EMPTY
51522: LIST
51523: LIST
51524: PPUSH
51525: CALL_OW 69
51529: ST_TO_ADDR
// for i in result do
51530: LD_ADDR_VAR 0 4
51534: PUSH
51535: LD_VAR 0 3
51539: PUSH
51540: FOR_IN
51541: IFFALSE 51962
// begin tag := GetTag ( i ) + 1 ;
51543: LD_ADDR_VAR 0 9
51547: PUSH
51548: LD_VAR 0 4
51552: PPUSH
51553: CALL_OW 110
51557: PUSH
51558: LD_INT 1
51560: PLUS
51561: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
51562: LD_ADDR_VAR 0 7
51566: PUSH
51567: LD_VAR 0 4
51571: PPUSH
51572: CALL_OW 250
51576: PPUSH
51577: LD_VAR 0 4
51581: PPUSH
51582: CALL_OW 251
51586: PPUSH
51587: LD_INT 6
51589: PPUSH
51590: CALL 51163 0 3
51594: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
51595: LD_VAR 0 4
51599: PPUSH
51600: CALL_OW 247
51604: PUSH
51605: LD_INT 2
51607: EQUAL
51608: PUSH
51609: LD_VAR 0 7
51613: AND
51614: PUSH
51615: LD_VAR 0 4
51619: PPUSH
51620: CALL_OW 264
51624: PUSH
51625: LD_VAR 0 10
51629: IN
51630: NOT
51631: AND
51632: IFFALSE 51671
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
51634: LD_VAR 0 4
51638: PPUSH
51639: LD_VAR 0 7
51643: PUSH
51644: LD_INT 1
51646: ARRAY
51647: PUSH
51648: LD_INT 1
51650: ARRAY
51651: PPUSH
51652: LD_VAR 0 7
51656: PUSH
51657: LD_INT 1
51659: ARRAY
51660: PUSH
51661: LD_INT 2
51663: ARRAY
51664: PPUSH
51665: CALL_OW 116
51669: GO 51960
// if path > tag then
51671: LD_VAR 0 2
51675: PUSH
51676: LD_VAR 0 9
51680: GREATER
51681: IFFALSE 51889
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
51683: LD_ADDR_VAR 0 6
51687: PUSH
51688: LD_VAR 0 5
51692: PPUSH
51693: LD_INT 91
51695: PUSH
51696: LD_VAR 0 4
51700: PUSH
51701: LD_INT 8
51703: PUSH
51704: EMPTY
51705: LIST
51706: LIST
51707: LIST
51708: PPUSH
51709: CALL_OW 72
51713: ST_TO_ADDR
// if nearEnemy then
51714: LD_VAR 0 6
51718: IFFALSE 51787
// begin if GetWeapon ( i ) = ru_time_lapser then
51720: LD_VAR 0 4
51724: PPUSH
51725: CALL_OW 264
51729: PUSH
51730: LD_INT 49
51732: EQUAL
51733: IFFALSE 51761
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
51735: LD_VAR 0 4
51739: PPUSH
51740: LD_VAR 0 6
51744: PPUSH
51745: LD_VAR 0 4
51749: PPUSH
51750: CALL_OW 74
51754: PPUSH
51755: CALL_OW 112
51759: GO 51785
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
51761: LD_VAR 0 4
51765: PPUSH
51766: LD_VAR 0 6
51770: PPUSH
51771: LD_VAR 0 4
51775: PPUSH
51776: CALL_OW 74
51780: PPUSH
51781: CALL 52889 0 2
// end else
51785: GO 51887
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
51787: LD_VAR 0 4
51791: PPUSH
51792: LD_VAR 0 2
51796: PUSH
51797: LD_VAR 0 9
51801: ARRAY
51802: PUSH
51803: LD_INT 1
51805: ARRAY
51806: PPUSH
51807: LD_VAR 0 2
51811: PUSH
51812: LD_VAR 0 9
51816: ARRAY
51817: PUSH
51818: LD_INT 2
51820: ARRAY
51821: PPUSH
51822: CALL_OW 297
51826: PUSH
51827: LD_INT 6
51829: GREATER
51830: IFFALSE 51873
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
51832: LD_VAR 0 4
51836: PPUSH
51837: LD_VAR 0 2
51841: PUSH
51842: LD_VAR 0 9
51846: ARRAY
51847: PUSH
51848: LD_INT 1
51850: ARRAY
51851: PPUSH
51852: LD_VAR 0 2
51856: PUSH
51857: LD_VAR 0 9
51861: ARRAY
51862: PUSH
51863: LD_INT 2
51865: ARRAY
51866: PPUSH
51867: CALL_OW 114
51871: GO 51887
// SetTag ( i , tag ) ;
51873: LD_VAR 0 4
51877: PPUSH
51878: LD_VAR 0 9
51882: PPUSH
51883: CALL_OW 109
// end else
51887: GO 51960
// if enemy then
51889: LD_VAR 0 5
51893: IFFALSE 51960
// begin if GetWeapon ( i ) = ru_time_lapser then
51895: LD_VAR 0 4
51899: PPUSH
51900: CALL_OW 264
51904: PUSH
51905: LD_INT 49
51907: EQUAL
51908: IFFALSE 51936
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
51910: LD_VAR 0 4
51914: PPUSH
51915: LD_VAR 0 5
51919: PPUSH
51920: LD_VAR 0 4
51924: PPUSH
51925: CALL_OW 74
51929: PPUSH
51930: CALL_OW 112
51934: GO 51960
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
51936: LD_VAR 0 4
51940: PPUSH
51941: LD_VAR 0 5
51945: PPUSH
51946: LD_VAR 0 4
51950: PPUSH
51951: CALL_OW 74
51955: PPUSH
51956: CALL 52889 0 2
// end ; end ;
51960: GO 51540
51962: POP
51963: POP
// end ;
51964: LD_VAR 0 3
51968: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
51969: LD_INT 0
51971: PPUSH
51972: PPUSH
51973: PPUSH
// if not unit or IsInUnit ( unit ) then
51974: LD_VAR 0 1
51978: NOT
51979: PUSH
51980: LD_VAR 0 1
51984: PPUSH
51985: CALL_OW 310
51989: OR
51990: IFFALSE 51994
// exit ;
51992: GO 52085
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
51994: LD_ADDR_VAR 0 4
51998: PUSH
51999: LD_VAR 0 1
52003: PPUSH
52004: CALL_OW 250
52008: PPUSH
52009: LD_VAR 0 2
52013: PPUSH
52014: LD_INT 1
52016: PPUSH
52017: CALL_OW 272
52021: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
52022: LD_ADDR_VAR 0 5
52026: PUSH
52027: LD_VAR 0 1
52031: PPUSH
52032: CALL_OW 251
52036: PPUSH
52037: LD_VAR 0 2
52041: PPUSH
52042: LD_INT 1
52044: PPUSH
52045: CALL_OW 273
52049: ST_TO_ADDR
// if ValidHex ( x , y ) then
52050: LD_VAR 0 4
52054: PPUSH
52055: LD_VAR 0 5
52059: PPUSH
52060: CALL_OW 488
52064: IFFALSE 52085
// ComTurnXY ( unit , x , y ) ;
52066: LD_VAR 0 1
52070: PPUSH
52071: LD_VAR 0 4
52075: PPUSH
52076: LD_VAR 0 5
52080: PPUSH
52081: CALL_OW 118
// end ;
52085: LD_VAR 0 3
52089: RET
// export function SeeUnits ( side , units ) ; var i ; begin
52090: LD_INT 0
52092: PPUSH
52093: PPUSH
// result := false ;
52094: LD_ADDR_VAR 0 3
52098: PUSH
52099: LD_INT 0
52101: ST_TO_ADDR
// if not units then
52102: LD_VAR 0 2
52106: NOT
52107: IFFALSE 52111
// exit ;
52109: GO 52156
// for i in units do
52111: LD_ADDR_VAR 0 4
52115: PUSH
52116: LD_VAR 0 2
52120: PUSH
52121: FOR_IN
52122: IFFALSE 52154
// if See ( side , i ) then
52124: LD_VAR 0 1
52128: PPUSH
52129: LD_VAR 0 4
52133: PPUSH
52134: CALL_OW 292
52138: IFFALSE 52152
// begin result := true ;
52140: LD_ADDR_VAR 0 3
52144: PUSH
52145: LD_INT 1
52147: ST_TO_ADDR
// exit ;
52148: POP
52149: POP
52150: GO 52156
// end ;
52152: GO 52121
52154: POP
52155: POP
// end ;
52156: LD_VAR 0 3
52160: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
52161: LD_INT 0
52163: PPUSH
52164: PPUSH
52165: PPUSH
52166: PPUSH
// if not unit or not points then
52167: LD_VAR 0 1
52171: NOT
52172: PUSH
52173: LD_VAR 0 2
52177: NOT
52178: OR
52179: IFFALSE 52183
// exit ;
52181: GO 52273
// dist := 99999 ;
52183: LD_ADDR_VAR 0 5
52187: PUSH
52188: LD_INT 99999
52190: ST_TO_ADDR
// for i in points do
52191: LD_ADDR_VAR 0 4
52195: PUSH
52196: LD_VAR 0 2
52200: PUSH
52201: FOR_IN
52202: IFFALSE 52271
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
52204: LD_ADDR_VAR 0 6
52208: PUSH
52209: LD_VAR 0 1
52213: PPUSH
52214: LD_VAR 0 4
52218: PUSH
52219: LD_INT 1
52221: ARRAY
52222: PPUSH
52223: LD_VAR 0 4
52227: PUSH
52228: LD_INT 2
52230: ARRAY
52231: PPUSH
52232: CALL_OW 297
52236: ST_TO_ADDR
// if tmpDist < dist then
52237: LD_VAR 0 6
52241: PUSH
52242: LD_VAR 0 5
52246: LESS
52247: IFFALSE 52269
// begin result := i ;
52249: LD_ADDR_VAR 0 3
52253: PUSH
52254: LD_VAR 0 4
52258: ST_TO_ADDR
// dist := tmpDist ;
52259: LD_ADDR_VAR 0 5
52263: PUSH
52264: LD_VAR 0 6
52268: ST_TO_ADDR
// end ; end ;
52269: GO 52201
52271: POP
52272: POP
// end ;
52273: LD_VAR 0 3
52277: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
52278: LD_INT 0
52280: PPUSH
// uc_side := side ;
52281: LD_ADDR_OWVAR 20
52285: PUSH
52286: LD_VAR 0 1
52290: ST_TO_ADDR
// uc_nation := 3 ;
52291: LD_ADDR_OWVAR 21
52295: PUSH
52296: LD_INT 3
52298: ST_TO_ADDR
// vc_chassis := 25 ;
52299: LD_ADDR_OWVAR 37
52303: PUSH
52304: LD_INT 25
52306: ST_TO_ADDR
// vc_engine := engine_siberite ;
52307: LD_ADDR_OWVAR 39
52311: PUSH
52312: LD_INT 3
52314: ST_TO_ADDR
// vc_control := control_computer ;
52315: LD_ADDR_OWVAR 38
52319: PUSH
52320: LD_INT 3
52322: ST_TO_ADDR
// vc_weapon := 59 ;
52323: LD_ADDR_OWVAR 40
52327: PUSH
52328: LD_INT 59
52330: ST_TO_ADDR
// result := CreateVehicle ;
52331: LD_ADDR_VAR 0 5
52335: PUSH
52336: CALL_OW 45
52340: ST_TO_ADDR
// SetDir ( result , d ) ;
52341: LD_VAR 0 5
52345: PPUSH
52346: LD_VAR 0 4
52350: PPUSH
52351: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
52355: LD_VAR 0 5
52359: PPUSH
52360: LD_VAR 0 2
52364: PPUSH
52365: LD_VAR 0 3
52369: PPUSH
52370: LD_INT 0
52372: PPUSH
52373: CALL_OW 48
// end ;
52377: LD_VAR 0 5
52381: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
52382: LD_INT 0
52384: PPUSH
52385: PPUSH
52386: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
52387: LD_ADDR_VAR 0 2
52391: PUSH
52392: LD_INT 0
52394: PUSH
52395: LD_INT 0
52397: PUSH
52398: LD_INT 0
52400: PUSH
52401: LD_INT 0
52403: PUSH
52404: EMPTY
52405: LIST
52406: LIST
52407: LIST
52408: LIST
52409: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
52410: LD_VAR 0 1
52414: NOT
52415: PUSH
52416: LD_VAR 0 1
52420: PPUSH
52421: CALL_OW 264
52425: PUSH
52426: LD_INT 12
52428: PUSH
52429: LD_INT 51
52431: PUSH
52432: LD_INT 32
52434: PUSH
52435: LD_INT 89
52437: PUSH
52438: EMPTY
52439: LIST
52440: LIST
52441: LIST
52442: LIST
52443: IN
52444: NOT
52445: OR
52446: IFFALSE 52450
// exit ;
52448: GO 52548
// for i := 1 to 3 do
52450: LD_ADDR_VAR 0 3
52454: PUSH
52455: DOUBLE
52456: LD_INT 1
52458: DEC
52459: ST_TO_ADDR
52460: LD_INT 3
52462: PUSH
52463: FOR_TO
52464: IFFALSE 52546
// begin tmp := GetCargo ( cargo , i ) ;
52466: LD_ADDR_VAR 0 4
52470: PUSH
52471: LD_VAR 0 1
52475: PPUSH
52476: LD_VAR 0 3
52480: PPUSH
52481: CALL_OW 289
52485: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
52486: LD_ADDR_VAR 0 2
52490: PUSH
52491: LD_VAR 0 2
52495: PPUSH
52496: LD_VAR 0 3
52500: PPUSH
52501: LD_VAR 0 4
52505: PPUSH
52506: CALL_OW 1
52510: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
52511: LD_ADDR_VAR 0 2
52515: PUSH
52516: LD_VAR 0 2
52520: PPUSH
52521: LD_INT 4
52523: PPUSH
52524: LD_VAR 0 2
52528: PUSH
52529: LD_INT 4
52531: ARRAY
52532: PUSH
52533: LD_VAR 0 4
52537: PLUS
52538: PPUSH
52539: CALL_OW 1
52543: ST_TO_ADDR
// end ;
52544: GO 52463
52546: POP
52547: POP
// end ;
52548: LD_VAR 0 2
52552: RET
// export function Length ( array ) ; begin
52553: LD_INT 0
52555: PPUSH
// result := array + 0 ;
52556: LD_ADDR_VAR 0 2
52560: PUSH
52561: LD_VAR 0 1
52565: PUSH
52566: LD_INT 0
52568: PLUS
52569: ST_TO_ADDR
// end ;
52570: LD_VAR 0 2
52574: RET
// export function PrepareArray ( array ) ; begin
52575: LD_INT 0
52577: PPUSH
// result := array diff 0 ;
52578: LD_ADDR_VAR 0 2
52582: PUSH
52583: LD_VAR 0 1
52587: PUSH
52588: LD_INT 0
52590: DIFF
52591: ST_TO_ADDR
// if not result [ 1 ] then
52592: LD_VAR 0 2
52596: PUSH
52597: LD_INT 1
52599: ARRAY
52600: NOT
52601: IFFALSE 52621
// result := Delete ( result , 1 ) ;
52603: LD_ADDR_VAR 0 2
52607: PUSH
52608: LD_VAR 0 2
52612: PPUSH
52613: LD_INT 1
52615: PPUSH
52616: CALL_OW 3
52620: ST_TO_ADDR
// end ;
52621: LD_VAR 0 2
52625: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
52626: LD_INT 0
52628: PPUSH
52629: PPUSH
52630: PPUSH
52631: PPUSH
// sibRocketRange := 25 ;
52632: LD_ADDR_VAR 0 6
52636: PUSH
52637: LD_INT 25
52639: ST_TO_ADDR
// result := false ;
52640: LD_ADDR_VAR 0 4
52644: PUSH
52645: LD_INT 0
52647: ST_TO_ADDR
// for i := 0 to 5 do
52648: LD_ADDR_VAR 0 5
52652: PUSH
52653: DOUBLE
52654: LD_INT 0
52656: DEC
52657: ST_TO_ADDR
52658: LD_INT 5
52660: PUSH
52661: FOR_TO
52662: IFFALSE 52729
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
52664: LD_VAR 0 1
52668: PPUSH
52669: LD_VAR 0 5
52673: PPUSH
52674: LD_VAR 0 6
52678: PPUSH
52679: CALL_OW 272
52683: PPUSH
52684: LD_VAR 0 2
52688: PPUSH
52689: LD_VAR 0 5
52693: PPUSH
52694: LD_VAR 0 6
52698: PPUSH
52699: CALL_OW 273
52703: PPUSH
52704: LD_VAR 0 3
52708: PPUSH
52709: CALL_OW 309
52713: IFFALSE 52727
// begin result := true ;
52715: LD_ADDR_VAR 0 4
52719: PUSH
52720: LD_INT 1
52722: ST_TO_ADDR
// exit ;
52723: POP
52724: POP
52725: GO 52731
// end ;
52727: GO 52661
52729: POP
52730: POP
// end ;
52731: LD_VAR 0 4
52735: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
52736: LD_INT 0
52738: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
52739: LD_VAR 0 1
52743: PPUSH
52744: LD_VAR 0 2
52748: PPUSH
52749: LD_INT 0
52751: PPUSH
52752: LD_INT 0
52754: PPUSH
52755: LD_INT 1
52757: PPUSH
52758: LD_INT 0
52760: PPUSH
52761: CALL_OW 587
// end ;
52765: LD_VAR 0 3
52769: RET
// export function CenterOnNow ( unit ) ; begin
52770: LD_INT 0
52772: PPUSH
// result := IsInUnit ( unit ) ;
52773: LD_ADDR_VAR 0 2
52777: PUSH
52778: LD_VAR 0 1
52782: PPUSH
52783: CALL_OW 310
52787: ST_TO_ADDR
// if not result then
52788: LD_VAR 0 2
52792: NOT
52793: IFFALSE 52805
// result := unit ;
52795: LD_ADDR_VAR 0 2
52799: PUSH
52800: LD_VAR 0 1
52804: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
52805: LD_VAR 0 1
52809: PPUSH
52810: CALL_OW 87
// end ;
52814: LD_VAR 0 2
52818: RET
// export function ComMoveHex ( unit , hex ) ; begin
52819: LD_INT 0
52821: PPUSH
// if not hex then
52822: LD_VAR 0 2
52826: NOT
52827: IFFALSE 52831
// exit ;
52829: GO 52884
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
52831: LD_VAR 0 2
52835: PUSH
52836: LD_INT 1
52838: ARRAY
52839: PPUSH
52840: LD_VAR 0 2
52844: PUSH
52845: LD_INT 2
52847: ARRAY
52848: PPUSH
52849: CALL_OW 428
52853: IFFALSE 52857
// exit ;
52855: GO 52884
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
52857: LD_VAR 0 1
52861: PPUSH
52862: LD_VAR 0 2
52866: PUSH
52867: LD_INT 1
52869: ARRAY
52870: PPUSH
52871: LD_VAR 0 2
52875: PUSH
52876: LD_INT 2
52878: ARRAY
52879: PPUSH
52880: CALL_OW 111
// end ;
52884: LD_VAR 0 3
52888: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
52889: LD_INT 0
52891: PPUSH
52892: PPUSH
52893: PPUSH
// if not unit or not enemy then
52894: LD_VAR 0 1
52898: NOT
52899: PUSH
52900: LD_VAR 0 2
52904: NOT
52905: OR
52906: IFFALSE 52910
// exit ;
52908: GO 53034
// x := GetX ( enemy ) ;
52910: LD_ADDR_VAR 0 4
52914: PUSH
52915: LD_VAR 0 2
52919: PPUSH
52920: CALL_OW 250
52924: ST_TO_ADDR
// y := GetY ( enemy ) ;
52925: LD_ADDR_VAR 0 5
52929: PUSH
52930: LD_VAR 0 2
52934: PPUSH
52935: CALL_OW 251
52939: ST_TO_ADDR
// if ValidHex ( x , y ) then
52940: LD_VAR 0 4
52944: PPUSH
52945: LD_VAR 0 5
52949: PPUSH
52950: CALL_OW 488
52954: IFFALSE 53034
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] and See ( GetSide ( unit ) , enemy ) then
52956: LD_VAR 0 2
52960: PPUSH
52961: CALL_OW 247
52965: PUSH
52966: LD_INT 3
52968: PUSH
52969: LD_INT 2
52971: PUSH
52972: EMPTY
52973: LIST
52974: LIST
52975: IN
52976: PUSH
52977: LD_VAR 0 1
52981: PPUSH
52982: CALL_OW 255
52986: PPUSH
52987: LD_VAR 0 2
52991: PPUSH
52992: CALL_OW 292
52996: AND
52997: IFFALSE 53015
// ComAttackUnit ( unit , enemy ) else
52999: LD_VAR 0 1
53003: PPUSH
53004: LD_VAR 0 2
53008: PPUSH
53009: CALL_OW 115
53013: GO 53034
// ComAgressiveMove ( unit , x , y ) ;
53015: LD_VAR 0 1
53019: PPUSH
53020: LD_VAR 0 4
53024: PPUSH
53025: LD_VAR 0 5
53029: PPUSH
53030: CALL_OW 114
// end ; end_of_file
53034: LD_VAR 0 3
53038: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
53039: LD_INT 0
53041: PPUSH
53042: PPUSH
// skirmish := false ;
53043: LD_ADDR_EXP 21
53047: PUSH
53048: LD_INT 0
53050: ST_TO_ADDR
// debug_mc := false ;
53051: LD_ADDR_EXP 22
53055: PUSH
53056: LD_INT 0
53058: ST_TO_ADDR
// mc_bases := [ ] ;
53059: LD_ADDR_EXP 23
53063: PUSH
53064: EMPTY
53065: ST_TO_ADDR
// mc_sides := [ ] ;
53066: LD_ADDR_EXP 49
53070: PUSH
53071: EMPTY
53072: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
53073: LD_ADDR_EXP 24
53077: PUSH
53078: EMPTY
53079: ST_TO_ADDR
// mc_building_repairs := [ ] ;
53080: LD_ADDR_EXP 25
53084: PUSH
53085: EMPTY
53086: ST_TO_ADDR
// mc_need_heal := [ ] ;
53087: LD_ADDR_EXP 26
53091: PUSH
53092: EMPTY
53093: ST_TO_ADDR
// mc_healers := [ ] ;
53094: LD_ADDR_EXP 27
53098: PUSH
53099: EMPTY
53100: ST_TO_ADDR
// mc_build_list := [ ] ;
53101: LD_ADDR_EXP 28
53105: PUSH
53106: EMPTY
53107: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
53108: LD_ADDR_EXP 55
53112: PUSH
53113: EMPTY
53114: ST_TO_ADDR
// mc_builders := [ ] ;
53115: LD_ADDR_EXP 29
53119: PUSH
53120: EMPTY
53121: ST_TO_ADDR
// mc_construct_list := [ ] ;
53122: LD_ADDR_EXP 30
53126: PUSH
53127: EMPTY
53128: ST_TO_ADDR
// mc_turret_list := [ ] ;
53129: LD_ADDR_EXP 31
53133: PUSH
53134: EMPTY
53135: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
53136: LD_ADDR_EXP 32
53140: PUSH
53141: EMPTY
53142: ST_TO_ADDR
// mc_miners := [ ] ;
53143: LD_ADDR_EXP 37
53147: PUSH
53148: EMPTY
53149: ST_TO_ADDR
// mc_mines := [ ] ;
53150: LD_ADDR_EXP 36
53154: PUSH
53155: EMPTY
53156: ST_TO_ADDR
// mc_minefields := [ ] ;
53157: LD_ADDR_EXP 38
53161: PUSH
53162: EMPTY
53163: ST_TO_ADDR
// mc_crates := [ ] ;
53164: LD_ADDR_EXP 39
53168: PUSH
53169: EMPTY
53170: ST_TO_ADDR
// mc_crates_collector := [ ] ;
53171: LD_ADDR_EXP 40
53175: PUSH
53176: EMPTY
53177: ST_TO_ADDR
// mc_crates_area := [ ] ;
53178: LD_ADDR_EXP 41
53182: PUSH
53183: EMPTY
53184: ST_TO_ADDR
// mc_vehicles := [ ] ;
53185: LD_ADDR_EXP 42
53189: PUSH
53190: EMPTY
53191: ST_TO_ADDR
// mc_attack := [ ] ;
53192: LD_ADDR_EXP 43
53196: PUSH
53197: EMPTY
53198: ST_TO_ADDR
// mc_produce := [ ] ;
53199: LD_ADDR_EXP 44
53203: PUSH
53204: EMPTY
53205: ST_TO_ADDR
// mc_defender := [ ] ;
53206: LD_ADDR_EXP 45
53210: PUSH
53211: EMPTY
53212: ST_TO_ADDR
// mc_parking := [ ] ;
53213: LD_ADDR_EXP 47
53217: PUSH
53218: EMPTY
53219: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
53220: LD_ADDR_EXP 33
53224: PUSH
53225: EMPTY
53226: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
53227: LD_ADDR_EXP 35
53231: PUSH
53232: EMPTY
53233: ST_TO_ADDR
// mc_scan := [ ] ;
53234: LD_ADDR_EXP 46
53238: PUSH
53239: EMPTY
53240: ST_TO_ADDR
// mc_scan_area := [ ] ;
53241: LD_ADDR_EXP 48
53245: PUSH
53246: EMPTY
53247: ST_TO_ADDR
// mc_tech := [ ] ;
53248: LD_ADDR_EXP 50
53252: PUSH
53253: EMPTY
53254: ST_TO_ADDR
// mc_class := [ ] ;
53255: LD_ADDR_EXP 64
53259: PUSH
53260: EMPTY
53261: ST_TO_ADDR
// mc_class_case_use := [ ] ;
53262: LD_ADDR_EXP 65
53266: PUSH
53267: EMPTY
53268: ST_TO_ADDR
// mc_is_defending := [ ] ;
53269: LD_ADDR_EXP 66
53273: PUSH
53274: EMPTY
53275: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
53276: LD_ADDR_EXP 57
53280: PUSH
53281: EMPTY
53282: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
53283: LD_ADDR_EXP 67
53287: PUSH
53288: LD_INT 0
53290: ST_TO_ADDR
// end ;
53291: LD_VAR 0 1
53295: RET
// export function MC_Kill ( base ) ; begin
53296: LD_INT 0
53298: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
53299: LD_ADDR_EXP 23
53303: PUSH
53304: LD_EXP 23
53308: PPUSH
53309: LD_VAR 0 1
53313: PPUSH
53314: EMPTY
53315: PPUSH
53316: CALL_OW 1
53320: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
53321: LD_ADDR_EXP 24
53325: PUSH
53326: LD_EXP 24
53330: PPUSH
53331: LD_VAR 0 1
53335: PPUSH
53336: EMPTY
53337: PPUSH
53338: CALL_OW 1
53342: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
53343: LD_ADDR_EXP 25
53347: PUSH
53348: LD_EXP 25
53352: PPUSH
53353: LD_VAR 0 1
53357: PPUSH
53358: EMPTY
53359: PPUSH
53360: CALL_OW 1
53364: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
53365: LD_ADDR_EXP 26
53369: PUSH
53370: LD_EXP 26
53374: PPUSH
53375: LD_VAR 0 1
53379: PPUSH
53380: EMPTY
53381: PPUSH
53382: CALL_OW 1
53386: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
53387: LD_ADDR_EXP 27
53391: PUSH
53392: LD_EXP 27
53396: PPUSH
53397: LD_VAR 0 1
53401: PPUSH
53402: EMPTY
53403: PPUSH
53404: CALL_OW 1
53408: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
53409: LD_ADDR_EXP 28
53413: PUSH
53414: LD_EXP 28
53418: PPUSH
53419: LD_VAR 0 1
53423: PPUSH
53424: EMPTY
53425: PPUSH
53426: CALL_OW 1
53430: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
53431: LD_ADDR_EXP 29
53435: PUSH
53436: LD_EXP 29
53440: PPUSH
53441: LD_VAR 0 1
53445: PPUSH
53446: EMPTY
53447: PPUSH
53448: CALL_OW 1
53452: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
53453: LD_ADDR_EXP 30
53457: PUSH
53458: LD_EXP 30
53462: PPUSH
53463: LD_VAR 0 1
53467: PPUSH
53468: EMPTY
53469: PPUSH
53470: CALL_OW 1
53474: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
53475: LD_ADDR_EXP 31
53479: PUSH
53480: LD_EXP 31
53484: PPUSH
53485: LD_VAR 0 1
53489: PPUSH
53490: EMPTY
53491: PPUSH
53492: CALL_OW 1
53496: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
53497: LD_ADDR_EXP 32
53501: PUSH
53502: LD_EXP 32
53506: PPUSH
53507: LD_VAR 0 1
53511: PPUSH
53512: EMPTY
53513: PPUSH
53514: CALL_OW 1
53518: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
53519: LD_ADDR_EXP 33
53523: PUSH
53524: LD_EXP 33
53528: PPUSH
53529: LD_VAR 0 1
53533: PPUSH
53534: EMPTY
53535: PPUSH
53536: CALL_OW 1
53540: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
53541: LD_ADDR_EXP 34
53545: PUSH
53546: LD_EXP 34
53550: PPUSH
53551: LD_VAR 0 1
53555: PPUSH
53556: LD_INT 0
53558: PPUSH
53559: CALL_OW 1
53563: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
53564: LD_ADDR_EXP 35
53568: PUSH
53569: LD_EXP 35
53573: PPUSH
53574: LD_VAR 0 1
53578: PPUSH
53579: EMPTY
53580: PPUSH
53581: CALL_OW 1
53585: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
53586: LD_ADDR_EXP 36
53590: PUSH
53591: LD_EXP 36
53595: PPUSH
53596: LD_VAR 0 1
53600: PPUSH
53601: EMPTY
53602: PPUSH
53603: CALL_OW 1
53607: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
53608: LD_ADDR_EXP 37
53612: PUSH
53613: LD_EXP 37
53617: PPUSH
53618: LD_VAR 0 1
53622: PPUSH
53623: EMPTY
53624: PPUSH
53625: CALL_OW 1
53629: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
53630: LD_ADDR_EXP 38
53634: PUSH
53635: LD_EXP 38
53639: PPUSH
53640: LD_VAR 0 1
53644: PPUSH
53645: EMPTY
53646: PPUSH
53647: CALL_OW 1
53651: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
53652: LD_ADDR_EXP 39
53656: PUSH
53657: LD_EXP 39
53661: PPUSH
53662: LD_VAR 0 1
53666: PPUSH
53667: EMPTY
53668: PPUSH
53669: CALL_OW 1
53673: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
53674: LD_ADDR_EXP 40
53678: PUSH
53679: LD_EXP 40
53683: PPUSH
53684: LD_VAR 0 1
53688: PPUSH
53689: EMPTY
53690: PPUSH
53691: CALL_OW 1
53695: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
53696: LD_ADDR_EXP 41
53700: PUSH
53701: LD_EXP 41
53705: PPUSH
53706: LD_VAR 0 1
53710: PPUSH
53711: EMPTY
53712: PPUSH
53713: CALL_OW 1
53717: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
53718: LD_ADDR_EXP 42
53722: PUSH
53723: LD_EXP 42
53727: PPUSH
53728: LD_VAR 0 1
53732: PPUSH
53733: EMPTY
53734: PPUSH
53735: CALL_OW 1
53739: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
53740: LD_ADDR_EXP 43
53744: PUSH
53745: LD_EXP 43
53749: PPUSH
53750: LD_VAR 0 1
53754: PPUSH
53755: EMPTY
53756: PPUSH
53757: CALL_OW 1
53761: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
53762: LD_ADDR_EXP 44
53766: PUSH
53767: LD_EXP 44
53771: PPUSH
53772: LD_VAR 0 1
53776: PPUSH
53777: EMPTY
53778: PPUSH
53779: CALL_OW 1
53783: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
53784: LD_ADDR_EXP 45
53788: PUSH
53789: LD_EXP 45
53793: PPUSH
53794: LD_VAR 0 1
53798: PPUSH
53799: EMPTY
53800: PPUSH
53801: CALL_OW 1
53805: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
53806: LD_ADDR_EXP 46
53810: PUSH
53811: LD_EXP 46
53815: PPUSH
53816: LD_VAR 0 1
53820: PPUSH
53821: EMPTY
53822: PPUSH
53823: CALL_OW 1
53827: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
53828: LD_ADDR_EXP 47
53832: PUSH
53833: LD_EXP 47
53837: PPUSH
53838: LD_VAR 0 1
53842: PPUSH
53843: EMPTY
53844: PPUSH
53845: CALL_OW 1
53849: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
53850: LD_ADDR_EXP 48
53854: PUSH
53855: LD_EXP 48
53859: PPUSH
53860: LD_VAR 0 1
53864: PPUSH
53865: EMPTY
53866: PPUSH
53867: CALL_OW 1
53871: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
53872: LD_ADDR_EXP 50
53876: PUSH
53877: LD_EXP 50
53881: PPUSH
53882: LD_VAR 0 1
53886: PPUSH
53887: EMPTY
53888: PPUSH
53889: CALL_OW 1
53893: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
53894: LD_ADDR_EXP 52
53898: PUSH
53899: LD_EXP 52
53903: PPUSH
53904: LD_VAR 0 1
53908: PPUSH
53909: EMPTY
53910: PPUSH
53911: CALL_OW 1
53915: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
53916: LD_ADDR_EXP 53
53920: PUSH
53921: LD_EXP 53
53925: PPUSH
53926: LD_VAR 0 1
53930: PPUSH
53931: EMPTY
53932: PPUSH
53933: CALL_OW 1
53937: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
53938: LD_ADDR_EXP 54
53942: PUSH
53943: LD_EXP 54
53947: PPUSH
53948: LD_VAR 0 1
53952: PPUSH
53953: EMPTY
53954: PPUSH
53955: CALL_OW 1
53959: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
53960: LD_ADDR_EXP 55
53964: PUSH
53965: LD_EXP 55
53969: PPUSH
53970: LD_VAR 0 1
53974: PPUSH
53975: EMPTY
53976: PPUSH
53977: CALL_OW 1
53981: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
53982: LD_ADDR_EXP 56
53986: PUSH
53987: LD_EXP 56
53991: PPUSH
53992: LD_VAR 0 1
53996: PPUSH
53997: EMPTY
53998: PPUSH
53999: CALL_OW 1
54003: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
54004: LD_ADDR_EXP 57
54008: PUSH
54009: LD_EXP 57
54013: PPUSH
54014: LD_VAR 0 1
54018: PPUSH
54019: EMPTY
54020: PPUSH
54021: CALL_OW 1
54025: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
54026: LD_ADDR_EXP 58
54030: PUSH
54031: LD_EXP 58
54035: PPUSH
54036: LD_VAR 0 1
54040: PPUSH
54041: EMPTY
54042: PPUSH
54043: CALL_OW 1
54047: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
54048: LD_ADDR_EXP 59
54052: PUSH
54053: LD_EXP 59
54057: PPUSH
54058: LD_VAR 0 1
54062: PPUSH
54063: EMPTY
54064: PPUSH
54065: CALL_OW 1
54069: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
54070: LD_ADDR_EXP 60
54074: PUSH
54075: LD_EXP 60
54079: PPUSH
54080: LD_VAR 0 1
54084: PPUSH
54085: EMPTY
54086: PPUSH
54087: CALL_OW 1
54091: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
54092: LD_ADDR_EXP 61
54096: PUSH
54097: LD_EXP 61
54101: PPUSH
54102: LD_VAR 0 1
54106: PPUSH
54107: EMPTY
54108: PPUSH
54109: CALL_OW 1
54113: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
54114: LD_ADDR_EXP 62
54118: PUSH
54119: LD_EXP 62
54123: PPUSH
54124: LD_VAR 0 1
54128: PPUSH
54129: EMPTY
54130: PPUSH
54131: CALL_OW 1
54135: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
54136: LD_ADDR_EXP 63
54140: PUSH
54141: LD_EXP 63
54145: PPUSH
54146: LD_VAR 0 1
54150: PPUSH
54151: EMPTY
54152: PPUSH
54153: CALL_OW 1
54157: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
54158: LD_ADDR_EXP 64
54162: PUSH
54163: LD_EXP 64
54167: PPUSH
54168: LD_VAR 0 1
54172: PPUSH
54173: EMPTY
54174: PPUSH
54175: CALL_OW 1
54179: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
54180: LD_ADDR_EXP 65
54184: PUSH
54185: LD_EXP 65
54189: PPUSH
54190: LD_VAR 0 1
54194: PPUSH
54195: LD_INT 0
54197: PPUSH
54198: CALL_OW 1
54202: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
54203: LD_ADDR_EXP 66
54207: PUSH
54208: LD_EXP 66
54212: PPUSH
54213: LD_VAR 0 1
54217: PPUSH
54218: LD_INT 0
54220: PPUSH
54221: CALL_OW 1
54225: ST_TO_ADDR
// end ;
54226: LD_VAR 0 2
54230: RET
// export function MC_Add ( side , units ) ; var base ; begin
54231: LD_INT 0
54233: PPUSH
54234: PPUSH
// base := mc_bases + 1 ;
54235: LD_ADDR_VAR 0 4
54239: PUSH
54240: LD_EXP 23
54244: PUSH
54245: LD_INT 1
54247: PLUS
54248: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
54249: LD_ADDR_EXP 49
54253: PUSH
54254: LD_EXP 49
54258: PPUSH
54259: LD_VAR 0 4
54263: PPUSH
54264: LD_VAR 0 1
54268: PPUSH
54269: CALL_OW 1
54273: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
54274: LD_ADDR_EXP 23
54278: PUSH
54279: LD_EXP 23
54283: PPUSH
54284: LD_VAR 0 4
54288: PPUSH
54289: LD_VAR 0 2
54293: PPUSH
54294: CALL_OW 1
54298: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
54299: LD_ADDR_EXP 24
54303: PUSH
54304: LD_EXP 24
54308: PPUSH
54309: LD_VAR 0 4
54313: PPUSH
54314: EMPTY
54315: PPUSH
54316: CALL_OW 1
54320: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
54321: LD_ADDR_EXP 25
54325: PUSH
54326: LD_EXP 25
54330: PPUSH
54331: LD_VAR 0 4
54335: PPUSH
54336: EMPTY
54337: PPUSH
54338: CALL_OW 1
54342: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
54343: LD_ADDR_EXP 26
54347: PUSH
54348: LD_EXP 26
54352: PPUSH
54353: LD_VAR 0 4
54357: PPUSH
54358: EMPTY
54359: PPUSH
54360: CALL_OW 1
54364: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
54365: LD_ADDR_EXP 27
54369: PUSH
54370: LD_EXP 27
54374: PPUSH
54375: LD_VAR 0 4
54379: PPUSH
54380: EMPTY
54381: PPUSH
54382: CALL_OW 1
54386: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
54387: LD_ADDR_EXP 28
54391: PUSH
54392: LD_EXP 28
54396: PPUSH
54397: LD_VAR 0 4
54401: PPUSH
54402: EMPTY
54403: PPUSH
54404: CALL_OW 1
54408: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
54409: LD_ADDR_EXP 29
54413: PUSH
54414: LD_EXP 29
54418: PPUSH
54419: LD_VAR 0 4
54423: PPUSH
54424: EMPTY
54425: PPUSH
54426: CALL_OW 1
54430: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
54431: LD_ADDR_EXP 30
54435: PUSH
54436: LD_EXP 30
54440: PPUSH
54441: LD_VAR 0 4
54445: PPUSH
54446: EMPTY
54447: PPUSH
54448: CALL_OW 1
54452: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
54453: LD_ADDR_EXP 31
54457: PUSH
54458: LD_EXP 31
54462: PPUSH
54463: LD_VAR 0 4
54467: PPUSH
54468: EMPTY
54469: PPUSH
54470: CALL_OW 1
54474: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
54475: LD_ADDR_EXP 32
54479: PUSH
54480: LD_EXP 32
54484: PPUSH
54485: LD_VAR 0 4
54489: PPUSH
54490: EMPTY
54491: PPUSH
54492: CALL_OW 1
54496: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
54497: LD_ADDR_EXP 33
54501: PUSH
54502: LD_EXP 33
54506: PPUSH
54507: LD_VAR 0 4
54511: PPUSH
54512: EMPTY
54513: PPUSH
54514: CALL_OW 1
54518: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
54519: LD_ADDR_EXP 34
54523: PUSH
54524: LD_EXP 34
54528: PPUSH
54529: LD_VAR 0 4
54533: PPUSH
54534: LD_INT 0
54536: PPUSH
54537: CALL_OW 1
54541: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
54542: LD_ADDR_EXP 35
54546: PUSH
54547: LD_EXP 35
54551: PPUSH
54552: LD_VAR 0 4
54556: PPUSH
54557: EMPTY
54558: PPUSH
54559: CALL_OW 1
54563: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
54564: LD_ADDR_EXP 36
54568: PUSH
54569: LD_EXP 36
54573: PPUSH
54574: LD_VAR 0 4
54578: PPUSH
54579: EMPTY
54580: PPUSH
54581: CALL_OW 1
54585: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
54586: LD_ADDR_EXP 37
54590: PUSH
54591: LD_EXP 37
54595: PPUSH
54596: LD_VAR 0 4
54600: PPUSH
54601: EMPTY
54602: PPUSH
54603: CALL_OW 1
54607: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
54608: LD_ADDR_EXP 38
54612: PUSH
54613: LD_EXP 38
54617: PPUSH
54618: LD_VAR 0 4
54622: PPUSH
54623: EMPTY
54624: PPUSH
54625: CALL_OW 1
54629: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
54630: LD_ADDR_EXP 39
54634: PUSH
54635: LD_EXP 39
54639: PPUSH
54640: LD_VAR 0 4
54644: PPUSH
54645: EMPTY
54646: PPUSH
54647: CALL_OW 1
54651: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
54652: LD_ADDR_EXP 40
54656: PUSH
54657: LD_EXP 40
54661: PPUSH
54662: LD_VAR 0 4
54666: PPUSH
54667: EMPTY
54668: PPUSH
54669: CALL_OW 1
54673: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
54674: LD_ADDR_EXP 41
54678: PUSH
54679: LD_EXP 41
54683: PPUSH
54684: LD_VAR 0 4
54688: PPUSH
54689: EMPTY
54690: PPUSH
54691: CALL_OW 1
54695: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
54696: LD_ADDR_EXP 42
54700: PUSH
54701: LD_EXP 42
54705: PPUSH
54706: LD_VAR 0 4
54710: PPUSH
54711: EMPTY
54712: PPUSH
54713: CALL_OW 1
54717: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
54718: LD_ADDR_EXP 43
54722: PUSH
54723: LD_EXP 43
54727: PPUSH
54728: LD_VAR 0 4
54732: PPUSH
54733: EMPTY
54734: PPUSH
54735: CALL_OW 1
54739: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
54740: LD_ADDR_EXP 44
54744: PUSH
54745: LD_EXP 44
54749: PPUSH
54750: LD_VAR 0 4
54754: PPUSH
54755: EMPTY
54756: PPUSH
54757: CALL_OW 1
54761: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
54762: LD_ADDR_EXP 45
54766: PUSH
54767: LD_EXP 45
54771: PPUSH
54772: LD_VAR 0 4
54776: PPUSH
54777: EMPTY
54778: PPUSH
54779: CALL_OW 1
54783: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
54784: LD_ADDR_EXP 46
54788: PUSH
54789: LD_EXP 46
54793: PPUSH
54794: LD_VAR 0 4
54798: PPUSH
54799: EMPTY
54800: PPUSH
54801: CALL_OW 1
54805: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
54806: LD_ADDR_EXP 47
54810: PUSH
54811: LD_EXP 47
54815: PPUSH
54816: LD_VAR 0 4
54820: PPUSH
54821: EMPTY
54822: PPUSH
54823: CALL_OW 1
54827: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
54828: LD_ADDR_EXP 48
54832: PUSH
54833: LD_EXP 48
54837: PPUSH
54838: LD_VAR 0 4
54842: PPUSH
54843: EMPTY
54844: PPUSH
54845: CALL_OW 1
54849: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
54850: LD_ADDR_EXP 50
54854: PUSH
54855: LD_EXP 50
54859: PPUSH
54860: LD_VAR 0 4
54864: PPUSH
54865: EMPTY
54866: PPUSH
54867: CALL_OW 1
54871: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
54872: LD_ADDR_EXP 52
54876: PUSH
54877: LD_EXP 52
54881: PPUSH
54882: LD_VAR 0 4
54886: PPUSH
54887: EMPTY
54888: PPUSH
54889: CALL_OW 1
54893: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
54894: LD_ADDR_EXP 53
54898: PUSH
54899: LD_EXP 53
54903: PPUSH
54904: LD_VAR 0 4
54908: PPUSH
54909: EMPTY
54910: PPUSH
54911: CALL_OW 1
54915: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
54916: LD_ADDR_EXP 54
54920: PUSH
54921: LD_EXP 54
54925: PPUSH
54926: LD_VAR 0 4
54930: PPUSH
54931: EMPTY
54932: PPUSH
54933: CALL_OW 1
54937: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
54938: LD_ADDR_EXP 55
54942: PUSH
54943: LD_EXP 55
54947: PPUSH
54948: LD_VAR 0 4
54952: PPUSH
54953: EMPTY
54954: PPUSH
54955: CALL_OW 1
54959: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
54960: LD_ADDR_EXP 56
54964: PUSH
54965: LD_EXP 56
54969: PPUSH
54970: LD_VAR 0 4
54974: PPUSH
54975: EMPTY
54976: PPUSH
54977: CALL_OW 1
54981: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
54982: LD_ADDR_EXP 57
54986: PUSH
54987: LD_EXP 57
54991: PPUSH
54992: LD_VAR 0 4
54996: PPUSH
54997: EMPTY
54998: PPUSH
54999: CALL_OW 1
55003: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
55004: LD_ADDR_EXP 58
55008: PUSH
55009: LD_EXP 58
55013: PPUSH
55014: LD_VAR 0 4
55018: PPUSH
55019: EMPTY
55020: PPUSH
55021: CALL_OW 1
55025: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
55026: LD_ADDR_EXP 59
55030: PUSH
55031: LD_EXP 59
55035: PPUSH
55036: LD_VAR 0 4
55040: PPUSH
55041: EMPTY
55042: PPUSH
55043: CALL_OW 1
55047: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
55048: LD_ADDR_EXP 60
55052: PUSH
55053: LD_EXP 60
55057: PPUSH
55058: LD_VAR 0 4
55062: PPUSH
55063: EMPTY
55064: PPUSH
55065: CALL_OW 1
55069: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
55070: LD_ADDR_EXP 61
55074: PUSH
55075: LD_EXP 61
55079: PPUSH
55080: LD_VAR 0 4
55084: PPUSH
55085: EMPTY
55086: PPUSH
55087: CALL_OW 1
55091: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
55092: LD_ADDR_EXP 62
55096: PUSH
55097: LD_EXP 62
55101: PPUSH
55102: LD_VAR 0 4
55106: PPUSH
55107: EMPTY
55108: PPUSH
55109: CALL_OW 1
55113: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
55114: LD_ADDR_EXP 63
55118: PUSH
55119: LD_EXP 63
55123: PPUSH
55124: LD_VAR 0 4
55128: PPUSH
55129: EMPTY
55130: PPUSH
55131: CALL_OW 1
55135: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
55136: LD_ADDR_EXP 64
55140: PUSH
55141: LD_EXP 64
55145: PPUSH
55146: LD_VAR 0 4
55150: PPUSH
55151: EMPTY
55152: PPUSH
55153: CALL_OW 1
55157: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
55158: LD_ADDR_EXP 65
55162: PUSH
55163: LD_EXP 65
55167: PPUSH
55168: LD_VAR 0 4
55172: PPUSH
55173: LD_INT 0
55175: PPUSH
55176: CALL_OW 1
55180: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
55181: LD_ADDR_EXP 66
55185: PUSH
55186: LD_EXP 66
55190: PPUSH
55191: LD_VAR 0 4
55195: PPUSH
55196: LD_INT 0
55198: PPUSH
55199: CALL_OW 1
55203: ST_TO_ADDR
// result := base ;
55204: LD_ADDR_VAR 0 3
55208: PUSH
55209: LD_VAR 0 4
55213: ST_TO_ADDR
// end ;
55214: LD_VAR 0 3
55218: RET
// export function MC_Start ( ) ; var i ; begin
55219: LD_INT 0
55221: PPUSH
55222: PPUSH
// for i = 1 to mc_bases do
55223: LD_ADDR_VAR 0 2
55227: PUSH
55228: DOUBLE
55229: LD_INT 1
55231: DEC
55232: ST_TO_ADDR
55233: LD_EXP 23
55237: PUSH
55238: FOR_TO
55239: IFFALSE 56339
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
55241: LD_ADDR_EXP 23
55245: PUSH
55246: LD_EXP 23
55250: PPUSH
55251: LD_VAR 0 2
55255: PPUSH
55256: LD_EXP 23
55260: PUSH
55261: LD_VAR 0 2
55265: ARRAY
55266: PUSH
55267: LD_INT 0
55269: DIFF
55270: PPUSH
55271: CALL_OW 1
55275: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
55276: LD_ADDR_EXP 24
55280: PUSH
55281: LD_EXP 24
55285: PPUSH
55286: LD_VAR 0 2
55290: PPUSH
55291: EMPTY
55292: PPUSH
55293: CALL_OW 1
55297: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
55298: LD_ADDR_EXP 25
55302: PUSH
55303: LD_EXP 25
55307: PPUSH
55308: LD_VAR 0 2
55312: PPUSH
55313: EMPTY
55314: PPUSH
55315: CALL_OW 1
55319: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
55320: LD_ADDR_EXP 26
55324: PUSH
55325: LD_EXP 26
55329: PPUSH
55330: LD_VAR 0 2
55334: PPUSH
55335: EMPTY
55336: PPUSH
55337: CALL_OW 1
55341: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
55342: LD_ADDR_EXP 27
55346: PUSH
55347: LD_EXP 27
55351: PPUSH
55352: LD_VAR 0 2
55356: PPUSH
55357: EMPTY
55358: PUSH
55359: EMPTY
55360: PUSH
55361: EMPTY
55362: LIST
55363: LIST
55364: PPUSH
55365: CALL_OW 1
55369: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
55370: LD_ADDR_EXP 28
55374: PUSH
55375: LD_EXP 28
55379: PPUSH
55380: LD_VAR 0 2
55384: PPUSH
55385: EMPTY
55386: PPUSH
55387: CALL_OW 1
55391: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
55392: LD_ADDR_EXP 55
55396: PUSH
55397: LD_EXP 55
55401: PPUSH
55402: LD_VAR 0 2
55406: PPUSH
55407: EMPTY
55408: PPUSH
55409: CALL_OW 1
55413: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
55414: LD_ADDR_EXP 29
55418: PUSH
55419: LD_EXP 29
55423: PPUSH
55424: LD_VAR 0 2
55428: PPUSH
55429: EMPTY
55430: PPUSH
55431: CALL_OW 1
55435: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
55436: LD_ADDR_EXP 30
55440: PUSH
55441: LD_EXP 30
55445: PPUSH
55446: LD_VAR 0 2
55450: PPUSH
55451: EMPTY
55452: PPUSH
55453: CALL_OW 1
55457: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
55458: LD_ADDR_EXP 31
55462: PUSH
55463: LD_EXP 31
55467: PPUSH
55468: LD_VAR 0 2
55472: PPUSH
55473: LD_EXP 23
55477: PUSH
55478: LD_VAR 0 2
55482: ARRAY
55483: PPUSH
55484: LD_INT 2
55486: PUSH
55487: LD_INT 30
55489: PUSH
55490: LD_INT 32
55492: PUSH
55493: EMPTY
55494: LIST
55495: LIST
55496: PUSH
55497: LD_INT 30
55499: PUSH
55500: LD_INT 33
55502: PUSH
55503: EMPTY
55504: LIST
55505: LIST
55506: PUSH
55507: EMPTY
55508: LIST
55509: LIST
55510: LIST
55511: PPUSH
55512: CALL_OW 72
55516: PPUSH
55517: CALL_OW 1
55521: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
55522: LD_ADDR_EXP 32
55526: PUSH
55527: LD_EXP 32
55531: PPUSH
55532: LD_VAR 0 2
55536: PPUSH
55537: LD_EXP 23
55541: PUSH
55542: LD_VAR 0 2
55546: ARRAY
55547: PPUSH
55548: LD_INT 2
55550: PUSH
55551: LD_INT 30
55553: PUSH
55554: LD_INT 32
55556: PUSH
55557: EMPTY
55558: LIST
55559: LIST
55560: PUSH
55561: LD_INT 30
55563: PUSH
55564: LD_INT 31
55566: PUSH
55567: EMPTY
55568: LIST
55569: LIST
55570: PUSH
55571: EMPTY
55572: LIST
55573: LIST
55574: LIST
55575: PUSH
55576: LD_INT 58
55578: PUSH
55579: EMPTY
55580: LIST
55581: PUSH
55582: EMPTY
55583: LIST
55584: LIST
55585: PPUSH
55586: CALL_OW 72
55590: PPUSH
55591: CALL_OW 1
55595: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
55596: LD_ADDR_EXP 33
55600: PUSH
55601: LD_EXP 33
55605: PPUSH
55606: LD_VAR 0 2
55610: PPUSH
55611: EMPTY
55612: PPUSH
55613: CALL_OW 1
55617: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
55618: LD_ADDR_EXP 37
55622: PUSH
55623: LD_EXP 37
55627: PPUSH
55628: LD_VAR 0 2
55632: PPUSH
55633: EMPTY
55634: PPUSH
55635: CALL_OW 1
55639: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
55640: LD_ADDR_EXP 36
55644: PUSH
55645: LD_EXP 36
55649: PPUSH
55650: LD_VAR 0 2
55654: PPUSH
55655: EMPTY
55656: PPUSH
55657: CALL_OW 1
55661: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
55662: LD_ADDR_EXP 38
55666: PUSH
55667: LD_EXP 38
55671: PPUSH
55672: LD_VAR 0 2
55676: PPUSH
55677: EMPTY
55678: PPUSH
55679: CALL_OW 1
55683: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
55684: LD_ADDR_EXP 39
55688: PUSH
55689: LD_EXP 39
55693: PPUSH
55694: LD_VAR 0 2
55698: PPUSH
55699: EMPTY
55700: PPUSH
55701: CALL_OW 1
55705: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
55706: LD_ADDR_EXP 40
55710: PUSH
55711: LD_EXP 40
55715: PPUSH
55716: LD_VAR 0 2
55720: PPUSH
55721: EMPTY
55722: PPUSH
55723: CALL_OW 1
55727: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
55728: LD_ADDR_EXP 41
55732: PUSH
55733: LD_EXP 41
55737: PPUSH
55738: LD_VAR 0 2
55742: PPUSH
55743: EMPTY
55744: PPUSH
55745: CALL_OW 1
55749: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
55750: LD_ADDR_EXP 42
55754: PUSH
55755: LD_EXP 42
55759: PPUSH
55760: LD_VAR 0 2
55764: PPUSH
55765: EMPTY
55766: PPUSH
55767: CALL_OW 1
55771: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
55772: LD_ADDR_EXP 43
55776: PUSH
55777: LD_EXP 43
55781: PPUSH
55782: LD_VAR 0 2
55786: PPUSH
55787: EMPTY
55788: PPUSH
55789: CALL_OW 1
55793: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
55794: LD_ADDR_EXP 44
55798: PUSH
55799: LD_EXP 44
55803: PPUSH
55804: LD_VAR 0 2
55808: PPUSH
55809: EMPTY
55810: PPUSH
55811: CALL_OW 1
55815: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
55816: LD_ADDR_EXP 45
55820: PUSH
55821: LD_EXP 45
55825: PPUSH
55826: LD_VAR 0 2
55830: PPUSH
55831: EMPTY
55832: PPUSH
55833: CALL_OW 1
55837: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
55838: LD_ADDR_EXP 34
55842: PUSH
55843: LD_EXP 34
55847: PPUSH
55848: LD_VAR 0 2
55852: PPUSH
55853: LD_INT 0
55855: PPUSH
55856: CALL_OW 1
55860: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
55861: LD_ADDR_EXP 47
55865: PUSH
55866: LD_EXP 47
55870: PPUSH
55871: LD_VAR 0 2
55875: PPUSH
55876: LD_INT 0
55878: PPUSH
55879: CALL_OW 1
55883: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
55884: LD_ADDR_EXP 35
55888: PUSH
55889: LD_EXP 35
55893: PPUSH
55894: LD_VAR 0 2
55898: PPUSH
55899: EMPTY
55900: PPUSH
55901: CALL_OW 1
55905: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
55906: LD_ADDR_EXP 46
55910: PUSH
55911: LD_EXP 46
55915: PPUSH
55916: LD_VAR 0 2
55920: PPUSH
55921: LD_INT 0
55923: PPUSH
55924: CALL_OW 1
55928: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
55929: LD_ADDR_EXP 48
55933: PUSH
55934: LD_EXP 48
55938: PPUSH
55939: LD_VAR 0 2
55943: PPUSH
55944: EMPTY
55945: PPUSH
55946: CALL_OW 1
55950: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
55951: LD_ADDR_EXP 51
55955: PUSH
55956: LD_EXP 51
55960: PPUSH
55961: LD_VAR 0 2
55965: PPUSH
55966: LD_INT 0
55968: PPUSH
55969: CALL_OW 1
55973: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
55974: LD_ADDR_EXP 52
55978: PUSH
55979: LD_EXP 52
55983: PPUSH
55984: LD_VAR 0 2
55988: PPUSH
55989: EMPTY
55990: PPUSH
55991: CALL_OW 1
55995: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
55996: LD_ADDR_EXP 53
56000: PUSH
56001: LD_EXP 53
56005: PPUSH
56006: LD_VAR 0 2
56010: PPUSH
56011: EMPTY
56012: PPUSH
56013: CALL_OW 1
56017: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
56018: LD_ADDR_EXP 54
56022: PUSH
56023: LD_EXP 54
56027: PPUSH
56028: LD_VAR 0 2
56032: PPUSH
56033: EMPTY
56034: PPUSH
56035: CALL_OW 1
56039: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
56040: LD_ADDR_EXP 56
56044: PUSH
56045: LD_EXP 56
56049: PPUSH
56050: LD_VAR 0 2
56054: PPUSH
56055: LD_EXP 23
56059: PUSH
56060: LD_VAR 0 2
56064: ARRAY
56065: PPUSH
56066: LD_INT 2
56068: PUSH
56069: LD_INT 30
56071: PUSH
56072: LD_INT 6
56074: PUSH
56075: EMPTY
56076: LIST
56077: LIST
56078: PUSH
56079: LD_INT 30
56081: PUSH
56082: LD_INT 7
56084: PUSH
56085: EMPTY
56086: LIST
56087: LIST
56088: PUSH
56089: LD_INT 30
56091: PUSH
56092: LD_INT 8
56094: PUSH
56095: EMPTY
56096: LIST
56097: LIST
56098: PUSH
56099: EMPTY
56100: LIST
56101: LIST
56102: LIST
56103: LIST
56104: PPUSH
56105: CALL_OW 72
56109: PPUSH
56110: CALL_OW 1
56114: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
56115: LD_ADDR_EXP 57
56119: PUSH
56120: LD_EXP 57
56124: PPUSH
56125: LD_VAR 0 2
56129: PPUSH
56130: EMPTY
56131: PPUSH
56132: CALL_OW 1
56136: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
56137: LD_ADDR_EXP 58
56141: PUSH
56142: LD_EXP 58
56146: PPUSH
56147: LD_VAR 0 2
56151: PPUSH
56152: EMPTY
56153: PPUSH
56154: CALL_OW 1
56158: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
56159: LD_ADDR_EXP 59
56163: PUSH
56164: LD_EXP 59
56168: PPUSH
56169: LD_VAR 0 2
56173: PPUSH
56174: EMPTY
56175: PPUSH
56176: CALL_OW 1
56180: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
56181: LD_ADDR_EXP 60
56185: PUSH
56186: LD_EXP 60
56190: PPUSH
56191: LD_VAR 0 2
56195: PPUSH
56196: EMPTY
56197: PPUSH
56198: CALL_OW 1
56202: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
56203: LD_ADDR_EXP 61
56207: PUSH
56208: LD_EXP 61
56212: PPUSH
56213: LD_VAR 0 2
56217: PPUSH
56218: EMPTY
56219: PPUSH
56220: CALL_OW 1
56224: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
56225: LD_ADDR_EXP 62
56229: PUSH
56230: LD_EXP 62
56234: PPUSH
56235: LD_VAR 0 2
56239: PPUSH
56240: EMPTY
56241: PPUSH
56242: CALL_OW 1
56246: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
56247: LD_ADDR_EXP 63
56251: PUSH
56252: LD_EXP 63
56256: PPUSH
56257: LD_VAR 0 2
56261: PPUSH
56262: EMPTY
56263: PPUSH
56264: CALL_OW 1
56268: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
56269: LD_ADDR_EXP 64
56273: PUSH
56274: LD_EXP 64
56278: PPUSH
56279: LD_VAR 0 2
56283: PPUSH
56284: EMPTY
56285: PPUSH
56286: CALL_OW 1
56290: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
56291: LD_ADDR_EXP 65
56295: PUSH
56296: LD_EXP 65
56300: PPUSH
56301: LD_VAR 0 2
56305: PPUSH
56306: LD_INT 0
56308: PPUSH
56309: CALL_OW 1
56313: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
56314: LD_ADDR_EXP 66
56318: PUSH
56319: LD_EXP 66
56323: PPUSH
56324: LD_VAR 0 2
56328: PPUSH
56329: LD_INT 0
56331: PPUSH
56332: CALL_OW 1
56336: ST_TO_ADDR
// end ;
56337: GO 55238
56339: POP
56340: POP
// MC_InitSides ( ) ;
56341: CALL 56627 0 0
// MC_InitResearch ( ) ;
56345: CALL 56366 0 0
// CustomInitMacro ( ) ;
56349: CALL 273 0 0
// skirmish := true ;
56353: LD_ADDR_EXP 21
56357: PUSH
56358: LD_INT 1
56360: ST_TO_ADDR
// end ;
56361: LD_VAR 0 1
56365: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
56366: LD_INT 0
56368: PPUSH
56369: PPUSH
56370: PPUSH
56371: PPUSH
56372: PPUSH
56373: PPUSH
// if not mc_bases then
56374: LD_EXP 23
56378: NOT
56379: IFFALSE 56383
// exit ;
56381: GO 56622
// for i = 1 to 8 do
56383: LD_ADDR_VAR 0 2
56387: PUSH
56388: DOUBLE
56389: LD_INT 1
56391: DEC
56392: ST_TO_ADDR
56393: LD_INT 8
56395: PUSH
56396: FOR_TO
56397: IFFALSE 56423
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
56399: LD_ADDR_EXP 50
56403: PUSH
56404: LD_EXP 50
56408: PPUSH
56409: LD_VAR 0 2
56413: PPUSH
56414: EMPTY
56415: PPUSH
56416: CALL_OW 1
56420: ST_TO_ADDR
56421: GO 56396
56423: POP
56424: POP
// tmp := [ ] ;
56425: LD_ADDR_VAR 0 5
56429: PUSH
56430: EMPTY
56431: ST_TO_ADDR
// for i = 1 to mc_sides do
56432: LD_ADDR_VAR 0 2
56436: PUSH
56437: DOUBLE
56438: LD_INT 1
56440: DEC
56441: ST_TO_ADDR
56442: LD_EXP 49
56446: PUSH
56447: FOR_TO
56448: IFFALSE 56506
// if not mc_sides [ i ] in tmp then
56450: LD_EXP 49
56454: PUSH
56455: LD_VAR 0 2
56459: ARRAY
56460: PUSH
56461: LD_VAR 0 5
56465: IN
56466: NOT
56467: IFFALSE 56504
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
56469: LD_ADDR_VAR 0 5
56473: PUSH
56474: LD_VAR 0 5
56478: PPUSH
56479: LD_VAR 0 5
56483: PUSH
56484: LD_INT 1
56486: PLUS
56487: PPUSH
56488: LD_EXP 49
56492: PUSH
56493: LD_VAR 0 2
56497: ARRAY
56498: PPUSH
56499: CALL_OW 2
56503: ST_TO_ADDR
56504: GO 56447
56506: POP
56507: POP
// if not tmp then
56508: LD_VAR 0 5
56512: NOT
56513: IFFALSE 56517
// exit ;
56515: GO 56622
// for j in tmp do
56517: LD_ADDR_VAR 0 3
56521: PUSH
56522: LD_VAR 0 5
56526: PUSH
56527: FOR_IN
56528: IFFALSE 56620
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
56530: LD_ADDR_VAR 0 6
56534: PUSH
56535: LD_INT 22
56537: PUSH
56538: LD_VAR 0 3
56542: PUSH
56543: EMPTY
56544: LIST
56545: LIST
56546: PPUSH
56547: CALL_OW 69
56551: ST_TO_ADDR
// if not un then
56552: LD_VAR 0 6
56556: NOT
56557: IFFALSE 56561
// continue ;
56559: GO 56527
// nation := GetNation ( un [ 1 ] ) ;
56561: LD_ADDR_VAR 0 4
56565: PUSH
56566: LD_VAR 0 6
56570: PUSH
56571: LD_INT 1
56573: ARRAY
56574: PPUSH
56575: CALL_OW 248
56579: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
56580: LD_ADDR_EXP 50
56584: PUSH
56585: LD_EXP 50
56589: PPUSH
56590: LD_VAR 0 3
56594: PPUSH
56595: LD_VAR 0 3
56599: PPUSH
56600: LD_VAR 0 4
56604: PPUSH
56605: LD_INT 1
56607: PPUSH
56608: CALL 11178 0 3
56612: PPUSH
56613: CALL_OW 1
56617: ST_TO_ADDR
// end ;
56618: GO 56527
56620: POP
56621: POP
// end ;
56622: LD_VAR 0 1
56626: RET
// export function MC_InitSides ( ) ; var i ; begin
56627: LD_INT 0
56629: PPUSH
56630: PPUSH
// if not mc_bases then
56631: LD_EXP 23
56635: NOT
56636: IFFALSE 56640
// exit ;
56638: GO 56714
// for i = 1 to mc_bases do
56640: LD_ADDR_VAR 0 2
56644: PUSH
56645: DOUBLE
56646: LD_INT 1
56648: DEC
56649: ST_TO_ADDR
56650: LD_EXP 23
56654: PUSH
56655: FOR_TO
56656: IFFALSE 56712
// if mc_bases [ i ] then
56658: LD_EXP 23
56662: PUSH
56663: LD_VAR 0 2
56667: ARRAY
56668: IFFALSE 56710
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
56670: LD_ADDR_EXP 49
56674: PUSH
56675: LD_EXP 49
56679: PPUSH
56680: LD_VAR 0 2
56684: PPUSH
56685: LD_EXP 23
56689: PUSH
56690: LD_VAR 0 2
56694: ARRAY
56695: PUSH
56696: LD_INT 1
56698: ARRAY
56699: PPUSH
56700: CALL_OW 255
56704: PPUSH
56705: CALL_OW 1
56709: ST_TO_ADDR
56710: GO 56655
56712: POP
56713: POP
// end ;
56714: LD_VAR 0 1
56718: RET
// every 0 0$03 trigger skirmish do
56719: LD_EXP 21
56723: IFFALSE 56877
56725: GO 56727
56727: DISABLE
// begin enable ;
56728: ENABLE
// MC_CheckBuildings ( ) ;
56729: CALL 61389 0 0
// MC_CheckPeopleLife ( ) ;
56733: CALL 61550 0 0
// RaiseSailEvent ( 100 ) ;
56737: LD_INT 100
56739: PPUSH
56740: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
56744: LD_INT 103
56746: PPUSH
56747: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
56751: LD_INT 104
56753: PPUSH
56754: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
56758: LD_INT 105
56760: PPUSH
56761: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
56765: LD_INT 106
56767: PPUSH
56768: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
56772: LD_INT 107
56774: PPUSH
56775: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
56779: LD_INT 108
56781: PPUSH
56782: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
56786: LD_INT 109
56788: PPUSH
56789: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
56793: LD_INT 110
56795: PPUSH
56796: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
56800: LD_INT 111
56802: PPUSH
56803: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
56807: LD_INT 112
56809: PPUSH
56810: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
56814: LD_INT 113
56816: PPUSH
56817: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
56821: LD_INT 120
56823: PPUSH
56824: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
56828: LD_INT 121
56830: PPUSH
56831: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
56835: LD_INT 122
56837: PPUSH
56838: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
56842: LD_INT 123
56844: PPUSH
56845: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
56849: LD_INT 124
56851: PPUSH
56852: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
56856: LD_INT 125
56858: PPUSH
56859: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
56863: LD_INT 126
56865: PPUSH
56866: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
56870: LD_INT 200
56872: PPUSH
56873: CALL_OW 427
// end ;
56877: END
// on SailEvent ( event ) do begin if event < 100 then
56878: LD_VAR 0 1
56882: PUSH
56883: LD_INT 100
56885: LESS
56886: IFFALSE 56897
// CustomEvent ( event ) ;
56888: LD_VAR 0 1
56892: PPUSH
56893: CALL 10329 0 1
// if event = 100 then
56897: LD_VAR 0 1
56901: PUSH
56902: LD_INT 100
56904: EQUAL
56905: IFFALSE 56911
// MC_ClassManager ( ) ;
56907: CALL 57303 0 0
// if event = 101 then
56911: LD_VAR 0 1
56915: PUSH
56916: LD_INT 101
56918: EQUAL
56919: IFFALSE 56925
// MC_RepairBuildings ( ) ;
56921: CALL 62135 0 0
// if event = 102 then
56925: LD_VAR 0 1
56929: PUSH
56930: LD_INT 102
56932: EQUAL
56933: IFFALSE 56939
// MC_Heal ( ) ;
56935: CALL 63070 0 0
// if event = 103 then
56939: LD_VAR 0 1
56943: PUSH
56944: LD_INT 103
56946: EQUAL
56947: IFFALSE 56953
// MC_Build ( ) ;
56949: CALL 63492 0 0
// if event = 104 then
56953: LD_VAR 0 1
56957: PUSH
56958: LD_INT 104
56960: EQUAL
56961: IFFALSE 56967
// MC_TurretWeapon ( ) ;
56963: CALL 65126 0 0
// if event = 105 then
56967: LD_VAR 0 1
56971: PUSH
56972: LD_INT 105
56974: EQUAL
56975: IFFALSE 56981
// MC_BuildUpgrade ( ) ;
56977: CALL 64677 0 0
// if event = 106 then
56981: LD_VAR 0 1
56985: PUSH
56986: LD_INT 106
56988: EQUAL
56989: IFFALSE 56995
// MC_PlantMines ( ) ;
56991: CALL 65556 0 0
// if event = 107 then
56995: LD_VAR 0 1
56999: PUSH
57000: LD_INT 107
57002: EQUAL
57003: IFFALSE 57009
// MC_CollectCrates ( ) ;
57005: CALL 66354 0 0
// if event = 108 then
57009: LD_VAR 0 1
57013: PUSH
57014: LD_INT 108
57016: EQUAL
57017: IFFALSE 57023
// MC_LinkRemoteControl ( ) ;
57019: CALL 68204 0 0
// if event = 109 then
57023: LD_VAR 0 1
57027: PUSH
57028: LD_INT 109
57030: EQUAL
57031: IFFALSE 57037
// MC_ProduceVehicle ( ) ;
57033: CALL 68385 0 0
// if event = 110 then
57037: LD_VAR 0 1
57041: PUSH
57042: LD_INT 110
57044: EQUAL
57045: IFFALSE 57051
// MC_SendAttack ( ) ;
57047: CALL 68851 0 0
// if event = 111 then
57051: LD_VAR 0 1
57055: PUSH
57056: LD_INT 111
57058: EQUAL
57059: IFFALSE 57065
// MC_Defend ( ) ;
57061: CALL 68959 0 0
// if event = 112 then
57065: LD_VAR 0 1
57069: PUSH
57070: LD_INT 112
57072: EQUAL
57073: IFFALSE 57079
// MC_Research ( ) ;
57075: CALL 69839 0 0
// if event = 113 then
57079: LD_VAR 0 1
57083: PUSH
57084: LD_INT 113
57086: EQUAL
57087: IFFALSE 57093
// MC_MinesTrigger ( ) ;
57089: CALL 70953 0 0
// if event = 120 then
57093: LD_VAR 0 1
57097: PUSH
57098: LD_INT 120
57100: EQUAL
57101: IFFALSE 57107
// MC_RepairVehicle ( ) ;
57103: CALL 71052 0 0
// if event = 121 then
57107: LD_VAR 0 1
57111: PUSH
57112: LD_INT 121
57114: EQUAL
57115: IFFALSE 57121
// MC_TameApe ( ) ;
57117: CALL 71821 0 0
// if event = 122 then
57121: LD_VAR 0 1
57125: PUSH
57126: LD_INT 122
57128: EQUAL
57129: IFFALSE 57135
// MC_ChangeApeClass ( ) ;
57131: CALL 72650 0 0
// if event = 123 then
57135: LD_VAR 0 1
57139: PUSH
57140: LD_INT 123
57142: EQUAL
57143: IFFALSE 57149
// MC_Bazooka ( ) ;
57145: CALL 73300 0 0
// if event = 124 then
57149: LD_VAR 0 1
57153: PUSH
57154: LD_INT 124
57156: EQUAL
57157: IFFALSE 57163
// MC_TeleportExit ( ) ;
57159: CALL 73498 0 0
// if event = 125 then
57163: LD_VAR 0 1
57167: PUSH
57168: LD_INT 125
57170: EQUAL
57171: IFFALSE 57177
// MC_Deposits ( ) ;
57173: CALL 74145 0 0
// if event = 126 then
57177: LD_VAR 0 1
57181: PUSH
57182: LD_INT 126
57184: EQUAL
57185: IFFALSE 57191
// MC_RemoteDriver ( ) ;
57187: CALL 74770 0 0
// if event = 200 then
57191: LD_VAR 0 1
57195: PUSH
57196: LD_INT 200
57198: EQUAL
57199: IFFALSE 57205
// MC_Idle ( ) ;
57201: CALL 76677 0 0
// end ;
57205: PPOPN 1
57207: END
// export function MC_Reset ( base , tag ) ; var i ; begin
57208: LD_INT 0
57210: PPUSH
57211: PPUSH
// if not mc_bases [ base ] or not tag then
57212: LD_EXP 23
57216: PUSH
57217: LD_VAR 0 1
57221: ARRAY
57222: NOT
57223: PUSH
57224: LD_VAR 0 2
57228: NOT
57229: OR
57230: IFFALSE 57234
// exit ;
57232: GO 57298
// for i in mc_bases [ base ] union mc_ape [ base ] do
57234: LD_ADDR_VAR 0 4
57238: PUSH
57239: LD_EXP 23
57243: PUSH
57244: LD_VAR 0 1
57248: ARRAY
57249: PUSH
57250: LD_EXP 52
57254: PUSH
57255: LD_VAR 0 1
57259: ARRAY
57260: UNION
57261: PUSH
57262: FOR_IN
57263: IFFALSE 57296
// if GetTag ( i ) = tag then
57265: LD_VAR 0 4
57269: PPUSH
57270: CALL_OW 110
57274: PUSH
57275: LD_VAR 0 2
57279: EQUAL
57280: IFFALSE 57294
// SetTag ( i , 0 ) ;
57282: LD_VAR 0 4
57286: PPUSH
57287: LD_INT 0
57289: PPUSH
57290: CALL_OW 109
57294: GO 57262
57296: POP
57297: POP
// end ;
57298: LD_VAR 0 3
57302: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
57303: LD_INT 0
57305: PPUSH
57306: PPUSH
57307: PPUSH
57308: PPUSH
57309: PPUSH
57310: PPUSH
57311: PPUSH
57312: PPUSH
// if not mc_bases then
57313: LD_EXP 23
57317: NOT
57318: IFFALSE 57322
// exit ;
57320: GO 57771
// for i = 1 to mc_bases do
57322: LD_ADDR_VAR 0 2
57326: PUSH
57327: DOUBLE
57328: LD_INT 1
57330: DEC
57331: ST_TO_ADDR
57332: LD_EXP 23
57336: PUSH
57337: FOR_TO
57338: IFFALSE 57769
// begin tmp := MC_ClassCheckReq ( i ) ;
57340: LD_ADDR_VAR 0 4
57344: PUSH
57345: LD_VAR 0 2
57349: PPUSH
57350: CALL 57776 0 1
57354: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
57355: LD_ADDR_EXP 64
57359: PUSH
57360: LD_EXP 64
57364: PPUSH
57365: LD_VAR 0 2
57369: PPUSH
57370: LD_VAR 0 4
57374: PPUSH
57375: CALL_OW 1
57379: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
57380: LD_ADDR_VAR 0 6
57384: PUSH
57385: LD_EXP 23
57389: PUSH
57390: LD_VAR 0 2
57394: ARRAY
57395: PPUSH
57396: LD_INT 2
57398: PUSH
57399: LD_INT 30
57401: PUSH
57402: LD_INT 4
57404: PUSH
57405: EMPTY
57406: LIST
57407: LIST
57408: PUSH
57409: LD_INT 30
57411: PUSH
57412: LD_INT 5
57414: PUSH
57415: EMPTY
57416: LIST
57417: LIST
57418: PUSH
57419: EMPTY
57420: LIST
57421: LIST
57422: LIST
57423: PPUSH
57424: CALL_OW 72
57428: PUSH
57429: LD_EXP 23
57433: PUSH
57434: LD_VAR 0 2
57438: ARRAY
57439: PPUSH
57440: LD_INT 2
57442: PUSH
57443: LD_INT 30
57445: PUSH
57446: LD_INT 0
57448: PUSH
57449: EMPTY
57450: LIST
57451: LIST
57452: PUSH
57453: LD_INT 30
57455: PUSH
57456: LD_INT 1
57458: PUSH
57459: EMPTY
57460: LIST
57461: LIST
57462: PUSH
57463: EMPTY
57464: LIST
57465: LIST
57466: LIST
57467: PPUSH
57468: CALL_OW 72
57472: PUSH
57473: LD_EXP 23
57477: PUSH
57478: LD_VAR 0 2
57482: ARRAY
57483: PPUSH
57484: LD_INT 30
57486: PUSH
57487: LD_INT 3
57489: PUSH
57490: EMPTY
57491: LIST
57492: LIST
57493: PPUSH
57494: CALL_OW 72
57498: PUSH
57499: LD_EXP 23
57503: PUSH
57504: LD_VAR 0 2
57508: ARRAY
57509: PPUSH
57510: LD_INT 2
57512: PUSH
57513: LD_INT 30
57515: PUSH
57516: LD_INT 6
57518: PUSH
57519: EMPTY
57520: LIST
57521: LIST
57522: PUSH
57523: LD_INT 30
57525: PUSH
57526: LD_INT 7
57528: PUSH
57529: EMPTY
57530: LIST
57531: LIST
57532: PUSH
57533: LD_INT 30
57535: PUSH
57536: LD_INT 8
57538: PUSH
57539: EMPTY
57540: LIST
57541: LIST
57542: PUSH
57543: EMPTY
57544: LIST
57545: LIST
57546: LIST
57547: LIST
57548: PPUSH
57549: CALL_OW 72
57553: PUSH
57554: EMPTY
57555: LIST
57556: LIST
57557: LIST
57558: LIST
57559: ST_TO_ADDR
// for j := 1 to 4 do
57560: LD_ADDR_VAR 0 3
57564: PUSH
57565: DOUBLE
57566: LD_INT 1
57568: DEC
57569: ST_TO_ADDR
57570: LD_INT 4
57572: PUSH
57573: FOR_TO
57574: IFFALSE 57765
// begin if not tmp [ j ] then
57576: LD_VAR 0 4
57580: PUSH
57581: LD_VAR 0 3
57585: ARRAY
57586: NOT
57587: IFFALSE 57591
// continue ;
57589: GO 57573
// for p in tmp [ j ] do
57591: LD_ADDR_VAR 0 5
57595: PUSH
57596: LD_VAR 0 4
57600: PUSH
57601: LD_VAR 0 3
57605: ARRAY
57606: PUSH
57607: FOR_IN
57608: IFFALSE 57761
// begin if not b [ j ] then
57610: LD_VAR 0 6
57614: PUSH
57615: LD_VAR 0 3
57619: ARRAY
57620: NOT
57621: IFFALSE 57625
// break ;
57623: GO 57761
// e := 0 ;
57625: LD_ADDR_VAR 0 7
57629: PUSH
57630: LD_INT 0
57632: ST_TO_ADDR
// for k in b [ j ] do
57633: LD_ADDR_VAR 0 8
57637: PUSH
57638: LD_VAR 0 6
57642: PUSH
57643: LD_VAR 0 3
57647: ARRAY
57648: PUSH
57649: FOR_IN
57650: IFFALSE 57677
// if IsNotFull ( k ) then
57652: LD_VAR 0 8
57656: PPUSH
57657: CALL 13299 0 1
57661: IFFALSE 57675
// begin e := k ;
57663: LD_ADDR_VAR 0 7
57667: PUSH
57668: LD_VAR 0 8
57672: ST_TO_ADDR
// break ;
57673: GO 57677
// end ;
57675: GO 57649
57677: POP
57678: POP
// if e and not UnitGoingToBuilding ( p , e ) then
57679: LD_VAR 0 7
57683: PUSH
57684: LD_VAR 0 5
57688: PPUSH
57689: LD_VAR 0 7
57693: PPUSH
57694: CALL 47449 0 2
57698: NOT
57699: AND
57700: IFFALSE 57759
// begin if IsInUnit ( p ) then
57702: LD_VAR 0 5
57706: PPUSH
57707: CALL_OW 310
57711: IFFALSE 57722
// ComExitBuilding ( p ) ;
57713: LD_VAR 0 5
57717: PPUSH
57718: CALL_OW 122
// ComEnterUnit ( p , e ) ;
57722: LD_VAR 0 5
57726: PPUSH
57727: LD_VAR 0 7
57731: PPUSH
57732: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
57736: LD_VAR 0 5
57740: PPUSH
57741: LD_VAR 0 3
57745: PPUSH
57746: CALL_OW 183
// AddComExitBuilding ( p ) ;
57750: LD_VAR 0 5
57754: PPUSH
57755: CALL_OW 182
// end ; end ;
57759: GO 57607
57761: POP
57762: POP
// end ;
57763: GO 57573
57765: POP
57766: POP
// end ;
57767: GO 57337
57769: POP
57770: POP
// end ;
57771: LD_VAR 0 1
57775: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
57776: LD_INT 0
57778: PPUSH
57779: PPUSH
57780: PPUSH
57781: PPUSH
57782: PPUSH
57783: PPUSH
57784: PPUSH
57785: PPUSH
57786: PPUSH
57787: PPUSH
57788: PPUSH
57789: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
57790: LD_ADDR_VAR 0 2
57794: PUSH
57795: LD_INT 0
57797: PUSH
57798: LD_INT 0
57800: PUSH
57801: LD_INT 0
57803: PUSH
57804: LD_INT 0
57806: PUSH
57807: EMPTY
57808: LIST
57809: LIST
57810: LIST
57811: LIST
57812: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
57813: LD_VAR 0 1
57817: NOT
57818: PUSH
57819: LD_EXP 23
57823: PUSH
57824: LD_VAR 0 1
57828: ARRAY
57829: NOT
57830: OR
57831: PUSH
57832: LD_EXP 23
57836: PUSH
57837: LD_VAR 0 1
57841: ARRAY
57842: PPUSH
57843: LD_INT 2
57845: PUSH
57846: LD_INT 30
57848: PUSH
57849: LD_INT 0
57851: PUSH
57852: EMPTY
57853: LIST
57854: LIST
57855: PUSH
57856: LD_INT 30
57858: PUSH
57859: LD_INT 1
57861: PUSH
57862: EMPTY
57863: LIST
57864: LIST
57865: PUSH
57866: EMPTY
57867: LIST
57868: LIST
57869: LIST
57870: PPUSH
57871: CALL_OW 72
57875: NOT
57876: OR
57877: IFFALSE 57881
// exit ;
57879: GO 61384
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
57881: LD_ADDR_VAR 0 4
57885: PUSH
57886: LD_EXP 23
57890: PUSH
57891: LD_VAR 0 1
57895: ARRAY
57896: PPUSH
57897: LD_INT 2
57899: PUSH
57900: LD_INT 25
57902: PUSH
57903: LD_INT 1
57905: PUSH
57906: EMPTY
57907: LIST
57908: LIST
57909: PUSH
57910: LD_INT 25
57912: PUSH
57913: LD_INT 2
57915: PUSH
57916: EMPTY
57917: LIST
57918: LIST
57919: PUSH
57920: LD_INT 25
57922: PUSH
57923: LD_INT 3
57925: PUSH
57926: EMPTY
57927: LIST
57928: LIST
57929: PUSH
57930: LD_INT 25
57932: PUSH
57933: LD_INT 4
57935: PUSH
57936: EMPTY
57937: LIST
57938: LIST
57939: PUSH
57940: LD_INT 25
57942: PUSH
57943: LD_INT 5
57945: PUSH
57946: EMPTY
57947: LIST
57948: LIST
57949: PUSH
57950: LD_INT 25
57952: PUSH
57953: LD_INT 8
57955: PUSH
57956: EMPTY
57957: LIST
57958: LIST
57959: PUSH
57960: LD_INT 25
57962: PUSH
57963: LD_INT 9
57965: PUSH
57966: EMPTY
57967: LIST
57968: LIST
57969: PUSH
57970: EMPTY
57971: LIST
57972: LIST
57973: LIST
57974: LIST
57975: LIST
57976: LIST
57977: LIST
57978: LIST
57979: PPUSH
57980: CALL_OW 72
57984: ST_TO_ADDR
// if not tmp then
57985: LD_VAR 0 4
57989: NOT
57990: IFFALSE 57994
// exit ;
57992: GO 61384
// for i in tmp do
57994: LD_ADDR_VAR 0 3
57998: PUSH
57999: LD_VAR 0 4
58003: PUSH
58004: FOR_IN
58005: IFFALSE 58036
// if GetTag ( i ) then
58007: LD_VAR 0 3
58011: PPUSH
58012: CALL_OW 110
58016: IFFALSE 58034
// tmp := tmp diff i ;
58018: LD_ADDR_VAR 0 4
58022: PUSH
58023: LD_VAR 0 4
58027: PUSH
58028: LD_VAR 0 3
58032: DIFF
58033: ST_TO_ADDR
58034: GO 58004
58036: POP
58037: POP
// if not tmp then
58038: LD_VAR 0 4
58042: NOT
58043: IFFALSE 58047
// exit ;
58045: GO 61384
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
58047: LD_ADDR_VAR 0 5
58051: PUSH
58052: LD_EXP 23
58056: PUSH
58057: LD_VAR 0 1
58061: ARRAY
58062: PPUSH
58063: LD_INT 2
58065: PUSH
58066: LD_INT 25
58068: PUSH
58069: LD_INT 1
58071: PUSH
58072: EMPTY
58073: LIST
58074: LIST
58075: PUSH
58076: LD_INT 25
58078: PUSH
58079: LD_INT 5
58081: PUSH
58082: EMPTY
58083: LIST
58084: LIST
58085: PUSH
58086: LD_INT 25
58088: PUSH
58089: LD_INT 8
58091: PUSH
58092: EMPTY
58093: LIST
58094: LIST
58095: PUSH
58096: LD_INT 25
58098: PUSH
58099: LD_INT 9
58101: PUSH
58102: EMPTY
58103: LIST
58104: LIST
58105: PUSH
58106: EMPTY
58107: LIST
58108: LIST
58109: LIST
58110: LIST
58111: LIST
58112: PPUSH
58113: CALL_OW 72
58117: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
58118: LD_ADDR_VAR 0 6
58122: PUSH
58123: LD_EXP 23
58127: PUSH
58128: LD_VAR 0 1
58132: ARRAY
58133: PPUSH
58134: LD_INT 25
58136: PUSH
58137: LD_INT 2
58139: PUSH
58140: EMPTY
58141: LIST
58142: LIST
58143: PPUSH
58144: CALL_OW 72
58148: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
58149: LD_ADDR_VAR 0 7
58153: PUSH
58154: LD_EXP 23
58158: PUSH
58159: LD_VAR 0 1
58163: ARRAY
58164: PPUSH
58165: LD_INT 25
58167: PUSH
58168: LD_INT 3
58170: PUSH
58171: EMPTY
58172: LIST
58173: LIST
58174: PPUSH
58175: CALL_OW 72
58179: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
58180: LD_ADDR_VAR 0 8
58184: PUSH
58185: LD_EXP 23
58189: PUSH
58190: LD_VAR 0 1
58194: ARRAY
58195: PPUSH
58196: LD_INT 25
58198: PUSH
58199: LD_INT 4
58201: PUSH
58202: EMPTY
58203: LIST
58204: LIST
58205: PUSH
58206: LD_INT 24
58208: PUSH
58209: LD_INT 251
58211: PUSH
58212: EMPTY
58213: LIST
58214: LIST
58215: PUSH
58216: EMPTY
58217: LIST
58218: LIST
58219: PPUSH
58220: CALL_OW 72
58224: ST_TO_ADDR
// if mc_is_defending [ base ] then
58225: LD_EXP 66
58229: PUSH
58230: LD_VAR 0 1
58234: ARRAY
58235: IFFALSE 58696
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
58237: LD_ADDR_EXP 65
58241: PUSH
58242: LD_EXP 65
58246: PPUSH
58247: LD_VAR 0 1
58251: PPUSH
58252: LD_INT 4
58254: PPUSH
58255: CALL_OW 1
58259: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
58260: LD_ADDR_VAR 0 12
58264: PUSH
58265: LD_EXP 23
58269: PUSH
58270: LD_VAR 0 1
58274: ARRAY
58275: PPUSH
58276: LD_INT 2
58278: PUSH
58279: LD_INT 30
58281: PUSH
58282: LD_INT 4
58284: PUSH
58285: EMPTY
58286: LIST
58287: LIST
58288: PUSH
58289: LD_INT 30
58291: PUSH
58292: LD_INT 5
58294: PUSH
58295: EMPTY
58296: LIST
58297: LIST
58298: PUSH
58299: EMPTY
58300: LIST
58301: LIST
58302: LIST
58303: PPUSH
58304: CALL_OW 72
58308: ST_TO_ADDR
// if not b then
58309: LD_VAR 0 12
58313: NOT
58314: IFFALSE 58318
// exit ;
58316: GO 61384
// p := [ ] ;
58318: LD_ADDR_VAR 0 11
58322: PUSH
58323: EMPTY
58324: ST_TO_ADDR
// if sci >= 2 then
58325: LD_VAR 0 8
58329: PUSH
58330: LD_INT 2
58332: GREATEREQUAL
58333: IFFALSE 58364
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
58335: LD_ADDR_VAR 0 8
58339: PUSH
58340: LD_VAR 0 8
58344: PUSH
58345: LD_INT 1
58347: ARRAY
58348: PUSH
58349: LD_VAR 0 8
58353: PUSH
58354: LD_INT 2
58356: ARRAY
58357: PUSH
58358: EMPTY
58359: LIST
58360: LIST
58361: ST_TO_ADDR
58362: GO 58425
// if sci = 1 then
58364: LD_VAR 0 8
58368: PUSH
58369: LD_INT 1
58371: EQUAL
58372: IFFALSE 58393
// sci := [ sci [ 1 ] ] else
58374: LD_ADDR_VAR 0 8
58378: PUSH
58379: LD_VAR 0 8
58383: PUSH
58384: LD_INT 1
58386: ARRAY
58387: PUSH
58388: EMPTY
58389: LIST
58390: ST_TO_ADDR
58391: GO 58425
// if sci = 0 then
58393: LD_VAR 0 8
58397: PUSH
58398: LD_INT 0
58400: EQUAL
58401: IFFALSE 58425
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
58403: LD_ADDR_VAR 0 11
58407: PUSH
58408: LD_VAR 0 4
58412: PPUSH
58413: LD_INT 4
58415: PPUSH
58416: CALL 47321 0 2
58420: PUSH
58421: LD_INT 1
58423: ARRAY
58424: ST_TO_ADDR
// if eng > 4 then
58425: LD_VAR 0 6
58429: PUSH
58430: LD_INT 4
58432: GREATER
58433: IFFALSE 58479
// for i = eng downto 4 do
58435: LD_ADDR_VAR 0 3
58439: PUSH
58440: DOUBLE
58441: LD_VAR 0 6
58445: INC
58446: ST_TO_ADDR
58447: LD_INT 4
58449: PUSH
58450: FOR_DOWNTO
58451: IFFALSE 58477
// eng := eng diff eng [ i ] ;
58453: LD_ADDR_VAR 0 6
58457: PUSH
58458: LD_VAR 0 6
58462: PUSH
58463: LD_VAR 0 6
58467: PUSH
58468: LD_VAR 0 3
58472: ARRAY
58473: DIFF
58474: ST_TO_ADDR
58475: GO 58450
58477: POP
58478: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
58479: LD_ADDR_VAR 0 4
58483: PUSH
58484: LD_VAR 0 4
58488: PUSH
58489: LD_VAR 0 5
58493: PUSH
58494: LD_VAR 0 6
58498: UNION
58499: PUSH
58500: LD_VAR 0 7
58504: UNION
58505: PUSH
58506: LD_VAR 0 8
58510: UNION
58511: DIFF
58512: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
58513: LD_ADDR_VAR 0 13
58517: PUSH
58518: LD_EXP 23
58522: PUSH
58523: LD_VAR 0 1
58527: ARRAY
58528: PPUSH
58529: LD_INT 2
58531: PUSH
58532: LD_INT 30
58534: PUSH
58535: LD_INT 32
58537: PUSH
58538: EMPTY
58539: LIST
58540: LIST
58541: PUSH
58542: LD_INT 30
58544: PUSH
58545: LD_INT 31
58547: PUSH
58548: EMPTY
58549: LIST
58550: LIST
58551: PUSH
58552: EMPTY
58553: LIST
58554: LIST
58555: LIST
58556: PPUSH
58557: CALL_OW 72
58561: PUSH
58562: LD_EXP 23
58566: PUSH
58567: LD_VAR 0 1
58571: ARRAY
58572: PPUSH
58573: LD_INT 2
58575: PUSH
58576: LD_INT 30
58578: PUSH
58579: LD_INT 4
58581: PUSH
58582: EMPTY
58583: LIST
58584: LIST
58585: PUSH
58586: LD_INT 30
58588: PUSH
58589: LD_INT 5
58591: PUSH
58592: EMPTY
58593: LIST
58594: LIST
58595: PUSH
58596: EMPTY
58597: LIST
58598: LIST
58599: LIST
58600: PPUSH
58601: CALL_OW 72
58605: PUSH
58606: LD_INT 6
58608: MUL
58609: PLUS
58610: ST_TO_ADDR
// if bcount < tmp then
58611: LD_VAR 0 13
58615: PUSH
58616: LD_VAR 0 4
58620: LESS
58621: IFFALSE 58667
// for i = tmp downto bcount do
58623: LD_ADDR_VAR 0 3
58627: PUSH
58628: DOUBLE
58629: LD_VAR 0 4
58633: INC
58634: ST_TO_ADDR
58635: LD_VAR 0 13
58639: PUSH
58640: FOR_DOWNTO
58641: IFFALSE 58665
// tmp := Delete ( tmp , tmp ) ;
58643: LD_ADDR_VAR 0 4
58647: PUSH
58648: LD_VAR 0 4
58652: PPUSH
58653: LD_VAR 0 4
58657: PPUSH
58658: CALL_OW 3
58662: ST_TO_ADDR
58663: GO 58640
58665: POP
58666: POP
// result := [ tmp , 0 , 0 , p ] ;
58667: LD_ADDR_VAR 0 2
58671: PUSH
58672: LD_VAR 0 4
58676: PUSH
58677: LD_INT 0
58679: PUSH
58680: LD_INT 0
58682: PUSH
58683: LD_VAR 0 11
58687: PUSH
58688: EMPTY
58689: LIST
58690: LIST
58691: LIST
58692: LIST
58693: ST_TO_ADDR
// exit ;
58694: GO 61384
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
58696: LD_EXP 23
58700: PUSH
58701: LD_VAR 0 1
58705: ARRAY
58706: PPUSH
58707: LD_INT 2
58709: PUSH
58710: LD_INT 30
58712: PUSH
58713: LD_INT 6
58715: PUSH
58716: EMPTY
58717: LIST
58718: LIST
58719: PUSH
58720: LD_INT 30
58722: PUSH
58723: LD_INT 7
58725: PUSH
58726: EMPTY
58727: LIST
58728: LIST
58729: PUSH
58730: LD_INT 30
58732: PUSH
58733: LD_INT 8
58735: PUSH
58736: EMPTY
58737: LIST
58738: LIST
58739: PUSH
58740: EMPTY
58741: LIST
58742: LIST
58743: LIST
58744: LIST
58745: PPUSH
58746: CALL_OW 72
58750: NOT
58751: PUSH
58752: LD_EXP 23
58756: PUSH
58757: LD_VAR 0 1
58761: ARRAY
58762: PPUSH
58763: LD_INT 30
58765: PUSH
58766: LD_INT 3
58768: PUSH
58769: EMPTY
58770: LIST
58771: LIST
58772: PPUSH
58773: CALL_OW 72
58777: NOT
58778: AND
58779: IFFALSE 58851
// begin if eng = tmp then
58781: LD_VAR 0 6
58785: PUSH
58786: LD_VAR 0 4
58790: EQUAL
58791: IFFALSE 58795
// exit ;
58793: GO 61384
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
58795: LD_ADDR_EXP 65
58799: PUSH
58800: LD_EXP 65
58804: PPUSH
58805: LD_VAR 0 1
58809: PPUSH
58810: LD_INT 1
58812: PPUSH
58813: CALL_OW 1
58817: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
58818: LD_ADDR_VAR 0 2
58822: PUSH
58823: LD_INT 0
58825: PUSH
58826: LD_VAR 0 4
58830: PUSH
58831: LD_VAR 0 6
58835: DIFF
58836: PUSH
58837: LD_INT 0
58839: PUSH
58840: LD_INT 0
58842: PUSH
58843: EMPTY
58844: LIST
58845: LIST
58846: LIST
58847: LIST
58848: ST_TO_ADDR
// exit ;
58849: GO 61384
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
58851: LD_EXP 50
58855: PUSH
58856: LD_EXP 49
58860: PUSH
58861: LD_VAR 0 1
58865: ARRAY
58866: ARRAY
58867: PUSH
58868: LD_EXP 23
58872: PUSH
58873: LD_VAR 0 1
58877: ARRAY
58878: PPUSH
58879: LD_INT 2
58881: PUSH
58882: LD_INT 30
58884: PUSH
58885: LD_INT 6
58887: PUSH
58888: EMPTY
58889: LIST
58890: LIST
58891: PUSH
58892: LD_INT 30
58894: PUSH
58895: LD_INT 7
58897: PUSH
58898: EMPTY
58899: LIST
58900: LIST
58901: PUSH
58902: LD_INT 30
58904: PUSH
58905: LD_INT 8
58907: PUSH
58908: EMPTY
58909: LIST
58910: LIST
58911: PUSH
58912: EMPTY
58913: LIST
58914: LIST
58915: LIST
58916: LIST
58917: PPUSH
58918: CALL_OW 72
58922: AND
58923: PUSH
58924: LD_EXP 23
58928: PUSH
58929: LD_VAR 0 1
58933: ARRAY
58934: PPUSH
58935: LD_INT 30
58937: PUSH
58938: LD_INT 3
58940: PUSH
58941: EMPTY
58942: LIST
58943: LIST
58944: PPUSH
58945: CALL_OW 72
58949: NOT
58950: AND
58951: IFFALSE 59165
// begin if sci >= 6 then
58953: LD_VAR 0 8
58957: PUSH
58958: LD_INT 6
58960: GREATEREQUAL
58961: IFFALSE 58965
// exit ;
58963: GO 61384
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
58965: LD_ADDR_EXP 65
58969: PUSH
58970: LD_EXP 65
58974: PPUSH
58975: LD_VAR 0 1
58979: PPUSH
58980: LD_INT 2
58982: PPUSH
58983: CALL_OW 1
58987: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
58988: LD_ADDR_VAR 0 9
58992: PUSH
58993: LD_VAR 0 4
58997: PUSH
58998: LD_VAR 0 8
59002: DIFF
59003: PPUSH
59004: LD_INT 4
59006: PPUSH
59007: CALL 47321 0 2
59011: ST_TO_ADDR
// p := [ ] ;
59012: LD_ADDR_VAR 0 11
59016: PUSH
59017: EMPTY
59018: ST_TO_ADDR
// if sci < 6 and sort > 6 then
59019: LD_VAR 0 8
59023: PUSH
59024: LD_INT 6
59026: LESS
59027: PUSH
59028: LD_VAR 0 9
59032: PUSH
59033: LD_INT 6
59035: GREATER
59036: AND
59037: IFFALSE 59118
// begin for i = 1 to 6 - sci do
59039: LD_ADDR_VAR 0 3
59043: PUSH
59044: DOUBLE
59045: LD_INT 1
59047: DEC
59048: ST_TO_ADDR
59049: LD_INT 6
59051: PUSH
59052: LD_VAR 0 8
59056: MINUS
59057: PUSH
59058: FOR_TO
59059: IFFALSE 59114
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
59061: LD_ADDR_VAR 0 11
59065: PUSH
59066: LD_VAR 0 11
59070: PPUSH
59071: LD_VAR 0 11
59075: PUSH
59076: LD_INT 1
59078: PLUS
59079: PPUSH
59080: LD_VAR 0 9
59084: PUSH
59085: LD_INT 1
59087: ARRAY
59088: PPUSH
59089: CALL_OW 2
59093: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
59094: LD_ADDR_VAR 0 9
59098: PUSH
59099: LD_VAR 0 9
59103: PPUSH
59104: LD_INT 1
59106: PPUSH
59107: CALL_OW 3
59111: ST_TO_ADDR
// end ;
59112: GO 59058
59114: POP
59115: POP
// end else
59116: GO 59138
// if sort then
59118: LD_VAR 0 9
59122: IFFALSE 59138
// p := sort [ 1 ] ;
59124: LD_ADDR_VAR 0 11
59128: PUSH
59129: LD_VAR 0 9
59133: PUSH
59134: LD_INT 1
59136: ARRAY
59137: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
59138: LD_ADDR_VAR 0 2
59142: PUSH
59143: LD_INT 0
59145: PUSH
59146: LD_INT 0
59148: PUSH
59149: LD_INT 0
59151: PUSH
59152: LD_VAR 0 11
59156: PUSH
59157: EMPTY
59158: LIST
59159: LIST
59160: LIST
59161: LIST
59162: ST_TO_ADDR
// exit ;
59163: GO 61384
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
59165: LD_EXP 50
59169: PUSH
59170: LD_EXP 49
59174: PUSH
59175: LD_VAR 0 1
59179: ARRAY
59180: ARRAY
59181: PUSH
59182: LD_EXP 23
59186: PUSH
59187: LD_VAR 0 1
59191: ARRAY
59192: PPUSH
59193: LD_INT 2
59195: PUSH
59196: LD_INT 30
59198: PUSH
59199: LD_INT 6
59201: PUSH
59202: EMPTY
59203: LIST
59204: LIST
59205: PUSH
59206: LD_INT 30
59208: PUSH
59209: LD_INT 7
59211: PUSH
59212: EMPTY
59213: LIST
59214: LIST
59215: PUSH
59216: LD_INT 30
59218: PUSH
59219: LD_INT 8
59221: PUSH
59222: EMPTY
59223: LIST
59224: LIST
59225: PUSH
59226: EMPTY
59227: LIST
59228: LIST
59229: LIST
59230: LIST
59231: PPUSH
59232: CALL_OW 72
59236: AND
59237: PUSH
59238: LD_EXP 23
59242: PUSH
59243: LD_VAR 0 1
59247: ARRAY
59248: PPUSH
59249: LD_INT 30
59251: PUSH
59252: LD_INT 3
59254: PUSH
59255: EMPTY
59256: LIST
59257: LIST
59258: PPUSH
59259: CALL_OW 72
59263: AND
59264: IFFALSE 59998
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
59266: LD_ADDR_EXP 65
59270: PUSH
59271: LD_EXP 65
59275: PPUSH
59276: LD_VAR 0 1
59280: PPUSH
59281: LD_INT 3
59283: PPUSH
59284: CALL_OW 1
59288: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
59289: LD_ADDR_VAR 0 2
59293: PUSH
59294: LD_INT 0
59296: PUSH
59297: LD_INT 0
59299: PUSH
59300: LD_INT 0
59302: PUSH
59303: LD_INT 0
59305: PUSH
59306: EMPTY
59307: LIST
59308: LIST
59309: LIST
59310: LIST
59311: ST_TO_ADDR
// if not eng then
59312: LD_VAR 0 6
59316: NOT
59317: IFFALSE 59380
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
59319: LD_ADDR_VAR 0 11
59323: PUSH
59324: LD_VAR 0 4
59328: PPUSH
59329: LD_INT 2
59331: PPUSH
59332: CALL 47321 0 2
59336: PUSH
59337: LD_INT 1
59339: ARRAY
59340: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
59341: LD_ADDR_VAR 0 2
59345: PUSH
59346: LD_VAR 0 2
59350: PPUSH
59351: LD_INT 2
59353: PPUSH
59354: LD_VAR 0 11
59358: PPUSH
59359: CALL_OW 1
59363: ST_TO_ADDR
// tmp := tmp diff p ;
59364: LD_ADDR_VAR 0 4
59368: PUSH
59369: LD_VAR 0 4
59373: PUSH
59374: LD_VAR 0 11
59378: DIFF
59379: ST_TO_ADDR
// end ; if tmp and sci < 6 then
59380: LD_VAR 0 4
59384: PUSH
59385: LD_VAR 0 8
59389: PUSH
59390: LD_INT 6
59392: LESS
59393: AND
59394: IFFALSE 59582
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
59396: LD_ADDR_VAR 0 9
59400: PUSH
59401: LD_VAR 0 4
59405: PUSH
59406: LD_VAR 0 8
59410: PUSH
59411: LD_VAR 0 7
59415: UNION
59416: DIFF
59417: PPUSH
59418: LD_INT 4
59420: PPUSH
59421: CALL 47321 0 2
59425: ST_TO_ADDR
// p := [ ] ;
59426: LD_ADDR_VAR 0 11
59430: PUSH
59431: EMPTY
59432: ST_TO_ADDR
// if sort then
59433: LD_VAR 0 9
59437: IFFALSE 59553
// for i = 1 to 6 - sci do
59439: LD_ADDR_VAR 0 3
59443: PUSH
59444: DOUBLE
59445: LD_INT 1
59447: DEC
59448: ST_TO_ADDR
59449: LD_INT 6
59451: PUSH
59452: LD_VAR 0 8
59456: MINUS
59457: PUSH
59458: FOR_TO
59459: IFFALSE 59551
// begin if i = sort then
59461: LD_VAR 0 3
59465: PUSH
59466: LD_VAR 0 9
59470: EQUAL
59471: IFFALSE 59475
// break ;
59473: GO 59551
// if GetClass ( i ) = 4 then
59475: LD_VAR 0 3
59479: PPUSH
59480: CALL_OW 257
59484: PUSH
59485: LD_INT 4
59487: EQUAL
59488: IFFALSE 59492
// continue ;
59490: GO 59458
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59492: LD_ADDR_VAR 0 11
59496: PUSH
59497: LD_VAR 0 11
59501: PPUSH
59502: LD_VAR 0 11
59506: PUSH
59507: LD_INT 1
59509: PLUS
59510: PPUSH
59511: LD_VAR 0 9
59515: PUSH
59516: LD_VAR 0 3
59520: ARRAY
59521: PPUSH
59522: CALL_OW 2
59526: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59527: LD_ADDR_VAR 0 4
59531: PUSH
59532: LD_VAR 0 4
59536: PUSH
59537: LD_VAR 0 9
59541: PUSH
59542: LD_VAR 0 3
59546: ARRAY
59547: DIFF
59548: ST_TO_ADDR
// end ;
59549: GO 59458
59551: POP
59552: POP
// if p then
59553: LD_VAR 0 11
59557: IFFALSE 59582
// result := Replace ( result , 4 , p ) ;
59559: LD_ADDR_VAR 0 2
59563: PUSH
59564: LD_VAR 0 2
59568: PPUSH
59569: LD_INT 4
59571: PPUSH
59572: LD_VAR 0 11
59576: PPUSH
59577: CALL_OW 1
59581: ST_TO_ADDR
// end ; if tmp and mech < 6 then
59582: LD_VAR 0 4
59586: PUSH
59587: LD_VAR 0 7
59591: PUSH
59592: LD_INT 6
59594: LESS
59595: AND
59596: IFFALSE 59784
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
59598: LD_ADDR_VAR 0 9
59602: PUSH
59603: LD_VAR 0 4
59607: PUSH
59608: LD_VAR 0 8
59612: PUSH
59613: LD_VAR 0 7
59617: UNION
59618: DIFF
59619: PPUSH
59620: LD_INT 3
59622: PPUSH
59623: CALL 47321 0 2
59627: ST_TO_ADDR
// p := [ ] ;
59628: LD_ADDR_VAR 0 11
59632: PUSH
59633: EMPTY
59634: ST_TO_ADDR
// if sort then
59635: LD_VAR 0 9
59639: IFFALSE 59755
// for i = 1 to 6 - mech do
59641: LD_ADDR_VAR 0 3
59645: PUSH
59646: DOUBLE
59647: LD_INT 1
59649: DEC
59650: ST_TO_ADDR
59651: LD_INT 6
59653: PUSH
59654: LD_VAR 0 7
59658: MINUS
59659: PUSH
59660: FOR_TO
59661: IFFALSE 59753
// begin if i = sort then
59663: LD_VAR 0 3
59667: PUSH
59668: LD_VAR 0 9
59672: EQUAL
59673: IFFALSE 59677
// break ;
59675: GO 59753
// if GetClass ( i ) = 3 then
59677: LD_VAR 0 3
59681: PPUSH
59682: CALL_OW 257
59686: PUSH
59687: LD_INT 3
59689: EQUAL
59690: IFFALSE 59694
// continue ;
59692: GO 59660
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59694: LD_ADDR_VAR 0 11
59698: PUSH
59699: LD_VAR 0 11
59703: PPUSH
59704: LD_VAR 0 11
59708: PUSH
59709: LD_INT 1
59711: PLUS
59712: PPUSH
59713: LD_VAR 0 9
59717: PUSH
59718: LD_VAR 0 3
59722: ARRAY
59723: PPUSH
59724: CALL_OW 2
59728: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59729: LD_ADDR_VAR 0 4
59733: PUSH
59734: LD_VAR 0 4
59738: PUSH
59739: LD_VAR 0 9
59743: PUSH
59744: LD_VAR 0 3
59748: ARRAY
59749: DIFF
59750: ST_TO_ADDR
// end ;
59751: GO 59660
59753: POP
59754: POP
// if p then
59755: LD_VAR 0 11
59759: IFFALSE 59784
// result := Replace ( result , 3 , p ) ;
59761: LD_ADDR_VAR 0 2
59765: PUSH
59766: LD_VAR 0 2
59770: PPUSH
59771: LD_INT 3
59773: PPUSH
59774: LD_VAR 0 11
59778: PPUSH
59779: CALL_OW 1
59783: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
59784: LD_VAR 0 4
59788: PUSH
59789: LD_INT 6
59791: GREATER
59792: PUSH
59793: LD_VAR 0 6
59797: PUSH
59798: LD_INT 6
59800: LESS
59801: AND
59802: IFFALSE 59996
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
59804: LD_ADDR_VAR 0 9
59808: PUSH
59809: LD_VAR 0 4
59813: PUSH
59814: LD_VAR 0 8
59818: PUSH
59819: LD_VAR 0 7
59823: UNION
59824: PUSH
59825: LD_VAR 0 6
59829: UNION
59830: DIFF
59831: PPUSH
59832: LD_INT 2
59834: PPUSH
59835: CALL 47321 0 2
59839: ST_TO_ADDR
// p := [ ] ;
59840: LD_ADDR_VAR 0 11
59844: PUSH
59845: EMPTY
59846: ST_TO_ADDR
// if sort then
59847: LD_VAR 0 9
59851: IFFALSE 59967
// for i = 1 to 6 - eng do
59853: LD_ADDR_VAR 0 3
59857: PUSH
59858: DOUBLE
59859: LD_INT 1
59861: DEC
59862: ST_TO_ADDR
59863: LD_INT 6
59865: PUSH
59866: LD_VAR 0 6
59870: MINUS
59871: PUSH
59872: FOR_TO
59873: IFFALSE 59965
// begin if i = sort then
59875: LD_VAR 0 3
59879: PUSH
59880: LD_VAR 0 9
59884: EQUAL
59885: IFFALSE 59889
// break ;
59887: GO 59965
// if GetClass ( i ) = 2 then
59889: LD_VAR 0 3
59893: PPUSH
59894: CALL_OW 257
59898: PUSH
59899: LD_INT 2
59901: EQUAL
59902: IFFALSE 59906
// continue ;
59904: GO 59872
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59906: LD_ADDR_VAR 0 11
59910: PUSH
59911: LD_VAR 0 11
59915: PPUSH
59916: LD_VAR 0 11
59920: PUSH
59921: LD_INT 1
59923: PLUS
59924: PPUSH
59925: LD_VAR 0 9
59929: PUSH
59930: LD_VAR 0 3
59934: ARRAY
59935: PPUSH
59936: CALL_OW 2
59940: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59941: LD_ADDR_VAR 0 4
59945: PUSH
59946: LD_VAR 0 4
59950: PUSH
59951: LD_VAR 0 9
59955: PUSH
59956: LD_VAR 0 3
59960: ARRAY
59961: DIFF
59962: ST_TO_ADDR
// end ;
59963: GO 59872
59965: POP
59966: POP
// if p then
59967: LD_VAR 0 11
59971: IFFALSE 59996
// result := Replace ( result , 2 , p ) ;
59973: LD_ADDR_VAR 0 2
59977: PUSH
59978: LD_VAR 0 2
59982: PPUSH
59983: LD_INT 2
59985: PPUSH
59986: LD_VAR 0 11
59990: PPUSH
59991: CALL_OW 1
59995: ST_TO_ADDR
// end ; exit ;
59996: GO 61384
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
59998: LD_EXP 50
60002: PUSH
60003: LD_EXP 49
60007: PUSH
60008: LD_VAR 0 1
60012: ARRAY
60013: ARRAY
60014: NOT
60015: PUSH
60016: LD_EXP 23
60020: PUSH
60021: LD_VAR 0 1
60025: ARRAY
60026: PPUSH
60027: LD_INT 30
60029: PUSH
60030: LD_INT 3
60032: PUSH
60033: EMPTY
60034: LIST
60035: LIST
60036: PPUSH
60037: CALL_OW 72
60041: AND
60042: PUSH
60043: LD_EXP 28
60047: PUSH
60048: LD_VAR 0 1
60052: ARRAY
60053: AND
60054: IFFALSE 60662
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
60056: LD_ADDR_EXP 65
60060: PUSH
60061: LD_EXP 65
60065: PPUSH
60066: LD_VAR 0 1
60070: PPUSH
60071: LD_INT 5
60073: PPUSH
60074: CALL_OW 1
60078: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
60079: LD_ADDR_VAR 0 2
60083: PUSH
60084: LD_INT 0
60086: PUSH
60087: LD_INT 0
60089: PUSH
60090: LD_INT 0
60092: PUSH
60093: LD_INT 0
60095: PUSH
60096: EMPTY
60097: LIST
60098: LIST
60099: LIST
60100: LIST
60101: ST_TO_ADDR
// if sci > 1 then
60102: LD_VAR 0 8
60106: PUSH
60107: LD_INT 1
60109: GREATER
60110: IFFALSE 60138
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
60112: LD_ADDR_VAR 0 4
60116: PUSH
60117: LD_VAR 0 4
60121: PUSH
60122: LD_VAR 0 8
60126: PUSH
60127: LD_VAR 0 8
60131: PUSH
60132: LD_INT 1
60134: ARRAY
60135: DIFF
60136: DIFF
60137: ST_TO_ADDR
// if tmp and not sci then
60138: LD_VAR 0 4
60142: PUSH
60143: LD_VAR 0 8
60147: NOT
60148: AND
60149: IFFALSE 60218
// begin sort := SortBySkill ( tmp , 4 ) ;
60151: LD_ADDR_VAR 0 9
60155: PUSH
60156: LD_VAR 0 4
60160: PPUSH
60161: LD_INT 4
60163: PPUSH
60164: CALL 47321 0 2
60168: ST_TO_ADDR
// if sort then
60169: LD_VAR 0 9
60173: IFFALSE 60189
// p := sort [ 1 ] ;
60175: LD_ADDR_VAR 0 11
60179: PUSH
60180: LD_VAR 0 9
60184: PUSH
60185: LD_INT 1
60187: ARRAY
60188: ST_TO_ADDR
// if p then
60189: LD_VAR 0 11
60193: IFFALSE 60218
// result := Replace ( result , 4 , p ) ;
60195: LD_ADDR_VAR 0 2
60199: PUSH
60200: LD_VAR 0 2
60204: PPUSH
60205: LD_INT 4
60207: PPUSH
60208: LD_VAR 0 11
60212: PPUSH
60213: CALL_OW 1
60217: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
60218: LD_ADDR_VAR 0 4
60222: PUSH
60223: LD_VAR 0 4
60227: PUSH
60228: LD_VAR 0 7
60232: DIFF
60233: ST_TO_ADDR
// if tmp and mech < 6 then
60234: LD_VAR 0 4
60238: PUSH
60239: LD_VAR 0 7
60243: PUSH
60244: LD_INT 6
60246: LESS
60247: AND
60248: IFFALSE 60436
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
60250: LD_ADDR_VAR 0 9
60254: PUSH
60255: LD_VAR 0 4
60259: PUSH
60260: LD_VAR 0 8
60264: PUSH
60265: LD_VAR 0 7
60269: UNION
60270: DIFF
60271: PPUSH
60272: LD_INT 3
60274: PPUSH
60275: CALL 47321 0 2
60279: ST_TO_ADDR
// p := [ ] ;
60280: LD_ADDR_VAR 0 11
60284: PUSH
60285: EMPTY
60286: ST_TO_ADDR
// if sort then
60287: LD_VAR 0 9
60291: IFFALSE 60407
// for i = 1 to 6 - mech do
60293: LD_ADDR_VAR 0 3
60297: PUSH
60298: DOUBLE
60299: LD_INT 1
60301: DEC
60302: ST_TO_ADDR
60303: LD_INT 6
60305: PUSH
60306: LD_VAR 0 7
60310: MINUS
60311: PUSH
60312: FOR_TO
60313: IFFALSE 60405
// begin if i = sort then
60315: LD_VAR 0 3
60319: PUSH
60320: LD_VAR 0 9
60324: EQUAL
60325: IFFALSE 60329
// break ;
60327: GO 60405
// if GetClass ( i ) = 3 then
60329: LD_VAR 0 3
60333: PPUSH
60334: CALL_OW 257
60338: PUSH
60339: LD_INT 3
60341: EQUAL
60342: IFFALSE 60346
// continue ;
60344: GO 60312
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60346: LD_ADDR_VAR 0 11
60350: PUSH
60351: LD_VAR 0 11
60355: PPUSH
60356: LD_VAR 0 11
60360: PUSH
60361: LD_INT 1
60363: PLUS
60364: PPUSH
60365: LD_VAR 0 9
60369: PUSH
60370: LD_VAR 0 3
60374: ARRAY
60375: PPUSH
60376: CALL_OW 2
60380: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60381: LD_ADDR_VAR 0 4
60385: PUSH
60386: LD_VAR 0 4
60390: PUSH
60391: LD_VAR 0 9
60395: PUSH
60396: LD_VAR 0 3
60400: ARRAY
60401: DIFF
60402: ST_TO_ADDR
// end ;
60403: GO 60312
60405: POP
60406: POP
// if p then
60407: LD_VAR 0 11
60411: IFFALSE 60436
// result := Replace ( result , 3 , p ) ;
60413: LD_ADDR_VAR 0 2
60417: PUSH
60418: LD_VAR 0 2
60422: PPUSH
60423: LD_INT 3
60425: PPUSH
60426: LD_VAR 0 11
60430: PPUSH
60431: CALL_OW 1
60435: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
60436: LD_ADDR_VAR 0 4
60440: PUSH
60441: LD_VAR 0 4
60445: PUSH
60446: LD_VAR 0 6
60450: DIFF
60451: ST_TO_ADDR
// if tmp and eng < 6 then
60452: LD_VAR 0 4
60456: PUSH
60457: LD_VAR 0 6
60461: PUSH
60462: LD_INT 6
60464: LESS
60465: AND
60466: IFFALSE 60660
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
60468: LD_ADDR_VAR 0 9
60472: PUSH
60473: LD_VAR 0 4
60477: PUSH
60478: LD_VAR 0 8
60482: PUSH
60483: LD_VAR 0 7
60487: UNION
60488: PUSH
60489: LD_VAR 0 6
60493: UNION
60494: DIFF
60495: PPUSH
60496: LD_INT 2
60498: PPUSH
60499: CALL 47321 0 2
60503: ST_TO_ADDR
// p := [ ] ;
60504: LD_ADDR_VAR 0 11
60508: PUSH
60509: EMPTY
60510: ST_TO_ADDR
// if sort then
60511: LD_VAR 0 9
60515: IFFALSE 60631
// for i = 1 to 6 - eng do
60517: LD_ADDR_VAR 0 3
60521: PUSH
60522: DOUBLE
60523: LD_INT 1
60525: DEC
60526: ST_TO_ADDR
60527: LD_INT 6
60529: PUSH
60530: LD_VAR 0 6
60534: MINUS
60535: PUSH
60536: FOR_TO
60537: IFFALSE 60629
// begin if i = sort then
60539: LD_VAR 0 3
60543: PUSH
60544: LD_VAR 0 9
60548: EQUAL
60549: IFFALSE 60553
// break ;
60551: GO 60629
// if GetClass ( i ) = 2 then
60553: LD_VAR 0 3
60557: PPUSH
60558: CALL_OW 257
60562: PUSH
60563: LD_INT 2
60565: EQUAL
60566: IFFALSE 60570
// continue ;
60568: GO 60536
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60570: LD_ADDR_VAR 0 11
60574: PUSH
60575: LD_VAR 0 11
60579: PPUSH
60580: LD_VAR 0 11
60584: PUSH
60585: LD_INT 1
60587: PLUS
60588: PPUSH
60589: LD_VAR 0 9
60593: PUSH
60594: LD_VAR 0 3
60598: ARRAY
60599: PPUSH
60600: CALL_OW 2
60604: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60605: LD_ADDR_VAR 0 4
60609: PUSH
60610: LD_VAR 0 4
60614: PUSH
60615: LD_VAR 0 9
60619: PUSH
60620: LD_VAR 0 3
60624: ARRAY
60625: DIFF
60626: ST_TO_ADDR
// end ;
60627: GO 60536
60629: POP
60630: POP
// if p then
60631: LD_VAR 0 11
60635: IFFALSE 60660
// result := Replace ( result , 2 , p ) ;
60637: LD_ADDR_VAR 0 2
60641: PUSH
60642: LD_VAR 0 2
60646: PPUSH
60647: LD_INT 2
60649: PPUSH
60650: LD_VAR 0 11
60654: PPUSH
60655: CALL_OW 1
60659: ST_TO_ADDR
// end ; exit ;
60660: GO 61384
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
60662: LD_EXP 50
60666: PUSH
60667: LD_EXP 49
60671: PUSH
60672: LD_VAR 0 1
60676: ARRAY
60677: ARRAY
60678: NOT
60679: PUSH
60680: LD_EXP 23
60684: PUSH
60685: LD_VAR 0 1
60689: ARRAY
60690: PPUSH
60691: LD_INT 30
60693: PUSH
60694: LD_INT 3
60696: PUSH
60697: EMPTY
60698: LIST
60699: LIST
60700: PPUSH
60701: CALL_OW 72
60705: AND
60706: PUSH
60707: LD_EXP 28
60711: PUSH
60712: LD_VAR 0 1
60716: ARRAY
60717: NOT
60718: AND
60719: IFFALSE 61384
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
60721: LD_ADDR_EXP 65
60725: PUSH
60726: LD_EXP 65
60730: PPUSH
60731: LD_VAR 0 1
60735: PPUSH
60736: LD_INT 6
60738: PPUSH
60739: CALL_OW 1
60743: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
60744: LD_ADDR_VAR 0 2
60748: PUSH
60749: LD_INT 0
60751: PUSH
60752: LD_INT 0
60754: PUSH
60755: LD_INT 0
60757: PUSH
60758: LD_INT 0
60760: PUSH
60761: EMPTY
60762: LIST
60763: LIST
60764: LIST
60765: LIST
60766: ST_TO_ADDR
// if sci >= 1 then
60767: LD_VAR 0 8
60771: PUSH
60772: LD_INT 1
60774: GREATEREQUAL
60775: IFFALSE 60797
// tmp := tmp diff sci [ 1 ] ;
60777: LD_ADDR_VAR 0 4
60781: PUSH
60782: LD_VAR 0 4
60786: PUSH
60787: LD_VAR 0 8
60791: PUSH
60792: LD_INT 1
60794: ARRAY
60795: DIFF
60796: ST_TO_ADDR
// if tmp and not sci then
60797: LD_VAR 0 4
60801: PUSH
60802: LD_VAR 0 8
60806: NOT
60807: AND
60808: IFFALSE 60877
// begin sort := SortBySkill ( tmp , 4 ) ;
60810: LD_ADDR_VAR 0 9
60814: PUSH
60815: LD_VAR 0 4
60819: PPUSH
60820: LD_INT 4
60822: PPUSH
60823: CALL 47321 0 2
60827: ST_TO_ADDR
// if sort then
60828: LD_VAR 0 9
60832: IFFALSE 60848
// p := sort [ 1 ] ;
60834: LD_ADDR_VAR 0 11
60838: PUSH
60839: LD_VAR 0 9
60843: PUSH
60844: LD_INT 1
60846: ARRAY
60847: ST_TO_ADDR
// if p then
60848: LD_VAR 0 11
60852: IFFALSE 60877
// result := Replace ( result , 4 , p ) ;
60854: LD_ADDR_VAR 0 2
60858: PUSH
60859: LD_VAR 0 2
60863: PPUSH
60864: LD_INT 4
60866: PPUSH
60867: LD_VAR 0 11
60871: PPUSH
60872: CALL_OW 1
60876: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
60877: LD_ADDR_VAR 0 4
60881: PUSH
60882: LD_VAR 0 4
60886: PUSH
60887: LD_VAR 0 7
60891: DIFF
60892: ST_TO_ADDR
// if tmp and mech < 6 then
60893: LD_VAR 0 4
60897: PUSH
60898: LD_VAR 0 7
60902: PUSH
60903: LD_INT 6
60905: LESS
60906: AND
60907: IFFALSE 61089
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
60909: LD_ADDR_VAR 0 9
60913: PUSH
60914: LD_VAR 0 4
60918: PUSH
60919: LD_VAR 0 7
60923: DIFF
60924: PPUSH
60925: LD_INT 3
60927: PPUSH
60928: CALL 47321 0 2
60932: ST_TO_ADDR
// p := [ ] ;
60933: LD_ADDR_VAR 0 11
60937: PUSH
60938: EMPTY
60939: ST_TO_ADDR
// if sort then
60940: LD_VAR 0 9
60944: IFFALSE 61060
// for i = 1 to 6 - mech do
60946: LD_ADDR_VAR 0 3
60950: PUSH
60951: DOUBLE
60952: LD_INT 1
60954: DEC
60955: ST_TO_ADDR
60956: LD_INT 6
60958: PUSH
60959: LD_VAR 0 7
60963: MINUS
60964: PUSH
60965: FOR_TO
60966: IFFALSE 61058
// begin if i = sort then
60968: LD_VAR 0 3
60972: PUSH
60973: LD_VAR 0 9
60977: EQUAL
60978: IFFALSE 60982
// break ;
60980: GO 61058
// if GetClass ( i ) = 3 then
60982: LD_VAR 0 3
60986: PPUSH
60987: CALL_OW 257
60991: PUSH
60992: LD_INT 3
60994: EQUAL
60995: IFFALSE 60999
// continue ;
60997: GO 60965
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60999: LD_ADDR_VAR 0 11
61003: PUSH
61004: LD_VAR 0 11
61008: PPUSH
61009: LD_VAR 0 11
61013: PUSH
61014: LD_INT 1
61016: PLUS
61017: PPUSH
61018: LD_VAR 0 9
61022: PUSH
61023: LD_VAR 0 3
61027: ARRAY
61028: PPUSH
61029: CALL_OW 2
61033: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61034: LD_ADDR_VAR 0 4
61038: PUSH
61039: LD_VAR 0 4
61043: PUSH
61044: LD_VAR 0 9
61048: PUSH
61049: LD_VAR 0 3
61053: ARRAY
61054: DIFF
61055: ST_TO_ADDR
// end ;
61056: GO 60965
61058: POP
61059: POP
// if p then
61060: LD_VAR 0 11
61064: IFFALSE 61089
// result := Replace ( result , 3 , p ) ;
61066: LD_ADDR_VAR 0 2
61070: PUSH
61071: LD_VAR 0 2
61075: PPUSH
61076: LD_INT 3
61078: PPUSH
61079: LD_VAR 0 11
61083: PPUSH
61084: CALL_OW 1
61088: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
61089: LD_ADDR_VAR 0 4
61093: PUSH
61094: LD_VAR 0 4
61098: PUSH
61099: LD_VAR 0 6
61103: DIFF
61104: ST_TO_ADDR
// if tmp and eng < 4 then
61105: LD_VAR 0 4
61109: PUSH
61110: LD_VAR 0 6
61114: PUSH
61115: LD_INT 4
61117: LESS
61118: AND
61119: IFFALSE 61309
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
61121: LD_ADDR_VAR 0 9
61125: PUSH
61126: LD_VAR 0 4
61130: PUSH
61131: LD_VAR 0 7
61135: PUSH
61136: LD_VAR 0 6
61140: UNION
61141: DIFF
61142: PPUSH
61143: LD_INT 2
61145: PPUSH
61146: CALL 47321 0 2
61150: ST_TO_ADDR
// p := [ ] ;
61151: LD_ADDR_VAR 0 11
61155: PUSH
61156: EMPTY
61157: ST_TO_ADDR
// if sort then
61158: LD_VAR 0 9
61162: IFFALSE 61278
// for i = 1 to 4 - eng do
61164: LD_ADDR_VAR 0 3
61168: PUSH
61169: DOUBLE
61170: LD_INT 1
61172: DEC
61173: ST_TO_ADDR
61174: LD_INT 4
61176: PUSH
61177: LD_VAR 0 6
61181: MINUS
61182: PUSH
61183: FOR_TO
61184: IFFALSE 61276
// begin if i = sort then
61186: LD_VAR 0 3
61190: PUSH
61191: LD_VAR 0 9
61195: EQUAL
61196: IFFALSE 61200
// break ;
61198: GO 61276
// if GetClass ( i ) = 2 then
61200: LD_VAR 0 3
61204: PPUSH
61205: CALL_OW 257
61209: PUSH
61210: LD_INT 2
61212: EQUAL
61213: IFFALSE 61217
// continue ;
61215: GO 61183
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61217: LD_ADDR_VAR 0 11
61221: PUSH
61222: LD_VAR 0 11
61226: PPUSH
61227: LD_VAR 0 11
61231: PUSH
61232: LD_INT 1
61234: PLUS
61235: PPUSH
61236: LD_VAR 0 9
61240: PUSH
61241: LD_VAR 0 3
61245: ARRAY
61246: PPUSH
61247: CALL_OW 2
61251: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61252: LD_ADDR_VAR 0 4
61256: PUSH
61257: LD_VAR 0 4
61261: PUSH
61262: LD_VAR 0 9
61266: PUSH
61267: LD_VAR 0 3
61271: ARRAY
61272: DIFF
61273: ST_TO_ADDR
// end ;
61274: GO 61183
61276: POP
61277: POP
// if p then
61278: LD_VAR 0 11
61282: IFFALSE 61307
// result := Replace ( result , 2 , p ) ;
61284: LD_ADDR_VAR 0 2
61288: PUSH
61289: LD_VAR 0 2
61293: PPUSH
61294: LD_INT 2
61296: PPUSH
61297: LD_VAR 0 11
61301: PPUSH
61302: CALL_OW 1
61306: ST_TO_ADDR
// end else
61307: GO 61353
// for i = eng downto 5 do
61309: LD_ADDR_VAR 0 3
61313: PUSH
61314: DOUBLE
61315: LD_VAR 0 6
61319: INC
61320: ST_TO_ADDR
61321: LD_INT 5
61323: PUSH
61324: FOR_DOWNTO
61325: IFFALSE 61351
// tmp := tmp union eng [ i ] ;
61327: LD_ADDR_VAR 0 4
61331: PUSH
61332: LD_VAR 0 4
61336: PUSH
61337: LD_VAR 0 6
61341: PUSH
61342: LD_VAR 0 3
61346: ARRAY
61347: UNION
61348: ST_TO_ADDR
61349: GO 61324
61351: POP
61352: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
61353: LD_ADDR_VAR 0 2
61357: PUSH
61358: LD_VAR 0 2
61362: PPUSH
61363: LD_INT 1
61365: PPUSH
61366: LD_VAR 0 4
61370: PUSH
61371: LD_VAR 0 5
61375: DIFF
61376: PPUSH
61377: CALL_OW 1
61381: ST_TO_ADDR
// exit ;
61382: GO 61384
// end ; end ;
61384: LD_VAR 0 2
61388: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
61389: LD_INT 0
61391: PPUSH
61392: PPUSH
61393: PPUSH
// if not mc_bases then
61394: LD_EXP 23
61398: NOT
61399: IFFALSE 61403
// exit ;
61401: GO 61545
// for i = 1 to mc_bases do
61403: LD_ADDR_VAR 0 2
61407: PUSH
61408: DOUBLE
61409: LD_INT 1
61411: DEC
61412: ST_TO_ADDR
61413: LD_EXP 23
61417: PUSH
61418: FOR_TO
61419: IFFALSE 61536
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
61421: LD_ADDR_VAR 0 3
61425: PUSH
61426: LD_EXP 23
61430: PUSH
61431: LD_VAR 0 2
61435: ARRAY
61436: PPUSH
61437: LD_INT 21
61439: PUSH
61440: LD_INT 3
61442: PUSH
61443: EMPTY
61444: LIST
61445: LIST
61446: PUSH
61447: LD_INT 3
61449: PUSH
61450: LD_INT 2
61452: PUSH
61453: LD_INT 30
61455: PUSH
61456: LD_INT 29
61458: PUSH
61459: EMPTY
61460: LIST
61461: LIST
61462: PUSH
61463: LD_INT 30
61465: PUSH
61466: LD_INT 30
61468: PUSH
61469: EMPTY
61470: LIST
61471: LIST
61472: PUSH
61473: EMPTY
61474: LIST
61475: LIST
61476: LIST
61477: PUSH
61478: EMPTY
61479: LIST
61480: LIST
61481: PUSH
61482: LD_INT 3
61484: PUSH
61485: LD_INT 24
61487: PUSH
61488: LD_INT 1000
61490: PUSH
61491: EMPTY
61492: LIST
61493: LIST
61494: PUSH
61495: EMPTY
61496: LIST
61497: LIST
61498: PUSH
61499: EMPTY
61500: LIST
61501: LIST
61502: LIST
61503: PPUSH
61504: CALL_OW 72
61508: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
61509: LD_ADDR_EXP 24
61513: PUSH
61514: LD_EXP 24
61518: PPUSH
61519: LD_VAR 0 2
61523: PPUSH
61524: LD_VAR 0 3
61528: PPUSH
61529: CALL_OW 1
61533: ST_TO_ADDR
// end ;
61534: GO 61418
61536: POP
61537: POP
// RaiseSailEvent ( 101 ) ;
61538: LD_INT 101
61540: PPUSH
61541: CALL_OW 427
// end ;
61545: LD_VAR 0 1
61549: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
61550: LD_INT 0
61552: PPUSH
61553: PPUSH
61554: PPUSH
61555: PPUSH
61556: PPUSH
61557: PPUSH
61558: PPUSH
// if not mc_bases then
61559: LD_EXP 23
61563: NOT
61564: IFFALSE 61568
// exit ;
61566: GO 62130
// for i = 1 to mc_bases do
61568: LD_ADDR_VAR 0 2
61572: PUSH
61573: DOUBLE
61574: LD_INT 1
61576: DEC
61577: ST_TO_ADDR
61578: LD_EXP 23
61582: PUSH
61583: FOR_TO
61584: IFFALSE 62121
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
61586: LD_ADDR_VAR 0 5
61590: PUSH
61591: LD_EXP 23
61595: PUSH
61596: LD_VAR 0 2
61600: ARRAY
61601: PUSH
61602: LD_EXP 52
61606: PUSH
61607: LD_VAR 0 2
61611: ARRAY
61612: UNION
61613: PPUSH
61614: LD_INT 21
61616: PUSH
61617: LD_INT 1
61619: PUSH
61620: EMPTY
61621: LIST
61622: LIST
61623: PUSH
61624: LD_INT 1
61626: PUSH
61627: LD_INT 3
61629: PUSH
61630: LD_INT 54
61632: PUSH
61633: EMPTY
61634: LIST
61635: PUSH
61636: EMPTY
61637: LIST
61638: LIST
61639: PUSH
61640: LD_INT 3
61642: PUSH
61643: LD_INT 24
61645: PUSH
61646: LD_INT 1000
61648: PUSH
61649: EMPTY
61650: LIST
61651: LIST
61652: PUSH
61653: EMPTY
61654: LIST
61655: LIST
61656: PUSH
61657: EMPTY
61658: LIST
61659: LIST
61660: LIST
61661: PUSH
61662: EMPTY
61663: LIST
61664: LIST
61665: PPUSH
61666: CALL_OW 72
61670: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
61671: LD_ADDR_VAR 0 6
61675: PUSH
61676: LD_EXP 23
61680: PUSH
61681: LD_VAR 0 2
61685: ARRAY
61686: PPUSH
61687: LD_INT 21
61689: PUSH
61690: LD_INT 1
61692: PUSH
61693: EMPTY
61694: LIST
61695: LIST
61696: PUSH
61697: LD_INT 1
61699: PUSH
61700: LD_INT 3
61702: PUSH
61703: LD_INT 54
61705: PUSH
61706: EMPTY
61707: LIST
61708: PUSH
61709: EMPTY
61710: LIST
61711: LIST
61712: PUSH
61713: LD_INT 3
61715: PUSH
61716: LD_INT 24
61718: PUSH
61719: LD_INT 250
61721: PUSH
61722: EMPTY
61723: LIST
61724: LIST
61725: PUSH
61726: EMPTY
61727: LIST
61728: LIST
61729: PUSH
61730: EMPTY
61731: LIST
61732: LIST
61733: LIST
61734: PUSH
61735: EMPTY
61736: LIST
61737: LIST
61738: PPUSH
61739: CALL_OW 72
61743: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
61744: LD_ADDR_VAR 0 7
61748: PUSH
61749: LD_VAR 0 5
61753: PUSH
61754: LD_VAR 0 6
61758: DIFF
61759: ST_TO_ADDR
// if not need_heal_1 then
61760: LD_VAR 0 6
61764: NOT
61765: IFFALSE 61798
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
61767: LD_ADDR_EXP 26
61771: PUSH
61772: LD_EXP 26
61776: PPUSH
61777: LD_VAR 0 2
61781: PUSH
61782: LD_INT 1
61784: PUSH
61785: EMPTY
61786: LIST
61787: LIST
61788: PPUSH
61789: EMPTY
61790: PPUSH
61791: CALL 16077 0 3
61795: ST_TO_ADDR
61796: GO 61868
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
61798: LD_ADDR_EXP 26
61802: PUSH
61803: LD_EXP 26
61807: PPUSH
61808: LD_VAR 0 2
61812: PUSH
61813: LD_INT 1
61815: PUSH
61816: EMPTY
61817: LIST
61818: LIST
61819: PPUSH
61820: LD_EXP 26
61824: PUSH
61825: LD_VAR 0 2
61829: ARRAY
61830: PUSH
61831: LD_INT 1
61833: ARRAY
61834: PPUSH
61835: LD_INT 3
61837: PUSH
61838: LD_INT 24
61840: PUSH
61841: LD_INT 1000
61843: PUSH
61844: EMPTY
61845: LIST
61846: LIST
61847: PUSH
61848: EMPTY
61849: LIST
61850: LIST
61851: PPUSH
61852: CALL_OW 72
61856: PUSH
61857: LD_VAR 0 6
61861: UNION
61862: PPUSH
61863: CALL 16077 0 3
61867: ST_TO_ADDR
// if not need_heal_2 then
61868: LD_VAR 0 7
61872: NOT
61873: IFFALSE 61906
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
61875: LD_ADDR_EXP 26
61879: PUSH
61880: LD_EXP 26
61884: PPUSH
61885: LD_VAR 0 2
61889: PUSH
61890: LD_INT 2
61892: PUSH
61893: EMPTY
61894: LIST
61895: LIST
61896: PPUSH
61897: EMPTY
61898: PPUSH
61899: CALL 16077 0 3
61903: ST_TO_ADDR
61904: GO 61938
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
61906: LD_ADDR_EXP 26
61910: PUSH
61911: LD_EXP 26
61915: PPUSH
61916: LD_VAR 0 2
61920: PUSH
61921: LD_INT 2
61923: PUSH
61924: EMPTY
61925: LIST
61926: LIST
61927: PPUSH
61928: LD_VAR 0 7
61932: PPUSH
61933: CALL 16077 0 3
61937: ST_TO_ADDR
// if need_heal_2 then
61938: LD_VAR 0 7
61942: IFFALSE 62103
// for j in need_heal_2 do
61944: LD_ADDR_VAR 0 3
61948: PUSH
61949: LD_VAR 0 7
61953: PUSH
61954: FOR_IN
61955: IFFALSE 62101
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61957: LD_ADDR_VAR 0 5
61961: PUSH
61962: LD_EXP 23
61966: PUSH
61967: LD_VAR 0 2
61971: ARRAY
61972: PPUSH
61973: LD_INT 2
61975: PUSH
61976: LD_INT 30
61978: PUSH
61979: LD_INT 6
61981: PUSH
61982: EMPTY
61983: LIST
61984: LIST
61985: PUSH
61986: LD_INT 30
61988: PUSH
61989: LD_INT 7
61991: PUSH
61992: EMPTY
61993: LIST
61994: LIST
61995: PUSH
61996: LD_INT 30
61998: PUSH
61999: LD_INT 8
62001: PUSH
62002: EMPTY
62003: LIST
62004: LIST
62005: PUSH
62006: LD_INT 30
62008: PUSH
62009: LD_INT 0
62011: PUSH
62012: EMPTY
62013: LIST
62014: LIST
62015: PUSH
62016: LD_INT 30
62018: PUSH
62019: LD_INT 1
62021: PUSH
62022: EMPTY
62023: LIST
62024: LIST
62025: PUSH
62026: EMPTY
62027: LIST
62028: LIST
62029: LIST
62030: LIST
62031: LIST
62032: LIST
62033: PPUSH
62034: CALL_OW 72
62038: ST_TO_ADDR
// if tmp then
62039: LD_VAR 0 5
62043: IFFALSE 62099
// begin k := NearestUnitToUnit ( tmp , j ) ;
62045: LD_ADDR_VAR 0 4
62049: PUSH
62050: LD_VAR 0 5
62054: PPUSH
62055: LD_VAR 0 3
62059: PPUSH
62060: CALL_OW 74
62064: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
62065: LD_VAR 0 3
62069: PPUSH
62070: LD_VAR 0 4
62074: PPUSH
62075: CALL_OW 296
62079: PUSH
62080: LD_INT 5
62082: GREATER
62083: IFFALSE 62099
// ComMoveToNearbyEntrance ( j , k ) ;
62085: LD_VAR 0 3
62089: PPUSH
62090: LD_VAR 0 4
62094: PPUSH
62095: CALL 49694 0 2
// end ; end ;
62099: GO 61954
62101: POP
62102: POP
// if not need_heal_1 and not need_heal_2 then
62103: LD_VAR 0 6
62107: NOT
62108: PUSH
62109: LD_VAR 0 7
62113: NOT
62114: AND
62115: IFFALSE 62119
// continue ;
62117: GO 61583
// end ;
62119: GO 61583
62121: POP
62122: POP
// RaiseSailEvent ( 102 ) ;
62123: LD_INT 102
62125: PPUSH
62126: CALL_OW 427
// end ;
62130: LD_VAR 0 1
62134: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
62135: LD_INT 0
62137: PPUSH
62138: PPUSH
62139: PPUSH
62140: PPUSH
62141: PPUSH
62142: PPUSH
62143: PPUSH
62144: PPUSH
// if not mc_bases then
62145: LD_EXP 23
62149: NOT
62150: IFFALSE 62154
// exit ;
62152: GO 63065
// for i = 1 to mc_bases do
62154: LD_ADDR_VAR 0 2
62158: PUSH
62159: DOUBLE
62160: LD_INT 1
62162: DEC
62163: ST_TO_ADDR
62164: LD_EXP 23
62168: PUSH
62169: FOR_TO
62170: IFFALSE 63063
// begin if not mc_building_need_repair [ i ] then
62172: LD_EXP 24
62176: PUSH
62177: LD_VAR 0 2
62181: ARRAY
62182: NOT
62183: IFFALSE 62368
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
62185: LD_ADDR_VAR 0 6
62189: PUSH
62190: LD_EXP 42
62194: PUSH
62195: LD_VAR 0 2
62199: ARRAY
62200: PPUSH
62201: LD_INT 3
62203: PUSH
62204: LD_INT 24
62206: PUSH
62207: LD_INT 1000
62209: PUSH
62210: EMPTY
62211: LIST
62212: LIST
62213: PUSH
62214: EMPTY
62215: LIST
62216: LIST
62217: PUSH
62218: LD_INT 2
62220: PUSH
62221: LD_INT 34
62223: PUSH
62224: LD_INT 13
62226: PUSH
62227: EMPTY
62228: LIST
62229: LIST
62230: PUSH
62231: LD_INT 34
62233: PUSH
62234: LD_INT 52
62236: PUSH
62237: EMPTY
62238: LIST
62239: LIST
62240: PUSH
62241: LD_INT 34
62243: PUSH
62244: LD_INT 88
62246: PUSH
62247: EMPTY
62248: LIST
62249: LIST
62250: PUSH
62251: EMPTY
62252: LIST
62253: LIST
62254: LIST
62255: LIST
62256: PUSH
62257: EMPTY
62258: LIST
62259: LIST
62260: PPUSH
62261: CALL_OW 72
62265: ST_TO_ADDR
// if cranes then
62266: LD_VAR 0 6
62270: IFFALSE 62332
// for j in cranes do
62272: LD_ADDR_VAR 0 3
62276: PUSH
62277: LD_VAR 0 6
62281: PUSH
62282: FOR_IN
62283: IFFALSE 62330
// if not IsInArea ( j , mc_parking [ i ] ) then
62285: LD_VAR 0 3
62289: PPUSH
62290: LD_EXP 47
62294: PUSH
62295: LD_VAR 0 2
62299: ARRAY
62300: PPUSH
62301: CALL_OW 308
62305: NOT
62306: IFFALSE 62328
// ComMoveToArea ( j , mc_parking [ i ] ) ;
62308: LD_VAR 0 3
62312: PPUSH
62313: LD_EXP 47
62317: PUSH
62318: LD_VAR 0 2
62322: ARRAY
62323: PPUSH
62324: CALL_OW 113
62328: GO 62282
62330: POP
62331: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
62332: LD_ADDR_EXP 25
62336: PUSH
62337: LD_EXP 25
62341: PPUSH
62342: LD_VAR 0 2
62346: PPUSH
62347: EMPTY
62348: PPUSH
62349: CALL_OW 1
62353: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
62354: LD_VAR 0 2
62358: PPUSH
62359: LD_INT 101
62361: PPUSH
62362: CALL 57208 0 2
// continue ;
62366: GO 62169
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
62368: LD_ADDR_EXP 29
62372: PUSH
62373: LD_EXP 29
62377: PPUSH
62378: LD_VAR 0 2
62382: PPUSH
62383: EMPTY
62384: PPUSH
62385: CALL_OW 1
62389: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
62390: LD_VAR 0 2
62394: PPUSH
62395: LD_INT 103
62397: PPUSH
62398: CALL 57208 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
62402: LD_ADDR_VAR 0 5
62406: PUSH
62407: LD_EXP 23
62411: PUSH
62412: LD_VAR 0 2
62416: ARRAY
62417: PUSH
62418: LD_EXP 52
62422: PUSH
62423: LD_VAR 0 2
62427: ARRAY
62428: UNION
62429: PPUSH
62430: LD_INT 2
62432: PUSH
62433: LD_INT 25
62435: PUSH
62436: LD_INT 2
62438: PUSH
62439: EMPTY
62440: LIST
62441: LIST
62442: PUSH
62443: LD_INT 25
62445: PUSH
62446: LD_INT 16
62448: PUSH
62449: EMPTY
62450: LIST
62451: LIST
62452: PUSH
62453: EMPTY
62454: LIST
62455: LIST
62456: LIST
62457: PUSH
62458: EMPTY
62459: LIST
62460: PPUSH
62461: CALL_OW 72
62465: ST_TO_ADDR
// if mc_need_heal [ i ] then
62466: LD_EXP 26
62470: PUSH
62471: LD_VAR 0 2
62475: ARRAY
62476: IFFALSE 62520
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
62478: LD_ADDR_VAR 0 5
62482: PUSH
62483: LD_VAR 0 5
62487: PUSH
62488: LD_EXP 26
62492: PUSH
62493: LD_VAR 0 2
62497: ARRAY
62498: PUSH
62499: LD_INT 1
62501: ARRAY
62502: PUSH
62503: LD_EXP 26
62507: PUSH
62508: LD_VAR 0 2
62512: ARRAY
62513: PUSH
62514: LD_INT 2
62516: ARRAY
62517: UNION
62518: DIFF
62519: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
62520: LD_ADDR_VAR 0 6
62524: PUSH
62525: LD_EXP 42
62529: PUSH
62530: LD_VAR 0 2
62534: ARRAY
62535: PPUSH
62536: LD_INT 2
62538: PUSH
62539: LD_INT 34
62541: PUSH
62542: LD_INT 13
62544: PUSH
62545: EMPTY
62546: LIST
62547: LIST
62548: PUSH
62549: LD_INT 34
62551: PUSH
62552: LD_INT 52
62554: PUSH
62555: EMPTY
62556: LIST
62557: LIST
62558: PUSH
62559: LD_INT 34
62561: PUSH
62562: LD_INT 88
62564: PUSH
62565: EMPTY
62566: LIST
62567: LIST
62568: PUSH
62569: EMPTY
62570: LIST
62571: LIST
62572: LIST
62573: LIST
62574: PPUSH
62575: CALL_OW 72
62579: ST_TO_ADDR
// if cranes then
62580: LD_VAR 0 6
62584: IFFALSE 62752
// begin for j in cranes do
62586: LD_ADDR_VAR 0 3
62590: PUSH
62591: LD_VAR 0 6
62595: PUSH
62596: FOR_IN
62597: IFFALSE 62750
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
62599: LD_VAR 0 3
62603: PPUSH
62604: CALL_OW 256
62608: PUSH
62609: LD_INT 1000
62611: EQUAL
62612: PUSH
62613: LD_VAR 0 3
62617: PPUSH
62618: CALL_OW 314
62622: NOT
62623: AND
62624: IFFALSE 62690
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
62626: LD_ADDR_VAR 0 8
62630: PUSH
62631: LD_EXP 24
62635: PUSH
62636: LD_VAR 0 2
62640: ARRAY
62641: PPUSH
62642: LD_VAR 0 3
62646: PPUSH
62647: CALL_OW 74
62651: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
62652: LD_VAR 0 8
62656: PPUSH
62657: LD_INT 16
62659: PPUSH
62660: CALL 19042 0 2
62664: PUSH
62665: LD_INT 4
62667: ARRAY
62668: PUSH
62669: LD_INT 10
62671: LESS
62672: IFFALSE 62688
// ComRepairBuilding ( j , to_repair ) ;
62674: LD_VAR 0 3
62678: PPUSH
62679: LD_VAR 0 8
62683: PPUSH
62684: CALL_OW 130
// end else
62688: GO 62748
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
62690: LD_VAR 0 3
62694: PPUSH
62695: CALL_OW 256
62699: PUSH
62700: LD_INT 500
62702: LESS
62703: PUSH
62704: LD_VAR 0 3
62708: PPUSH
62709: LD_EXP 47
62713: PUSH
62714: LD_VAR 0 2
62718: ARRAY
62719: PPUSH
62720: CALL_OW 308
62724: NOT
62725: AND
62726: IFFALSE 62748
// ComMoveToArea ( j , mc_parking [ i ] ) ;
62728: LD_VAR 0 3
62732: PPUSH
62733: LD_EXP 47
62737: PUSH
62738: LD_VAR 0 2
62742: ARRAY
62743: PPUSH
62744: CALL_OW 113
// end ;
62748: GO 62596
62750: POP
62751: POP
// end ; if tmp > 3 then
62752: LD_VAR 0 5
62756: PUSH
62757: LD_INT 3
62759: GREATER
62760: IFFALSE 62780
// tmp := ShrinkArray ( tmp , 4 ) ;
62762: LD_ADDR_VAR 0 5
62766: PUSH
62767: LD_VAR 0 5
62771: PPUSH
62772: LD_INT 4
62774: PPUSH
62775: CALL 49132 0 2
62779: ST_TO_ADDR
// if not tmp then
62780: LD_VAR 0 5
62784: NOT
62785: IFFALSE 62789
// continue ;
62787: GO 62169
// for j in tmp do
62789: LD_ADDR_VAR 0 3
62793: PUSH
62794: LD_VAR 0 5
62798: PUSH
62799: FOR_IN
62800: IFFALSE 63059
// begin if IsInUnit ( j ) then
62802: LD_VAR 0 3
62806: PPUSH
62807: CALL_OW 310
62811: IFFALSE 62822
// ComExitBuilding ( j ) ;
62813: LD_VAR 0 3
62817: PPUSH
62818: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
62822: LD_VAR 0 3
62826: PUSH
62827: LD_EXP 25
62831: PUSH
62832: LD_VAR 0 2
62836: ARRAY
62837: IN
62838: NOT
62839: IFFALSE 62897
// begin SetTag ( j , 101 ) ;
62841: LD_VAR 0 3
62845: PPUSH
62846: LD_INT 101
62848: PPUSH
62849: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
62853: LD_ADDR_EXP 25
62857: PUSH
62858: LD_EXP 25
62862: PPUSH
62863: LD_VAR 0 2
62867: PUSH
62868: LD_EXP 25
62872: PUSH
62873: LD_VAR 0 2
62877: ARRAY
62878: PUSH
62879: LD_INT 1
62881: PLUS
62882: PUSH
62883: EMPTY
62884: LIST
62885: LIST
62886: PPUSH
62887: LD_VAR 0 3
62891: PPUSH
62892: CALL 16077 0 3
62896: ST_TO_ADDR
// end ; wait ( 1 ) ;
62897: LD_INT 1
62899: PPUSH
62900: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
62904: LD_ADDR_VAR 0 7
62908: PUSH
62909: LD_EXP 24
62913: PUSH
62914: LD_VAR 0 2
62918: ARRAY
62919: ST_TO_ADDR
// if mc_scan [ i ] then
62920: LD_EXP 46
62924: PUSH
62925: LD_VAR 0 2
62929: ARRAY
62930: IFFALSE 62992
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
62932: LD_ADDR_VAR 0 7
62936: PUSH
62937: LD_EXP 24
62941: PUSH
62942: LD_VAR 0 2
62946: ARRAY
62947: PPUSH
62948: LD_INT 3
62950: PUSH
62951: LD_INT 30
62953: PUSH
62954: LD_INT 32
62956: PUSH
62957: EMPTY
62958: LIST
62959: LIST
62960: PUSH
62961: LD_INT 30
62963: PUSH
62964: LD_INT 33
62966: PUSH
62967: EMPTY
62968: LIST
62969: LIST
62970: PUSH
62971: LD_INT 30
62973: PUSH
62974: LD_INT 31
62976: PUSH
62977: EMPTY
62978: LIST
62979: LIST
62980: PUSH
62981: EMPTY
62982: LIST
62983: LIST
62984: LIST
62985: LIST
62986: PPUSH
62987: CALL_OW 72
62991: ST_TO_ADDR
// if not to_repair_tmp then
62992: LD_VAR 0 7
62996: NOT
62997: IFFALSE 63001
// continue ;
62999: GO 62799
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
63001: LD_ADDR_VAR 0 8
63005: PUSH
63006: LD_VAR 0 7
63010: PPUSH
63011: LD_VAR 0 3
63015: PPUSH
63016: CALL_OW 74
63020: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
63021: LD_VAR 0 8
63025: PPUSH
63026: LD_INT 16
63028: PPUSH
63029: CALL 19042 0 2
63033: PUSH
63034: LD_INT 4
63036: ARRAY
63037: PUSH
63038: LD_INT 14
63040: LESS
63041: IFFALSE 63057
// ComRepairBuilding ( j , to_repair ) ;
63043: LD_VAR 0 3
63047: PPUSH
63048: LD_VAR 0 8
63052: PPUSH
63053: CALL_OW 130
// end ;
63057: GO 62799
63059: POP
63060: POP
// end ;
63061: GO 62169
63063: POP
63064: POP
// end ;
63065: LD_VAR 0 1
63069: RET
// export function MC_Heal ; var i , j , tmp ; begin
63070: LD_INT 0
63072: PPUSH
63073: PPUSH
63074: PPUSH
63075: PPUSH
// if not mc_bases then
63076: LD_EXP 23
63080: NOT
63081: IFFALSE 63085
// exit ;
63083: GO 63487
// for i = 1 to mc_bases do
63085: LD_ADDR_VAR 0 2
63089: PUSH
63090: DOUBLE
63091: LD_INT 1
63093: DEC
63094: ST_TO_ADDR
63095: LD_EXP 23
63099: PUSH
63100: FOR_TO
63101: IFFALSE 63485
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
63103: LD_EXP 26
63107: PUSH
63108: LD_VAR 0 2
63112: ARRAY
63113: PUSH
63114: LD_INT 1
63116: ARRAY
63117: NOT
63118: PUSH
63119: LD_EXP 26
63123: PUSH
63124: LD_VAR 0 2
63128: ARRAY
63129: PUSH
63130: LD_INT 2
63132: ARRAY
63133: NOT
63134: AND
63135: IFFALSE 63173
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
63137: LD_ADDR_EXP 27
63141: PUSH
63142: LD_EXP 27
63146: PPUSH
63147: LD_VAR 0 2
63151: PPUSH
63152: EMPTY
63153: PPUSH
63154: CALL_OW 1
63158: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
63159: LD_VAR 0 2
63163: PPUSH
63164: LD_INT 102
63166: PPUSH
63167: CALL 57208 0 2
// continue ;
63171: GO 63100
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
63173: LD_ADDR_VAR 0 4
63177: PUSH
63178: LD_EXP 23
63182: PUSH
63183: LD_VAR 0 2
63187: ARRAY
63188: PPUSH
63189: LD_INT 25
63191: PUSH
63192: LD_INT 4
63194: PUSH
63195: EMPTY
63196: LIST
63197: LIST
63198: PPUSH
63199: CALL_OW 72
63203: ST_TO_ADDR
// if not tmp then
63204: LD_VAR 0 4
63208: NOT
63209: IFFALSE 63213
// continue ;
63211: GO 63100
// if mc_taming [ i ] then
63213: LD_EXP 54
63217: PUSH
63218: LD_VAR 0 2
63222: ARRAY
63223: IFFALSE 63247
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
63225: LD_ADDR_EXP 54
63229: PUSH
63230: LD_EXP 54
63234: PPUSH
63235: LD_VAR 0 2
63239: PPUSH
63240: EMPTY
63241: PPUSH
63242: CALL_OW 1
63246: ST_TO_ADDR
// for j in tmp do
63247: LD_ADDR_VAR 0 3
63251: PUSH
63252: LD_VAR 0 4
63256: PUSH
63257: FOR_IN
63258: IFFALSE 63481
// begin if IsInUnit ( j ) then
63260: LD_VAR 0 3
63264: PPUSH
63265: CALL_OW 310
63269: IFFALSE 63280
// ComExitBuilding ( j ) ;
63271: LD_VAR 0 3
63275: PPUSH
63276: CALL_OW 122
// if not j in mc_healers [ i ] then
63280: LD_VAR 0 3
63284: PUSH
63285: LD_EXP 27
63289: PUSH
63290: LD_VAR 0 2
63294: ARRAY
63295: IN
63296: NOT
63297: IFFALSE 63343
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
63299: LD_ADDR_EXP 27
63303: PUSH
63304: LD_EXP 27
63308: PPUSH
63309: LD_VAR 0 2
63313: PUSH
63314: LD_EXP 27
63318: PUSH
63319: LD_VAR 0 2
63323: ARRAY
63324: PUSH
63325: LD_INT 1
63327: PLUS
63328: PUSH
63329: EMPTY
63330: LIST
63331: LIST
63332: PPUSH
63333: LD_VAR 0 3
63337: PPUSH
63338: CALL 16077 0 3
63342: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
63343: LD_VAR 0 3
63347: PPUSH
63348: CALL_OW 110
63352: PUSH
63353: LD_INT 102
63355: NONEQUAL
63356: IFFALSE 63370
// SetTag ( j , 102 ) ;
63358: LD_VAR 0 3
63362: PPUSH
63363: LD_INT 102
63365: PPUSH
63366: CALL_OW 109
// Wait ( 3 ) ;
63370: LD_INT 3
63372: PPUSH
63373: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
63377: LD_EXP 26
63381: PUSH
63382: LD_VAR 0 2
63386: ARRAY
63387: PUSH
63388: LD_INT 1
63390: ARRAY
63391: IFFALSE 63423
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
63393: LD_VAR 0 3
63397: PPUSH
63398: LD_EXP 26
63402: PUSH
63403: LD_VAR 0 2
63407: ARRAY
63408: PUSH
63409: LD_INT 1
63411: ARRAY
63412: PUSH
63413: LD_INT 1
63415: ARRAY
63416: PPUSH
63417: CALL_OW 128
63421: GO 63479
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
63423: LD_VAR 0 3
63427: PPUSH
63428: CALL_OW 314
63432: NOT
63433: PUSH
63434: LD_EXP 26
63438: PUSH
63439: LD_VAR 0 2
63443: ARRAY
63444: PUSH
63445: LD_INT 2
63447: ARRAY
63448: AND
63449: IFFALSE 63479
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
63451: LD_VAR 0 3
63455: PPUSH
63456: LD_EXP 26
63460: PUSH
63461: LD_VAR 0 2
63465: ARRAY
63466: PUSH
63467: LD_INT 2
63469: ARRAY
63470: PUSH
63471: LD_INT 1
63473: ARRAY
63474: PPUSH
63475: CALL_OW 128
// end ;
63479: GO 63257
63481: POP
63482: POP
// end ;
63483: GO 63100
63485: POP
63486: POP
// end ;
63487: LD_VAR 0 1
63491: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
63492: LD_INT 0
63494: PPUSH
63495: PPUSH
63496: PPUSH
63497: PPUSH
63498: PPUSH
63499: PPUSH
// if not mc_bases then
63500: LD_EXP 23
63504: NOT
63505: IFFALSE 63509
// exit ;
63507: GO 64672
// for i = 1 to mc_bases do
63509: LD_ADDR_VAR 0 2
63513: PUSH
63514: DOUBLE
63515: LD_INT 1
63517: DEC
63518: ST_TO_ADDR
63519: LD_EXP 23
63523: PUSH
63524: FOR_TO
63525: IFFALSE 64670
// begin if mc_scan [ i ] then
63527: LD_EXP 46
63531: PUSH
63532: LD_VAR 0 2
63536: ARRAY
63537: IFFALSE 63541
// continue ;
63539: GO 63524
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
63541: LD_EXP 28
63545: PUSH
63546: LD_VAR 0 2
63550: ARRAY
63551: NOT
63552: PUSH
63553: LD_EXP 30
63557: PUSH
63558: LD_VAR 0 2
63562: ARRAY
63563: NOT
63564: AND
63565: PUSH
63566: LD_EXP 29
63570: PUSH
63571: LD_VAR 0 2
63575: ARRAY
63576: AND
63577: IFFALSE 63615
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
63579: LD_ADDR_EXP 29
63583: PUSH
63584: LD_EXP 29
63588: PPUSH
63589: LD_VAR 0 2
63593: PPUSH
63594: EMPTY
63595: PPUSH
63596: CALL_OW 1
63600: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
63601: LD_VAR 0 2
63605: PPUSH
63606: LD_INT 103
63608: PPUSH
63609: CALL 57208 0 2
// continue ;
63613: GO 63524
// end ; if mc_construct_list [ i ] then
63615: LD_EXP 30
63619: PUSH
63620: LD_VAR 0 2
63624: ARRAY
63625: IFFALSE 63845
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
63627: LD_ADDR_VAR 0 5
63631: PUSH
63632: LD_EXP 23
63636: PUSH
63637: LD_VAR 0 2
63641: ARRAY
63642: PPUSH
63643: LD_INT 25
63645: PUSH
63646: LD_INT 2
63648: PUSH
63649: EMPTY
63650: LIST
63651: LIST
63652: PPUSH
63653: CALL_OW 72
63657: PUSH
63658: LD_EXP 25
63662: PUSH
63663: LD_VAR 0 2
63667: ARRAY
63668: DIFF
63669: ST_TO_ADDR
// if not tmp then
63670: LD_VAR 0 5
63674: NOT
63675: IFFALSE 63679
// continue ;
63677: GO 63524
// for j in tmp do
63679: LD_ADDR_VAR 0 3
63683: PUSH
63684: LD_VAR 0 5
63688: PUSH
63689: FOR_IN
63690: IFFALSE 63841
// begin if not mc_builders [ i ] then
63692: LD_EXP 29
63696: PUSH
63697: LD_VAR 0 2
63701: ARRAY
63702: NOT
63703: IFFALSE 63761
// begin SetTag ( j , 103 ) ;
63705: LD_VAR 0 3
63709: PPUSH
63710: LD_INT 103
63712: PPUSH
63713: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
63717: LD_ADDR_EXP 29
63721: PUSH
63722: LD_EXP 29
63726: PPUSH
63727: LD_VAR 0 2
63731: PUSH
63732: LD_EXP 29
63736: PUSH
63737: LD_VAR 0 2
63741: ARRAY
63742: PUSH
63743: LD_INT 1
63745: PLUS
63746: PUSH
63747: EMPTY
63748: LIST
63749: LIST
63750: PPUSH
63751: LD_VAR 0 3
63755: PPUSH
63756: CALL 16077 0 3
63760: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
63761: LD_VAR 0 3
63765: PPUSH
63766: CALL_OW 310
63770: IFFALSE 63781
// ComExitBuilding ( j ) ;
63772: LD_VAR 0 3
63776: PPUSH
63777: CALL_OW 122
// wait ( 3 ) ;
63781: LD_INT 3
63783: PPUSH
63784: CALL_OW 67
// if not mc_construct_list [ i ] then
63788: LD_EXP 30
63792: PUSH
63793: LD_VAR 0 2
63797: ARRAY
63798: NOT
63799: IFFALSE 63803
// break ;
63801: GO 63841
// if not HasTask ( j ) then
63803: LD_VAR 0 3
63807: PPUSH
63808: CALL_OW 314
63812: NOT
63813: IFFALSE 63839
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
63815: LD_VAR 0 3
63819: PPUSH
63820: LD_EXP 30
63824: PUSH
63825: LD_VAR 0 2
63829: ARRAY
63830: PUSH
63831: LD_INT 1
63833: ARRAY
63834: PPUSH
63835: CALL 19315 0 2
// end ;
63839: GO 63689
63841: POP
63842: POP
// end else
63843: GO 64668
// if mc_build_list [ i ] then
63845: LD_EXP 28
63849: PUSH
63850: LD_VAR 0 2
63854: ARRAY
63855: IFFALSE 64668
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
63857: LD_EXP 28
63861: PUSH
63862: LD_VAR 0 2
63866: ARRAY
63867: PUSH
63868: LD_INT 1
63870: ARRAY
63871: PUSH
63872: LD_INT 1
63874: ARRAY
63875: PPUSH
63876: CALL 19139 0 1
63880: PUSH
63881: LD_EXP 23
63885: PUSH
63886: LD_VAR 0 2
63890: ARRAY
63891: PPUSH
63892: LD_INT 2
63894: PUSH
63895: LD_INT 30
63897: PUSH
63898: LD_INT 2
63900: PUSH
63901: EMPTY
63902: LIST
63903: LIST
63904: PUSH
63905: LD_INT 30
63907: PUSH
63908: LD_INT 3
63910: PUSH
63911: EMPTY
63912: LIST
63913: LIST
63914: PUSH
63915: EMPTY
63916: LIST
63917: LIST
63918: LIST
63919: PPUSH
63920: CALL_OW 72
63924: NOT
63925: AND
63926: IFFALSE 64031
// begin for j = 1 to mc_build_list [ i ] do
63928: LD_ADDR_VAR 0 3
63932: PUSH
63933: DOUBLE
63934: LD_INT 1
63936: DEC
63937: ST_TO_ADDR
63938: LD_EXP 28
63942: PUSH
63943: LD_VAR 0 2
63947: ARRAY
63948: PUSH
63949: FOR_TO
63950: IFFALSE 64029
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
63952: LD_EXP 28
63956: PUSH
63957: LD_VAR 0 2
63961: ARRAY
63962: PUSH
63963: LD_VAR 0 3
63967: ARRAY
63968: PUSH
63969: LD_INT 1
63971: ARRAY
63972: PUSH
63973: LD_INT 2
63975: EQUAL
63976: IFFALSE 64027
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
63978: LD_ADDR_EXP 28
63982: PUSH
63983: LD_EXP 28
63987: PPUSH
63988: LD_VAR 0 2
63992: PPUSH
63993: LD_EXP 28
63997: PUSH
63998: LD_VAR 0 2
64002: ARRAY
64003: PPUSH
64004: LD_VAR 0 3
64008: PPUSH
64009: LD_INT 1
64011: PPUSH
64012: LD_INT 0
64014: PPUSH
64015: CALL 15495 0 4
64019: PPUSH
64020: CALL_OW 1
64024: ST_TO_ADDR
// break ;
64025: GO 64029
// end ;
64027: GO 63949
64029: POP
64030: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64031: LD_ADDR_VAR 0 6
64035: PUSH
64036: LD_EXP 23
64040: PUSH
64041: LD_VAR 0 2
64045: ARRAY
64046: PPUSH
64047: LD_INT 2
64049: PUSH
64050: LD_INT 30
64052: PUSH
64053: LD_INT 0
64055: PUSH
64056: EMPTY
64057: LIST
64058: LIST
64059: PUSH
64060: LD_INT 30
64062: PUSH
64063: LD_INT 1
64065: PUSH
64066: EMPTY
64067: LIST
64068: LIST
64069: PUSH
64070: EMPTY
64071: LIST
64072: LIST
64073: LIST
64074: PPUSH
64075: CALL_OW 72
64079: ST_TO_ADDR
// for k := 1 to depot do
64080: LD_ADDR_VAR 0 4
64084: PUSH
64085: DOUBLE
64086: LD_INT 1
64088: DEC
64089: ST_TO_ADDR
64090: LD_VAR 0 6
64094: PUSH
64095: FOR_TO
64096: IFFALSE 64666
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
64098: LD_EXP 28
64102: PUSH
64103: LD_VAR 0 2
64107: ARRAY
64108: PUSH
64109: LD_INT 1
64111: ARRAY
64112: PUSH
64113: LD_INT 1
64115: ARRAY
64116: PUSH
64117: LD_INT 0
64119: EQUAL
64120: PUSH
64121: LD_VAR 0 6
64125: PUSH
64126: LD_VAR 0 4
64130: ARRAY
64131: PPUSH
64132: LD_EXP 28
64136: PUSH
64137: LD_VAR 0 2
64141: ARRAY
64142: PUSH
64143: LD_INT 1
64145: ARRAY
64146: PUSH
64147: LD_INT 1
64149: ARRAY
64150: PPUSH
64151: LD_EXP 28
64155: PUSH
64156: LD_VAR 0 2
64160: ARRAY
64161: PUSH
64162: LD_INT 1
64164: ARRAY
64165: PUSH
64166: LD_INT 2
64168: ARRAY
64169: PPUSH
64170: LD_EXP 28
64174: PUSH
64175: LD_VAR 0 2
64179: ARRAY
64180: PUSH
64181: LD_INT 1
64183: ARRAY
64184: PUSH
64185: LD_INT 3
64187: ARRAY
64188: PPUSH
64189: LD_EXP 28
64193: PUSH
64194: LD_VAR 0 2
64198: ARRAY
64199: PUSH
64200: LD_INT 1
64202: ARRAY
64203: PUSH
64204: LD_INT 4
64206: ARRAY
64207: PPUSH
64208: CALL 24551 0 5
64212: OR
64213: IFFALSE 64494
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
64215: LD_ADDR_VAR 0 5
64219: PUSH
64220: LD_EXP 23
64224: PUSH
64225: LD_VAR 0 2
64229: ARRAY
64230: PPUSH
64231: LD_INT 25
64233: PUSH
64234: LD_INT 2
64236: PUSH
64237: EMPTY
64238: LIST
64239: LIST
64240: PPUSH
64241: CALL_OW 72
64245: PUSH
64246: LD_EXP 25
64250: PUSH
64251: LD_VAR 0 2
64255: ARRAY
64256: DIFF
64257: ST_TO_ADDR
// if not tmp then
64258: LD_VAR 0 5
64262: NOT
64263: IFFALSE 64267
// continue ;
64265: GO 64095
// for j in tmp do
64267: LD_ADDR_VAR 0 3
64271: PUSH
64272: LD_VAR 0 5
64276: PUSH
64277: FOR_IN
64278: IFFALSE 64490
// begin if not mc_builders [ i ] then
64280: LD_EXP 29
64284: PUSH
64285: LD_VAR 0 2
64289: ARRAY
64290: NOT
64291: IFFALSE 64349
// begin SetTag ( j , 103 ) ;
64293: LD_VAR 0 3
64297: PPUSH
64298: LD_INT 103
64300: PPUSH
64301: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
64305: LD_ADDR_EXP 29
64309: PUSH
64310: LD_EXP 29
64314: PPUSH
64315: LD_VAR 0 2
64319: PUSH
64320: LD_EXP 29
64324: PUSH
64325: LD_VAR 0 2
64329: ARRAY
64330: PUSH
64331: LD_INT 1
64333: PLUS
64334: PUSH
64335: EMPTY
64336: LIST
64337: LIST
64338: PPUSH
64339: LD_VAR 0 3
64343: PPUSH
64344: CALL 16077 0 3
64348: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
64349: LD_VAR 0 3
64353: PPUSH
64354: CALL_OW 310
64358: IFFALSE 64369
// ComExitBuilding ( j ) ;
64360: LD_VAR 0 3
64364: PPUSH
64365: CALL_OW 122
// wait ( 3 ) ;
64369: LD_INT 3
64371: PPUSH
64372: CALL_OW 67
// if not mc_build_list [ i ] then
64376: LD_EXP 28
64380: PUSH
64381: LD_VAR 0 2
64385: ARRAY
64386: NOT
64387: IFFALSE 64391
// break ;
64389: GO 64490
// if not HasTask ( j ) then
64391: LD_VAR 0 3
64395: PPUSH
64396: CALL_OW 314
64400: NOT
64401: IFFALSE 64488
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
64403: LD_VAR 0 3
64407: PPUSH
64408: LD_EXP 28
64412: PUSH
64413: LD_VAR 0 2
64417: ARRAY
64418: PUSH
64419: LD_INT 1
64421: ARRAY
64422: PUSH
64423: LD_INT 1
64425: ARRAY
64426: PPUSH
64427: LD_EXP 28
64431: PUSH
64432: LD_VAR 0 2
64436: ARRAY
64437: PUSH
64438: LD_INT 1
64440: ARRAY
64441: PUSH
64442: LD_INT 2
64444: ARRAY
64445: PPUSH
64446: LD_EXP 28
64450: PUSH
64451: LD_VAR 0 2
64455: ARRAY
64456: PUSH
64457: LD_INT 1
64459: ARRAY
64460: PUSH
64461: LD_INT 3
64463: ARRAY
64464: PPUSH
64465: LD_EXP 28
64469: PUSH
64470: LD_VAR 0 2
64474: ARRAY
64475: PUSH
64476: LD_INT 1
64478: ARRAY
64479: PUSH
64480: LD_INT 4
64482: ARRAY
64483: PPUSH
64484: CALL_OW 145
// end ;
64488: GO 64277
64490: POP
64491: POP
// end else
64492: GO 64664
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
64494: LD_EXP 23
64498: PUSH
64499: LD_VAR 0 2
64503: ARRAY
64504: PPUSH
64505: LD_EXP 28
64509: PUSH
64510: LD_VAR 0 2
64514: ARRAY
64515: PUSH
64516: LD_INT 1
64518: ARRAY
64519: PUSH
64520: LD_INT 1
64522: ARRAY
64523: PPUSH
64524: LD_EXP 28
64528: PUSH
64529: LD_VAR 0 2
64533: ARRAY
64534: PUSH
64535: LD_INT 1
64537: ARRAY
64538: PUSH
64539: LD_INT 2
64541: ARRAY
64542: PPUSH
64543: LD_EXP 28
64547: PUSH
64548: LD_VAR 0 2
64552: ARRAY
64553: PUSH
64554: LD_INT 1
64556: ARRAY
64557: PUSH
64558: LD_INT 3
64560: ARRAY
64561: PPUSH
64562: LD_EXP 28
64566: PUSH
64567: LD_VAR 0 2
64571: ARRAY
64572: PUSH
64573: LD_INT 1
64575: ARRAY
64576: PUSH
64577: LD_INT 4
64579: ARRAY
64580: PPUSH
64581: LD_EXP 23
64585: PUSH
64586: LD_VAR 0 2
64590: ARRAY
64591: PPUSH
64592: LD_INT 21
64594: PUSH
64595: LD_INT 3
64597: PUSH
64598: EMPTY
64599: LIST
64600: LIST
64601: PPUSH
64602: CALL_OW 72
64606: PPUSH
64607: EMPTY
64608: PPUSH
64609: CALL 23305 0 7
64613: NOT
64614: IFFALSE 64664
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
64616: LD_ADDR_EXP 28
64620: PUSH
64621: LD_EXP 28
64625: PPUSH
64626: LD_VAR 0 2
64630: PPUSH
64631: LD_EXP 28
64635: PUSH
64636: LD_VAR 0 2
64640: ARRAY
64641: PPUSH
64642: LD_INT 1
64644: PPUSH
64645: LD_INT 1
64647: NEG
64648: PPUSH
64649: LD_INT 0
64651: PPUSH
64652: CALL 15495 0 4
64656: PPUSH
64657: CALL_OW 1
64661: ST_TO_ADDR
// continue ;
64662: GO 64095
// end ; end ;
64664: GO 64095
64666: POP
64667: POP
// end ; end ;
64668: GO 63524
64670: POP
64671: POP
// end ;
64672: LD_VAR 0 1
64676: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
64677: LD_INT 0
64679: PPUSH
64680: PPUSH
64681: PPUSH
64682: PPUSH
64683: PPUSH
64684: PPUSH
// if not mc_bases then
64685: LD_EXP 23
64689: NOT
64690: IFFALSE 64694
// exit ;
64692: GO 65121
// for i = 1 to mc_bases do
64694: LD_ADDR_VAR 0 2
64698: PUSH
64699: DOUBLE
64700: LD_INT 1
64702: DEC
64703: ST_TO_ADDR
64704: LD_EXP 23
64708: PUSH
64709: FOR_TO
64710: IFFALSE 65119
// begin tmp := mc_build_upgrade [ i ] ;
64712: LD_ADDR_VAR 0 4
64716: PUSH
64717: LD_EXP 55
64721: PUSH
64722: LD_VAR 0 2
64726: ARRAY
64727: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
64728: LD_ADDR_VAR 0 6
64732: PUSH
64733: LD_EXP 56
64737: PUSH
64738: LD_VAR 0 2
64742: ARRAY
64743: PPUSH
64744: LD_INT 2
64746: PUSH
64747: LD_INT 30
64749: PUSH
64750: LD_INT 6
64752: PUSH
64753: EMPTY
64754: LIST
64755: LIST
64756: PUSH
64757: LD_INT 30
64759: PUSH
64760: LD_INT 7
64762: PUSH
64763: EMPTY
64764: LIST
64765: LIST
64766: PUSH
64767: EMPTY
64768: LIST
64769: LIST
64770: LIST
64771: PPUSH
64772: CALL_OW 72
64776: ST_TO_ADDR
// if not tmp and not lab then
64777: LD_VAR 0 4
64781: NOT
64782: PUSH
64783: LD_VAR 0 6
64787: NOT
64788: AND
64789: IFFALSE 64793
// continue ;
64791: GO 64709
// if tmp then
64793: LD_VAR 0 4
64797: IFFALSE 64917
// for j in tmp do
64799: LD_ADDR_VAR 0 3
64803: PUSH
64804: LD_VAR 0 4
64808: PUSH
64809: FOR_IN
64810: IFFALSE 64915
// begin if UpgradeCost ( j ) then
64812: LD_VAR 0 3
64816: PPUSH
64817: CALL 22965 0 1
64821: IFFALSE 64913
// begin ComUpgrade ( j ) ;
64823: LD_VAR 0 3
64827: PPUSH
64828: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
64832: LD_ADDR_EXP 55
64836: PUSH
64837: LD_EXP 55
64841: PPUSH
64842: LD_VAR 0 2
64846: PPUSH
64847: LD_EXP 55
64851: PUSH
64852: LD_VAR 0 2
64856: ARRAY
64857: PUSH
64858: LD_VAR 0 3
64862: DIFF
64863: PPUSH
64864: CALL_OW 1
64868: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
64869: LD_ADDR_EXP 30
64873: PUSH
64874: LD_EXP 30
64878: PPUSH
64879: LD_VAR 0 2
64883: PUSH
64884: LD_EXP 30
64888: PUSH
64889: LD_VAR 0 2
64893: ARRAY
64894: PUSH
64895: LD_INT 1
64897: PLUS
64898: PUSH
64899: EMPTY
64900: LIST
64901: LIST
64902: PPUSH
64903: LD_VAR 0 3
64907: PPUSH
64908: CALL 16077 0 3
64912: ST_TO_ADDR
// end ; end ;
64913: GO 64809
64915: POP
64916: POP
// if not lab or not mc_lab_upgrade [ i ] then
64917: LD_VAR 0 6
64921: NOT
64922: PUSH
64923: LD_EXP 57
64927: PUSH
64928: LD_VAR 0 2
64932: ARRAY
64933: NOT
64934: OR
64935: IFFALSE 64939
// continue ;
64937: GO 64709
// for j in lab do
64939: LD_ADDR_VAR 0 3
64943: PUSH
64944: LD_VAR 0 6
64948: PUSH
64949: FOR_IN
64950: IFFALSE 65115
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
64952: LD_VAR 0 3
64956: PPUSH
64957: CALL_OW 266
64961: PUSH
64962: LD_INT 6
64964: PUSH
64965: LD_INT 7
64967: PUSH
64968: EMPTY
64969: LIST
64970: LIST
64971: IN
64972: PUSH
64973: LD_VAR 0 3
64977: PPUSH
64978: CALL_OW 461
64982: PUSH
64983: LD_INT 1
64985: NONEQUAL
64986: AND
64987: IFFALSE 65113
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
64989: LD_VAR 0 3
64993: PPUSH
64994: LD_EXP 57
64998: PUSH
64999: LD_VAR 0 2
65003: ARRAY
65004: PUSH
65005: LD_INT 1
65007: ARRAY
65008: PPUSH
65009: CALL 23170 0 2
65013: IFFALSE 65113
// begin ComCancel ( j ) ;
65015: LD_VAR 0 3
65019: PPUSH
65020: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
65024: LD_VAR 0 3
65028: PPUSH
65029: LD_EXP 57
65033: PUSH
65034: LD_VAR 0 2
65038: ARRAY
65039: PUSH
65040: LD_INT 1
65042: ARRAY
65043: PPUSH
65044: CALL_OW 207
// if not j in mc_construct_list [ i ] then
65048: LD_VAR 0 3
65052: PUSH
65053: LD_EXP 30
65057: PUSH
65058: LD_VAR 0 2
65062: ARRAY
65063: IN
65064: NOT
65065: IFFALSE 65111
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
65067: LD_ADDR_EXP 30
65071: PUSH
65072: LD_EXP 30
65076: PPUSH
65077: LD_VAR 0 2
65081: PUSH
65082: LD_EXP 30
65086: PUSH
65087: LD_VAR 0 2
65091: ARRAY
65092: PUSH
65093: LD_INT 1
65095: PLUS
65096: PUSH
65097: EMPTY
65098: LIST
65099: LIST
65100: PPUSH
65101: LD_VAR 0 3
65105: PPUSH
65106: CALL 16077 0 3
65110: ST_TO_ADDR
// break ;
65111: GO 65115
// end ; end ; end ;
65113: GO 64949
65115: POP
65116: POP
// end ;
65117: GO 64709
65119: POP
65120: POP
// end ;
65121: LD_VAR 0 1
65125: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
65126: LD_INT 0
65128: PPUSH
65129: PPUSH
65130: PPUSH
65131: PPUSH
65132: PPUSH
65133: PPUSH
65134: PPUSH
65135: PPUSH
65136: PPUSH
// if not mc_bases then
65137: LD_EXP 23
65141: NOT
65142: IFFALSE 65146
// exit ;
65144: GO 65551
// for i = 1 to mc_bases do
65146: LD_ADDR_VAR 0 2
65150: PUSH
65151: DOUBLE
65152: LD_INT 1
65154: DEC
65155: ST_TO_ADDR
65156: LD_EXP 23
65160: PUSH
65161: FOR_TO
65162: IFFALSE 65549
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
65164: LD_EXP 31
65168: PUSH
65169: LD_VAR 0 2
65173: ARRAY
65174: NOT
65175: PUSH
65176: LD_EXP 23
65180: PUSH
65181: LD_VAR 0 2
65185: ARRAY
65186: PPUSH
65187: LD_INT 30
65189: PUSH
65190: LD_INT 3
65192: PUSH
65193: EMPTY
65194: LIST
65195: LIST
65196: PPUSH
65197: CALL_OW 72
65201: NOT
65202: OR
65203: IFFALSE 65207
// continue ;
65205: GO 65161
// busy := false ;
65207: LD_ADDR_VAR 0 8
65211: PUSH
65212: LD_INT 0
65214: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
65215: LD_ADDR_VAR 0 4
65219: PUSH
65220: LD_EXP 23
65224: PUSH
65225: LD_VAR 0 2
65229: ARRAY
65230: PPUSH
65231: LD_INT 30
65233: PUSH
65234: LD_INT 3
65236: PUSH
65237: EMPTY
65238: LIST
65239: LIST
65240: PPUSH
65241: CALL_OW 72
65245: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
65246: LD_ADDR_VAR 0 6
65250: PUSH
65251: LD_EXP 31
65255: PUSH
65256: LD_VAR 0 2
65260: ARRAY
65261: PPUSH
65262: LD_INT 2
65264: PUSH
65265: LD_INT 30
65267: PUSH
65268: LD_INT 32
65270: PUSH
65271: EMPTY
65272: LIST
65273: LIST
65274: PUSH
65275: LD_INT 30
65277: PUSH
65278: LD_INT 33
65280: PUSH
65281: EMPTY
65282: LIST
65283: LIST
65284: PUSH
65285: EMPTY
65286: LIST
65287: LIST
65288: LIST
65289: PPUSH
65290: CALL_OW 72
65294: ST_TO_ADDR
// if not t then
65295: LD_VAR 0 6
65299: NOT
65300: IFFALSE 65304
// continue ;
65302: GO 65161
// for j in tmp do
65304: LD_ADDR_VAR 0 3
65308: PUSH
65309: LD_VAR 0 4
65313: PUSH
65314: FOR_IN
65315: IFFALSE 65345
// if not BuildingStatus ( j ) = bs_idle then
65317: LD_VAR 0 3
65321: PPUSH
65322: CALL_OW 461
65326: PUSH
65327: LD_INT 2
65329: EQUAL
65330: NOT
65331: IFFALSE 65343
// begin busy := true ;
65333: LD_ADDR_VAR 0 8
65337: PUSH
65338: LD_INT 1
65340: ST_TO_ADDR
// break ;
65341: GO 65345
// end ;
65343: GO 65314
65345: POP
65346: POP
// if busy then
65347: LD_VAR 0 8
65351: IFFALSE 65355
// continue ;
65353: GO 65161
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
65355: LD_ADDR_VAR 0 7
65359: PUSH
65360: LD_VAR 0 6
65364: PPUSH
65365: LD_INT 35
65367: PUSH
65368: LD_INT 0
65370: PUSH
65371: EMPTY
65372: LIST
65373: LIST
65374: PPUSH
65375: CALL_OW 72
65379: ST_TO_ADDR
// if tw then
65380: LD_VAR 0 7
65384: IFFALSE 65461
// begin tw := tw [ 1 ] ;
65386: LD_ADDR_VAR 0 7
65390: PUSH
65391: LD_VAR 0 7
65395: PUSH
65396: LD_INT 1
65398: ARRAY
65399: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
65400: LD_ADDR_VAR 0 9
65404: PUSH
65405: LD_VAR 0 7
65409: PPUSH
65410: LD_EXP 48
65414: PUSH
65415: LD_VAR 0 2
65419: ARRAY
65420: PPUSH
65421: CALL 21462 0 2
65425: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
65426: LD_EXP 62
65430: PUSH
65431: LD_VAR 0 2
65435: ARRAY
65436: IFFALSE 65459
// if not weapon in mc_allowed_tower_weapons [ i ] then
65438: LD_VAR 0 9
65442: PUSH
65443: LD_EXP 62
65447: PUSH
65448: LD_VAR 0 2
65452: ARRAY
65453: IN
65454: NOT
65455: IFFALSE 65459
// continue ;
65457: GO 65161
// end else
65459: GO 65524
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
65461: LD_ADDR_VAR 0 5
65465: PUSH
65466: LD_EXP 31
65470: PUSH
65471: LD_VAR 0 2
65475: ARRAY
65476: PPUSH
65477: LD_VAR 0 4
65481: PPUSH
65482: CALL 48365 0 2
65486: ST_TO_ADDR
// if not tmp2 then
65487: LD_VAR 0 5
65491: NOT
65492: IFFALSE 65496
// continue ;
65494: GO 65161
// tw := tmp2 [ 1 ] ;
65496: LD_ADDR_VAR 0 7
65500: PUSH
65501: LD_VAR 0 5
65505: PUSH
65506: LD_INT 1
65508: ARRAY
65509: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
65510: LD_ADDR_VAR 0 9
65514: PUSH
65515: LD_VAR 0 5
65519: PUSH
65520: LD_INT 2
65522: ARRAY
65523: ST_TO_ADDR
// end ; if not weapon then
65524: LD_VAR 0 9
65528: NOT
65529: IFFALSE 65533
// continue ;
65531: GO 65161
// ComPlaceWeapon ( tw , weapon ) ;
65533: LD_VAR 0 7
65537: PPUSH
65538: LD_VAR 0 9
65542: PPUSH
65543: CALL_OW 148
// end ;
65547: GO 65161
65549: POP
65550: POP
// end ;
65551: LD_VAR 0 1
65555: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
65556: LD_INT 0
65558: PPUSH
65559: PPUSH
65560: PPUSH
65561: PPUSH
65562: PPUSH
65563: PPUSH
65564: PPUSH
// if not mc_bases then
65565: LD_EXP 23
65569: NOT
65570: IFFALSE 65574
// exit ;
65572: GO 66349
// for i = 1 to mc_bases do
65574: LD_ADDR_VAR 0 2
65578: PUSH
65579: DOUBLE
65580: LD_INT 1
65582: DEC
65583: ST_TO_ADDR
65584: LD_EXP 23
65588: PUSH
65589: FOR_TO
65590: IFFALSE 66347
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
65592: LD_EXP 36
65596: PUSH
65597: LD_VAR 0 2
65601: ARRAY
65602: NOT
65603: PUSH
65604: LD_EXP 36
65608: PUSH
65609: LD_VAR 0 2
65613: ARRAY
65614: PUSH
65615: LD_EXP 37
65619: PUSH
65620: LD_VAR 0 2
65624: ARRAY
65625: EQUAL
65626: OR
65627: PUSH
65628: LD_EXP 46
65632: PUSH
65633: LD_VAR 0 2
65637: ARRAY
65638: OR
65639: IFFALSE 65643
// continue ;
65641: GO 65589
// if mc_miners [ i ] then
65643: LD_EXP 37
65647: PUSH
65648: LD_VAR 0 2
65652: ARRAY
65653: IFFALSE 66034
// begin for j = mc_miners [ i ] downto 1 do
65655: LD_ADDR_VAR 0 3
65659: PUSH
65660: DOUBLE
65661: LD_EXP 37
65665: PUSH
65666: LD_VAR 0 2
65670: ARRAY
65671: INC
65672: ST_TO_ADDR
65673: LD_INT 1
65675: PUSH
65676: FOR_DOWNTO
65677: IFFALSE 66032
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
65679: LD_EXP 37
65683: PUSH
65684: LD_VAR 0 2
65688: ARRAY
65689: PUSH
65690: LD_VAR 0 3
65694: ARRAY
65695: PPUSH
65696: CALL_OW 301
65700: PUSH
65701: LD_EXP 37
65705: PUSH
65706: LD_VAR 0 2
65710: ARRAY
65711: PUSH
65712: LD_VAR 0 3
65716: ARRAY
65717: PPUSH
65718: CALL_OW 257
65722: PUSH
65723: LD_INT 1
65725: NONEQUAL
65726: OR
65727: IFFALSE 65790
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
65729: LD_ADDR_VAR 0 5
65733: PUSH
65734: LD_EXP 37
65738: PUSH
65739: LD_VAR 0 2
65743: ARRAY
65744: PUSH
65745: LD_EXP 37
65749: PUSH
65750: LD_VAR 0 2
65754: ARRAY
65755: PUSH
65756: LD_VAR 0 3
65760: ARRAY
65761: DIFF
65762: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
65763: LD_ADDR_EXP 37
65767: PUSH
65768: LD_EXP 37
65772: PPUSH
65773: LD_VAR 0 2
65777: PPUSH
65778: LD_VAR 0 5
65782: PPUSH
65783: CALL_OW 1
65787: ST_TO_ADDR
// continue ;
65788: GO 65676
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
65790: LD_EXP 37
65794: PUSH
65795: LD_VAR 0 2
65799: ARRAY
65800: PUSH
65801: LD_VAR 0 3
65805: ARRAY
65806: PPUSH
65807: CALL_OW 257
65811: PUSH
65812: LD_INT 1
65814: EQUAL
65815: PUSH
65816: LD_EXP 37
65820: PUSH
65821: LD_VAR 0 2
65825: ARRAY
65826: PUSH
65827: LD_VAR 0 3
65831: ARRAY
65832: PPUSH
65833: CALL_OW 459
65837: NOT
65838: AND
65839: PUSH
65840: LD_EXP 37
65844: PUSH
65845: LD_VAR 0 2
65849: ARRAY
65850: PUSH
65851: LD_VAR 0 3
65855: ARRAY
65856: PPUSH
65857: CALL_OW 314
65861: NOT
65862: AND
65863: IFFALSE 66030
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
65865: LD_EXP 37
65869: PUSH
65870: LD_VAR 0 2
65874: ARRAY
65875: PUSH
65876: LD_VAR 0 3
65880: ARRAY
65881: PPUSH
65882: CALL_OW 310
65886: IFFALSE 65909
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
65888: LD_EXP 37
65892: PUSH
65893: LD_VAR 0 2
65897: ARRAY
65898: PUSH
65899: LD_VAR 0 3
65903: ARRAY
65904: PPUSH
65905: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
65909: LD_EXP 37
65913: PUSH
65914: LD_VAR 0 2
65918: ARRAY
65919: PUSH
65920: LD_VAR 0 3
65924: ARRAY
65925: PPUSH
65926: CALL_OW 314
65930: NOT
65931: IFFALSE 66030
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
65933: LD_ADDR_VAR 0 7
65937: PUSH
65938: LD_VAR 0 3
65942: PUSH
65943: LD_EXP 36
65947: PUSH
65948: LD_VAR 0 2
65952: ARRAY
65953: PPUSH
65954: CALL 13217 0 1
65958: MOD
65959: PUSH
65960: LD_INT 1
65962: PLUS
65963: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
65964: LD_EXP 37
65968: PUSH
65969: LD_VAR 0 2
65973: ARRAY
65974: PUSH
65975: LD_VAR 0 3
65979: ARRAY
65980: PPUSH
65981: LD_EXP 36
65985: PUSH
65986: LD_VAR 0 2
65990: ARRAY
65991: PUSH
65992: LD_VAR 0 7
65996: ARRAY
65997: PUSH
65998: LD_INT 1
66000: ARRAY
66001: PPUSH
66002: LD_EXP 36
66006: PUSH
66007: LD_VAR 0 2
66011: ARRAY
66012: PUSH
66013: LD_VAR 0 7
66017: ARRAY
66018: PUSH
66019: LD_INT 2
66021: ARRAY
66022: PPUSH
66023: LD_INT 0
66025: PPUSH
66026: CALL_OW 193
// end ; end ; end ;
66030: GO 65676
66032: POP
66033: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
66034: LD_ADDR_VAR 0 5
66038: PUSH
66039: LD_EXP 23
66043: PUSH
66044: LD_VAR 0 2
66048: ARRAY
66049: PPUSH
66050: LD_INT 2
66052: PUSH
66053: LD_INT 30
66055: PUSH
66056: LD_INT 4
66058: PUSH
66059: EMPTY
66060: LIST
66061: LIST
66062: PUSH
66063: LD_INT 30
66065: PUSH
66066: LD_INT 5
66068: PUSH
66069: EMPTY
66070: LIST
66071: LIST
66072: PUSH
66073: LD_INT 30
66075: PUSH
66076: LD_INT 32
66078: PUSH
66079: EMPTY
66080: LIST
66081: LIST
66082: PUSH
66083: EMPTY
66084: LIST
66085: LIST
66086: LIST
66087: LIST
66088: PPUSH
66089: CALL_OW 72
66093: ST_TO_ADDR
// if not tmp then
66094: LD_VAR 0 5
66098: NOT
66099: IFFALSE 66103
// continue ;
66101: GO 65589
// list := [ ] ;
66103: LD_ADDR_VAR 0 6
66107: PUSH
66108: EMPTY
66109: ST_TO_ADDR
// for j in tmp do
66110: LD_ADDR_VAR 0 3
66114: PUSH
66115: LD_VAR 0 5
66119: PUSH
66120: FOR_IN
66121: IFFALSE 66190
// begin for k in UnitsInside ( j ) do
66123: LD_ADDR_VAR 0 4
66127: PUSH
66128: LD_VAR 0 3
66132: PPUSH
66133: CALL_OW 313
66137: PUSH
66138: FOR_IN
66139: IFFALSE 66186
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
66141: LD_VAR 0 4
66145: PPUSH
66146: CALL_OW 257
66150: PUSH
66151: LD_INT 1
66153: EQUAL
66154: PUSH
66155: LD_VAR 0 4
66159: PPUSH
66160: CALL_OW 459
66164: NOT
66165: AND
66166: IFFALSE 66184
// list := list ^ k ;
66168: LD_ADDR_VAR 0 6
66172: PUSH
66173: LD_VAR 0 6
66177: PUSH
66178: LD_VAR 0 4
66182: ADD
66183: ST_TO_ADDR
66184: GO 66138
66186: POP
66187: POP
// end ;
66188: GO 66120
66190: POP
66191: POP
// list := list diff mc_miners [ i ] ;
66192: LD_ADDR_VAR 0 6
66196: PUSH
66197: LD_VAR 0 6
66201: PUSH
66202: LD_EXP 37
66206: PUSH
66207: LD_VAR 0 2
66211: ARRAY
66212: DIFF
66213: ST_TO_ADDR
// if not list then
66214: LD_VAR 0 6
66218: NOT
66219: IFFALSE 66223
// continue ;
66221: GO 65589
// k := mc_mines [ i ] - mc_miners [ i ] ;
66223: LD_ADDR_VAR 0 4
66227: PUSH
66228: LD_EXP 36
66232: PUSH
66233: LD_VAR 0 2
66237: ARRAY
66238: PUSH
66239: LD_EXP 37
66243: PUSH
66244: LD_VAR 0 2
66248: ARRAY
66249: MINUS
66250: ST_TO_ADDR
// if k > list then
66251: LD_VAR 0 4
66255: PUSH
66256: LD_VAR 0 6
66260: GREATER
66261: IFFALSE 66273
// k := list ;
66263: LD_ADDR_VAR 0 4
66267: PUSH
66268: LD_VAR 0 6
66272: ST_TO_ADDR
// for j = 1 to k do
66273: LD_ADDR_VAR 0 3
66277: PUSH
66278: DOUBLE
66279: LD_INT 1
66281: DEC
66282: ST_TO_ADDR
66283: LD_VAR 0 4
66287: PUSH
66288: FOR_TO
66289: IFFALSE 66343
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
66291: LD_ADDR_EXP 37
66295: PUSH
66296: LD_EXP 37
66300: PPUSH
66301: LD_VAR 0 2
66305: PUSH
66306: LD_EXP 37
66310: PUSH
66311: LD_VAR 0 2
66315: ARRAY
66316: PUSH
66317: LD_INT 1
66319: PLUS
66320: PUSH
66321: EMPTY
66322: LIST
66323: LIST
66324: PPUSH
66325: LD_VAR 0 6
66329: PUSH
66330: LD_VAR 0 3
66334: ARRAY
66335: PPUSH
66336: CALL 16077 0 3
66340: ST_TO_ADDR
66341: GO 66288
66343: POP
66344: POP
// end ;
66345: GO 65589
66347: POP
66348: POP
// end ;
66349: LD_VAR 0 1
66353: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
66354: LD_INT 0
66356: PPUSH
66357: PPUSH
66358: PPUSH
66359: PPUSH
66360: PPUSH
66361: PPUSH
66362: PPUSH
66363: PPUSH
66364: PPUSH
66365: PPUSH
66366: PPUSH
// if not mc_bases then
66367: LD_EXP 23
66371: NOT
66372: IFFALSE 66376
// exit ;
66374: GO 68199
// for i = 1 to mc_bases do
66376: LD_ADDR_VAR 0 2
66380: PUSH
66381: DOUBLE
66382: LD_INT 1
66384: DEC
66385: ST_TO_ADDR
66386: LD_EXP 23
66390: PUSH
66391: FOR_TO
66392: IFFALSE 68197
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
66394: LD_EXP 23
66398: PUSH
66399: LD_VAR 0 2
66403: ARRAY
66404: NOT
66405: PUSH
66406: LD_EXP 30
66410: PUSH
66411: LD_VAR 0 2
66415: ARRAY
66416: OR
66417: IFFALSE 66421
// continue ;
66419: GO 66391
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
66421: LD_EXP 39
66425: PUSH
66426: LD_VAR 0 2
66430: ARRAY
66431: NOT
66432: PUSH
66433: LD_EXP 40
66437: PUSH
66438: LD_VAR 0 2
66442: ARRAY
66443: AND
66444: IFFALSE 66482
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
66446: LD_ADDR_EXP 40
66450: PUSH
66451: LD_EXP 40
66455: PPUSH
66456: LD_VAR 0 2
66460: PPUSH
66461: EMPTY
66462: PPUSH
66463: CALL_OW 1
66467: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
66468: LD_VAR 0 2
66472: PPUSH
66473: LD_INT 107
66475: PPUSH
66476: CALL 57208 0 2
// continue ;
66480: GO 66391
// end ; target := [ ] ;
66482: LD_ADDR_VAR 0 7
66486: PUSH
66487: EMPTY
66488: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
66489: LD_ADDR_VAR 0 6
66493: PUSH
66494: LD_EXP 23
66498: PUSH
66499: LD_VAR 0 2
66503: ARRAY
66504: PUSH
66505: LD_INT 1
66507: ARRAY
66508: PPUSH
66509: CALL_OW 255
66513: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
66514: LD_ADDR_VAR 0 9
66518: PUSH
66519: LD_EXP 23
66523: PUSH
66524: LD_VAR 0 2
66528: ARRAY
66529: PPUSH
66530: LD_INT 2
66532: PUSH
66533: LD_INT 30
66535: PUSH
66536: LD_INT 0
66538: PUSH
66539: EMPTY
66540: LIST
66541: LIST
66542: PUSH
66543: LD_INT 30
66545: PUSH
66546: LD_INT 1
66548: PUSH
66549: EMPTY
66550: LIST
66551: LIST
66552: PUSH
66553: EMPTY
66554: LIST
66555: LIST
66556: LIST
66557: PPUSH
66558: CALL_OW 72
66562: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
66563: LD_ADDR_VAR 0 3
66567: PUSH
66568: DOUBLE
66569: LD_EXP 39
66573: PUSH
66574: LD_VAR 0 2
66578: ARRAY
66579: INC
66580: ST_TO_ADDR
66581: LD_INT 1
66583: PUSH
66584: FOR_DOWNTO
66585: IFFALSE 66830
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
66587: LD_EXP 39
66591: PUSH
66592: LD_VAR 0 2
66596: ARRAY
66597: PUSH
66598: LD_VAR 0 3
66602: ARRAY
66603: PUSH
66604: LD_INT 2
66606: ARRAY
66607: PPUSH
66608: LD_EXP 39
66612: PUSH
66613: LD_VAR 0 2
66617: ARRAY
66618: PUSH
66619: LD_VAR 0 3
66623: ARRAY
66624: PUSH
66625: LD_INT 3
66627: ARRAY
66628: PPUSH
66629: CALL_OW 488
66633: PUSH
66634: LD_EXP 39
66638: PUSH
66639: LD_VAR 0 2
66643: ARRAY
66644: PUSH
66645: LD_VAR 0 3
66649: ARRAY
66650: PUSH
66651: LD_INT 2
66653: ARRAY
66654: PPUSH
66655: LD_EXP 39
66659: PUSH
66660: LD_VAR 0 2
66664: ARRAY
66665: PUSH
66666: LD_VAR 0 3
66670: ARRAY
66671: PUSH
66672: LD_INT 3
66674: ARRAY
66675: PPUSH
66676: CALL_OW 284
66680: PUSH
66681: LD_INT 0
66683: EQUAL
66684: AND
66685: IFFALSE 66740
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
66687: LD_ADDR_VAR 0 5
66691: PUSH
66692: LD_EXP 39
66696: PUSH
66697: LD_VAR 0 2
66701: ARRAY
66702: PPUSH
66703: LD_VAR 0 3
66707: PPUSH
66708: CALL_OW 3
66712: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
66713: LD_ADDR_EXP 39
66717: PUSH
66718: LD_EXP 39
66722: PPUSH
66723: LD_VAR 0 2
66727: PPUSH
66728: LD_VAR 0 5
66732: PPUSH
66733: CALL_OW 1
66737: ST_TO_ADDR
// continue ;
66738: GO 66584
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
66740: LD_VAR 0 6
66744: PPUSH
66745: LD_EXP 39
66749: PUSH
66750: LD_VAR 0 2
66754: ARRAY
66755: PUSH
66756: LD_VAR 0 3
66760: ARRAY
66761: PUSH
66762: LD_INT 2
66764: ARRAY
66765: PPUSH
66766: LD_EXP 39
66770: PUSH
66771: LD_VAR 0 2
66775: ARRAY
66776: PUSH
66777: LD_VAR 0 3
66781: ARRAY
66782: PUSH
66783: LD_INT 3
66785: ARRAY
66786: PPUSH
66787: LD_INT 30
66789: PPUSH
66790: CALL 17341 0 4
66794: PUSH
66795: LD_INT 4
66797: ARRAY
66798: PUSH
66799: LD_INT 0
66801: EQUAL
66802: IFFALSE 66828
// begin target := mc_crates [ i ] [ j ] ;
66804: LD_ADDR_VAR 0 7
66808: PUSH
66809: LD_EXP 39
66813: PUSH
66814: LD_VAR 0 2
66818: ARRAY
66819: PUSH
66820: LD_VAR 0 3
66824: ARRAY
66825: ST_TO_ADDR
// break ;
66826: GO 66830
// end ; end ;
66828: GO 66584
66830: POP
66831: POP
// if not target then
66832: LD_VAR 0 7
66836: NOT
66837: IFFALSE 66841
// continue ;
66839: GO 66391
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
66841: LD_ADDR_VAR 0 8
66845: PUSH
66846: LD_EXP 42
66850: PUSH
66851: LD_VAR 0 2
66855: ARRAY
66856: PPUSH
66857: LD_INT 2
66859: PUSH
66860: LD_INT 3
66862: PUSH
66863: LD_INT 58
66865: PUSH
66866: EMPTY
66867: LIST
66868: PUSH
66869: EMPTY
66870: LIST
66871: LIST
66872: PUSH
66873: LD_INT 61
66875: PUSH
66876: EMPTY
66877: LIST
66878: PUSH
66879: LD_INT 33
66881: PUSH
66882: LD_INT 5
66884: PUSH
66885: EMPTY
66886: LIST
66887: LIST
66888: PUSH
66889: LD_INT 33
66891: PUSH
66892: LD_INT 3
66894: PUSH
66895: EMPTY
66896: LIST
66897: LIST
66898: PUSH
66899: EMPTY
66900: LIST
66901: LIST
66902: LIST
66903: LIST
66904: LIST
66905: PUSH
66906: LD_INT 2
66908: PUSH
66909: LD_INT 34
66911: PUSH
66912: LD_INT 32
66914: PUSH
66915: EMPTY
66916: LIST
66917: LIST
66918: PUSH
66919: LD_INT 34
66921: PUSH
66922: LD_INT 51
66924: PUSH
66925: EMPTY
66926: LIST
66927: LIST
66928: PUSH
66929: LD_INT 34
66931: PUSH
66932: LD_INT 12
66934: PUSH
66935: EMPTY
66936: LIST
66937: LIST
66938: PUSH
66939: EMPTY
66940: LIST
66941: LIST
66942: LIST
66943: LIST
66944: PUSH
66945: EMPTY
66946: LIST
66947: LIST
66948: PPUSH
66949: CALL_OW 72
66953: ST_TO_ADDR
// if not cargo then
66954: LD_VAR 0 8
66958: NOT
66959: IFFALSE 67665
// begin if mc_crates_collector [ i ] < 5 then
66961: LD_EXP 40
66965: PUSH
66966: LD_VAR 0 2
66970: ARRAY
66971: PUSH
66972: LD_INT 5
66974: LESS
66975: IFFALSE 67341
// begin if mc_ape [ i ] then
66977: LD_EXP 52
66981: PUSH
66982: LD_VAR 0 2
66986: ARRAY
66987: IFFALSE 67034
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
66989: LD_ADDR_VAR 0 5
66993: PUSH
66994: LD_EXP 52
66998: PUSH
66999: LD_VAR 0 2
67003: ARRAY
67004: PPUSH
67005: LD_INT 25
67007: PUSH
67008: LD_INT 16
67010: PUSH
67011: EMPTY
67012: LIST
67013: LIST
67014: PUSH
67015: LD_INT 24
67017: PUSH
67018: LD_INT 750
67020: PUSH
67021: EMPTY
67022: LIST
67023: LIST
67024: PUSH
67025: EMPTY
67026: LIST
67027: LIST
67028: PPUSH
67029: CALL_OW 72
67033: ST_TO_ADDR
// if not tmp then
67034: LD_VAR 0 5
67038: NOT
67039: IFFALSE 67086
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
67041: LD_ADDR_VAR 0 5
67045: PUSH
67046: LD_EXP 23
67050: PUSH
67051: LD_VAR 0 2
67055: ARRAY
67056: PPUSH
67057: LD_INT 25
67059: PUSH
67060: LD_INT 2
67062: PUSH
67063: EMPTY
67064: LIST
67065: LIST
67066: PUSH
67067: LD_INT 24
67069: PUSH
67070: LD_INT 750
67072: PUSH
67073: EMPTY
67074: LIST
67075: LIST
67076: PUSH
67077: EMPTY
67078: LIST
67079: LIST
67080: PPUSH
67081: CALL_OW 72
67085: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
67086: LD_EXP 52
67090: PUSH
67091: LD_VAR 0 2
67095: ARRAY
67096: PUSH
67097: LD_EXP 23
67101: PUSH
67102: LD_VAR 0 2
67106: ARRAY
67107: PPUSH
67108: LD_INT 25
67110: PUSH
67111: LD_INT 2
67113: PUSH
67114: EMPTY
67115: LIST
67116: LIST
67117: PUSH
67118: LD_INT 24
67120: PUSH
67121: LD_INT 750
67123: PUSH
67124: EMPTY
67125: LIST
67126: LIST
67127: PUSH
67128: EMPTY
67129: LIST
67130: LIST
67131: PPUSH
67132: CALL_OW 72
67136: AND
67137: PUSH
67138: LD_VAR 0 5
67142: PUSH
67143: LD_INT 5
67145: LESS
67146: AND
67147: IFFALSE 67229
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
67149: LD_ADDR_VAR 0 3
67153: PUSH
67154: LD_EXP 23
67158: PUSH
67159: LD_VAR 0 2
67163: ARRAY
67164: PPUSH
67165: LD_INT 25
67167: PUSH
67168: LD_INT 2
67170: PUSH
67171: EMPTY
67172: LIST
67173: LIST
67174: PUSH
67175: LD_INT 24
67177: PUSH
67178: LD_INT 750
67180: PUSH
67181: EMPTY
67182: LIST
67183: LIST
67184: PUSH
67185: EMPTY
67186: LIST
67187: LIST
67188: PPUSH
67189: CALL_OW 72
67193: PUSH
67194: FOR_IN
67195: IFFALSE 67227
// begin tmp := tmp union j ;
67197: LD_ADDR_VAR 0 5
67201: PUSH
67202: LD_VAR 0 5
67206: PUSH
67207: LD_VAR 0 3
67211: UNION
67212: ST_TO_ADDR
// if tmp >= 5 then
67213: LD_VAR 0 5
67217: PUSH
67218: LD_INT 5
67220: GREATEREQUAL
67221: IFFALSE 67225
// break ;
67223: GO 67227
// end ;
67225: GO 67194
67227: POP
67228: POP
// end ; if not tmp then
67229: LD_VAR 0 5
67233: NOT
67234: IFFALSE 67238
// continue ;
67236: GO 66391
// for j in tmp do
67238: LD_ADDR_VAR 0 3
67242: PUSH
67243: LD_VAR 0 5
67247: PUSH
67248: FOR_IN
67249: IFFALSE 67339
// if not GetTag ( j ) then
67251: LD_VAR 0 3
67255: PPUSH
67256: CALL_OW 110
67260: NOT
67261: IFFALSE 67337
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
67263: LD_ADDR_EXP 40
67267: PUSH
67268: LD_EXP 40
67272: PPUSH
67273: LD_VAR 0 2
67277: PUSH
67278: LD_EXP 40
67282: PUSH
67283: LD_VAR 0 2
67287: ARRAY
67288: PUSH
67289: LD_INT 1
67291: PLUS
67292: PUSH
67293: EMPTY
67294: LIST
67295: LIST
67296: PPUSH
67297: LD_VAR 0 3
67301: PPUSH
67302: CALL 16077 0 3
67306: ST_TO_ADDR
// SetTag ( j , 107 ) ;
67307: LD_VAR 0 3
67311: PPUSH
67312: LD_INT 107
67314: PPUSH
67315: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
67319: LD_EXP 40
67323: PUSH
67324: LD_VAR 0 2
67328: ARRAY
67329: PUSH
67330: LD_INT 5
67332: GREATEREQUAL
67333: IFFALSE 67337
// break ;
67335: GO 67339
// end ;
67337: GO 67248
67339: POP
67340: POP
// end ; if mc_crates_collector [ i ] and target then
67341: LD_EXP 40
67345: PUSH
67346: LD_VAR 0 2
67350: ARRAY
67351: PUSH
67352: LD_VAR 0 7
67356: AND
67357: IFFALSE 67663
// begin if mc_crates_collector [ i ] < target [ 1 ] then
67359: LD_EXP 40
67363: PUSH
67364: LD_VAR 0 2
67368: ARRAY
67369: PUSH
67370: LD_VAR 0 7
67374: PUSH
67375: LD_INT 1
67377: ARRAY
67378: LESS
67379: IFFALSE 67399
// tmp := mc_crates_collector [ i ] else
67381: LD_ADDR_VAR 0 5
67385: PUSH
67386: LD_EXP 40
67390: PUSH
67391: LD_VAR 0 2
67395: ARRAY
67396: ST_TO_ADDR
67397: GO 67413
// tmp := target [ 1 ] ;
67399: LD_ADDR_VAR 0 5
67403: PUSH
67404: LD_VAR 0 7
67408: PUSH
67409: LD_INT 1
67411: ARRAY
67412: ST_TO_ADDR
// k := 0 ;
67413: LD_ADDR_VAR 0 4
67417: PUSH
67418: LD_INT 0
67420: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
67421: LD_ADDR_VAR 0 3
67425: PUSH
67426: LD_EXP 40
67430: PUSH
67431: LD_VAR 0 2
67435: ARRAY
67436: PUSH
67437: FOR_IN
67438: IFFALSE 67661
// begin k := k + 1 ;
67440: LD_ADDR_VAR 0 4
67444: PUSH
67445: LD_VAR 0 4
67449: PUSH
67450: LD_INT 1
67452: PLUS
67453: ST_TO_ADDR
// if k > tmp then
67454: LD_VAR 0 4
67458: PUSH
67459: LD_VAR 0 5
67463: GREATER
67464: IFFALSE 67468
// break ;
67466: GO 67661
// if not GetClass ( j ) in [ 2 , 16 ] then
67468: LD_VAR 0 3
67472: PPUSH
67473: CALL_OW 257
67477: PUSH
67478: LD_INT 2
67480: PUSH
67481: LD_INT 16
67483: PUSH
67484: EMPTY
67485: LIST
67486: LIST
67487: IN
67488: NOT
67489: IFFALSE 67542
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
67491: LD_ADDR_EXP 40
67495: PUSH
67496: LD_EXP 40
67500: PPUSH
67501: LD_VAR 0 2
67505: PPUSH
67506: LD_EXP 40
67510: PUSH
67511: LD_VAR 0 2
67515: ARRAY
67516: PUSH
67517: LD_VAR 0 3
67521: DIFF
67522: PPUSH
67523: CALL_OW 1
67527: ST_TO_ADDR
// SetTag ( j , 0 ) ;
67528: LD_VAR 0 3
67532: PPUSH
67533: LD_INT 0
67535: PPUSH
67536: CALL_OW 109
// continue ;
67540: GO 67437
// end ; if IsInUnit ( j ) then
67542: LD_VAR 0 3
67546: PPUSH
67547: CALL_OW 310
67551: IFFALSE 67562
// ComExitBuilding ( j ) ;
67553: LD_VAR 0 3
67557: PPUSH
67558: CALL_OW 122
// wait ( 3 ) ;
67562: LD_INT 3
67564: PPUSH
67565: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
67569: LD_VAR 0 3
67573: PPUSH
67574: CALL_OW 314
67578: PUSH
67579: LD_VAR 0 6
67583: PPUSH
67584: LD_VAR 0 7
67588: PUSH
67589: LD_INT 2
67591: ARRAY
67592: PPUSH
67593: LD_VAR 0 7
67597: PUSH
67598: LD_INT 3
67600: ARRAY
67601: PPUSH
67602: LD_INT 30
67604: PPUSH
67605: CALL 17341 0 4
67609: PUSH
67610: LD_INT 4
67612: ARRAY
67613: AND
67614: IFFALSE 67632
// ComStandNearbyBuilding ( j , depot ) else
67616: LD_VAR 0 3
67620: PPUSH
67621: LD_VAR 0 9
67625: PPUSH
67626: CALL 12679 0 2
67630: GO 67659
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
67632: LD_VAR 0 3
67636: PPUSH
67637: LD_VAR 0 7
67641: PUSH
67642: LD_INT 2
67644: ARRAY
67645: PPUSH
67646: LD_VAR 0 7
67650: PUSH
67651: LD_INT 3
67653: ARRAY
67654: PPUSH
67655: CALL_OW 117
// end ;
67659: GO 67437
67661: POP
67662: POP
// end ; end else
67663: GO 68195
// begin for j in cargo do
67665: LD_ADDR_VAR 0 3
67669: PUSH
67670: LD_VAR 0 8
67674: PUSH
67675: FOR_IN
67676: IFFALSE 68193
// begin if GetTag ( j ) <> 0 then
67678: LD_VAR 0 3
67682: PPUSH
67683: CALL_OW 110
67687: PUSH
67688: LD_INT 0
67690: NONEQUAL
67691: IFFALSE 67695
// continue ;
67693: GO 67675
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
67695: LD_VAR 0 3
67699: PPUSH
67700: CALL_OW 256
67704: PUSH
67705: LD_INT 1000
67707: LESS
67708: PUSH
67709: LD_VAR 0 3
67713: PPUSH
67714: LD_EXP 47
67718: PUSH
67719: LD_VAR 0 2
67723: ARRAY
67724: PPUSH
67725: CALL_OW 308
67729: NOT
67730: AND
67731: IFFALSE 67753
// ComMoveToArea ( j , mc_parking [ i ] ) ;
67733: LD_VAR 0 3
67737: PPUSH
67738: LD_EXP 47
67742: PUSH
67743: LD_VAR 0 2
67747: ARRAY
67748: PPUSH
67749: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
67753: LD_VAR 0 3
67757: PPUSH
67758: CALL_OW 256
67762: PUSH
67763: LD_INT 1000
67765: LESS
67766: PUSH
67767: LD_VAR 0 3
67771: PPUSH
67772: LD_EXP 47
67776: PUSH
67777: LD_VAR 0 2
67781: ARRAY
67782: PPUSH
67783: CALL_OW 308
67787: AND
67788: IFFALSE 67792
// continue ;
67790: GO 67675
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
67792: LD_VAR 0 3
67796: PPUSH
67797: CALL_OW 262
67801: PUSH
67802: LD_INT 2
67804: EQUAL
67805: PUSH
67806: LD_VAR 0 3
67810: PPUSH
67811: CALL_OW 261
67815: PUSH
67816: LD_INT 15
67818: LESS
67819: AND
67820: IFFALSE 67824
// continue ;
67822: GO 67675
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
67824: LD_VAR 0 3
67828: PPUSH
67829: CALL_OW 262
67833: PUSH
67834: LD_INT 1
67836: EQUAL
67837: PUSH
67838: LD_VAR 0 3
67842: PPUSH
67843: CALL_OW 261
67847: PUSH
67848: LD_INT 10
67850: LESS
67851: AND
67852: IFFALSE 68132
// begin if not depot then
67854: LD_VAR 0 9
67858: NOT
67859: IFFALSE 67863
// continue ;
67861: GO 67675
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
67863: LD_VAR 0 3
67867: PPUSH
67868: LD_VAR 0 9
67872: PPUSH
67873: LD_VAR 0 3
67877: PPUSH
67878: CALL_OW 74
67882: PPUSH
67883: CALL_OW 296
67887: PUSH
67888: LD_INT 6
67890: LESS
67891: IFFALSE 67907
// SetFuel ( j , 100 ) else
67893: LD_VAR 0 3
67897: PPUSH
67898: LD_INT 100
67900: PPUSH
67901: CALL_OW 240
67905: GO 68132
// if GetFuel ( j ) = 0 then
67907: LD_VAR 0 3
67911: PPUSH
67912: CALL_OW 261
67916: PUSH
67917: LD_INT 0
67919: EQUAL
67920: IFFALSE 68132
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
67922: LD_ADDR_EXP 42
67926: PUSH
67927: LD_EXP 42
67931: PPUSH
67932: LD_VAR 0 2
67936: PPUSH
67937: LD_EXP 42
67941: PUSH
67942: LD_VAR 0 2
67946: ARRAY
67947: PUSH
67948: LD_VAR 0 3
67952: DIFF
67953: PPUSH
67954: CALL_OW 1
67958: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
67959: LD_VAR 0 3
67963: PPUSH
67964: CALL_OW 263
67968: PUSH
67969: LD_INT 1
67971: EQUAL
67972: IFFALSE 67988
// ComExitVehicle ( IsInUnit ( j ) ) ;
67974: LD_VAR 0 3
67978: PPUSH
67979: CALL_OW 310
67983: PPUSH
67984: CALL_OW 121
// if GetControl ( j ) = control_remote then
67988: LD_VAR 0 3
67992: PPUSH
67993: CALL_OW 263
67997: PUSH
67998: LD_INT 2
68000: EQUAL
68001: IFFALSE 68012
// ComUnlink ( j ) ;
68003: LD_VAR 0 3
68007: PPUSH
68008: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
68012: LD_ADDR_VAR 0 10
68016: PUSH
68017: LD_VAR 0 2
68021: PPUSH
68022: LD_INT 3
68024: PPUSH
68025: CALL 77776 0 2
68029: ST_TO_ADDR
// if fac then
68030: LD_VAR 0 10
68034: IFFALSE 68130
// begin for k in fac do
68036: LD_ADDR_VAR 0 4
68040: PUSH
68041: LD_VAR 0 10
68045: PUSH
68046: FOR_IN
68047: IFFALSE 68128
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
68049: LD_ADDR_VAR 0 11
68053: PUSH
68054: LD_VAR 0 10
68058: PPUSH
68059: LD_VAR 0 3
68063: PPUSH
68064: CALL_OW 265
68068: PPUSH
68069: LD_VAR 0 3
68073: PPUSH
68074: CALL_OW 262
68078: PPUSH
68079: LD_VAR 0 3
68083: PPUSH
68084: CALL_OW 263
68088: PPUSH
68089: LD_VAR 0 3
68093: PPUSH
68094: CALL_OW 264
68098: PPUSH
68099: CALL 13575 0 5
68103: ST_TO_ADDR
// if components then
68104: LD_VAR 0 11
68108: IFFALSE 68126
// begin MC_InsertProduceList ( i , components ) ;
68110: LD_VAR 0 2
68114: PPUSH
68115: LD_VAR 0 11
68119: PPUSH
68120: CALL 77321 0 2
// break ;
68124: GO 68128
// end ; end ;
68126: GO 68046
68128: POP
68129: POP
// end ; continue ;
68130: GO 67675
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
68132: LD_VAR 0 3
68136: PPUSH
68137: LD_INT 1
68139: PPUSH
68140: CALL_OW 289
68144: PUSH
68145: LD_INT 100
68147: LESS
68148: PUSH
68149: LD_VAR 0 3
68153: PPUSH
68154: CALL_OW 314
68158: NOT
68159: AND
68160: IFFALSE 68189
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
68162: LD_VAR 0 3
68166: PPUSH
68167: LD_VAR 0 7
68171: PUSH
68172: LD_INT 2
68174: ARRAY
68175: PPUSH
68176: LD_VAR 0 7
68180: PUSH
68181: LD_INT 3
68183: ARRAY
68184: PPUSH
68185: CALL_OW 117
// break ;
68189: GO 68193
// end ;
68191: GO 67675
68193: POP
68194: POP
// end ; end ;
68195: GO 66391
68197: POP
68198: POP
// end ;
68199: LD_VAR 0 1
68203: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
68204: LD_INT 0
68206: PPUSH
68207: PPUSH
68208: PPUSH
68209: PPUSH
// if not mc_bases then
68210: LD_EXP 23
68214: NOT
68215: IFFALSE 68219
// exit ;
68217: GO 68380
// for i = 1 to mc_bases do
68219: LD_ADDR_VAR 0 2
68223: PUSH
68224: DOUBLE
68225: LD_INT 1
68227: DEC
68228: ST_TO_ADDR
68229: LD_EXP 23
68233: PUSH
68234: FOR_TO
68235: IFFALSE 68378
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
68237: LD_ADDR_VAR 0 4
68241: PUSH
68242: LD_EXP 42
68246: PUSH
68247: LD_VAR 0 2
68251: ARRAY
68252: PUSH
68253: LD_EXP 45
68257: PUSH
68258: LD_VAR 0 2
68262: ARRAY
68263: UNION
68264: PPUSH
68265: LD_INT 33
68267: PUSH
68268: LD_INT 2
68270: PUSH
68271: EMPTY
68272: LIST
68273: LIST
68274: PPUSH
68275: CALL_OW 72
68279: ST_TO_ADDR
// if tmp then
68280: LD_VAR 0 4
68284: IFFALSE 68376
// for j in tmp do
68286: LD_ADDR_VAR 0 3
68290: PUSH
68291: LD_VAR 0 4
68295: PUSH
68296: FOR_IN
68297: IFFALSE 68374
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
68299: LD_VAR 0 3
68303: PPUSH
68304: CALL_OW 312
68308: NOT
68309: PUSH
68310: LD_VAR 0 3
68314: PPUSH
68315: CALL_OW 256
68319: PUSH
68320: LD_INT 250
68322: GREATEREQUAL
68323: AND
68324: IFFALSE 68337
// Connect ( j ) else
68326: LD_VAR 0 3
68330: PPUSH
68331: CALL 19423 0 1
68335: GO 68372
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
68337: LD_VAR 0 3
68341: PPUSH
68342: CALL_OW 256
68346: PUSH
68347: LD_INT 250
68349: LESS
68350: PUSH
68351: LD_VAR 0 3
68355: PPUSH
68356: CALL_OW 312
68360: AND
68361: IFFALSE 68372
// ComUnlink ( j ) ;
68363: LD_VAR 0 3
68367: PPUSH
68368: CALL_OW 136
68372: GO 68296
68374: POP
68375: POP
// end ;
68376: GO 68234
68378: POP
68379: POP
// end ;
68380: LD_VAR 0 1
68384: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
68385: LD_INT 0
68387: PPUSH
68388: PPUSH
68389: PPUSH
68390: PPUSH
68391: PPUSH
// if not mc_bases then
68392: LD_EXP 23
68396: NOT
68397: IFFALSE 68401
// exit ;
68399: GO 68846
// for i = 1 to mc_bases do
68401: LD_ADDR_VAR 0 2
68405: PUSH
68406: DOUBLE
68407: LD_INT 1
68409: DEC
68410: ST_TO_ADDR
68411: LD_EXP 23
68415: PUSH
68416: FOR_TO
68417: IFFALSE 68844
// begin if not mc_produce [ i ] then
68419: LD_EXP 44
68423: PUSH
68424: LD_VAR 0 2
68428: ARRAY
68429: NOT
68430: IFFALSE 68434
// continue ;
68432: GO 68416
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
68434: LD_ADDR_VAR 0 5
68438: PUSH
68439: LD_EXP 23
68443: PUSH
68444: LD_VAR 0 2
68448: ARRAY
68449: PPUSH
68450: LD_INT 30
68452: PUSH
68453: LD_INT 3
68455: PUSH
68456: EMPTY
68457: LIST
68458: LIST
68459: PPUSH
68460: CALL_OW 72
68464: ST_TO_ADDR
// if not fac then
68465: LD_VAR 0 5
68469: NOT
68470: IFFALSE 68474
// continue ;
68472: GO 68416
// for j in fac do
68474: LD_ADDR_VAR 0 3
68478: PUSH
68479: LD_VAR 0 5
68483: PUSH
68484: FOR_IN
68485: IFFALSE 68840
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
68487: LD_VAR 0 3
68491: PPUSH
68492: CALL_OW 461
68496: PUSH
68497: LD_INT 2
68499: NONEQUAL
68500: PUSH
68501: LD_VAR 0 3
68505: PPUSH
68506: LD_INT 15
68508: PPUSH
68509: CALL 19042 0 2
68513: PUSH
68514: LD_INT 4
68516: ARRAY
68517: OR
68518: IFFALSE 68522
// continue ;
68520: GO 68484
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
68522: LD_VAR 0 3
68526: PPUSH
68527: LD_EXP 44
68531: PUSH
68532: LD_VAR 0 2
68536: ARRAY
68537: PUSH
68538: LD_INT 1
68540: ARRAY
68541: PUSH
68542: LD_INT 1
68544: ARRAY
68545: PPUSH
68546: LD_EXP 44
68550: PUSH
68551: LD_VAR 0 2
68555: ARRAY
68556: PUSH
68557: LD_INT 1
68559: ARRAY
68560: PUSH
68561: LD_INT 2
68563: ARRAY
68564: PPUSH
68565: LD_EXP 44
68569: PUSH
68570: LD_VAR 0 2
68574: ARRAY
68575: PUSH
68576: LD_INT 1
68578: ARRAY
68579: PUSH
68580: LD_INT 3
68582: ARRAY
68583: PPUSH
68584: LD_EXP 44
68588: PUSH
68589: LD_VAR 0 2
68593: ARRAY
68594: PUSH
68595: LD_INT 1
68597: ARRAY
68598: PUSH
68599: LD_INT 4
68601: ARRAY
68602: PPUSH
68603: CALL_OW 448
68607: PUSH
68608: LD_VAR 0 3
68612: PPUSH
68613: LD_EXP 44
68617: PUSH
68618: LD_VAR 0 2
68622: ARRAY
68623: PUSH
68624: LD_INT 1
68626: ARRAY
68627: PUSH
68628: LD_INT 1
68630: ARRAY
68631: PUSH
68632: LD_EXP 44
68636: PUSH
68637: LD_VAR 0 2
68641: ARRAY
68642: PUSH
68643: LD_INT 1
68645: ARRAY
68646: PUSH
68647: LD_INT 2
68649: ARRAY
68650: PUSH
68651: LD_EXP 44
68655: PUSH
68656: LD_VAR 0 2
68660: ARRAY
68661: PUSH
68662: LD_INT 1
68664: ARRAY
68665: PUSH
68666: LD_INT 3
68668: ARRAY
68669: PUSH
68670: LD_EXP 44
68674: PUSH
68675: LD_VAR 0 2
68679: ARRAY
68680: PUSH
68681: LD_INT 1
68683: ARRAY
68684: PUSH
68685: LD_INT 4
68687: ARRAY
68688: PUSH
68689: EMPTY
68690: LIST
68691: LIST
68692: LIST
68693: LIST
68694: PPUSH
68695: CALL 22818 0 2
68699: AND
68700: IFFALSE 68838
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
68702: LD_VAR 0 3
68706: PPUSH
68707: LD_EXP 44
68711: PUSH
68712: LD_VAR 0 2
68716: ARRAY
68717: PUSH
68718: LD_INT 1
68720: ARRAY
68721: PUSH
68722: LD_INT 1
68724: ARRAY
68725: PPUSH
68726: LD_EXP 44
68730: PUSH
68731: LD_VAR 0 2
68735: ARRAY
68736: PUSH
68737: LD_INT 1
68739: ARRAY
68740: PUSH
68741: LD_INT 2
68743: ARRAY
68744: PPUSH
68745: LD_EXP 44
68749: PUSH
68750: LD_VAR 0 2
68754: ARRAY
68755: PUSH
68756: LD_INT 1
68758: ARRAY
68759: PUSH
68760: LD_INT 3
68762: ARRAY
68763: PPUSH
68764: LD_EXP 44
68768: PUSH
68769: LD_VAR 0 2
68773: ARRAY
68774: PUSH
68775: LD_INT 1
68777: ARRAY
68778: PUSH
68779: LD_INT 4
68781: ARRAY
68782: PPUSH
68783: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
68787: LD_ADDR_VAR 0 4
68791: PUSH
68792: LD_EXP 44
68796: PUSH
68797: LD_VAR 0 2
68801: ARRAY
68802: PPUSH
68803: LD_INT 1
68805: PPUSH
68806: CALL_OW 3
68810: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
68811: LD_ADDR_EXP 44
68815: PUSH
68816: LD_EXP 44
68820: PPUSH
68821: LD_VAR 0 2
68825: PPUSH
68826: LD_VAR 0 4
68830: PPUSH
68831: CALL_OW 1
68835: ST_TO_ADDR
// break ;
68836: GO 68840
// end ; end ;
68838: GO 68484
68840: POP
68841: POP
// end ;
68842: GO 68416
68844: POP
68845: POP
// end ;
68846: LD_VAR 0 1
68850: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
68851: LD_INT 0
68853: PPUSH
68854: PPUSH
68855: PPUSH
// if not mc_bases then
68856: LD_EXP 23
68860: NOT
68861: IFFALSE 68865
// exit ;
68863: GO 68954
// for i = 1 to mc_bases do
68865: LD_ADDR_VAR 0 2
68869: PUSH
68870: DOUBLE
68871: LD_INT 1
68873: DEC
68874: ST_TO_ADDR
68875: LD_EXP 23
68879: PUSH
68880: FOR_TO
68881: IFFALSE 68952
// begin if mc_attack [ i ] then
68883: LD_EXP 43
68887: PUSH
68888: LD_VAR 0 2
68892: ARRAY
68893: IFFALSE 68950
// begin tmp := mc_attack [ i ] [ 1 ] ;
68895: LD_ADDR_VAR 0 3
68899: PUSH
68900: LD_EXP 43
68904: PUSH
68905: LD_VAR 0 2
68909: ARRAY
68910: PUSH
68911: LD_INT 1
68913: ARRAY
68914: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
68915: LD_ADDR_EXP 43
68919: PUSH
68920: LD_EXP 43
68924: PPUSH
68925: LD_VAR 0 2
68929: PPUSH
68930: EMPTY
68931: PPUSH
68932: CALL_OW 1
68936: ST_TO_ADDR
// Attack ( tmp ) ;
68937: LD_VAR 0 3
68941: PPUSH
68942: CALL 83747 0 1
// exit ;
68946: POP
68947: POP
68948: GO 68954
// end ; end ;
68950: GO 68880
68952: POP
68953: POP
// end ;
68954: LD_VAR 0 1
68958: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
68959: LD_INT 0
68961: PPUSH
68962: PPUSH
68963: PPUSH
68964: PPUSH
68965: PPUSH
68966: PPUSH
68967: PPUSH
// if not mc_bases then
68968: LD_EXP 23
68972: NOT
68973: IFFALSE 68977
// exit ;
68975: GO 69834
// for i = 1 to mc_bases do
68977: LD_ADDR_VAR 0 2
68981: PUSH
68982: DOUBLE
68983: LD_INT 1
68985: DEC
68986: ST_TO_ADDR
68987: LD_EXP 23
68991: PUSH
68992: FOR_TO
68993: IFFALSE 69832
// begin if not mc_bases [ i ] then
68995: LD_EXP 23
68999: PUSH
69000: LD_VAR 0 2
69004: ARRAY
69005: NOT
69006: IFFALSE 69010
// continue ;
69008: GO 68992
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
69010: LD_ADDR_VAR 0 7
69014: PUSH
69015: LD_EXP 23
69019: PUSH
69020: LD_VAR 0 2
69024: ARRAY
69025: PUSH
69026: LD_INT 1
69028: ARRAY
69029: PPUSH
69030: CALL 12901 0 1
69034: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
69035: LD_ADDR_EXP 46
69039: PUSH
69040: LD_EXP 46
69044: PPUSH
69045: LD_VAR 0 2
69049: PPUSH
69050: LD_EXP 23
69054: PUSH
69055: LD_VAR 0 2
69059: ARRAY
69060: PUSH
69061: LD_INT 1
69063: ARRAY
69064: PPUSH
69065: CALL_OW 255
69069: PPUSH
69070: LD_EXP 48
69074: PUSH
69075: LD_VAR 0 2
69079: ARRAY
69080: PPUSH
69081: CALL 12866 0 2
69085: PPUSH
69086: CALL_OW 1
69090: ST_TO_ADDR
// if not mc_scan [ i ] then
69091: LD_EXP 46
69095: PUSH
69096: LD_VAR 0 2
69100: ARRAY
69101: NOT
69102: IFFALSE 69280
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
69104: LD_ADDR_EXP 66
69108: PUSH
69109: LD_EXP 66
69113: PPUSH
69114: LD_VAR 0 2
69118: PPUSH
69119: LD_INT 0
69121: PPUSH
69122: CALL_OW 1
69126: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
69127: LD_ADDR_VAR 0 4
69131: PUSH
69132: LD_EXP 23
69136: PUSH
69137: LD_VAR 0 2
69141: ARRAY
69142: PPUSH
69143: LD_INT 2
69145: PUSH
69146: LD_INT 25
69148: PUSH
69149: LD_INT 5
69151: PUSH
69152: EMPTY
69153: LIST
69154: LIST
69155: PUSH
69156: LD_INT 25
69158: PUSH
69159: LD_INT 8
69161: PUSH
69162: EMPTY
69163: LIST
69164: LIST
69165: PUSH
69166: LD_INT 25
69168: PUSH
69169: LD_INT 9
69171: PUSH
69172: EMPTY
69173: LIST
69174: LIST
69175: PUSH
69176: EMPTY
69177: LIST
69178: LIST
69179: LIST
69180: LIST
69181: PPUSH
69182: CALL_OW 72
69186: ST_TO_ADDR
// if not tmp then
69187: LD_VAR 0 4
69191: NOT
69192: IFFALSE 69196
// continue ;
69194: GO 68992
// for j in tmp do
69196: LD_ADDR_VAR 0 3
69200: PUSH
69201: LD_VAR 0 4
69205: PUSH
69206: FOR_IN
69207: IFFALSE 69278
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
69209: LD_VAR 0 3
69213: PPUSH
69214: CALL_OW 310
69218: PPUSH
69219: CALL_OW 266
69223: PUSH
69224: LD_INT 5
69226: EQUAL
69227: PUSH
69228: LD_VAR 0 3
69232: PPUSH
69233: CALL_OW 257
69237: PUSH
69238: LD_INT 1
69240: EQUAL
69241: AND
69242: PUSH
69243: LD_VAR 0 3
69247: PPUSH
69248: CALL_OW 459
69252: NOT
69253: AND
69254: PUSH
69255: LD_VAR 0 7
69259: AND
69260: IFFALSE 69276
// ComChangeProfession ( j , class ) ;
69262: LD_VAR 0 3
69266: PPUSH
69267: LD_VAR 0 7
69271: PPUSH
69272: CALL_OW 123
69276: GO 69206
69278: POP
69279: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
69280: LD_EXP 46
69284: PUSH
69285: LD_VAR 0 2
69289: ARRAY
69290: PUSH
69291: LD_EXP 66
69295: PUSH
69296: LD_VAR 0 2
69300: ARRAY
69301: NOT
69302: AND
69303: PUSH
69304: LD_EXP 45
69308: PUSH
69309: LD_VAR 0 2
69313: ARRAY
69314: NOT
69315: AND
69316: PUSH
69317: LD_EXP 23
69321: PUSH
69322: LD_VAR 0 2
69326: ARRAY
69327: PPUSH
69328: LD_INT 50
69330: PUSH
69331: EMPTY
69332: LIST
69333: PUSH
69334: LD_INT 2
69336: PUSH
69337: LD_INT 30
69339: PUSH
69340: LD_INT 32
69342: PUSH
69343: EMPTY
69344: LIST
69345: LIST
69346: PUSH
69347: LD_INT 30
69349: PUSH
69350: LD_INT 33
69352: PUSH
69353: EMPTY
69354: LIST
69355: LIST
69356: PUSH
69357: LD_INT 30
69359: PUSH
69360: LD_INT 4
69362: PUSH
69363: EMPTY
69364: LIST
69365: LIST
69366: PUSH
69367: LD_INT 30
69369: PUSH
69370: LD_INT 5
69372: PUSH
69373: EMPTY
69374: LIST
69375: LIST
69376: PUSH
69377: EMPTY
69378: LIST
69379: LIST
69380: LIST
69381: LIST
69382: LIST
69383: PUSH
69384: EMPTY
69385: LIST
69386: LIST
69387: PPUSH
69388: CALL_OW 72
69392: PUSH
69393: LD_INT 4
69395: LESS
69396: PUSH
69397: LD_EXP 23
69401: PUSH
69402: LD_VAR 0 2
69406: ARRAY
69407: PPUSH
69408: LD_INT 3
69410: PUSH
69411: LD_INT 24
69413: PUSH
69414: LD_INT 1000
69416: PUSH
69417: EMPTY
69418: LIST
69419: LIST
69420: PUSH
69421: EMPTY
69422: LIST
69423: LIST
69424: PUSH
69425: LD_INT 2
69427: PUSH
69428: LD_INT 30
69430: PUSH
69431: LD_INT 0
69433: PUSH
69434: EMPTY
69435: LIST
69436: LIST
69437: PUSH
69438: LD_INT 30
69440: PUSH
69441: LD_INT 1
69443: PUSH
69444: EMPTY
69445: LIST
69446: LIST
69447: PUSH
69448: EMPTY
69449: LIST
69450: LIST
69451: LIST
69452: PUSH
69453: EMPTY
69454: LIST
69455: LIST
69456: PPUSH
69457: CALL_OW 72
69461: OR
69462: AND
69463: IFFALSE 69714
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
69465: LD_ADDR_EXP 66
69469: PUSH
69470: LD_EXP 66
69474: PPUSH
69475: LD_VAR 0 2
69479: PPUSH
69480: LD_INT 1
69482: PPUSH
69483: CALL_OW 1
69487: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
69488: LD_ADDR_VAR 0 4
69492: PUSH
69493: LD_EXP 23
69497: PUSH
69498: LD_VAR 0 2
69502: ARRAY
69503: PPUSH
69504: LD_INT 2
69506: PUSH
69507: LD_INT 25
69509: PUSH
69510: LD_INT 1
69512: PUSH
69513: EMPTY
69514: LIST
69515: LIST
69516: PUSH
69517: LD_INT 25
69519: PUSH
69520: LD_INT 5
69522: PUSH
69523: EMPTY
69524: LIST
69525: LIST
69526: PUSH
69527: LD_INT 25
69529: PUSH
69530: LD_INT 8
69532: PUSH
69533: EMPTY
69534: LIST
69535: LIST
69536: PUSH
69537: LD_INT 25
69539: PUSH
69540: LD_INT 9
69542: PUSH
69543: EMPTY
69544: LIST
69545: LIST
69546: PUSH
69547: EMPTY
69548: LIST
69549: LIST
69550: LIST
69551: LIST
69552: LIST
69553: PPUSH
69554: CALL_OW 72
69558: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
69559: LD_ADDR_VAR 0 4
69563: PUSH
69564: LD_VAR 0 4
69568: PUSH
69569: LD_VAR 0 4
69573: PPUSH
69574: LD_INT 18
69576: PPUSH
69577: CALL 46386 0 2
69581: DIFF
69582: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
69583: LD_VAR 0 4
69587: NOT
69588: PUSH
69589: LD_EXP 23
69593: PUSH
69594: LD_VAR 0 2
69598: ARRAY
69599: PPUSH
69600: LD_INT 2
69602: PUSH
69603: LD_INT 30
69605: PUSH
69606: LD_INT 4
69608: PUSH
69609: EMPTY
69610: LIST
69611: LIST
69612: PUSH
69613: LD_INT 30
69615: PUSH
69616: LD_INT 5
69618: PUSH
69619: EMPTY
69620: LIST
69621: LIST
69622: PUSH
69623: EMPTY
69624: LIST
69625: LIST
69626: LIST
69627: PPUSH
69628: CALL_OW 72
69632: NOT
69633: AND
69634: IFFALSE 69696
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
69636: LD_ADDR_VAR 0 4
69640: PUSH
69641: LD_EXP 23
69645: PUSH
69646: LD_VAR 0 2
69650: ARRAY
69651: PPUSH
69652: LD_INT 2
69654: PUSH
69655: LD_INT 25
69657: PUSH
69658: LD_INT 2
69660: PUSH
69661: EMPTY
69662: LIST
69663: LIST
69664: PUSH
69665: LD_INT 25
69667: PUSH
69668: LD_INT 3
69670: PUSH
69671: EMPTY
69672: LIST
69673: LIST
69674: PUSH
69675: LD_INT 25
69677: PUSH
69678: LD_INT 4
69680: PUSH
69681: EMPTY
69682: LIST
69683: LIST
69684: PUSH
69685: EMPTY
69686: LIST
69687: LIST
69688: LIST
69689: LIST
69690: PPUSH
69691: CALL_OW 72
69695: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
69696: LD_VAR 0 2
69700: PPUSH
69701: LD_VAR 0 4
69705: PPUSH
69706: CALL 88456 0 2
// exit ;
69710: POP
69711: POP
69712: GO 69834
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
69714: LD_EXP 46
69718: PUSH
69719: LD_VAR 0 2
69723: ARRAY
69724: PUSH
69725: LD_EXP 66
69729: PUSH
69730: LD_VAR 0 2
69734: ARRAY
69735: NOT
69736: AND
69737: PUSH
69738: LD_EXP 45
69742: PUSH
69743: LD_VAR 0 2
69747: ARRAY
69748: AND
69749: IFFALSE 69830
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
69751: LD_ADDR_EXP 66
69755: PUSH
69756: LD_EXP 66
69760: PPUSH
69761: LD_VAR 0 2
69765: PPUSH
69766: LD_INT 1
69768: PPUSH
69769: CALL_OW 1
69773: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
69774: LD_ADDR_VAR 0 4
69778: PUSH
69779: LD_EXP 45
69783: PUSH
69784: LD_VAR 0 2
69788: ARRAY
69789: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
69790: LD_ADDR_EXP 45
69794: PUSH
69795: LD_EXP 45
69799: PPUSH
69800: LD_VAR 0 2
69804: PPUSH
69805: EMPTY
69806: PPUSH
69807: CALL_OW 1
69811: ST_TO_ADDR
// Defend ( i , tmp ) ;
69812: LD_VAR 0 2
69816: PPUSH
69817: LD_VAR 0 4
69821: PPUSH
69822: CALL 89052 0 2
// exit ;
69826: POP
69827: POP
69828: GO 69834
// end ; end ;
69830: GO 68992
69832: POP
69833: POP
// end ;
69834: LD_VAR 0 1
69838: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
69839: LD_INT 0
69841: PPUSH
69842: PPUSH
69843: PPUSH
69844: PPUSH
69845: PPUSH
69846: PPUSH
69847: PPUSH
69848: PPUSH
69849: PPUSH
69850: PPUSH
69851: PPUSH
// if not mc_bases then
69852: LD_EXP 23
69856: NOT
69857: IFFALSE 69861
// exit ;
69859: GO 70948
// for i = 1 to mc_bases do
69861: LD_ADDR_VAR 0 2
69865: PUSH
69866: DOUBLE
69867: LD_INT 1
69869: DEC
69870: ST_TO_ADDR
69871: LD_EXP 23
69875: PUSH
69876: FOR_TO
69877: IFFALSE 70946
// begin tmp := mc_lab [ i ] ;
69879: LD_ADDR_VAR 0 6
69883: PUSH
69884: LD_EXP 56
69888: PUSH
69889: LD_VAR 0 2
69893: ARRAY
69894: ST_TO_ADDR
// if not tmp then
69895: LD_VAR 0 6
69899: NOT
69900: IFFALSE 69904
// continue ;
69902: GO 69876
// idle_lab := 0 ;
69904: LD_ADDR_VAR 0 11
69908: PUSH
69909: LD_INT 0
69911: ST_TO_ADDR
// for j in tmp do
69912: LD_ADDR_VAR 0 3
69916: PUSH
69917: LD_VAR 0 6
69921: PUSH
69922: FOR_IN
69923: IFFALSE 70942
// begin researching := false ;
69925: LD_ADDR_VAR 0 10
69929: PUSH
69930: LD_INT 0
69932: ST_TO_ADDR
// side := GetSide ( j ) ;
69933: LD_ADDR_VAR 0 4
69937: PUSH
69938: LD_VAR 0 3
69942: PPUSH
69943: CALL_OW 255
69947: ST_TO_ADDR
// if not mc_tech [ side ] then
69948: LD_EXP 50
69952: PUSH
69953: LD_VAR 0 4
69957: ARRAY
69958: NOT
69959: IFFALSE 69963
// continue ;
69961: GO 69922
// if BuildingStatus ( j ) = bs_idle then
69963: LD_VAR 0 3
69967: PPUSH
69968: CALL_OW 461
69972: PUSH
69973: LD_INT 2
69975: EQUAL
69976: IFFALSE 70164
// begin if idle_lab and UnitsInside ( j ) < 6 then
69978: LD_VAR 0 11
69982: PUSH
69983: LD_VAR 0 3
69987: PPUSH
69988: CALL_OW 313
69992: PUSH
69993: LD_INT 6
69995: LESS
69996: AND
69997: IFFALSE 70068
// begin tmp2 := UnitsInside ( idle_lab ) ;
69999: LD_ADDR_VAR 0 9
70003: PUSH
70004: LD_VAR 0 11
70008: PPUSH
70009: CALL_OW 313
70013: ST_TO_ADDR
// if tmp2 then
70014: LD_VAR 0 9
70018: IFFALSE 70060
// for x in tmp2 do
70020: LD_ADDR_VAR 0 7
70024: PUSH
70025: LD_VAR 0 9
70029: PUSH
70030: FOR_IN
70031: IFFALSE 70058
// begin ComExitBuilding ( x ) ;
70033: LD_VAR 0 7
70037: PPUSH
70038: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
70042: LD_VAR 0 7
70046: PPUSH
70047: LD_VAR 0 3
70051: PPUSH
70052: CALL_OW 180
// end ;
70056: GO 70030
70058: POP
70059: POP
// idle_lab := 0 ;
70060: LD_ADDR_VAR 0 11
70064: PUSH
70065: LD_INT 0
70067: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
70068: LD_ADDR_VAR 0 5
70072: PUSH
70073: LD_EXP 50
70077: PUSH
70078: LD_VAR 0 4
70082: ARRAY
70083: PUSH
70084: FOR_IN
70085: IFFALSE 70145
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
70087: LD_VAR 0 3
70091: PPUSH
70092: LD_VAR 0 5
70096: PPUSH
70097: CALL_OW 430
70101: PUSH
70102: LD_VAR 0 4
70106: PPUSH
70107: LD_VAR 0 5
70111: PPUSH
70112: CALL 11971 0 2
70116: AND
70117: IFFALSE 70143
// begin researching := true ;
70119: LD_ADDR_VAR 0 10
70123: PUSH
70124: LD_INT 1
70126: ST_TO_ADDR
// ComResearch ( j , t ) ;
70127: LD_VAR 0 3
70131: PPUSH
70132: LD_VAR 0 5
70136: PPUSH
70137: CALL_OW 124
// break ;
70141: GO 70145
// end ;
70143: GO 70084
70145: POP
70146: POP
// if not researching then
70147: LD_VAR 0 10
70151: NOT
70152: IFFALSE 70164
// idle_lab := j ;
70154: LD_ADDR_VAR 0 11
70158: PUSH
70159: LD_VAR 0 3
70163: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
70164: LD_VAR 0 3
70168: PPUSH
70169: CALL_OW 461
70173: PUSH
70174: LD_INT 10
70176: EQUAL
70177: IFFALSE 70765
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
70179: LD_EXP 52
70183: PUSH
70184: LD_VAR 0 2
70188: ARRAY
70189: NOT
70190: PUSH
70191: LD_EXP 53
70195: PUSH
70196: LD_VAR 0 2
70200: ARRAY
70201: NOT
70202: AND
70203: PUSH
70204: LD_EXP 50
70208: PUSH
70209: LD_VAR 0 4
70213: ARRAY
70214: PUSH
70215: LD_INT 1
70217: GREATER
70218: AND
70219: IFFALSE 70350
// begin ComCancel ( j ) ;
70221: LD_VAR 0 3
70225: PPUSH
70226: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
70230: LD_ADDR_EXP 50
70234: PUSH
70235: LD_EXP 50
70239: PPUSH
70240: LD_VAR 0 4
70244: PPUSH
70245: LD_EXP 50
70249: PUSH
70250: LD_VAR 0 4
70254: ARRAY
70255: PPUSH
70256: LD_EXP 50
70260: PUSH
70261: LD_VAR 0 4
70265: ARRAY
70266: PUSH
70267: LD_INT 1
70269: MINUS
70270: PPUSH
70271: LD_EXP 50
70275: PUSH
70276: LD_VAR 0 4
70280: ARRAY
70281: PPUSH
70282: LD_INT 0
70284: PPUSH
70285: CALL 15495 0 4
70289: PPUSH
70290: CALL_OW 1
70294: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
70295: LD_ADDR_EXP 50
70299: PUSH
70300: LD_EXP 50
70304: PPUSH
70305: LD_VAR 0 4
70309: PPUSH
70310: LD_EXP 50
70314: PUSH
70315: LD_VAR 0 4
70319: ARRAY
70320: PPUSH
70321: LD_EXP 50
70325: PUSH
70326: LD_VAR 0 4
70330: ARRAY
70331: PPUSH
70332: LD_INT 1
70334: PPUSH
70335: LD_INT 0
70337: PPUSH
70338: CALL 15495 0 4
70342: PPUSH
70343: CALL_OW 1
70347: ST_TO_ADDR
// continue ;
70348: GO 69922
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
70350: LD_EXP 52
70354: PUSH
70355: LD_VAR 0 2
70359: ARRAY
70360: PUSH
70361: LD_EXP 53
70365: PUSH
70366: LD_VAR 0 2
70370: ARRAY
70371: NOT
70372: AND
70373: IFFALSE 70500
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
70375: LD_ADDR_EXP 53
70379: PUSH
70380: LD_EXP 53
70384: PPUSH
70385: LD_VAR 0 2
70389: PUSH
70390: LD_EXP 53
70394: PUSH
70395: LD_VAR 0 2
70399: ARRAY
70400: PUSH
70401: LD_INT 1
70403: PLUS
70404: PUSH
70405: EMPTY
70406: LIST
70407: LIST
70408: PPUSH
70409: LD_EXP 52
70413: PUSH
70414: LD_VAR 0 2
70418: ARRAY
70419: PUSH
70420: LD_INT 1
70422: ARRAY
70423: PPUSH
70424: CALL 16077 0 3
70428: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
70429: LD_EXP 52
70433: PUSH
70434: LD_VAR 0 2
70438: ARRAY
70439: PUSH
70440: LD_INT 1
70442: ARRAY
70443: PPUSH
70444: LD_INT 112
70446: PPUSH
70447: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
70451: LD_ADDR_VAR 0 9
70455: PUSH
70456: LD_EXP 52
70460: PUSH
70461: LD_VAR 0 2
70465: ARRAY
70466: PPUSH
70467: LD_INT 1
70469: PPUSH
70470: CALL_OW 3
70474: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
70475: LD_ADDR_EXP 52
70479: PUSH
70480: LD_EXP 52
70484: PPUSH
70485: LD_VAR 0 2
70489: PPUSH
70490: LD_VAR 0 9
70494: PPUSH
70495: CALL_OW 1
70499: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
70500: LD_EXP 52
70504: PUSH
70505: LD_VAR 0 2
70509: ARRAY
70510: PUSH
70511: LD_EXP 53
70515: PUSH
70516: LD_VAR 0 2
70520: ARRAY
70521: AND
70522: PUSH
70523: LD_EXP 53
70527: PUSH
70528: LD_VAR 0 2
70532: ARRAY
70533: PUSH
70534: LD_INT 1
70536: ARRAY
70537: PPUSH
70538: CALL_OW 310
70542: NOT
70543: AND
70544: PUSH
70545: LD_VAR 0 3
70549: PPUSH
70550: CALL_OW 313
70554: PUSH
70555: LD_INT 6
70557: EQUAL
70558: AND
70559: IFFALSE 70615
// begin tmp2 := UnitsInside ( j ) ;
70561: LD_ADDR_VAR 0 9
70565: PUSH
70566: LD_VAR 0 3
70570: PPUSH
70571: CALL_OW 313
70575: ST_TO_ADDR
// if tmp2 = 6 then
70576: LD_VAR 0 9
70580: PUSH
70581: LD_INT 6
70583: EQUAL
70584: IFFALSE 70615
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
70586: LD_VAR 0 9
70590: PUSH
70591: LD_INT 1
70593: ARRAY
70594: PPUSH
70595: LD_INT 112
70597: PPUSH
70598: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
70602: LD_VAR 0 9
70606: PUSH
70607: LD_INT 1
70609: ARRAY
70610: PPUSH
70611: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
70615: LD_EXP 53
70619: PUSH
70620: LD_VAR 0 2
70624: ARRAY
70625: PUSH
70626: LD_EXP 53
70630: PUSH
70631: LD_VAR 0 2
70635: ARRAY
70636: PUSH
70637: LD_INT 1
70639: ARRAY
70640: PPUSH
70641: CALL_OW 314
70645: NOT
70646: AND
70647: PUSH
70648: LD_EXP 53
70652: PUSH
70653: LD_VAR 0 2
70657: ARRAY
70658: PUSH
70659: LD_INT 1
70661: ARRAY
70662: PPUSH
70663: CALL_OW 310
70667: NOT
70668: AND
70669: IFFALSE 70695
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
70671: LD_EXP 53
70675: PUSH
70676: LD_VAR 0 2
70680: ARRAY
70681: PUSH
70682: LD_INT 1
70684: ARRAY
70685: PPUSH
70686: LD_VAR 0 3
70690: PPUSH
70691: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
70695: LD_EXP 53
70699: PUSH
70700: LD_VAR 0 2
70704: ARRAY
70705: PUSH
70706: LD_INT 1
70708: ARRAY
70709: PPUSH
70710: CALL_OW 310
70714: PUSH
70715: LD_EXP 53
70719: PUSH
70720: LD_VAR 0 2
70724: ARRAY
70725: PUSH
70726: LD_INT 1
70728: ARRAY
70729: PPUSH
70730: CALL_OW 310
70734: PPUSH
70735: CALL_OW 461
70739: PUSH
70740: LD_INT 3
70742: NONEQUAL
70743: AND
70744: IFFALSE 70765
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
70746: LD_EXP 53
70750: PUSH
70751: LD_VAR 0 2
70755: ARRAY
70756: PUSH
70757: LD_INT 1
70759: ARRAY
70760: PPUSH
70761: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
70765: LD_VAR 0 3
70769: PPUSH
70770: CALL_OW 461
70774: PUSH
70775: LD_INT 6
70777: EQUAL
70778: PUSH
70779: LD_VAR 0 6
70783: PUSH
70784: LD_INT 1
70786: GREATER
70787: AND
70788: IFFALSE 70940
// begin sci := [ ] ;
70790: LD_ADDR_VAR 0 8
70794: PUSH
70795: EMPTY
70796: ST_TO_ADDR
// for x in ( tmp diff j ) do
70797: LD_ADDR_VAR 0 7
70801: PUSH
70802: LD_VAR 0 6
70806: PUSH
70807: LD_VAR 0 3
70811: DIFF
70812: PUSH
70813: FOR_IN
70814: IFFALSE 70866
// begin if sci = 6 then
70816: LD_VAR 0 8
70820: PUSH
70821: LD_INT 6
70823: EQUAL
70824: IFFALSE 70828
// break ;
70826: GO 70866
// if BuildingStatus ( x ) = bs_idle then
70828: LD_VAR 0 7
70832: PPUSH
70833: CALL_OW 461
70837: PUSH
70838: LD_INT 2
70840: EQUAL
70841: IFFALSE 70864
// sci := sci ^ UnitsInside ( x ) ;
70843: LD_ADDR_VAR 0 8
70847: PUSH
70848: LD_VAR 0 8
70852: PUSH
70853: LD_VAR 0 7
70857: PPUSH
70858: CALL_OW 313
70862: ADD
70863: ST_TO_ADDR
// end ;
70864: GO 70813
70866: POP
70867: POP
// if not sci then
70868: LD_VAR 0 8
70872: NOT
70873: IFFALSE 70877
// continue ;
70875: GO 69922
// for x in sci do
70877: LD_ADDR_VAR 0 7
70881: PUSH
70882: LD_VAR 0 8
70886: PUSH
70887: FOR_IN
70888: IFFALSE 70938
// if IsInUnit ( x ) and not HasTask ( x ) then
70890: LD_VAR 0 7
70894: PPUSH
70895: CALL_OW 310
70899: PUSH
70900: LD_VAR 0 7
70904: PPUSH
70905: CALL_OW 314
70909: NOT
70910: AND
70911: IFFALSE 70936
// begin ComExitBuilding ( x ) ;
70913: LD_VAR 0 7
70917: PPUSH
70918: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
70922: LD_VAR 0 7
70926: PPUSH
70927: LD_VAR 0 3
70931: PPUSH
70932: CALL_OW 180
// end ;
70936: GO 70887
70938: POP
70939: POP
// end ; end ;
70940: GO 69922
70942: POP
70943: POP
// end ;
70944: GO 69876
70946: POP
70947: POP
// end ;
70948: LD_VAR 0 1
70952: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
70953: LD_INT 0
70955: PPUSH
70956: PPUSH
// if not mc_bases then
70957: LD_EXP 23
70961: NOT
70962: IFFALSE 70966
// exit ;
70964: GO 71047
// for i = 1 to mc_bases do
70966: LD_ADDR_VAR 0 2
70970: PUSH
70971: DOUBLE
70972: LD_INT 1
70974: DEC
70975: ST_TO_ADDR
70976: LD_EXP 23
70980: PUSH
70981: FOR_TO
70982: IFFALSE 71045
// if mc_mines [ i ] and mc_miners [ i ] then
70984: LD_EXP 36
70988: PUSH
70989: LD_VAR 0 2
70993: ARRAY
70994: PUSH
70995: LD_EXP 37
70999: PUSH
71000: LD_VAR 0 2
71004: ARRAY
71005: AND
71006: IFFALSE 71043
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
71008: LD_EXP 37
71012: PUSH
71013: LD_VAR 0 2
71017: ARRAY
71018: PUSH
71019: LD_INT 1
71021: ARRAY
71022: PPUSH
71023: CALL_OW 255
71027: PPUSH
71028: LD_EXP 36
71032: PUSH
71033: LD_VAR 0 2
71037: ARRAY
71038: PPUSH
71039: CALL 13054 0 2
71043: GO 70981
71045: POP
71046: POP
// end ;
71047: LD_VAR 0 1
71051: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
71052: LD_INT 0
71054: PPUSH
71055: PPUSH
71056: PPUSH
71057: PPUSH
71058: PPUSH
71059: PPUSH
71060: PPUSH
71061: PPUSH
// if not mc_bases or not mc_parking then
71062: LD_EXP 23
71066: NOT
71067: PUSH
71068: LD_EXP 47
71072: NOT
71073: OR
71074: IFFALSE 71078
// exit ;
71076: GO 71816
// for i = 1 to mc_bases do
71078: LD_ADDR_VAR 0 2
71082: PUSH
71083: DOUBLE
71084: LD_INT 1
71086: DEC
71087: ST_TO_ADDR
71088: LD_EXP 23
71092: PUSH
71093: FOR_TO
71094: IFFALSE 71814
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
71096: LD_EXP 23
71100: PUSH
71101: LD_VAR 0 2
71105: ARRAY
71106: NOT
71107: PUSH
71108: LD_EXP 47
71112: PUSH
71113: LD_VAR 0 2
71117: ARRAY
71118: NOT
71119: OR
71120: IFFALSE 71124
// continue ;
71122: GO 71093
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
71124: LD_ADDR_VAR 0 5
71128: PUSH
71129: LD_EXP 23
71133: PUSH
71134: LD_VAR 0 2
71138: ARRAY
71139: PUSH
71140: LD_INT 1
71142: ARRAY
71143: PPUSH
71144: CALL_OW 255
71148: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
71149: LD_ADDR_VAR 0 6
71153: PUSH
71154: LD_EXP 23
71158: PUSH
71159: LD_VAR 0 2
71163: ARRAY
71164: PPUSH
71165: LD_INT 30
71167: PUSH
71168: LD_INT 3
71170: PUSH
71171: EMPTY
71172: LIST
71173: LIST
71174: PPUSH
71175: CALL_OW 72
71179: ST_TO_ADDR
// if not fac then
71180: LD_VAR 0 6
71184: NOT
71185: IFFALSE 71236
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71187: LD_ADDR_VAR 0 6
71191: PUSH
71192: LD_EXP 23
71196: PUSH
71197: LD_VAR 0 2
71201: ARRAY
71202: PPUSH
71203: LD_INT 2
71205: PUSH
71206: LD_INT 30
71208: PUSH
71209: LD_INT 0
71211: PUSH
71212: EMPTY
71213: LIST
71214: LIST
71215: PUSH
71216: LD_INT 30
71218: PUSH
71219: LD_INT 1
71221: PUSH
71222: EMPTY
71223: LIST
71224: LIST
71225: PUSH
71226: EMPTY
71227: LIST
71228: LIST
71229: LIST
71230: PPUSH
71231: CALL_OW 72
71235: ST_TO_ADDR
// if not fac then
71236: LD_VAR 0 6
71240: NOT
71241: IFFALSE 71245
// continue ;
71243: GO 71093
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
71245: LD_ADDR_VAR 0 7
71249: PUSH
71250: LD_EXP 47
71254: PUSH
71255: LD_VAR 0 2
71259: ARRAY
71260: PPUSH
71261: LD_INT 22
71263: PUSH
71264: LD_VAR 0 5
71268: PUSH
71269: EMPTY
71270: LIST
71271: LIST
71272: PUSH
71273: LD_INT 21
71275: PUSH
71276: LD_INT 2
71278: PUSH
71279: EMPTY
71280: LIST
71281: LIST
71282: PUSH
71283: LD_INT 3
71285: PUSH
71286: LD_INT 60
71288: PUSH
71289: EMPTY
71290: LIST
71291: PUSH
71292: EMPTY
71293: LIST
71294: LIST
71295: PUSH
71296: LD_INT 3
71298: PUSH
71299: LD_INT 24
71301: PUSH
71302: LD_INT 1000
71304: PUSH
71305: EMPTY
71306: LIST
71307: LIST
71308: PUSH
71309: EMPTY
71310: LIST
71311: LIST
71312: PUSH
71313: EMPTY
71314: LIST
71315: LIST
71316: LIST
71317: LIST
71318: PPUSH
71319: CALL_OW 70
71323: ST_TO_ADDR
// for j in fac do
71324: LD_ADDR_VAR 0 3
71328: PUSH
71329: LD_VAR 0 6
71333: PUSH
71334: FOR_IN
71335: IFFALSE 71430
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
71337: LD_ADDR_VAR 0 7
71341: PUSH
71342: LD_VAR 0 7
71346: PUSH
71347: LD_INT 22
71349: PUSH
71350: LD_VAR 0 5
71354: PUSH
71355: EMPTY
71356: LIST
71357: LIST
71358: PUSH
71359: LD_INT 91
71361: PUSH
71362: LD_VAR 0 3
71366: PUSH
71367: LD_INT 15
71369: PUSH
71370: EMPTY
71371: LIST
71372: LIST
71373: LIST
71374: PUSH
71375: LD_INT 21
71377: PUSH
71378: LD_INT 2
71380: PUSH
71381: EMPTY
71382: LIST
71383: LIST
71384: PUSH
71385: LD_INT 3
71387: PUSH
71388: LD_INT 60
71390: PUSH
71391: EMPTY
71392: LIST
71393: PUSH
71394: EMPTY
71395: LIST
71396: LIST
71397: PUSH
71398: LD_INT 3
71400: PUSH
71401: LD_INT 24
71403: PUSH
71404: LD_INT 1000
71406: PUSH
71407: EMPTY
71408: LIST
71409: LIST
71410: PUSH
71411: EMPTY
71412: LIST
71413: LIST
71414: PUSH
71415: EMPTY
71416: LIST
71417: LIST
71418: LIST
71419: LIST
71420: LIST
71421: PPUSH
71422: CALL_OW 69
71426: UNION
71427: ST_TO_ADDR
71428: GO 71334
71430: POP
71431: POP
// if not vehs then
71432: LD_VAR 0 7
71436: NOT
71437: IFFALSE 71463
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
71439: LD_ADDR_EXP 35
71443: PUSH
71444: LD_EXP 35
71448: PPUSH
71449: LD_VAR 0 2
71453: PPUSH
71454: EMPTY
71455: PPUSH
71456: CALL_OW 1
71460: ST_TO_ADDR
// continue ;
71461: GO 71093
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
71463: LD_ADDR_VAR 0 8
71467: PUSH
71468: LD_EXP 23
71472: PUSH
71473: LD_VAR 0 2
71477: ARRAY
71478: PPUSH
71479: LD_INT 30
71481: PUSH
71482: LD_INT 3
71484: PUSH
71485: EMPTY
71486: LIST
71487: LIST
71488: PPUSH
71489: CALL_OW 72
71493: ST_TO_ADDR
// if tmp then
71494: LD_VAR 0 8
71498: IFFALSE 71601
// begin for j in tmp do
71500: LD_ADDR_VAR 0 3
71504: PUSH
71505: LD_VAR 0 8
71509: PUSH
71510: FOR_IN
71511: IFFALSE 71599
// for k in UnitsInside ( j ) do
71513: LD_ADDR_VAR 0 4
71517: PUSH
71518: LD_VAR 0 3
71522: PPUSH
71523: CALL_OW 313
71527: PUSH
71528: FOR_IN
71529: IFFALSE 71595
// if k then
71531: LD_VAR 0 4
71535: IFFALSE 71593
// if not k in mc_repair_vehicle [ i ] then
71537: LD_VAR 0 4
71541: PUSH
71542: LD_EXP 35
71546: PUSH
71547: LD_VAR 0 2
71551: ARRAY
71552: IN
71553: NOT
71554: IFFALSE 71593
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
71556: LD_ADDR_EXP 35
71560: PUSH
71561: LD_EXP 35
71565: PPUSH
71566: LD_VAR 0 2
71570: PPUSH
71571: LD_EXP 35
71575: PUSH
71576: LD_VAR 0 2
71580: ARRAY
71581: PUSH
71582: LD_VAR 0 4
71586: UNION
71587: PPUSH
71588: CALL_OW 1
71592: ST_TO_ADDR
71593: GO 71528
71595: POP
71596: POP
71597: GO 71510
71599: POP
71600: POP
// end ; if not mc_repair_vehicle [ i ] then
71601: LD_EXP 35
71605: PUSH
71606: LD_VAR 0 2
71610: ARRAY
71611: NOT
71612: IFFALSE 71616
// continue ;
71614: GO 71093
// for j in mc_repair_vehicle [ i ] do
71616: LD_ADDR_VAR 0 3
71620: PUSH
71621: LD_EXP 35
71625: PUSH
71626: LD_VAR 0 2
71630: ARRAY
71631: PUSH
71632: FOR_IN
71633: IFFALSE 71810
// begin if GetClass ( j ) <> 3 then
71635: LD_VAR 0 3
71639: PPUSH
71640: CALL_OW 257
71644: PUSH
71645: LD_INT 3
71647: NONEQUAL
71648: IFFALSE 71689
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
71650: LD_ADDR_EXP 35
71654: PUSH
71655: LD_EXP 35
71659: PPUSH
71660: LD_VAR 0 2
71664: PPUSH
71665: LD_EXP 35
71669: PUSH
71670: LD_VAR 0 2
71674: ARRAY
71675: PUSH
71676: LD_VAR 0 3
71680: DIFF
71681: PPUSH
71682: CALL_OW 1
71686: ST_TO_ADDR
// continue ;
71687: GO 71632
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
71689: LD_VAR 0 3
71693: PPUSH
71694: CALL_OW 311
71698: NOT
71699: PUSH
71700: LD_VAR 0 3
71704: PUSH
71705: LD_EXP 26
71709: PUSH
71710: LD_VAR 0 2
71714: ARRAY
71715: PUSH
71716: LD_INT 1
71718: ARRAY
71719: IN
71720: NOT
71721: AND
71722: PUSH
71723: LD_VAR 0 3
71727: PUSH
71728: LD_EXP 26
71732: PUSH
71733: LD_VAR 0 2
71737: ARRAY
71738: PUSH
71739: LD_INT 2
71741: ARRAY
71742: IN
71743: NOT
71744: AND
71745: IFFALSE 71808
// begin if IsInUnit ( j ) then
71747: LD_VAR 0 3
71751: PPUSH
71752: CALL_OW 310
71756: IFFALSE 71769
// ComExitBuilding ( j ) else
71758: LD_VAR 0 3
71762: PPUSH
71763: CALL_OW 122
71767: GO 71808
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
71769: LD_VAR 0 3
71773: PPUSH
71774: LD_VAR 0 7
71778: PUSH
71779: LD_INT 1
71781: ARRAY
71782: PPUSH
71783: CALL 50882 0 2
71787: NOT
71788: IFFALSE 71808
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
71790: LD_VAR 0 3
71794: PPUSH
71795: LD_VAR 0 7
71799: PUSH
71800: LD_INT 1
71802: ARRAY
71803: PPUSH
71804: CALL_OW 129
// end ; end ;
71808: GO 71632
71810: POP
71811: POP
// end ;
71812: GO 71093
71814: POP
71815: POP
// end ;
71816: LD_VAR 0 1
71820: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
71821: LD_INT 0
71823: PPUSH
71824: PPUSH
71825: PPUSH
71826: PPUSH
71827: PPUSH
71828: PPUSH
71829: PPUSH
71830: PPUSH
71831: PPUSH
71832: PPUSH
71833: PPUSH
// if not mc_bases then
71834: LD_EXP 23
71838: NOT
71839: IFFALSE 71843
// exit ;
71841: GO 72645
// for i = 1 to mc_bases do
71843: LD_ADDR_VAR 0 2
71847: PUSH
71848: DOUBLE
71849: LD_INT 1
71851: DEC
71852: ST_TO_ADDR
71853: LD_EXP 23
71857: PUSH
71858: FOR_TO
71859: IFFALSE 72643
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
71861: LD_EXP 51
71865: PUSH
71866: LD_VAR 0 2
71870: ARRAY
71871: NOT
71872: PUSH
71873: LD_EXP 26
71877: PUSH
71878: LD_VAR 0 2
71882: ARRAY
71883: PUSH
71884: LD_INT 1
71886: ARRAY
71887: OR
71888: PUSH
71889: LD_EXP 26
71893: PUSH
71894: LD_VAR 0 2
71898: ARRAY
71899: PUSH
71900: LD_INT 2
71902: ARRAY
71903: OR
71904: PUSH
71905: LD_EXP 49
71909: PUSH
71910: LD_VAR 0 2
71914: ARRAY
71915: PPUSH
71916: LD_INT 1
71918: PPUSH
71919: CALL_OW 325
71923: NOT
71924: OR
71925: PUSH
71926: LD_EXP 46
71930: PUSH
71931: LD_VAR 0 2
71935: ARRAY
71936: OR
71937: IFFALSE 71941
// continue ;
71939: GO 71858
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
71941: LD_ADDR_VAR 0 8
71945: PUSH
71946: LD_EXP 23
71950: PUSH
71951: LD_VAR 0 2
71955: ARRAY
71956: PPUSH
71957: LD_INT 25
71959: PUSH
71960: LD_INT 4
71962: PUSH
71963: EMPTY
71964: LIST
71965: LIST
71966: PUSH
71967: LD_INT 50
71969: PUSH
71970: EMPTY
71971: LIST
71972: PUSH
71973: LD_INT 3
71975: PUSH
71976: LD_INT 60
71978: PUSH
71979: EMPTY
71980: LIST
71981: PUSH
71982: EMPTY
71983: LIST
71984: LIST
71985: PUSH
71986: EMPTY
71987: LIST
71988: LIST
71989: LIST
71990: PPUSH
71991: CALL_OW 72
71995: PUSH
71996: LD_EXP 27
72000: PUSH
72001: LD_VAR 0 2
72005: ARRAY
72006: DIFF
72007: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72008: LD_ADDR_VAR 0 9
72012: PUSH
72013: LD_EXP 23
72017: PUSH
72018: LD_VAR 0 2
72022: ARRAY
72023: PPUSH
72024: LD_INT 2
72026: PUSH
72027: LD_INT 30
72029: PUSH
72030: LD_INT 0
72032: PUSH
72033: EMPTY
72034: LIST
72035: LIST
72036: PUSH
72037: LD_INT 30
72039: PUSH
72040: LD_INT 1
72042: PUSH
72043: EMPTY
72044: LIST
72045: LIST
72046: PUSH
72047: EMPTY
72048: LIST
72049: LIST
72050: LIST
72051: PPUSH
72052: CALL_OW 72
72056: ST_TO_ADDR
// if not tmp or not dep then
72057: LD_VAR 0 8
72061: NOT
72062: PUSH
72063: LD_VAR 0 9
72067: NOT
72068: OR
72069: IFFALSE 72073
// continue ;
72071: GO 71858
// side := GetSide ( tmp [ 1 ] ) ;
72073: LD_ADDR_VAR 0 11
72077: PUSH
72078: LD_VAR 0 8
72082: PUSH
72083: LD_INT 1
72085: ARRAY
72086: PPUSH
72087: CALL_OW 255
72091: ST_TO_ADDR
// dep := dep [ 1 ] ;
72092: LD_ADDR_VAR 0 9
72096: PUSH
72097: LD_VAR 0 9
72101: PUSH
72102: LD_INT 1
72104: ARRAY
72105: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
72106: LD_ADDR_VAR 0 7
72110: PUSH
72111: LD_EXP 51
72115: PUSH
72116: LD_VAR 0 2
72120: ARRAY
72121: PPUSH
72122: LD_INT 22
72124: PUSH
72125: LD_INT 0
72127: PUSH
72128: EMPTY
72129: LIST
72130: LIST
72131: PUSH
72132: LD_INT 25
72134: PUSH
72135: LD_INT 12
72137: PUSH
72138: EMPTY
72139: LIST
72140: LIST
72141: PUSH
72142: EMPTY
72143: LIST
72144: LIST
72145: PPUSH
72146: CALL_OW 70
72150: PUSH
72151: LD_INT 22
72153: PUSH
72154: LD_INT 0
72156: PUSH
72157: EMPTY
72158: LIST
72159: LIST
72160: PUSH
72161: LD_INT 25
72163: PUSH
72164: LD_INT 12
72166: PUSH
72167: EMPTY
72168: LIST
72169: LIST
72170: PUSH
72171: LD_INT 91
72173: PUSH
72174: LD_VAR 0 9
72178: PUSH
72179: LD_INT 20
72181: PUSH
72182: EMPTY
72183: LIST
72184: LIST
72185: LIST
72186: PUSH
72187: EMPTY
72188: LIST
72189: LIST
72190: LIST
72191: PPUSH
72192: CALL_OW 69
72196: UNION
72197: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
72198: LD_ADDR_VAR 0 10
72202: PUSH
72203: LD_EXP 51
72207: PUSH
72208: LD_VAR 0 2
72212: ARRAY
72213: PPUSH
72214: LD_INT 81
72216: PUSH
72217: LD_VAR 0 11
72221: PUSH
72222: EMPTY
72223: LIST
72224: LIST
72225: PPUSH
72226: CALL_OW 70
72230: ST_TO_ADDR
// if not apes or danger_at_area then
72231: LD_VAR 0 7
72235: NOT
72236: PUSH
72237: LD_VAR 0 10
72241: OR
72242: IFFALSE 72292
// begin if mc_taming [ i ] then
72244: LD_EXP 54
72248: PUSH
72249: LD_VAR 0 2
72253: ARRAY
72254: IFFALSE 72290
// begin MC_Reset ( i , 121 ) ;
72256: LD_VAR 0 2
72260: PPUSH
72261: LD_INT 121
72263: PPUSH
72264: CALL 57208 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
72268: LD_ADDR_EXP 54
72272: PUSH
72273: LD_EXP 54
72277: PPUSH
72278: LD_VAR 0 2
72282: PPUSH
72283: EMPTY
72284: PPUSH
72285: CALL_OW 1
72289: ST_TO_ADDR
// end ; continue ;
72290: GO 71858
// end ; for j in tmp do
72292: LD_ADDR_VAR 0 3
72296: PUSH
72297: LD_VAR 0 8
72301: PUSH
72302: FOR_IN
72303: IFFALSE 72639
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
72305: LD_VAR 0 3
72309: PUSH
72310: LD_EXP 54
72314: PUSH
72315: LD_VAR 0 2
72319: ARRAY
72320: IN
72321: NOT
72322: PUSH
72323: LD_EXP 54
72327: PUSH
72328: LD_VAR 0 2
72332: ARRAY
72333: PUSH
72334: LD_INT 3
72336: LESS
72337: AND
72338: IFFALSE 72396
// begin SetTag ( j , 121 ) ;
72340: LD_VAR 0 3
72344: PPUSH
72345: LD_INT 121
72347: PPUSH
72348: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
72352: LD_ADDR_EXP 54
72356: PUSH
72357: LD_EXP 54
72361: PPUSH
72362: LD_VAR 0 2
72366: PUSH
72367: LD_EXP 54
72371: PUSH
72372: LD_VAR 0 2
72376: ARRAY
72377: PUSH
72378: LD_INT 1
72380: PLUS
72381: PUSH
72382: EMPTY
72383: LIST
72384: LIST
72385: PPUSH
72386: LD_VAR 0 3
72390: PPUSH
72391: CALL 16077 0 3
72395: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
72396: LD_VAR 0 3
72400: PUSH
72401: LD_EXP 54
72405: PUSH
72406: LD_VAR 0 2
72410: ARRAY
72411: IN
72412: IFFALSE 72637
// begin if GetClass ( j ) <> 4 then
72414: LD_VAR 0 3
72418: PPUSH
72419: CALL_OW 257
72423: PUSH
72424: LD_INT 4
72426: NONEQUAL
72427: IFFALSE 72480
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
72429: LD_ADDR_EXP 54
72433: PUSH
72434: LD_EXP 54
72438: PPUSH
72439: LD_VAR 0 2
72443: PPUSH
72444: LD_EXP 54
72448: PUSH
72449: LD_VAR 0 2
72453: ARRAY
72454: PUSH
72455: LD_VAR 0 3
72459: DIFF
72460: PPUSH
72461: CALL_OW 1
72465: ST_TO_ADDR
// SetTag ( j , 0 ) ;
72466: LD_VAR 0 3
72470: PPUSH
72471: LD_INT 0
72473: PPUSH
72474: CALL_OW 109
// continue ;
72478: GO 72302
// end ; if IsInUnit ( j ) then
72480: LD_VAR 0 3
72484: PPUSH
72485: CALL_OW 310
72489: IFFALSE 72500
// ComExitBuilding ( j ) ;
72491: LD_VAR 0 3
72495: PPUSH
72496: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
72500: LD_ADDR_VAR 0 6
72504: PUSH
72505: LD_VAR 0 7
72509: PPUSH
72510: LD_VAR 0 3
72514: PPUSH
72515: CALL_OW 74
72519: ST_TO_ADDR
// if not ape then
72520: LD_VAR 0 6
72524: NOT
72525: IFFALSE 72529
// break ;
72527: GO 72639
// x := GetX ( ape ) ;
72529: LD_ADDR_VAR 0 4
72533: PUSH
72534: LD_VAR 0 6
72538: PPUSH
72539: CALL_OW 250
72543: ST_TO_ADDR
// y := GetY ( ape ) ;
72544: LD_ADDR_VAR 0 5
72548: PUSH
72549: LD_VAR 0 6
72553: PPUSH
72554: CALL_OW 251
72558: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
72559: LD_VAR 0 4
72563: PPUSH
72564: LD_VAR 0 5
72568: PPUSH
72569: CALL_OW 488
72573: NOT
72574: PUSH
72575: LD_VAR 0 11
72579: PPUSH
72580: LD_VAR 0 4
72584: PPUSH
72585: LD_VAR 0 5
72589: PPUSH
72590: LD_INT 20
72592: PPUSH
72593: CALL 17341 0 4
72597: PUSH
72598: LD_INT 4
72600: ARRAY
72601: OR
72602: IFFALSE 72606
// break ;
72604: GO 72639
// if not HasTask ( j ) then
72606: LD_VAR 0 3
72610: PPUSH
72611: CALL_OW 314
72615: NOT
72616: IFFALSE 72637
// ComTameXY ( j , x , y ) ;
72618: LD_VAR 0 3
72622: PPUSH
72623: LD_VAR 0 4
72627: PPUSH
72628: LD_VAR 0 5
72632: PPUSH
72633: CALL_OW 131
// end ; end ;
72637: GO 72302
72639: POP
72640: POP
// end ;
72641: GO 71858
72643: POP
72644: POP
// end ;
72645: LD_VAR 0 1
72649: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
72650: LD_INT 0
72652: PPUSH
72653: PPUSH
72654: PPUSH
72655: PPUSH
72656: PPUSH
72657: PPUSH
72658: PPUSH
72659: PPUSH
// if not mc_bases then
72660: LD_EXP 23
72664: NOT
72665: IFFALSE 72669
// exit ;
72667: GO 73295
// for i = 1 to mc_bases do
72669: LD_ADDR_VAR 0 2
72673: PUSH
72674: DOUBLE
72675: LD_INT 1
72677: DEC
72678: ST_TO_ADDR
72679: LD_EXP 23
72683: PUSH
72684: FOR_TO
72685: IFFALSE 73293
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
72687: LD_EXP 52
72691: PUSH
72692: LD_VAR 0 2
72696: ARRAY
72697: NOT
72698: PUSH
72699: LD_EXP 52
72703: PUSH
72704: LD_VAR 0 2
72708: ARRAY
72709: PPUSH
72710: LD_INT 25
72712: PUSH
72713: LD_INT 12
72715: PUSH
72716: EMPTY
72717: LIST
72718: LIST
72719: PPUSH
72720: CALL_OW 72
72724: NOT
72725: OR
72726: IFFALSE 72730
// continue ;
72728: GO 72684
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
72730: LD_ADDR_VAR 0 5
72734: PUSH
72735: LD_EXP 52
72739: PUSH
72740: LD_VAR 0 2
72744: ARRAY
72745: PUSH
72746: LD_INT 1
72748: ARRAY
72749: PPUSH
72750: CALL_OW 255
72754: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
72755: LD_VAR 0 5
72759: PPUSH
72760: LD_INT 2
72762: PPUSH
72763: CALL_OW 325
72767: IFFALSE 73020
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
72769: LD_ADDR_VAR 0 4
72773: PUSH
72774: LD_EXP 52
72778: PUSH
72779: LD_VAR 0 2
72783: ARRAY
72784: PPUSH
72785: LD_INT 25
72787: PUSH
72788: LD_INT 16
72790: PUSH
72791: EMPTY
72792: LIST
72793: LIST
72794: PPUSH
72795: CALL_OW 72
72799: ST_TO_ADDR
// if tmp < 6 then
72800: LD_VAR 0 4
72804: PUSH
72805: LD_INT 6
72807: LESS
72808: IFFALSE 73020
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72810: LD_ADDR_VAR 0 6
72814: PUSH
72815: LD_EXP 23
72819: PUSH
72820: LD_VAR 0 2
72824: ARRAY
72825: PPUSH
72826: LD_INT 2
72828: PUSH
72829: LD_INT 30
72831: PUSH
72832: LD_INT 0
72834: PUSH
72835: EMPTY
72836: LIST
72837: LIST
72838: PUSH
72839: LD_INT 30
72841: PUSH
72842: LD_INT 1
72844: PUSH
72845: EMPTY
72846: LIST
72847: LIST
72848: PUSH
72849: EMPTY
72850: LIST
72851: LIST
72852: LIST
72853: PPUSH
72854: CALL_OW 72
72858: ST_TO_ADDR
// if depot then
72859: LD_VAR 0 6
72863: IFFALSE 73020
// begin selected := 0 ;
72865: LD_ADDR_VAR 0 7
72869: PUSH
72870: LD_INT 0
72872: ST_TO_ADDR
// for j in depot do
72873: LD_ADDR_VAR 0 3
72877: PUSH
72878: LD_VAR 0 6
72882: PUSH
72883: FOR_IN
72884: IFFALSE 72915
// begin if UnitsInside ( j ) < 6 then
72886: LD_VAR 0 3
72890: PPUSH
72891: CALL_OW 313
72895: PUSH
72896: LD_INT 6
72898: LESS
72899: IFFALSE 72913
// begin selected := j ;
72901: LD_ADDR_VAR 0 7
72905: PUSH
72906: LD_VAR 0 3
72910: ST_TO_ADDR
// break ;
72911: GO 72915
// end ; end ;
72913: GO 72883
72915: POP
72916: POP
// if selected then
72917: LD_VAR 0 7
72921: IFFALSE 73020
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
72923: LD_ADDR_VAR 0 3
72927: PUSH
72928: LD_EXP 52
72932: PUSH
72933: LD_VAR 0 2
72937: ARRAY
72938: PPUSH
72939: LD_INT 25
72941: PUSH
72942: LD_INT 12
72944: PUSH
72945: EMPTY
72946: LIST
72947: LIST
72948: PPUSH
72949: CALL_OW 72
72953: PUSH
72954: FOR_IN
72955: IFFALSE 73018
// if not HasTask ( j ) then
72957: LD_VAR 0 3
72961: PPUSH
72962: CALL_OW 314
72966: NOT
72967: IFFALSE 73016
// begin if not IsInUnit ( j ) then
72969: LD_VAR 0 3
72973: PPUSH
72974: CALL_OW 310
72978: NOT
72979: IFFALSE 72995
// ComEnterUnit ( j , selected ) ;
72981: LD_VAR 0 3
72985: PPUSH
72986: LD_VAR 0 7
72990: PPUSH
72991: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
72995: LD_VAR 0 3
72999: PPUSH
73000: LD_INT 16
73002: PPUSH
73003: CALL_OW 183
// AddComExitBuilding ( j ) ;
73007: LD_VAR 0 3
73011: PPUSH
73012: CALL_OW 182
// end ;
73016: GO 72954
73018: POP
73019: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
73020: LD_VAR 0 5
73024: PPUSH
73025: LD_INT 11
73027: PPUSH
73028: CALL_OW 325
73032: IFFALSE 73291
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
73034: LD_ADDR_VAR 0 4
73038: PUSH
73039: LD_EXP 52
73043: PUSH
73044: LD_VAR 0 2
73048: ARRAY
73049: PPUSH
73050: LD_INT 25
73052: PUSH
73053: LD_INT 16
73055: PUSH
73056: EMPTY
73057: LIST
73058: LIST
73059: PPUSH
73060: CALL_OW 72
73064: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
73065: LD_VAR 0 4
73069: PUSH
73070: LD_INT 6
73072: GREATEREQUAL
73073: PUSH
73074: LD_VAR 0 5
73078: PPUSH
73079: LD_INT 2
73081: PPUSH
73082: CALL_OW 325
73086: NOT
73087: OR
73088: IFFALSE 73291
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
73090: LD_ADDR_VAR 0 8
73094: PUSH
73095: LD_EXP 23
73099: PUSH
73100: LD_VAR 0 2
73104: ARRAY
73105: PPUSH
73106: LD_INT 2
73108: PUSH
73109: LD_INT 30
73111: PUSH
73112: LD_INT 4
73114: PUSH
73115: EMPTY
73116: LIST
73117: LIST
73118: PUSH
73119: LD_INT 30
73121: PUSH
73122: LD_INT 5
73124: PUSH
73125: EMPTY
73126: LIST
73127: LIST
73128: PUSH
73129: EMPTY
73130: LIST
73131: LIST
73132: LIST
73133: PPUSH
73134: CALL_OW 72
73138: ST_TO_ADDR
// if barracks then
73139: LD_VAR 0 8
73143: IFFALSE 73291
// begin selected := 0 ;
73145: LD_ADDR_VAR 0 7
73149: PUSH
73150: LD_INT 0
73152: ST_TO_ADDR
// for j in barracks do
73153: LD_ADDR_VAR 0 3
73157: PUSH
73158: LD_VAR 0 8
73162: PUSH
73163: FOR_IN
73164: IFFALSE 73195
// begin if UnitsInside ( j ) < 6 then
73166: LD_VAR 0 3
73170: PPUSH
73171: CALL_OW 313
73175: PUSH
73176: LD_INT 6
73178: LESS
73179: IFFALSE 73193
// begin selected := j ;
73181: LD_ADDR_VAR 0 7
73185: PUSH
73186: LD_VAR 0 3
73190: ST_TO_ADDR
// break ;
73191: GO 73195
// end ; end ;
73193: GO 73163
73195: POP
73196: POP
// if selected then
73197: LD_VAR 0 7
73201: IFFALSE 73291
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
73203: LD_ADDR_VAR 0 3
73207: PUSH
73208: LD_EXP 52
73212: PUSH
73213: LD_VAR 0 2
73217: ARRAY
73218: PPUSH
73219: LD_INT 25
73221: PUSH
73222: LD_INT 12
73224: PUSH
73225: EMPTY
73226: LIST
73227: LIST
73228: PPUSH
73229: CALL_OW 72
73233: PUSH
73234: FOR_IN
73235: IFFALSE 73289
// if not IsInUnit ( j ) and not HasTask ( j ) then
73237: LD_VAR 0 3
73241: PPUSH
73242: CALL_OW 310
73246: NOT
73247: PUSH
73248: LD_VAR 0 3
73252: PPUSH
73253: CALL_OW 314
73257: NOT
73258: AND
73259: IFFALSE 73287
// begin ComEnterUnit ( j , selected ) ;
73261: LD_VAR 0 3
73265: PPUSH
73266: LD_VAR 0 7
73270: PPUSH
73271: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
73275: LD_VAR 0 3
73279: PPUSH
73280: LD_INT 15
73282: PPUSH
73283: CALL_OW 183
// end ;
73287: GO 73234
73289: POP
73290: POP
// end ; end ; end ; end ; end ;
73291: GO 72684
73293: POP
73294: POP
// end ;
73295: LD_VAR 0 1
73299: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
73300: LD_INT 0
73302: PPUSH
73303: PPUSH
73304: PPUSH
73305: PPUSH
// if not mc_bases then
73306: LD_EXP 23
73310: NOT
73311: IFFALSE 73315
// exit ;
73313: GO 73493
// for i = 1 to mc_bases do
73315: LD_ADDR_VAR 0 2
73319: PUSH
73320: DOUBLE
73321: LD_INT 1
73323: DEC
73324: ST_TO_ADDR
73325: LD_EXP 23
73329: PUSH
73330: FOR_TO
73331: IFFALSE 73491
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
73333: LD_ADDR_VAR 0 4
73337: PUSH
73338: LD_EXP 23
73342: PUSH
73343: LD_VAR 0 2
73347: ARRAY
73348: PPUSH
73349: LD_INT 25
73351: PUSH
73352: LD_INT 9
73354: PUSH
73355: EMPTY
73356: LIST
73357: LIST
73358: PPUSH
73359: CALL_OW 72
73363: ST_TO_ADDR
// if not tmp then
73364: LD_VAR 0 4
73368: NOT
73369: IFFALSE 73373
// continue ;
73371: GO 73330
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
73373: LD_EXP 49
73377: PUSH
73378: LD_VAR 0 2
73382: ARRAY
73383: PPUSH
73384: LD_INT 29
73386: PPUSH
73387: CALL_OW 325
73391: NOT
73392: PUSH
73393: LD_EXP 49
73397: PUSH
73398: LD_VAR 0 2
73402: ARRAY
73403: PPUSH
73404: LD_INT 28
73406: PPUSH
73407: CALL_OW 325
73411: NOT
73412: AND
73413: IFFALSE 73417
// continue ;
73415: GO 73330
// for j in tmp do
73417: LD_ADDR_VAR 0 3
73421: PUSH
73422: LD_VAR 0 4
73426: PUSH
73427: FOR_IN
73428: IFFALSE 73487
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
73430: LD_VAR 0 3
73434: PUSH
73435: LD_EXP 26
73439: PUSH
73440: LD_VAR 0 2
73444: ARRAY
73445: PUSH
73446: LD_INT 1
73448: ARRAY
73449: IN
73450: NOT
73451: PUSH
73452: LD_VAR 0 3
73456: PUSH
73457: LD_EXP 26
73461: PUSH
73462: LD_VAR 0 2
73466: ARRAY
73467: PUSH
73468: LD_INT 2
73470: ARRAY
73471: IN
73472: NOT
73473: AND
73474: IFFALSE 73485
// ComSpaceTimeShoot ( j ) ;
73476: LD_VAR 0 3
73480: PPUSH
73481: CALL 12062 0 1
73485: GO 73427
73487: POP
73488: POP
// end ;
73489: GO 73330
73491: POP
73492: POP
// end ;
73493: LD_VAR 0 1
73497: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
73498: LD_INT 0
73500: PPUSH
73501: PPUSH
73502: PPUSH
73503: PPUSH
73504: PPUSH
73505: PPUSH
73506: PPUSH
73507: PPUSH
73508: PPUSH
// if not mc_bases then
73509: LD_EXP 23
73513: NOT
73514: IFFALSE 73518
// exit ;
73516: GO 74140
// for i = 1 to mc_bases do
73518: LD_ADDR_VAR 0 2
73522: PUSH
73523: DOUBLE
73524: LD_INT 1
73526: DEC
73527: ST_TO_ADDR
73528: LD_EXP 23
73532: PUSH
73533: FOR_TO
73534: IFFALSE 74138
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
73536: LD_EXP 58
73540: PUSH
73541: LD_VAR 0 2
73545: ARRAY
73546: NOT
73547: PUSH
73548: LD_INT 38
73550: PPUSH
73551: LD_EXP 49
73555: PUSH
73556: LD_VAR 0 2
73560: ARRAY
73561: PPUSH
73562: CALL_OW 321
73566: PUSH
73567: LD_INT 2
73569: NONEQUAL
73570: OR
73571: IFFALSE 73575
// continue ;
73573: GO 73533
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
73575: LD_ADDR_VAR 0 8
73579: PUSH
73580: LD_EXP 23
73584: PUSH
73585: LD_VAR 0 2
73589: ARRAY
73590: PPUSH
73591: LD_INT 30
73593: PUSH
73594: LD_INT 34
73596: PUSH
73597: EMPTY
73598: LIST
73599: LIST
73600: PPUSH
73601: CALL_OW 72
73605: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
73606: LD_ADDR_VAR 0 9
73610: PUSH
73611: LD_EXP 23
73615: PUSH
73616: LD_VAR 0 2
73620: ARRAY
73621: PPUSH
73622: LD_INT 25
73624: PUSH
73625: LD_INT 4
73627: PUSH
73628: EMPTY
73629: LIST
73630: LIST
73631: PPUSH
73632: CALL_OW 72
73636: PPUSH
73637: LD_INT 0
73639: PPUSH
73640: CALL 46386 0 2
73644: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
73645: LD_VAR 0 9
73649: NOT
73650: PUSH
73651: LD_VAR 0 8
73655: NOT
73656: OR
73657: PUSH
73658: LD_EXP 23
73662: PUSH
73663: LD_VAR 0 2
73667: ARRAY
73668: PPUSH
73669: LD_INT 124
73671: PPUSH
73672: CALL 46386 0 2
73676: OR
73677: IFFALSE 73681
// continue ;
73679: GO 73533
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
73681: LD_EXP 59
73685: PUSH
73686: LD_VAR 0 2
73690: ARRAY
73691: PUSH
73692: LD_EXP 58
73696: PUSH
73697: LD_VAR 0 2
73701: ARRAY
73702: LESS
73703: PUSH
73704: LD_EXP 59
73708: PUSH
73709: LD_VAR 0 2
73713: ARRAY
73714: PUSH
73715: LD_VAR 0 8
73719: LESS
73720: AND
73721: IFFALSE 74136
// begin tmp := sci [ 1 ] ;
73723: LD_ADDR_VAR 0 7
73727: PUSH
73728: LD_VAR 0 9
73732: PUSH
73733: LD_INT 1
73735: ARRAY
73736: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
73737: LD_VAR 0 7
73741: PPUSH
73742: LD_INT 124
73744: PPUSH
73745: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
73749: LD_ADDR_VAR 0 3
73753: PUSH
73754: DOUBLE
73755: LD_EXP 58
73759: PUSH
73760: LD_VAR 0 2
73764: ARRAY
73765: INC
73766: ST_TO_ADDR
73767: LD_EXP 58
73771: PUSH
73772: LD_VAR 0 2
73776: ARRAY
73777: PUSH
73778: FOR_DOWNTO
73779: IFFALSE 74122
// begin if IsInUnit ( tmp ) then
73781: LD_VAR 0 7
73785: PPUSH
73786: CALL_OW 310
73790: IFFALSE 73801
// ComExitBuilding ( tmp ) ;
73792: LD_VAR 0 7
73796: PPUSH
73797: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
73801: LD_INT 35
73803: PPUSH
73804: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
73808: LD_VAR 0 7
73812: PPUSH
73813: CALL_OW 310
73817: NOT
73818: PUSH
73819: LD_VAR 0 7
73823: PPUSH
73824: CALL_OW 314
73828: NOT
73829: AND
73830: IFFALSE 73801
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
73832: LD_ADDR_VAR 0 6
73836: PUSH
73837: LD_VAR 0 7
73841: PPUSH
73842: CALL_OW 250
73846: PUSH
73847: LD_VAR 0 7
73851: PPUSH
73852: CALL_OW 251
73856: PUSH
73857: EMPTY
73858: LIST
73859: LIST
73860: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
73861: LD_INT 35
73863: PPUSH
73864: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
73868: LD_ADDR_VAR 0 4
73872: PUSH
73873: LD_EXP 58
73877: PUSH
73878: LD_VAR 0 2
73882: ARRAY
73883: PUSH
73884: LD_VAR 0 3
73888: ARRAY
73889: PUSH
73890: LD_INT 1
73892: ARRAY
73893: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
73894: LD_ADDR_VAR 0 5
73898: PUSH
73899: LD_EXP 58
73903: PUSH
73904: LD_VAR 0 2
73908: ARRAY
73909: PUSH
73910: LD_VAR 0 3
73914: ARRAY
73915: PUSH
73916: LD_INT 2
73918: ARRAY
73919: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
73920: LD_VAR 0 7
73924: PPUSH
73925: LD_INT 10
73927: PPUSH
73928: CALL 19042 0 2
73932: PUSH
73933: LD_INT 4
73935: ARRAY
73936: IFFALSE 73974
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
73938: LD_VAR 0 7
73942: PPUSH
73943: LD_VAR 0 6
73947: PUSH
73948: LD_INT 1
73950: ARRAY
73951: PPUSH
73952: LD_VAR 0 6
73956: PUSH
73957: LD_INT 2
73959: ARRAY
73960: PPUSH
73961: CALL_OW 111
// wait ( 0 0$10 ) ;
73965: LD_INT 350
73967: PPUSH
73968: CALL_OW 67
// end else
73972: GO 74000
// begin ComMoveXY ( tmp , x , y ) ;
73974: LD_VAR 0 7
73978: PPUSH
73979: LD_VAR 0 4
73983: PPUSH
73984: LD_VAR 0 5
73988: PPUSH
73989: CALL_OW 111
// wait ( 0 0$3 ) ;
73993: LD_INT 105
73995: PPUSH
73996: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
74000: LD_VAR 0 7
74004: PPUSH
74005: LD_VAR 0 4
74009: PPUSH
74010: LD_VAR 0 5
74014: PPUSH
74015: CALL_OW 307
74019: IFFALSE 73861
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
74021: LD_VAR 0 7
74025: PPUSH
74026: LD_VAR 0 4
74030: PPUSH
74031: LD_VAR 0 5
74035: PPUSH
74036: LD_VAR 0 8
74040: PUSH
74041: LD_VAR 0 3
74045: ARRAY
74046: PPUSH
74047: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
74051: LD_INT 35
74053: PPUSH
74054: CALL_OW 67
// until not HasTask ( tmp ) ;
74058: LD_VAR 0 7
74062: PPUSH
74063: CALL_OW 314
74067: NOT
74068: IFFALSE 74051
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
74070: LD_ADDR_EXP 59
74074: PUSH
74075: LD_EXP 59
74079: PPUSH
74080: LD_VAR 0 2
74084: PUSH
74085: LD_EXP 59
74089: PUSH
74090: LD_VAR 0 2
74094: ARRAY
74095: PUSH
74096: LD_INT 1
74098: PLUS
74099: PUSH
74100: EMPTY
74101: LIST
74102: LIST
74103: PPUSH
74104: LD_VAR 0 8
74108: PUSH
74109: LD_VAR 0 3
74113: ARRAY
74114: PPUSH
74115: CALL 16077 0 3
74119: ST_TO_ADDR
// end ;
74120: GO 73778
74122: POP
74123: POP
// MC_Reset ( i , 124 ) ;
74124: LD_VAR 0 2
74128: PPUSH
74129: LD_INT 124
74131: PPUSH
74132: CALL 57208 0 2
// end ; end ;
74136: GO 73533
74138: POP
74139: POP
// end ;
74140: LD_VAR 0 1
74144: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
74145: LD_INT 0
74147: PPUSH
74148: PPUSH
74149: PPUSH
// if not mc_bases then
74150: LD_EXP 23
74154: NOT
74155: IFFALSE 74159
// exit ;
74157: GO 74765
// for i = 1 to mc_bases do
74159: LD_ADDR_VAR 0 2
74163: PUSH
74164: DOUBLE
74165: LD_INT 1
74167: DEC
74168: ST_TO_ADDR
74169: LD_EXP 23
74173: PUSH
74174: FOR_TO
74175: IFFALSE 74763
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
74177: LD_ADDR_VAR 0 3
74181: PUSH
74182: LD_EXP 23
74186: PUSH
74187: LD_VAR 0 2
74191: ARRAY
74192: PPUSH
74193: LD_INT 25
74195: PUSH
74196: LD_INT 4
74198: PUSH
74199: EMPTY
74200: LIST
74201: LIST
74202: PPUSH
74203: CALL_OW 72
74207: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
74208: LD_VAR 0 3
74212: NOT
74213: PUSH
74214: LD_EXP 60
74218: PUSH
74219: LD_VAR 0 2
74223: ARRAY
74224: NOT
74225: OR
74226: PUSH
74227: LD_EXP 23
74231: PUSH
74232: LD_VAR 0 2
74236: ARRAY
74237: PPUSH
74238: LD_INT 2
74240: PUSH
74241: LD_INT 30
74243: PUSH
74244: LD_INT 0
74246: PUSH
74247: EMPTY
74248: LIST
74249: LIST
74250: PUSH
74251: LD_INT 30
74253: PUSH
74254: LD_INT 1
74256: PUSH
74257: EMPTY
74258: LIST
74259: LIST
74260: PUSH
74261: EMPTY
74262: LIST
74263: LIST
74264: LIST
74265: PPUSH
74266: CALL_OW 72
74270: NOT
74271: OR
74272: IFFALSE 74322
// begin if mc_deposits_finder [ i ] then
74274: LD_EXP 61
74278: PUSH
74279: LD_VAR 0 2
74283: ARRAY
74284: IFFALSE 74320
// begin MC_Reset ( i , 125 ) ;
74286: LD_VAR 0 2
74290: PPUSH
74291: LD_INT 125
74293: PPUSH
74294: CALL 57208 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
74298: LD_ADDR_EXP 61
74302: PUSH
74303: LD_EXP 61
74307: PPUSH
74308: LD_VAR 0 2
74312: PPUSH
74313: EMPTY
74314: PPUSH
74315: CALL_OW 1
74319: ST_TO_ADDR
// end ; continue ;
74320: GO 74174
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
74322: LD_EXP 60
74326: PUSH
74327: LD_VAR 0 2
74331: ARRAY
74332: PUSH
74333: LD_INT 1
74335: ARRAY
74336: PUSH
74337: LD_INT 3
74339: ARRAY
74340: PUSH
74341: LD_INT 1
74343: EQUAL
74344: PUSH
74345: LD_INT 20
74347: PPUSH
74348: LD_EXP 49
74352: PUSH
74353: LD_VAR 0 2
74357: ARRAY
74358: PPUSH
74359: CALL_OW 321
74363: PUSH
74364: LD_INT 2
74366: NONEQUAL
74367: AND
74368: IFFALSE 74418
// begin if mc_deposits_finder [ i ] then
74370: LD_EXP 61
74374: PUSH
74375: LD_VAR 0 2
74379: ARRAY
74380: IFFALSE 74416
// begin MC_Reset ( i , 125 ) ;
74382: LD_VAR 0 2
74386: PPUSH
74387: LD_INT 125
74389: PPUSH
74390: CALL 57208 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
74394: LD_ADDR_EXP 61
74398: PUSH
74399: LD_EXP 61
74403: PPUSH
74404: LD_VAR 0 2
74408: PPUSH
74409: EMPTY
74410: PPUSH
74411: CALL_OW 1
74415: ST_TO_ADDR
// end ; continue ;
74416: GO 74174
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
74418: LD_EXP 60
74422: PUSH
74423: LD_VAR 0 2
74427: ARRAY
74428: PUSH
74429: LD_INT 1
74431: ARRAY
74432: PUSH
74433: LD_INT 1
74435: ARRAY
74436: PPUSH
74437: LD_EXP 60
74441: PUSH
74442: LD_VAR 0 2
74446: ARRAY
74447: PUSH
74448: LD_INT 1
74450: ARRAY
74451: PUSH
74452: LD_INT 2
74454: ARRAY
74455: PPUSH
74456: LD_EXP 49
74460: PUSH
74461: LD_VAR 0 2
74465: ARRAY
74466: PPUSH
74467: CALL_OW 440
74471: IFFALSE 74514
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
74473: LD_ADDR_EXP 60
74477: PUSH
74478: LD_EXP 60
74482: PPUSH
74483: LD_VAR 0 2
74487: PPUSH
74488: LD_EXP 60
74492: PUSH
74493: LD_VAR 0 2
74497: ARRAY
74498: PPUSH
74499: LD_INT 1
74501: PPUSH
74502: CALL_OW 3
74506: PPUSH
74507: CALL_OW 1
74511: ST_TO_ADDR
74512: GO 74761
// begin if not mc_deposits_finder [ i ] then
74514: LD_EXP 61
74518: PUSH
74519: LD_VAR 0 2
74523: ARRAY
74524: NOT
74525: IFFALSE 74577
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
74527: LD_ADDR_EXP 61
74531: PUSH
74532: LD_EXP 61
74536: PPUSH
74537: LD_VAR 0 2
74541: PPUSH
74542: LD_VAR 0 3
74546: PUSH
74547: LD_INT 1
74549: ARRAY
74550: PUSH
74551: EMPTY
74552: LIST
74553: PPUSH
74554: CALL_OW 1
74558: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
74559: LD_VAR 0 3
74563: PUSH
74564: LD_INT 1
74566: ARRAY
74567: PPUSH
74568: LD_INT 125
74570: PPUSH
74571: CALL_OW 109
// end else
74575: GO 74761
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
74577: LD_EXP 61
74581: PUSH
74582: LD_VAR 0 2
74586: ARRAY
74587: PUSH
74588: LD_INT 1
74590: ARRAY
74591: PPUSH
74592: CALL_OW 310
74596: IFFALSE 74619
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
74598: LD_EXP 61
74602: PUSH
74603: LD_VAR 0 2
74607: ARRAY
74608: PUSH
74609: LD_INT 1
74611: ARRAY
74612: PPUSH
74613: CALL_OW 122
74617: GO 74761
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
74619: LD_EXP 61
74623: PUSH
74624: LD_VAR 0 2
74628: ARRAY
74629: PUSH
74630: LD_INT 1
74632: ARRAY
74633: PPUSH
74634: CALL_OW 314
74638: NOT
74639: PUSH
74640: LD_EXP 61
74644: PUSH
74645: LD_VAR 0 2
74649: ARRAY
74650: PUSH
74651: LD_INT 1
74653: ARRAY
74654: PPUSH
74655: LD_EXP 60
74659: PUSH
74660: LD_VAR 0 2
74664: ARRAY
74665: PUSH
74666: LD_INT 1
74668: ARRAY
74669: PUSH
74670: LD_INT 1
74672: ARRAY
74673: PPUSH
74674: LD_EXP 60
74678: PUSH
74679: LD_VAR 0 2
74683: ARRAY
74684: PUSH
74685: LD_INT 1
74687: ARRAY
74688: PUSH
74689: LD_INT 2
74691: ARRAY
74692: PPUSH
74693: CALL_OW 297
74697: PUSH
74698: LD_INT 6
74700: GREATER
74701: AND
74702: IFFALSE 74761
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
74704: LD_EXP 61
74708: PUSH
74709: LD_VAR 0 2
74713: ARRAY
74714: PUSH
74715: LD_INT 1
74717: ARRAY
74718: PPUSH
74719: LD_EXP 60
74723: PUSH
74724: LD_VAR 0 2
74728: ARRAY
74729: PUSH
74730: LD_INT 1
74732: ARRAY
74733: PUSH
74734: LD_INT 1
74736: ARRAY
74737: PPUSH
74738: LD_EXP 60
74742: PUSH
74743: LD_VAR 0 2
74747: ARRAY
74748: PUSH
74749: LD_INT 1
74751: ARRAY
74752: PUSH
74753: LD_INT 2
74755: ARRAY
74756: PPUSH
74757: CALL_OW 111
// end ; end ; end ;
74761: GO 74174
74763: POP
74764: POP
// end ;
74765: LD_VAR 0 1
74769: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
74770: LD_INT 0
74772: PPUSH
74773: PPUSH
74774: PPUSH
74775: PPUSH
74776: PPUSH
74777: PPUSH
74778: PPUSH
74779: PPUSH
74780: PPUSH
74781: PPUSH
74782: PPUSH
// if not mc_bases then
74783: LD_EXP 23
74787: NOT
74788: IFFALSE 74792
// exit ;
74790: GO 75732
// for i = 1 to mc_bases do
74792: LD_ADDR_VAR 0 2
74796: PUSH
74797: DOUBLE
74798: LD_INT 1
74800: DEC
74801: ST_TO_ADDR
74802: LD_EXP 23
74806: PUSH
74807: FOR_TO
74808: IFFALSE 75730
// begin if not mc_bases [ i ] or mc_scan [ i ] then
74810: LD_EXP 23
74814: PUSH
74815: LD_VAR 0 2
74819: ARRAY
74820: NOT
74821: PUSH
74822: LD_EXP 46
74826: PUSH
74827: LD_VAR 0 2
74831: ARRAY
74832: OR
74833: IFFALSE 74837
// continue ;
74835: GO 74807
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
74837: LD_ADDR_VAR 0 7
74841: PUSH
74842: LD_EXP 23
74846: PUSH
74847: LD_VAR 0 2
74851: ARRAY
74852: PUSH
74853: LD_INT 1
74855: ARRAY
74856: PPUSH
74857: CALL_OW 248
74861: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
74862: LD_VAR 0 7
74866: PUSH
74867: LD_INT 3
74869: EQUAL
74870: PUSH
74871: LD_EXP 42
74875: PUSH
74876: LD_VAR 0 2
74880: ARRAY
74881: PUSH
74882: LD_EXP 45
74886: PUSH
74887: LD_VAR 0 2
74891: ARRAY
74892: UNION
74893: PPUSH
74894: LD_INT 33
74896: PUSH
74897: LD_INT 2
74899: PUSH
74900: EMPTY
74901: LIST
74902: LIST
74903: PPUSH
74904: CALL_OW 72
74908: NOT
74909: OR
74910: IFFALSE 74914
// continue ;
74912: GO 74807
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
74914: LD_ADDR_VAR 0 9
74918: PUSH
74919: LD_EXP 23
74923: PUSH
74924: LD_VAR 0 2
74928: ARRAY
74929: PPUSH
74930: LD_INT 30
74932: PUSH
74933: LD_INT 36
74935: PUSH
74936: EMPTY
74937: LIST
74938: LIST
74939: PPUSH
74940: CALL_OW 72
74944: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
74945: LD_ADDR_VAR 0 10
74949: PUSH
74950: LD_EXP 42
74954: PUSH
74955: LD_VAR 0 2
74959: ARRAY
74960: PPUSH
74961: LD_INT 34
74963: PUSH
74964: LD_INT 31
74966: PUSH
74967: EMPTY
74968: LIST
74969: LIST
74970: PPUSH
74971: CALL_OW 72
74975: ST_TO_ADDR
// if not cts and not mcts then
74976: LD_VAR 0 9
74980: NOT
74981: PUSH
74982: LD_VAR 0 10
74986: NOT
74987: AND
74988: IFFALSE 74992
// continue ;
74990: GO 74807
// x := cts ;
74992: LD_ADDR_VAR 0 11
74996: PUSH
74997: LD_VAR 0 9
75001: ST_TO_ADDR
// if not x then
75002: LD_VAR 0 11
75006: NOT
75007: IFFALSE 75019
// x := mcts ;
75009: LD_ADDR_VAR 0 11
75013: PUSH
75014: LD_VAR 0 10
75018: ST_TO_ADDR
// if not x then
75019: LD_VAR 0 11
75023: NOT
75024: IFFALSE 75028
// continue ;
75026: GO 74807
// if mc_remote_driver [ i ] then
75028: LD_EXP 63
75032: PUSH
75033: LD_VAR 0 2
75037: ARRAY
75038: IFFALSE 75425
// for j in mc_remote_driver [ i ] do
75040: LD_ADDR_VAR 0 3
75044: PUSH
75045: LD_EXP 63
75049: PUSH
75050: LD_VAR 0 2
75054: ARRAY
75055: PUSH
75056: FOR_IN
75057: IFFALSE 75423
// begin if GetClass ( j ) <> 3 then
75059: LD_VAR 0 3
75063: PPUSH
75064: CALL_OW 257
75068: PUSH
75069: LD_INT 3
75071: NONEQUAL
75072: IFFALSE 75125
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
75074: LD_ADDR_EXP 63
75078: PUSH
75079: LD_EXP 63
75083: PPUSH
75084: LD_VAR 0 2
75088: PPUSH
75089: LD_EXP 63
75093: PUSH
75094: LD_VAR 0 2
75098: ARRAY
75099: PUSH
75100: LD_VAR 0 3
75104: DIFF
75105: PPUSH
75106: CALL_OW 1
75110: ST_TO_ADDR
// SetTag ( j , 0 ) ;
75111: LD_VAR 0 3
75115: PPUSH
75116: LD_INT 0
75118: PPUSH
75119: CALL_OW 109
// continue ;
75123: GO 75056
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
75125: LD_EXP 42
75129: PUSH
75130: LD_VAR 0 2
75134: ARRAY
75135: PPUSH
75136: LD_INT 34
75138: PUSH
75139: LD_INT 31
75141: PUSH
75142: EMPTY
75143: LIST
75144: LIST
75145: PUSH
75146: LD_INT 58
75148: PUSH
75149: EMPTY
75150: LIST
75151: PUSH
75152: EMPTY
75153: LIST
75154: LIST
75155: PPUSH
75156: CALL_OW 72
75160: PUSH
75161: LD_VAR 0 3
75165: PPUSH
75166: CALL 46421 0 1
75170: NOT
75171: AND
75172: IFFALSE 75243
// begin if IsInUnit ( j ) then
75174: LD_VAR 0 3
75178: PPUSH
75179: CALL_OW 310
75183: IFFALSE 75194
// ComExitBuilding ( j ) ;
75185: LD_VAR 0 3
75189: PPUSH
75190: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
75194: LD_VAR 0 3
75198: PPUSH
75199: LD_EXP 42
75203: PUSH
75204: LD_VAR 0 2
75208: ARRAY
75209: PPUSH
75210: LD_INT 34
75212: PUSH
75213: LD_INT 31
75215: PUSH
75216: EMPTY
75217: LIST
75218: LIST
75219: PUSH
75220: LD_INT 58
75222: PUSH
75223: EMPTY
75224: LIST
75225: PUSH
75226: EMPTY
75227: LIST
75228: LIST
75229: PPUSH
75230: CALL_OW 72
75234: PUSH
75235: LD_INT 1
75237: ARRAY
75238: PPUSH
75239: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
75243: LD_VAR 0 3
75247: PPUSH
75248: CALL_OW 310
75252: NOT
75253: PUSH
75254: LD_VAR 0 3
75258: PPUSH
75259: CALL_OW 310
75263: PPUSH
75264: CALL_OW 266
75268: PUSH
75269: LD_INT 36
75271: NONEQUAL
75272: PUSH
75273: LD_VAR 0 3
75277: PPUSH
75278: CALL 46421 0 1
75282: NOT
75283: AND
75284: OR
75285: IFFALSE 75421
// begin if IsInUnit ( j ) then
75287: LD_VAR 0 3
75291: PPUSH
75292: CALL_OW 310
75296: IFFALSE 75307
// ComExitBuilding ( j ) ;
75298: LD_VAR 0 3
75302: PPUSH
75303: CALL_OW 122
// ct := 0 ;
75307: LD_ADDR_VAR 0 8
75311: PUSH
75312: LD_INT 0
75314: ST_TO_ADDR
// for k in x do
75315: LD_ADDR_VAR 0 4
75319: PUSH
75320: LD_VAR 0 11
75324: PUSH
75325: FOR_IN
75326: IFFALSE 75399
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
75328: LD_VAR 0 4
75332: PPUSH
75333: CALL_OW 264
75337: PUSH
75338: LD_INT 31
75340: EQUAL
75341: PUSH
75342: LD_VAR 0 4
75346: PPUSH
75347: CALL_OW 311
75351: NOT
75352: AND
75353: PUSH
75354: LD_VAR 0 4
75358: PPUSH
75359: CALL_OW 266
75363: PUSH
75364: LD_INT 36
75366: EQUAL
75367: PUSH
75368: LD_VAR 0 4
75372: PPUSH
75373: CALL_OW 313
75377: PUSH
75378: LD_INT 3
75380: LESS
75381: AND
75382: OR
75383: IFFALSE 75397
// begin ct := k ;
75385: LD_ADDR_VAR 0 8
75389: PUSH
75390: LD_VAR 0 4
75394: ST_TO_ADDR
// break ;
75395: GO 75399
// end ;
75397: GO 75325
75399: POP
75400: POP
// if ct then
75401: LD_VAR 0 8
75405: IFFALSE 75421
// ComEnterUnit ( j , ct ) ;
75407: LD_VAR 0 3
75411: PPUSH
75412: LD_VAR 0 8
75416: PPUSH
75417: CALL_OW 120
// end ; end ;
75421: GO 75056
75423: POP
75424: POP
// places := 0 ;
75425: LD_ADDR_VAR 0 5
75429: PUSH
75430: LD_INT 0
75432: ST_TO_ADDR
// for j = 1 to x do
75433: LD_ADDR_VAR 0 3
75437: PUSH
75438: DOUBLE
75439: LD_INT 1
75441: DEC
75442: ST_TO_ADDR
75443: LD_VAR 0 11
75447: PUSH
75448: FOR_TO
75449: IFFALSE 75525
// if GetWeapon ( x [ j ] ) = ar_control_tower then
75451: LD_VAR 0 11
75455: PUSH
75456: LD_VAR 0 3
75460: ARRAY
75461: PPUSH
75462: CALL_OW 264
75466: PUSH
75467: LD_INT 31
75469: EQUAL
75470: IFFALSE 75488
// places := places + 1 else
75472: LD_ADDR_VAR 0 5
75476: PUSH
75477: LD_VAR 0 5
75481: PUSH
75482: LD_INT 1
75484: PLUS
75485: ST_TO_ADDR
75486: GO 75523
// if GetBType ( x [ j ] ) = b_control_tower then
75488: LD_VAR 0 11
75492: PUSH
75493: LD_VAR 0 3
75497: ARRAY
75498: PPUSH
75499: CALL_OW 266
75503: PUSH
75504: LD_INT 36
75506: EQUAL
75507: IFFALSE 75523
// places := places + 3 ;
75509: LD_ADDR_VAR 0 5
75513: PUSH
75514: LD_VAR 0 5
75518: PUSH
75519: LD_INT 3
75521: PLUS
75522: ST_TO_ADDR
75523: GO 75448
75525: POP
75526: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
75527: LD_VAR 0 5
75531: PUSH
75532: LD_INT 0
75534: EQUAL
75535: PUSH
75536: LD_VAR 0 5
75540: PUSH
75541: LD_EXP 63
75545: PUSH
75546: LD_VAR 0 2
75550: ARRAY
75551: LESSEQUAL
75552: OR
75553: IFFALSE 75557
// continue ;
75555: GO 74807
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
75557: LD_ADDR_VAR 0 6
75561: PUSH
75562: LD_EXP 23
75566: PUSH
75567: LD_VAR 0 2
75571: ARRAY
75572: PPUSH
75573: LD_INT 25
75575: PUSH
75576: LD_INT 3
75578: PUSH
75579: EMPTY
75580: LIST
75581: LIST
75582: PPUSH
75583: CALL_OW 72
75587: PUSH
75588: LD_EXP 63
75592: PUSH
75593: LD_VAR 0 2
75597: ARRAY
75598: DIFF
75599: PPUSH
75600: LD_INT 3
75602: PPUSH
75603: CALL 47321 0 2
75607: ST_TO_ADDR
// for j in tmp do
75608: LD_ADDR_VAR 0 3
75612: PUSH
75613: LD_VAR 0 6
75617: PUSH
75618: FOR_IN
75619: IFFALSE 75654
// if GetTag ( j ) > 0 then
75621: LD_VAR 0 3
75625: PPUSH
75626: CALL_OW 110
75630: PUSH
75631: LD_INT 0
75633: GREATER
75634: IFFALSE 75652
// tmp := tmp diff j ;
75636: LD_ADDR_VAR 0 6
75640: PUSH
75641: LD_VAR 0 6
75645: PUSH
75646: LD_VAR 0 3
75650: DIFF
75651: ST_TO_ADDR
75652: GO 75618
75654: POP
75655: POP
// if not tmp then
75656: LD_VAR 0 6
75660: NOT
75661: IFFALSE 75665
// continue ;
75663: GO 74807
// if places then
75665: LD_VAR 0 5
75669: IFFALSE 75728
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
75671: LD_ADDR_EXP 63
75675: PUSH
75676: LD_EXP 63
75680: PPUSH
75681: LD_VAR 0 2
75685: PPUSH
75686: LD_EXP 63
75690: PUSH
75691: LD_VAR 0 2
75695: ARRAY
75696: PUSH
75697: LD_VAR 0 6
75701: PUSH
75702: LD_INT 1
75704: ARRAY
75705: UNION
75706: PPUSH
75707: CALL_OW 1
75711: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
75712: LD_VAR 0 6
75716: PUSH
75717: LD_INT 1
75719: ARRAY
75720: PPUSH
75721: LD_INT 126
75723: PPUSH
75724: CALL_OW 109
// end ; end ;
75728: GO 74807
75730: POP
75731: POP
// end ;
75732: LD_VAR 0 1
75736: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
75737: LD_INT 0
75739: PPUSH
75740: PPUSH
75741: PPUSH
75742: PPUSH
75743: PPUSH
75744: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
75745: LD_VAR 0 1
75749: NOT
75750: PUSH
75751: LD_VAR 0 2
75755: NOT
75756: OR
75757: PUSH
75758: LD_VAR 0 3
75762: NOT
75763: OR
75764: PUSH
75765: LD_VAR 0 4
75769: PUSH
75770: LD_INT 1
75772: PUSH
75773: LD_INT 2
75775: PUSH
75776: LD_INT 3
75778: PUSH
75779: LD_INT 4
75781: PUSH
75782: LD_INT 5
75784: PUSH
75785: LD_INT 8
75787: PUSH
75788: LD_INT 9
75790: PUSH
75791: LD_INT 15
75793: PUSH
75794: LD_INT 16
75796: PUSH
75797: EMPTY
75798: LIST
75799: LIST
75800: LIST
75801: LIST
75802: LIST
75803: LIST
75804: LIST
75805: LIST
75806: LIST
75807: IN
75808: NOT
75809: OR
75810: IFFALSE 75814
// exit ;
75812: GO 76672
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
75814: LD_ADDR_VAR 0 2
75818: PUSH
75819: LD_VAR 0 2
75823: PPUSH
75824: LD_INT 21
75826: PUSH
75827: LD_INT 3
75829: PUSH
75830: EMPTY
75831: LIST
75832: LIST
75833: PUSH
75834: LD_INT 24
75836: PUSH
75837: LD_INT 250
75839: PUSH
75840: EMPTY
75841: LIST
75842: LIST
75843: PUSH
75844: EMPTY
75845: LIST
75846: LIST
75847: PPUSH
75848: CALL_OW 72
75852: ST_TO_ADDR
// case class of 1 , 15 :
75853: LD_VAR 0 4
75857: PUSH
75858: LD_INT 1
75860: DOUBLE
75861: EQUAL
75862: IFTRUE 75872
75864: LD_INT 15
75866: DOUBLE
75867: EQUAL
75868: IFTRUE 75872
75870: GO 75957
75872: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
75873: LD_ADDR_VAR 0 8
75877: PUSH
75878: LD_VAR 0 2
75882: PPUSH
75883: LD_INT 2
75885: PUSH
75886: LD_INT 30
75888: PUSH
75889: LD_INT 32
75891: PUSH
75892: EMPTY
75893: LIST
75894: LIST
75895: PUSH
75896: LD_INT 30
75898: PUSH
75899: LD_INT 31
75901: PUSH
75902: EMPTY
75903: LIST
75904: LIST
75905: PUSH
75906: EMPTY
75907: LIST
75908: LIST
75909: LIST
75910: PPUSH
75911: CALL_OW 72
75915: PUSH
75916: LD_VAR 0 2
75920: PPUSH
75921: LD_INT 2
75923: PUSH
75924: LD_INT 30
75926: PUSH
75927: LD_INT 4
75929: PUSH
75930: EMPTY
75931: LIST
75932: LIST
75933: PUSH
75934: LD_INT 30
75936: PUSH
75937: LD_INT 5
75939: PUSH
75940: EMPTY
75941: LIST
75942: LIST
75943: PUSH
75944: EMPTY
75945: LIST
75946: LIST
75947: LIST
75948: PPUSH
75949: CALL_OW 72
75953: ADD
75954: ST_TO_ADDR
75955: GO 76203
75957: LD_INT 2
75959: DOUBLE
75960: EQUAL
75961: IFTRUE 75971
75963: LD_INT 16
75965: DOUBLE
75966: EQUAL
75967: IFTRUE 75971
75969: GO 76017
75971: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
75972: LD_ADDR_VAR 0 8
75976: PUSH
75977: LD_VAR 0 2
75981: PPUSH
75982: LD_INT 2
75984: PUSH
75985: LD_INT 30
75987: PUSH
75988: LD_INT 0
75990: PUSH
75991: EMPTY
75992: LIST
75993: LIST
75994: PUSH
75995: LD_INT 30
75997: PUSH
75998: LD_INT 1
76000: PUSH
76001: EMPTY
76002: LIST
76003: LIST
76004: PUSH
76005: EMPTY
76006: LIST
76007: LIST
76008: LIST
76009: PPUSH
76010: CALL_OW 72
76014: ST_TO_ADDR
76015: GO 76203
76017: LD_INT 3
76019: DOUBLE
76020: EQUAL
76021: IFTRUE 76025
76023: GO 76071
76025: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
76026: LD_ADDR_VAR 0 8
76030: PUSH
76031: LD_VAR 0 2
76035: PPUSH
76036: LD_INT 2
76038: PUSH
76039: LD_INT 30
76041: PUSH
76042: LD_INT 2
76044: PUSH
76045: EMPTY
76046: LIST
76047: LIST
76048: PUSH
76049: LD_INT 30
76051: PUSH
76052: LD_INT 3
76054: PUSH
76055: EMPTY
76056: LIST
76057: LIST
76058: PUSH
76059: EMPTY
76060: LIST
76061: LIST
76062: LIST
76063: PPUSH
76064: CALL_OW 72
76068: ST_TO_ADDR
76069: GO 76203
76071: LD_INT 4
76073: DOUBLE
76074: EQUAL
76075: IFTRUE 76079
76077: GO 76136
76079: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
76080: LD_ADDR_VAR 0 8
76084: PUSH
76085: LD_VAR 0 2
76089: PPUSH
76090: LD_INT 2
76092: PUSH
76093: LD_INT 30
76095: PUSH
76096: LD_INT 6
76098: PUSH
76099: EMPTY
76100: LIST
76101: LIST
76102: PUSH
76103: LD_INT 30
76105: PUSH
76106: LD_INT 7
76108: PUSH
76109: EMPTY
76110: LIST
76111: LIST
76112: PUSH
76113: LD_INT 30
76115: PUSH
76116: LD_INT 8
76118: PUSH
76119: EMPTY
76120: LIST
76121: LIST
76122: PUSH
76123: EMPTY
76124: LIST
76125: LIST
76126: LIST
76127: LIST
76128: PPUSH
76129: CALL_OW 72
76133: ST_TO_ADDR
76134: GO 76203
76136: LD_INT 5
76138: DOUBLE
76139: EQUAL
76140: IFTRUE 76156
76142: LD_INT 8
76144: DOUBLE
76145: EQUAL
76146: IFTRUE 76156
76148: LD_INT 9
76150: DOUBLE
76151: EQUAL
76152: IFTRUE 76156
76154: GO 76202
76156: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
76157: LD_ADDR_VAR 0 8
76161: PUSH
76162: LD_VAR 0 2
76166: PPUSH
76167: LD_INT 2
76169: PUSH
76170: LD_INT 30
76172: PUSH
76173: LD_INT 4
76175: PUSH
76176: EMPTY
76177: LIST
76178: LIST
76179: PUSH
76180: LD_INT 30
76182: PUSH
76183: LD_INT 5
76185: PUSH
76186: EMPTY
76187: LIST
76188: LIST
76189: PUSH
76190: EMPTY
76191: LIST
76192: LIST
76193: LIST
76194: PPUSH
76195: CALL_OW 72
76199: ST_TO_ADDR
76200: GO 76203
76202: POP
// if not tmp then
76203: LD_VAR 0 8
76207: NOT
76208: IFFALSE 76212
// exit ;
76210: GO 76672
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
76212: LD_VAR 0 4
76216: PUSH
76217: LD_INT 1
76219: PUSH
76220: LD_INT 15
76222: PUSH
76223: EMPTY
76224: LIST
76225: LIST
76226: IN
76227: PUSH
76228: LD_EXP 32
76232: PUSH
76233: LD_VAR 0 1
76237: ARRAY
76238: AND
76239: IFFALSE 76395
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
76241: LD_ADDR_VAR 0 9
76245: PUSH
76246: LD_EXP 32
76250: PUSH
76251: LD_VAR 0 1
76255: ARRAY
76256: PUSH
76257: LD_INT 1
76259: ARRAY
76260: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
76261: LD_VAR 0 9
76265: PUSH
76266: LD_EXP 33
76270: PUSH
76271: LD_VAR 0 1
76275: ARRAY
76276: IN
76277: NOT
76278: IFFALSE 76393
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
76280: LD_ADDR_EXP 33
76284: PUSH
76285: LD_EXP 33
76289: PPUSH
76290: LD_VAR 0 1
76294: PUSH
76295: LD_EXP 33
76299: PUSH
76300: LD_VAR 0 1
76304: ARRAY
76305: PUSH
76306: LD_INT 1
76308: PLUS
76309: PUSH
76310: EMPTY
76311: LIST
76312: LIST
76313: PPUSH
76314: LD_VAR 0 9
76318: PPUSH
76319: CALL 16077 0 3
76323: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
76324: LD_ADDR_EXP 32
76328: PUSH
76329: LD_EXP 32
76333: PPUSH
76334: LD_VAR 0 1
76338: PPUSH
76339: LD_EXP 32
76343: PUSH
76344: LD_VAR 0 1
76348: ARRAY
76349: PUSH
76350: LD_VAR 0 9
76354: DIFF
76355: PPUSH
76356: CALL_OW 1
76360: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
76361: LD_VAR 0 3
76365: PPUSH
76366: LD_EXP 33
76370: PUSH
76371: LD_VAR 0 1
76375: ARRAY
76376: PUSH
76377: LD_EXP 33
76381: PUSH
76382: LD_VAR 0 1
76386: ARRAY
76387: ARRAY
76388: PPUSH
76389: CALL_OW 120
// end ; exit ;
76393: GO 76672
// end ; if tmp > 1 then
76395: LD_VAR 0 8
76399: PUSH
76400: LD_INT 1
76402: GREATER
76403: IFFALSE 76507
// for i = 2 to tmp do
76405: LD_ADDR_VAR 0 6
76409: PUSH
76410: DOUBLE
76411: LD_INT 2
76413: DEC
76414: ST_TO_ADDR
76415: LD_VAR 0 8
76419: PUSH
76420: FOR_TO
76421: IFFALSE 76505
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
76423: LD_VAR 0 8
76427: PUSH
76428: LD_VAR 0 6
76432: ARRAY
76433: PPUSH
76434: CALL_OW 461
76438: PUSH
76439: LD_INT 6
76441: EQUAL
76442: IFFALSE 76503
// begin x := tmp [ i ] ;
76444: LD_ADDR_VAR 0 9
76448: PUSH
76449: LD_VAR 0 8
76453: PUSH
76454: LD_VAR 0 6
76458: ARRAY
76459: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
76460: LD_ADDR_VAR 0 8
76464: PUSH
76465: LD_VAR 0 8
76469: PPUSH
76470: LD_VAR 0 6
76474: PPUSH
76475: CALL_OW 3
76479: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
76480: LD_ADDR_VAR 0 8
76484: PUSH
76485: LD_VAR 0 8
76489: PPUSH
76490: LD_INT 1
76492: PPUSH
76493: LD_VAR 0 9
76497: PPUSH
76498: CALL_OW 2
76502: ST_TO_ADDR
// end ;
76503: GO 76420
76505: POP
76506: POP
// for i in tmp do
76507: LD_ADDR_VAR 0 6
76511: PUSH
76512: LD_VAR 0 8
76516: PUSH
76517: FOR_IN
76518: IFFALSE 76545
// begin if IsNotFull ( i ) then
76520: LD_VAR 0 6
76524: PPUSH
76525: CALL 13299 0 1
76529: IFFALSE 76543
// begin j := i ;
76531: LD_ADDR_VAR 0 7
76535: PUSH
76536: LD_VAR 0 6
76540: ST_TO_ADDR
// break ;
76541: GO 76545
// end ; end ;
76543: GO 76517
76545: POP
76546: POP
// if j then
76547: LD_VAR 0 7
76551: IFFALSE 76569
// ComEnterUnit ( unit , j ) else
76553: LD_VAR 0 3
76557: PPUSH
76558: LD_VAR 0 7
76562: PPUSH
76563: CALL_OW 120
76567: GO 76672
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76569: LD_ADDR_VAR 0 10
76573: PUSH
76574: LD_VAR 0 2
76578: PPUSH
76579: LD_INT 2
76581: PUSH
76582: LD_INT 30
76584: PUSH
76585: LD_INT 0
76587: PUSH
76588: EMPTY
76589: LIST
76590: LIST
76591: PUSH
76592: LD_INT 30
76594: PUSH
76595: LD_INT 1
76597: PUSH
76598: EMPTY
76599: LIST
76600: LIST
76601: PUSH
76602: EMPTY
76603: LIST
76604: LIST
76605: LIST
76606: PPUSH
76607: CALL_OW 72
76611: ST_TO_ADDR
// if depot then
76612: LD_VAR 0 10
76616: IFFALSE 76672
// begin depot := NearestUnitToUnit ( depot , unit ) ;
76618: LD_ADDR_VAR 0 10
76622: PUSH
76623: LD_VAR 0 10
76627: PPUSH
76628: LD_VAR 0 3
76632: PPUSH
76633: CALL_OW 74
76637: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
76638: LD_VAR 0 3
76642: PPUSH
76643: LD_VAR 0 10
76647: PPUSH
76648: CALL_OW 296
76652: PUSH
76653: LD_INT 10
76655: GREATER
76656: IFFALSE 76672
// ComStandNearbyBuilding ( unit , depot ) ;
76658: LD_VAR 0 3
76662: PPUSH
76663: LD_VAR 0 10
76667: PPUSH
76668: CALL 12679 0 2
// end ; end ; end ;
76672: LD_VAR 0 5
76676: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
76677: LD_INT 0
76679: PPUSH
76680: PPUSH
76681: PPUSH
76682: PPUSH
// if not mc_bases then
76683: LD_EXP 23
76687: NOT
76688: IFFALSE 76692
// exit ;
76690: GO 76931
// for i = 1 to mc_bases do
76692: LD_ADDR_VAR 0 2
76696: PUSH
76697: DOUBLE
76698: LD_INT 1
76700: DEC
76701: ST_TO_ADDR
76702: LD_EXP 23
76706: PUSH
76707: FOR_TO
76708: IFFALSE 76929
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
76710: LD_ADDR_VAR 0 4
76714: PUSH
76715: LD_EXP 23
76719: PUSH
76720: LD_VAR 0 2
76724: ARRAY
76725: PPUSH
76726: LD_INT 21
76728: PUSH
76729: LD_INT 1
76731: PUSH
76732: EMPTY
76733: LIST
76734: LIST
76735: PPUSH
76736: CALL_OW 72
76740: PUSH
76741: LD_EXP 52
76745: PUSH
76746: LD_VAR 0 2
76750: ARRAY
76751: UNION
76752: ST_TO_ADDR
// if not tmp then
76753: LD_VAR 0 4
76757: NOT
76758: IFFALSE 76762
// continue ;
76760: GO 76707
// for j in tmp do
76762: LD_ADDR_VAR 0 3
76766: PUSH
76767: LD_VAR 0 4
76771: PUSH
76772: FOR_IN
76773: IFFALSE 76925
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
76775: LD_VAR 0 3
76779: PPUSH
76780: CALL_OW 110
76784: NOT
76785: PUSH
76786: LD_VAR 0 3
76790: PPUSH
76791: CALL_OW 314
76795: NOT
76796: AND
76797: PUSH
76798: LD_VAR 0 3
76802: PPUSH
76803: CALL_OW 311
76807: NOT
76808: AND
76809: PUSH
76810: LD_VAR 0 3
76814: PPUSH
76815: CALL_OW 310
76819: NOT
76820: AND
76821: PUSH
76822: LD_VAR 0 3
76826: PUSH
76827: LD_EXP 26
76831: PUSH
76832: LD_VAR 0 2
76836: ARRAY
76837: PUSH
76838: LD_INT 1
76840: ARRAY
76841: IN
76842: NOT
76843: AND
76844: PUSH
76845: LD_VAR 0 3
76849: PUSH
76850: LD_EXP 26
76854: PUSH
76855: LD_VAR 0 2
76859: ARRAY
76860: PUSH
76861: LD_INT 2
76863: ARRAY
76864: IN
76865: NOT
76866: AND
76867: PUSH
76868: LD_VAR 0 3
76872: PUSH
76873: LD_EXP 35
76877: PUSH
76878: LD_VAR 0 2
76882: ARRAY
76883: IN
76884: NOT
76885: AND
76886: IFFALSE 76923
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
76888: LD_VAR 0 2
76892: PPUSH
76893: LD_EXP 23
76897: PUSH
76898: LD_VAR 0 2
76902: ARRAY
76903: PPUSH
76904: LD_VAR 0 3
76908: PPUSH
76909: LD_VAR 0 3
76913: PPUSH
76914: CALL_OW 257
76918: PPUSH
76919: CALL 75737 0 4
// end ;
76923: GO 76772
76925: POP
76926: POP
// end ;
76927: GO 76707
76929: POP
76930: POP
// end ;
76931: LD_VAR 0 1
76935: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
76936: LD_INT 0
76938: PPUSH
76939: PPUSH
76940: PPUSH
76941: PPUSH
76942: PPUSH
76943: PPUSH
// if not mc_bases [ base ] then
76944: LD_EXP 23
76948: PUSH
76949: LD_VAR 0 1
76953: ARRAY
76954: NOT
76955: IFFALSE 76959
// exit ;
76957: GO 77160
// tmp := [ ] ;
76959: LD_ADDR_VAR 0 6
76963: PUSH
76964: EMPTY
76965: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
76966: LD_ADDR_VAR 0 7
76970: PUSH
76971: LD_VAR 0 3
76975: PPUSH
76976: LD_INT 0
76978: PPUSH
76979: CALL_OW 517
76983: ST_TO_ADDR
// if not list then
76984: LD_VAR 0 7
76988: NOT
76989: IFFALSE 76993
// exit ;
76991: GO 77160
// c := Count ( list [ 1 ] ) ;
76993: LD_ADDR_VAR 0 9
76997: PUSH
76998: LD_VAR 0 7
77002: PUSH
77003: LD_INT 1
77005: ARRAY
77006: PPUSH
77007: CALL 13217 0 1
77011: ST_TO_ADDR
// if amount > c then
77012: LD_VAR 0 2
77016: PUSH
77017: LD_VAR 0 9
77021: GREATER
77022: IFFALSE 77034
// amount := c ;
77024: LD_ADDR_VAR 0 2
77028: PUSH
77029: LD_VAR 0 9
77033: ST_TO_ADDR
// for i := 1 to amount do
77034: LD_ADDR_VAR 0 5
77038: PUSH
77039: DOUBLE
77040: LD_INT 1
77042: DEC
77043: ST_TO_ADDR
77044: LD_VAR 0 2
77048: PUSH
77049: FOR_TO
77050: IFFALSE 77108
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
77052: LD_ADDR_VAR 0 6
77056: PUSH
77057: LD_VAR 0 6
77061: PPUSH
77062: LD_VAR 0 5
77066: PPUSH
77067: LD_VAR 0 7
77071: PUSH
77072: LD_INT 1
77074: ARRAY
77075: PUSH
77076: LD_VAR 0 5
77080: ARRAY
77081: PUSH
77082: LD_VAR 0 7
77086: PUSH
77087: LD_INT 2
77089: ARRAY
77090: PUSH
77091: LD_VAR 0 5
77095: ARRAY
77096: PUSH
77097: EMPTY
77098: LIST
77099: LIST
77100: PPUSH
77101: CALL_OW 1
77105: ST_TO_ADDR
77106: GO 77049
77108: POP
77109: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
77110: LD_ADDR_EXP 36
77114: PUSH
77115: LD_EXP 36
77119: PPUSH
77120: LD_VAR 0 1
77124: PPUSH
77125: LD_VAR 0 6
77129: PPUSH
77130: CALL_OW 1
77134: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
77135: LD_ADDR_EXP 38
77139: PUSH
77140: LD_EXP 38
77144: PPUSH
77145: LD_VAR 0 1
77149: PPUSH
77150: LD_VAR 0 3
77154: PPUSH
77155: CALL_OW 1
77159: ST_TO_ADDR
// end ;
77160: LD_VAR 0 4
77164: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
77165: LD_INT 0
77167: PPUSH
// if not mc_bases [ base ] then
77168: LD_EXP 23
77172: PUSH
77173: LD_VAR 0 1
77177: ARRAY
77178: NOT
77179: IFFALSE 77183
// exit ;
77181: GO 77208
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
77183: LD_ADDR_EXP 28
77187: PUSH
77188: LD_EXP 28
77192: PPUSH
77193: LD_VAR 0 1
77197: PPUSH
77198: LD_VAR 0 2
77202: PPUSH
77203: CALL_OW 1
77207: ST_TO_ADDR
// end ;
77208: LD_VAR 0 3
77212: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
77213: LD_INT 0
77215: PPUSH
// if not mc_bases [ base ] then
77216: LD_EXP 23
77220: PUSH
77221: LD_VAR 0 1
77225: ARRAY
77226: NOT
77227: IFFALSE 77231
// exit ;
77229: GO 77268
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
77231: LD_ADDR_EXP 28
77235: PUSH
77236: LD_EXP 28
77240: PPUSH
77241: LD_VAR 0 1
77245: PPUSH
77246: LD_EXP 28
77250: PUSH
77251: LD_VAR 0 1
77255: ARRAY
77256: PUSH
77257: LD_VAR 0 2
77261: UNION
77262: PPUSH
77263: CALL_OW 1
77267: ST_TO_ADDR
// end ;
77268: LD_VAR 0 3
77272: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
77273: LD_INT 0
77275: PPUSH
// if not mc_bases [ base ] then
77276: LD_EXP 23
77280: PUSH
77281: LD_VAR 0 1
77285: ARRAY
77286: NOT
77287: IFFALSE 77291
// exit ;
77289: GO 77316
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
77291: LD_ADDR_EXP 44
77295: PUSH
77296: LD_EXP 44
77300: PPUSH
77301: LD_VAR 0 1
77305: PPUSH
77306: LD_VAR 0 2
77310: PPUSH
77311: CALL_OW 1
77315: ST_TO_ADDR
// end ;
77316: LD_VAR 0 3
77320: RET
// export function MC_InsertProduceList ( base , components ) ; begin
77321: LD_INT 0
77323: PPUSH
// if not mc_bases [ base ] then
77324: LD_EXP 23
77328: PUSH
77329: LD_VAR 0 1
77333: ARRAY
77334: NOT
77335: IFFALSE 77339
// exit ;
77337: GO 77376
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
77339: LD_ADDR_EXP 44
77343: PUSH
77344: LD_EXP 44
77348: PPUSH
77349: LD_VAR 0 1
77353: PPUSH
77354: LD_EXP 44
77358: PUSH
77359: LD_VAR 0 1
77363: ARRAY
77364: PUSH
77365: LD_VAR 0 2
77369: ADD
77370: PPUSH
77371: CALL_OW 1
77375: ST_TO_ADDR
// end ;
77376: LD_VAR 0 3
77380: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
77381: LD_INT 0
77383: PPUSH
// if not mc_bases [ base ] then
77384: LD_EXP 23
77388: PUSH
77389: LD_VAR 0 1
77393: ARRAY
77394: NOT
77395: IFFALSE 77399
// exit ;
77397: GO 77453
// mc_defender := Replace ( mc_defender , base , deflist ) ;
77399: LD_ADDR_EXP 45
77403: PUSH
77404: LD_EXP 45
77408: PPUSH
77409: LD_VAR 0 1
77413: PPUSH
77414: LD_VAR 0 2
77418: PPUSH
77419: CALL_OW 1
77423: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
77424: LD_ADDR_EXP 34
77428: PUSH
77429: LD_EXP 34
77433: PPUSH
77434: LD_VAR 0 1
77438: PPUSH
77439: LD_VAR 0 2
77443: PUSH
77444: LD_INT 0
77446: PLUS
77447: PPUSH
77448: CALL_OW 1
77452: ST_TO_ADDR
// end ;
77453: LD_VAR 0 3
77457: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
77458: LD_INT 0
77460: PPUSH
// if not mc_bases [ base ] then
77461: LD_EXP 23
77465: PUSH
77466: LD_VAR 0 1
77470: ARRAY
77471: NOT
77472: IFFALSE 77476
// exit ;
77474: GO 77501
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
77476: LD_ADDR_EXP 34
77480: PUSH
77481: LD_EXP 34
77485: PPUSH
77486: LD_VAR 0 1
77490: PPUSH
77491: LD_VAR 0 2
77495: PPUSH
77496: CALL_OW 1
77500: ST_TO_ADDR
// end ;
77501: LD_VAR 0 3
77505: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
77506: LD_INT 0
77508: PPUSH
77509: PPUSH
77510: PPUSH
77511: PPUSH
// if not mc_bases [ base ] then
77512: LD_EXP 23
77516: PUSH
77517: LD_VAR 0 1
77521: ARRAY
77522: NOT
77523: IFFALSE 77527
// exit ;
77525: GO 77592
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
77527: LD_ADDR_EXP 43
77531: PUSH
77532: LD_EXP 43
77536: PPUSH
77537: LD_VAR 0 1
77541: PUSH
77542: LD_EXP 43
77546: PUSH
77547: LD_VAR 0 1
77551: ARRAY
77552: PUSH
77553: LD_INT 1
77555: PLUS
77556: PUSH
77557: EMPTY
77558: LIST
77559: LIST
77560: PPUSH
77561: LD_VAR 0 1
77565: PUSH
77566: LD_VAR 0 2
77570: PUSH
77571: LD_VAR 0 3
77575: PUSH
77576: LD_VAR 0 4
77580: PUSH
77581: EMPTY
77582: LIST
77583: LIST
77584: LIST
77585: LIST
77586: PPUSH
77587: CALL 16077 0 3
77591: ST_TO_ADDR
// end ;
77592: LD_VAR 0 5
77596: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
77597: LD_INT 0
77599: PPUSH
// if not mc_bases [ base ] then
77600: LD_EXP 23
77604: PUSH
77605: LD_VAR 0 1
77609: ARRAY
77610: NOT
77611: IFFALSE 77615
// exit ;
77613: GO 77640
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
77615: LD_ADDR_EXP 60
77619: PUSH
77620: LD_EXP 60
77624: PPUSH
77625: LD_VAR 0 1
77629: PPUSH
77630: LD_VAR 0 2
77634: PPUSH
77635: CALL_OW 1
77639: ST_TO_ADDR
// end ;
77640: LD_VAR 0 3
77644: RET
// export function MC_GetMinesField ( base ) ; begin
77645: LD_INT 0
77647: PPUSH
// result := mc_mines [ base ] ;
77648: LD_ADDR_VAR 0 2
77652: PUSH
77653: LD_EXP 36
77657: PUSH
77658: LD_VAR 0 1
77662: ARRAY
77663: ST_TO_ADDR
// end ;
77664: LD_VAR 0 2
77668: RET
// export function MC_GetProduceList ( base ) ; begin
77669: LD_INT 0
77671: PPUSH
// result := mc_produce [ base ] ;
77672: LD_ADDR_VAR 0 2
77676: PUSH
77677: LD_EXP 44
77681: PUSH
77682: LD_VAR 0 1
77686: ARRAY
77687: ST_TO_ADDR
// end ;
77688: LD_VAR 0 2
77692: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
77693: LD_INT 0
77695: PPUSH
77696: PPUSH
// if not mc_bases then
77697: LD_EXP 23
77701: NOT
77702: IFFALSE 77706
// exit ;
77704: GO 77771
// if mc_bases [ base ] then
77706: LD_EXP 23
77710: PUSH
77711: LD_VAR 0 1
77715: ARRAY
77716: IFFALSE 77771
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
77718: LD_ADDR_VAR 0 3
77722: PUSH
77723: LD_EXP 23
77727: PUSH
77728: LD_VAR 0 1
77732: ARRAY
77733: PPUSH
77734: LD_INT 30
77736: PUSH
77737: LD_VAR 0 2
77741: PUSH
77742: EMPTY
77743: LIST
77744: LIST
77745: PPUSH
77746: CALL_OW 72
77750: ST_TO_ADDR
// if result then
77751: LD_VAR 0 3
77755: IFFALSE 77771
// result := result [ 1 ] ;
77757: LD_ADDR_VAR 0 3
77761: PUSH
77762: LD_VAR 0 3
77766: PUSH
77767: LD_INT 1
77769: ARRAY
77770: ST_TO_ADDR
// end ; end ;
77771: LD_VAR 0 3
77775: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
77776: LD_INT 0
77778: PPUSH
77779: PPUSH
// if not mc_bases then
77780: LD_EXP 23
77784: NOT
77785: IFFALSE 77789
// exit ;
77787: GO 77834
// if mc_bases [ base ] then
77789: LD_EXP 23
77793: PUSH
77794: LD_VAR 0 1
77798: ARRAY
77799: IFFALSE 77834
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
77801: LD_ADDR_VAR 0 3
77805: PUSH
77806: LD_EXP 23
77810: PUSH
77811: LD_VAR 0 1
77815: ARRAY
77816: PPUSH
77817: LD_INT 30
77819: PUSH
77820: LD_VAR 0 2
77824: PUSH
77825: EMPTY
77826: LIST
77827: LIST
77828: PPUSH
77829: CALL_OW 72
77833: ST_TO_ADDR
// end ;
77834: LD_VAR 0 3
77838: RET
// export function MC_SetTame ( base , area ) ; begin
77839: LD_INT 0
77841: PPUSH
// if not mc_bases or not base then
77842: LD_EXP 23
77846: NOT
77847: PUSH
77848: LD_VAR 0 1
77852: NOT
77853: OR
77854: IFFALSE 77858
// exit ;
77856: GO 77883
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
77858: LD_ADDR_EXP 51
77862: PUSH
77863: LD_EXP 51
77867: PPUSH
77868: LD_VAR 0 1
77872: PPUSH
77873: LD_VAR 0 2
77877: PPUSH
77878: CALL_OW 1
77882: ST_TO_ADDR
// end ;
77883: LD_VAR 0 3
77887: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
77888: LD_INT 0
77890: PPUSH
77891: PPUSH
// if not mc_bases or not base then
77892: LD_EXP 23
77896: NOT
77897: PUSH
77898: LD_VAR 0 1
77902: NOT
77903: OR
77904: IFFALSE 77908
// exit ;
77906: GO 78010
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
77908: LD_ADDR_VAR 0 4
77912: PUSH
77913: LD_EXP 23
77917: PUSH
77918: LD_VAR 0 1
77922: ARRAY
77923: PPUSH
77924: LD_INT 30
77926: PUSH
77927: LD_VAR 0 2
77931: PUSH
77932: EMPTY
77933: LIST
77934: LIST
77935: PPUSH
77936: CALL_OW 72
77940: ST_TO_ADDR
// if not tmp then
77941: LD_VAR 0 4
77945: NOT
77946: IFFALSE 77950
// exit ;
77948: GO 78010
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
77950: LD_ADDR_EXP 55
77954: PUSH
77955: LD_EXP 55
77959: PPUSH
77960: LD_VAR 0 1
77964: PPUSH
77965: LD_EXP 55
77969: PUSH
77970: LD_VAR 0 1
77974: ARRAY
77975: PPUSH
77976: LD_EXP 55
77980: PUSH
77981: LD_VAR 0 1
77985: ARRAY
77986: PUSH
77987: LD_INT 1
77989: PLUS
77990: PPUSH
77991: LD_VAR 0 4
77995: PUSH
77996: LD_INT 1
77998: ARRAY
77999: PPUSH
78000: CALL_OW 2
78004: PPUSH
78005: CALL_OW 1
78009: ST_TO_ADDR
// end ;
78010: LD_VAR 0 3
78014: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
78015: LD_INT 0
78017: PPUSH
78018: PPUSH
// if not mc_bases or not base or not kinds then
78019: LD_EXP 23
78023: NOT
78024: PUSH
78025: LD_VAR 0 1
78029: NOT
78030: OR
78031: PUSH
78032: LD_VAR 0 2
78036: NOT
78037: OR
78038: IFFALSE 78042
// exit ;
78040: GO 78103
// for i in kinds do
78042: LD_ADDR_VAR 0 4
78046: PUSH
78047: LD_VAR 0 2
78051: PUSH
78052: FOR_IN
78053: IFFALSE 78101
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
78055: LD_ADDR_EXP 57
78059: PUSH
78060: LD_EXP 57
78064: PPUSH
78065: LD_VAR 0 1
78069: PUSH
78070: LD_EXP 57
78074: PUSH
78075: LD_VAR 0 1
78079: ARRAY
78080: PUSH
78081: LD_INT 1
78083: PLUS
78084: PUSH
78085: EMPTY
78086: LIST
78087: LIST
78088: PPUSH
78089: LD_VAR 0 4
78093: PPUSH
78094: CALL 16077 0 3
78098: ST_TO_ADDR
78099: GO 78052
78101: POP
78102: POP
// end ;
78103: LD_VAR 0 3
78107: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
78108: LD_INT 0
78110: PPUSH
// if not mc_bases or not base or not areas then
78111: LD_EXP 23
78115: NOT
78116: PUSH
78117: LD_VAR 0 1
78121: NOT
78122: OR
78123: PUSH
78124: LD_VAR 0 2
78128: NOT
78129: OR
78130: IFFALSE 78134
// exit ;
78132: GO 78159
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
78134: LD_ADDR_EXP 41
78138: PUSH
78139: LD_EXP 41
78143: PPUSH
78144: LD_VAR 0 1
78148: PPUSH
78149: LD_VAR 0 2
78153: PPUSH
78154: CALL_OW 1
78158: ST_TO_ADDR
// end ;
78159: LD_VAR 0 3
78163: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
78164: LD_INT 0
78166: PPUSH
// if not mc_bases or not base or not teleports_exit then
78167: LD_EXP 23
78171: NOT
78172: PUSH
78173: LD_VAR 0 1
78177: NOT
78178: OR
78179: PUSH
78180: LD_VAR 0 2
78184: NOT
78185: OR
78186: IFFALSE 78190
// exit ;
78188: GO 78215
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
78190: LD_ADDR_EXP 58
78194: PUSH
78195: LD_EXP 58
78199: PPUSH
78200: LD_VAR 0 1
78204: PPUSH
78205: LD_VAR 0 2
78209: PPUSH
78210: CALL_OW 1
78214: ST_TO_ADDR
// end ;
78215: LD_VAR 0 3
78219: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
78220: LD_INT 0
78222: PPUSH
78223: PPUSH
78224: PPUSH
// if not mc_bases or not base or not ext_list then
78225: LD_EXP 23
78229: NOT
78230: PUSH
78231: LD_VAR 0 1
78235: NOT
78236: OR
78237: PUSH
78238: LD_VAR 0 5
78242: NOT
78243: OR
78244: IFFALSE 78248
// exit ;
78246: GO 78421
// tmp := GetFacExtXYD ( x , y , d ) ;
78248: LD_ADDR_VAR 0 8
78252: PUSH
78253: LD_VAR 0 2
78257: PPUSH
78258: LD_VAR 0 3
78262: PPUSH
78263: LD_VAR 0 4
78267: PPUSH
78268: CALL 46451 0 3
78272: ST_TO_ADDR
// if not tmp then
78273: LD_VAR 0 8
78277: NOT
78278: IFFALSE 78282
// exit ;
78280: GO 78421
// for i in tmp do
78282: LD_ADDR_VAR 0 7
78286: PUSH
78287: LD_VAR 0 8
78291: PUSH
78292: FOR_IN
78293: IFFALSE 78419
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
78295: LD_ADDR_EXP 28
78299: PUSH
78300: LD_EXP 28
78304: PPUSH
78305: LD_VAR 0 1
78309: PPUSH
78310: LD_EXP 28
78314: PUSH
78315: LD_VAR 0 1
78319: ARRAY
78320: PPUSH
78321: LD_EXP 28
78325: PUSH
78326: LD_VAR 0 1
78330: ARRAY
78331: PUSH
78332: LD_INT 1
78334: PLUS
78335: PPUSH
78336: LD_VAR 0 5
78340: PUSH
78341: LD_INT 1
78343: ARRAY
78344: PUSH
78345: LD_VAR 0 7
78349: PUSH
78350: LD_INT 1
78352: ARRAY
78353: PUSH
78354: LD_VAR 0 7
78358: PUSH
78359: LD_INT 2
78361: ARRAY
78362: PUSH
78363: LD_VAR 0 7
78367: PUSH
78368: LD_INT 3
78370: ARRAY
78371: PUSH
78372: EMPTY
78373: LIST
78374: LIST
78375: LIST
78376: LIST
78377: PPUSH
78378: CALL_OW 2
78382: PPUSH
78383: CALL_OW 1
78387: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
78388: LD_ADDR_VAR 0 5
78392: PUSH
78393: LD_VAR 0 5
78397: PPUSH
78398: LD_INT 1
78400: PPUSH
78401: CALL_OW 3
78405: ST_TO_ADDR
// if not ext_list then
78406: LD_VAR 0 5
78410: NOT
78411: IFFALSE 78417
// exit ;
78413: POP
78414: POP
78415: GO 78421
// end ;
78417: GO 78292
78419: POP
78420: POP
// end ;
78421: LD_VAR 0 6
78425: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
78426: LD_INT 0
78428: PPUSH
// if not mc_bases or not base or not weapon_list then
78429: LD_EXP 23
78433: NOT
78434: PUSH
78435: LD_VAR 0 1
78439: NOT
78440: OR
78441: PUSH
78442: LD_VAR 0 2
78446: NOT
78447: OR
78448: IFFALSE 78452
// exit ;
78450: GO 78477
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
78452: LD_ADDR_EXP 62
78456: PUSH
78457: LD_EXP 62
78461: PPUSH
78462: LD_VAR 0 1
78466: PPUSH
78467: LD_VAR 0 2
78471: PPUSH
78472: CALL_OW 1
78476: ST_TO_ADDR
// end ;
78477: LD_VAR 0 3
78481: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
78482: LD_INT 0
78484: PPUSH
// if not mc_bases or not base or not tech_list then
78485: LD_EXP 23
78489: NOT
78490: PUSH
78491: LD_VAR 0 1
78495: NOT
78496: OR
78497: PUSH
78498: LD_VAR 0 2
78502: NOT
78503: OR
78504: IFFALSE 78508
// exit ;
78506: GO 78533
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
78508: LD_ADDR_EXP 50
78512: PUSH
78513: LD_EXP 50
78517: PPUSH
78518: LD_VAR 0 1
78522: PPUSH
78523: LD_VAR 0 2
78527: PPUSH
78528: CALL_OW 1
78532: ST_TO_ADDR
// end ;
78533: LD_VAR 0 3
78537: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
78538: LD_INT 0
78540: PPUSH
// if not mc_bases or not parking_area or not base then
78541: LD_EXP 23
78545: NOT
78546: PUSH
78547: LD_VAR 0 2
78551: NOT
78552: OR
78553: PUSH
78554: LD_VAR 0 1
78558: NOT
78559: OR
78560: IFFALSE 78564
// exit ;
78562: GO 78589
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
78564: LD_ADDR_EXP 47
78568: PUSH
78569: LD_EXP 47
78573: PPUSH
78574: LD_VAR 0 1
78578: PPUSH
78579: LD_VAR 0 2
78583: PPUSH
78584: CALL_OW 1
78588: ST_TO_ADDR
// end ;
78589: LD_VAR 0 3
78593: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
78594: LD_INT 0
78596: PPUSH
// if not mc_bases or not base or not scan_area then
78597: LD_EXP 23
78601: NOT
78602: PUSH
78603: LD_VAR 0 1
78607: NOT
78608: OR
78609: PUSH
78610: LD_VAR 0 2
78614: NOT
78615: OR
78616: IFFALSE 78620
// exit ;
78618: GO 78645
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
78620: LD_ADDR_EXP 48
78624: PUSH
78625: LD_EXP 48
78629: PPUSH
78630: LD_VAR 0 1
78634: PPUSH
78635: LD_VAR 0 2
78639: PPUSH
78640: CALL_OW 1
78644: ST_TO_ADDR
// end ;
78645: LD_VAR 0 3
78649: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
78650: LD_INT 0
78652: PPUSH
78653: PPUSH
// if not mc_bases or not base then
78654: LD_EXP 23
78658: NOT
78659: PUSH
78660: LD_VAR 0 1
78664: NOT
78665: OR
78666: IFFALSE 78670
// exit ;
78668: GO 78734
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
78670: LD_ADDR_VAR 0 3
78674: PUSH
78675: LD_INT 1
78677: PUSH
78678: LD_INT 2
78680: PUSH
78681: LD_INT 3
78683: PUSH
78684: LD_INT 4
78686: PUSH
78687: LD_INT 11
78689: PUSH
78690: EMPTY
78691: LIST
78692: LIST
78693: LIST
78694: LIST
78695: LIST
78696: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
78697: LD_ADDR_EXP 50
78701: PUSH
78702: LD_EXP 50
78706: PPUSH
78707: LD_VAR 0 1
78711: PPUSH
78712: LD_EXP 50
78716: PUSH
78717: LD_VAR 0 1
78721: ARRAY
78722: PUSH
78723: LD_VAR 0 3
78727: DIFF
78728: PPUSH
78729: CALL_OW 1
78733: ST_TO_ADDR
// end ;
78734: LD_VAR 0 2
78738: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
78739: LD_INT 0
78741: PPUSH
// result := mc_vehicles [ base ] ;
78742: LD_ADDR_VAR 0 3
78746: PUSH
78747: LD_EXP 42
78751: PUSH
78752: LD_VAR 0 1
78756: ARRAY
78757: ST_TO_ADDR
// if onlyCombat then
78758: LD_VAR 0 2
78762: IFFALSE 78934
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
78764: LD_ADDR_VAR 0 3
78768: PUSH
78769: LD_VAR 0 3
78773: PUSH
78774: LD_VAR 0 3
78778: PPUSH
78779: LD_INT 2
78781: PUSH
78782: LD_INT 34
78784: PUSH
78785: LD_INT 12
78787: PUSH
78788: EMPTY
78789: LIST
78790: LIST
78791: PUSH
78792: LD_INT 34
78794: PUSH
78795: LD_INT 51
78797: PUSH
78798: EMPTY
78799: LIST
78800: LIST
78801: PUSH
78802: LD_INT 34
78804: PUSH
78805: LD_INT 89
78807: PUSH
78808: EMPTY
78809: LIST
78810: LIST
78811: PUSH
78812: LD_INT 34
78814: PUSH
78815: LD_INT 32
78817: PUSH
78818: EMPTY
78819: LIST
78820: LIST
78821: PUSH
78822: LD_INT 34
78824: PUSH
78825: LD_INT 13
78827: PUSH
78828: EMPTY
78829: LIST
78830: LIST
78831: PUSH
78832: LD_INT 34
78834: PUSH
78835: LD_INT 52
78837: PUSH
78838: EMPTY
78839: LIST
78840: LIST
78841: PUSH
78842: LD_INT 34
78844: PUSH
78845: LD_INT 88
78847: PUSH
78848: EMPTY
78849: LIST
78850: LIST
78851: PUSH
78852: LD_INT 34
78854: PUSH
78855: LD_INT 14
78857: PUSH
78858: EMPTY
78859: LIST
78860: LIST
78861: PUSH
78862: LD_INT 34
78864: PUSH
78865: LD_INT 53
78867: PUSH
78868: EMPTY
78869: LIST
78870: LIST
78871: PUSH
78872: LD_INT 34
78874: PUSH
78875: LD_INT 98
78877: PUSH
78878: EMPTY
78879: LIST
78880: LIST
78881: PUSH
78882: LD_INT 34
78884: PUSH
78885: LD_INT 31
78887: PUSH
78888: EMPTY
78889: LIST
78890: LIST
78891: PUSH
78892: LD_INT 34
78894: PUSH
78895: LD_INT 48
78897: PUSH
78898: EMPTY
78899: LIST
78900: LIST
78901: PUSH
78902: LD_INT 34
78904: PUSH
78905: LD_INT 8
78907: PUSH
78908: EMPTY
78909: LIST
78910: LIST
78911: PUSH
78912: EMPTY
78913: LIST
78914: LIST
78915: LIST
78916: LIST
78917: LIST
78918: LIST
78919: LIST
78920: LIST
78921: LIST
78922: LIST
78923: LIST
78924: LIST
78925: LIST
78926: LIST
78927: PPUSH
78928: CALL_OW 72
78932: DIFF
78933: ST_TO_ADDR
// end ; end_of_file
78934: LD_VAR 0 3
78938: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
78939: LD_INT 0
78941: PPUSH
78942: PPUSH
78943: PPUSH
// if not mc_bases or not skirmish then
78944: LD_EXP 23
78948: NOT
78949: PUSH
78950: LD_EXP 21
78954: NOT
78955: OR
78956: IFFALSE 78960
// exit ;
78958: GO 79125
// for i = 1 to mc_bases do
78960: LD_ADDR_VAR 0 4
78964: PUSH
78965: DOUBLE
78966: LD_INT 1
78968: DEC
78969: ST_TO_ADDR
78970: LD_EXP 23
78974: PUSH
78975: FOR_TO
78976: IFFALSE 79123
// begin if sci in mc_bases [ i ] then
78978: LD_VAR 0 2
78982: PUSH
78983: LD_EXP 23
78987: PUSH
78988: LD_VAR 0 4
78992: ARRAY
78993: IN
78994: IFFALSE 79121
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
78996: LD_ADDR_EXP 52
79000: PUSH
79001: LD_EXP 52
79005: PPUSH
79006: LD_VAR 0 4
79010: PUSH
79011: LD_EXP 52
79015: PUSH
79016: LD_VAR 0 4
79020: ARRAY
79021: PUSH
79022: LD_INT 1
79024: PLUS
79025: PUSH
79026: EMPTY
79027: LIST
79028: LIST
79029: PPUSH
79030: LD_VAR 0 1
79034: PPUSH
79035: CALL 16077 0 3
79039: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
79040: LD_ADDR_VAR 0 5
79044: PUSH
79045: LD_EXP 23
79049: PUSH
79050: LD_VAR 0 4
79054: ARRAY
79055: PPUSH
79056: LD_INT 2
79058: PUSH
79059: LD_INT 30
79061: PUSH
79062: LD_INT 0
79064: PUSH
79065: EMPTY
79066: LIST
79067: LIST
79068: PUSH
79069: LD_INT 30
79071: PUSH
79072: LD_INT 1
79074: PUSH
79075: EMPTY
79076: LIST
79077: LIST
79078: PUSH
79079: EMPTY
79080: LIST
79081: LIST
79082: LIST
79083: PPUSH
79084: CALL_OW 72
79088: PPUSH
79089: LD_VAR 0 1
79093: PPUSH
79094: CALL_OW 74
79098: ST_TO_ADDR
// if tmp then
79099: LD_VAR 0 5
79103: IFFALSE 79119
// ComStandNearbyBuilding ( ape , tmp ) ;
79105: LD_VAR 0 1
79109: PPUSH
79110: LD_VAR 0 5
79114: PPUSH
79115: CALL 12679 0 2
// break ;
79119: GO 79123
// end ; end ;
79121: GO 78975
79123: POP
79124: POP
// end ;
79125: LD_VAR 0 3
79129: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
79130: LD_INT 0
79132: PPUSH
79133: PPUSH
79134: PPUSH
// if not mc_bases or not skirmish then
79135: LD_EXP 23
79139: NOT
79140: PUSH
79141: LD_EXP 21
79145: NOT
79146: OR
79147: IFFALSE 79151
// exit ;
79149: GO 79240
// for i = 1 to mc_bases do
79151: LD_ADDR_VAR 0 4
79155: PUSH
79156: DOUBLE
79157: LD_INT 1
79159: DEC
79160: ST_TO_ADDR
79161: LD_EXP 23
79165: PUSH
79166: FOR_TO
79167: IFFALSE 79238
// begin if building in mc_busy_turret_list [ i ] then
79169: LD_VAR 0 1
79173: PUSH
79174: LD_EXP 33
79178: PUSH
79179: LD_VAR 0 4
79183: ARRAY
79184: IN
79185: IFFALSE 79236
// begin tmp := mc_busy_turret_list [ i ] diff building ;
79187: LD_ADDR_VAR 0 5
79191: PUSH
79192: LD_EXP 33
79196: PUSH
79197: LD_VAR 0 4
79201: ARRAY
79202: PUSH
79203: LD_VAR 0 1
79207: DIFF
79208: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
79209: LD_ADDR_EXP 33
79213: PUSH
79214: LD_EXP 33
79218: PPUSH
79219: LD_VAR 0 4
79223: PPUSH
79224: LD_VAR 0 5
79228: PPUSH
79229: CALL_OW 1
79233: ST_TO_ADDR
// break ;
79234: GO 79238
// end ; end ;
79236: GO 79166
79238: POP
79239: POP
// end ;
79240: LD_VAR 0 3
79244: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
79245: LD_INT 0
79247: PPUSH
79248: PPUSH
79249: PPUSH
// if not mc_bases or not skirmish then
79250: LD_EXP 23
79254: NOT
79255: PUSH
79256: LD_EXP 21
79260: NOT
79261: OR
79262: IFFALSE 79266
// exit ;
79264: GO 79465
// for i = 1 to mc_bases do
79266: LD_ADDR_VAR 0 5
79270: PUSH
79271: DOUBLE
79272: LD_INT 1
79274: DEC
79275: ST_TO_ADDR
79276: LD_EXP 23
79280: PUSH
79281: FOR_TO
79282: IFFALSE 79463
// if building in mc_bases [ i ] then
79284: LD_VAR 0 1
79288: PUSH
79289: LD_EXP 23
79293: PUSH
79294: LD_VAR 0 5
79298: ARRAY
79299: IN
79300: IFFALSE 79461
// begin tmp := mc_bases [ i ] diff building ;
79302: LD_ADDR_VAR 0 6
79306: PUSH
79307: LD_EXP 23
79311: PUSH
79312: LD_VAR 0 5
79316: ARRAY
79317: PUSH
79318: LD_VAR 0 1
79322: DIFF
79323: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
79324: LD_ADDR_EXP 23
79328: PUSH
79329: LD_EXP 23
79333: PPUSH
79334: LD_VAR 0 5
79338: PPUSH
79339: LD_VAR 0 6
79343: PPUSH
79344: CALL_OW 1
79348: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
79349: LD_VAR 0 1
79353: PUSH
79354: LD_EXP 31
79358: PUSH
79359: LD_VAR 0 5
79363: ARRAY
79364: IN
79365: IFFALSE 79404
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
79367: LD_ADDR_EXP 31
79371: PUSH
79372: LD_EXP 31
79376: PPUSH
79377: LD_VAR 0 5
79381: PPUSH
79382: LD_EXP 31
79386: PUSH
79387: LD_VAR 0 5
79391: ARRAY
79392: PUSH
79393: LD_VAR 0 1
79397: DIFF
79398: PPUSH
79399: CALL_OW 1
79403: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
79404: LD_VAR 0 1
79408: PUSH
79409: LD_EXP 32
79413: PUSH
79414: LD_VAR 0 5
79418: ARRAY
79419: IN
79420: IFFALSE 79459
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
79422: LD_ADDR_EXP 32
79426: PUSH
79427: LD_EXP 32
79431: PPUSH
79432: LD_VAR 0 5
79436: PPUSH
79437: LD_EXP 32
79441: PUSH
79442: LD_VAR 0 5
79446: ARRAY
79447: PUSH
79448: LD_VAR 0 1
79452: DIFF
79453: PPUSH
79454: CALL_OW 1
79458: ST_TO_ADDR
// break ;
79459: GO 79463
// end ;
79461: GO 79281
79463: POP
79464: POP
// end ;
79465: LD_VAR 0 4
79469: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
79470: LD_INT 0
79472: PPUSH
79473: PPUSH
79474: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
79475: LD_EXP 23
79479: NOT
79480: PUSH
79481: LD_EXP 21
79485: NOT
79486: OR
79487: PUSH
79488: LD_VAR 0 3
79492: PUSH
79493: LD_EXP 49
79497: IN
79498: NOT
79499: OR
79500: IFFALSE 79504
// exit ;
79502: GO 79627
// for i = 1 to mc_vehicles do
79504: LD_ADDR_VAR 0 6
79508: PUSH
79509: DOUBLE
79510: LD_INT 1
79512: DEC
79513: ST_TO_ADDR
79514: LD_EXP 42
79518: PUSH
79519: FOR_TO
79520: IFFALSE 79625
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
79522: LD_VAR 0 2
79526: PUSH
79527: LD_EXP 42
79531: PUSH
79532: LD_VAR 0 6
79536: ARRAY
79537: IN
79538: PUSH
79539: LD_VAR 0 1
79543: PUSH
79544: LD_EXP 42
79548: PUSH
79549: LD_VAR 0 6
79553: ARRAY
79554: IN
79555: OR
79556: IFFALSE 79623
// begin tmp := mc_vehicles [ i ] diff old ;
79558: LD_ADDR_VAR 0 7
79562: PUSH
79563: LD_EXP 42
79567: PUSH
79568: LD_VAR 0 6
79572: ARRAY
79573: PUSH
79574: LD_VAR 0 2
79578: DIFF
79579: ST_TO_ADDR
// tmp := tmp diff new ;
79580: LD_ADDR_VAR 0 7
79584: PUSH
79585: LD_VAR 0 7
79589: PUSH
79590: LD_VAR 0 1
79594: DIFF
79595: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
79596: LD_ADDR_EXP 42
79600: PUSH
79601: LD_EXP 42
79605: PPUSH
79606: LD_VAR 0 6
79610: PPUSH
79611: LD_VAR 0 7
79615: PPUSH
79616: CALL_OW 1
79620: ST_TO_ADDR
// break ;
79621: GO 79625
// end ;
79623: GO 79519
79625: POP
79626: POP
// end ;
79627: LD_VAR 0 5
79631: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
79632: LD_INT 0
79634: PPUSH
79635: PPUSH
79636: PPUSH
79637: PPUSH
// if not mc_bases or not skirmish then
79638: LD_EXP 23
79642: NOT
79643: PUSH
79644: LD_EXP 21
79648: NOT
79649: OR
79650: IFFALSE 79654
// exit ;
79652: GO 80074
// repeat wait ( 0 0$1 ) ;
79654: LD_INT 35
79656: PPUSH
79657: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
79661: LD_EXP 67
79665: NOT
79666: IFFALSE 79654
// mc_block_vehicle_constructed_thread := true ;
79668: LD_ADDR_EXP 67
79672: PUSH
79673: LD_INT 1
79675: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
79676: LD_ADDR_VAR 0 5
79680: PUSH
79681: LD_VAR 0 1
79685: PPUSH
79686: CALL_OW 255
79690: ST_TO_ADDR
// for i = 1 to mc_bases do
79691: LD_ADDR_VAR 0 4
79695: PUSH
79696: DOUBLE
79697: LD_INT 1
79699: DEC
79700: ST_TO_ADDR
79701: LD_EXP 23
79705: PUSH
79706: FOR_TO
79707: IFFALSE 80064
// begin if factory in mc_bases [ i ] then
79709: LD_VAR 0 2
79713: PUSH
79714: LD_EXP 23
79718: PUSH
79719: LD_VAR 0 4
79723: ARRAY
79724: IN
79725: IFFALSE 80062
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
79727: LD_EXP 45
79731: PUSH
79732: LD_VAR 0 4
79736: ARRAY
79737: PUSH
79738: LD_EXP 34
79742: PUSH
79743: LD_VAR 0 4
79747: ARRAY
79748: LESS
79749: PUSH
79750: LD_VAR 0 1
79754: PPUSH
79755: CALL_OW 264
79759: PUSH
79760: LD_INT 31
79762: PUSH
79763: LD_INT 32
79765: PUSH
79766: LD_INT 51
79768: PUSH
79769: LD_INT 89
79771: PUSH
79772: LD_INT 12
79774: PUSH
79775: LD_INT 30
79777: PUSH
79778: LD_INT 98
79780: PUSH
79781: LD_INT 11
79783: PUSH
79784: LD_INT 53
79786: PUSH
79787: LD_INT 14
79789: PUSH
79790: LD_INT 91
79792: PUSH
79793: LD_INT 29
79795: PUSH
79796: LD_INT 99
79798: PUSH
79799: LD_INT 13
79801: PUSH
79802: LD_INT 52
79804: PUSH
79805: LD_INT 88
79807: PUSH
79808: LD_INT 48
79810: PUSH
79811: LD_INT 8
79813: PUSH
79814: EMPTY
79815: LIST
79816: LIST
79817: LIST
79818: LIST
79819: LIST
79820: LIST
79821: LIST
79822: LIST
79823: LIST
79824: LIST
79825: LIST
79826: LIST
79827: LIST
79828: LIST
79829: LIST
79830: LIST
79831: LIST
79832: LIST
79833: IN
79834: NOT
79835: AND
79836: IFFALSE 79884
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
79838: LD_ADDR_EXP 45
79842: PUSH
79843: LD_EXP 45
79847: PPUSH
79848: LD_VAR 0 4
79852: PUSH
79853: LD_EXP 45
79857: PUSH
79858: LD_VAR 0 4
79862: ARRAY
79863: PUSH
79864: LD_INT 1
79866: PLUS
79867: PUSH
79868: EMPTY
79869: LIST
79870: LIST
79871: PPUSH
79872: LD_VAR 0 1
79876: PPUSH
79877: CALL 16077 0 3
79881: ST_TO_ADDR
79882: GO 79928
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
79884: LD_ADDR_EXP 42
79888: PUSH
79889: LD_EXP 42
79893: PPUSH
79894: LD_VAR 0 4
79898: PUSH
79899: LD_EXP 42
79903: PUSH
79904: LD_VAR 0 4
79908: ARRAY
79909: PUSH
79910: LD_INT 1
79912: PLUS
79913: PUSH
79914: EMPTY
79915: LIST
79916: LIST
79917: PPUSH
79918: LD_VAR 0 1
79922: PPUSH
79923: CALL 16077 0 3
79927: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
79928: LD_ADDR_EXP 67
79932: PUSH
79933: LD_INT 0
79935: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
79936: LD_VAR 0 1
79940: PPUSH
79941: CALL_OW 263
79945: PUSH
79946: LD_INT 2
79948: EQUAL
79949: IFFALSE 79978
// begin repeat wait ( 0 0$3 ) ;
79951: LD_INT 105
79953: PPUSH
79954: CALL_OW 67
// Connect ( vehicle ) ;
79958: LD_VAR 0 1
79962: PPUSH
79963: CALL 19423 0 1
// until IsControledBy ( vehicle ) ;
79967: LD_VAR 0 1
79971: PPUSH
79972: CALL_OW 312
79976: IFFALSE 79951
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
79978: LD_VAR 0 1
79982: PPUSH
79983: LD_EXP 47
79987: PUSH
79988: LD_VAR 0 4
79992: ARRAY
79993: PPUSH
79994: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
79998: LD_VAR 0 1
80002: PPUSH
80003: CALL_OW 263
80007: PUSH
80008: LD_INT 1
80010: NONEQUAL
80011: IFFALSE 80015
// break ;
80013: GO 80064
// repeat wait ( 0 0$1 ) ;
80015: LD_INT 35
80017: PPUSH
80018: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
80022: LD_VAR 0 1
80026: PPUSH
80027: LD_EXP 47
80031: PUSH
80032: LD_VAR 0 4
80036: ARRAY
80037: PPUSH
80038: CALL_OW 308
80042: IFFALSE 80015
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
80044: LD_VAR 0 1
80048: PPUSH
80049: CALL_OW 311
80053: PPUSH
80054: CALL_OW 121
// exit ;
80058: POP
80059: POP
80060: GO 80074
// end ; end ;
80062: GO 79706
80064: POP
80065: POP
// mc_block_vehicle_constructed_thread := false ;
80066: LD_ADDR_EXP 67
80070: PUSH
80071: LD_INT 0
80073: ST_TO_ADDR
// end ;
80074: LD_VAR 0 3
80078: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
80079: LD_INT 0
80081: PPUSH
80082: PPUSH
80083: PPUSH
80084: PPUSH
// if not mc_bases or not skirmish then
80085: LD_EXP 23
80089: NOT
80090: PUSH
80091: LD_EXP 21
80095: NOT
80096: OR
80097: IFFALSE 80101
// exit ;
80099: GO 80454
// repeat wait ( 0 0$1 ) ;
80101: LD_INT 35
80103: PPUSH
80104: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
80108: LD_VAR 0 2
80112: PPUSH
80113: LD_VAR 0 3
80117: PPUSH
80118: CALL_OW 284
80122: IFFALSE 80101
// if GetResourceTypeXY ( x , y ) = mat_artefact then
80124: LD_VAR 0 2
80128: PPUSH
80129: LD_VAR 0 3
80133: PPUSH
80134: CALL_OW 283
80138: PUSH
80139: LD_INT 4
80141: EQUAL
80142: IFFALSE 80146
// exit ;
80144: GO 80454
// for i = 1 to mc_bases do
80146: LD_ADDR_VAR 0 7
80150: PUSH
80151: DOUBLE
80152: LD_INT 1
80154: DEC
80155: ST_TO_ADDR
80156: LD_EXP 23
80160: PUSH
80161: FOR_TO
80162: IFFALSE 80452
// begin if mc_crates_area [ i ] then
80164: LD_EXP 41
80168: PUSH
80169: LD_VAR 0 7
80173: ARRAY
80174: IFFALSE 80285
// for j in mc_crates_area [ i ] do
80176: LD_ADDR_VAR 0 8
80180: PUSH
80181: LD_EXP 41
80185: PUSH
80186: LD_VAR 0 7
80190: ARRAY
80191: PUSH
80192: FOR_IN
80193: IFFALSE 80283
// if InArea ( x , y , j ) then
80195: LD_VAR 0 2
80199: PPUSH
80200: LD_VAR 0 3
80204: PPUSH
80205: LD_VAR 0 8
80209: PPUSH
80210: CALL_OW 309
80214: IFFALSE 80281
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
80216: LD_ADDR_EXP 39
80220: PUSH
80221: LD_EXP 39
80225: PPUSH
80226: LD_VAR 0 7
80230: PUSH
80231: LD_EXP 39
80235: PUSH
80236: LD_VAR 0 7
80240: ARRAY
80241: PUSH
80242: LD_INT 1
80244: PLUS
80245: PUSH
80246: EMPTY
80247: LIST
80248: LIST
80249: PPUSH
80250: LD_VAR 0 4
80254: PUSH
80255: LD_VAR 0 2
80259: PUSH
80260: LD_VAR 0 3
80264: PUSH
80265: EMPTY
80266: LIST
80267: LIST
80268: LIST
80269: PPUSH
80270: CALL 16077 0 3
80274: ST_TO_ADDR
// exit ;
80275: POP
80276: POP
80277: POP
80278: POP
80279: GO 80454
// end ;
80281: GO 80192
80283: POP
80284: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80285: LD_ADDR_VAR 0 9
80289: PUSH
80290: LD_EXP 23
80294: PUSH
80295: LD_VAR 0 7
80299: ARRAY
80300: PPUSH
80301: LD_INT 2
80303: PUSH
80304: LD_INT 30
80306: PUSH
80307: LD_INT 0
80309: PUSH
80310: EMPTY
80311: LIST
80312: LIST
80313: PUSH
80314: LD_INT 30
80316: PUSH
80317: LD_INT 1
80319: PUSH
80320: EMPTY
80321: LIST
80322: LIST
80323: PUSH
80324: EMPTY
80325: LIST
80326: LIST
80327: LIST
80328: PPUSH
80329: CALL_OW 72
80333: ST_TO_ADDR
// if not depot then
80334: LD_VAR 0 9
80338: NOT
80339: IFFALSE 80343
// continue ;
80341: GO 80161
// for j in depot do
80343: LD_ADDR_VAR 0 8
80347: PUSH
80348: LD_VAR 0 9
80352: PUSH
80353: FOR_IN
80354: IFFALSE 80448
// if GetDistUnitXY ( j , x , y ) < 30 then
80356: LD_VAR 0 8
80360: PPUSH
80361: LD_VAR 0 2
80365: PPUSH
80366: LD_VAR 0 3
80370: PPUSH
80371: CALL_OW 297
80375: PUSH
80376: LD_INT 30
80378: LESS
80379: IFFALSE 80446
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
80381: LD_ADDR_EXP 39
80385: PUSH
80386: LD_EXP 39
80390: PPUSH
80391: LD_VAR 0 7
80395: PUSH
80396: LD_EXP 39
80400: PUSH
80401: LD_VAR 0 7
80405: ARRAY
80406: PUSH
80407: LD_INT 1
80409: PLUS
80410: PUSH
80411: EMPTY
80412: LIST
80413: LIST
80414: PPUSH
80415: LD_VAR 0 4
80419: PUSH
80420: LD_VAR 0 2
80424: PUSH
80425: LD_VAR 0 3
80429: PUSH
80430: EMPTY
80431: LIST
80432: LIST
80433: LIST
80434: PPUSH
80435: CALL 16077 0 3
80439: ST_TO_ADDR
// exit ;
80440: POP
80441: POP
80442: POP
80443: POP
80444: GO 80454
// end ;
80446: GO 80353
80448: POP
80449: POP
// end ;
80450: GO 80161
80452: POP
80453: POP
// end ;
80454: LD_VAR 0 6
80458: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
80459: LD_INT 0
80461: PPUSH
80462: PPUSH
80463: PPUSH
80464: PPUSH
// if not mc_bases or not skirmish then
80465: LD_EXP 23
80469: NOT
80470: PUSH
80471: LD_EXP 21
80475: NOT
80476: OR
80477: IFFALSE 80481
// exit ;
80479: GO 80758
// side := GetSide ( lab ) ;
80481: LD_ADDR_VAR 0 4
80485: PUSH
80486: LD_VAR 0 2
80490: PPUSH
80491: CALL_OW 255
80495: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
80496: LD_VAR 0 4
80500: PUSH
80501: LD_EXP 49
80505: IN
80506: NOT
80507: PUSH
80508: LD_EXP 50
80512: NOT
80513: OR
80514: PUSH
80515: LD_EXP 23
80519: NOT
80520: OR
80521: IFFALSE 80525
// exit ;
80523: GO 80758
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
80525: LD_ADDR_EXP 50
80529: PUSH
80530: LD_EXP 50
80534: PPUSH
80535: LD_VAR 0 4
80539: PPUSH
80540: LD_EXP 50
80544: PUSH
80545: LD_VAR 0 4
80549: ARRAY
80550: PUSH
80551: LD_VAR 0 1
80555: DIFF
80556: PPUSH
80557: CALL_OW 1
80561: ST_TO_ADDR
// for i = 1 to mc_bases do
80562: LD_ADDR_VAR 0 5
80566: PUSH
80567: DOUBLE
80568: LD_INT 1
80570: DEC
80571: ST_TO_ADDR
80572: LD_EXP 23
80576: PUSH
80577: FOR_TO
80578: IFFALSE 80756
// begin if lab in mc_bases [ i ] then
80580: LD_VAR 0 2
80584: PUSH
80585: LD_EXP 23
80589: PUSH
80590: LD_VAR 0 5
80594: ARRAY
80595: IN
80596: IFFALSE 80754
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
80598: LD_VAR 0 1
80602: PUSH
80603: LD_INT 11
80605: PUSH
80606: LD_INT 4
80608: PUSH
80609: LD_INT 3
80611: PUSH
80612: LD_INT 2
80614: PUSH
80615: EMPTY
80616: LIST
80617: LIST
80618: LIST
80619: LIST
80620: IN
80621: PUSH
80622: LD_EXP 53
80626: PUSH
80627: LD_VAR 0 5
80631: ARRAY
80632: AND
80633: IFFALSE 80754
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
80635: LD_ADDR_VAR 0 6
80639: PUSH
80640: LD_EXP 53
80644: PUSH
80645: LD_VAR 0 5
80649: ARRAY
80650: PUSH
80651: LD_INT 1
80653: ARRAY
80654: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
80655: LD_ADDR_EXP 53
80659: PUSH
80660: LD_EXP 53
80664: PPUSH
80665: LD_VAR 0 5
80669: PPUSH
80670: EMPTY
80671: PPUSH
80672: CALL_OW 1
80676: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
80677: LD_VAR 0 6
80681: PPUSH
80682: LD_INT 0
80684: PPUSH
80685: CALL_OW 109
// ComExitBuilding ( tmp ) ;
80689: LD_VAR 0 6
80693: PPUSH
80694: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
80698: LD_ADDR_EXP 52
80702: PUSH
80703: LD_EXP 52
80707: PPUSH
80708: LD_VAR 0 5
80712: PPUSH
80713: LD_EXP 52
80717: PUSH
80718: LD_VAR 0 5
80722: ARRAY
80723: PPUSH
80724: LD_INT 1
80726: PPUSH
80727: LD_VAR 0 6
80731: PPUSH
80732: CALL_OW 2
80736: PPUSH
80737: CALL_OW 1
80741: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
80742: LD_VAR 0 5
80746: PPUSH
80747: LD_INT 112
80749: PPUSH
80750: CALL 57208 0 2
// end ; end ; end ;
80754: GO 80577
80756: POP
80757: POP
// end ;
80758: LD_VAR 0 3
80762: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
80763: LD_INT 0
80765: PPUSH
80766: PPUSH
80767: PPUSH
80768: PPUSH
80769: PPUSH
80770: PPUSH
80771: PPUSH
80772: PPUSH
// if not mc_bases or not skirmish then
80773: LD_EXP 23
80777: NOT
80778: PUSH
80779: LD_EXP 21
80783: NOT
80784: OR
80785: IFFALSE 80789
// exit ;
80787: GO 82158
// for i = 1 to mc_bases do
80789: LD_ADDR_VAR 0 3
80793: PUSH
80794: DOUBLE
80795: LD_INT 1
80797: DEC
80798: ST_TO_ADDR
80799: LD_EXP 23
80803: PUSH
80804: FOR_TO
80805: IFFALSE 82156
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
80807: LD_VAR 0 1
80811: PUSH
80812: LD_EXP 23
80816: PUSH
80817: LD_VAR 0 3
80821: ARRAY
80822: IN
80823: PUSH
80824: LD_VAR 0 1
80828: PUSH
80829: LD_EXP 30
80833: PUSH
80834: LD_VAR 0 3
80838: ARRAY
80839: IN
80840: OR
80841: PUSH
80842: LD_VAR 0 1
80846: PUSH
80847: LD_EXP 45
80851: PUSH
80852: LD_VAR 0 3
80856: ARRAY
80857: IN
80858: OR
80859: PUSH
80860: LD_VAR 0 1
80864: PUSH
80865: LD_EXP 42
80869: PUSH
80870: LD_VAR 0 3
80874: ARRAY
80875: IN
80876: OR
80877: PUSH
80878: LD_VAR 0 1
80882: PUSH
80883: LD_EXP 52
80887: PUSH
80888: LD_VAR 0 3
80892: ARRAY
80893: IN
80894: OR
80895: PUSH
80896: LD_VAR 0 1
80900: PUSH
80901: LD_EXP 53
80905: PUSH
80906: LD_VAR 0 3
80910: ARRAY
80911: IN
80912: OR
80913: IFFALSE 82154
// begin if un in mc_ape [ i ] then
80915: LD_VAR 0 1
80919: PUSH
80920: LD_EXP 52
80924: PUSH
80925: LD_VAR 0 3
80929: ARRAY
80930: IN
80931: IFFALSE 80970
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
80933: LD_ADDR_EXP 52
80937: PUSH
80938: LD_EXP 52
80942: PPUSH
80943: LD_VAR 0 3
80947: PPUSH
80948: LD_EXP 52
80952: PUSH
80953: LD_VAR 0 3
80957: ARRAY
80958: PUSH
80959: LD_VAR 0 1
80963: DIFF
80964: PPUSH
80965: CALL_OW 1
80969: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
80970: LD_VAR 0 1
80974: PUSH
80975: LD_EXP 53
80979: PUSH
80980: LD_VAR 0 3
80984: ARRAY
80985: IN
80986: IFFALSE 81010
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
80988: LD_ADDR_EXP 53
80992: PUSH
80993: LD_EXP 53
80997: PPUSH
80998: LD_VAR 0 3
81002: PPUSH
81003: EMPTY
81004: PPUSH
81005: CALL_OW 1
81009: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
81010: LD_VAR 0 1
81014: PPUSH
81015: CALL_OW 247
81019: PUSH
81020: LD_INT 2
81022: EQUAL
81023: PUSH
81024: LD_VAR 0 1
81028: PPUSH
81029: CALL_OW 110
81033: PUSH
81034: LD_INT 20
81036: EQUAL
81037: PUSH
81038: LD_VAR 0 1
81042: PUSH
81043: LD_EXP 45
81047: PUSH
81048: LD_VAR 0 3
81052: ARRAY
81053: IN
81054: OR
81055: PUSH
81056: LD_VAR 0 1
81060: PPUSH
81061: CALL_OW 264
81065: PUSH
81066: LD_INT 12
81068: PUSH
81069: LD_INT 51
81071: PUSH
81072: LD_INT 89
81074: PUSH
81075: LD_INT 32
81077: PUSH
81078: LD_INT 13
81080: PUSH
81081: LD_INT 52
81083: PUSH
81084: LD_INT 31
81086: PUSH
81087: EMPTY
81088: LIST
81089: LIST
81090: LIST
81091: LIST
81092: LIST
81093: LIST
81094: LIST
81095: IN
81096: OR
81097: AND
81098: IFFALSE 81406
// begin if un in mc_defender [ i ] then
81100: LD_VAR 0 1
81104: PUSH
81105: LD_EXP 45
81109: PUSH
81110: LD_VAR 0 3
81114: ARRAY
81115: IN
81116: IFFALSE 81155
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
81118: LD_ADDR_EXP 45
81122: PUSH
81123: LD_EXP 45
81127: PPUSH
81128: LD_VAR 0 3
81132: PPUSH
81133: LD_EXP 45
81137: PUSH
81138: LD_VAR 0 3
81142: ARRAY
81143: PUSH
81144: LD_VAR 0 1
81148: DIFF
81149: PPUSH
81150: CALL_OW 1
81154: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
81155: LD_ADDR_VAR 0 8
81159: PUSH
81160: LD_VAR 0 3
81164: PPUSH
81165: LD_INT 3
81167: PPUSH
81168: CALL 77776 0 2
81172: ST_TO_ADDR
// if fac then
81173: LD_VAR 0 8
81177: IFFALSE 81406
// begin for j in fac do
81179: LD_ADDR_VAR 0 4
81183: PUSH
81184: LD_VAR 0 8
81188: PUSH
81189: FOR_IN
81190: IFFALSE 81404
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
81192: LD_ADDR_VAR 0 9
81196: PUSH
81197: LD_VAR 0 8
81201: PPUSH
81202: LD_VAR 0 1
81206: PPUSH
81207: CALL_OW 265
81211: PPUSH
81212: LD_VAR 0 1
81216: PPUSH
81217: CALL_OW 262
81221: PPUSH
81222: LD_VAR 0 1
81226: PPUSH
81227: CALL_OW 263
81231: PPUSH
81232: LD_VAR 0 1
81236: PPUSH
81237: CALL_OW 264
81241: PPUSH
81242: CALL 13575 0 5
81246: ST_TO_ADDR
// if components then
81247: LD_VAR 0 9
81251: IFFALSE 81402
// begin if GetWeapon ( un ) = ar_control_tower then
81253: LD_VAR 0 1
81257: PPUSH
81258: CALL_OW 264
81262: PUSH
81263: LD_INT 31
81265: EQUAL
81266: IFFALSE 81383
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
81268: LD_VAR 0 1
81272: PPUSH
81273: CALL_OW 311
81277: PPUSH
81278: LD_INT 0
81280: PPUSH
81281: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
81285: LD_ADDR_EXP 63
81289: PUSH
81290: LD_EXP 63
81294: PPUSH
81295: LD_VAR 0 3
81299: PPUSH
81300: LD_EXP 63
81304: PUSH
81305: LD_VAR 0 3
81309: ARRAY
81310: PUSH
81311: LD_VAR 0 1
81315: PPUSH
81316: CALL_OW 311
81320: DIFF
81321: PPUSH
81322: CALL_OW 1
81326: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
81327: LD_ADDR_VAR 0 7
81331: PUSH
81332: LD_EXP 44
81336: PUSH
81337: LD_VAR 0 3
81341: ARRAY
81342: PPUSH
81343: LD_INT 1
81345: PPUSH
81346: LD_VAR 0 9
81350: PPUSH
81351: CALL_OW 2
81355: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
81356: LD_ADDR_EXP 44
81360: PUSH
81361: LD_EXP 44
81365: PPUSH
81366: LD_VAR 0 3
81370: PPUSH
81371: LD_VAR 0 7
81375: PPUSH
81376: CALL_OW 1
81380: ST_TO_ADDR
// end else
81381: GO 81400
// MC_InsertProduceList ( i , [ components ] ) ;
81383: LD_VAR 0 3
81387: PPUSH
81388: LD_VAR 0 9
81392: PUSH
81393: EMPTY
81394: LIST
81395: PPUSH
81396: CALL 77321 0 2
// break ;
81400: GO 81404
// end ; end ;
81402: GO 81189
81404: POP
81405: POP
// end ; end ; if GetType ( un ) = unit_building then
81406: LD_VAR 0 1
81410: PPUSH
81411: CALL_OW 247
81415: PUSH
81416: LD_INT 3
81418: EQUAL
81419: IFFALSE 81822
// begin btype := GetBType ( un ) ;
81421: LD_ADDR_VAR 0 5
81425: PUSH
81426: LD_VAR 0 1
81430: PPUSH
81431: CALL_OW 266
81435: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
81436: LD_VAR 0 5
81440: PUSH
81441: LD_INT 29
81443: PUSH
81444: LD_INT 30
81446: PUSH
81447: EMPTY
81448: LIST
81449: LIST
81450: IN
81451: IFFALSE 81524
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
81453: LD_VAR 0 1
81457: PPUSH
81458: CALL_OW 250
81462: PPUSH
81463: LD_VAR 0 1
81467: PPUSH
81468: CALL_OW 251
81472: PPUSH
81473: LD_VAR 0 1
81477: PPUSH
81478: CALL_OW 255
81482: PPUSH
81483: CALL_OW 440
81487: NOT
81488: IFFALSE 81524
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
81490: LD_VAR 0 1
81494: PPUSH
81495: CALL_OW 250
81499: PPUSH
81500: LD_VAR 0 1
81504: PPUSH
81505: CALL_OW 251
81509: PPUSH
81510: LD_VAR 0 1
81514: PPUSH
81515: CALL_OW 255
81519: PPUSH
81520: CALL_OW 441
// end ; if btype = b_warehouse then
81524: LD_VAR 0 5
81528: PUSH
81529: LD_INT 1
81531: EQUAL
81532: IFFALSE 81550
// begin btype := b_depot ;
81534: LD_ADDR_VAR 0 5
81538: PUSH
81539: LD_INT 0
81541: ST_TO_ADDR
// pos := 1 ;
81542: LD_ADDR_VAR 0 6
81546: PUSH
81547: LD_INT 1
81549: ST_TO_ADDR
// end ; if btype = b_factory then
81550: LD_VAR 0 5
81554: PUSH
81555: LD_INT 3
81557: EQUAL
81558: IFFALSE 81576
// begin btype := b_workshop ;
81560: LD_ADDR_VAR 0 5
81564: PUSH
81565: LD_INT 2
81567: ST_TO_ADDR
// pos := 1 ;
81568: LD_ADDR_VAR 0 6
81572: PUSH
81573: LD_INT 1
81575: ST_TO_ADDR
// end ; if btype = b_barracks then
81576: LD_VAR 0 5
81580: PUSH
81581: LD_INT 5
81583: EQUAL
81584: IFFALSE 81594
// btype := b_armoury ;
81586: LD_ADDR_VAR 0 5
81590: PUSH
81591: LD_INT 4
81593: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
81594: LD_VAR 0 5
81598: PUSH
81599: LD_INT 7
81601: PUSH
81602: LD_INT 8
81604: PUSH
81605: EMPTY
81606: LIST
81607: LIST
81608: IN
81609: IFFALSE 81619
// btype := b_lab ;
81611: LD_ADDR_VAR 0 5
81615: PUSH
81616: LD_INT 6
81618: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
81619: LD_ADDR_EXP 28
81623: PUSH
81624: LD_EXP 28
81628: PPUSH
81629: LD_VAR 0 3
81633: PUSH
81634: LD_EXP 28
81638: PUSH
81639: LD_VAR 0 3
81643: ARRAY
81644: PUSH
81645: LD_INT 1
81647: PLUS
81648: PUSH
81649: EMPTY
81650: LIST
81651: LIST
81652: PPUSH
81653: LD_VAR 0 5
81657: PUSH
81658: LD_VAR 0 1
81662: PPUSH
81663: CALL_OW 250
81667: PUSH
81668: LD_VAR 0 1
81672: PPUSH
81673: CALL_OW 251
81677: PUSH
81678: LD_VAR 0 1
81682: PPUSH
81683: CALL_OW 254
81687: PUSH
81688: EMPTY
81689: LIST
81690: LIST
81691: LIST
81692: LIST
81693: PPUSH
81694: CALL 16077 0 3
81698: ST_TO_ADDR
// if pos = 1 then
81699: LD_VAR 0 6
81703: PUSH
81704: LD_INT 1
81706: EQUAL
81707: IFFALSE 81822
// begin tmp := mc_build_list [ i ] ;
81709: LD_ADDR_VAR 0 7
81713: PUSH
81714: LD_EXP 28
81718: PUSH
81719: LD_VAR 0 3
81723: ARRAY
81724: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
81725: LD_VAR 0 7
81729: PPUSH
81730: LD_INT 2
81732: PUSH
81733: LD_INT 30
81735: PUSH
81736: LD_INT 0
81738: PUSH
81739: EMPTY
81740: LIST
81741: LIST
81742: PUSH
81743: LD_INT 30
81745: PUSH
81746: LD_INT 1
81748: PUSH
81749: EMPTY
81750: LIST
81751: LIST
81752: PUSH
81753: EMPTY
81754: LIST
81755: LIST
81756: LIST
81757: PPUSH
81758: CALL_OW 72
81762: IFFALSE 81772
// pos := 2 ;
81764: LD_ADDR_VAR 0 6
81768: PUSH
81769: LD_INT 2
81771: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
81772: LD_ADDR_VAR 0 7
81776: PUSH
81777: LD_VAR 0 7
81781: PPUSH
81782: LD_VAR 0 6
81786: PPUSH
81787: LD_VAR 0 7
81791: PPUSH
81792: CALL 16403 0 3
81796: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
81797: LD_ADDR_EXP 28
81801: PUSH
81802: LD_EXP 28
81806: PPUSH
81807: LD_VAR 0 3
81811: PPUSH
81812: LD_VAR 0 7
81816: PPUSH
81817: CALL_OW 1
81821: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
81822: LD_VAR 0 1
81826: PUSH
81827: LD_EXP 23
81831: PUSH
81832: LD_VAR 0 3
81836: ARRAY
81837: IN
81838: IFFALSE 81877
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
81840: LD_ADDR_EXP 23
81844: PUSH
81845: LD_EXP 23
81849: PPUSH
81850: LD_VAR 0 3
81854: PPUSH
81855: LD_EXP 23
81859: PUSH
81860: LD_VAR 0 3
81864: ARRAY
81865: PUSH
81866: LD_VAR 0 1
81870: DIFF
81871: PPUSH
81872: CALL_OW 1
81876: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
81877: LD_VAR 0 1
81881: PUSH
81882: LD_EXP 30
81886: PUSH
81887: LD_VAR 0 3
81891: ARRAY
81892: IN
81893: IFFALSE 81932
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
81895: LD_ADDR_EXP 30
81899: PUSH
81900: LD_EXP 30
81904: PPUSH
81905: LD_VAR 0 3
81909: PPUSH
81910: LD_EXP 30
81914: PUSH
81915: LD_VAR 0 3
81919: ARRAY
81920: PUSH
81921: LD_VAR 0 1
81925: DIFF
81926: PPUSH
81927: CALL_OW 1
81931: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
81932: LD_VAR 0 1
81936: PUSH
81937: LD_EXP 42
81941: PUSH
81942: LD_VAR 0 3
81946: ARRAY
81947: IN
81948: IFFALSE 81987
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
81950: LD_ADDR_EXP 42
81954: PUSH
81955: LD_EXP 42
81959: PPUSH
81960: LD_VAR 0 3
81964: PPUSH
81965: LD_EXP 42
81969: PUSH
81970: LD_VAR 0 3
81974: ARRAY
81975: PUSH
81976: LD_VAR 0 1
81980: DIFF
81981: PPUSH
81982: CALL_OW 1
81986: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
81987: LD_VAR 0 1
81991: PUSH
81992: LD_EXP 45
81996: PUSH
81997: LD_VAR 0 3
82001: ARRAY
82002: IN
82003: IFFALSE 82042
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
82005: LD_ADDR_EXP 45
82009: PUSH
82010: LD_EXP 45
82014: PPUSH
82015: LD_VAR 0 3
82019: PPUSH
82020: LD_EXP 45
82024: PUSH
82025: LD_VAR 0 3
82029: ARRAY
82030: PUSH
82031: LD_VAR 0 1
82035: DIFF
82036: PPUSH
82037: CALL_OW 1
82041: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
82042: LD_VAR 0 1
82046: PUSH
82047: LD_EXP 32
82051: PUSH
82052: LD_VAR 0 3
82056: ARRAY
82057: IN
82058: IFFALSE 82097
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
82060: LD_ADDR_EXP 32
82064: PUSH
82065: LD_EXP 32
82069: PPUSH
82070: LD_VAR 0 3
82074: PPUSH
82075: LD_EXP 32
82079: PUSH
82080: LD_VAR 0 3
82084: ARRAY
82085: PUSH
82086: LD_VAR 0 1
82090: DIFF
82091: PPUSH
82092: CALL_OW 1
82096: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
82097: LD_VAR 0 1
82101: PUSH
82102: LD_EXP 31
82106: PUSH
82107: LD_VAR 0 3
82111: ARRAY
82112: IN
82113: IFFALSE 82152
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
82115: LD_ADDR_EXP 31
82119: PUSH
82120: LD_EXP 31
82124: PPUSH
82125: LD_VAR 0 3
82129: PPUSH
82130: LD_EXP 31
82134: PUSH
82135: LD_VAR 0 3
82139: ARRAY
82140: PUSH
82141: LD_VAR 0 1
82145: DIFF
82146: PPUSH
82147: CALL_OW 1
82151: ST_TO_ADDR
// end ; break ;
82152: GO 82156
// end ;
82154: GO 80804
82156: POP
82157: POP
// end ;
82158: LD_VAR 0 2
82162: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
82163: LD_INT 0
82165: PPUSH
82166: PPUSH
82167: PPUSH
// if not mc_bases or not skirmish then
82168: LD_EXP 23
82172: NOT
82173: PUSH
82174: LD_EXP 21
82178: NOT
82179: OR
82180: IFFALSE 82184
// exit ;
82182: GO 82399
// for i = 1 to mc_bases do
82184: LD_ADDR_VAR 0 3
82188: PUSH
82189: DOUBLE
82190: LD_INT 1
82192: DEC
82193: ST_TO_ADDR
82194: LD_EXP 23
82198: PUSH
82199: FOR_TO
82200: IFFALSE 82397
// begin if building in mc_construct_list [ i ] then
82202: LD_VAR 0 1
82206: PUSH
82207: LD_EXP 30
82211: PUSH
82212: LD_VAR 0 3
82216: ARRAY
82217: IN
82218: IFFALSE 82395
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
82220: LD_ADDR_EXP 30
82224: PUSH
82225: LD_EXP 30
82229: PPUSH
82230: LD_VAR 0 3
82234: PPUSH
82235: LD_EXP 30
82239: PUSH
82240: LD_VAR 0 3
82244: ARRAY
82245: PUSH
82246: LD_VAR 0 1
82250: DIFF
82251: PPUSH
82252: CALL_OW 1
82256: ST_TO_ADDR
// if building in mc_lab [ i ] then
82257: LD_VAR 0 1
82261: PUSH
82262: LD_EXP 56
82266: PUSH
82267: LD_VAR 0 3
82271: ARRAY
82272: IN
82273: IFFALSE 82328
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
82275: LD_ADDR_EXP 57
82279: PUSH
82280: LD_EXP 57
82284: PPUSH
82285: LD_VAR 0 3
82289: PPUSH
82290: LD_EXP 57
82294: PUSH
82295: LD_VAR 0 3
82299: ARRAY
82300: PPUSH
82301: LD_INT 1
82303: PPUSH
82304: LD_EXP 57
82308: PUSH
82309: LD_VAR 0 3
82313: ARRAY
82314: PPUSH
82315: LD_INT 0
82317: PPUSH
82318: CALL 15495 0 4
82322: PPUSH
82323: CALL_OW 1
82327: ST_TO_ADDR
// if not building in mc_bases [ i ] then
82328: LD_VAR 0 1
82332: PUSH
82333: LD_EXP 23
82337: PUSH
82338: LD_VAR 0 3
82342: ARRAY
82343: IN
82344: NOT
82345: IFFALSE 82391
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
82347: LD_ADDR_EXP 23
82351: PUSH
82352: LD_EXP 23
82356: PPUSH
82357: LD_VAR 0 3
82361: PUSH
82362: LD_EXP 23
82366: PUSH
82367: LD_VAR 0 3
82371: ARRAY
82372: PUSH
82373: LD_INT 1
82375: PLUS
82376: PUSH
82377: EMPTY
82378: LIST
82379: LIST
82380: PPUSH
82381: LD_VAR 0 1
82385: PPUSH
82386: CALL 16077 0 3
82390: ST_TO_ADDR
// exit ;
82391: POP
82392: POP
82393: GO 82399
// end ; end ;
82395: GO 82199
82397: POP
82398: POP
// end ;
82399: LD_VAR 0 2
82403: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
82404: LD_INT 0
82406: PPUSH
82407: PPUSH
82408: PPUSH
82409: PPUSH
82410: PPUSH
82411: PPUSH
82412: PPUSH
// if not mc_bases or not skirmish then
82413: LD_EXP 23
82417: NOT
82418: PUSH
82419: LD_EXP 21
82423: NOT
82424: OR
82425: IFFALSE 82429
// exit ;
82427: GO 83090
// for i = 1 to mc_bases do
82429: LD_ADDR_VAR 0 3
82433: PUSH
82434: DOUBLE
82435: LD_INT 1
82437: DEC
82438: ST_TO_ADDR
82439: LD_EXP 23
82443: PUSH
82444: FOR_TO
82445: IFFALSE 83088
// begin if building in mc_construct_list [ i ] then
82447: LD_VAR 0 1
82451: PUSH
82452: LD_EXP 30
82456: PUSH
82457: LD_VAR 0 3
82461: ARRAY
82462: IN
82463: IFFALSE 83086
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
82465: LD_ADDR_EXP 30
82469: PUSH
82470: LD_EXP 30
82474: PPUSH
82475: LD_VAR 0 3
82479: PPUSH
82480: LD_EXP 30
82484: PUSH
82485: LD_VAR 0 3
82489: ARRAY
82490: PUSH
82491: LD_VAR 0 1
82495: DIFF
82496: PPUSH
82497: CALL_OW 1
82501: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
82502: LD_ADDR_EXP 23
82506: PUSH
82507: LD_EXP 23
82511: PPUSH
82512: LD_VAR 0 3
82516: PUSH
82517: LD_EXP 23
82521: PUSH
82522: LD_VAR 0 3
82526: ARRAY
82527: PUSH
82528: LD_INT 1
82530: PLUS
82531: PUSH
82532: EMPTY
82533: LIST
82534: LIST
82535: PPUSH
82536: LD_VAR 0 1
82540: PPUSH
82541: CALL 16077 0 3
82545: ST_TO_ADDR
// btype := GetBType ( building ) ;
82546: LD_ADDR_VAR 0 5
82550: PUSH
82551: LD_VAR 0 1
82555: PPUSH
82556: CALL_OW 266
82560: ST_TO_ADDR
// side := GetSide ( building ) ;
82561: LD_ADDR_VAR 0 8
82565: PUSH
82566: LD_VAR 0 1
82570: PPUSH
82571: CALL_OW 255
82575: ST_TO_ADDR
// if btype = b_lab then
82576: LD_VAR 0 5
82580: PUSH
82581: LD_INT 6
82583: EQUAL
82584: IFFALSE 82634
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
82586: LD_ADDR_EXP 56
82590: PUSH
82591: LD_EXP 56
82595: PPUSH
82596: LD_VAR 0 3
82600: PUSH
82601: LD_EXP 56
82605: PUSH
82606: LD_VAR 0 3
82610: ARRAY
82611: PUSH
82612: LD_INT 1
82614: PLUS
82615: PUSH
82616: EMPTY
82617: LIST
82618: LIST
82619: PPUSH
82620: LD_VAR 0 1
82624: PPUSH
82625: CALL 16077 0 3
82629: ST_TO_ADDR
// exit ;
82630: POP
82631: POP
82632: GO 83090
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
82634: LD_VAR 0 5
82638: PUSH
82639: LD_INT 0
82641: PUSH
82642: LD_INT 2
82644: PUSH
82645: LD_INT 4
82647: PUSH
82648: EMPTY
82649: LIST
82650: LIST
82651: LIST
82652: IN
82653: IFFALSE 82777
// begin if btype = b_armoury then
82655: LD_VAR 0 5
82659: PUSH
82660: LD_INT 4
82662: EQUAL
82663: IFFALSE 82673
// btype := b_barracks ;
82665: LD_ADDR_VAR 0 5
82669: PUSH
82670: LD_INT 5
82672: ST_TO_ADDR
// if btype = b_depot then
82673: LD_VAR 0 5
82677: PUSH
82678: LD_INT 0
82680: EQUAL
82681: IFFALSE 82691
// btype := b_warehouse ;
82683: LD_ADDR_VAR 0 5
82687: PUSH
82688: LD_INT 1
82690: ST_TO_ADDR
// if btype = b_workshop then
82691: LD_VAR 0 5
82695: PUSH
82696: LD_INT 2
82698: EQUAL
82699: IFFALSE 82709
// btype := b_factory ;
82701: LD_ADDR_VAR 0 5
82705: PUSH
82706: LD_INT 3
82708: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
82709: LD_VAR 0 5
82713: PPUSH
82714: LD_VAR 0 8
82718: PPUSH
82719: CALL_OW 323
82723: PUSH
82724: LD_INT 1
82726: EQUAL
82727: IFFALSE 82773
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
82729: LD_ADDR_EXP 55
82733: PUSH
82734: LD_EXP 55
82738: PPUSH
82739: LD_VAR 0 3
82743: PUSH
82744: LD_EXP 55
82748: PUSH
82749: LD_VAR 0 3
82753: ARRAY
82754: PUSH
82755: LD_INT 1
82757: PLUS
82758: PUSH
82759: EMPTY
82760: LIST
82761: LIST
82762: PPUSH
82763: LD_VAR 0 1
82767: PPUSH
82768: CALL 16077 0 3
82772: ST_TO_ADDR
// exit ;
82773: POP
82774: POP
82775: GO 83090
// end ; if btype in [ b_bunker , b_turret ] then
82777: LD_VAR 0 5
82781: PUSH
82782: LD_INT 32
82784: PUSH
82785: LD_INT 33
82787: PUSH
82788: EMPTY
82789: LIST
82790: LIST
82791: IN
82792: IFFALSE 83082
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
82794: LD_ADDR_EXP 31
82798: PUSH
82799: LD_EXP 31
82803: PPUSH
82804: LD_VAR 0 3
82808: PUSH
82809: LD_EXP 31
82813: PUSH
82814: LD_VAR 0 3
82818: ARRAY
82819: PUSH
82820: LD_INT 1
82822: PLUS
82823: PUSH
82824: EMPTY
82825: LIST
82826: LIST
82827: PPUSH
82828: LD_VAR 0 1
82832: PPUSH
82833: CALL 16077 0 3
82837: ST_TO_ADDR
// if btype = b_bunker then
82838: LD_VAR 0 5
82842: PUSH
82843: LD_INT 32
82845: EQUAL
82846: IFFALSE 83082
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
82848: LD_ADDR_EXP 32
82852: PUSH
82853: LD_EXP 32
82857: PPUSH
82858: LD_VAR 0 3
82862: PUSH
82863: LD_EXP 32
82867: PUSH
82868: LD_VAR 0 3
82872: ARRAY
82873: PUSH
82874: LD_INT 1
82876: PLUS
82877: PUSH
82878: EMPTY
82879: LIST
82880: LIST
82881: PPUSH
82882: LD_VAR 0 1
82886: PPUSH
82887: CALL 16077 0 3
82891: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
82892: LD_ADDR_VAR 0 6
82896: PUSH
82897: LD_EXP 23
82901: PUSH
82902: LD_VAR 0 3
82906: ARRAY
82907: PPUSH
82908: LD_INT 25
82910: PUSH
82911: LD_INT 1
82913: PUSH
82914: EMPTY
82915: LIST
82916: LIST
82917: PUSH
82918: LD_INT 3
82920: PUSH
82921: LD_INT 54
82923: PUSH
82924: EMPTY
82925: LIST
82926: PUSH
82927: EMPTY
82928: LIST
82929: LIST
82930: PUSH
82931: EMPTY
82932: LIST
82933: LIST
82934: PPUSH
82935: CALL_OW 72
82939: ST_TO_ADDR
// if tmp then
82940: LD_VAR 0 6
82944: IFFALSE 82950
// exit ;
82946: POP
82947: POP
82948: GO 83090
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
82950: LD_ADDR_VAR 0 6
82954: PUSH
82955: LD_EXP 23
82959: PUSH
82960: LD_VAR 0 3
82964: ARRAY
82965: PPUSH
82966: LD_INT 2
82968: PUSH
82969: LD_INT 30
82971: PUSH
82972: LD_INT 4
82974: PUSH
82975: EMPTY
82976: LIST
82977: LIST
82978: PUSH
82979: LD_INT 30
82981: PUSH
82982: LD_INT 5
82984: PUSH
82985: EMPTY
82986: LIST
82987: LIST
82988: PUSH
82989: EMPTY
82990: LIST
82991: LIST
82992: LIST
82993: PPUSH
82994: CALL_OW 72
82998: ST_TO_ADDR
// if not tmp then
82999: LD_VAR 0 6
83003: NOT
83004: IFFALSE 83010
// exit ;
83006: POP
83007: POP
83008: GO 83090
// for j in tmp do
83010: LD_ADDR_VAR 0 4
83014: PUSH
83015: LD_VAR 0 6
83019: PUSH
83020: FOR_IN
83021: IFFALSE 83080
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
83023: LD_ADDR_VAR 0 7
83027: PUSH
83028: LD_VAR 0 4
83032: PPUSH
83033: CALL_OW 313
83037: PPUSH
83038: LD_INT 25
83040: PUSH
83041: LD_INT 1
83043: PUSH
83044: EMPTY
83045: LIST
83046: LIST
83047: PPUSH
83048: CALL_OW 72
83052: ST_TO_ADDR
// if units then
83053: LD_VAR 0 7
83057: IFFALSE 83078
// begin ComExitBuilding ( units [ 1 ] ) ;
83059: LD_VAR 0 7
83063: PUSH
83064: LD_INT 1
83066: ARRAY
83067: PPUSH
83068: CALL_OW 122
// exit ;
83072: POP
83073: POP
83074: POP
83075: POP
83076: GO 83090
// end ; end ;
83078: GO 83020
83080: POP
83081: POP
// end ; end ; exit ;
83082: POP
83083: POP
83084: GO 83090
// end ; end ;
83086: GO 82444
83088: POP
83089: POP
// end ;
83090: LD_VAR 0 2
83094: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
83095: LD_INT 0
83097: PPUSH
83098: PPUSH
83099: PPUSH
83100: PPUSH
83101: PPUSH
83102: PPUSH
83103: PPUSH
// if not mc_bases or not skirmish then
83104: LD_EXP 23
83108: NOT
83109: PUSH
83110: LD_EXP 21
83114: NOT
83115: OR
83116: IFFALSE 83120
// exit ;
83118: GO 83385
// btype := GetBType ( building ) ;
83120: LD_ADDR_VAR 0 6
83124: PUSH
83125: LD_VAR 0 1
83129: PPUSH
83130: CALL_OW 266
83134: ST_TO_ADDR
// x := GetX ( building ) ;
83135: LD_ADDR_VAR 0 7
83139: PUSH
83140: LD_VAR 0 1
83144: PPUSH
83145: CALL_OW 250
83149: ST_TO_ADDR
// y := GetY ( building ) ;
83150: LD_ADDR_VAR 0 8
83154: PUSH
83155: LD_VAR 0 1
83159: PPUSH
83160: CALL_OW 251
83164: ST_TO_ADDR
// d := GetDir ( building ) ;
83165: LD_ADDR_VAR 0 9
83169: PUSH
83170: LD_VAR 0 1
83174: PPUSH
83175: CALL_OW 254
83179: ST_TO_ADDR
// for i = 1 to mc_bases do
83180: LD_ADDR_VAR 0 4
83184: PUSH
83185: DOUBLE
83186: LD_INT 1
83188: DEC
83189: ST_TO_ADDR
83190: LD_EXP 23
83194: PUSH
83195: FOR_TO
83196: IFFALSE 83383
// begin if not mc_build_list [ i ] then
83198: LD_EXP 28
83202: PUSH
83203: LD_VAR 0 4
83207: ARRAY
83208: NOT
83209: IFFALSE 83213
// continue ;
83211: GO 83195
// for j := 1 to mc_build_list [ i ] do
83213: LD_ADDR_VAR 0 5
83217: PUSH
83218: DOUBLE
83219: LD_INT 1
83221: DEC
83222: ST_TO_ADDR
83223: LD_EXP 28
83227: PUSH
83228: LD_VAR 0 4
83232: ARRAY
83233: PUSH
83234: FOR_TO
83235: IFFALSE 83379
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
83237: LD_VAR 0 6
83241: PUSH
83242: LD_VAR 0 7
83246: PUSH
83247: LD_VAR 0 8
83251: PUSH
83252: LD_VAR 0 9
83256: PUSH
83257: EMPTY
83258: LIST
83259: LIST
83260: LIST
83261: LIST
83262: PPUSH
83263: LD_EXP 28
83267: PUSH
83268: LD_VAR 0 4
83272: ARRAY
83273: PUSH
83274: LD_VAR 0 5
83278: ARRAY
83279: PPUSH
83280: CALL 22634 0 2
83284: IFFALSE 83377
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
83286: LD_ADDR_EXP 28
83290: PUSH
83291: LD_EXP 28
83295: PPUSH
83296: LD_VAR 0 4
83300: PPUSH
83301: LD_EXP 28
83305: PUSH
83306: LD_VAR 0 4
83310: ARRAY
83311: PPUSH
83312: LD_VAR 0 5
83316: PPUSH
83317: CALL_OW 3
83321: PPUSH
83322: CALL_OW 1
83326: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
83327: LD_ADDR_EXP 30
83331: PUSH
83332: LD_EXP 30
83336: PPUSH
83337: LD_VAR 0 4
83341: PUSH
83342: LD_EXP 30
83346: PUSH
83347: LD_VAR 0 4
83351: ARRAY
83352: PUSH
83353: LD_INT 1
83355: PLUS
83356: PUSH
83357: EMPTY
83358: LIST
83359: LIST
83360: PPUSH
83361: LD_VAR 0 1
83365: PPUSH
83366: CALL 16077 0 3
83370: ST_TO_ADDR
// exit ;
83371: POP
83372: POP
83373: POP
83374: POP
83375: GO 83385
// end ;
83377: GO 83234
83379: POP
83380: POP
// end ;
83381: GO 83195
83383: POP
83384: POP
// end ;
83385: LD_VAR 0 3
83389: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
83390: LD_INT 0
83392: PPUSH
83393: PPUSH
83394: PPUSH
// if not mc_bases or not skirmish then
83395: LD_EXP 23
83399: NOT
83400: PUSH
83401: LD_EXP 21
83405: NOT
83406: OR
83407: IFFALSE 83411
// exit ;
83409: GO 83601
// for i = 1 to mc_bases do
83411: LD_ADDR_VAR 0 4
83415: PUSH
83416: DOUBLE
83417: LD_INT 1
83419: DEC
83420: ST_TO_ADDR
83421: LD_EXP 23
83425: PUSH
83426: FOR_TO
83427: IFFALSE 83514
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
83429: LD_VAR 0 1
83433: PUSH
83434: LD_EXP 31
83438: PUSH
83439: LD_VAR 0 4
83443: ARRAY
83444: IN
83445: PUSH
83446: LD_VAR 0 1
83450: PUSH
83451: LD_EXP 32
83455: PUSH
83456: LD_VAR 0 4
83460: ARRAY
83461: IN
83462: NOT
83463: AND
83464: IFFALSE 83512
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
83466: LD_ADDR_EXP 32
83470: PUSH
83471: LD_EXP 32
83475: PPUSH
83476: LD_VAR 0 4
83480: PUSH
83481: LD_EXP 32
83485: PUSH
83486: LD_VAR 0 4
83490: ARRAY
83491: PUSH
83492: LD_INT 1
83494: PLUS
83495: PUSH
83496: EMPTY
83497: LIST
83498: LIST
83499: PPUSH
83500: LD_VAR 0 1
83504: PPUSH
83505: CALL 16077 0 3
83509: ST_TO_ADDR
// break ;
83510: GO 83514
// end ; end ;
83512: GO 83426
83514: POP
83515: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
83516: LD_VAR 0 1
83520: PPUSH
83521: CALL_OW 257
83525: PUSH
83526: LD_EXP 49
83530: IN
83531: PUSH
83532: LD_VAR 0 1
83536: PPUSH
83537: CALL_OW 266
83541: PUSH
83542: LD_INT 5
83544: EQUAL
83545: AND
83546: PUSH
83547: LD_VAR 0 2
83551: PPUSH
83552: CALL_OW 110
83556: PUSH
83557: LD_INT 18
83559: NONEQUAL
83560: AND
83561: IFFALSE 83601
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
83563: LD_VAR 0 2
83567: PPUSH
83568: CALL_OW 257
83572: PUSH
83573: LD_INT 5
83575: PUSH
83576: LD_INT 8
83578: PUSH
83579: LD_INT 9
83581: PUSH
83582: EMPTY
83583: LIST
83584: LIST
83585: LIST
83586: IN
83587: IFFALSE 83601
// SetClass ( unit , 1 ) ;
83589: LD_VAR 0 2
83593: PPUSH
83594: LD_INT 1
83596: PPUSH
83597: CALL_OW 336
// end ;
83601: LD_VAR 0 3
83605: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
83606: LD_INT 0
83608: PPUSH
83609: PPUSH
// if not mc_bases or not skirmish then
83610: LD_EXP 23
83614: NOT
83615: PUSH
83616: LD_EXP 21
83620: NOT
83621: OR
83622: IFFALSE 83626
// exit ;
83624: GO 83742
// if GetLives ( abandoned_vehicle ) > 250 then
83626: LD_VAR 0 2
83630: PPUSH
83631: CALL_OW 256
83635: PUSH
83636: LD_INT 250
83638: GREATER
83639: IFFALSE 83643
// exit ;
83641: GO 83742
// for i = 1 to mc_bases do
83643: LD_ADDR_VAR 0 6
83647: PUSH
83648: DOUBLE
83649: LD_INT 1
83651: DEC
83652: ST_TO_ADDR
83653: LD_EXP 23
83657: PUSH
83658: FOR_TO
83659: IFFALSE 83740
// begin if driver in mc_bases [ i ] then
83661: LD_VAR 0 1
83665: PUSH
83666: LD_EXP 23
83670: PUSH
83671: LD_VAR 0 6
83675: ARRAY
83676: IN
83677: IFFALSE 83738
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
83679: LD_VAR 0 1
83683: PPUSH
83684: LD_EXP 23
83688: PUSH
83689: LD_VAR 0 6
83693: ARRAY
83694: PPUSH
83695: LD_INT 2
83697: PUSH
83698: LD_INT 30
83700: PUSH
83701: LD_INT 0
83703: PUSH
83704: EMPTY
83705: LIST
83706: LIST
83707: PUSH
83708: LD_INT 30
83710: PUSH
83711: LD_INT 1
83713: PUSH
83714: EMPTY
83715: LIST
83716: LIST
83717: PUSH
83718: EMPTY
83719: LIST
83720: LIST
83721: LIST
83722: PPUSH
83723: CALL_OW 72
83727: PUSH
83728: LD_INT 1
83730: ARRAY
83731: PPUSH
83732: CALL 49694 0 2
// break ;
83736: GO 83740
// end ; end ;
83738: GO 83658
83740: POP
83741: POP
// end ; end_of_file
83742: LD_VAR 0 5
83746: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
83747: LD_INT 0
83749: PPUSH
83750: PPUSH
83751: PPUSH
83752: PPUSH
83753: PPUSH
83754: PPUSH
83755: PPUSH
83756: PPUSH
83757: PPUSH
83758: PPUSH
83759: PPUSH
83760: PPUSH
83761: PPUSH
83762: PPUSH
83763: PPUSH
83764: PPUSH
83765: PPUSH
83766: PPUSH
83767: PPUSH
83768: PPUSH
83769: PPUSH
83770: PPUSH
83771: PPUSH
83772: PPUSH
83773: PPUSH
83774: PPUSH
83775: PPUSH
83776: PPUSH
83777: PPUSH
83778: PPUSH
83779: PPUSH
83780: PPUSH
83781: PPUSH
83782: PPUSH
// if not list then
83783: LD_VAR 0 1
83787: NOT
83788: IFFALSE 83792
// exit ;
83790: GO 88451
// base := list [ 1 ] ;
83792: LD_ADDR_VAR 0 3
83796: PUSH
83797: LD_VAR 0 1
83801: PUSH
83802: LD_INT 1
83804: ARRAY
83805: ST_TO_ADDR
// group := list [ 2 ] ;
83806: LD_ADDR_VAR 0 4
83810: PUSH
83811: LD_VAR 0 1
83815: PUSH
83816: LD_INT 2
83818: ARRAY
83819: ST_TO_ADDR
// path := list [ 3 ] ;
83820: LD_ADDR_VAR 0 5
83824: PUSH
83825: LD_VAR 0 1
83829: PUSH
83830: LD_INT 3
83832: ARRAY
83833: ST_TO_ADDR
// flags := list [ 4 ] ;
83834: LD_ADDR_VAR 0 6
83838: PUSH
83839: LD_VAR 0 1
83843: PUSH
83844: LD_INT 4
83846: ARRAY
83847: ST_TO_ADDR
// mined := [ ] ;
83848: LD_ADDR_VAR 0 27
83852: PUSH
83853: EMPTY
83854: ST_TO_ADDR
// bombed := [ ] ;
83855: LD_ADDR_VAR 0 28
83859: PUSH
83860: EMPTY
83861: ST_TO_ADDR
// healers := [ ] ;
83862: LD_ADDR_VAR 0 31
83866: PUSH
83867: EMPTY
83868: ST_TO_ADDR
// to_heal := [ ] ;
83869: LD_ADDR_VAR 0 30
83873: PUSH
83874: EMPTY
83875: ST_TO_ADDR
// repairs := [ ] ;
83876: LD_ADDR_VAR 0 33
83880: PUSH
83881: EMPTY
83882: ST_TO_ADDR
// to_repair := [ ] ;
83883: LD_ADDR_VAR 0 32
83887: PUSH
83888: EMPTY
83889: ST_TO_ADDR
// if not group or not path then
83890: LD_VAR 0 4
83894: NOT
83895: PUSH
83896: LD_VAR 0 5
83900: NOT
83901: OR
83902: IFFALSE 83906
// exit ;
83904: GO 88451
// side := GetSide ( group [ 1 ] ) ;
83906: LD_ADDR_VAR 0 35
83910: PUSH
83911: LD_VAR 0 4
83915: PUSH
83916: LD_INT 1
83918: ARRAY
83919: PPUSH
83920: CALL_OW 255
83924: ST_TO_ADDR
// if flags then
83925: LD_VAR 0 6
83929: IFFALSE 84073
// begin f_ignore_area := flags [ 1 ] ;
83931: LD_ADDR_VAR 0 17
83935: PUSH
83936: LD_VAR 0 6
83940: PUSH
83941: LD_INT 1
83943: ARRAY
83944: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
83945: LD_ADDR_VAR 0 18
83949: PUSH
83950: LD_VAR 0 6
83954: PUSH
83955: LD_INT 2
83957: ARRAY
83958: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
83959: LD_ADDR_VAR 0 19
83963: PUSH
83964: LD_VAR 0 6
83968: PUSH
83969: LD_INT 3
83971: ARRAY
83972: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
83973: LD_ADDR_VAR 0 20
83977: PUSH
83978: LD_VAR 0 6
83982: PUSH
83983: LD_INT 4
83985: ARRAY
83986: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
83987: LD_ADDR_VAR 0 21
83991: PUSH
83992: LD_VAR 0 6
83996: PUSH
83997: LD_INT 5
83999: ARRAY
84000: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
84001: LD_ADDR_VAR 0 22
84005: PUSH
84006: LD_VAR 0 6
84010: PUSH
84011: LD_INT 6
84013: ARRAY
84014: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
84015: LD_ADDR_VAR 0 23
84019: PUSH
84020: LD_VAR 0 6
84024: PUSH
84025: LD_INT 7
84027: ARRAY
84028: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
84029: LD_ADDR_VAR 0 24
84033: PUSH
84034: LD_VAR 0 6
84038: PUSH
84039: LD_INT 8
84041: ARRAY
84042: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
84043: LD_ADDR_VAR 0 25
84047: PUSH
84048: LD_VAR 0 6
84052: PUSH
84053: LD_INT 9
84055: ARRAY
84056: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
84057: LD_ADDR_VAR 0 26
84061: PUSH
84062: LD_VAR 0 6
84066: PUSH
84067: LD_INT 10
84069: ARRAY
84070: ST_TO_ADDR
// end else
84071: GO 84153
// begin f_ignore_area := false ;
84073: LD_ADDR_VAR 0 17
84077: PUSH
84078: LD_INT 0
84080: ST_TO_ADDR
// f_capture := false ;
84081: LD_ADDR_VAR 0 18
84085: PUSH
84086: LD_INT 0
84088: ST_TO_ADDR
// f_ignore_civ := false ;
84089: LD_ADDR_VAR 0 19
84093: PUSH
84094: LD_INT 0
84096: ST_TO_ADDR
// f_murder := false ;
84097: LD_ADDR_VAR 0 20
84101: PUSH
84102: LD_INT 0
84104: ST_TO_ADDR
// f_mines := false ;
84105: LD_ADDR_VAR 0 21
84109: PUSH
84110: LD_INT 0
84112: ST_TO_ADDR
// f_repair := false ;
84113: LD_ADDR_VAR 0 22
84117: PUSH
84118: LD_INT 0
84120: ST_TO_ADDR
// f_heal := false ;
84121: LD_ADDR_VAR 0 23
84125: PUSH
84126: LD_INT 0
84128: ST_TO_ADDR
// f_spacetime := false ;
84129: LD_ADDR_VAR 0 24
84133: PUSH
84134: LD_INT 0
84136: ST_TO_ADDR
// f_attack_depot := false ;
84137: LD_ADDR_VAR 0 25
84141: PUSH
84142: LD_INT 0
84144: ST_TO_ADDR
// f_crawl := false ;
84145: LD_ADDR_VAR 0 26
84149: PUSH
84150: LD_INT 0
84152: ST_TO_ADDR
// end ; if f_heal then
84153: LD_VAR 0 23
84157: IFFALSE 84184
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
84159: LD_ADDR_VAR 0 31
84163: PUSH
84164: LD_VAR 0 4
84168: PPUSH
84169: LD_INT 25
84171: PUSH
84172: LD_INT 4
84174: PUSH
84175: EMPTY
84176: LIST
84177: LIST
84178: PPUSH
84179: CALL_OW 72
84183: ST_TO_ADDR
// if f_repair then
84184: LD_VAR 0 22
84188: IFFALSE 84215
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
84190: LD_ADDR_VAR 0 33
84194: PUSH
84195: LD_VAR 0 4
84199: PPUSH
84200: LD_INT 25
84202: PUSH
84203: LD_INT 3
84205: PUSH
84206: EMPTY
84207: LIST
84208: LIST
84209: PPUSH
84210: CALL_OW 72
84214: ST_TO_ADDR
// units_path := [ ] ;
84215: LD_ADDR_VAR 0 16
84219: PUSH
84220: EMPTY
84221: ST_TO_ADDR
// for i = 1 to group do
84222: LD_ADDR_VAR 0 7
84226: PUSH
84227: DOUBLE
84228: LD_INT 1
84230: DEC
84231: ST_TO_ADDR
84232: LD_VAR 0 4
84236: PUSH
84237: FOR_TO
84238: IFFALSE 84267
// units_path := Replace ( units_path , i , path ) ;
84240: LD_ADDR_VAR 0 16
84244: PUSH
84245: LD_VAR 0 16
84249: PPUSH
84250: LD_VAR 0 7
84254: PPUSH
84255: LD_VAR 0 5
84259: PPUSH
84260: CALL_OW 1
84264: ST_TO_ADDR
84265: GO 84237
84267: POP
84268: POP
// repeat for i = group downto 1 do
84269: LD_ADDR_VAR 0 7
84273: PUSH
84274: DOUBLE
84275: LD_VAR 0 4
84279: INC
84280: ST_TO_ADDR
84281: LD_INT 1
84283: PUSH
84284: FOR_DOWNTO
84285: IFFALSE 88407
// begin wait ( 5 ) ;
84287: LD_INT 5
84289: PPUSH
84290: CALL_OW 67
// tmp := [ ] ;
84294: LD_ADDR_VAR 0 14
84298: PUSH
84299: EMPTY
84300: ST_TO_ADDR
// attacking := false ;
84301: LD_ADDR_VAR 0 29
84305: PUSH
84306: LD_INT 0
84308: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
84309: LD_VAR 0 4
84313: PUSH
84314: LD_VAR 0 7
84318: ARRAY
84319: PPUSH
84320: CALL_OW 301
84324: PUSH
84325: LD_VAR 0 4
84329: PUSH
84330: LD_VAR 0 7
84334: ARRAY
84335: NOT
84336: OR
84337: IFFALSE 84446
// begin if GetType ( group [ i ] ) = unit_human then
84339: LD_VAR 0 4
84343: PUSH
84344: LD_VAR 0 7
84348: ARRAY
84349: PPUSH
84350: CALL_OW 247
84354: PUSH
84355: LD_INT 1
84357: EQUAL
84358: IFFALSE 84404
// begin to_heal := to_heal diff group [ i ] ;
84360: LD_ADDR_VAR 0 30
84364: PUSH
84365: LD_VAR 0 30
84369: PUSH
84370: LD_VAR 0 4
84374: PUSH
84375: LD_VAR 0 7
84379: ARRAY
84380: DIFF
84381: ST_TO_ADDR
// healers := healers diff group [ i ] ;
84382: LD_ADDR_VAR 0 31
84386: PUSH
84387: LD_VAR 0 31
84391: PUSH
84392: LD_VAR 0 4
84396: PUSH
84397: LD_VAR 0 7
84401: ARRAY
84402: DIFF
84403: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
84404: LD_ADDR_VAR 0 4
84408: PUSH
84409: LD_VAR 0 4
84413: PPUSH
84414: LD_VAR 0 7
84418: PPUSH
84419: CALL_OW 3
84423: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
84424: LD_ADDR_VAR 0 16
84428: PUSH
84429: LD_VAR 0 16
84433: PPUSH
84434: LD_VAR 0 7
84438: PPUSH
84439: CALL_OW 3
84443: ST_TO_ADDR
// continue ;
84444: GO 84284
// end ; if f_repair then
84446: LD_VAR 0 22
84450: IFFALSE 84939
// begin if GetType ( group [ i ] ) = unit_vehicle then
84452: LD_VAR 0 4
84456: PUSH
84457: LD_VAR 0 7
84461: ARRAY
84462: PPUSH
84463: CALL_OW 247
84467: PUSH
84468: LD_INT 2
84470: EQUAL
84471: IFFALSE 84661
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
84473: LD_VAR 0 4
84477: PUSH
84478: LD_VAR 0 7
84482: ARRAY
84483: PPUSH
84484: CALL_OW 256
84488: PUSH
84489: LD_INT 700
84491: LESS
84492: PUSH
84493: LD_VAR 0 4
84497: PUSH
84498: LD_VAR 0 7
84502: ARRAY
84503: PUSH
84504: LD_VAR 0 32
84508: IN
84509: NOT
84510: AND
84511: IFFALSE 84535
// to_repair := to_repair union group [ i ] ;
84513: LD_ADDR_VAR 0 32
84517: PUSH
84518: LD_VAR 0 32
84522: PUSH
84523: LD_VAR 0 4
84527: PUSH
84528: LD_VAR 0 7
84532: ARRAY
84533: UNION
84534: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
84535: LD_VAR 0 4
84539: PUSH
84540: LD_VAR 0 7
84544: ARRAY
84545: PPUSH
84546: CALL_OW 256
84550: PUSH
84551: LD_INT 1000
84553: EQUAL
84554: PUSH
84555: LD_VAR 0 4
84559: PUSH
84560: LD_VAR 0 7
84564: ARRAY
84565: PUSH
84566: LD_VAR 0 32
84570: IN
84571: AND
84572: IFFALSE 84596
// to_repair := to_repair diff group [ i ] ;
84574: LD_ADDR_VAR 0 32
84578: PUSH
84579: LD_VAR 0 32
84583: PUSH
84584: LD_VAR 0 4
84588: PUSH
84589: LD_VAR 0 7
84593: ARRAY
84594: DIFF
84595: ST_TO_ADDR
// if group [ i ] in to_repair then
84596: LD_VAR 0 4
84600: PUSH
84601: LD_VAR 0 7
84605: ARRAY
84606: PUSH
84607: LD_VAR 0 32
84611: IN
84612: IFFALSE 84659
// begin if not IsInArea ( group [ i ] , f_repair ) then
84614: LD_VAR 0 4
84618: PUSH
84619: LD_VAR 0 7
84623: ARRAY
84624: PPUSH
84625: LD_VAR 0 22
84629: PPUSH
84630: CALL_OW 308
84634: NOT
84635: IFFALSE 84657
// ComMoveToArea ( group [ i ] , f_repair ) ;
84637: LD_VAR 0 4
84641: PUSH
84642: LD_VAR 0 7
84646: ARRAY
84647: PPUSH
84648: LD_VAR 0 22
84652: PPUSH
84653: CALL_OW 113
// continue ;
84657: GO 84284
// end ; end else
84659: GO 84939
// if group [ i ] in repairs then
84661: LD_VAR 0 4
84665: PUSH
84666: LD_VAR 0 7
84670: ARRAY
84671: PUSH
84672: LD_VAR 0 33
84676: IN
84677: IFFALSE 84939
// begin if IsInUnit ( group [ i ] ) then
84679: LD_VAR 0 4
84683: PUSH
84684: LD_VAR 0 7
84688: ARRAY
84689: PPUSH
84690: CALL_OW 310
84694: IFFALSE 84762
// begin z := IsInUnit ( group [ i ] ) ;
84696: LD_ADDR_VAR 0 13
84700: PUSH
84701: LD_VAR 0 4
84705: PUSH
84706: LD_VAR 0 7
84710: ARRAY
84711: PPUSH
84712: CALL_OW 310
84716: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
84717: LD_VAR 0 13
84721: PUSH
84722: LD_VAR 0 32
84726: IN
84727: PUSH
84728: LD_VAR 0 13
84732: PPUSH
84733: LD_VAR 0 22
84737: PPUSH
84738: CALL_OW 308
84742: AND
84743: IFFALSE 84760
// ComExitVehicle ( group [ i ] ) ;
84745: LD_VAR 0 4
84749: PUSH
84750: LD_VAR 0 7
84754: ARRAY
84755: PPUSH
84756: CALL_OW 121
// end else
84760: GO 84939
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
84762: LD_ADDR_VAR 0 13
84766: PUSH
84767: LD_VAR 0 4
84771: PPUSH
84772: LD_INT 95
84774: PUSH
84775: LD_VAR 0 22
84779: PUSH
84780: EMPTY
84781: LIST
84782: LIST
84783: PUSH
84784: LD_INT 58
84786: PUSH
84787: EMPTY
84788: LIST
84789: PUSH
84790: EMPTY
84791: LIST
84792: LIST
84793: PPUSH
84794: CALL_OW 72
84798: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
84799: LD_VAR 0 4
84803: PUSH
84804: LD_VAR 0 7
84808: ARRAY
84809: PPUSH
84810: CALL_OW 314
84814: NOT
84815: IFFALSE 84937
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
84817: LD_ADDR_VAR 0 10
84821: PUSH
84822: LD_VAR 0 13
84826: PPUSH
84827: LD_VAR 0 4
84831: PUSH
84832: LD_VAR 0 7
84836: ARRAY
84837: PPUSH
84838: CALL_OW 74
84842: ST_TO_ADDR
// if not x then
84843: LD_VAR 0 10
84847: NOT
84848: IFFALSE 84852
// continue ;
84850: GO 84284
// if GetLives ( x ) < 1000 then
84852: LD_VAR 0 10
84856: PPUSH
84857: CALL_OW 256
84861: PUSH
84862: LD_INT 1000
84864: LESS
84865: IFFALSE 84889
// ComRepairVehicle ( group [ i ] , x ) else
84867: LD_VAR 0 4
84871: PUSH
84872: LD_VAR 0 7
84876: ARRAY
84877: PPUSH
84878: LD_VAR 0 10
84882: PPUSH
84883: CALL_OW 129
84887: GO 84937
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
84889: LD_VAR 0 23
84893: PUSH
84894: LD_VAR 0 4
84898: PUSH
84899: LD_VAR 0 7
84903: ARRAY
84904: PPUSH
84905: CALL_OW 256
84909: PUSH
84910: LD_INT 1000
84912: LESS
84913: AND
84914: NOT
84915: IFFALSE 84937
// ComEnterUnit ( group [ i ] , x ) ;
84917: LD_VAR 0 4
84921: PUSH
84922: LD_VAR 0 7
84926: ARRAY
84927: PPUSH
84928: LD_VAR 0 10
84932: PPUSH
84933: CALL_OW 120
// end ; continue ;
84937: GO 84284
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
84939: LD_VAR 0 23
84943: PUSH
84944: LD_VAR 0 4
84948: PUSH
84949: LD_VAR 0 7
84953: ARRAY
84954: PPUSH
84955: CALL_OW 247
84959: PUSH
84960: LD_INT 1
84962: EQUAL
84963: AND
84964: IFFALSE 85442
// begin if group [ i ] in healers then
84966: LD_VAR 0 4
84970: PUSH
84971: LD_VAR 0 7
84975: ARRAY
84976: PUSH
84977: LD_VAR 0 31
84981: IN
84982: IFFALSE 85255
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
84984: LD_VAR 0 4
84988: PUSH
84989: LD_VAR 0 7
84993: ARRAY
84994: PPUSH
84995: LD_VAR 0 23
84999: PPUSH
85000: CALL_OW 308
85004: NOT
85005: PUSH
85006: LD_VAR 0 4
85010: PUSH
85011: LD_VAR 0 7
85015: ARRAY
85016: PPUSH
85017: CALL_OW 314
85021: NOT
85022: AND
85023: IFFALSE 85047
// ComMoveToArea ( group [ i ] , f_heal ) else
85025: LD_VAR 0 4
85029: PUSH
85030: LD_VAR 0 7
85034: ARRAY
85035: PPUSH
85036: LD_VAR 0 23
85040: PPUSH
85041: CALL_OW 113
85045: GO 85253
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
85047: LD_VAR 0 4
85051: PUSH
85052: LD_VAR 0 7
85056: ARRAY
85057: PPUSH
85058: CALL 46197 0 1
85062: PPUSH
85063: CALL_OW 256
85067: PUSH
85068: LD_INT 1000
85070: EQUAL
85071: IFFALSE 85090
// ComStop ( group [ i ] ) else
85073: LD_VAR 0 4
85077: PUSH
85078: LD_VAR 0 7
85082: ARRAY
85083: PPUSH
85084: CALL_OW 141
85088: GO 85253
// if not HasTask ( group [ i ] ) and to_heal then
85090: LD_VAR 0 4
85094: PUSH
85095: LD_VAR 0 7
85099: ARRAY
85100: PPUSH
85101: CALL_OW 314
85105: NOT
85106: PUSH
85107: LD_VAR 0 30
85111: AND
85112: IFFALSE 85253
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
85114: LD_ADDR_VAR 0 13
85118: PUSH
85119: LD_VAR 0 30
85123: PPUSH
85124: LD_INT 3
85126: PUSH
85127: LD_INT 54
85129: PUSH
85130: EMPTY
85131: LIST
85132: PUSH
85133: EMPTY
85134: LIST
85135: LIST
85136: PPUSH
85137: CALL_OW 72
85141: PPUSH
85142: LD_VAR 0 4
85146: PUSH
85147: LD_VAR 0 7
85151: ARRAY
85152: PPUSH
85153: CALL_OW 74
85157: ST_TO_ADDR
// if z then
85158: LD_VAR 0 13
85162: IFFALSE 85253
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
85164: LD_INT 91
85166: PUSH
85167: LD_VAR 0 13
85171: PUSH
85172: LD_INT 10
85174: PUSH
85175: EMPTY
85176: LIST
85177: LIST
85178: LIST
85179: PUSH
85180: LD_INT 81
85182: PUSH
85183: LD_VAR 0 13
85187: PPUSH
85188: CALL_OW 255
85192: PUSH
85193: EMPTY
85194: LIST
85195: LIST
85196: PUSH
85197: EMPTY
85198: LIST
85199: LIST
85200: PPUSH
85201: CALL_OW 69
85205: PUSH
85206: LD_INT 0
85208: EQUAL
85209: IFFALSE 85233
// ComHeal ( group [ i ] , z ) else
85211: LD_VAR 0 4
85215: PUSH
85216: LD_VAR 0 7
85220: ARRAY
85221: PPUSH
85222: LD_VAR 0 13
85226: PPUSH
85227: CALL_OW 128
85231: GO 85253
// ComMoveToArea ( group [ i ] , f_heal ) ;
85233: LD_VAR 0 4
85237: PUSH
85238: LD_VAR 0 7
85242: ARRAY
85243: PPUSH
85244: LD_VAR 0 23
85248: PPUSH
85249: CALL_OW 113
// end ; continue ;
85253: GO 84284
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
85255: LD_VAR 0 4
85259: PUSH
85260: LD_VAR 0 7
85264: ARRAY
85265: PPUSH
85266: CALL_OW 256
85270: PUSH
85271: LD_INT 700
85273: LESS
85274: PUSH
85275: LD_VAR 0 4
85279: PUSH
85280: LD_VAR 0 7
85284: ARRAY
85285: PUSH
85286: LD_VAR 0 30
85290: IN
85291: NOT
85292: AND
85293: IFFALSE 85317
// to_heal := to_heal union group [ i ] ;
85295: LD_ADDR_VAR 0 30
85299: PUSH
85300: LD_VAR 0 30
85304: PUSH
85305: LD_VAR 0 4
85309: PUSH
85310: LD_VAR 0 7
85314: ARRAY
85315: UNION
85316: ST_TO_ADDR
// if group [ i ] in to_heal then
85317: LD_VAR 0 4
85321: PUSH
85322: LD_VAR 0 7
85326: ARRAY
85327: PUSH
85328: LD_VAR 0 30
85332: IN
85333: IFFALSE 85442
// begin if GetLives ( group [ i ] ) = 1000 then
85335: LD_VAR 0 4
85339: PUSH
85340: LD_VAR 0 7
85344: ARRAY
85345: PPUSH
85346: CALL_OW 256
85350: PUSH
85351: LD_INT 1000
85353: EQUAL
85354: IFFALSE 85380
// to_heal := to_heal diff group [ i ] else
85356: LD_ADDR_VAR 0 30
85360: PUSH
85361: LD_VAR 0 30
85365: PUSH
85366: LD_VAR 0 4
85370: PUSH
85371: LD_VAR 0 7
85375: ARRAY
85376: DIFF
85377: ST_TO_ADDR
85378: GO 85442
// begin if not IsInArea ( group [ i ] , to_heal ) then
85380: LD_VAR 0 4
85384: PUSH
85385: LD_VAR 0 7
85389: ARRAY
85390: PPUSH
85391: LD_VAR 0 30
85395: PPUSH
85396: CALL_OW 308
85400: NOT
85401: IFFALSE 85425
// ComMoveToArea ( group [ i ] , f_heal ) else
85403: LD_VAR 0 4
85407: PUSH
85408: LD_VAR 0 7
85412: ARRAY
85413: PPUSH
85414: LD_VAR 0 23
85418: PPUSH
85419: CALL_OW 113
85423: GO 85440
// ComHold ( group [ i ] ) ;
85425: LD_VAR 0 4
85429: PUSH
85430: LD_VAR 0 7
85434: ARRAY
85435: PPUSH
85436: CALL_OW 140
// continue ;
85440: GO 84284
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
85442: LD_VAR 0 4
85446: PUSH
85447: LD_VAR 0 7
85451: ARRAY
85452: PPUSH
85453: LD_INT 10
85455: PPUSH
85456: CALL 43968 0 2
85460: NOT
85461: PUSH
85462: LD_VAR 0 16
85466: PUSH
85467: LD_VAR 0 7
85471: ARRAY
85472: PUSH
85473: EMPTY
85474: EQUAL
85475: NOT
85476: AND
85477: IFFALSE 85743
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
85479: LD_VAR 0 4
85483: PUSH
85484: LD_VAR 0 7
85488: ARRAY
85489: PPUSH
85490: CALL_OW 262
85494: PUSH
85495: LD_INT 1
85497: PUSH
85498: LD_INT 2
85500: PUSH
85501: EMPTY
85502: LIST
85503: LIST
85504: IN
85505: IFFALSE 85546
// if GetFuel ( group [ i ] ) < 10 then
85507: LD_VAR 0 4
85511: PUSH
85512: LD_VAR 0 7
85516: ARRAY
85517: PPUSH
85518: CALL_OW 261
85522: PUSH
85523: LD_INT 10
85525: LESS
85526: IFFALSE 85546
// SetFuel ( group [ i ] , 12 ) ;
85528: LD_VAR 0 4
85532: PUSH
85533: LD_VAR 0 7
85537: ARRAY
85538: PPUSH
85539: LD_INT 12
85541: PPUSH
85542: CALL_OW 240
// if units_path [ i ] then
85546: LD_VAR 0 16
85550: PUSH
85551: LD_VAR 0 7
85555: ARRAY
85556: IFFALSE 85741
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
85558: LD_VAR 0 4
85562: PUSH
85563: LD_VAR 0 7
85567: ARRAY
85568: PPUSH
85569: LD_VAR 0 16
85573: PUSH
85574: LD_VAR 0 7
85578: ARRAY
85579: PUSH
85580: LD_INT 1
85582: ARRAY
85583: PUSH
85584: LD_INT 1
85586: ARRAY
85587: PPUSH
85588: LD_VAR 0 16
85592: PUSH
85593: LD_VAR 0 7
85597: ARRAY
85598: PUSH
85599: LD_INT 1
85601: ARRAY
85602: PUSH
85603: LD_INT 2
85605: ARRAY
85606: PPUSH
85607: CALL_OW 297
85611: PUSH
85612: LD_INT 6
85614: GREATER
85615: IFFALSE 85690
// begin if not HasTask ( group [ i ] ) then
85617: LD_VAR 0 4
85621: PUSH
85622: LD_VAR 0 7
85626: ARRAY
85627: PPUSH
85628: CALL_OW 314
85632: NOT
85633: IFFALSE 85688
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
85635: LD_VAR 0 4
85639: PUSH
85640: LD_VAR 0 7
85644: ARRAY
85645: PPUSH
85646: LD_VAR 0 16
85650: PUSH
85651: LD_VAR 0 7
85655: ARRAY
85656: PUSH
85657: LD_INT 1
85659: ARRAY
85660: PUSH
85661: LD_INT 1
85663: ARRAY
85664: PPUSH
85665: LD_VAR 0 16
85669: PUSH
85670: LD_VAR 0 7
85674: ARRAY
85675: PUSH
85676: LD_INT 1
85678: ARRAY
85679: PUSH
85680: LD_INT 2
85682: ARRAY
85683: PPUSH
85684: CALL_OW 114
// end else
85688: GO 85741
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
85690: LD_ADDR_VAR 0 15
85694: PUSH
85695: LD_VAR 0 16
85699: PUSH
85700: LD_VAR 0 7
85704: ARRAY
85705: PPUSH
85706: LD_INT 1
85708: PPUSH
85709: CALL_OW 3
85713: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
85714: LD_ADDR_VAR 0 16
85718: PUSH
85719: LD_VAR 0 16
85723: PPUSH
85724: LD_VAR 0 7
85728: PPUSH
85729: LD_VAR 0 15
85733: PPUSH
85734: CALL_OW 1
85738: ST_TO_ADDR
// continue ;
85739: GO 84284
// end ; end ; end else
85741: GO 88405
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
85743: LD_ADDR_VAR 0 14
85747: PUSH
85748: LD_INT 81
85750: PUSH
85751: LD_VAR 0 4
85755: PUSH
85756: LD_VAR 0 7
85760: ARRAY
85761: PPUSH
85762: CALL_OW 255
85766: PUSH
85767: EMPTY
85768: LIST
85769: LIST
85770: PPUSH
85771: CALL_OW 69
85775: ST_TO_ADDR
// if not tmp then
85776: LD_VAR 0 14
85780: NOT
85781: IFFALSE 85785
// continue ;
85783: GO 84284
// if f_ignore_area then
85785: LD_VAR 0 17
85789: IFFALSE 85877
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
85791: LD_ADDR_VAR 0 15
85795: PUSH
85796: LD_VAR 0 14
85800: PPUSH
85801: LD_INT 3
85803: PUSH
85804: LD_INT 92
85806: PUSH
85807: LD_VAR 0 17
85811: PUSH
85812: LD_INT 1
85814: ARRAY
85815: PUSH
85816: LD_VAR 0 17
85820: PUSH
85821: LD_INT 2
85823: ARRAY
85824: PUSH
85825: LD_VAR 0 17
85829: PUSH
85830: LD_INT 3
85832: ARRAY
85833: PUSH
85834: EMPTY
85835: LIST
85836: LIST
85837: LIST
85838: LIST
85839: PUSH
85840: EMPTY
85841: LIST
85842: LIST
85843: PPUSH
85844: CALL_OW 72
85848: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
85849: LD_VAR 0 14
85853: PUSH
85854: LD_VAR 0 15
85858: DIFF
85859: IFFALSE 85877
// tmp := tmp diff tmp2 ;
85861: LD_ADDR_VAR 0 14
85865: PUSH
85866: LD_VAR 0 14
85870: PUSH
85871: LD_VAR 0 15
85875: DIFF
85876: ST_TO_ADDR
// end ; if not f_murder then
85877: LD_VAR 0 20
85881: NOT
85882: IFFALSE 85940
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
85884: LD_ADDR_VAR 0 15
85888: PUSH
85889: LD_VAR 0 14
85893: PPUSH
85894: LD_INT 3
85896: PUSH
85897: LD_INT 50
85899: PUSH
85900: EMPTY
85901: LIST
85902: PUSH
85903: EMPTY
85904: LIST
85905: LIST
85906: PPUSH
85907: CALL_OW 72
85911: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
85912: LD_VAR 0 14
85916: PUSH
85917: LD_VAR 0 15
85921: DIFF
85922: IFFALSE 85940
// tmp := tmp diff tmp2 ;
85924: LD_ADDR_VAR 0 14
85928: PUSH
85929: LD_VAR 0 14
85933: PUSH
85934: LD_VAR 0 15
85938: DIFF
85939: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
85940: LD_ADDR_VAR 0 14
85944: PUSH
85945: LD_VAR 0 4
85949: PUSH
85950: LD_VAR 0 7
85954: ARRAY
85955: PPUSH
85956: LD_VAR 0 14
85960: PPUSH
85961: LD_INT 1
85963: PPUSH
85964: LD_INT 1
85966: PPUSH
85967: CALL 16512 0 4
85971: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
85972: LD_VAR 0 4
85976: PUSH
85977: LD_VAR 0 7
85981: ARRAY
85982: PPUSH
85983: CALL_OW 257
85987: PUSH
85988: LD_INT 1
85990: EQUAL
85991: IFFALSE 86439
// begin if WantPlant ( group [ i ] ) then
85993: LD_VAR 0 4
85997: PUSH
85998: LD_VAR 0 7
86002: ARRAY
86003: PPUSH
86004: CALL 16013 0 1
86008: IFFALSE 86012
// continue ;
86010: GO 84284
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
86012: LD_VAR 0 18
86016: PUSH
86017: LD_VAR 0 4
86021: PUSH
86022: LD_VAR 0 7
86026: ARRAY
86027: PPUSH
86028: CALL_OW 310
86032: NOT
86033: AND
86034: PUSH
86035: LD_VAR 0 14
86039: PUSH
86040: LD_INT 1
86042: ARRAY
86043: PUSH
86044: LD_VAR 0 14
86048: PPUSH
86049: LD_INT 21
86051: PUSH
86052: LD_INT 2
86054: PUSH
86055: EMPTY
86056: LIST
86057: LIST
86058: PUSH
86059: LD_INT 58
86061: PUSH
86062: EMPTY
86063: LIST
86064: PUSH
86065: EMPTY
86066: LIST
86067: LIST
86068: PPUSH
86069: CALL_OW 72
86073: IN
86074: AND
86075: IFFALSE 86111
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
86077: LD_VAR 0 4
86081: PUSH
86082: LD_VAR 0 7
86086: ARRAY
86087: PPUSH
86088: LD_VAR 0 14
86092: PUSH
86093: LD_INT 1
86095: ARRAY
86096: PPUSH
86097: CALL_OW 120
// attacking := true ;
86101: LD_ADDR_VAR 0 29
86105: PUSH
86106: LD_INT 1
86108: ST_TO_ADDR
// continue ;
86109: GO 84284
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
86111: LD_VAR 0 26
86115: PUSH
86116: LD_VAR 0 4
86120: PUSH
86121: LD_VAR 0 7
86125: ARRAY
86126: PPUSH
86127: CALL_OW 257
86131: PUSH
86132: LD_INT 1
86134: EQUAL
86135: AND
86136: PUSH
86137: LD_VAR 0 4
86141: PUSH
86142: LD_VAR 0 7
86146: ARRAY
86147: PPUSH
86148: CALL_OW 256
86152: PUSH
86153: LD_INT 800
86155: LESS
86156: AND
86157: PUSH
86158: LD_VAR 0 4
86162: PUSH
86163: LD_VAR 0 7
86167: ARRAY
86168: PPUSH
86169: CALL_OW 318
86173: NOT
86174: AND
86175: IFFALSE 86192
// ComCrawl ( group [ i ] ) ;
86177: LD_VAR 0 4
86181: PUSH
86182: LD_VAR 0 7
86186: ARRAY
86187: PPUSH
86188: CALL_OW 137
// if f_mines then
86192: LD_VAR 0 21
86196: IFFALSE 86439
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
86198: LD_VAR 0 14
86202: PUSH
86203: LD_INT 1
86205: ARRAY
86206: PPUSH
86207: CALL_OW 247
86211: PUSH
86212: LD_INT 3
86214: EQUAL
86215: PUSH
86216: LD_VAR 0 14
86220: PUSH
86221: LD_INT 1
86223: ARRAY
86224: PUSH
86225: LD_VAR 0 27
86229: IN
86230: NOT
86231: AND
86232: IFFALSE 86439
// begin x := GetX ( tmp [ 1 ] ) ;
86234: LD_ADDR_VAR 0 10
86238: PUSH
86239: LD_VAR 0 14
86243: PUSH
86244: LD_INT 1
86246: ARRAY
86247: PPUSH
86248: CALL_OW 250
86252: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
86253: LD_ADDR_VAR 0 11
86257: PUSH
86258: LD_VAR 0 14
86262: PUSH
86263: LD_INT 1
86265: ARRAY
86266: PPUSH
86267: CALL_OW 251
86271: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
86272: LD_ADDR_VAR 0 12
86276: PUSH
86277: LD_VAR 0 4
86281: PUSH
86282: LD_VAR 0 7
86286: ARRAY
86287: PPUSH
86288: CALL 44053 0 1
86292: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
86293: LD_VAR 0 4
86297: PUSH
86298: LD_VAR 0 7
86302: ARRAY
86303: PPUSH
86304: LD_VAR 0 10
86308: PPUSH
86309: LD_VAR 0 11
86313: PPUSH
86314: LD_VAR 0 14
86318: PUSH
86319: LD_INT 1
86321: ARRAY
86322: PPUSH
86323: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
86327: LD_VAR 0 4
86331: PUSH
86332: LD_VAR 0 7
86336: ARRAY
86337: PPUSH
86338: LD_VAR 0 10
86342: PPUSH
86343: LD_VAR 0 12
86347: PPUSH
86348: LD_INT 7
86350: PPUSH
86351: CALL_OW 272
86355: PPUSH
86356: LD_VAR 0 11
86360: PPUSH
86361: LD_VAR 0 12
86365: PPUSH
86366: LD_INT 7
86368: PPUSH
86369: CALL_OW 273
86373: PPUSH
86374: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
86378: LD_VAR 0 4
86382: PUSH
86383: LD_VAR 0 7
86387: ARRAY
86388: PPUSH
86389: LD_INT 71
86391: PPUSH
86392: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
86396: LD_ADDR_VAR 0 27
86400: PUSH
86401: LD_VAR 0 27
86405: PPUSH
86406: LD_VAR 0 27
86410: PUSH
86411: LD_INT 1
86413: PLUS
86414: PPUSH
86415: LD_VAR 0 14
86419: PUSH
86420: LD_INT 1
86422: ARRAY
86423: PPUSH
86424: CALL_OW 1
86428: ST_TO_ADDR
// attacking := true ;
86429: LD_ADDR_VAR 0 29
86433: PUSH
86434: LD_INT 1
86436: ST_TO_ADDR
// continue ;
86437: GO 84284
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
86439: LD_VAR 0 4
86443: PUSH
86444: LD_VAR 0 7
86448: ARRAY
86449: PPUSH
86450: CALL_OW 257
86454: PUSH
86455: LD_INT 17
86457: EQUAL
86458: PUSH
86459: LD_VAR 0 4
86463: PUSH
86464: LD_VAR 0 7
86468: ARRAY
86469: PPUSH
86470: CALL_OW 110
86474: PUSH
86475: LD_INT 71
86477: EQUAL
86478: NOT
86479: AND
86480: IFFALSE 86626
// begin attacking := false ;
86482: LD_ADDR_VAR 0 29
86486: PUSH
86487: LD_INT 0
86489: ST_TO_ADDR
// k := 5 ;
86490: LD_ADDR_VAR 0 9
86494: PUSH
86495: LD_INT 5
86497: ST_TO_ADDR
// if tmp < k then
86498: LD_VAR 0 14
86502: PUSH
86503: LD_VAR 0 9
86507: LESS
86508: IFFALSE 86520
// k := tmp ;
86510: LD_ADDR_VAR 0 9
86514: PUSH
86515: LD_VAR 0 14
86519: ST_TO_ADDR
// for j = 1 to k do
86520: LD_ADDR_VAR 0 8
86524: PUSH
86525: DOUBLE
86526: LD_INT 1
86528: DEC
86529: ST_TO_ADDR
86530: LD_VAR 0 9
86534: PUSH
86535: FOR_TO
86536: IFFALSE 86624
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
86538: LD_VAR 0 14
86542: PUSH
86543: LD_VAR 0 8
86547: ARRAY
86548: PUSH
86549: LD_VAR 0 14
86553: PPUSH
86554: LD_INT 58
86556: PUSH
86557: EMPTY
86558: LIST
86559: PPUSH
86560: CALL_OW 72
86564: IN
86565: NOT
86566: IFFALSE 86622
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
86568: LD_VAR 0 4
86572: PUSH
86573: LD_VAR 0 7
86577: ARRAY
86578: PPUSH
86579: LD_VAR 0 14
86583: PUSH
86584: LD_VAR 0 8
86588: ARRAY
86589: PPUSH
86590: CALL_OW 115
// attacking := true ;
86594: LD_ADDR_VAR 0 29
86598: PUSH
86599: LD_INT 1
86601: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
86602: LD_VAR 0 4
86606: PUSH
86607: LD_VAR 0 7
86611: ARRAY
86612: PPUSH
86613: LD_INT 71
86615: PPUSH
86616: CALL_OW 109
// continue ;
86620: GO 86535
// end ; end ;
86622: GO 86535
86624: POP
86625: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
86626: LD_VAR 0 4
86630: PUSH
86631: LD_VAR 0 7
86635: ARRAY
86636: PPUSH
86637: CALL_OW 257
86641: PUSH
86642: LD_INT 8
86644: EQUAL
86645: PUSH
86646: LD_VAR 0 4
86650: PUSH
86651: LD_VAR 0 7
86655: ARRAY
86656: PPUSH
86657: CALL_OW 264
86661: PUSH
86662: LD_INT 28
86664: PUSH
86665: LD_INT 45
86667: PUSH
86668: LD_INT 7
86670: PUSH
86671: LD_INT 47
86673: PUSH
86674: EMPTY
86675: LIST
86676: LIST
86677: LIST
86678: LIST
86679: IN
86680: OR
86681: IFFALSE 86937
// begin attacking := false ;
86683: LD_ADDR_VAR 0 29
86687: PUSH
86688: LD_INT 0
86690: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
86691: LD_VAR 0 14
86695: PUSH
86696: LD_INT 1
86698: ARRAY
86699: PPUSH
86700: CALL_OW 266
86704: PUSH
86705: LD_INT 32
86707: PUSH
86708: LD_INT 31
86710: PUSH
86711: LD_INT 33
86713: PUSH
86714: LD_INT 4
86716: PUSH
86717: LD_INT 5
86719: PUSH
86720: EMPTY
86721: LIST
86722: LIST
86723: LIST
86724: LIST
86725: LIST
86726: IN
86727: IFFALSE 86913
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
86729: LD_ADDR_VAR 0 9
86733: PUSH
86734: LD_VAR 0 14
86738: PUSH
86739: LD_INT 1
86741: ARRAY
86742: PPUSH
86743: CALL_OW 266
86747: PPUSH
86748: LD_VAR 0 14
86752: PUSH
86753: LD_INT 1
86755: ARRAY
86756: PPUSH
86757: CALL_OW 250
86761: PPUSH
86762: LD_VAR 0 14
86766: PUSH
86767: LD_INT 1
86769: ARRAY
86770: PPUSH
86771: CALL_OW 251
86775: PPUSH
86776: LD_VAR 0 14
86780: PUSH
86781: LD_INT 1
86783: ARRAY
86784: PPUSH
86785: CALL_OW 254
86789: PPUSH
86790: LD_VAR 0 14
86794: PUSH
86795: LD_INT 1
86797: ARRAY
86798: PPUSH
86799: CALL_OW 248
86803: PPUSH
86804: LD_INT 0
86806: PPUSH
86807: CALL 25423 0 6
86811: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
86812: LD_ADDR_VAR 0 8
86816: PUSH
86817: LD_VAR 0 4
86821: PUSH
86822: LD_VAR 0 7
86826: ARRAY
86827: PPUSH
86828: LD_VAR 0 9
86832: PPUSH
86833: CALL 44166 0 2
86837: ST_TO_ADDR
// if j then
86838: LD_VAR 0 8
86842: IFFALSE 86911
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
86844: LD_VAR 0 8
86848: PUSH
86849: LD_INT 1
86851: ARRAY
86852: PPUSH
86853: LD_VAR 0 8
86857: PUSH
86858: LD_INT 2
86860: ARRAY
86861: PPUSH
86862: CALL_OW 488
86866: IFFALSE 86911
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
86868: LD_VAR 0 4
86872: PUSH
86873: LD_VAR 0 7
86877: ARRAY
86878: PPUSH
86879: LD_VAR 0 8
86883: PUSH
86884: LD_INT 1
86886: ARRAY
86887: PPUSH
86888: LD_VAR 0 8
86892: PUSH
86893: LD_INT 2
86895: ARRAY
86896: PPUSH
86897: CALL_OW 116
// attacking := true ;
86901: LD_ADDR_VAR 0 29
86905: PUSH
86906: LD_INT 1
86908: ST_TO_ADDR
// continue ;
86909: GO 84284
// end ; end else
86911: GO 86937
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86913: LD_VAR 0 4
86917: PUSH
86918: LD_VAR 0 7
86922: ARRAY
86923: PPUSH
86924: LD_VAR 0 14
86928: PUSH
86929: LD_INT 1
86931: ARRAY
86932: PPUSH
86933: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
86937: LD_VAR 0 4
86941: PUSH
86942: LD_VAR 0 7
86946: ARRAY
86947: PPUSH
86948: CALL_OW 265
86952: PUSH
86953: LD_INT 11
86955: EQUAL
86956: IFFALSE 87234
// begin k := 10 ;
86958: LD_ADDR_VAR 0 9
86962: PUSH
86963: LD_INT 10
86965: ST_TO_ADDR
// x := 0 ;
86966: LD_ADDR_VAR 0 10
86970: PUSH
86971: LD_INT 0
86973: ST_TO_ADDR
// if tmp < k then
86974: LD_VAR 0 14
86978: PUSH
86979: LD_VAR 0 9
86983: LESS
86984: IFFALSE 86996
// k := tmp ;
86986: LD_ADDR_VAR 0 9
86990: PUSH
86991: LD_VAR 0 14
86995: ST_TO_ADDR
// for j = k downto 1 do
86996: LD_ADDR_VAR 0 8
87000: PUSH
87001: DOUBLE
87002: LD_VAR 0 9
87006: INC
87007: ST_TO_ADDR
87008: LD_INT 1
87010: PUSH
87011: FOR_DOWNTO
87012: IFFALSE 87087
// begin if GetType ( tmp [ j ] ) = unit_human then
87014: LD_VAR 0 14
87018: PUSH
87019: LD_VAR 0 8
87023: ARRAY
87024: PPUSH
87025: CALL_OW 247
87029: PUSH
87030: LD_INT 1
87032: EQUAL
87033: IFFALSE 87085
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
87035: LD_VAR 0 4
87039: PUSH
87040: LD_VAR 0 7
87044: ARRAY
87045: PPUSH
87046: LD_VAR 0 14
87050: PUSH
87051: LD_VAR 0 8
87055: ARRAY
87056: PPUSH
87057: CALL 44420 0 2
// x := tmp [ j ] ;
87061: LD_ADDR_VAR 0 10
87065: PUSH
87066: LD_VAR 0 14
87070: PUSH
87071: LD_VAR 0 8
87075: ARRAY
87076: ST_TO_ADDR
// attacking := true ;
87077: LD_ADDR_VAR 0 29
87081: PUSH
87082: LD_INT 1
87084: ST_TO_ADDR
// end ; end ;
87085: GO 87011
87087: POP
87088: POP
// if not x then
87089: LD_VAR 0 10
87093: NOT
87094: IFFALSE 87234
// begin attacking := true ;
87096: LD_ADDR_VAR 0 29
87100: PUSH
87101: LD_INT 1
87103: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
87104: LD_VAR 0 4
87108: PUSH
87109: LD_VAR 0 7
87113: ARRAY
87114: PPUSH
87115: CALL_OW 250
87119: PPUSH
87120: LD_VAR 0 4
87124: PUSH
87125: LD_VAR 0 7
87129: ARRAY
87130: PPUSH
87131: CALL_OW 251
87135: PPUSH
87136: CALL_OW 546
87140: PUSH
87141: LD_INT 2
87143: ARRAY
87144: PUSH
87145: LD_VAR 0 14
87149: PUSH
87150: LD_INT 1
87152: ARRAY
87153: PPUSH
87154: CALL_OW 250
87158: PPUSH
87159: LD_VAR 0 14
87163: PUSH
87164: LD_INT 1
87166: ARRAY
87167: PPUSH
87168: CALL_OW 251
87172: PPUSH
87173: CALL_OW 546
87177: PUSH
87178: LD_INT 2
87180: ARRAY
87181: EQUAL
87182: IFFALSE 87210
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
87184: LD_VAR 0 4
87188: PUSH
87189: LD_VAR 0 7
87193: ARRAY
87194: PPUSH
87195: LD_VAR 0 14
87199: PUSH
87200: LD_INT 1
87202: ARRAY
87203: PPUSH
87204: CALL 44420 0 2
87208: GO 87234
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
87210: LD_VAR 0 4
87214: PUSH
87215: LD_VAR 0 7
87219: ARRAY
87220: PPUSH
87221: LD_VAR 0 14
87225: PUSH
87226: LD_INT 1
87228: ARRAY
87229: PPUSH
87230: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
87234: LD_VAR 0 4
87238: PUSH
87239: LD_VAR 0 7
87243: ARRAY
87244: PPUSH
87245: CALL_OW 264
87249: PUSH
87250: LD_INT 29
87252: EQUAL
87253: IFFALSE 87619
// begin if WantsToAttack ( group [ i ] ) in bombed then
87255: LD_VAR 0 4
87259: PUSH
87260: LD_VAR 0 7
87264: ARRAY
87265: PPUSH
87266: CALL_OW 319
87270: PUSH
87271: LD_VAR 0 28
87275: IN
87276: IFFALSE 87280
// continue ;
87278: GO 84284
// k := 8 ;
87280: LD_ADDR_VAR 0 9
87284: PUSH
87285: LD_INT 8
87287: ST_TO_ADDR
// x := 0 ;
87288: LD_ADDR_VAR 0 10
87292: PUSH
87293: LD_INT 0
87295: ST_TO_ADDR
// if tmp < k then
87296: LD_VAR 0 14
87300: PUSH
87301: LD_VAR 0 9
87305: LESS
87306: IFFALSE 87318
// k := tmp ;
87308: LD_ADDR_VAR 0 9
87312: PUSH
87313: LD_VAR 0 14
87317: ST_TO_ADDR
// for j = 1 to k do
87318: LD_ADDR_VAR 0 8
87322: PUSH
87323: DOUBLE
87324: LD_INT 1
87326: DEC
87327: ST_TO_ADDR
87328: LD_VAR 0 9
87332: PUSH
87333: FOR_TO
87334: IFFALSE 87466
// begin if GetType ( tmp [ j ] ) = unit_building then
87336: LD_VAR 0 14
87340: PUSH
87341: LD_VAR 0 8
87345: ARRAY
87346: PPUSH
87347: CALL_OW 247
87351: PUSH
87352: LD_INT 3
87354: EQUAL
87355: IFFALSE 87464
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
87357: LD_VAR 0 14
87361: PUSH
87362: LD_VAR 0 8
87366: ARRAY
87367: PUSH
87368: LD_VAR 0 28
87372: IN
87373: NOT
87374: PUSH
87375: LD_VAR 0 14
87379: PUSH
87380: LD_VAR 0 8
87384: ARRAY
87385: PPUSH
87386: CALL_OW 313
87390: AND
87391: IFFALSE 87464
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
87393: LD_VAR 0 4
87397: PUSH
87398: LD_VAR 0 7
87402: ARRAY
87403: PPUSH
87404: LD_VAR 0 14
87408: PUSH
87409: LD_VAR 0 8
87413: ARRAY
87414: PPUSH
87415: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
87419: LD_ADDR_VAR 0 28
87423: PUSH
87424: LD_VAR 0 28
87428: PPUSH
87429: LD_VAR 0 28
87433: PUSH
87434: LD_INT 1
87436: PLUS
87437: PPUSH
87438: LD_VAR 0 14
87442: PUSH
87443: LD_VAR 0 8
87447: ARRAY
87448: PPUSH
87449: CALL_OW 1
87453: ST_TO_ADDR
// attacking := true ;
87454: LD_ADDR_VAR 0 29
87458: PUSH
87459: LD_INT 1
87461: ST_TO_ADDR
// break ;
87462: GO 87466
// end ; end ;
87464: GO 87333
87466: POP
87467: POP
// if not attacking and f_attack_depot then
87468: LD_VAR 0 29
87472: NOT
87473: PUSH
87474: LD_VAR 0 25
87478: AND
87479: IFFALSE 87574
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
87481: LD_ADDR_VAR 0 13
87485: PUSH
87486: LD_VAR 0 14
87490: PPUSH
87491: LD_INT 2
87493: PUSH
87494: LD_INT 30
87496: PUSH
87497: LD_INT 0
87499: PUSH
87500: EMPTY
87501: LIST
87502: LIST
87503: PUSH
87504: LD_INT 30
87506: PUSH
87507: LD_INT 1
87509: PUSH
87510: EMPTY
87511: LIST
87512: LIST
87513: PUSH
87514: EMPTY
87515: LIST
87516: LIST
87517: LIST
87518: PPUSH
87519: CALL_OW 72
87523: ST_TO_ADDR
// if z then
87524: LD_VAR 0 13
87528: IFFALSE 87574
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
87530: LD_VAR 0 4
87534: PUSH
87535: LD_VAR 0 7
87539: ARRAY
87540: PPUSH
87541: LD_VAR 0 13
87545: PPUSH
87546: LD_VAR 0 4
87550: PUSH
87551: LD_VAR 0 7
87555: ARRAY
87556: PPUSH
87557: CALL_OW 74
87561: PPUSH
87562: CALL_OW 115
// attacking := true ;
87566: LD_ADDR_VAR 0 29
87570: PUSH
87571: LD_INT 1
87573: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
87574: LD_VAR 0 4
87578: PUSH
87579: LD_VAR 0 7
87583: ARRAY
87584: PPUSH
87585: CALL_OW 256
87589: PUSH
87590: LD_INT 500
87592: LESS
87593: IFFALSE 87619
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
87595: LD_VAR 0 4
87599: PUSH
87600: LD_VAR 0 7
87604: ARRAY
87605: PPUSH
87606: LD_VAR 0 14
87610: PUSH
87611: LD_INT 1
87613: ARRAY
87614: PPUSH
87615: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
87619: LD_VAR 0 4
87623: PUSH
87624: LD_VAR 0 7
87628: ARRAY
87629: PPUSH
87630: CALL_OW 264
87634: PUSH
87635: LD_INT 49
87637: EQUAL
87638: IFFALSE 87759
// begin if not HasTask ( group [ i ] ) then
87640: LD_VAR 0 4
87644: PUSH
87645: LD_VAR 0 7
87649: ARRAY
87650: PPUSH
87651: CALL_OW 314
87655: NOT
87656: IFFALSE 87759
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
87658: LD_ADDR_VAR 0 9
87662: PUSH
87663: LD_INT 81
87665: PUSH
87666: LD_VAR 0 4
87670: PUSH
87671: LD_VAR 0 7
87675: ARRAY
87676: PPUSH
87677: CALL_OW 255
87681: PUSH
87682: EMPTY
87683: LIST
87684: LIST
87685: PPUSH
87686: CALL_OW 69
87690: PPUSH
87691: LD_VAR 0 4
87695: PUSH
87696: LD_VAR 0 7
87700: ARRAY
87701: PPUSH
87702: CALL_OW 74
87706: ST_TO_ADDR
// if k then
87707: LD_VAR 0 9
87711: IFFALSE 87759
// if GetDistUnits ( group [ i ] , k ) > 10 then
87713: LD_VAR 0 4
87717: PUSH
87718: LD_VAR 0 7
87722: ARRAY
87723: PPUSH
87724: LD_VAR 0 9
87728: PPUSH
87729: CALL_OW 296
87733: PUSH
87734: LD_INT 10
87736: GREATER
87737: IFFALSE 87759
// ComMoveUnit ( group [ i ] , k ) ;
87739: LD_VAR 0 4
87743: PUSH
87744: LD_VAR 0 7
87748: ARRAY
87749: PPUSH
87750: LD_VAR 0 9
87754: PPUSH
87755: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
87759: LD_VAR 0 4
87763: PUSH
87764: LD_VAR 0 7
87768: ARRAY
87769: PPUSH
87770: CALL_OW 256
87774: PUSH
87775: LD_INT 250
87777: LESS
87778: PUSH
87779: LD_VAR 0 4
87783: PUSH
87784: LD_VAR 0 7
87788: ARRAY
87789: PUSH
87790: LD_INT 21
87792: PUSH
87793: LD_INT 2
87795: PUSH
87796: EMPTY
87797: LIST
87798: LIST
87799: PUSH
87800: LD_INT 23
87802: PUSH
87803: LD_INT 2
87805: PUSH
87806: EMPTY
87807: LIST
87808: LIST
87809: PUSH
87810: EMPTY
87811: LIST
87812: LIST
87813: PPUSH
87814: CALL_OW 69
87818: IN
87819: AND
87820: IFFALSE 87945
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
87822: LD_ADDR_VAR 0 9
87826: PUSH
87827: LD_OWVAR 3
87831: PUSH
87832: LD_VAR 0 4
87836: PUSH
87837: LD_VAR 0 7
87841: ARRAY
87842: DIFF
87843: PPUSH
87844: LD_VAR 0 4
87848: PUSH
87849: LD_VAR 0 7
87853: ARRAY
87854: PPUSH
87855: CALL_OW 74
87859: ST_TO_ADDR
// if not k then
87860: LD_VAR 0 9
87864: NOT
87865: IFFALSE 87869
// continue ;
87867: GO 84284
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
87869: LD_VAR 0 9
87873: PUSH
87874: LD_INT 81
87876: PUSH
87877: LD_VAR 0 4
87881: PUSH
87882: LD_VAR 0 7
87886: ARRAY
87887: PPUSH
87888: CALL_OW 255
87892: PUSH
87893: EMPTY
87894: LIST
87895: LIST
87896: PPUSH
87897: CALL_OW 69
87901: IN
87902: PUSH
87903: LD_VAR 0 9
87907: PPUSH
87908: LD_VAR 0 4
87912: PUSH
87913: LD_VAR 0 7
87917: ARRAY
87918: PPUSH
87919: CALL_OW 296
87923: PUSH
87924: LD_INT 5
87926: LESS
87927: AND
87928: IFFALSE 87945
// ComAutodestruct ( group [ i ] ) ;
87930: LD_VAR 0 4
87934: PUSH
87935: LD_VAR 0 7
87939: ARRAY
87940: PPUSH
87941: CALL 44318 0 1
// end ; if f_attack_depot then
87945: LD_VAR 0 25
87949: IFFALSE 88061
// begin k := 6 ;
87951: LD_ADDR_VAR 0 9
87955: PUSH
87956: LD_INT 6
87958: ST_TO_ADDR
// if tmp < k then
87959: LD_VAR 0 14
87963: PUSH
87964: LD_VAR 0 9
87968: LESS
87969: IFFALSE 87981
// k := tmp ;
87971: LD_ADDR_VAR 0 9
87975: PUSH
87976: LD_VAR 0 14
87980: ST_TO_ADDR
// for j = 1 to k do
87981: LD_ADDR_VAR 0 8
87985: PUSH
87986: DOUBLE
87987: LD_INT 1
87989: DEC
87990: ST_TO_ADDR
87991: LD_VAR 0 9
87995: PUSH
87996: FOR_TO
87997: IFFALSE 88059
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
87999: LD_VAR 0 8
88003: PPUSH
88004: CALL_OW 266
88008: PUSH
88009: LD_INT 0
88011: PUSH
88012: LD_INT 1
88014: PUSH
88015: EMPTY
88016: LIST
88017: LIST
88018: IN
88019: IFFALSE 88057
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
88021: LD_VAR 0 4
88025: PUSH
88026: LD_VAR 0 7
88030: ARRAY
88031: PPUSH
88032: LD_VAR 0 14
88036: PUSH
88037: LD_VAR 0 8
88041: ARRAY
88042: PPUSH
88043: CALL_OW 115
// attacking := true ;
88047: LD_ADDR_VAR 0 29
88051: PUSH
88052: LD_INT 1
88054: ST_TO_ADDR
// break ;
88055: GO 88059
// end ;
88057: GO 87996
88059: POP
88060: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
88061: LD_VAR 0 4
88065: PUSH
88066: LD_VAR 0 7
88070: ARRAY
88071: PPUSH
88072: CALL_OW 302
88076: PUSH
88077: LD_VAR 0 29
88081: NOT
88082: AND
88083: IFFALSE 88405
// begin if GetTag ( group [ i ] ) = 71 then
88085: LD_VAR 0 4
88089: PUSH
88090: LD_VAR 0 7
88094: ARRAY
88095: PPUSH
88096: CALL_OW 110
88100: PUSH
88101: LD_INT 71
88103: EQUAL
88104: IFFALSE 88145
// begin if HasTask ( group [ i ] ) then
88106: LD_VAR 0 4
88110: PUSH
88111: LD_VAR 0 7
88115: ARRAY
88116: PPUSH
88117: CALL_OW 314
88121: IFFALSE 88127
// continue else
88123: GO 84284
88125: GO 88145
// SetTag ( group [ i ] , 0 ) ;
88127: LD_VAR 0 4
88131: PUSH
88132: LD_VAR 0 7
88136: ARRAY
88137: PPUSH
88138: LD_INT 0
88140: PPUSH
88141: CALL_OW 109
// end ; k := 8 ;
88145: LD_ADDR_VAR 0 9
88149: PUSH
88150: LD_INT 8
88152: ST_TO_ADDR
// x := 0 ;
88153: LD_ADDR_VAR 0 10
88157: PUSH
88158: LD_INT 0
88160: ST_TO_ADDR
// if tmp < k then
88161: LD_VAR 0 14
88165: PUSH
88166: LD_VAR 0 9
88170: LESS
88171: IFFALSE 88183
// k := tmp ;
88173: LD_ADDR_VAR 0 9
88177: PUSH
88178: LD_VAR 0 14
88182: ST_TO_ADDR
// for j = 1 to k do
88183: LD_ADDR_VAR 0 8
88187: PUSH
88188: DOUBLE
88189: LD_INT 1
88191: DEC
88192: ST_TO_ADDR
88193: LD_VAR 0 9
88197: PUSH
88198: FOR_TO
88199: IFFALSE 88297
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
88201: LD_VAR 0 14
88205: PUSH
88206: LD_VAR 0 8
88210: ARRAY
88211: PPUSH
88212: CALL_OW 247
88216: PUSH
88217: LD_INT 1
88219: EQUAL
88220: PUSH
88221: LD_VAR 0 14
88225: PUSH
88226: LD_VAR 0 8
88230: ARRAY
88231: PPUSH
88232: CALL_OW 256
88236: PUSH
88237: LD_INT 250
88239: LESS
88240: PUSH
88241: LD_VAR 0 20
88245: AND
88246: PUSH
88247: LD_VAR 0 20
88251: NOT
88252: PUSH
88253: LD_VAR 0 14
88257: PUSH
88258: LD_VAR 0 8
88262: ARRAY
88263: PPUSH
88264: CALL_OW 256
88268: PUSH
88269: LD_INT 250
88271: GREATEREQUAL
88272: AND
88273: OR
88274: AND
88275: IFFALSE 88295
// begin x := tmp [ j ] ;
88277: LD_ADDR_VAR 0 10
88281: PUSH
88282: LD_VAR 0 14
88286: PUSH
88287: LD_VAR 0 8
88291: ARRAY
88292: ST_TO_ADDR
// break ;
88293: GO 88297
// end ;
88295: GO 88198
88297: POP
88298: POP
// if x then
88299: LD_VAR 0 10
88303: IFFALSE 88327
// ComAttackUnit ( group [ i ] , x ) else
88305: LD_VAR 0 4
88309: PUSH
88310: LD_VAR 0 7
88314: ARRAY
88315: PPUSH
88316: LD_VAR 0 10
88320: PPUSH
88321: CALL_OW 115
88325: GO 88351
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
88327: LD_VAR 0 4
88331: PUSH
88332: LD_VAR 0 7
88336: ARRAY
88337: PPUSH
88338: LD_VAR 0 14
88342: PUSH
88343: LD_INT 1
88345: ARRAY
88346: PPUSH
88347: CALL_OW 115
// if not HasTask ( group [ i ] ) then
88351: LD_VAR 0 4
88355: PUSH
88356: LD_VAR 0 7
88360: ARRAY
88361: PPUSH
88362: CALL_OW 314
88366: NOT
88367: IFFALSE 88405
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
88369: LD_VAR 0 4
88373: PUSH
88374: LD_VAR 0 7
88378: ARRAY
88379: PPUSH
88380: LD_VAR 0 14
88384: PPUSH
88385: LD_VAR 0 4
88389: PUSH
88390: LD_VAR 0 7
88394: ARRAY
88395: PPUSH
88396: CALL_OW 74
88400: PPUSH
88401: CALL_OW 115
// end ; end ; end ;
88405: GO 84284
88407: POP
88408: POP
// wait ( 0 0$2 ) ;
88409: LD_INT 70
88411: PPUSH
88412: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
88416: LD_VAR 0 4
88420: NOT
88421: PUSH
88422: LD_VAR 0 4
88426: PUSH
88427: EMPTY
88428: EQUAL
88429: OR
88430: PUSH
88431: LD_INT 81
88433: PUSH
88434: LD_VAR 0 35
88438: PUSH
88439: EMPTY
88440: LIST
88441: LIST
88442: PPUSH
88443: CALL_OW 69
88447: NOT
88448: OR
88449: IFFALSE 84269
// end ;
88451: LD_VAR 0 2
88455: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
88456: LD_INT 0
88458: PPUSH
88459: PPUSH
88460: PPUSH
88461: PPUSH
88462: PPUSH
88463: PPUSH
// if not base or not mc_bases [ base ] or not solds then
88464: LD_VAR 0 1
88468: NOT
88469: PUSH
88470: LD_EXP 23
88474: PUSH
88475: LD_VAR 0 1
88479: ARRAY
88480: NOT
88481: OR
88482: PUSH
88483: LD_VAR 0 2
88487: NOT
88488: OR
88489: IFFALSE 88493
// exit ;
88491: GO 89047
// side := mc_sides [ base ] ;
88493: LD_ADDR_VAR 0 6
88497: PUSH
88498: LD_EXP 49
88502: PUSH
88503: LD_VAR 0 1
88507: ARRAY
88508: ST_TO_ADDR
// if not side then
88509: LD_VAR 0 6
88513: NOT
88514: IFFALSE 88518
// exit ;
88516: GO 89047
// for i in solds do
88518: LD_ADDR_VAR 0 7
88522: PUSH
88523: LD_VAR 0 2
88527: PUSH
88528: FOR_IN
88529: IFFALSE 88590
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
88531: LD_VAR 0 7
88535: PPUSH
88536: CALL_OW 310
88540: PPUSH
88541: CALL_OW 266
88545: PUSH
88546: LD_INT 32
88548: PUSH
88549: LD_INT 31
88551: PUSH
88552: EMPTY
88553: LIST
88554: LIST
88555: IN
88556: IFFALSE 88576
// solds := solds diff i else
88558: LD_ADDR_VAR 0 2
88562: PUSH
88563: LD_VAR 0 2
88567: PUSH
88568: LD_VAR 0 7
88572: DIFF
88573: ST_TO_ADDR
88574: GO 88588
// SetTag ( i , 18 ) ;
88576: LD_VAR 0 7
88580: PPUSH
88581: LD_INT 18
88583: PPUSH
88584: CALL_OW 109
88588: GO 88528
88590: POP
88591: POP
// if not solds then
88592: LD_VAR 0 2
88596: NOT
88597: IFFALSE 88601
// exit ;
88599: GO 89047
// repeat wait ( 0 0$2 ) ;
88601: LD_INT 70
88603: PPUSH
88604: CALL_OW 67
// enemy := mc_scan [ base ] ;
88608: LD_ADDR_VAR 0 4
88612: PUSH
88613: LD_EXP 46
88617: PUSH
88618: LD_VAR 0 1
88622: ARRAY
88623: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
88624: LD_EXP 23
88628: PUSH
88629: LD_VAR 0 1
88633: ARRAY
88634: NOT
88635: PUSH
88636: LD_EXP 23
88640: PUSH
88641: LD_VAR 0 1
88645: ARRAY
88646: PUSH
88647: EMPTY
88648: EQUAL
88649: OR
88650: IFFALSE 88687
// begin for i in solds do
88652: LD_ADDR_VAR 0 7
88656: PUSH
88657: LD_VAR 0 2
88661: PUSH
88662: FOR_IN
88663: IFFALSE 88676
// ComStop ( i ) ;
88665: LD_VAR 0 7
88669: PPUSH
88670: CALL_OW 141
88674: GO 88662
88676: POP
88677: POP
// solds := [ ] ;
88678: LD_ADDR_VAR 0 2
88682: PUSH
88683: EMPTY
88684: ST_TO_ADDR
// exit ;
88685: GO 89047
// end ; for i in solds do
88687: LD_ADDR_VAR 0 7
88691: PUSH
88692: LD_VAR 0 2
88696: PUSH
88697: FOR_IN
88698: IFFALSE 89019
// begin if IsInUnit ( i ) then
88700: LD_VAR 0 7
88704: PPUSH
88705: CALL_OW 310
88709: IFFALSE 88720
// ComExitBuilding ( i ) ;
88711: LD_VAR 0 7
88715: PPUSH
88716: CALL_OW 122
// if GetLives ( i ) > 500 then
88720: LD_VAR 0 7
88724: PPUSH
88725: CALL_OW 256
88729: PUSH
88730: LD_INT 500
88732: GREATER
88733: IFFALSE 88786
// begin e := NearestUnitToUnit ( enemy , i ) ;
88735: LD_ADDR_VAR 0 5
88739: PUSH
88740: LD_VAR 0 4
88744: PPUSH
88745: LD_VAR 0 7
88749: PPUSH
88750: CALL_OW 74
88754: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
88755: LD_VAR 0 7
88759: PPUSH
88760: LD_VAR 0 5
88764: PPUSH
88765: CALL_OW 250
88769: PPUSH
88770: LD_VAR 0 5
88774: PPUSH
88775: CALL_OW 251
88779: PPUSH
88780: CALL_OW 114
// end else
88784: GO 89017
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
88786: LD_VAR 0 7
88790: PPUSH
88791: LD_EXP 23
88795: PUSH
88796: LD_VAR 0 1
88800: ARRAY
88801: PPUSH
88802: LD_INT 2
88804: PUSH
88805: LD_INT 30
88807: PUSH
88808: LD_INT 0
88810: PUSH
88811: EMPTY
88812: LIST
88813: LIST
88814: PUSH
88815: LD_INT 30
88817: PUSH
88818: LD_INT 1
88820: PUSH
88821: EMPTY
88822: LIST
88823: LIST
88824: PUSH
88825: LD_INT 30
88827: PUSH
88828: LD_INT 6
88830: PUSH
88831: EMPTY
88832: LIST
88833: LIST
88834: PUSH
88835: EMPTY
88836: LIST
88837: LIST
88838: LIST
88839: LIST
88840: PPUSH
88841: CALL_OW 72
88845: PPUSH
88846: LD_VAR 0 7
88850: PPUSH
88851: CALL_OW 74
88855: PPUSH
88856: CALL_OW 296
88860: PUSH
88861: LD_INT 10
88863: GREATER
88864: IFFALSE 89017
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
88866: LD_ADDR_VAR 0 8
88870: PUSH
88871: LD_EXP 23
88875: PUSH
88876: LD_VAR 0 1
88880: ARRAY
88881: PPUSH
88882: LD_INT 2
88884: PUSH
88885: LD_INT 30
88887: PUSH
88888: LD_INT 0
88890: PUSH
88891: EMPTY
88892: LIST
88893: LIST
88894: PUSH
88895: LD_INT 30
88897: PUSH
88898: LD_INT 1
88900: PUSH
88901: EMPTY
88902: LIST
88903: LIST
88904: PUSH
88905: LD_INT 30
88907: PUSH
88908: LD_INT 6
88910: PUSH
88911: EMPTY
88912: LIST
88913: LIST
88914: PUSH
88915: EMPTY
88916: LIST
88917: LIST
88918: LIST
88919: LIST
88920: PPUSH
88921: CALL_OW 72
88925: PPUSH
88926: LD_VAR 0 7
88930: PPUSH
88931: CALL_OW 74
88935: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
88936: LD_VAR 0 7
88940: PPUSH
88941: LD_VAR 0 8
88945: PPUSH
88946: CALL_OW 250
88950: PPUSH
88951: LD_INT 3
88953: PPUSH
88954: LD_INT 5
88956: PPUSH
88957: CALL_OW 272
88961: PPUSH
88962: LD_VAR 0 8
88966: PPUSH
88967: CALL_OW 251
88971: PPUSH
88972: LD_INT 3
88974: PPUSH
88975: LD_INT 5
88977: PPUSH
88978: CALL_OW 273
88982: PPUSH
88983: CALL_OW 111
// SetTag ( i , 0 ) ;
88987: LD_VAR 0 7
88991: PPUSH
88992: LD_INT 0
88994: PPUSH
88995: CALL_OW 109
// solds := solds diff i ;
88999: LD_ADDR_VAR 0 2
89003: PUSH
89004: LD_VAR 0 2
89008: PUSH
89009: LD_VAR 0 7
89013: DIFF
89014: ST_TO_ADDR
// continue ;
89015: GO 88697
// end ; end ;
89017: GO 88697
89019: POP
89020: POP
// until not solds or not enemy ;
89021: LD_VAR 0 2
89025: NOT
89026: PUSH
89027: LD_VAR 0 4
89031: NOT
89032: OR
89033: IFFALSE 88601
// MC_Reset ( base , 18 ) ;
89035: LD_VAR 0 1
89039: PPUSH
89040: LD_INT 18
89042: PPUSH
89043: CALL 57208 0 2
// end ;
89047: LD_VAR 0 3
89051: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
89052: LD_INT 0
89054: PPUSH
89055: PPUSH
89056: PPUSH
89057: PPUSH
89058: PPUSH
89059: PPUSH
89060: PPUSH
89061: PPUSH
89062: PPUSH
89063: PPUSH
89064: PPUSH
89065: PPUSH
89066: PPUSH
89067: PPUSH
89068: PPUSH
89069: PPUSH
89070: PPUSH
89071: PPUSH
89072: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
89073: LD_ADDR_VAR 0 12
89077: PUSH
89078: LD_EXP 23
89082: PUSH
89083: LD_VAR 0 1
89087: ARRAY
89088: PPUSH
89089: LD_INT 25
89091: PUSH
89092: LD_INT 3
89094: PUSH
89095: EMPTY
89096: LIST
89097: LIST
89098: PPUSH
89099: CALL_OW 72
89103: ST_TO_ADDR
// if mc_remote_driver [ base ] then
89104: LD_EXP 63
89108: PUSH
89109: LD_VAR 0 1
89113: ARRAY
89114: IFFALSE 89138
// mechs := mechs diff mc_remote_driver [ base ] ;
89116: LD_ADDR_VAR 0 12
89120: PUSH
89121: LD_VAR 0 12
89125: PUSH
89126: LD_EXP 63
89130: PUSH
89131: LD_VAR 0 1
89135: ARRAY
89136: DIFF
89137: ST_TO_ADDR
// for i in mechs do
89138: LD_ADDR_VAR 0 4
89142: PUSH
89143: LD_VAR 0 12
89147: PUSH
89148: FOR_IN
89149: IFFALSE 89184
// if GetTag ( i ) > 0 then
89151: LD_VAR 0 4
89155: PPUSH
89156: CALL_OW 110
89160: PUSH
89161: LD_INT 0
89163: GREATER
89164: IFFALSE 89182
// mechs := mechs diff i ;
89166: LD_ADDR_VAR 0 12
89170: PUSH
89171: LD_VAR 0 12
89175: PUSH
89176: LD_VAR 0 4
89180: DIFF
89181: ST_TO_ADDR
89182: GO 89148
89184: POP
89185: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
89186: LD_ADDR_VAR 0 8
89190: PUSH
89191: LD_EXP 23
89195: PUSH
89196: LD_VAR 0 1
89200: ARRAY
89201: PPUSH
89202: LD_INT 2
89204: PUSH
89205: LD_INT 25
89207: PUSH
89208: LD_INT 1
89210: PUSH
89211: EMPTY
89212: LIST
89213: LIST
89214: PUSH
89215: LD_INT 25
89217: PUSH
89218: LD_INT 5
89220: PUSH
89221: EMPTY
89222: LIST
89223: LIST
89224: PUSH
89225: LD_INT 25
89227: PUSH
89228: LD_INT 8
89230: PUSH
89231: EMPTY
89232: LIST
89233: LIST
89234: PUSH
89235: LD_INT 25
89237: PUSH
89238: LD_INT 9
89240: PUSH
89241: EMPTY
89242: LIST
89243: LIST
89244: PUSH
89245: EMPTY
89246: LIST
89247: LIST
89248: LIST
89249: LIST
89250: LIST
89251: PPUSH
89252: CALL_OW 72
89256: ST_TO_ADDR
// if not defenders and not solds then
89257: LD_VAR 0 2
89261: NOT
89262: PUSH
89263: LD_VAR 0 8
89267: NOT
89268: AND
89269: IFFALSE 89273
// exit ;
89271: GO 91043
// depot_under_attack := false ;
89273: LD_ADDR_VAR 0 16
89277: PUSH
89278: LD_INT 0
89280: ST_TO_ADDR
// sold_defenders := [ ] ;
89281: LD_ADDR_VAR 0 17
89285: PUSH
89286: EMPTY
89287: ST_TO_ADDR
// if mechs then
89288: LD_VAR 0 12
89292: IFFALSE 89445
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
89294: LD_ADDR_VAR 0 4
89298: PUSH
89299: LD_VAR 0 2
89303: PPUSH
89304: LD_INT 21
89306: PUSH
89307: LD_INT 2
89309: PUSH
89310: EMPTY
89311: LIST
89312: LIST
89313: PPUSH
89314: CALL_OW 72
89318: PUSH
89319: FOR_IN
89320: IFFALSE 89443
// begin if GetTag ( i ) <> 20 then
89322: LD_VAR 0 4
89326: PPUSH
89327: CALL_OW 110
89331: PUSH
89332: LD_INT 20
89334: NONEQUAL
89335: IFFALSE 89349
// SetTag ( i , 20 ) ;
89337: LD_VAR 0 4
89341: PPUSH
89342: LD_INT 20
89344: PPUSH
89345: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
89349: LD_VAR 0 4
89353: PPUSH
89354: CALL_OW 263
89358: PUSH
89359: LD_INT 1
89361: EQUAL
89362: PUSH
89363: LD_VAR 0 4
89367: PPUSH
89368: CALL_OW 311
89372: NOT
89373: AND
89374: IFFALSE 89441
// begin un := mechs [ 1 ] ;
89376: LD_ADDR_VAR 0 10
89380: PUSH
89381: LD_VAR 0 12
89385: PUSH
89386: LD_INT 1
89388: ARRAY
89389: ST_TO_ADDR
// ComExit ( un ) ;
89390: LD_VAR 0 10
89394: PPUSH
89395: CALL 49215 0 1
// AddComEnterUnit ( un , i ) ;
89399: LD_VAR 0 10
89403: PPUSH
89404: LD_VAR 0 4
89408: PPUSH
89409: CALL_OW 180
// SetTag ( un , 19 ) ;
89413: LD_VAR 0 10
89417: PPUSH
89418: LD_INT 19
89420: PPUSH
89421: CALL_OW 109
// mechs := mechs diff un ;
89425: LD_ADDR_VAR 0 12
89429: PUSH
89430: LD_VAR 0 12
89434: PUSH
89435: LD_VAR 0 10
89439: DIFF
89440: ST_TO_ADDR
// end ; end ;
89441: GO 89319
89443: POP
89444: POP
// if solds then
89445: LD_VAR 0 8
89449: IFFALSE 89508
// for i in solds do
89451: LD_ADDR_VAR 0 4
89455: PUSH
89456: LD_VAR 0 8
89460: PUSH
89461: FOR_IN
89462: IFFALSE 89506
// if not GetTag ( i ) then
89464: LD_VAR 0 4
89468: PPUSH
89469: CALL_OW 110
89473: NOT
89474: IFFALSE 89504
// begin defenders := defenders union i ;
89476: LD_ADDR_VAR 0 2
89480: PUSH
89481: LD_VAR 0 2
89485: PUSH
89486: LD_VAR 0 4
89490: UNION
89491: ST_TO_ADDR
// SetTag ( i , 18 ) ;
89492: LD_VAR 0 4
89496: PPUSH
89497: LD_INT 18
89499: PPUSH
89500: CALL_OW 109
// end ;
89504: GO 89461
89506: POP
89507: POP
// repeat wait ( 0 0$2 ) ;
89508: LD_INT 70
89510: PPUSH
89511: CALL_OW 67
// enemy := mc_scan [ base ] ;
89515: LD_ADDR_VAR 0 21
89519: PUSH
89520: LD_EXP 46
89524: PUSH
89525: LD_VAR 0 1
89529: ARRAY
89530: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
89531: LD_EXP 23
89535: PUSH
89536: LD_VAR 0 1
89540: ARRAY
89541: NOT
89542: PUSH
89543: LD_EXP 23
89547: PUSH
89548: LD_VAR 0 1
89552: ARRAY
89553: PUSH
89554: EMPTY
89555: EQUAL
89556: OR
89557: IFFALSE 89594
// begin for i in defenders do
89559: LD_ADDR_VAR 0 4
89563: PUSH
89564: LD_VAR 0 2
89568: PUSH
89569: FOR_IN
89570: IFFALSE 89583
// ComStop ( i ) ;
89572: LD_VAR 0 4
89576: PPUSH
89577: CALL_OW 141
89581: GO 89569
89583: POP
89584: POP
// defenders := [ ] ;
89585: LD_ADDR_VAR 0 2
89589: PUSH
89590: EMPTY
89591: ST_TO_ADDR
// exit ;
89592: GO 91043
// end ; for i in defenders do
89594: LD_ADDR_VAR 0 4
89598: PUSH
89599: LD_VAR 0 2
89603: PUSH
89604: FOR_IN
89605: IFFALSE 90503
// begin e := NearestUnitToUnit ( enemy , i ) ;
89607: LD_ADDR_VAR 0 13
89611: PUSH
89612: LD_VAR 0 21
89616: PPUSH
89617: LD_VAR 0 4
89621: PPUSH
89622: CALL_OW 74
89626: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
89627: LD_ADDR_VAR 0 7
89631: PUSH
89632: LD_EXP 23
89636: PUSH
89637: LD_VAR 0 1
89641: ARRAY
89642: PPUSH
89643: LD_INT 2
89645: PUSH
89646: LD_INT 30
89648: PUSH
89649: LD_INT 0
89651: PUSH
89652: EMPTY
89653: LIST
89654: LIST
89655: PUSH
89656: LD_INT 30
89658: PUSH
89659: LD_INT 1
89661: PUSH
89662: EMPTY
89663: LIST
89664: LIST
89665: PUSH
89666: EMPTY
89667: LIST
89668: LIST
89669: LIST
89670: PPUSH
89671: CALL_OW 72
89675: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
89676: LD_ADDR_VAR 0 16
89680: PUSH
89681: LD_VAR 0 7
89685: NOT
89686: PUSH
89687: LD_VAR 0 7
89691: PPUSH
89692: LD_INT 3
89694: PUSH
89695: LD_INT 24
89697: PUSH
89698: LD_INT 600
89700: PUSH
89701: EMPTY
89702: LIST
89703: LIST
89704: PUSH
89705: EMPTY
89706: LIST
89707: LIST
89708: PPUSH
89709: CALL_OW 72
89713: OR
89714: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
89715: LD_VAR 0 4
89719: PPUSH
89720: CALL_OW 247
89724: PUSH
89725: LD_INT 2
89727: DOUBLE
89728: EQUAL
89729: IFTRUE 89733
89731: GO 90129
89733: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
89734: LD_VAR 0 4
89738: PPUSH
89739: CALL_OW 256
89743: PUSH
89744: LD_INT 1000
89746: EQUAL
89747: PUSH
89748: LD_VAR 0 4
89752: PPUSH
89753: LD_VAR 0 13
89757: PPUSH
89758: CALL_OW 296
89762: PUSH
89763: LD_INT 40
89765: LESS
89766: PUSH
89767: LD_VAR 0 13
89771: PPUSH
89772: LD_EXP 48
89776: PUSH
89777: LD_VAR 0 1
89781: ARRAY
89782: PPUSH
89783: CALL_OW 308
89787: OR
89788: AND
89789: IFFALSE 89911
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
89791: LD_VAR 0 4
89795: PPUSH
89796: CALL_OW 262
89800: PUSH
89801: LD_INT 1
89803: EQUAL
89804: PUSH
89805: LD_VAR 0 4
89809: PPUSH
89810: CALL_OW 261
89814: PUSH
89815: LD_INT 30
89817: LESS
89818: AND
89819: PUSH
89820: LD_VAR 0 7
89824: AND
89825: IFFALSE 89895
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
89827: LD_VAR 0 4
89831: PPUSH
89832: LD_VAR 0 7
89836: PPUSH
89837: LD_VAR 0 4
89841: PPUSH
89842: CALL_OW 74
89846: PPUSH
89847: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
89851: LD_VAR 0 4
89855: PPUSH
89856: LD_VAR 0 7
89860: PPUSH
89861: LD_VAR 0 4
89865: PPUSH
89866: CALL_OW 74
89870: PPUSH
89871: CALL_OW 296
89875: PUSH
89876: LD_INT 6
89878: LESS
89879: IFFALSE 89893
// SetFuel ( i , 100 ) ;
89881: LD_VAR 0 4
89885: PPUSH
89886: LD_INT 100
89888: PPUSH
89889: CALL_OW 240
// end else
89893: GO 89909
// ComAttackUnit ( i , e ) ;
89895: LD_VAR 0 4
89899: PPUSH
89900: LD_VAR 0 13
89904: PPUSH
89905: CALL_OW 115
// end else
89909: GO 90012
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
89911: LD_VAR 0 13
89915: PPUSH
89916: LD_EXP 48
89920: PUSH
89921: LD_VAR 0 1
89925: ARRAY
89926: PPUSH
89927: CALL_OW 308
89931: NOT
89932: PUSH
89933: LD_VAR 0 4
89937: PPUSH
89938: LD_VAR 0 13
89942: PPUSH
89943: CALL_OW 296
89947: PUSH
89948: LD_INT 40
89950: GREATEREQUAL
89951: AND
89952: PUSH
89953: LD_VAR 0 4
89957: PPUSH
89958: CALL_OW 256
89962: PUSH
89963: LD_INT 650
89965: LESSEQUAL
89966: OR
89967: PUSH
89968: LD_VAR 0 4
89972: PPUSH
89973: LD_EXP 47
89977: PUSH
89978: LD_VAR 0 1
89982: ARRAY
89983: PPUSH
89984: CALL_OW 308
89988: NOT
89989: AND
89990: IFFALSE 90012
// ComMoveToArea ( i , mc_parking [ base ] ) ;
89992: LD_VAR 0 4
89996: PPUSH
89997: LD_EXP 47
90001: PUSH
90002: LD_VAR 0 1
90006: ARRAY
90007: PPUSH
90008: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
90012: LD_VAR 0 4
90016: PPUSH
90017: CALL_OW 256
90021: PUSH
90022: LD_INT 1000
90024: LESS
90025: PUSH
90026: LD_VAR 0 4
90030: PPUSH
90031: CALL_OW 263
90035: PUSH
90036: LD_INT 1
90038: EQUAL
90039: AND
90040: PUSH
90041: LD_VAR 0 4
90045: PPUSH
90046: CALL_OW 311
90050: AND
90051: PUSH
90052: LD_VAR 0 4
90056: PPUSH
90057: LD_EXP 47
90061: PUSH
90062: LD_VAR 0 1
90066: ARRAY
90067: PPUSH
90068: CALL_OW 308
90072: AND
90073: IFFALSE 90127
// begin mech := IsDrivenBy ( i ) ;
90075: LD_ADDR_VAR 0 9
90079: PUSH
90080: LD_VAR 0 4
90084: PPUSH
90085: CALL_OW 311
90089: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
90090: LD_VAR 0 9
90094: PPUSH
90095: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
90099: LD_VAR 0 9
90103: PPUSH
90104: LD_VAR 0 4
90108: PPUSH
90109: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
90113: LD_VAR 0 9
90117: PPUSH
90118: LD_VAR 0 4
90122: PPUSH
90123: CALL_OW 180
// end ; end ; unit_human :
90127: GO 90474
90129: LD_INT 1
90131: DOUBLE
90132: EQUAL
90133: IFTRUE 90137
90135: GO 90473
90137: POP
// begin b := IsInUnit ( i ) ;
90138: LD_ADDR_VAR 0 18
90142: PUSH
90143: LD_VAR 0 4
90147: PPUSH
90148: CALL_OW 310
90152: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
90153: LD_ADDR_VAR 0 19
90157: PUSH
90158: LD_VAR 0 18
90162: NOT
90163: PUSH
90164: LD_VAR 0 18
90168: PPUSH
90169: CALL_OW 266
90173: PUSH
90174: LD_INT 32
90176: PUSH
90177: LD_INT 31
90179: PUSH
90180: EMPTY
90181: LIST
90182: LIST
90183: IN
90184: OR
90185: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
90186: LD_VAR 0 18
90190: PPUSH
90191: CALL_OW 266
90195: PUSH
90196: LD_INT 5
90198: EQUAL
90199: PUSH
90200: LD_VAR 0 4
90204: PPUSH
90205: CALL_OW 257
90209: PUSH
90210: LD_INT 1
90212: PUSH
90213: LD_INT 2
90215: PUSH
90216: LD_INT 3
90218: PUSH
90219: LD_INT 4
90221: PUSH
90222: EMPTY
90223: LIST
90224: LIST
90225: LIST
90226: LIST
90227: IN
90228: AND
90229: IFFALSE 90266
// begin class := AllowSpecClass ( i ) ;
90231: LD_ADDR_VAR 0 20
90235: PUSH
90236: LD_VAR 0 4
90240: PPUSH
90241: CALL 12901 0 1
90245: ST_TO_ADDR
// if class then
90246: LD_VAR 0 20
90250: IFFALSE 90266
// ComChangeProfession ( i , class ) ;
90252: LD_VAR 0 4
90256: PPUSH
90257: LD_VAR 0 20
90261: PPUSH
90262: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
90266: LD_VAR 0 16
90270: PUSH
90271: LD_VAR 0 2
90275: PPUSH
90276: LD_INT 21
90278: PUSH
90279: LD_INT 2
90281: PUSH
90282: EMPTY
90283: LIST
90284: LIST
90285: PPUSH
90286: CALL_OW 72
90290: PUSH
90291: LD_INT 1
90293: LESSEQUAL
90294: OR
90295: PUSH
90296: LD_VAR 0 19
90300: AND
90301: PUSH
90302: LD_VAR 0 4
90306: PUSH
90307: LD_VAR 0 17
90311: IN
90312: NOT
90313: AND
90314: IFFALSE 90407
// begin if b then
90316: LD_VAR 0 18
90320: IFFALSE 90369
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
90322: LD_VAR 0 18
90326: PPUSH
90327: LD_VAR 0 21
90331: PPUSH
90332: LD_VAR 0 18
90336: PPUSH
90337: CALL_OW 74
90341: PPUSH
90342: CALL_OW 296
90346: PUSH
90347: LD_INT 10
90349: LESS
90350: PUSH
90351: LD_VAR 0 18
90355: PPUSH
90356: CALL_OW 461
90360: PUSH
90361: LD_INT 7
90363: NONEQUAL
90364: AND
90365: IFFALSE 90369
// continue ;
90367: GO 89604
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
90369: LD_ADDR_VAR 0 17
90373: PUSH
90374: LD_VAR 0 17
90378: PPUSH
90379: LD_VAR 0 17
90383: PUSH
90384: LD_INT 1
90386: PLUS
90387: PPUSH
90388: LD_VAR 0 4
90392: PPUSH
90393: CALL_OW 1
90397: ST_TO_ADDR
// ComExitBuilding ( i ) ;
90398: LD_VAR 0 4
90402: PPUSH
90403: CALL_OW 122
// end ; if sold_defenders then
90407: LD_VAR 0 17
90411: IFFALSE 90471
// if i in sold_defenders then
90413: LD_VAR 0 4
90417: PUSH
90418: LD_VAR 0 17
90422: IN
90423: IFFALSE 90471
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
90425: LD_VAR 0 4
90429: PPUSH
90430: CALL_OW 314
90434: NOT
90435: PUSH
90436: LD_VAR 0 4
90440: PPUSH
90441: LD_VAR 0 13
90445: PPUSH
90446: CALL_OW 296
90450: PUSH
90451: LD_INT 30
90453: LESS
90454: AND
90455: IFFALSE 90471
// ComAttackUnit ( i , e ) ;
90457: LD_VAR 0 4
90461: PPUSH
90462: LD_VAR 0 13
90466: PPUSH
90467: CALL_OW 115
// end ; end ; end ;
90471: GO 90474
90473: POP
// if IsDead ( i ) then
90474: LD_VAR 0 4
90478: PPUSH
90479: CALL_OW 301
90483: IFFALSE 90501
// defenders := defenders diff i ;
90485: LD_ADDR_VAR 0 2
90489: PUSH
90490: LD_VAR 0 2
90494: PUSH
90495: LD_VAR 0 4
90499: DIFF
90500: ST_TO_ADDR
// end ;
90501: GO 89604
90503: POP
90504: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
90505: LD_VAR 0 21
90509: NOT
90510: PUSH
90511: LD_VAR 0 2
90515: NOT
90516: OR
90517: PUSH
90518: LD_EXP 23
90522: PUSH
90523: LD_VAR 0 1
90527: ARRAY
90528: NOT
90529: OR
90530: IFFALSE 89508
// MC_Reset ( base , 18 ) ;
90532: LD_VAR 0 1
90536: PPUSH
90537: LD_INT 18
90539: PPUSH
90540: CALL 57208 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
90544: LD_ADDR_VAR 0 2
90548: PUSH
90549: LD_VAR 0 2
90553: PUSH
90554: LD_VAR 0 2
90558: PPUSH
90559: LD_INT 2
90561: PUSH
90562: LD_INT 25
90564: PUSH
90565: LD_INT 1
90567: PUSH
90568: EMPTY
90569: LIST
90570: LIST
90571: PUSH
90572: LD_INT 25
90574: PUSH
90575: LD_INT 5
90577: PUSH
90578: EMPTY
90579: LIST
90580: LIST
90581: PUSH
90582: LD_INT 25
90584: PUSH
90585: LD_INT 8
90587: PUSH
90588: EMPTY
90589: LIST
90590: LIST
90591: PUSH
90592: LD_INT 25
90594: PUSH
90595: LD_INT 9
90597: PUSH
90598: EMPTY
90599: LIST
90600: LIST
90601: PUSH
90602: EMPTY
90603: LIST
90604: LIST
90605: LIST
90606: LIST
90607: LIST
90608: PPUSH
90609: CALL_OW 72
90613: DIFF
90614: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
90615: LD_VAR 0 21
90619: NOT
90620: PUSH
90621: LD_VAR 0 2
90625: PPUSH
90626: LD_INT 21
90628: PUSH
90629: LD_INT 2
90631: PUSH
90632: EMPTY
90633: LIST
90634: LIST
90635: PPUSH
90636: CALL_OW 72
90640: AND
90641: IFFALSE 90979
// begin tmp := FilterByTag ( defenders , 19 ) ;
90643: LD_ADDR_VAR 0 11
90647: PUSH
90648: LD_VAR 0 2
90652: PPUSH
90653: LD_INT 19
90655: PPUSH
90656: CALL 46386 0 2
90660: ST_TO_ADDR
// if tmp then
90661: LD_VAR 0 11
90665: IFFALSE 90735
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
90667: LD_ADDR_VAR 0 11
90671: PUSH
90672: LD_VAR 0 11
90676: PPUSH
90677: LD_INT 25
90679: PUSH
90680: LD_INT 3
90682: PUSH
90683: EMPTY
90684: LIST
90685: LIST
90686: PPUSH
90687: CALL_OW 72
90691: ST_TO_ADDR
// if tmp then
90692: LD_VAR 0 11
90696: IFFALSE 90735
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
90698: LD_ADDR_EXP 35
90702: PUSH
90703: LD_EXP 35
90707: PPUSH
90708: LD_VAR 0 1
90712: PPUSH
90713: LD_EXP 35
90717: PUSH
90718: LD_VAR 0 1
90722: ARRAY
90723: PUSH
90724: LD_VAR 0 11
90728: UNION
90729: PPUSH
90730: CALL_OW 1
90734: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
90735: LD_VAR 0 1
90739: PPUSH
90740: LD_INT 19
90742: PPUSH
90743: CALL 57208 0 2
// repeat wait ( 0 0$1 ) ;
90747: LD_INT 35
90749: PPUSH
90750: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
90754: LD_EXP 23
90758: PUSH
90759: LD_VAR 0 1
90763: ARRAY
90764: NOT
90765: PUSH
90766: LD_EXP 23
90770: PUSH
90771: LD_VAR 0 1
90775: ARRAY
90776: PUSH
90777: EMPTY
90778: EQUAL
90779: OR
90780: IFFALSE 90817
// begin for i in defenders do
90782: LD_ADDR_VAR 0 4
90786: PUSH
90787: LD_VAR 0 2
90791: PUSH
90792: FOR_IN
90793: IFFALSE 90806
// ComStop ( i ) ;
90795: LD_VAR 0 4
90799: PPUSH
90800: CALL_OW 141
90804: GO 90792
90806: POP
90807: POP
// defenders := [ ] ;
90808: LD_ADDR_VAR 0 2
90812: PUSH
90813: EMPTY
90814: ST_TO_ADDR
// exit ;
90815: GO 91043
// end ; for i in defenders do
90817: LD_ADDR_VAR 0 4
90821: PUSH
90822: LD_VAR 0 2
90826: PUSH
90827: FOR_IN
90828: IFFALSE 90917
// begin if not IsInArea ( i , mc_parking [ base ] ) then
90830: LD_VAR 0 4
90834: PPUSH
90835: LD_EXP 47
90839: PUSH
90840: LD_VAR 0 1
90844: ARRAY
90845: PPUSH
90846: CALL_OW 308
90850: NOT
90851: IFFALSE 90875
// ComMoveToArea ( i , mc_parking [ base ] ) else
90853: LD_VAR 0 4
90857: PPUSH
90858: LD_EXP 47
90862: PUSH
90863: LD_VAR 0 1
90867: ARRAY
90868: PPUSH
90869: CALL_OW 113
90873: GO 90915
// if GetControl ( i ) = control_manual then
90875: LD_VAR 0 4
90879: PPUSH
90880: CALL_OW 263
90884: PUSH
90885: LD_INT 1
90887: EQUAL
90888: IFFALSE 90915
// if IsDrivenBy ( i ) then
90890: LD_VAR 0 4
90894: PPUSH
90895: CALL_OW 311
90899: IFFALSE 90915
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
90901: LD_VAR 0 4
90905: PPUSH
90906: CALL_OW 311
90910: PPUSH
90911: CALL_OW 121
// end ;
90915: GO 90827
90917: POP
90918: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
90919: LD_VAR 0 2
90923: PPUSH
90924: LD_INT 95
90926: PUSH
90927: LD_EXP 47
90931: PUSH
90932: LD_VAR 0 1
90936: ARRAY
90937: PUSH
90938: EMPTY
90939: LIST
90940: LIST
90941: PPUSH
90942: CALL_OW 72
90946: PUSH
90947: LD_VAR 0 2
90951: EQUAL
90952: PUSH
90953: LD_EXP 46
90957: PUSH
90958: LD_VAR 0 1
90962: ARRAY
90963: OR
90964: PUSH
90965: LD_EXP 23
90969: PUSH
90970: LD_VAR 0 1
90974: ARRAY
90975: NOT
90976: OR
90977: IFFALSE 90747
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
90979: LD_ADDR_EXP 45
90983: PUSH
90984: LD_EXP 45
90988: PPUSH
90989: LD_VAR 0 1
90993: PPUSH
90994: LD_VAR 0 2
90998: PPUSH
90999: LD_INT 21
91001: PUSH
91002: LD_INT 2
91004: PUSH
91005: EMPTY
91006: LIST
91007: LIST
91008: PPUSH
91009: CALL_OW 72
91013: PPUSH
91014: CALL_OW 1
91018: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
91019: LD_VAR 0 1
91023: PPUSH
91024: LD_INT 19
91026: PPUSH
91027: CALL 57208 0 2
// MC_Reset ( base , 20 ) ;
91031: LD_VAR 0 1
91035: PPUSH
91036: LD_INT 20
91038: PPUSH
91039: CALL 57208 0 2
// end ; end_of_file
91043: LD_VAR 0 3
91047: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
91048: LD_INT 0
91050: PPUSH
91051: PPUSH
91052: PPUSH
91053: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
91054: LD_VAR 0 1
91058: PPUSH
91059: CALL_OW 264
91063: PUSH
91064: LD_INT 91
91066: EQUAL
91067: IFFALSE 91139
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
91069: LD_INT 68
91071: PPUSH
91072: LD_VAR 0 1
91076: PPUSH
91077: CALL_OW 255
91081: PPUSH
91082: CALL_OW 321
91086: PUSH
91087: LD_INT 2
91089: EQUAL
91090: IFFALSE 91102
// eff := 70 else
91092: LD_ADDR_VAR 0 4
91096: PUSH
91097: LD_INT 70
91099: ST_TO_ADDR
91100: GO 91110
// eff := 30 ;
91102: LD_ADDR_VAR 0 4
91106: PUSH
91107: LD_INT 30
91109: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
91110: LD_VAR 0 1
91114: PPUSH
91115: CALL_OW 250
91119: PPUSH
91120: LD_VAR 0 1
91124: PPUSH
91125: CALL_OW 251
91129: PPUSH
91130: LD_VAR 0 4
91134: PPUSH
91135: CALL_OW 495
// end ; end ;
91139: LD_VAR 0 2
91143: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
91144: LD_INT 0
91146: PPUSH
// end ;
91147: LD_VAR 0 4
91151: RET
// export function SOS_Command ( cmd ) ; begin
91152: LD_INT 0
91154: PPUSH
// end ;
91155: LD_VAR 0 2
91159: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
91160: LD_INT 0
91162: PPUSH
// end ;
91163: LD_VAR 0 6
91167: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
91168: LD_INT 0
91170: PPUSH
91171: PPUSH
// if not vehicle or not factory then
91172: LD_VAR 0 1
91176: NOT
91177: PUSH
91178: LD_VAR 0 2
91182: NOT
91183: OR
91184: IFFALSE 91188
// exit ;
91186: GO 91419
// if factoryWaypoints >= factory then
91188: LD_EXP 137
91192: PUSH
91193: LD_VAR 0 2
91197: GREATEREQUAL
91198: IFFALSE 91419
// if factoryWaypoints [ factory ] then
91200: LD_EXP 137
91204: PUSH
91205: LD_VAR 0 2
91209: ARRAY
91210: IFFALSE 91419
// begin if GetControl ( vehicle ) = control_manual then
91212: LD_VAR 0 1
91216: PPUSH
91217: CALL_OW 263
91221: PUSH
91222: LD_INT 1
91224: EQUAL
91225: IFFALSE 91306
// begin driver := IsDrivenBy ( vehicle ) ;
91227: LD_ADDR_VAR 0 4
91231: PUSH
91232: LD_VAR 0 1
91236: PPUSH
91237: CALL_OW 311
91241: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
91242: LD_VAR 0 4
91246: PPUSH
91247: LD_EXP 137
91251: PUSH
91252: LD_VAR 0 2
91256: ARRAY
91257: PUSH
91258: LD_INT 3
91260: ARRAY
91261: PPUSH
91262: LD_EXP 137
91266: PUSH
91267: LD_VAR 0 2
91271: ARRAY
91272: PUSH
91273: LD_INT 4
91275: ARRAY
91276: PPUSH
91277: CALL_OW 171
// AddComExitVehicle ( driver ) ;
91281: LD_VAR 0 4
91285: PPUSH
91286: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
91290: LD_VAR 0 4
91294: PPUSH
91295: LD_VAR 0 2
91299: PPUSH
91300: CALL_OW 180
// end else
91304: GO 91419
// if GetControl ( vehicle ) = control_remote then
91306: LD_VAR 0 1
91310: PPUSH
91311: CALL_OW 263
91315: PUSH
91316: LD_INT 2
91318: EQUAL
91319: IFFALSE 91380
// begin wait ( 0 0$2 ) ;
91321: LD_INT 70
91323: PPUSH
91324: CALL_OW 67
// if Connect ( vehicle ) then
91328: LD_VAR 0 1
91332: PPUSH
91333: CALL 19423 0 1
91337: IFFALSE 91378
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
91339: LD_VAR 0 1
91343: PPUSH
91344: LD_EXP 137
91348: PUSH
91349: LD_VAR 0 2
91353: ARRAY
91354: PUSH
91355: LD_INT 3
91357: ARRAY
91358: PPUSH
91359: LD_EXP 137
91363: PUSH
91364: LD_VAR 0 2
91368: ARRAY
91369: PUSH
91370: LD_INT 4
91372: ARRAY
91373: PPUSH
91374: CALL_OW 171
// end else
91378: GO 91419
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
91380: LD_VAR 0 1
91384: PPUSH
91385: LD_EXP 137
91389: PUSH
91390: LD_VAR 0 2
91394: ARRAY
91395: PUSH
91396: LD_INT 3
91398: ARRAY
91399: PPUSH
91400: LD_EXP 137
91404: PUSH
91405: LD_VAR 0 2
91409: ARRAY
91410: PUSH
91411: LD_INT 4
91413: ARRAY
91414: PPUSH
91415: CALL_OW 171
// end ; end ;
91419: LD_VAR 0 3
91423: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
91424: LD_INT 0
91426: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
91427: LD_VAR 0 1
91431: PUSH
91432: LD_INT 250
91434: EQUAL
91435: PUSH
91436: LD_VAR 0 2
91440: PPUSH
91441: CALL_OW 264
91445: PUSH
91446: LD_INT 81
91448: EQUAL
91449: AND
91450: IFFALSE 91471
// MinerPlaceMine ( unit , x , y ) ;
91452: LD_VAR 0 2
91456: PPUSH
91457: LD_VAR 0 4
91461: PPUSH
91462: LD_VAR 0 5
91466: PPUSH
91467: CALL 94295 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
91471: LD_VAR 0 1
91475: PUSH
91476: LD_INT 251
91478: EQUAL
91479: PUSH
91480: LD_VAR 0 2
91484: PPUSH
91485: CALL_OW 264
91489: PUSH
91490: LD_INT 81
91492: EQUAL
91493: AND
91494: IFFALSE 91515
// MinerDetonateMine ( unit , x , y ) ;
91496: LD_VAR 0 2
91500: PPUSH
91501: LD_VAR 0 4
91505: PPUSH
91506: LD_VAR 0 5
91510: PPUSH
91511: CALL 94570 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
91515: LD_VAR 0 1
91519: PUSH
91520: LD_INT 252
91522: EQUAL
91523: PUSH
91524: LD_VAR 0 2
91528: PPUSH
91529: CALL_OW 264
91533: PUSH
91534: LD_INT 81
91536: EQUAL
91537: AND
91538: IFFALSE 91559
// MinerCreateMinefield ( unit , x , y ) ;
91540: LD_VAR 0 2
91544: PPUSH
91545: LD_VAR 0 4
91549: PPUSH
91550: LD_VAR 0 5
91554: PPUSH
91555: CALL 94987 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
91559: LD_VAR 0 1
91563: PUSH
91564: LD_INT 253
91566: EQUAL
91567: PUSH
91568: LD_VAR 0 2
91572: PPUSH
91573: CALL_OW 257
91577: PUSH
91578: LD_INT 5
91580: EQUAL
91581: AND
91582: IFFALSE 91603
// ComBinocular ( unit , x , y ) ;
91584: LD_VAR 0 2
91588: PPUSH
91589: LD_VAR 0 4
91593: PPUSH
91594: LD_VAR 0 5
91598: PPUSH
91599: CALL 95356 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
91603: LD_VAR 0 1
91607: PUSH
91608: LD_INT 254
91610: EQUAL
91611: PUSH
91612: LD_VAR 0 2
91616: PPUSH
91617: CALL_OW 264
91621: PUSH
91622: LD_INT 99
91624: EQUAL
91625: AND
91626: PUSH
91627: LD_VAR 0 3
91631: PPUSH
91632: CALL_OW 263
91636: PUSH
91637: LD_INT 3
91639: EQUAL
91640: AND
91641: IFFALSE 91657
// HackDestroyVehicle ( unit , selectedUnit ) ;
91643: LD_VAR 0 2
91647: PPUSH
91648: LD_VAR 0 3
91652: PPUSH
91653: CALL 93659 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
91657: LD_VAR 0 1
91661: PUSH
91662: LD_INT 255
91664: EQUAL
91665: PUSH
91666: LD_VAR 0 2
91670: PPUSH
91671: CALL_OW 264
91675: PUSH
91676: LD_INT 14
91678: PUSH
91679: LD_INT 53
91681: PUSH
91682: EMPTY
91683: LIST
91684: LIST
91685: IN
91686: AND
91687: PUSH
91688: LD_VAR 0 4
91692: PPUSH
91693: LD_VAR 0 5
91697: PPUSH
91698: CALL_OW 488
91702: AND
91703: IFFALSE 91727
// CutTreeXYR ( unit , x , y , 12 ) ;
91705: LD_VAR 0 2
91709: PPUSH
91710: LD_VAR 0 4
91714: PPUSH
91715: LD_VAR 0 5
91719: PPUSH
91720: LD_INT 12
91722: PPUSH
91723: CALL 91822 0 4
// if cmd = 256 then
91727: LD_VAR 0 1
91731: PUSH
91732: LD_INT 256
91734: EQUAL
91735: IFFALSE 91756
// SetFactoryWaypoint ( unit , x , y ) ;
91737: LD_VAR 0 2
91741: PPUSH
91742: LD_VAR 0 4
91746: PPUSH
91747: LD_VAR 0 5
91751: PPUSH
91752: CALL 110430 0 3
// if cmd = 257 then
91756: LD_VAR 0 1
91760: PUSH
91761: LD_INT 257
91763: EQUAL
91764: IFFALSE 91785
// SetWarehouseGatheringPoint ( unit , x , y ) ;
91766: LD_VAR 0 2
91770: PPUSH
91771: LD_VAR 0 4
91775: PPUSH
91776: LD_VAR 0 5
91780: PPUSH
91781: CALL 110792 0 3
// if cmd = 258 then
91785: LD_VAR 0 1
91789: PUSH
91790: LD_INT 258
91792: EQUAL
91793: IFFALSE 91817
// BurnTreeXYR ( unit , x , y , 8 ) ;
91795: LD_VAR 0 2
91799: PPUSH
91800: LD_VAR 0 4
91804: PPUSH
91805: LD_VAR 0 5
91809: PPUSH
91810: LD_INT 8
91812: PPUSH
91813: CALL 92216 0 4
// end ;
91817: LD_VAR 0 6
91821: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
91822: LD_INT 0
91824: PPUSH
91825: PPUSH
91826: PPUSH
91827: PPUSH
91828: PPUSH
91829: PPUSH
91830: PPUSH
91831: PPUSH
91832: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
91833: LD_VAR 0 1
91837: PPUSH
91838: CALL_OW 302
91842: NOT
91843: PUSH
91844: LD_VAR 0 2
91848: PPUSH
91849: LD_VAR 0 3
91853: PPUSH
91854: CALL_OW 488
91858: NOT
91859: OR
91860: PUSH
91861: LD_VAR 0 4
91865: NOT
91866: OR
91867: IFFALSE 91871
// exit ;
91869: GO 92211
// list := [ ] ;
91871: LD_ADDR_VAR 0 13
91875: PUSH
91876: EMPTY
91877: ST_TO_ADDR
// if x - r < 0 then
91878: LD_VAR 0 2
91882: PUSH
91883: LD_VAR 0 4
91887: MINUS
91888: PUSH
91889: LD_INT 0
91891: LESS
91892: IFFALSE 91904
// min_x := 0 else
91894: LD_ADDR_VAR 0 7
91898: PUSH
91899: LD_INT 0
91901: ST_TO_ADDR
91902: GO 91920
// min_x := x - r ;
91904: LD_ADDR_VAR 0 7
91908: PUSH
91909: LD_VAR 0 2
91913: PUSH
91914: LD_VAR 0 4
91918: MINUS
91919: ST_TO_ADDR
// if y - r < 0 then
91920: LD_VAR 0 3
91924: PUSH
91925: LD_VAR 0 4
91929: MINUS
91930: PUSH
91931: LD_INT 0
91933: LESS
91934: IFFALSE 91946
// min_y := 0 else
91936: LD_ADDR_VAR 0 8
91940: PUSH
91941: LD_INT 0
91943: ST_TO_ADDR
91944: GO 91962
// min_y := y - r ;
91946: LD_ADDR_VAR 0 8
91950: PUSH
91951: LD_VAR 0 3
91955: PUSH
91956: LD_VAR 0 4
91960: MINUS
91961: ST_TO_ADDR
// max_x := x + r ;
91962: LD_ADDR_VAR 0 9
91966: PUSH
91967: LD_VAR 0 2
91971: PUSH
91972: LD_VAR 0 4
91976: PLUS
91977: ST_TO_ADDR
// max_y := y + r ;
91978: LD_ADDR_VAR 0 10
91982: PUSH
91983: LD_VAR 0 3
91987: PUSH
91988: LD_VAR 0 4
91992: PLUS
91993: ST_TO_ADDR
// for _x = min_x to max_x do
91994: LD_ADDR_VAR 0 11
91998: PUSH
91999: DOUBLE
92000: LD_VAR 0 7
92004: DEC
92005: ST_TO_ADDR
92006: LD_VAR 0 9
92010: PUSH
92011: FOR_TO
92012: IFFALSE 92129
// for _y = min_y to max_y do
92014: LD_ADDR_VAR 0 12
92018: PUSH
92019: DOUBLE
92020: LD_VAR 0 8
92024: DEC
92025: ST_TO_ADDR
92026: LD_VAR 0 10
92030: PUSH
92031: FOR_TO
92032: IFFALSE 92125
// begin if not ValidHex ( _x , _y ) then
92034: LD_VAR 0 11
92038: PPUSH
92039: LD_VAR 0 12
92043: PPUSH
92044: CALL_OW 488
92048: NOT
92049: IFFALSE 92053
// continue ;
92051: GO 92031
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
92053: LD_VAR 0 11
92057: PPUSH
92058: LD_VAR 0 12
92062: PPUSH
92063: CALL_OW 351
92067: PUSH
92068: LD_VAR 0 11
92072: PPUSH
92073: LD_VAR 0 12
92077: PPUSH
92078: CALL_OW 554
92082: AND
92083: IFFALSE 92123
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
92085: LD_ADDR_VAR 0 13
92089: PUSH
92090: LD_VAR 0 13
92094: PPUSH
92095: LD_VAR 0 13
92099: PUSH
92100: LD_INT 1
92102: PLUS
92103: PPUSH
92104: LD_VAR 0 11
92108: PUSH
92109: LD_VAR 0 12
92113: PUSH
92114: EMPTY
92115: LIST
92116: LIST
92117: PPUSH
92118: CALL_OW 2
92122: ST_TO_ADDR
// end ;
92123: GO 92031
92125: POP
92126: POP
92127: GO 92011
92129: POP
92130: POP
// if not list then
92131: LD_VAR 0 13
92135: NOT
92136: IFFALSE 92140
// exit ;
92138: GO 92211
// for i in list do
92140: LD_ADDR_VAR 0 6
92144: PUSH
92145: LD_VAR 0 13
92149: PUSH
92150: FOR_IN
92151: IFFALSE 92209
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
92153: LD_VAR 0 1
92157: PPUSH
92158: LD_STRING M
92160: PUSH
92161: LD_VAR 0 6
92165: PUSH
92166: LD_INT 1
92168: ARRAY
92169: PUSH
92170: LD_VAR 0 6
92174: PUSH
92175: LD_INT 2
92177: ARRAY
92178: PUSH
92179: LD_INT 0
92181: PUSH
92182: LD_INT 0
92184: PUSH
92185: LD_INT 0
92187: PUSH
92188: LD_INT 0
92190: PUSH
92191: EMPTY
92192: LIST
92193: LIST
92194: LIST
92195: LIST
92196: LIST
92197: LIST
92198: LIST
92199: PUSH
92200: EMPTY
92201: LIST
92202: PPUSH
92203: CALL_OW 447
92207: GO 92150
92209: POP
92210: POP
// end ;
92211: LD_VAR 0 5
92215: RET
// function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
92216: LD_INT 0
92218: PPUSH
92219: PPUSH
92220: PPUSH
92221: PPUSH
92222: PPUSH
92223: PPUSH
92224: PPUSH
92225: PPUSH
92226: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
92227: LD_VAR 0 1
92231: PPUSH
92232: CALL_OW 302
92236: NOT
92237: PUSH
92238: LD_VAR 0 2
92242: PPUSH
92243: LD_VAR 0 3
92247: PPUSH
92248: CALL_OW 488
92252: NOT
92253: OR
92254: PUSH
92255: LD_VAR 0 4
92259: NOT
92260: OR
92261: IFFALSE 92265
// exit ;
92263: GO 92613
// list := [ ] ;
92265: LD_ADDR_VAR 0 13
92269: PUSH
92270: EMPTY
92271: ST_TO_ADDR
// if x - r < 0 then
92272: LD_VAR 0 2
92276: PUSH
92277: LD_VAR 0 4
92281: MINUS
92282: PUSH
92283: LD_INT 0
92285: LESS
92286: IFFALSE 92298
// min_x := 0 else
92288: LD_ADDR_VAR 0 7
92292: PUSH
92293: LD_INT 0
92295: ST_TO_ADDR
92296: GO 92314
// min_x := x - r ;
92298: LD_ADDR_VAR 0 7
92302: PUSH
92303: LD_VAR 0 2
92307: PUSH
92308: LD_VAR 0 4
92312: MINUS
92313: ST_TO_ADDR
// if y - r < 0 then
92314: LD_VAR 0 3
92318: PUSH
92319: LD_VAR 0 4
92323: MINUS
92324: PUSH
92325: LD_INT 0
92327: LESS
92328: IFFALSE 92340
// min_y := 0 else
92330: LD_ADDR_VAR 0 8
92334: PUSH
92335: LD_INT 0
92337: ST_TO_ADDR
92338: GO 92356
// min_y := y - r ;
92340: LD_ADDR_VAR 0 8
92344: PUSH
92345: LD_VAR 0 3
92349: PUSH
92350: LD_VAR 0 4
92354: MINUS
92355: ST_TO_ADDR
// max_x := x + r ;
92356: LD_ADDR_VAR 0 9
92360: PUSH
92361: LD_VAR 0 2
92365: PUSH
92366: LD_VAR 0 4
92370: PLUS
92371: ST_TO_ADDR
// max_y := y + r ;
92372: LD_ADDR_VAR 0 10
92376: PUSH
92377: LD_VAR 0 3
92381: PUSH
92382: LD_VAR 0 4
92386: PLUS
92387: ST_TO_ADDR
// for _x = min_x to max_x do
92388: LD_ADDR_VAR 0 11
92392: PUSH
92393: DOUBLE
92394: LD_VAR 0 7
92398: DEC
92399: ST_TO_ADDR
92400: LD_VAR 0 9
92404: PUSH
92405: FOR_TO
92406: IFFALSE 92523
// for _y = min_y to max_y do
92408: LD_ADDR_VAR 0 12
92412: PUSH
92413: DOUBLE
92414: LD_VAR 0 8
92418: DEC
92419: ST_TO_ADDR
92420: LD_VAR 0 10
92424: PUSH
92425: FOR_TO
92426: IFFALSE 92519
// begin if not ValidHex ( _x , _y ) then
92428: LD_VAR 0 11
92432: PPUSH
92433: LD_VAR 0 12
92437: PPUSH
92438: CALL_OW 488
92442: NOT
92443: IFFALSE 92447
// continue ;
92445: GO 92425
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
92447: LD_VAR 0 11
92451: PPUSH
92452: LD_VAR 0 12
92456: PPUSH
92457: CALL_OW 351
92461: PUSH
92462: LD_VAR 0 11
92466: PPUSH
92467: LD_VAR 0 12
92471: PPUSH
92472: CALL_OW 554
92476: AND
92477: IFFALSE 92517
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
92479: LD_ADDR_VAR 0 13
92483: PUSH
92484: LD_VAR 0 13
92488: PPUSH
92489: LD_VAR 0 13
92493: PUSH
92494: LD_INT 1
92496: PLUS
92497: PPUSH
92498: LD_VAR 0 11
92502: PUSH
92503: LD_VAR 0 12
92507: PUSH
92508: EMPTY
92509: LIST
92510: LIST
92511: PPUSH
92512: CALL_OW 2
92516: ST_TO_ADDR
// end ;
92517: GO 92425
92519: POP
92520: POP
92521: GO 92405
92523: POP
92524: POP
// if not list then
92525: LD_VAR 0 13
92529: NOT
92530: IFFALSE 92534
// exit ;
92532: GO 92613
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
92534: LD_ADDR_VAR 0 13
92538: PUSH
92539: LD_VAR 0 1
92543: PPUSH
92544: LD_VAR 0 13
92548: PPUSH
92549: LD_INT 1
92551: PPUSH
92552: LD_INT 1
92554: PPUSH
92555: CALL 16565 0 4
92559: ST_TO_ADDR
// ComStop ( flame ) ;
92560: LD_VAR 0 1
92564: PPUSH
92565: CALL_OW 141
// for i in list do
92569: LD_ADDR_VAR 0 6
92573: PUSH
92574: LD_VAR 0 13
92578: PUSH
92579: FOR_IN
92580: IFFALSE 92611
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
92582: LD_VAR 0 1
92586: PPUSH
92587: LD_VAR 0 6
92591: PUSH
92592: LD_INT 1
92594: ARRAY
92595: PPUSH
92596: LD_VAR 0 6
92600: PUSH
92601: LD_INT 2
92603: ARRAY
92604: PPUSH
92605: CALL_OW 176
92609: GO 92579
92611: POP
92612: POP
// end ;
92613: LD_VAR 0 5
92617: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
92618: LD_EXP 68
92622: NOT
92623: IFFALSE 92673
92625: GO 92627
92627: DISABLE
// begin initHack := true ;
92628: LD_ADDR_EXP 68
92632: PUSH
92633: LD_INT 1
92635: ST_TO_ADDR
// hackTanks := [ ] ;
92636: LD_ADDR_EXP 69
92640: PUSH
92641: EMPTY
92642: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
92643: LD_ADDR_EXP 70
92647: PUSH
92648: EMPTY
92649: ST_TO_ADDR
// hackLimit := 3 ;
92650: LD_ADDR_EXP 71
92654: PUSH
92655: LD_INT 3
92657: ST_TO_ADDR
// hackDist := 12 ;
92658: LD_ADDR_EXP 72
92662: PUSH
92663: LD_INT 12
92665: ST_TO_ADDR
// hackCounter := [ ] ;
92666: LD_ADDR_EXP 73
92670: PUSH
92671: EMPTY
92672: ST_TO_ADDR
// end ;
92673: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
92674: LD_EXP 68
92678: PUSH
92679: LD_INT 34
92681: PUSH
92682: LD_INT 99
92684: PUSH
92685: EMPTY
92686: LIST
92687: LIST
92688: PPUSH
92689: CALL_OW 69
92693: AND
92694: IFFALSE 92947
92696: GO 92698
92698: DISABLE
92699: LD_INT 0
92701: PPUSH
92702: PPUSH
// begin enable ;
92703: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
92704: LD_ADDR_VAR 0 1
92708: PUSH
92709: LD_INT 34
92711: PUSH
92712: LD_INT 99
92714: PUSH
92715: EMPTY
92716: LIST
92717: LIST
92718: PPUSH
92719: CALL_OW 69
92723: PUSH
92724: FOR_IN
92725: IFFALSE 92945
// begin if not i in hackTanks then
92727: LD_VAR 0 1
92731: PUSH
92732: LD_EXP 69
92736: IN
92737: NOT
92738: IFFALSE 92821
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
92740: LD_ADDR_EXP 69
92744: PUSH
92745: LD_EXP 69
92749: PPUSH
92750: LD_EXP 69
92754: PUSH
92755: LD_INT 1
92757: PLUS
92758: PPUSH
92759: LD_VAR 0 1
92763: PPUSH
92764: CALL_OW 1
92768: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
92769: LD_ADDR_EXP 70
92773: PUSH
92774: LD_EXP 70
92778: PPUSH
92779: LD_EXP 70
92783: PUSH
92784: LD_INT 1
92786: PLUS
92787: PPUSH
92788: EMPTY
92789: PPUSH
92790: CALL_OW 1
92794: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
92795: LD_ADDR_EXP 73
92799: PUSH
92800: LD_EXP 73
92804: PPUSH
92805: LD_EXP 73
92809: PUSH
92810: LD_INT 1
92812: PLUS
92813: PPUSH
92814: EMPTY
92815: PPUSH
92816: CALL_OW 1
92820: ST_TO_ADDR
// end ; if not IsOk ( i ) then
92821: LD_VAR 0 1
92825: PPUSH
92826: CALL_OW 302
92830: NOT
92831: IFFALSE 92844
// begin HackUnlinkAll ( i ) ;
92833: LD_VAR 0 1
92837: PPUSH
92838: CALL 92950 0 1
// continue ;
92842: GO 92724
// end ; HackCheckCapturedStatus ( i ) ;
92844: LD_VAR 0 1
92848: PPUSH
92849: CALL 93393 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
92853: LD_ADDR_VAR 0 2
92857: PUSH
92858: LD_INT 81
92860: PUSH
92861: LD_VAR 0 1
92865: PPUSH
92866: CALL_OW 255
92870: PUSH
92871: EMPTY
92872: LIST
92873: LIST
92874: PUSH
92875: LD_INT 33
92877: PUSH
92878: LD_INT 3
92880: PUSH
92881: EMPTY
92882: LIST
92883: LIST
92884: PUSH
92885: LD_INT 91
92887: PUSH
92888: LD_VAR 0 1
92892: PUSH
92893: LD_EXP 72
92897: PUSH
92898: EMPTY
92899: LIST
92900: LIST
92901: LIST
92902: PUSH
92903: LD_INT 50
92905: PUSH
92906: EMPTY
92907: LIST
92908: PUSH
92909: EMPTY
92910: LIST
92911: LIST
92912: LIST
92913: LIST
92914: PPUSH
92915: CALL_OW 69
92919: ST_TO_ADDR
// if not tmp then
92920: LD_VAR 0 2
92924: NOT
92925: IFFALSE 92929
// continue ;
92927: GO 92724
// HackLink ( i , tmp ) ;
92929: LD_VAR 0 1
92933: PPUSH
92934: LD_VAR 0 2
92938: PPUSH
92939: CALL 93086 0 2
// end ;
92943: GO 92724
92945: POP
92946: POP
// end ;
92947: PPOPN 2
92949: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
92950: LD_INT 0
92952: PPUSH
92953: PPUSH
92954: PPUSH
// if not hack in hackTanks then
92955: LD_VAR 0 1
92959: PUSH
92960: LD_EXP 69
92964: IN
92965: NOT
92966: IFFALSE 92970
// exit ;
92968: GO 93081
// index := GetElementIndex ( hackTanks , hack ) ;
92970: LD_ADDR_VAR 0 4
92974: PUSH
92975: LD_EXP 69
92979: PPUSH
92980: LD_VAR 0 1
92984: PPUSH
92985: CALL 15862 0 2
92989: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
92990: LD_EXP 70
92994: PUSH
92995: LD_VAR 0 4
92999: ARRAY
93000: IFFALSE 93081
// begin for i in hackTanksCaptured [ index ] do
93002: LD_ADDR_VAR 0 3
93006: PUSH
93007: LD_EXP 70
93011: PUSH
93012: LD_VAR 0 4
93016: ARRAY
93017: PUSH
93018: FOR_IN
93019: IFFALSE 93045
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
93021: LD_VAR 0 3
93025: PUSH
93026: LD_INT 1
93028: ARRAY
93029: PPUSH
93030: LD_VAR 0 3
93034: PUSH
93035: LD_INT 2
93037: ARRAY
93038: PPUSH
93039: CALL_OW 235
93043: GO 93018
93045: POP
93046: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
93047: LD_ADDR_EXP 70
93051: PUSH
93052: LD_EXP 70
93056: PPUSH
93057: LD_VAR 0 4
93061: PPUSH
93062: EMPTY
93063: PPUSH
93064: CALL_OW 1
93068: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
93069: LD_VAR 0 1
93073: PPUSH
93074: LD_INT 0
93076: PPUSH
93077: CALL_OW 505
// end ; end ;
93081: LD_VAR 0 2
93085: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
93086: LD_INT 0
93088: PPUSH
93089: PPUSH
93090: PPUSH
// if not hack in hackTanks or not vehicles then
93091: LD_VAR 0 1
93095: PUSH
93096: LD_EXP 69
93100: IN
93101: NOT
93102: PUSH
93103: LD_VAR 0 2
93107: NOT
93108: OR
93109: IFFALSE 93113
// exit ;
93111: GO 93388
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
93113: LD_ADDR_VAR 0 2
93117: PUSH
93118: LD_VAR 0 1
93122: PPUSH
93123: LD_VAR 0 2
93127: PPUSH
93128: LD_INT 1
93130: PPUSH
93131: LD_INT 1
93133: PPUSH
93134: CALL 16512 0 4
93138: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
93139: LD_ADDR_VAR 0 5
93143: PUSH
93144: LD_EXP 69
93148: PPUSH
93149: LD_VAR 0 1
93153: PPUSH
93154: CALL 15862 0 2
93158: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
93159: LD_EXP 70
93163: PUSH
93164: LD_VAR 0 5
93168: ARRAY
93169: PUSH
93170: LD_EXP 71
93174: LESS
93175: IFFALSE 93364
// begin for i := 1 to vehicles do
93177: LD_ADDR_VAR 0 4
93181: PUSH
93182: DOUBLE
93183: LD_INT 1
93185: DEC
93186: ST_TO_ADDR
93187: LD_VAR 0 2
93191: PUSH
93192: FOR_TO
93193: IFFALSE 93362
// begin if hackTanksCaptured [ index ] = hackLimit then
93195: LD_EXP 70
93199: PUSH
93200: LD_VAR 0 5
93204: ARRAY
93205: PUSH
93206: LD_EXP 71
93210: EQUAL
93211: IFFALSE 93215
// break ;
93213: GO 93362
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
93215: LD_ADDR_EXP 73
93219: PUSH
93220: LD_EXP 73
93224: PPUSH
93225: LD_VAR 0 5
93229: PPUSH
93230: LD_EXP 73
93234: PUSH
93235: LD_VAR 0 5
93239: ARRAY
93240: PUSH
93241: LD_INT 1
93243: PLUS
93244: PPUSH
93245: CALL_OW 1
93249: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
93250: LD_ADDR_EXP 70
93254: PUSH
93255: LD_EXP 70
93259: PPUSH
93260: LD_VAR 0 5
93264: PUSH
93265: LD_EXP 70
93269: PUSH
93270: LD_VAR 0 5
93274: ARRAY
93275: PUSH
93276: LD_INT 1
93278: PLUS
93279: PUSH
93280: EMPTY
93281: LIST
93282: LIST
93283: PPUSH
93284: LD_VAR 0 2
93288: PUSH
93289: LD_VAR 0 4
93293: ARRAY
93294: PUSH
93295: LD_VAR 0 2
93299: PUSH
93300: LD_VAR 0 4
93304: ARRAY
93305: PPUSH
93306: CALL_OW 255
93310: PUSH
93311: EMPTY
93312: LIST
93313: LIST
93314: PPUSH
93315: CALL 16077 0 3
93319: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
93320: LD_VAR 0 2
93324: PUSH
93325: LD_VAR 0 4
93329: ARRAY
93330: PPUSH
93331: LD_VAR 0 1
93335: PPUSH
93336: CALL_OW 255
93340: PPUSH
93341: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
93345: LD_VAR 0 2
93349: PUSH
93350: LD_VAR 0 4
93354: ARRAY
93355: PPUSH
93356: CALL_OW 141
// end ;
93360: GO 93192
93362: POP
93363: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
93364: LD_VAR 0 1
93368: PPUSH
93369: LD_EXP 70
93373: PUSH
93374: LD_VAR 0 5
93378: ARRAY
93379: PUSH
93380: LD_INT 0
93382: PLUS
93383: PPUSH
93384: CALL_OW 505
// end ;
93388: LD_VAR 0 3
93392: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
93393: LD_INT 0
93395: PPUSH
93396: PPUSH
93397: PPUSH
93398: PPUSH
// if not hack in hackTanks then
93399: LD_VAR 0 1
93403: PUSH
93404: LD_EXP 69
93408: IN
93409: NOT
93410: IFFALSE 93414
// exit ;
93412: GO 93654
// index := GetElementIndex ( hackTanks , hack ) ;
93414: LD_ADDR_VAR 0 4
93418: PUSH
93419: LD_EXP 69
93423: PPUSH
93424: LD_VAR 0 1
93428: PPUSH
93429: CALL 15862 0 2
93433: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
93434: LD_ADDR_VAR 0 3
93438: PUSH
93439: DOUBLE
93440: LD_EXP 70
93444: PUSH
93445: LD_VAR 0 4
93449: ARRAY
93450: INC
93451: ST_TO_ADDR
93452: LD_INT 1
93454: PUSH
93455: FOR_DOWNTO
93456: IFFALSE 93628
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
93458: LD_ADDR_VAR 0 5
93462: PUSH
93463: LD_EXP 70
93467: PUSH
93468: LD_VAR 0 4
93472: ARRAY
93473: PUSH
93474: LD_VAR 0 3
93478: ARRAY
93479: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
93480: LD_VAR 0 5
93484: PUSH
93485: LD_INT 1
93487: ARRAY
93488: PPUSH
93489: CALL_OW 302
93493: NOT
93494: PUSH
93495: LD_VAR 0 5
93499: PUSH
93500: LD_INT 1
93502: ARRAY
93503: PPUSH
93504: CALL_OW 255
93508: PUSH
93509: LD_VAR 0 1
93513: PPUSH
93514: CALL_OW 255
93518: NONEQUAL
93519: OR
93520: IFFALSE 93626
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
93522: LD_VAR 0 5
93526: PUSH
93527: LD_INT 1
93529: ARRAY
93530: PPUSH
93531: CALL_OW 305
93535: PUSH
93536: LD_VAR 0 5
93540: PUSH
93541: LD_INT 1
93543: ARRAY
93544: PPUSH
93545: CALL_OW 255
93549: PUSH
93550: LD_VAR 0 1
93554: PPUSH
93555: CALL_OW 255
93559: EQUAL
93560: AND
93561: IFFALSE 93585
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
93563: LD_VAR 0 5
93567: PUSH
93568: LD_INT 1
93570: ARRAY
93571: PPUSH
93572: LD_VAR 0 5
93576: PUSH
93577: LD_INT 2
93579: ARRAY
93580: PPUSH
93581: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
93585: LD_ADDR_EXP 70
93589: PUSH
93590: LD_EXP 70
93594: PPUSH
93595: LD_VAR 0 4
93599: PPUSH
93600: LD_EXP 70
93604: PUSH
93605: LD_VAR 0 4
93609: ARRAY
93610: PPUSH
93611: LD_VAR 0 3
93615: PPUSH
93616: CALL_OW 3
93620: PPUSH
93621: CALL_OW 1
93625: ST_TO_ADDR
// end ; end ;
93626: GO 93455
93628: POP
93629: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
93630: LD_VAR 0 1
93634: PPUSH
93635: LD_EXP 70
93639: PUSH
93640: LD_VAR 0 4
93644: ARRAY
93645: PUSH
93646: LD_INT 0
93648: PLUS
93649: PPUSH
93650: CALL_OW 505
// end ;
93654: LD_VAR 0 2
93658: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
93659: LD_INT 0
93661: PPUSH
93662: PPUSH
93663: PPUSH
93664: PPUSH
// if not hack in hackTanks then
93665: LD_VAR 0 1
93669: PUSH
93670: LD_EXP 69
93674: IN
93675: NOT
93676: IFFALSE 93680
// exit ;
93678: GO 93765
// index := GetElementIndex ( hackTanks , hack ) ;
93680: LD_ADDR_VAR 0 5
93684: PUSH
93685: LD_EXP 69
93689: PPUSH
93690: LD_VAR 0 1
93694: PPUSH
93695: CALL 15862 0 2
93699: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
93700: LD_ADDR_VAR 0 4
93704: PUSH
93705: DOUBLE
93706: LD_INT 1
93708: DEC
93709: ST_TO_ADDR
93710: LD_EXP 70
93714: PUSH
93715: LD_VAR 0 5
93719: ARRAY
93720: PUSH
93721: FOR_TO
93722: IFFALSE 93763
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
93724: LD_EXP 70
93728: PUSH
93729: LD_VAR 0 5
93733: ARRAY
93734: PUSH
93735: LD_VAR 0 4
93739: ARRAY
93740: PUSH
93741: LD_INT 1
93743: ARRAY
93744: PUSH
93745: LD_VAR 0 2
93749: EQUAL
93750: IFFALSE 93761
// KillUnit ( vehicle ) ;
93752: LD_VAR 0 2
93756: PPUSH
93757: CALL_OW 66
93761: GO 93721
93763: POP
93764: POP
// end ;
93765: LD_VAR 0 3
93769: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
93770: LD_EXP 74
93774: NOT
93775: IFFALSE 93810
93777: GO 93779
93779: DISABLE
// begin initMiner := true ;
93780: LD_ADDR_EXP 74
93784: PUSH
93785: LD_INT 1
93787: ST_TO_ADDR
// minersList := [ ] ;
93788: LD_ADDR_EXP 75
93792: PUSH
93793: EMPTY
93794: ST_TO_ADDR
// minerMinesList := [ ] ;
93795: LD_ADDR_EXP 76
93799: PUSH
93800: EMPTY
93801: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
93802: LD_ADDR_EXP 77
93806: PUSH
93807: LD_INT 5
93809: ST_TO_ADDR
// end ;
93810: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
93811: LD_EXP 74
93815: PUSH
93816: LD_INT 34
93818: PUSH
93819: LD_INT 81
93821: PUSH
93822: EMPTY
93823: LIST
93824: LIST
93825: PPUSH
93826: CALL_OW 69
93830: AND
93831: IFFALSE 94292
93833: GO 93835
93835: DISABLE
93836: LD_INT 0
93838: PPUSH
93839: PPUSH
93840: PPUSH
93841: PPUSH
// begin enable ;
93842: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
93843: LD_ADDR_VAR 0 1
93847: PUSH
93848: LD_INT 34
93850: PUSH
93851: LD_INT 81
93853: PUSH
93854: EMPTY
93855: LIST
93856: LIST
93857: PPUSH
93858: CALL_OW 69
93862: PUSH
93863: FOR_IN
93864: IFFALSE 93936
// begin if not i in minersList then
93866: LD_VAR 0 1
93870: PUSH
93871: LD_EXP 75
93875: IN
93876: NOT
93877: IFFALSE 93934
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
93879: LD_ADDR_EXP 75
93883: PUSH
93884: LD_EXP 75
93888: PPUSH
93889: LD_EXP 75
93893: PUSH
93894: LD_INT 1
93896: PLUS
93897: PPUSH
93898: LD_VAR 0 1
93902: PPUSH
93903: CALL_OW 1
93907: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
93908: LD_ADDR_EXP 76
93912: PUSH
93913: LD_EXP 76
93917: PPUSH
93918: LD_EXP 76
93922: PUSH
93923: LD_INT 1
93925: PLUS
93926: PPUSH
93927: EMPTY
93928: PPUSH
93929: CALL_OW 1
93933: ST_TO_ADDR
// end end ;
93934: GO 93863
93936: POP
93937: POP
// for i := minerMinesList downto 1 do
93938: LD_ADDR_VAR 0 1
93942: PUSH
93943: DOUBLE
93944: LD_EXP 76
93948: INC
93949: ST_TO_ADDR
93950: LD_INT 1
93952: PUSH
93953: FOR_DOWNTO
93954: IFFALSE 94290
// begin if IsLive ( minersList [ i ] ) then
93956: LD_EXP 75
93960: PUSH
93961: LD_VAR 0 1
93965: ARRAY
93966: PPUSH
93967: CALL_OW 300
93971: IFFALSE 93999
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
93973: LD_EXP 75
93977: PUSH
93978: LD_VAR 0 1
93982: ARRAY
93983: PPUSH
93984: LD_EXP 76
93988: PUSH
93989: LD_VAR 0 1
93993: ARRAY
93994: PPUSH
93995: CALL_OW 505
// if not minerMinesList [ i ] then
93999: LD_EXP 76
94003: PUSH
94004: LD_VAR 0 1
94008: ARRAY
94009: NOT
94010: IFFALSE 94014
// continue ;
94012: GO 93953
// for j := minerMinesList [ i ] downto 1 do
94014: LD_ADDR_VAR 0 2
94018: PUSH
94019: DOUBLE
94020: LD_EXP 76
94024: PUSH
94025: LD_VAR 0 1
94029: ARRAY
94030: INC
94031: ST_TO_ADDR
94032: LD_INT 1
94034: PUSH
94035: FOR_DOWNTO
94036: IFFALSE 94286
// begin side := GetSide ( minersList [ i ] ) ;
94038: LD_ADDR_VAR 0 3
94042: PUSH
94043: LD_EXP 75
94047: PUSH
94048: LD_VAR 0 1
94052: ARRAY
94053: PPUSH
94054: CALL_OW 255
94058: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
94059: LD_ADDR_VAR 0 4
94063: PUSH
94064: LD_EXP 76
94068: PUSH
94069: LD_VAR 0 1
94073: ARRAY
94074: PUSH
94075: LD_VAR 0 2
94079: ARRAY
94080: PUSH
94081: LD_INT 1
94083: ARRAY
94084: PPUSH
94085: LD_EXP 76
94089: PUSH
94090: LD_VAR 0 1
94094: ARRAY
94095: PUSH
94096: LD_VAR 0 2
94100: ARRAY
94101: PUSH
94102: LD_INT 2
94104: ARRAY
94105: PPUSH
94106: CALL_OW 428
94110: ST_TO_ADDR
// if not tmp then
94111: LD_VAR 0 4
94115: NOT
94116: IFFALSE 94120
// continue ;
94118: GO 94035
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
94120: LD_VAR 0 4
94124: PUSH
94125: LD_INT 81
94127: PUSH
94128: LD_VAR 0 3
94132: PUSH
94133: EMPTY
94134: LIST
94135: LIST
94136: PPUSH
94137: CALL_OW 69
94141: IN
94142: PUSH
94143: LD_EXP 76
94147: PUSH
94148: LD_VAR 0 1
94152: ARRAY
94153: PUSH
94154: LD_VAR 0 2
94158: ARRAY
94159: PUSH
94160: LD_INT 1
94162: ARRAY
94163: PPUSH
94164: LD_EXP 76
94168: PUSH
94169: LD_VAR 0 1
94173: ARRAY
94174: PUSH
94175: LD_VAR 0 2
94179: ARRAY
94180: PUSH
94181: LD_INT 2
94183: ARRAY
94184: PPUSH
94185: CALL_OW 458
94189: AND
94190: IFFALSE 94284
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
94192: LD_EXP 76
94196: PUSH
94197: LD_VAR 0 1
94201: ARRAY
94202: PUSH
94203: LD_VAR 0 2
94207: ARRAY
94208: PUSH
94209: LD_INT 1
94211: ARRAY
94212: PPUSH
94213: LD_EXP 76
94217: PUSH
94218: LD_VAR 0 1
94222: ARRAY
94223: PUSH
94224: LD_VAR 0 2
94228: ARRAY
94229: PUSH
94230: LD_INT 2
94232: ARRAY
94233: PPUSH
94234: LD_VAR 0 3
94238: PPUSH
94239: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
94243: LD_ADDR_EXP 76
94247: PUSH
94248: LD_EXP 76
94252: PPUSH
94253: LD_VAR 0 1
94257: PPUSH
94258: LD_EXP 76
94262: PUSH
94263: LD_VAR 0 1
94267: ARRAY
94268: PPUSH
94269: LD_VAR 0 2
94273: PPUSH
94274: CALL_OW 3
94278: PPUSH
94279: CALL_OW 1
94283: ST_TO_ADDR
// end ; end ;
94284: GO 94035
94286: POP
94287: POP
// end ;
94288: GO 93953
94290: POP
94291: POP
// end ;
94292: PPOPN 4
94294: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
94295: LD_INT 0
94297: PPUSH
94298: PPUSH
// result := false ;
94299: LD_ADDR_VAR 0 4
94303: PUSH
94304: LD_INT 0
94306: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
94307: LD_VAR 0 1
94311: PPUSH
94312: CALL_OW 264
94316: PUSH
94317: LD_INT 81
94319: EQUAL
94320: NOT
94321: IFFALSE 94325
// exit ;
94323: GO 94565
// index := GetElementIndex ( minersList , unit ) ;
94325: LD_ADDR_VAR 0 5
94329: PUSH
94330: LD_EXP 75
94334: PPUSH
94335: LD_VAR 0 1
94339: PPUSH
94340: CALL 15862 0 2
94344: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
94345: LD_EXP 76
94349: PUSH
94350: LD_VAR 0 5
94354: ARRAY
94355: PUSH
94356: LD_EXP 77
94360: GREATEREQUAL
94361: IFFALSE 94365
// exit ;
94363: GO 94565
// ComMoveXY ( unit , x , y ) ;
94365: LD_VAR 0 1
94369: PPUSH
94370: LD_VAR 0 2
94374: PPUSH
94375: LD_VAR 0 3
94379: PPUSH
94380: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
94384: LD_INT 35
94386: PPUSH
94387: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
94391: LD_VAR 0 1
94395: PPUSH
94396: LD_VAR 0 2
94400: PPUSH
94401: LD_VAR 0 3
94405: PPUSH
94406: CALL 47614 0 3
94410: NOT
94411: PUSH
94412: LD_VAR 0 1
94416: PPUSH
94417: CALL_OW 314
94421: AND
94422: IFFALSE 94426
// exit ;
94424: GO 94565
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
94426: LD_VAR 0 2
94430: PPUSH
94431: LD_VAR 0 3
94435: PPUSH
94436: CALL_OW 428
94440: PUSH
94441: LD_VAR 0 1
94445: EQUAL
94446: PUSH
94447: LD_VAR 0 1
94451: PPUSH
94452: CALL_OW 314
94456: NOT
94457: AND
94458: IFFALSE 94384
// PlaySoundXY ( x , y , PlantMine ) ;
94460: LD_VAR 0 2
94464: PPUSH
94465: LD_VAR 0 3
94469: PPUSH
94470: LD_STRING PlantMine
94472: PPUSH
94473: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
94477: LD_VAR 0 2
94481: PPUSH
94482: LD_VAR 0 3
94486: PPUSH
94487: LD_VAR 0 1
94491: PPUSH
94492: CALL_OW 255
94496: PPUSH
94497: LD_INT 0
94499: PPUSH
94500: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
94504: LD_ADDR_EXP 76
94508: PUSH
94509: LD_EXP 76
94513: PPUSH
94514: LD_VAR 0 5
94518: PUSH
94519: LD_EXP 76
94523: PUSH
94524: LD_VAR 0 5
94528: ARRAY
94529: PUSH
94530: LD_INT 1
94532: PLUS
94533: PUSH
94534: EMPTY
94535: LIST
94536: LIST
94537: PPUSH
94538: LD_VAR 0 2
94542: PUSH
94543: LD_VAR 0 3
94547: PUSH
94548: EMPTY
94549: LIST
94550: LIST
94551: PPUSH
94552: CALL 16077 0 3
94556: ST_TO_ADDR
// result := true ;
94557: LD_ADDR_VAR 0 4
94561: PUSH
94562: LD_INT 1
94564: ST_TO_ADDR
// end ;
94565: LD_VAR 0 4
94569: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
94570: LD_INT 0
94572: PPUSH
94573: PPUSH
94574: PPUSH
// if not unit in minersList then
94575: LD_VAR 0 1
94579: PUSH
94580: LD_EXP 75
94584: IN
94585: NOT
94586: IFFALSE 94590
// exit ;
94588: GO 94982
// index := GetElementIndex ( minersList , unit ) ;
94590: LD_ADDR_VAR 0 6
94594: PUSH
94595: LD_EXP 75
94599: PPUSH
94600: LD_VAR 0 1
94604: PPUSH
94605: CALL 15862 0 2
94609: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
94610: LD_ADDR_VAR 0 5
94614: PUSH
94615: DOUBLE
94616: LD_EXP 76
94620: PUSH
94621: LD_VAR 0 6
94625: ARRAY
94626: INC
94627: ST_TO_ADDR
94628: LD_INT 1
94630: PUSH
94631: FOR_DOWNTO
94632: IFFALSE 94793
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
94634: LD_EXP 76
94638: PUSH
94639: LD_VAR 0 6
94643: ARRAY
94644: PUSH
94645: LD_VAR 0 5
94649: ARRAY
94650: PUSH
94651: LD_INT 1
94653: ARRAY
94654: PUSH
94655: LD_VAR 0 2
94659: EQUAL
94660: PUSH
94661: LD_EXP 76
94665: PUSH
94666: LD_VAR 0 6
94670: ARRAY
94671: PUSH
94672: LD_VAR 0 5
94676: ARRAY
94677: PUSH
94678: LD_INT 2
94680: ARRAY
94681: PUSH
94682: LD_VAR 0 3
94686: EQUAL
94687: AND
94688: IFFALSE 94791
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
94690: LD_EXP 76
94694: PUSH
94695: LD_VAR 0 6
94699: ARRAY
94700: PUSH
94701: LD_VAR 0 5
94705: ARRAY
94706: PUSH
94707: LD_INT 1
94709: ARRAY
94710: PPUSH
94711: LD_EXP 76
94715: PUSH
94716: LD_VAR 0 6
94720: ARRAY
94721: PUSH
94722: LD_VAR 0 5
94726: ARRAY
94727: PUSH
94728: LD_INT 2
94730: ARRAY
94731: PPUSH
94732: LD_VAR 0 1
94736: PPUSH
94737: CALL_OW 255
94741: PPUSH
94742: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
94746: LD_ADDR_EXP 76
94750: PUSH
94751: LD_EXP 76
94755: PPUSH
94756: LD_VAR 0 6
94760: PPUSH
94761: LD_EXP 76
94765: PUSH
94766: LD_VAR 0 6
94770: ARRAY
94771: PPUSH
94772: LD_VAR 0 5
94776: PPUSH
94777: CALL_OW 3
94781: PPUSH
94782: CALL_OW 1
94786: ST_TO_ADDR
// exit ;
94787: POP
94788: POP
94789: GO 94982
// end ; end ;
94791: GO 94631
94793: POP
94794: POP
// for i := minerMinesList [ index ] downto 1 do
94795: LD_ADDR_VAR 0 5
94799: PUSH
94800: DOUBLE
94801: LD_EXP 76
94805: PUSH
94806: LD_VAR 0 6
94810: ARRAY
94811: INC
94812: ST_TO_ADDR
94813: LD_INT 1
94815: PUSH
94816: FOR_DOWNTO
94817: IFFALSE 94980
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
94819: LD_EXP 76
94823: PUSH
94824: LD_VAR 0 6
94828: ARRAY
94829: PUSH
94830: LD_VAR 0 5
94834: ARRAY
94835: PUSH
94836: LD_INT 1
94838: ARRAY
94839: PPUSH
94840: LD_EXP 76
94844: PUSH
94845: LD_VAR 0 6
94849: ARRAY
94850: PUSH
94851: LD_VAR 0 5
94855: ARRAY
94856: PUSH
94857: LD_INT 2
94859: ARRAY
94860: PPUSH
94861: LD_VAR 0 2
94865: PPUSH
94866: LD_VAR 0 3
94870: PPUSH
94871: CALL_OW 298
94875: PUSH
94876: LD_INT 6
94878: LESS
94879: IFFALSE 94978
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
94881: LD_EXP 76
94885: PUSH
94886: LD_VAR 0 6
94890: ARRAY
94891: PUSH
94892: LD_VAR 0 5
94896: ARRAY
94897: PUSH
94898: LD_INT 1
94900: ARRAY
94901: PPUSH
94902: LD_EXP 76
94906: PUSH
94907: LD_VAR 0 6
94911: ARRAY
94912: PUSH
94913: LD_VAR 0 5
94917: ARRAY
94918: PUSH
94919: LD_INT 2
94921: ARRAY
94922: PPUSH
94923: LD_VAR 0 1
94927: PPUSH
94928: CALL_OW 255
94932: PPUSH
94933: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
94937: LD_ADDR_EXP 76
94941: PUSH
94942: LD_EXP 76
94946: PPUSH
94947: LD_VAR 0 6
94951: PPUSH
94952: LD_EXP 76
94956: PUSH
94957: LD_VAR 0 6
94961: ARRAY
94962: PPUSH
94963: LD_VAR 0 5
94967: PPUSH
94968: CALL_OW 3
94972: PPUSH
94973: CALL_OW 1
94977: ST_TO_ADDR
// end ; end ;
94978: GO 94816
94980: POP
94981: POP
// end ;
94982: LD_VAR 0 4
94986: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
94987: LD_INT 0
94989: PPUSH
94990: PPUSH
94991: PPUSH
94992: PPUSH
94993: PPUSH
94994: PPUSH
94995: PPUSH
94996: PPUSH
94997: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
94998: LD_VAR 0 1
95002: PPUSH
95003: CALL_OW 264
95007: PUSH
95008: LD_INT 81
95010: EQUAL
95011: NOT
95012: PUSH
95013: LD_VAR 0 1
95017: PUSH
95018: LD_EXP 75
95022: IN
95023: NOT
95024: OR
95025: IFFALSE 95029
// exit ;
95027: GO 95351
// index := GetElementIndex ( minersList , unit ) ;
95029: LD_ADDR_VAR 0 6
95033: PUSH
95034: LD_EXP 75
95038: PPUSH
95039: LD_VAR 0 1
95043: PPUSH
95044: CALL 15862 0 2
95048: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
95049: LD_ADDR_VAR 0 8
95053: PUSH
95054: LD_EXP 77
95058: PUSH
95059: LD_EXP 76
95063: PUSH
95064: LD_VAR 0 6
95068: ARRAY
95069: MINUS
95070: ST_TO_ADDR
// if not minesFreeAmount then
95071: LD_VAR 0 8
95075: NOT
95076: IFFALSE 95080
// exit ;
95078: GO 95351
// tmp := [ ] ;
95080: LD_ADDR_VAR 0 7
95084: PUSH
95085: EMPTY
95086: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
95087: LD_ADDR_VAR 0 5
95091: PUSH
95092: DOUBLE
95093: LD_INT 1
95095: DEC
95096: ST_TO_ADDR
95097: LD_VAR 0 8
95101: PUSH
95102: FOR_TO
95103: IFFALSE 95298
// begin _d := rand ( 0 , 5 ) ;
95105: LD_ADDR_VAR 0 11
95109: PUSH
95110: LD_INT 0
95112: PPUSH
95113: LD_INT 5
95115: PPUSH
95116: CALL_OW 12
95120: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
95121: LD_ADDR_VAR 0 12
95125: PUSH
95126: LD_INT 2
95128: PPUSH
95129: LD_INT 6
95131: PPUSH
95132: CALL_OW 12
95136: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
95137: LD_ADDR_VAR 0 9
95141: PUSH
95142: LD_VAR 0 2
95146: PPUSH
95147: LD_VAR 0 11
95151: PPUSH
95152: LD_VAR 0 12
95156: PPUSH
95157: CALL_OW 272
95161: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
95162: LD_ADDR_VAR 0 10
95166: PUSH
95167: LD_VAR 0 3
95171: PPUSH
95172: LD_VAR 0 11
95176: PPUSH
95177: LD_VAR 0 12
95181: PPUSH
95182: CALL_OW 273
95186: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
95187: LD_VAR 0 9
95191: PPUSH
95192: LD_VAR 0 10
95196: PPUSH
95197: CALL_OW 488
95201: PUSH
95202: LD_VAR 0 9
95206: PUSH
95207: LD_VAR 0 10
95211: PUSH
95212: EMPTY
95213: LIST
95214: LIST
95215: PUSH
95216: LD_VAR 0 7
95220: IN
95221: NOT
95222: AND
95223: PUSH
95224: LD_VAR 0 9
95228: PPUSH
95229: LD_VAR 0 10
95233: PPUSH
95234: CALL_OW 458
95238: NOT
95239: AND
95240: IFFALSE 95282
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
95242: LD_ADDR_VAR 0 7
95246: PUSH
95247: LD_VAR 0 7
95251: PPUSH
95252: LD_VAR 0 7
95256: PUSH
95257: LD_INT 1
95259: PLUS
95260: PPUSH
95261: LD_VAR 0 9
95265: PUSH
95266: LD_VAR 0 10
95270: PUSH
95271: EMPTY
95272: LIST
95273: LIST
95274: PPUSH
95275: CALL_OW 1
95279: ST_TO_ADDR
95280: GO 95296
// i := i - 1 ;
95282: LD_ADDR_VAR 0 5
95286: PUSH
95287: LD_VAR 0 5
95291: PUSH
95292: LD_INT 1
95294: MINUS
95295: ST_TO_ADDR
// end ;
95296: GO 95102
95298: POP
95299: POP
// for i in tmp do
95300: LD_ADDR_VAR 0 5
95304: PUSH
95305: LD_VAR 0 7
95309: PUSH
95310: FOR_IN
95311: IFFALSE 95349
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
95313: LD_VAR 0 1
95317: PPUSH
95318: LD_VAR 0 5
95322: PUSH
95323: LD_INT 1
95325: ARRAY
95326: PPUSH
95327: LD_VAR 0 5
95331: PUSH
95332: LD_INT 2
95334: ARRAY
95335: PPUSH
95336: CALL 94295 0 3
95340: NOT
95341: IFFALSE 95347
// exit ;
95343: POP
95344: POP
95345: GO 95351
95347: GO 95310
95349: POP
95350: POP
// end ;
95351: LD_VAR 0 4
95355: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
95356: LD_INT 0
95358: PPUSH
95359: PPUSH
95360: PPUSH
95361: PPUSH
95362: PPUSH
95363: PPUSH
95364: PPUSH
// if not GetClass ( unit ) = class_sniper then
95365: LD_VAR 0 1
95369: PPUSH
95370: CALL_OW 257
95374: PUSH
95375: LD_INT 5
95377: EQUAL
95378: NOT
95379: IFFALSE 95383
// exit ;
95381: GO 95771
// dist := 8 ;
95383: LD_ADDR_VAR 0 5
95387: PUSH
95388: LD_INT 8
95390: ST_TO_ADDR
// viewRange := 12 ;
95391: LD_ADDR_VAR 0 7
95395: PUSH
95396: LD_INT 12
95398: ST_TO_ADDR
// side := GetSide ( unit ) ;
95399: LD_ADDR_VAR 0 6
95403: PUSH
95404: LD_VAR 0 1
95408: PPUSH
95409: CALL_OW 255
95413: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
95414: LD_INT 61
95416: PPUSH
95417: LD_VAR 0 6
95421: PPUSH
95422: CALL_OW 321
95426: PUSH
95427: LD_INT 2
95429: EQUAL
95430: IFFALSE 95440
// viewRange := 16 ;
95432: LD_ADDR_VAR 0 7
95436: PUSH
95437: LD_INT 16
95439: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
95440: LD_VAR 0 1
95444: PPUSH
95445: LD_VAR 0 2
95449: PPUSH
95450: LD_VAR 0 3
95454: PPUSH
95455: CALL_OW 297
95459: PUSH
95460: LD_VAR 0 5
95464: GREATER
95465: IFFALSE 95544
// begin ComMoveXY ( unit , x , y ) ;
95467: LD_VAR 0 1
95471: PPUSH
95472: LD_VAR 0 2
95476: PPUSH
95477: LD_VAR 0 3
95481: PPUSH
95482: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
95486: LD_INT 35
95488: PPUSH
95489: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
95493: LD_VAR 0 1
95497: PPUSH
95498: LD_VAR 0 2
95502: PPUSH
95503: LD_VAR 0 3
95507: PPUSH
95508: CALL 47614 0 3
95512: NOT
95513: IFFALSE 95517
// exit ;
95515: GO 95771
// until GetDistUnitXY ( unit , x , y ) < dist ;
95517: LD_VAR 0 1
95521: PPUSH
95522: LD_VAR 0 2
95526: PPUSH
95527: LD_VAR 0 3
95531: PPUSH
95532: CALL_OW 297
95536: PUSH
95537: LD_VAR 0 5
95541: LESS
95542: IFFALSE 95486
// end ; ComTurnXY ( unit , x , y ) ;
95544: LD_VAR 0 1
95548: PPUSH
95549: LD_VAR 0 2
95553: PPUSH
95554: LD_VAR 0 3
95558: PPUSH
95559: CALL_OW 118
// wait ( 5 ) ;
95563: LD_INT 5
95565: PPUSH
95566: CALL_OW 67
// _d := GetDir ( unit ) ;
95570: LD_ADDR_VAR 0 10
95574: PUSH
95575: LD_VAR 0 1
95579: PPUSH
95580: CALL_OW 254
95584: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
95585: LD_ADDR_VAR 0 8
95589: PUSH
95590: LD_VAR 0 1
95594: PPUSH
95595: CALL_OW 250
95599: PPUSH
95600: LD_VAR 0 10
95604: PPUSH
95605: LD_VAR 0 5
95609: PPUSH
95610: CALL_OW 272
95614: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
95615: LD_ADDR_VAR 0 9
95619: PUSH
95620: LD_VAR 0 1
95624: PPUSH
95625: CALL_OW 251
95629: PPUSH
95630: LD_VAR 0 10
95634: PPUSH
95635: LD_VAR 0 5
95639: PPUSH
95640: CALL_OW 273
95644: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
95645: LD_VAR 0 8
95649: PPUSH
95650: LD_VAR 0 9
95654: PPUSH
95655: CALL_OW 488
95659: NOT
95660: IFFALSE 95664
// exit ;
95662: GO 95771
// ComAnimCustom ( unit , 1 ) ;
95664: LD_VAR 0 1
95668: PPUSH
95669: LD_INT 1
95671: PPUSH
95672: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
95676: LD_VAR 0 8
95680: PPUSH
95681: LD_VAR 0 9
95685: PPUSH
95686: LD_VAR 0 6
95690: PPUSH
95691: LD_VAR 0 7
95695: PPUSH
95696: CALL_OW 330
// repeat wait ( 1 ) ;
95700: LD_INT 1
95702: PPUSH
95703: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
95707: LD_VAR 0 1
95711: PPUSH
95712: CALL_OW 316
95716: PUSH
95717: LD_VAR 0 1
95721: PPUSH
95722: CALL_OW 314
95726: OR
95727: PUSH
95728: LD_VAR 0 1
95732: PPUSH
95733: CALL_OW 302
95737: NOT
95738: OR
95739: PUSH
95740: LD_VAR 0 1
95744: PPUSH
95745: CALL_OW 301
95749: OR
95750: IFFALSE 95700
// RemoveSeeing ( _x , _y , side ) ;
95752: LD_VAR 0 8
95756: PPUSH
95757: LD_VAR 0 9
95761: PPUSH
95762: LD_VAR 0 6
95766: PPUSH
95767: CALL_OW 331
// end ; end_of_file end_of_file
95771: LD_VAR 0 4
95775: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
95776: LD_VAR 0 1
95780: PUSH
95781: LD_INT 200
95783: DOUBLE
95784: GREATEREQUAL
95785: IFFALSE 95793
95787: LD_INT 299
95789: DOUBLE
95790: LESSEQUAL
95791: IFTRUE 95795
95793: GO 95827
95795: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
95796: LD_VAR 0 1
95800: PPUSH
95801: LD_VAR 0 2
95805: PPUSH
95806: LD_VAR 0 3
95810: PPUSH
95811: LD_VAR 0 4
95815: PPUSH
95816: LD_VAR 0 5
95820: PPUSH
95821: CALL 91424 0 5
95825: GO 95904
95827: LD_INT 300
95829: DOUBLE
95830: GREATEREQUAL
95831: IFFALSE 95839
95833: LD_INT 399
95835: DOUBLE
95836: LESSEQUAL
95837: IFTRUE 95841
95839: GO 95903
95841: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
95842: LD_VAR 0 1
95846: PPUSH
95847: LD_VAR 0 2
95851: PPUSH
95852: LD_VAR 0 3
95856: PPUSH
95857: LD_VAR 0 4
95861: PPUSH
95862: LD_VAR 0 5
95866: PPUSH
95867: LD_VAR 0 6
95871: PPUSH
95872: LD_VAR 0 7
95876: PPUSH
95877: LD_VAR 0 8
95881: PPUSH
95882: LD_VAR 0 9
95886: PPUSH
95887: LD_VAR 0 10
95891: PPUSH
95892: LD_VAR 0 11
95896: PPUSH
95897: CALL 108442 0 11
95901: GO 95904
95903: POP
// end ;
95904: PPOPN 11
95906: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
95907: LD_VAR 0 1
95911: PPUSH
95912: LD_VAR 0 2
95916: PPUSH
95917: LD_VAR 0 3
95921: PPUSH
95922: LD_VAR 0 4
95926: PPUSH
95927: LD_VAR 0 5
95931: PPUSH
95932: CALL 91160 0 5
// end ; end_of_file
95936: PPOPN 5
95938: END
// export globalGameSaveCounter ; every 0 0$1 do
95939: GO 95941
95941: DISABLE
// begin enable ;
95942: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
95943: LD_STRING updateTimer(
95945: PUSH
95946: LD_OWVAR 1
95950: STR
95951: PUSH
95952: LD_STRING );
95954: STR
95955: PPUSH
95956: CALL_OW 559
// end ;
95960: END
// every 0 0$1 do
95961: GO 95963
95963: DISABLE
// begin globalGameSaveCounter := 0 ;
95964: LD_ADDR_EXP 78
95968: PUSH
95969: LD_INT 0
95971: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
95972: LD_STRING setGameSaveCounter(0)
95974: PPUSH
95975: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
95979: LD_STRING initStreamRollete();
95981: PPUSH
95982: CALL_OW 559
// InitStreamMode ;
95986: CALL 97312 0 0
// DefineStreamItems ( false ) ;
95990: LD_INT 0
95992: PPUSH
95993: CALL 97776 0 1
// end ;
95997: END
// export function SOS_MapStart ( ) ; begin
95998: LD_INT 0
96000: PPUSH
// if streamModeActive then
96001: LD_EXP 79
96005: IFFALSE 96014
// DefineStreamItems ( true ) ;
96007: LD_INT 1
96009: PPUSH
96010: CALL 97776 0 1
// UpdateLuaVariables ( ) ;
96014: CALL 96031 0 0
// UpdateFactoryWaypoints ( ) ;
96018: CALL 110645 0 0
// UpdateWarehouseGatheringPoints ( ) ;
96022: CALL 110902 0 0
// end ;
96026: LD_VAR 0 1
96030: RET
// function UpdateLuaVariables ( ) ; begin
96031: LD_INT 0
96033: PPUSH
// if globalGameSaveCounter then
96034: LD_EXP 78
96038: IFFALSE 96072
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
96040: LD_ADDR_EXP 78
96044: PUSH
96045: LD_EXP 78
96049: PPUSH
96050: CALL 50178 0 1
96054: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
96055: LD_STRING setGameSaveCounter(
96057: PUSH
96058: LD_EXP 78
96062: STR
96063: PUSH
96064: LD_STRING )
96066: STR
96067: PPUSH
96068: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
96072: LD_STRING setGameDifficulty(
96074: PUSH
96075: LD_OWVAR 67
96079: STR
96080: PUSH
96081: LD_STRING )
96083: STR
96084: PPUSH
96085: CALL_OW 559
// end ;
96089: LD_VAR 0 1
96093: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
96094: LD_INT 0
96096: PPUSH
// if p2 = stream_mode then
96097: LD_VAR 0 2
96101: PUSH
96102: LD_INT 100
96104: EQUAL
96105: IFFALSE 97108
// begin if not StreamModeActive then
96107: LD_EXP 79
96111: NOT
96112: IFFALSE 96122
// StreamModeActive := true ;
96114: LD_ADDR_EXP 79
96118: PUSH
96119: LD_INT 1
96121: ST_TO_ADDR
// if p3 = 0 then
96122: LD_VAR 0 3
96126: PUSH
96127: LD_INT 0
96129: EQUAL
96130: IFFALSE 96136
// InitStreamMode ;
96132: CALL 97312 0 0
// if p3 = 1 then
96136: LD_VAR 0 3
96140: PUSH
96141: LD_INT 1
96143: EQUAL
96144: IFFALSE 96154
// sRocket := true ;
96146: LD_ADDR_EXP 84
96150: PUSH
96151: LD_INT 1
96153: ST_TO_ADDR
// if p3 = 2 then
96154: LD_VAR 0 3
96158: PUSH
96159: LD_INT 2
96161: EQUAL
96162: IFFALSE 96172
// sSpeed := true ;
96164: LD_ADDR_EXP 83
96168: PUSH
96169: LD_INT 1
96171: ST_TO_ADDR
// if p3 = 3 then
96172: LD_VAR 0 3
96176: PUSH
96177: LD_INT 3
96179: EQUAL
96180: IFFALSE 96190
// sEngine := true ;
96182: LD_ADDR_EXP 85
96186: PUSH
96187: LD_INT 1
96189: ST_TO_ADDR
// if p3 = 4 then
96190: LD_VAR 0 3
96194: PUSH
96195: LD_INT 4
96197: EQUAL
96198: IFFALSE 96208
// sSpec := true ;
96200: LD_ADDR_EXP 82
96204: PUSH
96205: LD_INT 1
96207: ST_TO_ADDR
// if p3 = 5 then
96208: LD_VAR 0 3
96212: PUSH
96213: LD_INT 5
96215: EQUAL
96216: IFFALSE 96226
// sLevel := true ;
96218: LD_ADDR_EXP 86
96222: PUSH
96223: LD_INT 1
96225: ST_TO_ADDR
// if p3 = 6 then
96226: LD_VAR 0 3
96230: PUSH
96231: LD_INT 6
96233: EQUAL
96234: IFFALSE 96244
// sArmoury := true ;
96236: LD_ADDR_EXP 87
96240: PUSH
96241: LD_INT 1
96243: ST_TO_ADDR
// if p3 = 7 then
96244: LD_VAR 0 3
96248: PUSH
96249: LD_INT 7
96251: EQUAL
96252: IFFALSE 96262
// sRadar := true ;
96254: LD_ADDR_EXP 88
96258: PUSH
96259: LD_INT 1
96261: ST_TO_ADDR
// if p3 = 8 then
96262: LD_VAR 0 3
96266: PUSH
96267: LD_INT 8
96269: EQUAL
96270: IFFALSE 96280
// sBunker := true ;
96272: LD_ADDR_EXP 89
96276: PUSH
96277: LD_INT 1
96279: ST_TO_ADDR
// if p3 = 9 then
96280: LD_VAR 0 3
96284: PUSH
96285: LD_INT 9
96287: EQUAL
96288: IFFALSE 96298
// sHack := true ;
96290: LD_ADDR_EXP 90
96294: PUSH
96295: LD_INT 1
96297: ST_TO_ADDR
// if p3 = 10 then
96298: LD_VAR 0 3
96302: PUSH
96303: LD_INT 10
96305: EQUAL
96306: IFFALSE 96316
// sFire := true ;
96308: LD_ADDR_EXP 91
96312: PUSH
96313: LD_INT 1
96315: ST_TO_ADDR
// if p3 = 11 then
96316: LD_VAR 0 3
96320: PUSH
96321: LD_INT 11
96323: EQUAL
96324: IFFALSE 96334
// sRefresh := true ;
96326: LD_ADDR_EXP 92
96330: PUSH
96331: LD_INT 1
96333: ST_TO_ADDR
// if p3 = 12 then
96334: LD_VAR 0 3
96338: PUSH
96339: LD_INT 12
96341: EQUAL
96342: IFFALSE 96352
// sExp := true ;
96344: LD_ADDR_EXP 93
96348: PUSH
96349: LD_INT 1
96351: ST_TO_ADDR
// if p3 = 13 then
96352: LD_VAR 0 3
96356: PUSH
96357: LD_INT 13
96359: EQUAL
96360: IFFALSE 96370
// sDepot := true ;
96362: LD_ADDR_EXP 94
96366: PUSH
96367: LD_INT 1
96369: ST_TO_ADDR
// if p3 = 14 then
96370: LD_VAR 0 3
96374: PUSH
96375: LD_INT 14
96377: EQUAL
96378: IFFALSE 96388
// sFlag := true ;
96380: LD_ADDR_EXP 95
96384: PUSH
96385: LD_INT 1
96387: ST_TO_ADDR
// if p3 = 15 then
96388: LD_VAR 0 3
96392: PUSH
96393: LD_INT 15
96395: EQUAL
96396: IFFALSE 96406
// sKamikadze := true ;
96398: LD_ADDR_EXP 103
96402: PUSH
96403: LD_INT 1
96405: ST_TO_ADDR
// if p3 = 16 then
96406: LD_VAR 0 3
96410: PUSH
96411: LD_INT 16
96413: EQUAL
96414: IFFALSE 96424
// sTroll := true ;
96416: LD_ADDR_EXP 104
96420: PUSH
96421: LD_INT 1
96423: ST_TO_ADDR
// if p3 = 17 then
96424: LD_VAR 0 3
96428: PUSH
96429: LD_INT 17
96431: EQUAL
96432: IFFALSE 96442
// sSlow := true ;
96434: LD_ADDR_EXP 105
96438: PUSH
96439: LD_INT 1
96441: ST_TO_ADDR
// if p3 = 18 then
96442: LD_VAR 0 3
96446: PUSH
96447: LD_INT 18
96449: EQUAL
96450: IFFALSE 96460
// sLack := true ;
96452: LD_ADDR_EXP 106
96456: PUSH
96457: LD_INT 1
96459: ST_TO_ADDR
// if p3 = 19 then
96460: LD_VAR 0 3
96464: PUSH
96465: LD_INT 19
96467: EQUAL
96468: IFFALSE 96478
// sTank := true ;
96470: LD_ADDR_EXP 108
96474: PUSH
96475: LD_INT 1
96477: ST_TO_ADDR
// if p3 = 20 then
96478: LD_VAR 0 3
96482: PUSH
96483: LD_INT 20
96485: EQUAL
96486: IFFALSE 96496
// sRemote := true ;
96488: LD_ADDR_EXP 109
96492: PUSH
96493: LD_INT 1
96495: ST_TO_ADDR
// if p3 = 21 then
96496: LD_VAR 0 3
96500: PUSH
96501: LD_INT 21
96503: EQUAL
96504: IFFALSE 96514
// sPowell := true ;
96506: LD_ADDR_EXP 110
96510: PUSH
96511: LD_INT 1
96513: ST_TO_ADDR
// if p3 = 22 then
96514: LD_VAR 0 3
96518: PUSH
96519: LD_INT 22
96521: EQUAL
96522: IFFALSE 96532
// sTeleport := true ;
96524: LD_ADDR_EXP 113
96528: PUSH
96529: LD_INT 1
96531: ST_TO_ADDR
// if p3 = 23 then
96532: LD_VAR 0 3
96536: PUSH
96537: LD_INT 23
96539: EQUAL
96540: IFFALSE 96550
// sOilTower := true ;
96542: LD_ADDR_EXP 115
96546: PUSH
96547: LD_INT 1
96549: ST_TO_ADDR
// if p3 = 24 then
96550: LD_VAR 0 3
96554: PUSH
96555: LD_INT 24
96557: EQUAL
96558: IFFALSE 96568
// sShovel := true ;
96560: LD_ADDR_EXP 116
96564: PUSH
96565: LD_INT 1
96567: ST_TO_ADDR
// if p3 = 25 then
96568: LD_VAR 0 3
96572: PUSH
96573: LD_INT 25
96575: EQUAL
96576: IFFALSE 96586
// sSheik := true ;
96578: LD_ADDR_EXP 117
96582: PUSH
96583: LD_INT 1
96585: ST_TO_ADDR
// if p3 = 26 then
96586: LD_VAR 0 3
96590: PUSH
96591: LD_INT 26
96593: EQUAL
96594: IFFALSE 96604
// sEarthquake := true ;
96596: LD_ADDR_EXP 119
96600: PUSH
96601: LD_INT 1
96603: ST_TO_ADDR
// if p3 = 27 then
96604: LD_VAR 0 3
96608: PUSH
96609: LD_INT 27
96611: EQUAL
96612: IFFALSE 96622
// sAI := true ;
96614: LD_ADDR_EXP 120
96618: PUSH
96619: LD_INT 1
96621: ST_TO_ADDR
// if p3 = 28 then
96622: LD_VAR 0 3
96626: PUSH
96627: LD_INT 28
96629: EQUAL
96630: IFFALSE 96640
// sCargo := true ;
96632: LD_ADDR_EXP 123
96636: PUSH
96637: LD_INT 1
96639: ST_TO_ADDR
// if p3 = 29 then
96640: LD_VAR 0 3
96644: PUSH
96645: LD_INT 29
96647: EQUAL
96648: IFFALSE 96658
// sDLaser := true ;
96650: LD_ADDR_EXP 124
96654: PUSH
96655: LD_INT 1
96657: ST_TO_ADDR
// if p3 = 30 then
96658: LD_VAR 0 3
96662: PUSH
96663: LD_INT 30
96665: EQUAL
96666: IFFALSE 96676
// sExchange := true ;
96668: LD_ADDR_EXP 125
96672: PUSH
96673: LD_INT 1
96675: ST_TO_ADDR
// if p3 = 31 then
96676: LD_VAR 0 3
96680: PUSH
96681: LD_INT 31
96683: EQUAL
96684: IFFALSE 96694
// sFac := true ;
96686: LD_ADDR_EXP 126
96690: PUSH
96691: LD_INT 1
96693: ST_TO_ADDR
// if p3 = 32 then
96694: LD_VAR 0 3
96698: PUSH
96699: LD_INT 32
96701: EQUAL
96702: IFFALSE 96712
// sPower := true ;
96704: LD_ADDR_EXP 127
96708: PUSH
96709: LD_INT 1
96711: ST_TO_ADDR
// if p3 = 33 then
96712: LD_VAR 0 3
96716: PUSH
96717: LD_INT 33
96719: EQUAL
96720: IFFALSE 96730
// sRandom := true ;
96722: LD_ADDR_EXP 128
96726: PUSH
96727: LD_INT 1
96729: ST_TO_ADDR
// if p3 = 34 then
96730: LD_VAR 0 3
96734: PUSH
96735: LD_INT 34
96737: EQUAL
96738: IFFALSE 96748
// sShield := true ;
96740: LD_ADDR_EXP 129
96744: PUSH
96745: LD_INT 1
96747: ST_TO_ADDR
// if p3 = 35 then
96748: LD_VAR 0 3
96752: PUSH
96753: LD_INT 35
96755: EQUAL
96756: IFFALSE 96766
// sTime := true ;
96758: LD_ADDR_EXP 130
96762: PUSH
96763: LD_INT 1
96765: ST_TO_ADDR
// if p3 = 36 then
96766: LD_VAR 0 3
96770: PUSH
96771: LD_INT 36
96773: EQUAL
96774: IFFALSE 96784
// sTools := true ;
96776: LD_ADDR_EXP 131
96780: PUSH
96781: LD_INT 1
96783: ST_TO_ADDR
// if p3 = 101 then
96784: LD_VAR 0 3
96788: PUSH
96789: LD_INT 101
96791: EQUAL
96792: IFFALSE 96802
// sSold := true ;
96794: LD_ADDR_EXP 96
96798: PUSH
96799: LD_INT 1
96801: ST_TO_ADDR
// if p3 = 102 then
96802: LD_VAR 0 3
96806: PUSH
96807: LD_INT 102
96809: EQUAL
96810: IFFALSE 96820
// sDiff := true ;
96812: LD_ADDR_EXP 97
96816: PUSH
96817: LD_INT 1
96819: ST_TO_ADDR
// if p3 = 103 then
96820: LD_VAR 0 3
96824: PUSH
96825: LD_INT 103
96827: EQUAL
96828: IFFALSE 96838
// sFog := true ;
96830: LD_ADDR_EXP 100
96834: PUSH
96835: LD_INT 1
96837: ST_TO_ADDR
// if p3 = 104 then
96838: LD_VAR 0 3
96842: PUSH
96843: LD_INT 104
96845: EQUAL
96846: IFFALSE 96856
// sReset := true ;
96848: LD_ADDR_EXP 101
96852: PUSH
96853: LD_INT 1
96855: ST_TO_ADDR
// if p3 = 105 then
96856: LD_VAR 0 3
96860: PUSH
96861: LD_INT 105
96863: EQUAL
96864: IFFALSE 96874
// sSun := true ;
96866: LD_ADDR_EXP 102
96870: PUSH
96871: LD_INT 1
96873: ST_TO_ADDR
// if p3 = 106 then
96874: LD_VAR 0 3
96878: PUSH
96879: LD_INT 106
96881: EQUAL
96882: IFFALSE 96892
// sTiger := true ;
96884: LD_ADDR_EXP 98
96888: PUSH
96889: LD_INT 1
96891: ST_TO_ADDR
// if p3 = 107 then
96892: LD_VAR 0 3
96896: PUSH
96897: LD_INT 107
96899: EQUAL
96900: IFFALSE 96910
// sBomb := true ;
96902: LD_ADDR_EXP 99
96906: PUSH
96907: LD_INT 1
96909: ST_TO_ADDR
// if p3 = 108 then
96910: LD_VAR 0 3
96914: PUSH
96915: LD_INT 108
96917: EQUAL
96918: IFFALSE 96928
// sWound := true ;
96920: LD_ADDR_EXP 107
96924: PUSH
96925: LD_INT 1
96927: ST_TO_ADDR
// if p3 = 109 then
96928: LD_VAR 0 3
96932: PUSH
96933: LD_INT 109
96935: EQUAL
96936: IFFALSE 96946
// sBetray := true ;
96938: LD_ADDR_EXP 111
96942: PUSH
96943: LD_INT 1
96945: ST_TO_ADDR
// if p3 = 110 then
96946: LD_VAR 0 3
96950: PUSH
96951: LD_INT 110
96953: EQUAL
96954: IFFALSE 96964
// sContamin := true ;
96956: LD_ADDR_EXP 112
96960: PUSH
96961: LD_INT 1
96963: ST_TO_ADDR
// if p3 = 111 then
96964: LD_VAR 0 3
96968: PUSH
96969: LD_INT 111
96971: EQUAL
96972: IFFALSE 96982
// sOil := true ;
96974: LD_ADDR_EXP 114
96978: PUSH
96979: LD_INT 1
96981: ST_TO_ADDR
// if p3 = 112 then
96982: LD_VAR 0 3
96986: PUSH
96987: LD_INT 112
96989: EQUAL
96990: IFFALSE 97000
// sStu := true ;
96992: LD_ADDR_EXP 118
96996: PUSH
96997: LD_INT 1
96999: ST_TO_ADDR
// if p3 = 113 then
97000: LD_VAR 0 3
97004: PUSH
97005: LD_INT 113
97007: EQUAL
97008: IFFALSE 97018
// sBazooka := true ;
97010: LD_ADDR_EXP 121
97014: PUSH
97015: LD_INT 1
97017: ST_TO_ADDR
// if p3 = 114 then
97018: LD_VAR 0 3
97022: PUSH
97023: LD_INT 114
97025: EQUAL
97026: IFFALSE 97036
// sMortar := true ;
97028: LD_ADDR_EXP 122
97032: PUSH
97033: LD_INT 1
97035: ST_TO_ADDR
// if p3 = 115 then
97036: LD_VAR 0 3
97040: PUSH
97041: LD_INT 115
97043: EQUAL
97044: IFFALSE 97054
// sRanger := true ;
97046: LD_ADDR_EXP 132
97050: PUSH
97051: LD_INT 1
97053: ST_TO_ADDR
// if p3 = 116 then
97054: LD_VAR 0 3
97058: PUSH
97059: LD_INT 116
97061: EQUAL
97062: IFFALSE 97072
// sComputer := true ;
97064: LD_ADDR_EXP 133
97068: PUSH
97069: LD_INT 1
97071: ST_TO_ADDR
// if p3 = 117 then
97072: LD_VAR 0 3
97076: PUSH
97077: LD_INT 117
97079: EQUAL
97080: IFFALSE 97090
// s30 := true ;
97082: LD_ADDR_EXP 134
97086: PUSH
97087: LD_INT 1
97089: ST_TO_ADDR
// if p3 = 118 then
97090: LD_VAR 0 3
97094: PUSH
97095: LD_INT 118
97097: EQUAL
97098: IFFALSE 97108
// s60 := true ;
97100: LD_ADDR_EXP 135
97104: PUSH
97105: LD_INT 1
97107: ST_TO_ADDR
// end ; if p2 = hack_mode then
97108: LD_VAR 0 2
97112: PUSH
97113: LD_INT 101
97115: EQUAL
97116: IFFALSE 97244
// begin case p3 of 1 :
97118: LD_VAR 0 3
97122: PUSH
97123: LD_INT 1
97125: DOUBLE
97126: EQUAL
97127: IFTRUE 97131
97129: GO 97138
97131: POP
// hHackUnlimitedResources ; 2 :
97132: CALL 109391 0 0
97136: GO 97244
97138: LD_INT 2
97140: DOUBLE
97141: EQUAL
97142: IFTRUE 97146
97144: GO 97153
97146: POP
// hHackSetLevel10 ; 3 :
97147: CALL 109524 0 0
97151: GO 97244
97153: LD_INT 3
97155: DOUBLE
97156: EQUAL
97157: IFTRUE 97161
97159: GO 97168
97161: POP
// hHackSetLevel10YourUnits ; 4 :
97162: CALL 109609 0 0
97166: GO 97244
97168: LD_INT 4
97170: DOUBLE
97171: EQUAL
97172: IFTRUE 97176
97174: GO 97183
97176: POP
// hHackInvincible ; 5 :
97177: CALL 110057 0 0
97181: GO 97244
97183: LD_INT 5
97185: DOUBLE
97186: EQUAL
97187: IFTRUE 97191
97189: GO 97198
97191: POP
// hHackInvisible ; 6 :
97192: CALL 110168 0 0
97196: GO 97244
97198: LD_INT 6
97200: DOUBLE
97201: EQUAL
97202: IFTRUE 97206
97204: GO 97213
97206: POP
// hHackChangeYourSide ; 7 :
97207: CALL 110225 0 0
97211: GO 97244
97213: LD_INT 7
97215: DOUBLE
97216: EQUAL
97217: IFTRUE 97221
97219: GO 97228
97221: POP
// hHackChangeUnitSide ; 8 :
97222: CALL 110267 0 0
97226: GO 97244
97228: LD_INT 8
97230: DOUBLE
97231: EQUAL
97232: IFTRUE 97236
97234: GO 97243
97236: POP
// hHackFog ; end ;
97237: CALL 110368 0 0
97241: GO 97244
97243: POP
// end ; if p2 = game_save_mode then
97244: LD_VAR 0 2
97248: PUSH
97249: LD_INT 102
97251: EQUAL
97252: IFFALSE 97307
// begin if p3 = 1 then
97254: LD_VAR 0 3
97258: PUSH
97259: LD_INT 1
97261: EQUAL
97262: IFFALSE 97274
// globalGameSaveCounter := p4 ;
97264: LD_ADDR_EXP 78
97268: PUSH
97269: LD_VAR 0 4
97273: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
97274: LD_VAR 0 3
97278: PUSH
97279: LD_INT 2
97281: EQUAL
97282: PUSH
97283: LD_EXP 78
97287: AND
97288: IFFALSE 97307
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
97290: LD_STRING setGameSaveCounter(
97292: PUSH
97293: LD_EXP 78
97297: STR
97298: PUSH
97299: LD_STRING )
97301: STR
97302: PPUSH
97303: CALL_OW 559
// end ; end ;
97307: LD_VAR 0 7
97311: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
97312: LD_INT 0
97314: PPUSH
// streamModeActive := false ;
97315: LD_ADDR_EXP 79
97319: PUSH
97320: LD_INT 0
97322: ST_TO_ADDR
// normalCounter := 36 ;
97323: LD_ADDR_EXP 80
97327: PUSH
97328: LD_INT 36
97330: ST_TO_ADDR
// hardcoreCounter := 18 ;
97331: LD_ADDR_EXP 81
97335: PUSH
97336: LD_INT 18
97338: ST_TO_ADDR
// sRocket := false ;
97339: LD_ADDR_EXP 84
97343: PUSH
97344: LD_INT 0
97346: ST_TO_ADDR
// sSpeed := false ;
97347: LD_ADDR_EXP 83
97351: PUSH
97352: LD_INT 0
97354: ST_TO_ADDR
// sEngine := false ;
97355: LD_ADDR_EXP 85
97359: PUSH
97360: LD_INT 0
97362: ST_TO_ADDR
// sSpec := false ;
97363: LD_ADDR_EXP 82
97367: PUSH
97368: LD_INT 0
97370: ST_TO_ADDR
// sLevel := false ;
97371: LD_ADDR_EXP 86
97375: PUSH
97376: LD_INT 0
97378: ST_TO_ADDR
// sArmoury := false ;
97379: LD_ADDR_EXP 87
97383: PUSH
97384: LD_INT 0
97386: ST_TO_ADDR
// sRadar := false ;
97387: LD_ADDR_EXP 88
97391: PUSH
97392: LD_INT 0
97394: ST_TO_ADDR
// sBunker := false ;
97395: LD_ADDR_EXP 89
97399: PUSH
97400: LD_INT 0
97402: ST_TO_ADDR
// sHack := false ;
97403: LD_ADDR_EXP 90
97407: PUSH
97408: LD_INT 0
97410: ST_TO_ADDR
// sFire := false ;
97411: LD_ADDR_EXP 91
97415: PUSH
97416: LD_INT 0
97418: ST_TO_ADDR
// sRefresh := false ;
97419: LD_ADDR_EXP 92
97423: PUSH
97424: LD_INT 0
97426: ST_TO_ADDR
// sExp := false ;
97427: LD_ADDR_EXP 93
97431: PUSH
97432: LD_INT 0
97434: ST_TO_ADDR
// sDepot := false ;
97435: LD_ADDR_EXP 94
97439: PUSH
97440: LD_INT 0
97442: ST_TO_ADDR
// sFlag := false ;
97443: LD_ADDR_EXP 95
97447: PUSH
97448: LD_INT 0
97450: ST_TO_ADDR
// sKamikadze := false ;
97451: LD_ADDR_EXP 103
97455: PUSH
97456: LD_INT 0
97458: ST_TO_ADDR
// sTroll := false ;
97459: LD_ADDR_EXP 104
97463: PUSH
97464: LD_INT 0
97466: ST_TO_ADDR
// sSlow := false ;
97467: LD_ADDR_EXP 105
97471: PUSH
97472: LD_INT 0
97474: ST_TO_ADDR
// sLack := false ;
97475: LD_ADDR_EXP 106
97479: PUSH
97480: LD_INT 0
97482: ST_TO_ADDR
// sTank := false ;
97483: LD_ADDR_EXP 108
97487: PUSH
97488: LD_INT 0
97490: ST_TO_ADDR
// sRemote := false ;
97491: LD_ADDR_EXP 109
97495: PUSH
97496: LD_INT 0
97498: ST_TO_ADDR
// sPowell := false ;
97499: LD_ADDR_EXP 110
97503: PUSH
97504: LD_INT 0
97506: ST_TO_ADDR
// sTeleport := false ;
97507: LD_ADDR_EXP 113
97511: PUSH
97512: LD_INT 0
97514: ST_TO_ADDR
// sOilTower := false ;
97515: LD_ADDR_EXP 115
97519: PUSH
97520: LD_INT 0
97522: ST_TO_ADDR
// sShovel := false ;
97523: LD_ADDR_EXP 116
97527: PUSH
97528: LD_INT 0
97530: ST_TO_ADDR
// sSheik := false ;
97531: LD_ADDR_EXP 117
97535: PUSH
97536: LD_INT 0
97538: ST_TO_ADDR
// sEarthquake := false ;
97539: LD_ADDR_EXP 119
97543: PUSH
97544: LD_INT 0
97546: ST_TO_ADDR
// sAI := false ;
97547: LD_ADDR_EXP 120
97551: PUSH
97552: LD_INT 0
97554: ST_TO_ADDR
// sCargo := false ;
97555: LD_ADDR_EXP 123
97559: PUSH
97560: LD_INT 0
97562: ST_TO_ADDR
// sDLaser := false ;
97563: LD_ADDR_EXP 124
97567: PUSH
97568: LD_INT 0
97570: ST_TO_ADDR
// sExchange := false ;
97571: LD_ADDR_EXP 125
97575: PUSH
97576: LD_INT 0
97578: ST_TO_ADDR
// sFac := false ;
97579: LD_ADDR_EXP 126
97583: PUSH
97584: LD_INT 0
97586: ST_TO_ADDR
// sPower := false ;
97587: LD_ADDR_EXP 127
97591: PUSH
97592: LD_INT 0
97594: ST_TO_ADDR
// sRandom := false ;
97595: LD_ADDR_EXP 128
97599: PUSH
97600: LD_INT 0
97602: ST_TO_ADDR
// sShield := false ;
97603: LD_ADDR_EXP 129
97607: PUSH
97608: LD_INT 0
97610: ST_TO_ADDR
// sTime := false ;
97611: LD_ADDR_EXP 130
97615: PUSH
97616: LD_INT 0
97618: ST_TO_ADDR
// sTools := false ;
97619: LD_ADDR_EXP 131
97623: PUSH
97624: LD_INT 0
97626: ST_TO_ADDR
// sSold := false ;
97627: LD_ADDR_EXP 96
97631: PUSH
97632: LD_INT 0
97634: ST_TO_ADDR
// sDiff := false ;
97635: LD_ADDR_EXP 97
97639: PUSH
97640: LD_INT 0
97642: ST_TO_ADDR
// sFog := false ;
97643: LD_ADDR_EXP 100
97647: PUSH
97648: LD_INT 0
97650: ST_TO_ADDR
// sReset := false ;
97651: LD_ADDR_EXP 101
97655: PUSH
97656: LD_INT 0
97658: ST_TO_ADDR
// sSun := false ;
97659: LD_ADDR_EXP 102
97663: PUSH
97664: LD_INT 0
97666: ST_TO_ADDR
// sTiger := false ;
97667: LD_ADDR_EXP 98
97671: PUSH
97672: LD_INT 0
97674: ST_TO_ADDR
// sBomb := false ;
97675: LD_ADDR_EXP 99
97679: PUSH
97680: LD_INT 0
97682: ST_TO_ADDR
// sWound := false ;
97683: LD_ADDR_EXP 107
97687: PUSH
97688: LD_INT 0
97690: ST_TO_ADDR
// sBetray := false ;
97691: LD_ADDR_EXP 111
97695: PUSH
97696: LD_INT 0
97698: ST_TO_ADDR
// sContamin := false ;
97699: LD_ADDR_EXP 112
97703: PUSH
97704: LD_INT 0
97706: ST_TO_ADDR
// sOil := false ;
97707: LD_ADDR_EXP 114
97711: PUSH
97712: LD_INT 0
97714: ST_TO_ADDR
// sStu := false ;
97715: LD_ADDR_EXP 118
97719: PUSH
97720: LD_INT 0
97722: ST_TO_ADDR
// sBazooka := false ;
97723: LD_ADDR_EXP 121
97727: PUSH
97728: LD_INT 0
97730: ST_TO_ADDR
// sMortar := false ;
97731: LD_ADDR_EXP 122
97735: PUSH
97736: LD_INT 0
97738: ST_TO_ADDR
// sRanger := false ;
97739: LD_ADDR_EXP 132
97743: PUSH
97744: LD_INT 0
97746: ST_TO_ADDR
// sComputer := false ;
97747: LD_ADDR_EXP 133
97751: PUSH
97752: LD_INT 0
97754: ST_TO_ADDR
// s30 := false ;
97755: LD_ADDR_EXP 134
97759: PUSH
97760: LD_INT 0
97762: ST_TO_ADDR
// s60 := false ;
97763: LD_ADDR_EXP 135
97767: PUSH
97768: LD_INT 0
97770: ST_TO_ADDR
// end ;
97771: LD_VAR 0 1
97775: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
97776: LD_INT 0
97778: PPUSH
97779: PPUSH
97780: PPUSH
97781: PPUSH
97782: PPUSH
97783: PPUSH
97784: PPUSH
// result := [ ] ;
97785: LD_ADDR_VAR 0 2
97789: PUSH
97790: EMPTY
97791: ST_TO_ADDR
// if campaign_id = 1 then
97792: LD_OWVAR 69
97796: PUSH
97797: LD_INT 1
97799: EQUAL
97800: IFFALSE 100966
// begin case mission_number of 1 :
97802: LD_OWVAR 70
97806: PUSH
97807: LD_INT 1
97809: DOUBLE
97810: EQUAL
97811: IFTRUE 97815
97813: GO 97891
97815: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
97816: LD_ADDR_VAR 0 2
97820: PUSH
97821: LD_INT 2
97823: PUSH
97824: LD_INT 4
97826: PUSH
97827: LD_INT 11
97829: PUSH
97830: LD_INT 12
97832: PUSH
97833: LD_INT 15
97835: PUSH
97836: LD_INT 16
97838: PUSH
97839: LD_INT 22
97841: PUSH
97842: LD_INT 23
97844: PUSH
97845: LD_INT 26
97847: PUSH
97848: EMPTY
97849: LIST
97850: LIST
97851: LIST
97852: LIST
97853: LIST
97854: LIST
97855: LIST
97856: LIST
97857: LIST
97858: PUSH
97859: LD_INT 101
97861: PUSH
97862: LD_INT 102
97864: PUSH
97865: LD_INT 106
97867: PUSH
97868: LD_INT 116
97870: PUSH
97871: LD_INT 117
97873: PUSH
97874: LD_INT 118
97876: PUSH
97877: EMPTY
97878: LIST
97879: LIST
97880: LIST
97881: LIST
97882: LIST
97883: LIST
97884: PUSH
97885: EMPTY
97886: LIST
97887: LIST
97888: ST_TO_ADDR
97889: GO 100964
97891: LD_INT 2
97893: DOUBLE
97894: EQUAL
97895: IFTRUE 97899
97897: GO 97983
97899: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
97900: LD_ADDR_VAR 0 2
97904: PUSH
97905: LD_INT 2
97907: PUSH
97908: LD_INT 4
97910: PUSH
97911: LD_INT 11
97913: PUSH
97914: LD_INT 12
97916: PUSH
97917: LD_INT 15
97919: PUSH
97920: LD_INT 16
97922: PUSH
97923: LD_INT 22
97925: PUSH
97926: LD_INT 23
97928: PUSH
97929: LD_INT 26
97931: PUSH
97932: EMPTY
97933: LIST
97934: LIST
97935: LIST
97936: LIST
97937: LIST
97938: LIST
97939: LIST
97940: LIST
97941: LIST
97942: PUSH
97943: LD_INT 101
97945: PUSH
97946: LD_INT 102
97948: PUSH
97949: LD_INT 105
97951: PUSH
97952: LD_INT 106
97954: PUSH
97955: LD_INT 108
97957: PUSH
97958: LD_INT 116
97960: PUSH
97961: LD_INT 117
97963: PUSH
97964: LD_INT 118
97966: PUSH
97967: EMPTY
97968: LIST
97969: LIST
97970: LIST
97971: LIST
97972: LIST
97973: LIST
97974: LIST
97975: LIST
97976: PUSH
97977: EMPTY
97978: LIST
97979: LIST
97980: ST_TO_ADDR
97981: GO 100964
97983: LD_INT 3
97985: DOUBLE
97986: EQUAL
97987: IFTRUE 97991
97989: GO 98079
97991: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
97992: LD_ADDR_VAR 0 2
97996: PUSH
97997: LD_INT 2
97999: PUSH
98000: LD_INT 4
98002: PUSH
98003: LD_INT 5
98005: PUSH
98006: LD_INT 11
98008: PUSH
98009: LD_INT 12
98011: PUSH
98012: LD_INT 15
98014: PUSH
98015: LD_INT 16
98017: PUSH
98018: LD_INT 22
98020: PUSH
98021: LD_INT 26
98023: PUSH
98024: LD_INT 36
98026: PUSH
98027: EMPTY
98028: LIST
98029: LIST
98030: LIST
98031: LIST
98032: LIST
98033: LIST
98034: LIST
98035: LIST
98036: LIST
98037: LIST
98038: PUSH
98039: LD_INT 101
98041: PUSH
98042: LD_INT 102
98044: PUSH
98045: LD_INT 105
98047: PUSH
98048: LD_INT 106
98050: PUSH
98051: LD_INT 108
98053: PUSH
98054: LD_INT 116
98056: PUSH
98057: LD_INT 117
98059: PUSH
98060: LD_INT 118
98062: PUSH
98063: EMPTY
98064: LIST
98065: LIST
98066: LIST
98067: LIST
98068: LIST
98069: LIST
98070: LIST
98071: LIST
98072: PUSH
98073: EMPTY
98074: LIST
98075: LIST
98076: ST_TO_ADDR
98077: GO 100964
98079: LD_INT 4
98081: DOUBLE
98082: EQUAL
98083: IFTRUE 98087
98085: GO 98183
98087: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
98088: LD_ADDR_VAR 0 2
98092: PUSH
98093: LD_INT 2
98095: PUSH
98096: LD_INT 4
98098: PUSH
98099: LD_INT 5
98101: PUSH
98102: LD_INT 8
98104: PUSH
98105: LD_INT 11
98107: PUSH
98108: LD_INT 12
98110: PUSH
98111: LD_INT 15
98113: PUSH
98114: LD_INT 16
98116: PUSH
98117: LD_INT 22
98119: PUSH
98120: LD_INT 23
98122: PUSH
98123: LD_INT 26
98125: PUSH
98126: LD_INT 36
98128: PUSH
98129: EMPTY
98130: LIST
98131: LIST
98132: LIST
98133: LIST
98134: LIST
98135: LIST
98136: LIST
98137: LIST
98138: LIST
98139: LIST
98140: LIST
98141: LIST
98142: PUSH
98143: LD_INT 101
98145: PUSH
98146: LD_INT 102
98148: PUSH
98149: LD_INT 105
98151: PUSH
98152: LD_INT 106
98154: PUSH
98155: LD_INT 108
98157: PUSH
98158: LD_INT 116
98160: PUSH
98161: LD_INT 117
98163: PUSH
98164: LD_INT 118
98166: PUSH
98167: EMPTY
98168: LIST
98169: LIST
98170: LIST
98171: LIST
98172: LIST
98173: LIST
98174: LIST
98175: LIST
98176: PUSH
98177: EMPTY
98178: LIST
98179: LIST
98180: ST_TO_ADDR
98181: GO 100964
98183: LD_INT 5
98185: DOUBLE
98186: EQUAL
98187: IFTRUE 98191
98189: GO 98303
98191: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
98192: LD_ADDR_VAR 0 2
98196: PUSH
98197: LD_INT 2
98199: PUSH
98200: LD_INT 4
98202: PUSH
98203: LD_INT 5
98205: PUSH
98206: LD_INT 6
98208: PUSH
98209: LD_INT 8
98211: PUSH
98212: LD_INT 11
98214: PUSH
98215: LD_INT 12
98217: PUSH
98218: LD_INT 15
98220: PUSH
98221: LD_INT 16
98223: PUSH
98224: LD_INT 22
98226: PUSH
98227: LD_INT 23
98229: PUSH
98230: LD_INT 25
98232: PUSH
98233: LD_INT 26
98235: PUSH
98236: LD_INT 36
98238: PUSH
98239: EMPTY
98240: LIST
98241: LIST
98242: LIST
98243: LIST
98244: LIST
98245: LIST
98246: LIST
98247: LIST
98248: LIST
98249: LIST
98250: LIST
98251: LIST
98252: LIST
98253: LIST
98254: PUSH
98255: LD_INT 101
98257: PUSH
98258: LD_INT 102
98260: PUSH
98261: LD_INT 105
98263: PUSH
98264: LD_INT 106
98266: PUSH
98267: LD_INT 108
98269: PUSH
98270: LD_INT 109
98272: PUSH
98273: LD_INT 112
98275: PUSH
98276: LD_INT 116
98278: PUSH
98279: LD_INT 117
98281: PUSH
98282: LD_INT 118
98284: PUSH
98285: EMPTY
98286: LIST
98287: LIST
98288: LIST
98289: LIST
98290: LIST
98291: LIST
98292: LIST
98293: LIST
98294: LIST
98295: LIST
98296: PUSH
98297: EMPTY
98298: LIST
98299: LIST
98300: ST_TO_ADDR
98301: GO 100964
98303: LD_INT 6
98305: DOUBLE
98306: EQUAL
98307: IFTRUE 98311
98309: GO 98443
98311: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
98312: LD_ADDR_VAR 0 2
98316: PUSH
98317: LD_INT 2
98319: PUSH
98320: LD_INT 4
98322: PUSH
98323: LD_INT 5
98325: PUSH
98326: LD_INT 6
98328: PUSH
98329: LD_INT 8
98331: PUSH
98332: LD_INT 11
98334: PUSH
98335: LD_INT 12
98337: PUSH
98338: LD_INT 15
98340: PUSH
98341: LD_INT 16
98343: PUSH
98344: LD_INT 20
98346: PUSH
98347: LD_INT 21
98349: PUSH
98350: LD_INT 22
98352: PUSH
98353: LD_INT 23
98355: PUSH
98356: LD_INT 25
98358: PUSH
98359: LD_INT 26
98361: PUSH
98362: LD_INT 30
98364: PUSH
98365: LD_INT 31
98367: PUSH
98368: LD_INT 32
98370: PUSH
98371: LD_INT 36
98373: PUSH
98374: EMPTY
98375: LIST
98376: LIST
98377: LIST
98378: LIST
98379: LIST
98380: LIST
98381: LIST
98382: LIST
98383: LIST
98384: LIST
98385: LIST
98386: LIST
98387: LIST
98388: LIST
98389: LIST
98390: LIST
98391: LIST
98392: LIST
98393: LIST
98394: PUSH
98395: LD_INT 101
98397: PUSH
98398: LD_INT 102
98400: PUSH
98401: LD_INT 105
98403: PUSH
98404: LD_INT 106
98406: PUSH
98407: LD_INT 108
98409: PUSH
98410: LD_INT 109
98412: PUSH
98413: LD_INT 112
98415: PUSH
98416: LD_INT 116
98418: PUSH
98419: LD_INT 117
98421: PUSH
98422: LD_INT 118
98424: PUSH
98425: EMPTY
98426: LIST
98427: LIST
98428: LIST
98429: LIST
98430: LIST
98431: LIST
98432: LIST
98433: LIST
98434: LIST
98435: LIST
98436: PUSH
98437: EMPTY
98438: LIST
98439: LIST
98440: ST_TO_ADDR
98441: GO 100964
98443: LD_INT 7
98445: DOUBLE
98446: EQUAL
98447: IFTRUE 98451
98449: GO 98563
98451: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
98452: LD_ADDR_VAR 0 2
98456: PUSH
98457: LD_INT 2
98459: PUSH
98460: LD_INT 4
98462: PUSH
98463: LD_INT 5
98465: PUSH
98466: LD_INT 7
98468: PUSH
98469: LD_INT 11
98471: PUSH
98472: LD_INT 12
98474: PUSH
98475: LD_INT 15
98477: PUSH
98478: LD_INT 16
98480: PUSH
98481: LD_INT 20
98483: PUSH
98484: LD_INT 21
98486: PUSH
98487: LD_INT 22
98489: PUSH
98490: LD_INT 23
98492: PUSH
98493: LD_INT 25
98495: PUSH
98496: LD_INT 26
98498: PUSH
98499: EMPTY
98500: LIST
98501: LIST
98502: LIST
98503: LIST
98504: LIST
98505: LIST
98506: LIST
98507: LIST
98508: LIST
98509: LIST
98510: LIST
98511: LIST
98512: LIST
98513: LIST
98514: PUSH
98515: LD_INT 101
98517: PUSH
98518: LD_INT 102
98520: PUSH
98521: LD_INT 103
98523: PUSH
98524: LD_INT 105
98526: PUSH
98527: LD_INT 106
98529: PUSH
98530: LD_INT 108
98532: PUSH
98533: LD_INT 112
98535: PUSH
98536: LD_INT 116
98538: PUSH
98539: LD_INT 117
98541: PUSH
98542: LD_INT 118
98544: PUSH
98545: EMPTY
98546: LIST
98547: LIST
98548: LIST
98549: LIST
98550: LIST
98551: LIST
98552: LIST
98553: LIST
98554: LIST
98555: LIST
98556: PUSH
98557: EMPTY
98558: LIST
98559: LIST
98560: ST_TO_ADDR
98561: GO 100964
98563: LD_INT 8
98565: DOUBLE
98566: EQUAL
98567: IFTRUE 98571
98569: GO 98711
98571: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
98572: LD_ADDR_VAR 0 2
98576: PUSH
98577: LD_INT 2
98579: PUSH
98580: LD_INT 4
98582: PUSH
98583: LD_INT 5
98585: PUSH
98586: LD_INT 6
98588: PUSH
98589: LD_INT 7
98591: PUSH
98592: LD_INT 8
98594: PUSH
98595: LD_INT 11
98597: PUSH
98598: LD_INT 12
98600: PUSH
98601: LD_INT 15
98603: PUSH
98604: LD_INT 16
98606: PUSH
98607: LD_INT 20
98609: PUSH
98610: LD_INT 21
98612: PUSH
98613: LD_INT 22
98615: PUSH
98616: LD_INT 23
98618: PUSH
98619: LD_INT 25
98621: PUSH
98622: LD_INT 26
98624: PUSH
98625: LD_INT 30
98627: PUSH
98628: LD_INT 31
98630: PUSH
98631: LD_INT 32
98633: PUSH
98634: LD_INT 36
98636: PUSH
98637: EMPTY
98638: LIST
98639: LIST
98640: LIST
98641: LIST
98642: LIST
98643: LIST
98644: LIST
98645: LIST
98646: LIST
98647: LIST
98648: LIST
98649: LIST
98650: LIST
98651: LIST
98652: LIST
98653: LIST
98654: LIST
98655: LIST
98656: LIST
98657: LIST
98658: PUSH
98659: LD_INT 101
98661: PUSH
98662: LD_INT 102
98664: PUSH
98665: LD_INT 103
98667: PUSH
98668: LD_INT 105
98670: PUSH
98671: LD_INT 106
98673: PUSH
98674: LD_INT 108
98676: PUSH
98677: LD_INT 109
98679: PUSH
98680: LD_INT 112
98682: PUSH
98683: LD_INT 116
98685: PUSH
98686: LD_INT 117
98688: PUSH
98689: LD_INT 118
98691: PUSH
98692: EMPTY
98693: LIST
98694: LIST
98695: LIST
98696: LIST
98697: LIST
98698: LIST
98699: LIST
98700: LIST
98701: LIST
98702: LIST
98703: LIST
98704: PUSH
98705: EMPTY
98706: LIST
98707: LIST
98708: ST_TO_ADDR
98709: GO 100964
98711: LD_INT 9
98713: DOUBLE
98714: EQUAL
98715: IFTRUE 98719
98717: GO 98867
98719: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
98720: LD_ADDR_VAR 0 2
98724: PUSH
98725: LD_INT 2
98727: PUSH
98728: LD_INT 4
98730: PUSH
98731: LD_INT 5
98733: PUSH
98734: LD_INT 6
98736: PUSH
98737: LD_INT 7
98739: PUSH
98740: LD_INT 8
98742: PUSH
98743: LD_INT 11
98745: PUSH
98746: LD_INT 12
98748: PUSH
98749: LD_INT 15
98751: PUSH
98752: LD_INT 16
98754: PUSH
98755: LD_INT 20
98757: PUSH
98758: LD_INT 21
98760: PUSH
98761: LD_INT 22
98763: PUSH
98764: LD_INT 23
98766: PUSH
98767: LD_INT 25
98769: PUSH
98770: LD_INT 26
98772: PUSH
98773: LD_INT 28
98775: PUSH
98776: LD_INT 30
98778: PUSH
98779: LD_INT 31
98781: PUSH
98782: LD_INT 32
98784: PUSH
98785: LD_INT 36
98787: PUSH
98788: EMPTY
98789: LIST
98790: LIST
98791: LIST
98792: LIST
98793: LIST
98794: LIST
98795: LIST
98796: LIST
98797: LIST
98798: LIST
98799: LIST
98800: LIST
98801: LIST
98802: LIST
98803: LIST
98804: LIST
98805: LIST
98806: LIST
98807: LIST
98808: LIST
98809: LIST
98810: PUSH
98811: LD_INT 101
98813: PUSH
98814: LD_INT 102
98816: PUSH
98817: LD_INT 103
98819: PUSH
98820: LD_INT 105
98822: PUSH
98823: LD_INT 106
98825: PUSH
98826: LD_INT 108
98828: PUSH
98829: LD_INT 109
98831: PUSH
98832: LD_INT 112
98834: PUSH
98835: LD_INT 114
98837: PUSH
98838: LD_INT 116
98840: PUSH
98841: LD_INT 117
98843: PUSH
98844: LD_INT 118
98846: PUSH
98847: EMPTY
98848: LIST
98849: LIST
98850: LIST
98851: LIST
98852: LIST
98853: LIST
98854: LIST
98855: LIST
98856: LIST
98857: LIST
98858: LIST
98859: LIST
98860: PUSH
98861: EMPTY
98862: LIST
98863: LIST
98864: ST_TO_ADDR
98865: GO 100964
98867: LD_INT 10
98869: DOUBLE
98870: EQUAL
98871: IFTRUE 98875
98873: GO 99071
98875: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
98876: LD_ADDR_VAR 0 2
98880: PUSH
98881: LD_INT 2
98883: PUSH
98884: LD_INT 4
98886: PUSH
98887: LD_INT 5
98889: PUSH
98890: LD_INT 6
98892: PUSH
98893: LD_INT 7
98895: PUSH
98896: LD_INT 8
98898: PUSH
98899: LD_INT 9
98901: PUSH
98902: LD_INT 10
98904: PUSH
98905: LD_INT 11
98907: PUSH
98908: LD_INT 12
98910: PUSH
98911: LD_INT 13
98913: PUSH
98914: LD_INT 14
98916: PUSH
98917: LD_INT 15
98919: PUSH
98920: LD_INT 16
98922: PUSH
98923: LD_INT 17
98925: PUSH
98926: LD_INT 18
98928: PUSH
98929: LD_INT 19
98931: PUSH
98932: LD_INT 20
98934: PUSH
98935: LD_INT 21
98937: PUSH
98938: LD_INT 22
98940: PUSH
98941: LD_INT 23
98943: PUSH
98944: LD_INT 24
98946: PUSH
98947: LD_INT 25
98949: PUSH
98950: LD_INT 26
98952: PUSH
98953: LD_INT 28
98955: PUSH
98956: LD_INT 30
98958: PUSH
98959: LD_INT 31
98961: PUSH
98962: LD_INT 32
98964: PUSH
98965: LD_INT 36
98967: PUSH
98968: EMPTY
98969: LIST
98970: LIST
98971: LIST
98972: LIST
98973: LIST
98974: LIST
98975: LIST
98976: LIST
98977: LIST
98978: LIST
98979: LIST
98980: LIST
98981: LIST
98982: LIST
98983: LIST
98984: LIST
98985: LIST
98986: LIST
98987: LIST
98988: LIST
98989: LIST
98990: LIST
98991: LIST
98992: LIST
98993: LIST
98994: LIST
98995: LIST
98996: LIST
98997: LIST
98998: PUSH
98999: LD_INT 101
99001: PUSH
99002: LD_INT 102
99004: PUSH
99005: LD_INT 103
99007: PUSH
99008: LD_INT 104
99010: PUSH
99011: LD_INT 105
99013: PUSH
99014: LD_INT 106
99016: PUSH
99017: LD_INT 107
99019: PUSH
99020: LD_INT 108
99022: PUSH
99023: LD_INT 109
99025: PUSH
99026: LD_INT 110
99028: PUSH
99029: LD_INT 111
99031: PUSH
99032: LD_INT 112
99034: PUSH
99035: LD_INT 114
99037: PUSH
99038: LD_INT 116
99040: PUSH
99041: LD_INT 117
99043: PUSH
99044: LD_INT 118
99046: PUSH
99047: EMPTY
99048: LIST
99049: LIST
99050: LIST
99051: LIST
99052: LIST
99053: LIST
99054: LIST
99055: LIST
99056: LIST
99057: LIST
99058: LIST
99059: LIST
99060: LIST
99061: LIST
99062: LIST
99063: LIST
99064: PUSH
99065: EMPTY
99066: LIST
99067: LIST
99068: ST_TO_ADDR
99069: GO 100964
99071: LD_INT 11
99073: DOUBLE
99074: EQUAL
99075: IFTRUE 99079
99077: GO 99283
99079: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
99080: LD_ADDR_VAR 0 2
99084: PUSH
99085: LD_INT 2
99087: PUSH
99088: LD_INT 3
99090: PUSH
99091: LD_INT 4
99093: PUSH
99094: LD_INT 5
99096: PUSH
99097: LD_INT 6
99099: PUSH
99100: LD_INT 7
99102: PUSH
99103: LD_INT 8
99105: PUSH
99106: LD_INT 9
99108: PUSH
99109: LD_INT 10
99111: PUSH
99112: LD_INT 11
99114: PUSH
99115: LD_INT 12
99117: PUSH
99118: LD_INT 13
99120: PUSH
99121: LD_INT 14
99123: PUSH
99124: LD_INT 15
99126: PUSH
99127: LD_INT 16
99129: PUSH
99130: LD_INT 17
99132: PUSH
99133: LD_INT 18
99135: PUSH
99136: LD_INT 19
99138: PUSH
99139: LD_INT 20
99141: PUSH
99142: LD_INT 21
99144: PUSH
99145: LD_INT 22
99147: PUSH
99148: LD_INT 23
99150: PUSH
99151: LD_INT 24
99153: PUSH
99154: LD_INT 25
99156: PUSH
99157: LD_INT 26
99159: PUSH
99160: LD_INT 28
99162: PUSH
99163: LD_INT 30
99165: PUSH
99166: LD_INT 31
99168: PUSH
99169: LD_INT 32
99171: PUSH
99172: LD_INT 34
99174: PUSH
99175: LD_INT 36
99177: PUSH
99178: EMPTY
99179: LIST
99180: LIST
99181: LIST
99182: LIST
99183: LIST
99184: LIST
99185: LIST
99186: LIST
99187: LIST
99188: LIST
99189: LIST
99190: LIST
99191: LIST
99192: LIST
99193: LIST
99194: LIST
99195: LIST
99196: LIST
99197: LIST
99198: LIST
99199: LIST
99200: LIST
99201: LIST
99202: LIST
99203: LIST
99204: LIST
99205: LIST
99206: LIST
99207: LIST
99208: LIST
99209: LIST
99210: PUSH
99211: LD_INT 101
99213: PUSH
99214: LD_INT 102
99216: PUSH
99217: LD_INT 103
99219: PUSH
99220: LD_INT 104
99222: PUSH
99223: LD_INT 105
99225: PUSH
99226: LD_INT 106
99228: PUSH
99229: LD_INT 107
99231: PUSH
99232: LD_INT 108
99234: PUSH
99235: LD_INT 109
99237: PUSH
99238: LD_INT 110
99240: PUSH
99241: LD_INT 111
99243: PUSH
99244: LD_INT 112
99246: PUSH
99247: LD_INT 114
99249: PUSH
99250: LD_INT 116
99252: PUSH
99253: LD_INT 117
99255: PUSH
99256: LD_INT 118
99258: PUSH
99259: EMPTY
99260: LIST
99261: LIST
99262: LIST
99263: LIST
99264: LIST
99265: LIST
99266: LIST
99267: LIST
99268: LIST
99269: LIST
99270: LIST
99271: LIST
99272: LIST
99273: LIST
99274: LIST
99275: LIST
99276: PUSH
99277: EMPTY
99278: LIST
99279: LIST
99280: ST_TO_ADDR
99281: GO 100964
99283: LD_INT 12
99285: DOUBLE
99286: EQUAL
99287: IFTRUE 99291
99289: GO 99511
99291: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
99292: LD_ADDR_VAR 0 2
99296: PUSH
99297: LD_INT 1
99299: PUSH
99300: LD_INT 2
99302: PUSH
99303: LD_INT 3
99305: PUSH
99306: LD_INT 4
99308: PUSH
99309: LD_INT 5
99311: PUSH
99312: LD_INT 6
99314: PUSH
99315: LD_INT 7
99317: PUSH
99318: LD_INT 8
99320: PUSH
99321: LD_INT 9
99323: PUSH
99324: LD_INT 10
99326: PUSH
99327: LD_INT 11
99329: PUSH
99330: LD_INT 12
99332: PUSH
99333: LD_INT 13
99335: PUSH
99336: LD_INT 14
99338: PUSH
99339: LD_INT 15
99341: PUSH
99342: LD_INT 16
99344: PUSH
99345: LD_INT 17
99347: PUSH
99348: LD_INT 18
99350: PUSH
99351: LD_INT 19
99353: PUSH
99354: LD_INT 20
99356: PUSH
99357: LD_INT 21
99359: PUSH
99360: LD_INT 22
99362: PUSH
99363: LD_INT 23
99365: PUSH
99366: LD_INT 24
99368: PUSH
99369: LD_INT 25
99371: PUSH
99372: LD_INT 26
99374: PUSH
99375: LD_INT 27
99377: PUSH
99378: LD_INT 28
99380: PUSH
99381: LD_INT 30
99383: PUSH
99384: LD_INT 31
99386: PUSH
99387: LD_INT 32
99389: PUSH
99390: LD_INT 33
99392: PUSH
99393: LD_INT 34
99395: PUSH
99396: LD_INT 36
99398: PUSH
99399: EMPTY
99400: LIST
99401: LIST
99402: LIST
99403: LIST
99404: LIST
99405: LIST
99406: LIST
99407: LIST
99408: LIST
99409: LIST
99410: LIST
99411: LIST
99412: LIST
99413: LIST
99414: LIST
99415: LIST
99416: LIST
99417: LIST
99418: LIST
99419: LIST
99420: LIST
99421: LIST
99422: LIST
99423: LIST
99424: LIST
99425: LIST
99426: LIST
99427: LIST
99428: LIST
99429: LIST
99430: LIST
99431: LIST
99432: LIST
99433: LIST
99434: PUSH
99435: LD_INT 101
99437: PUSH
99438: LD_INT 102
99440: PUSH
99441: LD_INT 103
99443: PUSH
99444: LD_INT 104
99446: PUSH
99447: LD_INT 105
99449: PUSH
99450: LD_INT 106
99452: PUSH
99453: LD_INT 107
99455: PUSH
99456: LD_INT 108
99458: PUSH
99459: LD_INT 109
99461: PUSH
99462: LD_INT 110
99464: PUSH
99465: LD_INT 111
99467: PUSH
99468: LD_INT 112
99470: PUSH
99471: LD_INT 113
99473: PUSH
99474: LD_INT 114
99476: PUSH
99477: LD_INT 116
99479: PUSH
99480: LD_INT 117
99482: PUSH
99483: LD_INT 118
99485: PUSH
99486: EMPTY
99487: LIST
99488: LIST
99489: LIST
99490: LIST
99491: LIST
99492: LIST
99493: LIST
99494: LIST
99495: LIST
99496: LIST
99497: LIST
99498: LIST
99499: LIST
99500: LIST
99501: LIST
99502: LIST
99503: LIST
99504: PUSH
99505: EMPTY
99506: LIST
99507: LIST
99508: ST_TO_ADDR
99509: GO 100964
99511: LD_INT 13
99513: DOUBLE
99514: EQUAL
99515: IFTRUE 99519
99517: GO 99727
99519: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
99520: LD_ADDR_VAR 0 2
99524: PUSH
99525: LD_INT 1
99527: PUSH
99528: LD_INT 2
99530: PUSH
99531: LD_INT 3
99533: PUSH
99534: LD_INT 4
99536: PUSH
99537: LD_INT 5
99539: PUSH
99540: LD_INT 8
99542: PUSH
99543: LD_INT 9
99545: PUSH
99546: LD_INT 10
99548: PUSH
99549: LD_INT 11
99551: PUSH
99552: LD_INT 12
99554: PUSH
99555: LD_INT 14
99557: PUSH
99558: LD_INT 15
99560: PUSH
99561: LD_INT 16
99563: PUSH
99564: LD_INT 17
99566: PUSH
99567: LD_INT 18
99569: PUSH
99570: LD_INT 19
99572: PUSH
99573: LD_INT 20
99575: PUSH
99576: LD_INT 21
99578: PUSH
99579: LD_INT 22
99581: PUSH
99582: LD_INT 23
99584: PUSH
99585: LD_INT 24
99587: PUSH
99588: LD_INT 25
99590: PUSH
99591: LD_INT 26
99593: PUSH
99594: LD_INT 27
99596: PUSH
99597: LD_INT 28
99599: PUSH
99600: LD_INT 30
99602: PUSH
99603: LD_INT 31
99605: PUSH
99606: LD_INT 32
99608: PUSH
99609: LD_INT 33
99611: PUSH
99612: LD_INT 34
99614: PUSH
99615: LD_INT 36
99617: PUSH
99618: EMPTY
99619: LIST
99620: LIST
99621: LIST
99622: LIST
99623: LIST
99624: LIST
99625: LIST
99626: LIST
99627: LIST
99628: LIST
99629: LIST
99630: LIST
99631: LIST
99632: LIST
99633: LIST
99634: LIST
99635: LIST
99636: LIST
99637: LIST
99638: LIST
99639: LIST
99640: LIST
99641: LIST
99642: LIST
99643: LIST
99644: LIST
99645: LIST
99646: LIST
99647: LIST
99648: LIST
99649: LIST
99650: PUSH
99651: LD_INT 101
99653: PUSH
99654: LD_INT 102
99656: PUSH
99657: LD_INT 103
99659: PUSH
99660: LD_INT 104
99662: PUSH
99663: LD_INT 105
99665: PUSH
99666: LD_INT 106
99668: PUSH
99669: LD_INT 107
99671: PUSH
99672: LD_INT 108
99674: PUSH
99675: LD_INT 109
99677: PUSH
99678: LD_INT 110
99680: PUSH
99681: LD_INT 111
99683: PUSH
99684: LD_INT 112
99686: PUSH
99687: LD_INT 113
99689: PUSH
99690: LD_INT 114
99692: PUSH
99693: LD_INT 116
99695: PUSH
99696: LD_INT 117
99698: PUSH
99699: LD_INT 118
99701: PUSH
99702: EMPTY
99703: LIST
99704: LIST
99705: LIST
99706: LIST
99707: LIST
99708: LIST
99709: LIST
99710: LIST
99711: LIST
99712: LIST
99713: LIST
99714: LIST
99715: LIST
99716: LIST
99717: LIST
99718: LIST
99719: LIST
99720: PUSH
99721: EMPTY
99722: LIST
99723: LIST
99724: ST_TO_ADDR
99725: GO 100964
99727: LD_INT 14
99729: DOUBLE
99730: EQUAL
99731: IFTRUE 99735
99733: GO 99959
99735: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
99736: LD_ADDR_VAR 0 2
99740: PUSH
99741: LD_INT 1
99743: PUSH
99744: LD_INT 2
99746: PUSH
99747: LD_INT 3
99749: PUSH
99750: LD_INT 4
99752: PUSH
99753: LD_INT 5
99755: PUSH
99756: LD_INT 6
99758: PUSH
99759: LD_INT 7
99761: PUSH
99762: LD_INT 8
99764: PUSH
99765: LD_INT 9
99767: PUSH
99768: LD_INT 10
99770: PUSH
99771: LD_INT 11
99773: PUSH
99774: LD_INT 12
99776: PUSH
99777: LD_INT 13
99779: PUSH
99780: LD_INT 14
99782: PUSH
99783: LD_INT 15
99785: PUSH
99786: LD_INT 16
99788: PUSH
99789: LD_INT 17
99791: PUSH
99792: LD_INT 18
99794: PUSH
99795: LD_INT 19
99797: PUSH
99798: LD_INT 20
99800: PUSH
99801: LD_INT 21
99803: PUSH
99804: LD_INT 22
99806: PUSH
99807: LD_INT 23
99809: PUSH
99810: LD_INT 24
99812: PUSH
99813: LD_INT 25
99815: PUSH
99816: LD_INT 26
99818: PUSH
99819: LD_INT 27
99821: PUSH
99822: LD_INT 28
99824: PUSH
99825: LD_INT 29
99827: PUSH
99828: LD_INT 30
99830: PUSH
99831: LD_INT 31
99833: PUSH
99834: LD_INT 32
99836: PUSH
99837: LD_INT 33
99839: PUSH
99840: LD_INT 34
99842: PUSH
99843: LD_INT 36
99845: PUSH
99846: EMPTY
99847: LIST
99848: LIST
99849: LIST
99850: LIST
99851: LIST
99852: LIST
99853: LIST
99854: LIST
99855: LIST
99856: LIST
99857: LIST
99858: LIST
99859: LIST
99860: LIST
99861: LIST
99862: LIST
99863: LIST
99864: LIST
99865: LIST
99866: LIST
99867: LIST
99868: LIST
99869: LIST
99870: LIST
99871: LIST
99872: LIST
99873: LIST
99874: LIST
99875: LIST
99876: LIST
99877: LIST
99878: LIST
99879: LIST
99880: LIST
99881: LIST
99882: PUSH
99883: LD_INT 101
99885: PUSH
99886: LD_INT 102
99888: PUSH
99889: LD_INT 103
99891: PUSH
99892: LD_INT 104
99894: PUSH
99895: LD_INT 105
99897: PUSH
99898: LD_INT 106
99900: PUSH
99901: LD_INT 107
99903: PUSH
99904: LD_INT 108
99906: PUSH
99907: LD_INT 109
99909: PUSH
99910: LD_INT 110
99912: PUSH
99913: LD_INT 111
99915: PUSH
99916: LD_INT 112
99918: PUSH
99919: LD_INT 113
99921: PUSH
99922: LD_INT 114
99924: PUSH
99925: LD_INT 116
99927: PUSH
99928: LD_INT 117
99930: PUSH
99931: LD_INT 118
99933: PUSH
99934: EMPTY
99935: LIST
99936: LIST
99937: LIST
99938: LIST
99939: LIST
99940: LIST
99941: LIST
99942: LIST
99943: LIST
99944: LIST
99945: LIST
99946: LIST
99947: LIST
99948: LIST
99949: LIST
99950: LIST
99951: LIST
99952: PUSH
99953: EMPTY
99954: LIST
99955: LIST
99956: ST_TO_ADDR
99957: GO 100964
99959: LD_INT 15
99961: DOUBLE
99962: EQUAL
99963: IFTRUE 99967
99965: GO 100191
99967: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
99968: LD_ADDR_VAR 0 2
99972: PUSH
99973: LD_INT 1
99975: PUSH
99976: LD_INT 2
99978: PUSH
99979: LD_INT 3
99981: PUSH
99982: LD_INT 4
99984: PUSH
99985: LD_INT 5
99987: PUSH
99988: LD_INT 6
99990: PUSH
99991: LD_INT 7
99993: PUSH
99994: LD_INT 8
99996: PUSH
99997: LD_INT 9
99999: PUSH
100000: LD_INT 10
100002: PUSH
100003: LD_INT 11
100005: PUSH
100006: LD_INT 12
100008: PUSH
100009: LD_INT 13
100011: PUSH
100012: LD_INT 14
100014: PUSH
100015: LD_INT 15
100017: PUSH
100018: LD_INT 16
100020: PUSH
100021: LD_INT 17
100023: PUSH
100024: LD_INT 18
100026: PUSH
100027: LD_INT 19
100029: PUSH
100030: LD_INT 20
100032: PUSH
100033: LD_INT 21
100035: PUSH
100036: LD_INT 22
100038: PUSH
100039: LD_INT 23
100041: PUSH
100042: LD_INT 24
100044: PUSH
100045: LD_INT 25
100047: PUSH
100048: LD_INT 26
100050: PUSH
100051: LD_INT 27
100053: PUSH
100054: LD_INT 28
100056: PUSH
100057: LD_INT 29
100059: PUSH
100060: LD_INT 30
100062: PUSH
100063: LD_INT 31
100065: PUSH
100066: LD_INT 32
100068: PUSH
100069: LD_INT 33
100071: PUSH
100072: LD_INT 34
100074: PUSH
100075: LD_INT 36
100077: PUSH
100078: EMPTY
100079: LIST
100080: LIST
100081: LIST
100082: LIST
100083: LIST
100084: LIST
100085: LIST
100086: LIST
100087: LIST
100088: LIST
100089: LIST
100090: LIST
100091: LIST
100092: LIST
100093: LIST
100094: LIST
100095: LIST
100096: LIST
100097: LIST
100098: LIST
100099: LIST
100100: LIST
100101: LIST
100102: LIST
100103: LIST
100104: LIST
100105: LIST
100106: LIST
100107: LIST
100108: LIST
100109: LIST
100110: LIST
100111: LIST
100112: LIST
100113: LIST
100114: PUSH
100115: LD_INT 101
100117: PUSH
100118: LD_INT 102
100120: PUSH
100121: LD_INT 103
100123: PUSH
100124: LD_INT 104
100126: PUSH
100127: LD_INT 105
100129: PUSH
100130: LD_INT 106
100132: PUSH
100133: LD_INT 107
100135: PUSH
100136: LD_INT 108
100138: PUSH
100139: LD_INT 109
100141: PUSH
100142: LD_INT 110
100144: PUSH
100145: LD_INT 111
100147: PUSH
100148: LD_INT 112
100150: PUSH
100151: LD_INT 113
100153: PUSH
100154: LD_INT 114
100156: PUSH
100157: LD_INT 116
100159: PUSH
100160: LD_INT 117
100162: PUSH
100163: LD_INT 118
100165: PUSH
100166: EMPTY
100167: LIST
100168: LIST
100169: LIST
100170: LIST
100171: LIST
100172: LIST
100173: LIST
100174: LIST
100175: LIST
100176: LIST
100177: LIST
100178: LIST
100179: LIST
100180: LIST
100181: LIST
100182: LIST
100183: LIST
100184: PUSH
100185: EMPTY
100186: LIST
100187: LIST
100188: ST_TO_ADDR
100189: GO 100964
100191: LD_INT 16
100193: DOUBLE
100194: EQUAL
100195: IFTRUE 100199
100197: GO 100335
100199: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
100200: LD_ADDR_VAR 0 2
100204: PUSH
100205: LD_INT 2
100207: PUSH
100208: LD_INT 4
100210: PUSH
100211: LD_INT 5
100213: PUSH
100214: LD_INT 7
100216: PUSH
100217: LD_INT 11
100219: PUSH
100220: LD_INT 12
100222: PUSH
100223: LD_INT 15
100225: PUSH
100226: LD_INT 16
100228: PUSH
100229: LD_INT 20
100231: PUSH
100232: LD_INT 21
100234: PUSH
100235: LD_INT 22
100237: PUSH
100238: LD_INT 23
100240: PUSH
100241: LD_INT 25
100243: PUSH
100244: LD_INT 26
100246: PUSH
100247: LD_INT 30
100249: PUSH
100250: LD_INT 31
100252: PUSH
100253: LD_INT 32
100255: PUSH
100256: LD_INT 33
100258: PUSH
100259: LD_INT 34
100261: PUSH
100262: EMPTY
100263: LIST
100264: LIST
100265: LIST
100266: LIST
100267: LIST
100268: LIST
100269: LIST
100270: LIST
100271: LIST
100272: LIST
100273: LIST
100274: LIST
100275: LIST
100276: LIST
100277: LIST
100278: LIST
100279: LIST
100280: LIST
100281: LIST
100282: PUSH
100283: LD_INT 101
100285: PUSH
100286: LD_INT 102
100288: PUSH
100289: LD_INT 103
100291: PUSH
100292: LD_INT 106
100294: PUSH
100295: LD_INT 108
100297: PUSH
100298: LD_INT 112
100300: PUSH
100301: LD_INT 113
100303: PUSH
100304: LD_INT 114
100306: PUSH
100307: LD_INT 116
100309: PUSH
100310: LD_INT 117
100312: PUSH
100313: LD_INT 118
100315: PUSH
100316: EMPTY
100317: LIST
100318: LIST
100319: LIST
100320: LIST
100321: LIST
100322: LIST
100323: LIST
100324: LIST
100325: LIST
100326: LIST
100327: LIST
100328: PUSH
100329: EMPTY
100330: LIST
100331: LIST
100332: ST_TO_ADDR
100333: GO 100964
100335: LD_INT 17
100337: DOUBLE
100338: EQUAL
100339: IFTRUE 100343
100341: GO 100567
100343: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
100344: LD_ADDR_VAR 0 2
100348: PUSH
100349: LD_INT 1
100351: PUSH
100352: LD_INT 2
100354: PUSH
100355: LD_INT 3
100357: PUSH
100358: LD_INT 4
100360: PUSH
100361: LD_INT 5
100363: PUSH
100364: LD_INT 6
100366: PUSH
100367: LD_INT 7
100369: PUSH
100370: LD_INT 8
100372: PUSH
100373: LD_INT 9
100375: PUSH
100376: LD_INT 10
100378: PUSH
100379: LD_INT 11
100381: PUSH
100382: LD_INT 12
100384: PUSH
100385: LD_INT 13
100387: PUSH
100388: LD_INT 14
100390: PUSH
100391: LD_INT 15
100393: PUSH
100394: LD_INT 16
100396: PUSH
100397: LD_INT 17
100399: PUSH
100400: LD_INT 18
100402: PUSH
100403: LD_INT 19
100405: PUSH
100406: LD_INT 20
100408: PUSH
100409: LD_INT 21
100411: PUSH
100412: LD_INT 22
100414: PUSH
100415: LD_INT 23
100417: PUSH
100418: LD_INT 24
100420: PUSH
100421: LD_INT 25
100423: PUSH
100424: LD_INT 26
100426: PUSH
100427: LD_INT 27
100429: PUSH
100430: LD_INT 28
100432: PUSH
100433: LD_INT 29
100435: PUSH
100436: LD_INT 30
100438: PUSH
100439: LD_INT 31
100441: PUSH
100442: LD_INT 32
100444: PUSH
100445: LD_INT 33
100447: PUSH
100448: LD_INT 34
100450: PUSH
100451: LD_INT 36
100453: PUSH
100454: EMPTY
100455: LIST
100456: LIST
100457: LIST
100458: LIST
100459: LIST
100460: LIST
100461: LIST
100462: LIST
100463: LIST
100464: LIST
100465: LIST
100466: LIST
100467: LIST
100468: LIST
100469: LIST
100470: LIST
100471: LIST
100472: LIST
100473: LIST
100474: LIST
100475: LIST
100476: LIST
100477: LIST
100478: LIST
100479: LIST
100480: LIST
100481: LIST
100482: LIST
100483: LIST
100484: LIST
100485: LIST
100486: LIST
100487: LIST
100488: LIST
100489: LIST
100490: PUSH
100491: LD_INT 101
100493: PUSH
100494: LD_INT 102
100496: PUSH
100497: LD_INT 103
100499: PUSH
100500: LD_INT 104
100502: PUSH
100503: LD_INT 105
100505: PUSH
100506: LD_INT 106
100508: PUSH
100509: LD_INT 107
100511: PUSH
100512: LD_INT 108
100514: PUSH
100515: LD_INT 109
100517: PUSH
100518: LD_INT 110
100520: PUSH
100521: LD_INT 111
100523: PUSH
100524: LD_INT 112
100526: PUSH
100527: LD_INT 113
100529: PUSH
100530: LD_INT 114
100532: PUSH
100533: LD_INT 116
100535: PUSH
100536: LD_INT 117
100538: PUSH
100539: LD_INT 118
100541: PUSH
100542: EMPTY
100543: LIST
100544: LIST
100545: LIST
100546: LIST
100547: LIST
100548: LIST
100549: LIST
100550: LIST
100551: LIST
100552: LIST
100553: LIST
100554: LIST
100555: LIST
100556: LIST
100557: LIST
100558: LIST
100559: LIST
100560: PUSH
100561: EMPTY
100562: LIST
100563: LIST
100564: ST_TO_ADDR
100565: GO 100964
100567: LD_INT 18
100569: DOUBLE
100570: EQUAL
100571: IFTRUE 100575
100573: GO 100723
100575: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
100576: LD_ADDR_VAR 0 2
100580: PUSH
100581: LD_INT 2
100583: PUSH
100584: LD_INT 4
100586: PUSH
100587: LD_INT 5
100589: PUSH
100590: LD_INT 7
100592: PUSH
100593: LD_INT 11
100595: PUSH
100596: LD_INT 12
100598: PUSH
100599: LD_INT 15
100601: PUSH
100602: LD_INT 16
100604: PUSH
100605: LD_INT 20
100607: PUSH
100608: LD_INT 21
100610: PUSH
100611: LD_INT 22
100613: PUSH
100614: LD_INT 23
100616: PUSH
100617: LD_INT 25
100619: PUSH
100620: LD_INT 26
100622: PUSH
100623: LD_INT 30
100625: PUSH
100626: LD_INT 31
100628: PUSH
100629: LD_INT 32
100631: PUSH
100632: LD_INT 33
100634: PUSH
100635: LD_INT 34
100637: PUSH
100638: LD_INT 35
100640: PUSH
100641: LD_INT 36
100643: PUSH
100644: EMPTY
100645: LIST
100646: LIST
100647: LIST
100648: LIST
100649: LIST
100650: LIST
100651: LIST
100652: LIST
100653: LIST
100654: LIST
100655: LIST
100656: LIST
100657: LIST
100658: LIST
100659: LIST
100660: LIST
100661: LIST
100662: LIST
100663: LIST
100664: LIST
100665: LIST
100666: PUSH
100667: LD_INT 101
100669: PUSH
100670: LD_INT 102
100672: PUSH
100673: LD_INT 103
100675: PUSH
100676: LD_INT 106
100678: PUSH
100679: LD_INT 108
100681: PUSH
100682: LD_INT 112
100684: PUSH
100685: LD_INT 113
100687: PUSH
100688: LD_INT 114
100690: PUSH
100691: LD_INT 115
100693: PUSH
100694: LD_INT 116
100696: PUSH
100697: LD_INT 117
100699: PUSH
100700: LD_INT 118
100702: PUSH
100703: EMPTY
100704: LIST
100705: LIST
100706: LIST
100707: LIST
100708: LIST
100709: LIST
100710: LIST
100711: LIST
100712: LIST
100713: LIST
100714: LIST
100715: LIST
100716: PUSH
100717: EMPTY
100718: LIST
100719: LIST
100720: ST_TO_ADDR
100721: GO 100964
100723: LD_INT 19
100725: DOUBLE
100726: EQUAL
100727: IFTRUE 100731
100729: GO 100963
100731: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
100732: LD_ADDR_VAR 0 2
100736: PUSH
100737: LD_INT 1
100739: PUSH
100740: LD_INT 2
100742: PUSH
100743: LD_INT 3
100745: PUSH
100746: LD_INT 4
100748: PUSH
100749: LD_INT 5
100751: PUSH
100752: LD_INT 6
100754: PUSH
100755: LD_INT 7
100757: PUSH
100758: LD_INT 8
100760: PUSH
100761: LD_INT 9
100763: PUSH
100764: LD_INT 10
100766: PUSH
100767: LD_INT 11
100769: PUSH
100770: LD_INT 12
100772: PUSH
100773: LD_INT 13
100775: PUSH
100776: LD_INT 14
100778: PUSH
100779: LD_INT 15
100781: PUSH
100782: LD_INT 16
100784: PUSH
100785: LD_INT 17
100787: PUSH
100788: LD_INT 18
100790: PUSH
100791: LD_INT 19
100793: PUSH
100794: LD_INT 20
100796: PUSH
100797: LD_INT 21
100799: PUSH
100800: LD_INT 22
100802: PUSH
100803: LD_INT 23
100805: PUSH
100806: LD_INT 24
100808: PUSH
100809: LD_INT 25
100811: PUSH
100812: LD_INT 26
100814: PUSH
100815: LD_INT 27
100817: PUSH
100818: LD_INT 28
100820: PUSH
100821: LD_INT 29
100823: PUSH
100824: LD_INT 30
100826: PUSH
100827: LD_INT 31
100829: PUSH
100830: LD_INT 32
100832: PUSH
100833: LD_INT 33
100835: PUSH
100836: LD_INT 34
100838: PUSH
100839: LD_INT 35
100841: PUSH
100842: LD_INT 36
100844: PUSH
100845: EMPTY
100846: LIST
100847: LIST
100848: LIST
100849: LIST
100850: LIST
100851: LIST
100852: LIST
100853: LIST
100854: LIST
100855: LIST
100856: LIST
100857: LIST
100858: LIST
100859: LIST
100860: LIST
100861: LIST
100862: LIST
100863: LIST
100864: LIST
100865: LIST
100866: LIST
100867: LIST
100868: LIST
100869: LIST
100870: LIST
100871: LIST
100872: LIST
100873: LIST
100874: LIST
100875: LIST
100876: LIST
100877: LIST
100878: LIST
100879: LIST
100880: LIST
100881: LIST
100882: PUSH
100883: LD_INT 101
100885: PUSH
100886: LD_INT 102
100888: PUSH
100889: LD_INT 103
100891: PUSH
100892: LD_INT 104
100894: PUSH
100895: LD_INT 105
100897: PUSH
100898: LD_INT 106
100900: PUSH
100901: LD_INT 107
100903: PUSH
100904: LD_INT 108
100906: PUSH
100907: LD_INT 109
100909: PUSH
100910: LD_INT 110
100912: PUSH
100913: LD_INT 111
100915: PUSH
100916: LD_INT 112
100918: PUSH
100919: LD_INT 113
100921: PUSH
100922: LD_INT 114
100924: PUSH
100925: LD_INT 115
100927: PUSH
100928: LD_INT 116
100930: PUSH
100931: LD_INT 117
100933: PUSH
100934: LD_INT 118
100936: PUSH
100937: EMPTY
100938: LIST
100939: LIST
100940: LIST
100941: LIST
100942: LIST
100943: LIST
100944: LIST
100945: LIST
100946: LIST
100947: LIST
100948: LIST
100949: LIST
100950: LIST
100951: LIST
100952: LIST
100953: LIST
100954: LIST
100955: LIST
100956: PUSH
100957: EMPTY
100958: LIST
100959: LIST
100960: ST_TO_ADDR
100961: GO 100964
100963: POP
// end else
100964: GO 101195
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
100966: LD_ADDR_VAR 0 2
100970: PUSH
100971: LD_INT 1
100973: PUSH
100974: LD_INT 2
100976: PUSH
100977: LD_INT 3
100979: PUSH
100980: LD_INT 4
100982: PUSH
100983: LD_INT 5
100985: PUSH
100986: LD_INT 6
100988: PUSH
100989: LD_INT 7
100991: PUSH
100992: LD_INT 8
100994: PUSH
100995: LD_INT 9
100997: PUSH
100998: LD_INT 10
101000: PUSH
101001: LD_INT 11
101003: PUSH
101004: LD_INT 12
101006: PUSH
101007: LD_INT 13
101009: PUSH
101010: LD_INT 14
101012: PUSH
101013: LD_INT 15
101015: PUSH
101016: LD_INT 16
101018: PUSH
101019: LD_INT 17
101021: PUSH
101022: LD_INT 18
101024: PUSH
101025: LD_INT 19
101027: PUSH
101028: LD_INT 20
101030: PUSH
101031: LD_INT 21
101033: PUSH
101034: LD_INT 22
101036: PUSH
101037: LD_INT 23
101039: PUSH
101040: LD_INT 24
101042: PUSH
101043: LD_INT 25
101045: PUSH
101046: LD_INT 26
101048: PUSH
101049: LD_INT 27
101051: PUSH
101052: LD_INT 28
101054: PUSH
101055: LD_INT 29
101057: PUSH
101058: LD_INT 30
101060: PUSH
101061: LD_INT 31
101063: PUSH
101064: LD_INT 32
101066: PUSH
101067: LD_INT 33
101069: PUSH
101070: LD_INT 34
101072: PUSH
101073: LD_INT 35
101075: PUSH
101076: LD_INT 36
101078: PUSH
101079: EMPTY
101080: LIST
101081: LIST
101082: LIST
101083: LIST
101084: LIST
101085: LIST
101086: LIST
101087: LIST
101088: LIST
101089: LIST
101090: LIST
101091: LIST
101092: LIST
101093: LIST
101094: LIST
101095: LIST
101096: LIST
101097: LIST
101098: LIST
101099: LIST
101100: LIST
101101: LIST
101102: LIST
101103: LIST
101104: LIST
101105: LIST
101106: LIST
101107: LIST
101108: LIST
101109: LIST
101110: LIST
101111: LIST
101112: LIST
101113: LIST
101114: LIST
101115: LIST
101116: PUSH
101117: LD_INT 101
101119: PUSH
101120: LD_INT 102
101122: PUSH
101123: LD_INT 103
101125: PUSH
101126: LD_INT 104
101128: PUSH
101129: LD_INT 105
101131: PUSH
101132: LD_INT 106
101134: PUSH
101135: LD_INT 107
101137: PUSH
101138: LD_INT 108
101140: PUSH
101141: LD_INT 109
101143: PUSH
101144: LD_INT 110
101146: PUSH
101147: LD_INT 111
101149: PUSH
101150: LD_INT 112
101152: PUSH
101153: LD_INT 113
101155: PUSH
101156: LD_INT 114
101158: PUSH
101159: LD_INT 115
101161: PUSH
101162: LD_INT 116
101164: PUSH
101165: LD_INT 117
101167: PUSH
101168: LD_INT 118
101170: PUSH
101171: EMPTY
101172: LIST
101173: LIST
101174: LIST
101175: LIST
101176: LIST
101177: LIST
101178: LIST
101179: LIST
101180: LIST
101181: LIST
101182: LIST
101183: LIST
101184: LIST
101185: LIST
101186: LIST
101187: LIST
101188: LIST
101189: LIST
101190: PUSH
101191: EMPTY
101192: LIST
101193: LIST
101194: ST_TO_ADDR
// if result then
101195: LD_VAR 0 2
101199: IFFALSE 101985
// begin normal :=  ;
101201: LD_ADDR_VAR 0 5
101205: PUSH
101206: LD_STRING 
101208: ST_TO_ADDR
// hardcore :=  ;
101209: LD_ADDR_VAR 0 6
101213: PUSH
101214: LD_STRING 
101216: ST_TO_ADDR
// active :=  ;
101217: LD_ADDR_VAR 0 7
101221: PUSH
101222: LD_STRING 
101224: ST_TO_ADDR
// for i = 1 to normalCounter do
101225: LD_ADDR_VAR 0 8
101229: PUSH
101230: DOUBLE
101231: LD_INT 1
101233: DEC
101234: ST_TO_ADDR
101235: LD_EXP 80
101239: PUSH
101240: FOR_TO
101241: IFFALSE 101342
// begin tmp := 0 ;
101243: LD_ADDR_VAR 0 3
101247: PUSH
101248: LD_STRING 0
101250: ST_TO_ADDR
// if result [ 1 ] then
101251: LD_VAR 0 2
101255: PUSH
101256: LD_INT 1
101258: ARRAY
101259: IFFALSE 101324
// if result [ 1 ] [ 1 ] = i then
101261: LD_VAR 0 2
101265: PUSH
101266: LD_INT 1
101268: ARRAY
101269: PUSH
101270: LD_INT 1
101272: ARRAY
101273: PUSH
101274: LD_VAR 0 8
101278: EQUAL
101279: IFFALSE 101324
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
101281: LD_ADDR_VAR 0 2
101285: PUSH
101286: LD_VAR 0 2
101290: PPUSH
101291: LD_INT 1
101293: PPUSH
101294: LD_VAR 0 2
101298: PUSH
101299: LD_INT 1
101301: ARRAY
101302: PPUSH
101303: LD_INT 1
101305: PPUSH
101306: CALL_OW 3
101310: PPUSH
101311: CALL_OW 1
101315: ST_TO_ADDR
// tmp := 1 ;
101316: LD_ADDR_VAR 0 3
101320: PUSH
101321: LD_STRING 1
101323: ST_TO_ADDR
// end ; normal := normal & tmp ;
101324: LD_ADDR_VAR 0 5
101328: PUSH
101329: LD_VAR 0 5
101333: PUSH
101334: LD_VAR 0 3
101338: STR
101339: ST_TO_ADDR
// end ;
101340: GO 101240
101342: POP
101343: POP
// for i = 1 to hardcoreCounter do
101344: LD_ADDR_VAR 0 8
101348: PUSH
101349: DOUBLE
101350: LD_INT 1
101352: DEC
101353: ST_TO_ADDR
101354: LD_EXP 81
101358: PUSH
101359: FOR_TO
101360: IFFALSE 101465
// begin tmp := 0 ;
101362: LD_ADDR_VAR 0 3
101366: PUSH
101367: LD_STRING 0
101369: ST_TO_ADDR
// if result [ 2 ] then
101370: LD_VAR 0 2
101374: PUSH
101375: LD_INT 2
101377: ARRAY
101378: IFFALSE 101447
// if result [ 2 ] [ 1 ] = 100 + i then
101380: LD_VAR 0 2
101384: PUSH
101385: LD_INT 2
101387: ARRAY
101388: PUSH
101389: LD_INT 1
101391: ARRAY
101392: PUSH
101393: LD_INT 100
101395: PUSH
101396: LD_VAR 0 8
101400: PLUS
101401: EQUAL
101402: IFFALSE 101447
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
101404: LD_ADDR_VAR 0 2
101408: PUSH
101409: LD_VAR 0 2
101413: PPUSH
101414: LD_INT 2
101416: PPUSH
101417: LD_VAR 0 2
101421: PUSH
101422: LD_INT 2
101424: ARRAY
101425: PPUSH
101426: LD_INT 1
101428: PPUSH
101429: CALL_OW 3
101433: PPUSH
101434: CALL_OW 1
101438: ST_TO_ADDR
// tmp := 1 ;
101439: LD_ADDR_VAR 0 3
101443: PUSH
101444: LD_STRING 1
101446: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
101447: LD_ADDR_VAR 0 6
101451: PUSH
101452: LD_VAR 0 6
101456: PUSH
101457: LD_VAR 0 3
101461: STR
101462: ST_TO_ADDR
// end ;
101463: GO 101359
101465: POP
101466: POP
// if isGameLoad then
101467: LD_VAR 0 1
101471: IFFALSE 101946
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
101473: LD_ADDR_VAR 0 4
101477: PUSH
101478: LD_EXP 84
101482: PUSH
101483: LD_EXP 83
101487: PUSH
101488: LD_EXP 85
101492: PUSH
101493: LD_EXP 82
101497: PUSH
101498: LD_EXP 86
101502: PUSH
101503: LD_EXP 87
101507: PUSH
101508: LD_EXP 88
101512: PUSH
101513: LD_EXP 89
101517: PUSH
101518: LD_EXP 90
101522: PUSH
101523: LD_EXP 91
101527: PUSH
101528: LD_EXP 92
101532: PUSH
101533: LD_EXP 93
101537: PUSH
101538: LD_EXP 94
101542: PUSH
101543: LD_EXP 95
101547: PUSH
101548: LD_EXP 103
101552: PUSH
101553: LD_EXP 104
101557: PUSH
101558: LD_EXP 105
101562: PUSH
101563: LD_EXP 106
101567: PUSH
101568: LD_EXP 108
101572: PUSH
101573: LD_EXP 109
101577: PUSH
101578: LD_EXP 110
101582: PUSH
101583: LD_EXP 113
101587: PUSH
101588: LD_EXP 115
101592: PUSH
101593: LD_EXP 116
101597: PUSH
101598: LD_EXP 117
101602: PUSH
101603: LD_EXP 119
101607: PUSH
101608: LD_EXP 120
101612: PUSH
101613: LD_EXP 123
101617: PUSH
101618: LD_EXP 124
101622: PUSH
101623: LD_EXP 125
101627: PUSH
101628: LD_EXP 126
101632: PUSH
101633: LD_EXP 127
101637: PUSH
101638: LD_EXP 128
101642: PUSH
101643: LD_EXP 129
101647: PUSH
101648: LD_EXP 130
101652: PUSH
101653: LD_EXP 131
101657: PUSH
101658: LD_EXP 96
101662: PUSH
101663: LD_EXP 97
101667: PUSH
101668: LD_EXP 100
101672: PUSH
101673: LD_EXP 101
101677: PUSH
101678: LD_EXP 102
101682: PUSH
101683: LD_EXP 98
101687: PUSH
101688: LD_EXP 99
101692: PUSH
101693: LD_EXP 107
101697: PUSH
101698: LD_EXP 111
101702: PUSH
101703: LD_EXP 112
101707: PUSH
101708: LD_EXP 114
101712: PUSH
101713: LD_EXP 118
101717: PUSH
101718: LD_EXP 121
101722: PUSH
101723: LD_EXP 122
101727: PUSH
101728: LD_EXP 132
101732: PUSH
101733: LD_EXP 133
101737: PUSH
101738: LD_EXP 134
101742: PUSH
101743: LD_EXP 135
101747: PUSH
101748: EMPTY
101749: LIST
101750: LIST
101751: LIST
101752: LIST
101753: LIST
101754: LIST
101755: LIST
101756: LIST
101757: LIST
101758: LIST
101759: LIST
101760: LIST
101761: LIST
101762: LIST
101763: LIST
101764: LIST
101765: LIST
101766: LIST
101767: LIST
101768: LIST
101769: LIST
101770: LIST
101771: LIST
101772: LIST
101773: LIST
101774: LIST
101775: LIST
101776: LIST
101777: LIST
101778: LIST
101779: LIST
101780: LIST
101781: LIST
101782: LIST
101783: LIST
101784: LIST
101785: LIST
101786: LIST
101787: LIST
101788: LIST
101789: LIST
101790: LIST
101791: LIST
101792: LIST
101793: LIST
101794: LIST
101795: LIST
101796: LIST
101797: LIST
101798: LIST
101799: LIST
101800: LIST
101801: LIST
101802: LIST
101803: ST_TO_ADDR
// tmp :=  ;
101804: LD_ADDR_VAR 0 3
101808: PUSH
101809: LD_STRING 
101811: ST_TO_ADDR
// for i = 1 to normalCounter do
101812: LD_ADDR_VAR 0 8
101816: PUSH
101817: DOUBLE
101818: LD_INT 1
101820: DEC
101821: ST_TO_ADDR
101822: LD_EXP 80
101826: PUSH
101827: FOR_TO
101828: IFFALSE 101864
// begin if flags [ i ] then
101830: LD_VAR 0 4
101834: PUSH
101835: LD_VAR 0 8
101839: ARRAY
101840: IFFALSE 101862
// tmp := tmp & i & ; ;
101842: LD_ADDR_VAR 0 3
101846: PUSH
101847: LD_VAR 0 3
101851: PUSH
101852: LD_VAR 0 8
101856: STR
101857: PUSH
101858: LD_STRING ;
101860: STR
101861: ST_TO_ADDR
// end ;
101862: GO 101827
101864: POP
101865: POP
// for i = 1 to hardcoreCounter do
101866: LD_ADDR_VAR 0 8
101870: PUSH
101871: DOUBLE
101872: LD_INT 1
101874: DEC
101875: ST_TO_ADDR
101876: LD_EXP 81
101880: PUSH
101881: FOR_TO
101882: IFFALSE 101928
// begin if flags [ normalCounter + i ] then
101884: LD_VAR 0 4
101888: PUSH
101889: LD_EXP 80
101893: PUSH
101894: LD_VAR 0 8
101898: PLUS
101899: ARRAY
101900: IFFALSE 101926
// tmp := tmp & ( 100 + i ) & ; ;
101902: LD_ADDR_VAR 0 3
101906: PUSH
101907: LD_VAR 0 3
101911: PUSH
101912: LD_INT 100
101914: PUSH
101915: LD_VAR 0 8
101919: PLUS
101920: STR
101921: PUSH
101922: LD_STRING ;
101924: STR
101925: ST_TO_ADDR
// end ;
101926: GO 101881
101928: POP
101929: POP
// if tmp then
101930: LD_VAR 0 3
101934: IFFALSE 101946
// active := tmp ;
101936: LD_ADDR_VAR 0 7
101940: PUSH
101941: LD_VAR 0 3
101945: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
101946: LD_STRING getStreamItemsFromMission("
101948: PUSH
101949: LD_VAR 0 5
101953: STR
101954: PUSH
101955: LD_STRING ","
101957: STR
101958: PUSH
101959: LD_VAR 0 6
101963: STR
101964: PUSH
101965: LD_STRING ","
101967: STR
101968: PUSH
101969: LD_VAR 0 7
101973: STR
101974: PUSH
101975: LD_STRING ")
101977: STR
101978: PPUSH
101979: CALL_OW 559
// end else
101983: GO 101992
// ToLua ( getStreamItemsFromMission("","","") ) ;
101985: LD_STRING getStreamItemsFromMission("","","")
101987: PPUSH
101988: CALL_OW 559
// end ;
101992: LD_VAR 0 2
101996: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
101997: LD_EXP 79
102001: PUSH
102002: LD_EXP 84
102006: AND
102007: IFFALSE 102131
102009: GO 102011
102011: DISABLE
102012: LD_INT 0
102014: PPUSH
102015: PPUSH
// begin enable ;
102016: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
102017: LD_ADDR_VAR 0 2
102021: PUSH
102022: LD_INT 22
102024: PUSH
102025: LD_OWVAR 2
102029: PUSH
102030: EMPTY
102031: LIST
102032: LIST
102033: PUSH
102034: LD_INT 2
102036: PUSH
102037: LD_INT 34
102039: PUSH
102040: LD_INT 7
102042: PUSH
102043: EMPTY
102044: LIST
102045: LIST
102046: PUSH
102047: LD_INT 34
102049: PUSH
102050: LD_INT 45
102052: PUSH
102053: EMPTY
102054: LIST
102055: LIST
102056: PUSH
102057: LD_INT 34
102059: PUSH
102060: LD_INT 28
102062: PUSH
102063: EMPTY
102064: LIST
102065: LIST
102066: PUSH
102067: LD_INT 34
102069: PUSH
102070: LD_INT 47
102072: PUSH
102073: EMPTY
102074: LIST
102075: LIST
102076: PUSH
102077: EMPTY
102078: LIST
102079: LIST
102080: LIST
102081: LIST
102082: LIST
102083: PUSH
102084: EMPTY
102085: LIST
102086: LIST
102087: PPUSH
102088: CALL_OW 69
102092: ST_TO_ADDR
// if not tmp then
102093: LD_VAR 0 2
102097: NOT
102098: IFFALSE 102102
// exit ;
102100: GO 102131
// for i in tmp do
102102: LD_ADDR_VAR 0 1
102106: PUSH
102107: LD_VAR 0 2
102111: PUSH
102112: FOR_IN
102113: IFFALSE 102129
// begin SetLives ( i , 0 ) ;
102115: LD_VAR 0 1
102119: PPUSH
102120: LD_INT 0
102122: PPUSH
102123: CALL_OW 234
// end ;
102127: GO 102112
102129: POP
102130: POP
// end ;
102131: PPOPN 2
102133: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
102134: LD_EXP 79
102138: PUSH
102139: LD_EXP 85
102143: AND
102144: IFFALSE 102228
102146: GO 102148
102148: DISABLE
102149: LD_INT 0
102151: PPUSH
102152: PPUSH
// begin enable ;
102153: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
102154: LD_ADDR_VAR 0 2
102158: PUSH
102159: LD_INT 22
102161: PUSH
102162: LD_OWVAR 2
102166: PUSH
102167: EMPTY
102168: LIST
102169: LIST
102170: PUSH
102171: LD_INT 32
102173: PUSH
102174: LD_INT 3
102176: PUSH
102177: EMPTY
102178: LIST
102179: LIST
102180: PUSH
102181: EMPTY
102182: LIST
102183: LIST
102184: PPUSH
102185: CALL_OW 69
102189: ST_TO_ADDR
// if not tmp then
102190: LD_VAR 0 2
102194: NOT
102195: IFFALSE 102199
// exit ;
102197: GO 102228
// for i in tmp do
102199: LD_ADDR_VAR 0 1
102203: PUSH
102204: LD_VAR 0 2
102208: PUSH
102209: FOR_IN
102210: IFFALSE 102226
// begin SetLives ( i , 0 ) ;
102212: LD_VAR 0 1
102216: PPUSH
102217: LD_INT 0
102219: PPUSH
102220: CALL_OW 234
// end ;
102224: GO 102209
102226: POP
102227: POP
// end ;
102228: PPOPN 2
102230: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
102231: LD_EXP 79
102235: PUSH
102236: LD_EXP 82
102240: AND
102241: IFFALSE 102334
102243: GO 102245
102245: DISABLE
102246: LD_INT 0
102248: PPUSH
// begin enable ;
102249: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
102250: LD_ADDR_VAR 0 1
102254: PUSH
102255: LD_INT 22
102257: PUSH
102258: LD_OWVAR 2
102262: PUSH
102263: EMPTY
102264: LIST
102265: LIST
102266: PUSH
102267: LD_INT 2
102269: PUSH
102270: LD_INT 25
102272: PUSH
102273: LD_INT 5
102275: PUSH
102276: EMPTY
102277: LIST
102278: LIST
102279: PUSH
102280: LD_INT 25
102282: PUSH
102283: LD_INT 9
102285: PUSH
102286: EMPTY
102287: LIST
102288: LIST
102289: PUSH
102290: LD_INT 25
102292: PUSH
102293: LD_INT 8
102295: PUSH
102296: EMPTY
102297: LIST
102298: LIST
102299: PUSH
102300: EMPTY
102301: LIST
102302: LIST
102303: LIST
102304: LIST
102305: PUSH
102306: EMPTY
102307: LIST
102308: LIST
102309: PPUSH
102310: CALL_OW 69
102314: PUSH
102315: FOR_IN
102316: IFFALSE 102332
// begin SetClass ( i , 1 ) ;
102318: LD_VAR 0 1
102322: PPUSH
102323: LD_INT 1
102325: PPUSH
102326: CALL_OW 336
// end ;
102330: GO 102315
102332: POP
102333: POP
// end ;
102334: PPOPN 1
102336: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
102337: LD_EXP 79
102341: PUSH
102342: LD_EXP 83
102346: AND
102347: PUSH
102348: LD_OWVAR 65
102352: PUSH
102353: LD_INT 7
102355: LESS
102356: AND
102357: IFFALSE 102371
102359: GO 102361
102361: DISABLE
// begin enable ;
102362: ENABLE
// game_speed := 7 ;
102363: LD_ADDR_OWVAR 65
102367: PUSH
102368: LD_INT 7
102370: ST_TO_ADDR
// end ;
102371: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
102372: LD_EXP 79
102376: PUSH
102377: LD_EXP 86
102381: AND
102382: IFFALSE 102584
102384: GO 102386
102386: DISABLE
102387: LD_INT 0
102389: PPUSH
102390: PPUSH
102391: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
102392: LD_ADDR_VAR 0 3
102396: PUSH
102397: LD_INT 81
102399: PUSH
102400: LD_OWVAR 2
102404: PUSH
102405: EMPTY
102406: LIST
102407: LIST
102408: PUSH
102409: LD_INT 21
102411: PUSH
102412: LD_INT 1
102414: PUSH
102415: EMPTY
102416: LIST
102417: LIST
102418: PUSH
102419: EMPTY
102420: LIST
102421: LIST
102422: PPUSH
102423: CALL_OW 69
102427: ST_TO_ADDR
// if not tmp then
102428: LD_VAR 0 3
102432: NOT
102433: IFFALSE 102437
// exit ;
102435: GO 102584
// if tmp > 5 then
102437: LD_VAR 0 3
102441: PUSH
102442: LD_INT 5
102444: GREATER
102445: IFFALSE 102457
// k := 5 else
102447: LD_ADDR_VAR 0 2
102451: PUSH
102452: LD_INT 5
102454: ST_TO_ADDR
102455: GO 102467
// k := tmp ;
102457: LD_ADDR_VAR 0 2
102461: PUSH
102462: LD_VAR 0 3
102466: ST_TO_ADDR
// for i := 1 to k do
102467: LD_ADDR_VAR 0 1
102471: PUSH
102472: DOUBLE
102473: LD_INT 1
102475: DEC
102476: ST_TO_ADDR
102477: LD_VAR 0 2
102481: PUSH
102482: FOR_TO
102483: IFFALSE 102582
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
102485: LD_VAR 0 3
102489: PUSH
102490: LD_VAR 0 1
102494: ARRAY
102495: PPUSH
102496: LD_VAR 0 1
102500: PUSH
102501: LD_INT 4
102503: MOD
102504: PUSH
102505: LD_INT 1
102507: PLUS
102508: PPUSH
102509: CALL_OW 259
102513: PUSH
102514: LD_INT 10
102516: LESS
102517: IFFALSE 102580
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
102519: LD_VAR 0 3
102523: PUSH
102524: LD_VAR 0 1
102528: ARRAY
102529: PPUSH
102530: LD_VAR 0 1
102534: PUSH
102535: LD_INT 4
102537: MOD
102538: PUSH
102539: LD_INT 1
102541: PLUS
102542: PPUSH
102543: LD_VAR 0 3
102547: PUSH
102548: LD_VAR 0 1
102552: ARRAY
102553: PPUSH
102554: LD_VAR 0 1
102558: PUSH
102559: LD_INT 4
102561: MOD
102562: PUSH
102563: LD_INT 1
102565: PLUS
102566: PPUSH
102567: CALL_OW 259
102571: PUSH
102572: LD_INT 1
102574: PLUS
102575: PPUSH
102576: CALL_OW 237
102580: GO 102482
102582: POP
102583: POP
// end ;
102584: PPOPN 3
102586: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
102587: LD_EXP 79
102591: PUSH
102592: LD_EXP 87
102596: AND
102597: IFFALSE 102617
102599: GO 102601
102601: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
102602: LD_INT 4
102604: PPUSH
102605: LD_OWVAR 2
102609: PPUSH
102610: LD_INT 0
102612: PPUSH
102613: CALL_OW 324
102617: END
// every 0 0$1 trigger StreamModeActive and sShovel do
102618: LD_EXP 79
102622: PUSH
102623: LD_EXP 116
102627: AND
102628: IFFALSE 102648
102630: GO 102632
102632: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
102633: LD_INT 19
102635: PPUSH
102636: LD_OWVAR 2
102640: PPUSH
102641: LD_INT 0
102643: PPUSH
102644: CALL_OW 324
102648: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
102649: LD_EXP 79
102653: PUSH
102654: LD_EXP 88
102658: AND
102659: IFFALSE 102761
102661: GO 102663
102663: DISABLE
102664: LD_INT 0
102666: PPUSH
102667: PPUSH
// begin enable ;
102668: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
102669: LD_ADDR_VAR 0 2
102673: PUSH
102674: LD_INT 22
102676: PUSH
102677: LD_OWVAR 2
102681: PUSH
102682: EMPTY
102683: LIST
102684: LIST
102685: PUSH
102686: LD_INT 2
102688: PUSH
102689: LD_INT 34
102691: PUSH
102692: LD_INT 11
102694: PUSH
102695: EMPTY
102696: LIST
102697: LIST
102698: PUSH
102699: LD_INT 34
102701: PUSH
102702: LD_INT 30
102704: PUSH
102705: EMPTY
102706: LIST
102707: LIST
102708: PUSH
102709: EMPTY
102710: LIST
102711: LIST
102712: LIST
102713: PUSH
102714: EMPTY
102715: LIST
102716: LIST
102717: PPUSH
102718: CALL_OW 69
102722: ST_TO_ADDR
// if not tmp then
102723: LD_VAR 0 2
102727: NOT
102728: IFFALSE 102732
// exit ;
102730: GO 102761
// for i in tmp do
102732: LD_ADDR_VAR 0 1
102736: PUSH
102737: LD_VAR 0 2
102741: PUSH
102742: FOR_IN
102743: IFFALSE 102759
// begin SetLives ( i , 0 ) ;
102745: LD_VAR 0 1
102749: PPUSH
102750: LD_INT 0
102752: PPUSH
102753: CALL_OW 234
// end ;
102757: GO 102742
102759: POP
102760: POP
// end ;
102761: PPOPN 2
102763: END
// every 0 0$1 trigger StreamModeActive and sBunker do
102764: LD_EXP 79
102768: PUSH
102769: LD_EXP 89
102773: AND
102774: IFFALSE 102794
102776: GO 102778
102778: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
102779: LD_INT 32
102781: PPUSH
102782: LD_OWVAR 2
102786: PPUSH
102787: LD_INT 0
102789: PPUSH
102790: CALL_OW 324
102794: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
102795: LD_EXP 79
102799: PUSH
102800: LD_EXP 90
102804: AND
102805: IFFALSE 102986
102807: GO 102809
102809: DISABLE
102810: LD_INT 0
102812: PPUSH
102813: PPUSH
102814: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
102815: LD_ADDR_VAR 0 2
102819: PUSH
102820: LD_INT 22
102822: PUSH
102823: LD_OWVAR 2
102827: PUSH
102828: EMPTY
102829: LIST
102830: LIST
102831: PUSH
102832: LD_INT 33
102834: PUSH
102835: LD_INT 3
102837: PUSH
102838: EMPTY
102839: LIST
102840: LIST
102841: PUSH
102842: EMPTY
102843: LIST
102844: LIST
102845: PPUSH
102846: CALL_OW 69
102850: ST_TO_ADDR
// if not tmp then
102851: LD_VAR 0 2
102855: NOT
102856: IFFALSE 102860
// exit ;
102858: GO 102986
// side := 0 ;
102860: LD_ADDR_VAR 0 3
102864: PUSH
102865: LD_INT 0
102867: ST_TO_ADDR
// for i := 1 to 8 do
102868: LD_ADDR_VAR 0 1
102872: PUSH
102873: DOUBLE
102874: LD_INT 1
102876: DEC
102877: ST_TO_ADDR
102878: LD_INT 8
102880: PUSH
102881: FOR_TO
102882: IFFALSE 102930
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
102884: LD_OWVAR 2
102888: PUSH
102889: LD_VAR 0 1
102893: NONEQUAL
102894: PUSH
102895: LD_OWVAR 2
102899: PPUSH
102900: LD_VAR 0 1
102904: PPUSH
102905: CALL_OW 81
102909: PUSH
102910: LD_INT 2
102912: EQUAL
102913: AND
102914: IFFALSE 102928
// begin side := i ;
102916: LD_ADDR_VAR 0 3
102920: PUSH
102921: LD_VAR 0 1
102925: ST_TO_ADDR
// break ;
102926: GO 102930
// end ;
102928: GO 102881
102930: POP
102931: POP
// if not side then
102932: LD_VAR 0 3
102936: NOT
102937: IFFALSE 102941
// exit ;
102939: GO 102986
// for i := 1 to tmp do
102941: LD_ADDR_VAR 0 1
102945: PUSH
102946: DOUBLE
102947: LD_INT 1
102949: DEC
102950: ST_TO_ADDR
102951: LD_VAR 0 2
102955: PUSH
102956: FOR_TO
102957: IFFALSE 102984
// if Prob ( 60 ) then
102959: LD_INT 60
102961: PPUSH
102962: CALL_OW 13
102966: IFFALSE 102982
// SetSide ( i , side ) ;
102968: LD_VAR 0 1
102972: PPUSH
102973: LD_VAR 0 3
102977: PPUSH
102978: CALL_OW 235
102982: GO 102956
102984: POP
102985: POP
// end ;
102986: PPOPN 3
102988: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
102989: LD_EXP 79
102993: PUSH
102994: LD_EXP 92
102998: AND
102999: IFFALSE 103118
103001: GO 103003
103003: DISABLE
103004: LD_INT 0
103006: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
103007: LD_ADDR_VAR 0 1
103011: PUSH
103012: LD_INT 22
103014: PUSH
103015: LD_OWVAR 2
103019: PUSH
103020: EMPTY
103021: LIST
103022: LIST
103023: PUSH
103024: LD_INT 21
103026: PUSH
103027: LD_INT 1
103029: PUSH
103030: EMPTY
103031: LIST
103032: LIST
103033: PUSH
103034: LD_INT 3
103036: PUSH
103037: LD_INT 23
103039: PUSH
103040: LD_INT 0
103042: PUSH
103043: EMPTY
103044: LIST
103045: LIST
103046: PUSH
103047: EMPTY
103048: LIST
103049: LIST
103050: PUSH
103051: EMPTY
103052: LIST
103053: LIST
103054: LIST
103055: PPUSH
103056: CALL_OW 69
103060: PUSH
103061: FOR_IN
103062: IFFALSE 103116
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
103064: LD_VAR 0 1
103068: PPUSH
103069: CALL_OW 257
103073: PUSH
103074: LD_INT 1
103076: PUSH
103077: LD_INT 2
103079: PUSH
103080: LD_INT 3
103082: PUSH
103083: LD_INT 4
103085: PUSH
103086: EMPTY
103087: LIST
103088: LIST
103089: LIST
103090: LIST
103091: IN
103092: IFFALSE 103114
// SetClass ( un , rand ( 1 , 4 ) ) ;
103094: LD_VAR 0 1
103098: PPUSH
103099: LD_INT 1
103101: PPUSH
103102: LD_INT 4
103104: PPUSH
103105: CALL_OW 12
103109: PPUSH
103110: CALL_OW 336
103114: GO 103061
103116: POP
103117: POP
// end ;
103118: PPOPN 1
103120: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
103121: LD_EXP 79
103125: PUSH
103126: LD_EXP 91
103130: AND
103131: IFFALSE 103210
103133: GO 103135
103135: DISABLE
103136: LD_INT 0
103138: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
103139: LD_ADDR_VAR 0 1
103143: PUSH
103144: LD_INT 22
103146: PUSH
103147: LD_OWVAR 2
103151: PUSH
103152: EMPTY
103153: LIST
103154: LIST
103155: PUSH
103156: LD_INT 21
103158: PUSH
103159: LD_INT 3
103161: PUSH
103162: EMPTY
103163: LIST
103164: LIST
103165: PUSH
103166: EMPTY
103167: LIST
103168: LIST
103169: PPUSH
103170: CALL_OW 69
103174: ST_TO_ADDR
// if not tmp then
103175: LD_VAR 0 1
103179: NOT
103180: IFFALSE 103184
// exit ;
103182: GO 103210
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
103184: LD_VAR 0 1
103188: PUSH
103189: LD_INT 1
103191: PPUSH
103192: LD_VAR 0 1
103196: PPUSH
103197: CALL_OW 12
103201: ARRAY
103202: PPUSH
103203: LD_INT 100
103205: PPUSH
103206: CALL_OW 234
// end ;
103210: PPOPN 1
103212: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
103213: LD_EXP 79
103217: PUSH
103218: LD_EXP 93
103222: AND
103223: IFFALSE 103321
103225: GO 103227
103227: DISABLE
103228: LD_INT 0
103230: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
103231: LD_ADDR_VAR 0 1
103235: PUSH
103236: LD_INT 22
103238: PUSH
103239: LD_OWVAR 2
103243: PUSH
103244: EMPTY
103245: LIST
103246: LIST
103247: PUSH
103248: LD_INT 21
103250: PUSH
103251: LD_INT 1
103253: PUSH
103254: EMPTY
103255: LIST
103256: LIST
103257: PUSH
103258: EMPTY
103259: LIST
103260: LIST
103261: PPUSH
103262: CALL_OW 69
103266: ST_TO_ADDR
// if not tmp then
103267: LD_VAR 0 1
103271: NOT
103272: IFFALSE 103276
// exit ;
103274: GO 103321
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
103276: LD_VAR 0 1
103280: PUSH
103281: LD_INT 1
103283: PPUSH
103284: LD_VAR 0 1
103288: PPUSH
103289: CALL_OW 12
103293: ARRAY
103294: PPUSH
103295: LD_INT 1
103297: PPUSH
103298: LD_INT 4
103300: PPUSH
103301: CALL_OW 12
103305: PPUSH
103306: LD_INT 3000
103308: PPUSH
103309: LD_INT 9000
103311: PPUSH
103312: CALL_OW 12
103316: PPUSH
103317: CALL_OW 492
// end ;
103321: PPOPN 1
103323: END
// every 0 0$1 trigger StreamModeActive and sDepot do
103324: LD_EXP 79
103328: PUSH
103329: LD_EXP 94
103333: AND
103334: IFFALSE 103354
103336: GO 103338
103338: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
103339: LD_INT 1
103341: PPUSH
103342: LD_OWVAR 2
103346: PPUSH
103347: LD_INT 0
103349: PPUSH
103350: CALL_OW 324
103354: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
103355: LD_EXP 79
103359: PUSH
103360: LD_EXP 95
103364: AND
103365: IFFALSE 103448
103367: GO 103369
103369: DISABLE
103370: LD_INT 0
103372: PPUSH
103373: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
103374: LD_ADDR_VAR 0 2
103378: PUSH
103379: LD_INT 22
103381: PUSH
103382: LD_OWVAR 2
103386: PUSH
103387: EMPTY
103388: LIST
103389: LIST
103390: PUSH
103391: LD_INT 21
103393: PUSH
103394: LD_INT 3
103396: PUSH
103397: EMPTY
103398: LIST
103399: LIST
103400: PUSH
103401: EMPTY
103402: LIST
103403: LIST
103404: PPUSH
103405: CALL_OW 69
103409: ST_TO_ADDR
// if not tmp then
103410: LD_VAR 0 2
103414: NOT
103415: IFFALSE 103419
// exit ;
103417: GO 103448
// for i in tmp do
103419: LD_ADDR_VAR 0 1
103423: PUSH
103424: LD_VAR 0 2
103428: PUSH
103429: FOR_IN
103430: IFFALSE 103446
// SetBLevel ( i , 10 ) ;
103432: LD_VAR 0 1
103436: PPUSH
103437: LD_INT 10
103439: PPUSH
103440: CALL_OW 241
103444: GO 103429
103446: POP
103447: POP
// end ;
103448: PPOPN 2
103450: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
103451: LD_EXP 79
103455: PUSH
103456: LD_EXP 96
103460: AND
103461: IFFALSE 103572
103463: GO 103465
103465: DISABLE
103466: LD_INT 0
103468: PPUSH
103469: PPUSH
103470: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103471: LD_ADDR_VAR 0 3
103475: PUSH
103476: LD_INT 22
103478: PUSH
103479: LD_OWVAR 2
103483: PUSH
103484: EMPTY
103485: LIST
103486: LIST
103487: PUSH
103488: LD_INT 25
103490: PUSH
103491: LD_INT 1
103493: PUSH
103494: EMPTY
103495: LIST
103496: LIST
103497: PUSH
103498: EMPTY
103499: LIST
103500: LIST
103501: PPUSH
103502: CALL_OW 69
103506: ST_TO_ADDR
// if not tmp then
103507: LD_VAR 0 3
103511: NOT
103512: IFFALSE 103516
// exit ;
103514: GO 103572
// un := tmp [ rand ( 1 , tmp ) ] ;
103516: LD_ADDR_VAR 0 2
103520: PUSH
103521: LD_VAR 0 3
103525: PUSH
103526: LD_INT 1
103528: PPUSH
103529: LD_VAR 0 3
103533: PPUSH
103534: CALL_OW 12
103538: ARRAY
103539: ST_TO_ADDR
// if Crawls ( un ) then
103540: LD_VAR 0 2
103544: PPUSH
103545: CALL_OW 318
103549: IFFALSE 103560
// ComWalk ( un ) ;
103551: LD_VAR 0 2
103555: PPUSH
103556: CALL_OW 138
// SetClass ( un , class_sniper ) ;
103560: LD_VAR 0 2
103564: PPUSH
103565: LD_INT 5
103567: PPUSH
103568: CALL_OW 336
// end ;
103572: PPOPN 3
103574: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
103575: LD_EXP 79
103579: PUSH
103580: LD_EXP 97
103584: AND
103585: PUSH
103586: LD_OWVAR 67
103590: PUSH
103591: LD_INT 4
103593: LESS
103594: AND
103595: IFFALSE 103614
103597: GO 103599
103599: DISABLE
// begin Difficulty := Difficulty + 1 ;
103600: LD_ADDR_OWVAR 67
103604: PUSH
103605: LD_OWVAR 67
103609: PUSH
103610: LD_INT 1
103612: PLUS
103613: ST_TO_ADDR
// end ;
103614: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
103615: LD_EXP 79
103619: PUSH
103620: LD_EXP 98
103624: AND
103625: IFFALSE 103728
103627: GO 103629
103629: DISABLE
103630: LD_INT 0
103632: PPUSH
// begin for i := 1 to 5 do
103633: LD_ADDR_VAR 0 1
103637: PUSH
103638: DOUBLE
103639: LD_INT 1
103641: DEC
103642: ST_TO_ADDR
103643: LD_INT 5
103645: PUSH
103646: FOR_TO
103647: IFFALSE 103726
// begin uc_nation := nation_nature ;
103649: LD_ADDR_OWVAR 21
103653: PUSH
103654: LD_INT 0
103656: ST_TO_ADDR
// uc_side := 0 ;
103657: LD_ADDR_OWVAR 20
103661: PUSH
103662: LD_INT 0
103664: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
103665: LD_ADDR_OWVAR 29
103669: PUSH
103670: LD_INT 12
103672: PUSH
103673: LD_INT 12
103675: PUSH
103676: EMPTY
103677: LIST
103678: LIST
103679: ST_TO_ADDR
// hc_agressivity := 20 ;
103680: LD_ADDR_OWVAR 35
103684: PUSH
103685: LD_INT 20
103687: ST_TO_ADDR
// hc_class := class_tiger ;
103688: LD_ADDR_OWVAR 28
103692: PUSH
103693: LD_INT 14
103695: ST_TO_ADDR
// hc_gallery :=  ;
103696: LD_ADDR_OWVAR 33
103700: PUSH
103701: LD_STRING 
103703: ST_TO_ADDR
// hc_name :=  ;
103704: LD_ADDR_OWVAR 26
103708: PUSH
103709: LD_STRING 
103711: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
103712: CALL_OW 44
103716: PPUSH
103717: LD_INT 0
103719: PPUSH
103720: CALL_OW 51
// end ;
103724: GO 103646
103726: POP
103727: POP
// end ;
103728: PPOPN 1
103730: END
// every 0 0$1 trigger StreamModeActive and sBomb do
103731: LD_EXP 79
103735: PUSH
103736: LD_EXP 99
103740: AND
103741: IFFALSE 103750
103743: GO 103745
103745: DISABLE
// StreamSibBomb ;
103746: CALL 103751 0 0
103750: END
// export function StreamSibBomb ; var i , x , y ; begin
103751: LD_INT 0
103753: PPUSH
103754: PPUSH
103755: PPUSH
103756: PPUSH
// result := false ;
103757: LD_ADDR_VAR 0 1
103761: PUSH
103762: LD_INT 0
103764: ST_TO_ADDR
// for i := 1 to 16 do
103765: LD_ADDR_VAR 0 2
103769: PUSH
103770: DOUBLE
103771: LD_INT 1
103773: DEC
103774: ST_TO_ADDR
103775: LD_INT 16
103777: PUSH
103778: FOR_TO
103779: IFFALSE 103978
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
103781: LD_ADDR_VAR 0 3
103785: PUSH
103786: LD_INT 10
103788: PUSH
103789: LD_INT 20
103791: PUSH
103792: LD_INT 30
103794: PUSH
103795: LD_INT 40
103797: PUSH
103798: LD_INT 50
103800: PUSH
103801: LD_INT 60
103803: PUSH
103804: LD_INT 70
103806: PUSH
103807: LD_INT 80
103809: PUSH
103810: LD_INT 90
103812: PUSH
103813: LD_INT 100
103815: PUSH
103816: LD_INT 110
103818: PUSH
103819: LD_INT 120
103821: PUSH
103822: LD_INT 130
103824: PUSH
103825: LD_INT 140
103827: PUSH
103828: LD_INT 150
103830: PUSH
103831: EMPTY
103832: LIST
103833: LIST
103834: LIST
103835: LIST
103836: LIST
103837: LIST
103838: LIST
103839: LIST
103840: LIST
103841: LIST
103842: LIST
103843: LIST
103844: LIST
103845: LIST
103846: LIST
103847: PUSH
103848: LD_INT 1
103850: PPUSH
103851: LD_INT 15
103853: PPUSH
103854: CALL_OW 12
103858: ARRAY
103859: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
103860: LD_ADDR_VAR 0 4
103864: PUSH
103865: LD_INT 10
103867: PUSH
103868: LD_INT 20
103870: PUSH
103871: LD_INT 30
103873: PUSH
103874: LD_INT 40
103876: PUSH
103877: LD_INT 50
103879: PUSH
103880: LD_INT 60
103882: PUSH
103883: LD_INT 70
103885: PUSH
103886: LD_INT 80
103888: PUSH
103889: LD_INT 90
103891: PUSH
103892: LD_INT 100
103894: PUSH
103895: LD_INT 110
103897: PUSH
103898: LD_INT 120
103900: PUSH
103901: LD_INT 130
103903: PUSH
103904: LD_INT 140
103906: PUSH
103907: LD_INT 150
103909: PUSH
103910: EMPTY
103911: LIST
103912: LIST
103913: LIST
103914: LIST
103915: LIST
103916: LIST
103917: LIST
103918: LIST
103919: LIST
103920: LIST
103921: LIST
103922: LIST
103923: LIST
103924: LIST
103925: LIST
103926: PUSH
103927: LD_INT 1
103929: PPUSH
103930: LD_INT 15
103932: PPUSH
103933: CALL_OW 12
103937: ARRAY
103938: ST_TO_ADDR
// if ValidHex ( x , y ) then
103939: LD_VAR 0 3
103943: PPUSH
103944: LD_VAR 0 4
103948: PPUSH
103949: CALL_OW 488
103953: IFFALSE 103976
// begin result := [ x , y ] ;
103955: LD_ADDR_VAR 0 1
103959: PUSH
103960: LD_VAR 0 3
103964: PUSH
103965: LD_VAR 0 4
103969: PUSH
103970: EMPTY
103971: LIST
103972: LIST
103973: ST_TO_ADDR
// break ;
103974: GO 103978
// end ; end ;
103976: GO 103778
103978: POP
103979: POP
// if result then
103980: LD_VAR 0 1
103984: IFFALSE 104044
// begin ToLua ( playSibBomb() ) ;
103986: LD_STRING playSibBomb()
103988: PPUSH
103989: CALL_OW 559
// wait ( 0 0$14 ) ;
103993: LD_INT 490
103995: PPUSH
103996: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
104000: LD_VAR 0 1
104004: PUSH
104005: LD_INT 1
104007: ARRAY
104008: PPUSH
104009: LD_VAR 0 1
104013: PUSH
104014: LD_INT 2
104016: ARRAY
104017: PPUSH
104018: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
104022: LD_VAR 0 1
104026: PUSH
104027: LD_INT 1
104029: ARRAY
104030: PPUSH
104031: LD_VAR 0 1
104035: PUSH
104036: LD_INT 2
104038: ARRAY
104039: PPUSH
104040: CALL_OW 429
// end ; end ;
104044: LD_VAR 0 1
104048: RET
// every 0 0$1 trigger StreamModeActive and sReset do
104049: LD_EXP 79
104053: PUSH
104054: LD_EXP 101
104058: AND
104059: IFFALSE 104071
104061: GO 104063
104063: DISABLE
// YouLost (  ) ;
104064: LD_STRING 
104066: PPUSH
104067: CALL_OW 104
104071: END
// every 0 0$1 trigger StreamModeActive and sFog do
104072: LD_EXP 79
104076: PUSH
104077: LD_EXP 100
104081: AND
104082: IFFALSE 104096
104084: GO 104086
104086: DISABLE
// FogOff ( your_side ) ;
104087: LD_OWVAR 2
104091: PPUSH
104092: CALL_OW 344
104096: END
// every 0 0$1 trigger StreamModeActive and sSun do
104097: LD_EXP 79
104101: PUSH
104102: LD_EXP 102
104106: AND
104107: IFFALSE 104135
104109: GO 104111
104111: DISABLE
// begin solar_recharge_percent := 0 ;
104112: LD_ADDR_OWVAR 79
104116: PUSH
104117: LD_INT 0
104119: ST_TO_ADDR
// wait ( 5 5$00 ) ;
104120: LD_INT 10500
104122: PPUSH
104123: CALL_OW 67
// solar_recharge_percent := 100 ;
104127: LD_ADDR_OWVAR 79
104131: PUSH
104132: LD_INT 100
104134: ST_TO_ADDR
// end ;
104135: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
104136: LD_EXP 79
104140: PUSH
104141: LD_EXP 103
104145: AND
104146: IFFALSE 104385
104148: GO 104150
104150: DISABLE
104151: LD_INT 0
104153: PPUSH
104154: PPUSH
104155: PPUSH
// begin tmp := [ ] ;
104156: LD_ADDR_VAR 0 3
104160: PUSH
104161: EMPTY
104162: ST_TO_ADDR
// for i := 1 to 6 do
104163: LD_ADDR_VAR 0 1
104167: PUSH
104168: DOUBLE
104169: LD_INT 1
104171: DEC
104172: ST_TO_ADDR
104173: LD_INT 6
104175: PUSH
104176: FOR_TO
104177: IFFALSE 104282
// begin uc_nation := nation_nature ;
104179: LD_ADDR_OWVAR 21
104183: PUSH
104184: LD_INT 0
104186: ST_TO_ADDR
// uc_side := 0 ;
104187: LD_ADDR_OWVAR 20
104191: PUSH
104192: LD_INT 0
104194: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
104195: LD_ADDR_OWVAR 29
104199: PUSH
104200: LD_INT 12
104202: PUSH
104203: LD_INT 12
104205: PUSH
104206: EMPTY
104207: LIST
104208: LIST
104209: ST_TO_ADDR
// hc_agressivity := 20 ;
104210: LD_ADDR_OWVAR 35
104214: PUSH
104215: LD_INT 20
104217: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
104218: LD_ADDR_OWVAR 28
104222: PUSH
104223: LD_INT 17
104225: ST_TO_ADDR
// hc_gallery :=  ;
104226: LD_ADDR_OWVAR 33
104230: PUSH
104231: LD_STRING 
104233: ST_TO_ADDR
// hc_name :=  ;
104234: LD_ADDR_OWVAR 26
104238: PUSH
104239: LD_STRING 
104241: ST_TO_ADDR
// un := CreateHuman ;
104242: LD_ADDR_VAR 0 2
104246: PUSH
104247: CALL_OW 44
104251: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
104252: LD_VAR 0 2
104256: PPUSH
104257: LD_INT 1
104259: PPUSH
104260: CALL_OW 51
// tmp := tmp ^ un ;
104264: LD_ADDR_VAR 0 3
104268: PUSH
104269: LD_VAR 0 3
104273: PUSH
104274: LD_VAR 0 2
104278: ADD
104279: ST_TO_ADDR
// end ;
104280: GO 104176
104282: POP
104283: POP
// repeat wait ( 0 0$1 ) ;
104284: LD_INT 35
104286: PPUSH
104287: CALL_OW 67
// for un in tmp do
104291: LD_ADDR_VAR 0 2
104295: PUSH
104296: LD_VAR 0 3
104300: PUSH
104301: FOR_IN
104302: IFFALSE 104376
// begin if IsDead ( un ) then
104304: LD_VAR 0 2
104308: PPUSH
104309: CALL_OW 301
104313: IFFALSE 104333
// begin tmp := tmp diff un ;
104315: LD_ADDR_VAR 0 3
104319: PUSH
104320: LD_VAR 0 3
104324: PUSH
104325: LD_VAR 0 2
104329: DIFF
104330: ST_TO_ADDR
// continue ;
104331: GO 104301
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
104333: LD_VAR 0 2
104337: PPUSH
104338: LD_INT 3
104340: PUSH
104341: LD_INT 22
104343: PUSH
104344: LD_INT 0
104346: PUSH
104347: EMPTY
104348: LIST
104349: LIST
104350: PUSH
104351: EMPTY
104352: LIST
104353: LIST
104354: PPUSH
104355: CALL_OW 69
104359: PPUSH
104360: LD_VAR 0 2
104364: PPUSH
104365: CALL_OW 74
104369: PPUSH
104370: CALL_OW 115
// end ;
104374: GO 104301
104376: POP
104377: POP
// until not tmp ;
104378: LD_VAR 0 3
104382: NOT
104383: IFFALSE 104284
// end ;
104385: PPOPN 3
104387: END
// every 0 0$1 trigger StreamModeActive and sTroll do
104388: LD_EXP 79
104392: PUSH
104393: LD_EXP 104
104397: AND
104398: IFFALSE 104452
104400: GO 104402
104402: DISABLE
// begin ToLua ( displayTroll(); ) ;
104403: LD_STRING displayTroll();
104405: PPUSH
104406: CALL_OW 559
// wait ( 3 3$00 ) ;
104410: LD_INT 6300
104412: PPUSH
104413: CALL_OW 67
// ToLua ( hideTroll(); ) ;
104417: LD_STRING hideTroll();
104419: PPUSH
104420: CALL_OW 559
// wait ( 1 1$00 ) ;
104424: LD_INT 2100
104426: PPUSH
104427: CALL_OW 67
// ToLua ( displayTroll(); ) ;
104431: LD_STRING displayTroll();
104433: PPUSH
104434: CALL_OW 559
// wait ( 1 1$00 ) ;
104438: LD_INT 2100
104440: PPUSH
104441: CALL_OW 67
// ToLua ( hideTroll(); ) ;
104445: LD_STRING hideTroll();
104447: PPUSH
104448: CALL_OW 559
// end ;
104452: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
104453: LD_EXP 79
104457: PUSH
104458: LD_EXP 105
104462: AND
104463: IFFALSE 104526
104465: GO 104467
104467: DISABLE
104468: LD_INT 0
104470: PPUSH
// begin p := 0 ;
104471: LD_ADDR_VAR 0 1
104475: PUSH
104476: LD_INT 0
104478: ST_TO_ADDR
// repeat game_speed := 1 ;
104479: LD_ADDR_OWVAR 65
104483: PUSH
104484: LD_INT 1
104486: ST_TO_ADDR
// wait ( 0 0$1 ) ;
104487: LD_INT 35
104489: PPUSH
104490: CALL_OW 67
// p := p + 1 ;
104494: LD_ADDR_VAR 0 1
104498: PUSH
104499: LD_VAR 0 1
104503: PUSH
104504: LD_INT 1
104506: PLUS
104507: ST_TO_ADDR
// until p >= 60 ;
104508: LD_VAR 0 1
104512: PUSH
104513: LD_INT 60
104515: GREATEREQUAL
104516: IFFALSE 104479
// game_speed := 4 ;
104518: LD_ADDR_OWVAR 65
104522: PUSH
104523: LD_INT 4
104525: ST_TO_ADDR
// end ;
104526: PPOPN 1
104528: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
104529: LD_EXP 79
104533: PUSH
104534: LD_EXP 106
104538: AND
104539: IFFALSE 104685
104541: GO 104543
104543: DISABLE
104544: LD_INT 0
104546: PPUSH
104547: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
104548: LD_ADDR_VAR 0 1
104552: PUSH
104553: LD_INT 22
104555: PUSH
104556: LD_OWVAR 2
104560: PUSH
104561: EMPTY
104562: LIST
104563: LIST
104564: PUSH
104565: LD_INT 2
104567: PUSH
104568: LD_INT 30
104570: PUSH
104571: LD_INT 0
104573: PUSH
104574: EMPTY
104575: LIST
104576: LIST
104577: PUSH
104578: LD_INT 30
104580: PUSH
104581: LD_INT 1
104583: PUSH
104584: EMPTY
104585: LIST
104586: LIST
104587: PUSH
104588: EMPTY
104589: LIST
104590: LIST
104591: LIST
104592: PUSH
104593: EMPTY
104594: LIST
104595: LIST
104596: PPUSH
104597: CALL_OW 69
104601: ST_TO_ADDR
// if not depot then
104602: LD_VAR 0 1
104606: NOT
104607: IFFALSE 104611
// exit ;
104609: GO 104685
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
104611: LD_ADDR_VAR 0 2
104615: PUSH
104616: LD_VAR 0 1
104620: PUSH
104621: LD_INT 1
104623: PPUSH
104624: LD_VAR 0 1
104628: PPUSH
104629: CALL_OW 12
104633: ARRAY
104634: PPUSH
104635: CALL_OW 274
104639: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
104640: LD_VAR 0 2
104644: PPUSH
104645: LD_INT 1
104647: PPUSH
104648: LD_INT 0
104650: PPUSH
104651: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
104655: LD_VAR 0 2
104659: PPUSH
104660: LD_INT 2
104662: PPUSH
104663: LD_INT 0
104665: PPUSH
104666: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
104670: LD_VAR 0 2
104674: PPUSH
104675: LD_INT 3
104677: PPUSH
104678: LD_INT 0
104680: PPUSH
104681: CALL_OW 277
// end ;
104685: PPOPN 2
104687: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
104688: LD_EXP 79
104692: PUSH
104693: LD_EXP 107
104697: AND
104698: IFFALSE 104795
104700: GO 104702
104702: DISABLE
104703: LD_INT 0
104705: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
104706: LD_ADDR_VAR 0 1
104710: PUSH
104711: LD_INT 22
104713: PUSH
104714: LD_OWVAR 2
104718: PUSH
104719: EMPTY
104720: LIST
104721: LIST
104722: PUSH
104723: LD_INT 21
104725: PUSH
104726: LD_INT 1
104728: PUSH
104729: EMPTY
104730: LIST
104731: LIST
104732: PUSH
104733: LD_INT 3
104735: PUSH
104736: LD_INT 23
104738: PUSH
104739: LD_INT 0
104741: PUSH
104742: EMPTY
104743: LIST
104744: LIST
104745: PUSH
104746: EMPTY
104747: LIST
104748: LIST
104749: PUSH
104750: EMPTY
104751: LIST
104752: LIST
104753: LIST
104754: PPUSH
104755: CALL_OW 69
104759: ST_TO_ADDR
// if not tmp then
104760: LD_VAR 0 1
104764: NOT
104765: IFFALSE 104769
// exit ;
104767: GO 104795
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
104769: LD_VAR 0 1
104773: PUSH
104774: LD_INT 1
104776: PPUSH
104777: LD_VAR 0 1
104781: PPUSH
104782: CALL_OW 12
104786: ARRAY
104787: PPUSH
104788: LD_INT 200
104790: PPUSH
104791: CALL_OW 234
// end ;
104795: PPOPN 1
104797: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
104798: LD_EXP 79
104802: PUSH
104803: LD_EXP 108
104807: AND
104808: IFFALSE 104887
104810: GO 104812
104812: DISABLE
104813: LD_INT 0
104815: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
104816: LD_ADDR_VAR 0 1
104820: PUSH
104821: LD_INT 22
104823: PUSH
104824: LD_OWVAR 2
104828: PUSH
104829: EMPTY
104830: LIST
104831: LIST
104832: PUSH
104833: LD_INT 21
104835: PUSH
104836: LD_INT 2
104838: PUSH
104839: EMPTY
104840: LIST
104841: LIST
104842: PUSH
104843: EMPTY
104844: LIST
104845: LIST
104846: PPUSH
104847: CALL_OW 69
104851: ST_TO_ADDR
// if not tmp then
104852: LD_VAR 0 1
104856: NOT
104857: IFFALSE 104861
// exit ;
104859: GO 104887
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
104861: LD_VAR 0 1
104865: PUSH
104866: LD_INT 1
104868: PPUSH
104869: LD_VAR 0 1
104873: PPUSH
104874: CALL_OW 12
104878: ARRAY
104879: PPUSH
104880: LD_INT 60
104882: PPUSH
104883: CALL_OW 234
// end ;
104887: PPOPN 1
104889: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
104890: LD_EXP 79
104894: PUSH
104895: LD_EXP 109
104899: AND
104900: IFFALSE 104999
104902: GO 104904
104904: DISABLE
104905: LD_INT 0
104907: PPUSH
104908: PPUSH
// begin enable ;
104909: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
104910: LD_ADDR_VAR 0 1
104914: PUSH
104915: LD_INT 22
104917: PUSH
104918: LD_OWVAR 2
104922: PUSH
104923: EMPTY
104924: LIST
104925: LIST
104926: PUSH
104927: LD_INT 61
104929: PUSH
104930: EMPTY
104931: LIST
104932: PUSH
104933: LD_INT 33
104935: PUSH
104936: LD_INT 2
104938: PUSH
104939: EMPTY
104940: LIST
104941: LIST
104942: PUSH
104943: EMPTY
104944: LIST
104945: LIST
104946: LIST
104947: PPUSH
104948: CALL_OW 69
104952: ST_TO_ADDR
// if not tmp then
104953: LD_VAR 0 1
104957: NOT
104958: IFFALSE 104962
// exit ;
104960: GO 104999
// for i in tmp do
104962: LD_ADDR_VAR 0 2
104966: PUSH
104967: LD_VAR 0 1
104971: PUSH
104972: FOR_IN
104973: IFFALSE 104997
// if IsControledBy ( i ) then
104975: LD_VAR 0 2
104979: PPUSH
104980: CALL_OW 312
104984: IFFALSE 104995
// ComUnlink ( i ) ;
104986: LD_VAR 0 2
104990: PPUSH
104991: CALL_OW 136
104995: GO 104972
104997: POP
104998: POP
// end ;
104999: PPOPN 2
105001: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
105002: LD_EXP 79
105006: PUSH
105007: LD_EXP 110
105011: AND
105012: IFFALSE 105152
105014: GO 105016
105016: DISABLE
105017: LD_INT 0
105019: PPUSH
105020: PPUSH
// begin ToLua ( displayPowell(); ) ;
105021: LD_STRING displayPowell();
105023: PPUSH
105024: CALL_OW 559
// uc_side := 0 ;
105028: LD_ADDR_OWVAR 20
105032: PUSH
105033: LD_INT 0
105035: ST_TO_ADDR
// uc_nation := 2 ;
105036: LD_ADDR_OWVAR 21
105040: PUSH
105041: LD_INT 2
105043: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
105044: LD_ADDR_OWVAR 37
105048: PUSH
105049: LD_INT 14
105051: ST_TO_ADDR
// vc_engine := engine_siberite ;
105052: LD_ADDR_OWVAR 39
105056: PUSH
105057: LD_INT 3
105059: ST_TO_ADDR
// vc_control := control_apeman ;
105060: LD_ADDR_OWVAR 38
105064: PUSH
105065: LD_INT 5
105067: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
105068: LD_ADDR_OWVAR 40
105072: PUSH
105073: LD_INT 29
105075: ST_TO_ADDR
// un := CreateVehicle ;
105076: LD_ADDR_VAR 0 2
105080: PUSH
105081: CALL_OW 45
105085: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
105086: LD_VAR 0 2
105090: PPUSH
105091: LD_INT 1
105093: PPUSH
105094: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
105098: LD_INT 35
105100: PPUSH
105101: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
105105: LD_VAR 0 2
105109: PPUSH
105110: LD_INT 22
105112: PUSH
105113: LD_OWVAR 2
105117: PUSH
105118: EMPTY
105119: LIST
105120: LIST
105121: PPUSH
105122: CALL_OW 69
105126: PPUSH
105127: LD_VAR 0 2
105131: PPUSH
105132: CALL_OW 74
105136: PPUSH
105137: CALL_OW 115
// until IsDead ( un ) ;
105141: LD_VAR 0 2
105145: PPUSH
105146: CALL_OW 301
105150: IFFALSE 105098
// end ;
105152: PPOPN 2
105154: END
// every 0 0$1 trigger StreamModeActive and sStu do
105155: LD_EXP 79
105159: PUSH
105160: LD_EXP 118
105164: AND
105165: IFFALSE 105181
105167: GO 105169
105169: DISABLE
// begin ToLua ( displayStucuk(); ) ;
105170: LD_STRING displayStucuk();
105172: PPUSH
105173: CALL_OW 559
// ResetFog ;
105177: CALL_OW 335
// end ;
105181: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
105182: LD_EXP 79
105186: PUSH
105187: LD_EXP 111
105191: AND
105192: IFFALSE 105333
105194: GO 105196
105196: DISABLE
105197: LD_INT 0
105199: PPUSH
105200: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
105201: LD_ADDR_VAR 0 2
105205: PUSH
105206: LD_INT 22
105208: PUSH
105209: LD_OWVAR 2
105213: PUSH
105214: EMPTY
105215: LIST
105216: LIST
105217: PUSH
105218: LD_INT 21
105220: PUSH
105221: LD_INT 1
105223: PUSH
105224: EMPTY
105225: LIST
105226: LIST
105227: PUSH
105228: EMPTY
105229: LIST
105230: LIST
105231: PPUSH
105232: CALL_OW 69
105236: ST_TO_ADDR
// if not tmp then
105237: LD_VAR 0 2
105241: NOT
105242: IFFALSE 105246
// exit ;
105244: GO 105333
// un := tmp [ rand ( 1 , tmp ) ] ;
105246: LD_ADDR_VAR 0 1
105250: PUSH
105251: LD_VAR 0 2
105255: PUSH
105256: LD_INT 1
105258: PPUSH
105259: LD_VAR 0 2
105263: PPUSH
105264: CALL_OW 12
105268: ARRAY
105269: ST_TO_ADDR
// SetSide ( un , 0 ) ;
105270: LD_VAR 0 1
105274: PPUSH
105275: LD_INT 0
105277: PPUSH
105278: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
105282: LD_VAR 0 1
105286: PPUSH
105287: LD_OWVAR 3
105291: PUSH
105292: LD_VAR 0 1
105296: DIFF
105297: PPUSH
105298: LD_VAR 0 1
105302: PPUSH
105303: CALL_OW 74
105307: PPUSH
105308: CALL_OW 115
// wait ( 0 0$20 ) ;
105312: LD_INT 700
105314: PPUSH
105315: CALL_OW 67
// SetSide ( un , your_side ) ;
105319: LD_VAR 0 1
105323: PPUSH
105324: LD_OWVAR 2
105328: PPUSH
105329: CALL_OW 235
// end ;
105333: PPOPN 2
105335: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
105336: LD_EXP 79
105340: PUSH
105341: LD_EXP 112
105345: AND
105346: IFFALSE 105452
105348: GO 105350
105350: DISABLE
105351: LD_INT 0
105353: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
105354: LD_ADDR_VAR 0 1
105358: PUSH
105359: LD_INT 22
105361: PUSH
105362: LD_OWVAR 2
105366: PUSH
105367: EMPTY
105368: LIST
105369: LIST
105370: PUSH
105371: LD_INT 2
105373: PUSH
105374: LD_INT 30
105376: PUSH
105377: LD_INT 0
105379: PUSH
105380: EMPTY
105381: LIST
105382: LIST
105383: PUSH
105384: LD_INT 30
105386: PUSH
105387: LD_INT 1
105389: PUSH
105390: EMPTY
105391: LIST
105392: LIST
105393: PUSH
105394: EMPTY
105395: LIST
105396: LIST
105397: LIST
105398: PUSH
105399: EMPTY
105400: LIST
105401: LIST
105402: PPUSH
105403: CALL_OW 69
105407: ST_TO_ADDR
// if not depot then
105408: LD_VAR 0 1
105412: NOT
105413: IFFALSE 105417
// exit ;
105415: GO 105452
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
105417: LD_VAR 0 1
105421: PUSH
105422: LD_INT 1
105424: ARRAY
105425: PPUSH
105426: CALL_OW 250
105430: PPUSH
105431: LD_VAR 0 1
105435: PUSH
105436: LD_INT 1
105438: ARRAY
105439: PPUSH
105440: CALL_OW 251
105444: PPUSH
105445: LD_INT 70
105447: PPUSH
105448: CALL_OW 495
// end ;
105452: PPOPN 1
105454: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
105455: LD_EXP 79
105459: PUSH
105460: LD_EXP 113
105464: AND
105465: IFFALSE 105676
105467: GO 105469
105469: DISABLE
105470: LD_INT 0
105472: PPUSH
105473: PPUSH
105474: PPUSH
105475: PPUSH
105476: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
105477: LD_ADDR_VAR 0 5
105481: PUSH
105482: LD_INT 22
105484: PUSH
105485: LD_OWVAR 2
105489: PUSH
105490: EMPTY
105491: LIST
105492: LIST
105493: PUSH
105494: LD_INT 21
105496: PUSH
105497: LD_INT 1
105499: PUSH
105500: EMPTY
105501: LIST
105502: LIST
105503: PUSH
105504: EMPTY
105505: LIST
105506: LIST
105507: PPUSH
105508: CALL_OW 69
105512: ST_TO_ADDR
// if not tmp then
105513: LD_VAR 0 5
105517: NOT
105518: IFFALSE 105522
// exit ;
105520: GO 105676
// for i in tmp do
105522: LD_ADDR_VAR 0 1
105526: PUSH
105527: LD_VAR 0 5
105531: PUSH
105532: FOR_IN
105533: IFFALSE 105674
// begin d := rand ( 0 , 5 ) ;
105535: LD_ADDR_VAR 0 4
105539: PUSH
105540: LD_INT 0
105542: PPUSH
105543: LD_INT 5
105545: PPUSH
105546: CALL_OW 12
105550: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
105551: LD_ADDR_VAR 0 2
105555: PUSH
105556: LD_VAR 0 1
105560: PPUSH
105561: CALL_OW 250
105565: PPUSH
105566: LD_VAR 0 4
105570: PPUSH
105571: LD_INT 3
105573: PPUSH
105574: LD_INT 12
105576: PPUSH
105577: CALL_OW 12
105581: PPUSH
105582: CALL_OW 272
105586: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
105587: LD_ADDR_VAR 0 3
105591: PUSH
105592: LD_VAR 0 1
105596: PPUSH
105597: CALL_OW 251
105601: PPUSH
105602: LD_VAR 0 4
105606: PPUSH
105607: LD_INT 3
105609: PPUSH
105610: LD_INT 12
105612: PPUSH
105613: CALL_OW 12
105617: PPUSH
105618: CALL_OW 273
105622: ST_TO_ADDR
// if ValidHex ( x , y ) then
105623: LD_VAR 0 2
105627: PPUSH
105628: LD_VAR 0 3
105632: PPUSH
105633: CALL_OW 488
105637: IFFALSE 105672
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
105639: LD_VAR 0 1
105643: PPUSH
105644: LD_VAR 0 2
105648: PPUSH
105649: LD_VAR 0 3
105653: PPUSH
105654: LD_INT 3
105656: PPUSH
105657: LD_INT 6
105659: PPUSH
105660: CALL_OW 12
105664: PPUSH
105665: LD_INT 1
105667: PPUSH
105668: CALL_OW 483
// end ;
105672: GO 105532
105674: POP
105675: POP
// end ;
105676: PPOPN 5
105678: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
105679: LD_EXP 79
105683: PUSH
105684: LD_EXP 114
105688: AND
105689: IFFALSE 105783
105691: GO 105693
105693: DISABLE
105694: LD_INT 0
105696: PPUSH
105697: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
105698: LD_ADDR_VAR 0 2
105702: PUSH
105703: LD_INT 22
105705: PUSH
105706: LD_OWVAR 2
105710: PUSH
105711: EMPTY
105712: LIST
105713: LIST
105714: PUSH
105715: LD_INT 32
105717: PUSH
105718: LD_INT 1
105720: PUSH
105721: EMPTY
105722: LIST
105723: LIST
105724: PUSH
105725: LD_INT 21
105727: PUSH
105728: LD_INT 2
105730: PUSH
105731: EMPTY
105732: LIST
105733: LIST
105734: PUSH
105735: EMPTY
105736: LIST
105737: LIST
105738: LIST
105739: PPUSH
105740: CALL_OW 69
105744: ST_TO_ADDR
// if not tmp then
105745: LD_VAR 0 2
105749: NOT
105750: IFFALSE 105754
// exit ;
105752: GO 105783
// for i in tmp do
105754: LD_ADDR_VAR 0 1
105758: PUSH
105759: LD_VAR 0 2
105763: PUSH
105764: FOR_IN
105765: IFFALSE 105781
// SetFuel ( i , 0 ) ;
105767: LD_VAR 0 1
105771: PPUSH
105772: LD_INT 0
105774: PPUSH
105775: CALL_OW 240
105779: GO 105764
105781: POP
105782: POP
// end ;
105783: PPOPN 2
105785: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
105786: LD_EXP 79
105790: PUSH
105791: LD_EXP 115
105795: AND
105796: IFFALSE 105862
105798: GO 105800
105800: DISABLE
105801: LD_INT 0
105803: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
105804: LD_ADDR_VAR 0 1
105808: PUSH
105809: LD_INT 22
105811: PUSH
105812: LD_OWVAR 2
105816: PUSH
105817: EMPTY
105818: LIST
105819: LIST
105820: PUSH
105821: LD_INT 30
105823: PUSH
105824: LD_INT 29
105826: PUSH
105827: EMPTY
105828: LIST
105829: LIST
105830: PUSH
105831: EMPTY
105832: LIST
105833: LIST
105834: PPUSH
105835: CALL_OW 69
105839: ST_TO_ADDR
// if not tmp then
105840: LD_VAR 0 1
105844: NOT
105845: IFFALSE 105849
// exit ;
105847: GO 105862
// DestroyUnit ( tmp [ 1 ] ) ;
105849: LD_VAR 0 1
105853: PUSH
105854: LD_INT 1
105856: ARRAY
105857: PPUSH
105858: CALL_OW 65
// end ;
105862: PPOPN 1
105864: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
105865: LD_EXP 79
105869: PUSH
105870: LD_EXP 117
105874: AND
105875: IFFALSE 106004
105877: GO 105879
105879: DISABLE
105880: LD_INT 0
105882: PPUSH
// begin uc_side := 0 ;
105883: LD_ADDR_OWVAR 20
105887: PUSH
105888: LD_INT 0
105890: ST_TO_ADDR
// uc_nation := nation_arabian ;
105891: LD_ADDR_OWVAR 21
105895: PUSH
105896: LD_INT 2
105898: ST_TO_ADDR
// hc_gallery :=  ;
105899: LD_ADDR_OWVAR 33
105903: PUSH
105904: LD_STRING 
105906: ST_TO_ADDR
// hc_name :=  ;
105907: LD_ADDR_OWVAR 26
105911: PUSH
105912: LD_STRING 
105914: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
105915: LD_INT 1
105917: PPUSH
105918: LD_INT 11
105920: PPUSH
105921: LD_INT 10
105923: PPUSH
105924: CALL_OW 380
// un := CreateHuman ;
105928: LD_ADDR_VAR 0 1
105932: PUSH
105933: CALL_OW 44
105937: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
105938: LD_VAR 0 1
105942: PPUSH
105943: LD_INT 1
105945: PPUSH
105946: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
105950: LD_INT 35
105952: PPUSH
105953: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
105957: LD_VAR 0 1
105961: PPUSH
105962: LD_INT 22
105964: PUSH
105965: LD_OWVAR 2
105969: PUSH
105970: EMPTY
105971: LIST
105972: LIST
105973: PPUSH
105974: CALL_OW 69
105978: PPUSH
105979: LD_VAR 0 1
105983: PPUSH
105984: CALL_OW 74
105988: PPUSH
105989: CALL_OW 115
// until IsDead ( un ) ;
105993: LD_VAR 0 1
105997: PPUSH
105998: CALL_OW 301
106002: IFFALSE 105950
// end ;
106004: PPOPN 1
106006: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
106007: LD_EXP 79
106011: PUSH
106012: LD_EXP 119
106016: AND
106017: IFFALSE 106029
106019: GO 106021
106021: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
106022: LD_STRING earthquake(getX(game), 0, 32)
106024: PPUSH
106025: CALL_OW 559
106029: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
106030: LD_EXP 79
106034: PUSH
106035: LD_EXP 120
106039: AND
106040: IFFALSE 106131
106042: GO 106044
106044: DISABLE
106045: LD_INT 0
106047: PPUSH
// begin enable ;
106048: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
106049: LD_ADDR_VAR 0 1
106053: PUSH
106054: LD_INT 22
106056: PUSH
106057: LD_OWVAR 2
106061: PUSH
106062: EMPTY
106063: LIST
106064: LIST
106065: PUSH
106066: LD_INT 21
106068: PUSH
106069: LD_INT 2
106071: PUSH
106072: EMPTY
106073: LIST
106074: LIST
106075: PUSH
106076: LD_INT 33
106078: PUSH
106079: LD_INT 3
106081: PUSH
106082: EMPTY
106083: LIST
106084: LIST
106085: PUSH
106086: EMPTY
106087: LIST
106088: LIST
106089: LIST
106090: PPUSH
106091: CALL_OW 69
106095: ST_TO_ADDR
// if not tmp then
106096: LD_VAR 0 1
106100: NOT
106101: IFFALSE 106105
// exit ;
106103: GO 106131
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
106105: LD_VAR 0 1
106109: PUSH
106110: LD_INT 1
106112: PPUSH
106113: LD_VAR 0 1
106117: PPUSH
106118: CALL_OW 12
106122: ARRAY
106123: PPUSH
106124: LD_INT 1
106126: PPUSH
106127: CALL_OW 234
// end ;
106131: PPOPN 1
106133: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
106134: LD_EXP 79
106138: PUSH
106139: LD_EXP 121
106143: AND
106144: IFFALSE 106285
106146: GO 106148
106148: DISABLE
106149: LD_INT 0
106151: PPUSH
106152: PPUSH
106153: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
106154: LD_ADDR_VAR 0 3
106158: PUSH
106159: LD_INT 22
106161: PUSH
106162: LD_OWVAR 2
106166: PUSH
106167: EMPTY
106168: LIST
106169: LIST
106170: PUSH
106171: LD_INT 25
106173: PUSH
106174: LD_INT 1
106176: PUSH
106177: EMPTY
106178: LIST
106179: LIST
106180: PUSH
106181: EMPTY
106182: LIST
106183: LIST
106184: PPUSH
106185: CALL_OW 69
106189: ST_TO_ADDR
// if not tmp then
106190: LD_VAR 0 3
106194: NOT
106195: IFFALSE 106199
// exit ;
106197: GO 106285
// un := tmp [ rand ( 1 , tmp ) ] ;
106199: LD_ADDR_VAR 0 2
106203: PUSH
106204: LD_VAR 0 3
106208: PUSH
106209: LD_INT 1
106211: PPUSH
106212: LD_VAR 0 3
106216: PPUSH
106217: CALL_OW 12
106221: ARRAY
106222: ST_TO_ADDR
// if Crawls ( un ) then
106223: LD_VAR 0 2
106227: PPUSH
106228: CALL_OW 318
106232: IFFALSE 106243
// ComWalk ( un ) ;
106234: LD_VAR 0 2
106238: PPUSH
106239: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
106243: LD_VAR 0 2
106247: PPUSH
106248: LD_INT 9
106250: PPUSH
106251: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
106255: LD_INT 28
106257: PPUSH
106258: LD_OWVAR 2
106262: PPUSH
106263: LD_INT 2
106265: PPUSH
106266: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
106270: LD_INT 29
106272: PPUSH
106273: LD_OWVAR 2
106277: PPUSH
106278: LD_INT 2
106280: PPUSH
106281: CALL_OW 322
// end ;
106285: PPOPN 3
106287: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
106288: LD_EXP 79
106292: PUSH
106293: LD_EXP 122
106297: AND
106298: IFFALSE 106409
106300: GO 106302
106302: DISABLE
106303: LD_INT 0
106305: PPUSH
106306: PPUSH
106307: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
106308: LD_ADDR_VAR 0 3
106312: PUSH
106313: LD_INT 22
106315: PUSH
106316: LD_OWVAR 2
106320: PUSH
106321: EMPTY
106322: LIST
106323: LIST
106324: PUSH
106325: LD_INT 25
106327: PUSH
106328: LD_INT 1
106330: PUSH
106331: EMPTY
106332: LIST
106333: LIST
106334: PUSH
106335: EMPTY
106336: LIST
106337: LIST
106338: PPUSH
106339: CALL_OW 69
106343: ST_TO_ADDR
// if not tmp then
106344: LD_VAR 0 3
106348: NOT
106349: IFFALSE 106353
// exit ;
106351: GO 106409
// un := tmp [ rand ( 1 , tmp ) ] ;
106353: LD_ADDR_VAR 0 2
106357: PUSH
106358: LD_VAR 0 3
106362: PUSH
106363: LD_INT 1
106365: PPUSH
106366: LD_VAR 0 3
106370: PPUSH
106371: CALL_OW 12
106375: ARRAY
106376: ST_TO_ADDR
// if Crawls ( un ) then
106377: LD_VAR 0 2
106381: PPUSH
106382: CALL_OW 318
106386: IFFALSE 106397
// ComWalk ( un ) ;
106388: LD_VAR 0 2
106392: PPUSH
106393: CALL_OW 138
// SetClass ( un , class_mortar ) ;
106397: LD_VAR 0 2
106401: PPUSH
106402: LD_INT 8
106404: PPUSH
106405: CALL_OW 336
// end ;
106409: PPOPN 3
106411: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
106412: LD_EXP 79
106416: PUSH
106417: LD_EXP 123
106421: AND
106422: IFFALSE 106566
106424: GO 106426
106426: DISABLE
106427: LD_INT 0
106429: PPUSH
106430: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
106431: LD_ADDR_VAR 0 2
106435: PUSH
106436: LD_INT 22
106438: PUSH
106439: LD_OWVAR 2
106443: PUSH
106444: EMPTY
106445: LIST
106446: LIST
106447: PUSH
106448: LD_INT 21
106450: PUSH
106451: LD_INT 2
106453: PUSH
106454: EMPTY
106455: LIST
106456: LIST
106457: PUSH
106458: LD_INT 2
106460: PUSH
106461: LD_INT 34
106463: PUSH
106464: LD_INT 12
106466: PUSH
106467: EMPTY
106468: LIST
106469: LIST
106470: PUSH
106471: LD_INT 34
106473: PUSH
106474: LD_INT 51
106476: PUSH
106477: EMPTY
106478: LIST
106479: LIST
106480: PUSH
106481: LD_INT 34
106483: PUSH
106484: LD_INT 32
106486: PUSH
106487: EMPTY
106488: LIST
106489: LIST
106490: PUSH
106491: EMPTY
106492: LIST
106493: LIST
106494: LIST
106495: LIST
106496: PUSH
106497: EMPTY
106498: LIST
106499: LIST
106500: LIST
106501: PPUSH
106502: CALL_OW 69
106506: ST_TO_ADDR
// if not tmp then
106507: LD_VAR 0 2
106511: NOT
106512: IFFALSE 106516
// exit ;
106514: GO 106566
// for i in tmp do
106516: LD_ADDR_VAR 0 1
106520: PUSH
106521: LD_VAR 0 2
106525: PUSH
106526: FOR_IN
106527: IFFALSE 106564
// if GetCargo ( i , mat_artifact ) = 0 then
106529: LD_VAR 0 1
106533: PPUSH
106534: LD_INT 4
106536: PPUSH
106537: CALL_OW 289
106541: PUSH
106542: LD_INT 0
106544: EQUAL
106545: IFFALSE 106562
// SetCargo ( i , mat_siberit , 100 ) ;
106547: LD_VAR 0 1
106551: PPUSH
106552: LD_INT 3
106554: PPUSH
106555: LD_INT 100
106557: PPUSH
106558: CALL_OW 290
106562: GO 106526
106564: POP
106565: POP
// end ;
106566: PPOPN 2
106568: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
106569: LD_EXP 79
106573: PUSH
106574: LD_EXP 124
106578: AND
106579: IFFALSE 106762
106581: GO 106583
106583: DISABLE
106584: LD_INT 0
106586: PPUSH
106587: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
106588: LD_ADDR_VAR 0 2
106592: PUSH
106593: LD_INT 22
106595: PUSH
106596: LD_OWVAR 2
106600: PUSH
106601: EMPTY
106602: LIST
106603: LIST
106604: PPUSH
106605: CALL_OW 69
106609: ST_TO_ADDR
// if not tmp then
106610: LD_VAR 0 2
106614: NOT
106615: IFFALSE 106619
// exit ;
106617: GO 106762
// for i := 1 to 2 do
106619: LD_ADDR_VAR 0 1
106623: PUSH
106624: DOUBLE
106625: LD_INT 1
106627: DEC
106628: ST_TO_ADDR
106629: LD_INT 2
106631: PUSH
106632: FOR_TO
106633: IFFALSE 106760
// begin uc_side := your_side ;
106635: LD_ADDR_OWVAR 20
106639: PUSH
106640: LD_OWVAR 2
106644: ST_TO_ADDR
// uc_nation := nation_american ;
106645: LD_ADDR_OWVAR 21
106649: PUSH
106650: LD_INT 1
106652: ST_TO_ADDR
// vc_chassis := us_morphling ;
106653: LD_ADDR_OWVAR 37
106657: PUSH
106658: LD_INT 5
106660: ST_TO_ADDR
// vc_engine := engine_siberite ;
106661: LD_ADDR_OWVAR 39
106665: PUSH
106666: LD_INT 3
106668: ST_TO_ADDR
// vc_control := control_computer ;
106669: LD_ADDR_OWVAR 38
106673: PUSH
106674: LD_INT 3
106676: ST_TO_ADDR
// vc_weapon := us_double_laser ;
106677: LD_ADDR_OWVAR 40
106681: PUSH
106682: LD_INT 10
106684: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
106685: LD_VAR 0 2
106689: PUSH
106690: LD_INT 1
106692: ARRAY
106693: PPUSH
106694: CALL_OW 310
106698: NOT
106699: IFFALSE 106746
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
106701: CALL_OW 45
106705: PPUSH
106706: LD_VAR 0 2
106710: PUSH
106711: LD_INT 1
106713: ARRAY
106714: PPUSH
106715: CALL_OW 250
106719: PPUSH
106720: LD_VAR 0 2
106724: PUSH
106725: LD_INT 1
106727: ARRAY
106728: PPUSH
106729: CALL_OW 251
106733: PPUSH
106734: LD_INT 12
106736: PPUSH
106737: LD_INT 1
106739: PPUSH
106740: CALL_OW 50
106744: GO 106758
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
106746: CALL_OW 45
106750: PPUSH
106751: LD_INT 1
106753: PPUSH
106754: CALL_OW 51
// end ;
106758: GO 106632
106760: POP
106761: POP
// end ;
106762: PPOPN 2
106764: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
106765: LD_EXP 79
106769: PUSH
106770: LD_EXP 125
106774: AND
106775: IFFALSE 106997
106777: GO 106779
106779: DISABLE
106780: LD_INT 0
106782: PPUSH
106783: PPUSH
106784: PPUSH
106785: PPUSH
106786: PPUSH
106787: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
106788: LD_ADDR_VAR 0 6
106792: PUSH
106793: LD_INT 22
106795: PUSH
106796: LD_OWVAR 2
106800: PUSH
106801: EMPTY
106802: LIST
106803: LIST
106804: PUSH
106805: LD_INT 21
106807: PUSH
106808: LD_INT 1
106810: PUSH
106811: EMPTY
106812: LIST
106813: LIST
106814: PUSH
106815: LD_INT 3
106817: PUSH
106818: LD_INT 23
106820: PUSH
106821: LD_INT 0
106823: PUSH
106824: EMPTY
106825: LIST
106826: LIST
106827: PUSH
106828: EMPTY
106829: LIST
106830: LIST
106831: PUSH
106832: EMPTY
106833: LIST
106834: LIST
106835: LIST
106836: PPUSH
106837: CALL_OW 69
106841: ST_TO_ADDR
// if not tmp then
106842: LD_VAR 0 6
106846: NOT
106847: IFFALSE 106851
// exit ;
106849: GO 106997
// s1 := rand ( 1 , 4 ) ;
106851: LD_ADDR_VAR 0 2
106855: PUSH
106856: LD_INT 1
106858: PPUSH
106859: LD_INT 4
106861: PPUSH
106862: CALL_OW 12
106866: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
106867: LD_ADDR_VAR 0 4
106871: PUSH
106872: LD_VAR 0 6
106876: PUSH
106877: LD_INT 1
106879: ARRAY
106880: PPUSH
106881: LD_VAR 0 2
106885: PPUSH
106886: CALL_OW 259
106890: ST_TO_ADDR
// if s1 = 1 then
106891: LD_VAR 0 2
106895: PUSH
106896: LD_INT 1
106898: EQUAL
106899: IFFALSE 106919
// s2 := rand ( 2 , 4 ) else
106901: LD_ADDR_VAR 0 3
106905: PUSH
106906: LD_INT 2
106908: PPUSH
106909: LD_INT 4
106911: PPUSH
106912: CALL_OW 12
106916: ST_TO_ADDR
106917: GO 106927
// s2 := 1 ;
106919: LD_ADDR_VAR 0 3
106923: PUSH
106924: LD_INT 1
106926: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
106927: LD_ADDR_VAR 0 5
106931: PUSH
106932: LD_VAR 0 6
106936: PUSH
106937: LD_INT 1
106939: ARRAY
106940: PPUSH
106941: LD_VAR 0 3
106945: PPUSH
106946: CALL_OW 259
106950: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
106951: LD_VAR 0 6
106955: PUSH
106956: LD_INT 1
106958: ARRAY
106959: PPUSH
106960: LD_VAR 0 2
106964: PPUSH
106965: LD_VAR 0 5
106969: PPUSH
106970: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
106974: LD_VAR 0 6
106978: PUSH
106979: LD_INT 1
106981: ARRAY
106982: PPUSH
106983: LD_VAR 0 3
106987: PPUSH
106988: LD_VAR 0 4
106992: PPUSH
106993: CALL_OW 237
// end ;
106997: PPOPN 6
106999: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
107000: LD_EXP 79
107004: PUSH
107005: LD_EXP 126
107009: AND
107010: IFFALSE 107089
107012: GO 107014
107014: DISABLE
107015: LD_INT 0
107017: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
107018: LD_ADDR_VAR 0 1
107022: PUSH
107023: LD_INT 22
107025: PUSH
107026: LD_OWVAR 2
107030: PUSH
107031: EMPTY
107032: LIST
107033: LIST
107034: PUSH
107035: LD_INT 30
107037: PUSH
107038: LD_INT 3
107040: PUSH
107041: EMPTY
107042: LIST
107043: LIST
107044: PUSH
107045: EMPTY
107046: LIST
107047: LIST
107048: PPUSH
107049: CALL_OW 69
107053: ST_TO_ADDR
// if not tmp then
107054: LD_VAR 0 1
107058: NOT
107059: IFFALSE 107063
// exit ;
107061: GO 107089
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
107063: LD_VAR 0 1
107067: PUSH
107068: LD_INT 1
107070: PPUSH
107071: LD_VAR 0 1
107075: PPUSH
107076: CALL_OW 12
107080: ARRAY
107081: PPUSH
107082: LD_INT 1
107084: PPUSH
107085: CALL_OW 234
// end ;
107089: PPOPN 1
107091: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
107092: LD_EXP 79
107096: PUSH
107097: LD_EXP 127
107101: AND
107102: IFFALSE 107214
107104: GO 107106
107106: DISABLE
107107: LD_INT 0
107109: PPUSH
107110: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
107111: LD_ADDR_VAR 0 2
107115: PUSH
107116: LD_INT 22
107118: PUSH
107119: LD_OWVAR 2
107123: PUSH
107124: EMPTY
107125: LIST
107126: LIST
107127: PUSH
107128: LD_INT 2
107130: PUSH
107131: LD_INT 30
107133: PUSH
107134: LD_INT 27
107136: PUSH
107137: EMPTY
107138: LIST
107139: LIST
107140: PUSH
107141: LD_INT 30
107143: PUSH
107144: LD_INT 26
107146: PUSH
107147: EMPTY
107148: LIST
107149: LIST
107150: PUSH
107151: LD_INT 30
107153: PUSH
107154: LD_INT 28
107156: PUSH
107157: EMPTY
107158: LIST
107159: LIST
107160: PUSH
107161: EMPTY
107162: LIST
107163: LIST
107164: LIST
107165: LIST
107166: PUSH
107167: EMPTY
107168: LIST
107169: LIST
107170: PPUSH
107171: CALL_OW 69
107175: ST_TO_ADDR
// if not tmp then
107176: LD_VAR 0 2
107180: NOT
107181: IFFALSE 107185
// exit ;
107183: GO 107214
// for i in tmp do
107185: LD_ADDR_VAR 0 1
107189: PUSH
107190: LD_VAR 0 2
107194: PUSH
107195: FOR_IN
107196: IFFALSE 107212
// SetLives ( i , 1 ) ;
107198: LD_VAR 0 1
107202: PPUSH
107203: LD_INT 1
107205: PPUSH
107206: CALL_OW 234
107210: GO 107195
107212: POP
107213: POP
// end ;
107214: PPOPN 2
107216: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
107217: LD_EXP 79
107221: PUSH
107222: LD_EXP 128
107226: AND
107227: IFFALSE 107514
107229: GO 107231
107231: DISABLE
107232: LD_INT 0
107234: PPUSH
107235: PPUSH
107236: PPUSH
// begin i := rand ( 1 , 7 ) ;
107237: LD_ADDR_VAR 0 1
107241: PUSH
107242: LD_INT 1
107244: PPUSH
107245: LD_INT 7
107247: PPUSH
107248: CALL_OW 12
107252: ST_TO_ADDR
// case i of 1 :
107253: LD_VAR 0 1
107257: PUSH
107258: LD_INT 1
107260: DOUBLE
107261: EQUAL
107262: IFTRUE 107266
107264: GO 107276
107266: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
107267: LD_STRING earthquake(getX(game), 0, 32)
107269: PPUSH
107270: CALL_OW 559
107274: GO 107514
107276: LD_INT 2
107278: DOUBLE
107279: EQUAL
107280: IFTRUE 107284
107282: GO 107298
107284: POP
// begin ToLua ( displayStucuk(); ) ;
107285: LD_STRING displayStucuk();
107287: PPUSH
107288: CALL_OW 559
// ResetFog ;
107292: CALL_OW 335
// end ; 3 :
107296: GO 107514
107298: LD_INT 3
107300: DOUBLE
107301: EQUAL
107302: IFTRUE 107306
107304: GO 107410
107306: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
107307: LD_ADDR_VAR 0 2
107311: PUSH
107312: LD_INT 22
107314: PUSH
107315: LD_OWVAR 2
107319: PUSH
107320: EMPTY
107321: LIST
107322: LIST
107323: PUSH
107324: LD_INT 25
107326: PUSH
107327: LD_INT 1
107329: PUSH
107330: EMPTY
107331: LIST
107332: LIST
107333: PUSH
107334: EMPTY
107335: LIST
107336: LIST
107337: PPUSH
107338: CALL_OW 69
107342: ST_TO_ADDR
// if not tmp then
107343: LD_VAR 0 2
107347: NOT
107348: IFFALSE 107352
// exit ;
107350: GO 107514
// un := tmp [ rand ( 1 , tmp ) ] ;
107352: LD_ADDR_VAR 0 3
107356: PUSH
107357: LD_VAR 0 2
107361: PUSH
107362: LD_INT 1
107364: PPUSH
107365: LD_VAR 0 2
107369: PPUSH
107370: CALL_OW 12
107374: ARRAY
107375: ST_TO_ADDR
// if Crawls ( un ) then
107376: LD_VAR 0 3
107380: PPUSH
107381: CALL_OW 318
107385: IFFALSE 107396
// ComWalk ( un ) ;
107387: LD_VAR 0 3
107391: PPUSH
107392: CALL_OW 138
// SetClass ( un , class_mortar ) ;
107396: LD_VAR 0 3
107400: PPUSH
107401: LD_INT 8
107403: PPUSH
107404: CALL_OW 336
// end ; 4 :
107408: GO 107514
107410: LD_INT 4
107412: DOUBLE
107413: EQUAL
107414: IFTRUE 107418
107416: GO 107492
107418: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
107419: LD_ADDR_VAR 0 2
107423: PUSH
107424: LD_INT 22
107426: PUSH
107427: LD_OWVAR 2
107431: PUSH
107432: EMPTY
107433: LIST
107434: LIST
107435: PUSH
107436: LD_INT 30
107438: PUSH
107439: LD_INT 29
107441: PUSH
107442: EMPTY
107443: LIST
107444: LIST
107445: PUSH
107446: EMPTY
107447: LIST
107448: LIST
107449: PPUSH
107450: CALL_OW 69
107454: ST_TO_ADDR
// if not tmp then
107455: LD_VAR 0 2
107459: NOT
107460: IFFALSE 107464
// exit ;
107462: GO 107514
// CenterNowOnUnits ( tmp [ 1 ] ) ;
107464: LD_VAR 0 2
107468: PUSH
107469: LD_INT 1
107471: ARRAY
107472: PPUSH
107473: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
107477: LD_VAR 0 2
107481: PUSH
107482: LD_INT 1
107484: ARRAY
107485: PPUSH
107486: CALL_OW 65
// end ; 5 .. 7 :
107490: GO 107514
107492: LD_INT 5
107494: DOUBLE
107495: GREATEREQUAL
107496: IFFALSE 107504
107498: LD_INT 7
107500: DOUBLE
107501: LESSEQUAL
107502: IFTRUE 107506
107504: GO 107513
107506: POP
// StreamSibBomb ; end ;
107507: CALL 103751 0 0
107511: GO 107514
107513: POP
// end ;
107514: PPOPN 3
107516: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
107517: LD_EXP 79
107521: PUSH
107522: LD_EXP 129
107526: AND
107527: IFFALSE 107683
107529: GO 107531
107531: DISABLE
107532: LD_INT 0
107534: PPUSH
107535: PPUSH
107536: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
107537: LD_ADDR_VAR 0 2
107541: PUSH
107542: LD_INT 81
107544: PUSH
107545: LD_OWVAR 2
107549: PUSH
107550: EMPTY
107551: LIST
107552: LIST
107553: PUSH
107554: LD_INT 2
107556: PUSH
107557: LD_INT 21
107559: PUSH
107560: LD_INT 1
107562: PUSH
107563: EMPTY
107564: LIST
107565: LIST
107566: PUSH
107567: LD_INT 21
107569: PUSH
107570: LD_INT 2
107572: PUSH
107573: EMPTY
107574: LIST
107575: LIST
107576: PUSH
107577: EMPTY
107578: LIST
107579: LIST
107580: LIST
107581: PUSH
107582: EMPTY
107583: LIST
107584: LIST
107585: PPUSH
107586: CALL_OW 69
107590: ST_TO_ADDR
// if not tmp then
107591: LD_VAR 0 2
107595: NOT
107596: IFFALSE 107600
// exit ;
107598: GO 107683
// p := 0 ;
107600: LD_ADDR_VAR 0 3
107604: PUSH
107605: LD_INT 0
107607: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
107608: LD_INT 35
107610: PPUSH
107611: CALL_OW 67
// p := p + 1 ;
107615: LD_ADDR_VAR 0 3
107619: PUSH
107620: LD_VAR 0 3
107624: PUSH
107625: LD_INT 1
107627: PLUS
107628: ST_TO_ADDR
// for i in tmp do
107629: LD_ADDR_VAR 0 1
107633: PUSH
107634: LD_VAR 0 2
107638: PUSH
107639: FOR_IN
107640: IFFALSE 107671
// if GetLives ( i ) < 1000 then
107642: LD_VAR 0 1
107646: PPUSH
107647: CALL_OW 256
107651: PUSH
107652: LD_INT 1000
107654: LESS
107655: IFFALSE 107669
// SetLives ( i , 1000 ) ;
107657: LD_VAR 0 1
107661: PPUSH
107662: LD_INT 1000
107664: PPUSH
107665: CALL_OW 234
107669: GO 107639
107671: POP
107672: POP
// until p > 20 ;
107673: LD_VAR 0 3
107677: PUSH
107678: LD_INT 20
107680: GREATER
107681: IFFALSE 107608
// end ;
107683: PPOPN 3
107685: END
// every 0 0$1 trigger StreamModeActive and sTime do
107686: LD_EXP 79
107690: PUSH
107691: LD_EXP 130
107695: AND
107696: IFFALSE 107731
107698: GO 107700
107700: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
107701: LD_INT 28
107703: PPUSH
107704: LD_OWVAR 2
107708: PPUSH
107709: LD_INT 2
107711: PPUSH
107712: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
107716: LD_INT 30
107718: PPUSH
107719: LD_OWVAR 2
107723: PPUSH
107724: LD_INT 2
107726: PPUSH
107727: CALL_OW 322
// end ;
107731: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
107732: LD_EXP 79
107736: PUSH
107737: LD_EXP 131
107741: AND
107742: IFFALSE 107863
107744: GO 107746
107746: DISABLE
107747: LD_INT 0
107749: PPUSH
107750: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
107751: LD_ADDR_VAR 0 2
107755: PUSH
107756: LD_INT 22
107758: PUSH
107759: LD_OWVAR 2
107763: PUSH
107764: EMPTY
107765: LIST
107766: LIST
107767: PUSH
107768: LD_INT 21
107770: PUSH
107771: LD_INT 1
107773: PUSH
107774: EMPTY
107775: LIST
107776: LIST
107777: PUSH
107778: LD_INT 3
107780: PUSH
107781: LD_INT 23
107783: PUSH
107784: LD_INT 0
107786: PUSH
107787: EMPTY
107788: LIST
107789: LIST
107790: PUSH
107791: EMPTY
107792: LIST
107793: LIST
107794: PUSH
107795: EMPTY
107796: LIST
107797: LIST
107798: LIST
107799: PPUSH
107800: CALL_OW 69
107804: ST_TO_ADDR
// if not tmp then
107805: LD_VAR 0 2
107809: NOT
107810: IFFALSE 107814
// exit ;
107812: GO 107863
// for i in tmp do
107814: LD_ADDR_VAR 0 1
107818: PUSH
107819: LD_VAR 0 2
107823: PUSH
107824: FOR_IN
107825: IFFALSE 107861
// begin if Crawls ( i ) then
107827: LD_VAR 0 1
107831: PPUSH
107832: CALL_OW 318
107836: IFFALSE 107847
// ComWalk ( i ) ;
107838: LD_VAR 0 1
107842: PPUSH
107843: CALL_OW 138
// SetClass ( i , 2 ) ;
107847: LD_VAR 0 1
107851: PPUSH
107852: LD_INT 2
107854: PPUSH
107855: CALL_OW 336
// end ;
107859: GO 107824
107861: POP
107862: POP
// end ;
107863: PPOPN 2
107865: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
107866: LD_EXP 79
107870: PUSH
107871: LD_EXP 132
107875: AND
107876: IFFALSE 108164
107878: GO 107880
107880: DISABLE
107881: LD_INT 0
107883: PPUSH
107884: PPUSH
107885: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
107886: LD_OWVAR 2
107890: PPUSH
107891: LD_INT 9
107893: PPUSH
107894: LD_INT 1
107896: PPUSH
107897: LD_INT 1
107899: PPUSH
107900: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
107904: LD_INT 9
107906: PPUSH
107907: LD_OWVAR 2
107911: PPUSH
107912: CALL_OW 343
// uc_side := 9 ;
107916: LD_ADDR_OWVAR 20
107920: PUSH
107921: LD_INT 9
107923: ST_TO_ADDR
// uc_nation := 2 ;
107924: LD_ADDR_OWVAR 21
107928: PUSH
107929: LD_INT 2
107931: ST_TO_ADDR
// hc_name := Dark Warrior ;
107932: LD_ADDR_OWVAR 26
107936: PUSH
107937: LD_STRING Dark Warrior
107939: ST_TO_ADDR
// hc_gallery :=  ;
107940: LD_ADDR_OWVAR 33
107944: PUSH
107945: LD_STRING 
107947: ST_TO_ADDR
// hc_noskilllimit := true ;
107948: LD_ADDR_OWVAR 76
107952: PUSH
107953: LD_INT 1
107955: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
107956: LD_ADDR_OWVAR 31
107960: PUSH
107961: LD_INT 30
107963: PUSH
107964: LD_INT 30
107966: PUSH
107967: LD_INT 30
107969: PUSH
107970: LD_INT 30
107972: PUSH
107973: EMPTY
107974: LIST
107975: LIST
107976: LIST
107977: LIST
107978: ST_TO_ADDR
// un := CreateHuman ;
107979: LD_ADDR_VAR 0 3
107983: PUSH
107984: CALL_OW 44
107988: ST_TO_ADDR
// hc_noskilllimit := false ;
107989: LD_ADDR_OWVAR 76
107993: PUSH
107994: LD_INT 0
107996: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
107997: LD_VAR 0 3
108001: PPUSH
108002: LD_INT 1
108004: PPUSH
108005: CALL_OW 51
// ToLua ( playRanger() ) ;
108009: LD_STRING playRanger()
108011: PPUSH
108012: CALL_OW 559
// p := 0 ;
108016: LD_ADDR_VAR 0 2
108020: PUSH
108021: LD_INT 0
108023: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
108024: LD_INT 35
108026: PPUSH
108027: CALL_OW 67
// p := p + 1 ;
108031: LD_ADDR_VAR 0 2
108035: PUSH
108036: LD_VAR 0 2
108040: PUSH
108041: LD_INT 1
108043: PLUS
108044: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
108045: LD_VAR 0 3
108049: PPUSH
108050: CALL_OW 256
108054: PUSH
108055: LD_INT 1000
108057: LESS
108058: IFFALSE 108072
// SetLives ( un , 1000 ) ;
108060: LD_VAR 0 3
108064: PPUSH
108065: LD_INT 1000
108067: PPUSH
108068: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
108072: LD_VAR 0 3
108076: PPUSH
108077: LD_INT 81
108079: PUSH
108080: LD_OWVAR 2
108084: PUSH
108085: EMPTY
108086: LIST
108087: LIST
108088: PUSH
108089: LD_INT 91
108091: PUSH
108092: LD_VAR 0 3
108096: PUSH
108097: LD_INT 30
108099: PUSH
108100: EMPTY
108101: LIST
108102: LIST
108103: LIST
108104: PUSH
108105: EMPTY
108106: LIST
108107: LIST
108108: PPUSH
108109: CALL_OW 69
108113: PPUSH
108114: LD_VAR 0 3
108118: PPUSH
108119: CALL_OW 74
108123: PPUSH
108124: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
108128: LD_VAR 0 2
108132: PUSH
108133: LD_INT 80
108135: GREATER
108136: PUSH
108137: LD_VAR 0 3
108141: PPUSH
108142: CALL_OW 301
108146: OR
108147: IFFALSE 108024
// if un then
108149: LD_VAR 0 3
108153: IFFALSE 108164
// RemoveUnit ( un ) ;
108155: LD_VAR 0 3
108159: PPUSH
108160: CALL_OW 64
// end ;
108164: PPOPN 3
108166: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
108167: LD_EXP 133
108171: IFFALSE 108287
108173: GO 108175
108175: DISABLE
108176: LD_INT 0
108178: PPUSH
108179: PPUSH
108180: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
108181: LD_ADDR_VAR 0 2
108185: PUSH
108186: LD_INT 81
108188: PUSH
108189: LD_OWVAR 2
108193: PUSH
108194: EMPTY
108195: LIST
108196: LIST
108197: PUSH
108198: LD_INT 21
108200: PUSH
108201: LD_INT 1
108203: PUSH
108204: EMPTY
108205: LIST
108206: LIST
108207: PUSH
108208: EMPTY
108209: LIST
108210: LIST
108211: PPUSH
108212: CALL_OW 69
108216: ST_TO_ADDR
// ToLua ( playComputer() ) ;
108217: LD_STRING playComputer()
108219: PPUSH
108220: CALL_OW 559
// if not tmp then
108224: LD_VAR 0 2
108228: NOT
108229: IFFALSE 108233
// exit ;
108231: GO 108287
// for i in tmp do
108233: LD_ADDR_VAR 0 1
108237: PUSH
108238: LD_VAR 0 2
108242: PUSH
108243: FOR_IN
108244: IFFALSE 108285
// for j := 1 to 4 do
108246: LD_ADDR_VAR 0 3
108250: PUSH
108251: DOUBLE
108252: LD_INT 1
108254: DEC
108255: ST_TO_ADDR
108256: LD_INT 4
108258: PUSH
108259: FOR_TO
108260: IFFALSE 108281
// SetSkill ( i , j , 10 ) ;
108262: LD_VAR 0 1
108266: PPUSH
108267: LD_VAR 0 3
108271: PPUSH
108272: LD_INT 10
108274: PPUSH
108275: CALL_OW 237
108279: GO 108259
108281: POP
108282: POP
108283: GO 108243
108285: POP
108286: POP
// end ;
108287: PPOPN 3
108289: END
// every 0 0$1 trigger s30 do var i , tmp ;
108290: LD_EXP 134
108294: IFFALSE 108363
108296: GO 108298
108298: DISABLE
108299: LD_INT 0
108301: PPUSH
108302: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
108303: LD_ADDR_VAR 0 2
108307: PUSH
108308: LD_INT 22
108310: PUSH
108311: LD_OWVAR 2
108315: PUSH
108316: EMPTY
108317: LIST
108318: LIST
108319: PPUSH
108320: CALL_OW 69
108324: ST_TO_ADDR
// if not tmp then
108325: LD_VAR 0 2
108329: NOT
108330: IFFALSE 108334
// exit ;
108332: GO 108363
// for i in tmp do
108334: LD_ADDR_VAR 0 1
108338: PUSH
108339: LD_VAR 0 2
108343: PUSH
108344: FOR_IN
108345: IFFALSE 108361
// SetLives ( i , 300 ) ;
108347: LD_VAR 0 1
108351: PPUSH
108352: LD_INT 300
108354: PPUSH
108355: CALL_OW 234
108359: GO 108344
108361: POP
108362: POP
// end ;
108363: PPOPN 2
108365: END
// every 0 0$1 trigger s60 do var i , tmp ;
108366: LD_EXP 135
108370: IFFALSE 108439
108372: GO 108374
108374: DISABLE
108375: LD_INT 0
108377: PPUSH
108378: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
108379: LD_ADDR_VAR 0 2
108383: PUSH
108384: LD_INT 22
108386: PUSH
108387: LD_OWVAR 2
108391: PUSH
108392: EMPTY
108393: LIST
108394: LIST
108395: PPUSH
108396: CALL_OW 69
108400: ST_TO_ADDR
// if not tmp then
108401: LD_VAR 0 2
108405: NOT
108406: IFFALSE 108410
// exit ;
108408: GO 108439
// for i in tmp do
108410: LD_ADDR_VAR 0 1
108414: PUSH
108415: LD_VAR 0 2
108419: PUSH
108420: FOR_IN
108421: IFFALSE 108437
// SetLives ( i , 600 ) ;
108423: LD_VAR 0 1
108427: PPUSH
108428: LD_INT 600
108430: PPUSH
108431: CALL_OW 234
108435: GO 108420
108437: POP
108438: POP
// end ;
108439: PPOPN 2
108441: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
108442: LD_INT 0
108444: PPUSH
// case cmd of 301 :
108445: LD_VAR 0 1
108449: PUSH
108450: LD_INT 301
108452: DOUBLE
108453: EQUAL
108454: IFTRUE 108458
108456: GO 108490
108458: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
108459: LD_VAR 0 6
108463: PPUSH
108464: LD_VAR 0 7
108468: PPUSH
108469: LD_VAR 0 8
108473: PPUSH
108474: LD_VAR 0 4
108478: PPUSH
108479: LD_VAR 0 5
108483: PPUSH
108484: CALL 109699 0 5
108488: GO 108611
108490: LD_INT 302
108492: DOUBLE
108493: EQUAL
108494: IFTRUE 108498
108496: GO 108535
108498: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
108499: LD_VAR 0 6
108503: PPUSH
108504: LD_VAR 0 7
108508: PPUSH
108509: LD_VAR 0 8
108513: PPUSH
108514: LD_VAR 0 9
108518: PPUSH
108519: LD_VAR 0 4
108523: PPUSH
108524: LD_VAR 0 5
108528: PPUSH
108529: CALL 109790 0 6
108533: GO 108611
108535: LD_INT 303
108537: DOUBLE
108538: EQUAL
108539: IFTRUE 108543
108541: GO 108580
108543: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
108544: LD_VAR 0 6
108548: PPUSH
108549: LD_VAR 0 7
108553: PPUSH
108554: LD_VAR 0 8
108558: PPUSH
108559: LD_VAR 0 9
108563: PPUSH
108564: LD_VAR 0 4
108568: PPUSH
108569: LD_VAR 0 5
108573: PPUSH
108574: CALL 108616 0 6
108578: GO 108611
108580: LD_INT 304
108582: DOUBLE
108583: EQUAL
108584: IFTRUE 108588
108586: GO 108610
108588: POP
// hHackTeleport ( unit , x , y ) ; end ;
108589: LD_VAR 0 2
108593: PPUSH
108594: LD_VAR 0 4
108598: PPUSH
108599: LD_VAR 0 5
108603: PPUSH
108604: CALL 110383 0 3
108608: GO 108611
108610: POP
// end ;
108611: LD_VAR 0 12
108615: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
108616: LD_INT 0
108618: PPUSH
108619: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
108620: LD_VAR 0 1
108624: PUSH
108625: LD_INT 1
108627: LESS
108628: PUSH
108629: LD_VAR 0 1
108633: PUSH
108634: LD_INT 3
108636: GREATER
108637: OR
108638: PUSH
108639: LD_VAR 0 5
108643: PPUSH
108644: LD_VAR 0 6
108648: PPUSH
108649: CALL_OW 428
108653: OR
108654: IFFALSE 108658
// exit ;
108656: GO 109386
// uc_side := your_side ;
108658: LD_ADDR_OWVAR 20
108662: PUSH
108663: LD_OWVAR 2
108667: ST_TO_ADDR
// uc_nation := nation ;
108668: LD_ADDR_OWVAR 21
108672: PUSH
108673: LD_VAR 0 1
108677: ST_TO_ADDR
// bc_level = 1 ;
108678: LD_ADDR_OWVAR 43
108682: PUSH
108683: LD_INT 1
108685: ST_TO_ADDR
// case btype of 1 :
108686: LD_VAR 0 2
108690: PUSH
108691: LD_INT 1
108693: DOUBLE
108694: EQUAL
108695: IFTRUE 108699
108697: GO 108710
108699: POP
// bc_type := b_depot ; 2 :
108700: LD_ADDR_OWVAR 42
108704: PUSH
108705: LD_INT 0
108707: ST_TO_ADDR
108708: GO 109330
108710: LD_INT 2
108712: DOUBLE
108713: EQUAL
108714: IFTRUE 108718
108716: GO 108729
108718: POP
// bc_type := b_warehouse ; 3 :
108719: LD_ADDR_OWVAR 42
108723: PUSH
108724: LD_INT 1
108726: ST_TO_ADDR
108727: GO 109330
108729: LD_INT 3
108731: DOUBLE
108732: EQUAL
108733: IFTRUE 108737
108735: GO 108748
108737: POP
// bc_type := b_lab ; 4 .. 9 :
108738: LD_ADDR_OWVAR 42
108742: PUSH
108743: LD_INT 6
108745: ST_TO_ADDR
108746: GO 109330
108748: LD_INT 4
108750: DOUBLE
108751: GREATEREQUAL
108752: IFFALSE 108760
108754: LD_INT 9
108756: DOUBLE
108757: LESSEQUAL
108758: IFTRUE 108762
108760: GO 108822
108762: POP
// begin bc_type := b_lab_half ;
108763: LD_ADDR_OWVAR 42
108767: PUSH
108768: LD_INT 7
108770: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
108771: LD_ADDR_OWVAR 44
108775: PUSH
108776: LD_INT 10
108778: PUSH
108779: LD_INT 11
108781: PUSH
108782: LD_INT 12
108784: PUSH
108785: LD_INT 15
108787: PUSH
108788: LD_INT 14
108790: PUSH
108791: LD_INT 13
108793: PUSH
108794: EMPTY
108795: LIST
108796: LIST
108797: LIST
108798: LIST
108799: LIST
108800: LIST
108801: PUSH
108802: LD_VAR 0 2
108806: PUSH
108807: LD_INT 3
108809: MINUS
108810: ARRAY
108811: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
108812: LD_ADDR_OWVAR 45
108816: PUSH
108817: LD_INT 9
108819: ST_TO_ADDR
// end ; 10 .. 13 :
108820: GO 109330
108822: LD_INT 10
108824: DOUBLE
108825: GREATEREQUAL
108826: IFFALSE 108834
108828: LD_INT 13
108830: DOUBLE
108831: LESSEQUAL
108832: IFTRUE 108836
108834: GO 108913
108836: POP
// begin bc_type := b_lab_full ;
108837: LD_ADDR_OWVAR 42
108841: PUSH
108842: LD_INT 8
108844: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
108845: LD_ADDR_OWVAR 44
108849: PUSH
108850: LD_INT 10
108852: PUSH
108853: LD_INT 12
108855: PUSH
108856: LD_INT 14
108858: PUSH
108859: LD_INT 13
108861: PUSH
108862: EMPTY
108863: LIST
108864: LIST
108865: LIST
108866: LIST
108867: PUSH
108868: LD_VAR 0 2
108872: PUSH
108873: LD_INT 9
108875: MINUS
108876: ARRAY
108877: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
108878: LD_ADDR_OWVAR 45
108882: PUSH
108883: LD_INT 11
108885: PUSH
108886: LD_INT 15
108888: PUSH
108889: LD_INT 12
108891: PUSH
108892: LD_INT 15
108894: PUSH
108895: EMPTY
108896: LIST
108897: LIST
108898: LIST
108899: LIST
108900: PUSH
108901: LD_VAR 0 2
108905: PUSH
108906: LD_INT 9
108908: MINUS
108909: ARRAY
108910: ST_TO_ADDR
// end ; 14 :
108911: GO 109330
108913: LD_INT 14
108915: DOUBLE
108916: EQUAL
108917: IFTRUE 108921
108919: GO 108932
108921: POP
// bc_type := b_workshop ; 15 :
108922: LD_ADDR_OWVAR 42
108926: PUSH
108927: LD_INT 2
108929: ST_TO_ADDR
108930: GO 109330
108932: LD_INT 15
108934: DOUBLE
108935: EQUAL
108936: IFTRUE 108940
108938: GO 108951
108940: POP
// bc_type := b_factory ; 16 :
108941: LD_ADDR_OWVAR 42
108945: PUSH
108946: LD_INT 3
108948: ST_TO_ADDR
108949: GO 109330
108951: LD_INT 16
108953: DOUBLE
108954: EQUAL
108955: IFTRUE 108959
108957: GO 108970
108959: POP
// bc_type := b_ext_gun ; 17 :
108960: LD_ADDR_OWVAR 42
108964: PUSH
108965: LD_INT 17
108967: ST_TO_ADDR
108968: GO 109330
108970: LD_INT 17
108972: DOUBLE
108973: EQUAL
108974: IFTRUE 108978
108976: GO 109006
108978: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
108979: LD_ADDR_OWVAR 42
108983: PUSH
108984: LD_INT 19
108986: PUSH
108987: LD_INT 23
108989: PUSH
108990: LD_INT 19
108992: PUSH
108993: EMPTY
108994: LIST
108995: LIST
108996: LIST
108997: PUSH
108998: LD_VAR 0 1
109002: ARRAY
109003: ST_TO_ADDR
109004: GO 109330
109006: LD_INT 18
109008: DOUBLE
109009: EQUAL
109010: IFTRUE 109014
109012: GO 109025
109014: POP
// bc_type := b_ext_radar ; 19 :
109015: LD_ADDR_OWVAR 42
109019: PUSH
109020: LD_INT 20
109022: ST_TO_ADDR
109023: GO 109330
109025: LD_INT 19
109027: DOUBLE
109028: EQUAL
109029: IFTRUE 109033
109031: GO 109044
109033: POP
// bc_type := b_ext_radio ; 20 :
109034: LD_ADDR_OWVAR 42
109038: PUSH
109039: LD_INT 22
109041: ST_TO_ADDR
109042: GO 109330
109044: LD_INT 20
109046: DOUBLE
109047: EQUAL
109048: IFTRUE 109052
109050: GO 109063
109052: POP
// bc_type := b_ext_siberium ; 21 :
109053: LD_ADDR_OWVAR 42
109057: PUSH
109058: LD_INT 21
109060: ST_TO_ADDR
109061: GO 109330
109063: LD_INT 21
109065: DOUBLE
109066: EQUAL
109067: IFTRUE 109071
109069: GO 109082
109071: POP
// bc_type := b_ext_computer ; 22 :
109072: LD_ADDR_OWVAR 42
109076: PUSH
109077: LD_INT 24
109079: ST_TO_ADDR
109080: GO 109330
109082: LD_INT 22
109084: DOUBLE
109085: EQUAL
109086: IFTRUE 109090
109088: GO 109101
109090: POP
// bc_type := b_ext_track ; 23 :
109091: LD_ADDR_OWVAR 42
109095: PUSH
109096: LD_INT 16
109098: ST_TO_ADDR
109099: GO 109330
109101: LD_INT 23
109103: DOUBLE
109104: EQUAL
109105: IFTRUE 109109
109107: GO 109120
109109: POP
// bc_type := b_ext_laser ; 24 :
109110: LD_ADDR_OWVAR 42
109114: PUSH
109115: LD_INT 25
109117: ST_TO_ADDR
109118: GO 109330
109120: LD_INT 24
109122: DOUBLE
109123: EQUAL
109124: IFTRUE 109128
109126: GO 109139
109128: POP
// bc_type := b_control_tower ; 25 :
109129: LD_ADDR_OWVAR 42
109133: PUSH
109134: LD_INT 36
109136: ST_TO_ADDR
109137: GO 109330
109139: LD_INT 25
109141: DOUBLE
109142: EQUAL
109143: IFTRUE 109147
109145: GO 109158
109147: POP
// bc_type := b_breastwork ; 26 :
109148: LD_ADDR_OWVAR 42
109152: PUSH
109153: LD_INT 31
109155: ST_TO_ADDR
109156: GO 109330
109158: LD_INT 26
109160: DOUBLE
109161: EQUAL
109162: IFTRUE 109166
109164: GO 109177
109166: POP
// bc_type := b_bunker ; 27 :
109167: LD_ADDR_OWVAR 42
109171: PUSH
109172: LD_INT 32
109174: ST_TO_ADDR
109175: GO 109330
109177: LD_INT 27
109179: DOUBLE
109180: EQUAL
109181: IFTRUE 109185
109183: GO 109196
109185: POP
// bc_type := b_turret ; 28 :
109186: LD_ADDR_OWVAR 42
109190: PUSH
109191: LD_INT 33
109193: ST_TO_ADDR
109194: GO 109330
109196: LD_INT 28
109198: DOUBLE
109199: EQUAL
109200: IFTRUE 109204
109202: GO 109215
109204: POP
// bc_type := b_armoury ; 29 :
109205: LD_ADDR_OWVAR 42
109209: PUSH
109210: LD_INT 4
109212: ST_TO_ADDR
109213: GO 109330
109215: LD_INT 29
109217: DOUBLE
109218: EQUAL
109219: IFTRUE 109223
109221: GO 109234
109223: POP
// bc_type := b_barracks ; 30 :
109224: LD_ADDR_OWVAR 42
109228: PUSH
109229: LD_INT 5
109231: ST_TO_ADDR
109232: GO 109330
109234: LD_INT 30
109236: DOUBLE
109237: EQUAL
109238: IFTRUE 109242
109240: GO 109253
109242: POP
// bc_type := b_solar_power ; 31 :
109243: LD_ADDR_OWVAR 42
109247: PUSH
109248: LD_INT 27
109250: ST_TO_ADDR
109251: GO 109330
109253: LD_INT 31
109255: DOUBLE
109256: EQUAL
109257: IFTRUE 109261
109259: GO 109272
109261: POP
// bc_type := b_oil_power ; 32 :
109262: LD_ADDR_OWVAR 42
109266: PUSH
109267: LD_INT 26
109269: ST_TO_ADDR
109270: GO 109330
109272: LD_INT 32
109274: DOUBLE
109275: EQUAL
109276: IFTRUE 109280
109278: GO 109291
109280: POP
// bc_type := b_siberite_power ; 33 :
109281: LD_ADDR_OWVAR 42
109285: PUSH
109286: LD_INT 28
109288: ST_TO_ADDR
109289: GO 109330
109291: LD_INT 33
109293: DOUBLE
109294: EQUAL
109295: IFTRUE 109299
109297: GO 109310
109299: POP
// bc_type := b_oil_mine ; 34 :
109300: LD_ADDR_OWVAR 42
109304: PUSH
109305: LD_INT 29
109307: ST_TO_ADDR
109308: GO 109330
109310: LD_INT 34
109312: DOUBLE
109313: EQUAL
109314: IFTRUE 109318
109316: GO 109329
109318: POP
// bc_type := b_siberite_mine ; end ;
109319: LD_ADDR_OWVAR 42
109323: PUSH
109324: LD_INT 30
109326: ST_TO_ADDR
109327: GO 109330
109329: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
109330: LD_ADDR_VAR 0 8
109334: PUSH
109335: LD_VAR 0 5
109339: PPUSH
109340: LD_VAR 0 6
109344: PPUSH
109345: LD_VAR 0 3
109349: PPUSH
109350: CALL_OW 47
109354: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
109355: LD_OWVAR 42
109359: PUSH
109360: LD_INT 32
109362: PUSH
109363: LD_INT 33
109365: PUSH
109366: EMPTY
109367: LIST
109368: LIST
109369: IN
109370: IFFALSE 109386
// PlaceWeaponTurret ( b , weapon ) ;
109372: LD_VAR 0 8
109376: PPUSH
109377: LD_VAR 0 4
109381: PPUSH
109382: CALL_OW 431
// end ;
109386: LD_VAR 0 7
109390: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
109391: LD_INT 0
109393: PPUSH
109394: PPUSH
109395: PPUSH
109396: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
109397: LD_ADDR_VAR 0 4
109401: PUSH
109402: LD_INT 22
109404: PUSH
109405: LD_OWVAR 2
109409: PUSH
109410: EMPTY
109411: LIST
109412: LIST
109413: PUSH
109414: LD_INT 2
109416: PUSH
109417: LD_INT 30
109419: PUSH
109420: LD_INT 0
109422: PUSH
109423: EMPTY
109424: LIST
109425: LIST
109426: PUSH
109427: LD_INT 30
109429: PUSH
109430: LD_INT 1
109432: PUSH
109433: EMPTY
109434: LIST
109435: LIST
109436: PUSH
109437: EMPTY
109438: LIST
109439: LIST
109440: LIST
109441: PUSH
109442: EMPTY
109443: LIST
109444: LIST
109445: PPUSH
109446: CALL_OW 69
109450: ST_TO_ADDR
// if not tmp then
109451: LD_VAR 0 4
109455: NOT
109456: IFFALSE 109460
// exit ;
109458: GO 109519
// for i in tmp do
109460: LD_ADDR_VAR 0 2
109464: PUSH
109465: LD_VAR 0 4
109469: PUSH
109470: FOR_IN
109471: IFFALSE 109517
// for j = 1 to 3 do
109473: LD_ADDR_VAR 0 3
109477: PUSH
109478: DOUBLE
109479: LD_INT 1
109481: DEC
109482: ST_TO_ADDR
109483: LD_INT 3
109485: PUSH
109486: FOR_TO
109487: IFFALSE 109513
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
109489: LD_VAR 0 2
109493: PPUSH
109494: CALL_OW 274
109498: PPUSH
109499: LD_VAR 0 3
109503: PPUSH
109504: LD_INT 99999
109506: PPUSH
109507: CALL_OW 277
109511: GO 109486
109513: POP
109514: POP
109515: GO 109470
109517: POP
109518: POP
// end ;
109519: LD_VAR 0 1
109523: RET
// export function hHackSetLevel10 ; var i , j ; begin
109524: LD_INT 0
109526: PPUSH
109527: PPUSH
109528: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
109529: LD_ADDR_VAR 0 2
109533: PUSH
109534: LD_INT 21
109536: PUSH
109537: LD_INT 1
109539: PUSH
109540: EMPTY
109541: LIST
109542: LIST
109543: PPUSH
109544: CALL_OW 69
109548: PUSH
109549: FOR_IN
109550: IFFALSE 109602
// if IsSelected ( i ) then
109552: LD_VAR 0 2
109556: PPUSH
109557: CALL_OW 306
109561: IFFALSE 109600
// begin for j := 1 to 4 do
109563: LD_ADDR_VAR 0 3
109567: PUSH
109568: DOUBLE
109569: LD_INT 1
109571: DEC
109572: ST_TO_ADDR
109573: LD_INT 4
109575: PUSH
109576: FOR_TO
109577: IFFALSE 109598
// SetSkill ( i , j , 10 ) ;
109579: LD_VAR 0 2
109583: PPUSH
109584: LD_VAR 0 3
109588: PPUSH
109589: LD_INT 10
109591: PPUSH
109592: CALL_OW 237
109596: GO 109576
109598: POP
109599: POP
// end ;
109600: GO 109549
109602: POP
109603: POP
// end ;
109604: LD_VAR 0 1
109608: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
109609: LD_INT 0
109611: PPUSH
109612: PPUSH
109613: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
109614: LD_ADDR_VAR 0 2
109618: PUSH
109619: LD_INT 22
109621: PUSH
109622: LD_OWVAR 2
109626: PUSH
109627: EMPTY
109628: LIST
109629: LIST
109630: PUSH
109631: LD_INT 21
109633: PUSH
109634: LD_INT 1
109636: PUSH
109637: EMPTY
109638: LIST
109639: LIST
109640: PUSH
109641: EMPTY
109642: LIST
109643: LIST
109644: PPUSH
109645: CALL_OW 69
109649: PUSH
109650: FOR_IN
109651: IFFALSE 109692
// begin for j := 1 to 4 do
109653: LD_ADDR_VAR 0 3
109657: PUSH
109658: DOUBLE
109659: LD_INT 1
109661: DEC
109662: ST_TO_ADDR
109663: LD_INT 4
109665: PUSH
109666: FOR_TO
109667: IFFALSE 109688
// SetSkill ( i , j , 10 ) ;
109669: LD_VAR 0 2
109673: PPUSH
109674: LD_VAR 0 3
109678: PPUSH
109679: LD_INT 10
109681: PPUSH
109682: CALL_OW 237
109686: GO 109666
109688: POP
109689: POP
// end ;
109690: GO 109650
109692: POP
109693: POP
// end ;
109694: LD_VAR 0 1
109698: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
109699: LD_INT 0
109701: PPUSH
// uc_side := your_side ;
109702: LD_ADDR_OWVAR 20
109706: PUSH
109707: LD_OWVAR 2
109711: ST_TO_ADDR
// uc_nation := nation ;
109712: LD_ADDR_OWVAR 21
109716: PUSH
109717: LD_VAR 0 1
109721: ST_TO_ADDR
// InitHc ;
109722: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
109726: LD_INT 0
109728: PPUSH
109729: LD_VAR 0 2
109733: PPUSH
109734: LD_VAR 0 3
109738: PPUSH
109739: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
109743: LD_VAR 0 4
109747: PPUSH
109748: LD_VAR 0 5
109752: PPUSH
109753: CALL_OW 428
109757: PUSH
109758: LD_INT 0
109760: EQUAL
109761: IFFALSE 109785
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
109763: CALL_OW 44
109767: PPUSH
109768: LD_VAR 0 4
109772: PPUSH
109773: LD_VAR 0 5
109777: PPUSH
109778: LD_INT 1
109780: PPUSH
109781: CALL_OW 48
// end ;
109785: LD_VAR 0 6
109789: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
109790: LD_INT 0
109792: PPUSH
109793: PPUSH
// uc_side := your_side ;
109794: LD_ADDR_OWVAR 20
109798: PUSH
109799: LD_OWVAR 2
109803: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
109804: LD_VAR 0 1
109808: PUSH
109809: LD_INT 1
109811: PUSH
109812: LD_INT 2
109814: PUSH
109815: LD_INT 3
109817: PUSH
109818: LD_INT 4
109820: PUSH
109821: LD_INT 5
109823: PUSH
109824: EMPTY
109825: LIST
109826: LIST
109827: LIST
109828: LIST
109829: LIST
109830: IN
109831: IFFALSE 109843
// uc_nation := nation_american else
109833: LD_ADDR_OWVAR 21
109837: PUSH
109838: LD_INT 1
109840: ST_TO_ADDR
109841: GO 109886
// if chassis in [ 11 , 12 , 13 , 14 ] then
109843: LD_VAR 0 1
109847: PUSH
109848: LD_INT 11
109850: PUSH
109851: LD_INT 12
109853: PUSH
109854: LD_INT 13
109856: PUSH
109857: LD_INT 14
109859: PUSH
109860: EMPTY
109861: LIST
109862: LIST
109863: LIST
109864: LIST
109865: IN
109866: IFFALSE 109878
// uc_nation := nation_arabian else
109868: LD_ADDR_OWVAR 21
109872: PUSH
109873: LD_INT 2
109875: ST_TO_ADDR
109876: GO 109886
// uc_nation := nation_russian ;
109878: LD_ADDR_OWVAR 21
109882: PUSH
109883: LD_INT 3
109885: ST_TO_ADDR
// vc_chassis := chassis ;
109886: LD_ADDR_OWVAR 37
109890: PUSH
109891: LD_VAR 0 1
109895: ST_TO_ADDR
// vc_engine := engine ;
109896: LD_ADDR_OWVAR 39
109900: PUSH
109901: LD_VAR 0 2
109905: ST_TO_ADDR
// vc_control := control ;
109906: LD_ADDR_OWVAR 38
109910: PUSH
109911: LD_VAR 0 3
109915: ST_TO_ADDR
// vc_weapon := weapon ;
109916: LD_ADDR_OWVAR 40
109920: PUSH
109921: LD_VAR 0 4
109925: ST_TO_ADDR
// un := CreateVehicle ;
109926: LD_ADDR_VAR 0 8
109930: PUSH
109931: CALL_OW 45
109935: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
109936: LD_VAR 0 8
109940: PPUSH
109941: LD_INT 0
109943: PPUSH
109944: LD_INT 5
109946: PPUSH
109947: CALL_OW 12
109951: PPUSH
109952: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
109956: LD_VAR 0 8
109960: PPUSH
109961: LD_VAR 0 5
109965: PPUSH
109966: LD_VAR 0 6
109970: PPUSH
109971: LD_INT 1
109973: PPUSH
109974: CALL_OW 48
// end ;
109978: LD_VAR 0 7
109982: RET
// export hInvincible ; every 1 do
109983: GO 109985
109985: DISABLE
// hInvincible := [ ] ;
109986: LD_ADDR_EXP 136
109990: PUSH
109991: EMPTY
109992: ST_TO_ADDR
109993: END
// every 10 do var i ;
109994: GO 109996
109996: DISABLE
109997: LD_INT 0
109999: PPUSH
// begin enable ;
110000: ENABLE
// if not hInvincible then
110001: LD_EXP 136
110005: NOT
110006: IFFALSE 110010
// exit ;
110008: GO 110054
// for i in hInvincible do
110010: LD_ADDR_VAR 0 1
110014: PUSH
110015: LD_EXP 136
110019: PUSH
110020: FOR_IN
110021: IFFALSE 110052
// if GetLives ( i ) < 1000 then
110023: LD_VAR 0 1
110027: PPUSH
110028: CALL_OW 256
110032: PUSH
110033: LD_INT 1000
110035: LESS
110036: IFFALSE 110050
// SetLives ( i , 1000 ) ;
110038: LD_VAR 0 1
110042: PPUSH
110043: LD_INT 1000
110045: PPUSH
110046: CALL_OW 234
110050: GO 110020
110052: POP
110053: POP
// end ;
110054: PPOPN 1
110056: END
// export function hHackInvincible ; var i ; begin
110057: LD_INT 0
110059: PPUSH
110060: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
110061: LD_ADDR_VAR 0 2
110065: PUSH
110066: LD_INT 2
110068: PUSH
110069: LD_INT 21
110071: PUSH
110072: LD_INT 1
110074: PUSH
110075: EMPTY
110076: LIST
110077: LIST
110078: PUSH
110079: LD_INT 21
110081: PUSH
110082: LD_INT 2
110084: PUSH
110085: EMPTY
110086: LIST
110087: LIST
110088: PUSH
110089: EMPTY
110090: LIST
110091: LIST
110092: LIST
110093: PPUSH
110094: CALL_OW 69
110098: PUSH
110099: FOR_IN
110100: IFFALSE 110161
// if IsSelected ( i ) then
110102: LD_VAR 0 2
110106: PPUSH
110107: CALL_OW 306
110111: IFFALSE 110159
// begin if i in hInvincible then
110113: LD_VAR 0 2
110117: PUSH
110118: LD_EXP 136
110122: IN
110123: IFFALSE 110143
// hInvincible := hInvincible diff i else
110125: LD_ADDR_EXP 136
110129: PUSH
110130: LD_EXP 136
110134: PUSH
110135: LD_VAR 0 2
110139: DIFF
110140: ST_TO_ADDR
110141: GO 110159
// hInvincible := hInvincible union i ;
110143: LD_ADDR_EXP 136
110147: PUSH
110148: LD_EXP 136
110152: PUSH
110153: LD_VAR 0 2
110157: UNION
110158: ST_TO_ADDR
// end ;
110159: GO 110099
110161: POP
110162: POP
// end ;
110163: LD_VAR 0 1
110167: RET
// export function hHackInvisible ; var i , j ; begin
110168: LD_INT 0
110170: PPUSH
110171: PPUSH
110172: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
110173: LD_ADDR_VAR 0 2
110177: PUSH
110178: LD_INT 21
110180: PUSH
110181: LD_INT 1
110183: PUSH
110184: EMPTY
110185: LIST
110186: LIST
110187: PPUSH
110188: CALL_OW 69
110192: PUSH
110193: FOR_IN
110194: IFFALSE 110218
// if IsSelected ( i ) then
110196: LD_VAR 0 2
110200: PPUSH
110201: CALL_OW 306
110205: IFFALSE 110216
// ComForceInvisible ( i ) ;
110207: LD_VAR 0 2
110211: PPUSH
110212: CALL_OW 496
110216: GO 110193
110218: POP
110219: POP
// end ;
110220: LD_VAR 0 1
110224: RET
// export function hHackChangeYourSide ; begin
110225: LD_INT 0
110227: PPUSH
// if your_side = 8 then
110228: LD_OWVAR 2
110232: PUSH
110233: LD_INT 8
110235: EQUAL
110236: IFFALSE 110248
// your_side := 0 else
110238: LD_ADDR_OWVAR 2
110242: PUSH
110243: LD_INT 0
110245: ST_TO_ADDR
110246: GO 110262
// your_side := your_side + 1 ;
110248: LD_ADDR_OWVAR 2
110252: PUSH
110253: LD_OWVAR 2
110257: PUSH
110258: LD_INT 1
110260: PLUS
110261: ST_TO_ADDR
// end ;
110262: LD_VAR 0 1
110266: RET
// export function hHackChangeUnitSide ; var i , j ; begin
110267: LD_INT 0
110269: PPUSH
110270: PPUSH
110271: PPUSH
// for i in all_units do
110272: LD_ADDR_VAR 0 2
110276: PUSH
110277: LD_OWVAR 3
110281: PUSH
110282: FOR_IN
110283: IFFALSE 110361
// if IsSelected ( i ) then
110285: LD_VAR 0 2
110289: PPUSH
110290: CALL_OW 306
110294: IFFALSE 110359
// begin j := GetSide ( i ) ;
110296: LD_ADDR_VAR 0 3
110300: PUSH
110301: LD_VAR 0 2
110305: PPUSH
110306: CALL_OW 255
110310: ST_TO_ADDR
// if j = 8 then
110311: LD_VAR 0 3
110315: PUSH
110316: LD_INT 8
110318: EQUAL
110319: IFFALSE 110331
// j := 0 else
110321: LD_ADDR_VAR 0 3
110325: PUSH
110326: LD_INT 0
110328: ST_TO_ADDR
110329: GO 110345
// j := j + 1 ;
110331: LD_ADDR_VAR 0 3
110335: PUSH
110336: LD_VAR 0 3
110340: PUSH
110341: LD_INT 1
110343: PLUS
110344: ST_TO_ADDR
// SetSide ( i , j ) ;
110345: LD_VAR 0 2
110349: PPUSH
110350: LD_VAR 0 3
110354: PPUSH
110355: CALL_OW 235
// end ;
110359: GO 110282
110361: POP
110362: POP
// end ;
110363: LD_VAR 0 1
110367: RET
// export function hHackFog ; begin
110368: LD_INT 0
110370: PPUSH
// FogOff ( true ) ;
110371: LD_INT 1
110373: PPUSH
110374: CALL_OW 344
// end ;
110378: LD_VAR 0 1
110382: RET
// export function hHackTeleport ( unit , x , y ) ; begin
110383: LD_INT 0
110385: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
110386: LD_VAR 0 1
110390: PPUSH
110391: LD_VAR 0 2
110395: PPUSH
110396: LD_VAR 0 3
110400: PPUSH
110401: LD_INT 1
110403: PPUSH
110404: LD_INT 1
110406: PPUSH
110407: CALL_OW 483
// CenterOnXY ( x , y ) ;
110411: LD_VAR 0 2
110415: PPUSH
110416: LD_VAR 0 3
110420: PPUSH
110421: CALL_OW 84
// end ;
110425: LD_VAR 0 4
110429: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
110430: LD_INT 0
110432: PPUSH
110433: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
110434: LD_VAR 0 1
110438: NOT
110439: PUSH
110440: LD_VAR 0 2
110444: PPUSH
110445: LD_VAR 0 3
110449: PPUSH
110450: CALL_OW 488
110454: NOT
110455: OR
110456: PUSH
110457: LD_VAR 0 1
110461: PPUSH
110462: CALL_OW 266
110466: PUSH
110467: LD_INT 3
110469: NONEQUAL
110470: PUSH
110471: LD_VAR 0 1
110475: PPUSH
110476: CALL_OW 247
110480: PUSH
110481: LD_INT 1
110483: EQUAL
110484: NOT
110485: AND
110486: OR
110487: IFFALSE 110491
// exit ;
110489: GO 110640
// if GetType ( factory ) = unit_human then
110491: LD_VAR 0 1
110495: PPUSH
110496: CALL_OW 247
110500: PUSH
110501: LD_INT 1
110503: EQUAL
110504: IFFALSE 110521
// factory := IsInUnit ( factory ) ;
110506: LD_ADDR_VAR 0 1
110510: PUSH
110511: LD_VAR 0 1
110515: PPUSH
110516: CALL_OW 310
110520: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
110521: LD_VAR 0 1
110525: PPUSH
110526: CALL_OW 266
110530: PUSH
110531: LD_INT 3
110533: NONEQUAL
110534: IFFALSE 110538
// exit ;
110536: GO 110640
// if HexInfo ( x , y ) = factory then
110538: LD_VAR 0 2
110542: PPUSH
110543: LD_VAR 0 3
110547: PPUSH
110548: CALL_OW 428
110552: PUSH
110553: LD_VAR 0 1
110557: EQUAL
110558: IFFALSE 110585
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
110560: LD_ADDR_EXP 137
110564: PUSH
110565: LD_EXP 137
110569: PPUSH
110570: LD_VAR 0 1
110574: PPUSH
110575: LD_INT 0
110577: PPUSH
110578: CALL_OW 1
110582: ST_TO_ADDR
110583: GO 110636
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
110585: LD_ADDR_EXP 137
110589: PUSH
110590: LD_EXP 137
110594: PPUSH
110595: LD_VAR 0 1
110599: PPUSH
110600: LD_VAR 0 1
110604: PPUSH
110605: CALL_OW 255
110609: PUSH
110610: LD_VAR 0 1
110614: PUSH
110615: LD_VAR 0 2
110619: PUSH
110620: LD_VAR 0 3
110624: PUSH
110625: EMPTY
110626: LIST
110627: LIST
110628: LIST
110629: LIST
110630: PPUSH
110631: CALL_OW 1
110635: ST_TO_ADDR
// UpdateFactoryWaypoints ;
110636: CALL 110645 0 0
// end ;
110640: LD_VAR 0 4
110644: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
110645: LD_INT 0
110647: PPUSH
110648: PPUSH
110649: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
110650: LD_STRING resetFactoryWaypoint();
110652: PPUSH
110653: CALL_OW 559
// if factoryWaypoints then
110657: LD_EXP 137
110661: IFFALSE 110787
// begin list := PrepareArray ( factoryWaypoints ) ;
110663: LD_ADDR_VAR 0 3
110667: PUSH
110668: LD_EXP 137
110672: PPUSH
110673: CALL 52575 0 1
110677: ST_TO_ADDR
// for i := 1 to list do
110678: LD_ADDR_VAR 0 2
110682: PUSH
110683: DOUBLE
110684: LD_INT 1
110686: DEC
110687: ST_TO_ADDR
110688: LD_VAR 0 3
110692: PUSH
110693: FOR_TO
110694: IFFALSE 110785
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
110696: LD_STRING setFactoryWaypointXY(
110698: PUSH
110699: LD_VAR 0 3
110703: PUSH
110704: LD_VAR 0 2
110708: ARRAY
110709: PUSH
110710: LD_INT 1
110712: ARRAY
110713: STR
110714: PUSH
110715: LD_STRING ,
110717: STR
110718: PUSH
110719: LD_VAR 0 3
110723: PUSH
110724: LD_VAR 0 2
110728: ARRAY
110729: PUSH
110730: LD_INT 2
110732: ARRAY
110733: STR
110734: PUSH
110735: LD_STRING ,
110737: STR
110738: PUSH
110739: LD_VAR 0 3
110743: PUSH
110744: LD_VAR 0 2
110748: ARRAY
110749: PUSH
110750: LD_INT 3
110752: ARRAY
110753: STR
110754: PUSH
110755: LD_STRING ,
110757: STR
110758: PUSH
110759: LD_VAR 0 3
110763: PUSH
110764: LD_VAR 0 2
110768: ARRAY
110769: PUSH
110770: LD_INT 4
110772: ARRAY
110773: STR
110774: PUSH
110775: LD_STRING )
110777: STR
110778: PPUSH
110779: CALL_OW 559
110783: GO 110693
110785: POP
110786: POP
// end ; end ;
110787: LD_VAR 0 1
110791: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
110792: LD_INT 0
110794: PPUSH
// if HexInfo ( x , y ) = warehouse then
110795: LD_VAR 0 2
110799: PPUSH
110800: LD_VAR 0 3
110804: PPUSH
110805: CALL_OW 428
110809: PUSH
110810: LD_VAR 0 1
110814: EQUAL
110815: IFFALSE 110842
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
110817: LD_ADDR_EXP 138
110821: PUSH
110822: LD_EXP 138
110826: PPUSH
110827: LD_VAR 0 1
110831: PPUSH
110832: LD_INT 0
110834: PPUSH
110835: CALL_OW 1
110839: ST_TO_ADDR
110840: GO 110893
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
110842: LD_ADDR_EXP 138
110846: PUSH
110847: LD_EXP 138
110851: PPUSH
110852: LD_VAR 0 1
110856: PPUSH
110857: LD_VAR 0 1
110861: PPUSH
110862: CALL_OW 255
110866: PUSH
110867: LD_VAR 0 1
110871: PUSH
110872: LD_VAR 0 2
110876: PUSH
110877: LD_VAR 0 3
110881: PUSH
110882: EMPTY
110883: LIST
110884: LIST
110885: LIST
110886: LIST
110887: PPUSH
110888: CALL_OW 1
110892: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
110893: CALL 110902 0 0
// end ;
110897: LD_VAR 0 4
110901: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
110902: LD_INT 0
110904: PPUSH
110905: PPUSH
110906: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
110907: LD_STRING resetWarehouseGatheringPoints();
110909: PPUSH
110910: CALL_OW 559
// if warehouseGatheringPoints then
110914: LD_EXP 138
110918: IFFALSE 111044
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
110920: LD_ADDR_VAR 0 3
110924: PUSH
110925: LD_EXP 138
110929: PPUSH
110930: CALL 52575 0 1
110934: ST_TO_ADDR
// for i := 1 to list do
110935: LD_ADDR_VAR 0 2
110939: PUSH
110940: DOUBLE
110941: LD_INT 1
110943: DEC
110944: ST_TO_ADDR
110945: LD_VAR 0 3
110949: PUSH
110950: FOR_TO
110951: IFFALSE 111042
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
110953: LD_STRING setWarehouseGatheringPointXY(
110955: PUSH
110956: LD_VAR 0 3
110960: PUSH
110961: LD_VAR 0 2
110965: ARRAY
110966: PUSH
110967: LD_INT 1
110969: ARRAY
110970: STR
110971: PUSH
110972: LD_STRING ,
110974: STR
110975: PUSH
110976: LD_VAR 0 3
110980: PUSH
110981: LD_VAR 0 2
110985: ARRAY
110986: PUSH
110987: LD_INT 2
110989: ARRAY
110990: STR
110991: PUSH
110992: LD_STRING ,
110994: STR
110995: PUSH
110996: LD_VAR 0 3
111000: PUSH
111001: LD_VAR 0 2
111005: ARRAY
111006: PUSH
111007: LD_INT 3
111009: ARRAY
111010: STR
111011: PUSH
111012: LD_STRING ,
111014: STR
111015: PUSH
111016: LD_VAR 0 3
111020: PUSH
111021: LD_VAR 0 2
111025: ARRAY
111026: PUSH
111027: LD_INT 4
111029: ARRAY
111030: STR
111031: PUSH
111032: LD_STRING )
111034: STR
111035: PPUSH
111036: CALL_OW 559
111040: GO 110950
111042: POP
111043: POP
// end ; end ;
111044: LD_VAR 0 1
111048: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
111049: LD_EXP 138
111053: IFFALSE 111738
111055: GO 111057
111057: DISABLE
111058: LD_INT 0
111060: PPUSH
111061: PPUSH
111062: PPUSH
111063: PPUSH
111064: PPUSH
111065: PPUSH
111066: PPUSH
111067: PPUSH
111068: PPUSH
// begin enable ;
111069: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
111070: LD_ADDR_VAR 0 3
111074: PUSH
111075: LD_EXP 138
111079: PPUSH
111080: CALL 52575 0 1
111084: ST_TO_ADDR
// if not list then
111085: LD_VAR 0 3
111089: NOT
111090: IFFALSE 111094
// exit ;
111092: GO 111738
// for i := 1 to list do
111094: LD_ADDR_VAR 0 1
111098: PUSH
111099: DOUBLE
111100: LD_INT 1
111102: DEC
111103: ST_TO_ADDR
111104: LD_VAR 0 3
111108: PUSH
111109: FOR_TO
111110: IFFALSE 111736
// begin depot := list [ i ] [ 2 ] ;
111112: LD_ADDR_VAR 0 8
111116: PUSH
111117: LD_VAR 0 3
111121: PUSH
111122: LD_VAR 0 1
111126: ARRAY
111127: PUSH
111128: LD_INT 2
111130: ARRAY
111131: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
111132: LD_ADDR_VAR 0 5
111136: PUSH
111137: LD_VAR 0 3
111141: PUSH
111142: LD_VAR 0 1
111146: ARRAY
111147: PUSH
111148: LD_INT 1
111150: ARRAY
111151: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
111152: LD_VAR 0 8
111156: PPUSH
111157: CALL_OW 301
111161: PUSH
111162: LD_VAR 0 5
111166: PUSH
111167: LD_VAR 0 8
111171: PPUSH
111172: CALL_OW 255
111176: NONEQUAL
111177: OR
111178: IFFALSE 111207
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
111180: LD_ADDR_EXP 138
111184: PUSH
111185: LD_EXP 138
111189: PPUSH
111190: LD_VAR 0 8
111194: PPUSH
111195: LD_INT 0
111197: PPUSH
111198: CALL_OW 1
111202: ST_TO_ADDR
// exit ;
111203: POP
111204: POP
111205: GO 111738
// end ; x := list [ i ] [ 3 ] ;
111207: LD_ADDR_VAR 0 6
111211: PUSH
111212: LD_VAR 0 3
111216: PUSH
111217: LD_VAR 0 1
111221: ARRAY
111222: PUSH
111223: LD_INT 3
111225: ARRAY
111226: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
111227: LD_ADDR_VAR 0 7
111231: PUSH
111232: LD_VAR 0 3
111236: PUSH
111237: LD_VAR 0 1
111241: ARRAY
111242: PUSH
111243: LD_INT 4
111245: ARRAY
111246: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
111247: LD_ADDR_VAR 0 9
111251: PUSH
111252: LD_VAR 0 6
111256: PPUSH
111257: LD_VAR 0 7
111261: PPUSH
111262: LD_INT 16
111264: PPUSH
111265: CALL 51163 0 3
111269: ST_TO_ADDR
// if not cratesNearbyPoint then
111270: LD_VAR 0 9
111274: NOT
111275: IFFALSE 111281
// exit ;
111277: POP
111278: POP
111279: GO 111738
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
111281: LD_ADDR_VAR 0 4
111285: PUSH
111286: LD_INT 22
111288: PUSH
111289: LD_VAR 0 5
111293: PUSH
111294: EMPTY
111295: LIST
111296: LIST
111297: PUSH
111298: LD_INT 3
111300: PUSH
111301: LD_INT 60
111303: PUSH
111304: EMPTY
111305: LIST
111306: PUSH
111307: EMPTY
111308: LIST
111309: LIST
111310: PUSH
111311: LD_INT 91
111313: PUSH
111314: LD_VAR 0 8
111318: PUSH
111319: LD_INT 6
111321: PUSH
111322: EMPTY
111323: LIST
111324: LIST
111325: LIST
111326: PUSH
111327: LD_INT 2
111329: PUSH
111330: LD_INT 25
111332: PUSH
111333: LD_INT 2
111335: PUSH
111336: EMPTY
111337: LIST
111338: LIST
111339: PUSH
111340: LD_INT 25
111342: PUSH
111343: LD_INT 16
111345: PUSH
111346: EMPTY
111347: LIST
111348: LIST
111349: PUSH
111350: EMPTY
111351: LIST
111352: LIST
111353: LIST
111354: PUSH
111355: EMPTY
111356: LIST
111357: LIST
111358: LIST
111359: LIST
111360: PPUSH
111361: CALL_OW 69
111365: PUSH
111366: LD_VAR 0 8
111370: PPUSH
111371: CALL_OW 313
111375: PPUSH
111376: LD_INT 3
111378: PUSH
111379: LD_INT 60
111381: PUSH
111382: EMPTY
111383: LIST
111384: PUSH
111385: EMPTY
111386: LIST
111387: LIST
111388: PUSH
111389: LD_INT 2
111391: PUSH
111392: LD_INT 25
111394: PUSH
111395: LD_INT 2
111397: PUSH
111398: EMPTY
111399: LIST
111400: LIST
111401: PUSH
111402: LD_INT 25
111404: PUSH
111405: LD_INT 16
111407: PUSH
111408: EMPTY
111409: LIST
111410: LIST
111411: PUSH
111412: EMPTY
111413: LIST
111414: LIST
111415: LIST
111416: PUSH
111417: EMPTY
111418: LIST
111419: LIST
111420: PPUSH
111421: CALL_OW 72
111425: UNION
111426: ST_TO_ADDR
// if tmp then
111427: LD_VAR 0 4
111431: IFFALSE 111511
// begin tmp := ShrinkArray ( tmp , 3 ) ;
111433: LD_ADDR_VAR 0 4
111437: PUSH
111438: LD_VAR 0 4
111442: PPUSH
111443: LD_INT 3
111445: PPUSH
111446: CALL 49132 0 2
111450: ST_TO_ADDR
// for j in tmp do
111451: LD_ADDR_VAR 0 2
111455: PUSH
111456: LD_VAR 0 4
111460: PUSH
111461: FOR_IN
111462: IFFALSE 111505
// begin if IsInUnit ( j ) then
111464: LD_VAR 0 2
111468: PPUSH
111469: CALL_OW 310
111473: IFFALSE 111484
// ComExit ( j ) ;
111475: LD_VAR 0 2
111479: PPUSH
111480: CALL 49215 0 1
// AddComCollect ( j , x , y ) ;
111484: LD_VAR 0 2
111488: PPUSH
111489: LD_VAR 0 6
111493: PPUSH
111494: LD_VAR 0 7
111498: PPUSH
111499: CALL_OW 177
// end ;
111503: GO 111461
111505: POP
111506: POP
// exit ;
111507: POP
111508: POP
111509: GO 111738
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
111511: LD_ADDR_VAR 0 4
111515: PUSH
111516: LD_INT 22
111518: PUSH
111519: LD_VAR 0 5
111523: PUSH
111524: EMPTY
111525: LIST
111526: LIST
111527: PUSH
111528: LD_INT 91
111530: PUSH
111531: LD_VAR 0 8
111535: PUSH
111536: LD_INT 8
111538: PUSH
111539: EMPTY
111540: LIST
111541: LIST
111542: LIST
111543: PUSH
111544: LD_INT 2
111546: PUSH
111547: LD_INT 34
111549: PUSH
111550: LD_INT 12
111552: PUSH
111553: EMPTY
111554: LIST
111555: LIST
111556: PUSH
111557: LD_INT 34
111559: PUSH
111560: LD_INT 51
111562: PUSH
111563: EMPTY
111564: LIST
111565: LIST
111566: PUSH
111567: LD_INT 34
111569: PUSH
111570: LD_INT 32
111572: PUSH
111573: EMPTY
111574: LIST
111575: LIST
111576: PUSH
111577: LD_INT 34
111579: PUSH
111580: LD_INT 89
111582: PUSH
111583: EMPTY
111584: LIST
111585: LIST
111586: PUSH
111587: EMPTY
111588: LIST
111589: LIST
111590: LIST
111591: LIST
111592: LIST
111593: PUSH
111594: EMPTY
111595: LIST
111596: LIST
111597: LIST
111598: PPUSH
111599: CALL_OW 69
111603: ST_TO_ADDR
// if tmp then
111604: LD_VAR 0 4
111608: IFFALSE 111734
// begin for j in tmp do
111610: LD_ADDR_VAR 0 2
111614: PUSH
111615: LD_VAR 0 4
111619: PUSH
111620: FOR_IN
111621: IFFALSE 111732
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
111623: LD_VAR 0 2
111627: PPUSH
111628: CALL_OW 262
111632: PUSH
111633: LD_INT 3
111635: EQUAL
111636: PUSH
111637: LD_VAR 0 2
111641: PPUSH
111642: CALL_OW 261
111646: PUSH
111647: LD_INT 20
111649: GREATER
111650: OR
111651: PUSH
111652: LD_VAR 0 2
111656: PPUSH
111657: CALL_OW 314
111661: NOT
111662: AND
111663: PUSH
111664: LD_VAR 0 2
111668: PPUSH
111669: CALL_OW 263
111673: PUSH
111674: LD_INT 1
111676: NONEQUAL
111677: PUSH
111678: LD_VAR 0 2
111682: PPUSH
111683: CALL_OW 311
111687: OR
111688: AND
111689: IFFALSE 111730
// begin ComCollect ( j , x , y ) ;
111691: LD_VAR 0 2
111695: PPUSH
111696: LD_VAR 0 6
111700: PPUSH
111701: LD_VAR 0 7
111705: PPUSH
111706: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
111710: LD_VAR 0 2
111714: PPUSH
111715: LD_VAR 0 8
111719: PPUSH
111720: CALL_OW 172
// exit ;
111724: POP
111725: POP
111726: POP
111727: POP
111728: GO 111738
// end ;
111730: GO 111620
111732: POP
111733: POP
// end ; end ;
111734: GO 111109
111736: POP
111737: POP
// end ; end_of_file
111738: PPOPN 9
111740: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
111741: LD_VAR 0 1
111745: PPUSH
111746: LD_VAR 0 2
111750: PPUSH
111751: LD_VAR 0 3
111755: PPUSH
111756: LD_VAR 0 4
111760: PPUSH
111761: LD_VAR 0 5
111765: PPUSH
111766: LD_VAR 0 6
111770: PPUSH
111771: CALL 96094 0 6
// end ;
111775: PPOPN 6
111777: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
111778: LD_INT 0
111780: PPUSH
// begin if not units then
111781: LD_VAR 0 1
111785: NOT
111786: IFFALSE 111790
// exit ;
111788: GO 111790
// end ;
111790: PPOPN 7
111792: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
111793: CALL 95998 0 0
// end ;
111797: PPOPN 1
111799: END
