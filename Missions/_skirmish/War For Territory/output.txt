// starting begin ResetFog ;
   0: CALL_OW 335
// InitVariables ;
   4: CALL 180 0 0
// if debug then
   8: LD_EXP 1
  12: IFFALSE 21
// begin FogOff ( 1 ) ;
  14: LD_INT 1
  16: PPUSH
  17: CALL_OW 344
// end ; ChangeSideFog ( 4 , 1 ) ;
  21: LD_INT 4
  23: PPUSH
  24: LD_INT 1
  26: PPUSH
  27: CALL_OW 343
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , gensher_ape , 0 ) ;
  31: LD_INT 0
  33: PPUSH
  34: LD_INT 0
  36: PPUSH
  37: LD_INT 3
  39: PPUSH
  40: LD_INT 0
  42: PPUSH
  43: LD_INT 0
  45: PPUSH
  46: LD_INT 0
  48: PPUSH
  49: LD_INT 0
  51: PPUSH
  52: LD_INT 7
  54: PPUSH
  55: LD_INT 0
  57: PPUSH
  58: CALL 37429 0 9
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , powell_ape , 0 ) ;
  62: LD_INT 0
  64: PPUSH
  65: LD_INT 0
  67: PPUSH
  68: LD_INT 3
  70: PPUSH
  71: LD_INT 0
  73: PPUSH
  74: LD_INT 0
  76: PPUSH
  77: LD_INT 0
  79: PPUSH
  80: LD_INT 0
  82: PPUSH
  83: LD_INT 4
  85: PPUSH
  86: LD_INT 0
  88: PPUSH
  89: CALL 37429 0 9
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , popov_ape , 0 ) ;
  93: LD_INT 0
  95: PPUSH
  96: LD_INT 0
  98: PPUSH
  99: LD_INT 3
 101: PPUSH
 102: LD_INT 0
 104: PPUSH
 105: LD_INT 0
 107: PPUSH
 108: LD_INT 0
 110: PPUSH
 111: LD_INT 0
 113: PPUSH
 114: LD_INT 11
 116: PPUSH
 117: LD_INT 0
 119: PPUSH
 120: CALL 37429 0 9
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , sikorski_ape , 0 ) ;
 124: LD_INT 0
 126: PPUSH
 127: LD_INT 0
 129: PPUSH
 130: LD_INT 3
 132: PPUSH
 133: LD_INT 0
 135: PPUSH
 136: LD_INT 0
 138: PPUSH
 139: LD_INT 0
 141: PPUSH
 142: LD_INT 0
 144: PPUSH
 145: LD_INT 14
 147: PPUSH
 148: LD_INT 0
 150: PPUSH
 151: CALL 37429 0 9
// PrepareGensher ;
 155: CALL 1331 0 0
// PreparePopov ;
 159: CALL 2581 0 0
// PreparePowell ;
 163: CALL 394 0 0
// PrepareSikorski ;
 167: CALL 3705 0 0
// MC_Start ( ) ;
 171: CALL 44249 0 0
// Action ;
 175: CALL 4112 0 0
// end ;
 179: END
// export debug , game , staticMines ; function InitVariables ; begin
 180: LD_INT 0
 182: PPUSH
// debug := false ;
 183: LD_ADDR_EXP 1
 187: PUSH
 188: LD_INT 0
 190: ST_TO_ADDR
// game := true ;
 191: LD_ADDR_EXP 2
 195: PUSH
 196: LD_INT 1
 198: ST_TO_ADDR
// staticMines := [ ] ;
 199: LD_ADDR_EXP 3
 203: PUSH
 204: EMPTY
 205: ST_TO_ADDR
// end ;
 206: LD_VAR 0 1
 210: RET
// export function CustomInitMacro ; begin
 211: LD_INT 0
 213: PPUSH
// InitMC_Gensher ( ) ;
 214: CALL 1719 0 0
// InitMC_Powell ( ) ;
 218: CALL 609 0 0
// InitMC_Popov ( ) ;
 222: CALL 2907 0 0
// end ;
 226: LD_VAR 0 1
 230: RET
// every 0 0$10 do var cr , time , i ;
 231: GO 233
 233: DISABLE
 234: LD_INT 0
 236: PPUSH
 237: PPUSH
 238: PPUSH
// begin time := 0 0$30 ;
 239: LD_ADDR_VAR 0 2
 243: PUSH
 244: LD_INT 1050
 246: ST_TO_ADDR
// repeat wait ( time ) ;
 247: LD_VAR 0 2
 251: PPUSH
 252: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
 256: LD_ADDR_VAR 0 1
 260: PUSH
 261: LD_INT 1
 263: PPUSH
 264: LD_INT 5
 266: PPUSH
 267: CALL_OW 12
 271: ST_TO_ADDR
// for i in [ powell_crates , gensher_crates , popov_crates , sikorski_crates ] do
 272: LD_ADDR_VAR 0 3
 276: PUSH
 277: LD_INT 5
 279: PUSH
 280: LD_INT 8
 282: PUSH
 283: LD_INT 12
 285: PUSH
 286: LD_INT 13
 288: PUSH
 289: EMPTY
 290: LIST
 291: LIST
 292: LIST
 293: LIST
 294: PUSH
 295: FOR_IN
 296: IFFALSE 350
// begin if GetResourceArea ( i , mat_cans ) < 20 then
 298: LD_VAR 0 3
 302: PPUSH
 303: LD_INT 1
 305: PPUSH
 306: CALL_OW 287
 310: PUSH
 311: LD_INT 20
 313: LESS
 314: IFFALSE 333
// CreateCratesArea ( cr , i , true ) ;
 316: LD_VAR 0 1
 320: PPUSH
 321: LD_VAR 0 3
 325: PPUSH
 326: LD_INT 1
 328: PPUSH
 329: CALL_OW 55
// wait ( rand ( 0 0$5 , 0 0$20 ) ) ;
 333: LD_INT 175
 335: PPUSH
 336: LD_INT 700
 338: PPUSH
 339: CALL_OW 12
 343: PPUSH
 344: CALL_OW 67
// end ;
 348: GO 295
 350: POP
 351: POP
// time := time + 0 0$2 ;
 352: LD_ADDR_VAR 0 2
 356: PUSH
 357: LD_VAR 0 2
 361: PUSH
 362: LD_INT 70
 364: PLUS
 365: ST_TO_ADDR
// if time > 1 1$00 then
 366: LD_VAR 0 2
 370: PUSH
 371: LD_INT 2100
 373: GREATER
 374: IFFALSE 384
// time := 0 0$25 ;
 376: LD_ADDR_VAR 0 2
 380: PUSH
 381: LD_INT 875
 383: ST_TO_ADDR
// until not game ;
 384: LD_EXP 2
 388: NOT
 389: IFFALSE 247
// end ; end_of_file
 391: PPOPN 3
 393: END
// export Powell , powell_side ; export function PreparePowell ; var i , tmp ; begin
 394: LD_INT 0
 396: PPUSH
 397: PPUSH
 398: PPUSH
// powell_side := 4 ;
 399: LD_ADDR_EXP 5
 403: PUSH
 404: LD_INT 4
 406: ST_TO_ADDR
// uc_side := powell_side ;
 407: LD_ADDR_OWVAR 20
 411: PUSH
 412: LD_EXP 5
 416: ST_TO_ADDR
// uc_nation := 1 ;
 417: LD_ADDR_OWVAR 21
 421: PUSH
 422: LD_INT 1
 424: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
 425: LD_ADDR_EXP 4
 429: PUSH
 430: LD_STRING Powell
 432: PPUSH
 433: CALL_OW 25
 437: ST_TO_ADDR
// SetSkill ( Powell , 1 , 7 ) ;
 438: LD_EXP 4
 442: PPUSH
 443: LD_INT 1
 445: PPUSH
 446: LD_INT 7
 448: PPUSH
 449: CALL_OW 237
// SetSkill ( Powell , 2 , 5 ) ;
 453: LD_EXP 4
 457: PPUSH
 458: LD_INT 2
 460: PPUSH
 461: LD_INT 5
 463: PPUSH
 464: CALL_OW 237
// SetSkill ( Powell , 3 , 6 ) ;
 468: LD_EXP 4
 472: PPUSH
 473: LD_INT 3
 475: PPUSH
 476: LD_INT 6
 478: PPUSH
 479: CALL_OW 237
// SetSkill ( Powell , 4 , 4 ) ;
 483: LD_EXP 4
 487: PPUSH
 488: LD_INT 4
 490: PPUSH
 491: LD_INT 4
 493: PPUSH
 494: CALL_OW 237
// PlaceHumanInUnit ( Powell , us_depot ) ;
 498: LD_EXP 4
 502: PPUSH
 503: LD_INT 4
 505: PPUSH
 506: CALL_OW 52
// tmp := PrepareBase ( us_depot , powell_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 1000 , 100 , 0 ] , [ 4 , 4 , 4 , 4 ] ) ;
 510: LD_ADDR_VAR 0 3
 514: PUSH
 515: LD_INT 4
 517: PPUSH
 518: LD_INT 1
 520: PPUSH
 521: LD_STRING 
 523: PPUSH
 524: LD_INT 8
 526: PUSH
 527: LD_INT 7
 529: PUSH
 530: LD_INT 6
 532: PUSH
 533: EMPTY
 534: LIST
 535: LIST
 536: LIST
 537: PUSH
 538: LD_OWVAR 67
 542: ARRAY
 543: PPUSH
 544: LD_INT 1000
 546: PUSH
 547: LD_INT 100
 549: PUSH
 550: LD_INT 0
 552: PUSH
 553: EMPTY
 554: LIST
 555: LIST
 556: LIST
 557: PPUSH
 558: LD_INT 4
 560: PUSH
 561: LD_INT 4
 563: PUSH
 564: LD_INT 4
 566: PUSH
 567: LD_INT 4
 569: PUSH
 570: EMPTY
 571: LIST
 572: LIST
 573: LIST
 574: LIST
 575: PPUSH
 576: CALL 12746 0 6
 580: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , tmp ) ;
 581: LD_ADDR_EXP 14
 585: PUSH
 586: LD_EXP 14
 590: PPUSH
 591: LD_INT 1
 593: PPUSH
 594: LD_VAR 0 3
 598: PPUSH
 599: CALL_OW 1
 603: ST_TO_ADDR
// end ;
 604: LD_VAR 0 1
 608: RET
// export function InitMC_Powell ( ) ; begin
 609: LD_INT 0
 611: PPUSH
// MC_SetScanArea ( 1 , powell_base ) ;
 612: LD_INT 1
 614: PPUSH
 615: LD_INT 1
 617: PPUSH
 618: CALL 67158 0 2
// MC_SetParkingArea ( 1 , powell_parking ) ;
 622: LD_INT 1
 624: PPUSH
 625: LD_INT 6
 627: PPUSH
 628: CALL 67102 0 2
// MC_SetDepositsXY ( 1 , [ [ 167 , 102 , 0 ] , [ 173 , 83 , 1 ] , [ 171 , 141 , 0 ] , [ 178 , 148 , 1 ] ] ) ;
 632: LD_INT 1
 634: PPUSH
 635: LD_INT 167
 637: PUSH
 638: LD_INT 102
 640: PUSH
 641: LD_INT 0
 643: PUSH
 644: EMPTY
 645: LIST
 646: LIST
 647: LIST
 648: PUSH
 649: LD_INT 173
 651: PUSH
 652: LD_INT 83
 654: PUSH
 655: LD_INT 1
 657: PUSH
 658: EMPTY
 659: LIST
 660: LIST
 661: LIST
 662: PUSH
 663: LD_INT 171
 665: PUSH
 666: LD_INT 141
 668: PUSH
 669: LD_INT 0
 671: PUSH
 672: EMPTY
 673: LIST
 674: LIST
 675: LIST
 676: PUSH
 677: LD_INT 178
 679: PUSH
 680: LD_INT 148
 682: PUSH
 683: LD_INT 1
 685: PUSH
 686: EMPTY
 687: LIST
 688: LIST
 689: LIST
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PPUSH
 697: CALL 66161 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ us_radar , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
 701: LD_INT 1
 703: PPUSH
 704: LD_INT 11
 706: PUSH
 707: LD_INT 6
 709: PUSH
 710: LD_INT 7
 712: PUSH
 713: LD_INT 9
 715: PUSH
 716: LD_INT 10
 718: PUSH
 719: EMPTY
 720: LIST
 721: LIST
 722: LIST
 723: LIST
 724: LIST
 725: PPUSH
 726: CALL 66990 0 2
// MC_SetCratesArea ( 1 , powell_crates ) ;
 730: LD_INT 1
 732: PPUSH
 733: LD_INT 5
 735: PPUSH
 736: CALL 66672 0 2
// MC_SetTame ( 1 , powell_ape ) ;
 740: LD_INT 1
 742: PPUSH
 743: LD_INT 4
 745: PPUSH
 746: CALL 66403 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 750: LD_INT 1
 752: PPUSH
 753: LD_INT 4
 755: PPUSH
 756: CALL 66022 0 2
// MC_SetProduceList ( 1 , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] ] ) ;
 760: LD_INT 1
 762: PPUSH
 763: LD_INT 3
 765: PUSH
 766: LD_INT 1
 768: PUSH
 769: LD_INT 2
 771: PUSH
 772: LD_INT 5
 774: PUSH
 775: EMPTY
 776: LIST
 777: LIST
 778: LIST
 779: LIST
 780: PUSH
 781: LD_INT 4
 783: PUSH
 784: LD_INT 1
 786: PUSH
 787: LD_INT 2
 789: PUSH
 790: LD_INT 6
 792: PUSH
 793: EMPTY
 794: LIST
 795: LIST
 796: LIST
 797: LIST
 798: PUSH
 799: LD_INT 4
 801: PUSH
 802: LD_INT 1
 804: PUSH
 805: LD_INT 2
 807: PUSH
 808: LD_INT 7
 810: PUSH
 811: EMPTY
 812: LIST
 813: LIST
 814: LIST
 815: LIST
 816: PUSH
 817: LD_INT 4
 819: PUSH
 820: LD_INT 1
 822: PUSH
 823: LD_INT 2
 825: PUSH
 826: LD_INT 6
 828: PUSH
 829: EMPTY
 830: LIST
 831: LIST
 832: LIST
 833: LIST
 834: PUSH
 835: LD_INT 5
 837: PUSH
 838: LD_INT 1
 840: PUSH
 841: LD_INT 2
 843: PUSH
 844: LD_INT 6
 846: PUSH
 847: EMPTY
 848: LIST
 849: LIST
 850: LIST
 851: LIST
 852: PUSH
 853: EMPTY
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: LIST
 859: PPUSH
 860: CALL 65837 0 2
// MC_SetBuildingList ( 1 , [ [ b_lab , 200 , 111 , 4 ] , [ b_oil_mine , 167 , 102 , 0 ] , [ b_armoury , 178 , 117 , 2 ] , [ b_workshop , 197 , 144 , 4 ] , [ b_solar_power , 206 , 124 , 3 ] , [ b_solar_power , 209 , 128 , 3 ] , [ b_solar_power , 211 , 132 , 3 ] , [ b_siberite_mine , 173 , 83 , 3 ] , [ b_lab , 186 , 103 , 2 ] , [ b_turret , 173 , 99 , 2 ] , [ b_bunker , 174 , 102 , 2 ] , [ b_bunker , 178 , 100 , 2 ] , [ b_turret , 174 , 108 , 1 ] , [ b_turret , 182 , 122 , 1 ] , [ b_control_tower , 194 , 124 , 5 ] , [ b_siberite_power , 204 , 133 , 3 ] , [ b_solar_power , 201 , 133 , 3 ] , [ b_siberite_power , 199 , 119 , 5 ] , [ b_turret , 184 , 141 , 1 ] , [ b_turret , 183 , 131 , 2 ] ] ) ;
 864: LD_INT 1
 866: PPUSH
 867: LD_INT 6
 869: PUSH
 870: LD_INT 200
 872: PUSH
 873: LD_INT 111
 875: PUSH
 876: LD_INT 4
 878: PUSH
 879: EMPTY
 880: LIST
 881: LIST
 882: LIST
 883: LIST
 884: PUSH
 885: LD_INT 29
 887: PUSH
 888: LD_INT 167
 890: PUSH
 891: LD_INT 102
 893: PUSH
 894: LD_INT 0
 896: PUSH
 897: EMPTY
 898: LIST
 899: LIST
 900: LIST
 901: LIST
 902: PUSH
 903: LD_INT 4
 905: PUSH
 906: LD_INT 178
 908: PUSH
 909: LD_INT 117
 911: PUSH
 912: LD_INT 2
 914: PUSH
 915: EMPTY
 916: LIST
 917: LIST
 918: LIST
 919: LIST
 920: PUSH
 921: LD_INT 2
 923: PUSH
 924: LD_INT 197
 926: PUSH
 927: LD_INT 144
 929: PUSH
 930: LD_INT 4
 932: PUSH
 933: EMPTY
 934: LIST
 935: LIST
 936: LIST
 937: LIST
 938: PUSH
 939: LD_INT 27
 941: PUSH
 942: LD_INT 206
 944: PUSH
 945: LD_INT 124
 947: PUSH
 948: LD_INT 3
 950: PUSH
 951: EMPTY
 952: LIST
 953: LIST
 954: LIST
 955: LIST
 956: PUSH
 957: LD_INT 27
 959: PUSH
 960: LD_INT 209
 962: PUSH
 963: LD_INT 128
 965: PUSH
 966: LD_INT 3
 968: PUSH
 969: EMPTY
 970: LIST
 971: LIST
 972: LIST
 973: LIST
 974: PUSH
 975: LD_INT 27
 977: PUSH
 978: LD_INT 211
 980: PUSH
 981: LD_INT 132
 983: PUSH
 984: LD_INT 3
 986: PUSH
 987: EMPTY
 988: LIST
 989: LIST
 990: LIST
 991: LIST
 992: PUSH
 993: LD_INT 30
 995: PUSH
 996: LD_INT 173
 998: PUSH
 999: LD_INT 83
1001: PUSH
1002: LD_INT 3
1004: PUSH
1005: EMPTY
1006: LIST
1007: LIST
1008: LIST
1009: LIST
1010: PUSH
1011: LD_INT 6
1013: PUSH
1014: LD_INT 186
1016: PUSH
1017: LD_INT 103
1019: PUSH
1020: LD_INT 2
1022: PUSH
1023: EMPTY
1024: LIST
1025: LIST
1026: LIST
1027: LIST
1028: PUSH
1029: LD_INT 33
1031: PUSH
1032: LD_INT 173
1034: PUSH
1035: LD_INT 99
1037: PUSH
1038: LD_INT 2
1040: PUSH
1041: EMPTY
1042: LIST
1043: LIST
1044: LIST
1045: LIST
1046: PUSH
1047: LD_INT 32
1049: PUSH
1050: LD_INT 174
1052: PUSH
1053: LD_INT 102
1055: PUSH
1056: LD_INT 2
1058: PUSH
1059: EMPTY
1060: LIST
1061: LIST
1062: LIST
1063: LIST
1064: PUSH
1065: LD_INT 32
1067: PUSH
1068: LD_INT 178
1070: PUSH
1071: LD_INT 100
1073: PUSH
1074: LD_INT 2
1076: PUSH
1077: EMPTY
1078: LIST
1079: LIST
1080: LIST
1081: LIST
1082: PUSH
1083: LD_INT 33
1085: PUSH
1086: LD_INT 174
1088: PUSH
1089: LD_INT 108
1091: PUSH
1092: LD_INT 1
1094: PUSH
1095: EMPTY
1096: LIST
1097: LIST
1098: LIST
1099: LIST
1100: PUSH
1101: LD_INT 33
1103: PUSH
1104: LD_INT 182
1106: PUSH
1107: LD_INT 122
1109: PUSH
1110: LD_INT 1
1112: PUSH
1113: EMPTY
1114: LIST
1115: LIST
1116: LIST
1117: LIST
1118: PUSH
1119: LD_INT 36
1121: PUSH
1122: LD_INT 194
1124: PUSH
1125: LD_INT 124
1127: PUSH
1128: LD_INT 5
1130: PUSH
1131: EMPTY
1132: LIST
1133: LIST
1134: LIST
1135: LIST
1136: PUSH
1137: LD_INT 28
1139: PUSH
1140: LD_INT 204
1142: PUSH
1143: LD_INT 133
1145: PUSH
1146: LD_INT 3
1148: PUSH
1149: EMPTY
1150: LIST
1151: LIST
1152: LIST
1153: LIST
1154: PUSH
1155: LD_INT 27
1157: PUSH
1158: LD_INT 201
1160: PUSH
1161: LD_INT 133
1163: PUSH
1164: LD_INT 3
1166: PUSH
1167: EMPTY
1168: LIST
1169: LIST
1170: LIST
1171: LIST
1172: PUSH
1173: LD_INT 28
1175: PUSH
1176: LD_INT 199
1178: PUSH
1179: LD_INT 119
1181: PUSH
1182: LD_INT 5
1184: PUSH
1185: EMPTY
1186: LIST
1187: LIST
1188: LIST
1189: LIST
1190: PUSH
1191: LD_INT 33
1193: PUSH
1194: LD_INT 184
1196: PUSH
1197: LD_INT 141
1199: PUSH
1200: LD_INT 1
1202: PUSH
1203: EMPTY
1204: LIST
1205: LIST
1206: LIST
1207: LIST
1208: PUSH
1209: LD_INT 33
1211: PUSH
1212: LD_INT 183
1214: PUSH
1215: LD_INT 131
1217: PUSH
1218: LD_INT 2
1220: PUSH
1221: EMPTY
1222: LIST
1223: LIST
1224: LIST
1225: LIST
1226: PUSH
1227: EMPTY
1228: LIST
1229: LIST
1230: LIST
1231: LIST
1232: LIST
1233: LIST
1234: LIST
1235: LIST
1236: LIST
1237: LIST
1238: LIST
1239: LIST
1240: LIST
1241: LIST
1242: LIST
1243: LIST
1244: LIST
1245: LIST
1246: LIST
1247: LIST
1248: PPUSH
1249: CALL 65729 0 2
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_opto , b_lab_computer , b_lab_siberium ] ) ;
1253: LD_INT 1
1255: PPUSH
1256: LD_INT 10
1258: PUSH
1259: LD_INT 15
1261: PUSH
1262: LD_INT 12
1264: PUSH
1265: LD_INT 11
1267: PUSH
1268: EMPTY
1269: LIST
1270: LIST
1271: LIST
1272: LIST
1273: PPUSH
1274: CALL 66579 0 2
// MC_SetFactoryExtension ( 1 , 197 , 144 , 4 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1278: LD_INT 1
1280: PPUSH
1281: LD_INT 197
1283: PPUSH
1284: LD_INT 144
1286: PPUSH
1287: LD_INT 4
1289: PPUSH
1290: LD_INT 19
1292: PUSH
1293: LD_INT 16
1295: PUSH
1296: LD_INT 17
1298: PUSH
1299: LD_INT 18
1301: PUSH
1302: LD_INT 22
1304: PUSH
1305: EMPTY
1306: LIST
1307: LIST
1308: LIST
1309: LIST
1310: LIST
1311: PPUSH
1312: CALL 66784 0 5
// MC_SetUpgradeBuilding ( 1 , b_depot ) ;
1316: LD_INT 1
1318: PPUSH
1319: LD_INT 0
1321: PPUSH
1322: CALL 66452 0 2
// end ; end_of_file
1326: LD_VAR 0 1
1330: RET
// export Gensher , gensher_side ; export function PrepareGensher ; var i , tmp , un ; begin
1331: LD_INT 0
1333: PPUSH
1334: PPUSH
1335: PPUSH
1336: PPUSH
// gensher_side := 2 ;
1337: LD_ADDR_EXP 7
1341: PUSH
1342: LD_INT 2
1344: ST_TO_ADDR
// uc_side := gensher_side ;
1345: LD_ADDR_OWVAR 20
1349: PUSH
1350: LD_EXP 7
1354: ST_TO_ADDR
// uc_nation := 2 ;
1355: LD_ADDR_OWVAR 21
1359: PUSH
1360: LD_INT 2
1362: ST_TO_ADDR
// tmp := PrepareBase ( ar_depot , gensher_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 1500 , 300 , 30 ] , [ 4 , 4 , 4 , 4 ] ) ;
1363: LD_ADDR_VAR 0 3
1367: PUSH
1368: LD_INT 7
1370: PPUSH
1371: LD_INT 2
1373: PPUSH
1374: LD_STRING 
1376: PPUSH
1377: LD_INT 8
1379: PUSH
1380: LD_INT 7
1382: PUSH
1383: LD_INT 6
1385: PUSH
1386: EMPTY
1387: LIST
1388: LIST
1389: LIST
1390: PUSH
1391: LD_OWVAR 67
1395: ARRAY
1396: PPUSH
1397: LD_INT 1500
1399: PUSH
1400: LD_INT 300
1402: PUSH
1403: LD_INT 30
1405: PUSH
1406: EMPTY
1407: LIST
1408: LIST
1409: LIST
1410: PPUSH
1411: LD_INT 4
1413: PUSH
1414: LD_INT 4
1416: PUSH
1417: LD_INT 4
1419: PUSH
1420: LD_INT 4
1422: PUSH
1423: EMPTY
1424: LIST
1425: LIST
1426: LIST
1427: LIST
1428: PPUSH
1429: CALL 12746 0 6
1433: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp ) ;
1434: LD_ADDR_EXP 14
1438: PUSH
1439: LD_EXP 14
1443: PPUSH
1444: LD_INT 2
1446: PPUSH
1447: LD_VAR 0 3
1451: PPUSH
1452: CALL_OW 1
1456: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] ] ) ;
1457: LD_ADDR_VAR 0 3
1461: PUSH
1462: LD_INT 22
1464: PUSH
1465: LD_INT 2
1467: PUSH
1468: EMPTY
1469: LIST
1470: LIST
1471: PUSH
1472: LD_INT 30
1474: PUSH
1475: LD_INT 31
1477: PUSH
1478: EMPTY
1479: LIST
1480: LIST
1481: PUSH
1482: EMPTY
1483: LIST
1484: LIST
1485: PPUSH
1486: CALL_OW 69
1490: ST_TO_ADDR
// for i in tmp do
1491: LD_ADDR_VAR 0 2
1495: PUSH
1496: LD_VAR 0 3
1500: PUSH
1501: FOR_IN
1502: IFFALSE 1572
// begin PrepareHuman ( false , 1 , [ 4 , 3 , 3 ] [ Difficulty ] ) ;
1504: LD_INT 0
1506: PPUSH
1507: LD_INT 1
1509: PPUSH
1510: LD_INT 4
1512: PUSH
1513: LD_INT 3
1515: PUSH
1516: LD_INT 3
1518: PUSH
1519: EMPTY
1520: LIST
1521: LIST
1522: LIST
1523: PUSH
1524: LD_OWVAR 67
1528: ARRAY
1529: PPUSH
1530: CALL_OW 380
// un := CreateHuman ;
1534: LD_ADDR_VAR 0 4
1538: PUSH
1539: CALL_OW 44
1543: ST_TO_ADDR
// SetDir ( un , 1 ) ;
1544: LD_VAR 0 4
1548: PPUSH
1549: LD_INT 1
1551: PPUSH
1552: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
1556: LD_VAR 0 4
1560: PPUSH
1561: LD_VAR 0 2
1565: PPUSH
1566: CALL_OW 52
// end ;
1570: GO 1501
1572: POP
1573: POP
// tmp := AreaToList ( gensher_mines , 0 ) ;
1574: LD_ADDR_VAR 0 3
1578: PUSH
1579: LD_INT 15
1581: PPUSH
1582: LD_INT 0
1584: PPUSH
1585: CALL_OW 517
1589: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
1590: LD_ADDR_VAR 0 2
1594: PUSH
1595: DOUBLE
1596: LD_INT 1
1598: DEC
1599: ST_TO_ADDR
1600: LD_VAR 0 3
1604: PUSH
1605: LD_INT 1
1607: ARRAY
1608: PUSH
1609: FOR_TO
1610: IFFALSE 1712
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
1612: LD_VAR 0 3
1616: PUSH
1617: LD_INT 1
1619: ARRAY
1620: PUSH
1621: LD_VAR 0 2
1625: ARRAY
1626: PPUSH
1627: LD_VAR 0 3
1631: PUSH
1632: LD_INT 2
1634: ARRAY
1635: PUSH
1636: LD_VAR 0 2
1640: ARRAY
1641: PPUSH
1642: LD_INT 2
1644: PPUSH
1645: LD_INT 0
1647: PPUSH
1648: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
1652: LD_ADDR_EXP 3
1656: PUSH
1657: LD_EXP 3
1661: PPUSH
1662: LD_EXP 3
1666: PUSH
1667: LD_INT 1
1669: PLUS
1670: PPUSH
1671: LD_VAR 0 3
1675: PUSH
1676: LD_INT 1
1678: ARRAY
1679: PUSH
1680: LD_VAR 0 2
1684: ARRAY
1685: PUSH
1686: LD_VAR 0 3
1690: PUSH
1691: LD_INT 2
1693: ARRAY
1694: PUSH
1695: LD_VAR 0 2
1699: ARRAY
1700: PUSH
1701: EMPTY
1702: LIST
1703: LIST
1704: PPUSH
1705: CALL_OW 2
1709: ST_TO_ADDR
// end ;
1710: GO 1609
1712: POP
1713: POP
// end ;
1714: LD_VAR 0 1
1718: RET
// export function InitMC_Gensher ( ) ; begin
1719: LD_INT 0
1721: PPUSH
// MC_SetScanArea ( 2 , gensher_base ) ;
1722: LD_INT 2
1724: PPUSH
1725: LD_INT 2
1727: PPUSH
1728: CALL 67158 0 2
// MC_SetParkingArea ( 2 , gensher_parking ) ;
1732: LD_INT 2
1734: PPUSH
1735: LD_INT 9
1737: PPUSH
1738: CALL 67102 0 2
// MC_SetDepositsXY ( 2 , [ [ 56 , 23 , 0 ] , [ 52 , 40 , 1 ] ] ) ;
1742: LD_INT 2
1744: PPUSH
1745: LD_INT 56
1747: PUSH
1748: LD_INT 23
1750: PUSH
1751: LD_INT 0
1753: PUSH
1754: EMPTY
1755: LIST
1756: LIST
1757: LIST
1758: PUSH
1759: LD_INT 52
1761: PUSH
1762: LD_INT 40
1764: PUSH
1765: LD_INT 1
1767: PUSH
1768: EMPTY
1769: LIST
1770: LIST
1771: LIST
1772: PUSH
1773: EMPTY
1774: LIST
1775: LIST
1776: PPUSH
1777: CALL 66161 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ar_gun , ar_rocket_launcher ] ) ;
1781: LD_INT 2
1783: PPUSH
1784: LD_INT 27
1786: PUSH
1787: LD_INT 28
1789: PUSH
1790: EMPTY
1791: LIST
1792: LIST
1793: PPUSH
1794: CALL 66990 0 2
// MC_SetCratesArea ( 2 , gensher_crates ) ;
1798: LD_INT 2
1800: PPUSH
1801: LD_INT 8
1803: PPUSH
1804: CALL 66672 0 2
// MC_SetTame ( 2 , gensher_ape ) ;
1808: LD_INT 2
1810: PPUSH
1811: LD_INT 7
1813: PPUSH
1814: CALL 66403 0 2
// MC_SetDefenderLimit ( 2 , 4 ) ;
1818: LD_INT 2
1820: PPUSH
1821: LD_INT 4
1823: PPUSH
1824: CALL 66022 0 2
// MC_SetProduceList ( 2 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_flame_thrower ] ] ) ;
1828: LD_INT 2
1830: PPUSH
1831: LD_INT 13
1833: PUSH
1834: LD_INT 2
1836: PUSH
1837: LD_INT 1
1839: PUSH
1840: LD_INT 31
1842: PUSH
1843: EMPTY
1844: LIST
1845: LIST
1846: LIST
1847: LIST
1848: PUSH
1849: LD_INT 13
1851: PUSH
1852: LD_INT 2
1854: PUSH
1855: LD_INT 1
1857: PUSH
1858: LD_INT 31
1860: PUSH
1861: EMPTY
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: PUSH
1867: LD_INT 14
1869: PUSH
1870: LD_INT 1
1872: PUSH
1873: LD_INT 2
1875: PUSH
1876: LD_INT 27
1878: PUSH
1879: EMPTY
1880: LIST
1881: LIST
1882: LIST
1883: LIST
1884: PUSH
1885: LD_INT 14
1887: PUSH
1888: LD_INT 1
1890: PUSH
1891: LD_INT 2
1893: PUSH
1894: LD_INT 27
1896: PUSH
1897: EMPTY
1898: LIST
1899: LIST
1900: LIST
1901: LIST
1902: PUSH
1903: LD_INT 14
1905: PUSH
1906: LD_INT 1
1908: PUSH
1909: LD_INT 2
1911: PUSH
1912: LD_INT 28
1914: PUSH
1915: EMPTY
1916: LIST
1917: LIST
1918: LIST
1919: LIST
1920: PUSH
1921: LD_INT 14
1923: PUSH
1924: LD_INT 1
1926: PUSH
1927: LD_INT 1
1929: PUSH
1930: LD_INT 26
1932: PUSH
1933: EMPTY
1934: LIST
1935: LIST
1936: LIST
1937: LIST
1938: PUSH
1939: EMPTY
1940: LIST
1941: LIST
1942: LIST
1943: LIST
1944: LIST
1945: LIST
1946: PPUSH
1947: CALL 65837 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 13 , 18 , 1 ] , [ b_lab , 17 , 27 , 1 ] , [ b_solar_power , 17 , 3 , 0 ] , [ b_oil_mine , 56 , 23 , 0 ] , [ b_armoury , 42 , 29 , 5 ] , [ b_workshop , 11 , 7 , 2 ] , [ b_solar_power , 20 , 3 , 0 ] , [ b_solar_power , 23 , 3 , 0 ] , [ b_solar_power , 26 , 3 , 0 ] , [ b_bunker , 27 , 44 , 5 ] , [ b_bunker , 41 , 41 , 5 ] , [ b_bunker , 45 , 24 , 5 ] , [ b_bunker , 48 , 19 , 5 ] , [ b_bunker , 41 , 3 , 4 ] , [ b_armoury , 44 , 9 , 4 ] , [ b_siberite_mine , 52 , 40 , 3 ] ] ) ;
1951: LD_INT 2
1953: PPUSH
1954: LD_INT 6
1956: PUSH
1957: LD_INT 13
1959: PUSH
1960: LD_INT 18
1962: PUSH
1963: LD_INT 1
1965: PUSH
1966: EMPTY
1967: LIST
1968: LIST
1969: LIST
1970: LIST
1971: PUSH
1972: LD_INT 6
1974: PUSH
1975: LD_INT 17
1977: PUSH
1978: LD_INT 27
1980: PUSH
1981: LD_INT 1
1983: PUSH
1984: EMPTY
1985: LIST
1986: LIST
1987: LIST
1988: LIST
1989: PUSH
1990: LD_INT 27
1992: PUSH
1993: LD_INT 17
1995: PUSH
1996: LD_INT 3
1998: PUSH
1999: LD_INT 0
2001: PUSH
2002: EMPTY
2003: LIST
2004: LIST
2005: LIST
2006: LIST
2007: PUSH
2008: LD_INT 29
2010: PUSH
2011: LD_INT 56
2013: PUSH
2014: LD_INT 23
2016: PUSH
2017: LD_INT 0
2019: PUSH
2020: EMPTY
2021: LIST
2022: LIST
2023: LIST
2024: LIST
2025: PUSH
2026: LD_INT 4
2028: PUSH
2029: LD_INT 42
2031: PUSH
2032: LD_INT 29
2034: PUSH
2035: LD_INT 5
2037: PUSH
2038: EMPTY
2039: LIST
2040: LIST
2041: LIST
2042: LIST
2043: PUSH
2044: LD_INT 2
2046: PUSH
2047: LD_INT 11
2049: PUSH
2050: LD_INT 7
2052: PUSH
2053: LD_INT 2
2055: PUSH
2056: EMPTY
2057: LIST
2058: LIST
2059: LIST
2060: LIST
2061: PUSH
2062: LD_INT 27
2064: PUSH
2065: LD_INT 20
2067: PUSH
2068: LD_INT 3
2070: PUSH
2071: LD_INT 0
2073: PUSH
2074: EMPTY
2075: LIST
2076: LIST
2077: LIST
2078: LIST
2079: PUSH
2080: LD_INT 27
2082: PUSH
2083: LD_INT 23
2085: PUSH
2086: LD_INT 3
2088: PUSH
2089: LD_INT 0
2091: PUSH
2092: EMPTY
2093: LIST
2094: LIST
2095: LIST
2096: LIST
2097: PUSH
2098: LD_INT 27
2100: PUSH
2101: LD_INT 26
2103: PUSH
2104: LD_INT 3
2106: PUSH
2107: LD_INT 0
2109: PUSH
2110: EMPTY
2111: LIST
2112: LIST
2113: LIST
2114: LIST
2115: PUSH
2116: LD_INT 32
2118: PUSH
2119: LD_INT 27
2121: PUSH
2122: LD_INT 44
2124: PUSH
2125: LD_INT 5
2127: PUSH
2128: EMPTY
2129: LIST
2130: LIST
2131: LIST
2132: LIST
2133: PUSH
2134: LD_INT 32
2136: PUSH
2137: LD_INT 41
2139: PUSH
2140: LD_INT 41
2142: PUSH
2143: LD_INT 5
2145: PUSH
2146: EMPTY
2147: LIST
2148: LIST
2149: LIST
2150: LIST
2151: PUSH
2152: LD_INT 32
2154: PUSH
2155: LD_INT 45
2157: PUSH
2158: LD_INT 24
2160: PUSH
2161: LD_INT 5
2163: PUSH
2164: EMPTY
2165: LIST
2166: LIST
2167: LIST
2168: LIST
2169: PUSH
2170: LD_INT 32
2172: PUSH
2173: LD_INT 48
2175: PUSH
2176: LD_INT 19
2178: PUSH
2179: LD_INT 5
2181: PUSH
2182: EMPTY
2183: LIST
2184: LIST
2185: LIST
2186: LIST
2187: PUSH
2188: LD_INT 32
2190: PUSH
2191: LD_INT 41
2193: PUSH
2194: LD_INT 3
2196: PUSH
2197: LD_INT 4
2199: PUSH
2200: EMPTY
2201: LIST
2202: LIST
2203: LIST
2204: LIST
2205: PUSH
2206: LD_INT 4
2208: PUSH
2209: LD_INT 44
2211: PUSH
2212: LD_INT 9
2214: PUSH
2215: LD_INT 4
2217: PUSH
2218: EMPTY
2219: LIST
2220: LIST
2221: LIST
2222: LIST
2223: PUSH
2224: LD_INT 30
2226: PUSH
2227: LD_INT 52
2229: PUSH
2230: LD_INT 40
2232: PUSH
2233: LD_INT 3
2235: PUSH
2236: EMPTY
2237: LIST
2238: LIST
2239: LIST
2240: LIST
2241: PUSH
2242: EMPTY
2243: LIST
2244: LIST
2245: LIST
2246: LIST
2247: LIST
2248: LIST
2249: LIST
2250: LIST
2251: LIST
2252: LIST
2253: LIST
2254: LIST
2255: LIST
2256: LIST
2257: LIST
2258: LIST
2259: PPUSH
2260: CALL 65729 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_opto , b_lab_biological , b_lab_siberium ] ) ;
2264: LD_INT 2
2266: PPUSH
2267: LD_INT 10
2269: PUSH
2270: LD_INT 15
2272: PUSH
2273: LD_INT 13
2275: PUSH
2276: LD_INT 11
2278: PUSH
2279: EMPTY
2280: LIST
2281: LIST
2282: LIST
2283: LIST
2284: PPUSH
2285: CALL 66579 0 2
// MC_SetFactoryExtension ( 2 , 11 , 7 , 2 , [ b_ext_stitch , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
2289: LD_INT 2
2291: PPUSH
2292: LD_INT 11
2294: PPUSH
2295: LD_INT 7
2297: PPUSH
2298: LD_INT 2
2300: PPUSH
2301: LD_INT 23
2303: PUSH
2304: LD_INT 16
2306: PUSH
2307: LD_INT 17
2309: PUSH
2310: LD_INT 18
2312: PUSH
2313: LD_INT 22
2315: PUSH
2316: EMPTY
2317: LIST
2318: LIST
2319: LIST
2320: LIST
2321: LIST
2322: PPUSH
2323: CALL 66784 0 5
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
2327: LD_INT 2
2329: PPUSH
2330: LD_INT 0
2332: PPUSH
2333: CALL 66452 0 2
// end ;
2337: LD_VAR 0 1
2341: RET
// every 10 trigger staticMines and FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) do var i , j , tmp , x , y ;
2342: LD_EXP 3
2346: PUSH
2347: LD_INT 15
2349: PPUSH
2350: LD_INT 81
2352: PUSH
2353: LD_INT 2
2355: PUSH
2356: EMPTY
2357: LIST
2358: LIST
2359: PPUSH
2360: CALL_OW 70
2364: AND
2365: IFFALSE 2578
2367: GO 2369
2369: DISABLE
2370: LD_INT 0
2372: PPUSH
2373: PPUSH
2374: PPUSH
2375: PPUSH
2376: PPUSH
// begin enable ;
2377: ENABLE
// tmp := FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) ;
2378: LD_ADDR_VAR 0 3
2382: PUSH
2383: LD_INT 15
2385: PPUSH
2386: LD_INT 81
2388: PUSH
2389: LD_INT 2
2391: PUSH
2392: EMPTY
2393: LIST
2394: LIST
2395: PPUSH
2396: CALL_OW 70
2400: ST_TO_ADDR
// if not tmp then
2401: LD_VAR 0 3
2405: NOT
2406: IFFALSE 2410
// exit ;
2408: GO 2578
// for i in tmp do
2410: LD_ADDR_VAR 0 1
2414: PUSH
2415: LD_VAR 0 3
2419: PUSH
2420: FOR_IN
2421: IFFALSE 2576
// begin x := GetX ( i ) ;
2423: LD_ADDR_VAR 0 4
2427: PUSH
2428: LD_VAR 0 1
2432: PPUSH
2433: CALL_OW 250
2437: ST_TO_ADDR
// y := GetY ( i ) ;
2438: LD_ADDR_VAR 0 5
2442: PUSH
2443: LD_VAR 0 1
2447: PPUSH
2448: CALL_OW 251
2452: ST_TO_ADDR
// if MineAtPos ( x , y ) then
2453: LD_VAR 0 4
2457: PPUSH
2458: LD_VAR 0 5
2462: PPUSH
2463: CALL_OW 458
2467: IFFALSE 2574
// begin LaunchMineAtPos ( x , y , 2 ) ;
2469: LD_VAR 0 4
2473: PPUSH
2474: LD_VAR 0 5
2478: PPUSH
2479: LD_INT 2
2481: PPUSH
2482: CALL_OW 456
// for j = 1 to staticMines do
2486: LD_ADDR_VAR 0 2
2490: PUSH
2491: DOUBLE
2492: LD_INT 1
2494: DEC
2495: ST_TO_ADDR
2496: LD_EXP 3
2500: PUSH
2501: FOR_TO
2502: IFFALSE 2572
// if staticMines [ j ] [ 1 ] = x and staticMines [ j ] [ 2 ] = y then
2504: LD_EXP 3
2508: PUSH
2509: LD_VAR 0 2
2513: ARRAY
2514: PUSH
2515: LD_INT 1
2517: ARRAY
2518: PUSH
2519: LD_VAR 0 4
2523: EQUAL
2524: PUSH
2525: LD_EXP 3
2529: PUSH
2530: LD_VAR 0 2
2534: ARRAY
2535: PUSH
2536: LD_INT 2
2538: ARRAY
2539: PUSH
2540: LD_VAR 0 5
2544: EQUAL
2545: AND
2546: IFFALSE 2570
// begin staticMines := Delete ( staticMines , j ) ;
2548: LD_ADDR_EXP 3
2552: PUSH
2553: LD_EXP 3
2557: PPUSH
2558: LD_VAR 0 2
2562: PPUSH
2563: CALL_OW 3
2567: ST_TO_ADDR
// break ;
2568: GO 2572
// end ;
2570: GO 2501
2572: POP
2573: POP
// end ; end ;
2574: GO 2420
2576: POP
2577: POP
// end ; end_of_file
2578: PPOPN 5
2580: END
// export Popov , popov_side , extraPopovForces ; export function PreparePopov ; var i , un , tmp ; begin
2581: LD_INT 0
2583: PPUSH
2584: PPUSH
2585: PPUSH
2586: PPUSH
// popov_side := 3 ;
2587: LD_ADDR_EXP 9
2591: PUSH
2592: LD_INT 3
2594: ST_TO_ADDR
// uc_side := popov_side ;
2595: LD_ADDR_OWVAR 20
2599: PUSH
2600: LD_EXP 9
2604: ST_TO_ADDR
// uc_nation := 3 ;
2605: LD_ADDR_OWVAR 21
2609: PUSH
2610: LD_INT 3
2612: ST_TO_ADDR
// tmp := PrepareBase ( ru_depot , popov_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 1500 , 300 , 30 ] , [ 4 , 4 , 4 , 4 ] ) ;
2613: LD_ADDR_VAR 0 4
2617: PUSH
2618: LD_INT 9
2620: PPUSH
2621: LD_INT 3
2623: PPUSH
2624: LD_STRING 
2626: PPUSH
2627: LD_INT 8
2629: PUSH
2630: LD_INT 7
2632: PUSH
2633: LD_INT 6
2635: PUSH
2636: EMPTY
2637: LIST
2638: LIST
2639: LIST
2640: PUSH
2641: LD_OWVAR 67
2645: ARRAY
2646: PPUSH
2647: LD_INT 1500
2649: PUSH
2650: LD_INT 300
2652: PUSH
2653: LD_INT 30
2655: PUSH
2656: EMPTY
2657: LIST
2658: LIST
2659: LIST
2660: PPUSH
2661: LD_INT 4
2663: PUSH
2664: LD_INT 4
2666: PUSH
2667: LD_INT 4
2669: PUSH
2670: LD_INT 4
2672: PUSH
2673: EMPTY
2674: LIST
2675: LIST
2676: LIST
2677: LIST
2678: PPUSH
2679: CALL 12746 0 6
2683: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 3 , tmp ) ;
2684: LD_ADDR_EXP 14
2688: PUSH
2689: LD_EXP 14
2693: PPUSH
2694: LD_INT 3
2696: PPUSH
2697: LD_VAR 0 4
2701: PPUSH
2702: CALL_OW 1
2706: ST_TO_ADDR
// extraPopovForces := [ ] ;
2707: LD_ADDR_EXP 10
2711: PUSH
2712: EMPTY
2713: ST_TO_ADDR
// for i := 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
2714: LD_ADDR_VAR 0 2
2718: PUSH
2719: DOUBLE
2720: LD_INT 1
2722: DEC
2723: ST_TO_ADDR
2724: LD_INT 4
2726: PUSH
2727: LD_INT 5
2729: PUSH
2730: LD_INT 6
2732: PUSH
2733: EMPTY
2734: LIST
2735: LIST
2736: LIST
2737: PUSH
2738: LD_OWVAR 67
2742: ARRAY
2743: PUSH
2744: FOR_TO
2745: IFFALSE 2848
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
2747: LD_INT 0
2749: PPUSH
2750: LD_INT 1
2752: PPUSH
2753: LD_INT 4
2755: PUSH
2756: LD_INT 5
2758: PUSH
2759: LD_INT 6
2761: PUSH
2762: EMPTY
2763: LIST
2764: LIST
2765: LIST
2766: PUSH
2767: LD_OWVAR 67
2771: ARRAY
2772: PPUSH
2773: CALL_OW 380
// un := CreateHuman ;
2777: LD_ADDR_VAR 0 3
2781: PUSH
2782: CALL_OW 44
2786: ST_TO_ADDR
// PlaceUnitXYR ( un , 131 , 110 , 8 , false ) ;
2787: LD_VAR 0 3
2791: PPUSH
2792: LD_INT 131
2794: PPUSH
2795: LD_INT 110
2797: PPUSH
2798: LD_INT 8
2800: PPUSH
2801: LD_INT 0
2803: PPUSH
2804: CALL_OW 50
// ComHold ( un ) ;
2808: LD_VAR 0 3
2812: PPUSH
2813: CALL_OW 140
// extraPopovForces := Replace ( extraPopovForces , extraPopovForces + 1 , un ) ;
2817: LD_ADDR_EXP 10
2821: PUSH
2822: LD_EXP 10
2826: PPUSH
2827: LD_EXP 10
2831: PUSH
2832: LD_INT 1
2834: PLUS
2835: PPUSH
2836: LD_VAR 0 3
2840: PPUSH
2841: CALL_OW 1
2845: ST_TO_ADDR
// end ;
2846: GO 2744
2848: POP
2849: POP
// PrepareSoldier ( false , 6 ) ;
2850: LD_INT 0
2852: PPUSH
2853: LD_INT 6
2855: PPUSH
2856: CALL_OW 381
// un := CreateHuman ;
2860: LD_ADDR_VAR 0 3
2864: PUSH
2865: CALL_OW 44
2869: ST_TO_ADDR
// SetDir ( un , 1 ) ;
2870: LD_VAR 0 3
2874: PPUSH
2875: LD_INT 1
2877: PPUSH
2878: CALL_OW 233
// PlaceHumanInUnit ( un , HexInfo ( 150 , 158 ) ) ;
2882: LD_VAR 0 3
2886: PPUSH
2887: LD_INT 150
2889: PPUSH
2890: LD_INT 158
2892: PPUSH
2893: CALL_OW 428
2897: PPUSH
2898: CALL_OW 52
// end ;
2902: LD_VAR 0 1
2906: RET
// export function InitMC_Popov ( ) ; begin
2907: LD_INT 0
2909: PPUSH
// MC_SetScanArea ( 3 , popov_base ) ;
2910: LD_INT 3
2912: PPUSH
2913: LD_INT 3
2915: PPUSH
2916: CALL 67158 0 2
// MC_SetParkingArea ( 3 , popov_parking ) ;
2920: LD_INT 3
2922: PPUSH
2923: LD_INT 10
2925: PPUSH
2926: CALL 67102 0 2
// MC_SetDepositsXY ( 3 , [ [ 86 , 118 , 0 ] , [ 123 , 151 , 1 ] , [ 106 , 113 , 0 ] ] ) ;
2930: LD_INT 3
2932: PPUSH
2933: LD_INT 86
2935: PUSH
2936: LD_INT 118
2938: PUSH
2939: LD_INT 0
2941: PUSH
2942: EMPTY
2943: LIST
2944: LIST
2945: LIST
2946: PUSH
2947: LD_INT 123
2949: PUSH
2950: LD_INT 151
2952: PUSH
2953: LD_INT 1
2955: PUSH
2956: EMPTY
2957: LIST
2958: LIST
2959: LIST
2960: PUSH
2961: LD_INT 106
2963: PUSH
2964: LD_INT 113
2966: PUSH
2967: LD_INT 0
2969: PUSH
2970: EMPTY
2971: LIST
2972: LIST
2973: LIST
2974: PUSH
2975: EMPTY
2976: LIST
2977: LIST
2978: LIST
2979: PPUSH
2980: CALL 66161 0 2
// MC_SetAllowedTurretWeapons ( 3 , [ ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ) ;
2984: LD_INT 3
2986: PPUSH
2987: LD_INT 46
2989: PUSH
2990: LD_INT 45
2992: PUSH
2993: LD_INT 47
2995: PUSH
2996: LD_INT 49
2998: PUSH
2999: EMPTY
3000: LIST
3001: LIST
3002: LIST
3003: LIST
3004: PPUSH
3005: CALL 66990 0 2
// MC_SetCratesArea ( 3 , popov_crates ) ;
3009: LD_INT 3
3011: PPUSH
3012: LD_INT 12
3014: PPUSH
3015: CALL 66672 0 2
// MC_SetTame ( 3 , popov_ape ) ;
3019: LD_INT 3
3021: PPUSH
3022: LD_INT 11
3024: PPUSH
3025: CALL 66403 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
3029: LD_INT 3
3031: PPUSH
3032: LD_INT 4
3034: PPUSH
3035: CALL 66022 0 2
// MC_SetProduceList ( 3 , [ [ ru_heavy_wheeled , engine_combustion , control_manual , ru_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] ] ) ;
3039: LD_INT 3
3041: PPUSH
3042: LD_INT 23
3044: PUSH
3045: LD_INT 1
3047: PUSH
3048: LD_INT 1
3050: PUSH
3051: LD_INT 44
3053: PUSH
3054: EMPTY
3055: LIST
3056: LIST
3057: LIST
3058: LIST
3059: PUSH
3060: LD_INT 23
3062: PUSH
3063: LD_INT 1
3065: PUSH
3066: LD_INT 3
3068: PUSH
3069: LD_INT 45
3071: PUSH
3072: EMPTY
3073: LIST
3074: LIST
3075: LIST
3076: LIST
3077: PUSH
3078: LD_INT 21
3080: PUSH
3081: LD_INT 1
3083: PUSH
3084: LD_INT 3
3086: PUSH
3087: LD_INT 43
3089: PUSH
3090: EMPTY
3091: LIST
3092: LIST
3093: LIST
3094: LIST
3095: PUSH
3096: LD_INT 21
3098: PUSH
3099: LD_INT 1
3101: PUSH
3102: LD_INT 3
3104: PUSH
3105: LD_INT 45
3107: PUSH
3108: EMPTY
3109: LIST
3110: LIST
3111: LIST
3112: LIST
3113: PUSH
3114: EMPTY
3115: LIST
3116: LIST
3117: LIST
3118: LIST
3119: PPUSH
3120: CALL 65837 0 2
// MC_SetBuildingList ( 3 , [ [ b_lab , 76 , 145 , 1 ] , [ b_oil_power , 87 , 144 , 0 ] , [ b_oil_mine , 86 , 118 , 0 ] , [ b_oil_mine , 106 , 113 , 0 ] , [ b_oil_power , 87 , 147 , 1 ] , [ b_workshop , 94 , 161 , 0 ] , [ b_lab , 81 , 155 , 1 ] , [ b_armoury , 103 , 147 , 3 ] , [ b_oil_power , 96 , 152 , 0 ] , [ b_oil_power , 96 , 149 , 3 ] , [ b_bunker , 109 , 142 , 3 ] , [ b_bunker , 112 , 148 , 3 ] , [ b_turret , 120 , 159 , 4 ] , [ b_turret , 122 , 163 , 4 ] , [ b_turret , 123 , 167 , 4 ] , [ b_turret , 59 , 111 , 3 ] , [ b_turret , 65 , 111 , 3 ] , [ b_turret , 76 , 117 , 3 ] , [ b_turret , 80 , 119 , 3 ] , [ b_turret , 87 , 125 , 3 ] , [ b_armoury , 92 , 129 , 3 ] , [ b_siberite_power , 85 , 165 , 0 ] , [ b_siberite_power , 83 , 161 , 4 ] , [ b_siberite_power , 91 , 166 , 3 ] , [ b_siberite_power , 102 , 166 , 2 ] , [ b_teleport , 91 , 147 , 3 ] ] ) ;
3124: LD_INT 3
3126: PPUSH
3127: LD_INT 6
3129: PUSH
3130: LD_INT 76
3132: PUSH
3133: LD_INT 145
3135: PUSH
3136: LD_INT 1
3138: PUSH
3139: EMPTY
3140: LIST
3141: LIST
3142: LIST
3143: LIST
3144: PUSH
3145: LD_INT 26
3147: PUSH
3148: LD_INT 87
3150: PUSH
3151: LD_INT 144
3153: PUSH
3154: LD_INT 0
3156: PUSH
3157: EMPTY
3158: LIST
3159: LIST
3160: LIST
3161: LIST
3162: PUSH
3163: LD_INT 29
3165: PUSH
3166: LD_INT 86
3168: PUSH
3169: LD_INT 118
3171: PUSH
3172: LD_INT 0
3174: PUSH
3175: EMPTY
3176: LIST
3177: LIST
3178: LIST
3179: LIST
3180: PUSH
3181: LD_INT 29
3183: PUSH
3184: LD_INT 106
3186: PUSH
3187: LD_INT 113
3189: PUSH
3190: LD_INT 0
3192: PUSH
3193: EMPTY
3194: LIST
3195: LIST
3196: LIST
3197: LIST
3198: PUSH
3199: LD_INT 26
3201: PUSH
3202: LD_INT 87
3204: PUSH
3205: LD_INT 147
3207: PUSH
3208: LD_INT 1
3210: PUSH
3211: EMPTY
3212: LIST
3213: LIST
3214: LIST
3215: LIST
3216: PUSH
3217: LD_INT 2
3219: PUSH
3220: LD_INT 94
3222: PUSH
3223: LD_INT 161
3225: PUSH
3226: LD_INT 0
3228: PUSH
3229: EMPTY
3230: LIST
3231: LIST
3232: LIST
3233: LIST
3234: PUSH
3235: LD_INT 6
3237: PUSH
3238: LD_INT 81
3240: PUSH
3241: LD_INT 155
3243: PUSH
3244: LD_INT 1
3246: PUSH
3247: EMPTY
3248: LIST
3249: LIST
3250: LIST
3251: LIST
3252: PUSH
3253: LD_INT 4
3255: PUSH
3256: LD_INT 103
3258: PUSH
3259: LD_INT 147
3261: PUSH
3262: LD_INT 3
3264: PUSH
3265: EMPTY
3266: LIST
3267: LIST
3268: LIST
3269: LIST
3270: PUSH
3271: LD_INT 26
3273: PUSH
3274: LD_INT 96
3276: PUSH
3277: LD_INT 152
3279: PUSH
3280: LD_INT 0
3282: PUSH
3283: EMPTY
3284: LIST
3285: LIST
3286: LIST
3287: LIST
3288: PUSH
3289: LD_INT 26
3291: PUSH
3292: LD_INT 96
3294: PUSH
3295: LD_INT 149
3297: PUSH
3298: LD_INT 3
3300: PUSH
3301: EMPTY
3302: LIST
3303: LIST
3304: LIST
3305: LIST
3306: PUSH
3307: LD_INT 32
3309: PUSH
3310: LD_INT 109
3312: PUSH
3313: LD_INT 142
3315: PUSH
3316: LD_INT 3
3318: PUSH
3319: EMPTY
3320: LIST
3321: LIST
3322: LIST
3323: LIST
3324: PUSH
3325: LD_INT 32
3327: PUSH
3328: LD_INT 112
3330: PUSH
3331: LD_INT 148
3333: PUSH
3334: LD_INT 3
3336: PUSH
3337: EMPTY
3338: LIST
3339: LIST
3340: LIST
3341: LIST
3342: PUSH
3343: LD_INT 33
3345: PUSH
3346: LD_INT 120
3348: PUSH
3349: LD_INT 159
3351: PUSH
3352: LD_INT 4
3354: PUSH
3355: EMPTY
3356: LIST
3357: LIST
3358: LIST
3359: LIST
3360: PUSH
3361: LD_INT 33
3363: PUSH
3364: LD_INT 122
3366: PUSH
3367: LD_INT 163
3369: PUSH
3370: LD_INT 4
3372: PUSH
3373: EMPTY
3374: LIST
3375: LIST
3376: LIST
3377: LIST
3378: PUSH
3379: LD_INT 33
3381: PUSH
3382: LD_INT 123
3384: PUSH
3385: LD_INT 167
3387: PUSH
3388: LD_INT 4
3390: PUSH
3391: EMPTY
3392: LIST
3393: LIST
3394: LIST
3395: LIST
3396: PUSH
3397: LD_INT 33
3399: PUSH
3400: LD_INT 59
3402: PUSH
3403: LD_INT 111
3405: PUSH
3406: LD_INT 3
3408: PUSH
3409: EMPTY
3410: LIST
3411: LIST
3412: LIST
3413: LIST
3414: PUSH
3415: LD_INT 33
3417: PUSH
3418: LD_INT 65
3420: PUSH
3421: LD_INT 111
3423: PUSH
3424: LD_INT 3
3426: PUSH
3427: EMPTY
3428: LIST
3429: LIST
3430: LIST
3431: LIST
3432: PUSH
3433: LD_INT 33
3435: PUSH
3436: LD_INT 76
3438: PUSH
3439: LD_INT 117
3441: PUSH
3442: LD_INT 3
3444: PUSH
3445: EMPTY
3446: LIST
3447: LIST
3448: LIST
3449: LIST
3450: PUSH
3451: LD_INT 33
3453: PUSH
3454: LD_INT 80
3456: PUSH
3457: LD_INT 119
3459: PUSH
3460: LD_INT 3
3462: PUSH
3463: EMPTY
3464: LIST
3465: LIST
3466: LIST
3467: LIST
3468: PUSH
3469: LD_INT 33
3471: PUSH
3472: LD_INT 87
3474: PUSH
3475: LD_INT 125
3477: PUSH
3478: LD_INT 3
3480: PUSH
3481: EMPTY
3482: LIST
3483: LIST
3484: LIST
3485: LIST
3486: PUSH
3487: LD_INT 4
3489: PUSH
3490: LD_INT 92
3492: PUSH
3493: LD_INT 129
3495: PUSH
3496: LD_INT 3
3498: PUSH
3499: EMPTY
3500: LIST
3501: LIST
3502: LIST
3503: LIST
3504: PUSH
3505: LD_INT 28
3507: PUSH
3508: LD_INT 85
3510: PUSH
3511: LD_INT 165
3513: PUSH
3514: LD_INT 0
3516: PUSH
3517: EMPTY
3518: LIST
3519: LIST
3520: LIST
3521: LIST
3522: PUSH
3523: LD_INT 28
3525: PUSH
3526: LD_INT 83
3528: PUSH
3529: LD_INT 161
3531: PUSH
3532: LD_INT 4
3534: PUSH
3535: EMPTY
3536: LIST
3537: LIST
3538: LIST
3539: LIST
3540: PUSH
3541: LD_INT 28
3543: PUSH
3544: LD_INT 91
3546: PUSH
3547: LD_INT 166
3549: PUSH
3550: LD_INT 3
3552: PUSH
3553: EMPTY
3554: LIST
3555: LIST
3556: LIST
3557: LIST
3558: PUSH
3559: LD_INT 28
3561: PUSH
3562: LD_INT 102
3564: PUSH
3565: LD_INT 166
3567: PUSH
3568: LD_INT 2
3570: PUSH
3571: EMPTY
3572: LIST
3573: LIST
3574: LIST
3575: LIST
3576: PUSH
3577: LD_INT 34
3579: PUSH
3580: LD_INT 91
3582: PUSH
3583: LD_INT 147
3585: PUSH
3586: LD_INT 3
3588: PUSH
3589: EMPTY
3590: LIST
3591: LIST
3592: LIST
3593: LIST
3594: PUSH
3595: EMPTY
3596: LIST
3597: LIST
3598: LIST
3599: LIST
3600: LIST
3601: LIST
3602: LIST
3603: LIST
3604: LIST
3605: LIST
3606: LIST
3607: LIST
3608: LIST
3609: LIST
3610: LIST
3611: LIST
3612: LIST
3613: LIST
3614: LIST
3615: LIST
3616: LIST
3617: LIST
3618: LIST
3619: LIST
3620: LIST
3621: LIST
3622: PPUSH
3623: CALL 65729 0 2
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_siberium ] ) ;
3627: LD_INT 3
3629: PPUSH
3630: LD_INT 10
3632: PUSH
3633: LD_INT 12
3635: PUSH
3636: LD_INT 14
3638: PUSH
3639: LD_INT 11
3641: PUSH
3642: EMPTY
3643: LIST
3644: LIST
3645: LIST
3646: LIST
3647: PPUSH
3648: CALL 66579 0 2
// MC_SetFactoryExtension ( 3 , 94 , 161 , 0 , [ b_ext_noncombat , b_ext_gun , b_ext_rocket , b_ext_computer , b_ext_siberium ] ) ;
3652: LD_INT 3
3654: PPUSH
3655: LD_INT 94
3657: PPUSH
3658: LD_INT 161
3660: PPUSH
3661: LD_INT 0
3663: PPUSH
3664: LD_INT 19
3666: PUSH
3667: LD_INT 17
3669: PUSH
3670: LD_INT 18
3672: PUSH
3673: LD_INT 24
3675: PUSH
3676: LD_INT 21
3678: PUSH
3679: EMPTY
3680: LIST
3681: LIST
3682: LIST
3683: LIST
3684: LIST
3685: PPUSH
3686: CALL 66784 0 5
// MC_SetUpgradeBuilding ( 3 , b_depot ) ;
3690: LD_INT 3
3692: PPUSH
3693: LD_INT 0
3695: PPUSH
3696: CALL 66452 0 2
// end ; end_of_file
3700: LD_VAR 0 1
3704: RET
// export Sikorski ; export function PrepareSikorski ; var i , j , un ; begin
3705: LD_INT 0
3707: PPUSH
3708: PPUSH
3709: PPUSH
3710: PPUSH
// uc_side := 1 ;
3711: LD_ADDR_OWVAR 20
3715: PUSH
3716: LD_INT 1
3718: ST_TO_ADDR
// uc_nation := 1 ;
3719: LD_ADDR_OWVAR 21
3723: PUSH
3724: LD_INT 1
3726: ST_TO_ADDR
// hc_importance := 100 ;
3727: LD_ADDR_OWVAR 32
3731: PUSH
3732: LD_INT 100
3734: ST_TO_ADDR
// hc_name := Jeremy Sikorski ;
3735: LD_ADDR_OWVAR 26
3739: PUSH
3740: LD_STRING Jeremy Sikorski
3742: ST_TO_ADDR
// hc_gallery := us ;
3743: LD_ADDR_OWVAR 33
3747: PUSH
3748: LD_STRING us
3750: ST_TO_ADDR
// hc_face_number := 19 ;
3751: LD_ADDR_OWVAR 34
3755: PUSH
3756: LD_INT 19
3758: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , [ 4 , 4 , 3 ] [ Difficulty ] ) ;
3759: LD_INT 1
3761: PPUSH
3762: LD_INT 1
3764: PPUSH
3765: LD_INT 4
3767: PUSH
3768: LD_INT 4
3770: PUSH
3771: LD_INT 3
3773: PUSH
3774: EMPTY
3775: LIST
3776: LIST
3777: LIST
3778: PUSH
3779: LD_OWVAR 67
3783: ARRAY
3784: PPUSH
3785: CALL_OW 380
// hc_attr := [ 10 , 12 ] ;
3789: LD_ADDR_OWVAR 29
3793: PUSH
3794: LD_INT 10
3796: PUSH
3797: LD_INT 12
3799: PUSH
3800: EMPTY
3801: LIST
3802: LIST
3803: ST_TO_ADDR
// Sikorski := CreateHuman ;
3804: LD_ADDR_EXP 11
3808: PUSH
3809: CALL_OW 44
3813: ST_TO_ADDR
// PlaceUnitXYR ( Sikorski , 133 , 19 , 2 , false ) ;
3814: LD_EXP 11
3818: PPUSH
3819: LD_INT 133
3821: PPUSH
3822: LD_INT 19
3824: PPUSH
3825: LD_INT 2
3827: PPUSH
3828: LD_INT 0
3830: PPUSH
3831: CALL_OW 50
// InitHc_All ( ) ;
3835: CALL_OW 584
// for i := 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
3839: LD_ADDR_VAR 0 2
3843: PUSH
3844: DOUBLE
3845: LD_INT 1
3847: DEC
3848: ST_TO_ADDR
3849: LD_INT 4
3851: PUSH
3852: LD_INT 3
3854: PUSH
3855: LD_INT 3
3857: PUSH
3858: EMPTY
3859: LIST
3860: LIST
3861: LIST
3862: PUSH
3863: LD_OWVAR 67
3867: ARRAY
3868: PUSH
3869: FOR_TO
3870: IFFALSE 3986
// for j := 1 to 4 do
3872: LD_ADDR_VAR 0 3
3876: PUSH
3877: DOUBLE
3878: LD_INT 1
3880: DEC
3881: ST_TO_ADDR
3882: LD_INT 4
3884: PUSH
3885: FOR_TO
3886: IFFALSE 3982
// begin PrepareHuman ( false , j , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
3888: LD_INT 0
3890: PPUSH
3891: LD_VAR 0 3
3895: PPUSH
3896: LD_INT 5
3898: PUSH
3899: LD_INT 4
3901: PUSH
3902: LD_INT 3
3904: PUSH
3905: EMPTY
3906: LIST
3907: LIST
3908: LIST
3909: PUSH
3910: LD_OWVAR 67
3914: ARRAY
3915: PPUSH
3916: CALL_OW 380
// un := CreateHuman ;
3920: LD_ADDR_VAR 0 4
3924: PUSH
3925: CALL_OW 44
3929: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3930: LD_VAR 0 4
3934: PPUSH
3935: LD_INT 0
3937: PPUSH
3938: LD_INT 5
3940: PPUSH
3941: CALL_OW 12
3945: PPUSH
3946: CALL_OW 233
// PlaceUnitXYR ( un , 133 , 19 , 6 , false ) ;
3950: LD_VAR 0 4
3954: PPUSH
3955: LD_INT 133
3957: PPUSH
3958: LD_INT 19
3960: PPUSH
3961: LD_INT 6
3963: PPUSH
3964: LD_INT 0
3966: PPUSH
3967: CALL_OW 50
// ComHold ( un ) ;
3971: LD_VAR 0 4
3975: PPUSH
3976: CALL_OW 140
// end ;
3980: GO 3885
3982: POP
3983: POP
3984: GO 3869
3986: POP
3987: POP
// vc_chassis := us_heavy_tracked ;
3988: LD_ADDR_OWVAR 37
3992: PUSH
3993: LD_INT 4
3995: ST_TO_ADDR
// vc_engine := engine_combustion ;
3996: LD_ADDR_OWVAR 39
4000: PUSH
4001: LD_INT 1
4003: ST_TO_ADDR
// vc_control := control_manual ;
4004: LD_ADDR_OWVAR 38
4008: PUSH
4009: LD_INT 1
4011: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
4012: LD_ADDR_OWVAR 40
4016: PUSH
4017: LD_INT 14
4019: ST_TO_ADDR
// vc_fuel_battery := 60 ;
4020: LD_ADDR_OWVAR 41
4024: PUSH
4025: LD_INT 60
4027: ST_TO_ADDR
// un := CreateVehicle ;
4028: LD_ADDR_VAR 0 4
4032: PUSH
4033: CALL_OW 45
4037: ST_TO_ADDR
// SetDir ( un , 2 ) ;
4038: LD_VAR 0 4
4042: PPUSH
4043: LD_INT 2
4045: PPUSH
4046: CALL_OW 233
// PlaceUnitXY ( un , 128 , 12 , false ) ;
4050: LD_VAR 0 4
4054: PPUSH
4055: LD_INT 128
4057: PPUSH
4058: LD_INT 12
4060: PPUSH
4061: LD_INT 0
4063: PPUSH
4064: CALL_OW 48
// for i := 1 to 3 do
4068: LD_ADDR_VAR 0 2
4072: PUSH
4073: DOUBLE
4074: LD_INT 1
4076: DEC
4077: ST_TO_ADDR
4078: LD_INT 3
4080: PUSH
4081: FOR_TO
4082: IFFALSE 4105
// CreateCratesXYR ( 5 , 133 , 19 , 3 , false ) ;
4084: LD_INT 5
4086: PPUSH
4087: LD_INT 133
4089: PPUSH
4090: LD_INT 19
4092: PPUSH
4093: LD_INT 3
4095: PPUSH
4096: LD_INT 0
4098: PPUSH
4099: CALL_OW 56
4103: GO 4081
4105: POP
4106: POP
// end ; end_of_file
4107: LD_VAR 0 1
4111: RET
// export function Action ; begin
4112: LD_INT 0
4114: PPUSH
// wait ( 0 0$5 ) ;
4115: LD_INT 175
4117: PPUSH
4118: CALL_OW 67
// InGameOn ;
4122: CALL_OW 8
// wait ( 0 0$2 ) ;
4126: LD_INT 70
4128: PPUSH
4129: CALL_OW 67
// CenterNowOnXY ( 133 , 19 ) ;
4133: LD_INT 133
4135: PPUSH
4136: LD_INT 19
4138: PPUSH
4139: CALL_OW 86
// Say ( Sikorski , WT-DS-1 ) ;
4143: LD_EXP 11
4147: PPUSH
4148: LD_STRING WT-DS-1
4150: PPUSH
4151: CALL_OW 88
// wait ( 0 0$5 ) ;
4155: LD_INT 175
4157: PPUSH
4158: CALL_OW 67
// InGameOff ;
4162: CALL_OW 9
// ChangeMissionObjectives ( DestroyEnemy ) ;
4166: LD_STRING DestroyEnemy
4168: PPUSH
4169: CALL_OW 337
// end ; end_of_file
4173: LD_VAR 0 1
4177: RET
// on UnitDestroyed ( un ) do begin MCE_UnitDestroyed ( un ) ;
4178: LD_VAR 0 1
4182: PPUSH
4183: CALL 69296 0 1
// if un = Powell then
4187: LD_VAR 0 1
4191: PUSH
4192: LD_EXP 4
4196: EQUAL
4197: IFFALSE 4206
// YouLost ( Powell ) ;
4199: LD_STRING Powell
4201: PPUSH
4202: CALL_OW 104
// end ;
4206: PPOPN 1
4208: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
4209: LD_VAR 0 1
4213: PPUSH
4214: LD_VAR 0 2
4218: PPUSH
4219: CALL 71630 0 2
// end ;
4223: PPOPN 2
4225: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
4226: LD_VAR 0 1
4230: PPUSH
4231: CALL 70698 0 1
// end ;
4235: PPOPN 1
4237: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
4238: LD_VAR 0 1
4242: PPUSH
4243: CALL 70939 0 1
// end ;
4247: PPOPN 1
4249: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
4250: LD_VAR 0 1
4254: PPUSH
4255: LD_VAR 0 2
4259: PPUSH
4260: CALL 68992 0 2
// end ;
4264: PPOPN 2
4266: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
4267: LD_VAR 0 1
4271: PPUSH
4272: LD_VAR 0 2
4276: PPUSH
4277: LD_VAR 0 3
4281: PPUSH
4282: LD_VAR 0 4
4286: PPUSH
4287: LD_VAR 0 5
4291: PPUSH
4292: CALL 68612 0 5
// end ;
4296: PPOPN 5
4298: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
4299: LD_VAR 0 1
4303: PPUSH
4304: LD_VAR 0 2
4308: PPUSH
4309: CALL 68202 0 2
// end ;
4313: PPOPN 2
4315: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
4316: LD_VAR 0 1
4320: PPUSH
4321: LD_VAR 0 2
4325: PPUSH
4326: LD_VAR 0 3
4330: PPUSH
4331: LD_VAR 0 4
4335: PPUSH
4336: CALL 68040 0 4
// end ;
4340: PPOPN 4
4342: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
4343: LD_VAR 0 1
4347: PPUSH
4348: LD_VAR 0 2
4352: PPUSH
4353: LD_VAR 0 3
4357: PPUSH
4358: CALL 67815 0 3
// end ;
4362: PPOPN 3
4364: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
4365: LD_VAR 0 1
4369: PPUSH
4370: LD_VAR 0 2
4374: PPUSH
4375: CALL 67700 0 2
// end ;
4379: PPOPN 2
4381: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
4382: LD_VAR 0 1
4386: PPUSH
4387: LD_VAR 0 2
4391: PPUSH
4392: CALL 71891 0 2
// end ;
4396: PPOPN 2
4398: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
4399: LD_VAR 0 1
4403: PPUSH
4404: LD_VAR 0 2
4408: PPUSH
4409: LD_VAR 0 3
4413: PPUSH
4414: LD_VAR 0 4
4418: PPUSH
4419: CALL 72107 0 4
// end ;
4423: PPOPN 4
4425: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
4426: LD_VAR 0 1
4430: PPUSH
4431: LD_VAR 0 2
4435: PPUSH
4436: CALL 67509 0 2
// end ;
4440: PPOPN 2
4442: END
// export function CustomEvent ( event ) ; begin
4443: LD_INT 0
4445: PPUSH
// end ;
4446: LD_VAR 0 2
4450: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 then
4451: LD_VAR 0 1
4455: PUSH
4456: LD_INT 1
4458: EQUAL
4459: PUSH
4460: LD_VAR 0 2
4464: PUSH
4465: LD_INT 4
4467: EQUAL
4468: AND
4469: IFFALSE 4478
// YouLost ( FriendlyFire ) ;
4471: LD_STRING FriendlyFire
4473: PPUSH
4474: CALL_OW 104
// end ; end_of_file
4478: PPOPN 2
4480: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
4481: LD_INT 0
4483: PPUSH
4484: PPUSH
// if exist_mode then
4485: LD_VAR 0 2
4489: IFFALSE 4514
// unit := CreateCharacter ( prefix & ident ) else
4491: LD_ADDR_VAR 0 5
4495: PUSH
4496: LD_VAR 0 3
4500: PUSH
4501: LD_VAR 0 1
4505: STR
4506: PPUSH
4507: CALL_OW 34
4511: ST_TO_ADDR
4512: GO 4529
// unit := NewCharacter ( ident ) ;
4514: LD_ADDR_VAR 0 5
4518: PUSH
4519: LD_VAR 0 1
4523: PPUSH
4524: CALL_OW 25
4528: ST_TO_ADDR
// result := unit ;
4529: LD_ADDR_VAR 0 4
4533: PUSH
4534: LD_VAR 0 5
4538: ST_TO_ADDR
// end ;
4539: LD_VAR 0 4
4543: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
4544: LD_INT 0
4546: PPUSH
4547: PPUSH
// if not side or not nation then
4548: LD_VAR 0 1
4552: NOT
4553: PUSH
4554: LD_VAR 0 2
4558: NOT
4559: OR
4560: IFFALSE 4564
// exit ;
4562: GO 5328
// case nation of nation_american :
4564: LD_VAR 0 2
4568: PUSH
4569: LD_INT 1
4571: DOUBLE
4572: EQUAL
4573: IFTRUE 4577
4575: GO 4791
4577: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
4578: LD_ADDR_VAR 0 4
4582: PUSH
4583: LD_INT 35
4585: PUSH
4586: LD_INT 45
4588: PUSH
4589: LD_INT 46
4591: PUSH
4592: LD_INT 47
4594: PUSH
4595: LD_INT 82
4597: PUSH
4598: LD_INT 83
4600: PUSH
4601: LD_INT 84
4603: PUSH
4604: LD_INT 85
4606: PUSH
4607: LD_INT 86
4609: PUSH
4610: LD_INT 1
4612: PUSH
4613: LD_INT 2
4615: PUSH
4616: LD_INT 6
4618: PUSH
4619: LD_INT 15
4621: PUSH
4622: LD_INT 16
4624: PUSH
4625: LD_INT 7
4627: PUSH
4628: LD_INT 12
4630: PUSH
4631: LD_INT 13
4633: PUSH
4634: LD_INT 10
4636: PUSH
4637: LD_INT 14
4639: PUSH
4640: LD_INT 20
4642: PUSH
4643: LD_INT 21
4645: PUSH
4646: LD_INT 22
4648: PUSH
4649: LD_INT 25
4651: PUSH
4652: LD_INT 32
4654: PUSH
4655: LD_INT 27
4657: PUSH
4658: LD_INT 36
4660: PUSH
4661: LD_INT 69
4663: PUSH
4664: LD_INT 39
4666: PUSH
4667: LD_INT 34
4669: PUSH
4670: LD_INT 40
4672: PUSH
4673: LD_INT 48
4675: PUSH
4676: LD_INT 49
4678: PUSH
4679: LD_INT 50
4681: PUSH
4682: LD_INT 51
4684: PUSH
4685: LD_INT 52
4687: PUSH
4688: LD_INT 53
4690: PUSH
4691: LD_INT 54
4693: PUSH
4694: LD_INT 55
4696: PUSH
4697: LD_INT 56
4699: PUSH
4700: LD_INT 57
4702: PUSH
4703: LD_INT 58
4705: PUSH
4706: LD_INT 59
4708: PUSH
4709: LD_INT 60
4711: PUSH
4712: LD_INT 61
4714: PUSH
4715: LD_INT 62
4717: PUSH
4718: LD_INT 80
4720: PUSH
4721: LD_INT 82
4723: PUSH
4724: LD_INT 83
4726: PUSH
4727: LD_INT 84
4729: PUSH
4730: LD_INT 85
4732: PUSH
4733: LD_INT 86
4735: PUSH
4736: EMPTY
4737: LIST
4738: LIST
4739: LIST
4740: LIST
4741: LIST
4742: LIST
4743: LIST
4744: LIST
4745: LIST
4746: LIST
4747: LIST
4748: LIST
4749: LIST
4750: LIST
4751: LIST
4752: LIST
4753: LIST
4754: LIST
4755: LIST
4756: LIST
4757: LIST
4758: LIST
4759: LIST
4760: LIST
4761: LIST
4762: LIST
4763: LIST
4764: LIST
4765: LIST
4766: LIST
4767: LIST
4768: LIST
4769: LIST
4770: LIST
4771: LIST
4772: LIST
4773: LIST
4774: LIST
4775: LIST
4776: LIST
4777: LIST
4778: LIST
4779: LIST
4780: LIST
4781: LIST
4782: LIST
4783: LIST
4784: LIST
4785: LIST
4786: LIST
4787: LIST
4788: ST_TO_ADDR
4789: GO 5252
4791: LD_INT 2
4793: DOUBLE
4794: EQUAL
4795: IFTRUE 4799
4797: GO 5021
4799: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
4800: LD_ADDR_VAR 0 4
4804: PUSH
4805: LD_INT 35
4807: PUSH
4808: LD_INT 45
4810: PUSH
4811: LD_INT 46
4813: PUSH
4814: LD_INT 47
4816: PUSH
4817: LD_INT 82
4819: PUSH
4820: LD_INT 83
4822: PUSH
4823: LD_INT 84
4825: PUSH
4826: LD_INT 85
4828: PUSH
4829: LD_INT 87
4831: PUSH
4832: LD_INT 70
4834: PUSH
4835: LD_INT 1
4837: PUSH
4838: LD_INT 11
4840: PUSH
4841: LD_INT 3
4843: PUSH
4844: LD_INT 4
4846: PUSH
4847: LD_INT 5
4849: PUSH
4850: LD_INT 6
4852: PUSH
4853: LD_INT 15
4855: PUSH
4856: LD_INT 18
4858: PUSH
4859: LD_INT 7
4861: PUSH
4862: LD_INT 17
4864: PUSH
4865: LD_INT 8
4867: PUSH
4868: LD_INT 20
4870: PUSH
4871: LD_INT 21
4873: PUSH
4874: LD_INT 22
4876: PUSH
4877: LD_INT 72
4879: PUSH
4880: LD_INT 26
4882: PUSH
4883: LD_INT 69
4885: PUSH
4886: LD_INT 39
4888: PUSH
4889: LD_INT 40
4891: PUSH
4892: LD_INT 41
4894: PUSH
4895: LD_INT 42
4897: PUSH
4898: LD_INT 43
4900: PUSH
4901: LD_INT 48
4903: PUSH
4904: LD_INT 49
4906: PUSH
4907: LD_INT 50
4909: PUSH
4910: LD_INT 51
4912: PUSH
4913: LD_INT 52
4915: PUSH
4916: LD_INT 53
4918: PUSH
4919: LD_INT 54
4921: PUSH
4922: LD_INT 55
4924: PUSH
4925: LD_INT 56
4927: PUSH
4928: LD_INT 60
4930: PUSH
4931: LD_INT 61
4933: PUSH
4934: LD_INT 62
4936: PUSH
4937: LD_INT 66
4939: PUSH
4940: LD_INT 67
4942: PUSH
4943: LD_INT 68
4945: PUSH
4946: LD_INT 81
4948: PUSH
4949: LD_INT 82
4951: PUSH
4952: LD_INT 83
4954: PUSH
4955: LD_INT 84
4957: PUSH
4958: LD_INT 85
4960: PUSH
4961: LD_INT 87
4963: PUSH
4964: EMPTY
4965: LIST
4966: LIST
4967: LIST
4968: LIST
4969: LIST
4970: LIST
4971: LIST
4972: LIST
4973: LIST
4974: LIST
4975: LIST
4976: LIST
4977: LIST
4978: LIST
4979: LIST
4980: LIST
4981: LIST
4982: LIST
4983: LIST
4984: LIST
4985: LIST
4986: LIST
4987: LIST
4988: LIST
4989: LIST
4990: LIST
4991: LIST
4992: LIST
4993: LIST
4994: LIST
4995: LIST
4996: LIST
4997: LIST
4998: LIST
4999: LIST
5000: LIST
5001: LIST
5002: LIST
5003: LIST
5004: LIST
5005: LIST
5006: LIST
5007: LIST
5008: LIST
5009: LIST
5010: LIST
5011: LIST
5012: LIST
5013: LIST
5014: LIST
5015: LIST
5016: LIST
5017: LIST
5018: ST_TO_ADDR
5019: GO 5252
5021: LD_INT 3
5023: DOUBLE
5024: EQUAL
5025: IFTRUE 5029
5027: GO 5251
5029: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
5030: LD_ADDR_VAR 0 4
5034: PUSH
5035: LD_INT 46
5037: PUSH
5038: LD_INT 47
5040: PUSH
5041: LD_INT 1
5043: PUSH
5044: LD_INT 2
5046: PUSH
5047: LD_INT 82
5049: PUSH
5050: LD_INT 83
5052: PUSH
5053: LD_INT 84
5055: PUSH
5056: LD_INT 85
5058: PUSH
5059: LD_INT 86
5061: PUSH
5062: LD_INT 11
5064: PUSH
5065: LD_INT 9
5067: PUSH
5068: LD_INT 20
5070: PUSH
5071: LD_INT 19
5073: PUSH
5074: LD_INT 21
5076: PUSH
5077: LD_INT 24
5079: PUSH
5080: LD_INT 22
5082: PUSH
5083: LD_INT 25
5085: PUSH
5086: LD_INT 28
5088: PUSH
5089: LD_INT 29
5091: PUSH
5092: LD_INT 30
5094: PUSH
5095: LD_INT 31
5097: PUSH
5098: LD_INT 37
5100: PUSH
5101: LD_INT 38
5103: PUSH
5104: LD_INT 32
5106: PUSH
5107: LD_INT 27
5109: PUSH
5110: LD_INT 33
5112: PUSH
5113: LD_INT 69
5115: PUSH
5116: LD_INT 39
5118: PUSH
5119: LD_INT 34
5121: PUSH
5122: LD_INT 40
5124: PUSH
5125: LD_INT 71
5127: PUSH
5128: LD_INT 23
5130: PUSH
5131: LD_INT 44
5133: PUSH
5134: LD_INT 48
5136: PUSH
5137: LD_INT 49
5139: PUSH
5140: LD_INT 50
5142: PUSH
5143: LD_INT 51
5145: PUSH
5146: LD_INT 52
5148: PUSH
5149: LD_INT 53
5151: PUSH
5152: LD_INT 54
5154: PUSH
5155: LD_INT 55
5157: PUSH
5158: LD_INT 56
5160: PUSH
5161: LD_INT 57
5163: PUSH
5164: LD_INT 58
5166: PUSH
5167: LD_INT 59
5169: PUSH
5170: LD_INT 63
5172: PUSH
5173: LD_INT 64
5175: PUSH
5176: LD_INT 65
5178: PUSH
5179: LD_INT 82
5181: PUSH
5182: LD_INT 83
5184: PUSH
5185: LD_INT 84
5187: PUSH
5188: LD_INT 85
5190: PUSH
5191: LD_INT 86
5193: PUSH
5194: EMPTY
5195: LIST
5196: LIST
5197: LIST
5198: LIST
5199: LIST
5200: LIST
5201: LIST
5202: LIST
5203: LIST
5204: LIST
5205: LIST
5206: LIST
5207: LIST
5208: LIST
5209: LIST
5210: LIST
5211: LIST
5212: LIST
5213: LIST
5214: LIST
5215: LIST
5216: LIST
5217: LIST
5218: LIST
5219: LIST
5220: LIST
5221: LIST
5222: LIST
5223: LIST
5224: LIST
5225: LIST
5226: LIST
5227: LIST
5228: LIST
5229: LIST
5230: LIST
5231: LIST
5232: LIST
5233: LIST
5234: LIST
5235: LIST
5236: LIST
5237: LIST
5238: LIST
5239: LIST
5240: LIST
5241: LIST
5242: LIST
5243: LIST
5244: LIST
5245: LIST
5246: LIST
5247: LIST
5248: ST_TO_ADDR
5249: GO 5252
5251: POP
// if state > - 1 and state < 3 then
5252: LD_VAR 0 3
5256: PUSH
5257: LD_INT 1
5259: NEG
5260: GREATER
5261: PUSH
5262: LD_VAR 0 3
5266: PUSH
5267: LD_INT 3
5269: LESS
5270: AND
5271: IFFALSE 5328
// for i in result do
5273: LD_ADDR_VAR 0 5
5277: PUSH
5278: LD_VAR 0 4
5282: PUSH
5283: FOR_IN
5284: IFFALSE 5326
// if GetTech ( i , side ) <> state then
5286: LD_VAR 0 5
5290: PPUSH
5291: LD_VAR 0 1
5295: PPUSH
5296: CALL_OW 321
5300: PUSH
5301: LD_VAR 0 3
5305: NONEQUAL
5306: IFFALSE 5324
// result := result diff i ;
5308: LD_ADDR_VAR 0 4
5312: PUSH
5313: LD_VAR 0 4
5317: PUSH
5318: LD_VAR 0 5
5322: DIFF
5323: ST_TO_ADDR
5324: GO 5283
5326: POP
5327: POP
// end ;
5328: LD_VAR 0 4
5332: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
5333: LD_INT 0
5335: PPUSH
5336: PPUSH
5337: PPUSH
// result := true ;
5338: LD_ADDR_VAR 0 3
5342: PUSH
5343: LD_INT 1
5345: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
5346: LD_ADDR_VAR 0 5
5350: PUSH
5351: LD_VAR 0 2
5355: PPUSH
5356: CALL_OW 480
5360: ST_TO_ADDR
// if not tmp then
5361: LD_VAR 0 5
5365: NOT
5366: IFFALSE 5370
// exit ;
5368: GO 5419
// for i in tmp do
5370: LD_ADDR_VAR 0 4
5374: PUSH
5375: LD_VAR 0 5
5379: PUSH
5380: FOR_IN
5381: IFFALSE 5417
// if GetTech ( i , side ) <> state_researched then
5383: LD_VAR 0 4
5387: PPUSH
5388: LD_VAR 0 1
5392: PPUSH
5393: CALL_OW 321
5397: PUSH
5398: LD_INT 2
5400: NONEQUAL
5401: IFFALSE 5415
// begin result := false ;
5403: LD_ADDR_VAR 0 3
5407: PUSH
5408: LD_INT 0
5410: ST_TO_ADDR
// exit ;
5411: POP
5412: POP
5413: GO 5419
// end ;
5415: GO 5380
5417: POP
5418: POP
// end ;
5419: LD_VAR 0 3
5423: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
5424: LD_INT 0
5426: PPUSH
5427: PPUSH
5428: PPUSH
5429: PPUSH
5430: PPUSH
5431: PPUSH
5432: PPUSH
5433: PPUSH
5434: PPUSH
5435: PPUSH
5436: PPUSH
5437: PPUSH
5438: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
5439: LD_VAR 0 1
5443: NOT
5444: PUSH
5445: LD_VAR 0 1
5449: PPUSH
5450: CALL_OW 257
5454: PUSH
5455: LD_INT 9
5457: NONEQUAL
5458: OR
5459: IFFALSE 5463
// exit ;
5461: GO 6036
// side := GetSide ( unit ) ;
5463: LD_ADDR_VAR 0 9
5467: PUSH
5468: LD_VAR 0 1
5472: PPUSH
5473: CALL_OW 255
5477: ST_TO_ADDR
// tech_space := tech_spacanom ;
5478: LD_ADDR_VAR 0 12
5482: PUSH
5483: LD_INT 29
5485: ST_TO_ADDR
// tech_time := tech_taurad ;
5486: LD_ADDR_VAR 0 13
5490: PUSH
5491: LD_INT 28
5493: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
5494: LD_ADDR_VAR 0 11
5498: PUSH
5499: LD_VAR 0 1
5503: PPUSH
5504: CALL_OW 310
5508: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
5509: LD_VAR 0 11
5513: PPUSH
5514: CALL_OW 247
5518: PUSH
5519: LD_INT 2
5521: EQUAL
5522: IFFALSE 5526
// exit ;
5524: GO 6036
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
5526: LD_ADDR_VAR 0 8
5530: PUSH
5531: LD_INT 81
5533: PUSH
5534: LD_VAR 0 9
5538: PUSH
5539: EMPTY
5540: LIST
5541: LIST
5542: PUSH
5543: LD_INT 3
5545: PUSH
5546: LD_INT 21
5548: PUSH
5549: LD_INT 3
5551: PUSH
5552: EMPTY
5553: LIST
5554: LIST
5555: PUSH
5556: EMPTY
5557: LIST
5558: LIST
5559: PUSH
5560: EMPTY
5561: LIST
5562: LIST
5563: PPUSH
5564: CALL_OW 69
5568: ST_TO_ADDR
// if not tmp then
5569: LD_VAR 0 8
5573: NOT
5574: IFFALSE 5578
// exit ;
5576: GO 6036
// if in_unit then
5578: LD_VAR 0 11
5582: IFFALSE 5606
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
5584: LD_ADDR_VAR 0 10
5588: PUSH
5589: LD_VAR 0 8
5593: PPUSH
5594: LD_VAR 0 11
5598: PPUSH
5599: CALL_OW 74
5603: ST_TO_ADDR
5604: GO 5626
// enemy := NearestUnitToUnit ( tmp , unit ) ;
5606: LD_ADDR_VAR 0 10
5610: PUSH
5611: LD_VAR 0 8
5615: PPUSH
5616: LD_VAR 0 1
5620: PPUSH
5621: CALL_OW 74
5625: ST_TO_ADDR
// if not enemy then
5626: LD_VAR 0 10
5630: NOT
5631: IFFALSE 5635
// exit ;
5633: GO 6036
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
5635: LD_VAR 0 11
5639: PUSH
5640: LD_VAR 0 11
5644: PPUSH
5645: LD_VAR 0 10
5649: PPUSH
5650: CALL_OW 296
5654: PUSH
5655: LD_INT 13
5657: GREATER
5658: AND
5659: PUSH
5660: LD_VAR 0 1
5664: PPUSH
5665: LD_VAR 0 10
5669: PPUSH
5670: CALL_OW 296
5674: PUSH
5675: LD_INT 12
5677: GREATER
5678: OR
5679: IFFALSE 5683
// exit ;
5681: GO 6036
// missile := [ 1 ] ;
5683: LD_ADDR_VAR 0 14
5687: PUSH
5688: LD_INT 1
5690: PUSH
5691: EMPTY
5692: LIST
5693: ST_TO_ADDR
// if Researched ( side , tech_space ) then
5694: LD_VAR 0 9
5698: PPUSH
5699: LD_VAR 0 12
5703: PPUSH
5704: CALL_OW 325
5708: IFFALSE 5737
// missile := Insert ( missile , missile + 1 , 2 ) ;
5710: LD_ADDR_VAR 0 14
5714: PUSH
5715: LD_VAR 0 14
5719: PPUSH
5720: LD_VAR 0 14
5724: PUSH
5725: LD_INT 1
5727: PLUS
5728: PPUSH
5729: LD_INT 2
5731: PPUSH
5732: CALL_OW 2
5736: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
5737: LD_VAR 0 9
5741: PPUSH
5742: LD_VAR 0 13
5746: PPUSH
5747: CALL_OW 325
5751: PUSH
5752: LD_VAR 0 10
5756: PPUSH
5757: CALL_OW 255
5761: PPUSH
5762: LD_VAR 0 13
5766: PPUSH
5767: CALL_OW 325
5771: NOT
5772: AND
5773: IFFALSE 5802
// missile := Insert ( missile , missile + 1 , 3 ) ;
5775: LD_ADDR_VAR 0 14
5779: PUSH
5780: LD_VAR 0 14
5784: PPUSH
5785: LD_VAR 0 14
5789: PUSH
5790: LD_INT 1
5792: PLUS
5793: PPUSH
5794: LD_INT 3
5796: PPUSH
5797: CALL_OW 2
5801: ST_TO_ADDR
// if missile < 2 then
5802: LD_VAR 0 14
5806: PUSH
5807: LD_INT 2
5809: LESS
5810: IFFALSE 5814
// exit ;
5812: GO 6036
// x := GetX ( enemy ) ;
5814: LD_ADDR_VAR 0 4
5818: PUSH
5819: LD_VAR 0 10
5823: PPUSH
5824: CALL_OW 250
5828: ST_TO_ADDR
// y := GetY ( enemy ) ;
5829: LD_ADDR_VAR 0 5
5833: PUSH
5834: LD_VAR 0 10
5838: PPUSH
5839: CALL_OW 251
5843: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
5844: LD_ADDR_VAR 0 6
5848: PUSH
5849: LD_VAR 0 4
5853: PUSH
5854: LD_INT 1
5856: NEG
5857: PPUSH
5858: LD_INT 1
5860: PPUSH
5861: CALL_OW 12
5865: PLUS
5866: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
5867: LD_ADDR_VAR 0 7
5871: PUSH
5872: LD_VAR 0 5
5876: PUSH
5877: LD_INT 1
5879: NEG
5880: PPUSH
5881: LD_INT 1
5883: PPUSH
5884: CALL_OW 12
5888: PLUS
5889: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
5890: LD_VAR 0 6
5894: PPUSH
5895: LD_VAR 0 7
5899: PPUSH
5900: CALL_OW 488
5904: NOT
5905: IFFALSE 5927
// begin _x := x ;
5907: LD_ADDR_VAR 0 6
5911: PUSH
5912: LD_VAR 0 4
5916: ST_TO_ADDR
// _y := y ;
5917: LD_ADDR_VAR 0 7
5921: PUSH
5922: LD_VAR 0 5
5926: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
5927: LD_ADDR_VAR 0 3
5931: PUSH
5932: LD_INT 1
5934: PPUSH
5935: LD_VAR 0 14
5939: PPUSH
5940: CALL_OW 12
5944: ST_TO_ADDR
// case i of 1 :
5945: LD_VAR 0 3
5949: PUSH
5950: LD_INT 1
5952: DOUBLE
5953: EQUAL
5954: IFTRUE 5958
5956: GO 5975
5958: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
5959: LD_VAR 0 1
5963: PPUSH
5964: LD_VAR 0 10
5968: PPUSH
5969: CALL_OW 115
5973: GO 6036
5975: LD_INT 2
5977: DOUBLE
5978: EQUAL
5979: IFTRUE 5983
5981: GO 6005
5983: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
5984: LD_VAR 0 1
5988: PPUSH
5989: LD_VAR 0 6
5993: PPUSH
5994: LD_VAR 0 7
5998: PPUSH
5999: CALL_OW 153
6003: GO 6036
6005: LD_INT 3
6007: DOUBLE
6008: EQUAL
6009: IFTRUE 6013
6011: GO 6035
6013: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
6014: LD_VAR 0 1
6018: PPUSH
6019: LD_VAR 0 6
6023: PPUSH
6024: LD_VAR 0 7
6028: PPUSH
6029: CALL_OW 154
6033: GO 6036
6035: POP
// end ;
6036: LD_VAR 0 2
6040: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
6041: LD_INT 0
6043: PPUSH
6044: PPUSH
6045: PPUSH
6046: PPUSH
6047: PPUSH
6048: PPUSH
// if not unit or not building then
6049: LD_VAR 0 1
6053: NOT
6054: PUSH
6055: LD_VAR 0 2
6059: NOT
6060: OR
6061: IFFALSE 6065
// exit ;
6063: GO 6223
// x := GetX ( building ) ;
6065: LD_ADDR_VAR 0 5
6069: PUSH
6070: LD_VAR 0 2
6074: PPUSH
6075: CALL_OW 250
6079: ST_TO_ADDR
// y := GetY ( building ) ;
6080: LD_ADDR_VAR 0 6
6084: PUSH
6085: LD_VAR 0 2
6089: PPUSH
6090: CALL_OW 251
6094: ST_TO_ADDR
// for i = 0 to 5 do
6095: LD_ADDR_VAR 0 4
6099: PUSH
6100: DOUBLE
6101: LD_INT 0
6103: DEC
6104: ST_TO_ADDR
6105: LD_INT 5
6107: PUSH
6108: FOR_TO
6109: IFFALSE 6221
// begin _x := ShiftX ( x , i , 3 ) ;
6111: LD_ADDR_VAR 0 7
6115: PUSH
6116: LD_VAR 0 5
6120: PPUSH
6121: LD_VAR 0 4
6125: PPUSH
6126: LD_INT 3
6128: PPUSH
6129: CALL_OW 272
6133: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
6134: LD_ADDR_VAR 0 8
6138: PUSH
6139: LD_VAR 0 6
6143: PPUSH
6144: LD_VAR 0 4
6148: PPUSH
6149: LD_INT 3
6151: PPUSH
6152: CALL_OW 273
6156: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
6157: LD_VAR 0 7
6161: PPUSH
6162: LD_VAR 0 8
6166: PPUSH
6167: CALL_OW 488
6171: NOT
6172: IFFALSE 6176
// continue ;
6174: GO 6108
// if HexInfo ( _x , _y ) = 0 then
6176: LD_VAR 0 7
6180: PPUSH
6181: LD_VAR 0 8
6185: PPUSH
6186: CALL_OW 428
6190: PUSH
6191: LD_INT 0
6193: EQUAL
6194: IFFALSE 6219
// begin ComMoveXY ( unit , _x , _y ) ;
6196: LD_VAR 0 1
6200: PPUSH
6201: LD_VAR 0 7
6205: PPUSH
6206: LD_VAR 0 8
6210: PPUSH
6211: CALL_OW 111
// exit ;
6215: POP
6216: POP
6217: GO 6223
// end ; end ;
6219: GO 6108
6221: POP
6222: POP
// end ;
6223: LD_VAR 0 3
6227: RET
// export function ScanBase ( side , base_area ) ; begin
6228: LD_INT 0
6230: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
6231: LD_ADDR_VAR 0 3
6235: PUSH
6236: LD_VAR 0 2
6240: PPUSH
6241: LD_INT 81
6243: PUSH
6244: LD_VAR 0 1
6248: PUSH
6249: EMPTY
6250: LIST
6251: LIST
6252: PPUSH
6253: CALL_OW 70
6257: ST_TO_ADDR
// end ;
6258: LD_VAR 0 3
6262: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
6263: LD_INT 0
6265: PPUSH
6266: PPUSH
6267: PPUSH
6268: PPUSH
// result := false ;
6269: LD_ADDR_VAR 0 2
6273: PUSH
6274: LD_INT 0
6276: ST_TO_ADDR
// side := GetSide ( unit ) ;
6277: LD_ADDR_VAR 0 3
6281: PUSH
6282: LD_VAR 0 1
6286: PPUSH
6287: CALL_OW 255
6291: ST_TO_ADDR
// nat := GetNation ( unit ) ;
6292: LD_ADDR_VAR 0 4
6296: PUSH
6297: LD_VAR 0 1
6301: PPUSH
6302: CALL_OW 248
6306: ST_TO_ADDR
// case nat of 1 :
6307: LD_VAR 0 4
6311: PUSH
6312: LD_INT 1
6314: DOUBLE
6315: EQUAL
6316: IFTRUE 6320
6318: GO 6331
6320: POP
// tech := tech_lassight ; 2 :
6321: LD_ADDR_VAR 0 5
6325: PUSH
6326: LD_INT 12
6328: ST_TO_ADDR
6329: GO 6370
6331: LD_INT 2
6333: DOUBLE
6334: EQUAL
6335: IFTRUE 6339
6337: GO 6350
6339: POP
// tech := tech_mortar ; 3 :
6340: LD_ADDR_VAR 0 5
6344: PUSH
6345: LD_INT 41
6347: ST_TO_ADDR
6348: GO 6370
6350: LD_INT 3
6352: DOUBLE
6353: EQUAL
6354: IFTRUE 6358
6356: GO 6369
6358: POP
// tech := tech_bazooka ; end ;
6359: LD_ADDR_VAR 0 5
6363: PUSH
6364: LD_INT 44
6366: ST_TO_ADDR
6367: GO 6370
6369: POP
// if Researched ( side , tech ) then
6370: LD_VAR 0 3
6374: PPUSH
6375: LD_VAR 0 5
6379: PPUSH
6380: CALL_OW 325
6384: IFFALSE 6411
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
6386: LD_ADDR_VAR 0 2
6390: PUSH
6391: LD_INT 5
6393: PUSH
6394: LD_INT 8
6396: PUSH
6397: LD_INT 9
6399: PUSH
6400: EMPTY
6401: LIST
6402: LIST
6403: LIST
6404: PUSH
6405: LD_VAR 0 4
6409: ARRAY
6410: ST_TO_ADDR
// end ;
6411: LD_VAR 0 2
6415: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
6416: LD_INT 0
6418: PPUSH
6419: PPUSH
6420: PPUSH
// if not mines then
6421: LD_VAR 0 2
6425: NOT
6426: IFFALSE 6430
// exit ;
6428: GO 6574
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
6430: LD_ADDR_VAR 0 5
6434: PUSH
6435: LD_INT 81
6437: PUSH
6438: LD_VAR 0 1
6442: PUSH
6443: EMPTY
6444: LIST
6445: LIST
6446: PUSH
6447: LD_INT 3
6449: PUSH
6450: LD_INT 21
6452: PUSH
6453: LD_INT 3
6455: PUSH
6456: EMPTY
6457: LIST
6458: LIST
6459: PUSH
6460: EMPTY
6461: LIST
6462: LIST
6463: PUSH
6464: EMPTY
6465: LIST
6466: LIST
6467: PPUSH
6468: CALL_OW 69
6472: ST_TO_ADDR
// for i in mines do
6473: LD_ADDR_VAR 0 4
6477: PUSH
6478: LD_VAR 0 2
6482: PUSH
6483: FOR_IN
6484: IFFALSE 6572
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
6486: LD_VAR 0 4
6490: PUSH
6491: LD_INT 1
6493: ARRAY
6494: PPUSH
6495: LD_VAR 0 4
6499: PUSH
6500: LD_INT 2
6502: ARRAY
6503: PPUSH
6504: CALL_OW 458
6508: NOT
6509: IFFALSE 6513
// continue ;
6511: GO 6483
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
6513: LD_VAR 0 4
6517: PUSH
6518: LD_INT 1
6520: ARRAY
6521: PPUSH
6522: LD_VAR 0 4
6526: PUSH
6527: LD_INT 2
6529: ARRAY
6530: PPUSH
6531: CALL_OW 428
6535: PUSH
6536: LD_VAR 0 5
6540: IN
6541: IFFALSE 6570
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
6543: LD_VAR 0 4
6547: PUSH
6548: LD_INT 1
6550: ARRAY
6551: PPUSH
6552: LD_VAR 0 4
6556: PUSH
6557: LD_INT 2
6559: ARRAY
6560: PPUSH
6561: LD_VAR 0 1
6565: PPUSH
6566: CALL_OW 456
// end ;
6570: GO 6483
6572: POP
6573: POP
// end ;
6574: LD_VAR 0 3
6578: RET
// export function Count ( array ) ; var i ; begin
6579: LD_INT 0
6581: PPUSH
6582: PPUSH
// result := 0 ;
6583: LD_ADDR_VAR 0 2
6587: PUSH
6588: LD_INT 0
6590: ST_TO_ADDR
// for i in array do
6591: LD_ADDR_VAR 0 3
6595: PUSH
6596: LD_VAR 0 1
6600: PUSH
6601: FOR_IN
6602: IFFALSE 6626
// if i then
6604: LD_VAR 0 3
6608: IFFALSE 6624
// result := result + 1 ;
6610: LD_ADDR_VAR 0 2
6614: PUSH
6615: LD_VAR 0 2
6619: PUSH
6620: LD_INT 1
6622: PLUS
6623: ST_TO_ADDR
6624: GO 6601
6626: POP
6627: POP
// end ;
6628: LD_VAR 0 2
6632: RET
// export function IsEmpty ( building ) ; begin
6633: LD_INT 0
6635: PPUSH
// if not building then
6636: LD_VAR 0 1
6640: NOT
6641: IFFALSE 6645
// exit ;
6643: GO 6688
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
6645: LD_ADDR_VAR 0 2
6649: PUSH
6650: LD_VAR 0 1
6654: PUSH
6655: LD_INT 22
6657: PUSH
6658: LD_VAR 0 1
6662: PPUSH
6663: CALL_OW 255
6667: PUSH
6668: EMPTY
6669: LIST
6670: LIST
6671: PUSH
6672: LD_INT 58
6674: PUSH
6675: EMPTY
6676: LIST
6677: PUSH
6678: EMPTY
6679: LIST
6680: LIST
6681: PPUSH
6682: CALL_OW 69
6686: IN
6687: ST_TO_ADDR
// end ;
6688: LD_VAR 0 2
6692: RET
// export function IsNotFull ( building ) ; begin
6693: LD_INT 0
6695: PPUSH
// if not building then
6696: LD_VAR 0 1
6700: NOT
6701: IFFALSE 6705
// exit ;
6703: GO 6724
// result := UnitsInside ( building ) < 6 ;
6705: LD_ADDR_VAR 0 2
6709: PUSH
6710: LD_VAR 0 1
6714: PPUSH
6715: CALL_OW 313
6719: PUSH
6720: LD_INT 6
6722: LESS
6723: ST_TO_ADDR
// end ;
6724: LD_VAR 0 2
6728: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
6729: LD_INT 0
6731: PPUSH
6732: PPUSH
6733: PPUSH
6734: PPUSH
// tmp := [ ] ;
6735: LD_ADDR_VAR 0 3
6739: PUSH
6740: EMPTY
6741: ST_TO_ADDR
// list := [ ] ;
6742: LD_ADDR_VAR 0 5
6746: PUSH
6747: EMPTY
6748: ST_TO_ADDR
// for i = 16 to 25 do
6749: LD_ADDR_VAR 0 4
6753: PUSH
6754: DOUBLE
6755: LD_INT 16
6757: DEC
6758: ST_TO_ADDR
6759: LD_INT 25
6761: PUSH
6762: FOR_TO
6763: IFFALSE 6836
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
6765: LD_ADDR_VAR 0 3
6769: PUSH
6770: LD_VAR 0 3
6774: PUSH
6775: LD_INT 22
6777: PUSH
6778: LD_VAR 0 1
6782: PPUSH
6783: CALL_OW 255
6787: PUSH
6788: EMPTY
6789: LIST
6790: LIST
6791: PUSH
6792: LD_INT 91
6794: PUSH
6795: LD_VAR 0 1
6799: PUSH
6800: LD_INT 6
6802: PUSH
6803: EMPTY
6804: LIST
6805: LIST
6806: LIST
6807: PUSH
6808: LD_INT 30
6810: PUSH
6811: LD_VAR 0 4
6815: PUSH
6816: EMPTY
6817: LIST
6818: LIST
6819: PUSH
6820: EMPTY
6821: LIST
6822: LIST
6823: LIST
6824: PUSH
6825: EMPTY
6826: LIST
6827: PPUSH
6828: CALL_OW 69
6832: ADD
6833: ST_TO_ADDR
6834: GO 6762
6836: POP
6837: POP
// for i = 1 to tmp do
6838: LD_ADDR_VAR 0 4
6842: PUSH
6843: DOUBLE
6844: LD_INT 1
6846: DEC
6847: ST_TO_ADDR
6848: LD_VAR 0 3
6852: PUSH
6853: FOR_TO
6854: IFFALSE 6942
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
6856: LD_ADDR_VAR 0 5
6860: PUSH
6861: LD_VAR 0 5
6865: PUSH
6866: LD_VAR 0 3
6870: PUSH
6871: LD_VAR 0 4
6875: ARRAY
6876: PPUSH
6877: CALL_OW 266
6881: PUSH
6882: LD_VAR 0 3
6886: PUSH
6887: LD_VAR 0 4
6891: ARRAY
6892: PPUSH
6893: CALL_OW 250
6897: PUSH
6898: LD_VAR 0 3
6902: PUSH
6903: LD_VAR 0 4
6907: ARRAY
6908: PPUSH
6909: CALL_OW 251
6913: PUSH
6914: LD_VAR 0 3
6918: PUSH
6919: LD_VAR 0 4
6923: ARRAY
6924: PPUSH
6925: CALL_OW 254
6929: PUSH
6930: EMPTY
6931: LIST
6932: LIST
6933: LIST
6934: LIST
6935: PUSH
6936: EMPTY
6937: LIST
6938: ADD
6939: ST_TO_ADDR
6940: GO 6853
6942: POP
6943: POP
// result := list ;
6944: LD_ADDR_VAR 0 2
6948: PUSH
6949: LD_VAR 0 5
6953: ST_TO_ADDR
// end ;
6954: LD_VAR 0 2
6958: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
6959: LD_INT 0
6961: PPUSH
6962: PPUSH
6963: PPUSH
6964: PPUSH
6965: PPUSH
6966: PPUSH
6967: PPUSH
// if not factory then
6968: LD_VAR 0 1
6972: NOT
6973: IFFALSE 6977
// exit ;
6975: GO 7570
// if control = control_apeman then
6977: LD_VAR 0 4
6981: PUSH
6982: LD_INT 5
6984: EQUAL
6985: IFFALSE 7094
// begin tmp := UnitsInside ( factory ) ;
6987: LD_ADDR_VAR 0 8
6991: PUSH
6992: LD_VAR 0 1
6996: PPUSH
6997: CALL_OW 313
7001: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
7002: LD_VAR 0 8
7006: PPUSH
7007: LD_INT 25
7009: PUSH
7010: LD_INT 12
7012: PUSH
7013: EMPTY
7014: LIST
7015: LIST
7016: PPUSH
7017: CALL_OW 72
7021: NOT
7022: IFFALSE 7032
// control := control_manual ;
7024: LD_ADDR_VAR 0 4
7028: PUSH
7029: LD_INT 1
7031: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
7032: LD_ADDR_VAR 0 8
7036: PUSH
7037: LD_VAR 0 1
7041: PPUSH
7042: CALL 6729 0 1
7046: ST_TO_ADDR
// if tmp then
7047: LD_VAR 0 8
7051: IFFALSE 7094
// begin for i in tmp do
7053: LD_ADDR_VAR 0 7
7057: PUSH
7058: LD_VAR 0 8
7062: PUSH
7063: FOR_IN
7064: IFFALSE 7092
// if i [ 1 ] = b_ext_radio then
7066: LD_VAR 0 7
7070: PUSH
7071: LD_INT 1
7073: ARRAY
7074: PUSH
7075: LD_INT 22
7077: EQUAL
7078: IFFALSE 7090
// begin control := control_remote ;
7080: LD_ADDR_VAR 0 4
7084: PUSH
7085: LD_INT 2
7087: ST_TO_ADDR
// break ;
7088: GO 7092
// end ;
7090: GO 7063
7092: POP
7093: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
7094: LD_VAR 0 1
7098: PPUSH
7099: LD_VAR 0 2
7103: PPUSH
7104: LD_VAR 0 3
7108: PPUSH
7109: LD_VAR 0 4
7113: PPUSH
7114: LD_VAR 0 5
7118: PPUSH
7119: CALL_OW 448
7123: IFFALSE 7158
// begin result := [ chassis , engine , control , weapon ] ;
7125: LD_ADDR_VAR 0 6
7129: PUSH
7130: LD_VAR 0 2
7134: PUSH
7135: LD_VAR 0 3
7139: PUSH
7140: LD_VAR 0 4
7144: PUSH
7145: LD_VAR 0 5
7149: PUSH
7150: EMPTY
7151: LIST
7152: LIST
7153: LIST
7154: LIST
7155: ST_TO_ADDR
// exit ;
7156: GO 7570
// end ; _chassis := AvailableChassisList ( factory ) ;
7158: LD_ADDR_VAR 0 9
7162: PUSH
7163: LD_VAR 0 1
7167: PPUSH
7168: CALL_OW 475
7172: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
7173: LD_ADDR_VAR 0 11
7177: PUSH
7178: LD_VAR 0 1
7182: PPUSH
7183: CALL_OW 476
7187: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
7188: LD_ADDR_VAR 0 12
7192: PUSH
7193: LD_VAR 0 1
7197: PPUSH
7198: CALL_OW 477
7202: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
7203: LD_ADDR_VAR 0 10
7207: PUSH
7208: LD_VAR 0 1
7212: PPUSH
7213: CALL_OW 478
7217: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
7218: LD_VAR 0 9
7222: NOT
7223: PUSH
7224: LD_VAR 0 11
7228: NOT
7229: OR
7230: PUSH
7231: LD_VAR 0 12
7235: NOT
7236: OR
7237: PUSH
7238: LD_VAR 0 10
7242: NOT
7243: OR
7244: IFFALSE 7279
// begin result := [ chassis , engine , control , weapon ] ;
7246: LD_ADDR_VAR 0 6
7250: PUSH
7251: LD_VAR 0 2
7255: PUSH
7256: LD_VAR 0 3
7260: PUSH
7261: LD_VAR 0 4
7265: PUSH
7266: LD_VAR 0 5
7270: PUSH
7271: EMPTY
7272: LIST
7273: LIST
7274: LIST
7275: LIST
7276: ST_TO_ADDR
// exit ;
7277: GO 7570
// end ; if not chassis in _chassis then
7279: LD_VAR 0 2
7283: PUSH
7284: LD_VAR 0 9
7288: IN
7289: NOT
7290: IFFALSE 7316
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
7292: LD_ADDR_VAR 0 2
7296: PUSH
7297: LD_VAR 0 9
7301: PUSH
7302: LD_INT 1
7304: PPUSH
7305: LD_VAR 0 9
7309: PPUSH
7310: CALL_OW 12
7314: ARRAY
7315: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
7316: LD_VAR 0 2
7320: PPUSH
7321: LD_VAR 0 3
7325: PPUSH
7326: CALL 7575 0 2
7330: NOT
7331: IFFALSE 7390
// repeat engine := _engine [ 1 ] ;
7333: LD_ADDR_VAR 0 3
7337: PUSH
7338: LD_VAR 0 11
7342: PUSH
7343: LD_INT 1
7345: ARRAY
7346: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
7347: LD_ADDR_VAR 0 11
7351: PUSH
7352: LD_VAR 0 11
7356: PPUSH
7357: LD_INT 1
7359: PPUSH
7360: CALL_OW 3
7364: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
7365: LD_VAR 0 2
7369: PPUSH
7370: LD_VAR 0 3
7374: PPUSH
7375: CALL 7575 0 2
7379: PUSH
7380: LD_VAR 0 11
7384: PUSH
7385: EMPTY
7386: EQUAL
7387: OR
7388: IFFALSE 7333
// if not control in _control then
7390: LD_VAR 0 4
7394: PUSH
7395: LD_VAR 0 12
7399: IN
7400: NOT
7401: IFFALSE 7427
// control := _control [ rand ( 1 , _control ) ] ;
7403: LD_ADDR_VAR 0 4
7407: PUSH
7408: LD_VAR 0 12
7412: PUSH
7413: LD_INT 1
7415: PPUSH
7416: LD_VAR 0 12
7420: PPUSH
7421: CALL_OW 12
7425: ARRAY
7426: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
7427: LD_VAR 0 2
7431: PPUSH
7432: LD_VAR 0 5
7436: PPUSH
7437: CALL 7795 0 2
7441: NOT
7442: IFFALSE 7501
// repeat weapon := _weapon [ 1 ] ;
7444: LD_ADDR_VAR 0 5
7448: PUSH
7449: LD_VAR 0 10
7453: PUSH
7454: LD_INT 1
7456: ARRAY
7457: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
7458: LD_ADDR_VAR 0 10
7462: PUSH
7463: LD_VAR 0 10
7467: PPUSH
7468: LD_INT 1
7470: PPUSH
7471: CALL_OW 3
7475: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
7476: LD_VAR 0 2
7480: PPUSH
7481: LD_VAR 0 5
7485: PPUSH
7486: CALL 7795 0 2
7490: PUSH
7491: LD_VAR 0 10
7495: PUSH
7496: EMPTY
7497: EQUAL
7498: OR
7499: IFFALSE 7444
// result := [ ] ;
7501: LD_ADDR_VAR 0 6
7505: PUSH
7506: EMPTY
7507: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
7508: LD_VAR 0 1
7512: PPUSH
7513: LD_VAR 0 2
7517: PPUSH
7518: LD_VAR 0 3
7522: PPUSH
7523: LD_VAR 0 4
7527: PPUSH
7528: LD_VAR 0 5
7532: PPUSH
7533: CALL_OW 448
7537: IFFALSE 7570
// result := [ chassis , engine , control , weapon ] ;
7539: LD_ADDR_VAR 0 6
7543: PUSH
7544: LD_VAR 0 2
7548: PUSH
7549: LD_VAR 0 3
7553: PUSH
7554: LD_VAR 0 4
7558: PUSH
7559: LD_VAR 0 5
7563: PUSH
7564: EMPTY
7565: LIST
7566: LIST
7567: LIST
7568: LIST
7569: ST_TO_ADDR
// end ;
7570: LD_VAR 0 6
7574: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
7575: LD_INT 0
7577: PPUSH
// if not chassis or not engine then
7578: LD_VAR 0 1
7582: NOT
7583: PUSH
7584: LD_VAR 0 2
7588: NOT
7589: OR
7590: IFFALSE 7594
// exit ;
7592: GO 7790
// case engine of engine_solar :
7594: LD_VAR 0 2
7598: PUSH
7599: LD_INT 2
7601: DOUBLE
7602: EQUAL
7603: IFTRUE 7607
7605: GO 7645
7607: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
7608: LD_ADDR_VAR 0 3
7612: PUSH
7613: LD_INT 11
7615: PUSH
7616: LD_INT 12
7618: PUSH
7619: LD_INT 13
7621: PUSH
7622: LD_INT 14
7624: PUSH
7625: LD_INT 1
7627: PUSH
7628: LD_INT 2
7630: PUSH
7631: LD_INT 3
7633: PUSH
7634: EMPTY
7635: LIST
7636: LIST
7637: LIST
7638: LIST
7639: LIST
7640: LIST
7641: LIST
7642: ST_TO_ADDR
7643: GO 7774
7645: LD_INT 1
7647: DOUBLE
7648: EQUAL
7649: IFTRUE 7653
7651: GO 7715
7653: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
7654: LD_ADDR_VAR 0 3
7658: PUSH
7659: LD_INT 11
7661: PUSH
7662: LD_INT 12
7664: PUSH
7665: LD_INT 13
7667: PUSH
7668: LD_INT 14
7670: PUSH
7671: LD_INT 1
7673: PUSH
7674: LD_INT 2
7676: PUSH
7677: LD_INT 3
7679: PUSH
7680: LD_INT 4
7682: PUSH
7683: LD_INT 5
7685: PUSH
7686: LD_INT 21
7688: PUSH
7689: LD_INT 23
7691: PUSH
7692: LD_INT 22
7694: PUSH
7695: LD_INT 24
7697: PUSH
7698: EMPTY
7699: LIST
7700: LIST
7701: LIST
7702: LIST
7703: LIST
7704: LIST
7705: LIST
7706: LIST
7707: LIST
7708: LIST
7709: LIST
7710: LIST
7711: LIST
7712: ST_TO_ADDR
7713: GO 7774
7715: LD_INT 3
7717: DOUBLE
7718: EQUAL
7719: IFTRUE 7723
7721: GO 7773
7723: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
7724: LD_ADDR_VAR 0 3
7728: PUSH
7729: LD_INT 13
7731: PUSH
7732: LD_INT 14
7734: PUSH
7735: LD_INT 2
7737: PUSH
7738: LD_INT 3
7740: PUSH
7741: LD_INT 4
7743: PUSH
7744: LD_INT 5
7746: PUSH
7747: LD_INT 21
7749: PUSH
7750: LD_INT 22
7752: PUSH
7753: LD_INT 23
7755: PUSH
7756: LD_INT 24
7758: PUSH
7759: EMPTY
7760: LIST
7761: LIST
7762: LIST
7763: LIST
7764: LIST
7765: LIST
7766: LIST
7767: LIST
7768: LIST
7769: LIST
7770: ST_TO_ADDR
7771: GO 7774
7773: POP
// result := ( chassis in result ) ;
7774: LD_ADDR_VAR 0 3
7778: PUSH
7779: LD_VAR 0 1
7783: PUSH
7784: LD_VAR 0 3
7788: IN
7789: ST_TO_ADDR
// end ;
7790: LD_VAR 0 3
7794: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
7795: LD_INT 0
7797: PPUSH
// if not chassis or not weapon then
7798: LD_VAR 0 1
7802: NOT
7803: PUSH
7804: LD_VAR 0 2
7808: NOT
7809: OR
7810: IFFALSE 7814
// exit ;
7812: GO 8840
// case weapon of us_machine_gun :
7814: LD_VAR 0 2
7818: PUSH
7819: LD_INT 2
7821: DOUBLE
7822: EQUAL
7823: IFTRUE 7827
7825: GO 7857
7827: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
7828: LD_ADDR_VAR 0 3
7832: PUSH
7833: LD_INT 1
7835: PUSH
7836: LD_INT 2
7838: PUSH
7839: LD_INT 3
7841: PUSH
7842: LD_INT 4
7844: PUSH
7845: LD_INT 5
7847: PUSH
7848: EMPTY
7849: LIST
7850: LIST
7851: LIST
7852: LIST
7853: LIST
7854: ST_TO_ADDR
7855: GO 8824
7857: LD_INT 3
7859: DOUBLE
7860: EQUAL
7861: IFTRUE 7865
7863: GO 7895
7865: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
7866: LD_ADDR_VAR 0 3
7870: PUSH
7871: LD_INT 1
7873: PUSH
7874: LD_INT 2
7876: PUSH
7877: LD_INT 3
7879: PUSH
7880: LD_INT 4
7882: PUSH
7883: LD_INT 5
7885: PUSH
7886: EMPTY
7887: LIST
7888: LIST
7889: LIST
7890: LIST
7891: LIST
7892: ST_TO_ADDR
7893: GO 8824
7895: LD_INT 11
7897: DOUBLE
7898: EQUAL
7899: IFTRUE 7903
7901: GO 7933
7903: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
7904: LD_ADDR_VAR 0 3
7908: PUSH
7909: LD_INT 1
7911: PUSH
7912: LD_INT 2
7914: PUSH
7915: LD_INT 3
7917: PUSH
7918: LD_INT 4
7920: PUSH
7921: LD_INT 5
7923: PUSH
7924: EMPTY
7925: LIST
7926: LIST
7927: LIST
7928: LIST
7929: LIST
7930: ST_TO_ADDR
7931: GO 8824
7933: LD_INT 4
7935: DOUBLE
7936: EQUAL
7937: IFTRUE 7941
7939: GO 7967
7941: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
7942: LD_ADDR_VAR 0 3
7946: PUSH
7947: LD_INT 2
7949: PUSH
7950: LD_INT 3
7952: PUSH
7953: LD_INT 4
7955: PUSH
7956: LD_INT 5
7958: PUSH
7959: EMPTY
7960: LIST
7961: LIST
7962: LIST
7963: LIST
7964: ST_TO_ADDR
7965: GO 8824
7967: LD_INT 5
7969: DOUBLE
7970: EQUAL
7971: IFTRUE 7975
7973: GO 8001
7975: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
7976: LD_ADDR_VAR 0 3
7980: PUSH
7981: LD_INT 2
7983: PUSH
7984: LD_INT 3
7986: PUSH
7987: LD_INT 4
7989: PUSH
7990: LD_INT 5
7992: PUSH
7993: EMPTY
7994: LIST
7995: LIST
7996: LIST
7997: LIST
7998: ST_TO_ADDR
7999: GO 8824
8001: LD_INT 9
8003: DOUBLE
8004: EQUAL
8005: IFTRUE 8009
8007: GO 8035
8009: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
8010: LD_ADDR_VAR 0 3
8014: PUSH
8015: LD_INT 2
8017: PUSH
8018: LD_INT 3
8020: PUSH
8021: LD_INT 4
8023: PUSH
8024: LD_INT 5
8026: PUSH
8027: EMPTY
8028: LIST
8029: LIST
8030: LIST
8031: LIST
8032: ST_TO_ADDR
8033: GO 8824
8035: LD_INT 7
8037: DOUBLE
8038: EQUAL
8039: IFTRUE 8043
8041: GO 8069
8043: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
8044: LD_ADDR_VAR 0 3
8048: PUSH
8049: LD_INT 2
8051: PUSH
8052: LD_INT 3
8054: PUSH
8055: LD_INT 4
8057: PUSH
8058: LD_INT 5
8060: PUSH
8061: EMPTY
8062: LIST
8063: LIST
8064: LIST
8065: LIST
8066: ST_TO_ADDR
8067: GO 8824
8069: LD_INT 12
8071: DOUBLE
8072: EQUAL
8073: IFTRUE 8077
8075: GO 8103
8077: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
8078: LD_ADDR_VAR 0 3
8082: PUSH
8083: LD_INT 2
8085: PUSH
8086: LD_INT 3
8088: PUSH
8089: LD_INT 4
8091: PUSH
8092: LD_INT 5
8094: PUSH
8095: EMPTY
8096: LIST
8097: LIST
8098: LIST
8099: LIST
8100: ST_TO_ADDR
8101: GO 8824
8103: LD_INT 13
8105: DOUBLE
8106: EQUAL
8107: IFTRUE 8111
8109: GO 8137
8111: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
8112: LD_ADDR_VAR 0 3
8116: PUSH
8117: LD_INT 2
8119: PUSH
8120: LD_INT 3
8122: PUSH
8123: LD_INT 4
8125: PUSH
8126: LD_INT 5
8128: PUSH
8129: EMPTY
8130: LIST
8131: LIST
8132: LIST
8133: LIST
8134: ST_TO_ADDR
8135: GO 8824
8137: LD_INT 14
8139: DOUBLE
8140: EQUAL
8141: IFTRUE 8145
8143: GO 8163
8145: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
8146: LD_ADDR_VAR 0 3
8150: PUSH
8151: LD_INT 4
8153: PUSH
8154: LD_INT 5
8156: PUSH
8157: EMPTY
8158: LIST
8159: LIST
8160: ST_TO_ADDR
8161: GO 8824
8163: LD_INT 6
8165: DOUBLE
8166: EQUAL
8167: IFTRUE 8171
8169: GO 8189
8171: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
8172: LD_ADDR_VAR 0 3
8176: PUSH
8177: LD_INT 4
8179: PUSH
8180: LD_INT 5
8182: PUSH
8183: EMPTY
8184: LIST
8185: LIST
8186: ST_TO_ADDR
8187: GO 8824
8189: LD_INT 10
8191: DOUBLE
8192: EQUAL
8193: IFTRUE 8197
8195: GO 8215
8197: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
8198: LD_ADDR_VAR 0 3
8202: PUSH
8203: LD_INT 4
8205: PUSH
8206: LD_INT 5
8208: PUSH
8209: EMPTY
8210: LIST
8211: LIST
8212: ST_TO_ADDR
8213: GO 8824
8215: LD_INT 22
8217: DOUBLE
8218: EQUAL
8219: IFTRUE 8223
8221: GO 8249
8223: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
8224: LD_ADDR_VAR 0 3
8228: PUSH
8229: LD_INT 11
8231: PUSH
8232: LD_INT 12
8234: PUSH
8235: LD_INT 13
8237: PUSH
8238: LD_INT 14
8240: PUSH
8241: EMPTY
8242: LIST
8243: LIST
8244: LIST
8245: LIST
8246: ST_TO_ADDR
8247: GO 8824
8249: LD_INT 23
8251: DOUBLE
8252: EQUAL
8253: IFTRUE 8257
8255: GO 8283
8257: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
8258: LD_ADDR_VAR 0 3
8262: PUSH
8263: LD_INT 11
8265: PUSH
8266: LD_INT 12
8268: PUSH
8269: LD_INT 13
8271: PUSH
8272: LD_INT 14
8274: PUSH
8275: EMPTY
8276: LIST
8277: LIST
8278: LIST
8279: LIST
8280: ST_TO_ADDR
8281: GO 8824
8283: LD_INT 24
8285: DOUBLE
8286: EQUAL
8287: IFTRUE 8291
8289: GO 8317
8291: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
8292: LD_ADDR_VAR 0 3
8296: PUSH
8297: LD_INT 11
8299: PUSH
8300: LD_INT 12
8302: PUSH
8303: LD_INT 13
8305: PUSH
8306: LD_INT 14
8308: PUSH
8309: EMPTY
8310: LIST
8311: LIST
8312: LIST
8313: LIST
8314: ST_TO_ADDR
8315: GO 8824
8317: LD_INT 30
8319: DOUBLE
8320: EQUAL
8321: IFTRUE 8325
8323: GO 8351
8325: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
8326: LD_ADDR_VAR 0 3
8330: PUSH
8331: LD_INT 11
8333: PUSH
8334: LD_INT 12
8336: PUSH
8337: LD_INT 13
8339: PUSH
8340: LD_INT 14
8342: PUSH
8343: EMPTY
8344: LIST
8345: LIST
8346: LIST
8347: LIST
8348: ST_TO_ADDR
8349: GO 8824
8351: LD_INT 25
8353: DOUBLE
8354: EQUAL
8355: IFTRUE 8359
8357: GO 8377
8359: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
8360: LD_ADDR_VAR 0 3
8364: PUSH
8365: LD_INT 13
8367: PUSH
8368: LD_INT 14
8370: PUSH
8371: EMPTY
8372: LIST
8373: LIST
8374: ST_TO_ADDR
8375: GO 8824
8377: LD_INT 27
8379: DOUBLE
8380: EQUAL
8381: IFTRUE 8385
8383: GO 8403
8385: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
8386: LD_ADDR_VAR 0 3
8390: PUSH
8391: LD_INT 13
8393: PUSH
8394: LD_INT 14
8396: PUSH
8397: EMPTY
8398: LIST
8399: LIST
8400: ST_TO_ADDR
8401: GO 8824
8403: LD_INT 28
8405: DOUBLE
8406: EQUAL
8407: IFTRUE 8411
8409: GO 8429
8411: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
8412: LD_ADDR_VAR 0 3
8416: PUSH
8417: LD_INT 13
8419: PUSH
8420: LD_INT 14
8422: PUSH
8423: EMPTY
8424: LIST
8425: LIST
8426: ST_TO_ADDR
8427: GO 8824
8429: LD_INT 29
8431: DOUBLE
8432: EQUAL
8433: IFTRUE 8437
8435: GO 8455
8437: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
8438: LD_ADDR_VAR 0 3
8442: PUSH
8443: LD_INT 13
8445: PUSH
8446: LD_INT 14
8448: PUSH
8449: EMPTY
8450: LIST
8451: LIST
8452: ST_TO_ADDR
8453: GO 8824
8455: LD_INT 31
8457: DOUBLE
8458: EQUAL
8459: IFTRUE 8463
8461: GO 8481
8463: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
8464: LD_ADDR_VAR 0 3
8468: PUSH
8469: LD_INT 13
8471: PUSH
8472: LD_INT 14
8474: PUSH
8475: EMPTY
8476: LIST
8477: LIST
8478: ST_TO_ADDR
8479: GO 8824
8481: LD_INT 26
8483: DOUBLE
8484: EQUAL
8485: IFTRUE 8489
8487: GO 8507
8489: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
8490: LD_ADDR_VAR 0 3
8494: PUSH
8495: LD_INT 13
8497: PUSH
8498: LD_INT 14
8500: PUSH
8501: EMPTY
8502: LIST
8503: LIST
8504: ST_TO_ADDR
8505: GO 8824
8507: LD_INT 42
8509: DOUBLE
8510: EQUAL
8511: IFTRUE 8515
8513: GO 8541
8515: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
8516: LD_ADDR_VAR 0 3
8520: PUSH
8521: LD_INT 21
8523: PUSH
8524: LD_INT 22
8526: PUSH
8527: LD_INT 23
8529: PUSH
8530: LD_INT 24
8532: PUSH
8533: EMPTY
8534: LIST
8535: LIST
8536: LIST
8537: LIST
8538: ST_TO_ADDR
8539: GO 8824
8541: LD_INT 43
8543: DOUBLE
8544: EQUAL
8545: IFTRUE 8549
8547: GO 8575
8549: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
8550: LD_ADDR_VAR 0 3
8554: PUSH
8555: LD_INT 21
8557: PUSH
8558: LD_INT 22
8560: PUSH
8561: LD_INT 23
8563: PUSH
8564: LD_INT 24
8566: PUSH
8567: EMPTY
8568: LIST
8569: LIST
8570: LIST
8571: LIST
8572: ST_TO_ADDR
8573: GO 8824
8575: LD_INT 44
8577: DOUBLE
8578: EQUAL
8579: IFTRUE 8583
8581: GO 8609
8583: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
8584: LD_ADDR_VAR 0 3
8588: PUSH
8589: LD_INT 21
8591: PUSH
8592: LD_INT 22
8594: PUSH
8595: LD_INT 23
8597: PUSH
8598: LD_INT 24
8600: PUSH
8601: EMPTY
8602: LIST
8603: LIST
8604: LIST
8605: LIST
8606: ST_TO_ADDR
8607: GO 8824
8609: LD_INT 45
8611: DOUBLE
8612: EQUAL
8613: IFTRUE 8617
8615: GO 8643
8617: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
8618: LD_ADDR_VAR 0 3
8622: PUSH
8623: LD_INT 21
8625: PUSH
8626: LD_INT 22
8628: PUSH
8629: LD_INT 23
8631: PUSH
8632: LD_INT 24
8634: PUSH
8635: EMPTY
8636: LIST
8637: LIST
8638: LIST
8639: LIST
8640: ST_TO_ADDR
8641: GO 8824
8643: LD_INT 49
8645: DOUBLE
8646: EQUAL
8647: IFTRUE 8651
8649: GO 8677
8651: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
8652: LD_ADDR_VAR 0 3
8656: PUSH
8657: LD_INT 21
8659: PUSH
8660: LD_INT 22
8662: PUSH
8663: LD_INT 23
8665: PUSH
8666: LD_INT 24
8668: PUSH
8669: EMPTY
8670: LIST
8671: LIST
8672: LIST
8673: LIST
8674: ST_TO_ADDR
8675: GO 8824
8677: LD_INT 51
8679: DOUBLE
8680: EQUAL
8681: IFTRUE 8685
8683: GO 8711
8685: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
8686: LD_ADDR_VAR 0 3
8690: PUSH
8691: LD_INT 21
8693: PUSH
8694: LD_INT 22
8696: PUSH
8697: LD_INT 23
8699: PUSH
8700: LD_INT 24
8702: PUSH
8703: EMPTY
8704: LIST
8705: LIST
8706: LIST
8707: LIST
8708: ST_TO_ADDR
8709: GO 8824
8711: LD_INT 52
8713: DOUBLE
8714: EQUAL
8715: IFTRUE 8719
8717: GO 8745
8719: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
8720: LD_ADDR_VAR 0 3
8724: PUSH
8725: LD_INT 21
8727: PUSH
8728: LD_INT 22
8730: PUSH
8731: LD_INT 23
8733: PUSH
8734: LD_INT 24
8736: PUSH
8737: EMPTY
8738: LIST
8739: LIST
8740: LIST
8741: LIST
8742: ST_TO_ADDR
8743: GO 8824
8745: LD_INT 53
8747: DOUBLE
8748: EQUAL
8749: IFTRUE 8753
8751: GO 8771
8753: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
8754: LD_ADDR_VAR 0 3
8758: PUSH
8759: LD_INT 23
8761: PUSH
8762: LD_INT 24
8764: PUSH
8765: EMPTY
8766: LIST
8767: LIST
8768: ST_TO_ADDR
8769: GO 8824
8771: LD_INT 46
8773: DOUBLE
8774: EQUAL
8775: IFTRUE 8779
8777: GO 8797
8779: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
8780: LD_ADDR_VAR 0 3
8784: PUSH
8785: LD_INT 23
8787: PUSH
8788: LD_INT 24
8790: PUSH
8791: EMPTY
8792: LIST
8793: LIST
8794: ST_TO_ADDR
8795: GO 8824
8797: LD_INT 47
8799: DOUBLE
8800: EQUAL
8801: IFTRUE 8805
8803: GO 8823
8805: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
8806: LD_ADDR_VAR 0 3
8810: PUSH
8811: LD_INT 23
8813: PUSH
8814: LD_INT 24
8816: PUSH
8817: EMPTY
8818: LIST
8819: LIST
8820: ST_TO_ADDR
8821: GO 8824
8823: POP
// result := ( chassis in result ) ;
8824: LD_ADDR_VAR 0 3
8828: PUSH
8829: LD_VAR 0 1
8833: PUSH
8834: LD_VAR 0 3
8838: IN
8839: ST_TO_ADDR
// end ;
8840: LD_VAR 0 3
8844: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
8845: LD_INT 0
8847: PPUSH
8848: PPUSH
8849: PPUSH
8850: PPUSH
8851: PPUSH
8852: PPUSH
8853: PPUSH
// result := array ;
8854: LD_ADDR_VAR 0 5
8858: PUSH
8859: LD_VAR 0 1
8863: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
8864: LD_VAR 0 1
8868: NOT
8869: PUSH
8870: LD_VAR 0 2
8874: NOT
8875: OR
8876: PUSH
8877: LD_VAR 0 3
8881: NOT
8882: OR
8883: PUSH
8884: LD_VAR 0 2
8888: PUSH
8889: LD_VAR 0 1
8893: GREATER
8894: OR
8895: PUSH
8896: LD_VAR 0 3
8900: PUSH
8901: LD_VAR 0 1
8905: GREATER
8906: OR
8907: IFFALSE 8911
// exit ;
8909: GO 9207
// if direction then
8911: LD_VAR 0 4
8915: IFFALSE 8979
// begin d := 1 ;
8917: LD_ADDR_VAR 0 9
8921: PUSH
8922: LD_INT 1
8924: ST_TO_ADDR
// if i_from > i_to then
8925: LD_VAR 0 2
8929: PUSH
8930: LD_VAR 0 3
8934: GREATER
8935: IFFALSE 8961
// length := ( array - i_from ) + i_to else
8937: LD_ADDR_VAR 0 11
8941: PUSH
8942: LD_VAR 0 1
8946: PUSH
8947: LD_VAR 0 2
8951: MINUS
8952: PUSH
8953: LD_VAR 0 3
8957: PLUS
8958: ST_TO_ADDR
8959: GO 8977
// length := i_to - i_from ;
8961: LD_ADDR_VAR 0 11
8965: PUSH
8966: LD_VAR 0 3
8970: PUSH
8971: LD_VAR 0 2
8975: MINUS
8976: ST_TO_ADDR
// end else
8977: GO 9040
// begin d := - 1 ;
8979: LD_ADDR_VAR 0 9
8983: PUSH
8984: LD_INT 1
8986: NEG
8987: ST_TO_ADDR
// if i_from > i_to then
8988: LD_VAR 0 2
8992: PUSH
8993: LD_VAR 0 3
8997: GREATER
8998: IFFALSE 9018
// length := i_from - i_to else
9000: LD_ADDR_VAR 0 11
9004: PUSH
9005: LD_VAR 0 2
9009: PUSH
9010: LD_VAR 0 3
9014: MINUS
9015: ST_TO_ADDR
9016: GO 9040
// length := ( array - i_to ) + i_from ;
9018: LD_ADDR_VAR 0 11
9022: PUSH
9023: LD_VAR 0 1
9027: PUSH
9028: LD_VAR 0 3
9032: MINUS
9033: PUSH
9034: LD_VAR 0 2
9038: PLUS
9039: ST_TO_ADDR
// end ; if not length then
9040: LD_VAR 0 11
9044: NOT
9045: IFFALSE 9049
// exit ;
9047: GO 9207
// tmp := array ;
9049: LD_ADDR_VAR 0 10
9053: PUSH
9054: LD_VAR 0 1
9058: ST_TO_ADDR
// for i = 1 to length do
9059: LD_ADDR_VAR 0 6
9063: PUSH
9064: DOUBLE
9065: LD_INT 1
9067: DEC
9068: ST_TO_ADDR
9069: LD_VAR 0 11
9073: PUSH
9074: FOR_TO
9075: IFFALSE 9195
// begin for j = 1 to array do
9077: LD_ADDR_VAR 0 7
9081: PUSH
9082: DOUBLE
9083: LD_INT 1
9085: DEC
9086: ST_TO_ADDR
9087: LD_VAR 0 1
9091: PUSH
9092: FOR_TO
9093: IFFALSE 9181
// begin k := j + d ;
9095: LD_ADDR_VAR 0 8
9099: PUSH
9100: LD_VAR 0 7
9104: PUSH
9105: LD_VAR 0 9
9109: PLUS
9110: ST_TO_ADDR
// if k > array then
9111: LD_VAR 0 8
9115: PUSH
9116: LD_VAR 0 1
9120: GREATER
9121: IFFALSE 9131
// k := 1 ;
9123: LD_ADDR_VAR 0 8
9127: PUSH
9128: LD_INT 1
9130: ST_TO_ADDR
// if not k then
9131: LD_VAR 0 8
9135: NOT
9136: IFFALSE 9148
// k := array ;
9138: LD_ADDR_VAR 0 8
9142: PUSH
9143: LD_VAR 0 1
9147: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
9148: LD_ADDR_VAR 0 10
9152: PUSH
9153: LD_VAR 0 10
9157: PPUSH
9158: LD_VAR 0 8
9162: PPUSH
9163: LD_VAR 0 1
9167: PUSH
9168: LD_VAR 0 7
9172: ARRAY
9173: PPUSH
9174: CALL_OW 1
9178: ST_TO_ADDR
// end ;
9179: GO 9092
9181: POP
9182: POP
// array := tmp ;
9183: LD_ADDR_VAR 0 1
9187: PUSH
9188: LD_VAR 0 10
9192: ST_TO_ADDR
// end ;
9193: GO 9074
9195: POP
9196: POP
// result := array ;
9197: LD_ADDR_VAR 0 5
9201: PUSH
9202: LD_VAR 0 1
9206: ST_TO_ADDR
// end ;
9207: LD_VAR 0 5
9211: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
9212: LD_INT 0
9214: PPUSH
9215: PPUSH
// result := 0 ;
9216: LD_ADDR_VAR 0 3
9220: PUSH
9221: LD_INT 0
9223: ST_TO_ADDR
// if not array or not value in array then
9224: LD_VAR 0 1
9228: NOT
9229: PUSH
9230: LD_VAR 0 2
9234: PUSH
9235: LD_VAR 0 1
9239: IN
9240: NOT
9241: OR
9242: IFFALSE 9246
// exit ;
9244: GO 9300
// for i = 1 to array do
9246: LD_ADDR_VAR 0 4
9250: PUSH
9251: DOUBLE
9252: LD_INT 1
9254: DEC
9255: ST_TO_ADDR
9256: LD_VAR 0 1
9260: PUSH
9261: FOR_TO
9262: IFFALSE 9298
// if value = array [ i ] then
9264: LD_VAR 0 2
9268: PUSH
9269: LD_VAR 0 1
9273: PUSH
9274: LD_VAR 0 4
9278: ARRAY
9279: EQUAL
9280: IFFALSE 9296
// begin result := i ;
9282: LD_ADDR_VAR 0 3
9286: PUSH
9287: LD_VAR 0 4
9291: ST_TO_ADDR
// exit ;
9292: POP
9293: POP
9294: GO 9300
// end ;
9296: GO 9261
9298: POP
9299: POP
// end ;
9300: LD_VAR 0 3
9304: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
9305: LD_INT 0
9307: PPUSH
// vc_chassis := chassis ;
9308: LD_ADDR_OWVAR 37
9312: PUSH
9313: LD_VAR 0 1
9317: ST_TO_ADDR
// vc_engine := engine ;
9318: LD_ADDR_OWVAR 39
9322: PUSH
9323: LD_VAR 0 2
9327: ST_TO_ADDR
// vc_control := control ;
9328: LD_ADDR_OWVAR 38
9332: PUSH
9333: LD_VAR 0 3
9337: ST_TO_ADDR
// vc_weapon := weapon ;
9338: LD_ADDR_OWVAR 40
9342: PUSH
9343: LD_VAR 0 4
9347: ST_TO_ADDR
// vc_fuel_battery := fuel ;
9348: LD_ADDR_OWVAR 41
9352: PUSH
9353: LD_VAR 0 5
9357: ST_TO_ADDR
// end ;
9358: LD_VAR 0 6
9362: RET
// export function WantPlant ( unit ) ; var task ; begin
9363: LD_INT 0
9365: PPUSH
9366: PPUSH
// result := false ;
9367: LD_ADDR_VAR 0 2
9371: PUSH
9372: LD_INT 0
9374: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
9375: LD_ADDR_VAR 0 3
9379: PUSH
9380: LD_VAR 0 1
9384: PPUSH
9385: CALL_OW 437
9389: ST_TO_ADDR
// if task then
9390: LD_VAR 0 3
9394: IFFALSE 9422
// if task [ 1 ] [ 1 ] = p then
9396: LD_VAR 0 3
9400: PUSH
9401: LD_INT 1
9403: ARRAY
9404: PUSH
9405: LD_INT 1
9407: ARRAY
9408: PUSH
9409: LD_STRING p
9411: EQUAL
9412: IFFALSE 9422
// result := true ;
9414: LD_ADDR_VAR 0 2
9418: PUSH
9419: LD_INT 1
9421: ST_TO_ADDR
// end ;
9422: LD_VAR 0 2
9426: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
9427: LD_INT 0
9429: PPUSH
9430: PPUSH
9431: PPUSH
9432: PPUSH
// if pos < 1 then
9433: LD_VAR 0 2
9437: PUSH
9438: LD_INT 1
9440: LESS
9441: IFFALSE 9445
// exit ;
9443: GO 9748
// if pos = 1 then
9445: LD_VAR 0 2
9449: PUSH
9450: LD_INT 1
9452: EQUAL
9453: IFFALSE 9486
// result := Replace ( arr , pos [ 1 ] , value ) else
9455: LD_ADDR_VAR 0 4
9459: PUSH
9460: LD_VAR 0 1
9464: PPUSH
9465: LD_VAR 0 2
9469: PUSH
9470: LD_INT 1
9472: ARRAY
9473: PPUSH
9474: LD_VAR 0 3
9478: PPUSH
9479: CALL_OW 1
9483: ST_TO_ADDR
9484: GO 9748
// begin tmp := arr ;
9486: LD_ADDR_VAR 0 6
9490: PUSH
9491: LD_VAR 0 1
9495: ST_TO_ADDR
// s_arr := [ tmp ] ;
9496: LD_ADDR_VAR 0 7
9500: PUSH
9501: LD_VAR 0 6
9505: PUSH
9506: EMPTY
9507: LIST
9508: ST_TO_ADDR
// for i = 1 to pos - 1 do
9509: LD_ADDR_VAR 0 5
9513: PUSH
9514: DOUBLE
9515: LD_INT 1
9517: DEC
9518: ST_TO_ADDR
9519: LD_VAR 0 2
9523: PUSH
9524: LD_INT 1
9526: MINUS
9527: PUSH
9528: FOR_TO
9529: IFFALSE 9574
// begin tmp := tmp [ pos [ i ] ] ;
9531: LD_ADDR_VAR 0 6
9535: PUSH
9536: LD_VAR 0 6
9540: PUSH
9541: LD_VAR 0 2
9545: PUSH
9546: LD_VAR 0 5
9550: ARRAY
9551: ARRAY
9552: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
9553: LD_ADDR_VAR 0 7
9557: PUSH
9558: LD_VAR 0 7
9562: PUSH
9563: LD_VAR 0 6
9567: PUSH
9568: EMPTY
9569: LIST
9570: ADD
9571: ST_TO_ADDR
// end ;
9572: GO 9528
9574: POP
9575: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
9576: LD_ADDR_VAR 0 6
9580: PUSH
9581: LD_VAR 0 6
9585: PPUSH
9586: LD_VAR 0 2
9590: PUSH
9591: LD_VAR 0 2
9595: ARRAY
9596: PPUSH
9597: LD_VAR 0 3
9601: PPUSH
9602: CALL_OW 1
9606: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
9607: LD_ADDR_VAR 0 7
9611: PUSH
9612: LD_VAR 0 7
9616: PPUSH
9617: LD_VAR 0 7
9621: PPUSH
9622: LD_VAR 0 6
9626: PPUSH
9627: CALL_OW 1
9631: ST_TO_ADDR
// for i = s_arr downto 2 do
9632: LD_ADDR_VAR 0 5
9636: PUSH
9637: DOUBLE
9638: LD_VAR 0 7
9642: INC
9643: ST_TO_ADDR
9644: LD_INT 2
9646: PUSH
9647: FOR_DOWNTO
9648: IFFALSE 9732
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
9650: LD_ADDR_VAR 0 6
9654: PUSH
9655: LD_VAR 0 7
9659: PUSH
9660: LD_VAR 0 5
9664: PUSH
9665: LD_INT 1
9667: MINUS
9668: ARRAY
9669: PPUSH
9670: LD_VAR 0 2
9674: PUSH
9675: LD_VAR 0 5
9679: PUSH
9680: LD_INT 1
9682: MINUS
9683: ARRAY
9684: PPUSH
9685: LD_VAR 0 7
9689: PUSH
9690: LD_VAR 0 5
9694: ARRAY
9695: PPUSH
9696: CALL_OW 1
9700: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
9701: LD_ADDR_VAR 0 7
9705: PUSH
9706: LD_VAR 0 7
9710: PPUSH
9711: LD_VAR 0 5
9715: PUSH
9716: LD_INT 1
9718: MINUS
9719: PPUSH
9720: LD_VAR 0 6
9724: PPUSH
9725: CALL_OW 1
9729: ST_TO_ADDR
// end ;
9730: GO 9647
9732: POP
9733: POP
// result := s_arr [ 1 ] ;
9734: LD_ADDR_VAR 0 4
9738: PUSH
9739: LD_VAR 0 7
9743: PUSH
9744: LD_INT 1
9746: ARRAY
9747: ST_TO_ADDR
// end ; end ;
9748: LD_VAR 0 4
9752: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
9753: LD_INT 0
9755: PPUSH
9756: PPUSH
// if not list then
9757: LD_VAR 0 1
9761: NOT
9762: IFFALSE 9766
// exit ;
9764: GO 9857
// i := list [ pos1 ] ;
9766: LD_ADDR_VAR 0 5
9770: PUSH
9771: LD_VAR 0 1
9775: PUSH
9776: LD_VAR 0 2
9780: ARRAY
9781: ST_TO_ADDR
// if not i then
9782: LD_VAR 0 5
9786: NOT
9787: IFFALSE 9791
// exit ;
9789: GO 9857
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
9791: LD_ADDR_VAR 0 1
9795: PUSH
9796: LD_VAR 0 1
9800: PPUSH
9801: LD_VAR 0 2
9805: PPUSH
9806: LD_VAR 0 1
9810: PUSH
9811: LD_VAR 0 3
9815: ARRAY
9816: PPUSH
9817: CALL_OW 1
9821: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
9822: LD_ADDR_VAR 0 1
9826: PUSH
9827: LD_VAR 0 1
9831: PPUSH
9832: LD_VAR 0 3
9836: PPUSH
9837: LD_VAR 0 5
9841: PPUSH
9842: CALL_OW 1
9846: ST_TO_ADDR
// result := list ;
9847: LD_ADDR_VAR 0 4
9851: PUSH
9852: LD_VAR 0 1
9856: ST_TO_ADDR
// end ;
9857: LD_VAR 0 4
9861: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
9862: LD_INT 0
9864: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
9865: LD_ADDR_VAR 0 5
9869: PUSH
9870: LD_VAR 0 1
9874: PPUSH
9875: CALL_OW 250
9879: PPUSH
9880: LD_VAR 0 1
9884: PPUSH
9885: CALL_OW 251
9889: PPUSH
9890: LD_VAR 0 2
9894: PPUSH
9895: LD_VAR 0 3
9899: PPUSH
9900: LD_VAR 0 4
9904: PPUSH
9905: CALL 9915 0 5
9909: ST_TO_ADDR
// end ;
9910: LD_VAR 0 5
9914: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
9915: LD_INT 0
9917: PPUSH
9918: PPUSH
9919: PPUSH
9920: PPUSH
// if not list then
9921: LD_VAR 0 3
9925: NOT
9926: IFFALSE 9930
// exit ;
9928: GO 10318
// result := [ ] ;
9930: LD_ADDR_VAR 0 6
9934: PUSH
9935: EMPTY
9936: ST_TO_ADDR
// for i in list do
9937: LD_ADDR_VAR 0 7
9941: PUSH
9942: LD_VAR 0 3
9946: PUSH
9947: FOR_IN
9948: IFFALSE 10150
// begin tmp := GetDistUnitXY ( i , x , y ) ;
9950: LD_ADDR_VAR 0 9
9954: PUSH
9955: LD_VAR 0 7
9959: PPUSH
9960: LD_VAR 0 1
9964: PPUSH
9965: LD_VAR 0 2
9969: PPUSH
9970: CALL_OW 297
9974: ST_TO_ADDR
// if not result then
9975: LD_VAR 0 6
9979: NOT
9980: IFFALSE 10006
// result := [ [ i , tmp ] ] else
9982: LD_ADDR_VAR 0 6
9986: PUSH
9987: LD_VAR 0 7
9991: PUSH
9992: LD_VAR 0 9
9996: PUSH
9997: EMPTY
9998: LIST
9999: LIST
10000: PUSH
10001: EMPTY
10002: LIST
10003: ST_TO_ADDR
10004: GO 10148
// begin if result [ result ] [ 2 ] < tmp then
10006: LD_VAR 0 6
10010: PUSH
10011: LD_VAR 0 6
10015: ARRAY
10016: PUSH
10017: LD_INT 2
10019: ARRAY
10020: PUSH
10021: LD_VAR 0 9
10025: LESS
10026: IFFALSE 10068
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
10028: LD_ADDR_VAR 0 6
10032: PUSH
10033: LD_VAR 0 6
10037: PPUSH
10038: LD_VAR 0 6
10042: PUSH
10043: LD_INT 1
10045: PLUS
10046: PPUSH
10047: LD_VAR 0 7
10051: PUSH
10052: LD_VAR 0 9
10056: PUSH
10057: EMPTY
10058: LIST
10059: LIST
10060: PPUSH
10061: CALL_OW 2
10065: ST_TO_ADDR
10066: GO 10148
// for j = 1 to result do
10068: LD_ADDR_VAR 0 8
10072: PUSH
10073: DOUBLE
10074: LD_INT 1
10076: DEC
10077: ST_TO_ADDR
10078: LD_VAR 0 6
10082: PUSH
10083: FOR_TO
10084: IFFALSE 10146
// begin if tmp < result [ j ] [ 2 ] then
10086: LD_VAR 0 9
10090: PUSH
10091: LD_VAR 0 6
10095: PUSH
10096: LD_VAR 0 8
10100: ARRAY
10101: PUSH
10102: LD_INT 2
10104: ARRAY
10105: LESS
10106: IFFALSE 10144
// begin result := Insert ( result , j , [ i , tmp ] ) ;
10108: LD_ADDR_VAR 0 6
10112: PUSH
10113: LD_VAR 0 6
10117: PPUSH
10118: LD_VAR 0 8
10122: PPUSH
10123: LD_VAR 0 7
10127: PUSH
10128: LD_VAR 0 9
10132: PUSH
10133: EMPTY
10134: LIST
10135: LIST
10136: PPUSH
10137: CALL_OW 2
10141: ST_TO_ADDR
// break ;
10142: GO 10146
// end ; end ;
10144: GO 10083
10146: POP
10147: POP
// end ; end ;
10148: GO 9947
10150: POP
10151: POP
// if result and not asc then
10152: LD_VAR 0 6
10156: PUSH
10157: LD_VAR 0 4
10161: NOT
10162: AND
10163: IFFALSE 10238
// begin tmp := result ;
10165: LD_ADDR_VAR 0 9
10169: PUSH
10170: LD_VAR 0 6
10174: ST_TO_ADDR
// for i = tmp downto 1 do
10175: LD_ADDR_VAR 0 7
10179: PUSH
10180: DOUBLE
10181: LD_VAR 0 9
10185: INC
10186: ST_TO_ADDR
10187: LD_INT 1
10189: PUSH
10190: FOR_DOWNTO
10191: IFFALSE 10236
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
10193: LD_ADDR_VAR 0 6
10197: PUSH
10198: LD_VAR 0 6
10202: PPUSH
10203: LD_VAR 0 9
10207: PUSH
10208: LD_VAR 0 7
10212: MINUS
10213: PUSH
10214: LD_INT 1
10216: PLUS
10217: PPUSH
10218: LD_VAR 0 9
10222: PUSH
10223: LD_VAR 0 7
10227: ARRAY
10228: PPUSH
10229: CALL_OW 1
10233: ST_TO_ADDR
10234: GO 10190
10236: POP
10237: POP
// end ; tmp := [ ] ;
10238: LD_ADDR_VAR 0 9
10242: PUSH
10243: EMPTY
10244: ST_TO_ADDR
// if mode then
10245: LD_VAR 0 5
10249: IFFALSE 10318
// begin for i = 1 to result do
10251: LD_ADDR_VAR 0 7
10255: PUSH
10256: DOUBLE
10257: LD_INT 1
10259: DEC
10260: ST_TO_ADDR
10261: LD_VAR 0 6
10265: PUSH
10266: FOR_TO
10267: IFFALSE 10306
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
10269: LD_ADDR_VAR 0 9
10273: PUSH
10274: LD_VAR 0 9
10278: PPUSH
10279: LD_VAR 0 7
10283: PPUSH
10284: LD_VAR 0 6
10288: PUSH
10289: LD_VAR 0 7
10293: ARRAY
10294: PUSH
10295: LD_INT 1
10297: ARRAY
10298: PPUSH
10299: CALL_OW 1
10303: ST_TO_ADDR
10304: GO 10266
10306: POP
10307: POP
// result := tmp ;
10308: LD_ADDR_VAR 0 6
10312: PUSH
10313: LD_VAR 0 9
10317: ST_TO_ADDR
// end ; end ;
10318: LD_VAR 0 6
10322: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
10323: LD_INT 0
10325: PPUSH
10326: PPUSH
10327: PPUSH
10328: PPUSH
10329: PPUSH
10330: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
10331: LD_ADDR_VAR 0 5
10335: PUSH
10336: LD_INT 0
10338: PUSH
10339: LD_INT 0
10341: PUSH
10342: LD_INT 0
10344: PUSH
10345: EMPTY
10346: PUSH
10347: EMPTY
10348: LIST
10349: LIST
10350: LIST
10351: LIST
10352: ST_TO_ADDR
// if not x or not y then
10353: LD_VAR 0 2
10357: NOT
10358: PUSH
10359: LD_VAR 0 3
10363: NOT
10364: OR
10365: IFFALSE 10369
// exit ;
10367: GO 12015
// if not range then
10369: LD_VAR 0 4
10373: NOT
10374: IFFALSE 10384
// range := 10 ;
10376: LD_ADDR_VAR 0 4
10380: PUSH
10381: LD_INT 10
10383: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
10384: LD_ADDR_VAR 0 8
10388: PUSH
10389: LD_INT 81
10391: PUSH
10392: LD_VAR 0 1
10396: PUSH
10397: EMPTY
10398: LIST
10399: LIST
10400: PUSH
10401: LD_INT 92
10403: PUSH
10404: LD_VAR 0 2
10408: PUSH
10409: LD_VAR 0 3
10413: PUSH
10414: LD_VAR 0 4
10418: PUSH
10419: EMPTY
10420: LIST
10421: LIST
10422: LIST
10423: LIST
10424: PUSH
10425: LD_INT 3
10427: PUSH
10428: LD_INT 21
10430: PUSH
10431: LD_INT 3
10433: PUSH
10434: EMPTY
10435: LIST
10436: LIST
10437: PUSH
10438: EMPTY
10439: LIST
10440: LIST
10441: PUSH
10442: EMPTY
10443: LIST
10444: LIST
10445: LIST
10446: PPUSH
10447: CALL_OW 69
10451: ST_TO_ADDR
// if not tmp then
10452: LD_VAR 0 8
10456: NOT
10457: IFFALSE 10461
// exit ;
10459: GO 12015
// for i in tmp do
10461: LD_ADDR_VAR 0 6
10465: PUSH
10466: LD_VAR 0 8
10470: PUSH
10471: FOR_IN
10472: IFFALSE 11990
// begin points := [ 0 , 0 , 0 ] ;
10474: LD_ADDR_VAR 0 9
10478: PUSH
10479: LD_INT 0
10481: PUSH
10482: LD_INT 0
10484: PUSH
10485: LD_INT 0
10487: PUSH
10488: EMPTY
10489: LIST
10490: LIST
10491: LIST
10492: ST_TO_ADDR
// bpoints := 1 ;
10493: LD_ADDR_VAR 0 10
10497: PUSH
10498: LD_INT 1
10500: ST_TO_ADDR
// case GetType ( i ) of unit_human :
10501: LD_VAR 0 6
10505: PPUSH
10506: CALL_OW 247
10510: PUSH
10511: LD_INT 1
10513: DOUBLE
10514: EQUAL
10515: IFTRUE 10519
10517: GO 11097
10519: POP
// begin if GetClass ( i ) = 1 then
10520: LD_VAR 0 6
10524: PPUSH
10525: CALL_OW 257
10529: PUSH
10530: LD_INT 1
10532: EQUAL
10533: IFFALSE 10554
// points := [ 10 , 5 , 3 ] ;
10535: LD_ADDR_VAR 0 9
10539: PUSH
10540: LD_INT 10
10542: PUSH
10543: LD_INT 5
10545: PUSH
10546: LD_INT 3
10548: PUSH
10549: EMPTY
10550: LIST
10551: LIST
10552: LIST
10553: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
10554: LD_VAR 0 6
10558: PPUSH
10559: CALL_OW 257
10563: PUSH
10564: LD_INT 2
10566: PUSH
10567: LD_INT 3
10569: PUSH
10570: LD_INT 4
10572: PUSH
10573: EMPTY
10574: LIST
10575: LIST
10576: LIST
10577: IN
10578: IFFALSE 10599
// points := [ 3 , 2 , 1 ] ;
10580: LD_ADDR_VAR 0 9
10584: PUSH
10585: LD_INT 3
10587: PUSH
10588: LD_INT 2
10590: PUSH
10591: LD_INT 1
10593: PUSH
10594: EMPTY
10595: LIST
10596: LIST
10597: LIST
10598: ST_TO_ADDR
// if GetClass ( i ) = 5 then
10599: LD_VAR 0 6
10603: PPUSH
10604: CALL_OW 257
10608: PUSH
10609: LD_INT 5
10611: EQUAL
10612: IFFALSE 10633
// points := [ 130 , 5 , 2 ] ;
10614: LD_ADDR_VAR 0 9
10618: PUSH
10619: LD_INT 130
10621: PUSH
10622: LD_INT 5
10624: PUSH
10625: LD_INT 2
10627: PUSH
10628: EMPTY
10629: LIST
10630: LIST
10631: LIST
10632: ST_TO_ADDR
// if GetClass ( i ) = 8 then
10633: LD_VAR 0 6
10637: PPUSH
10638: CALL_OW 257
10642: PUSH
10643: LD_INT 8
10645: EQUAL
10646: IFFALSE 10667
// points := [ 35 , 35 , 30 ] ;
10648: LD_ADDR_VAR 0 9
10652: PUSH
10653: LD_INT 35
10655: PUSH
10656: LD_INT 35
10658: PUSH
10659: LD_INT 30
10661: PUSH
10662: EMPTY
10663: LIST
10664: LIST
10665: LIST
10666: ST_TO_ADDR
// if GetClass ( i ) = 9 then
10667: LD_VAR 0 6
10671: PPUSH
10672: CALL_OW 257
10676: PUSH
10677: LD_INT 9
10679: EQUAL
10680: IFFALSE 10701
// points := [ 20 , 55 , 40 ] ;
10682: LD_ADDR_VAR 0 9
10686: PUSH
10687: LD_INT 20
10689: PUSH
10690: LD_INT 55
10692: PUSH
10693: LD_INT 40
10695: PUSH
10696: EMPTY
10697: LIST
10698: LIST
10699: LIST
10700: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
10701: LD_VAR 0 6
10705: PPUSH
10706: CALL_OW 257
10710: PUSH
10711: LD_INT 12
10713: PUSH
10714: LD_INT 16
10716: PUSH
10717: EMPTY
10718: LIST
10719: LIST
10720: IN
10721: IFFALSE 10742
// points := [ 5 , 3 , 2 ] ;
10723: LD_ADDR_VAR 0 9
10727: PUSH
10728: LD_INT 5
10730: PUSH
10731: LD_INT 3
10733: PUSH
10734: LD_INT 2
10736: PUSH
10737: EMPTY
10738: LIST
10739: LIST
10740: LIST
10741: ST_TO_ADDR
// if GetClass ( i ) = 17 then
10742: LD_VAR 0 6
10746: PPUSH
10747: CALL_OW 257
10751: PUSH
10752: LD_INT 17
10754: EQUAL
10755: IFFALSE 10776
// points := [ 100 , 50 , 75 ] ;
10757: LD_ADDR_VAR 0 9
10761: PUSH
10762: LD_INT 100
10764: PUSH
10765: LD_INT 50
10767: PUSH
10768: LD_INT 75
10770: PUSH
10771: EMPTY
10772: LIST
10773: LIST
10774: LIST
10775: ST_TO_ADDR
// if GetClass ( i ) = 15 then
10776: LD_VAR 0 6
10780: PPUSH
10781: CALL_OW 257
10785: PUSH
10786: LD_INT 15
10788: EQUAL
10789: IFFALSE 10810
// points := [ 10 , 5 , 3 ] ;
10791: LD_ADDR_VAR 0 9
10795: PUSH
10796: LD_INT 10
10798: PUSH
10799: LD_INT 5
10801: PUSH
10802: LD_INT 3
10804: PUSH
10805: EMPTY
10806: LIST
10807: LIST
10808: LIST
10809: ST_TO_ADDR
// if GetClass ( i ) = 14 then
10810: LD_VAR 0 6
10814: PPUSH
10815: CALL_OW 257
10819: PUSH
10820: LD_INT 14
10822: EQUAL
10823: IFFALSE 10844
// points := [ 10 , 0 , 0 ] ;
10825: LD_ADDR_VAR 0 9
10829: PUSH
10830: LD_INT 10
10832: PUSH
10833: LD_INT 0
10835: PUSH
10836: LD_INT 0
10838: PUSH
10839: EMPTY
10840: LIST
10841: LIST
10842: LIST
10843: ST_TO_ADDR
// if GetClass ( i ) = 11 then
10844: LD_VAR 0 6
10848: PPUSH
10849: CALL_OW 257
10853: PUSH
10854: LD_INT 11
10856: EQUAL
10857: IFFALSE 10878
// points := [ 30 , 10 , 5 ] ;
10859: LD_ADDR_VAR 0 9
10863: PUSH
10864: LD_INT 30
10866: PUSH
10867: LD_INT 10
10869: PUSH
10870: LD_INT 5
10872: PUSH
10873: EMPTY
10874: LIST
10875: LIST
10876: LIST
10877: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
10878: LD_VAR 0 1
10882: PPUSH
10883: LD_INT 5
10885: PPUSH
10886: CALL_OW 321
10890: PUSH
10891: LD_INT 2
10893: EQUAL
10894: IFFALSE 10911
// bpoints := bpoints * 1.8 ;
10896: LD_ADDR_VAR 0 10
10900: PUSH
10901: LD_VAR 0 10
10905: PUSH
10906: LD_REAL  1.80000000000000E+0000
10909: MUL
10910: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
10911: LD_VAR 0 6
10915: PPUSH
10916: CALL_OW 257
10920: PUSH
10921: LD_INT 1
10923: PUSH
10924: LD_INT 2
10926: PUSH
10927: LD_INT 3
10929: PUSH
10930: LD_INT 4
10932: PUSH
10933: EMPTY
10934: LIST
10935: LIST
10936: LIST
10937: LIST
10938: IN
10939: PUSH
10940: LD_VAR 0 1
10944: PPUSH
10945: LD_INT 51
10947: PPUSH
10948: CALL_OW 321
10952: PUSH
10953: LD_INT 2
10955: EQUAL
10956: AND
10957: IFFALSE 10974
// bpoints := bpoints * 1.2 ;
10959: LD_ADDR_VAR 0 10
10963: PUSH
10964: LD_VAR 0 10
10968: PUSH
10969: LD_REAL  1.20000000000000E+0000
10972: MUL
10973: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
10974: LD_VAR 0 6
10978: PPUSH
10979: CALL_OW 257
10983: PUSH
10984: LD_INT 5
10986: PUSH
10987: LD_INT 7
10989: PUSH
10990: LD_INT 9
10992: PUSH
10993: EMPTY
10994: LIST
10995: LIST
10996: LIST
10997: IN
10998: PUSH
10999: LD_VAR 0 1
11003: PPUSH
11004: LD_INT 52
11006: PPUSH
11007: CALL_OW 321
11011: PUSH
11012: LD_INT 2
11014: EQUAL
11015: AND
11016: IFFALSE 11033
// bpoints := bpoints * 1.5 ;
11018: LD_ADDR_VAR 0 10
11022: PUSH
11023: LD_VAR 0 10
11027: PUSH
11028: LD_REAL  1.50000000000000E+0000
11031: MUL
11032: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
11033: LD_VAR 0 1
11037: PPUSH
11038: LD_INT 66
11040: PPUSH
11041: CALL_OW 321
11045: PUSH
11046: LD_INT 2
11048: EQUAL
11049: IFFALSE 11066
// bpoints := bpoints * 1.1 ;
11051: LD_ADDR_VAR 0 10
11055: PUSH
11056: LD_VAR 0 10
11060: PUSH
11061: LD_REAL  1.10000000000000E+0000
11064: MUL
11065: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
11066: LD_ADDR_VAR 0 10
11070: PUSH
11071: LD_VAR 0 10
11075: PUSH
11076: LD_VAR 0 6
11080: PPUSH
11081: LD_INT 1
11083: PPUSH
11084: CALL_OW 259
11088: PUSH
11089: LD_REAL  1.15000000000000E+0000
11092: MUL
11093: MUL
11094: ST_TO_ADDR
// end ; unit_vehicle :
11095: GO 11919
11097: LD_INT 2
11099: DOUBLE
11100: EQUAL
11101: IFTRUE 11105
11103: GO 11907
11105: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
11106: LD_VAR 0 6
11110: PPUSH
11111: CALL_OW 264
11115: PUSH
11116: LD_INT 2
11118: PUSH
11119: LD_INT 42
11121: PUSH
11122: LD_INT 24
11124: PUSH
11125: EMPTY
11126: LIST
11127: LIST
11128: LIST
11129: IN
11130: IFFALSE 11151
// points := [ 25 , 5 , 3 ] ;
11132: LD_ADDR_VAR 0 9
11136: PUSH
11137: LD_INT 25
11139: PUSH
11140: LD_INT 5
11142: PUSH
11143: LD_INT 3
11145: PUSH
11146: EMPTY
11147: LIST
11148: LIST
11149: LIST
11150: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
11151: LD_VAR 0 6
11155: PPUSH
11156: CALL_OW 264
11160: PUSH
11161: LD_INT 4
11163: PUSH
11164: LD_INT 43
11166: PUSH
11167: LD_INT 25
11169: PUSH
11170: EMPTY
11171: LIST
11172: LIST
11173: LIST
11174: IN
11175: IFFALSE 11196
// points := [ 40 , 15 , 5 ] ;
11177: LD_ADDR_VAR 0 9
11181: PUSH
11182: LD_INT 40
11184: PUSH
11185: LD_INT 15
11187: PUSH
11188: LD_INT 5
11190: PUSH
11191: EMPTY
11192: LIST
11193: LIST
11194: LIST
11195: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
11196: LD_VAR 0 6
11200: PPUSH
11201: CALL_OW 264
11205: PUSH
11206: LD_INT 3
11208: PUSH
11209: LD_INT 23
11211: PUSH
11212: EMPTY
11213: LIST
11214: LIST
11215: IN
11216: IFFALSE 11237
// points := [ 7 , 25 , 8 ] ;
11218: LD_ADDR_VAR 0 9
11222: PUSH
11223: LD_INT 7
11225: PUSH
11226: LD_INT 25
11228: PUSH
11229: LD_INT 8
11231: PUSH
11232: EMPTY
11233: LIST
11234: LIST
11235: LIST
11236: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
11237: LD_VAR 0 6
11241: PPUSH
11242: CALL_OW 264
11246: PUSH
11247: LD_INT 5
11249: PUSH
11250: LD_INT 27
11252: PUSH
11253: LD_INT 44
11255: PUSH
11256: EMPTY
11257: LIST
11258: LIST
11259: LIST
11260: IN
11261: IFFALSE 11282
// points := [ 14 , 50 , 16 ] ;
11263: LD_ADDR_VAR 0 9
11267: PUSH
11268: LD_INT 14
11270: PUSH
11271: LD_INT 50
11273: PUSH
11274: LD_INT 16
11276: PUSH
11277: EMPTY
11278: LIST
11279: LIST
11280: LIST
11281: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
11282: LD_VAR 0 6
11286: PPUSH
11287: CALL_OW 264
11291: PUSH
11292: LD_INT 6
11294: PUSH
11295: LD_INT 46
11297: PUSH
11298: EMPTY
11299: LIST
11300: LIST
11301: IN
11302: IFFALSE 11323
// points := [ 32 , 120 , 70 ] ;
11304: LD_ADDR_VAR 0 9
11308: PUSH
11309: LD_INT 32
11311: PUSH
11312: LD_INT 120
11314: PUSH
11315: LD_INT 70
11317: PUSH
11318: EMPTY
11319: LIST
11320: LIST
11321: LIST
11322: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
11323: LD_VAR 0 6
11327: PPUSH
11328: CALL_OW 264
11332: PUSH
11333: LD_INT 7
11335: PUSH
11336: LD_INT 28
11338: PUSH
11339: LD_INT 45
11341: PUSH
11342: EMPTY
11343: LIST
11344: LIST
11345: LIST
11346: IN
11347: IFFALSE 11368
// points := [ 35 , 20 , 45 ] ;
11349: LD_ADDR_VAR 0 9
11353: PUSH
11354: LD_INT 35
11356: PUSH
11357: LD_INT 20
11359: PUSH
11360: LD_INT 45
11362: PUSH
11363: EMPTY
11364: LIST
11365: LIST
11366: LIST
11367: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
11368: LD_VAR 0 6
11372: PPUSH
11373: CALL_OW 264
11377: PUSH
11378: LD_INT 47
11380: PUSH
11381: EMPTY
11382: LIST
11383: IN
11384: IFFALSE 11405
// points := [ 67 , 45 , 75 ] ;
11386: LD_ADDR_VAR 0 9
11390: PUSH
11391: LD_INT 67
11393: PUSH
11394: LD_INT 45
11396: PUSH
11397: LD_INT 75
11399: PUSH
11400: EMPTY
11401: LIST
11402: LIST
11403: LIST
11404: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
11405: LD_VAR 0 6
11409: PPUSH
11410: CALL_OW 264
11414: PUSH
11415: LD_INT 26
11417: PUSH
11418: EMPTY
11419: LIST
11420: IN
11421: IFFALSE 11442
// points := [ 120 , 30 , 80 ] ;
11423: LD_ADDR_VAR 0 9
11427: PUSH
11428: LD_INT 120
11430: PUSH
11431: LD_INT 30
11433: PUSH
11434: LD_INT 80
11436: PUSH
11437: EMPTY
11438: LIST
11439: LIST
11440: LIST
11441: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
11442: LD_VAR 0 6
11446: PPUSH
11447: CALL_OW 264
11451: PUSH
11452: LD_INT 22
11454: PUSH
11455: EMPTY
11456: LIST
11457: IN
11458: IFFALSE 11479
// points := [ 40 , 1 , 1 ] ;
11460: LD_ADDR_VAR 0 9
11464: PUSH
11465: LD_INT 40
11467: PUSH
11468: LD_INT 1
11470: PUSH
11471: LD_INT 1
11473: PUSH
11474: EMPTY
11475: LIST
11476: LIST
11477: LIST
11478: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
11479: LD_VAR 0 6
11483: PPUSH
11484: CALL_OW 264
11488: PUSH
11489: LD_INT 29
11491: PUSH
11492: EMPTY
11493: LIST
11494: IN
11495: IFFALSE 11516
// points := [ 70 , 200 , 400 ] ;
11497: LD_ADDR_VAR 0 9
11501: PUSH
11502: LD_INT 70
11504: PUSH
11505: LD_INT 200
11507: PUSH
11508: LD_INT 400
11510: PUSH
11511: EMPTY
11512: LIST
11513: LIST
11514: LIST
11515: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
11516: LD_VAR 0 6
11520: PPUSH
11521: CALL_OW 264
11525: PUSH
11526: LD_INT 14
11528: PUSH
11529: LD_INT 53
11531: PUSH
11532: EMPTY
11533: LIST
11534: LIST
11535: IN
11536: IFFALSE 11557
// points := [ 40 , 10 , 20 ] ;
11538: LD_ADDR_VAR 0 9
11542: PUSH
11543: LD_INT 40
11545: PUSH
11546: LD_INT 10
11548: PUSH
11549: LD_INT 20
11551: PUSH
11552: EMPTY
11553: LIST
11554: LIST
11555: LIST
11556: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
11557: LD_VAR 0 6
11561: PPUSH
11562: CALL_OW 264
11566: PUSH
11567: LD_INT 9
11569: PUSH
11570: EMPTY
11571: LIST
11572: IN
11573: IFFALSE 11594
// points := [ 5 , 70 , 20 ] ;
11575: LD_ADDR_VAR 0 9
11579: PUSH
11580: LD_INT 5
11582: PUSH
11583: LD_INT 70
11585: PUSH
11586: LD_INT 20
11588: PUSH
11589: EMPTY
11590: LIST
11591: LIST
11592: LIST
11593: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
11594: LD_VAR 0 6
11598: PPUSH
11599: CALL_OW 264
11603: PUSH
11604: LD_INT 10
11606: PUSH
11607: EMPTY
11608: LIST
11609: IN
11610: IFFALSE 11631
// points := [ 35 , 110 , 70 ] ;
11612: LD_ADDR_VAR 0 9
11616: PUSH
11617: LD_INT 35
11619: PUSH
11620: LD_INT 110
11622: PUSH
11623: LD_INT 70
11625: PUSH
11626: EMPTY
11627: LIST
11628: LIST
11629: LIST
11630: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
11631: LD_VAR 0 6
11635: PPUSH
11636: CALL_OW 265
11640: PUSH
11641: LD_INT 25
11643: EQUAL
11644: IFFALSE 11665
// points := [ 80 , 65 , 100 ] ;
11646: LD_ADDR_VAR 0 9
11650: PUSH
11651: LD_INT 80
11653: PUSH
11654: LD_INT 65
11656: PUSH
11657: LD_INT 100
11659: PUSH
11660: EMPTY
11661: LIST
11662: LIST
11663: LIST
11664: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
11665: LD_VAR 0 6
11669: PPUSH
11670: CALL_OW 263
11674: PUSH
11675: LD_INT 1
11677: EQUAL
11678: IFFALSE 11713
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
11680: LD_ADDR_VAR 0 10
11684: PUSH
11685: LD_VAR 0 10
11689: PUSH
11690: LD_VAR 0 6
11694: PPUSH
11695: CALL_OW 311
11699: PPUSH
11700: LD_INT 3
11702: PPUSH
11703: CALL_OW 259
11707: PUSH
11708: LD_INT 4
11710: MUL
11711: MUL
11712: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
11713: LD_VAR 0 6
11717: PPUSH
11718: CALL_OW 263
11722: PUSH
11723: LD_INT 2
11725: EQUAL
11726: IFFALSE 11777
// begin j := IsControledBy ( i ) ;
11728: LD_ADDR_VAR 0 7
11732: PUSH
11733: LD_VAR 0 6
11737: PPUSH
11738: CALL_OW 312
11742: ST_TO_ADDR
// if j then
11743: LD_VAR 0 7
11747: IFFALSE 11777
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
11749: LD_ADDR_VAR 0 10
11753: PUSH
11754: LD_VAR 0 10
11758: PUSH
11759: LD_VAR 0 7
11763: PPUSH
11764: LD_INT 3
11766: PPUSH
11767: CALL_OW 259
11771: PUSH
11772: LD_INT 3
11774: MUL
11775: MUL
11776: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
11777: LD_VAR 0 6
11781: PPUSH
11782: CALL_OW 264
11786: PUSH
11787: LD_INT 5
11789: PUSH
11790: LD_INT 6
11792: PUSH
11793: LD_INT 46
11795: PUSH
11796: LD_INT 44
11798: PUSH
11799: LD_INT 47
11801: PUSH
11802: LD_INT 45
11804: PUSH
11805: LD_INT 28
11807: PUSH
11808: LD_INT 7
11810: PUSH
11811: LD_INT 27
11813: PUSH
11814: LD_INT 29
11816: PUSH
11817: EMPTY
11818: LIST
11819: LIST
11820: LIST
11821: LIST
11822: LIST
11823: LIST
11824: LIST
11825: LIST
11826: LIST
11827: LIST
11828: IN
11829: PUSH
11830: LD_VAR 0 1
11834: PPUSH
11835: LD_INT 52
11837: PPUSH
11838: CALL_OW 321
11842: PUSH
11843: LD_INT 2
11845: EQUAL
11846: AND
11847: IFFALSE 11864
// bpoints := bpoints * 1.2 ;
11849: LD_ADDR_VAR 0 10
11853: PUSH
11854: LD_VAR 0 10
11858: PUSH
11859: LD_REAL  1.20000000000000E+0000
11862: MUL
11863: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
11864: LD_VAR 0 6
11868: PPUSH
11869: CALL_OW 264
11873: PUSH
11874: LD_INT 6
11876: PUSH
11877: LD_INT 46
11879: PUSH
11880: LD_INT 47
11882: PUSH
11883: EMPTY
11884: LIST
11885: LIST
11886: LIST
11887: IN
11888: IFFALSE 11905
// bpoints := bpoints * 1.2 ;
11890: LD_ADDR_VAR 0 10
11894: PUSH
11895: LD_VAR 0 10
11899: PUSH
11900: LD_REAL  1.20000000000000E+0000
11903: MUL
11904: ST_TO_ADDR
// end ; unit_building :
11905: GO 11919
11907: LD_INT 3
11909: DOUBLE
11910: EQUAL
11911: IFTRUE 11915
11913: GO 11918
11915: POP
// ; end ;
11916: GO 11919
11918: POP
// for j = 1 to 3 do
11919: LD_ADDR_VAR 0 7
11923: PUSH
11924: DOUBLE
11925: LD_INT 1
11927: DEC
11928: ST_TO_ADDR
11929: LD_INT 3
11931: PUSH
11932: FOR_TO
11933: IFFALSE 11986
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
11935: LD_ADDR_VAR 0 5
11939: PUSH
11940: LD_VAR 0 5
11944: PPUSH
11945: LD_VAR 0 7
11949: PPUSH
11950: LD_VAR 0 5
11954: PUSH
11955: LD_VAR 0 7
11959: ARRAY
11960: PUSH
11961: LD_VAR 0 9
11965: PUSH
11966: LD_VAR 0 7
11970: ARRAY
11971: PUSH
11972: LD_VAR 0 10
11976: MUL
11977: PLUS
11978: PPUSH
11979: CALL_OW 1
11983: ST_TO_ADDR
11984: GO 11932
11986: POP
11987: POP
// end ;
11988: GO 10471
11990: POP
11991: POP
// result := Replace ( result , 4 , tmp ) ;
11992: LD_ADDR_VAR 0 5
11996: PUSH
11997: LD_VAR 0 5
12001: PPUSH
12002: LD_INT 4
12004: PPUSH
12005: LD_VAR 0 8
12009: PPUSH
12010: CALL_OW 1
12014: ST_TO_ADDR
// end ;
12015: LD_VAR 0 5
12019: RET
// export function DangerAtRange ( unit , range ) ; begin
12020: LD_INT 0
12022: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
12023: LD_ADDR_VAR 0 3
12027: PUSH
12028: LD_VAR 0 1
12032: PPUSH
12033: CALL_OW 255
12037: PPUSH
12038: LD_VAR 0 1
12042: PPUSH
12043: CALL_OW 250
12047: PPUSH
12048: LD_VAR 0 1
12052: PPUSH
12053: CALL_OW 251
12057: PPUSH
12058: LD_VAR 0 2
12062: PPUSH
12063: CALL 10323 0 4
12067: ST_TO_ADDR
// end ;
12068: LD_VAR 0 3
12072: RET
// export function DangerInArea ( side , area ) ; begin
12073: LD_INT 0
12075: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
12076: LD_ADDR_VAR 0 3
12080: PUSH
12081: LD_VAR 0 2
12085: PPUSH
12086: LD_INT 81
12088: PUSH
12089: LD_VAR 0 1
12093: PUSH
12094: EMPTY
12095: LIST
12096: LIST
12097: PPUSH
12098: CALL_OW 70
12102: ST_TO_ADDR
// end ;
12103: LD_VAR 0 3
12107: RET
// export function IsExtension ( b ) ; begin
12108: LD_INT 0
12110: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
12111: LD_ADDR_VAR 0 2
12115: PUSH
12116: LD_VAR 0 1
12120: PUSH
12121: LD_INT 23
12123: PUSH
12124: LD_INT 20
12126: PUSH
12127: LD_INT 22
12129: PUSH
12130: LD_INT 17
12132: PUSH
12133: LD_INT 24
12135: PUSH
12136: LD_INT 21
12138: PUSH
12139: LD_INT 19
12141: PUSH
12142: LD_INT 16
12144: PUSH
12145: LD_INT 25
12147: PUSH
12148: LD_INT 18
12150: PUSH
12151: EMPTY
12152: LIST
12153: LIST
12154: LIST
12155: LIST
12156: LIST
12157: LIST
12158: LIST
12159: LIST
12160: LIST
12161: LIST
12162: IN
12163: ST_TO_ADDR
// end ;
12164: LD_VAR 0 2
12168: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
12169: LD_INT 0
12171: PPUSH
12172: PPUSH
12173: PPUSH
// result := [ ] ;
12174: LD_ADDR_VAR 0 4
12178: PUSH
12179: EMPTY
12180: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
12181: LD_ADDR_VAR 0 5
12185: PUSH
12186: LD_VAR 0 2
12190: PPUSH
12191: LD_INT 21
12193: PUSH
12194: LD_INT 3
12196: PUSH
12197: EMPTY
12198: LIST
12199: LIST
12200: PPUSH
12201: CALL_OW 70
12205: ST_TO_ADDR
// if not tmp then
12206: LD_VAR 0 5
12210: NOT
12211: IFFALSE 12215
// exit ;
12213: GO 12279
// if checkLink then
12215: LD_VAR 0 3
12219: IFFALSE 12269
// begin for i in tmp do
12221: LD_ADDR_VAR 0 6
12225: PUSH
12226: LD_VAR 0 5
12230: PUSH
12231: FOR_IN
12232: IFFALSE 12267
// if GetBase ( i ) <> base then
12234: LD_VAR 0 6
12238: PPUSH
12239: CALL_OW 274
12243: PUSH
12244: LD_VAR 0 1
12248: NONEQUAL
12249: IFFALSE 12265
// ComLinkToBase ( base , i ) ;
12251: LD_VAR 0 1
12255: PPUSH
12256: LD_VAR 0 6
12260: PPUSH
12261: CALL_OW 169
12265: GO 12231
12267: POP
12268: POP
// end ; result := tmp ;
12269: LD_ADDR_VAR 0 4
12273: PUSH
12274: LD_VAR 0 5
12278: ST_TO_ADDR
// end ;
12279: LD_VAR 0 4
12283: RET
// export function ComComplete ( units , b ) ; var i ; begin
12284: LD_INT 0
12286: PPUSH
12287: PPUSH
// if not units then
12288: LD_VAR 0 1
12292: NOT
12293: IFFALSE 12297
// exit ;
12295: GO 12387
// for i in units do
12297: LD_ADDR_VAR 0 4
12301: PUSH
12302: LD_VAR 0 1
12306: PUSH
12307: FOR_IN
12308: IFFALSE 12385
// if BuildingStatus ( b ) = bs_build then
12310: LD_VAR 0 2
12314: PPUSH
12315: CALL_OW 461
12319: PUSH
12320: LD_INT 1
12322: EQUAL
12323: IFFALSE 12383
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
12325: LD_VAR 0 4
12329: PPUSH
12330: LD_STRING h
12332: PUSH
12333: LD_VAR 0 2
12337: PPUSH
12338: CALL_OW 250
12342: PUSH
12343: LD_VAR 0 2
12347: PPUSH
12348: CALL_OW 251
12352: PUSH
12353: LD_VAR 0 2
12357: PUSH
12358: LD_INT 0
12360: PUSH
12361: LD_INT 0
12363: PUSH
12364: LD_INT 0
12366: PUSH
12367: EMPTY
12368: LIST
12369: LIST
12370: LIST
12371: LIST
12372: LIST
12373: LIST
12374: LIST
12375: PUSH
12376: EMPTY
12377: LIST
12378: PPUSH
12379: CALL_OW 446
12383: GO 12307
12385: POP
12386: POP
// end ;
12387: LD_VAR 0 3
12391: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
12392: LD_INT 0
12394: PPUSH
12395: PPUSH
12396: PPUSH
12397: PPUSH
12398: PPUSH
12399: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
12400: LD_VAR 0 1
12404: NOT
12405: PUSH
12406: LD_VAR 0 1
12410: PPUSH
12411: CALL_OW 263
12415: PUSH
12416: LD_INT 2
12418: EQUAL
12419: NOT
12420: OR
12421: IFFALSE 12425
// exit ;
12423: GO 12741
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
12425: LD_ADDR_VAR 0 6
12429: PUSH
12430: LD_INT 22
12432: PUSH
12433: LD_VAR 0 1
12437: PPUSH
12438: CALL_OW 255
12442: PUSH
12443: EMPTY
12444: LIST
12445: LIST
12446: PUSH
12447: LD_INT 2
12449: PUSH
12450: LD_INT 30
12452: PUSH
12453: LD_INT 36
12455: PUSH
12456: EMPTY
12457: LIST
12458: LIST
12459: PUSH
12460: LD_INT 34
12462: PUSH
12463: LD_INT 31
12465: PUSH
12466: EMPTY
12467: LIST
12468: LIST
12469: PUSH
12470: EMPTY
12471: LIST
12472: LIST
12473: LIST
12474: PUSH
12475: EMPTY
12476: LIST
12477: LIST
12478: PPUSH
12479: CALL_OW 69
12483: ST_TO_ADDR
// if not tmp then
12484: LD_VAR 0 6
12488: NOT
12489: IFFALSE 12493
// exit ;
12491: GO 12741
// result := [ ] ;
12493: LD_ADDR_VAR 0 2
12497: PUSH
12498: EMPTY
12499: ST_TO_ADDR
// for i in tmp do
12500: LD_ADDR_VAR 0 3
12504: PUSH
12505: LD_VAR 0 6
12509: PUSH
12510: FOR_IN
12511: IFFALSE 12582
// begin t := UnitsInside ( i ) ;
12513: LD_ADDR_VAR 0 4
12517: PUSH
12518: LD_VAR 0 3
12522: PPUSH
12523: CALL_OW 313
12527: ST_TO_ADDR
// if t then
12528: LD_VAR 0 4
12532: IFFALSE 12580
// for j in t do
12534: LD_ADDR_VAR 0 7
12538: PUSH
12539: LD_VAR 0 4
12543: PUSH
12544: FOR_IN
12545: IFFALSE 12578
// result := Insert ( result , result + 1 , j ) ;
12547: LD_ADDR_VAR 0 2
12551: PUSH
12552: LD_VAR 0 2
12556: PPUSH
12557: LD_VAR 0 2
12561: PUSH
12562: LD_INT 1
12564: PLUS
12565: PPUSH
12566: LD_VAR 0 7
12570: PPUSH
12571: CALL_OW 2
12575: ST_TO_ADDR
12576: GO 12544
12578: POP
12579: POP
// end ;
12580: GO 12510
12582: POP
12583: POP
// if not result then
12584: LD_VAR 0 2
12588: NOT
12589: IFFALSE 12593
// exit ;
12591: GO 12741
// mech := result [ 1 ] ;
12593: LD_ADDR_VAR 0 5
12597: PUSH
12598: LD_VAR 0 2
12602: PUSH
12603: LD_INT 1
12605: ARRAY
12606: ST_TO_ADDR
// if result > 1 then
12607: LD_VAR 0 2
12611: PUSH
12612: LD_INT 1
12614: GREATER
12615: IFFALSE 12727
// for i = 2 to result do
12617: LD_ADDR_VAR 0 3
12621: PUSH
12622: DOUBLE
12623: LD_INT 2
12625: DEC
12626: ST_TO_ADDR
12627: LD_VAR 0 2
12631: PUSH
12632: FOR_TO
12633: IFFALSE 12725
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
12635: LD_ADDR_VAR 0 4
12639: PUSH
12640: LD_VAR 0 2
12644: PUSH
12645: LD_VAR 0 3
12649: ARRAY
12650: PPUSH
12651: LD_INT 3
12653: PPUSH
12654: CALL_OW 259
12658: PUSH
12659: LD_VAR 0 2
12663: PUSH
12664: LD_VAR 0 3
12668: ARRAY
12669: PPUSH
12670: CALL_OW 432
12674: MINUS
12675: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
12676: LD_VAR 0 4
12680: PUSH
12681: LD_VAR 0 5
12685: PPUSH
12686: LD_INT 3
12688: PPUSH
12689: CALL_OW 259
12693: PUSH
12694: LD_VAR 0 5
12698: PPUSH
12699: CALL_OW 432
12703: MINUS
12704: GREATEREQUAL
12705: IFFALSE 12723
// mech := result [ i ] ;
12707: LD_ADDR_VAR 0 5
12711: PUSH
12712: LD_VAR 0 2
12716: PUSH
12717: LD_VAR 0 3
12721: ARRAY
12722: ST_TO_ADDR
// end ;
12723: GO 12632
12725: POP
12726: POP
// ComLinkTo ( vehicle , mech ) ;
12727: LD_VAR 0 1
12731: PPUSH
12732: LD_VAR 0 5
12736: PPUSH
12737: CALL_OW 135
// end ;
12741: LD_VAR 0 2
12745: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
12746: LD_INT 0
12748: PPUSH
12749: PPUSH
12750: PPUSH
12751: PPUSH
12752: PPUSH
12753: PPUSH
12754: PPUSH
12755: PPUSH
12756: PPUSH
12757: PPUSH
12758: PPUSH
12759: PPUSH
12760: PPUSH
// result := [ ] ;
12761: LD_ADDR_VAR 0 7
12765: PUSH
12766: EMPTY
12767: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
12768: LD_VAR 0 1
12772: PPUSH
12773: CALL_OW 266
12777: PUSH
12778: LD_INT 0
12780: PUSH
12781: LD_INT 1
12783: PUSH
12784: EMPTY
12785: LIST
12786: LIST
12787: IN
12788: NOT
12789: IFFALSE 12793
// exit ;
12791: GO 14427
// if name then
12793: LD_VAR 0 3
12797: IFFALSE 12813
// SetBName ( base_dep , name ) ;
12799: LD_VAR 0 1
12803: PPUSH
12804: LD_VAR 0 3
12808: PPUSH
12809: CALL_OW 500
// base := GetBase ( base_dep ) ;
12813: LD_ADDR_VAR 0 15
12817: PUSH
12818: LD_VAR 0 1
12822: PPUSH
12823: CALL_OW 274
12827: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
12828: LD_ADDR_VAR 0 16
12832: PUSH
12833: LD_VAR 0 1
12837: PPUSH
12838: CALL_OW 255
12842: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
12843: LD_ADDR_VAR 0 17
12847: PUSH
12848: LD_VAR 0 1
12852: PPUSH
12853: CALL_OW 248
12857: ST_TO_ADDR
// if sources then
12858: LD_VAR 0 5
12862: IFFALSE 12909
// for i = 1 to 3 do
12864: LD_ADDR_VAR 0 8
12868: PUSH
12869: DOUBLE
12870: LD_INT 1
12872: DEC
12873: ST_TO_ADDR
12874: LD_INT 3
12876: PUSH
12877: FOR_TO
12878: IFFALSE 12907
// AddResourceType ( base , i , sources [ i ] ) ;
12880: LD_VAR 0 15
12884: PPUSH
12885: LD_VAR 0 8
12889: PPUSH
12890: LD_VAR 0 5
12894: PUSH
12895: LD_VAR 0 8
12899: ARRAY
12900: PPUSH
12901: CALL_OW 276
12905: GO 12877
12907: POP
12908: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
12909: LD_ADDR_VAR 0 18
12913: PUSH
12914: LD_VAR 0 15
12918: PPUSH
12919: LD_VAR 0 2
12923: PPUSH
12924: LD_INT 1
12926: PPUSH
12927: CALL 12169 0 3
12931: ST_TO_ADDR
// InitHc ;
12932: CALL_OW 19
// InitUc ;
12936: CALL_OW 18
// uc_side := side ;
12940: LD_ADDR_OWVAR 20
12944: PUSH
12945: LD_VAR 0 16
12949: ST_TO_ADDR
// uc_nation := nation ;
12950: LD_ADDR_OWVAR 21
12954: PUSH
12955: LD_VAR 0 17
12959: ST_TO_ADDR
// if buildings then
12960: LD_VAR 0 18
12964: IFFALSE 14286
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
12966: LD_ADDR_VAR 0 19
12970: PUSH
12971: LD_VAR 0 18
12975: PPUSH
12976: LD_INT 2
12978: PUSH
12979: LD_INT 30
12981: PUSH
12982: LD_INT 29
12984: PUSH
12985: EMPTY
12986: LIST
12987: LIST
12988: PUSH
12989: LD_INT 30
12991: PUSH
12992: LD_INT 30
12994: PUSH
12995: EMPTY
12996: LIST
12997: LIST
12998: PUSH
12999: EMPTY
13000: LIST
13001: LIST
13002: LIST
13003: PPUSH
13004: CALL_OW 72
13008: ST_TO_ADDR
// if tmp then
13009: LD_VAR 0 19
13013: IFFALSE 13061
// for i in tmp do
13015: LD_ADDR_VAR 0 8
13019: PUSH
13020: LD_VAR 0 19
13024: PUSH
13025: FOR_IN
13026: IFFALSE 13059
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
13028: LD_VAR 0 8
13032: PPUSH
13033: CALL_OW 250
13037: PPUSH
13038: LD_VAR 0 8
13042: PPUSH
13043: CALL_OW 251
13047: PPUSH
13048: LD_VAR 0 16
13052: PPUSH
13053: CALL_OW 441
13057: GO 13025
13059: POP
13060: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
13061: LD_VAR 0 18
13065: PPUSH
13066: LD_INT 2
13068: PUSH
13069: LD_INT 30
13071: PUSH
13072: LD_INT 32
13074: PUSH
13075: EMPTY
13076: LIST
13077: LIST
13078: PUSH
13079: LD_INT 30
13081: PUSH
13082: LD_INT 33
13084: PUSH
13085: EMPTY
13086: LIST
13087: LIST
13088: PUSH
13089: EMPTY
13090: LIST
13091: LIST
13092: LIST
13093: PPUSH
13094: CALL_OW 72
13098: IFFALSE 13186
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
13100: LD_ADDR_VAR 0 8
13104: PUSH
13105: LD_VAR 0 18
13109: PPUSH
13110: LD_INT 2
13112: PUSH
13113: LD_INT 30
13115: PUSH
13116: LD_INT 32
13118: PUSH
13119: EMPTY
13120: LIST
13121: LIST
13122: PUSH
13123: LD_INT 30
13125: PUSH
13126: LD_INT 33
13128: PUSH
13129: EMPTY
13130: LIST
13131: LIST
13132: PUSH
13133: EMPTY
13134: LIST
13135: LIST
13136: LIST
13137: PPUSH
13138: CALL_OW 72
13142: PUSH
13143: FOR_IN
13144: IFFALSE 13184
// begin if not GetBWeapon ( i ) then
13146: LD_VAR 0 8
13150: PPUSH
13151: CALL_OW 269
13155: NOT
13156: IFFALSE 13182
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
13158: LD_VAR 0 8
13162: PPUSH
13163: LD_VAR 0 8
13167: PPUSH
13168: LD_VAR 0 2
13172: PPUSH
13173: CALL 14432 0 2
13177: PPUSH
13178: CALL_OW 431
// end ;
13182: GO 13143
13184: POP
13185: POP
// end ; for i = 1 to personel do
13186: LD_ADDR_VAR 0 8
13190: PUSH
13191: DOUBLE
13192: LD_INT 1
13194: DEC
13195: ST_TO_ADDR
13196: LD_VAR 0 6
13200: PUSH
13201: FOR_TO
13202: IFFALSE 14266
// begin if i > 4 then
13204: LD_VAR 0 8
13208: PUSH
13209: LD_INT 4
13211: GREATER
13212: IFFALSE 13216
// break ;
13214: GO 14266
// case i of 1 :
13216: LD_VAR 0 8
13220: PUSH
13221: LD_INT 1
13223: DOUBLE
13224: EQUAL
13225: IFTRUE 13229
13227: GO 13309
13229: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
13230: LD_ADDR_VAR 0 12
13234: PUSH
13235: LD_VAR 0 18
13239: PPUSH
13240: LD_INT 22
13242: PUSH
13243: LD_VAR 0 16
13247: PUSH
13248: EMPTY
13249: LIST
13250: LIST
13251: PUSH
13252: LD_INT 58
13254: PUSH
13255: EMPTY
13256: LIST
13257: PUSH
13258: LD_INT 2
13260: PUSH
13261: LD_INT 30
13263: PUSH
13264: LD_INT 32
13266: PUSH
13267: EMPTY
13268: LIST
13269: LIST
13270: PUSH
13271: LD_INT 30
13273: PUSH
13274: LD_INT 4
13276: PUSH
13277: EMPTY
13278: LIST
13279: LIST
13280: PUSH
13281: LD_INT 30
13283: PUSH
13284: LD_INT 5
13286: PUSH
13287: EMPTY
13288: LIST
13289: LIST
13290: PUSH
13291: EMPTY
13292: LIST
13293: LIST
13294: LIST
13295: LIST
13296: PUSH
13297: EMPTY
13298: LIST
13299: LIST
13300: LIST
13301: PPUSH
13302: CALL_OW 72
13306: ST_TO_ADDR
13307: GO 13531
13309: LD_INT 2
13311: DOUBLE
13312: EQUAL
13313: IFTRUE 13317
13315: GO 13379
13317: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
13318: LD_ADDR_VAR 0 12
13322: PUSH
13323: LD_VAR 0 18
13327: PPUSH
13328: LD_INT 22
13330: PUSH
13331: LD_VAR 0 16
13335: PUSH
13336: EMPTY
13337: LIST
13338: LIST
13339: PUSH
13340: LD_INT 2
13342: PUSH
13343: LD_INT 30
13345: PUSH
13346: LD_INT 0
13348: PUSH
13349: EMPTY
13350: LIST
13351: LIST
13352: PUSH
13353: LD_INT 30
13355: PUSH
13356: LD_INT 1
13358: PUSH
13359: EMPTY
13360: LIST
13361: LIST
13362: PUSH
13363: EMPTY
13364: LIST
13365: LIST
13366: LIST
13367: PUSH
13368: EMPTY
13369: LIST
13370: LIST
13371: PPUSH
13372: CALL_OW 72
13376: ST_TO_ADDR
13377: GO 13531
13379: LD_INT 3
13381: DOUBLE
13382: EQUAL
13383: IFTRUE 13387
13385: GO 13449
13387: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
13388: LD_ADDR_VAR 0 12
13392: PUSH
13393: LD_VAR 0 18
13397: PPUSH
13398: LD_INT 22
13400: PUSH
13401: LD_VAR 0 16
13405: PUSH
13406: EMPTY
13407: LIST
13408: LIST
13409: PUSH
13410: LD_INT 2
13412: PUSH
13413: LD_INT 30
13415: PUSH
13416: LD_INT 2
13418: PUSH
13419: EMPTY
13420: LIST
13421: LIST
13422: PUSH
13423: LD_INT 30
13425: PUSH
13426: LD_INT 3
13428: PUSH
13429: EMPTY
13430: LIST
13431: LIST
13432: PUSH
13433: EMPTY
13434: LIST
13435: LIST
13436: LIST
13437: PUSH
13438: EMPTY
13439: LIST
13440: LIST
13441: PPUSH
13442: CALL_OW 72
13446: ST_TO_ADDR
13447: GO 13531
13449: LD_INT 4
13451: DOUBLE
13452: EQUAL
13453: IFTRUE 13457
13455: GO 13530
13457: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
13458: LD_ADDR_VAR 0 12
13462: PUSH
13463: LD_VAR 0 18
13467: PPUSH
13468: LD_INT 22
13470: PUSH
13471: LD_VAR 0 16
13475: PUSH
13476: EMPTY
13477: LIST
13478: LIST
13479: PUSH
13480: LD_INT 2
13482: PUSH
13483: LD_INT 30
13485: PUSH
13486: LD_INT 6
13488: PUSH
13489: EMPTY
13490: LIST
13491: LIST
13492: PUSH
13493: LD_INT 30
13495: PUSH
13496: LD_INT 7
13498: PUSH
13499: EMPTY
13500: LIST
13501: LIST
13502: PUSH
13503: LD_INT 30
13505: PUSH
13506: LD_INT 8
13508: PUSH
13509: EMPTY
13510: LIST
13511: LIST
13512: PUSH
13513: EMPTY
13514: LIST
13515: LIST
13516: LIST
13517: LIST
13518: PUSH
13519: EMPTY
13520: LIST
13521: LIST
13522: PPUSH
13523: CALL_OW 72
13527: ST_TO_ADDR
13528: GO 13531
13530: POP
// if i = 1 then
13531: LD_VAR 0 8
13535: PUSH
13536: LD_INT 1
13538: EQUAL
13539: IFFALSE 13650
// begin tmp := [ ] ;
13541: LD_ADDR_VAR 0 19
13545: PUSH
13546: EMPTY
13547: ST_TO_ADDR
// for j in f do
13548: LD_ADDR_VAR 0 9
13552: PUSH
13553: LD_VAR 0 12
13557: PUSH
13558: FOR_IN
13559: IFFALSE 13632
// if GetBType ( j ) = b_bunker then
13561: LD_VAR 0 9
13565: PPUSH
13566: CALL_OW 266
13570: PUSH
13571: LD_INT 32
13573: EQUAL
13574: IFFALSE 13601
// tmp := Insert ( tmp , 1 , j ) else
13576: LD_ADDR_VAR 0 19
13580: PUSH
13581: LD_VAR 0 19
13585: PPUSH
13586: LD_INT 1
13588: PPUSH
13589: LD_VAR 0 9
13593: PPUSH
13594: CALL_OW 2
13598: ST_TO_ADDR
13599: GO 13630
// tmp := Insert ( tmp , tmp + 1 , j ) ;
13601: LD_ADDR_VAR 0 19
13605: PUSH
13606: LD_VAR 0 19
13610: PPUSH
13611: LD_VAR 0 19
13615: PUSH
13616: LD_INT 1
13618: PLUS
13619: PPUSH
13620: LD_VAR 0 9
13624: PPUSH
13625: CALL_OW 2
13629: ST_TO_ADDR
13630: GO 13558
13632: POP
13633: POP
// if tmp then
13634: LD_VAR 0 19
13638: IFFALSE 13650
// f := tmp ;
13640: LD_ADDR_VAR 0 12
13644: PUSH
13645: LD_VAR 0 19
13649: ST_TO_ADDR
// end ; x := personel [ i ] ;
13650: LD_ADDR_VAR 0 13
13654: PUSH
13655: LD_VAR 0 6
13659: PUSH
13660: LD_VAR 0 8
13664: ARRAY
13665: ST_TO_ADDR
// if x = - 1 then
13666: LD_VAR 0 13
13670: PUSH
13671: LD_INT 1
13673: NEG
13674: EQUAL
13675: IFFALSE 13884
// begin for j in f do
13677: LD_ADDR_VAR 0 9
13681: PUSH
13682: LD_VAR 0 12
13686: PUSH
13687: FOR_IN
13688: IFFALSE 13880
// repeat InitHc ;
13690: CALL_OW 19
// if GetBType ( j ) = b_barracks then
13694: LD_VAR 0 9
13698: PPUSH
13699: CALL_OW 266
13703: PUSH
13704: LD_INT 5
13706: EQUAL
13707: IFFALSE 13777
// begin if UnitsInside ( j ) < 3 then
13709: LD_VAR 0 9
13713: PPUSH
13714: CALL_OW 313
13718: PUSH
13719: LD_INT 3
13721: LESS
13722: IFFALSE 13758
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
13724: LD_INT 0
13726: PPUSH
13727: LD_INT 5
13729: PUSH
13730: LD_INT 8
13732: PUSH
13733: LD_INT 9
13735: PUSH
13736: EMPTY
13737: LIST
13738: LIST
13739: LIST
13740: PUSH
13741: LD_VAR 0 17
13745: ARRAY
13746: PPUSH
13747: LD_VAR 0 4
13751: PPUSH
13752: CALL_OW 380
13756: GO 13775
// PrepareHuman ( false , i , skill ) ;
13758: LD_INT 0
13760: PPUSH
13761: LD_VAR 0 8
13765: PPUSH
13766: LD_VAR 0 4
13770: PPUSH
13771: CALL_OW 380
// end else
13775: GO 13794
// PrepareHuman ( false , i , skill ) ;
13777: LD_INT 0
13779: PPUSH
13780: LD_VAR 0 8
13784: PPUSH
13785: LD_VAR 0 4
13789: PPUSH
13790: CALL_OW 380
// un := CreateHuman ;
13794: LD_ADDR_VAR 0 14
13798: PUSH
13799: CALL_OW 44
13803: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
13804: LD_ADDR_VAR 0 7
13808: PUSH
13809: LD_VAR 0 7
13813: PPUSH
13814: LD_INT 1
13816: PPUSH
13817: LD_VAR 0 14
13821: PPUSH
13822: CALL_OW 2
13826: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
13827: LD_VAR 0 14
13831: PPUSH
13832: LD_VAR 0 9
13836: PPUSH
13837: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
13841: LD_VAR 0 9
13845: PPUSH
13846: CALL_OW 313
13850: PUSH
13851: LD_INT 6
13853: EQUAL
13854: PUSH
13855: LD_VAR 0 9
13859: PPUSH
13860: CALL_OW 266
13864: PUSH
13865: LD_INT 32
13867: PUSH
13868: LD_INT 31
13870: PUSH
13871: EMPTY
13872: LIST
13873: LIST
13874: IN
13875: OR
13876: IFFALSE 13690
13878: GO 13687
13880: POP
13881: POP
// end else
13882: GO 14264
// for j = 1 to x do
13884: LD_ADDR_VAR 0 9
13888: PUSH
13889: DOUBLE
13890: LD_INT 1
13892: DEC
13893: ST_TO_ADDR
13894: LD_VAR 0 13
13898: PUSH
13899: FOR_TO
13900: IFFALSE 14262
// begin InitHc ;
13902: CALL_OW 19
// if not f then
13906: LD_VAR 0 12
13910: NOT
13911: IFFALSE 14000
// begin PrepareHuman ( false , i , skill ) ;
13913: LD_INT 0
13915: PPUSH
13916: LD_VAR 0 8
13920: PPUSH
13921: LD_VAR 0 4
13925: PPUSH
13926: CALL_OW 380
// un := CreateHuman ;
13930: LD_ADDR_VAR 0 14
13934: PUSH
13935: CALL_OW 44
13939: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
13940: LD_ADDR_VAR 0 7
13944: PUSH
13945: LD_VAR 0 7
13949: PPUSH
13950: LD_INT 1
13952: PPUSH
13953: LD_VAR 0 14
13957: PPUSH
13958: CALL_OW 2
13962: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
13963: LD_VAR 0 14
13967: PPUSH
13968: LD_VAR 0 1
13972: PPUSH
13973: CALL_OW 250
13977: PPUSH
13978: LD_VAR 0 1
13982: PPUSH
13983: CALL_OW 251
13987: PPUSH
13988: LD_INT 10
13990: PPUSH
13991: LD_INT 0
13993: PPUSH
13994: CALL_OW 50
// continue ;
13998: GO 13899
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
14000: LD_VAR 0 12
14004: PUSH
14005: LD_INT 1
14007: ARRAY
14008: PPUSH
14009: CALL_OW 313
14013: PUSH
14014: LD_VAR 0 12
14018: PUSH
14019: LD_INT 1
14021: ARRAY
14022: PPUSH
14023: CALL_OW 266
14027: PUSH
14028: LD_INT 32
14030: PUSH
14031: LD_INT 31
14033: PUSH
14034: EMPTY
14035: LIST
14036: LIST
14037: IN
14038: AND
14039: PUSH
14040: LD_VAR 0 12
14044: PUSH
14045: LD_INT 1
14047: ARRAY
14048: PPUSH
14049: CALL_OW 313
14053: PUSH
14054: LD_INT 6
14056: EQUAL
14057: OR
14058: IFFALSE 14078
// f := Delete ( f , 1 ) ;
14060: LD_ADDR_VAR 0 12
14064: PUSH
14065: LD_VAR 0 12
14069: PPUSH
14070: LD_INT 1
14072: PPUSH
14073: CALL_OW 3
14077: ST_TO_ADDR
// if not f then
14078: LD_VAR 0 12
14082: NOT
14083: IFFALSE 14101
// begin x := x + 2 ;
14085: LD_ADDR_VAR 0 13
14089: PUSH
14090: LD_VAR 0 13
14094: PUSH
14095: LD_INT 2
14097: PLUS
14098: ST_TO_ADDR
// continue ;
14099: GO 13899
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
14101: LD_VAR 0 12
14105: PUSH
14106: LD_INT 1
14108: ARRAY
14109: PPUSH
14110: CALL_OW 266
14114: PUSH
14115: LD_INT 5
14117: EQUAL
14118: IFFALSE 14192
// begin if UnitsInside ( f [ 1 ] ) < 3 then
14120: LD_VAR 0 12
14124: PUSH
14125: LD_INT 1
14127: ARRAY
14128: PPUSH
14129: CALL_OW 313
14133: PUSH
14134: LD_INT 3
14136: LESS
14137: IFFALSE 14173
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
14139: LD_INT 0
14141: PPUSH
14142: LD_INT 5
14144: PUSH
14145: LD_INT 8
14147: PUSH
14148: LD_INT 9
14150: PUSH
14151: EMPTY
14152: LIST
14153: LIST
14154: LIST
14155: PUSH
14156: LD_VAR 0 17
14160: ARRAY
14161: PPUSH
14162: LD_VAR 0 4
14166: PPUSH
14167: CALL_OW 380
14171: GO 14190
// PrepareHuman ( false , i , skill ) ;
14173: LD_INT 0
14175: PPUSH
14176: LD_VAR 0 8
14180: PPUSH
14181: LD_VAR 0 4
14185: PPUSH
14186: CALL_OW 380
// end else
14190: GO 14209
// PrepareHuman ( false , i , skill ) ;
14192: LD_INT 0
14194: PPUSH
14195: LD_VAR 0 8
14199: PPUSH
14200: LD_VAR 0 4
14204: PPUSH
14205: CALL_OW 380
// un := CreateHuman ;
14209: LD_ADDR_VAR 0 14
14213: PUSH
14214: CALL_OW 44
14218: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
14219: LD_ADDR_VAR 0 7
14223: PUSH
14224: LD_VAR 0 7
14228: PPUSH
14229: LD_INT 1
14231: PPUSH
14232: LD_VAR 0 14
14236: PPUSH
14237: CALL_OW 2
14241: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
14242: LD_VAR 0 14
14246: PPUSH
14247: LD_VAR 0 12
14251: PUSH
14252: LD_INT 1
14254: ARRAY
14255: PPUSH
14256: CALL_OW 52
// end ;
14260: GO 13899
14262: POP
14263: POP
// end ;
14264: GO 13201
14266: POP
14267: POP
// result := result ^ buildings ;
14268: LD_ADDR_VAR 0 7
14272: PUSH
14273: LD_VAR 0 7
14277: PUSH
14278: LD_VAR 0 18
14282: ADD
14283: ST_TO_ADDR
// end else
14284: GO 14427
// begin for i = 1 to personel do
14286: LD_ADDR_VAR 0 8
14290: PUSH
14291: DOUBLE
14292: LD_INT 1
14294: DEC
14295: ST_TO_ADDR
14296: LD_VAR 0 6
14300: PUSH
14301: FOR_TO
14302: IFFALSE 14425
// begin if i > 4 then
14304: LD_VAR 0 8
14308: PUSH
14309: LD_INT 4
14311: GREATER
14312: IFFALSE 14316
// break ;
14314: GO 14425
// x := personel [ i ] ;
14316: LD_ADDR_VAR 0 13
14320: PUSH
14321: LD_VAR 0 6
14325: PUSH
14326: LD_VAR 0 8
14330: ARRAY
14331: ST_TO_ADDR
// if x = - 1 then
14332: LD_VAR 0 13
14336: PUSH
14337: LD_INT 1
14339: NEG
14340: EQUAL
14341: IFFALSE 14345
// continue ;
14343: GO 14301
// PrepareHuman ( false , i , skill ) ;
14345: LD_INT 0
14347: PPUSH
14348: LD_VAR 0 8
14352: PPUSH
14353: LD_VAR 0 4
14357: PPUSH
14358: CALL_OW 380
// un := CreateHuman ;
14362: LD_ADDR_VAR 0 14
14366: PUSH
14367: CALL_OW 44
14371: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
14372: LD_VAR 0 14
14376: PPUSH
14377: LD_VAR 0 1
14381: PPUSH
14382: CALL_OW 250
14386: PPUSH
14387: LD_VAR 0 1
14391: PPUSH
14392: CALL_OW 251
14396: PPUSH
14397: LD_INT 10
14399: PPUSH
14400: LD_INT 0
14402: PPUSH
14403: CALL_OW 50
// result := result ^ un ;
14407: LD_ADDR_VAR 0 7
14411: PUSH
14412: LD_VAR 0 7
14416: PUSH
14417: LD_VAR 0 14
14421: ADD
14422: ST_TO_ADDR
// end ;
14423: GO 14301
14425: POP
14426: POP
// end ; end ;
14427: LD_VAR 0 7
14431: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
14432: LD_INT 0
14434: PPUSH
14435: PPUSH
14436: PPUSH
14437: PPUSH
14438: PPUSH
14439: PPUSH
14440: PPUSH
14441: PPUSH
14442: PPUSH
14443: PPUSH
14444: PPUSH
14445: PPUSH
14446: PPUSH
14447: PPUSH
14448: PPUSH
14449: PPUSH
// result := false ;
14450: LD_ADDR_VAR 0 3
14454: PUSH
14455: LD_INT 0
14457: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
14458: LD_VAR 0 1
14462: NOT
14463: PUSH
14464: LD_VAR 0 1
14468: PPUSH
14469: CALL_OW 266
14473: PUSH
14474: LD_INT 32
14476: PUSH
14477: LD_INT 33
14479: PUSH
14480: EMPTY
14481: LIST
14482: LIST
14483: IN
14484: NOT
14485: OR
14486: IFFALSE 14490
// exit ;
14488: GO 15629
// nat := GetNation ( tower ) ;
14490: LD_ADDR_VAR 0 12
14494: PUSH
14495: LD_VAR 0 1
14499: PPUSH
14500: CALL_OW 248
14504: ST_TO_ADDR
// side := GetSide ( tower ) ;
14505: LD_ADDR_VAR 0 16
14509: PUSH
14510: LD_VAR 0 1
14514: PPUSH
14515: CALL_OW 255
14519: ST_TO_ADDR
// x := GetX ( tower ) ;
14520: LD_ADDR_VAR 0 10
14524: PUSH
14525: LD_VAR 0 1
14529: PPUSH
14530: CALL_OW 250
14534: ST_TO_ADDR
// y := GetY ( tower ) ;
14535: LD_ADDR_VAR 0 11
14539: PUSH
14540: LD_VAR 0 1
14544: PPUSH
14545: CALL_OW 251
14549: ST_TO_ADDR
// if not x or not y then
14550: LD_VAR 0 10
14554: NOT
14555: PUSH
14556: LD_VAR 0 11
14560: NOT
14561: OR
14562: IFFALSE 14566
// exit ;
14564: GO 15629
// weapon := 0 ;
14566: LD_ADDR_VAR 0 18
14570: PUSH
14571: LD_INT 0
14573: ST_TO_ADDR
// fac_list := [ ] ;
14574: LD_ADDR_VAR 0 17
14578: PUSH
14579: EMPTY
14580: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
14581: LD_ADDR_VAR 0 6
14585: PUSH
14586: LD_VAR 0 1
14590: PPUSH
14591: CALL_OW 274
14595: PPUSH
14596: LD_VAR 0 2
14600: PPUSH
14601: LD_INT 0
14603: PPUSH
14604: CALL 12169 0 3
14608: PPUSH
14609: LD_INT 30
14611: PUSH
14612: LD_INT 3
14614: PUSH
14615: EMPTY
14616: LIST
14617: LIST
14618: PPUSH
14619: CALL_OW 72
14623: ST_TO_ADDR
// if not factories then
14624: LD_VAR 0 6
14628: NOT
14629: IFFALSE 14633
// exit ;
14631: GO 15629
// for i in factories do
14633: LD_ADDR_VAR 0 8
14637: PUSH
14638: LD_VAR 0 6
14642: PUSH
14643: FOR_IN
14644: IFFALSE 14669
// fac_list := fac_list union AvailableWeaponList ( i ) ;
14646: LD_ADDR_VAR 0 17
14650: PUSH
14651: LD_VAR 0 17
14655: PUSH
14656: LD_VAR 0 8
14660: PPUSH
14661: CALL_OW 478
14665: UNION
14666: ST_TO_ADDR
14667: GO 14643
14669: POP
14670: POP
// if not fac_list then
14671: LD_VAR 0 17
14675: NOT
14676: IFFALSE 14680
// exit ;
14678: GO 15629
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
14680: LD_ADDR_VAR 0 5
14684: PUSH
14685: LD_INT 4
14687: PUSH
14688: LD_INT 5
14690: PUSH
14691: LD_INT 9
14693: PUSH
14694: LD_INT 10
14696: PUSH
14697: LD_INT 6
14699: PUSH
14700: LD_INT 7
14702: PUSH
14703: LD_INT 11
14705: PUSH
14706: EMPTY
14707: LIST
14708: LIST
14709: LIST
14710: LIST
14711: LIST
14712: LIST
14713: LIST
14714: PUSH
14715: LD_INT 27
14717: PUSH
14718: LD_INT 28
14720: PUSH
14721: LD_INT 26
14723: PUSH
14724: LD_INT 30
14726: PUSH
14727: EMPTY
14728: LIST
14729: LIST
14730: LIST
14731: LIST
14732: PUSH
14733: LD_INT 43
14735: PUSH
14736: LD_INT 44
14738: PUSH
14739: LD_INT 46
14741: PUSH
14742: LD_INT 45
14744: PUSH
14745: LD_INT 47
14747: PUSH
14748: LD_INT 49
14750: PUSH
14751: EMPTY
14752: LIST
14753: LIST
14754: LIST
14755: LIST
14756: LIST
14757: LIST
14758: PUSH
14759: EMPTY
14760: LIST
14761: LIST
14762: LIST
14763: PUSH
14764: LD_VAR 0 12
14768: ARRAY
14769: ST_TO_ADDR
// for i in list do
14770: LD_ADDR_VAR 0 8
14774: PUSH
14775: LD_VAR 0 5
14779: PUSH
14780: FOR_IN
14781: IFFALSE 14814
// if not i in fac_list then
14783: LD_VAR 0 8
14787: PUSH
14788: LD_VAR 0 17
14792: IN
14793: NOT
14794: IFFALSE 14812
// list := list diff i ;
14796: LD_ADDR_VAR 0 5
14800: PUSH
14801: LD_VAR 0 5
14805: PUSH
14806: LD_VAR 0 8
14810: DIFF
14811: ST_TO_ADDR
14812: GO 14780
14814: POP
14815: POP
// if not list then
14816: LD_VAR 0 5
14820: NOT
14821: IFFALSE 14825
// exit ;
14823: GO 15629
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
14825: LD_VAR 0 12
14829: PUSH
14830: LD_INT 3
14832: EQUAL
14833: PUSH
14834: LD_INT 49
14836: PUSH
14837: LD_VAR 0 5
14841: IN
14842: AND
14843: PUSH
14844: LD_INT 31
14846: PPUSH
14847: LD_VAR 0 16
14851: PPUSH
14852: CALL_OW 321
14856: PUSH
14857: LD_INT 2
14859: EQUAL
14860: AND
14861: IFFALSE 14921
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
14863: LD_INT 22
14865: PUSH
14866: LD_VAR 0 16
14870: PUSH
14871: EMPTY
14872: LIST
14873: LIST
14874: PUSH
14875: LD_INT 35
14877: PUSH
14878: LD_INT 49
14880: PUSH
14881: EMPTY
14882: LIST
14883: LIST
14884: PUSH
14885: LD_INT 91
14887: PUSH
14888: LD_VAR 0 1
14892: PUSH
14893: LD_INT 10
14895: PUSH
14896: EMPTY
14897: LIST
14898: LIST
14899: LIST
14900: PUSH
14901: EMPTY
14902: LIST
14903: LIST
14904: LIST
14905: PPUSH
14906: CALL_OW 69
14910: NOT
14911: IFFALSE 14921
// weapon := ru_time_lapser ;
14913: LD_ADDR_VAR 0 18
14917: PUSH
14918: LD_INT 49
14920: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
14921: LD_VAR 0 12
14925: PUSH
14926: LD_INT 1
14928: PUSH
14929: LD_INT 2
14931: PUSH
14932: EMPTY
14933: LIST
14934: LIST
14935: IN
14936: PUSH
14937: LD_INT 11
14939: PUSH
14940: LD_VAR 0 5
14944: IN
14945: PUSH
14946: LD_INT 30
14948: PUSH
14949: LD_VAR 0 5
14953: IN
14954: OR
14955: AND
14956: PUSH
14957: LD_INT 6
14959: PPUSH
14960: LD_VAR 0 16
14964: PPUSH
14965: CALL_OW 321
14969: PUSH
14970: LD_INT 2
14972: EQUAL
14973: AND
14974: IFFALSE 15139
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
14976: LD_INT 22
14978: PUSH
14979: LD_VAR 0 16
14983: PUSH
14984: EMPTY
14985: LIST
14986: LIST
14987: PUSH
14988: LD_INT 2
14990: PUSH
14991: LD_INT 35
14993: PUSH
14994: LD_INT 11
14996: PUSH
14997: EMPTY
14998: LIST
14999: LIST
15000: PUSH
15001: LD_INT 35
15003: PUSH
15004: LD_INT 30
15006: PUSH
15007: EMPTY
15008: LIST
15009: LIST
15010: PUSH
15011: EMPTY
15012: LIST
15013: LIST
15014: LIST
15015: PUSH
15016: LD_INT 91
15018: PUSH
15019: LD_VAR 0 1
15023: PUSH
15024: LD_INT 18
15026: PUSH
15027: EMPTY
15028: LIST
15029: LIST
15030: LIST
15031: PUSH
15032: EMPTY
15033: LIST
15034: LIST
15035: LIST
15036: PPUSH
15037: CALL_OW 69
15041: NOT
15042: PUSH
15043: LD_INT 22
15045: PUSH
15046: LD_VAR 0 16
15050: PUSH
15051: EMPTY
15052: LIST
15053: LIST
15054: PUSH
15055: LD_INT 2
15057: PUSH
15058: LD_INT 30
15060: PUSH
15061: LD_INT 32
15063: PUSH
15064: EMPTY
15065: LIST
15066: LIST
15067: PUSH
15068: LD_INT 30
15070: PUSH
15071: LD_INT 33
15073: PUSH
15074: EMPTY
15075: LIST
15076: LIST
15077: PUSH
15078: EMPTY
15079: LIST
15080: LIST
15081: LIST
15082: PUSH
15083: LD_INT 91
15085: PUSH
15086: LD_VAR 0 1
15090: PUSH
15091: LD_INT 12
15093: PUSH
15094: EMPTY
15095: LIST
15096: LIST
15097: LIST
15098: PUSH
15099: EMPTY
15100: LIST
15101: LIST
15102: LIST
15103: PUSH
15104: EMPTY
15105: LIST
15106: PPUSH
15107: CALL_OW 69
15111: PUSH
15112: LD_INT 2
15114: GREATER
15115: AND
15116: IFFALSE 15139
// weapon := [ us_radar , ar_radar ] [ nat ] ;
15118: LD_ADDR_VAR 0 18
15122: PUSH
15123: LD_INT 11
15125: PUSH
15126: LD_INT 30
15128: PUSH
15129: EMPTY
15130: LIST
15131: LIST
15132: PUSH
15133: LD_VAR 0 12
15137: ARRAY
15138: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
15139: LD_VAR 0 18
15143: NOT
15144: PUSH
15145: LD_INT 40
15147: PPUSH
15148: LD_VAR 0 16
15152: PPUSH
15153: CALL_OW 321
15157: PUSH
15158: LD_INT 2
15160: EQUAL
15161: AND
15162: PUSH
15163: LD_INT 7
15165: PUSH
15166: LD_VAR 0 5
15170: IN
15171: PUSH
15172: LD_INT 28
15174: PUSH
15175: LD_VAR 0 5
15179: IN
15180: OR
15181: PUSH
15182: LD_INT 45
15184: PUSH
15185: LD_VAR 0 5
15189: IN
15190: OR
15191: AND
15192: IFFALSE 15446
// begin hex := GetHexInfo ( x , y ) ;
15194: LD_ADDR_VAR 0 4
15198: PUSH
15199: LD_VAR 0 10
15203: PPUSH
15204: LD_VAR 0 11
15208: PPUSH
15209: CALL_OW 546
15213: ST_TO_ADDR
// if hex [ 1 ] then
15214: LD_VAR 0 4
15218: PUSH
15219: LD_INT 1
15221: ARRAY
15222: IFFALSE 15226
// exit ;
15224: GO 15629
// height := hex [ 2 ] ;
15226: LD_ADDR_VAR 0 15
15230: PUSH
15231: LD_VAR 0 4
15235: PUSH
15236: LD_INT 2
15238: ARRAY
15239: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
15240: LD_ADDR_VAR 0 14
15244: PUSH
15245: LD_INT 0
15247: PUSH
15248: LD_INT 2
15250: PUSH
15251: LD_INT 3
15253: PUSH
15254: LD_INT 5
15256: PUSH
15257: EMPTY
15258: LIST
15259: LIST
15260: LIST
15261: LIST
15262: ST_TO_ADDR
// for i in tmp do
15263: LD_ADDR_VAR 0 8
15267: PUSH
15268: LD_VAR 0 14
15272: PUSH
15273: FOR_IN
15274: IFFALSE 15444
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
15276: LD_ADDR_VAR 0 9
15280: PUSH
15281: LD_VAR 0 10
15285: PPUSH
15286: LD_VAR 0 8
15290: PPUSH
15291: LD_INT 5
15293: PPUSH
15294: CALL_OW 272
15298: PUSH
15299: LD_VAR 0 11
15303: PPUSH
15304: LD_VAR 0 8
15308: PPUSH
15309: LD_INT 5
15311: PPUSH
15312: CALL_OW 273
15316: PUSH
15317: EMPTY
15318: LIST
15319: LIST
15320: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
15321: LD_VAR 0 9
15325: PUSH
15326: LD_INT 1
15328: ARRAY
15329: PPUSH
15330: LD_VAR 0 9
15334: PUSH
15335: LD_INT 2
15337: ARRAY
15338: PPUSH
15339: CALL_OW 488
15343: IFFALSE 15442
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
15345: LD_ADDR_VAR 0 4
15349: PUSH
15350: LD_VAR 0 9
15354: PUSH
15355: LD_INT 1
15357: ARRAY
15358: PPUSH
15359: LD_VAR 0 9
15363: PUSH
15364: LD_INT 2
15366: ARRAY
15367: PPUSH
15368: CALL_OW 546
15372: ST_TO_ADDR
// if hex [ 1 ] then
15373: LD_VAR 0 4
15377: PUSH
15378: LD_INT 1
15380: ARRAY
15381: IFFALSE 15385
// continue ;
15383: GO 15273
// h := hex [ 2 ] ;
15385: LD_ADDR_VAR 0 13
15389: PUSH
15390: LD_VAR 0 4
15394: PUSH
15395: LD_INT 2
15397: ARRAY
15398: ST_TO_ADDR
// if h + 7 < height then
15399: LD_VAR 0 13
15403: PUSH
15404: LD_INT 7
15406: PLUS
15407: PUSH
15408: LD_VAR 0 15
15412: LESS
15413: IFFALSE 15442
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
15415: LD_ADDR_VAR 0 18
15419: PUSH
15420: LD_INT 7
15422: PUSH
15423: LD_INT 28
15425: PUSH
15426: LD_INT 45
15428: PUSH
15429: EMPTY
15430: LIST
15431: LIST
15432: LIST
15433: PUSH
15434: LD_VAR 0 12
15438: ARRAY
15439: ST_TO_ADDR
// break ;
15440: GO 15444
// end ; end ; end ;
15442: GO 15273
15444: POP
15445: POP
// end ; if not weapon then
15446: LD_VAR 0 18
15450: NOT
15451: IFFALSE 15511
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
15453: LD_ADDR_VAR 0 5
15457: PUSH
15458: LD_VAR 0 5
15462: PUSH
15463: LD_INT 11
15465: PUSH
15466: LD_INT 30
15468: PUSH
15469: LD_INT 49
15471: PUSH
15472: EMPTY
15473: LIST
15474: LIST
15475: LIST
15476: DIFF
15477: ST_TO_ADDR
// if not list then
15478: LD_VAR 0 5
15482: NOT
15483: IFFALSE 15487
// exit ;
15485: GO 15629
// weapon := list [ rand ( 1 , list ) ] ;
15487: LD_ADDR_VAR 0 18
15491: PUSH
15492: LD_VAR 0 5
15496: PUSH
15497: LD_INT 1
15499: PPUSH
15500: LD_VAR 0 5
15504: PPUSH
15505: CALL_OW 12
15509: ARRAY
15510: ST_TO_ADDR
// end ; if weapon then
15511: LD_VAR 0 18
15515: IFFALSE 15629
// begin tmp := CostOfWeapon ( weapon ) ;
15517: LD_ADDR_VAR 0 14
15521: PUSH
15522: LD_VAR 0 18
15526: PPUSH
15527: CALL_OW 451
15531: ST_TO_ADDR
// j := GetBase ( tower ) ;
15532: LD_ADDR_VAR 0 9
15536: PUSH
15537: LD_VAR 0 1
15541: PPUSH
15542: CALL_OW 274
15546: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
15547: LD_VAR 0 9
15551: PPUSH
15552: LD_INT 1
15554: PPUSH
15555: CALL_OW 275
15559: PUSH
15560: LD_VAR 0 14
15564: PUSH
15565: LD_INT 1
15567: ARRAY
15568: GREATEREQUAL
15569: PUSH
15570: LD_VAR 0 9
15574: PPUSH
15575: LD_INT 2
15577: PPUSH
15578: CALL_OW 275
15582: PUSH
15583: LD_VAR 0 14
15587: PUSH
15588: LD_INT 2
15590: ARRAY
15591: GREATEREQUAL
15592: AND
15593: PUSH
15594: LD_VAR 0 9
15598: PPUSH
15599: LD_INT 3
15601: PPUSH
15602: CALL_OW 275
15606: PUSH
15607: LD_VAR 0 14
15611: PUSH
15612: LD_INT 3
15614: ARRAY
15615: GREATEREQUAL
15616: AND
15617: IFFALSE 15629
// result := weapon ;
15619: LD_ADDR_VAR 0 3
15623: PUSH
15624: LD_VAR 0 18
15628: ST_TO_ADDR
// end ; end ;
15629: LD_VAR 0 3
15633: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
15634: LD_INT 0
15636: PPUSH
15637: PPUSH
// result := true ;
15638: LD_ADDR_VAR 0 3
15642: PUSH
15643: LD_INT 1
15645: ST_TO_ADDR
// if array1 = array2 then
15646: LD_VAR 0 1
15650: PUSH
15651: LD_VAR 0 2
15655: EQUAL
15656: IFFALSE 15716
// begin for i = 1 to array1 do
15658: LD_ADDR_VAR 0 4
15662: PUSH
15663: DOUBLE
15664: LD_INT 1
15666: DEC
15667: ST_TO_ADDR
15668: LD_VAR 0 1
15672: PUSH
15673: FOR_TO
15674: IFFALSE 15712
// if array1 [ i ] <> array2 [ i ] then
15676: LD_VAR 0 1
15680: PUSH
15681: LD_VAR 0 4
15685: ARRAY
15686: PUSH
15687: LD_VAR 0 2
15691: PUSH
15692: LD_VAR 0 4
15696: ARRAY
15697: NONEQUAL
15698: IFFALSE 15710
// begin result := false ;
15700: LD_ADDR_VAR 0 3
15704: PUSH
15705: LD_INT 0
15707: ST_TO_ADDR
// break ;
15708: GO 15712
// end ;
15710: GO 15673
15712: POP
15713: POP
// end else
15714: GO 15724
// result := false ;
15716: LD_ADDR_VAR 0 3
15720: PUSH
15721: LD_INT 0
15723: ST_TO_ADDR
// end ;
15724: LD_VAR 0 3
15728: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
15729: LD_INT 0
15731: PPUSH
15732: PPUSH
// if not array1 or not array2 then
15733: LD_VAR 0 1
15737: NOT
15738: PUSH
15739: LD_VAR 0 2
15743: NOT
15744: OR
15745: IFFALSE 15749
// exit ;
15747: GO 15813
// result := true ;
15749: LD_ADDR_VAR 0 3
15753: PUSH
15754: LD_INT 1
15756: ST_TO_ADDR
// for i = 1 to array1 do
15757: LD_ADDR_VAR 0 4
15761: PUSH
15762: DOUBLE
15763: LD_INT 1
15765: DEC
15766: ST_TO_ADDR
15767: LD_VAR 0 1
15771: PUSH
15772: FOR_TO
15773: IFFALSE 15811
// if array1 [ i ] <> array2 [ i ] then
15775: LD_VAR 0 1
15779: PUSH
15780: LD_VAR 0 4
15784: ARRAY
15785: PUSH
15786: LD_VAR 0 2
15790: PUSH
15791: LD_VAR 0 4
15795: ARRAY
15796: NONEQUAL
15797: IFFALSE 15809
// begin result := false ;
15799: LD_ADDR_VAR 0 3
15803: PUSH
15804: LD_INT 0
15806: ST_TO_ADDR
// break ;
15807: GO 15811
// end ;
15809: GO 15772
15811: POP
15812: POP
// end ;
15813: LD_VAR 0 3
15817: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
15818: LD_INT 0
15820: PPUSH
15821: PPUSH
15822: PPUSH
// pom := GetBase ( fac ) ;
15823: LD_ADDR_VAR 0 5
15827: PUSH
15828: LD_VAR 0 1
15832: PPUSH
15833: CALL_OW 274
15837: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
15838: LD_ADDR_VAR 0 4
15842: PUSH
15843: LD_VAR 0 2
15847: PUSH
15848: LD_INT 1
15850: ARRAY
15851: PPUSH
15852: LD_VAR 0 2
15856: PUSH
15857: LD_INT 2
15859: ARRAY
15860: PPUSH
15861: LD_VAR 0 2
15865: PUSH
15866: LD_INT 3
15868: ARRAY
15869: PPUSH
15870: LD_VAR 0 2
15874: PUSH
15875: LD_INT 4
15877: ARRAY
15878: PPUSH
15879: CALL_OW 449
15883: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
15884: LD_ADDR_VAR 0 3
15888: PUSH
15889: LD_VAR 0 5
15893: PPUSH
15894: LD_INT 1
15896: PPUSH
15897: CALL_OW 275
15901: PUSH
15902: LD_VAR 0 4
15906: PUSH
15907: LD_INT 1
15909: ARRAY
15910: GREATEREQUAL
15911: PUSH
15912: LD_VAR 0 5
15916: PPUSH
15917: LD_INT 2
15919: PPUSH
15920: CALL_OW 275
15924: PUSH
15925: LD_VAR 0 4
15929: PUSH
15930: LD_INT 2
15932: ARRAY
15933: GREATEREQUAL
15934: AND
15935: PUSH
15936: LD_VAR 0 5
15940: PPUSH
15941: LD_INT 3
15943: PPUSH
15944: CALL_OW 275
15948: PUSH
15949: LD_VAR 0 4
15953: PUSH
15954: LD_INT 3
15956: ARRAY
15957: GREATEREQUAL
15958: AND
15959: ST_TO_ADDR
// end ;
15960: LD_VAR 0 3
15964: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
15965: LD_INT 0
15967: PPUSH
15968: PPUSH
15969: PPUSH
15970: PPUSH
// pom := GetBase ( building ) ;
15971: LD_ADDR_VAR 0 3
15975: PUSH
15976: LD_VAR 0 1
15980: PPUSH
15981: CALL_OW 274
15985: ST_TO_ADDR
// if not pom then
15986: LD_VAR 0 3
15990: NOT
15991: IFFALSE 15995
// exit ;
15993: GO 16165
// btype := GetBType ( building ) ;
15995: LD_ADDR_VAR 0 5
15999: PUSH
16000: LD_VAR 0 1
16004: PPUSH
16005: CALL_OW 266
16009: ST_TO_ADDR
// if btype = b_armoury then
16010: LD_VAR 0 5
16014: PUSH
16015: LD_INT 4
16017: EQUAL
16018: IFFALSE 16028
// btype := b_barracks ;
16020: LD_ADDR_VAR 0 5
16024: PUSH
16025: LD_INT 5
16027: ST_TO_ADDR
// if btype = b_depot then
16028: LD_VAR 0 5
16032: PUSH
16033: LD_INT 0
16035: EQUAL
16036: IFFALSE 16046
// btype := b_warehouse ;
16038: LD_ADDR_VAR 0 5
16042: PUSH
16043: LD_INT 1
16045: ST_TO_ADDR
// if btype = b_workshop then
16046: LD_VAR 0 5
16050: PUSH
16051: LD_INT 2
16053: EQUAL
16054: IFFALSE 16064
// btype := b_factory ;
16056: LD_ADDR_VAR 0 5
16060: PUSH
16061: LD_INT 3
16063: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
16064: LD_ADDR_VAR 0 4
16068: PUSH
16069: LD_VAR 0 5
16073: PPUSH
16074: LD_VAR 0 1
16078: PPUSH
16079: CALL_OW 248
16083: PPUSH
16084: CALL_OW 450
16088: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
16089: LD_ADDR_VAR 0 2
16093: PUSH
16094: LD_VAR 0 3
16098: PPUSH
16099: LD_INT 1
16101: PPUSH
16102: CALL_OW 275
16106: PUSH
16107: LD_VAR 0 4
16111: PUSH
16112: LD_INT 1
16114: ARRAY
16115: GREATEREQUAL
16116: PUSH
16117: LD_VAR 0 3
16121: PPUSH
16122: LD_INT 2
16124: PPUSH
16125: CALL_OW 275
16129: PUSH
16130: LD_VAR 0 4
16134: PUSH
16135: LD_INT 2
16137: ARRAY
16138: GREATEREQUAL
16139: AND
16140: PUSH
16141: LD_VAR 0 3
16145: PPUSH
16146: LD_INT 3
16148: PPUSH
16149: CALL_OW 275
16153: PUSH
16154: LD_VAR 0 4
16158: PUSH
16159: LD_INT 3
16161: ARRAY
16162: GREATEREQUAL
16163: AND
16164: ST_TO_ADDR
// end ;
16165: LD_VAR 0 2
16169: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
16170: LD_INT 0
16172: PPUSH
16173: PPUSH
16174: PPUSH
// pom := GetBase ( building ) ;
16175: LD_ADDR_VAR 0 4
16179: PUSH
16180: LD_VAR 0 1
16184: PPUSH
16185: CALL_OW 274
16189: ST_TO_ADDR
// if not pom then
16190: LD_VAR 0 4
16194: NOT
16195: IFFALSE 16199
// exit ;
16197: GO 16300
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
16199: LD_ADDR_VAR 0 5
16203: PUSH
16204: LD_VAR 0 2
16208: PPUSH
16209: LD_VAR 0 1
16213: PPUSH
16214: CALL_OW 248
16218: PPUSH
16219: CALL_OW 450
16223: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
16224: LD_ADDR_VAR 0 3
16228: PUSH
16229: LD_VAR 0 4
16233: PPUSH
16234: LD_INT 1
16236: PPUSH
16237: CALL_OW 275
16241: PUSH
16242: LD_VAR 0 5
16246: PUSH
16247: LD_INT 1
16249: ARRAY
16250: GREATEREQUAL
16251: PUSH
16252: LD_VAR 0 4
16256: PPUSH
16257: LD_INT 2
16259: PPUSH
16260: CALL_OW 275
16264: PUSH
16265: LD_VAR 0 5
16269: PUSH
16270: LD_INT 2
16272: ARRAY
16273: GREATEREQUAL
16274: AND
16275: PUSH
16276: LD_VAR 0 4
16280: PPUSH
16281: LD_INT 3
16283: PPUSH
16284: CALL_OW 275
16288: PUSH
16289: LD_VAR 0 5
16293: PUSH
16294: LD_INT 3
16296: ARRAY
16297: GREATEREQUAL
16298: AND
16299: ST_TO_ADDR
// end ;
16300: LD_VAR 0 3
16304: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
16305: LD_INT 0
16307: PPUSH
16308: PPUSH
16309: PPUSH
16310: PPUSH
16311: PPUSH
16312: PPUSH
16313: PPUSH
16314: PPUSH
16315: PPUSH
16316: PPUSH
16317: PPUSH
// result := false ;
16318: LD_ADDR_VAR 0 8
16322: PUSH
16323: LD_INT 0
16325: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
16326: LD_VAR 0 5
16330: NOT
16331: PUSH
16332: LD_VAR 0 1
16336: NOT
16337: OR
16338: PUSH
16339: LD_VAR 0 2
16343: NOT
16344: OR
16345: PUSH
16346: LD_VAR 0 3
16350: NOT
16351: OR
16352: IFFALSE 16356
// exit ;
16354: GO 17170
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
16356: LD_ADDR_VAR 0 14
16360: PUSH
16361: LD_VAR 0 1
16365: PPUSH
16366: LD_VAR 0 2
16370: PPUSH
16371: LD_VAR 0 3
16375: PPUSH
16376: LD_VAR 0 4
16380: PPUSH
16381: LD_VAR 0 5
16385: PUSH
16386: LD_INT 1
16388: ARRAY
16389: PPUSH
16390: CALL_OW 248
16394: PPUSH
16395: LD_INT 0
16397: PPUSH
16398: CALL 18007 0 6
16402: ST_TO_ADDR
// if not hexes then
16403: LD_VAR 0 14
16407: NOT
16408: IFFALSE 16412
// exit ;
16410: GO 17170
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
16412: LD_ADDR_VAR 0 17
16416: PUSH
16417: LD_VAR 0 5
16421: PPUSH
16422: LD_INT 22
16424: PUSH
16425: LD_VAR 0 13
16429: PPUSH
16430: CALL_OW 255
16434: PUSH
16435: EMPTY
16436: LIST
16437: LIST
16438: PUSH
16439: LD_INT 2
16441: PUSH
16442: LD_INT 30
16444: PUSH
16445: LD_INT 0
16447: PUSH
16448: EMPTY
16449: LIST
16450: LIST
16451: PUSH
16452: LD_INT 30
16454: PUSH
16455: LD_INT 1
16457: PUSH
16458: EMPTY
16459: LIST
16460: LIST
16461: PUSH
16462: EMPTY
16463: LIST
16464: LIST
16465: LIST
16466: PUSH
16467: EMPTY
16468: LIST
16469: LIST
16470: PPUSH
16471: CALL_OW 72
16475: ST_TO_ADDR
// for i = 1 to hexes do
16476: LD_ADDR_VAR 0 9
16480: PUSH
16481: DOUBLE
16482: LD_INT 1
16484: DEC
16485: ST_TO_ADDR
16486: LD_VAR 0 14
16490: PUSH
16491: FOR_TO
16492: IFFALSE 17168
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
16494: LD_ADDR_VAR 0 13
16498: PUSH
16499: LD_VAR 0 14
16503: PUSH
16504: LD_VAR 0 9
16508: ARRAY
16509: PUSH
16510: LD_INT 1
16512: ARRAY
16513: PPUSH
16514: LD_VAR 0 14
16518: PUSH
16519: LD_VAR 0 9
16523: ARRAY
16524: PUSH
16525: LD_INT 2
16527: ARRAY
16528: PPUSH
16529: CALL_OW 428
16533: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
16534: LD_VAR 0 14
16538: PUSH
16539: LD_VAR 0 9
16543: ARRAY
16544: PUSH
16545: LD_INT 1
16547: ARRAY
16548: PPUSH
16549: LD_VAR 0 14
16553: PUSH
16554: LD_VAR 0 9
16558: ARRAY
16559: PUSH
16560: LD_INT 2
16562: ARRAY
16563: PPUSH
16564: CALL_OW 351
16568: PUSH
16569: LD_VAR 0 14
16573: PUSH
16574: LD_VAR 0 9
16578: ARRAY
16579: PUSH
16580: LD_INT 1
16582: ARRAY
16583: PPUSH
16584: LD_VAR 0 14
16588: PUSH
16589: LD_VAR 0 9
16593: ARRAY
16594: PUSH
16595: LD_INT 2
16597: ARRAY
16598: PPUSH
16599: CALL_OW 488
16603: NOT
16604: OR
16605: PUSH
16606: LD_VAR 0 13
16610: PPUSH
16611: CALL_OW 247
16615: PUSH
16616: LD_INT 3
16618: EQUAL
16619: OR
16620: IFFALSE 16626
// exit ;
16622: POP
16623: POP
16624: GO 17170
// if not tmp then
16626: LD_VAR 0 13
16630: NOT
16631: IFFALSE 16635
// continue ;
16633: GO 16491
// result := true ;
16635: LD_ADDR_VAR 0 8
16639: PUSH
16640: LD_INT 1
16642: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
16643: LD_VAR 0 6
16647: PUSH
16648: LD_VAR 0 13
16652: PPUSH
16653: CALL_OW 247
16657: PUSH
16658: LD_INT 2
16660: EQUAL
16661: AND
16662: PUSH
16663: LD_VAR 0 13
16667: PPUSH
16668: CALL_OW 263
16672: PUSH
16673: LD_INT 1
16675: EQUAL
16676: AND
16677: IFFALSE 16841
// begin if IsDrivenBy ( tmp ) then
16679: LD_VAR 0 13
16683: PPUSH
16684: CALL_OW 311
16688: IFFALSE 16692
// continue ;
16690: GO 16491
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
16692: LD_VAR 0 6
16696: PPUSH
16697: LD_INT 3
16699: PUSH
16700: LD_INT 60
16702: PUSH
16703: EMPTY
16704: LIST
16705: PUSH
16706: EMPTY
16707: LIST
16708: LIST
16709: PUSH
16710: LD_INT 3
16712: PUSH
16713: LD_INT 55
16715: PUSH
16716: EMPTY
16717: LIST
16718: PUSH
16719: EMPTY
16720: LIST
16721: LIST
16722: PUSH
16723: EMPTY
16724: LIST
16725: LIST
16726: PPUSH
16727: CALL_OW 72
16731: IFFALSE 16839
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
16733: LD_ADDR_VAR 0 18
16737: PUSH
16738: LD_VAR 0 6
16742: PPUSH
16743: LD_INT 3
16745: PUSH
16746: LD_INT 60
16748: PUSH
16749: EMPTY
16750: LIST
16751: PUSH
16752: EMPTY
16753: LIST
16754: LIST
16755: PUSH
16756: LD_INT 3
16758: PUSH
16759: LD_INT 55
16761: PUSH
16762: EMPTY
16763: LIST
16764: PUSH
16765: EMPTY
16766: LIST
16767: LIST
16768: PUSH
16769: EMPTY
16770: LIST
16771: LIST
16772: PPUSH
16773: CALL_OW 72
16777: PUSH
16778: LD_INT 1
16780: ARRAY
16781: ST_TO_ADDR
// if IsInUnit ( driver ) then
16782: LD_VAR 0 18
16786: PPUSH
16787: CALL_OW 310
16791: IFFALSE 16802
// ComExit ( driver ) ;
16793: LD_VAR 0 18
16797: PPUSH
16798: CALL 41191 0 1
// AddComEnterUnit ( driver , tmp ) ;
16802: LD_VAR 0 18
16806: PPUSH
16807: LD_VAR 0 13
16811: PPUSH
16812: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
16816: LD_VAR 0 18
16820: PPUSH
16821: LD_VAR 0 7
16825: PPUSH
16826: CALL_OW 173
// AddComExitVehicle ( driver ) ;
16830: LD_VAR 0 18
16834: PPUSH
16835: CALL_OW 181
// end ; continue ;
16839: GO 16491
// end ; if not cleaners or not tmp in cleaners then
16841: LD_VAR 0 6
16845: NOT
16846: PUSH
16847: LD_VAR 0 13
16851: PUSH
16852: LD_VAR 0 6
16856: IN
16857: NOT
16858: OR
16859: IFFALSE 17166
// begin if dep then
16861: LD_VAR 0 17
16865: IFFALSE 17001
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
16867: LD_ADDR_VAR 0 16
16871: PUSH
16872: LD_VAR 0 17
16876: PUSH
16877: LD_INT 1
16879: ARRAY
16880: PPUSH
16881: CALL_OW 250
16885: PPUSH
16886: LD_VAR 0 17
16890: PUSH
16891: LD_INT 1
16893: ARRAY
16894: PPUSH
16895: CALL_OW 254
16899: PPUSH
16900: LD_INT 5
16902: PPUSH
16903: CALL_OW 272
16907: PUSH
16908: LD_VAR 0 17
16912: PUSH
16913: LD_INT 1
16915: ARRAY
16916: PPUSH
16917: CALL_OW 251
16921: PPUSH
16922: LD_VAR 0 17
16926: PUSH
16927: LD_INT 1
16929: ARRAY
16930: PPUSH
16931: CALL_OW 254
16935: PPUSH
16936: LD_INT 5
16938: PPUSH
16939: CALL_OW 273
16943: PUSH
16944: EMPTY
16945: LIST
16946: LIST
16947: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
16948: LD_VAR 0 16
16952: PUSH
16953: LD_INT 1
16955: ARRAY
16956: PPUSH
16957: LD_VAR 0 16
16961: PUSH
16962: LD_INT 2
16964: ARRAY
16965: PPUSH
16966: CALL_OW 488
16970: IFFALSE 17001
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
16972: LD_VAR 0 13
16976: PPUSH
16977: LD_VAR 0 16
16981: PUSH
16982: LD_INT 1
16984: ARRAY
16985: PPUSH
16986: LD_VAR 0 16
16990: PUSH
16991: LD_INT 2
16993: ARRAY
16994: PPUSH
16995: CALL_OW 111
// continue ;
16999: GO 16491
// end ; end ; r := GetDir ( tmp ) ;
17001: LD_ADDR_VAR 0 15
17005: PUSH
17006: LD_VAR 0 13
17010: PPUSH
17011: CALL_OW 254
17015: ST_TO_ADDR
// if r = 5 then
17016: LD_VAR 0 15
17020: PUSH
17021: LD_INT 5
17023: EQUAL
17024: IFFALSE 17034
// r := 0 ;
17026: LD_ADDR_VAR 0 15
17030: PUSH
17031: LD_INT 0
17033: ST_TO_ADDR
// for j = r to 5 do
17034: LD_ADDR_VAR 0 10
17038: PUSH
17039: DOUBLE
17040: LD_VAR 0 15
17044: DEC
17045: ST_TO_ADDR
17046: LD_INT 5
17048: PUSH
17049: FOR_TO
17050: IFFALSE 17164
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
17052: LD_ADDR_VAR 0 11
17056: PUSH
17057: LD_VAR 0 13
17061: PPUSH
17062: CALL_OW 250
17066: PPUSH
17067: LD_VAR 0 10
17071: PPUSH
17072: LD_INT 2
17074: PPUSH
17075: CALL_OW 272
17079: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
17080: LD_ADDR_VAR 0 12
17084: PUSH
17085: LD_VAR 0 13
17089: PPUSH
17090: CALL_OW 251
17094: PPUSH
17095: LD_VAR 0 10
17099: PPUSH
17100: LD_INT 2
17102: PPUSH
17103: CALL_OW 273
17107: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
17108: LD_VAR 0 11
17112: PPUSH
17113: LD_VAR 0 12
17117: PPUSH
17118: CALL_OW 488
17122: PUSH
17123: LD_VAR 0 11
17127: PPUSH
17128: LD_VAR 0 12
17132: PPUSH
17133: CALL_OW 428
17137: NOT
17138: AND
17139: IFFALSE 17162
// begin ComMoveXY ( tmp , _x , _y ) ;
17141: LD_VAR 0 13
17145: PPUSH
17146: LD_VAR 0 11
17150: PPUSH
17151: LD_VAR 0 12
17155: PPUSH
17156: CALL_OW 111
// break ;
17160: GO 17164
// end ; end ;
17162: GO 17049
17164: POP
17165: POP
// end ; end ;
17166: GO 16491
17168: POP
17169: POP
// end ;
17170: LD_VAR 0 8
17174: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
17175: LD_INT 0
17177: PPUSH
17178: PPUSH
17179: PPUSH
17180: PPUSH
17181: PPUSH
17182: PPUSH
17183: PPUSH
17184: PPUSH
17185: PPUSH
17186: PPUSH
// result := false ;
17187: LD_ADDR_VAR 0 6
17191: PUSH
17192: LD_INT 0
17194: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
17195: LD_VAR 0 1
17199: NOT
17200: PUSH
17201: LD_VAR 0 1
17205: PPUSH
17206: CALL_OW 266
17210: PUSH
17211: LD_INT 0
17213: PUSH
17214: LD_INT 1
17216: PUSH
17217: EMPTY
17218: LIST
17219: LIST
17220: IN
17221: NOT
17222: OR
17223: PUSH
17224: LD_VAR 0 2
17228: NOT
17229: OR
17230: PUSH
17231: LD_VAR 0 5
17235: PUSH
17236: LD_INT 0
17238: PUSH
17239: LD_INT 1
17241: PUSH
17242: LD_INT 2
17244: PUSH
17245: LD_INT 3
17247: PUSH
17248: LD_INT 4
17250: PUSH
17251: LD_INT 5
17253: PUSH
17254: EMPTY
17255: LIST
17256: LIST
17257: LIST
17258: LIST
17259: LIST
17260: LIST
17261: IN
17262: NOT
17263: OR
17264: PUSH
17265: LD_VAR 0 3
17269: PPUSH
17270: LD_VAR 0 4
17274: PPUSH
17275: CALL_OW 488
17279: NOT
17280: OR
17281: IFFALSE 17285
// exit ;
17283: GO 18002
// pom := GetBase ( depot ) ;
17285: LD_ADDR_VAR 0 10
17289: PUSH
17290: LD_VAR 0 1
17294: PPUSH
17295: CALL_OW 274
17299: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
17300: LD_ADDR_VAR 0 11
17304: PUSH
17305: LD_VAR 0 2
17309: PPUSH
17310: LD_VAR 0 1
17314: PPUSH
17315: CALL_OW 248
17319: PPUSH
17320: CALL_OW 450
17324: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
17325: LD_VAR 0 10
17329: PPUSH
17330: LD_INT 1
17332: PPUSH
17333: CALL_OW 275
17337: PUSH
17338: LD_VAR 0 11
17342: PUSH
17343: LD_INT 1
17345: ARRAY
17346: GREATEREQUAL
17347: PUSH
17348: LD_VAR 0 10
17352: PPUSH
17353: LD_INT 2
17355: PPUSH
17356: CALL_OW 275
17360: PUSH
17361: LD_VAR 0 11
17365: PUSH
17366: LD_INT 2
17368: ARRAY
17369: GREATEREQUAL
17370: AND
17371: PUSH
17372: LD_VAR 0 10
17376: PPUSH
17377: LD_INT 3
17379: PPUSH
17380: CALL_OW 275
17384: PUSH
17385: LD_VAR 0 11
17389: PUSH
17390: LD_INT 3
17392: ARRAY
17393: GREATEREQUAL
17394: AND
17395: NOT
17396: IFFALSE 17400
// exit ;
17398: GO 18002
// if GetBType ( depot ) = b_depot then
17400: LD_VAR 0 1
17404: PPUSH
17405: CALL_OW 266
17409: PUSH
17410: LD_INT 0
17412: EQUAL
17413: IFFALSE 17425
// dist := 28 else
17415: LD_ADDR_VAR 0 14
17419: PUSH
17420: LD_INT 28
17422: ST_TO_ADDR
17423: GO 17433
// dist := 36 ;
17425: LD_ADDR_VAR 0 14
17429: PUSH
17430: LD_INT 36
17432: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
17433: LD_VAR 0 1
17437: PPUSH
17438: LD_VAR 0 3
17442: PPUSH
17443: LD_VAR 0 4
17447: PPUSH
17448: CALL_OW 297
17452: PUSH
17453: LD_VAR 0 14
17457: GREATER
17458: IFFALSE 17462
// exit ;
17460: GO 18002
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
17462: LD_ADDR_VAR 0 12
17466: PUSH
17467: LD_VAR 0 2
17471: PPUSH
17472: LD_VAR 0 3
17476: PPUSH
17477: LD_VAR 0 4
17481: PPUSH
17482: LD_VAR 0 5
17486: PPUSH
17487: LD_VAR 0 1
17491: PPUSH
17492: CALL_OW 248
17496: PPUSH
17497: LD_INT 0
17499: PPUSH
17500: CALL 18007 0 6
17504: ST_TO_ADDR
// if not hexes then
17505: LD_VAR 0 12
17509: NOT
17510: IFFALSE 17514
// exit ;
17512: GO 18002
// hex := GetHexInfo ( x , y ) ;
17514: LD_ADDR_VAR 0 15
17518: PUSH
17519: LD_VAR 0 3
17523: PPUSH
17524: LD_VAR 0 4
17528: PPUSH
17529: CALL_OW 546
17533: ST_TO_ADDR
// if hex [ 1 ] then
17534: LD_VAR 0 15
17538: PUSH
17539: LD_INT 1
17541: ARRAY
17542: IFFALSE 17546
// exit ;
17544: GO 18002
// height := hex [ 2 ] ;
17546: LD_ADDR_VAR 0 13
17550: PUSH
17551: LD_VAR 0 15
17555: PUSH
17556: LD_INT 2
17558: ARRAY
17559: ST_TO_ADDR
// for i = 1 to hexes do
17560: LD_ADDR_VAR 0 7
17564: PUSH
17565: DOUBLE
17566: LD_INT 1
17568: DEC
17569: ST_TO_ADDR
17570: LD_VAR 0 12
17574: PUSH
17575: FOR_TO
17576: IFFALSE 17906
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
17578: LD_VAR 0 12
17582: PUSH
17583: LD_VAR 0 7
17587: ARRAY
17588: PUSH
17589: LD_INT 1
17591: ARRAY
17592: PPUSH
17593: LD_VAR 0 12
17597: PUSH
17598: LD_VAR 0 7
17602: ARRAY
17603: PUSH
17604: LD_INT 2
17606: ARRAY
17607: PPUSH
17608: CALL_OW 488
17612: NOT
17613: PUSH
17614: LD_VAR 0 12
17618: PUSH
17619: LD_VAR 0 7
17623: ARRAY
17624: PUSH
17625: LD_INT 1
17627: ARRAY
17628: PPUSH
17629: LD_VAR 0 12
17633: PUSH
17634: LD_VAR 0 7
17638: ARRAY
17639: PUSH
17640: LD_INT 2
17642: ARRAY
17643: PPUSH
17644: CALL_OW 428
17648: PUSH
17649: LD_INT 0
17651: GREATER
17652: OR
17653: PUSH
17654: LD_VAR 0 12
17658: PUSH
17659: LD_VAR 0 7
17663: ARRAY
17664: PUSH
17665: LD_INT 1
17667: ARRAY
17668: PPUSH
17669: LD_VAR 0 12
17673: PUSH
17674: LD_VAR 0 7
17678: ARRAY
17679: PUSH
17680: LD_INT 2
17682: ARRAY
17683: PPUSH
17684: CALL_OW 351
17688: OR
17689: IFFALSE 17695
// exit ;
17691: POP
17692: POP
17693: GO 18002
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
17695: LD_ADDR_VAR 0 8
17699: PUSH
17700: LD_VAR 0 12
17704: PUSH
17705: LD_VAR 0 7
17709: ARRAY
17710: PUSH
17711: LD_INT 1
17713: ARRAY
17714: PPUSH
17715: LD_VAR 0 12
17719: PUSH
17720: LD_VAR 0 7
17724: ARRAY
17725: PUSH
17726: LD_INT 2
17728: ARRAY
17729: PPUSH
17730: CALL_OW 546
17734: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
17735: LD_VAR 0 8
17739: PUSH
17740: LD_INT 1
17742: ARRAY
17743: PUSH
17744: LD_VAR 0 8
17748: PUSH
17749: LD_INT 2
17751: ARRAY
17752: PUSH
17753: LD_VAR 0 13
17757: PUSH
17758: LD_INT 2
17760: PLUS
17761: GREATER
17762: OR
17763: PUSH
17764: LD_VAR 0 8
17768: PUSH
17769: LD_INT 2
17771: ARRAY
17772: PUSH
17773: LD_VAR 0 13
17777: PUSH
17778: LD_INT 2
17780: MINUS
17781: LESS
17782: OR
17783: PUSH
17784: LD_VAR 0 8
17788: PUSH
17789: LD_INT 3
17791: ARRAY
17792: PUSH
17793: LD_INT 0
17795: PUSH
17796: LD_INT 8
17798: PUSH
17799: LD_INT 9
17801: PUSH
17802: LD_INT 10
17804: PUSH
17805: LD_INT 11
17807: PUSH
17808: LD_INT 12
17810: PUSH
17811: LD_INT 13
17813: PUSH
17814: LD_INT 16
17816: PUSH
17817: LD_INT 17
17819: PUSH
17820: LD_INT 18
17822: PUSH
17823: LD_INT 19
17825: PUSH
17826: LD_INT 20
17828: PUSH
17829: LD_INT 21
17831: PUSH
17832: EMPTY
17833: LIST
17834: LIST
17835: LIST
17836: LIST
17837: LIST
17838: LIST
17839: LIST
17840: LIST
17841: LIST
17842: LIST
17843: LIST
17844: LIST
17845: LIST
17846: IN
17847: NOT
17848: OR
17849: PUSH
17850: LD_VAR 0 8
17854: PUSH
17855: LD_INT 5
17857: ARRAY
17858: NOT
17859: OR
17860: PUSH
17861: LD_VAR 0 8
17865: PUSH
17866: LD_INT 6
17868: ARRAY
17869: PUSH
17870: LD_INT 1
17872: PUSH
17873: LD_INT 2
17875: PUSH
17876: LD_INT 7
17878: PUSH
17879: LD_INT 9
17881: PUSH
17882: LD_INT 10
17884: PUSH
17885: LD_INT 11
17887: PUSH
17888: EMPTY
17889: LIST
17890: LIST
17891: LIST
17892: LIST
17893: LIST
17894: LIST
17895: IN
17896: NOT
17897: OR
17898: IFFALSE 17904
// exit ;
17900: POP
17901: POP
17902: GO 18002
// end ;
17904: GO 17575
17906: POP
17907: POP
// side := GetSide ( depot ) ;
17908: LD_ADDR_VAR 0 9
17912: PUSH
17913: LD_VAR 0 1
17917: PPUSH
17918: CALL_OW 255
17922: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
17923: LD_VAR 0 9
17927: PPUSH
17928: LD_VAR 0 3
17932: PPUSH
17933: LD_VAR 0 4
17937: PPUSH
17938: LD_INT 20
17940: PPUSH
17941: CALL 10323 0 4
17945: PUSH
17946: LD_INT 4
17948: ARRAY
17949: IFFALSE 17953
// exit ;
17951: GO 18002
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
17953: LD_VAR 0 2
17957: PUSH
17958: LD_INT 29
17960: PUSH
17961: LD_INT 30
17963: PUSH
17964: EMPTY
17965: LIST
17966: LIST
17967: IN
17968: PUSH
17969: LD_VAR 0 3
17973: PPUSH
17974: LD_VAR 0 4
17978: PPUSH
17979: LD_VAR 0 9
17983: PPUSH
17984: CALL_OW 440
17988: NOT
17989: AND
17990: IFFALSE 17994
// exit ;
17992: GO 18002
// result := true ;
17994: LD_ADDR_VAR 0 6
17998: PUSH
17999: LD_INT 1
18001: ST_TO_ADDR
// end ;
18002: LD_VAR 0 6
18006: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
18007: LD_INT 0
18009: PPUSH
18010: PPUSH
18011: PPUSH
18012: PPUSH
18013: PPUSH
18014: PPUSH
18015: PPUSH
18016: PPUSH
18017: PPUSH
18018: PPUSH
18019: PPUSH
18020: PPUSH
18021: PPUSH
18022: PPUSH
18023: PPUSH
18024: PPUSH
18025: PPUSH
18026: PPUSH
18027: PPUSH
18028: PPUSH
18029: PPUSH
18030: PPUSH
18031: PPUSH
18032: PPUSH
18033: PPUSH
18034: PPUSH
18035: PPUSH
18036: PPUSH
18037: PPUSH
18038: PPUSH
18039: PPUSH
18040: PPUSH
18041: PPUSH
18042: PPUSH
18043: PPUSH
18044: PPUSH
18045: PPUSH
18046: PPUSH
18047: PPUSH
18048: PPUSH
18049: PPUSH
18050: PPUSH
18051: PPUSH
18052: PPUSH
18053: PPUSH
18054: PPUSH
18055: PPUSH
18056: PPUSH
18057: PPUSH
18058: PPUSH
18059: PPUSH
18060: PPUSH
18061: PPUSH
18062: PPUSH
18063: PPUSH
18064: PPUSH
18065: PPUSH
18066: PPUSH
// result = [ ] ;
18067: LD_ADDR_VAR 0 7
18071: PUSH
18072: EMPTY
18073: ST_TO_ADDR
// temp_list = [ ] ;
18074: LD_ADDR_VAR 0 9
18078: PUSH
18079: EMPTY
18080: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
18081: LD_VAR 0 4
18085: PUSH
18086: LD_INT 0
18088: PUSH
18089: LD_INT 1
18091: PUSH
18092: LD_INT 2
18094: PUSH
18095: LD_INT 3
18097: PUSH
18098: LD_INT 4
18100: PUSH
18101: LD_INT 5
18103: PUSH
18104: EMPTY
18105: LIST
18106: LIST
18107: LIST
18108: LIST
18109: LIST
18110: LIST
18111: IN
18112: NOT
18113: PUSH
18114: LD_VAR 0 1
18118: PUSH
18119: LD_INT 0
18121: PUSH
18122: LD_INT 1
18124: PUSH
18125: EMPTY
18126: LIST
18127: LIST
18128: IN
18129: PUSH
18130: LD_VAR 0 5
18134: PUSH
18135: LD_INT 1
18137: PUSH
18138: LD_INT 2
18140: PUSH
18141: LD_INT 3
18143: PUSH
18144: EMPTY
18145: LIST
18146: LIST
18147: LIST
18148: IN
18149: NOT
18150: AND
18151: OR
18152: IFFALSE 18156
// exit ;
18154: GO 36547
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
18156: LD_VAR 0 1
18160: PUSH
18161: LD_INT 6
18163: PUSH
18164: LD_INT 7
18166: PUSH
18167: LD_INT 8
18169: PUSH
18170: LD_INT 13
18172: PUSH
18173: LD_INT 12
18175: PUSH
18176: LD_INT 15
18178: PUSH
18179: LD_INT 11
18181: PUSH
18182: LD_INT 14
18184: PUSH
18185: LD_INT 10
18187: PUSH
18188: EMPTY
18189: LIST
18190: LIST
18191: LIST
18192: LIST
18193: LIST
18194: LIST
18195: LIST
18196: LIST
18197: LIST
18198: IN
18199: IFFALSE 18209
// btype = b_lab ;
18201: LD_ADDR_VAR 0 1
18205: PUSH
18206: LD_INT 6
18208: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
18209: LD_VAR 0 6
18213: PUSH
18214: LD_INT 0
18216: PUSH
18217: LD_INT 1
18219: PUSH
18220: LD_INT 2
18222: PUSH
18223: EMPTY
18224: LIST
18225: LIST
18226: LIST
18227: IN
18228: NOT
18229: PUSH
18230: LD_VAR 0 1
18234: PUSH
18235: LD_INT 0
18237: PUSH
18238: LD_INT 1
18240: PUSH
18241: LD_INT 2
18243: PUSH
18244: LD_INT 3
18246: PUSH
18247: LD_INT 6
18249: PUSH
18250: LD_INT 36
18252: PUSH
18253: LD_INT 4
18255: PUSH
18256: LD_INT 5
18258: PUSH
18259: LD_INT 31
18261: PUSH
18262: LD_INT 32
18264: PUSH
18265: LD_INT 33
18267: PUSH
18268: EMPTY
18269: LIST
18270: LIST
18271: LIST
18272: LIST
18273: LIST
18274: LIST
18275: LIST
18276: LIST
18277: LIST
18278: LIST
18279: LIST
18280: IN
18281: NOT
18282: PUSH
18283: LD_VAR 0 6
18287: PUSH
18288: LD_INT 1
18290: EQUAL
18291: AND
18292: OR
18293: PUSH
18294: LD_VAR 0 1
18298: PUSH
18299: LD_INT 2
18301: PUSH
18302: LD_INT 3
18304: PUSH
18305: EMPTY
18306: LIST
18307: LIST
18308: IN
18309: NOT
18310: PUSH
18311: LD_VAR 0 6
18315: PUSH
18316: LD_INT 2
18318: EQUAL
18319: AND
18320: OR
18321: IFFALSE 18331
// mode = 0 ;
18323: LD_ADDR_VAR 0 6
18327: PUSH
18328: LD_INT 0
18330: ST_TO_ADDR
// case mode of 0 :
18331: LD_VAR 0 6
18335: PUSH
18336: LD_INT 0
18338: DOUBLE
18339: EQUAL
18340: IFTRUE 18344
18342: GO 29797
18344: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
18345: LD_ADDR_VAR 0 11
18349: PUSH
18350: LD_INT 0
18352: PUSH
18353: LD_INT 0
18355: PUSH
18356: EMPTY
18357: LIST
18358: LIST
18359: PUSH
18360: LD_INT 0
18362: PUSH
18363: LD_INT 1
18365: NEG
18366: PUSH
18367: EMPTY
18368: LIST
18369: LIST
18370: PUSH
18371: LD_INT 1
18373: PUSH
18374: LD_INT 0
18376: PUSH
18377: EMPTY
18378: LIST
18379: LIST
18380: PUSH
18381: LD_INT 1
18383: PUSH
18384: LD_INT 1
18386: PUSH
18387: EMPTY
18388: LIST
18389: LIST
18390: PUSH
18391: LD_INT 0
18393: PUSH
18394: LD_INT 1
18396: PUSH
18397: EMPTY
18398: LIST
18399: LIST
18400: PUSH
18401: LD_INT 1
18403: NEG
18404: PUSH
18405: LD_INT 0
18407: PUSH
18408: EMPTY
18409: LIST
18410: LIST
18411: PUSH
18412: LD_INT 1
18414: NEG
18415: PUSH
18416: LD_INT 1
18418: NEG
18419: PUSH
18420: EMPTY
18421: LIST
18422: LIST
18423: PUSH
18424: LD_INT 1
18426: NEG
18427: PUSH
18428: LD_INT 2
18430: NEG
18431: PUSH
18432: EMPTY
18433: LIST
18434: LIST
18435: PUSH
18436: LD_INT 0
18438: PUSH
18439: LD_INT 2
18441: NEG
18442: PUSH
18443: EMPTY
18444: LIST
18445: LIST
18446: PUSH
18447: LD_INT 1
18449: PUSH
18450: LD_INT 1
18452: NEG
18453: PUSH
18454: EMPTY
18455: LIST
18456: LIST
18457: PUSH
18458: LD_INT 1
18460: PUSH
18461: LD_INT 2
18463: PUSH
18464: EMPTY
18465: LIST
18466: LIST
18467: PUSH
18468: LD_INT 0
18470: PUSH
18471: LD_INT 2
18473: PUSH
18474: EMPTY
18475: LIST
18476: LIST
18477: PUSH
18478: LD_INT 1
18480: NEG
18481: PUSH
18482: LD_INT 1
18484: PUSH
18485: EMPTY
18486: LIST
18487: LIST
18488: PUSH
18489: LD_INT 1
18491: PUSH
18492: LD_INT 3
18494: PUSH
18495: EMPTY
18496: LIST
18497: LIST
18498: PUSH
18499: LD_INT 0
18501: PUSH
18502: LD_INT 3
18504: PUSH
18505: EMPTY
18506: LIST
18507: LIST
18508: PUSH
18509: LD_INT 1
18511: NEG
18512: PUSH
18513: LD_INT 2
18515: PUSH
18516: EMPTY
18517: LIST
18518: LIST
18519: PUSH
18520: EMPTY
18521: LIST
18522: LIST
18523: LIST
18524: LIST
18525: LIST
18526: LIST
18527: LIST
18528: LIST
18529: LIST
18530: LIST
18531: LIST
18532: LIST
18533: LIST
18534: LIST
18535: LIST
18536: LIST
18537: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
18538: LD_ADDR_VAR 0 12
18542: PUSH
18543: LD_INT 0
18545: PUSH
18546: LD_INT 0
18548: PUSH
18549: EMPTY
18550: LIST
18551: LIST
18552: PUSH
18553: LD_INT 0
18555: PUSH
18556: LD_INT 1
18558: NEG
18559: PUSH
18560: EMPTY
18561: LIST
18562: LIST
18563: PUSH
18564: LD_INT 1
18566: PUSH
18567: LD_INT 0
18569: PUSH
18570: EMPTY
18571: LIST
18572: LIST
18573: PUSH
18574: LD_INT 1
18576: PUSH
18577: LD_INT 1
18579: PUSH
18580: EMPTY
18581: LIST
18582: LIST
18583: PUSH
18584: LD_INT 0
18586: PUSH
18587: LD_INT 1
18589: PUSH
18590: EMPTY
18591: LIST
18592: LIST
18593: PUSH
18594: LD_INT 1
18596: NEG
18597: PUSH
18598: LD_INT 0
18600: PUSH
18601: EMPTY
18602: LIST
18603: LIST
18604: PUSH
18605: LD_INT 1
18607: NEG
18608: PUSH
18609: LD_INT 1
18611: NEG
18612: PUSH
18613: EMPTY
18614: LIST
18615: LIST
18616: PUSH
18617: LD_INT 1
18619: PUSH
18620: LD_INT 1
18622: NEG
18623: PUSH
18624: EMPTY
18625: LIST
18626: LIST
18627: PUSH
18628: LD_INT 2
18630: PUSH
18631: LD_INT 0
18633: PUSH
18634: EMPTY
18635: LIST
18636: LIST
18637: PUSH
18638: LD_INT 2
18640: PUSH
18641: LD_INT 1
18643: PUSH
18644: EMPTY
18645: LIST
18646: LIST
18647: PUSH
18648: LD_INT 1
18650: NEG
18651: PUSH
18652: LD_INT 1
18654: PUSH
18655: EMPTY
18656: LIST
18657: LIST
18658: PUSH
18659: LD_INT 2
18661: NEG
18662: PUSH
18663: LD_INT 0
18665: PUSH
18666: EMPTY
18667: LIST
18668: LIST
18669: PUSH
18670: LD_INT 2
18672: NEG
18673: PUSH
18674: LD_INT 1
18676: NEG
18677: PUSH
18678: EMPTY
18679: LIST
18680: LIST
18681: PUSH
18682: LD_INT 2
18684: NEG
18685: PUSH
18686: LD_INT 1
18688: PUSH
18689: EMPTY
18690: LIST
18691: LIST
18692: PUSH
18693: LD_INT 3
18695: NEG
18696: PUSH
18697: LD_INT 0
18699: PUSH
18700: EMPTY
18701: LIST
18702: LIST
18703: PUSH
18704: LD_INT 3
18706: NEG
18707: PUSH
18708: LD_INT 1
18710: NEG
18711: PUSH
18712: EMPTY
18713: LIST
18714: LIST
18715: PUSH
18716: EMPTY
18717: LIST
18718: LIST
18719: LIST
18720: LIST
18721: LIST
18722: LIST
18723: LIST
18724: LIST
18725: LIST
18726: LIST
18727: LIST
18728: LIST
18729: LIST
18730: LIST
18731: LIST
18732: LIST
18733: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
18734: LD_ADDR_VAR 0 13
18738: PUSH
18739: LD_INT 0
18741: PUSH
18742: LD_INT 0
18744: PUSH
18745: EMPTY
18746: LIST
18747: LIST
18748: PUSH
18749: LD_INT 0
18751: PUSH
18752: LD_INT 1
18754: NEG
18755: PUSH
18756: EMPTY
18757: LIST
18758: LIST
18759: PUSH
18760: LD_INT 1
18762: PUSH
18763: LD_INT 0
18765: PUSH
18766: EMPTY
18767: LIST
18768: LIST
18769: PUSH
18770: LD_INT 1
18772: PUSH
18773: LD_INT 1
18775: PUSH
18776: EMPTY
18777: LIST
18778: LIST
18779: PUSH
18780: LD_INT 0
18782: PUSH
18783: LD_INT 1
18785: PUSH
18786: EMPTY
18787: LIST
18788: LIST
18789: PUSH
18790: LD_INT 1
18792: NEG
18793: PUSH
18794: LD_INT 0
18796: PUSH
18797: EMPTY
18798: LIST
18799: LIST
18800: PUSH
18801: LD_INT 1
18803: NEG
18804: PUSH
18805: LD_INT 1
18807: NEG
18808: PUSH
18809: EMPTY
18810: LIST
18811: LIST
18812: PUSH
18813: LD_INT 1
18815: NEG
18816: PUSH
18817: LD_INT 2
18819: NEG
18820: PUSH
18821: EMPTY
18822: LIST
18823: LIST
18824: PUSH
18825: LD_INT 2
18827: PUSH
18828: LD_INT 1
18830: PUSH
18831: EMPTY
18832: LIST
18833: LIST
18834: PUSH
18835: LD_INT 2
18837: PUSH
18838: LD_INT 2
18840: PUSH
18841: EMPTY
18842: LIST
18843: LIST
18844: PUSH
18845: LD_INT 1
18847: PUSH
18848: LD_INT 2
18850: PUSH
18851: EMPTY
18852: LIST
18853: LIST
18854: PUSH
18855: LD_INT 2
18857: NEG
18858: PUSH
18859: LD_INT 1
18861: NEG
18862: PUSH
18863: EMPTY
18864: LIST
18865: LIST
18866: PUSH
18867: LD_INT 2
18869: NEG
18870: PUSH
18871: LD_INT 2
18873: NEG
18874: PUSH
18875: EMPTY
18876: LIST
18877: LIST
18878: PUSH
18879: LD_INT 2
18881: NEG
18882: PUSH
18883: LD_INT 3
18885: NEG
18886: PUSH
18887: EMPTY
18888: LIST
18889: LIST
18890: PUSH
18891: LD_INT 3
18893: NEG
18894: PUSH
18895: LD_INT 2
18897: NEG
18898: PUSH
18899: EMPTY
18900: LIST
18901: LIST
18902: PUSH
18903: LD_INT 3
18905: NEG
18906: PUSH
18907: LD_INT 3
18909: NEG
18910: PUSH
18911: EMPTY
18912: LIST
18913: LIST
18914: PUSH
18915: EMPTY
18916: LIST
18917: LIST
18918: LIST
18919: LIST
18920: LIST
18921: LIST
18922: LIST
18923: LIST
18924: LIST
18925: LIST
18926: LIST
18927: LIST
18928: LIST
18929: LIST
18930: LIST
18931: LIST
18932: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
18933: LD_ADDR_VAR 0 14
18937: PUSH
18938: LD_INT 0
18940: PUSH
18941: LD_INT 0
18943: PUSH
18944: EMPTY
18945: LIST
18946: LIST
18947: PUSH
18948: LD_INT 0
18950: PUSH
18951: LD_INT 1
18953: NEG
18954: PUSH
18955: EMPTY
18956: LIST
18957: LIST
18958: PUSH
18959: LD_INT 1
18961: PUSH
18962: LD_INT 0
18964: PUSH
18965: EMPTY
18966: LIST
18967: LIST
18968: PUSH
18969: LD_INT 1
18971: PUSH
18972: LD_INT 1
18974: PUSH
18975: EMPTY
18976: LIST
18977: LIST
18978: PUSH
18979: LD_INT 0
18981: PUSH
18982: LD_INT 1
18984: PUSH
18985: EMPTY
18986: LIST
18987: LIST
18988: PUSH
18989: LD_INT 1
18991: NEG
18992: PUSH
18993: LD_INT 0
18995: PUSH
18996: EMPTY
18997: LIST
18998: LIST
18999: PUSH
19000: LD_INT 1
19002: NEG
19003: PUSH
19004: LD_INT 1
19006: NEG
19007: PUSH
19008: EMPTY
19009: LIST
19010: LIST
19011: PUSH
19012: LD_INT 1
19014: NEG
19015: PUSH
19016: LD_INT 2
19018: NEG
19019: PUSH
19020: EMPTY
19021: LIST
19022: LIST
19023: PUSH
19024: LD_INT 0
19026: PUSH
19027: LD_INT 2
19029: NEG
19030: PUSH
19031: EMPTY
19032: LIST
19033: LIST
19034: PUSH
19035: LD_INT 1
19037: PUSH
19038: LD_INT 1
19040: NEG
19041: PUSH
19042: EMPTY
19043: LIST
19044: LIST
19045: PUSH
19046: LD_INT 1
19048: PUSH
19049: LD_INT 2
19051: PUSH
19052: EMPTY
19053: LIST
19054: LIST
19055: PUSH
19056: LD_INT 0
19058: PUSH
19059: LD_INT 2
19061: PUSH
19062: EMPTY
19063: LIST
19064: LIST
19065: PUSH
19066: LD_INT 1
19068: NEG
19069: PUSH
19070: LD_INT 1
19072: PUSH
19073: EMPTY
19074: LIST
19075: LIST
19076: PUSH
19077: LD_INT 1
19079: NEG
19080: PUSH
19081: LD_INT 3
19083: NEG
19084: PUSH
19085: EMPTY
19086: LIST
19087: LIST
19088: PUSH
19089: LD_INT 0
19091: PUSH
19092: LD_INT 3
19094: NEG
19095: PUSH
19096: EMPTY
19097: LIST
19098: LIST
19099: PUSH
19100: LD_INT 1
19102: PUSH
19103: LD_INT 2
19105: NEG
19106: PUSH
19107: EMPTY
19108: LIST
19109: LIST
19110: PUSH
19111: EMPTY
19112: LIST
19113: LIST
19114: LIST
19115: LIST
19116: LIST
19117: LIST
19118: LIST
19119: LIST
19120: LIST
19121: LIST
19122: LIST
19123: LIST
19124: LIST
19125: LIST
19126: LIST
19127: LIST
19128: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
19129: LD_ADDR_VAR 0 15
19133: PUSH
19134: LD_INT 0
19136: PUSH
19137: LD_INT 0
19139: PUSH
19140: EMPTY
19141: LIST
19142: LIST
19143: PUSH
19144: LD_INT 0
19146: PUSH
19147: LD_INT 1
19149: NEG
19150: PUSH
19151: EMPTY
19152: LIST
19153: LIST
19154: PUSH
19155: LD_INT 1
19157: PUSH
19158: LD_INT 0
19160: PUSH
19161: EMPTY
19162: LIST
19163: LIST
19164: PUSH
19165: LD_INT 1
19167: PUSH
19168: LD_INT 1
19170: PUSH
19171: EMPTY
19172: LIST
19173: LIST
19174: PUSH
19175: LD_INT 0
19177: PUSH
19178: LD_INT 1
19180: PUSH
19181: EMPTY
19182: LIST
19183: LIST
19184: PUSH
19185: LD_INT 1
19187: NEG
19188: PUSH
19189: LD_INT 0
19191: PUSH
19192: EMPTY
19193: LIST
19194: LIST
19195: PUSH
19196: LD_INT 1
19198: NEG
19199: PUSH
19200: LD_INT 1
19202: NEG
19203: PUSH
19204: EMPTY
19205: LIST
19206: LIST
19207: PUSH
19208: LD_INT 1
19210: PUSH
19211: LD_INT 1
19213: NEG
19214: PUSH
19215: EMPTY
19216: LIST
19217: LIST
19218: PUSH
19219: LD_INT 2
19221: PUSH
19222: LD_INT 0
19224: PUSH
19225: EMPTY
19226: LIST
19227: LIST
19228: PUSH
19229: LD_INT 2
19231: PUSH
19232: LD_INT 1
19234: PUSH
19235: EMPTY
19236: LIST
19237: LIST
19238: PUSH
19239: LD_INT 1
19241: NEG
19242: PUSH
19243: LD_INT 1
19245: PUSH
19246: EMPTY
19247: LIST
19248: LIST
19249: PUSH
19250: LD_INT 2
19252: NEG
19253: PUSH
19254: LD_INT 0
19256: PUSH
19257: EMPTY
19258: LIST
19259: LIST
19260: PUSH
19261: LD_INT 2
19263: NEG
19264: PUSH
19265: LD_INT 1
19267: NEG
19268: PUSH
19269: EMPTY
19270: LIST
19271: LIST
19272: PUSH
19273: LD_INT 2
19275: PUSH
19276: LD_INT 1
19278: NEG
19279: PUSH
19280: EMPTY
19281: LIST
19282: LIST
19283: PUSH
19284: LD_INT 3
19286: PUSH
19287: LD_INT 0
19289: PUSH
19290: EMPTY
19291: LIST
19292: LIST
19293: PUSH
19294: LD_INT 3
19296: PUSH
19297: LD_INT 1
19299: PUSH
19300: EMPTY
19301: LIST
19302: LIST
19303: PUSH
19304: EMPTY
19305: LIST
19306: LIST
19307: LIST
19308: LIST
19309: LIST
19310: LIST
19311: LIST
19312: LIST
19313: LIST
19314: LIST
19315: LIST
19316: LIST
19317: LIST
19318: LIST
19319: LIST
19320: LIST
19321: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
19322: LD_ADDR_VAR 0 16
19326: PUSH
19327: LD_INT 0
19329: PUSH
19330: LD_INT 0
19332: PUSH
19333: EMPTY
19334: LIST
19335: LIST
19336: PUSH
19337: LD_INT 0
19339: PUSH
19340: LD_INT 1
19342: NEG
19343: PUSH
19344: EMPTY
19345: LIST
19346: LIST
19347: PUSH
19348: LD_INT 1
19350: PUSH
19351: LD_INT 0
19353: PUSH
19354: EMPTY
19355: LIST
19356: LIST
19357: PUSH
19358: LD_INT 1
19360: PUSH
19361: LD_INT 1
19363: PUSH
19364: EMPTY
19365: LIST
19366: LIST
19367: PUSH
19368: LD_INT 0
19370: PUSH
19371: LD_INT 1
19373: PUSH
19374: EMPTY
19375: LIST
19376: LIST
19377: PUSH
19378: LD_INT 1
19380: NEG
19381: PUSH
19382: LD_INT 0
19384: PUSH
19385: EMPTY
19386: LIST
19387: LIST
19388: PUSH
19389: LD_INT 1
19391: NEG
19392: PUSH
19393: LD_INT 1
19395: NEG
19396: PUSH
19397: EMPTY
19398: LIST
19399: LIST
19400: PUSH
19401: LD_INT 1
19403: NEG
19404: PUSH
19405: LD_INT 2
19407: NEG
19408: PUSH
19409: EMPTY
19410: LIST
19411: LIST
19412: PUSH
19413: LD_INT 2
19415: PUSH
19416: LD_INT 1
19418: PUSH
19419: EMPTY
19420: LIST
19421: LIST
19422: PUSH
19423: LD_INT 2
19425: PUSH
19426: LD_INT 2
19428: PUSH
19429: EMPTY
19430: LIST
19431: LIST
19432: PUSH
19433: LD_INT 1
19435: PUSH
19436: LD_INT 2
19438: PUSH
19439: EMPTY
19440: LIST
19441: LIST
19442: PUSH
19443: LD_INT 2
19445: NEG
19446: PUSH
19447: LD_INT 1
19449: NEG
19450: PUSH
19451: EMPTY
19452: LIST
19453: LIST
19454: PUSH
19455: LD_INT 2
19457: NEG
19458: PUSH
19459: LD_INT 2
19461: NEG
19462: PUSH
19463: EMPTY
19464: LIST
19465: LIST
19466: PUSH
19467: LD_INT 3
19469: PUSH
19470: LD_INT 2
19472: PUSH
19473: EMPTY
19474: LIST
19475: LIST
19476: PUSH
19477: LD_INT 3
19479: PUSH
19480: LD_INT 3
19482: PUSH
19483: EMPTY
19484: LIST
19485: LIST
19486: PUSH
19487: LD_INT 2
19489: PUSH
19490: LD_INT 3
19492: PUSH
19493: EMPTY
19494: LIST
19495: LIST
19496: PUSH
19497: EMPTY
19498: LIST
19499: LIST
19500: LIST
19501: LIST
19502: LIST
19503: LIST
19504: LIST
19505: LIST
19506: LIST
19507: LIST
19508: LIST
19509: LIST
19510: LIST
19511: LIST
19512: LIST
19513: LIST
19514: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
19515: LD_ADDR_VAR 0 17
19519: PUSH
19520: LD_INT 0
19522: PUSH
19523: LD_INT 0
19525: PUSH
19526: EMPTY
19527: LIST
19528: LIST
19529: PUSH
19530: LD_INT 0
19532: PUSH
19533: LD_INT 1
19535: NEG
19536: PUSH
19537: EMPTY
19538: LIST
19539: LIST
19540: PUSH
19541: LD_INT 1
19543: PUSH
19544: LD_INT 0
19546: PUSH
19547: EMPTY
19548: LIST
19549: LIST
19550: PUSH
19551: LD_INT 1
19553: PUSH
19554: LD_INT 1
19556: PUSH
19557: EMPTY
19558: LIST
19559: LIST
19560: PUSH
19561: LD_INT 0
19563: PUSH
19564: LD_INT 1
19566: PUSH
19567: EMPTY
19568: LIST
19569: LIST
19570: PUSH
19571: LD_INT 1
19573: NEG
19574: PUSH
19575: LD_INT 0
19577: PUSH
19578: EMPTY
19579: LIST
19580: LIST
19581: PUSH
19582: LD_INT 1
19584: NEG
19585: PUSH
19586: LD_INT 1
19588: NEG
19589: PUSH
19590: EMPTY
19591: LIST
19592: LIST
19593: PUSH
19594: LD_INT 1
19596: NEG
19597: PUSH
19598: LD_INT 2
19600: NEG
19601: PUSH
19602: EMPTY
19603: LIST
19604: LIST
19605: PUSH
19606: LD_INT 0
19608: PUSH
19609: LD_INT 2
19611: NEG
19612: PUSH
19613: EMPTY
19614: LIST
19615: LIST
19616: PUSH
19617: LD_INT 1
19619: PUSH
19620: LD_INT 1
19622: NEG
19623: PUSH
19624: EMPTY
19625: LIST
19626: LIST
19627: PUSH
19628: LD_INT 2
19630: PUSH
19631: LD_INT 0
19633: PUSH
19634: EMPTY
19635: LIST
19636: LIST
19637: PUSH
19638: LD_INT 2
19640: PUSH
19641: LD_INT 1
19643: PUSH
19644: EMPTY
19645: LIST
19646: LIST
19647: PUSH
19648: LD_INT 2
19650: PUSH
19651: LD_INT 2
19653: PUSH
19654: EMPTY
19655: LIST
19656: LIST
19657: PUSH
19658: LD_INT 1
19660: PUSH
19661: LD_INT 2
19663: PUSH
19664: EMPTY
19665: LIST
19666: LIST
19667: PUSH
19668: LD_INT 0
19670: PUSH
19671: LD_INT 2
19673: PUSH
19674: EMPTY
19675: LIST
19676: LIST
19677: PUSH
19678: LD_INT 1
19680: NEG
19681: PUSH
19682: LD_INT 1
19684: PUSH
19685: EMPTY
19686: LIST
19687: LIST
19688: PUSH
19689: LD_INT 2
19691: NEG
19692: PUSH
19693: LD_INT 0
19695: PUSH
19696: EMPTY
19697: LIST
19698: LIST
19699: PUSH
19700: LD_INT 2
19702: NEG
19703: PUSH
19704: LD_INT 1
19706: NEG
19707: PUSH
19708: EMPTY
19709: LIST
19710: LIST
19711: PUSH
19712: LD_INT 2
19714: NEG
19715: PUSH
19716: LD_INT 2
19718: NEG
19719: PUSH
19720: EMPTY
19721: LIST
19722: LIST
19723: PUSH
19724: EMPTY
19725: LIST
19726: LIST
19727: LIST
19728: LIST
19729: LIST
19730: LIST
19731: LIST
19732: LIST
19733: LIST
19734: LIST
19735: LIST
19736: LIST
19737: LIST
19738: LIST
19739: LIST
19740: LIST
19741: LIST
19742: LIST
19743: LIST
19744: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
19745: LD_ADDR_VAR 0 18
19749: PUSH
19750: LD_INT 0
19752: PUSH
19753: LD_INT 0
19755: PUSH
19756: EMPTY
19757: LIST
19758: LIST
19759: PUSH
19760: LD_INT 0
19762: PUSH
19763: LD_INT 1
19765: NEG
19766: PUSH
19767: EMPTY
19768: LIST
19769: LIST
19770: PUSH
19771: LD_INT 1
19773: PUSH
19774: LD_INT 0
19776: PUSH
19777: EMPTY
19778: LIST
19779: LIST
19780: PUSH
19781: LD_INT 1
19783: PUSH
19784: LD_INT 1
19786: PUSH
19787: EMPTY
19788: LIST
19789: LIST
19790: PUSH
19791: LD_INT 0
19793: PUSH
19794: LD_INT 1
19796: PUSH
19797: EMPTY
19798: LIST
19799: LIST
19800: PUSH
19801: LD_INT 1
19803: NEG
19804: PUSH
19805: LD_INT 0
19807: PUSH
19808: EMPTY
19809: LIST
19810: LIST
19811: PUSH
19812: LD_INT 1
19814: NEG
19815: PUSH
19816: LD_INT 1
19818: NEG
19819: PUSH
19820: EMPTY
19821: LIST
19822: LIST
19823: PUSH
19824: LD_INT 1
19826: NEG
19827: PUSH
19828: LD_INT 2
19830: NEG
19831: PUSH
19832: EMPTY
19833: LIST
19834: LIST
19835: PUSH
19836: LD_INT 0
19838: PUSH
19839: LD_INT 2
19841: NEG
19842: PUSH
19843: EMPTY
19844: LIST
19845: LIST
19846: PUSH
19847: LD_INT 1
19849: PUSH
19850: LD_INT 1
19852: NEG
19853: PUSH
19854: EMPTY
19855: LIST
19856: LIST
19857: PUSH
19858: LD_INT 2
19860: PUSH
19861: LD_INT 0
19863: PUSH
19864: EMPTY
19865: LIST
19866: LIST
19867: PUSH
19868: LD_INT 2
19870: PUSH
19871: LD_INT 1
19873: PUSH
19874: EMPTY
19875: LIST
19876: LIST
19877: PUSH
19878: LD_INT 2
19880: PUSH
19881: LD_INT 2
19883: PUSH
19884: EMPTY
19885: LIST
19886: LIST
19887: PUSH
19888: LD_INT 1
19890: PUSH
19891: LD_INT 2
19893: PUSH
19894: EMPTY
19895: LIST
19896: LIST
19897: PUSH
19898: LD_INT 0
19900: PUSH
19901: LD_INT 2
19903: PUSH
19904: EMPTY
19905: LIST
19906: LIST
19907: PUSH
19908: LD_INT 1
19910: NEG
19911: PUSH
19912: LD_INT 1
19914: PUSH
19915: EMPTY
19916: LIST
19917: LIST
19918: PUSH
19919: LD_INT 2
19921: NEG
19922: PUSH
19923: LD_INT 0
19925: PUSH
19926: EMPTY
19927: LIST
19928: LIST
19929: PUSH
19930: LD_INT 2
19932: NEG
19933: PUSH
19934: LD_INT 1
19936: NEG
19937: PUSH
19938: EMPTY
19939: LIST
19940: LIST
19941: PUSH
19942: LD_INT 2
19944: NEG
19945: PUSH
19946: LD_INT 2
19948: NEG
19949: PUSH
19950: EMPTY
19951: LIST
19952: LIST
19953: PUSH
19954: EMPTY
19955: LIST
19956: LIST
19957: LIST
19958: LIST
19959: LIST
19960: LIST
19961: LIST
19962: LIST
19963: LIST
19964: LIST
19965: LIST
19966: LIST
19967: LIST
19968: LIST
19969: LIST
19970: LIST
19971: LIST
19972: LIST
19973: LIST
19974: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
19975: LD_ADDR_VAR 0 19
19979: PUSH
19980: LD_INT 0
19982: PUSH
19983: LD_INT 0
19985: PUSH
19986: EMPTY
19987: LIST
19988: LIST
19989: PUSH
19990: LD_INT 0
19992: PUSH
19993: LD_INT 1
19995: NEG
19996: PUSH
19997: EMPTY
19998: LIST
19999: LIST
20000: PUSH
20001: LD_INT 1
20003: PUSH
20004: LD_INT 0
20006: PUSH
20007: EMPTY
20008: LIST
20009: LIST
20010: PUSH
20011: LD_INT 1
20013: PUSH
20014: LD_INT 1
20016: PUSH
20017: EMPTY
20018: LIST
20019: LIST
20020: PUSH
20021: LD_INT 0
20023: PUSH
20024: LD_INT 1
20026: PUSH
20027: EMPTY
20028: LIST
20029: LIST
20030: PUSH
20031: LD_INT 1
20033: NEG
20034: PUSH
20035: LD_INT 0
20037: PUSH
20038: EMPTY
20039: LIST
20040: LIST
20041: PUSH
20042: LD_INT 1
20044: NEG
20045: PUSH
20046: LD_INT 1
20048: NEG
20049: PUSH
20050: EMPTY
20051: LIST
20052: LIST
20053: PUSH
20054: LD_INT 1
20056: NEG
20057: PUSH
20058: LD_INT 2
20060: NEG
20061: PUSH
20062: EMPTY
20063: LIST
20064: LIST
20065: PUSH
20066: LD_INT 0
20068: PUSH
20069: LD_INT 2
20071: NEG
20072: PUSH
20073: EMPTY
20074: LIST
20075: LIST
20076: PUSH
20077: LD_INT 1
20079: PUSH
20080: LD_INT 1
20082: NEG
20083: PUSH
20084: EMPTY
20085: LIST
20086: LIST
20087: PUSH
20088: LD_INT 2
20090: PUSH
20091: LD_INT 0
20093: PUSH
20094: EMPTY
20095: LIST
20096: LIST
20097: PUSH
20098: LD_INT 2
20100: PUSH
20101: LD_INT 1
20103: PUSH
20104: EMPTY
20105: LIST
20106: LIST
20107: PUSH
20108: LD_INT 2
20110: PUSH
20111: LD_INT 2
20113: PUSH
20114: EMPTY
20115: LIST
20116: LIST
20117: PUSH
20118: LD_INT 1
20120: PUSH
20121: LD_INT 2
20123: PUSH
20124: EMPTY
20125: LIST
20126: LIST
20127: PUSH
20128: LD_INT 0
20130: PUSH
20131: LD_INT 2
20133: PUSH
20134: EMPTY
20135: LIST
20136: LIST
20137: PUSH
20138: LD_INT 1
20140: NEG
20141: PUSH
20142: LD_INT 1
20144: PUSH
20145: EMPTY
20146: LIST
20147: LIST
20148: PUSH
20149: LD_INT 2
20151: NEG
20152: PUSH
20153: LD_INT 0
20155: PUSH
20156: EMPTY
20157: LIST
20158: LIST
20159: PUSH
20160: LD_INT 2
20162: NEG
20163: PUSH
20164: LD_INT 1
20166: NEG
20167: PUSH
20168: EMPTY
20169: LIST
20170: LIST
20171: PUSH
20172: LD_INT 2
20174: NEG
20175: PUSH
20176: LD_INT 2
20178: NEG
20179: PUSH
20180: EMPTY
20181: LIST
20182: LIST
20183: PUSH
20184: EMPTY
20185: LIST
20186: LIST
20187: LIST
20188: LIST
20189: LIST
20190: LIST
20191: LIST
20192: LIST
20193: LIST
20194: LIST
20195: LIST
20196: LIST
20197: LIST
20198: LIST
20199: LIST
20200: LIST
20201: LIST
20202: LIST
20203: LIST
20204: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
20205: LD_ADDR_VAR 0 20
20209: PUSH
20210: LD_INT 0
20212: PUSH
20213: LD_INT 0
20215: PUSH
20216: EMPTY
20217: LIST
20218: LIST
20219: PUSH
20220: LD_INT 0
20222: PUSH
20223: LD_INT 1
20225: NEG
20226: PUSH
20227: EMPTY
20228: LIST
20229: LIST
20230: PUSH
20231: LD_INT 1
20233: PUSH
20234: LD_INT 0
20236: PUSH
20237: EMPTY
20238: LIST
20239: LIST
20240: PUSH
20241: LD_INT 1
20243: PUSH
20244: LD_INT 1
20246: PUSH
20247: EMPTY
20248: LIST
20249: LIST
20250: PUSH
20251: LD_INT 0
20253: PUSH
20254: LD_INT 1
20256: PUSH
20257: EMPTY
20258: LIST
20259: LIST
20260: PUSH
20261: LD_INT 1
20263: NEG
20264: PUSH
20265: LD_INT 0
20267: PUSH
20268: EMPTY
20269: LIST
20270: LIST
20271: PUSH
20272: LD_INT 1
20274: NEG
20275: PUSH
20276: LD_INT 1
20278: NEG
20279: PUSH
20280: EMPTY
20281: LIST
20282: LIST
20283: PUSH
20284: LD_INT 1
20286: NEG
20287: PUSH
20288: LD_INT 2
20290: NEG
20291: PUSH
20292: EMPTY
20293: LIST
20294: LIST
20295: PUSH
20296: LD_INT 0
20298: PUSH
20299: LD_INT 2
20301: NEG
20302: PUSH
20303: EMPTY
20304: LIST
20305: LIST
20306: PUSH
20307: LD_INT 1
20309: PUSH
20310: LD_INT 1
20312: NEG
20313: PUSH
20314: EMPTY
20315: LIST
20316: LIST
20317: PUSH
20318: LD_INT 2
20320: PUSH
20321: LD_INT 0
20323: PUSH
20324: EMPTY
20325: LIST
20326: LIST
20327: PUSH
20328: LD_INT 2
20330: PUSH
20331: LD_INT 1
20333: PUSH
20334: EMPTY
20335: LIST
20336: LIST
20337: PUSH
20338: LD_INT 2
20340: PUSH
20341: LD_INT 2
20343: PUSH
20344: EMPTY
20345: LIST
20346: LIST
20347: PUSH
20348: LD_INT 1
20350: PUSH
20351: LD_INT 2
20353: PUSH
20354: EMPTY
20355: LIST
20356: LIST
20357: PUSH
20358: LD_INT 0
20360: PUSH
20361: LD_INT 2
20363: PUSH
20364: EMPTY
20365: LIST
20366: LIST
20367: PUSH
20368: LD_INT 1
20370: NEG
20371: PUSH
20372: LD_INT 1
20374: PUSH
20375: EMPTY
20376: LIST
20377: LIST
20378: PUSH
20379: LD_INT 2
20381: NEG
20382: PUSH
20383: LD_INT 0
20385: PUSH
20386: EMPTY
20387: LIST
20388: LIST
20389: PUSH
20390: LD_INT 2
20392: NEG
20393: PUSH
20394: LD_INT 1
20396: NEG
20397: PUSH
20398: EMPTY
20399: LIST
20400: LIST
20401: PUSH
20402: LD_INT 2
20404: NEG
20405: PUSH
20406: LD_INT 2
20408: NEG
20409: PUSH
20410: EMPTY
20411: LIST
20412: LIST
20413: PUSH
20414: EMPTY
20415: LIST
20416: LIST
20417: LIST
20418: LIST
20419: LIST
20420: LIST
20421: LIST
20422: LIST
20423: LIST
20424: LIST
20425: LIST
20426: LIST
20427: LIST
20428: LIST
20429: LIST
20430: LIST
20431: LIST
20432: LIST
20433: LIST
20434: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
20435: LD_ADDR_VAR 0 21
20439: PUSH
20440: LD_INT 0
20442: PUSH
20443: LD_INT 0
20445: PUSH
20446: EMPTY
20447: LIST
20448: LIST
20449: PUSH
20450: LD_INT 0
20452: PUSH
20453: LD_INT 1
20455: NEG
20456: PUSH
20457: EMPTY
20458: LIST
20459: LIST
20460: PUSH
20461: LD_INT 1
20463: PUSH
20464: LD_INT 0
20466: PUSH
20467: EMPTY
20468: LIST
20469: LIST
20470: PUSH
20471: LD_INT 1
20473: PUSH
20474: LD_INT 1
20476: PUSH
20477: EMPTY
20478: LIST
20479: LIST
20480: PUSH
20481: LD_INT 0
20483: PUSH
20484: LD_INT 1
20486: PUSH
20487: EMPTY
20488: LIST
20489: LIST
20490: PUSH
20491: LD_INT 1
20493: NEG
20494: PUSH
20495: LD_INT 0
20497: PUSH
20498: EMPTY
20499: LIST
20500: LIST
20501: PUSH
20502: LD_INT 1
20504: NEG
20505: PUSH
20506: LD_INT 1
20508: NEG
20509: PUSH
20510: EMPTY
20511: LIST
20512: LIST
20513: PUSH
20514: LD_INT 1
20516: NEG
20517: PUSH
20518: LD_INT 2
20520: NEG
20521: PUSH
20522: EMPTY
20523: LIST
20524: LIST
20525: PUSH
20526: LD_INT 0
20528: PUSH
20529: LD_INT 2
20531: NEG
20532: PUSH
20533: EMPTY
20534: LIST
20535: LIST
20536: PUSH
20537: LD_INT 1
20539: PUSH
20540: LD_INT 1
20542: NEG
20543: PUSH
20544: EMPTY
20545: LIST
20546: LIST
20547: PUSH
20548: LD_INT 2
20550: PUSH
20551: LD_INT 0
20553: PUSH
20554: EMPTY
20555: LIST
20556: LIST
20557: PUSH
20558: LD_INT 2
20560: PUSH
20561: LD_INT 1
20563: PUSH
20564: EMPTY
20565: LIST
20566: LIST
20567: PUSH
20568: LD_INT 2
20570: PUSH
20571: LD_INT 2
20573: PUSH
20574: EMPTY
20575: LIST
20576: LIST
20577: PUSH
20578: LD_INT 1
20580: PUSH
20581: LD_INT 2
20583: PUSH
20584: EMPTY
20585: LIST
20586: LIST
20587: PUSH
20588: LD_INT 0
20590: PUSH
20591: LD_INT 2
20593: PUSH
20594: EMPTY
20595: LIST
20596: LIST
20597: PUSH
20598: LD_INT 1
20600: NEG
20601: PUSH
20602: LD_INT 1
20604: PUSH
20605: EMPTY
20606: LIST
20607: LIST
20608: PUSH
20609: LD_INT 2
20611: NEG
20612: PUSH
20613: LD_INT 0
20615: PUSH
20616: EMPTY
20617: LIST
20618: LIST
20619: PUSH
20620: LD_INT 2
20622: NEG
20623: PUSH
20624: LD_INT 1
20626: NEG
20627: PUSH
20628: EMPTY
20629: LIST
20630: LIST
20631: PUSH
20632: LD_INT 2
20634: NEG
20635: PUSH
20636: LD_INT 2
20638: NEG
20639: PUSH
20640: EMPTY
20641: LIST
20642: LIST
20643: PUSH
20644: EMPTY
20645: LIST
20646: LIST
20647: LIST
20648: LIST
20649: LIST
20650: LIST
20651: LIST
20652: LIST
20653: LIST
20654: LIST
20655: LIST
20656: LIST
20657: LIST
20658: LIST
20659: LIST
20660: LIST
20661: LIST
20662: LIST
20663: LIST
20664: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
20665: LD_ADDR_VAR 0 22
20669: PUSH
20670: LD_INT 0
20672: PUSH
20673: LD_INT 0
20675: PUSH
20676: EMPTY
20677: LIST
20678: LIST
20679: PUSH
20680: LD_INT 0
20682: PUSH
20683: LD_INT 1
20685: NEG
20686: PUSH
20687: EMPTY
20688: LIST
20689: LIST
20690: PUSH
20691: LD_INT 1
20693: PUSH
20694: LD_INT 0
20696: PUSH
20697: EMPTY
20698: LIST
20699: LIST
20700: PUSH
20701: LD_INT 1
20703: PUSH
20704: LD_INT 1
20706: PUSH
20707: EMPTY
20708: LIST
20709: LIST
20710: PUSH
20711: LD_INT 0
20713: PUSH
20714: LD_INT 1
20716: PUSH
20717: EMPTY
20718: LIST
20719: LIST
20720: PUSH
20721: LD_INT 1
20723: NEG
20724: PUSH
20725: LD_INT 0
20727: PUSH
20728: EMPTY
20729: LIST
20730: LIST
20731: PUSH
20732: LD_INT 1
20734: NEG
20735: PUSH
20736: LD_INT 1
20738: NEG
20739: PUSH
20740: EMPTY
20741: LIST
20742: LIST
20743: PUSH
20744: LD_INT 1
20746: NEG
20747: PUSH
20748: LD_INT 2
20750: NEG
20751: PUSH
20752: EMPTY
20753: LIST
20754: LIST
20755: PUSH
20756: LD_INT 0
20758: PUSH
20759: LD_INT 2
20761: NEG
20762: PUSH
20763: EMPTY
20764: LIST
20765: LIST
20766: PUSH
20767: LD_INT 1
20769: PUSH
20770: LD_INT 1
20772: NEG
20773: PUSH
20774: EMPTY
20775: LIST
20776: LIST
20777: PUSH
20778: LD_INT 2
20780: PUSH
20781: LD_INT 0
20783: PUSH
20784: EMPTY
20785: LIST
20786: LIST
20787: PUSH
20788: LD_INT 2
20790: PUSH
20791: LD_INT 1
20793: PUSH
20794: EMPTY
20795: LIST
20796: LIST
20797: PUSH
20798: LD_INT 2
20800: PUSH
20801: LD_INT 2
20803: PUSH
20804: EMPTY
20805: LIST
20806: LIST
20807: PUSH
20808: LD_INT 1
20810: PUSH
20811: LD_INT 2
20813: PUSH
20814: EMPTY
20815: LIST
20816: LIST
20817: PUSH
20818: LD_INT 0
20820: PUSH
20821: LD_INT 2
20823: PUSH
20824: EMPTY
20825: LIST
20826: LIST
20827: PUSH
20828: LD_INT 1
20830: NEG
20831: PUSH
20832: LD_INT 1
20834: PUSH
20835: EMPTY
20836: LIST
20837: LIST
20838: PUSH
20839: LD_INT 2
20841: NEG
20842: PUSH
20843: LD_INT 0
20845: PUSH
20846: EMPTY
20847: LIST
20848: LIST
20849: PUSH
20850: LD_INT 2
20852: NEG
20853: PUSH
20854: LD_INT 1
20856: NEG
20857: PUSH
20858: EMPTY
20859: LIST
20860: LIST
20861: PUSH
20862: LD_INT 2
20864: NEG
20865: PUSH
20866: LD_INT 2
20868: NEG
20869: PUSH
20870: EMPTY
20871: LIST
20872: LIST
20873: PUSH
20874: EMPTY
20875: LIST
20876: LIST
20877: LIST
20878: LIST
20879: LIST
20880: LIST
20881: LIST
20882: LIST
20883: LIST
20884: LIST
20885: LIST
20886: LIST
20887: LIST
20888: LIST
20889: LIST
20890: LIST
20891: LIST
20892: LIST
20893: LIST
20894: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
20895: LD_ADDR_VAR 0 23
20899: PUSH
20900: LD_INT 0
20902: PUSH
20903: LD_INT 0
20905: PUSH
20906: EMPTY
20907: LIST
20908: LIST
20909: PUSH
20910: LD_INT 0
20912: PUSH
20913: LD_INT 1
20915: NEG
20916: PUSH
20917: EMPTY
20918: LIST
20919: LIST
20920: PUSH
20921: LD_INT 1
20923: PUSH
20924: LD_INT 0
20926: PUSH
20927: EMPTY
20928: LIST
20929: LIST
20930: PUSH
20931: LD_INT 1
20933: PUSH
20934: LD_INT 1
20936: PUSH
20937: EMPTY
20938: LIST
20939: LIST
20940: PUSH
20941: LD_INT 0
20943: PUSH
20944: LD_INT 1
20946: PUSH
20947: EMPTY
20948: LIST
20949: LIST
20950: PUSH
20951: LD_INT 1
20953: NEG
20954: PUSH
20955: LD_INT 0
20957: PUSH
20958: EMPTY
20959: LIST
20960: LIST
20961: PUSH
20962: LD_INT 1
20964: NEG
20965: PUSH
20966: LD_INT 1
20968: NEG
20969: PUSH
20970: EMPTY
20971: LIST
20972: LIST
20973: PUSH
20974: LD_INT 1
20976: NEG
20977: PUSH
20978: LD_INT 2
20980: NEG
20981: PUSH
20982: EMPTY
20983: LIST
20984: LIST
20985: PUSH
20986: LD_INT 0
20988: PUSH
20989: LD_INT 2
20991: NEG
20992: PUSH
20993: EMPTY
20994: LIST
20995: LIST
20996: PUSH
20997: LD_INT 1
20999: PUSH
21000: LD_INT 1
21002: NEG
21003: PUSH
21004: EMPTY
21005: LIST
21006: LIST
21007: PUSH
21008: LD_INT 2
21010: PUSH
21011: LD_INT 0
21013: PUSH
21014: EMPTY
21015: LIST
21016: LIST
21017: PUSH
21018: LD_INT 2
21020: PUSH
21021: LD_INT 1
21023: PUSH
21024: EMPTY
21025: LIST
21026: LIST
21027: PUSH
21028: LD_INT 2
21030: PUSH
21031: LD_INT 2
21033: PUSH
21034: EMPTY
21035: LIST
21036: LIST
21037: PUSH
21038: LD_INT 1
21040: PUSH
21041: LD_INT 2
21043: PUSH
21044: EMPTY
21045: LIST
21046: LIST
21047: PUSH
21048: LD_INT 0
21050: PUSH
21051: LD_INT 2
21053: PUSH
21054: EMPTY
21055: LIST
21056: LIST
21057: PUSH
21058: LD_INT 1
21060: NEG
21061: PUSH
21062: LD_INT 1
21064: PUSH
21065: EMPTY
21066: LIST
21067: LIST
21068: PUSH
21069: LD_INT 2
21071: NEG
21072: PUSH
21073: LD_INT 0
21075: PUSH
21076: EMPTY
21077: LIST
21078: LIST
21079: PUSH
21080: LD_INT 2
21082: NEG
21083: PUSH
21084: LD_INT 1
21086: NEG
21087: PUSH
21088: EMPTY
21089: LIST
21090: LIST
21091: PUSH
21092: LD_INT 2
21094: NEG
21095: PUSH
21096: LD_INT 2
21098: NEG
21099: PUSH
21100: EMPTY
21101: LIST
21102: LIST
21103: PUSH
21104: LD_INT 2
21106: NEG
21107: PUSH
21108: LD_INT 3
21110: NEG
21111: PUSH
21112: EMPTY
21113: LIST
21114: LIST
21115: PUSH
21116: LD_INT 1
21118: NEG
21119: PUSH
21120: LD_INT 3
21122: NEG
21123: PUSH
21124: EMPTY
21125: LIST
21126: LIST
21127: PUSH
21128: LD_INT 1
21130: PUSH
21131: LD_INT 2
21133: NEG
21134: PUSH
21135: EMPTY
21136: LIST
21137: LIST
21138: PUSH
21139: LD_INT 2
21141: PUSH
21142: LD_INT 1
21144: NEG
21145: PUSH
21146: EMPTY
21147: LIST
21148: LIST
21149: PUSH
21150: EMPTY
21151: LIST
21152: LIST
21153: LIST
21154: LIST
21155: LIST
21156: LIST
21157: LIST
21158: LIST
21159: LIST
21160: LIST
21161: LIST
21162: LIST
21163: LIST
21164: LIST
21165: LIST
21166: LIST
21167: LIST
21168: LIST
21169: LIST
21170: LIST
21171: LIST
21172: LIST
21173: LIST
21174: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
21175: LD_ADDR_VAR 0 24
21179: PUSH
21180: LD_INT 0
21182: PUSH
21183: LD_INT 0
21185: PUSH
21186: EMPTY
21187: LIST
21188: LIST
21189: PUSH
21190: LD_INT 0
21192: PUSH
21193: LD_INT 1
21195: NEG
21196: PUSH
21197: EMPTY
21198: LIST
21199: LIST
21200: PUSH
21201: LD_INT 1
21203: PUSH
21204: LD_INT 0
21206: PUSH
21207: EMPTY
21208: LIST
21209: LIST
21210: PUSH
21211: LD_INT 1
21213: PUSH
21214: LD_INT 1
21216: PUSH
21217: EMPTY
21218: LIST
21219: LIST
21220: PUSH
21221: LD_INT 0
21223: PUSH
21224: LD_INT 1
21226: PUSH
21227: EMPTY
21228: LIST
21229: LIST
21230: PUSH
21231: LD_INT 1
21233: NEG
21234: PUSH
21235: LD_INT 0
21237: PUSH
21238: EMPTY
21239: LIST
21240: LIST
21241: PUSH
21242: LD_INT 1
21244: NEG
21245: PUSH
21246: LD_INT 1
21248: NEG
21249: PUSH
21250: EMPTY
21251: LIST
21252: LIST
21253: PUSH
21254: LD_INT 1
21256: NEG
21257: PUSH
21258: LD_INT 2
21260: NEG
21261: PUSH
21262: EMPTY
21263: LIST
21264: LIST
21265: PUSH
21266: LD_INT 0
21268: PUSH
21269: LD_INT 2
21271: NEG
21272: PUSH
21273: EMPTY
21274: LIST
21275: LIST
21276: PUSH
21277: LD_INT 1
21279: PUSH
21280: LD_INT 1
21282: NEG
21283: PUSH
21284: EMPTY
21285: LIST
21286: LIST
21287: PUSH
21288: LD_INT 2
21290: PUSH
21291: LD_INT 0
21293: PUSH
21294: EMPTY
21295: LIST
21296: LIST
21297: PUSH
21298: LD_INT 2
21300: PUSH
21301: LD_INT 1
21303: PUSH
21304: EMPTY
21305: LIST
21306: LIST
21307: PUSH
21308: LD_INT 2
21310: PUSH
21311: LD_INT 2
21313: PUSH
21314: EMPTY
21315: LIST
21316: LIST
21317: PUSH
21318: LD_INT 1
21320: PUSH
21321: LD_INT 2
21323: PUSH
21324: EMPTY
21325: LIST
21326: LIST
21327: PUSH
21328: LD_INT 0
21330: PUSH
21331: LD_INT 2
21333: PUSH
21334: EMPTY
21335: LIST
21336: LIST
21337: PUSH
21338: LD_INT 1
21340: NEG
21341: PUSH
21342: LD_INT 1
21344: PUSH
21345: EMPTY
21346: LIST
21347: LIST
21348: PUSH
21349: LD_INT 2
21351: NEG
21352: PUSH
21353: LD_INT 0
21355: PUSH
21356: EMPTY
21357: LIST
21358: LIST
21359: PUSH
21360: LD_INT 2
21362: NEG
21363: PUSH
21364: LD_INT 1
21366: NEG
21367: PUSH
21368: EMPTY
21369: LIST
21370: LIST
21371: PUSH
21372: LD_INT 2
21374: NEG
21375: PUSH
21376: LD_INT 2
21378: NEG
21379: PUSH
21380: EMPTY
21381: LIST
21382: LIST
21383: PUSH
21384: LD_INT 1
21386: PUSH
21387: LD_INT 2
21389: NEG
21390: PUSH
21391: EMPTY
21392: LIST
21393: LIST
21394: PUSH
21395: LD_INT 2
21397: PUSH
21398: LD_INT 1
21400: NEG
21401: PUSH
21402: EMPTY
21403: LIST
21404: LIST
21405: PUSH
21406: LD_INT 3
21408: PUSH
21409: LD_INT 1
21411: PUSH
21412: EMPTY
21413: LIST
21414: LIST
21415: PUSH
21416: LD_INT 3
21418: PUSH
21419: LD_INT 2
21421: PUSH
21422: EMPTY
21423: LIST
21424: LIST
21425: PUSH
21426: EMPTY
21427: LIST
21428: LIST
21429: LIST
21430: LIST
21431: LIST
21432: LIST
21433: LIST
21434: LIST
21435: LIST
21436: LIST
21437: LIST
21438: LIST
21439: LIST
21440: LIST
21441: LIST
21442: LIST
21443: LIST
21444: LIST
21445: LIST
21446: LIST
21447: LIST
21448: LIST
21449: LIST
21450: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
21451: LD_ADDR_VAR 0 25
21455: PUSH
21456: LD_INT 0
21458: PUSH
21459: LD_INT 0
21461: PUSH
21462: EMPTY
21463: LIST
21464: LIST
21465: PUSH
21466: LD_INT 0
21468: PUSH
21469: LD_INT 1
21471: NEG
21472: PUSH
21473: EMPTY
21474: LIST
21475: LIST
21476: PUSH
21477: LD_INT 1
21479: PUSH
21480: LD_INT 0
21482: PUSH
21483: EMPTY
21484: LIST
21485: LIST
21486: PUSH
21487: LD_INT 1
21489: PUSH
21490: LD_INT 1
21492: PUSH
21493: EMPTY
21494: LIST
21495: LIST
21496: PUSH
21497: LD_INT 0
21499: PUSH
21500: LD_INT 1
21502: PUSH
21503: EMPTY
21504: LIST
21505: LIST
21506: PUSH
21507: LD_INT 1
21509: NEG
21510: PUSH
21511: LD_INT 0
21513: PUSH
21514: EMPTY
21515: LIST
21516: LIST
21517: PUSH
21518: LD_INT 1
21520: NEG
21521: PUSH
21522: LD_INT 1
21524: NEG
21525: PUSH
21526: EMPTY
21527: LIST
21528: LIST
21529: PUSH
21530: LD_INT 1
21532: NEG
21533: PUSH
21534: LD_INT 2
21536: NEG
21537: PUSH
21538: EMPTY
21539: LIST
21540: LIST
21541: PUSH
21542: LD_INT 0
21544: PUSH
21545: LD_INT 2
21547: NEG
21548: PUSH
21549: EMPTY
21550: LIST
21551: LIST
21552: PUSH
21553: LD_INT 1
21555: PUSH
21556: LD_INT 1
21558: NEG
21559: PUSH
21560: EMPTY
21561: LIST
21562: LIST
21563: PUSH
21564: LD_INT 2
21566: PUSH
21567: LD_INT 0
21569: PUSH
21570: EMPTY
21571: LIST
21572: LIST
21573: PUSH
21574: LD_INT 2
21576: PUSH
21577: LD_INT 1
21579: PUSH
21580: EMPTY
21581: LIST
21582: LIST
21583: PUSH
21584: LD_INT 2
21586: PUSH
21587: LD_INT 2
21589: PUSH
21590: EMPTY
21591: LIST
21592: LIST
21593: PUSH
21594: LD_INT 1
21596: PUSH
21597: LD_INT 2
21599: PUSH
21600: EMPTY
21601: LIST
21602: LIST
21603: PUSH
21604: LD_INT 0
21606: PUSH
21607: LD_INT 2
21609: PUSH
21610: EMPTY
21611: LIST
21612: LIST
21613: PUSH
21614: LD_INT 1
21616: NEG
21617: PUSH
21618: LD_INT 1
21620: PUSH
21621: EMPTY
21622: LIST
21623: LIST
21624: PUSH
21625: LD_INT 2
21627: NEG
21628: PUSH
21629: LD_INT 0
21631: PUSH
21632: EMPTY
21633: LIST
21634: LIST
21635: PUSH
21636: LD_INT 2
21638: NEG
21639: PUSH
21640: LD_INT 1
21642: NEG
21643: PUSH
21644: EMPTY
21645: LIST
21646: LIST
21647: PUSH
21648: LD_INT 2
21650: NEG
21651: PUSH
21652: LD_INT 2
21654: NEG
21655: PUSH
21656: EMPTY
21657: LIST
21658: LIST
21659: PUSH
21660: LD_INT 3
21662: PUSH
21663: LD_INT 1
21665: PUSH
21666: EMPTY
21667: LIST
21668: LIST
21669: PUSH
21670: LD_INT 3
21672: PUSH
21673: LD_INT 2
21675: PUSH
21676: EMPTY
21677: LIST
21678: LIST
21679: PUSH
21680: LD_INT 2
21682: PUSH
21683: LD_INT 3
21685: PUSH
21686: EMPTY
21687: LIST
21688: LIST
21689: PUSH
21690: LD_INT 1
21692: PUSH
21693: LD_INT 3
21695: PUSH
21696: EMPTY
21697: LIST
21698: LIST
21699: PUSH
21700: EMPTY
21701: LIST
21702: LIST
21703: LIST
21704: LIST
21705: LIST
21706: LIST
21707: LIST
21708: LIST
21709: LIST
21710: LIST
21711: LIST
21712: LIST
21713: LIST
21714: LIST
21715: LIST
21716: LIST
21717: LIST
21718: LIST
21719: LIST
21720: LIST
21721: LIST
21722: LIST
21723: LIST
21724: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
21725: LD_ADDR_VAR 0 26
21729: PUSH
21730: LD_INT 0
21732: PUSH
21733: LD_INT 0
21735: PUSH
21736: EMPTY
21737: LIST
21738: LIST
21739: PUSH
21740: LD_INT 0
21742: PUSH
21743: LD_INT 1
21745: NEG
21746: PUSH
21747: EMPTY
21748: LIST
21749: LIST
21750: PUSH
21751: LD_INT 1
21753: PUSH
21754: LD_INT 0
21756: PUSH
21757: EMPTY
21758: LIST
21759: LIST
21760: PUSH
21761: LD_INT 1
21763: PUSH
21764: LD_INT 1
21766: PUSH
21767: EMPTY
21768: LIST
21769: LIST
21770: PUSH
21771: LD_INT 0
21773: PUSH
21774: LD_INT 1
21776: PUSH
21777: EMPTY
21778: LIST
21779: LIST
21780: PUSH
21781: LD_INT 1
21783: NEG
21784: PUSH
21785: LD_INT 0
21787: PUSH
21788: EMPTY
21789: LIST
21790: LIST
21791: PUSH
21792: LD_INT 1
21794: NEG
21795: PUSH
21796: LD_INT 1
21798: NEG
21799: PUSH
21800: EMPTY
21801: LIST
21802: LIST
21803: PUSH
21804: LD_INT 1
21806: NEG
21807: PUSH
21808: LD_INT 2
21810: NEG
21811: PUSH
21812: EMPTY
21813: LIST
21814: LIST
21815: PUSH
21816: LD_INT 0
21818: PUSH
21819: LD_INT 2
21821: NEG
21822: PUSH
21823: EMPTY
21824: LIST
21825: LIST
21826: PUSH
21827: LD_INT 1
21829: PUSH
21830: LD_INT 1
21832: NEG
21833: PUSH
21834: EMPTY
21835: LIST
21836: LIST
21837: PUSH
21838: LD_INT 2
21840: PUSH
21841: LD_INT 0
21843: PUSH
21844: EMPTY
21845: LIST
21846: LIST
21847: PUSH
21848: LD_INT 2
21850: PUSH
21851: LD_INT 1
21853: PUSH
21854: EMPTY
21855: LIST
21856: LIST
21857: PUSH
21858: LD_INT 2
21860: PUSH
21861: LD_INT 2
21863: PUSH
21864: EMPTY
21865: LIST
21866: LIST
21867: PUSH
21868: LD_INT 1
21870: PUSH
21871: LD_INT 2
21873: PUSH
21874: EMPTY
21875: LIST
21876: LIST
21877: PUSH
21878: LD_INT 0
21880: PUSH
21881: LD_INT 2
21883: PUSH
21884: EMPTY
21885: LIST
21886: LIST
21887: PUSH
21888: LD_INT 1
21890: NEG
21891: PUSH
21892: LD_INT 1
21894: PUSH
21895: EMPTY
21896: LIST
21897: LIST
21898: PUSH
21899: LD_INT 2
21901: NEG
21902: PUSH
21903: LD_INT 0
21905: PUSH
21906: EMPTY
21907: LIST
21908: LIST
21909: PUSH
21910: LD_INT 2
21912: NEG
21913: PUSH
21914: LD_INT 1
21916: NEG
21917: PUSH
21918: EMPTY
21919: LIST
21920: LIST
21921: PUSH
21922: LD_INT 2
21924: NEG
21925: PUSH
21926: LD_INT 2
21928: NEG
21929: PUSH
21930: EMPTY
21931: LIST
21932: LIST
21933: PUSH
21934: LD_INT 2
21936: PUSH
21937: LD_INT 3
21939: PUSH
21940: EMPTY
21941: LIST
21942: LIST
21943: PUSH
21944: LD_INT 1
21946: PUSH
21947: LD_INT 3
21949: PUSH
21950: EMPTY
21951: LIST
21952: LIST
21953: PUSH
21954: LD_INT 1
21956: NEG
21957: PUSH
21958: LD_INT 2
21960: PUSH
21961: EMPTY
21962: LIST
21963: LIST
21964: PUSH
21965: LD_INT 2
21967: NEG
21968: PUSH
21969: LD_INT 1
21971: PUSH
21972: EMPTY
21973: LIST
21974: LIST
21975: PUSH
21976: EMPTY
21977: LIST
21978: LIST
21979: LIST
21980: LIST
21981: LIST
21982: LIST
21983: LIST
21984: LIST
21985: LIST
21986: LIST
21987: LIST
21988: LIST
21989: LIST
21990: LIST
21991: LIST
21992: LIST
21993: LIST
21994: LIST
21995: LIST
21996: LIST
21997: LIST
21998: LIST
21999: LIST
22000: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
22001: LD_ADDR_VAR 0 27
22005: PUSH
22006: LD_INT 0
22008: PUSH
22009: LD_INT 0
22011: PUSH
22012: EMPTY
22013: LIST
22014: LIST
22015: PUSH
22016: LD_INT 0
22018: PUSH
22019: LD_INT 1
22021: NEG
22022: PUSH
22023: EMPTY
22024: LIST
22025: LIST
22026: PUSH
22027: LD_INT 1
22029: PUSH
22030: LD_INT 0
22032: PUSH
22033: EMPTY
22034: LIST
22035: LIST
22036: PUSH
22037: LD_INT 1
22039: PUSH
22040: LD_INT 1
22042: PUSH
22043: EMPTY
22044: LIST
22045: LIST
22046: PUSH
22047: LD_INT 0
22049: PUSH
22050: LD_INT 1
22052: PUSH
22053: EMPTY
22054: LIST
22055: LIST
22056: PUSH
22057: LD_INT 1
22059: NEG
22060: PUSH
22061: LD_INT 0
22063: PUSH
22064: EMPTY
22065: LIST
22066: LIST
22067: PUSH
22068: LD_INT 1
22070: NEG
22071: PUSH
22072: LD_INT 1
22074: NEG
22075: PUSH
22076: EMPTY
22077: LIST
22078: LIST
22079: PUSH
22080: LD_INT 1
22082: NEG
22083: PUSH
22084: LD_INT 2
22086: NEG
22087: PUSH
22088: EMPTY
22089: LIST
22090: LIST
22091: PUSH
22092: LD_INT 0
22094: PUSH
22095: LD_INT 2
22097: NEG
22098: PUSH
22099: EMPTY
22100: LIST
22101: LIST
22102: PUSH
22103: LD_INT 1
22105: PUSH
22106: LD_INT 1
22108: NEG
22109: PUSH
22110: EMPTY
22111: LIST
22112: LIST
22113: PUSH
22114: LD_INT 2
22116: PUSH
22117: LD_INT 0
22119: PUSH
22120: EMPTY
22121: LIST
22122: LIST
22123: PUSH
22124: LD_INT 2
22126: PUSH
22127: LD_INT 1
22129: PUSH
22130: EMPTY
22131: LIST
22132: LIST
22133: PUSH
22134: LD_INT 2
22136: PUSH
22137: LD_INT 2
22139: PUSH
22140: EMPTY
22141: LIST
22142: LIST
22143: PUSH
22144: LD_INT 1
22146: PUSH
22147: LD_INT 2
22149: PUSH
22150: EMPTY
22151: LIST
22152: LIST
22153: PUSH
22154: LD_INT 0
22156: PUSH
22157: LD_INT 2
22159: PUSH
22160: EMPTY
22161: LIST
22162: LIST
22163: PUSH
22164: LD_INT 1
22166: NEG
22167: PUSH
22168: LD_INT 1
22170: PUSH
22171: EMPTY
22172: LIST
22173: LIST
22174: PUSH
22175: LD_INT 2
22177: NEG
22178: PUSH
22179: LD_INT 0
22181: PUSH
22182: EMPTY
22183: LIST
22184: LIST
22185: PUSH
22186: LD_INT 2
22188: NEG
22189: PUSH
22190: LD_INT 1
22192: NEG
22193: PUSH
22194: EMPTY
22195: LIST
22196: LIST
22197: PUSH
22198: LD_INT 2
22200: NEG
22201: PUSH
22202: LD_INT 2
22204: NEG
22205: PUSH
22206: EMPTY
22207: LIST
22208: LIST
22209: PUSH
22210: LD_INT 1
22212: NEG
22213: PUSH
22214: LD_INT 2
22216: PUSH
22217: EMPTY
22218: LIST
22219: LIST
22220: PUSH
22221: LD_INT 2
22223: NEG
22224: PUSH
22225: LD_INT 1
22227: PUSH
22228: EMPTY
22229: LIST
22230: LIST
22231: PUSH
22232: LD_INT 3
22234: NEG
22235: PUSH
22236: LD_INT 1
22238: NEG
22239: PUSH
22240: EMPTY
22241: LIST
22242: LIST
22243: PUSH
22244: LD_INT 3
22246: NEG
22247: PUSH
22248: LD_INT 2
22250: NEG
22251: PUSH
22252: EMPTY
22253: LIST
22254: LIST
22255: PUSH
22256: EMPTY
22257: LIST
22258: LIST
22259: LIST
22260: LIST
22261: LIST
22262: LIST
22263: LIST
22264: LIST
22265: LIST
22266: LIST
22267: LIST
22268: LIST
22269: LIST
22270: LIST
22271: LIST
22272: LIST
22273: LIST
22274: LIST
22275: LIST
22276: LIST
22277: LIST
22278: LIST
22279: LIST
22280: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
22281: LD_ADDR_VAR 0 28
22285: PUSH
22286: LD_INT 0
22288: PUSH
22289: LD_INT 0
22291: PUSH
22292: EMPTY
22293: LIST
22294: LIST
22295: PUSH
22296: LD_INT 0
22298: PUSH
22299: LD_INT 1
22301: NEG
22302: PUSH
22303: EMPTY
22304: LIST
22305: LIST
22306: PUSH
22307: LD_INT 1
22309: PUSH
22310: LD_INT 0
22312: PUSH
22313: EMPTY
22314: LIST
22315: LIST
22316: PUSH
22317: LD_INT 1
22319: PUSH
22320: LD_INT 1
22322: PUSH
22323: EMPTY
22324: LIST
22325: LIST
22326: PUSH
22327: LD_INT 0
22329: PUSH
22330: LD_INT 1
22332: PUSH
22333: EMPTY
22334: LIST
22335: LIST
22336: PUSH
22337: LD_INT 1
22339: NEG
22340: PUSH
22341: LD_INT 0
22343: PUSH
22344: EMPTY
22345: LIST
22346: LIST
22347: PUSH
22348: LD_INT 1
22350: NEG
22351: PUSH
22352: LD_INT 1
22354: NEG
22355: PUSH
22356: EMPTY
22357: LIST
22358: LIST
22359: PUSH
22360: LD_INT 1
22362: NEG
22363: PUSH
22364: LD_INT 2
22366: NEG
22367: PUSH
22368: EMPTY
22369: LIST
22370: LIST
22371: PUSH
22372: LD_INT 0
22374: PUSH
22375: LD_INT 2
22377: NEG
22378: PUSH
22379: EMPTY
22380: LIST
22381: LIST
22382: PUSH
22383: LD_INT 1
22385: PUSH
22386: LD_INT 1
22388: NEG
22389: PUSH
22390: EMPTY
22391: LIST
22392: LIST
22393: PUSH
22394: LD_INT 2
22396: PUSH
22397: LD_INT 0
22399: PUSH
22400: EMPTY
22401: LIST
22402: LIST
22403: PUSH
22404: LD_INT 2
22406: PUSH
22407: LD_INT 1
22409: PUSH
22410: EMPTY
22411: LIST
22412: LIST
22413: PUSH
22414: LD_INT 2
22416: PUSH
22417: LD_INT 2
22419: PUSH
22420: EMPTY
22421: LIST
22422: LIST
22423: PUSH
22424: LD_INT 1
22426: PUSH
22427: LD_INT 2
22429: PUSH
22430: EMPTY
22431: LIST
22432: LIST
22433: PUSH
22434: LD_INT 0
22436: PUSH
22437: LD_INT 2
22439: PUSH
22440: EMPTY
22441: LIST
22442: LIST
22443: PUSH
22444: LD_INT 1
22446: NEG
22447: PUSH
22448: LD_INT 1
22450: PUSH
22451: EMPTY
22452: LIST
22453: LIST
22454: PUSH
22455: LD_INT 2
22457: NEG
22458: PUSH
22459: LD_INT 0
22461: PUSH
22462: EMPTY
22463: LIST
22464: LIST
22465: PUSH
22466: LD_INT 2
22468: NEG
22469: PUSH
22470: LD_INT 1
22472: NEG
22473: PUSH
22474: EMPTY
22475: LIST
22476: LIST
22477: PUSH
22478: LD_INT 2
22480: NEG
22481: PUSH
22482: LD_INT 2
22484: NEG
22485: PUSH
22486: EMPTY
22487: LIST
22488: LIST
22489: PUSH
22490: LD_INT 2
22492: NEG
22493: PUSH
22494: LD_INT 3
22496: NEG
22497: PUSH
22498: EMPTY
22499: LIST
22500: LIST
22501: PUSH
22502: LD_INT 1
22504: NEG
22505: PUSH
22506: LD_INT 3
22508: NEG
22509: PUSH
22510: EMPTY
22511: LIST
22512: LIST
22513: PUSH
22514: LD_INT 3
22516: NEG
22517: PUSH
22518: LD_INT 1
22520: NEG
22521: PUSH
22522: EMPTY
22523: LIST
22524: LIST
22525: PUSH
22526: LD_INT 3
22528: NEG
22529: PUSH
22530: LD_INT 2
22532: NEG
22533: PUSH
22534: EMPTY
22535: LIST
22536: LIST
22537: PUSH
22538: EMPTY
22539: LIST
22540: LIST
22541: LIST
22542: LIST
22543: LIST
22544: LIST
22545: LIST
22546: LIST
22547: LIST
22548: LIST
22549: LIST
22550: LIST
22551: LIST
22552: LIST
22553: LIST
22554: LIST
22555: LIST
22556: LIST
22557: LIST
22558: LIST
22559: LIST
22560: LIST
22561: LIST
22562: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
22563: LD_ADDR_VAR 0 29
22567: PUSH
22568: LD_INT 0
22570: PUSH
22571: LD_INT 0
22573: PUSH
22574: EMPTY
22575: LIST
22576: LIST
22577: PUSH
22578: LD_INT 0
22580: PUSH
22581: LD_INT 1
22583: NEG
22584: PUSH
22585: EMPTY
22586: LIST
22587: LIST
22588: PUSH
22589: LD_INT 1
22591: PUSH
22592: LD_INT 0
22594: PUSH
22595: EMPTY
22596: LIST
22597: LIST
22598: PUSH
22599: LD_INT 1
22601: PUSH
22602: LD_INT 1
22604: PUSH
22605: EMPTY
22606: LIST
22607: LIST
22608: PUSH
22609: LD_INT 0
22611: PUSH
22612: LD_INT 1
22614: PUSH
22615: EMPTY
22616: LIST
22617: LIST
22618: PUSH
22619: LD_INT 1
22621: NEG
22622: PUSH
22623: LD_INT 0
22625: PUSH
22626: EMPTY
22627: LIST
22628: LIST
22629: PUSH
22630: LD_INT 1
22632: NEG
22633: PUSH
22634: LD_INT 1
22636: NEG
22637: PUSH
22638: EMPTY
22639: LIST
22640: LIST
22641: PUSH
22642: LD_INT 1
22644: NEG
22645: PUSH
22646: LD_INT 2
22648: NEG
22649: PUSH
22650: EMPTY
22651: LIST
22652: LIST
22653: PUSH
22654: LD_INT 0
22656: PUSH
22657: LD_INT 2
22659: NEG
22660: PUSH
22661: EMPTY
22662: LIST
22663: LIST
22664: PUSH
22665: LD_INT 1
22667: PUSH
22668: LD_INT 1
22670: NEG
22671: PUSH
22672: EMPTY
22673: LIST
22674: LIST
22675: PUSH
22676: LD_INT 2
22678: PUSH
22679: LD_INT 0
22681: PUSH
22682: EMPTY
22683: LIST
22684: LIST
22685: PUSH
22686: LD_INT 2
22688: PUSH
22689: LD_INT 1
22691: PUSH
22692: EMPTY
22693: LIST
22694: LIST
22695: PUSH
22696: LD_INT 1
22698: PUSH
22699: LD_INT 2
22701: PUSH
22702: EMPTY
22703: LIST
22704: LIST
22705: PUSH
22706: LD_INT 0
22708: PUSH
22709: LD_INT 2
22711: PUSH
22712: EMPTY
22713: LIST
22714: LIST
22715: PUSH
22716: LD_INT 1
22718: NEG
22719: PUSH
22720: LD_INT 1
22722: PUSH
22723: EMPTY
22724: LIST
22725: LIST
22726: PUSH
22727: LD_INT 2
22729: NEG
22730: PUSH
22731: LD_INT 1
22733: NEG
22734: PUSH
22735: EMPTY
22736: LIST
22737: LIST
22738: PUSH
22739: LD_INT 2
22741: NEG
22742: PUSH
22743: LD_INT 2
22745: NEG
22746: PUSH
22747: EMPTY
22748: LIST
22749: LIST
22750: PUSH
22751: LD_INT 2
22753: NEG
22754: PUSH
22755: LD_INT 3
22757: NEG
22758: PUSH
22759: EMPTY
22760: LIST
22761: LIST
22762: PUSH
22763: LD_INT 2
22765: PUSH
22766: LD_INT 1
22768: NEG
22769: PUSH
22770: EMPTY
22771: LIST
22772: LIST
22773: PUSH
22774: LD_INT 3
22776: PUSH
22777: LD_INT 1
22779: PUSH
22780: EMPTY
22781: LIST
22782: LIST
22783: PUSH
22784: LD_INT 1
22786: PUSH
22787: LD_INT 3
22789: PUSH
22790: EMPTY
22791: LIST
22792: LIST
22793: PUSH
22794: LD_INT 1
22796: NEG
22797: PUSH
22798: LD_INT 2
22800: PUSH
22801: EMPTY
22802: LIST
22803: LIST
22804: PUSH
22805: LD_INT 3
22807: NEG
22808: PUSH
22809: LD_INT 2
22811: NEG
22812: PUSH
22813: EMPTY
22814: LIST
22815: LIST
22816: PUSH
22817: EMPTY
22818: LIST
22819: LIST
22820: LIST
22821: LIST
22822: LIST
22823: LIST
22824: LIST
22825: LIST
22826: LIST
22827: LIST
22828: LIST
22829: LIST
22830: LIST
22831: LIST
22832: LIST
22833: LIST
22834: LIST
22835: LIST
22836: LIST
22837: LIST
22838: LIST
22839: LIST
22840: LIST
22841: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
22842: LD_ADDR_VAR 0 30
22846: PUSH
22847: LD_INT 0
22849: PUSH
22850: LD_INT 0
22852: PUSH
22853: EMPTY
22854: LIST
22855: LIST
22856: PUSH
22857: LD_INT 0
22859: PUSH
22860: LD_INT 1
22862: NEG
22863: PUSH
22864: EMPTY
22865: LIST
22866: LIST
22867: PUSH
22868: LD_INT 1
22870: PUSH
22871: LD_INT 0
22873: PUSH
22874: EMPTY
22875: LIST
22876: LIST
22877: PUSH
22878: LD_INT 1
22880: PUSH
22881: LD_INT 1
22883: PUSH
22884: EMPTY
22885: LIST
22886: LIST
22887: PUSH
22888: LD_INT 0
22890: PUSH
22891: LD_INT 1
22893: PUSH
22894: EMPTY
22895: LIST
22896: LIST
22897: PUSH
22898: LD_INT 1
22900: NEG
22901: PUSH
22902: LD_INT 0
22904: PUSH
22905: EMPTY
22906: LIST
22907: LIST
22908: PUSH
22909: LD_INT 1
22911: NEG
22912: PUSH
22913: LD_INT 1
22915: NEG
22916: PUSH
22917: EMPTY
22918: LIST
22919: LIST
22920: PUSH
22921: LD_INT 1
22923: NEG
22924: PUSH
22925: LD_INT 2
22927: NEG
22928: PUSH
22929: EMPTY
22930: LIST
22931: LIST
22932: PUSH
22933: LD_INT 0
22935: PUSH
22936: LD_INT 2
22938: NEG
22939: PUSH
22940: EMPTY
22941: LIST
22942: LIST
22943: PUSH
22944: LD_INT 1
22946: PUSH
22947: LD_INT 1
22949: NEG
22950: PUSH
22951: EMPTY
22952: LIST
22953: LIST
22954: PUSH
22955: LD_INT 2
22957: PUSH
22958: LD_INT 0
22960: PUSH
22961: EMPTY
22962: LIST
22963: LIST
22964: PUSH
22965: LD_INT 2
22967: PUSH
22968: LD_INT 1
22970: PUSH
22971: EMPTY
22972: LIST
22973: LIST
22974: PUSH
22975: LD_INT 2
22977: PUSH
22978: LD_INT 2
22980: PUSH
22981: EMPTY
22982: LIST
22983: LIST
22984: PUSH
22985: LD_INT 1
22987: PUSH
22988: LD_INT 2
22990: PUSH
22991: EMPTY
22992: LIST
22993: LIST
22994: PUSH
22995: LD_INT 1
22997: NEG
22998: PUSH
22999: LD_INT 1
23001: PUSH
23002: EMPTY
23003: LIST
23004: LIST
23005: PUSH
23006: LD_INT 2
23008: NEG
23009: PUSH
23010: LD_INT 0
23012: PUSH
23013: EMPTY
23014: LIST
23015: LIST
23016: PUSH
23017: LD_INT 2
23019: NEG
23020: PUSH
23021: LD_INT 1
23023: NEG
23024: PUSH
23025: EMPTY
23026: LIST
23027: LIST
23028: PUSH
23029: LD_INT 1
23031: NEG
23032: PUSH
23033: LD_INT 3
23035: NEG
23036: PUSH
23037: EMPTY
23038: LIST
23039: LIST
23040: PUSH
23041: LD_INT 1
23043: PUSH
23044: LD_INT 2
23046: NEG
23047: PUSH
23048: EMPTY
23049: LIST
23050: LIST
23051: PUSH
23052: LD_INT 3
23054: PUSH
23055: LD_INT 2
23057: PUSH
23058: EMPTY
23059: LIST
23060: LIST
23061: PUSH
23062: LD_INT 2
23064: PUSH
23065: LD_INT 3
23067: PUSH
23068: EMPTY
23069: LIST
23070: LIST
23071: PUSH
23072: LD_INT 2
23074: NEG
23075: PUSH
23076: LD_INT 1
23078: PUSH
23079: EMPTY
23080: LIST
23081: LIST
23082: PUSH
23083: LD_INT 3
23085: NEG
23086: PUSH
23087: LD_INT 1
23089: NEG
23090: PUSH
23091: EMPTY
23092: LIST
23093: LIST
23094: PUSH
23095: EMPTY
23096: LIST
23097: LIST
23098: LIST
23099: LIST
23100: LIST
23101: LIST
23102: LIST
23103: LIST
23104: LIST
23105: LIST
23106: LIST
23107: LIST
23108: LIST
23109: LIST
23110: LIST
23111: LIST
23112: LIST
23113: LIST
23114: LIST
23115: LIST
23116: LIST
23117: LIST
23118: LIST
23119: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
23120: LD_ADDR_VAR 0 31
23124: PUSH
23125: LD_INT 0
23127: PUSH
23128: LD_INT 0
23130: PUSH
23131: EMPTY
23132: LIST
23133: LIST
23134: PUSH
23135: LD_INT 0
23137: PUSH
23138: LD_INT 1
23140: NEG
23141: PUSH
23142: EMPTY
23143: LIST
23144: LIST
23145: PUSH
23146: LD_INT 1
23148: PUSH
23149: LD_INT 0
23151: PUSH
23152: EMPTY
23153: LIST
23154: LIST
23155: PUSH
23156: LD_INT 1
23158: PUSH
23159: LD_INT 1
23161: PUSH
23162: EMPTY
23163: LIST
23164: LIST
23165: PUSH
23166: LD_INT 0
23168: PUSH
23169: LD_INT 1
23171: PUSH
23172: EMPTY
23173: LIST
23174: LIST
23175: PUSH
23176: LD_INT 1
23178: NEG
23179: PUSH
23180: LD_INT 0
23182: PUSH
23183: EMPTY
23184: LIST
23185: LIST
23186: PUSH
23187: LD_INT 1
23189: NEG
23190: PUSH
23191: LD_INT 1
23193: NEG
23194: PUSH
23195: EMPTY
23196: LIST
23197: LIST
23198: PUSH
23199: LD_INT 1
23201: NEG
23202: PUSH
23203: LD_INT 2
23205: NEG
23206: PUSH
23207: EMPTY
23208: LIST
23209: LIST
23210: PUSH
23211: LD_INT 1
23213: PUSH
23214: LD_INT 1
23216: NEG
23217: PUSH
23218: EMPTY
23219: LIST
23220: LIST
23221: PUSH
23222: LD_INT 2
23224: PUSH
23225: LD_INT 0
23227: PUSH
23228: EMPTY
23229: LIST
23230: LIST
23231: PUSH
23232: LD_INT 2
23234: PUSH
23235: LD_INT 1
23237: PUSH
23238: EMPTY
23239: LIST
23240: LIST
23241: PUSH
23242: LD_INT 2
23244: PUSH
23245: LD_INT 2
23247: PUSH
23248: EMPTY
23249: LIST
23250: LIST
23251: PUSH
23252: LD_INT 1
23254: PUSH
23255: LD_INT 2
23257: PUSH
23258: EMPTY
23259: LIST
23260: LIST
23261: PUSH
23262: LD_INT 0
23264: PUSH
23265: LD_INT 2
23267: PUSH
23268: EMPTY
23269: LIST
23270: LIST
23271: PUSH
23272: LD_INT 1
23274: NEG
23275: PUSH
23276: LD_INT 1
23278: PUSH
23279: EMPTY
23280: LIST
23281: LIST
23282: PUSH
23283: LD_INT 2
23285: NEG
23286: PUSH
23287: LD_INT 1
23289: NEG
23290: PUSH
23291: EMPTY
23292: LIST
23293: LIST
23294: PUSH
23295: LD_INT 2
23297: NEG
23298: PUSH
23299: LD_INT 2
23301: NEG
23302: PUSH
23303: EMPTY
23304: LIST
23305: LIST
23306: PUSH
23307: LD_INT 2
23309: NEG
23310: PUSH
23311: LD_INT 3
23313: NEG
23314: PUSH
23315: EMPTY
23316: LIST
23317: LIST
23318: PUSH
23319: LD_INT 2
23321: PUSH
23322: LD_INT 1
23324: NEG
23325: PUSH
23326: EMPTY
23327: LIST
23328: LIST
23329: PUSH
23330: LD_INT 3
23332: PUSH
23333: LD_INT 1
23335: PUSH
23336: EMPTY
23337: LIST
23338: LIST
23339: PUSH
23340: LD_INT 1
23342: PUSH
23343: LD_INT 3
23345: PUSH
23346: EMPTY
23347: LIST
23348: LIST
23349: PUSH
23350: LD_INT 1
23352: NEG
23353: PUSH
23354: LD_INT 2
23356: PUSH
23357: EMPTY
23358: LIST
23359: LIST
23360: PUSH
23361: LD_INT 3
23363: NEG
23364: PUSH
23365: LD_INT 2
23367: NEG
23368: PUSH
23369: EMPTY
23370: LIST
23371: LIST
23372: PUSH
23373: EMPTY
23374: LIST
23375: LIST
23376: LIST
23377: LIST
23378: LIST
23379: LIST
23380: LIST
23381: LIST
23382: LIST
23383: LIST
23384: LIST
23385: LIST
23386: LIST
23387: LIST
23388: LIST
23389: LIST
23390: LIST
23391: LIST
23392: LIST
23393: LIST
23394: LIST
23395: LIST
23396: LIST
23397: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
23398: LD_ADDR_VAR 0 32
23402: PUSH
23403: LD_INT 0
23405: PUSH
23406: LD_INT 0
23408: PUSH
23409: EMPTY
23410: LIST
23411: LIST
23412: PUSH
23413: LD_INT 0
23415: PUSH
23416: LD_INT 1
23418: NEG
23419: PUSH
23420: EMPTY
23421: LIST
23422: LIST
23423: PUSH
23424: LD_INT 1
23426: PUSH
23427: LD_INT 0
23429: PUSH
23430: EMPTY
23431: LIST
23432: LIST
23433: PUSH
23434: LD_INT 1
23436: PUSH
23437: LD_INT 1
23439: PUSH
23440: EMPTY
23441: LIST
23442: LIST
23443: PUSH
23444: LD_INT 0
23446: PUSH
23447: LD_INT 1
23449: PUSH
23450: EMPTY
23451: LIST
23452: LIST
23453: PUSH
23454: LD_INT 1
23456: NEG
23457: PUSH
23458: LD_INT 0
23460: PUSH
23461: EMPTY
23462: LIST
23463: LIST
23464: PUSH
23465: LD_INT 1
23467: NEG
23468: PUSH
23469: LD_INT 1
23471: NEG
23472: PUSH
23473: EMPTY
23474: LIST
23475: LIST
23476: PUSH
23477: LD_INT 1
23479: NEG
23480: PUSH
23481: LD_INT 2
23483: NEG
23484: PUSH
23485: EMPTY
23486: LIST
23487: LIST
23488: PUSH
23489: LD_INT 0
23491: PUSH
23492: LD_INT 2
23494: NEG
23495: PUSH
23496: EMPTY
23497: LIST
23498: LIST
23499: PUSH
23500: LD_INT 1
23502: PUSH
23503: LD_INT 1
23505: NEG
23506: PUSH
23507: EMPTY
23508: LIST
23509: LIST
23510: PUSH
23511: LD_INT 2
23513: PUSH
23514: LD_INT 1
23516: PUSH
23517: EMPTY
23518: LIST
23519: LIST
23520: PUSH
23521: LD_INT 2
23523: PUSH
23524: LD_INT 2
23526: PUSH
23527: EMPTY
23528: LIST
23529: LIST
23530: PUSH
23531: LD_INT 1
23533: PUSH
23534: LD_INT 2
23536: PUSH
23537: EMPTY
23538: LIST
23539: LIST
23540: PUSH
23541: LD_INT 0
23543: PUSH
23544: LD_INT 2
23546: PUSH
23547: EMPTY
23548: LIST
23549: LIST
23550: PUSH
23551: LD_INT 1
23553: NEG
23554: PUSH
23555: LD_INT 1
23557: PUSH
23558: EMPTY
23559: LIST
23560: LIST
23561: PUSH
23562: LD_INT 2
23564: NEG
23565: PUSH
23566: LD_INT 0
23568: PUSH
23569: EMPTY
23570: LIST
23571: LIST
23572: PUSH
23573: LD_INT 2
23575: NEG
23576: PUSH
23577: LD_INT 1
23579: NEG
23580: PUSH
23581: EMPTY
23582: LIST
23583: LIST
23584: PUSH
23585: LD_INT 1
23587: NEG
23588: PUSH
23589: LD_INT 3
23591: NEG
23592: PUSH
23593: EMPTY
23594: LIST
23595: LIST
23596: PUSH
23597: LD_INT 1
23599: PUSH
23600: LD_INT 2
23602: NEG
23603: PUSH
23604: EMPTY
23605: LIST
23606: LIST
23607: PUSH
23608: LD_INT 3
23610: PUSH
23611: LD_INT 2
23613: PUSH
23614: EMPTY
23615: LIST
23616: LIST
23617: PUSH
23618: LD_INT 2
23620: PUSH
23621: LD_INT 3
23623: PUSH
23624: EMPTY
23625: LIST
23626: LIST
23627: PUSH
23628: LD_INT 2
23630: NEG
23631: PUSH
23632: LD_INT 1
23634: PUSH
23635: EMPTY
23636: LIST
23637: LIST
23638: PUSH
23639: LD_INT 3
23641: NEG
23642: PUSH
23643: LD_INT 1
23645: NEG
23646: PUSH
23647: EMPTY
23648: LIST
23649: LIST
23650: PUSH
23651: EMPTY
23652: LIST
23653: LIST
23654: LIST
23655: LIST
23656: LIST
23657: LIST
23658: LIST
23659: LIST
23660: LIST
23661: LIST
23662: LIST
23663: LIST
23664: LIST
23665: LIST
23666: LIST
23667: LIST
23668: LIST
23669: LIST
23670: LIST
23671: LIST
23672: LIST
23673: LIST
23674: LIST
23675: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
23676: LD_ADDR_VAR 0 33
23680: PUSH
23681: LD_INT 0
23683: PUSH
23684: LD_INT 0
23686: PUSH
23687: EMPTY
23688: LIST
23689: LIST
23690: PUSH
23691: LD_INT 0
23693: PUSH
23694: LD_INT 1
23696: NEG
23697: PUSH
23698: EMPTY
23699: LIST
23700: LIST
23701: PUSH
23702: LD_INT 1
23704: PUSH
23705: LD_INT 0
23707: PUSH
23708: EMPTY
23709: LIST
23710: LIST
23711: PUSH
23712: LD_INT 1
23714: PUSH
23715: LD_INT 1
23717: PUSH
23718: EMPTY
23719: LIST
23720: LIST
23721: PUSH
23722: LD_INT 0
23724: PUSH
23725: LD_INT 1
23727: PUSH
23728: EMPTY
23729: LIST
23730: LIST
23731: PUSH
23732: LD_INT 1
23734: NEG
23735: PUSH
23736: LD_INT 0
23738: PUSH
23739: EMPTY
23740: LIST
23741: LIST
23742: PUSH
23743: LD_INT 1
23745: NEG
23746: PUSH
23747: LD_INT 1
23749: NEG
23750: PUSH
23751: EMPTY
23752: LIST
23753: LIST
23754: PUSH
23755: LD_INT 1
23757: NEG
23758: PUSH
23759: LD_INT 2
23761: NEG
23762: PUSH
23763: EMPTY
23764: LIST
23765: LIST
23766: PUSH
23767: LD_INT 1
23769: PUSH
23770: LD_INT 1
23772: NEG
23773: PUSH
23774: EMPTY
23775: LIST
23776: LIST
23777: PUSH
23778: LD_INT 2
23780: PUSH
23781: LD_INT 0
23783: PUSH
23784: EMPTY
23785: LIST
23786: LIST
23787: PUSH
23788: LD_INT 2
23790: PUSH
23791: LD_INT 1
23793: PUSH
23794: EMPTY
23795: LIST
23796: LIST
23797: PUSH
23798: LD_INT 1
23800: PUSH
23801: LD_INT 2
23803: PUSH
23804: EMPTY
23805: LIST
23806: LIST
23807: PUSH
23808: LD_INT 0
23810: PUSH
23811: LD_INT 2
23813: PUSH
23814: EMPTY
23815: LIST
23816: LIST
23817: PUSH
23818: LD_INT 1
23820: NEG
23821: PUSH
23822: LD_INT 1
23824: PUSH
23825: EMPTY
23826: LIST
23827: LIST
23828: PUSH
23829: LD_INT 2
23831: NEG
23832: PUSH
23833: LD_INT 0
23835: PUSH
23836: EMPTY
23837: LIST
23838: LIST
23839: PUSH
23840: LD_INT 2
23842: NEG
23843: PUSH
23844: LD_INT 1
23846: NEG
23847: PUSH
23848: EMPTY
23849: LIST
23850: LIST
23851: PUSH
23852: LD_INT 2
23854: NEG
23855: PUSH
23856: LD_INT 2
23858: NEG
23859: PUSH
23860: EMPTY
23861: LIST
23862: LIST
23863: PUSH
23864: LD_INT 2
23866: NEG
23867: PUSH
23868: LD_INT 3
23870: NEG
23871: PUSH
23872: EMPTY
23873: LIST
23874: LIST
23875: PUSH
23876: LD_INT 2
23878: PUSH
23879: LD_INT 1
23881: NEG
23882: PUSH
23883: EMPTY
23884: LIST
23885: LIST
23886: PUSH
23887: LD_INT 3
23889: PUSH
23890: LD_INT 1
23892: PUSH
23893: EMPTY
23894: LIST
23895: LIST
23896: PUSH
23897: LD_INT 1
23899: PUSH
23900: LD_INT 3
23902: PUSH
23903: EMPTY
23904: LIST
23905: LIST
23906: PUSH
23907: LD_INT 1
23909: NEG
23910: PUSH
23911: LD_INT 2
23913: PUSH
23914: EMPTY
23915: LIST
23916: LIST
23917: PUSH
23918: LD_INT 3
23920: NEG
23921: PUSH
23922: LD_INT 2
23924: NEG
23925: PUSH
23926: EMPTY
23927: LIST
23928: LIST
23929: PUSH
23930: EMPTY
23931: LIST
23932: LIST
23933: LIST
23934: LIST
23935: LIST
23936: LIST
23937: LIST
23938: LIST
23939: LIST
23940: LIST
23941: LIST
23942: LIST
23943: LIST
23944: LIST
23945: LIST
23946: LIST
23947: LIST
23948: LIST
23949: LIST
23950: LIST
23951: LIST
23952: LIST
23953: LIST
23954: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
23955: LD_ADDR_VAR 0 34
23959: PUSH
23960: LD_INT 0
23962: PUSH
23963: LD_INT 0
23965: PUSH
23966: EMPTY
23967: LIST
23968: LIST
23969: PUSH
23970: LD_INT 0
23972: PUSH
23973: LD_INT 1
23975: NEG
23976: PUSH
23977: EMPTY
23978: LIST
23979: LIST
23980: PUSH
23981: LD_INT 1
23983: PUSH
23984: LD_INT 0
23986: PUSH
23987: EMPTY
23988: LIST
23989: LIST
23990: PUSH
23991: LD_INT 1
23993: PUSH
23994: LD_INT 1
23996: PUSH
23997: EMPTY
23998: LIST
23999: LIST
24000: PUSH
24001: LD_INT 0
24003: PUSH
24004: LD_INT 1
24006: PUSH
24007: EMPTY
24008: LIST
24009: LIST
24010: PUSH
24011: LD_INT 1
24013: NEG
24014: PUSH
24015: LD_INT 0
24017: PUSH
24018: EMPTY
24019: LIST
24020: LIST
24021: PUSH
24022: LD_INT 1
24024: NEG
24025: PUSH
24026: LD_INT 1
24028: NEG
24029: PUSH
24030: EMPTY
24031: LIST
24032: LIST
24033: PUSH
24034: LD_INT 1
24036: NEG
24037: PUSH
24038: LD_INT 2
24040: NEG
24041: PUSH
24042: EMPTY
24043: LIST
24044: LIST
24045: PUSH
24046: LD_INT 0
24048: PUSH
24049: LD_INT 2
24051: NEG
24052: PUSH
24053: EMPTY
24054: LIST
24055: LIST
24056: PUSH
24057: LD_INT 1
24059: PUSH
24060: LD_INT 1
24062: NEG
24063: PUSH
24064: EMPTY
24065: LIST
24066: LIST
24067: PUSH
24068: LD_INT 2
24070: PUSH
24071: LD_INT 1
24073: PUSH
24074: EMPTY
24075: LIST
24076: LIST
24077: PUSH
24078: LD_INT 2
24080: PUSH
24081: LD_INT 2
24083: PUSH
24084: EMPTY
24085: LIST
24086: LIST
24087: PUSH
24088: LD_INT 1
24090: PUSH
24091: LD_INT 2
24093: PUSH
24094: EMPTY
24095: LIST
24096: LIST
24097: PUSH
24098: LD_INT 1
24100: NEG
24101: PUSH
24102: LD_INT 1
24104: PUSH
24105: EMPTY
24106: LIST
24107: LIST
24108: PUSH
24109: LD_INT 2
24111: NEG
24112: PUSH
24113: LD_INT 0
24115: PUSH
24116: EMPTY
24117: LIST
24118: LIST
24119: PUSH
24120: LD_INT 2
24122: NEG
24123: PUSH
24124: LD_INT 1
24126: NEG
24127: PUSH
24128: EMPTY
24129: LIST
24130: LIST
24131: PUSH
24132: LD_INT 2
24134: NEG
24135: PUSH
24136: LD_INT 2
24138: NEG
24139: PUSH
24140: EMPTY
24141: LIST
24142: LIST
24143: PUSH
24144: LD_INT 1
24146: NEG
24147: PUSH
24148: LD_INT 3
24150: NEG
24151: PUSH
24152: EMPTY
24153: LIST
24154: LIST
24155: PUSH
24156: LD_INT 1
24158: PUSH
24159: LD_INT 2
24161: NEG
24162: PUSH
24163: EMPTY
24164: LIST
24165: LIST
24166: PUSH
24167: LD_INT 3
24169: PUSH
24170: LD_INT 2
24172: PUSH
24173: EMPTY
24174: LIST
24175: LIST
24176: PUSH
24177: LD_INT 2
24179: PUSH
24180: LD_INT 3
24182: PUSH
24183: EMPTY
24184: LIST
24185: LIST
24186: PUSH
24187: LD_INT 2
24189: NEG
24190: PUSH
24191: LD_INT 1
24193: PUSH
24194: EMPTY
24195: LIST
24196: LIST
24197: PUSH
24198: LD_INT 3
24200: NEG
24201: PUSH
24202: LD_INT 1
24204: NEG
24205: PUSH
24206: EMPTY
24207: LIST
24208: LIST
24209: PUSH
24210: EMPTY
24211: LIST
24212: LIST
24213: LIST
24214: LIST
24215: LIST
24216: LIST
24217: LIST
24218: LIST
24219: LIST
24220: LIST
24221: LIST
24222: LIST
24223: LIST
24224: LIST
24225: LIST
24226: LIST
24227: LIST
24228: LIST
24229: LIST
24230: LIST
24231: LIST
24232: LIST
24233: LIST
24234: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
24235: LD_ADDR_VAR 0 35
24239: PUSH
24240: LD_INT 0
24242: PUSH
24243: LD_INT 0
24245: PUSH
24246: EMPTY
24247: LIST
24248: LIST
24249: PUSH
24250: LD_INT 0
24252: PUSH
24253: LD_INT 1
24255: NEG
24256: PUSH
24257: EMPTY
24258: LIST
24259: LIST
24260: PUSH
24261: LD_INT 1
24263: PUSH
24264: LD_INT 0
24266: PUSH
24267: EMPTY
24268: LIST
24269: LIST
24270: PUSH
24271: LD_INT 1
24273: PUSH
24274: LD_INT 1
24276: PUSH
24277: EMPTY
24278: LIST
24279: LIST
24280: PUSH
24281: LD_INT 0
24283: PUSH
24284: LD_INT 1
24286: PUSH
24287: EMPTY
24288: LIST
24289: LIST
24290: PUSH
24291: LD_INT 1
24293: NEG
24294: PUSH
24295: LD_INT 0
24297: PUSH
24298: EMPTY
24299: LIST
24300: LIST
24301: PUSH
24302: LD_INT 1
24304: NEG
24305: PUSH
24306: LD_INT 1
24308: NEG
24309: PUSH
24310: EMPTY
24311: LIST
24312: LIST
24313: PUSH
24314: LD_INT 2
24316: PUSH
24317: LD_INT 1
24319: PUSH
24320: EMPTY
24321: LIST
24322: LIST
24323: PUSH
24324: LD_INT 2
24326: NEG
24327: PUSH
24328: LD_INT 1
24330: NEG
24331: PUSH
24332: EMPTY
24333: LIST
24334: LIST
24335: PUSH
24336: EMPTY
24337: LIST
24338: LIST
24339: LIST
24340: LIST
24341: LIST
24342: LIST
24343: LIST
24344: LIST
24345: LIST
24346: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
24347: LD_ADDR_VAR 0 36
24351: PUSH
24352: LD_INT 0
24354: PUSH
24355: LD_INT 0
24357: PUSH
24358: EMPTY
24359: LIST
24360: LIST
24361: PUSH
24362: LD_INT 0
24364: PUSH
24365: LD_INT 1
24367: NEG
24368: PUSH
24369: EMPTY
24370: LIST
24371: LIST
24372: PUSH
24373: LD_INT 1
24375: PUSH
24376: LD_INT 0
24378: PUSH
24379: EMPTY
24380: LIST
24381: LIST
24382: PUSH
24383: LD_INT 1
24385: PUSH
24386: LD_INT 1
24388: PUSH
24389: EMPTY
24390: LIST
24391: LIST
24392: PUSH
24393: LD_INT 0
24395: PUSH
24396: LD_INT 1
24398: PUSH
24399: EMPTY
24400: LIST
24401: LIST
24402: PUSH
24403: LD_INT 1
24405: NEG
24406: PUSH
24407: LD_INT 0
24409: PUSH
24410: EMPTY
24411: LIST
24412: LIST
24413: PUSH
24414: LD_INT 1
24416: NEG
24417: PUSH
24418: LD_INT 1
24420: NEG
24421: PUSH
24422: EMPTY
24423: LIST
24424: LIST
24425: PUSH
24426: LD_INT 1
24428: NEG
24429: PUSH
24430: LD_INT 2
24432: NEG
24433: PUSH
24434: EMPTY
24435: LIST
24436: LIST
24437: PUSH
24438: LD_INT 1
24440: PUSH
24441: LD_INT 2
24443: PUSH
24444: EMPTY
24445: LIST
24446: LIST
24447: PUSH
24448: EMPTY
24449: LIST
24450: LIST
24451: LIST
24452: LIST
24453: LIST
24454: LIST
24455: LIST
24456: LIST
24457: LIST
24458: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
24459: LD_ADDR_VAR 0 37
24463: PUSH
24464: LD_INT 0
24466: PUSH
24467: LD_INT 0
24469: PUSH
24470: EMPTY
24471: LIST
24472: LIST
24473: PUSH
24474: LD_INT 0
24476: PUSH
24477: LD_INT 1
24479: NEG
24480: PUSH
24481: EMPTY
24482: LIST
24483: LIST
24484: PUSH
24485: LD_INT 1
24487: PUSH
24488: LD_INT 0
24490: PUSH
24491: EMPTY
24492: LIST
24493: LIST
24494: PUSH
24495: LD_INT 1
24497: PUSH
24498: LD_INT 1
24500: PUSH
24501: EMPTY
24502: LIST
24503: LIST
24504: PUSH
24505: LD_INT 0
24507: PUSH
24508: LD_INT 1
24510: PUSH
24511: EMPTY
24512: LIST
24513: LIST
24514: PUSH
24515: LD_INT 1
24517: NEG
24518: PUSH
24519: LD_INT 0
24521: PUSH
24522: EMPTY
24523: LIST
24524: LIST
24525: PUSH
24526: LD_INT 1
24528: NEG
24529: PUSH
24530: LD_INT 1
24532: NEG
24533: PUSH
24534: EMPTY
24535: LIST
24536: LIST
24537: PUSH
24538: LD_INT 1
24540: PUSH
24541: LD_INT 1
24543: NEG
24544: PUSH
24545: EMPTY
24546: LIST
24547: LIST
24548: PUSH
24549: LD_INT 1
24551: NEG
24552: PUSH
24553: LD_INT 1
24555: PUSH
24556: EMPTY
24557: LIST
24558: LIST
24559: PUSH
24560: EMPTY
24561: LIST
24562: LIST
24563: LIST
24564: LIST
24565: LIST
24566: LIST
24567: LIST
24568: LIST
24569: LIST
24570: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
24571: LD_ADDR_VAR 0 38
24575: PUSH
24576: LD_INT 0
24578: PUSH
24579: LD_INT 0
24581: PUSH
24582: EMPTY
24583: LIST
24584: LIST
24585: PUSH
24586: LD_INT 0
24588: PUSH
24589: LD_INT 1
24591: NEG
24592: PUSH
24593: EMPTY
24594: LIST
24595: LIST
24596: PUSH
24597: LD_INT 1
24599: PUSH
24600: LD_INT 0
24602: PUSH
24603: EMPTY
24604: LIST
24605: LIST
24606: PUSH
24607: LD_INT 1
24609: PUSH
24610: LD_INT 1
24612: PUSH
24613: EMPTY
24614: LIST
24615: LIST
24616: PUSH
24617: LD_INT 0
24619: PUSH
24620: LD_INT 1
24622: PUSH
24623: EMPTY
24624: LIST
24625: LIST
24626: PUSH
24627: LD_INT 1
24629: NEG
24630: PUSH
24631: LD_INT 0
24633: PUSH
24634: EMPTY
24635: LIST
24636: LIST
24637: PUSH
24638: LD_INT 1
24640: NEG
24641: PUSH
24642: LD_INT 1
24644: NEG
24645: PUSH
24646: EMPTY
24647: LIST
24648: LIST
24649: PUSH
24650: LD_INT 2
24652: PUSH
24653: LD_INT 1
24655: PUSH
24656: EMPTY
24657: LIST
24658: LIST
24659: PUSH
24660: LD_INT 2
24662: NEG
24663: PUSH
24664: LD_INT 1
24666: NEG
24667: PUSH
24668: EMPTY
24669: LIST
24670: LIST
24671: PUSH
24672: EMPTY
24673: LIST
24674: LIST
24675: LIST
24676: LIST
24677: LIST
24678: LIST
24679: LIST
24680: LIST
24681: LIST
24682: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
24683: LD_ADDR_VAR 0 39
24687: PUSH
24688: LD_INT 0
24690: PUSH
24691: LD_INT 0
24693: PUSH
24694: EMPTY
24695: LIST
24696: LIST
24697: PUSH
24698: LD_INT 0
24700: PUSH
24701: LD_INT 1
24703: NEG
24704: PUSH
24705: EMPTY
24706: LIST
24707: LIST
24708: PUSH
24709: LD_INT 1
24711: PUSH
24712: LD_INT 0
24714: PUSH
24715: EMPTY
24716: LIST
24717: LIST
24718: PUSH
24719: LD_INT 1
24721: PUSH
24722: LD_INT 1
24724: PUSH
24725: EMPTY
24726: LIST
24727: LIST
24728: PUSH
24729: LD_INT 0
24731: PUSH
24732: LD_INT 1
24734: PUSH
24735: EMPTY
24736: LIST
24737: LIST
24738: PUSH
24739: LD_INT 1
24741: NEG
24742: PUSH
24743: LD_INT 0
24745: PUSH
24746: EMPTY
24747: LIST
24748: LIST
24749: PUSH
24750: LD_INT 1
24752: NEG
24753: PUSH
24754: LD_INT 1
24756: NEG
24757: PUSH
24758: EMPTY
24759: LIST
24760: LIST
24761: PUSH
24762: LD_INT 1
24764: NEG
24765: PUSH
24766: LD_INT 2
24768: NEG
24769: PUSH
24770: EMPTY
24771: LIST
24772: LIST
24773: PUSH
24774: LD_INT 1
24776: PUSH
24777: LD_INT 2
24779: PUSH
24780: EMPTY
24781: LIST
24782: LIST
24783: PUSH
24784: EMPTY
24785: LIST
24786: LIST
24787: LIST
24788: LIST
24789: LIST
24790: LIST
24791: LIST
24792: LIST
24793: LIST
24794: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
24795: LD_ADDR_VAR 0 40
24799: PUSH
24800: LD_INT 0
24802: PUSH
24803: LD_INT 0
24805: PUSH
24806: EMPTY
24807: LIST
24808: LIST
24809: PUSH
24810: LD_INT 0
24812: PUSH
24813: LD_INT 1
24815: NEG
24816: PUSH
24817: EMPTY
24818: LIST
24819: LIST
24820: PUSH
24821: LD_INT 1
24823: PUSH
24824: LD_INT 0
24826: PUSH
24827: EMPTY
24828: LIST
24829: LIST
24830: PUSH
24831: LD_INT 1
24833: PUSH
24834: LD_INT 1
24836: PUSH
24837: EMPTY
24838: LIST
24839: LIST
24840: PUSH
24841: LD_INT 0
24843: PUSH
24844: LD_INT 1
24846: PUSH
24847: EMPTY
24848: LIST
24849: LIST
24850: PUSH
24851: LD_INT 1
24853: NEG
24854: PUSH
24855: LD_INT 0
24857: PUSH
24858: EMPTY
24859: LIST
24860: LIST
24861: PUSH
24862: LD_INT 1
24864: NEG
24865: PUSH
24866: LD_INT 1
24868: NEG
24869: PUSH
24870: EMPTY
24871: LIST
24872: LIST
24873: PUSH
24874: LD_INT 1
24876: PUSH
24877: LD_INT 1
24879: NEG
24880: PUSH
24881: EMPTY
24882: LIST
24883: LIST
24884: PUSH
24885: LD_INT 1
24887: NEG
24888: PUSH
24889: LD_INT 1
24891: PUSH
24892: EMPTY
24893: LIST
24894: LIST
24895: PUSH
24896: EMPTY
24897: LIST
24898: LIST
24899: LIST
24900: LIST
24901: LIST
24902: LIST
24903: LIST
24904: LIST
24905: LIST
24906: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
24907: LD_ADDR_VAR 0 41
24911: PUSH
24912: LD_INT 0
24914: PUSH
24915: LD_INT 0
24917: PUSH
24918: EMPTY
24919: LIST
24920: LIST
24921: PUSH
24922: LD_INT 0
24924: PUSH
24925: LD_INT 1
24927: NEG
24928: PUSH
24929: EMPTY
24930: LIST
24931: LIST
24932: PUSH
24933: LD_INT 1
24935: PUSH
24936: LD_INT 0
24938: PUSH
24939: EMPTY
24940: LIST
24941: LIST
24942: PUSH
24943: LD_INT 1
24945: PUSH
24946: LD_INT 1
24948: PUSH
24949: EMPTY
24950: LIST
24951: LIST
24952: PUSH
24953: LD_INT 0
24955: PUSH
24956: LD_INT 1
24958: PUSH
24959: EMPTY
24960: LIST
24961: LIST
24962: PUSH
24963: LD_INT 1
24965: NEG
24966: PUSH
24967: LD_INT 0
24969: PUSH
24970: EMPTY
24971: LIST
24972: LIST
24973: PUSH
24974: LD_INT 1
24976: NEG
24977: PUSH
24978: LD_INT 1
24980: NEG
24981: PUSH
24982: EMPTY
24983: LIST
24984: LIST
24985: PUSH
24986: LD_INT 1
24988: NEG
24989: PUSH
24990: LD_INT 2
24992: NEG
24993: PUSH
24994: EMPTY
24995: LIST
24996: LIST
24997: PUSH
24998: LD_INT 1
25000: PUSH
25001: LD_INT 1
25003: NEG
25004: PUSH
25005: EMPTY
25006: LIST
25007: LIST
25008: PUSH
25009: LD_INT 2
25011: PUSH
25012: LD_INT 0
25014: PUSH
25015: EMPTY
25016: LIST
25017: LIST
25018: PUSH
25019: LD_INT 2
25021: PUSH
25022: LD_INT 1
25024: PUSH
25025: EMPTY
25026: LIST
25027: LIST
25028: PUSH
25029: LD_INT 2
25031: PUSH
25032: LD_INT 2
25034: PUSH
25035: EMPTY
25036: LIST
25037: LIST
25038: PUSH
25039: LD_INT 1
25041: PUSH
25042: LD_INT 2
25044: PUSH
25045: EMPTY
25046: LIST
25047: LIST
25048: PUSH
25049: LD_INT 1
25051: NEG
25052: PUSH
25053: LD_INT 1
25055: PUSH
25056: EMPTY
25057: LIST
25058: LIST
25059: PUSH
25060: LD_INT 2
25062: NEG
25063: PUSH
25064: LD_INT 0
25066: PUSH
25067: EMPTY
25068: LIST
25069: LIST
25070: PUSH
25071: LD_INT 2
25073: NEG
25074: PUSH
25075: LD_INT 1
25077: NEG
25078: PUSH
25079: EMPTY
25080: LIST
25081: LIST
25082: PUSH
25083: LD_INT 2
25085: NEG
25086: PUSH
25087: LD_INT 2
25089: NEG
25090: PUSH
25091: EMPTY
25092: LIST
25093: LIST
25094: PUSH
25095: LD_INT 2
25097: NEG
25098: PUSH
25099: LD_INT 3
25101: NEG
25102: PUSH
25103: EMPTY
25104: LIST
25105: LIST
25106: PUSH
25107: LD_INT 2
25109: PUSH
25110: LD_INT 1
25112: NEG
25113: PUSH
25114: EMPTY
25115: LIST
25116: LIST
25117: PUSH
25118: LD_INT 3
25120: PUSH
25121: LD_INT 0
25123: PUSH
25124: EMPTY
25125: LIST
25126: LIST
25127: PUSH
25128: LD_INT 3
25130: PUSH
25131: LD_INT 1
25133: PUSH
25134: EMPTY
25135: LIST
25136: LIST
25137: PUSH
25138: LD_INT 3
25140: PUSH
25141: LD_INT 2
25143: PUSH
25144: EMPTY
25145: LIST
25146: LIST
25147: PUSH
25148: LD_INT 3
25150: PUSH
25151: LD_INT 3
25153: PUSH
25154: EMPTY
25155: LIST
25156: LIST
25157: PUSH
25158: LD_INT 2
25160: PUSH
25161: LD_INT 3
25163: PUSH
25164: EMPTY
25165: LIST
25166: LIST
25167: PUSH
25168: LD_INT 2
25170: NEG
25171: PUSH
25172: LD_INT 1
25174: PUSH
25175: EMPTY
25176: LIST
25177: LIST
25178: PUSH
25179: LD_INT 3
25181: NEG
25182: PUSH
25183: LD_INT 0
25185: PUSH
25186: EMPTY
25187: LIST
25188: LIST
25189: PUSH
25190: LD_INT 3
25192: NEG
25193: PUSH
25194: LD_INT 1
25196: NEG
25197: PUSH
25198: EMPTY
25199: LIST
25200: LIST
25201: PUSH
25202: LD_INT 3
25204: NEG
25205: PUSH
25206: LD_INT 2
25208: NEG
25209: PUSH
25210: EMPTY
25211: LIST
25212: LIST
25213: PUSH
25214: LD_INT 3
25216: NEG
25217: PUSH
25218: LD_INT 3
25220: NEG
25221: PUSH
25222: EMPTY
25223: LIST
25224: LIST
25225: PUSH
25226: EMPTY
25227: LIST
25228: LIST
25229: LIST
25230: LIST
25231: LIST
25232: LIST
25233: LIST
25234: LIST
25235: LIST
25236: LIST
25237: LIST
25238: LIST
25239: LIST
25240: LIST
25241: LIST
25242: LIST
25243: LIST
25244: LIST
25245: LIST
25246: LIST
25247: LIST
25248: LIST
25249: LIST
25250: LIST
25251: LIST
25252: LIST
25253: LIST
25254: LIST
25255: LIST
25256: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
25257: LD_ADDR_VAR 0 42
25261: PUSH
25262: LD_INT 0
25264: PUSH
25265: LD_INT 0
25267: PUSH
25268: EMPTY
25269: LIST
25270: LIST
25271: PUSH
25272: LD_INT 0
25274: PUSH
25275: LD_INT 1
25277: NEG
25278: PUSH
25279: EMPTY
25280: LIST
25281: LIST
25282: PUSH
25283: LD_INT 1
25285: PUSH
25286: LD_INT 0
25288: PUSH
25289: EMPTY
25290: LIST
25291: LIST
25292: PUSH
25293: LD_INT 1
25295: PUSH
25296: LD_INT 1
25298: PUSH
25299: EMPTY
25300: LIST
25301: LIST
25302: PUSH
25303: LD_INT 0
25305: PUSH
25306: LD_INT 1
25308: PUSH
25309: EMPTY
25310: LIST
25311: LIST
25312: PUSH
25313: LD_INT 1
25315: NEG
25316: PUSH
25317: LD_INT 0
25319: PUSH
25320: EMPTY
25321: LIST
25322: LIST
25323: PUSH
25324: LD_INT 1
25326: NEG
25327: PUSH
25328: LD_INT 1
25330: NEG
25331: PUSH
25332: EMPTY
25333: LIST
25334: LIST
25335: PUSH
25336: LD_INT 1
25338: NEG
25339: PUSH
25340: LD_INT 2
25342: NEG
25343: PUSH
25344: EMPTY
25345: LIST
25346: LIST
25347: PUSH
25348: LD_INT 0
25350: PUSH
25351: LD_INT 2
25353: NEG
25354: PUSH
25355: EMPTY
25356: LIST
25357: LIST
25358: PUSH
25359: LD_INT 1
25361: PUSH
25362: LD_INT 1
25364: NEG
25365: PUSH
25366: EMPTY
25367: LIST
25368: LIST
25369: PUSH
25370: LD_INT 2
25372: PUSH
25373: LD_INT 1
25375: PUSH
25376: EMPTY
25377: LIST
25378: LIST
25379: PUSH
25380: LD_INT 2
25382: PUSH
25383: LD_INT 2
25385: PUSH
25386: EMPTY
25387: LIST
25388: LIST
25389: PUSH
25390: LD_INT 1
25392: PUSH
25393: LD_INT 2
25395: PUSH
25396: EMPTY
25397: LIST
25398: LIST
25399: PUSH
25400: LD_INT 0
25402: PUSH
25403: LD_INT 2
25405: PUSH
25406: EMPTY
25407: LIST
25408: LIST
25409: PUSH
25410: LD_INT 1
25412: NEG
25413: PUSH
25414: LD_INT 1
25416: PUSH
25417: EMPTY
25418: LIST
25419: LIST
25420: PUSH
25421: LD_INT 2
25423: NEG
25424: PUSH
25425: LD_INT 1
25427: NEG
25428: PUSH
25429: EMPTY
25430: LIST
25431: LIST
25432: PUSH
25433: LD_INT 2
25435: NEG
25436: PUSH
25437: LD_INT 2
25439: NEG
25440: PUSH
25441: EMPTY
25442: LIST
25443: LIST
25444: PUSH
25445: LD_INT 2
25447: NEG
25448: PUSH
25449: LD_INT 3
25451: NEG
25452: PUSH
25453: EMPTY
25454: LIST
25455: LIST
25456: PUSH
25457: LD_INT 1
25459: NEG
25460: PUSH
25461: LD_INT 3
25463: NEG
25464: PUSH
25465: EMPTY
25466: LIST
25467: LIST
25468: PUSH
25469: LD_INT 0
25471: PUSH
25472: LD_INT 3
25474: NEG
25475: PUSH
25476: EMPTY
25477: LIST
25478: LIST
25479: PUSH
25480: LD_INT 1
25482: PUSH
25483: LD_INT 2
25485: NEG
25486: PUSH
25487: EMPTY
25488: LIST
25489: LIST
25490: PUSH
25491: LD_INT 3
25493: PUSH
25494: LD_INT 2
25496: PUSH
25497: EMPTY
25498: LIST
25499: LIST
25500: PUSH
25501: LD_INT 3
25503: PUSH
25504: LD_INT 3
25506: PUSH
25507: EMPTY
25508: LIST
25509: LIST
25510: PUSH
25511: LD_INT 2
25513: PUSH
25514: LD_INT 3
25516: PUSH
25517: EMPTY
25518: LIST
25519: LIST
25520: PUSH
25521: LD_INT 1
25523: PUSH
25524: LD_INT 3
25526: PUSH
25527: EMPTY
25528: LIST
25529: LIST
25530: PUSH
25531: LD_INT 0
25533: PUSH
25534: LD_INT 3
25536: PUSH
25537: EMPTY
25538: LIST
25539: LIST
25540: PUSH
25541: LD_INT 1
25543: NEG
25544: PUSH
25545: LD_INT 2
25547: PUSH
25548: EMPTY
25549: LIST
25550: LIST
25551: PUSH
25552: LD_INT 3
25554: NEG
25555: PUSH
25556: LD_INT 2
25558: NEG
25559: PUSH
25560: EMPTY
25561: LIST
25562: LIST
25563: PUSH
25564: LD_INT 3
25566: NEG
25567: PUSH
25568: LD_INT 3
25570: NEG
25571: PUSH
25572: EMPTY
25573: LIST
25574: LIST
25575: PUSH
25576: EMPTY
25577: LIST
25578: LIST
25579: LIST
25580: LIST
25581: LIST
25582: LIST
25583: LIST
25584: LIST
25585: LIST
25586: LIST
25587: LIST
25588: LIST
25589: LIST
25590: LIST
25591: LIST
25592: LIST
25593: LIST
25594: LIST
25595: LIST
25596: LIST
25597: LIST
25598: LIST
25599: LIST
25600: LIST
25601: LIST
25602: LIST
25603: LIST
25604: LIST
25605: LIST
25606: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
25607: LD_ADDR_VAR 0 43
25611: PUSH
25612: LD_INT 0
25614: PUSH
25615: LD_INT 0
25617: PUSH
25618: EMPTY
25619: LIST
25620: LIST
25621: PUSH
25622: LD_INT 0
25624: PUSH
25625: LD_INT 1
25627: NEG
25628: PUSH
25629: EMPTY
25630: LIST
25631: LIST
25632: PUSH
25633: LD_INT 1
25635: PUSH
25636: LD_INT 0
25638: PUSH
25639: EMPTY
25640: LIST
25641: LIST
25642: PUSH
25643: LD_INT 1
25645: PUSH
25646: LD_INT 1
25648: PUSH
25649: EMPTY
25650: LIST
25651: LIST
25652: PUSH
25653: LD_INT 0
25655: PUSH
25656: LD_INT 1
25658: PUSH
25659: EMPTY
25660: LIST
25661: LIST
25662: PUSH
25663: LD_INT 1
25665: NEG
25666: PUSH
25667: LD_INT 0
25669: PUSH
25670: EMPTY
25671: LIST
25672: LIST
25673: PUSH
25674: LD_INT 1
25676: NEG
25677: PUSH
25678: LD_INT 1
25680: NEG
25681: PUSH
25682: EMPTY
25683: LIST
25684: LIST
25685: PUSH
25686: LD_INT 1
25688: NEG
25689: PUSH
25690: LD_INT 2
25692: NEG
25693: PUSH
25694: EMPTY
25695: LIST
25696: LIST
25697: PUSH
25698: LD_INT 0
25700: PUSH
25701: LD_INT 2
25703: NEG
25704: PUSH
25705: EMPTY
25706: LIST
25707: LIST
25708: PUSH
25709: LD_INT 1
25711: PUSH
25712: LD_INT 1
25714: NEG
25715: PUSH
25716: EMPTY
25717: LIST
25718: LIST
25719: PUSH
25720: LD_INT 2
25722: PUSH
25723: LD_INT 0
25725: PUSH
25726: EMPTY
25727: LIST
25728: LIST
25729: PUSH
25730: LD_INT 2
25732: PUSH
25733: LD_INT 1
25735: PUSH
25736: EMPTY
25737: LIST
25738: LIST
25739: PUSH
25740: LD_INT 1
25742: PUSH
25743: LD_INT 2
25745: PUSH
25746: EMPTY
25747: LIST
25748: LIST
25749: PUSH
25750: LD_INT 0
25752: PUSH
25753: LD_INT 2
25755: PUSH
25756: EMPTY
25757: LIST
25758: LIST
25759: PUSH
25760: LD_INT 1
25762: NEG
25763: PUSH
25764: LD_INT 1
25766: PUSH
25767: EMPTY
25768: LIST
25769: LIST
25770: PUSH
25771: LD_INT 2
25773: NEG
25774: PUSH
25775: LD_INT 0
25777: PUSH
25778: EMPTY
25779: LIST
25780: LIST
25781: PUSH
25782: LD_INT 2
25784: NEG
25785: PUSH
25786: LD_INT 1
25788: NEG
25789: PUSH
25790: EMPTY
25791: LIST
25792: LIST
25793: PUSH
25794: LD_INT 1
25796: NEG
25797: PUSH
25798: LD_INT 3
25800: NEG
25801: PUSH
25802: EMPTY
25803: LIST
25804: LIST
25805: PUSH
25806: LD_INT 0
25808: PUSH
25809: LD_INT 3
25811: NEG
25812: PUSH
25813: EMPTY
25814: LIST
25815: LIST
25816: PUSH
25817: LD_INT 1
25819: PUSH
25820: LD_INT 2
25822: NEG
25823: PUSH
25824: EMPTY
25825: LIST
25826: LIST
25827: PUSH
25828: LD_INT 2
25830: PUSH
25831: LD_INT 1
25833: NEG
25834: PUSH
25835: EMPTY
25836: LIST
25837: LIST
25838: PUSH
25839: LD_INT 3
25841: PUSH
25842: LD_INT 0
25844: PUSH
25845: EMPTY
25846: LIST
25847: LIST
25848: PUSH
25849: LD_INT 3
25851: PUSH
25852: LD_INT 1
25854: PUSH
25855: EMPTY
25856: LIST
25857: LIST
25858: PUSH
25859: LD_INT 1
25861: PUSH
25862: LD_INT 3
25864: PUSH
25865: EMPTY
25866: LIST
25867: LIST
25868: PUSH
25869: LD_INT 0
25871: PUSH
25872: LD_INT 3
25874: PUSH
25875: EMPTY
25876: LIST
25877: LIST
25878: PUSH
25879: LD_INT 1
25881: NEG
25882: PUSH
25883: LD_INT 2
25885: PUSH
25886: EMPTY
25887: LIST
25888: LIST
25889: PUSH
25890: LD_INT 2
25892: NEG
25893: PUSH
25894: LD_INT 1
25896: PUSH
25897: EMPTY
25898: LIST
25899: LIST
25900: PUSH
25901: LD_INT 3
25903: NEG
25904: PUSH
25905: LD_INT 0
25907: PUSH
25908: EMPTY
25909: LIST
25910: LIST
25911: PUSH
25912: LD_INT 3
25914: NEG
25915: PUSH
25916: LD_INT 1
25918: NEG
25919: PUSH
25920: EMPTY
25921: LIST
25922: LIST
25923: PUSH
25924: EMPTY
25925: LIST
25926: LIST
25927: LIST
25928: LIST
25929: LIST
25930: LIST
25931: LIST
25932: LIST
25933: LIST
25934: LIST
25935: LIST
25936: LIST
25937: LIST
25938: LIST
25939: LIST
25940: LIST
25941: LIST
25942: LIST
25943: LIST
25944: LIST
25945: LIST
25946: LIST
25947: LIST
25948: LIST
25949: LIST
25950: LIST
25951: LIST
25952: LIST
25953: LIST
25954: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
25955: LD_ADDR_VAR 0 44
25959: PUSH
25960: LD_INT 0
25962: PUSH
25963: LD_INT 0
25965: PUSH
25966: EMPTY
25967: LIST
25968: LIST
25969: PUSH
25970: LD_INT 0
25972: PUSH
25973: LD_INT 1
25975: NEG
25976: PUSH
25977: EMPTY
25978: LIST
25979: LIST
25980: PUSH
25981: LD_INT 1
25983: PUSH
25984: LD_INT 0
25986: PUSH
25987: EMPTY
25988: LIST
25989: LIST
25990: PUSH
25991: LD_INT 1
25993: PUSH
25994: LD_INT 1
25996: PUSH
25997: EMPTY
25998: LIST
25999: LIST
26000: PUSH
26001: LD_INT 0
26003: PUSH
26004: LD_INT 1
26006: PUSH
26007: EMPTY
26008: LIST
26009: LIST
26010: PUSH
26011: LD_INT 1
26013: NEG
26014: PUSH
26015: LD_INT 0
26017: PUSH
26018: EMPTY
26019: LIST
26020: LIST
26021: PUSH
26022: LD_INT 1
26024: NEG
26025: PUSH
26026: LD_INT 1
26028: NEG
26029: PUSH
26030: EMPTY
26031: LIST
26032: LIST
26033: PUSH
26034: LD_INT 1
26036: NEG
26037: PUSH
26038: LD_INT 2
26040: NEG
26041: PUSH
26042: EMPTY
26043: LIST
26044: LIST
26045: PUSH
26046: LD_INT 1
26048: PUSH
26049: LD_INT 1
26051: NEG
26052: PUSH
26053: EMPTY
26054: LIST
26055: LIST
26056: PUSH
26057: LD_INT 2
26059: PUSH
26060: LD_INT 0
26062: PUSH
26063: EMPTY
26064: LIST
26065: LIST
26066: PUSH
26067: LD_INT 2
26069: PUSH
26070: LD_INT 1
26072: PUSH
26073: EMPTY
26074: LIST
26075: LIST
26076: PUSH
26077: LD_INT 2
26079: PUSH
26080: LD_INT 2
26082: PUSH
26083: EMPTY
26084: LIST
26085: LIST
26086: PUSH
26087: LD_INT 1
26089: PUSH
26090: LD_INT 2
26092: PUSH
26093: EMPTY
26094: LIST
26095: LIST
26096: PUSH
26097: LD_INT 1
26099: NEG
26100: PUSH
26101: LD_INT 1
26103: PUSH
26104: EMPTY
26105: LIST
26106: LIST
26107: PUSH
26108: LD_INT 2
26110: NEG
26111: PUSH
26112: LD_INT 0
26114: PUSH
26115: EMPTY
26116: LIST
26117: LIST
26118: PUSH
26119: LD_INT 2
26121: NEG
26122: PUSH
26123: LD_INT 1
26125: NEG
26126: PUSH
26127: EMPTY
26128: LIST
26129: LIST
26130: PUSH
26131: LD_INT 2
26133: NEG
26134: PUSH
26135: LD_INT 2
26137: NEG
26138: PUSH
26139: EMPTY
26140: LIST
26141: LIST
26142: PUSH
26143: LD_INT 2
26145: NEG
26146: PUSH
26147: LD_INT 3
26149: NEG
26150: PUSH
26151: EMPTY
26152: LIST
26153: LIST
26154: PUSH
26155: LD_INT 2
26157: PUSH
26158: LD_INT 1
26160: NEG
26161: PUSH
26162: EMPTY
26163: LIST
26164: LIST
26165: PUSH
26166: LD_INT 3
26168: PUSH
26169: LD_INT 0
26171: PUSH
26172: EMPTY
26173: LIST
26174: LIST
26175: PUSH
26176: LD_INT 3
26178: PUSH
26179: LD_INT 1
26181: PUSH
26182: EMPTY
26183: LIST
26184: LIST
26185: PUSH
26186: LD_INT 3
26188: PUSH
26189: LD_INT 2
26191: PUSH
26192: EMPTY
26193: LIST
26194: LIST
26195: PUSH
26196: LD_INT 3
26198: PUSH
26199: LD_INT 3
26201: PUSH
26202: EMPTY
26203: LIST
26204: LIST
26205: PUSH
26206: LD_INT 2
26208: PUSH
26209: LD_INT 3
26211: PUSH
26212: EMPTY
26213: LIST
26214: LIST
26215: PUSH
26216: LD_INT 2
26218: NEG
26219: PUSH
26220: LD_INT 1
26222: PUSH
26223: EMPTY
26224: LIST
26225: LIST
26226: PUSH
26227: LD_INT 3
26229: NEG
26230: PUSH
26231: LD_INT 0
26233: PUSH
26234: EMPTY
26235: LIST
26236: LIST
26237: PUSH
26238: LD_INT 3
26240: NEG
26241: PUSH
26242: LD_INT 1
26244: NEG
26245: PUSH
26246: EMPTY
26247: LIST
26248: LIST
26249: PUSH
26250: LD_INT 3
26252: NEG
26253: PUSH
26254: LD_INT 2
26256: NEG
26257: PUSH
26258: EMPTY
26259: LIST
26260: LIST
26261: PUSH
26262: LD_INT 3
26264: NEG
26265: PUSH
26266: LD_INT 3
26268: NEG
26269: PUSH
26270: EMPTY
26271: LIST
26272: LIST
26273: PUSH
26274: EMPTY
26275: LIST
26276: LIST
26277: LIST
26278: LIST
26279: LIST
26280: LIST
26281: LIST
26282: LIST
26283: LIST
26284: LIST
26285: LIST
26286: LIST
26287: LIST
26288: LIST
26289: LIST
26290: LIST
26291: LIST
26292: LIST
26293: LIST
26294: LIST
26295: LIST
26296: LIST
26297: LIST
26298: LIST
26299: LIST
26300: LIST
26301: LIST
26302: LIST
26303: LIST
26304: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
26305: LD_ADDR_VAR 0 45
26309: PUSH
26310: LD_INT 0
26312: PUSH
26313: LD_INT 0
26315: PUSH
26316: EMPTY
26317: LIST
26318: LIST
26319: PUSH
26320: LD_INT 0
26322: PUSH
26323: LD_INT 1
26325: NEG
26326: PUSH
26327: EMPTY
26328: LIST
26329: LIST
26330: PUSH
26331: LD_INT 1
26333: PUSH
26334: LD_INT 0
26336: PUSH
26337: EMPTY
26338: LIST
26339: LIST
26340: PUSH
26341: LD_INT 1
26343: PUSH
26344: LD_INT 1
26346: PUSH
26347: EMPTY
26348: LIST
26349: LIST
26350: PUSH
26351: LD_INT 0
26353: PUSH
26354: LD_INT 1
26356: PUSH
26357: EMPTY
26358: LIST
26359: LIST
26360: PUSH
26361: LD_INT 1
26363: NEG
26364: PUSH
26365: LD_INT 0
26367: PUSH
26368: EMPTY
26369: LIST
26370: LIST
26371: PUSH
26372: LD_INT 1
26374: NEG
26375: PUSH
26376: LD_INT 1
26378: NEG
26379: PUSH
26380: EMPTY
26381: LIST
26382: LIST
26383: PUSH
26384: LD_INT 1
26386: NEG
26387: PUSH
26388: LD_INT 2
26390: NEG
26391: PUSH
26392: EMPTY
26393: LIST
26394: LIST
26395: PUSH
26396: LD_INT 0
26398: PUSH
26399: LD_INT 2
26401: NEG
26402: PUSH
26403: EMPTY
26404: LIST
26405: LIST
26406: PUSH
26407: LD_INT 1
26409: PUSH
26410: LD_INT 1
26412: NEG
26413: PUSH
26414: EMPTY
26415: LIST
26416: LIST
26417: PUSH
26418: LD_INT 2
26420: PUSH
26421: LD_INT 1
26423: PUSH
26424: EMPTY
26425: LIST
26426: LIST
26427: PUSH
26428: LD_INT 2
26430: PUSH
26431: LD_INT 2
26433: PUSH
26434: EMPTY
26435: LIST
26436: LIST
26437: PUSH
26438: LD_INT 1
26440: PUSH
26441: LD_INT 2
26443: PUSH
26444: EMPTY
26445: LIST
26446: LIST
26447: PUSH
26448: LD_INT 0
26450: PUSH
26451: LD_INT 2
26453: PUSH
26454: EMPTY
26455: LIST
26456: LIST
26457: PUSH
26458: LD_INT 1
26460: NEG
26461: PUSH
26462: LD_INT 1
26464: PUSH
26465: EMPTY
26466: LIST
26467: LIST
26468: PUSH
26469: LD_INT 2
26471: NEG
26472: PUSH
26473: LD_INT 1
26475: NEG
26476: PUSH
26477: EMPTY
26478: LIST
26479: LIST
26480: PUSH
26481: LD_INT 2
26483: NEG
26484: PUSH
26485: LD_INT 2
26487: NEG
26488: PUSH
26489: EMPTY
26490: LIST
26491: LIST
26492: PUSH
26493: LD_INT 2
26495: NEG
26496: PUSH
26497: LD_INT 3
26499: NEG
26500: PUSH
26501: EMPTY
26502: LIST
26503: LIST
26504: PUSH
26505: LD_INT 1
26507: NEG
26508: PUSH
26509: LD_INT 3
26511: NEG
26512: PUSH
26513: EMPTY
26514: LIST
26515: LIST
26516: PUSH
26517: LD_INT 0
26519: PUSH
26520: LD_INT 3
26522: NEG
26523: PUSH
26524: EMPTY
26525: LIST
26526: LIST
26527: PUSH
26528: LD_INT 1
26530: PUSH
26531: LD_INT 2
26533: NEG
26534: PUSH
26535: EMPTY
26536: LIST
26537: LIST
26538: PUSH
26539: LD_INT 3
26541: PUSH
26542: LD_INT 2
26544: PUSH
26545: EMPTY
26546: LIST
26547: LIST
26548: PUSH
26549: LD_INT 3
26551: PUSH
26552: LD_INT 3
26554: PUSH
26555: EMPTY
26556: LIST
26557: LIST
26558: PUSH
26559: LD_INT 2
26561: PUSH
26562: LD_INT 3
26564: PUSH
26565: EMPTY
26566: LIST
26567: LIST
26568: PUSH
26569: LD_INT 1
26571: PUSH
26572: LD_INT 3
26574: PUSH
26575: EMPTY
26576: LIST
26577: LIST
26578: PUSH
26579: LD_INT 0
26581: PUSH
26582: LD_INT 3
26584: PUSH
26585: EMPTY
26586: LIST
26587: LIST
26588: PUSH
26589: LD_INT 1
26591: NEG
26592: PUSH
26593: LD_INT 2
26595: PUSH
26596: EMPTY
26597: LIST
26598: LIST
26599: PUSH
26600: LD_INT 3
26602: NEG
26603: PUSH
26604: LD_INT 2
26606: NEG
26607: PUSH
26608: EMPTY
26609: LIST
26610: LIST
26611: PUSH
26612: LD_INT 3
26614: NEG
26615: PUSH
26616: LD_INT 3
26618: NEG
26619: PUSH
26620: EMPTY
26621: LIST
26622: LIST
26623: PUSH
26624: EMPTY
26625: LIST
26626: LIST
26627: LIST
26628: LIST
26629: LIST
26630: LIST
26631: LIST
26632: LIST
26633: LIST
26634: LIST
26635: LIST
26636: LIST
26637: LIST
26638: LIST
26639: LIST
26640: LIST
26641: LIST
26642: LIST
26643: LIST
26644: LIST
26645: LIST
26646: LIST
26647: LIST
26648: LIST
26649: LIST
26650: LIST
26651: LIST
26652: LIST
26653: LIST
26654: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
26655: LD_ADDR_VAR 0 46
26659: PUSH
26660: LD_INT 0
26662: PUSH
26663: LD_INT 0
26665: PUSH
26666: EMPTY
26667: LIST
26668: LIST
26669: PUSH
26670: LD_INT 0
26672: PUSH
26673: LD_INT 1
26675: NEG
26676: PUSH
26677: EMPTY
26678: LIST
26679: LIST
26680: PUSH
26681: LD_INT 1
26683: PUSH
26684: LD_INT 0
26686: PUSH
26687: EMPTY
26688: LIST
26689: LIST
26690: PUSH
26691: LD_INT 1
26693: PUSH
26694: LD_INT 1
26696: PUSH
26697: EMPTY
26698: LIST
26699: LIST
26700: PUSH
26701: LD_INT 0
26703: PUSH
26704: LD_INT 1
26706: PUSH
26707: EMPTY
26708: LIST
26709: LIST
26710: PUSH
26711: LD_INT 1
26713: NEG
26714: PUSH
26715: LD_INT 0
26717: PUSH
26718: EMPTY
26719: LIST
26720: LIST
26721: PUSH
26722: LD_INT 1
26724: NEG
26725: PUSH
26726: LD_INT 1
26728: NEG
26729: PUSH
26730: EMPTY
26731: LIST
26732: LIST
26733: PUSH
26734: LD_INT 1
26736: NEG
26737: PUSH
26738: LD_INT 2
26740: NEG
26741: PUSH
26742: EMPTY
26743: LIST
26744: LIST
26745: PUSH
26746: LD_INT 0
26748: PUSH
26749: LD_INT 2
26751: NEG
26752: PUSH
26753: EMPTY
26754: LIST
26755: LIST
26756: PUSH
26757: LD_INT 1
26759: PUSH
26760: LD_INT 1
26762: NEG
26763: PUSH
26764: EMPTY
26765: LIST
26766: LIST
26767: PUSH
26768: LD_INT 2
26770: PUSH
26771: LD_INT 0
26773: PUSH
26774: EMPTY
26775: LIST
26776: LIST
26777: PUSH
26778: LD_INT 2
26780: PUSH
26781: LD_INT 1
26783: PUSH
26784: EMPTY
26785: LIST
26786: LIST
26787: PUSH
26788: LD_INT 1
26790: PUSH
26791: LD_INT 2
26793: PUSH
26794: EMPTY
26795: LIST
26796: LIST
26797: PUSH
26798: LD_INT 0
26800: PUSH
26801: LD_INT 2
26803: PUSH
26804: EMPTY
26805: LIST
26806: LIST
26807: PUSH
26808: LD_INT 1
26810: NEG
26811: PUSH
26812: LD_INT 1
26814: PUSH
26815: EMPTY
26816: LIST
26817: LIST
26818: PUSH
26819: LD_INT 2
26821: NEG
26822: PUSH
26823: LD_INT 0
26825: PUSH
26826: EMPTY
26827: LIST
26828: LIST
26829: PUSH
26830: LD_INT 2
26832: NEG
26833: PUSH
26834: LD_INT 1
26836: NEG
26837: PUSH
26838: EMPTY
26839: LIST
26840: LIST
26841: PUSH
26842: LD_INT 1
26844: NEG
26845: PUSH
26846: LD_INT 3
26848: NEG
26849: PUSH
26850: EMPTY
26851: LIST
26852: LIST
26853: PUSH
26854: LD_INT 0
26856: PUSH
26857: LD_INT 3
26859: NEG
26860: PUSH
26861: EMPTY
26862: LIST
26863: LIST
26864: PUSH
26865: LD_INT 1
26867: PUSH
26868: LD_INT 2
26870: NEG
26871: PUSH
26872: EMPTY
26873: LIST
26874: LIST
26875: PUSH
26876: LD_INT 2
26878: PUSH
26879: LD_INT 1
26881: NEG
26882: PUSH
26883: EMPTY
26884: LIST
26885: LIST
26886: PUSH
26887: LD_INT 3
26889: PUSH
26890: LD_INT 0
26892: PUSH
26893: EMPTY
26894: LIST
26895: LIST
26896: PUSH
26897: LD_INT 3
26899: PUSH
26900: LD_INT 1
26902: PUSH
26903: EMPTY
26904: LIST
26905: LIST
26906: PUSH
26907: LD_INT 1
26909: PUSH
26910: LD_INT 3
26912: PUSH
26913: EMPTY
26914: LIST
26915: LIST
26916: PUSH
26917: LD_INT 0
26919: PUSH
26920: LD_INT 3
26922: PUSH
26923: EMPTY
26924: LIST
26925: LIST
26926: PUSH
26927: LD_INT 1
26929: NEG
26930: PUSH
26931: LD_INT 2
26933: PUSH
26934: EMPTY
26935: LIST
26936: LIST
26937: PUSH
26938: LD_INT 2
26940: NEG
26941: PUSH
26942: LD_INT 1
26944: PUSH
26945: EMPTY
26946: LIST
26947: LIST
26948: PUSH
26949: LD_INT 3
26951: NEG
26952: PUSH
26953: LD_INT 0
26955: PUSH
26956: EMPTY
26957: LIST
26958: LIST
26959: PUSH
26960: LD_INT 3
26962: NEG
26963: PUSH
26964: LD_INT 1
26966: NEG
26967: PUSH
26968: EMPTY
26969: LIST
26970: LIST
26971: PUSH
26972: EMPTY
26973: LIST
26974: LIST
26975: LIST
26976: LIST
26977: LIST
26978: LIST
26979: LIST
26980: LIST
26981: LIST
26982: LIST
26983: LIST
26984: LIST
26985: LIST
26986: LIST
26987: LIST
26988: LIST
26989: LIST
26990: LIST
26991: LIST
26992: LIST
26993: LIST
26994: LIST
26995: LIST
26996: LIST
26997: LIST
26998: LIST
26999: LIST
27000: LIST
27001: LIST
27002: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27003: LD_ADDR_VAR 0 47
27007: PUSH
27008: LD_INT 0
27010: PUSH
27011: LD_INT 0
27013: PUSH
27014: EMPTY
27015: LIST
27016: LIST
27017: PUSH
27018: LD_INT 0
27020: PUSH
27021: LD_INT 1
27023: NEG
27024: PUSH
27025: EMPTY
27026: LIST
27027: LIST
27028: PUSH
27029: LD_INT 1
27031: PUSH
27032: LD_INT 0
27034: PUSH
27035: EMPTY
27036: LIST
27037: LIST
27038: PUSH
27039: LD_INT 1
27041: PUSH
27042: LD_INT 1
27044: PUSH
27045: EMPTY
27046: LIST
27047: LIST
27048: PUSH
27049: LD_INT 0
27051: PUSH
27052: LD_INT 1
27054: PUSH
27055: EMPTY
27056: LIST
27057: LIST
27058: PUSH
27059: LD_INT 1
27061: NEG
27062: PUSH
27063: LD_INT 0
27065: PUSH
27066: EMPTY
27067: LIST
27068: LIST
27069: PUSH
27070: LD_INT 1
27072: NEG
27073: PUSH
27074: LD_INT 1
27076: NEG
27077: PUSH
27078: EMPTY
27079: LIST
27080: LIST
27081: PUSH
27082: LD_INT 1
27084: NEG
27085: PUSH
27086: LD_INT 2
27088: NEG
27089: PUSH
27090: EMPTY
27091: LIST
27092: LIST
27093: PUSH
27094: LD_INT 0
27096: PUSH
27097: LD_INT 2
27099: NEG
27100: PUSH
27101: EMPTY
27102: LIST
27103: LIST
27104: PUSH
27105: LD_INT 1
27107: PUSH
27108: LD_INT 1
27110: NEG
27111: PUSH
27112: EMPTY
27113: LIST
27114: LIST
27115: PUSH
27116: LD_INT 2
27118: NEG
27119: PUSH
27120: LD_INT 1
27122: NEG
27123: PUSH
27124: EMPTY
27125: LIST
27126: LIST
27127: PUSH
27128: LD_INT 2
27130: NEG
27131: PUSH
27132: LD_INT 2
27134: NEG
27135: PUSH
27136: EMPTY
27137: LIST
27138: LIST
27139: PUSH
27140: EMPTY
27141: LIST
27142: LIST
27143: LIST
27144: LIST
27145: LIST
27146: LIST
27147: LIST
27148: LIST
27149: LIST
27150: LIST
27151: LIST
27152: LIST
27153: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
27154: LD_ADDR_VAR 0 48
27158: PUSH
27159: LD_INT 0
27161: PUSH
27162: LD_INT 0
27164: PUSH
27165: EMPTY
27166: LIST
27167: LIST
27168: PUSH
27169: LD_INT 0
27171: PUSH
27172: LD_INT 1
27174: NEG
27175: PUSH
27176: EMPTY
27177: LIST
27178: LIST
27179: PUSH
27180: LD_INT 1
27182: PUSH
27183: LD_INT 0
27185: PUSH
27186: EMPTY
27187: LIST
27188: LIST
27189: PUSH
27190: LD_INT 1
27192: PUSH
27193: LD_INT 1
27195: PUSH
27196: EMPTY
27197: LIST
27198: LIST
27199: PUSH
27200: LD_INT 0
27202: PUSH
27203: LD_INT 1
27205: PUSH
27206: EMPTY
27207: LIST
27208: LIST
27209: PUSH
27210: LD_INT 1
27212: NEG
27213: PUSH
27214: LD_INT 0
27216: PUSH
27217: EMPTY
27218: LIST
27219: LIST
27220: PUSH
27221: LD_INT 1
27223: NEG
27224: PUSH
27225: LD_INT 1
27227: NEG
27228: PUSH
27229: EMPTY
27230: LIST
27231: LIST
27232: PUSH
27233: LD_INT 1
27235: NEG
27236: PUSH
27237: LD_INT 2
27239: NEG
27240: PUSH
27241: EMPTY
27242: LIST
27243: LIST
27244: PUSH
27245: LD_INT 0
27247: PUSH
27248: LD_INT 2
27250: NEG
27251: PUSH
27252: EMPTY
27253: LIST
27254: LIST
27255: PUSH
27256: LD_INT 1
27258: PUSH
27259: LD_INT 1
27261: NEG
27262: PUSH
27263: EMPTY
27264: LIST
27265: LIST
27266: PUSH
27267: LD_INT 2
27269: PUSH
27270: LD_INT 0
27272: PUSH
27273: EMPTY
27274: LIST
27275: LIST
27276: PUSH
27277: LD_INT 2
27279: PUSH
27280: LD_INT 1
27282: PUSH
27283: EMPTY
27284: LIST
27285: LIST
27286: PUSH
27287: EMPTY
27288: LIST
27289: LIST
27290: LIST
27291: LIST
27292: LIST
27293: LIST
27294: LIST
27295: LIST
27296: LIST
27297: LIST
27298: LIST
27299: LIST
27300: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
27301: LD_ADDR_VAR 0 49
27305: PUSH
27306: LD_INT 0
27308: PUSH
27309: LD_INT 0
27311: PUSH
27312: EMPTY
27313: LIST
27314: LIST
27315: PUSH
27316: LD_INT 0
27318: PUSH
27319: LD_INT 1
27321: NEG
27322: PUSH
27323: EMPTY
27324: LIST
27325: LIST
27326: PUSH
27327: LD_INT 1
27329: PUSH
27330: LD_INT 0
27332: PUSH
27333: EMPTY
27334: LIST
27335: LIST
27336: PUSH
27337: LD_INT 1
27339: PUSH
27340: LD_INT 1
27342: PUSH
27343: EMPTY
27344: LIST
27345: LIST
27346: PUSH
27347: LD_INT 0
27349: PUSH
27350: LD_INT 1
27352: PUSH
27353: EMPTY
27354: LIST
27355: LIST
27356: PUSH
27357: LD_INT 1
27359: NEG
27360: PUSH
27361: LD_INT 0
27363: PUSH
27364: EMPTY
27365: LIST
27366: LIST
27367: PUSH
27368: LD_INT 1
27370: NEG
27371: PUSH
27372: LD_INT 1
27374: NEG
27375: PUSH
27376: EMPTY
27377: LIST
27378: LIST
27379: PUSH
27380: LD_INT 1
27382: PUSH
27383: LD_INT 1
27385: NEG
27386: PUSH
27387: EMPTY
27388: LIST
27389: LIST
27390: PUSH
27391: LD_INT 2
27393: PUSH
27394: LD_INT 0
27396: PUSH
27397: EMPTY
27398: LIST
27399: LIST
27400: PUSH
27401: LD_INT 2
27403: PUSH
27404: LD_INT 1
27406: PUSH
27407: EMPTY
27408: LIST
27409: LIST
27410: PUSH
27411: LD_INT 2
27413: PUSH
27414: LD_INT 2
27416: PUSH
27417: EMPTY
27418: LIST
27419: LIST
27420: PUSH
27421: LD_INT 1
27423: PUSH
27424: LD_INT 2
27426: PUSH
27427: EMPTY
27428: LIST
27429: LIST
27430: PUSH
27431: EMPTY
27432: LIST
27433: LIST
27434: LIST
27435: LIST
27436: LIST
27437: LIST
27438: LIST
27439: LIST
27440: LIST
27441: LIST
27442: LIST
27443: LIST
27444: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
27445: LD_ADDR_VAR 0 50
27449: PUSH
27450: LD_INT 0
27452: PUSH
27453: LD_INT 0
27455: PUSH
27456: EMPTY
27457: LIST
27458: LIST
27459: PUSH
27460: LD_INT 0
27462: PUSH
27463: LD_INT 1
27465: NEG
27466: PUSH
27467: EMPTY
27468: LIST
27469: LIST
27470: PUSH
27471: LD_INT 1
27473: PUSH
27474: LD_INT 0
27476: PUSH
27477: EMPTY
27478: LIST
27479: LIST
27480: PUSH
27481: LD_INT 1
27483: PUSH
27484: LD_INT 1
27486: PUSH
27487: EMPTY
27488: LIST
27489: LIST
27490: PUSH
27491: LD_INT 0
27493: PUSH
27494: LD_INT 1
27496: PUSH
27497: EMPTY
27498: LIST
27499: LIST
27500: PUSH
27501: LD_INT 1
27503: NEG
27504: PUSH
27505: LD_INT 0
27507: PUSH
27508: EMPTY
27509: LIST
27510: LIST
27511: PUSH
27512: LD_INT 1
27514: NEG
27515: PUSH
27516: LD_INT 1
27518: NEG
27519: PUSH
27520: EMPTY
27521: LIST
27522: LIST
27523: PUSH
27524: LD_INT 2
27526: PUSH
27527: LD_INT 1
27529: PUSH
27530: EMPTY
27531: LIST
27532: LIST
27533: PUSH
27534: LD_INT 2
27536: PUSH
27537: LD_INT 2
27539: PUSH
27540: EMPTY
27541: LIST
27542: LIST
27543: PUSH
27544: LD_INT 1
27546: PUSH
27547: LD_INT 2
27549: PUSH
27550: EMPTY
27551: LIST
27552: LIST
27553: PUSH
27554: LD_INT 0
27556: PUSH
27557: LD_INT 2
27559: PUSH
27560: EMPTY
27561: LIST
27562: LIST
27563: PUSH
27564: LD_INT 1
27566: NEG
27567: PUSH
27568: LD_INT 1
27570: PUSH
27571: EMPTY
27572: LIST
27573: LIST
27574: PUSH
27575: EMPTY
27576: LIST
27577: LIST
27578: LIST
27579: LIST
27580: LIST
27581: LIST
27582: LIST
27583: LIST
27584: LIST
27585: LIST
27586: LIST
27587: LIST
27588: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
27589: LD_ADDR_VAR 0 51
27593: PUSH
27594: LD_INT 0
27596: PUSH
27597: LD_INT 0
27599: PUSH
27600: EMPTY
27601: LIST
27602: LIST
27603: PUSH
27604: LD_INT 0
27606: PUSH
27607: LD_INT 1
27609: NEG
27610: PUSH
27611: EMPTY
27612: LIST
27613: LIST
27614: PUSH
27615: LD_INT 1
27617: PUSH
27618: LD_INT 0
27620: PUSH
27621: EMPTY
27622: LIST
27623: LIST
27624: PUSH
27625: LD_INT 1
27627: PUSH
27628: LD_INT 1
27630: PUSH
27631: EMPTY
27632: LIST
27633: LIST
27634: PUSH
27635: LD_INT 0
27637: PUSH
27638: LD_INT 1
27640: PUSH
27641: EMPTY
27642: LIST
27643: LIST
27644: PUSH
27645: LD_INT 1
27647: NEG
27648: PUSH
27649: LD_INT 0
27651: PUSH
27652: EMPTY
27653: LIST
27654: LIST
27655: PUSH
27656: LD_INT 1
27658: NEG
27659: PUSH
27660: LD_INT 1
27662: NEG
27663: PUSH
27664: EMPTY
27665: LIST
27666: LIST
27667: PUSH
27668: LD_INT 1
27670: PUSH
27671: LD_INT 2
27673: PUSH
27674: EMPTY
27675: LIST
27676: LIST
27677: PUSH
27678: LD_INT 0
27680: PUSH
27681: LD_INT 2
27683: PUSH
27684: EMPTY
27685: LIST
27686: LIST
27687: PUSH
27688: LD_INT 1
27690: NEG
27691: PUSH
27692: LD_INT 1
27694: PUSH
27695: EMPTY
27696: LIST
27697: LIST
27698: PUSH
27699: LD_INT 2
27701: NEG
27702: PUSH
27703: LD_INT 0
27705: PUSH
27706: EMPTY
27707: LIST
27708: LIST
27709: PUSH
27710: LD_INT 2
27712: NEG
27713: PUSH
27714: LD_INT 1
27716: NEG
27717: PUSH
27718: EMPTY
27719: LIST
27720: LIST
27721: PUSH
27722: EMPTY
27723: LIST
27724: LIST
27725: LIST
27726: LIST
27727: LIST
27728: LIST
27729: LIST
27730: LIST
27731: LIST
27732: LIST
27733: LIST
27734: LIST
27735: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27736: LD_ADDR_VAR 0 52
27740: PUSH
27741: LD_INT 0
27743: PUSH
27744: LD_INT 0
27746: PUSH
27747: EMPTY
27748: LIST
27749: LIST
27750: PUSH
27751: LD_INT 0
27753: PUSH
27754: LD_INT 1
27756: NEG
27757: PUSH
27758: EMPTY
27759: LIST
27760: LIST
27761: PUSH
27762: LD_INT 1
27764: PUSH
27765: LD_INT 0
27767: PUSH
27768: EMPTY
27769: LIST
27770: LIST
27771: PUSH
27772: LD_INT 1
27774: PUSH
27775: LD_INT 1
27777: PUSH
27778: EMPTY
27779: LIST
27780: LIST
27781: PUSH
27782: LD_INT 0
27784: PUSH
27785: LD_INT 1
27787: PUSH
27788: EMPTY
27789: LIST
27790: LIST
27791: PUSH
27792: LD_INT 1
27794: NEG
27795: PUSH
27796: LD_INT 0
27798: PUSH
27799: EMPTY
27800: LIST
27801: LIST
27802: PUSH
27803: LD_INT 1
27805: NEG
27806: PUSH
27807: LD_INT 1
27809: NEG
27810: PUSH
27811: EMPTY
27812: LIST
27813: LIST
27814: PUSH
27815: LD_INT 1
27817: NEG
27818: PUSH
27819: LD_INT 2
27821: NEG
27822: PUSH
27823: EMPTY
27824: LIST
27825: LIST
27826: PUSH
27827: LD_INT 1
27829: NEG
27830: PUSH
27831: LD_INT 1
27833: PUSH
27834: EMPTY
27835: LIST
27836: LIST
27837: PUSH
27838: LD_INT 2
27840: NEG
27841: PUSH
27842: LD_INT 0
27844: PUSH
27845: EMPTY
27846: LIST
27847: LIST
27848: PUSH
27849: LD_INT 2
27851: NEG
27852: PUSH
27853: LD_INT 1
27855: NEG
27856: PUSH
27857: EMPTY
27858: LIST
27859: LIST
27860: PUSH
27861: LD_INT 2
27863: NEG
27864: PUSH
27865: LD_INT 2
27867: NEG
27868: PUSH
27869: EMPTY
27870: LIST
27871: LIST
27872: PUSH
27873: EMPTY
27874: LIST
27875: LIST
27876: LIST
27877: LIST
27878: LIST
27879: LIST
27880: LIST
27881: LIST
27882: LIST
27883: LIST
27884: LIST
27885: LIST
27886: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27887: LD_ADDR_VAR 0 53
27891: PUSH
27892: LD_INT 0
27894: PUSH
27895: LD_INT 0
27897: PUSH
27898: EMPTY
27899: LIST
27900: LIST
27901: PUSH
27902: LD_INT 0
27904: PUSH
27905: LD_INT 1
27907: NEG
27908: PUSH
27909: EMPTY
27910: LIST
27911: LIST
27912: PUSH
27913: LD_INT 1
27915: PUSH
27916: LD_INT 0
27918: PUSH
27919: EMPTY
27920: LIST
27921: LIST
27922: PUSH
27923: LD_INT 1
27925: PUSH
27926: LD_INT 1
27928: PUSH
27929: EMPTY
27930: LIST
27931: LIST
27932: PUSH
27933: LD_INT 0
27935: PUSH
27936: LD_INT 1
27938: PUSH
27939: EMPTY
27940: LIST
27941: LIST
27942: PUSH
27943: LD_INT 1
27945: NEG
27946: PUSH
27947: LD_INT 0
27949: PUSH
27950: EMPTY
27951: LIST
27952: LIST
27953: PUSH
27954: LD_INT 1
27956: NEG
27957: PUSH
27958: LD_INT 1
27960: NEG
27961: PUSH
27962: EMPTY
27963: LIST
27964: LIST
27965: PUSH
27966: LD_INT 1
27968: NEG
27969: PUSH
27970: LD_INT 2
27972: NEG
27973: PUSH
27974: EMPTY
27975: LIST
27976: LIST
27977: PUSH
27978: LD_INT 0
27980: PUSH
27981: LD_INT 2
27983: NEG
27984: PUSH
27985: EMPTY
27986: LIST
27987: LIST
27988: PUSH
27989: LD_INT 1
27991: PUSH
27992: LD_INT 1
27994: NEG
27995: PUSH
27996: EMPTY
27997: LIST
27998: LIST
27999: PUSH
28000: LD_INT 2
28002: PUSH
28003: LD_INT 0
28005: PUSH
28006: EMPTY
28007: LIST
28008: LIST
28009: PUSH
28010: LD_INT 2
28012: PUSH
28013: LD_INT 1
28015: PUSH
28016: EMPTY
28017: LIST
28018: LIST
28019: PUSH
28020: LD_INT 2
28022: PUSH
28023: LD_INT 2
28025: PUSH
28026: EMPTY
28027: LIST
28028: LIST
28029: PUSH
28030: LD_INT 1
28032: PUSH
28033: LD_INT 2
28035: PUSH
28036: EMPTY
28037: LIST
28038: LIST
28039: PUSH
28040: LD_INT 0
28042: PUSH
28043: LD_INT 2
28045: PUSH
28046: EMPTY
28047: LIST
28048: LIST
28049: PUSH
28050: LD_INT 1
28052: NEG
28053: PUSH
28054: LD_INT 1
28056: PUSH
28057: EMPTY
28058: LIST
28059: LIST
28060: PUSH
28061: LD_INT 2
28063: NEG
28064: PUSH
28065: LD_INT 0
28067: PUSH
28068: EMPTY
28069: LIST
28070: LIST
28071: PUSH
28072: LD_INT 2
28074: NEG
28075: PUSH
28076: LD_INT 1
28078: NEG
28079: PUSH
28080: EMPTY
28081: LIST
28082: LIST
28083: PUSH
28084: LD_INT 2
28086: NEG
28087: PUSH
28088: LD_INT 2
28090: NEG
28091: PUSH
28092: EMPTY
28093: LIST
28094: LIST
28095: PUSH
28096: EMPTY
28097: LIST
28098: LIST
28099: LIST
28100: LIST
28101: LIST
28102: LIST
28103: LIST
28104: LIST
28105: LIST
28106: LIST
28107: LIST
28108: LIST
28109: LIST
28110: LIST
28111: LIST
28112: LIST
28113: LIST
28114: LIST
28115: LIST
28116: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28117: LD_ADDR_VAR 0 54
28121: PUSH
28122: LD_INT 0
28124: PUSH
28125: LD_INT 0
28127: PUSH
28128: EMPTY
28129: LIST
28130: LIST
28131: PUSH
28132: LD_INT 0
28134: PUSH
28135: LD_INT 1
28137: NEG
28138: PUSH
28139: EMPTY
28140: LIST
28141: LIST
28142: PUSH
28143: LD_INT 1
28145: PUSH
28146: LD_INT 0
28148: PUSH
28149: EMPTY
28150: LIST
28151: LIST
28152: PUSH
28153: LD_INT 1
28155: PUSH
28156: LD_INT 1
28158: PUSH
28159: EMPTY
28160: LIST
28161: LIST
28162: PUSH
28163: LD_INT 0
28165: PUSH
28166: LD_INT 1
28168: PUSH
28169: EMPTY
28170: LIST
28171: LIST
28172: PUSH
28173: LD_INT 1
28175: NEG
28176: PUSH
28177: LD_INT 0
28179: PUSH
28180: EMPTY
28181: LIST
28182: LIST
28183: PUSH
28184: LD_INT 1
28186: NEG
28187: PUSH
28188: LD_INT 1
28190: NEG
28191: PUSH
28192: EMPTY
28193: LIST
28194: LIST
28195: PUSH
28196: LD_INT 1
28198: NEG
28199: PUSH
28200: LD_INT 2
28202: NEG
28203: PUSH
28204: EMPTY
28205: LIST
28206: LIST
28207: PUSH
28208: LD_INT 0
28210: PUSH
28211: LD_INT 2
28213: NEG
28214: PUSH
28215: EMPTY
28216: LIST
28217: LIST
28218: PUSH
28219: LD_INT 1
28221: PUSH
28222: LD_INT 1
28224: NEG
28225: PUSH
28226: EMPTY
28227: LIST
28228: LIST
28229: PUSH
28230: LD_INT 2
28232: PUSH
28233: LD_INT 0
28235: PUSH
28236: EMPTY
28237: LIST
28238: LIST
28239: PUSH
28240: LD_INT 2
28242: PUSH
28243: LD_INT 1
28245: PUSH
28246: EMPTY
28247: LIST
28248: LIST
28249: PUSH
28250: LD_INT 2
28252: PUSH
28253: LD_INT 2
28255: PUSH
28256: EMPTY
28257: LIST
28258: LIST
28259: PUSH
28260: LD_INT 1
28262: PUSH
28263: LD_INT 2
28265: PUSH
28266: EMPTY
28267: LIST
28268: LIST
28269: PUSH
28270: LD_INT 0
28272: PUSH
28273: LD_INT 2
28275: PUSH
28276: EMPTY
28277: LIST
28278: LIST
28279: PUSH
28280: LD_INT 1
28282: NEG
28283: PUSH
28284: LD_INT 1
28286: PUSH
28287: EMPTY
28288: LIST
28289: LIST
28290: PUSH
28291: LD_INT 2
28293: NEG
28294: PUSH
28295: LD_INT 0
28297: PUSH
28298: EMPTY
28299: LIST
28300: LIST
28301: PUSH
28302: LD_INT 2
28304: NEG
28305: PUSH
28306: LD_INT 1
28308: NEG
28309: PUSH
28310: EMPTY
28311: LIST
28312: LIST
28313: PUSH
28314: LD_INT 2
28316: NEG
28317: PUSH
28318: LD_INT 2
28320: NEG
28321: PUSH
28322: EMPTY
28323: LIST
28324: LIST
28325: PUSH
28326: EMPTY
28327: LIST
28328: LIST
28329: LIST
28330: LIST
28331: LIST
28332: LIST
28333: LIST
28334: LIST
28335: LIST
28336: LIST
28337: LIST
28338: LIST
28339: LIST
28340: LIST
28341: LIST
28342: LIST
28343: LIST
28344: LIST
28345: LIST
28346: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28347: LD_ADDR_VAR 0 55
28351: PUSH
28352: LD_INT 0
28354: PUSH
28355: LD_INT 0
28357: PUSH
28358: EMPTY
28359: LIST
28360: LIST
28361: PUSH
28362: LD_INT 0
28364: PUSH
28365: LD_INT 1
28367: NEG
28368: PUSH
28369: EMPTY
28370: LIST
28371: LIST
28372: PUSH
28373: LD_INT 1
28375: PUSH
28376: LD_INT 0
28378: PUSH
28379: EMPTY
28380: LIST
28381: LIST
28382: PUSH
28383: LD_INT 1
28385: PUSH
28386: LD_INT 1
28388: PUSH
28389: EMPTY
28390: LIST
28391: LIST
28392: PUSH
28393: LD_INT 0
28395: PUSH
28396: LD_INT 1
28398: PUSH
28399: EMPTY
28400: LIST
28401: LIST
28402: PUSH
28403: LD_INT 1
28405: NEG
28406: PUSH
28407: LD_INT 0
28409: PUSH
28410: EMPTY
28411: LIST
28412: LIST
28413: PUSH
28414: LD_INT 1
28416: NEG
28417: PUSH
28418: LD_INT 1
28420: NEG
28421: PUSH
28422: EMPTY
28423: LIST
28424: LIST
28425: PUSH
28426: LD_INT 1
28428: NEG
28429: PUSH
28430: LD_INT 2
28432: NEG
28433: PUSH
28434: EMPTY
28435: LIST
28436: LIST
28437: PUSH
28438: LD_INT 0
28440: PUSH
28441: LD_INT 2
28443: NEG
28444: PUSH
28445: EMPTY
28446: LIST
28447: LIST
28448: PUSH
28449: LD_INT 1
28451: PUSH
28452: LD_INT 1
28454: NEG
28455: PUSH
28456: EMPTY
28457: LIST
28458: LIST
28459: PUSH
28460: LD_INT 2
28462: PUSH
28463: LD_INT 0
28465: PUSH
28466: EMPTY
28467: LIST
28468: LIST
28469: PUSH
28470: LD_INT 2
28472: PUSH
28473: LD_INT 1
28475: PUSH
28476: EMPTY
28477: LIST
28478: LIST
28479: PUSH
28480: LD_INT 2
28482: PUSH
28483: LD_INT 2
28485: PUSH
28486: EMPTY
28487: LIST
28488: LIST
28489: PUSH
28490: LD_INT 1
28492: PUSH
28493: LD_INT 2
28495: PUSH
28496: EMPTY
28497: LIST
28498: LIST
28499: PUSH
28500: LD_INT 0
28502: PUSH
28503: LD_INT 2
28505: PUSH
28506: EMPTY
28507: LIST
28508: LIST
28509: PUSH
28510: LD_INT 1
28512: NEG
28513: PUSH
28514: LD_INT 1
28516: PUSH
28517: EMPTY
28518: LIST
28519: LIST
28520: PUSH
28521: LD_INT 2
28523: NEG
28524: PUSH
28525: LD_INT 0
28527: PUSH
28528: EMPTY
28529: LIST
28530: LIST
28531: PUSH
28532: LD_INT 2
28534: NEG
28535: PUSH
28536: LD_INT 1
28538: NEG
28539: PUSH
28540: EMPTY
28541: LIST
28542: LIST
28543: PUSH
28544: LD_INT 2
28546: NEG
28547: PUSH
28548: LD_INT 2
28550: NEG
28551: PUSH
28552: EMPTY
28553: LIST
28554: LIST
28555: PUSH
28556: EMPTY
28557: LIST
28558: LIST
28559: LIST
28560: LIST
28561: LIST
28562: LIST
28563: LIST
28564: LIST
28565: LIST
28566: LIST
28567: LIST
28568: LIST
28569: LIST
28570: LIST
28571: LIST
28572: LIST
28573: LIST
28574: LIST
28575: LIST
28576: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28577: LD_ADDR_VAR 0 56
28581: PUSH
28582: LD_INT 0
28584: PUSH
28585: LD_INT 0
28587: PUSH
28588: EMPTY
28589: LIST
28590: LIST
28591: PUSH
28592: LD_INT 0
28594: PUSH
28595: LD_INT 1
28597: NEG
28598: PUSH
28599: EMPTY
28600: LIST
28601: LIST
28602: PUSH
28603: LD_INT 1
28605: PUSH
28606: LD_INT 0
28608: PUSH
28609: EMPTY
28610: LIST
28611: LIST
28612: PUSH
28613: LD_INT 1
28615: PUSH
28616: LD_INT 1
28618: PUSH
28619: EMPTY
28620: LIST
28621: LIST
28622: PUSH
28623: LD_INT 0
28625: PUSH
28626: LD_INT 1
28628: PUSH
28629: EMPTY
28630: LIST
28631: LIST
28632: PUSH
28633: LD_INT 1
28635: NEG
28636: PUSH
28637: LD_INT 0
28639: PUSH
28640: EMPTY
28641: LIST
28642: LIST
28643: PUSH
28644: LD_INT 1
28646: NEG
28647: PUSH
28648: LD_INT 1
28650: NEG
28651: PUSH
28652: EMPTY
28653: LIST
28654: LIST
28655: PUSH
28656: LD_INT 1
28658: NEG
28659: PUSH
28660: LD_INT 2
28662: NEG
28663: PUSH
28664: EMPTY
28665: LIST
28666: LIST
28667: PUSH
28668: LD_INT 0
28670: PUSH
28671: LD_INT 2
28673: NEG
28674: PUSH
28675: EMPTY
28676: LIST
28677: LIST
28678: PUSH
28679: LD_INT 1
28681: PUSH
28682: LD_INT 1
28684: NEG
28685: PUSH
28686: EMPTY
28687: LIST
28688: LIST
28689: PUSH
28690: LD_INT 2
28692: PUSH
28693: LD_INT 0
28695: PUSH
28696: EMPTY
28697: LIST
28698: LIST
28699: PUSH
28700: LD_INT 2
28702: PUSH
28703: LD_INT 1
28705: PUSH
28706: EMPTY
28707: LIST
28708: LIST
28709: PUSH
28710: LD_INT 2
28712: PUSH
28713: LD_INT 2
28715: PUSH
28716: EMPTY
28717: LIST
28718: LIST
28719: PUSH
28720: LD_INT 1
28722: PUSH
28723: LD_INT 2
28725: PUSH
28726: EMPTY
28727: LIST
28728: LIST
28729: PUSH
28730: LD_INT 0
28732: PUSH
28733: LD_INT 2
28735: PUSH
28736: EMPTY
28737: LIST
28738: LIST
28739: PUSH
28740: LD_INT 1
28742: NEG
28743: PUSH
28744: LD_INT 1
28746: PUSH
28747: EMPTY
28748: LIST
28749: LIST
28750: PUSH
28751: LD_INT 2
28753: NEG
28754: PUSH
28755: LD_INT 0
28757: PUSH
28758: EMPTY
28759: LIST
28760: LIST
28761: PUSH
28762: LD_INT 2
28764: NEG
28765: PUSH
28766: LD_INT 1
28768: NEG
28769: PUSH
28770: EMPTY
28771: LIST
28772: LIST
28773: PUSH
28774: LD_INT 2
28776: NEG
28777: PUSH
28778: LD_INT 2
28780: NEG
28781: PUSH
28782: EMPTY
28783: LIST
28784: LIST
28785: PUSH
28786: EMPTY
28787: LIST
28788: LIST
28789: LIST
28790: LIST
28791: LIST
28792: LIST
28793: LIST
28794: LIST
28795: LIST
28796: LIST
28797: LIST
28798: LIST
28799: LIST
28800: LIST
28801: LIST
28802: LIST
28803: LIST
28804: LIST
28805: LIST
28806: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28807: LD_ADDR_VAR 0 57
28811: PUSH
28812: LD_INT 0
28814: PUSH
28815: LD_INT 0
28817: PUSH
28818: EMPTY
28819: LIST
28820: LIST
28821: PUSH
28822: LD_INT 0
28824: PUSH
28825: LD_INT 1
28827: NEG
28828: PUSH
28829: EMPTY
28830: LIST
28831: LIST
28832: PUSH
28833: LD_INT 1
28835: PUSH
28836: LD_INT 0
28838: PUSH
28839: EMPTY
28840: LIST
28841: LIST
28842: PUSH
28843: LD_INT 1
28845: PUSH
28846: LD_INT 1
28848: PUSH
28849: EMPTY
28850: LIST
28851: LIST
28852: PUSH
28853: LD_INT 0
28855: PUSH
28856: LD_INT 1
28858: PUSH
28859: EMPTY
28860: LIST
28861: LIST
28862: PUSH
28863: LD_INT 1
28865: NEG
28866: PUSH
28867: LD_INT 0
28869: PUSH
28870: EMPTY
28871: LIST
28872: LIST
28873: PUSH
28874: LD_INT 1
28876: NEG
28877: PUSH
28878: LD_INT 1
28880: NEG
28881: PUSH
28882: EMPTY
28883: LIST
28884: LIST
28885: PUSH
28886: LD_INT 1
28888: NEG
28889: PUSH
28890: LD_INT 2
28892: NEG
28893: PUSH
28894: EMPTY
28895: LIST
28896: LIST
28897: PUSH
28898: LD_INT 0
28900: PUSH
28901: LD_INT 2
28903: NEG
28904: PUSH
28905: EMPTY
28906: LIST
28907: LIST
28908: PUSH
28909: LD_INT 1
28911: PUSH
28912: LD_INT 1
28914: NEG
28915: PUSH
28916: EMPTY
28917: LIST
28918: LIST
28919: PUSH
28920: LD_INT 2
28922: PUSH
28923: LD_INT 0
28925: PUSH
28926: EMPTY
28927: LIST
28928: LIST
28929: PUSH
28930: LD_INT 2
28932: PUSH
28933: LD_INT 1
28935: PUSH
28936: EMPTY
28937: LIST
28938: LIST
28939: PUSH
28940: LD_INT 2
28942: PUSH
28943: LD_INT 2
28945: PUSH
28946: EMPTY
28947: LIST
28948: LIST
28949: PUSH
28950: LD_INT 1
28952: PUSH
28953: LD_INT 2
28955: PUSH
28956: EMPTY
28957: LIST
28958: LIST
28959: PUSH
28960: LD_INT 0
28962: PUSH
28963: LD_INT 2
28965: PUSH
28966: EMPTY
28967: LIST
28968: LIST
28969: PUSH
28970: LD_INT 1
28972: NEG
28973: PUSH
28974: LD_INT 1
28976: PUSH
28977: EMPTY
28978: LIST
28979: LIST
28980: PUSH
28981: LD_INT 2
28983: NEG
28984: PUSH
28985: LD_INT 0
28987: PUSH
28988: EMPTY
28989: LIST
28990: LIST
28991: PUSH
28992: LD_INT 2
28994: NEG
28995: PUSH
28996: LD_INT 1
28998: NEG
28999: PUSH
29000: EMPTY
29001: LIST
29002: LIST
29003: PUSH
29004: LD_INT 2
29006: NEG
29007: PUSH
29008: LD_INT 2
29010: NEG
29011: PUSH
29012: EMPTY
29013: LIST
29014: LIST
29015: PUSH
29016: EMPTY
29017: LIST
29018: LIST
29019: LIST
29020: LIST
29021: LIST
29022: LIST
29023: LIST
29024: LIST
29025: LIST
29026: LIST
29027: LIST
29028: LIST
29029: LIST
29030: LIST
29031: LIST
29032: LIST
29033: LIST
29034: LIST
29035: LIST
29036: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29037: LD_ADDR_VAR 0 58
29041: PUSH
29042: LD_INT 0
29044: PUSH
29045: LD_INT 0
29047: PUSH
29048: EMPTY
29049: LIST
29050: LIST
29051: PUSH
29052: LD_INT 0
29054: PUSH
29055: LD_INT 1
29057: NEG
29058: PUSH
29059: EMPTY
29060: LIST
29061: LIST
29062: PUSH
29063: LD_INT 1
29065: PUSH
29066: LD_INT 0
29068: PUSH
29069: EMPTY
29070: LIST
29071: LIST
29072: PUSH
29073: LD_INT 1
29075: PUSH
29076: LD_INT 1
29078: PUSH
29079: EMPTY
29080: LIST
29081: LIST
29082: PUSH
29083: LD_INT 0
29085: PUSH
29086: LD_INT 1
29088: PUSH
29089: EMPTY
29090: LIST
29091: LIST
29092: PUSH
29093: LD_INT 1
29095: NEG
29096: PUSH
29097: LD_INT 0
29099: PUSH
29100: EMPTY
29101: LIST
29102: LIST
29103: PUSH
29104: LD_INT 1
29106: NEG
29107: PUSH
29108: LD_INT 1
29110: NEG
29111: PUSH
29112: EMPTY
29113: LIST
29114: LIST
29115: PUSH
29116: LD_INT 1
29118: NEG
29119: PUSH
29120: LD_INT 2
29122: NEG
29123: PUSH
29124: EMPTY
29125: LIST
29126: LIST
29127: PUSH
29128: LD_INT 0
29130: PUSH
29131: LD_INT 2
29133: NEG
29134: PUSH
29135: EMPTY
29136: LIST
29137: LIST
29138: PUSH
29139: LD_INT 1
29141: PUSH
29142: LD_INT 1
29144: NEG
29145: PUSH
29146: EMPTY
29147: LIST
29148: LIST
29149: PUSH
29150: LD_INT 2
29152: PUSH
29153: LD_INT 0
29155: PUSH
29156: EMPTY
29157: LIST
29158: LIST
29159: PUSH
29160: LD_INT 2
29162: PUSH
29163: LD_INT 1
29165: PUSH
29166: EMPTY
29167: LIST
29168: LIST
29169: PUSH
29170: LD_INT 2
29172: PUSH
29173: LD_INT 2
29175: PUSH
29176: EMPTY
29177: LIST
29178: LIST
29179: PUSH
29180: LD_INT 1
29182: PUSH
29183: LD_INT 2
29185: PUSH
29186: EMPTY
29187: LIST
29188: LIST
29189: PUSH
29190: LD_INT 0
29192: PUSH
29193: LD_INT 2
29195: PUSH
29196: EMPTY
29197: LIST
29198: LIST
29199: PUSH
29200: LD_INT 1
29202: NEG
29203: PUSH
29204: LD_INT 1
29206: PUSH
29207: EMPTY
29208: LIST
29209: LIST
29210: PUSH
29211: LD_INT 2
29213: NEG
29214: PUSH
29215: LD_INT 0
29217: PUSH
29218: EMPTY
29219: LIST
29220: LIST
29221: PUSH
29222: LD_INT 2
29224: NEG
29225: PUSH
29226: LD_INT 1
29228: NEG
29229: PUSH
29230: EMPTY
29231: LIST
29232: LIST
29233: PUSH
29234: LD_INT 2
29236: NEG
29237: PUSH
29238: LD_INT 2
29240: NEG
29241: PUSH
29242: EMPTY
29243: LIST
29244: LIST
29245: PUSH
29246: EMPTY
29247: LIST
29248: LIST
29249: LIST
29250: LIST
29251: LIST
29252: LIST
29253: LIST
29254: LIST
29255: LIST
29256: LIST
29257: LIST
29258: LIST
29259: LIST
29260: LIST
29261: LIST
29262: LIST
29263: LIST
29264: LIST
29265: LIST
29266: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
29267: LD_ADDR_VAR 0 59
29271: PUSH
29272: LD_INT 0
29274: PUSH
29275: LD_INT 0
29277: PUSH
29278: EMPTY
29279: LIST
29280: LIST
29281: PUSH
29282: LD_INT 0
29284: PUSH
29285: LD_INT 1
29287: NEG
29288: PUSH
29289: EMPTY
29290: LIST
29291: LIST
29292: PUSH
29293: LD_INT 1
29295: PUSH
29296: LD_INT 0
29298: PUSH
29299: EMPTY
29300: LIST
29301: LIST
29302: PUSH
29303: LD_INT 1
29305: PUSH
29306: LD_INT 1
29308: PUSH
29309: EMPTY
29310: LIST
29311: LIST
29312: PUSH
29313: LD_INT 0
29315: PUSH
29316: LD_INT 1
29318: PUSH
29319: EMPTY
29320: LIST
29321: LIST
29322: PUSH
29323: LD_INT 1
29325: NEG
29326: PUSH
29327: LD_INT 0
29329: PUSH
29330: EMPTY
29331: LIST
29332: LIST
29333: PUSH
29334: LD_INT 1
29336: NEG
29337: PUSH
29338: LD_INT 1
29340: NEG
29341: PUSH
29342: EMPTY
29343: LIST
29344: LIST
29345: PUSH
29346: EMPTY
29347: LIST
29348: LIST
29349: LIST
29350: LIST
29351: LIST
29352: LIST
29353: LIST
29354: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
29355: LD_ADDR_VAR 0 60
29359: PUSH
29360: LD_INT 0
29362: PUSH
29363: LD_INT 0
29365: PUSH
29366: EMPTY
29367: LIST
29368: LIST
29369: PUSH
29370: LD_INT 0
29372: PUSH
29373: LD_INT 1
29375: NEG
29376: PUSH
29377: EMPTY
29378: LIST
29379: LIST
29380: PUSH
29381: LD_INT 1
29383: PUSH
29384: LD_INT 0
29386: PUSH
29387: EMPTY
29388: LIST
29389: LIST
29390: PUSH
29391: LD_INT 1
29393: PUSH
29394: LD_INT 1
29396: PUSH
29397: EMPTY
29398: LIST
29399: LIST
29400: PUSH
29401: LD_INT 0
29403: PUSH
29404: LD_INT 1
29406: PUSH
29407: EMPTY
29408: LIST
29409: LIST
29410: PUSH
29411: LD_INT 1
29413: NEG
29414: PUSH
29415: LD_INT 0
29417: PUSH
29418: EMPTY
29419: LIST
29420: LIST
29421: PUSH
29422: LD_INT 1
29424: NEG
29425: PUSH
29426: LD_INT 1
29428: NEG
29429: PUSH
29430: EMPTY
29431: LIST
29432: LIST
29433: PUSH
29434: EMPTY
29435: LIST
29436: LIST
29437: LIST
29438: LIST
29439: LIST
29440: LIST
29441: LIST
29442: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
29443: LD_ADDR_VAR 0 61
29447: PUSH
29448: LD_INT 0
29450: PUSH
29451: LD_INT 0
29453: PUSH
29454: EMPTY
29455: LIST
29456: LIST
29457: PUSH
29458: LD_INT 0
29460: PUSH
29461: LD_INT 1
29463: NEG
29464: PUSH
29465: EMPTY
29466: LIST
29467: LIST
29468: PUSH
29469: LD_INT 1
29471: PUSH
29472: LD_INT 0
29474: PUSH
29475: EMPTY
29476: LIST
29477: LIST
29478: PUSH
29479: LD_INT 1
29481: PUSH
29482: LD_INT 1
29484: PUSH
29485: EMPTY
29486: LIST
29487: LIST
29488: PUSH
29489: LD_INT 0
29491: PUSH
29492: LD_INT 1
29494: PUSH
29495: EMPTY
29496: LIST
29497: LIST
29498: PUSH
29499: LD_INT 1
29501: NEG
29502: PUSH
29503: LD_INT 0
29505: PUSH
29506: EMPTY
29507: LIST
29508: LIST
29509: PUSH
29510: LD_INT 1
29512: NEG
29513: PUSH
29514: LD_INT 1
29516: NEG
29517: PUSH
29518: EMPTY
29519: LIST
29520: LIST
29521: PUSH
29522: EMPTY
29523: LIST
29524: LIST
29525: LIST
29526: LIST
29527: LIST
29528: LIST
29529: LIST
29530: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
29531: LD_ADDR_VAR 0 62
29535: PUSH
29536: LD_INT 0
29538: PUSH
29539: LD_INT 0
29541: PUSH
29542: EMPTY
29543: LIST
29544: LIST
29545: PUSH
29546: LD_INT 0
29548: PUSH
29549: LD_INT 1
29551: NEG
29552: PUSH
29553: EMPTY
29554: LIST
29555: LIST
29556: PUSH
29557: LD_INT 1
29559: PUSH
29560: LD_INT 0
29562: PUSH
29563: EMPTY
29564: LIST
29565: LIST
29566: PUSH
29567: LD_INT 1
29569: PUSH
29570: LD_INT 1
29572: PUSH
29573: EMPTY
29574: LIST
29575: LIST
29576: PUSH
29577: LD_INT 0
29579: PUSH
29580: LD_INT 1
29582: PUSH
29583: EMPTY
29584: LIST
29585: LIST
29586: PUSH
29587: LD_INT 1
29589: NEG
29590: PUSH
29591: LD_INT 0
29593: PUSH
29594: EMPTY
29595: LIST
29596: LIST
29597: PUSH
29598: LD_INT 1
29600: NEG
29601: PUSH
29602: LD_INT 1
29604: NEG
29605: PUSH
29606: EMPTY
29607: LIST
29608: LIST
29609: PUSH
29610: EMPTY
29611: LIST
29612: LIST
29613: LIST
29614: LIST
29615: LIST
29616: LIST
29617: LIST
29618: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
29619: LD_ADDR_VAR 0 63
29623: PUSH
29624: LD_INT 0
29626: PUSH
29627: LD_INT 0
29629: PUSH
29630: EMPTY
29631: LIST
29632: LIST
29633: PUSH
29634: LD_INT 0
29636: PUSH
29637: LD_INT 1
29639: NEG
29640: PUSH
29641: EMPTY
29642: LIST
29643: LIST
29644: PUSH
29645: LD_INT 1
29647: PUSH
29648: LD_INT 0
29650: PUSH
29651: EMPTY
29652: LIST
29653: LIST
29654: PUSH
29655: LD_INT 1
29657: PUSH
29658: LD_INT 1
29660: PUSH
29661: EMPTY
29662: LIST
29663: LIST
29664: PUSH
29665: LD_INT 0
29667: PUSH
29668: LD_INT 1
29670: PUSH
29671: EMPTY
29672: LIST
29673: LIST
29674: PUSH
29675: LD_INT 1
29677: NEG
29678: PUSH
29679: LD_INT 0
29681: PUSH
29682: EMPTY
29683: LIST
29684: LIST
29685: PUSH
29686: LD_INT 1
29688: NEG
29689: PUSH
29690: LD_INT 1
29692: NEG
29693: PUSH
29694: EMPTY
29695: LIST
29696: LIST
29697: PUSH
29698: EMPTY
29699: LIST
29700: LIST
29701: LIST
29702: LIST
29703: LIST
29704: LIST
29705: LIST
29706: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
29707: LD_ADDR_VAR 0 64
29711: PUSH
29712: LD_INT 0
29714: PUSH
29715: LD_INT 0
29717: PUSH
29718: EMPTY
29719: LIST
29720: LIST
29721: PUSH
29722: LD_INT 0
29724: PUSH
29725: LD_INT 1
29727: NEG
29728: PUSH
29729: EMPTY
29730: LIST
29731: LIST
29732: PUSH
29733: LD_INT 1
29735: PUSH
29736: LD_INT 0
29738: PUSH
29739: EMPTY
29740: LIST
29741: LIST
29742: PUSH
29743: LD_INT 1
29745: PUSH
29746: LD_INT 1
29748: PUSH
29749: EMPTY
29750: LIST
29751: LIST
29752: PUSH
29753: LD_INT 0
29755: PUSH
29756: LD_INT 1
29758: PUSH
29759: EMPTY
29760: LIST
29761: LIST
29762: PUSH
29763: LD_INT 1
29765: NEG
29766: PUSH
29767: LD_INT 0
29769: PUSH
29770: EMPTY
29771: LIST
29772: LIST
29773: PUSH
29774: LD_INT 1
29776: NEG
29777: PUSH
29778: LD_INT 1
29780: NEG
29781: PUSH
29782: EMPTY
29783: LIST
29784: LIST
29785: PUSH
29786: EMPTY
29787: LIST
29788: LIST
29789: LIST
29790: LIST
29791: LIST
29792: LIST
29793: LIST
29794: ST_TO_ADDR
// end ; 1 :
29795: GO 35692
29797: LD_INT 1
29799: DOUBLE
29800: EQUAL
29801: IFTRUE 29805
29803: GO 32428
29805: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
29806: LD_ADDR_VAR 0 11
29810: PUSH
29811: LD_INT 1
29813: NEG
29814: PUSH
29815: LD_INT 3
29817: NEG
29818: PUSH
29819: EMPTY
29820: LIST
29821: LIST
29822: PUSH
29823: LD_INT 0
29825: PUSH
29826: LD_INT 3
29828: NEG
29829: PUSH
29830: EMPTY
29831: LIST
29832: LIST
29833: PUSH
29834: LD_INT 1
29836: PUSH
29837: LD_INT 2
29839: NEG
29840: PUSH
29841: EMPTY
29842: LIST
29843: LIST
29844: PUSH
29845: EMPTY
29846: LIST
29847: LIST
29848: LIST
29849: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
29850: LD_ADDR_VAR 0 12
29854: PUSH
29855: LD_INT 2
29857: PUSH
29858: LD_INT 1
29860: NEG
29861: PUSH
29862: EMPTY
29863: LIST
29864: LIST
29865: PUSH
29866: LD_INT 3
29868: PUSH
29869: LD_INT 0
29871: PUSH
29872: EMPTY
29873: LIST
29874: LIST
29875: PUSH
29876: LD_INT 3
29878: PUSH
29879: LD_INT 1
29881: PUSH
29882: EMPTY
29883: LIST
29884: LIST
29885: PUSH
29886: EMPTY
29887: LIST
29888: LIST
29889: LIST
29890: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
29891: LD_ADDR_VAR 0 13
29895: PUSH
29896: LD_INT 3
29898: PUSH
29899: LD_INT 2
29901: PUSH
29902: EMPTY
29903: LIST
29904: LIST
29905: PUSH
29906: LD_INT 3
29908: PUSH
29909: LD_INT 3
29911: PUSH
29912: EMPTY
29913: LIST
29914: LIST
29915: PUSH
29916: LD_INT 2
29918: PUSH
29919: LD_INT 3
29921: PUSH
29922: EMPTY
29923: LIST
29924: LIST
29925: PUSH
29926: EMPTY
29927: LIST
29928: LIST
29929: LIST
29930: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
29931: LD_ADDR_VAR 0 14
29935: PUSH
29936: LD_INT 1
29938: PUSH
29939: LD_INT 3
29941: PUSH
29942: EMPTY
29943: LIST
29944: LIST
29945: PUSH
29946: LD_INT 0
29948: PUSH
29949: LD_INT 3
29951: PUSH
29952: EMPTY
29953: LIST
29954: LIST
29955: PUSH
29956: LD_INT 1
29958: NEG
29959: PUSH
29960: LD_INT 2
29962: PUSH
29963: EMPTY
29964: LIST
29965: LIST
29966: PUSH
29967: EMPTY
29968: LIST
29969: LIST
29970: LIST
29971: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
29972: LD_ADDR_VAR 0 15
29976: PUSH
29977: LD_INT 2
29979: NEG
29980: PUSH
29981: LD_INT 1
29983: PUSH
29984: EMPTY
29985: LIST
29986: LIST
29987: PUSH
29988: LD_INT 3
29990: NEG
29991: PUSH
29992: LD_INT 0
29994: PUSH
29995: EMPTY
29996: LIST
29997: LIST
29998: PUSH
29999: LD_INT 3
30001: NEG
30002: PUSH
30003: LD_INT 1
30005: NEG
30006: PUSH
30007: EMPTY
30008: LIST
30009: LIST
30010: PUSH
30011: EMPTY
30012: LIST
30013: LIST
30014: LIST
30015: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30016: LD_ADDR_VAR 0 16
30020: PUSH
30021: LD_INT 2
30023: NEG
30024: PUSH
30025: LD_INT 3
30027: NEG
30028: PUSH
30029: EMPTY
30030: LIST
30031: LIST
30032: PUSH
30033: LD_INT 3
30035: NEG
30036: PUSH
30037: LD_INT 2
30039: NEG
30040: PUSH
30041: EMPTY
30042: LIST
30043: LIST
30044: PUSH
30045: LD_INT 3
30047: NEG
30048: PUSH
30049: LD_INT 3
30051: NEG
30052: PUSH
30053: EMPTY
30054: LIST
30055: LIST
30056: PUSH
30057: EMPTY
30058: LIST
30059: LIST
30060: LIST
30061: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
30062: LD_ADDR_VAR 0 17
30066: PUSH
30067: LD_INT 1
30069: NEG
30070: PUSH
30071: LD_INT 3
30073: NEG
30074: PUSH
30075: EMPTY
30076: LIST
30077: LIST
30078: PUSH
30079: LD_INT 0
30081: PUSH
30082: LD_INT 3
30084: NEG
30085: PUSH
30086: EMPTY
30087: LIST
30088: LIST
30089: PUSH
30090: LD_INT 1
30092: PUSH
30093: LD_INT 2
30095: NEG
30096: PUSH
30097: EMPTY
30098: LIST
30099: LIST
30100: PUSH
30101: EMPTY
30102: LIST
30103: LIST
30104: LIST
30105: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
30106: LD_ADDR_VAR 0 18
30110: PUSH
30111: LD_INT 2
30113: PUSH
30114: LD_INT 1
30116: NEG
30117: PUSH
30118: EMPTY
30119: LIST
30120: LIST
30121: PUSH
30122: LD_INT 3
30124: PUSH
30125: LD_INT 0
30127: PUSH
30128: EMPTY
30129: LIST
30130: LIST
30131: PUSH
30132: LD_INT 3
30134: PUSH
30135: LD_INT 1
30137: PUSH
30138: EMPTY
30139: LIST
30140: LIST
30141: PUSH
30142: EMPTY
30143: LIST
30144: LIST
30145: LIST
30146: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
30147: LD_ADDR_VAR 0 19
30151: PUSH
30152: LD_INT 3
30154: PUSH
30155: LD_INT 2
30157: PUSH
30158: EMPTY
30159: LIST
30160: LIST
30161: PUSH
30162: LD_INT 3
30164: PUSH
30165: LD_INT 3
30167: PUSH
30168: EMPTY
30169: LIST
30170: LIST
30171: PUSH
30172: LD_INT 2
30174: PUSH
30175: LD_INT 3
30177: PUSH
30178: EMPTY
30179: LIST
30180: LIST
30181: PUSH
30182: EMPTY
30183: LIST
30184: LIST
30185: LIST
30186: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
30187: LD_ADDR_VAR 0 20
30191: PUSH
30192: LD_INT 1
30194: PUSH
30195: LD_INT 3
30197: PUSH
30198: EMPTY
30199: LIST
30200: LIST
30201: PUSH
30202: LD_INT 0
30204: PUSH
30205: LD_INT 3
30207: PUSH
30208: EMPTY
30209: LIST
30210: LIST
30211: PUSH
30212: LD_INT 1
30214: NEG
30215: PUSH
30216: LD_INT 2
30218: PUSH
30219: EMPTY
30220: LIST
30221: LIST
30222: PUSH
30223: EMPTY
30224: LIST
30225: LIST
30226: LIST
30227: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
30228: LD_ADDR_VAR 0 21
30232: PUSH
30233: LD_INT 2
30235: NEG
30236: PUSH
30237: LD_INT 1
30239: PUSH
30240: EMPTY
30241: LIST
30242: LIST
30243: PUSH
30244: LD_INT 3
30246: NEG
30247: PUSH
30248: LD_INT 0
30250: PUSH
30251: EMPTY
30252: LIST
30253: LIST
30254: PUSH
30255: LD_INT 3
30257: NEG
30258: PUSH
30259: LD_INT 1
30261: NEG
30262: PUSH
30263: EMPTY
30264: LIST
30265: LIST
30266: PUSH
30267: EMPTY
30268: LIST
30269: LIST
30270: LIST
30271: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30272: LD_ADDR_VAR 0 22
30276: PUSH
30277: LD_INT 2
30279: NEG
30280: PUSH
30281: LD_INT 3
30283: NEG
30284: PUSH
30285: EMPTY
30286: LIST
30287: LIST
30288: PUSH
30289: LD_INT 3
30291: NEG
30292: PUSH
30293: LD_INT 2
30295: NEG
30296: PUSH
30297: EMPTY
30298: LIST
30299: LIST
30300: PUSH
30301: LD_INT 3
30303: NEG
30304: PUSH
30305: LD_INT 3
30307: NEG
30308: PUSH
30309: EMPTY
30310: LIST
30311: LIST
30312: PUSH
30313: EMPTY
30314: LIST
30315: LIST
30316: LIST
30317: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
30318: LD_ADDR_VAR 0 23
30322: PUSH
30323: LD_INT 0
30325: PUSH
30326: LD_INT 3
30328: NEG
30329: PUSH
30330: EMPTY
30331: LIST
30332: LIST
30333: PUSH
30334: LD_INT 1
30336: NEG
30337: PUSH
30338: LD_INT 4
30340: NEG
30341: PUSH
30342: EMPTY
30343: LIST
30344: LIST
30345: PUSH
30346: LD_INT 1
30348: PUSH
30349: LD_INT 3
30351: NEG
30352: PUSH
30353: EMPTY
30354: LIST
30355: LIST
30356: PUSH
30357: EMPTY
30358: LIST
30359: LIST
30360: LIST
30361: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
30362: LD_ADDR_VAR 0 24
30366: PUSH
30367: LD_INT 3
30369: PUSH
30370: LD_INT 0
30372: PUSH
30373: EMPTY
30374: LIST
30375: LIST
30376: PUSH
30377: LD_INT 3
30379: PUSH
30380: LD_INT 1
30382: NEG
30383: PUSH
30384: EMPTY
30385: LIST
30386: LIST
30387: PUSH
30388: LD_INT 4
30390: PUSH
30391: LD_INT 1
30393: PUSH
30394: EMPTY
30395: LIST
30396: LIST
30397: PUSH
30398: EMPTY
30399: LIST
30400: LIST
30401: LIST
30402: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
30403: LD_ADDR_VAR 0 25
30407: PUSH
30408: LD_INT 3
30410: PUSH
30411: LD_INT 3
30413: PUSH
30414: EMPTY
30415: LIST
30416: LIST
30417: PUSH
30418: LD_INT 4
30420: PUSH
30421: LD_INT 3
30423: PUSH
30424: EMPTY
30425: LIST
30426: LIST
30427: PUSH
30428: LD_INT 3
30430: PUSH
30431: LD_INT 4
30433: PUSH
30434: EMPTY
30435: LIST
30436: LIST
30437: PUSH
30438: EMPTY
30439: LIST
30440: LIST
30441: LIST
30442: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
30443: LD_ADDR_VAR 0 26
30447: PUSH
30448: LD_INT 0
30450: PUSH
30451: LD_INT 3
30453: PUSH
30454: EMPTY
30455: LIST
30456: LIST
30457: PUSH
30458: LD_INT 1
30460: PUSH
30461: LD_INT 4
30463: PUSH
30464: EMPTY
30465: LIST
30466: LIST
30467: PUSH
30468: LD_INT 1
30470: NEG
30471: PUSH
30472: LD_INT 3
30474: PUSH
30475: EMPTY
30476: LIST
30477: LIST
30478: PUSH
30479: EMPTY
30480: LIST
30481: LIST
30482: LIST
30483: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
30484: LD_ADDR_VAR 0 27
30488: PUSH
30489: LD_INT 3
30491: NEG
30492: PUSH
30493: LD_INT 0
30495: PUSH
30496: EMPTY
30497: LIST
30498: LIST
30499: PUSH
30500: LD_INT 3
30502: NEG
30503: PUSH
30504: LD_INT 1
30506: PUSH
30507: EMPTY
30508: LIST
30509: LIST
30510: PUSH
30511: LD_INT 4
30513: NEG
30514: PUSH
30515: LD_INT 1
30517: NEG
30518: PUSH
30519: EMPTY
30520: LIST
30521: LIST
30522: PUSH
30523: EMPTY
30524: LIST
30525: LIST
30526: LIST
30527: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
30528: LD_ADDR_VAR 0 28
30532: PUSH
30533: LD_INT 3
30535: NEG
30536: PUSH
30537: LD_INT 3
30539: NEG
30540: PUSH
30541: EMPTY
30542: LIST
30543: LIST
30544: PUSH
30545: LD_INT 3
30547: NEG
30548: PUSH
30549: LD_INT 4
30551: NEG
30552: PUSH
30553: EMPTY
30554: LIST
30555: LIST
30556: PUSH
30557: LD_INT 4
30559: NEG
30560: PUSH
30561: LD_INT 3
30563: NEG
30564: PUSH
30565: EMPTY
30566: LIST
30567: LIST
30568: PUSH
30569: EMPTY
30570: LIST
30571: LIST
30572: LIST
30573: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
30574: LD_ADDR_VAR 0 29
30578: PUSH
30579: LD_INT 1
30581: NEG
30582: PUSH
30583: LD_INT 3
30585: NEG
30586: PUSH
30587: EMPTY
30588: LIST
30589: LIST
30590: PUSH
30591: LD_INT 0
30593: PUSH
30594: LD_INT 3
30596: NEG
30597: PUSH
30598: EMPTY
30599: LIST
30600: LIST
30601: PUSH
30602: LD_INT 1
30604: PUSH
30605: LD_INT 2
30607: NEG
30608: PUSH
30609: EMPTY
30610: LIST
30611: LIST
30612: PUSH
30613: LD_INT 1
30615: NEG
30616: PUSH
30617: LD_INT 4
30619: NEG
30620: PUSH
30621: EMPTY
30622: LIST
30623: LIST
30624: PUSH
30625: LD_INT 0
30627: PUSH
30628: LD_INT 4
30630: NEG
30631: PUSH
30632: EMPTY
30633: LIST
30634: LIST
30635: PUSH
30636: LD_INT 1
30638: PUSH
30639: LD_INT 3
30641: NEG
30642: PUSH
30643: EMPTY
30644: LIST
30645: LIST
30646: PUSH
30647: LD_INT 1
30649: NEG
30650: PUSH
30651: LD_INT 5
30653: NEG
30654: PUSH
30655: EMPTY
30656: LIST
30657: LIST
30658: PUSH
30659: LD_INT 0
30661: PUSH
30662: LD_INT 5
30664: NEG
30665: PUSH
30666: EMPTY
30667: LIST
30668: LIST
30669: PUSH
30670: LD_INT 1
30672: PUSH
30673: LD_INT 4
30675: NEG
30676: PUSH
30677: EMPTY
30678: LIST
30679: LIST
30680: PUSH
30681: LD_INT 1
30683: NEG
30684: PUSH
30685: LD_INT 6
30687: NEG
30688: PUSH
30689: EMPTY
30690: LIST
30691: LIST
30692: PUSH
30693: LD_INT 0
30695: PUSH
30696: LD_INT 6
30698: NEG
30699: PUSH
30700: EMPTY
30701: LIST
30702: LIST
30703: PUSH
30704: LD_INT 1
30706: PUSH
30707: LD_INT 5
30709: NEG
30710: PUSH
30711: EMPTY
30712: LIST
30713: LIST
30714: PUSH
30715: EMPTY
30716: LIST
30717: LIST
30718: LIST
30719: LIST
30720: LIST
30721: LIST
30722: LIST
30723: LIST
30724: LIST
30725: LIST
30726: LIST
30727: LIST
30728: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
30729: LD_ADDR_VAR 0 30
30733: PUSH
30734: LD_INT 2
30736: PUSH
30737: LD_INT 1
30739: NEG
30740: PUSH
30741: EMPTY
30742: LIST
30743: LIST
30744: PUSH
30745: LD_INT 3
30747: PUSH
30748: LD_INT 0
30750: PUSH
30751: EMPTY
30752: LIST
30753: LIST
30754: PUSH
30755: LD_INT 3
30757: PUSH
30758: LD_INT 1
30760: PUSH
30761: EMPTY
30762: LIST
30763: LIST
30764: PUSH
30765: LD_INT 3
30767: PUSH
30768: LD_INT 1
30770: NEG
30771: PUSH
30772: EMPTY
30773: LIST
30774: LIST
30775: PUSH
30776: LD_INT 4
30778: PUSH
30779: LD_INT 0
30781: PUSH
30782: EMPTY
30783: LIST
30784: LIST
30785: PUSH
30786: LD_INT 4
30788: PUSH
30789: LD_INT 1
30791: PUSH
30792: EMPTY
30793: LIST
30794: LIST
30795: PUSH
30796: LD_INT 4
30798: PUSH
30799: LD_INT 1
30801: NEG
30802: PUSH
30803: EMPTY
30804: LIST
30805: LIST
30806: PUSH
30807: LD_INT 5
30809: PUSH
30810: LD_INT 0
30812: PUSH
30813: EMPTY
30814: LIST
30815: LIST
30816: PUSH
30817: LD_INT 5
30819: PUSH
30820: LD_INT 1
30822: PUSH
30823: EMPTY
30824: LIST
30825: LIST
30826: PUSH
30827: LD_INT 5
30829: PUSH
30830: LD_INT 1
30832: NEG
30833: PUSH
30834: EMPTY
30835: LIST
30836: LIST
30837: PUSH
30838: LD_INT 6
30840: PUSH
30841: LD_INT 0
30843: PUSH
30844: EMPTY
30845: LIST
30846: LIST
30847: PUSH
30848: LD_INT 6
30850: PUSH
30851: LD_INT 1
30853: PUSH
30854: EMPTY
30855: LIST
30856: LIST
30857: PUSH
30858: EMPTY
30859: LIST
30860: LIST
30861: LIST
30862: LIST
30863: LIST
30864: LIST
30865: LIST
30866: LIST
30867: LIST
30868: LIST
30869: LIST
30870: LIST
30871: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
30872: LD_ADDR_VAR 0 31
30876: PUSH
30877: LD_INT 3
30879: PUSH
30880: LD_INT 2
30882: PUSH
30883: EMPTY
30884: LIST
30885: LIST
30886: PUSH
30887: LD_INT 3
30889: PUSH
30890: LD_INT 3
30892: PUSH
30893: EMPTY
30894: LIST
30895: LIST
30896: PUSH
30897: LD_INT 2
30899: PUSH
30900: LD_INT 3
30902: PUSH
30903: EMPTY
30904: LIST
30905: LIST
30906: PUSH
30907: LD_INT 4
30909: PUSH
30910: LD_INT 3
30912: PUSH
30913: EMPTY
30914: LIST
30915: LIST
30916: PUSH
30917: LD_INT 4
30919: PUSH
30920: LD_INT 4
30922: PUSH
30923: EMPTY
30924: LIST
30925: LIST
30926: PUSH
30927: LD_INT 3
30929: PUSH
30930: LD_INT 4
30932: PUSH
30933: EMPTY
30934: LIST
30935: LIST
30936: PUSH
30937: LD_INT 5
30939: PUSH
30940: LD_INT 4
30942: PUSH
30943: EMPTY
30944: LIST
30945: LIST
30946: PUSH
30947: LD_INT 5
30949: PUSH
30950: LD_INT 5
30952: PUSH
30953: EMPTY
30954: LIST
30955: LIST
30956: PUSH
30957: LD_INT 4
30959: PUSH
30960: LD_INT 5
30962: PUSH
30963: EMPTY
30964: LIST
30965: LIST
30966: PUSH
30967: LD_INT 6
30969: PUSH
30970: LD_INT 5
30972: PUSH
30973: EMPTY
30974: LIST
30975: LIST
30976: PUSH
30977: LD_INT 6
30979: PUSH
30980: LD_INT 6
30982: PUSH
30983: EMPTY
30984: LIST
30985: LIST
30986: PUSH
30987: LD_INT 5
30989: PUSH
30990: LD_INT 6
30992: PUSH
30993: EMPTY
30994: LIST
30995: LIST
30996: PUSH
30997: EMPTY
30998: LIST
30999: LIST
31000: LIST
31001: LIST
31002: LIST
31003: LIST
31004: LIST
31005: LIST
31006: LIST
31007: LIST
31008: LIST
31009: LIST
31010: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
31011: LD_ADDR_VAR 0 32
31015: PUSH
31016: LD_INT 1
31018: PUSH
31019: LD_INT 3
31021: PUSH
31022: EMPTY
31023: LIST
31024: LIST
31025: PUSH
31026: LD_INT 0
31028: PUSH
31029: LD_INT 3
31031: PUSH
31032: EMPTY
31033: LIST
31034: LIST
31035: PUSH
31036: LD_INT 1
31038: NEG
31039: PUSH
31040: LD_INT 2
31042: PUSH
31043: EMPTY
31044: LIST
31045: LIST
31046: PUSH
31047: LD_INT 1
31049: PUSH
31050: LD_INT 4
31052: PUSH
31053: EMPTY
31054: LIST
31055: LIST
31056: PUSH
31057: LD_INT 0
31059: PUSH
31060: LD_INT 4
31062: PUSH
31063: EMPTY
31064: LIST
31065: LIST
31066: PUSH
31067: LD_INT 1
31069: NEG
31070: PUSH
31071: LD_INT 3
31073: PUSH
31074: EMPTY
31075: LIST
31076: LIST
31077: PUSH
31078: LD_INT 1
31080: PUSH
31081: LD_INT 5
31083: PUSH
31084: EMPTY
31085: LIST
31086: LIST
31087: PUSH
31088: LD_INT 0
31090: PUSH
31091: LD_INT 5
31093: PUSH
31094: EMPTY
31095: LIST
31096: LIST
31097: PUSH
31098: LD_INT 1
31100: NEG
31101: PUSH
31102: LD_INT 4
31104: PUSH
31105: EMPTY
31106: LIST
31107: LIST
31108: PUSH
31109: LD_INT 1
31111: PUSH
31112: LD_INT 6
31114: PUSH
31115: EMPTY
31116: LIST
31117: LIST
31118: PUSH
31119: LD_INT 0
31121: PUSH
31122: LD_INT 6
31124: PUSH
31125: EMPTY
31126: LIST
31127: LIST
31128: PUSH
31129: LD_INT 1
31131: NEG
31132: PUSH
31133: LD_INT 5
31135: PUSH
31136: EMPTY
31137: LIST
31138: LIST
31139: PUSH
31140: EMPTY
31141: LIST
31142: LIST
31143: LIST
31144: LIST
31145: LIST
31146: LIST
31147: LIST
31148: LIST
31149: LIST
31150: LIST
31151: LIST
31152: LIST
31153: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
31154: LD_ADDR_VAR 0 33
31158: PUSH
31159: LD_INT 2
31161: NEG
31162: PUSH
31163: LD_INT 1
31165: PUSH
31166: EMPTY
31167: LIST
31168: LIST
31169: PUSH
31170: LD_INT 3
31172: NEG
31173: PUSH
31174: LD_INT 0
31176: PUSH
31177: EMPTY
31178: LIST
31179: LIST
31180: PUSH
31181: LD_INT 3
31183: NEG
31184: PUSH
31185: LD_INT 1
31187: NEG
31188: PUSH
31189: EMPTY
31190: LIST
31191: LIST
31192: PUSH
31193: LD_INT 3
31195: NEG
31196: PUSH
31197: LD_INT 1
31199: PUSH
31200: EMPTY
31201: LIST
31202: LIST
31203: PUSH
31204: LD_INT 4
31206: NEG
31207: PUSH
31208: LD_INT 0
31210: PUSH
31211: EMPTY
31212: LIST
31213: LIST
31214: PUSH
31215: LD_INT 4
31217: NEG
31218: PUSH
31219: LD_INT 1
31221: NEG
31222: PUSH
31223: EMPTY
31224: LIST
31225: LIST
31226: PUSH
31227: LD_INT 4
31229: NEG
31230: PUSH
31231: LD_INT 1
31233: PUSH
31234: EMPTY
31235: LIST
31236: LIST
31237: PUSH
31238: LD_INT 5
31240: NEG
31241: PUSH
31242: LD_INT 0
31244: PUSH
31245: EMPTY
31246: LIST
31247: LIST
31248: PUSH
31249: LD_INT 5
31251: NEG
31252: PUSH
31253: LD_INT 1
31255: NEG
31256: PUSH
31257: EMPTY
31258: LIST
31259: LIST
31260: PUSH
31261: LD_INT 5
31263: NEG
31264: PUSH
31265: LD_INT 1
31267: PUSH
31268: EMPTY
31269: LIST
31270: LIST
31271: PUSH
31272: LD_INT 6
31274: NEG
31275: PUSH
31276: LD_INT 0
31278: PUSH
31279: EMPTY
31280: LIST
31281: LIST
31282: PUSH
31283: LD_INT 6
31285: NEG
31286: PUSH
31287: LD_INT 1
31289: NEG
31290: PUSH
31291: EMPTY
31292: LIST
31293: LIST
31294: PUSH
31295: EMPTY
31296: LIST
31297: LIST
31298: LIST
31299: LIST
31300: LIST
31301: LIST
31302: LIST
31303: LIST
31304: LIST
31305: LIST
31306: LIST
31307: LIST
31308: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
31309: LD_ADDR_VAR 0 34
31313: PUSH
31314: LD_INT 2
31316: NEG
31317: PUSH
31318: LD_INT 3
31320: NEG
31321: PUSH
31322: EMPTY
31323: LIST
31324: LIST
31325: PUSH
31326: LD_INT 3
31328: NEG
31329: PUSH
31330: LD_INT 2
31332: NEG
31333: PUSH
31334: EMPTY
31335: LIST
31336: LIST
31337: PUSH
31338: LD_INT 3
31340: NEG
31341: PUSH
31342: LD_INT 3
31344: NEG
31345: PUSH
31346: EMPTY
31347: LIST
31348: LIST
31349: PUSH
31350: LD_INT 3
31352: NEG
31353: PUSH
31354: LD_INT 4
31356: NEG
31357: PUSH
31358: EMPTY
31359: LIST
31360: LIST
31361: PUSH
31362: LD_INT 4
31364: NEG
31365: PUSH
31366: LD_INT 3
31368: NEG
31369: PUSH
31370: EMPTY
31371: LIST
31372: LIST
31373: PUSH
31374: LD_INT 4
31376: NEG
31377: PUSH
31378: LD_INT 4
31380: NEG
31381: PUSH
31382: EMPTY
31383: LIST
31384: LIST
31385: PUSH
31386: LD_INT 4
31388: NEG
31389: PUSH
31390: LD_INT 5
31392: NEG
31393: PUSH
31394: EMPTY
31395: LIST
31396: LIST
31397: PUSH
31398: LD_INT 5
31400: NEG
31401: PUSH
31402: LD_INT 4
31404: NEG
31405: PUSH
31406: EMPTY
31407: LIST
31408: LIST
31409: PUSH
31410: LD_INT 5
31412: NEG
31413: PUSH
31414: LD_INT 5
31416: NEG
31417: PUSH
31418: EMPTY
31419: LIST
31420: LIST
31421: PUSH
31422: LD_INT 5
31424: NEG
31425: PUSH
31426: LD_INT 6
31428: NEG
31429: PUSH
31430: EMPTY
31431: LIST
31432: LIST
31433: PUSH
31434: LD_INT 6
31436: NEG
31437: PUSH
31438: LD_INT 5
31440: NEG
31441: PUSH
31442: EMPTY
31443: LIST
31444: LIST
31445: PUSH
31446: LD_INT 6
31448: NEG
31449: PUSH
31450: LD_INT 6
31452: NEG
31453: PUSH
31454: EMPTY
31455: LIST
31456: LIST
31457: PUSH
31458: EMPTY
31459: LIST
31460: LIST
31461: LIST
31462: LIST
31463: LIST
31464: LIST
31465: LIST
31466: LIST
31467: LIST
31468: LIST
31469: LIST
31470: LIST
31471: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
31472: LD_ADDR_VAR 0 41
31476: PUSH
31477: LD_INT 0
31479: PUSH
31480: LD_INT 2
31482: NEG
31483: PUSH
31484: EMPTY
31485: LIST
31486: LIST
31487: PUSH
31488: LD_INT 1
31490: NEG
31491: PUSH
31492: LD_INT 3
31494: NEG
31495: PUSH
31496: EMPTY
31497: LIST
31498: LIST
31499: PUSH
31500: LD_INT 1
31502: PUSH
31503: LD_INT 2
31505: NEG
31506: PUSH
31507: EMPTY
31508: LIST
31509: LIST
31510: PUSH
31511: EMPTY
31512: LIST
31513: LIST
31514: LIST
31515: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
31516: LD_ADDR_VAR 0 42
31520: PUSH
31521: LD_INT 2
31523: PUSH
31524: LD_INT 0
31526: PUSH
31527: EMPTY
31528: LIST
31529: LIST
31530: PUSH
31531: LD_INT 2
31533: PUSH
31534: LD_INT 1
31536: NEG
31537: PUSH
31538: EMPTY
31539: LIST
31540: LIST
31541: PUSH
31542: LD_INT 3
31544: PUSH
31545: LD_INT 1
31547: PUSH
31548: EMPTY
31549: LIST
31550: LIST
31551: PUSH
31552: EMPTY
31553: LIST
31554: LIST
31555: LIST
31556: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
31557: LD_ADDR_VAR 0 43
31561: PUSH
31562: LD_INT 2
31564: PUSH
31565: LD_INT 2
31567: PUSH
31568: EMPTY
31569: LIST
31570: LIST
31571: PUSH
31572: LD_INT 3
31574: PUSH
31575: LD_INT 2
31577: PUSH
31578: EMPTY
31579: LIST
31580: LIST
31581: PUSH
31582: LD_INT 2
31584: PUSH
31585: LD_INT 3
31587: PUSH
31588: EMPTY
31589: LIST
31590: LIST
31591: PUSH
31592: EMPTY
31593: LIST
31594: LIST
31595: LIST
31596: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
31597: LD_ADDR_VAR 0 44
31601: PUSH
31602: LD_INT 0
31604: PUSH
31605: LD_INT 2
31607: PUSH
31608: EMPTY
31609: LIST
31610: LIST
31611: PUSH
31612: LD_INT 1
31614: PUSH
31615: LD_INT 3
31617: PUSH
31618: EMPTY
31619: LIST
31620: LIST
31621: PUSH
31622: LD_INT 1
31624: NEG
31625: PUSH
31626: LD_INT 2
31628: PUSH
31629: EMPTY
31630: LIST
31631: LIST
31632: PUSH
31633: EMPTY
31634: LIST
31635: LIST
31636: LIST
31637: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
31638: LD_ADDR_VAR 0 45
31642: PUSH
31643: LD_INT 2
31645: NEG
31646: PUSH
31647: LD_INT 0
31649: PUSH
31650: EMPTY
31651: LIST
31652: LIST
31653: PUSH
31654: LD_INT 2
31656: NEG
31657: PUSH
31658: LD_INT 1
31660: PUSH
31661: EMPTY
31662: LIST
31663: LIST
31664: PUSH
31665: LD_INT 3
31667: NEG
31668: PUSH
31669: LD_INT 1
31671: NEG
31672: PUSH
31673: EMPTY
31674: LIST
31675: LIST
31676: PUSH
31677: EMPTY
31678: LIST
31679: LIST
31680: LIST
31681: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
31682: LD_ADDR_VAR 0 46
31686: PUSH
31687: LD_INT 2
31689: NEG
31690: PUSH
31691: LD_INT 2
31693: NEG
31694: PUSH
31695: EMPTY
31696: LIST
31697: LIST
31698: PUSH
31699: LD_INT 2
31701: NEG
31702: PUSH
31703: LD_INT 3
31705: NEG
31706: PUSH
31707: EMPTY
31708: LIST
31709: LIST
31710: PUSH
31711: LD_INT 3
31713: NEG
31714: PUSH
31715: LD_INT 2
31717: NEG
31718: PUSH
31719: EMPTY
31720: LIST
31721: LIST
31722: PUSH
31723: EMPTY
31724: LIST
31725: LIST
31726: LIST
31727: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
31728: LD_ADDR_VAR 0 47
31732: PUSH
31733: LD_INT 2
31735: NEG
31736: PUSH
31737: LD_INT 3
31739: NEG
31740: PUSH
31741: EMPTY
31742: LIST
31743: LIST
31744: PUSH
31745: LD_INT 1
31747: NEG
31748: PUSH
31749: LD_INT 3
31751: NEG
31752: PUSH
31753: EMPTY
31754: LIST
31755: LIST
31756: PUSH
31757: EMPTY
31758: LIST
31759: LIST
31760: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
31761: LD_ADDR_VAR 0 48
31765: PUSH
31766: LD_INT 1
31768: PUSH
31769: LD_INT 2
31771: NEG
31772: PUSH
31773: EMPTY
31774: LIST
31775: LIST
31776: PUSH
31777: LD_INT 2
31779: PUSH
31780: LD_INT 1
31782: NEG
31783: PUSH
31784: EMPTY
31785: LIST
31786: LIST
31787: PUSH
31788: EMPTY
31789: LIST
31790: LIST
31791: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
31792: LD_ADDR_VAR 0 49
31796: PUSH
31797: LD_INT 3
31799: PUSH
31800: LD_INT 1
31802: PUSH
31803: EMPTY
31804: LIST
31805: LIST
31806: PUSH
31807: LD_INT 3
31809: PUSH
31810: LD_INT 2
31812: PUSH
31813: EMPTY
31814: LIST
31815: LIST
31816: PUSH
31817: EMPTY
31818: LIST
31819: LIST
31820: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
31821: LD_ADDR_VAR 0 50
31825: PUSH
31826: LD_INT 2
31828: PUSH
31829: LD_INT 3
31831: PUSH
31832: EMPTY
31833: LIST
31834: LIST
31835: PUSH
31836: LD_INT 1
31838: PUSH
31839: LD_INT 3
31841: PUSH
31842: EMPTY
31843: LIST
31844: LIST
31845: PUSH
31846: EMPTY
31847: LIST
31848: LIST
31849: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
31850: LD_ADDR_VAR 0 51
31854: PUSH
31855: LD_INT 1
31857: NEG
31858: PUSH
31859: LD_INT 2
31861: PUSH
31862: EMPTY
31863: LIST
31864: LIST
31865: PUSH
31866: LD_INT 2
31868: NEG
31869: PUSH
31870: LD_INT 1
31872: PUSH
31873: EMPTY
31874: LIST
31875: LIST
31876: PUSH
31877: EMPTY
31878: LIST
31879: LIST
31880: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31881: LD_ADDR_VAR 0 52
31885: PUSH
31886: LD_INT 3
31888: NEG
31889: PUSH
31890: LD_INT 1
31892: NEG
31893: PUSH
31894: EMPTY
31895: LIST
31896: LIST
31897: PUSH
31898: LD_INT 3
31900: NEG
31901: PUSH
31902: LD_INT 2
31904: NEG
31905: PUSH
31906: EMPTY
31907: LIST
31908: LIST
31909: PUSH
31910: EMPTY
31911: LIST
31912: LIST
31913: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
31914: LD_ADDR_VAR 0 53
31918: PUSH
31919: LD_INT 1
31921: NEG
31922: PUSH
31923: LD_INT 3
31925: NEG
31926: PUSH
31927: EMPTY
31928: LIST
31929: LIST
31930: PUSH
31931: LD_INT 0
31933: PUSH
31934: LD_INT 3
31936: NEG
31937: PUSH
31938: EMPTY
31939: LIST
31940: LIST
31941: PUSH
31942: LD_INT 1
31944: PUSH
31945: LD_INT 2
31947: NEG
31948: PUSH
31949: EMPTY
31950: LIST
31951: LIST
31952: PUSH
31953: EMPTY
31954: LIST
31955: LIST
31956: LIST
31957: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
31958: LD_ADDR_VAR 0 54
31962: PUSH
31963: LD_INT 2
31965: PUSH
31966: LD_INT 1
31968: NEG
31969: PUSH
31970: EMPTY
31971: LIST
31972: LIST
31973: PUSH
31974: LD_INT 3
31976: PUSH
31977: LD_INT 0
31979: PUSH
31980: EMPTY
31981: LIST
31982: LIST
31983: PUSH
31984: LD_INT 3
31986: PUSH
31987: LD_INT 1
31989: PUSH
31990: EMPTY
31991: LIST
31992: LIST
31993: PUSH
31994: EMPTY
31995: LIST
31996: LIST
31997: LIST
31998: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
31999: LD_ADDR_VAR 0 55
32003: PUSH
32004: LD_INT 3
32006: PUSH
32007: LD_INT 2
32009: PUSH
32010: EMPTY
32011: LIST
32012: LIST
32013: PUSH
32014: LD_INT 3
32016: PUSH
32017: LD_INT 3
32019: PUSH
32020: EMPTY
32021: LIST
32022: LIST
32023: PUSH
32024: LD_INT 2
32026: PUSH
32027: LD_INT 3
32029: PUSH
32030: EMPTY
32031: LIST
32032: LIST
32033: PUSH
32034: EMPTY
32035: LIST
32036: LIST
32037: LIST
32038: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
32039: LD_ADDR_VAR 0 56
32043: PUSH
32044: LD_INT 1
32046: PUSH
32047: LD_INT 3
32049: PUSH
32050: EMPTY
32051: LIST
32052: LIST
32053: PUSH
32054: LD_INT 0
32056: PUSH
32057: LD_INT 3
32059: PUSH
32060: EMPTY
32061: LIST
32062: LIST
32063: PUSH
32064: LD_INT 1
32066: NEG
32067: PUSH
32068: LD_INT 2
32070: PUSH
32071: EMPTY
32072: LIST
32073: LIST
32074: PUSH
32075: EMPTY
32076: LIST
32077: LIST
32078: LIST
32079: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
32080: LD_ADDR_VAR 0 57
32084: PUSH
32085: LD_INT 2
32087: NEG
32088: PUSH
32089: LD_INT 1
32091: PUSH
32092: EMPTY
32093: LIST
32094: LIST
32095: PUSH
32096: LD_INT 3
32098: NEG
32099: PUSH
32100: LD_INT 0
32102: PUSH
32103: EMPTY
32104: LIST
32105: LIST
32106: PUSH
32107: LD_INT 3
32109: NEG
32110: PUSH
32111: LD_INT 1
32113: NEG
32114: PUSH
32115: EMPTY
32116: LIST
32117: LIST
32118: PUSH
32119: EMPTY
32120: LIST
32121: LIST
32122: LIST
32123: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32124: LD_ADDR_VAR 0 58
32128: PUSH
32129: LD_INT 2
32131: NEG
32132: PUSH
32133: LD_INT 3
32135: NEG
32136: PUSH
32137: EMPTY
32138: LIST
32139: LIST
32140: PUSH
32141: LD_INT 3
32143: NEG
32144: PUSH
32145: LD_INT 2
32147: NEG
32148: PUSH
32149: EMPTY
32150: LIST
32151: LIST
32152: PUSH
32153: LD_INT 3
32155: NEG
32156: PUSH
32157: LD_INT 3
32159: NEG
32160: PUSH
32161: EMPTY
32162: LIST
32163: LIST
32164: PUSH
32165: EMPTY
32166: LIST
32167: LIST
32168: LIST
32169: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
32170: LD_ADDR_VAR 0 59
32174: PUSH
32175: LD_INT 1
32177: NEG
32178: PUSH
32179: LD_INT 2
32181: NEG
32182: PUSH
32183: EMPTY
32184: LIST
32185: LIST
32186: PUSH
32187: LD_INT 0
32189: PUSH
32190: LD_INT 2
32192: NEG
32193: PUSH
32194: EMPTY
32195: LIST
32196: LIST
32197: PUSH
32198: LD_INT 1
32200: PUSH
32201: LD_INT 1
32203: NEG
32204: PUSH
32205: EMPTY
32206: LIST
32207: LIST
32208: PUSH
32209: EMPTY
32210: LIST
32211: LIST
32212: LIST
32213: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
32214: LD_ADDR_VAR 0 60
32218: PUSH
32219: LD_INT 1
32221: PUSH
32222: LD_INT 1
32224: NEG
32225: PUSH
32226: EMPTY
32227: LIST
32228: LIST
32229: PUSH
32230: LD_INT 2
32232: PUSH
32233: LD_INT 0
32235: PUSH
32236: EMPTY
32237: LIST
32238: LIST
32239: PUSH
32240: LD_INT 2
32242: PUSH
32243: LD_INT 1
32245: PUSH
32246: EMPTY
32247: LIST
32248: LIST
32249: PUSH
32250: EMPTY
32251: LIST
32252: LIST
32253: LIST
32254: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
32255: LD_ADDR_VAR 0 61
32259: PUSH
32260: LD_INT 2
32262: PUSH
32263: LD_INT 1
32265: PUSH
32266: EMPTY
32267: LIST
32268: LIST
32269: PUSH
32270: LD_INT 2
32272: PUSH
32273: LD_INT 2
32275: PUSH
32276: EMPTY
32277: LIST
32278: LIST
32279: PUSH
32280: LD_INT 1
32282: PUSH
32283: LD_INT 2
32285: PUSH
32286: EMPTY
32287: LIST
32288: LIST
32289: PUSH
32290: EMPTY
32291: LIST
32292: LIST
32293: LIST
32294: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
32295: LD_ADDR_VAR 0 62
32299: PUSH
32300: LD_INT 1
32302: PUSH
32303: LD_INT 2
32305: PUSH
32306: EMPTY
32307: LIST
32308: LIST
32309: PUSH
32310: LD_INT 0
32312: PUSH
32313: LD_INT 2
32315: PUSH
32316: EMPTY
32317: LIST
32318: LIST
32319: PUSH
32320: LD_INT 1
32322: NEG
32323: PUSH
32324: LD_INT 1
32326: PUSH
32327: EMPTY
32328: LIST
32329: LIST
32330: PUSH
32331: EMPTY
32332: LIST
32333: LIST
32334: LIST
32335: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
32336: LD_ADDR_VAR 0 63
32340: PUSH
32341: LD_INT 1
32343: NEG
32344: PUSH
32345: LD_INT 1
32347: PUSH
32348: EMPTY
32349: LIST
32350: LIST
32351: PUSH
32352: LD_INT 2
32354: NEG
32355: PUSH
32356: LD_INT 0
32358: PUSH
32359: EMPTY
32360: LIST
32361: LIST
32362: PUSH
32363: LD_INT 2
32365: NEG
32366: PUSH
32367: LD_INT 1
32369: NEG
32370: PUSH
32371: EMPTY
32372: LIST
32373: LIST
32374: PUSH
32375: EMPTY
32376: LIST
32377: LIST
32378: LIST
32379: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32380: LD_ADDR_VAR 0 64
32384: PUSH
32385: LD_INT 1
32387: NEG
32388: PUSH
32389: LD_INT 2
32391: NEG
32392: PUSH
32393: EMPTY
32394: LIST
32395: LIST
32396: PUSH
32397: LD_INT 2
32399: NEG
32400: PUSH
32401: LD_INT 1
32403: NEG
32404: PUSH
32405: EMPTY
32406: LIST
32407: LIST
32408: PUSH
32409: LD_INT 2
32411: NEG
32412: PUSH
32413: LD_INT 2
32415: NEG
32416: PUSH
32417: EMPTY
32418: LIST
32419: LIST
32420: PUSH
32421: EMPTY
32422: LIST
32423: LIST
32424: LIST
32425: ST_TO_ADDR
// end ; 2 :
32426: GO 35692
32428: LD_INT 2
32430: DOUBLE
32431: EQUAL
32432: IFTRUE 32436
32434: GO 35691
32436: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
32437: LD_ADDR_VAR 0 29
32441: PUSH
32442: LD_INT 4
32444: PUSH
32445: LD_INT 0
32447: PUSH
32448: EMPTY
32449: LIST
32450: LIST
32451: PUSH
32452: LD_INT 4
32454: PUSH
32455: LD_INT 1
32457: NEG
32458: PUSH
32459: EMPTY
32460: LIST
32461: LIST
32462: PUSH
32463: LD_INT 5
32465: PUSH
32466: LD_INT 0
32468: PUSH
32469: EMPTY
32470: LIST
32471: LIST
32472: PUSH
32473: LD_INT 5
32475: PUSH
32476: LD_INT 1
32478: PUSH
32479: EMPTY
32480: LIST
32481: LIST
32482: PUSH
32483: LD_INT 4
32485: PUSH
32486: LD_INT 1
32488: PUSH
32489: EMPTY
32490: LIST
32491: LIST
32492: PUSH
32493: LD_INT 3
32495: PUSH
32496: LD_INT 0
32498: PUSH
32499: EMPTY
32500: LIST
32501: LIST
32502: PUSH
32503: LD_INT 3
32505: PUSH
32506: LD_INT 1
32508: NEG
32509: PUSH
32510: EMPTY
32511: LIST
32512: LIST
32513: PUSH
32514: LD_INT 3
32516: PUSH
32517: LD_INT 2
32519: NEG
32520: PUSH
32521: EMPTY
32522: LIST
32523: LIST
32524: PUSH
32525: LD_INT 5
32527: PUSH
32528: LD_INT 2
32530: PUSH
32531: EMPTY
32532: LIST
32533: LIST
32534: PUSH
32535: LD_INT 3
32537: PUSH
32538: LD_INT 3
32540: PUSH
32541: EMPTY
32542: LIST
32543: LIST
32544: PUSH
32545: LD_INT 3
32547: PUSH
32548: LD_INT 2
32550: PUSH
32551: EMPTY
32552: LIST
32553: LIST
32554: PUSH
32555: LD_INT 4
32557: PUSH
32558: LD_INT 3
32560: PUSH
32561: EMPTY
32562: LIST
32563: LIST
32564: PUSH
32565: LD_INT 4
32567: PUSH
32568: LD_INT 4
32570: PUSH
32571: EMPTY
32572: LIST
32573: LIST
32574: PUSH
32575: LD_INT 3
32577: PUSH
32578: LD_INT 4
32580: PUSH
32581: EMPTY
32582: LIST
32583: LIST
32584: PUSH
32585: LD_INT 2
32587: PUSH
32588: LD_INT 3
32590: PUSH
32591: EMPTY
32592: LIST
32593: LIST
32594: PUSH
32595: LD_INT 2
32597: PUSH
32598: LD_INT 2
32600: PUSH
32601: EMPTY
32602: LIST
32603: LIST
32604: PUSH
32605: LD_INT 4
32607: PUSH
32608: LD_INT 2
32610: PUSH
32611: EMPTY
32612: LIST
32613: LIST
32614: PUSH
32615: LD_INT 2
32617: PUSH
32618: LD_INT 4
32620: PUSH
32621: EMPTY
32622: LIST
32623: LIST
32624: PUSH
32625: LD_INT 0
32627: PUSH
32628: LD_INT 4
32630: PUSH
32631: EMPTY
32632: LIST
32633: LIST
32634: PUSH
32635: LD_INT 0
32637: PUSH
32638: LD_INT 3
32640: PUSH
32641: EMPTY
32642: LIST
32643: LIST
32644: PUSH
32645: LD_INT 1
32647: PUSH
32648: LD_INT 4
32650: PUSH
32651: EMPTY
32652: LIST
32653: LIST
32654: PUSH
32655: LD_INT 1
32657: PUSH
32658: LD_INT 5
32660: PUSH
32661: EMPTY
32662: LIST
32663: LIST
32664: PUSH
32665: LD_INT 0
32667: PUSH
32668: LD_INT 5
32670: PUSH
32671: EMPTY
32672: LIST
32673: LIST
32674: PUSH
32675: LD_INT 1
32677: NEG
32678: PUSH
32679: LD_INT 4
32681: PUSH
32682: EMPTY
32683: LIST
32684: LIST
32685: PUSH
32686: LD_INT 1
32688: NEG
32689: PUSH
32690: LD_INT 3
32692: PUSH
32693: EMPTY
32694: LIST
32695: LIST
32696: PUSH
32697: LD_INT 2
32699: PUSH
32700: LD_INT 5
32702: PUSH
32703: EMPTY
32704: LIST
32705: LIST
32706: PUSH
32707: LD_INT 2
32709: NEG
32710: PUSH
32711: LD_INT 3
32713: PUSH
32714: EMPTY
32715: LIST
32716: LIST
32717: PUSH
32718: LD_INT 3
32720: NEG
32721: PUSH
32722: LD_INT 0
32724: PUSH
32725: EMPTY
32726: LIST
32727: LIST
32728: PUSH
32729: LD_INT 3
32731: NEG
32732: PUSH
32733: LD_INT 1
32735: NEG
32736: PUSH
32737: EMPTY
32738: LIST
32739: LIST
32740: PUSH
32741: LD_INT 2
32743: NEG
32744: PUSH
32745: LD_INT 0
32747: PUSH
32748: EMPTY
32749: LIST
32750: LIST
32751: PUSH
32752: LD_INT 2
32754: NEG
32755: PUSH
32756: LD_INT 1
32758: PUSH
32759: EMPTY
32760: LIST
32761: LIST
32762: PUSH
32763: LD_INT 3
32765: NEG
32766: PUSH
32767: LD_INT 1
32769: PUSH
32770: EMPTY
32771: LIST
32772: LIST
32773: PUSH
32774: LD_INT 4
32776: NEG
32777: PUSH
32778: LD_INT 0
32780: PUSH
32781: EMPTY
32782: LIST
32783: LIST
32784: PUSH
32785: LD_INT 4
32787: NEG
32788: PUSH
32789: LD_INT 1
32791: NEG
32792: PUSH
32793: EMPTY
32794: LIST
32795: LIST
32796: PUSH
32797: LD_INT 4
32799: NEG
32800: PUSH
32801: LD_INT 2
32803: NEG
32804: PUSH
32805: EMPTY
32806: LIST
32807: LIST
32808: PUSH
32809: LD_INT 2
32811: NEG
32812: PUSH
32813: LD_INT 2
32815: PUSH
32816: EMPTY
32817: LIST
32818: LIST
32819: PUSH
32820: LD_INT 4
32822: NEG
32823: PUSH
32824: LD_INT 4
32826: NEG
32827: PUSH
32828: EMPTY
32829: LIST
32830: LIST
32831: PUSH
32832: LD_INT 4
32834: NEG
32835: PUSH
32836: LD_INT 5
32838: NEG
32839: PUSH
32840: EMPTY
32841: LIST
32842: LIST
32843: PUSH
32844: LD_INT 3
32846: NEG
32847: PUSH
32848: LD_INT 4
32850: NEG
32851: PUSH
32852: EMPTY
32853: LIST
32854: LIST
32855: PUSH
32856: LD_INT 3
32858: NEG
32859: PUSH
32860: LD_INT 3
32862: NEG
32863: PUSH
32864: EMPTY
32865: LIST
32866: LIST
32867: PUSH
32868: LD_INT 4
32870: NEG
32871: PUSH
32872: LD_INT 3
32874: NEG
32875: PUSH
32876: EMPTY
32877: LIST
32878: LIST
32879: PUSH
32880: LD_INT 5
32882: NEG
32883: PUSH
32884: LD_INT 4
32886: NEG
32887: PUSH
32888: EMPTY
32889: LIST
32890: LIST
32891: PUSH
32892: LD_INT 5
32894: NEG
32895: PUSH
32896: LD_INT 5
32898: NEG
32899: PUSH
32900: EMPTY
32901: LIST
32902: LIST
32903: PUSH
32904: LD_INT 3
32906: NEG
32907: PUSH
32908: LD_INT 5
32910: NEG
32911: PUSH
32912: EMPTY
32913: LIST
32914: LIST
32915: PUSH
32916: LD_INT 5
32918: NEG
32919: PUSH
32920: LD_INT 3
32922: NEG
32923: PUSH
32924: EMPTY
32925: LIST
32926: LIST
32927: PUSH
32928: EMPTY
32929: LIST
32930: LIST
32931: LIST
32932: LIST
32933: LIST
32934: LIST
32935: LIST
32936: LIST
32937: LIST
32938: LIST
32939: LIST
32940: LIST
32941: LIST
32942: LIST
32943: LIST
32944: LIST
32945: LIST
32946: LIST
32947: LIST
32948: LIST
32949: LIST
32950: LIST
32951: LIST
32952: LIST
32953: LIST
32954: LIST
32955: LIST
32956: LIST
32957: LIST
32958: LIST
32959: LIST
32960: LIST
32961: LIST
32962: LIST
32963: LIST
32964: LIST
32965: LIST
32966: LIST
32967: LIST
32968: LIST
32969: LIST
32970: LIST
32971: LIST
32972: LIST
32973: LIST
32974: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
32975: LD_ADDR_VAR 0 30
32979: PUSH
32980: LD_INT 4
32982: PUSH
32983: LD_INT 4
32985: PUSH
32986: EMPTY
32987: LIST
32988: LIST
32989: PUSH
32990: LD_INT 4
32992: PUSH
32993: LD_INT 3
32995: PUSH
32996: EMPTY
32997: LIST
32998: LIST
32999: PUSH
33000: LD_INT 5
33002: PUSH
33003: LD_INT 4
33005: PUSH
33006: EMPTY
33007: LIST
33008: LIST
33009: PUSH
33010: LD_INT 5
33012: PUSH
33013: LD_INT 5
33015: PUSH
33016: EMPTY
33017: LIST
33018: LIST
33019: PUSH
33020: LD_INT 4
33022: PUSH
33023: LD_INT 5
33025: PUSH
33026: EMPTY
33027: LIST
33028: LIST
33029: PUSH
33030: LD_INT 3
33032: PUSH
33033: LD_INT 4
33035: PUSH
33036: EMPTY
33037: LIST
33038: LIST
33039: PUSH
33040: LD_INT 3
33042: PUSH
33043: LD_INT 3
33045: PUSH
33046: EMPTY
33047: LIST
33048: LIST
33049: PUSH
33050: LD_INT 5
33052: PUSH
33053: LD_INT 3
33055: PUSH
33056: EMPTY
33057: LIST
33058: LIST
33059: PUSH
33060: LD_INT 3
33062: PUSH
33063: LD_INT 5
33065: PUSH
33066: EMPTY
33067: LIST
33068: LIST
33069: PUSH
33070: LD_INT 0
33072: PUSH
33073: LD_INT 3
33075: PUSH
33076: EMPTY
33077: LIST
33078: LIST
33079: PUSH
33080: LD_INT 0
33082: PUSH
33083: LD_INT 2
33085: PUSH
33086: EMPTY
33087: LIST
33088: LIST
33089: PUSH
33090: LD_INT 1
33092: PUSH
33093: LD_INT 3
33095: PUSH
33096: EMPTY
33097: LIST
33098: LIST
33099: PUSH
33100: LD_INT 1
33102: PUSH
33103: LD_INT 4
33105: PUSH
33106: EMPTY
33107: LIST
33108: LIST
33109: PUSH
33110: LD_INT 0
33112: PUSH
33113: LD_INT 4
33115: PUSH
33116: EMPTY
33117: LIST
33118: LIST
33119: PUSH
33120: LD_INT 1
33122: NEG
33123: PUSH
33124: LD_INT 3
33126: PUSH
33127: EMPTY
33128: LIST
33129: LIST
33130: PUSH
33131: LD_INT 1
33133: NEG
33134: PUSH
33135: LD_INT 2
33137: PUSH
33138: EMPTY
33139: LIST
33140: LIST
33141: PUSH
33142: LD_INT 2
33144: PUSH
33145: LD_INT 4
33147: PUSH
33148: EMPTY
33149: LIST
33150: LIST
33151: PUSH
33152: LD_INT 2
33154: NEG
33155: PUSH
33156: LD_INT 2
33158: PUSH
33159: EMPTY
33160: LIST
33161: LIST
33162: PUSH
33163: LD_INT 4
33165: NEG
33166: PUSH
33167: LD_INT 0
33169: PUSH
33170: EMPTY
33171: LIST
33172: LIST
33173: PUSH
33174: LD_INT 4
33176: NEG
33177: PUSH
33178: LD_INT 1
33180: NEG
33181: PUSH
33182: EMPTY
33183: LIST
33184: LIST
33185: PUSH
33186: LD_INT 3
33188: NEG
33189: PUSH
33190: LD_INT 0
33192: PUSH
33193: EMPTY
33194: LIST
33195: LIST
33196: PUSH
33197: LD_INT 3
33199: NEG
33200: PUSH
33201: LD_INT 1
33203: PUSH
33204: EMPTY
33205: LIST
33206: LIST
33207: PUSH
33208: LD_INT 4
33210: NEG
33211: PUSH
33212: LD_INT 1
33214: PUSH
33215: EMPTY
33216: LIST
33217: LIST
33218: PUSH
33219: LD_INT 5
33221: NEG
33222: PUSH
33223: LD_INT 0
33225: PUSH
33226: EMPTY
33227: LIST
33228: LIST
33229: PUSH
33230: LD_INT 5
33232: NEG
33233: PUSH
33234: LD_INT 1
33236: NEG
33237: PUSH
33238: EMPTY
33239: LIST
33240: LIST
33241: PUSH
33242: LD_INT 5
33244: NEG
33245: PUSH
33246: LD_INT 2
33248: NEG
33249: PUSH
33250: EMPTY
33251: LIST
33252: LIST
33253: PUSH
33254: LD_INT 3
33256: NEG
33257: PUSH
33258: LD_INT 2
33260: PUSH
33261: EMPTY
33262: LIST
33263: LIST
33264: PUSH
33265: LD_INT 3
33267: NEG
33268: PUSH
33269: LD_INT 3
33271: NEG
33272: PUSH
33273: EMPTY
33274: LIST
33275: LIST
33276: PUSH
33277: LD_INT 3
33279: NEG
33280: PUSH
33281: LD_INT 4
33283: NEG
33284: PUSH
33285: EMPTY
33286: LIST
33287: LIST
33288: PUSH
33289: LD_INT 2
33291: NEG
33292: PUSH
33293: LD_INT 3
33295: NEG
33296: PUSH
33297: EMPTY
33298: LIST
33299: LIST
33300: PUSH
33301: LD_INT 2
33303: NEG
33304: PUSH
33305: LD_INT 2
33307: NEG
33308: PUSH
33309: EMPTY
33310: LIST
33311: LIST
33312: PUSH
33313: LD_INT 3
33315: NEG
33316: PUSH
33317: LD_INT 2
33319: NEG
33320: PUSH
33321: EMPTY
33322: LIST
33323: LIST
33324: PUSH
33325: LD_INT 4
33327: NEG
33328: PUSH
33329: LD_INT 3
33331: NEG
33332: PUSH
33333: EMPTY
33334: LIST
33335: LIST
33336: PUSH
33337: LD_INT 4
33339: NEG
33340: PUSH
33341: LD_INT 4
33343: NEG
33344: PUSH
33345: EMPTY
33346: LIST
33347: LIST
33348: PUSH
33349: LD_INT 2
33351: NEG
33352: PUSH
33353: LD_INT 4
33355: NEG
33356: PUSH
33357: EMPTY
33358: LIST
33359: LIST
33360: PUSH
33361: LD_INT 4
33363: NEG
33364: PUSH
33365: LD_INT 2
33367: NEG
33368: PUSH
33369: EMPTY
33370: LIST
33371: LIST
33372: PUSH
33373: LD_INT 0
33375: PUSH
33376: LD_INT 4
33378: NEG
33379: PUSH
33380: EMPTY
33381: LIST
33382: LIST
33383: PUSH
33384: LD_INT 0
33386: PUSH
33387: LD_INT 5
33389: NEG
33390: PUSH
33391: EMPTY
33392: LIST
33393: LIST
33394: PUSH
33395: LD_INT 1
33397: PUSH
33398: LD_INT 4
33400: NEG
33401: PUSH
33402: EMPTY
33403: LIST
33404: LIST
33405: PUSH
33406: LD_INT 1
33408: PUSH
33409: LD_INT 3
33411: NEG
33412: PUSH
33413: EMPTY
33414: LIST
33415: LIST
33416: PUSH
33417: LD_INT 0
33419: PUSH
33420: LD_INT 3
33422: NEG
33423: PUSH
33424: EMPTY
33425: LIST
33426: LIST
33427: PUSH
33428: LD_INT 1
33430: NEG
33431: PUSH
33432: LD_INT 4
33434: NEG
33435: PUSH
33436: EMPTY
33437: LIST
33438: LIST
33439: PUSH
33440: LD_INT 1
33442: NEG
33443: PUSH
33444: LD_INT 5
33446: NEG
33447: PUSH
33448: EMPTY
33449: LIST
33450: LIST
33451: PUSH
33452: LD_INT 2
33454: PUSH
33455: LD_INT 3
33457: NEG
33458: PUSH
33459: EMPTY
33460: LIST
33461: LIST
33462: PUSH
33463: LD_INT 2
33465: NEG
33466: PUSH
33467: LD_INT 5
33469: NEG
33470: PUSH
33471: EMPTY
33472: LIST
33473: LIST
33474: PUSH
33475: EMPTY
33476: LIST
33477: LIST
33478: LIST
33479: LIST
33480: LIST
33481: LIST
33482: LIST
33483: LIST
33484: LIST
33485: LIST
33486: LIST
33487: LIST
33488: LIST
33489: LIST
33490: LIST
33491: LIST
33492: LIST
33493: LIST
33494: LIST
33495: LIST
33496: LIST
33497: LIST
33498: LIST
33499: LIST
33500: LIST
33501: LIST
33502: LIST
33503: LIST
33504: LIST
33505: LIST
33506: LIST
33507: LIST
33508: LIST
33509: LIST
33510: LIST
33511: LIST
33512: LIST
33513: LIST
33514: LIST
33515: LIST
33516: LIST
33517: LIST
33518: LIST
33519: LIST
33520: LIST
33521: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
33522: LD_ADDR_VAR 0 31
33526: PUSH
33527: LD_INT 0
33529: PUSH
33530: LD_INT 4
33532: PUSH
33533: EMPTY
33534: LIST
33535: LIST
33536: PUSH
33537: LD_INT 0
33539: PUSH
33540: LD_INT 3
33542: PUSH
33543: EMPTY
33544: LIST
33545: LIST
33546: PUSH
33547: LD_INT 1
33549: PUSH
33550: LD_INT 4
33552: PUSH
33553: EMPTY
33554: LIST
33555: LIST
33556: PUSH
33557: LD_INT 1
33559: PUSH
33560: LD_INT 5
33562: PUSH
33563: EMPTY
33564: LIST
33565: LIST
33566: PUSH
33567: LD_INT 0
33569: PUSH
33570: LD_INT 5
33572: PUSH
33573: EMPTY
33574: LIST
33575: LIST
33576: PUSH
33577: LD_INT 1
33579: NEG
33580: PUSH
33581: LD_INT 4
33583: PUSH
33584: EMPTY
33585: LIST
33586: LIST
33587: PUSH
33588: LD_INT 1
33590: NEG
33591: PUSH
33592: LD_INT 3
33594: PUSH
33595: EMPTY
33596: LIST
33597: LIST
33598: PUSH
33599: LD_INT 2
33601: PUSH
33602: LD_INT 5
33604: PUSH
33605: EMPTY
33606: LIST
33607: LIST
33608: PUSH
33609: LD_INT 2
33611: NEG
33612: PUSH
33613: LD_INT 3
33615: PUSH
33616: EMPTY
33617: LIST
33618: LIST
33619: PUSH
33620: LD_INT 3
33622: NEG
33623: PUSH
33624: LD_INT 0
33626: PUSH
33627: EMPTY
33628: LIST
33629: LIST
33630: PUSH
33631: LD_INT 3
33633: NEG
33634: PUSH
33635: LD_INT 1
33637: NEG
33638: PUSH
33639: EMPTY
33640: LIST
33641: LIST
33642: PUSH
33643: LD_INT 2
33645: NEG
33646: PUSH
33647: LD_INT 0
33649: PUSH
33650: EMPTY
33651: LIST
33652: LIST
33653: PUSH
33654: LD_INT 2
33656: NEG
33657: PUSH
33658: LD_INT 1
33660: PUSH
33661: EMPTY
33662: LIST
33663: LIST
33664: PUSH
33665: LD_INT 3
33667: NEG
33668: PUSH
33669: LD_INT 1
33671: PUSH
33672: EMPTY
33673: LIST
33674: LIST
33675: PUSH
33676: LD_INT 4
33678: NEG
33679: PUSH
33680: LD_INT 0
33682: PUSH
33683: EMPTY
33684: LIST
33685: LIST
33686: PUSH
33687: LD_INT 4
33689: NEG
33690: PUSH
33691: LD_INT 1
33693: NEG
33694: PUSH
33695: EMPTY
33696: LIST
33697: LIST
33698: PUSH
33699: LD_INT 4
33701: NEG
33702: PUSH
33703: LD_INT 2
33705: NEG
33706: PUSH
33707: EMPTY
33708: LIST
33709: LIST
33710: PUSH
33711: LD_INT 2
33713: NEG
33714: PUSH
33715: LD_INT 2
33717: PUSH
33718: EMPTY
33719: LIST
33720: LIST
33721: PUSH
33722: LD_INT 4
33724: NEG
33725: PUSH
33726: LD_INT 4
33728: NEG
33729: PUSH
33730: EMPTY
33731: LIST
33732: LIST
33733: PUSH
33734: LD_INT 4
33736: NEG
33737: PUSH
33738: LD_INT 5
33740: NEG
33741: PUSH
33742: EMPTY
33743: LIST
33744: LIST
33745: PUSH
33746: LD_INT 3
33748: NEG
33749: PUSH
33750: LD_INT 4
33752: NEG
33753: PUSH
33754: EMPTY
33755: LIST
33756: LIST
33757: PUSH
33758: LD_INT 3
33760: NEG
33761: PUSH
33762: LD_INT 3
33764: NEG
33765: PUSH
33766: EMPTY
33767: LIST
33768: LIST
33769: PUSH
33770: LD_INT 4
33772: NEG
33773: PUSH
33774: LD_INT 3
33776: NEG
33777: PUSH
33778: EMPTY
33779: LIST
33780: LIST
33781: PUSH
33782: LD_INT 5
33784: NEG
33785: PUSH
33786: LD_INT 4
33788: NEG
33789: PUSH
33790: EMPTY
33791: LIST
33792: LIST
33793: PUSH
33794: LD_INT 5
33796: NEG
33797: PUSH
33798: LD_INT 5
33800: NEG
33801: PUSH
33802: EMPTY
33803: LIST
33804: LIST
33805: PUSH
33806: LD_INT 3
33808: NEG
33809: PUSH
33810: LD_INT 5
33812: NEG
33813: PUSH
33814: EMPTY
33815: LIST
33816: LIST
33817: PUSH
33818: LD_INT 5
33820: NEG
33821: PUSH
33822: LD_INT 3
33824: NEG
33825: PUSH
33826: EMPTY
33827: LIST
33828: LIST
33829: PUSH
33830: LD_INT 0
33832: PUSH
33833: LD_INT 3
33835: NEG
33836: PUSH
33837: EMPTY
33838: LIST
33839: LIST
33840: PUSH
33841: LD_INT 0
33843: PUSH
33844: LD_INT 4
33846: NEG
33847: PUSH
33848: EMPTY
33849: LIST
33850: LIST
33851: PUSH
33852: LD_INT 1
33854: PUSH
33855: LD_INT 3
33857: NEG
33858: PUSH
33859: EMPTY
33860: LIST
33861: LIST
33862: PUSH
33863: LD_INT 1
33865: PUSH
33866: LD_INT 2
33868: NEG
33869: PUSH
33870: EMPTY
33871: LIST
33872: LIST
33873: PUSH
33874: LD_INT 0
33876: PUSH
33877: LD_INT 2
33879: NEG
33880: PUSH
33881: EMPTY
33882: LIST
33883: LIST
33884: PUSH
33885: LD_INT 1
33887: NEG
33888: PUSH
33889: LD_INT 3
33891: NEG
33892: PUSH
33893: EMPTY
33894: LIST
33895: LIST
33896: PUSH
33897: LD_INT 1
33899: NEG
33900: PUSH
33901: LD_INT 4
33903: NEG
33904: PUSH
33905: EMPTY
33906: LIST
33907: LIST
33908: PUSH
33909: LD_INT 2
33911: PUSH
33912: LD_INT 2
33914: NEG
33915: PUSH
33916: EMPTY
33917: LIST
33918: LIST
33919: PUSH
33920: LD_INT 2
33922: NEG
33923: PUSH
33924: LD_INT 4
33926: NEG
33927: PUSH
33928: EMPTY
33929: LIST
33930: LIST
33931: PUSH
33932: LD_INT 4
33934: PUSH
33935: LD_INT 0
33937: PUSH
33938: EMPTY
33939: LIST
33940: LIST
33941: PUSH
33942: LD_INT 4
33944: PUSH
33945: LD_INT 1
33947: NEG
33948: PUSH
33949: EMPTY
33950: LIST
33951: LIST
33952: PUSH
33953: LD_INT 5
33955: PUSH
33956: LD_INT 0
33958: PUSH
33959: EMPTY
33960: LIST
33961: LIST
33962: PUSH
33963: LD_INT 5
33965: PUSH
33966: LD_INT 1
33968: PUSH
33969: EMPTY
33970: LIST
33971: LIST
33972: PUSH
33973: LD_INT 4
33975: PUSH
33976: LD_INT 1
33978: PUSH
33979: EMPTY
33980: LIST
33981: LIST
33982: PUSH
33983: LD_INT 3
33985: PUSH
33986: LD_INT 0
33988: PUSH
33989: EMPTY
33990: LIST
33991: LIST
33992: PUSH
33993: LD_INT 3
33995: PUSH
33996: LD_INT 1
33998: NEG
33999: PUSH
34000: EMPTY
34001: LIST
34002: LIST
34003: PUSH
34004: LD_INT 3
34006: PUSH
34007: LD_INT 2
34009: NEG
34010: PUSH
34011: EMPTY
34012: LIST
34013: LIST
34014: PUSH
34015: LD_INT 5
34017: PUSH
34018: LD_INT 2
34020: PUSH
34021: EMPTY
34022: LIST
34023: LIST
34024: PUSH
34025: EMPTY
34026: LIST
34027: LIST
34028: LIST
34029: LIST
34030: LIST
34031: LIST
34032: LIST
34033: LIST
34034: LIST
34035: LIST
34036: LIST
34037: LIST
34038: LIST
34039: LIST
34040: LIST
34041: LIST
34042: LIST
34043: LIST
34044: LIST
34045: LIST
34046: LIST
34047: LIST
34048: LIST
34049: LIST
34050: LIST
34051: LIST
34052: LIST
34053: LIST
34054: LIST
34055: LIST
34056: LIST
34057: LIST
34058: LIST
34059: LIST
34060: LIST
34061: LIST
34062: LIST
34063: LIST
34064: LIST
34065: LIST
34066: LIST
34067: LIST
34068: LIST
34069: LIST
34070: LIST
34071: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
34072: LD_ADDR_VAR 0 32
34076: PUSH
34077: LD_INT 4
34079: NEG
34080: PUSH
34081: LD_INT 0
34083: PUSH
34084: EMPTY
34085: LIST
34086: LIST
34087: PUSH
34088: LD_INT 4
34090: NEG
34091: PUSH
34092: LD_INT 1
34094: NEG
34095: PUSH
34096: EMPTY
34097: LIST
34098: LIST
34099: PUSH
34100: LD_INT 3
34102: NEG
34103: PUSH
34104: LD_INT 0
34106: PUSH
34107: EMPTY
34108: LIST
34109: LIST
34110: PUSH
34111: LD_INT 3
34113: NEG
34114: PUSH
34115: LD_INT 1
34117: PUSH
34118: EMPTY
34119: LIST
34120: LIST
34121: PUSH
34122: LD_INT 4
34124: NEG
34125: PUSH
34126: LD_INT 1
34128: PUSH
34129: EMPTY
34130: LIST
34131: LIST
34132: PUSH
34133: LD_INT 5
34135: NEG
34136: PUSH
34137: LD_INT 0
34139: PUSH
34140: EMPTY
34141: LIST
34142: LIST
34143: PUSH
34144: LD_INT 5
34146: NEG
34147: PUSH
34148: LD_INT 1
34150: NEG
34151: PUSH
34152: EMPTY
34153: LIST
34154: LIST
34155: PUSH
34156: LD_INT 5
34158: NEG
34159: PUSH
34160: LD_INT 2
34162: NEG
34163: PUSH
34164: EMPTY
34165: LIST
34166: LIST
34167: PUSH
34168: LD_INT 3
34170: NEG
34171: PUSH
34172: LD_INT 2
34174: PUSH
34175: EMPTY
34176: LIST
34177: LIST
34178: PUSH
34179: LD_INT 3
34181: NEG
34182: PUSH
34183: LD_INT 3
34185: NEG
34186: PUSH
34187: EMPTY
34188: LIST
34189: LIST
34190: PUSH
34191: LD_INT 3
34193: NEG
34194: PUSH
34195: LD_INT 4
34197: NEG
34198: PUSH
34199: EMPTY
34200: LIST
34201: LIST
34202: PUSH
34203: LD_INT 2
34205: NEG
34206: PUSH
34207: LD_INT 3
34209: NEG
34210: PUSH
34211: EMPTY
34212: LIST
34213: LIST
34214: PUSH
34215: LD_INT 2
34217: NEG
34218: PUSH
34219: LD_INT 2
34221: NEG
34222: PUSH
34223: EMPTY
34224: LIST
34225: LIST
34226: PUSH
34227: LD_INT 3
34229: NEG
34230: PUSH
34231: LD_INT 2
34233: NEG
34234: PUSH
34235: EMPTY
34236: LIST
34237: LIST
34238: PUSH
34239: LD_INT 4
34241: NEG
34242: PUSH
34243: LD_INT 3
34245: NEG
34246: PUSH
34247: EMPTY
34248: LIST
34249: LIST
34250: PUSH
34251: LD_INT 4
34253: NEG
34254: PUSH
34255: LD_INT 4
34257: NEG
34258: PUSH
34259: EMPTY
34260: LIST
34261: LIST
34262: PUSH
34263: LD_INT 2
34265: NEG
34266: PUSH
34267: LD_INT 4
34269: NEG
34270: PUSH
34271: EMPTY
34272: LIST
34273: LIST
34274: PUSH
34275: LD_INT 4
34277: NEG
34278: PUSH
34279: LD_INT 2
34281: NEG
34282: PUSH
34283: EMPTY
34284: LIST
34285: LIST
34286: PUSH
34287: LD_INT 0
34289: PUSH
34290: LD_INT 4
34292: NEG
34293: PUSH
34294: EMPTY
34295: LIST
34296: LIST
34297: PUSH
34298: LD_INT 0
34300: PUSH
34301: LD_INT 5
34303: NEG
34304: PUSH
34305: EMPTY
34306: LIST
34307: LIST
34308: PUSH
34309: LD_INT 1
34311: PUSH
34312: LD_INT 4
34314: NEG
34315: PUSH
34316: EMPTY
34317: LIST
34318: LIST
34319: PUSH
34320: LD_INT 1
34322: PUSH
34323: LD_INT 3
34325: NEG
34326: PUSH
34327: EMPTY
34328: LIST
34329: LIST
34330: PUSH
34331: LD_INT 0
34333: PUSH
34334: LD_INT 3
34336: NEG
34337: PUSH
34338: EMPTY
34339: LIST
34340: LIST
34341: PUSH
34342: LD_INT 1
34344: NEG
34345: PUSH
34346: LD_INT 4
34348: NEG
34349: PUSH
34350: EMPTY
34351: LIST
34352: LIST
34353: PUSH
34354: LD_INT 1
34356: NEG
34357: PUSH
34358: LD_INT 5
34360: NEG
34361: PUSH
34362: EMPTY
34363: LIST
34364: LIST
34365: PUSH
34366: LD_INT 2
34368: PUSH
34369: LD_INT 3
34371: NEG
34372: PUSH
34373: EMPTY
34374: LIST
34375: LIST
34376: PUSH
34377: LD_INT 2
34379: NEG
34380: PUSH
34381: LD_INT 5
34383: NEG
34384: PUSH
34385: EMPTY
34386: LIST
34387: LIST
34388: PUSH
34389: LD_INT 3
34391: PUSH
34392: LD_INT 0
34394: PUSH
34395: EMPTY
34396: LIST
34397: LIST
34398: PUSH
34399: LD_INT 3
34401: PUSH
34402: LD_INT 1
34404: NEG
34405: PUSH
34406: EMPTY
34407: LIST
34408: LIST
34409: PUSH
34410: LD_INT 4
34412: PUSH
34413: LD_INT 0
34415: PUSH
34416: EMPTY
34417: LIST
34418: LIST
34419: PUSH
34420: LD_INT 4
34422: PUSH
34423: LD_INT 1
34425: PUSH
34426: EMPTY
34427: LIST
34428: LIST
34429: PUSH
34430: LD_INT 3
34432: PUSH
34433: LD_INT 1
34435: PUSH
34436: EMPTY
34437: LIST
34438: LIST
34439: PUSH
34440: LD_INT 2
34442: PUSH
34443: LD_INT 0
34445: PUSH
34446: EMPTY
34447: LIST
34448: LIST
34449: PUSH
34450: LD_INT 2
34452: PUSH
34453: LD_INT 1
34455: NEG
34456: PUSH
34457: EMPTY
34458: LIST
34459: LIST
34460: PUSH
34461: LD_INT 2
34463: PUSH
34464: LD_INT 2
34466: NEG
34467: PUSH
34468: EMPTY
34469: LIST
34470: LIST
34471: PUSH
34472: LD_INT 4
34474: PUSH
34475: LD_INT 2
34477: PUSH
34478: EMPTY
34479: LIST
34480: LIST
34481: PUSH
34482: LD_INT 4
34484: PUSH
34485: LD_INT 4
34487: PUSH
34488: EMPTY
34489: LIST
34490: LIST
34491: PUSH
34492: LD_INT 4
34494: PUSH
34495: LD_INT 3
34497: PUSH
34498: EMPTY
34499: LIST
34500: LIST
34501: PUSH
34502: LD_INT 5
34504: PUSH
34505: LD_INT 4
34507: PUSH
34508: EMPTY
34509: LIST
34510: LIST
34511: PUSH
34512: LD_INT 5
34514: PUSH
34515: LD_INT 5
34517: PUSH
34518: EMPTY
34519: LIST
34520: LIST
34521: PUSH
34522: LD_INT 4
34524: PUSH
34525: LD_INT 5
34527: PUSH
34528: EMPTY
34529: LIST
34530: LIST
34531: PUSH
34532: LD_INT 3
34534: PUSH
34535: LD_INT 4
34537: PUSH
34538: EMPTY
34539: LIST
34540: LIST
34541: PUSH
34542: LD_INT 3
34544: PUSH
34545: LD_INT 3
34547: PUSH
34548: EMPTY
34549: LIST
34550: LIST
34551: PUSH
34552: LD_INT 5
34554: PUSH
34555: LD_INT 3
34557: PUSH
34558: EMPTY
34559: LIST
34560: LIST
34561: PUSH
34562: LD_INT 3
34564: PUSH
34565: LD_INT 5
34567: PUSH
34568: EMPTY
34569: LIST
34570: LIST
34571: PUSH
34572: EMPTY
34573: LIST
34574: LIST
34575: LIST
34576: LIST
34577: LIST
34578: LIST
34579: LIST
34580: LIST
34581: LIST
34582: LIST
34583: LIST
34584: LIST
34585: LIST
34586: LIST
34587: LIST
34588: LIST
34589: LIST
34590: LIST
34591: LIST
34592: LIST
34593: LIST
34594: LIST
34595: LIST
34596: LIST
34597: LIST
34598: LIST
34599: LIST
34600: LIST
34601: LIST
34602: LIST
34603: LIST
34604: LIST
34605: LIST
34606: LIST
34607: LIST
34608: LIST
34609: LIST
34610: LIST
34611: LIST
34612: LIST
34613: LIST
34614: LIST
34615: LIST
34616: LIST
34617: LIST
34618: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
34619: LD_ADDR_VAR 0 33
34623: PUSH
34624: LD_INT 4
34626: NEG
34627: PUSH
34628: LD_INT 4
34630: NEG
34631: PUSH
34632: EMPTY
34633: LIST
34634: LIST
34635: PUSH
34636: LD_INT 4
34638: NEG
34639: PUSH
34640: LD_INT 5
34642: NEG
34643: PUSH
34644: EMPTY
34645: LIST
34646: LIST
34647: PUSH
34648: LD_INT 3
34650: NEG
34651: PUSH
34652: LD_INT 4
34654: NEG
34655: PUSH
34656: EMPTY
34657: LIST
34658: LIST
34659: PUSH
34660: LD_INT 3
34662: NEG
34663: PUSH
34664: LD_INT 3
34666: NEG
34667: PUSH
34668: EMPTY
34669: LIST
34670: LIST
34671: PUSH
34672: LD_INT 4
34674: NEG
34675: PUSH
34676: LD_INT 3
34678: NEG
34679: PUSH
34680: EMPTY
34681: LIST
34682: LIST
34683: PUSH
34684: LD_INT 5
34686: NEG
34687: PUSH
34688: LD_INT 4
34690: NEG
34691: PUSH
34692: EMPTY
34693: LIST
34694: LIST
34695: PUSH
34696: LD_INT 5
34698: NEG
34699: PUSH
34700: LD_INT 5
34702: NEG
34703: PUSH
34704: EMPTY
34705: LIST
34706: LIST
34707: PUSH
34708: LD_INT 3
34710: NEG
34711: PUSH
34712: LD_INT 5
34714: NEG
34715: PUSH
34716: EMPTY
34717: LIST
34718: LIST
34719: PUSH
34720: LD_INT 5
34722: NEG
34723: PUSH
34724: LD_INT 3
34726: NEG
34727: PUSH
34728: EMPTY
34729: LIST
34730: LIST
34731: PUSH
34732: LD_INT 0
34734: PUSH
34735: LD_INT 3
34737: NEG
34738: PUSH
34739: EMPTY
34740: LIST
34741: LIST
34742: PUSH
34743: LD_INT 0
34745: PUSH
34746: LD_INT 4
34748: NEG
34749: PUSH
34750: EMPTY
34751: LIST
34752: LIST
34753: PUSH
34754: LD_INT 1
34756: PUSH
34757: LD_INT 3
34759: NEG
34760: PUSH
34761: EMPTY
34762: LIST
34763: LIST
34764: PUSH
34765: LD_INT 1
34767: PUSH
34768: LD_INT 2
34770: NEG
34771: PUSH
34772: EMPTY
34773: LIST
34774: LIST
34775: PUSH
34776: LD_INT 0
34778: PUSH
34779: LD_INT 2
34781: NEG
34782: PUSH
34783: EMPTY
34784: LIST
34785: LIST
34786: PUSH
34787: LD_INT 1
34789: NEG
34790: PUSH
34791: LD_INT 3
34793: NEG
34794: PUSH
34795: EMPTY
34796: LIST
34797: LIST
34798: PUSH
34799: LD_INT 1
34801: NEG
34802: PUSH
34803: LD_INT 4
34805: NEG
34806: PUSH
34807: EMPTY
34808: LIST
34809: LIST
34810: PUSH
34811: LD_INT 2
34813: PUSH
34814: LD_INT 2
34816: NEG
34817: PUSH
34818: EMPTY
34819: LIST
34820: LIST
34821: PUSH
34822: LD_INT 2
34824: NEG
34825: PUSH
34826: LD_INT 4
34828: NEG
34829: PUSH
34830: EMPTY
34831: LIST
34832: LIST
34833: PUSH
34834: LD_INT 4
34836: PUSH
34837: LD_INT 0
34839: PUSH
34840: EMPTY
34841: LIST
34842: LIST
34843: PUSH
34844: LD_INT 4
34846: PUSH
34847: LD_INT 1
34849: NEG
34850: PUSH
34851: EMPTY
34852: LIST
34853: LIST
34854: PUSH
34855: LD_INT 5
34857: PUSH
34858: LD_INT 0
34860: PUSH
34861: EMPTY
34862: LIST
34863: LIST
34864: PUSH
34865: LD_INT 5
34867: PUSH
34868: LD_INT 1
34870: PUSH
34871: EMPTY
34872: LIST
34873: LIST
34874: PUSH
34875: LD_INT 4
34877: PUSH
34878: LD_INT 1
34880: PUSH
34881: EMPTY
34882: LIST
34883: LIST
34884: PUSH
34885: LD_INT 3
34887: PUSH
34888: LD_INT 0
34890: PUSH
34891: EMPTY
34892: LIST
34893: LIST
34894: PUSH
34895: LD_INT 3
34897: PUSH
34898: LD_INT 1
34900: NEG
34901: PUSH
34902: EMPTY
34903: LIST
34904: LIST
34905: PUSH
34906: LD_INT 3
34908: PUSH
34909: LD_INT 2
34911: NEG
34912: PUSH
34913: EMPTY
34914: LIST
34915: LIST
34916: PUSH
34917: LD_INT 5
34919: PUSH
34920: LD_INT 2
34922: PUSH
34923: EMPTY
34924: LIST
34925: LIST
34926: PUSH
34927: LD_INT 3
34929: PUSH
34930: LD_INT 3
34932: PUSH
34933: EMPTY
34934: LIST
34935: LIST
34936: PUSH
34937: LD_INT 3
34939: PUSH
34940: LD_INT 2
34942: PUSH
34943: EMPTY
34944: LIST
34945: LIST
34946: PUSH
34947: LD_INT 4
34949: PUSH
34950: LD_INT 3
34952: PUSH
34953: EMPTY
34954: LIST
34955: LIST
34956: PUSH
34957: LD_INT 4
34959: PUSH
34960: LD_INT 4
34962: PUSH
34963: EMPTY
34964: LIST
34965: LIST
34966: PUSH
34967: LD_INT 3
34969: PUSH
34970: LD_INT 4
34972: PUSH
34973: EMPTY
34974: LIST
34975: LIST
34976: PUSH
34977: LD_INT 2
34979: PUSH
34980: LD_INT 3
34982: PUSH
34983: EMPTY
34984: LIST
34985: LIST
34986: PUSH
34987: LD_INT 2
34989: PUSH
34990: LD_INT 2
34992: PUSH
34993: EMPTY
34994: LIST
34995: LIST
34996: PUSH
34997: LD_INT 4
34999: PUSH
35000: LD_INT 2
35002: PUSH
35003: EMPTY
35004: LIST
35005: LIST
35006: PUSH
35007: LD_INT 2
35009: PUSH
35010: LD_INT 4
35012: PUSH
35013: EMPTY
35014: LIST
35015: LIST
35016: PUSH
35017: LD_INT 0
35019: PUSH
35020: LD_INT 4
35022: PUSH
35023: EMPTY
35024: LIST
35025: LIST
35026: PUSH
35027: LD_INT 0
35029: PUSH
35030: LD_INT 3
35032: PUSH
35033: EMPTY
35034: LIST
35035: LIST
35036: PUSH
35037: LD_INT 1
35039: PUSH
35040: LD_INT 4
35042: PUSH
35043: EMPTY
35044: LIST
35045: LIST
35046: PUSH
35047: LD_INT 1
35049: PUSH
35050: LD_INT 5
35052: PUSH
35053: EMPTY
35054: LIST
35055: LIST
35056: PUSH
35057: LD_INT 0
35059: PUSH
35060: LD_INT 5
35062: PUSH
35063: EMPTY
35064: LIST
35065: LIST
35066: PUSH
35067: LD_INT 1
35069: NEG
35070: PUSH
35071: LD_INT 4
35073: PUSH
35074: EMPTY
35075: LIST
35076: LIST
35077: PUSH
35078: LD_INT 1
35080: NEG
35081: PUSH
35082: LD_INT 3
35084: PUSH
35085: EMPTY
35086: LIST
35087: LIST
35088: PUSH
35089: LD_INT 2
35091: PUSH
35092: LD_INT 5
35094: PUSH
35095: EMPTY
35096: LIST
35097: LIST
35098: PUSH
35099: LD_INT 2
35101: NEG
35102: PUSH
35103: LD_INT 3
35105: PUSH
35106: EMPTY
35107: LIST
35108: LIST
35109: PUSH
35110: EMPTY
35111: LIST
35112: LIST
35113: LIST
35114: LIST
35115: LIST
35116: LIST
35117: LIST
35118: LIST
35119: LIST
35120: LIST
35121: LIST
35122: LIST
35123: LIST
35124: LIST
35125: LIST
35126: LIST
35127: LIST
35128: LIST
35129: LIST
35130: LIST
35131: LIST
35132: LIST
35133: LIST
35134: LIST
35135: LIST
35136: LIST
35137: LIST
35138: LIST
35139: LIST
35140: LIST
35141: LIST
35142: LIST
35143: LIST
35144: LIST
35145: LIST
35146: LIST
35147: LIST
35148: LIST
35149: LIST
35150: LIST
35151: LIST
35152: LIST
35153: LIST
35154: LIST
35155: LIST
35156: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
35157: LD_ADDR_VAR 0 34
35161: PUSH
35162: LD_INT 0
35164: PUSH
35165: LD_INT 4
35167: NEG
35168: PUSH
35169: EMPTY
35170: LIST
35171: LIST
35172: PUSH
35173: LD_INT 0
35175: PUSH
35176: LD_INT 5
35178: NEG
35179: PUSH
35180: EMPTY
35181: LIST
35182: LIST
35183: PUSH
35184: LD_INT 1
35186: PUSH
35187: LD_INT 4
35189: NEG
35190: PUSH
35191: EMPTY
35192: LIST
35193: LIST
35194: PUSH
35195: LD_INT 1
35197: PUSH
35198: LD_INT 3
35200: NEG
35201: PUSH
35202: EMPTY
35203: LIST
35204: LIST
35205: PUSH
35206: LD_INT 0
35208: PUSH
35209: LD_INT 3
35211: NEG
35212: PUSH
35213: EMPTY
35214: LIST
35215: LIST
35216: PUSH
35217: LD_INT 1
35219: NEG
35220: PUSH
35221: LD_INT 4
35223: NEG
35224: PUSH
35225: EMPTY
35226: LIST
35227: LIST
35228: PUSH
35229: LD_INT 1
35231: NEG
35232: PUSH
35233: LD_INT 5
35235: NEG
35236: PUSH
35237: EMPTY
35238: LIST
35239: LIST
35240: PUSH
35241: LD_INT 2
35243: PUSH
35244: LD_INT 3
35246: NEG
35247: PUSH
35248: EMPTY
35249: LIST
35250: LIST
35251: PUSH
35252: LD_INT 2
35254: NEG
35255: PUSH
35256: LD_INT 5
35258: NEG
35259: PUSH
35260: EMPTY
35261: LIST
35262: LIST
35263: PUSH
35264: LD_INT 3
35266: PUSH
35267: LD_INT 0
35269: PUSH
35270: EMPTY
35271: LIST
35272: LIST
35273: PUSH
35274: LD_INT 3
35276: PUSH
35277: LD_INT 1
35279: NEG
35280: PUSH
35281: EMPTY
35282: LIST
35283: LIST
35284: PUSH
35285: LD_INT 4
35287: PUSH
35288: LD_INT 0
35290: PUSH
35291: EMPTY
35292: LIST
35293: LIST
35294: PUSH
35295: LD_INT 4
35297: PUSH
35298: LD_INT 1
35300: PUSH
35301: EMPTY
35302: LIST
35303: LIST
35304: PUSH
35305: LD_INT 3
35307: PUSH
35308: LD_INT 1
35310: PUSH
35311: EMPTY
35312: LIST
35313: LIST
35314: PUSH
35315: LD_INT 2
35317: PUSH
35318: LD_INT 0
35320: PUSH
35321: EMPTY
35322: LIST
35323: LIST
35324: PUSH
35325: LD_INT 2
35327: PUSH
35328: LD_INT 1
35330: NEG
35331: PUSH
35332: EMPTY
35333: LIST
35334: LIST
35335: PUSH
35336: LD_INT 2
35338: PUSH
35339: LD_INT 2
35341: NEG
35342: PUSH
35343: EMPTY
35344: LIST
35345: LIST
35346: PUSH
35347: LD_INT 4
35349: PUSH
35350: LD_INT 2
35352: PUSH
35353: EMPTY
35354: LIST
35355: LIST
35356: PUSH
35357: LD_INT 4
35359: PUSH
35360: LD_INT 4
35362: PUSH
35363: EMPTY
35364: LIST
35365: LIST
35366: PUSH
35367: LD_INT 4
35369: PUSH
35370: LD_INT 3
35372: PUSH
35373: EMPTY
35374: LIST
35375: LIST
35376: PUSH
35377: LD_INT 5
35379: PUSH
35380: LD_INT 4
35382: PUSH
35383: EMPTY
35384: LIST
35385: LIST
35386: PUSH
35387: LD_INT 5
35389: PUSH
35390: LD_INT 5
35392: PUSH
35393: EMPTY
35394: LIST
35395: LIST
35396: PUSH
35397: LD_INT 4
35399: PUSH
35400: LD_INT 5
35402: PUSH
35403: EMPTY
35404: LIST
35405: LIST
35406: PUSH
35407: LD_INT 3
35409: PUSH
35410: LD_INT 4
35412: PUSH
35413: EMPTY
35414: LIST
35415: LIST
35416: PUSH
35417: LD_INT 3
35419: PUSH
35420: LD_INT 3
35422: PUSH
35423: EMPTY
35424: LIST
35425: LIST
35426: PUSH
35427: LD_INT 5
35429: PUSH
35430: LD_INT 3
35432: PUSH
35433: EMPTY
35434: LIST
35435: LIST
35436: PUSH
35437: LD_INT 3
35439: PUSH
35440: LD_INT 5
35442: PUSH
35443: EMPTY
35444: LIST
35445: LIST
35446: PUSH
35447: LD_INT 0
35449: PUSH
35450: LD_INT 3
35452: PUSH
35453: EMPTY
35454: LIST
35455: LIST
35456: PUSH
35457: LD_INT 0
35459: PUSH
35460: LD_INT 2
35462: PUSH
35463: EMPTY
35464: LIST
35465: LIST
35466: PUSH
35467: LD_INT 1
35469: PUSH
35470: LD_INT 3
35472: PUSH
35473: EMPTY
35474: LIST
35475: LIST
35476: PUSH
35477: LD_INT 1
35479: PUSH
35480: LD_INT 4
35482: PUSH
35483: EMPTY
35484: LIST
35485: LIST
35486: PUSH
35487: LD_INT 0
35489: PUSH
35490: LD_INT 4
35492: PUSH
35493: EMPTY
35494: LIST
35495: LIST
35496: PUSH
35497: LD_INT 1
35499: NEG
35500: PUSH
35501: LD_INT 3
35503: PUSH
35504: EMPTY
35505: LIST
35506: LIST
35507: PUSH
35508: LD_INT 1
35510: NEG
35511: PUSH
35512: LD_INT 2
35514: PUSH
35515: EMPTY
35516: LIST
35517: LIST
35518: PUSH
35519: LD_INT 2
35521: PUSH
35522: LD_INT 4
35524: PUSH
35525: EMPTY
35526: LIST
35527: LIST
35528: PUSH
35529: LD_INT 2
35531: NEG
35532: PUSH
35533: LD_INT 2
35535: PUSH
35536: EMPTY
35537: LIST
35538: LIST
35539: PUSH
35540: LD_INT 4
35542: NEG
35543: PUSH
35544: LD_INT 0
35546: PUSH
35547: EMPTY
35548: LIST
35549: LIST
35550: PUSH
35551: LD_INT 4
35553: NEG
35554: PUSH
35555: LD_INT 1
35557: NEG
35558: PUSH
35559: EMPTY
35560: LIST
35561: LIST
35562: PUSH
35563: LD_INT 3
35565: NEG
35566: PUSH
35567: LD_INT 0
35569: PUSH
35570: EMPTY
35571: LIST
35572: LIST
35573: PUSH
35574: LD_INT 3
35576: NEG
35577: PUSH
35578: LD_INT 1
35580: PUSH
35581: EMPTY
35582: LIST
35583: LIST
35584: PUSH
35585: LD_INT 4
35587: NEG
35588: PUSH
35589: LD_INT 1
35591: PUSH
35592: EMPTY
35593: LIST
35594: LIST
35595: PUSH
35596: LD_INT 5
35598: NEG
35599: PUSH
35600: LD_INT 0
35602: PUSH
35603: EMPTY
35604: LIST
35605: LIST
35606: PUSH
35607: LD_INT 5
35609: NEG
35610: PUSH
35611: LD_INT 1
35613: NEG
35614: PUSH
35615: EMPTY
35616: LIST
35617: LIST
35618: PUSH
35619: LD_INT 5
35621: NEG
35622: PUSH
35623: LD_INT 2
35625: NEG
35626: PUSH
35627: EMPTY
35628: LIST
35629: LIST
35630: PUSH
35631: LD_INT 3
35633: NEG
35634: PUSH
35635: LD_INT 2
35637: PUSH
35638: EMPTY
35639: LIST
35640: LIST
35641: PUSH
35642: EMPTY
35643: LIST
35644: LIST
35645: LIST
35646: LIST
35647: LIST
35648: LIST
35649: LIST
35650: LIST
35651: LIST
35652: LIST
35653: LIST
35654: LIST
35655: LIST
35656: LIST
35657: LIST
35658: LIST
35659: LIST
35660: LIST
35661: LIST
35662: LIST
35663: LIST
35664: LIST
35665: LIST
35666: LIST
35667: LIST
35668: LIST
35669: LIST
35670: LIST
35671: LIST
35672: LIST
35673: LIST
35674: LIST
35675: LIST
35676: LIST
35677: LIST
35678: LIST
35679: LIST
35680: LIST
35681: LIST
35682: LIST
35683: LIST
35684: LIST
35685: LIST
35686: LIST
35687: LIST
35688: ST_TO_ADDR
// end ; end ;
35689: GO 35692
35691: POP
// case btype of b_depot , b_warehouse :
35692: LD_VAR 0 1
35696: PUSH
35697: LD_INT 0
35699: DOUBLE
35700: EQUAL
35701: IFTRUE 35711
35703: LD_INT 1
35705: DOUBLE
35706: EQUAL
35707: IFTRUE 35711
35709: GO 35912
35711: POP
// case nation of nation_american :
35712: LD_VAR 0 5
35716: PUSH
35717: LD_INT 1
35719: DOUBLE
35720: EQUAL
35721: IFTRUE 35725
35723: GO 35781
35725: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
35726: LD_ADDR_VAR 0 9
35730: PUSH
35731: LD_VAR 0 11
35735: PUSH
35736: LD_VAR 0 12
35740: PUSH
35741: LD_VAR 0 13
35745: PUSH
35746: LD_VAR 0 14
35750: PUSH
35751: LD_VAR 0 15
35755: PUSH
35756: LD_VAR 0 16
35760: PUSH
35761: EMPTY
35762: LIST
35763: LIST
35764: LIST
35765: LIST
35766: LIST
35767: LIST
35768: PUSH
35769: LD_VAR 0 4
35773: PUSH
35774: LD_INT 1
35776: PLUS
35777: ARRAY
35778: ST_TO_ADDR
35779: GO 35910
35781: LD_INT 2
35783: DOUBLE
35784: EQUAL
35785: IFTRUE 35789
35787: GO 35845
35789: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
35790: LD_ADDR_VAR 0 9
35794: PUSH
35795: LD_VAR 0 17
35799: PUSH
35800: LD_VAR 0 18
35804: PUSH
35805: LD_VAR 0 19
35809: PUSH
35810: LD_VAR 0 20
35814: PUSH
35815: LD_VAR 0 21
35819: PUSH
35820: LD_VAR 0 22
35824: PUSH
35825: EMPTY
35826: LIST
35827: LIST
35828: LIST
35829: LIST
35830: LIST
35831: LIST
35832: PUSH
35833: LD_VAR 0 4
35837: PUSH
35838: LD_INT 1
35840: PLUS
35841: ARRAY
35842: ST_TO_ADDR
35843: GO 35910
35845: LD_INT 3
35847: DOUBLE
35848: EQUAL
35849: IFTRUE 35853
35851: GO 35909
35853: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
35854: LD_ADDR_VAR 0 9
35858: PUSH
35859: LD_VAR 0 23
35863: PUSH
35864: LD_VAR 0 24
35868: PUSH
35869: LD_VAR 0 25
35873: PUSH
35874: LD_VAR 0 26
35878: PUSH
35879: LD_VAR 0 27
35883: PUSH
35884: LD_VAR 0 28
35888: PUSH
35889: EMPTY
35890: LIST
35891: LIST
35892: LIST
35893: LIST
35894: LIST
35895: LIST
35896: PUSH
35897: LD_VAR 0 4
35901: PUSH
35902: LD_INT 1
35904: PLUS
35905: ARRAY
35906: ST_TO_ADDR
35907: GO 35910
35909: POP
35910: GO 36465
35912: LD_INT 2
35914: DOUBLE
35915: EQUAL
35916: IFTRUE 35926
35918: LD_INT 3
35920: DOUBLE
35921: EQUAL
35922: IFTRUE 35926
35924: GO 35982
35926: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
35927: LD_ADDR_VAR 0 9
35931: PUSH
35932: LD_VAR 0 29
35936: PUSH
35937: LD_VAR 0 30
35941: PUSH
35942: LD_VAR 0 31
35946: PUSH
35947: LD_VAR 0 32
35951: PUSH
35952: LD_VAR 0 33
35956: PUSH
35957: LD_VAR 0 34
35961: PUSH
35962: EMPTY
35963: LIST
35964: LIST
35965: LIST
35966: LIST
35967: LIST
35968: LIST
35969: PUSH
35970: LD_VAR 0 4
35974: PUSH
35975: LD_INT 1
35977: PLUS
35978: ARRAY
35979: ST_TO_ADDR
35980: GO 36465
35982: LD_INT 16
35984: DOUBLE
35985: EQUAL
35986: IFTRUE 36044
35988: LD_INT 17
35990: DOUBLE
35991: EQUAL
35992: IFTRUE 36044
35994: LD_INT 18
35996: DOUBLE
35997: EQUAL
35998: IFTRUE 36044
36000: LD_INT 19
36002: DOUBLE
36003: EQUAL
36004: IFTRUE 36044
36006: LD_INT 22
36008: DOUBLE
36009: EQUAL
36010: IFTRUE 36044
36012: LD_INT 20
36014: DOUBLE
36015: EQUAL
36016: IFTRUE 36044
36018: LD_INT 21
36020: DOUBLE
36021: EQUAL
36022: IFTRUE 36044
36024: LD_INT 23
36026: DOUBLE
36027: EQUAL
36028: IFTRUE 36044
36030: LD_INT 24
36032: DOUBLE
36033: EQUAL
36034: IFTRUE 36044
36036: LD_INT 25
36038: DOUBLE
36039: EQUAL
36040: IFTRUE 36044
36042: GO 36100
36044: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
36045: LD_ADDR_VAR 0 9
36049: PUSH
36050: LD_VAR 0 35
36054: PUSH
36055: LD_VAR 0 36
36059: PUSH
36060: LD_VAR 0 37
36064: PUSH
36065: LD_VAR 0 38
36069: PUSH
36070: LD_VAR 0 39
36074: PUSH
36075: LD_VAR 0 40
36079: PUSH
36080: EMPTY
36081: LIST
36082: LIST
36083: LIST
36084: LIST
36085: LIST
36086: LIST
36087: PUSH
36088: LD_VAR 0 4
36092: PUSH
36093: LD_INT 1
36095: PLUS
36096: ARRAY
36097: ST_TO_ADDR
36098: GO 36465
36100: LD_INT 6
36102: DOUBLE
36103: EQUAL
36104: IFTRUE 36156
36106: LD_INT 7
36108: DOUBLE
36109: EQUAL
36110: IFTRUE 36156
36112: LD_INT 8
36114: DOUBLE
36115: EQUAL
36116: IFTRUE 36156
36118: LD_INT 13
36120: DOUBLE
36121: EQUAL
36122: IFTRUE 36156
36124: LD_INT 12
36126: DOUBLE
36127: EQUAL
36128: IFTRUE 36156
36130: LD_INT 15
36132: DOUBLE
36133: EQUAL
36134: IFTRUE 36156
36136: LD_INT 11
36138: DOUBLE
36139: EQUAL
36140: IFTRUE 36156
36142: LD_INT 14
36144: DOUBLE
36145: EQUAL
36146: IFTRUE 36156
36148: LD_INT 10
36150: DOUBLE
36151: EQUAL
36152: IFTRUE 36156
36154: GO 36212
36156: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
36157: LD_ADDR_VAR 0 9
36161: PUSH
36162: LD_VAR 0 41
36166: PUSH
36167: LD_VAR 0 42
36171: PUSH
36172: LD_VAR 0 43
36176: PUSH
36177: LD_VAR 0 44
36181: PUSH
36182: LD_VAR 0 45
36186: PUSH
36187: LD_VAR 0 46
36191: PUSH
36192: EMPTY
36193: LIST
36194: LIST
36195: LIST
36196: LIST
36197: LIST
36198: LIST
36199: PUSH
36200: LD_VAR 0 4
36204: PUSH
36205: LD_INT 1
36207: PLUS
36208: ARRAY
36209: ST_TO_ADDR
36210: GO 36465
36212: LD_INT 36
36214: DOUBLE
36215: EQUAL
36216: IFTRUE 36220
36218: GO 36276
36220: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
36221: LD_ADDR_VAR 0 9
36225: PUSH
36226: LD_VAR 0 47
36230: PUSH
36231: LD_VAR 0 48
36235: PUSH
36236: LD_VAR 0 49
36240: PUSH
36241: LD_VAR 0 50
36245: PUSH
36246: LD_VAR 0 51
36250: PUSH
36251: LD_VAR 0 52
36255: PUSH
36256: EMPTY
36257: LIST
36258: LIST
36259: LIST
36260: LIST
36261: LIST
36262: LIST
36263: PUSH
36264: LD_VAR 0 4
36268: PUSH
36269: LD_INT 1
36271: PLUS
36272: ARRAY
36273: ST_TO_ADDR
36274: GO 36465
36276: LD_INT 4
36278: DOUBLE
36279: EQUAL
36280: IFTRUE 36302
36282: LD_INT 5
36284: DOUBLE
36285: EQUAL
36286: IFTRUE 36302
36288: LD_INT 34
36290: DOUBLE
36291: EQUAL
36292: IFTRUE 36302
36294: LD_INT 37
36296: DOUBLE
36297: EQUAL
36298: IFTRUE 36302
36300: GO 36358
36302: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
36303: LD_ADDR_VAR 0 9
36307: PUSH
36308: LD_VAR 0 53
36312: PUSH
36313: LD_VAR 0 54
36317: PUSH
36318: LD_VAR 0 55
36322: PUSH
36323: LD_VAR 0 56
36327: PUSH
36328: LD_VAR 0 57
36332: PUSH
36333: LD_VAR 0 58
36337: PUSH
36338: EMPTY
36339: LIST
36340: LIST
36341: LIST
36342: LIST
36343: LIST
36344: LIST
36345: PUSH
36346: LD_VAR 0 4
36350: PUSH
36351: LD_INT 1
36353: PLUS
36354: ARRAY
36355: ST_TO_ADDR
36356: GO 36465
36358: LD_INT 31
36360: DOUBLE
36361: EQUAL
36362: IFTRUE 36408
36364: LD_INT 32
36366: DOUBLE
36367: EQUAL
36368: IFTRUE 36408
36370: LD_INT 33
36372: DOUBLE
36373: EQUAL
36374: IFTRUE 36408
36376: LD_INT 27
36378: DOUBLE
36379: EQUAL
36380: IFTRUE 36408
36382: LD_INT 26
36384: DOUBLE
36385: EQUAL
36386: IFTRUE 36408
36388: LD_INT 28
36390: DOUBLE
36391: EQUAL
36392: IFTRUE 36408
36394: LD_INT 29
36396: DOUBLE
36397: EQUAL
36398: IFTRUE 36408
36400: LD_INT 30
36402: DOUBLE
36403: EQUAL
36404: IFTRUE 36408
36406: GO 36464
36408: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
36409: LD_ADDR_VAR 0 9
36413: PUSH
36414: LD_VAR 0 59
36418: PUSH
36419: LD_VAR 0 60
36423: PUSH
36424: LD_VAR 0 61
36428: PUSH
36429: LD_VAR 0 62
36433: PUSH
36434: LD_VAR 0 63
36438: PUSH
36439: LD_VAR 0 64
36443: PUSH
36444: EMPTY
36445: LIST
36446: LIST
36447: LIST
36448: LIST
36449: LIST
36450: LIST
36451: PUSH
36452: LD_VAR 0 4
36456: PUSH
36457: LD_INT 1
36459: PLUS
36460: ARRAY
36461: ST_TO_ADDR
36462: GO 36465
36464: POP
// temp_list2 = [ ] ;
36465: LD_ADDR_VAR 0 10
36469: PUSH
36470: EMPTY
36471: ST_TO_ADDR
// for i in temp_list do
36472: LD_ADDR_VAR 0 8
36476: PUSH
36477: LD_VAR 0 9
36481: PUSH
36482: FOR_IN
36483: IFFALSE 36535
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
36485: LD_ADDR_VAR 0 10
36489: PUSH
36490: LD_VAR 0 10
36494: PUSH
36495: LD_VAR 0 8
36499: PUSH
36500: LD_INT 1
36502: ARRAY
36503: PUSH
36504: LD_VAR 0 2
36508: PLUS
36509: PUSH
36510: LD_VAR 0 8
36514: PUSH
36515: LD_INT 2
36517: ARRAY
36518: PUSH
36519: LD_VAR 0 3
36523: PLUS
36524: PUSH
36525: EMPTY
36526: LIST
36527: LIST
36528: PUSH
36529: EMPTY
36530: LIST
36531: ADD
36532: ST_TO_ADDR
36533: GO 36482
36535: POP
36536: POP
// result = temp_list2 ;
36537: LD_ADDR_VAR 0 7
36541: PUSH
36542: LD_VAR 0 10
36546: ST_TO_ADDR
// end ;
36547: LD_VAR 0 7
36551: RET
// export function EnemyInRange ( unit , dist ) ; begin
36552: LD_INT 0
36554: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
36555: LD_ADDR_VAR 0 3
36559: PUSH
36560: LD_VAR 0 1
36564: PPUSH
36565: CALL_OW 255
36569: PPUSH
36570: LD_VAR 0 1
36574: PPUSH
36575: CALL_OW 250
36579: PPUSH
36580: LD_VAR 0 1
36584: PPUSH
36585: CALL_OW 251
36589: PPUSH
36590: LD_VAR 0 2
36594: PPUSH
36595: CALL 10323 0 4
36599: PUSH
36600: LD_INT 4
36602: ARRAY
36603: ST_TO_ADDR
// end ;
36604: LD_VAR 0 3
36608: RET
// export function PlayerSeeMe ( unit ) ; begin
36609: LD_INT 0
36611: PPUSH
// result := See ( your_side , unit ) ;
36612: LD_ADDR_VAR 0 2
36616: PUSH
36617: LD_OWVAR 2
36621: PPUSH
36622: LD_VAR 0 1
36626: PPUSH
36627: CALL_OW 292
36631: ST_TO_ADDR
// end ;
36632: LD_VAR 0 2
36636: RET
// export function ReverseDir ( unit ) ; begin
36637: LD_INT 0
36639: PPUSH
// if not unit then
36640: LD_VAR 0 1
36644: NOT
36645: IFFALSE 36649
// exit ;
36647: GO 36672
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
36649: LD_ADDR_VAR 0 2
36653: PUSH
36654: LD_VAR 0 1
36658: PPUSH
36659: CALL_OW 254
36663: PUSH
36664: LD_INT 3
36666: PLUS
36667: PUSH
36668: LD_INT 6
36670: MOD
36671: ST_TO_ADDR
// end ;
36672: LD_VAR 0 2
36676: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
36677: LD_INT 0
36679: PPUSH
36680: PPUSH
36681: PPUSH
36682: PPUSH
36683: PPUSH
// if not hexes then
36684: LD_VAR 0 2
36688: NOT
36689: IFFALSE 36693
// exit ;
36691: GO 36841
// dist := 9999 ;
36693: LD_ADDR_VAR 0 5
36697: PUSH
36698: LD_INT 9999
36700: ST_TO_ADDR
// for i = 1 to hexes do
36701: LD_ADDR_VAR 0 4
36705: PUSH
36706: DOUBLE
36707: LD_INT 1
36709: DEC
36710: ST_TO_ADDR
36711: LD_VAR 0 2
36715: PUSH
36716: FOR_TO
36717: IFFALSE 36829
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
36719: LD_VAR 0 1
36723: PPUSH
36724: LD_VAR 0 2
36728: PUSH
36729: LD_VAR 0 4
36733: ARRAY
36734: PUSH
36735: LD_INT 1
36737: ARRAY
36738: PPUSH
36739: LD_VAR 0 2
36743: PUSH
36744: LD_VAR 0 4
36748: ARRAY
36749: PUSH
36750: LD_INT 2
36752: ARRAY
36753: PPUSH
36754: CALL_OW 297
36758: PUSH
36759: LD_VAR 0 5
36763: LESS
36764: IFFALSE 36827
// begin hex := hexes [ i ] ;
36766: LD_ADDR_VAR 0 7
36770: PUSH
36771: LD_VAR 0 2
36775: PUSH
36776: LD_VAR 0 4
36780: ARRAY
36781: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
36782: LD_ADDR_VAR 0 5
36786: PUSH
36787: LD_VAR 0 1
36791: PPUSH
36792: LD_VAR 0 2
36796: PUSH
36797: LD_VAR 0 4
36801: ARRAY
36802: PUSH
36803: LD_INT 1
36805: ARRAY
36806: PPUSH
36807: LD_VAR 0 2
36811: PUSH
36812: LD_VAR 0 4
36816: ARRAY
36817: PUSH
36818: LD_INT 2
36820: ARRAY
36821: PPUSH
36822: CALL_OW 297
36826: ST_TO_ADDR
// end ; end ;
36827: GO 36716
36829: POP
36830: POP
// result := hex ;
36831: LD_ADDR_VAR 0 3
36835: PUSH
36836: LD_VAR 0 7
36840: ST_TO_ADDR
// end ;
36841: LD_VAR 0 3
36845: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
36846: LD_INT 0
36848: PPUSH
36849: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
36850: LD_VAR 0 1
36854: NOT
36855: PUSH
36856: LD_VAR 0 1
36860: PUSH
36861: LD_INT 21
36863: PUSH
36864: LD_INT 2
36866: PUSH
36867: EMPTY
36868: LIST
36869: LIST
36870: PUSH
36871: LD_INT 23
36873: PUSH
36874: LD_INT 2
36876: PUSH
36877: EMPTY
36878: LIST
36879: LIST
36880: PUSH
36881: EMPTY
36882: LIST
36883: LIST
36884: PPUSH
36885: CALL_OW 69
36889: IN
36890: NOT
36891: OR
36892: IFFALSE 36896
// exit ;
36894: GO 36943
// for i = 1 to 3 do
36896: LD_ADDR_VAR 0 3
36900: PUSH
36901: DOUBLE
36902: LD_INT 1
36904: DEC
36905: ST_TO_ADDR
36906: LD_INT 3
36908: PUSH
36909: FOR_TO
36910: IFFALSE 36941
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
36912: LD_VAR 0 1
36916: PPUSH
36917: CALL_OW 250
36921: PPUSH
36922: LD_VAR 0 1
36926: PPUSH
36927: CALL_OW 251
36931: PPUSH
36932: LD_INT 1
36934: PPUSH
36935: CALL_OW 453
36939: GO 36909
36941: POP
36942: POP
// end ;
36943: LD_VAR 0 2
36947: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
36948: LD_INT 0
36950: PPUSH
36951: PPUSH
36952: PPUSH
36953: PPUSH
36954: PPUSH
36955: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
36956: LD_VAR 0 1
36960: NOT
36961: PUSH
36962: LD_VAR 0 2
36966: NOT
36967: OR
36968: PUSH
36969: LD_VAR 0 1
36973: PPUSH
36974: CALL_OW 314
36978: OR
36979: IFFALSE 36983
// exit ;
36981: GO 37424
// x := GetX ( enemy_unit ) ;
36983: LD_ADDR_VAR 0 7
36987: PUSH
36988: LD_VAR 0 2
36992: PPUSH
36993: CALL_OW 250
36997: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
36998: LD_ADDR_VAR 0 8
37002: PUSH
37003: LD_VAR 0 2
37007: PPUSH
37008: CALL_OW 251
37012: ST_TO_ADDR
// if not x or not y then
37013: LD_VAR 0 7
37017: NOT
37018: PUSH
37019: LD_VAR 0 8
37023: NOT
37024: OR
37025: IFFALSE 37029
// exit ;
37027: GO 37424
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
37029: LD_ADDR_VAR 0 6
37033: PUSH
37034: LD_VAR 0 7
37038: PPUSH
37039: LD_INT 0
37041: PPUSH
37042: LD_INT 4
37044: PPUSH
37045: CALL_OW 272
37049: PUSH
37050: LD_VAR 0 8
37054: PPUSH
37055: LD_INT 0
37057: PPUSH
37058: LD_INT 4
37060: PPUSH
37061: CALL_OW 273
37065: PUSH
37066: EMPTY
37067: LIST
37068: LIST
37069: PUSH
37070: LD_VAR 0 7
37074: PPUSH
37075: LD_INT 1
37077: PPUSH
37078: LD_INT 4
37080: PPUSH
37081: CALL_OW 272
37085: PUSH
37086: LD_VAR 0 8
37090: PPUSH
37091: LD_INT 1
37093: PPUSH
37094: LD_INT 4
37096: PPUSH
37097: CALL_OW 273
37101: PUSH
37102: EMPTY
37103: LIST
37104: LIST
37105: PUSH
37106: LD_VAR 0 7
37110: PPUSH
37111: LD_INT 2
37113: PPUSH
37114: LD_INT 4
37116: PPUSH
37117: CALL_OW 272
37121: PUSH
37122: LD_VAR 0 8
37126: PPUSH
37127: LD_INT 2
37129: PPUSH
37130: LD_INT 4
37132: PPUSH
37133: CALL_OW 273
37137: PUSH
37138: EMPTY
37139: LIST
37140: LIST
37141: PUSH
37142: LD_VAR 0 7
37146: PPUSH
37147: LD_INT 3
37149: PPUSH
37150: LD_INT 4
37152: PPUSH
37153: CALL_OW 272
37157: PUSH
37158: LD_VAR 0 8
37162: PPUSH
37163: LD_INT 3
37165: PPUSH
37166: LD_INT 4
37168: PPUSH
37169: CALL_OW 273
37173: PUSH
37174: EMPTY
37175: LIST
37176: LIST
37177: PUSH
37178: LD_VAR 0 7
37182: PPUSH
37183: LD_INT 4
37185: PPUSH
37186: LD_INT 4
37188: PPUSH
37189: CALL_OW 272
37193: PUSH
37194: LD_VAR 0 8
37198: PPUSH
37199: LD_INT 4
37201: PPUSH
37202: LD_INT 4
37204: PPUSH
37205: CALL_OW 273
37209: PUSH
37210: EMPTY
37211: LIST
37212: LIST
37213: PUSH
37214: LD_VAR 0 7
37218: PPUSH
37219: LD_INT 5
37221: PPUSH
37222: LD_INT 4
37224: PPUSH
37225: CALL_OW 272
37229: PUSH
37230: LD_VAR 0 8
37234: PPUSH
37235: LD_INT 5
37237: PPUSH
37238: LD_INT 4
37240: PPUSH
37241: CALL_OW 273
37245: PUSH
37246: EMPTY
37247: LIST
37248: LIST
37249: PUSH
37250: EMPTY
37251: LIST
37252: LIST
37253: LIST
37254: LIST
37255: LIST
37256: LIST
37257: ST_TO_ADDR
// for i = tmp downto 1 do
37258: LD_ADDR_VAR 0 4
37262: PUSH
37263: DOUBLE
37264: LD_VAR 0 6
37268: INC
37269: ST_TO_ADDR
37270: LD_INT 1
37272: PUSH
37273: FOR_DOWNTO
37274: IFFALSE 37375
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
37276: LD_VAR 0 6
37280: PUSH
37281: LD_VAR 0 4
37285: ARRAY
37286: PUSH
37287: LD_INT 1
37289: ARRAY
37290: PPUSH
37291: LD_VAR 0 6
37295: PUSH
37296: LD_VAR 0 4
37300: ARRAY
37301: PUSH
37302: LD_INT 2
37304: ARRAY
37305: PPUSH
37306: CALL_OW 488
37310: NOT
37311: PUSH
37312: LD_VAR 0 6
37316: PUSH
37317: LD_VAR 0 4
37321: ARRAY
37322: PUSH
37323: LD_INT 1
37325: ARRAY
37326: PPUSH
37327: LD_VAR 0 6
37331: PUSH
37332: LD_VAR 0 4
37336: ARRAY
37337: PUSH
37338: LD_INT 2
37340: ARRAY
37341: PPUSH
37342: CALL_OW 428
37346: PUSH
37347: LD_INT 0
37349: NONEQUAL
37350: OR
37351: IFFALSE 37373
// tmp := Delete ( tmp , i ) ;
37353: LD_ADDR_VAR 0 6
37357: PUSH
37358: LD_VAR 0 6
37362: PPUSH
37363: LD_VAR 0 4
37367: PPUSH
37368: CALL_OW 3
37372: ST_TO_ADDR
37373: GO 37273
37375: POP
37376: POP
// j := GetClosestHex ( unit , tmp ) ;
37377: LD_ADDR_VAR 0 5
37381: PUSH
37382: LD_VAR 0 1
37386: PPUSH
37387: LD_VAR 0 6
37391: PPUSH
37392: CALL 36677 0 2
37396: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
37397: LD_VAR 0 1
37401: PPUSH
37402: LD_VAR 0 5
37406: PUSH
37407: LD_INT 1
37409: ARRAY
37410: PPUSH
37411: LD_VAR 0 5
37415: PUSH
37416: LD_INT 2
37418: ARRAY
37419: PPUSH
37420: CALL_OW 111
// end ;
37424: LD_VAR 0 3
37428: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
37429: LD_INT 0
37431: PPUSH
37432: PPUSH
37433: PPUSH
// uc_side = 0 ;
37434: LD_ADDR_OWVAR 20
37438: PUSH
37439: LD_INT 0
37441: ST_TO_ADDR
// uc_nation = 0 ;
37442: LD_ADDR_OWVAR 21
37446: PUSH
37447: LD_INT 0
37449: ST_TO_ADDR
// InitHc_All ( ) ;
37450: CALL_OW 584
// InitVc ;
37454: CALL_OW 20
// if mastodonts then
37458: LD_VAR 0 6
37462: IFFALSE 37529
// for i = 1 to mastodonts do
37464: LD_ADDR_VAR 0 11
37468: PUSH
37469: DOUBLE
37470: LD_INT 1
37472: DEC
37473: ST_TO_ADDR
37474: LD_VAR 0 6
37478: PUSH
37479: FOR_TO
37480: IFFALSE 37527
// begin vc_chassis := 31 ;
37482: LD_ADDR_OWVAR 37
37486: PUSH
37487: LD_INT 31
37489: ST_TO_ADDR
// vc_control := control_rider ;
37490: LD_ADDR_OWVAR 38
37494: PUSH
37495: LD_INT 4
37497: ST_TO_ADDR
// animal := CreateVehicle ;
37498: LD_ADDR_VAR 0 12
37502: PUSH
37503: CALL_OW 45
37507: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
37508: LD_VAR 0 12
37512: PPUSH
37513: LD_VAR 0 8
37517: PPUSH
37518: LD_INT 0
37520: PPUSH
37521: CALL 39717 0 3
// end ;
37525: GO 37479
37527: POP
37528: POP
// if horses then
37529: LD_VAR 0 5
37533: IFFALSE 37600
// for i = 1 to horses do
37535: LD_ADDR_VAR 0 11
37539: PUSH
37540: DOUBLE
37541: LD_INT 1
37543: DEC
37544: ST_TO_ADDR
37545: LD_VAR 0 5
37549: PUSH
37550: FOR_TO
37551: IFFALSE 37598
// begin hc_class := 21 ;
37553: LD_ADDR_OWVAR 28
37557: PUSH
37558: LD_INT 21
37560: ST_TO_ADDR
// hc_gallery :=  ;
37561: LD_ADDR_OWVAR 33
37565: PUSH
37566: LD_STRING 
37568: ST_TO_ADDR
// animal := CreateHuman ;
37569: LD_ADDR_VAR 0 12
37573: PUSH
37574: CALL_OW 44
37578: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
37579: LD_VAR 0 12
37583: PPUSH
37584: LD_VAR 0 8
37588: PPUSH
37589: LD_INT 0
37591: PPUSH
37592: CALL 39717 0 3
// end ;
37596: GO 37550
37598: POP
37599: POP
// if birds then
37600: LD_VAR 0 1
37604: IFFALSE 37671
// for i = 1 to birds do
37606: LD_ADDR_VAR 0 11
37610: PUSH
37611: DOUBLE
37612: LD_INT 1
37614: DEC
37615: ST_TO_ADDR
37616: LD_VAR 0 1
37620: PUSH
37621: FOR_TO
37622: IFFALSE 37669
// begin hc_class = 18 ;
37624: LD_ADDR_OWVAR 28
37628: PUSH
37629: LD_INT 18
37631: ST_TO_ADDR
// hc_gallery =  ;
37632: LD_ADDR_OWVAR 33
37636: PUSH
37637: LD_STRING 
37639: ST_TO_ADDR
// animal := CreateHuman ;
37640: LD_ADDR_VAR 0 12
37644: PUSH
37645: CALL_OW 44
37649: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
37650: LD_VAR 0 12
37654: PPUSH
37655: LD_VAR 0 8
37659: PPUSH
37660: LD_INT 0
37662: PPUSH
37663: CALL 39717 0 3
// end ;
37667: GO 37621
37669: POP
37670: POP
// if tigers then
37671: LD_VAR 0 2
37675: IFFALSE 37759
// for i = 1 to tigers do
37677: LD_ADDR_VAR 0 11
37681: PUSH
37682: DOUBLE
37683: LD_INT 1
37685: DEC
37686: ST_TO_ADDR
37687: LD_VAR 0 2
37691: PUSH
37692: FOR_TO
37693: IFFALSE 37757
// begin hc_class = class_tiger ;
37695: LD_ADDR_OWVAR 28
37699: PUSH
37700: LD_INT 14
37702: ST_TO_ADDR
// hc_gallery =  ;
37703: LD_ADDR_OWVAR 33
37707: PUSH
37708: LD_STRING 
37710: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
37711: LD_ADDR_OWVAR 35
37715: PUSH
37716: LD_INT 7
37718: NEG
37719: PPUSH
37720: LD_INT 7
37722: PPUSH
37723: CALL_OW 12
37727: ST_TO_ADDR
// animal := CreateHuman ;
37728: LD_ADDR_VAR 0 12
37732: PUSH
37733: CALL_OW 44
37737: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
37738: LD_VAR 0 12
37742: PPUSH
37743: LD_VAR 0 8
37747: PPUSH
37748: LD_INT 0
37750: PPUSH
37751: CALL 39717 0 3
// end ;
37755: GO 37692
37757: POP
37758: POP
// if apemans then
37759: LD_VAR 0 3
37763: IFFALSE 37886
// for i = 1 to apemans do
37765: LD_ADDR_VAR 0 11
37769: PUSH
37770: DOUBLE
37771: LD_INT 1
37773: DEC
37774: ST_TO_ADDR
37775: LD_VAR 0 3
37779: PUSH
37780: FOR_TO
37781: IFFALSE 37884
// begin hc_class = class_apeman ;
37783: LD_ADDR_OWVAR 28
37787: PUSH
37788: LD_INT 12
37790: ST_TO_ADDR
// hc_gallery =  ;
37791: LD_ADDR_OWVAR 33
37795: PUSH
37796: LD_STRING 
37798: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
37799: LD_ADDR_OWVAR 35
37803: PUSH
37804: LD_INT 5
37806: NEG
37807: PPUSH
37808: LD_INT 5
37810: PPUSH
37811: CALL_OW 12
37815: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
37816: LD_ADDR_OWVAR 31
37820: PUSH
37821: LD_INT 1
37823: PPUSH
37824: LD_INT 3
37826: PPUSH
37827: CALL_OW 12
37831: PUSH
37832: LD_INT 1
37834: PPUSH
37835: LD_INT 3
37837: PPUSH
37838: CALL_OW 12
37842: PUSH
37843: LD_INT 0
37845: PUSH
37846: LD_INT 0
37848: PUSH
37849: EMPTY
37850: LIST
37851: LIST
37852: LIST
37853: LIST
37854: ST_TO_ADDR
// animal := CreateHuman ;
37855: LD_ADDR_VAR 0 12
37859: PUSH
37860: CALL_OW 44
37864: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
37865: LD_VAR 0 12
37869: PPUSH
37870: LD_VAR 0 8
37874: PPUSH
37875: LD_INT 0
37877: PPUSH
37878: CALL 39717 0 3
// end ;
37882: GO 37780
37884: POP
37885: POP
// if enchidnas then
37886: LD_VAR 0 4
37890: IFFALSE 37957
// for i = 1 to enchidnas do
37892: LD_ADDR_VAR 0 11
37896: PUSH
37897: DOUBLE
37898: LD_INT 1
37900: DEC
37901: ST_TO_ADDR
37902: LD_VAR 0 4
37906: PUSH
37907: FOR_TO
37908: IFFALSE 37955
// begin hc_class = 13 ;
37910: LD_ADDR_OWVAR 28
37914: PUSH
37915: LD_INT 13
37917: ST_TO_ADDR
// hc_gallery =  ;
37918: LD_ADDR_OWVAR 33
37922: PUSH
37923: LD_STRING 
37925: ST_TO_ADDR
// animal := CreateHuman ;
37926: LD_ADDR_VAR 0 12
37930: PUSH
37931: CALL_OW 44
37935: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
37936: LD_VAR 0 12
37940: PPUSH
37941: LD_VAR 0 8
37945: PPUSH
37946: LD_INT 0
37948: PPUSH
37949: CALL 39717 0 3
// end ;
37953: GO 37907
37955: POP
37956: POP
// if fishes then
37957: LD_VAR 0 7
37961: IFFALSE 38028
// for i = 1 to fishes do
37963: LD_ADDR_VAR 0 11
37967: PUSH
37968: DOUBLE
37969: LD_INT 1
37971: DEC
37972: ST_TO_ADDR
37973: LD_VAR 0 7
37977: PUSH
37978: FOR_TO
37979: IFFALSE 38026
// begin hc_class = 20 ;
37981: LD_ADDR_OWVAR 28
37985: PUSH
37986: LD_INT 20
37988: ST_TO_ADDR
// hc_gallery =  ;
37989: LD_ADDR_OWVAR 33
37993: PUSH
37994: LD_STRING 
37996: ST_TO_ADDR
// animal := CreateHuman ;
37997: LD_ADDR_VAR 0 12
38001: PUSH
38002: CALL_OW 44
38006: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
38007: LD_VAR 0 12
38011: PPUSH
38012: LD_VAR 0 9
38016: PPUSH
38017: LD_INT 0
38019: PPUSH
38020: CALL 39717 0 3
// end ;
38024: GO 37978
38026: POP
38027: POP
// end ;
38028: LD_VAR 0 10
38032: RET
// export function WantHeal ( sci , unit ) ; begin
38033: LD_INT 0
38035: PPUSH
// if GetTaskList ( sci ) > 0 then
38036: LD_VAR 0 1
38040: PPUSH
38041: CALL_OW 437
38045: PUSH
38046: LD_INT 0
38048: GREATER
38049: IFFALSE 38119
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
38051: LD_VAR 0 1
38055: PPUSH
38056: CALL_OW 437
38060: PUSH
38061: LD_INT 1
38063: ARRAY
38064: PUSH
38065: LD_INT 1
38067: ARRAY
38068: PUSH
38069: LD_STRING l
38071: EQUAL
38072: PUSH
38073: LD_VAR 0 1
38077: PPUSH
38078: CALL_OW 437
38082: PUSH
38083: LD_INT 1
38085: ARRAY
38086: PUSH
38087: LD_INT 4
38089: ARRAY
38090: PUSH
38091: LD_VAR 0 2
38095: EQUAL
38096: AND
38097: IFFALSE 38109
// result := true else
38099: LD_ADDR_VAR 0 3
38103: PUSH
38104: LD_INT 1
38106: ST_TO_ADDR
38107: GO 38117
// result := false ;
38109: LD_ADDR_VAR 0 3
38113: PUSH
38114: LD_INT 0
38116: ST_TO_ADDR
// end else
38117: GO 38127
// result := false ;
38119: LD_ADDR_VAR 0 3
38123: PUSH
38124: LD_INT 0
38126: ST_TO_ADDR
// end ;
38127: LD_VAR 0 3
38131: RET
// export function HealTarget ( sci ) ; begin
38132: LD_INT 0
38134: PPUSH
// if not sci then
38135: LD_VAR 0 1
38139: NOT
38140: IFFALSE 38144
// exit ;
38142: GO 38209
// result := 0 ;
38144: LD_ADDR_VAR 0 2
38148: PUSH
38149: LD_INT 0
38151: ST_TO_ADDR
// if GetTaskList ( sci ) then
38152: LD_VAR 0 1
38156: PPUSH
38157: CALL_OW 437
38161: IFFALSE 38209
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
38163: LD_VAR 0 1
38167: PPUSH
38168: CALL_OW 437
38172: PUSH
38173: LD_INT 1
38175: ARRAY
38176: PUSH
38177: LD_INT 1
38179: ARRAY
38180: PUSH
38181: LD_STRING l
38183: EQUAL
38184: IFFALSE 38209
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
38186: LD_ADDR_VAR 0 2
38190: PUSH
38191: LD_VAR 0 1
38195: PPUSH
38196: CALL_OW 437
38200: PUSH
38201: LD_INT 1
38203: ARRAY
38204: PUSH
38205: LD_INT 4
38207: ARRAY
38208: ST_TO_ADDR
// end ;
38209: LD_VAR 0 2
38213: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
38214: LD_INT 0
38216: PPUSH
38217: PPUSH
38218: PPUSH
38219: PPUSH
// if not base_units then
38220: LD_VAR 0 1
38224: NOT
38225: IFFALSE 38229
// exit ;
38227: GO 38316
// result := false ;
38229: LD_ADDR_VAR 0 2
38233: PUSH
38234: LD_INT 0
38236: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
38237: LD_ADDR_VAR 0 5
38241: PUSH
38242: LD_VAR 0 1
38246: PPUSH
38247: LD_INT 21
38249: PUSH
38250: LD_INT 3
38252: PUSH
38253: EMPTY
38254: LIST
38255: LIST
38256: PPUSH
38257: CALL_OW 72
38261: ST_TO_ADDR
// if not tmp then
38262: LD_VAR 0 5
38266: NOT
38267: IFFALSE 38271
// exit ;
38269: GO 38316
// for i in tmp do
38271: LD_ADDR_VAR 0 3
38275: PUSH
38276: LD_VAR 0 5
38280: PUSH
38281: FOR_IN
38282: IFFALSE 38314
// begin result := EnemyInRange ( i , 22 ) ;
38284: LD_ADDR_VAR 0 2
38288: PUSH
38289: LD_VAR 0 3
38293: PPUSH
38294: LD_INT 22
38296: PPUSH
38297: CALL 36552 0 2
38301: ST_TO_ADDR
// if result then
38302: LD_VAR 0 2
38306: IFFALSE 38312
// exit ;
38308: POP
38309: POP
38310: GO 38316
// end ;
38312: GO 38281
38314: POP
38315: POP
// end ;
38316: LD_VAR 0 2
38320: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
38321: LD_INT 0
38323: PPUSH
38324: PPUSH
// if not units then
38325: LD_VAR 0 1
38329: NOT
38330: IFFALSE 38334
// exit ;
38332: GO 38404
// result := [ ] ;
38334: LD_ADDR_VAR 0 3
38338: PUSH
38339: EMPTY
38340: ST_TO_ADDR
// for i in units do
38341: LD_ADDR_VAR 0 4
38345: PUSH
38346: LD_VAR 0 1
38350: PUSH
38351: FOR_IN
38352: IFFALSE 38402
// if GetTag ( i ) = tag then
38354: LD_VAR 0 4
38358: PPUSH
38359: CALL_OW 110
38363: PUSH
38364: LD_VAR 0 2
38368: EQUAL
38369: IFFALSE 38400
// result := Insert ( result , result + 1 , i ) ;
38371: LD_ADDR_VAR 0 3
38375: PUSH
38376: LD_VAR 0 3
38380: PPUSH
38381: LD_VAR 0 3
38385: PUSH
38386: LD_INT 1
38388: PLUS
38389: PPUSH
38390: LD_VAR 0 4
38394: PPUSH
38395: CALL_OW 2
38399: ST_TO_ADDR
38400: GO 38351
38402: POP
38403: POP
// end ;
38404: LD_VAR 0 3
38408: RET
// export function IsDriver ( un ) ; begin
38409: LD_INT 0
38411: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
38412: LD_ADDR_VAR 0 2
38416: PUSH
38417: LD_VAR 0 1
38421: PUSH
38422: LD_INT 55
38424: PUSH
38425: EMPTY
38426: LIST
38427: PPUSH
38428: CALL_OW 69
38432: IN
38433: ST_TO_ADDR
// end ;
38434: LD_VAR 0 2
38438: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
38439: LD_INT 0
38441: PPUSH
38442: PPUSH
// list := [ ] ;
38443: LD_ADDR_VAR 0 5
38447: PUSH
38448: EMPTY
38449: ST_TO_ADDR
// case d of 0 :
38450: LD_VAR 0 3
38454: PUSH
38455: LD_INT 0
38457: DOUBLE
38458: EQUAL
38459: IFTRUE 38463
38461: GO 38596
38463: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
38464: LD_ADDR_VAR 0 5
38468: PUSH
38469: LD_VAR 0 1
38473: PUSH
38474: LD_INT 4
38476: MINUS
38477: PUSH
38478: LD_VAR 0 2
38482: PUSH
38483: LD_INT 4
38485: MINUS
38486: PUSH
38487: LD_INT 2
38489: PUSH
38490: EMPTY
38491: LIST
38492: LIST
38493: LIST
38494: PUSH
38495: LD_VAR 0 1
38499: PUSH
38500: LD_INT 3
38502: MINUS
38503: PUSH
38504: LD_VAR 0 2
38508: PUSH
38509: LD_INT 1
38511: PUSH
38512: EMPTY
38513: LIST
38514: LIST
38515: LIST
38516: PUSH
38517: LD_VAR 0 1
38521: PUSH
38522: LD_INT 4
38524: PLUS
38525: PUSH
38526: LD_VAR 0 2
38530: PUSH
38531: LD_INT 4
38533: PUSH
38534: EMPTY
38535: LIST
38536: LIST
38537: LIST
38538: PUSH
38539: LD_VAR 0 1
38543: PUSH
38544: LD_INT 3
38546: PLUS
38547: PUSH
38548: LD_VAR 0 2
38552: PUSH
38553: LD_INT 3
38555: PLUS
38556: PUSH
38557: LD_INT 5
38559: PUSH
38560: EMPTY
38561: LIST
38562: LIST
38563: LIST
38564: PUSH
38565: LD_VAR 0 1
38569: PUSH
38570: LD_VAR 0 2
38574: PUSH
38575: LD_INT 4
38577: PLUS
38578: PUSH
38579: LD_INT 0
38581: PUSH
38582: EMPTY
38583: LIST
38584: LIST
38585: LIST
38586: PUSH
38587: EMPTY
38588: LIST
38589: LIST
38590: LIST
38591: LIST
38592: LIST
38593: ST_TO_ADDR
// end ; 1 :
38594: GO 39294
38596: LD_INT 1
38598: DOUBLE
38599: EQUAL
38600: IFTRUE 38604
38602: GO 38737
38604: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
38605: LD_ADDR_VAR 0 5
38609: PUSH
38610: LD_VAR 0 1
38614: PUSH
38615: LD_VAR 0 2
38619: PUSH
38620: LD_INT 4
38622: MINUS
38623: PUSH
38624: LD_INT 3
38626: PUSH
38627: EMPTY
38628: LIST
38629: LIST
38630: LIST
38631: PUSH
38632: LD_VAR 0 1
38636: PUSH
38637: LD_INT 3
38639: MINUS
38640: PUSH
38641: LD_VAR 0 2
38645: PUSH
38646: LD_INT 3
38648: MINUS
38649: PUSH
38650: LD_INT 2
38652: PUSH
38653: EMPTY
38654: LIST
38655: LIST
38656: LIST
38657: PUSH
38658: LD_VAR 0 1
38662: PUSH
38663: LD_INT 4
38665: MINUS
38666: PUSH
38667: LD_VAR 0 2
38671: PUSH
38672: LD_INT 1
38674: PUSH
38675: EMPTY
38676: LIST
38677: LIST
38678: LIST
38679: PUSH
38680: LD_VAR 0 1
38684: PUSH
38685: LD_VAR 0 2
38689: PUSH
38690: LD_INT 3
38692: PLUS
38693: PUSH
38694: LD_INT 0
38696: PUSH
38697: EMPTY
38698: LIST
38699: LIST
38700: LIST
38701: PUSH
38702: LD_VAR 0 1
38706: PUSH
38707: LD_INT 4
38709: PLUS
38710: PUSH
38711: LD_VAR 0 2
38715: PUSH
38716: LD_INT 4
38718: PLUS
38719: PUSH
38720: LD_INT 5
38722: PUSH
38723: EMPTY
38724: LIST
38725: LIST
38726: LIST
38727: PUSH
38728: EMPTY
38729: LIST
38730: LIST
38731: LIST
38732: LIST
38733: LIST
38734: ST_TO_ADDR
// end ; 2 :
38735: GO 39294
38737: LD_INT 2
38739: DOUBLE
38740: EQUAL
38741: IFTRUE 38745
38743: GO 38874
38745: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
38746: LD_ADDR_VAR 0 5
38750: PUSH
38751: LD_VAR 0 1
38755: PUSH
38756: LD_VAR 0 2
38760: PUSH
38761: LD_INT 3
38763: MINUS
38764: PUSH
38765: LD_INT 3
38767: PUSH
38768: EMPTY
38769: LIST
38770: LIST
38771: LIST
38772: PUSH
38773: LD_VAR 0 1
38777: PUSH
38778: LD_INT 4
38780: PLUS
38781: PUSH
38782: LD_VAR 0 2
38786: PUSH
38787: LD_INT 4
38789: PUSH
38790: EMPTY
38791: LIST
38792: LIST
38793: LIST
38794: PUSH
38795: LD_VAR 0 1
38799: PUSH
38800: LD_VAR 0 2
38804: PUSH
38805: LD_INT 4
38807: PLUS
38808: PUSH
38809: LD_INT 0
38811: PUSH
38812: EMPTY
38813: LIST
38814: LIST
38815: LIST
38816: PUSH
38817: LD_VAR 0 1
38821: PUSH
38822: LD_INT 3
38824: MINUS
38825: PUSH
38826: LD_VAR 0 2
38830: PUSH
38831: LD_INT 1
38833: PUSH
38834: EMPTY
38835: LIST
38836: LIST
38837: LIST
38838: PUSH
38839: LD_VAR 0 1
38843: PUSH
38844: LD_INT 4
38846: MINUS
38847: PUSH
38848: LD_VAR 0 2
38852: PUSH
38853: LD_INT 4
38855: MINUS
38856: PUSH
38857: LD_INT 2
38859: PUSH
38860: EMPTY
38861: LIST
38862: LIST
38863: LIST
38864: PUSH
38865: EMPTY
38866: LIST
38867: LIST
38868: LIST
38869: LIST
38870: LIST
38871: ST_TO_ADDR
// end ; 3 :
38872: GO 39294
38874: LD_INT 3
38876: DOUBLE
38877: EQUAL
38878: IFTRUE 38882
38880: GO 39015
38882: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
38883: LD_ADDR_VAR 0 5
38887: PUSH
38888: LD_VAR 0 1
38892: PUSH
38893: LD_INT 3
38895: PLUS
38896: PUSH
38897: LD_VAR 0 2
38901: PUSH
38902: LD_INT 4
38904: PUSH
38905: EMPTY
38906: LIST
38907: LIST
38908: LIST
38909: PUSH
38910: LD_VAR 0 1
38914: PUSH
38915: LD_INT 4
38917: PLUS
38918: PUSH
38919: LD_VAR 0 2
38923: PUSH
38924: LD_INT 4
38926: PLUS
38927: PUSH
38928: LD_INT 5
38930: PUSH
38931: EMPTY
38932: LIST
38933: LIST
38934: LIST
38935: PUSH
38936: LD_VAR 0 1
38940: PUSH
38941: LD_INT 4
38943: MINUS
38944: PUSH
38945: LD_VAR 0 2
38949: PUSH
38950: LD_INT 1
38952: PUSH
38953: EMPTY
38954: LIST
38955: LIST
38956: LIST
38957: PUSH
38958: LD_VAR 0 1
38962: PUSH
38963: LD_VAR 0 2
38967: PUSH
38968: LD_INT 4
38970: MINUS
38971: PUSH
38972: LD_INT 3
38974: PUSH
38975: EMPTY
38976: LIST
38977: LIST
38978: LIST
38979: PUSH
38980: LD_VAR 0 1
38984: PUSH
38985: LD_INT 3
38987: MINUS
38988: PUSH
38989: LD_VAR 0 2
38993: PUSH
38994: LD_INT 3
38996: MINUS
38997: PUSH
38998: LD_INT 2
39000: PUSH
39001: EMPTY
39002: LIST
39003: LIST
39004: LIST
39005: PUSH
39006: EMPTY
39007: LIST
39008: LIST
39009: LIST
39010: LIST
39011: LIST
39012: ST_TO_ADDR
// end ; 4 :
39013: GO 39294
39015: LD_INT 4
39017: DOUBLE
39018: EQUAL
39019: IFTRUE 39023
39021: GO 39156
39023: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
39024: LD_ADDR_VAR 0 5
39028: PUSH
39029: LD_VAR 0 1
39033: PUSH
39034: LD_VAR 0 2
39038: PUSH
39039: LD_INT 4
39041: PLUS
39042: PUSH
39043: LD_INT 0
39045: PUSH
39046: EMPTY
39047: LIST
39048: LIST
39049: LIST
39050: PUSH
39051: LD_VAR 0 1
39055: PUSH
39056: LD_INT 3
39058: PLUS
39059: PUSH
39060: LD_VAR 0 2
39064: PUSH
39065: LD_INT 3
39067: PLUS
39068: PUSH
39069: LD_INT 5
39071: PUSH
39072: EMPTY
39073: LIST
39074: LIST
39075: LIST
39076: PUSH
39077: LD_VAR 0 1
39081: PUSH
39082: LD_INT 4
39084: PLUS
39085: PUSH
39086: LD_VAR 0 2
39090: PUSH
39091: LD_INT 4
39093: PUSH
39094: EMPTY
39095: LIST
39096: LIST
39097: LIST
39098: PUSH
39099: LD_VAR 0 1
39103: PUSH
39104: LD_VAR 0 2
39108: PUSH
39109: LD_INT 3
39111: MINUS
39112: PUSH
39113: LD_INT 3
39115: PUSH
39116: EMPTY
39117: LIST
39118: LIST
39119: LIST
39120: PUSH
39121: LD_VAR 0 1
39125: PUSH
39126: LD_INT 4
39128: MINUS
39129: PUSH
39130: LD_VAR 0 2
39134: PUSH
39135: LD_INT 4
39137: MINUS
39138: PUSH
39139: LD_INT 2
39141: PUSH
39142: EMPTY
39143: LIST
39144: LIST
39145: LIST
39146: PUSH
39147: EMPTY
39148: LIST
39149: LIST
39150: LIST
39151: LIST
39152: LIST
39153: ST_TO_ADDR
// end ; 5 :
39154: GO 39294
39156: LD_INT 5
39158: DOUBLE
39159: EQUAL
39160: IFTRUE 39164
39162: GO 39293
39164: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
39165: LD_ADDR_VAR 0 5
39169: PUSH
39170: LD_VAR 0 1
39174: PUSH
39175: LD_INT 4
39177: MINUS
39178: PUSH
39179: LD_VAR 0 2
39183: PUSH
39184: LD_INT 1
39186: PUSH
39187: EMPTY
39188: LIST
39189: LIST
39190: LIST
39191: PUSH
39192: LD_VAR 0 1
39196: PUSH
39197: LD_VAR 0 2
39201: PUSH
39202: LD_INT 4
39204: MINUS
39205: PUSH
39206: LD_INT 3
39208: PUSH
39209: EMPTY
39210: LIST
39211: LIST
39212: LIST
39213: PUSH
39214: LD_VAR 0 1
39218: PUSH
39219: LD_INT 4
39221: PLUS
39222: PUSH
39223: LD_VAR 0 2
39227: PUSH
39228: LD_INT 4
39230: PLUS
39231: PUSH
39232: LD_INT 5
39234: PUSH
39235: EMPTY
39236: LIST
39237: LIST
39238: LIST
39239: PUSH
39240: LD_VAR 0 1
39244: PUSH
39245: LD_INT 3
39247: PLUS
39248: PUSH
39249: LD_VAR 0 2
39253: PUSH
39254: LD_INT 4
39256: PUSH
39257: EMPTY
39258: LIST
39259: LIST
39260: LIST
39261: PUSH
39262: LD_VAR 0 1
39266: PUSH
39267: LD_VAR 0 2
39271: PUSH
39272: LD_INT 3
39274: PLUS
39275: PUSH
39276: LD_INT 0
39278: PUSH
39279: EMPTY
39280: LIST
39281: LIST
39282: LIST
39283: PUSH
39284: EMPTY
39285: LIST
39286: LIST
39287: LIST
39288: LIST
39289: LIST
39290: ST_TO_ADDR
// end ; end ;
39291: GO 39294
39293: POP
// result := list ;
39294: LD_ADDR_VAR 0 4
39298: PUSH
39299: LD_VAR 0 5
39303: ST_TO_ADDR
// end ;
39304: LD_VAR 0 4
39308: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
39309: LD_INT 0
39311: PPUSH
39312: PPUSH
39313: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
39314: LD_VAR 0 1
39318: NOT
39319: PUSH
39320: LD_VAR 0 2
39324: PUSH
39325: LD_INT 1
39327: PUSH
39328: LD_INT 2
39330: PUSH
39331: LD_INT 3
39333: PUSH
39334: LD_INT 4
39336: PUSH
39337: EMPTY
39338: LIST
39339: LIST
39340: LIST
39341: LIST
39342: IN
39343: NOT
39344: OR
39345: IFFALSE 39349
// exit ;
39347: GO 39441
// tmp := [ ] ;
39349: LD_ADDR_VAR 0 5
39353: PUSH
39354: EMPTY
39355: ST_TO_ADDR
// for i in units do
39356: LD_ADDR_VAR 0 4
39360: PUSH
39361: LD_VAR 0 1
39365: PUSH
39366: FOR_IN
39367: IFFALSE 39410
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
39369: LD_ADDR_VAR 0 5
39373: PUSH
39374: LD_VAR 0 5
39378: PPUSH
39379: LD_VAR 0 5
39383: PUSH
39384: LD_INT 1
39386: PLUS
39387: PPUSH
39388: LD_VAR 0 4
39392: PPUSH
39393: LD_VAR 0 2
39397: PPUSH
39398: CALL_OW 259
39402: PPUSH
39403: CALL_OW 2
39407: ST_TO_ADDR
39408: GO 39366
39410: POP
39411: POP
// if not tmp then
39412: LD_VAR 0 5
39416: NOT
39417: IFFALSE 39421
// exit ;
39419: GO 39441
// result := SortListByListDesc ( units , tmp ) ;
39421: LD_ADDR_VAR 0 3
39425: PUSH
39426: LD_VAR 0 1
39430: PPUSH
39431: LD_VAR 0 5
39435: PPUSH
39436: CALL_OW 77
39440: ST_TO_ADDR
// end ;
39441: LD_VAR 0 3
39445: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
39446: LD_INT 0
39448: PPUSH
39449: PPUSH
39450: PPUSH
// result := false ;
39451: LD_ADDR_VAR 0 3
39455: PUSH
39456: LD_INT 0
39458: ST_TO_ADDR
// x := GetX ( building ) ;
39459: LD_ADDR_VAR 0 4
39463: PUSH
39464: LD_VAR 0 2
39468: PPUSH
39469: CALL_OW 250
39473: ST_TO_ADDR
// y := GetY ( building ) ;
39474: LD_ADDR_VAR 0 5
39478: PUSH
39479: LD_VAR 0 2
39483: PPUSH
39484: CALL_OW 251
39488: ST_TO_ADDR
// if not building or not x or not y then
39489: LD_VAR 0 2
39493: NOT
39494: PUSH
39495: LD_VAR 0 4
39499: NOT
39500: OR
39501: PUSH
39502: LD_VAR 0 5
39506: NOT
39507: OR
39508: IFFALSE 39512
// exit ;
39510: GO 39604
// if GetTaskList ( unit ) then
39512: LD_VAR 0 1
39516: PPUSH
39517: CALL_OW 437
39521: IFFALSE 39604
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
39523: LD_STRING e
39525: PUSH
39526: LD_VAR 0 1
39530: PPUSH
39531: CALL_OW 437
39535: PUSH
39536: LD_INT 1
39538: ARRAY
39539: PUSH
39540: LD_INT 1
39542: ARRAY
39543: EQUAL
39544: PUSH
39545: LD_VAR 0 4
39549: PUSH
39550: LD_VAR 0 1
39554: PPUSH
39555: CALL_OW 437
39559: PUSH
39560: LD_INT 1
39562: ARRAY
39563: PUSH
39564: LD_INT 2
39566: ARRAY
39567: EQUAL
39568: AND
39569: PUSH
39570: LD_VAR 0 5
39574: PUSH
39575: LD_VAR 0 1
39579: PPUSH
39580: CALL_OW 437
39584: PUSH
39585: LD_INT 1
39587: ARRAY
39588: PUSH
39589: LD_INT 3
39591: ARRAY
39592: EQUAL
39593: AND
39594: IFFALSE 39604
// result := true end ;
39596: LD_ADDR_VAR 0 3
39600: PUSH
39601: LD_INT 1
39603: ST_TO_ADDR
// end ;
39604: LD_VAR 0 3
39608: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
39609: LD_INT 0
39611: PPUSH
// result := false ;
39612: LD_ADDR_VAR 0 4
39616: PUSH
39617: LD_INT 0
39619: ST_TO_ADDR
// if GetTaskList ( unit ) then
39620: LD_VAR 0 1
39624: PPUSH
39625: CALL_OW 437
39629: IFFALSE 39712
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
39631: LD_STRING M
39633: PUSH
39634: LD_VAR 0 1
39638: PPUSH
39639: CALL_OW 437
39643: PUSH
39644: LD_INT 1
39646: ARRAY
39647: PUSH
39648: LD_INT 1
39650: ARRAY
39651: EQUAL
39652: PUSH
39653: LD_VAR 0 2
39657: PUSH
39658: LD_VAR 0 1
39662: PPUSH
39663: CALL_OW 437
39667: PUSH
39668: LD_INT 1
39670: ARRAY
39671: PUSH
39672: LD_INT 2
39674: ARRAY
39675: EQUAL
39676: AND
39677: PUSH
39678: LD_VAR 0 3
39682: PUSH
39683: LD_VAR 0 1
39687: PPUSH
39688: CALL_OW 437
39692: PUSH
39693: LD_INT 1
39695: ARRAY
39696: PUSH
39697: LD_INT 3
39699: ARRAY
39700: EQUAL
39701: AND
39702: IFFALSE 39712
// result := true ;
39704: LD_ADDR_VAR 0 4
39708: PUSH
39709: LD_INT 1
39711: ST_TO_ADDR
// end ; end ;
39712: LD_VAR 0 4
39716: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
39717: LD_INT 0
39719: PPUSH
39720: PPUSH
39721: PPUSH
39722: PPUSH
// if not unit or not area then
39723: LD_VAR 0 1
39727: NOT
39728: PUSH
39729: LD_VAR 0 2
39733: NOT
39734: OR
39735: IFFALSE 39739
// exit ;
39737: GO 39903
// tmp := AreaToList ( area , i ) ;
39739: LD_ADDR_VAR 0 6
39743: PUSH
39744: LD_VAR 0 2
39748: PPUSH
39749: LD_VAR 0 5
39753: PPUSH
39754: CALL_OW 517
39758: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
39759: LD_ADDR_VAR 0 5
39763: PUSH
39764: DOUBLE
39765: LD_INT 1
39767: DEC
39768: ST_TO_ADDR
39769: LD_VAR 0 6
39773: PUSH
39774: LD_INT 1
39776: ARRAY
39777: PUSH
39778: FOR_TO
39779: IFFALSE 39901
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
39781: LD_ADDR_VAR 0 7
39785: PUSH
39786: LD_VAR 0 6
39790: PUSH
39791: LD_INT 1
39793: ARRAY
39794: PUSH
39795: LD_VAR 0 5
39799: ARRAY
39800: PUSH
39801: LD_VAR 0 6
39805: PUSH
39806: LD_INT 2
39808: ARRAY
39809: PUSH
39810: LD_VAR 0 5
39814: ARRAY
39815: PUSH
39816: EMPTY
39817: LIST
39818: LIST
39819: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
39820: LD_VAR 0 7
39824: PUSH
39825: LD_INT 1
39827: ARRAY
39828: PPUSH
39829: LD_VAR 0 7
39833: PUSH
39834: LD_INT 2
39836: ARRAY
39837: PPUSH
39838: CALL_OW 428
39842: PUSH
39843: LD_INT 0
39845: EQUAL
39846: IFFALSE 39899
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
39848: LD_VAR 0 1
39852: PPUSH
39853: LD_VAR 0 7
39857: PUSH
39858: LD_INT 1
39860: ARRAY
39861: PPUSH
39862: LD_VAR 0 7
39866: PUSH
39867: LD_INT 2
39869: ARRAY
39870: PPUSH
39871: LD_VAR 0 3
39875: PPUSH
39876: CALL_OW 48
// result := IsPlaced ( unit ) ;
39880: LD_ADDR_VAR 0 4
39884: PUSH
39885: LD_VAR 0 1
39889: PPUSH
39890: CALL_OW 305
39894: ST_TO_ADDR
// exit ;
39895: POP
39896: POP
39897: GO 39903
// end ; end ;
39899: GO 39778
39901: POP
39902: POP
// end ;
39903: LD_VAR 0 4
39907: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
39908: LD_INT 0
39910: PPUSH
39911: PPUSH
39912: PPUSH
// if not side or side > 8 then
39913: LD_VAR 0 1
39917: NOT
39918: PUSH
39919: LD_VAR 0 1
39923: PUSH
39924: LD_INT 8
39926: GREATER
39927: OR
39928: IFFALSE 39932
// exit ;
39930: GO 40119
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
39932: LD_ADDR_VAR 0 4
39936: PUSH
39937: LD_INT 22
39939: PUSH
39940: LD_VAR 0 1
39944: PUSH
39945: EMPTY
39946: LIST
39947: LIST
39948: PUSH
39949: LD_INT 21
39951: PUSH
39952: LD_INT 3
39954: PUSH
39955: EMPTY
39956: LIST
39957: LIST
39958: PUSH
39959: EMPTY
39960: LIST
39961: LIST
39962: PPUSH
39963: CALL_OW 69
39967: ST_TO_ADDR
// if not tmp then
39968: LD_VAR 0 4
39972: NOT
39973: IFFALSE 39977
// exit ;
39975: GO 40119
// enable_addtolog := true ;
39977: LD_ADDR_OWVAR 81
39981: PUSH
39982: LD_INT 1
39984: ST_TO_ADDR
// AddToLog ( [ ) ;
39985: LD_STRING [
39987: PPUSH
39988: CALL_OW 561
// for i in tmp do
39992: LD_ADDR_VAR 0 3
39996: PUSH
39997: LD_VAR 0 4
40001: PUSH
40002: FOR_IN
40003: IFFALSE 40110
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
40005: LD_STRING [
40007: PUSH
40008: LD_VAR 0 3
40012: PPUSH
40013: CALL_OW 266
40017: STR
40018: PUSH
40019: LD_STRING , 
40021: STR
40022: PUSH
40023: LD_VAR 0 3
40027: PPUSH
40028: CALL_OW 250
40032: STR
40033: PUSH
40034: LD_STRING , 
40036: STR
40037: PUSH
40038: LD_VAR 0 3
40042: PPUSH
40043: CALL_OW 251
40047: STR
40048: PUSH
40049: LD_STRING , 
40051: STR
40052: PUSH
40053: LD_VAR 0 3
40057: PPUSH
40058: CALL_OW 254
40062: STR
40063: PUSH
40064: LD_STRING , 
40066: STR
40067: PUSH
40068: LD_VAR 0 3
40072: PPUSH
40073: LD_INT 1
40075: PPUSH
40076: CALL_OW 268
40080: STR
40081: PUSH
40082: LD_STRING , 
40084: STR
40085: PUSH
40086: LD_VAR 0 3
40090: PPUSH
40091: LD_INT 2
40093: PPUSH
40094: CALL_OW 268
40098: STR
40099: PUSH
40100: LD_STRING ],
40102: STR
40103: PPUSH
40104: CALL_OW 561
// end ;
40108: GO 40002
40110: POP
40111: POP
// AddToLog ( ]; ) ;
40112: LD_STRING ];
40114: PPUSH
40115: CALL_OW 561
// end ;
40119: LD_VAR 0 2
40123: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
40124: LD_INT 0
40126: PPUSH
40127: PPUSH
40128: PPUSH
40129: PPUSH
40130: PPUSH
// if not area or not rate or not max then
40131: LD_VAR 0 1
40135: NOT
40136: PUSH
40137: LD_VAR 0 2
40141: NOT
40142: OR
40143: PUSH
40144: LD_VAR 0 4
40148: NOT
40149: OR
40150: IFFALSE 40154
// exit ;
40152: GO 40346
// while 1 do
40154: LD_INT 1
40156: IFFALSE 40346
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
40158: LD_ADDR_VAR 0 9
40162: PUSH
40163: LD_VAR 0 1
40167: PPUSH
40168: LD_INT 1
40170: PPUSH
40171: CALL_OW 287
40175: PUSH
40176: LD_INT 10
40178: MUL
40179: ST_TO_ADDR
// r := rate / 10 ;
40180: LD_ADDR_VAR 0 7
40184: PUSH
40185: LD_VAR 0 2
40189: PUSH
40190: LD_INT 10
40192: DIVREAL
40193: ST_TO_ADDR
// time := 1 1$00 ;
40194: LD_ADDR_VAR 0 8
40198: PUSH
40199: LD_INT 2100
40201: ST_TO_ADDR
// if amount < min then
40202: LD_VAR 0 9
40206: PUSH
40207: LD_VAR 0 3
40211: LESS
40212: IFFALSE 40230
// r := r * 2 else
40214: LD_ADDR_VAR 0 7
40218: PUSH
40219: LD_VAR 0 7
40223: PUSH
40224: LD_INT 2
40226: MUL
40227: ST_TO_ADDR
40228: GO 40256
// if amount > max then
40230: LD_VAR 0 9
40234: PUSH
40235: LD_VAR 0 4
40239: GREATER
40240: IFFALSE 40256
// r := r / 2 ;
40242: LD_ADDR_VAR 0 7
40246: PUSH
40247: LD_VAR 0 7
40251: PUSH
40252: LD_INT 2
40254: DIVREAL
40255: ST_TO_ADDR
// time := time / r ;
40256: LD_ADDR_VAR 0 8
40260: PUSH
40261: LD_VAR 0 8
40265: PUSH
40266: LD_VAR 0 7
40270: DIVREAL
40271: ST_TO_ADDR
// if time < 0 then
40272: LD_VAR 0 8
40276: PUSH
40277: LD_INT 0
40279: LESS
40280: IFFALSE 40297
// time := time * - 1 ;
40282: LD_ADDR_VAR 0 8
40286: PUSH
40287: LD_VAR 0 8
40291: PUSH
40292: LD_INT 1
40294: NEG
40295: MUL
40296: ST_TO_ADDR
// wait ( time ) ;
40297: LD_VAR 0 8
40301: PPUSH
40302: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
40306: LD_INT 35
40308: PPUSH
40309: LD_INT 875
40311: PPUSH
40312: CALL_OW 12
40316: PPUSH
40317: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
40321: LD_INT 1
40323: PPUSH
40324: LD_INT 5
40326: PPUSH
40327: CALL_OW 12
40331: PPUSH
40332: LD_VAR 0 1
40336: PPUSH
40337: LD_INT 1
40339: PPUSH
40340: CALL_OW 55
// end ;
40344: GO 40154
// end ;
40346: LD_VAR 0 5
40350: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
40351: LD_INT 0
40353: PPUSH
40354: PPUSH
40355: PPUSH
40356: PPUSH
40357: PPUSH
40358: PPUSH
40359: PPUSH
40360: PPUSH
// if not turrets or not factories then
40361: LD_VAR 0 1
40365: NOT
40366: PUSH
40367: LD_VAR 0 2
40371: NOT
40372: OR
40373: IFFALSE 40377
// exit ;
40375: GO 40684
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
40377: LD_ADDR_VAR 0 10
40381: PUSH
40382: LD_INT 5
40384: PUSH
40385: LD_INT 6
40387: PUSH
40388: EMPTY
40389: LIST
40390: LIST
40391: PUSH
40392: LD_INT 2
40394: PUSH
40395: LD_INT 4
40397: PUSH
40398: EMPTY
40399: LIST
40400: LIST
40401: PUSH
40402: LD_INT 3
40404: PUSH
40405: LD_INT 5
40407: PUSH
40408: EMPTY
40409: LIST
40410: LIST
40411: PUSH
40412: EMPTY
40413: LIST
40414: LIST
40415: LIST
40416: PUSH
40417: LD_INT 24
40419: PUSH
40420: LD_INT 25
40422: PUSH
40423: EMPTY
40424: LIST
40425: LIST
40426: PUSH
40427: LD_INT 23
40429: PUSH
40430: LD_INT 27
40432: PUSH
40433: EMPTY
40434: LIST
40435: LIST
40436: PUSH
40437: EMPTY
40438: LIST
40439: LIST
40440: PUSH
40441: LD_INT 42
40443: PUSH
40444: LD_INT 43
40446: PUSH
40447: EMPTY
40448: LIST
40449: LIST
40450: PUSH
40451: LD_INT 44
40453: PUSH
40454: LD_INT 46
40456: PUSH
40457: EMPTY
40458: LIST
40459: LIST
40460: PUSH
40461: LD_INT 45
40463: PUSH
40464: LD_INT 47
40466: PUSH
40467: EMPTY
40468: LIST
40469: LIST
40470: PUSH
40471: EMPTY
40472: LIST
40473: LIST
40474: LIST
40475: PUSH
40476: EMPTY
40477: LIST
40478: LIST
40479: LIST
40480: ST_TO_ADDR
// result := [ ] ;
40481: LD_ADDR_VAR 0 3
40485: PUSH
40486: EMPTY
40487: ST_TO_ADDR
// for i in turrets do
40488: LD_ADDR_VAR 0 4
40492: PUSH
40493: LD_VAR 0 1
40497: PUSH
40498: FOR_IN
40499: IFFALSE 40682
// begin nat := GetNation ( i ) ;
40501: LD_ADDR_VAR 0 7
40505: PUSH
40506: LD_VAR 0 4
40510: PPUSH
40511: CALL_OW 248
40515: ST_TO_ADDR
// weapon := 0 ;
40516: LD_ADDR_VAR 0 8
40520: PUSH
40521: LD_INT 0
40523: ST_TO_ADDR
// if not nat then
40524: LD_VAR 0 7
40528: NOT
40529: IFFALSE 40533
// continue ;
40531: GO 40498
// for j in list [ nat ] do
40533: LD_ADDR_VAR 0 5
40537: PUSH
40538: LD_VAR 0 10
40542: PUSH
40543: LD_VAR 0 7
40547: ARRAY
40548: PUSH
40549: FOR_IN
40550: IFFALSE 40591
// if GetBWeapon ( i ) = j [ 1 ] then
40552: LD_VAR 0 4
40556: PPUSH
40557: CALL_OW 269
40561: PUSH
40562: LD_VAR 0 5
40566: PUSH
40567: LD_INT 1
40569: ARRAY
40570: EQUAL
40571: IFFALSE 40589
// begin weapon := j [ 2 ] ;
40573: LD_ADDR_VAR 0 8
40577: PUSH
40578: LD_VAR 0 5
40582: PUSH
40583: LD_INT 2
40585: ARRAY
40586: ST_TO_ADDR
// break ;
40587: GO 40591
// end ;
40589: GO 40549
40591: POP
40592: POP
// if not weapon then
40593: LD_VAR 0 8
40597: NOT
40598: IFFALSE 40602
// continue ;
40600: GO 40498
// for k in factories do
40602: LD_ADDR_VAR 0 6
40606: PUSH
40607: LD_VAR 0 2
40611: PUSH
40612: FOR_IN
40613: IFFALSE 40678
// begin weapons := AvailableWeaponList ( k ) ;
40615: LD_ADDR_VAR 0 9
40619: PUSH
40620: LD_VAR 0 6
40624: PPUSH
40625: CALL_OW 478
40629: ST_TO_ADDR
// if not weapons then
40630: LD_VAR 0 9
40634: NOT
40635: IFFALSE 40639
// continue ;
40637: GO 40612
// if weapon in weapons then
40639: LD_VAR 0 8
40643: PUSH
40644: LD_VAR 0 9
40648: IN
40649: IFFALSE 40676
// begin result := [ i , weapon ] ;
40651: LD_ADDR_VAR 0 3
40655: PUSH
40656: LD_VAR 0 4
40660: PUSH
40661: LD_VAR 0 8
40665: PUSH
40666: EMPTY
40667: LIST
40668: LIST
40669: ST_TO_ADDR
// exit ;
40670: POP
40671: POP
40672: POP
40673: POP
40674: GO 40684
// end ; end ;
40676: GO 40612
40678: POP
40679: POP
// end ;
40680: GO 40498
40682: POP
40683: POP
// end ;
40684: LD_VAR 0 3
40688: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
40689: LD_INT 0
40691: PPUSH
// if not side or side > 8 then
40692: LD_VAR 0 3
40696: NOT
40697: PUSH
40698: LD_VAR 0 3
40702: PUSH
40703: LD_INT 8
40705: GREATER
40706: OR
40707: IFFALSE 40711
// exit ;
40709: GO 40770
// if not range then
40711: LD_VAR 0 4
40715: NOT
40716: IFFALSE 40727
// range := - 12 ;
40718: LD_ADDR_VAR 0 4
40722: PUSH
40723: LD_INT 12
40725: NEG
40726: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
40727: LD_VAR 0 1
40731: PPUSH
40732: LD_VAR 0 2
40736: PPUSH
40737: LD_VAR 0 3
40741: PPUSH
40742: LD_VAR 0 4
40746: PPUSH
40747: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
40751: LD_VAR 0 1
40755: PPUSH
40756: LD_VAR 0 2
40760: PPUSH
40761: LD_VAR 0 3
40765: PPUSH
40766: CALL_OW 331
// end ;
40770: LD_VAR 0 5
40774: RET
// export function Video ( mode ) ; begin
40775: LD_INT 0
40777: PPUSH
// ingame_video = mode ;
40778: LD_ADDR_OWVAR 52
40782: PUSH
40783: LD_VAR 0 1
40787: ST_TO_ADDR
// interface_hidden = mode ;
40788: LD_ADDR_OWVAR 54
40792: PUSH
40793: LD_VAR 0 1
40797: ST_TO_ADDR
// end ;
40798: LD_VAR 0 2
40802: RET
// export function Join ( array , element ) ; begin
40803: LD_INT 0
40805: PPUSH
// result := Replace ( array , array + 1 , element ) ;
40806: LD_ADDR_VAR 0 3
40810: PUSH
40811: LD_VAR 0 1
40815: PPUSH
40816: LD_VAR 0 1
40820: PUSH
40821: LD_INT 1
40823: PLUS
40824: PPUSH
40825: LD_VAR 0 2
40829: PPUSH
40830: CALL_OW 1
40834: ST_TO_ADDR
// end ;
40835: LD_VAR 0 3
40839: RET
// export function JoinUnion ( array , element ) ; begin
40840: LD_INT 0
40842: PPUSH
// result := array union element ;
40843: LD_ADDR_VAR 0 3
40847: PUSH
40848: LD_VAR 0 1
40852: PUSH
40853: LD_VAR 0 2
40857: UNION
40858: ST_TO_ADDR
// end ;
40859: LD_VAR 0 3
40863: RET
// export function GetBehemoths ( side ) ; begin
40864: LD_INT 0
40866: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
40867: LD_ADDR_VAR 0 2
40871: PUSH
40872: LD_INT 22
40874: PUSH
40875: LD_VAR 0 1
40879: PUSH
40880: EMPTY
40881: LIST
40882: LIST
40883: PUSH
40884: LD_INT 31
40886: PUSH
40887: LD_INT 25
40889: PUSH
40890: EMPTY
40891: LIST
40892: LIST
40893: PUSH
40894: EMPTY
40895: LIST
40896: LIST
40897: PPUSH
40898: CALL_OW 69
40902: ST_TO_ADDR
// end ;
40903: LD_VAR 0 2
40907: RET
// export function Shuffle ( array ) ; var i , index ; begin
40908: LD_INT 0
40910: PPUSH
40911: PPUSH
40912: PPUSH
// result := [ ] ;
40913: LD_ADDR_VAR 0 2
40917: PUSH
40918: EMPTY
40919: ST_TO_ADDR
// if not array then
40920: LD_VAR 0 1
40924: NOT
40925: IFFALSE 40929
// exit ;
40927: GO 41028
// Randomize ;
40929: CALL_OW 10
// for i = array downto 1 do
40933: LD_ADDR_VAR 0 3
40937: PUSH
40938: DOUBLE
40939: LD_VAR 0 1
40943: INC
40944: ST_TO_ADDR
40945: LD_INT 1
40947: PUSH
40948: FOR_DOWNTO
40949: IFFALSE 41026
// begin index := rand ( 1 , array ) ;
40951: LD_ADDR_VAR 0 4
40955: PUSH
40956: LD_INT 1
40958: PPUSH
40959: LD_VAR 0 1
40963: PPUSH
40964: CALL_OW 12
40968: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
40969: LD_ADDR_VAR 0 2
40973: PUSH
40974: LD_VAR 0 2
40978: PPUSH
40979: LD_VAR 0 2
40983: PUSH
40984: LD_INT 1
40986: PLUS
40987: PPUSH
40988: LD_VAR 0 1
40992: PUSH
40993: LD_VAR 0 4
40997: ARRAY
40998: PPUSH
40999: CALL_OW 2
41003: ST_TO_ADDR
// array := Delete ( array , index ) ;
41004: LD_ADDR_VAR 0 1
41008: PUSH
41009: LD_VAR 0 1
41013: PPUSH
41014: LD_VAR 0 4
41018: PPUSH
41019: CALL_OW 3
41023: ST_TO_ADDR
// end ;
41024: GO 40948
41026: POP
41027: POP
// end ;
41028: LD_VAR 0 2
41032: RET
// export function GetBaseMaterials ( base ) ; begin
41033: LD_INT 0
41035: PPUSH
// result := [ 0 , 0 , 0 ] ;
41036: LD_ADDR_VAR 0 2
41040: PUSH
41041: LD_INT 0
41043: PUSH
41044: LD_INT 0
41046: PUSH
41047: LD_INT 0
41049: PUSH
41050: EMPTY
41051: LIST
41052: LIST
41053: LIST
41054: ST_TO_ADDR
// if not base then
41055: LD_VAR 0 1
41059: NOT
41060: IFFALSE 41064
// exit ;
41062: GO 41113
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
41064: LD_ADDR_VAR 0 2
41068: PUSH
41069: LD_VAR 0 1
41073: PPUSH
41074: LD_INT 1
41076: PPUSH
41077: CALL_OW 275
41081: PUSH
41082: LD_VAR 0 1
41086: PPUSH
41087: LD_INT 2
41089: PPUSH
41090: CALL_OW 275
41094: PUSH
41095: LD_VAR 0 1
41099: PPUSH
41100: LD_INT 3
41102: PPUSH
41103: CALL_OW 275
41107: PUSH
41108: EMPTY
41109: LIST
41110: LIST
41111: LIST
41112: ST_TO_ADDR
// end ;
41113: LD_VAR 0 2
41117: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
41118: LD_INT 0
41120: PPUSH
41121: PPUSH
// result := array ;
41122: LD_ADDR_VAR 0 3
41126: PUSH
41127: LD_VAR 0 1
41131: ST_TO_ADDR
// if size > 0 then
41132: LD_VAR 0 2
41136: PUSH
41137: LD_INT 0
41139: GREATER
41140: IFFALSE 41186
// for i := array downto size do
41142: LD_ADDR_VAR 0 4
41146: PUSH
41147: DOUBLE
41148: LD_VAR 0 1
41152: INC
41153: ST_TO_ADDR
41154: LD_VAR 0 2
41158: PUSH
41159: FOR_DOWNTO
41160: IFFALSE 41184
// result := Delete ( result , result ) ;
41162: LD_ADDR_VAR 0 3
41166: PUSH
41167: LD_VAR 0 3
41171: PPUSH
41172: LD_VAR 0 3
41176: PPUSH
41177: CALL_OW 3
41181: ST_TO_ADDR
41182: GO 41159
41184: POP
41185: POP
// end ;
41186: LD_VAR 0 3
41190: RET
// export function ComExit ( unit ) ; var tmp ; begin
41191: LD_INT 0
41193: PPUSH
41194: PPUSH
// if not IsInUnit ( unit ) then
41195: LD_VAR 0 1
41199: PPUSH
41200: CALL_OW 310
41204: NOT
41205: IFFALSE 41209
// exit ;
41207: GO 41269
// tmp := IsInUnit ( unit ) ;
41209: LD_ADDR_VAR 0 3
41213: PUSH
41214: LD_VAR 0 1
41218: PPUSH
41219: CALL_OW 310
41223: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
41224: LD_VAR 0 3
41228: PPUSH
41229: CALL_OW 247
41233: PUSH
41234: LD_INT 2
41236: EQUAL
41237: IFFALSE 41250
// ComExitVehicle ( unit ) else
41239: LD_VAR 0 1
41243: PPUSH
41244: CALL_OW 121
41248: GO 41259
// ComExitBuilding ( unit ) ;
41250: LD_VAR 0 1
41254: PPUSH
41255: CALL_OW 122
// result := tmp ;
41259: LD_ADDR_VAR 0 2
41263: PUSH
41264: LD_VAR 0 3
41268: ST_TO_ADDR
// end ;
41269: LD_VAR 0 2
41273: RET
// export function ComExitAll ( units ) ; var i ; begin
41274: LD_INT 0
41276: PPUSH
41277: PPUSH
// if not units then
41278: LD_VAR 0 1
41282: NOT
41283: IFFALSE 41287
// exit ;
41285: GO 41313
// for i in units do
41287: LD_ADDR_VAR 0 3
41291: PUSH
41292: LD_VAR 0 1
41296: PUSH
41297: FOR_IN
41298: IFFALSE 41311
// ComExit ( i ) ;
41300: LD_VAR 0 3
41304: PPUSH
41305: CALL 41191 0 1
41309: GO 41297
41311: POP
41312: POP
// end ;
41313: LD_VAR 0 2
41317: RET
// export function ResetHc ; begin
41318: LD_INT 0
41320: PPUSH
// InitHc ;
41321: CALL_OW 19
// hc_importance := 0 ;
41325: LD_ADDR_OWVAR 32
41329: PUSH
41330: LD_INT 0
41332: ST_TO_ADDR
// end ;
41333: LD_VAR 0 1
41337: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
41338: LD_INT 0
41340: PPUSH
41341: PPUSH
41342: PPUSH
// _x := ( x1 + x2 ) div 2 ;
41343: LD_ADDR_VAR 0 6
41347: PUSH
41348: LD_VAR 0 1
41352: PUSH
41353: LD_VAR 0 3
41357: PLUS
41358: PUSH
41359: LD_INT 2
41361: DIV
41362: ST_TO_ADDR
// if _x < 0 then
41363: LD_VAR 0 6
41367: PUSH
41368: LD_INT 0
41370: LESS
41371: IFFALSE 41388
// _x := _x * - 1 ;
41373: LD_ADDR_VAR 0 6
41377: PUSH
41378: LD_VAR 0 6
41382: PUSH
41383: LD_INT 1
41385: NEG
41386: MUL
41387: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
41388: LD_ADDR_VAR 0 7
41392: PUSH
41393: LD_VAR 0 2
41397: PUSH
41398: LD_VAR 0 4
41402: PLUS
41403: PUSH
41404: LD_INT 2
41406: DIV
41407: ST_TO_ADDR
// if _y < 0 then
41408: LD_VAR 0 7
41412: PUSH
41413: LD_INT 0
41415: LESS
41416: IFFALSE 41433
// _y := _y * - 1 ;
41418: LD_ADDR_VAR 0 7
41422: PUSH
41423: LD_VAR 0 7
41427: PUSH
41428: LD_INT 1
41430: NEG
41431: MUL
41432: ST_TO_ADDR
// result := [ _x , _y ] ;
41433: LD_ADDR_VAR 0 5
41437: PUSH
41438: LD_VAR 0 6
41442: PUSH
41443: LD_VAR 0 7
41447: PUSH
41448: EMPTY
41449: LIST
41450: LIST
41451: ST_TO_ADDR
// end ;
41452: LD_VAR 0 5
41456: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
41457: LD_INT 0
41459: PPUSH
41460: PPUSH
41461: PPUSH
41462: PPUSH
// task := GetTaskList ( unit ) ;
41463: LD_ADDR_VAR 0 7
41467: PUSH
41468: LD_VAR 0 1
41472: PPUSH
41473: CALL_OW 437
41477: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
41478: LD_VAR 0 7
41482: NOT
41483: PUSH
41484: LD_VAR 0 1
41488: PPUSH
41489: LD_VAR 0 2
41493: PPUSH
41494: CALL_OW 308
41498: NOT
41499: AND
41500: IFFALSE 41504
// exit ;
41502: GO 41622
// if IsInArea ( unit , area ) then
41504: LD_VAR 0 1
41508: PPUSH
41509: LD_VAR 0 2
41513: PPUSH
41514: CALL_OW 308
41518: IFFALSE 41536
// begin ComMoveToArea ( unit , goAway ) ;
41520: LD_VAR 0 1
41524: PPUSH
41525: LD_VAR 0 3
41529: PPUSH
41530: CALL_OW 113
// exit ;
41534: GO 41622
// end ; if task [ 1 ] [ 1 ] <> M then
41536: LD_VAR 0 7
41540: PUSH
41541: LD_INT 1
41543: ARRAY
41544: PUSH
41545: LD_INT 1
41547: ARRAY
41548: PUSH
41549: LD_STRING M
41551: NONEQUAL
41552: IFFALSE 41556
// exit ;
41554: GO 41622
// x := task [ 1 ] [ 2 ] ;
41556: LD_ADDR_VAR 0 5
41560: PUSH
41561: LD_VAR 0 7
41565: PUSH
41566: LD_INT 1
41568: ARRAY
41569: PUSH
41570: LD_INT 2
41572: ARRAY
41573: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
41574: LD_ADDR_VAR 0 6
41578: PUSH
41579: LD_VAR 0 7
41583: PUSH
41584: LD_INT 1
41586: ARRAY
41587: PUSH
41588: LD_INT 3
41590: ARRAY
41591: ST_TO_ADDR
// if InArea ( x , y , area ) then
41592: LD_VAR 0 5
41596: PPUSH
41597: LD_VAR 0 6
41601: PPUSH
41602: LD_VAR 0 2
41606: PPUSH
41607: CALL_OW 309
41611: IFFALSE 41622
// ComStop ( unit ) ;
41613: LD_VAR 0 1
41617: PPUSH
41618: CALL_OW 141
// end ;
41622: LD_VAR 0 4
41626: RET
// export function Abs ( value ) ; begin
41627: LD_INT 0
41629: PPUSH
// result := value ;
41630: LD_ADDR_VAR 0 2
41634: PUSH
41635: LD_VAR 0 1
41639: ST_TO_ADDR
// if value < 0 then
41640: LD_VAR 0 1
41644: PUSH
41645: LD_INT 0
41647: LESS
41648: IFFALSE 41665
// result := value * - 1 ;
41650: LD_ADDR_VAR 0 2
41654: PUSH
41655: LD_VAR 0 1
41659: PUSH
41660: LD_INT 1
41662: NEG
41663: MUL
41664: ST_TO_ADDR
// end ;
41665: LD_VAR 0 2
41669: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
41670: LD_INT 0
41672: PPUSH
41673: PPUSH
41674: PPUSH
41675: PPUSH
41676: PPUSH
41677: PPUSH
41678: PPUSH
41679: PPUSH
// if not unit or not building then
41680: LD_VAR 0 1
41684: NOT
41685: PUSH
41686: LD_VAR 0 2
41690: NOT
41691: OR
41692: IFFALSE 41696
// exit ;
41694: GO 41922
// x := GetX ( building ) ;
41696: LD_ADDR_VAR 0 4
41700: PUSH
41701: LD_VAR 0 2
41705: PPUSH
41706: CALL_OW 250
41710: ST_TO_ADDR
// y := GetY ( building ) ;
41711: LD_ADDR_VAR 0 6
41715: PUSH
41716: LD_VAR 0 2
41720: PPUSH
41721: CALL_OW 251
41725: ST_TO_ADDR
// d := GetDir ( building ) ;
41726: LD_ADDR_VAR 0 8
41730: PUSH
41731: LD_VAR 0 2
41735: PPUSH
41736: CALL_OW 254
41740: ST_TO_ADDR
// r := 4 ;
41741: LD_ADDR_VAR 0 9
41745: PUSH
41746: LD_INT 4
41748: ST_TO_ADDR
// for i := 1 to 5 do
41749: LD_ADDR_VAR 0 10
41753: PUSH
41754: DOUBLE
41755: LD_INT 1
41757: DEC
41758: ST_TO_ADDR
41759: LD_INT 5
41761: PUSH
41762: FOR_TO
41763: IFFALSE 41920
// begin _x := ShiftX ( x , d , r + i ) ;
41765: LD_ADDR_VAR 0 5
41769: PUSH
41770: LD_VAR 0 4
41774: PPUSH
41775: LD_VAR 0 8
41779: PPUSH
41780: LD_VAR 0 9
41784: PUSH
41785: LD_VAR 0 10
41789: PLUS
41790: PPUSH
41791: CALL_OW 272
41795: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
41796: LD_ADDR_VAR 0 7
41800: PUSH
41801: LD_VAR 0 6
41805: PPUSH
41806: LD_VAR 0 8
41810: PPUSH
41811: LD_VAR 0 9
41815: PUSH
41816: LD_VAR 0 10
41820: PLUS
41821: PPUSH
41822: CALL_OW 273
41826: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
41827: LD_VAR 0 5
41831: PPUSH
41832: LD_VAR 0 7
41836: PPUSH
41837: CALL_OW 488
41841: PUSH
41842: LD_VAR 0 5
41846: PPUSH
41847: LD_VAR 0 7
41851: PPUSH
41852: CALL_OW 428
41856: PPUSH
41857: CALL_OW 247
41861: PUSH
41862: LD_INT 3
41864: PUSH
41865: LD_INT 2
41867: PUSH
41868: EMPTY
41869: LIST
41870: LIST
41871: IN
41872: NOT
41873: AND
41874: IFFALSE 41918
// begin ComMoveXY ( unit , _x , _y ) ;
41876: LD_VAR 0 1
41880: PPUSH
41881: LD_VAR 0 5
41885: PPUSH
41886: LD_VAR 0 7
41890: PPUSH
41891: CALL_OW 111
// result := [ _x , _y ] ;
41895: LD_ADDR_VAR 0 3
41899: PUSH
41900: LD_VAR 0 5
41904: PUSH
41905: LD_VAR 0 7
41909: PUSH
41910: EMPTY
41911: LIST
41912: LIST
41913: ST_TO_ADDR
// exit ;
41914: POP
41915: POP
41916: GO 41922
// end ; end ;
41918: GO 41762
41920: POP
41921: POP
// end ;
41922: LD_VAR 0 3
41926: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
41927: LD_INT 0
41929: PPUSH
41930: PPUSH
41931: PPUSH
// result := 0 ;
41932: LD_ADDR_VAR 0 3
41936: PUSH
41937: LD_INT 0
41939: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
41940: LD_VAR 0 1
41944: PUSH
41945: LD_INT 0
41947: LESS
41948: PUSH
41949: LD_VAR 0 1
41953: PUSH
41954: LD_INT 8
41956: GREATER
41957: OR
41958: PUSH
41959: LD_VAR 0 2
41963: PUSH
41964: LD_INT 0
41966: LESS
41967: OR
41968: PUSH
41969: LD_VAR 0 2
41973: PUSH
41974: LD_INT 8
41976: GREATER
41977: OR
41978: IFFALSE 41982
// exit ;
41980: GO 42057
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
41982: LD_ADDR_VAR 0 4
41986: PUSH
41987: LD_INT 22
41989: PUSH
41990: LD_VAR 0 2
41994: PUSH
41995: EMPTY
41996: LIST
41997: LIST
41998: PPUSH
41999: CALL_OW 69
42003: PUSH
42004: FOR_IN
42005: IFFALSE 42055
// begin un := UnitShoot ( i ) ;
42007: LD_ADDR_VAR 0 5
42011: PUSH
42012: LD_VAR 0 4
42016: PPUSH
42017: CALL_OW 504
42021: ST_TO_ADDR
// if GetSide ( un ) = side1 then
42022: LD_VAR 0 5
42026: PPUSH
42027: CALL_OW 255
42031: PUSH
42032: LD_VAR 0 1
42036: EQUAL
42037: IFFALSE 42053
// begin result := un ;
42039: LD_ADDR_VAR 0 3
42043: PUSH
42044: LD_VAR 0 5
42048: ST_TO_ADDR
// exit ;
42049: POP
42050: POP
42051: GO 42057
// end ; end ;
42053: GO 42004
42055: POP
42056: POP
// end ;
42057: LD_VAR 0 3
42061: RET
// export function GetCargoBay ( units ) ; begin
42062: LD_INT 0
42064: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
42065: LD_ADDR_VAR 0 2
42069: PUSH
42070: LD_VAR 0 1
42074: PPUSH
42075: LD_INT 2
42077: PUSH
42078: LD_INT 34
42080: PUSH
42081: LD_INT 12
42083: PUSH
42084: EMPTY
42085: LIST
42086: LIST
42087: PUSH
42088: LD_INT 34
42090: PUSH
42091: LD_INT 51
42093: PUSH
42094: EMPTY
42095: LIST
42096: LIST
42097: PUSH
42098: LD_INT 34
42100: PUSH
42101: LD_INT 32
42103: PUSH
42104: EMPTY
42105: LIST
42106: LIST
42107: PUSH
42108: LD_INT 34
42110: PUSH
42111: LD_EXP 58
42115: PUSH
42116: EMPTY
42117: LIST
42118: LIST
42119: PUSH
42120: EMPTY
42121: LIST
42122: LIST
42123: LIST
42124: LIST
42125: LIST
42126: PPUSH
42127: CALL_OW 72
42131: ST_TO_ADDR
// end ; end_of_file
42132: LD_VAR 0 2
42136: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
42137: LD_INT 0
42139: PPUSH
42140: PPUSH
// skirmish := false ;
42141: LD_ADDR_EXP 12
42145: PUSH
42146: LD_INT 0
42148: ST_TO_ADDR
// debug_mc := false ;
42149: LD_ADDR_EXP 13
42153: PUSH
42154: LD_INT 0
42156: ST_TO_ADDR
// mc_bases := [ ] ;
42157: LD_ADDR_EXP 14
42161: PUSH
42162: EMPTY
42163: ST_TO_ADDR
// mc_sides := [ ] ;
42164: LD_ADDR_EXP 40
42168: PUSH
42169: EMPTY
42170: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
42171: LD_ADDR_EXP 15
42175: PUSH
42176: EMPTY
42177: ST_TO_ADDR
// mc_building_repairs := [ ] ;
42178: LD_ADDR_EXP 16
42182: PUSH
42183: EMPTY
42184: ST_TO_ADDR
// mc_need_heal := [ ] ;
42185: LD_ADDR_EXP 17
42189: PUSH
42190: EMPTY
42191: ST_TO_ADDR
// mc_healers := [ ] ;
42192: LD_ADDR_EXP 18
42196: PUSH
42197: EMPTY
42198: ST_TO_ADDR
// mc_build_list := [ ] ;
42199: LD_ADDR_EXP 19
42203: PUSH
42204: EMPTY
42205: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
42206: LD_ADDR_EXP 46
42210: PUSH
42211: EMPTY
42212: ST_TO_ADDR
// mc_builders := [ ] ;
42213: LD_ADDR_EXP 20
42217: PUSH
42218: EMPTY
42219: ST_TO_ADDR
// mc_construct_list := [ ] ;
42220: LD_ADDR_EXP 21
42224: PUSH
42225: EMPTY
42226: ST_TO_ADDR
// mc_turret_list := [ ] ;
42227: LD_ADDR_EXP 22
42231: PUSH
42232: EMPTY
42233: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
42234: LD_ADDR_EXP 23
42238: PUSH
42239: EMPTY
42240: ST_TO_ADDR
// mc_miners := [ ] ;
42241: LD_ADDR_EXP 28
42245: PUSH
42246: EMPTY
42247: ST_TO_ADDR
// mc_mines := [ ] ;
42248: LD_ADDR_EXP 27
42252: PUSH
42253: EMPTY
42254: ST_TO_ADDR
// mc_minefields := [ ] ;
42255: LD_ADDR_EXP 29
42259: PUSH
42260: EMPTY
42261: ST_TO_ADDR
// mc_crates := [ ] ;
42262: LD_ADDR_EXP 30
42266: PUSH
42267: EMPTY
42268: ST_TO_ADDR
// mc_crates_collector := [ ] ;
42269: LD_ADDR_EXP 31
42273: PUSH
42274: EMPTY
42275: ST_TO_ADDR
// mc_crates_area := [ ] ;
42276: LD_ADDR_EXP 32
42280: PUSH
42281: EMPTY
42282: ST_TO_ADDR
// mc_vehicles := [ ] ;
42283: LD_ADDR_EXP 33
42287: PUSH
42288: EMPTY
42289: ST_TO_ADDR
// mc_attack := [ ] ;
42290: LD_ADDR_EXP 34
42294: PUSH
42295: EMPTY
42296: ST_TO_ADDR
// mc_produce := [ ] ;
42297: LD_ADDR_EXP 35
42301: PUSH
42302: EMPTY
42303: ST_TO_ADDR
// mc_defender := [ ] ;
42304: LD_ADDR_EXP 36
42308: PUSH
42309: EMPTY
42310: ST_TO_ADDR
// mc_parking := [ ] ;
42311: LD_ADDR_EXP 38
42315: PUSH
42316: EMPTY
42317: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
42318: LD_ADDR_EXP 24
42322: PUSH
42323: EMPTY
42324: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
42325: LD_ADDR_EXP 26
42329: PUSH
42330: EMPTY
42331: ST_TO_ADDR
// mc_scan := [ ] ;
42332: LD_ADDR_EXP 37
42336: PUSH
42337: EMPTY
42338: ST_TO_ADDR
// mc_scan_area := [ ] ;
42339: LD_ADDR_EXP 39
42343: PUSH
42344: EMPTY
42345: ST_TO_ADDR
// mc_tech := [ ] ;
42346: LD_ADDR_EXP 41
42350: PUSH
42351: EMPTY
42352: ST_TO_ADDR
// mc_class := [ ] ;
42353: LD_ADDR_EXP 55
42357: PUSH
42358: EMPTY
42359: ST_TO_ADDR
// mc_class_case_use := [ ] ;
42360: LD_ADDR_EXP 56
42364: PUSH
42365: EMPTY
42366: ST_TO_ADDR
// end ;
42367: LD_VAR 0 1
42371: RET
// export function MC_Kill ( base ) ; begin
42372: LD_INT 0
42374: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
42375: LD_ADDR_EXP 14
42379: PUSH
42380: LD_EXP 14
42384: PPUSH
42385: LD_VAR 0 1
42389: PPUSH
42390: EMPTY
42391: PPUSH
42392: CALL_OW 1
42396: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
42397: LD_ADDR_EXP 15
42401: PUSH
42402: LD_EXP 15
42406: PPUSH
42407: LD_VAR 0 1
42411: PPUSH
42412: EMPTY
42413: PPUSH
42414: CALL_OW 1
42418: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
42419: LD_ADDR_EXP 16
42423: PUSH
42424: LD_EXP 16
42428: PPUSH
42429: LD_VAR 0 1
42433: PPUSH
42434: EMPTY
42435: PPUSH
42436: CALL_OW 1
42440: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
42441: LD_ADDR_EXP 17
42445: PUSH
42446: LD_EXP 17
42450: PPUSH
42451: LD_VAR 0 1
42455: PPUSH
42456: EMPTY
42457: PPUSH
42458: CALL_OW 1
42462: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
42463: LD_ADDR_EXP 18
42467: PUSH
42468: LD_EXP 18
42472: PPUSH
42473: LD_VAR 0 1
42477: PPUSH
42478: EMPTY
42479: PPUSH
42480: CALL_OW 1
42484: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
42485: LD_ADDR_EXP 19
42489: PUSH
42490: LD_EXP 19
42494: PPUSH
42495: LD_VAR 0 1
42499: PPUSH
42500: EMPTY
42501: PPUSH
42502: CALL_OW 1
42506: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
42507: LD_ADDR_EXP 20
42511: PUSH
42512: LD_EXP 20
42516: PPUSH
42517: LD_VAR 0 1
42521: PPUSH
42522: EMPTY
42523: PPUSH
42524: CALL_OW 1
42528: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
42529: LD_ADDR_EXP 21
42533: PUSH
42534: LD_EXP 21
42538: PPUSH
42539: LD_VAR 0 1
42543: PPUSH
42544: EMPTY
42545: PPUSH
42546: CALL_OW 1
42550: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
42551: LD_ADDR_EXP 22
42555: PUSH
42556: LD_EXP 22
42560: PPUSH
42561: LD_VAR 0 1
42565: PPUSH
42566: EMPTY
42567: PPUSH
42568: CALL_OW 1
42572: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
42573: LD_ADDR_EXP 23
42577: PUSH
42578: LD_EXP 23
42582: PPUSH
42583: LD_VAR 0 1
42587: PPUSH
42588: EMPTY
42589: PPUSH
42590: CALL_OW 1
42594: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
42595: LD_ADDR_EXP 24
42599: PUSH
42600: LD_EXP 24
42604: PPUSH
42605: LD_VAR 0 1
42609: PPUSH
42610: EMPTY
42611: PPUSH
42612: CALL_OW 1
42616: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
42617: LD_ADDR_EXP 25
42621: PUSH
42622: LD_EXP 25
42626: PPUSH
42627: LD_VAR 0 1
42631: PPUSH
42632: LD_INT 0
42634: PPUSH
42635: CALL_OW 1
42639: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
42640: LD_ADDR_EXP 26
42644: PUSH
42645: LD_EXP 26
42649: PPUSH
42650: LD_VAR 0 1
42654: PPUSH
42655: EMPTY
42656: PPUSH
42657: CALL_OW 1
42661: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
42662: LD_ADDR_EXP 27
42666: PUSH
42667: LD_EXP 27
42671: PPUSH
42672: LD_VAR 0 1
42676: PPUSH
42677: EMPTY
42678: PPUSH
42679: CALL_OW 1
42683: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
42684: LD_ADDR_EXP 28
42688: PUSH
42689: LD_EXP 28
42693: PPUSH
42694: LD_VAR 0 1
42698: PPUSH
42699: EMPTY
42700: PPUSH
42701: CALL_OW 1
42705: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
42706: LD_ADDR_EXP 29
42710: PUSH
42711: LD_EXP 29
42715: PPUSH
42716: LD_VAR 0 1
42720: PPUSH
42721: EMPTY
42722: PPUSH
42723: CALL_OW 1
42727: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
42728: LD_ADDR_EXP 30
42732: PUSH
42733: LD_EXP 30
42737: PPUSH
42738: LD_VAR 0 1
42742: PPUSH
42743: EMPTY
42744: PPUSH
42745: CALL_OW 1
42749: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
42750: LD_ADDR_EXP 31
42754: PUSH
42755: LD_EXP 31
42759: PPUSH
42760: LD_VAR 0 1
42764: PPUSH
42765: EMPTY
42766: PPUSH
42767: CALL_OW 1
42771: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
42772: LD_ADDR_EXP 32
42776: PUSH
42777: LD_EXP 32
42781: PPUSH
42782: LD_VAR 0 1
42786: PPUSH
42787: EMPTY
42788: PPUSH
42789: CALL_OW 1
42793: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
42794: LD_ADDR_EXP 33
42798: PUSH
42799: LD_EXP 33
42803: PPUSH
42804: LD_VAR 0 1
42808: PPUSH
42809: EMPTY
42810: PPUSH
42811: CALL_OW 1
42815: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
42816: LD_ADDR_EXP 34
42820: PUSH
42821: LD_EXP 34
42825: PPUSH
42826: LD_VAR 0 1
42830: PPUSH
42831: EMPTY
42832: PPUSH
42833: CALL_OW 1
42837: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
42838: LD_ADDR_EXP 35
42842: PUSH
42843: LD_EXP 35
42847: PPUSH
42848: LD_VAR 0 1
42852: PPUSH
42853: EMPTY
42854: PPUSH
42855: CALL_OW 1
42859: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
42860: LD_ADDR_EXP 36
42864: PUSH
42865: LD_EXP 36
42869: PPUSH
42870: LD_VAR 0 1
42874: PPUSH
42875: EMPTY
42876: PPUSH
42877: CALL_OW 1
42881: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
42882: LD_ADDR_EXP 37
42886: PUSH
42887: LD_EXP 37
42891: PPUSH
42892: LD_VAR 0 1
42896: PPUSH
42897: EMPTY
42898: PPUSH
42899: CALL_OW 1
42903: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
42904: LD_ADDR_EXP 38
42908: PUSH
42909: LD_EXP 38
42913: PPUSH
42914: LD_VAR 0 1
42918: PPUSH
42919: EMPTY
42920: PPUSH
42921: CALL_OW 1
42925: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
42926: LD_ADDR_EXP 39
42930: PUSH
42931: LD_EXP 39
42935: PPUSH
42936: LD_VAR 0 1
42940: PPUSH
42941: EMPTY
42942: PPUSH
42943: CALL_OW 1
42947: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
42948: LD_ADDR_EXP 41
42952: PUSH
42953: LD_EXP 41
42957: PPUSH
42958: LD_VAR 0 1
42962: PPUSH
42963: EMPTY
42964: PPUSH
42965: CALL_OW 1
42969: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
42970: LD_ADDR_EXP 43
42974: PUSH
42975: LD_EXP 43
42979: PPUSH
42980: LD_VAR 0 1
42984: PPUSH
42985: EMPTY
42986: PPUSH
42987: CALL_OW 1
42991: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
42992: LD_ADDR_EXP 44
42996: PUSH
42997: LD_EXP 44
43001: PPUSH
43002: LD_VAR 0 1
43006: PPUSH
43007: EMPTY
43008: PPUSH
43009: CALL_OW 1
43013: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
43014: LD_ADDR_EXP 45
43018: PUSH
43019: LD_EXP 45
43023: PPUSH
43024: LD_VAR 0 1
43028: PPUSH
43029: EMPTY
43030: PPUSH
43031: CALL_OW 1
43035: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
43036: LD_ADDR_EXP 46
43040: PUSH
43041: LD_EXP 46
43045: PPUSH
43046: LD_VAR 0 1
43050: PPUSH
43051: EMPTY
43052: PPUSH
43053: CALL_OW 1
43057: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
43058: LD_ADDR_EXP 47
43062: PUSH
43063: LD_EXP 47
43067: PPUSH
43068: LD_VAR 0 1
43072: PPUSH
43073: EMPTY
43074: PPUSH
43075: CALL_OW 1
43079: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
43080: LD_ADDR_EXP 48
43084: PUSH
43085: LD_EXP 48
43089: PPUSH
43090: LD_VAR 0 1
43094: PPUSH
43095: EMPTY
43096: PPUSH
43097: CALL_OW 1
43101: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
43102: LD_ADDR_EXP 49
43106: PUSH
43107: LD_EXP 49
43111: PPUSH
43112: LD_VAR 0 1
43116: PPUSH
43117: EMPTY
43118: PPUSH
43119: CALL_OW 1
43123: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
43124: LD_ADDR_EXP 50
43128: PUSH
43129: LD_EXP 50
43133: PPUSH
43134: LD_VAR 0 1
43138: PPUSH
43139: EMPTY
43140: PPUSH
43141: CALL_OW 1
43145: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
43146: LD_ADDR_EXP 51
43150: PUSH
43151: LD_EXP 51
43155: PPUSH
43156: LD_VAR 0 1
43160: PPUSH
43161: EMPTY
43162: PPUSH
43163: CALL_OW 1
43167: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
43168: LD_ADDR_EXP 52
43172: PUSH
43173: LD_EXP 52
43177: PPUSH
43178: LD_VAR 0 1
43182: PPUSH
43183: EMPTY
43184: PPUSH
43185: CALL_OW 1
43189: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
43190: LD_ADDR_EXP 53
43194: PUSH
43195: LD_EXP 53
43199: PPUSH
43200: LD_VAR 0 1
43204: PPUSH
43205: EMPTY
43206: PPUSH
43207: CALL_OW 1
43211: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
43212: LD_ADDR_EXP 54
43216: PUSH
43217: LD_EXP 54
43221: PPUSH
43222: LD_VAR 0 1
43226: PPUSH
43227: EMPTY
43228: PPUSH
43229: CALL_OW 1
43233: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
43234: LD_ADDR_EXP 55
43238: PUSH
43239: LD_EXP 55
43243: PPUSH
43244: LD_VAR 0 1
43248: PPUSH
43249: EMPTY
43250: PPUSH
43251: CALL_OW 1
43255: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
43256: LD_ADDR_EXP 56
43260: PUSH
43261: LD_EXP 56
43265: PPUSH
43266: LD_VAR 0 1
43270: PPUSH
43271: LD_INT 0
43273: PPUSH
43274: CALL_OW 1
43278: ST_TO_ADDR
// end ;
43279: LD_VAR 0 2
43283: RET
// export function MC_Add ( side , units ) ; var base ; begin
43284: LD_INT 0
43286: PPUSH
43287: PPUSH
// base := mc_bases + 1 ;
43288: LD_ADDR_VAR 0 4
43292: PUSH
43293: LD_EXP 14
43297: PUSH
43298: LD_INT 1
43300: PLUS
43301: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
43302: LD_ADDR_EXP 40
43306: PUSH
43307: LD_EXP 40
43311: PPUSH
43312: LD_VAR 0 4
43316: PPUSH
43317: LD_VAR 0 1
43321: PPUSH
43322: CALL_OW 1
43326: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
43327: LD_ADDR_EXP 14
43331: PUSH
43332: LD_EXP 14
43336: PPUSH
43337: LD_VAR 0 4
43341: PPUSH
43342: LD_VAR 0 2
43346: PPUSH
43347: CALL_OW 1
43351: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
43352: LD_ADDR_EXP 15
43356: PUSH
43357: LD_EXP 15
43361: PPUSH
43362: LD_VAR 0 4
43366: PPUSH
43367: EMPTY
43368: PPUSH
43369: CALL_OW 1
43373: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
43374: LD_ADDR_EXP 16
43378: PUSH
43379: LD_EXP 16
43383: PPUSH
43384: LD_VAR 0 4
43388: PPUSH
43389: EMPTY
43390: PPUSH
43391: CALL_OW 1
43395: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
43396: LD_ADDR_EXP 17
43400: PUSH
43401: LD_EXP 17
43405: PPUSH
43406: LD_VAR 0 4
43410: PPUSH
43411: EMPTY
43412: PPUSH
43413: CALL_OW 1
43417: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
43418: LD_ADDR_EXP 18
43422: PUSH
43423: LD_EXP 18
43427: PPUSH
43428: LD_VAR 0 4
43432: PPUSH
43433: EMPTY
43434: PPUSH
43435: CALL_OW 1
43439: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
43440: LD_ADDR_EXP 19
43444: PUSH
43445: LD_EXP 19
43449: PPUSH
43450: LD_VAR 0 4
43454: PPUSH
43455: EMPTY
43456: PPUSH
43457: CALL_OW 1
43461: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
43462: LD_ADDR_EXP 20
43466: PUSH
43467: LD_EXP 20
43471: PPUSH
43472: LD_VAR 0 4
43476: PPUSH
43477: EMPTY
43478: PPUSH
43479: CALL_OW 1
43483: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
43484: LD_ADDR_EXP 21
43488: PUSH
43489: LD_EXP 21
43493: PPUSH
43494: LD_VAR 0 4
43498: PPUSH
43499: EMPTY
43500: PPUSH
43501: CALL_OW 1
43505: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
43506: LD_ADDR_EXP 22
43510: PUSH
43511: LD_EXP 22
43515: PPUSH
43516: LD_VAR 0 4
43520: PPUSH
43521: EMPTY
43522: PPUSH
43523: CALL_OW 1
43527: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
43528: LD_ADDR_EXP 23
43532: PUSH
43533: LD_EXP 23
43537: PPUSH
43538: LD_VAR 0 4
43542: PPUSH
43543: EMPTY
43544: PPUSH
43545: CALL_OW 1
43549: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
43550: LD_ADDR_EXP 24
43554: PUSH
43555: LD_EXP 24
43559: PPUSH
43560: LD_VAR 0 4
43564: PPUSH
43565: EMPTY
43566: PPUSH
43567: CALL_OW 1
43571: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
43572: LD_ADDR_EXP 25
43576: PUSH
43577: LD_EXP 25
43581: PPUSH
43582: LD_VAR 0 4
43586: PPUSH
43587: LD_INT 0
43589: PPUSH
43590: CALL_OW 1
43594: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
43595: LD_ADDR_EXP 26
43599: PUSH
43600: LD_EXP 26
43604: PPUSH
43605: LD_VAR 0 4
43609: PPUSH
43610: EMPTY
43611: PPUSH
43612: CALL_OW 1
43616: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
43617: LD_ADDR_EXP 27
43621: PUSH
43622: LD_EXP 27
43626: PPUSH
43627: LD_VAR 0 4
43631: PPUSH
43632: EMPTY
43633: PPUSH
43634: CALL_OW 1
43638: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
43639: LD_ADDR_EXP 28
43643: PUSH
43644: LD_EXP 28
43648: PPUSH
43649: LD_VAR 0 4
43653: PPUSH
43654: EMPTY
43655: PPUSH
43656: CALL_OW 1
43660: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
43661: LD_ADDR_EXP 29
43665: PUSH
43666: LD_EXP 29
43670: PPUSH
43671: LD_VAR 0 4
43675: PPUSH
43676: EMPTY
43677: PPUSH
43678: CALL_OW 1
43682: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
43683: LD_ADDR_EXP 30
43687: PUSH
43688: LD_EXP 30
43692: PPUSH
43693: LD_VAR 0 4
43697: PPUSH
43698: EMPTY
43699: PPUSH
43700: CALL_OW 1
43704: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
43705: LD_ADDR_EXP 31
43709: PUSH
43710: LD_EXP 31
43714: PPUSH
43715: LD_VAR 0 4
43719: PPUSH
43720: EMPTY
43721: PPUSH
43722: CALL_OW 1
43726: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
43727: LD_ADDR_EXP 32
43731: PUSH
43732: LD_EXP 32
43736: PPUSH
43737: LD_VAR 0 4
43741: PPUSH
43742: EMPTY
43743: PPUSH
43744: CALL_OW 1
43748: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
43749: LD_ADDR_EXP 33
43753: PUSH
43754: LD_EXP 33
43758: PPUSH
43759: LD_VAR 0 4
43763: PPUSH
43764: EMPTY
43765: PPUSH
43766: CALL_OW 1
43770: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
43771: LD_ADDR_EXP 34
43775: PUSH
43776: LD_EXP 34
43780: PPUSH
43781: LD_VAR 0 4
43785: PPUSH
43786: EMPTY
43787: PPUSH
43788: CALL_OW 1
43792: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
43793: LD_ADDR_EXP 35
43797: PUSH
43798: LD_EXP 35
43802: PPUSH
43803: LD_VAR 0 4
43807: PPUSH
43808: EMPTY
43809: PPUSH
43810: CALL_OW 1
43814: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
43815: LD_ADDR_EXP 36
43819: PUSH
43820: LD_EXP 36
43824: PPUSH
43825: LD_VAR 0 4
43829: PPUSH
43830: EMPTY
43831: PPUSH
43832: CALL_OW 1
43836: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
43837: LD_ADDR_EXP 37
43841: PUSH
43842: LD_EXP 37
43846: PPUSH
43847: LD_VAR 0 4
43851: PPUSH
43852: EMPTY
43853: PPUSH
43854: CALL_OW 1
43858: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
43859: LD_ADDR_EXP 38
43863: PUSH
43864: LD_EXP 38
43868: PPUSH
43869: LD_VAR 0 4
43873: PPUSH
43874: EMPTY
43875: PPUSH
43876: CALL_OW 1
43880: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
43881: LD_ADDR_EXP 39
43885: PUSH
43886: LD_EXP 39
43890: PPUSH
43891: LD_VAR 0 4
43895: PPUSH
43896: EMPTY
43897: PPUSH
43898: CALL_OW 1
43902: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
43903: LD_ADDR_EXP 41
43907: PUSH
43908: LD_EXP 41
43912: PPUSH
43913: LD_VAR 0 4
43917: PPUSH
43918: EMPTY
43919: PPUSH
43920: CALL_OW 1
43924: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
43925: LD_ADDR_EXP 43
43929: PUSH
43930: LD_EXP 43
43934: PPUSH
43935: LD_VAR 0 4
43939: PPUSH
43940: EMPTY
43941: PPUSH
43942: CALL_OW 1
43946: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
43947: LD_ADDR_EXP 44
43951: PUSH
43952: LD_EXP 44
43956: PPUSH
43957: LD_VAR 0 4
43961: PPUSH
43962: EMPTY
43963: PPUSH
43964: CALL_OW 1
43968: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
43969: LD_ADDR_EXP 45
43973: PUSH
43974: LD_EXP 45
43978: PPUSH
43979: LD_VAR 0 4
43983: PPUSH
43984: EMPTY
43985: PPUSH
43986: CALL_OW 1
43990: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
43991: LD_ADDR_EXP 46
43995: PUSH
43996: LD_EXP 46
44000: PPUSH
44001: LD_VAR 0 4
44005: PPUSH
44006: EMPTY
44007: PPUSH
44008: CALL_OW 1
44012: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
44013: LD_ADDR_EXP 47
44017: PUSH
44018: LD_EXP 47
44022: PPUSH
44023: LD_VAR 0 4
44027: PPUSH
44028: EMPTY
44029: PPUSH
44030: CALL_OW 1
44034: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
44035: LD_ADDR_EXP 48
44039: PUSH
44040: LD_EXP 48
44044: PPUSH
44045: LD_VAR 0 4
44049: PPUSH
44050: EMPTY
44051: PPUSH
44052: CALL_OW 1
44056: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
44057: LD_ADDR_EXP 49
44061: PUSH
44062: LD_EXP 49
44066: PPUSH
44067: LD_VAR 0 4
44071: PPUSH
44072: EMPTY
44073: PPUSH
44074: CALL_OW 1
44078: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
44079: LD_ADDR_EXP 50
44083: PUSH
44084: LD_EXP 50
44088: PPUSH
44089: LD_VAR 0 4
44093: PPUSH
44094: EMPTY
44095: PPUSH
44096: CALL_OW 1
44100: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
44101: LD_ADDR_EXP 51
44105: PUSH
44106: LD_EXP 51
44110: PPUSH
44111: LD_VAR 0 4
44115: PPUSH
44116: EMPTY
44117: PPUSH
44118: CALL_OW 1
44122: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
44123: LD_ADDR_EXP 52
44127: PUSH
44128: LD_EXP 52
44132: PPUSH
44133: LD_VAR 0 4
44137: PPUSH
44138: EMPTY
44139: PPUSH
44140: CALL_OW 1
44144: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
44145: LD_ADDR_EXP 53
44149: PUSH
44150: LD_EXP 53
44154: PPUSH
44155: LD_VAR 0 4
44159: PPUSH
44160: EMPTY
44161: PPUSH
44162: CALL_OW 1
44166: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
44167: LD_ADDR_EXP 54
44171: PUSH
44172: LD_EXP 54
44176: PPUSH
44177: LD_VAR 0 4
44181: PPUSH
44182: EMPTY
44183: PPUSH
44184: CALL_OW 1
44188: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
44189: LD_ADDR_EXP 55
44193: PUSH
44194: LD_EXP 55
44198: PPUSH
44199: LD_VAR 0 4
44203: PPUSH
44204: EMPTY
44205: PPUSH
44206: CALL_OW 1
44210: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
44211: LD_ADDR_EXP 56
44215: PUSH
44216: LD_EXP 56
44220: PPUSH
44221: LD_VAR 0 4
44225: PPUSH
44226: LD_INT 0
44228: PPUSH
44229: CALL_OW 1
44233: ST_TO_ADDR
// result := base ;
44234: LD_ADDR_VAR 0 3
44238: PUSH
44239: LD_VAR 0 4
44243: ST_TO_ADDR
// end ;
44244: LD_VAR 0 3
44248: RET
// export function MC_Start ( ) ; var i ; begin
44249: LD_INT 0
44251: PPUSH
44252: PPUSH
// for i = 1 to mc_bases do
44253: LD_ADDR_VAR 0 2
44257: PUSH
44258: DOUBLE
44259: LD_INT 1
44261: DEC
44262: ST_TO_ADDR
44263: LD_EXP 14
44267: PUSH
44268: FOR_TO
44269: IFFALSE 45346
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
44271: LD_ADDR_EXP 14
44275: PUSH
44276: LD_EXP 14
44280: PPUSH
44281: LD_VAR 0 2
44285: PPUSH
44286: LD_EXP 14
44290: PUSH
44291: LD_VAR 0 2
44295: ARRAY
44296: PUSH
44297: LD_INT 0
44299: DIFF
44300: PPUSH
44301: CALL_OW 1
44305: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
44306: LD_ADDR_EXP 15
44310: PUSH
44311: LD_EXP 15
44315: PPUSH
44316: LD_VAR 0 2
44320: PPUSH
44321: EMPTY
44322: PPUSH
44323: CALL_OW 1
44327: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
44328: LD_ADDR_EXP 16
44332: PUSH
44333: LD_EXP 16
44337: PPUSH
44338: LD_VAR 0 2
44342: PPUSH
44343: EMPTY
44344: PPUSH
44345: CALL_OW 1
44349: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
44350: LD_ADDR_EXP 17
44354: PUSH
44355: LD_EXP 17
44359: PPUSH
44360: LD_VAR 0 2
44364: PPUSH
44365: EMPTY
44366: PPUSH
44367: CALL_OW 1
44371: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
44372: LD_ADDR_EXP 18
44376: PUSH
44377: LD_EXP 18
44381: PPUSH
44382: LD_VAR 0 2
44386: PPUSH
44387: EMPTY
44388: PUSH
44389: EMPTY
44390: PUSH
44391: EMPTY
44392: LIST
44393: LIST
44394: PPUSH
44395: CALL_OW 1
44399: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
44400: LD_ADDR_EXP 19
44404: PUSH
44405: LD_EXP 19
44409: PPUSH
44410: LD_VAR 0 2
44414: PPUSH
44415: EMPTY
44416: PPUSH
44417: CALL_OW 1
44421: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
44422: LD_ADDR_EXP 46
44426: PUSH
44427: LD_EXP 46
44431: PPUSH
44432: LD_VAR 0 2
44436: PPUSH
44437: EMPTY
44438: PPUSH
44439: CALL_OW 1
44443: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
44444: LD_ADDR_EXP 20
44448: PUSH
44449: LD_EXP 20
44453: PPUSH
44454: LD_VAR 0 2
44458: PPUSH
44459: EMPTY
44460: PPUSH
44461: CALL_OW 1
44465: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
44466: LD_ADDR_EXP 21
44470: PUSH
44471: LD_EXP 21
44475: PPUSH
44476: LD_VAR 0 2
44480: PPUSH
44481: EMPTY
44482: PPUSH
44483: CALL_OW 1
44487: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
44488: LD_ADDR_EXP 22
44492: PUSH
44493: LD_EXP 22
44497: PPUSH
44498: LD_VAR 0 2
44502: PPUSH
44503: LD_EXP 14
44507: PUSH
44508: LD_VAR 0 2
44512: ARRAY
44513: PPUSH
44514: LD_INT 2
44516: PUSH
44517: LD_INT 30
44519: PUSH
44520: LD_INT 32
44522: PUSH
44523: EMPTY
44524: LIST
44525: LIST
44526: PUSH
44527: LD_INT 30
44529: PUSH
44530: LD_INT 33
44532: PUSH
44533: EMPTY
44534: LIST
44535: LIST
44536: PUSH
44537: EMPTY
44538: LIST
44539: LIST
44540: LIST
44541: PPUSH
44542: CALL_OW 72
44546: PPUSH
44547: CALL_OW 1
44551: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
44552: LD_ADDR_EXP 23
44556: PUSH
44557: LD_EXP 23
44561: PPUSH
44562: LD_VAR 0 2
44566: PPUSH
44567: LD_EXP 14
44571: PUSH
44572: LD_VAR 0 2
44576: ARRAY
44577: PPUSH
44578: LD_INT 2
44580: PUSH
44581: LD_INT 30
44583: PUSH
44584: LD_INT 32
44586: PUSH
44587: EMPTY
44588: LIST
44589: LIST
44590: PUSH
44591: LD_INT 30
44593: PUSH
44594: LD_INT 31
44596: PUSH
44597: EMPTY
44598: LIST
44599: LIST
44600: PUSH
44601: EMPTY
44602: LIST
44603: LIST
44604: LIST
44605: PUSH
44606: LD_INT 58
44608: PUSH
44609: EMPTY
44610: LIST
44611: PUSH
44612: EMPTY
44613: LIST
44614: LIST
44615: PPUSH
44616: CALL_OW 72
44620: PPUSH
44621: CALL_OW 1
44625: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
44626: LD_ADDR_EXP 24
44630: PUSH
44631: LD_EXP 24
44635: PPUSH
44636: LD_VAR 0 2
44640: PPUSH
44641: EMPTY
44642: PPUSH
44643: CALL_OW 1
44647: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
44648: LD_ADDR_EXP 28
44652: PUSH
44653: LD_EXP 28
44657: PPUSH
44658: LD_VAR 0 2
44662: PPUSH
44663: EMPTY
44664: PPUSH
44665: CALL_OW 1
44669: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
44670: LD_ADDR_EXP 27
44674: PUSH
44675: LD_EXP 27
44679: PPUSH
44680: LD_VAR 0 2
44684: PPUSH
44685: EMPTY
44686: PPUSH
44687: CALL_OW 1
44691: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
44692: LD_ADDR_EXP 29
44696: PUSH
44697: LD_EXP 29
44701: PPUSH
44702: LD_VAR 0 2
44706: PPUSH
44707: EMPTY
44708: PPUSH
44709: CALL_OW 1
44713: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
44714: LD_ADDR_EXP 30
44718: PUSH
44719: LD_EXP 30
44723: PPUSH
44724: LD_VAR 0 2
44728: PPUSH
44729: EMPTY
44730: PPUSH
44731: CALL_OW 1
44735: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
44736: LD_ADDR_EXP 31
44740: PUSH
44741: LD_EXP 31
44745: PPUSH
44746: LD_VAR 0 2
44750: PPUSH
44751: EMPTY
44752: PPUSH
44753: CALL_OW 1
44757: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
44758: LD_ADDR_EXP 32
44762: PUSH
44763: LD_EXP 32
44767: PPUSH
44768: LD_VAR 0 2
44772: PPUSH
44773: EMPTY
44774: PPUSH
44775: CALL_OW 1
44779: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
44780: LD_ADDR_EXP 33
44784: PUSH
44785: LD_EXP 33
44789: PPUSH
44790: LD_VAR 0 2
44794: PPUSH
44795: EMPTY
44796: PPUSH
44797: CALL_OW 1
44801: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
44802: LD_ADDR_EXP 34
44806: PUSH
44807: LD_EXP 34
44811: PPUSH
44812: LD_VAR 0 2
44816: PPUSH
44817: EMPTY
44818: PPUSH
44819: CALL_OW 1
44823: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
44824: LD_ADDR_EXP 35
44828: PUSH
44829: LD_EXP 35
44833: PPUSH
44834: LD_VAR 0 2
44838: PPUSH
44839: EMPTY
44840: PPUSH
44841: CALL_OW 1
44845: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
44846: LD_ADDR_EXP 36
44850: PUSH
44851: LD_EXP 36
44855: PPUSH
44856: LD_VAR 0 2
44860: PPUSH
44861: EMPTY
44862: PPUSH
44863: CALL_OW 1
44867: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
44868: LD_ADDR_EXP 25
44872: PUSH
44873: LD_EXP 25
44877: PPUSH
44878: LD_VAR 0 2
44882: PPUSH
44883: LD_INT 0
44885: PPUSH
44886: CALL_OW 1
44890: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
44891: LD_ADDR_EXP 38
44895: PUSH
44896: LD_EXP 38
44900: PPUSH
44901: LD_VAR 0 2
44905: PPUSH
44906: LD_INT 0
44908: PPUSH
44909: CALL_OW 1
44913: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
44914: LD_ADDR_EXP 26
44918: PUSH
44919: LD_EXP 26
44923: PPUSH
44924: LD_VAR 0 2
44928: PPUSH
44929: EMPTY
44930: PPUSH
44931: CALL_OW 1
44935: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
44936: LD_ADDR_EXP 37
44940: PUSH
44941: LD_EXP 37
44945: PPUSH
44946: LD_VAR 0 2
44950: PPUSH
44951: LD_INT 0
44953: PPUSH
44954: CALL_OW 1
44958: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
44959: LD_ADDR_EXP 39
44963: PUSH
44964: LD_EXP 39
44968: PPUSH
44969: LD_VAR 0 2
44973: PPUSH
44974: EMPTY
44975: PPUSH
44976: CALL_OW 1
44980: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
44981: LD_ADDR_EXP 42
44985: PUSH
44986: LD_EXP 42
44990: PPUSH
44991: LD_VAR 0 2
44995: PPUSH
44996: LD_INT 0
44998: PPUSH
44999: CALL_OW 1
45003: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
45004: LD_ADDR_EXP 43
45008: PUSH
45009: LD_EXP 43
45013: PPUSH
45014: LD_VAR 0 2
45018: PPUSH
45019: EMPTY
45020: PPUSH
45021: CALL_OW 1
45025: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
45026: LD_ADDR_EXP 44
45030: PUSH
45031: LD_EXP 44
45035: PPUSH
45036: LD_VAR 0 2
45040: PPUSH
45041: EMPTY
45042: PPUSH
45043: CALL_OW 1
45047: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
45048: LD_ADDR_EXP 45
45052: PUSH
45053: LD_EXP 45
45057: PPUSH
45058: LD_VAR 0 2
45062: PPUSH
45063: EMPTY
45064: PPUSH
45065: CALL_OW 1
45069: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
45070: LD_ADDR_EXP 47
45074: PUSH
45075: LD_EXP 47
45079: PPUSH
45080: LD_VAR 0 2
45084: PPUSH
45085: LD_EXP 14
45089: PUSH
45090: LD_VAR 0 2
45094: ARRAY
45095: PPUSH
45096: LD_INT 2
45098: PUSH
45099: LD_INT 30
45101: PUSH
45102: LD_INT 6
45104: PUSH
45105: EMPTY
45106: LIST
45107: LIST
45108: PUSH
45109: LD_INT 30
45111: PUSH
45112: LD_INT 7
45114: PUSH
45115: EMPTY
45116: LIST
45117: LIST
45118: PUSH
45119: LD_INT 30
45121: PUSH
45122: LD_INT 8
45124: PUSH
45125: EMPTY
45126: LIST
45127: LIST
45128: PUSH
45129: EMPTY
45130: LIST
45131: LIST
45132: LIST
45133: LIST
45134: PPUSH
45135: CALL_OW 72
45139: PPUSH
45140: CALL_OW 1
45144: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
45145: LD_ADDR_EXP 48
45149: PUSH
45150: LD_EXP 48
45154: PPUSH
45155: LD_VAR 0 2
45159: PPUSH
45160: EMPTY
45161: PPUSH
45162: CALL_OW 1
45166: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
45167: LD_ADDR_EXP 49
45171: PUSH
45172: LD_EXP 49
45176: PPUSH
45177: LD_VAR 0 2
45181: PPUSH
45182: EMPTY
45183: PPUSH
45184: CALL_OW 1
45188: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
45189: LD_ADDR_EXP 50
45193: PUSH
45194: LD_EXP 50
45198: PPUSH
45199: LD_VAR 0 2
45203: PPUSH
45204: EMPTY
45205: PPUSH
45206: CALL_OW 1
45210: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
45211: LD_ADDR_EXP 51
45215: PUSH
45216: LD_EXP 51
45220: PPUSH
45221: LD_VAR 0 2
45225: PPUSH
45226: EMPTY
45227: PPUSH
45228: CALL_OW 1
45232: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
45233: LD_ADDR_EXP 52
45237: PUSH
45238: LD_EXP 52
45242: PPUSH
45243: LD_VAR 0 2
45247: PPUSH
45248: EMPTY
45249: PPUSH
45250: CALL_OW 1
45254: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
45255: LD_ADDR_EXP 53
45259: PUSH
45260: LD_EXP 53
45264: PPUSH
45265: LD_VAR 0 2
45269: PPUSH
45270: EMPTY
45271: PPUSH
45272: CALL_OW 1
45276: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
45277: LD_ADDR_EXP 54
45281: PUSH
45282: LD_EXP 54
45286: PPUSH
45287: LD_VAR 0 2
45291: PPUSH
45292: EMPTY
45293: PPUSH
45294: CALL_OW 1
45298: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
45299: LD_ADDR_EXP 55
45303: PUSH
45304: LD_EXP 55
45308: PPUSH
45309: LD_VAR 0 2
45313: PPUSH
45314: EMPTY
45315: PPUSH
45316: CALL_OW 1
45320: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
45321: LD_ADDR_EXP 56
45325: PUSH
45326: LD_EXP 56
45330: PPUSH
45331: LD_VAR 0 2
45335: PPUSH
45336: LD_INT 0
45338: PPUSH
45339: CALL_OW 1
45343: ST_TO_ADDR
// end ;
45344: GO 44268
45346: POP
45347: POP
// MC_InitSides ( ) ;
45348: CALL 45634 0 0
// MC_InitResearch ( ) ;
45352: CALL 45373 0 0
// CustomInitMacro ( ) ;
45356: CALL 211 0 0
// skirmish := true ;
45360: LD_ADDR_EXP 12
45364: PUSH
45365: LD_INT 1
45367: ST_TO_ADDR
// end ;
45368: LD_VAR 0 1
45372: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
45373: LD_INT 0
45375: PPUSH
45376: PPUSH
45377: PPUSH
45378: PPUSH
45379: PPUSH
45380: PPUSH
// if not mc_bases then
45381: LD_EXP 14
45385: NOT
45386: IFFALSE 45390
// exit ;
45388: GO 45629
// for i = 1 to 8 do
45390: LD_ADDR_VAR 0 2
45394: PUSH
45395: DOUBLE
45396: LD_INT 1
45398: DEC
45399: ST_TO_ADDR
45400: LD_INT 8
45402: PUSH
45403: FOR_TO
45404: IFFALSE 45430
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
45406: LD_ADDR_EXP 41
45410: PUSH
45411: LD_EXP 41
45415: PPUSH
45416: LD_VAR 0 2
45420: PPUSH
45421: EMPTY
45422: PPUSH
45423: CALL_OW 1
45427: ST_TO_ADDR
45428: GO 45403
45430: POP
45431: POP
// tmp := [ ] ;
45432: LD_ADDR_VAR 0 5
45436: PUSH
45437: EMPTY
45438: ST_TO_ADDR
// for i = 1 to mc_sides do
45439: LD_ADDR_VAR 0 2
45443: PUSH
45444: DOUBLE
45445: LD_INT 1
45447: DEC
45448: ST_TO_ADDR
45449: LD_EXP 40
45453: PUSH
45454: FOR_TO
45455: IFFALSE 45513
// if not mc_sides [ i ] in tmp then
45457: LD_EXP 40
45461: PUSH
45462: LD_VAR 0 2
45466: ARRAY
45467: PUSH
45468: LD_VAR 0 5
45472: IN
45473: NOT
45474: IFFALSE 45511
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
45476: LD_ADDR_VAR 0 5
45480: PUSH
45481: LD_VAR 0 5
45485: PPUSH
45486: LD_VAR 0 5
45490: PUSH
45491: LD_INT 1
45493: PLUS
45494: PPUSH
45495: LD_EXP 40
45499: PUSH
45500: LD_VAR 0 2
45504: ARRAY
45505: PPUSH
45506: CALL_OW 2
45510: ST_TO_ADDR
45511: GO 45454
45513: POP
45514: POP
// if not tmp then
45515: LD_VAR 0 5
45519: NOT
45520: IFFALSE 45524
// exit ;
45522: GO 45629
// for j in tmp do
45524: LD_ADDR_VAR 0 3
45528: PUSH
45529: LD_VAR 0 5
45533: PUSH
45534: FOR_IN
45535: IFFALSE 45627
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
45537: LD_ADDR_VAR 0 6
45541: PUSH
45542: LD_INT 22
45544: PUSH
45545: LD_VAR 0 3
45549: PUSH
45550: EMPTY
45551: LIST
45552: LIST
45553: PPUSH
45554: CALL_OW 69
45558: ST_TO_ADDR
// if not un then
45559: LD_VAR 0 6
45563: NOT
45564: IFFALSE 45568
// continue ;
45566: GO 45534
// nation := GetNation ( un [ 1 ] ) ;
45568: LD_ADDR_VAR 0 4
45572: PUSH
45573: LD_VAR 0 6
45577: PUSH
45578: LD_INT 1
45580: ARRAY
45581: PPUSH
45582: CALL_OW 248
45586: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
45587: LD_ADDR_EXP 41
45591: PUSH
45592: LD_EXP 41
45596: PPUSH
45597: LD_VAR 0 3
45601: PPUSH
45602: LD_VAR 0 3
45606: PPUSH
45607: LD_VAR 0 4
45611: PPUSH
45612: LD_INT 1
45614: PPUSH
45615: CALL 4544 0 3
45619: PPUSH
45620: CALL_OW 1
45624: ST_TO_ADDR
// end ;
45625: GO 45534
45627: POP
45628: POP
// end ;
45629: LD_VAR 0 1
45633: RET
// export function MC_InitSides ( ) ; var i ; begin
45634: LD_INT 0
45636: PPUSH
45637: PPUSH
// if not mc_bases then
45638: LD_EXP 14
45642: NOT
45643: IFFALSE 45647
// exit ;
45645: GO 45721
// for i = 1 to mc_bases do
45647: LD_ADDR_VAR 0 2
45651: PUSH
45652: DOUBLE
45653: LD_INT 1
45655: DEC
45656: ST_TO_ADDR
45657: LD_EXP 14
45661: PUSH
45662: FOR_TO
45663: IFFALSE 45719
// if mc_bases [ i ] then
45665: LD_EXP 14
45669: PUSH
45670: LD_VAR 0 2
45674: ARRAY
45675: IFFALSE 45717
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
45677: LD_ADDR_EXP 40
45681: PUSH
45682: LD_EXP 40
45686: PPUSH
45687: LD_VAR 0 2
45691: PPUSH
45692: LD_EXP 14
45696: PUSH
45697: LD_VAR 0 2
45701: ARRAY
45702: PUSH
45703: LD_INT 1
45705: ARRAY
45706: PPUSH
45707: CALL_OW 255
45711: PPUSH
45712: CALL_OW 1
45716: ST_TO_ADDR
45717: GO 45662
45719: POP
45720: POP
// end ;
45721: LD_VAR 0 1
45725: RET
// every 0 0$03 trigger skirmish do
45726: LD_EXP 12
45730: IFFALSE 45884
45732: GO 45734
45734: DISABLE
// begin enable ;
45735: ENABLE
// MC_CheckBuildings ( ) ;
45736: CALL 50382 0 0
// MC_CheckPeopleLife ( ) ;
45740: CALL 50507 0 0
// RaiseSailEvent ( 100 ) ;
45744: LD_INT 100
45746: PPUSH
45747: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
45751: LD_INT 103
45753: PPUSH
45754: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
45758: LD_INT 104
45760: PPUSH
45761: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
45765: LD_INT 105
45767: PPUSH
45768: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
45772: LD_INT 106
45774: PPUSH
45775: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
45779: LD_INT 107
45781: PPUSH
45782: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
45786: LD_INT 108
45788: PPUSH
45789: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
45793: LD_INT 109
45795: PPUSH
45796: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
45800: LD_INT 110
45802: PPUSH
45803: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
45807: LD_INT 111
45809: PPUSH
45810: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
45814: LD_INT 112
45816: PPUSH
45817: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
45821: LD_INT 113
45823: PPUSH
45824: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
45828: LD_INT 120
45830: PPUSH
45831: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
45835: LD_INT 121
45837: PPUSH
45838: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
45842: LD_INT 122
45844: PPUSH
45845: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
45849: LD_INT 123
45851: PPUSH
45852: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
45856: LD_INT 124
45858: PPUSH
45859: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
45863: LD_INT 125
45865: PPUSH
45866: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
45870: LD_INT 126
45872: PPUSH
45873: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
45877: LD_INT 200
45879: PPUSH
45880: CALL_OW 427
// end ;
45884: END
// on SailEvent ( event ) do begin if event < 100 then
45885: LD_VAR 0 1
45889: PUSH
45890: LD_INT 100
45892: LESS
45893: IFFALSE 45904
// CustomEvent ( event ) ;
45895: LD_VAR 0 1
45899: PPUSH
45900: CALL 4443 0 1
// if event = 100 then
45904: LD_VAR 0 1
45908: PUSH
45909: LD_INT 100
45911: EQUAL
45912: IFFALSE 45918
// MC_ClassManager ( ) ;
45914: CALL 46310 0 0
// if event = 101 then
45918: LD_VAR 0 1
45922: PUSH
45923: LD_INT 101
45925: EQUAL
45926: IFFALSE 45932
// MC_RepairBuildings ( ) ;
45928: CALL 51092 0 0
// if event = 102 then
45932: LD_VAR 0 1
45936: PUSH
45937: LD_INT 102
45939: EQUAL
45940: IFFALSE 45946
// MC_Heal ( ) ;
45942: CALL 51977 0 0
// if event = 103 then
45946: LD_VAR 0 1
45950: PUSH
45951: LD_INT 103
45953: EQUAL
45954: IFFALSE 45960
// MC_Build ( ) ;
45956: CALL 52399 0 0
// if event = 104 then
45960: LD_VAR 0 1
45964: PUSH
45965: LD_INT 104
45967: EQUAL
45968: IFFALSE 45974
// MC_TurretWeapon ( ) ;
45970: CALL 54040 0 0
// if event = 105 then
45974: LD_VAR 0 1
45978: PUSH
45979: LD_INT 105
45981: EQUAL
45982: IFFALSE 45988
// MC_BuildUpgrade ( ) ;
45984: CALL 53591 0 0
// if event = 106 then
45988: LD_VAR 0 1
45992: PUSH
45993: LD_INT 106
45995: EQUAL
45996: IFFALSE 46002
// MC_PlantMines ( ) ;
45998: CALL 54470 0 0
// if event = 107 then
46002: LD_VAR 0 1
46006: PUSH
46007: LD_INT 107
46009: EQUAL
46010: IFFALSE 46016
// MC_CollectCrates ( ) ;
46012: CALL 55261 0 0
// if event = 108 then
46016: LD_VAR 0 1
46020: PUSH
46021: LD_INT 108
46023: EQUAL
46024: IFFALSE 46030
// MC_LinkRemoteControl ( ) ;
46026: CALL 57037 0 0
// if event = 109 then
46030: LD_VAR 0 1
46034: PUSH
46035: LD_INT 109
46037: EQUAL
46038: IFFALSE 46044
// MC_ProduceVehicle ( ) ;
46040: CALL 57218 0 0
// if event = 110 then
46044: LD_VAR 0 1
46048: PUSH
46049: LD_INT 110
46051: EQUAL
46052: IFFALSE 46058
// MC_SendAttack ( ) ;
46054: CALL 57684 0 0
// if event = 111 then
46058: LD_VAR 0 1
46062: PUSH
46063: LD_INT 111
46065: EQUAL
46066: IFFALSE 46072
// MC_Defend ( ) ;
46068: CALL 57792 0 0
// if event = 112 then
46072: LD_VAR 0 1
46076: PUSH
46077: LD_INT 112
46079: EQUAL
46080: IFFALSE 46086
// MC_Research ( ) ;
46082: CALL 58419 0 0
// if event = 113 then
46086: LD_VAR 0 1
46090: PUSH
46091: LD_INT 113
46093: EQUAL
46094: IFFALSE 46100
// MC_MinesTrigger ( ) ;
46096: CALL 59533 0 0
// if event = 120 then
46100: LD_VAR 0 1
46104: PUSH
46105: LD_INT 120
46107: EQUAL
46108: IFFALSE 46114
// MC_RepairVehicle ( ) ;
46110: CALL 59632 0 0
// if event = 121 then
46114: LD_VAR 0 1
46118: PUSH
46119: LD_INT 121
46121: EQUAL
46122: IFFALSE 46128
// MC_TameApe ( ) ;
46124: CALL 60362 0 0
// if event = 122 then
46128: LD_VAR 0 1
46132: PUSH
46133: LD_INT 122
46135: EQUAL
46136: IFFALSE 46142
// MC_ChangeApeClass ( ) ;
46138: CALL 61191 0 0
// if event = 123 then
46142: LD_VAR 0 1
46146: PUSH
46147: LD_INT 123
46149: EQUAL
46150: IFFALSE 46156
// MC_Bazooka ( ) ;
46152: CALL 61841 0 0
// if event = 124 then
46156: LD_VAR 0 1
46160: PUSH
46161: LD_INT 124
46163: EQUAL
46164: IFFALSE 46170
// MC_TeleportExit ( ) ;
46166: CALL 62039 0 0
// if event = 125 then
46170: LD_VAR 0 1
46174: PUSH
46175: LD_INT 125
46177: EQUAL
46178: IFFALSE 46184
// MC_Deposits ( ) ;
46180: CALL 62686 0 0
// if event = 126 then
46184: LD_VAR 0 1
46188: PUSH
46189: LD_INT 126
46191: EQUAL
46192: IFFALSE 46198
// MC_RemoteDriver ( ) ;
46194: CALL 63311 0 0
// if event = 200 then
46198: LD_VAR 0 1
46202: PUSH
46203: LD_INT 200
46205: EQUAL
46206: IFFALSE 46212
// MC_Idle ( ) ;
46208: CALL 65260 0 0
// end ;
46212: PPOPN 1
46214: END
// export function MC_Reset ( base , tag ) ; var i ; begin
46215: LD_INT 0
46217: PPUSH
46218: PPUSH
// if not mc_bases [ base ] or not tag then
46219: LD_EXP 14
46223: PUSH
46224: LD_VAR 0 1
46228: ARRAY
46229: NOT
46230: PUSH
46231: LD_VAR 0 2
46235: NOT
46236: OR
46237: IFFALSE 46241
// exit ;
46239: GO 46305
// for i in mc_bases [ base ] union mc_ape [ base ] do
46241: LD_ADDR_VAR 0 4
46245: PUSH
46246: LD_EXP 14
46250: PUSH
46251: LD_VAR 0 1
46255: ARRAY
46256: PUSH
46257: LD_EXP 43
46261: PUSH
46262: LD_VAR 0 1
46266: ARRAY
46267: UNION
46268: PUSH
46269: FOR_IN
46270: IFFALSE 46303
// if GetTag ( i ) = tag then
46272: LD_VAR 0 4
46276: PPUSH
46277: CALL_OW 110
46281: PUSH
46282: LD_VAR 0 2
46286: EQUAL
46287: IFFALSE 46301
// SetTag ( i , 0 ) ;
46289: LD_VAR 0 4
46293: PPUSH
46294: LD_INT 0
46296: PPUSH
46297: CALL_OW 109
46301: GO 46269
46303: POP
46304: POP
// end ;
46305: LD_VAR 0 3
46309: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
46310: LD_INT 0
46312: PPUSH
46313: PPUSH
46314: PPUSH
46315: PPUSH
46316: PPUSH
46317: PPUSH
46318: PPUSH
46319: PPUSH
// if not mc_bases then
46320: LD_EXP 14
46324: NOT
46325: IFFALSE 46329
// exit ;
46327: GO 46787
// for i = 1 to mc_bases do
46329: LD_ADDR_VAR 0 2
46333: PUSH
46334: DOUBLE
46335: LD_INT 1
46337: DEC
46338: ST_TO_ADDR
46339: LD_EXP 14
46343: PUSH
46344: FOR_TO
46345: IFFALSE 46785
// begin tmp := MC_ClassCheckReq ( i ) ;
46347: LD_ADDR_VAR 0 4
46351: PUSH
46352: LD_VAR 0 2
46356: PPUSH
46357: CALL 46792 0 1
46361: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
46362: LD_ADDR_EXP 55
46366: PUSH
46367: LD_EXP 55
46371: PPUSH
46372: LD_VAR 0 2
46376: PPUSH
46377: LD_VAR 0 4
46381: PPUSH
46382: CALL_OW 1
46386: ST_TO_ADDR
// if not tmp then
46387: LD_VAR 0 4
46391: NOT
46392: IFFALSE 46396
// continue ;
46394: GO 46344
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
46396: LD_ADDR_VAR 0 6
46400: PUSH
46401: LD_EXP 14
46405: PUSH
46406: LD_VAR 0 2
46410: ARRAY
46411: PPUSH
46412: LD_INT 2
46414: PUSH
46415: LD_INT 30
46417: PUSH
46418: LD_INT 4
46420: PUSH
46421: EMPTY
46422: LIST
46423: LIST
46424: PUSH
46425: LD_INT 30
46427: PUSH
46428: LD_INT 5
46430: PUSH
46431: EMPTY
46432: LIST
46433: LIST
46434: PUSH
46435: EMPTY
46436: LIST
46437: LIST
46438: LIST
46439: PPUSH
46440: CALL_OW 72
46444: PUSH
46445: LD_EXP 14
46449: PUSH
46450: LD_VAR 0 2
46454: ARRAY
46455: PPUSH
46456: LD_INT 2
46458: PUSH
46459: LD_INT 30
46461: PUSH
46462: LD_INT 0
46464: PUSH
46465: EMPTY
46466: LIST
46467: LIST
46468: PUSH
46469: LD_INT 30
46471: PUSH
46472: LD_INT 1
46474: PUSH
46475: EMPTY
46476: LIST
46477: LIST
46478: PUSH
46479: EMPTY
46480: LIST
46481: LIST
46482: LIST
46483: PPUSH
46484: CALL_OW 72
46488: PUSH
46489: LD_EXP 14
46493: PUSH
46494: LD_VAR 0 2
46498: ARRAY
46499: PPUSH
46500: LD_INT 30
46502: PUSH
46503: LD_INT 3
46505: PUSH
46506: EMPTY
46507: LIST
46508: LIST
46509: PPUSH
46510: CALL_OW 72
46514: PUSH
46515: LD_EXP 14
46519: PUSH
46520: LD_VAR 0 2
46524: ARRAY
46525: PPUSH
46526: LD_INT 2
46528: PUSH
46529: LD_INT 30
46531: PUSH
46532: LD_INT 6
46534: PUSH
46535: EMPTY
46536: LIST
46537: LIST
46538: PUSH
46539: LD_INT 30
46541: PUSH
46542: LD_INT 7
46544: PUSH
46545: EMPTY
46546: LIST
46547: LIST
46548: PUSH
46549: LD_INT 30
46551: PUSH
46552: LD_INT 8
46554: PUSH
46555: EMPTY
46556: LIST
46557: LIST
46558: PUSH
46559: EMPTY
46560: LIST
46561: LIST
46562: LIST
46563: LIST
46564: PPUSH
46565: CALL_OW 72
46569: PUSH
46570: EMPTY
46571: LIST
46572: LIST
46573: LIST
46574: LIST
46575: ST_TO_ADDR
// for j = 1 to 4 do
46576: LD_ADDR_VAR 0 3
46580: PUSH
46581: DOUBLE
46582: LD_INT 1
46584: DEC
46585: ST_TO_ADDR
46586: LD_INT 4
46588: PUSH
46589: FOR_TO
46590: IFFALSE 46781
// begin if not tmp [ j ] then
46592: LD_VAR 0 4
46596: PUSH
46597: LD_VAR 0 3
46601: ARRAY
46602: NOT
46603: IFFALSE 46607
// continue ;
46605: GO 46589
// for p in tmp [ j ] do
46607: LD_ADDR_VAR 0 5
46611: PUSH
46612: LD_VAR 0 4
46616: PUSH
46617: LD_VAR 0 3
46621: ARRAY
46622: PUSH
46623: FOR_IN
46624: IFFALSE 46777
// begin if not b [ j ] then
46626: LD_VAR 0 6
46630: PUSH
46631: LD_VAR 0 3
46635: ARRAY
46636: NOT
46637: IFFALSE 46641
// break ;
46639: GO 46777
// e := 0 ;
46641: LD_ADDR_VAR 0 7
46645: PUSH
46646: LD_INT 0
46648: ST_TO_ADDR
// for k in b [ j ] do
46649: LD_ADDR_VAR 0 8
46653: PUSH
46654: LD_VAR 0 6
46658: PUSH
46659: LD_VAR 0 3
46663: ARRAY
46664: PUSH
46665: FOR_IN
46666: IFFALSE 46693
// if IsNotFull ( k ) then
46668: LD_VAR 0 8
46672: PPUSH
46673: CALL 6693 0 1
46677: IFFALSE 46691
// begin e := k ;
46679: LD_ADDR_VAR 0 7
46683: PUSH
46684: LD_VAR 0 8
46688: ST_TO_ADDR
// break ;
46689: GO 46693
// end ;
46691: GO 46665
46693: POP
46694: POP
// if e and not UnitGoingToBuilding ( p , e ) then
46695: LD_VAR 0 7
46699: PUSH
46700: LD_VAR 0 5
46704: PPUSH
46705: LD_VAR 0 7
46709: PPUSH
46710: CALL 39446 0 2
46714: NOT
46715: AND
46716: IFFALSE 46775
// begin if IsInUnit ( p ) then
46718: LD_VAR 0 5
46722: PPUSH
46723: CALL_OW 310
46727: IFFALSE 46738
// ComExitBuilding ( p ) ;
46729: LD_VAR 0 5
46733: PPUSH
46734: CALL_OW 122
// ComEnterUnit ( p , e ) ;
46738: LD_VAR 0 5
46742: PPUSH
46743: LD_VAR 0 7
46747: PPUSH
46748: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
46752: LD_VAR 0 5
46756: PPUSH
46757: LD_VAR 0 3
46761: PPUSH
46762: CALL_OW 183
// AddComExitBuilding ( p ) ;
46766: LD_VAR 0 5
46770: PPUSH
46771: CALL_OW 182
// end ; end ;
46775: GO 46623
46777: POP
46778: POP
// end ;
46779: GO 46589
46781: POP
46782: POP
// end ;
46783: GO 46344
46785: POP
46786: POP
// end ;
46787: LD_VAR 0 1
46791: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
46792: LD_INT 0
46794: PPUSH
46795: PPUSH
46796: PPUSH
46797: PPUSH
46798: PPUSH
46799: PPUSH
46800: PPUSH
46801: PPUSH
46802: PPUSH
46803: PPUSH
46804: PPUSH
46805: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
46806: LD_VAR 0 1
46810: NOT
46811: PUSH
46812: LD_EXP 14
46816: PUSH
46817: LD_VAR 0 1
46821: ARRAY
46822: NOT
46823: OR
46824: PUSH
46825: LD_EXP 14
46829: PUSH
46830: LD_VAR 0 1
46834: ARRAY
46835: PPUSH
46836: LD_INT 2
46838: PUSH
46839: LD_INT 30
46841: PUSH
46842: LD_INT 0
46844: PUSH
46845: EMPTY
46846: LIST
46847: LIST
46848: PUSH
46849: LD_INT 30
46851: PUSH
46852: LD_INT 1
46854: PUSH
46855: EMPTY
46856: LIST
46857: LIST
46858: PUSH
46859: EMPTY
46860: LIST
46861: LIST
46862: LIST
46863: PPUSH
46864: CALL_OW 72
46868: NOT
46869: OR
46870: IFFALSE 46874
// exit ;
46872: GO 50377
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
46874: LD_ADDR_VAR 0 4
46878: PUSH
46879: LD_EXP 14
46883: PUSH
46884: LD_VAR 0 1
46888: ARRAY
46889: PPUSH
46890: LD_INT 2
46892: PUSH
46893: LD_INT 25
46895: PUSH
46896: LD_INT 1
46898: PUSH
46899: EMPTY
46900: LIST
46901: LIST
46902: PUSH
46903: LD_INT 25
46905: PUSH
46906: LD_INT 2
46908: PUSH
46909: EMPTY
46910: LIST
46911: LIST
46912: PUSH
46913: LD_INT 25
46915: PUSH
46916: LD_INT 3
46918: PUSH
46919: EMPTY
46920: LIST
46921: LIST
46922: PUSH
46923: LD_INT 25
46925: PUSH
46926: LD_INT 4
46928: PUSH
46929: EMPTY
46930: LIST
46931: LIST
46932: PUSH
46933: LD_INT 25
46935: PUSH
46936: LD_INT 5
46938: PUSH
46939: EMPTY
46940: LIST
46941: LIST
46942: PUSH
46943: LD_INT 25
46945: PUSH
46946: LD_INT 8
46948: PUSH
46949: EMPTY
46950: LIST
46951: LIST
46952: PUSH
46953: LD_INT 25
46955: PUSH
46956: LD_INT 9
46958: PUSH
46959: EMPTY
46960: LIST
46961: LIST
46962: PUSH
46963: EMPTY
46964: LIST
46965: LIST
46966: LIST
46967: LIST
46968: LIST
46969: LIST
46970: LIST
46971: LIST
46972: PPUSH
46973: CALL_OW 72
46977: ST_TO_ADDR
// if not tmp then
46978: LD_VAR 0 4
46982: NOT
46983: IFFALSE 46987
// exit ;
46985: GO 50377
// for i in tmp do
46987: LD_ADDR_VAR 0 3
46991: PUSH
46992: LD_VAR 0 4
46996: PUSH
46997: FOR_IN
46998: IFFALSE 47029
// if GetTag ( i ) then
47000: LD_VAR 0 3
47004: PPUSH
47005: CALL_OW 110
47009: IFFALSE 47027
// tmp := tmp diff i ;
47011: LD_ADDR_VAR 0 4
47015: PUSH
47016: LD_VAR 0 4
47020: PUSH
47021: LD_VAR 0 3
47025: DIFF
47026: ST_TO_ADDR
47027: GO 46997
47029: POP
47030: POP
// if not tmp then
47031: LD_VAR 0 4
47035: NOT
47036: IFFALSE 47040
// exit ;
47038: GO 50377
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
47040: LD_ADDR_VAR 0 5
47044: PUSH
47045: LD_EXP 14
47049: PUSH
47050: LD_VAR 0 1
47054: ARRAY
47055: PPUSH
47056: LD_INT 2
47058: PUSH
47059: LD_INT 25
47061: PUSH
47062: LD_INT 1
47064: PUSH
47065: EMPTY
47066: LIST
47067: LIST
47068: PUSH
47069: LD_INT 25
47071: PUSH
47072: LD_INT 5
47074: PUSH
47075: EMPTY
47076: LIST
47077: LIST
47078: PUSH
47079: LD_INT 25
47081: PUSH
47082: LD_INT 8
47084: PUSH
47085: EMPTY
47086: LIST
47087: LIST
47088: PUSH
47089: LD_INT 25
47091: PUSH
47092: LD_INT 9
47094: PUSH
47095: EMPTY
47096: LIST
47097: LIST
47098: PUSH
47099: EMPTY
47100: LIST
47101: LIST
47102: LIST
47103: LIST
47104: LIST
47105: PPUSH
47106: CALL_OW 72
47110: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
47111: LD_ADDR_VAR 0 6
47115: PUSH
47116: LD_EXP 14
47120: PUSH
47121: LD_VAR 0 1
47125: ARRAY
47126: PPUSH
47127: LD_INT 25
47129: PUSH
47130: LD_INT 2
47132: PUSH
47133: EMPTY
47134: LIST
47135: LIST
47136: PPUSH
47137: CALL_OW 72
47141: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
47142: LD_ADDR_VAR 0 7
47146: PUSH
47147: LD_EXP 14
47151: PUSH
47152: LD_VAR 0 1
47156: ARRAY
47157: PPUSH
47158: LD_INT 25
47160: PUSH
47161: LD_INT 3
47163: PUSH
47164: EMPTY
47165: LIST
47166: LIST
47167: PPUSH
47168: CALL_OW 72
47172: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
47173: LD_ADDR_VAR 0 8
47177: PUSH
47178: LD_EXP 14
47182: PUSH
47183: LD_VAR 0 1
47187: ARRAY
47188: PPUSH
47189: LD_INT 25
47191: PUSH
47192: LD_INT 4
47194: PUSH
47195: EMPTY
47196: LIST
47197: LIST
47198: PUSH
47199: LD_INT 24
47201: PUSH
47202: LD_INT 251
47204: PUSH
47205: EMPTY
47206: LIST
47207: LIST
47208: PUSH
47209: EMPTY
47210: LIST
47211: LIST
47212: PPUSH
47213: CALL_OW 72
47217: ST_TO_ADDR
// if mc_scan [ base ] then
47218: LD_EXP 37
47222: PUSH
47223: LD_VAR 0 1
47227: ARRAY
47228: IFFALSE 47689
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
47230: LD_ADDR_EXP 56
47234: PUSH
47235: LD_EXP 56
47239: PPUSH
47240: LD_VAR 0 1
47244: PPUSH
47245: LD_INT 4
47247: PPUSH
47248: CALL_OW 1
47252: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
47253: LD_ADDR_VAR 0 12
47257: PUSH
47258: LD_EXP 14
47262: PUSH
47263: LD_VAR 0 1
47267: ARRAY
47268: PPUSH
47269: LD_INT 2
47271: PUSH
47272: LD_INT 30
47274: PUSH
47275: LD_INT 4
47277: PUSH
47278: EMPTY
47279: LIST
47280: LIST
47281: PUSH
47282: LD_INT 30
47284: PUSH
47285: LD_INT 5
47287: PUSH
47288: EMPTY
47289: LIST
47290: LIST
47291: PUSH
47292: EMPTY
47293: LIST
47294: LIST
47295: LIST
47296: PPUSH
47297: CALL_OW 72
47301: ST_TO_ADDR
// if not b then
47302: LD_VAR 0 12
47306: NOT
47307: IFFALSE 47311
// exit ;
47309: GO 50377
// p := [ ] ;
47311: LD_ADDR_VAR 0 11
47315: PUSH
47316: EMPTY
47317: ST_TO_ADDR
// if sci >= 2 then
47318: LD_VAR 0 8
47322: PUSH
47323: LD_INT 2
47325: GREATEREQUAL
47326: IFFALSE 47357
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
47328: LD_ADDR_VAR 0 8
47332: PUSH
47333: LD_VAR 0 8
47337: PUSH
47338: LD_INT 1
47340: ARRAY
47341: PUSH
47342: LD_VAR 0 8
47346: PUSH
47347: LD_INT 2
47349: ARRAY
47350: PUSH
47351: EMPTY
47352: LIST
47353: LIST
47354: ST_TO_ADDR
47355: GO 47418
// if sci = 1 then
47357: LD_VAR 0 8
47361: PUSH
47362: LD_INT 1
47364: EQUAL
47365: IFFALSE 47386
// sci := [ sci [ 1 ] ] else
47367: LD_ADDR_VAR 0 8
47371: PUSH
47372: LD_VAR 0 8
47376: PUSH
47377: LD_INT 1
47379: ARRAY
47380: PUSH
47381: EMPTY
47382: LIST
47383: ST_TO_ADDR
47384: GO 47418
// if sci = 0 then
47386: LD_VAR 0 8
47390: PUSH
47391: LD_INT 0
47393: EQUAL
47394: IFFALSE 47418
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
47396: LD_ADDR_VAR 0 11
47400: PUSH
47401: LD_VAR 0 4
47405: PPUSH
47406: LD_INT 4
47408: PPUSH
47409: CALL 39309 0 2
47413: PUSH
47414: LD_INT 1
47416: ARRAY
47417: ST_TO_ADDR
// if eng > 4 then
47418: LD_VAR 0 6
47422: PUSH
47423: LD_INT 4
47425: GREATER
47426: IFFALSE 47472
// for i = eng downto 4 do
47428: LD_ADDR_VAR 0 3
47432: PUSH
47433: DOUBLE
47434: LD_VAR 0 6
47438: INC
47439: ST_TO_ADDR
47440: LD_INT 4
47442: PUSH
47443: FOR_DOWNTO
47444: IFFALSE 47470
// eng := eng diff eng [ i ] ;
47446: LD_ADDR_VAR 0 6
47450: PUSH
47451: LD_VAR 0 6
47455: PUSH
47456: LD_VAR 0 6
47460: PUSH
47461: LD_VAR 0 3
47465: ARRAY
47466: DIFF
47467: ST_TO_ADDR
47468: GO 47443
47470: POP
47471: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
47472: LD_ADDR_VAR 0 4
47476: PUSH
47477: LD_VAR 0 4
47481: PUSH
47482: LD_VAR 0 5
47486: PUSH
47487: LD_VAR 0 6
47491: UNION
47492: PUSH
47493: LD_VAR 0 7
47497: UNION
47498: PUSH
47499: LD_VAR 0 8
47503: UNION
47504: DIFF
47505: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
47506: LD_ADDR_VAR 0 13
47510: PUSH
47511: LD_EXP 14
47515: PUSH
47516: LD_VAR 0 1
47520: ARRAY
47521: PPUSH
47522: LD_INT 2
47524: PUSH
47525: LD_INT 30
47527: PUSH
47528: LD_INT 32
47530: PUSH
47531: EMPTY
47532: LIST
47533: LIST
47534: PUSH
47535: LD_INT 30
47537: PUSH
47538: LD_INT 31
47540: PUSH
47541: EMPTY
47542: LIST
47543: LIST
47544: PUSH
47545: EMPTY
47546: LIST
47547: LIST
47548: LIST
47549: PPUSH
47550: CALL_OW 72
47554: PUSH
47555: LD_EXP 14
47559: PUSH
47560: LD_VAR 0 1
47564: ARRAY
47565: PPUSH
47566: LD_INT 2
47568: PUSH
47569: LD_INT 30
47571: PUSH
47572: LD_INT 4
47574: PUSH
47575: EMPTY
47576: LIST
47577: LIST
47578: PUSH
47579: LD_INT 30
47581: PUSH
47582: LD_INT 5
47584: PUSH
47585: EMPTY
47586: LIST
47587: LIST
47588: PUSH
47589: EMPTY
47590: LIST
47591: LIST
47592: LIST
47593: PPUSH
47594: CALL_OW 72
47598: PUSH
47599: LD_INT 6
47601: MUL
47602: PLUS
47603: ST_TO_ADDR
// if bcount < tmp then
47604: LD_VAR 0 13
47608: PUSH
47609: LD_VAR 0 4
47613: LESS
47614: IFFALSE 47660
// for i = tmp downto bcount do
47616: LD_ADDR_VAR 0 3
47620: PUSH
47621: DOUBLE
47622: LD_VAR 0 4
47626: INC
47627: ST_TO_ADDR
47628: LD_VAR 0 13
47632: PUSH
47633: FOR_DOWNTO
47634: IFFALSE 47658
// tmp := Delete ( tmp , tmp ) ;
47636: LD_ADDR_VAR 0 4
47640: PUSH
47641: LD_VAR 0 4
47645: PPUSH
47646: LD_VAR 0 4
47650: PPUSH
47651: CALL_OW 3
47655: ST_TO_ADDR
47656: GO 47633
47658: POP
47659: POP
// result := [ tmp , 0 , 0 , p ] ;
47660: LD_ADDR_VAR 0 2
47664: PUSH
47665: LD_VAR 0 4
47669: PUSH
47670: LD_INT 0
47672: PUSH
47673: LD_INT 0
47675: PUSH
47676: LD_VAR 0 11
47680: PUSH
47681: EMPTY
47682: LIST
47683: LIST
47684: LIST
47685: LIST
47686: ST_TO_ADDR
// exit ;
47687: GO 50377
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
47689: LD_EXP 14
47693: PUSH
47694: LD_VAR 0 1
47698: ARRAY
47699: PPUSH
47700: LD_INT 2
47702: PUSH
47703: LD_INT 30
47705: PUSH
47706: LD_INT 6
47708: PUSH
47709: EMPTY
47710: LIST
47711: LIST
47712: PUSH
47713: LD_INT 30
47715: PUSH
47716: LD_INT 7
47718: PUSH
47719: EMPTY
47720: LIST
47721: LIST
47722: PUSH
47723: LD_INT 30
47725: PUSH
47726: LD_INT 8
47728: PUSH
47729: EMPTY
47730: LIST
47731: LIST
47732: PUSH
47733: EMPTY
47734: LIST
47735: LIST
47736: LIST
47737: LIST
47738: PPUSH
47739: CALL_OW 72
47743: NOT
47744: PUSH
47745: LD_EXP 14
47749: PUSH
47750: LD_VAR 0 1
47754: ARRAY
47755: PPUSH
47756: LD_INT 30
47758: PUSH
47759: LD_INT 3
47761: PUSH
47762: EMPTY
47763: LIST
47764: LIST
47765: PPUSH
47766: CALL_OW 72
47770: NOT
47771: AND
47772: IFFALSE 47844
// begin if eng = tmp then
47774: LD_VAR 0 6
47778: PUSH
47779: LD_VAR 0 4
47783: EQUAL
47784: IFFALSE 47788
// exit ;
47786: GO 50377
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
47788: LD_ADDR_EXP 56
47792: PUSH
47793: LD_EXP 56
47797: PPUSH
47798: LD_VAR 0 1
47802: PPUSH
47803: LD_INT 1
47805: PPUSH
47806: CALL_OW 1
47810: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
47811: LD_ADDR_VAR 0 2
47815: PUSH
47816: LD_INT 0
47818: PUSH
47819: LD_VAR 0 4
47823: PUSH
47824: LD_VAR 0 6
47828: DIFF
47829: PUSH
47830: LD_INT 0
47832: PUSH
47833: LD_INT 0
47835: PUSH
47836: EMPTY
47837: LIST
47838: LIST
47839: LIST
47840: LIST
47841: ST_TO_ADDR
// exit ;
47842: GO 50377
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
47844: LD_EXP 41
47848: PUSH
47849: LD_EXP 40
47853: PUSH
47854: LD_VAR 0 1
47858: ARRAY
47859: ARRAY
47860: PUSH
47861: LD_EXP 14
47865: PUSH
47866: LD_VAR 0 1
47870: ARRAY
47871: PPUSH
47872: LD_INT 2
47874: PUSH
47875: LD_INT 30
47877: PUSH
47878: LD_INT 6
47880: PUSH
47881: EMPTY
47882: LIST
47883: LIST
47884: PUSH
47885: LD_INT 30
47887: PUSH
47888: LD_INT 7
47890: PUSH
47891: EMPTY
47892: LIST
47893: LIST
47894: PUSH
47895: LD_INT 30
47897: PUSH
47898: LD_INT 8
47900: PUSH
47901: EMPTY
47902: LIST
47903: LIST
47904: PUSH
47905: EMPTY
47906: LIST
47907: LIST
47908: LIST
47909: LIST
47910: PPUSH
47911: CALL_OW 72
47915: AND
47916: PUSH
47917: LD_EXP 14
47921: PUSH
47922: LD_VAR 0 1
47926: ARRAY
47927: PPUSH
47928: LD_INT 30
47930: PUSH
47931: LD_INT 3
47933: PUSH
47934: EMPTY
47935: LIST
47936: LIST
47937: PPUSH
47938: CALL_OW 72
47942: NOT
47943: AND
47944: IFFALSE 48158
// begin if sci >= 6 then
47946: LD_VAR 0 8
47950: PUSH
47951: LD_INT 6
47953: GREATEREQUAL
47954: IFFALSE 47958
// exit ;
47956: GO 50377
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
47958: LD_ADDR_EXP 56
47962: PUSH
47963: LD_EXP 56
47967: PPUSH
47968: LD_VAR 0 1
47972: PPUSH
47973: LD_INT 2
47975: PPUSH
47976: CALL_OW 1
47980: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
47981: LD_ADDR_VAR 0 9
47985: PUSH
47986: LD_VAR 0 4
47990: PUSH
47991: LD_VAR 0 8
47995: DIFF
47996: PPUSH
47997: LD_INT 4
47999: PPUSH
48000: CALL 39309 0 2
48004: ST_TO_ADDR
// p := [ ] ;
48005: LD_ADDR_VAR 0 11
48009: PUSH
48010: EMPTY
48011: ST_TO_ADDR
// if sci < 6 and sort > 6 then
48012: LD_VAR 0 8
48016: PUSH
48017: LD_INT 6
48019: LESS
48020: PUSH
48021: LD_VAR 0 9
48025: PUSH
48026: LD_INT 6
48028: GREATER
48029: AND
48030: IFFALSE 48111
// begin for i = 1 to 6 - sci do
48032: LD_ADDR_VAR 0 3
48036: PUSH
48037: DOUBLE
48038: LD_INT 1
48040: DEC
48041: ST_TO_ADDR
48042: LD_INT 6
48044: PUSH
48045: LD_VAR 0 8
48049: MINUS
48050: PUSH
48051: FOR_TO
48052: IFFALSE 48107
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
48054: LD_ADDR_VAR 0 11
48058: PUSH
48059: LD_VAR 0 11
48063: PPUSH
48064: LD_VAR 0 11
48068: PUSH
48069: LD_INT 1
48071: PLUS
48072: PPUSH
48073: LD_VAR 0 9
48077: PUSH
48078: LD_INT 1
48080: ARRAY
48081: PPUSH
48082: CALL_OW 2
48086: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
48087: LD_ADDR_VAR 0 9
48091: PUSH
48092: LD_VAR 0 9
48096: PPUSH
48097: LD_INT 1
48099: PPUSH
48100: CALL_OW 3
48104: ST_TO_ADDR
// end ;
48105: GO 48051
48107: POP
48108: POP
// end else
48109: GO 48131
// if sort then
48111: LD_VAR 0 9
48115: IFFALSE 48131
// p := sort [ 1 ] ;
48117: LD_ADDR_VAR 0 11
48121: PUSH
48122: LD_VAR 0 9
48126: PUSH
48127: LD_INT 1
48129: ARRAY
48130: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
48131: LD_ADDR_VAR 0 2
48135: PUSH
48136: LD_INT 0
48138: PUSH
48139: LD_INT 0
48141: PUSH
48142: LD_INT 0
48144: PUSH
48145: LD_VAR 0 11
48149: PUSH
48150: EMPTY
48151: LIST
48152: LIST
48153: LIST
48154: LIST
48155: ST_TO_ADDR
// exit ;
48156: GO 50377
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
48158: LD_EXP 41
48162: PUSH
48163: LD_EXP 40
48167: PUSH
48168: LD_VAR 0 1
48172: ARRAY
48173: ARRAY
48174: PUSH
48175: LD_EXP 14
48179: PUSH
48180: LD_VAR 0 1
48184: ARRAY
48185: PPUSH
48186: LD_INT 2
48188: PUSH
48189: LD_INT 30
48191: PUSH
48192: LD_INT 6
48194: PUSH
48195: EMPTY
48196: LIST
48197: LIST
48198: PUSH
48199: LD_INT 30
48201: PUSH
48202: LD_INT 7
48204: PUSH
48205: EMPTY
48206: LIST
48207: LIST
48208: PUSH
48209: LD_INT 30
48211: PUSH
48212: LD_INT 8
48214: PUSH
48215: EMPTY
48216: LIST
48217: LIST
48218: PUSH
48219: EMPTY
48220: LIST
48221: LIST
48222: LIST
48223: LIST
48224: PPUSH
48225: CALL_OW 72
48229: AND
48230: PUSH
48231: LD_EXP 14
48235: PUSH
48236: LD_VAR 0 1
48240: ARRAY
48241: PPUSH
48242: LD_INT 30
48244: PUSH
48245: LD_INT 3
48247: PUSH
48248: EMPTY
48249: LIST
48250: LIST
48251: PPUSH
48252: CALL_OW 72
48256: AND
48257: IFFALSE 48991
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
48259: LD_ADDR_EXP 56
48263: PUSH
48264: LD_EXP 56
48268: PPUSH
48269: LD_VAR 0 1
48273: PPUSH
48274: LD_INT 3
48276: PPUSH
48277: CALL_OW 1
48281: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
48282: LD_ADDR_VAR 0 2
48286: PUSH
48287: LD_INT 0
48289: PUSH
48290: LD_INT 0
48292: PUSH
48293: LD_INT 0
48295: PUSH
48296: LD_INT 0
48298: PUSH
48299: EMPTY
48300: LIST
48301: LIST
48302: LIST
48303: LIST
48304: ST_TO_ADDR
// if not eng then
48305: LD_VAR 0 6
48309: NOT
48310: IFFALSE 48373
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
48312: LD_ADDR_VAR 0 11
48316: PUSH
48317: LD_VAR 0 4
48321: PPUSH
48322: LD_INT 2
48324: PPUSH
48325: CALL 39309 0 2
48329: PUSH
48330: LD_INT 1
48332: ARRAY
48333: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
48334: LD_ADDR_VAR 0 2
48338: PUSH
48339: LD_VAR 0 2
48343: PPUSH
48344: LD_INT 2
48346: PPUSH
48347: LD_VAR 0 11
48351: PPUSH
48352: CALL_OW 1
48356: ST_TO_ADDR
// tmp := tmp diff p ;
48357: LD_ADDR_VAR 0 4
48361: PUSH
48362: LD_VAR 0 4
48366: PUSH
48367: LD_VAR 0 11
48371: DIFF
48372: ST_TO_ADDR
// end ; if tmp and sci < 6 then
48373: LD_VAR 0 4
48377: PUSH
48378: LD_VAR 0 8
48382: PUSH
48383: LD_INT 6
48385: LESS
48386: AND
48387: IFFALSE 48575
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
48389: LD_ADDR_VAR 0 9
48393: PUSH
48394: LD_VAR 0 4
48398: PUSH
48399: LD_VAR 0 8
48403: PUSH
48404: LD_VAR 0 7
48408: UNION
48409: DIFF
48410: PPUSH
48411: LD_INT 4
48413: PPUSH
48414: CALL 39309 0 2
48418: ST_TO_ADDR
// p := [ ] ;
48419: LD_ADDR_VAR 0 11
48423: PUSH
48424: EMPTY
48425: ST_TO_ADDR
// if sort then
48426: LD_VAR 0 9
48430: IFFALSE 48546
// for i = 1 to 6 - sci do
48432: LD_ADDR_VAR 0 3
48436: PUSH
48437: DOUBLE
48438: LD_INT 1
48440: DEC
48441: ST_TO_ADDR
48442: LD_INT 6
48444: PUSH
48445: LD_VAR 0 8
48449: MINUS
48450: PUSH
48451: FOR_TO
48452: IFFALSE 48544
// begin if i = sort then
48454: LD_VAR 0 3
48458: PUSH
48459: LD_VAR 0 9
48463: EQUAL
48464: IFFALSE 48468
// break ;
48466: GO 48544
// if GetClass ( i ) = 4 then
48468: LD_VAR 0 3
48472: PPUSH
48473: CALL_OW 257
48477: PUSH
48478: LD_INT 4
48480: EQUAL
48481: IFFALSE 48485
// continue ;
48483: GO 48451
// p := Insert ( p , p + 1 , sort [ i ] ) ;
48485: LD_ADDR_VAR 0 11
48489: PUSH
48490: LD_VAR 0 11
48494: PPUSH
48495: LD_VAR 0 11
48499: PUSH
48500: LD_INT 1
48502: PLUS
48503: PPUSH
48504: LD_VAR 0 9
48508: PUSH
48509: LD_VAR 0 3
48513: ARRAY
48514: PPUSH
48515: CALL_OW 2
48519: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
48520: LD_ADDR_VAR 0 4
48524: PUSH
48525: LD_VAR 0 4
48529: PUSH
48530: LD_VAR 0 9
48534: PUSH
48535: LD_VAR 0 3
48539: ARRAY
48540: DIFF
48541: ST_TO_ADDR
// end ;
48542: GO 48451
48544: POP
48545: POP
// if p then
48546: LD_VAR 0 11
48550: IFFALSE 48575
// result := Replace ( result , 4 , p ) ;
48552: LD_ADDR_VAR 0 2
48556: PUSH
48557: LD_VAR 0 2
48561: PPUSH
48562: LD_INT 4
48564: PPUSH
48565: LD_VAR 0 11
48569: PPUSH
48570: CALL_OW 1
48574: ST_TO_ADDR
// end ; if tmp and mech < 6 then
48575: LD_VAR 0 4
48579: PUSH
48580: LD_VAR 0 7
48584: PUSH
48585: LD_INT 6
48587: LESS
48588: AND
48589: IFFALSE 48777
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
48591: LD_ADDR_VAR 0 9
48595: PUSH
48596: LD_VAR 0 4
48600: PUSH
48601: LD_VAR 0 8
48605: PUSH
48606: LD_VAR 0 7
48610: UNION
48611: DIFF
48612: PPUSH
48613: LD_INT 3
48615: PPUSH
48616: CALL 39309 0 2
48620: ST_TO_ADDR
// p := [ ] ;
48621: LD_ADDR_VAR 0 11
48625: PUSH
48626: EMPTY
48627: ST_TO_ADDR
// if sort then
48628: LD_VAR 0 9
48632: IFFALSE 48748
// for i = 1 to 6 - mech do
48634: LD_ADDR_VAR 0 3
48638: PUSH
48639: DOUBLE
48640: LD_INT 1
48642: DEC
48643: ST_TO_ADDR
48644: LD_INT 6
48646: PUSH
48647: LD_VAR 0 7
48651: MINUS
48652: PUSH
48653: FOR_TO
48654: IFFALSE 48746
// begin if i = sort then
48656: LD_VAR 0 3
48660: PUSH
48661: LD_VAR 0 9
48665: EQUAL
48666: IFFALSE 48670
// break ;
48668: GO 48746
// if GetClass ( i ) = 3 then
48670: LD_VAR 0 3
48674: PPUSH
48675: CALL_OW 257
48679: PUSH
48680: LD_INT 3
48682: EQUAL
48683: IFFALSE 48687
// continue ;
48685: GO 48653
// p := Insert ( p , p + 1 , sort [ i ] ) ;
48687: LD_ADDR_VAR 0 11
48691: PUSH
48692: LD_VAR 0 11
48696: PPUSH
48697: LD_VAR 0 11
48701: PUSH
48702: LD_INT 1
48704: PLUS
48705: PPUSH
48706: LD_VAR 0 9
48710: PUSH
48711: LD_VAR 0 3
48715: ARRAY
48716: PPUSH
48717: CALL_OW 2
48721: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
48722: LD_ADDR_VAR 0 4
48726: PUSH
48727: LD_VAR 0 4
48731: PUSH
48732: LD_VAR 0 9
48736: PUSH
48737: LD_VAR 0 3
48741: ARRAY
48742: DIFF
48743: ST_TO_ADDR
// end ;
48744: GO 48653
48746: POP
48747: POP
// if p then
48748: LD_VAR 0 11
48752: IFFALSE 48777
// result := Replace ( result , 3 , p ) ;
48754: LD_ADDR_VAR 0 2
48758: PUSH
48759: LD_VAR 0 2
48763: PPUSH
48764: LD_INT 3
48766: PPUSH
48767: LD_VAR 0 11
48771: PPUSH
48772: CALL_OW 1
48776: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
48777: LD_VAR 0 4
48781: PUSH
48782: LD_INT 6
48784: GREATER
48785: PUSH
48786: LD_VAR 0 6
48790: PUSH
48791: LD_INT 6
48793: LESS
48794: AND
48795: IFFALSE 48989
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
48797: LD_ADDR_VAR 0 9
48801: PUSH
48802: LD_VAR 0 4
48806: PUSH
48807: LD_VAR 0 8
48811: PUSH
48812: LD_VAR 0 7
48816: UNION
48817: PUSH
48818: LD_VAR 0 6
48822: UNION
48823: DIFF
48824: PPUSH
48825: LD_INT 2
48827: PPUSH
48828: CALL 39309 0 2
48832: ST_TO_ADDR
// p := [ ] ;
48833: LD_ADDR_VAR 0 11
48837: PUSH
48838: EMPTY
48839: ST_TO_ADDR
// if sort then
48840: LD_VAR 0 9
48844: IFFALSE 48960
// for i = 1 to 6 - eng do
48846: LD_ADDR_VAR 0 3
48850: PUSH
48851: DOUBLE
48852: LD_INT 1
48854: DEC
48855: ST_TO_ADDR
48856: LD_INT 6
48858: PUSH
48859: LD_VAR 0 6
48863: MINUS
48864: PUSH
48865: FOR_TO
48866: IFFALSE 48958
// begin if i = sort then
48868: LD_VAR 0 3
48872: PUSH
48873: LD_VAR 0 9
48877: EQUAL
48878: IFFALSE 48882
// break ;
48880: GO 48958
// if GetClass ( i ) = 2 then
48882: LD_VAR 0 3
48886: PPUSH
48887: CALL_OW 257
48891: PUSH
48892: LD_INT 2
48894: EQUAL
48895: IFFALSE 48899
// continue ;
48897: GO 48865
// p := Insert ( p , p + 1 , sort [ i ] ) ;
48899: LD_ADDR_VAR 0 11
48903: PUSH
48904: LD_VAR 0 11
48908: PPUSH
48909: LD_VAR 0 11
48913: PUSH
48914: LD_INT 1
48916: PLUS
48917: PPUSH
48918: LD_VAR 0 9
48922: PUSH
48923: LD_VAR 0 3
48927: ARRAY
48928: PPUSH
48929: CALL_OW 2
48933: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
48934: LD_ADDR_VAR 0 4
48938: PUSH
48939: LD_VAR 0 4
48943: PUSH
48944: LD_VAR 0 9
48948: PUSH
48949: LD_VAR 0 3
48953: ARRAY
48954: DIFF
48955: ST_TO_ADDR
// end ;
48956: GO 48865
48958: POP
48959: POP
// if p then
48960: LD_VAR 0 11
48964: IFFALSE 48989
// result := Replace ( result , 2 , p ) ;
48966: LD_ADDR_VAR 0 2
48970: PUSH
48971: LD_VAR 0 2
48975: PPUSH
48976: LD_INT 2
48978: PPUSH
48979: LD_VAR 0 11
48983: PPUSH
48984: CALL_OW 1
48988: ST_TO_ADDR
// end ; exit ;
48989: GO 50377
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
48991: LD_EXP 41
48995: PUSH
48996: LD_EXP 40
49000: PUSH
49001: LD_VAR 0 1
49005: ARRAY
49006: ARRAY
49007: NOT
49008: PUSH
49009: LD_EXP 14
49013: PUSH
49014: LD_VAR 0 1
49018: ARRAY
49019: PPUSH
49020: LD_INT 30
49022: PUSH
49023: LD_INT 3
49025: PUSH
49026: EMPTY
49027: LIST
49028: LIST
49029: PPUSH
49030: CALL_OW 72
49034: AND
49035: PUSH
49036: LD_EXP 19
49040: PUSH
49041: LD_VAR 0 1
49045: ARRAY
49046: AND
49047: IFFALSE 49655
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
49049: LD_ADDR_EXP 56
49053: PUSH
49054: LD_EXP 56
49058: PPUSH
49059: LD_VAR 0 1
49063: PPUSH
49064: LD_INT 5
49066: PPUSH
49067: CALL_OW 1
49071: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
49072: LD_ADDR_VAR 0 2
49076: PUSH
49077: LD_INT 0
49079: PUSH
49080: LD_INT 0
49082: PUSH
49083: LD_INT 0
49085: PUSH
49086: LD_INT 0
49088: PUSH
49089: EMPTY
49090: LIST
49091: LIST
49092: LIST
49093: LIST
49094: ST_TO_ADDR
// if sci > 1 then
49095: LD_VAR 0 8
49099: PUSH
49100: LD_INT 1
49102: GREATER
49103: IFFALSE 49131
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
49105: LD_ADDR_VAR 0 4
49109: PUSH
49110: LD_VAR 0 4
49114: PUSH
49115: LD_VAR 0 8
49119: PUSH
49120: LD_VAR 0 8
49124: PUSH
49125: LD_INT 1
49127: ARRAY
49128: DIFF
49129: DIFF
49130: ST_TO_ADDR
// if tmp and not sci then
49131: LD_VAR 0 4
49135: PUSH
49136: LD_VAR 0 8
49140: NOT
49141: AND
49142: IFFALSE 49211
// begin sort := SortBySkill ( tmp , 4 ) ;
49144: LD_ADDR_VAR 0 9
49148: PUSH
49149: LD_VAR 0 4
49153: PPUSH
49154: LD_INT 4
49156: PPUSH
49157: CALL 39309 0 2
49161: ST_TO_ADDR
// if sort then
49162: LD_VAR 0 9
49166: IFFALSE 49182
// p := sort [ 1 ] ;
49168: LD_ADDR_VAR 0 11
49172: PUSH
49173: LD_VAR 0 9
49177: PUSH
49178: LD_INT 1
49180: ARRAY
49181: ST_TO_ADDR
// if p then
49182: LD_VAR 0 11
49186: IFFALSE 49211
// result := Replace ( result , 4 , p ) ;
49188: LD_ADDR_VAR 0 2
49192: PUSH
49193: LD_VAR 0 2
49197: PPUSH
49198: LD_INT 4
49200: PPUSH
49201: LD_VAR 0 11
49205: PPUSH
49206: CALL_OW 1
49210: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
49211: LD_ADDR_VAR 0 4
49215: PUSH
49216: LD_VAR 0 4
49220: PUSH
49221: LD_VAR 0 7
49225: DIFF
49226: ST_TO_ADDR
// if tmp and mech < 6 then
49227: LD_VAR 0 4
49231: PUSH
49232: LD_VAR 0 7
49236: PUSH
49237: LD_INT 6
49239: LESS
49240: AND
49241: IFFALSE 49429
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
49243: LD_ADDR_VAR 0 9
49247: PUSH
49248: LD_VAR 0 4
49252: PUSH
49253: LD_VAR 0 8
49257: PUSH
49258: LD_VAR 0 7
49262: UNION
49263: DIFF
49264: PPUSH
49265: LD_INT 3
49267: PPUSH
49268: CALL 39309 0 2
49272: ST_TO_ADDR
// p := [ ] ;
49273: LD_ADDR_VAR 0 11
49277: PUSH
49278: EMPTY
49279: ST_TO_ADDR
// if sort then
49280: LD_VAR 0 9
49284: IFFALSE 49400
// for i = 1 to 6 - mech do
49286: LD_ADDR_VAR 0 3
49290: PUSH
49291: DOUBLE
49292: LD_INT 1
49294: DEC
49295: ST_TO_ADDR
49296: LD_INT 6
49298: PUSH
49299: LD_VAR 0 7
49303: MINUS
49304: PUSH
49305: FOR_TO
49306: IFFALSE 49398
// begin if i = sort then
49308: LD_VAR 0 3
49312: PUSH
49313: LD_VAR 0 9
49317: EQUAL
49318: IFFALSE 49322
// break ;
49320: GO 49398
// if GetClass ( i ) = 3 then
49322: LD_VAR 0 3
49326: PPUSH
49327: CALL_OW 257
49331: PUSH
49332: LD_INT 3
49334: EQUAL
49335: IFFALSE 49339
// continue ;
49337: GO 49305
// p := Insert ( p , p + 1 , sort [ i ] ) ;
49339: LD_ADDR_VAR 0 11
49343: PUSH
49344: LD_VAR 0 11
49348: PPUSH
49349: LD_VAR 0 11
49353: PUSH
49354: LD_INT 1
49356: PLUS
49357: PPUSH
49358: LD_VAR 0 9
49362: PUSH
49363: LD_VAR 0 3
49367: ARRAY
49368: PPUSH
49369: CALL_OW 2
49373: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
49374: LD_ADDR_VAR 0 4
49378: PUSH
49379: LD_VAR 0 4
49383: PUSH
49384: LD_VAR 0 9
49388: PUSH
49389: LD_VAR 0 3
49393: ARRAY
49394: DIFF
49395: ST_TO_ADDR
// end ;
49396: GO 49305
49398: POP
49399: POP
// if p then
49400: LD_VAR 0 11
49404: IFFALSE 49429
// result := Replace ( result , 3 , p ) ;
49406: LD_ADDR_VAR 0 2
49410: PUSH
49411: LD_VAR 0 2
49415: PPUSH
49416: LD_INT 3
49418: PPUSH
49419: LD_VAR 0 11
49423: PPUSH
49424: CALL_OW 1
49428: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
49429: LD_ADDR_VAR 0 4
49433: PUSH
49434: LD_VAR 0 4
49438: PUSH
49439: LD_VAR 0 6
49443: DIFF
49444: ST_TO_ADDR
// if tmp and eng < 6 then
49445: LD_VAR 0 4
49449: PUSH
49450: LD_VAR 0 6
49454: PUSH
49455: LD_INT 6
49457: LESS
49458: AND
49459: IFFALSE 49653
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
49461: LD_ADDR_VAR 0 9
49465: PUSH
49466: LD_VAR 0 4
49470: PUSH
49471: LD_VAR 0 8
49475: PUSH
49476: LD_VAR 0 7
49480: UNION
49481: PUSH
49482: LD_VAR 0 6
49486: UNION
49487: DIFF
49488: PPUSH
49489: LD_INT 2
49491: PPUSH
49492: CALL 39309 0 2
49496: ST_TO_ADDR
// p := [ ] ;
49497: LD_ADDR_VAR 0 11
49501: PUSH
49502: EMPTY
49503: ST_TO_ADDR
// if sort then
49504: LD_VAR 0 9
49508: IFFALSE 49624
// for i = 1 to 6 - eng do
49510: LD_ADDR_VAR 0 3
49514: PUSH
49515: DOUBLE
49516: LD_INT 1
49518: DEC
49519: ST_TO_ADDR
49520: LD_INT 6
49522: PUSH
49523: LD_VAR 0 6
49527: MINUS
49528: PUSH
49529: FOR_TO
49530: IFFALSE 49622
// begin if i = sort then
49532: LD_VAR 0 3
49536: PUSH
49537: LD_VAR 0 9
49541: EQUAL
49542: IFFALSE 49546
// break ;
49544: GO 49622
// if GetClass ( i ) = 2 then
49546: LD_VAR 0 3
49550: PPUSH
49551: CALL_OW 257
49555: PUSH
49556: LD_INT 2
49558: EQUAL
49559: IFFALSE 49563
// continue ;
49561: GO 49529
// p := Insert ( p , p + 1 , sort [ i ] ) ;
49563: LD_ADDR_VAR 0 11
49567: PUSH
49568: LD_VAR 0 11
49572: PPUSH
49573: LD_VAR 0 11
49577: PUSH
49578: LD_INT 1
49580: PLUS
49581: PPUSH
49582: LD_VAR 0 9
49586: PUSH
49587: LD_VAR 0 3
49591: ARRAY
49592: PPUSH
49593: CALL_OW 2
49597: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
49598: LD_ADDR_VAR 0 4
49602: PUSH
49603: LD_VAR 0 4
49607: PUSH
49608: LD_VAR 0 9
49612: PUSH
49613: LD_VAR 0 3
49617: ARRAY
49618: DIFF
49619: ST_TO_ADDR
// end ;
49620: GO 49529
49622: POP
49623: POP
// if p then
49624: LD_VAR 0 11
49628: IFFALSE 49653
// result := Replace ( result , 2 , p ) ;
49630: LD_ADDR_VAR 0 2
49634: PUSH
49635: LD_VAR 0 2
49639: PPUSH
49640: LD_INT 2
49642: PPUSH
49643: LD_VAR 0 11
49647: PPUSH
49648: CALL_OW 1
49652: ST_TO_ADDR
// end ; exit ;
49653: GO 50377
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
49655: LD_EXP 41
49659: PUSH
49660: LD_EXP 40
49664: PUSH
49665: LD_VAR 0 1
49669: ARRAY
49670: ARRAY
49671: NOT
49672: PUSH
49673: LD_EXP 14
49677: PUSH
49678: LD_VAR 0 1
49682: ARRAY
49683: PPUSH
49684: LD_INT 30
49686: PUSH
49687: LD_INT 3
49689: PUSH
49690: EMPTY
49691: LIST
49692: LIST
49693: PPUSH
49694: CALL_OW 72
49698: AND
49699: PUSH
49700: LD_EXP 19
49704: PUSH
49705: LD_VAR 0 1
49709: ARRAY
49710: NOT
49711: AND
49712: IFFALSE 50377
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
49714: LD_ADDR_EXP 56
49718: PUSH
49719: LD_EXP 56
49723: PPUSH
49724: LD_VAR 0 1
49728: PPUSH
49729: LD_INT 6
49731: PPUSH
49732: CALL_OW 1
49736: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
49737: LD_ADDR_VAR 0 2
49741: PUSH
49742: LD_INT 0
49744: PUSH
49745: LD_INT 0
49747: PUSH
49748: LD_INT 0
49750: PUSH
49751: LD_INT 0
49753: PUSH
49754: EMPTY
49755: LIST
49756: LIST
49757: LIST
49758: LIST
49759: ST_TO_ADDR
// if sci >= 1 then
49760: LD_VAR 0 8
49764: PUSH
49765: LD_INT 1
49767: GREATEREQUAL
49768: IFFALSE 49790
// tmp := tmp diff sci [ 1 ] ;
49770: LD_ADDR_VAR 0 4
49774: PUSH
49775: LD_VAR 0 4
49779: PUSH
49780: LD_VAR 0 8
49784: PUSH
49785: LD_INT 1
49787: ARRAY
49788: DIFF
49789: ST_TO_ADDR
// if tmp and not sci then
49790: LD_VAR 0 4
49794: PUSH
49795: LD_VAR 0 8
49799: NOT
49800: AND
49801: IFFALSE 49870
// begin sort := SortBySkill ( tmp , 4 ) ;
49803: LD_ADDR_VAR 0 9
49807: PUSH
49808: LD_VAR 0 4
49812: PPUSH
49813: LD_INT 4
49815: PPUSH
49816: CALL 39309 0 2
49820: ST_TO_ADDR
// if sort then
49821: LD_VAR 0 9
49825: IFFALSE 49841
// p := sort [ 1 ] ;
49827: LD_ADDR_VAR 0 11
49831: PUSH
49832: LD_VAR 0 9
49836: PUSH
49837: LD_INT 1
49839: ARRAY
49840: ST_TO_ADDR
// if p then
49841: LD_VAR 0 11
49845: IFFALSE 49870
// result := Replace ( result , 4 , p ) ;
49847: LD_ADDR_VAR 0 2
49851: PUSH
49852: LD_VAR 0 2
49856: PPUSH
49857: LD_INT 4
49859: PPUSH
49860: LD_VAR 0 11
49864: PPUSH
49865: CALL_OW 1
49869: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
49870: LD_ADDR_VAR 0 4
49874: PUSH
49875: LD_VAR 0 4
49879: PUSH
49880: LD_VAR 0 7
49884: DIFF
49885: ST_TO_ADDR
// if tmp and mech < 6 then
49886: LD_VAR 0 4
49890: PUSH
49891: LD_VAR 0 7
49895: PUSH
49896: LD_INT 6
49898: LESS
49899: AND
49900: IFFALSE 50082
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
49902: LD_ADDR_VAR 0 9
49906: PUSH
49907: LD_VAR 0 4
49911: PUSH
49912: LD_VAR 0 7
49916: DIFF
49917: PPUSH
49918: LD_INT 3
49920: PPUSH
49921: CALL 39309 0 2
49925: ST_TO_ADDR
// p := [ ] ;
49926: LD_ADDR_VAR 0 11
49930: PUSH
49931: EMPTY
49932: ST_TO_ADDR
// if sort then
49933: LD_VAR 0 9
49937: IFFALSE 50053
// for i = 1 to 6 - mech do
49939: LD_ADDR_VAR 0 3
49943: PUSH
49944: DOUBLE
49945: LD_INT 1
49947: DEC
49948: ST_TO_ADDR
49949: LD_INT 6
49951: PUSH
49952: LD_VAR 0 7
49956: MINUS
49957: PUSH
49958: FOR_TO
49959: IFFALSE 50051
// begin if i = sort then
49961: LD_VAR 0 3
49965: PUSH
49966: LD_VAR 0 9
49970: EQUAL
49971: IFFALSE 49975
// break ;
49973: GO 50051
// if GetClass ( i ) = 3 then
49975: LD_VAR 0 3
49979: PPUSH
49980: CALL_OW 257
49984: PUSH
49985: LD_INT 3
49987: EQUAL
49988: IFFALSE 49992
// continue ;
49990: GO 49958
// p := Insert ( p , p + 1 , sort [ i ] ) ;
49992: LD_ADDR_VAR 0 11
49996: PUSH
49997: LD_VAR 0 11
50001: PPUSH
50002: LD_VAR 0 11
50006: PUSH
50007: LD_INT 1
50009: PLUS
50010: PPUSH
50011: LD_VAR 0 9
50015: PUSH
50016: LD_VAR 0 3
50020: ARRAY
50021: PPUSH
50022: CALL_OW 2
50026: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
50027: LD_ADDR_VAR 0 4
50031: PUSH
50032: LD_VAR 0 4
50036: PUSH
50037: LD_VAR 0 9
50041: PUSH
50042: LD_VAR 0 3
50046: ARRAY
50047: DIFF
50048: ST_TO_ADDR
// end ;
50049: GO 49958
50051: POP
50052: POP
// if p then
50053: LD_VAR 0 11
50057: IFFALSE 50082
// result := Replace ( result , 3 , p ) ;
50059: LD_ADDR_VAR 0 2
50063: PUSH
50064: LD_VAR 0 2
50068: PPUSH
50069: LD_INT 3
50071: PPUSH
50072: LD_VAR 0 11
50076: PPUSH
50077: CALL_OW 1
50081: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
50082: LD_ADDR_VAR 0 4
50086: PUSH
50087: LD_VAR 0 4
50091: PUSH
50092: LD_VAR 0 6
50096: DIFF
50097: ST_TO_ADDR
// if tmp and eng < 4 then
50098: LD_VAR 0 4
50102: PUSH
50103: LD_VAR 0 6
50107: PUSH
50108: LD_INT 4
50110: LESS
50111: AND
50112: IFFALSE 50302
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
50114: LD_ADDR_VAR 0 9
50118: PUSH
50119: LD_VAR 0 4
50123: PUSH
50124: LD_VAR 0 7
50128: PUSH
50129: LD_VAR 0 6
50133: UNION
50134: DIFF
50135: PPUSH
50136: LD_INT 2
50138: PPUSH
50139: CALL 39309 0 2
50143: ST_TO_ADDR
// p := [ ] ;
50144: LD_ADDR_VAR 0 11
50148: PUSH
50149: EMPTY
50150: ST_TO_ADDR
// if sort then
50151: LD_VAR 0 9
50155: IFFALSE 50271
// for i = 1 to 4 - eng do
50157: LD_ADDR_VAR 0 3
50161: PUSH
50162: DOUBLE
50163: LD_INT 1
50165: DEC
50166: ST_TO_ADDR
50167: LD_INT 4
50169: PUSH
50170: LD_VAR 0 6
50174: MINUS
50175: PUSH
50176: FOR_TO
50177: IFFALSE 50269
// begin if i = sort then
50179: LD_VAR 0 3
50183: PUSH
50184: LD_VAR 0 9
50188: EQUAL
50189: IFFALSE 50193
// break ;
50191: GO 50269
// if GetClass ( i ) = 2 then
50193: LD_VAR 0 3
50197: PPUSH
50198: CALL_OW 257
50202: PUSH
50203: LD_INT 2
50205: EQUAL
50206: IFFALSE 50210
// continue ;
50208: GO 50176
// p := Insert ( p , p + 1 , sort [ i ] ) ;
50210: LD_ADDR_VAR 0 11
50214: PUSH
50215: LD_VAR 0 11
50219: PPUSH
50220: LD_VAR 0 11
50224: PUSH
50225: LD_INT 1
50227: PLUS
50228: PPUSH
50229: LD_VAR 0 9
50233: PUSH
50234: LD_VAR 0 3
50238: ARRAY
50239: PPUSH
50240: CALL_OW 2
50244: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
50245: LD_ADDR_VAR 0 4
50249: PUSH
50250: LD_VAR 0 4
50254: PUSH
50255: LD_VAR 0 9
50259: PUSH
50260: LD_VAR 0 3
50264: ARRAY
50265: DIFF
50266: ST_TO_ADDR
// end ;
50267: GO 50176
50269: POP
50270: POP
// if p then
50271: LD_VAR 0 11
50275: IFFALSE 50300
// result := Replace ( result , 2 , p ) ;
50277: LD_ADDR_VAR 0 2
50281: PUSH
50282: LD_VAR 0 2
50286: PPUSH
50287: LD_INT 2
50289: PPUSH
50290: LD_VAR 0 11
50294: PPUSH
50295: CALL_OW 1
50299: ST_TO_ADDR
// end else
50300: GO 50346
// for i = eng downto 5 do
50302: LD_ADDR_VAR 0 3
50306: PUSH
50307: DOUBLE
50308: LD_VAR 0 6
50312: INC
50313: ST_TO_ADDR
50314: LD_INT 5
50316: PUSH
50317: FOR_DOWNTO
50318: IFFALSE 50344
// tmp := tmp union eng [ i ] ;
50320: LD_ADDR_VAR 0 4
50324: PUSH
50325: LD_VAR 0 4
50329: PUSH
50330: LD_VAR 0 6
50334: PUSH
50335: LD_VAR 0 3
50339: ARRAY
50340: UNION
50341: ST_TO_ADDR
50342: GO 50317
50344: POP
50345: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
50346: LD_ADDR_VAR 0 2
50350: PUSH
50351: LD_VAR 0 2
50355: PPUSH
50356: LD_INT 1
50358: PPUSH
50359: LD_VAR 0 4
50363: PUSH
50364: LD_VAR 0 5
50368: DIFF
50369: PPUSH
50370: CALL_OW 1
50374: ST_TO_ADDR
// exit ;
50375: GO 50377
// end ; end ;
50377: LD_VAR 0 2
50381: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
50382: LD_INT 0
50384: PPUSH
50385: PPUSH
50386: PPUSH
// if not mc_bases then
50387: LD_EXP 14
50391: NOT
50392: IFFALSE 50396
// exit ;
50394: GO 50502
// for i = 1 to mc_bases do
50396: LD_ADDR_VAR 0 2
50400: PUSH
50401: DOUBLE
50402: LD_INT 1
50404: DEC
50405: ST_TO_ADDR
50406: LD_EXP 14
50410: PUSH
50411: FOR_TO
50412: IFFALSE 50493
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
50414: LD_ADDR_VAR 0 3
50418: PUSH
50419: LD_EXP 14
50423: PUSH
50424: LD_VAR 0 2
50428: ARRAY
50429: PPUSH
50430: LD_INT 21
50432: PUSH
50433: LD_INT 3
50435: PUSH
50436: EMPTY
50437: LIST
50438: LIST
50439: PUSH
50440: LD_INT 3
50442: PUSH
50443: LD_INT 24
50445: PUSH
50446: LD_INT 1000
50448: PUSH
50449: EMPTY
50450: LIST
50451: LIST
50452: PUSH
50453: EMPTY
50454: LIST
50455: LIST
50456: PUSH
50457: EMPTY
50458: LIST
50459: LIST
50460: PPUSH
50461: CALL_OW 72
50465: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
50466: LD_ADDR_EXP 15
50470: PUSH
50471: LD_EXP 15
50475: PPUSH
50476: LD_VAR 0 2
50480: PPUSH
50481: LD_VAR 0 3
50485: PPUSH
50486: CALL_OW 1
50490: ST_TO_ADDR
// end ;
50491: GO 50411
50493: POP
50494: POP
// RaiseSailEvent ( 101 ) ;
50495: LD_INT 101
50497: PPUSH
50498: CALL_OW 427
// end ;
50502: LD_VAR 0 1
50506: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
50507: LD_INT 0
50509: PPUSH
50510: PPUSH
50511: PPUSH
50512: PPUSH
50513: PPUSH
50514: PPUSH
50515: PPUSH
// if not mc_bases then
50516: LD_EXP 14
50520: NOT
50521: IFFALSE 50525
// exit ;
50523: GO 51087
// for i = 1 to mc_bases do
50525: LD_ADDR_VAR 0 2
50529: PUSH
50530: DOUBLE
50531: LD_INT 1
50533: DEC
50534: ST_TO_ADDR
50535: LD_EXP 14
50539: PUSH
50540: FOR_TO
50541: IFFALSE 51078
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
50543: LD_ADDR_VAR 0 5
50547: PUSH
50548: LD_EXP 14
50552: PUSH
50553: LD_VAR 0 2
50557: ARRAY
50558: PUSH
50559: LD_EXP 43
50563: PUSH
50564: LD_VAR 0 2
50568: ARRAY
50569: UNION
50570: PPUSH
50571: LD_INT 21
50573: PUSH
50574: LD_INT 1
50576: PUSH
50577: EMPTY
50578: LIST
50579: LIST
50580: PUSH
50581: LD_INT 1
50583: PUSH
50584: LD_INT 3
50586: PUSH
50587: LD_INT 54
50589: PUSH
50590: EMPTY
50591: LIST
50592: PUSH
50593: EMPTY
50594: LIST
50595: LIST
50596: PUSH
50597: LD_INT 3
50599: PUSH
50600: LD_INT 24
50602: PUSH
50603: LD_INT 1000
50605: PUSH
50606: EMPTY
50607: LIST
50608: LIST
50609: PUSH
50610: EMPTY
50611: LIST
50612: LIST
50613: PUSH
50614: EMPTY
50615: LIST
50616: LIST
50617: LIST
50618: PUSH
50619: EMPTY
50620: LIST
50621: LIST
50622: PPUSH
50623: CALL_OW 72
50627: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
50628: LD_ADDR_VAR 0 6
50632: PUSH
50633: LD_EXP 14
50637: PUSH
50638: LD_VAR 0 2
50642: ARRAY
50643: PPUSH
50644: LD_INT 21
50646: PUSH
50647: LD_INT 1
50649: PUSH
50650: EMPTY
50651: LIST
50652: LIST
50653: PUSH
50654: LD_INT 1
50656: PUSH
50657: LD_INT 3
50659: PUSH
50660: LD_INT 54
50662: PUSH
50663: EMPTY
50664: LIST
50665: PUSH
50666: EMPTY
50667: LIST
50668: LIST
50669: PUSH
50670: LD_INT 3
50672: PUSH
50673: LD_INT 24
50675: PUSH
50676: LD_INT 250
50678: PUSH
50679: EMPTY
50680: LIST
50681: LIST
50682: PUSH
50683: EMPTY
50684: LIST
50685: LIST
50686: PUSH
50687: EMPTY
50688: LIST
50689: LIST
50690: LIST
50691: PUSH
50692: EMPTY
50693: LIST
50694: LIST
50695: PPUSH
50696: CALL_OW 72
50700: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
50701: LD_ADDR_VAR 0 7
50705: PUSH
50706: LD_VAR 0 5
50710: PUSH
50711: LD_VAR 0 6
50715: DIFF
50716: ST_TO_ADDR
// if not need_heal_1 then
50717: LD_VAR 0 6
50721: NOT
50722: IFFALSE 50755
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
50724: LD_ADDR_EXP 17
50728: PUSH
50729: LD_EXP 17
50733: PPUSH
50734: LD_VAR 0 2
50738: PUSH
50739: LD_INT 1
50741: PUSH
50742: EMPTY
50743: LIST
50744: LIST
50745: PPUSH
50746: EMPTY
50747: PPUSH
50748: CALL 9427 0 3
50752: ST_TO_ADDR
50753: GO 50825
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
50755: LD_ADDR_EXP 17
50759: PUSH
50760: LD_EXP 17
50764: PPUSH
50765: LD_VAR 0 2
50769: PUSH
50770: LD_INT 1
50772: PUSH
50773: EMPTY
50774: LIST
50775: LIST
50776: PPUSH
50777: LD_EXP 17
50781: PUSH
50782: LD_VAR 0 2
50786: ARRAY
50787: PUSH
50788: LD_INT 1
50790: ARRAY
50791: PPUSH
50792: LD_INT 3
50794: PUSH
50795: LD_INT 24
50797: PUSH
50798: LD_INT 1000
50800: PUSH
50801: EMPTY
50802: LIST
50803: LIST
50804: PUSH
50805: EMPTY
50806: LIST
50807: LIST
50808: PPUSH
50809: CALL_OW 72
50813: PUSH
50814: LD_VAR 0 6
50818: UNION
50819: PPUSH
50820: CALL 9427 0 3
50824: ST_TO_ADDR
// if not need_heal_2 then
50825: LD_VAR 0 7
50829: NOT
50830: IFFALSE 50863
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
50832: LD_ADDR_EXP 17
50836: PUSH
50837: LD_EXP 17
50841: PPUSH
50842: LD_VAR 0 2
50846: PUSH
50847: LD_INT 2
50849: PUSH
50850: EMPTY
50851: LIST
50852: LIST
50853: PPUSH
50854: EMPTY
50855: PPUSH
50856: CALL 9427 0 3
50860: ST_TO_ADDR
50861: GO 50895
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
50863: LD_ADDR_EXP 17
50867: PUSH
50868: LD_EXP 17
50872: PPUSH
50873: LD_VAR 0 2
50877: PUSH
50878: LD_INT 2
50880: PUSH
50881: EMPTY
50882: LIST
50883: LIST
50884: PPUSH
50885: LD_VAR 0 7
50889: PPUSH
50890: CALL 9427 0 3
50894: ST_TO_ADDR
// if need_heal_2 then
50895: LD_VAR 0 7
50899: IFFALSE 51060
// for j in need_heal_2 do
50901: LD_ADDR_VAR 0 3
50905: PUSH
50906: LD_VAR 0 7
50910: PUSH
50911: FOR_IN
50912: IFFALSE 51058
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
50914: LD_ADDR_VAR 0 5
50918: PUSH
50919: LD_EXP 14
50923: PUSH
50924: LD_VAR 0 2
50928: ARRAY
50929: PPUSH
50930: LD_INT 2
50932: PUSH
50933: LD_INT 30
50935: PUSH
50936: LD_INT 6
50938: PUSH
50939: EMPTY
50940: LIST
50941: LIST
50942: PUSH
50943: LD_INT 30
50945: PUSH
50946: LD_INT 7
50948: PUSH
50949: EMPTY
50950: LIST
50951: LIST
50952: PUSH
50953: LD_INT 30
50955: PUSH
50956: LD_INT 8
50958: PUSH
50959: EMPTY
50960: LIST
50961: LIST
50962: PUSH
50963: LD_INT 30
50965: PUSH
50966: LD_INT 0
50968: PUSH
50969: EMPTY
50970: LIST
50971: LIST
50972: PUSH
50973: LD_INT 30
50975: PUSH
50976: LD_INT 1
50978: PUSH
50979: EMPTY
50980: LIST
50981: LIST
50982: PUSH
50983: EMPTY
50984: LIST
50985: LIST
50986: LIST
50987: LIST
50988: LIST
50989: LIST
50990: PPUSH
50991: CALL_OW 72
50995: ST_TO_ADDR
// if tmp then
50996: LD_VAR 0 5
51000: IFFALSE 51056
// begin k := NearestUnitToUnit ( tmp , j ) ;
51002: LD_ADDR_VAR 0 4
51006: PUSH
51007: LD_VAR 0 5
51011: PPUSH
51012: LD_VAR 0 3
51016: PPUSH
51017: CALL_OW 74
51021: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
51022: LD_VAR 0 3
51026: PPUSH
51027: LD_VAR 0 4
51031: PPUSH
51032: CALL_OW 296
51036: PUSH
51037: LD_INT 5
51039: GREATER
51040: IFFALSE 51056
// ComMoveToNearbyEntrance ( j , k ) ;
51042: LD_VAR 0 3
51046: PPUSH
51047: LD_VAR 0 4
51051: PPUSH
51052: CALL 41670 0 2
// end ; end ;
51056: GO 50911
51058: POP
51059: POP
// if not need_heal_1 and not need_heal_2 then
51060: LD_VAR 0 6
51064: NOT
51065: PUSH
51066: LD_VAR 0 7
51070: NOT
51071: AND
51072: IFFALSE 51076
// continue ;
51074: GO 50540
// end ;
51076: GO 50540
51078: POP
51079: POP
// RaiseSailEvent ( 102 ) ;
51080: LD_INT 102
51082: PPUSH
51083: CALL_OW 427
// end ;
51087: LD_VAR 0 1
51091: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
51092: LD_INT 0
51094: PPUSH
51095: PPUSH
51096: PPUSH
51097: PPUSH
51098: PPUSH
51099: PPUSH
51100: PPUSH
51101: PPUSH
// if not mc_bases then
51102: LD_EXP 14
51106: NOT
51107: IFFALSE 51111
// exit ;
51109: GO 51972
// for i = 1 to mc_bases do
51111: LD_ADDR_VAR 0 2
51115: PUSH
51116: DOUBLE
51117: LD_INT 1
51119: DEC
51120: ST_TO_ADDR
51121: LD_EXP 14
51125: PUSH
51126: FOR_TO
51127: IFFALSE 51970
// begin if not mc_building_need_repair [ i ] then
51129: LD_EXP 15
51133: PUSH
51134: LD_VAR 0 2
51138: ARRAY
51139: NOT
51140: IFFALSE 51327
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
51142: LD_ADDR_VAR 0 6
51146: PUSH
51147: LD_EXP 33
51151: PUSH
51152: LD_VAR 0 2
51156: ARRAY
51157: PPUSH
51158: LD_INT 3
51160: PUSH
51161: LD_INT 24
51163: PUSH
51164: LD_INT 1000
51166: PUSH
51167: EMPTY
51168: LIST
51169: LIST
51170: PUSH
51171: EMPTY
51172: LIST
51173: LIST
51174: PUSH
51175: LD_INT 2
51177: PUSH
51178: LD_INT 34
51180: PUSH
51181: LD_INT 13
51183: PUSH
51184: EMPTY
51185: LIST
51186: LIST
51187: PUSH
51188: LD_INT 34
51190: PUSH
51191: LD_INT 52
51193: PUSH
51194: EMPTY
51195: LIST
51196: LIST
51197: PUSH
51198: LD_INT 34
51200: PUSH
51201: LD_EXP 63
51205: PUSH
51206: EMPTY
51207: LIST
51208: LIST
51209: PUSH
51210: EMPTY
51211: LIST
51212: LIST
51213: LIST
51214: LIST
51215: PUSH
51216: EMPTY
51217: LIST
51218: LIST
51219: PPUSH
51220: CALL_OW 72
51224: ST_TO_ADDR
// if cranes then
51225: LD_VAR 0 6
51229: IFFALSE 51291
// for j in cranes do
51231: LD_ADDR_VAR 0 3
51235: PUSH
51236: LD_VAR 0 6
51240: PUSH
51241: FOR_IN
51242: IFFALSE 51289
// if not IsInArea ( j , mc_parking [ i ] ) then
51244: LD_VAR 0 3
51248: PPUSH
51249: LD_EXP 38
51253: PUSH
51254: LD_VAR 0 2
51258: ARRAY
51259: PPUSH
51260: CALL_OW 308
51264: NOT
51265: IFFALSE 51287
// ComMoveToArea ( j , mc_parking [ i ] ) ;
51267: LD_VAR 0 3
51271: PPUSH
51272: LD_EXP 38
51276: PUSH
51277: LD_VAR 0 2
51281: ARRAY
51282: PPUSH
51283: CALL_OW 113
51287: GO 51241
51289: POP
51290: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
51291: LD_ADDR_EXP 16
51295: PUSH
51296: LD_EXP 16
51300: PPUSH
51301: LD_VAR 0 2
51305: PPUSH
51306: EMPTY
51307: PPUSH
51308: CALL_OW 1
51312: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
51313: LD_VAR 0 2
51317: PPUSH
51318: LD_INT 101
51320: PPUSH
51321: CALL 46215 0 2
// continue ;
51325: GO 51126
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
51327: LD_ADDR_EXP 20
51331: PUSH
51332: LD_EXP 20
51336: PPUSH
51337: LD_VAR 0 2
51341: PPUSH
51342: EMPTY
51343: PPUSH
51344: CALL_OW 1
51348: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
51349: LD_VAR 0 2
51353: PPUSH
51354: LD_INT 103
51356: PPUSH
51357: CALL 46215 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
51361: LD_ADDR_VAR 0 5
51365: PUSH
51366: LD_EXP 14
51370: PUSH
51371: LD_VAR 0 2
51375: ARRAY
51376: PUSH
51377: LD_EXP 43
51381: PUSH
51382: LD_VAR 0 2
51386: ARRAY
51387: UNION
51388: PPUSH
51389: LD_INT 2
51391: PUSH
51392: LD_INT 25
51394: PUSH
51395: LD_INT 2
51397: PUSH
51398: EMPTY
51399: LIST
51400: LIST
51401: PUSH
51402: LD_INT 25
51404: PUSH
51405: LD_INT 16
51407: PUSH
51408: EMPTY
51409: LIST
51410: LIST
51411: PUSH
51412: EMPTY
51413: LIST
51414: LIST
51415: LIST
51416: PUSH
51417: EMPTY
51418: LIST
51419: PPUSH
51420: CALL_OW 72
51424: PUSH
51425: LD_EXP 17
51429: PUSH
51430: LD_VAR 0 2
51434: ARRAY
51435: PUSH
51436: LD_INT 1
51438: ARRAY
51439: PUSH
51440: LD_EXP 17
51444: PUSH
51445: LD_VAR 0 2
51449: ARRAY
51450: PUSH
51451: LD_INT 2
51453: ARRAY
51454: UNION
51455: DIFF
51456: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
51457: LD_ADDR_VAR 0 6
51461: PUSH
51462: LD_EXP 33
51466: PUSH
51467: LD_VAR 0 2
51471: ARRAY
51472: PPUSH
51473: LD_INT 2
51475: PUSH
51476: LD_INT 34
51478: PUSH
51479: LD_INT 13
51481: PUSH
51482: EMPTY
51483: LIST
51484: LIST
51485: PUSH
51486: LD_INT 34
51488: PUSH
51489: LD_INT 52
51491: PUSH
51492: EMPTY
51493: LIST
51494: LIST
51495: PUSH
51496: LD_INT 34
51498: PUSH
51499: LD_EXP 63
51503: PUSH
51504: EMPTY
51505: LIST
51506: LIST
51507: PUSH
51508: EMPTY
51509: LIST
51510: LIST
51511: LIST
51512: LIST
51513: PPUSH
51514: CALL_OW 72
51518: ST_TO_ADDR
// if cranes then
51519: LD_VAR 0 6
51523: IFFALSE 51659
// begin for j in cranes do
51525: LD_ADDR_VAR 0 3
51529: PUSH
51530: LD_VAR 0 6
51534: PUSH
51535: FOR_IN
51536: IFFALSE 51657
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
51538: LD_VAR 0 3
51542: PPUSH
51543: CALL_OW 256
51547: PUSH
51548: LD_INT 1000
51550: EQUAL
51551: PUSH
51552: LD_VAR 0 3
51556: PPUSH
51557: CALL_OW 314
51561: NOT
51562: AND
51563: IFFALSE 51597
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
51565: LD_VAR 0 3
51569: PPUSH
51570: LD_EXP 15
51574: PUSH
51575: LD_VAR 0 2
51579: ARRAY
51580: PPUSH
51581: LD_VAR 0 3
51585: PPUSH
51586: CALL_OW 74
51590: PPUSH
51591: CALL_OW 130
51595: GO 51655
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
51597: LD_VAR 0 3
51601: PPUSH
51602: CALL_OW 256
51606: PUSH
51607: LD_INT 500
51609: LESS
51610: PUSH
51611: LD_VAR 0 3
51615: PPUSH
51616: LD_EXP 38
51620: PUSH
51621: LD_VAR 0 2
51625: ARRAY
51626: PPUSH
51627: CALL_OW 308
51631: NOT
51632: AND
51633: IFFALSE 51655
// ComMoveToArea ( j , mc_parking [ i ] ) ;
51635: LD_VAR 0 3
51639: PPUSH
51640: LD_EXP 38
51644: PUSH
51645: LD_VAR 0 2
51649: ARRAY
51650: PPUSH
51651: CALL_OW 113
// end ;
51655: GO 51535
51657: POP
51658: POP
// end ; if tmp > 3 then
51659: LD_VAR 0 5
51663: PUSH
51664: LD_INT 3
51666: GREATER
51667: IFFALSE 51687
// tmp := ShrinkArray ( tmp , 4 ) ;
51669: LD_ADDR_VAR 0 5
51673: PUSH
51674: LD_VAR 0 5
51678: PPUSH
51679: LD_INT 4
51681: PPUSH
51682: CALL 41118 0 2
51686: ST_TO_ADDR
// if not tmp then
51687: LD_VAR 0 5
51691: NOT
51692: IFFALSE 51696
// continue ;
51694: GO 51126
// for j in tmp do
51696: LD_ADDR_VAR 0 3
51700: PUSH
51701: LD_VAR 0 5
51705: PUSH
51706: FOR_IN
51707: IFFALSE 51966
// begin if IsInUnit ( j ) then
51709: LD_VAR 0 3
51713: PPUSH
51714: CALL_OW 310
51718: IFFALSE 51729
// ComExitBuilding ( j ) ;
51720: LD_VAR 0 3
51724: PPUSH
51725: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
51729: LD_VAR 0 3
51733: PUSH
51734: LD_EXP 16
51738: PUSH
51739: LD_VAR 0 2
51743: ARRAY
51744: IN
51745: NOT
51746: IFFALSE 51804
// begin SetTag ( j , 101 ) ;
51748: LD_VAR 0 3
51752: PPUSH
51753: LD_INT 101
51755: PPUSH
51756: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
51760: LD_ADDR_EXP 16
51764: PUSH
51765: LD_EXP 16
51769: PPUSH
51770: LD_VAR 0 2
51774: PUSH
51775: LD_EXP 16
51779: PUSH
51780: LD_VAR 0 2
51784: ARRAY
51785: PUSH
51786: LD_INT 1
51788: PLUS
51789: PUSH
51790: EMPTY
51791: LIST
51792: LIST
51793: PPUSH
51794: LD_VAR 0 3
51798: PPUSH
51799: CALL 9427 0 3
51803: ST_TO_ADDR
// end ; wait ( 1 ) ;
51804: LD_INT 1
51806: PPUSH
51807: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
51811: LD_ADDR_VAR 0 7
51815: PUSH
51816: LD_EXP 15
51820: PUSH
51821: LD_VAR 0 2
51825: ARRAY
51826: ST_TO_ADDR
// if mc_scan [ i ] then
51827: LD_EXP 37
51831: PUSH
51832: LD_VAR 0 2
51836: ARRAY
51837: IFFALSE 51899
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
51839: LD_ADDR_VAR 0 7
51843: PUSH
51844: LD_EXP 15
51848: PUSH
51849: LD_VAR 0 2
51853: ARRAY
51854: PPUSH
51855: LD_INT 3
51857: PUSH
51858: LD_INT 30
51860: PUSH
51861: LD_INT 32
51863: PUSH
51864: EMPTY
51865: LIST
51866: LIST
51867: PUSH
51868: LD_INT 30
51870: PUSH
51871: LD_INT 33
51873: PUSH
51874: EMPTY
51875: LIST
51876: LIST
51877: PUSH
51878: LD_INT 30
51880: PUSH
51881: LD_INT 31
51883: PUSH
51884: EMPTY
51885: LIST
51886: LIST
51887: PUSH
51888: EMPTY
51889: LIST
51890: LIST
51891: LIST
51892: LIST
51893: PPUSH
51894: CALL_OW 72
51898: ST_TO_ADDR
// if not to_repair_tmp then
51899: LD_VAR 0 7
51903: NOT
51904: IFFALSE 51908
// continue ;
51906: GO 51706
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
51908: LD_ADDR_VAR 0 8
51912: PUSH
51913: LD_VAR 0 7
51917: PPUSH
51918: LD_VAR 0 3
51922: PPUSH
51923: CALL_OW 74
51927: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
51928: LD_VAR 0 8
51932: PPUSH
51933: LD_INT 16
51935: PPUSH
51936: CALL 12020 0 2
51940: PUSH
51941: LD_INT 4
51943: ARRAY
51944: PUSH
51945: LD_INT 10
51947: LESS
51948: IFFALSE 51964
// ComRepairBuilding ( j , to_repair ) ;
51950: LD_VAR 0 3
51954: PPUSH
51955: LD_VAR 0 8
51959: PPUSH
51960: CALL_OW 130
// end ;
51964: GO 51706
51966: POP
51967: POP
// end ;
51968: GO 51126
51970: POP
51971: POP
// end ;
51972: LD_VAR 0 1
51976: RET
// export function MC_Heal ; var i , j , tmp ; begin
51977: LD_INT 0
51979: PPUSH
51980: PPUSH
51981: PPUSH
51982: PPUSH
// if not mc_bases then
51983: LD_EXP 14
51987: NOT
51988: IFFALSE 51992
// exit ;
51990: GO 52394
// for i = 1 to mc_bases do
51992: LD_ADDR_VAR 0 2
51996: PUSH
51997: DOUBLE
51998: LD_INT 1
52000: DEC
52001: ST_TO_ADDR
52002: LD_EXP 14
52006: PUSH
52007: FOR_TO
52008: IFFALSE 52392
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
52010: LD_EXP 17
52014: PUSH
52015: LD_VAR 0 2
52019: ARRAY
52020: PUSH
52021: LD_INT 1
52023: ARRAY
52024: NOT
52025: PUSH
52026: LD_EXP 17
52030: PUSH
52031: LD_VAR 0 2
52035: ARRAY
52036: PUSH
52037: LD_INT 2
52039: ARRAY
52040: NOT
52041: AND
52042: IFFALSE 52080
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
52044: LD_ADDR_EXP 18
52048: PUSH
52049: LD_EXP 18
52053: PPUSH
52054: LD_VAR 0 2
52058: PPUSH
52059: EMPTY
52060: PPUSH
52061: CALL_OW 1
52065: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
52066: LD_VAR 0 2
52070: PPUSH
52071: LD_INT 102
52073: PPUSH
52074: CALL 46215 0 2
// continue ;
52078: GO 52007
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
52080: LD_ADDR_VAR 0 4
52084: PUSH
52085: LD_EXP 14
52089: PUSH
52090: LD_VAR 0 2
52094: ARRAY
52095: PPUSH
52096: LD_INT 25
52098: PUSH
52099: LD_INT 4
52101: PUSH
52102: EMPTY
52103: LIST
52104: LIST
52105: PPUSH
52106: CALL_OW 72
52110: ST_TO_ADDR
// if not tmp then
52111: LD_VAR 0 4
52115: NOT
52116: IFFALSE 52120
// continue ;
52118: GO 52007
// if mc_taming [ i ] then
52120: LD_EXP 45
52124: PUSH
52125: LD_VAR 0 2
52129: ARRAY
52130: IFFALSE 52154
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
52132: LD_ADDR_EXP 45
52136: PUSH
52137: LD_EXP 45
52141: PPUSH
52142: LD_VAR 0 2
52146: PPUSH
52147: EMPTY
52148: PPUSH
52149: CALL_OW 1
52153: ST_TO_ADDR
// for j in tmp do
52154: LD_ADDR_VAR 0 3
52158: PUSH
52159: LD_VAR 0 4
52163: PUSH
52164: FOR_IN
52165: IFFALSE 52388
// begin if IsInUnit ( j ) then
52167: LD_VAR 0 3
52171: PPUSH
52172: CALL_OW 310
52176: IFFALSE 52187
// ComExitBuilding ( j ) ;
52178: LD_VAR 0 3
52182: PPUSH
52183: CALL_OW 122
// if not j in mc_healers [ i ] then
52187: LD_VAR 0 3
52191: PUSH
52192: LD_EXP 18
52196: PUSH
52197: LD_VAR 0 2
52201: ARRAY
52202: IN
52203: NOT
52204: IFFALSE 52250
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
52206: LD_ADDR_EXP 18
52210: PUSH
52211: LD_EXP 18
52215: PPUSH
52216: LD_VAR 0 2
52220: PUSH
52221: LD_EXP 18
52225: PUSH
52226: LD_VAR 0 2
52230: ARRAY
52231: PUSH
52232: LD_INT 1
52234: PLUS
52235: PUSH
52236: EMPTY
52237: LIST
52238: LIST
52239: PPUSH
52240: LD_VAR 0 3
52244: PPUSH
52245: CALL 9427 0 3
52249: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
52250: LD_VAR 0 3
52254: PPUSH
52255: CALL_OW 110
52259: PUSH
52260: LD_INT 102
52262: NONEQUAL
52263: IFFALSE 52277
// SetTag ( j , 102 ) ;
52265: LD_VAR 0 3
52269: PPUSH
52270: LD_INT 102
52272: PPUSH
52273: CALL_OW 109
// Wait ( 3 ) ;
52277: LD_INT 3
52279: PPUSH
52280: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
52284: LD_EXP 17
52288: PUSH
52289: LD_VAR 0 2
52293: ARRAY
52294: PUSH
52295: LD_INT 1
52297: ARRAY
52298: IFFALSE 52330
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
52300: LD_VAR 0 3
52304: PPUSH
52305: LD_EXP 17
52309: PUSH
52310: LD_VAR 0 2
52314: ARRAY
52315: PUSH
52316: LD_INT 1
52318: ARRAY
52319: PUSH
52320: LD_INT 1
52322: ARRAY
52323: PPUSH
52324: CALL_OW 128
52328: GO 52386
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
52330: LD_VAR 0 3
52334: PPUSH
52335: CALL_OW 314
52339: NOT
52340: PUSH
52341: LD_EXP 17
52345: PUSH
52346: LD_VAR 0 2
52350: ARRAY
52351: PUSH
52352: LD_INT 2
52354: ARRAY
52355: AND
52356: IFFALSE 52386
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
52358: LD_VAR 0 3
52362: PPUSH
52363: LD_EXP 17
52367: PUSH
52368: LD_VAR 0 2
52372: ARRAY
52373: PUSH
52374: LD_INT 2
52376: ARRAY
52377: PUSH
52378: LD_INT 1
52380: ARRAY
52381: PPUSH
52382: CALL_OW 128
// end ;
52386: GO 52164
52388: POP
52389: POP
// end ;
52390: GO 52007
52392: POP
52393: POP
// end ;
52394: LD_VAR 0 1
52398: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
52399: LD_INT 0
52401: PPUSH
52402: PPUSH
52403: PPUSH
52404: PPUSH
52405: PPUSH
// if not mc_bases then
52406: LD_EXP 14
52410: NOT
52411: IFFALSE 52415
// exit ;
52413: GO 53586
// for i = 1 to mc_bases do
52415: LD_ADDR_VAR 0 2
52419: PUSH
52420: DOUBLE
52421: LD_INT 1
52423: DEC
52424: ST_TO_ADDR
52425: LD_EXP 14
52429: PUSH
52430: FOR_TO
52431: IFFALSE 53584
// begin if mc_scan [ i ] then
52433: LD_EXP 37
52437: PUSH
52438: LD_VAR 0 2
52442: ARRAY
52443: IFFALSE 52447
// continue ;
52445: GO 52430
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
52447: LD_EXP 19
52451: PUSH
52452: LD_VAR 0 2
52456: ARRAY
52457: NOT
52458: PUSH
52459: LD_EXP 21
52463: PUSH
52464: LD_VAR 0 2
52468: ARRAY
52469: NOT
52470: AND
52471: PUSH
52472: LD_EXP 20
52476: PUSH
52477: LD_VAR 0 2
52481: ARRAY
52482: AND
52483: IFFALSE 52521
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
52485: LD_ADDR_EXP 20
52489: PUSH
52490: LD_EXP 20
52494: PPUSH
52495: LD_VAR 0 2
52499: PPUSH
52500: EMPTY
52501: PPUSH
52502: CALL_OW 1
52506: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
52507: LD_VAR 0 2
52511: PPUSH
52512: LD_INT 103
52514: PPUSH
52515: CALL 46215 0 2
// continue ;
52519: GO 52430
// end ; if mc_construct_list [ i ] then
52521: LD_EXP 21
52525: PUSH
52526: LD_VAR 0 2
52530: ARRAY
52531: IFFALSE 52751
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
52533: LD_ADDR_VAR 0 4
52537: PUSH
52538: LD_EXP 14
52542: PUSH
52543: LD_VAR 0 2
52547: ARRAY
52548: PPUSH
52549: LD_INT 25
52551: PUSH
52552: LD_INT 2
52554: PUSH
52555: EMPTY
52556: LIST
52557: LIST
52558: PPUSH
52559: CALL_OW 72
52563: PUSH
52564: LD_EXP 16
52568: PUSH
52569: LD_VAR 0 2
52573: ARRAY
52574: DIFF
52575: ST_TO_ADDR
// if not tmp then
52576: LD_VAR 0 4
52580: NOT
52581: IFFALSE 52585
// continue ;
52583: GO 52430
// for j in tmp do
52585: LD_ADDR_VAR 0 3
52589: PUSH
52590: LD_VAR 0 4
52594: PUSH
52595: FOR_IN
52596: IFFALSE 52747
// begin if not mc_builders [ i ] then
52598: LD_EXP 20
52602: PUSH
52603: LD_VAR 0 2
52607: ARRAY
52608: NOT
52609: IFFALSE 52667
// begin SetTag ( j , 103 ) ;
52611: LD_VAR 0 3
52615: PPUSH
52616: LD_INT 103
52618: PPUSH
52619: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
52623: LD_ADDR_EXP 20
52627: PUSH
52628: LD_EXP 20
52632: PPUSH
52633: LD_VAR 0 2
52637: PUSH
52638: LD_EXP 20
52642: PUSH
52643: LD_VAR 0 2
52647: ARRAY
52648: PUSH
52649: LD_INT 1
52651: PLUS
52652: PUSH
52653: EMPTY
52654: LIST
52655: LIST
52656: PPUSH
52657: LD_VAR 0 3
52661: PPUSH
52662: CALL 9427 0 3
52666: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
52667: LD_VAR 0 3
52671: PPUSH
52672: CALL_OW 310
52676: IFFALSE 52687
// ComExitBuilding ( j ) ;
52678: LD_VAR 0 3
52682: PPUSH
52683: CALL_OW 122
// wait ( 3 ) ;
52687: LD_INT 3
52689: PPUSH
52690: CALL_OW 67
// if not mc_construct_list [ i ] then
52694: LD_EXP 21
52698: PUSH
52699: LD_VAR 0 2
52703: ARRAY
52704: NOT
52705: IFFALSE 52709
// break ;
52707: GO 52747
// if not HasTask ( j ) then
52709: LD_VAR 0 3
52713: PPUSH
52714: CALL_OW 314
52718: NOT
52719: IFFALSE 52745
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
52721: LD_VAR 0 3
52725: PPUSH
52726: LD_EXP 21
52730: PUSH
52731: LD_VAR 0 2
52735: ARRAY
52736: PUSH
52737: LD_INT 1
52739: ARRAY
52740: PPUSH
52741: CALL 12284 0 2
// end ;
52745: GO 52595
52747: POP
52748: POP
// end else
52749: GO 53582
// if mc_build_list [ i ] then
52751: LD_EXP 19
52755: PUSH
52756: LD_VAR 0 2
52760: ARRAY
52761: IFFALSE 53582
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52763: LD_ADDR_VAR 0 5
52767: PUSH
52768: LD_EXP 14
52772: PUSH
52773: LD_VAR 0 2
52777: ARRAY
52778: PPUSH
52779: LD_INT 2
52781: PUSH
52782: LD_INT 30
52784: PUSH
52785: LD_INT 0
52787: PUSH
52788: EMPTY
52789: LIST
52790: LIST
52791: PUSH
52792: LD_INT 30
52794: PUSH
52795: LD_INT 1
52797: PUSH
52798: EMPTY
52799: LIST
52800: LIST
52801: PUSH
52802: EMPTY
52803: LIST
52804: LIST
52805: LIST
52806: PPUSH
52807: CALL_OW 72
52811: ST_TO_ADDR
// if depot then
52812: LD_VAR 0 5
52816: IFFALSE 52834
// depot := depot [ 1 ] else
52818: LD_ADDR_VAR 0 5
52822: PUSH
52823: LD_VAR 0 5
52827: PUSH
52828: LD_INT 1
52830: ARRAY
52831: ST_TO_ADDR
52832: GO 52842
// depot := 0 ;
52834: LD_ADDR_VAR 0 5
52838: PUSH
52839: LD_INT 0
52841: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
52842: LD_EXP 19
52846: PUSH
52847: LD_VAR 0 2
52851: ARRAY
52852: PUSH
52853: LD_INT 1
52855: ARRAY
52856: PUSH
52857: LD_INT 1
52859: ARRAY
52860: PPUSH
52861: CALL 12108 0 1
52865: PUSH
52866: LD_EXP 14
52870: PUSH
52871: LD_VAR 0 2
52875: ARRAY
52876: PPUSH
52877: LD_INT 2
52879: PUSH
52880: LD_INT 30
52882: PUSH
52883: LD_INT 2
52885: PUSH
52886: EMPTY
52887: LIST
52888: LIST
52889: PUSH
52890: LD_INT 30
52892: PUSH
52893: LD_INT 3
52895: PUSH
52896: EMPTY
52897: LIST
52898: LIST
52899: PUSH
52900: EMPTY
52901: LIST
52902: LIST
52903: LIST
52904: PPUSH
52905: CALL_OW 72
52909: NOT
52910: AND
52911: IFFALSE 53016
// begin for j = 1 to mc_build_list [ i ] do
52913: LD_ADDR_VAR 0 3
52917: PUSH
52918: DOUBLE
52919: LD_INT 1
52921: DEC
52922: ST_TO_ADDR
52923: LD_EXP 19
52927: PUSH
52928: LD_VAR 0 2
52932: ARRAY
52933: PUSH
52934: FOR_TO
52935: IFFALSE 53014
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
52937: LD_EXP 19
52941: PUSH
52942: LD_VAR 0 2
52946: ARRAY
52947: PUSH
52948: LD_VAR 0 3
52952: ARRAY
52953: PUSH
52954: LD_INT 1
52956: ARRAY
52957: PUSH
52958: LD_INT 2
52960: EQUAL
52961: IFFALSE 53012
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
52963: LD_ADDR_EXP 19
52967: PUSH
52968: LD_EXP 19
52972: PPUSH
52973: LD_VAR 0 2
52977: PPUSH
52978: LD_EXP 19
52982: PUSH
52983: LD_VAR 0 2
52987: ARRAY
52988: PPUSH
52989: LD_VAR 0 3
52993: PPUSH
52994: LD_INT 1
52996: PPUSH
52997: LD_INT 0
52999: PPUSH
53000: CALL 8845 0 4
53004: PPUSH
53005: CALL_OW 1
53009: ST_TO_ADDR
// break ;
53010: GO 53014
// end ;
53012: GO 52934
53014: POP
53015: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
53016: LD_EXP 19
53020: PUSH
53021: LD_VAR 0 2
53025: ARRAY
53026: PUSH
53027: LD_INT 1
53029: ARRAY
53030: PUSH
53031: LD_INT 1
53033: ARRAY
53034: PUSH
53035: LD_INT 0
53037: EQUAL
53038: PUSH
53039: LD_VAR 0 5
53043: PUSH
53044: LD_VAR 0 5
53048: PPUSH
53049: LD_EXP 19
53053: PUSH
53054: LD_VAR 0 2
53058: ARRAY
53059: PUSH
53060: LD_INT 1
53062: ARRAY
53063: PUSH
53064: LD_INT 1
53066: ARRAY
53067: PPUSH
53068: LD_EXP 19
53072: PUSH
53073: LD_VAR 0 2
53077: ARRAY
53078: PUSH
53079: LD_INT 1
53081: ARRAY
53082: PUSH
53083: LD_INT 2
53085: ARRAY
53086: PPUSH
53087: LD_EXP 19
53091: PUSH
53092: LD_VAR 0 2
53096: ARRAY
53097: PUSH
53098: LD_INT 1
53100: ARRAY
53101: PUSH
53102: LD_INT 3
53104: ARRAY
53105: PPUSH
53106: LD_EXP 19
53110: PUSH
53111: LD_VAR 0 2
53115: ARRAY
53116: PUSH
53117: LD_INT 1
53119: ARRAY
53120: PUSH
53121: LD_INT 4
53123: ARRAY
53124: PPUSH
53125: CALL 17175 0 5
53129: AND
53130: OR
53131: IFFALSE 53412
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
53133: LD_ADDR_VAR 0 4
53137: PUSH
53138: LD_EXP 14
53142: PUSH
53143: LD_VAR 0 2
53147: ARRAY
53148: PPUSH
53149: LD_INT 25
53151: PUSH
53152: LD_INT 2
53154: PUSH
53155: EMPTY
53156: LIST
53157: LIST
53158: PPUSH
53159: CALL_OW 72
53163: PUSH
53164: LD_EXP 16
53168: PUSH
53169: LD_VAR 0 2
53173: ARRAY
53174: DIFF
53175: ST_TO_ADDR
// if not tmp then
53176: LD_VAR 0 4
53180: NOT
53181: IFFALSE 53185
// continue ;
53183: GO 52430
// for j in tmp do
53185: LD_ADDR_VAR 0 3
53189: PUSH
53190: LD_VAR 0 4
53194: PUSH
53195: FOR_IN
53196: IFFALSE 53408
// begin if not mc_builders [ i ] then
53198: LD_EXP 20
53202: PUSH
53203: LD_VAR 0 2
53207: ARRAY
53208: NOT
53209: IFFALSE 53267
// begin SetTag ( j , 103 ) ;
53211: LD_VAR 0 3
53215: PPUSH
53216: LD_INT 103
53218: PPUSH
53219: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
53223: LD_ADDR_EXP 20
53227: PUSH
53228: LD_EXP 20
53232: PPUSH
53233: LD_VAR 0 2
53237: PUSH
53238: LD_EXP 20
53242: PUSH
53243: LD_VAR 0 2
53247: ARRAY
53248: PUSH
53249: LD_INT 1
53251: PLUS
53252: PUSH
53253: EMPTY
53254: LIST
53255: LIST
53256: PPUSH
53257: LD_VAR 0 3
53261: PPUSH
53262: CALL 9427 0 3
53266: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
53267: LD_VAR 0 3
53271: PPUSH
53272: CALL_OW 310
53276: IFFALSE 53287
// ComExitBuilding ( j ) ;
53278: LD_VAR 0 3
53282: PPUSH
53283: CALL_OW 122
// wait ( 3 ) ;
53287: LD_INT 3
53289: PPUSH
53290: CALL_OW 67
// if not mc_build_list [ i ] then
53294: LD_EXP 19
53298: PUSH
53299: LD_VAR 0 2
53303: ARRAY
53304: NOT
53305: IFFALSE 53309
// break ;
53307: GO 53408
// if not HasTask ( j ) then
53309: LD_VAR 0 3
53313: PPUSH
53314: CALL_OW 314
53318: NOT
53319: IFFALSE 53406
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
53321: LD_VAR 0 3
53325: PPUSH
53326: LD_EXP 19
53330: PUSH
53331: LD_VAR 0 2
53335: ARRAY
53336: PUSH
53337: LD_INT 1
53339: ARRAY
53340: PUSH
53341: LD_INT 1
53343: ARRAY
53344: PPUSH
53345: LD_EXP 19
53349: PUSH
53350: LD_VAR 0 2
53354: ARRAY
53355: PUSH
53356: LD_INT 1
53358: ARRAY
53359: PUSH
53360: LD_INT 2
53362: ARRAY
53363: PPUSH
53364: LD_EXP 19
53368: PUSH
53369: LD_VAR 0 2
53373: ARRAY
53374: PUSH
53375: LD_INT 1
53377: ARRAY
53378: PUSH
53379: LD_INT 3
53381: ARRAY
53382: PPUSH
53383: LD_EXP 19
53387: PUSH
53388: LD_VAR 0 2
53392: ARRAY
53393: PUSH
53394: LD_INT 1
53396: ARRAY
53397: PUSH
53398: LD_INT 4
53400: ARRAY
53401: PPUSH
53402: CALL_OW 145
// end ;
53406: GO 53195
53408: POP
53409: POP
// end else
53410: GO 53582
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
53412: LD_EXP 14
53416: PUSH
53417: LD_VAR 0 2
53421: ARRAY
53422: PPUSH
53423: LD_EXP 19
53427: PUSH
53428: LD_VAR 0 2
53432: ARRAY
53433: PUSH
53434: LD_INT 1
53436: ARRAY
53437: PUSH
53438: LD_INT 1
53440: ARRAY
53441: PPUSH
53442: LD_EXP 19
53446: PUSH
53447: LD_VAR 0 2
53451: ARRAY
53452: PUSH
53453: LD_INT 1
53455: ARRAY
53456: PUSH
53457: LD_INT 2
53459: ARRAY
53460: PPUSH
53461: LD_EXP 19
53465: PUSH
53466: LD_VAR 0 2
53470: ARRAY
53471: PUSH
53472: LD_INT 1
53474: ARRAY
53475: PUSH
53476: LD_INT 3
53478: ARRAY
53479: PPUSH
53480: LD_EXP 19
53484: PUSH
53485: LD_VAR 0 2
53489: ARRAY
53490: PUSH
53491: LD_INT 1
53493: ARRAY
53494: PUSH
53495: LD_INT 4
53497: ARRAY
53498: PPUSH
53499: LD_EXP 14
53503: PUSH
53504: LD_VAR 0 2
53508: ARRAY
53509: PPUSH
53510: LD_INT 21
53512: PUSH
53513: LD_INT 3
53515: PUSH
53516: EMPTY
53517: LIST
53518: LIST
53519: PPUSH
53520: CALL_OW 72
53524: PPUSH
53525: EMPTY
53526: PPUSH
53527: CALL 16305 0 7
53531: NOT
53532: IFFALSE 53582
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
53534: LD_ADDR_EXP 19
53538: PUSH
53539: LD_EXP 19
53543: PPUSH
53544: LD_VAR 0 2
53548: PPUSH
53549: LD_EXP 19
53553: PUSH
53554: LD_VAR 0 2
53558: ARRAY
53559: PPUSH
53560: LD_INT 1
53562: PPUSH
53563: LD_INT 1
53565: NEG
53566: PPUSH
53567: LD_INT 0
53569: PPUSH
53570: CALL 8845 0 4
53574: PPUSH
53575: CALL_OW 1
53579: ST_TO_ADDR
// continue ;
53580: GO 52430
// end ; end ; end ;
53582: GO 52430
53584: POP
53585: POP
// end ;
53586: LD_VAR 0 1
53590: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
53591: LD_INT 0
53593: PPUSH
53594: PPUSH
53595: PPUSH
53596: PPUSH
53597: PPUSH
53598: PPUSH
// if not mc_bases then
53599: LD_EXP 14
53603: NOT
53604: IFFALSE 53608
// exit ;
53606: GO 54035
// for i = 1 to mc_bases do
53608: LD_ADDR_VAR 0 2
53612: PUSH
53613: DOUBLE
53614: LD_INT 1
53616: DEC
53617: ST_TO_ADDR
53618: LD_EXP 14
53622: PUSH
53623: FOR_TO
53624: IFFALSE 54033
// begin tmp := mc_build_upgrade [ i ] ;
53626: LD_ADDR_VAR 0 4
53630: PUSH
53631: LD_EXP 46
53635: PUSH
53636: LD_VAR 0 2
53640: ARRAY
53641: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
53642: LD_ADDR_VAR 0 6
53646: PUSH
53647: LD_EXP 47
53651: PUSH
53652: LD_VAR 0 2
53656: ARRAY
53657: PPUSH
53658: LD_INT 2
53660: PUSH
53661: LD_INT 30
53663: PUSH
53664: LD_INT 6
53666: PUSH
53667: EMPTY
53668: LIST
53669: LIST
53670: PUSH
53671: LD_INT 30
53673: PUSH
53674: LD_INT 7
53676: PUSH
53677: EMPTY
53678: LIST
53679: LIST
53680: PUSH
53681: EMPTY
53682: LIST
53683: LIST
53684: LIST
53685: PPUSH
53686: CALL_OW 72
53690: ST_TO_ADDR
// if not tmp and not lab then
53691: LD_VAR 0 4
53695: NOT
53696: PUSH
53697: LD_VAR 0 6
53701: NOT
53702: AND
53703: IFFALSE 53707
// continue ;
53705: GO 53623
// if tmp then
53707: LD_VAR 0 4
53711: IFFALSE 53831
// for j in tmp do
53713: LD_ADDR_VAR 0 3
53717: PUSH
53718: LD_VAR 0 4
53722: PUSH
53723: FOR_IN
53724: IFFALSE 53829
// begin if UpgradeCost ( j ) then
53726: LD_VAR 0 3
53730: PPUSH
53731: CALL 15965 0 1
53735: IFFALSE 53827
// begin ComUpgrade ( j ) ;
53737: LD_VAR 0 3
53741: PPUSH
53742: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
53746: LD_ADDR_EXP 46
53750: PUSH
53751: LD_EXP 46
53755: PPUSH
53756: LD_VAR 0 2
53760: PPUSH
53761: LD_EXP 46
53765: PUSH
53766: LD_VAR 0 2
53770: ARRAY
53771: PUSH
53772: LD_VAR 0 3
53776: DIFF
53777: PPUSH
53778: CALL_OW 1
53782: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
53783: LD_ADDR_EXP 21
53787: PUSH
53788: LD_EXP 21
53792: PPUSH
53793: LD_VAR 0 2
53797: PUSH
53798: LD_EXP 21
53802: PUSH
53803: LD_VAR 0 2
53807: ARRAY
53808: PUSH
53809: LD_INT 1
53811: PLUS
53812: PUSH
53813: EMPTY
53814: LIST
53815: LIST
53816: PPUSH
53817: LD_VAR 0 3
53821: PPUSH
53822: CALL 9427 0 3
53826: ST_TO_ADDR
// end ; end ;
53827: GO 53723
53829: POP
53830: POP
// if not lab or not mc_lab_upgrade [ i ] then
53831: LD_VAR 0 6
53835: NOT
53836: PUSH
53837: LD_EXP 48
53841: PUSH
53842: LD_VAR 0 2
53846: ARRAY
53847: NOT
53848: OR
53849: IFFALSE 53853
// continue ;
53851: GO 53623
// for j in lab do
53853: LD_ADDR_VAR 0 3
53857: PUSH
53858: LD_VAR 0 6
53862: PUSH
53863: FOR_IN
53864: IFFALSE 54029
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
53866: LD_VAR 0 3
53870: PPUSH
53871: CALL_OW 266
53875: PUSH
53876: LD_INT 6
53878: PUSH
53879: LD_INT 7
53881: PUSH
53882: EMPTY
53883: LIST
53884: LIST
53885: IN
53886: PUSH
53887: LD_VAR 0 3
53891: PPUSH
53892: CALL_OW 461
53896: PUSH
53897: LD_INT 1
53899: NONEQUAL
53900: AND
53901: IFFALSE 54027
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
53903: LD_VAR 0 3
53907: PPUSH
53908: LD_EXP 48
53912: PUSH
53913: LD_VAR 0 2
53917: ARRAY
53918: PUSH
53919: LD_INT 1
53921: ARRAY
53922: PPUSH
53923: CALL 16170 0 2
53927: IFFALSE 54027
// begin ComCancel ( j ) ;
53929: LD_VAR 0 3
53933: PPUSH
53934: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
53938: LD_VAR 0 3
53942: PPUSH
53943: LD_EXP 48
53947: PUSH
53948: LD_VAR 0 2
53952: ARRAY
53953: PUSH
53954: LD_INT 1
53956: ARRAY
53957: PPUSH
53958: CALL_OW 207
// if not j in mc_construct_list [ i ] then
53962: LD_VAR 0 3
53966: PUSH
53967: LD_EXP 21
53971: PUSH
53972: LD_VAR 0 2
53976: ARRAY
53977: IN
53978: NOT
53979: IFFALSE 54025
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
53981: LD_ADDR_EXP 21
53985: PUSH
53986: LD_EXP 21
53990: PPUSH
53991: LD_VAR 0 2
53995: PUSH
53996: LD_EXP 21
54000: PUSH
54001: LD_VAR 0 2
54005: ARRAY
54006: PUSH
54007: LD_INT 1
54009: PLUS
54010: PUSH
54011: EMPTY
54012: LIST
54013: LIST
54014: PPUSH
54015: LD_VAR 0 3
54019: PPUSH
54020: CALL 9427 0 3
54024: ST_TO_ADDR
// break ;
54025: GO 54029
// end ; end ; end ;
54027: GO 53863
54029: POP
54030: POP
// end ;
54031: GO 53623
54033: POP
54034: POP
// end ;
54035: LD_VAR 0 1
54039: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
54040: LD_INT 0
54042: PPUSH
54043: PPUSH
54044: PPUSH
54045: PPUSH
54046: PPUSH
54047: PPUSH
54048: PPUSH
54049: PPUSH
54050: PPUSH
// if not mc_bases then
54051: LD_EXP 14
54055: NOT
54056: IFFALSE 54060
// exit ;
54058: GO 54465
// for i = 1 to mc_bases do
54060: LD_ADDR_VAR 0 2
54064: PUSH
54065: DOUBLE
54066: LD_INT 1
54068: DEC
54069: ST_TO_ADDR
54070: LD_EXP 14
54074: PUSH
54075: FOR_TO
54076: IFFALSE 54463
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
54078: LD_EXP 22
54082: PUSH
54083: LD_VAR 0 2
54087: ARRAY
54088: NOT
54089: PUSH
54090: LD_EXP 14
54094: PUSH
54095: LD_VAR 0 2
54099: ARRAY
54100: PPUSH
54101: LD_INT 30
54103: PUSH
54104: LD_INT 3
54106: PUSH
54107: EMPTY
54108: LIST
54109: LIST
54110: PPUSH
54111: CALL_OW 72
54115: NOT
54116: OR
54117: IFFALSE 54121
// continue ;
54119: GO 54075
// busy := false ;
54121: LD_ADDR_VAR 0 8
54125: PUSH
54126: LD_INT 0
54128: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
54129: LD_ADDR_VAR 0 4
54133: PUSH
54134: LD_EXP 14
54138: PUSH
54139: LD_VAR 0 2
54143: ARRAY
54144: PPUSH
54145: LD_INT 30
54147: PUSH
54148: LD_INT 3
54150: PUSH
54151: EMPTY
54152: LIST
54153: LIST
54154: PPUSH
54155: CALL_OW 72
54159: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
54160: LD_ADDR_VAR 0 6
54164: PUSH
54165: LD_EXP 22
54169: PUSH
54170: LD_VAR 0 2
54174: ARRAY
54175: PPUSH
54176: LD_INT 2
54178: PUSH
54179: LD_INT 30
54181: PUSH
54182: LD_INT 32
54184: PUSH
54185: EMPTY
54186: LIST
54187: LIST
54188: PUSH
54189: LD_INT 30
54191: PUSH
54192: LD_INT 33
54194: PUSH
54195: EMPTY
54196: LIST
54197: LIST
54198: PUSH
54199: EMPTY
54200: LIST
54201: LIST
54202: LIST
54203: PPUSH
54204: CALL_OW 72
54208: ST_TO_ADDR
// if not t then
54209: LD_VAR 0 6
54213: NOT
54214: IFFALSE 54218
// continue ;
54216: GO 54075
// for j in tmp do
54218: LD_ADDR_VAR 0 3
54222: PUSH
54223: LD_VAR 0 4
54227: PUSH
54228: FOR_IN
54229: IFFALSE 54259
// if not BuildingStatus ( j ) = bs_idle then
54231: LD_VAR 0 3
54235: PPUSH
54236: CALL_OW 461
54240: PUSH
54241: LD_INT 2
54243: EQUAL
54244: NOT
54245: IFFALSE 54257
// begin busy := true ;
54247: LD_ADDR_VAR 0 8
54251: PUSH
54252: LD_INT 1
54254: ST_TO_ADDR
// break ;
54255: GO 54259
// end ;
54257: GO 54228
54259: POP
54260: POP
// if busy then
54261: LD_VAR 0 8
54265: IFFALSE 54269
// continue ;
54267: GO 54075
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
54269: LD_ADDR_VAR 0 7
54273: PUSH
54274: LD_VAR 0 6
54278: PPUSH
54279: LD_INT 35
54281: PUSH
54282: LD_INT 0
54284: PUSH
54285: EMPTY
54286: LIST
54287: LIST
54288: PPUSH
54289: CALL_OW 72
54293: ST_TO_ADDR
// if tw then
54294: LD_VAR 0 7
54298: IFFALSE 54375
// begin tw := tw [ 1 ] ;
54300: LD_ADDR_VAR 0 7
54304: PUSH
54305: LD_VAR 0 7
54309: PUSH
54310: LD_INT 1
54312: ARRAY
54313: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
54314: LD_ADDR_VAR 0 9
54318: PUSH
54319: LD_VAR 0 7
54323: PPUSH
54324: LD_EXP 39
54328: PUSH
54329: LD_VAR 0 2
54333: ARRAY
54334: PPUSH
54335: CALL 14432 0 2
54339: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
54340: LD_EXP 53
54344: PUSH
54345: LD_VAR 0 2
54349: ARRAY
54350: IFFALSE 54373
// if not weapon in mc_allowed_tower_weapons [ i ] then
54352: LD_VAR 0 9
54356: PUSH
54357: LD_EXP 53
54361: PUSH
54362: LD_VAR 0 2
54366: ARRAY
54367: IN
54368: NOT
54369: IFFALSE 54373
// continue ;
54371: GO 54075
// end else
54373: GO 54438
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
54375: LD_ADDR_VAR 0 5
54379: PUSH
54380: LD_EXP 22
54384: PUSH
54385: LD_VAR 0 2
54389: ARRAY
54390: PPUSH
54391: LD_VAR 0 4
54395: PPUSH
54396: CALL 40351 0 2
54400: ST_TO_ADDR
// if not tmp2 then
54401: LD_VAR 0 5
54405: NOT
54406: IFFALSE 54410
// continue ;
54408: GO 54075
// tw := tmp2 [ 1 ] ;
54410: LD_ADDR_VAR 0 7
54414: PUSH
54415: LD_VAR 0 5
54419: PUSH
54420: LD_INT 1
54422: ARRAY
54423: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
54424: LD_ADDR_VAR 0 9
54428: PUSH
54429: LD_VAR 0 5
54433: PUSH
54434: LD_INT 2
54436: ARRAY
54437: ST_TO_ADDR
// end ; if not weapon then
54438: LD_VAR 0 9
54442: NOT
54443: IFFALSE 54447
// continue ;
54445: GO 54075
// ComPlaceWeapon ( tw , weapon ) ;
54447: LD_VAR 0 7
54451: PPUSH
54452: LD_VAR 0 9
54456: PPUSH
54457: CALL_OW 148
// end ;
54461: GO 54075
54463: POP
54464: POP
// end ;
54465: LD_VAR 0 1
54469: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
54470: LD_INT 0
54472: PPUSH
54473: PPUSH
54474: PPUSH
54475: PPUSH
54476: PPUSH
54477: PPUSH
54478: PPUSH
// if not mc_bases then
54479: LD_EXP 14
54483: NOT
54484: IFFALSE 54488
// exit ;
54486: GO 55256
// for i = 1 to mc_bases do
54488: LD_ADDR_VAR 0 2
54492: PUSH
54493: DOUBLE
54494: LD_INT 1
54496: DEC
54497: ST_TO_ADDR
54498: LD_EXP 14
54502: PUSH
54503: FOR_TO
54504: IFFALSE 55254
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
54506: LD_EXP 27
54510: PUSH
54511: LD_VAR 0 2
54515: ARRAY
54516: NOT
54517: PUSH
54518: LD_EXP 27
54522: PUSH
54523: LD_VAR 0 2
54527: ARRAY
54528: PUSH
54529: LD_EXP 28
54533: PUSH
54534: LD_VAR 0 2
54538: ARRAY
54539: EQUAL
54540: OR
54541: PUSH
54542: LD_EXP 37
54546: PUSH
54547: LD_VAR 0 2
54551: ARRAY
54552: OR
54553: IFFALSE 54557
// continue ;
54555: GO 54503
// if mc_miners [ i ] then
54557: LD_EXP 28
54561: PUSH
54562: LD_VAR 0 2
54566: ARRAY
54567: IFFALSE 54941
// begin for j = mc_miners [ i ] downto 1 do
54569: LD_ADDR_VAR 0 3
54573: PUSH
54574: DOUBLE
54575: LD_EXP 28
54579: PUSH
54580: LD_VAR 0 2
54584: ARRAY
54585: INC
54586: ST_TO_ADDR
54587: LD_INT 1
54589: PUSH
54590: FOR_DOWNTO
54591: IFFALSE 54939
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
54593: LD_EXP 28
54597: PUSH
54598: LD_VAR 0 2
54602: ARRAY
54603: PUSH
54604: LD_VAR 0 3
54608: ARRAY
54609: PPUSH
54610: CALL_OW 301
54614: PUSH
54615: LD_EXP 28
54619: PUSH
54620: LD_VAR 0 2
54624: ARRAY
54625: PUSH
54626: LD_VAR 0 3
54630: ARRAY
54631: PPUSH
54632: CALL_OW 257
54636: PUSH
54637: LD_INT 1
54639: NONEQUAL
54640: OR
54641: IFFALSE 54704
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
54643: LD_ADDR_VAR 0 5
54647: PUSH
54648: LD_EXP 28
54652: PUSH
54653: LD_VAR 0 2
54657: ARRAY
54658: PUSH
54659: LD_EXP 28
54663: PUSH
54664: LD_VAR 0 2
54668: ARRAY
54669: PUSH
54670: LD_VAR 0 3
54674: ARRAY
54675: DIFF
54676: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
54677: LD_ADDR_EXP 28
54681: PUSH
54682: LD_EXP 28
54686: PPUSH
54687: LD_VAR 0 2
54691: PPUSH
54692: LD_VAR 0 5
54696: PPUSH
54697: CALL_OW 1
54701: ST_TO_ADDR
// continue ;
54702: GO 54590
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
54704: LD_EXP 28
54708: PUSH
54709: LD_VAR 0 2
54713: ARRAY
54714: PUSH
54715: LD_VAR 0 3
54719: ARRAY
54720: PPUSH
54721: CALL_OW 257
54725: PUSH
54726: LD_INT 1
54728: EQUAL
54729: PUSH
54730: LD_EXP 28
54734: PUSH
54735: LD_VAR 0 2
54739: ARRAY
54740: PUSH
54741: LD_VAR 0 3
54745: ARRAY
54746: PPUSH
54747: CALL_OW 459
54751: NOT
54752: AND
54753: PUSH
54754: LD_EXP 28
54758: PUSH
54759: LD_VAR 0 2
54763: ARRAY
54764: PUSH
54765: LD_VAR 0 3
54769: ARRAY
54770: PPUSH
54771: CALL_OW 314
54775: NOT
54776: AND
54777: IFFALSE 54937
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
54779: LD_EXP 28
54783: PUSH
54784: LD_VAR 0 2
54788: ARRAY
54789: PUSH
54790: LD_VAR 0 3
54794: ARRAY
54795: PPUSH
54796: CALL_OW 310
54800: IFFALSE 54823
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
54802: LD_EXP 28
54806: PUSH
54807: LD_VAR 0 2
54811: ARRAY
54812: PUSH
54813: LD_VAR 0 3
54817: ARRAY
54818: PPUSH
54819: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
54823: LD_EXP 28
54827: PUSH
54828: LD_VAR 0 2
54832: ARRAY
54833: PUSH
54834: LD_VAR 0 3
54838: ARRAY
54839: PPUSH
54840: CALL_OW 314
54844: NOT
54845: IFFALSE 54937
// begin r := rand ( 1 , mc_mines [ i ] ) ;
54847: LD_ADDR_VAR 0 7
54851: PUSH
54852: LD_INT 1
54854: PPUSH
54855: LD_EXP 27
54859: PUSH
54860: LD_VAR 0 2
54864: ARRAY
54865: PPUSH
54866: CALL_OW 12
54870: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
54871: LD_EXP 28
54875: PUSH
54876: LD_VAR 0 2
54880: ARRAY
54881: PUSH
54882: LD_VAR 0 3
54886: ARRAY
54887: PPUSH
54888: LD_EXP 27
54892: PUSH
54893: LD_VAR 0 2
54897: ARRAY
54898: PUSH
54899: LD_VAR 0 7
54903: ARRAY
54904: PUSH
54905: LD_INT 1
54907: ARRAY
54908: PPUSH
54909: LD_EXP 27
54913: PUSH
54914: LD_VAR 0 2
54918: ARRAY
54919: PUSH
54920: LD_VAR 0 7
54924: ARRAY
54925: PUSH
54926: LD_INT 2
54928: ARRAY
54929: PPUSH
54930: LD_INT 0
54932: PPUSH
54933: CALL_OW 193
// end ; end ; end ;
54937: GO 54590
54939: POP
54940: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
54941: LD_ADDR_VAR 0 5
54945: PUSH
54946: LD_EXP 14
54950: PUSH
54951: LD_VAR 0 2
54955: ARRAY
54956: PPUSH
54957: LD_INT 2
54959: PUSH
54960: LD_INT 30
54962: PUSH
54963: LD_INT 4
54965: PUSH
54966: EMPTY
54967: LIST
54968: LIST
54969: PUSH
54970: LD_INT 30
54972: PUSH
54973: LD_INT 5
54975: PUSH
54976: EMPTY
54977: LIST
54978: LIST
54979: PUSH
54980: LD_INT 30
54982: PUSH
54983: LD_INT 32
54985: PUSH
54986: EMPTY
54987: LIST
54988: LIST
54989: PUSH
54990: EMPTY
54991: LIST
54992: LIST
54993: LIST
54994: LIST
54995: PPUSH
54996: CALL_OW 72
55000: ST_TO_ADDR
// if not tmp then
55001: LD_VAR 0 5
55005: NOT
55006: IFFALSE 55010
// continue ;
55008: GO 54503
// list := [ ] ;
55010: LD_ADDR_VAR 0 6
55014: PUSH
55015: EMPTY
55016: ST_TO_ADDR
// for j in tmp do
55017: LD_ADDR_VAR 0 3
55021: PUSH
55022: LD_VAR 0 5
55026: PUSH
55027: FOR_IN
55028: IFFALSE 55097
// begin for k in UnitsInside ( j ) do
55030: LD_ADDR_VAR 0 4
55034: PUSH
55035: LD_VAR 0 3
55039: PPUSH
55040: CALL_OW 313
55044: PUSH
55045: FOR_IN
55046: IFFALSE 55093
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
55048: LD_VAR 0 4
55052: PPUSH
55053: CALL_OW 257
55057: PUSH
55058: LD_INT 1
55060: EQUAL
55061: PUSH
55062: LD_VAR 0 4
55066: PPUSH
55067: CALL_OW 459
55071: NOT
55072: AND
55073: IFFALSE 55091
// list := list ^ k ;
55075: LD_ADDR_VAR 0 6
55079: PUSH
55080: LD_VAR 0 6
55084: PUSH
55085: LD_VAR 0 4
55089: ADD
55090: ST_TO_ADDR
55091: GO 55045
55093: POP
55094: POP
// end ;
55095: GO 55027
55097: POP
55098: POP
// list := list diff mc_miners [ i ] ;
55099: LD_ADDR_VAR 0 6
55103: PUSH
55104: LD_VAR 0 6
55108: PUSH
55109: LD_EXP 28
55113: PUSH
55114: LD_VAR 0 2
55118: ARRAY
55119: DIFF
55120: ST_TO_ADDR
// if not list then
55121: LD_VAR 0 6
55125: NOT
55126: IFFALSE 55130
// continue ;
55128: GO 54503
// k := mc_mines [ i ] - mc_miners [ i ] ;
55130: LD_ADDR_VAR 0 4
55134: PUSH
55135: LD_EXP 27
55139: PUSH
55140: LD_VAR 0 2
55144: ARRAY
55145: PUSH
55146: LD_EXP 28
55150: PUSH
55151: LD_VAR 0 2
55155: ARRAY
55156: MINUS
55157: ST_TO_ADDR
// if k > list then
55158: LD_VAR 0 4
55162: PUSH
55163: LD_VAR 0 6
55167: GREATER
55168: IFFALSE 55180
// k := list ;
55170: LD_ADDR_VAR 0 4
55174: PUSH
55175: LD_VAR 0 6
55179: ST_TO_ADDR
// for j = 1 to k do
55180: LD_ADDR_VAR 0 3
55184: PUSH
55185: DOUBLE
55186: LD_INT 1
55188: DEC
55189: ST_TO_ADDR
55190: LD_VAR 0 4
55194: PUSH
55195: FOR_TO
55196: IFFALSE 55250
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
55198: LD_ADDR_EXP 28
55202: PUSH
55203: LD_EXP 28
55207: PPUSH
55208: LD_VAR 0 2
55212: PUSH
55213: LD_EXP 28
55217: PUSH
55218: LD_VAR 0 2
55222: ARRAY
55223: PUSH
55224: LD_INT 1
55226: PLUS
55227: PUSH
55228: EMPTY
55229: LIST
55230: LIST
55231: PPUSH
55232: LD_VAR 0 6
55236: PUSH
55237: LD_VAR 0 3
55241: ARRAY
55242: PPUSH
55243: CALL 9427 0 3
55247: ST_TO_ADDR
55248: GO 55195
55250: POP
55251: POP
// end ;
55252: GO 54503
55254: POP
55255: POP
// end ;
55256: LD_VAR 0 1
55260: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
55261: LD_INT 0
55263: PPUSH
55264: PPUSH
55265: PPUSH
55266: PPUSH
55267: PPUSH
55268: PPUSH
55269: PPUSH
55270: PPUSH
55271: PPUSH
55272: PPUSH
// if not mc_bases then
55273: LD_EXP 14
55277: NOT
55278: IFFALSE 55282
// exit ;
55280: GO 57032
// for i = 1 to mc_bases do
55282: LD_ADDR_VAR 0 2
55286: PUSH
55287: DOUBLE
55288: LD_INT 1
55290: DEC
55291: ST_TO_ADDR
55292: LD_EXP 14
55296: PUSH
55297: FOR_TO
55298: IFFALSE 57030
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
55300: LD_EXP 14
55304: PUSH
55305: LD_VAR 0 2
55309: ARRAY
55310: NOT
55311: PUSH
55312: LD_EXP 21
55316: PUSH
55317: LD_VAR 0 2
55321: ARRAY
55322: OR
55323: IFFALSE 55327
// continue ;
55325: GO 55297
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
55327: LD_EXP 30
55331: PUSH
55332: LD_VAR 0 2
55336: ARRAY
55337: NOT
55338: PUSH
55339: LD_EXP 31
55343: PUSH
55344: LD_VAR 0 2
55348: ARRAY
55349: AND
55350: IFFALSE 55388
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
55352: LD_ADDR_EXP 31
55356: PUSH
55357: LD_EXP 31
55361: PPUSH
55362: LD_VAR 0 2
55366: PPUSH
55367: EMPTY
55368: PPUSH
55369: CALL_OW 1
55373: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
55374: LD_VAR 0 2
55378: PPUSH
55379: LD_INT 107
55381: PPUSH
55382: CALL 46215 0 2
// continue ;
55386: GO 55297
// end ; target := [ ] ;
55388: LD_ADDR_VAR 0 6
55392: PUSH
55393: EMPTY
55394: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
55395: LD_ADDR_VAR 0 3
55399: PUSH
55400: DOUBLE
55401: LD_EXP 30
55405: PUSH
55406: LD_VAR 0 2
55410: ARRAY
55411: INC
55412: ST_TO_ADDR
55413: LD_INT 1
55415: PUSH
55416: FOR_DOWNTO
55417: IFFALSE 55677
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
55419: LD_EXP 30
55423: PUSH
55424: LD_VAR 0 2
55428: ARRAY
55429: PUSH
55430: LD_VAR 0 3
55434: ARRAY
55435: PUSH
55436: LD_INT 2
55438: ARRAY
55439: PPUSH
55440: LD_EXP 30
55444: PUSH
55445: LD_VAR 0 2
55449: ARRAY
55450: PUSH
55451: LD_VAR 0 3
55455: ARRAY
55456: PUSH
55457: LD_INT 3
55459: ARRAY
55460: PPUSH
55461: CALL_OW 488
55465: PUSH
55466: LD_EXP 30
55470: PUSH
55471: LD_VAR 0 2
55475: ARRAY
55476: PUSH
55477: LD_VAR 0 3
55481: ARRAY
55482: PUSH
55483: LD_INT 2
55485: ARRAY
55486: PPUSH
55487: LD_EXP 30
55491: PUSH
55492: LD_VAR 0 2
55496: ARRAY
55497: PUSH
55498: LD_VAR 0 3
55502: ARRAY
55503: PUSH
55504: LD_INT 3
55506: ARRAY
55507: PPUSH
55508: CALL_OW 284
55512: PUSH
55513: LD_INT 0
55515: EQUAL
55516: AND
55517: IFFALSE 55572
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
55519: LD_ADDR_VAR 0 5
55523: PUSH
55524: LD_EXP 30
55528: PUSH
55529: LD_VAR 0 2
55533: ARRAY
55534: PPUSH
55535: LD_VAR 0 3
55539: PPUSH
55540: CALL_OW 3
55544: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
55545: LD_ADDR_EXP 30
55549: PUSH
55550: LD_EXP 30
55554: PPUSH
55555: LD_VAR 0 2
55559: PPUSH
55560: LD_VAR 0 5
55564: PPUSH
55565: CALL_OW 1
55569: ST_TO_ADDR
// continue ;
55570: GO 55416
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
55572: LD_EXP 14
55576: PUSH
55577: LD_VAR 0 2
55581: ARRAY
55582: PUSH
55583: LD_INT 1
55585: ARRAY
55586: PPUSH
55587: CALL_OW 255
55591: PPUSH
55592: LD_EXP 30
55596: PUSH
55597: LD_VAR 0 2
55601: ARRAY
55602: PUSH
55603: LD_VAR 0 3
55607: ARRAY
55608: PUSH
55609: LD_INT 2
55611: ARRAY
55612: PPUSH
55613: LD_EXP 30
55617: PUSH
55618: LD_VAR 0 2
55622: ARRAY
55623: PUSH
55624: LD_VAR 0 3
55628: ARRAY
55629: PUSH
55630: LD_INT 3
55632: ARRAY
55633: PPUSH
55634: LD_INT 30
55636: PPUSH
55637: CALL 10323 0 4
55641: PUSH
55642: LD_INT 4
55644: ARRAY
55645: PUSH
55646: LD_INT 0
55648: EQUAL
55649: IFFALSE 55675
// begin target := mc_crates [ i ] [ j ] ;
55651: LD_ADDR_VAR 0 6
55655: PUSH
55656: LD_EXP 30
55660: PUSH
55661: LD_VAR 0 2
55665: ARRAY
55666: PUSH
55667: LD_VAR 0 3
55671: ARRAY
55672: ST_TO_ADDR
// break ;
55673: GO 55677
// end ; end ;
55675: GO 55416
55677: POP
55678: POP
// if not target then
55679: LD_VAR 0 6
55683: NOT
55684: IFFALSE 55688
// continue ;
55686: GO 55297
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
55688: LD_ADDR_VAR 0 7
55692: PUSH
55693: LD_EXP 33
55697: PUSH
55698: LD_VAR 0 2
55702: ARRAY
55703: PPUSH
55704: LD_INT 2
55706: PUSH
55707: LD_INT 3
55709: PUSH
55710: LD_INT 58
55712: PUSH
55713: EMPTY
55714: LIST
55715: PUSH
55716: EMPTY
55717: LIST
55718: LIST
55719: PUSH
55720: LD_INT 61
55722: PUSH
55723: EMPTY
55724: LIST
55725: PUSH
55726: LD_INT 33
55728: PUSH
55729: LD_INT 5
55731: PUSH
55732: EMPTY
55733: LIST
55734: LIST
55735: PUSH
55736: LD_INT 33
55738: PUSH
55739: LD_INT 3
55741: PUSH
55742: EMPTY
55743: LIST
55744: LIST
55745: PUSH
55746: EMPTY
55747: LIST
55748: LIST
55749: LIST
55750: LIST
55751: LIST
55752: PUSH
55753: LD_INT 2
55755: PUSH
55756: LD_INT 34
55758: PUSH
55759: LD_INT 32
55761: PUSH
55762: EMPTY
55763: LIST
55764: LIST
55765: PUSH
55766: LD_INT 34
55768: PUSH
55769: LD_INT 51
55771: PUSH
55772: EMPTY
55773: LIST
55774: LIST
55775: PUSH
55776: LD_INT 34
55778: PUSH
55779: LD_INT 12
55781: PUSH
55782: EMPTY
55783: LIST
55784: LIST
55785: PUSH
55786: EMPTY
55787: LIST
55788: LIST
55789: LIST
55790: LIST
55791: PUSH
55792: EMPTY
55793: LIST
55794: LIST
55795: PPUSH
55796: CALL_OW 72
55800: ST_TO_ADDR
// if not cargo then
55801: LD_VAR 0 7
55805: NOT
55806: IFFALSE 56449
// begin if mc_crates_collector [ i ] < 5 then
55808: LD_EXP 31
55812: PUSH
55813: LD_VAR 0 2
55817: ARRAY
55818: PUSH
55819: LD_INT 5
55821: LESS
55822: IFFALSE 56188
// begin if mc_ape [ i ] then
55824: LD_EXP 43
55828: PUSH
55829: LD_VAR 0 2
55833: ARRAY
55834: IFFALSE 55881
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
55836: LD_ADDR_VAR 0 5
55840: PUSH
55841: LD_EXP 43
55845: PUSH
55846: LD_VAR 0 2
55850: ARRAY
55851: PPUSH
55852: LD_INT 25
55854: PUSH
55855: LD_INT 16
55857: PUSH
55858: EMPTY
55859: LIST
55860: LIST
55861: PUSH
55862: LD_INT 24
55864: PUSH
55865: LD_INT 750
55867: PUSH
55868: EMPTY
55869: LIST
55870: LIST
55871: PUSH
55872: EMPTY
55873: LIST
55874: LIST
55875: PPUSH
55876: CALL_OW 72
55880: ST_TO_ADDR
// if not tmp then
55881: LD_VAR 0 5
55885: NOT
55886: IFFALSE 55933
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
55888: LD_ADDR_VAR 0 5
55892: PUSH
55893: LD_EXP 14
55897: PUSH
55898: LD_VAR 0 2
55902: ARRAY
55903: PPUSH
55904: LD_INT 25
55906: PUSH
55907: LD_INT 2
55909: PUSH
55910: EMPTY
55911: LIST
55912: LIST
55913: PUSH
55914: LD_INT 24
55916: PUSH
55917: LD_INT 750
55919: PUSH
55920: EMPTY
55921: LIST
55922: LIST
55923: PUSH
55924: EMPTY
55925: LIST
55926: LIST
55927: PPUSH
55928: CALL_OW 72
55932: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
55933: LD_EXP 43
55937: PUSH
55938: LD_VAR 0 2
55942: ARRAY
55943: PUSH
55944: LD_EXP 14
55948: PUSH
55949: LD_VAR 0 2
55953: ARRAY
55954: PPUSH
55955: LD_INT 25
55957: PUSH
55958: LD_INT 2
55960: PUSH
55961: EMPTY
55962: LIST
55963: LIST
55964: PUSH
55965: LD_INT 24
55967: PUSH
55968: LD_INT 750
55970: PUSH
55971: EMPTY
55972: LIST
55973: LIST
55974: PUSH
55975: EMPTY
55976: LIST
55977: LIST
55978: PPUSH
55979: CALL_OW 72
55983: AND
55984: PUSH
55985: LD_VAR 0 5
55989: PUSH
55990: LD_INT 5
55992: LESS
55993: AND
55994: IFFALSE 56076
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
55996: LD_ADDR_VAR 0 3
56000: PUSH
56001: LD_EXP 14
56005: PUSH
56006: LD_VAR 0 2
56010: ARRAY
56011: PPUSH
56012: LD_INT 25
56014: PUSH
56015: LD_INT 2
56017: PUSH
56018: EMPTY
56019: LIST
56020: LIST
56021: PUSH
56022: LD_INT 24
56024: PUSH
56025: LD_INT 750
56027: PUSH
56028: EMPTY
56029: LIST
56030: LIST
56031: PUSH
56032: EMPTY
56033: LIST
56034: LIST
56035: PPUSH
56036: CALL_OW 72
56040: PUSH
56041: FOR_IN
56042: IFFALSE 56074
// begin tmp := tmp union j ;
56044: LD_ADDR_VAR 0 5
56048: PUSH
56049: LD_VAR 0 5
56053: PUSH
56054: LD_VAR 0 3
56058: UNION
56059: ST_TO_ADDR
// if tmp >= 5 then
56060: LD_VAR 0 5
56064: PUSH
56065: LD_INT 5
56067: GREATEREQUAL
56068: IFFALSE 56072
// break ;
56070: GO 56074
// end ;
56072: GO 56041
56074: POP
56075: POP
// end ; if not tmp then
56076: LD_VAR 0 5
56080: NOT
56081: IFFALSE 56085
// continue ;
56083: GO 55297
// for j in tmp do
56085: LD_ADDR_VAR 0 3
56089: PUSH
56090: LD_VAR 0 5
56094: PUSH
56095: FOR_IN
56096: IFFALSE 56186
// if not GetTag ( j ) then
56098: LD_VAR 0 3
56102: PPUSH
56103: CALL_OW 110
56107: NOT
56108: IFFALSE 56184
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
56110: LD_ADDR_EXP 31
56114: PUSH
56115: LD_EXP 31
56119: PPUSH
56120: LD_VAR 0 2
56124: PUSH
56125: LD_EXP 31
56129: PUSH
56130: LD_VAR 0 2
56134: ARRAY
56135: PUSH
56136: LD_INT 1
56138: PLUS
56139: PUSH
56140: EMPTY
56141: LIST
56142: LIST
56143: PPUSH
56144: LD_VAR 0 3
56148: PPUSH
56149: CALL 9427 0 3
56153: ST_TO_ADDR
// SetTag ( j , 107 ) ;
56154: LD_VAR 0 3
56158: PPUSH
56159: LD_INT 107
56161: PPUSH
56162: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
56166: LD_EXP 31
56170: PUSH
56171: LD_VAR 0 2
56175: ARRAY
56176: PUSH
56177: LD_INT 5
56179: GREATEREQUAL
56180: IFFALSE 56184
// break ;
56182: GO 56186
// end ;
56184: GO 56095
56186: POP
56187: POP
// end ; if mc_crates_collector [ i ] and target then
56188: LD_EXP 31
56192: PUSH
56193: LD_VAR 0 2
56197: ARRAY
56198: PUSH
56199: LD_VAR 0 6
56203: AND
56204: IFFALSE 56447
// begin if mc_crates_collector [ i ] < target [ 1 ] then
56206: LD_EXP 31
56210: PUSH
56211: LD_VAR 0 2
56215: ARRAY
56216: PUSH
56217: LD_VAR 0 6
56221: PUSH
56222: LD_INT 1
56224: ARRAY
56225: LESS
56226: IFFALSE 56246
// tmp := mc_crates_collector [ i ] else
56228: LD_ADDR_VAR 0 5
56232: PUSH
56233: LD_EXP 31
56237: PUSH
56238: LD_VAR 0 2
56242: ARRAY
56243: ST_TO_ADDR
56244: GO 56260
// tmp := target [ 1 ] ;
56246: LD_ADDR_VAR 0 5
56250: PUSH
56251: LD_VAR 0 6
56255: PUSH
56256: LD_INT 1
56258: ARRAY
56259: ST_TO_ADDR
// k := 0 ;
56260: LD_ADDR_VAR 0 4
56264: PUSH
56265: LD_INT 0
56267: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
56268: LD_ADDR_VAR 0 3
56272: PUSH
56273: LD_EXP 31
56277: PUSH
56278: LD_VAR 0 2
56282: ARRAY
56283: PUSH
56284: FOR_IN
56285: IFFALSE 56445
// begin k := k + 1 ;
56287: LD_ADDR_VAR 0 4
56291: PUSH
56292: LD_VAR 0 4
56296: PUSH
56297: LD_INT 1
56299: PLUS
56300: ST_TO_ADDR
// if k > tmp then
56301: LD_VAR 0 4
56305: PUSH
56306: LD_VAR 0 5
56310: GREATER
56311: IFFALSE 56315
// break ;
56313: GO 56445
// if not GetClass ( j ) in [ 2 , 16 ] then
56315: LD_VAR 0 3
56319: PPUSH
56320: CALL_OW 257
56324: PUSH
56325: LD_INT 2
56327: PUSH
56328: LD_INT 16
56330: PUSH
56331: EMPTY
56332: LIST
56333: LIST
56334: IN
56335: NOT
56336: IFFALSE 56389
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
56338: LD_ADDR_EXP 31
56342: PUSH
56343: LD_EXP 31
56347: PPUSH
56348: LD_VAR 0 2
56352: PPUSH
56353: LD_EXP 31
56357: PUSH
56358: LD_VAR 0 2
56362: ARRAY
56363: PUSH
56364: LD_VAR 0 3
56368: DIFF
56369: PPUSH
56370: CALL_OW 1
56374: ST_TO_ADDR
// SetTag ( j , 0 ) ;
56375: LD_VAR 0 3
56379: PPUSH
56380: LD_INT 0
56382: PPUSH
56383: CALL_OW 109
// continue ;
56387: GO 56284
// end ; if IsInUnit ( j ) then
56389: LD_VAR 0 3
56393: PPUSH
56394: CALL_OW 310
56398: IFFALSE 56409
// ComExitBuilding ( j ) ;
56400: LD_VAR 0 3
56404: PPUSH
56405: CALL_OW 122
// wait ( 3 ) ;
56409: LD_INT 3
56411: PPUSH
56412: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
56416: LD_VAR 0 3
56420: PPUSH
56421: LD_VAR 0 6
56425: PUSH
56426: LD_INT 2
56428: ARRAY
56429: PPUSH
56430: LD_VAR 0 6
56434: PUSH
56435: LD_INT 3
56437: ARRAY
56438: PPUSH
56439: CALL_OW 117
// end ;
56443: GO 56284
56445: POP
56446: POP
// end ; end else
56447: GO 57028
// begin for j in cargo do
56449: LD_ADDR_VAR 0 3
56453: PUSH
56454: LD_VAR 0 7
56458: PUSH
56459: FOR_IN
56460: IFFALSE 57026
// begin if GetTag ( j ) <> 0 then
56462: LD_VAR 0 3
56466: PPUSH
56467: CALL_OW 110
56471: PUSH
56472: LD_INT 0
56474: NONEQUAL
56475: IFFALSE 56479
// continue ;
56477: GO 56459
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
56479: LD_VAR 0 3
56483: PPUSH
56484: CALL_OW 256
56488: PUSH
56489: LD_INT 1000
56491: LESS
56492: PUSH
56493: LD_VAR 0 3
56497: PPUSH
56498: LD_EXP 38
56502: PUSH
56503: LD_VAR 0 2
56507: ARRAY
56508: PPUSH
56509: CALL_OW 308
56513: NOT
56514: AND
56515: IFFALSE 56537
// ComMoveToArea ( j , mc_parking [ i ] ) ;
56517: LD_VAR 0 3
56521: PPUSH
56522: LD_EXP 38
56526: PUSH
56527: LD_VAR 0 2
56531: ARRAY
56532: PPUSH
56533: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
56537: LD_VAR 0 3
56541: PPUSH
56542: CALL_OW 256
56546: PUSH
56547: LD_INT 1000
56549: LESS
56550: PUSH
56551: LD_VAR 0 3
56555: PPUSH
56556: LD_EXP 38
56560: PUSH
56561: LD_VAR 0 2
56565: ARRAY
56566: PPUSH
56567: CALL_OW 308
56571: AND
56572: IFFALSE 56576
// continue ;
56574: GO 56459
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
56576: LD_VAR 0 3
56580: PPUSH
56581: CALL_OW 262
56585: PUSH
56586: LD_INT 2
56588: EQUAL
56589: PUSH
56590: LD_VAR 0 3
56594: PPUSH
56595: CALL_OW 261
56599: PUSH
56600: LD_INT 15
56602: LESS
56603: AND
56604: IFFALSE 56608
// continue ;
56606: GO 56459
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
56608: LD_VAR 0 3
56612: PPUSH
56613: CALL_OW 262
56617: PUSH
56618: LD_INT 1
56620: EQUAL
56621: PUSH
56622: LD_VAR 0 3
56626: PPUSH
56627: CALL_OW 261
56631: PUSH
56632: LD_INT 10
56634: LESS
56635: AND
56636: IFFALSE 56965
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
56638: LD_ADDR_VAR 0 8
56642: PUSH
56643: LD_EXP 14
56647: PUSH
56648: LD_VAR 0 2
56652: ARRAY
56653: PPUSH
56654: LD_INT 2
56656: PUSH
56657: LD_INT 30
56659: PUSH
56660: LD_INT 0
56662: PUSH
56663: EMPTY
56664: LIST
56665: LIST
56666: PUSH
56667: LD_INT 30
56669: PUSH
56670: LD_INT 1
56672: PUSH
56673: EMPTY
56674: LIST
56675: LIST
56676: PUSH
56677: EMPTY
56678: LIST
56679: LIST
56680: LIST
56681: PPUSH
56682: CALL_OW 72
56686: ST_TO_ADDR
// if not depot then
56687: LD_VAR 0 8
56691: NOT
56692: IFFALSE 56696
// continue ;
56694: GO 56459
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
56696: LD_VAR 0 3
56700: PPUSH
56701: LD_VAR 0 8
56705: PPUSH
56706: LD_VAR 0 3
56710: PPUSH
56711: CALL_OW 74
56715: PPUSH
56716: CALL_OW 296
56720: PUSH
56721: LD_INT 6
56723: LESS
56724: IFFALSE 56740
// SetFuel ( j , 100 ) else
56726: LD_VAR 0 3
56730: PPUSH
56731: LD_INT 100
56733: PPUSH
56734: CALL_OW 240
56738: GO 56965
// if GetFuel ( j ) = 0 then
56740: LD_VAR 0 3
56744: PPUSH
56745: CALL_OW 261
56749: PUSH
56750: LD_INT 0
56752: EQUAL
56753: IFFALSE 56965
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
56755: LD_ADDR_EXP 33
56759: PUSH
56760: LD_EXP 33
56764: PPUSH
56765: LD_VAR 0 2
56769: PPUSH
56770: LD_EXP 33
56774: PUSH
56775: LD_VAR 0 2
56779: ARRAY
56780: PUSH
56781: LD_VAR 0 3
56785: DIFF
56786: PPUSH
56787: CALL_OW 1
56791: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
56792: LD_VAR 0 3
56796: PPUSH
56797: CALL_OW 263
56801: PUSH
56802: LD_INT 1
56804: EQUAL
56805: IFFALSE 56821
// ComExitVehicle ( IsInUnit ( j ) ) ;
56807: LD_VAR 0 3
56811: PPUSH
56812: CALL_OW 310
56816: PPUSH
56817: CALL_OW 121
// if GetControl ( j ) = control_remote then
56821: LD_VAR 0 3
56825: PPUSH
56826: CALL_OW 263
56830: PUSH
56831: LD_INT 2
56833: EQUAL
56834: IFFALSE 56845
// ComUnlink ( j ) ;
56836: LD_VAR 0 3
56840: PPUSH
56841: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
56845: LD_ADDR_VAR 0 9
56849: PUSH
56850: LD_VAR 0 2
56854: PPUSH
56855: LD_INT 3
56857: PPUSH
56858: CALL 66340 0 2
56862: ST_TO_ADDR
// if fac then
56863: LD_VAR 0 9
56867: IFFALSE 56963
// begin for k in fac do
56869: LD_ADDR_VAR 0 4
56873: PUSH
56874: LD_VAR 0 9
56878: PUSH
56879: FOR_IN
56880: IFFALSE 56961
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
56882: LD_ADDR_VAR 0 10
56886: PUSH
56887: LD_VAR 0 9
56891: PPUSH
56892: LD_VAR 0 3
56896: PPUSH
56897: CALL_OW 265
56901: PPUSH
56902: LD_VAR 0 3
56906: PPUSH
56907: CALL_OW 262
56911: PPUSH
56912: LD_VAR 0 3
56916: PPUSH
56917: CALL_OW 263
56921: PPUSH
56922: LD_VAR 0 3
56926: PPUSH
56927: CALL_OW 264
56931: PPUSH
56932: CALL 6959 0 5
56936: ST_TO_ADDR
// if components then
56937: LD_VAR 0 10
56941: IFFALSE 56959
// begin MC_InsertProduceList ( i , components ) ;
56943: LD_VAR 0 2
56947: PPUSH
56948: LD_VAR 0 10
56952: PPUSH
56953: CALL 65885 0 2
// break ;
56957: GO 56961
// end ; end ;
56959: GO 56879
56961: POP
56962: POP
// end ; continue ;
56963: GO 56459
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
56965: LD_VAR 0 3
56969: PPUSH
56970: LD_INT 1
56972: PPUSH
56973: CALL_OW 289
56977: PUSH
56978: LD_INT 100
56980: LESS
56981: PUSH
56982: LD_VAR 0 3
56986: PPUSH
56987: CALL_OW 314
56991: NOT
56992: AND
56993: IFFALSE 57022
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
56995: LD_VAR 0 3
56999: PPUSH
57000: LD_VAR 0 6
57004: PUSH
57005: LD_INT 2
57007: ARRAY
57008: PPUSH
57009: LD_VAR 0 6
57013: PUSH
57014: LD_INT 3
57016: ARRAY
57017: PPUSH
57018: CALL_OW 117
// break ;
57022: GO 57026
// end ;
57024: GO 56459
57026: POP
57027: POP
// end ; end ;
57028: GO 55297
57030: POP
57031: POP
// end ;
57032: LD_VAR 0 1
57036: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
57037: LD_INT 0
57039: PPUSH
57040: PPUSH
57041: PPUSH
57042: PPUSH
// if not mc_bases then
57043: LD_EXP 14
57047: NOT
57048: IFFALSE 57052
// exit ;
57050: GO 57213
// for i = 1 to mc_bases do
57052: LD_ADDR_VAR 0 2
57056: PUSH
57057: DOUBLE
57058: LD_INT 1
57060: DEC
57061: ST_TO_ADDR
57062: LD_EXP 14
57066: PUSH
57067: FOR_TO
57068: IFFALSE 57211
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
57070: LD_ADDR_VAR 0 4
57074: PUSH
57075: LD_EXP 33
57079: PUSH
57080: LD_VAR 0 2
57084: ARRAY
57085: PUSH
57086: LD_EXP 36
57090: PUSH
57091: LD_VAR 0 2
57095: ARRAY
57096: UNION
57097: PPUSH
57098: LD_INT 33
57100: PUSH
57101: LD_INT 2
57103: PUSH
57104: EMPTY
57105: LIST
57106: LIST
57107: PPUSH
57108: CALL_OW 72
57112: ST_TO_ADDR
// if tmp then
57113: LD_VAR 0 4
57117: IFFALSE 57209
// for j in tmp do
57119: LD_ADDR_VAR 0 3
57123: PUSH
57124: LD_VAR 0 4
57128: PUSH
57129: FOR_IN
57130: IFFALSE 57207
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
57132: LD_VAR 0 3
57136: PPUSH
57137: CALL_OW 312
57141: NOT
57142: PUSH
57143: LD_VAR 0 3
57147: PPUSH
57148: CALL_OW 256
57152: PUSH
57153: LD_INT 250
57155: GREATEREQUAL
57156: AND
57157: IFFALSE 57170
// Connect ( j ) else
57159: LD_VAR 0 3
57163: PPUSH
57164: CALL 12392 0 1
57168: GO 57205
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
57170: LD_VAR 0 3
57174: PPUSH
57175: CALL_OW 256
57179: PUSH
57180: LD_INT 250
57182: LESS
57183: PUSH
57184: LD_VAR 0 3
57188: PPUSH
57189: CALL_OW 312
57193: AND
57194: IFFALSE 57205
// ComUnlink ( j ) ;
57196: LD_VAR 0 3
57200: PPUSH
57201: CALL_OW 136
57205: GO 57129
57207: POP
57208: POP
// end ;
57209: GO 57067
57211: POP
57212: POP
// end ;
57213: LD_VAR 0 1
57217: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
57218: LD_INT 0
57220: PPUSH
57221: PPUSH
57222: PPUSH
57223: PPUSH
57224: PPUSH
// if not mc_bases then
57225: LD_EXP 14
57229: NOT
57230: IFFALSE 57234
// exit ;
57232: GO 57679
// for i = 1 to mc_bases do
57234: LD_ADDR_VAR 0 2
57238: PUSH
57239: DOUBLE
57240: LD_INT 1
57242: DEC
57243: ST_TO_ADDR
57244: LD_EXP 14
57248: PUSH
57249: FOR_TO
57250: IFFALSE 57677
// begin if not mc_produce [ i ] then
57252: LD_EXP 35
57256: PUSH
57257: LD_VAR 0 2
57261: ARRAY
57262: NOT
57263: IFFALSE 57267
// continue ;
57265: GO 57249
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
57267: LD_ADDR_VAR 0 5
57271: PUSH
57272: LD_EXP 14
57276: PUSH
57277: LD_VAR 0 2
57281: ARRAY
57282: PPUSH
57283: LD_INT 30
57285: PUSH
57286: LD_INT 3
57288: PUSH
57289: EMPTY
57290: LIST
57291: LIST
57292: PPUSH
57293: CALL_OW 72
57297: ST_TO_ADDR
// if not fac then
57298: LD_VAR 0 5
57302: NOT
57303: IFFALSE 57307
// continue ;
57305: GO 57249
// for j in fac do
57307: LD_ADDR_VAR 0 3
57311: PUSH
57312: LD_VAR 0 5
57316: PUSH
57317: FOR_IN
57318: IFFALSE 57673
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
57320: LD_VAR 0 3
57324: PPUSH
57325: CALL_OW 461
57329: PUSH
57330: LD_INT 2
57332: NONEQUAL
57333: PUSH
57334: LD_VAR 0 3
57338: PPUSH
57339: LD_INT 15
57341: PPUSH
57342: CALL 12020 0 2
57346: PUSH
57347: LD_INT 4
57349: ARRAY
57350: OR
57351: IFFALSE 57355
// continue ;
57353: GO 57317
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
57355: LD_VAR 0 3
57359: PPUSH
57360: LD_EXP 35
57364: PUSH
57365: LD_VAR 0 2
57369: ARRAY
57370: PUSH
57371: LD_INT 1
57373: ARRAY
57374: PUSH
57375: LD_INT 1
57377: ARRAY
57378: PPUSH
57379: LD_EXP 35
57383: PUSH
57384: LD_VAR 0 2
57388: ARRAY
57389: PUSH
57390: LD_INT 1
57392: ARRAY
57393: PUSH
57394: LD_INT 2
57396: ARRAY
57397: PPUSH
57398: LD_EXP 35
57402: PUSH
57403: LD_VAR 0 2
57407: ARRAY
57408: PUSH
57409: LD_INT 1
57411: ARRAY
57412: PUSH
57413: LD_INT 3
57415: ARRAY
57416: PPUSH
57417: LD_EXP 35
57421: PUSH
57422: LD_VAR 0 2
57426: ARRAY
57427: PUSH
57428: LD_INT 1
57430: ARRAY
57431: PUSH
57432: LD_INT 4
57434: ARRAY
57435: PPUSH
57436: CALL_OW 448
57440: PUSH
57441: LD_VAR 0 3
57445: PPUSH
57446: LD_EXP 35
57450: PUSH
57451: LD_VAR 0 2
57455: ARRAY
57456: PUSH
57457: LD_INT 1
57459: ARRAY
57460: PUSH
57461: LD_INT 1
57463: ARRAY
57464: PUSH
57465: LD_EXP 35
57469: PUSH
57470: LD_VAR 0 2
57474: ARRAY
57475: PUSH
57476: LD_INT 1
57478: ARRAY
57479: PUSH
57480: LD_INT 2
57482: ARRAY
57483: PUSH
57484: LD_EXP 35
57488: PUSH
57489: LD_VAR 0 2
57493: ARRAY
57494: PUSH
57495: LD_INT 1
57497: ARRAY
57498: PUSH
57499: LD_INT 3
57501: ARRAY
57502: PUSH
57503: LD_EXP 35
57507: PUSH
57508: LD_VAR 0 2
57512: ARRAY
57513: PUSH
57514: LD_INT 1
57516: ARRAY
57517: PUSH
57518: LD_INT 4
57520: ARRAY
57521: PUSH
57522: EMPTY
57523: LIST
57524: LIST
57525: LIST
57526: LIST
57527: PPUSH
57528: CALL 15818 0 2
57532: AND
57533: IFFALSE 57671
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
57535: LD_VAR 0 3
57539: PPUSH
57540: LD_EXP 35
57544: PUSH
57545: LD_VAR 0 2
57549: ARRAY
57550: PUSH
57551: LD_INT 1
57553: ARRAY
57554: PUSH
57555: LD_INT 1
57557: ARRAY
57558: PPUSH
57559: LD_EXP 35
57563: PUSH
57564: LD_VAR 0 2
57568: ARRAY
57569: PUSH
57570: LD_INT 1
57572: ARRAY
57573: PUSH
57574: LD_INT 2
57576: ARRAY
57577: PPUSH
57578: LD_EXP 35
57582: PUSH
57583: LD_VAR 0 2
57587: ARRAY
57588: PUSH
57589: LD_INT 1
57591: ARRAY
57592: PUSH
57593: LD_INT 3
57595: ARRAY
57596: PPUSH
57597: LD_EXP 35
57601: PUSH
57602: LD_VAR 0 2
57606: ARRAY
57607: PUSH
57608: LD_INT 1
57610: ARRAY
57611: PUSH
57612: LD_INT 4
57614: ARRAY
57615: PPUSH
57616: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
57620: LD_ADDR_VAR 0 4
57624: PUSH
57625: LD_EXP 35
57629: PUSH
57630: LD_VAR 0 2
57634: ARRAY
57635: PPUSH
57636: LD_INT 1
57638: PPUSH
57639: CALL_OW 3
57643: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
57644: LD_ADDR_EXP 35
57648: PUSH
57649: LD_EXP 35
57653: PPUSH
57654: LD_VAR 0 2
57658: PPUSH
57659: LD_VAR 0 4
57663: PPUSH
57664: CALL_OW 1
57668: ST_TO_ADDR
// break ;
57669: GO 57673
// end ; end ;
57671: GO 57317
57673: POP
57674: POP
// end ;
57675: GO 57249
57677: POP
57678: POP
// end ;
57679: LD_VAR 0 1
57683: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
57684: LD_INT 0
57686: PPUSH
57687: PPUSH
57688: PPUSH
// if not mc_bases then
57689: LD_EXP 14
57693: NOT
57694: IFFALSE 57698
// exit ;
57696: GO 57787
// for i = 1 to mc_bases do
57698: LD_ADDR_VAR 0 2
57702: PUSH
57703: DOUBLE
57704: LD_INT 1
57706: DEC
57707: ST_TO_ADDR
57708: LD_EXP 14
57712: PUSH
57713: FOR_TO
57714: IFFALSE 57785
// begin if mc_attack [ i ] then
57716: LD_EXP 34
57720: PUSH
57721: LD_VAR 0 2
57725: ARRAY
57726: IFFALSE 57783
// begin tmp := mc_attack [ i ] [ 1 ] ;
57728: LD_ADDR_VAR 0 3
57732: PUSH
57733: LD_EXP 34
57737: PUSH
57738: LD_VAR 0 2
57742: ARRAY
57743: PUSH
57744: LD_INT 1
57746: ARRAY
57747: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
57748: LD_ADDR_EXP 34
57752: PUSH
57753: LD_EXP 34
57757: PPUSH
57758: LD_VAR 0 2
57762: PPUSH
57763: EMPTY
57764: PPUSH
57765: CALL_OW 1
57769: ST_TO_ADDR
// Attack ( tmp ) ;
57770: LD_VAR 0 3
57774: PPUSH
57775: CALL 72392 0 1
// exit ;
57779: POP
57780: POP
57781: GO 57787
// end ; end ;
57783: GO 57713
57785: POP
57786: POP
// end ;
57787: LD_VAR 0 1
57791: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
57792: LD_INT 0
57794: PPUSH
57795: PPUSH
57796: PPUSH
57797: PPUSH
57798: PPUSH
57799: PPUSH
57800: PPUSH
// if not mc_bases then
57801: LD_EXP 14
57805: NOT
57806: IFFALSE 57810
// exit ;
57808: GO 58414
// for i = 1 to mc_bases do
57810: LD_ADDR_VAR 0 2
57814: PUSH
57815: DOUBLE
57816: LD_INT 1
57818: DEC
57819: ST_TO_ADDR
57820: LD_EXP 14
57824: PUSH
57825: FOR_TO
57826: IFFALSE 58412
// begin if not mc_bases [ i ] then
57828: LD_EXP 14
57832: PUSH
57833: LD_VAR 0 2
57837: ARRAY
57838: NOT
57839: IFFALSE 57843
// continue ;
57841: GO 57825
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
57843: LD_ADDR_VAR 0 7
57847: PUSH
57848: LD_EXP 14
57852: PUSH
57853: LD_VAR 0 2
57857: ARRAY
57858: PUSH
57859: LD_INT 1
57861: ARRAY
57862: PPUSH
57863: CALL 6263 0 1
57867: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
57868: LD_ADDR_EXP 37
57872: PUSH
57873: LD_EXP 37
57877: PPUSH
57878: LD_VAR 0 2
57882: PPUSH
57883: LD_EXP 14
57887: PUSH
57888: LD_VAR 0 2
57892: ARRAY
57893: PUSH
57894: LD_INT 1
57896: ARRAY
57897: PPUSH
57898: CALL_OW 255
57902: PPUSH
57903: LD_EXP 39
57907: PUSH
57908: LD_VAR 0 2
57912: ARRAY
57913: PPUSH
57914: CALL 6228 0 2
57918: PPUSH
57919: CALL_OW 1
57923: ST_TO_ADDR
// if not mc_scan [ i ] then
57924: LD_EXP 37
57928: PUSH
57929: LD_VAR 0 2
57933: ARRAY
57934: NOT
57935: IFFALSE 58090
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
57937: LD_ADDR_VAR 0 4
57941: PUSH
57942: LD_EXP 14
57946: PUSH
57947: LD_VAR 0 2
57951: ARRAY
57952: PPUSH
57953: LD_INT 2
57955: PUSH
57956: LD_INT 25
57958: PUSH
57959: LD_INT 5
57961: PUSH
57962: EMPTY
57963: LIST
57964: LIST
57965: PUSH
57966: LD_INT 25
57968: PUSH
57969: LD_INT 8
57971: PUSH
57972: EMPTY
57973: LIST
57974: LIST
57975: PUSH
57976: LD_INT 25
57978: PUSH
57979: LD_INT 9
57981: PUSH
57982: EMPTY
57983: LIST
57984: LIST
57985: PUSH
57986: EMPTY
57987: LIST
57988: LIST
57989: LIST
57990: LIST
57991: PPUSH
57992: CALL_OW 72
57996: ST_TO_ADDR
// if not tmp then
57997: LD_VAR 0 4
58001: NOT
58002: IFFALSE 58006
// continue ;
58004: GO 57825
// for j in tmp do
58006: LD_ADDR_VAR 0 3
58010: PUSH
58011: LD_VAR 0 4
58015: PUSH
58016: FOR_IN
58017: IFFALSE 58088
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
58019: LD_VAR 0 3
58023: PPUSH
58024: CALL_OW 310
58028: PPUSH
58029: CALL_OW 266
58033: PUSH
58034: LD_INT 5
58036: EQUAL
58037: PUSH
58038: LD_VAR 0 3
58042: PPUSH
58043: CALL_OW 257
58047: PUSH
58048: LD_INT 1
58050: EQUAL
58051: AND
58052: PUSH
58053: LD_VAR 0 3
58057: PPUSH
58058: CALL_OW 459
58062: NOT
58063: AND
58064: PUSH
58065: LD_VAR 0 7
58069: AND
58070: IFFALSE 58086
// ComChangeProfession ( j , class ) ;
58072: LD_VAR 0 3
58076: PPUSH
58077: LD_VAR 0 7
58081: PPUSH
58082: CALL_OW 123
58086: GO 58016
58088: POP
58089: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
58090: LD_EXP 37
58094: PUSH
58095: LD_VAR 0 2
58099: ARRAY
58100: PUSH
58101: LD_EXP 36
58105: PUSH
58106: LD_VAR 0 2
58110: ARRAY
58111: NOT
58112: AND
58113: PUSH
58114: LD_EXP 14
58118: PUSH
58119: LD_VAR 0 2
58123: ARRAY
58124: PPUSH
58125: LD_INT 30
58127: PUSH
58128: LD_INT 32
58130: PUSH
58131: EMPTY
58132: LIST
58133: LIST
58134: PPUSH
58135: CALL_OW 72
58139: NOT
58140: AND
58141: PUSH
58142: LD_EXP 14
58146: PUSH
58147: LD_VAR 0 2
58151: ARRAY
58152: PPUSH
58153: LD_INT 2
58155: PUSH
58156: LD_INT 30
58158: PUSH
58159: LD_INT 4
58161: PUSH
58162: EMPTY
58163: LIST
58164: LIST
58165: PUSH
58166: LD_INT 30
58168: PUSH
58169: LD_INT 5
58171: PUSH
58172: EMPTY
58173: LIST
58174: LIST
58175: PUSH
58176: EMPTY
58177: LIST
58178: LIST
58179: LIST
58180: PPUSH
58181: CALL_OW 72
58185: NOT
58186: AND
58187: IFFALSE 58319
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
58189: LD_ADDR_VAR 0 4
58193: PUSH
58194: LD_EXP 14
58198: PUSH
58199: LD_VAR 0 2
58203: ARRAY
58204: PPUSH
58205: LD_INT 2
58207: PUSH
58208: LD_INT 25
58210: PUSH
58211: LD_INT 1
58213: PUSH
58214: EMPTY
58215: LIST
58216: LIST
58217: PUSH
58218: LD_INT 25
58220: PUSH
58221: LD_INT 5
58223: PUSH
58224: EMPTY
58225: LIST
58226: LIST
58227: PUSH
58228: LD_INT 25
58230: PUSH
58231: LD_INT 8
58233: PUSH
58234: EMPTY
58235: LIST
58236: LIST
58237: PUSH
58238: LD_INT 25
58240: PUSH
58241: LD_INT 9
58243: PUSH
58244: EMPTY
58245: LIST
58246: LIST
58247: PUSH
58248: EMPTY
58249: LIST
58250: LIST
58251: LIST
58252: LIST
58253: LIST
58254: PPUSH
58255: CALL_OW 72
58259: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
58260: LD_ADDR_VAR 0 4
58264: PUSH
58265: LD_VAR 0 4
58269: PUSH
58270: LD_VAR 0 4
58274: PPUSH
58275: LD_INT 18
58277: PPUSH
58278: CALL 38321 0 2
58282: DIFF
58283: ST_TO_ADDR
// if tmp then
58284: LD_VAR 0 4
58288: IFFALSE 58319
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
58290: LD_VAR 0 2
58294: PPUSH
58295: LD_VAR 0 4
58299: PPUSH
58300: LD_EXP 39
58304: PUSH
58305: LD_VAR 0 2
58309: ARRAY
58310: PPUSH
58311: CALL 77101 0 3
// exit ;
58315: POP
58316: POP
58317: GO 58414
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
58319: LD_EXP 37
58323: PUSH
58324: LD_VAR 0 2
58328: ARRAY
58329: PUSH
58330: LD_EXP 36
58334: PUSH
58335: LD_VAR 0 2
58339: ARRAY
58340: AND
58341: IFFALSE 58410
// begin tmp := mc_defender [ i ] ;
58343: LD_ADDR_VAR 0 4
58347: PUSH
58348: LD_EXP 36
58352: PUSH
58353: LD_VAR 0 2
58357: ARRAY
58358: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
58359: LD_ADDR_EXP 36
58363: PUSH
58364: LD_EXP 36
58368: PPUSH
58369: LD_VAR 0 2
58373: PPUSH
58374: EMPTY
58375: PPUSH
58376: CALL_OW 1
58380: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
58381: LD_VAR 0 2
58385: PPUSH
58386: LD_VAR 0 4
58390: PPUSH
58391: LD_EXP 37
58395: PUSH
58396: LD_VAR 0 2
58400: ARRAY
58401: PPUSH
58402: CALL 77662 0 3
// exit ;
58406: POP
58407: POP
58408: GO 58414
// end ; end ;
58410: GO 57825
58412: POP
58413: POP
// end ;
58414: LD_VAR 0 1
58418: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
58419: LD_INT 0
58421: PPUSH
58422: PPUSH
58423: PPUSH
58424: PPUSH
58425: PPUSH
58426: PPUSH
58427: PPUSH
58428: PPUSH
58429: PPUSH
58430: PPUSH
58431: PPUSH
// if not mc_bases then
58432: LD_EXP 14
58436: NOT
58437: IFFALSE 58441
// exit ;
58439: GO 59528
// for i = 1 to mc_bases do
58441: LD_ADDR_VAR 0 2
58445: PUSH
58446: DOUBLE
58447: LD_INT 1
58449: DEC
58450: ST_TO_ADDR
58451: LD_EXP 14
58455: PUSH
58456: FOR_TO
58457: IFFALSE 59526
// begin tmp := mc_lab [ i ] ;
58459: LD_ADDR_VAR 0 6
58463: PUSH
58464: LD_EXP 47
58468: PUSH
58469: LD_VAR 0 2
58473: ARRAY
58474: ST_TO_ADDR
// if not tmp then
58475: LD_VAR 0 6
58479: NOT
58480: IFFALSE 58484
// continue ;
58482: GO 58456
// idle_lab := 0 ;
58484: LD_ADDR_VAR 0 11
58488: PUSH
58489: LD_INT 0
58491: ST_TO_ADDR
// for j in tmp do
58492: LD_ADDR_VAR 0 3
58496: PUSH
58497: LD_VAR 0 6
58501: PUSH
58502: FOR_IN
58503: IFFALSE 59522
// begin researching := false ;
58505: LD_ADDR_VAR 0 10
58509: PUSH
58510: LD_INT 0
58512: ST_TO_ADDR
// side := GetSide ( j ) ;
58513: LD_ADDR_VAR 0 4
58517: PUSH
58518: LD_VAR 0 3
58522: PPUSH
58523: CALL_OW 255
58527: ST_TO_ADDR
// if not mc_tech [ side ] then
58528: LD_EXP 41
58532: PUSH
58533: LD_VAR 0 4
58537: ARRAY
58538: NOT
58539: IFFALSE 58543
// continue ;
58541: GO 58502
// if BuildingStatus ( j ) = bs_idle then
58543: LD_VAR 0 3
58547: PPUSH
58548: CALL_OW 461
58552: PUSH
58553: LD_INT 2
58555: EQUAL
58556: IFFALSE 58744
// begin if idle_lab and UnitsInside ( j ) < 6 then
58558: LD_VAR 0 11
58562: PUSH
58563: LD_VAR 0 3
58567: PPUSH
58568: CALL_OW 313
58572: PUSH
58573: LD_INT 6
58575: LESS
58576: AND
58577: IFFALSE 58648
// begin tmp2 := UnitsInside ( idle_lab ) ;
58579: LD_ADDR_VAR 0 9
58583: PUSH
58584: LD_VAR 0 11
58588: PPUSH
58589: CALL_OW 313
58593: ST_TO_ADDR
// if tmp2 then
58594: LD_VAR 0 9
58598: IFFALSE 58640
// for x in tmp2 do
58600: LD_ADDR_VAR 0 7
58604: PUSH
58605: LD_VAR 0 9
58609: PUSH
58610: FOR_IN
58611: IFFALSE 58638
// begin ComExitBuilding ( x ) ;
58613: LD_VAR 0 7
58617: PPUSH
58618: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
58622: LD_VAR 0 7
58626: PPUSH
58627: LD_VAR 0 3
58631: PPUSH
58632: CALL_OW 180
// end ;
58636: GO 58610
58638: POP
58639: POP
// idle_lab := 0 ;
58640: LD_ADDR_VAR 0 11
58644: PUSH
58645: LD_INT 0
58647: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
58648: LD_ADDR_VAR 0 5
58652: PUSH
58653: LD_EXP 41
58657: PUSH
58658: LD_VAR 0 4
58662: ARRAY
58663: PUSH
58664: FOR_IN
58665: IFFALSE 58725
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
58667: LD_VAR 0 3
58671: PPUSH
58672: LD_VAR 0 5
58676: PPUSH
58677: CALL_OW 430
58681: PUSH
58682: LD_VAR 0 4
58686: PPUSH
58687: LD_VAR 0 5
58691: PPUSH
58692: CALL 5333 0 2
58696: AND
58697: IFFALSE 58723
// begin researching := true ;
58699: LD_ADDR_VAR 0 10
58703: PUSH
58704: LD_INT 1
58706: ST_TO_ADDR
// ComResearch ( j , t ) ;
58707: LD_VAR 0 3
58711: PPUSH
58712: LD_VAR 0 5
58716: PPUSH
58717: CALL_OW 124
// break ;
58721: GO 58725
// end ;
58723: GO 58664
58725: POP
58726: POP
// if not researching then
58727: LD_VAR 0 10
58731: NOT
58732: IFFALSE 58744
// idle_lab := j ;
58734: LD_ADDR_VAR 0 11
58738: PUSH
58739: LD_VAR 0 3
58743: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
58744: LD_VAR 0 3
58748: PPUSH
58749: CALL_OW 461
58753: PUSH
58754: LD_INT 10
58756: EQUAL
58757: IFFALSE 59345
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
58759: LD_EXP 43
58763: PUSH
58764: LD_VAR 0 2
58768: ARRAY
58769: NOT
58770: PUSH
58771: LD_EXP 44
58775: PUSH
58776: LD_VAR 0 2
58780: ARRAY
58781: NOT
58782: AND
58783: PUSH
58784: LD_EXP 41
58788: PUSH
58789: LD_VAR 0 4
58793: ARRAY
58794: PUSH
58795: LD_INT 1
58797: GREATER
58798: AND
58799: IFFALSE 58930
// begin ComCancel ( j ) ;
58801: LD_VAR 0 3
58805: PPUSH
58806: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
58810: LD_ADDR_EXP 41
58814: PUSH
58815: LD_EXP 41
58819: PPUSH
58820: LD_VAR 0 4
58824: PPUSH
58825: LD_EXP 41
58829: PUSH
58830: LD_VAR 0 4
58834: ARRAY
58835: PPUSH
58836: LD_EXP 41
58840: PUSH
58841: LD_VAR 0 4
58845: ARRAY
58846: PUSH
58847: LD_INT 1
58849: MINUS
58850: PPUSH
58851: LD_EXP 41
58855: PUSH
58856: LD_VAR 0 4
58860: ARRAY
58861: PPUSH
58862: LD_INT 0
58864: PPUSH
58865: CALL 8845 0 4
58869: PPUSH
58870: CALL_OW 1
58874: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
58875: LD_ADDR_EXP 41
58879: PUSH
58880: LD_EXP 41
58884: PPUSH
58885: LD_VAR 0 4
58889: PPUSH
58890: LD_EXP 41
58894: PUSH
58895: LD_VAR 0 4
58899: ARRAY
58900: PPUSH
58901: LD_EXP 41
58905: PUSH
58906: LD_VAR 0 4
58910: ARRAY
58911: PPUSH
58912: LD_INT 1
58914: PPUSH
58915: LD_INT 0
58917: PPUSH
58918: CALL 8845 0 4
58922: PPUSH
58923: CALL_OW 1
58927: ST_TO_ADDR
// continue ;
58928: GO 58502
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
58930: LD_EXP 43
58934: PUSH
58935: LD_VAR 0 2
58939: ARRAY
58940: PUSH
58941: LD_EXP 44
58945: PUSH
58946: LD_VAR 0 2
58950: ARRAY
58951: NOT
58952: AND
58953: IFFALSE 59080
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
58955: LD_ADDR_EXP 44
58959: PUSH
58960: LD_EXP 44
58964: PPUSH
58965: LD_VAR 0 2
58969: PUSH
58970: LD_EXP 44
58974: PUSH
58975: LD_VAR 0 2
58979: ARRAY
58980: PUSH
58981: LD_INT 1
58983: PLUS
58984: PUSH
58985: EMPTY
58986: LIST
58987: LIST
58988: PPUSH
58989: LD_EXP 43
58993: PUSH
58994: LD_VAR 0 2
58998: ARRAY
58999: PUSH
59000: LD_INT 1
59002: ARRAY
59003: PPUSH
59004: CALL 9427 0 3
59008: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
59009: LD_EXP 43
59013: PUSH
59014: LD_VAR 0 2
59018: ARRAY
59019: PUSH
59020: LD_INT 1
59022: ARRAY
59023: PPUSH
59024: LD_INT 112
59026: PPUSH
59027: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
59031: LD_ADDR_VAR 0 9
59035: PUSH
59036: LD_EXP 43
59040: PUSH
59041: LD_VAR 0 2
59045: ARRAY
59046: PPUSH
59047: LD_INT 1
59049: PPUSH
59050: CALL_OW 3
59054: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
59055: LD_ADDR_EXP 43
59059: PUSH
59060: LD_EXP 43
59064: PPUSH
59065: LD_VAR 0 2
59069: PPUSH
59070: LD_VAR 0 9
59074: PPUSH
59075: CALL_OW 1
59079: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
59080: LD_EXP 43
59084: PUSH
59085: LD_VAR 0 2
59089: ARRAY
59090: PUSH
59091: LD_EXP 44
59095: PUSH
59096: LD_VAR 0 2
59100: ARRAY
59101: AND
59102: PUSH
59103: LD_EXP 44
59107: PUSH
59108: LD_VAR 0 2
59112: ARRAY
59113: PUSH
59114: LD_INT 1
59116: ARRAY
59117: PPUSH
59118: CALL_OW 310
59122: NOT
59123: AND
59124: PUSH
59125: LD_VAR 0 3
59129: PPUSH
59130: CALL_OW 313
59134: PUSH
59135: LD_INT 6
59137: EQUAL
59138: AND
59139: IFFALSE 59195
// begin tmp2 := UnitsInside ( j ) ;
59141: LD_ADDR_VAR 0 9
59145: PUSH
59146: LD_VAR 0 3
59150: PPUSH
59151: CALL_OW 313
59155: ST_TO_ADDR
// if tmp2 = 6 then
59156: LD_VAR 0 9
59160: PUSH
59161: LD_INT 6
59163: EQUAL
59164: IFFALSE 59195
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
59166: LD_VAR 0 9
59170: PUSH
59171: LD_INT 1
59173: ARRAY
59174: PPUSH
59175: LD_INT 112
59177: PPUSH
59178: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
59182: LD_VAR 0 9
59186: PUSH
59187: LD_INT 1
59189: ARRAY
59190: PPUSH
59191: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
59195: LD_EXP 44
59199: PUSH
59200: LD_VAR 0 2
59204: ARRAY
59205: PUSH
59206: LD_EXP 44
59210: PUSH
59211: LD_VAR 0 2
59215: ARRAY
59216: PUSH
59217: LD_INT 1
59219: ARRAY
59220: PPUSH
59221: CALL_OW 314
59225: NOT
59226: AND
59227: PUSH
59228: LD_EXP 44
59232: PUSH
59233: LD_VAR 0 2
59237: ARRAY
59238: PUSH
59239: LD_INT 1
59241: ARRAY
59242: PPUSH
59243: CALL_OW 310
59247: NOT
59248: AND
59249: IFFALSE 59275
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
59251: LD_EXP 44
59255: PUSH
59256: LD_VAR 0 2
59260: ARRAY
59261: PUSH
59262: LD_INT 1
59264: ARRAY
59265: PPUSH
59266: LD_VAR 0 3
59270: PPUSH
59271: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
59275: LD_EXP 44
59279: PUSH
59280: LD_VAR 0 2
59284: ARRAY
59285: PUSH
59286: LD_INT 1
59288: ARRAY
59289: PPUSH
59290: CALL_OW 310
59294: PUSH
59295: LD_EXP 44
59299: PUSH
59300: LD_VAR 0 2
59304: ARRAY
59305: PUSH
59306: LD_INT 1
59308: ARRAY
59309: PPUSH
59310: CALL_OW 310
59314: PPUSH
59315: CALL_OW 461
59319: PUSH
59320: LD_INT 3
59322: NONEQUAL
59323: AND
59324: IFFALSE 59345
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
59326: LD_EXP 44
59330: PUSH
59331: LD_VAR 0 2
59335: ARRAY
59336: PUSH
59337: LD_INT 1
59339: ARRAY
59340: PPUSH
59341: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
59345: LD_VAR 0 3
59349: PPUSH
59350: CALL_OW 461
59354: PUSH
59355: LD_INT 6
59357: EQUAL
59358: PUSH
59359: LD_VAR 0 6
59363: PUSH
59364: LD_INT 1
59366: GREATER
59367: AND
59368: IFFALSE 59520
// begin sci := [ ] ;
59370: LD_ADDR_VAR 0 8
59374: PUSH
59375: EMPTY
59376: ST_TO_ADDR
// for x in ( tmp diff j ) do
59377: LD_ADDR_VAR 0 7
59381: PUSH
59382: LD_VAR 0 6
59386: PUSH
59387: LD_VAR 0 3
59391: DIFF
59392: PUSH
59393: FOR_IN
59394: IFFALSE 59446
// begin if sci = 6 then
59396: LD_VAR 0 8
59400: PUSH
59401: LD_INT 6
59403: EQUAL
59404: IFFALSE 59408
// break ;
59406: GO 59446
// if BuildingStatus ( x ) = bs_idle then
59408: LD_VAR 0 7
59412: PPUSH
59413: CALL_OW 461
59417: PUSH
59418: LD_INT 2
59420: EQUAL
59421: IFFALSE 59444
// sci := sci ^ UnitsInside ( x ) ;
59423: LD_ADDR_VAR 0 8
59427: PUSH
59428: LD_VAR 0 8
59432: PUSH
59433: LD_VAR 0 7
59437: PPUSH
59438: CALL_OW 313
59442: ADD
59443: ST_TO_ADDR
// end ;
59444: GO 59393
59446: POP
59447: POP
// if not sci then
59448: LD_VAR 0 8
59452: NOT
59453: IFFALSE 59457
// continue ;
59455: GO 58502
// for x in sci do
59457: LD_ADDR_VAR 0 7
59461: PUSH
59462: LD_VAR 0 8
59466: PUSH
59467: FOR_IN
59468: IFFALSE 59518
// if IsInUnit ( x ) and not HasTask ( x ) then
59470: LD_VAR 0 7
59474: PPUSH
59475: CALL_OW 310
59479: PUSH
59480: LD_VAR 0 7
59484: PPUSH
59485: CALL_OW 314
59489: NOT
59490: AND
59491: IFFALSE 59516
// begin ComExitBuilding ( x ) ;
59493: LD_VAR 0 7
59497: PPUSH
59498: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
59502: LD_VAR 0 7
59506: PPUSH
59507: LD_VAR 0 3
59511: PPUSH
59512: CALL_OW 180
// end ;
59516: GO 59467
59518: POP
59519: POP
// end ; end ;
59520: GO 58502
59522: POP
59523: POP
// end ;
59524: GO 58456
59526: POP
59527: POP
// end ;
59528: LD_VAR 0 1
59532: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
59533: LD_INT 0
59535: PPUSH
59536: PPUSH
// if not mc_bases then
59537: LD_EXP 14
59541: NOT
59542: IFFALSE 59546
// exit ;
59544: GO 59627
// for i = 1 to mc_bases do
59546: LD_ADDR_VAR 0 2
59550: PUSH
59551: DOUBLE
59552: LD_INT 1
59554: DEC
59555: ST_TO_ADDR
59556: LD_EXP 14
59560: PUSH
59561: FOR_TO
59562: IFFALSE 59625
// if mc_mines [ i ] and mc_miners [ i ] then
59564: LD_EXP 27
59568: PUSH
59569: LD_VAR 0 2
59573: ARRAY
59574: PUSH
59575: LD_EXP 28
59579: PUSH
59580: LD_VAR 0 2
59584: ARRAY
59585: AND
59586: IFFALSE 59623
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
59588: LD_EXP 28
59592: PUSH
59593: LD_VAR 0 2
59597: ARRAY
59598: PUSH
59599: LD_INT 1
59601: ARRAY
59602: PPUSH
59603: CALL_OW 255
59607: PPUSH
59608: LD_EXP 27
59612: PUSH
59613: LD_VAR 0 2
59617: ARRAY
59618: PPUSH
59619: CALL 6416 0 2
59623: GO 59561
59625: POP
59626: POP
// end ;
59627: LD_VAR 0 1
59631: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
59632: LD_INT 0
59634: PPUSH
59635: PPUSH
59636: PPUSH
59637: PPUSH
59638: PPUSH
59639: PPUSH
59640: PPUSH
59641: PPUSH
// if not mc_bases or not mc_parking then
59642: LD_EXP 14
59646: NOT
59647: PUSH
59648: LD_EXP 38
59652: NOT
59653: OR
59654: IFFALSE 59658
// exit ;
59656: GO 60357
// for i = 1 to mc_bases do
59658: LD_ADDR_VAR 0 2
59662: PUSH
59663: DOUBLE
59664: LD_INT 1
59666: DEC
59667: ST_TO_ADDR
59668: LD_EXP 14
59672: PUSH
59673: FOR_TO
59674: IFFALSE 60355
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
59676: LD_EXP 14
59680: PUSH
59681: LD_VAR 0 2
59685: ARRAY
59686: NOT
59687: PUSH
59688: LD_EXP 38
59692: PUSH
59693: LD_VAR 0 2
59697: ARRAY
59698: NOT
59699: OR
59700: IFFALSE 59704
// continue ;
59702: GO 59673
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
59704: LD_ADDR_VAR 0 5
59708: PUSH
59709: LD_EXP 14
59713: PUSH
59714: LD_VAR 0 2
59718: ARRAY
59719: PUSH
59720: LD_INT 1
59722: ARRAY
59723: PPUSH
59724: CALL_OW 255
59728: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
59729: LD_ADDR_VAR 0 6
59733: PUSH
59734: LD_EXP 14
59738: PUSH
59739: LD_VAR 0 2
59743: ARRAY
59744: PPUSH
59745: LD_INT 30
59747: PUSH
59748: LD_INT 3
59750: PUSH
59751: EMPTY
59752: LIST
59753: LIST
59754: PPUSH
59755: CALL_OW 72
59759: ST_TO_ADDR
// if not fac then
59760: LD_VAR 0 6
59764: NOT
59765: IFFALSE 59816
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
59767: LD_ADDR_VAR 0 6
59771: PUSH
59772: LD_EXP 14
59776: PUSH
59777: LD_VAR 0 2
59781: ARRAY
59782: PPUSH
59783: LD_INT 2
59785: PUSH
59786: LD_INT 30
59788: PUSH
59789: LD_INT 0
59791: PUSH
59792: EMPTY
59793: LIST
59794: LIST
59795: PUSH
59796: LD_INT 30
59798: PUSH
59799: LD_INT 1
59801: PUSH
59802: EMPTY
59803: LIST
59804: LIST
59805: PUSH
59806: EMPTY
59807: LIST
59808: LIST
59809: LIST
59810: PPUSH
59811: CALL_OW 72
59815: ST_TO_ADDR
// if not fac then
59816: LD_VAR 0 6
59820: NOT
59821: IFFALSE 59825
// continue ;
59823: GO 59673
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
59825: LD_ADDR_VAR 0 7
59829: PUSH
59830: LD_EXP 38
59834: PUSH
59835: LD_VAR 0 2
59839: ARRAY
59840: PPUSH
59841: LD_INT 22
59843: PUSH
59844: LD_VAR 0 5
59848: PUSH
59849: EMPTY
59850: LIST
59851: LIST
59852: PUSH
59853: LD_INT 21
59855: PUSH
59856: LD_INT 2
59858: PUSH
59859: EMPTY
59860: LIST
59861: LIST
59862: PUSH
59863: LD_INT 3
59865: PUSH
59866: LD_INT 24
59868: PUSH
59869: LD_INT 1000
59871: PUSH
59872: EMPTY
59873: LIST
59874: LIST
59875: PUSH
59876: EMPTY
59877: LIST
59878: LIST
59879: PUSH
59880: EMPTY
59881: LIST
59882: LIST
59883: LIST
59884: PPUSH
59885: CALL_OW 70
59889: ST_TO_ADDR
// for j in fac do
59890: LD_ADDR_VAR 0 3
59894: PUSH
59895: LD_VAR 0 6
59899: PUSH
59900: FOR_IN
59901: IFFALSE 59982
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
59903: LD_ADDR_VAR 0 7
59907: PUSH
59908: LD_VAR 0 7
59912: PUSH
59913: LD_INT 22
59915: PUSH
59916: LD_VAR 0 5
59920: PUSH
59921: EMPTY
59922: LIST
59923: LIST
59924: PUSH
59925: LD_INT 91
59927: PUSH
59928: LD_VAR 0 3
59932: PUSH
59933: LD_INT 15
59935: PUSH
59936: EMPTY
59937: LIST
59938: LIST
59939: LIST
59940: PUSH
59941: LD_INT 21
59943: PUSH
59944: LD_INT 2
59946: PUSH
59947: EMPTY
59948: LIST
59949: LIST
59950: PUSH
59951: LD_INT 3
59953: PUSH
59954: LD_INT 24
59956: PUSH
59957: LD_INT 1000
59959: PUSH
59960: EMPTY
59961: LIST
59962: LIST
59963: PUSH
59964: EMPTY
59965: LIST
59966: LIST
59967: PUSH
59968: EMPTY
59969: LIST
59970: LIST
59971: LIST
59972: LIST
59973: PPUSH
59974: CALL_OW 69
59978: UNION
59979: ST_TO_ADDR
59980: GO 59900
59982: POP
59983: POP
// if not vehs then
59984: LD_VAR 0 7
59988: NOT
59989: IFFALSE 60015
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
59991: LD_ADDR_EXP 26
59995: PUSH
59996: LD_EXP 26
60000: PPUSH
60001: LD_VAR 0 2
60005: PPUSH
60006: EMPTY
60007: PPUSH
60008: CALL_OW 1
60012: ST_TO_ADDR
// continue ;
60013: GO 59673
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
60015: LD_ADDR_VAR 0 8
60019: PUSH
60020: LD_EXP 14
60024: PUSH
60025: LD_VAR 0 2
60029: ARRAY
60030: PPUSH
60031: LD_INT 30
60033: PUSH
60034: LD_INT 3
60036: PUSH
60037: EMPTY
60038: LIST
60039: LIST
60040: PPUSH
60041: CALL_OW 72
60045: ST_TO_ADDR
// if tmp then
60046: LD_VAR 0 8
60050: IFFALSE 60153
// begin for j in tmp do
60052: LD_ADDR_VAR 0 3
60056: PUSH
60057: LD_VAR 0 8
60061: PUSH
60062: FOR_IN
60063: IFFALSE 60151
// for k in UnitsInside ( j ) do
60065: LD_ADDR_VAR 0 4
60069: PUSH
60070: LD_VAR 0 3
60074: PPUSH
60075: CALL_OW 313
60079: PUSH
60080: FOR_IN
60081: IFFALSE 60147
// if k then
60083: LD_VAR 0 4
60087: IFFALSE 60145
// if not k in mc_repair_vehicle [ i ] then
60089: LD_VAR 0 4
60093: PUSH
60094: LD_EXP 26
60098: PUSH
60099: LD_VAR 0 2
60103: ARRAY
60104: IN
60105: NOT
60106: IFFALSE 60145
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
60108: LD_ADDR_EXP 26
60112: PUSH
60113: LD_EXP 26
60117: PPUSH
60118: LD_VAR 0 2
60122: PPUSH
60123: LD_EXP 26
60127: PUSH
60128: LD_VAR 0 2
60132: ARRAY
60133: PUSH
60134: LD_VAR 0 4
60138: UNION
60139: PPUSH
60140: CALL_OW 1
60144: ST_TO_ADDR
60145: GO 60080
60147: POP
60148: POP
60149: GO 60062
60151: POP
60152: POP
// end ; if not mc_repair_vehicle [ i ] then
60153: LD_EXP 26
60157: PUSH
60158: LD_VAR 0 2
60162: ARRAY
60163: NOT
60164: IFFALSE 60168
// continue ;
60166: GO 59673
// for j in mc_repair_vehicle [ i ] do
60168: LD_ADDR_VAR 0 3
60172: PUSH
60173: LD_EXP 26
60177: PUSH
60178: LD_VAR 0 2
60182: ARRAY
60183: PUSH
60184: FOR_IN
60185: IFFALSE 60351
// begin if GetClass ( j ) <> 3 then
60187: LD_VAR 0 3
60191: PPUSH
60192: CALL_OW 257
60196: PUSH
60197: LD_INT 3
60199: NONEQUAL
60200: IFFALSE 60241
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
60202: LD_ADDR_EXP 26
60206: PUSH
60207: LD_EXP 26
60211: PPUSH
60212: LD_VAR 0 2
60216: PPUSH
60217: LD_EXP 26
60221: PUSH
60222: LD_VAR 0 2
60226: ARRAY
60227: PUSH
60228: LD_VAR 0 3
60232: DIFF
60233: PPUSH
60234: CALL_OW 1
60238: ST_TO_ADDR
// continue ;
60239: GO 60184
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
60241: LD_VAR 0 3
60245: PPUSH
60246: CALL_OW 311
60250: NOT
60251: PUSH
60252: LD_VAR 0 3
60256: PUSH
60257: LD_EXP 17
60261: PUSH
60262: LD_VAR 0 2
60266: ARRAY
60267: PUSH
60268: LD_INT 1
60270: ARRAY
60271: IN
60272: NOT
60273: AND
60274: PUSH
60275: LD_VAR 0 3
60279: PUSH
60280: LD_EXP 17
60284: PUSH
60285: LD_VAR 0 2
60289: ARRAY
60290: PUSH
60291: LD_INT 2
60293: ARRAY
60294: IN
60295: NOT
60296: AND
60297: IFFALSE 60349
// begin if IsInUnit ( j ) then
60299: LD_VAR 0 3
60303: PPUSH
60304: CALL_OW 310
60308: IFFALSE 60319
// ComExitBuilding ( j ) ;
60310: LD_VAR 0 3
60314: PPUSH
60315: CALL_OW 122
// if not HasTask ( j ) then
60319: LD_VAR 0 3
60323: PPUSH
60324: CALL_OW 314
60328: NOT
60329: IFFALSE 60349
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
60331: LD_VAR 0 3
60335: PPUSH
60336: LD_VAR 0 7
60340: PUSH
60341: LD_INT 1
60343: ARRAY
60344: PPUSH
60345: CALL_OW 189
// end ; end ;
60349: GO 60184
60351: POP
60352: POP
// end ;
60353: GO 59673
60355: POP
60356: POP
// end ;
60357: LD_VAR 0 1
60361: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
60362: LD_INT 0
60364: PPUSH
60365: PPUSH
60366: PPUSH
60367: PPUSH
60368: PPUSH
60369: PPUSH
60370: PPUSH
60371: PPUSH
60372: PPUSH
60373: PPUSH
60374: PPUSH
// if not mc_bases then
60375: LD_EXP 14
60379: NOT
60380: IFFALSE 60384
// exit ;
60382: GO 61186
// for i = 1 to mc_bases do
60384: LD_ADDR_VAR 0 2
60388: PUSH
60389: DOUBLE
60390: LD_INT 1
60392: DEC
60393: ST_TO_ADDR
60394: LD_EXP 14
60398: PUSH
60399: FOR_TO
60400: IFFALSE 61184
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
60402: LD_EXP 42
60406: PUSH
60407: LD_VAR 0 2
60411: ARRAY
60412: NOT
60413: PUSH
60414: LD_EXP 17
60418: PUSH
60419: LD_VAR 0 2
60423: ARRAY
60424: PUSH
60425: LD_INT 1
60427: ARRAY
60428: OR
60429: PUSH
60430: LD_EXP 17
60434: PUSH
60435: LD_VAR 0 2
60439: ARRAY
60440: PUSH
60441: LD_INT 2
60443: ARRAY
60444: OR
60445: PUSH
60446: LD_EXP 40
60450: PUSH
60451: LD_VAR 0 2
60455: ARRAY
60456: PPUSH
60457: LD_INT 1
60459: PPUSH
60460: CALL_OW 325
60464: NOT
60465: OR
60466: PUSH
60467: LD_EXP 37
60471: PUSH
60472: LD_VAR 0 2
60476: ARRAY
60477: OR
60478: IFFALSE 60482
// continue ;
60480: GO 60399
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
60482: LD_ADDR_VAR 0 8
60486: PUSH
60487: LD_EXP 14
60491: PUSH
60492: LD_VAR 0 2
60496: ARRAY
60497: PPUSH
60498: LD_INT 25
60500: PUSH
60501: LD_INT 4
60503: PUSH
60504: EMPTY
60505: LIST
60506: LIST
60507: PUSH
60508: LD_INT 50
60510: PUSH
60511: EMPTY
60512: LIST
60513: PUSH
60514: LD_INT 3
60516: PUSH
60517: LD_INT 60
60519: PUSH
60520: EMPTY
60521: LIST
60522: PUSH
60523: EMPTY
60524: LIST
60525: LIST
60526: PUSH
60527: EMPTY
60528: LIST
60529: LIST
60530: LIST
60531: PPUSH
60532: CALL_OW 72
60536: PUSH
60537: LD_EXP 18
60541: PUSH
60542: LD_VAR 0 2
60546: ARRAY
60547: DIFF
60548: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60549: LD_ADDR_VAR 0 9
60553: PUSH
60554: LD_EXP 14
60558: PUSH
60559: LD_VAR 0 2
60563: ARRAY
60564: PPUSH
60565: LD_INT 2
60567: PUSH
60568: LD_INT 30
60570: PUSH
60571: LD_INT 0
60573: PUSH
60574: EMPTY
60575: LIST
60576: LIST
60577: PUSH
60578: LD_INT 30
60580: PUSH
60581: LD_INT 1
60583: PUSH
60584: EMPTY
60585: LIST
60586: LIST
60587: PUSH
60588: EMPTY
60589: LIST
60590: LIST
60591: LIST
60592: PPUSH
60593: CALL_OW 72
60597: ST_TO_ADDR
// if not tmp or not dep then
60598: LD_VAR 0 8
60602: NOT
60603: PUSH
60604: LD_VAR 0 9
60608: NOT
60609: OR
60610: IFFALSE 60614
// continue ;
60612: GO 60399
// side := GetSide ( tmp [ 1 ] ) ;
60614: LD_ADDR_VAR 0 11
60618: PUSH
60619: LD_VAR 0 8
60623: PUSH
60624: LD_INT 1
60626: ARRAY
60627: PPUSH
60628: CALL_OW 255
60632: ST_TO_ADDR
// dep := dep [ 1 ] ;
60633: LD_ADDR_VAR 0 9
60637: PUSH
60638: LD_VAR 0 9
60642: PUSH
60643: LD_INT 1
60645: ARRAY
60646: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
60647: LD_ADDR_VAR 0 7
60651: PUSH
60652: LD_EXP 42
60656: PUSH
60657: LD_VAR 0 2
60661: ARRAY
60662: PPUSH
60663: LD_INT 22
60665: PUSH
60666: LD_INT 0
60668: PUSH
60669: EMPTY
60670: LIST
60671: LIST
60672: PUSH
60673: LD_INT 25
60675: PUSH
60676: LD_INT 12
60678: PUSH
60679: EMPTY
60680: LIST
60681: LIST
60682: PUSH
60683: EMPTY
60684: LIST
60685: LIST
60686: PPUSH
60687: CALL_OW 70
60691: PUSH
60692: LD_INT 22
60694: PUSH
60695: LD_INT 0
60697: PUSH
60698: EMPTY
60699: LIST
60700: LIST
60701: PUSH
60702: LD_INT 25
60704: PUSH
60705: LD_INT 12
60707: PUSH
60708: EMPTY
60709: LIST
60710: LIST
60711: PUSH
60712: LD_INT 91
60714: PUSH
60715: LD_VAR 0 9
60719: PUSH
60720: LD_INT 20
60722: PUSH
60723: EMPTY
60724: LIST
60725: LIST
60726: LIST
60727: PUSH
60728: EMPTY
60729: LIST
60730: LIST
60731: LIST
60732: PPUSH
60733: CALL_OW 69
60737: UNION
60738: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
60739: LD_ADDR_VAR 0 10
60743: PUSH
60744: LD_EXP 42
60748: PUSH
60749: LD_VAR 0 2
60753: ARRAY
60754: PPUSH
60755: LD_INT 81
60757: PUSH
60758: LD_VAR 0 11
60762: PUSH
60763: EMPTY
60764: LIST
60765: LIST
60766: PPUSH
60767: CALL_OW 70
60771: ST_TO_ADDR
// if not apes or danger_at_area then
60772: LD_VAR 0 7
60776: NOT
60777: PUSH
60778: LD_VAR 0 10
60782: OR
60783: IFFALSE 60833
// begin if mc_taming [ i ] then
60785: LD_EXP 45
60789: PUSH
60790: LD_VAR 0 2
60794: ARRAY
60795: IFFALSE 60831
// begin MC_Reset ( i , 121 ) ;
60797: LD_VAR 0 2
60801: PPUSH
60802: LD_INT 121
60804: PPUSH
60805: CALL 46215 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
60809: LD_ADDR_EXP 45
60813: PUSH
60814: LD_EXP 45
60818: PPUSH
60819: LD_VAR 0 2
60823: PPUSH
60824: EMPTY
60825: PPUSH
60826: CALL_OW 1
60830: ST_TO_ADDR
// end ; continue ;
60831: GO 60399
// end ; for j in tmp do
60833: LD_ADDR_VAR 0 3
60837: PUSH
60838: LD_VAR 0 8
60842: PUSH
60843: FOR_IN
60844: IFFALSE 61180
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
60846: LD_VAR 0 3
60850: PUSH
60851: LD_EXP 45
60855: PUSH
60856: LD_VAR 0 2
60860: ARRAY
60861: IN
60862: NOT
60863: PUSH
60864: LD_EXP 45
60868: PUSH
60869: LD_VAR 0 2
60873: ARRAY
60874: PUSH
60875: LD_INT 3
60877: LESS
60878: AND
60879: IFFALSE 60937
// begin SetTag ( j , 121 ) ;
60881: LD_VAR 0 3
60885: PPUSH
60886: LD_INT 121
60888: PPUSH
60889: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
60893: LD_ADDR_EXP 45
60897: PUSH
60898: LD_EXP 45
60902: PPUSH
60903: LD_VAR 0 2
60907: PUSH
60908: LD_EXP 45
60912: PUSH
60913: LD_VAR 0 2
60917: ARRAY
60918: PUSH
60919: LD_INT 1
60921: PLUS
60922: PUSH
60923: EMPTY
60924: LIST
60925: LIST
60926: PPUSH
60927: LD_VAR 0 3
60931: PPUSH
60932: CALL 9427 0 3
60936: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
60937: LD_VAR 0 3
60941: PUSH
60942: LD_EXP 45
60946: PUSH
60947: LD_VAR 0 2
60951: ARRAY
60952: IN
60953: IFFALSE 61178
// begin if GetClass ( j ) <> 4 then
60955: LD_VAR 0 3
60959: PPUSH
60960: CALL_OW 257
60964: PUSH
60965: LD_INT 4
60967: NONEQUAL
60968: IFFALSE 61021
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
60970: LD_ADDR_EXP 45
60974: PUSH
60975: LD_EXP 45
60979: PPUSH
60980: LD_VAR 0 2
60984: PPUSH
60985: LD_EXP 45
60989: PUSH
60990: LD_VAR 0 2
60994: ARRAY
60995: PUSH
60996: LD_VAR 0 3
61000: DIFF
61001: PPUSH
61002: CALL_OW 1
61006: ST_TO_ADDR
// SetTag ( j , 0 ) ;
61007: LD_VAR 0 3
61011: PPUSH
61012: LD_INT 0
61014: PPUSH
61015: CALL_OW 109
// continue ;
61019: GO 60843
// end ; if IsInUnit ( j ) then
61021: LD_VAR 0 3
61025: PPUSH
61026: CALL_OW 310
61030: IFFALSE 61041
// ComExitBuilding ( j ) ;
61032: LD_VAR 0 3
61036: PPUSH
61037: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
61041: LD_ADDR_VAR 0 6
61045: PUSH
61046: LD_VAR 0 7
61050: PPUSH
61051: LD_VAR 0 3
61055: PPUSH
61056: CALL_OW 74
61060: ST_TO_ADDR
// if not ape then
61061: LD_VAR 0 6
61065: NOT
61066: IFFALSE 61070
// break ;
61068: GO 61180
// x := GetX ( ape ) ;
61070: LD_ADDR_VAR 0 4
61074: PUSH
61075: LD_VAR 0 6
61079: PPUSH
61080: CALL_OW 250
61084: ST_TO_ADDR
// y := GetY ( ape ) ;
61085: LD_ADDR_VAR 0 5
61089: PUSH
61090: LD_VAR 0 6
61094: PPUSH
61095: CALL_OW 251
61099: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
61100: LD_VAR 0 4
61104: PPUSH
61105: LD_VAR 0 5
61109: PPUSH
61110: CALL_OW 488
61114: NOT
61115: PUSH
61116: LD_VAR 0 11
61120: PPUSH
61121: LD_VAR 0 4
61125: PPUSH
61126: LD_VAR 0 5
61130: PPUSH
61131: LD_INT 20
61133: PPUSH
61134: CALL 10323 0 4
61138: PUSH
61139: LD_INT 4
61141: ARRAY
61142: OR
61143: IFFALSE 61147
// break ;
61145: GO 61180
// if not HasTask ( j ) then
61147: LD_VAR 0 3
61151: PPUSH
61152: CALL_OW 314
61156: NOT
61157: IFFALSE 61178
// ComTameXY ( j , x , y ) ;
61159: LD_VAR 0 3
61163: PPUSH
61164: LD_VAR 0 4
61168: PPUSH
61169: LD_VAR 0 5
61173: PPUSH
61174: CALL_OW 131
// end ; end ;
61178: GO 60843
61180: POP
61181: POP
// end ;
61182: GO 60399
61184: POP
61185: POP
// end ;
61186: LD_VAR 0 1
61190: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
61191: LD_INT 0
61193: PPUSH
61194: PPUSH
61195: PPUSH
61196: PPUSH
61197: PPUSH
61198: PPUSH
61199: PPUSH
61200: PPUSH
// if not mc_bases then
61201: LD_EXP 14
61205: NOT
61206: IFFALSE 61210
// exit ;
61208: GO 61836
// for i = 1 to mc_bases do
61210: LD_ADDR_VAR 0 2
61214: PUSH
61215: DOUBLE
61216: LD_INT 1
61218: DEC
61219: ST_TO_ADDR
61220: LD_EXP 14
61224: PUSH
61225: FOR_TO
61226: IFFALSE 61834
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
61228: LD_EXP 43
61232: PUSH
61233: LD_VAR 0 2
61237: ARRAY
61238: NOT
61239: PUSH
61240: LD_EXP 43
61244: PUSH
61245: LD_VAR 0 2
61249: ARRAY
61250: PPUSH
61251: LD_INT 25
61253: PUSH
61254: LD_INT 12
61256: PUSH
61257: EMPTY
61258: LIST
61259: LIST
61260: PPUSH
61261: CALL_OW 72
61265: NOT
61266: OR
61267: IFFALSE 61271
// continue ;
61269: GO 61225
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
61271: LD_ADDR_VAR 0 5
61275: PUSH
61276: LD_EXP 43
61280: PUSH
61281: LD_VAR 0 2
61285: ARRAY
61286: PUSH
61287: LD_INT 1
61289: ARRAY
61290: PPUSH
61291: CALL_OW 255
61295: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
61296: LD_VAR 0 5
61300: PPUSH
61301: LD_INT 2
61303: PPUSH
61304: CALL_OW 325
61308: IFFALSE 61561
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
61310: LD_ADDR_VAR 0 4
61314: PUSH
61315: LD_EXP 43
61319: PUSH
61320: LD_VAR 0 2
61324: ARRAY
61325: PPUSH
61326: LD_INT 25
61328: PUSH
61329: LD_INT 16
61331: PUSH
61332: EMPTY
61333: LIST
61334: LIST
61335: PPUSH
61336: CALL_OW 72
61340: ST_TO_ADDR
// if tmp < 6 then
61341: LD_VAR 0 4
61345: PUSH
61346: LD_INT 6
61348: LESS
61349: IFFALSE 61561
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61351: LD_ADDR_VAR 0 6
61355: PUSH
61356: LD_EXP 14
61360: PUSH
61361: LD_VAR 0 2
61365: ARRAY
61366: PPUSH
61367: LD_INT 2
61369: PUSH
61370: LD_INT 30
61372: PUSH
61373: LD_INT 0
61375: PUSH
61376: EMPTY
61377: LIST
61378: LIST
61379: PUSH
61380: LD_INT 30
61382: PUSH
61383: LD_INT 1
61385: PUSH
61386: EMPTY
61387: LIST
61388: LIST
61389: PUSH
61390: EMPTY
61391: LIST
61392: LIST
61393: LIST
61394: PPUSH
61395: CALL_OW 72
61399: ST_TO_ADDR
// if depot then
61400: LD_VAR 0 6
61404: IFFALSE 61561
// begin selected := 0 ;
61406: LD_ADDR_VAR 0 7
61410: PUSH
61411: LD_INT 0
61413: ST_TO_ADDR
// for j in depot do
61414: LD_ADDR_VAR 0 3
61418: PUSH
61419: LD_VAR 0 6
61423: PUSH
61424: FOR_IN
61425: IFFALSE 61456
// begin if UnitsInside ( j ) < 6 then
61427: LD_VAR 0 3
61431: PPUSH
61432: CALL_OW 313
61436: PUSH
61437: LD_INT 6
61439: LESS
61440: IFFALSE 61454
// begin selected := j ;
61442: LD_ADDR_VAR 0 7
61446: PUSH
61447: LD_VAR 0 3
61451: ST_TO_ADDR
// break ;
61452: GO 61456
// end ; end ;
61454: GO 61424
61456: POP
61457: POP
// if selected then
61458: LD_VAR 0 7
61462: IFFALSE 61561
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
61464: LD_ADDR_VAR 0 3
61468: PUSH
61469: LD_EXP 43
61473: PUSH
61474: LD_VAR 0 2
61478: ARRAY
61479: PPUSH
61480: LD_INT 25
61482: PUSH
61483: LD_INT 12
61485: PUSH
61486: EMPTY
61487: LIST
61488: LIST
61489: PPUSH
61490: CALL_OW 72
61494: PUSH
61495: FOR_IN
61496: IFFALSE 61559
// if not HasTask ( j ) then
61498: LD_VAR 0 3
61502: PPUSH
61503: CALL_OW 314
61507: NOT
61508: IFFALSE 61557
// begin if not IsInUnit ( j ) then
61510: LD_VAR 0 3
61514: PPUSH
61515: CALL_OW 310
61519: NOT
61520: IFFALSE 61536
// ComEnterUnit ( j , selected ) ;
61522: LD_VAR 0 3
61526: PPUSH
61527: LD_VAR 0 7
61531: PPUSH
61532: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
61536: LD_VAR 0 3
61540: PPUSH
61541: LD_INT 16
61543: PPUSH
61544: CALL_OW 183
// AddComExitBuilding ( j ) ;
61548: LD_VAR 0 3
61552: PPUSH
61553: CALL_OW 182
// end ;
61557: GO 61495
61559: POP
61560: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
61561: LD_VAR 0 5
61565: PPUSH
61566: LD_INT 11
61568: PPUSH
61569: CALL_OW 325
61573: IFFALSE 61832
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
61575: LD_ADDR_VAR 0 4
61579: PUSH
61580: LD_EXP 43
61584: PUSH
61585: LD_VAR 0 2
61589: ARRAY
61590: PPUSH
61591: LD_INT 25
61593: PUSH
61594: LD_INT 16
61596: PUSH
61597: EMPTY
61598: LIST
61599: LIST
61600: PPUSH
61601: CALL_OW 72
61605: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
61606: LD_VAR 0 4
61610: PUSH
61611: LD_INT 6
61613: GREATEREQUAL
61614: PUSH
61615: LD_VAR 0 5
61619: PPUSH
61620: LD_INT 2
61622: PPUSH
61623: CALL_OW 325
61627: NOT
61628: OR
61629: IFFALSE 61832
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
61631: LD_ADDR_VAR 0 8
61635: PUSH
61636: LD_EXP 14
61640: PUSH
61641: LD_VAR 0 2
61645: ARRAY
61646: PPUSH
61647: LD_INT 2
61649: PUSH
61650: LD_INT 30
61652: PUSH
61653: LD_INT 4
61655: PUSH
61656: EMPTY
61657: LIST
61658: LIST
61659: PUSH
61660: LD_INT 30
61662: PUSH
61663: LD_INT 5
61665: PUSH
61666: EMPTY
61667: LIST
61668: LIST
61669: PUSH
61670: EMPTY
61671: LIST
61672: LIST
61673: LIST
61674: PPUSH
61675: CALL_OW 72
61679: ST_TO_ADDR
// if barracks then
61680: LD_VAR 0 8
61684: IFFALSE 61832
// begin selected := 0 ;
61686: LD_ADDR_VAR 0 7
61690: PUSH
61691: LD_INT 0
61693: ST_TO_ADDR
// for j in barracks do
61694: LD_ADDR_VAR 0 3
61698: PUSH
61699: LD_VAR 0 8
61703: PUSH
61704: FOR_IN
61705: IFFALSE 61736
// begin if UnitsInside ( j ) < 6 then
61707: LD_VAR 0 3
61711: PPUSH
61712: CALL_OW 313
61716: PUSH
61717: LD_INT 6
61719: LESS
61720: IFFALSE 61734
// begin selected := j ;
61722: LD_ADDR_VAR 0 7
61726: PUSH
61727: LD_VAR 0 3
61731: ST_TO_ADDR
// break ;
61732: GO 61736
// end ; end ;
61734: GO 61704
61736: POP
61737: POP
// if selected then
61738: LD_VAR 0 7
61742: IFFALSE 61832
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
61744: LD_ADDR_VAR 0 3
61748: PUSH
61749: LD_EXP 43
61753: PUSH
61754: LD_VAR 0 2
61758: ARRAY
61759: PPUSH
61760: LD_INT 25
61762: PUSH
61763: LD_INT 12
61765: PUSH
61766: EMPTY
61767: LIST
61768: LIST
61769: PPUSH
61770: CALL_OW 72
61774: PUSH
61775: FOR_IN
61776: IFFALSE 61830
// if not IsInUnit ( j ) and not HasTask ( j ) then
61778: LD_VAR 0 3
61782: PPUSH
61783: CALL_OW 310
61787: NOT
61788: PUSH
61789: LD_VAR 0 3
61793: PPUSH
61794: CALL_OW 314
61798: NOT
61799: AND
61800: IFFALSE 61828
// begin ComEnterUnit ( j , selected ) ;
61802: LD_VAR 0 3
61806: PPUSH
61807: LD_VAR 0 7
61811: PPUSH
61812: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
61816: LD_VAR 0 3
61820: PPUSH
61821: LD_INT 15
61823: PPUSH
61824: CALL_OW 183
// end ;
61828: GO 61775
61830: POP
61831: POP
// end ; end ; end ; end ; end ;
61832: GO 61225
61834: POP
61835: POP
// end ;
61836: LD_VAR 0 1
61840: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
61841: LD_INT 0
61843: PPUSH
61844: PPUSH
61845: PPUSH
61846: PPUSH
// if not mc_bases then
61847: LD_EXP 14
61851: NOT
61852: IFFALSE 61856
// exit ;
61854: GO 62034
// for i = 1 to mc_bases do
61856: LD_ADDR_VAR 0 2
61860: PUSH
61861: DOUBLE
61862: LD_INT 1
61864: DEC
61865: ST_TO_ADDR
61866: LD_EXP 14
61870: PUSH
61871: FOR_TO
61872: IFFALSE 62032
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
61874: LD_ADDR_VAR 0 4
61878: PUSH
61879: LD_EXP 14
61883: PUSH
61884: LD_VAR 0 2
61888: ARRAY
61889: PPUSH
61890: LD_INT 25
61892: PUSH
61893: LD_INT 9
61895: PUSH
61896: EMPTY
61897: LIST
61898: LIST
61899: PPUSH
61900: CALL_OW 72
61904: ST_TO_ADDR
// if not tmp then
61905: LD_VAR 0 4
61909: NOT
61910: IFFALSE 61914
// continue ;
61912: GO 61871
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
61914: LD_EXP 40
61918: PUSH
61919: LD_VAR 0 2
61923: ARRAY
61924: PPUSH
61925: LD_INT 29
61927: PPUSH
61928: CALL_OW 325
61932: NOT
61933: PUSH
61934: LD_EXP 40
61938: PUSH
61939: LD_VAR 0 2
61943: ARRAY
61944: PPUSH
61945: LD_INT 28
61947: PPUSH
61948: CALL_OW 325
61952: NOT
61953: AND
61954: IFFALSE 61958
// continue ;
61956: GO 61871
// for j in tmp do
61958: LD_ADDR_VAR 0 3
61962: PUSH
61963: LD_VAR 0 4
61967: PUSH
61968: FOR_IN
61969: IFFALSE 62028
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
61971: LD_VAR 0 3
61975: PUSH
61976: LD_EXP 17
61980: PUSH
61981: LD_VAR 0 2
61985: ARRAY
61986: PUSH
61987: LD_INT 1
61989: ARRAY
61990: IN
61991: NOT
61992: PUSH
61993: LD_VAR 0 3
61997: PUSH
61998: LD_EXP 17
62002: PUSH
62003: LD_VAR 0 2
62007: ARRAY
62008: PUSH
62009: LD_INT 2
62011: ARRAY
62012: IN
62013: NOT
62014: AND
62015: IFFALSE 62026
// ComSpaceTimeShoot ( j ) ;
62017: LD_VAR 0 3
62021: PPUSH
62022: CALL 5424 0 1
62026: GO 61968
62028: POP
62029: POP
// end ;
62030: GO 61871
62032: POP
62033: POP
// end ;
62034: LD_VAR 0 1
62038: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
62039: LD_INT 0
62041: PPUSH
62042: PPUSH
62043: PPUSH
62044: PPUSH
62045: PPUSH
62046: PPUSH
62047: PPUSH
62048: PPUSH
62049: PPUSH
// if not mc_bases then
62050: LD_EXP 14
62054: NOT
62055: IFFALSE 62059
// exit ;
62057: GO 62681
// for i = 1 to mc_bases do
62059: LD_ADDR_VAR 0 2
62063: PUSH
62064: DOUBLE
62065: LD_INT 1
62067: DEC
62068: ST_TO_ADDR
62069: LD_EXP 14
62073: PUSH
62074: FOR_TO
62075: IFFALSE 62679
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
62077: LD_EXP 49
62081: PUSH
62082: LD_VAR 0 2
62086: ARRAY
62087: NOT
62088: PUSH
62089: LD_INT 38
62091: PPUSH
62092: LD_EXP 40
62096: PUSH
62097: LD_VAR 0 2
62101: ARRAY
62102: PPUSH
62103: CALL_OW 321
62107: PUSH
62108: LD_INT 2
62110: NONEQUAL
62111: OR
62112: IFFALSE 62116
// continue ;
62114: GO 62074
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
62116: LD_ADDR_VAR 0 8
62120: PUSH
62121: LD_EXP 14
62125: PUSH
62126: LD_VAR 0 2
62130: ARRAY
62131: PPUSH
62132: LD_INT 30
62134: PUSH
62135: LD_INT 34
62137: PUSH
62138: EMPTY
62139: LIST
62140: LIST
62141: PPUSH
62142: CALL_OW 72
62146: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
62147: LD_ADDR_VAR 0 9
62151: PUSH
62152: LD_EXP 14
62156: PUSH
62157: LD_VAR 0 2
62161: ARRAY
62162: PPUSH
62163: LD_INT 25
62165: PUSH
62166: LD_INT 4
62168: PUSH
62169: EMPTY
62170: LIST
62171: LIST
62172: PPUSH
62173: CALL_OW 72
62177: PPUSH
62178: LD_INT 0
62180: PPUSH
62181: CALL 38321 0 2
62185: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
62186: LD_VAR 0 9
62190: NOT
62191: PUSH
62192: LD_VAR 0 8
62196: NOT
62197: OR
62198: PUSH
62199: LD_EXP 14
62203: PUSH
62204: LD_VAR 0 2
62208: ARRAY
62209: PPUSH
62210: LD_INT 124
62212: PPUSH
62213: CALL 38321 0 2
62217: OR
62218: IFFALSE 62222
// continue ;
62220: GO 62074
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
62222: LD_EXP 50
62226: PUSH
62227: LD_VAR 0 2
62231: ARRAY
62232: PUSH
62233: LD_EXP 49
62237: PUSH
62238: LD_VAR 0 2
62242: ARRAY
62243: LESS
62244: PUSH
62245: LD_EXP 50
62249: PUSH
62250: LD_VAR 0 2
62254: ARRAY
62255: PUSH
62256: LD_VAR 0 8
62260: LESS
62261: AND
62262: IFFALSE 62677
// begin tmp := sci [ 1 ] ;
62264: LD_ADDR_VAR 0 7
62268: PUSH
62269: LD_VAR 0 9
62273: PUSH
62274: LD_INT 1
62276: ARRAY
62277: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
62278: LD_VAR 0 7
62282: PPUSH
62283: LD_INT 124
62285: PPUSH
62286: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
62290: LD_ADDR_VAR 0 3
62294: PUSH
62295: DOUBLE
62296: LD_EXP 49
62300: PUSH
62301: LD_VAR 0 2
62305: ARRAY
62306: INC
62307: ST_TO_ADDR
62308: LD_EXP 49
62312: PUSH
62313: LD_VAR 0 2
62317: ARRAY
62318: PUSH
62319: FOR_DOWNTO
62320: IFFALSE 62663
// begin if IsInUnit ( tmp ) then
62322: LD_VAR 0 7
62326: PPUSH
62327: CALL_OW 310
62331: IFFALSE 62342
// ComExitBuilding ( tmp ) ;
62333: LD_VAR 0 7
62337: PPUSH
62338: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
62342: LD_INT 35
62344: PPUSH
62345: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
62349: LD_VAR 0 7
62353: PPUSH
62354: CALL_OW 310
62358: NOT
62359: PUSH
62360: LD_VAR 0 7
62364: PPUSH
62365: CALL_OW 314
62369: NOT
62370: AND
62371: IFFALSE 62342
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
62373: LD_ADDR_VAR 0 6
62377: PUSH
62378: LD_VAR 0 7
62382: PPUSH
62383: CALL_OW 250
62387: PUSH
62388: LD_VAR 0 7
62392: PPUSH
62393: CALL_OW 251
62397: PUSH
62398: EMPTY
62399: LIST
62400: LIST
62401: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
62402: LD_INT 35
62404: PPUSH
62405: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
62409: LD_ADDR_VAR 0 4
62413: PUSH
62414: LD_EXP 49
62418: PUSH
62419: LD_VAR 0 2
62423: ARRAY
62424: PUSH
62425: LD_VAR 0 3
62429: ARRAY
62430: PUSH
62431: LD_INT 1
62433: ARRAY
62434: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
62435: LD_ADDR_VAR 0 5
62439: PUSH
62440: LD_EXP 49
62444: PUSH
62445: LD_VAR 0 2
62449: ARRAY
62450: PUSH
62451: LD_VAR 0 3
62455: ARRAY
62456: PUSH
62457: LD_INT 2
62459: ARRAY
62460: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
62461: LD_VAR 0 7
62465: PPUSH
62466: LD_INT 10
62468: PPUSH
62469: CALL 12020 0 2
62473: PUSH
62474: LD_INT 4
62476: ARRAY
62477: IFFALSE 62515
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
62479: LD_VAR 0 7
62483: PPUSH
62484: LD_VAR 0 6
62488: PUSH
62489: LD_INT 1
62491: ARRAY
62492: PPUSH
62493: LD_VAR 0 6
62497: PUSH
62498: LD_INT 2
62500: ARRAY
62501: PPUSH
62502: CALL_OW 111
// wait ( 0 0$10 ) ;
62506: LD_INT 350
62508: PPUSH
62509: CALL_OW 67
// end else
62513: GO 62541
// begin ComMoveXY ( tmp , x , y ) ;
62515: LD_VAR 0 7
62519: PPUSH
62520: LD_VAR 0 4
62524: PPUSH
62525: LD_VAR 0 5
62529: PPUSH
62530: CALL_OW 111
// wait ( 0 0$3 ) ;
62534: LD_INT 105
62536: PPUSH
62537: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
62541: LD_VAR 0 7
62545: PPUSH
62546: LD_VAR 0 4
62550: PPUSH
62551: LD_VAR 0 5
62555: PPUSH
62556: CALL_OW 307
62560: IFFALSE 62402
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
62562: LD_VAR 0 7
62566: PPUSH
62567: LD_VAR 0 4
62571: PPUSH
62572: LD_VAR 0 5
62576: PPUSH
62577: LD_VAR 0 8
62581: PUSH
62582: LD_VAR 0 3
62586: ARRAY
62587: PPUSH
62588: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
62592: LD_INT 35
62594: PPUSH
62595: CALL_OW 67
// until not HasTask ( tmp ) ;
62599: LD_VAR 0 7
62603: PPUSH
62604: CALL_OW 314
62608: NOT
62609: IFFALSE 62592
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
62611: LD_ADDR_EXP 50
62615: PUSH
62616: LD_EXP 50
62620: PPUSH
62621: LD_VAR 0 2
62625: PUSH
62626: LD_EXP 50
62630: PUSH
62631: LD_VAR 0 2
62635: ARRAY
62636: PUSH
62637: LD_INT 1
62639: PLUS
62640: PUSH
62641: EMPTY
62642: LIST
62643: LIST
62644: PPUSH
62645: LD_VAR 0 8
62649: PUSH
62650: LD_VAR 0 3
62654: ARRAY
62655: PPUSH
62656: CALL 9427 0 3
62660: ST_TO_ADDR
// end ;
62661: GO 62319
62663: POP
62664: POP
// MC_Reset ( i , 124 ) ;
62665: LD_VAR 0 2
62669: PPUSH
62670: LD_INT 124
62672: PPUSH
62673: CALL 46215 0 2
// end ; end ;
62677: GO 62074
62679: POP
62680: POP
// end ;
62681: LD_VAR 0 1
62685: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
62686: LD_INT 0
62688: PPUSH
62689: PPUSH
62690: PPUSH
// if not mc_bases then
62691: LD_EXP 14
62695: NOT
62696: IFFALSE 62700
// exit ;
62698: GO 63306
// for i = 1 to mc_bases do
62700: LD_ADDR_VAR 0 2
62704: PUSH
62705: DOUBLE
62706: LD_INT 1
62708: DEC
62709: ST_TO_ADDR
62710: LD_EXP 14
62714: PUSH
62715: FOR_TO
62716: IFFALSE 63304
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
62718: LD_ADDR_VAR 0 3
62722: PUSH
62723: LD_EXP 14
62727: PUSH
62728: LD_VAR 0 2
62732: ARRAY
62733: PPUSH
62734: LD_INT 25
62736: PUSH
62737: LD_INT 4
62739: PUSH
62740: EMPTY
62741: LIST
62742: LIST
62743: PPUSH
62744: CALL_OW 72
62748: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
62749: LD_VAR 0 3
62753: NOT
62754: PUSH
62755: LD_EXP 51
62759: PUSH
62760: LD_VAR 0 2
62764: ARRAY
62765: NOT
62766: OR
62767: PUSH
62768: LD_EXP 14
62772: PUSH
62773: LD_VAR 0 2
62777: ARRAY
62778: PPUSH
62779: LD_INT 2
62781: PUSH
62782: LD_INT 30
62784: PUSH
62785: LD_INT 0
62787: PUSH
62788: EMPTY
62789: LIST
62790: LIST
62791: PUSH
62792: LD_INT 30
62794: PUSH
62795: LD_INT 1
62797: PUSH
62798: EMPTY
62799: LIST
62800: LIST
62801: PUSH
62802: EMPTY
62803: LIST
62804: LIST
62805: LIST
62806: PPUSH
62807: CALL_OW 72
62811: NOT
62812: OR
62813: IFFALSE 62863
// begin if mc_deposits_finder [ i ] then
62815: LD_EXP 52
62819: PUSH
62820: LD_VAR 0 2
62824: ARRAY
62825: IFFALSE 62861
// begin MC_Reset ( i , 125 ) ;
62827: LD_VAR 0 2
62831: PPUSH
62832: LD_INT 125
62834: PPUSH
62835: CALL 46215 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
62839: LD_ADDR_EXP 52
62843: PUSH
62844: LD_EXP 52
62848: PPUSH
62849: LD_VAR 0 2
62853: PPUSH
62854: EMPTY
62855: PPUSH
62856: CALL_OW 1
62860: ST_TO_ADDR
// end ; continue ;
62861: GO 62715
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
62863: LD_EXP 51
62867: PUSH
62868: LD_VAR 0 2
62872: ARRAY
62873: PUSH
62874: LD_INT 1
62876: ARRAY
62877: PUSH
62878: LD_INT 3
62880: ARRAY
62881: PUSH
62882: LD_INT 1
62884: EQUAL
62885: PUSH
62886: LD_INT 20
62888: PPUSH
62889: LD_EXP 40
62893: PUSH
62894: LD_VAR 0 2
62898: ARRAY
62899: PPUSH
62900: CALL_OW 321
62904: PUSH
62905: LD_INT 2
62907: NONEQUAL
62908: AND
62909: IFFALSE 62959
// begin if mc_deposits_finder [ i ] then
62911: LD_EXP 52
62915: PUSH
62916: LD_VAR 0 2
62920: ARRAY
62921: IFFALSE 62957
// begin MC_Reset ( i , 125 ) ;
62923: LD_VAR 0 2
62927: PPUSH
62928: LD_INT 125
62930: PPUSH
62931: CALL 46215 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
62935: LD_ADDR_EXP 52
62939: PUSH
62940: LD_EXP 52
62944: PPUSH
62945: LD_VAR 0 2
62949: PPUSH
62950: EMPTY
62951: PPUSH
62952: CALL_OW 1
62956: ST_TO_ADDR
// end ; continue ;
62957: GO 62715
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
62959: LD_EXP 51
62963: PUSH
62964: LD_VAR 0 2
62968: ARRAY
62969: PUSH
62970: LD_INT 1
62972: ARRAY
62973: PUSH
62974: LD_INT 1
62976: ARRAY
62977: PPUSH
62978: LD_EXP 51
62982: PUSH
62983: LD_VAR 0 2
62987: ARRAY
62988: PUSH
62989: LD_INT 1
62991: ARRAY
62992: PUSH
62993: LD_INT 2
62995: ARRAY
62996: PPUSH
62997: LD_EXP 40
63001: PUSH
63002: LD_VAR 0 2
63006: ARRAY
63007: PPUSH
63008: CALL_OW 440
63012: IFFALSE 63055
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
63014: LD_ADDR_EXP 51
63018: PUSH
63019: LD_EXP 51
63023: PPUSH
63024: LD_VAR 0 2
63028: PPUSH
63029: LD_EXP 51
63033: PUSH
63034: LD_VAR 0 2
63038: ARRAY
63039: PPUSH
63040: LD_INT 1
63042: PPUSH
63043: CALL_OW 3
63047: PPUSH
63048: CALL_OW 1
63052: ST_TO_ADDR
63053: GO 63302
// begin if not mc_deposits_finder [ i ] then
63055: LD_EXP 52
63059: PUSH
63060: LD_VAR 0 2
63064: ARRAY
63065: NOT
63066: IFFALSE 63118
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
63068: LD_ADDR_EXP 52
63072: PUSH
63073: LD_EXP 52
63077: PPUSH
63078: LD_VAR 0 2
63082: PPUSH
63083: LD_VAR 0 3
63087: PUSH
63088: LD_INT 1
63090: ARRAY
63091: PUSH
63092: EMPTY
63093: LIST
63094: PPUSH
63095: CALL_OW 1
63099: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
63100: LD_VAR 0 3
63104: PUSH
63105: LD_INT 1
63107: ARRAY
63108: PPUSH
63109: LD_INT 125
63111: PPUSH
63112: CALL_OW 109
// end else
63116: GO 63302
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
63118: LD_EXP 52
63122: PUSH
63123: LD_VAR 0 2
63127: ARRAY
63128: PUSH
63129: LD_INT 1
63131: ARRAY
63132: PPUSH
63133: CALL_OW 310
63137: IFFALSE 63160
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
63139: LD_EXP 52
63143: PUSH
63144: LD_VAR 0 2
63148: ARRAY
63149: PUSH
63150: LD_INT 1
63152: ARRAY
63153: PPUSH
63154: CALL_OW 122
63158: GO 63302
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
63160: LD_EXP 52
63164: PUSH
63165: LD_VAR 0 2
63169: ARRAY
63170: PUSH
63171: LD_INT 1
63173: ARRAY
63174: PPUSH
63175: CALL_OW 314
63179: NOT
63180: PUSH
63181: LD_EXP 52
63185: PUSH
63186: LD_VAR 0 2
63190: ARRAY
63191: PUSH
63192: LD_INT 1
63194: ARRAY
63195: PPUSH
63196: LD_EXP 51
63200: PUSH
63201: LD_VAR 0 2
63205: ARRAY
63206: PUSH
63207: LD_INT 1
63209: ARRAY
63210: PUSH
63211: LD_INT 1
63213: ARRAY
63214: PPUSH
63215: LD_EXP 51
63219: PUSH
63220: LD_VAR 0 2
63224: ARRAY
63225: PUSH
63226: LD_INT 1
63228: ARRAY
63229: PUSH
63230: LD_INT 2
63232: ARRAY
63233: PPUSH
63234: CALL_OW 297
63238: PUSH
63239: LD_INT 6
63241: GREATER
63242: AND
63243: IFFALSE 63302
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
63245: LD_EXP 52
63249: PUSH
63250: LD_VAR 0 2
63254: ARRAY
63255: PUSH
63256: LD_INT 1
63258: ARRAY
63259: PPUSH
63260: LD_EXP 51
63264: PUSH
63265: LD_VAR 0 2
63269: ARRAY
63270: PUSH
63271: LD_INT 1
63273: ARRAY
63274: PUSH
63275: LD_INT 1
63277: ARRAY
63278: PPUSH
63279: LD_EXP 51
63283: PUSH
63284: LD_VAR 0 2
63288: ARRAY
63289: PUSH
63290: LD_INT 1
63292: ARRAY
63293: PUSH
63294: LD_INT 2
63296: ARRAY
63297: PPUSH
63298: CALL_OW 111
// end ; end ; end ;
63302: GO 62715
63304: POP
63305: POP
// end ;
63306: LD_VAR 0 1
63310: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
63311: LD_INT 0
63313: PPUSH
63314: PPUSH
63315: PPUSH
63316: PPUSH
63317: PPUSH
63318: PPUSH
63319: PPUSH
63320: PPUSH
63321: PPUSH
63322: PPUSH
63323: PPUSH
// if not mc_bases then
63324: LD_EXP 14
63328: NOT
63329: IFFALSE 63333
// exit ;
63331: GO 64273
// for i = 1 to mc_bases do
63333: LD_ADDR_VAR 0 2
63337: PUSH
63338: DOUBLE
63339: LD_INT 1
63341: DEC
63342: ST_TO_ADDR
63343: LD_EXP 14
63347: PUSH
63348: FOR_TO
63349: IFFALSE 64271
// begin if not mc_bases [ i ] or mc_scan [ i ] then
63351: LD_EXP 14
63355: PUSH
63356: LD_VAR 0 2
63360: ARRAY
63361: NOT
63362: PUSH
63363: LD_EXP 37
63367: PUSH
63368: LD_VAR 0 2
63372: ARRAY
63373: OR
63374: IFFALSE 63378
// continue ;
63376: GO 63348
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
63378: LD_ADDR_VAR 0 7
63382: PUSH
63383: LD_EXP 14
63387: PUSH
63388: LD_VAR 0 2
63392: ARRAY
63393: PUSH
63394: LD_INT 1
63396: ARRAY
63397: PPUSH
63398: CALL_OW 248
63402: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
63403: LD_VAR 0 7
63407: PUSH
63408: LD_INT 3
63410: EQUAL
63411: PUSH
63412: LD_EXP 33
63416: PUSH
63417: LD_VAR 0 2
63421: ARRAY
63422: PUSH
63423: LD_EXP 36
63427: PUSH
63428: LD_VAR 0 2
63432: ARRAY
63433: UNION
63434: PPUSH
63435: LD_INT 33
63437: PUSH
63438: LD_INT 2
63440: PUSH
63441: EMPTY
63442: LIST
63443: LIST
63444: PPUSH
63445: CALL_OW 72
63449: NOT
63450: OR
63451: IFFALSE 63455
// continue ;
63453: GO 63348
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
63455: LD_ADDR_VAR 0 9
63459: PUSH
63460: LD_EXP 14
63464: PUSH
63465: LD_VAR 0 2
63469: ARRAY
63470: PPUSH
63471: LD_INT 30
63473: PUSH
63474: LD_INT 36
63476: PUSH
63477: EMPTY
63478: LIST
63479: LIST
63480: PPUSH
63481: CALL_OW 72
63485: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
63486: LD_ADDR_VAR 0 10
63490: PUSH
63491: LD_EXP 33
63495: PUSH
63496: LD_VAR 0 2
63500: ARRAY
63501: PPUSH
63502: LD_INT 34
63504: PUSH
63505: LD_INT 31
63507: PUSH
63508: EMPTY
63509: LIST
63510: LIST
63511: PPUSH
63512: CALL_OW 72
63516: ST_TO_ADDR
// if not cts and not mcts then
63517: LD_VAR 0 9
63521: NOT
63522: PUSH
63523: LD_VAR 0 10
63527: NOT
63528: AND
63529: IFFALSE 63533
// continue ;
63531: GO 63348
// x := cts ;
63533: LD_ADDR_VAR 0 11
63537: PUSH
63538: LD_VAR 0 9
63542: ST_TO_ADDR
// if not x then
63543: LD_VAR 0 11
63547: NOT
63548: IFFALSE 63560
// x := mcts ;
63550: LD_ADDR_VAR 0 11
63554: PUSH
63555: LD_VAR 0 10
63559: ST_TO_ADDR
// if not x then
63560: LD_VAR 0 11
63564: NOT
63565: IFFALSE 63569
// continue ;
63567: GO 63348
// if mc_remote_driver [ i ] then
63569: LD_EXP 54
63573: PUSH
63574: LD_VAR 0 2
63578: ARRAY
63579: IFFALSE 63966
// for j in mc_remote_driver [ i ] do
63581: LD_ADDR_VAR 0 3
63585: PUSH
63586: LD_EXP 54
63590: PUSH
63591: LD_VAR 0 2
63595: ARRAY
63596: PUSH
63597: FOR_IN
63598: IFFALSE 63964
// begin if GetClass ( j ) <> 3 then
63600: LD_VAR 0 3
63604: PPUSH
63605: CALL_OW 257
63609: PUSH
63610: LD_INT 3
63612: NONEQUAL
63613: IFFALSE 63666
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
63615: LD_ADDR_EXP 54
63619: PUSH
63620: LD_EXP 54
63624: PPUSH
63625: LD_VAR 0 2
63629: PPUSH
63630: LD_EXP 54
63634: PUSH
63635: LD_VAR 0 2
63639: ARRAY
63640: PUSH
63641: LD_VAR 0 3
63645: DIFF
63646: PPUSH
63647: CALL_OW 1
63651: ST_TO_ADDR
// SetTag ( j , 0 ) ;
63652: LD_VAR 0 3
63656: PPUSH
63657: LD_INT 0
63659: PPUSH
63660: CALL_OW 109
// continue ;
63664: GO 63597
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
63666: LD_EXP 33
63670: PUSH
63671: LD_VAR 0 2
63675: ARRAY
63676: PPUSH
63677: LD_INT 34
63679: PUSH
63680: LD_INT 31
63682: PUSH
63683: EMPTY
63684: LIST
63685: LIST
63686: PUSH
63687: LD_INT 58
63689: PUSH
63690: EMPTY
63691: LIST
63692: PUSH
63693: EMPTY
63694: LIST
63695: LIST
63696: PPUSH
63697: CALL_OW 72
63701: PUSH
63702: LD_VAR 0 3
63706: PPUSH
63707: CALL 38409 0 1
63711: NOT
63712: AND
63713: IFFALSE 63784
// begin if IsInUnit ( j ) then
63715: LD_VAR 0 3
63719: PPUSH
63720: CALL_OW 310
63724: IFFALSE 63735
// ComExitBuilding ( j ) ;
63726: LD_VAR 0 3
63730: PPUSH
63731: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
63735: LD_VAR 0 3
63739: PPUSH
63740: LD_EXP 33
63744: PUSH
63745: LD_VAR 0 2
63749: ARRAY
63750: PPUSH
63751: LD_INT 34
63753: PUSH
63754: LD_INT 31
63756: PUSH
63757: EMPTY
63758: LIST
63759: LIST
63760: PUSH
63761: LD_INT 58
63763: PUSH
63764: EMPTY
63765: LIST
63766: PUSH
63767: EMPTY
63768: LIST
63769: LIST
63770: PPUSH
63771: CALL_OW 72
63775: PUSH
63776: LD_INT 1
63778: ARRAY
63779: PPUSH
63780: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
63784: LD_VAR 0 3
63788: PPUSH
63789: CALL_OW 310
63793: NOT
63794: PUSH
63795: LD_VAR 0 3
63799: PPUSH
63800: CALL_OW 310
63804: PPUSH
63805: CALL_OW 266
63809: PUSH
63810: LD_INT 36
63812: NONEQUAL
63813: PUSH
63814: LD_VAR 0 3
63818: PPUSH
63819: CALL 38409 0 1
63823: NOT
63824: AND
63825: OR
63826: IFFALSE 63962
// begin if IsInUnit ( j ) then
63828: LD_VAR 0 3
63832: PPUSH
63833: CALL_OW 310
63837: IFFALSE 63848
// ComExitBuilding ( j ) ;
63839: LD_VAR 0 3
63843: PPUSH
63844: CALL_OW 122
// ct := 0 ;
63848: LD_ADDR_VAR 0 8
63852: PUSH
63853: LD_INT 0
63855: ST_TO_ADDR
// for k in x do
63856: LD_ADDR_VAR 0 4
63860: PUSH
63861: LD_VAR 0 11
63865: PUSH
63866: FOR_IN
63867: IFFALSE 63940
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
63869: LD_VAR 0 4
63873: PPUSH
63874: CALL_OW 264
63878: PUSH
63879: LD_INT 31
63881: EQUAL
63882: PUSH
63883: LD_VAR 0 4
63887: PPUSH
63888: CALL_OW 311
63892: NOT
63893: AND
63894: PUSH
63895: LD_VAR 0 4
63899: PPUSH
63900: CALL_OW 266
63904: PUSH
63905: LD_INT 36
63907: EQUAL
63908: PUSH
63909: LD_VAR 0 4
63913: PPUSH
63914: CALL_OW 313
63918: PUSH
63919: LD_INT 3
63921: LESS
63922: AND
63923: OR
63924: IFFALSE 63938
// begin ct := k ;
63926: LD_ADDR_VAR 0 8
63930: PUSH
63931: LD_VAR 0 4
63935: ST_TO_ADDR
// break ;
63936: GO 63940
// end ;
63938: GO 63866
63940: POP
63941: POP
// if ct then
63942: LD_VAR 0 8
63946: IFFALSE 63962
// ComEnterUnit ( j , ct ) ;
63948: LD_VAR 0 3
63952: PPUSH
63953: LD_VAR 0 8
63957: PPUSH
63958: CALL_OW 120
// end ; end ;
63962: GO 63597
63964: POP
63965: POP
// places := 0 ;
63966: LD_ADDR_VAR 0 5
63970: PUSH
63971: LD_INT 0
63973: ST_TO_ADDR
// for j = 1 to x do
63974: LD_ADDR_VAR 0 3
63978: PUSH
63979: DOUBLE
63980: LD_INT 1
63982: DEC
63983: ST_TO_ADDR
63984: LD_VAR 0 11
63988: PUSH
63989: FOR_TO
63990: IFFALSE 64066
// if GetWeapon ( x [ j ] ) = ar_control_tower then
63992: LD_VAR 0 11
63996: PUSH
63997: LD_VAR 0 3
64001: ARRAY
64002: PPUSH
64003: CALL_OW 264
64007: PUSH
64008: LD_INT 31
64010: EQUAL
64011: IFFALSE 64029
// places := places + 1 else
64013: LD_ADDR_VAR 0 5
64017: PUSH
64018: LD_VAR 0 5
64022: PUSH
64023: LD_INT 1
64025: PLUS
64026: ST_TO_ADDR
64027: GO 64064
// if GetBType ( x [ j ] ) = b_control_tower then
64029: LD_VAR 0 11
64033: PUSH
64034: LD_VAR 0 3
64038: ARRAY
64039: PPUSH
64040: CALL_OW 266
64044: PUSH
64045: LD_INT 36
64047: EQUAL
64048: IFFALSE 64064
// places := places + 3 ;
64050: LD_ADDR_VAR 0 5
64054: PUSH
64055: LD_VAR 0 5
64059: PUSH
64060: LD_INT 3
64062: PLUS
64063: ST_TO_ADDR
64064: GO 63989
64066: POP
64067: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
64068: LD_VAR 0 5
64072: PUSH
64073: LD_INT 0
64075: EQUAL
64076: PUSH
64077: LD_VAR 0 5
64081: PUSH
64082: LD_EXP 54
64086: PUSH
64087: LD_VAR 0 2
64091: ARRAY
64092: LESSEQUAL
64093: OR
64094: IFFALSE 64098
// continue ;
64096: GO 63348
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
64098: LD_ADDR_VAR 0 6
64102: PUSH
64103: LD_EXP 14
64107: PUSH
64108: LD_VAR 0 2
64112: ARRAY
64113: PPUSH
64114: LD_INT 25
64116: PUSH
64117: LD_INT 3
64119: PUSH
64120: EMPTY
64121: LIST
64122: LIST
64123: PPUSH
64124: CALL_OW 72
64128: PUSH
64129: LD_EXP 54
64133: PUSH
64134: LD_VAR 0 2
64138: ARRAY
64139: DIFF
64140: PPUSH
64141: LD_INT 3
64143: PPUSH
64144: CALL 39309 0 2
64148: ST_TO_ADDR
// for j in tmp do
64149: LD_ADDR_VAR 0 3
64153: PUSH
64154: LD_VAR 0 6
64158: PUSH
64159: FOR_IN
64160: IFFALSE 64195
// if GetTag ( j ) > 0 then
64162: LD_VAR 0 3
64166: PPUSH
64167: CALL_OW 110
64171: PUSH
64172: LD_INT 0
64174: GREATER
64175: IFFALSE 64193
// tmp := tmp diff j ;
64177: LD_ADDR_VAR 0 6
64181: PUSH
64182: LD_VAR 0 6
64186: PUSH
64187: LD_VAR 0 3
64191: DIFF
64192: ST_TO_ADDR
64193: GO 64159
64195: POP
64196: POP
// if not tmp then
64197: LD_VAR 0 6
64201: NOT
64202: IFFALSE 64206
// continue ;
64204: GO 63348
// if places then
64206: LD_VAR 0 5
64210: IFFALSE 64269
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
64212: LD_ADDR_EXP 54
64216: PUSH
64217: LD_EXP 54
64221: PPUSH
64222: LD_VAR 0 2
64226: PPUSH
64227: LD_EXP 54
64231: PUSH
64232: LD_VAR 0 2
64236: ARRAY
64237: PUSH
64238: LD_VAR 0 6
64242: PUSH
64243: LD_INT 1
64245: ARRAY
64246: UNION
64247: PPUSH
64248: CALL_OW 1
64252: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
64253: LD_VAR 0 6
64257: PUSH
64258: LD_INT 1
64260: ARRAY
64261: PPUSH
64262: LD_INT 126
64264: PPUSH
64265: CALL_OW 109
// end ; end ;
64269: GO 63348
64271: POP
64272: POP
// end ;
64273: LD_VAR 0 1
64277: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
64278: LD_INT 0
64280: PPUSH
64281: PPUSH
64282: PPUSH
64283: PPUSH
64284: PPUSH
64285: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
64286: LD_VAR 0 1
64290: NOT
64291: PUSH
64292: LD_VAR 0 2
64296: NOT
64297: OR
64298: PUSH
64299: LD_VAR 0 3
64303: NOT
64304: OR
64305: PUSH
64306: LD_VAR 0 4
64310: PUSH
64311: LD_INT 1
64313: PUSH
64314: LD_INT 2
64316: PUSH
64317: LD_INT 3
64319: PUSH
64320: LD_INT 4
64322: PUSH
64323: LD_INT 5
64325: PUSH
64326: LD_INT 8
64328: PUSH
64329: LD_INT 9
64331: PUSH
64332: LD_INT 15
64334: PUSH
64335: LD_INT 16
64337: PUSH
64338: EMPTY
64339: LIST
64340: LIST
64341: LIST
64342: LIST
64343: LIST
64344: LIST
64345: LIST
64346: LIST
64347: LIST
64348: IN
64349: NOT
64350: OR
64351: IFFALSE 64355
// exit ;
64353: GO 65255
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
64355: LD_ADDR_VAR 0 2
64359: PUSH
64360: LD_VAR 0 2
64364: PPUSH
64365: LD_INT 21
64367: PUSH
64368: LD_INT 3
64370: PUSH
64371: EMPTY
64372: LIST
64373: LIST
64374: PUSH
64375: LD_INT 24
64377: PUSH
64378: LD_INT 250
64380: PUSH
64381: EMPTY
64382: LIST
64383: LIST
64384: PUSH
64385: EMPTY
64386: LIST
64387: LIST
64388: PPUSH
64389: CALL_OW 72
64393: ST_TO_ADDR
// case class of 1 , 15 :
64394: LD_VAR 0 4
64398: PUSH
64399: LD_INT 1
64401: DOUBLE
64402: EQUAL
64403: IFTRUE 64413
64405: LD_INT 15
64407: DOUBLE
64408: EQUAL
64409: IFTRUE 64413
64411: GO 64498
64413: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
64414: LD_ADDR_VAR 0 8
64418: PUSH
64419: LD_VAR 0 2
64423: PPUSH
64424: LD_INT 2
64426: PUSH
64427: LD_INT 30
64429: PUSH
64430: LD_INT 32
64432: PUSH
64433: EMPTY
64434: LIST
64435: LIST
64436: PUSH
64437: LD_INT 30
64439: PUSH
64440: LD_INT 31
64442: PUSH
64443: EMPTY
64444: LIST
64445: LIST
64446: PUSH
64447: EMPTY
64448: LIST
64449: LIST
64450: LIST
64451: PPUSH
64452: CALL_OW 72
64456: PUSH
64457: LD_VAR 0 2
64461: PPUSH
64462: LD_INT 2
64464: PUSH
64465: LD_INT 30
64467: PUSH
64468: LD_INT 4
64470: PUSH
64471: EMPTY
64472: LIST
64473: LIST
64474: PUSH
64475: LD_INT 30
64477: PUSH
64478: LD_INT 5
64480: PUSH
64481: EMPTY
64482: LIST
64483: LIST
64484: PUSH
64485: EMPTY
64486: LIST
64487: LIST
64488: LIST
64489: PPUSH
64490: CALL_OW 72
64494: ADD
64495: ST_TO_ADDR
64496: GO 64744
64498: LD_INT 2
64500: DOUBLE
64501: EQUAL
64502: IFTRUE 64512
64504: LD_INT 16
64506: DOUBLE
64507: EQUAL
64508: IFTRUE 64512
64510: GO 64558
64512: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
64513: LD_ADDR_VAR 0 8
64517: PUSH
64518: LD_VAR 0 2
64522: PPUSH
64523: LD_INT 2
64525: PUSH
64526: LD_INT 30
64528: PUSH
64529: LD_INT 0
64531: PUSH
64532: EMPTY
64533: LIST
64534: LIST
64535: PUSH
64536: LD_INT 30
64538: PUSH
64539: LD_INT 1
64541: PUSH
64542: EMPTY
64543: LIST
64544: LIST
64545: PUSH
64546: EMPTY
64547: LIST
64548: LIST
64549: LIST
64550: PPUSH
64551: CALL_OW 72
64555: ST_TO_ADDR
64556: GO 64744
64558: LD_INT 3
64560: DOUBLE
64561: EQUAL
64562: IFTRUE 64566
64564: GO 64612
64566: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
64567: LD_ADDR_VAR 0 8
64571: PUSH
64572: LD_VAR 0 2
64576: PPUSH
64577: LD_INT 2
64579: PUSH
64580: LD_INT 30
64582: PUSH
64583: LD_INT 2
64585: PUSH
64586: EMPTY
64587: LIST
64588: LIST
64589: PUSH
64590: LD_INT 30
64592: PUSH
64593: LD_INT 3
64595: PUSH
64596: EMPTY
64597: LIST
64598: LIST
64599: PUSH
64600: EMPTY
64601: LIST
64602: LIST
64603: LIST
64604: PPUSH
64605: CALL_OW 72
64609: ST_TO_ADDR
64610: GO 64744
64612: LD_INT 4
64614: DOUBLE
64615: EQUAL
64616: IFTRUE 64620
64618: GO 64677
64620: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
64621: LD_ADDR_VAR 0 8
64625: PUSH
64626: LD_VAR 0 2
64630: PPUSH
64631: LD_INT 2
64633: PUSH
64634: LD_INT 30
64636: PUSH
64637: LD_INT 6
64639: PUSH
64640: EMPTY
64641: LIST
64642: LIST
64643: PUSH
64644: LD_INT 30
64646: PUSH
64647: LD_INT 7
64649: PUSH
64650: EMPTY
64651: LIST
64652: LIST
64653: PUSH
64654: LD_INT 30
64656: PUSH
64657: LD_INT 8
64659: PUSH
64660: EMPTY
64661: LIST
64662: LIST
64663: PUSH
64664: EMPTY
64665: LIST
64666: LIST
64667: LIST
64668: LIST
64669: PPUSH
64670: CALL_OW 72
64674: ST_TO_ADDR
64675: GO 64744
64677: LD_INT 5
64679: DOUBLE
64680: EQUAL
64681: IFTRUE 64697
64683: LD_INT 8
64685: DOUBLE
64686: EQUAL
64687: IFTRUE 64697
64689: LD_INT 9
64691: DOUBLE
64692: EQUAL
64693: IFTRUE 64697
64695: GO 64743
64697: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
64698: LD_ADDR_VAR 0 8
64702: PUSH
64703: LD_VAR 0 2
64707: PPUSH
64708: LD_INT 2
64710: PUSH
64711: LD_INT 30
64713: PUSH
64714: LD_INT 4
64716: PUSH
64717: EMPTY
64718: LIST
64719: LIST
64720: PUSH
64721: LD_INT 30
64723: PUSH
64724: LD_INT 5
64726: PUSH
64727: EMPTY
64728: LIST
64729: LIST
64730: PUSH
64731: EMPTY
64732: LIST
64733: LIST
64734: LIST
64735: PPUSH
64736: CALL_OW 72
64740: ST_TO_ADDR
64741: GO 64744
64743: POP
// if not tmp then
64744: LD_VAR 0 8
64748: NOT
64749: IFFALSE 64753
// exit ;
64751: GO 65255
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
64753: LD_VAR 0 4
64757: PUSH
64758: LD_INT 1
64760: PUSH
64761: LD_INT 15
64763: PUSH
64764: EMPTY
64765: LIST
64766: LIST
64767: IN
64768: PUSH
64769: LD_EXP 23
64773: PUSH
64774: LD_VAR 0 1
64778: ARRAY
64779: AND
64780: IFFALSE 64936
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
64782: LD_ADDR_VAR 0 9
64786: PUSH
64787: LD_EXP 23
64791: PUSH
64792: LD_VAR 0 1
64796: ARRAY
64797: PUSH
64798: LD_INT 1
64800: ARRAY
64801: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
64802: LD_VAR 0 9
64806: PUSH
64807: LD_EXP 24
64811: PUSH
64812: LD_VAR 0 1
64816: ARRAY
64817: IN
64818: NOT
64819: IFFALSE 64934
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
64821: LD_ADDR_EXP 24
64825: PUSH
64826: LD_EXP 24
64830: PPUSH
64831: LD_VAR 0 1
64835: PUSH
64836: LD_EXP 24
64840: PUSH
64841: LD_VAR 0 1
64845: ARRAY
64846: PUSH
64847: LD_INT 1
64849: PLUS
64850: PUSH
64851: EMPTY
64852: LIST
64853: LIST
64854: PPUSH
64855: LD_VAR 0 9
64859: PPUSH
64860: CALL 9427 0 3
64864: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
64865: LD_ADDR_EXP 23
64869: PUSH
64870: LD_EXP 23
64874: PPUSH
64875: LD_VAR 0 1
64879: PPUSH
64880: LD_EXP 23
64884: PUSH
64885: LD_VAR 0 1
64889: ARRAY
64890: PUSH
64891: LD_VAR 0 9
64895: DIFF
64896: PPUSH
64897: CALL_OW 1
64901: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
64902: LD_VAR 0 3
64906: PPUSH
64907: LD_EXP 24
64911: PUSH
64912: LD_VAR 0 1
64916: ARRAY
64917: PUSH
64918: LD_EXP 24
64922: PUSH
64923: LD_VAR 0 1
64927: ARRAY
64928: ARRAY
64929: PPUSH
64930: CALL_OW 120
// end ; exit ;
64934: GO 65255
// end ; if tmp > 1 then
64936: LD_VAR 0 8
64940: PUSH
64941: LD_INT 1
64943: GREATER
64944: IFFALSE 65048
// for i = 2 to tmp do
64946: LD_ADDR_VAR 0 6
64950: PUSH
64951: DOUBLE
64952: LD_INT 2
64954: DEC
64955: ST_TO_ADDR
64956: LD_VAR 0 8
64960: PUSH
64961: FOR_TO
64962: IFFALSE 65046
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
64964: LD_VAR 0 8
64968: PUSH
64969: LD_VAR 0 6
64973: ARRAY
64974: PPUSH
64975: CALL_OW 461
64979: PUSH
64980: LD_INT 6
64982: EQUAL
64983: IFFALSE 65044
// begin x := tmp [ i ] ;
64985: LD_ADDR_VAR 0 9
64989: PUSH
64990: LD_VAR 0 8
64994: PUSH
64995: LD_VAR 0 6
64999: ARRAY
65000: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
65001: LD_ADDR_VAR 0 8
65005: PUSH
65006: LD_VAR 0 8
65010: PPUSH
65011: LD_VAR 0 6
65015: PPUSH
65016: CALL_OW 3
65020: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
65021: LD_ADDR_VAR 0 8
65025: PUSH
65026: LD_VAR 0 8
65030: PPUSH
65031: LD_INT 1
65033: PPUSH
65034: LD_VAR 0 9
65038: PPUSH
65039: CALL_OW 2
65043: ST_TO_ADDR
// end ;
65044: GO 64961
65046: POP
65047: POP
// for i in tmp do
65048: LD_ADDR_VAR 0 6
65052: PUSH
65053: LD_VAR 0 8
65057: PUSH
65058: FOR_IN
65059: IFFALSE 65128
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
65061: LD_VAR 0 6
65065: PPUSH
65066: CALL_OW 313
65070: PUSH
65071: LD_INT 6
65073: LESS
65074: PUSH
65075: LD_VAR 0 6
65079: PPUSH
65080: CALL_OW 266
65084: PUSH
65085: LD_INT 31
65087: PUSH
65088: LD_INT 32
65090: PUSH
65091: EMPTY
65092: LIST
65093: LIST
65094: IN
65095: NOT
65096: AND
65097: PUSH
65098: LD_VAR 0 6
65102: PPUSH
65103: CALL_OW 313
65107: PUSH
65108: LD_INT 0
65110: EQUAL
65111: OR
65112: IFFALSE 65126
// begin j := i ;
65114: LD_ADDR_VAR 0 7
65118: PUSH
65119: LD_VAR 0 6
65123: ST_TO_ADDR
// break ;
65124: GO 65128
// end ; end ;
65126: GO 65058
65128: POP
65129: POP
// if j then
65130: LD_VAR 0 7
65134: IFFALSE 65152
// ComEnterUnit ( unit , j ) else
65136: LD_VAR 0 3
65140: PPUSH
65141: LD_VAR 0 7
65145: PPUSH
65146: CALL_OW 120
65150: GO 65255
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65152: LD_ADDR_VAR 0 10
65156: PUSH
65157: LD_VAR 0 2
65161: PPUSH
65162: LD_INT 2
65164: PUSH
65165: LD_INT 30
65167: PUSH
65168: LD_INT 0
65170: PUSH
65171: EMPTY
65172: LIST
65173: LIST
65174: PUSH
65175: LD_INT 30
65177: PUSH
65178: LD_INT 1
65180: PUSH
65181: EMPTY
65182: LIST
65183: LIST
65184: PUSH
65185: EMPTY
65186: LIST
65187: LIST
65188: LIST
65189: PPUSH
65190: CALL_OW 72
65194: ST_TO_ADDR
// if depot then
65195: LD_VAR 0 10
65199: IFFALSE 65255
// begin depot := NearestUnitToUnit ( depot , unit ) ;
65201: LD_ADDR_VAR 0 10
65205: PUSH
65206: LD_VAR 0 10
65210: PPUSH
65211: LD_VAR 0 3
65215: PPUSH
65216: CALL_OW 74
65220: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
65221: LD_VAR 0 3
65225: PPUSH
65226: LD_VAR 0 10
65230: PPUSH
65231: CALL_OW 296
65235: PUSH
65236: LD_INT 10
65238: GREATER
65239: IFFALSE 65255
// ComStandNearbyBuilding ( unit , depot ) ;
65241: LD_VAR 0 3
65245: PPUSH
65246: LD_VAR 0 10
65250: PPUSH
65251: CALL 6041 0 2
// end ; end ; end ;
65255: LD_VAR 0 5
65259: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
65260: LD_INT 0
65262: PPUSH
65263: PPUSH
65264: PPUSH
65265: PPUSH
// if not mc_bases then
65266: LD_EXP 14
65270: NOT
65271: IFFALSE 65275
// exit ;
65273: GO 65514
// for i = 1 to mc_bases do
65275: LD_ADDR_VAR 0 2
65279: PUSH
65280: DOUBLE
65281: LD_INT 1
65283: DEC
65284: ST_TO_ADDR
65285: LD_EXP 14
65289: PUSH
65290: FOR_TO
65291: IFFALSE 65512
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
65293: LD_ADDR_VAR 0 4
65297: PUSH
65298: LD_EXP 14
65302: PUSH
65303: LD_VAR 0 2
65307: ARRAY
65308: PPUSH
65309: LD_INT 21
65311: PUSH
65312: LD_INT 1
65314: PUSH
65315: EMPTY
65316: LIST
65317: LIST
65318: PPUSH
65319: CALL_OW 72
65323: PUSH
65324: LD_EXP 43
65328: PUSH
65329: LD_VAR 0 2
65333: ARRAY
65334: UNION
65335: ST_TO_ADDR
// if not tmp then
65336: LD_VAR 0 4
65340: NOT
65341: IFFALSE 65345
// continue ;
65343: GO 65290
// for j in tmp do
65345: LD_ADDR_VAR 0 3
65349: PUSH
65350: LD_VAR 0 4
65354: PUSH
65355: FOR_IN
65356: IFFALSE 65508
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
65358: LD_VAR 0 3
65362: PPUSH
65363: CALL_OW 110
65367: NOT
65368: PUSH
65369: LD_VAR 0 3
65373: PPUSH
65374: CALL_OW 314
65378: NOT
65379: AND
65380: PUSH
65381: LD_VAR 0 3
65385: PPUSH
65386: CALL_OW 311
65390: NOT
65391: AND
65392: PUSH
65393: LD_VAR 0 3
65397: PPUSH
65398: CALL_OW 310
65402: NOT
65403: AND
65404: PUSH
65405: LD_VAR 0 3
65409: PUSH
65410: LD_EXP 17
65414: PUSH
65415: LD_VAR 0 2
65419: ARRAY
65420: PUSH
65421: LD_INT 1
65423: ARRAY
65424: IN
65425: NOT
65426: AND
65427: PUSH
65428: LD_VAR 0 3
65432: PUSH
65433: LD_EXP 17
65437: PUSH
65438: LD_VAR 0 2
65442: ARRAY
65443: PUSH
65444: LD_INT 2
65446: ARRAY
65447: IN
65448: NOT
65449: AND
65450: PUSH
65451: LD_VAR 0 3
65455: PUSH
65456: LD_EXP 26
65460: PUSH
65461: LD_VAR 0 2
65465: ARRAY
65466: IN
65467: NOT
65468: AND
65469: IFFALSE 65506
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
65471: LD_VAR 0 2
65475: PPUSH
65476: LD_EXP 14
65480: PUSH
65481: LD_VAR 0 2
65485: ARRAY
65486: PPUSH
65487: LD_VAR 0 3
65491: PPUSH
65492: LD_VAR 0 3
65496: PPUSH
65497: CALL_OW 257
65501: PPUSH
65502: CALL 64278 0 4
// end ;
65506: GO 65355
65508: POP
65509: POP
// end ;
65510: GO 65290
65512: POP
65513: POP
// end ;
65514: LD_VAR 0 1
65518: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
65519: LD_INT 0
65521: PPUSH
65522: PPUSH
65523: PPUSH
65524: PPUSH
65525: PPUSH
65526: PPUSH
// if not mc_bases [ base ] then
65527: LD_EXP 14
65531: PUSH
65532: LD_VAR 0 1
65536: ARRAY
65537: NOT
65538: IFFALSE 65542
// exit ;
65540: GO 65724
// tmp := [ ] ;
65542: LD_ADDR_VAR 0 6
65546: PUSH
65547: EMPTY
65548: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
65549: LD_ADDR_VAR 0 7
65553: PUSH
65554: LD_VAR 0 3
65558: PPUSH
65559: LD_INT 0
65561: PPUSH
65562: CALL_OW 517
65566: ST_TO_ADDR
// if not list then
65567: LD_VAR 0 7
65571: NOT
65572: IFFALSE 65576
// exit ;
65574: GO 65724
// for i = 1 to amount do
65576: LD_ADDR_VAR 0 5
65580: PUSH
65581: DOUBLE
65582: LD_INT 1
65584: DEC
65585: ST_TO_ADDR
65586: LD_VAR 0 2
65590: PUSH
65591: FOR_TO
65592: IFFALSE 65672
// begin x := rand ( 1 , list [ 1 ] ) ;
65594: LD_ADDR_VAR 0 8
65598: PUSH
65599: LD_INT 1
65601: PPUSH
65602: LD_VAR 0 7
65606: PUSH
65607: LD_INT 1
65609: ARRAY
65610: PPUSH
65611: CALL_OW 12
65615: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
65616: LD_ADDR_VAR 0 6
65620: PUSH
65621: LD_VAR 0 6
65625: PPUSH
65626: LD_VAR 0 5
65630: PPUSH
65631: LD_VAR 0 7
65635: PUSH
65636: LD_INT 1
65638: ARRAY
65639: PUSH
65640: LD_VAR 0 8
65644: ARRAY
65645: PUSH
65646: LD_VAR 0 7
65650: PUSH
65651: LD_INT 2
65653: ARRAY
65654: PUSH
65655: LD_VAR 0 8
65659: ARRAY
65660: PUSH
65661: EMPTY
65662: LIST
65663: LIST
65664: PPUSH
65665: CALL_OW 1
65669: ST_TO_ADDR
// end ;
65670: GO 65591
65672: POP
65673: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
65674: LD_ADDR_EXP 27
65678: PUSH
65679: LD_EXP 27
65683: PPUSH
65684: LD_VAR 0 1
65688: PPUSH
65689: LD_VAR 0 6
65693: PPUSH
65694: CALL_OW 1
65698: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
65699: LD_ADDR_EXP 29
65703: PUSH
65704: LD_EXP 29
65708: PPUSH
65709: LD_VAR 0 1
65713: PPUSH
65714: LD_VAR 0 3
65718: PPUSH
65719: CALL_OW 1
65723: ST_TO_ADDR
// end ;
65724: LD_VAR 0 4
65728: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
65729: LD_INT 0
65731: PPUSH
// if not mc_bases [ base ] then
65732: LD_EXP 14
65736: PUSH
65737: LD_VAR 0 1
65741: ARRAY
65742: NOT
65743: IFFALSE 65747
// exit ;
65745: GO 65772
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
65747: LD_ADDR_EXP 19
65751: PUSH
65752: LD_EXP 19
65756: PPUSH
65757: LD_VAR 0 1
65761: PPUSH
65762: LD_VAR 0 2
65766: PPUSH
65767: CALL_OW 1
65771: ST_TO_ADDR
// end ;
65772: LD_VAR 0 3
65776: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
65777: LD_INT 0
65779: PPUSH
// if not mc_bases [ base ] then
65780: LD_EXP 14
65784: PUSH
65785: LD_VAR 0 1
65789: ARRAY
65790: NOT
65791: IFFALSE 65795
// exit ;
65793: GO 65832
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
65795: LD_ADDR_EXP 19
65799: PUSH
65800: LD_EXP 19
65804: PPUSH
65805: LD_VAR 0 1
65809: PPUSH
65810: LD_EXP 19
65814: PUSH
65815: LD_VAR 0 1
65819: ARRAY
65820: PUSH
65821: LD_VAR 0 2
65825: UNION
65826: PPUSH
65827: CALL_OW 1
65831: ST_TO_ADDR
// end ;
65832: LD_VAR 0 3
65836: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
65837: LD_INT 0
65839: PPUSH
// if not mc_bases [ base ] then
65840: LD_EXP 14
65844: PUSH
65845: LD_VAR 0 1
65849: ARRAY
65850: NOT
65851: IFFALSE 65855
// exit ;
65853: GO 65880
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
65855: LD_ADDR_EXP 35
65859: PUSH
65860: LD_EXP 35
65864: PPUSH
65865: LD_VAR 0 1
65869: PPUSH
65870: LD_VAR 0 2
65874: PPUSH
65875: CALL_OW 1
65879: ST_TO_ADDR
// end ;
65880: LD_VAR 0 3
65884: RET
// export function MC_InsertProduceList ( base , components ) ; begin
65885: LD_INT 0
65887: PPUSH
// if not mc_bases [ base ] then
65888: LD_EXP 14
65892: PUSH
65893: LD_VAR 0 1
65897: ARRAY
65898: NOT
65899: IFFALSE 65903
// exit ;
65901: GO 65940
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
65903: LD_ADDR_EXP 35
65907: PUSH
65908: LD_EXP 35
65912: PPUSH
65913: LD_VAR 0 1
65917: PPUSH
65918: LD_EXP 35
65922: PUSH
65923: LD_VAR 0 1
65927: ARRAY
65928: PUSH
65929: LD_VAR 0 2
65933: ADD
65934: PPUSH
65935: CALL_OW 1
65939: ST_TO_ADDR
// end ;
65940: LD_VAR 0 3
65944: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
65945: LD_INT 0
65947: PPUSH
// if not mc_bases [ base ] then
65948: LD_EXP 14
65952: PUSH
65953: LD_VAR 0 1
65957: ARRAY
65958: NOT
65959: IFFALSE 65963
// exit ;
65961: GO 66017
// mc_defender := Replace ( mc_defender , base , deflist ) ;
65963: LD_ADDR_EXP 36
65967: PUSH
65968: LD_EXP 36
65972: PPUSH
65973: LD_VAR 0 1
65977: PPUSH
65978: LD_VAR 0 2
65982: PPUSH
65983: CALL_OW 1
65987: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
65988: LD_ADDR_EXP 25
65992: PUSH
65993: LD_EXP 25
65997: PPUSH
65998: LD_VAR 0 1
66002: PPUSH
66003: LD_VAR 0 2
66007: PUSH
66008: LD_INT 0
66010: PLUS
66011: PPUSH
66012: CALL_OW 1
66016: ST_TO_ADDR
// end ;
66017: LD_VAR 0 3
66021: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
66022: LD_INT 0
66024: PPUSH
// if not mc_bases [ base ] then
66025: LD_EXP 14
66029: PUSH
66030: LD_VAR 0 1
66034: ARRAY
66035: NOT
66036: IFFALSE 66040
// exit ;
66038: GO 66065
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
66040: LD_ADDR_EXP 25
66044: PUSH
66045: LD_EXP 25
66049: PPUSH
66050: LD_VAR 0 1
66054: PPUSH
66055: LD_VAR 0 2
66059: PPUSH
66060: CALL_OW 1
66064: ST_TO_ADDR
// end ;
66065: LD_VAR 0 3
66069: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
66070: LD_INT 0
66072: PPUSH
66073: PPUSH
66074: PPUSH
66075: PPUSH
// if not mc_bases [ base ] then
66076: LD_EXP 14
66080: PUSH
66081: LD_VAR 0 1
66085: ARRAY
66086: NOT
66087: IFFALSE 66091
// exit ;
66089: GO 66156
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
66091: LD_ADDR_EXP 34
66095: PUSH
66096: LD_EXP 34
66100: PPUSH
66101: LD_VAR 0 1
66105: PUSH
66106: LD_EXP 34
66110: PUSH
66111: LD_VAR 0 1
66115: ARRAY
66116: PUSH
66117: LD_INT 1
66119: PLUS
66120: PUSH
66121: EMPTY
66122: LIST
66123: LIST
66124: PPUSH
66125: LD_VAR 0 1
66129: PUSH
66130: LD_VAR 0 2
66134: PUSH
66135: LD_VAR 0 3
66139: PUSH
66140: LD_VAR 0 4
66144: PUSH
66145: EMPTY
66146: LIST
66147: LIST
66148: LIST
66149: LIST
66150: PPUSH
66151: CALL 9427 0 3
66155: ST_TO_ADDR
// end ;
66156: LD_VAR 0 5
66160: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
66161: LD_INT 0
66163: PPUSH
// if not mc_bases [ base ] then
66164: LD_EXP 14
66168: PUSH
66169: LD_VAR 0 1
66173: ARRAY
66174: NOT
66175: IFFALSE 66179
// exit ;
66177: GO 66204
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
66179: LD_ADDR_EXP 51
66183: PUSH
66184: LD_EXP 51
66188: PPUSH
66189: LD_VAR 0 1
66193: PPUSH
66194: LD_VAR 0 2
66198: PPUSH
66199: CALL_OW 1
66203: ST_TO_ADDR
// end ;
66204: LD_VAR 0 3
66208: RET
// export function MC_GetMinesField ( base ) ; begin
66209: LD_INT 0
66211: PPUSH
// result := mc_mines [ base ] ;
66212: LD_ADDR_VAR 0 2
66216: PUSH
66217: LD_EXP 27
66221: PUSH
66222: LD_VAR 0 1
66226: ARRAY
66227: ST_TO_ADDR
// end ;
66228: LD_VAR 0 2
66232: RET
// export function MC_GetProduceList ( base ) ; begin
66233: LD_INT 0
66235: PPUSH
// result := mc_produce [ base ] ;
66236: LD_ADDR_VAR 0 2
66240: PUSH
66241: LD_EXP 35
66245: PUSH
66246: LD_VAR 0 1
66250: ARRAY
66251: ST_TO_ADDR
// end ;
66252: LD_VAR 0 2
66256: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
66257: LD_INT 0
66259: PPUSH
66260: PPUSH
// if not mc_bases then
66261: LD_EXP 14
66265: NOT
66266: IFFALSE 66270
// exit ;
66268: GO 66335
// if mc_bases [ base ] then
66270: LD_EXP 14
66274: PUSH
66275: LD_VAR 0 1
66279: ARRAY
66280: IFFALSE 66335
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
66282: LD_ADDR_VAR 0 3
66286: PUSH
66287: LD_EXP 14
66291: PUSH
66292: LD_VAR 0 1
66296: ARRAY
66297: PPUSH
66298: LD_INT 30
66300: PUSH
66301: LD_VAR 0 2
66305: PUSH
66306: EMPTY
66307: LIST
66308: LIST
66309: PPUSH
66310: CALL_OW 72
66314: ST_TO_ADDR
// if result then
66315: LD_VAR 0 3
66319: IFFALSE 66335
// result := result [ 1 ] ;
66321: LD_ADDR_VAR 0 3
66325: PUSH
66326: LD_VAR 0 3
66330: PUSH
66331: LD_INT 1
66333: ARRAY
66334: ST_TO_ADDR
// end ; end ;
66335: LD_VAR 0 3
66339: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
66340: LD_INT 0
66342: PPUSH
66343: PPUSH
// if not mc_bases then
66344: LD_EXP 14
66348: NOT
66349: IFFALSE 66353
// exit ;
66351: GO 66398
// if mc_bases [ base ] then
66353: LD_EXP 14
66357: PUSH
66358: LD_VAR 0 1
66362: ARRAY
66363: IFFALSE 66398
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
66365: LD_ADDR_VAR 0 3
66369: PUSH
66370: LD_EXP 14
66374: PUSH
66375: LD_VAR 0 1
66379: ARRAY
66380: PPUSH
66381: LD_INT 30
66383: PUSH
66384: LD_VAR 0 2
66388: PUSH
66389: EMPTY
66390: LIST
66391: LIST
66392: PPUSH
66393: CALL_OW 72
66397: ST_TO_ADDR
// end ;
66398: LD_VAR 0 3
66402: RET
// export function MC_SetTame ( base , area ) ; begin
66403: LD_INT 0
66405: PPUSH
// if not mc_bases or not base then
66406: LD_EXP 14
66410: NOT
66411: PUSH
66412: LD_VAR 0 1
66416: NOT
66417: OR
66418: IFFALSE 66422
// exit ;
66420: GO 66447
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
66422: LD_ADDR_EXP 42
66426: PUSH
66427: LD_EXP 42
66431: PPUSH
66432: LD_VAR 0 1
66436: PPUSH
66437: LD_VAR 0 2
66441: PPUSH
66442: CALL_OW 1
66446: ST_TO_ADDR
// end ;
66447: LD_VAR 0 3
66451: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
66452: LD_INT 0
66454: PPUSH
66455: PPUSH
// if not mc_bases or not base then
66456: LD_EXP 14
66460: NOT
66461: PUSH
66462: LD_VAR 0 1
66466: NOT
66467: OR
66468: IFFALSE 66472
// exit ;
66470: GO 66574
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
66472: LD_ADDR_VAR 0 4
66476: PUSH
66477: LD_EXP 14
66481: PUSH
66482: LD_VAR 0 1
66486: ARRAY
66487: PPUSH
66488: LD_INT 30
66490: PUSH
66491: LD_VAR 0 2
66495: PUSH
66496: EMPTY
66497: LIST
66498: LIST
66499: PPUSH
66500: CALL_OW 72
66504: ST_TO_ADDR
// if not tmp then
66505: LD_VAR 0 4
66509: NOT
66510: IFFALSE 66514
// exit ;
66512: GO 66574
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
66514: LD_ADDR_EXP 46
66518: PUSH
66519: LD_EXP 46
66523: PPUSH
66524: LD_VAR 0 1
66528: PPUSH
66529: LD_EXP 46
66533: PUSH
66534: LD_VAR 0 1
66538: ARRAY
66539: PPUSH
66540: LD_EXP 46
66544: PUSH
66545: LD_VAR 0 1
66549: ARRAY
66550: PUSH
66551: LD_INT 1
66553: PLUS
66554: PPUSH
66555: LD_VAR 0 4
66559: PUSH
66560: LD_INT 1
66562: ARRAY
66563: PPUSH
66564: CALL_OW 2
66568: PPUSH
66569: CALL_OW 1
66573: ST_TO_ADDR
// end ;
66574: LD_VAR 0 3
66578: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
66579: LD_INT 0
66581: PPUSH
66582: PPUSH
// if not mc_bases or not base or not kinds then
66583: LD_EXP 14
66587: NOT
66588: PUSH
66589: LD_VAR 0 1
66593: NOT
66594: OR
66595: PUSH
66596: LD_VAR 0 2
66600: NOT
66601: OR
66602: IFFALSE 66606
// exit ;
66604: GO 66667
// for i in kinds do
66606: LD_ADDR_VAR 0 4
66610: PUSH
66611: LD_VAR 0 2
66615: PUSH
66616: FOR_IN
66617: IFFALSE 66665
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
66619: LD_ADDR_EXP 48
66623: PUSH
66624: LD_EXP 48
66628: PPUSH
66629: LD_VAR 0 1
66633: PUSH
66634: LD_EXP 48
66638: PUSH
66639: LD_VAR 0 1
66643: ARRAY
66644: PUSH
66645: LD_INT 1
66647: PLUS
66648: PUSH
66649: EMPTY
66650: LIST
66651: LIST
66652: PPUSH
66653: LD_VAR 0 4
66657: PPUSH
66658: CALL 9427 0 3
66662: ST_TO_ADDR
66663: GO 66616
66665: POP
66666: POP
// end ;
66667: LD_VAR 0 3
66671: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
66672: LD_INT 0
66674: PPUSH
// if not mc_bases or not base or not areas then
66675: LD_EXP 14
66679: NOT
66680: PUSH
66681: LD_VAR 0 1
66685: NOT
66686: OR
66687: PUSH
66688: LD_VAR 0 2
66692: NOT
66693: OR
66694: IFFALSE 66698
// exit ;
66696: GO 66723
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
66698: LD_ADDR_EXP 32
66702: PUSH
66703: LD_EXP 32
66707: PPUSH
66708: LD_VAR 0 1
66712: PPUSH
66713: LD_VAR 0 2
66717: PPUSH
66718: CALL_OW 1
66722: ST_TO_ADDR
// end ;
66723: LD_VAR 0 3
66727: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
66728: LD_INT 0
66730: PPUSH
// if not mc_bases or not base or not teleports_exit then
66731: LD_EXP 14
66735: NOT
66736: PUSH
66737: LD_VAR 0 1
66741: NOT
66742: OR
66743: PUSH
66744: LD_VAR 0 2
66748: NOT
66749: OR
66750: IFFALSE 66754
// exit ;
66752: GO 66779
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
66754: LD_ADDR_EXP 49
66758: PUSH
66759: LD_EXP 49
66763: PPUSH
66764: LD_VAR 0 1
66768: PPUSH
66769: LD_VAR 0 2
66773: PPUSH
66774: CALL_OW 1
66778: ST_TO_ADDR
// end ;
66779: LD_VAR 0 3
66783: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
66784: LD_INT 0
66786: PPUSH
66787: PPUSH
66788: PPUSH
// if not mc_bases or not base or not ext_list then
66789: LD_EXP 14
66793: NOT
66794: PUSH
66795: LD_VAR 0 1
66799: NOT
66800: OR
66801: PUSH
66802: LD_VAR 0 5
66806: NOT
66807: OR
66808: IFFALSE 66812
// exit ;
66810: GO 66985
// tmp := GetFacExtXYD ( x , y , d ) ;
66812: LD_ADDR_VAR 0 8
66816: PUSH
66817: LD_VAR 0 2
66821: PPUSH
66822: LD_VAR 0 3
66826: PPUSH
66827: LD_VAR 0 4
66831: PPUSH
66832: CALL 38439 0 3
66836: ST_TO_ADDR
// if not tmp then
66837: LD_VAR 0 8
66841: NOT
66842: IFFALSE 66846
// exit ;
66844: GO 66985
// for i in tmp do
66846: LD_ADDR_VAR 0 7
66850: PUSH
66851: LD_VAR 0 8
66855: PUSH
66856: FOR_IN
66857: IFFALSE 66983
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
66859: LD_ADDR_EXP 19
66863: PUSH
66864: LD_EXP 19
66868: PPUSH
66869: LD_VAR 0 1
66873: PPUSH
66874: LD_EXP 19
66878: PUSH
66879: LD_VAR 0 1
66883: ARRAY
66884: PPUSH
66885: LD_EXP 19
66889: PUSH
66890: LD_VAR 0 1
66894: ARRAY
66895: PUSH
66896: LD_INT 1
66898: PLUS
66899: PPUSH
66900: LD_VAR 0 5
66904: PUSH
66905: LD_INT 1
66907: ARRAY
66908: PUSH
66909: LD_VAR 0 7
66913: PUSH
66914: LD_INT 1
66916: ARRAY
66917: PUSH
66918: LD_VAR 0 7
66922: PUSH
66923: LD_INT 2
66925: ARRAY
66926: PUSH
66927: LD_VAR 0 7
66931: PUSH
66932: LD_INT 3
66934: ARRAY
66935: PUSH
66936: EMPTY
66937: LIST
66938: LIST
66939: LIST
66940: LIST
66941: PPUSH
66942: CALL_OW 2
66946: PPUSH
66947: CALL_OW 1
66951: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
66952: LD_ADDR_VAR 0 5
66956: PUSH
66957: LD_VAR 0 5
66961: PPUSH
66962: LD_INT 1
66964: PPUSH
66965: CALL_OW 3
66969: ST_TO_ADDR
// if not ext_list then
66970: LD_VAR 0 5
66974: NOT
66975: IFFALSE 66981
// exit ;
66977: POP
66978: POP
66979: GO 66985
// end ;
66981: GO 66856
66983: POP
66984: POP
// end ;
66985: LD_VAR 0 6
66989: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
66990: LD_INT 0
66992: PPUSH
// if not mc_bases or not base or not weapon_list then
66993: LD_EXP 14
66997: NOT
66998: PUSH
66999: LD_VAR 0 1
67003: NOT
67004: OR
67005: PUSH
67006: LD_VAR 0 2
67010: NOT
67011: OR
67012: IFFALSE 67016
// exit ;
67014: GO 67041
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
67016: LD_ADDR_EXP 53
67020: PUSH
67021: LD_EXP 53
67025: PPUSH
67026: LD_VAR 0 1
67030: PPUSH
67031: LD_VAR 0 2
67035: PPUSH
67036: CALL_OW 1
67040: ST_TO_ADDR
// end ;
67041: LD_VAR 0 3
67045: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
67046: LD_INT 0
67048: PPUSH
// if not mc_bases or not base or not tech_list then
67049: LD_EXP 14
67053: NOT
67054: PUSH
67055: LD_VAR 0 1
67059: NOT
67060: OR
67061: PUSH
67062: LD_VAR 0 2
67066: NOT
67067: OR
67068: IFFALSE 67072
// exit ;
67070: GO 67097
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
67072: LD_ADDR_EXP 41
67076: PUSH
67077: LD_EXP 41
67081: PPUSH
67082: LD_VAR 0 1
67086: PPUSH
67087: LD_VAR 0 2
67091: PPUSH
67092: CALL_OW 1
67096: ST_TO_ADDR
// end ;
67097: LD_VAR 0 3
67101: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
67102: LD_INT 0
67104: PPUSH
// if not mc_bases or not parking_area or not base then
67105: LD_EXP 14
67109: NOT
67110: PUSH
67111: LD_VAR 0 2
67115: NOT
67116: OR
67117: PUSH
67118: LD_VAR 0 1
67122: NOT
67123: OR
67124: IFFALSE 67128
// exit ;
67126: GO 67153
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
67128: LD_ADDR_EXP 38
67132: PUSH
67133: LD_EXP 38
67137: PPUSH
67138: LD_VAR 0 1
67142: PPUSH
67143: LD_VAR 0 2
67147: PPUSH
67148: CALL_OW 1
67152: ST_TO_ADDR
// end ;
67153: LD_VAR 0 3
67157: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
67158: LD_INT 0
67160: PPUSH
// if not mc_bases or not base or not scan_area then
67161: LD_EXP 14
67165: NOT
67166: PUSH
67167: LD_VAR 0 1
67171: NOT
67172: OR
67173: PUSH
67174: LD_VAR 0 2
67178: NOT
67179: OR
67180: IFFALSE 67184
// exit ;
67182: GO 67209
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
67184: LD_ADDR_EXP 39
67188: PUSH
67189: LD_EXP 39
67193: PPUSH
67194: LD_VAR 0 1
67198: PPUSH
67199: LD_VAR 0 2
67203: PPUSH
67204: CALL_OW 1
67208: ST_TO_ADDR
// end ;
67209: LD_VAR 0 3
67213: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
67214: LD_INT 0
67216: PPUSH
67217: PPUSH
// if not mc_bases or not base then
67218: LD_EXP 14
67222: NOT
67223: PUSH
67224: LD_VAR 0 1
67228: NOT
67229: OR
67230: IFFALSE 67234
// exit ;
67232: GO 67298
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
67234: LD_ADDR_VAR 0 3
67238: PUSH
67239: LD_INT 1
67241: PUSH
67242: LD_INT 2
67244: PUSH
67245: LD_INT 3
67247: PUSH
67248: LD_INT 4
67250: PUSH
67251: LD_INT 11
67253: PUSH
67254: EMPTY
67255: LIST
67256: LIST
67257: LIST
67258: LIST
67259: LIST
67260: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
67261: LD_ADDR_EXP 41
67265: PUSH
67266: LD_EXP 41
67270: PPUSH
67271: LD_VAR 0 1
67275: PPUSH
67276: LD_EXP 41
67280: PUSH
67281: LD_VAR 0 1
67285: ARRAY
67286: PUSH
67287: LD_VAR 0 3
67291: DIFF
67292: PPUSH
67293: CALL_OW 1
67297: ST_TO_ADDR
// end ;
67298: LD_VAR 0 2
67302: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
67303: LD_INT 0
67305: PPUSH
// result := mc_vehicles [ base ] ;
67306: LD_ADDR_VAR 0 3
67310: PUSH
67311: LD_EXP 33
67315: PUSH
67316: LD_VAR 0 1
67320: ARRAY
67321: ST_TO_ADDR
// if onlyCombat then
67322: LD_VAR 0 2
67326: IFFALSE 67504
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
67328: LD_ADDR_VAR 0 3
67332: PUSH
67333: LD_VAR 0 3
67337: PUSH
67338: LD_VAR 0 3
67342: PPUSH
67343: LD_INT 2
67345: PUSH
67346: LD_INT 34
67348: PUSH
67349: LD_INT 12
67351: PUSH
67352: EMPTY
67353: LIST
67354: LIST
67355: PUSH
67356: LD_INT 34
67358: PUSH
67359: LD_INT 51
67361: PUSH
67362: EMPTY
67363: LIST
67364: LIST
67365: PUSH
67366: LD_INT 34
67368: PUSH
67369: LD_EXP 58
67373: PUSH
67374: EMPTY
67375: LIST
67376: LIST
67377: PUSH
67378: LD_INT 34
67380: PUSH
67381: LD_INT 32
67383: PUSH
67384: EMPTY
67385: LIST
67386: LIST
67387: PUSH
67388: LD_INT 34
67390: PUSH
67391: LD_INT 13
67393: PUSH
67394: EMPTY
67395: LIST
67396: LIST
67397: PUSH
67398: LD_INT 34
67400: PUSH
67401: LD_INT 52
67403: PUSH
67404: EMPTY
67405: LIST
67406: LIST
67407: PUSH
67408: LD_INT 34
67410: PUSH
67411: LD_EXP 63
67415: PUSH
67416: EMPTY
67417: LIST
67418: LIST
67419: PUSH
67420: LD_INT 34
67422: PUSH
67423: LD_INT 14
67425: PUSH
67426: EMPTY
67427: LIST
67428: LIST
67429: PUSH
67430: LD_INT 34
67432: PUSH
67433: LD_INT 53
67435: PUSH
67436: EMPTY
67437: LIST
67438: LIST
67439: PUSH
67440: LD_INT 34
67442: PUSH
67443: LD_EXP 57
67447: PUSH
67448: EMPTY
67449: LIST
67450: LIST
67451: PUSH
67452: LD_INT 34
67454: PUSH
67455: LD_INT 31
67457: PUSH
67458: EMPTY
67459: LIST
67460: LIST
67461: PUSH
67462: LD_INT 34
67464: PUSH
67465: LD_INT 48
67467: PUSH
67468: EMPTY
67469: LIST
67470: LIST
67471: PUSH
67472: LD_INT 34
67474: PUSH
67475: LD_INT 8
67477: PUSH
67478: EMPTY
67479: LIST
67480: LIST
67481: PUSH
67482: EMPTY
67483: LIST
67484: LIST
67485: LIST
67486: LIST
67487: LIST
67488: LIST
67489: LIST
67490: LIST
67491: LIST
67492: LIST
67493: LIST
67494: LIST
67495: LIST
67496: LIST
67497: PPUSH
67498: CALL_OW 72
67502: DIFF
67503: ST_TO_ADDR
// end ; end_of_file
67504: LD_VAR 0 3
67508: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
67509: LD_INT 0
67511: PPUSH
67512: PPUSH
67513: PPUSH
// if not mc_bases or not skirmish then
67514: LD_EXP 14
67518: NOT
67519: PUSH
67520: LD_EXP 12
67524: NOT
67525: OR
67526: IFFALSE 67530
// exit ;
67528: GO 67695
// for i = 1 to mc_bases do
67530: LD_ADDR_VAR 0 4
67534: PUSH
67535: DOUBLE
67536: LD_INT 1
67538: DEC
67539: ST_TO_ADDR
67540: LD_EXP 14
67544: PUSH
67545: FOR_TO
67546: IFFALSE 67693
// begin if sci in mc_bases [ i ] then
67548: LD_VAR 0 2
67552: PUSH
67553: LD_EXP 14
67557: PUSH
67558: LD_VAR 0 4
67562: ARRAY
67563: IN
67564: IFFALSE 67691
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
67566: LD_ADDR_EXP 43
67570: PUSH
67571: LD_EXP 43
67575: PPUSH
67576: LD_VAR 0 4
67580: PUSH
67581: LD_EXP 43
67585: PUSH
67586: LD_VAR 0 4
67590: ARRAY
67591: PUSH
67592: LD_INT 1
67594: PLUS
67595: PUSH
67596: EMPTY
67597: LIST
67598: LIST
67599: PPUSH
67600: LD_VAR 0 1
67604: PPUSH
67605: CALL 9427 0 3
67609: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
67610: LD_ADDR_VAR 0 5
67614: PUSH
67615: LD_EXP 14
67619: PUSH
67620: LD_VAR 0 4
67624: ARRAY
67625: PPUSH
67626: LD_INT 2
67628: PUSH
67629: LD_INT 30
67631: PUSH
67632: LD_INT 0
67634: PUSH
67635: EMPTY
67636: LIST
67637: LIST
67638: PUSH
67639: LD_INT 30
67641: PUSH
67642: LD_INT 1
67644: PUSH
67645: EMPTY
67646: LIST
67647: LIST
67648: PUSH
67649: EMPTY
67650: LIST
67651: LIST
67652: LIST
67653: PPUSH
67654: CALL_OW 72
67658: PPUSH
67659: LD_VAR 0 1
67663: PPUSH
67664: CALL_OW 74
67668: ST_TO_ADDR
// if tmp then
67669: LD_VAR 0 5
67673: IFFALSE 67689
// ComStandNearbyBuilding ( ape , tmp ) ;
67675: LD_VAR 0 1
67679: PPUSH
67680: LD_VAR 0 5
67684: PPUSH
67685: CALL 6041 0 2
// break ;
67689: GO 67693
// end ; end ;
67691: GO 67545
67693: POP
67694: POP
// end ;
67695: LD_VAR 0 3
67699: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
67700: LD_INT 0
67702: PPUSH
67703: PPUSH
67704: PPUSH
// if not mc_bases or not skirmish then
67705: LD_EXP 14
67709: NOT
67710: PUSH
67711: LD_EXP 12
67715: NOT
67716: OR
67717: IFFALSE 67721
// exit ;
67719: GO 67810
// for i = 1 to mc_bases do
67721: LD_ADDR_VAR 0 4
67725: PUSH
67726: DOUBLE
67727: LD_INT 1
67729: DEC
67730: ST_TO_ADDR
67731: LD_EXP 14
67735: PUSH
67736: FOR_TO
67737: IFFALSE 67808
// begin if building in mc_busy_turret_list [ i ] then
67739: LD_VAR 0 1
67743: PUSH
67744: LD_EXP 24
67748: PUSH
67749: LD_VAR 0 4
67753: ARRAY
67754: IN
67755: IFFALSE 67806
// begin tmp := mc_busy_turret_list [ i ] diff building ;
67757: LD_ADDR_VAR 0 5
67761: PUSH
67762: LD_EXP 24
67766: PUSH
67767: LD_VAR 0 4
67771: ARRAY
67772: PUSH
67773: LD_VAR 0 1
67777: DIFF
67778: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
67779: LD_ADDR_EXP 24
67783: PUSH
67784: LD_EXP 24
67788: PPUSH
67789: LD_VAR 0 4
67793: PPUSH
67794: LD_VAR 0 5
67798: PPUSH
67799: CALL_OW 1
67803: ST_TO_ADDR
// break ;
67804: GO 67808
// end ; end ;
67806: GO 67736
67808: POP
67809: POP
// end ;
67810: LD_VAR 0 3
67814: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
67815: LD_INT 0
67817: PPUSH
67818: PPUSH
67819: PPUSH
// if not mc_bases or not skirmish then
67820: LD_EXP 14
67824: NOT
67825: PUSH
67826: LD_EXP 12
67830: NOT
67831: OR
67832: IFFALSE 67836
// exit ;
67834: GO 68035
// for i = 1 to mc_bases do
67836: LD_ADDR_VAR 0 5
67840: PUSH
67841: DOUBLE
67842: LD_INT 1
67844: DEC
67845: ST_TO_ADDR
67846: LD_EXP 14
67850: PUSH
67851: FOR_TO
67852: IFFALSE 68033
// if building in mc_bases [ i ] then
67854: LD_VAR 0 1
67858: PUSH
67859: LD_EXP 14
67863: PUSH
67864: LD_VAR 0 5
67868: ARRAY
67869: IN
67870: IFFALSE 68031
// begin tmp := mc_bases [ i ] diff building ;
67872: LD_ADDR_VAR 0 6
67876: PUSH
67877: LD_EXP 14
67881: PUSH
67882: LD_VAR 0 5
67886: ARRAY
67887: PUSH
67888: LD_VAR 0 1
67892: DIFF
67893: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
67894: LD_ADDR_EXP 14
67898: PUSH
67899: LD_EXP 14
67903: PPUSH
67904: LD_VAR 0 5
67908: PPUSH
67909: LD_VAR 0 6
67913: PPUSH
67914: CALL_OW 1
67918: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
67919: LD_VAR 0 1
67923: PUSH
67924: LD_EXP 22
67928: PUSH
67929: LD_VAR 0 5
67933: ARRAY
67934: IN
67935: IFFALSE 67974
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
67937: LD_ADDR_EXP 22
67941: PUSH
67942: LD_EXP 22
67946: PPUSH
67947: LD_VAR 0 5
67951: PPUSH
67952: LD_EXP 22
67956: PUSH
67957: LD_VAR 0 5
67961: ARRAY
67962: PUSH
67963: LD_VAR 0 1
67967: DIFF
67968: PPUSH
67969: CALL_OW 1
67973: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
67974: LD_VAR 0 1
67978: PUSH
67979: LD_EXP 23
67983: PUSH
67984: LD_VAR 0 5
67988: ARRAY
67989: IN
67990: IFFALSE 68029
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
67992: LD_ADDR_EXP 23
67996: PUSH
67997: LD_EXP 23
68001: PPUSH
68002: LD_VAR 0 5
68006: PPUSH
68007: LD_EXP 23
68011: PUSH
68012: LD_VAR 0 5
68016: ARRAY
68017: PUSH
68018: LD_VAR 0 1
68022: DIFF
68023: PPUSH
68024: CALL_OW 1
68028: ST_TO_ADDR
// break ;
68029: GO 68033
// end ;
68031: GO 67851
68033: POP
68034: POP
// end ;
68035: LD_VAR 0 4
68039: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
68040: LD_INT 0
68042: PPUSH
68043: PPUSH
68044: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
68045: LD_EXP 14
68049: NOT
68050: PUSH
68051: LD_EXP 12
68055: NOT
68056: OR
68057: PUSH
68058: LD_VAR 0 3
68062: PUSH
68063: LD_EXP 40
68067: IN
68068: NOT
68069: OR
68070: IFFALSE 68074
// exit ;
68072: GO 68197
// for i = 1 to mc_vehicles do
68074: LD_ADDR_VAR 0 6
68078: PUSH
68079: DOUBLE
68080: LD_INT 1
68082: DEC
68083: ST_TO_ADDR
68084: LD_EXP 33
68088: PUSH
68089: FOR_TO
68090: IFFALSE 68195
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
68092: LD_VAR 0 2
68096: PUSH
68097: LD_EXP 33
68101: PUSH
68102: LD_VAR 0 6
68106: ARRAY
68107: IN
68108: PUSH
68109: LD_VAR 0 1
68113: PUSH
68114: LD_EXP 33
68118: PUSH
68119: LD_VAR 0 6
68123: ARRAY
68124: IN
68125: OR
68126: IFFALSE 68193
// begin tmp := mc_vehicles [ i ] diff old ;
68128: LD_ADDR_VAR 0 7
68132: PUSH
68133: LD_EXP 33
68137: PUSH
68138: LD_VAR 0 6
68142: ARRAY
68143: PUSH
68144: LD_VAR 0 2
68148: DIFF
68149: ST_TO_ADDR
// tmp := tmp diff new ;
68150: LD_ADDR_VAR 0 7
68154: PUSH
68155: LD_VAR 0 7
68159: PUSH
68160: LD_VAR 0 1
68164: DIFF
68165: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
68166: LD_ADDR_EXP 33
68170: PUSH
68171: LD_EXP 33
68175: PPUSH
68176: LD_VAR 0 6
68180: PPUSH
68181: LD_VAR 0 7
68185: PPUSH
68186: CALL_OW 1
68190: ST_TO_ADDR
// break ;
68191: GO 68195
// end ;
68193: GO 68089
68195: POP
68196: POP
// end ;
68197: LD_VAR 0 5
68201: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
68202: LD_INT 0
68204: PPUSH
68205: PPUSH
68206: PPUSH
68207: PPUSH
// if not mc_bases or not skirmish then
68208: LD_EXP 14
68212: NOT
68213: PUSH
68214: LD_EXP 12
68218: NOT
68219: OR
68220: IFFALSE 68224
// exit ;
68222: GO 68607
// side := GetSide ( vehicle ) ;
68224: LD_ADDR_VAR 0 5
68228: PUSH
68229: LD_VAR 0 1
68233: PPUSH
68234: CALL_OW 255
68238: ST_TO_ADDR
// for i = 1 to mc_bases do
68239: LD_ADDR_VAR 0 4
68243: PUSH
68244: DOUBLE
68245: LD_INT 1
68247: DEC
68248: ST_TO_ADDR
68249: LD_EXP 14
68253: PUSH
68254: FOR_TO
68255: IFFALSE 68605
// begin if factory in mc_bases [ i ] then
68257: LD_VAR 0 2
68261: PUSH
68262: LD_EXP 14
68266: PUSH
68267: LD_VAR 0 4
68271: ARRAY
68272: IN
68273: IFFALSE 68603
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
68275: LD_EXP 36
68279: PUSH
68280: LD_VAR 0 4
68284: ARRAY
68285: PUSH
68286: LD_EXP 25
68290: PUSH
68291: LD_VAR 0 4
68295: ARRAY
68296: LESS
68297: PUSH
68298: LD_VAR 0 1
68302: PPUSH
68303: CALL_OW 264
68307: PUSH
68308: LD_INT 31
68310: PUSH
68311: LD_INT 32
68313: PUSH
68314: LD_INT 51
68316: PUSH
68317: LD_EXP 58
68321: PUSH
68322: LD_INT 12
68324: PUSH
68325: LD_INT 30
68327: PUSH
68328: LD_EXP 57
68332: PUSH
68333: LD_INT 11
68335: PUSH
68336: LD_INT 53
68338: PUSH
68339: LD_INT 14
68341: PUSH
68342: LD_EXP 61
68346: PUSH
68347: LD_INT 29
68349: PUSH
68350: LD_EXP 59
68354: PUSH
68355: LD_INT 13
68357: PUSH
68358: LD_INT 52
68360: PUSH
68361: LD_EXP 63
68365: PUSH
68366: LD_INT 48
68368: PUSH
68369: LD_INT 8
68371: PUSH
68372: EMPTY
68373: LIST
68374: LIST
68375: LIST
68376: LIST
68377: LIST
68378: LIST
68379: LIST
68380: LIST
68381: LIST
68382: LIST
68383: LIST
68384: LIST
68385: LIST
68386: LIST
68387: LIST
68388: LIST
68389: LIST
68390: LIST
68391: IN
68392: NOT
68393: AND
68394: IFFALSE 68442
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
68396: LD_ADDR_EXP 36
68400: PUSH
68401: LD_EXP 36
68405: PPUSH
68406: LD_VAR 0 4
68410: PUSH
68411: LD_EXP 36
68415: PUSH
68416: LD_VAR 0 4
68420: ARRAY
68421: PUSH
68422: LD_INT 1
68424: PLUS
68425: PUSH
68426: EMPTY
68427: LIST
68428: LIST
68429: PPUSH
68430: LD_VAR 0 1
68434: PPUSH
68435: CALL 9427 0 3
68439: ST_TO_ADDR
68440: GO 68486
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
68442: LD_ADDR_EXP 33
68446: PUSH
68447: LD_EXP 33
68451: PPUSH
68452: LD_VAR 0 4
68456: PUSH
68457: LD_EXP 33
68461: PUSH
68462: LD_VAR 0 4
68466: ARRAY
68467: PUSH
68468: LD_INT 1
68470: PLUS
68471: PUSH
68472: EMPTY
68473: LIST
68474: LIST
68475: PPUSH
68476: LD_VAR 0 1
68480: PPUSH
68481: CALL 9427 0 3
68485: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
68486: LD_VAR 0 1
68490: PPUSH
68491: CALL_OW 263
68495: PUSH
68496: LD_INT 2
68498: EQUAL
68499: IFFALSE 68519
// begin repeat wait ( 0 0$1 ) ;
68501: LD_INT 35
68503: PPUSH
68504: CALL_OW 67
// until IsControledBy ( vehicle ) ;
68508: LD_VAR 0 1
68512: PPUSH
68513: CALL_OW 312
68517: IFFALSE 68501
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
68519: LD_VAR 0 1
68523: PPUSH
68524: LD_EXP 38
68528: PUSH
68529: LD_VAR 0 4
68533: ARRAY
68534: PPUSH
68535: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
68539: LD_VAR 0 1
68543: PPUSH
68544: CALL_OW 263
68548: PUSH
68549: LD_INT 1
68551: NONEQUAL
68552: IFFALSE 68556
// break ;
68554: GO 68605
// repeat wait ( 0 0$1 ) ;
68556: LD_INT 35
68558: PPUSH
68559: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
68563: LD_VAR 0 1
68567: PPUSH
68568: LD_EXP 38
68572: PUSH
68573: LD_VAR 0 4
68577: ARRAY
68578: PPUSH
68579: CALL_OW 308
68583: IFFALSE 68556
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
68585: LD_VAR 0 1
68589: PPUSH
68590: CALL_OW 311
68594: PPUSH
68595: CALL_OW 121
// exit ;
68599: POP
68600: POP
68601: GO 68607
// end ; end ;
68603: GO 68254
68605: POP
68606: POP
// end ;
68607: LD_VAR 0 3
68611: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
68612: LD_INT 0
68614: PPUSH
68615: PPUSH
68616: PPUSH
68617: PPUSH
// if not mc_bases or not skirmish then
68618: LD_EXP 14
68622: NOT
68623: PUSH
68624: LD_EXP 12
68628: NOT
68629: OR
68630: IFFALSE 68634
// exit ;
68632: GO 68987
// repeat wait ( 0 0$1 ) ;
68634: LD_INT 35
68636: PPUSH
68637: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
68641: LD_VAR 0 2
68645: PPUSH
68646: LD_VAR 0 3
68650: PPUSH
68651: CALL_OW 284
68655: IFFALSE 68634
// if GetResourceTypeXY ( x , y ) = mat_artefact then
68657: LD_VAR 0 2
68661: PPUSH
68662: LD_VAR 0 3
68666: PPUSH
68667: CALL_OW 283
68671: PUSH
68672: LD_INT 4
68674: EQUAL
68675: IFFALSE 68679
// exit ;
68677: GO 68987
// for i = 1 to mc_bases do
68679: LD_ADDR_VAR 0 7
68683: PUSH
68684: DOUBLE
68685: LD_INT 1
68687: DEC
68688: ST_TO_ADDR
68689: LD_EXP 14
68693: PUSH
68694: FOR_TO
68695: IFFALSE 68985
// begin if mc_crates_area [ i ] then
68697: LD_EXP 32
68701: PUSH
68702: LD_VAR 0 7
68706: ARRAY
68707: IFFALSE 68818
// for j in mc_crates_area [ i ] do
68709: LD_ADDR_VAR 0 8
68713: PUSH
68714: LD_EXP 32
68718: PUSH
68719: LD_VAR 0 7
68723: ARRAY
68724: PUSH
68725: FOR_IN
68726: IFFALSE 68816
// if InArea ( x , y , j ) then
68728: LD_VAR 0 2
68732: PPUSH
68733: LD_VAR 0 3
68737: PPUSH
68738: LD_VAR 0 8
68742: PPUSH
68743: CALL_OW 309
68747: IFFALSE 68814
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
68749: LD_ADDR_EXP 30
68753: PUSH
68754: LD_EXP 30
68758: PPUSH
68759: LD_VAR 0 7
68763: PUSH
68764: LD_EXP 30
68768: PUSH
68769: LD_VAR 0 7
68773: ARRAY
68774: PUSH
68775: LD_INT 1
68777: PLUS
68778: PUSH
68779: EMPTY
68780: LIST
68781: LIST
68782: PPUSH
68783: LD_VAR 0 4
68787: PUSH
68788: LD_VAR 0 2
68792: PUSH
68793: LD_VAR 0 3
68797: PUSH
68798: EMPTY
68799: LIST
68800: LIST
68801: LIST
68802: PPUSH
68803: CALL 9427 0 3
68807: ST_TO_ADDR
// exit ;
68808: POP
68809: POP
68810: POP
68811: POP
68812: GO 68987
// end ;
68814: GO 68725
68816: POP
68817: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68818: LD_ADDR_VAR 0 9
68822: PUSH
68823: LD_EXP 14
68827: PUSH
68828: LD_VAR 0 7
68832: ARRAY
68833: PPUSH
68834: LD_INT 2
68836: PUSH
68837: LD_INT 30
68839: PUSH
68840: LD_INT 0
68842: PUSH
68843: EMPTY
68844: LIST
68845: LIST
68846: PUSH
68847: LD_INT 30
68849: PUSH
68850: LD_INT 1
68852: PUSH
68853: EMPTY
68854: LIST
68855: LIST
68856: PUSH
68857: EMPTY
68858: LIST
68859: LIST
68860: LIST
68861: PPUSH
68862: CALL_OW 72
68866: ST_TO_ADDR
// if not depot then
68867: LD_VAR 0 9
68871: NOT
68872: IFFALSE 68876
// continue ;
68874: GO 68694
// for j in depot do
68876: LD_ADDR_VAR 0 8
68880: PUSH
68881: LD_VAR 0 9
68885: PUSH
68886: FOR_IN
68887: IFFALSE 68981
// if GetDistUnitXY ( j , x , y ) < 30 then
68889: LD_VAR 0 8
68893: PPUSH
68894: LD_VAR 0 2
68898: PPUSH
68899: LD_VAR 0 3
68903: PPUSH
68904: CALL_OW 297
68908: PUSH
68909: LD_INT 30
68911: LESS
68912: IFFALSE 68979
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
68914: LD_ADDR_EXP 30
68918: PUSH
68919: LD_EXP 30
68923: PPUSH
68924: LD_VAR 0 7
68928: PUSH
68929: LD_EXP 30
68933: PUSH
68934: LD_VAR 0 7
68938: ARRAY
68939: PUSH
68940: LD_INT 1
68942: PLUS
68943: PUSH
68944: EMPTY
68945: LIST
68946: LIST
68947: PPUSH
68948: LD_VAR 0 4
68952: PUSH
68953: LD_VAR 0 2
68957: PUSH
68958: LD_VAR 0 3
68962: PUSH
68963: EMPTY
68964: LIST
68965: LIST
68966: LIST
68967: PPUSH
68968: CALL 9427 0 3
68972: ST_TO_ADDR
// exit ;
68973: POP
68974: POP
68975: POP
68976: POP
68977: GO 68987
// end ;
68979: GO 68886
68981: POP
68982: POP
// end ;
68983: GO 68694
68985: POP
68986: POP
// end ;
68987: LD_VAR 0 6
68991: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
68992: LD_INT 0
68994: PPUSH
68995: PPUSH
68996: PPUSH
68997: PPUSH
// if not mc_bases or not skirmish then
68998: LD_EXP 14
69002: NOT
69003: PUSH
69004: LD_EXP 12
69008: NOT
69009: OR
69010: IFFALSE 69014
// exit ;
69012: GO 69291
// side := GetSide ( lab ) ;
69014: LD_ADDR_VAR 0 4
69018: PUSH
69019: LD_VAR 0 2
69023: PPUSH
69024: CALL_OW 255
69028: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
69029: LD_VAR 0 4
69033: PUSH
69034: LD_EXP 40
69038: IN
69039: NOT
69040: PUSH
69041: LD_EXP 41
69045: NOT
69046: OR
69047: PUSH
69048: LD_EXP 14
69052: NOT
69053: OR
69054: IFFALSE 69058
// exit ;
69056: GO 69291
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
69058: LD_ADDR_EXP 41
69062: PUSH
69063: LD_EXP 41
69067: PPUSH
69068: LD_VAR 0 4
69072: PPUSH
69073: LD_EXP 41
69077: PUSH
69078: LD_VAR 0 4
69082: ARRAY
69083: PUSH
69084: LD_VAR 0 1
69088: DIFF
69089: PPUSH
69090: CALL_OW 1
69094: ST_TO_ADDR
// for i = 1 to mc_bases do
69095: LD_ADDR_VAR 0 5
69099: PUSH
69100: DOUBLE
69101: LD_INT 1
69103: DEC
69104: ST_TO_ADDR
69105: LD_EXP 14
69109: PUSH
69110: FOR_TO
69111: IFFALSE 69289
// begin if lab in mc_bases [ i ] then
69113: LD_VAR 0 2
69117: PUSH
69118: LD_EXP 14
69122: PUSH
69123: LD_VAR 0 5
69127: ARRAY
69128: IN
69129: IFFALSE 69287
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
69131: LD_VAR 0 1
69135: PUSH
69136: LD_INT 11
69138: PUSH
69139: LD_INT 4
69141: PUSH
69142: LD_INT 3
69144: PUSH
69145: LD_INT 2
69147: PUSH
69148: EMPTY
69149: LIST
69150: LIST
69151: LIST
69152: LIST
69153: IN
69154: PUSH
69155: LD_EXP 44
69159: PUSH
69160: LD_VAR 0 5
69164: ARRAY
69165: AND
69166: IFFALSE 69287
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
69168: LD_ADDR_VAR 0 6
69172: PUSH
69173: LD_EXP 44
69177: PUSH
69178: LD_VAR 0 5
69182: ARRAY
69183: PUSH
69184: LD_INT 1
69186: ARRAY
69187: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
69188: LD_ADDR_EXP 44
69192: PUSH
69193: LD_EXP 44
69197: PPUSH
69198: LD_VAR 0 5
69202: PPUSH
69203: EMPTY
69204: PPUSH
69205: CALL_OW 1
69209: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
69210: LD_VAR 0 6
69214: PPUSH
69215: LD_INT 0
69217: PPUSH
69218: CALL_OW 109
// ComExitBuilding ( tmp ) ;
69222: LD_VAR 0 6
69226: PPUSH
69227: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
69231: LD_ADDR_EXP 43
69235: PUSH
69236: LD_EXP 43
69240: PPUSH
69241: LD_VAR 0 5
69245: PPUSH
69246: LD_EXP 43
69250: PUSH
69251: LD_VAR 0 5
69255: ARRAY
69256: PPUSH
69257: LD_INT 1
69259: PPUSH
69260: LD_VAR 0 6
69264: PPUSH
69265: CALL_OW 2
69269: PPUSH
69270: CALL_OW 1
69274: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
69275: LD_VAR 0 5
69279: PPUSH
69280: LD_INT 112
69282: PPUSH
69283: CALL 46215 0 2
// end ; end ; end ;
69287: GO 69110
69289: POP
69290: POP
// end ;
69291: LD_VAR 0 3
69295: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
69296: LD_INT 0
69298: PPUSH
69299: PPUSH
69300: PPUSH
69301: PPUSH
69302: PPUSH
69303: PPUSH
69304: PPUSH
69305: PPUSH
// if not mc_bases or not skirmish then
69306: LD_EXP 14
69310: NOT
69311: PUSH
69312: LD_EXP 12
69316: NOT
69317: OR
69318: IFFALSE 69322
// exit ;
69320: GO 70693
// for i = 1 to mc_bases do
69322: LD_ADDR_VAR 0 3
69326: PUSH
69327: DOUBLE
69328: LD_INT 1
69330: DEC
69331: ST_TO_ADDR
69332: LD_EXP 14
69336: PUSH
69337: FOR_TO
69338: IFFALSE 70691
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
69340: LD_VAR 0 1
69344: PUSH
69345: LD_EXP 14
69349: PUSH
69350: LD_VAR 0 3
69354: ARRAY
69355: IN
69356: PUSH
69357: LD_VAR 0 1
69361: PUSH
69362: LD_EXP 21
69366: PUSH
69367: LD_VAR 0 3
69371: ARRAY
69372: IN
69373: OR
69374: PUSH
69375: LD_VAR 0 1
69379: PUSH
69380: LD_EXP 36
69384: PUSH
69385: LD_VAR 0 3
69389: ARRAY
69390: IN
69391: OR
69392: PUSH
69393: LD_VAR 0 1
69397: PUSH
69398: LD_EXP 33
69402: PUSH
69403: LD_VAR 0 3
69407: ARRAY
69408: IN
69409: OR
69410: PUSH
69411: LD_VAR 0 1
69415: PUSH
69416: LD_EXP 43
69420: PUSH
69421: LD_VAR 0 3
69425: ARRAY
69426: IN
69427: OR
69428: PUSH
69429: LD_VAR 0 1
69433: PUSH
69434: LD_EXP 44
69438: PUSH
69439: LD_VAR 0 3
69443: ARRAY
69444: IN
69445: OR
69446: IFFALSE 70689
// begin if un in mc_ape [ i ] then
69448: LD_VAR 0 1
69452: PUSH
69453: LD_EXP 43
69457: PUSH
69458: LD_VAR 0 3
69462: ARRAY
69463: IN
69464: IFFALSE 69503
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
69466: LD_ADDR_EXP 43
69470: PUSH
69471: LD_EXP 43
69475: PPUSH
69476: LD_VAR 0 3
69480: PPUSH
69481: LD_EXP 43
69485: PUSH
69486: LD_VAR 0 3
69490: ARRAY
69491: PUSH
69492: LD_VAR 0 1
69496: DIFF
69497: PPUSH
69498: CALL_OW 1
69502: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
69503: LD_VAR 0 1
69507: PUSH
69508: LD_EXP 44
69512: PUSH
69513: LD_VAR 0 3
69517: ARRAY
69518: IN
69519: IFFALSE 69543
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
69521: LD_ADDR_EXP 44
69525: PUSH
69526: LD_EXP 44
69530: PPUSH
69531: LD_VAR 0 3
69535: PPUSH
69536: EMPTY
69537: PPUSH
69538: CALL_OW 1
69542: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
69543: LD_VAR 0 1
69547: PPUSH
69548: CALL_OW 247
69552: PUSH
69553: LD_INT 2
69555: EQUAL
69556: PUSH
69557: LD_VAR 0 1
69561: PPUSH
69562: CALL_OW 110
69566: PUSH
69567: LD_INT 20
69569: EQUAL
69570: PUSH
69571: LD_VAR 0 1
69575: PUSH
69576: LD_EXP 36
69580: PUSH
69581: LD_VAR 0 3
69585: ARRAY
69586: IN
69587: OR
69588: PUSH
69589: LD_VAR 0 1
69593: PPUSH
69594: CALL_OW 264
69598: PUSH
69599: LD_INT 12
69601: PUSH
69602: LD_INT 51
69604: PUSH
69605: LD_EXP 58
69609: PUSH
69610: LD_INT 32
69612: PUSH
69613: LD_INT 13
69615: PUSH
69616: LD_INT 52
69618: PUSH
69619: LD_INT 31
69621: PUSH
69622: EMPTY
69623: LIST
69624: LIST
69625: LIST
69626: LIST
69627: LIST
69628: LIST
69629: LIST
69630: IN
69631: OR
69632: AND
69633: IFFALSE 69941
// begin if un in mc_defender [ i ] then
69635: LD_VAR 0 1
69639: PUSH
69640: LD_EXP 36
69644: PUSH
69645: LD_VAR 0 3
69649: ARRAY
69650: IN
69651: IFFALSE 69690
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
69653: LD_ADDR_EXP 36
69657: PUSH
69658: LD_EXP 36
69662: PPUSH
69663: LD_VAR 0 3
69667: PPUSH
69668: LD_EXP 36
69672: PUSH
69673: LD_VAR 0 3
69677: ARRAY
69678: PUSH
69679: LD_VAR 0 1
69683: DIFF
69684: PPUSH
69685: CALL_OW 1
69689: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
69690: LD_ADDR_VAR 0 8
69694: PUSH
69695: LD_VAR 0 3
69699: PPUSH
69700: LD_INT 3
69702: PPUSH
69703: CALL 66340 0 2
69707: ST_TO_ADDR
// if fac then
69708: LD_VAR 0 8
69712: IFFALSE 69941
// begin for j in fac do
69714: LD_ADDR_VAR 0 4
69718: PUSH
69719: LD_VAR 0 8
69723: PUSH
69724: FOR_IN
69725: IFFALSE 69939
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
69727: LD_ADDR_VAR 0 9
69731: PUSH
69732: LD_VAR 0 8
69736: PPUSH
69737: LD_VAR 0 1
69741: PPUSH
69742: CALL_OW 265
69746: PPUSH
69747: LD_VAR 0 1
69751: PPUSH
69752: CALL_OW 262
69756: PPUSH
69757: LD_VAR 0 1
69761: PPUSH
69762: CALL_OW 263
69766: PPUSH
69767: LD_VAR 0 1
69771: PPUSH
69772: CALL_OW 264
69776: PPUSH
69777: CALL 6959 0 5
69781: ST_TO_ADDR
// if components then
69782: LD_VAR 0 9
69786: IFFALSE 69937
// begin if GetWeapon ( un ) = ar_control_tower then
69788: LD_VAR 0 1
69792: PPUSH
69793: CALL_OW 264
69797: PUSH
69798: LD_INT 31
69800: EQUAL
69801: IFFALSE 69918
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
69803: LD_VAR 0 1
69807: PPUSH
69808: CALL_OW 311
69812: PPUSH
69813: LD_INT 0
69815: PPUSH
69816: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
69820: LD_ADDR_EXP 54
69824: PUSH
69825: LD_EXP 54
69829: PPUSH
69830: LD_VAR 0 3
69834: PPUSH
69835: LD_EXP 54
69839: PUSH
69840: LD_VAR 0 3
69844: ARRAY
69845: PUSH
69846: LD_VAR 0 1
69850: PPUSH
69851: CALL_OW 311
69855: DIFF
69856: PPUSH
69857: CALL_OW 1
69861: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
69862: LD_ADDR_VAR 0 7
69866: PUSH
69867: LD_EXP 35
69871: PUSH
69872: LD_VAR 0 3
69876: ARRAY
69877: PPUSH
69878: LD_INT 1
69880: PPUSH
69881: LD_VAR 0 9
69885: PPUSH
69886: CALL_OW 2
69890: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
69891: LD_ADDR_EXP 35
69895: PUSH
69896: LD_EXP 35
69900: PPUSH
69901: LD_VAR 0 3
69905: PPUSH
69906: LD_VAR 0 7
69910: PPUSH
69911: CALL_OW 1
69915: ST_TO_ADDR
// end else
69916: GO 69935
// MC_InsertProduceList ( i , [ components ] ) ;
69918: LD_VAR 0 3
69922: PPUSH
69923: LD_VAR 0 9
69927: PUSH
69928: EMPTY
69929: LIST
69930: PPUSH
69931: CALL 65885 0 2
// break ;
69935: GO 69939
// end ; end ;
69937: GO 69724
69939: POP
69940: POP
// end ; end ; if GetType ( un ) = unit_building then
69941: LD_VAR 0 1
69945: PPUSH
69946: CALL_OW 247
69950: PUSH
69951: LD_INT 3
69953: EQUAL
69954: IFFALSE 70357
// begin btype := GetBType ( un ) ;
69956: LD_ADDR_VAR 0 5
69960: PUSH
69961: LD_VAR 0 1
69965: PPUSH
69966: CALL_OW 266
69970: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
69971: LD_VAR 0 5
69975: PUSH
69976: LD_INT 29
69978: PUSH
69979: LD_INT 30
69981: PUSH
69982: EMPTY
69983: LIST
69984: LIST
69985: IN
69986: IFFALSE 70059
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
69988: LD_VAR 0 1
69992: PPUSH
69993: CALL_OW 250
69997: PPUSH
69998: LD_VAR 0 1
70002: PPUSH
70003: CALL_OW 251
70007: PPUSH
70008: LD_VAR 0 1
70012: PPUSH
70013: CALL_OW 255
70017: PPUSH
70018: CALL_OW 440
70022: NOT
70023: IFFALSE 70059
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
70025: LD_VAR 0 1
70029: PPUSH
70030: CALL_OW 250
70034: PPUSH
70035: LD_VAR 0 1
70039: PPUSH
70040: CALL_OW 251
70044: PPUSH
70045: LD_VAR 0 1
70049: PPUSH
70050: CALL_OW 255
70054: PPUSH
70055: CALL_OW 441
// end ; if btype = b_warehouse then
70059: LD_VAR 0 5
70063: PUSH
70064: LD_INT 1
70066: EQUAL
70067: IFFALSE 70085
// begin btype := b_depot ;
70069: LD_ADDR_VAR 0 5
70073: PUSH
70074: LD_INT 0
70076: ST_TO_ADDR
// pos := 1 ;
70077: LD_ADDR_VAR 0 6
70081: PUSH
70082: LD_INT 1
70084: ST_TO_ADDR
// end ; if btype = b_factory then
70085: LD_VAR 0 5
70089: PUSH
70090: LD_INT 3
70092: EQUAL
70093: IFFALSE 70111
// begin btype := b_workshop ;
70095: LD_ADDR_VAR 0 5
70099: PUSH
70100: LD_INT 2
70102: ST_TO_ADDR
// pos := 1 ;
70103: LD_ADDR_VAR 0 6
70107: PUSH
70108: LD_INT 1
70110: ST_TO_ADDR
// end ; if btype = b_barracks then
70111: LD_VAR 0 5
70115: PUSH
70116: LD_INT 5
70118: EQUAL
70119: IFFALSE 70129
// btype := b_armoury ;
70121: LD_ADDR_VAR 0 5
70125: PUSH
70126: LD_INT 4
70128: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
70129: LD_VAR 0 5
70133: PUSH
70134: LD_INT 7
70136: PUSH
70137: LD_INT 8
70139: PUSH
70140: EMPTY
70141: LIST
70142: LIST
70143: IN
70144: IFFALSE 70154
// btype := b_lab ;
70146: LD_ADDR_VAR 0 5
70150: PUSH
70151: LD_INT 6
70153: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
70154: LD_ADDR_EXP 19
70158: PUSH
70159: LD_EXP 19
70163: PPUSH
70164: LD_VAR 0 3
70168: PUSH
70169: LD_EXP 19
70173: PUSH
70174: LD_VAR 0 3
70178: ARRAY
70179: PUSH
70180: LD_INT 1
70182: PLUS
70183: PUSH
70184: EMPTY
70185: LIST
70186: LIST
70187: PPUSH
70188: LD_VAR 0 5
70192: PUSH
70193: LD_VAR 0 1
70197: PPUSH
70198: CALL_OW 250
70202: PUSH
70203: LD_VAR 0 1
70207: PPUSH
70208: CALL_OW 251
70212: PUSH
70213: LD_VAR 0 1
70217: PPUSH
70218: CALL_OW 254
70222: PUSH
70223: EMPTY
70224: LIST
70225: LIST
70226: LIST
70227: LIST
70228: PPUSH
70229: CALL 9427 0 3
70233: ST_TO_ADDR
// if pos = 1 then
70234: LD_VAR 0 6
70238: PUSH
70239: LD_INT 1
70241: EQUAL
70242: IFFALSE 70357
// begin tmp := mc_build_list [ i ] ;
70244: LD_ADDR_VAR 0 7
70248: PUSH
70249: LD_EXP 19
70253: PUSH
70254: LD_VAR 0 3
70258: ARRAY
70259: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
70260: LD_VAR 0 7
70264: PPUSH
70265: LD_INT 2
70267: PUSH
70268: LD_INT 30
70270: PUSH
70271: LD_INT 0
70273: PUSH
70274: EMPTY
70275: LIST
70276: LIST
70277: PUSH
70278: LD_INT 30
70280: PUSH
70281: LD_INT 1
70283: PUSH
70284: EMPTY
70285: LIST
70286: LIST
70287: PUSH
70288: EMPTY
70289: LIST
70290: LIST
70291: LIST
70292: PPUSH
70293: CALL_OW 72
70297: IFFALSE 70307
// pos := 2 ;
70299: LD_ADDR_VAR 0 6
70303: PUSH
70304: LD_INT 2
70306: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
70307: LD_ADDR_VAR 0 7
70311: PUSH
70312: LD_VAR 0 7
70316: PPUSH
70317: LD_VAR 0 6
70321: PPUSH
70322: LD_VAR 0 7
70326: PPUSH
70327: CALL 9753 0 3
70331: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
70332: LD_ADDR_EXP 19
70336: PUSH
70337: LD_EXP 19
70341: PPUSH
70342: LD_VAR 0 3
70346: PPUSH
70347: LD_VAR 0 7
70351: PPUSH
70352: CALL_OW 1
70356: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
70357: LD_VAR 0 1
70361: PUSH
70362: LD_EXP 14
70366: PUSH
70367: LD_VAR 0 3
70371: ARRAY
70372: IN
70373: IFFALSE 70412
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
70375: LD_ADDR_EXP 14
70379: PUSH
70380: LD_EXP 14
70384: PPUSH
70385: LD_VAR 0 3
70389: PPUSH
70390: LD_EXP 14
70394: PUSH
70395: LD_VAR 0 3
70399: ARRAY
70400: PUSH
70401: LD_VAR 0 1
70405: DIFF
70406: PPUSH
70407: CALL_OW 1
70411: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
70412: LD_VAR 0 1
70416: PUSH
70417: LD_EXP 21
70421: PUSH
70422: LD_VAR 0 3
70426: ARRAY
70427: IN
70428: IFFALSE 70467
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
70430: LD_ADDR_EXP 21
70434: PUSH
70435: LD_EXP 21
70439: PPUSH
70440: LD_VAR 0 3
70444: PPUSH
70445: LD_EXP 21
70449: PUSH
70450: LD_VAR 0 3
70454: ARRAY
70455: PUSH
70456: LD_VAR 0 1
70460: DIFF
70461: PPUSH
70462: CALL_OW 1
70466: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
70467: LD_VAR 0 1
70471: PUSH
70472: LD_EXP 33
70476: PUSH
70477: LD_VAR 0 3
70481: ARRAY
70482: IN
70483: IFFALSE 70522
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
70485: LD_ADDR_EXP 33
70489: PUSH
70490: LD_EXP 33
70494: PPUSH
70495: LD_VAR 0 3
70499: PPUSH
70500: LD_EXP 33
70504: PUSH
70505: LD_VAR 0 3
70509: ARRAY
70510: PUSH
70511: LD_VAR 0 1
70515: DIFF
70516: PPUSH
70517: CALL_OW 1
70521: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
70522: LD_VAR 0 1
70526: PUSH
70527: LD_EXP 36
70531: PUSH
70532: LD_VAR 0 3
70536: ARRAY
70537: IN
70538: IFFALSE 70577
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
70540: LD_ADDR_EXP 36
70544: PUSH
70545: LD_EXP 36
70549: PPUSH
70550: LD_VAR 0 3
70554: PPUSH
70555: LD_EXP 36
70559: PUSH
70560: LD_VAR 0 3
70564: ARRAY
70565: PUSH
70566: LD_VAR 0 1
70570: DIFF
70571: PPUSH
70572: CALL_OW 1
70576: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
70577: LD_VAR 0 1
70581: PUSH
70582: LD_EXP 23
70586: PUSH
70587: LD_VAR 0 3
70591: ARRAY
70592: IN
70593: IFFALSE 70632
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
70595: LD_ADDR_EXP 23
70599: PUSH
70600: LD_EXP 23
70604: PPUSH
70605: LD_VAR 0 3
70609: PPUSH
70610: LD_EXP 23
70614: PUSH
70615: LD_VAR 0 3
70619: ARRAY
70620: PUSH
70621: LD_VAR 0 1
70625: DIFF
70626: PPUSH
70627: CALL_OW 1
70631: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
70632: LD_VAR 0 1
70636: PUSH
70637: LD_EXP 22
70641: PUSH
70642: LD_VAR 0 3
70646: ARRAY
70647: IN
70648: IFFALSE 70687
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
70650: LD_ADDR_EXP 22
70654: PUSH
70655: LD_EXP 22
70659: PPUSH
70660: LD_VAR 0 3
70664: PPUSH
70665: LD_EXP 22
70669: PUSH
70670: LD_VAR 0 3
70674: ARRAY
70675: PUSH
70676: LD_VAR 0 1
70680: DIFF
70681: PPUSH
70682: CALL_OW 1
70686: ST_TO_ADDR
// end ; break ;
70687: GO 70691
// end ;
70689: GO 69337
70691: POP
70692: POP
// end ;
70693: LD_VAR 0 2
70697: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
70698: LD_INT 0
70700: PPUSH
70701: PPUSH
70702: PPUSH
// if not mc_bases or not skirmish then
70703: LD_EXP 14
70707: NOT
70708: PUSH
70709: LD_EXP 12
70713: NOT
70714: OR
70715: IFFALSE 70719
// exit ;
70717: GO 70934
// for i = 1 to mc_bases do
70719: LD_ADDR_VAR 0 3
70723: PUSH
70724: DOUBLE
70725: LD_INT 1
70727: DEC
70728: ST_TO_ADDR
70729: LD_EXP 14
70733: PUSH
70734: FOR_TO
70735: IFFALSE 70932
// begin if building in mc_construct_list [ i ] then
70737: LD_VAR 0 1
70741: PUSH
70742: LD_EXP 21
70746: PUSH
70747: LD_VAR 0 3
70751: ARRAY
70752: IN
70753: IFFALSE 70930
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
70755: LD_ADDR_EXP 21
70759: PUSH
70760: LD_EXP 21
70764: PPUSH
70765: LD_VAR 0 3
70769: PPUSH
70770: LD_EXP 21
70774: PUSH
70775: LD_VAR 0 3
70779: ARRAY
70780: PUSH
70781: LD_VAR 0 1
70785: DIFF
70786: PPUSH
70787: CALL_OW 1
70791: ST_TO_ADDR
// if building in mc_lab [ i ] then
70792: LD_VAR 0 1
70796: PUSH
70797: LD_EXP 47
70801: PUSH
70802: LD_VAR 0 3
70806: ARRAY
70807: IN
70808: IFFALSE 70863
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
70810: LD_ADDR_EXP 48
70814: PUSH
70815: LD_EXP 48
70819: PPUSH
70820: LD_VAR 0 3
70824: PPUSH
70825: LD_EXP 48
70829: PUSH
70830: LD_VAR 0 3
70834: ARRAY
70835: PPUSH
70836: LD_INT 1
70838: PPUSH
70839: LD_EXP 48
70843: PUSH
70844: LD_VAR 0 3
70848: ARRAY
70849: PPUSH
70850: LD_INT 0
70852: PPUSH
70853: CALL 8845 0 4
70857: PPUSH
70858: CALL_OW 1
70862: ST_TO_ADDR
// if not building in mc_bases [ i ] then
70863: LD_VAR 0 1
70867: PUSH
70868: LD_EXP 14
70872: PUSH
70873: LD_VAR 0 3
70877: ARRAY
70878: IN
70879: NOT
70880: IFFALSE 70926
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
70882: LD_ADDR_EXP 14
70886: PUSH
70887: LD_EXP 14
70891: PPUSH
70892: LD_VAR 0 3
70896: PUSH
70897: LD_EXP 14
70901: PUSH
70902: LD_VAR 0 3
70906: ARRAY
70907: PUSH
70908: LD_INT 1
70910: PLUS
70911: PUSH
70912: EMPTY
70913: LIST
70914: LIST
70915: PPUSH
70916: LD_VAR 0 1
70920: PPUSH
70921: CALL 9427 0 3
70925: ST_TO_ADDR
// exit ;
70926: POP
70927: POP
70928: GO 70934
// end ; end ;
70930: GO 70734
70932: POP
70933: POP
// end ;
70934: LD_VAR 0 2
70938: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
70939: LD_INT 0
70941: PPUSH
70942: PPUSH
70943: PPUSH
70944: PPUSH
70945: PPUSH
70946: PPUSH
70947: PPUSH
// if not mc_bases or not skirmish then
70948: LD_EXP 14
70952: NOT
70953: PUSH
70954: LD_EXP 12
70958: NOT
70959: OR
70960: IFFALSE 70964
// exit ;
70962: GO 71625
// for i = 1 to mc_bases do
70964: LD_ADDR_VAR 0 3
70968: PUSH
70969: DOUBLE
70970: LD_INT 1
70972: DEC
70973: ST_TO_ADDR
70974: LD_EXP 14
70978: PUSH
70979: FOR_TO
70980: IFFALSE 71623
// begin if building in mc_construct_list [ i ] then
70982: LD_VAR 0 1
70986: PUSH
70987: LD_EXP 21
70991: PUSH
70992: LD_VAR 0 3
70996: ARRAY
70997: IN
70998: IFFALSE 71621
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
71000: LD_ADDR_EXP 21
71004: PUSH
71005: LD_EXP 21
71009: PPUSH
71010: LD_VAR 0 3
71014: PPUSH
71015: LD_EXP 21
71019: PUSH
71020: LD_VAR 0 3
71024: ARRAY
71025: PUSH
71026: LD_VAR 0 1
71030: DIFF
71031: PPUSH
71032: CALL_OW 1
71036: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
71037: LD_ADDR_EXP 14
71041: PUSH
71042: LD_EXP 14
71046: PPUSH
71047: LD_VAR 0 3
71051: PUSH
71052: LD_EXP 14
71056: PUSH
71057: LD_VAR 0 3
71061: ARRAY
71062: PUSH
71063: LD_INT 1
71065: PLUS
71066: PUSH
71067: EMPTY
71068: LIST
71069: LIST
71070: PPUSH
71071: LD_VAR 0 1
71075: PPUSH
71076: CALL 9427 0 3
71080: ST_TO_ADDR
// btype := GetBType ( building ) ;
71081: LD_ADDR_VAR 0 5
71085: PUSH
71086: LD_VAR 0 1
71090: PPUSH
71091: CALL_OW 266
71095: ST_TO_ADDR
// side := GetSide ( building ) ;
71096: LD_ADDR_VAR 0 8
71100: PUSH
71101: LD_VAR 0 1
71105: PPUSH
71106: CALL_OW 255
71110: ST_TO_ADDR
// if btype = b_lab then
71111: LD_VAR 0 5
71115: PUSH
71116: LD_INT 6
71118: EQUAL
71119: IFFALSE 71169
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
71121: LD_ADDR_EXP 47
71125: PUSH
71126: LD_EXP 47
71130: PPUSH
71131: LD_VAR 0 3
71135: PUSH
71136: LD_EXP 47
71140: PUSH
71141: LD_VAR 0 3
71145: ARRAY
71146: PUSH
71147: LD_INT 1
71149: PLUS
71150: PUSH
71151: EMPTY
71152: LIST
71153: LIST
71154: PPUSH
71155: LD_VAR 0 1
71159: PPUSH
71160: CALL 9427 0 3
71164: ST_TO_ADDR
// exit ;
71165: POP
71166: POP
71167: GO 71625
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
71169: LD_VAR 0 5
71173: PUSH
71174: LD_INT 0
71176: PUSH
71177: LD_INT 2
71179: PUSH
71180: LD_INT 4
71182: PUSH
71183: EMPTY
71184: LIST
71185: LIST
71186: LIST
71187: IN
71188: IFFALSE 71312
// begin if btype = b_armoury then
71190: LD_VAR 0 5
71194: PUSH
71195: LD_INT 4
71197: EQUAL
71198: IFFALSE 71208
// btype := b_barracks ;
71200: LD_ADDR_VAR 0 5
71204: PUSH
71205: LD_INT 5
71207: ST_TO_ADDR
// if btype = b_depot then
71208: LD_VAR 0 5
71212: PUSH
71213: LD_INT 0
71215: EQUAL
71216: IFFALSE 71226
// btype := b_warehouse ;
71218: LD_ADDR_VAR 0 5
71222: PUSH
71223: LD_INT 1
71225: ST_TO_ADDR
// if btype = b_workshop then
71226: LD_VAR 0 5
71230: PUSH
71231: LD_INT 2
71233: EQUAL
71234: IFFALSE 71244
// btype := b_factory ;
71236: LD_ADDR_VAR 0 5
71240: PUSH
71241: LD_INT 3
71243: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
71244: LD_VAR 0 5
71248: PPUSH
71249: LD_VAR 0 8
71253: PPUSH
71254: CALL_OW 323
71258: PUSH
71259: LD_INT 1
71261: EQUAL
71262: IFFALSE 71308
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
71264: LD_ADDR_EXP 46
71268: PUSH
71269: LD_EXP 46
71273: PPUSH
71274: LD_VAR 0 3
71278: PUSH
71279: LD_EXP 46
71283: PUSH
71284: LD_VAR 0 3
71288: ARRAY
71289: PUSH
71290: LD_INT 1
71292: PLUS
71293: PUSH
71294: EMPTY
71295: LIST
71296: LIST
71297: PPUSH
71298: LD_VAR 0 1
71302: PPUSH
71303: CALL 9427 0 3
71307: ST_TO_ADDR
// exit ;
71308: POP
71309: POP
71310: GO 71625
// end ; if btype in [ b_bunker , b_turret ] then
71312: LD_VAR 0 5
71316: PUSH
71317: LD_INT 32
71319: PUSH
71320: LD_INT 33
71322: PUSH
71323: EMPTY
71324: LIST
71325: LIST
71326: IN
71327: IFFALSE 71617
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
71329: LD_ADDR_EXP 22
71333: PUSH
71334: LD_EXP 22
71338: PPUSH
71339: LD_VAR 0 3
71343: PUSH
71344: LD_EXP 22
71348: PUSH
71349: LD_VAR 0 3
71353: ARRAY
71354: PUSH
71355: LD_INT 1
71357: PLUS
71358: PUSH
71359: EMPTY
71360: LIST
71361: LIST
71362: PPUSH
71363: LD_VAR 0 1
71367: PPUSH
71368: CALL 9427 0 3
71372: ST_TO_ADDR
// if btype = b_bunker then
71373: LD_VAR 0 5
71377: PUSH
71378: LD_INT 32
71380: EQUAL
71381: IFFALSE 71617
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
71383: LD_ADDR_EXP 23
71387: PUSH
71388: LD_EXP 23
71392: PPUSH
71393: LD_VAR 0 3
71397: PUSH
71398: LD_EXP 23
71402: PUSH
71403: LD_VAR 0 3
71407: ARRAY
71408: PUSH
71409: LD_INT 1
71411: PLUS
71412: PUSH
71413: EMPTY
71414: LIST
71415: LIST
71416: PPUSH
71417: LD_VAR 0 1
71421: PPUSH
71422: CALL 9427 0 3
71426: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
71427: LD_ADDR_VAR 0 6
71431: PUSH
71432: LD_EXP 14
71436: PUSH
71437: LD_VAR 0 3
71441: ARRAY
71442: PPUSH
71443: LD_INT 25
71445: PUSH
71446: LD_INT 1
71448: PUSH
71449: EMPTY
71450: LIST
71451: LIST
71452: PUSH
71453: LD_INT 3
71455: PUSH
71456: LD_INT 54
71458: PUSH
71459: EMPTY
71460: LIST
71461: PUSH
71462: EMPTY
71463: LIST
71464: LIST
71465: PUSH
71466: EMPTY
71467: LIST
71468: LIST
71469: PPUSH
71470: CALL_OW 72
71474: ST_TO_ADDR
// if tmp then
71475: LD_VAR 0 6
71479: IFFALSE 71485
// exit ;
71481: POP
71482: POP
71483: GO 71625
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
71485: LD_ADDR_VAR 0 6
71489: PUSH
71490: LD_EXP 14
71494: PUSH
71495: LD_VAR 0 3
71499: ARRAY
71500: PPUSH
71501: LD_INT 2
71503: PUSH
71504: LD_INT 30
71506: PUSH
71507: LD_INT 4
71509: PUSH
71510: EMPTY
71511: LIST
71512: LIST
71513: PUSH
71514: LD_INT 30
71516: PUSH
71517: LD_INT 5
71519: PUSH
71520: EMPTY
71521: LIST
71522: LIST
71523: PUSH
71524: EMPTY
71525: LIST
71526: LIST
71527: LIST
71528: PPUSH
71529: CALL_OW 72
71533: ST_TO_ADDR
// if not tmp then
71534: LD_VAR 0 6
71538: NOT
71539: IFFALSE 71545
// exit ;
71541: POP
71542: POP
71543: GO 71625
// for j in tmp do
71545: LD_ADDR_VAR 0 4
71549: PUSH
71550: LD_VAR 0 6
71554: PUSH
71555: FOR_IN
71556: IFFALSE 71615
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
71558: LD_ADDR_VAR 0 7
71562: PUSH
71563: LD_VAR 0 4
71567: PPUSH
71568: CALL_OW 313
71572: PPUSH
71573: LD_INT 25
71575: PUSH
71576: LD_INT 1
71578: PUSH
71579: EMPTY
71580: LIST
71581: LIST
71582: PPUSH
71583: CALL_OW 72
71587: ST_TO_ADDR
// if units then
71588: LD_VAR 0 7
71592: IFFALSE 71613
// begin ComExitBuilding ( units [ 1 ] ) ;
71594: LD_VAR 0 7
71598: PUSH
71599: LD_INT 1
71601: ARRAY
71602: PPUSH
71603: CALL_OW 122
// exit ;
71607: POP
71608: POP
71609: POP
71610: POP
71611: GO 71625
// end ; end ;
71613: GO 71555
71615: POP
71616: POP
// end ; end ; exit ;
71617: POP
71618: POP
71619: GO 71625
// end ; end ;
71621: GO 70979
71623: POP
71624: POP
// end ;
71625: LD_VAR 0 2
71629: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
71630: LD_INT 0
71632: PPUSH
71633: PPUSH
71634: PPUSH
71635: PPUSH
71636: PPUSH
71637: PPUSH
71638: PPUSH
// if not mc_bases or not skirmish then
71639: LD_EXP 14
71643: NOT
71644: PUSH
71645: LD_EXP 12
71649: NOT
71650: OR
71651: IFFALSE 71655
// exit ;
71653: GO 71886
// btype := GetBType ( building ) ;
71655: LD_ADDR_VAR 0 6
71659: PUSH
71660: LD_VAR 0 1
71664: PPUSH
71665: CALL_OW 266
71669: ST_TO_ADDR
// x := GetX ( building ) ;
71670: LD_ADDR_VAR 0 7
71674: PUSH
71675: LD_VAR 0 1
71679: PPUSH
71680: CALL_OW 250
71684: ST_TO_ADDR
// y := GetY ( building ) ;
71685: LD_ADDR_VAR 0 8
71689: PUSH
71690: LD_VAR 0 1
71694: PPUSH
71695: CALL_OW 251
71699: ST_TO_ADDR
// d := GetDir ( building ) ;
71700: LD_ADDR_VAR 0 9
71704: PUSH
71705: LD_VAR 0 1
71709: PPUSH
71710: CALL_OW 254
71714: ST_TO_ADDR
// for i = 1 to mc_bases do
71715: LD_ADDR_VAR 0 4
71719: PUSH
71720: DOUBLE
71721: LD_INT 1
71723: DEC
71724: ST_TO_ADDR
71725: LD_EXP 14
71729: PUSH
71730: FOR_TO
71731: IFFALSE 71884
// begin if not mc_build_list [ i ] then
71733: LD_EXP 19
71737: PUSH
71738: LD_VAR 0 4
71742: ARRAY
71743: NOT
71744: IFFALSE 71748
// continue ;
71746: GO 71730
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
71748: LD_VAR 0 6
71752: PUSH
71753: LD_VAR 0 7
71757: PUSH
71758: LD_VAR 0 8
71762: PUSH
71763: LD_VAR 0 9
71767: PUSH
71768: EMPTY
71769: LIST
71770: LIST
71771: LIST
71772: LIST
71773: PPUSH
71774: LD_EXP 19
71778: PUSH
71779: LD_VAR 0 4
71783: ARRAY
71784: PUSH
71785: LD_INT 1
71787: ARRAY
71788: PPUSH
71789: CALL 15634 0 2
71793: IFFALSE 71882
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
71795: LD_ADDR_EXP 19
71799: PUSH
71800: LD_EXP 19
71804: PPUSH
71805: LD_VAR 0 4
71809: PPUSH
71810: LD_EXP 19
71814: PUSH
71815: LD_VAR 0 4
71819: ARRAY
71820: PPUSH
71821: LD_INT 1
71823: PPUSH
71824: CALL_OW 3
71828: PPUSH
71829: CALL_OW 1
71833: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
71834: LD_ADDR_EXP 21
71838: PUSH
71839: LD_EXP 21
71843: PPUSH
71844: LD_VAR 0 4
71848: PUSH
71849: LD_EXP 21
71853: PUSH
71854: LD_VAR 0 4
71858: ARRAY
71859: PUSH
71860: LD_INT 1
71862: PLUS
71863: PUSH
71864: EMPTY
71865: LIST
71866: LIST
71867: PPUSH
71868: LD_VAR 0 1
71872: PPUSH
71873: CALL 9427 0 3
71877: ST_TO_ADDR
// exit ;
71878: POP
71879: POP
71880: GO 71886
// end ; end ;
71882: GO 71730
71884: POP
71885: POP
// end ;
71886: LD_VAR 0 3
71890: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
71891: LD_INT 0
71893: PPUSH
71894: PPUSH
71895: PPUSH
// if not mc_bases or not skirmish then
71896: LD_EXP 14
71900: NOT
71901: PUSH
71902: LD_EXP 12
71906: NOT
71907: OR
71908: IFFALSE 71912
// exit ;
71910: GO 72102
// for i = 1 to mc_bases do
71912: LD_ADDR_VAR 0 4
71916: PUSH
71917: DOUBLE
71918: LD_INT 1
71920: DEC
71921: ST_TO_ADDR
71922: LD_EXP 14
71926: PUSH
71927: FOR_TO
71928: IFFALSE 72015
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
71930: LD_VAR 0 1
71934: PUSH
71935: LD_EXP 22
71939: PUSH
71940: LD_VAR 0 4
71944: ARRAY
71945: IN
71946: PUSH
71947: LD_VAR 0 1
71951: PUSH
71952: LD_EXP 23
71956: PUSH
71957: LD_VAR 0 4
71961: ARRAY
71962: IN
71963: NOT
71964: AND
71965: IFFALSE 72013
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
71967: LD_ADDR_EXP 23
71971: PUSH
71972: LD_EXP 23
71976: PPUSH
71977: LD_VAR 0 4
71981: PUSH
71982: LD_EXP 23
71986: PUSH
71987: LD_VAR 0 4
71991: ARRAY
71992: PUSH
71993: LD_INT 1
71995: PLUS
71996: PUSH
71997: EMPTY
71998: LIST
71999: LIST
72000: PPUSH
72001: LD_VAR 0 1
72005: PPUSH
72006: CALL 9427 0 3
72010: ST_TO_ADDR
// break ;
72011: GO 72015
// end ; end ;
72013: GO 71927
72015: POP
72016: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
72017: LD_VAR 0 1
72021: PPUSH
72022: CALL_OW 257
72026: PUSH
72027: LD_EXP 40
72031: IN
72032: PUSH
72033: LD_VAR 0 1
72037: PPUSH
72038: CALL_OW 266
72042: PUSH
72043: LD_INT 5
72045: EQUAL
72046: AND
72047: PUSH
72048: LD_VAR 0 2
72052: PPUSH
72053: CALL_OW 110
72057: PUSH
72058: LD_INT 18
72060: NONEQUAL
72061: AND
72062: IFFALSE 72102
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
72064: LD_VAR 0 2
72068: PPUSH
72069: CALL_OW 257
72073: PUSH
72074: LD_INT 5
72076: PUSH
72077: LD_INT 8
72079: PUSH
72080: LD_INT 9
72082: PUSH
72083: EMPTY
72084: LIST
72085: LIST
72086: LIST
72087: IN
72088: IFFALSE 72102
// SetClass ( unit , 1 ) ;
72090: LD_VAR 0 2
72094: PPUSH
72095: LD_INT 1
72097: PPUSH
72098: CALL_OW 336
// end ;
72102: LD_VAR 0 3
72106: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
72107: LD_INT 0
72109: PPUSH
72110: PPUSH
// if not mc_bases or not skirmish then
72111: LD_EXP 14
72115: NOT
72116: PUSH
72117: LD_EXP 12
72121: NOT
72122: OR
72123: IFFALSE 72127
// exit ;
72125: GO 72243
// if GetLives ( abandoned_vehicle ) > 250 then
72127: LD_VAR 0 2
72131: PPUSH
72132: CALL_OW 256
72136: PUSH
72137: LD_INT 250
72139: GREATER
72140: IFFALSE 72144
// exit ;
72142: GO 72243
// for i = 1 to mc_bases do
72144: LD_ADDR_VAR 0 6
72148: PUSH
72149: DOUBLE
72150: LD_INT 1
72152: DEC
72153: ST_TO_ADDR
72154: LD_EXP 14
72158: PUSH
72159: FOR_TO
72160: IFFALSE 72241
// begin if driver in mc_bases [ i ] then
72162: LD_VAR 0 1
72166: PUSH
72167: LD_EXP 14
72171: PUSH
72172: LD_VAR 0 6
72176: ARRAY
72177: IN
72178: IFFALSE 72239
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
72180: LD_VAR 0 1
72184: PPUSH
72185: LD_EXP 14
72189: PUSH
72190: LD_VAR 0 6
72194: ARRAY
72195: PPUSH
72196: LD_INT 2
72198: PUSH
72199: LD_INT 30
72201: PUSH
72202: LD_INT 0
72204: PUSH
72205: EMPTY
72206: LIST
72207: LIST
72208: PUSH
72209: LD_INT 30
72211: PUSH
72212: LD_INT 1
72214: PUSH
72215: EMPTY
72216: LIST
72217: LIST
72218: PUSH
72219: EMPTY
72220: LIST
72221: LIST
72222: LIST
72223: PPUSH
72224: CALL_OW 72
72228: PUSH
72229: LD_INT 1
72231: ARRAY
72232: PPUSH
72233: CALL 41670 0 2
// break ;
72237: GO 72241
// end ; end ;
72239: GO 72159
72241: POP
72242: POP
// end ; end_of_file
72243: LD_VAR 0 5
72247: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
72248: LD_INT 0
72250: PPUSH
// ar_miner := 81 ;
72251: LD_ADDR_EXP 64
72255: PUSH
72256: LD_INT 81
72258: ST_TO_ADDR
// ar_crane := 88 ;
72259: LD_ADDR_EXP 63
72263: PUSH
72264: LD_INT 88
72266: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
72267: LD_ADDR_EXP 58
72271: PUSH
72272: LD_INT 89
72274: ST_TO_ADDR
// us_hack := 99 ;
72275: LD_ADDR_EXP 59
72279: PUSH
72280: LD_INT 99
72282: ST_TO_ADDR
// us_artillery := 97 ;
72283: LD_ADDR_EXP 60
72287: PUSH
72288: LD_INT 97
72290: ST_TO_ADDR
// ar_bio_bomb := 91 ;
72291: LD_ADDR_EXP 61
72295: PUSH
72296: LD_INT 91
72298: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
72299: LD_ADDR_EXP 62
72303: PUSH
72304: LD_INT 92
72306: ST_TO_ADDR
// ru_radar := 98 ;
72307: LD_ADDR_EXP 57
72311: PUSH
72312: LD_INT 98
72314: ST_TO_ADDR
// tech_Artillery := 80 ;
72315: LD_ADDR_EXP 65
72319: PUSH
72320: LD_INT 80
72322: ST_TO_ADDR
// tech_RadMat := 81 ;
72323: LD_ADDR_EXP 66
72327: PUSH
72328: LD_INT 81
72330: ST_TO_ADDR
// tech_BasicTools := 82 ;
72331: LD_ADDR_EXP 67
72335: PUSH
72336: LD_INT 82
72338: ST_TO_ADDR
// tech_Cargo := 83 ;
72339: LD_ADDR_EXP 68
72343: PUSH
72344: LD_INT 83
72346: ST_TO_ADDR
// tech_Track := 84 ;
72347: LD_ADDR_EXP 69
72351: PUSH
72352: LD_INT 84
72354: ST_TO_ADDR
// tech_Crane := 85 ;
72355: LD_ADDR_EXP 70
72359: PUSH
72360: LD_INT 85
72362: ST_TO_ADDR
// tech_Bulldozer := 86 ;
72363: LD_ADDR_EXP 71
72367: PUSH
72368: LD_INT 86
72370: ST_TO_ADDR
// tech_Hovercraft := 87 ;
72371: LD_ADDR_EXP 72
72375: PUSH
72376: LD_INT 87
72378: ST_TO_ADDR
// end ;
72379: LD_VAR 0 1
72383: RET
// every 1 do
72384: GO 72386
72386: DISABLE
// InitGlobalVariables ; end_of_file
72387: CALL 72248 0 0
72391: END
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
72392: LD_INT 0
72394: PPUSH
72395: PPUSH
72396: PPUSH
72397: PPUSH
72398: PPUSH
72399: PPUSH
72400: PPUSH
72401: PPUSH
72402: PPUSH
72403: PPUSH
72404: PPUSH
72405: PPUSH
72406: PPUSH
72407: PPUSH
72408: PPUSH
72409: PPUSH
72410: PPUSH
72411: PPUSH
72412: PPUSH
72413: PPUSH
72414: PPUSH
72415: PPUSH
72416: PPUSH
72417: PPUSH
72418: PPUSH
72419: PPUSH
72420: PPUSH
72421: PPUSH
72422: PPUSH
72423: PPUSH
72424: PPUSH
72425: PPUSH
72426: PPUSH
72427: PPUSH
// if not list then
72428: LD_VAR 0 1
72432: NOT
72433: IFFALSE 72437
// exit ;
72435: GO 77096
// base := list [ 1 ] ;
72437: LD_ADDR_VAR 0 3
72441: PUSH
72442: LD_VAR 0 1
72446: PUSH
72447: LD_INT 1
72449: ARRAY
72450: ST_TO_ADDR
// group := list [ 2 ] ;
72451: LD_ADDR_VAR 0 4
72455: PUSH
72456: LD_VAR 0 1
72460: PUSH
72461: LD_INT 2
72463: ARRAY
72464: ST_TO_ADDR
// path := list [ 3 ] ;
72465: LD_ADDR_VAR 0 5
72469: PUSH
72470: LD_VAR 0 1
72474: PUSH
72475: LD_INT 3
72477: ARRAY
72478: ST_TO_ADDR
// flags := list [ 4 ] ;
72479: LD_ADDR_VAR 0 6
72483: PUSH
72484: LD_VAR 0 1
72488: PUSH
72489: LD_INT 4
72491: ARRAY
72492: ST_TO_ADDR
// mined := [ ] ;
72493: LD_ADDR_VAR 0 27
72497: PUSH
72498: EMPTY
72499: ST_TO_ADDR
// bombed := [ ] ;
72500: LD_ADDR_VAR 0 28
72504: PUSH
72505: EMPTY
72506: ST_TO_ADDR
// healers := [ ] ;
72507: LD_ADDR_VAR 0 31
72511: PUSH
72512: EMPTY
72513: ST_TO_ADDR
// to_heal := [ ] ;
72514: LD_ADDR_VAR 0 30
72518: PUSH
72519: EMPTY
72520: ST_TO_ADDR
// repairs := [ ] ;
72521: LD_ADDR_VAR 0 33
72525: PUSH
72526: EMPTY
72527: ST_TO_ADDR
// to_repair := [ ] ;
72528: LD_ADDR_VAR 0 32
72532: PUSH
72533: EMPTY
72534: ST_TO_ADDR
// if not group or not path then
72535: LD_VAR 0 4
72539: NOT
72540: PUSH
72541: LD_VAR 0 5
72545: NOT
72546: OR
72547: IFFALSE 72551
// exit ;
72549: GO 77096
// side := GetSide ( group [ 1 ] ) ;
72551: LD_ADDR_VAR 0 35
72555: PUSH
72556: LD_VAR 0 4
72560: PUSH
72561: LD_INT 1
72563: ARRAY
72564: PPUSH
72565: CALL_OW 255
72569: ST_TO_ADDR
// if flags then
72570: LD_VAR 0 6
72574: IFFALSE 72718
// begin f_ignore_area := flags [ 1 ] ;
72576: LD_ADDR_VAR 0 17
72580: PUSH
72581: LD_VAR 0 6
72585: PUSH
72586: LD_INT 1
72588: ARRAY
72589: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
72590: LD_ADDR_VAR 0 18
72594: PUSH
72595: LD_VAR 0 6
72599: PUSH
72600: LD_INT 2
72602: ARRAY
72603: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
72604: LD_ADDR_VAR 0 19
72608: PUSH
72609: LD_VAR 0 6
72613: PUSH
72614: LD_INT 3
72616: ARRAY
72617: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
72618: LD_ADDR_VAR 0 20
72622: PUSH
72623: LD_VAR 0 6
72627: PUSH
72628: LD_INT 4
72630: ARRAY
72631: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
72632: LD_ADDR_VAR 0 21
72636: PUSH
72637: LD_VAR 0 6
72641: PUSH
72642: LD_INT 5
72644: ARRAY
72645: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
72646: LD_ADDR_VAR 0 22
72650: PUSH
72651: LD_VAR 0 6
72655: PUSH
72656: LD_INT 6
72658: ARRAY
72659: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
72660: LD_ADDR_VAR 0 23
72664: PUSH
72665: LD_VAR 0 6
72669: PUSH
72670: LD_INT 7
72672: ARRAY
72673: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
72674: LD_ADDR_VAR 0 24
72678: PUSH
72679: LD_VAR 0 6
72683: PUSH
72684: LD_INT 8
72686: ARRAY
72687: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
72688: LD_ADDR_VAR 0 25
72692: PUSH
72693: LD_VAR 0 6
72697: PUSH
72698: LD_INT 9
72700: ARRAY
72701: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
72702: LD_ADDR_VAR 0 26
72706: PUSH
72707: LD_VAR 0 6
72711: PUSH
72712: LD_INT 10
72714: ARRAY
72715: ST_TO_ADDR
// end else
72716: GO 72798
// begin f_ignore_area := false ;
72718: LD_ADDR_VAR 0 17
72722: PUSH
72723: LD_INT 0
72725: ST_TO_ADDR
// f_capture := false ;
72726: LD_ADDR_VAR 0 18
72730: PUSH
72731: LD_INT 0
72733: ST_TO_ADDR
// f_ignore_civ := false ;
72734: LD_ADDR_VAR 0 19
72738: PUSH
72739: LD_INT 0
72741: ST_TO_ADDR
// f_murder := false ;
72742: LD_ADDR_VAR 0 20
72746: PUSH
72747: LD_INT 0
72749: ST_TO_ADDR
// f_mines := false ;
72750: LD_ADDR_VAR 0 21
72754: PUSH
72755: LD_INT 0
72757: ST_TO_ADDR
// f_repair := false ;
72758: LD_ADDR_VAR 0 22
72762: PUSH
72763: LD_INT 0
72765: ST_TO_ADDR
// f_heal := false ;
72766: LD_ADDR_VAR 0 23
72770: PUSH
72771: LD_INT 0
72773: ST_TO_ADDR
// f_spacetime := false ;
72774: LD_ADDR_VAR 0 24
72778: PUSH
72779: LD_INT 0
72781: ST_TO_ADDR
// f_attack_depot := false ;
72782: LD_ADDR_VAR 0 25
72786: PUSH
72787: LD_INT 0
72789: ST_TO_ADDR
// f_crawl := false ;
72790: LD_ADDR_VAR 0 26
72794: PUSH
72795: LD_INT 0
72797: ST_TO_ADDR
// end ; if f_heal then
72798: LD_VAR 0 23
72802: IFFALSE 72829
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
72804: LD_ADDR_VAR 0 31
72808: PUSH
72809: LD_VAR 0 4
72813: PPUSH
72814: LD_INT 25
72816: PUSH
72817: LD_INT 4
72819: PUSH
72820: EMPTY
72821: LIST
72822: LIST
72823: PPUSH
72824: CALL_OW 72
72828: ST_TO_ADDR
// if f_repair then
72829: LD_VAR 0 22
72833: IFFALSE 72860
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
72835: LD_ADDR_VAR 0 33
72839: PUSH
72840: LD_VAR 0 4
72844: PPUSH
72845: LD_INT 25
72847: PUSH
72848: LD_INT 3
72850: PUSH
72851: EMPTY
72852: LIST
72853: LIST
72854: PPUSH
72855: CALL_OW 72
72859: ST_TO_ADDR
// units_path := [ ] ;
72860: LD_ADDR_VAR 0 16
72864: PUSH
72865: EMPTY
72866: ST_TO_ADDR
// for i = 1 to group do
72867: LD_ADDR_VAR 0 7
72871: PUSH
72872: DOUBLE
72873: LD_INT 1
72875: DEC
72876: ST_TO_ADDR
72877: LD_VAR 0 4
72881: PUSH
72882: FOR_TO
72883: IFFALSE 72912
// units_path := Replace ( units_path , i , path ) ;
72885: LD_ADDR_VAR 0 16
72889: PUSH
72890: LD_VAR 0 16
72894: PPUSH
72895: LD_VAR 0 7
72899: PPUSH
72900: LD_VAR 0 5
72904: PPUSH
72905: CALL_OW 1
72909: ST_TO_ADDR
72910: GO 72882
72912: POP
72913: POP
// repeat for i = group downto 1 do
72914: LD_ADDR_VAR 0 7
72918: PUSH
72919: DOUBLE
72920: LD_VAR 0 4
72924: INC
72925: ST_TO_ADDR
72926: LD_INT 1
72928: PUSH
72929: FOR_DOWNTO
72930: IFFALSE 77052
// begin wait ( 5 ) ;
72932: LD_INT 5
72934: PPUSH
72935: CALL_OW 67
// tmp := [ ] ;
72939: LD_ADDR_VAR 0 14
72943: PUSH
72944: EMPTY
72945: ST_TO_ADDR
// attacking := false ;
72946: LD_ADDR_VAR 0 29
72950: PUSH
72951: LD_INT 0
72953: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
72954: LD_VAR 0 4
72958: PUSH
72959: LD_VAR 0 7
72963: ARRAY
72964: PPUSH
72965: CALL_OW 301
72969: PUSH
72970: LD_VAR 0 4
72974: PUSH
72975: LD_VAR 0 7
72979: ARRAY
72980: NOT
72981: OR
72982: IFFALSE 73091
// begin if GetType ( group [ i ] ) = unit_human then
72984: LD_VAR 0 4
72988: PUSH
72989: LD_VAR 0 7
72993: ARRAY
72994: PPUSH
72995: CALL_OW 247
72999: PUSH
73000: LD_INT 1
73002: EQUAL
73003: IFFALSE 73049
// begin to_heal := to_heal diff group [ i ] ;
73005: LD_ADDR_VAR 0 30
73009: PUSH
73010: LD_VAR 0 30
73014: PUSH
73015: LD_VAR 0 4
73019: PUSH
73020: LD_VAR 0 7
73024: ARRAY
73025: DIFF
73026: ST_TO_ADDR
// healers := healers diff group [ i ] ;
73027: LD_ADDR_VAR 0 31
73031: PUSH
73032: LD_VAR 0 31
73036: PUSH
73037: LD_VAR 0 4
73041: PUSH
73042: LD_VAR 0 7
73046: ARRAY
73047: DIFF
73048: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
73049: LD_ADDR_VAR 0 4
73053: PUSH
73054: LD_VAR 0 4
73058: PPUSH
73059: LD_VAR 0 7
73063: PPUSH
73064: CALL_OW 3
73068: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
73069: LD_ADDR_VAR 0 16
73073: PUSH
73074: LD_VAR 0 16
73078: PPUSH
73079: LD_VAR 0 7
73083: PPUSH
73084: CALL_OW 3
73088: ST_TO_ADDR
// continue ;
73089: GO 72929
// end ; if f_repair then
73091: LD_VAR 0 22
73095: IFFALSE 73584
// begin if GetType ( group [ i ] ) = unit_vehicle then
73097: LD_VAR 0 4
73101: PUSH
73102: LD_VAR 0 7
73106: ARRAY
73107: PPUSH
73108: CALL_OW 247
73112: PUSH
73113: LD_INT 2
73115: EQUAL
73116: IFFALSE 73306
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
73118: LD_VAR 0 4
73122: PUSH
73123: LD_VAR 0 7
73127: ARRAY
73128: PPUSH
73129: CALL_OW 256
73133: PUSH
73134: LD_INT 700
73136: LESS
73137: PUSH
73138: LD_VAR 0 4
73142: PUSH
73143: LD_VAR 0 7
73147: ARRAY
73148: PUSH
73149: LD_VAR 0 32
73153: IN
73154: NOT
73155: AND
73156: IFFALSE 73180
// to_repair := to_repair union group [ i ] ;
73158: LD_ADDR_VAR 0 32
73162: PUSH
73163: LD_VAR 0 32
73167: PUSH
73168: LD_VAR 0 4
73172: PUSH
73173: LD_VAR 0 7
73177: ARRAY
73178: UNION
73179: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
73180: LD_VAR 0 4
73184: PUSH
73185: LD_VAR 0 7
73189: ARRAY
73190: PPUSH
73191: CALL_OW 256
73195: PUSH
73196: LD_INT 1000
73198: EQUAL
73199: PUSH
73200: LD_VAR 0 4
73204: PUSH
73205: LD_VAR 0 7
73209: ARRAY
73210: PUSH
73211: LD_VAR 0 32
73215: IN
73216: AND
73217: IFFALSE 73241
// to_repair := to_repair diff group [ i ] ;
73219: LD_ADDR_VAR 0 32
73223: PUSH
73224: LD_VAR 0 32
73228: PUSH
73229: LD_VAR 0 4
73233: PUSH
73234: LD_VAR 0 7
73238: ARRAY
73239: DIFF
73240: ST_TO_ADDR
// if group [ i ] in to_repair then
73241: LD_VAR 0 4
73245: PUSH
73246: LD_VAR 0 7
73250: ARRAY
73251: PUSH
73252: LD_VAR 0 32
73256: IN
73257: IFFALSE 73304
// begin if not IsInArea ( group [ i ] , f_repair ) then
73259: LD_VAR 0 4
73263: PUSH
73264: LD_VAR 0 7
73268: ARRAY
73269: PPUSH
73270: LD_VAR 0 22
73274: PPUSH
73275: CALL_OW 308
73279: NOT
73280: IFFALSE 73302
// ComMoveToArea ( group [ i ] , f_repair ) ;
73282: LD_VAR 0 4
73286: PUSH
73287: LD_VAR 0 7
73291: ARRAY
73292: PPUSH
73293: LD_VAR 0 22
73297: PPUSH
73298: CALL_OW 113
// continue ;
73302: GO 72929
// end ; end else
73304: GO 73584
// if group [ i ] in repairs then
73306: LD_VAR 0 4
73310: PUSH
73311: LD_VAR 0 7
73315: ARRAY
73316: PUSH
73317: LD_VAR 0 33
73321: IN
73322: IFFALSE 73584
// begin if IsInUnit ( group [ i ] ) then
73324: LD_VAR 0 4
73328: PUSH
73329: LD_VAR 0 7
73333: ARRAY
73334: PPUSH
73335: CALL_OW 310
73339: IFFALSE 73407
// begin z := IsInUnit ( group [ i ] ) ;
73341: LD_ADDR_VAR 0 13
73345: PUSH
73346: LD_VAR 0 4
73350: PUSH
73351: LD_VAR 0 7
73355: ARRAY
73356: PPUSH
73357: CALL_OW 310
73361: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
73362: LD_VAR 0 13
73366: PUSH
73367: LD_VAR 0 32
73371: IN
73372: PUSH
73373: LD_VAR 0 13
73377: PPUSH
73378: LD_VAR 0 22
73382: PPUSH
73383: CALL_OW 308
73387: AND
73388: IFFALSE 73405
// ComExitVehicle ( group [ i ] ) ;
73390: LD_VAR 0 4
73394: PUSH
73395: LD_VAR 0 7
73399: ARRAY
73400: PPUSH
73401: CALL_OW 121
// end else
73405: GO 73584
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
73407: LD_ADDR_VAR 0 13
73411: PUSH
73412: LD_VAR 0 4
73416: PPUSH
73417: LD_INT 95
73419: PUSH
73420: LD_VAR 0 22
73424: PUSH
73425: EMPTY
73426: LIST
73427: LIST
73428: PUSH
73429: LD_INT 58
73431: PUSH
73432: EMPTY
73433: LIST
73434: PUSH
73435: EMPTY
73436: LIST
73437: LIST
73438: PPUSH
73439: CALL_OW 72
73443: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
73444: LD_VAR 0 4
73448: PUSH
73449: LD_VAR 0 7
73453: ARRAY
73454: PPUSH
73455: CALL_OW 314
73459: NOT
73460: IFFALSE 73582
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
73462: LD_ADDR_VAR 0 10
73466: PUSH
73467: LD_VAR 0 13
73471: PPUSH
73472: LD_VAR 0 4
73476: PUSH
73477: LD_VAR 0 7
73481: ARRAY
73482: PPUSH
73483: CALL_OW 74
73487: ST_TO_ADDR
// if not x then
73488: LD_VAR 0 10
73492: NOT
73493: IFFALSE 73497
// continue ;
73495: GO 72929
// if GetLives ( x ) < 1000 then
73497: LD_VAR 0 10
73501: PPUSH
73502: CALL_OW 256
73506: PUSH
73507: LD_INT 1000
73509: LESS
73510: IFFALSE 73534
// ComRepairVehicle ( group [ i ] , x ) else
73512: LD_VAR 0 4
73516: PUSH
73517: LD_VAR 0 7
73521: ARRAY
73522: PPUSH
73523: LD_VAR 0 10
73527: PPUSH
73528: CALL_OW 129
73532: GO 73582
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
73534: LD_VAR 0 23
73538: PUSH
73539: LD_VAR 0 4
73543: PUSH
73544: LD_VAR 0 7
73548: ARRAY
73549: PPUSH
73550: CALL_OW 256
73554: PUSH
73555: LD_INT 1000
73557: LESS
73558: AND
73559: NOT
73560: IFFALSE 73582
// ComEnterUnit ( group [ i ] , x ) ;
73562: LD_VAR 0 4
73566: PUSH
73567: LD_VAR 0 7
73571: ARRAY
73572: PPUSH
73573: LD_VAR 0 10
73577: PPUSH
73578: CALL_OW 120
// end ; continue ;
73582: GO 72929
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
73584: LD_VAR 0 23
73588: PUSH
73589: LD_VAR 0 4
73593: PUSH
73594: LD_VAR 0 7
73598: ARRAY
73599: PPUSH
73600: CALL_OW 247
73604: PUSH
73605: LD_INT 1
73607: EQUAL
73608: AND
73609: IFFALSE 74087
// begin if group [ i ] in healers then
73611: LD_VAR 0 4
73615: PUSH
73616: LD_VAR 0 7
73620: ARRAY
73621: PUSH
73622: LD_VAR 0 31
73626: IN
73627: IFFALSE 73900
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
73629: LD_VAR 0 4
73633: PUSH
73634: LD_VAR 0 7
73638: ARRAY
73639: PPUSH
73640: LD_VAR 0 23
73644: PPUSH
73645: CALL_OW 308
73649: NOT
73650: PUSH
73651: LD_VAR 0 4
73655: PUSH
73656: LD_VAR 0 7
73660: ARRAY
73661: PPUSH
73662: CALL_OW 314
73666: NOT
73667: AND
73668: IFFALSE 73692
// ComMoveToArea ( group [ i ] , f_heal ) else
73670: LD_VAR 0 4
73674: PUSH
73675: LD_VAR 0 7
73679: ARRAY
73680: PPUSH
73681: LD_VAR 0 23
73685: PPUSH
73686: CALL_OW 113
73690: GO 73898
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
73692: LD_VAR 0 4
73696: PUSH
73697: LD_VAR 0 7
73701: ARRAY
73702: PPUSH
73703: CALL 38132 0 1
73707: PPUSH
73708: CALL_OW 256
73712: PUSH
73713: LD_INT 1000
73715: EQUAL
73716: IFFALSE 73735
// ComStop ( group [ i ] ) else
73718: LD_VAR 0 4
73722: PUSH
73723: LD_VAR 0 7
73727: ARRAY
73728: PPUSH
73729: CALL_OW 141
73733: GO 73898
// if not HasTask ( group [ i ] ) and to_heal then
73735: LD_VAR 0 4
73739: PUSH
73740: LD_VAR 0 7
73744: ARRAY
73745: PPUSH
73746: CALL_OW 314
73750: NOT
73751: PUSH
73752: LD_VAR 0 30
73756: AND
73757: IFFALSE 73898
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
73759: LD_ADDR_VAR 0 13
73763: PUSH
73764: LD_VAR 0 30
73768: PPUSH
73769: LD_INT 3
73771: PUSH
73772: LD_INT 54
73774: PUSH
73775: EMPTY
73776: LIST
73777: PUSH
73778: EMPTY
73779: LIST
73780: LIST
73781: PPUSH
73782: CALL_OW 72
73786: PPUSH
73787: LD_VAR 0 4
73791: PUSH
73792: LD_VAR 0 7
73796: ARRAY
73797: PPUSH
73798: CALL_OW 74
73802: ST_TO_ADDR
// if z then
73803: LD_VAR 0 13
73807: IFFALSE 73898
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
73809: LD_INT 91
73811: PUSH
73812: LD_VAR 0 13
73816: PUSH
73817: LD_INT 10
73819: PUSH
73820: EMPTY
73821: LIST
73822: LIST
73823: LIST
73824: PUSH
73825: LD_INT 81
73827: PUSH
73828: LD_VAR 0 13
73832: PPUSH
73833: CALL_OW 255
73837: PUSH
73838: EMPTY
73839: LIST
73840: LIST
73841: PUSH
73842: EMPTY
73843: LIST
73844: LIST
73845: PPUSH
73846: CALL_OW 69
73850: PUSH
73851: LD_INT 0
73853: EQUAL
73854: IFFALSE 73878
// ComHeal ( group [ i ] , z ) else
73856: LD_VAR 0 4
73860: PUSH
73861: LD_VAR 0 7
73865: ARRAY
73866: PPUSH
73867: LD_VAR 0 13
73871: PPUSH
73872: CALL_OW 128
73876: GO 73898
// ComMoveToArea ( group [ i ] , f_heal ) ;
73878: LD_VAR 0 4
73882: PUSH
73883: LD_VAR 0 7
73887: ARRAY
73888: PPUSH
73889: LD_VAR 0 23
73893: PPUSH
73894: CALL_OW 113
// end ; continue ;
73898: GO 72929
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
73900: LD_VAR 0 4
73904: PUSH
73905: LD_VAR 0 7
73909: ARRAY
73910: PPUSH
73911: CALL_OW 256
73915: PUSH
73916: LD_INT 700
73918: LESS
73919: PUSH
73920: LD_VAR 0 4
73924: PUSH
73925: LD_VAR 0 7
73929: ARRAY
73930: PUSH
73931: LD_VAR 0 30
73935: IN
73936: NOT
73937: AND
73938: IFFALSE 73962
// to_heal := to_heal union group [ i ] ;
73940: LD_ADDR_VAR 0 30
73944: PUSH
73945: LD_VAR 0 30
73949: PUSH
73950: LD_VAR 0 4
73954: PUSH
73955: LD_VAR 0 7
73959: ARRAY
73960: UNION
73961: ST_TO_ADDR
// if group [ i ] in to_heal then
73962: LD_VAR 0 4
73966: PUSH
73967: LD_VAR 0 7
73971: ARRAY
73972: PUSH
73973: LD_VAR 0 30
73977: IN
73978: IFFALSE 74087
// begin if GetLives ( group [ i ] ) = 1000 then
73980: LD_VAR 0 4
73984: PUSH
73985: LD_VAR 0 7
73989: ARRAY
73990: PPUSH
73991: CALL_OW 256
73995: PUSH
73996: LD_INT 1000
73998: EQUAL
73999: IFFALSE 74025
// to_heal := to_heal diff group [ i ] else
74001: LD_ADDR_VAR 0 30
74005: PUSH
74006: LD_VAR 0 30
74010: PUSH
74011: LD_VAR 0 4
74015: PUSH
74016: LD_VAR 0 7
74020: ARRAY
74021: DIFF
74022: ST_TO_ADDR
74023: GO 74087
// begin if not IsInArea ( group [ i ] , to_heal ) then
74025: LD_VAR 0 4
74029: PUSH
74030: LD_VAR 0 7
74034: ARRAY
74035: PPUSH
74036: LD_VAR 0 30
74040: PPUSH
74041: CALL_OW 308
74045: NOT
74046: IFFALSE 74070
// ComMoveToArea ( group [ i ] , f_heal ) else
74048: LD_VAR 0 4
74052: PUSH
74053: LD_VAR 0 7
74057: ARRAY
74058: PPUSH
74059: LD_VAR 0 23
74063: PPUSH
74064: CALL_OW 113
74068: GO 74085
// ComHold ( group [ i ] ) ;
74070: LD_VAR 0 4
74074: PUSH
74075: LD_VAR 0 7
74079: ARRAY
74080: PPUSH
74081: CALL_OW 140
// continue ;
74085: GO 72929
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
74087: LD_VAR 0 4
74091: PUSH
74092: LD_VAR 0 7
74096: ARRAY
74097: PPUSH
74098: LD_INT 10
74100: PPUSH
74101: CALL 36552 0 2
74105: NOT
74106: PUSH
74107: LD_VAR 0 16
74111: PUSH
74112: LD_VAR 0 7
74116: ARRAY
74117: PUSH
74118: EMPTY
74119: EQUAL
74120: NOT
74121: AND
74122: IFFALSE 74388
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
74124: LD_VAR 0 4
74128: PUSH
74129: LD_VAR 0 7
74133: ARRAY
74134: PPUSH
74135: CALL_OW 262
74139: PUSH
74140: LD_INT 1
74142: PUSH
74143: LD_INT 2
74145: PUSH
74146: EMPTY
74147: LIST
74148: LIST
74149: IN
74150: IFFALSE 74191
// if GetFuel ( group [ i ] ) < 10 then
74152: LD_VAR 0 4
74156: PUSH
74157: LD_VAR 0 7
74161: ARRAY
74162: PPUSH
74163: CALL_OW 261
74167: PUSH
74168: LD_INT 10
74170: LESS
74171: IFFALSE 74191
// SetFuel ( group [ i ] , 12 ) ;
74173: LD_VAR 0 4
74177: PUSH
74178: LD_VAR 0 7
74182: ARRAY
74183: PPUSH
74184: LD_INT 12
74186: PPUSH
74187: CALL_OW 240
// if units_path [ i ] then
74191: LD_VAR 0 16
74195: PUSH
74196: LD_VAR 0 7
74200: ARRAY
74201: IFFALSE 74386
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
74203: LD_VAR 0 4
74207: PUSH
74208: LD_VAR 0 7
74212: ARRAY
74213: PPUSH
74214: LD_VAR 0 16
74218: PUSH
74219: LD_VAR 0 7
74223: ARRAY
74224: PUSH
74225: LD_INT 1
74227: ARRAY
74228: PUSH
74229: LD_INT 1
74231: ARRAY
74232: PPUSH
74233: LD_VAR 0 16
74237: PUSH
74238: LD_VAR 0 7
74242: ARRAY
74243: PUSH
74244: LD_INT 1
74246: ARRAY
74247: PUSH
74248: LD_INT 2
74250: ARRAY
74251: PPUSH
74252: CALL_OW 297
74256: PUSH
74257: LD_INT 6
74259: GREATER
74260: IFFALSE 74335
// begin if not HasTask ( group [ i ] ) then
74262: LD_VAR 0 4
74266: PUSH
74267: LD_VAR 0 7
74271: ARRAY
74272: PPUSH
74273: CALL_OW 314
74277: NOT
74278: IFFALSE 74333
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
74280: LD_VAR 0 4
74284: PUSH
74285: LD_VAR 0 7
74289: ARRAY
74290: PPUSH
74291: LD_VAR 0 16
74295: PUSH
74296: LD_VAR 0 7
74300: ARRAY
74301: PUSH
74302: LD_INT 1
74304: ARRAY
74305: PUSH
74306: LD_INT 1
74308: ARRAY
74309: PPUSH
74310: LD_VAR 0 16
74314: PUSH
74315: LD_VAR 0 7
74319: ARRAY
74320: PUSH
74321: LD_INT 1
74323: ARRAY
74324: PUSH
74325: LD_INT 2
74327: ARRAY
74328: PPUSH
74329: CALL_OW 114
// end else
74333: GO 74386
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
74335: LD_ADDR_VAR 0 15
74339: PUSH
74340: LD_VAR 0 16
74344: PUSH
74345: LD_VAR 0 7
74349: ARRAY
74350: PPUSH
74351: LD_INT 1
74353: PPUSH
74354: CALL_OW 3
74358: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
74359: LD_ADDR_VAR 0 16
74363: PUSH
74364: LD_VAR 0 16
74368: PPUSH
74369: LD_VAR 0 7
74373: PPUSH
74374: LD_VAR 0 15
74378: PPUSH
74379: CALL_OW 1
74383: ST_TO_ADDR
// continue ;
74384: GO 72929
// end ; end ; end else
74386: GO 77050
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
74388: LD_ADDR_VAR 0 14
74392: PUSH
74393: LD_INT 81
74395: PUSH
74396: LD_VAR 0 4
74400: PUSH
74401: LD_VAR 0 7
74405: ARRAY
74406: PPUSH
74407: CALL_OW 255
74411: PUSH
74412: EMPTY
74413: LIST
74414: LIST
74415: PPUSH
74416: CALL_OW 69
74420: ST_TO_ADDR
// if not tmp then
74421: LD_VAR 0 14
74425: NOT
74426: IFFALSE 74430
// continue ;
74428: GO 72929
// if f_ignore_area then
74430: LD_VAR 0 17
74434: IFFALSE 74522
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
74436: LD_ADDR_VAR 0 15
74440: PUSH
74441: LD_VAR 0 14
74445: PPUSH
74446: LD_INT 3
74448: PUSH
74449: LD_INT 92
74451: PUSH
74452: LD_VAR 0 17
74456: PUSH
74457: LD_INT 1
74459: ARRAY
74460: PUSH
74461: LD_VAR 0 17
74465: PUSH
74466: LD_INT 2
74468: ARRAY
74469: PUSH
74470: LD_VAR 0 17
74474: PUSH
74475: LD_INT 3
74477: ARRAY
74478: PUSH
74479: EMPTY
74480: LIST
74481: LIST
74482: LIST
74483: LIST
74484: PUSH
74485: EMPTY
74486: LIST
74487: LIST
74488: PPUSH
74489: CALL_OW 72
74493: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
74494: LD_VAR 0 14
74498: PUSH
74499: LD_VAR 0 15
74503: DIFF
74504: IFFALSE 74522
// tmp := tmp diff tmp2 ;
74506: LD_ADDR_VAR 0 14
74510: PUSH
74511: LD_VAR 0 14
74515: PUSH
74516: LD_VAR 0 15
74520: DIFF
74521: ST_TO_ADDR
// end ; if not f_murder then
74522: LD_VAR 0 20
74526: NOT
74527: IFFALSE 74585
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
74529: LD_ADDR_VAR 0 15
74533: PUSH
74534: LD_VAR 0 14
74538: PPUSH
74539: LD_INT 3
74541: PUSH
74542: LD_INT 50
74544: PUSH
74545: EMPTY
74546: LIST
74547: PUSH
74548: EMPTY
74549: LIST
74550: LIST
74551: PPUSH
74552: CALL_OW 72
74556: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
74557: LD_VAR 0 14
74561: PUSH
74562: LD_VAR 0 15
74566: DIFF
74567: IFFALSE 74585
// tmp := tmp diff tmp2 ;
74569: LD_ADDR_VAR 0 14
74573: PUSH
74574: LD_VAR 0 14
74578: PUSH
74579: LD_VAR 0 15
74583: DIFF
74584: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
74585: LD_ADDR_VAR 0 14
74589: PUSH
74590: LD_VAR 0 4
74594: PUSH
74595: LD_VAR 0 7
74599: ARRAY
74600: PPUSH
74601: LD_VAR 0 14
74605: PPUSH
74606: LD_INT 1
74608: PPUSH
74609: LD_INT 1
74611: PPUSH
74612: CALL 9862 0 4
74616: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
74617: LD_VAR 0 4
74621: PUSH
74622: LD_VAR 0 7
74626: ARRAY
74627: PPUSH
74628: CALL_OW 257
74632: PUSH
74633: LD_INT 1
74635: EQUAL
74636: IFFALSE 75084
// begin if WantPlant ( group [ i ] ) then
74638: LD_VAR 0 4
74642: PUSH
74643: LD_VAR 0 7
74647: ARRAY
74648: PPUSH
74649: CALL 9363 0 1
74653: IFFALSE 74657
// continue ;
74655: GO 72929
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
74657: LD_VAR 0 18
74661: PUSH
74662: LD_VAR 0 4
74666: PUSH
74667: LD_VAR 0 7
74671: ARRAY
74672: PPUSH
74673: CALL_OW 310
74677: NOT
74678: AND
74679: PUSH
74680: LD_VAR 0 14
74684: PUSH
74685: LD_INT 1
74687: ARRAY
74688: PUSH
74689: LD_VAR 0 14
74693: PPUSH
74694: LD_INT 21
74696: PUSH
74697: LD_INT 2
74699: PUSH
74700: EMPTY
74701: LIST
74702: LIST
74703: PUSH
74704: LD_INT 58
74706: PUSH
74707: EMPTY
74708: LIST
74709: PUSH
74710: EMPTY
74711: LIST
74712: LIST
74713: PPUSH
74714: CALL_OW 72
74718: IN
74719: AND
74720: IFFALSE 74756
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
74722: LD_VAR 0 4
74726: PUSH
74727: LD_VAR 0 7
74731: ARRAY
74732: PPUSH
74733: LD_VAR 0 14
74737: PUSH
74738: LD_INT 1
74740: ARRAY
74741: PPUSH
74742: CALL_OW 120
// attacking := true ;
74746: LD_ADDR_VAR 0 29
74750: PUSH
74751: LD_INT 1
74753: ST_TO_ADDR
// continue ;
74754: GO 72929
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
74756: LD_VAR 0 26
74760: PUSH
74761: LD_VAR 0 4
74765: PUSH
74766: LD_VAR 0 7
74770: ARRAY
74771: PPUSH
74772: CALL_OW 257
74776: PUSH
74777: LD_INT 1
74779: EQUAL
74780: AND
74781: PUSH
74782: LD_VAR 0 4
74786: PUSH
74787: LD_VAR 0 7
74791: ARRAY
74792: PPUSH
74793: CALL_OW 256
74797: PUSH
74798: LD_INT 800
74800: LESS
74801: AND
74802: PUSH
74803: LD_VAR 0 4
74807: PUSH
74808: LD_VAR 0 7
74812: ARRAY
74813: PPUSH
74814: CALL_OW 318
74818: NOT
74819: AND
74820: IFFALSE 74837
// ComCrawl ( group [ i ] ) ;
74822: LD_VAR 0 4
74826: PUSH
74827: LD_VAR 0 7
74831: ARRAY
74832: PPUSH
74833: CALL_OW 137
// if f_mines then
74837: LD_VAR 0 21
74841: IFFALSE 75084
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
74843: LD_VAR 0 14
74847: PUSH
74848: LD_INT 1
74850: ARRAY
74851: PPUSH
74852: CALL_OW 247
74856: PUSH
74857: LD_INT 3
74859: EQUAL
74860: PUSH
74861: LD_VAR 0 14
74865: PUSH
74866: LD_INT 1
74868: ARRAY
74869: PUSH
74870: LD_VAR 0 27
74874: IN
74875: NOT
74876: AND
74877: IFFALSE 75084
// begin x := GetX ( tmp [ 1 ] ) ;
74879: LD_ADDR_VAR 0 10
74883: PUSH
74884: LD_VAR 0 14
74888: PUSH
74889: LD_INT 1
74891: ARRAY
74892: PPUSH
74893: CALL_OW 250
74897: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
74898: LD_ADDR_VAR 0 11
74902: PUSH
74903: LD_VAR 0 14
74907: PUSH
74908: LD_INT 1
74910: ARRAY
74911: PPUSH
74912: CALL_OW 251
74916: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
74917: LD_ADDR_VAR 0 12
74921: PUSH
74922: LD_VAR 0 4
74926: PUSH
74927: LD_VAR 0 7
74931: ARRAY
74932: PPUSH
74933: CALL 36637 0 1
74937: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
74938: LD_VAR 0 4
74942: PUSH
74943: LD_VAR 0 7
74947: ARRAY
74948: PPUSH
74949: LD_VAR 0 10
74953: PPUSH
74954: LD_VAR 0 11
74958: PPUSH
74959: LD_VAR 0 14
74963: PUSH
74964: LD_INT 1
74966: ARRAY
74967: PPUSH
74968: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
74972: LD_VAR 0 4
74976: PUSH
74977: LD_VAR 0 7
74981: ARRAY
74982: PPUSH
74983: LD_VAR 0 10
74987: PPUSH
74988: LD_VAR 0 12
74992: PPUSH
74993: LD_INT 7
74995: PPUSH
74996: CALL_OW 272
75000: PPUSH
75001: LD_VAR 0 11
75005: PPUSH
75006: LD_VAR 0 12
75010: PPUSH
75011: LD_INT 7
75013: PPUSH
75014: CALL_OW 273
75018: PPUSH
75019: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
75023: LD_VAR 0 4
75027: PUSH
75028: LD_VAR 0 7
75032: ARRAY
75033: PPUSH
75034: LD_INT 71
75036: PPUSH
75037: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
75041: LD_ADDR_VAR 0 27
75045: PUSH
75046: LD_VAR 0 27
75050: PPUSH
75051: LD_VAR 0 27
75055: PUSH
75056: LD_INT 1
75058: PLUS
75059: PPUSH
75060: LD_VAR 0 14
75064: PUSH
75065: LD_INT 1
75067: ARRAY
75068: PPUSH
75069: CALL_OW 1
75073: ST_TO_ADDR
// attacking := true ;
75074: LD_ADDR_VAR 0 29
75078: PUSH
75079: LD_INT 1
75081: ST_TO_ADDR
// continue ;
75082: GO 72929
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
75084: LD_VAR 0 4
75088: PUSH
75089: LD_VAR 0 7
75093: ARRAY
75094: PPUSH
75095: CALL_OW 257
75099: PUSH
75100: LD_INT 17
75102: EQUAL
75103: PUSH
75104: LD_VAR 0 4
75108: PUSH
75109: LD_VAR 0 7
75113: ARRAY
75114: PPUSH
75115: CALL_OW 110
75119: PUSH
75120: LD_INT 71
75122: EQUAL
75123: NOT
75124: AND
75125: IFFALSE 75271
// begin attacking := false ;
75127: LD_ADDR_VAR 0 29
75131: PUSH
75132: LD_INT 0
75134: ST_TO_ADDR
// k := 5 ;
75135: LD_ADDR_VAR 0 9
75139: PUSH
75140: LD_INT 5
75142: ST_TO_ADDR
// if tmp < k then
75143: LD_VAR 0 14
75147: PUSH
75148: LD_VAR 0 9
75152: LESS
75153: IFFALSE 75165
// k := tmp ;
75155: LD_ADDR_VAR 0 9
75159: PUSH
75160: LD_VAR 0 14
75164: ST_TO_ADDR
// for j = 1 to k do
75165: LD_ADDR_VAR 0 8
75169: PUSH
75170: DOUBLE
75171: LD_INT 1
75173: DEC
75174: ST_TO_ADDR
75175: LD_VAR 0 9
75179: PUSH
75180: FOR_TO
75181: IFFALSE 75269
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
75183: LD_VAR 0 14
75187: PUSH
75188: LD_VAR 0 8
75192: ARRAY
75193: PUSH
75194: LD_VAR 0 14
75198: PPUSH
75199: LD_INT 58
75201: PUSH
75202: EMPTY
75203: LIST
75204: PPUSH
75205: CALL_OW 72
75209: IN
75210: NOT
75211: IFFALSE 75267
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
75213: LD_VAR 0 4
75217: PUSH
75218: LD_VAR 0 7
75222: ARRAY
75223: PPUSH
75224: LD_VAR 0 14
75228: PUSH
75229: LD_VAR 0 8
75233: ARRAY
75234: PPUSH
75235: CALL_OW 115
// attacking := true ;
75239: LD_ADDR_VAR 0 29
75243: PUSH
75244: LD_INT 1
75246: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
75247: LD_VAR 0 4
75251: PUSH
75252: LD_VAR 0 7
75256: ARRAY
75257: PPUSH
75258: LD_INT 71
75260: PPUSH
75261: CALL_OW 109
// continue ;
75265: GO 75180
// end ; end ;
75267: GO 75180
75269: POP
75270: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
75271: LD_VAR 0 4
75275: PUSH
75276: LD_VAR 0 7
75280: ARRAY
75281: PPUSH
75282: CALL_OW 257
75286: PUSH
75287: LD_INT 8
75289: EQUAL
75290: PUSH
75291: LD_VAR 0 4
75295: PUSH
75296: LD_VAR 0 7
75300: ARRAY
75301: PPUSH
75302: CALL_OW 264
75306: PUSH
75307: LD_INT 28
75309: PUSH
75310: LD_INT 45
75312: PUSH
75313: LD_INT 7
75315: PUSH
75316: LD_INT 47
75318: PUSH
75319: EMPTY
75320: LIST
75321: LIST
75322: LIST
75323: LIST
75324: IN
75325: OR
75326: IFFALSE 75582
// begin attacking := false ;
75328: LD_ADDR_VAR 0 29
75332: PUSH
75333: LD_INT 0
75335: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
75336: LD_VAR 0 14
75340: PUSH
75341: LD_INT 1
75343: ARRAY
75344: PPUSH
75345: CALL_OW 266
75349: PUSH
75350: LD_INT 32
75352: PUSH
75353: LD_INT 31
75355: PUSH
75356: LD_INT 33
75358: PUSH
75359: LD_INT 4
75361: PUSH
75362: LD_INT 5
75364: PUSH
75365: EMPTY
75366: LIST
75367: LIST
75368: LIST
75369: LIST
75370: LIST
75371: IN
75372: IFFALSE 75558
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
75374: LD_ADDR_VAR 0 9
75378: PUSH
75379: LD_VAR 0 14
75383: PUSH
75384: LD_INT 1
75386: ARRAY
75387: PPUSH
75388: CALL_OW 266
75392: PPUSH
75393: LD_VAR 0 14
75397: PUSH
75398: LD_INT 1
75400: ARRAY
75401: PPUSH
75402: CALL_OW 250
75406: PPUSH
75407: LD_VAR 0 14
75411: PUSH
75412: LD_INT 1
75414: ARRAY
75415: PPUSH
75416: CALL_OW 251
75420: PPUSH
75421: LD_VAR 0 14
75425: PUSH
75426: LD_INT 1
75428: ARRAY
75429: PPUSH
75430: CALL_OW 254
75434: PPUSH
75435: LD_VAR 0 14
75439: PUSH
75440: LD_INT 1
75442: ARRAY
75443: PPUSH
75444: CALL_OW 248
75448: PPUSH
75449: LD_INT 0
75451: PPUSH
75452: CALL 18007 0 6
75456: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
75457: LD_ADDR_VAR 0 8
75461: PUSH
75462: LD_VAR 0 4
75466: PUSH
75467: LD_VAR 0 7
75471: ARRAY
75472: PPUSH
75473: LD_VAR 0 9
75477: PPUSH
75478: CALL 36677 0 2
75482: ST_TO_ADDR
// if j then
75483: LD_VAR 0 8
75487: IFFALSE 75556
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
75489: LD_VAR 0 8
75493: PUSH
75494: LD_INT 1
75496: ARRAY
75497: PPUSH
75498: LD_VAR 0 8
75502: PUSH
75503: LD_INT 2
75505: ARRAY
75506: PPUSH
75507: CALL_OW 488
75511: IFFALSE 75556
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
75513: LD_VAR 0 4
75517: PUSH
75518: LD_VAR 0 7
75522: ARRAY
75523: PPUSH
75524: LD_VAR 0 8
75528: PUSH
75529: LD_INT 1
75531: ARRAY
75532: PPUSH
75533: LD_VAR 0 8
75537: PUSH
75538: LD_INT 2
75540: ARRAY
75541: PPUSH
75542: CALL_OW 116
// attacking := true ;
75546: LD_ADDR_VAR 0 29
75550: PUSH
75551: LD_INT 1
75553: ST_TO_ADDR
// continue ;
75554: GO 72929
// end ; end else
75556: GO 75582
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
75558: LD_VAR 0 4
75562: PUSH
75563: LD_VAR 0 7
75567: ARRAY
75568: PPUSH
75569: LD_VAR 0 14
75573: PUSH
75574: LD_INT 1
75576: ARRAY
75577: PPUSH
75578: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
75582: LD_VAR 0 4
75586: PUSH
75587: LD_VAR 0 7
75591: ARRAY
75592: PPUSH
75593: CALL_OW 265
75597: PUSH
75598: LD_INT 11
75600: EQUAL
75601: IFFALSE 75879
// begin k := 10 ;
75603: LD_ADDR_VAR 0 9
75607: PUSH
75608: LD_INT 10
75610: ST_TO_ADDR
// x := 0 ;
75611: LD_ADDR_VAR 0 10
75615: PUSH
75616: LD_INT 0
75618: ST_TO_ADDR
// if tmp < k then
75619: LD_VAR 0 14
75623: PUSH
75624: LD_VAR 0 9
75628: LESS
75629: IFFALSE 75641
// k := tmp ;
75631: LD_ADDR_VAR 0 9
75635: PUSH
75636: LD_VAR 0 14
75640: ST_TO_ADDR
// for j = k downto 1 do
75641: LD_ADDR_VAR 0 8
75645: PUSH
75646: DOUBLE
75647: LD_VAR 0 9
75651: INC
75652: ST_TO_ADDR
75653: LD_INT 1
75655: PUSH
75656: FOR_DOWNTO
75657: IFFALSE 75732
// begin if GetType ( tmp [ j ] ) = unit_human then
75659: LD_VAR 0 14
75663: PUSH
75664: LD_VAR 0 8
75668: ARRAY
75669: PPUSH
75670: CALL_OW 247
75674: PUSH
75675: LD_INT 1
75677: EQUAL
75678: IFFALSE 75730
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
75680: LD_VAR 0 4
75684: PUSH
75685: LD_VAR 0 7
75689: ARRAY
75690: PPUSH
75691: LD_VAR 0 14
75695: PUSH
75696: LD_VAR 0 8
75700: ARRAY
75701: PPUSH
75702: CALL 36948 0 2
// x := tmp [ j ] ;
75706: LD_ADDR_VAR 0 10
75710: PUSH
75711: LD_VAR 0 14
75715: PUSH
75716: LD_VAR 0 8
75720: ARRAY
75721: ST_TO_ADDR
// attacking := true ;
75722: LD_ADDR_VAR 0 29
75726: PUSH
75727: LD_INT 1
75729: ST_TO_ADDR
// end ; end ;
75730: GO 75656
75732: POP
75733: POP
// if not x then
75734: LD_VAR 0 10
75738: NOT
75739: IFFALSE 75879
// begin attacking := true ;
75741: LD_ADDR_VAR 0 29
75745: PUSH
75746: LD_INT 1
75748: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
75749: LD_VAR 0 4
75753: PUSH
75754: LD_VAR 0 7
75758: ARRAY
75759: PPUSH
75760: CALL_OW 250
75764: PPUSH
75765: LD_VAR 0 4
75769: PUSH
75770: LD_VAR 0 7
75774: ARRAY
75775: PPUSH
75776: CALL_OW 251
75780: PPUSH
75781: CALL_OW 546
75785: PUSH
75786: LD_INT 2
75788: ARRAY
75789: PUSH
75790: LD_VAR 0 14
75794: PUSH
75795: LD_INT 1
75797: ARRAY
75798: PPUSH
75799: CALL_OW 250
75803: PPUSH
75804: LD_VAR 0 14
75808: PUSH
75809: LD_INT 1
75811: ARRAY
75812: PPUSH
75813: CALL_OW 251
75817: PPUSH
75818: CALL_OW 546
75822: PUSH
75823: LD_INT 2
75825: ARRAY
75826: EQUAL
75827: IFFALSE 75855
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
75829: LD_VAR 0 4
75833: PUSH
75834: LD_VAR 0 7
75838: ARRAY
75839: PPUSH
75840: LD_VAR 0 14
75844: PUSH
75845: LD_INT 1
75847: ARRAY
75848: PPUSH
75849: CALL 36948 0 2
75853: GO 75879
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
75855: LD_VAR 0 4
75859: PUSH
75860: LD_VAR 0 7
75864: ARRAY
75865: PPUSH
75866: LD_VAR 0 14
75870: PUSH
75871: LD_INT 1
75873: ARRAY
75874: PPUSH
75875: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
75879: LD_VAR 0 4
75883: PUSH
75884: LD_VAR 0 7
75888: ARRAY
75889: PPUSH
75890: CALL_OW 264
75894: PUSH
75895: LD_INT 29
75897: EQUAL
75898: IFFALSE 76264
// begin if WantsToAttack ( group [ i ] ) in bombed then
75900: LD_VAR 0 4
75904: PUSH
75905: LD_VAR 0 7
75909: ARRAY
75910: PPUSH
75911: CALL_OW 319
75915: PUSH
75916: LD_VAR 0 28
75920: IN
75921: IFFALSE 75925
// continue ;
75923: GO 72929
// k := 8 ;
75925: LD_ADDR_VAR 0 9
75929: PUSH
75930: LD_INT 8
75932: ST_TO_ADDR
// x := 0 ;
75933: LD_ADDR_VAR 0 10
75937: PUSH
75938: LD_INT 0
75940: ST_TO_ADDR
// if tmp < k then
75941: LD_VAR 0 14
75945: PUSH
75946: LD_VAR 0 9
75950: LESS
75951: IFFALSE 75963
// k := tmp ;
75953: LD_ADDR_VAR 0 9
75957: PUSH
75958: LD_VAR 0 14
75962: ST_TO_ADDR
// for j = 1 to k do
75963: LD_ADDR_VAR 0 8
75967: PUSH
75968: DOUBLE
75969: LD_INT 1
75971: DEC
75972: ST_TO_ADDR
75973: LD_VAR 0 9
75977: PUSH
75978: FOR_TO
75979: IFFALSE 76111
// begin if GetType ( tmp [ j ] ) = unit_building then
75981: LD_VAR 0 14
75985: PUSH
75986: LD_VAR 0 8
75990: ARRAY
75991: PPUSH
75992: CALL_OW 247
75996: PUSH
75997: LD_INT 3
75999: EQUAL
76000: IFFALSE 76109
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
76002: LD_VAR 0 14
76006: PUSH
76007: LD_VAR 0 8
76011: ARRAY
76012: PUSH
76013: LD_VAR 0 28
76017: IN
76018: NOT
76019: PUSH
76020: LD_VAR 0 14
76024: PUSH
76025: LD_VAR 0 8
76029: ARRAY
76030: PPUSH
76031: CALL_OW 313
76035: AND
76036: IFFALSE 76109
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
76038: LD_VAR 0 4
76042: PUSH
76043: LD_VAR 0 7
76047: ARRAY
76048: PPUSH
76049: LD_VAR 0 14
76053: PUSH
76054: LD_VAR 0 8
76058: ARRAY
76059: PPUSH
76060: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
76064: LD_ADDR_VAR 0 28
76068: PUSH
76069: LD_VAR 0 28
76073: PPUSH
76074: LD_VAR 0 28
76078: PUSH
76079: LD_INT 1
76081: PLUS
76082: PPUSH
76083: LD_VAR 0 14
76087: PUSH
76088: LD_VAR 0 8
76092: ARRAY
76093: PPUSH
76094: CALL_OW 1
76098: ST_TO_ADDR
// attacking := true ;
76099: LD_ADDR_VAR 0 29
76103: PUSH
76104: LD_INT 1
76106: ST_TO_ADDR
// break ;
76107: GO 76111
// end ; end ;
76109: GO 75978
76111: POP
76112: POP
// if not attacking and f_attack_depot then
76113: LD_VAR 0 29
76117: NOT
76118: PUSH
76119: LD_VAR 0 25
76123: AND
76124: IFFALSE 76219
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76126: LD_ADDR_VAR 0 13
76130: PUSH
76131: LD_VAR 0 14
76135: PPUSH
76136: LD_INT 2
76138: PUSH
76139: LD_INT 30
76141: PUSH
76142: LD_INT 0
76144: PUSH
76145: EMPTY
76146: LIST
76147: LIST
76148: PUSH
76149: LD_INT 30
76151: PUSH
76152: LD_INT 1
76154: PUSH
76155: EMPTY
76156: LIST
76157: LIST
76158: PUSH
76159: EMPTY
76160: LIST
76161: LIST
76162: LIST
76163: PPUSH
76164: CALL_OW 72
76168: ST_TO_ADDR
// if z then
76169: LD_VAR 0 13
76173: IFFALSE 76219
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
76175: LD_VAR 0 4
76179: PUSH
76180: LD_VAR 0 7
76184: ARRAY
76185: PPUSH
76186: LD_VAR 0 13
76190: PPUSH
76191: LD_VAR 0 4
76195: PUSH
76196: LD_VAR 0 7
76200: ARRAY
76201: PPUSH
76202: CALL_OW 74
76206: PPUSH
76207: CALL_OW 115
// attacking := true ;
76211: LD_ADDR_VAR 0 29
76215: PUSH
76216: LD_INT 1
76218: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
76219: LD_VAR 0 4
76223: PUSH
76224: LD_VAR 0 7
76228: ARRAY
76229: PPUSH
76230: CALL_OW 256
76234: PUSH
76235: LD_INT 500
76237: LESS
76238: IFFALSE 76264
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
76240: LD_VAR 0 4
76244: PUSH
76245: LD_VAR 0 7
76249: ARRAY
76250: PPUSH
76251: LD_VAR 0 14
76255: PUSH
76256: LD_INT 1
76258: ARRAY
76259: PPUSH
76260: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
76264: LD_VAR 0 4
76268: PUSH
76269: LD_VAR 0 7
76273: ARRAY
76274: PPUSH
76275: CALL_OW 264
76279: PUSH
76280: LD_INT 49
76282: EQUAL
76283: IFFALSE 76404
// begin if not HasTask ( group [ i ] ) then
76285: LD_VAR 0 4
76289: PUSH
76290: LD_VAR 0 7
76294: ARRAY
76295: PPUSH
76296: CALL_OW 314
76300: NOT
76301: IFFALSE 76404
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
76303: LD_ADDR_VAR 0 9
76307: PUSH
76308: LD_INT 81
76310: PUSH
76311: LD_VAR 0 4
76315: PUSH
76316: LD_VAR 0 7
76320: ARRAY
76321: PPUSH
76322: CALL_OW 255
76326: PUSH
76327: EMPTY
76328: LIST
76329: LIST
76330: PPUSH
76331: CALL_OW 69
76335: PPUSH
76336: LD_VAR 0 4
76340: PUSH
76341: LD_VAR 0 7
76345: ARRAY
76346: PPUSH
76347: CALL_OW 74
76351: ST_TO_ADDR
// if k then
76352: LD_VAR 0 9
76356: IFFALSE 76404
// if GetDistUnits ( group [ i ] , k ) > 10 then
76358: LD_VAR 0 4
76362: PUSH
76363: LD_VAR 0 7
76367: ARRAY
76368: PPUSH
76369: LD_VAR 0 9
76373: PPUSH
76374: CALL_OW 296
76378: PUSH
76379: LD_INT 10
76381: GREATER
76382: IFFALSE 76404
// ComMoveUnit ( group [ i ] , k ) ;
76384: LD_VAR 0 4
76388: PUSH
76389: LD_VAR 0 7
76393: ARRAY
76394: PPUSH
76395: LD_VAR 0 9
76399: PPUSH
76400: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
76404: LD_VAR 0 4
76408: PUSH
76409: LD_VAR 0 7
76413: ARRAY
76414: PPUSH
76415: CALL_OW 256
76419: PUSH
76420: LD_INT 250
76422: LESS
76423: PUSH
76424: LD_VAR 0 4
76428: PUSH
76429: LD_VAR 0 7
76433: ARRAY
76434: PUSH
76435: LD_INT 21
76437: PUSH
76438: LD_INT 2
76440: PUSH
76441: EMPTY
76442: LIST
76443: LIST
76444: PUSH
76445: LD_INT 23
76447: PUSH
76448: LD_INT 2
76450: PUSH
76451: EMPTY
76452: LIST
76453: LIST
76454: PUSH
76455: EMPTY
76456: LIST
76457: LIST
76458: PPUSH
76459: CALL_OW 69
76463: IN
76464: AND
76465: IFFALSE 76590
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
76467: LD_ADDR_VAR 0 9
76471: PUSH
76472: LD_OWVAR 3
76476: PUSH
76477: LD_VAR 0 4
76481: PUSH
76482: LD_VAR 0 7
76486: ARRAY
76487: DIFF
76488: PPUSH
76489: LD_VAR 0 4
76493: PUSH
76494: LD_VAR 0 7
76498: ARRAY
76499: PPUSH
76500: CALL_OW 74
76504: ST_TO_ADDR
// if not k then
76505: LD_VAR 0 9
76509: NOT
76510: IFFALSE 76514
// continue ;
76512: GO 72929
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
76514: LD_VAR 0 9
76518: PUSH
76519: LD_INT 81
76521: PUSH
76522: LD_VAR 0 4
76526: PUSH
76527: LD_VAR 0 7
76531: ARRAY
76532: PPUSH
76533: CALL_OW 255
76537: PUSH
76538: EMPTY
76539: LIST
76540: LIST
76541: PPUSH
76542: CALL_OW 69
76546: IN
76547: PUSH
76548: LD_VAR 0 9
76552: PPUSH
76553: LD_VAR 0 4
76557: PUSH
76558: LD_VAR 0 7
76562: ARRAY
76563: PPUSH
76564: CALL_OW 296
76568: PUSH
76569: LD_INT 5
76571: LESS
76572: AND
76573: IFFALSE 76590
// ComAutodestruct ( group [ i ] ) ;
76575: LD_VAR 0 4
76579: PUSH
76580: LD_VAR 0 7
76584: ARRAY
76585: PPUSH
76586: CALL 36846 0 1
// end ; if f_attack_depot then
76590: LD_VAR 0 25
76594: IFFALSE 76706
// begin k := 6 ;
76596: LD_ADDR_VAR 0 9
76600: PUSH
76601: LD_INT 6
76603: ST_TO_ADDR
// if tmp < k then
76604: LD_VAR 0 14
76608: PUSH
76609: LD_VAR 0 9
76613: LESS
76614: IFFALSE 76626
// k := tmp ;
76616: LD_ADDR_VAR 0 9
76620: PUSH
76621: LD_VAR 0 14
76625: ST_TO_ADDR
// for j = 1 to k do
76626: LD_ADDR_VAR 0 8
76630: PUSH
76631: DOUBLE
76632: LD_INT 1
76634: DEC
76635: ST_TO_ADDR
76636: LD_VAR 0 9
76640: PUSH
76641: FOR_TO
76642: IFFALSE 76704
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
76644: LD_VAR 0 8
76648: PPUSH
76649: CALL_OW 266
76653: PUSH
76654: LD_INT 0
76656: PUSH
76657: LD_INT 1
76659: PUSH
76660: EMPTY
76661: LIST
76662: LIST
76663: IN
76664: IFFALSE 76702
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
76666: LD_VAR 0 4
76670: PUSH
76671: LD_VAR 0 7
76675: ARRAY
76676: PPUSH
76677: LD_VAR 0 14
76681: PUSH
76682: LD_VAR 0 8
76686: ARRAY
76687: PPUSH
76688: CALL_OW 115
// attacking := true ;
76692: LD_ADDR_VAR 0 29
76696: PUSH
76697: LD_INT 1
76699: ST_TO_ADDR
// break ;
76700: GO 76704
// end ;
76702: GO 76641
76704: POP
76705: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
76706: LD_VAR 0 4
76710: PUSH
76711: LD_VAR 0 7
76715: ARRAY
76716: PPUSH
76717: CALL_OW 302
76721: PUSH
76722: LD_VAR 0 29
76726: NOT
76727: AND
76728: IFFALSE 77050
// begin if GetTag ( group [ i ] ) = 71 then
76730: LD_VAR 0 4
76734: PUSH
76735: LD_VAR 0 7
76739: ARRAY
76740: PPUSH
76741: CALL_OW 110
76745: PUSH
76746: LD_INT 71
76748: EQUAL
76749: IFFALSE 76790
// begin if HasTask ( group [ i ] ) then
76751: LD_VAR 0 4
76755: PUSH
76756: LD_VAR 0 7
76760: ARRAY
76761: PPUSH
76762: CALL_OW 314
76766: IFFALSE 76772
// continue else
76768: GO 72929
76770: GO 76790
// SetTag ( group [ i ] , 0 ) ;
76772: LD_VAR 0 4
76776: PUSH
76777: LD_VAR 0 7
76781: ARRAY
76782: PPUSH
76783: LD_INT 0
76785: PPUSH
76786: CALL_OW 109
// end ; k := 8 ;
76790: LD_ADDR_VAR 0 9
76794: PUSH
76795: LD_INT 8
76797: ST_TO_ADDR
// x := 0 ;
76798: LD_ADDR_VAR 0 10
76802: PUSH
76803: LD_INT 0
76805: ST_TO_ADDR
// if tmp < k then
76806: LD_VAR 0 14
76810: PUSH
76811: LD_VAR 0 9
76815: LESS
76816: IFFALSE 76828
// k := tmp ;
76818: LD_ADDR_VAR 0 9
76822: PUSH
76823: LD_VAR 0 14
76827: ST_TO_ADDR
// for j = 1 to k do
76828: LD_ADDR_VAR 0 8
76832: PUSH
76833: DOUBLE
76834: LD_INT 1
76836: DEC
76837: ST_TO_ADDR
76838: LD_VAR 0 9
76842: PUSH
76843: FOR_TO
76844: IFFALSE 76942
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
76846: LD_VAR 0 14
76850: PUSH
76851: LD_VAR 0 8
76855: ARRAY
76856: PPUSH
76857: CALL_OW 247
76861: PUSH
76862: LD_INT 1
76864: EQUAL
76865: PUSH
76866: LD_VAR 0 14
76870: PUSH
76871: LD_VAR 0 8
76875: ARRAY
76876: PPUSH
76877: CALL_OW 256
76881: PUSH
76882: LD_INT 250
76884: LESS
76885: PUSH
76886: LD_VAR 0 20
76890: AND
76891: PUSH
76892: LD_VAR 0 20
76896: NOT
76897: PUSH
76898: LD_VAR 0 14
76902: PUSH
76903: LD_VAR 0 8
76907: ARRAY
76908: PPUSH
76909: CALL_OW 256
76913: PUSH
76914: LD_INT 250
76916: GREATEREQUAL
76917: AND
76918: OR
76919: AND
76920: IFFALSE 76940
// begin x := tmp [ j ] ;
76922: LD_ADDR_VAR 0 10
76926: PUSH
76927: LD_VAR 0 14
76931: PUSH
76932: LD_VAR 0 8
76936: ARRAY
76937: ST_TO_ADDR
// break ;
76938: GO 76942
// end ;
76940: GO 76843
76942: POP
76943: POP
// if x then
76944: LD_VAR 0 10
76948: IFFALSE 76972
// ComAttackUnit ( group [ i ] , x ) else
76950: LD_VAR 0 4
76954: PUSH
76955: LD_VAR 0 7
76959: ARRAY
76960: PPUSH
76961: LD_VAR 0 10
76965: PPUSH
76966: CALL_OW 115
76970: GO 76996
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
76972: LD_VAR 0 4
76976: PUSH
76977: LD_VAR 0 7
76981: ARRAY
76982: PPUSH
76983: LD_VAR 0 14
76987: PUSH
76988: LD_INT 1
76990: ARRAY
76991: PPUSH
76992: CALL_OW 115
// if not HasTask ( group [ i ] ) then
76996: LD_VAR 0 4
77000: PUSH
77001: LD_VAR 0 7
77005: ARRAY
77006: PPUSH
77007: CALL_OW 314
77011: NOT
77012: IFFALSE 77050
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
77014: LD_VAR 0 4
77018: PUSH
77019: LD_VAR 0 7
77023: ARRAY
77024: PPUSH
77025: LD_VAR 0 14
77029: PPUSH
77030: LD_VAR 0 4
77034: PUSH
77035: LD_VAR 0 7
77039: ARRAY
77040: PPUSH
77041: CALL_OW 74
77045: PPUSH
77046: CALL_OW 115
// end ; end ; end ;
77050: GO 72929
77052: POP
77053: POP
// wait ( 0 0$2 ) ;
77054: LD_INT 70
77056: PPUSH
77057: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
77061: LD_VAR 0 4
77065: NOT
77066: PUSH
77067: LD_VAR 0 4
77071: PUSH
77072: EMPTY
77073: EQUAL
77074: OR
77075: PUSH
77076: LD_INT 81
77078: PUSH
77079: LD_VAR 0 35
77083: PUSH
77084: EMPTY
77085: LIST
77086: LIST
77087: PPUSH
77088: CALL_OW 69
77092: NOT
77093: OR
77094: IFFALSE 72914
// end ;
77096: LD_VAR 0 2
77100: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
77101: LD_INT 0
77103: PPUSH
77104: PPUSH
77105: PPUSH
77106: PPUSH
77107: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
77108: LD_VAR 0 1
77112: NOT
77113: PUSH
77114: LD_EXP 14
77118: PUSH
77119: LD_VAR 0 1
77123: ARRAY
77124: NOT
77125: OR
77126: PUSH
77127: LD_VAR 0 2
77131: NOT
77132: OR
77133: PUSH
77134: LD_VAR 0 3
77138: NOT
77139: OR
77140: IFFALSE 77144
// exit ;
77142: GO 77657
// side := mc_sides [ base ] ;
77144: LD_ADDR_VAR 0 6
77148: PUSH
77149: LD_EXP 40
77153: PUSH
77154: LD_VAR 0 1
77158: ARRAY
77159: ST_TO_ADDR
// if not side then
77160: LD_VAR 0 6
77164: NOT
77165: IFFALSE 77169
// exit ;
77167: GO 77657
// for i in solds do
77169: LD_ADDR_VAR 0 7
77173: PUSH
77174: LD_VAR 0 2
77178: PUSH
77179: FOR_IN
77180: IFFALSE 77241
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
77182: LD_VAR 0 7
77186: PPUSH
77187: CALL_OW 310
77191: PPUSH
77192: CALL_OW 266
77196: PUSH
77197: LD_INT 32
77199: PUSH
77200: LD_INT 31
77202: PUSH
77203: EMPTY
77204: LIST
77205: LIST
77206: IN
77207: IFFALSE 77227
// solds := solds diff i else
77209: LD_ADDR_VAR 0 2
77213: PUSH
77214: LD_VAR 0 2
77218: PUSH
77219: LD_VAR 0 7
77223: DIFF
77224: ST_TO_ADDR
77225: GO 77239
// SetTag ( i , 18 ) ;
77227: LD_VAR 0 7
77231: PPUSH
77232: LD_INT 18
77234: PPUSH
77235: CALL_OW 109
77239: GO 77179
77241: POP
77242: POP
// if not solds then
77243: LD_VAR 0 2
77247: NOT
77248: IFFALSE 77252
// exit ;
77250: GO 77657
// repeat wait ( 0 0$2 ) ;
77252: LD_INT 70
77254: PPUSH
77255: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
77259: LD_ADDR_VAR 0 5
77263: PUSH
77264: LD_VAR 0 6
77268: PPUSH
77269: LD_VAR 0 3
77273: PPUSH
77274: CALL 6228 0 2
77278: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
77279: LD_EXP 14
77283: PUSH
77284: LD_VAR 0 1
77288: ARRAY
77289: NOT
77290: PUSH
77291: LD_EXP 14
77295: PUSH
77296: LD_VAR 0 1
77300: ARRAY
77301: PUSH
77302: EMPTY
77303: EQUAL
77304: OR
77305: IFFALSE 77342
// begin for i in solds do
77307: LD_ADDR_VAR 0 7
77311: PUSH
77312: LD_VAR 0 2
77316: PUSH
77317: FOR_IN
77318: IFFALSE 77331
// ComStop ( i ) ;
77320: LD_VAR 0 7
77324: PPUSH
77325: CALL_OW 141
77329: GO 77317
77331: POP
77332: POP
// solds := [ ] ;
77333: LD_ADDR_VAR 0 2
77337: PUSH
77338: EMPTY
77339: ST_TO_ADDR
// exit ;
77340: GO 77657
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
77342: LD_VAR 0 5
77346: NOT
77347: PUSH
77348: LD_VAR 0 5
77352: PUSH
77353: LD_INT 3
77355: GREATER
77356: OR
77357: PUSH
77358: LD_EXP 36
77362: PUSH
77363: LD_VAR 0 1
77367: ARRAY
77368: OR
77369: IFFALSE 77410
// begin for i in solds do
77371: LD_ADDR_VAR 0 7
77375: PUSH
77376: LD_VAR 0 2
77380: PUSH
77381: FOR_IN
77382: IFFALSE 77406
// if HasTask ( i ) then
77384: LD_VAR 0 7
77388: PPUSH
77389: CALL_OW 314
77393: IFFALSE 77404
// ComStop ( i ) ;
77395: LD_VAR 0 7
77399: PPUSH
77400: CALL_OW 141
77404: GO 77381
77406: POP
77407: POP
// break ;
77408: GO 77645
// end ; for i in solds do
77410: LD_ADDR_VAR 0 7
77414: PUSH
77415: LD_VAR 0 2
77419: PUSH
77420: FOR_IN
77421: IFFALSE 77637
// begin if IsInUnit ( i ) then
77423: LD_VAR 0 7
77427: PPUSH
77428: CALL_OW 310
77432: IFFALSE 77443
// ComExitBuilding ( i ) ;
77434: LD_VAR 0 7
77438: PPUSH
77439: CALL_OW 122
// if GetLives ( i ) > 333 then
77443: LD_VAR 0 7
77447: PPUSH
77448: CALL_OW 256
77452: PUSH
77453: LD_INT 333
77455: GREATER
77456: IFFALSE 77484
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
77458: LD_VAR 0 7
77462: PPUSH
77463: LD_VAR 0 5
77467: PPUSH
77468: LD_VAR 0 7
77472: PPUSH
77473: CALL_OW 74
77477: PPUSH
77478: CALL_OW 115
77482: GO 77635
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
77484: LD_ADDR_VAR 0 8
77488: PUSH
77489: LD_EXP 14
77493: PUSH
77494: LD_VAR 0 1
77498: ARRAY
77499: PPUSH
77500: LD_INT 2
77502: PUSH
77503: LD_INT 30
77505: PUSH
77506: LD_INT 0
77508: PUSH
77509: EMPTY
77510: LIST
77511: LIST
77512: PUSH
77513: LD_INT 30
77515: PUSH
77516: LD_INT 1
77518: PUSH
77519: EMPTY
77520: LIST
77521: LIST
77522: PUSH
77523: LD_INT 30
77525: PUSH
77526: LD_INT 6
77528: PUSH
77529: EMPTY
77530: LIST
77531: LIST
77532: PUSH
77533: EMPTY
77534: LIST
77535: LIST
77536: LIST
77537: LIST
77538: PPUSH
77539: CALL_OW 72
77543: PPUSH
77544: LD_VAR 0 7
77548: PPUSH
77549: CALL_OW 74
77553: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
77554: LD_VAR 0 7
77558: PPUSH
77559: LD_VAR 0 8
77563: PPUSH
77564: CALL_OW 250
77568: PPUSH
77569: LD_INT 3
77571: PPUSH
77572: LD_INT 5
77574: PPUSH
77575: CALL_OW 272
77579: PPUSH
77580: LD_VAR 0 8
77584: PPUSH
77585: CALL_OW 251
77589: PPUSH
77590: LD_INT 3
77592: PPUSH
77593: LD_INT 5
77595: PPUSH
77596: CALL_OW 273
77600: PPUSH
77601: CALL_OW 111
// SetTag ( i , 0 ) ;
77605: LD_VAR 0 7
77609: PPUSH
77610: LD_INT 0
77612: PPUSH
77613: CALL_OW 109
// solds := solds diff i ;
77617: LD_ADDR_VAR 0 2
77621: PUSH
77622: LD_VAR 0 2
77626: PUSH
77627: LD_VAR 0 7
77631: DIFF
77632: ST_TO_ADDR
// continue ;
77633: GO 77420
// end ; end ;
77635: GO 77420
77637: POP
77638: POP
// until solds ;
77639: LD_VAR 0 2
77643: IFFALSE 77252
// MC_Reset ( base , 18 ) ;
77645: LD_VAR 0 1
77649: PPUSH
77650: LD_INT 18
77652: PPUSH
77653: CALL 46215 0 2
// end ;
77657: LD_VAR 0 4
77661: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
77662: LD_INT 0
77664: PPUSH
77665: PPUSH
77666: PPUSH
77667: PPUSH
77668: PPUSH
77669: PPUSH
77670: PPUSH
77671: PPUSH
77672: PPUSH
77673: PPUSH
77674: PPUSH
77675: PPUSH
77676: PPUSH
77677: PPUSH
77678: PPUSH
77679: PPUSH
77680: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
77681: LD_ADDR_VAR 0 13
77685: PUSH
77686: LD_EXP 14
77690: PUSH
77691: LD_VAR 0 1
77695: ARRAY
77696: PPUSH
77697: LD_INT 25
77699: PUSH
77700: LD_INT 3
77702: PUSH
77703: EMPTY
77704: LIST
77705: LIST
77706: PPUSH
77707: CALL_OW 72
77711: ST_TO_ADDR
// if mc_remote_driver [ base ] then
77712: LD_EXP 54
77716: PUSH
77717: LD_VAR 0 1
77721: ARRAY
77722: IFFALSE 77746
// mechs := mechs diff mc_remote_driver [ base ] ;
77724: LD_ADDR_VAR 0 13
77728: PUSH
77729: LD_VAR 0 13
77733: PUSH
77734: LD_EXP 54
77738: PUSH
77739: LD_VAR 0 1
77743: ARRAY
77744: DIFF
77745: ST_TO_ADDR
// for i in mechs do
77746: LD_ADDR_VAR 0 5
77750: PUSH
77751: LD_VAR 0 13
77755: PUSH
77756: FOR_IN
77757: IFFALSE 77792
// if GetTag ( i ) > 0 then
77759: LD_VAR 0 5
77763: PPUSH
77764: CALL_OW 110
77768: PUSH
77769: LD_INT 0
77771: GREATER
77772: IFFALSE 77790
// mechs := mechs diff i ;
77774: LD_ADDR_VAR 0 13
77778: PUSH
77779: LD_VAR 0 13
77783: PUSH
77784: LD_VAR 0 5
77788: DIFF
77789: ST_TO_ADDR
77790: GO 77756
77792: POP
77793: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
77794: LD_ADDR_VAR 0 9
77798: PUSH
77799: LD_EXP 14
77803: PUSH
77804: LD_VAR 0 1
77808: ARRAY
77809: PPUSH
77810: LD_INT 2
77812: PUSH
77813: LD_INT 25
77815: PUSH
77816: LD_INT 1
77818: PUSH
77819: EMPTY
77820: LIST
77821: LIST
77822: PUSH
77823: LD_INT 25
77825: PUSH
77826: LD_INT 5
77828: PUSH
77829: EMPTY
77830: LIST
77831: LIST
77832: PUSH
77833: LD_INT 25
77835: PUSH
77836: LD_INT 8
77838: PUSH
77839: EMPTY
77840: LIST
77841: LIST
77842: PUSH
77843: LD_INT 25
77845: PUSH
77846: LD_INT 9
77848: PUSH
77849: EMPTY
77850: LIST
77851: LIST
77852: PUSH
77853: EMPTY
77854: LIST
77855: LIST
77856: LIST
77857: LIST
77858: LIST
77859: PPUSH
77860: CALL_OW 72
77864: ST_TO_ADDR
// if not defenders and not solds then
77865: LD_VAR 0 2
77869: NOT
77870: PUSH
77871: LD_VAR 0 9
77875: NOT
77876: AND
77877: IFFALSE 77881
// exit ;
77879: GO 79571
// depot_under_attack := false ;
77881: LD_ADDR_VAR 0 17
77885: PUSH
77886: LD_INT 0
77888: ST_TO_ADDR
// sold_defenders := [ ] ;
77889: LD_ADDR_VAR 0 18
77893: PUSH
77894: EMPTY
77895: ST_TO_ADDR
// if mechs then
77896: LD_VAR 0 13
77900: IFFALSE 78053
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
77902: LD_ADDR_VAR 0 5
77906: PUSH
77907: LD_VAR 0 2
77911: PPUSH
77912: LD_INT 21
77914: PUSH
77915: LD_INT 2
77917: PUSH
77918: EMPTY
77919: LIST
77920: LIST
77921: PPUSH
77922: CALL_OW 72
77926: PUSH
77927: FOR_IN
77928: IFFALSE 78051
// begin if GetTag ( i ) <> 20 then
77930: LD_VAR 0 5
77934: PPUSH
77935: CALL_OW 110
77939: PUSH
77940: LD_INT 20
77942: NONEQUAL
77943: IFFALSE 77957
// SetTag ( i , 20 ) ;
77945: LD_VAR 0 5
77949: PPUSH
77950: LD_INT 20
77952: PPUSH
77953: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
77957: LD_VAR 0 5
77961: PPUSH
77962: CALL_OW 263
77966: PUSH
77967: LD_INT 1
77969: EQUAL
77970: PUSH
77971: LD_VAR 0 5
77975: PPUSH
77976: CALL_OW 311
77980: NOT
77981: AND
77982: IFFALSE 78049
// begin un := mechs [ 1 ] ;
77984: LD_ADDR_VAR 0 11
77988: PUSH
77989: LD_VAR 0 13
77993: PUSH
77994: LD_INT 1
77996: ARRAY
77997: ST_TO_ADDR
// ComExit ( un ) ;
77998: LD_VAR 0 11
78002: PPUSH
78003: CALL 41191 0 1
// AddComEnterUnit ( un , i ) ;
78007: LD_VAR 0 11
78011: PPUSH
78012: LD_VAR 0 5
78016: PPUSH
78017: CALL_OW 180
// SetTag ( un , 19 ) ;
78021: LD_VAR 0 11
78025: PPUSH
78026: LD_INT 19
78028: PPUSH
78029: CALL_OW 109
// mechs := mechs diff un ;
78033: LD_ADDR_VAR 0 13
78037: PUSH
78038: LD_VAR 0 13
78042: PUSH
78043: LD_VAR 0 11
78047: DIFF
78048: ST_TO_ADDR
// end ; end ;
78049: GO 77927
78051: POP
78052: POP
// if solds then
78053: LD_VAR 0 9
78057: IFFALSE 78116
// for i in solds do
78059: LD_ADDR_VAR 0 5
78063: PUSH
78064: LD_VAR 0 9
78068: PUSH
78069: FOR_IN
78070: IFFALSE 78114
// if not GetTag ( i ) then
78072: LD_VAR 0 5
78076: PPUSH
78077: CALL_OW 110
78081: NOT
78082: IFFALSE 78112
// begin defenders := defenders union i ;
78084: LD_ADDR_VAR 0 2
78088: PUSH
78089: LD_VAR 0 2
78093: PUSH
78094: LD_VAR 0 5
78098: UNION
78099: ST_TO_ADDR
// SetTag ( i , 18 ) ;
78100: LD_VAR 0 5
78104: PPUSH
78105: LD_INT 18
78107: PPUSH
78108: CALL_OW 109
// end ;
78112: GO 78069
78114: POP
78115: POP
// repeat wait ( 0 0$2 ) ;
78116: LD_INT 70
78118: PPUSH
78119: CALL_OW 67
// enemy := mc_scan [ base ] ;
78123: LD_ADDR_VAR 0 3
78127: PUSH
78128: LD_EXP 37
78132: PUSH
78133: LD_VAR 0 1
78137: ARRAY
78138: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
78139: LD_EXP 14
78143: PUSH
78144: LD_VAR 0 1
78148: ARRAY
78149: NOT
78150: PUSH
78151: LD_EXP 14
78155: PUSH
78156: LD_VAR 0 1
78160: ARRAY
78161: PUSH
78162: EMPTY
78163: EQUAL
78164: OR
78165: IFFALSE 78202
// begin for i in defenders do
78167: LD_ADDR_VAR 0 5
78171: PUSH
78172: LD_VAR 0 2
78176: PUSH
78177: FOR_IN
78178: IFFALSE 78191
// ComStop ( i ) ;
78180: LD_VAR 0 5
78184: PPUSH
78185: CALL_OW 141
78189: GO 78177
78191: POP
78192: POP
// defenders := [ ] ;
78193: LD_ADDR_VAR 0 2
78197: PUSH
78198: EMPTY
78199: ST_TO_ADDR
// exit ;
78200: GO 79571
// end ; for i in defenders do
78202: LD_ADDR_VAR 0 5
78206: PUSH
78207: LD_VAR 0 2
78211: PUSH
78212: FOR_IN
78213: IFFALSE 79031
// begin e := NearestUnitToUnit ( enemy , i ) ;
78215: LD_ADDR_VAR 0 14
78219: PUSH
78220: LD_VAR 0 3
78224: PPUSH
78225: LD_VAR 0 5
78229: PPUSH
78230: CALL_OW 74
78234: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78235: LD_ADDR_VAR 0 8
78239: PUSH
78240: LD_EXP 14
78244: PUSH
78245: LD_VAR 0 1
78249: ARRAY
78250: PPUSH
78251: LD_INT 2
78253: PUSH
78254: LD_INT 30
78256: PUSH
78257: LD_INT 0
78259: PUSH
78260: EMPTY
78261: LIST
78262: LIST
78263: PUSH
78264: LD_INT 30
78266: PUSH
78267: LD_INT 1
78269: PUSH
78270: EMPTY
78271: LIST
78272: LIST
78273: PUSH
78274: EMPTY
78275: LIST
78276: LIST
78277: LIST
78278: PPUSH
78279: CALL_OW 72
78283: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
78284: LD_ADDR_VAR 0 17
78288: PUSH
78289: LD_VAR 0 8
78293: NOT
78294: PUSH
78295: LD_VAR 0 8
78299: PPUSH
78300: LD_INT 3
78302: PUSH
78303: LD_INT 24
78305: PUSH
78306: LD_INT 600
78308: PUSH
78309: EMPTY
78310: LIST
78311: LIST
78312: PUSH
78313: EMPTY
78314: LIST
78315: LIST
78316: PPUSH
78317: CALL_OW 72
78321: OR
78322: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
78323: LD_VAR 0 5
78327: PPUSH
78328: CALL_OW 247
78332: PUSH
78333: LD_INT 2
78335: DOUBLE
78336: EQUAL
78337: IFTRUE 78341
78339: GO 78737
78341: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
78342: LD_VAR 0 5
78346: PPUSH
78347: CALL_OW 256
78351: PUSH
78352: LD_INT 650
78354: GREATER
78355: PUSH
78356: LD_VAR 0 5
78360: PPUSH
78361: LD_VAR 0 14
78365: PPUSH
78366: CALL_OW 296
78370: PUSH
78371: LD_INT 40
78373: LESS
78374: PUSH
78375: LD_VAR 0 14
78379: PPUSH
78380: LD_EXP 39
78384: PUSH
78385: LD_VAR 0 1
78389: ARRAY
78390: PPUSH
78391: CALL_OW 308
78395: OR
78396: AND
78397: IFFALSE 78519
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
78399: LD_VAR 0 5
78403: PPUSH
78404: CALL_OW 262
78408: PUSH
78409: LD_INT 1
78411: EQUAL
78412: PUSH
78413: LD_VAR 0 5
78417: PPUSH
78418: CALL_OW 261
78422: PUSH
78423: LD_INT 30
78425: LESS
78426: AND
78427: PUSH
78428: LD_VAR 0 8
78432: AND
78433: IFFALSE 78503
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
78435: LD_VAR 0 5
78439: PPUSH
78440: LD_VAR 0 8
78444: PPUSH
78445: LD_VAR 0 5
78449: PPUSH
78450: CALL_OW 74
78454: PPUSH
78455: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
78459: LD_VAR 0 5
78463: PPUSH
78464: LD_VAR 0 8
78468: PPUSH
78469: LD_VAR 0 5
78473: PPUSH
78474: CALL_OW 74
78478: PPUSH
78479: CALL_OW 296
78483: PUSH
78484: LD_INT 6
78486: LESS
78487: IFFALSE 78501
// SetFuel ( i , 100 ) ;
78489: LD_VAR 0 5
78493: PPUSH
78494: LD_INT 100
78496: PPUSH
78497: CALL_OW 240
// end else
78501: GO 78517
// ComAttackUnit ( i , e ) ;
78503: LD_VAR 0 5
78507: PPUSH
78508: LD_VAR 0 14
78512: PPUSH
78513: CALL_OW 115
// end else
78517: GO 78620
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
78519: LD_VAR 0 14
78523: PPUSH
78524: LD_EXP 39
78528: PUSH
78529: LD_VAR 0 1
78533: ARRAY
78534: PPUSH
78535: CALL_OW 308
78539: NOT
78540: PUSH
78541: LD_VAR 0 5
78545: PPUSH
78546: LD_VAR 0 14
78550: PPUSH
78551: CALL_OW 296
78555: PUSH
78556: LD_INT 40
78558: GREATEREQUAL
78559: AND
78560: PUSH
78561: LD_VAR 0 5
78565: PPUSH
78566: CALL_OW 256
78570: PUSH
78571: LD_INT 650
78573: LESSEQUAL
78574: OR
78575: PUSH
78576: LD_VAR 0 5
78580: PPUSH
78581: LD_EXP 38
78585: PUSH
78586: LD_VAR 0 1
78590: ARRAY
78591: PPUSH
78592: CALL_OW 308
78596: NOT
78597: AND
78598: IFFALSE 78620
// ComMoveToArea ( i , mc_parking [ base ] ) ;
78600: LD_VAR 0 5
78604: PPUSH
78605: LD_EXP 38
78609: PUSH
78610: LD_VAR 0 1
78614: ARRAY
78615: PPUSH
78616: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
78620: LD_VAR 0 5
78624: PPUSH
78625: CALL_OW 256
78629: PUSH
78630: LD_INT 998
78632: LESS
78633: PUSH
78634: LD_VAR 0 5
78638: PPUSH
78639: CALL_OW 263
78643: PUSH
78644: LD_INT 1
78646: EQUAL
78647: AND
78648: PUSH
78649: LD_VAR 0 5
78653: PPUSH
78654: CALL_OW 311
78658: AND
78659: PUSH
78660: LD_VAR 0 5
78664: PPUSH
78665: LD_EXP 38
78669: PUSH
78670: LD_VAR 0 1
78674: ARRAY
78675: PPUSH
78676: CALL_OW 308
78680: AND
78681: IFFALSE 78735
// begin mech := IsDrivenBy ( i ) ;
78683: LD_ADDR_VAR 0 10
78687: PUSH
78688: LD_VAR 0 5
78692: PPUSH
78693: CALL_OW 311
78697: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
78698: LD_VAR 0 10
78702: PPUSH
78703: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
78707: LD_VAR 0 10
78711: PPUSH
78712: LD_VAR 0 5
78716: PPUSH
78717: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
78721: LD_VAR 0 10
78725: PPUSH
78726: LD_VAR 0 5
78730: PPUSH
78731: CALL_OW 180
// end ; end ; unit_human :
78735: GO 79002
78737: LD_INT 1
78739: DOUBLE
78740: EQUAL
78741: IFTRUE 78745
78743: GO 79001
78745: POP
// begin b := IsInUnit ( i ) ;
78746: LD_ADDR_VAR 0 19
78750: PUSH
78751: LD_VAR 0 5
78755: PPUSH
78756: CALL_OW 310
78760: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
78761: LD_ADDR_VAR 0 20
78765: PUSH
78766: LD_VAR 0 19
78770: NOT
78771: PUSH
78772: LD_VAR 0 19
78776: PPUSH
78777: CALL_OW 266
78781: PUSH
78782: LD_INT 32
78784: PUSH
78785: LD_INT 31
78787: PUSH
78788: EMPTY
78789: LIST
78790: LIST
78791: IN
78792: OR
78793: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
78794: LD_VAR 0 17
78798: PUSH
78799: LD_VAR 0 2
78803: PPUSH
78804: LD_INT 21
78806: PUSH
78807: LD_INT 2
78809: PUSH
78810: EMPTY
78811: LIST
78812: LIST
78813: PPUSH
78814: CALL_OW 72
78818: PUSH
78819: LD_INT 1
78821: LESSEQUAL
78822: OR
78823: PUSH
78824: LD_VAR 0 20
78828: AND
78829: PUSH
78830: LD_VAR 0 5
78834: PUSH
78835: LD_VAR 0 18
78839: IN
78840: NOT
78841: AND
78842: IFFALSE 78935
// begin if b then
78844: LD_VAR 0 19
78848: IFFALSE 78897
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
78850: LD_VAR 0 19
78854: PPUSH
78855: LD_VAR 0 3
78859: PPUSH
78860: LD_VAR 0 19
78864: PPUSH
78865: CALL_OW 74
78869: PPUSH
78870: CALL_OW 296
78874: PUSH
78875: LD_INT 10
78877: LESS
78878: PUSH
78879: LD_VAR 0 19
78883: PPUSH
78884: CALL_OW 461
78888: PUSH
78889: LD_INT 7
78891: NONEQUAL
78892: AND
78893: IFFALSE 78897
// continue ;
78895: GO 78212
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
78897: LD_ADDR_VAR 0 18
78901: PUSH
78902: LD_VAR 0 18
78906: PPUSH
78907: LD_VAR 0 18
78911: PUSH
78912: LD_INT 1
78914: PLUS
78915: PPUSH
78916: LD_VAR 0 5
78920: PPUSH
78921: CALL_OW 1
78925: ST_TO_ADDR
// ComExitBuilding ( i ) ;
78926: LD_VAR 0 5
78930: PPUSH
78931: CALL_OW 122
// end ; if sold_defenders then
78935: LD_VAR 0 18
78939: IFFALSE 78999
// if i in sold_defenders then
78941: LD_VAR 0 5
78945: PUSH
78946: LD_VAR 0 18
78950: IN
78951: IFFALSE 78999
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
78953: LD_VAR 0 5
78957: PPUSH
78958: CALL_OW 314
78962: NOT
78963: PUSH
78964: LD_VAR 0 5
78968: PPUSH
78969: LD_VAR 0 14
78973: PPUSH
78974: CALL_OW 296
78978: PUSH
78979: LD_INT 30
78981: LESS
78982: AND
78983: IFFALSE 78999
// ComAttackUnit ( i , e ) ;
78985: LD_VAR 0 5
78989: PPUSH
78990: LD_VAR 0 14
78994: PPUSH
78995: CALL_OW 115
// end ; end ; end ;
78999: GO 79002
79001: POP
// if IsDead ( i ) then
79002: LD_VAR 0 5
79006: PPUSH
79007: CALL_OW 301
79011: IFFALSE 79029
// defenders := defenders diff i ;
79013: LD_ADDR_VAR 0 2
79017: PUSH
79018: LD_VAR 0 2
79022: PUSH
79023: LD_VAR 0 5
79027: DIFF
79028: ST_TO_ADDR
// end ;
79029: GO 78212
79031: POP
79032: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
79033: LD_VAR 0 3
79037: NOT
79038: PUSH
79039: LD_VAR 0 2
79043: NOT
79044: OR
79045: PUSH
79046: LD_EXP 14
79050: PUSH
79051: LD_VAR 0 1
79055: ARRAY
79056: NOT
79057: OR
79058: IFFALSE 78116
// MC_Reset ( base , 18 ) ;
79060: LD_VAR 0 1
79064: PPUSH
79065: LD_INT 18
79067: PPUSH
79068: CALL 46215 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
79072: LD_ADDR_VAR 0 2
79076: PUSH
79077: LD_VAR 0 2
79081: PUSH
79082: LD_VAR 0 2
79086: PPUSH
79087: LD_INT 2
79089: PUSH
79090: LD_INT 25
79092: PUSH
79093: LD_INT 1
79095: PUSH
79096: EMPTY
79097: LIST
79098: LIST
79099: PUSH
79100: LD_INT 25
79102: PUSH
79103: LD_INT 5
79105: PUSH
79106: EMPTY
79107: LIST
79108: LIST
79109: PUSH
79110: LD_INT 25
79112: PUSH
79113: LD_INT 8
79115: PUSH
79116: EMPTY
79117: LIST
79118: LIST
79119: PUSH
79120: LD_INT 25
79122: PUSH
79123: LD_INT 9
79125: PUSH
79126: EMPTY
79127: LIST
79128: LIST
79129: PUSH
79130: EMPTY
79131: LIST
79132: LIST
79133: LIST
79134: LIST
79135: LIST
79136: PPUSH
79137: CALL_OW 72
79141: DIFF
79142: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
79143: LD_VAR 0 3
79147: NOT
79148: PUSH
79149: LD_VAR 0 2
79153: PPUSH
79154: LD_INT 21
79156: PUSH
79157: LD_INT 2
79159: PUSH
79160: EMPTY
79161: LIST
79162: LIST
79163: PPUSH
79164: CALL_OW 72
79168: AND
79169: IFFALSE 79507
// begin tmp := FilterByTag ( defenders , 19 ) ;
79171: LD_ADDR_VAR 0 12
79175: PUSH
79176: LD_VAR 0 2
79180: PPUSH
79181: LD_INT 19
79183: PPUSH
79184: CALL 38321 0 2
79188: ST_TO_ADDR
// if tmp then
79189: LD_VAR 0 12
79193: IFFALSE 79263
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
79195: LD_ADDR_VAR 0 12
79199: PUSH
79200: LD_VAR 0 12
79204: PPUSH
79205: LD_INT 25
79207: PUSH
79208: LD_INT 3
79210: PUSH
79211: EMPTY
79212: LIST
79213: LIST
79214: PPUSH
79215: CALL_OW 72
79219: ST_TO_ADDR
// if tmp then
79220: LD_VAR 0 12
79224: IFFALSE 79263
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
79226: LD_ADDR_EXP 26
79230: PUSH
79231: LD_EXP 26
79235: PPUSH
79236: LD_VAR 0 1
79240: PPUSH
79241: LD_EXP 26
79245: PUSH
79246: LD_VAR 0 1
79250: ARRAY
79251: PUSH
79252: LD_VAR 0 12
79256: UNION
79257: PPUSH
79258: CALL_OW 1
79262: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
79263: LD_VAR 0 1
79267: PPUSH
79268: LD_INT 19
79270: PPUSH
79271: CALL 46215 0 2
// repeat wait ( 0 0$1 ) ;
79275: LD_INT 35
79277: PPUSH
79278: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
79282: LD_EXP 14
79286: PUSH
79287: LD_VAR 0 1
79291: ARRAY
79292: NOT
79293: PUSH
79294: LD_EXP 14
79298: PUSH
79299: LD_VAR 0 1
79303: ARRAY
79304: PUSH
79305: EMPTY
79306: EQUAL
79307: OR
79308: IFFALSE 79345
// begin for i in defenders do
79310: LD_ADDR_VAR 0 5
79314: PUSH
79315: LD_VAR 0 2
79319: PUSH
79320: FOR_IN
79321: IFFALSE 79334
// ComStop ( i ) ;
79323: LD_VAR 0 5
79327: PPUSH
79328: CALL_OW 141
79332: GO 79320
79334: POP
79335: POP
// defenders := [ ] ;
79336: LD_ADDR_VAR 0 2
79340: PUSH
79341: EMPTY
79342: ST_TO_ADDR
// exit ;
79343: GO 79571
// end ; for i in defenders do
79345: LD_ADDR_VAR 0 5
79349: PUSH
79350: LD_VAR 0 2
79354: PUSH
79355: FOR_IN
79356: IFFALSE 79445
// begin if not IsInArea ( i , mc_parking [ base ] ) then
79358: LD_VAR 0 5
79362: PPUSH
79363: LD_EXP 38
79367: PUSH
79368: LD_VAR 0 1
79372: ARRAY
79373: PPUSH
79374: CALL_OW 308
79378: NOT
79379: IFFALSE 79403
// ComMoveToArea ( i , mc_parking [ base ] ) else
79381: LD_VAR 0 5
79385: PPUSH
79386: LD_EXP 38
79390: PUSH
79391: LD_VAR 0 1
79395: ARRAY
79396: PPUSH
79397: CALL_OW 113
79401: GO 79443
// if GetControl ( i ) = control_manual then
79403: LD_VAR 0 5
79407: PPUSH
79408: CALL_OW 263
79412: PUSH
79413: LD_INT 1
79415: EQUAL
79416: IFFALSE 79443
// if IsDrivenBy ( i ) then
79418: LD_VAR 0 5
79422: PPUSH
79423: CALL_OW 311
79427: IFFALSE 79443
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
79429: LD_VAR 0 5
79433: PPUSH
79434: CALL_OW 311
79438: PPUSH
79439: CALL_OW 121
// end ;
79443: GO 79355
79445: POP
79446: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
79447: LD_VAR 0 2
79451: PPUSH
79452: LD_INT 95
79454: PUSH
79455: LD_EXP 38
79459: PUSH
79460: LD_VAR 0 1
79464: ARRAY
79465: PUSH
79466: EMPTY
79467: LIST
79468: LIST
79469: PPUSH
79470: CALL_OW 72
79474: PUSH
79475: LD_VAR 0 2
79479: EQUAL
79480: PUSH
79481: LD_EXP 37
79485: PUSH
79486: LD_VAR 0 1
79490: ARRAY
79491: OR
79492: PUSH
79493: LD_EXP 14
79497: PUSH
79498: LD_VAR 0 1
79502: ARRAY
79503: NOT
79504: OR
79505: IFFALSE 79275
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
79507: LD_ADDR_EXP 36
79511: PUSH
79512: LD_EXP 36
79516: PPUSH
79517: LD_VAR 0 1
79521: PPUSH
79522: LD_VAR 0 2
79526: PPUSH
79527: LD_INT 21
79529: PUSH
79530: LD_INT 2
79532: PUSH
79533: EMPTY
79534: LIST
79535: LIST
79536: PPUSH
79537: CALL_OW 72
79541: PPUSH
79542: CALL_OW 1
79546: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
79547: LD_VAR 0 1
79551: PPUSH
79552: LD_INT 19
79554: PPUSH
79555: CALL 46215 0 2
// MC_Reset ( base , 20 ) ;
79559: LD_VAR 0 1
79563: PPUSH
79564: LD_INT 20
79566: PPUSH
79567: CALL 46215 0 2
// end ; end_of_file
79571: LD_VAR 0 4
79575: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
79576: LD_INT 0
79578: PPUSH
79579: PPUSH
79580: PPUSH
79581: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
79582: LD_VAR 0 1
79586: PPUSH
79587: CALL_OW 264
79591: PUSH
79592: LD_EXP 61
79596: EQUAL
79597: IFFALSE 79669
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
79599: LD_INT 68
79601: PPUSH
79602: LD_VAR 0 1
79606: PPUSH
79607: CALL_OW 255
79611: PPUSH
79612: CALL_OW 321
79616: PUSH
79617: LD_INT 2
79619: EQUAL
79620: IFFALSE 79632
// eff := 70 else
79622: LD_ADDR_VAR 0 4
79626: PUSH
79627: LD_INT 70
79629: ST_TO_ADDR
79630: GO 79640
// eff := 30 ;
79632: LD_ADDR_VAR 0 4
79636: PUSH
79637: LD_INT 30
79639: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
79640: LD_VAR 0 1
79644: PPUSH
79645: CALL_OW 250
79649: PPUSH
79650: LD_VAR 0 1
79654: PPUSH
79655: CALL_OW 251
79659: PPUSH
79660: LD_VAR 0 4
79664: PPUSH
79665: CALL_OW 495
// end ; end ;
79669: LD_VAR 0 2
79673: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
79674: LD_INT 0
79676: PPUSH
// end ;
79677: LD_VAR 0 4
79681: RET
// export function SOS_Command ( cmd ) ; begin
79682: LD_INT 0
79684: PPUSH
// end ;
79685: LD_VAR 0 2
79689: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
79690: LD_INT 0
79692: PPUSH
// if cmd = 121 then
79693: LD_VAR 0 1
79697: PUSH
79698: LD_INT 121
79700: EQUAL
79701: IFFALSE 79703
// end ;
79703: LD_VAR 0 6
79707: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
79708: LD_INT 0
79710: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
79711: LD_VAR 0 1
79715: PUSH
79716: LD_INT 250
79718: EQUAL
79719: PUSH
79720: LD_VAR 0 2
79724: PPUSH
79725: CALL_OW 264
79729: PUSH
79730: LD_EXP 64
79734: EQUAL
79735: AND
79736: IFFALSE 79757
// MinerPlaceMine ( unit , x , y ) ;
79738: LD_VAR 0 2
79742: PPUSH
79743: LD_VAR 0 4
79747: PPUSH
79748: LD_VAR 0 5
79752: PPUSH
79753: CALL 82106 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
79757: LD_VAR 0 1
79761: PUSH
79762: LD_INT 251
79764: EQUAL
79765: PUSH
79766: LD_VAR 0 2
79770: PPUSH
79771: CALL_OW 264
79775: PUSH
79776: LD_EXP 64
79780: EQUAL
79781: AND
79782: IFFALSE 79803
// MinerDetonateMine ( unit , x , y ) ;
79784: LD_VAR 0 2
79788: PPUSH
79789: LD_VAR 0 4
79793: PPUSH
79794: LD_VAR 0 5
79798: PPUSH
79799: CALL 82383 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
79803: LD_VAR 0 1
79807: PUSH
79808: LD_INT 252
79810: EQUAL
79811: PUSH
79812: LD_VAR 0 2
79816: PPUSH
79817: CALL_OW 264
79821: PUSH
79822: LD_EXP 64
79826: EQUAL
79827: AND
79828: IFFALSE 79849
// MinerCreateMinefield ( unit , x , y ) ;
79830: LD_VAR 0 2
79834: PPUSH
79835: LD_VAR 0 4
79839: PPUSH
79840: LD_VAR 0 5
79844: PPUSH
79845: CALL 82800 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
79849: LD_VAR 0 1
79853: PUSH
79854: LD_INT 253
79856: EQUAL
79857: PUSH
79858: LD_VAR 0 2
79862: PPUSH
79863: CALL_OW 257
79867: PUSH
79868: LD_INT 5
79870: EQUAL
79871: AND
79872: IFFALSE 79893
// ComBinocular ( unit , x , y ) ;
79874: LD_VAR 0 2
79878: PPUSH
79879: LD_VAR 0 4
79883: PPUSH
79884: LD_VAR 0 5
79888: PPUSH
79889: CALL 83171 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
79893: LD_VAR 0 1
79897: PUSH
79898: LD_INT 254
79900: EQUAL
79901: PUSH
79902: LD_VAR 0 2
79906: PPUSH
79907: CALL_OW 264
79911: PUSH
79912: LD_EXP 59
79916: EQUAL
79917: AND
79918: PUSH
79919: LD_VAR 0 3
79923: PPUSH
79924: CALL_OW 263
79928: PUSH
79929: LD_INT 3
79931: EQUAL
79932: AND
79933: IFFALSE 79949
// HackDestroyVehicle ( unit , selectedUnit ) ;
79935: LD_VAR 0 2
79939: PPUSH
79940: LD_VAR 0 3
79944: PPUSH
79945: CALL 81466 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
79949: LD_VAR 0 1
79953: PUSH
79954: LD_INT 255
79956: EQUAL
79957: PUSH
79958: LD_VAR 0 2
79962: PPUSH
79963: CALL_OW 264
79967: PUSH
79968: LD_INT 14
79970: PUSH
79971: LD_INT 53
79973: PUSH
79974: EMPTY
79975: LIST
79976: LIST
79977: IN
79978: AND
79979: PUSH
79980: LD_VAR 0 4
79984: PPUSH
79985: LD_VAR 0 5
79989: PPUSH
79990: CALL_OW 488
79994: AND
79995: IFFALSE 80019
// CutTreeXYR ( unit , x , y , 12 ) ;
79997: LD_VAR 0 2
80001: PPUSH
80002: LD_VAR 0 4
80006: PPUSH
80007: LD_VAR 0 5
80011: PPUSH
80012: LD_INT 12
80014: PPUSH
80015: CALL 80032 0 4
// end ;
80019: LD_VAR 0 6
80023: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
80024: LD_INT 0
80026: PPUSH
// end ;
80027: LD_VAR 0 4
80031: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
80032: LD_INT 0
80034: PPUSH
80035: PPUSH
80036: PPUSH
80037: PPUSH
80038: PPUSH
80039: PPUSH
80040: PPUSH
80041: PPUSH
80042: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
80043: LD_VAR 0 1
80047: NOT
80048: PUSH
80049: LD_VAR 0 2
80053: PPUSH
80054: LD_VAR 0 3
80058: PPUSH
80059: CALL_OW 488
80063: NOT
80064: OR
80065: PUSH
80066: LD_VAR 0 4
80070: NOT
80071: OR
80072: IFFALSE 80076
// exit ;
80074: GO 80416
// list := [ ] ;
80076: LD_ADDR_VAR 0 13
80080: PUSH
80081: EMPTY
80082: ST_TO_ADDR
// if x - r < 0 then
80083: LD_VAR 0 2
80087: PUSH
80088: LD_VAR 0 4
80092: MINUS
80093: PUSH
80094: LD_INT 0
80096: LESS
80097: IFFALSE 80109
// min_x := 0 else
80099: LD_ADDR_VAR 0 7
80103: PUSH
80104: LD_INT 0
80106: ST_TO_ADDR
80107: GO 80125
// min_x := x - r ;
80109: LD_ADDR_VAR 0 7
80113: PUSH
80114: LD_VAR 0 2
80118: PUSH
80119: LD_VAR 0 4
80123: MINUS
80124: ST_TO_ADDR
// if y - r < 0 then
80125: LD_VAR 0 3
80129: PUSH
80130: LD_VAR 0 4
80134: MINUS
80135: PUSH
80136: LD_INT 0
80138: LESS
80139: IFFALSE 80151
// min_y := 0 else
80141: LD_ADDR_VAR 0 8
80145: PUSH
80146: LD_INT 0
80148: ST_TO_ADDR
80149: GO 80167
// min_y := y - r ;
80151: LD_ADDR_VAR 0 8
80155: PUSH
80156: LD_VAR 0 3
80160: PUSH
80161: LD_VAR 0 4
80165: MINUS
80166: ST_TO_ADDR
// max_x := x + r ;
80167: LD_ADDR_VAR 0 9
80171: PUSH
80172: LD_VAR 0 2
80176: PUSH
80177: LD_VAR 0 4
80181: PLUS
80182: ST_TO_ADDR
// max_y := y + r ;
80183: LD_ADDR_VAR 0 10
80187: PUSH
80188: LD_VAR 0 3
80192: PUSH
80193: LD_VAR 0 4
80197: PLUS
80198: ST_TO_ADDR
// for _x = min_x to max_x do
80199: LD_ADDR_VAR 0 11
80203: PUSH
80204: DOUBLE
80205: LD_VAR 0 7
80209: DEC
80210: ST_TO_ADDR
80211: LD_VAR 0 9
80215: PUSH
80216: FOR_TO
80217: IFFALSE 80334
// for _y = min_y to max_y do
80219: LD_ADDR_VAR 0 12
80223: PUSH
80224: DOUBLE
80225: LD_VAR 0 8
80229: DEC
80230: ST_TO_ADDR
80231: LD_VAR 0 10
80235: PUSH
80236: FOR_TO
80237: IFFALSE 80330
// begin if not ValidHex ( _x , _y ) then
80239: LD_VAR 0 11
80243: PPUSH
80244: LD_VAR 0 12
80248: PPUSH
80249: CALL_OW 488
80253: NOT
80254: IFFALSE 80258
// continue ;
80256: GO 80236
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
80258: LD_VAR 0 11
80262: PPUSH
80263: LD_VAR 0 12
80267: PPUSH
80268: CALL_OW 351
80272: PUSH
80273: LD_VAR 0 11
80277: PPUSH
80278: LD_VAR 0 12
80282: PPUSH
80283: CALL_OW 554
80287: AND
80288: IFFALSE 80328
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
80290: LD_ADDR_VAR 0 13
80294: PUSH
80295: LD_VAR 0 13
80299: PPUSH
80300: LD_VAR 0 13
80304: PUSH
80305: LD_INT 1
80307: PLUS
80308: PPUSH
80309: LD_VAR 0 11
80313: PUSH
80314: LD_VAR 0 12
80318: PUSH
80319: EMPTY
80320: LIST
80321: LIST
80322: PPUSH
80323: CALL_OW 2
80327: ST_TO_ADDR
// end ;
80328: GO 80236
80330: POP
80331: POP
80332: GO 80216
80334: POP
80335: POP
// if not list then
80336: LD_VAR 0 13
80340: NOT
80341: IFFALSE 80345
// exit ;
80343: GO 80416
// for i in list do
80345: LD_ADDR_VAR 0 6
80349: PUSH
80350: LD_VAR 0 13
80354: PUSH
80355: FOR_IN
80356: IFFALSE 80414
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
80358: LD_VAR 0 1
80362: PPUSH
80363: LD_STRING M
80365: PUSH
80366: LD_VAR 0 6
80370: PUSH
80371: LD_INT 1
80373: ARRAY
80374: PUSH
80375: LD_VAR 0 6
80379: PUSH
80380: LD_INT 2
80382: ARRAY
80383: PUSH
80384: LD_INT 0
80386: PUSH
80387: LD_INT 0
80389: PUSH
80390: LD_INT 0
80392: PUSH
80393: LD_INT 0
80395: PUSH
80396: EMPTY
80397: LIST
80398: LIST
80399: LIST
80400: LIST
80401: LIST
80402: LIST
80403: LIST
80404: PUSH
80405: EMPTY
80406: LIST
80407: PPUSH
80408: CALL_OW 447
80412: GO 80355
80414: POP
80415: POP
// end ;
80416: LD_VAR 0 5
80420: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
80421: LD_EXP 75
80425: NOT
80426: IFFALSE 80476
80428: GO 80430
80430: DISABLE
// begin initHack := true ;
80431: LD_ADDR_EXP 75
80435: PUSH
80436: LD_INT 1
80438: ST_TO_ADDR
// hackTanks := [ ] ;
80439: LD_ADDR_EXP 76
80443: PUSH
80444: EMPTY
80445: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
80446: LD_ADDR_EXP 77
80450: PUSH
80451: EMPTY
80452: ST_TO_ADDR
// hackLimit := 3 ;
80453: LD_ADDR_EXP 78
80457: PUSH
80458: LD_INT 3
80460: ST_TO_ADDR
// hackDist := 12 ;
80461: LD_ADDR_EXP 79
80465: PUSH
80466: LD_INT 12
80468: ST_TO_ADDR
// hackCounter := [ ] ;
80469: LD_ADDR_EXP 80
80473: PUSH
80474: EMPTY
80475: ST_TO_ADDR
// end ;
80476: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
80477: LD_EXP 75
80481: PUSH
80482: LD_INT 34
80484: PUSH
80485: LD_EXP 59
80489: PUSH
80490: EMPTY
80491: LIST
80492: LIST
80493: PPUSH
80494: CALL_OW 69
80498: AND
80499: IFFALSE 80754
80501: GO 80503
80503: DISABLE
80504: LD_INT 0
80506: PPUSH
80507: PPUSH
// begin enable ;
80508: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
80509: LD_ADDR_VAR 0 1
80513: PUSH
80514: LD_INT 34
80516: PUSH
80517: LD_EXP 59
80521: PUSH
80522: EMPTY
80523: LIST
80524: LIST
80525: PPUSH
80526: CALL_OW 69
80530: PUSH
80531: FOR_IN
80532: IFFALSE 80752
// begin if not i in hackTanks then
80534: LD_VAR 0 1
80538: PUSH
80539: LD_EXP 76
80543: IN
80544: NOT
80545: IFFALSE 80628
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
80547: LD_ADDR_EXP 76
80551: PUSH
80552: LD_EXP 76
80556: PPUSH
80557: LD_EXP 76
80561: PUSH
80562: LD_INT 1
80564: PLUS
80565: PPUSH
80566: LD_VAR 0 1
80570: PPUSH
80571: CALL_OW 1
80575: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
80576: LD_ADDR_EXP 77
80580: PUSH
80581: LD_EXP 77
80585: PPUSH
80586: LD_EXP 77
80590: PUSH
80591: LD_INT 1
80593: PLUS
80594: PPUSH
80595: EMPTY
80596: PPUSH
80597: CALL_OW 1
80601: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
80602: LD_ADDR_EXP 80
80606: PUSH
80607: LD_EXP 80
80611: PPUSH
80612: LD_EXP 80
80616: PUSH
80617: LD_INT 1
80619: PLUS
80620: PPUSH
80621: EMPTY
80622: PPUSH
80623: CALL_OW 1
80627: ST_TO_ADDR
// end ; if not IsOk ( i ) then
80628: LD_VAR 0 1
80632: PPUSH
80633: CALL_OW 302
80637: NOT
80638: IFFALSE 80651
// begin HackUnlinkAll ( i ) ;
80640: LD_VAR 0 1
80644: PPUSH
80645: CALL 80757 0 1
// continue ;
80649: GO 80531
// end ; HackCheckCapturedStatus ( i ) ;
80651: LD_VAR 0 1
80655: PPUSH
80656: CALL 81200 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
80660: LD_ADDR_VAR 0 2
80664: PUSH
80665: LD_INT 81
80667: PUSH
80668: LD_VAR 0 1
80672: PPUSH
80673: CALL_OW 255
80677: PUSH
80678: EMPTY
80679: LIST
80680: LIST
80681: PUSH
80682: LD_INT 33
80684: PUSH
80685: LD_INT 3
80687: PUSH
80688: EMPTY
80689: LIST
80690: LIST
80691: PUSH
80692: LD_INT 91
80694: PUSH
80695: LD_VAR 0 1
80699: PUSH
80700: LD_EXP 79
80704: PUSH
80705: EMPTY
80706: LIST
80707: LIST
80708: LIST
80709: PUSH
80710: LD_INT 50
80712: PUSH
80713: EMPTY
80714: LIST
80715: PUSH
80716: EMPTY
80717: LIST
80718: LIST
80719: LIST
80720: LIST
80721: PPUSH
80722: CALL_OW 69
80726: ST_TO_ADDR
// if not tmp then
80727: LD_VAR 0 2
80731: NOT
80732: IFFALSE 80736
// continue ;
80734: GO 80531
// HackLink ( i , tmp ) ;
80736: LD_VAR 0 1
80740: PPUSH
80741: LD_VAR 0 2
80745: PPUSH
80746: CALL 80893 0 2
// end ;
80750: GO 80531
80752: POP
80753: POP
// end ;
80754: PPOPN 2
80756: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
80757: LD_INT 0
80759: PPUSH
80760: PPUSH
80761: PPUSH
// if not hack in hackTanks then
80762: LD_VAR 0 1
80766: PUSH
80767: LD_EXP 76
80771: IN
80772: NOT
80773: IFFALSE 80777
// exit ;
80775: GO 80888
// index := GetElementIndex ( hackTanks , hack ) ;
80777: LD_ADDR_VAR 0 4
80781: PUSH
80782: LD_EXP 76
80786: PPUSH
80787: LD_VAR 0 1
80791: PPUSH
80792: CALL 9212 0 2
80796: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
80797: LD_EXP 77
80801: PUSH
80802: LD_VAR 0 4
80806: ARRAY
80807: IFFALSE 80888
// begin for i in hackTanksCaptured [ index ] do
80809: LD_ADDR_VAR 0 3
80813: PUSH
80814: LD_EXP 77
80818: PUSH
80819: LD_VAR 0 4
80823: ARRAY
80824: PUSH
80825: FOR_IN
80826: IFFALSE 80852
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
80828: LD_VAR 0 3
80832: PUSH
80833: LD_INT 1
80835: ARRAY
80836: PPUSH
80837: LD_VAR 0 3
80841: PUSH
80842: LD_INT 2
80844: ARRAY
80845: PPUSH
80846: CALL_OW 235
80850: GO 80825
80852: POP
80853: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
80854: LD_ADDR_EXP 77
80858: PUSH
80859: LD_EXP 77
80863: PPUSH
80864: LD_VAR 0 4
80868: PPUSH
80869: EMPTY
80870: PPUSH
80871: CALL_OW 1
80875: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
80876: LD_VAR 0 1
80880: PPUSH
80881: LD_INT 0
80883: PPUSH
80884: CALL_OW 505
// end ; end ;
80888: LD_VAR 0 2
80892: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
80893: LD_INT 0
80895: PPUSH
80896: PPUSH
80897: PPUSH
// if not hack in hackTanks or not vehicles then
80898: LD_VAR 0 1
80902: PUSH
80903: LD_EXP 76
80907: IN
80908: NOT
80909: PUSH
80910: LD_VAR 0 2
80914: NOT
80915: OR
80916: IFFALSE 80920
// exit ;
80918: GO 81195
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
80920: LD_ADDR_VAR 0 2
80924: PUSH
80925: LD_VAR 0 1
80929: PPUSH
80930: LD_VAR 0 2
80934: PPUSH
80935: LD_INT 1
80937: PPUSH
80938: LD_INT 1
80940: PPUSH
80941: CALL 9862 0 4
80945: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
80946: LD_ADDR_VAR 0 5
80950: PUSH
80951: LD_EXP 76
80955: PPUSH
80956: LD_VAR 0 1
80960: PPUSH
80961: CALL 9212 0 2
80965: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
80966: LD_EXP 77
80970: PUSH
80971: LD_VAR 0 5
80975: ARRAY
80976: PUSH
80977: LD_EXP 78
80981: LESS
80982: IFFALSE 81171
// begin for i := 1 to vehicles do
80984: LD_ADDR_VAR 0 4
80988: PUSH
80989: DOUBLE
80990: LD_INT 1
80992: DEC
80993: ST_TO_ADDR
80994: LD_VAR 0 2
80998: PUSH
80999: FOR_TO
81000: IFFALSE 81169
// begin if hackTanksCaptured [ index ] = hackLimit then
81002: LD_EXP 77
81006: PUSH
81007: LD_VAR 0 5
81011: ARRAY
81012: PUSH
81013: LD_EXP 78
81017: EQUAL
81018: IFFALSE 81022
// break ;
81020: GO 81169
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
81022: LD_ADDR_EXP 80
81026: PUSH
81027: LD_EXP 80
81031: PPUSH
81032: LD_VAR 0 5
81036: PPUSH
81037: LD_EXP 80
81041: PUSH
81042: LD_VAR 0 5
81046: ARRAY
81047: PUSH
81048: LD_INT 1
81050: PLUS
81051: PPUSH
81052: CALL_OW 1
81056: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
81057: LD_ADDR_EXP 77
81061: PUSH
81062: LD_EXP 77
81066: PPUSH
81067: LD_VAR 0 5
81071: PUSH
81072: LD_EXP 77
81076: PUSH
81077: LD_VAR 0 5
81081: ARRAY
81082: PUSH
81083: LD_INT 1
81085: PLUS
81086: PUSH
81087: EMPTY
81088: LIST
81089: LIST
81090: PPUSH
81091: LD_VAR 0 2
81095: PUSH
81096: LD_VAR 0 4
81100: ARRAY
81101: PUSH
81102: LD_VAR 0 2
81106: PUSH
81107: LD_VAR 0 4
81111: ARRAY
81112: PPUSH
81113: CALL_OW 255
81117: PUSH
81118: EMPTY
81119: LIST
81120: LIST
81121: PPUSH
81122: CALL 9427 0 3
81126: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
81127: LD_VAR 0 2
81131: PUSH
81132: LD_VAR 0 4
81136: ARRAY
81137: PPUSH
81138: LD_VAR 0 1
81142: PPUSH
81143: CALL_OW 255
81147: PPUSH
81148: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
81152: LD_VAR 0 2
81156: PUSH
81157: LD_VAR 0 4
81161: ARRAY
81162: PPUSH
81163: CALL_OW 141
// end ;
81167: GO 80999
81169: POP
81170: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
81171: LD_VAR 0 1
81175: PPUSH
81176: LD_EXP 77
81180: PUSH
81181: LD_VAR 0 5
81185: ARRAY
81186: PUSH
81187: LD_INT 0
81189: PLUS
81190: PPUSH
81191: CALL_OW 505
// end ;
81195: LD_VAR 0 3
81199: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
81200: LD_INT 0
81202: PPUSH
81203: PPUSH
81204: PPUSH
81205: PPUSH
// if not hack in hackTanks then
81206: LD_VAR 0 1
81210: PUSH
81211: LD_EXP 76
81215: IN
81216: NOT
81217: IFFALSE 81221
// exit ;
81219: GO 81461
// index := GetElementIndex ( hackTanks , hack ) ;
81221: LD_ADDR_VAR 0 4
81225: PUSH
81226: LD_EXP 76
81230: PPUSH
81231: LD_VAR 0 1
81235: PPUSH
81236: CALL 9212 0 2
81240: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
81241: LD_ADDR_VAR 0 3
81245: PUSH
81246: DOUBLE
81247: LD_EXP 77
81251: PUSH
81252: LD_VAR 0 4
81256: ARRAY
81257: INC
81258: ST_TO_ADDR
81259: LD_INT 1
81261: PUSH
81262: FOR_DOWNTO
81263: IFFALSE 81435
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
81265: LD_ADDR_VAR 0 5
81269: PUSH
81270: LD_EXP 77
81274: PUSH
81275: LD_VAR 0 4
81279: ARRAY
81280: PUSH
81281: LD_VAR 0 3
81285: ARRAY
81286: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
81287: LD_VAR 0 5
81291: PUSH
81292: LD_INT 1
81294: ARRAY
81295: PPUSH
81296: CALL_OW 302
81300: NOT
81301: PUSH
81302: LD_VAR 0 5
81306: PUSH
81307: LD_INT 1
81309: ARRAY
81310: PPUSH
81311: CALL_OW 255
81315: PUSH
81316: LD_VAR 0 1
81320: PPUSH
81321: CALL_OW 255
81325: NONEQUAL
81326: OR
81327: IFFALSE 81433
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
81329: LD_VAR 0 5
81333: PUSH
81334: LD_INT 1
81336: ARRAY
81337: PPUSH
81338: CALL_OW 305
81342: PUSH
81343: LD_VAR 0 5
81347: PUSH
81348: LD_INT 1
81350: ARRAY
81351: PPUSH
81352: CALL_OW 255
81356: PUSH
81357: LD_VAR 0 1
81361: PPUSH
81362: CALL_OW 255
81366: EQUAL
81367: AND
81368: IFFALSE 81392
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
81370: LD_VAR 0 5
81374: PUSH
81375: LD_INT 1
81377: ARRAY
81378: PPUSH
81379: LD_VAR 0 5
81383: PUSH
81384: LD_INT 2
81386: ARRAY
81387: PPUSH
81388: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
81392: LD_ADDR_EXP 77
81396: PUSH
81397: LD_EXP 77
81401: PPUSH
81402: LD_VAR 0 4
81406: PPUSH
81407: LD_EXP 77
81411: PUSH
81412: LD_VAR 0 4
81416: ARRAY
81417: PPUSH
81418: LD_VAR 0 3
81422: PPUSH
81423: CALL_OW 3
81427: PPUSH
81428: CALL_OW 1
81432: ST_TO_ADDR
// end ; end ;
81433: GO 81262
81435: POP
81436: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
81437: LD_VAR 0 1
81441: PPUSH
81442: LD_EXP 77
81446: PUSH
81447: LD_VAR 0 4
81451: ARRAY
81452: PUSH
81453: LD_INT 0
81455: PLUS
81456: PPUSH
81457: CALL_OW 505
// end ;
81461: LD_VAR 0 2
81465: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
81466: LD_INT 0
81468: PPUSH
81469: PPUSH
81470: PPUSH
81471: PPUSH
// if not hack in hackTanks then
81472: LD_VAR 0 1
81476: PUSH
81477: LD_EXP 76
81481: IN
81482: NOT
81483: IFFALSE 81487
// exit ;
81485: GO 81572
// index := GetElementIndex ( hackTanks , hack ) ;
81487: LD_ADDR_VAR 0 5
81491: PUSH
81492: LD_EXP 76
81496: PPUSH
81497: LD_VAR 0 1
81501: PPUSH
81502: CALL 9212 0 2
81506: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
81507: LD_ADDR_VAR 0 4
81511: PUSH
81512: DOUBLE
81513: LD_INT 1
81515: DEC
81516: ST_TO_ADDR
81517: LD_EXP 77
81521: PUSH
81522: LD_VAR 0 5
81526: ARRAY
81527: PUSH
81528: FOR_TO
81529: IFFALSE 81570
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
81531: LD_EXP 77
81535: PUSH
81536: LD_VAR 0 5
81540: ARRAY
81541: PUSH
81542: LD_VAR 0 4
81546: ARRAY
81547: PUSH
81548: LD_INT 1
81550: ARRAY
81551: PUSH
81552: LD_VAR 0 2
81556: EQUAL
81557: IFFALSE 81568
// KillUnit ( vehicle ) ;
81559: LD_VAR 0 2
81563: PPUSH
81564: CALL_OW 66
81568: GO 81528
81570: POP
81571: POP
// end ;
81572: LD_VAR 0 3
81576: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
81577: LD_EXP 81
81581: NOT
81582: IFFALSE 81617
81584: GO 81586
81586: DISABLE
// begin initMiner := true ;
81587: LD_ADDR_EXP 81
81591: PUSH
81592: LD_INT 1
81594: ST_TO_ADDR
// minersList := [ ] ;
81595: LD_ADDR_EXP 82
81599: PUSH
81600: EMPTY
81601: ST_TO_ADDR
// minerMinesList := [ ] ;
81602: LD_ADDR_EXP 83
81606: PUSH
81607: EMPTY
81608: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
81609: LD_ADDR_EXP 84
81613: PUSH
81614: LD_INT 5
81616: ST_TO_ADDR
// end ;
81617: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
81618: LD_EXP 81
81622: PUSH
81623: LD_INT 34
81625: PUSH
81626: LD_EXP 64
81630: PUSH
81631: EMPTY
81632: LIST
81633: LIST
81634: PPUSH
81635: CALL_OW 69
81639: AND
81640: IFFALSE 82103
81642: GO 81644
81644: DISABLE
81645: LD_INT 0
81647: PPUSH
81648: PPUSH
81649: PPUSH
81650: PPUSH
// begin enable ;
81651: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
81652: LD_ADDR_VAR 0 1
81656: PUSH
81657: LD_INT 34
81659: PUSH
81660: LD_EXP 64
81664: PUSH
81665: EMPTY
81666: LIST
81667: LIST
81668: PPUSH
81669: CALL_OW 69
81673: PUSH
81674: FOR_IN
81675: IFFALSE 81747
// begin if not i in minersList then
81677: LD_VAR 0 1
81681: PUSH
81682: LD_EXP 82
81686: IN
81687: NOT
81688: IFFALSE 81745
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
81690: LD_ADDR_EXP 82
81694: PUSH
81695: LD_EXP 82
81699: PPUSH
81700: LD_EXP 82
81704: PUSH
81705: LD_INT 1
81707: PLUS
81708: PPUSH
81709: LD_VAR 0 1
81713: PPUSH
81714: CALL_OW 1
81718: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
81719: LD_ADDR_EXP 83
81723: PUSH
81724: LD_EXP 83
81728: PPUSH
81729: LD_EXP 83
81733: PUSH
81734: LD_INT 1
81736: PLUS
81737: PPUSH
81738: EMPTY
81739: PPUSH
81740: CALL_OW 1
81744: ST_TO_ADDR
// end end ;
81745: GO 81674
81747: POP
81748: POP
// for i := minerMinesList downto 1 do
81749: LD_ADDR_VAR 0 1
81753: PUSH
81754: DOUBLE
81755: LD_EXP 83
81759: INC
81760: ST_TO_ADDR
81761: LD_INT 1
81763: PUSH
81764: FOR_DOWNTO
81765: IFFALSE 82101
// begin if IsLive ( minersList [ i ] ) then
81767: LD_EXP 82
81771: PUSH
81772: LD_VAR 0 1
81776: ARRAY
81777: PPUSH
81778: CALL_OW 300
81782: IFFALSE 81810
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
81784: LD_EXP 82
81788: PUSH
81789: LD_VAR 0 1
81793: ARRAY
81794: PPUSH
81795: LD_EXP 83
81799: PUSH
81800: LD_VAR 0 1
81804: ARRAY
81805: PPUSH
81806: CALL_OW 505
// if not minerMinesList [ i ] then
81810: LD_EXP 83
81814: PUSH
81815: LD_VAR 0 1
81819: ARRAY
81820: NOT
81821: IFFALSE 81825
// continue ;
81823: GO 81764
// for j := minerMinesList [ i ] downto 1 do
81825: LD_ADDR_VAR 0 2
81829: PUSH
81830: DOUBLE
81831: LD_EXP 83
81835: PUSH
81836: LD_VAR 0 1
81840: ARRAY
81841: INC
81842: ST_TO_ADDR
81843: LD_INT 1
81845: PUSH
81846: FOR_DOWNTO
81847: IFFALSE 82097
// begin side := GetSide ( minersList [ i ] ) ;
81849: LD_ADDR_VAR 0 3
81853: PUSH
81854: LD_EXP 82
81858: PUSH
81859: LD_VAR 0 1
81863: ARRAY
81864: PPUSH
81865: CALL_OW 255
81869: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
81870: LD_ADDR_VAR 0 4
81874: PUSH
81875: LD_EXP 83
81879: PUSH
81880: LD_VAR 0 1
81884: ARRAY
81885: PUSH
81886: LD_VAR 0 2
81890: ARRAY
81891: PUSH
81892: LD_INT 1
81894: ARRAY
81895: PPUSH
81896: LD_EXP 83
81900: PUSH
81901: LD_VAR 0 1
81905: ARRAY
81906: PUSH
81907: LD_VAR 0 2
81911: ARRAY
81912: PUSH
81913: LD_INT 2
81915: ARRAY
81916: PPUSH
81917: CALL_OW 428
81921: ST_TO_ADDR
// if not tmp then
81922: LD_VAR 0 4
81926: NOT
81927: IFFALSE 81931
// continue ;
81929: GO 81846
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
81931: LD_VAR 0 4
81935: PUSH
81936: LD_INT 81
81938: PUSH
81939: LD_VAR 0 3
81943: PUSH
81944: EMPTY
81945: LIST
81946: LIST
81947: PPUSH
81948: CALL_OW 69
81952: IN
81953: PUSH
81954: LD_EXP 83
81958: PUSH
81959: LD_VAR 0 1
81963: ARRAY
81964: PUSH
81965: LD_VAR 0 2
81969: ARRAY
81970: PUSH
81971: LD_INT 1
81973: ARRAY
81974: PPUSH
81975: LD_EXP 83
81979: PUSH
81980: LD_VAR 0 1
81984: ARRAY
81985: PUSH
81986: LD_VAR 0 2
81990: ARRAY
81991: PUSH
81992: LD_INT 2
81994: ARRAY
81995: PPUSH
81996: CALL_OW 458
82000: AND
82001: IFFALSE 82095
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
82003: LD_EXP 83
82007: PUSH
82008: LD_VAR 0 1
82012: ARRAY
82013: PUSH
82014: LD_VAR 0 2
82018: ARRAY
82019: PUSH
82020: LD_INT 1
82022: ARRAY
82023: PPUSH
82024: LD_EXP 83
82028: PUSH
82029: LD_VAR 0 1
82033: ARRAY
82034: PUSH
82035: LD_VAR 0 2
82039: ARRAY
82040: PUSH
82041: LD_INT 2
82043: ARRAY
82044: PPUSH
82045: LD_VAR 0 3
82049: PPUSH
82050: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
82054: LD_ADDR_EXP 83
82058: PUSH
82059: LD_EXP 83
82063: PPUSH
82064: LD_VAR 0 1
82068: PPUSH
82069: LD_EXP 83
82073: PUSH
82074: LD_VAR 0 1
82078: ARRAY
82079: PPUSH
82080: LD_VAR 0 2
82084: PPUSH
82085: CALL_OW 3
82089: PPUSH
82090: CALL_OW 1
82094: ST_TO_ADDR
// end ; end ;
82095: GO 81846
82097: POP
82098: POP
// end ;
82099: GO 81764
82101: POP
82102: POP
// end ;
82103: PPOPN 4
82105: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
82106: LD_INT 0
82108: PPUSH
82109: PPUSH
// result := false ;
82110: LD_ADDR_VAR 0 4
82114: PUSH
82115: LD_INT 0
82117: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
82118: LD_VAR 0 1
82122: PPUSH
82123: CALL_OW 264
82127: PUSH
82128: LD_EXP 64
82132: EQUAL
82133: NOT
82134: IFFALSE 82138
// exit ;
82136: GO 82378
// index := GetElementIndex ( minersList , unit ) ;
82138: LD_ADDR_VAR 0 5
82142: PUSH
82143: LD_EXP 82
82147: PPUSH
82148: LD_VAR 0 1
82152: PPUSH
82153: CALL 9212 0 2
82157: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
82158: LD_EXP 83
82162: PUSH
82163: LD_VAR 0 5
82167: ARRAY
82168: PUSH
82169: LD_EXP 84
82173: GREATEREQUAL
82174: IFFALSE 82178
// exit ;
82176: GO 82378
// ComMoveXY ( unit , x , y ) ;
82178: LD_VAR 0 1
82182: PPUSH
82183: LD_VAR 0 2
82187: PPUSH
82188: LD_VAR 0 3
82192: PPUSH
82193: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
82197: LD_INT 35
82199: PPUSH
82200: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
82204: LD_VAR 0 1
82208: PPUSH
82209: LD_VAR 0 2
82213: PPUSH
82214: LD_VAR 0 3
82218: PPUSH
82219: CALL 39609 0 3
82223: NOT
82224: PUSH
82225: LD_VAR 0 1
82229: PPUSH
82230: CALL_OW 314
82234: AND
82235: IFFALSE 82239
// exit ;
82237: GO 82378
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
82239: LD_VAR 0 2
82243: PPUSH
82244: LD_VAR 0 3
82248: PPUSH
82249: CALL_OW 428
82253: PUSH
82254: LD_VAR 0 1
82258: EQUAL
82259: PUSH
82260: LD_VAR 0 1
82264: PPUSH
82265: CALL_OW 314
82269: NOT
82270: AND
82271: IFFALSE 82197
// PlaySoundXY ( x , y , PlantMine ) ;
82273: LD_VAR 0 2
82277: PPUSH
82278: LD_VAR 0 3
82282: PPUSH
82283: LD_STRING PlantMine
82285: PPUSH
82286: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
82290: LD_VAR 0 2
82294: PPUSH
82295: LD_VAR 0 3
82299: PPUSH
82300: LD_VAR 0 1
82304: PPUSH
82305: CALL_OW 255
82309: PPUSH
82310: LD_INT 0
82312: PPUSH
82313: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
82317: LD_ADDR_EXP 83
82321: PUSH
82322: LD_EXP 83
82326: PPUSH
82327: LD_VAR 0 5
82331: PUSH
82332: LD_EXP 83
82336: PUSH
82337: LD_VAR 0 5
82341: ARRAY
82342: PUSH
82343: LD_INT 1
82345: PLUS
82346: PUSH
82347: EMPTY
82348: LIST
82349: LIST
82350: PPUSH
82351: LD_VAR 0 2
82355: PUSH
82356: LD_VAR 0 3
82360: PUSH
82361: EMPTY
82362: LIST
82363: LIST
82364: PPUSH
82365: CALL 9427 0 3
82369: ST_TO_ADDR
// result := true ;
82370: LD_ADDR_VAR 0 4
82374: PUSH
82375: LD_INT 1
82377: ST_TO_ADDR
// end ;
82378: LD_VAR 0 4
82382: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
82383: LD_INT 0
82385: PPUSH
82386: PPUSH
82387: PPUSH
// if not unit in minersList then
82388: LD_VAR 0 1
82392: PUSH
82393: LD_EXP 82
82397: IN
82398: NOT
82399: IFFALSE 82403
// exit ;
82401: GO 82795
// index := GetElementIndex ( minersList , unit ) ;
82403: LD_ADDR_VAR 0 6
82407: PUSH
82408: LD_EXP 82
82412: PPUSH
82413: LD_VAR 0 1
82417: PPUSH
82418: CALL 9212 0 2
82422: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
82423: LD_ADDR_VAR 0 5
82427: PUSH
82428: DOUBLE
82429: LD_EXP 83
82433: PUSH
82434: LD_VAR 0 6
82438: ARRAY
82439: INC
82440: ST_TO_ADDR
82441: LD_INT 1
82443: PUSH
82444: FOR_DOWNTO
82445: IFFALSE 82606
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
82447: LD_EXP 83
82451: PUSH
82452: LD_VAR 0 6
82456: ARRAY
82457: PUSH
82458: LD_VAR 0 5
82462: ARRAY
82463: PUSH
82464: LD_INT 1
82466: ARRAY
82467: PUSH
82468: LD_VAR 0 2
82472: EQUAL
82473: PUSH
82474: LD_EXP 83
82478: PUSH
82479: LD_VAR 0 6
82483: ARRAY
82484: PUSH
82485: LD_VAR 0 5
82489: ARRAY
82490: PUSH
82491: LD_INT 2
82493: ARRAY
82494: PUSH
82495: LD_VAR 0 3
82499: EQUAL
82500: AND
82501: IFFALSE 82604
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
82503: LD_EXP 83
82507: PUSH
82508: LD_VAR 0 6
82512: ARRAY
82513: PUSH
82514: LD_VAR 0 5
82518: ARRAY
82519: PUSH
82520: LD_INT 1
82522: ARRAY
82523: PPUSH
82524: LD_EXP 83
82528: PUSH
82529: LD_VAR 0 6
82533: ARRAY
82534: PUSH
82535: LD_VAR 0 5
82539: ARRAY
82540: PUSH
82541: LD_INT 2
82543: ARRAY
82544: PPUSH
82545: LD_VAR 0 1
82549: PPUSH
82550: CALL_OW 255
82554: PPUSH
82555: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
82559: LD_ADDR_EXP 83
82563: PUSH
82564: LD_EXP 83
82568: PPUSH
82569: LD_VAR 0 6
82573: PPUSH
82574: LD_EXP 83
82578: PUSH
82579: LD_VAR 0 6
82583: ARRAY
82584: PPUSH
82585: LD_VAR 0 5
82589: PPUSH
82590: CALL_OW 3
82594: PPUSH
82595: CALL_OW 1
82599: ST_TO_ADDR
// exit ;
82600: POP
82601: POP
82602: GO 82795
// end ; end ;
82604: GO 82444
82606: POP
82607: POP
// for i := minerMinesList [ index ] downto 1 do
82608: LD_ADDR_VAR 0 5
82612: PUSH
82613: DOUBLE
82614: LD_EXP 83
82618: PUSH
82619: LD_VAR 0 6
82623: ARRAY
82624: INC
82625: ST_TO_ADDR
82626: LD_INT 1
82628: PUSH
82629: FOR_DOWNTO
82630: IFFALSE 82793
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
82632: LD_EXP 83
82636: PUSH
82637: LD_VAR 0 6
82641: ARRAY
82642: PUSH
82643: LD_VAR 0 5
82647: ARRAY
82648: PUSH
82649: LD_INT 1
82651: ARRAY
82652: PPUSH
82653: LD_EXP 83
82657: PUSH
82658: LD_VAR 0 6
82662: ARRAY
82663: PUSH
82664: LD_VAR 0 5
82668: ARRAY
82669: PUSH
82670: LD_INT 2
82672: ARRAY
82673: PPUSH
82674: LD_VAR 0 2
82678: PPUSH
82679: LD_VAR 0 3
82683: PPUSH
82684: CALL_OW 298
82688: PUSH
82689: LD_INT 6
82691: LESS
82692: IFFALSE 82791
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
82694: LD_EXP 83
82698: PUSH
82699: LD_VAR 0 6
82703: ARRAY
82704: PUSH
82705: LD_VAR 0 5
82709: ARRAY
82710: PUSH
82711: LD_INT 1
82713: ARRAY
82714: PPUSH
82715: LD_EXP 83
82719: PUSH
82720: LD_VAR 0 6
82724: ARRAY
82725: PUSH
82726: LD_VAR 0 5
82730: ARRAY
82731: PUSH
82732: LD_INT 2
82734: ARRAY
82735: PPUSH
82736: LD_VAR 0 1
82740: PPUSH
82741: CALL_OW 255
82745: PPUSH
82746: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
82750: LD_ADDR_EXP 83
82754: PUSH
82755: LD_EXP 83
82759: PPUSH
82760: LD_VAR 0 6
82764: PPUSH
82765: LD_EXP 83
82769: PUSH
82770: LD_VAR 0 6
82774: ARRAY
82775: PPUSH
82776: LD_VAR 0 5
82780: PPUSH
82781: CALL_OW 3
82785: PPUSH
82786: CALL_OW 1
82790: ST_TO_ADDR
// end ; end ;
82791: GO 82629
82793: POP
82794: POP
// end ;
82795: LD_VAR 0 4
82799: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
82800: LD_INT 0
82802: PPUSH
82803: PPUSH
82804: PPUSH
82805: PPUSH
82806: PPUSH
82807: PPUSH
82808: PPUSH
82809: PPUSH
82810: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
82811: LD_VAR 0 1
82815: PPUSH
82816: CALL_OW 264
82820: PUSH
82821: LD_EXP 64
82825: EQUAL
82826: NOT
82827: PUSH
82828: LD_VAR 0 1
82832: PUSH
82833: LD_EXP 82
82837: IN
82838: NOT
82839: OR
82840: IFFALSE 82844
// exit ;
82842: GO 83166
// index := GetElementIndex ( minersList , unit ) ;
82844: LD_ADDR_VAR 0 6
82848: PUSH
82849: LD_EXP 82
82853: PPUSH
82854: LD_VAR 0 1
82858: PPUSH
82859: CALL 9212 0 2
82863: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
82864: LD_ADDR_VAR 0 8
82868: PUSH
82869: LD_EXP 84
82873: PUSH
82874: LD_EXP 83
82878: PUSH
82879: LD_VAR 0 6
82883: ARRAY
82884: MINUS
82885: ST_TO_ADDR
// if not minesFreeAmount then
82886: LD_VAR 0 8
82890: NOT
82891: IFFALSE 82895
// exit ;
82893: GO 83166
// tmp := [ ] ;
82895: LD_ADDR_VAR 0 7
82899: PUSH
82900: EMPTY
82901: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
82902: LD_ADDR_VAR 0 5
82906: PUSH
82907: DOUBLE
82908: LD_INT 1
82910: DEC
82911: ST_TO_ADDR
82912: LD_VAR 0 8
82916: PUSH
82917: FOR_TO
82918: IFFALSE 83113
// begin _d := rand ( 0 , 5 ) ;
82920: LD_ADDR_VAR 0 11
82924: PUSH
82925: LD_INT 0
82927: PPUSH
82928: LD_INT 5
82930: PPUSH
82931: CALL_OW 12
82935: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
82936: LD_ADDR_VAR 0 12
82940: PUSH
82941: LD_INT 2
82943: PPUSH
82944: LD_INT 6
82946: PPUSH
82947: CALL_OW 12
82951: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
82952: LD_ADDR_VAR 0 9
82956: PUSH
82957: LD_VAR 0 2
82961: PPUSH
82962: LD_VAR 0 11
82966: PPUSH
82967: LD_VAR 0 12
82971: PPUSH
82972: CALL_OW 272
82976: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
82977: LD_ADDR_VAR 0 10
82981: PUSH
82982: LD_VAR 0 3
82986: PPUSH
82987: LD_VAR 0 11
82991: PPUSH
82992: LD_VAR 0 12
82996: PPUSH
82997: CALL_OW 273
83001: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
83002: LD_VAR 0 9
83006: PPUSH
83007: LD_VAR 0 10
83011: PPUSH
83012: CALL_OW 488
83016: PUSH
83017: LD_VAR 0 9
83021: PUSH
83022: LD_VAR 0 10
83026: PUSH
83027: EMPTY
83028: LIST
83029: LIST
83030: PUSH
83031: LD_VAR 0 7
83035: IN
83036: NOT
83037: AND
83038: PUSH
83039: LD_VAR 0 9
83043: PPUSH
83044: LD_VAR 0 10
83048: PPUSH
83049: CALL_OW 458
83053: NOT
83054: AND
83055: IFFALSE 83097
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
83057: LD_ADDR_VAR 0 7
83061: PUSH
83062: LD_VAR 0 7
83066: PPUSH
83067: LD_VAR 0 7
83071: PUSH
83072: LD_INT 1
83074: PLUS
83075: PPUSH
83076: LD_VAR 0 9
83080: PUSH
83081: LD_VAR 0 10
83085: PUSH
83086: EMPTY
83087: LIST
83088: LIST
83089: PPUSH
83090: CALL_OW 1
83094: ST_TO_ADDR
83095: GO 83111
// i := i - 1 ;
83097: LD_ADDR_VAR 0 5
83101: PUSH
83102: LD_VAR 0 5
83106: PUSH
83107: LD_INT 1
83109: MINUS
83110: ST_TO_ADDR
// end ;
83111: GO 82917
83113: POP
83114: POP
// for i in tmp do
83115: LD_ADDR_VAR 0 5
83119: PUSH
83120: LD_VAR 0 7
83124: PUSH
83125: FOR_IN
83126: IFFALSE 83164
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
83128: LD_VAR 0 1
83132: PPUSH
83133: LD_VAR 0 5
83137: PUSH
83138: LD_INT 1
83140: ARRAY
83141: PPUSH
83142: LD_VAR 0 5
83146: PUSH
83147: LD_INT 2
83149: ARRAY
83150: PPUSH
83151: CALL 82106 0 3
83155: NOT
83156: IFFALSE 83162
// exit ;
83158: POP
83159: POP
83160: GO 83166
83162: GO 83125
83164: POP
83165: POP
// end ;
83166: LD_VAR 0 4
83170: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
83171: LD_INT 0
83173: PPUSH
83174: PPUSH
83175: PPUSH
83176: PPUSH
83177: PPUSH
83178: PPUSH
83179: PPUSH
// if not GetClass ( unit ) = class_sniper then
83180: LD_VAR 0 1
83184: PPUSH
83185: CALL_OW 257
83189: PUSH
83190: LD_INT 5
83192: EQUAL
83193: NOT
83194: IFFALSE 83198
// exit ;
83196: GO 83586
// dist := 8 ;
83198: LD_ADDR_VAR 0 5
83202: PUSH
83203: LD_INT 8
83205: ST_TO_ADDR
// viewRange := 12 ;
83206: LD_ADDR_VAR 0 7
83210: PUSH
83211: LD_INT 12
83213: ST_TO_ADDR
// side := GetSide ( unit ) ;
83214: LD_ADDR_VAR 0 6
83218: PUSH
83219: LD_VAR 0 1
83223: PPUSH
83224: CALL_OW 255
83228: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
83229: LD_INT 61
83231: PPUSH
83232: LD_VAR 0 6
83236: PPUSH
83237: CALL_OW 321
83241: PUSH
83242: LD_INT 2
83244: EQUAL
83245: IFFALSE 83255
// viewRange := 16 ;
83247: LD_ADDR_VAR 0 7
83251: PUSH
83252: LD_INT 16
83254: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
83255: LD_VAR 0 1
83259: PPUSH
83260: LD_VAR 0 2
83264: PPUSH
83265: LD_VAR 0 3
83269: PPUSH
83270: CALL_OW 297
83274: PUSH
83275: LD_VAR 0 5
83279: GREATER
83280: IFFALSE 83359
// begin ComMoveXY ( unit , x , y ) ;
83282: LD_VAR 0 1
83286: PPUSH
83287: LD_VAR 0 2
83291: PPUSH
83292: LD_VAR 0 3
83296: PPUSH
83297: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
83301: LD_INT 35
83303: PPUSH
83304: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
83308: LD_VAR 0 1
83312: PPUSH
83313: LD_VAR 0 2
83317: PPUSH
83318: LD_VAR 0 3
83322: PPUSH
83323: CALL 39609 0 3
83327: NOT
83328: IFFALSE 83332
// exit ;
83330: GO 83586
// until GetDistUnitXY ( unit , x , y ) < dist ;
83332: LD_VAR 0 1
83336: PPUSH
83337: LD_VAR 0 2
83341: PPUSH
83342: LD_VAR 0 3
83346: PPUSH
83347: CALL_OW 297
83351: PUSH
83352: LD_VAR 0 5
83356: LESS
83357: IFFALSE 83301
// end ; ComTurnXY ( unit , x , y ) ;
83359: LD_VAR 0 1
83363: PPUSH
83364: LD_VAR 0 2
83368: PPUSH
83369: LD_VAR 0 3
83373: PPUSH
83374: CALL_OW 118
// wait ( 5 ) ;
83378: LD_INT 5
83380: PPUSH
83381: CALL_OW 67
// _d := GetDir ( unit ) ;
83385: LD_ADDR_VAR 0 10
83389: PUSH
83390: LD_VAR 0 1
83394: PPUSH
83395: CALL_OW 254
83399: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
83400: LD_ADDR_VAR 0 8
83404: PUSH
83405: LD_VAR 0 1
83409: PPUSH
83410: CALL_OW 250
83414: PPUSH
83415: LD_VAR 0 10
83419: PPUSH
83420: LD_VAR 0 5
83424: PPUSH
83425: CALL_OW 272
83429: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
83430: LD_ADDR_VAR 0 9
83434: PUSH
83435: LD_VAR 0 1
83439: PPUSH
83440: CALL_OW 251
83444: PPUSH
83445: LD_VAR 0 10
83449: PPUSH
83450: LD_VAR 0 5
83454: PPUSH
83455: CALL_OW 273
83459: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
83460: LD_VAR 0 8
83464: PPUSH
83465: LD_VAR 0 9
83469: PPUSH
83470: CALL_OW 488
83474: NOT
83475: IFFALSE 83479
// exit ;
83477: GO 83586
// ComAnimCustom ( unit , 1 ) ;
83479: LD_VAR 0 1
83483: PPUSH
83484: LD_INT 1
83486: PPUSH
83487: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
83491: LD_VAR 0 8
83495: PPUSH
83496: LD_VAR 0 9
83500: PPUSH
83501: LD_VAR 0 6
83505: PPUSH
83506: LD_VAR 0 7
83510: PPUSH
83511: CALL_OW 330
// repeat wait ( 1 ) ;
83515: LD_INT 1
83517: PPUSH
83518: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
83522: LD_VAR 0 1
83526: PPUSH
83527: CALL_OW 316
83531: PUSH
83532: LD_VAR 0 1
83536: PPUSH
83537: CALL_OW 314
83541: OR
83542: PUSH
83543: LD_VAR 0 1
83547: PPUSH
83548: CALL_OW 302
83552: NOT
83553: OR
83554: PUSH
83555: LD_VAR 0 1
83559: PPUSH
83560: CALL_OW 301
83564: OR
83565: IFFALSE 83515
// RemoveSeeing ( _x , _y , side ) ;
83567: LD_VAR 0 8
83571: PPUSH
83572: LD_VAR 0 9
83576: PPUSH
83577: LD_VAR 0 6
83581: PPUSH
83582: CALL_OW 331
// end ; end_of_file end_of_file
83586: LD_VAR 0 4
83590: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
83591: LD_VAR 0 1
83595: PUSH
83596: LD_INT 200
83598: DOUBLE
83599: GREATEREQUAL
83600: IFFALSE 83608
83602: LD_INT 299
83604: DOUBLE
83605: LESSEQUAL
83606: IFTRUE 83610
83608: GO 83642
83610: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; end ;
83611: LD_VAR 0 1
83615: PPUSH
83616: LD_VAR 0 2
83620: PPUSH
83621: LD_VAR 0 3
83625: PPUSH
83626: LD_VAR 0 4
83630: PPUSH
83631: LD_VAR 0 5
83635: PPUSH
83636: CALL 79708 0 5
83640: GO 83643
83642: POP
// end ; end_of_file
83643: PPOPN 11
83645: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
83646: LD_VAR 0 2
83650: PUSH
83651: LD_INT 100
83653: EQUAL
83654: IFFALSE 84603
// begin if not StreamModeActive then
83656: LD_EXP 85
83660: NOT
83661: IFFALSE 83671
// StreamModeActive := true ;
83663: LD_ADDR_EXP 85
83667: PUSH
83668: LD_INT 1
83670: ST_TO_ADDR
// if p3 = 0 then
83671: LD_VAR 0 3
83675: PUSH
83676: LD_INT 0
83678: EQUAL
83679: IFFALSE 83685
// InitStreamMode ;
83681: CALL 84761 0 0
// if p3 = 1 then
83685: LD_VAR 0 3
83689: PUSH
83690: LD_INT 1
83692: EQUAL
83693: IFFALSE 83703
// sRocket := true ;
83695: LD_ADDR_EXP 90
83699: PUSH
83700: LD_INT 1
83702: ST_TO_ADDR
// if p3 = 2 then
83703: LD_VAR 0 3
83707: PUSH
83708: LD_INT 2
83710: EQUAL
83711: IFFALSE 83721
// sSpeed := true ;
83713: LD_ADDR_EXP 89
83717: PUSH
83718: LD_INT 1
83720: ST_TO_ADDR
// if p3 = 3 then
83721: LD_VAR 0 3
83725: PUSH
83726: LD_INT 3
83728: EQUAL
83729: IFFALSE 83739
// sEngine := true ;
83731: LD_ADDR_EXP 91
83735: PUSH
83736: LD_INT 1
83738: ST_TO_ADDR
// if p3 = 4 then
83739: LD_VAR 0 3
83743: PUSH
83744: LD_INT 4
83746: EQUAL
83747: IFFALSE 83757
// sSpec := true ;
83749: LD_ADDR_EXP 88
83753: PUSH
83754: LD_INT 1
83756: ST_TO_ADDR
// if p3 = 5 then
83757: LD_VAR 0 3
83761: PUSH
83762: LD_INT 5
83764: EQUAL
83765: IFFALSE 83775
// sLevel := true ;
83767: LD_ADDR_EXP 92
83771: PUSH
83772: LD_INT 1
83774: ST_TO_ADDR
// if p3 = 6 then
83775: LD_VAR 0 3
83779: PUSH
83780: LD_INT 6
83782: EQUAL
83783: IFFALSE 83793
// sArmoury := true ;
83785: LD_ADDR_EXP 93
83789: PUSH
83790: LD_INT 1
83792: ST_TO_ADDR
// if p3 = 7 then
83793: LD_VAR 0 3
83797: PUSH
83798: LD_INT 7
83800: EQUAL
83801: IFFALSE 83811
// sRadar := true ;
83803: LD_ADDR_EXP 94
83807: PUSH
83808: LD_INT 1
83810: ST_TO_ADDR
// if p3 = 8 then
83811: LD_VAR 0 3
83815: PUSH
83816: LD_INT 8
83818: EQUAL
83819: IFFALSE 83829
// sBunker := true ;
83821: LD_ADDR_EXP 95
83825: PUSH
83826: LD_INT 1
83828: ST_TO_ADDR
// if p3 = 9 then
83829: LD_VAR 0 3
83833: PUSH
83834: LD_INT 9
83836: EQUAL
83837: IFFALSE 83847
// sHack := true ;
83839: LD_ADDR_EXP 96
83843: PUSH
83844: LD_INT 1
83846: ST_TO_ADDR
// if p3 = 10 then
83847: LD_VAR 0 3
83851: PUSH
83852: LD_INT 10
83854: EQUAL
83855: IFFALSE 83865
// sFire := true ;
83857: LD_ADDR_EXP 97
83861: PUSH
83862: LD_INT 1
83864: ST_TO_ADDR
// if p3 = 11 then
83865: LD_VAR 0 3
83869: PUSH
83870: LD_INT 11
83872: EQUAL
83873: IFFALSE 83883
// sRefresh := true ;
83875: LD_ADDR_EXP 98
83879: PUSH
83880: LD_INT 1
83882: ST_TO_ADDR
// if p3 = 12 then
83883: LD_VAR 0 3
83887: PUSH
83888: LD_INT 12
83890: EQUAL
83891: IFFALSE 83901
// sExp := true ;
83893: LD_ADDR_EXP 99
83897: PUSH
83898: LD_INT 1
83900: ST_TO_ADDR
// if p3 = 13 then
83901: LD_VAR 0 3
83905: PUSH
83906: LD_INT 13
83908: EQUAL
83909: IFFALSE 83919
// sDepot := true ;
83911: LD_ADDR_EXP 100
83915: PUSH
83916: LD_INT 1
83918: ST_TO_ADDR
// if p3 = 14 then
83919: LD_VAR 0 3
83923: PUSH
83924: LD_INT 14
83926: EQUAL
83927: IFFALSE 83937
// sFlag := true ;
83929: LD_ADDR_EXP 101
83933: PUSH
83934: LD_INT 1
83936: ST_TO_ADDR
// if p3 = 15 then
83937: LD_VAR 0 3
83941: PUSH
83942: LD_INT 15
83944: EQUAL
83945: IFFALSE 83955
// sKamikadze := true ;
83947: LD_ADDR_EXP 109
83951: PUSH
83952: LD_INT 1
83954: ST_TO_ADDR
// if p3 = 16 then
83955: LD_VAR 0 3
83959: PUSH
83960: LD_INT 16
83962: EQUAL
83963: IFFALSE 83973
// sTroll := true ;
83965: LD_ADDR_EXP 110
83969: PUSH
83970: LD_INT 1
83972: ST_TO_ADDR
// if p3 = 17 then
83973: LD_VAR 0 3
83977: PUSH
83978: LD_INT 17
83980: EQUAL
83981: IFFALSE 83991
// sSlow := true ;
83983: LD_ADDR_EXP 111
83987: PUSH
83988: LD_INT 1
83990: ST_TO_ADDR
// if p3 = 18 then
83991: LD_VAR 0 3
83995: PUSH
83996: LD_INT 18
83998: EQUAL
83999: IFFALSE 84009
// sLack := true ;
84001: LD_ADDR_EXP 112
84005: PUSH
84006: LD_INT 1
84008: ST_TO_ADDR
// if p3 = 19 then
84009: LD_VAR 0 3
84013: PUSH
84014: LD_INT 19
84016: EQUAL
84017: IFFALSE 84027
// sTank := true ;
84019: LD_ADDR_EXP 114
84023: PUSH
84024: LD_INT 1
84026: ST_TO_ADDR
// if p3 = 20 then
84027: LD_VAR 0 3
84031: PUSH
84032: LD_INT 20
84034: EQUAL
84035: IFFALSE 84045
// sRemote := true ;
84037: LD_ADDR_EXP 115
84041: PUSH
84042: LD_INT 1
84044: ST_TO_ADDR
// if p3 = 21 then
84045: LD_VAR 0 3
84049: PUSH
84050: LD_INT 21
84052: EQUAL
84053: IFFALSE 84063
// sPowell := true ;
84055: LD_ADDR_EXP 116
84059: PUSH
84060: LD_INT 1
84062: ST_TO_ADDR
// if p3 = 22 then
84063: LD_VAR 0 3
84067: PUSH
84068: LD_INT 22
84070: EQUAL
84071: IFFALSE 84081
// sTeleport := true ;
84073: LD_ADDR_EXP 119
84077: PUSH
84078: LD_INT 1
84080: ST_TO_ADDR
// if p3 = 23 then
84081: LD_VAR 0 3
84085: PUSH
84086: LD_INT 23
84088: EQUAL
84089: IFFALSE 84099
// sOilTower := true ;
84091: LD_ADDR_EXP 121
84095: PUSH
84096: LD_INT 1
84098: ST_TO_ADDR
// if p3 = 24 then
84099: LD_VAR 0 3
84103: PUSH
84104: LD_INT 24
84106: EQUAL
84107: IFFALSE 84117
// sShovel := true ;
84109: LD_ADDR_EXP 122
84113: PUSH
84114: LD_INT 1
84116: ST_TO_ADDR
// if p3 = 25 then
84117: LD_VAR 0 3
84121: PUSH
84122: LD_INT 25
84124: EQUAL
84125: IFFALSE 84135
// sSheik := true ;
84127: LD_ADDR_EXP 123
84131: PUSH
84132: LD_INT 1
84134: ST_TO_ADDR
// if p3 = 26 then
84135: LD_VAR 0 3
84139: PUSH
84140: LD_INT 26
84142: EQUAL
84143: IFFALSE 84153
// sEarthquake := true ;
84145: LD_ADDR_EXP 125
84149: PUSH
84150: LD_INT 1
84152: ST_TO_ADDR
// if p3 = 27 then
84153: LD_VAR 0 3
84157: PUSH
84158: LD_INT 27
84160: EQUAL
84161: IFFALSE 84171
// sAI := true ;
84163: LD_ADDR_EXP 126
84167: PUSH
84168: LD_INT 1
84170: ST_TO_ADDR
// if p3 = 28 then
84171: LD_VAR 0 3
84175: PUSH
84176: LD_INT 28
84178: EQUAL
84179: IFFALSE 84189
// sCargo := true ;
84181: LD_ADDR_EXP 129
84185: PUSH
84186: LD_INT 1
84188: ST_TO_ADDR
// if p3 = 29 then
84189: LD_VAR 0 3
84193: PUSH
84194: LD_INT 29
84196: EQUAL
84197: IFFALSE 84207
// sDLaser := true ;
84199: LD_ADDR_EXP 130
84203: PUSH
84204: LD_INT 1
84206: ST_TO_ADDR
// if p3 = 30 then
84207: LD_VAR 0 3
84211: PUSH
84212: LD_INT 30
84214: EQUAL
84215: IFFALSE 84225
// sExchange := true ;
84217: LD_ADDR_EXP 131
84221: PUSH
84222: LD_INT 1
84224: ST_TO_ADDR
// if p3 = 31 then
84225: LD_VAR 0 3
84229: PUSH
84230: LD_INT 31
84232: EQUAL
84233: IFFALSE 84243
// sFac := true ;
84235: LD_ADDR_EXP 132
84239: PUSH
84240: LD_INT 1
84242: ST_TO_ADDR
// if p3 = 32 then
84243: LD_VAR 0 3
84247: PUSH
84248: LD_INT 32
84250: EQUAL
84251: IFFALSE 84261
// sPower := true ;
84253: LD_ADDR_EXP 133
84257: PUSH
84258: LD_INT 1
84260: ST_TO_ADDR
// if p3 = 33 then
84261: LD_VAR 0 3
84265: PUSH
84266: LD_INT 33
84268: EQUAL
84269: IFFALSE 84279
// sRandom := true ;
84271: LD_ADDR_EXP 134
84275: PUSH
84276: LD_INT 1
84278: ST_TO_ADDR
// if p3 = 34 then
84279: LD_VAR 0 3
84283: PUSH
84284: LD_INT 34
84286: EQUAL
84287: IFFALSE 84297
// sShield := true ;
84289: LD_ADDR_EXP 135
84293: PUSH
84294: LD_INT 1
84296: ST_TO_ADDR
// if p3 = 35 then
84297: LD_VAR 0 3
84301: PUSH
84302: LD_INT 35
84304: EQUAL
84305: IFFALSE 84315
// sTime := true ;
84307: LD_ADDR_EXP 136
84311: PUSH
84312: LD_INT 1
84314: ST_TO_ADDR
// if p3 = 36 then
84315: LD_VAR 0 3
84319: PUSH
84320: LD_INT 36
84322: EQUAL
84323: IFFALSE 84333
// sTools := true ;
84325: LD_ADDR_EXP 137
84329: PUSH
84330: LD_INT 1
84332: ST_TO_ADDR
// if p3 = 101 then
84333: LD_VAR 0 3
84337: PUSH
84338: LD_INT 101
84340: EQUAL
84341: IFFALSE 84351
// sSold := true ;
84343: LD_ADDR_EXP 102
84347: PUSH
84348: LD_INT 1
84350: ST_TO_ADDR
// if p3 = 102 then
84351: LD_VAR 0 3
84355: PUSH
84356: LD_INT 102
84358: EQUAL
84359: IFFALSE 84369
// sDiff := true ;
84361: LD_ADDR_EXP 103
84365: PUSH
84366: LD_INT 1
84368: ST_TO_ADDR
// if p3 = 103 then
84369: LD_VAR 0 3
84373: PUSH
84374: LD_INT 103
84376: EQUAL
84377: IFFALSE 84387
// sFog := true ;
84379: LD_ADDR_EXP 106
84383: PUSH
84384: LD_INT 1
84386: ST_TO_ADDR
// if p3 = 104 then
84387: LD_VAR 0 3
84391: PUSH
84392: LD_INT 104
84394: EQUAL
84395: IFFALSE 84405
// sReset := true ;
84397: LD_ADDR_EXP 107
84401: PUSH
84402: LD_INT 1
84404: ST_TO_ADDR
// if p3 = 105 then
84405: LD_VAR 0 3
84409: PUSH
84410: LD_INT 105
84412: EQUAL
84413: IFFALSE 84423
// sSun := true ;
84415: LD_ADDR_EXP 108
84419: PUSH
84420: LD_INT 1
84422: ST_TO_ADDR
// if p3 = 106 then
84423: LD_VAR 0 3
84427: PUSH
84428: LD_INT 106
84430: EQUAL
84431: IFFALSE 84441
// sTiger := true ;
84433: LD_ADDR_EXP 104
84437: PUSH
84438: LD_INT 1
84440: ST_TO_ADDR
// if p3 = 107 then
84441: LD_VAR 0 3
84445: PUSH
84446: LD_INT 107
84448: EQUAL
84449: IFFALSE 84459
// sBomb := true ;
84451: LD_ADDR_EXP 105
84455: PUSH
84456: LD_INT 1
84458: ST_TO_ADDR
// if p3 = 108 then
84459: LD_VAR 0 3
84463: PUSH
84464: LD_INT 108
84466: EQUAL
84467: IFFALSE 84477
// sWound := true ;
84469: LD_ADDR_EXP 113
84473: PUSH
84474: LD_INT 1
84476: ST_TO_ADDR
// if p3 = 109 then
84477: LD_VAR 0 3
84481: PUSH
84482: LD_INT 109
84484: EQUAL
84485: IFFALSE 84495
// sBetray := true ;
84487: LD_ADDR_EXP 117
84491: PUSH
84492: LD_INT 1
84494: ST_TO_ADDR
// if p3 = 110 then
84495: LD_VAR 0 3
84499: PUSH
84500: LD_INT 110
84502: EQUAL
84503: IFFALSE 84513
// sContamin := true ;
84505: LD_ADDR_EXP 118
84509: PUSH
84510: LD_INT 1
84512: ST_TO_ADDR
// if p3 = 111 then
84513: LD_VAR 0 3
84517: PUSH
84518: LD_INT 111
84520: EQUAL
84521: IFFALSE 84531
// sOil := true ;
84523: LD_ADDR_EXP 120
84527: PUSH
84528: LD_INT 1
84530: ST_TO_ADDR
// if p3 = 112 then
84531: LD_VAR 0 3
84535: PUSH
84536: LD_INT 112
84538: EQUAL
84539: IFFALSE 84549
// sStu := true ;
84541: LD_ADDR_EXP 124
84545: PUSH
84546: LD_INT 1
84548: ST_TO_ADDR
// if p3 = 113 then
84549: LD_VAR 0 3
84553: PUSH
84554: LD_INT 113
84556: EQUAL
84557: IFFALSE 84567
// sBazooka := true ;
84559: LD_ADDR_EXP 127
84563: PUSH
84564: LD_INT 1
84566: ST_TO_ADDR
// if p3 = 114 then
84567: LD_VAR 0 3
84571: PUSH
84572: LD_INT 114
84574: EQUAL
84575: IFFALSE 84585
// sMortar := true ;
84577: LD_ADDR_EXP 128
84581: PUSH
84582: LD_INT 1
84584: ST_TO_ADDR
// if p3 = 115 then
84585: LD_VAR 0 3
84589: PUSH
84590: LD_INT 115
84592: EQUAL
84593: IFFALSE 84603
// sRanger := true ;
84595: LD_ADDR_EXP 138
84599: PUSH
84600: LD_INT 1
84602: ST_TO_ADDR
// end ; if p2 = 101 then
84603: LD_VAR 0 2
84607: PUSH
84608: LD_INT 101
84610: EQUAL
84611: IFFALSE 84739
// begin case p3 of 1 :
84613: LD_VAR 0 3
84617: PUSH
84618: LD_INT 1
84620: DOUBLE
84621: EQUAL
84622: IFTRUE 84626
84624: GO 84633
84626: POP
// hHackUnlimitedResources ; 2 :
84627: CALL 95774 0 0
84631: GO 84739
84633: LD_INT 2
84635: DOUBLE
84636: EQUAL
84637: IFTRUE 84641
84639: GO 84648
84641: POP
// hHackSetLevel10 ; 3 :
84642: CALL 95907 0 0
84646: GO 84739
84648: LD_INT 3
84650: DOUBLE
84651: EQUAL
84652: IFTRUE 84656
84654: GO 84663
84656: POP
// hHackSetLevel10YourUnits ; 4 :
84657: CALL 95992 0 0
84661: GO 84739
84663: LD_INT 4
84665: DOUBLE
84666: EQUAL
84667: IFTRUE 84671
84669: GO 84678
84671: POP
// hHackInvincible ; 5 :
84672: CALL 96440 0 0
84676: GO 84739
84678: LD_INT 5
84680: DOUBLE
84681: EQUAL
84682: IFTRUE 84686
84684: GO 84693
84686: POP
// hHackInvisible ; 6 :
84687: CALL 96551 0 0
84691: GO 84739
84693: LD_INT 6
84695: DOUBLE
84696: EQUAL
84697: IFTRUE 84701
84699: GO 84708
84701: POP
// hHackChangeYourSide ; 7 :
84702: CALL 96608 0 0
84706: GO 84739
84708: LD_INT 7
84710: DOUBLE
84711: EQUAL
84712: IFTRUE 84716
84714: GO 84723
84716: POP
// hHackChangeUnitSide ; 8 :
84717: CALL 96650 0 0
84721: GO 84739
84723: LD_INT 8
84725: DOUBLE
84726: EQUAL
84727: IFTRUE 84731
84729: GO 84738
84731: POP
// hHackFog ; end ;
84732: CALL 96751 0 0
84736: GO 84739
84738: POP
// end ; end ;
84739: PPOPN 6
84741: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
84742: GO 84744
84744: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
84745: LD_STRING initStreamRollete();
84747: PPUSH
84748: CALL_OW 559
// InitStreamMode ;
84752: CALL 84761 0 0
// DefineStreamItems ( ) ;
84756: CALL 85201 0 0
// end ;
84760: END
// function InitStreamMode ; begin
84761: LD_INT 0
84763: PPUSH
// streamModeActive := false ;
84764: LD_ADDR_EXP 85
84768: PUSH
84769: LD_INT 0
84771: ST_TO_ADDR
// normalCounter := 36 ;
84772: LD_ADDR_EXP 86
84776: PUSH
84777: LD_INT 36
84779: ST_TO_ADDR
// hardcoreCounter := 16 ;
84780: LD_ADDR_EXP 87
84784: PUSH
84785: LD_INT 16
84787: ST_TO_ADDR
// sRocket := false ;
84788: LD_ADDR_EXP 90
84792: PUSH
84793: LD_INT 0
84795: ST_TO_ADDR
// sSpeed := false ;
84796: LD_ADDR_EXP 89
84800: PUSH
84801: LD_INT 0
84803: ST_TO_ADDR
// sEngine := false ;
84804: LD_ADDR_EXP 91
84808: PUSH
84809: LD_INT 0
84811: ST_TO_ADDR
// sSpec := false ;
84812: LD_ADDR_EXP 88
84816: PUSH
84817: LD_INT 0
84819: ST_TO_ADDR
// sLevel := false ;
84820: LD_ADDR_EXP 92
84824: PUSH
84825: LD_INT 0
84827: ST_TO_ADDR
// sArmoury := false ;
84828: LD_ADDR_EXP 93
84832: PUSH
84833: LD_INT 0
84835: ST_TO_ADDR
// sRadar := false ;
84836: LD_ADDR_EXP 94
84840: PUSH
84841: LD_INT 0
84843: ST_TO_ADDR
// sBunker := false ;
84844: LD_ADDR_EXP 95
84848: PUSH
84849: LD_INT 0
84851: ST_TO_ADDR
// sHack := false ;
84852: LD_ADDR_EXP 96
84856: PUSH
84857: LD_INT 0
84859: ST_TO_ADDR
// sFire := false ;
84860: LD_ADDR_EXP 97
84864: PUSH
84865: LD_INT 0
84867: ST_TO_ADDR
// sRefresh := false ;
84868: LD_ADDR_EXP 98
84872: PUSH
84873: LD_INT 0
84875: ST_TO_ADDR
// sExp := false ;
84876: LD_ADDR_EXP 99
84880: PUSH
84881: LD_INT 0
84883: ST_TO_ADDR
// sDepot := false ;
84884: LD_ADDR_EXP 100
84888: PUSH
84889: LD_INT 0
84891: ST_TO_ADDR
// sFlag := false ;
84892: LD_ADDR_EXP 101
84896: PUSH
84897: LD_INT 0
84899: ST_TO_ADDR
// sKamikadze := false ;
84900: LD_ADDR_EXP 109
84904: PUSH
84905: LD_INT 0
84907: ST_TO_ADDR
// sTroll := false ;
84908: LD_ADDR_EXP 110
84912: PUSH
84913: LD_INT 0
84915: ST_TO_ADDR
// sSlow := false ;
84916: LD_ADDR_EXP 111
84920: PUSH
84921: LD_INT 0
84923: ST_TO_ADDR
// sLack := false ;
84924: LD_ADDR_EXP 112
84928: PUSH
84929: LD_INT 0
84931: ST_TO_ADDR
// sTank := false ;
84932: LD_ADDR_EXP 114
84936: PUSH
84937: LD_INT 0
84939: ST_TO_ADDR
// sRemote := false ;
84940: LD_ADDR_EXP 115
84944: PUSH
84945: LD_INT 0
84947: ST_TO_ADDR
// sPowell := false ;
84948: LD_ADDR_EXP 116
84952: PUSH
84953: LD_INT 0
84955: ST_TO_ADDR
// sTeleport := false ;
84956: LD_ADDR_EXP 119
84960: PUSH
84961: LD_INT 0
84963: ST_TO_ADDR
// sOilTower := false ;
84964: LD_ADDR_EXP 121
84968: PUSH
84969: LD_INT 0
84971: ST_TO_ADDR
// sShovel := false ;
84972: LD_ADDR_EXP 122
84976: PUSH
84977: LD_INT 0
84979: ST_TO_ADDR
// sSheik := false ;
84980: LD_ADDR_EXP 123
84984: PUSH
84985: LD_INT 0
84987: ST_TO_ADDR
// sEarthquake := false ;
84988: LD_ADDR_EXP 125
84992: PUSH
84993: LD_INT 0
84995: ST_TO_ADDR
// sAI := false ;
84996: LD_ADDR_EXP 126
85000: PUSH
85001: LD_INT 0
85003: ST_TO_ADDR
// sCargo := false ;
85004: LD_ADDR_EXP 129
85008: PUSH
85009: LD_INT 0
85011: ST_TO_ADDR
// sDLaser := false ;
85012: LD_ADDR_EXP 130
85016: PUSH
85017: LD_INT 0
85019: ST_TO_ADDR
// sExchange := false ;
85020: LD_ADDR_EXP 131
85024: PUSH
85025: LD_INT 0
85027: ST_TO_ADDR
// sFac := false ;
85028: LD_ADDR_EXP 132
85032: PUSH
85033: LD_INT 0
85035: ST_TO_ADDR
// sPower := false ;
85036: LD_ADDR_EXP 133
85040: PUSH
85041: LD_INT 0
85043: ST_TO_ADDR
// sRandom := false ;
85044: LD_ADDR_EXP 134
85048: PUSH
85049: LD_INT 0
85051: ST_TO_ADDR
// sShield := false ;
85052: LD_ADDR_EXP 135
85056: PUSH
85057: LD_INT 0
85059: ST_TO_ADDR
// sTime := false ;
85060: LD_ADDR_EXP 136
85064: PUSH
85065: LD_INT 0
85067: ST_TO_ADDR
// sTools := false ;
85068: LD_ADDR_EXP 137
85072: PUSH
85073: LD_INT 0
85075: ST_TO_ADDR
// sSold := false ;
85076: LD_ADDR_EXP 102
85080: PUSH
85081: LD_INT 0
85083: ST_TO_ADDR
// sDiff := false ;
85084: LD_ADDR_EXP 103
85088: PUSH
85089: LD_INT 0
85091: ST_TO_ADDR
// sFog := false ;
85092: LD_ADDR_EXP 106
85096: PUSH
85097: LD_INT 0
85099: ST_TO_ADDR
// sReset := false ;
85100: LD_ADDR_EXP 107
85104: PUSH
85105: LD_INT 0
85107: ST_TO_ADDR
// sSun := false ;
85108: LD_ADDR_EXP 108
85112: PUSH
85113: LD_INT 0
85115: ST_TO_ADDR
// sTiger := false ;
85116: LD_ADDR_EXP 104
85120: PUSH
85121: LD_INT 0
85123: ST_TO_ADDR
// sBomb := false ;
85124: LD_ADDR_EXP 105
85128: PUSH
85129: LD_INT 0
85131: ST_TO_ADDR
// sWound := false ;
85132: LD_ADDR_EXP 113
85136: PUSH
85137: LD_INT 0
85139: ST_TO_ADDR
// sBetray := false ;
85140: LD_ADDR_EXP 117
85144: PUSH
85145: LD_INT 0
85147: ST_TO_ADDR
// sContamin := false ;
85148: LD_ADDR_EXP 118
85152: PUSH
85153: LD_INT 0
85155: ST_TO_ADDR
// sOil := false ;
85156: LD_ADDR_EXP 120
85160: PUSH
85161: LD_INT 0
85163: ST_TO_ADDR
// sStu := false ;
85164: LD_ADDR_EXP 124
85168: PUSH
85169: LD_INT 0
85171: ST_TO_ADDR
// sBazooka := false ;
85172: LD_ADDR_EXP 127
85176: PUSH
85177: LD_INT 0
85179: ST_TO_ADDR
// sMortar := false ;
85180: LD_ADDR_EXP 128
85184: PUSH
85185: LD_INT 0
85187: ST_TO_ADDR
// sRanger := false ;
85188: LD_ADDR_EXP 138
85192: PUSH
85193: LD_INT 0
85195: ST_TO_ADDR
// end ;
85196: LD_VAR 0 1
85200: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
85201: LD_INT 0
85203: PPUSH
85204: PPUSH
85205: PPUSH
85206: PPUSH
85207: PPUSH
// result := [ ] ;
85208: LD_ADDR_VAR 0 1
85212: PUSH
85213: EMPTY
85214: ST_TO_ADDR
// if campaign_id = 1 then
85215: LD_OWVAR 69
85219: PUSH
85220: LD_INT 1
85222: EQUAL
85223: IFFALSE 88161
// begin case mission_number of 1 :
85225: LD_OWVAR 70
85229: PUSH
85230: LD_INT 1
85232: DOUBLE
85233: EQUAL
85234: IFTRUE 85238
85236: GO 85302
85238: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
85239: LD_ADDR_VAR 0 1
85243: PUSH
85244: LD_INT 2
85246: PUSH
85247: LD_INT 4
85249: PUSH
85250: LD_INT 11
85252: PUSH
85253: LD_INT 12
85255: PUSH
85256: LD_INT 15
85258: PUSH
85259: LD_INT 16
85261: PUSH
85262: LD_INT 22
85264: PUSH
85265: LD_INT 23
85267: PUSH
85268: LD_INT 26
85270: PUSH
85271: EMPTY
85272: LIST
85273: LIST
85274: LIST
85275: LIST
85276: LIST
85277: LIST
85278: LIST
85279: LIST
85280: LIST
85281: PUSH
85282: LD_INT 101
85284: PUSH
85285: LD_INT 102
85287: PUSH
85288: LD_INT 106
85290: PUSH
85291: EMPTY
85292: LIST
85293: LIST
85294: LIST
85295: PUSH
85296: EMPTY
85297: LIST
85298: LIST
85299: ST_TO_ADDR
85300: GO 88159
85302: LD_INT 2
85304: DOUBLE
85305: EQUAL
85306: IFTRUE 85310
85308: GO 85382
85310: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
85311: LD_ADDR_VAR 0 1
85315: PUSH
85316: LD_INT 2
85318: PUSH
85319: LD_INT 4
85321: PUSH
85322: LD_INT 11
85324: PUSH
85325: LD_INT 12
85327: PUSH
85328: LD_INT 15
85330: PUSH
85331: LD_INT 16
85333: PUSH
85334: LD_INT 22
85336: PUSH
85337: LD_INT 23
85339: PUSH
85340: LD_INT 26
85342: PUSH
85343: EMPTY
85344: LIST
85345: LIST
85346: LIST
85347: LIST
85348: LIST
85349: LIST
85350: LIST
85351: LIST
85352: LIST
85353: PUSH
85354: LD_INT 101
85356: PUSH
85357: LD_INT 102
85359: PUSH
85360: LD_INT 105
85362: PUSH
85363: LD_INT 106
85365: PUSH
85366: LD_INT 108
85368: PUSH
85369: EMPTY
85370: LIST
85371: LIST
85372: LIST
85373: LIST
85374: LIST
85375: PUSH
85376: EMPTY
85377: LIST
85378: LIST
85379: ST_TO_ADDR
85380: GO 88159
85382: LD_INT 3
85384: DOUBLE
85385: EQUAL
85386: IFTRUE 85390
85388: GO 85466
85390: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
85391: LD_ADDR_VAR 0 1
85395: PUSH
85396: LD_INT 2
85398: PUSH
85399: LD_INT 4
85401: PUSH
85402: LD_INT 5
85404: PUSH
85405: LD_INT 11
85407: PUSH
85408: LD_INT 12
85410: PUSH
85411: LD_INT 15
85413: PUSH
85414: LD_INT 16
85416: PUSH
85417: LD_INT 22
85419: PUSH
85420: LD_INT 26
85422: PUSH
85423: LD_INT 36
85425: PUSH
85426: EMPTY
85427: LIST
85428: LIST
85429: LIST
85430: LIST
85431: LIST
85432: LIST
85433: LIST
85434: LIST
85435: LIST
85436: LIST
85437: PUSH
85438: LD_INT 101
85440: PUSH
85441: LD_INT 102
85443: PUSH
85444: LD_INT 105
85446: PUSH
85447: LD_INT 106
85449: PUSH
85450: LD_INT 108
85452: PUSH
85453: EMPTY
85454: LIST
85455: LIST
85456: LIST
85457: LIST
85458: LIST
85459: PUSH
85460: EMPTY
85461: LIST
85462: LIST
85463: ST_TO_ADDR
85464: GO 88159
85466: LD_INT 4
85468: DOUBLE
85469: EQUAL
85470: IFTRUE 85474
85472: GO 85558
85474: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
85475: LD_ADDR_VAR 0 1
85479: PUSH
85480: LD_INT 2
85482: PUSH
85483: LD_INT 4
85485: PUSH
85486: LD_INT 5
85488: PUSH
85489: LD_INT 8
85491: PUSH
85492: LD_INT 11
85494: PUSH
85495: LD_INT 12
85497: PUSH
85498: LD_INT 15
85500: PUSH
85501: LD_INT 16
85503: PUSH
85504: LD_INT 22
85506: PUSH
85507: LD_INT 23
85509: PUSH
85510: LD_INT 26
85512: PUSH
85513: LD_INT 36
85515: PUSH
85516: EMPTY
85517: LIST
85518: LIST
85519: LIST
85520: LIST
85521: LIST
85522: LIST
85523: LIST
85524: LIST
85525: LIST
85526: LIST
85527: LIST
85528: LIST
85529: PUSH
85530: LD_INT 101
85532: PUSH
85533: LD_INT 102
85535: PUSH
85536: LD_INT 105
85538: PUSH
85539: LD_INT 106
85541: PUSH
85542: LD_INT 108
85544: PUSH
85545: EMPTY
85546: LIST
85547: LIST
85548: LIST
85549: LIST
85550: LIST
85551: PUSH
85552: EMPTY
85553: LIST
85554: LIST
85555: ST_TO_ADDR
85556: GO 88159
85558: LD_INT 5
85560: DOUBLE
85561: EQUAL
85562: IFTRUE 85566
85564: GO 85666
85566: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
85567: LD_ADDR_VAR 0 1
85571: PUSH
85572: LD_INT 2
85574: PUSH
85575: LD_INT 4
85577: PUSH
85578: LD_INT 5
85580: PUSH
85581: LD_INT 6
85583: PUSH
85584: LD_INT 8
85586: PUSH
85587: LD_INT 11
85589: PUSH
85590: LD_INT 12
85592: PUSH
85593: LD_INT 15
85595: PUSH
85596: LD_INT 16
85598: PUSH
85599: LD_INT 22
85601: PUSH
85602: LD_INT 23
85604: PUSH
85605: LD_INT 25
85607: PUSH
85608: LD_INT 26
85610: PUSH
85611: LD_INT 36
85613: PUSH
85614: EMPTY
85615: LIST
85616: LIST
85617: LIST
85618: LIST
85619: LIST
85620: LIST
85621: LIST
85622: LIST
85623: LIST
85624: LIST
85625: LIST
85626: LIST
85627: LIST
85628: LIST
85629: PUSH
85630: LD_INT 101
85632: PUSH
85633: LD_INT 102
85635: PUSH
85636: LD_INT 105
85638: PUSH
85639: LD_INT 106
85641: PUSH
85642: LD_INT 108
85644: PUSH
85645: LD_INT 109
85647: PUSH
85648: LD_INT 112
85650: PUSH
85651: EMPTY
85652: LIST
85653: LIST
85654: LIST
85655: LIST
85656: LIST
85657: LIST
85658: LIST
85659: PUSH
85660: EMPTY
85661: LIST
85662: LIST
85663: ST_TO_ADDR
85664: GO 88159
85666: LD_INT 6
85668: DOUBLE
85669: EQUAL
85670: IFTRUE 85674
85672: GO 85794
85674: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
85675: LD_ADDR_VAR 0 1
85679: PUSH
85680: LD_INT 2
85682: PUSH
85683: LD_INT 4
85685: PUSH
85686: LD_INT 5
85688: PUSH
85689: LD_INT 6
85691: PUSH
85692: LD_INT 8
85694: PUSH
85695: LD_INT 11
85697: PUSH
85698: LD_INT 12
85700: PUSH
85701: LD_INT 15
85703: PUSH
85704: LD_INT 16
85706: PUSH
85707: LD_INT 20
85709: PUSH
85710: LD_INT 21
85712: PUSH
85713: LD_INT 22
85715: PUSH
85716: LD_INT 23
85718: PUSH
85719: LD_INT 25
85721: PUSH
85722: LD_INT 26
85724: PUSH
85725: LD_INT 30
85727: PUSH
85728: LD_INT 31
85730: PUSH
85731: LD_INT 32
85733: PUSH
85734: LD_INT 36
85736: PUSH
85737: EMPTY
85738: LIST
85739: LIST
85740: LIST
85741: LIST
85742: LIST
85743: LIST
85744: LIST
85745: LIST
85746: LIST
85747: LIST
85748: LIST
85749: LIST
85750: LIST
85751: LIST
85752: LIST
85753: LIST
85754: LIST
85755: LIST
85756: LIST
85757: PUSH
85758: LD_INT 101
85760: PUSH
85761: LD_INT 102
85763: PUSH
85764: LD_INT 105
85766: PUSH
85767: LD_INT 106
85769: PUSH
85770: LD_INT 108
85772: PUSH
85773: LD_INT 109
85775: PUSH
85776: LD_INT 112
85778: PUSH
85779: EMPTY
85780: LIST
85781: LIST
85782: LIST
85783: LIST
85784: LIST
85785: LIST
85786: LIST
85787: PUSH
85788: EMPTY
85789: LIST
85790: LIST
85791: ST_TO_ADDR
85792: GO 88159
85794: LD_INT 7
85796: DOUBLE
85797: EQUAL
85798: IFTRUE 85802
85800: GO 85902
85802: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
85803: LD_ADDR_VAR 0 1
85807: PUSH
85808: LD_INT 2
85810: PUSH
85811: LD_INT 4
85813: PUSH
85814: LD_INT 5
85816: PUSH
85817: LD_INT 7
85819: PUSH
85820: LD_INT 11
85822: PUSH
85823: LD_INT 12
85825: PUSH
85826: LD_INT 15
85828: PUSH
85829: LD_INT 16
85831: PUSH
85832: LD_INT 20
85834: PUSH
85835: LD_INT 21
85837: PUSH
85838: LD_INT 22
85840: PUSH
85841: LD_INT 23
85843: PUSH
85844: LD_INT 25
85846: PUSH
85847: LD_INT 26
85849: PUSH
85850: EMPTY
85851: LIST
85852: LIST
85853: LIST
85854: LIST
85855: LIST
85856: LIST
85857: LIST
85858: LIST
85859: LIST
85860: LIST
85861: LIST
85862: LIST
85863: LIST
85864: LIST
85865: PUSH
85866: LD_INT 101
85868: PUSH
85869: LD_INT 102
85871: PUSH
85872: LD_INT 103
85874: PUSH
85875: LD_INT 105
85877: PUSH
85878: LD_INT 106
85880: PUSH
85881: LD_INT 108
85883: PUSH
85884: LD_INT 112
85886: PUSH
85887: EMPTY
85888: LIST
85889: LIST
85890: LIST
85891: LIST
85892: LIST
85893: LIST
85894: LIST
85895: PUSH
85896: EMPTY
85897: LIST
85898: LIST
85899: ST_TO_ADDR
85900: GO 88159
85902: LD_INT 8
85904: DOUBLE
85905: EQUAL
85906: IFTRUE 85910
85908: GO 86038
85910: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
85911: LD_ADDR_VAR 0 1
85915: PUSH
85916: LD_INT 2
85918: PUSH
85919: LD_INT 4
85921: PUSH
85922: LD_INT 5
85924: PUSH
85925: LD_INT 6
85927: PUSH
85928: LD_INT 7
85930: PUSH
85931: LD_INT 8
85933: PUSH
85934: LD_INT 11
85936: PUSH
85937: LD_INT 12
85939: PUSH
85940: LD_INT 15
85942: PUSH
85943: LD_INT 16
85945: PUSH
85946: LD_INT 20
85948: PUSH
85949: LD_INT 21
85951: PUSH
85952: LD_INT 22
85954: PUSH
85955: LD_INT 23
85957: PUSH
85958: LD_INT 25
85960: PUSH
85961: LD_INT 26
85963: PUSH
85964: LD_INT 30
85966: PUSH
85967: LD_INT 31
85969: PUSH
85970: LD_INT 32
85972: PUSH
85973: LD_INT 36
85975: PUSH
85976: EMPTY
85977: LIST
85978: LIST
85979: LIST
85980: LIST
85981: LIST
85982: LIST
85983: LIST
85984: LIST
85985: LIST
85986: LIST
85987: LIST
85988: LIST
85989: LIST
85990: LIST
85991: LIST
85992: LIST
85993: LIST
85994: LIST
85995: LIST
85996: LIST
85997: PUSH
85998: LD_INT 101
86000: PUSH
86001: LD_INT 102
86003: PUSH
86004: LD_INT 103
86006: PUSH
86007: LD_INT 105
86009: PUSH
86010: LD_INT 106
86012: PUSH
86013: LD_INT 108
86015: PUSH
86016: LD_INT 109
86018: PUSH
86019: LD_INT 112
86021: PUSH
86022: EMPTY
86023: LIST
86024: LIST
86025: LIST
86026: LIST
86027: LIST
86028: LIST
86029: LIST
86030: LIST
86031: PUSH
86032: EMPTY
86033: LIST
86034: LIST
86035: ST_TO_ADDR
86036: GO 88159
86038: LD_INT 9
86040: DOUBLE
86041: EQUAL
86042: IFTRUE 86046
86044: GO 86182
86046: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
86047: LD_ADDR_VAR 0 1
86051: PUSH
86052: LD_INT 2
86054: PUSH
86055: LD_INT 4
86057: PUSH
86058: LD_INT 5
86060: PUSH
86061: LD_INT 6
86063: PUSH
86064: LD_INT 7
86066: PUSH
86067: LD_INT 8
86069: PUSH
86070: LD_INT 11
86072: PUSH
86073: LD_INT 12
86075: PUSH
86076: LD_INT 15
86078: PUSH
86079: LD_INT 16
86081: PUSH
86082: LD_INT 20
86084: PUSH
86085: LD_INT 21
86087: PUSH
86088: LD_INT 22
86090: PUSH
86091: LD_INT 23
86093: PUSH
86094: LD_INT 25
86096: PUSH
86097: LD_INT 26
86099: PUSH
86100: LD_INT 28
86102: PUSH
86103: LD_INT 30
86105: PUSH
86106: LD_INT 31
86108: PUSH
86109: LD_INT 32
86111: PUSH
86112: LD_INT 36
86114: PUSH
86115: EMPTY
86116: LIST
86117: LIST
86118: LIST
86119: LIST
86120: LIST
86121: LIST
86122: LIST
86123: LIST
86124: LIST
86125: LIST
86126: LIST
86127: LIST
86128: LIST
86129: LIST
86130: LIST
86131: LIST
86132: LIST
86133: LIST
86134: LIST
86135: LIST
86136: LIST
86137: PUSH
86138: LD_INT 101
86140: PUSH
86141: LD_INT 102
86143: PUSH
86144: LD_INT 103
86146: PUSH
86147: LD_INT 105
86149: PUSH
86150: LD_INT 106
86152: PUSH
86153: LD_INT 108
86155: PUSH
86156: LD_INT 109
86158: PUSH
86159: LD_INT 112
86161: PUSH
86162: LD_INT 114
86164: PUSH
86165: EMPTY
86166: LIST
86167: LIST
86168: LIST
86169: LIST
86170: LIST
86171: LIST
86172: LIST
86173: LIST
86174: LIST
86175: PUSH
86176: EMPTY
86177: LIST
86178: LIST
86179: ST_TO_ADDR
86180: GO 88159
86182: LD_INT 10
86184: DOUBLE
86185: EQUAL
86186: IFTRUE 86190
86188: GO 86374
86190: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
86191: LD_ADDR_VAR 0 1
86195: PUSH
86196: LD_INT 2
86198: PUSH
86199: LD_INT 4
86201: PUSH
86202: LD_INT 5
86204: PUSH
86205: LD_INT 6
86207: PUSH
86208: LD_INT 7
86210: PUSH
86211: LD_INT 8
86213: PUSH
86214: LD_INT 9
86216: PUSH
86217: LD_INT 10
86219: PUSH
86220: LD_INT 11
86222: PUSH
86223: LD_INT 12
86225: PUSH
86226: LD_INT 13
86228: PUSH
86229: LD_INT 14
86231: PUSH
86232: LD_INT 15
86234: PUSH
86235: LD_INT 16
86237: PUSH
86238: LD_INT 17
86240: PUSH
86241: LD_INT 18
86243: PUSH
86244: LD_INT 19
86246: PUSH
86247: LD_INT 20
86249: PUSH
86250: LD_INT 21
86252: PUSH
86253: LD_INT 22
86255: PUSH
86256: LD_INT 23
86258: PUSH
86259: LD_INT 24
86261: PUSH
86262: LD_INT 25
86264: PUSH
86265: LD_INT 26
86267: PUSH
86268: LD_INT 28
86270: PUSH
86271: LD_INT 30
86273: PUSH
86274: LD_INT 31
86276: PUSH
86277: LD_INT 32
86279: PUSH
86280: LD_INT 36
86282: PUSH
86283: EMPTY
86284: LIST
86285: LIST
86286: LIST
86287: LIST
86288: LIST
86289: LIST
86290: LIST
86291: LIST
86292: LIST
86293: LIST
86294: LIST
86295: LIST
86296: LIST
86297: LIST
86298: LIST
86299: LIST
86300: LIST
86301: LIST
86302: LIST
86303: LIST
86304: LIST
86305: LIST
86306: LIST
86307: LIST
86308: LIST
86309: LIST
86310: LIST
86311: LIST
86312: LIST
86313: PUSH
86314: LD_INT 101
86316: PUSH
86317: LD_INT 102
86319: PUSH
86320: LD_INT 103
86322: PUSH
86323: LD_INT 104
86325: PUSH
86326: LD_INT 105
86328: PUSH
86329: LD_INT 106
86331: PUSH
86332: LD_INT 107
86334: PUSH
86335: LD_INT 108
86337: PUSH
86338: LD_INT 109
86340: PUSH
86341: LD_INT 110
86343: PUSH
86344: LD_INT 111
86346: PUSH
86347: LD_INT 112
86349: PUSH
86350: LD_INT 114
86352: PUSH
86353: EMPTY
86354: LIST
86355: LIST
86356: LIST
86357: LIST
86358: LIST
86359: LIST
86360: LIST
86361: LIST
86362: LIST
86363: LIST
86364: LIST
86365: LIST
86366: LIST
86367: PUSH
86368: EMPTY
86369: LIST
86370: LIST
86371: ST_TO_ADDR
86372: GO 88159
86374: LD_INT 11
86376: DOUBLE
86377: EQUAL
86378: IFTRUE 86382
86380: GO 86574
86382: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
86383: LD_ADDR_VAR 0 1
86387: PUSH
86388: LD_INT 2
86390: PUSH
86391: LD_INT 3
86393: PUSH
86394: LD_INT 4
86396: PUSH
86397: LD_INT 5
86399: PUSH
86400: LD_INT 6
86402: PUSH
86403: LD_INT 7
86405: PUSH
86406: LD_INT 8
86408: PUSH
86409: LD_INT 9
86411: PUSH
86412: LD_INT 10
86414: PUSH
86415: LD_INT 11
86417: PUSH
86418: LD_INT 12
86420: PUSH
86421: LD_INT 13
86423: PUSH
86424: LD_INT 14
86426: PUSH
86427: LD_INT 15
86429: PUSH
86430: LD_INT 16
86432: PUSH
86433: LD_INT 17
86435: PUSH
86436: LD_INT 18
86438: PUSH
86439: LD_INT 19
86441: PUSH
86442: LD_INT 20
86444: PUSH
86445: LD_INT 21
86447: PUSH
86448: LD_INT 22
86450: PUSH
86451: LD_INT 23
86453: PUSH
86454: LD_INT 24
86456: PUSH
86457: LD_INT 25
86459: PUSH
86460: LD_INT 26
86462: PUSH
86463: LD_INT 28
86465: PUSH
86466: LD_INT 30
86468: PUSH
86469: LD_INT 31
86471: PUSH
86472: LD_INT 32
86474: PUSH
86475: LD_INT 34
86477: PUSH
86478: LD_INT 36
86480: PUSH
86481: EMPTY
86482: LIST
86483: LIST
86484: LIST
86485: LIST
86486: LIST
86487: LIST
86488: LIST
86489: LIST
86490: LIST
86491: LIST
86492: LIST
86493: LIST
86494: LIST
86495: LIST
86496: LIST
86497: LIST
86498: LIST
86499: LIST
86500: LIST
86501: LIST
86502: LIST
86503: LIST
86504: LIST
86505: LIST
86506: LIST
86507: LIST
86508: LIST
86509: LIST
86510: LIST
86511: LIST
86512: LIST
86513: PUSH
86514: LD_INT 101
86516: PUSH
86517: LD_INT 102
86519: PUSH
86520: LD_INT 103
86522: PUSH
86523: LD_INT 104
86525: PUSH
86526: LD_INT 105
86528: PUSH
86529: LD_INT 106
86531: PUSH
86532: LD_INT 107
86534: PUSH
86535: LD_INT 108
86537: PUSH
86538: LD_INT 109
86540: PUSH
86541: LD_INT 110
86543: PUSH
86544: LD_INT 111
86546: PUSH
86547: LD_INT 112
86549: PUSH
86550: LD_INT 114
86552: PUSH
86553: EMPTY
86554: LIST
86555: LIST
86556: LIST
86557: LIST
86558: LIST
86559: LIST
86560: LIST
86561: LIST
86562: LIST
86563: LIST
86564: LIST
86565: LIST
86566: LIST
86567: PUSH
86568: EMPTY
86569: LIST
86570: LIST
86571: ST_TO_ADDR
86572: GO 88159
86574: LD_INT 12
86576: DOUBLE
86577: EQUAL
86578: IFTRUE 86582
86580: GO 86790
86582: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
86583: LD_ADDR_VAR 0 1
86587: PUSH
86588: LD_INT 1
86590: PUSH
86591: LD_INT 2
86593: PUSH
86594: LD_INT 3
86596: PUSH
86597: LD_INT 4
86599: PUSH
86600: LD_INT 5
86602: PUSH
86603: LD_INT 6
86605: PUSH
86606: LD_INT 7
86608: PUSH
86609: LD_INT 8
86611: PUSH
86612: LD_INT 9
86614: PUSH
86615: LD_INT 10
86617: PUSH
86618: LD_INT 11
86620: PUSH
86621: LD_INT 12
86623: PUSH
86624: LD_INT 13
86626: PUSH
86627: LD_INT 14
86629: PUSH
86630: LD_INT 15
86632: PUSH
86633: LD_INT 16
86635: PUSH
86636: LD_INT 17
86638: PUSH
86639: LD_INT 18
86641: PUSH
86642: LD_INT 19
86644: PUSH
86645: LD_INT 20
86647: PUSH
86648: LD_INT 21
86650: PUSH
86651: LD_INT 22
86653: PUSH
86654: LD_INT 23
86656: PUSH
86657: LD_INT 24
86659: PUSH
86660: LD_INT 25
86662: PUSH
86663: LD_INT 26
86665: PUSH
86666: LD_INT 27
86668: PUSH
86669: LD_INT 28
86671: PUSH
86672: LD_INT 30
86674: PUSH
86675: LD_INT 31
86677: PUSH
86678: LD_INT 32
86680: PUSH
86681: LD_INT 33
86683: PUSH
86684: LD_INT 34
86686: PUSH
86687: LD_INT 36
86689: PUSH
86690: EMPTY
86691: LIST
86692: LIST
86693: LIST
86694: LIST
86695: LIST
86696: LIST
86697: LIST
86698: LIST
86699: LIST
86700: LIST
86701: LIST
86702: LIST
86703: LIST
86704: LIST
86705: LIST
86706: LIST
86707: LIST
86708: LIST
86709: LIST
86710: LIST
86711: LIST
86712: LIST
86713: LIST
86714: LIST
86715: LIST
86716: LIST
86717: LIST
86718: LIST
86719: LIST
86720: LIST
86721: LIST
86722: LIST
86723: LIST
86724: LIST
86725: PUSH
86726: LD_INT 101
86728: PUSH
86729: LD_INT 102
86731: PUSH
86732: LD_INT 103
86734: PUSH
86735: LD_INT 104
86737: PUSH
86738: LD_INT 105
86740: PUSH
86741: LD_INT 106
86743: PUSH
86744: LD_INT 107
86746: PUSH
86747: LD_INT 108
86749: PUSH
86750: LD_INT 109
86752: PUSH
86753: LD_INT 110
86755: PUSH
86756: LD_INT 111
86758: PUSH
86759: LD_INT 112
86761: PUSH
86762: LD_INT 113
86764: PUSH
86765: LD_INT 114
86767: PUSH
86768: EMPTY
86769: LIST
86770: LIST
86771: LIST
86772: LIST
86773: LIST
86774: LIST
86775: LIST
86776: LIST
86777: LIST
86778: LIST
86779: LIST
86780: LIST
86781: LIST
86782: LIST
86783: PUSH
86784: EMPTY
86785: LIST
86786: LIST
86787: ST_TO_ADDR
86788: GO 88159
86790: LD_INT 13
86792: DOUBLE
86793: EQUAL
86794: IFTRUE 86798
86796: GO 86994
86798: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
86799: LD_ADDR_VAR 0 1
86803: PUSH
86804: LD_INT 1
86806: PUSH
86807: LD_INT 2
86809: PUSH
86810: LD_INT 3
86812: PUSH
86813: LD_INT 4
86815: PUSH
86816: LD_INT 5
86818: PUSH
86819: LD_INT 8
86821: PUSH
86822: LD_INT 9
86824: PUSH
86825: LD_INT 10
86827: PUSH
86828: LD_INT 11
86830: PUSH
86831: LD_INT 12
86833: PUSH
86834: LD_INT 14
86836: PUSH
86837: LD_INT 15
86839: PUSH
86840: LD_INT 16
86842: PUSH
86843: LD_INT 17
86845: PUSH
86846: LD_INT 18
86848: PUSH
86849: LD_INT 19
86851: PUSH
86852: LD_INT 20
86854: PUSH
86855: LD_INT 21
86857: PUSH
86858: LD_INT 22
86860: PUSH
86861: LD_INT 23
86863: PUSH
86864: LD_INT 24
86866: PUSH
86867: LD_INT 25
86869: PUSH
86870: LD_INT 26
86872: PUSH
86873: LD_INT 27
86875: PUSH
86876: LD_INT 28
86878: PUSH
86879: LD_INT 30
86881: PUSH
86882: LD_INT 31
86884: PUSH
86885: LD_INT 32
86887: PUSH
86888: LD_INT 33
86890: PUSH
86891: LD_INT 34
86893: PUSH
86894: LD_INT 36
86896: PUSH
86897: EMPTY
86898: LIST
86899: LIST
86900: LIST
86901: LIST
86902: LIST
86903: LIST
86904: LIST
86905: LIST
86906: LIST
86907: LIST
86908: LIST
86909: LIST
86910: LIST
86911: LIST
86912: LIST
86913: LIST
86914: LIST
86915: LIST
86916: LIST
86917: LIST
86918: LIST
86919: LIST
86920: LIST
86921: LIST
86922: LIST
86923: LIST
86924: LIST
86925: LIST
86926: LIST
86927: LIST
86928: LIST
86929: PUSH
86930: LD_INT 101
86932: PUSH
86933: LD_INT 102
86935: PUSH
86936: LD_INT 103
86938: PUSH
86939: LD_INT 104
86941: PUSH
86942: LD_INT 105
86944: PUSH
86945: LD_INT 106
86947: PUSH
86948: LD_INT 107
86950: PUSH
86951: LD_INT 108
86953: PUSH
86954: LD_INT 109
86956: PUSH
86957: LD_INT 110
86959: PUSH
86960: LD_INT 111
86962: PUSH
86963: LD_INT 112
86965: PUSH
86966: LD_INT 113
86968: PUSH
86969: LD_INT 114
86971: PUSH
86972: EMPTY
86973: LIST
86974: LIST
86975: LIST
86976: LIST
86977: LIST
86978: LIST
86979: LIST
86980: LIST
86981: LIST
86982: LIST
86983: LIST
86984: LIST
86985: LIST
86986: LIST
86987: PUSH
86988: EMPTY
86989: LIST
86990: LIST
86991: ST_TO_ADDR
86992: GO 88159
86994: LD_INT 14
86996: DOUBLE
86997: EQUAL
86998: IFTRUE 87002
87000: GO 87214
87002: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
87003: LD_ADDR_VAR 0 1
87007: PUSH
87008: LD_INT 1
87010: PUSH
87011: LD_INT 2
87013: PUSH
87014: LD_INT 3
87016: PUSH
87017: LD_INT 4
87019: PUSH
87020: LD_INT 5
87022: PUSH
87023: LD_INT 6
87025: PUSH
87026: LD_INT 7
87028: PUSH
87029: LD_INT 8
87031: PUSH
87032: LD_INT 9
87034: PUSH
87035: LD_INT 10
87037: PUSH
87038: LD_INT 11
87040: PUSH
87041: LD_INT 12
87043: PUSH
87044: LD_INT 13
87046: PUSH
87047: LD_INT 14
87049: PUSH
87050: LD_INT 15
87052: PUSH
87053: LD_INT 16
87055: PUSH
87056: LD_INT 17
87058: PUSH
87059: LD_INT 18
87061: PUSH
87062: LD_INT 19
87064: PUSH
87065: LD_INT 20
87067: PUSH
87068: LD_INT 21
87070: PUSH
87071: LD_INT 22
87073: PUSH
87074: LD_INT 23
87076: PUSH
87077: LD_INT 24
87079: PUSH
87080: LD_INT 25
87082: PUSH
87083: LD_INT 26
87085: PUSH
87086: LD_INT 27
87088: PUSH
87089: LD_INT 28
87091: PUSH
87092: LD_INT 29
87094: PUSH
87095: LD_INT 30
87097: PUSH
87098: LD_INT 31
87100: PUSH
87101: LD_INT 32
87103: PUSH
87104: LD_INT 33
87106: PUSH
87107: LD_INT 34
87109: PUSH
87110: LD_INT 36
87112: PUSH
87113: EMPTY
87114: LIST
87115: LIST
87116: LIST
87117: LIST
87118: LIST
87119: LIST
87120: LIST
87121: LIST
87122: LIST
87123: LIST
87124: LIST
87125: LIST
87126: LIST
87127: LIST
87128: LIST
87129: LIST
87130: LIST
87131: LIST
87132: LIST
87133: LIST
87134: LIST
87135: LIST
87136: LIST
87137: LIST
87138: LIST
87139: LIST
87140: LIST
87141: LIST
87142: LIST
87143: LIST
87144: LIST
87145: LIST
87146: LIST
87147: LIST
87148: LIST
87149: PUSH
87150: LD_INT 101
87152: PUSH
87153: LD_INT 102
87155: PUSH
87156: LD_INT 103
87158: PUSH
87159: LD_INT 104
87161: PUSH
87162: LD_INT 105
87164: PUSH
87165: LD_INT 106
87167: PUSH
87168: LD_INT 107
87170: PUSH
87171: LD_INT 108
87173: PUSH
87174: LD_INT 109
87176: PUSH
87177: LD_INT 110
87179: PUSH
87180: LD_INT 111
87182: PUSH
87183: LD_INT 112
87185: PUSH
87186: LD_INT 113
87188: PUSH
87189: LD_INT 114
87191: PUSH
87192: EMPTY
87193: LIST
87194: LIST
87195: LIST
87196: LIST
87197: LIST
87198: LIST
87199: LIST
87200: LIST
87201: LIST
87202: LIST
87203: LIST
87204: LIST
87205: LIST
87206: LIST
87207: PUSH
87208: EMPTY
87209: LIST
87210: LIST
87211: ST_TO_ADDR
87212: GO 88159
87214: LD_INT 15
87216: DOUBLE
87217: EQUAL
87218: IFTRUE 87222
87220: GO 87434
87222: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
87223: LD_ADDR_VAR 0 1
87227: PUSH
87228: LD_INT 1
87230: PUSH
87231: LD_INT 2
87233: PUSH
87234: LD_INT 3
87236: PUSH
87237: LD_INT 4
87239: PUSH
87240: LD_INT 5
87242: PUSH
87243: LD_INT 6
87245: PUSH
87246: LD_INT 7
87248: PUSH
87249: LD_INT 8
87251: PUSH
87252: LD_INT 9
87254: PUSH
87255: LD_INT 10
87257: PUSH
87258: LD_INT 11
87260: PUSH
87261: LD_INT 12
87263: PUSH
87264: LD_INT 13
87266: PUSH
87267: LD_INT 14
87269: PUSH
87270: LD_INT 15
87272: PUSH
87273: LD_INT 16
87275: PUSH
87276: LD_INT 17
87278: PUSH
87279: LD_INT 18
87281: PUSH
87282: LD_INT 19
87284: PUSH
87285: LD_INT 20
87287: PUSH
87288: LD_INT 21
87290: PUSH
87291: LD_INT 22
87293: PUSH
87294: LD_INT 23
87296: PUSH
87297: LD_INT 24
87299: PUSH
87300: LD_INT 25
87302: PUSH
87303: LD_INT 26
87305: PUSH
87306: LD_INT 27
87308: PUSH
87309: LD_INT 28
87311: PUSH
87312: LD_INT 29
87314: PUSH
87315: LD_INT 30
87317: PUSH
87318: LD_INT 31
87320: PUSH
87321: LD_INT 32
87323: PUSH
87324: LD_INT 33
87326: PUSH
87327: LD_INT 34
87329: PUSH
87330: LD_INT 36
87332: PUSH
87333: EMPTY
87334: LIST
87335: LIST
87336: LIST
87337: LIST
87338: LIST
87339: LIST
87340: LIST
87341: LIST
87342: LIST
87343: LIST
87344: LIST
87345: LIST
87346: LIST
87347: LIST
87348: LIST
87349: LIST
87350: LIST
87351: LIST
87352: LIST
87353: LIST
87354: LIST
87355: LIST
87356: LIST
87357: LIST
87358: LIST
87359: LIST
87360: LIST
87361: LIST
87362: LIST
87363: LIST
87364: LIST
87365: LIST
87366: LIST
87367: LIST
87368: LIST
87369: PUSH
87370: LD_INT 101
87372: PUSH
87373: LD_INT 102
87375: PUSH
87376: LD_INT 103
87378: PUSH
87379: LD_INT 104
87381: PUSH
87382: LD_INT 105
87384: PUSH
87385: LD_INT 106
87387: PUSH
87388: LD_INT 107
87390: PUSH
87391: LD_INT 108
87393: PUSH
87394: LD_INT 109
87396: PUSH
87397: LD_INT 110
87399: PUSH
87400: LD_INT 111
87402: PUSH
87403: LD_INT 112
87405: PUSH
87406: LD_INT 113
87408: PUSH
87409: LD_INT 114
87411: PUSH
87412: EMPTY
87413: LIST
87414: LIST
87415: LIST
87416: LIST
87417: LIST
87418: LIST
87419: LIST
87420: LIST
87421: LIST
87422: LIST
87423: LIST
87424: LIST
87425: LIST
87426: LIST
87427: PUSH
87428: EMPTY
87429: LIST
87430: LIST
87431: ST_TO_ADDR
87432: GO 88159
87434: LD_INT 16
87436: DOUBLE
87437: EQUAL
87438: IFTRUE 87442
87440: GO 87566
87442: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
87443: LD_ADDR_VAR 0 1
87447: PUSH
87448: LD_INT 2
87450: PUSH
87451: LD_INT 4
87453: PUSH
87454: LD_INT 5
87456: PUSH
87457: LD_INT 7
87459: PUSH
87460: LD_INT 11
87462: PUSH
87463: LD_INT 12
87465: PUSH
87466: LD_INT 15
87468: PUSH
87469: LD_INT 16
87471: PUSH
87472: LD_INT 20
87474: PUSH
87475: LD_INT 21
87477: PUSH
87478: LD_INT 22
87480: PUSH
87481: LD_INT 23
87483: PUSH
87484: LD_INT 25
87486: PUSH
87487: LD_INT 26
87489: PUSH
87490: LD_INT 30
87492: PUSH
87493: LD_INT 31
87495: PUSH
87496: LD_INT 32
87498: PUSH
87499: LD_INT 33
87501: PUSH
87502: LD_INT 34
87504: PUSH
87505: EMPTY
87506: LIST
87507: LIST
87508: LIST
87509: LIST
87510: LIST
87511: LIST
87512: LIST
87513: LIST
87514: LIST
87515: LIST
87516: LIST
87517: LIST
87518: LIST
87519: LIST
87520: LIST
87521: LIST
87522: LIST
87523: LIST
87524: LIST
87525: PUSH
87526: LD_INT 101
87528: PUSH
87529: LD_INT 102
87531: PUSH
87532: LD_INT 103
87534: PUSH
87535: LD_INT 106
87537: PUSH
87538: LD_INT 108
87540: PUSH
87541: LD_INT 112
87543: PUSH
87544: LD_INT 113
87546: PUSH
87547: LD_INT 114
87549: PUSH
87550: EMPTY
87551: LIST
87552: LIST
87553: LIST
87554: LIST
87555: LIST
87556: LIST
87557: LIST
87558: LIST
87559: PUSH
87560: EMPTY
87561: LIST
87562: LIST
87563: ST_TO_ADDR
87564: GO 88159
87566: LD_INT 17
87568: DOUBLE
87569: EQUAL
87570: IFTRUE 87574
87572: GO 87786
87574: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
87575: LD_ADDR_VAR 0 1
87579: PUSH
87580: LD_INT 1
87582: PUSH
87583: LD_INT 2
87585: PUSH
87586: LD_INT 3
87588: PUSH
87589: LD_INT 4
87591: PUSH
87592: LD_INT 5
87594: PUSH
87595: LD_INT 6
87597: PUSH
87598: LD_INT 7
87600: PUSH
87601: LD_INT 8
87603: PUSH
87604: LD_INT 9
87606: PUSH
87607: LD_INT 10
87609: PUSH
87610: LD_INT 11
87612: PUSH
87613: LD_INT 12
87615: PUSH
87616: LD_INT 13
87618: PUSH
87619: LD_INT 14
87621: PUSH
87622: LD_INT 15
87624: PUSH
87625: LD_INT 16
87627: PUSH
87628: LD_INT 17
87630: PUSH
87631: LD_INT 18
87633: PUSH
87634: LD_INT 19
87636: PUSH
87637: LD_INT 20
87639: PUSH
87640: LD_INT 21
87642: PUSH
87643: LD_INT 22
87645: PUSH
87646: LD_INT 23
87648: PUSH
87649: LD_INT 24
87651: PUSH
87652: LD_INT 25
87654: PUSH
87655: LD_INT 26
87657: PUSH
87658: LD_INT 27
87660: PUSH
87661: LD_INT 28
87663: PUSH
87664: LD_INT 29
87666: PUSH
87667: LD_INT 30
87669: PUSH
87670: LD_INT 31
87672: PUSH
87673: LD_INT 32
87675: PUSH
87676: LD_INT 33
87678: PUSH
87679: LD_INT 34
87681: PUSH
87682: LD_INT 36
87684: PUSH
87685: EMPTY
87686: LIST
87687: LIST
87688: LIST
87689: LIST
87690: LIST
87691: LIST
87692: LIST
87693: LIST
87694: LIST
87695: LIST
87696: LIST
87697: LIST
87698: LIST
87699: LIST
87700: LIST
87701: LIST
87702: LIST
87703: LIST
87704: LIST
87705: LIST
87706: LIST
87707: LIST
87708: LIST
87709: LIST
87710: LIST
87711: LIST
87712: LIST
87713: LIST
87714: LIST
87715: LIST
87716: LIST
87717: LIST
87718: LIST
87719: LIST
87720: LIST
87721: PUSH
87722: LD_INT 101
87724: PUSH
87725: LD_INT 102
87727: PUSH
87728: LD_INT 103
87730: PUSH
87731: LD_INT 104
87733: PUSH
87734: LD_INT 105
87736: PUSH
87737: LD_INT 106
87739: PUSH
87740: LD_INT 107
87742: PUSH
87743: LD_INT 108
87745: PUSH
87746: LD_INT 109
87748: PUSH
87749: LD_INT 110
87751: PUSH
87752: LD_INT 111
87754: PUSH
87755: LD_INT 112
87757: PUSH
87758: LD_INT 113
87760: PUSH
87761: LD_INT 114
87763: PUSH
87764: EMPTY
87765: LIST
87766: LIST
87767: LIST
87768: LIST
87769: LIST
87770: LIST
87771: LIST
87772: LIST
87773: LIST
87774: LIST
87775: LIST
87776: LIST
87777: LIST
87778: LIST
87779: PUSH
87780: EMPTY
87781: LIST
87782: LIST
87783: ST_TO_ADDR
87784: GO 88159
87786: LD_INT 18
87788: DOUBLE
87789: EQUAL
87790: IFTRUE 87794
87792: GO 87930
87794: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
87795: LD_ADDR_VAR 0 1
87799: PUSH
87800: LD_INT 2
87802: PUSH
87803: LD_INT 4
87805: PUSH
87806: LD_INT 5
87808: PUSH
87809: LD_INT 7
87811: PUSH
87812: LD_INT 11
87814: PUSH
87815: LD_INT 12
87817: PUSH
87818: LD_INT 15
87820: PUSH
87821: LD_INT 16
87823: PUSH
87824: LD_INT 20
87826: PUSH
87827: LD_INT 21
87829: PUSH
87830: LD_INT 22
87832: PUSH
87833: LD_INT 23
87835: PUSH
87836: LD_INT 25
87838: PUSH
87839: LD_INT 26
87841: PUSH
87842: LD_INT 30
87844: PUSH
87845: LD_INT 31
87847: PUSH
87848: LD_INT 32
87850: PUSH
87851: LD_INT 33
87853: PUSH
87854: LD_INT 34
87856: PUSH
87857: LD_INT 35
87859: PUSH
87860: LD_INT 36
87862: PUSH
87863: EMPTY
87864: LIST
87865: LIST
87866: LIST
87867: LIST
87868: LIST
87869: LIST
87870: LIST
87871: LIST
87872: LIST
87873: LIST
87874: LIST
87875: LIST
87876: LIST
87877: LIST
87878: LIST
87879: LIST
87880: LIST
87881: LIST
87882: LIST
87883: LIST
87884: LIST
87885: PUSH
87886: LD_INT 101
87888: PUSH
87889: LD_INT 102
87891: PUSH
87892: LD_INT 103
87894: PUSH
87895: LD_INT 106
87897: PUSH
87898: LD_INT 108
87900: PUSH
87901: LD_INT 112
87903: PUSH
87904: LD_INT 113
87906: PUSH
87907: LD_INT 114
87909: PUSH
87910: LD_INT 115
87912: PUSH
87913: EMPTY
87914: LIST
87915: LIST
87916: LIST
87917: LIST
87918: LIST
87919: LIST
87920: LIST
87921: LIST
87922: LIST
87923: PUSH
87924: EMPTY
87925: LIST
87926: LIST
87927: ST_TO_ADDR
87928: GO 88159
87930: LD_INT 19
87932: DOUBLE
87933: EQUAL
87934: IFTRUE 87938
87936: GO 88158
87938: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
87939: LD_ADDR_VAR 0 1
87943: PUSH
87944: LD_INT 1
87946: PUSH
87947: LD_INT 2
87949: PUSH
87950: LD_INT 3
87952: PUSH
87953: LD_INT 4
87955: PUSH
87956: LD_INT 5
87958: PUSH
87959: LD_INT 6
87961: PUSH
87962: LD_INT 7
87964: PUSH
87965: LD_INT 8
87967: PUSH
87968: LD_INT 9
87970: PUSH
87971: LD_INT 10
87973: PUSH
87974: LD_INT 11
87976: PUSH
87977: LD_INT 12
87979: PUSH
87980: LD_INT 13
87982: PUSH
87983: LD_INT 14
87985: PUSH
87986: LD_INT 15
87988: PUSH
87989: LD_INT 16
87991: PUSH
87992: LD_INT 17
87994: PUSH
87995: LD_INT 18
87997: PUSH
87998: LD_INT 19
88000: PUSH
88001: LD_INT 20
88003: PUSH
88004: LD_INT 21
88006: PUSH
88007: LD_INT 22
88009: PUSH
88010: LD_INT 23
88012: PUSH
88013: LD_INT 24
88015: PUSH
88016: LD_INT 25
88018: PUSH
88019: LD_INT 26
88021: PUSH
88022: LD_INT 27
88024: PUSH
88025: LD_INT 28
88027: PUSH
88028: LD_INT 29
88030: PUSH
88031: LD_INT 30
88033: PUSH
88034: LD_INT 31
88036: PUSH
88037: LD_INT 32
88039: PUSH
88040: LD_INT 33
88042: PUSH
88043: LD_INT 34
88045: PUSH
88046: LD_INT 35
88048: PUSH
88049: LD_INT 36
88051: PUSH
88052: EMPTY
88053: LIST
88054: LIST
88055: LIST
88056: LIST
88057: LIST
88058: LIST
88059: LIST
88060: LIST
88061: LIST
88062: LIST
88063: LIST
88064: LIST
88065: LIST
88066: LIST
88067: LIST
88068: LIST
88069: LIST
88070: LIST
88071: LIST
88072: LIST
88073: LIST
88074: LIST
88075: LIST
88076: LIST
88077: LIST
88078: LIST
88079: LIST
88080: LIST
88081: LIST
88082: LIST
88083: LIST
88084: LIST
88085: LIST
88086: LIST
88087: LIST
88088: LIST
88089: PUSH
88090: LD_INT 101
88092: PUSH
88093: LD_INT 102
88095: PUSH
88096: LD_INT 103
88098: PUSH
88099: LD_INT 104
88101: PUSH
88102: LD_INT 105
88104: PUSH
88105: LD_INT 106
88107: PUSH
88108: LD_INT 107
88110: PUSH
88111: LD_INT 108
88113: PUSH
88114: LD_INT 109
88116: PUSH
88117: LD_INT 110
88119: PUSH
88120: LD_INT 111
88122: PUSH
88123: LD_INT 112
88125: PUSH
88126: LD_INT 113
88128: PUSH
88129: LD_INT 114
88131: PUSH
88132: LD_INT 115
88134: PUSH
88135: EMPTY
88136: LIST
88137: LIST
88138: LIST
88139: LIST
88140: LIST
88141: LIST
88142: LIST
88143: LIST
88144: LIST
88145: LIST
88146: LIST
88147: LIST
88148: LIST
88149: LIST
88150: LIST
88151: PUSH
88152: EMPTY
88153: LIST
88154: LIST
88155: ST_TO_ADDR
88156: GO 88159
88158: POP
// end else
88159: GO 88378
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
88161: LD_ADDR_VAR 0 1
88165: PUSH
88166: LD_INT 1
88168: PUSH
88169: LD_INT 2
88171: PUSH
88172: LD_INT 3
88174: PUSH
88175: LD_INT 4
88177: PUSH
88178: LD_INT 5
88180: PUSH
88181: LD_INT 6
88183: PUSH
88184: LD_INT 7
88186: PUSH
88187: LD_INT 8
88189: PUSH
88190: LD_INT 9
88192: PUSH
88193: LD_INT 10
88195: PUSH
88196: LD_INT 11
88198: PUSH
88199: LD_INT 12
88201: PUSH
88202: LD_INT 13
88204: PUSH
88205: LD_INT 14
88207: PUSH
88208: LD_INT 15
88210: PUSH
88211: LD_INT 16
88213: PUSH
88214: LD_INT 17
88216: PUSH
88217: LD_INT 18
88219: PUSH
88220: LD_INT 19
88222: PUSH
88223: LD_INT 20
88225: PUSH
88226: LD_INT 21
88228: PUSH
88229: LD_INT 22
88231: PUSH
88232: LD_INT 23
88234: PUSH
88235: LD_INT 24
88237: PUSH
88238: LD_INT 25
88240: PUSH
88241: LD_INT 26
88243: PUSH
88244: LD_INT 27
88246: PUSH
88247: LD_INT 28
88249: PUSH
88250: LD_INT 29
88252: PUSH
88253: LD_INT 30
88255: PUSH
88256: LD_INT 31
88258: PUSH
88259: LD_INT 32
88261: PUSH
88262: LD_INT 33
88264: PUSH
88265: LD_INT 34
88267: PUSH
88268: LD_INT 35
88270: PUSH
88271: LD_INT 36
88273: PUSH
88274: EMPTY
88275: LIST
88276: LIST
88277: LIST
88278: LIST
88279: LIST
88280: LIST
88281: LIST
88282: LIST
88283: LIST
88284: LIST
88285: LIST
88286: LIST
88287: LIST
88288: LIST
88289: LIST
88290: LIST
88291: LIST
88292: LIST
88293: LIST
88294: LIST
88295: LIST
88296: LIST
88297: LIST
88298: LIST
88299: LIST
88300: LIST
88301: LIST
88302: LIST
88303: LIST
88304: LIST
88305: LIST
88306: LIST
88307: LIST
88308: LIST
88309: LIST
88310: LIST
88311: PUSH
88312: LD_INT 101
88314: PUSH
88315: LD_INT 102
88317: PUSH
88318: LD_INT 103
88320: PUSH
88321: LD_INT 104
88323: PUSH
88324: LD_INT 105
88326: PUSH
88327: LD_INT 106
88329: PUSH
88330: LD_INT 107
88332: PUSH
88333: LD_INT 108
88335: PUSH
88336: LD_INT 109
88338: PUSH
88339: LD_INT 110
88341: PUSH
88342: LD_INT 111
88344: PUSH
88345: LD_INT 112
88347: PUSH
88348: LD_INT 113
88350: PUSH
88351: LD_INT 114
88353: PUSH
88354: LD_INT 115
88356: PUSH
88357: EMPTY
88358: LIST
88359: LIST
88360: LIST
88361: LIST
88362: LIST
88363: LIST
88364: LIST
88365: LIST
88366: LIST
88367: LIST
88368: LIST
88369: LIST
88370: LIST
88371: LIST
88372: LIST
88373: PUSH
88374: EMPTY
88375: LIST
88376: LIST
88377: ST_TO_ADDR
// if result then
88378: LD_VAR 0 1
88382: IFFALSE 88671
// begin normal :=  ;
88384: LD_ADDR_VAR 0 3
88388: PUSH
88389: LD_STRING 
88391: ST_TO_ADDR
// hardcore :=  ;
88392: LD_ADDR_VAR 0 4
88396: PUSH
88397: LD_STRING 
88399: ST_TO_ADDR
// for i = 1 to normalCounter do
88400: LD_ADDR_VAR 0 5
88404: PUSH
88405: DOUBLE
88406: LD_INT 1
88408: DEC
88409: ST_TO_ADDR
88410: LD_EXP 86
88414: PUSH
88415: FOR_TO
88416: IFFALSE 88517
// begin tmp := 0 ;
88418: LD_ADDR_VAR 0 2
88422: PUSH
88423: LD_STRING 0
88425: ST_TO_ADDR
// if result [ 1 ] then
88426: LD_VAR 0 1
88430: PUSH
88431: LD_INT 1
88433: ARRAY
88434: IFFALSE 88499
// if result [ 1 ] [ 1 ] = i then
88436: LD_VAR 0 1
88440: PUSH
88441: LD_INT 1
88443: ARRAY
88444: PUSH
88445: LD_INT 1
88447: ARRAY
88448: PUSH
88449: LD_VAR 0 5
88453: EQUAL
88454: IFFALSE 88499
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
88456: LD_ADDR_VAR 0 1
88460: PUSH
88461: LD_VAR 0 1
88465: PPUSH
88466: LD_INT 1
88468: PPUSH
88469: LD_VAR 0 1
88473: PUSH
88474: LD_INT 1
88476: ARRAY
88477: PPUSH
88478: LD_INT 1
88480: PPUSH
88481: CALL_OW 3
88485: PPUSH
88486: CALL_OW 1
88490: ST_TO_ADDR
// tmp := 1 ;
88491: LD_ADDR_VAR 0 2
88495: PUSH
88496: LD_STRING 1
88498: ST_TO_ADDR
// end ; normal := normal & tmp ;
88499: LD_ADDR_VAR 0 3
88503: PUSH
88504: LD_VAR 0 3
88508: PUSH
88509: LD_VAR 0 2
88513: STR
88514: ST_TO_ADDR
// end ;
88515: GO 88415
88517: POP
88518: POP
// for i = 1 to hardcoreCounter do
88519: LD_ADDR_VAR 0 5
88523: PUSH
88524: DOUBLE
88525: LD_INT 1
88527: DEC
88528: ST_TO_ADDR
88529: LD_EXP 87
88533: PUSH
88534: FOR_TO
88535: IFFALSE 88640
// begin tmp := 0 ;
88537: LD_ADDR_VAR 0 2
88541: PUSH
88542: LD_STRING 0
88544: ST_TO_ADDR
// if result [ 2 ] then
88545: LD_VAR 0 1
88549: PUSH
88550: LD_INT 2
88552: ARRAY
88553: IFFALSE 88622
// if result [ 2 ] [ 1 ] = 100 + i then
88555: LD_VAR 0 1
88559: PUSH
88560: LD_INT 2
88562: ARRAY
88563: PUSH
88564: LD_INT 1
88566: ARRAY
88567: PUSH
88568: LD_INT 100
88570: PUSH
88571: LD_VAR 0 5
88575: PLUS
88576: EQUAL
88577: IFFALSE 88622
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
88579: LD_ADDR_VAR 0 1
88583: PUSH
88584: LD_VAR 0 1
88588: PPUSH
88589: LD_INT 2
88591: PPUSH
88592: LD_VAR 0 1
88596: PUSH
88597: LD_INT 2
88599: ARRAY
88600: PPUSH
88601: LD_INT 1
88603: PPUSH
88604: CALL_OW 3
88608: PPUSH
88609: CALL_OW 1
88613: ST_TO_ADDR
// tmp := 1 ;
88614: LD_ADDR_VAR 0 2
88618: PUSH
88619: LD_STRING 1
88621: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
88622: LD_ADDR_VAR 0 4
88626: PUSH
88627: LD_VAR 0 4
88631: PUSH
88632: LD_VAR 0 2
88636: STR
88637: ST_TO_ADDR
// end ;
88638: GO 88534
88640: POP
88641: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
88642: LD_STRING getStreamItemsFromMission("
88644: PUSH
88645: LD_VAR 0 3
88649: STR
88650: PUSH
88651: LD_STRING ","
88653: STR
88654: PUSH
88655: LD_VAR 0 4
88659: STR
88660: PUSH
88661: LD_STRING ")
88663: STR
88664: PPUSH
88665: CALL_OW 559
// end else
88669: GO 88678
// ToLua ( getStreamItemsFromMission("","") ) ;
88671: LD_STRING getStreamItemsFromMission("","")
88673: PPUSH
88674: CALL_OW 559
// end ;
88678: LD_VAR 0 1
88682: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
88683: LD_EXP 85
88687: PUSH
88688: LD_EXP 90
88692: AND
88693: IFFALSE 88817
88695: GO 88697
88697: DISABLE
88698: LD_INT 0
88700: PPUSH
88701: PPUSH
// begin enable ;
88702: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
88703: LD_ADDR_VAR 0 2
88707: PUSH
88708: LD_INT 22
88710: PUSH
88711: LD_OWVAR 2
88715: PUSH
88716: EMPTY
88717: LIST
88718: LIST
88719: PUSH
88720: LD_INT 2
88722: PUSH
88723: LD_INT 34
88725: PUSH
88726: LD_INT 7
88728: PUSH
88729: EMPTY
88730: LIST
88731: LIST
88732: PUSH
88733: LD_INT 34
88735: PUSH
88736: LD_INT 45
88738: PUSH
88739: EMPTY
88740: LIST
88741: LIST
88742: PUSH
88743: LD_INT 34
88745: PUSH
88746: LD_INT 28
88748: PUSH
88749: EMPTY
88750: LIST
88751: LIST
88752: PUSH
88753: LD_INT 34
88755: PUSH
88756: LD_INT 47
88758: PUSH
88759: EMPTY
88760: LIST
88761: LIST
88762: PUSH
88763: EMPTY
88764: LIST
88765: LIST
88766: LIST
88767: LIST
88768: LIST
88769: PUSH
88770: EMPTY
88771: LIST
88772: LIST
88773: PPUSH
88774: CALL_OW 69
88778: ST_TO_ADDR
// if not tmp then
88779: LD_VAR 0 2
88783: NOT
88784: IFFALSE 88788
// exit ;
88786: GO 88817
// for i in tmp do
88788: LD_ADDR_VAR 0 1
88792: PUSH
88793: LD_VAR 0 2
88797: PUSH
88798: FOR_IN
88799: IFFALSE 88815
// begin SetLives ( i , 0 ) ;
88801: LD_VAR 0 1
88805: PPUSH
88806: LD_INT 0
88808: PPUSH
88809: CALL_OW 234
// end ;
88813: GO 88798
88815: POP
88816: POP
// end ;
88817: PPOPN 2
88819: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
88820: LD_EXP 85
88824: PUSH
88825: LD_EXP 91
88829: AND
88830: IFFALSE 88914
88832: GO 88834
88834: DISABLE
88835: LD_INT 0
88837: PPUSH
88838: PPUSH
// begin enable ;
88839: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
88840: LD_ADDR_VAR 0 2
88844: PUSH
88845: LD_INT 22
88847: PUSH
88848: LD_OWVAR 2
88852: PUSH
88853: EMPTY
88854: LIST
88855: LIST
88856: PUSH
88857: LD_INT 32
88859: PUSH
88860: LD_INT 3
88862: PUSH
88863: EMPTY
88864: LIST
88865: LIST
88866: PUSH
88867: EMPTY
88868: LIST
88869: LIST
88870: PPUSH
88871: CALL_OW 69
88875: ST_TO_ADDR
// if not tmp then
88876: LD_VAR 0 2
88880: NOT
88881: IFFALSE 88885
// exit ;
88883: GO 88914
// for i in tmp do
88885: LD_ADDR_VAR 0 1
88889: PUSH
88890: LD_VAR 0 2
88894: PUSH
88895: FOR_IN
88896: IFFALSE 88912
// begin SetLives ( i , 0 ) ;
88898: LD_VAR 0 1
88902: PPUSH
88903: LD_INT 0
88905: PPUSH
88906: CALL_OW 234
// end ;
88910: GO 88895
88912: POP
88913: POP
// end ;
88914: PPOPN 2
88916: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
88917: LD_EXP 85
88921: PUSH
88922: LD_EXP 88
88926: AND
88927: IFFALSE 89020
88929: GO 88931
88931: DISABLE
88932: LD_INT 0
88934: PPUSH
// begin enable ;
88935: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
88936: LD_ADDR_VAR 0 1
88940: PUSH
88941: LD_INT 22
88943: PUSH
88944: LD_OWVAR 2
88948: PUSH
88949: EMPTY
88950: LIST
88951: LIST
88952: PUSH
88953: LD_INT 2
88955: PUSH
88956: LD_INT 25
88958: PUSH
88959: LD_INT 5
88961: PUSH
88962: EMPTY
88963: LIST
88964: LIST
88965: PUSH
88966: LD_INT 25
88968: PUSH
88969: LD_INT 9
88971: PUSH
88972: EMPTY
88973: LIST
88974: LIST
88975: PUSH
88976: LD_INT 25
88978: PUSH
88979: LD_INT 8
88981: PUSH
88982: EMPTY
88983: LIST
88984: LIST
88985: PUSH
88986: EMPTY
88987: LIST
88988: LIST
88989: LIST
88990: LIST
88991: PUSH
88992: EMPTY
88993: LIST
88994: LIST
88995: PPUSH
88996: CALL_OW 69
89000: PUSH
89001: FOR_IN
89002: IFFALSE 89018
// begin SetClass ( i , 1 ) ;
89004: LD_VAR 0 1
89008: PPUSH
89009: LD_INT 1
89011: PPUSH
89012: CALL_OW 336
// end ;
89016: GO 89001
89018: POP
89019: POP
// end ;
89020: PPOPN 1
89022: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
89023: LD_EXP 85
89027: PUSH
89028: LD_EXP 89
89032: AND
89033: PUSH
89034: LD_OWVAR 65
89038: PUSH
89039: LD_INT 7
89041: LESS
89042: AND
89043: IFFALSE 89057
89045: GO 89047
89047: DISABLE
// begin enable ;
89048: ENABLE
// game_speed := 7 ;
89049: LD_ADDR_OWVAR 65
89053: PUSH
89054: LD_INT 7
89056: ST_TO_ADDR
// end ;
89057: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
89058: LD_EXP 85
89062: PUSH
89063: LD_EXP 92
89067: AND
89068: IFFALSE 89270
89070: GO 89072
89072: DISABLE
89073: LD_INT 0
89075: PPUSH
89076: PPUSH
89077: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
89078: LD_ADDR_VAR 0 3
89082: PUSH
89083: LD_INT 81
89085: PUSH
89086: LD_OWVAR 2
89090: PUSH
89091: EMPTY
89092: LIST
89093: LIST
89094: PUSH
89095: LD_INT 21
89097: PUSH
89098: LD_INT 1
89100: PUSH
89101: EMPTY
89102: LIST
89103: LIST
89104: PUSH
89105: EMPTY
89106: LIST
89107: LIST
89108: PPUSH
89109: CALL_OW 69
89113: ST_TO_ADDR
// if not tmp then
89114: LD_VAR 0 3
89118: NOT
89119: IFFALSE 89123
// exit ;
89121: GO 89270
// if tmp > 5 then
89123: LD_VAR 0 3
89127: PUSH
89128: LD_INT 5
89130: GREATER
89131: IFFALSE 89143
// k := 5 else
89133: LD_ADDR_VAR 0 2
89137: PUSH
89138: LD_INT 5
89140: ST_TO_ADDR
89141: GO 89153
// k := tmp ;
89143: LD_ADDR_VAR 0 2
89147: PUSH
89148: LD_VAR 0 3
89152: ST_TO_ADDR
// for i := 1 to k do
89153: LD_ADDR_VAR 0 1
89157: PUSH
89158: DOUBLE
89159: LD_INT 1
89161: DEC
89162: ST_TO_ADDR
89163: LD_VAR 0 2
89167: PUSH
89168: FOR_TO
89169: IFFALSE 89268
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
89171: LD_VAR 0 3
89175: PUSH
89176: LD_VAR 0 1
89180: ARRAY
89181: PPUSH
89182: LD_VAR 0 1
89186: PUSH
89187: LD_INT 4
89189: MOD
89190: PUSH
89191: LD_INT 1
89193: PLUS
89194: PPUSH
89195: CALL_OW 259
89199: PUSH
89200: LD_INT 10
89202: LESS
89203: IFFALSE 89266
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
89205: LD_VAR 0 3
89209: PUSH
89210: LD_VAR 0 1
89214: ARRAY
89215: PPUSH
89216: LD_VAR 0 1
89220: PUSH
89221: LD_INT 4
89223: MOD
89224: PUSH
89225: LD_INT 1
89227: PLUS
89228: PPUSH
89229: LD_VAR 0 3
89233: PUSH
89234: LD_VAR 0 1
89238: ARRAY
89239: PPUSH
89240: LD_VAR 0 1
89244: PUSH
89245: LD_INT 4
89247: MOD
89248: PUSH
89249: LD_INT 1
89251: PLUS
89252: PPUSH
89253: CALL_OW 259
89257: PUSH
89258: LD_INT 1
89260: PLUS
89261: PPUSH
89262: CALL_OW 237
89266: GO 89168
89268: POP
89269: POP
// end ;
89270: PPOPN 3
89272: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
89273: LD_EXP 85
89277: PUSH
89278: LD_EXP 93
89282: AND
89283: IFFALSE 89303
89285: GO 89287
89287: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
89288: LD_INT 4
89290: PPUSH
89291: LD_OWVAR 2
89295: PPUSH
89296: LD_INT 0
89298: PPUSH
89299: CALL_OW 324
89303: END
// every 0 0$1 trigger StreamModeActive and sShovel do
89304: LD_EXP 85
89308: PUSH
89309: LD_EXP 122
89313: AND
89314: IFFALSE 89334
89316: GO 89318
89318: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
89319: LD_INT 19
89321: PPUSH
89322: LD_OWVAR 2
89326: PPUSH
89327: LD_INT 0
89329: PPUSH
89330: CALL_OW 324
89334: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
89335: LD_EXP 85
89339: PUSH
89340: LD_EXP 94
89344: AND
89345: IFFALSE 89447
89347: GO 89349
89349: DISABLE
89350: LD_INT 0
89352: PPUSH
89353: PPUSH
// begin enable ;
89354: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
89355: LD_ADDR_VAR 0 2
89359: PUSH
89360: LD_INT 22
89362: PUSH
89363: LD_OWVAR 2
89367: PUSH
89368: EMPTY
89369: LIST
89370: LIST
89371: PUSH
89372: LD_INT 2
89374: PUSH
89375: LD_INT 34
89377: PUSH
89378: LD_INT 11
89380: PUSH
89381: EMPTY
89382: LIST
89383: LIST
89384: PUSH
89385: LD_INT 34
89387: PUSH
89388: LD_INT 30
89390: PUSH
89391: EMPTY
89392: LIST
89393: LIST
89394: PUSH
89395: EMPTY
89396: LIST
89397: LIST
89398: LIST
89399: PUSH
89400: EMPTY
89401: LIST
89402: LIST
89403: PPUSH
89404: CALL_OW 69
89408: ST_TO_ADDR
// if not tmp then
89409: LD_VAR 0 2
89413: NOT
89414: IFFALSE 89418
// exit ;
89416: GO 89447
// for i in tmp do
89418: LD_ADDR_VAR 0 1
89422: PUSH
89423: LD_VAR 0 2
89427: PUSH
89428: FOR_IN
89429: IFFALSE 89445
// begin SetLives ( i , 0 ) ;
89431: LD_VAR 0 1
89435: PPUSH
89436: LD_INT 0
89438: PPUSH
89439: CALL_OW 234
// end ;
89443: GO 89428
89445: POP
89446: POP
// end ;
89447: PPOPN 2
89449: END
// every 0 0$1 trigger StreamModeActive and sBunker do
89450: LD_EXP 85
89454: PUSH
89455: LD_EXP 95
89459: AND
89460: IFFALSE 89480
89462: GO 89464
89464: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
89465: LD_INT 32
89467: PPUSH
89468: LD_OWVAR 2
89472: PPUSH
89473: LD_INT 0
89475: PPUSH
89476: CALL_OW 324
89480: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
89481: LD_EXP 85
89485: PUSH
89486: LD_EXP 96
89490: AND
89491: IFFALSE 89672
89493: GO 89495
89495: DISABLE
89496: LD_INT 0
89498: PPUSH
89499: PPUSH
89500: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
89501: LD_ADDR_VAR 0 2
89505: PUSH
89506: LD_INT 22
89508: PUSH
89509: LD_OWVAR 2
89513: PUSH
89514: EMPTY
89515: LIST
89516: LIST
89517: PUSH
89518: LD_INT 33
89520: PUSH
89521: LD_INT 3
89523: PUSH
89524: EMPTY
89525: LIST
89526: LIST
89527: PUSH
89528: EMPTY
89529: LIST
89530: LIST
89531: PPUSH
89532: CALL_OW 69
89536: ST_TO_ADDR
// if not tmp then
89537: LD_VAR 0 2
89541: NOT
89542: IFFALSE 89546
// exit ;
89544: GO 89672
// side := 0 ;
89546: LD_ADDR_VAR 0 3
89550: PUSH
89551: LD_INT 0
89553: ST_TO_ADDR
// for i := 1 to 8 do
89554: LD_ADDR_VAR 0 1
89558: PUSH
89559: DOUBLE
89560: LD_INT 1
89562: DEC
89563: ST_TO_ADDR
89564: LD_INT 8
89566: PUSH
89567: FOR_TO
89568: IFFALSE 89616
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
89570: LD_OWVAR 2
89574: PUSH
89575: LD_VAR 0 1
89579: NONEQUAL
89580: PUSH
89581: LD_OWVAR 2
89585: PPUSH
89586: LD_VAR 0 1
89590: PPUSH
89591: CALL_OW 81
89595: PUSH
89596: LD_INT 2
89598: EQUAL
89599: AND
89600: IFFALSE 89614
// begin side := i ;
89602: LD_ADDR_VAR 0 3
89606: PUSH
89607: LD_VAR 0 1
89611: ST_TO_ADDR
// break ;
89612: GO 89616
// end ;
89614: GO 89567
89616: POP
89617: POP
// if not side then
89618: LD_VAR 0 3
89622: NOT
89623: IFFALSE 89627
// exit ;
89625: GO 89672
// for i := 1 to tmp do
89627: LD_ADDR_VAR 0 1
89631: PUSH
89632: DOUBLE
89633: LD_INT 1
89635: DEC
89636: ST_TO_ADDR
89637: LD_VAR 0 2
89641: PUSH
89642: FOR_TO
89643: IFFALSE 89670
// if Prob ( 60 ) then
89645: LD_INT 60
89647: PPUSH
89648: CALL_OW 13
89652: IFFALSE 89668
// SetSide ( i , side ) ;
89654: LD_VAR 0 1
89658: PPUSH
89659: LD_VAR 0 3
89663: PPUSH
89664: CALL_OW 235
89668: GO 89642
89670: POP
89671: POP
// end ;
89672: PPOPN 3
89674: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
89675: LD_EXP 85
89679: PUSH
89680: LD_EXP 98
89684: AND
89685: IFFALSE 89804
89687: GO 89689
89689: DISABLE
89690: LD_INT 0
89692: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
89693: LD_ADDR_VAR 0 1
89697: PUSH
89698: LD_INT 22
89700: PUSH
89701: LD_OWVAR 2
89705: PUSH
89706: EMPTY
89707: LIST
89708: LIST
89709: PUSH
89710: LD_INT 21
89712: PUSH
89713: LD_INT 1
89715: PUSH
89716: EMPTY
89717: LIST
89718: LIST
89719: PUSH
89720: LD_INT 3
89722: PUSH
89723: LD_INT 23
89725: PUSH
89726: LD_INT 0
89728: PUSH
89729: EMPTY
89730: LIST
89731: LIST
89732: PUSH
89733: EMPTY
89734: LIST
89735: LIST
89736: PUSH
89737: EMPTY
89738: LIST
89739: LIST
89740: LIST
89741: PPUSH
89742: CALL_OW 69
89746: PUSH
89747: FOR_IN
89748: IFFALSE 89802
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
89750: LD_VAR 0 1
89754: PPUSH
89755: CALL_OW 257
89759: PUSH
89760: LD_INT 1
89762: PUSH
89763: LD_INT 2
89765: PUSH
89766: LD_INT 3
89768: PUSH
89769: LD_INT 4
89771: PUSH
89772: EMPTY
89773: LIST
89774: LIST
89775: LIST
89776: LIST
89777: IN
89778: IFFALSE 89800
// SetClass ( un , rand ( 1 , 4 ) ) ;
89780: LD_VAR 0 1
89784: PPUSH
89785: LD_INT 1
89787: PPUSH
89788: LD_INT 4
89790: PPUSH
89791: CALL_OW 12
89795: PPUSH
89796: CALL_OW 336
89800: GO 89747
89802: POP
89803: POP
// end ;
89804: PPOPN 1
89806: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
89807: LD_EXP 85
89811: PUSH
89812: LD_EXP 97
89816: AND
89817: IFFALSE 89896
89819: GO 89821
89821: DISABLE
89822: LD_INT 0
89824: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
89825: LD_ADDR_VAR 0 1
89829: PUSH
89830: LD_INT 22
89832: PUSH
89833: LD_OWVAR 2
89837: PUSH
89838: EMPTY
89839: LIST
89840: LIST
89841: PUSH
89842: LD_INT 21
89844: PUSH
89845: LD_INT 3
89847: PUSH
89848: EMPTY
89849: LIST
89850: LIST
89851: PUSH
89852: EMPTY
89853: LIST
89854: LIST
89855: PPUSH
89856: CALL_OW 69
89860: ST_TO_ADDR
// if not tmp then
89861: LD_VAR 0 1
89865: NOT
89866: IFFALSE 89870
// exit ;
89868: GO 89896
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
89870: LD_VAR 0 1
89874: PUSH
89875: LD_INT 1
89877: PPUSH
89878: LD_VAR 0 1
89882: PPUSH
89883: CALL_OW 12
89887: ARRAY
89888: PPUSH
89889: LD_INT 100
89891: PPUSH
89892: CALL_OW 234
// end ;
89896: PPOPN 1
89898: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
89899: LD_EXP 85
89903: PUSH
89904: LD_EXP 99
89908: AND
89909: IFFALSE 90007
89911: GO 89913
89913: DISABLE
89914: LD_INT 0
89916: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
89917: LD_ADDR_VAR 0 1
89921: PUSH
89922: LD_INT 22
89924: PUSH
89925: LD_OWVAR 2
89929: PUSH
89930: EMPTY
89931: LIST
89932: LIST
89933: PUSH
89934: LD_INT 21
89936: PUSH
89937: LD_INT 1
89939: PUSH
89940: EMPTY
89941: LIST
89942: LIST
89943: PUSH
89944: EMPTY
89945: LIST
89946: LIST
89947: PPUSH
89948: CALL_OW 69
89952: ST_TO_ADDR
// if not tmp then
89953: LD_VAR 0 1
89957: NOT
89958: IFFALSE 89962
// exit ;
89960: GO 90007
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
89962: LD_VAR 0 1
89966: PUSH
89967: LD_INT 1
89969: PPUSH
89970: LD_VAR 0 1
89974: PPUSH
89975: CALL_OW 12
89979: ARRAY
89980: PPUSH
89981: LD_INT 1
89983: PPUSH
89984: LD_INT 4
89986: PPUSH
89987: CALL_OW 12
89991: PPUSH
89992: LD_INT 3000
89994: PPUSH
89995: LD_INT 9000
89997: PPUSH
89998: CALL_OW 12
90002: PPUSH
90003: CALL_OW 492
// end ;
90007: PPOPN 1
90009: END
// every 0 0$1 trigger StreamModeActive and sDepot do
90010: LD_EXP 85
90014: PUSH
90015: LD_EXP 100
90019: AND
90020: IFFALSE 90040
90022: GO 90024
90024: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
90025: LD_INT 1
90027: PPUSH
90028: LD_OWVAR 2
90032: PPUSH
90033: LD_INT 0
90035: PPUSH
90036: CALL_OW 324
90040: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
90041: LD_EXP 85
90045: PUSH
90046: LD_EXP 101
90050: AND
90051: IFFALSE 90134
90053: GO 90055
90055: DISABLE
90056: LD_INT 0
90058: PPUSH
90059: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
90060: LD_ADDR_VAR 0 2
90064: PUSH
90065: LD_INT 22
90067: PUSH
90068: LD_OWVAR 2
90072: PUSH
90073: EMPTY
90074: LIST
90075: LIST
90076: PUSH
90077: LD_INT 21
90079: PUSH
90080: LD_INT 3
90082: PUSH
90083: EMPTY
90084: LIST
90085: LIST
90086: PUSH
90087: EMPTY
90088: LIST
90089: LIST
90090: PPUSH
90091: CALL_OW 69
90095: ST_TO_ADDR
// if not tmp then
90096: LD_VAR 0 2
90100: NOT
90101: IFFALSE 90105
// exit ;
90103: GO 90134
// for i in tmp do
90105: LD_ADDR_VAR 0 1
90109: PUSH
90110: LD_VAR 0 2
90114: PUSH
90115: FOR_IN
90116: IFFALSE 90132
// SetBLevel ( i , 10 ) ;
90118: LD_VAR 0 1
90122: PPUSH
90123: LD_INT 10
90125: PPUSH
90126: CALL_OW 241
90130: GO 90115
90132: POP
90133: POP
// end ;
90134: PPOPN 2
90136: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
90137: LD_EXP 85
90141: PUSH
90142: LD_EXP 102
90146: AND
90147: IFFALSE 90258
90149: GO 90151
90151: DISABLE
90152: LD_INT 0
90154: PPUSH
90155: PPUSH
90156: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
90157: LD_ADDR_VAR 0 3
90161: PUSH
90162: LD_INT 22
90164: PUSH
90165: LD_OWVAR 2
90169: PUSH
90170: EMPTY
90171: LIST
90172: LIST
90173: PUSH
90174: LD_INT 25
90176: PUSH
90177: LD_INT 1
90179: PUSH
90180: EMPTY
90181: LIST
90182: LIST
90183: PUSH
90184: EMPTY
90185: LIST
90186: LIST
90187: PPUSH
90188: CALL_OW 69
90192: ST_TO_ADDR
// if not tmp then
90193: LD_VAR 0 3
90197: NOT
90198: IFFALSE 90202
// exit ;
90200: GO 90258
// un := tmp [ rand ( 1 , tmp ) ] ;
90202: LD_ADDR_VAR 0 2
90206: PUSH
90207: LD_VAR 0 3
90211: PUSH
90212: LD_INT 1
90214: PPUSH
90215: LD_VAR 0 3
90219: PPUSH
90220: CALL_OW 12
90224: ARRAY
90225: ST_TO_ADDR
// if Crawls ( un ) then
90226: LD_VAR 0 2
90230: PPUSH
90231: CALL_OW 318
90235: IFFALSE 90246
// ComWalk ( un ) ;
90237: LD_VAR 0 2
90241: PPUSH
90242: CALL_OW 138
// SetClass ( un , class_sniper ) ;
90246: LD_VAR 0 2
90250: PPUSH
90251: LD_INT 5
90253: PPUSH
90254: CALL_OW 336
// end ;
90258: PPOPN 3
90260: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
90261: LD_EXP 85
90265: PUSH
90266: LD_EXP 103
90270: AND
90271: PUSH
90272: LD_OWVAR 67
90276: PUSH
90277: LD_INT 3
90279: LESS
90280: AND
90281: IFFALSE 90300
90283: GO 90285
90285: DISABLE
// Difficulty := Difficulty + 1 ;
90286: LD_ADDR_OWVAR 67
90290: PUSH
90291: LD_OWVAR 67
90295: PUSH
90296: LD_INT 1
90298: PLUS
90299: ST_TO_ADDR
90300: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
90301: LD_EXP 85
90305: PUSH
90306: LD_EXP 104
90310: AND
90311: IFFALSE 90414
90313: GO 90315
90315: DISABLE
90316: LD_INT 0
90318: PPUSH
// begin for i := 1 to 5 do
90319: LD_ADDR_VAR 0 1
90323: PUSH
90324: DOUBLE
90325: LD_INT 1
90327: DEC
90328: ST_TO_ADDR
90329: LD_INT 5
90331: PUSH
90332: FOR_TO
90333: IFFALSE 90412
// begin uc_nation := nation_nature ;
90335: LD_ADDR_OWVAR 21
90339: PUSH
90340: LD_INT 0
90342: ST_TO_ADDR
// uc_side := 0 ;
90343: LD_ADDR_OWVAR 20
90347: PUSH
90348: LD_INT 0
90350: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
90351: LD_ADDR_OWVAR 29
90355: PUSH
90356: LD_INT 12
90358: PUSH
90359: LD_INT 12
90361: PUSH
90362: EMPTY
90363: LIST
90364: LIST
90365: ST_TO_ADDR
// hc_agressivity := 20 ;
90366: LD_ADDR_OWVAR 35
90370: PUSH
90371: LD_INT 20
90373: ST_TO_ADDR
// hc_class := class_tiger ;
90374: LD_ADDR_OWVAR 28
90378: PUSH
90379: LD_INT 14
90381: ST_TO_ADDR
// hc_gallery :=  ;
90382: LD_ADDR_OWVAR 33
90386: PUSH
90387: LD_STRING 
90389: ST_TO_ADDR
// hc_name :=  ;
90390: LD_ADDR_OWVAR 26
90394: PUSH
90395: LD_STRING 
90397: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
90398: CALL_OW 44
90402: PPUSH
90403: LD_INT 0
90405: PPUSH
90406: CALL_OW 51
// end ;
90410: GO 90332
90412: POP
90413: POP
// end ;
90414: PPOPN 1
90416: END
// every 0 0$1 trigger StreamModeActive and sBomb do
90417: LD_EXP 85
90421: PUSH
90422: LD_EXP 105
90426: AND
90427: IFFALSE 90436
90429: GO 90431
90431: DISABLE
// StreamSibBomb ;
90432: CALL 90437 0 0
90436: END
// export function StreamSibBomb ; var i , x , y ; begin
90437: LD_INT 0
90439: PPUSH
90440: PPUSH
90441: PPUSH
90442: PPUSH
// result := false ;
90443: LD_ADDR_VAR 0 1
90447: PUSH
90448: LD_INT 0
90450: ST_TO_ADDR
// for i := 1 to 16 do
90451: LD_ADDR_VAR 0 2
90455: PUSH
90456: DOUBLE
90457: LD_INT 1
90459: DEC
90460: ST_TO_ADDR
90461: LD_INT 16
90463: PUSH
90464: FOR_TO
90465: IFFALSE 90664
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
90467: LD_ADDR_VAR 0 3
90471: PUSH
90472: LD_INT 10
90474: PUSH
90475: LD_INT 20
90477: PUSH
90478: LD_INT 30
90480: PUSH
90481: LD_INT 40
90483: PUSH
90484: LD_INT 50
90486: PUSH
90487: LD_INT 60
90489: PUSH
90490: LD_INT 70
90492: PUSH
90493: LD_INT 80
90495: PUSH
90496: LD_INT 90
90498: PUSH
90499: LD_INT 100
90501: PUSH
90502: LD_INT 110
90504: PUSH
90505: LD_INT 120
90507: PUSH
90508: LD_INT 130
90510: PUSH
90511: LD_INT 140
90513: PUSH
90514: LD_INT 150
90516: PUSH
90517: EMPTY
90518: LIST
90519: LIST
90520: LIST
90521: LIST
90522: LIST
90523: LIST
90524: LIST
90525: LIST
90526: LIST
90527: LIST
90528: LIST
90529: LIST
90530: LIST
90531: LIST
90532: LIST
90533: PUSH
90534: LD_INT 1
90536: PPUSH
90537: LD_INT 15
90539: PPUSH
90540: CALL_OW 12
90544: ARRAY
90545: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
90546: LD_ADDR_VAR 0 4
90550: PUSH
90551: LD_INT 10
90553: PUSH
90554: LD_INT 20
90556: PUSH
90557: LD_INT 30
90559: PUSH
90560: LD_INT 40
90562: PUSH
90563: LD_INT 50
90565: PUSH
90566: LD_INT 60
90568: PUSH
90569: LD_INT 70
90571: PUSH
90572: LD_INT 80
90574: PUSH
90575: LD_INT 90
90577: PUSH
90578: LD_INT 100
90580: PUSH
90581: LD_INT 110
90583: PUSH
90584: LD_INT 120
90586: PUSH
90587: LD_INT 130
90589: PUSH
90590: LD_INT 140
90592: PUSH
90593: LD_INT 150
90595: PUSH
90596: EMPTY
90597: LIST
90598: LIST
90599: LIST
90600: LIST
90601: LIST
90602: LIST
90603: LIST
90604: LIST
90605: LIST
90606: LIST
90607: LIST
90608: LIST
90609: LIST
90610: LIST
90611: LIST
90612: PUSH
90613: LD_INT 1
90615: PPUSH
90616: LD_INT 15
90618: PPUSH
90619: CALL_OW 12
90623: ARRAY
90624: ST_TO_ADDR
// if ValidHex ( x , y ) then
90625: LD_VAR 0 3
90629: PPUSH
90630: LD_VAR 0 4
90634: PPUSH
90635: CALL_OW 488
90639: IFFALSE 90662
// begin result := [ x , y ] ;
90641: LD_ADDR_VAR 0 1
90645: PUSH
90646: LD_VAR 0 3
90650: PUSH
90651: LD_VAR 0 4
90655: PUSH
90656: EMPTY
90657: LIST
90658: LIST
90659: ST_TO_ADDR
// break ;
90660: GO 90664
// end ; end ;
90662: GO 90464
90664: POP
90665: POP
// if result then
90666: LD_VAR 0 1
90670: IFFALSE 90730
// begin ToLua ( playSibBomb() ) ;
90672: LD_STRING playSibBomb()
90674: PPUSH
90675: CALL_OW 559
// wait ( 0 0$14 ) ;
90679: LD_INT 490
90681: PPUSH
90682: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
90686: LD_VAR 0 1
90690: PUSH
90691: LD_INT 1
90693: ARRAY
90694: PPUSH
90695: LD_VAR 0 1
90699: PUSH
90700: LD_INT 2
90702: ARRAY
90703: PPUSH
90704: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
90708: LD_VAR 0 1
90712: PUSH
90713: LD_INT 1
90715: ARRAY
90716: PPUSH
90717: LD_VAR 0 1
90721: PUSH
90722: LD_INT 2
90724: ARRAY
90725: PPUSH
90726: CALL_OW 429
// end ; end ;
90730: LD_VAR 0 1
90734: RET
// every 0 0$1 trigger StreamModeActive and sReset do
90735: LD_EXP 85
90739: PUSH
90740: LD_EXP 107
90744: AND
90745: IFFALSE 90757
90747: GO 90749
90749: DISABLE
// YouLost (  ) ;
90750: LD_STRING 
90752: PPUSH
90753: CALL_OW 104
90757: END
// every 0 0$1 trigger StreamModeActive and sFog do
90758: LD_EXP 85
90762: PUSH
90763: LD_EXP 106
90767: AND
90768: IFFALSE 90782
90770: GO 90772
90772: DISABLE
// FogOff ( your_side ) ;
90773: LD_OWVAR 2
90777: PPUSH
90778: CALL_OW 344
90782: END
// every 0 0$1 trigger StreamModeActive and sSun do
90783: LD_EXP 85
90787: PUSH
90788: LD_EXP 108
90792: AND
90793: IFFALSE 90821
90795: GO 90797
90797: DISABLE
// begin solar_recharge_percent := 0 ;
90798: LD_ADDR_OWVAR 79
90802: PUSH
90803: LD_INT 0
90805: ST_TO_ADDR
// wait ( 5 5$00 ) ;
90806: LD_INT 10500
90808: PPUSH
90809: CALL_OW 67
// solar_recharge_percent := 100 ;
90813: LD_ADDR_OWVAR 79
90817: PUSH
90818: LD_INT 100
90820: ST_TO_ADDR
// end ;
90821: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
90822: LD_EXP 85
90826: PUSH
90827: LD_EXP 109
90831: AND
90832: IFFALSE 91071
90834: GO 90836
90836: DISABLE
90837: LD_INT 0
90839: PPUSH
90840: PPUSH
90841: PPUSH
// begin tmp := [ ] ;
90842: LD_ADDR_VAR 0 3
90846: PUSH
90847: EMPTY
90848: ST_TO_ADDR
// for i := 1 to 6 do
90849: LD_ADDR_VAR 0 1
90853: PUSH
90854: DOUBLE
90855: LD_INT 1
90857: DEC
90858: ST_TO_ADDR
90859: LD_INT 6
90861: PUSH
90862: FOR_TO
90863: IFFALSE 90968
// begin uc_nation := nation_nature ;
90865: LD_ADDR_OWVAR 21
90869: PUSH
90870: LD_INT 0
90872: ST_TO_ADDR
// uc_side := 0 ;
90873: LD_ADDR_OWVAR 20
90877: PUSH
90878: LD_INT 0
90880: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
90881: LD_ADDR_OWVAR 29
90885: PUSH
90886: LD_INT 12
90888: PUSH
90889: LD_INT 12
90891: PUSH
90892: EMPTY
90893: LIST
90894: LIST
90895: ST_TO_ADDR
// hc_agressivity := 20 ;
90896: LD_ADDR_OWVAR 35
90900: PUSH
90901: LD_INT 20
90903: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
90904: LD_ADDR_OWVAR 28
90908: PUSH
90909: LD_INT 17
90911: ST_TO_ADDR
// hc_gallery :=  ;
90912: LD_ADDR_OWVAR 33
90916: PUSH
90917: LD_STRING 
90919: ST_TO_ADDR
// hc_name :=  ;
90920: LD_ADDR_OWVAR 26
90924: PUSH
90925: LD_STRING 
90927: ST_TO_ADDR
// un := CreateHuman ;
90928: LD_ADDR_VAR 0 2
90932: PUSH
90933: CALL_OW 44
90937: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
90938: LD_VAR 0 2
90942: PPUSH
90943: LD_INT 1
90945: PPUSH
90946: CALL_OW 51
// tmp := tmp ^ un ;
90950: LD_ADDR_VAR 0 3
90954: PUSH
90955: LD_VAR 0 3
90959: PUSH
90960: LD_VAR 0 2
90964: ADD
90965: ST_TO_ADDR
// end ;
90966: GO 90862
90968: POP
90969: POP
// repeat wait ( 0 0$1 ) ;
90970: LD_INT 35
90972: PPUSH
90973: CALL_OW 67
// for un in tmp do
90977: LD_ADDR_VAR 0 2
90981: PUSH
90982: LD_VAR 0 3
90986: PUSH
90987: FOR_IN
90988: IFFALSE 91062
// begin if IsDead ( un ) then
90990: LD_VAR 0 2
90994: PPUSH
90995: CALL_OW 301
90999: IFFALSE 91019
// begin tmp := tmp diff un ;
91001: LD_ADDR_VAR 0 3
91005: PUSH
91006: LD_VAR 0 3
91010: PUSH
91011: LD_VAR 0 2
91015: DIFF
91016: ST_TO_ADDR
// continue ;
91017: GO 90987
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
91019: LD_VAR 0 2
91023: PPUSH
91024: LD_INT 3
91026: PUSH
91027: LD_INT 22
91029: PUSH
91030: LD_INT 0
91032: PUSH
91033: EMPTY
91034: LIST
91035: LIST
91036: PUSH
91037: EMPTY
91038: LIST
91039: LIST
91040: PPUSH
91041: CALL_OW 69
91045: PPUSH
91046: LD_VAR 0 2
91050: PPUSH
91051: CALL_OW 74
91055: PPUSH
91056: CALL_OW 115
// end ;
91060: GO 90987
91062: POP
91063: POP
// until not tmp ;
91064: LD_VAR 0 3
91068: NOT
91069: IFFALSE 90970
// end ;
91071: PPOPN 3
91073: END
// every 0 0$1 trigger StreamModeActive and sTroll do
91074: LD_EXP 85
91078: PUSH
91079: LD_EXP 110
91083: AND
91084: IFFALSE 91138
91086: GO 91088
91088: DISABLE
// begin ToLua ( displayTroll(); ) ;
91089: LD_STRING displayTroll();
91091: PPUSH
91092: CALL_OW 559
// wait ( 3 3$00 ) ;
91096: LD_INT 6300
91098: PPUSH
91099: CALL_OW 67
// ToLua ( hideTroll(); ) ;
91103: LD_STRING hideTroll();
91105: PPUSH
91106: CALL_OW 559
// wait ( 1 1$00 ) ;
91110: LD_INT 2100
91112: PPUSH
91113: CALL_OW 67
// ToLua ( displayTroll(); ) ;
91117: LD_STRING displayTroll();
91119: PPUSH
91120: CALL_OW 559
// wait ( 1 1$00 ) ;
91124: LD_INT 2100
91126: PPUSH
91127: CALL_OW 67
// ToLua ( hideTroll(); ) ;
91131: LD_STRING hideTroll();
91133: PPUSH
91134: CALL_OW 559
// end ;
91138: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
91139: LD_EXP 85
91143: PUSH
91144: LD_EXP 111
91148: AND
91149: IFFALSE 91212
91151: GO 91153
91153: DISABLE
91154: LD_INT 0
91156: PPUSH
// begin p := 0 ;
91157: LD_ADDR_VAR 0 1
91161: PUSH
91162: LD_INT 0
91164: ST_TO_ADDR
// repeat game_speed := 1 ;
91165: LD_ADDR_OWVAR 65
91169: PUSH
91170: LD_INT 1
91172: ST_TO_ADDR
// wait ( 0 0$1 ) ;
91173: LD_INT 35
91175: PPUSH
91176: CALL_OW 67
// p := p + 1 ;
91180: LD_ADDR_VAR 0 1
91184: PUSH
91185: LD_VAR 0 1
91189: PUSH
91190: LD_INT 1
91192: PLUS
91193: ST_TO_ADDR
// until p >= 60 ;
91194: LD_VAR 0 1
91198: PUSH
91199: LD_INT 60
91201: GREATEREQUAL
91202: IFFALSE 91165
// game_speed := 4 ;
91204: LD_ADDR_OWVAR 65
91208: PUSH
91209: LD_INT 4
91211: ST_TO_ADDR
// end ;
91212: PPOPN 1
91214: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
91215: LD_EXP 85
91219: PUSH
91220: LD_EXP 112
91224: AND
91225: IFFALSE 91371
91227: GO 91229
91229: DISABLE
91230: LD_INT 0
91232: PPUSH
91233: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
91234: LD_ADDR_VAR 0 1
91238: PUSH
91239: LD_INT 22
91241: PUSH
91242: LD_OWVAR 2
91246: PUSH
91247: EMPTY
91248: LIST
91249: LIST
91250: PUSH
91251: LD_INT 2
91253: PUSH
91254: LD_INT 30
91256: PUSH
91257: LD_INT 0
91259: PUSH
91260: EMPTY
91261: LIST
91262: LIST
91263: PUSH
91264: LD_INT 30
91266: PUSH
91267: LD_INT 1
91269: PUSH
91270: EMPTY
91271: LIST
91272: LIST
91273: PUSH
91274: EMPTY
91275: LIST
91276: LIST
91277: LIST
91278: PUSH
91279: EMPTY
91280: LIST
91281: LIST
91282: PPUSH
91283: CALL_OW 69
91287: ST_TO_ADDR
// if not depot then
91288: LD_VAR 0 1
91292: NOT
91293: IFFALSE 91297
// exit ;
91295: GO 91371
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
91297: LD_ADDR_VAR 0 2
91301: PUSH
91302: LD_VAR 0 1
91306: PUSH
91307: LD_INT 1
91309: PPUSH
91310: LD_VAR 0 1
91314: PPUSH
91315: CALL_OW 12
91319: ARRAY
91320: PPUSH
91321: CALL_OW 274
91325: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
91326: LD_VAR 0 2
91330: PPUSH
91331: LD_INT 1
91333: PPUSH
91334: LD_INT 0
91336: PPUSH
91337: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
91341: LD_VAR 0 2
91345: PPUSH
91346: LD_INT 2
91348: PPUSH
91349: LD_INT 0
91351: PPUSH
91352: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
91356: LD_VAR 0 2
91360: PPUSH
91361: LD_INT 3
91363: PPUSH
91364: LD_INT 0
91366: PPUSH
91367: CALL_OW 277
// end ;
91371: PPOPN 2
91373: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
91374: LD_EXP 85
91378: PUSH
91379: LD_EXP 113
91383: AND
91384: IFFALSE 91481
91386: GO 91388
91388: DISABLE
91389: LD_INT 0
91391: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
91392: LD_ADDR_VAR 0 1
91396: PUSH
91397: LD_INT 22
91399: PUSH
91400: LD_OWVAR 2
91404: PUSH
91405: EMPTY
91406: LIST
91407: LIST
91408: PUSH
91409: LD_INT 21
91411: PUSH
91412: LD_INT 1
91414: PUSH
91415: EMPTY
91416: LIST
91417: LIST
91418: PUSH
91419: LD_INT 3
91421: PUSH
91422: LD_INT 23
91424: PUSH
91425: LD_INT 0
91427: PUSH
91428: EMPTY
91429: LIST
91430: LIST
91431: PUSH
91432: EMPTY
91433: LIST
91434: LIST
91435: PUSH
91436: EMPTY
91437: LIST
91438: LIST
91439: LIST
91440: PPUSH
91441: CALL_OW 69
91445: ST_TO_ADDR
// if not tmp then
91446: LD_VAR 0 1
91450: NOT
91451: IFFALSE 91455
// exit ;
91453: GO 91481
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
91455: LD_VAR 0 1
91459: PUSH
91460: LD_INT 1
91462: PPUSH
91463: LD_VAR 0 1
91467: PPUSH
91468: CALL_OW 12
91472: ARRAY
91473: PPUSH
91474: LD_INT 200
91476: PPUSH
91477: CALL_OW 234
// end ;
91481: PPOPN 1
91483: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
91484: LD_EXP 85
91488: PUSH
91489: LD_EXP 114
91493: AND
91494: IFFALSE 91573
91496: GO 91498
91498: DISABLE
91499: LD_INT 0
91501: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
91502: LD_ADDR_VAR 0 1
91506: PUSH
91507: LD_INT 22
91509: PUSH
91510: LD_OWVAR 2
91514: PUSH
91515: EMPTY
91516: LIST
91517: LIST
91518: PUSH
91519: LD_INT 21
91521: PUSH
91522: LD_INT 2
91524: PUSH
91525: EMPTY
91526: LIST
91527: LIST
91528: PUSH
91529: EMPTY
91530: LIST
91531: LIST
91532: PPUSH
91533: CALL_OW 69
91537: ST_TO_ADDR
// if not tmp then
91538: LD_VAR 0 1
91542: NOT
91543: IFFALSE 91547
// exit ;
91545: GO 91573
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
91547: LD_VAR 0 1
91551: PUSH
91552: LD_INT 1
91554: PPUSH
91555: LD_VAR 0 1
91559: PPUSH
91560: CALL_OW 12
91564: ARRAY
91565: PPUSH
91566: LD_INT 60
91568: PPUSH
91569: CALL_OW 234
// end ;
91573: PPOPN 1
91575: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
91576: LD_EXP 85
91580: PUSH
91581: LD_EXP 115
91585: AND
91586: IFFALSE 91685
91588: GO 91590
91590: DISABLE
91591: LD_INT 0
91593: PPUSH
91594: PPUSH
// begin enable ;
91595: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
91596: LD_ADDR_VAR 0 1
91600: PUSH
91601: LD_INT 22
91603: PUSH
91604: LD_OWVAR 2
91608: PUSH
91609: EMPTY
91610: LIST
91611: LIST
91612: PUSH
91613: LD_INT 61
91615: PUSH
91616: EMPTY
91617: LIST
91618: PUSH
91619: LD_INT 33
91621: PUSH
91622: LD_INT 2
91624: PUSH
91625: EMPTY
91626: LIST
91627: LIST
91628: PUSH
91629: EMPTY
91630: LIST
91631: LIST
91632: LIST
91633: PPUSH
91634: CALL_OW 69
91638: ST_TO_ADDR
// if not tmp then
91639: LD_VAR 0 1
91643: NOT
91644: IFFALSE 91648
// exit ;
91646: GO 91685
// for i in tmp do
91648: LD_ADDR_VAR 0 2
91652: PUSH
91653: LD_VAR 0 1
91657: PUSH
91658: FOR_IN
91659: IFFALSE 91683
// if IsControledBy ( i ) then
91661: LD_VAR 0 2
91665: PPUSH
91666: CALL_OW 312
91670: IFFALSE 91681
// ComUnlink ( i ) ;
91672: LD_VAR 0 2
91676: PPUSH
91677: CALL_OW 136
91681: GO 91658
91683: POP
91684: POP
// end ;
91685: PPOPN 2
91687: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
91688: LD_EXP 85
91692: PUSH
91693: LD_EXP 116
91697: AND
91698: IFFALSE 91838
91700: GO 91702
91702: DISABLE
91703: LD_INT 0
91705: PPUSH
91706: PPUSH
// begin ToLua ( displayPowell(); ) ;
91707: LD_STRING displayPowell();
91709: PPUSH
91710: CALL_OW 559
// uc_side := 0 ;
91714: LD_ADDR_OWVAR 20
91718: PUSH
91719: LD_INT 0
91721: ST_TO_ADDR
// uc_nation := 2 ;
91722: LD_ADDR_OWVAR 21
91726: PUSH
91727: LD_INT 2
91729: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
91730: LD_ADDR_OWVAR 37
91734: PUSH
91735: LD_INT 14
91737: ST_TO_ADDR
// vc_engine := engine_siberite ;
91738: LD_ADDR_OWVAR 39
91742: PUSH
91743: LD_INT 3
91745: ST_TO_ADDR
// vc_control := control_apeman ;
91746: LD_ADDR_OWVAR 38
91750: PUSH
91751: LD_INT 5
91753: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
91754: LD_ADDR_OWVAR 40
91758: PUSH
91759: LD_INT 29
91761: ST_TO_ADDR
// un := CreateVehicle ;
91762: LD_ADDR_VAR 0 2
91766: PUSH
91767: CALL_OW 45
91771: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
91772: LD_VAR 0 2
91776: PPUSH
91777: LD_INT 1
91779: PPUSH
91780: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
91784: LD_INT 35
91786: PPUSH
91787: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
91791: LD_VAR 0 2
91795: PPUSH
91796: LD_INT 22
91798: PUSH
91799: LD_OWVAR 2
91803: PUSH
91804: EMPTY
91805: LIST
91806: LIST
91807: PPUSH
91808: CALL_OW 69
91812: PPUSH
91813: LD_VAR 0 2
91817: PPUSH
91818: CALL_OW 74
91822: PPUSH
91823: CALL_OW 115
// until IsDead ( un ) ;
91827: LD_VAR 0 2
91831: PPUSH
91832: CALL_OW 301
91836: IFFALSE 91784
// end ;
91838: PPOPN 2
91840: END
// every 0 0$1 trigger StreamModeActive and sStu do
91841: LD_EXP 85
91845: PUSH
91846: LD_EXP 124
91850: AND
91851: IFFALSE 91867
91853: GO 91855
91855: DISABLE
// begin ToLua ( displayStucuk(); ) ;
91856: LD_STRING displayStucuk();
91858: PPUSH
91859: CALL_OW 559
// ResetFog ;
91863: CALL_OW 335
// end ;
91867: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
91868: LD_EXP 85
91872: PUSH
91873: LD_EXP 117
91877: AND
91878: IFFALSE 92019
91880: GO 91882
91882: DISABLE
91883: LD_INT 0
91885: PPUSH
91886: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
91887: LD_ADDR_VAR 0 2
91891: PUSH
91892: LD_INT 22
91894: PUSH
91895: LD_OWVAR 2
91899: PUSH
91900: EMPTY
91901: LIST
91902: LIST
91903: PUSH
91904: LD_INT 21
91906: PUSH
91907: LD_INT 1
91909: PUSH
91910: EMPTY
91911: LIST
91912: LIST
91913: PUSH
91914: EMPTY
91915: LIST
91916: LIST
91917: PPUSH
91918: CALL_OW 69
91922: ST_TO_ADDR
// if not tmp then
91923: LD_VAR 0 2
91927: NOT
91928: IFFALSE 91932
// exit ;
91930: GO 92019
// un := tmp [ rand ( 1 , tmp ) ] ;
91932: LD_ADDR_VAR 0 1
91936: PUSH
91937: LD_VAR 0 2
91941: PUSH
91942: LD_INT 1
91944: PPUSH
91945: LD_VAR 0 2
91949: PPUSH
91950: CALL_OW 12
91954: ARRAY
91955: ST_TO_ADDR
// SetSide ( un , 0 ) ;
91956: LD_VAR 0 1
91960: PPUSH
91961: LD_INT 0
91963: PPUSH
91964: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
91968: LD_VAR 0 1
91972: PPUSH
91973: LD_OWVAR 3
91977: PUSH
91978: LD_VAR 0 1
91982: DIFF
91983: PPUSH
91984: LD_VAR 0 1
91988: PPUSH
91989: CALL_OW 74
91993: PPUSH
91994: CALL_OW 115
// wait ( 0 0$20 ) ;
91998: LD_INT 700
92000: PPUSH
92001: CALL_OW 67
// SetSide ( un , your_side ) ;
92005: LD_VAR 0 1
92009: PPUSH
92010: LD_OWVAR 2
92014: PPUSH
92015: CALL_OW 235
// end ;
92019: PPOPN 2
92021: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
92022: LD_EXP 85
92026: PUSH
92027: LD_EXP 118
92031: AND
92032: IFFALSE 92138
92034: GO 92036
92036: DISABLE
92037: LD_INT 0
92039: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
92040: LD_ADDR_VAR 0 1
92044: PUSH
92045: LD_INT 22
92047: PUSH
92048: LD_OWVAR 2
92052: PUSH
92053: EMPTY
92054: LIST
92055: LIST
92056: PUSH
92057: LD_INT 2
92059: PUSH
92060: LD_INT 30
92062: PUSH
92063: LD_INT 0
92065: PUSH
92066: EMPTY
92067: LIST
92068: LIST
92069: PUSH
92070: LD_INT 30
92072: PUSH
92073: LD_INT 1
92075: PUSH
92076: EMPTY
92077: LIST
92078: LIST
92079: PUSH
92080: EMPTY
92081: LIST
92082: LIST
92083: LIST
92084: PUSH
92085: EMPTY
92086: LIST
92087: LIST
92088: PPUSH
92089: CALL_OW 69
92093: ST_TO_ADDR
// if not depot then
92094: LD_VAR 0 1
92098: NOT
92099: IFFALSE 92103
// exit ;
92101: GO 92138
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
92103: LD_VAR 0 1
92107: PUSH
92108: LD_INT 1
92110: ARRAY
92111: PPUSH
92112: CALL_OW 250
92116: PPUSH
92117: LD_VAR 0 1
92121: PUSH
92122: LD_INT 1
92124: ARRAY
92125: PPUSH
92126: CALL_OW 251
92130: PPUSH
92131: LD_INT 70
92133: PPUSH
92134: CALL_OW 495
// end ;
92138: PPOPN 1
92140: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
92141: LD_EXP 85
92145: PUSH
92146: LD_EXP 119
92150: AND
92151: IFFALSE 92362
92153: GO 92155
92155: DISABLE
92156: LD_INT 0
92158: PPUSH
92159: PPUSH
92160: PPUSH
92161: PPUSH
92162: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
92163: LD_ADDR_VAR 0 5
92167: PUSH
92168: LD_INT 22
92170: PUSH
92171: LD_OWVAR 2
92175: PUSH
92176: EMPTY
92177: LIST
92178: LIST
92179: PUSH
92180: LD_INT 21
92182: PUSH
92183: LD_INT 1
92185: PUSH
92186: EMPTY
92187: LIST
92188: LIST
92189: PUSH
92190: EMPTY
92191: LIST
92192: LIST
92193: PPUSH
92194: CALL_OW 69
92198: ST_TO_ADDR
// if not tmp then
92199: LD_VAR 0 5
92203: NOT
92204: IFFALSE 92208
// exit ;
92206: GO 92362
// for i in tmp do
92208: LD_ADDR_VAR 0 1
92212: PUSH
92213: LD_VAR 0 5
92217: PUSH
92218: FOR_IN
92219: IFFALSE 92360
// begin d := rand ( 0 , 5 ) ;
92221: LD_ADDR_VAR 0 4
92225: PUSH
92226: LD_INT 0
92228: PPUSH
92229: LD_INT 5
92231: PPUSH
92232: CALL_OW 12
92236: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
92237: LD_ADDR_VAR 0 2
92241: PUSH
92242: LD_VAR 0 1
92246: PPUSH
92247: CALL_OW 250
92251: PPUSH
92252: LD_VAR 0 4
92256: PPUSH
92257: LD_INT 3
92259: PPUSH
92260: LD_INT 12
92262: PPUSH
92263: CALL_OW 12
92267: PPUSH
92268: CALL_OW 272
92272: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
92273: LD_ADDR_VAR 0 3
92277: PUSH
92278: LD_VAR 0 1
92282: PPUSH
92283: CALL_OW 251
92287: PPUSH
92288: LD_VAR 0 4
92292: PPUSH
92293: LD_INT 3
92295: PPUSH
92296: LD_INT 12
92298: PPUSH
92299: CALL_OW 12
92303: PPUSH
92304: CALL_OW 273
92308: ST_TO_ADDR
// if ValidHex ( x , y ) then
92309: LD_VAR 0 2
92313: PPUSH
92314: LD_VAR 0 3
92318: PPUSH
92319: CALL_OW 488
92323: IFFALSE 92358
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
92325: LD_VAR 0 1
92329: PPUSH
92330: LD_VAR 0 2
92334: PPUSH
92335: LD_VAR 0 3
92339: PPUSH
92340: LD_INT 3
92342: PPUSH
92343: LD_INT 6
92345: PPUSH
92346: CALL_OW 12
92350: PPUSH
92351: LD_INT 1
92353: PPUSH
92354: CALL_OW 483
// end ;
92358: GO 92218
92360: POP
92361: POP
// end ;
92362: PPOPN 5
92364: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
92365: LD_EXP 85
92369: PUSH
92370: LD_EXP 120
92374: AND
92375: IFFALSE 92469
92377: GO 92379
92379: DISABLE
92380: LD_INT 0
92382: PPUSH
92383: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
92384: LD_ADDR_VAR 0 2
92388: PUSH
92389: LD_INT 22
92391: PUSH
92392: LD_OWVAR 2
92396: PUSH
92397: EMPTY
92398: LIST
92399: LIST
92400: PUSH
92401: LD_INT 32
92403: PUSH
92404: LD_INT 1
92406: PUSH
92407: EMPTY
92408: LIST
92409: LIST
92410: PUSH
92411: LD_INT 21
92413: PUSH
92414: LD_INT 2
92416: PUSH
92417: EMPTY
92418: LIST
92419: LIST
92420: PUSH
92421: EMPTY
92422: LIST
92423: LIST
92424: LIST
92425: PPUSH
92426: CALL_OW 69
92430: ST_TO_ADDR
// if not tmp then
92431: LD_VAR 0 2
92435: NOT
92436: IFFALSE 92440
// exit ;
92438: GO 92469
// for i in tmp do
92440: LD_ADDR_VAR 0 1
92444: PUSH
92445: LD_VAR 0 2
92449: PUSH
92450: FOR_IN
92451: IFFALSE 92467
// SetFuel ( i , 0 ) ;
92453: LD_VAR 0 1
92457: PPUSH
92458: LD_INT 0
92460: PPUSH
92461: CALL_OW 240
92465: GO 92450
92467: POP
92468: POP
// end ;
92469: PPOPN 2
92471: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
92472: LD_EXP 85
92476: PUSH
92477: LD_EXP 121
92481: AND
92482: IFFALSE 92548
92484: GO 92486
92486: DISABLE
92487: LD_INT 0
92489: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
92490: LD_ADDR_VAR 0 1
92494: PUSH
92495: LD_INT 22
92497: PUSH
92498: LD_OWVAR 2
92502: PUSH
92503: EMPTY
92504: LIST
92505: LIST
92506: PUSH
92507: LD_INT 30
92509: PUSH
92510: LD_INT 29
92512: PUSH
92513: EMPTY
92514: LIST
92515: LIST
92516: PUSH
92517: EMPTY
92518: LIST
92519: LIST
92520: PPUSH
92521: CALL_OW 69
92525: ST_TO_ADDR
// if not tmp then
92526: LD_VAR 0 1
92530: NOT
92531: IFFALSE 92535
// exit ;
92533: GO 92548
// DestroyUnit ( tmp [ 1 ] ) ;
92535: LD_VAR 0 1
92539: PUSH
92540: LD_INT 1
92542: ARRAY
92543: PPUSH
92544: CALL_OW 65
// end ;
92548: PPOPN 1
92550: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
92551: LD_EXP 85
92555: PUSH
92556: LD_EXP 123
92560: AND
92561: IFFALSE 92690
92563: GO 92565
92565: DISABLE
92566: LD_INT 0
92568: PPUSH
// begin uc_side := 0 ;
92569: LD_ADDR_OWVAR 20
92573: PUSH
92574: LD_INT 0
92576: ST_TO_ADDR
// uc_nation := nation_arabian ;
92577: LD_ADDR_OWVAR 21
92581: PUSH
92582: LD_INT 2
92584: ST_TO_ADDR
// hc_gallery :=  ;
92585: LD_ADDR_OWVAR 33
92589: PUSH
92590: LD_STRING 
92592: ST_TO_ADDR
// hc_name :=  ;
92593: LD_ADDR_OWVAR 26
92597: PUSH
92598: LD_STRING 
92600: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
92601: LD_INT 1
92603: PPUSH
92604: LD_INT 11
92606: PPUSH
92607: LD_INT 10
92609: PPUSH
92610: CALL_OW 380
// un := CreateHuman ;
92614: LD_ADDR_VAR 0 1
92618: PUSH
92619: CALL_OW 44
92623: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
92624: LD_VAR 0 1
92628: PPUSH
92629: LD_INT 1
92631: PPUSH
92632: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
92636: LD_INT 35
92638: PPUSH
92639: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
92643: LD_VAR 0 1
92647: PPUSH
92648: LD_INT 22
92650: PUSH
92651: LD_OWVAR 2
92655: PUSH
92656: EMPTY
92657: LIST
92658: LIST
92659: PPUSH
92660: CALL_OW 69
92664: PPUSH
92665: LD_VAR 0 1
92669: PPUSH
92670: CALL_OW 74
92674: PPUSH
92675: CALL_OW 115
// until IsDead ( un ) ;
92679: LD_VAR 0 1
92683: PPUSH
92684: CALL_OW 301
92688: IFFALSE 92636
// end ;
92690: PPOPN 1
92692: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
92693: LD_EXP 85
92697: PUSH
92698: LD_EXP 125
92702: AND
92703: IFFALSE 92715
92705: GO 92707
92707: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
92708: LD_STRING earthquake(getX(game), 0, 32)
92710: PPUSH
92711: CALL_OW 559
92715: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
92716: LD_EXP 85
92720: PUSH
92721: LD_EXP 126
92725: AND
92726: IFFALSE 92817
92728: GO 92730
92730: DISABLE
92731: LD_INT 0
92733: PPUSH
// begin enable ;
92734: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
92735: LD_ADDR_VAR 0 1
92739: PUSH
92740: LD_INT 22
92742: PUSH
92743: LD_OWVAR 2
92747: PUSH
92748: EMPTY
92749: LIST
92750: LIST
92751: PUSH
92752: LD_INT 21
92754: PUSH
92755: LD_INT 2
92757: PUSH
92758: EMPTY
92759: LIST
92760: LIST
92761: PUSH
92762: LD_INT 33
92764: PUSH
92765: LD_INT 3
92767: PUSH
92768: EMPTY
92769: LIST
92770: LIST
92771: PUSH
92772: EMPTY
92773: LIST
92774: LIST
92775: LIST
92776: PPUSH
92777: CALL_OW 69
92781: ST_TO_ADDR
// if not tmp then
92782: LD_VAR 0 1
92786: NOT
92787: IFFALSE 92791
// exit ;
92789: GO 92817
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
92791: LD_VAR 0 1
92795: PUSH
92796: LD_INT 1
92798: PPUSH
92799: LD_VAR 0 1
92803: PPUSH
92804: CALL_OW 12
92808: ARRAY
92809: PPUSH
92810: LD_INT 1
92812: PPUSH
92813: CALL_OW 234
// end ;
92817: PPOPN 1
92819: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
92820: LD_EXP 85
92824: PUSH
92825: LD_EXP 127
92829: AND
92830: IFFALSE 92971
92832: GO 92834
92834: DISABLE
92835: LD_INT 0
92837: PPUSH
92838: PPUSH
92839: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
92840: LD_ADDR_VAR 0 3
92844: PUSH
92845: LD_INT 22
92847: PUSH
92848: LD_OWVAR 2
92852: PUSH
92853: EMPTY
92854: LIST
92855: LIST
92856: PUSH
92857: LD_INT 25
92859: PUSH
92860: LD_INT 1
92862: PUSH
92863: EMPTY
92864: LIST
92865: LIST
92866: PUSH
92867: EMPTY
92868: LIST
92869: LIST
92870: PPUSH
92871: CALL_OW 69
92875: ST_TO_ADDR
// if not tmp then
92876: LD_VAR 0 3
92880: NOT
92881: IFFALSE 92885
// exit ;
92883: GO 92971
// un := tmp [ rand ( 1 , tmp ) ] ;
92885: LD_ADDR_VAR 0 2
92889: PUSH
92890: LD_VAR 0 3
92894: PUSH
92895: LD_INT 1
92897: PPUSH
92898: LD_VAR 0 3
92902: PPUSH
92903: CALL_OW 12
92907: ARRAY
92908: ST_TO_ADDR
// if Crawls ( un ) then
92909: LD_VAR 0 2
92913: PPUSH
92914: CALL_OW 318
92918: IFFALSE 92929
// ComWalk ( un ) ;
92920: LD_VAR 0 2
92924: PPUSH
92925: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
92929: LD_VAR 0 2
92933: PPUSH
92934: LD_INT 9
92936: PPUSH
92937: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
92941: LD_INT 28
92943: PPUSH
92944: LD_OWVAR 2
92948: PPUSH
92949: LD_INT 2
92951: PPUSH
92952: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
92956: LD_INT 29
92958: PPUSH
92959: LD_OWVAR 2
92963: PPUSH
92964: LD_INT 2
92966: PPUSH
92967: CALL_OW 322
// end ;
92971: PPOPN 3
92973: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
92974: LD_EXP 85
92978: PUSH
92979: LD_EXP 128
92983: AND
92984: IFFALSE 93095
92986: GO 92988
92988: DISABLE
92989: LD_INT 0
92991: PPUSH
92992: PPUSH
92993: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
92994: LD_ADDR_VAR 0 3
92998: PUSH
92999: LD_INT 22
93001: PUSH
93002: LD_OWVAR 2
93006: PUSH
93007: EMPTY
93008: LIST
93009: LIST
93010: PUSH
93011: LD_INT 25
93013: PUSH
93014: LD_INT 1
93016: PUSH
93017: EMPTY
93018: LIST
93019: LIST
93020: PUSH
93021: EMPTY
93022: LIST
93023: LIST
93024: PPUSH
93025: CALL_OW 69
93029: ST_TO_ADDR
// if not tmp then
93030: LD_VAR 0 3
93034: NOT
93035: IFFALSE 93039
// exit ;
93037: GO 93095
// un := tmp [ rand ( 1 , tmp ) ] ;
93039: LD_ADDR_VAR 0 2
93043: PUSH
93044: LD_VAR 0 3
93048: PUSH
93049: LD_INT 1
93051: PPUSH
93052: LD_VAR 0 3
93056: PPUSH
93057: CALL_OW 12
93061: ARRAY
93062: ST_TO_ADDR
// if Crawls ( un ) then
93063: LD_VAR 0 2
93067: PPUSH
93068: CALL_OW 318
93072: IFFALSE 93083
// ComWalk ( un ) ;
93074: LD_VAR 0 2
93078: PPUSH
93079: CALL_OW 138
// SetClass ( un , class_mortar ) ;
93083: LD_VAR 0 2
93087: PPUSH
93088: LD_INT 8
93090: PPUSH
93091: CALL_OW 336
// end ;
93095: PPOPN 3
93097: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
93098: LD_EXP 85
93102: PUSH
93103: LD_EXP 129
93107: AND
93108: IFFALSE 93252
93110: GO 93112
93112: DISABLE
93113: LD_INT 0
93115: PPUSH
93116: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
93117: LD_ADDR_VAR 0 2
93121: PUSH
93122: LD_INT 22
93124: PUSH
93125: LD_OWVAR 2
93129: PUSH
93130: EMPTY
93131: LIST
93132: LIST
93133: PUSH
93134: LD_INT 21
93136: PUSH
93137: LD_INT 2
93139: PUSH
93140: EMPTY
93141: LIST
93142: LIST
93143: PUSH
93144: LD_INT 2
93146: PUSH
93147: LD_INT 34
93149: PUSH
93150: LD_INT 12
93152: PUSH
93153: EMPTY
93154: LIST
93155: LIST
93156: PUSH
93157: LD_INT 34
93159: PUSH
93160: LD_INT 51
93162: PUSH
93163: EMPTY
93164: LIST
93165: LIST
93166: PUSH
93167: LD_INT 34
93169: PUSH
93170: LD_INT 32
93172: PUSH
93173: EMPTY
93174: LIST
93175: LIST
93176: PUSH
93177: EMPTY
93178: LIST
93179: LIST
93180: LIST
93181: LIST
93182: PUSH
93183: EMPTY
93184: LIST
93185: LIST
93186: LIST
93187: PPUSH
93188: CALL_OW 69
93192: ST_TO_ADDR
// if not tmp then
93193: LD_VAR 0 2
93197: NOT
93198: IFFALSE 93202
// exit ;
93200: GO 93252
// for i in tmp do
93202: LD_ADDR_VAR 0 1
93206: PUSH
93207: LD_VAR 0 2
93211: PUSH
93212: FOR_IN
93213: IFFALSE 93250
// if GetCargo ( i , mat_artifact ) = 0 then
93215: LD_VAR 0 1
93219: PPUSH
93220: LD_INT 4
93222: PPUSH
93223: CALL_OW 289
93227: PUSH
93228: LD_INT 0
93230: EQUAL
93231: IFFALSE 93248
// SetCargo ( i , mat_siberit , 100 ) ;
93233: LD_VAR 0 1
93237: PPUSH
93238: LD_INT 3
93240: PPUSH
93241: LD_INT 100
93243: PPUSH
93244: CALL_OW 290
93248: GO 93212
93250: POP
93251: POP
// end ;
93252: PPOPN 2
93254: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
93255: LD_EXP 85
93259: PUSH
93260: LD_EXP 130
93264: AND
93265: IFFALSE 93448
93267: GO 93269
93269: DISABLE
93270: LD_INT 0
93272: PPUSH
93273: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
93274: LD_ADDR_VAR 0 2
93278: PUSH
93279: LD_INT 22
93281: PUSH
93282: LD_OWVAR 2
93286: PUSH
93287: EMPTY
93288: LIST
93289: LIST
93290: PPUSH
93291: CALL_OW 69
93295: ST_TO_ADDR
// if not tmp then
93296: LD_VAR 0 2
93300: NOT
93301: IFFALSE 93305
// exit ;
93303: GO 93448
// for i := 1 to 2 do
93305: LD_ADDR_VAR 0 1
93309: PUSH
93310: DOUBLE
93311: LD_INT 1
93313: DEC
93314: ST_TO_ADDR
93315: LD_INT 2
93317: PUSH
93318: FOR_TO
93319: IFFALSE 93446
// begin uc_side := your_side ;
93321: LD_ADDR_OWVAR 20
93325: PUSH
93326: LD_OWVAR 2
93330: ST_TO_ADDR
// uc_nation := nation_american ;
93331: LD_ADDR_OWVAR 21
93335: PUSH
93336: LD_INT 1
93338: ST_TO_ADDR
// vc_chassis := us_morphling ;
93339: LD_ADDR_OWVAR 37
93343: PUSH
93344: LD_INT 5
93346: ST_TO_ADDR
// vc_engine := engine_siberite ;
93347: LD_ADDR_OWVAR 39
93351: PUSH
93352: LD_INT 3
93354: ST_TO_ADDR
// vc_control := control_computer ;
93355: LD_ADDR_OWVAR 38
93359: PUSH
93360: LD_INT 3
93362: ST_TO_ADDR
// vc_weapon := us_double_laser ;
93363: LD_ADDR_OWVAR 40
93367: PUSH
93368: LD_INT 10
93370: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
93371: LD_VAR 0 2
93375: PUSH
93376: LD_INT 1
93378: ARRAY
93379: PPUSH
93380: CALL_OW 310
93384: NOT
93385: IFFALSE 93432
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
93387: CALL_OW 45
93391: PPUSH
93392: LD_VAR 0 2
93396: PUSH
93397: LD_INT 1
93399: ARRAY
93400: PPUSH
93401: CALL_OW 250
93405: PPUSH
93406: LD_VAR 0 2
93410: PUSH
93411: LD_INT 1
93413: ARRAY
93414: PPUSH
93415: CALL_OW 251
93419: PPUSH
93420: LD_INT 12
93422: PPUSH
93423: LD_INT 1
93425: PPUSH
93426: CALL_OW 50
93430: GO 93444
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
93432: CALL_OW 45
93436: PPUSH
93437: LD_INT 1
93439: PPUSH
93440: CALL_OW 51
// end ;
93444: GO 93318
93446: POP
93447: POP
// end ;
93448: PPOPN 2
93450: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
93451: LD_EXP 85
93455: PUSH
93456: LD_EXP 131
93460: AND
93461: IFFALSE 93683
93463: GO 93465
93465: DISABLE
93466: LD_INT 0
93468: PPUSH
93469: PPUSH
93470: PPUSH
93471: PPUSH
93472: PPUSH
93473: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
93474: LD_ADDR_VAR 0 6
93478: PUSH
93479: LD_INT 22
93481: PUSH
93482: LD_OWVAR 2
93486: PUSH
93487: EMPTY
93488: LIST
93489: LIST
93490: PUSH
93491: LD_INT 21
93493: PUSH
93494: LD_INT 1
93496: PUSH
93497: EMPTY
93498: LIST
93499: LIST
93500: PUSH
93501: LD_INT 3
93503: PUSH
93504: LD_INT 23
93506: PUSH
93507: LD_INT 0
93509: PUSH
93510: EMPTY
93511: LIST
93512: LIST
93513: PUSH
93514: EMPTY
93515: LIST
93516: LIST
93517: PUSH
93518: EMPTY
93519: LIST
93520: LIST
93521: LIST
93522: PPUSH
93523: CALL_OW 69
93527: ST_TO_ADDR
// if not tmp then
93528: LD_VAR 0 6
93532: NOT
93533: IFFALSE 93537
// exit ;
93535: GO 93683
// s1 := rand ( 1 , 4 ) ;
93537: LD_ADDR_VAR 0 2
93541: PUSH
93542: LD_INT 1
93544: PPUSH
93545: LD_INT 4
93547: PPUSH
93548: CALL_OW 12
93552: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
93553: LD_ADDR_VAR 0 4
93557: PUSH
93558: LD_VAR 0 6
93562: PUSH
93563: LD_INT 1
93565: ARRAY
93566: PPUSH
93567: LD_VAR 0 2
93571: PPUSH
93572: CALL_OW 259
93576: ST_TO_ADDR
// if s1 = 1 then
93577: LD_VAR 0 2
93581: PUSH
93582: LD_INT 1
93584: EQUAL
93585: IFFALSE 93605
// s2 := rand ( 2 , 4 ) else
93587: LD_ADDR_VAR 0 3
93591: PUSH
93592: LD_INT 2
93594: PPUSH
93595: LD_INT 4
93597: PPUSH
93598: CALL_OW 12
93602: ST_TO_ADDR
93603: GO 93613
// s2 := 1 ;
93605: LD_ADDR_VAR 0 3
93609: PUSH
93610: LD_INT 1
93612: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
93613: LD_ADDR_VAR 0 5
93617: PUSH
93618: LD_VAR 0 6
93622: PUSH
93623: LD_INT 1
93625: ARRAY
93626: PPUSH
93627: LD_VAR 0 3
93631: PPUSH
93632: CALL_OW 259
93636: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
93637: LD_VAR 0 6
93641: PUSH
93642: LD_INT 1
93644: ARRAY
93645: PPUSH
93646: LD_VAR 0 2
93650: PPUSH
93651: LD_VAR 0 5
93655: PPUSH
93656: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
93660: LD_VAR 0 6
93664: PUSH
93665: LD_INT 1
93667: ARRAY
93668: PPUSH
93669: LD_VAR 0 3
93673: PPUSH
93674: LD_VAR 0 4
93678: PPUSH
93679: CALL_OW 237
// end ;
93683: PPOPN 6
93685: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
93686: LD_EXP 85
93690: PUSH
93691: LD_EXP 132
93695: AND
93696: IFFALSE 93775
93698: GO 93700
93700: DISABLE
93701: LD_INT 0
93703: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
93704: LD_ADDR_VAR 0 1
93708: PUSH
93709: LD_INT 22
93711: PUSH
93712: LD_OWVAR 2
93716: PUSH
93717: EMPTY
93718: LIST
93719: LIST
93720: PUSH
93721: LD_INT 30
93723: PUSH
93724: LD_INT 3
93726: PUSH
93727: EMPTY
93728: LIST
93729: LIST
93730: PUSH
93731: EMPTY
93732: LIST
93733: LIST
93734: PPUSH
93735: CALL_OW 69
93739: ST_TO_ADDR
// if not tmp then
93740: LD_VAR 0 1
93744: NOT
93745: IFFALSE 93749
// exit ;
93747: GO 93775
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
93749: LD_VAR 0 1
93753: PUSH
93754: LD_INT 1
93756: PPUSH
93757: LD_VAR 0 1
93761: PPUSH
93762: CALL_OW 12
93766: ARRAY
93767: PPUSH
93768: LD_INT 1
93770: PPUSH
93771: CALL_OW 234
// end ;
93775: PPOPN 1
93777: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
93778: LD_EXP 85
93782: PUSH
93783: LD_EXP 133
93787: AND
93788: IFFALSE 93900
93790: GO 93792
93792: DISABLE
93793: LD_INT 0
93795: PPUSH
93796: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
93797: LD_ADDR_VAR 0 2
93801: PUSH
93802: LD_INT 22
93804: PUSH
93805: LD_OWVAR 2
93809: PUSH
93810: EMPTY
93811: LIST
93812: LIST
93813: PUSH
93814: LD_INT 2
93816: PUSH
93817: LD_INT 30
93819: PUSH
93820: LD_INT 27
93822: PUSH
93823: EMPTY
93824: LIST
93825: LIST
93826: PUSH
93827: LD_INT 30
93829: PUSH
93830: LD_INT 26
93832: PUSH
93833: EMPTY
93834: LIST
93835: LIST
93836: PUSH
93837: LD_INT 30
93839: PUSH
93840: LD_INT 28
93842: PUSH
93843: EMPTY
93844: LIST
93845: LIST
93846: PUSH
93847: EMPTY
93848: LIST
93849: LIST
93850: LIST
93851: LIST
93852: PUSH
93853: EMPTY
93854: LIST
93855: LIST
93856: PPUSH
93857: CALL_OW 69
93861: ST_TO_ADDR
// if not tmp then
93862: LD_VAR 0 2
93866: NOT
93867: IFFALSE 93871
// exit ;
93869: GO 93900
// for i in tmp do
93871: LD_ADDR_VAR 0 1
93875: PUSH
93876: LD_VAR 0 2
93880: PUSH
93881: FOR_IN
93882: IFFALSE 93898
// SetLives ( i , 1 ) ;
93884: LD_VAR 0 1
93888: PPUSH
93889: LD_INT 1
93891: PPUSH
93892: CALL_OW 234
93896: GO 93881
93898: POP
93899: POP
// end ;
93900: PPOPN 2
93902: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
93903: LD_EXP 85
93907: PUSH
93908: LD_EXP 134
93912: AND
93913: IFFALSE 94187
93915: GO 93917
93917: DISABLE
93918: LD_INT 0
93920: PPUSH
93921: PPUSH
93922: PPUSH
// begin i := rand ( 1 , 7 ) ;
93923: LD_ADDR_VAR 0 1
93927: PUSH
93928: LD_INT 1
93930: PPUSH
93931: LD_INT 7
93933: PPUSH
93934: CALL_OW 12
93938: ST_TO_ADDR
// case i of 1 :
93939: LD_VAR 0 1
93943: PUSH
93944: LD_INT 1
93946: DOUBLE
93947: EQUAL
93948: IFTRUE 93952
93950: GO 93962
93952: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
93953: LD_STRING earthquake(getX(game), 0, 32)
93955: PPUSH
93956: CALL_OW 559
93960: GO 94187
93962: LD_INT 2
93964: DOUBLE
93965: EQUAL
93966: IFTRUE 93970
93968: GO 93984
93970: POP
// begin ToLua ( displayStucuk(); ) ;
93971: LD_STRING displayStucuk();
93973: PPUSH
93974: CALL_OW 559
// ResetFog ;
93978: CALL_OW 335
// end ; 3 :
93982: GO 94187
93984: LD_INT 3
93986: DOUBLE
93987: EQUAL
93988: IFTRUE 93992
93990: GO 94096
93992: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
93993: LD_ADDR_VAR 0 2
93997: PUSH
93998: LD_INT 22
94000: PUSH
94001: LD_OWVAR 2
94005: PUSH
94006: EMPTY
94007: LIST
94008: LIST
94009: PUSH
94010: LD_INT 25
94012: PUSH
94013: LD_INT 1
94015: PUSH
94016: EMPTY
94017: LIST
94018: LIST
94019: PUSH
94020: EMPTY
94021: LIST
94022: LIST
94023: PPUSH
94024: CALL_OW 69
94028: ST_TO_ADDR
// if not tmp then
94029: LD_VAR 0 2
94033: NOT
94034: IFFALSE 94038
// exit ;
94036: GO 94187
// un := tmp [ rand ( 1 , tmp ) ] ;
94038: LD_ADDR_VAR 0 3
94042: PUSH
94043: LD_VAR 0 2
94047: PUSH
94048: LD_INT 1
94050: PPUSH
94051: LD_VAR 0 2
94055: PPUSH
94056: CALL_OW 12
94060: ARRAY
94061: ST_TO_ADDR
// if Crawls ( un ) then
94062: LD_VAR 0 3
94066: PPUSH
94067: CALL_OW 318
94071: IFFALSE 94082
// ComWalk ( un ) ;
94073: LD_VAR 0 3
94077: PPUSH
94078: CALL_OW 138
// SetClass ( un , class_mortar ) ;
94082: LD_VAR 0 3
94086: PPUSH
94087: LD_INT 8
94089: PPUSH
94090: CALL_OW 336
// end ; 4 :
94094: GO 94187
94096: LD_INT 4
94098: DOUBLE
94099: EQUAL
94100: IFTRUE 94104
94102: GO 94165
94104: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
94105: LD_ADDR_VAR 0 2
94109: PUSH
94110: LD_INT 22
94112: PUSH
94113: LD_OWVAR 2
94117: PUSH
94118: EMPTY
94119: LIST
94120: LIST
94121: PUSH
94122: LD_INT 30
94124: PUSH
94125: LD_INT 29
94127: PUSH
94128: EMPTY
94129: LIST
94130: LIST
94131: PUSH
94132: EMPTY
94133: LIST
94134: LIST
94135: PPUSH
94136: CALL_OW 69
94140: ST_TO_ADDR
// if not tmp then
94141: LD_VAR 0 2
94145: NOT
94146: IFFALSE 94150
// exit ;
94148: GO 94187
// DestroyUnit ( tmp [ 1 ] ) ;
94150: LD_VAR 0 2
94154: PUSH
94155: LD_INT 1
94157: ARRAY
94158: PPUSH
94159: CALL_OW 65
// end ; 5 .. 7 :
94163: GO 94187
94165: LD_INT 5
94167: DOUBLE
94168: GREATEREQUAL
94169: IFFALSE 94177
94171: LD_INT 7
94173: DOUBLE
94174: LESSEQUAL
94175: IFTRUE 94179
94177: GO 94186
94179: POP
// StreamSibBomb ; end ;
94180: CALL 90437 0 0
94184: GO 94187
94186: POP
// end ;
94187: PPOPN 3
94189: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
94190: LD_EXP 85
94194: PUSH
94195: LD_EXP 135
94199: AND
94200: IFFALSE 94356
94202: GO 94204
94204: DISABLE
94205: LD_INT 0
94207: PPUSH
94208: PPUSH
94209: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
94210: LD_ADDR_VAR 0 2
94214: PUSH
94215: LD_INT 81
94217: PUSH
94218: LD_OWVAR 2
94222: PUSH
94223: EMPTY
94224: LIST
94225: LIST
94226: PUSH
94227: LD_INT 2
94229: PUSH
94230: LD_INT 21
94232: PUSH
94233: LD_INT 1
94235: PUSH
94236: EMPTY
94237: LIST
94238: LIST
94239: PUSH
94240: LD_INT 21
94242: PUSH
94243: LD_INT 2
94245: PUSH
94246: EMPTY
94247: LIST
94248: LIST
94249: PUSH
94250: EMPTY
94251: LIST
94252: LIST
94253: LIST
94254: PUSH
94255: EMPTY
94256: LIST
94257: LIST
94258: PPUSH
94259: CALL_OW 69
94263: ST_TO_ADDR
// if not tmp then
94264: LD_VAR 0 2
94268: NOT
94269: IFFALSE 94273
// exit ;
94271: GO 94356
// p := 0 ;
94273: LD_ADDR_VAR 0 3
94277: PUSH
94278: LD_INT 0
94280: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
94281: LD_INT 35
94283: PPUSH
94284: CALL_OW 67
// p := p + 1 ;
94288: LD_ADDR_VAR 0 3
94292: PUSH
94293: LD_VAR 0 3
94297: PUSH
94298: LD_INT 1
94300: PLUS
94301: ST_TO_ADDR
// for i in tmp do
94302: LD_ADDR_VAR 0 1
94306: PUSH
94307: LD_VAR 0 2
94311: PUSH
94312: FOR_IN
94313: IFFALSE 94344
// if GetLives ( i ) < 1000 then
94315: LD_VAR 0 1
94319: PPUSH
94320: CALL_OW 256
94324: PUSH
94325: LD_INT 1000
94327: LESS
94328: IFFALSE 94342
// SetLives ( i , 1000 ) ;
94330: LD_VAR 0 1
94334: PPUSH
94335: LD_INT 1000
94337: PPUSH
94338: CALL_OW 234
94342: GO 94312
94344: POP
94345: POP
// until p > 20 ;
94346: LD_VAR 0 3
94350: PUSH
94351: LD_INT 20
94353: GREATER
94354: IFFALSE 94281
// end ;
94356: PPOPN 3
94358: END
// every 0 0$1 trigger StreamModeActive and sTime do
94359: LD_EXP 85
94363: PUSH
94364: LD_EXP 136
94368: AND
94369: IFFALSE 94404
94371: GO 94373
94373: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
94374: LD_INT 28
94376: PPUSH
94377: LD_OWVAR 2
94381: PPUSH
94382: LD_INT 2
94384: PPUSH
94385: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
94389: LD_INT 30
94391: PPUSH
94392: LD_OWVAR 2
94396: PPUSH
94397: LD_INT 2
94399: PPUSH
94400: CALL_OW 322
// end ;
94404: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
94405: LD_EXP 85
94409: PUSH
94410: LD_EXP 137
94414: AND
94415: IFFALSE 94536
94417: GO 94419
94419: DISABLE
94420: LD_INT 0
94422: PPUSH
94423: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
94424: LD_ADDR_VAR 0 2
94428: PUSH
94429: LD_INT 22
94431: PUSH
94432: LD_OWVAR 2
94436: PUSH
94437: EMPTY
94438: LIST
94439: LIST
94440: PUSH
94441: LD_INT 21
94443: PUSH
94444: LD_INT 1
94446: PUSH
94447: EMPTY
94448: LIST
94449: LIST
94450: PUSH
94451: LD_INT 3
94453: PUSH
94454: LD_INT 23
94456: PUSH
94457: LD_INT 0
94459: PUSH
94460: EMPTY
94461: LIST
94462: LIST
94463: PUSH
94464: EMPTY
94465: LIST
94466: LIST
94467: PUSH
94468: EMPTY
94469: LIST
94470: LIST
94471: LIST
94472: PPUSH
94473: CALL_OW 69
94477: ST_TO_ADDR
// if not tmp then
94478: LD_VAR 0 2
94482: NOT
94483: IFFALSE 94487
// exit ;
94485: GO 94536
// for i in tmp do
94487: LD_ADDR_VAR 0 1
94491: PUSH
94492: LD_VAR 0 2
94496: PUSH
94497: FOR_IN
94498: IFFALSE 94534
// begin if Crawls ( i ) then
94500: LD_VAR 0 1
94504: PPUSH
94505: CALL_OW 318
94509: IFFALSE 94520
// ComWalk ( i ) ;
94511: LD_VAR 0 1
94515: PPUSH
94516: CALL_OW 138
// SetClass ( i , 2 ) ;
94520: LD_VAR 0 1
94524: PPUSH
94525: LD_INT 2
94527: PPUSH
94528: CALL_OW 336
// end ;
94532: GO 94497
94534: POP
94535: POP
// end ;
94536: PPOPN 2
94538: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
94539: LD_EXP 85
94543: PUSH
94544: LD_EXP 138
94548: AND
94549: IFFALSE 94830
94551: GO 94553
94553: DISABLE
94554: LD_INT 0
94556: PPUSH
94557: PPUSH
94558: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
94559: LD_OWVAR 2
94563: PPUSH
94564: LD_INT 9
94566: PPUSH
94567: LD_INT 1
94569: PPUSH
94570: LD_INT 1
94572: PPUSH
94573: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
94577: LD_INT 9
94579: PPUSH
94580: LD_OWVAR 2
94584: PPUSH
94585: CALL_OW 343
// uc_side := 9 ;
94589: LD_ADDR_OWVAR 20
94593: PUSH
94594: LD_INT 9
94596: ST_TO_ADDR
// uc_nation := 2 ;
94597: LD_ADDR_OWVAR 21
94601: PUSH
94602: LD_INT 2
94604: ST_TO_ADDR
// hc_name := Dark Warrior ;
94605: LD_ADDR_OWVAR 26
94609: PUSH
94610: LD_STRING Dark Warrior
94612: ST_TO_ADDR
// hc_gallery :=  ;
94613: LD_ADDR_OWVAR 33
94617: PUSH
94618: LD_STRING 
94620: ST_TO_ADDR
// hc_noskilllimit := true ;
94621: LD_ADDR_OWVAR 76
94625: PUSH
94626: LD_INT 1
94628: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
94629: LD_ADDR_OWVAR 31
94633: PUSH
94634: LD_INT 30
94636: PUSH
94637: LD_INT 30
94639: PUSH
94640: LD_INT 30
94642: PUSH
94643: LD_INT 30
94645: PUSH
94646: EMPTY
94647: LIST
94648: LIST
94649: LIST
94650: LIST
94651: ST_TO_ADDR
// un := CreateHuman ;
94652: LD_ADDR_VAR 0 3
94656: PUSH
94657: CALL_OW 44
94661: ST_TO_ADDR
// hc_noskilllimit := false ;
94662: LD_ADDR_OWVAR 76
94666: PUSH
94667: LD_INT 0
94669: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
94670: LD_VAR 0 3
94674: PPUSH
94675: LD_INT 1
94677: PPUSH
94678: CALL_OW 51
// p := 0 ;
94682: LD_ADDR_VAR 0 2
94686: PUSH
94687: LD_INT 0
94689: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
94690: LD_INT 35
94692: PPUSH
94693: CALL_OW 67
// p := p + 1 ;
94697: LD_ADDR_VAR 0 2
94701: PUSH
94702: LD_VAR 0 2
94706: PUSH
94707: LD_INT 1
94709: PLUS
94710: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
94711: LD_VAR 0 3
94715: PPUSH
94716: CALL_OW 256
94720: PUSH
94721: LD_INT 1000
94723: LESS
94724: IFFALSE 94738
// SetLives ( un , 1000 ) ;
94726: LD_VAR 0 3
94730: PPUSH
94731: LD_INT 1000
94733: PPUSH
94734: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
94738: LD_VAR 0 3
94742: PPUSH
94743: LD_INT 81
94745: PUSH
94746: LD_OWVAR 2
94750: PUSH
94751: EMPTY
94752: LIST
94753: LIST
94754: PUSH
94755: LD_INT 91
94757: PUSH
94758: LD_VAR 0 3
94762: PUSH
94763: LD_INT 30
94765: PUSH
94766: EMPTY
94767: LIST
94768: LIST
94769: LIST
94770: PUSH
94771: EMPTY
94772: LIST
94773: LIST
94774: PPUSH
94775: CALL_OW 69
94779: PPUSH
94780: LD_VAR 0 3
94784: PPUSH
94785: CALL_OW 74
94789: PPUSH
94790: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
94794: LD_VAR 0 2
94798: PUSH
94799: LD_INT 60
94801: GREATER
94802: PUSH
94803: LD_VAR 0 3
94807: PPUSH
94808: CALL_OW 301
94812: OR
94813: IFFALSE 94690
// if un then
94815: LD_VAR 0 3
94819: IFFALSE 94830
// RemoveUnit ( un ) ;
94821: LD_VAR 0 3
94825: PPUSH
94826: CALL_OW 64
// end ;
94830: PPOPN 3
94832: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
94833: LD_INT 0
94835: PPUSH
// case cmd of 301 :
94836: LD_VAR 0 1
94840: PUSH
94841: LD_INT 301
94843: DOUBLE
94844: EQUAL
94845: IFTRUE 94849
94847: GO 94881
94849: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
94850: LD_VAR 0 6
94854: PPUSH
94855: LD_VAR 0 7
94859: PPUSH
94860: LD_VAR 0 8
94864: PPUSH
94865: LD_VAR 0 4
94869: PPUSH
94870: LD_VAR 0 5
94874: PPUSH
94875: CALL 96082 0 5
94879: GO 95002
94881: LD_INT 302
94883: DOUBLE
94884: EQUAL
94885: IFTRUE 94889
94887: GO 94926
94889: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
94890: LD_VAR 0 6
94894: PPUSH
94895: LD_VAR 0 7
94899: PPUSH
94900: LD_VAR 0 8
94904: PPUSH
94905: LD_VAR 0 9
94909: PPUSH
94910: LD_VAR 0 4
94914: PPUSH
94915: LD_VAR 0 5
94919: PPUSH
94920: CALL 96173 0 6
94924: GO 95002
94926: LD_INT 303
94928: DOUBLE
94929: EQUAL
94930: IFTRUE 94934
94932: GO 94971
94934: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
94935: LD_VAR 0 6
94939: PPUSH
94940: LD_VAR 0 7
94944: PPUSH
94945: LD_VAR 0 8
94949: PPUSH
94950: LD_VAR 0 9
94954: PPUSH
94955: LD_VAR 0 4
94959: PPUSH
94960: LD_VAR 0 5
94964: PPUSH
94965: CALL 95007 0 6
94969: GO 95002
94971: LD_INT 304
94973: DOUBLE
94974: EQUAL
94975: IFTRUE 94979
94977: GO 95001
94979: POP
// hHackTeleport ( unit , x , y ) ; end ;
94980: LD_VAR 0 2
94984: PPUSH
94985: LD_VAR 0 4
94989: PPUSH
94990: LD_VAR 0 5
94994: PPUSH
94995: CALL 96766 0 3
94999: GO 95002
95001: POP
// end ;
95002: LD_VAR 0 12
95006: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
95007: LD_INT 0
95009: PPUSH
95010: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
95011: LD_VAR 0 1
95015: PUSH
95016: LD_INT 1
95018: LESS
95019: PUSH
95020: LD_VAR 0 1
95024: PUSH
95025: LD_INT 3
95027: GREATER
95028: OR
95029: PUSH
95030: LD_VAR 0 5
95034: PPUSH
95035: LD_VAR 0 6
95039: PPUSH
95040: CALL_OW 428
95044: OR
95045: IFFALSE 95049
// exit ;
95047: GO 95769
// uc_side := your_side ;
95049: LD_ADDR_OWVAR 20
95053: PUSH
95054: LD_OWVAR 2
95058: ST_TO_ADDR
// uc_nation := nation ;
95059: LD_ADDR_OWVAR 21
95063: PUSH
95064: LD_VAR 0 1
95068: ST_TO_ADDR
// bc_level = 1 ;
95069: LD_ADDR_OWVAR 43
95073: PUSH
95074: LD_INT 1
95076: ST_TO_ADDR
// case btype of 1 :
95077: LD_VAR 0 2
95081: PUSH
95082: LD_INT 1
95084: DOUBLE
95085: EQUAL
95086: IFTRUE 95090
95088: GO 95101
95090: POP
// bc_type := b_depot ; 2 :
95091: LD_ADDR_OWVAR 42
95095: PUSH
95096: LD_INT 0
95098: ST_TO_ADDR
95099: GO 95713
95101: LD_INT 2
95103: DOUBLE
95104: EQUAL
95105: IFTRUE 95109
95107: GO 95120
95109: POP
// bc_type := b_warehouse ; 3 :
95110: LD_ADDR_OWVAR 42
95114: PUSH
95115: LD_INT 1
95117: ST_TO_ADDR
95118: GO 95713
95120: LD_INT 3
95122: DOUBLE
95123: EQUAL
95124: IFTRUE 95128
95126: GO 95139
95128: POP
// bc_type := b_lab ; 4 .. 9 :
95129: LD_ADDR_OWVAR 42
95133: PUSH
95134: LD_INT 6
95136: ST_TO_ADDR
95137: GO 95713
95139: LD_INT 4
95141: DOUBLE
95142: GREATEREQUAL
95143: IFFALSE 95151
95145: LD_INT 9
95147: DOUBLE
95148: LESSEQUAL
95149: IFTRUE 95153
95151: GO 95205
95153: POP
// begin bc_type := b_lab_half ;
95154: LD_ADDR_OWVAR 42
95158: PUSH
95159: LD_INT 7
95161: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
95162: LD_ADDR_OWVAR 44
95166: PUSH
95167: LD_INT 10
95169: PUSH
95170: LD_INT 11
95172: PUSH
95173: LD_INT 12
95175: PUSH
95176: LD_INT 15
95178: PUSH
95179: LD_INT 14
95181: PUSH
95182: LD_INT 13
95184: PUSH
95185: EMPTY
95186: LIST
95187: LIST
95188: LIST
95189: LIST
95190: LIST
95191: LIST
95192: PUSH
95193: LD_VAR 0 2
95197: PUSH
95198: LD_INT 3
95200: MINUS
95201: ARRAY
95202: ST_TO_ADDR
// end ; 10 .. 13 :
95203: GO 95713
95205: LD_INT 10
95207: DOUBLE
95208: GREATEREQUAL
95209: IFFALSE 95217
95211: LD_INT 13
95213: DOUBLE
95214: LESSEQUAL
95215: IFTRUE 95219
95217: GO 95296
95219: POP
// begin bc_type := b_lab_full ;
95220: LD_ADDR_OWVAR 42
95224: PUSH
95225: LD_INT 8
95227: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
95228: LD_ADDR_OWVAR 44
95232: PUSH
95233: LD_INT 10
95235: PUSH
95236: LD_INT 12
95238: PUSH
95239: LD_INT 14
95241: PUSH
95242: LD_INT 13
95244: PUSH
95245: EMPTY
95246: LIST
95247: LIST
95248: LIST
95249: LIST
95250: PUSH
95251: LD_VAR 0 2
95255: PUSH
95256: LD_INT 9
95258: MINUS
95259: ARRAY
95260: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
95261: LD_ADDR_OWVAR 45
95265: PUSH
95266: LD_INT 11
95268: PUSH
95269: LD_INT 15
95271: PUSH
95272: LD_INT 12
95274: PUSH
95275: LD_INT 15
95277: PUSH
95278: EMPTY
95279: LIST
95280: LIST
95281: LIST
95282: LIST
95283: PUSH
95284: LD_VAR 0 2
95288: PUSH
95289: LD_INT 9
95291: MINUS
95292: ARRAY
95293: ST_TO_ADDR
// end ; 14 :
95294: GO 95713
95296: LD_INT 14
95298: DOUBLE
95299: EQUAL
95300: IFTRUE 95304
95302: GO 95315
95304: POP
// bc_type := b_workshop ; 15 :
95305: LD_ADDR_OWVAR 42
95309: PUSH
95310: LD_INT 2
95312: ST_TO_ADDR
95313: GO 95713
95315: LD_INT 15
95317: DOUBLE
95318: EQUAL
95319: IFTRUE 95323
95321: GO 95334
95323: POP
// bc_type := b_factory ; 16 :
95324: LD_ADDR_OWVAR 42
95328: PUSH
95329: LD_INT 3
95331: ST_TO_ADDR
95332: GO 95713
95334: LD_INT 16
95336: DOUBLE
95337: EQUAL
95338: IFTRUE 95342
95340: GO 95353
95342: POP
// bc_type := b_ext_gun ; 17 :
95343: LD_ADDR_OWVAR 42
95347: PUSH
95348: LD_INT 17
95350: ST_TO_ADDR
95351: GO 95713
95353: LD_INT 17
95355: DOUBLE
95356: EQUAL
95357: IFTRUE 95361
95359: GO 95389
95361: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
95362: LD_ADDR_OWVAR 42
95366: PUSH
95367: LD_INT 19
95369: PUSH
95370: LD_INT 23
95372: PUSH
95373: LD_INT 19
95375: PUSH
95376: EMPTY
95377: LIST
95378: LIST
95379: LIST
95380: PUSH
95381: LD_VAR 0 1
95385: ARRAY
95386: ST_TO_ADDR
95387: GO 95713
95389: LD_INT 18
95391: DOUBLE
95392: EQUAL
95393: IFTRUE 95397
95395: GO 95408
95397: POP
// bc_type := b_ext_radar ; 19 :
95398: LD_ADDR_OWVAR 42
95402: PUSH
95403: LD_INT 20
95405: ST_TO_ADDR
95406: GO 95713
95408: LD_INT 19
95410: DOUBLE
95411: EQUAL
95412: IFTRUE 95416
95414: GO 95427
95416: POP
// bc_type := b_ext_radio ; 20 :
95417: LD_ADDR_OWVAR 42
95421: PUSH
95422: LD_INT 22
95424: ST_TO_ADDR
95425: GO 95713
95427: LD_INT 20
95429: DOUBLE
95430: EQUAL
95431: IFTRUE 95435
95433: GO 95446
95435: POP
// bc_type := b_ext_siberium ; 21 :
95436: LD_ADDR_OWVAR 42
95440: PUSH
95441: LD_INT 21
95443: ST_TO_ADDR
95444: GO 95713
95446: LD_INT 21
95448: DOUBLE
95449: EQUAL
95450: IFTRUE 95454
95452: GO 95465
95454: POP
// bc_type := b_ext_computer ; 22 :
95455: LD_ADDR_OWVAR 42
95459: PUSH
95460: LD_INT 24
95462: ST_TO_ADDR
95463: GO 95713
95465: LD_INT 22
95467: DOUBLE
95468: EQUAL
95469: IFTRUE 95473
95471: GO 95484
95473: POP
// bc_type := b_ext_track ; 23 :
95474: LD_ADDR_OWVAR 42
95478: PUSH
95479: LD_INT 16
95481: ST_TO_ADDR
95482: GO 95713
95484: LD_INT 23
95486: DOUBLE
95487: EQUAL
95488: IFTRUE 95492
95490: GO 95503
95492: POP
// bc_type := b_ext_laser ; 24 :
95493: LD_ADDR_OWVAR 42
95497: PUSH
95498: LD_INT 25
95500: ST_TO_ADDR
95501: GO 95713
95503: LD_INT 24
95505: DOUBLE
95506: EQUAL
95507: IFTRUE 95511
95509: GO 95522
95511: POP
// bc_type := b_control_tower ; 25 :
95512: LD_ADDR_OWVAR 42
95516: PUSH
95517: LD_INT 36
95519: ST_TO_ADDR
95520: GO 95713
95522: LD_INT 25
95524: DOUBLE
95525: EQUAL
95526: IFTRUE 95530
95528: GO 95541
95530: POP
// bc_type := b_breastwork ; 26 :
95531: LD_ADDR_OWVAR 42
95535: PUSH
95536: LD_INT 31
95538: ST_TO_ADDR
95539: GO 95713
95541: LD_INT 26
95543: DOUBLE
95544: EQUAL
95545: IFTRUE 95549
95547: GO 95560
95549: POP
// bc_type := b_bunker ; 27 :
95550: LD_ADDR_OWVAR 42
95554: PUSH
95555: LD_INT 32
95557: ST_TO_ADDR
95558: GO 95713
95560: LD_INT 27
95562: DOUBLE
95563: EQUAL
95564: IFTRUE 95568
95566: GO 95579
95568: POP
// bc_type := b_turret ; 28 :
95569: LD_ADDR_OWVAR 42
95573: PUSH
95574: LD_INT 33
95576: ST_TO_ADDR
95577: GO 95713
95579: LD_INT 28
95581: DOUBLE
95582: EQUAL
95583: IFTRUE 95587
95585: GO 95598
95587: POP
// bc_type := b_armoury ; 29 :
95588: LD_ADDR_OWVAR 42
95592: PUSH
95593: LD_INT 4
95595: ST_TO_ADDR
95596: GO 95713
95598: LD_INT 29
95600: DOUBLE
95601: EQUAL
95602: IFTRUE 95606
95604: GO 95617
95606: POP
// bc_type := b_barracks ; 30 :
95607: LD_ADDR_OWVAR 42
95611: PUSH
95612: LD_INT 5
95614: ST_TO_ADDR
95615: GO 95713
95617: LD_INT 30
95619: DOUBLE
95620: EQUAL
95621: IFTRUE 95625
95623: GO 95636
95625: POP
// bc_type := b_solar_power ; 31 :
95626: LD_ADDR_OWVAR 42
95630: PUSH
95631: LD_INT 27
95633: ST_TO_ADDR
95634: GO 95713
95636: LD_INT 31
95638: DOUBLE
95639: EQUAL
95640: IFTRUE 95644
95642: GO 95655
95644: POP
// bc_type := b_oil_power ; 32 :
95645: LD_ADDR_OWVAR 42
95649: PUSH
95650: LD_INT 26
95652: ST_TO_ADDR
95653: GO 95713
95655: LD_INT 32
95657: DOUBLE
95658: EQUAL
95659: IFTRUE 95663
95661: GO 95674
95663: POP
// bc_type := b_siberite_power ; 33 :
95664: LD_ADDR_OWVAR 42
95668: PUSH
95669: LD_INT 28
95671: ST_TO_ADDR
95672: GO 95713
95674: LD_INT 33
95676: DOUBLE
95677: EQUAL
95678: IFTRUE 95682
95680: GO 95693
95682: POP
// bc_type := b_oil_mine ; 34 :
95683: LD_ADDR_OWVAR 42
95687: PUSH
95688: LD_INT 29
95690: ST_TO_ADDR
95691: GO 95713
95693: LD_INT 34
95695: DOUBLE
95696: EQUAL
95697: IFTRUE 95701
95699: GO 95712
95701: POP
// bc_type := b_siberite_mine ; end ;
95702: LD_ADDR_OWVAR 42
95706: PUSH
95707: LD_INT 30
95709: ST_TO_ADDR
95710: GO 95713
95712: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
95713: LD_ADDR_VAR 0 8
95717: PUSH
95718: LD_VAR 0 5
95722: PPUSH
95723: LD_VAR 0 6
95727: PPUSH
95728: LD_VAR 0 3
95732: PPUSH
95733: CALL_OW 47
95737: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
95738: LD_OWVAR 42
95742: PUSH
95743: LD_INT 32
95745: PUSH
95746: LD_INT 33
95748: PUSH
95749: EMPTY
95750: LIST
95751: LIST
95752: IN
95753: IFFALSE 95769
// PlaceWeaponTurret ( b , weapon ) ;
95755: LD_VAR 0 8
95759: PPUSH
95760: LD_VAR 0 4
95764: PPUSH
95765: CALL_OW 431
// end ;
95769: LD_VAR 0 7
95773: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
95774: LD_INT 0
95776: PPUSH
95777: PPUSH
95778: PPUSH
95779: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
95780: LD_ADDR_VAR 0 4
95784: PUSH
95785: LD_INT 22
95787: PUSH
95788: LD_OWVAR 2
95792: PUSH
95793: EMPTY
95794: LIST
95795: LIST
95796: PUSH
95797: LD_INT 2
95799: PUSH
95800: LD_INT 30
95802: PUSH
95803: LD_INT 0
95805: PUSH
95806: EMPTY
95807: LIST
95808: LIST
95809: PUSH
95810: LD_INT 30
95812: PUSH
95813: LD_INT 1
95815: PUSH
95816: EMPTY
95817: LIST
95818: LIST
95819: PUSH
95820: EMPTY
95821: LIST
95822: LIST
95823: LIST
95824: PUSH
95825: EMPTY
95826: LIST
95827: LIST
95828: PPUSH
95829: CALL_OW 69
95833: ST_TO_ADDR
// if not tmp then
95834: LD_VAR 0 4
95838: NOT
95839: IFFALSE 95843
// exit ;
95841: GO 95902
// for i in tmp do
95843: LD_ADDR_VAR 0 2
95847: PUSH
95848: LD_VAR 0 4
95852: PUSH
95853: FOR_IN
95854: IFFALSE 95900
// for j = 1 to 3 do
95856: LD_ADDR_VAR 0 3
95860: PUSH
95861: DOUBLE
95862: LD_INT 1
95864: DEC
95865: ST_TO_ADDR
95866: LD_INT 3
95868: PUSH
95869: FOR_TO
95870: IFFALSE 95896
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
95872: LD_VAR 0 2
95876: PPUSH
95877: CALL_OW 274
95881: PPUSH
95882: LD_VAR 0 3
95886: PPUSH
95887: LD_INT 99999
95889: PPUSH
95890: CALL_OW 277
95894: GO 95869
95896: POP
95897: POP
95898: GO 95853
95900: POP
95901: POP
// end ;
95902: LD_VAR 0 1
95906: RET
// export function hHackSetLevel10 ; var i , j ; begin
95907: LD_INT 0
95909: PPUSH
95910: PPUSH
95911: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
95912: LD_ADDR_VAR 0 2
95916: PUSH
95917: LD_INT 21
95919: PUSH
95920: LD_INT 1
95922: PUSH
95923: EMPTY
95924: LIST
95925: LIST
95926: PPUSH
95927: CALL_OW 69
95931: PUSH
95932: FOR_IN
95933: IFFALSE 95985
// if IsSelected ( i ) then
95935: LD_VAR 0 2
95939: PPUSH
95940: CALL_OW 306
95944: IFFALSE 95983
// begin for j := 1 to 4 do
95946: LD_ADDR_VAR 0 3
95950: PUSH
95951: DOUBLE
95952: LD_INT 1
95954: DEC
95955: ST_TO_ADDR
95956: LD_INT 4
95958: PUSH
95959: FOR_TO
95960: IFFALSE 95981
// SetSkill ( i , j , 10 ) ;
95962: LD_VAR 0 2
95966: PPUSH
95967: LD_VAR 0 3
95971: PPUSH
95972: LD_INT 10
95974: PPUSH
95975: CALL_OW 237
95979: GO 95959
95981: POP
95982: POP
// end ;
95983: GO 95932
95985: POP
95986: POP
// end ;
95987: LD_VAR 0 1
95991: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
95992: LD_INT 0
95994: PPUSH
95995: PPUSH
95996: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
95997: LD_ADDR_VAR 0 2
96001: PUSH
96002: LD_INT 22
96004: PUSH
96005: LD_OWVAR 2
96009: PUSH
96010: EMPTY
96011: LIST
96012: LIST
96013: PUSH
96014: LD_INT 21
96016: PUSH
96017: LD_INT 1
96019: PUSH
96020: EMPTY
96021: LIST
96022: LIST
96023: PUSH
96024: EMPTY
96025: LIST
96026: LIST
96027: PPUSH
96028: CALL_OW 69
96032: PUSH
96033: FOR_IN
96034: IFFALSE 96075
// begin for j := 1 to 4 do
96036: LD_ADDR_VAR 0 3
96040: PUSH
96041: DOUBLE
96042: LD_INT 1
96044: DEC
96045: ST_TO_ADDR
96046: LD_INT 4
96048: PUSH
96049: FOR_TO
96050: IFFALSE 96071
// SetSkill ( i , j , 10 ) ;
96052: LD_VAR 0 2
96056: PPUSH
96057: LD_VAR 0 3
96061: PPUSH
96062: LD_INT 10
96064: PPUSH
96065: CALL_OW 237
96069: GO 96049
96071: POP
96072: POP
// end ;
96073: GO 96033
96075: POP
96076: POP
// end ;
96077: LD_VAR 0 1
96081: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
96082: LD_INT 0
96084: PPUSH
// uc_side := your_side ;
96085: LD_ADDR_OWVAR 20
96089: PUSH
96090: LD_OWVAR 2
96094: ST_TO_ADDR
// uc_nation := nation ;
96095: LD_ADDR_OWVAR 21
96099: PUSH
96100: LD_VAR 0 1
96104: ST_TO_ADDR
// InitHc ;
96105: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
96109: LD_INT 0
96111: PPUSH
96112: LD_VAR 0 2
96116: PPUSH
96117: LD_VAR 0 3
96121: PPUSH
96122: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
96126: LD_VAR 0 4
96130: PPUSH
96131: LD_VAR 0 5
96135: PPUSH
96136: CALL_OW 428
96140: PUSH
96141: LD_INT 0
96143: EQUAL
96144: IFFALSE 96168
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
96146: CALL_OW 44
96150: PPUSH
96151: LD_VAR 0 4
96155: PPUSH
96156: LD_VAR 0 5
96160: PPUSH
96161: LD_INT 1
96163: PPUSH
96164: CALL_OW 48
// end ;
96168: LD_VAR 0 6
96172: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
96173: LD_INT 0
96175: PPUSH
96176: PPUSH
// uc_side := your_side ;
96177: LD_ADDR_OWVAR 20
96181: PUSH
96182: LD_OWVAR 2
96186: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
96187: LD_VAR 0 1
96191: PUSH
96192: LD_INT 1
96194: PUSH
96195: LD_INT 2
96197: PUSH
96198: LD_INT 3
96200: PUSH
96201: LD_INT 4
96203: PUSH
96204: LD_INT 5
96206: PUSH
96207: EMPTY
96208: LIST
96209: LIST
96210: LIST
96211: LIST
96212: LIST
96213: IN
96214: IFFALSE 96226
// uc_nation := nation_american else
96216: LD_ADDR_OWVAR 21
96220: PUSH
96221: LD_INT 1
96223: ST_TO_ADDR
96224: GO 96269
// if chassis in [ 11 , 12 , 13 , 14 ] then
96226: LD_VAR 0 1
96230: PUSH
96231: LD_INT 11
96233: PUSH
96234: LD_INT 12
96236: PUSH
96237: LD_INT 13
96239: PUSH
96240: LD_INT 14
96242: PUSH
96243: EMPTY
96244: LIST
96245: LIST
96246: LIST
96247: LIST
96248: IN
96249: IFFALSE 96261
// uc_nation := nation_arabian else
96251: LD_ADDR_OWVAR 21
96255: PUSH
96256: LD_INT 2
96258: ST_TO_ADDR
96259: GO 96269
// uc_nation := nation_russian ;
96261: LD_ADDR_OWVAR 21
96265: PUSH
96266: LD_INT 3
96268: ST_TO_ADDR
// vc_chassis := chassis ;
96269: LD_ADDR_OWVAR 37
96273: PUSH
96274: LD_VAR 0 1
96278: ST_TO_ADDR
// vc_engine := engine ;
96279: LD_ADDR_OWVAR 39
96283: PUSH
96284: LD_VAR 0 2
96288: ST_TO_ADDR
// vc_control := control ;
96289: LD_ADDR_OWVAR 38
96293: PUSH
96294: LD_VAR 0 3
96298: ST_TO_ADDR
// vc_weapon := weapon ;
96299: LD_ADDR_OWVAR 40
96303: PUSH
96304: LD_VAR 0 4
96308: ST_TO_ADDR
// un := CreateVehicle ;
96309: LD_ADDR_VAR 0 8
96313: PUSH
96314: CALL_OW 45
96318: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
96319: LD_VAR 0 8
96323: PPUSH
96324: LD_INT 0
96326: PPUSH
96327: LD_INT 5
96329: PPUSH
96330: CALL_OW 12
96334: PPUSH
96335: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
96339: LD_VAR 0 8
96343: PPUSH
96344: LD_VAR 0 5
96348: PPUSH
96349: LD_VAR 0 6
96353: PPUSH
96354: LD_INT 1
96356: PPUSH
96357: CALL_OW 48
// end ;
96361: LD_VAR 0 7
96365: RET
// export hInvincible ; every 1 do
96366: GO 96368
96368: DISABLE
// hInvincible := [ ] ;
96369: LD_ADDR_EXP 139
96373: PUSH
96374: EMPTY
96375: ST_TO_ADDR
96376: END
// every 10 do var i ;
96377: GO 96379
96379: DISABLE
96380: LD_INT 0
96382: PPUSH
// begin enable ;
96383: ENABLE
// if not hInvincible then
96384: LD_EXP 139
96388: NOT
96389: IFFALSE 96393
// exit ;
96391: GO 96437
// for i in hInvincible do
96393: LD_ADDR_VAR 0 1
96397: PUSH
96398: LD_EXP 139
96402: PUSH
96403: FOR_IN
96404: IFFALSE 96435
// if GetLives ( i ) < 1000 then
96406: LD_VAR 0 1
96410: PPUSH
96411: CALL_OW 256
96415: PUSH
96416: LD_INT 1000
96418: LESS
96419: IFFALSE 96433
// SetLives ( i , 1000 ) ;
96421: LD_VAR 0 1
96425: PPUSH
96426: LD_INT 1000
96428: PPUSH
96429: CALL_OW 234
96433: GO 96403
96435: POP
96436: POP
// end ;
96437: PPOPN 1
96439: END
// export function hHackInvincible ; var i ; begin
96440: LD_INT 0
96442: PPUSH
96443: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
96444: LD_ADDR_VAR 0 2
96448: PUSH
96449: LD_INT 2
96451: PUSH
96452: LD_INT 21
96454: PUSH
96455: LD_INT 1
96457: PUSH
96458: EMPTY
96459: LIST
96460: LIST
96461: PUSH
96462: LD_INT 21
96464: PUSH
96465: LD_INT 2
96467: PUSH
96468: EMPTY
96469: LIST
96470: LIST
96471: PUSH
96472: EMPTY
96473: LIST
96474: LIST
96475: LIST
96476: PPUSH
96477: CALL_OW 69
96481: PUSH
96482: FOR_IN
96483: IFFALSE 96544
// if IsSelected ( i ) then
96485: LD_VAR 0 2
96489: PPUSH
96490: CALL_OW 306
96494: IFFALSE 96542
// begin if i in hInvincible then
96496: LD_VAR 0 2
96500: PUSH
96501: LD_EXP 139
96505: IN
96506: IFFALSE 96526
// hInvincible := hInvincible diff i else
96508: LD_ADDR_EXP 139
96512: PUSH
96513: LD_EXP 139
96517: PUSH
96518: LD_VAR 0 2
96522: DIFF
96523: ST_TO_ADDR
96524: GO 96542
// hInvincible := hInvincible union i ;
96526: LD_ADDR_EXP 139
96530: PUSH
96531: LD_EXP 139
96535: PUSH
96536: LD_VAR 0 2
96540: UNION
96541: ST_TO_ADDR
// end ;
96542: GO 96482
96544: POP
96545: POP
// end ;
96546: LD_VAR 0 1
96550: RET
// export function hHackInvisible ; var i , j ; begin
96551: LD_INT 0
96553: PPUSH
96554: PPUSH
96555: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
96556: LD_ADDR_VAR 0 2
96560: PUSH
96561: LD_INT 21
96563: PUSH
96564: LD_INT 1
96566: PUSH
96567: EMPTY
96568: LIST
96569: LIST
96570: PPUSH
96571: CALL_OW 69
96575: PUSH
96576: FOR_IN
96577: IFFALSE 96601
// if IsSelected ( i ) then
96579: LD_VAR 0 2
96583: PPUSH
96584: CALL_OW 306
96588: IFFALSE 96599
// ComForceInvisible ( i ) ;
96590: LD_VAR 0 2
96594: PPUSH
96595: CALL_OW 496
96599: GO 96576
96601: POP
96602: POP
// end ;
96603: LD_VAR 0 1
96607: RET
// export function hHackChangeYourSide ; begin
96608: LD_INT 0
96610: PPUSH
// if your_side = 8 then
96611: LD_OWVAR 2
96615: PUSH
96616: LD_INT 8
96618: EQUAL
96619: IFFALSE 96631
// your_side := 0 else
96621: LD_ADDR_OWVAR 2
96625: PUSH
96626: LD_INT 0
96628: ST_TO_ADDR
96629: GO 96645
// your_side := your_side + 1 ;
96631: LD_ADDR_OWVAR 2
96635: PUSH
96636: LD_OWVAR 2
96640: PUSH
96641: LD_INT 1
96643: PLUS
96644: ST_TO_ADDR
// end ;
96645: LD_VAR 0 1
96649: RET
// export function hHackChangeUnitSide ; var i , j ; begin
96650: LD_INT 0
96652: PPUSH
96653: PPUSH
96654: PPUSH
// for i in all_units do
96655: LD_ADDR_VAR 0 2
96659: PUSH
96660: LD_OWVAR 3
96664: PUSH
96665: FOR_IN
96666: IFFALSE 96744
// if IsSelected ( i ) then
96668: LD_VAR 0 2
96672: PPUSH
96673: CALL_OW 306
96677: IFFALSE 96742
// begin j := GetSide ( i ) ;
96679: LD_ADDR_VAR 0 3
96683: PUSH
96684: LD_VAR 0 2
96688: PPUSH
96689: CALL_OW 255
96693: ST_TO_ADDR
// if j = 8 then
96694: LD_VAR 0 3
96698: PUSH
96699: LD_INT 8
96701: EQUAL
96702: IFFALSE 96714
// j := 0 else
96704: LD_ADDR_VAR 0 3
96708: PUSH
96709: LD_INT 0
96711: ST_TO_ADDR
96712: GO 96728
// j := j + 1 ;
96714: LD_ADDR_VAR 0 3
96718: PUSH
96719: LD_VAR 0 3
96723: PUSH
96724: LD_INT 1
96726: PLUS
96727: ST_TO_ADDR
// SetSide ( i , j ) ;
96728: LD_VAR 0 2
96732: PPUSH
96733: LD_VAR 0 3
96737: PPUSH
96738: CALL_OW 235
// end ;
96742: GO 96665
96744: POP
96745: POP
// end ;
96746: LD_VAR 0 1
96750: RET
// export function hHackFog ; begin
96751: LD_INT 0
96753: PPUSH
// FogOff ( true ) ;
96754: LD_INT 1
96756: PPUSH
96757: CALL_OW 344
// end ;
96761: LD_VAR 0 1
96765: RET
// export function hHackTeleport ( unit , x , y ) ; begin
96766: LD_INT 0
96768: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
96769: LD_VAR 0 1
96773: PPUSH
96774: LD_VAR 0 2
96778: PPUSH
96779: LD_VAR 0 3
96783: PPUSH
96784: LD_INT 1
96786: PPUSH
96787: LD_INT 1
96789: PPUSH
96790: CALL_OW 483
// CenterOnXY ( x , y ) ;
96794: LD_VAR 0 2
96798: PPUSH
96799: LD_VAR 0 3
96803: PPUSH
96804: CALL_OW 84
// end ;
96808: LD_VAR 0 4
96812: RET
