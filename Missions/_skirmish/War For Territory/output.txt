// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitGlobalVariables ;
  11: CALL 81721 0 0
// InitVariables ;
  15: CALL 214 0 0
// if debug then
  19: LD_EXP 1
  23: IFFALSE 42
// begin FogOff ( 1 ) ;
  25: LD_INT 1
  27: PPUSH
  28: CALL_OW 344
// Difficulty := 2 ;
  32: LD_ADDR_OWVAR 67
  36: PUSH
  37: LD_INT 2
  39: ST_TO_ADDR
// end else
  40: GO 55
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  42: LD_ADDR_OWVAR 67
  46: PUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL_OW 426
  54: ST_TO_ADDR
// ChangeSideFog ( 4 , 1 ) ;
  55: LD_INT 4
  57: PPUSH
  58: LD_INT 1
  60: PPUSH
  61: CALL_OW 343
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , gensher_ape , 0 ) ;
  65: LD_INT 0
  67: PPUSH
  68: LD_INT 0
  70: PPUSH
  71: LD_INT 5
  73: PPUSH
  74: LD_INT 0
  76: PPUSH
  77: LD_INT 0
  79: PPUSH
  80: LD_INT 0
  82: PPUSH
  83: LD_INT 0
  85: PPUSH
  86: LD_INT 7
  88: PPUSH
  89: LD_INT 0
  91: PPUSH
  92: CALL 44367 0 9
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , powell_ape , 0 ) ;
  96: LD_INT 0
  98: PPUSH
  99: LD_INT 0
 101: PPUSH
 102: LD_INT 3
 104: PPUSH
 105: LD_INT 0
 107: PPUSH
 108: LD_INT 0
 110: PPUSH
 111: LD_INT 0
 113: PPUSH
 114: LD_INT 0
 116: PPUSH
 117: LD_INT 4
 119: PPUSH
 120: LD_INT 0
 122: PPUSH
 123: CALL 44367 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , popov_ape , 0 ) ;
 127: LD_INT 0
 129: PPUSH
 130: LD_INT 0
 132: PPUSH
 133: LD_INT 5
 135: PPUSH
 136: LD_INT 0
 138: PPUSH
 139: LD_INT 0
 141: PPUSH
 142: LD_INT 0
 144: PPUSH
 145: LD_INT 0
 147: PPUSH
 148: LD_INT 11
 150: PPUSH
 151: LD_INT 0
 153: PPUSH
 154: CALL 44367 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , sikorski_ape , 0 ) ;
 158: LD_INT 0
 160: PPUSH
 161: LD_INT 0
 163: PPUSH
 164: LD_INT 5
 166: PPUSH
 167: LD_INT 0
 169: PPUSH
 170: LD_INT 0
 172: PPUSH
 173: LD_INT 0
 175: PPUSH
 176: LD_INT 0
 178: PPUSH
 179: LD_INT 14
 181: PPUSH
 182: LD_INT 0
 184: PPUSH
 185: CALL 44367 0 9
// PrepareGensher ;
 189: CALL 3160 0 0
// PreparePopov ;
 193: CALL 6371 0 0
// PreparePowell ;
 197: CALL 593 0 0
// PrepareSikorski ;
 201: CALL 9059 0 0
// MC_Start ( ) ;
 205: CALL 53260 0 0
// Action ;
 209: CALL 9466 0 0
// end ;
 213: END
// export debug , game , staticMines , arDestroyed , ruDestroyed , loseCounter , powellLoseCounter , powellInTrouble , sikorskiInTrouble ; function InitVariables ; begin
 214: LD_INT 0
 216: PPUSH
// debug := false ;
 217: LD_ADDR_EXP 1
 221: PUSH
 222: LD_INT 0
 224: ST_TO_ADDR
// game := true ;
 225: LD_ADDR_EXP 2
 229: PUSH
 230: LD_INT 1
 232: ST_TO_ADDR
// staticMines := [ ] ;
 233: LD_ADDR_EXP 3
 237: PUSH
 238: EMPTY
 239: ST_TO_ADDR
// arDestroyed := false ;
 240: LD_ADDR_EXP 4
 244: PUSH
 245: LD_INT 0
 247: ST_TO_ADDR
// ruDestroyed := false ;
 248: LD_ADDR_EXP 5
 252: PUSH
 253: LD_INT 0
 255: ST_TO_ADDR
// powellInTrouble := false ;
 256: LD_ADDR_EXP 8
 260: PUSH
 261: LD_INT 0
 263: ST_TO_ADDR
// sikorskiInTrouble := false ;
 264: LD_ADDR_EXP 9
 268: PUSH
 269: LD_INT 0
 271: ST_TO_ADDR
// end ;
 272: LD_VAR 0 1
 276: RET
// export function CustomInitMacro ; begin
 277: LD_INT 0
 279: PPUSH
// InitMC_Gensher ( ) ;
 280: CALL 4294 0 0
// InitMC_Powell ( ) ;
 284: CALL 1515 0 0
// InitMC_Popov ( ) ;
 288: CALL 7529 0 0
// end ;
 292: LD_VAR 0 1
 296: RET
// every 0 0$10 do var cr , time , i ;
 297: GO 299
 299: DISABLE
 300: LD_INT 0
 302: PPUSH
 303: PPUSH
 304: PPUSH
// begin time := 0 0$20 ;
 305: LD_ADDR_VAR 0 2
 309: PUSH
 310: LD_INT 700
 312: ST_TO_ADDR
// repeat wait ( time ) ;
 313: LD_VAR 0 2
 317: PPUSH
 318: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
 322: LD_ADDR_VAR 0 1
 326: PUSH
 327: LD_INT 1
 329: PPUSH
 330: LD_INT 5
 332: PPUSH
 333: CALL_OW 12
 337: ST_TO_ADDR
// for i in [ powell_crates , gensher_crates , popov_crates , sikorski_crates ] do
 338: LD_ADDR_VAR 0 3
 342: PUSH
 343: LD_INT 5
 345: PUSH
 346: LD_INT 8
 348: PUSH
 349: LD_INT 12
 351: PUSH
 352: LD_INT 13
 354: PUSH
 355: EMPTY
 356: LIST
 357: LIST
 358: LIST
 359: LIST
 360: PUSH
 361: FOR_IN
 362: IFFALSE 416
// begin if GetResourceArea ( i , mat_cans ) < 40 then
 364: LD_VAR 0 3
 368: PPUSH
 369: LD_INT 1
 371: PPUSH
 372: CALL_OW 287
 376: PUSH
 377: LD_INT 40
 379: LESS
 380: IFFALSE 399
// CreateCratesArea ( cr , i , true ) ;
 382: LD_VAR 0 1
 386: PPUSH
 387: LD_VAR 0 3
 391: PPUSH
 392: LD_INT 1
 394: PPUSH
 395: CALL_OW 55
// wait ( rand ( 0 0$5 , 0 0$15 ) ) ;
 399: LD_INT 175
 401: PPUSH
 402: LD_INT 525
 404: PPUSH
 405: CALL_OW 12
 409: PPUSH
 410: CALL_OW 67
// end ;
 414: GO 361
 416: POP
 417: POP
// time := time + 0 0$2 ;
 418: LD_ADDR_VAR 0 2
 422: PUSH
 423: LD_VAR 0 2
 427: PUSH
 428: LD_INT 70
 430: PLUS
 431: ST_TO_ADDR
// if time > 0 0$35 then
 432: LD_VAR 0 2
 436: PUSH
 437: LD_INT 1225
 439: GREATER
 440: IFFALSE 450
// time := 0 0$25 ;
 442: LD_ADDR_VAR 0 2
 446: PUSH
 447: LD_INT 875
 449: ST_TO_ADDR
// until not game ;
 450: LD_EXP 2
 454: NOT
 455: IFFALSE 313
// end ;
 457: PPOPN 3
 459: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
 460: LD_INT 3
 462: PUSH
 463: LD_INT 22
 465: PUSH
 466: LD_INT 1
 468: PUSH
 469: EMPTY
 470: LIST
 471: LIST
 472: PUSH
 473: EMPTY
 474: LIST
 475: LIST
 476: PUSH
 477: LD_INT 32
 479: PUSH
 480: LD_INT 1
 482: PUSH
 483: EMPTY
 484: LIST
 485: LIST
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: PPUSH
 491: CALL_OW 69
 495: IFFALSE 590
 497: GO 499
 499: DISABLE
 500: LD_INT 0
 502: PPUSH
 503: PPUSH
// begin enable ;
 504: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
 505: LD_ADDR_VAR 0 2
 509: PUSH
 510: LD_INT 3
 512: PUSH
 513: LD_INT 22
 515: PUSH
 516: LD_INT 1
 518: PUSH
 519: EMPTY
 520: LIST
 521: LIST
 522: PUSH
 523: EMPTY
 524: LIST
 525: LIST
 526: PUSH
 527: LD_INT 32
 529: PUSH
 530: LD_INT 1
 532: PUSH
 533: EMPTY
 534: LIST
 535: LIST
 536: PUSH
 537: EMPTY
 538: LIST
 539: LIST
 540: PPUSH
 541: CALL_OW 69
 545: ST_TO_ADDR
// for i in tmp do
 546: LD_ADDR_VAR 0 1
 550: PUSH
 551: LD_VAR 0 2
 555: PUSH
 556: FOR_IN
 557: IFFALSE 588
// if GetFuel ( i ) < 5 then
 559: LD_VAR 0 1
 563: PPUSH
 564: CALL_OW 261
 568: PUSH
 569: LD_INT 5
 571: LESS
 572: IFFALSE 586
// SetFuel ( i , 5 ) ;
 574: LD_VAR 0 1
 578: PPUSH
 579: LD_INT 5
 581: PPUSH
 582: CALL_OW 240
 586: GO 556
 588: POP
 589: POP
// end ; end_of_file
 590: PPOPN 2
 592: END
// export Powell , powell_side , powellAttackGroup ; export function PreparePowell ; var i , list , b , tmp ; begin
 593: LD_INT 0
 595: PPUSH
 596: PPUSH
 597: PPUSH
 598: PPUSH
 599: PPUSH
// powell_side := 4 ;
 600: LD_ADDR_EXP 11
 604: PUSH
 605: LD_INT 4
 607: ST_TO_ADDR
// uc_side := powell_side ;
 608: LD_ADDR_OWVAR 20
 612: PUSH
 613: LD_EXP 11
 617: ST_TO_ADDR
// uc_nation := 1 ;
 618: LD_ADDR_OWVAR 21
 622: PUSH
 623: LD_INT 1
 625: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
 626: LD_ADDR_EXP 10
 630: PUSH
 631: LD_STRING Powell
 633: PPUSH
 634: CALL_OW 25
 638: ST_TO_ADDR
// SetSkill ( Powell , 1 , 7 ) ;
 639: LD_EXP 10
 643: PPUSH
 644: LD_INT 1
 646: PPUSH
 647: LD_INT 7
 649: PPUSH
 650: CALL_OW 237
// SetSkill ( Powell , 2 , 5 ) ;
 654: LD_EXP 10
 658: PPUSH
 659: LD_INT 2
 661: PPUSH
 662: LD_INT 5
 664: PPUSH
 665: CALL_OW 237
// SetSkill ( Powell , 3 , 6 ) ;
 669: LD_EXP 10
 673: PPUSH
 674: LD_INT 3
 676: PPUSH
 677: LD_INT 6
 679: PPUSH
 680: CALL_OW 237
// SetSkill ( Powell , 4 , 4 ) ;
 684: LD_EXP 10
 688: PPUSH
 689: LD_INT 4
 691: PPUSH
 692: LD_INT 4
 694: PPUSH
 695: CALL_OW 237
// PlaceHumanInUnit ( Powell , us_depot ) ;
 699: LD_EXP 10
 703: PPUSH
 704: LD_INT 4
 706: PPUSH
 707: CALL_OW 52
// list := [ [ b_barracks , 178 , 117 , 2 ] , [ b_oil_mine , 167 , 102 , 0 ] , [ b_lab , 200 , 111 , 4 , b_lab_weapon , b_lab_siberium ] , [ b_factory , 201 , 140 , 4 ] , [ b_solar_power , 206 , 124 , 3 ] , [ b_solar_power , 209 , 128 , 3 ] , [ b_solar_power , 211 , 132 , 3 ] , [ b_siberite_mine , 173 , 83 , 3 ] , [ b_lab , 186 , 103 , 2 , b_lab_computer , b_lab_opto ] , [ b_turret , 173 , 99 , 2 , us_heavy_gun ] , [ b_bunker , 174 , 102 , 2 , us_heavy_gun ] , [ b_bunker , 178 , 100 , 2 , us_heavy_gun ] , [ b_turret , 174 , 108 , 1 , us_rocket_launcher ] , [ b_turret , 182 , 122 , 1 , us_rocket_launcher ] , [ b_control_tower , 194 , 124 , 5 ] , [ b_turret , 184 , 141 , 1 , us_heavy_gun ] , [ b_turret , 183 , 131 , 2 , us_radar ] , [ b_turret , 194 , 146 , 4 , us_rocket_launcher ] , [ b_turret , 190 , 142 , 4 , us_rocket_launcher ] , [ b_siberite_power , 204 , 133 , 3 ] , [ b_solar_power , 201 , 133 , 3 ] , [ b_siberite_power , 199 , 119 , 5 ] ] ;
 711: LD_ADDR_VAR 0 3
 715: PUSH
 716: LD_INT 5
 718: PUSH
 719: LD_INT 178
 721: PUSH
 722: LD_INT 117
 724: PUSH
 725: LD_INT 2
 727: PUSH
 728: EMPTY
 729: LIST
 730: LIST
 731: LIST
 732: LIST
 733: PUSH
 734: LD_INT 29
 736: PUSH
 737: LD_INT 167
 739: PUSH
 740: LD_INT 102
 742: PUSH
 743: LD_INT 0
 745: PUSH
 746: EMPTY
 747: LIST
 748: LIST
 749: LIST
 750: LIST
 751: PUSH
 752: LD_INT 6
 754: PUSH
 755: LD_INT 200
 757: PUSH
 758: LD_INT 111
 760: PUSH
 761: LD_INT 4
 763: PUSH
 764: LD_INT 10
 766: PUSH
 767: LD_INT 11
 769: PUSH
 770: EMPTY
 771: LIST
 772: LIST
 773: LIST
 774: LIST
 775: LIST
 776: LIST
 777: PUSH
 778: LD_INT 3
 780: PUSH
 781: LD_INT 201
 783: PUSH
 784: LD_INT 140
 786: PUSH
 787: LD_INT 4
 789: PUSH
 790: EMPTY
 791: LIST
 792: LIST
 793: LIST
 794: LIST
 795: PUSH
 796: LD_INT 27
 798: PUSH
 799: LD_INT 206
 801: PUSH
 802: LD_INT 124
 804: PUSH
 805: LD_INT 3
 807: PUSH
 808: EMPTY
 809: LIST
 810: LIST
 811: LIST
 812: LIST
 813: PUSH
 814: LD_INT 27
 816: PUSH
 817: LD_INT 209
 819: PUSH
 820: LD_INT 128
 822: PUSH
 823: LD_INT 3
 825: PUSH
 826: EMPTY
 827: LIST
 828: LIST
 829: LIST
 830: LIST
 831: PUSH
 832: LD_INT 27
 834: PUSH
 835: LD_INT 211
 837: PUSH
 838: LD_INT 132
 840: PUSH
 841: LD_INT 3
 843: PUSH
 844: EMPTY
 845: LIST
 846: LIST
 847: LIST
 848: LIST
 849: PUSH
 850: LD_INT 30
 852: PUSH
 853: LD_INT 173
 855: PUSH
 856: LD_INT 83
 858: PUSH
 859: LD_INT 3
 861: PUSH
 862: EMPTY
 863: LIST
 864: LIST
 865: LIST
 866: LIST
 867: PUSH
 868: LD_INT 6
 870: PUSH
 871: LD_INT 186
 873: PUSH
 874: LD_INT 103
 876: PUSH
 877: LD_INT 2
 879: PUSH
 880: LD_INT 12
 882: PUSH
 883: LD_INT 15
 885: PUSH
 886: EMPTY
 887: LIST
 888: LIST
 889: LIST
 890: LIST
 891: LIST
 892: LIST
 893: PUSH
 894: LD_INT 33
 896: PUSH
 897: LD_INT 173
 899: PUSH
 900: LD_INT 99
 902: PUSH
 903: LD_INT 2
 905: PUSH
 906: LD_INT 6
 908: PUSH
 909: EMPTY
 910: LIST
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: PUSH
 916: LD_INT 32
 918: PUSH
 919: LD_INT 174
 921: PUSH
 922: LD_INT 102
 924: PUSH
 925: LD_INT 2
 927: PUSH
 928: LD_INT 6
 930: PUSH
 931: EMPTY
 932: LIST
 933: LIST
 934: LIST
 935: LIST
 936: LIST
 937: PUSH
 938: LD_INT 32
 940: PUSH
 941: LD_INT 178
 943: PUSH
 944: LD_INT 100
 946: PUSH
 947: LD_INT 2
 949: PUSH
 950: LD_INT 6
 952: PUSH
 953: EMPTY
 954: LIST
 955: LIST
 956: LIST
 957: LIST
 958: LIST
 959: PUSH
 960: LD_INT 33
 962: PUSH
 963: LD_INT 174
 965: PUSH
 966: LD_INT 108
 968: PUSH
 969: LD_INT 1
 971: PUSH
 972: LD_INT 7
 974: PUSH
 975: EMPTY
 976: LIST
 977: LIST
 978: LIST
 979: LIST
 980: LIST
 981: PUSH
 982: LD_INT 33
 984: PUSH
 985: LD_INT 182
 987: PUSH
 988: LD_INT 122
 990: PUSH
 991: LD_INT 1
 993: PUSH
 994: LD_INT 7
 996: PUSH
 997: EMPTY
 998: LIST
 999: LIST
1000: LIST
1001: LIST
1002: LIST
1003: PUSH
1004: LD_INT 36
1006: PUSH
1007: LD_INT 194
1009: PUSH
1010: LD_INT 124
1012: PUSH
1013: LD_INT 5
1015: PUSH
1016: EMPTY
1017: LIST
1018: LIST
1019: LIST
1020: LIST
1021: PUSH
1022: LD_INT 33
1024: PUSH
1025: LD_INT 184
1027: PUSH
1028: LD_INT 141
1030: PUSH
1031: LD_INT 1
1033: PUSH
1034: LD_INT 6
1036: PUSH
1037: EMPTY
1038: LIST
1039: LIST
1040: LIST
1041: LIST
1042: LIST
1043: PUSH
1044: LD_INT 33
1046: PUSH
1047: LD_INT 183
1049: PUSH
1050: LD_INT 131
1052: PUSH
1053: LD_INT 2
1055: PUSH
1056: LD_INT 11
1058: PUSH
1059: EMPTY
1060: LIST
1061: LIST
1062: LIST
1063: LIST
1064: LIST
1065: PUSH
1066: LD_INT 33
1068: PUSH
1069: LD_INT 194
1071: PUSH
1072: LD_INT 146
1074: PUSH
1075: LD_INT 4
1077: PUSH
1078: LD_INT 7
1080: PUSH
1081: EMPTY
1082: LIST
1083: LIST
1084: LIST
1085: LIST
1086: LIST
1087: PUSH
1088: LD_INT 33
1090: PUSH
1091: LD_INT 190
1093: PUSH
1094: LD_INT 142
1096: PUSH
1097: LD_INT 4
1099: PUSH
1100: LD_INT 7
1102: PUSH
1103: EMPTY
1104: LIST
1105: LIST
1106: LIST
1107: LIST
1108: LIST
1109: PUSH
1110: LD_INT 28
1112: PUSH
1113: LD_INT 204
1115: PUSH
1116: LD_INT 133
1118: PUSH
1119: LD_INT 3
1121: PUSH
1122: EMPTY
1123: LIST
1124: LIST
1125: LIST
1126: LIST
1127: PUSH
1128: LD_INT 27
1130: PUSH
1131: LD_INT 201
1133: PUSH
1134: LD_INT 133
1136: PUSH
1137: LD_INT 3
1139: PUSH
1140: EMPTY
1141: LIST
1142: LIST
1143: LIST
1144: LIST
1145: PUSH
1146: LD_INT 28
1148: PUSH
1149: LD_INT 199
1151: PUSH
1152: LD_INT 119
1154: PUSH
1155: LD_INT 5
1157: PUSH
1158: EMPTY
1159: LIST
1160: LIST
1161: LIST
1162: LIST
1163: PUSH
1164: EMPTY
1165: LIST
1166: LIST
1167: LIST
1168: LIST
1169: LIST
1170: LIST
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: LIST
1180: LIST
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: LIST
1186: LIST
1187: ST_TO_ADDR
// for i in list do
1188: LD_ADDR_VAR 0 2
1192: PUSH
1193: LD_VAR 0 3
1197: PUSH
1198: FOR_IN
1199: IFFALSE 1377
// begin uc_side := 4 ;
1201: LD_ADDR_OWVAR 20
1205: PUSH
1206: LD_INT 4
1208: ST_TO_ADDR
// uc_nation := 1 ;
1209: LD_ADDR_OWVAR 21
1213: PUSH
1214: LD_INT 1
1216: ST_TO_ADDR
// bc_type := i [ 1 ] ;
1217: LD_ADDR_OWVAR 42
1221: PUSH
1222: LD_VAR 0 2
1226: PUSH
1227: LD_INT 1
1229: ARRAY
1230: ST_TO_ADDR
// bc_kind1 := - 1 ;
1231: LD_ADDR_OWVAR 44
1235: PUSH
1236: LD_INT 1
1238: NEG
1239: ST_TO_ADDR
// bc_kind2 := - 1 ;
1240: LD_ADDR_OWVAR 45
1244: PUSH
1245: LD_INT 1
1247: NEG
1248: ST_TO_ADDR
// if i [ 1 ] = b_lab then
1249: LD_VAR 0 2
1253: PUSH
1254: LD_INT 1
1256: ARRAY
1257: PUSH
1258: LD_INT 6
1260: EQUAL
1261: IFFALSE 1299
// begin bc_type := b_lab_full ;
1263: LD_ADDR_OWVAR 42
1267: PUSH
1268: LD_INT 8
1270: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
1271: LD_ADDR_OWVAR 44
1275: PUSH
1276: LD_VAR 0 2
1280: PUSH
1281: LD_INT 5
1283: ARRAY
1284: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
1285: LD_ADDR_OWVAR 45
1289: PUSH
1290: LD_VAR 0 2
1294: PUSH
1295: LD_INT 6
1297: ARRAY
1298: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1299: LD_ADDR_VAR 0 4
1303: PUSH
1304: LD_VAR 0 2
1308: PUSH
1309: LD_INT 2
1311: ARRAY
1312: PPUSH
1313: LD_VAR 0 2
1317: PUSH
1318: LD_INT 3
1320: ARRAY
1321: PPUSH
1322: LD_VAR 0 2
1326: PUSH
1327: LD_INT 4
1329: ARRAY
1330: PPUSH
1331: CALL_OW 47
1335: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
1336: LD_VAR 0 2
1340: PUSH
1341: LD_INT 1
1343: ARRAY
1344: PUSH
1345: LD_INT 33
1347: PUSH
1348: LD_INT 32
1350: PUSH
1351: EMPTY
1352: LIST
1353: LIST
1354: IN
1355: IFFALSE 1375
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
1357: LD_VAR 0 4
1361: PPUSH
1362: LD_VAR 0 2
1366: PUSH
1367: LD_INT 5
1369: ARRAY
1370: PPUSH
1371: CALL_OW 431
// end ;
1375: GO 1198
1377: POP
1378: POP
// tmp := PrepareBase ( us_depot , powell_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 5500 , 500 , 0 ] , [ 6 , 6 , 6 , 6 ] ) ;
1379: LD_ADDR_VAR 0 5
1383: PUSH
1384: LD_INT 4
1386: PPUSH
1387: LD_INT 1
1389: PPUSH
1390: LD_STRING 
1392: PPUSH
1393: LD_INT 8
1395: PUSH
1396: LD_INT 7
1398: PUSH
1399: LD_INT 6
1401: PUSH
1402: EMPTY
1403: LIST
1404: LIST
1405: LIST
1406: PUSH
1407: LD_OWVAR 67
1411: ARRAY
1412: PPUSH
1413: LD_INT 5500
1415: PUSH
1416: LD_INT 500
1418: PUSH
1419: LD_INT 0
1421: PUSH
1422: EMPTY
1423: LIST
1424: LIST
1425: LIST
1426: PPUSH
1427: LD_INT 6
1429: PUSH
1430: LD_INT 6
1432: PUSH
1433: LD_INT 6
1435: PUSH
1436: LD_INT 6
1438: PUSH
1439: EMPTY
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: PPUSH
1445: CALL 19314 0 6
1449: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , tmp union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) ) ;
1450: LD_ADDR_EXP 23
1454: PUSH
1455: LD_EXP 23
1459: PPUSH
1460: LD_INT 1
1462: PPUSH
1463: LD_VAR 0 5
1467: PUSH
1468: LD_INT 22
1470: PUSH
1471: LD_INT 4
1473: PUSH
1474: EMPTY
1475: LIST
1476: LIST
1477: PUSH
1478: LD_INT 21
1480: PUSH
1481: LD_INT 3
1483: PUSH
1484: EMPTY
1485: LIST
1486: LIST
1487: PUSH
1488: EMPTY
1489: LIST
1490: LIST
1491: PPUSH
1492: CALL_OW 69
1496: UNION
1497: PPUSH
1498: CALL_OW 1
1502: ST_TO_ADDR
// powellAttackGroup := [ ] ;
1503: LD_ADDR_EXP 12
1507: PUSH
1508: EMPTY
1509: ST_TO_ADDR
// end ;
1510: LD_VAR 0 1
1514: RET
// export function InitMC_Powell ( ) ; begin
1515: LD_INT 0
1517: PPUSH
// MC_SetScanArea ( 1 , powell_base ) ;
1518: LD_INT 1
1520: PPUSH
1521: LD_INT 1
1523: PPUSH
1524: CALL 76588 0 2
// MC_SetParkingArea ( 1 , powell_parking ) ;
1528: LD_INT 1
1530: PPUSH
1531: LD_INT 6
1533: PPUSH
1534: CALL 76532 0 2
// MC_SetDepositsXY ( 1 , [ [ 167 , 102 , 0 ] , [ 173 , 83 , 1 ] , [ 171 , 141 , 0 ] , [ 178 , 148 , 1 ] ] ) ;
1538: LD_INT 1
1540: PPUSH
1541: LD_INT 167
1543: PUSH
1544: LD_INT 102
1546: PUSH
1547: LD_INT 0
1549: PUSH
1550: EMPTY
1551: LIST
1552: LIST
1553: LIST
1554: PUSH
1555: LD_INT 173
1557: PUSH
1558: LD_INT 83
1560: PUSH
1561: LD_INT 1
1563: PUSH
1564: EMPTY
1565: LIST
1566: LIST
1567: LIST
1568: PUSH
1569: LD_INT 171
1571: PUSH
1572: LD_INT 141
1574: PUSH
1575: LD_INT 0
1577: PUSH
1578: EMPTY
1579: LIST
1580: LIST
1581: LIST
1582: PUSH
1583: LD_INT 178
1585: PUSH
1586: LD_INT 148
1588: PUSH
1589: LD_INT 1
1591: PUSH
1592: EMPTY
1593: LIST
1594: LIST
1595: LIST
1596: PUSH
1597: EMPTY
1598: LIST
1599: LIST
1600: LIST
1601: LIST
1602: PPUSH
1603: CALL 75591 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ us_radar , us_heavy_gun , us_rocket_launcher ] ) ;
1607: LD_INT 1
1609: PPUSH
1610: LD_INT 11
1612: PUSH
1613: LD_INT 6
1615: PUSH
1616: LD_INT 7
1618: PUSH
1619: EMPTY
1620: LIST
1621: LIST
1622: LIST
1623: PPUSH
1624: CALL 76420 0 2
// MC_SetCratesArea ( 1 , powell_crates ) ;
1628: LD_INT 1
1630: PPUSH
1631: LD_INT 5
1633: PPUSH
1634: CALL 76102 0 2
// MC_SetTame ( 1 , powell_ape ) ;
1638: LD_INT 1
1640: PPUSH
1641: LD_INT 4
1643: PPUSH
1644: CALL 75833 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
1648: LD_INT 1
1650: PPUSH
1651: LD_INT 4
1653: PPUSH
1654: CALL 75452 0 2
// MC_SetProduceList ( 1 , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ] ) ;
1658: LD_INT 1
1660: PPUSH
1661: LD_INT 3
1663: PUSH
1664: LD_INT 1
1666: PUSH
1667: LD_INT 2
1669: PUSH
1670: LD_INT 5
1672: PUSH
1673: EMPTY
1674: LIST
1675: LIST
1676: LIST
1677: LIST
1678: PUSH
1679: LD_INT 4
1681: PUSH
1682: LD_INT 1
1684: PUSH
1685: LD_INT 2
1687: PUSH
1688: LD_INT 6
1690: PUSH
1691: EMPTY
1692: LIST
1693: LIST
1694: LIST
1695: LIST
1696: PUSH
1697: LD_INT 4
1699: PUSH
1700: LD_INT 1
1702: PUSH
1703: LD_INT 2
1705: PUSH
1706: LD_INT 7
1708: PUSH
1709: EMPTY
1710: LIST
1711: LIST
1712: LIST
1713: LIST
1714: PUSH
1715: LD_INT 4
1717: PUSH
1718: LD_INT 1
1720: PUSH
1721: LD_INT 2
1723: PUSH
1724: LD_INT 6
1726: PUSH
1727: EMPTY
1728: LIST
1729: LIST
1730: LIST
1731: LIST
1732: PUSH
1733: EMPTY
1734: LIST
1735: LIST
1736: LIST
1737: LIST
1738: PPUSH
1739: CALL 75267 0 2
// MC_SetFactoryExtension ( 1 , 201 , 140 , 4 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1743: LD_INT 1
1745: PPUSH
1746: LD_INT 201
1748: PPUSH
1749: LD_INT 140
1751: PPUSH
1752: LD_INT 4
1754: PPUSH
1755: LD_INT 19
1757: PUSH
1758: LD_INT 16
1760: PUSH
1761: LD_INT 17
1763: PUSH
1764: LD_INT 18
1766: PUSH
1767: LD_INT 22
1769: PUSH
1770: EMPTY
1771: LIST
1772: LIST
1773: LIST
1774: LIST
1775: LIST
1776: PPUSH
1777: CALL 76214 0 5
// end ;
1781: LD_VAR 0 1
1785: RET
// every 8 8$00 + 2 2$00 trigger IsOk ( us_depot ) do var i , base , tmp , attackers , amount ;
1786: LD_INT 4
1788: PPUSH
1789: CALL_OW 302
1793: IFFALSE 2453
1795: GO 1797
1797: DISABLE
1798: LD_INT 0
1800: PPUSH
1801: PPUSH
1802: PPUSH
1803: PPUSH
1804: PPUSH
// begin enable ;
1805: ENABLE
// base := 1 ;
1806: LD_ADDR_VAR 0 2
1810: PUSH
1811: LD_INT 1
1813: ST_TO_ADDR
// tmp := [ [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ] ;
1814: LD_ADDR_VAR 0 3
1818: PUSH
1819: LD_INT 4
1821: PUSH
1822: LD_INT 1
1824: PUSH
1825: LD_INT 2
1827: PUSH
1828: LD_INT 6
1830: PUSH
1831: EMPTY
1832: LIST
1833: LIST
1834: LIST
1835: LIST
1836: PUSH
1837: LD_INT 4
1839: PUSH
1840: LD_INT 1
1842: PUSH
1843: LD_INT 2
1845: PUSH
1846: LD_INT 6
1848: PUSH
1849: EMPTY
1850: LIST
1851: LIST
1852: LIST
1853: LIST
1854: PUSH
1855: LD_INT 3
1857: PUSH
1858: LD_INT 1
1860: PUSH
1861: LD_INT 2
1863: PUSH
1864: LD_INT 7
1866: PUSH
1867: EMPTY
1868: LIST
1869: LIST
1870: LIST
1871: LIST
1872: PUSH
1873: LD_INT 3
1875: PUSH
1876: LD_INT 1
1878: PUSH
1879: LD_INT 2
1881: PUSH
1882: LD_INT 7
1884: PUSH
1885: EMPTY
1886: LIST
1887: LIST
1888: LIST
1889: LIST
1890: PUSH
1891: EMPTY
1892: LIST
1893: LIST
1894: LIST
1895: LIST
1896: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
1897: LD_ADDR_VAR 0 5
1901: PUSH
1902: LD_VAR 0 5
1906: PUSH
1907: LD_OWVAR 1
1911: PUSH
1912: LD_INT 21000
1914: DIV
1915: PLUS
1916: ST_TO_ADDR
// if amount > 8 then
1917: LD_VAR 0 5
1921: PUSH
1922: LD_INT 8
1924: GREATER
1925: IFFALSE 1935
// amount := 8 ;
1927: LD_ADDR_VAR 0 5
1931: PUSH
1932: LD_INT 8
1934: ST_TO_ADDR
// for i = 1 to amount do
1935: LD_ADDR_VAR 0 1
1939: PUSH
1940: DOUBLE
1941: LD_INT 1
1943: DEC
1944: ST_TO_ADDR
1945: LD_VAR 0 5
1949: PUSH
1950: FOR_TO
1951: IFFALSE 2035
// tmp := Insert ( tmp , tmp + 1 , [ [ us_medium_tracked , us_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ us_rocket_launcher , us_double_gun ] [ rand ( 1 , 2 ) ] ] ) ;
1953: LD_ADDR_VAR 0 3
1957: PUSH
1958: LD_VAR 0 3
1962: PPUSH
1963: LD_VAR 0 3
1967: PUSH
1968: LD_INT 1
1970: PLUS
1971: PPUSH
1972: LD_INT 3
1974: PUSH
1975: LD_INT 4
1977: PUSH
1978: EMPTY
1979: LIST
1980: LIST
1981: PUSH
1982: LD_INT 1
1984: PPUSH
1985: LD_INT 2
1987: PPUSH
1988: CALL_OW 12
1992: ARRAY
1993: PUSH
1994: LD_INT 1
1996: PUSH
1997: LD_INT 2
1999: PUSH
2000: LD_INT 7
2002: PUSH
2003: LD_INT 5
2005: PUSH
2006: EMPTY
2007: LIST
2008: LIST
2009: PUSH
2010: LD_INT 1
2012: PPUSH
2013: LD_INT 2
2015: PPUSH
2016: CALL_OW 12
2020: ARRAY
2021: PUSH
2022: EMPTY
2023: LIST
2024: LIST
2025: LIST
2026: LIST
2027: PPUSH
2028: CALL_OW 2
2032: ST_TO_ADDR
2033: GO 1950
2035: POP
2036: POP
// MC_InsertProduceList ( base , tmp ) ;
2037: LD_VAR 0 2
2041: PPUSH
2042: LD_VAR 0 3
2046: PPUSH
2047: CALL 75315 0 2
// repeat wait ( 0 0$1 ) ;
2051: LD_INT 35
2053: PPUSH
2054: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
2058: LD_VAR 0 2
2062: PPUSH
2063: LD_INT 1
2065: PPUSH
2066: CALL 76733 0 2
2070: PUSH
2071: LD_VAR 0 5
2075: GREATEREQUAL
2076: IFFALSE 2051
// wait ( 0 0$30 ) ;
2078: LD_INT 1050
2080: PPUSH
2081: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , us_bulldozer ] ] ) ;
2085: LD_ADDR_VAR 0 4
2089: PUSH
2090: LD_EXP 42
2094: PUSH
2095: LD_VAR 0 2
2099: ARRAY
2100: PUSH
2101: LD_EXP 42
2105: PUSH
2106: LD_VAR 0 2
2110: ARRAY
2111: PPUSH
2112: LD_INT 2
2114: PUSH
2115: LD_INT 34
2117: PUSH
2118: LD_INT 12
2120: PUSH
2121: EMPTY
2122: LIST
2123: LIST
2124: PUSH
2125: LD_INT 34
2127: PUSH
2128: LD_INT 13
2130: PUSH
2131: EMPTY
2132: LIST
2133: LIST
2134: PUSH
2135: LD_INT 34
2137: PUSH
2138: LD_INT 14
2140: PUSH
2141: EMPTY
2142: LIST
2143: LIST
2144: PUSH
2145: EMPTY
2146: LIST
2147: LIST
2148: LIST
2149: LIST
2150: PPUSH
2151: CALL_OW 72
2155: DIFF
2156: ST_TO_ADDR
// if not attackers then
2157: LD_VAR 0 4
2161: NOT
2162: IFFALSE 2166
// exit ;
2164: GO 2453
// DialogPowellsAttack ;
2166: CALL 9597 0 0
// powellAttackGroup := attackers ;
2170: LD_ADDR_EXP 12
2174: PUSH
2175: LD_VAR 0 4
2179: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
2180: LD_ADDR_EXP 42
2184: PUSH
2185: LD_EXP 42
2189: PPUSH
2190: LD_VAR 0 2
2194: PPUSH
2195: LD_EXP 42
2199: PUSH
2200: LD_VAR 0 2
2204: ARRAY
2205: PUSH
2206: LD_VAR 0 4
2210: DIFF
2211: PPUSH
2212: CALL_OW 1
2216: ST_TO_ADDR
// if sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 4 ] ) then
2217: LD_EXP 9
2221: PUSH
2222: LD_INT 16
2224: PPUSH
2225: LD_INT 81
2227: PUSH
2228: LD_INT 4
2230: PUSH
2231: EMPTY
2232: LIST
2233: LIST
2234: PPUSH
2235: CALL_OW 70
2239: AND
2240: IFFALSE 2259
// ComAgressiveMove ( attackers , 135 , 21 ) else
2242: LD_VAR 0 4
2246: PPUSH
2247: LD_INT 135
2249: PPUSH
2250: LD_INT 21
2252: PPUSH
2253: CALL_OW 114
2257: GO 2274
// ComAgressiveMove ( attackers , 146 , 103 ) ;
2259: LD_VAR 0 4
2263: PPUSH
2264: LD_INT 146
2266: PPUSH
2267: LD_INT 103
2269: PPUSH
2270: CALL_OW 114
// wait ( 0 0$5 ) ;
2274: LD_INT 175
2276: PPUSH
2277: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
2281: LD_INT 35
2283: PPUSH
2284: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
2288: LD_VAR 0 4
2292: PPUSH
2293: LD_INT 60
2295: PUSH
2296: EMPTY
2297: LIST
2298: PPUSH
2299: CALL_OW 72
2303: NOT
2304: IFFALSE 2281
// if FilterAllUnits ( [ f_side , 3 ] ) then
2306: LD_INT 22
2308: PUSH
2309: LD_INT 3
2311: PUSH
2312: EMPTY
2313: LIST
2314: LIST
2315: PPUSH
2316: CALL_OW 69
2320: IFFALSE 2339
// ComAgressiveMove ( attackers , 102 , 116 ) else
2322: LD_VAR 0 4
2326: PPUSH
2327: LD_INT 102
2329: PPUSH
2330: LD_INT 116
2332: PPUSH
2333: CALL_OW 114
2337: GO 2354
// ComAgressiveMove ( attackers , 66 , 41 ) ;
2339: LD_VAR 0 4
2343: PPUSH
2344: LD_INT 66
2346: PPUSH
2347: LD_INT 41
2349: PPUSH
2350: CALL_OW 114
// wait ( 0 0$10 ) ;
2354: LD_INT 350
2356: PPUSH
2357: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
2361: LD_INT 35
2363: PPUSH
2364: CALL_OW 67
// for i in attackers do
2368: LD_ADDR_VAR 0 1
2372: PUSH
2373: LD_VAR 0 4
2377: PUSH
2378: FOR_IN
2379: IFFALSE 2429
// if not HasTask ( i ) then
2381: LD_VAR 0 1
2385: PPUSH
2386: CALL_OW 314
2390: NOT
2391: IFFALSE 2427
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) ;
2393: LD_VAR 0 1
2397: PPUSH
2398: LD_INT 81
2400: PUSH
2401: LD_INT 4
2403: PUSH
2404: EMPTY
2405: LIST
2406: LIST
2407: PPUSH
2408: CALL_OW 69
2412: PPUSH
2413: LD_VAR 0 1
2417: PPUSH
2418: CALL_OW 74
2422: PPUSH
2423: CALL_OW 115
2427: GO 2378
2429: POP
2430: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
2431: LD_VAR 0 4
2435: PPUSH
2436: LD_INT 50
2438: PUSH
2439: EMPTY
2440: LIST
2441: PPUSH
2442: CALL_OW 72
2446: NOT
2447: IFFALSE 2361
// DialogPowellsAttackFailed ;
2449: CALL 9862 0 0
// end ;
2453: PPOPN 5
2455: END
// every 0 0$2 do var vehicles , mechs , i ;
2456: GO 2458
2458: DISABLE
2459: LD_INT 0
2461: PPUSH
2462: PPUSH
2463: PPUSH
// begin enable ;
2464: ENABLE
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] , [ f_distxy , 191 , 140 , 10 ] ] ) ;
2465: LD_ADDR_VAR 0 1
2469: PUSH
2470: LD_INT 22
2472: PUSH
2473: LD_INT 1
2475: PUSH
2476: EMPTY
2477: LIST
2478: LIST
2479: PUSH
2480: LD_INT 21
2482: PUSH
2483: LD_INT 2
2485: PUSH
2486: EMPTY
2487: LIST
2488: LIST
2489: PUSH
2490: LD_INT 3
2492: PUSH
2493: LD_INT 24
2495: PUSH
2496: LD_INT 1000
2498: PUSH
2499: EMPTY
2500: LIST
2501: LIST
2502: PUSH
2503: EMPTY
2504: LIST
2505: LIST
2506: PUSH
2507: LD_INT 92
2509: PUSH
2510: LD_INT 191
2512: PUSH
2513: LD_INT 140
2515: PUSH
2516: LD_INT 10
2518: PUSH
2519: EMPTY
2520: LIST
2521: LIST
2522: LIST
2523: LIST
2524: PUSH
2525: EMPTY
2526: LIST
2527: LIST
2528: LIST
2529: LIST
2530: PPUSH
2531: CALL_OW 69
2535: ST_TO_ADDR
// mechs := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 3 ] ] ) ;
2536: LD_ADDR_VAR 0 2
2540: PUSH
2541: LD_INT 22
2543: PUSH
2544: LD_INT 4
2546: PUSH
2547: EMPTY
2548: LIST
2549: LIST
2550: PUSH
2551: LD_INT 25
2553: PUSH
2554: LD_INT 3
2556: PUSH
2557: EMPTY
2558: LIST
2559: LIST
2560: PUSH
2561: EMPTY
2562: LIST
2563: LIST
2564: PPUSH
2565: CALL_OW 69
2569: ST_TO_ADDR
// if not mechs then
2570: LD_VAR 0 2
2574: NOT
2575: IFFALSE 2579
// exit ;
2577: GO 2753
// if mc_remote_driver [ 1 ] then
2579: LD_EXP 63
2583: PUSH
2584: LD_INT 1
2586: ARRAY
2587: IFFALSE 2609
// mechs := mechs diff mc_remote_driver [ 1 ] ;
2589: LD_ADDR_VAR 0 2
2593: PUSH
2594: LD_VAR 0 2
2598: PUSH
2599: LD_EXP 63
2603: PUSH
2604: LD_INT 1
2606: ARRAY
2607: DIFF
2608: ST_TO_ADDR
// if not mechs then
2609: LD_VAR 0 2
2613: NOT
2614: IFFALSE 2618
// exit ;
2616: GO 2753
// if vehicles then
2618: LD_VAR 0 1
2622: IFFALSE 2710
// begin for i in mechs do
2624: LD_ADDR_VAR 0 3
2628: PUSH
2629: LD_VAR 0 2
2633: PUSH
2634: FOR_IN
2635: IFFALSE 2706
// begin if GetTag ( i ) <> 120 then
2637: LD_VAR 0 3
2641: PPUSH
2642: CALL_OW 110
2646: PUSH
2647: LD_INT 120
2649: NONEQUAL
2650: IFFALSE 2664
// SetTag ( i , 120 ) ;
2652: LD_VAR 0 3
2656: PPUSH
2657: LD_INT 120
2659: PPUSH
2660: CALL_OW 109
// if IsInUnit ( i ) then
2664: LD_VAR 0 3
2668: PPUSH
2669: CALL_OW 310
2673: IFFALSE 2686
// ComExitBuilding ( i ) else
2675: LD_VAR 0 3
2679: PPUSH
2680: CALL_OW 122
2684: GO 2704
// ComRepairVehicle ( i , vehicles [ 1 ] ) ;
2686: LD_VAR 0 3
2690: PPUSH
2691: LD_VAR 0 1
2695: PUSH
2696: LD_INT 1
2698: ARRAY
2699: PPUSH
2700: CALL_OW 129
// end ;
2704: GO 2634
2706: POP
2707: POP
// end else
2708: GO 2753
// if FilterByTag ( mechs , 120 ) then
2710: LD_VAR 0 2
2714: PPUSH
2715: LD_INT 120
2717: PPUSH
2718: CALL 45259 0 2
2722: IFFALSE 2753
// begin for i in mechs do
2724: LD_ADDR_VAR 0 3
2728: PUSH
2729: LD_VAR 0 2
2733: PUSH
2734: FOR_IN
2735: IFFALSE 2751
// begin SetTag ( i , 0 ) ;
2737: LD_VAR 0 3
2741: PPUSH
2742: LD_INT 0
2744: PPUSH
2745: CALL_OW 109
// end ;
2749: GO 2734
2751: POP
2752: POP
// end ; end ;
2753: PPOPN 3
2755: END
// every 0 0$2 do var people , sci , i ;
2756: GO 2758
2758: DISABLE
2759: LD_INT 0
2761: PPUSH
2762: PPUSH
2763: PPUSH
// begin enable ;
2764: ENABLE
// people := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] , [ f_distxy , 188 , 112 , 10 ] ] ) ;
2765: LD_ADDR_VAR 0 1
2769: PUSH
2770: LD_INT 22
2772: PUSH
2773: LD_INT 1
2775: PUSH
2776: EMPTY
2777: LIST
2778: LIST
2779: PUSH
2780: LD_INT 21
2782: PUSH
2783: LD_INT 1
2785: PUSH
2786: EMPTY
2787: LIST
2788: LIST
2789: PUSH
2790: LD_INT 3
2792: PUSH
2793: LD_INT 24
2795: PUSH
2796: LD_INT 1000
2798: PUSH
2799: EMPTY
2800: LIST
2801: LIST
2802: PUSH
2803: EMPTY
2804: LIST
2805: LIST
2806: PUSH
2807: LD_INT 92
2809: PUSH
2810: LD_INT 188
2812: PUSH
2813: LD_INT 112
2815: PUSH
2816: LD_INT 10
2818: PUSH
2819: EMPTY
2820: LIST
2821: LIST
2822: LIST
2823: LIST
2824: PUSH
2825: EMPTY
2826: LIST
2827: LIST
2828: LIST
2829: LIST
2830: PPUSH
2831: CALL_OW 69
2835: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 4 ] ] ) ;
2836: LD_ADDR_VAR 0 2
2840: PUSH
2841: LD_INT 22
2843: PUSH
2844: LD_INT 4
2846: PUSH
2847: EMPTY
2848: LIST
2849: LIST
2850: PUSH
2851: LD_INT 25
2853: PUSH
2854: LD_INT 4
2856: PUSH
2857: EMPTY
2858: LIST
2859: LIST
2860: PUSH
2861: EMPTY
2862: LIST
2863: LIST
2864: PPUSH
2865: CALL_OW 69
2869: ST_TO_ADDR
// if not sci then
2870: LD_VAR 0 2
2874: NOT
2875: IFFALSE 2879
// exit ;
2877: GO 3014
// if people then
2879: LD_VAR 0 1
2883: IFFALSE 2971
// begin for i in sci do
2885: LD_ADDR_VAR 0 3
2889: PUSH
2890: LD_VAR 0 2
2894: PUSH
2895: FOR_IN
2896: IFFALSE 2967
// begin if GetTag ( i ) <> 102 then
2898: LD_VAR 0 3
2902: PPUSH
2903: CALL_OW 110
2907: PUSH
2908: LD_INT 102
2910: NONEQUAL
2911: IFFALSE 2925
// SetTag ( i , 102 ) ;
2913: LD_VAR 0 3
2917: PPUSH
2918: LD_INT 102
2920: PPUSH
2921: CALL_OW 109
// if IsInUnit ( i ) then
2925: LD_VAR 0 3
2929: PPUSH
2930: CALL_OW 310
2934: IFFALSE 2947
// ComExitBuilding ( i ) else
2936: LD_VAR 0 3
2940: PPUSH
2941: CALL_OW 122
2945: GO 2965
// ComHeal ( i , people [ 1 ] ) ;
2947: LD_VAR 0 3
2951: PPUSH
2952: LD_VAR 0 1
2956: PUSH
2957: LD_INT 1
2959: ARRAY
2960: PPUSH
2961: CALL_OW 128
// end ;
2965: GO 2895
2967: POP
2968: POP
// end else
2969: GO 3014
// if FilterByTag ( sci , 102 ) then
2971: LD_VAR 0 2
2975: PPUSH
2976: LD_INT 102
2978: PPUSH
2979: CALL 45259 0 2
2983: IFFALSE 3014
// begin for i in sci do
2985: LD_ADDR_VAR 0 3
2989: PUSH
2990: LD_VAR 0 2
2994: PUSH
2995: FOR_IN
2996: IFFALSE 3012
// begin SetTag ( i , 0 ) ;
2998: LD_VAR 0 3
3002: PPUSH
3003: LD_INT 0
3005: PPUSH
3006: CALL_OW 109
// end ;
3010: GO 2995
3012: POP
3013: POP
// end ; end ;
3014: PPOPN 3
3016: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 4 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
3017: LD_INT 22
3019: PUSH
3020: LD_INT 4
3022: PUSH
3023: EMPTY
3024: LIST
3025: LIST
3026: PUSH
3027: LD_INT 33
3029: PUSH
3030: LD_INT 2
3032: PUSH
3033: EMPTY
3034: LIST
3035: LIST
3036: PUSH
3037: LD_INT 50
3039: PUSH
3040: EMPTY
3041: LIST
3042: PUSH
3043: LD_INT 3
3045: PUSH
3046: LD_INT 61
3048: PUSH
3049: EMPTY
3050: LIST
3051: PUSH
3052: EMPTY
3053: LIST
3054: LIST
3055: PUSH
3056: EMPTY
3057: LIST
3058: LIST
3059: LIST
3060: LIST
3061: PPUSH
3062: CALL_OW 69
3066: IFFALSE 3157
3068: GO 3070
3070: DISABLE
3071: LD_INT 0
3073: PPUSH
3074: PPUSH
// begin enable ;
3075: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
3076: LD_ADDR_VAR 0 2
3080: PUSH
3081: LD_INT 22
3083: PUSH
3084: LD_INT 4
3086: PUSH
3087: EMPTY
3088: LIST
3089: LIST
3090: PUSH
3091: LD_INT 33
3093: PUSH
3094: LD_INT 2
3096: PUSH
3097: EMPTY
3098: LIST
3099: LIST
3100: PUSH
3101: LD_INT 50
3103: PUSH
3104: EMPTY
3105: LIST
3106: PUSH
3107: LD_INT 3
3109: PUSH
3110: LD_INT 61
3112: PUSH
3113: EMPTY
3114: LIST
3115: PUSH
3116: EMPTY
3117: LIST
3118: LIST
3119: PUSH
3120: EMPTY
3121: LIST
3122: LIST
3123: LIST
3124: LIST
3125: PPUSH
3126: CALL_OW 69
3130: ST_TO_ADDR
// for i in tmp do
3131: LD_ADDR_VAR 0 1
3135: PUSH
3136: LD_VAR 0 2
3140: PUSH
3141: FOR_IN
3142: IFFALSE 3155
// Connect ( i ) ;
3144: LD_VAR 0 1
3148: PPUSH
3149: CALL 18961 0 1
3153: GO 3141
3155: POP
3156: POP
// end ; end_of_file
3157: PPOPN 2
3159: END
// export Gensher , gensher_side , gensherAttackGroup ; export function PrepareGensher ; var i , b , tmp , un , list ; begin
3160: LD_INT 0
3162: PPUSH
3163: PPUSH
3164: PPUSH
3165: PPUSH
3166: PPUSH
3167: PPUSH
// gensher_side := 2 ;
3168: LD_ADDR_EXP 14
3172: PUSH
3173: LD_INT 2
3175: ST_TO_ADDR
// uc_side := gensher_side ;
3176: LD_ADDR_OWVAR 20
3180: PUSH
3181: LD_EXP 14
3185: ST_TO_ADDR
// uc_nation := 2 ;
3186: LD_ADDR_OWVAR 21
3190: PUSH
3191: LD_INT 2
3193: ST_TO_ADDR
// list := [ [ b_barracks , 42 , 29 , 5 ] , [ b_barracks , 36 , 40 , 5 ] , [ b_lab , 13 , 18 , 1 , b_lab_weapon , b_lab_opto ] , [ b_solar_power , 17 , 3 , 0 ] , [ b_oil_mine , 56 , 23 , 0 ] , [ b_factory , 11 , 7 , 2 ] , [ b_solar_power , 20 , 3 , 0 ] , [ b_solar_power , 23 , 3 , 0 ] , [ b_solar_power , 26 , 3 , 0 ] , [ b_lab , 17 , 27 , 1 , b_lab_biological , b_lab_siberium ] , [ b_bunker , 27 , 44 , 5 , ar_gun ] , [ b_bunker , 41 , 41 , 5 , ar_gun ] , [ b_bunker , 45 , 24 , 5 , ar_rocket_launcher ] , [ b_bunker , 48 , 19 , 5 , ar_rocket_launcher ] , [ b_bunker , 41 , 3 , 4 , ar_rocket_launcher ] , [ b_barracks , 44 , 9 , 4 ] , [ b_siberite_mine , 52 , 40 , 3 ] ] ;
3194: LD_ADDR_VAR 0 6
3198: PUSH
3199: LD_INT 5
3201: PUSH
3202: LD_INT 42
3204: PUSH
3205: LD_INT 29
3207: PUSH
3208: LD_INT 5
3210: PUSH
3211: EMPTY
3212: LIST
3213: LIST
3214: LIST
3215: LIST
3216: PUSH
3217: LD_INT 5
3219: PUSH
3220: LD_INT 36
3222: PUSH
3223: LD_INT 40
3225: PUSH
3226: LD_INT 5
3228: PUSH
3229: EMPTY
3230: LIST
3231: LIST
3232: LIST
3233: LIST
3234: PUSH
3235: LD_INT 6
3237: PUSH
3238: LD_INT 13
3240: PUSH
3241: LD_INT 18
3243: PUSH
3244: LD_INT 1
3246: PUSH
3247: LD_INT 10
3249: PUSH
3250: LD_INT 15
3252: PUSH
3253: EMPTY
3254: LIST
3255: LIST
3256: LIST
3257: LIST
3258: LIST
3259: LIST
3260: PUSH
3261: LD_INT 27
3263: PUSH
3264: LD_INT 17
3266: PUSH
3267: LD_INT 3
3269: PUSH
3270: LD_INT 0
3272: PUSH
3273: EMPTY
3274: LIST
3275: LIST
3276: LIST
3277: LIST
3278: PUSH
3279: LD_INT 29
3281: PUSH
3282: LD_INT 56
3284: PUSH
3285: LD_INT 23
3287: PUSH
3288: LD_INT 0
3290: PUSH
3291: EMPTY
3292: LIST
3293: LIST
3294: LIST
3295: LIST
3296: PUSH
3297: LD_INT 3
3299: PUSH
3300: LD_INT 11
3302: PUSH
3303: LD_INT 7
3305: PUSH
3306: LD_INT 2
3308: PUSH
3309: EMPTY
3310: LIST
3311: LIST
3312: LIST
3313: LIST
3314: PUSH
3315: LD_INT 27
3317: PUSH
3318: LD_INT 20
3320: PUSH
3321: LD_INT 3
3323: PUSH
3324: LD_INT 0
3326: PUSH
3327: EMPTY
3328: LIST
3329: LIST
3330: LIST
3331: LIST
3332: PUSH
3333: LD_INT 27
3335: PUSH
3336: LD_INT 23
3338: PUSH
3339: LD_INT 3
3341: PUSH
3342: LD_INT 0
3344: PUSH
3345: EMPTY
3346: LIST
3347: LIST
3348: LIST
3349: LIST
3350: PUSH
3351: LD_INT 27
3353: PUSH
3354: LD_INT 26
3356: PUSH
3357: LD_INT 3
3359: PUSH
3360: LD_INT 0
3362: PUSH
3363: EMPTY
3364: LIST
3365: LIST
3366: LIST
3367: LIST
3368: PUSH
3369: LD_INT 6
3371: PUSH
3372: LD_INT 17
3374: PUSH
3375: LD_INT 27
3377: PUSH
3378: LD_INT 1
3380: PUSH
3381: LD_INT 13
3383: PUSH
3384: LD_INT 11
3386: PUSH
3387: EMPTY
3388: LIST
3389: LIST
3390: LIST
3391: LIST
3392: LIST
3393: LIST
3394: PUSH
3395: LD_INT 32
3397: PUSH
3398: LD_INT 27
3400: PUSH
3401: LD_INT 44
3403: PUSH
3404: LD_INT 5
3406: PUSH
3407: LD_INT 27
3409: PUSH
3410: EMPTY
3411: LIST
3412: LIST
3413: LIST
3414: LIST
3415: LIST
3416: PUSH
3417: LD_INT 32
3419: PUSH
3420: LD_INT 41
3422: PUSH
3423: LD_INT 41
3425: PUSH
3426: LD_INT 5
3428: PUSH
3429: LD_INT 27
3431: PUSH
3432: EMPTY
3433: LIST
3434: LIST
3435: LIST
3436: LIST
3437: LIST
3438: PUSH
3439: LD_INT 32
3441: PUSH
3442: LD_INT 45
3444: PUSH
3445: LD_INT 24
3447: PUSH
3448: LD_INT 5
3450: PUSH
3451: LD_INT 28
3453: PUSH
3454: EMPTY
3455: LIST
3456: LIST
3457: LIST
3458: LIST
3459: LIST
3460: PUSH
3461: LD_INT 32
3463: PUSH
3464: LD_INT 48
3466: PUSH
3467: LD_INT 19
3469: PUSH
3470: LD_INT 5
3472: PUSH
3473: LD_INT 28
3475: PUSH
3476: EMPTY
3477: LIST
3478: LIST
3479: LIST
3480: LIST
3481: LIST
3482: PUSH
3483: LD_INT 32
3485: PUSH
3486: LD_INT 41
3488: PUSH
3489: LD_INT 3
3491: PUSH
3492: LD_INT 4
3494: PUSH
3495: LD_INT 28
3497: PUSH
3498: EMPTY
3499: LIST
3500: LIST
3501: LIST
3502: LIST
3503: LIST
3504: PUSH
3505: LD_INT 5
3507: PUSH
3508: LD_INT 44
3510: PUSH
3511: LD_INT 9
3513: PUSH
3514: LD_INT 4
3516: PUSH
3517: EMPTY
3518: LIST
3519: LIST
3520: LIST
3521: LIST
3522: PUSH
3523: LD_INT 30
3525: PUSH
3526: LD_INT 52
3528: PUSH
3529: LD_INT 40
3531: PUSH
3532: LD_INT 3
3534: PUSH
3535: EMPTY
3536: LIST
3537: LIST
3538: LIST
3539: LIST
3540: PUSH
3541: EMPTY
3542: LIST
3543: LIST
3544: LIST
3545: LIST
3546: LIST
3547: LIST
3548: LIST
3549: LIST
3550: LIST
3551: LIST
3552: LIST
3553: LIST
3554: LIST
3555: LIST
3556: LIST
3557: LIST
3558: LIST
3559: ST_TO_ADDR
// for i in list do
3560: LD_ADDR_VAR 0 2
3564: PUSH
3565: LD_VAR 0 6
3569: PUSH
3570: FOR_IN
3571: IFFALSE 3749
// begin uc_side := 2 ;
3573: LD_ADDR_OWVAR 20
3577: PUSH
3578: LD_INT 2
3580: ST_TO_ADDR
// uc_nation := 2 ;
3581: LD_ADDR_OWVAR 21
3585: PUSH
3586: LD_INT 2
3588: ST_TO_ADDR
// bc_type := i [ 1 ] ;
3589: LD_ADDR_OWVAR 42
3593: PUSH
3594: LD_VAR 0 2
3598: PUSH
3599: LD_INT 1
3601: ARRAY
3602: ST_TO_ADDR
// bc_kind1 := - 1 ;
3603: LD_ADDR_OWVAR 44
3607: PUSH
3608: LD_INT 1
3610: NEG
3611: ST_TO_ADDR
// bc_kind2 := - 1 ;
3612: LD_ADDR_OWVAR 45
3616: PUSH
3617: LD_INT 1
3619: NEG
3620: ST_TO_ADDR
// if i [ 1 ] = b_lab then
3621: LD_VAR 0 2
3625: PUSH
3626: LD_INT 1
3628: ARRAY
3629: PUSH
3630: LD_INT 6
3632: EQUAL
3633: IFFALSE 3671
// begin bc_type := b_lab_full ;
3635: LD_ADDR_OWVAR 42
3639: PUSH
3640: LD_INT 8
3642: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
3643: LD_ADDR_OWVAR 44
3647: PUSH
3648: LD_VAR 0 2
3652: PUSH
3653: LD_INT 5
3655: ARRAY
3656: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
3657: LD_ADDR_OWVAR 45
3661: PUSH
3662: LD_VAR 0 2
3666: PUSH
3667: LD_INT 6
3669: ARRAY
3670: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
3671: LD_ADDR_VAR 0 3
3675: PUSH
3676: LD_VAR 0 2
3680: PUSH
3681: LD_INT 2
3683: ARRAY
3684: PPUSH
3685: LD_VAR 0 2
3689: PUSH
3690: LD_INT 3
3692: ARRAY
3693: PPUSH
3694: LD_VAR 0 2
3698: PUSH
3699: LD_INT 4
3701: ARRAY
3702: PPUSH
3703: CALL_OW 47
3707: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
3708: LD_VAR 0 2
3712: PUSH
3713: LD_INT 1
3715: ARRAY
3716: PUSH
3717: LD_INT 33
3719: PUSH
3720: LD_INT 32
3722: PUSH
3723: EMPTY
3724: LIST
3725: LIST
3726: IN
3727: IFFALSE 3747
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
3729: LD_VAR 0 3
3733: PPUSH
3734: LD_VAR 0 2
3738: PUSH
3739: LD_INT 5
3741: ARRAY
3742: PPUSH
3743: CALL_OW 431
// end ;
3747: GO 3570
3749: POP
3750: POP
// tmp := PrepareBase ( ar_depot , gensher_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 11500 , 1100 , 60 ] , [ 6 , 6 , 6 , 6 ] ) ;
3751: LD_ADDR_VAR 0 4
3755: PUSH
3756: LD_INT 7
3758: PPUSH
3759: LD_INT 2
3761: PPUSH
3762: LD_STRING 
3764: PPUSH
3765: LD_INT 8
3767: PUSH
3768: LD_INT 7
3770: PUSH
3771: LD_INT 6
3773: PUSH
3774: EMPTY
3775: LIST
3776: LIST
3777: LIST
3778: PUSH
3779: LD_OWVAR 67
3783: ARRAY
3784: PPUSH
3785: LD_INT 11500
3787: PUSH
3788: LD_INT 1100
3790: PUSH
3791: LD_INT 60
3793: PUSH
3794: EMPTY
3795: LIST
3796: LIST
3797: LIST
3798: PPUSH
3799: LD_INT 6
3801: PUSH
3802: LD_INT 6
3804: PUSH
3805: LD_INT 6
3807: PUSH
3808: LD_INT 6
3810: PUSH
3811: EMPTY
3812: LIST
3813: LIST
3814: LIST
3815: LIST
3816: PPUSH
3817: CALL 19314 0 6
3821: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ) ;
3822: LD_ADDR_EXP 23
3826: PUSH
3827: LD_EXP 23
3831: PPUSH
3832: LD_INT 2
3834: PPUSH
3835: LD_VAR 0 4
3839: PUSH
3840: LD_INT 22
3842: PUSH
3843: LD_INT 2
3845: PUSH
3846: EMPTY
3847: LIST
3848: LIST
3849: PUSH
3850: LD_INT 21
3852: PUSH
3853: LD_INT 3
3855: PUSH
3856: EMPTY
3857: LIST
3858: LIST
3859: PUSH
3860: EMPTY
3861: LIST
3862: LIST
3863: PPUSH
3864: CALL_OW 69
3868: UNION
3869: PPUSH
3870: CALL_OW 1
3874: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] ] ) ;
3875: LD_ADDR_VAR 0 4
3879: PUSH
3880: LD_INT 22
3882: PUSH
3883: LD_INT 2
3885: PUSH
3886: EMPTY
3887: LIST
3888: LIST
3889: PUSH
3890: LD_INT 30
3892: PUSH
3893: LD_INT 31
3895: PUSH
3896: EMPTY
3897: LIST
3898: LIST
3899: PUSH
3900: EMPTY
3901: LIST
3902: LIST
3903: PPUSH
3904: CALL_OW 69
3908: ST_TO_ADDR
// for i in tmp do
3909: LD_ADDR_VAR 0 2
3913: PUSH
3914: LD_VAR 0 4
3918: PUSH
3919: FOR_IN
3920: IFFALSE 3990
// begin PrepareHuman ( false , 1 , [ 4 , 3 , 3 ] [ Difficulty ] ) ;
3922: LD_INT 0
3924: PPUSH
3925: LD_INT 1
3927: PPUSH
3928: LD_INT 4
3930: PUSH
3931: LD_INT 3
3933: PUSH
3934: LD_INT 3
3936: PUSH
3937: EMPTY
3938: LIST
3939: LIST
3940: LIST
3941: PUSH
3942: LD_OWVAR 67
3946: ARRAY
3947: PPUSH
3948: CALL_OW 380
// un := CreateHuman ;
3952: LD_ADDR_VAR 0 5
3956: PUSH
3957: CALL_OW 44
3961: ST_TO_ADDR
// SetDir ( un , 1 ) ;
3962: LD_VAR 0 5
3966: PPUSH
3967: LD_INT 1
3969: PPUSH
3970: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3974: LD_VAR 0 5
3978: PPUSH
3979: LD_VAR 0 2
3983: PPUSH
3984: CALL_OW 52
// end ;
3988: GO 3919
3990: POP
3991: POP
// tmp := AreaToList ( gensher_mines , 0 ) ;
3992: LD_ADDR_VAR 0 4
3996: PUSH
3997: LD_INT 15
3999: PPUSH
4000: LD_INT 0
4002: PPUSH
4003: CALL_OW 517
4007: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
4008: LD_ADDR_VAR 0 2
4012: PUSH
4013: DOUBLE
4014: LD_INT 1
4016: DEC
4017: ST_TO_ADDR
4018: LD_VAR 0 4
4022: PUSH
4023: LD_INT 1
4025: ARRAY
4026: PUSH
4027: FOR_TO
4028: IFFALSE 4130
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
4030: LD_VAR 0 4
4034: PUSH
4035: LD_INT 1
4037: ARRAY
4038: PUSH
4039: LD_VAR 0 2
4043: ARRAY
4044: PPUSH
4045: LD_VAR 0 4
4049: PUSH
4050: LD_INT 2
4052: ARRAY
4053: PUSH
4054: LD_VAR 0 2
4058: ARRAY
4059: PPUSH
4060: LD_INT 2
4062: PPUSH
4063: LD_INT 0
4065: PPUSH
4066: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
4070: LD_ADDR_EXP 3
4074: PUSH
4075: LD_EXP 3
4079: PPUSH
4080: LD_EXP 3
4084: PUSH
4085: LD_INT 1
4087: PLUS
4088: PPUSH
4089: LD_VAR 0 4
4093: PUSH
4094: LD_INT 1
4096: ARRAY
4097: PUSH
4098: LD_VAR 0 2
4102: ARRAY
4103: PUSH
4104: LD_VAR 0 4
4108: PUSH
4109: LD_INT 2
4111: ARRAY
4112: PUSH
4113: LD_VAR 0 2
4117: ARRAY
4118: PUSH
4119: EMPTY
4120: LIST
4121: LIST
4122: PPUSH
4123: CALL_OW 2
4127: ST_TO_ADDR
// end ;
4128: GO 4027
4130: POP
4131: POP
// if Difficulty > 1 then
4132: LD_OWVAR 67
4136: PUSH
4137: LD_INT 1
4139: GREATER
4140: IFFALSE 4282
// begin tmp := AreaToList ( gensher_mines2 , 0 ) ;
4142: LD_ADDR_VAR 0 4
4146: PUSH
4147: LD_INT 19
4149: PPUSH
4150: LD_INT 0
4152: PPUSH
4153: CALL_OW 517
4157: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
4158: LD_ADDR_VAR 0 2
4162: PUSH
4163: DOUBLE
4164: LD_INT 1
4166: DEC
4167: ST_TO_ADDR
4168: LD_VAR 0 4
4172: PUSH
4173: LD_INT 1
4175: ARRAY
4176: PUSH
4177: FOR_TO
4178: IFFALSE 4280
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
4180: LD_VAR 0 4
4184: PUSH
4185: LD_INT 1
4187: ARRAY
4188: PUSH
4189: LD_VAR 0 2
4193: ARRAY
4194: PPUSH
4195: LD_VAR 0 4
4199: PUSH
4200: LD_INT 2
4202: ARRAY
4203: PUSH
4204: LD_VAR 0 2
4208: ARRAY
4209: PPUSH
4210: LD_INT 2
4212: PPUSH
4213: LD_INT 0
4215: PPUSH
4216: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
4220: LD_ADDR_EXP 3
4224: PUSH
4225: LD_EXP 3
4229: PPUSH
4230: LD_EXP 3
4234: PUSH
4235: LD_INT 1
4237: PLUS
4238: PPUSH
4239: LD_VAR 0 4
4243: PUSH
4244: LD_INT 1
4246: ARRAY
4247: PUSH
4248: LD_VAR 0 2
4252: ARRAY
4253: PUSH
4254: LD_VAR 0 4
4258: PUSH
4259: LD_INT 2
4261: ARRAY
4262: PUSH
4263: LD_VAR 0 2
4267: ARRAY
4268: PUSH
4269: EMPTY
4270: LIST
4271: LIST
4272: PPUSH
4273: CALL_OW 2
4277: ST_TO_ADDR
// end ;
4278: GO 4177
4280: POP
4281: POP
// end ; gensherAttackGroup := [ ] ;
4282: LD_ADDR_EXP 15
4286: PUSH
4287: EMPTY
4288: ST_TO_ADDR
// end ;
4289: LD_VAR 0 1
4293: RET
// export function InitMC_Gensher ( ) ; begin
4294: LD_INT 0
4296: PPUSH
// MC_SetScanArea ( 2 , gensher_base ) ;
4297: LD_INT 2
4299: PPUSH
4300: LD_INT 2
4302: PPUSH
4303: CALL 76588 0 2
// MC_SetParkingArea ( 2 , gensher_parking ) ;
4307: LD_INT 2
4309: PPUSH
4310: LD_INT 9
4312: PPUSH
4313: CALL 76532 0 2
// MC_SetDepositsXY ( 2 , [ [ 56 , 23 , 0 ] , [ 52 , 40 , 1 ] ] ) ;
4317: LD_INT 2
4319: PPUSH
4320: LD_INT 56
4322: PUSH
4323: LD_INT 23
4325: PUSH
4326: LD_INT 0
4328: PUSH
4329: EMPTY
4330: LIST
4331: LIST
4332: LIST
4333: PUSH
4334: LD_INT 52
4336: PUSH
4337: LD_INT 40
4339: PUSH
4340: LD_INT 1
4342: PUSH
4343: EMPTY
4344: LIST
4345: LIST
4346: LIST
4347: PUSH
4348: EMPTY
4349: LIST
4350: LIST
4351: PPUSH
4352: CALL 75591 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ar_gun , ar_rocket_launcher ] ) ;
4356: LD_INT 2
4358: PPUSH
4359: LD_INT 27
4361: PUSH
4362: LD_INT 28
4364: PUSH
4365: EMPTY
4366: LIST
4367: LIST
4368: PPUSH
4369: CALL 76420 0 2
// MC_SetCratesArea ( 2 , gensher_crates ) ;
4373: LD_INT 2
4375: PPUSH
4376: LD_INT 8
4378: PPUSH
4379: CALL 76102 0 2
// MC_SetTame ( 2 , gensher_ape ) ;
4383: LD_INT 2
4385: PPUSH
4386: LD_INT 7
4388: PPUSH
4389: CALL 75833 0 2
// MC_SetDefenderLimit ( 2 , 4 ) ;
4393: LD_INT 2
4395: PPUSH
4396: LD_INT 4
4398: PPUSH
4399: CALL 75452 0 2
// MC_SetProduceList ( 2 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ) ;
4403: LD_INT 2
4405: PPUSH
4406: LD_INT 13
4408: PUSH
4409: LD_INT 2
4411: PUSH
4412: LD_INT 1
4414: PUSH
4415: LD_INT 31
4417: PUSH
4418: EMPTY
4419: LIST
4420: LIST
4421: LIST
4422: LIST
4423: PUSH
4424: LD_INT 13
4426: PUSH
4427: LD_INT 2
4429: PUSH
4430: LD_INT 1
4432: PUSH
4433: LD_INT 31
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: LIST
4440: LIST
4441: PUSH
4442: LD_INT 14
4444: PUSH
4445: LD_INT 1
4447: PUSH
4448: LD_INT 2
4450: PUSH
4451: LD_INT 27
4453: PUSH
4454: EMPTY
4455: LIST
4456: LIST
4457: LIST
4458: LIST
4459: PUSH
4460: LD_INT 14
4462: PUSH
4463: LD_INT 1
4465: PUSH
4466: LD_INT 2
4468: PUSH
4469: LD_INT 27
4471: PUSH
4472: EMPTY
4473: LIST
4474: LIST
4475: LIST
4476: LIST
4477: PUSH
4478: LD_INT 14
4480: PUSH
4481: LD_INT 1
4483: PUSH
4484: LD_INT 2
4486: PUSH
4487: LD_INT 28
4489: PUSH
4490: EMPTY
4491: LIST
4492: LIST
4493: LIST
4494: LIST
4495: PUSH
4496: LD_INT 14
4498: PUSH
4499: LD_INT 1
4501: PUSH
4502: LD_INT 2
4504: PUSH
4505: LD_INT 26
4507: PUSH
4508: EMPTY
4509: LIST
4510: LIST
4511: LIST
4512: LIST
4513: PUSH
4514: EMPTY
4515: LIST
4516: LIST
4517: LIST
4518: LIST
4519: LIST
4520: LIST
4521: PPUSH
4522: CALL 75267 0 2
// MC_SetFactoryExtension ( 2 , 11 , 7 , 2 , [ b_ext_stitch , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
4526: LD_INT 2
4528: PPUSH
4529: LD_INT 11
4531: PPUSH
4532: LD_INT 7
4534: PPUSH
4535: LD_INT 2
4537: PPUSH
4538: LD_INT 23
4540: PUSH
4541: LD_INT 16
4543: PUSH
4544: LD_INT 17
4546: PUSH
4547: LD_INT 18
4549: PUSH
4550: LD_INT 22
4552: PUSH
4553: EMPTY
4554: LIST
4555: LIST
4556: LIST
4557: LIST
4558: LIST
4559: PPUSH
4560: CALL 76214 0 5
// end ;
4564: LD_VAR 0 1
4568: RET
// every 2 trigger staticMines and FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) do var i , j , tmp , x , y ;
4569: LD_EXP 3
4573: PUSH
4574: LD_INT 15
4576: PPUSH
4577: LD_INT 81
4579: PUSH
4580: LD_INT 2
4582: PUSH
4583: EMPTY
4584: LIST
4585: LIST
4586: PPUSH
4587: CALL_OW 70
4591: AND
4592: IFFALSE 4805
4594: GO 4596
4596: DISABLE
4597: LD_INT 0
4599: PPUSH
4600: PPUSH
4601: PPUSH
4602: PPUSH
4603: PPUSH
// begin enable ;
4604: ENABLE
// tmp := FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) ;
4605: LD_ADDR_VAR 0 3
4609: PUSH
4610: LD_INT 15
4612: PPUSH
4613: LD_INT 81
4615: PUSH
4616: LD_INT 2
4618: PUSH
4619: EMPTY
4620: LIST
4621: LIST
4622: PPUSH
4623: CALL_OW 70
4627: ST_TO_ADDR
// if not tmp then
4628: LD_VAR 0 3
4632: NOT
4633: IFFALSE 4637
// exit ;
4635: GO 4805
// for i in tmp do
4637: LD_ADDR_VAR 0 1
4641: PUSH
4642: LD_VAR 0 3
4646: PUSH
4647: FOR_IN
4648: IFFALSE 4803
// begin x := GetX ( i ) ;
4650: LD_ADDR_VAR 0 4
4654: PUSH
4655: LD_VAR 0 1
4659: PPUSH
4660: CALL_OW 250
4664: ST_TO_ADDR
// y := GetY ( i ) ;
4665: LD_ADDR_VAR 0 5
4669: PUSH
4670: LD_VAR 0 1
4674: PPUSH
4675: CALL_OW 251
4679: ST_TO_ADDR
// if MineAtPos ( x , y ) then
4680: LD_VAR 0 4
4684: PPUSH
4685: LD_VAR 0 5
4689: PPUSH
4690: CALL_OW 458
4694: IFFALSE 4801
// begin LaunchMineAtPos ( x , y , 2 ) ;
4696: LD_VAR 0 4
4700: PPUSH
4701: LD_VAR 0 5
4705: PPUSH
4706: LD_INT 2
4708: PPUSH
4709: CALL_OW 456
// for j = 1 to staticMines do
4713: LD_ADDR_VAR 0 2
4717: PUSH
4718: DOUBLE
4719: LD_INT 1
4721: DEC
4722: ST_TO_ADDR
4723: LD_EXP 3
4727: PUSH
4728: FOR_TO
4729: IFFALSE 4799
// if staticMines [ j ] [ 1 ] = x and staticMines [ j ] [ 2 ] = y then
4731: LD_EXP 3
4735: PUSH
4736: LD_VAR 0 2
4740: ARRAY
4741: PUSH
4742: LD_INT 1
4744: ARRAY
4745: PUSH
4746: LD_VAR 0 4
4750: EQUAL
4751: PUSH
4752: LD_EXP 3
4756: PUSH
4757: LD_VAR 0 2
4761: ARRAY
4762: PUSH
4763: LD_INT 2
4765: ARRAY
4766: PUSH
4767: LD_VAR 0 5
4771: EQUAL
4772: AND
4773: IFFALSE 4797
// begin staticMines := Delete ( staticMines , j ) ;
4775: LD_ADDR_EXP 3
4779: PUSH
4780: LD_EXP 3
4784: PPUSH
4785: LD_VAR 0 2
4789: PPUSH
4790: CALL_OW 3
4794: ST_TO_ADDR
// break ;
4795: GO 4799
// end ;
4797: GO 4728
4799: POP
4800: POP
// end ; end ;
4801: GO 4647
4803: POP
4804: POP
// end ;
4805: PPOPN 5
4807: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ar_depot ) and not arDestroyed do var i , base , tmp , attackers , amount ;
4808: LD_INT 7
4810: PPUSH
4811: CALL_OW 302
4815: PUSH
4816: LD_EXP 4
4820: NOT
4821: AND
4822: IFFALSE 5426
4824: GO 4826
4826: DISABLE
4827: LD_INT 0
4829: PPUSH
4830: PPUSH
4831: PPUSH
4832: PPUSH
4833: PPUSH
// begin enable ;
4834: ENABLE
// base := 2 ;
4835: LD_ADDR_VAR 0 2
4839: PUSH
4840: LD_INT 2
4842: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_mortar ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ;
4843: LD_ADDR_VAR 0 3
4847: PUSH
4848: LD_INT 14
4850: PUSH
4851: LD_INT 1
4853: PUSH
4854: LD_INT 2
4856: PUSH
4857: LD_INT 27
4859: PUSH
4860: EMPTY
4861: LIST
4862: LIST
4863: LIST
4864: LIST
4865: PUSH
4866: LD_INT 14
4868: PUSH
4869: LD_INT 1
4871: PUSH
4872: LD_INT 2
4874: PUSH
4875: LD_INT 27
4877: PUSH
4878: EMPTY
4879: LIST
4880: LIST
4881: LIST
4882: LIST
4883: PUSH
4884: LD_INT 14
4886: PUSH
4887: LD_INT 1
4889: PUSH
4890: LD_INT 2
4892: PUSH
4893: LD_EXP 72
4897: PUSH
4898: EMPTY
4899: LIST
4900: LIST
4901: LIST
4902: LIST
4903: PUSH
4904: LD_INT 14
4906: PUSH
4907: LD_INT 1
4909: PUSH
4910: LD_INT 2
4912: PUSH
4913: LD_INT 26
4915: PUSH
4916: EMPTY
4917: LIST
4918: LIST
4919: LIST
4920: LIST
4921: PUSH
4922: EMPTY
4923: LIST
4924: LIST
4925: LIST
4926: LIST
4927: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
4928: LD_ADDR_VAR 0 5
4932: PUSH
4933: LD_VAR 0 5
4937: PUSH
4938: LD_OWVAR 1
4942: PUSH
4943: LD_INT 21000
4945: DIV
4946: PLUS
4947: ST_TO_ADDR
// if amount > 8 then
4948: LD_VAR 0 5
4952: PUSH
4953: LD_INT 8
4955: GREATER
4956: IFFALSE 4966
// amount := 8 ;
4958: LD_ADDR_VAR 0 5
4962: PUSH
4963: LD_INT 8
4965: ST_TO_ADDR
// for i = 1 to amount do
4966: LD_ADDR_VAR 0 1
4970: PUSH
4971: DOUBLE
4972: LD_INT 1
4974: DEC
4975: ST_TO_ADDR
4976: LD_VAR 0 5
4980: PUSH
4981: FOR_TO
4982: IFFALSE 5070
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_half_tracked , ar_medium_trike ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gatling_gun , ar_gun ] [ rand ( 1 , 3 ) ] ] ) ;
4984: LD_ADDR_VAR 0 3
4988: PUSH
4989: LD_VAR 0 3
4993: PPUSH
4994: LD_VAR 0 3
4998: PUSH
4999: LD_INT 1
5001: PLUS
5002: PPUSH
5003: LD_INT 14
5005: PUSH
5006: LD_INT 13
5008: PUSH
5009: EMPTY
5010: LIST
5011: LIST
5012: PUSH
5013: LD_INT 1
5015: PPUSH
5016: LD_INT 2
5018: PPUSH
5019: CALL_OW 12
5023: ARRAY
5024: PUSH
5025: LD_INT 1
5027: PUSH
5028: LD_INT 2
5030: PUSH
5031: LD_INT 28
5033: PUSH
5034: LD_INT 25
5036: PUSH
5037: LD_INT 27
5039: PUSH
5040: EMPTY
5041: LIST
5042: LIST
5043: LIST
5044: PUSH
5045: LD_INT 1
5047: PPUSH
5048: LD_INT 3
5050: PPUSH
5051: CALL_OW 12
5055: ARRAY
5056: PUSH
5057: EMPTY
5058: LIST
5059: LIST
5060: LIST
5061: LIST
5062: PPUSH
5063: CALL_OW 2
5067: ST_TO_ADDR
5068: GO 4981
5070: POP
5071: POP
// MC_InsertProduceList ( base , tmp ) ;
5072: LD_VAR 0 2
5076: PPUSH
5077: LD_VAR 0 3
5081: PPUSH
5082: CALL 75315 0 2
// repeat wait ( 0 0$1 ) ;
5086: LD_INT 35
5088: PPUSH
5089: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
5093: LD_VAR 0 2
5097: PPUSH
5098: LD_INT 1
5100: PPUSH
5101: CALL 76733 0 2
5105: PUSH
5106: LD_VAR 0 5
5110: GREATEREQUAL
5111: IFFALSE 5086
// wait ( 0 0$30 ) ;
5113: LD_INT 1050
5115: PPUSH
5116: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_control_tower ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
5120: LD_ADDR_VAR 0 4
5124: PUSH
5125: LD_EXP 42
5129: PUSH
5130: LD_VAR 0 2
5134: ARRAY
5135: PUSH
5136: LD_EXP 42
5140: PUSH
5141: LD_VAR 0 2
5145: ARRAY
5146: PPUSH
5147: LD_INT 2
5149: PUSH
5150: LD_INT 34
5152: PUSH
5153: LD_INT 31
5155: PUSH
5156: EMPTY
5157: LIST
5158: LIST
5159: PUSH
5160: LD_INT 34
5162: PUSH
5163: LD_INT 32
5165: PUSH
5166: EMPTY
5167: LIST
5168: LIST
5169: PUSH
5170: LD_INT 34
5172: PUSH
5173: LD_EXP 73
5177: PUSH
5178: EMPTY
5179: LIST
5180: LIST
5181: PUSH
5182: EMPTY
5183: LIST
5184: LIST
5185: LIST
5186: LIST
5187: PPUSH
5188: CALL_OW 72
5192: DIFF
5193: ST_TO_ADDR
// if not attackers then
5194: LD_VAR 0 4
5198: NOT
5199: IFFALSE 5203
// exit ;
5201: GO 5426
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
5203: LD_ADDR_EXP 42
5207: PUSH
5208: LD_EXP 42
5212: PPUSH
5213: LD_VAR 0 2
5217: PPUSH
5218: LD_EXP 42
5222: PUSH
5223: LD_VAR 0 2
5227: ARRAY
5228: PUSH
5229: LD_VAR 0 4
5233: DIFF
5234: PPUSH
5235: CALL_OW 1
5239: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
5240: LD_VAR 0 4
5244: PPUSH
5245: LD_INT 107
5247: PPUSH
5248: LD_INT 74
5250: PPUSH
5251: CALL_OW 114
// wait ( 0 0$5 ) ;
5255: LD_INT 175
5257: PPUSH
5258: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
5262: LD_INT 35
5264: PPUSH
5265: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5269: LD_VAR 0 4
5273: PPUSH
5274: LD_INT 60
5276: PUSH
5277: EMPTY
5278: LIST
5279: PPUSH
5280: CALL_OW 72
5284: NOT
5285: IFFALSE 5262
// if rand ( 0 , 1 ) then
5287: LD_INT 0
5289: PPUSH
5290: LD_INT 1
5292: PPUSH
5293: CALL_OW 12
5297: IFFALSE 5316
// ComAgressiveMove ( attackers , 155 , 108 ) else
5299: LD_VAR 0 4
5303: PPUSH
5304: LD_INT 155
5306: PPUSH
5307: LD_INT 108
5309: PPUSH
5310: CALL_OW 114
5314: GO 5331
// ComAgressiveMove ( attackers , 149 , 55 ) ;
5316: LD_VAR 0 4
5320: PPUSH
5321: LD_INT 149
5323: PPUSH
5324: LD_INT 55
5326: PPUSH
5327: CALL_OW 114
// wait ( 0 0$10 ) ;
5331: LD_INT 350
5333: PPUSH
5334: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
5338: LD_INT 35
5340: PPUSH
5341: CALL_OW 67
// for i in attackers do
5345: LD_ADDR_VAR 0 1
5349: PUSH
5350: LD_VAR 0 4
5354: PUSH
5355: FOR_IN
5356: IFFALSE 5406
// if not HasTask ( i ) then
5358: LD_VAR 0 1
5362: PPUSH
5363: CALL_OW 314
5367: NOT
5368: IFFALSE 5404
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
5370: LD_VAR 0 1
5374: PPUSH
5375: LD_INT 81
5377: PUSH
5378: LD_INT 2
5380: PUSH
5381: EMPTY
5382: LIST
5383: LIST
5384: PPUSH
5385: CALL_OW 69
5389: PPUSH
5390: LD_VAR 0 1
5394: PPUSH
5395: CALL_OW 74
5399: PPUSH
5400: CALL_OW 115
5404: GO 5355
5406: POP
5407: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
5408: LD_VAR 0 4
5412: PPUSH
5413: LD_INT 50
5415: PUSH
5416: EMPTY
5417: LIST
5418: PPUSH
5419: CALL_OW 72
5423: NOT
5424: IFFALSE 5338
// end ;
5426: PPOPN 5
5428: END
// every 8 8$00 + 9 9$00 trigger not arDestroyed and tick < 91 91$00 do var i , un , tmp ;
5429: LD_EXP 4
5433: NOT
5434: PUSH
5435: LD_OWVAR 1
5439: PUSH
5440: LD_INT 191100
5442: LESS
5443: AND
5444: IFFALSE 6116
5446: GO 5448
5448: DISABLE
5449: LD_INT 0
5451: PPUSH
5452: PPUSH
5453: PPUSH
// begin enable ;
5454: ENABLE
// tmp := [ ] ;
5455: LD_ADDR_VAR 0 3
5459: PUSH
5460: EMPTY
5461: ST_TO_ADDR
// if tick < 35 35$00 then
5462: LD_OWVAR 1
5466: PUSH
5467: LD_INT 73500
5469: LESS
5470: IFFALSE 5668
// begin for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
5472: LD_ADDR_VAR 0 1
5476: PUSH
5477: DOUBLE
5478: LD_INT 1
5480: DEC
5481: ST_TO_ADDR
5482: LD_INT 4
5484: PUSH
5485: LD_INT 5
5487: PUSH
5488: LD_INT 5
5490: PUSH
5491: EMPTY
5492: LIST
5493: LIST
5494: LIST
5495: PUSH
5496: LD_OWVAR 67
5500: ARRAY
5501: PUSH
5502: FOR_TO
5503: IFFALSE 5664
// begin uc_side := 2 ;
5505: LD_ADDR_OWVAR 20
5509: PUSH
5510: LD_INT 2
5512: ST_TO_ADDR
// uc_nation := 2 ;
5513: LD_ADDR_OWVAR 21
5517: PUSH
5518: LD_INT 2
5520: ST_TO_ADDR
// InitHC_All ( ) ;
5521: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
5525: LD_INT 0
5527: PPUSH
5528: LD_INT 1
5530: PPUSH
5531: LD_INT 5
5533: PUSH
5534: LD_INT 6
5536: PUSH
5537: LD_INT 7
5539: PUSH
5540: EMPTY
5541: LIST
5542: LIST
5543: LIST
5544: PUSH
5545: LD_OWVAR 67
5549: ARRAY
5550: PPUSH
5551: CALL_OW 380
// un := CreateHuman ;
5555: LD_ADDR_VAR 0 2
5559: PUSH
5560: CALL_OW 44
5564: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5565: LD_VAR 0 2
5569: PPUSH
5570: LD_INT 17
5572: PPUSH
5573: LD_INT 0
5575: PPUSH
5576: CALL_OW 49
// SetClass ( un , [ class_soldier , class_mortar ] [ rand ( 1 , 2 ) ] ) ;
5580: LD_VAR 0 2
5584: PPUSH
5585: LD_INT 1
5587: PUSH
5588: LD_INT 8
5590: PUSH
5591: EMPTY
5592: LIST
5593: LIST
5594: PUSH
5595: LD_INT 1
5597: PPUSH
5598: LD_INT 2
5600: PPUSH
5601: CALL_OW 12
5605: ARRAY
5606: PPUSH
5607: CALL_OW 336
// ComAgressiveMove ( un , 111 , 34 ) ;
5611: LD_VAR 0 2
5615: PPUSH
5616: LD_INT 111
5618: PPUSH
5619: LD_INT 34
5621: PPUSH
5622: CALL_OW 114
// wait ( 0 0$2 ) ;
5626: LD_INT 70
5628: PPUSH
5629: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5633: LD_ADDR_VAR 0 3
5637: PUSH
5638: LD_VAR 0 3
5642: PPUSH
5643: LD_VAR 0 3
5647: PUSH
5648: LD_INT 1
5650: PLUS
5651: PPUSH
5652: LD_VAR 0 2
5656: PPUSH
5657: CALL_OW 1
5661: ST_TO_ADDR
// end ;
5662: GO 5502
5664: POP
5665: POP
// end else
5666: GO 5809
// begin for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
5668: LD_ADDR_VAR 0 1
5672: PUSH
5673: DOUBLE
5674: LD_INT 1
5676: DEC
5677: ST_TO_ADDR
5678: LD_INT 4
5680: PUSH
5681: LD_INT 5
5683: PUSH
5684: LD_INT 5
5686: PUSH
5687: EMPTY
5688: LIST
5689: LIST
5690: LIST
5691: PUSH
5692: LD_OWVAR 67
5696: ARRAY
5697: PUSH
5698: FOR_TO
5699: IFFALSE 5807
// begin uc_side := 2 ;
5701: LD_ADDR_OWVAR 20
5705: PUSH
5706: LD_INT 2
5708: ST_TO_ADDR
// uc_nation := 0 ;
5709: LD_ADDR_OWVAR 21
5713: PUSH
5714: LD_INT 0
5716: ST_TO_ADDR
// InitHC_All ( ) ;
5717: CALL_OW 584
// hc_class := class_apeman_kamikaze ;
5721: LD_ADDR_OWVAR 28
5725: PUSH
5726: LD_INT 17
5728: ST_TO_ADDR
// un := CreateHuman ;
5729: LD_ADDR_VAR 0 2
5733: PUSH
5734: CALL_OW 44
5738: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5739: LD_VAR 0 2
5743: PPUSH
5744: LD_INT 17
5746: PPUSH
5747: LD_INT 0
5749: PPUSH
5750: CALL_OW 49
// ComAgressiveMove ( un , 110 , 33 ) ;
5754: LD_VAR 0 2
5758: PPUSH
5759: LD_INT 110
5761: PPUSH
5762: LD_INT 33
5764: PPUSH
5765: CALL_OW 114
// wait ( 0 0$2 ) ;
5769: LD_INT 70
5771: PPUSH
5772: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5776: LD_ADDR_VAR 0 3
5780: PUSH
5781: LD_VAR 0 3
5785: PPUSH
5786: LD_VAR 0 3
5790: PUSH
5791: LD_INT 1
5793: PLUS
5794: PPUSH
5795: LD_VAR 0 2
5799: PPUSH
5800: CALL_OW 1
5804: ST_TO_ADDR
// end ;
5805: GO 5698
5807: POP
5808: POP
// end ; for i := 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
5809: LD_ADDR_VAR 0 1
5813: PUSH
5814: DOUBLE
5815: LD_INT 1
5817: DEC
5818: ST_TO_ADDR
5819: LD_INT 3
5821: PUSH
5822: LD_INT 4
5824: PUSH
5825: LD_INT 5
5827: PUSH
5828: EMPTY
5829: LIST
5830: LIST
5831: LIST
5832: PUSH
5833: LD_OWVAR 67
5837: ARRAY
5838: PUSH
5839: FOR_TO
5840: IFFALSE 6005
// begin uc_side := 2 ;
5842: LD_ADDR_OWVAR 20
5846: PUSH
5847: LD_INT 2
5849: ST_TO_ADDR
// uc_nation := 2 ;
5850: LD_ADDR_OWVAR 21
5854: PUSH
5855: LD_INT 2
5857: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_selfpropelled_bomb , ar_rocket_launcher , ar_gun ] [ rand ( 1 , 3 ) ] , 90 ) ;
5858: LD_INT 14
5860: PPUSH
5861: LD_INT 3
5863: PPUSH
5864: LD_INT 5
5866: PPUSH
5867: LD_INT 29
5869: PUSH
5870: LD_INT 28
5872: PUSH
5873: LD_INT 27
5875: PUSH
5876: EMPTY
5877: LIST
5878: LIST
5879: LIST
5880: PUSH
5881: LD_INT 1
5883: PPUSH
5884: LD_INT 3
5886: PPUSH
5887: CALL_OW 12
5891: ARRAY
5892: PPUSH
5893: LD_INT 90
5895: PPUSH
5896: CALL 15868 0 5
// un := CreateVehicle ;
5900: LD_ADDR_VAR 0 2
5904: PUSH
5905: CALL_OW 45
5909: ST_TO_ADDR
// SetDir ( un , 2 ) ;
5910: LD_VAR 0 2
5914: PPUSH
5915: LD_INT 2
5917: PPUSH
5918: CALL_OW 233
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5922: LD_VAR 0 2
5926: PPUSH
5927: LD_INT 17
5929: PPUSH
5930: LD_INT 0
5932: PPUSH
5933: CALL_OW 49
// ComMoveXY ( un , 66 , 23 ) ;
5937: LD_VAR 0 2
5941: PPUSH
5942: LD_INT 66
5944: PPUSH
5945: LD_INT 23
5947: PPUSH
5948: CALL_OW 111
// wait ( 0 0$3 ) ;
5952: LD_INT 105
5954: PPUSH
5955: CALL_OW 67
// AddComAgressiveMove ( un , 147 , 103 ) ;
5959: LD_VAR 0 2
5963: PPUSH
5964: LD_INT 147
5966: PPUSH
5967: LD_INT 103
5969: PPUSH
5970: CALL_OW 174
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5974: LD_ADDR_VAR 0 3
5978: PUSH
5979: LD_VAR 0 3
5983: PPUSH
5984: LD_VAR 0 3
5988: PUSH
5989: LD_INT 1
5991: PLUS
5992: PPUSH
5993: LD_VAR 0 2
5997: PPUSH
5998: CALL_OW 1
6002: ST_TO_ADDR
// end ;
6003: GO 5839
6005: POP
6006: POP
// if not tmp then
6007: LD_VAR 0 3
6011: NOT
6012: IFFALSE 6016
// exit ;
6014: GO 6116
// wait ( 0 0$5 ) ;
6016: LD_INT 175
6018: PPUSH
6019: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
6023: LD_INT 70
6025: PPUSH
6026: CALL_OW 67
// for i in tmp do
6030: LD_ADDR_VAR 0 1
6034: PUSH
6035: LD_VAR 0 3
6039: PUSH
6040: FOR_IN
6041: IFFALSE 6107
// begin if not IsOk ( i ) then
6043: LD_VAR 0 1
6047: PPUSH
6048: CALL_OW 302
6052: NOT
6053: IFFALSE 6071
// tmp := tmp diff i ;
6055: LD_ADDR_VAR 0 3
6059: PUSH
6060: LD_VAR 0 3
6064: PUSH
6065: LD_VAR 0 1
6069: DIFF
6070: ST_TO_ADDR
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
6071: LD_VAR 0 1
6075: PPUSH
6076: LD_INT 81
6078: PUSH
6079: LD_INT 2
6081: PUSH
6082: EMPTY
6083: LIST
6084: LIST
6085: PPUSH
6086: CALL_OW 69
6090: PPUSH
6091: LD_VAR 0 1
6095: PPUSH
6096: CALL_OW 74
6100: PPUSH
6101: CALL_OW 115
// end ;
6105: GO 6040
6107: POP
6108: POP
// until not tmp ;
6109: LD_VAR 0 3
6113: NOT
6114: IFFALSE 6023
// end ;
6116: PPOPN 3
6118: END
// every 9 9$00 trigger Difficulty > 1 do var un ;
6119: LD_OWVAR 67
6123: PUSH
6124: LD_INT 1
6126: GREATER
6127: IFFALSE 6225
6129: GO 6131
6131: DISABLE
6132: LD_INT 0
6134: PPUSH
// begin uc_side := 2 ;
6135: LD_ADDR_OWVAR 20
6139: PUSH
6140: LD_INT 2
6142: ST_TO_ADDR
// uc_nation := 2 ;
6143: LD_ADDR_OWVAR 21
6147: PUSH
6148: LD_INT 2
6150: ST_TO_ADDR
// PrepareHuman ( false , 4 , 6 ) ;
6151: LD_INT 0
6153: PPUSH
6154: LD_INT 4
6156: PPUSH
6157: LD_INT 6
6159: PPUSH
6160: CALL_OW 380
// un := CreateHuman ;
6164: LD_ADDR_VAR 0 1
6168: PUSH
6169: CALL_OW 44
6173: ST_TO_ADDR
// PlaceUnitXYD ( un , 88 , 1 , 2 , false ) ;
6174: LD_VAR 0 1
6178: PPUSH
6179: LD_INT 88
6181: PPUSH
6182: LD_INT 1
6184: PPUSH
6185: LD_INT 2
6187: PPUSH
6188: LD_INT 0
6190: PPUSH
6191: CALL 49873 0 5
// ComMoveXY ( un , 130 , 35 ) ;
6195: LD_VAR 0 1
6199: PPUSH
6200: LD_INT 130
6202: PPUSH
6203: LD_INT 35
6205: PPUSH
6206: CALL_OW 111
// AddComContaminate ( un , 132 , 39 ) ;
6210: LD_VAR 0 1
6214: PPUSH
6215: LD_INT 132
6217: PPUSH
6218: LD_INT 39
6220: PPUSH
6221: CALL_OW 218
// end ;
6225: PPOPN 1
6227: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
6228: LD_INT 22
6230: PUSH
6231: LD_INT 2
6233: PUSH
6234: EMPTY
6235: LIST
6236: LIST
6237: PUSH
6238: LD_INT 33
6240: PUSH
6241: LD_INT 2
6243: PUSH
6244: EMPTY
6245: LIST
6246: LIST
6247: PUSH
6248: LD_INT 50
6250: PUSH
6251: EMPTY
6252: LIST
6253: PUSH
6254: LD_INT 3
6256: PUSH
6257: LD_INT 61
6259: PUSH
6260: EMPTY
6261: LIST
6262: PUSH
6263: EMPTY
6264: LIST
6265: LIST
6266: PUSH
6267: EMPTY
6268: LIST
6269: LIST
6270: LIST
6271: LIST
6272: PPUSH
6273: CALL_OW 69
6277: IFFALSE 6368
6279: GO 6281
6281: DISABLE
6282: LD_INT 0
6284: PPUSH
6285: PPUSH
// begin enable ;
6286: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
6287: LD_ADDR_VAR 0 2
6291: PUSH
6292: LD_INT 22
6294: PUSH
6295: LD_INT 2
6297: PUSH
6298: EMPTY
6299: LIST
6300: LIST
6301: PUSH
6302: LD_INT 33
6304: PUSH
6305: LD_INT 2
6307: PUSH
6308: EMPTY
6309: LIST
6310: LIST
6311: PUSH
6312: LD_INT 50
6314: PUSH
6315: EMPTY
6316: LIST
6317: PUSH
6318: LD_INT 3
6320: PUSH
6321: LD_INT 61
6323: PUSH
6324: EMPTY
6325: LIST
6326: PUSH
6327: EMPTY
6328: LIST
6329: LIST
6330: PUSH
6331: EMPTY
6332: LIST
6333: LIST
6334: LIST
6335: LIST
6336: PPUSH
6337: CALL_OW 69
6341: ST_TO_ADDR
// for i in tmp do
6342: LD_ADDR_VAR 0 1
6346: PUSH
6347: LD_VAR 0 2
6351: PUSH
6352: FOR_IN
6353: IFFALSE 6366
// Connect ( i ) ;
6355: LD_VAR 0 1
6359: PPUSH
6360: CALL 18961 0 1
6364: GO 6352
6366: POP
6367: POP
// end ; end_of_file
6368: PPOPN 2
6370: END
// export Popov , popov_side , extraPopovForces , popovAttackGroup ; export function PreparePopov ; var i , un , tmp , b , list ; begin
6371: LD_INT 0
6373: PPUSH
6374: PPUSH
6375: PPUSH
6376: PPUSH
6377: PPUSH
6378: PPUSH
// popov_side := 3 ;
6379: LD_ADDR_EXP 17
6383: PUSH
6384: LD_INT 3
6386: ST_TO_ADDR
// uc_side := popov_side ;
6387: LD_ADDR_OWVAR 20
6391: PUSH
6392: LD_EXP 17
6396: ST_TO_ADDR
// uc_nation := 3 ;
6397: LD_ADDR_OWVAR 21
6401: PUSH
6402: LD_INT 3
6404: ST_TO_ADDR
// list := [ [ b_barracks , 103 , 147 , 3 ] , [ b_barracks , 70 , 117 , 3 ] , [ b_lab , 76 , 145 , 1 , b_lab_weapon , b_lab_siberium ] , [ b_oil_power , 87 , 144 , 0 ] , [ b_oil_mine , 86 , 118 , 0 ] , [ b_oil_mine , 98 , 121 , 0 ] , [ b_oil_power , 87 , 147 , 1 ] , [ b_siberite_mine , 123 , 151 , 1 ] , [ b_factory , 94 , 161 , 0 ] , [ b_lab , 81 , 155 , 1 , b_lab_computer , b_lab_spacetime ] , [ b_oil_power , 96 , 152 , 0 ] , [ b_oil_power , 96 , 149 , 3 ] , [ b_bunker , 109 , 142 , 3 , ru_heavy_gun ] , [ b_bunker , 112 , 148 , 3 , ru_heavy_gun ] , [ b_turret , 120 , 159 , 4 , ru_rocket_launcher ] , [ b_turret , 122 , 163 , 4 , ru_rocket_launcher ] , [ b_turret , 123 , 167 , 4 , ru_rocket_launcher ] , [ b_turret , 59 , 111 , 3 , ru_rocket_launcher ] , [ b_turret , 65 , 111 , 3 , ru_heavy_gun ] , [ b_turret , 76 , 117 , 3 , ru_rocket_launcher ] , [ b_turret , 80 , 119 , 3 , ru_heavy_gun ] , [ b_turret , 87 , 125 , 3 , ru_rocket_launcher ] , [ b_barracks , 92 , 129 , 3 ] , [ b_siberite_power , 85 , 165 , 0 ] , [ b_siberite_power , 83 , 161 , 4 ] , [ b_siberite_power , 91 , 166 , 3 ] , [ b_siberite_power , 102 , 166 , 2 ] ] ;
6405: LD_ADDR_VAR 0 6
6409: PUSH
6410: LD_INT 5
6412: PUSH
6413: LD_INT 103
6415: PUSH
6416: LD_INT 147
6418: PUSH
6419: LD_INT 3
6421: PUSH
6422: EMPTY
6423: LIST
6424: LIST
6425: LIST
6426: LIST
6427: PUSH
6428: LD_INT 5
6430: PUSH
6431: LD_INT 70
6433: PUSH
6434: LD_INT 117
6436: PUSH
6437: LD_INT 3
6439: PUSH
6440: EMPTY
6441: LIST
6442: LIST
6443: LIST
6444: LIST
6445: PUSH
6446: LD_INT 6
6448: PUSH
6449: LD_INT 76
6451: PUSH
6452: LD_INT 145
6454: PUSH
6455: LD_INT 1
6457: PUSH
6458: LD_INT 10
6460: PUSH
6461: LD_INT 11
6463: PUSH
6464: EMPTY
6465: LIST
6466: LIST
6467: LIST
6468: LIST
6469: LIST
6470: LIST
6471: PUSH
6472: LD_INT 26
6474: PUSH
6475: LD_INT 87
6477: PUSH
6478: LD_INT 144
6480: PUSH
6481: LD_INT 0
6483: PUSH
6484: EMPTY
6485: LIST
6486: LIST
6487: LIST
6488: LIST
6489: PUSH
6490: LD_INT 29
6492: PUSH
6493: LD_INT 86
6495: PUSH
6496: LD_INT 118
6498: PUSH
6499: LD_INT 0
6501: PUSH
6502: EMPTY
6503: LIST
6504: LIST
6505: LIST
6506: LIST
6507: PUSH
6508: LD_INT 29
6510: PUSH
6511: LD_INT 98
6513: PUSH
6514: LD_INT 121
6516: PUSH
6517: LD_INT 0
6519: PUSH
6520: EMPTY
6521: LIST
6522: LIST
6523: LIST
6524: LIST
6525: PUSH
6526: LD_INT 26
6528: PUSH
6529: LD_INT 87
6531: PUSH
6532: LD_INT 147
6534: PUSH
6535: LD_INT 1
6537: PUSH
6538: EMPTY
6539: LIST
6540: LIST
6541: LIST
6542: LIST
6543: PUSH
6544: LD_INT 30
6546: PUSH
6547: LD_INT 123
6549: PUSH
6550: LD_INT 151
6552: PUSH
6553: LD_INT 1
6555: PUSH
6556: EMPTY
6557: LIST
6558: LIST
6559: LIST
6560: LIST
6561: PUSH
6562: LD_INT 3
6564: PUSH
6565: LD_INT 94
6567: PUSH
6568: LD_INT 161
6570: PUSH
6571: LD_INT 0
6573: PUSH
6574: EMPTY
6575: LIST
6576: LIST
6577: LIST
6578: LIST
6579: PUSH
6580: LD_INT 6
6582: PUSH
6583: LD_INT 81
6585: PUSH
6586: LD_INT 155
6588: PUSH
6589: LD_INT 1
6591: PUSH
6592: LD_INT 12
6594: PUSH
6595: LD_INT 14
6597: PUSH
6598: EMPTY
6599: LIST
6600: LIST
6601: LIST
6602: LIST
6603: LIST
6604: LIST
6605: PUSH
6606: LD_INT 26
6608: PUSH
6609: LD_INT 96
6611: PUSH
6612: LD_INT 152
6614: PUSH
6615: LD_INT 0
6617: PUSH
6618: EMPTY
6619: LIST
6620: LIST
6621: LIST
6622: LIST
6623: PUSH
6624: LD_INT 26
6626: PUSH
6627: LD_INT 96
6629: PUSH
6630: LD_INT 149
6632: PUSH
6633: LD_INT 3
6635: PUSH
6636: EMPTY
6637: LIST
6638: LIST
6639: LIST
6640: LIST
6641: PUSH
6642: LD_INT 32
6644: PUSH
6645: LD_INT 109
6647: PUSH
6648: LD_INT 142
6650: PUSH
6651: LD_INT 3
6653: PUSH
6654: LD_INT 46
6656: PUSH
6657: EMPTY
6658: LIST
6659: LIST
6660: LIST
6661: LIST
6662: LIST
6663: PUSH
6664: LD_INT 32
6666: PUSH
6667: LD_INT 112
6669: PUSH
6670: LD_INT 148
6672: PUSH
6673: LD_INT 3
6675: PUSH
6676: LD_INT 46
6678: PUSH
6679: EMPTY
6680: LIST
6681: LIST
6682: LIST
6683: LIST
6684: LIST
6685: PUSH
6686: LD_INT 33
6688: PUSH
6689: LD_INT 120
6691: PUSH
6692: LD_INT 159
6694: PUSH
6695: LD_INT 4
6697: PUSH
6698: LD_INT 45
6700: PUSH
6701: EMPTY
6702: LIST
6703: LIST
6704: LIST
6705: LIST
6706: LIST
6707: PUSH
6708: LD_INT 33
6710: PUSH
6711: LD_INT 122
6713: PUSH
6714: LD_INT 163
6716: PUSH
6717: LD_INT 4
6719: PUSH
6720: LD_INT 45
6722: PUSH
6723: EMPTY
6724: LIST
6725: LIST
6726: LIST
6727: LIST
6728: LIST
6729: PUSH
6730: LD_INT 33
6732: PUSH
6733: LD_INT 123
6735: PUSH
6736: LD_INT 167
6738: PUSH
6739: LD_INT 4
6741: PUSH
6742: LD_INT 45
6744: PUSH
6745: EMPTY
6746: LIST
6747: LIST
6748: LIST
6749: LIST
6750: LIST
6751: PUSH
6752: LD_INT 33
6754: PUSH
6755: LD_INT 59
6757: PUSH
6758: LD_INT 111
6760: PUSH
6761: LD_INT 3
6763: PUSH
6764: LD_INT 45
6766: PUSH
6767: EMPTY
6768: LIST
6769: LIST
6770: LIST
6771: LIST
6772: LIST
6773: PUSH
6774: LD_INT 33
6776: PUSH
6777: LD_INT 65
6779: PUSH
6780: LD_INT 111
6782: PUSH
6783: LD_INT 3
6785: PUSH
6786: LD_INT 46
6788: PUSH
6789: EMPTY
6790: LIST
6791: LIST
6792: LIST
6793: LIST
6794: LIST
6795: PUSH
6796: LD_INT 33
6798: PUSH
6799: LD_INT 76
6801: PUSH
6802: LD_INT 117
6804: PUSH
6805: LD_INT 3
6807: PUSH
6808: LD_INT 45
6810: PUSH
6811: EMPTY
6812: LIST
6813: LIST
6814: LIST
6815: LIST
6816: LIST
6817: PUSH
6818: LD_INT 33
6820: PUSH
6821: LD_INT 80
6823: PUSH
6824: LD_INT 119
6826: PUSH
6827: LD_INT 3
6829: PUSH
6830: LD_INT 46
6832: PUSH
6833: EMPTY
6834: LIST
6835: LIST
6836: LIST
6837: LIST
6838: LIST
6839: PUSH
6840: LD_INT 33
6842: PUSH
6843: LD_INT 87
6845: PUSH
6846: LD_INT 125
6848: PUSH
6849: LD_INT 3
6851: PUSH
6852: LD_INT 45
6854: PUSH
6855: EMPTY
6856: LIST
6857: LIST
6858: LIST
6859: LIST
6860: LIST
6861: PUSH
6862: LD_INT 5
6864: PUSH
6865: LD_INT 92
6867: PUSH
6868: LD_INT 129
6870: PUSH
6871: LD_INT 3
6873: PUSH
6874: EMPTY
6875: LIST
6876: LIST
6877: LIST
6878: LIST
6879: PUSH
6880: LD_INT 28
6882: PUSH
6883: LD_INT 85
6885: PUSH
6886: LD_INT 165
6888: PUSH
6889: LD_INT 0
6891: PUSH
6892: EMPTY
6893: LIST
6894: LIST
6895: LIST
6896: LIST
6897: PUSH
6898: LD_INT 28
6900: PUSH
6901: LD_INT 83
6903: PUSH
6904: LD_INT 161
6906: PUSH
6907: LD_INT 4
6909: PUSH
6910: EMPTY
6911: LIST
6912: LIST
6913: LIST
6914: LIST
6915: PUSH
6916: LD_INT 28
6918: PUSH
6919: LD_INT 91
6921: PUSH
6922: LD_INT 166
6924: PUSH
6925: LD_INT 3
6927: PUSH
6928: EMPTY
6929: LIST
6930: LIST
6931: LIST
6932: LIST
6933: PUSH
6934: LD_INT 28
6936: PUSH
6937: LD_INT 102
6939: PUSH
6940: LD_INT 166
6942: PUSH
6943: LD_INT 2
6945: PUSH
6946: EMPTY
6947: LIST
6948: LIST
6949: LIST
6950: LIST
6951: PUSH
6952: EMPTY
6953: LIST
6954: LIST
6955: LIST
6956: LIST
6957: LIST
6958: LIST
6959: LIST
6960: LIST
6961: LIST
6962: LIST
6963: LIST
6964: LIST
6965: LIST
6966: LIST
6967: LIST
6968: LIST
6969: LIST
6970: LIST
6971: LIST
6972: LIST
6973: LIST
6974: LIST
6975: LIST
6976: LIST
6977: LIST
6978: LIST
6979: LIST
6980: ST_TO_ADDR
// for i in list do
6981: LD_ADDR_VAR 0 2
6985: PUSH
6986: LD_VAR 0 6
6990: PUSH
6991: FOR_IN
6992: IFFALSE 7170
// begin uc_side := 3 ;
6994: LD_ADDR_OWVAR 20
6998: PUSH
6999: LD_INT 3
7001: ST_TO_ADDR
// uc_nation := 3 ;
7002: LD_ADDR_OWVAR 21
7006: PUSH
7007: LD_INT 3
7009: ST_TO_ADDR
// bc_type := i [ 1 ] ;
7010: LD_ADDR_OWVAR 42
7014: PUSH
7015: LD_VAR 0 2
7019: PUSH
7020: LD_INT 1
7022: ARRAY
7023: ST_TO_ADDR
// bc_kind1 := - 1 ;
7024: LD_ADDR_OWVAR 44
7028: PUSH
7029: LD_INT 1
7031: NEG
7032: ST_TO_ADDR
// bc_kind2 := - 1 ;
7033: LD_ADDR_OWVAR 45
7037: PUSH
7038: LD_INT 1
7040: NEG
7041: ST_TO_ADDR
// if i [ 1 ] = b_lab then
7042: LD_VAR 0 2
7046: PUSH
7047: LD_INT 1
7049: ARRAY
7050: PUSH
7051: LD_INT 6
7053: EQUAL
7054: IFFALSE 7092
// begin bc_type := b_lab_full ;
7056: LD_ADDR_OWVAR 42
7060: PUSH
7061: LD_INT 8
7063: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
7064: LD_ADDR_OWVAR 44
7068: PUSH
7069: LD_VAR 0 2
7073: PUSH
7074: LD_INT 5
7076: ARRAY
7077: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
7078: LD_ADDR_OWVAR 45
7082: PUSH
7083: LD_VAR 0 2
7087: PUSH
7088: LD_INT 6
7090: ARRAY
7091: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
7092: LD_ADDR_VAR 0 5
7096: PUSH
7097: LD_VAR 0 2
7101: PUSH
7102: LD_INT 2
7104: ARRAY
7105: PPUSH
7106: LD_VAR 0 2
7110: PUSH
7111: LD_INT 3
7113: ARRAY
7114: PPUSH
7115: LD_VAR 0 2
7119: PUSH
7120: LD_INT 4
7122: ARRAY
7123: PPUSH
7124: CALL_OW 47
7128: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
7129: LD_VAR 0 2
7133: PUSH
7134: LD_INT 1
7136: ARRAY
7137: PUSH
7138: LD_INT 33
7140: PUSH
7141: LD_INT 32
7143: PUSH
7144: EMPTY
7145: LIST
7146: LIST
7147: IN
7148: IFFALSE 7168
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
7150: LD_VAR 0 5
7154: PPUSH
7155: LD_VAR 0 2
7159: PUSH
7160: LD_INT 5
7162: ARRAY
7163: PPUSH
7164: CALL_OW 431
// end ;
7168: GO 6991
7170: POP
7171: POP
// tmp := PrepareBase ( ru_depot , popov_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 11500 , 1100 , 60 ] , [ 6 , 6 , 6 , 6 ] ) ;
7172: LD_ADDR_VAR 0 4
7176: PUSH
7177: LD_INT 9
7179: PPUSH
7180: LD_INT 3
7182: PPUSH
7183: LD_STRING 
7185: PPUSH
7186: LD_INT 8
7188: PUSH
7189: LD_INT 7
7191: PUSH
7192: LD_INT 6
7194: PUSH
7195: EMPTY
7196: LIST
7197: LIST
7198: LIST
7199: PUSH
7200: LD_OWVAR 67
7204: ARRAY
7205: PPUSH
7206: LD_INT 11500
7208: PUSH
7209: LD_INT 1100
7211: PUSH
7212: LD_INT 60
7214: PUSH
7215: EMPTY
7216: LIST
7217: LIST
7218: LIST
7219: PPUSH
7220: LD_INT 6
7222: PUSH
7223: LD_INT 6
7225: PUSH
7226: LD_INT 6
7228: PUSH
7229: LD_INT 6
7231: PUSH
7232: EMPTY
7233: LIST
7234: LIST
7235: LIST
7236: LIST
7237: PPUSH
7238: CALL 19314 0 6
7242: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 3 , tmp union FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ) ;
7243: LD_ADDR_EXP 23
7247: PUSH
7248: LD_EXP 23
7252: PPUSH
7253: LD_INT 3
7255: PPUSH
7256: LD_VAR 0 4
7260: PUSH
7261: LD_INT 22
7263: PUSH
7264: LD_INT 3
7266: PUSH
7267: EMPTY
7268: LIST
7269: LIST
7270: PUSH
7271: LD_INT 21
7273: PUSH
7274: LD_INT 3
7276: PUSH
7277: EMPTY
7278: LIST
7279: LIST
7280: PUSH
7281: EMPTY
7282: LIST
7283: LIST
7284: PPUSH
7285: CALL_OW 69
7289: UNION
7290: PPUSH
7291: CALL_OW 1
7295: ST_TO_ADDR
// extraPopovForces := [ ] ;
7296: LD_ADDR_EXP 18
7300: PUSH
7301: EMPTY
7302: ST_TO_ADDR
// for i := 1 to [ 8 , 9 , 10 ] [ Difficulty ] do
7303: LD_ADDR_VAR 0 2
7307: PUSH
7308: DOUBLE
7309: LD_INT 1
7311: DEC
7312: ST_TO_ADDR
7313: LD_INT 8
7315: PUSH
7316: LD_INT 9
7318: PUSH
7319: LD_INT 10
7321: PUSH
7322: EMPTY
7323: LIST
7324: LIST
7325: LIST
7326: PUSH
7327: LD_OWVAR 67
7331: ARRAY
7332: PUSH
7333: FOR_TO
7334: IFFALSE 7463
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
7336: LD_INT 0
7338: PPUSH
7339: LD_INT 1
7341: PPUSH
7342: LD_INT 4
7344: PUSH
7345: LD_INT 5
7347: PUSH
7348: LD_INT 6
7350: PUSH
7351: EMPTY
7352: LIST
7353: LIST
7354: LIST
7355: PUSH
7356: LD_OWVAR 67
7360: ARRAY
7361: PPUSH
7362: CALL_OW 380
// un := CreateHuman ;
7366: LD_ADDR_VAR 0 3
7370: PUSH
7371: CALL_OW 44
7375: ST_TO_ADDR
// if rand ( 0 , 1 ) then
7376: LD_INT 0
7378: PPUSH
7379: LD_INT 1
7381: PPUSH
7382: CALL_OW 12
7386: IFFALSE 7411
// PlaceUnitXYR ( un , 131 , 110 , 8 , false ) else
7388: LD_VAR 0 3
7392: PPUSH
7393: LD_INT 131
7395: PPUSH
7396: LD_INT 110
7398: PPUSH
7399: LD_INT 8
7401: PPUSH
7402: LD_INT 0
7404: PPUSH
7405: CALL_OW 50
7409: GO 7432
// PlaceUnitXYR ( un , 100 , 99 , 8 , false ) ;
7411: LD_VAR 0 3
7415: PPUSH
7416: LD_INT 100
7418: PPUSH
7419: LD_INT 99
7421: PPUSH
7422: LD_INT 8
7424: PPUSH
7425: LD_INT 0
7427: PPUSH
7428: CALL_OW 50
// extraPopovForces := Replace ( extraPopovForces , extraPopovForces + 1 , un ) ;
7432: LD_ADDR_EXP 18
7436: PUSH
7437: LD_EXP 18
7441: PPUSH
7442: LD_EXP 18
7446: PUSH
7447: LD_INT 1
7449: PLUS
7450: PPUSH
7451: LD_VAR 0 3
7455: PPUSH
7456: CALL_OW 1
7460: ST_TO_ADDR
// end ;
7461: GO 7333
7463: POP
7464: POP
// PrepareSoldier ( false , 6 ) ;
7465: LD_INT 0
7467: PPUSH
7468: LD_INT 6
7470: PPUSH
7471: CALL_OW 381
// un := CreateHuman ;
7475: LD_ADDR_VAR 0 3
7479: PUSH
7480: CALL_OW 44
7484: ST_TO_ADDR
// SetDir ( un , 1 ) ;
7485: LD_VAR 0 3
7489: PPUSH
7490: LD_INT 1
7492: PPUSH
7493: CALL_OW 233
// PlaceHumanInUnit ( un , HexInfo ( 150 , 158 ) ) ;
7497: LD_VAR 0 3
7501: PPUSH
7502: LD_INT 150
7504: PPUSH
7505: LD_INT 158
7507: PPUSH
7508: CALL_OW 428
7512: PPUSH
7513: CALL_OW 52
// popovAttackGroup := [ ] ;
7517: LD_ADDR_EXP 19
7521: PUSH
7522: EMPTY
7523: ST_TO_ADDR
// end ;
7524: LD_VAR 0 1
7528: RET
// export function InitMC_Popov ( ) ; begin
7529: LD_INT 0
7531: PPUSH
// MC_SetScanArea ( 3 , popov_base ) ;
7532: LD_INT 3
7534: PPUSH
7535: LD_INT 3
7537: PPUSH
7538: CALL 76588 0 2
// MC_SetParkingArea ( 3 , popov_parking ) ;
7542: LD_INT 3
7544: PPUSH
7545: LD_INT 10
7547: PPUSH
7548: CALL 76532 0 2
// MC_SetDepositsXY ( 3 , [ [ 86 , 118 , 0 ] , [ 123 , 151 , 1 ] , [ 98 , 121 , 0 ] ] ) ;
7552: LD_INT 3
7554: PPUSH
7555: LD_INT 86
7557: PUSH
7558: LD_INT 118
7560: PUSH
7561: LD_INT 0
7563: PUSH
7564: EMPTY
7565: LIST
7566: LIST
7567: LIST
7568: PUSH
7569: LD_INT 123
7571: PUSH
7572: LD_INT 151
7574: PUSH
7575: LD_INT 1
7577: PUSH
7578: EMPTY
7579: LIST
7580: LIST
7581: LIST
7582: PUSH
7583: LD_INT 98
7585: PUSH
7586: LD_INT 121
7588: PUSH
7589: LD_INT 0
7591: PUSH
7592: EMPTY
7593: LIST
7594: LIST
7595: LIST
7596: PUSH
7597: EMPTY
7598: LIST
7599: LIST
7600: LIST
7601: PPUSH
7602: CALL 75591 0 2
// MC_SetAllowedTurretWeapons ( 3 , [ ru_heavy_gun , ru_rocket_launcher ] ) ;
7606: LD_INT 3
7608: PPUSH
7609: LD_INT 46
7611: PUSH
7612: LD_INT 45
7614: PUSH
7615: EMPTY
7616: LIST
7617: LIST
7618: PPUSH
7619: CALL 76420 0 2
// MC_SetCratesArea ( 3 , popov_crates ) ;
7623: LD_INT 3
7625: PPUSH
7626: LD_INT 12
7628: PPUSH
7629: CALL 76102 0 2
// MC_SetTame ( 3 , popov_ape ) ;
7633: LD_INT 3
7635: PPUSH
7636: LD_INT 11
7638: PPUSH
7639: CALL 75833 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
7643: LD_INT 3
7645: PPUSH
7646: LD_INT 4
7648: PPUSH
7649: CALL 75452 0 2
// MC_SetProduceList ( 3 , [ [ ru_heavy_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] ] ) ;
7653: LD_INT 3
7655: PPUSH
7656: LD_INT 23
7658: PUSH
7659: LD_INT 1
7661: PUSH
7662: LD_INT 3
7664: PUSH
7665: LD_INT 44
7667: PUSH
7668: EMPTY
7669: LIST
7670: LIST
7671: LIST
7672: LIST
7673: PUSH
7674: LD_INT 23
7676: PUSH
7677: LD_INT 1
7679: PUSH
7680: LD_INT 3
7682: PUSH
7683: LD_INT 45
7685: PUSH
7686: EMPTY
7687: LIST
7688: LIST
7689: LIST
7690: LIST
7691: PUSH
7692: LD_INT 21
7694: PUSH
7695: LD_INT 1
7697: PUSH
7698: LD_INT 3
7700: PUSH
7701: LD_INT 44
7703: PUSH
7704: EMPTY
7705: LIST
7706: LIST
7707: LIST
7708: LIST
7709: PUSH
7710: LD_INT 21
7712: PUSH
7713: LD_INT 1
7715: PUSH
7716: LD_INT 3
7718: PUSH
7719: LD_INT 45
7721: PUSH
7722: EMPTY
7723: LIST
7724: LIST
7725: LIST
7726: LIST
7727: PUSH
7728: EMPTY
7729: LIST
7730: LIST
7731: LIST
7732: LIST
7733: PPUSH
7734: CALL 75267 0 2
// MC_SetFactoryExtension ( 3 , 94 , 161 , 0 , [ b_ext_noncombat , b_ext_gun , b_ext_rocket , b_ext_computer , b_ext_siberium ] ) ;
7738: LD_INT 3
7740: PPUSH
7741: LD_INT 94
7743: PPUSH
7744: LD_INT 161
7746: PPUSH
7747: LD_INT 0
7749: PPUSH
7750: LD_INT 19
7752: PUSH
7753: LD_INT 17
7755: PUSH
7756: LD_INT 18
7758: PUSH
7759: LD_INT 24
7761: PUSH
7762: LD_INT 21
7764: PUSH
7765: EMPTY
7766: LIST
7767: LIST
7768: LIST
7769: LIST
7770: LIST
7771: PPUSH
7772: CALL 76214 0 5
// MC_InsertProduceList ( 3 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] ] ) ;
7776: LD_INT 3
7778: PPUSH
7779: LD_INT 21
7781: PUSH
7782: LD_INT 1
7784: PUSH
7785: LD_INT 3
7787: PUSH
7788: LD_INT 51
7790: PUSH
7791: EMPTY
7792: LIST
7793: LIST
7794: LIST
7795: LIST
7796: PUSH
7797: EMPTY
7798: LIST
7799: PPUSH
7800: CALL 75315 0 2
// end ;
7804: LD_VAR 0 1
7808: RET
// every 9 9$00 trigger extraPopovForces and not ruDestroyed do
7809: LD_EXP 18
7813: PUSH
7814: LD_EXP 5
7818: NOT
7819: AND
7820: IFFALSE 7880
7822: GO 7824
7824: DISABLE
// begin ComMoveXY ( extraPopovForces , 106 , 137 ) ;
7825: LD_EXP 18
7829: PPUSH
7830: LD_INT 106
7832: PPUSH
7833: LD_INT 137
7835: PPUSH
7836: CALL_OW 111
// mc_bases := Replace ( mc_bases , 3 , mc_bases [ 3 ] union extraPopovForces ) ;
7840: LD_ADDR_EXP 23
7844: PUSH
7845: LD_EXP 23
7849: PPUSH
7850: LD_INT 3
7852: PPUSH
7853: LD_EXP 23
7857: PUSH
7858: LD_INT 3
7860: ARRAY
7861: PUSH
7862: LD_EXP 18
7866: UNION
7867: PPUSH
7868: CALL_OW 1
7872: ST_TO_ADDR
// extraPopovForces := [ ] ;
7873: LD_ADDR_EXP 18
7877: PUSH
7878: EMPTY
7879: ST_TO_ADDR
// end ;
7880: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ru_depot ) and not ruDestroyed do var i , base , tmp , attackers , amount ;
7881: LD_INT 9
7883: PPUSH
7884: CALL_OW 302
7888: PUSH
7889: LD_EXP 5
7893: NOT
7894: AND
7895: IFFALSE 8461
7897: GO 7899
7899: DISABLE
7900: LD_INT 0
7902: PPUSH
7903: PPUSH
7904: PPUSH
7905: PPUSH
7906: PPUSH
// begin enable ;
7907: ENABLE
// base := 3 ;
7908: LD_ADDR_VAR 0 2
7912: PUSH
7913: LD_INT 3
7915: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] ] ;
7916: LD_ADDR_VAR 0 3
7920: PUSH
7921: LD_INT 22
7923: PUSH
7924: LD_INT 1
7926: PUSH
7927: LD_INT 3
7929: PUSH
7930: LD_INT 44
7932: PUSH
7933: EMPTY
7934: LIST
7935: LIST
7936: LIST
7937: LIST
7938: PUSH
7939: LD_INT 24
7941: PUSH
7942: LD_INT 1
7944: PUSH
7945: LD_INT 3
7947: PUSH
7948: LD_INT 46
7950: PUSH
7951: EMPTY
7952: LIST
7953: LIST
7954: LIST
7955: LIST
7956: PUSH
7957: LD_INT 24
7959: PUSH
7960: LD_INT 1
7962: PUSH
7963: LD_INT 3
7965: PUSH
7966: LD_INT 46
7968: PUSH
7969: EMPTY
7970: LIST
7971: LIST
7972: LIST
7973: LIST
7974: PUSH
7975: LD_INT 24
7977: PUSH
7978: LD_INT 1
7980: PUSH
7981: LD_INT 3
7983: PUSH
7984: LD_INT 46
7986: PUSH
7987: EMPTY
7988: LIST
7989: LIST
7990: LIST
7991: LIST
7992: PUSH
7993: EMPTY
7994: LIST
7995: LIST
7996: LIST
7997: LIST
7998: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
7999: LD_ADDR_VAR 0 5
8003: PUSH
8004: LD_VAR 0 5
8008: PUSH
8009: LD_OWVAR 1
8013: PUSH
8014: LD_INT 21000
8016: DIV
8017: PLUS
8018: ST_TO_ADDR
// if amount > 8 then
8019: LD_VAR 0 5
8023: PUSH
8024: LD_INT 8
8026: GREATER
8027: IFFALSE 8037
// amount := 8 ;
8029: LD_ADDR_VAR 0 5
8033: PUSH
8034: LD_INT 8
8036: ST_TO_ADDR
// for i = 1 to amount do
8037: LD_ADDR_VAR 0 1
8041: PUSH
8042: DOUBLE
8043: LD_INT 1
8045: DEC
8046: ST_TO_ADDR
8047: LD_VAR 0 5
8051: PUSH
8052: FOR_TO
8053: IFFALSE 8118
// tmp := Insert ( tmp , tmp + 1 , [ ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
8055: LD_ADDR_VAR 0 3
8059: PUSH
8060: LD_VAR 0 3
8064: PPUSH
8065: LD_VAR 0 3
8069: PUSH
8070: LD_INT 1
8072: PLUS
8073: PPUSH
8074: LD_INT 24
8076: PUSH
8077: LD_INT 1
8079: PUSH
8080: LD_INT 3
8082: PUSH
8083: LD_INT 46
8085: PUSH
8086: LD_INT 45
8088: PUSH
8089: EMPTY
8090: LIST
8091: LIST
8092: PUSH
8093: LD_INT 1
8095: PPUSH
8096: LD_INT 2
8098: PPUSH
8099: CALL_OW 12
8103: ARRAY
8104: PUSH
8105: EMPTY
8106: LIST
8107: LIST
8108: LIST
8109: LIST
8110: PPUSH
8111: CALL_OW 2
8115: ST_TO_ADDR
8116: GO 8052
8118: POP
8119: POP
// MC_InsertProduceList ( base , tmp ) ;
8120: LD_VAR 0 2
8124: PPUSH
8125: LD_VAR 0 3
8129: PPUSH
8130: CALL 75315 0 2
// repeat wait ( 0 0$1 ) ;
8134: LD_INT 35
8136: PPUSH
8137: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
8141: LD_VAR 0 2
8145: PPUSH
8146: LD_INT 1
8148: PPUSH
8149: CALL 76733 0 2
8153: PUSH
8154: LD_VAR 0 5
8158: GREATEREQUAL
8159: IFFALSE 8134
// wait ( 0 0$30 ) ;
8161: LD_INT 1050
8163: PPUSH
8164: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
8168: LD_ADDR_VAR 0 4
8172: PUSH
8173: LD_EXP 42
8177: PUSH
8178: LD_VAR 0 2
8182: ARRAY
8183: PUSH
8184: LD_EXP 42
8188: PUSH
8189: LD_VAR 0 2
8193: ARRAY
8194: PPUSH
8195: LD_INT 2
8197: PUSH
8198: LD_INT 34
8200: PUSH
8201: LD_INT 51
8203: PUSH
8204: EMPTY
8205: LIST
8206: LIST
8207: PUSH
8208: LD_INT 34
8210: PUSH
8211: LD_INT 52
8213: PUSH
8214: EMPTY
8215: LIST
8216: LIST
8217: PUSH
8218: EMPTY
8219: LIST
8220: LIST
8221: LIST
8222: PPUSH
8223: CALL_OW 72
8227: DIFF
8228: ST_TO_ADDR
// if not attackers then
8229: LD_VAR 0 4
8233: NOT
8234: IFFALSE 8238
// exit ;
8236: GO 8461
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
8238: LD_ADDR_EXP 42
8242: PUSH
8243: LD_EXP 42
8247: PPUSH
8248: LD_VAR 0 2
8252: PPUSH
8253: LD_EXP 42
8257: PUSH
8258: LD_VAR 0 2
8262: ARRAY
8263: PUSH
8264: LD_VAR 0 4
8268: DIFF
8269: PPUSH
8270: CALL_OW 1
8274: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
8275: LD_VAR 0 4
8279: PPUSH
8280: LD_INT 107
8282: PPUSH
8283: LD_INT 74
8285: PPUSH
8286: CALL_OW 114
// wait ( 0 0$5 ) ;
8290: LD_INT 175
8292: PPUSH
8293: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8297: LD_INT 35
8299: PPUSH
8300: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
8304: LD_VAR 0 4
8308: PPUSH
8309: LD_INT 60
8311: PUSH
8312: EMPTY
8313: LIST
8314: PPUSH
8315: CALL_OW 72
8319: NOT
8320: IFFALSE 8297
// if rand ( 0 , 1 ) then
8322: LD_INT 0
8324: PPUSH
8325: LD_INT 1
8327: PPUSH
8328: CALL_OW 12
8332: IFFALSE 8351
// ComAgressiveMove ( attackers , 155 , 108 ) else
8334: LD_VAR 0 4
8338: PPUSH
8339: LD_INT 155
8341: PPUSH
8342: LD_INT 108
8344: PPUSH
8345: CALL_OW 114
8349: GO 8366
// ComAgressiveMove ( attackers , 149 , 55 ) ;
8351: LD_VAR 0 4
8355: PPUSH
8356: LD_INT 149
8358: PPUSH
8359: LD_INT 55
8361: PPUSH
8362: CALL_OW 114
// wait ( 0 0$10 ) ;
8366: LD_INT 350
8368: PPUSH
8369: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8373: LD_INT 35
8375: PPUSH
8376: CALL_OW 67
// for i in attackers do
8380: LD_ADDR_VAR 0 1
8384: PUSH
8385: LD_VAR 0 4
8389: PUSH
8390: FOR_IN
8391: IFFALSE 8441
// if not HasTask ( i ) then
8393: LD_VAR 0 1
8397: PPUSH
8398: CALL_OW 314
8402: NOT
8403: IFFALSE 8439
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8405: LD_VAR 0 1
8409: PPUSH
8410: LD_INT 81
8412: PUSH
8413: LD_INT 3
8415: PUSH
8416: EMPTY
8417: LIST
8418: LIST
8419: PPUSH
8420: CALL_OW 69
8424: PPUSH
8425: LD_VAR 0 1
8429: PPUSH
8430: CALL_OW 74
8434: PPUSH
8435: CALL_OW 115
8439: GO 8390
8441: POP
8442: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
8443: LD_VAR 0 4
8447: PPUSH
8448: LD_INT 50
8450: PUSH
8451: EMPTY
8452: LIST
8453: PPUSH
8454: CALL_OW 72
8458: NOT
8459: IFFALSE 8373
// end ;
8461: PPOPN 5
8463: END
// every 12 12$00 + 10 10$00 trigger not ruDestroyed do var i , un , tmp , amount ;
8464: LD_EXP 5
8468: NOT
8469: IFFALSE 9056
8471: GO 8473
8473: DISABLE
8474: LD_INT 0
8476: PPUSH
8477: PPUSH
8478: PPUSH
8479: PPUSH
// begin enable ;
8480: ENABLE
// if Difficulty = 1 and tick < 30 30$00 then
8481: LD_OWVAR 67
8485: PUSH
8486: LD_INT 1
8488: EQUAL
8489: PUSH
8490: LD_OWVAR 1
8494: PUSH
8495: LD_INT 63000
8497: LESS
8498: AND
8499: IFFALSE 8503
// exit ;
8501: GO 9056
// tmp := [ ] ;
8503: LD_ADDR_VAR 0 3
8507: PUSH
8508: EMPTY
8509: ST_TO_ADDR
// if tick < 45 45$00 then
8510: LD_OWVAR 1
8514: PUSH
8515: LD_INT 94500
8517: LESS
8518: IFFALSE 8695
// begin for i := 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
8520: LD_ADDR_VAR 0 1
8524: PUSH
8525: DOUBLE
8526: LD_INT 1
8528: DEC
8529: ST_TO_ADDR
8530: LD_INT 2
8532: PUSH
8533: LD_INT 3
8535: PUSH
8536: LD_INT 4
8538: PUSH
8539: EMPTY
8540: LIST
8541: LIST
8542: LIST
8543: PUSH
8544: LD_OWVAR 67
8548: ARRAY
8549: PUSH
8550: FOR_TO
8551: IFFALSE 8693
// begin uc_side := 3 ;
8553: LD_ADDR_OWVAR 20
8557: PUSH
8558: LD_INT 3
8560: ST_TO_ADDR
// uc_nation := 3 ;
8561: LD_ADDR_OWVAR 21
8565: PUSH
8566: LD_INT 3
8568: ST_TO_ADDR
// InitHC_All ( ) ;
8569: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
8573: LD_INT 0
8575: PPUSH
8576: LD_INT 1
8578: PPUSH
8579: LD_INT 5
8581: PUSH
8582: LD_INT 6
8584: PUSH
8585: LD_INT 7
8587: PUSH
8588: EMPTY
8589: LIST
8590: LIST
8591: LIST
8592: PUSH
8593: LD_OWVAR 67
8597: ARRAY
8598: PPUSH
8599: CALL_OW 380
// un := CreateHuman ;
8603: LD_ADDR_VAR 0 2
8607: PUSH
8608: CALL_OW 44
8612: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
8613: LD_VAR 0 2
8617: PPUSH
8618: LD_INT 18
8620: PPUSH
8621: LD_INT 0
8623: PPUSH
8624: CALL_OW 49
// SetClass ( un , class_bazooker ) ;
8628: LD_VAR 0 2
8632: PPUSH
8633: LD_INT 9
8635: PPUSH
8636: CALL_OW 336
// ComMoveXY ( un , 147 , 161 ) ;
8640: LD_VAR 0 2
8644: PPUSH
8645: LD_INT 147
8647: PPUSH
8648: LD_INT 161
8650: PPUSH
8651: CALL_OW 111
// wait ( 0 0$2 ) ;
8655: LD_INT 70
8657: PPUSH
8658: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8662: LD_ADDR_VAR 0 3
8666: PUSH
8667: LD_VAR 0 3
8671: PPUSH
8672: LD_VAR 0 3
8676: PUSH
8677: LD_INT 1
8679: PLUS
8680: PPUSH
8681: LD_VAR 0 2
8685: PPUSH
8686: CALL_OW 1
8690: ST_TO_ADDR
// end ;
8691: GO 8550
8693: POP
8694: POP
// end ; amount := [ 3 , 4 , 5 ] [ Difficulty ] + tick div 10 10$00 ;
8695: LD_ADDR_VAR 0 4
8699: PUSH
8700: LD_INT 3
8702: PUSH
8703: LD_INT 4
8705: PUSH
8706: LD_INT 5
8708: PUSH
8709: EMPTY
8710: LIST
8711: LIST
8712: LIST
8713: PUSH
8714: LD_OWVAR 67
8718: ARRAY
8719: PUSH
8720: LD_OWVAR 1
8724: PUSH
8725: LD_INT 21000
8727: DIV
8728: PLUS
8729: ST_TO_ADDR
// if amount > 15 then
8730: LD_VAR 0 4
8734: PUSH
8735: LD_INT 15
8737: GREATER
8738: IFFALSE 8748
// amount := 15 ;
8740: LD_ADDR_VAR 0 4
8744: PUSH
8745: LD_INT 15
8747: ST_TO_ADDR
// for i := 1 to amount do
8748: LD_ADDR_VAR 0 1
8752: PUSH
8753: DOUBLE
8754: LD_INT 1
8756: DEC
8757: ST_TO_ADDR
8758: LD_VAR 0 4
8762: PUSH
8763: FOR_TO
8764: IFFALSE 8910
// begin uc_side := 3 ;
8766: LD_ADDR_OWVAR 20
8770: PUSH
8771: LD_INT 3
8773: ST_TO_ADDR
// uc_nation := 3 ;
8774: LD_ADDR_OWVAR 21
8778: PUSH
8779: LD_INT 3
8781: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 5 ) ] , 90 ) ;
8782: LD_INT 24
8784: PPUSH
8785: LD_INT 1
8787: PPUSH
8788: LD_INT 3
8790: PPUSH
8791: LD_INT 46
8793: PUSH
8794: LD_INT 45
8796: PUSH
8797: LD_INT 44
8799: PUSH
8800: LD_INT 43
8802: PUSH
8803: LD_INT 42
8805: PUSH
8806: EMPTY
8807: LIST
8808: LIST
8809: LIST
8810: LIST
8811: LIST
8812: PUSH
8813: LD_INT 1
8815: PPUSH
8816: LD_INT 5
8818: PPUSH
8819: CALL_OW 12
8823: ARRAY
8824: PPUSH
8825: LD_INT 90
8827: PPUSH
8828: CALL 15868 0 5
// un := CreateVehicle ;
8832: LD_ADDR_VAR 0 2
8836: PUSH
8837: CALL_OW 45
8841: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
8842: LD_VAR 0 2
8846: PPUSH
8847: LD_INT 18
8849: PPUSH
8850: LD_INT 0
8852: PPUSH
8853: CALL_OW 49
// ComMoveXY ( un , 147 , 161 ) ;
8857: LD_VAR 0 2
8861: PPUSH
8862: LD_INT 147
8864: PPUSH
8865: LD_INT 161
8867: PPUSH
8868: CALL_OW 111
// wait ( 0 0$3 ) ;
8872: LD_INT 105
8874: PPUSH
8875: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8879: LD_ADDR_VAR 0 3
8883: PUSH
8884: LD_VAR 0 3
8888: PPUSH
8889: LD_VAR 0 3
8893: PUSH
8894: LD_INT 1
8896: PLUS
8897: PPUSH
8898: LD_VAR 0 2
8902: PPUSH
8903: CALL_OW 1
8907: ST_TO_ADDR
// end ;
8908: GO 8763
8910: POP
8911: POP
// if not tmp then
8912: LD_VAR 0 3
8916: NOT
8917: IFFALSE 8921
// exit ;
8919: GO 9056
// wait ( 0 0$5 ) ;
8921: LD_INT 175
8923: PPUSH
8924: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
8928: LD_INT 70
8930: PPUSH
8931: CALL_OW 67
// for i in tmp do
8935: LD_ADDR_VAR 0 1
8939: PUSH
8940: LD_VAR 0 3
8944: PUSH
8945: FOR_IN
8946: IFFALSE 9047
// begin if not IsOk ( i ) or IsDead ( i ) then
8948: LD_VAR 0 1
8952: PPUSH
8953: CALL_OW 302
8957: NOT
8958: PUSH
8959: LD_VAR 0 1
8963: PPUSH
8964: CALL_OW 301
8968: OR
8969: IFFALSE 8987
// tmp := tmp diff i ;
8971: LD_ADDR_VAR 0 3
8975: PUSH
8976: LD_VAR 0 3
8980: PUSH
8981: LD_VAR 0 1
8985: DIFF
8986: ST_TO_ADDR
// if GetClass ( i ) = class_bazooker then
8987: LD_VAR 0 1
8991: PPUSH
8992: CALL_OW 257
8996: PUSH
8997: LD_INT 9
8999: EQUAL
9000: IFFALSE 9011
// ComSpaceTimeShoot ( i ) ;
9002: LD_VAR 0 1
9006: PPUSH
9007: CALL 11951 0 1
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9011: LD_VAR 0 1
9015: PPUSH
9016: LD_INT 81
9018: PUSH
9019: LD_INT 3
9021: PUSH
9022: EMPTY
9023: LIST
9024: LIST
9025: PPUSH
9026: CALL_OW 69
9030: PPUSH
9031: LD_VAR 0 1
9035: PPUSH
9036: CALL_OW 74
9040: PPUSH
9041: CALL_OW 115
// end ;
9045: GO 8945
9047: POP
9048: POP
// until not tmp ;
9049: LD_VAR 0 3
9053: NOT
9054: IFFALSE 8928
// end ; end_of_file
9056: PPOPN 4
9058: END
// export Sikorski ; export function PrepareSikorski ; var i , j , un ; begin
9059: LD_INT 0
9061: PPUSH
9062: PPUSH
9063: PPUSH
9064: PPUSH
// uc_side := 1 ;
9065: LD_ADDR_OWVAR 20
9069: PUSH
9070: LD_INT 1
9072: ST_TO_ADDR
// uc_nation := 1 ;
9073: LD_ADDR_OWVAR 21
9077: PUSH
9078: LD_INT 1
9080: ST_TO_ADDR
// hc_importance := 100 ;
9081: LD_ADDR_OWVAR 32
9085: PUSH
9086: LD_INT 100
9088: ST_TO_ADDR
// hc_name := Jeremy Sikorski ;
9089: LD_ADDR_OWVAR 26
9093: PUSH
9094: LD_STRING Jeremy Sikorski
9096: ST_TO_ADDR
// hc_gallery := us ;
9097: LD_ADDR_OWVAR 33
9101: PUSH
9102: LD_STRING us
9104: ST_TO_ADDR
// hc_face_number := 19 ;
9105: LD_ADDR_OWVAR 34
9109: PUSH
9110: LD_INT 19
9112: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , [ 4 , 4 , 3 ] [ Difficulty ] ) ;
9113: LD_INT 1
9115: PPUSH
9116: LD_INT 1
9118: PPUSH
9119: LD_INT 4
9121: PUSH
9122: LD_INT 4
9124: PUSH
9125: LD_INT 3
9127: PUSH
9128: EMPTY
9129: LIST
9130: LIST
9131: LIST
9132: PUSH
9133: LD_OWVAR 67
9137: ARRAY
9138: PPUSH
9139: CALL_OW 380
// hc_attr := [ 10 , 12 ] ;
9143: LD_ADDR_OWVAR 29
9147: PUSH
9148: LD_INT 10
9150: PUSH
9151: LD_INT 12
9153: PUSH
9154: EMPTY
9155: LIST
9156: LIST
9157: ST_TO_ADDR
// Sikorski := CreateHuman ;
9158: LD_ADDR_EXP 20
9162: PUSH
9163: CALL_OW 44
9167: ST_TO_ADDR
// PlaceUnitXYR ( Sikorski , 133 , 19 , 2 , false ) ;
9168: LD_EXP 20
9172: PPUSH
9173: LD_INT 133
9175: PPUSH
9176: LD_INT 19
9178: PPUSH
9179: LD_INT 2
9181: PPUSH
9182: LD_INT 0
9184: PPUSH
9185: CALL_OW 50
// InitHc_All ( ) ;
9189: CALL_OW 584
// for i := 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
9193: LD_ADDR_VAR 0 2
9197: PUSH
9198: DOUBLE
9199: LD_INT 1
9201: DEC
9202: ST_TO_ADDR
9203: LD_INT 4
9205: PUSH
9206: LD_INT 3
9208: PUSH
9209: LD_INT 3
9211: PUSH
9212: EMPTY
9213: LIST
9214: LIST
9215: LIST
9216: PUSH
9217: LD_OWVAR 67
9221: ARRAY
9222: PUSH
9223: FOR_TO
9224: IFFALSE 9340
// for j := 1 to 4 do
9226: LD_ADDR_VAR 0 3
9230: PUSH
9231: DOUBLE
9232: LD_INT 1
9234: DEC
9235: ST_TO_ADDR
9236: LD_INT 4
9238: PUSH
9239: FOR_TO
9240: IFFALSE 9336
// begin PrepareHuman ( false , j , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
9242: LD_INT 0
9244: PPUSH
9245: LD_VAR 0 3
9249: PPUSH
9250: LD_INT 5
9252: PUSH
9253: LD_INT 4
9255: PUSH
9256: LD_INT 3
9258: PUSH
9259: EMPTY
9260: LIST
9261: LIST
9262: LIST
9263: PUSH
9264: LD_OWVAR 67
9268: ARRAY
9269: PPUSH
9270: CALL_OW 380
// un := CreateHuman ;
9274: LD_ADDR_VAR 0 4
9278: PUSH
9279: CALL_OW 44
9283: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
9284: LD_VAR 0 4
9288: PPUSH
9289: LD_INT 0
9291: PPUSH
9292: LD_INT 5
9294: PPUSH
9295: CALL_OW 12
9299: PPUSH
9300: CALL_OW 233
// PlaceUnitXYR ( un , 133 , 19 , 6 , false ) ;
9304: LD_VAR 0 4
9308: PPUSH
9309: LD_INT 133
9311: PPUSH
9312: LD_INT 19
9314: PPUSH
9315: LD_INT 6
9317: PPUSH
9318: LD_INT 0
9320: PPUSH
9321: CALL_OW 50
// ComHold ( un ) ;
9325: LD_VAR 0 4
9329: PPUSH
9330: CALL_OW 140
// end ;
9334: GO 9239
9336: POP
9337: POP
9338: GO 9223
9340: POP
9341: POP
// vc_chassis := us_heavy_tracked ;
9342: LD_ADDR_OWVAR 37
9346: PUSH
9347: LD_INT 4
9349: ST_TO_ADDR
// vc_engine := engine_combustion ;
9350: LD_ADDR_OWVAR 39
9354: PUSH
9355: LD_INT 1
9357: ST_TO_ADDR
// vc_control := control_manual ;
9358: LD_ADDR_OWVAR 38
9362: PUSH
9363: LD_INT 1
9365: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
9366: LD_ADDR_OWVAR 40
9370: PUSH
9371: LD_INT 14
9373: ST_TO_ADDR
// vc_fuel_battery := 60 ;
9374: LD_ADDR_OWVAR 41
9378: PUSH
9379: LD_INT 60
9381: ST_TO_ADDR
// un := CreateVehicle ;
9382: LD_ADDR_VAR 0 4
9386: PUSH
9387: CALL_OW 45
9391: ST_TO_ADDR
// SetDir ( un , 2 ) ;
9392: LD_VAR 0 4
9396: PPUSH
9397: LD_INT 2
9399: PPUSH
9400: CALL_OW 233
// PlaceUnitXY ( un , 128 , 12 , false ) ;
9404: LD_VAR 0 4
9408: PPUSH
9409: LD_INT 128
9411: PPUSH
9412: LD_INT 12
9414: PPUSH
9415: LD_INT 0
9417: PPUSH
9418: CALL_OW 48
// for i := 1 to 3 do
9422: LD_ADDR_VAR 0 2
9426: PUSH
9427: DOUBLE
9428: LD_INT 1
9430: DEC
9431: ST_TO_ADDR
9432: LD_INT 3
9434: PUSH
9435: FOR_TO
9436: IFFALSE 9459
// CreateCratesXYR ( 5 , 133 , 19 , 3 , false ) ;
9438: LD_INT 5
9440: PPUSH
9441: LD_INT 133
9443: PPUSH
9444: LD_INT 19
9446: PPUSH
9447: LD_INT 3
9449: PPUSH
9450: LD_INT 0
9452: PPUSH
9453: CALL_OW 56
9457: GO 9435
9459: POP
9460: POP
// end ; end_of_file
9461: LD_VAR 0 1
9465: RET
// export function Action ; begin
9466: LD_INT 0
9468: PPUSH
// InGameOn ;
9469: CALL_OW 8
// CenterNowOnXY ( 133 , 19 ) ;
9473: LD_INT 133
9475: PPUSH
9476: LD_INT 19
9478: PPUSH
9479: CALL_OW 86
// Say ( Sikorski , WT-DS-1 ) ;
9483: LD_EXP 20
9487: PPUSH
9488: LD_STRING WT-DS-1
9490: PPUSH
9491: CALL_OW 88
// InGameOff ;
9495: CALL_OW 9
// ChangeMissionObjectives ( DestroyEnemy ) ;
9499: LD_STRING DestroyEnemy
9501: PPUSH
9502: CALL_OW 337
// wait ( 0 0$20 ) ;
9506: LD_INT 700
9508: PPUSH
9509: CALL_OW 67
// DialogueOn ;
9513: CALL_OW 6
// PlaceSeeing ( 100 , 37 , 1 , - 30 ) ;
9517: LD_INT 100
9519: PPUSH
9520: LD_INT 37
9522: PPUSH
9523: LD_INT 1
9525: PPUSH
9526: LD_INT 30
9528: NEG
9529: PPUSH
9530: CALL_OW 330
// CenterNowOnXY ( 100 , 37 ) ;
9534: LD_INT 100
9536: PPUSH
9537: LD_INT 37
9539: PPUSH
9540: CALL_OW 86
// SayRadio ( Powell , WT-PL-1 ) ;
9544: LD_EXP 10
9548: PPUSH
9549: LD_STRING WT-PL-1
9551: PPUSH
9552: CALL_OW 94
// Say ( Sikorski , WT-DS-2 ) ;
9556: LD_EXP 20
9560: PPUSH
9561: LD_STRING WT-DS-2
9563: PPUSH
9564: CALL_OW 88
// DialogueOff ;
9568: CALL_OW 7
// wait ( 0 0$2 ) ;
9572: LD_INT 70
9574: PPUSH
9575: CALL_OW 67
// RemoveSeeing ( 100 , 37 , 1 ) ;
9579: LD_INT 100
9581: PPUSH
9582: LD_INT 37
9584: PPUSH
9585: LD_INT 1
9587: PPUSH
9588: CALL_OW 331
// end ;
9592: LD_VAR 0 1
9596: RET
// export function DialogPowellsAttack ; begin
9597: LD_INT 0
9599: PPUSH
// SayRadio ( Powell , WT-PL-8 ) ;
9600: LD_EXP 10
9604: PPUSH
9605: LD_STRING WT-PL-8
9607: PPUSH
9608: CALL_OW 94
// end ;
9612: LD_VAR 0 1
9616: RET
// export function DialogContaminateSib ( x , y ) ; begin
9617: LD_INT 0
9619: PPUSH
// DialogueOn ;
9620: CALL_OW 6
// CenterNowOnXY ( x , y ) ;
9624: LD_VAR 0 1
9628: PPUSH
9629: LD_VAR 0 2
9633: PPUSH
9634: CALL_OW 86
// Say ( Sikorski , WT-DS-3 ) ;
9638: LD_EXP 20
9642: PPUSH
9643: LD_STRING WT-DS-3
9645: PPUSH
9646: CALL_OW 88
// DialogueOff ;
9650: CALL_OW 7
// end ;
9654: LD_VAR 0 3
9658: RET
// every 0 0$3 trigger not powellInTrouble and FilterUnitsInArea ( powell_base , [ f_enemy , 4 ] ) > 3 do
9659: LD_EXP 8
9663: NOT
9664: PUSH
9665: LD_INT 1
9667: PPUSH
9668: LD_INT 81
9670: PUSH
9671: LD_INT 4
9673: PUSH
9674: EMPTY
9675: LIST
9676: LIST
9677: PPUSH
9678: CALL_OW 70
9682: PUSH
9683: LD_INT 3
9685: GREATER
9686: AND
9687: IFFALSE 9759
9689: GO 9691
9691: DISABLE
// begin powellInTrouble := true ;
9692: LD_ADDR_EXP 8
9696: PUSH
9697: LD_INT 1
9699: ST_TO_ADDR
// Say ( Sikorski , WT-DS-6 ) ;
9700: LD_EXP 20
9704: PPUSH
9705: LD_STRING WT-DS-6
9707: PPUSH
9708: CALL_OW 88
// if not FilterUnitsInArea ( powell_base , [ f_side , 1 ] ) then
9712: LD_INT 1
9714: PPUSH
9715: LD_INT 22
9717: PUSH
9718: LD_INT 1
9720: PUSH
9721: EMPTY
9722: LIST
9723: LIST
9724: PPUSH
9725: CALL_OW 70
9729: NOT
9730: IFFALSE 9744
// SayRadio ( Powell , WT-PL-6 ) ;
9732: LD_EXP 10
9736: PPUSH
9737: LD_STRING WT-PL-6
9739: PPUSH
9740: CALL_OW 94
// wait ( 1 1$30 ) ;
9744: LD_INT 3150
9746: PPUSH
9747: CALL_OW 67
// powellInTrouble := false ;
9751: LD_ADDR_EXP 8
9755: PUSH
9756: LD_INT 0
9758: ST_TO_ADDR
// end ;
9759: END
// every 0 0$3 trigger not sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 1 ] ) > 6 do
9760: LD_EXP 9
9764: NOT
9765: PUSH
9766: LD_INT 16
9768: PPUSH
9769: LD_INT 81
9771: PUSH
9772: LD_INT 1
9774: PUSH
9775: EMPTY
9776: LIST
9777: LIST
9778: PPUSH
9779: CALL_OW 70
9783: PUSH
9784: LD_INT 6
9786: GREATER
9787: AND
9788: IFFALSE 9861
9790: GO 9792
9792: DISABLE
// begin sikorskiInTrouble := true ;
9793: LD_ADDR_EXP 9
9797: PUSH
9798: LD_INT 1
9800: ST_TO_ADDR
// Say ( Sikorski , WT-DS-7 ) ;
9801: LD_EXP 20
9805: PPUSH
9806: LD_STRING WT-DS-7
9808: PPUSH
9809: CALL_OW 88
// if not powellAttackGroup then
9813: LD_EXP 12
9817: NOT
9818: IFFALSE 9834
// SayRadio ( Powell , WT-PL-7n ) else
9820: LD_EXP 10
9824: PPUSH
9825: LD_STRING WT-PL-7n
9827: PPUSH
9828: CALL_OW 94
9832: GO 9846
// SayRadio ( Powell , WT-PL-7y ) ;
9834: LD_EXP 10
9838: PPUSH
9839: LD_STRING WT-PL-7y
9841: PPUSH
9842: CALL_OW 94
// wait ( 1 1$30 ) ;
9846: LD_INT 3150
9848: PPUSH
9849: CALL_OW 67
// sikorskiInTrouble := false ;
9853: LD_ADDR_EXP 9
9857: PUSH
9858: LD_INT 0
9860: ST_TO_ADDR
// end ;
9861: END
// export function DialogPowellsAttackFailed ; begin
9862: LD_INT 0
9864: PPUSH
// if not ruDestroyed then
9865: LD_EXP 5
9869: NOT
9870: IFFALSE 9886
// SayRadio ( Powell , WT-PL-9 ) else
9872: LD_EXP 10
9876: PPUSH
9877: LD_STRING WT-PL-9
9879: PPUSH
9880: CALL_OW 94
9884: GO 9898
// SayRadio ( Powell , WT-PL-10 ) ;
9886: LD_EXP 10
9890: PPUSH
9891: LD_STRING WT-PL-10
9893: PPUSH
9894: CALL_OW 94
// end ;
9898: LD_VAR 0 1
9902: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
9903: LD_INT 22
9905: PUSH
9906: LD_INT 2
9908: PUSH
9909: EMPTY
9910: LIST
9911: LIST
9912: PUSH
9913: LD_INT 21
9915: PUSH
9916: LD_INT 1
9918: PUSH
9919: EMPTY
9920: LIST
9921: LIST
9922: PUSH
9923: EMPTY
9924: LIST
9925: LIST
9926: PPUSH
9927: CALL_OW 69
9931: PUSH
9932: LD_INT 0
9934: EQUAL
9935: IFFALSE 9979
9937: GO 9939
9939: DISABLE
// begin arDestroyed := true ;
9940: LD_ADDR_EXP 4
9944: PUSH
9945: LD_INT 1
9947: ST_TO_ADDR
// MC_Kill ( 2 ) ;
9948: LD_INT 2
9950: PPUSH
9951: CALL 51337 0 1
// Say ( Sikorski , WT-DS-4 ) ;
9955: LD_EXP 20
9959: PPUSH
9960: LD_STRING WT-DS-4
9962: PPUSH
9963: CALL_OW 88
// SayRadio ( Powell , WT-PL-4 ) ;
9967: LD_EXP 10
9971: PPUSH
9972: LD_STRING WT-PL-4
9974: PPUSH
9975: CALL_OW 94
// end ;
9979: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
9980: LD_INT 22
9982: PUSH
9983: LD_INT 3
9985: PUSH
9986: EMPTY
9987: LIST
9988: LIST
9989: PUSH
9990: LD_INT 21
9992: PUSH
9993: LD_INT 1
9995: PUSH
9996: EMPTY
9997: LIST
9998: LIST
9999: PUSH
10000: EMPTY
10001: LIST
10002: LIST
10003: PPUSH
10004: CALL_OW 69
10008: PUSH
10009: LD_INT 0
10011: EQUAL
10012: IFFALSE 10056
10014: GO 10016
10016: DISABLE
// begin ruDestroyed := true ;
10017: LD_ADDR_EXP 5
10021: PUSH
10022: LD_INT 1
10024: ST_TO_ADDR
// MC_Kill ( 3 ) ;
10025: LD_INT 3
10027: PPUSH
10028: CALL 51337 0 1
// Say ( Sikorski , WT-DS-5 ) ;
10032: LD_EXP 20
10036: PPUSH
10037: LD_STRING WT-DS-5
10039: PPUSH
10040: CALL_OW 88
// SayRadio ( Powell , WT-PL-5 ) ;
10044: LD_EXP 10
10048: PPUSH
10049: LD_STRING WT-PL-5
10051: PPUSH
10052: CALL_OW 94
// end ;
10056: END
// every 0 0$1 trigger ruDestroyed and arDestroyed do
10057: LD_EXP 5
10061: PUSH
10062: LD_EXP 4
10066: AND
10067: IFFALSE 10240
10069: GO 10071
10071: DISABLE
// begin wait ( 0 0$3 ) ;
10072: LD_INT 105
10074: PPUSH
10075: CALL_OW 67
// if tick >= [ 60 60$00 , 50 50$00 , 45 45$00 ] [ Difficulty ] then
10079: LD_OWVAR 1
10083: PUSH
10084: LD_INT 126000
10086: PUSH
10087: LD_INT 105000
10089: PUSH
10090: LD_INT 94500
10092: PUSH
10093: EMPTY
10094: LIST
10095: LIST
10096: LIST
10097: PUSH
10098: LD_OWVAR 67
10102: ARRAY
10103: GREATEREQUAL
10104: IFFALSE 10119
// AddMedal ( WoT-med-1 , - 1 ) else
10106: LD_STRING WoT-med-1
10108: PPUSH
10109: LD_INT 1
10111: NEG
10112: PPUSH
10113: CALL_OW 101
10117: GO 10129
// AddMedal ( WoT-med-1 , 1 ) ;
10119: LD_STRING WoT-med-1
10121: PPUSH
10122: LD_INT 1
10124: PPUSH
10125: CALL_OW 101
// if loseCounter >= [ 4 , 3 , 2 ] [ Difficulty ] then
10129: LD_EXP 6
10133: PUSH
10134: LD_INT 4
10136: PUSH
10137: LD_INT 3
10139: PUSH
10140: LD_INT 2
10142: PUSH
10143: EMPTY
10144: LIST
10145: LIST
10146: LIST
10147: PUSH
10148: LD_OWVAR 67
10152: ARRAY
10153: GREATEREQUAL
10154: IFFALSE 10169
// AddMedal ( WoT-med-2 , - 1 ) else
10156: LD_STRING WoT-med-2
10158: PPUSH
10159: LD_INT 1
10161: NEG
10162: PPUSH
10163: CALL_OW 101
10167: GO 10179
// AddMedal ( WoT-med-2 , 1 ) ;
10169: LD_STRING WoT-med-2
10171: PPUSH
10172: LD_INT 1
10174: PPUSH
10175: CALL_OW 101
// if powellLoseCounter >= [ 8 , 6 , 5 ] [ Difficulty ] then
10179: LD_EXP 7
10183: PUSH
10184: LD_INT 8
10186: PUSH
10187: LD_INT 6
10189: PUSH
10190: LD_INT 5
10192: PUSH
10193: EMPTY
10194: LIST
10195: LIST
10196: LIST
10197: PUSH
10198: LD_OWVAR 67
10202: ARRAY
10203: GREATEREQUAL
10204: IFFALSE 10219
// AddMedal ( WoT-med-3 , - 1 ) else
10206: LD_STRING WoT-med-3
10208: PPUSH
10209: LD_INT 1
10211: NEG
10212: PPUSH
10213: CALL_OW 101
10217: GO 10229
// AddMedal ( WoT-med-3 , 1 ) ;
10219: LD_STRING WoT-med-3
10221: PPUSH
10222: LD_INT 1
10224: PPUSH
10225: CALL_OW 101
// GiveMedals ( MAIN ) ;
10229: LD_STRING MAIN
10231: PPUSH
10232: CALL_OW 102
// YouWin ;
10236: CALL_OW 103
// end ; end_of_file
10240: END
// export function CustomEvent ( event ) ; begin
10241: LD_INT 0
10243: PPUSH
// end ;
10244: LD_VAR 0 2
10248: RET
// on Command ( com ) do var i , j , temp ;
10249: LD_INT 0
10251: PPUSH
10252: PPUSH
10253: PPUSH
// begin if com = 60 then
10254: LD_VAR 0 1
10258: PUSH
10259: LD_INT 60
10261: EQUAL
10262: IFFALSE 10441
// begin for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_weapon , us_cargo_bay ] ] ] ) do
10264: LD_ADDR_VAR 0 2
10268: PUSH
10269: LD_INT 22
10271: PUSH
10272: LD_INT 1
10274: PUSH
10275: EMPTY
10276: LIST
10277: LIST
10278: PUSH
10279: LD_INT 2
10281: PUSH
10282: LD_INT 21
10284: PUSH
10285: LD_INT 1
10287: PUSH
10288: EMPTY
10289: LIST
10290: LIST
10291: PUSH
10292: LD_INT 34
10294: PUSH
10295: LD_INT 12
10297: PUSH
10298: EMPTY
10299: LIST
10300: LIST
10301: PUSH
10302: EMPTY
10303: LIST
10304: LIST
10305: LIST
10306: PUSH
10307: EMPTY
10308: LIST
10309: LIST
10310: PPUSH
10311: CALL_OW 69
10315: PUSH
10316: FOR_IN
10317: IFFALSE 10439
// begin if GetTaskList ( i ) > 0 then
10319: LD_VAR 0 2
10323: PPUSH
10324: CALL_OW 437
10328: PUSH
10329: LD_INT 0
10331: GREATER
10332: IFFALSE 10437
// for j = 1 to GetTaskList ( i ) do
10334: LD_ADDR_VAR 0 3
10338: PUSH
10339: DOUBLE
10340: LD_INT 1
10342: DEC
10343: ST_TO_ADDR
10344: LD_VAR 0 2
10348: PPUSH
10349: CALL_OW 437
10353: PUSH
10354: FOR_TO
10355: IFFALSE 10435
// begin temp = GetTaskList ( i ) [ j ] [ 4 ] ;
10357: LD_ADDR_VAR 0 4
10361: PUSH
10362: LD_VAR 0 2
10366: PPUSH
10367: CALL_OW 437
10371: PUSH
10372: LD_VAR 0 3
10376: ARRAY
10377: PUSH
10378: LD_INT 4
10380: ARRAY
10381: ST_TO_ADDR
// if GetSide ( temp ) = 4 and GetTaskList ( i ) [ j ] [ 1 ] = < then
10382: LD_VAR 0 4
10386: PPUSH
10387: CALL_OW 255
10391: PUSH
10392: LD_INT 4
10394: EQUAL
10395: PUSH
10396: LD_VAR 0 2
10400: PPUSH
10401: CALL_OW 437
10405: PUSH
10406: LD_VAR 0 3
10410: ARRAY
10411: PUSH
10412: LD_INT 1
10414: ARRAY
10415: PUSH
10416: LD_STRING <
10418: EQUAL
10419: AND
10420: IFFALSE 10433
// SetTaskList ( i , [ ] ) ;
10422: LD_VAR 0 2
10426: PPUSH
10427: EMPTY
10428: PPUSH
10429: CALL_OW 446
// end ;
10433: GO 10354
10435: POP
10436: POP
// end ;
10437: GO 10316
10439: POP
10440: POP
// end ; end ;
10441: PPOPN 4
10443: END
// on SibDepositContaminated ( sci , x , y ) do begin if GetSide ( HexInfo ( x , y ) ) = 1 or ( x = 132 and y = 39 ) then
10444: LD_VAR 0 2
10448: PPUSH
10449: LD_VAR 0 3
10453: PPUSH
10454: CALL_OW 428
10458: PPUSH
10459: CALL_OW 255
10463: PUSH
10464: LD_INT 1
10466: EQUAL
10467: PUSH
10468: LD_VAR 0 2
10472: PUSH
10473: LD_INT 132
10475: EQUAL
10476: PUSH
10477: LD_VAR 0 3
10481: PUSH
10482: LD_INT 39
10484: EQUAL
10485: AND
10486: OR
10487: IFFALSE 10503
// DialogContaminateSib ( x , y ) ;
10489: LD_VAR 0 2
10493: PPUSH
10494: LD_VAR 0 3
10498: PPUSH
10499: CALL 9617 0 2
// end ;
10503: PPOPN 3
10505: END
// on UnitDestroyed ( un ) do begin MCE_UnitDestroyed ( un ) ;
10506: LD_VAR 0 1
10510: PPUSH
10511: CALL 78735 0 1
// if un = Powell then
10515: LD_VAR 0 1
10519: PUSH
10520: LD_EXP 10
10524: EQUAL
10525: IFFALSE 10534
// YouLost ( Powell ) ;
10527: LD_STRING Powell
10529: PPUSH
10530: CALL_OW 104
// if un = Sikorski then
10534: LD_VAR 0 1
10538: PUSH
10539: LD_EXP 20
10543: EQUAL
10544: IFFALSE 10553
// YouLost ( Sikorski ) ;
10546: LD_STRING Sikorski
10548: PPUSH
10549: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) then
10553: LD_VAR 0 1
10557: PUSH
10558: LD_INT 22
10560: PUSH
10561: LD_INT 1
10563: PUSH
10564: EMPTY
10565: LIST
10566: LIST
10567: PUSH
10568: LD_INT 21
10570: PUSH
10571: LD_INT 1
10573: PUSH
10574: EMPTY
10575: LIST
10576: LIST
10577: PUSH
10578: EMPTY
10579: LIST
10580: LIST
10581: PPUSH
10582: CALL_OW 69
10586: IN
10587: IFFALSE 10603
// loseCounter := loseCounter + 1 ;
10589: LD_ADDR_EXP 6
10593: PUSH
10594: LD_EXP 6
10598: PUSH
10599: LD_INT 1
10601: PLUS
10602: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) then
10603: LD_VAR 0 1
10607: PUSH
10608: LD_INT 22
10610: PUSH
10611: LD_INT 4
10613: PUSH
10614: EMPTY
10615: LIST
10616: LIST
10617: PUSH
10618: LD_INT 21
10620: PUSH
10621: LD_INT 1
10623: PUSH
10624: EMPTY
10625: LIST
10626: LIST
10627: PUSH
10628: EMPTY
10629: LIST
10630: LIST
10631: PPUSH
10632: CALL_OW 69
10636: IN
10637: IFFALSE 10653
// powellLoseCounter := powellLoseCounter + 1 ;
10639: LD_ADDR_EXP 7
10643: PUSH
10644: LD_EXP 7
10648: PUSH
10649: LD_INT 1
10651: PLUS
10652: ST_TO_ADDR
// if un in powellAttackGroup then
10653: LD_VAR 0 1
10657: PUSH
10658: LD_EXP 12
10662: IN
10663: IFFALSE 10681
// powellAttackGroup := powellAttackGroup diff un ;
10665: LD_ADDR_EXP 12
10669: PUSH
10670: LD_EXP 12
10674: PUSH
10675: LD_VAR 0 1
10679: DIFF
10680: ST_TO_ADDR
// if un in gensherAttackGroup then
10681: LD_VAR 0 1
10685: PUSH
10686: LD_EXP 15
10690: IN
10691: IFFALSE 10709
// gensherAttackGroup := gensherAttackGroup diff un ;
10693: LD_ADDR_EXP 15
10697: PUSH
10698: LD_EXP 15
10702: PUSH
10703: LD_VAR 0 1
10707: DIFF
10708: ST_TO_ADDR
// if un in popovAttackGroup then
10709: LD_VAR 0 1
10713: PUSH
10714: LD_EXP 19
10718: IN
10719: IFFALSE 10737
// popovAttackGroup := popovAttackGroup diff un ;
10721: LD_ADDR_EXP 19
10725: PUSH
10726: LD_EXP 19
10730: PUSH
10731: LD_VAR 0 1
10735: DIFF
10736: ST_TO_ADDR
// end ;
10737: PPOPN 1
10739: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10740: LD_VAR 0 1
10744: PPUSH
10745: LD_VAR 0 2
10749: PPUSH
10750: CALL 81069 0 2
// end ;
10754: PPOPN 2
10756: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10757: LD_VAR 0 1
10761: PPUSH
10762: CALL 80137 0 1
// end ;
10766: PPOPN 1
10768: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
10769: LD_VAR 0 1
10773: PPUSH
10774: CALL 80378 0 1
// end ;
10778: PPOPN 1
10780: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10781: LD_VAR 0 1
10785: PPUSH
10786: LD_VAR 0 2
10790: PPUSH
10791: CALL 78431 0 2
// end ;
10795: PPOPN 2
10797: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10798: LD_VAR 0 1
10802: PPUSH
10803: LD_VAR 0 2
10807: PPUSH
10808: LD_VAR 0 3
10812: PPUSH
10813: LD_VAR 0 4
10817: PPUSH
10818: LD_VAR 0 5
10822: PPUSH
10823: CALL 78051 0 5
// end ;
10827: PPOPN 5
10829: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
10830: LD_VAR 0 1
10834: PPUSH
10835: LD_VAR 0 2
10839: PPUSH
10840: CALL 77632 0 2
// end ;
10844: PPOPN 2
10846: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10847: LD_VAR 0 1
10851: PPUSH
10852: LD_VAR 0 2
10856: PPUSH
10857: LD_VAR 0 3
10861: PPUSH
10862: LD_VAR 0 4
10866: PPUSH
10867: CALL 77470 0 4
// end ;
10871: PPOPN 4
10873: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10874: LD_VAR 0 1
10878: PPUSH
10879: LD_VAR 0 2
10883: PPUSH
10884: LD_VAR 0 3
10888: PPUSH
10889: CALL 77245 0 3
// end ;
10893: PPOPN 3
10895: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10896: LD_VAR 0 1
10900: PPUSH
10901: LD_VAR 0 2
10905: PPUSH
10906: CALL 77130 0 2
// end ;
10910: PPOPN 2
10912: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10913: LD_VAR 0 1
10917: PPUSH
10918: LD_VAR 0 2
10922: PPUSH
10923: CALL 81364 0 2
// end ;
10927: PPOPN 2
10929: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10930: LD_VAR 0 1
10934: PPUSH
10935: LD_VAR 0 2
10939: PPUSH
10940: LD_VAR 0 3
10944: PPUSH
10945: LD_VAR 0 4
10949: PPUSH
10950: CALL 81580 0 4
// end ;
10954: PPOPN 4
10956: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10957: LD_VAR 0 1
10961: PPUSH
10962: LD_VAR 0 2
10966: PPUSH
10967: CALL 76939 0 2
// end ;
10971: PPOPN 2
10973: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 then
10974: LD_VAR 0 1
10978: PUSH
10979: LD_INT 1
10981: EQUAL
10982: PUSH
10983: LD_VAR 0 2
10987: PUSH
10988: LD_INT 4
10990: EQUAL
10991: AND
10992: IFFALSE 11001
// YouLost ( FriendlyFire ) ;
10994: LD_STRING FriendlyFire
10996: PPUSH
10997: CALL_OW 104
// end ; end_of_file
11001: PPOPN 2
11003: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
11004: LD_INT 0
11006: PPUSH
11007: PPUSH
// if exist_mode then
11008: LD_VAR 0 2
11012: IFFALSE 11037
// unit := CreateCharacter ( prefix & ident ) else
11014: LD_ADDR_VAR 0 5
11018: PUSH
11019: LD_VAR 0 3
11023: PUSH
11024: LD_VAR 0 1
11028: STR
11029: PPUSH
11030: CALL_OW 34
11034: ST_TO_ADDR
11035: GO 11052
// unit := NewCharacter ( ident ) ;
11037: LD_ADDR_VAR 0 5
11041: PUSH
11042: LD_VAR 0 1
11046: PPUSH
11047: CALL_OW 25
11051: ST_TO_ADDR
// result := unit ;
11052: LD_ADDR_VAR 0 4
11056: PUSH
11057: LD_VAR 0 5
11061: ST_TO_ADDR
// end ;
11062: LD_VAR 0 4
11066: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
11067: LD_INT 0
11069: PPUSH
11070: PPUSH
// if not side or not nation then
11071: LD_VAR 0 1
11075: NOT
11076: PUSH
11077: LD_VAR 0 2
11081: NOT
11082: OR
11083: IFFALSE 11087
// exit ;
11085: GO 11855
// case nation of nation_american :
11087: LD_VAR 0 2
11091: PUSH
11092: LD_INT 1
11094: DOUBLE
11095: EQUAL
11096: IFTRUE 11100
11098: GO 11314
11100: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
11101: LD_ADDR_VAR 0 4
11105: PUSH
11106: LD_INT 35
11108: PUSH
11109: LD_INT 45
11111: PUSH
11112: LD_INT 46
11114: PUSH
11115: LD_INT 47
11117: PUSH
11118: LD_INT 82
11120: PUSH
11121: LD_INT 83
11123: PUSH
11124: LD_INT 84
11126: PUSH
11127: LD_INT 85
11129: PUSH
11130: LD_INT 86
11132: PUSH
11133: LD_INT 1
11135: PUSH
11136: LD_INT 2
11138: PUSH
11139: LD_INT 6
11141: PUSH
11142: LD_INT 15
11144: PUSH
11145: LD_INT 16
11147: PUSH
11148: LD_INT 7
11150: PUSH
11151: LD_INT 12
11153: PUSH
11154: LD_INT 13
11156: PUSH
11157: LD_INT 10
11159: PUSH
11160: LD_INT 14
11162: PUSH
11163: LD_INT 20
11165: PUSH
11166: LD_INT 21
11168: PUSH
11169: LD_INT 22
11171: PUSH
11172: LD_INT 25
11174: PUSH
11175: LD_INT 32
11177: PUSH
11178: LD_INT 27
11180: PUSH
11181: LD_INT 36
11183: PUSH
11184: LD_INT 69
11186: PUSH
11187: LD_INT 39
11189: PUSH
11190: LD_INT 34
11192: PUSH
11193: LD_INT 40
11195: PUSH
11196: LD_INT 48
11198: PUSH
11199: LD_INT 49
11201: PUSH
11202: LD_INT 50
11204: PUSH
11205: LD_INT 51
11207: PUSH
11208: LD_INT 52
11210: PUSH
11211: LD_INT 53
11213: PUSH
11214: LD_INT 54
11216: PUSH
11217: LD_INT 55
11219: PUSH
11220: LD_INT 56
11222: PUSH
11223: LD_INT 57
11225: PUSH
11226: LD_INT 58
11228: PUSH
11229: LD_INT 59
11231: PUSH
11232: LD_INT 60
11234: PUSH
11235: LD_INT 61
11237: PUSH
11238: LD_INT 62
11240: PUSH
11241: LD_INT 80
11243: PUSH
11244: LD_INT 82
11246: PUSH
11247: LD_INT 83
11249: PUSH
11250: LD_INT 84
11252: PUSH
11253: LD_INT 85
11255: PUSH
11256: LD_INT 86
11258: PUSH
11259: EMPTY
11260: LIST
11261: LIST
11262: LIST
11263: LIST
11264: LIST
11265: LIST
11266: LIST
11267: LIST
11268: LIST
11269: LIST
11270: LIST
11271: LIST
11272: LIST
11273: LIST
11274: LIST
11275: LIST
11276: LIST
11277: LIST
11278: LIST
11279: LIST
11280: LIST
11281: LIST
11282: LIST
11283: LIST
11284: LIST
11285: LIST
11286: LIST
11287: LIST
11288: LIST
11289: LIST
11290: LIST
11291: LIST
11292: LIST
11293: LIST
11294: LIST
11295: LIST
11296: LIST
11297: LIST
11298: LIST
11299: LIST
11300: LIST
11301: LIST
11302: LIST
11303: LIST
11304: LIST
11305: LIST
11306: LIST
11307: LIST
11308: LIST
11309: LIST
11310: LIST
11311: ST_TO_ADDR
11312: GO 11779
11314: LD_INT 2
11316: DOUBLE
11317: EQUAL
11318: IFTRUE 11322
11320: GO 11548
11322: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
11323: LD_ADDR_VAR 0 4
11327: PUSH
11328: LD_INT 35
11330: PUSH
11331: LD_INT 45
11333: PUSH
11334: LD_INT 46
11336: PUSH
11337: LD_INT 47
11339: PUSH
11340: LD_INT 82
11342: PUSH
11343: LD_INT 83
11345: PUSH
11346: LD_INT 84
11348: PUSH
11349: LD_INT 85
11351: PUSH
11352: LD_INT 87
11354: PUSH
11355: LD_INT 70
11357: PUSH
11358: LD_INT 1
11360: PUSH
11361: LD_INT 11
11363: PUSH
11364: LD_INT 3
11366: PUSH
11367: LD_INT 4
11369: PUSH
11370: LD_INT 5
11372: PUSH
11373: LD_INT 6
11375: PUSH
11376: LD_INT 15
11378: PUSH
11379: LD_INT 18
11381: PUSH
11382: LD_INT 7
11384: PUSH
11385: LD_INT 17
11387: PUSH
11388: LD_INT 8
11390: PUSH
11391: LD_INT 20
11393: PUSH
11394: LD_INT 21
11396: PUSH
11397: LD_INT 22
11399: PUSH
11400: LD_INT 72
11402: PUSH
11403: LD_INT 26
11405: PUSH
11406: LD_INT 69
11408: PUSH
11409: LD_INT 39
11411: PUSH
11412: LD_INT 40
11414: PUSH
11415: LD_INT 41
11417: PUSH
11418: LD_INT 42
11420: PUSH
11421: LD_INT 43
11423: PUSH
11424: LD_INT 48
11426: PUSH
11427: LD_INT 49
11429: PUSH
11430: LD_INT 50
11432: PUSH
11433: LD_INT 51
11435: PUSH
11436: LD_INT 52
11438: PUSH
11439: LD_INT 53
11441: PUSH
11442: LD_INT 54
11444: PUSH
11445: LD_INT 55
11447: PUSH
11448: LD_INT 56
11450: PUSH
11451: LD_INT 60
11453: PUSH
11454: LD_INT 61
11456: PUSH
11457: LD_INT 62
11459: PUSH
11460: LD_INT 66
11462: PUSH
11463: LD_INT 67
11465: PUSH
11466: LD_INT 68
11468: PUSH
11469: LD_INT 81
11471: PUSH
11472: LD_INT 82
11474: PUSH
11475: LD_INT 83
11477: PUSH
11478: LD_INT 84
11480: PUSH
11481: LD_INT 85
11483: PUSH
11484: LD_INT 87
11486: PUSH
11487: LD_INT 88
11489: PUSH
11490: EMPTY
11491: LIST
11492: LIST
11493: LIST
11494: LIST
11495: LIST
11496: LIST
11497: LIST
11498: LIST
11499: LIST
11500: LIST
11501: LIST
11502: LIST
11503: LIST
11504: LIST
11505: LIST
11506: LIST
11507: LIST
11508: LIST
11509: LIST
11510: LIST
11511: LIST
11512: LIST
11513: LIST
11514: LIST
11515: LIST
11516: LIST
11517: LIST
11518: LIST
11519: LIST
11520: LIST
11521: LIST
11522: LIST
11523: LIST
11524: LIST
11525: LIST
11526: LIST
11527: LIST
11528: LIST
11529: LIST
11530: LIST
11531: LIST
11532: LIST
11533: LIST
11534: LIST
11535: LIST
11536: LIST
11537: LIST
11538: LIST
11539: LIST
11540: LIST
11541: LIST
11542: LIST
11543: LIST
11544: LIST
11545: ST_TO_ADDR
11546: GO 11779
11548: LD_INT 3
11550: DOUBLE
11551: EQUAL
11552: IFTRUE 11556
11554: GO 11778
11556: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
11557: LD_ADDR_VAR 0 4
11561: PUSH
11562: LD_INT 46
11564: PUSH
11565: LD_INT 47
11567: PUSH
11568: LD_INT 1
11570: PUSH
11571: LD_INT 2
11573: PUSH
11574: LD_INT 82
11576: PUSH
11577: LD_INT 83
11579: PUSH
11580: LD_INT 84
11582: PUSH
11583: LD_INT 85
11585: PUSH
11586: LD_INT 86
11588: PUSH
11589: LD_INT 11
11591: PUSH
11592: LD_INT 9
11594: PUSH
11595: LD_INT 20
11597: PUSH
11598: LD_INT 19
11600: PUSH
11601: LD_INT 21
11603: PUSH
11604: LD_INT 24
11606: PUSH
11607: LD_INT 22
11609: PUSH
11610: LD_INT 25
11612: PUSH
11613: LD_INT 28
11615: PUSH
11616: LD_INT 29
11618: PUSH
11619: LD_INT 30
11621: PUSH
11622: LD_INT 31
11624: PUSH
11625: LD_INT 37
11627: PUSH
11628: LD_INT 38
11630: PUSH
11631: LD_INT 32
11633: PUSH
11634: LD_INT 27
11636: PUSH
11637: LD_INT 33
11639: PUSH
11640: LD_INT 69
11642: PUSH
11643: LD_INT 39
11645: PUSH
11646: LD_INT 34
11648: PUSH
11649: LD_INT 40
11651: PUSH
11652: LD_INT 71
11654: PUSH
11655: LD_INT 23
11657: PUSH
11658: LD_INT 44
11660: PUSH
11661: LD_INT 48
11663: PUSH
11664: LD_INT 49
11666: PUSH
11667: LD_INT 50
11669: PUSH
11670: LD_INT 51
11672: PUSH
11673: LD_INT 52
11675: PUSH
11676: LD_INT 53
11678: PUSH
11679: LD_INT 54
11681: PUSH
11682: LD_INT 55
11684: PUSH
11685: LD_INT 56
11687: PUSH
11688: LD_INT 57
11690: PUSH
11691: LD_INT 58
11693: PUSH
11694: LD_INT 59
11696: PUSH
11697: LD_INT 63
11699: PUSH
11700: LD_INT 64
11702: PUSH
11703: LD_INT 65
11705: PUSH
11706: LD_INT 82
11708: PUSH
11709: LD_INT 83
11711: PUSH
11712: LD_INT 84
11714: PUSH
11715: LD_INT 85
11717: PUSH
11718: LD_INT 86
11720: PUSH
11721: EMPTY
11722: LIST
11723: LIST
11724: LIST
11725: LIST
11726: LIST
11727: LIST
11728: LIST
11729: LIST
11730: LIST
11731: LIST
11732: LIST
11733: LIST
11734: LIST
11735: LIST
11736: LIST
11737: LIST
11738: LIST
11739: LIST
11740: LIST
11741: LIST
11742: LIST
11743: LIST
11744: LIST
11745: LIST
11746: LIST
11747: LIST
11748: LIST
11749: LIST
11750: LIST
11751: LIST
11752: LIST
11753: LIST
11754: LIST
11755: LIST
11756: LIST
11757: LIST
11758: LIST
11759: LIST
11760: LIST
11761: LIST
11762: LIST
11763: LIST
11764: LIST
11765: LIST
11766: LIST
11767: LIST
11768: LIST
11769: LIST
11770: LIST
11771: LIST
11772: LIST
11773: LIST
11774: LIST
11775: ST_TO_ADDR
11776: GO 11779
11778: POP
// if state > - 1 and state < 3 then
11779: LD_VAR 0 3
11783: PUSH
11784: LD_INT 1
11786: NEG
11787: GREATER
11788: PUSH
11789: LD_VAR 0 3
11793: PUSH
11794: LD_INT 3
11796: LESS
11797: AND
11798: IFFALSE 11855
// for i in result do
11800: LD_ADDR_VAR 0 5
11804: PUSH
11805: LD_VAR 0 4
11809: PUSH
11810: FOR_IN
11811: IFFALSE 11853
// if GetTech ( i , side ) <> state then
11813: LD_VAR 0 5
11817: PPUSH
11818: LD_VAR 0 1
11822: PPUSH
11823: CALL_OW 321
11827: PUSH
11828: LD_VAR 0 3
11832: NONEQUAL
11833: IFFALSE 11851
// result := result diff i ;
11835: LD_ADDR_VAR 0 4
11839: PUSH
11840: LD_VAR 0 4
11844: PUSH
11845: LD_VAR 0 5
11849: DIFF
11850: ST_TO_ADDR
11851: GO 11810
11853: POP
11854: POP
// end ;
11855: LD_VAR 0 4
11859: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
11860: LD_INT 0
11862: PPUSH
11863: PPUSH
11864: PPUSH
// result := true ;
11865: LD_ADDR_VAR 0 3
11869: PUSH
11870: LD_INT 1
11872: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
11873: LD_ADDR_VAR 0 5
11877: PUSH
11878: LD_VAR 0 2
11882: PPUSH
11883: CALL_OW 480
11887: ST_TO_ADDR
// if not tmp then
11888: LD_VAR 0 5
11892: NOT
11893: IFFALSE 11897
// exit ;
11895: GO 11946
// for i in tmp do
11897: LD_ADDR_VAR 0 4
11901: PUSH
11902: LD_VAR 0 5
11906: PUSH
11907: FOR_IN
11908: IFFALSE 11944
// if GetTech ( i , side ) <> state_researched then
11910: LD_VAR 0 4
11914: PPUSH
11915: LD_VAR 0 1
11919: PPUSH
11920: CALL_OW 321
11924: PUSH
11925: LD_INT 2
11927: NONEQUAL
11928: IFFALSE 11942
// begin result := false ;
11930: LD_ADDR_VAR 0 3
11934: PUSH
11935: LD_INT 0
11937: ST_TO_ADDR
// exit ;
11938: POP
11939: POP
11940: GO 11946
// end ;
11942: GO 11907
11944: POP
11945: POP
// end ;
11946: LD_VAR 0 3
11950: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
11951: LD_INT 0
11953: PPUSH
11954: PPUSH
11955: PPUSH
11956: PPUSH
11957: PPUSH
11958: PPUSH
11959: PPUSH
11960: PPUSH
11961: PPUSH
11962: PPUSH
11963: PPUSH
11964: PPUSH
11965: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
11966: LD_VAR 0 1
11970: NOT
11971: PUSH
11972: LD_VAR 0 1
11976: PPUSH
11977: CALL_OW 257
11981: PUSH
11982: LD_INT 9
11984: NONEQUAL
11985: OR
11986: IFFALSE 11990
// exit ;
11988: GO 12563
// side := GetSide ( unit ) ;
11990: LD_ADDR_VAR 0 9
11994: PUSH
11995: LD_VAR 0 1
11999: PPUSH
12000: CALL_OW 255
12004: ST_TO_ADDR
// tech_space := tech_spacanom ;
12005: LD_ADDR_VAR 0 12
12009: PUSH
12010: LD_INT 29
12012: ST_TO_ADDR
// tech_time := tech_taurad ;
12013: LD_ADDR_VAR 0 13
12017: PUSH
12018: LD_INT 28
12020: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
12021: LD_ADDR_VAR 0 11
12025: PUSH
12026: LD_VAR 0 1
12030: PPUSH
12031: CALL_OW 310
12035: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
12036: LD_VAR 0 11
12040: PPUSH
12041: CALL_OW 247
12045: PUSH
12046: LD_INT 2
12048: EQUAL
12049: IFFALSE 12053
// exit ;
12051: GO 12563
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
12053: LD_ADDR_VAR 0 8
12057: PUSH
12058: LD_INT 81
12060: PUSH
12061: LD_VAR 0 9
12065: PUSH
12066: EMPTY
12067: LIST
12068: LIST
12069: PUSH
12070: LD_INT 3
12072: PUSH
12073: LD_INT 21
12075: PUSH
12076: LD_INT 3
12078: PUSH
12079: EMPTY
12080: LIST
12081: LIST
12082: PUSH
12083: EMPTY
12084: LIST
12085: LIST
12086: PUSH
12087: EMPTY
12088: LIST
12089: LIST
12090: PPUSH
12091: CALL_OW 69
12095: ST_TO_ADDR
// if not tmp then
12096: LD_VAR 0 8
12100: NOT
12101: IFFALSE 12105
// exit ;
12103: GO 12563
// if in_unit then
12105: LD_VAR 0 11
12109: IFFALSE 12133
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
12111: LD_ADDR_VAR 0 10
12115: PUSH
12116: LD_VAR 0 8
12120: PPUSH
12121: LD_VAR 0 11
12125: PPUSH
12126: CALL_OW 74
12130: ST_TO_ADDR
12131: GO 12153
// enemy := NearestUnitToUnit ( tmp , unit ) ;
12133: LD_ADDR_VAR 0 10
12137: PUSH
12138: LD_VAR 0 8
12142: PPUSH
12143: LD_VAR 0 1
12147: PPUSH
12148: CALL_OW 74
12152: ST_TO_ADDR
// if not enemy then
12153: LD_VAR 0 10
12157: NOT
12158: IFFALSE 12162
// exit ;
12160: GO 12563
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
12162: LD_VAR 0 11
12166: PUSH
12167: LD_VAR 0 11
12171: PPUSH
12172: LD_VAR 0 10
12176: PPUSH
12177: CALL_OW 296
12181: PUSH
12182: LD_INT 13
12184: GREATER
12185: AND
12186: PUSH
12187: LD_VAR 0 1
12191: PPUSH
12192: LD_VAR 0 10
12196: PPUSH
12197: CALL_OW 296
12201: PUSH
12202: LD_INT 12
12204: GREATER
12205: OR
12206: IFFALSE 12210
// exit ;
12208: GO 12563
// missile := [ 1 ] ;
12210: LD_ADDR_VAR 0 14
12214: PUSH
12215: LD_INT 1
12217: PUSH
12218: EMPTY
12219: LIST
12220: ST_TO_ADDR
// if Researched ( side , tech_space ) then
12221: LD_VAR 0 9
12225: PPUSH
12226: LD_VAR 0 12
12230: PPUSH
12231: CALL_OW 325
12235: IFFALSE 12264
// missile := Insert ( missile , missile + 1 , 2 ) ;
12237: LD_ADDR_VAR 0 14
12241: PUSH
12242: LD_VAR 0 14
12246: PPUSH
12247: LD_VAR 0 14
12251: PUSH
12252: LD_INT 1
12254: PLUS
12255: PPUSH
12256: LD_INT 2
12258: PPUSH
12259: CALL_OW 2
12263: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
12264: LD_VAR 0 9
12268: PPUSH
12269: LD_VAR 0 13
12273: PPUSH
12274: CALL_OW 325
12278: PUSH
12279: LD_VAR 0 10
12283: PPUSH
12284: CALL_OW 255
12288: PPUSH
12289: LD_VAR 0 13
12293: PPUSH
12294: CALL_OW 325
12298: NOT
12299: AND
12300: IFFALSE 12329
// missile := Insert ( missile , missile + 1 , 3 ) ;
12302: LD_ADDR_VAR 0 14
12306: PUSH
12307: LD_VAR 0 14
12311: PPUSH
12312: LD_VAR 0 14
12316: PUSH
12317: LD_INT 1
12319: PLUS
12320: PPUSH
12321: LD_INT 3
12323: PPUSH
12324: CALL_OW 2
12328: ST_TO_ADDR
// if missile < 2 then
12329: LD_VAR 0 14
12333: PUSH
12334: LD_INT 2
12336: LESS
12337: IFFALSE 12341
// exit ;
12339: GO 12563
// x := GetX ( enemy ) ;
12341: LD_ADDR_VAR 0 4
12345: PUSH
12346: LD_VAR 0 10
12350: PPUSH
12351: CALL_OW 250
12355: ST_TO_ADDR
// y := GetY ( enemy ) ;
12356: LD_ADDR_VAR 0 5
12360: PUSH
12361: LD_VAR 0 10
12365: PPUSH
12366: CALL_OW 251
12370: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
12371: LD_ADDR_VAR 0 6
12375: PUSH
12376: LD_VAR 0 4
12380: PUSH
12381: LD_INT 1
12383: NEG
12384: PPUSH
12385: LD_INT 1
12387: PPUSH
12388: CALL_OW 12
12392: PLUS
12393: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
12394: LD_ADDR_VAR 0 7
12398: PUSH
12399: LD_VAR 0 5
12403: PUSH
12404: LD_INT 1
12406: NEG
12407: PPUSH
12408: LD_INT 1
12410: PPUSH
12411: CALL_OW 12
12415: PLUS
12416: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
12417: LD_VAR 0 6
12421: PPUSH
12422: LD_VAR 0 7
12426: PPUSH
12427: CALL_OW 488
12431: NOT
12432: IFFALSE 12454
// begin _x := x ;
12434: LD_ADDR_VAR 0 6
12438: PUSH
12439: LD_VAR 0 4
12443: ST_TO_ADDR
// _y := y ;
12444: LD_ADDR_VAR 0 7
12448: PUSH
12449: LD_VAR 0 5
12453: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
12454: LD_ADDR_VAR 0 3
12458: PUSH
12459: LD_INT 1
12461: PPUSH
12462: LD_VAR 0 14
12466: PPUSH
12467: CALL_OW 12
12471: ST_TO_ADDR
// case i of 1 :
12472: LD_VAR 0 3
12476: PUSH
12477: LD_INT 1
12479: DOUBLE
12480: EQUAL
12481: IFTRUE 12485
12483: GO 12502
12485: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
12486: LD_VAR 0 1
12490: PPUSH
12491: LD_VAR 0 10
12495: PPUSH
12496: CALL_OW 115
12500: GO 12563
12502: LD_INT 2
12504: DOUBLE
12505: EQUAL
12506: IFTRUE 12510
12508: GO 12532
12510: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
12511: LD_VAR 0 1
12515: PPUSH
12516: LD_VAR 0 6
12520: PPUSH
12521: LD_VAR 0 7
12525: PPUSH
12526: CALL_OW 153
12530: GO 12563
12532: LD_INT 3
12534: DOUBLE
12535: EQUAL
12536: IFTRUE 12540
12538: GO 12562
12540: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
12541: LD_VAR 0 1
12545: PPUSH
12546: LD_VAR 0 6
12550: PPUSH
12551: LD_VAR 0 7
12555: PPUSH
12556: CALL_OW 154
12560: GO 12563
12562: POP
// end ;
12563: LD_VAR 0 2
12567: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
12568: LD_INT 0
12570: PPUSH
12571: PPUSH
12572: PPUSH
12573: PPUSH
12574: PPUSH
12575: PPUSH
// if not unit or not building then
12576: LD_VAR 0 1
12580: NOT
12581: PUSH
12582: LD_VAR 0 2
12586: NOT
12587: OR
12588: IFFALSE 12592
// exit ;
12590: GO 12750
// x := GetX ( building ) ;
12592: LD_ADDR_VAR 0 5
12596: PUSH
12597: LD_VAR 0 2
12601: PPUSH
12602: CALL_OW 250
12606: ST_TO_ADDR
// y := GetY ( building ) ;
12607: LD_ADDR_VAR 0 6
12611: PUSH
12612: LD_VAR 0 2
12616: PPUSH
12617: CALL_OW 251
12621: ST_TO_ADDR
// for i = 0 to 5 do
12622: LD_ADDR_VAR 0 4
12626: PUSH
12627: DOUBLE
12628: LD_INT 0
12630: DEC
12631: ST_TO_ADDR
12632: LD_INT 5
12634: PUSH
12635: FOR_TO
12636: IFFALSE 12748
// begin _x := ShiftX ( x , i , 3 ) ;
12638: LD_ADDR_VAR 0 7
12642: PUSH
12643: LD_VAR 0 5
12647: PPUSH
12648: LD_VAR 0 4
12652: PPUSH
12653: LD_INT 3
12655: PPUSH
12656: CALL_OW 272
12660: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
12661: LD_ADDR_VAR 0 8
12665: PUSH
12666: LD_VAR 0 6
12670: PPUSH
12671: LD_VAR 0 4
12675: PPUSH
12676: LD_INT 3
12678: PPUSH
12679: CALL_OW 273
12683: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
12684: LD_VAR 0 7
12688: PPUSH
12689: LD_VAR 0 8
12693: PPUSH
12694: CALL_OW 488
12698: NOT
12699: IFFALSE 12703
// continue ;
12701: GO 12635
// if HexInfo ( _x , _y ) = 0 then
12703: LD_VAR 0 7
12707: PPUSH
12708: LD_VAR 0 8
12712: PPUSH
12713: CALL_OW 428
12717: PUSH
12718: LD_INT 0
12720: EQUAL
12721: IFFALSE 12746
// begin ComMoveXY ( unit , _x , _y ) ;
12723: LD_VAR 0 1
12727: PPUSH
12728: LD_VAR 0 7
12732: PPUSH
12733: LD_VAR 0 8
12737: PPUSH
12738: CALL_OW 111
// exit ;
12742: POP
12743: POP
12744: GO 12750
// end ; end ;
12746: GO 12635
12748: POP
12749: POP
// end ;
12750: LD_VAR 0 3
12754: RET
// export function ScanBase ( side , base_area ) ; begin
12755: LD_INT 0
12757: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
12758: LD_ADDR_VAR 0 3
12762: PUSH
12763: LD_VAR 0 2
12767: PPUSH
12768: LD_INT 81
12770: PUSH
12771: LD_VAR 0 1
12775: PUSH
12776: EMPTY
12777: LIST
12778: LIST
12779: PPUSH
12780: CALL_OW 70
12784: ST_TO_ADDR
// end ;
12785: LD_VAR 0 3
12789: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
12790: LD_INT 0
12792: PPUSH
12793: PPUSH
12794: PPUSH
12795: PPUSH
// result := false ;
12796: LD_ADDR_VAR 0 2
12800: PUSH
12801: LD_INT 0
12803: ST_TO_ADDR
// side := GetSide ( unit ) ;
12804: LD_ADDR_VAR 0 3
12808: PUSH
12809: LD_VAR 0 1
12813: PPUSH
12814: CALL_OW 255
12818: ST_TO_ADDR
// nat := GetNation ( unit ) ;
12819: LD_ADDR_VAR 0 4
12823: PUSH
12824: LD_VAR 0 1
12828: PPUSH
12829: CALL_OW 248
12833: ST_TO_ADDR
// case nat of 1 :
12834: LD_VAR 0 4
12838: PUSH
12839: LD_INT 1
12841: DOUBLE
12842: EQUAL
12843: IFTRUE 12847
12845: GO 12858
12847: POP
// tech := tech_lassight ; 2 :
12848: LD_ADDR_VAR 0 5
12852: PUSH
12853: LD_INT 12
12855: ST_TO_ADDR
12856: GO 12897
12858: LD_INT 2
12860: DOUBLE
12861: EQUAL
12862: IFTRUE 12866
12864: GO 12877
12866: POP
// tech := tech_mortar ; 3 :
12867: LD_ADDR_VAR 0 5
12871: PUSH
12872: LD_INT 41
12874: ST_TO_ADDR
12875: GO 12897
12877: LD_INT 3
12879: DOUBLE
12880: EQUAL
12881: IFTRUE 12885
12883: GO 12896
12885: POP
// tech := tech_bazooka ; end ;
12886: LD_ADDR_VAR 0 5
12890: PUSH
12891: LD_INT 44
12893: ST_TO_ADDR
12894: GO 12897
12896: POP
// if Researched ( side , tech ) then
12897: LD_VAR 0 3
12901: PPUSH
12902: LD_VAR 0 5
12906: PPUSH
12907: CALL_OW 325
12911: IFFALSE 12938
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
12913: LD_ADDR_VAR 0 2
12917: PUSH
12918: LD_INT 5
12920: PUSH
12921: LD_INT 8
12923: PUSH
12924: LD_INT 9
12926: PUSH
12927: EMPTY
12928: LIST
12929: LIST
12930: LIST
12931: PUSH
12932: LD_VAR 0 4
12936: ARRAY
12937: ST_TO_ADDR
// end ;
12938: LD_VAR 0 2
12942: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
12943: LD_INT 0
12945: PPUSH
12946: PPUSH
12947: PPUSH
// if not mines then
12948: LD_VAR 0 2
12952: NOT
12953: IFFALSE 12957
// exit ;
12955: GO 13101
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
12957: LD_ADDR_VAR 0 5
12961: PUSH
12962: LD_INT 81
12964: PUSH
12965: LD_VAR 0 1
12969: PUSH
12970: EMPTY
12971: LIST
12972: LIST
12973: PUSH
12974: LD_INT 3
12976: PUSH
12977: LD_INT 21
12979: PUSH
12980: LD_INT 3
12982: PUSH
12983: EMPTY
12984: LIST
12985: LIST
12986: PUSH
12987: EMPTY
12988: LIST
12989: LIST
12990: PUSH
12991: EMPTY
12992: LIST
12993: LIST
12994: PPUSH
12995: CALL_OW 69
12999: ST_TO_ADDR
// for i in mines do
13000: LD_ADDR_VAR 0 4
13004: PUSH
13005: LD_VAR 0 2
13009: PUSH
13010: FOR_IN
13011: IFFALSE 13099
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
13013: LD_VAR 0 4
13017: PUSH
13018: LD_INT 1
13020: ARRAY
13021: PPUSH
13022: LD_VAR 0 4
13026: PUSH
13027: LD_INT 2
13029: ARRAY
13030: PPUSH
13031: CALL_OW 458
13035: NOT
13036: IFFALSE 13040
// continue ;
13038: GO 13010
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
13040: LD_VAR 0 4
13044: PUSH
13045: LD_INT 1
13047: ARRAY
13048: PPUSH
13049: LD_VAR 0 4
13053: PUSH
13054: LD_INT 2
13056: ARRAY
13057: PPUSH
13058: CALL_OW 428
13062: PUSH
13063: LD_VAR 0 5
13067: IN
13068: IFFALSE 13097
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
13070: LD_VAR 0 4
13074: PUSH
13075: LD_INT 1
13077: ARRAY
13078: PPUSH
13079: LD_VAR 0 4
13083: PUSH
13084: LD_INT 2
13086: ARRAY
13087: PPUSH
13088: LD_VAR 0 1
13092: PPUSH
13093: CALL_OW 456
// end ;
13097: GO 13010
13099: POP
13100: POP
// end ;
13101: LD_VAR 0 3
13105: RET
// export function Count ( array ) ; var i ; begin
13106: LD_INT 0
13108: PPUSH
13109: PPUSH
// result := 0 ;
13110: LD_ADDR_VAR 0 2
13114: PUSH
13115: LD_INT 0
13117: ST_TO_ADDR
// for i in array do
13118: LD_ADDR_VAR 0 3
13122: PUSH
13123: LD_VAR 0 1
13127: PUSH
13128: FOR_IN
13129: IFFALSE 13153
// if i then
13131: LD_VAR 0 3
13135: IFFALSE 13151
// result := result + 1 ;
13137: LD_ADDR_VAR 0 2
13141: PUSH
13142: LD_VAR 0 2
13146: PUSH
13147: LD_INT 1
13149: PLUS
13150: ST_TO_ADDR
13151: GO 13128
13153: POP
13154: POP
// end ;
13155: LD_VAR 0 2
13159: RET
// export function IsEmpty ( building ) ; begin
13160: LD_INT 0
13162: PPUSH
// if not building then
13163: LD_VAR 0 1
13167: NOT
13168: IFFALSE 13172
// exit ;
13170: GO 13215
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
13172: LD_ADDR_VAR 0 2
13176: PUSH
13177: LD_VAR 0 1
13181: PUSH
13182: LD_INT 22
13184: PUSH
13185: LD_VAR 0 1
13189: PPUSH
13190: CALL_OW 255
13194: PUSH
13195: EMPTY
13196: LIST
13197: LIST
13198: PUSH
13199: LD_INT 58
13201: PUSH
13202: EMPTY
13203: LIST
13204: PUSH
13205: EMPTY
13206: LIST
13207: LIST
13208: PPUSH
13209: CALL_OW 69
13213: IN
13214: ST_TO_ADDR
// end ;
13215: LD_VAR 0 2
13219: RET
// export function IsNotFull ( building ) ; begin
13220: LD_INT 0
13222: PPUSH
// if not building then
13223: LD_VAR 0 1
13227: NOT
13228: IFFALSE 13232
// exit ;
13230: GO 13251
// result := UnitsInside ( building ) < 6 ;
13232: LD_ADDR_VAR 0 2
13236: PUSH
13237: LD_VAR 0 1
13241: PPUSH
13242: CALL_OW 313
13246: PUSH
13247: LD_INT 6
13249: LESS
13250: ST_TO_ADDR
// end ;
13251: LD_VAR 0 2
13255: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
13256: LD_INT 0
13258: PPUSH
13259: PPUSH
13260: PPUSH
13261: PPUSH
// tmp := [ ] ;
13262: LD_ADDR_VAR 0 3
13266: PUSH
13267: EMPTY
13268: ST_TO_ADDR
// list := [ ] ;
13269: LD_ADDR_VAR 0 5
13273: PUSH
13274: EMPTY
13275: ST_TO_ADDR
// for i = 16 to 25 do
13276: LD_ADDR_VAR 0 4
13280: PUSH
13281: DOUBLE
13282: LD_INT 16
13284: DEC
13285: ST_TO_ADDR
13286: LD_INT 25
13288: PUSH
13289: FOR_TO
13290: IFFALSE 13363
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
13292: LD_ADDR_VAR 0 3
13296: PUSH
13297: LD_VAR 0 3
13301: PUSH
13302: LD_INT 22
13304: PUSH
13305: LD_VAR 0 1
13309: PPUSH
13310: CALL_OW 255
13314: PUSH
13315: EMPTY
13316: LIST
13317: LIST
13318: PUSH
13319: LD_INT 91
13321: PUSH
13322: LD_VAR 0 1
13326: PUSH
13327: LD_INT 6
13329: PUSH
13330: EMPTY
13331: LIST
13332: LIST
13333: LIST
13334: PUSH
13335: LD_INT 30
13337: PUSH
13338: LD_VAR 0 4
13342: PUSH
13343: EMPTY
13344: LIST
13345: LIST
13346: PUSH
13347: EMPTY
13348: LIST
13349: LIST
13350: LIST
13351: PUSH
13352: EMPTY
13353: LIST
13354: PPUSH
13355: CALL_OW 69
13359: ADD
13360: ST_TO_ADDR
13361: GO 13289
13363: POP
13364: POP
// for i = 1 to tmp do
13365: LD_ADDR_VAR 0 4
13369: PUSH
13370: DOUBLE
13371: LD_INT 1
13373: DEC
13374: ST_TO_ADDR
13375: LD_VAR 0 3
13379: PUSH
13380: FOR_TO
13381: IFFALSE 13469
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
13383: LD_ADDR_VAR 0 5
13387: PUSH
13388: LD_VAR 0 5
13392: PUSH
13393: LD_VAR 0 3
13397: PUSH
13398: LD_VAR 0 4
13402: ARRAY
13403: PPUSH
13404: CALL_OW 266
13408: PUSH
13409: LD_VAR 0 3
13413: PUSH
13414: LD_VAR 0 4
13418: ARRAY
13419: PPUSH
13420: CALL_OW 250
13424: PUSH
13425: LD_VAR 0 3
13429: PUSH
13430: LD_VAR 0 4
13434: ARRAY
13435: PPUSH
13436: CALL_OW 251
13440: PUSH
13441: LD_VAR 0 3
13445: PUSH
13446: LD_VAR 0 4
13450: ARRAY
13451: PPUSH
13452: CALL_OW 254
13456: PUSH
13457: EMPTY
13458: LIST
13459: LIST
13460: LIST
13461: LIST
13462: PUSH
13463: EMPTY
13464: LIST
13465: ADD
13466: ST_TO_ADDR
13467: GO 13380
13469: POP
13470: POP
// result := list ;
13471: LD_ADDR_VAR 0 2
13475: PUSH
13476: LD_VAR 0 5
13480: ST_TO_ADDR
// end ;
13481: LD_VAR 0 2
13485: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
13486: LD_INT 0
13488: PPUSH
13489: PPUSH
13490: PPUSH
13491: PPUSH
13492: PPUSH
13493: PPUSH
13494: PPUSH
// if not factory then
13495: LD_VAR 0 1
13499: NOT
13500: IFFALSE 13504
// exit ;
13502: GO 14097
// if control = control_apeman then
13504: LD_VAR 0 4
13508: PUSH
13509: LD_INT 5
13511: EQUAL
13512: IFFALSE 13621
// begin tmp := UnitsInside ( factory ) ;
13514: LD_ADDR_VAR 0 8
13518: PUSH
13519: LD_VAR 0 1
13523: PPUSH
13524: CALL_OW 313
13528: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
13529: LD_VAR 0 8
13533: PPUSH
13534: LD_INT 25
13536: PUSH
13537: LD_INT 12
13539: PUSH
13540: EMPTY
13541: LIST
13542: LIST
13543: PPUSH
13544: CALL_OW 72
13548: NOT
13549: IFFALSE 13559
// control := control_manual ;
13551: LD_ADDR_VAR 0 4
13555: PUSH
13556: LD_INT 1
13558: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
13559: LD_ADDR_VAR 0 8
13563: PUSH
13564: LD_VAR 0 1
13568: PPUSH
13569: CALL 13256 0 1
13573: ST_TO_ADDR
// if tmp then
13574: LD_VAR 0 8
13578: IFFALSE 13621
// begin for i in tmp do
13580: LD_ADDR_VAR 0 7
13584: PUSH
13585: LD_VAR 0 8
13589: PUSH
13590: FOR_IN
13591: IFFALSE 13619
// if i [ 1 ] = b_ext_radio then
13593: LD_VAR 0 7
13597: PUSH
13598: LD_INT 1
13600: ARRAY
13601: PUSH
13602: LD_INT 22
13604: EQUAL
13605: IFFALSE 13617
// begin control := control_remote ;
13607: LD_ADDR_VAR 0 4
13611: PUSH
13612: LD_INT 2
13614: ST_TO_ADDR
// break ;
13615: GO 13619
// end ;
13617: GO 13590
13619: POP
13620: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
13621: LD_VAR 0 1
13625: PPUSH
13626: LD_VAR 0 2
13630: PPUSH
13631: LD_VAR 0 3
13635: PPUSH
13636: LD_VAR 0 4
13640: PPUSH
13641: LD_VAR 0 5
13645: PPUSH
13646: CALL_OW 448
13650: IFFALSE 13685
// begin result := [ chassis , engine , control , weapon ] ;
13652: LD_ADDR_VAR 0 6
13656: PUSH
13657: LD_VAR 0 2
13661: PUSH
13662: LD_VAR 0 3
13666: PUSH
13667: LD_VAR 0 4
13671: PUSH
13672: LD_VAR 0 5
13676: PUSH
13677: EMPTY
13678: LIST
13679: LIST
13680: LIST
13681: LIST
13682: ST_TO_ADDR
// exit ;
13683: GO 14097
// end ; _chassis := AvailableChassisList ( factory ) ;
13685: LD_ADDR_VAR 0 9
13689: PUSH
13690: LD_VAR 0 1
13694: PPUSH
13695: CALL_OW 475
13699: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
13700: LD_ADDR_VAR 0 11
13704: PUSH
13705: LD_VAR 0 1
13709: PPUSH
13710: CALL_OW 476
13714: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
13715: LD_ADDR_VAR 0 12
13719: PUSH
13720: LD_VAR 0 1
13724: PPUSH
13725: CALL_OW 477
13729: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
13730: LD_ADDR_VAR 0 10
13734: PUSH
13735: LD_VAR 0 1
13739: PPUSH
13740: CALL_OW 478
13744: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
13745: LD_VAR 0 9
13749: NOT
13750: PUSH
13751: LD_VAR 0 11
13755: NOT
13756: OR
13757: PUSH
13758: LD_VAR 0 12
13762: NOT
13763: OR
13764: PUSH
13765: LD_VAR 0 10
13769: NOT
13770: OR
13771: IFFALSE 13806
// begin result := [ chassis , engine , control , weapon ] ;
13773: LD_ADDR_VAR 0 6
13777: PUSH
13778: LD_VAR 0 2
13782: PUSH
13783: LD_VAR 0 3
13787: PUSH
13788: LD_VAR 0 4
13792: PUSH
13793: LD_VAR 0 5
13797: PUSH
13798: EMPTY
13799: LIST
13800: LIST
13801: LIST
13802: LIST
13803: ST_TO_ADDR
// exit ;
13804: GO 14097
// end ; if not chassis in _chassis then
13806: LD_VAR 0 2
13810: PUSH
13811: LD_VAR 0 9
13815: IN
13816: NOT
13817: IFFALSE 13843
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
13819: LD_ADDR_VAR 0 2
13823: PUSH
13824: LD_VAR 0 9
13828: PUSH
13829: LD_INT 1
13831: PPUSH
13832: LD_VAR 0 9
13836: PPUSH
13837: CALL_OW 12
13841: ARRAY
13842: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
13843: LD_VAR 0 2
13847: PPUSH
13848: LD_VAR 0 3
13852: PPUSH
13853: CALL 14102 0 2
13857: NOT
13858: IFFALSE 13917
// repeat engine := _engine [ 1 ] ;
13860: LD_ADDR_VAR 0 3
13864: PUSH
13865: LD_VAR 0 11
13869: PUSH
13870: LD_INT 1
13872: ARRAY
13873: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
13874: LD_ADDR_VAR 0 11
13878: PUSH
13879: LD_VAR 0 11
13883: PPUSH
13884: LD_INT 1
13886: PPUSH
13887: CALL_OW 3
13891: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
13892: LD_VAR 0 2
13896: PPUSH
13897: LD_VAR 0 3
13901: PPUSH
13902: CALL 14102 0 2
13906: PUSH
13907: LD_VAR 0 11
13911: PUSH
13912: EMPTY
13913: EQUAL
13914: OR
13915: IFFALSE 13860
// if not control in _control then
13917: LD_VAR 0 4
13921: PUSH
13922: LD_VAR 0 12
13926: IN
13927: NOT
13928: IFFALSE 13954
// control := _control [ rand ( 1 , _control ) ] ;
13930: LD_ADDR_VAR 0 4
13934: PUSH
13935: LD_VAR 0 12
13939: PUSH
13940: LD_INT 1
13942: PPUSH
13943: LD_VAR 0 12
13947: PPUSH
13948: CALL_OW 12
13952: ARRAY
13953: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
13954: LD_VAR 0 2
13958: PPUSH
13959: LD_VAR 0 5
13963: PPUSH
13964: CALL 14322 0 2
13968: NOT
13969: IFFALSE 14028
// repeat weapon := _weapon [ 1 ] ;
13971: LD_ADDR_VAR 0 5
13975: PUSH
13976: LD_VAR 0 10
13980: PUSH
13981: LD_INT 1
13983: ARRAY
13984: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
13985: LD_ADDR_VAR 0 10
13989: PUSH
13990: LD_VAR 0 10
13994: PPUSH
13995: LD_INT 1
13997: PPUSH
13998: CALL_OW 3
14002: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
14003: LD_VAR 0 2
14007: PPUSH
14008: LD_VAR 0 5
14012: PPUSH
14013: CALL 14322 0 2
14017: PUSH
14018: LD_VAR 0 10
14022: PUSH
14023: EMPTY
14024: EQUAL
14025: OR
14026: IFFALSE 13971
// result := [ ] ;
14028: LD_ADDR_VAR 0 6
14032: PUSH
14033: EMPTY
14034: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
14035: LD_VAR 0 1
14039: PPUSH
14040: LD_VAR 0 2
14044: PPUSH
14045: LD_VAR 0 3
14049: PPUSH
14050: LD_VAR 0 4
14054: PPUSH
14055: LD_VAR 0 5
14059: PPUSH
14060: CALL_OW 448
14064: IFFALSE 14097
// result := [ chassis , engine , control , weapon ] ;
14066: LD_ADDR_VAR 0 6
14070: PUSH
14071: LD_VAR 0 2
14075: PUSH
14076: LD_VAR 0 3
14080: PUSH
14081: LD_VAR 0 4
14085: PUSH
14086: LD_VAR 0 5
14090: PUSH
14091: EMPTY
14092: LIST
14093: LIST
14094: LIST
14095: LIST
14096: ST_TO_ADDR
// end ;
14097: LD_VAR 0 6
14101: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
14102: LD_INT 0
14104: PPUSH
// if not chassis or not engine then
14105: LD_VAR 0 1
14109: NOT
14110: PUSH
14111: LD_VAR 0 2
14115: NOT
14116: OR
14117: IFFALSE 14121
// exit ;
14119: GO 14317
// case engine of engine_solar :
14121: LD_VAR 0 2
14125: PUSH
14126: LD_INT 2
14128: DOUBLE
14129: EQUAL
14130: IFTRUE 14134
14132: GO 14172
14134: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
14135: LD_ADDR_VAR 0 3
14139: PUSH
14140: LD_INT 11
14142: PUSH
14143: LD_INT 12
14145: PUSH
14146: LD_INT 13
14148: PUSH
14149: LD_INT 14
14151: PUSH
14152: LD_INT 1
14154: PUSH
14155: LD_INT 2
14157: PUSH
14158: LD_INT 3
14160: PUSH
14161: EMPTY
14162: LIST
14163: LIST
14164: LIST
14165: LIST
14166: LIST
14167: LIST
14168: LIST
14169: ST_TO_ADDR
14170: GO 14301
14172: LD_INT 1
14174: DOUBLE
14175: EQUAL
14176: IFTRUE 14180
14178: GO 14242
14180: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
14181: LD_ADDR_VAR 0 3
14185: PUSH
14186: LD_INT 11
14188: PUSH
14189: LD_INT 12
14191: PUSH
14192: LD_INT 13
14194: PUSH
14195: LD_INT 14
14197: PUSH
14198: LD_INT 1
14200: PUSH
14201: LD_INT 2
14203: PUSH
14204: LD_INT 3
14206: PUSH
14207: LD_INT 4
14209: PUSH
14210: LD_INT 5
14212: PUSH
14213: LD_INT 21
14215: PUSH
14216: LD_INT 23
14218: PUSH
14219: LD_INT 22
14221: PUSH
14222: LD_INT 24
14224: PUSH
14225: EMPTY
14226: LIST
14227: LIST
14228: LIST
14229: LIST
14230: LIST
14231: LIST
14232: LIST
14233: LIST
14234: LIST
14235: LIST
14236: LIST
14237: LIST
14238: LIST
14239: ST_TO_ADDR
14240: GO 14301
14242: LD_INT 3
14244: DOUBLE
14245: EQUAL
14246: IFTRUE 14250
14248: GO 14300
14250: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
14251: LD_ADDR_VAR 0 3
14255: PUSH
14256: LD_INT 13
14258: PUSH
14259: LD_INT 14
14261: PUSH
14262: LD_INT 2
14264: PUSH
14265: LD_INT 3
14267: PUSH
14268: LD_INT 4
14270: PUSH
14271: LD_INT 5
14273: PUSH
14274: LD_INT 21
14276: PUSH
14277: LD_INT 22
14279: PUSH
14280: LD_INT 23
14282: PUSH
14283: LD_INT 24
14285: PUSH
14286: EMPTY
14287: LIST
14288: LIST
14289: LIST
14290: LIST
14291: LIST
14292: LIST
14293: LIST
14294: LIST
14295: LIST
14296: LIST
14297: ST_TO_ADDR
14298: GO 14301
14300: POP
// result := ( chassis in result ) ;
14301: LD_ADDR_VAR 0 3
14305: PUSH
14306: LD_VAR 0 1
14310: PUSH
14311: LD_VAR 0 3
14315: IN
14316: ST_TO_ADDR
// end ;
14317: LD_VAR 0 3
14321: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
14322: LD_INT 0
14324: PPUSH
// if not chassis or not weapon then
14325: LD_VAR 0 1
14329: NOT
14330: PUSH
14331: LD_VAR 0 2
14335: NOT
14336: OR
14337: IFFALSE 14341
// exit ;
14339: GO 15403
// case weapon of us_machine_gun :
14341: LD_VAR 0 2
14345: PUSH
14346: LD_INT 2
14348: DOUBLE
14349: EQUAL
14350: IFTRUE 14354
14352: GO 14384
14354: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
14355: LD_ADDR_VAR 0 3
14359: PUSH
14360: LD_INT 1
14362: PUSH
14363: LD_INT 2
14365: PUSH
14366: LD_INT 3
14368: PUSH
14369: LD_INT 4
14371: PUSH
14372: LD_INT 5
14374: PUSH
14375: EMPTY
14376: LIST
14377: LIST
14378: LIST
14379: LIST
14380: LIST
14381: ST_TO_ADDR
14382: GO 15387
14384: LD_INT 3
14386: DOUBLE
14387: EQUAL
14388: IFTRUE 14392
14390: GO 14422
14392: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
14393: LD_ADDR_VAR 0 3
14397: PUSH
14398: LD_INT 1
14400: PUSH
14401: LD_INT 2
14403: PUSH
14404: LD_INT 3
14406: PUSH
14407: LD_INT 4
14409: PUSH
14410: LD_INT 5
14412: PUSH
14413: EMPTY
14414: LIST
14415: LIST
14416: LIST
14417: LIST
14418: LIST
14419: ST_TO_ADDR
14420: GO 15387
14422: LD_INT 11
14424: DOUBLE
14425: EQUAL
14426: IFTRUE 14430
14428: GO 14460
14430: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
14431: LD_ADDR_VAR 0 3
14435: PUSH
14436: LD_INT 1
14438: PUSH
14439: LD_INT 2
14441: PUSH
14442: LD_INT 3
14444: PUSH
14445: LD_INT 4
14447: PUSH
14448: LD_INT 5
14450: PUSH
14451: EMPTY
14452: LIST
14453: LIST
14454: LIST
14455: LIST
14456: LIST
14457: ST_TO_ADDR
14458: GO 15387
14460: LD_INT 4
14462: DOUBLE
14463: EQUAL
14464: IFTRUE 14468
14466: GO 14494
14468: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
14469: LD_ADDR_VAR 0 3
14473: PUSH
14474: LD_INT 2
14476: PUSH
14477: LD_INT 3
14479: PUSH
14480: LD_INT 4
14482: PUSH
14483: LD_INT 5
14485: PUSH
14486: EMPTY
14487: LIST
14488: LIST
14489: LIST
14490: LIST
14491: ST_TO_ADDR
14492: GO 15387
14494: LD_INT 5
14496: DOUBLE
14497: EQUAL
14498: IFTRUE 14502
14500: GO 14528
14502: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
14503: LD_ADDR_VAR 0 3
14507: PUSH
14508: LD_INT 2
14510: PUSH
14511: LD_INT 3
14513: PUSH
14514: LD_INT 4
14516: PUSH
14517: LD_INT 5
14519: PUSH
14520: EMPTY
14521: LIST
14522: LIST
14523: LIST
14524: LIST
14525: ST_TO_ADDR
14526: GO 15387
14528: LD_INT 9
14530: DOUBLE
14531: EQUAL
14532: IFTRUE 14536
14534: GO 14562
14536: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
14537: LD_ADDR_VAR 0 3
14541: PUSH
14542: LD_INT 2
14544: PUSH
14545: LD_INT 3
14547: PUSH
14548: LD_INT 4
14550: PUSH
14551: LD_INT 5
14553: PUSH
14554: EMPTY
14555: LIST
14556: LIST
14557: LIST
14558: LIST
14559: ST_TO_ADDR
14560: GO 15387
14562: LD_INT 7
14564: DOUBLE
14565: EQUAL
14566: IFTRUE 14570
14568: GO 14596
14570: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
14571: LD_ADDR_VAR 0 3
14575: PUSH
14576: LD_INT 2
14578: PUSH
14579: LD_INT 3
14581: PUSH
14582: LD_INT 4
14584: PUSH
14585: LD_INT 5
14587: PUSH
14588: EMPTY
14589: LIST
14590: LIST
14591: LIST
14592: LIST
14593: ST_TO_ADDR
14594: GO 15387
14596: LD_INT 12
14598: DOUBLE
14599: EQUAL
14600: IFTRUE 14604
14602: GO 14630
14604: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
14605: LD_ADDR_VAR 0 3
14609: PUSH
14610: LD_INT 2
14612: PUSH
14613: LD_INT 3
14615: PUSH
14616: LD_INT 4
14618: PUSH
14619: LD_INT 5
14621: PUSH
14622: EMPTY
14623: LIST
14624: LIST
14625: LIST
14626: LIST
14627: ST_TO_ADDR
14628: GO 15387
14630: LD_INT 13
14632: DOUBLE
14633: EQUAL
14634: IFTRUE 14638
14636: GO 14664
14638: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
14639: LD_ADDR_VAR 0 3
14643: PUSH
14644: LD_INT 2
14646: PUSH
14647: LD_INT 3
14649: PUSH
14650: LD_INT 4
14652: PUSH
14653: LD_INT 5
14655: PUSH
14656: EMPTY
14657: LIST
14658: LIST
14659: LIST
14660: LIST
14661: ST_TO_ADDR
14662: GO 15387
14664: LD_INT 14
14666: DOUBLE
14667: EQUAL
14668: IFTRUE 14672
14670: GO 14690
14672: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
14673: LD_ADDR_VAR 0 3
14677: PUSH
14678: LD_INT 4
14680: PUSH
14681: LD_INT 5
14683: PUSH
14684: EMPTY
14685: LIST
14686: LIST
14687: ST_TO_ADDR
14688: GO 15387
14690: LD_INT 6
14692: DOUBLE
14693: EQUAL
14694: IFTRUE 14698
14696: GO 14716
14698: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
14699: LD_ADDR_VAR 0 3
14703: PUSH
14704: LD_INT 4
14706: PUSH
14707: LD_INT 5
14709: PUSH
14710: EMPTY
14711: LIST
14712: LIST
14713: ST_TO_ADDR
14714: GO 15387
14716: LD_INT 10
14718: DOUBLE
14719: EQUAL
14720: IFTRUE 14724
14722: GO 14742
14724: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
14725: LD_ADDR_VAR 0 3
14729: PUSH
14730: LD_INT 4
14732: PUSH
14733: LD_INT 5
14735: PUSH
14736: EMPTY
14737: LIST
14738: LIST
14739: ST_TO_ADDR
14740: GO 15387
14742: LD_INT 22
14744: DOUBLE
14745: EQUAL
14746: IFTRUE 14750
14748: GO 14776
14750: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
14751: LD_ADDR_VAR 0 3
14755: PUSH
14756: LD_INT 11
14758: PUSH
14759: LD_INT 12
14761: PUSH
14762: LD_INT 13
14764: PUSH
14765: LD_INT 14
14767: PUSH
14768: EMPTY
14769: LIST
14770: LIST
14771: LIST
14772: LIST
14773: ST_TO_ADDR
14774: GO 15387
14776: LD_INT 23
14778: DOUBLE
14779: EQUAL
14780: IFTRUE 14784
14782: GO 14810
14784: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
14785: LD_ADDR_VAR 0 3
14789: PUSH
14790: LD_INT 11
14792: PUSH
14793: LD_INT 12
14795: PUSH
14796: LD_INT 13
14798: PUSH
14799: LD_INT 14
14801: PUSH
14802: EMPTY
14803: LIST
14804: LIST
14805: LIST
14806: LIST
14807: ST_TO_ADDR
14808: GO 15387
14810: LD_INT 24
14812: DOUBLE
14813: EQUAL
14814: IFTRUE 14818
14816: GO 14844
14818: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
14819: LD_ADDR_VAR 0 3
14823: PUSH
14824: LD_INT 11
14826: PUSH
14827: LD_INT 12
14829: PUSH
14830: LD_INT 13
14832: PUSH
14833: LD_INT 14
14835: PUSH
14836: EMPTY
14837: LIST
14838: LIST
14839: LIST
14840: LIST
14841: ST_TO_ADDR
14842: GO 15387
14844: LD_INT 30
14846: DOUBLE
14847: EQUAL
14848: IFTRUE 14852
14850: GO 14878
14852: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
14853: LD_ADDR_VAR 0 3
14857: PUSH
14858: LD_INT 11
14860: PUSH
14861: LD_INT 12
14863: PUSH
14864: LD_INT 13
14866: PUSH
14867: LD_INT 14
14869: PUSH
14870: EMPTY
14871: LIST
14872: LIST
14873: LIST
14874: LIST
14875: ST_TO_ADDR
14876: GO 15387
14878: LD_INT 25
14880: DOUBLE
14881: EQUAL
14882: IFTRUE 14886
14884: GO 14904
14886: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
14887: LD_ADDR_VAR 0 3
14891: PUSH
14892: LD_INT 13
14894: PUSH
14895: LD_INT 14
14897: PUSH
14898: EMPTY
14899: LIST
14900: LIST
14901: ST_TO_ADDR
14902: GO 15387
14904: LD_INT 27
14906: DOUBLE
14907: EQUAL
14908: IFTRUE 14912
14910: GO 14930
14912: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
14913: LD_ADDR_VAR 0 3
14917: PUSH
14918: LD_INT 13
14920: PUSH
14921: LD_INT 14
14923: PUSH
14924: EMPTY
14925: LIST
14926: LIST
14927: ST_TO_ADDR
14928: GO 15387
14930: LD_EXP 72
14934: DOUBLE
14935: EQUAL
14936: IFTRUE 14940
14938: GO 14966
14940: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
14941: LD_ADDR_VAR 0 3
14945: PUSH
14946: LD_INT 11
14948: PUSH
14949: LD_INT 12
14951: PUSH
14952: LD_INT 13
14954: PUSH
14955: LD_INT 14
14957: PUSH
14958: EMPTY
14959: LIST
14960: LIST
14961: LIST
14962: LIST
14963: ST_TO_ADDR
14964: GO 15387
14966: LD_INT 28
14968: DOUBLE
14969: EQUAL
14970: IFTRUE 14974
14972: GO 14992
14974: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
14975: LD_ADDR_VAR 0 3
14979: PUSH
14980: LD_INT 13
14982: PUSH
14983: LD_INT 14
14985: PUSH
14986: EMPTY
14987: LIST
14988: LIST
14989: ST_TO_ADDR
14990: GO 15387
14992: LD_INT 29
14994: DOUBLE
14995: EQUAL
14996: IFTRUE 15000
14998: GO 15018
15000: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
15001: LD_ADDR_VAR 0 3
15005: PUSH
15006: LD_INT 13
15008: PUSH
15009: LD_INT 14
15011: PUSH
15012: EMPTY
15013: LIST
15014: LIST
15015: ST_TO_ADDR
15016: GO 15387
15018: LD_INT 31
15020: DOUBLE
15021: EQUAL
15022: IFTRUE 15026
15024: GO 15044
15026: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
15027: LD_ADDR_VAR 0 3
15031: PUSH
15032: LD_INT 13
15034: PUSH
15035: LD_INT 14
15037: PUSH
15038: EMPTY
15039: LIST
15040: LIST
15041: ST_TO_ADDR
15042: GO 15387
15044: LD_INT 26
15046: DOUBLE
15047: EQUAL
15048: IFTRUE 15052
15050: GO 15070
15052: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
15053: LD_ADDR_VAR 0 3
15057: PUSH
15058: LD_INT 13
15060: PUSH
15061: LD_INT 14
15063: PUSH
15064: EMPTY
15065: LIST
15066: LIST
15067: ST_TO_ADDR
15068: GO 15387
15070: LD_INT 42
15072: DOUBLE
15073: EQUAL
15074: IFTRUE 15078
15076: GO 15104
15078: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
15079: LD_ADDR_VAR 0 3
15083: PUSH
15084: LD_INT 21
15086: PUSH
15087: LD_INT 22
15089: PUSH
15090: LD_INT 23
15092: PUSH
15093: LD_INT 24
15095: PUSH
15096: EMPTY
15097: LIST
15098: LIST
15099: LIST
15100: LIST
15101: ST_TO_ADDR
15102: GO 15387
15104: LD_INT 43
15106: DOUBLE
15107: EQUAL
15108: IFTRUE 15112
15110: GO 15138
15112: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
15113: LD_ADDR_VAR 0 3
15117: PUSH
15118: LD_INT 21
15120: PUSH
15121: LD_INT 22
15123: PUSH
15124: LD_INT 23
15126: PUSH
15127: LD_INT 24
15129: PUSH
15130: EMPTY
15131: LIST
15132: LIST
15133: LIST
15134: LIST
15135: ST_TO_ADDR
15136: GO 15387
15138: LD_INT 44
15140: DOUBLE
15141: EQUAL
15142: IFTRUE 15146
15144: GO 15172
15146: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
15147: LD_ADDR_VAR 0 3
15151: PUSH
15152: LD_INT 21
15154: PUSH
15155: LD_INT 22
15157: PUSH
15158: LD_INT 23
15160: PUSH
15161: LD_INT 24
15163: PUSH
15164: EMPTY
15165: LIST
15166: LIST
15167: LIST
15168: LIST
15169: ST_TO_ADDR
15170: GO 15387
15172: LD_INT 45
15174: DOUBLE
15175: EQUAL
15176: IFTRUE 15180
15178: GO 15206
15180: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
15181: LD_ADDR_VAR 0 3
15185: PUSH
15186: LD_INT 21
15188: PUSH
15189: LD_INT 22
15191: PUSH
15192: LD_INT 23
15194: PUSH
15195: LD_INT 24
15197: PUSH
15198: EMPTY
15199: LIST
15200: LIST
15201: LIST
15202: LIST
15203: ST_TO_ADDR
15204: GO 15387
15206: LD_INT 49
15208: DOUBLE
15209: EQUAL
15210: IFTRUE 15214
15212: GO 15240
15214: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
15215: LD_ADDR_VAR 0 3
15219: PUSH
15220: LD_INT 21
15222: PUSH
15223: LD_INT 22
15225: PUSH
15226: LD_INT 23
15228: PUSH
15229: LD_INT 24
15231: PUSH
15232: EMPTY
15233: LIST
15234: LIST
15235: LIST
15236: LIST
15237: ST_TO_ADDR
15238: GO 15387
15240: LD_INT 51
15242: DOUBLE
15243: EQUAL
15244: IFTRUE 15248
15246: GO 15274
15248: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
15249: LD_ADDR_VAR 0 3
15253: PUSH
15254: LD_INT 21
15256: PUSH
15257: LD_INT 22
15259: PUSH
15260: LD_INT 23
15262: PUSH
15263: LD_INT 24
15265: PUSH
15266: EMPTY
15267: LIST
15268: LIST
15269: LIST
15270: LIST
15271: ST_TO_ADDR
15272: GO 15387
15274: LD_INT 52
15276: DOUBLE
15277: EQUAL
15278: IFTRUE 15282
15280: GO 15308
15282: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
15283: LD_ADDR_VAR 0 3
15287: PUSH
15288: LD_INT 21
15290: PUSH
15291: LD_INT 22
15293: PUSH
15294: LD_INT 23
15296: PUSH
15297: LD_INT 24
15299: PUSH
15300: EMPTY
15301: LIST
15302: LIST
15303: LIST
15304: LIST
15305: ST_TO_ADDR
15306: GO 15387
15308: LD_INT 53
15310: DOUBLE
15311: EQUAL
15312: IFTRUE 15316
15314: GO 15334
15316: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
15317: LD_ADDR_VAR 0 3
15321: PUSH
15322: LD_INT 23
15324: PUSH
15325: LD_INT 24
15327: PUSH
15328: EMPTY
15329: LIST
15330: LIST
15331: ST_TO_ADDR
15332: GO 15387
15334: LD_INT 46
15336: DOUBLE
15337: EQUAL
15338: IFTRUE 15342
15340: GO 15360
15342: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
15343: LD_ADDR_VAR 0 3
15347: PUSH
15348: LD_INT 23
15350: PUSH
15351: LD_INT 24
15353: PUSH
15354: EMPTY
15355: LIST
15356: LIST
15357: ST_TO_ADDR
15358: GO 15387
15360: LD_INT 47
15362: DOUBLE
15363: EQUAL
15364: IFTRUE 15368
15366: GO 15386
15368: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
15369: LD_ADDR_VAR 0 3
15373: PUSH
15374: LD_INT 23
15376: PUSH
15377: LD_INT 24
15379: PUSH
15380: EMPTY
15381: LIST
15382: LIST
15383: ST_TO_ADDR
15384: GO 15387
15386: POP
// result := ( chassis in result ) ;
15387: LD_ADDR_VAR 0 3
15391: PUSH
15392: LD_VAR 0 1
15396: PUSH
15397: LD_VAR 0 3
15401: IN
15402: ST_TO_ADDR
// end ;
15403: LD_VAR 0 3
15407: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
15408: LD_INT 0
15410: PPUSH
15411: PPUSH
15412: PPUSH
15413: PPUSH
15414: PPUSH
15415: PPUSH
15416: PPUSH
// result := array ;
15417: LD_ADDR_VAR 0 5
15421: PUSH
15422: LD_VAR 0 1
15426: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
15427: LD_VAR 0 1
15431: NOT
15432: PUSH
15433: LD_VAR 0 2
15437: NOT
15438: OR
15439: PUSH
15440: LD_VAR 0 3
15444: NOT
15445: OR
15446: PUSH
15447: LD_VAR 0 2
15451: PUSH
15452: LD_VAR 0 1
15456: GREATER
15457: OR
15458: PUSH
15459: LD_VAR 0 3
15463: PUSH
15464: LD_VAR 0 1
15468: GREATER
15469: OR
15470: IFFALSE 15474
// exit ;
15472: GO 15770
// if direction then
15474: LD_VAR 0 4
15478: IFFALSE 15542
// begin d := 1 ;
15480: LD_ADDR_VAR 0 9
15484: PUSH
15485: LD_INT 1
15487: ST_TO_ADDR
// if i_from > i_to then
15488: LD_VAR 0 2
15492: PUSH
15493: LD_VAR 0 3
15497: GREATER
15498: IFFALSE 15524
// length := ( array - i_from ) + i_to else
15500: LD_ADDR_VAR 0 11
15504: PUSH
15505: LD_VAR 0 1
15509: PUSH
15510: LD_VAR 0 2
15514: MINUS
15515: PUSH
15516: LD_VAR 0 3
15520: PLUS
15521: ST_TO_ADDR
15522: GO 15540
// length := i_to - i_from ;
15524: LD_ADDR_VAR 0 11
15528: PUSH
15529: LD_VAR 0 3
15533: PUSH
15534: LD_VAR 0 2
15538: MINUS
15539: ST_TO_ADDR
// end else
15540: GO 15603
// begin d := - 1 ;
15542: LD_ADDR_VAR 0 9
15546: PUSH
15547: LD_INT 1
15549: NEG
15550: ST_TO_ADDR
// if i_from > i_to then
15551: LD_VAR 0 2
15555: PUSH
15556: LD_VAR 0 3
15560: GREATER
15561: IFFALSE 15581
// length := i_from - i_to else
15563: LD_ADDR_VAR 0 11
15567: PUSH
15568: LD_VAR 0 2
15572: PUSH
15573: LD_VAR 0 3
15577: MINUS
15578: ST_TO_ADDR
15579: GO 15603
// length := ( array - i_to ) + i_from ;
15581: LD_ADDR_VAR 0 11
15585: PUSH
15586: LD_VAR 0 1
15590: PUSH
15591: LD_VAR 0 3
15595: MINUS
15596: PUSH
15597: LD_VAR 0 2
15601: PLUS
15602: ST_TO_ADDR
// end ; if not length then
15603: LD_VAR 0 11
15607: NOT
15608: IFFALSE 15612
// exit ;
15610: GO 15770
// tmp := array ;
15612: LD_ADDR_VAR 0 10
15616: PUSH
15617: LD_VAR 0 1
15621: ST_TO_ADDR
// for i = 1 to length do
15622: LD_ADDR_VAR 0 6
15626: PUSH
15627: DOUBLE
15628: LD_INT 1
15630: DEC
15631: ST_TO_ADDR
15632: LD_VAR 0 11
15636: PUSH
15637: FOR_TO
15638: IFFALSE 15758
// begin for j = 1 to array do
15640: LD_ADDR_VAR 0 7
15644: PUSH
15645: DOUBLE
15646: LD_INT 1
15648: DEC
15649: ST_TO_ADDR
15650: LD_VAR 0 1
15654: PUSH
15655: FOR_TO
15656: IFFALSE 15744
// begin k := j + d ;
15658: LD_ADDR_VAR 0 8
15662: PUSH
15663: LD_VAR 0 7
15667: PUSH
15668: LD_VAR 0 9
15672: PLUS
15673: ST_TO_ADDR
// if k > array then
15674: LD_VAR 0 8
15678: PUSH
15679: LD_VAR 0 1
15683: GREATER
15684: IFFALSE 15694
// k := 1 ;
15686: LD_ADDR_VAR 0 8
15690: PUSH
15691: LD_INT 1
15693: ST_TO_ADDR
// if not k then
15694: LD_VAR 0 8
15698: NOT
15699: IFFALSE 15711
// k := array ;
15701: LD_ADDR_VAR 0 8
15705: PUSH
15706: LD_VAR 0 1
15710: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
15711: LD_ADDR_VAR 0 10
15715: PUSH
15716: LD_VAR 0 10
15720: PPUSH
15721: LD_VAR 0 8
15725: PPUSH
15726: LD_VAR 0 1
15730: PUSH
15731: LD_VAR 0 7
15735: ARRAY
15736: PPUSH
15737: CALL_OW 1
15741: ST_TO_ADDR
// end ;
15742: GO 15655
15744: POP
15745: POP
// array := tmp ;
15746: LD_ADDR_VAR 0 1
15750: PUSH
15751: LD_VAR 0 10
15755: ST_TO_ADDR
// end ;
15756: GO 15637
15758: POP
15759: POP
// result := array ;
15760: LD_ADDR_VAR 0 5
15764: PUSH
15765: LD_VAR 0 1
15769: ST_TO_ADDR
// end ;
15770: LD_VAR 0 5
15774: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
15775: LD_INT 0
15777: PPUSH
15778: PPUSH
// result := 0 ;
15779: LD_ADDR_VAR 0 3
15783: PUSH
15784: LD_INT 0
15786: ST_TO_ADDR
// if not array or not value in array then
15787: LD_VAR 0 1
15791: NOT
15792: PUSH
15793: LD_VAR 0 2
15797: PUSH
15798: LD_VAR 0 1
15802: IN
15803: NOT
15804: OR
15805: IFFALSE 15809
// exit ;
15807: GO 15863
// for i = 1 to array do
15809: LD_ADDR_VAR 0 4
15813: PUSH
15814: DOUBLE
15815: LD_INT 1
15817: DEC
15818: ST_TO_ADDR
15819: LD_VAR 0 1
15823: PUSH
15824: FOR_TO
15825: IFFALSE 15861
// if value = array [ i ] then
15827: LD_VAR 0 2
15831: PUSH
15832: LD_VAR 0 1
15836: PUSH
15837: LD_VAR 0 4
15841: ARRAY
15842: EQUAL
15843: IFFALSE 15859
// begin result := i ;
15845: LD_ADDR_VAR 0 3
15849: PUSH
15850: LD_VAR 0 4
15854: ST_TO_ADDR
// exit ;
15855: POP
15856: POP
15857: GO 15863
// end ;
15859: GO 15824
15861: POP
15862: POP
// end ;
15863: LD_VAR 0 3
15867: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
15868: LD_INT 0
15870: PPUSH
// vc_chassis := chassis ;
15871: LD_ADDR_OWVAR 37
15875: PUSH
15876: LD_VAR 0 1
15880: ST_TO_ADDR
// vc_engine := engine ;
15881: LD_ADDR_OWVAR 39
15885: PUSH
15886: LD_VAR 0 2
15890: ST_TO_ADDR
// vc_control := control ;
15891: LD_ADDR_OWVAR 38
15895: PUSH
15896: LD_VAR 0 3
15900: ST_TO_ADDR
// vc_weapon := weapon ;
15901: LD_ADDR_OWVAR 40
15905: PUSH
15906: LD_VAR 0 4
15910: ST_TO_ADDR
// vc_fuel_battery := fuel ;
15911: LD_ADDR_OWVAR 41
15915: PUSH
15916: LD_VAR 0 5
15920: ST_TO_ADDR
// end ;
15921: LD_VAR 0 6
15925: RET
// export function WantPlant ( unit ) ; var task ; begin
15926: LD_INT 0
15928: PPUSH
15929: PPUSH
// result := false ;
15930: LD_ADDR_VAR 0 2
15934: PUSH
15935: LD_INT 0
15937: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
15938: LD_ADDR_VAR 0 3
15942: PUSH
15943: LD_VAR 0 1
15947: PPUSH
15948: CALL_OW 437
15952: ST_TO_ADDR
// if task then
15953: LD_VAR 0 3
15957: IFFALSE 15985
// if task [ 1 ] [ 1 ] = p then
15959: LD_VAR 0 3
15963: PUSH
15964: LD_INT 1
15966: ARRAY
15967: PUSH
15968: LD_INT 1
15970: ARRAY
15971: PUSH
15972: LD_STRING p
15974: EQUAL
15975: IFFALSE 15985
// result := true ;
15977: LD_ADDR_VAR 0 2
15981: PUSH
15982: LD_INT 1
15984: ST_TO_ADDR
// end ;
15985: LD_VAR 0 2
15989: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
15990: LD_INT 0
15992: PPUSH
15993: PPUSH
15994: PPUSH
15995: PPUSH
// if pos < 1 then
15996: LD_VAR 0 2
16000: PUSH
16001: LD_INT 1
16003: LESS
16004: IFFALSE 16008
// exit ;
16006: GO 16311
// if pos = 1 then
16008: LD_VAR 0 2
16012: PUSH
16013: LD_INT 1
16015: EQUAL
16016: IFFALSE 16049
// result := Replace ( arr , pos [ 1 ] , value ) else
16018: LD_ADDR_VAR 0 4
16022: PUSH
16023: LD_VAR 0 1
16027: PPUSH
16028: LD_VAR 0 2
16032: PUSH
16033: LD_INT 1
16035: ARRAY
16036: PPUSH
16037: LD_VAR 0 3
16041: PPUSH
16042: CALL_OW 1
16046: ST_TO_ADDR
16047: GO 16311
// begin tmp := arr ;
16049: LD_ADDR_VAR 0 6
16053: PUSH
16054: LD_VAR 0 1
16058: ST_TO_ADDR
// s_arr := [ tmp ] ;
16059: LD_ADDR_VAR 0 7
16063: PUSH
16064: LD_VAR 0 6
16068: PUSH
16069: EMPTY
16070: LIST
16071: ST_TO_ADDR
// for i = 1 to pos - 1 do
16072: LD_ADDR_VAR 0 5
16076: PUSH
16077: DOUBLE
16078: LD_INT 1
16080: DEC
16081: ST_TO_ADDR
16082: LD_VAR 0 2
16086: PUSH
16087: LD_INT 1
16089: MINUS
16090: PUSH
16091: FOR_TO
16092: IFFALSE 16137
// begin tmp := tmp [ pos [ i ] ] ;
16094: LD_ADDR_VAR 0 6
16098: PUSH
16099: LD_VAR 0 6
16103: PUSH
16104: LD_VAR 0 2
16108: PUSH
16109: LD_VAR 0 5
16113: ARRAY
16114: ARRAY
16115: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
16116: LD_ADDR_VAR 0 7
16120: PUSH
16121: LD_VAR 0 7
16125: PUSH
16126: LD_VAR 0 6
16130: PUSH
16131: EMPTY
16132: LIST
16133: ADD
16134: ST_TO_ADDR
// end ;
16135: GO 16091
16137: POP
16138: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
16139: LD_ADDR_VAR 0 6
16143: PUSH
16144: LD_VAR 0 6
16148: PPUSH
16149: LD_VAR 0 2
16153: PUSH
16154: LD_VAR 0 2
16158: ARRAY
16159: PPUSH
16160: LD_VAR 0 3
16164: PPUSH
16165: CALL_OW 1
16169: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
16170: LD_ADDR_VAR 0 7
16174: PUSH
16175: LD_VAR 0 7
16179: PPUSH
16180: LD_VAR 0 7
16184: PPUSH
16185: LD_VAR 0 6
16189: PPUSH
16190: CALL_OW 1
16194: ST_TO_ADDR
// for i = s_arr downto 2 do
16195: LD_ADDR_VAR 0 5
16199: PUSH
16200: DOUBLE
16201: LD_VAR 0 7
16205: INC
16206: ST_TO_ADDR
16207: LD_INT 2
16209: PUSH
16210: FOR_DOWNTO
16211: IFFALSE 16295
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
16213: LD_ADDR_VAR 0 6
16217: PUSH
16218: LD_VAR 0 7
16222: PUSH
16223: LD_VAR 0 5
16227: PUSH
16228: LD_INT 1
16230: MINUS
16231: ARRAY
16232: PPUSH
16233: LD_VAR 0 2
16237: PUSH
16238: LD_VAR 0 5
16242: PUSH
16243: LD_INT 1
16245: MINUS
16246: ARRAY
16247: PPUSH
16248: LD_VAR 0 7
16252: PUSH
16253: LD_VAR 0 5
16257: ARRAY
16258: PPUSH
16259: CALL_OW 1
16263: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
16264: LD_ADDR_VAR 0 7
16268: PUSH
16269: LD_VAR 0 7
16273: PPUSH
16274: LD_VAR 0 5
16278: PUSH
16279: LD_INT 1
16281: MINUS
16282: PPUSH
16283: LD_VAR 0 6
16287: PPUSH
16288: CALL_OW 1
16292: ST_TO_ADDR
// end ;
16293: GO 16210
16295: POP
16296: POP
// result := s_arr [ 1 ] ;
16297: LD_ADDR_VAR 0 4
16301: PUSH
16302: LD_VAR 0 7
16306: PUSH
16307: LD_INT 1
16309: ARRAY
16310: ST_TO_ADDR
// end ; end ;
16311: LD_VAR 0 4
16315: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
16316: LD_INT 0
16318: PPUSH
16319: PPUSH
// if not list then
16320: LD_VAR 0 1
16324: NOT
16325: IFFALSE 16329
// exit ;
16327: GO 16420
// i := list [ pos1 ] ;
16329: LD_ADDR_VAR 0 5
16333: PUSH
16334: LD_VAR 0 1
16338: PUSH
16339: LD_VAR 0 2
16343: ARRAY
16344: ST_TO_ADDR
// if not i then
16345: LD_VAR 0 5
16349: NOT
16350: IFFALSE 16354
// exit ;
16352: GO 16420
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
16354: LD_ADDR_VAR 0 1
16358: PUSH
16359: LD_VAR 0 1
16363: PPUSH
16364: LD_VAR 0 2
16368: PPUSH
16369: LD_VAR 0 1
16373: PUSH
16374: LD_VAR 0 3
16378: ARRAY
16379: PPUSH
16380: CALL_OW 1
16384: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
16385: LD_ADDR_VAR 0 1
16389: PUSH
16390: LD_VAR 0 1
16394: PPUSH
16395: LD_VAR 0 3
16399: PPUSH
16400: LD_VAR 0 5
16404: PPUSH
16405: CALL_OW 1
16409: ST_TO_ADDR
// result := list ;
16410: LD_ADDR_VAR 0 4
16414: PUSH
16415: LD_VAR 0 1
16419: ST_TO_ADDR
// end ;
16420: LD_VAR 0 4
16424: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
16425: LD_INT 0
16427: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
16428: LD_ADDR_VAR 0 5
16432: PUSH
16433: LD_VAR 0 1
16437: PPUSH
16438: CALL_OW 250
16442: PPUSH
16443: LD_VAR 0 1
16447: PPUSH
16448: CALL_OW 251
16452: PPUSH
16453: LD_VAR 0 2
16457: PPUSH
16458: LD_VAR 0 3
16462: PPUSH
16463: LD_VAR 0 4
16467: PPUSH
16468: CALL 16478 0 5
16472: ST_TO_ADDR
// end ;
16473: LD_VAR 0 5
16477: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
16478: LD_INT 0
16480: PPUSH
16481: PPUSH
16482: PPUSH
16483: PPUSH
// if not list then
16484: LD_VAR 0 3
16488: NOT
16489: IFFALSE 16493
// exit ;
16491: GO 16881
// result := [ ] ;
16493: LD_ADDR_VAR 0 6
16497: PUSH
16498: EMPTY
16499: ST_TO_ADDR
// for i in list do
16500: LD_ADDR_VAR 0 7
16504: PUSH
16505: LD_VAR 0 3
16509: PUSH
16510: FOR_IN
16511: IFFALSE 16713
// begin tmp := GetDistUnitXY ( i , x , y ) ;
16513: LD_ADDR_VAR 0 9
16517: PUSH
16518: LD_VAR 0 7
16522: PPUSH
16523: LD_VAR 0 1
16527: PPUSH
16528: LD_VAR 0 2
16532: PPUSH
16533: CALL_OW 297
16537: ST_TO_ADDR
// if not result then
16538: LD_VAR 0 6
16542: NOT
16543: IFFALSE 16569
// result := [ [ i , tmp ] ] else
16545: LD_ADDR_VAR 0 6
16549: PUSH
16550: LD_VAR 0 7
16554: PUSH
16555: LD_VAR 0 9
16559: PUSH
16560: EMPTY
16561: LIST
16562: LIST
16563: PUSH
16564: EMPTY
16565: LIST
16566: ST_TO_ADDR
16567: GO 16711
// begin if result [ result ] [ 2 ] < tmp then
16569: LD_VAR 0 6
16573: PUSH
16574: LD_VAR 0 6
16578: ARRAY
16579: PUSH
16580: LD_INT 2
16582: ARRAY
16583: PUSH
16584: LD_VAR 0 9
16588: LESS
16589: IFFALSE 16631
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
16591: LD_ADDR_VAR 0 6
16595: PUSH
16596: LD_VAR 0 6
16600: PPUSH
16601: LD_VAR 0 6
16605: PUSH
16606: LD_INT 1
16608: PLUS
16609: PPUSH
16610: LD_VAR 0 7
16614: PUSH
16615: LD_VAR 0 9
16619: PUSH
16620: EMPTY
16621: LIST
16622: LIST
16623: PPUSH
16624: CALL_OW 2
16628: ST_TO_ADDR
16629: GO 16711
// for j = 1 to result do
16631: LD_ADDR_VAR 0 8
16635: PUSH
16636: DOUBLE
16637: LD_INT 1
16639: DEC
16640: ST_TO_ADDR
16641: LD_VAR 0 6
16645: PUSH
16646: FOR_TO
16647: IFFALSE 16709
// begin if tmp < result [ j ] [ 2 ] then
16649: LD_VAR 0 9
16653: PUSH
16654: LD_VAR 0 6
16658: PUSH
16659: LD_VAR 0 8
16663: ARRAY
16664: PUSH
16665: LD_INT 2
16667: ARRAY
16668: LESS
16669: IFFALSE 16707
// begin result := Insert ( result , j , [ i , tmp ] ) ;
16671: LD_ADDR_VAR 0 6
16675: PUSH
16676: LD_VAR 0 6
16680: PPUSH
16681: LD_VAR 0 8
16685: PPUSH
16686: LD_VAR 0 7
16690: PUSH
16691: LD_VAR 0 9
16695: PUSH
16696: EMPTY
16697: LIST
16698: LIST
16699: PPUSH
16700: CALL_OW 2
16704: ST_TO_ADDR
// break ;
16705: GO 16709
// end ; end ;
16707: GO 16646
16709: POP
16710: POP
// end ; end ;
16711: GO 16510
16713: POP
16714: POP
// if result and not asc then
16715: LD_VAR 0 6
16719: PUSH
16720: LD_VAR 0 4
16724: NOT
16725: AND
16726: IFFALSE 16801
// begin tmp := result ;
16728: LD_ADDR_VAR 0 9
16732: PUSH
16733: LD_VAR 0 6
16737: ST_TO_ADDR
// for i = tmp downto 1 do
16738: LD_ADDR_VAR 0 7
16742: PUSH
16743: DOUBLE
16744: LD_VAR 0 9
16748: INC
16749: ST_TO_ADDR
16750: LD_INT 1
16752: PUSH
16753: FOR_DOWNTO
16754: IFFALSE 16799
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
16756: LD_ADDR_VAR 0 6
16760: PUSH
16761: LD_VAR 0 6
16765: PPUSH
16766: LD_VAR 0 9
16770: PUSH
16771: LD_VAR 0 7
16775: MINUS
16776: PUSH
16777: LD_INT 1
16779: PLUS
16780: PPUSH
16781: LD_VAR 0 9
16785: PUSH
16786: LD_VAR 0 7
16790: ARRAY
16791: PPUSH
16792: CALL_OW 1
16796: ST_TO_ADDR
16797: GO 16753
16799: POP
16800: POP
// end ; tmp := [ ] ;
16801: LD_ADDR_VAR 0 9
16805: PUSH
16806: EMPTY
16807: ST_TO_ADDR
// if mode then
16808: LD_VAR 0 5
16812: IFFALSE 16881
// begin for i = 1 to result do
16814: LD_ADDR_VAR 0 7
16818: PUSH
16819: DOUBLE
16820: LD_INT 1
16822: DEC
16823: ST_TO_ADDR
16824: LD_VAR 0 6
16828: PUSH
16829: FOR_TO
16830: IFFALSE 16869
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
16832: LD_ADDR_VAR 0 9
16836: PUSH
16837: LD_VAR 0 9
16841: PPUSH
16842: LD_VAR 0 7
16846: PPUSH
16847: LD_VAR 0 6
16851: PUSH
16852: LD_VAR 0 7
16856: ARRAY
16857: PUSH
16858: LD_INT 1
16860: ARRAY
16861: PPUSH
16862: CALL_OW 1
16866: ST_TO_ADDR
16867: GO 16829
16869: POP
16870: POP
// result := tmp ;
16871: LD_ADDR_VAR 0 6
16875: PUSH
16876: LD_VAR 0 9
16880: ST_TO_ADDR
// end ; end ;
16881: LD_VAR 0 6
16885: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
16886: LD_INT 0
16888: PPUSH
16889: PPUSH
16890: PPUSH
16891: PPUSH
16892: PPUSH
16893: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
16894: LD_ADDR_VAR 0 5
16898: PUSH
16899: LD_INT 0
16901: PUSH
16902: LD_INT 0
16904: PUSH
16905: LD_INT 0
16907: PUSH
16908: EMPTY
16909: PUSH
16910: EMPTY
16911: LIST
16912: LIST
16913: LIST
16914: LIST
16915: ST_TO_ADDR
// if not x or not y then
16916: LD_VAR 0 2
16920: NOT
16921: PUSH
16922: LD_VAR 0 3
16926: NOT
16927: OR
16928: IFFALSE 16932
// exit ;
16930: GO 18584
// if not range then
16932: LD_VAR 0 4
16936: NOT
16937: IFFALSE 16947
// range := 10 ;
16939: LD_ADDR_VAR 0 4
16943: PUSH
16944: LD_INT 10
16946: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
16947: LD_ADDR_VAR 0 8
16951: PUSH
16952: LD_INT 81
16954: PUSH
16955: LD_VAR 0 1
16959: PUSH
16960: EMPTY
16961: LIST
16962: LIST
16963: PUSH
16964: LD_INT 92
16966: PUSH
16967: LD_VAR 0 2
16971: PUSH
16972: LD_VAR 0 3
16976: PUSH
16977: LD_VAR 0 4
16981: PUSH
16982: EMPTY
16983: LIST
16984: LIST
16985: LIST
16986: LIST
16987: PUSH
16988: LD_INT 3
16990: PUSH
16991: LD_INT 21
16993: PUSH
16994: LD_INT 3
16996: PUSH
16997: EMPTY
16998: LIST
16999: LIST
17000: PUSH
17001: EMPTY
17002: LIST
17003: LIST
17004: PUSH
17005: EMPTY
17006: LIST
17007: LIST
17008: LIST
17009: PPUSH
17010: CALL_OW 69
17014: ST_TO_ADDR
// if not tmp then
17015: LD_VAR 0 8
17019: NOT
17020: IFFALSE 17024
// exit ;
17022: GO 18584
// for i in tmp do
17024: LD_ADDR_VAR 0 6
17028: PUSH
17029: LD_VAR 0 8
17033: PUSH
17034: FOR_IN
17035: IFFALSE 18559
// begin points := [ 0 , 0 , 0 ] ;
17037: LD_ADDR_VAR 0 9
17041: PUSH
17042: LD_INT 0
17044: PUSH
17045: LD_INT 0
17047: PUSH
17048: LD_INT 0
17050: PUSH
17051: EMPTY
17052: LIST
17053: LIST
17054: LIST
17055: ST_TO_ADDR
// bpoints := 1 ;
17056: LD_ADDR_VAR 0 10
17060: PUSH
17061: LD_INT 1
17063: ST_TO_ADDR
// case GetType ( i ) of unit_human :
17064: LD_VAR 0 6
17068: PPUSH
17069: CALL_OW 247
17073: PUSH
17074: LD_INT 1
17076: DOUBLE
17077: EQUAL
17078: IFTRUE 17082
17080: GO 17660
17082: POP
// begin if GetClass ( i ) = 1 then
17083: LD_VAR 0 6
17087: PPUSH
17088: CALL_OW 257
17092: PUSH
17093: LD_INT 1
17095: EQUAL
17096: IFFALSE 17117
// points := [ 10 , 5 , 3 ] ;
17098: LD_ADDR_VAR 0 9
17102: PUSH
17103: LD_INT 10
17105: PUSH
17106: LD_INT 5
17108: PUSH
17109: LD_INT 3
17111: PUSH
17112: EMPTY
17113: LIST
17114: LIST
17115: LIST
17116: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
17117: LD_VAR 0 6
17121: PPUSH
17122: CALL_OW 257
17126: PUSH
17127: LD_INT 2
17129: PUSH
17130: LD_INT 3
17132: PUSH
17133: LD_INT 4
17135: PUSH
17136: EMPTY
17137: LIST
17138: LIST
17139: LIST
17140: IN
17141: IFFALSE 17162
// points := [ 3 , 2 , 1 ] ;
17143: LD_ADDR_VAR 0 9
17147: PUSH
17148: LD_INT 3
17150: PUSH
17151: LD_INT 2
17153: PUSH
17154: LD_INT 1
17156: PUSH
17157: EMPTY
17158: LIST
17159: LIST
17160: LIST
17161: ST_TO_ADDR
// if GetClass ( i ) = 5 then
17162: LD_VAR 0 6
17166: PPUSH
17167: CALL_OW 257
17171: PUSH
17172: LD_INT 5
17174: EQUAL
17175: IFFALSE 17196
// points := [ 130 , 5 , 2 ] ;
17177: LD_ADDR_VAR 0 9
17181: PUSH
17182: LD_INT 130
17184: PUSH
17185: LD_INT 5
17187: PUSH
17188: LD_INT 2
17190: PUSH
17191: EMPTY
17192: LIST
17193: LIST
17194: LIST
17195: ST_TO_ADDR
// if GetClass ( i ) = 8 then
17196: LD_VAR 0 6
17200: PPUSH
17201: CALL_OW 257
17205: PUSH
17206: LD_INT 8
17208: EQUAL
17209: IFFALSE 17230
// points := [ 35 , 35 , 30 ] ;
17211: LD_ADDR_VAR 0 9
17215: PUSH
17216: LD_INT 35
17218: PUSH
17219: LD_INT 35
17221: PUSH
17222: LD_INT 30
17224: PUSH
17225: EMPTY
17226: LIST
17227: LIST
17228: LIST
17229: ST_TO_ADDR
// if GetClass ( i ) = 9 then
17230: LD_VAR 0 6
17234: PPUSH
17235: CALL_OW 257
17239: PUSH
17240: LD_INT 9
17242: EQUAL
17243: IFFALSE 17264
// points := [ 20 , 55 , 40 ] ;
17245: LD_ADDR_VAR 0 9
17249: PUSH
17250: LD_INT 20
17252: PUSH
17253: LD_INT 55
17255: PUSH
17256: LD_INT 40
17258: PUSH
17259: EMPTY
17260: LIST
17261: LIST
17262: LIST
17263: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
17264: LD_VAR 0 6
17268: PPUSH
17269: CALL_OW 257
17273: PUSH
17274: LD_INT 12
17276: PUSH
17277: LD_INT 16
17279: PUSH
17280: EMPTY
17281: LIST
17282: LIST
17283: IN
17284: IFFALSE 17305
// points := [ 5 , 3 , 2 ] ;
17286: LD_ADDR_VAR 0 9
17290: PUSH
17291: LD_INT 5
17293: PUSH
17294: LD_INT 3
17296: PUSH
17297: LD_INT 2
17299: PUSH
17300: EMPTY
17301: LIST
17302: LIST
17303: LIST
17304: ST_TO_ADDR
// if GetClass ( i ) = 17 then
17305: LD_VAR 0 6
17309: PPUSH
17310: CALL_OW 257
17314: PUSH
17315: LD_INT 17
17317: EQUAL
17318: IFFALSE 17339
// points := [ 100 , 50 , 75 ] ;
17320: LD_ADDR_VAR 0 9
17324: PUSH
17325: LD_INT 100
17327: PUSH
17328: LD_INT 50
17330: PUSH
17331: LD_INT 75
17333: PUSH
17334: EMPTY
17335: LIST
17336: LIST
17337: LIST
17338: ST_TO_ADDR
// if GetClass ( i ) = 15 then
17339: LD_VAR 0 6
17343: PPUSH
17344: CALL_OW 257
17348: PUSH
17349: LD_INT 15
17351: EQUAL
17352: IFFALSE 17373
// points := [ 10 , 5 , 3 ] ;
17354: LD_ADDR_VAR 0 9
17358: PUSH
17359: LD_INT 10
17361: PUSH
17362: LD_INT 5
17364: PUSH
17365: LD_INT 3
17367: PUSH
17368: EMPTY
17369: LIST
17370: LIST
17371: LIST
17372: ST_TO_ADDR
// if GetClass ( i ) = 14 then
17373: LD_VAR 0 6
17377: PPUSH
17378: CALL_OW 257
17382: PUSH
17383: LD_INT 14
17385: EQUAL
17386: IFFALSE 17407
// points := [ 10 , 0 , 0 ] ;
17388: LD_ADDR_VAR 0 9
17392: PUSH
17393: LD_INT 10
17395: PUSH
17396: LD_INT 0
17398: PUSH
17399: LD_INT 0
17401: PUSH
17402: EMPTY
17403: LIST
17404: LIST
17405: LIST
17406: ST_TO_ADDR
// if GetClass ( i ) = 11 then
17407: LD_VAR 0 6
17411: PPUSH
17412: CALL_OW 257
17416: PUSH
17417: LD_INT 11
17419: EQUAL
17420: IFFALSE 17441
// points := [ 30 , 10 , 5 ] ;
17422: LD_ADDR_VAR 0 9
17426: PUSH
17427: LD_INT 30
17429: PUSH
17430: LD_INT 10
17432: PUSH
17433: LD_INT 5
17435: PUSH
17436: EMPTY
17437: LIST
17438: LIST
17439: LIST
17440: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
17441: LD_VAR 0 1
17445: PPUSH
17446: LD_INT 5
17448: PPUSH
17449: CALL_OW 321
17453: PUSH
17454: LD_INT 2
17456: EQUAL
17457: IFFALSE 17474
// bpoints := bpoints * 1.8 ;
17459: LD_ADDR_VAR 0 10
17463: PUSH
17464: LD_VAR 0 10
17468: PUSH
17469: LD_REAL  1.80000000000000E+0000
17472: MUL
17473: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
17474: LD_VAR 0 6
17478: PPUSH
17479: CALL_OW 257
17483: PUSH
17484: LD_INT 1
17486: PUSH
17487: LD_INT 2
17489: PUSH
17490: LD_INT 3
17492: PUSH
17493: LD_INT 4
17495: PUSH
17496: EMPTY
17497: LIST
17498: LIST
17499: LIST
17500: LIST
17501: IN
17502: PUSH
17503: LD_VAR 0 1
17507: PPUSH
17508: LD_INT 51
17510: PPUSH
17511: CALL_OW 321
17515: PUSH
17516: LD_INT 2
17518: EQUAL
17519: AND
17520: IFFALSE 17537
// bpoints := bpoints * 1.2 ;
17522: LD_ADDR_VAR 0 10
17526: PUSH
17527: LD_VAR 0 10
17531: PUSH
17532: LD_REAL  1.20000000000000E+0000
17535: MUL
17536: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
17537: LD_VAR 0 6
17541: PPUSH
17542: CALL_OW 257
17546: PUSH
17547: LD_INT 5
17549: PUSH
17550: LD_INT 7
17552: PUSH
17553: LD_INT 9
17555: PUSH
17556: EMPTY
17557: LIST
17558: LIST
17559: LIST
17560: IN
17561: PUSH
17562: LD_VAR 0 1
17566: PPUSH
17567: LD_INT 52
17569: PPUSH
17570: CALL_OW 321
17574: PUSH
17575: LD_INT 2
17577: EQUAL
17578: AND
17579: IFFALSE 17596
// bpoints := bpoints * 1.5 ;
17581: LD_ADDR_VAR 0 10
17585: PUSH
17586: LD_VAR 0 10
17590: PUSH
17591: LD_REAL  1.50000000000000E+0000
17594: MUL
17595: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
17596: LD_VAR 0 1
17600: PPUSH
17601: LD_INT 66
17603: PPUSH
17604: CALL_OW 321
17608: PUSH
17609: LD_INT 2
17611: EQUAL
17612: IFFALSE 17629
// bpoints := bpoints * 1.1 ;
17614: LD_ADDR_VAR 0 10
17618: PUSH
17619: LD_VAR 0 10
17623: PUSH
17624: LD_REAL  1.10000000000000E+0000
17627: MUL
17628: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
17629: LD_ADDR_VAR 0 10
17633: PUSH
17634: LD_VAR 0 10
17638: PUSH
17639: LD_VAR 0 6
17643: PPUSH
17644: LD_INT 1
17646: PPUSH
17647: CALL_OW 259
17651: PUSH
17652: LD_REAL  1.15000000000000E+0000
17655: MUL
17656: MUL
17657: ST_TO_ADDR
// end ; unit_vehicle :
17658: GO 18488
17660: LD_INT 2
17662: DOUBLE
17663: EQUAL
17664: IFTRUE 17668
17666: GO 18476
17668: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
17669: LD_VAR 0 6
17673: PPUSH
17674: CALL_OW 264
17678: PUSH
17679: LD_INT 2
17681: PUSH
17682: LD_INT 42
17684: PUSH
17685: LD_INT 24
17687: PUSH
17688: EMPTY
17689: LIST
17690: LIST
17691: LIST
17692: IN
17693: IFFALSE 17714
// points := [ 25 , 5 , 3 ] ;
17695: LD_ADDR_VAR 0 9
17699: PUSH
17700: LD_INT 25
17702: PUSH
17703: LD_INT 5
17705: PUSH
17706: LD_INT 3
17708: PUSH
17709: EMPTY
17710: LIST
17711: LIST
17712: LIST
17713: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
17714: LD_VAR 0 6
17718: PPUSH
17719: CALL_OW 264
17723: PUSH
17724: LD_INT 4
17726: PUSH
17727: LD_INT 43
17729: PUSH
17730: LD_INT 25
17732: PUSH
17733: EMPTY
17734: LIST
17735: LIST
17736: LIST
17737: IN
17738: IFFALSE 17759
// points := [ 40 , 15 , 5 ] ;
17740: LD_ADDR_VAR 0 9
17744: PUSH
17745: LD_INT 40
17747: PUSH
17748: LD_INT 15
17750: PUSH
17751: LD_INT 5
17753: PUSH
17754: EMPTY
17755: LIST
17756: LIST
17757: LIST
17758: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
17759: LD_VAR 0 6
17763: PPUSH
17764: CALL_OW 264
17768: PUSH
17769: LD_INT 3
17771: PUSH
17772: LD_INT 23
17774: PUSH
17775: EMPTY
17776: LIST
17777: LIST
17778: IN
17779: IFFALSE 17800
// points := [ 7 , 25 , 8 ] ;
17781: LD_ADDR_VAR 0 9
17785: PUSH
17786: LD_INT 7
17788: PUSH
17789: LD_INT 25
17791: PUSH
17792: LD_INT 8
17794: PUSH
17795: EMPTY
17796: LIST
17797: LIST
17798: LIST
17799: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
17800: LD_VAR 0 6
17804: PPUSH
17805: CALL_OW 264
17809: PUSH
17810: LD_INT 5
17812: PUSH
17813: LD_INT 27
17815: PUSH
17816: LD_INT 44
17818: PUSH
17819: EMPTY
17820: LIST
17821: LIST
17822: LIST
17823: IN
17824: IFFALSE 17845
// points := [ 14 , 50 , 16 ] ;
17826: LD_ADDR_VAR 0 9
17830: PUSH
17831: LD_INT 14
17833: PUSH
17834: LD_INT 50
17836: PUSH
17837: LD_INT 16
17839: PUSH
17840: EMPTY
17841: LIST
17842: LIST
17843: LIST
17844: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
17845: LD_VAR 0 6
17849: PPUSH
17850: CALL_OW 264
17854: PUSH
17855: LD_INT 6
17857: PUSH
17858: LD_INT 46
17860: PUSH
17861: EMPTY
17862: LIST
17863: LIST
17864: IN
17865: IFFALSE 17886
// points := [ 32 , 120 , 70 ] ;
17867: LD_ADDR_VAR 0 9
17871: PUSH
17872: LD_INT 32
17874: PUSH
17875: LD_INT 120
17877: PUSH
17878: LD_INT 70
17880: PUSH
17881: EMPTY
17882: LIST
17883: LIST
17884: LIST
17885: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
17886: LD_VAR 0 6
17890: PPUSH
17891: CALL_OW 264
17895: PUSH
17896: LD_INT 7
17898: PUSH
17899: LD_INT 28
17901: PUSH
17902: LD_INT 45
17904: PUSH
17905: LD_EXP 72
17909: PUSH
17910: EMPTY
17911: LIST
17912: LIST
17913: LIST
17914: LIST
17915: IN
17916: IFFALSE 17937
// points := [ 35 , 20 , 45 ] ;
17918: LD_ADDR_VAR 0 9
17922: PUSH
17923: LD_INT 35
17925: PUSH
17926: LD_INT 20
17928: PUSH
17929: LD_INT 45
17931: PUSH
17932: EMPTY
17933: LIST
17934: LIST
17935: LIST
17936: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
17937: LD_VAR 0 6
17941: PPUSH
17942: CALL_OW 264
17946: PUSH
17947: LD_INT 47
17949: PUSH
17950: EMPTY
17951: LIST
17952: IN
17953: IFFALSE 17974
// points := [ 67 , 45 , 75 ] ;
17955: LD_ADDR_VAR 0 9
17959: PUSH
17960: LD_INT 67
17962: PUSH
17963: LD_INT 45
17965: PUSH
17966: LD_INT 75
17968: PUSH
17969: EMPTY
17970: LIST
17971: LIST
17972: LIST
17973: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
17974: LD_VAR 0 6
17978: PPUSH
17979: CALL_OW 264
17983: PUSH
17984: LD_INT 26
17986: PUSH
17987: EMPTY
17988: LIST
17989: IN
17990: IFFALSE 18011
// points := [ 120 , 30 , 80 ] ;
17992: LD_ADDR_VAR 0 9
17996: PUSH
17997: LD_INT 120
17999: PUSH
18000: LD_INT 30
18002: PUSH
18003: LD_INT 80
18005: PUSH
18006: EMPTY
18007: LIST
18008: LIST
18009: LIST
18010: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
18011: LD_VAR 0 6
18015: PPUSH
18016: CALL_OW 264
18020: PUSH
18021: LD_INT 22
18023: PUSH
18024: EMPTY
18025: LIST
18026: IN
18027: IFFALSE 18048
// points := [ 40 , 1 , 1 ] ;
18029: LD_ADDR_VAR 0 9
18033: PUSH
18034: LD_INT 40
18036: PUSH
18037: LD_INT 1
18039: PUSH
18040: LD_INT 1
18042: PUSH
18043: EMPTY
18044: LIST
18045: LIST
18046: LIST
18047: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
18048: LD_VAR 0 6
18052: PPUSH
18053: CALL_OW 264
18057: PUSH
18058: LD_INT 29
18060: PUSH
18061: EMPTY
18062: LIST
18063: IN
18064: IFFALSE 18085
// points := [ 70 , 200 , 400 ] ;
18066: LD_ADDR_VAR 0 9
18070: PUSH
18071: LD_INT 70
18073: PUSH
18074: LD_INT 200
18076: PUSH
18077: LD_INT 400
18079: PUSH
18080: EMPTY
18081: LIST
18082: LIST
18083: LIST
18084: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
18085: LD_VAR 0 6
18089: PPUSH
18090: CALL_OW 264
18094: PUSH
18095: LD_INT 14
18097: PUSH
18098: LD_INT 53
18100: PUSH
18101: EMPTY
18102: LIST
18103: LIST
18104: IN
18105: IFFALSE 18126
// points := [ 40 , 10 , 20 ] ;
18107: LD_ADDR_VAR 0 9
18111: PUSH
18112: LD_INT 40
18114: PUSH
18115: LD_INT 10
18117: PUSH
18118: LD_INT 20
18120: PUSH
18121: EMPTY
18122: LIST
18123: LIST
18124: LIST
18125: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
18126: LD_VAR 0 6
18130: PPUSH
18131: CALL_OW 264
18135: PUSH
18136: LD_INT 9
18138: PUSH
18139: EMPTY
18140: LIST
18141: IN
18142: IFFALSE 18163
// points := [ 5 , 70 , 20 ] ;
18144: LD_ADDR_VAR 0 9
18148: PUSH
18149: LD_INT 5
18151: PUSH
18152: LD_INT 70
18154: PUSH
18155: LD_INT 20
18157: PUSH
18158: EMPTY
18159: LIST
18160: LIST
18161: LIST
18162: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
18163: LD_VAR 0 6
18167: PPUSH
18168: CALL_OW 264
18172: PUSH
18173: LD_INT 10
18175: PUSH
18176: EMPTY
18177: LIST
18178: IN
18179: IFFALSE 18200
// points := [ 35 , 110 , 70 ] ;
18181: LD_ADDR_VAR 0 9
18185: PUSH
18186: LD_INT 35
18188: PUSH
18189: LD_INT 110
18191: PUSH
18192: LD_INT 70
18194: PUSH
18195: EMPTY
18196: LIST
18197: LIST
18198: LIST
18199: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
18200: LD_VAR 0 6
18204: PPUSH
18205: CALL_OW 265
18209: PUSH
18210: LD_INT 25
18212: EQUAL
18213: IFFALSE 18234
// points := [ 80 , 65 , 100 ] ;
18215: LD_ADDR_VAR 0 9
18219: PUSH
18220: LD_INT 80
18222: PUSH
18223: LD_INT 65
18225: PUSH
18226: LD_INT 100
18228: PUSH
18229: EMPTY
18230: LIST
18231: LIST
18232: LIST
18233: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
18234: LD_VAR 0 6
18238: PPUSH
18239: CALL_OW 263
18243: PUSH
18244: LD_INT 1
18246: EQUAL
18247: IFFALSE 18282
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
18249: LD_ADDR_VAR 0 10
18253: PUSH
18254: LD_VAR 0 10
18258: PUSH
18259: LD_VAR 0 6
18263: PPUSH
18264: CALL_OW 311
18268: PPUSH
18269: LD_INT 3
18271: PPUSH
18272: CALL_OW 259
18276: PUSH
18277: LD_INT 4
18279: MUL
18280: MUL
18281: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
18282: LD_VAR 0 6
18286: PPUSH
18287: CALL_OW 263
18291: PUSH
18292: LD_INT 2
18294: EQUAL
18295: IFFALSE 18346
// begin j := IsControledBy ( i ) ;
18297: LD_ADDR_VAR 0 7
18301: PUSH
18302: LD_VAR 0 6
18306: PPUSH
18307: CALL_OW 312
18311: ST_TO_ADDR
// if j then
18312: LD_VAR 0 7
18316: IFFALSE 18346
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
18318: LD_ADDR_VAR 0 10
18322: PUSH
18323: LD_VAR 0 10
18327: PUSH
18328: LD_VAR 0 7
18332: PPUSH
18333: LD_INT 3
18335: PPUSH
18336: CALL_OW 259
18340: PUSH
18341: LD_INT 3
18343: MUL
18344: MUL
18345: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
18346: LD_VAR 0 6
18350: PPUSH
18351: CALL_OW 264
18355: PUSH
18356: LD_INT 5
18358: PUSH
18359: LD_INT 6
18361: PUSH
18362: LD_INT 46
18364: PUSH
18365: LD_INT 44
18367: PUSH
18368: LD_INT 47
18370: PUSH
18371: LD_INT 45
18373: PUSH
18374: LD_INT 28
18376: PUSH
18377: LD_INT 7
18379: PUSH
18380: LD_INT 27
18382: PUSH
18383: LD_INT 29
18385: PUSH
18386: EMPTY
18387: LIST
18388: LIST
18389: LIST
18390: LIST
18391: LIST
18392: LIST
18393: LIST
18394: LIST
18395: LIST
18396: LIST
18397: IN
18398: PUSH
18399: LD_VAR 0 1
18403: PPUSH
18404: LD_INT 52
18406: PPUSH
18407: CALL_OW 321
18411: PUSH
18412: LD_INT 2
18414: EQUAL
18415: AND
18416: IFFALSE 18433
// bpoints := bpoints * 1.2 ;
18418: LD_ADDR_VAR 0 10
18422: PUSH
18423: LD_VAR 0 10
18427: PUSH
18428: LD_REAL  1.20000000000000E+0000
18431: MUL
18432: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
18433: LD_VAR 0 6
18437: PPUSH
18438: CALL_OW 264
18442: PUSH
18443: LD_INT 6
18445: PUSH
18446: LD_INT 46
18448: PUSH
18449: LD_INT 47
18451: PUSH
18452: EMPTY
18453: LIST
18454: LIST
18455: LIST
18456: IN
18457: IFFALSE 18474
// bpoints := bpoints * 1.2 ;
18459: LD_ADDR_VAR 0 10
18463: PUSH
18464: LD_VAR 0 10
18468: PUSH
18469: LD_REAL  1.20000000000000E+0000
18472: MUL
18473: ST_TO_ADDR
// end ; unit_building :
18474: GO 18488
18476: LD_INT 3
18478: DOUBLE
18479: EQUAL
18480: IFTRUE 18484
18482: GO 18487
18484: POP
// ; end ;
18485: GO 18488
18487: POP
// for j = 1 to 3 do
18488: LD_ADDR_VAR 0 7
18492: PUSH
18493: DOUBLE
18494: LD_INT 1
18496: DEC
18497: ST_TO_ADDR
18498: LD_INT 3
18500: PUSH
18501: FOR_TO
18502: IFFALSE 18555
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
18504: LD_ADDR_VAR 0 5
18508: PUSH
18509: LD_VAR 0 5
18513: PPUSH
18514: LD_VAR 0 7
18518: PPUSH
18519: LD_VAR 0 5
18523: PUSH
18524: LD_VAR 0 7
18528: ARRAY
18529: PUSH
18530: LD_VAR 0 9
18534: PUSH
18535: LD_VAR 0 7
18539: ARRAY
18540: PUSH
18541: LD_VAR 0 10
18545: MUL
18546: PLUS
18547: PPUSH
18548: CALL_OW 1
18552: ST_TO_ADDR
18553: GO 18501
18555: POP
18556: POP
// end ;
18557: GO 17034
18559: POP
18560: POP
// result := Replace ( result , 4 , tmp ) ;
18561: LD_ADDR_VAR 0 5
18565: PUSH
18566: LD_VAR 0 5
18570: PPUSH
18571: LD_INT 4
18573: PPUSH
18574: LD_VAR 0 8
18578: PPUSH
18579: CALL_OW 1
18583: ST_TO_ADDR
// end ;
18584: LD_VAR 0 5
18588: RET
// export function DangerAtRange ( unit , range ) ; begin
18589: LD_INT 0
18591: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
18592: LD_ADDR_VAR 0 3
18596: PUSH
18597: LD_VAR 0 1
18601: PPUSH
18602: CALL_OW 255
18606: PPUSH
18607: LD_VAR 0 1
18611: PPUSH
18612: CALL_OW 250
18616: PPUSH
18617: LD_VAR 0 1
18621: PPUSH
18622: CALL_OW 251
18626: PPUSH
18627: LD_VAR 0 2
18631: PPUSH
18632: CALL 16886 0 4
18636: ST_TO_ADDR
// end ;
18637: LD_VAR 0 3
18641: RET
// export function DangerInArea ( side , area ) ; begin
18642: LD_INT 0
18644: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
18645: LD_ADDR_VAR 0 3
18649: PUSH
18650: LD_VAR 0 2
18654: PPUSH
18655: LD_INT 81
18657: PUSH
18658: LD_VAR 0 1
18662: PUSH
18663: EMPTY
18664: LIST
18665: LIST
18666: PPUSH
18667: CALL_OW 70
18671: ST_TO_ADDR
// end ;
18672: LD_VAR 0 3
18676: RET
// export function IsExtension ( b ) ; begin
18677: LD_INT 0
18679: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
18680: LD_ADDR_VAR 0 2
18684: PUSH
18685: LD_VAR 0 1
18689: PUSH
18690: LD_INT 23
18692: PUSH
18693: LD_INT 20
18695: PUSH
18696: LD_INT 22
18698: PUSH
18699: LD_INT 17
18701: PUSH
18702: LD_INT 24
18704: PUSH
18705: LD_INT 21
18707: PUSH
18708: LD_INT 19
18710: PUSH
18711: LD_INT 16
18713: PUSH
18714: LD_INT 25
18716: PUSH
18717: LD_INT 18
18719: PUSH
18720: EMPTY
18721: LIST
18722: LIST
18723: LIST
18724: LIST
18725: LIST
18726: LIST
18727: LIST
18728: LIST
18729: LIST
18730: LIST
18731: IN
18732: ST_TO_ADDR
// end ;
18733: LD_VAR 0 2
18737: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
18738: LD_INT 0
18740: PPUSH
18741: PPUSH
18742: PPUSH
// result := [ ] ;
18743: LD_ADDR_VAR 0 4
18747: PUSH
18748: EMPTY
18749: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
18750: LD_ADDR_VAR 0 5
18754: PUSH
18755: LD_VAR 0 2
18759: PPUSH
18760: LD_INT 21
18762: PUSH
18763: LD_INT 3
18765: PUSH
18766: EMPTY
18767: LIST
18768: LIST
18769: PPUSH
18770: CALL_OW 70
18774: ST_TO_ADDR
// if not tmp then
18775: LD_VAR 0 5
18779: NOT
18780: IFFALSE 18784
// exit ;
18782: GO 18848
// if checkLink then
18784: LD_VAR 0 3
18788: IFFALSE 18838
// begin for i in tmp do
18790: LD_ADDR_VAR 0 6
18794: PUSH
18795: LD_VAR 0 5
18799: PUSH
18800: FOR_IN
18801: IFFALSE 18836
// if GetBase ( i ) <> base then
18803: LD_VAR 0 6
18807: PPUSH
18808: CALL_OW 274
18812: PUSH
18813: LD_VAR 0 1
18817: NONEQUAL
18818: IFFALSE 18834
// ComLinkToBase ( base , i ) ;
18820: LD_VAR 0 1
18824: PPUSH
18825: LD_VAR 0 6
18829: PPUSH
18830: CALL_OW 169
18834: GO 18800
18836: POP
18837: POP
// end ; result := tmp ;
18838: LD_ADDR_VAR 0 4
18842: PUSH
18843: LD_VAR 0 5
18847: ST_TO_ADDR
// end ;
18848: LD_VAR 0 4
18852: RET
// export function ComComplete ( units , b ) ; var i ; begin
18853: LD_INT 0
18855: PPUSH
18856: PPUSH
// if not units then
18857: LD_VAR 0 1
18861: NOT
18862: IFFALSE 18866
// exit ;
18864: GO 18956
// for i in units do
18866: LD_ADDR_VAR 0 4
18870: PUSH
18871: LD_VAR 0 1
18875: PUSH
18876: FOR_IN
18877: IFFALSE 18954
// if BuildingStatus ( b ) = bs_build then
18879: LD_VAR 0 2
18883: PPUSH
18884: CALL_OW 461
18888: PUSH
18889: LD_INT 1
18891: EQUAL
18892: IFFALSE 18952
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
18894: LD_VAR 0 4
18898: PPUSH
18899: LD_STRING h
18901: PUSH
18902: LD_VAR 0 2
18906: PPUSH
18907: CALL_OW 250
18911: PUSH
18912: LD_VAR 0 2
18916: PPUSH
18917: CALL_OW 251
18921: PUSH
18922: LD_VAR 0 2
18926: PUSH
18927: LD_INT 0
18929: PUSH
18930: LD_INT 0
18932: PUSH
18933: LD_INT 0
18935: PUSH
18936: EMPTY
18937: LIST
18938: LIST
18939: LIST
18940: LIST
18941: LIST
18942: LIST
18943: LIST
18944: PUSH
18945: EMPTY
18946: LIST
18947: PPUSH
18948: CALL_OW 446
18952: GO 18876
18954: POP
18955: POP
// end ;
18956: LD_VAR 0 3
18960: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
18961: LD_INT 0
18963: PPUSH
18964: PPUSH
18965: PPUSH
18966: PPUSH
18967: PPUSH
18968: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
18969: LD_VAR 0 1
18973: NOT
18974: PUSH
18975: LD_VAR 0 1
18979: PPUSH
18980: CALL_OW 263
18984: PUSH
18985: LD_INT 2
18987: NONEQUAL
18988: OR
18989: IFFALSE 18993
// exit ;
18991: GO 19309
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
18993: LD_ADDR_VAR 0 6
18997: PUSH
18998: LD_INT 22
19000: PUSH
19001: LD_VAR 0 1
19005: PPUSH
19006: CALL_OW 255
19010: PUSH
19011: EMPTY
19012: LIST
19013: LIST
19014: PUSH
19015: LD_INT 2
19017: PUSH
19018: LD_INT 30
19020: PUSH
19021: LD_INT 36
19023: PUSH
19024: EMPTY
19025: LIST
19026: LIST
19027: PUSH
19028: LD_INT 34
19030: PUSH
19031: LD_INT 31
19033: PUSH
19034: EMPTY
19035: LIST
19036: LIST
19037: PUSH
19038: EMPTY
19039: LIST
19040: LIST
19041: LIST
19042: PUSH
19043: EMPTY
19044: LIST
19045: LIST
19046: PPUSH
19047: CALL_OW 69
19051: ST_TO_ADDR
// if not tmp then
19052: LD_VAR 0 6
19056: NOT
19057: IFFALSE 19061
// exit ;
19059: GO 19309
// result := [ ] ;
19061: LD_ADDR_VAR 0 2
19065: PUSH
19066: EMPTY
19067: ST_TO_ADDR
// for i in tmp do
19068: LD_ADDR_VAR 0 3
19072: PUSH
19073: LD_VAR 0 6
19077: PUSH
19078: FOR_IN
19079: IFFALSE 19150
// begin t := UnitsInside ( i ) ;
19081: LD_ADDR_VAR 0 4
19085: PUSH
19086: LD_VAR 0 3
19090: PPUSH
19091: CALL_OW 313
19095: ST_TO_ADDR
// if t then
19096: LD_VAR 0 4
19100: IFFALSE 19148
// for j in t do
19102: LD_ADDR_VAR 0 7
19106: PUSH
19107: LD_VAR 0 4
19111: PUSH
19112: FOR_IN
19113: IFFALSE 19146
// result := Replace ( result , result + 1 , j ) ;
19115: LD_ADDR_VAR 0 2
19119: PUSH
19120: LD_VAR 0 2
19124: PPUSH
19125: LD_VAR 0 2
19129: PUSH
19130: LD_INT 1
19132: PLUS
19133: PPUSH
19134: LD_VAR 0 7
19138: PPUSH
19139: CALL_OW 1
19143: ST_TO_ADDR
19144: GO 19112
19146: POP
19147: POP
// end ;
19148: GO 19078
19150: POP
19151: POP
// if not result then
19152: LD_VAR 0 2
19156: NOT
19157: IFFALSE 19161
// exit ;
19159: GO 19309
// mech := result [ 1 ] ;
19161: LD_ADDR_VAR 0 5
19165: PUSH
19166: LD_VAR 0 2
19170: PUSH
19171: LD_INT 1
19173: ARRAY
19174: ST_TO_ADDR
// if result > 1 then
19175: LD_VAR 0 2
19179: PUSH
19180: LD_INT 1
19182: GREATER
19183: IFFALSE 19295
// begin for i = 2 to result do
19185: LD_ADDR_VAR 0 3
19189: PUSH
19190: DOUBLE
19191: LD_INT 2
19193: DEC
19194: ST_TO_ADDR
19195: LD_VAR 0 2
19199: PUSH
19200: FOR_TO
19201: IFFALSE 19293
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
19203: LD_ADDR_VAR 0 4
19207: PUSH
19208: LD_VAR 0 2
19212: PUSH
19213: LD_VAR 0 3
19217: ARRAY
19218: PPUSH
19219: LD_INT 3
19221: PPUSH
19222: CALL_OW 259
19226: PUSH
19227: LD_VAR 0 2
19231: PUSH
19232: LD_VAR 0 3
19236: ARRAY
19237: PPUSH
19238: CALL_OW 432
19242: MINUS
19243: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
19244: LD_VAR 0 4
19248: PUSH
19249: LD_VAR 0 5
19253: PPUSH
19254: LD_INT 3
19256: PPUSH
19257: CALL_OW 259
19261: PUSH
19262: LD_VAR 0 5
19266: PPUSH
19267: CALL_OW 432
19271: MINUS
19272: GREATEREQUAL
19273: IFFALSE 19291
// mech := result [ i ] ;
19275: LD_ADDR_VAR 0 5
19279: PUSH
19280: LD_VAR 0 2
19284: PUSH
19285: LD_VAR 0 3
19289: ARRAY
19290: ST_TO_ADDR
// end ;
19291: GO 19200
19293: POP
19294: POP
// end ; ComLinkTo ( vehicle , mech ) ;
19295: LD_VAR 0 1
19299: PPUSH
19300: LD_VAR 0 5
19304: PPUSH
19305: CALL_OW 135
// end ;
19309: LD_VAR 0 2
19313: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
19314: LD_INT 0
19316: PPUSH
19317: PPUSH
19318: PPUSH
19319: PPUSH
19320: PPUSH
19321: PPUSH
19322: PPUSH
19323: PPUSH
19324: PPUSH
19325: PPUSH
19326: PPUSH
19327: PPUSH
19328: PPUSH
// result := [ ] ;
19329: LD_ADDR_VAR 0 7
19333: PUSH
19334: EMPTY
19335: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
19336: LD_VAR 0 1
19340: PPUSH
19341: CALL_OW 266
19345: PUSH
19346: LD_INT 0
19348: PUSH
19349: LD_INT 1
19351: PUSH
19352: EMPTY
19353: LIST
19354: LIST
19355: IN
19356: NOT
19357: IFFALSE 19361
// exit ;
19359: GO 20995
// if name then
19361: LD_VAR 0 3
19365: IFFALSE 19381
// SetBName ( base_dep , name ) ;
19367: LD_VAR 0 1
19371: PPUSH
19372: LD_VAR 0 3
19376: PPUSH
19377: CALL_OW 500
// base := GetBase ( base_dep ) ;
19381: LD_ADDR_VAR 0 15
19385: PUSH
19386: LD_VAR 0 1
19390: PPUSH
19391: CALL_OW 274
19395: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
19396: LD_ADDR_VAR 0 16
19400: PUSH
19401: LD_VAR 0 1
19405: PPUSH
19406: CALL_OW 255
19410: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
19411: LD_ADDR_VAR 0 17
19415: PUSH
19416: LD_VAR 0 1
19420: PPUSH
19421: CALL_OW 248
19425: ST_TO_ADDR
// if sources then
19426: LD_VAR 0 5
19430: IFFALSE 19477
// for i = 1 to 3 do
19432: LD_ADDR_VAR 0 8
19436: PUSH
19437: DOUBLE
19438: LD_INT 1
19440: DEC
19441: ST_TO_ADDR
19442: LD_INT 3
19444: PUSH
19445: FOR_TO
19446: IFFALSE 19475
// AddResourceType ( base , i , sources [ i ] ) ;
19448: LD_VAR 0 15
19452: PPUSH
19453: LD_VAR 0 8
19457: PPUSH
19458: LD_VAR 0 5
19462: PUSH
19463: LD_VAR 0 8
19467: ARRAY
19468: PPUSH
19469: CALL_OW 276
19473: GO 19445
19475: POP
19476: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
19477: LD_ADDR_VAR 0 18
19481: PUSH
19482: LD_VAR 0 15
19486: PPUSH
19487: LD_VAR 0 2
19491: PPUSH
19492: LD_INT 1
19494: PPUSH
19495: CALL 18738 0 3
19499: ST_TO_ADDR
// InitHc ;
19500: CALL_OW 19
// InitUc ;
19504: CALL_OW 18
// uc_side := side ;
19508: LD_ADDR_OWVAR 20
19512: PUSH
19513: LD_VAR 0 16
19517: ST_TO_ADDR
// uc_nation := nation ;
19518: LD_ADDR_OWVAR 21
19522: PUSH
19523: LD_VAR 0 17
19527: ST_TO_ADDR
// if buildings then
19528: LD_VAR 0 18
19532: IFFALSE 20854
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
19534: LD_ADDR_VAR 0 19
19538: PUSH
19539: LD_VAR 0 18
19543: PPUSH
19544: LD_INT 2
19546: PUSH
19547: LD_INT 30
19549: PUSH
19550: LD_INT 29
19552: PUSH
19553: EMPTY
19554: LIST
19555: LIST
19556: PUSH
19557: LD_INT 30
19559: PUSH
19560: LD_INT 30
19562: PUSH
19563: EMPTY
19564: LIST
19565: LIST
19566: PUSH
19567: EMPTY
19568: LIST
19569: LIST
19570: LIST
19571: PPUSH
19572: CALL_OW 72
19576: ST_TO_ADDR
// if tmp then
19577: LD_VAR 0 19
19581: IFFALSE 19629
// for i in tmp do
19583: LD_ADDR_VAR 0 8
19587: PUSH
19588: LD_VAR 0 19
19592: PUSH
19593: FOR_IN
19594: IFFALSE 19627
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
19596: LD_VAR 0 8
19600: PPUSH
19601: CALL_OW 250
19605: PPUSH
19606: LD_VAR 0 8
19610: PPUSH
19611: CALL_OW 251
19615: PPUSH
19616: LD_VAR 0 16
19620: PPUSH
19621: CALL_OW 441
19625: GO 19593
19627: POP
19628: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
19629: LD_VAR 0 18
19633: PPUSH
19634: LD_INT 2
19636: PUSH
19637: LD_INT 30
19639: PUSH
19640: LD_INT 32
19642: PUSH
19643: EMPTY
19644: LIST
19645: LIST
19646: PUSH
19647: LD_INT 30
19649: PUSH
19650: LD_INT 33
19652: PUSH
19653: EMPTY
19654: LIST
19655: LIST
19656: PUSH
19657: EMPTY
19658: LIST
19659: LIST
19660: LIST
19661: PPUSH
19662: CALL_OW 72
19666: IFFALSE 19754
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
19668: LD_ADDR_VAR 0 8
19672: PUSH
19673: LD_VAR 0 18
19677: PPUSH
19678: LD_INT 2
19680: PUSH
19681: LD_INT 30
19683: PUSH
19684: LD_INT 32
19686: PUSH
19687: EMPTY
19688: LIST
19689: LIST
19690: PUSH
19691: LD_INT 30
19693: PUSH
19694: LD_INT 33
19696: PUSH
19697: EMPTY
19698: LIST
19699: LIST
19700: PUSH
19701: EMPTY
19702: LIST
19703: LIST
19704: LIST
19705: PPUSH
19706: CALL_OW 72
19710: PUSH
19711: FOR_IN
19712: IFFALSE 19752
// begin if not GetBWeapon ( i ) then
19714: LD_VAR 0 8
19718: PPUSH
19719: CALL_OW 269
19723: NOT
19724: IFFALSE 19750
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
19726: LD_VAR 0 8
19730: PPUSH
19731: LD_VAR 0 8
19735: PPUSH
19736: LD_VAR 0 2
19740: PPUSH
19741: CALL 21000 0 2
19745: PPUSH
19746: CALL_OW 431
// end ;
19750: GO 19711
19752: POP
19753: POP
// end ; for i = 1 to personel do
19754: LD_ADDR_VAR 0 8
19758: PUSH
19759: DOUBLE
19760: LD_INT 1
19762: DEC
19763: ST_TO_ADDR
19764: LD_VAR 0 6
19768: PUSH
19769: FOR_TO
19770: IFFALSE 20834
// begin if i > 4 then
19772: LD_VAR 0 8
19776: PUSH
19777: LD_INT 4
19779: GREATER
19780: IFFALSE 19784
// break ;
19782: GO 20834
// case i of 1 :
19784: LD_VAR 0 8
19788: PUSH
19789: LD_INT 1
19791: DOUBLE
19792: EQUAL
19793: IFTRUE 19797
19795: GO 19877
19797: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
19798: LD_ADDR_VAR 0 12
19802: PUSH
19803: LD_VAR 0 18
19807: PPUSH
19808: LD_INT 22
19810: PUSH
19811: LD_VAR 0 16
19815: PUSH
19816: EMPTY
19817: LIST
19818: LIST
19819: PUSH
19820: LD_INT 58
19822: PUSH
19823: EMPTY
19824: LIST
19825: PUSH
19826: LD_INT 2
19828: PUSH
19829: LD_INT 30
19831: PUSH
19832: LD_INT 32
19834: PUSH
19835: EMPTY
19836: LIST
19837: LIST
19838: PUSH
19839: LD_INT 30
19841: PUSH
19842: LD_INT 4
19844: PUSH
19845: EMPTY
19846: LIST
19847: LIST
19848: PUSH
19849: LD_INT 30
19851: PUSH
19852: LD_INT 5
19854: PUSH
19855: EMPTY
19856: LIST
19857: LIST
19858: PUSH
19859: EMPTY
19860: LIST
19861: LIST
19862: LIST
19863: LIST
19864: PUSH
19865: EMPTY
19866: LIST
19867: LIST
19868: LIST
19869: PPUSH
19870: CALL_OW 72
19874: ST_TO_ADDR
19875: GO 20099
19877: LD_INT 2
19879: DOUBLE
19880: EQUAL
19881: IFTRUE 19885
19883: GO 19947
19885: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
19886: LD_ADDR_VAR 0 12
19890: PUSH
19891: LD_VAR 0 18
19895: PPUSH
19896: LD_INT 22
19898: PUSH
19899: LD_VAR 0 16
19903: PUSH
19904: EMPTY
19905: LIST
19906: LIST
19907: PUSH
19908: LD_INT 2
19910: PUSH
19911: LD_INT 30
19913: PUSH
19914: LD_INT 0
19916: PUSH
19917: EMPTY
19918: LIST
19919: LIST
19920: PUSH
19921: LD_INT 30
19923: PUSH
19924: LD_INT 1
19926: PUSH
19927: EMPTY
19928: LIST
19929: LIST
19930: PUSH
19931: EMPTY
19932: LIST
19933: LIST
19934: LIST
19935: PUSH
19936: EMPTY
19937: LIST
19938: LIST
19939: PPUSH
19940: CALL_OW 72
19944: ST_TO_ADDR
19945: GO 20099
19947: LD_INT 3
19949: DOUBLE
19950: EQUAL
19951: IFTRUE 19955
19953: GO 20017
19955: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
19956: LD_ADDR_VAR 0 12
19960: PUSH
19961: LD_VAR 0 18
19965: PPUSH
19966: LD_INT 22
19968: PUSH
19969: LD_VAR 0 16
19973: PUSH
19974: EMPTY
19975: LIST
19976: LIST
19977: PUSH
19978: LD_INT 2
19980: PUSH
19981: LD_INT 30
19983: PUSH
19984: LD_INT 2
19986: PUSH
19987: EMPTY
19988: LIST
19989: LIST
19990: PUSH
19991: LD_INT 30
19993: PUSH
19994: LD_INT 3
19996: PUSH
19997: EMPTY
19998: LIST
19999: LIST
20000: PUSH
20001: EMPTY
20002: LIST
20003: LIST
20004: LIST
20005: PUSH
20006: EMPTY
20007: LIST
20008: LIST
20009: PPUSH
20010: CALL_OW 72
20014: ST_TO_ADDR
20015: GO 20099
20017: LD_INT 4
20019: DOUBLE
20020: EQUAL
20021: IFTRUE 20025
20023: GO 20098
20025: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
20026: LD_ADDR_VAR 0 12
20030: PUSH
20031: LD_VAR 0 18
20035: PPUSH
20036: LD_INT 22
20038: PUSH
20039: LD_VAR 0 16
20043: PUSH
20044: EMPTY
20045: LIST
20046: LIST
20047: PUSH
20048: LD_INT 2
20050: PUSH
20051: LD_INT 30
20053: PUSH
20054: LD_INT 6
20056: PUSH
20057: EMPTY
20058: LIST
20059: LIST
20060: PUSH
20061: LD_INT 30
20063: PUSH
20064: LD_INT 7
20066: PUSH
20067: EMPTY
20068: LIST
20069: LIST
20070: PUSH
20071: LD_INT 30
20073: PUSH
20074: LD_INT 8
20076: PUSH
20077: EMPTY
20078: LIST
20079: LIST
20080: PUSH
20081: EMPTY
20082: LIST
20083: LIST
20084: LIST
20085: LIST
20086: PUSH
20087: EMPTY
20088: LIST
20089: LIST
20090: PPUSH
20091: CALL_OW 72
20095: ST_TO_ADDR
20096: GO 20099
20098: POP
// if i = 1 then
20099: LD_VAR 0 8
20103: PUSH
20104: LD_INT 1
20106: EQUAL
20107: IFFALSE 20218
// begin tmp := [ ] ;
20109: LD_ADDR_VAR 0 19
20113: PUSH
20114: EMPTY
20115: ST_TO_ADDR
// for j in f do
20116: LD_ADDR_VAR 0 9
20120: PUSH
20121: LD_VAR 0 12
20125: PUSH
20126: FOR_IN
20127: IFFALSE 20200
// if GetBType ( j ) = b_bunker then
20129: LD_VAR 0 9
20133: PPUSH
20134: CALL_OW 266
20138: PUSH
20139: LD_INT 32
20141: EQUAL
20142: IFFALSE 20169
// tmp := Insert ( tmp , 1 , j ) else
20144: LD_ADDR_VAR 0 19
20148: PUSH
20149: LD_VAR 0 19
20153: PPUSH
20154: LD_INT 1
20156: PPUSH
20157: LD_VAR 0 9
20161: PPUSH
20162: CALL_OW 2
20166: ST_TO_ADDR
20167: GO 20198
// tmp := Insert ( tmp , tmp + 1 , j ) ;
20169: LD_ADDR_VAR 0 19
20173: PUSH
20174: LD_VAR 0 19
20178: PPUSH
20179: LD_VAR 0 19
20183: PUSH
20184: LD_INT 1
20186: PLUS
20187: PPUSH
20188: LD_VAR 0 9
20192: PPUSH
20193: CALL_OW 2
20197: ST_TO_ADDR
20198: GO 20126
20200: POP
20201: POP
// if tmp then
20202: LD_VAR 0 19
20206: IFFALSE 20218
// f := tmp ;
20208: LD_ADDR_VAR 0 12
20212: PUSH
20213: LD_VAR 0 19
20217: ST_TO_ADDR
// end ; x := personel [ i ] ;
20218: LD_ADDR_VAR 0 13
20222: PUSH
20223: LD_VAR 0 6
20227: PUSH
20228: LD_VAR 0 8
20232: ARRAY
20233: ST_TO_ADDR
// if x = - 1 then
20234: LD_VAR 0 13
20238: PUSH
20239: LD_INT 1
20241: NEG
20242: EQUAL
20243: IFFALSE 20452
// begin for j in f do
20245: LD_ADDR_VAR 0 9
20249: PUSH
20250: LD_VAR 0 12
20254: PUSH
20255: FOR_IN
20256: IFFALSE 20448
// repeat InitHc ;
20258: CALL_OW 19
// if GetBType ( j ) = b_barracks then
20262: LD_VAR 0 9
20266: PPUSH
20267: CALL_OW 266
20271: PUSH
20272: LD_INT 5
20274: EQUAL
20275: IFFALSE 20345
// begin if UnitsInside ( j ) < 3 then
20277: LD_VAR 0 9
20281: PPUSH
20282: CALL_OW 313
20286: PUSH
20287: LD_INT 3
20289: LESS
20290: IFFALSE 20326
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
20292: LD_INT 0
20294: PPUSH
20295: LD_INT 5
20297: PUSH
20298: LD_INT 8
20300: PUSH
20301: LD_INT 9
20303: PUSH
20304: EMPTY
20305: LIST
20306: LIST
20307: LIST
20308: PUSH
20309: LD_VAR 0 17
20313: ARRAY
20314: PPUSH
20315: LD_VAR 0 4
20319: PPUSH
20320: CALL_OW 380
20324: GO 20343
// PrepareHuman ( false , i , skill ) ;
20326: LD_INT 0
20328: PPUSH
20329: LD_VAR 0 8
20333: PPUSH
20334: LD_VAR 0 4
20338: PPUSH
20339: CALL_OW 380
// end else
20343: GO 20362
// PrepareHuman ( false , i , skill ) ;
20345: LD_INT 0
20347: PPUSH
20348: LD_VAR 0 8
20352: PPUSH
20353: LD_VAR 0 4
20357: PPUSH
20358: CALL_OW 380
// un := CreateHuman ;
20362: LD_ADDR_VAR 0 14
20366: PUSH
20367: CALL_OW 44
20371: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20372: LD_ADDR_VAR 0 7
20376: PUSH
20377: LD_VAR 0 7
20381: PPUSH
20382: LD_INT 1
20384: PPUSH
20385: LD_VAR 0 14
20389: PPUSH
20390: CALL_OW 2
20394: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
20395: LD_VAR 0 14
20399: PPUSH
20400: LD_VAR 0 9
20404: PPUSH
20405: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
20409: LD_VAR 0 9
20413: PPUSH
20414: CALL_OW 313
20418: PUSH
20419: LD_INT 6
20421: EQUAL
20422: PUSH
20423: LD_VAR 0 9
20427: PPUSH
20428: CALL_OW 266
20432: PUSH
20433: LD_INT 32
20435: PUSH
20436: LD_INT 31
20438: PUSH
20439: EMPTY
20440: LIST
20441: LIST
20442: IN
20443: OR
20444: IFFALSE 20258
20446: GO 20255
20448: POP
20449: POP
// end else
20450: GO 20832
// for j = 1 to x do
20452: LD_ADDR_VAR 0 9
20456: PUSH
20457: DOUBLE
20458: LD_INT 1
20460: DEC
20461: ST_TO_ADDR
20462: LD_VAR 0 13
20466: PUSH
20467: FOR_TO
20468: IFFALSE 20830
// begin InitHc ;
20470: CALL_OW 19
// if not f then
20474: LD_VAR 0 12
20478: NOT
20479: IFFALSE 20568
// begin PrepareHuman ( false , i , skill ) ;
20481: LD_INT 0
20483: PPUSH
20484: LD_VAR 0 8
20488: PPUSH
20489: LD_VAR 0 4
20493: PPUSH
20494: CALL_OW 380
// un := CreateHuman ;
20498: LD_ADDR_VAR 0 14
20502: PUSH
20503: CALL_OW 44
20507: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20508: LD_ADDR_VAR 0 7
20512: PUSH
20513: LD_VAR 0 7
20517: PPUSH
20518: LD_INT 1
20520: PPUSH
20521: LD_VAR 0 14
20525: PPUSH
20526: CALL_OW 2
20530: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
20531: LD_VAR 0 14
20535: PPUSH
20536: LD_VAR 0 1
20540: PPUSH
20541: CALL_OW 250
20545: PPUSH
20546: LD_VAR 0 1
20550: PPUSH
20551: CALL_OW 251
20555: PPUSH
20556: LD_INT 10
20558: PPUSH
20559: LD_INT 0
20561: PPUSH
20562: CALL_OW 50
// continue ;
20566: GO 20467
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
20568: LD_VAR 0 12
20572: PUSH
20573: LD_INT 1
20575: ARRAY
20576: PPUSH
20577: CALL_OW 313
20581: PUSH
20582: LD_VAR 0 12
20586: PUSH
20587: LD_INT 1
20589: ARRAY
20590: PPUSH
20591: CALL_OW 266
20595: PUSH
20596: LD_INT 32
20598: PUSH
20599: LD_INT 31
20601: PUSH
20602: EMPTY
20603: LIST
20604: LIST
20605: IN
20606: AND
20607: PUSH
20608: LD_VAR 0 12
20612: PUSH
20613: LD_INT 1
20615: ARRAY
20616: PPUSH
20617: CALL_OW 313
20621: PUSH
20622: LD_INT 6
20624: EQUAL
20625: OR
20626: IFFALSE 20646
// f := Delete ( f , 1 ) ;
20628: LD_ADDR_VAR 0 12
20632: PUSH
20633: LD_VAR 0 12
20637: PPUSH
20638: LD_INT 1
20640: PPUSH
20641: CALL_OW 3
20645: ST_TO_ADDR
// if not f then
20646: LD_VAR 0 12
20650: NOT
20651: IFFALSE 20669
// begin x := x + 2 ;
20653: LD_ADDR_VAR 0 13
20657: PUSH
20658: LD_VAR 0 13
20662: PUSH
20663: LD_INT 2
20665: PLUS
20666: ST_TO_ADDR
// continue ;
20667: GO 20467
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
20669: LD_VAR 0 12
20673: PUSH
20674: LD_INT 1
20676: ARRAY
20677: PPUSH
20678: CALL_OW 266
20682: PUSH
20683: LD_INT 5
20685: EQUAL
20686: IFFALSE 20760
// begin if UnitsInside ( f [ 1 ] ) < 3 then
20688: LD_VAR 0 12
20692: PUSH
20693: LD_INT 1
20695: ARRAY
20696: PPUSH
20697: CALL_OW 313
20701: PUSH
20702: LD_INT 3
20704: LESS
20705: IFFALSE 20741
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
20707: LD_INT 0
20709: PPUSH
20710: LD_INT 5
20712: PUSH
20713: LD_INT 8
20715: PUSH
20716: LD_INT 9
20718: PUSH
20719: EMPTY
20720: LIST
20721: LIST
20722: LIST
20723: PUSH
20724: LD_VAR 0 17
20728: ARRAY
20729: PPUSH
20730: LD_VAR 0 4
20734: PPUSH
20735: CALL_OW 380
20739: GO 20758
// PrepareHuman ( false , i , skill ) ;
20741: LD_INT 0
20743: PPUSH
20744: LD_VAR 0 8
20748: PPUSH
20749: LD_VAR 0 4
20753: PPUSH
20754: CALL_OW 380
// end else
20758: GO 20777
// PrepareHuman ( false , i , skill ) ;
20760: LD_INT 0
20762: PPUSH
20763: LD_VAR 0 8
20767: PPUSH
20768: LD_VAR 0 4
20772: PPUSH
20773: CALL_OW 380
// un := CreateHuman ;
20777: LD_ADDR_VAR 0 14
20781: PUSH
20782: CALL_OW 44
20786: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20787: LD_ADDR_VAR 0 7
20791: PUSH
20792: LD_VAR 0 7
20796: PPUSH
20797: LD_INT 1
20799: PPUSH
20800: LD_VAR 0 14
20804: PPUSH
20805: CALL_OW 2
20809: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
20810: LD_VAR 0 14
20814: PPUSH
20815: LD_VAR 0 12
20819: PUSH
20820: LD_INT 1
20822: ARRAY
20823: PPUSH
20824: CALL_OW 52
// end ;
20828: GO 20467
20830: POP
20831: POP
// end ;
20832: GO 19769
20834: POP
20835: POP
// result := result ^ buildings ;
20836: LD_ADDR_VAR 0 7
20840: PUSH
20841: LD_VAR 0 7
20845: PUSH
20846: LD_VAR 0 18
20850: ADD
20851: ST_TO_ADDR
// end else
20852: GO 20995
// begin for i = 1 to personel do
20854: LD_ADDR_VAR 0 8
20858: PUSH
20859: DOUBLE
20860: LD_INT 1
20862: DEC
20863: ST_TO_ADDR
20864: LD_VAR 0 6
20868: PUSH
20869: FOR_TO
20870: IFFALSE 20993
// begin if i > 4 then
20872: LD_VAR 0 8
20876: PUSH
20877: LD_INT 4
20879: GREATER
20880: IFFALSE 20884
// break ;
20882: GO 20993
// x := personel [ i ] ;
20884: LD_ADDR_VAR 0 13
20888: PUSH
20889: LD_VAR 0 6
20893: PUSH
20894: LD_VAR 0 8
20898: ARRAY
20899: ST_TO_ADDR
// if x = - 1 then
20900: LD_VAR 0 13
20904: PUSH
20905: LD_INT 1
20907: NEG
20908: EQUAL
20909: IFFALSE 20913
// continue ;
20911: GO 20869
// PrepareHuman ( false , i , skill ) ;
20913: LD_INT 0
20915: PPUSH
20916: LD_VAR 0 8
20920: PPUSH
20921: LD_VAR 0 4
20925: PPUSH
20926: CALL_OW 380
// un := CreateHuman ;
20930: LD_ADDR_VAR 0 14
20934: PUSH
20935: CALL_OW 44
20939: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
20940: LD_VAR 0 14
20944: PPUSH
20945: LD_VAR 0 1
20949: PPUSH
20950: CALL_OW 250
20954: PPUSH
20955: LD_VAR 0 1
20959: PPUSH
20960: CALL_OW 251
20964: PPUSH
20965: LD_INT 10
20967: PPUSH
20968: LD_INT 0
20970: PPUSH
20971: CALL_OW 50
// result := result ^ un ;
20975: LD_ADDR_VAR 0 7
20979: PUSH
20980: LD_VAR 0 7
20984: PUSH
20985: LD_VAR 0 14
20989: ADD
20990: ST_TO_ADDR
// end ;
20991: GO 20869
20993: POP
20994: POP
// end ; end ;
20995: LD_VAR 0 7
20999: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
21000: LD_INT 0
21002: PPUSH
21003: PPUSH
21004: PPUSH
21005: PPUSH
21006: PPUSH
21007: PPUSH
21008: PPUSH
21009: PPUSH
21010: PPUSH
21011: PPUSH
21012: PPUSH
21013: PPUSH
21014: PPUSH
21015: PPUSH
21016: PPUSH
21017: PPUSH
// result := false ;
21018: LD_ADDR_VAR 0 3
21022: PUSH
21023: LD_INT 0
21025: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
21026: LD_VAR 0 1
21030: NOT
21031: PUSH
21032: LD_VAR 0 1
21036: PPUSH
21037: CALL_OW 266
21041: PUSH
21042: LD_INT 32
21044: PUSH
21045: LD_INT 33
21047: PUSH
21048: EMPTY
21049: LIST
21050: LIST
21051: IN
21052: NOT
21053: OR
21054: IFFALSE 21058
// exit ;
21056: GO 22167
// nat := GetNation ( tower ) ;
21058: LD_ADDR_VAR 0 12
21062: PUSH
21063: LD_VAR 0 1
21067: PPUSH
21068: CALL_OW 248
21072: ST_TO_ADDR
// side := GetSide ( tower ) ;
21073: LD_ADDR_VAR 0 16
21077: PUSH
21078: LD_VAR 0 1
21082: PPUSH
21083: CALL_OW 255
21087: ST_TO_ADDR
// x := GetX ( tower ) ;
21088: LD_ADDR_VAR 0 10
21092: PUSH
21093: LD_VAR 0 1
21097: PPUSH
21098: CALL_OW 250
21102: ST_TO_ADDR
// y := GetY ( tower ) ;
21103: LD_ADDR_VAR 0 11
21107: PUSH
21108: LD_VAR 0 1
21112: PPUSH
21113: CALL_OW 251
21117: ST_TO_ADDR
// if not x or not y then
21118: LD_VAR 0 10
21122: NOT
21123: PUSH
21124: LD_VAR 0 11
21128: NOT
21129: OR
21130: IFFALSE 21134
// exit ;
21132: GO 22167
// weapon := 0 ;
21134: LD_ADDR_VAR 0 18
21138: PUSH
21139: LD_INT 0
21141: ST_TO_ADDR
// fac_list := [ ] ;
21142: LD_ADDR_VAR 0 17
21146: PUSH
21147: EMPTY
21148: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
21149: LD_ADDR_VAR 0 6
21153: PUSH
21154: LD_VAR 0 1
21158: PPUSH
21159: CALL_OW 274
21163: PPUSH
21164: LD_VAR 0 2
21168: PPUSH
21169: LD_INT 0
21171: PPUSH
21172: CALL 18738 0 3
21176: PPUSH
21177: LD_INT 30
21179: PUSH
21180: LD_INT 3
21182: PUSH
21183: EMPTY
21184: LIST
21185: LIST
21186: PPUSH
21187: CALL_OW 72
21191: ST_TO_ADDR
// if not factories then
21192: LD_VAR 0 6
21196: NOT
21197: IFFALSE 21201
// exit ;
21199: GO 22167
// for i in factories do
21201: LD_ADDR_VAR 0 8
21205: PUSH
21206: LD_VAR 0 6
21210: PUSH
21211: FOR_IN
21212: IFFALSE 21237
// fac_list := fac_list union AvailableWeaponList ( i ) ;
21214: LD_ADDR_VAR 0 17
21218: PUSH
21219: LD_VAR 0 17
21223: PUSH
21224: LD_VAR 0 8
21228: PPUSH
21229: CALL_OW 478
21233: UNION
21234: ST_TO_ADDR
21235: GO 21211
21237: POP
21238: POP
// if not fac_list then
21239: LD_VAR 0 17
21243: NOT
21244: IFFALSE 21248
// exit ;
21246: GO 22167
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
21248: LD_ADDR_VAR 0 5
21252: PUSH
21253: LD_INT 4
21255: PUSH
21256: LD_INT 5
21258: PUSH
21259: LD_INT 9
21261: PUSH
21262: LD_INT 10
21264: PUSH
21265: LD_INT 6
21267: PUSH
21268: LD_INT 7
21270: PUSH
21271: LD_INT 11
21273: PUSH
21274: EMPTY
21275: LIST
21276: LIST
21277: LIST
21278: LIST
21279: LIST
21280: LIST
21281: LIST
21282: PUSH
21283: LD_INT 27
21285: PUSH
21286: LD_INT 28
21288: PUSH
21289: LD_INT 26
21291: PUSH
21292: LD_INT 30
21294: PUSH
21295: EMPTY
21296: LIST
21297: LIST
21298: LIST
21299: LIST
21300: PUSH
21301: LD_INT 43
21303: PUSH
21304: LD_INT 44
21306: PUSH
21307: LD_INT 46
21309: PUSH
21310: LD_INT 45
21312: PUSH
21313: LD_INT 47
21315: PUSH
21316: LD_INT 49
21318: PUSH
21319: EMPTY
21320: LIST
21321: LIST
21322: LIST
21323: LIST
21324: LIST
21325: LIST
21326: PUSH
21327: EMPTY
21328: LIST
21329: LIST
21330: LIST
21331: PUSH
21332: LD_VAR 0 12
21336: ARRAY
21337: ST_TO_ADDR
// list := list isect fac_list ;
21338: LD_ADDR_VAR 0 5
21342: PUSH
21343: LD_VAR 0 5
21347: PUSH
21348: LD_VAR 0 17
21352: ISECT
21353: ST_TO_ADDR
// if not list then
21354: LD_VAR 0 5
21358: NOT
21359: IFFALSE 21363
// exit ;
21361: GO 22167
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
21363: LD_VAR 0 12
21367: PUSH
21368: LD_INT 3
21370: EQUAL
21371: PUSH
21372: LD_INT 49
21374: PUSH
21375: LD_VAR 0 5
21379: IN
21380: AND
21381: PUSH
21382: LD_INT 31
21384: PPUSH
21385: LD_VAR 0 16
21389: PPUSH
21390: CALL_OW 321
21394: PUSH
21395: LD_INT 2
21397: EQUAL
21398: AND
21399: IFFALSE 21459
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
21401: LD_INT 22
21403: PUSH
21404: LD_VAR 0 16
21408: PUSH
21409: EMPTY
21410: LIST
21411: LIST
21412: PUSH
21413: LD_INT 35
21415: PUSH
21416: LD_INT 49
21418: PUSH
21419: EMPTY
21420: LIST
21421: LIST
21422: PUSH
21423: LD_INT 91
21425: PUSH
21426: LD_VAR 0 1
21430: PUSH
21431: LD_INT 10
21433: PUSH
21434: EMPTY
21435: LIST
21436: LIST
21437: LIST
21438: PUSH
21439: EMPTY
21440: LIST
21441: LIST
21442: LIST
21443: PPUSH
21444: CALL_OW 69
21448: NOT
21449: IFFALSE 21459
// weapon := ru_time_lapser ;
21451: LD_ADDR_VAR 0 18
21455: PUSH
21456: LD_INT 49
21458: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
21459: LD_VAR 0 12
21463: PUSH
21464: LD_INT 1
21466: PUSH
21467: LD_INT 2
21469: PUSH
21470: EMPTY
21471: LIST
21472: LIST
21473: IN
21474: PUSH
21475: LD_INT 11
21477: PUSH
21478: LD_VAR 0 5
21482: IN
21483: PUSH
21484: LD_INT 30
21486: PUSH
21487: LD_VAR 0 5
21491: IN
21492: OR
21493: AND
21494: PUSH
21495: LD_INT 6
21497: PPUSH
21498: LD_VAR 0 16
21502: PPUSH
21503: CALL_OW 321
21507: PUSH
21508: LD_INT 2
21510: EQUAL
21511: AND
21512: IFFALSE 21677
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
21514: LD_INT 22
21516: PUSH
21517: LD_VAR 0 16
21521: PUSH
21522: EMPTY
21523: LIST
21524: LIST
21525: PUSH
21526: LD_INT 2
21528: PUSH
21529: LD_INT 35
21531: PUSH
21532: LD_INT 11
21534: PUSH
21535: EMPTY
21536: LIST
21537: LIST
21538: PUSH
21539: LD_INT 35
21541: PUSH
21542: LD_INT 30
21544: PUSH
21545: EMPTY
21546: LIST
21547: LIST
21548: PUSH
21549: EMPTY
21550: LIST
21551: LIST
21552: LIST
21553: PUSH
21554: LD_INT 91
21556: PUSH
21557: LD_VAR 0 1
21561: PUSH
21562: LD_INT 18
21564: PUSH
21565: EMPTY
21566: LIST
21567: LIST
21568: LIST
21569: PUSH
21570: EMPTY
21571: LIST
21572: LIST
21573: LIST
21574: PPUSH
21575: CALL_OW 69
21579: NOT
21580: PUSH
21581: LD_INT 22
21583: PUSH
21584: LD_VAR 0 16
21588: PUSH
21589: EMPTY
21590: LIST
21591: LIST
21592: PUSH
21593: LD_INT 2
21595: PUSH
21596: LD_INT 30
21598: PUSH
21599: LD_INT 32
21601: PUSH
21602: EMPTY
21603: LIST
21604: LIST
21605: PUSH
21606: LD_INT 30
21608: PUSH
21609: LD_INT 33
21611: PUSH
21612: EMPTY
21613: LIST
21614: LIST
21615: PUSH
21616: EMPTY
21617: LIST
21618: LIST
21619: LIST
21620: PUSH
21621: LD_INT 91
21623: PUSH
21624: LD_VAR 0 1
21628: PUSH
21629: LD_INT 12
21631: PUSH
21632: EMPTY
21633: LIST
21634: LIST
21635: LIST
21636: PUSH
21637: EMPTY
21638: LIST
21639: LIST
21640: LIST
21641: PUSH
21642: EMPTY
21643: LIST
21644: PPUSH
21645: CALL_OW 69
21649: PUSH
21650: LD_INT 2
21652: GREATER
21653: AND
21654: IFFALSE 21677
// weapon := [ us_radar , ar_radar ] [ nat ] ;
21656: LD_ADDR_VAR 0 18
21660: PUSH
21661: LD_INT 11
21663: PUSH
21664: LD_INT 30
21666: PUSH
21667: EMPTY
21668: LIST
21669: LIST
21670: PUSH
21671: LD_VAR 0 12
21675: ARRAY
21676: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
21677: LD_VAR 0 18
21681: NOT
21682: PUSH
21683: LD_INT 40
21685: PPUSH
21686: LD_VAR 0 16
21690: PPUSH
21691: CALL_OW 321
21695: PUSH
21696: LD_INT 2
21698: EQUAL
21699: AND
21700: PUSH
21701: LD_INT 7
21703: PUSH
21704: LD_VAR 0 5
21708: IN
21709: PUSH
21710: LD_INT 28
21712: PUSH
21713: LD_VAR 0 5
21717: IN
21718: OR
21719: PUSH
21720: LD_INT 45
21722: PUSH
21723: LD_VAR 0 5
21727: IN
21728: OR
21729: AND
21730: IFFALSE 21984
// begin hex := GetHexInfo ( x , y ) ;
21732: LD_ADDR_VAR 0 4
21736: PUSH
21737: LD_VAR 0 10
21741: PPUSH
21742: LD_VAR 0 11
21746: PPUSH
21747: CALL_OW 546
21751: ST_TO_ADDR
// if hex [ 1 ] then
21752: LD_VAR 0 4
21756: PUSH
21757: LD_INT 1
21759: ARRAY
21760: IFFALSE 21764
// exit ;
21762: GO 22167
// height := hex [ 2 ] ;
21764: LD_ADDR_VAR 0 15
21768: PUSH
21769: LD_VAR 0 4
21773: PUSH
21774: LD_INT 2
21776: ARRAY
21777: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
21778: LD_ADDR_VAR 0 14
21782: PUSH
21783: LD_INT 0
21785: PUSH
21786: LD_INT 2
21788: PUSH
21789: LD_INT 3
21791: PUSH
21792: LD_INT 5
21794: PUSH
21795: EMPTY
21796: LIST
21797: LIST
21798: LIST
21799: LIST
21800: ST_TO_ADDR
// for i in tmp do
21801: LD_ADDR_VAR 0 8
21805: PUSH
21806: LD_VAR 0 14
21810: PUSH
21811: FOR_IN
21812: IFFALSE 21982
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
21814: LD_ADDR_VAR 0 9
21818: PUSH
21819: LD_VAR 0 10
21823: PPUSH
21824: LD_VAR 0 8
21828: PPUSH
21829: LD_INT 5
21831: PPUSH
21832: CALL_OW 272
21836: PUSH
21837: LD_VAR 0 11
21841: PPUSH
21842: LD_VAR 0 8
21846: PPUSH
21847: LD_INT 5
21849: PPUSH
21850: CALL_OW 273
21854: PUSH
21855: EMPTY
21856: LIST
21857: LIST
21858: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
21859: LD_VAR 0 9
21863: PUSH
21864: LD_INT 1
21866: ARRAY
21867: PPUSH
21868: LD_VAR 0 9
21872: PUSH
21873: LD_INT 2
21875: ARRAY
21876: PPUSH
21877: CALL_OW 488
21881: IFFALSE 21980
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
21883: LD_ADDR_VAR 0 4
21887: PUSH
21888: LD_VAR 0 9
21892: PUSH
21893: LD_INT 1
21895: ARRAY
21896: PPUSH
21897: LD_VAR 0 9
21901: PUSH
21902: LD_INT 2
21904: ARRAY
21905: PPUSH
21906: CALL_OW 546
21910: ST_TO_ADDR
// if hex [ 1 ] then
21911: LD_VAR 0 4
21915: PUSH
21916: LD_INT 1
21918: ARRAY
21919: IFFALSE 21923
// continue ;
21921: GO 21811
// h := hex [ 2 ] ;
21923: LD_ADDR_VAR 0 13
21927: PUSH
21928: LD_VAR 0 4
21932: PUSH
21933: LD_INT 2
21935: ARRAY
21936: ST_TO_ADDR
// if h + 7 < height then
21937: LD_VAR 0 13
21941: PUSH
21942: LD_INT 7
21944: PLUS
21945: PUSH
21946: LD_VAR 0 15
21950: LESS
21951: IFFALSE 21980
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
21953: LD_ADDR_VAR 0 18
21957: PUSH
21958: LD_INT 7
21960: PUSH
21961: LD_INT 28
21963: PUSH
21964: LD_INT 45
21966: PUSH
21967: EMPTY
21968: LIST
21969: LIST
21970: LIST
21971: PUSH
21972: LD_VAR 0 12
21976: ARRAY
21977: ST_TO_ADDR
// break ;
21978: GO 21982
// end ; end ; end ;
21980: GO 21811
21982: POP
21983: POP
// end ; if not weapon then
21984: LD_VAR 0 18
21988: NOT
21989: IFFALSE 22049
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
21991: LD_ADDR_VAR 0 5
21995: PUSH
21996: LD_VAR 0 5
22000: PUSH
22001: LD_INT 11
22003: PUSH
22004: LD_INT 30
22006: PUSH
22007: LD_INT 49
22009: PUSH
22010: EMPTY
22011: LIST
22012: LIST
22013: LIST
22014: DIFF
22015: ST_TO_ADDR
// if not list then
22016: LD_VAR 0 5
22020: NOT
22021: IFFALSE 22025
// exit ;
22023: GO 22167
// weapon := list [ rand ( 1 , list ) ] ;
22025: LD_ADDR_VAR 0 18
22029: PUSH
22030: LD_VAR 0 5
22034: PUSH
22035: LD_INT 1
22037: PPUSH
22038: LD_VAR 0 5
22042: PPUSH
22043: CALL_OW 12
22047: ARRAY
22048: ST_TO_ADDR
// end ; if weapon then
22049: LD_VAR 0 18
22053: IFFALSE 22167
// begin tmp := CostOfWeapon ( weapon ) ;
22055: LD_ADDR_VAR 0 14
22059: PUSH
22060: LD_VAR 0 18
22064: PPUSH
22065: CALL_OW 451
22069: ST_TO_ADDR
// j := GetBase ( tower ) ;
22070: LD_ADDR_VAR 0 9
22074: PUSH
22075: LD_VAR 0 1
22079: PPUSH
22080: CALL_OW 274
22084: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
22085: LD_VAR 0 9
22089: PPUSH
22090: LD_INT 1
22092: PPUSH
22093: CALL_OW 275
22097: PUSH
22098: LD_VAR 0 14
22102: PUSH
22103: LD_INT 1
22105: ARRAY
22106: GREATEREQUAL
22107: PUSH
22108: LD_VAR 0 9
22112: PPUSH
22113: LD_INT 2
22115: PPUSH
22116: CALL_OW 275
22120: PUSH
22121: LD_VAR 0 14
22125: PUSH
22126: LD_INT 2
22128: ARRAY
22129: GREATEREQUAL
22130: AND
22131: PUSH
22132: LD_VAR 0 9
22136: PPUSH
22137: LD_INT 3
22139: PPUSH
22140: CALL_OW 275
22144: PUSH
22145: LD_VAR 0 14
22149: PUSH
22150: LD_INT 3
22152: ARRAY
22153: GREATEREQUAL
22154: AND
22155: IFFALSE 22167
// result := weapon ;
22157: LD_ADDR_VAR 0 3
22161: PUSH
22162: LD_VAR 0 18
22166: ST_TO_ADDR
// end ; end ;
22167: LD_VAR 0 3
22171: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
22172: LD_INT 0
22174: PPUSH
22175: PPUSH
// result := true ;
22176: LD_ADDR_VAR 0 3
22180: PUSH
22181: LD_INT 1
22183: ST_TO_ADDR
// if array1 = array2 then
22184: LD_VAR 0 1
22188: PUSH
22189: LD_VAR 0 2
22193: EQUAL
22194: IFFALSE 22254
// begin for i = 1 to array1 do
22196: LD_ADDR_VAR 0 4
22200: PUSH
22201: DOUBLE
22202: LD_INT 1
22204: DEC
22205: ST_TO_ADDR
22206: LD_VAR 0 1
22210: PUSH
22211: FOR_TO
22212: IFFALSE 22250
// if array1 [ i ] <> array2 [ i ] then
22214: LD_VAR 0 1
22218: PUSH
22219: LD_VAR 0 4
22223: ARRAY
22224: PUSH
22225: LD_VAR 0 2
22229: PUSH
22230: LD_VAR 0 4
22234: ARRAY
22235: NONEQUAL
22236: IFFALSE 22248
// begin result := false ;
22238: LD_ADDR_VAR 0 3
22242: PUSH
22243: LD_INT 0
22245: ST_TO_ADDR
// break ;
22246: GO 22250
// end ;
22248: GO 22211
22250: POP
22251: POP
// end else
22252: GO 22262
// result := false ;
22254: LD_ADDR_VAR 0 3
22258: PUSH
22259: LD_INT 0
22261: ST_TO_ADDR
// end ;
22262: LD_VAR 0 3
22266: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
22267: LD_INT 0
22269: PPUSH
22270: PPUSH
// if not array1 or not array2 then
22271: LD_VAR 0 1
22275: NOT
22276: PUSH
22277: LD_VAR 0 2
22281: NOT
22282: OR
22283: IFFALSE 22287
// exit ;
22285: GO 22351
// result := true ;
22287: LD_ADDR_VAR 0 3
22291: PUSH
22292: LD_INT 1
22294: ST_TO_ADDR
// for i = 1 to array1 do
22295: LD_ADDR_VAR 0 4
22299: PUSH
22300: DOUBLE
22301: LD_INT 1
22303: DEC
22304: ST_TO_ADDR
22305: LD_VAR 0 1
22309: PUSH
22310: FOR_TO
22311: IFFALSE 22349
// if array1 [ i ] <> array2 [ i ] then
22313: LD_VAR 0 1
22317: PUSH
22318: LD_VAR 0 4
22322: ARRAY
22323: PUSH
22324: LD_VAR 0 2
22328: PUSH
22329: LD_VAR 0 4
22333: ARRAY
22334: NONEQUAL
22335: IFFALSE 22347
// begin result := false ;
22337: LD_ADDR_VAR 0 3
22341: PUSH
22342: LD_INT 0
22344: ST_TO_ADDR
// break ;
22345: GO 22349
// end ;
22347: GO 22310
22349: POP
22350: POP
// end ;
22351: LD_VAR 0 3
22355: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
22356: LD_INT 0
22358: PPUSH
22359: PPUSH
22360: PPUSH
// pom := GetBase ( fac ) ;
22361: LD_ADDR_VAR 0 5
22365: PUSH
22366: LD_VAR 0 1
22370: PPUSH
22371: CALL_OW 274
22375: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
22376: LD_ADDR_VAR 0 4
22380: PUSH
22381: LD_VAR 0 2
22385: PUSH
22386: LD_INT 1
22388: ARRAY
22389: PPUSH
22390: LD_VAR 0 2
22394: PUSH
22395: LD_INT 2
22397: ARRAY
22398: PPUSH
22399: LD_VAR 0 2
22403: PUSH
22404: LD_INT 3
22406: ARRAY
22407: PPUSH
22408: LD_VAR 0 2
22412: PUSH
22413: LD_INT 4
22415: ARRAY
22416: PPUSH
22417: CALL_OW 449
22421: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22422: LD_ADDR_VAR 0 3
22426: PUSH
22427: LD_VAR 0 5
22431: PPUSH
22432: LD_INT 1
22434: PPUSH
22435: CALL_OW 275
22439: PUSH
22440: LD_VAR 0 4
22444: PUSH
22445: LD_INT 1
22447: ARRAY
22448: GREATEREQUAL
22449: PUSH
22450: LD_VAR 0 5
22454: PPUSH
22455: LD_INT 2
22457: PPUSH
22458: CALL_OW 275
22462: PUSH
22463: LD_VAR 0 4
22467: PUSH
22468: LD_INT 2
22470: ARRAY
22471: GREATEREQUAL
22472: AND
22473: PUSH
22474: LD_VAR 0 5
22478: PPUSH
22479: LD_INT 3
22481: PPUSH
22482: CALL_OW 275
22486: PUSH
22487: LD_VAR 0 4
22491: PUSH
22492: LD_INT 3
22494: ARRAY
22495: GREATEREQUAL
22496: AND
22497: ST_TO_ADDR
// end ;
22498: LD_VAR 0 3
22502: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
22503: LD_INT 0
22505: PPUSH
22506: PPUSH
22507: PPUSH
22508: PPUSH
// pom := GetBase ( building ) ;
22509: LD_ADDR_VAR 0 3
22513: PUSH
22514: LD_VAR 0 1
22518: PPUSH
22519: CALL_OW 274
22523: ST_TO_ADDR
// if not pom then
22524: LD_VAR 0 3
22528: NOT
22529: IFFALSE 22533
// exit ;
22531: GO 22703
// btype := GetBType ( building ) ;
22533: LD_ADDR_VAR 0 5
22537: PUSH
22538: LD_VAR 0 1
22542: PPUSH
22543: CALL_OW 266
22547: ST_TO_ADDR
// if btype = b_armoury then
22548: LD_VAR 0 5
22552: PUSH
22553: LD_INT 4
22555: EQUAL
22556: IFFALSE 22566
// btype := b_barracks ;
22558: LD_ADDR_VAR 0 5
22562: PUSH
22563: LD_INT 5
22565: ST_TO_ADDR
// if btype = b_depot then
22566: LD_VAR 0 5
22570: PUSH
22571: LD_INT 0
22573: EQUAL
22574: IFFALSE 22584
// btype := b_warehouse ;
22576: LD_ADDR_VAR 0 5
22580: PUSH
22581: LD_INT 1
22583: ST_TO_ADDR
// if btype = b_workshop then
22584: LD_VAR 0 5
22588: PUSH
22589: LD_INT 2
22591: EQUAL
22592: IFFALSE 22602
// btype := b_factory ;
22594: LD_ADDR_VAR 0 5
22598: PUSH
22599: LD_INT 3
22601: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
22602: LD_ADDR_VAR 0 4
22606: PUSH
22607: LD_VAR 0 5
22611: PPUSH
22612: LD_VAR 0 1
22616: PPUSH
22617: CALL_OW 248
22621: PPUSH
22622: CALL_OW 450
22626: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22627: LD_ADDR_VAR 0 2
22631: PUSH
22632: LD_VAR 0 3
22636: PPUSH
22637: LD_INT 1
22639: PPUSH
22640: CALL_OW 275
22644: PUSH
22645: LD_VAR 0 4
22649: PUSH
22650: LD_INT 1
22652: ARRAY
22653: GREATEREQUAL
22654: PUSH
22655: LD_VAR 0 3
22659: PPUSH
22660: LD_INT 2
22662: PPUSH
22663: CALL_OW 275
22667: PUSH
22668: LD_VAR 0 4
22672: PUSH
22673: LD_INT 2
22675: ARRAY
22676: GREATEREQUAL
22677: AND
22678: PUSH
22679: LD_VAR 0 3
22683: PPUSH
22684: LD_INT 3
22686: PPUSH
22687: CALL_OW 275
22691: PUSH
22692: LD_VAR 0 4
22696: PUSH
22697: LD_INT 3
22699: ARRAY
22700: GREATEREQUAL
22701: AND
22702: ST_TO_ADDR
// end ;
22703: LD_VAR 0 2
22707: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
22708: LD_INT 0
22710: PPUSH
22711: PPUSH
22712: PPUSH
// pom := GetBase ( building ) ;
22713: LD_ADDR_VAR 0 4
22717: PUSH
22718: LD_VAR 0 1
22722: PPUSH
22723: CALL_OW 274
22727: ST_TO_ADDR
// if not pom then
22728: LD_VAR 0 4
22732: NOT
22733: IFFALSE 22737
// exit ;
22735: GO 22838
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
22737: LD_ADDR_VAR 0 5
22741: PUSH
22742: LD_VAR 0 2
22746: PPUSH
22747: LD_VAR 0 1
22751: PPUSH
22752: CALL_OW 248
22756: PPUSH
22757: CALL_OW 450
22761: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22762: LD_ADDR_VAR 0 3
22766: PUSH
22767: LD_VAR 0 4
22771: PPUSH
22772: LD_INT 1
22774: PPUSH
22775: CALL_OW 275
22779: PUSH
22780: LD_VAR 0 5
22784: PUSH
22785: LD_INT 1
22787: ARRAY
22788: GREATEREQUAL
22789: PUSH
22790: LD_VAR 0 4
22794: PPUSH
22795: LD_INT 2
22797: PPUSH
22798: CALL_OW 275
22802: PUSH
22803: LD_VAR 0 5
22807: PUSH
22808: LD_INT 2
22810: ARRAY
22811: GREATEREQUAL
22812: AND
22813: PUSH
22814: LD_VAR 0 4
22818: PPUSH
22819: LD_INT 3
22821: PPUSH
22822: CALL_OW 275
22826: PUSH
22827: LD_VAR 0 5
22831: PUSH
22832: LD_INT 3
22834: ARRAY
22835: GREATEREQUAL
22836: AND
22837: ST_TO_ADDR
// end ;
22838: LD_VAR 0 3
22842: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
22843: LD_INT 0
22845: PPUSH
22846: PPUSH
22847: PPUSH
22848: PPUSH
22849: PPUSH
22850: PPUSH
22851: PPUSH
22852: PPUSH
22853: PPUSH
22854: PPUSH
22855: PPUSH
// result := false ;
22856: LD_ADDR_VAR 0 8
22860: PUSH
22861: LD_INT 0
22863: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
22864: LD_VAR 0 5
22868: NOT
22869: PUSH
22870: LD_VAR 0 1
22874: NOT
22875: OR
22876: PUSH
22877: LD_VAR 0 2
22881: NOT
22882: OR
22883: PUSH
22884: LD_VAR 0 3
22888: NOT
22889: OR
22890: IFFALSE 22894
// exit ;
22892: GO 23708
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
22894: LD_ADDR_VAR 0 14
22898: PUSH
22899: LD_VAR 0 1
22903: PPUSH
22904: LD_VAR 0 2
22908: PPUSH
22909: LD_VAR 0 3
22913: PPUSH
22914: LD_VAR 0 4
22918: PPUSH
22919: LD_VAR 0 5
22923: PUSH
22924: LD_INT 1
22926: ARRAY
22927: PPUSH
22928: CALL_OW 248
22932: PPUSH
22933: LD_INT 0
22935: PPUSH
22936: CALL 24945 0 6
22940: ST_TO_ADDR
// if not hexes then
22941: LD_VAR 0 14
22945: NOT
22946: IFFALSE 22950
// exit ;
22948: GO 23708
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
22950: LD_ADDR_VAR 0 17
22954: PUSH
22955: LD_VAR 0 5
22959: PPUSH
22960: LD_INT 22
22962: PUSH
22963: LD_VAR 0 13
22967: PPUSH
22968: CALL_OW 255
22972: PUSH
22973: EMPTY
22974: LIST
22975: LIST
22976: PUSH
22977: LD_INT 2
22979: PUSH
22980: LD_INT 30
22982: PUSH
22983: LD_INT 0
22985: PUSH
22986: EMPTY
22987: LIST
22988: LIST
22989: PUSH
22990: LD_INT 30
22992: PUSH
22993: LD_INT 1
22995: PUSH
22996: EMPTY
22997: LIST
22998: LIST
22999: PUSH
23000: EMPTY
23001: LIST
23002: LIST
23003: LIST
23004: PUSH
23005: EMPTY
23006: LIST
23007: LIST
23008: PPUSH
23009: CALL_OW 72
23013: ST_TO_ADDR
// for i = 1 to hexes do
23014: LD_ADDR_VAR 0 9
23018: PUSH
23019: DOUBLE
23020: LD_INT 1
23022: DEC
23023: ST_TO_ADDR
23024: LD_VAR 0 14
23028: PUSH
23029: FOR_TO
23030: IFFALSE 23706
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
23032: LD_ADDR_VAR 0 13
23036: PUSH
23037: LD_VAR 0 14
23041: PUSH
23042: LD_VAR 0 9
23046: ARRAY
23047: PUSH
23048: LD_INT 1
23050: ARRAY
23051: PPUSH
23052: LD_VAR 0 14
23056: PUSH
23057: LD_VAR 0 9
23061: ARRAY
23062: PUSH
23063: LD_INT 2
23065: ARRAY
23066: PPUSH
23067: CALL_OW 428
23071: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
23072: LD_VAR 0 14
23076: PUSH
23077: LD_VAR 0 9
23081: ARRAY
23082: PUSH
23083: LD_INT 1
23085: ARRAY
23086: PPUSH
23087: LD_VAR 0 14
23091: PUSH
23092: LD_VAR 0 9
23096: ARRAY
23097: PUSH
23098: LD_INT 2
23100: ARRAY
23101: PPUSH
23102: CALL_OW 351
23106: PUSH
23107: LD_VAR 0 14
23111: PUSH
23112: LD_VAR 0 9
23116: ARRAY
23117: PUSH
23118: LD_INT 1
23120: ARRAY
23121: PPUSH
23122: LD_VAR 0 14
23126: PUSH
23127: LD_VAR 0 9
23131: ARRAY
23132: PUSH
23133: LD_INT 2
23135: ARRAY
23136: PPUSH
23137: CALL_OW 488
23141: NOT
23142: OR
23143: PUSH
23144: LD_VAR 0 13
23148: PPUSH
23149: CALL_OW 247
23153: PUSH
23154: LD_INT 3
23156: EQUAL
23157: OR
23158: IFFALSE 23164
// exit ;
23160: POP
23161: POP
23162: GO 23708
// if not tmp then
23164: LD_VAR 0 13
23168: NOT
23169: IFFALSE 23173
// continue ;
23171: GO 23029
// result := true ;
23173: LD_ADDR_VAR 0 8
23177: PUSH
23178: LD_INT 1
23180: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
23181: LD_VAR 0 6
23185: PUSH
23186: LD_VAR 0 13
23190: PPUSH
23191: CALL_OW 247
23195: PUSH
23196: LD_INT 2
23198: EQUAL
23199: AND
23200: PUSH
23201: LD_VAR 0 13
23205: PPUSH
23206: CALL_OW 263
23210: PUSH
23211: LD_INT 1
23213: EQUAL
23214: AND
23215: IFFALSE 23379
// begin if IsDrivenBy ( tmp ) then
23217: LD_VAR 0 13
23221: PPUSH
23222: CALL_OW 311
23226: IFFALSE 23230
// continue ;
23228: GO 23029
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
23230: LD_VAR 0 6
23234: PPUSH
23235: LD_INT 3
23237: PUSH
23238: LD_INT 60
23240: PUSH
23241: EMPTY
23242: LIST
23243: PUSH
23244: EMPTY
23245: LIST
23246: LIST
23247: PUSH
23248: LD_INT 3
23250: PUSH
23251: LD_INT 55
23253: PUSH
23254: EMPTY
23255: LIST
23256: PUSH
23257: EMPTY
23258: LIST
23259: LIST
23260: PUSH
23261: EMPTY
23262: LIST
23263: LIST
23264: PPUSH
23265: CALL_OW 72
23269: IFFALSE 23377
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
23271: LD_ADDR_VAR 0 18
23275: PUSH
23276: LD_VAR 0 6
23280: PPUSH
23281: LD_INT 3
23283: PUSH
23284: LD_INT 60
23286: PUSH
23287: EMPTY
23288: LIST
23289: PUSH
23290: EMPTY
23291: LIST
23292: LIST
23293: PUSH
23294: LD_INT 3
23296: PUSH
23297: LD_INT 55
23299: PUSH
23300: EMPTY
23301: LIST
23302: PUSH
23303: EMPTY
23304: LIST
23305: LIST
23306: PUSH
23307: EMPTY
23308: LIST
23309: LIST
23310: PPUSH
23311: CALL_OW 72
23315: PUSH
23316: LD_INT 1
23318: ARRAY
23319: ST_TO_ADDR
// if IsInUnit ( driver ) then
23320: LD_VAR 0 18
23324: PPUSH
23325: CALL_OW 310
23329: IFFALSE 23340
// ComExit ( driver ) ;
23331: LD_VAR 0 18
23335: PPUSH
23336: CALL 48129 0 1
// AddComEnterUnit ( driver , tmp ) ;
23340: LD_VAR 0 18
23344: PPUSH
23345: LD_VAR 0 13
23349: PPUSH
23350: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
23354: LD_VAR 0 18
23358: PPUSH
23359: LD_VAR 0 7
23363: PPUSH
23364: CALL_OW 173
// AddComExitVehicle ( driver ) ;
23368: LD_VAR 0 18
23372: PPUSH
23373: CALL_OW 181
// end ; continue ;
23377: GO 23029
// end ; if not cleaners or not tmp in cleaners then
23379: LD_VAR 0 6
23383: NOT
23384: PUSH
23385: LD_VAR 0 13
23389: PUSH
23390: LD_VAR 0 6
23394: IN
23395: NOT
23396: OR
23397: IFFALSE 23704
// begin if dep then
23399: LD_VAR 0 17
23403: IFFALSE 23539
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
23405: LD_ADDR_VAR 0 16
23409: PUSH
23410: LD_VAR 0 17
23414: PUSH
23415: LD_INT 1
23417: ARRAY
23418: PPUSH
23419: CALL_OW 250
23423: PPUSH
23424: LD_VAR 0 17
23428: PUSH
23429: LD_INT 1
23431: ARRAY
23432: PPUSH
23433: CALL_OW 254
23437: PPUSH
23438: LD_INT 5
23440: PPUSH
23441: CALL_OW 272
23445: PUSH
23446: LD_VAR 0 17
23450: PUSH
23451: LD_INT 1
23453: ARRAY
23454: PPUSH
23455: CALL_OW 251
23459: PPUSH
23460: LD_VAR 0 17
23464: PUSH
23465: LD_INT 1
23467: ARRAY
23468: PPUSH
23469: CALL_OW 254
23473: PPUSH
23474: LD_INT 5
23476: PPUSH
23477: CALL_OW 273
23481: PUSH
23482: EMPTY
23483: LIST
23484: LIST
23485: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
23486: LD_VAR 0 16
23490: PUSH
23491: LD_INT 1
23493: ARRAY
23494: PPUSH
23495: LD_VAR 0 16
23499: PUSH
23500: LD_INT 2
23502: ARRAY
23503: PPUSH
23504: CALL_OW 488
23508: IFFALSE 23539
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
23510: LD_VAR 0 13
23514: PPUSH
23515: LD_VAR 0 16
23519: PUSH
23520: LD_INT 1
23522: ARRAY
23523: PPUSH
23524: LD_VAR 0 16
23528: PUSH
23529: LD_INT 2
23531: ARRAY
23532: PPUSH
23533: CALL_OW 111
// continue ;
23537: GO 23029
// end ; end ; r := GetDir ( tmp ) ;
23539: LD_ADDR_VAR 0 15
23543: PUSH
23544: LD_VAR 0 13
23548: PPUSH
23549: CALL_OW 254
23553: ST_TO_ADDR
// if r = 5 then
23554: LD_VAR 0 15
23558: PUSH
23559: LD_INT 5
23561: EQUAL
23562: IFFALSE 23572
// r := 0 ;
23564: LD_ADDR_VAR 0 15
23568: PUSH
23569: LD_INT 0
23571: ST_TO_ADDR
// for j = r to 5 do
23572: LD_ADDR_VAR 0 10
23576: PUSH
23577: DOUBLE
23578: LD_VAR 0 15
23582: DEC
23583: ST_TO_ADDR
23584: LD_INT 5
23586: PUSH
23587: FOR_TO
23588: IFFALSE 23702
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
23590: LD_ADDR_VAR 0 11
23594: PUSH
23595: LD_VAR 0 13
23599: PPUSH
23600: CALL_OW 250
23604: PPUSH
23605: LD_VAR 0 10
23609: PPUSH
23610: LD_INT 2
23612: PPUSH
23613: CALL_OW 272
23617: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
23618: LD_ADDR_VAR 0 12
23622: PUSH
23623: LD_VAR 0 13
23627: PPUSH
23628: CALL_OW 251
23632: PPUSH
23633: LD_VAR 0 10
23637: PPUSH
23638: LD_INT 2
23640: PPUSH
23641: CALL_OW 273
23645: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
23646: LD_VAR 0 11
23650: PPUSH
23651: LD_VAR 0 12
23655: PPUSH
23656: CALL_OW 488
23660: PUSH
23661: LD_VAR 0 11
23665: PPUSH
23666: LD_VAR 0 12
23670: PPUSH
23671: CALL_OW 428
23675: NOT
23676: AND
23677: IFFALSE 23700
// begin ComMoveXY ( tmp , _x , _y ) ;
23679: LD_VAR 0 13
23683: PPUSH
23684: LD_VAR 0 11
23688: PPUSH
23689: LD_VAR 0 12
23693: PPUSH
23694: CALL_OW 111
// break ;
23698: GO 23702
// end ; end ;
23700: GO 23587
23702: POP
23703: POP
// end ; end ;
23704: GO 23029
23706: POP
23707: POP
// end ;
23708: LD_VAR 0 8
23712: RET
// export function BuildingTechInvented ( side , btype ) ; begin
23713: LD_INT 0
23715: PPUSH
// result := true ;
23716: LD_ADDR_VAR 0 3
23720: PUSH
23721: LD_INT 1
23723: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
23724: LD_VAR 0 2
23728: PUSH
23729: LD_INT 24
23731: DOUBLE
23732: EQUAL
23733: IFTRUE 23743
23735: LD_INT 33
23737: DOUBLE
23738: EQUAL
23739: IFTRUE 23743
23741: GO 23768
23743: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
23744: LD_ADDR_VAR 0 3
23748: PUSH
23749: LD_INT 32
23751: PPUSH
23752: LD_VAR 0 1
23756: PPUSH
23757: CALL_OW 321
23761: PUSH
23762: LD_INT 2
23764: EQUAL
23765: ST_TO_ADDR
23766: GO 24088
23768: LD_INT 20
23770: DOUBLE
23771: EQUAL
23772: IFTRUE 23776
23774: GO 23801
23776: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
23777: LD_ADDR_VAR 0 3
23781: PUSH
23782: LD_INT 6
23784: PPUSH
23785: LD_VAR 0 1
23789: PPUSH
23790: CALL_OW 321
23794: PUSH
23795: LD_INT 2
23797: EQUAL
23798: ST_TO_ADDR
23799: GO 24088
23801: LD_INT 22
23803: DOUBLE
23804: EQUAL
23805: IFTRUE 23815
23807: LD_INT 36
23809: DOUBLE
23810: EQUAL
23811: IFTRUE 23815
23813: GO 23840
23815: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
23816: LD_ADDR_VAR 0 3
23820: PUSH
23821: LD_INT 15
23823: PPUSH
23824: LD_VAR 0 1
23828: PPUSH
23829: CALL_OW 321
23833: PUSH
23834: LD_INT 2
23836: EQUAL
23837: ST_TO_ADDR
23838: GO 24088
23840: LD_INT 30
23842: DOUBLE
23843: EQUAL
23844: IFTRUE 23848
23846: GO 23873
23848: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
23849: LD_ADDR_VAR 0 3
23853: PUSH
23854: LD_INT 20
23856: PPUSH
23857: LD_VAR 0 1
23861: PPUSH
23862: CALL_OW 321
23866: PUSH
23867: LD_INT 2
23869: EQUAL
23870: ST_TO_ADDR
23871: GO 24088
23873: LD_INT 28
23875: DOUBLE
23876: EQUAL
23877: IFTRUE 23887
23879: LD_INT 21
23881: DOUBLE
23882: EQUAL
23883: IFTRUE 23887
23885: GO 23912
23887: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
23888: LD_ADDR_VAR 0 3
23892: PUSH
23893: LD_INT 21
23895: PPUSH
23896: LD_VAR 0 1
23900: PPUSH
23901: CALL_OW 321
23905: PUSH
23906: LD_INT 2
23908: EQUAL
23909: ST_TO_ADDR
23910: GO 24088
23912: LD_INT 16
23914: DOUBLE
23915: EQUAL
23916: IFTRUE 23920
23918: GO 23947
23920: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
23921: LD_ADDR_VAR 0 3
23925: PUSH
23926: LD_EXP 79
23930: PPUSH
23931: LD_VAR 0 1
23935: PPUSH
23936: CALL_OW 321
23940: PUSH
23941: LD_INT 2
23943: EQUAL
23944: ST_TO_ADDR
23945: GO 24088
23947: LD_INT 19
23949: DOUBLE
23950: EQUAL
23951: IFTRUE 23961
23953: LD_INT 23
23955: DOUBLE
23956: EQUAL
23957: IFTRUE 23961
23959: GO 23988
23961: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
23962: LD_ADDR_VAR 0 3
23966: PUSH
23967: LD_EXP 78
23971: PPUSH
23972: LD_VAR 0 1
23976: PPUSH
23977: CALL_OW 321
23981: PUSH
23982: LD_INT 2
23984: EQUAL
23985: ST_TO_ADDR
23986: GO 24088
23988: LD_INT 17
23990: DOUBLE
23991: EQUAL
23992: IFTRUE 23996
23994: GO 24021
23996: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
23997: LD_ADDR_VAR 0 3
24001: PUSH
24002: LD_INT 39
24004: PPUSH
24005: LD_VAR 0 1
24009: PPUSH
24010: CALL_OW 321
24014: PUSH
24015: LD_INT 2
24017: EQUAL
24018: ST_TO_ADDR
24019: GO 24088
24021: LD_INT 18
24023: DOUBLE
24024: EQUAL
24025: IFTRUE 24029
24027: GO 24054
24029: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
24030: LD_ADDR_VAR 0 3
24034: PUSH
24035: LD_INT 40
24037: PPUSH
24038: LD_VAR 0 1
24042: PPUSH
24043: CALL_OW 321
24047: PUSH
24048: LD_INT 2
24050: EQUAL
24051: ST_TO_ADDR
24052: GO 24088
24054: LD_INT 27
24056: DOUBLE
24057: EQUAL
24058: IFTRUE 24062
24060: GO 24087
24062: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
24063: LD_ADDR_VAR 0 3
24067: PUSH
24068: LD_INT 35
24070: PPUSH
24071: LD_VAR 0 1
24075: PPUSH
24076: CALL_OW 321
24080: PUSH
24081: LD_INT 2
24083: EQUAL
24084: ST_TO_ADDR
24085: GO 24088
24087: POP
// end ;
24088: LD_VAR 0 3
24092: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
24093: LD_INT 0
24095: PPUSH
24096: PPUSH
24097: PPUSH
24098: PPUSH
24099: PPUSH
24100: PPUSH
24101: PPUSH
24102: PPUSH
24103: PPUSH
24104: PPUSH
24105: PPUSH
// result := false ;
24106: LD_ADDR_VAR 0 6
24110: PUSH
24111: LD_INT 0
24113: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
24114: LD_VAR 0 1
24118: NOT
24119: PUSH
24120: LD_VAR 0 1
24124: PPUSH
24125: CALL_OW 266
24129: PUSH
24130: LD_INT 0
24132: PUSH
24133: LD_INT 1
24135: PUSH
24136: EMPTY
24137: LIST
24138: LIST
24139: IN
24140: NOT
24141: OR
24142: PUSH
24143: LD_VAR 0 2
24147: NOT
24148: OR
24149: PUSH
24150: LD_VAR 0 5
24154: PUSH
24155: LD_INT 0
24157: PUSH
24158: LD_INT 1
24160: PUSH
24161: LD_INT 2
24163: PUSH
24164: LD_INT 3
24166: PUSH
24167: LD_INT 4
24169: PUSH
24170: LD_INT 5
24172: PUSH
24173: EMPTY
24174: LIST
24175: LIST
24176: LIST
24177: LIST
24178: LIST
24179: LIST
24180: IN
24181: NOT
24182: OR
24183: PUSH
24184: LD_VAR 0 3
24188: PPUSH
24189: LD_VAR 0 4
24193: PPUSH
24194: CALL_OW 488
24198: NOT
24199: OR
24200: IFFALSE 24204
// exit ;
24202: GO 24940
// side := GetSide ( depot ) ;
24204: LD_ADDR_VAR 0 9
24208: PUSH
24209: LD_VAR 0 1
24213: PPUSH
24214: CALL_OW 255
24218: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
24219: LD_VAR 0 9
24223: PPUSH
24224: LD_VAR 0 2
24228: PPUSH
24229: CALL 23713 0 2
24233: NOT
24234: IFFALSE 24238
// exit ;
24236: GO 24940
// pom := GetBase ( depot ) ;
24238: LD_ADDR_VAR 0 10
24242: PUSH
24243: LD_VAR 0 1
24247: PPUSH
24248: CALL_OW 274
24252: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
24253: LD_ADDR_VAR 0 11
24257: PUSH
24258: LD_VAR 0 2
24262: PPUSH
24263: LD_VAR 0 1
24267: PPUSH
24268: CALL_OW 248
24272: PPUSH
24273: CALL_OW 450
24277: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
24278: LD_VAR 0 10
24282: PPUSH
24283: LD_INT 1
24285: PPUSH
24286: CALL_OW 275
24290: PUSH
24291: LD_VAR 0 11
24295: PUSH
24296: LD_INT 1
24298: ARRAY
24299: GREATEREQUAL
24300: PUSH
24301: LD_VAR 0 10
24305: PPUSH
24306: LD_INT 2
24308: PPUSH
24309: CALL_OW 275
24313: PUSH
24314: LD_VAR 0 11
24318: PUSH
24319: LD_INT 2
24321: ARRAY
24322: GREATEREQUAL
24323: AND
24324: PUSH
24325: LD_VAR 0 10
24329: PPUSH
24330: LD_INT 3
24332: PPUSH
24333: CALL_OW 275
24337: PUSH
24338: LD_VAR 0 11
24342: PUSH
24343: LD_INT 3
24345: ARRAY
24346: GREATEREQUAL
24347: AND
24348: NOT
24349: IFFALSE 24353
// exit ;
24351: GO 24940
// if GetBType ( depot ) = b_depot then
24353: LD_VAR 0 1
24357: PPUSH
24358: CALL_OW 266
24362: PUSH
24363: LD_INT 0
24365: EQUAL
24366: IFFALSE 24378
// dist := 28 else
24368: LD_ADDR_VAR 0 14
24372: PUSH
24373: LD_INT 28
24375: ST_TO_ADDR
24376: GO 24386
// dist := 36 ;
24378: LD_ADDR_VAR 0 14
24382: PUSH
24383: LD_INT 36
24385: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
24386: LD_VAR 0 1
24390: PPUSH
24391: LD_VAR 0 3
24395: PPUSH
24396: LD_VAR 0 4
24400: PPUSH
24401: CALL_OW 297
24405: PUSH
24406: LD_VAR 0 14
24410: GREATER
24411: IFFALSE 24415
// exit ;
24413: GO 24940
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
24415: LD_ADDR_VAR 0 12
24419: PUSH
24420: LD_VAR 0 2
24424: PPUSH
24425: LD_VAR 0 3
24429: PPUSH
24430: LD_VAR 0 4
24434: PPUSH
24435: LD_VAR 0 5
24439: PPUSH
24440: LD_VAR 0 1
24444: PPUSH
24445: CALL_OW 248
24449: PPUSH
24450: LD_INT 0
24452: PPUSH
24453: CALL 24945 0 6
24457: ST_TO_ADDR
// if not hexes then
24458: LD_VAR 0 12
24462: NOT
24463: IFFALSE 24467
// exit ;
24465: GO 24940
// hex := GetHexInfo ( x , y ) ;
24467: LD_ADDR_VAR 0 15
24471: PUSH
24472: LD_VAR 0 3
24476: PPUSH
24477: LD_VAR 0 4
24481: PPUSH
24482: CALL_OW 546
24486: ST_TO_ADDR
// if hex [ 1 ] then
24487: LD_VAR 0 15
24491: PUSH
24492: LD_INT 1
24494: ARRAY
24495: IFFALSE 24499
// exit ;
24497: GO 24940
// height := hex [ 2 ] ;
24499: LD_ADDR_VAR 0 13
24503: PUSH
24504: LD_VAR 0 15
24508: PUSH
24509: LD_INT 2
24511: ARRAY
24512: ST_TO_ADDR
// for i = 1 to hexes do
24513: LD_ADDR_VAR 0 7
24517: PUSH
24518: DOUBLE
24519: LD_INT 1
24521: DEC
24522: ST_TO_ADDR
24523: LD_VAR 0 12
24527: PUSH
24528: FOR_TO
24529: IFFALSE 24859
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
24531: LD_VAR 0 12
24535: PUSH
24536: LD_VAR 0 7
24540: ARRAY
24541: PUSH
24542: LD_INT 1
24544: ARRAY
24545: PPUSH
24546: LD_VAR 0 12
24550: PUSH
24551: LD_VAR 0 7
24555: ARRAY
24556: PUSH
24557: LD_INT 2
24559: ARRAY
24560: PPUSH
24561: CALL_OW 488
24565: NOT
24566: PUSH
24567: LD_VAR 0 12
24571: PUSH
24572: LD_VAR 0 7
24576: ARRAY
24577: PUSH
24578: LD_INT 1
24580: ARRAY
24581: PPUSH
24582: LD_VAR 0 12
24586: PUSH
24587: LD_VAR 0 7
24591: ARRAY
24592: PUSH
24593: LD_INT 2
24595: ARRAY
24596: PPUSH
24597: CALL_OW 428
24601: PUSH
24602: LD_INT 0
24604: GREATER
24605: OR
24606: PUSH
24607: LD_VAR 0 12
24611: PUSH
24612: LD_VAR 0 7
24616: ARRAY
24617: PUSH
24618: LD_INT 1
24620: ARRAY
24621: PPUSH
24622: LD_VAR 0 12
24626: PUSH
24627: LD_VAR 0 7
24631: ARRAY
24632: PUSH
24633: LD_INT 2
24635: ARRAY
24636: PPUSH
24637: CALL_OW 351
24641: OR
24642: IFFALSE 24648
// exit ;
24644: POP
24645: POP
24646: GO 24940
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
24648: LD_ADDR_VAR 0 8
24652: PUSH
24653: LD_VAR 0 12
24657: PUSH
24658: LD_VAR 0 7
24662: ARRAY
24663: PUSH
24664: LD_INT 1
24666: ARRAY
24667: PPUSH
24668: LD_VAR 0 12
24672: PUSH
24673: LD_VAR 0 7
24677: ARRAY
24678: PUSH
24679: LD_INT 2
24681: ARRAY
24682: PPUSH
24683: CALL_OW 546
24687: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
24688: LD_VAR 0 8
24692: PUSH
24693: LD_INT 1
24695: ARRAY
24696: PUSH
24697: LD_VAR 0 8
24701: PUSH
24702: LD_INT 2
24704: ARRAY
24705: PUSH
24706: LD_VAR 0 13
24710: PUSH
24711: LD_INT 2
24713: PLUS
24714: GREATER
24715: OR
24716: PUSH
24717: LD_VAR 0 8
24721: PUSH
24722: LD_INT 2
24724: ARRAY
24725: PUSH
24726: LD_VAR 0 13
24730: PUSH
24731: LD_INT 2
24733: MINUS
24734: LESS
24735: OR
24736: PUSH
24737: LD_VAR 0 8
24741: PUSH
24742: LD_INT 3
24744: ARRAY
24745: PUSH
24746: LD_INT 0
24748: PUSH
24749: LD_INT 8
24751: PUSH
24752: LD_INT 9
24754: PUSH
24755: LD_INT 10
24757: PUSH
24758: LD_INT 11
24760: PUSH
24761: LD_INT 12
24763: PUSH
24764: LD_INT 13
24766: PUSH
24767: LD_INT 16
24769: PUSH
24770: LD_INT 17
24772: PUSH
24773: LD_INT 18
24775: PUSH
24776: LD_INT 19
24778: PUSH
24779: LD_INT 20
24781: PUSH
24782: LD_INT 21
24784: PUSH
24785: EMPTY
24786: LIST
24787: LIST
24788: LIST
24789: LIST
24790: LIST
24791: LIST
24792: LIST
24793: LIST
24794: LIST
24795: LIST
24796: LIST
24797: LIST
24798: LIST
24799: IN
24800: NOT
24801: OR
24802: PUSH
24803: LD_VAR 0 8
24807: PUSH
24808: LD_INT 5
24810: ARRAY
24811: NOT
24812: OR
24813: PUSH
24814: LD_VAR 0 8
24818: PUSH
24819: LD_INT 6
24821: ARRAY
24822: PUSH
24823: LD_INT 1
24825: PUSH
24826: LD_INT 2
24828: PUSH
24829: LD_INT 7
24831: PUSH
24832: LD_INT 9
24834: PUSH
24835: LD_INT 10
24837: PUSH
24838: LD_INT 11
24840: PUSH
24841: EMPTY
24842: LIST
24843: LIST
24844: LIST
24845: LIST
24846: LIST
24847: LIST
24848: IN
24849: NOT
24850: OR
24851: IFFALSE 24857
// exit ;
24853: POP
24854: POP
24855: GO 24940
// end ;
24857: GO 24528
24859: POP
24860: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
24861: LD_VAR 0 9
24865: PPUSH
24866: LD_VAR 0 3
24870: PPUSH
24871: LD_VAR 0 4
24875: PPUSH
24876: LD_INT 20
24878: PPUSH
24879: CALL 16886 0 4
24883: PUSH
24884: LD_INT 4
24886: ARRAY
24887: IFFALSE 24891
// exit ;
24889: GO 24940
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
24891: LD_VAR 0 2
24895: PUSH
24896: LD_INT 29
24898: PUSH
24899: LD_INT 30
24901: PUSH
24902: EMPTY
24903: LIST
24904: LIST
24905: IN
24906: PUSH
24907: LD_VAR 0 3
24911: PPUSH
24912: LD_VAR 0 4
24916: PPUSH
24917: LD_VAR 0 9
24921: PPUSH
24922: CALL_OW 440
24926: NOT
24927: AND
24928: IFFALSE 24932
// exit ;
24930: GO 24940
// result := true ;
24932: LD_ADDR_VAR 0 6
24936: PUSH
24937: LD_INT 1
24939: ST_TO_ADDR
// end ;
24940: LD_VAR 0 6
24944: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
24945: LD_INT 0
24947: PPUSH
24948: PPUSH
24949: PPUSH
24950: PPUSH
24951: PPUSH
24952: PPUSH
24953: PPUSH
24954: PPUSH
24955: PPUSH
24956: PPUSH
24957: PPUSH
24958: PPUSH
24959: PPUSH
24960: PPUSH
24961: PPUSH
24962: PPUSH
24963: PPUSH
24964: PPUSH
24965: PPUSH
24966: PPUSH
24967: PPUSH
24968: PPUSH
24969: PPUSH
24970: PPUSH
24971: PPUSH
24972: PPUSH
24973: PPUSH
24974: PPUSH
24975: PPUSH
24976: PPUSH
24977: PPUSH
24978: PPUSH
24979: PPUSH
24980: PPUSH
24981: PPUSH
24982: PPUSH
24983: PPUSH
24984: PPUSH
24985: PPUSH
24986: PPUSH
24987: PPUSH
24988: PPUSH
24989: PPUSH
24990: PPUSH
24991: PPUSH
24992: PPUSH
24993: PPUSH
24994: PPUSH
24995: PPUSH
24996: PPUSH
24997: PPUSH
24998: PPUSH
24999: PPUSH
25000: PPUSH
25001: PPUSH
25002: PPUSH
25003: PPUSH
25004: PPUSH
// result = [ ] ;
25005: LD_ADDR_VAR 0 7
25009: PUSH
25010: EMPTY
25011: ST_TO_ADDR
// temp_list = [ ] ;
25012: LD_ADDR_VAR 0 9
25016: PUSH
25017: EMPTY
25018: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
25019: LD_VAR 0 4
25023: PUSH
25024: LD_INT 0
25026: PUSH
25027: LD_INT 1
25029: PUSH
25030: LD_INT 2
25032: PUSH
25033: LD_INT 3
25035: PUSH
25036: LD_INT 4
25038: PUSH
25039: LD_INT 5
25041: PUSH
25042: EMPTY
25043: LIST
25044: LIST
25045: LIST
25046: LIST
25047: LIST
25048: LIST
25049: IN
25050: NOT
25051: PUSH
25052: LD_VAR 0 1
25056: PUSH
25057: LD_INT 0
25059: PUSH
25060: LD_INT 1
25062: PUSH
25063: EMPTY
25064: LIST
25065: LIST
25066: IN
25067: PUSH
25068: LD_VAR 0 5
25072: PUSH
25073: LD_INT 1
25075: PUSH
25076: LD_INT 2
25078: PUSH
25079: LD_INT 3
25081: PUSH
25082: EMPTY
25083: LIST
25084: LIST
25085: LIST
25086: IN
25087: NOT
25088: AND
25089: OR
25090: IFFALSE 25094
// exit ;
25092: GO 43485
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
25094: LD_VAR 0 1
25098: PUSH
25099: LD_INT 6
25101: PUSH
25102: LD_INT 7
25104: PUSH
25105: LD_INT 8
25107: PUSH
25108: LD_INT 13
25110: PUSH
25111: LD_INT 12
25113: PUSH
25114: LD_INT 15
25116: PUSH
25117: LD_INT 11
25119: PUSH
25120: LD_INT 14
25122: PUSH
25123: LD_INT 10
25125: PUSH
25126: EMPTY
25127: LIST
25128: LIST
25129: LIST
25130: LIST
25131: LIST
25132: LIST
25133: LIST
25134: LIST
25135: LIST
25136: IN
25137: IFFALSE 25147
// btype = b_lab ;
25139: LD_ADDR_VAR 0 1
25143: PUSH
25144: LD_INT 6
25146: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
25147: LD_VAR 0 6
25151: PUSH
25152: LD_INT 0
25154: PUSH
25155: LD_INT 1
25157: PUSH
25158: LD_INT 2
25160: PUSH
25161: EMPTY
25162: LIST
25163: LIST
25164: LIST
25165: IN
25166: NOT
25167: PUSH
25168: LD_VAR 0 1
25172: PUSH
25173: LD_INT 0
25175: PUSH
25176: LD_INT 1
25178: PUSH
25179: LD_INT 2
25181: PUSH
25182: LD_INT 3
25184: PUSH
25185: LD_INT 6
25187: PUSH
25188: LD_INT 36
25190: PUSH
25191: LD_INT 4
25193: PUSH
25194: LD_INT 5
25196: PUSH
25197: LD_INT 31
25199: PUSH
25200: LD_INT 32
25202: PUSH
25203: LD_INT 33
25205: PUSH
25206: EMPTY
25207: LIST
25208: LIST
25209: LIST
25210: LIST
25211: LIST
25212: LIST
25213: LIST
25214: LIST
25215: LIST
25216: LIST
25217: LIST
25218: IN
25219: NOT
25220: PUSH
25221: LD_VAR 0 6
25225: PUSH
25226: LD_INT 1
25228: EQUAL
25229: AND
25230: OR
25231: PUSH
25232: LD_VAR 0 1
25236: PUSH
25237: LD_INT 2
25239: PUSH
25240: LD_INT 3
25242: PUSH
25243: EMPTY
25244: LIST
25245: LIST
25246: IN
25247: NOT
25248: PUSH
25249: LD_VAR 0 6
25253: PUSH
25254: LD_INT 2
25256: EQUAL
25257: AND
25258: OR
25259: IFFALSE 25269
// mode = 0 ;
25261: LD_ADDR_VAR 0 6
25265: PUSH
25266: LD_INT 0
25268: ST_TO_ADDR
// case mode of 0 :
25269: LD_VAR 0 6
25273: PUSH
25274: LD_INT 0
25276: DOUBLE
25277: EQUAL
25278: IFTRUE 25282
25280: GO 36735
25282: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
25283: LD_ADDR_VAR 0 11
25287: PUSH
25288: LD_INT 0
25290: PUSH
25291: LD_INT 0
25293: PUSH
25294: EMPTY
25295: LIST
25296: LIST
25297: PUSH
25298: LD_INT 0
25300: PUSH
25301: LD_INT 1
25303: NEG
25304: PUSH
25305: EMPTY
25306: LIST
25307: LIST
25308: PUSH
25309: LD_INT 1
25311: PUSH
25312: LD_INT 0
25314: PUSH
25315: EMPTY
25316: LIST
25317: LIST
25318: PUSH
25319: LD_INT 1
25321: PUSH
25322: LD_INT 1
25324: PUSH
25325: EMPTY
25326: LIST
25327: LIST
25328: PUSH
25329: LD_INT 0
25331: PUSH
25332: LD_INT 1
25334: PUSH
25335: EMPTY
25336: LIST
25337: LIST
25338: PUSH
25339: LD_INT 1
25341: NEG
25342: PUSH
25343: LD_INT 0
25345: PUSH
25346: EMPTY
25347: LIST
25348: LIST
25349: PUSH
25350: LD_INT 1
25352: NEG
25353: PUSH
25354: LD_INT 1
25356: NEG
25357: PUSH
25358: EMPTY
25359: LIST
25360: LIST
25361: PUSH
25362: LD_INT 1
25364: NEG
25365: PUSH
25366: LD_INT 2
25368: NEG
25369: PUSH
25370: EMPTY
25371: LIST
25372: LIST
25373: PUSH
25374: LD_INT 0
25376: PUSH
25377: LD_INT 2
25379: NEG
25380: PUSH
25381: EMPTY
25382: LIST
25383: LIST
25384: PUSH
25385: LD_INT 1
25387: PUSH
25388: LD_INT 1
25390: NEG
25391: PUSH
25392: EMPTY
25393: LIST
25394: LIST
25395: PUSH
25396: LD_INT 1
25398: PUSH
25399: LD_INT 2
25401: PUSH
25402: EMPTY
25403: LIST
25404: LIST
25405: PUSH
25406: LD_INT 0
25408: PUSH
25409: LD_INT 2
25411: PUSH
25412: EMPTY
25413: LIST
25414: LIST
25415: PUSH
25416: LD_INT 1
25418: NEG
25419: PUSH
25420: LD_INT 1
25422: PUSH
25423: EMPTY
25424: LIST
25425: LIST
25426: PUSH
25427: LD_INT 1
25429: PUSH
25430: LD_INT 3
25432: PUSH
25433: EMPTY
25434: LIST
25435: LIST
25436: PUSH
25437: LD_INT 0
25439: PUSH
25440: LD_INT 3
25442: PUSH
25443: EMPTY
25444: LIST
25445: LIST
25446: PUSH
25447: LD_INT 1
25449: NEG
25450: PUSH
25451: LD_INT 2
25453: PUSH
25454: EMPTY
25455: LIST
25456: LIST
25457: PUSH
25458: EMPTY
25459: LIST
25460: LIST
25461: LIST
25462: LIST
25463: LIST
25464: LIST
25465: LIST
25466: LIST
25467: LIST
25468: LIST
25469: LIST
25470: LIST
25471: LIST
25472: LIST
25473: LIST
25474: LIST
25475: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
25476: LD_ADDR_VAR 0 12
25480: PUSH
25481: LD_INT 0
25483: PUSH
25484: LD_INT 0
25486: PUSH
25487: EMPTY
25488: LIST
25489: LIST
25490: PUSH
25491: LD_INT 0
25493: PUSH
25494: LD_INT 1
25496: NEG
25497: PUSH
25498: EMPTY
25499: LIST
25500: LIST
25501: PUSH
25502: LD_INT 1
25504: PUSH
25505: LD_INT 0
25507: PUSH
25508: EMPTY
25509: LIST
25510: LIST
25511: PUSH
25512: LD_INT 1
25514: PUSH
25515: LD_INT 1
25517: PUSH
25518: EMPTY
25519: LIST
25520: LIST
25521: PUSH
25522: LD_INT 0
25524: PUSH
25525: LD_INT 1
25527: PUSH
25528: EMPTY
25529: LIST
25530: LIST
25531: PUSH
25532: LD_INT 1
25534: NEG
25535: PUSH
25536: LD_INT 0
25538: PUSH
25539: EMPTY
25540: LIST
25541: LIST
25542: PUSH
25543: LD_INT 1
25545: NEG
25546: PUSH
25547: LD_INT 1
25549: NEG
25550: PUSH
25551: EMPTY
25552: LIST
25553: LIST
25554: PUSH
25555: LD_INT 1
25557: PUSH
25558: LD_INT 1
25560: NEG
25561: PUSH
25562: EMPTY
25563: LIST
25564: LIST
25565: PUSH
25566: LD_INT 2
25568: PUSH
25569: LD_INT 0
25571: PUSH
25572: EMPTY
25573: LIST
25574: LIST
25575: PUSH
25576: LD_INT 2
25578: PUSH
25579: LD_INT 1
25581: PUSH
25582: EMPTY
25583: LIST
25584: LIST
25585: PUSH
25586: LD_INT 1
25588: NEG
25589: PUSH
25590: LD_INT 1
25592: PUSH
25593: EMPTY
25594: LIST
25595: LIST
25596: PUSH
25597: LD_INT 2
25599: NEG
25600: PUSH
25601: LD_INT 0
25603: PUSH
25604: EMPTY
25605: LIST
25606: LIST
25607: PUSH
25608: LD_INT 2
25610: NEG
25611: PUSH
25612: LD_INT 1
25614: NEG
25615: PUSH
25616: EMPTY
25617: LIST
25618: LIST
25619: PUSH
25620: LD_INT 2
25622: NEG
25623: PUSH
25624: LD_INT 1
25626: PUSH
25627: EMPTY
25628: LIST
25629: LIST
25630: PUSH
25631: LD_INT 3
25633: NEG
25634: PUSH
25635: LD_INT 0
25637: PUSH
25638: EMPTY
25639: LIST
25640: LIST
25641: PUSH
25642: LD_INT 3
25644: NEG
25645: PUSH
25646: LD_INT 1
25648: NEG
25649: PUSH
25650: EMPTY
25651: LIST
25652: LIST
25653: PUSH
25654: EMPTY
25655: LIST
25656: LIST
25657: LIST
25658: LIST
25659: LIST
25660: LIST
25661: LIST
25662: LIST
25663: LIST
25664: LIST
25665: LIST
25666: LIST
25667: LIST
25668: LIST
25669: LIST
25670: LIST
25671: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
25672: LD_ADDR_VAR 0 13
25676: PUSH
25677: LD_INT 0
25679: PUSH
25680: LD_INT 0
25682: PUSH
25683: EMPTY
25684: LIST
25685: LIST
25686: PUSH
25687: LD_INT 0
25689: PUSH
25690: LD_INT 1
25692: NEG
25693: PUSH
25694: EMPTY
25695: LIST
25696: LIST
25697: PUSH
25698: LD_INT 1
25700: PUSH
25701: LD_INT 0
25703: PUSH
25704: EMPTY
25705: LIST
25706: LIST
25707: PUSH
25708: LD_INT 1
25710: PUSH
25711: LD_INT 1
25713: PUSH
25714: EMPTY
25715: LIST
25716: LIST
25717: PUSH
25718: LD_INT 0
25720: PUSH
25721: LD_INT 1
25723: PUSH
25724: EMPTY
25725: LIST
25726: LIST
25727: PUSH
25728: LD_INT 1
25730: NEG
25731: PUSH
25732: LD_INT 0
25734: PUSH
25735: EMPTY
25736: LIST
25737: LIST
25738: PUSH
25739: LD_INT 1
25741: NEG
25742: PUSH
25743: LD_INT 1
25745: NEG
25746: PUSH
25747: EMPTY
25748: LIST
25749: LIST
25750: PUSH
25751: LD_INT 1
25753: NEG
25754: PUSH
25755: LD_INT 2
25757: NEG
25758: PUSH
25759: EMPTY
25760: LIST
25761: LIST
25762: PUSH
25763: LD_INT 2
25765: PUSH
25766: LD_INT 1
25768: PUSH
25769: EMPTY
25770: LIST
25771: LIST
25772: PUSH
25773: LD_INT 2
25775: PUSH
25776: LD_INT 2
25778: PUSH
25779: EMPTY
25780: LIST
25781: LIST
25782: PUSH
25783: LD_INT 1
25785: PUSH
25786: LD_INT 2
25788: PUSH
25789: EMPTY
25790: LIST
25791: LIST
25792: PUSH
25793: LD_INT 2
25795: NEG
25796: PUSH
25797: LD_INT 1
25799: NEG
25800: PUSH
25801: EMPTY
25802: LIST
25803: LIST
25804: PUSH
25805: LD_INT 2
25807: NEG
25808: PUSH
25809: LD_INT 2
25811: NEG
25812: PUSH
25813: EMPTY
25814: LIST
25815: LIST
25816: PUSH
25817: LD_INT 2
25819: NEG
25820: PUSH
25821: LD_INT 3
25823: NEG
25824: PUSH
25825: EMPTY
25826: LIST
25827: LIST
25828: PUSH
25829: LD_INT 3
25831: NEG
25832: PUSH
25833: LD_INT 2
25835: NEG
25836: PUSH
25837: EMPTY
25838: LIST
25839: LIST
25840: PUSH
25841: LD_INT 3
25843: NEG
25844: PUSH
25845: LD_INT 3
25847: NEG
25848: PUSH
25849: EMPTY
25850: LIST
25851: LIST
25852: PUSH
25853: EMPTY
25854: LIST
25855: LIST
25856: LIST
25857: LIST
25858: LIST
25859: LIST
25860: LIST
25861: LIST
25862: LIST
25863: LIST
25864: LIST
25865: LIST
25866: LIST
25867: LIST
25868: LIST
25869: LIST
25870: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
25871: LD_ADDR_VAR 0 14
25875: PUSH
25876: LD_INT 0
25878: PUSH
25879: LD_INT 0
25881: PUSH
25882: EMPTY
25883: LIST
25884: LIST
25885: PUSH
25886: LD_INT 0
25888: PUSH
25889: LD_INT 1
25891: NEG
25892: PUSH
25893: EMPTY
25894: LIST
25895: LIST
25896: PUSH
25897: LD_INT 1
25899: PUSH
25900: LD_INT 0
25902: PUSH
25903: EMPTY
25904: LIST
25905: LIST
25906: PUSH
25907: LD_INT 1
25909: PUSH
25910: LD_INT 1
25912: PUSH
25913: EMPTY
25914: LIST
25915: LIST
25916: PUSH
25917: LD_INT 0
25919: PUSH
25920: LD_INT 1
25922: PUSH
25923: EMPTY
25924: LIST
25925: LIST
25926: PUSH
25927: LD_INT 1
25929: NEG
25930: PUSH
25931: LD_INT 0
25933: PUSH
25934: EMPTY
25935: LIST
25936: LIST
25937: PUSH
25938: LD_INT 1
25940: NEG
25941: PUSH
25942: LD_INT 1
25944: NEG
25945: PUSH
25946: EMPTY
25947: LIST
25948: LIST
25949: PUSH
25950: LD_INT 1
25952: NEG
25953: PUSH
25954: LD_INT 2
25956: NEG
25957: PUSH
25958: EMPTY
25959: LIST
25960: LIST
25961: PUSH
25962: LD_INT 0
25964: PUSH
25965: LD_INT 2
25967: NEG
25968: PUSH
25969: EMPTY
25970: LIST
25971: LIST
25972: PUSH
25973: LD_INT 1
25975: PUSH
25976: LD_INT 1
25978: NEG
25979: PUSH
25980: EMPTY
25981: LIST
25982: LIST
25983: PUSH
25984: LD_INT 1
25986: PUSH
25987: LD_INT 2
25989: PUSH
25990: EMPTY
25991: LIST
25992: LIST
25993: PUSH
25994: LD_INT 0
25996: PUSH
25997: LD_INT 2
25999: PUSH
26000: EMPTY
26001: LIST
26002: LIST
26003: PUSH
26004: LD_INT 1
26006: NEG
26007: PUSH
26008: LD_INT 1
26010: PUSH
26011: EMPTY
26012: LIST
26013: LIST
26014: PUSH
26015: LD_INT 1
26017: NEG
26018: PUSH
26019: LD_INT 3
26021: NEG
26022: PUSH
26023: EMPTY
26024: LIST
26025: LIST
26026: PUSH
26027: LD_INT 0
26029: PUSH
26030: LD_INT 3
26032: NEG
26033: PUSH
26034: EMPTY
26035: LIST
26036: LIST
26037: PUSH
26038: LD_INT 1
26040: PUSH
26041: LD_INT 2
26043: NEG
26044: PUSH
26045: EMPTY
26046: LIST
26047: LIST
26048: PUSH
26049: EMPTY
26050: LIST
26051: LIST
26052: LIST
26053: LIST
26054: LIST
26055: LIST
26056: LIST
26057: LIST
26058: LIST
26059: LIST
26060: LIST
26061: LIST
26062: LIST
26063: LIST
26064: LIST
26065: LIST
26066: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
26067: LD_ADDR_VAR 0 15
26071: PUSH
26072: LD_INT 0
26074: PUSH
26075: LD_INT 0
26077: PUSH
26078: EMPTY
26079: LIST
26080: LIST
26081: PUSH
26082: LD_INT 0
26084: PUSH
26085: LD_INT 1
26087: NEG
26088: PUSH
26089: EMPTY
26090: LIST
26091: LIST
26092: PUSH
26093: LD_INT 1
26095: PUSH
26096: LD_INT 0
26098: PUSH
26099: EMPTY
26100: LIST
26101: LIST
26102: PUSH
26103: LD_INT 1
26105: PUSH
26106: LD_INT 1
26108: PUSH
26109: EMPTY
26110: LIST
26111: LIST
26112: PUSH
26113: LD_INT 0
26115: PUSH
26116: LD_INT 1
26118: PUSH
26119: EMPTY
26120: LIST
26121: LIST
26122: PUSH
26123: LD_INT 1
26125: NEG
26126: PUSH
26127: LD_INT 0
26129: PUSH
26130: EMPTY
26131: LIST
26132: LIST
26133: PUSH
26134: LD_INT 1
26136: NEG
26137: PUSH
26138: LD_INT 1
26140: NEG
26141: PUSH
26142: EMPTY
26143: LIST
26144: LIST
26145: PUSH
26146: LD_INT 1
26148: PUSH
26149: LD_INT 1
26151: NEG
26152: PUSH
26153: EMPTY
26154: LIST
26155: LIST
26156: PUSH
26157: LD_INT 2
26159: PUSH
26160: LD_INT 0
26162: PUSH
26163: EMPTY
26164: LIST
26165: LIST
26166: PUSH
26167: LD_INT 2
26169: PUSH
26170: LD_INT 1
26172: PUSH
26173: EMPTY
26174: LIST
26175: LIST
26176: PUSH
26177: LD_INT 1
26179: NEG
26180: PUSH
26181: LD_INT 1
26183: PUSH
26184: EMPTY
26185: LIST
26186: LIST
26187: PUSH
26188: LD_INT 2
26190: NEG
26191: PUSH
26192: LD_INT 0
26194: PUSH
26195: EMPTY
26196: LIST
26197: LIST
26198: PUSH
26199: LD_INT 2
26201: NEG
26202: PUSH
26203: LD_INT 1
26205: NEG
26206: PUSH
26207: EMPTY
26208: LIST
26209: LIST
26210: PUSH
26211: LD_INT 2
26213: PUSH
26214: LD_INT 1
26216: NEG
26217: PUSH
26218: EMPTY
26219: LIST
26220: LIST
26221: PUSH
26222: LD_INT 3
26224: PUSH
26225: LD_INT 0
26227: PUSH
26228: EMPTY
26229: LIST
26230: LIST
26231: PUSH
26232: LD_INT 3
26234: PUSH
26235: LD_INT 1
26237: PUSH
26238: EMPTY
26239: LIST
26240: LIST
26241: PUSH
26242: EMPTY
26243: LIST
26244: LIST
26245: LIST
26246: LIST
26247: LIST
26248: LIST
26249: LIST
26250: LIST
26251: LIST
26252: LIST
26253: LIST
26254: LIST
26255: LIST
26256: LIST
26257: LIST
26258: LIST
26259: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
26260: LD_ADDR_VAR 0 16
26264: PUSH
26265: LD_INT 0
26267: PUSH
26268: LD_INT 0
26270: PUSH
26271: EMPTY
26272: LIST
26273: LIST
26274: PUSH
26275: LD_INT 0
26277: PUSH
26278: LD_INT 1
26280: NEG
26281: PUSH
26282: EMPTY
26283: LIST
26284: LIST
26285: PUSH
26286: LD_INT 1
26288: PUSH
26289: LD_INT 0
26291: PUSH
26292: EMPTY
26293: LIST
26294: LIST
26295: PUSH
26296: LD_INT 1
26298: PUSH
26299: LD_INT 1
26301: PUSH
26302: EMPTY
26303: LIST
26304: LIST
26305: PUSH
26306: LD_INT 0
26308: PUSH
26309: LD_INT 1
26311: PUSH
26312: EMPTY
26313: LIST
26314: LIST
26315: PUSH
26316: LD_INT 1
26318: NEG
26319: PUSH
26320: LD_INT 0
26322: PUSH
26323: EMPTY
26324: LIST
26325: LIST
26326: PUSH
26327: LD_INT 1
26329: NEG
26330: PUSH
26331: LD_INT 1
26333: NEG
26334: PUSH
26335: EMPTY
26336: LIST
26337: LIST
26338: PUSH
26339: LD_INT 1
26341: NEG
26342: PUSH
26343: LD_INT 2
26345: NEG
26346: PUSH
26347: EMPTY
26348: LIST
26349: LIST
26350: PUSH
26351: LD_INT 2
26353: PUSH
26354: LD_INT 1
26356: PUSH
26357: EMPTY
26358: LIST
26359: LIST
26360: PUSH
26361: LD_INT 2
26363: PUSH
26364: LD_INT 2
26366: PUSH
26367: EMPTY
26368: LIST
26369: LIST
26370: PUSH
26371: LD_INT 1
26373: PUSH
26374: LD_INT 2
26376: PUSH
26377: EMPTY
26378: LIST
26379: LIST
26380: PUSH
26381: LD_INT 2
26383: NEG
26384: PUSH
26385: LD_INT 1
26387: NEG
26388: PUSH
26389: EMPTY
26390: LIST
26391: LIST
26392: PUSH
26393: LD_INT 2
26395: NEG
26396: PUSH
26397: LD_INT 2
26399: NEG
26400: PUSH
26401: EMPTY
26402: LIST
26403: LIST
26404: PUSH
26405: LD_INT 3
26407: PUSH
26408: LD_INT 2
26410: PUSH
26411: EMPTY
26412: LIST
26413: LIST
26414: PUSH
26415: LD_INT 3
26417: PUSH
26418: LD_INT 3
26420: PUSH
26421: EMPTY
26422: LIST
26423: LIST
26424: PUSH
26425: LD_INT 2
26427: PUSH
26428: LD_INT 3
26430: PUSH
26431: EMPTY
26432: LIST
26433: LIST
26434: PUSH
26435: EMPTY
26436: LIST
26437: LIST
26438: LIST
26439: LIST
26440: LIST
26441: LIST
26442: LIST
26443: LIST
26444: LIST
26445: LIST
26446: LIST
26447: LIST
26448: LIST
26449: LIST
26450: LIST
26451: LIST
26452: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26453: LD_ADDR_VAR 0 17
26457: PUSH
26458: LD_INT 0
26460: PUSH
26461: LD_INT 0
26463: PUSH
26464: EMPTY
26465: LIST
26466: LIST
26467: PUSH
26468: LD_INT 0
26470: PUSH
26471: LD_INT 1
26473: NEG
26474: PUSH
26475: EMPTY
26476: LIST
26477: LIST
26478: PUSH
26479: LD_INT 1
26481: PUSH
26482: LD_INT 0
26484: PUSH
26485: EMPTY
26486: LIST
26487: LIST
26488: PUSH
26489: LD_INT 1
26491: PUSH
26492: LD_INT 1
26494: PUSH
26495: EMPTY
26496: LIST
26497: LIST
26498: PUSH
26499: LD_INT 0
26501: PUSH
26502: LD_INT 1
26504: PUSH
26505: EMPTY
26506: LIST
26507: LIST
26508: PUSH
26509: LD_INT 1
26511: NEG
26512: PUSH
26513: LD_INT 0
26515: PUSH
26516: EMPTY
26517: LIST
26518: LIST
26519: PUSH
26520: LD_INT 1
26522: NEG
26523: PUSH
26524: LD_INT 1
26526: NEG
26527: PUSH
26528: EMPTY
26529: LIST
26530: LIST
26531: PUSH
26532: LD_INT 1
26534: NEG
26535: PUSH
26536: LD_INT 2
26538: NEG
26539: PUSH
26540: EMPTY
26541: LIST
26542: LIST
26543: PUSH
26544: LD_INT 0
26546: PUSH
26547: LD_INT 2
26549: NEG
26550: PUSH
26551: EMPTY
26552: LIST
26553: LIST
26554: PUSH
26555: LD_INT 1
26557: PUSH
26558: LD_INT 1
26560: NEG
26561: PUSH
26562: EMPTY
26563: LIST
26564: LIST
26565: PUSH
26566: LD_INT 2
26568: PUSH
26569: LD_INT 0
26571: PUSH
26572: EMPTY
26573: LIST
26574: LIST
26575: PUSH
26576: LD_INT 2
26578: PUSH
26579: LD_INT 1
26581: PUSH
26582: EMPTY
26583: LIST
26584: LIST
26585: PUSH
26586: LD_INT 2
26588: PUSH
26589: LD_INT 2
26591: PUSH
26592: EMPTY
26593: LIST
26594: LIST
26595: PUSH
26596: LD_INT 1
26598: PUSH
26599: LD_INT 2
26601: PUSH
26602: EMPTY
26603: LIST
26604: LIST
26605: PUSH
26606: LD_INT 0
26608: PUSH
26609: LD_INT 2
26611: PUSH
26612: EMPTY
26613: LIST
26614: LIST
26615: PUSH
26616: LD_INT 1
26618: NEG
26619: PUSH
26620: LD_INT 1
26622: PUSH
26623: EMPTY
26624: LIST
26625: LIST
26626: PUSH
26627: LD_INT 2
26629: NEG
26630: PUSH
26631: LD_INT 0
26633: PUSH
26634: EMPTY
26635: LIST
26636: LIST
26637: PUSH
26638: LD_INT 2
26640: NEG
26641: PUSH
26642: LD_INT 1
26644: NEG
26645: PUSH
26646: EMPTY
26647: LIST
26648: LIST
26649: PUSH
26650: LD_INT 2
26652: NEG
26653: PUSH
26654: LD_INT 2
26656: NEG
26657: PUSH
26658: EMPTY
26659: LIST
26660: LIST
26661: PUSH
26662: EMPTY
26663: LIST
26664: LIST
26665: LIST
26666: LIST
26667: LIST
26668: LIST
26669: LIST
26670: LIST
26671: LIST
26672: LIST
26673: LIST
26674: LIST
26675: LIST
26676: LIST
26677: LIST
26678: LIST
26679: LIST
26680: LIST
26681: LIST
26682: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26683: LD_ADDR_VAR 0 18
26687: PUSH
26688: LD_INT 0
26690: PUSH
26691: LD_INT 0
26693: PUSH
26694: EMPTY
26695: LIST
26696: LIST
26697: PUSH
26698: LD_INT 0
26700: PUSH
26701: LD_INT 1
26703: NEG
26704: PUSH
26705: EMPTY
26706: LIST
26707: LIST
26708: PUSH
26709: LD_INT 1
26711: PUSH
26712: LD_INT 0
26714: PUSH
26715: EMPTY
26716: LIST
26717: LIST
26718: PUSH
26719: LD_INT 1
26721: PUSH
26722: LD_INT 1
26724: PUSH
26725: EMPTY
26726: LIST
26727: LIST
26728: PUSH
26729: LD_INT 0
26731: PUSH
26732: LD_INT 1
26734: PUSH
26735: EMPTY
26736: LIST
26737: LIST
26738: PUSH
26739: LD_INT 1
26741: NEG
26742: PUSH
26743: LD_INT 0
26745: PUSH
26746: EMPTY
26747: LIST
26748: LIST
26749: PUSH
26750: LD_INT 1
26752: NEG
26753: PUSH
26754: LD_INT 1
26756: NEG
26757: PUSH
26758: EMPTY
26759: LIST
26760: LIST
26761: PUSH
26762: LD_INT 1
26764: NEG
26765: PUSH
26766: LD_INT 2
26768: NEG
26769: PUSH
26770: EMPTY
26771: LIST
26772: LIST
26773: PUSH
26774: LD_INT 0
26776: PUSH
26777: LD_INT 2
26779: NEG
26780: PUSH
26781: EMPTY
26782: LIST
26783: LIST
26784: PUSH
26785: LD_INT 1
26787: PUSH
26788: LD_INT 1
26790: NEG
26791: PUSH
26792: EMPTY
26793: LIST
26794: LIST
26795: PUSH
26796: LD_INT 2
26798: PUSH
26799: LD_INT 0
26801: PUSH
26802: EMPTY
26803: LIST
26804: LIST
26805: PUSH
26806: LD_INT 2
26808: PUSH
26809: LD_INT 1
26811: PUSH
26812: EMPTY
26813: LIST
26814: LIST
26815: PUSH
26816: LD_INT 2
26818: PUSH
26819: LD_INT 2
26821: PUSH
26822: EMPTY
26823: LIST
26824: LIST
26825: PUSH
26826: LD_INT 1
26828: PUSH
26829: LD_INT 2
26831: PUSH
26832: EMPTY
26833: LIST
26834: LIST
26835: PUSH
26836: LD_INT 0
26838: PUSH
26839: LD_INT 2
26841: PUSH
26842: EMPTY
26843: LIST
26844: LIST
26845: PUSH
26846: LD_INT 1
26848: NEG
26849: PUSH
26850: LD_INT 1
26852: PUSH
26853: EMPTY
26854: LIST
26855: LIST
26856: PUSH
26857: LD_INT 2
26859: NEG
26860: PUSH
26861: LD_INT 0
26863: PUSH
26864: EMPTY
26865: LIST
26866: LIST
26867: PUSH
26868: LD_INT 2
26870: NEG
26871: PUSH
26872: LD_INT 1
26874: NEG
26875: PUSH
26876: EMPTY
26877: LIST
26878: LIST
26879: PUSH
26880: LD_INT 2
26882: NEG
26883: PUSH
26884: LD_INT 2
26886: NEG
26887: PUSH
26888: EMPTY
26889: LIST
26890: LIST
26891: PUSH
26892: EMPTY
26893: LIST
26894: LIST
26895: LIST
26896: LIST
26897: LIST
26898: LIST
26899: LIST
26900: LIST
26901: LIST
26902: LIST
26903: LIST
26904: LIST
26905: LIST
26906: LIST
26907: LIST
26908: LIST
26909: LIST
26910: LIST
26911: LIST
26912: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26913: LD_ADDR_VAR 0 19
26917: PUSH
26918: LD_INT 0
26920: PUSH
26921: LD_INT 0
26923: PUSH
26924: EMPTY
26925: LIST
26926: LIST
26927: PUSH
26928: LD_INT 0
26930: PUSH
26931: LD_INT 1
26933: NEG
26934: PUSH
26935: EMPTY
26936: LIST
26937: LIST
26938: PUSH
26939: LD_INT 1
26941: PUSH
26942: LD_INT 0
26944: PUSH
26945: EMPTY
26946: LIST
26947: LIST
26948: PUSH
26949: LD_INT 1
26951: PUSH
26952: LD_INT 1
26954: PUSH
26955: EMPTY
26956: LIST
26957: LIST
26958: PUSH
26959: LD_INT 0
26961: PUSH
26962: LD_INT 1
26964: PUSH
26965: EMPTY
26966: LIST
26967: LIST
26968: PUSH
26969: LD_INT 1
26971: NEG
26972: PUSH
26973: LD_INT 0
26975: PUSH
26976: EMPTY
26977: LIST
26978: LIST
26979: PUSH
26980: LD_INT 1
26982: NEG
26983: PUSH
26984: LD_INT 1
26986: NEG
26987: PUSH
26988: EMPTY
26989: LIST
26990: LIST
26991: PUSH
26992: LD_INT 1
26994: NEG
26995: PUSH
26996: LD_INT 2
26998: NEG
26999: PUSH
27000: EMPTY
27001: LIST
27002: LIST
27003: PUSH
27004: LD_INT 0
27006: PUSH
27007: LD_INT 2
27009: NEG
27010: PUSH
27011: EMPTY
27012: LIST
27013: LIST
27014: PUSH
27015: LD_INT 1
27017: PUSH
27018: LD_INT 1
27020: NEG
27021: PUSH
27022: EMPTY
27023: LIST
27024: LIST
27025: PUSH
27026: LD_INT 2
27028: PUSH
27029: LD_INT 0
27031: PUSH
27032: EMPTY
27033: LIST
27034: LIST
27035: PUSH
27036: LD_INT 2
27038: PUSH
27039: LD_INT 1
27041: PUSH
27042: EMPTY
27043: LIST
27044: LIST
27045: PUSH
27046: LD_INT 2
27048: PUSH
27049: LD_INT 2
27051: PUSH
27052: EMPTY
27053: LIST
27054: LIST
27055: PUSH
27056: LD_INT 1
27058: PUSH
27059: LD_INT 2
27061: PUSH
27062: EMPTY
27063: LIST
27064: LIST
27065: PUSH
27066: LD_INT 0
27068: PUSH
27069: LD_INT 2
27071: PUSH
27072: EMPTY
27073: LIST
27074: LIST
27075: PUSH
27076: LD_INT 1
27078: NEG
27079: PUSH
27080: LD_INT 1
27082: PUSH
27083: EMPTY
27084: LIST
27085: LIST
27086: PUSH
27087: LD_INT 2
27089: NEG
27090: PUSH
27091: LD_INT 0
27093: PUSH
27094: EMPTY
27095: LIST
27096: LIST
27097: PUSH
27098: LD_INT 2
27100: NEG
27101: PUSH
27102: LD_INT 1
27104: NEG
27105: PUSH
27106: EMPTY
27107: LIST
27108: LIST
27109: PUSH
27110: LD_INT 2
27112: NEG
27113: PUSH
27114: LD_INT 2
27116: NEG
27117: PUSH
27118: EMPTY
27119: LIST
27120: LIST
27121: PUSH
27122: EMPTY
27123: LIST
27124: LIST
27125: LIST
27126: LIST
27127: LIST
27128: LIST
27129: LIST
27130: LIST
27131: LIST
27132: LIST
27133: LIST
27134: LIST
27135: LIST
27136: LIST
27137: LIST
27138: LIST
27139: LIST
27140: LIST
27141: LIST
27142: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27143: LD_ADDR_VAR 0 20
27147: PUSH
27148: LD_INT 0
27150: PUSH
27151: LD_INT 0
27153: PUSH
27154: EMPTY
27155: LIST
27156: LIST
27157: PUSH
27158: LD_INT 0
27160: PUSH
27161: LD_INT 1
27163: NEG
27164: PUSH
27165: EMPTY
27166: LIST
27167: LIST
27168: PUSH
27169: LD_INT 1
27171: PUSH
27172: LD_INT 0
27174: PUSH
27175: EMPTY
27176: LIST
27177: LIST
27178: PUSH
27179: LD_INT 1
27181: PUSH
27182: LD_INT 1
27184: PUSH
27185: EMPTY
27186: LIST
27187: LIST
27188: PUSH
27189: LD_INT 0
27191: PUSH
27192: LD_INT 1
27194: PUSH
27195: EMPTY
27196: LIST
27197: LIST
27198: PUSH
27199: LD_INT 1
27201: NEG
27202: PUSH
27203: LD_INT 0
27205: PUSH
27206: EMPTY
27207: LIST
27208: LIST
27209: PUSH
27210: LD_INT 1
27212: NEG
27213: PUSH
27214: LD_INT 1
27216: NEG
27217: PUSH
27218: EMPTY
27219: LIST
27220: LIST
27221: PUSH
27222: LD_INT 1
27224: NEG
27225: PUSH
27226: LD_INT 2
27228: NEG
27229: PUSH
27230: EMPTY
27231: LIST
27232: LIST
27233: PUSH
27234: LD_INT 0
27236: PUSH
27237: LD_INT 2
27239: NEG
27240: PUSH
27241: EMPTY
27242: LIST
27243: LIST
27244: PUSH
27245: LD_INT 1
27247: PUSH
27248: LD_INT 1
27250: NEG
27251: PUSH
27252: EMPTY
27253: LIST
27254: LIST
27255: PUSH
27256: LD_INT 2
27258: PUSH
27259: LD_INT 0
27261: PUSH
27262: EMPTY
27263: LIST
27264: LIST
27265: PUSH
27266: LD_INT 2
27268: PUSH
27269: LD_INT 1
27271: PUSH
27272: EMPTY
27273: LIST
27274: LIST
27275: PUSH
27276: LD_INT 2
27278: PUSH
27279: LD_INT 2
27281: PUSH
27282: EMPTY
27283: LIST
27284: LIST
27285: PUSH
27286: LD_INT 1
27288: PUSH
27289: LD_INT 2
27291: PUSH
27292: EMPTY
27293: LIST
27294: LIST
27295: PUSH
27296: LD_INT 0
27298: PUSH
27299: LD_INT 2
27301: PUSH
27302: EMPTY
27303: LIST
27304: LIST
27305: PUSH
27306: LD_INT 1
27308: NEG
27309: PUSH
27310: LD_INT 1
27312: PUSH
27313: EMPTY
27314: LIST
27315: LIST
27316: PUSH
27317: LD_INT 2
27319: NEG
27320: PUSH
27321: LD_INT 0
27323: PUSH
27324: EMPTY
27325: LIST
27326: LIST
27327: PUSH
27328: LD_INT 2
27330: NEG
27331: PUSH
27332: LD_INT 1
27334: NEG
27335: PUSH
27336: EMPTY
27337: LIST
27338: LIST
27339: PUSH
27340: LD_INT 2
27342: NEG
27343: PUSH
27344: LD_INT 2
27346: NEG
27347: PUSH
27348: EMPTY
27349: LIST
27350: LIST
27351: PUSH
27352: EMPTY
27353: LIST
27354: LIST
27355: LIST
27356: LIST
27357: LIST
27358: LIST
27359: LIST
27360: LIST
27361: LIST
27362: LIST
27363: LIST
27364: LIST
27365: LIST
27366: LIST
27367: LIST
27368: LIST
27369: LIST
27370: LIST
27371: LIST
27372: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27373: LD_ADDR_VAR 0 21
27377: PUSH
27378: LD_INT 0
27380: PUSH
27381: LD_INT 0
27383: PUSH
27384: EMPTY
27385: LIST
27386: LIST
27387: PUSH
27388: LD_INT 0
27390: PUSH
27391: LD_INT 1
27393: NEG
27394: PUSH
27395: EMPTY
27396: LIST
27397: LIST
27398: PUSH
27399: LD_INT 1
27401: PUSH
27402: LD_INT 0
27404: PUSH
27405: EMPTY
27406: LIST
27407: LIST
27408: PUSH
27409: LD_INT 1
27411: PUSH
27412: LD_INT 1
27414: PUSH
27415: EMPTY
27416: LIST
27417: LIST
27418: PUSH
27419: LD_INT 0
27421: PUSH
27422: LD_INT 1
27424: PUSH
27425: EMPTY
27426: LIST
27427: LIST
27428: PUSH
27429: LD_INT 1
27431: NEG
27432: PUSH
27433: LD_INT 0
27435: PUSH
27436: EMPTY
27437: LIST
27438: LIST
27439: PUSH
27440: LD_INT 1
27442: NEG
27443: PUSH
27444: LD_INT 1
27446: NEG
27447: PUSH
27448: EMPTY
27449: LIST
27450: LIST
27451: PUSH
27452: LD_INT 1
27454: NEG
27455: PUSH
27456: LD_INT 2
27458: NEG
27459: PUSH
27460: EMPTY
27461: LIST
27462: LIST
27463: PUSH
27464: LD_INT 0
27466: PUSH
27467: LD_INT 2
27469: NEG
27470: PUSH
27471: EMPTY
27472: LIST
27473: LIST
27474: PUSH
27475: LD_INT 1
27477: PUSH
27478: LD_INT 1
27480: NEG
27481: PUSH
27482: EMPTY
27483: LIST
27484: LIST
27485: PUSH
27486: LD_INT 2
27488: PUSH
27489: LD_INT 0
27491: PUSH
27492: EMPTY
27493: LIST
27494: LIST
27495: PUSH
27496: LD_INT 2
27498: PUSH
27499: LD_INT 1
27501: PUSH
27502: EMPTY
27503: LIST
27504: LIST
27505: PUSH
27506: LD_INT 2
27508: PUSH
27509: LD_INT 2
27511: PUSH
27512: EMPTY
27513: LIST
27514: LIST
27515: PUSH
27516: LD_INT 1
27518: PUSH
27519: LD_INT 2
27521: PUSH
27522: EMPTY
27523: LIST
27524: LIST
27525: PUSH
27526: LD_INT 0
27528: PUSH
27529: LD_INT 2
27531: PUSH
27532: EMPTY
27533: LIST
27534: LIST
27535: PUSH
27536: LD_INT 1
27538: NEG
27539: PUSH
27540: LD_INT 1
27542: PUSH
27543: EMPTY
27544: LIST
27545: LIST
27546: PUSH
27547: LD_INT 2
27549: NEG
27550: PUSH
27551: LD_INT 0
27553: PUSH
27554: EMPTY
27555: LIST
27556: LIST
27557: PUSH
27558: LD_INT 2
27560: NEG
27561: PUSH
27562: LD_INT 1
27564: NEG
27565: PUSH
27566: EMPTY
27567: LIST
27568: LIST
27569: PUSH
27570: LD_INT 2
27572: NEG
27573: PUSH
27574: LD_INT 2
27576: NEG
27577: PUSH
27578: EMPTY
27579: LIST
27580: LIST
27581: PUSH
27582: EMPTY
27583: LIST
27584: LIST
27585: LIST
27586: LIST
27587: LIST
27588: LIST
27589: LIST
27590: LIST
27591: LIST
27592: LIST
27593: LIST
27594: LIST
27595: LIST
27596: LIST
27597: LIST
27598: LIST
27599: LIST
27600: LIST
27601: LIST
27602: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27603: LD_ADDR_VAR 0 22
27607: PUSH
27608: LD_INT 0
27610: PUSH
27611: LD_INT 0
27613: PUSH
27614: EMPTY
27615: LIST
27616: LIST
27617: PUSH
27618: LD_INT 0
27620: PUSH
27621: LD_INT 1
27623: NEG
27624: PUSH
27625: EMPTY
27626: LIST
27627: LIST
27628: PUSH
27629: LD_INT 1
27631: PUSH
27632: LD_INT 0
27634: PUSH
27635: EMPTY
27636: LIST
27637: LIST
27638: PUSH
27639: LD_INT 1
27641: PUSH
27642: LD_INT 1
27644: PUSH
27645: EMPTY
27646: LIST
27647: LIST
27648: PUSH
27649: LD_INT 0
27651: PUSH
27652: LD_INT 1
27654: PUSH
27655: EMPTY
27656: LIST
27657: LIST
27658: PUSH
27659: LD_INT 1
27661: NEG
27662: PUSH
27663: LD_INT 0
27665: PUSH
27666: EMPTY
27667: LIST
27668: LIST
27669: PUSH
27670: LD_INT 1
27672: NEG
27673: PUSH
27674: LD_INT 1
27676: NEG
27677: PUSH
27678: EMPTY
27679: LIST
27680: LIST
27681: PUSH
27682: LD_INT 1
27684: NEG
27685: PUSH
27686: LD_INT 2
27688: NEG
27689: PUSH
27690: EMPTY
27691: LIST
27692: LIST
27693: PUSH
27694: LD_INT 0
27696: PUSH
27697: LD_INT 2
27699: NEG
27700: PUSH
27701: EMPTY
27702: LIST
27703: LIST
27704: PUSH
27705: LD_INT 1
27707: PUSH
27708: LD_INT 1
27710: NEG
27711: PUSH
27712: EMPTY
27713: LIST
27714: LIST
27715: PUSH
27716: LD_INT 2
27718: PUSH
27719: LD_INT 0
27721: PUSH
27722: EMPTY
27723: LIST
27724: LIST
27725: PUSH
27726: LD_INT 2
27728: PUSH
27729: LD_INT 1
27731: PUSH
27732: EMPTY
27733: LIST
27734: LIST
27735: PUSH
27736: LD_INT 2
27738: PUSH
27739: LD_INT 2
27741: PUSH
27742: EMPTY
27743: LIST
27744: LIST
27745: PUSH
27746: LD_INT 1
27748: PUSH
27749: LD_INT 2
27751: PUSH
27752: EMPTY
27753: LIST
27754: LIST
27755: PUSH
27756: LD_INT 0
27758: PUSH
27759: LD_INT 2
27761: PUSH
27762: EMPTY
27763: LIST
27764: LIST
27765: PUSH
27766: LD_INT 1
27768: NEG
27769: PUSH
27770: LD_INT 1
27772: PUSH
27773: EMPTY
27774: LIST
27775: LIST
27776: PUSH
27777: LD_INT 2
27779: NEG
27780: PUSH
27781: LD_INT 0
27783: PUSH
27784: EMPTY
27785: LIST
27786: LIST
27787: PUSH
27788: LD_INT 2
27790: NEG
27791: PUSH
27792: LD_INT 1
27794: NEG
27795: PUSH
27796: EMPTY
27797: LIST
27798: LIST
27799: PUSH
27800: LD_INT 2
27802: NEG
27803: PUSH
27804: LD_INT 2
27806: NEG
27807: PUSH
27808: EMPTY
27809: LIST
27810: LIST
27811: PUSH
27812: EMPTY
27813: LIST
27814: LIST
27815: LIST
27816: LIST
27817: LIST
27818: LIST
27819: LIST
27820: LIST
27821: LIST
27822: LIST
27823: LIST
27824: LIST
27825: LIST
27826: LIST
27827: LIST
27828: LIST
27829: LIST
27830: LIST
27831: LIST
27832: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
27833: LD_ADDR_VAR 0 23
27837: PUSH
27838: LD_INT 0
27840: PUSH
27841: LD_INT 0
27843: PUSH
27844: EMPTY
27845: LIST
27846: LIST
27847: PUSH
27848: LD_INT 0
27850: PUSH
27851: LD_INT 1
27853: NEG
27854: PUSH
27855: EMPTY
27856: LIST
27857: LIST
27858: PUSH
27859: LD_INT 1
27861: PUSH
27862: LD_INT 0
27864: PUSH
27865: EMPTY
27866: LIST
27867: LIST
27868: PUSH
27869: LD_INT 1
27871: PUSH
27872: LD_INT 1
27874: PUSH
27875: EMPTY
27876: LIST
27877: LIST
27878: PUSH
27879: LD_INT 0
27881: PUSH
27882: LD_INT 1
27884: PUSH
27885: EMPTY
27886: LIST
27887: LIST
27888: PUSH
27889: LD_INT 1
27891: NEG
27892: PUSH
27893: LD_INT 0
27895: PUSH
27896: EMPTY
27897: LIST
27898: LIST
27899: PUSH
27900: LD_INT 1
27902: NEG
27903: PUSH
27904: LD_INT 1
27906: NEG
27907: PUSH
27908: EMPTY
27909: LIST
27910: LIST
27911: PUSH
27912: LD_INT 1
27914: NEG
27915: PUSH
27916: LD_INT 2
27918: NEG
27919: PUSH
27920: EMPTY
27921: LIST
27922: LIST
27923: PUSH
27924: LD_INT 0
27926: PUSH
27927: LD_INT 2
27929: NEG
27930: PUSH
27931: EMPTY
27932: LIST
27933: LIST
27934: PUSH
27935: LD_INT 1
27937: PUSH
27938: LD_INT 1
27940: NEG
27941: PUSH
27942: EMPTY
27943: LIST
27944: LIST
27945: PUSH
27946: LD_INT 2
27948: PUSH
27949: LD_INT 0
27951: PUSH
27952: EMPTY
27953: LIST
27954: LIST
27955: PUSH
27956: LD_INT 2
27958: PUSH
27959: LD_INT 1
27961: PUSH
27962: EMPTY
27963: LIST
27964: LIST
27965: PUSH
27966: LD_INT 2
27968: PUSH
27969: LD_INT 2
27971: PUSH
27972: EMPTY
27973: LIST
27974: LIST
27975: PUSH
27976: LD_INT 1
27978: PUSH
27979: LD_INT 2
27981: PUSH
27982: EMPTY
27983: LIST
27984: LIST
27985: PUSH
27986: LD_INT 0
27988: PUSH
27989: LD_INT 2
27991: PUSH
27992: EMPTY
27993: LIST
27994: LIST
27995: PUSH
27996: LD_INT 1
27998: NEG
27999: PUSH
28000: LD_INT 1
28002: PUSH
28003: EMPTY
28004: LIST
28005: LIST
28006: PUSH
28007: LD_INT 2
28009: NEG
28010: PUSH
28011: LD_INT 0
28013: PUSH
28014: EMPTY
28015: LIST
28016: LIST
28017: PUSH
28018: LD_INT 2
28020: NEG
28021: PUSH
28022: LD_INT 1
28024: NEG
28025: PUSH
28026: EMPTY
28027: LIST
28028: LIST
28029: PUSH
28030: LD_INT 2
28032: NEG
28033: PUSH
28034: LD_INT 2
28036: NEG
28037: PUSH
28038: EMPTY
28039: LIST
28040: LIST
28041: PUSH
28042: LD_INT 2
28044: NEG
28045: PUSH
28046: LD_INT 3
28048: NEG
28049: PUSH
28050: EMPTY
28051: LIST
28052: LIST
28053: PUSH
28054: LD_INT 1
28056: NEG
28057: PUSH
28058: LD_INT 3
28060: NEG
28061: PUSH
28062: EMPTY
28063: LIST
28064: LIST
28065: PUSH
28066: LD_INT 1
28068: PUSH
28069: LD_INT 2
28071: NEG
28072: PUSH
28073: EMPTY
28074: LIST
28075: LIST
28076: PUSH
28077: LD_INT 2
28079: PUSH
28080: LD_INT 1
28082: NEG
28083: PUSH
28084: EMPTY
28085: LIST
28086: LIST
28087: PUSH
28088: EMPTY
28089: LIST
28090: LIST
28091: LIST
28092: LIST
28093: LIST
28094: LIST
28095: LIST
28096: LIST
28097: LIST
28098: LIST
28099: LIST
28100: LIST
28101: LIST
28102: LIST
28103: LIST
28104: LIST
28105: LIST
28106: LIST
28107: LIST
28108: LIST
28109: LIST
28110: LIST
28111: LIST
28112: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
28113: LD_ADDR_VAR 0 24
28117: PUSH
28118: LD_INT 0
28120: PUSH
28121: LD_INT 0
28123: PUSH
28124: EMPTY
28125: LIST
28126: LIST
28127: PUSH
28128: LD_INT 0
28130: PUSH
28131: LD_INT 1
28133: NEG
28134: PUSH
28135: EMPTY
28136: LIST
28137: LIST
28138: PUSH
28139: LD_INT 1
28141: PUSH
28142: LD_INT 0
28144: PUSH
28145: EMPTY
28146: LIST
28147: LIST
28148: PUSH
28149: LD_INT 1
28151: PUSH
28152: LD_INT 1
28154: PUSH
28155: EMPTY
28156: LIST
28157: LIST
28158: PUSH
28159: LD_INT 0
28161: PUSH
28162: LD_INT 1
28164: PUSH
28165: EMPTY
28166: LIST
28167: LIST
28168: PUSH
28169: LD_INT 1
28171: NEG
28172: PUSH
28173: LD_INT 0
28175: PUSH
28176: EMPTY
28177: LIST
28178: LIST
28179: PUSH
28180: LD_INT 1
28182: NEG
28183: PUSH
28184: LD_INT 1
28186: NEG
28187: PUSH
28188: EMPTY
28189: LIST
28190: LIST
28191: PUSH
28192: LD_INT 1
28194: NEG
28195: PUSH
28196: LD_INT 2
28198: NEG
28199: PUSH
28200: EMPTY
28201: LIST
28202: LIST
28203: PUSH
28204: LD_INT 0
28206: PUSH
28207: LD_INT 2
28209: NEG
28210: PUSH
28211: EMPTY
28212: LIST
28213: LIST
28214: PUSH
28215: LD_INT 1
28217: PUSH
28218: LD_INT 1
28220: NEG
28221: PUSH
28222: EMPTY
28223: LIST
28224: LIST
28225: PUSH
28226: LD_INT 2
28228: PUSH
28229: LD_INT 0
28231: PUSH
28232: EMPTY
28233: LIST
28234: LIST
28235: PUSH
28236: LD_INT 2
28238: PUSH
28239: LD_INT 1
28241: PUSH
28242: EMPTY
28243: LIST
28244: LIST
28245: PUSH
28246: LD_INT 2
28248: PUSH
28249: LD_INT 2
28251: PUSH
28252: EMPTY
28253: LIST
28254: LIST
28255: PUSH
28256: LD_INT 1
28258: PUSH
28259: LD_INT 2
28261: PUSH
28262: EMPTY
28263: LIST
28264: LIST
28265: PUSH
28266: LD_INT 0
28268: PUSH
28269: LD_INT 2
28271: PUSH
28272: EMPTY
28273: LIST
28274: LIST
28275: PUSH
28276: LD_INT 1
28278: NEG
28279: PUSH
28280: LD_INT 1
28282: PUSH
28283: EMPTY
28284: LIST
28285: LIST
28286: PUSH
28287: LD_INT 2
28289: NEG
28290: PUSH
28291: LD_INT 0
28293: PUSH
28294: EMPTY
28295: LIST
28296: LIST
28297: PUSH
28298: LD_INT 2
28300: NEG
28301: PUSH
28302: LD_INT 1
28304: NEG
28305: PUSH
28306: EMPTY
28307: LIST
28308: LIST
28309: PUSH
28310: LD_INT 2
28312: NEG
28313: PUSH
28314: LD_INT 2
28316: NEG
28317: PUSH
28318: EMPTY
28319: LIST
28320: LIST
28321: PUSH
28322: LD_INT 1
28324: PUSH
28325: LD_INT 2
28327: NEG
28328: PUSH
28329: EMPTY
28330: LIST
28331: LIST
28332: PUSH
28333: LD_INT 2
28335: PUSH
28336: LD_INT 1
28338: NEG
28339: PUSH
28340: EMPTY
28341: LIST
28342: LIST
28343: PUSH
28344: LD_INT 3
28346: PUSH
28347: LD_INT 1
28349: PUSH
28350: EMPTY
28351: LIST
28352: LIST
28353: PUSH
28354: LD_INT 3
28356: PUSH
28357: LD_INT 2
28359: PUSH
28360: EMPTY
28361: LIST
28362: LIST
28363: PUSH
28364: EMPTY
28365: LIST
28366: LIST
28367: LIST
28368: LIST
28369: LIST
28370: LIST
28371: LIST
28372: LIST
28373: LIST
28374: LIST
28375: LIST
28376: LIST
28377: LIST
28378: LIST
28379: LIST
28380: LIST
28381: LIST
28382: LIST
28383: LIST
28384: LIST
28385: LIST
28386: LIST
28387: LIST
28388: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
28389: LD_ADDR_VAR 0 25
28393: PUSH
28394: LD_INT 0
28396: PUSH
28397: LD_INT 0
28399: PUSH
28400: EMPTY
28401: LIST
28402: LIST
28403: PUSH
28404: LD_INT 0
28406: PUSH
28407: LD_INT 1
28409: NEG
28410: PUSH
28411: EMPTY
28412: LIST
28413: LIST
28414: PUSH
28415: LD_INT 1
28417: PUSH
28418: LD_INT 0
28420: PUSH
28421: EMPTY
28422: LIST
28423: LIST
28424: PUSH
28425: LD_INT 1
28427: PUSH
28428: LD_INT 1
28430: PUSH
28431: EMPTY
28432: LIST
28433: LIST
28434: PUSH
28435: LD_INT 0
28437: PUSH
28438: LD_INT 1
28440: PUSH
28441: EMPTY
28442: LIST
28443: LIST
28444: PUSH
28445: LD_INT 1
28447: NEG
28448: PUSH
28449: LD_INT 0
28451: PUSH
28452: EMPTY
28453: LIST
28454: LIST
28455: PUSH
28456: LD_INT 1
28458: NEG
28459: PUSH
28460: LD_INT 1
28462: NEG
28463: PUSH
28464: EMPTY
28465: LIST
28466: LIST
28467: PUSH
28468: LD_INT 1
28470: NEG
28471: PUSH
28472: LD_INT 2
28474: NEG
28475: PUSH
28476: EMPTY
28477: LIST
28478: LIST
28479: PUSH
28480: LD_INT 0
28482: PUSH
28483: LD_INT 2
28485: NEG
28486: PUSH
28487: EMPTY
28488: LIST
28489: LIST
28490: PUSH
28491: LD_INT 1
28493: PUSH
28494: LD_INT 1
28496: NEG
28497: PUSH
28498: EMPTY
28499: LIST
28500: LIST
28501: PUSH
28502: LD_INT 2
28504: PUSH
28505: LD_INT 0
28507: PUSH
28508: EMPTY
28509: LIST
28510: LIST
28511: PUSH
28512: LD_INT 2
28514: PUSH
28515: LD_INT 1
28517: PUSH
28518: EMPTY
28519: LIST
28520: LIST
28521: PUSH
28522: LD_INT 2
28524: PUSH
28525: LD_INT 2
28527: PUSH
28528: EMPTY
28529: LIST
28530: LIST
28531: PUSH
28532: LD_INT 1
28534: PUSH
28535: LD_INT 2
28537: PUSH
28538: EMPTY
28539: LIST
28540: LIST
28541: PUSH
28542: LD_INT 0
28544: PUSH
28545: LD_INT 2
28547: PUSH
28548: EMPTY
28549: LIST
28550: LIST
28551: PUSH
28552: LD_INT 1
28554: NEG
28555: PUSH
28556: LD_INT 1
28558: PUSH
28559: EMPTY
28560: LIST
28561: LIST
28562: PUSH
28563: LD_INT 2
28565: NEG
28566: PUSH
28567: LD_INT 0
28569: PUSH
28570: EMPTY
28571: LIST
28572: LIST
28573: PUSH
28574: LD_INT 2
28576: NEG
28577: PUSH
28578: LD_INT 1
28580: NEG
28581: PUSH
28582: EMPTY
28583: LIST
28584: LIST
28585: PUSH
28586: LD_INT 2
28588: NEG
28589: PUSH
28590: LD_INT 2
28592: NEG
28593: PUSH
28594: EMPTY
28595: LIST
28596: LIST
28597: PUSH
28598: LD_INT 3
28600: PUSH
28601: LD_INT 1
28603: PUSH
28604: EMPTY
28605: LIST
28606: LIST
28607: PUSH
28608: LD_INT 3
28610: PUSH
28611: LD_INT 2
28613: PUSH
28614: EMPTY
28615: LIST
28616: LIST
28617: PUSH
28618: LD_INT 2
28620: PUSH
28621: LD_INT 3
28623: PUSH
28624: EMPTY
28625: LIST
28626: LIST
28627: PUSH
28628: LD_INT 1
28630: PUSH
28631: LD_INT 3
28633: PUSH
28634: EMPTY
28635: LIST
28636: LIST
28637: PUSH
28638: EMPTY
28639: LIST
28640: LIST
28641: LIST
28642: LIST
28643: LIST
28644: LIST
28645: LIST
28646: LIST
28647: LIST
28648: LIST
28649: LIST
28650: LIST
28651: LIST
28652: LIST
28653: LIST
28654: LIST
28655: LIST
28656: LIST
28657: LIST
28658: LIST
28659: LIST
28660: LIST
28661: LIST
28662: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
28663: LD_ADDR_VAR 0 26
28667: PUSH
28668: LD_INT 0
28670: PUSH
28671: LD_INT 0
28673: PUSH
28674: EMPTY
28675: LIST
28676: LIST
28677: PUSH
28678: LD_INT 0
28680: PUSH
28681: LD_INT 1
28683: NEG
28684: PUSH
28685: EMPTY
28686: LIST
28687: LIST
28688: PUSH
28689: LD_INT 1
28691: PUSH
28692: LD_INT 0
28694: PUSH
28695: EMPTY
28696: LIST
28697: LIST
28698: PUSH
28699: LD_INT 1
28701: PUSH
28702: LD_INT 1
28704: PUSH
28705: EMPTY
28706: LIST
28707: LIST
28708: PUSH
28709: LD_INT 0
28711: PUSH
28712: LD_INT 1
28714: PUSH
28715: EMPTY
28716: LIST
28717: LIST
28718: PUSH
28719: LD_INT 1
28721: NEG
28722: PUSH
28723: LD_INT 0
28725: PUSH
28726: EMPTY
28727: LIST
28728: LIST
28729: PUSH
28730: LD_INT 1
28732: NEG
28733: PUSH
28734: LD_INT 1
28736: NEG
28737: PUSH
28738: EMPTY
28739: LIST
28740: LIST
28741: PUSH
28742: LD_INT 1
28744: NEG
28745: PUSH
28746: LD_INT 2
28748: NEG
28749: PUSH
28750: EMPTY
28751: LIST
28752: LIST
28753: PUSH
28754: LD_INT 0
28756: PUSH
28757: LD_INT 2
28759: NEG
28760: PUSH
28761: EMPTY
28762: LIST
28763: LIST
28764: PUSH
28765: LD_INT 1
28767: PUSH
28768: LD_INT 1
28770: NEG
28771: PUSH
28772: EMPTY
28773: LIST
28774: LIST
28775: PUSH
28776: LD_INT 2
28778: PUSH
28779: LD_INT 0
28781: PUSH
28782: EMPTY
28783: LIST
28784: LIST
28785: PUSH
28786: LD_INT 2
28788: PUSH
28789: LD_INT 1
28791: PUSH
28792: EMPTY
28793: LIST
28794: LIST
28795: PUSH
28796: LD_INT 2
28798: PUSH
28799: LD_INT 2
28801: PUSH
28802: EMPTY
28803: LIST
28804: LIST
28805: PUSH
28806: LD_INT 1
28808: PUSH
28809: LD_INT 2
28811: PUSH
28812: EMPTY
28813: LIST
28814: LIST
28815: PUSH
28816: LD_INT 0
28818: PUSH
28819: LD_INT 2
28821: PUSH
28822: EMPTY
28823: LIST
28824: LIST
28825: PUSH
28826: LD_INT 1
28828: NEG
28829: PUSH
28830: LD_INT 1
28832: PUSH
28833: EMPTY
28834: LIST
28835: LIST
28836: PUSH
28837: LD_INT 2
28839: NEG
28840: PUSH
28841: LD_INT 0
28843: PUSH
28844: EMPTY
28845: LIST
28846: LIST
28847: PUSH
28848: LD_INT 2
28850: NEG
28851: PUSH
28852: LD_INT 1
28854: NEG
28855: PUSH
28856: EMPTY
28857: LIST
28858: LIST
28859: PUSH
28860: LD_INT 2
28862: NEG
28863: PUSH
28864: LD_INT 2
28866: NEG
28867: PUSH
28868: EMPTY
28869: LIST
28870: LIST
28871: PUSH
28872: LD_INT 2
28874: PUSH
28875: LD_INT 3
28877: PUSH
28878: EMPTY
28879: LIST
28880: LIST
28881: PUSH
28882: LD_INT 1
28884: PUSH
28885: LD_INT 3
28887: PUSH
28888: EMPTY
28889: LIST
28890: LIST
28891: PUSH
28892: LD_INT 1
28894: NEG
28895: PUSH
28896: LD_INT 2
28898: PUSH
28899: EMPTY
28900: LIST
28901: LIST
28902: PUSH
28903: LD_INT 2
28905: NEG
28906: PUSH
28907: LD_INT 1
28909: PUSH
28910: EMPTY
28911: LIST
28912: LIST
28913: PUSH
28914: EMPTY
28915: LIST
28916: LIST
28917: LIST
28918: LIST
28919: LIST
28920: LIST
28921: LIST
28922: LIST
28923: LIST
28924: LIST
28925: LIST
28926: LIST
28927: LIST
28928: LIST
28929: LIST
28930: LIST
28931: LIST
28932: LIST
28933: LIST
28934: LIST
28935: LIST
28936: LIST
28937: LIST
28938: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
28939: LD_ADDR_VAR 0 27
28943: PUSH
28944: LD_INT 0
28946: PUSH
28947: LD_INT 0
28949: PUSH
28950: EMPTY
28951: LIST
28952: LIST
28953: PUSH
28954: LD_INT 0
28956: PUSH
28957: LD_INT 1
28959: NEG
28960: PUSH
28961: EMPTY
28962: LIST
28963: LIST
28964: PUSH
28965: LD_INT 1
28967: PUSH
28968: LD_INT 0
28970: PUSH
28971: EMPTY
28972: LIST
28973: LIST
28974: PUSH
28975: LD_INT 1
28977: PUSH
28978: LD_INT 1
28980: PUSH
28981: EMPTY
28982: LIST
28983: LIST
28984: PUSH
28985: LD_INT 0
28987: PUSH
28988: LD_INT 1
28990: PUSH
28991: EMPTY
28992: LIST
28993: LIST
28994: PUSH
28995: LD_INT 1
28997: NEG
28998: PUSH
28999: LD_INT 0
29001: PUSH
29002: EMPTY
29003: LIST
29004: LIST
29005: PUSH
29006: LD_INT 1
29008: NEG
29009: PUSH
29010: LD_INT 1
29012: NEG
29013: PUSH
29014: EMPTY
29015: LIST
29016: LIST
29017: PUSH
29018: LD_INT 1
29020: NEG
29021: PUSH
29022: LD_INT 2
29024: NEG
29025: PUSH
29026: EMPTY
29027: LIST
29028: LIST
29029: PUSH
29030: LD_INT 0
29032: PUSH
29033: LD_INT 2
29035: NEG
29036: PUSH
29037: EMPTY
29038: LIST
29039: LIST
29040: PUSH
29041: LD_INT 1
29043: PUSH
29044: LD_INT 1
29046: NEG
29047: PUSH
29048: EMPTY
29049: LIST
29050: LIST
29051: PUSH
29052: LD_INT 2
29054: PUSH
29055: LD_INT 0
29057: PUSH
29058: EMPTY
29059: LIST
29060: LIST
29061: PUSH
29062: LD_INT 2
29064: PUSH
29065: LD_INT 1
29067: PUSH
29068: EMPTY
29069: LIST
29070: LIST
29071: PUSH
29072: LD_INT 2
29074: PUSH
29075: LD_INT 2
29077: PUSH
29078: EMPTY
29079: LIST
29080: LIST
29081: PUSH
29082: LD_INT 1
29084: PUSH
29085: LD_INT 2
29087: PUSH
29088: EMPTY
29089: LIST
29090: LIST
29091: PUSH
29092: LD_INT 0
29094: PUSH
29095: LD_INT 2
29097: PUSH
29098: EMPTY
29099: LIST
29100: LIST
29101: PUSH
29102: LD_INT 1
29104: NEG
29105: PUSH
29106: LD_INT 1
29108: PUSH
29109: EMPTY
29110: LIST
29111: LIST
29112: PUSH
29113: LD_INT 2
29115: NEG
29116: PUSH
29117: LD_INT 0
29119: PUSH
29120: EMPTY
29121: LIST
29122: LIST
29123: PUSH
29124: LD_INT 2
29126: NEG
29127: PUSH
29128: LD_INT 1
29130: NEG
29131: PUSH
29132: EMPTY
29133: LIST
29134: LIST
29135: PUSH
29136: LD_INT 2
29138: NEG
29139: PUSH
29140: LD_INT 2
29142: NEG
29143: PUSH
29144: EMPTY
29145: LIST
29146: LIST
29147: PUSH
29148: LD_INT 1
29150: NEG
29151: PUSH
29152: LD_INT 2
29154: PUSH
29155: EMPTY
29156: LIST
29157: LIST
29158: PUSH
29159: LD_INT 2
29161: NEG
29162: PUSH
29163: LD_INT 1
29165: PUSH
29166: EMPTY
29167: LIST
29168: LIST
29169: PUSH
29170: LD_INT 3
29172: NEG
29173: PUSH
29174: LD_INT 1
29176: NEG
29177: PUSH
29178: EMPTY
29179: LIST
29180: LIST
29181: PUSH
29182: LD_INT 3
29184: NEG
29185: PUSH
29186: LD_INT 2
29188: NEG
29189: PUSH
29190: EMPTY
29191: LIST
29192: LIST
29193: PUSH
29194: EMPTY
29195: LIST
29196: LIST
29197: LIST
29198: LIST
29199: LIST
29200: LIST
29201: LIST
29202: LIST
29203: LIST
29204: LIST
29205: LIST
29206: LIST
29207: LIST
29208: LIST
29209: LIST
29210: LIST
29211: LIST
29212: LIST
29213: LIST
29214: LIST
29215: LIST
29216: LIST
29217: LIST
29218: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
29219: LD_ADDR_VAR 0 28
29223: PUSH
29224: LD_INT 0
29226: PUSH
29227: LD_INT 0
29229: PUSH
29230: EMPTY
29231: LIST
29232: LIST
29233: PUSH
29234: LD_INT 0
29236: PUSH
29237: LD_INT 1
29239: NEG
29240: PUSH
29241: EMPTY
29242: LIST
29243: LIST
29244: PUSH
29245: LD_INT 1
29247: PUSH
29248: LD_INT 0
29250: PUSH
29251: EMPTY
29252: LIST
29253: LIST
29254: PUSH
29255: LD_INT 1
29257: PUSH
29258: LD_INT 1
29260: PUSH
29261: EMPTY
29262: LIST
29263: LIST
29264: PUSH
29265: LD_INT 0
29267: PUSH
29268: LD_INT 1
29270: PUSH
29271: EMPTY
29272: LIST
29273: LIST
29274: PUSH
29275: LD_INT 1
29277: NEG
29278: PUSH
29279: LD_INT 0
29281: PUSH
29282: EMPTY
29283: LIST
29284: LIST
29285: PUSH
29286: LD_INT 1
29288: NEG
29289: PUSH
29290: LD_INT 1
29292: NEG
29293: PUSH
29294: EMPTY
29295: LIST
29296: LIST
29297: PUSH
29298: LD_INT 1
29300: NEG
29301: PUSH
29302: LD_INT 2
29304: NEG
29305: PUSH
29306: EMPTY
29307: LIST
29308: LIST
29309: PUSH
29310: LD_INT 0
29312: PUSH
29313: LD_INT 2
29315: NEG
29316: PUSH
29317: EMPTY
29318: LIST
29319: LIST
29320: PUSH
29321: LD_INT 1
29323: PUSH
29324: LD_INT 1
29326: NEG
29327: PUSH
29328: EMPTY
29329: LIST
29330: LIST
29331: PUSH
29332: LD_INT 2
29334: PUSH
29335: LD_INT 0
29337: PUSH
29338: EMPTY
29339: LIST
29340: LIST
29341: PUSH
29342: LD_INT 2
29344: PUSH
29345: LD_INT 1
29347: PUSH
29348: EMPTY
29349: LIST
29350: LIST
29351: PUSH
29352: LD_INT 2
29354: PUSH
29355: LD_INT 2
29357: PUSH
29358: EMPTY
29359: LIST
29360: LIST
29361: PUSH
29362: LD_INT 1
29364: PUSH
29365: LD_INT 2
29367: PUSH
29368: EMPTY
29369: LIST
29370: LIST
29371: PUSH
29372: LD_INT 0
29374: PUSH
29375: LD_INT 2
29377: PUSH
29378: EMPTY
29379: LIST
29380: LIST
29381: PUSH
29382: LD_INT 1
29384: NEG
29385: PUSH
29386: LD_INT 1
29388: PUSH
29389: EMPTY
29390: LIST
29391: LIST
29392: PUSH
29393: LD_INT 2
29395: NEG
29396: PUSH
29397: LD_INT 0
29399: PUSH
29400: EMPTY
29401: LIST
29402: LIST
29403: PUSH
29404: LD_INT 2
29406: NEG
29407: PUSH
29408: LD_INT 1
29410: NEG
29411: PUSH
29412: EMPTY
29413: LIST
29414: LIST
29415: PUSH
29416: LD_INT 2
29418: NEG
29419: PUSH
29420: LD_INT 2
29422: NEG
29423: PUSH
29424: EMPTY
29425: LIST
29426: LIST
29427: PUSH
29428: LD_INT 2
29430: NEG
29431: PUSH
29432: LD_INT 3
29434: NEG
29435: PUSH
29436: EMPTY
29437: LIST
29438: LIST
29439: PUSH
29440: LD_INT 1
29442: NEG
29443: PUSH
29444: LD_INT 3
29446: NEG
29447: PUSH
29448: EMPTY
29449: LIST
29450: LIST
29451: PUSH
29452: LD_INT 3
29454: NEG
29455: PUSH
29456: LD_INT 1
29458: NEG
29459: PUSH
29460: EMPTY
29461: LIST
29462: LIST
29463: PUSH
29464: LD_INT 3
29466: NEG
29467: PUSH
29468: LD_INT 2
29470: NEG
29471: PUSH
29472: EMPTY
29473: LIST
29474: LIST
29475: PUSH
29476: EMPTY
29477: LIST
29478: LIST
29479: LIST
29480: LIST
29481: LIST
29482: LIST
29483: LIST
29484: LIST
29485: LIST
29486: LIST
29487: LIST
29488: LIST
29489: LIST
29490: LIST
29491: LIST
29492: LIST
29493: LIST
29494: LIST
29495: LIST
29496: LIST
29497: LIST
29498: LIST
29499: LIST
29500: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
29501: LD_ADDR_VAR 0 29
29505: PUSH
29506: LD_INT 0
29508: PUSH
29509: LD_INT 0
29511: PUSH
29512: EMPTY
29513: LIST
29514: LIST
29515: PUSH
29516: LD_INT 0
29518: PUSH
29519: LD_INT 1
29521: NEG
29522: PUSH
29523: EMPTY
29524: LIST
29525: LIST
29526: PUSH
29527: LD_INT 1
29529: PUSH
29530: LD_INT 0
29532: PUSH
29533: EMPTY
29534: LIST
29535: LIST
29536: PUSH
29537: LD_INT 1
29539: PUSH
29540: LD_INT 1
29542: PUSH
29543: EMPTY
29544: LIST
29545: LIST
29546: PUSH
29547: LD_INT 0
29549: PUSH
29550: LD_INT 1
29552: PUSH
29553: EMPTY
29554: LIST
29555: LIST
29556: PUSH
29557: LD_INT 1
29559: NEG
29560: PUSH
29561: LD_INT 0
29563: PUSH
29564: EMPTY
29565: LIST
29566: LIST
29567: PUSH
29568: LD_INT 1
29570: NEG
29571: PUSH
29572: LD_INT 1
29574: NEG
29575: PUSH
29576: EMPTY
29577: LIST
29578: LIST
29579: PUSH
29580: LD_INT 1
29582: NEG
29583: PUSH
29584: LD_INT 2
29586: NEG
29587: PUSH
29588: EMPTY
29589: LIST
29590: LIST
29591: PUSH
29592: LD_INT 0
29594: PUSH
29595: LD_INT 2
29597: NEG
29598: PUSH
29599: EMPTY
29600: LIST
29601: LIST
29602: PUSH
29603: LD_INT 1
29605: PUSH
29606: LD_INT 1
29608: NEG
29609: PUSH
29610: EMPTY
29611: LIST
29612: LIST
29613: PUSH
29614: LD_INT 2
29616: PUSH
29617: LD_INT 0
29619: PUSH
29620: EMPTY
29621: LIST
29622: LIST
29623: PUSH
29624: LD_INT 2
29626: PUSH
29627: LD_INT 1
29629: PUSH
29630: EMPTY
29631: LIST
29632: LIST
29633: PUSH
29634: LD_INT 1
29636: PUSH
29637: LD_INT 2
29639: PUSH
29640: EMPTY
29641: LIST
29642: LIST
29643: PUSH
29644: LD_INT 0
29646: PUSH
29647: LD_INT 2
29649: PUSH
29650: EMPTY
29651: LIST
29652: LIST
29653: PUSH
29654: LD_INT 1
29656: NEG
29657: PUSH
29658: LD_INT 1
29660: PUSH
29661: EMPTY
29662: LIST
29663: LIST
29664: PUSH
29665: LD_INT 2
29667: NEG
29668: PUSH
29669: LD_INT 1
29671: NEG
29672: PUSH
29673: EMPTY
29674: LIST
29675: LIST
29676: PUSH
29677: LD_INT 2
29679: NEG
29680: PUSH
29681: LD_INT 2
29683: NEG
29684: PUSH
29685: EMPTY
29686: LIST
29687: LIST
29688: PUSH
29689: LD_INT 2
29691: NEG
29692: PUSH
29693: LD_INT 3
29695: NEG
29696: PUSH
29697: EMPTY
29698: LIST
29699: LIST
29700: PUSH
29701: LD_INT 2
29703: PUSH
29704: LD_INT 1
29706: NEG
29707: PUSH
29708: EMPTY
29709: LIST
29710: LIST
29711: PUSH
29712: LD_INT 3
29714: PUSH
29715: LD_INT 1
29717: PUSH
29718: EMPTY
29719: LIST
29720: LIST
29721: PUSH
29722: LD_INT 1
29724: PUSH
29725: LD_INT 3
29727: PUSH
29728: EMPTY
29729: LIST
29730: LIST
29731: PUSH
29732: LD_INT 1
29734: NEG
29735: PUSH
29736: LD_INT 2
29738: PUSH
29739: EMPTY
29740: LIST
29741: LIST
29742: PUSH
29743: LD_INT 3
29745: NEG
29746: PUSH
29747: LD_INT 2
29749: NEG
29750: PUSH
29751: EMPTY
29752: LIST
29753: LIST
29754: PUSH
29755: EMPTY
29756: LIST
29757: LIST
29758: LIST
29759: LIST
29760: LIST
29761: LIST
29762: LIST
29763: LIST
29764: LIST
29765: LIST
29766: LIST
29767: LIST
29768: LIST
29769: LIST
29770: LIST
29771: LIST
29772: LIST
29773: LIST
29774: LIST
29775: LIST
29776: LIST
29777: LIST
29778: LIST
29779: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
29780: LD_ADDR_VAR 0 30
29784: PUSH
29785: LD_INT 0
29787: PUSH
29788: LD_INT 0
29790: PUSH
29791: EMPTY
29792: LIST
29793: LIST
29794: PUSH
29795: LD_INT 0
29797: PUSH
29798: LD_INT 1
29800: NEG
29801: PUSH
29802: EMPTY
29803: LIST
29804: LIST
29805: PUSH
29806: LD_INT 1
29808: PUSH
29809: LD_INT 0
29811: PUSH
29812: EMPTY
29813: LIST
29814: LIST
29815: PUSH
29816: LD_INT 1
29818: PUSH
29819: LD_INT 1
29821: PUSH
29822: EMPTY
29823: LIST
29824: LIST
29825: PUSH
29826: LD_INT 0
29828: PUSH
29829: LD_INT 1
29831: PUSH
29832: EMPTY
29833: LIST
29834: LIST
29835: PUSH
29836: LD_INT 1
29838: NEG
29839: PUSH
29840: LD_INT 0
29842: PUSH
29843: EMPTY
29844: LIST
29845: LIST
29846: PUSH
29847: LD_INT 1
29849: NEG
29850: PUSH
29851: LD_INT 1
29853: NEG
29854: PUSH
29855: EMPTY
29856: LIST
29857: LIST
29858: PUSH
29859: LD_INT 1
29861: NEG
29862: PUSH
29863: LD_INT 2
29865: NEG
29866: PUSH
29867: EMPTY
29868: LIST
29869: LIST
29870: PUSH
29871: LD_INT 0
29873: PUSH
29874: LD_INT 2
29876: NEG
29877: PUSH
29878: EMPTY
29879: LIST
29880: LIST
29881: PUSH
29882: LD_INT 1
29884: PUSH
29885: LD_INT 1
29887: NEG
29888: PUSH
29889: EMPTY
29890: LIST
29891: LIST
29892: PUSH
29893: LD_INT 2
29895: PUSH
29896: LD_INT 0
29898: PUSH
29899: EMPTY
29900: LIST
29901: LIST
29902: PUSH
29903: LD_INT 2
29905: PUSH
29906: LD_INT 1
29908: PUSH
29909: EMPTY
29910: LIST
29911: LIST
29912: PUSH
29913: LD_INT 2
29915: PUSH
29916: LD_INT 2
29918: PUSH
29919: EMPTY
29920: LIST
29921: LIST
29922: PUSH
29923: LD_INT 1
29925: PUSH
29926: LD_INT 2
29928: PUSH
29929: EMPTY
29930: LIST
29931: LIST
29932: PUSH
29933: LD_INT 1
29935: NEG
29936: PUSH
29937: LD_INT 1
29939: PUSH
29940: EMPTY
29941: LIST
29942: LIST
29943: PUSH
29944: LD_INT 2
29946: NEG
29947: PUSH
29948: LD_INT 0
29950: PUSH
29951: EMPTY
29952: LIST
29953: LIST
29954: PUSH
29955: LD_INT 2
29957: NEG
29958: PUSH
29959: LD_INT 1
29961: NEG
29962: PUSH
29963: EMPTY
29964: LIST
29965: LIST
29966: PUSH
29967: LD_INT 1
29969: NEG
29970: PUSH
29971: LD_INT 3
29973: NEG
29974: PUSH
29975: EMPTY
29976: LIST
29977: LIST
29978: PUSH
29979: LD_INT 1
29981: PUSH
29982: LD_INT 2
29984: NEG
29985: PUSH
29986: EMPTY
29987: LIST
29988: LIST
29989: PUSH
29990: LD_INT 3
29992: PUSH
29993: LD_INT 2
29995: PUSH
29996: EMPTY
29997: LIST
29998: LIST
29999: PUSH
30000: LD_INT 2
30002: PUSH
30003: LD_INT 3
30005: PUSH
30006: EMPTY
30007: LIST
30008: LIST
30009: PUSH
30010: LD_INT 2
30012: NEG
30013: PUSH
30014: LD_INT 1
30016: PUSH
30017: EMPTY
30018: LIST
30019: LIST
30020: PUSH
30021: LD_INT 3
30023: NEG
30024: PUSH
30025: LD_INT 1
30027: NEG
30028: PUSH
30029: EMPTY
30030: LIST
30031: LIST
30032: PUSH
30033: EMPTY
30034: LIST
30035: LIST
30036: LIST
30037: LIST
30038: LIST
30039: LIST
30040: LIST
30041: LIST
30042: LIST
30043: LIST
30044: LIST
30045: LIST
30046: LIST
30047: LIST
30048: LIST
30049: LIST
30050: LIST
30051: LIST
30052: LIST
30053: LIST
30054: LIST
30055: LIST
30056: LIST
30057: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
30058: LD_ADDR_VAR 0 31
30062: PUSH
30063: LD_INT 0
30065: PUSH
30066: LD_INT 0
30068: PUSH
30069: EMPTY
30070: LIST
30071: LIST
30072: PUSH
30073: LD_INT 0
30075: PUSH
30076: LD_INT 1
30078: NEG
30079: PUSH
30080: EMPTY
30081: LIST
30082: LIST
30083: PUSH
30084: LD_INT 1
30086: PUSH
30087: LD_INT 0
30089: PUSH
30090: EMPTY
30091: LIST
30092: LIST
30093: PUSH
30094: LD_INT 1
30096: PUSH
30097: LD_INT 1
30099: PUSH
30100: EMPTY
30101: LIST
30102: LIST
30103: PUSH
30104: LD_INT 0
30106: PUSH
30107: LD_INT 1
30109: PUSH
30110: EMPTY
30111: LIST
30112: LIST
30113: PUSH
30114: LD_INT 1
30116: NEG
30117: PUSH
30118: LD_INT 0
30120: PUSH
30121: EMPTY
30122: LIST
30123: LIST
30124: PUSH
30125: LD_INT 1
30127: NEG
30128: PUSH
30129: LD_INT 1
30131: NEG
30132: PUSH
30133: EMPTY
30134: LIST
30135: LIST
30136: PUSH
30137: LD_INT 1
30139: NEG
30140: PUSH
30141: LD_INT 2
30143: NEG
30144: PUSH
30145: EMPTY
30146: LIST
30147: LIST
30148: PUSH
30149: LD_INT 1
30151: PUSH
30152: LD_INT 1
30154: NEG
30155: PUSH
30156: EMPTY
30157: LIST
30158: LIST
30159: PUSH
30160: LD_INT 2
30162: PUSH
30163: LD_INT 0
30165: PUSH
30166: EMPTY
30167: LIST
30168: LIST
30169: PUSH
30170: LD_INT 2
30172: PUSH
30173: LD_INT 1
30175: PUSH
30176: EMPTY
30177: LIST
30178: LIST
30179: PUSH
30180: LD_INT 2
30182: PUSH
30183: LD_INT 2
30185: PUSH
30186: EMPTY
30187: LIST
30188: LIST
30189: PUSH
30190: LD_INT 1
30192: PUSH
30193: LD_INT 2
30195: PUSH
30196: EMPTY
30197: LIST
30198: LIST
30199: PUSH
30200: LD_INT 0
30202: PUSH
30203: LD_INT 2
30205: PUSH
30206: EMPTY
30207: LIST
30208: LIST
30209: PUSH
30210: LD_INT 1
30212: NEG
30213: PUSH
30214: LD_INT 1
30216: PUSH
30217: EMPTY
30218: LIST
30219: LIST
30220: PUSH
30221: LD_INT 2
30223: NEG
30224: PUSH
30225: LD_INT 1
30227: NEG
30228: PUSH
30229: EMPTY
30230: LIST
30231: LIST
30232: PUSH
30233: LD_INT 2
30235: NEG
30236: PUSH
30237: LD_INT 2
30239: NEG
30240: PUSH
30241: EMPTY
30242: LIST
30243: LIST
30244: PUSH
30245: LD_INT 2
30247: NEG
30248: PUSH
30249: LD_INT 3
30251: NEG
30252: PUSH
30253: EMPTY
30254: LIST
30255: LIST
30256: PUSH
30257: LD_INT 2
30259: PUSH
30260: LD_INT 1
30262: NEG
30263: PUSH
30264: EMPTY
30265: LIST
30266: LIST
30267: PUSH
30268: LD_INT 3
30270: PUSH
30271: LD_INT 1
30273: PUSH
30274: EMPTY
30275: LIST
30276: LIST
30277: PUSH
30278: LD_INT 1
30280: PUSH
30281: LD_INT 3
30283: PUSH
30284: EMPTY
30285: LIST
30286: LIST
30287: PUSH
30288: LD_INT 1
30290: NEG
30291: PUSH
30292: LD_INT 2
30294: PUSH
30295: EMPTY
30296: LIST
30297: LIST
30298: PUSH
30299: LD_INT 3
30301: NEG
30302: PUSH
30303: LD_INT 2
30305: NEG
30306: PUSH
30307: EMPTY
30308: LIST
30309: LIST
30310: PUSH
30311: EMPTY
30312: LIST
30313: LIST
30314: LIST
30315: LIST
30316: LIST
30317: LIST
30318: LIST
30319: LIST
30320: LIST
30321: LIST
30322: LIST
30323: LIST
30324: LIST
30325: LIST
30326: LIST
30327: LIST
30328: LIST
30329: LIST
30330: LIST
30331: LIST
30332: LIST
30333: LIST
30334: LIST
30335: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
30336: LD_ADDR_VAR 0 32
30340: PUSH
30341: LD_INT 0
30343: PUSH
30344: LD_INT 0
30346: PUSH
30347: EMPTY
30348: LIST
30349: LIST
30350: PUSH
30351: LD_INT 0
30353: PUSH
30354: LD_INT 1
30356: NEG
30357: PUSH
30358: EMPTY
30359: LIST
30360: LIST
30361: PUSH
30362: LD_INT 1
30364: PUSH
30365: LD_INT 0
30367: PUSH
30368: EMPTY
30369: LIST
30370: LIST
30371: PUSH
30372: LD_INT 1
30374: PUSH
30375: LD_INT 1
30377: PUSH
30378: EMPTY
30379: LIST
30380: LIST
30381: PUSH
30382: LD_INT 0
30384: PUSH
30385: LD_INT 1
30387: PUSH
30388: EMPTY
30389: LIST
30390: LIST
30391: PUSH
30392: LD_INT 1
30394: NEG
30395: PUSH
30396: LD_INT 0
30398: PUSH
30399: EMPTY
30400: LIST
30401: LIST
30402: PUSH
30403: LD_INT 1
30405: NEG
30406: PUSH
30407: LD_INT 1
30409: NEG
30410: PUSH
30411: EMPTY
30412: LIST
30413: LIST
30414: PUSH
30415: LD_INT 1
30417: NEG
30418: PUSH
30419: LD_INT 2
30421: NEG
30422: PUSH
30423: EMPTY
30424: LIST
30425: LIST
30426: PUSH
30427: LD_INT 0
30429: PUSH
30430: LD_INT 2
30432: NEG
30433: PUSH
30434: EMPTY
30435: LIST
30436: LIST
30437: PUSH
30438: LD_INT 1
30440: PUSH
30441: LD_INT 1
30443: NEG
30444: PUSH
30445: EMPTY
30446: LIST
30447: LIST
30448: PUSH
30449: LD_INT 2
30451: PUSH
30452: LD_INT 1
30454: PUSH
30455: EMPTY
30456: LIST
30457: LIST
30458: PUSH
30459: LD_INT 2
30461: PUSH
30462: LD_INT 2
30464: PUSH
30465: EMPTY
30466: LIST
30467: LIST
30468: PUSH
30469: LD_INT 1
30471: PUSH
30472: LD_INT 2
30474: PUSH
30475: EMPTY
30476: LIST
30477: LIST
30478: PUSH
30479: LD_INT 0
30481: PUSH
30482: LD_INT 2
30484: PUSH
30485: EMPTY
30486: LIST
30487: LIST
30488: PUSH
30489: LD_INT 1
30491: NEG
30492: PUSH
30493: LD_INT 1
30495: PUSH
30496: EMPTY
30497: LIST
30498: LIST
30499: PUSH
30500: LD_INT 2
30502: NEG
30503: PUSH
30504: LD_INT 0
30506: PUSH
30507: EMPTY
30508: LIST
30509: LIST
30510: PUSH
30511: LD_INT 2
30513: NEG
30514: PUSH
30515: LD_INT 1
30517: NEG
30518: PUSH
30519: EMPTY
30520: LIST
30521: LIST
30522: PUSH
30523: LD_INT 1
30525: NEG
30526: PUSH
30527: LD_INT 3
30529: NEG
30530: PUSH
30531: EMPTY
30532: LIST
30533: LIST
30534: PUSH
30535: LD_INT 1
30537: PUSH
30538: LD_INT 2
30540: NEG
30541: PUSH
30542: EMPTY
30543: LIST
30544: LIST
30545: PUSH
30546: LD_INT 3
30548: PUSH
30549: LD_INT 2
30551: PUSH
30552: EMPTY
30553: LIST
30554: LIST
30555: PUSH
30556: LD_INT 2
30558: PUSH
30559: LD_INT 3
30561: PUSH
30562: EMPTY
30563: LIST
30564: LIST
30565: PUSH
30566: LD_INT 2
30568: NEG
30569: PUSH
30570: LD_INT 1
30572: PUSH
30573: EMPTY
30574: LIST
30575: LIST
30576: PUSH
30577: LD_INT 3
30579: NEG
30580: PUSH
30581: LD_INT 1
30583: NEG
30584: PUSH
30585: EMPTY
30586: LIST
30587: LIST
30588: PUSH
30589: EMPTY
30590: LIST
30591: LIST
30592: LIST
30593: LIST
30594: LIST
30595: LIST
30596: LIST
30597: LIST
30598: LIST
30599: LIST
30600: LIST
30601: LIST
30602: LIST
30603: LIST
30604: LIST
30605: LIST
30606: LIST
30607: LIST
30608: LIST
30609: LIST
30610: LIST
30611: LIST
30612: LIST
30613: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
30614: LD_ADDR_VAR 0 33
30618: PUSH
30619: LD_INT 0
30621: PUSH
30622: LD_INT 0
30624: PUSH
30625: EMPTY
30626: LIST
30627: LIST
30628: PUSH
30629: LD_INT 0
30631: PUSH
30632: LD_INT 1
30634: NEG
30635: PUSH
30636: EMPTY
30637: LIST
30638: LIST
30639: PUSH
30640: LD_INT 1
30642: PUSH
30643: LD_INT 0
30645: PUSH
30646: EMPTY
30647: LIST
30648: LIST
30649: PUSH
30650: LD_INT 1
30652: PUSH
30653: LD_INT 1
30655: PUSH
30656: EMPTY
30657: LIST
30658: LIST
30659: PUSH
30660: LD_INT 0
30662: PUSH
30663: LD_INT 1
30665: PUSH
30666: EMPTY
30667: LIST
30668: LIST
30669: PUSH
30670: LD_INT 1
30672: NEG
30673: PUSH
30674: LD_INT 0
30676: PUSH
30677: EMPTY
30678: LIST
30679: LIST
30680: PUSH
30681: LD_INT 1
30683: NEG
30684: PUSH
30685: LD_INT 1
30687: NEG
30688: PUSH
30689: EMPTY
30690: LIST
30691: LIST
30692: PUSH
30693: LD_INT 1
30695: NEG
30696: PUSH
30697: LD_INT 2
30699: NEG
30700: PUSH
30701: EMPTY
30702: LIST
30703: LIST
30704: PUSH
30705: LD_INT 1
30707: PUSH
30708: LD_INT 1
30710: NEG
30711: PUSH
30712: EMPTY
30713: LIST
30714: LIST
30715: PUSH
30716: LD_INT 2
30718: PUSH
30719: LD_INT 0
30721: PUSH
30722: EMPTY
30723: LIST
30724: LIST
30725: PUSH
30726: LD_INT 2
30728: PUSH
30729: LD_INT 1
30731: PUSH
30732: EMPTY
30733: LIST
30734: LIST
30735: PUSH
30736: LD_INT 1
30738: PUSH
30739: LD_INT 2
30741: PUSH
30742: EMPTY
30743: LIST
30744: LIST
30745: PUSH
30746: LD_INT 0
30748: PUSH
30749: LD_INT 2
30751: PUSH
30752: EMPTY
30753: LIST
30754: LIST
30755: PUSH
30756: LD_INT 1
30758: NEG
30759: PUSH
30760: LD_INT 1
30762: PUSH
30763: EMPTY
30764: LIST
30765: LIST
30766: PUSH
30767: LD_INT 2
30769: NEG
30770: PUSH
30771: LD_INT 0
30773: PUSH
30774: EMPTY
30775: LIST
30776: LIST
30777: PUSH
30778: LD_INT 2
30780: NEG
30781: PUSH
30782: LD_INT 1
30784: NEG
30785: PUSH
30786: EMPTY
30787: LIST
30788: LIST
30789: PUSH
30790: LD_INT 2
30792: NEG
30793: PUSH
30794: LD_INT 2
30796: NEG
30797: PUSH
30798: EMPTY
30799: LIST
30800: LIST
30801: PUSH
30802: LD_INT 2
30804: NEG
30805: PUSH
30806: LD_INT 3
30808: NEG
30809: PUSH
30810: EMPTY
30811: LIST
30812: LIST
30813: PUSH
30814: LD_INT 2
30816: PUSH
30817: LD_INT 1
30819: NEG
30820: PUSH
30821: EMPTY
30822: LIST
30823: LIST
30824: PUSH
30825: LD_INT 3
30827: PUSH
30828: LD_INT 1
30830: PUSH
30831: EMPTY
30832: LIST
30833: LIST
30834: PUSH
30835: LD_INT 1
30837: PUSH
30838: LD_INT 3
30840: PUSH
30841: EMPTY
30842: LIST
30843: LIST
30844: PUSH
30845: LD_INT 1
30847: NEG
30848: PUSH
30849: LD_INT 2
30851: PUSH
30852: EMPTY
30853: LIST
30854: LIST
30855: PUSH
30856: LD_INT 3
30858: NEG
30859: PUSH
30860: LD_INT 2
30862: NEG
30863: PUSH
30864: EMPTY
30865: LIST
30866: LIST
30867: PUSH
30868: EMPTY
30869: LIST
30870: LIST
30871: LIST
30872: LIST
30873: LIST
30874: LIST
30875: LIST
30876: LIST
30877: LIST
30878: LIST
30879: LIST
30880: LIST
30881: LIST
30882: LIST
30883: LIST
30884: LIST
30885: LIST
30886: LIST
30887: LIST
30888: LIST
30889: LIST
30890: LIST
30891: LIST
30892: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
30893: LD_ADDR_VAR 0 34
30897: PUSH
30898: LD_INT 0
30900: PUSH
30901: LD_INT 0
30903: PUSH
30904: EMPTY
30905: LIST
30906: LIST
30907: PUSH
30908: LD_INT 0
30910: PUSH
30911: LD_INT 1
30913: NEG
30914: PUSH
30915: EMPTY
30916: LIST
30917: LIST
30918: PUSH
30919: LD_INT 1
30921: PUSH
30922: LD_INT 0
30924: PUSH
30925: EMPTY
30926: LIST
30927: LIST
30928: PUSH
30929: LD_INT 1
30931: PUSH
30932: LD_INT 1
30934: PUSH
30935: EMPTY
30936: LIST
30937: LIST
30938: PUSH
30939: LD_INT 0
30941: PUSH
30942: LD_INT 1
30944: PUSH
30945: EMPTY
30946: LIST
30947: LIST
30948: PUSH
30949: LD_INT 1
30951: NEG
30952: PUSH
30953: LD_INT 0
30955: PUSH
30956: EMPTY
30957: LIST
30958: LIST
30959: PUSH
30960: LD_INT 1
30962: NEG
30963: PUSH
30964: LD_INT 1
30966: NEG
30967: PUSH
30968: EMPTY
30969: LIST
30970: LIST
30971: PUSH
30972: LD_INT 1
30974: NEG
30975: PUSH
30976: LD_INT 2
30978: NEG
30979: PUSH
30980: EMPTY
30981: LIST
30982: LIST
30983: PUSH
30984: LD_INT 0
30986: PUSH
30987: LD_INT 2
30989: NEG
30990: PUSH
30991: EMPTY
30992: LIST
30993: LIST
30994: PUSH
30995: LD_INT 1
30997: PUSH
30998: LD_INT 1
31000: NEG
31001: PUSH
31002: EMPTY
31003: LIST
31004: LIST
31005: PUSH
31006: LD_INT 2
31008: PUSH
31009: LD_INT 1
31011: PUSH
31012: EMPTY
31013: LIST
31014: LIST
31015: PUSH
31016: LD_INT 2
31018: PUSH
31019: LD_INT 2
31021: PUSH
31022: EMPTY
31023: LIST
31024: LIST
31025: PUSH
31026: LD_INT 1
31028: PUSH
31029: LD_INT 2
31031: PUSH
31032: EMPTY
31033: LIST
31034: LIST
31035: PUSH
31036: LD_INT 1
31038: NEG
31039: PUSH
31040: LD_INT 1
31042: PUSH
31043: EMPTY
31044: LIST
31045: LIST
31046: PUSH
31047: LD_INT 2
31049: NEG
31050: PUSH
31051: LD_INT 0
31053: PUSH
31054: EMPTY
31055: LIST
31056: LIST
31057: PUSH
31058: LD_INT 2
31060: NEG
31061: PUSH
31062: LD_INT 1
31064: NEG
31065: PUSH
31066: EMPTY
31067: LIST
31068: LIST
31069: PUSH
31070: LD_INT 2
31072: NEG
31073: PUSH
31074: LD_INT 2
31076: NEG
31077: PUSH
31078: EMPTY
31079: LIST
31080: LIST
31081: PUSH
31082: LD_INT 1
31084: NEG
31085: PUSH
31086: LD_INT 3
31088: NEG
31089: PUSH
31090: EMPTY
31091: LIST
31092: LIST
31093: PUSH
31094: LD_INT 1
31096: PUSH
31097: LD_INT 2
31099: NEG
31100: PUSH
31101: EMPTY
31102: LIST
31103: LIST
31104: PUSH
31105: LD_INT 3
31107: PUSH
31108: LD_INT 2
31110: PUSH
31111: EMPTY
31112: LIST
31113: LIST
31114: PUSH
31115: LD_INT 2
31117: PUSH
31118: LD_INT 3
31120: PUSH
31121: EMPTY
31122: LIST
31123: LIST
31124: PUSH
31125: LD_INT 2
31127: NEG
31128: PUSH
31129: LD_INT 1
31131: PUSH
31132: EMPTY
31133: LIST
31134: LIST
31135: PUSH
31136: LD_INT 3
31138: NEG
31139: PUSH
31140: LD_INT 1
31142: NEG
31143: PUSH
31144: EMPTY
31145: LIST
31146: LIST
31147: PUSH
31148: EMPTY
31149: LIST
31150: LIST
31151: LIST
31152: LIST
31153: LIST
31154: LIST
31155: LIST
31156: LIST
31157: LIST
31158: LIST
31159: LIST
31160: LIST
31161: LIST
31162: LIST
31163: LIST
31164: LIST
31165: LIST
31166: LIST
31167: LIST
31168: LIST
31169: LIST
31170: LIST
31171: LIST
31172: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
31173: LD_ADDR_VAR 0 35
31177: PUSH
31178: LD_INT 0
31180: PUSH
31181: LD_INT 0
31183: PUSH
31184: EMPTY
31185: LIST
31186: LIST
31187: PUSH
31188: LD_INT 0
31190: PUSH
31191: LD_INT 1
31193: NEG
31194: PUSH
31195: EMPTY
31196: LIST
31197: LIST
31198: PUSH
31199: LD_INT 1
31201: PUSH
31202: LD_INT 0
31204: PUSH
31205: EMPTY
31206: LIST
31207: LIST
31208: PUSH
31209: LD_INT 1
31211: PUSH
31212: LD_INT 1
31214: PUSH
31215: EMPTY
31216: LIST
31217: LIST
31218: PUSH
31219: LD_INT 0
31221: PUSH
31222: LD_INT 1
31224: PUSH
31225: EMPTY
31226: LIST
31227: LIST
31228: PUSH
31229: LD_INT 1
31231: NEG
31232: PUSH
31233: LD_INT 0
31235: PUSH
31236: EMPTY
31237: LIST
31238: LIST
31239: PUSH
31240: LD_INT 1
31242: NEG
31243: PUSH
31244: LD_INT 1
31246: NEG
31247: PUSH
31248: EMPTY
31249: LIST
31250: LIST
31251: PUSH
31252: LD_INT 2
31254: PUSH
31255: LD_INT 1
31257: PUSH
31258: EMPTY
31259: LIST
31260: LIST
31261: PUSH
31262: LD_INT 2
31264: NEG
31265: PUSH
31266: LD_INT 1
31268: NEG
31269: PUSH
31270: EMPTY
31271: LIST
31272: LIST
31273: PUSH
31274: EMPTY
31275: LIST
31276: LIST
31277: LIST
31278: LIST
31279: LIST
31280: LIST
31281: LIST
31282: LIST
31283: LIST
31284: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
31285: LD_ADDR_VAR 0 36
31289: PUSH
31290: LD_INT 0
31292: PUSH
31293: LD_INT 0
31295: PUSH
31296: EMPTY
31297: LIST
31298: LIST
31299: PUSH
31300: LD_INT 0
31302: PUSH
31303: LD_INT 1
31305: NEG
31306: PUSH
31307: EMPTY
31308: LIST
31309: LIST
31310: PUSH
31311: LD_INT 1
31313: PUSH
31314: LD_INT 0
31316: PUSH
31317: EMPTY
31318: LIST
31319: LIST
31320: PUSH
31321: LD_INT 1
31323: PUSH
31324: LD_INT 1
31326: PUSH
31327: EMPTY
31328: LIST
31329: LIST
31330: PUSH
31331: LD_INT 0
31333: PUSH
31334: LD_INT 1
31336: PUSH
31337: EMPTY
31338: LIST
31339: LIST
31340: PUSH
31341: LD_INT 1
31343: NEG
31344: PUSH
31345: LD_INT 0
31347: PUSH
31348: EMPTY
31349: LIST
31350: LIST
31351: PUSH
31352: LD_INT 1
31354: NEG
31355: PUSH
31356: LD_INT 1
31358: NEG
31359: PUSH
31360: EMPTY
31361: LIST
31362: LIST
31363: PUSH
31364: LD_INT 1
31366: NEG
31367: PUSH
31368: LD_INT 2
31370: NEG
31371: PUSH
31372: EMPTY
31373: LIST
31374: LIST
31375: PUSH
31376: LD_INT 1
31378: PUSH
31379: LD_INT 2
31381: PUSH
31382: EMPTY
31383: LIST
31384: LIST
31385: PUSH
31386: EMPTY
31387: LIST
31388: LIST
31389: LIST
31390: LIST
31391: LIST
31392: LIST
31393: LIST
31394: LIST
31395: LIST
31396: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
31397: LD_ADDR_VAR 0 37
31401: PUSH
31402: LD_INT 0
31404: PUSH
31405: LD_INT 0
31407: PUSH
31408: EMPTY
31409: LIST
31410: LIST
31411: PUSH
31412: LD_INT 0
31414: PUSH
31415: LD_INT 1
31417: NEG
31418: PUSH
31419: EMPTY
31420: LIST
31421: LIST
31422: PUSH
31423: LD_INT 1
31425: PUSH
31426: LD_INT 0
31428: PUSH
31429: EMPTY
31430: LIST
31431: LIST
31432: PUSH
31433: LD_INT 1
31435: PUSH
31436: LD_INT 1
31438: PUSH
31439: EMPTY
31440: LIST
31441: LIST
31442: PUSH
31443: LD_INT 0
31445: PUSH
31446: LD_INT 1
31448: PUSH
31449: EMPTY
31450: LIST
31451: LIST
31452: PUSH
31453: LD_INT 1
31455: NEG
31456: PUSH
31457: LD_INT 0
31459: PUSH
31460: EMPTY
31461: LIST
31462: LIST
31463: PUSH
31464: LD_INT 1
31466: NEG
31467: PUSH
31468: LD_INT 1
31470: NEG
31471: PUSH
31472: EMPTY
31473: LIST
31474: LIST
31475: PUSH
31476: LD_INT 1
31478: PUSH
31479: LD_INT 1
31481: NEG
31482: PUSH
31483: EMPTY
31484: LIST
31485: LIST
31486: PUSH
31487: LD_INT 1
31489: NEG
31490: PUSH
31491: LD_INT 1
31493: PUSH
31494: EMPTY
31495: LIST
31496: LIST
31497: PUSH
31498: EMPTY
31499: LIST
31500: LIST
31501: LIST
31502: LIST
31503: LIST
31504: LIST
31505: LIST
31506: LIST
31507: LIST
31508: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
31509: LD_ADDR_VAR 0 38
31513: PUSH
31514: LD_INT 0
31516: PUSH
31517: LD_INT 0
31519: PUSH
31520: EMPTY
31521: LIST
31522: LIST
31523: PUSH
31524: LD_INT 0
31526: PUSH
31527: LD_INT 1
31529: NEG
31530: PUSH
31531: EMPTY
31532: LIST
31533: LIST
31534: PUSH
31535: LD_INT 1
31537: PUSH
31538: LD_INT 0
31540: PUSH
31541: EMPTY
31542: LIST
31543: LIST
31544: PUSH
31545: LD_INT 1
31547: PUSH
31548: LD_INT 1
31550: PUSH
31551: EMPTY
31552: LIST
31553: LIST
31554: PUSH
31555: LD_INT 0
31557: PUSH
31558: LD_INT 1
31560: PUSH
31561: EMPTY
31562: LIST
31563: LIST
31564: PUSH
31565: LD_INT 1
31567: NEG
31568: PUSH
31569: LD_INT 0
31571: PUSH
31572: EMPTY
31573: LIST
31574: LIST
31575: PUSH
31576: LD_INT 1
31578: NEG
31579: PUSH
31580: LD_INT 1
31582: NEG
31583: PUSH
31584: EMPTY
31585: LIST
31586: LIST
31587: PUSH
31588: LD_INT 2
31590: PUSH
31591: LD_INT 1
31593: PUSH
31594: EMPTY
31595: LIST
31596: LIST
31597: PUSH
31598: LD_INT 2
31600: NEG
31601: PUSH
31602: LD_INT 1
31604: NEG
31605: PUSH
31606: EMPTY
31607: LIST
31608: LIST
31609: PUSH
31610: EMPTY
31611: LIST
31612: LIST
31613: LIST
31614: LIST
31615: LIST
31616: LIST
31617: LIST
31618: LIST
31619: LIST
31620: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
31621: LD_ADDR_VAR 0 39
31625: PUSH
31626: LD_INT 0
31628: PUSH
31629: LD_INT 0
31631: PUSH
31632: EMPTY
31633: LIST
31634: LIST
31635: PUSH
31636: LD_INT 0
31638: PUSH
31639: LD_INT 1
31641: NEG
31642: PUSH
31643: EMPTY
31644: LIST
31645: LIST
31646: PUSH
31647: LD_INT 1
31649: PUSH
31650: LD_INT 0
31652: PUSH
31653: EMPTY
31654: LIST
31655: LIST
31656: PUSH
31657: LD_INT 1
31659: PUSH
31660: LD_INT 1
31662: PUSH
31663: EMPTY
31664: LIST
31665: LIST
31666: PUSH
31667: LD_INT 0
31669: PUSH
31670: LD_INT 1
31672: PUSH
31673: EMPTY
31674: LIST
31675: LIST
31676: PUSH
31677: LD_INT 1
31679: NEG
31680: PUSH
31681: LD_INT 0
31683: PUSH
31684: EMPTY
31685: LIST
31686: LIST
31687: PUSH
31688: LD_INT 1
31690: NEG
31691: PUSH
31692: LD_INT 1
31694: NEG
31695: PUSH
31696: EMPTY
31697: LIST
31698: LIST
31699: PUSH
31700: LD_INT 1
31702: NEG
31703: PUSH
31704: LD_INT 2
31706: NEG
31707: PUSH
31708: EMPTY
31709: LIST
31710: LIST
31711: PUSH
31712: LD_INT 1
31714: PUSH
31715: LD_INT 2
31717: PUSH
31718: EMPTY
31719: LIST
31720: LIST
31721: PUSH
31722: EMPTY
31723: LIST
31724: LIST
31725: LIST
31726: LIST
31727: LIST
31728: LIST
31729: LIST
31730: LIST
31731: LIST
31732: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
31733: LD_ADDR_VAR 0 40
31737: PUSH
31738: LD_INT 0
31740: PUSH
31741: LD_INT 0
31743: PUSH
31744: EMPTY
31745: LIST
31746: LIST
31747: PUSH
31748: LD_INT 0
31750: PUSH
31751: LD_INT 1
31753: NEG
31754: PUSH
31755: EMPTY
31756: LIST
31757: LIST
31758: PUSH
31759: LD_INT 1
31761: PUSH
31762: LD_INT 0
31764: PUSH
31765: EMPTY
31766: LIST
31767: LIST
31768: PUSH
31769: LD_INT 1
31771: PUSH
31772: LD_INT 1
31774: PUSH
31775: EMPTY
31776: LIST
31777: LIST
31778: PUSH
31779: LD_INT 0
31781: PUSH
31782: LD_INT 1
31784: PUSH
31785: EMPTY
31786: LIST
31787: LIST
31788: PUSH
31789: LD_INT 1
31791: NEG
31792: PUSH
31793: LD_INT 0
31795: PUSH
31796: EMPTY
31797: LIST
31798: LIST
31799: PUSH
31800: LD_INT 1
31802: NEG
31803: PUSH
31804: LD_INT 1
31806: NEG
31807: PUSH
31808: EMPTY
31809: LIST
31810: LIST
31811: PUSH
31812: LD_INT 1
31814: PUSH
31815: LD_INT 1
31817: NEG
31818: PUSH
31819: EMPTY
31820: LIST
31821: LIST
31822: PUSH
31823: LD_INT 1
31825: NEG
31826: PUSH
31827: LD_INT 1
31829: PUSH
31830: EMPTY
31831: LIST
31832: LIST
31833: PUSH
31834: EMPTY
31835: LIST
31836: LIST
31837: LIST
31838: LIST
31839: LIST
31840: LIST
31841: LIST
31842: LIST
31843: LIST
31844: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31845: LD_ADDR_VAR 0 41
31849: PUSH
31850: LD_INT 0
31852: PUSH
31853: LD_INT 0
31855: PUSH
31856: EMPTY
31857: LIST
31858: LIST
31859: PUSH
31860: LD_INT 0
31862: PUSH
31863: LD_INT 1
31865: NEG
31866: PUSH
31867: EMPTY
31868: LIST
31869: LIST
31870: PUSH
31871: LD_INT 1
31873: PUSH
31874: LD_INT 0
31876: PUSH
31877: EMPTY
31878: LIST
31879: LIST
31880: PUSH
31881: LD_INT 1
31883: PUSH
31884: LD_INT 1
31886: PUSH
31887: EMPTY
31888: LIST
31889: LIST
31890: PUSH
31891: LD_INT 0
31893: PUSH
31894: LD_INT 1
31896: PUSH
31897: EMPTY
31898: LIST
31899: LIST
31900: PUSH
31901: LD_INT 1
31903: NEG
31904: PUSH
31905: LD_INT 0
31907: PUSH
31908: EMPTY
31909: LIST
31910: LIST
31911: PUSH
31912: LD_INT 1
31914: NEG
31915: PUSH
31916: LD_INT 1
31918: NEG
31919: PUSH
31920: EMPTY
31921: LIST
31922: LIST
31923: PUSH
31924: LD_INT 1
31926: NEG
31927: PUSH
31928: LD_INT 2
31930: NEG
31931: PUSH
31932: EMPTY
31933: LIST
31934: LIST
31935: PUSH
31936: LD_INT 1
31938: PUSH
31939: LD_INT 1
31941: NEG
31942: PUSH
31943: EMPTY
31944: LIST
31945: LIST
31946: PUSH
31947: LD_INT 2
31949: PUSH
31950: LD_INT 0
31952: PUSH
31953: EMPTY
31954: LIST
31955: LIST
31956: PUSH
31957: LD_INT 2
31959: PUSH
31960: LD_INT 1
31962: PUSH
31963: EMPTY
31964: LIST
31965: LIST
31966: PUSH
31967: LD_INT 2
31969: PUSH
31970: LD_INT 2
31972: PUSH
31973: EMPTY
31974: LIST
31975: LIST
31976: PUSH
31977: LD_INT 1
31979: PUSH
31980: LD_INT 2
31982: PUSH
31983: EMPTY
31984: LIST
31985: LIST
31986: PUSH
31987: LD_INT 1
31989: NEG
31990: PUSH
31991: LD_INT 1
31993: PUSH
31994: EMPTY
31995: LIST
31996: LIST
31997: PUSH
31998: LD_INT 2
32000: NEG
32001: PUSH
32002: LD_INT 0
32004: PUSH
32005: EMPTY
32006: LIST
32007: LIST
32008: PUSH
32009: LD_INT 2
32011: NEG
32012: PUSH
32013: LD_INT 1
32015: NEG
32016: PUSH
32017: EMPTY
32018: LIST
32019: LIST
32020: PUSH
32021: LD_INT 2
32023: NEG
32024: PUSH
32025: LD_INT 2
32027: NEG
32028: PUSH
32029: EMPTY
32030: LIST
32031: LIST
32032: PUSH
32033: LD_INT 2
32035: NEG
32036: PUSH
32037: LD_INT 3
32039: NEG
32040: PUSH
32041: EMPTY
32042: LIST
32043: LIST
32044: PUSH
32045: LD_INT 2
32047: PUSH
32048: LD_INT 1
32050: NEG
32051: PUSH
32052: EMPTY
32053: LIST
32054: LIST
32055: PUSH
32056: LD_INT 3
32058: PUSH
32059: LD_INT 0
32061: PUSH
32062: EMPTY
32063: LIST
32064: LIST
32065: PUSH
32066: LD_INT 3
32068: PUSH
32069: LD_INT 1
32071: PUSH
32072: EMPTY
32073: LIST
32074: LIST
32075: PUSH
32076: LD_INT 3
32078: PUSH
32079: LD_INT 2
32081: PUSH
32082: EMPTY
32083: LIST
32084: LIST
32085: PUSH
32086: LD_INT 3
32088: PUSH
32089: LD_INT 3
32091: PUSH
32092: EMPTY
32093: LIST
32094: LIST
32095: PUSH
32096: LD_INT 2
32098: PUSH
32099: LD_INT 3
32101: PUSH
32102: EMPTY
32103: LIST
32104: LIST
32105: PUSH
32106: LD_INT 2
32108: NEG
32109: PUSH
32110: LD_INT 1
32112: PUSH
32113: EMPTY
32114: LIST
32115: LIST
32116: PUSH
32117: LD_INT 3
32119: NEG
32120: PUSH
32121: LD_INT 0
32123: PUSH
32124: EMPTY
32125: LIST
32126: LIST
32127: PUSH
32128: LD_INT 3
32130: NEG
32131: PUSH
32132: LD_INT 1
32134: NEG
32135: PUSH
32136: EMPTY
32137: LIST
32138: LIST
32139: PUSH
32140: LD_INT 3
32142: NEG
32143: PUSH
32144: LD_INT 2
32146: NEG
32147: PUSH
32148: EMPTY
32149: LIST
32150: LIST
32151: PUSH
32152: LD_INT 3
32154: NEG
32155: PUSH
32156: LD_INT 3
32158: NEG
32159: PUSH
32160: EMPTY
32161: LIST
32162: LIST
32163: PUSH
32164: EMPTY
32165: LIST
32166: LIST
32167: LIST
32168: LIST
32169: LIST
32170: LIST
32171: LIST
32172: LIST
32173: LIST
32174: LIST
32175: LIST
32176: LIST
32177: LIST
32178: LIST
32179: LIST
32180: LIST
32181: LIST
32182: LIST
32183: LIST
32184: LIST
32185: LIST
32186: LIST
32187: LIST
32188: LIST
32189: LIST
32190: LIST
32191: LIST
32192: LIST
32193: LIST
32194: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32195: LD_ADDR_VAR 0 42
32199: PUSH
32200: LD_INT 0
32202: PUSH
32203: LD_INT 0
32205: PUSH
32206: EMPTY
32207: LIST
32208: LIST
32209: PUSH
32210: LD_INT 0
32212: PUSH
32213: LD_INT 1
32215: NEG
32216: PUSH
32217: EMPTY
32218: LIST
32219: LIST
32220: PUSH
32221: LD_INT 1
32223: PUSH
32224: LD_INT 0
32226: PUSH
32227: EMPTY
32228: LIST
32229: LIST
32230: PUSH
32231: LD_INT 1
32233: PUSH
32234: LD_INT 1
32236: PUSH
32237: EMPTY
32238: LIST
32239: LIST
32240: PUSH
32241: LD_INT 0
32243: PUSH
32244: LD_INT 1
32246: PUSH
32247: EMPTY
32248: LIST
32249: LIST
32250: PUSH
32251: LD_INT 1
32253: NEG
32254: PUSH
32255: LD_INT 0
32257: PUSH
32258: EMPTY
32259: LIST
32260: LIST
32261: PUSH
32262: LD_INT 1
32264: NEG
32265: PUSH
32266: LD_INT 1
32268: NEG
32269: PUSH
32270: EMPTY
32271: LIST
32272: LIST
32273: PUSH
32274: LD_INT 1
32276: NEG
32277: PUSH
32278: LD_INT 2
32280: NEG
32281: PUSH
32282: EMPTY
32283: LIST
32284: LIST
32285: PUSH
32286: LD_INT 0
32288: PUSH
32289: LD_INT 2
32291: NEG
32292: PUSH
32293: EMPTY
32294: LIST
32295: LIST
32296: PUSH
32297: LD_INT 1
32299: PUSH
32300: LD_INT 1
32302: NEG
32303: PUSH
32304: EMPTY
32305: LIST
32306: LIST
32307: PUSH
32308: LD_INT 2
32310: PUSH
32311: LD_INT 1
32313: PUSH
32314: EMPTY
32315: LIST
32316: LIST
32317: PUSH
32318: LD_INT 2
32320: PUSH
32321: LD_INT 2
32323: PUSH
32324: EMPTY
32325: LIST
32326: LIST
32327: PUSH
32328: LD_INT 1
32330: PUSH
32331: LD_INT 2
32333: PUSH
32334: EMPTY
32335: LIST
32336: LIST
32337: PUSH
32338: LD_INT 0
32340: PUSH
32341: LD_INT 2
32343: PUSH
32344: EMPTY
32345: LIST
32346: LIST
32347: PUSH
32348: LD_INT 1
32350: NEG
32351: PUSH
32352: LD_INT 1
32354: PUSH
32355: EMPTY
32356: LIST
32357: LIST
32358: PUSH
32359: LD_INT 2
32361: NEG
32362: PUSH
32363: LD_INT 1
32365: NEG
32366: PUSH
32367: EMPTY
32368: LIST
32369: LIST
32370: PUSH
32371: LD_INT 2
32373: NEG
32374: PUSH
32375: LD_INT 2
32377: NEG
32378: PUSH
32379: EMPTY
32380: LIST
32381: LIST
32382: PUSH
32383: LD_INT 2
32385: NEG
32386: PUSH
32387: LD_INT 3
32389: NEG
32390: PUSH
32391: EMPTY
32392: LIST
32393: LIST
32394: PUSH
32395: LD_INT 1
32397: NEG
32398: PUSH
32399: LD_INT 3
32401: NEG
32402: PUSH
32403: EMPTY
32404: LIST
32405: LIST
32406: PUSH
32407: LD_INT 0
32409: PUSH
32410: LD_INT 3
32412: NEG
32413: PUSH
32414: EMPTY
32415: LIST
32416: LIST
32417: PUSH
32418: LD_INT 1
32420: PUSH
32421: LD_INT 2
32423: NEG
32424: PUSH
32425: EMPTY
32426: LIST
32427: LIST
32428: PUSH
32429: LD_INT 3
32431: PUSH
32432: LD_INT 2
32434: PUSH
32435: EMPTY
32436: LIST
32437: LIST
32438: PUSH
32439: LD_INT 3
32441: PUSH
32442: LD_INT 3
32444: PUSH
32445: EMPTY
32446: LIST
32447: LIST
32448: PUSH
32449: LD_INT 2
32451: PUSH
32452: LD_INT 3
32454: PUSH
32455: EMPTY
32456: LIST
32457: LIST
32458: PUSH
32459: LD_INT 1
32461: PUSH
32462: LD_INT 3
32464: PUSH
32465: EMPTY
32466: LIST
32467: LIST
32468: PUSH
32469: LD_INT 0
32471: PUSH
32472: LD_INT 3
32474: PUSH
32475: EMPTY
32476: LIST
32477: LIST
32478: PUSH
32479: LD_INT 1
32481: NEG
32482: PUSH
32483: LD_INT 2
32485: PUSH
32486: EMPTY
32487: LIST
32488: LIST
32489: PUSH
32490: LD_INT 3
32492: NEG
32493: PUSH
32494: LD_INT 2
32496: NEG
32497: PUSH
32498: EMPTY
32499: LIST
32500: LIST
32501: PUSH
32502: LD_INT 3
32504: NEG
32505: PUSH
32506: LD_INT 3
32508: NEG
32509: PUSH
32510: EMPTY
32511: LIST
32512: LIST
32513: PUSH
32514: EMPTY
32515: LIST
32516: LIST
32517: LIST
32518: LIST
32519: LIST
32520: LIST
32521: LIST
32522: LIST
32523: LIST
32524: LIST
32525: LIST
32526: LIST
32527: LIST
32528: LIST
32529: LIST
32530: LIST
32531: LIST
32532: LIST
32533: LIST
32534: LIST
32535: LIST
32536: LIST
32537: LIST
32538: LIST
32539: LIST
32540: LIST
32541: LIST
32542: LIST
32543: LIST
32544: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
32545: LD_ADDR_VAR 0 43
32549: PUSH
32550: LD_INT 0
32552: PUSH
32553: LD_INT 0
32555: PUSH
32556: EMPTY
32557: LIST
32558: LIST
32559: PUSH
32560: LD_INT 0
32562: PUSH
32563: LD_INT 1
32565: NEG
32566: PUSH
32567: EMPTY
32568: LIST
32569: LIST
32570: PUSH
32571: LD_INT 1
32573: PUSH
32574: LD_INT 0
32576: PUSH
32577: EMPTY
32578: LIST
32579: LIST
32580: PUSH
32581: LD_INT 1
32583: PUSH
32584: LD_INT 1
32586: PUSH
32587: EMPTY
32588: LIST
32589: LIST
32590: PUSH
32591: LD_INT 0
32593: PUSH
32594: LD_INT 1
32596: PUSH
32597: EMPTY
32598: LIST
32599: LIST
32600: PUSH
32601: LD_INT 1
32603: NEG
32604: PUSH
32605: LD_INT 0
32607: PUSH
32608: EMPTY
32609: LIST
32610: LIST
32611: PUSH
32612: LD_INT 1
32614: NEG
32615: PUSH
32616: LD_INT 1
32618: NEG
32619: PUSH
32620: EMPTY
32621: LIST
32622: LIST
32623: PUSH
32624: LD_INT 1
32626: NEG
32627: PUSH
32628: LD_INT 2
32630: NEG
32631: PUSH
32632: EMPTY
32633: LIST
32634: LIST
32635: PUSH
32636: LD_INT 0
32638: PUSH
32639: LD_INT 2
32641: NEG
32642: PUSH
32643: EMPTY
32644: LIST
32645: LIST
32646: PUSH
32647: LD_INT 1
32649: PUSH
32650: LD_INT 1
32652: NEG
32653: PUSH
32654: EMPTY
32655: LIST
32656: LIST
32657: PUSH
32658: LD_INT 2
32660: PUSH
32661: LD_INT 0
32663: PUSH
32664: EMPTY
32665: LIST
32666: LIST
32667: PUSH
32668: LD_INT 2
32670: PUSH
32671: LD_INT 1
32673: PUSH
32674: EMPTY
32675: LIST
32676: LIST
32677: PUSH
32678: LD_INT 1
32680: PUSH
32681: LD_INT 2
32683: PUSH
32684: EMPTY
32685: LIST
32686: LIST
32687: PUSH
32688: LD_INT 0
32690: PUSH
32691: LD_INT 2
32693: PUSH
32694: EMPTY
32695: LIST
32696: LIST
32697: PUSH
32698: LD_INT 1
32700: NEG
32701: PUSH
32702: LD_INT 1
32704: PUSH
32705: EMPTY
32706: LIST
32707: LIST
32708: PUSH
32709: LD_INT 2
32711: NEG
32712: PUSH
32713: LD_INT 0
32715: PUSH
32716: EMPTY
32717: LIST
32718: LIST
32719: PUSH
32720: LD_INT 2
32722: NEG
32723: PUSH
32724: LD_INT 1
32726: NEG
32727: PUSH
32728: EMPTY
32729: LIST
32730: LIST
32731: PUSH
32732: LD_INT 1
32734: NEG
32735: PUSH
32736: LD_INT 3
32738: NEG
32739: PUSH
32740: EMPTY
32741: LIST
32742: LIST
32743: PUSH
32744: LD_INT 0
32746: PUSH
32747: LD_INT 3
32749: NEG
32750: PUSH
32751: EMPTY
32752: LIST
32753: LIST
32754: PUSH
32755: LD_INT 1
32757: PUSH
32758: LD_INT 2
32760: NEG
32761: PUSH
32762: EMPTY
32763: LIST
32764: LIST
32765: PUSH
32766: LD_INT 2
32768: PUSH
32769: LD_INT 1
32771: NEG
32772: PUSH
32773: EMPTY
32774: LIST
32775: LIST
32776: PUSH
32777: LD_INT 3
32779: PUSH
32780: LD_INT 0
32782: PUSH
32783: EMPTY
32784: LIST
32785: LIST
32786: PUSH
32787: LD_INT 3
32789: PUSH
32790: LD_INT 1
32792: PUSH
32793: EMPTY
32794: LIST
32795: LIST
32796: PUSH
32797: LD_INT 1
32799: PUSH
32800: LD_INT 3
32802: PUSH
32803: EMPTY
32804: LIST
32805: LIST
32806: PUSH
32807: LD_INT 0
32809: PUSH
32810: LD_INT 3
32812: PUSH
32813: EMPTY
32814: LIST
32815: LIST
32816: PUSH
32817: LD_INT 1
32819: NEG
32820: PUSH
32821: LD_INT 2
32823: PUSH
32824: EMPTY
32825: LIST
32826: LIST
32827: PUSH
32828: LD_INT 2
32830: NEG
32831: PUSH
32832: LD_INT 1
32834: PUSH
32835: EMPTY
32836: LIST
32837: LIST
32838: PUSH
32839: LD_INT 3
32841: NEG
32842: PUSH
32843: LD_INT 0
32845: PUSH
32846: EMPTY
32847: LIST
32848: LIST
32849: PUSH
32850: LD_INT 3
32852: NEG
32853: PUSH
32854: LD_INT 1
32856: NEG
32857: PUSH
32858: EMPTY
32859: LIST
32860: LIST
32861: PUSH
32862: EMPTY
32863: LIST
32864: LIST
32865: LIST
32866: LIST
32867: LIST
32868: LIST
32869: LIST
32870: LIST
32871: LIST
32872: LIST
32873: LIST
32874: LIST
32875: LIST
32876: LIST
32877: LIST
32878: LIST
32879: LIST
32880: LIST
32881: LIST
32882: LIST
32883: LIST
32884: LIST
32885: LIST
32886: LIST
32887: LIST
32888: LIST
32889: LIST
32890: LIST
32891: LIST
32892: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32893: LD_ADDR_VAR 0 44
32897: PUSH
32898: LD_INT 0
32900: PUSH
32901: LD_INT 0
32903: PUSH
32904: EMPTY
32905: LIST
32906: LIST
32907: PUSH
32908: LD_INT 0
32910: PUSH
32911: LD_INT 1
32913: NEG
32914: PUSH
32915: EMPTY
32916: LIST
32917: LIST
32918: PUSH
32919: LD_INT 1
32921: PUSH
32922: LD_INT 0
32924: PUSH
32925: EMPTY
32926: LIST
32927: LIST
32928: PUSH
32929: LD_INT 1
32931: PUSH
32932: LD_INT 1
32934: PUSH
32935: EMPTY
32936: LIST
32937: LIST
32938: PUSH
32939: LD_INT 0
32941: PUSH
32942: LD_INT 1
32944: PUSH
32945: EMPTY
32946: LIST
32947: LIST
32948: PUSH
32949: LD_INT 1
32951: NEG
32952: PUSH
32953: LD_INT 0
32955: PUSH
32956: EMPTY
32957: LIST
32958: LIST
32959: PUSH
32960: LD_INT 1
32962: NEG
32963: PUSH
32964: LD_INT 1
32966: NEG
32967: PUSH
32968: EMPTY
32969: LIST
32970: LIST
32971: PUSH
32972: LD_INT 1
32974: NEG
32975: PUSH
32976: LD_INT 2
32978: NEG
32979: PUSH
32980: EMPTY
32981: LIST
32982: LIST
32983: PUSH
32984: LD_INT 1
32986: PUSH
32987: LD_INT 1
32989: NEG
32990: PUSH
32991: EMPTY
32992: LIST
32993: LIST
32994: PUSH
32995: LD_INT 2
32997: PUSH
32998: LD_INT 0
33000: PUSH
33001: EMPTY
33002: LIST
33003: LIST
33004: PUSH
33005: LD_INT 2
33007: PUSH
33008: LD_INT 1
33010: PUSH
33011: EMPTY
33012: LIST
33013: LIST
33014: PUSH
33015: LD_INT 2
33017: PUSH
33018: LD_INT 2
33020: PUSH
33021: EMPTY
33022: LIST
33023: LIST
33024: PUSH
33025: LD_INT 1
33027: PUSH
33028: LD_INT 2
33030: PUSH
33031: EMPTY
33032: LIST
33033: LIST
33034: PUSH
33035: LD_INT 1
33037: NEG
33038: PUSH
33039: LD_INT 1
33041: PUSH
33042: EMPTY
33043: LIST
33044: LIST
33045: PUSH
33046: LD_INT 2
33048: NEG
33049: PUSH
33050: LD_INT 0
33052: PUSH
33053: EMPTY
33054: LIST
33055: LIST
33056: PUSH
33057: LD_INT 2
33059: NEG
33060: PUSH
33061: LD_INT 1
33063: NEG
33064: PUSH
33065: EMPTY
33066: LIST
33067: LIST
33068: PUSH
33069: LD_INT 2
33071: NEG
33072: PUSH
33073: LD_INT 2
33075: NEG
33076: PUSH
33077: EMPTY
33078: LIST
33079: LIST
33080: PUSH
33081: LD_INT 2
33083: NEG
33084: PUSH
33085: LD_INT 3
33087: NEG
33088: PUSH
33089: EMPTY
33090: LIST
33091: LIST
33092: PUSH
33093: LD_INT 2
33095: PUSH
33096: LD_INT 1
33098: NEG
33099: PUSH
33100: EMPTY
33101: LIST
33102: LIST
33103: PUSH
33104: LD_INT 3
33106: PUSH
33107: LD_INT 0
33109: PUSH
33110: EMPTY
33111: LIST
33112: LIST
33113: PUSH
33114: LD_INT 3
33116: PUSH
33117: LD_INT 1
33119: PUSH
33120: EMPTY
33121: LIST
33122: LIST
33123: PUSH
33124: LD_INT 3
33126: PUSH
33127: LD_INT 2
33129: PUSH
33130: EMPTY
33131: LIST
33132: LIST
33133: PUSH
33134: LD_INT 3
33136: PUSH
33137: LD_INT 3
33139: PUSH
33140: EMPTY
33141: LIST
33142: LIST
33143: PUSH
33144: LD_INT 2
33146: PUSH
33147: LD_INT 3
33149: PUSH
33150: EMPTY
33151: LIST
33152: LIST
33153: PUSH
33154: LD_INT 2
33156: NEG
33157: PUSH
33158: LD_INT 1
33160: PUSH
33161: EMPTY
33162: LIST
33163: LIST
33164: PUSH
33165: LD_INT 3
33167: NEG
33168: PUSH
33169: LD_INT 0
33171: PUSH
33172: EMPTY
33173: LIST
33174: LIST
33175: PUSH
33176: LD_INT 3
33178: NEG
33179: PUSH
33180: LD_INT 1
33182: NEG
33183: PUSH
33184: EMPTY
33185: LIST
33186: LIST
33187: PUSH
33188: LD_INT 3
33190: NEG
33191: PUSH
33192: LD_INT 2
33194: NEG
33195: PUSH
33196: EMPTY
33197: LIST
33198: LIST
33199: PUSH
33200: LD_INT 3
33202: NEG
33203: PUSH
33204: LD_INT 3
33206: NEG
33207: PUSH
33208: EMPTY
33209: LIST
33210: LIST
33211: PUSH
33212: EMPTY
33213: LIST
33214: LIST
33215: LIST
33216: LIST
33217: LIST
33218: LIST
33219: LIST
33220: LIST
33221: LIST
33222: LIST
33223: LIST
33224: LIST
33225: LIST
33226: LIST
33227: LIST
33228: LIST
33229: LIST
33230: LIST
33231: LIST
33232: LIST
33233: LIST
33234: LIST
33235: LIST
33236: LIST
33237: LIST
33238: LIST
33239: LIST
33240: LIST
33241: LIST
33242: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33243: LD_ADDR_VAR 0 45
33247: PUSH
33248: LD_INT 0
33250: PUSH
33251: LD_INT 0
33253: PUSH
33254: EMPTY
33255: LIST
33256: LIST
33257: PUSH
33258: LD_INT 0
33260: PUSH
33261: LD_INT 1
33263: NEG
33264: PUSH
33265: EMPTY
33266: LIST
33267: LIST
33268: PUSH
33269: LD_INT 1
33271: PUSH
33272: LD_INT 0
33274: PUSH
33275: EMPTY
33276: LIST
33277: LIST
33278: PUSH
33279: LD_INT 1
33281: PUSH
33282: LD_INT 1
33284: PUSH
33285: EMPTY
33286: LIST
33287: LIST
33288: PUSH
33289: LD_INT 0
33291: PUSH
33292: LD_INT 1
33294: PUSH
33295: EMPTY
33296: LIST
33297: LIST
33298: PUSH
33299: LD_INT 1
33301: NEG
33302: PUSH
33303: LD_INT 0
33305: PUSH
33306: EMPTY
33307: LIST
33308: LIST
33309: PUSH
33310: LD_INT 1
33312: NEG
33313: PUSH
33314: LD_INT 1
33316: NEG
33317: PUSH
33318: EMPTY
33319: LIST
33320: LIST
33321: PUSH
33322: LD_INT 1
33324: NEG
33325: PUSH
33326: LD_INT 2
33328: NEG
33329: PUSH
33330: EMPTY
33331: LIST
33332: LIST
33333: PUSH
33334: LD_INT 0
33336: PUSH
33337: LD_INT 2
33339: NEG
33340: PUSH
33341: EMPTY
33342: LIST
33343: LIST
33344: PUSH
33345: LD_INT 1
33347: PUSH
33348: LD_INT 1
33350: NEG
33351: PUSH
33352: EMPTY
33353: LIST
33354: LIST
33355: PUSH
33356: LD_INT 2
33358: PUSH
33359: LD_INT 1
33361: PUSH
33362: EMPTY
33363: LIST
33364: LIST
33365: PUSH
33366: LD_INT 2
33368: PUSH
33369: LD_INT 2
33371: PUSH
33372: EMPTY
33373: LIST
33374: LIST
33375: PUSH
33376: LD_INT 1
33378: PUSH
33379: LD_INT 2
33381: PUSH
33382: EMPTY
33383: LIST
33384: LIST
33385: PUSH
33386: LD_INT 0
33388: PUSH
33389: LD_INT 2
33391: PUSH
33392: EMPTY
33393: LIST
33394: LIST
33395: PUSH
33396: LD_INT 1
33398: NEG
33399: PUSH
33400: LD_INT 1
33402: PUSH
33403: EMPTY
33404: LIST
33405: LIST
33406: PUSH
33407: LD_INT 2
33409: NEG
33410: PUSH
33411: LD_INT 1
33413: NEG
33414: PUSH
33415: EMPTY
33416: LIST
33417: LIST
33418: PUSH
33419: LD_INT 2
33421: NEG
33422: PUSH
33423: LD_INT 2
33425: NEG
33426: PUSH
33427: EMPTY
33428: LIST
33429: LIST
33430: PUSH
33431: LD_INT 2
33433: NEG
33434: PUSH
33435: LD_INT 3
33437: NEG
33438: PUSH
33439: EMPTY
33440: LIST
33441: LIST
33442: PUSH
33443: LD_INT 1
33445: NEG
33446: PUSH
33447: LD_INT 3
33449: NEG
33450: PUSH
33451: EMPTY
33452: LIST
33453: LIST
33454: PUSH
33455: LD_INT 0
33457: PUSH
33458: LD_INT 3
33460: NEG
33461: PUSH
33462: EMPTY
33463: LIST
33464: LIST
33465: PUSH
33466: LD_INT 1
33468: PUSH
33469: LD_INT 2
33471: NEG
33472: PUSH
33473: EMPTY
33474: LIST
33475: LIST
33476: PUSH
33477: LD_INT 3
33479: PUSH
33480: LD_INT 2
33482: PUSH
33483: EMPTY
33484: LIST
33485: LIST
33486: PUSH
33487: LD_INT 3
33489: PUSH
33490: LD_INT 3
33492: PUSH
33493: EMPTY
33494: LIST
33495: LIST
33496: PUSH
33497: LD_INT 2
33499: PUSH
33500: LD_INT 3
33502: PUSH
33503: EMPTY
33504: LIST
33505: LIST
33506: PUSH
33507: LD_INT 1
33509: PUSH
33510: LD_INT 3
33512: PUSH
33513: EMPTY
33514: LIST
33515: LIST
33516: PUSH
33517: LD_INT 0
33519: PUSH
33520: LD_INT 3
33522: PUSH
33523: EMPTY
33524: LIST
33525: LIST
33526: PUSH
33527: LD_INT 1
33529: NEG
33530: PUSH
33531: LD_INT 2
33533: PUSH
33534: EMPTY
33535: LIST
33536: LIST
33537: PUSH
33538: LD_INT 3
33540: NEG
33541: PUSH
33542: LD_INT 2
33544: NEG
33545: PUSH
33546: EMPTY
33547: LIST
33548: LIST
33549: PUSH
33550: LD_INT 3
33552: NEG
33553: PUSH
33554: LD_INT 3
33556: NEG
33557: PUSH
33558: EMPTY
33559: LIST
33560: LIST
33561: PUSH
33562: EMPTY
33563: LIST
33564: LIST
33565: LIST
33566: LIST
33567: LIST
33568: LIST
33569: LIST
33570: LIST
33571: LIST
33572: LIST
33573: LIST
33574: LIST
33575: LIST
33576: LIST
33577: LIST
33578: LIST
33579: LIST
33580: LIST
33581: LIST
33582: LIST
33583: LIST
33584: LIST
33585: LIST
33586: LIST
33587: LIST
33588: LIST
33589: LIST
33590: LIST
33591: LIST
33592: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
33593: LD_ADDR_VAR 0 46
33597: PUSH
33598: LD_INT 0
33600: PUSH
33601: LD_INT 0
33603: PUSH
33604: EMPTY
33605: LIST
33606: LIST
33607: PUSH
33608: LD_INT 0
33610: PUSH
33611: LD_INT 1
33613: NEG
33614: PUSH
33615: EMPTY
33616: LIST
33617: LIST
33618: PUSH
33619: LD_INT 1
33621: PUSH
33622: LD_INT 0
33624: PUSH
33625: EMPTY
33626: LIST
33627: LIST
33628: PUSH
33629: LD_INT 1
33631: PUSH
33632: LD_INT 1
33634: PUSH
33635: EMPTY
33636: LIST
33637: LIST
33638: PUSH
33639: LD_INT 0
33641: PUSH
33642: LD_INT 1
33644: PUSH
33645: EMPTY
33646: LIST
33647: LIST
33648: PUSH
33649: LD_INT 1
33651: NEG
33652: PUSH
33653: LD_INT 0
33655: PUSH
33656: EMPTY
33657: LIST
33658: LIST
33659: PUSH
33660: LD_INT 1
33662: NEG
33663: PUSH
33664: LD_INT 1
33666: NEG
33667: PUSH
33668: EMPTY
33669: LIST
33670: LIST
33671: PUSH
33672: LD_INT 1
33674: NEG
33675: PUSH
33676: LD_INT 2
33678: NEG
33679: PUSH
33680: EMPTY
33681: LIST
33682: LIST
33683: PUSH
33684: LD_INT 0
33686: PUSH
33687: LD_INT 2
33689: NEG
33690: PUSH
33691: EMPTY
33692: LIST
33693: LIST
33694: PUSH
33695: LD_INT 1
33697: PUSH
33698: LD_INT 1
33700: NEG
33701: PUSH
33702: EMPTY
33703: LIST
33704: LIST
33705: PUSH
33706: LD_INT 2
33708: PUSH
33709: LD_INT 0
33711: PUSH
33712: EMPTY
33713: LIST
33714: LIST
33715: PUSH
33716: LD_INT 2
33718: PUSH
33719: LD_INT 1
33721: PUSH
33722: EMPTY
33723: LIST
33724: LIST
33725: PUSH
33726: LD_INT 1
33728: PUSH
33729: LD_INT 2
33731: PUSH
33732: EMPTY
33733: LIST
33734: LIST
33735: PUSH
33736: LD_INT 0
33738: PUSH
33739: LD_INT 2
33741: PUSH
33742: EMPTY
33743: LIST
33744: LIST
33745: PUSH
33746: LD_INT 1
33748: NEG
33749: PUSH
33750: LD_INT 1
33752: PUSH
33753: EMPTY
33754: LIST
33755: LIST
33756: PUSH
33757: LD_INT 2
33759: NEG
33760: PUSH
33761: LD_INT 0
33763: PUSH
33764: EMPTY
33765: LIST
33766: LIST
33767: PUSH
33768: LD_INT 2
33770: NEG
33771: PUSH
33772: LD_INT 1
33774: NEG
33775: PUSH
33776: EMPTY
33777: LIST
33778: LIST
33779: PUSH
33780: LD_INT 1
33782: NEG
33783: PUSH
33784: LD_INT 3
33786: NEG
33787: PUSH
33788: EMPTY
33789: LIST
33790: LIST
33791: PUSH
33792: LD_INT 0
33794: PUSH
33795: LD_INT 3
33797: NEG
33798: PUSH
33799: EMPTY
33800: LIST
33801: LIST
33802: PUSH
33803: LD_INT 1
33805: PUSH
33806: LD_INT 2
33808: NEG
33809: PUSH
33810: EMPTY
33811: LIST
33812: LIST
33813: PUSH
33814: LD_INT 2
33816: PUSH
33817: LD_INT 1
33819: NEG
33820: PUSH
33821: EMPTY
33822: LIST
33823: LIST
33824: PUSH
33825: LD_INT 3
33827: PUSH
33828: LD_INT 0
33830: PUSH
33831: EMPTY
33832: LIST
33833: LIST
33834: PUSH
33835: LD_INT 3
33837: PUSH
33838: LD_INT 1
33840: PUSH
33841: EMPTY
33842: LIST
33843: LIST
33844: PUSH
33845: LD_INT 1
33847: PUSH
33848: LD_INT 3
33850: PUSH
33851: EMPTY
33852: LIST
33853: LIST
33854: PUSH
33855: LD_INT 0
33857: PUSH
33858: LD_INT 3
33860: PUSH
33861: EMPTY
33862: LIST
33863: LIST
33864: PUSH
33865: LD_INT 1
33867: NEG
33868: PUSH
33869: LD_INT 2
33871: PUSH
33872: EMPTY
33873: LIST
33874: LIST
33875: PUSH
33876: LD_INT 2
33878: NEG
33879: PUSH
33880: LD_INT 1
33882: PUSH
33883: EMPTY
33884: LIST
33885: LIST
33886: PUSH
33887: LD_INT 3
33889: NEG
33890: PUSH
33891: LD_INT 0
33893: PUSH
33894: EMPTY
33895: LIST
33896: LIST
33897: PUSH
33898: LD_INT 3
33900: NEG
33901: PUSH
33902: LD_INT 1
33904: NEG
33905: PUSH
33906: EMPTY
33907: LIST
33908: LIST
33909: PUSH
33910: EMPTY
33911: LIST
33912: LIST
33913: LIST
33914: LIST
33915: LIST
33916: LIST
33917: LIST
33918: LIST
33919: LIST
33920: LIST
33921: LIST
33922: LIST
33923: LIST
33924: LIST
33925: LIST
33926: LIST
33927: LIST
33928: LIST
33929: LIST
33930: LIST
33931: LIST
33932: LIST
33933: LIST
33934: LIST
33935: LIST
33936: LIST
33937: LIST
33938: LIST
33939: LIST
33940: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33941: LD_ADDR_VAR 0 47
33945: PUSH
33946: LD_INT 0
33948: PUSH
33949: LD_INT 0
33951: PUSH
33952: EMPTY
33953: LIST
33954: LIST
33955: PUSH
33956: LD_INT 0
33958: PUSH
33959: LD_INT 1
33961: NEG
33962: PUSH
33963: EMPTY
33964: LIST
33965: LIST
33966: PUSH
33967: LD_INT 1
33969: PUSH
33970: LD_INT 0
33972: PUSH
33973: EMPTY
33974: LIST
33975: LIST
33976: PUSH
33977: LD_INT 1
33979: PUSH
33980: LD_INT 1
33982: PUSH
33983: EMPTY
33984: LIST
33985: LIST
33986: PUSH
33987: LD_INT 0
33989: PUSH
33990: LD_INT 1
33992: PUSH
33993: EMPTY
33994: LIST
33995: LIST
33996: PUSH
33997: LD_INT 1
33999: NEG
34000: PUSH
34001: LD_INT 0
34003: PUSH
34004: EMPTY
34005: LIST
34006: LIST
34007: PUSH
34008: LD_INT 1
34010: NEG
34011: PUSH
34012: LD_INT 1
34014: NEG
34015: PUSH
34016: EMPTY
34017: LIST
34018: LIST
34019: PUSH
34020: LD_INT 1
34022: NEG
34023: PUSH
34024: LD_INT 2
34026: NEG
34027: PUSH
34028: EMPTY
34029: LIST
34030: LIST
34031: PUSH
34032: LD_INT 0
34034: PUSH
34035: LD_INT 2
34037: NEG
34038: PUSH
34039: EMPTY
34040: LIST
34041: LIST
34042: PUSH
34043: LD_INT 1
34045: PUSH
34046: LD_INT 1
34048: NEG
34049: PUSH
34050: EMPTY
34051: LIST
34052: LIST
34053: PUSH
34054: LD_INT 2
34056: NEG
34057: PUSH
34058: LD_INT 1
34060: NEG
34061: PUSH
34062: EMPTY
34063: LIST
34064: LIST
34065: PUSH
34066: LD_INT 2
34068: NEG
34069: PUSH
34070: LD_INT 2
34072: NEG
34073: PUSH
34074: EMPTY
34075: LIST
34076: LIST
34077: PUSH
34078: EMPTY
34079: LIST
34080: LIST
34081: LIST
34082: LIST
34083: LIST
34084: LIST
34085: LIST
34086: LIST
34087: LIST
34088: LIST
34089: LIST
34090: LIST
34091: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
34092: LD_ADDR_VAR 0 48
34096: PUSH
34097: LD_INT 0
34099: PUSH
34100: LD_INT 0
34102: PUSH
34103: EMPTY
34104: LIST
34105: LIST
34106: PUSH
34107: LD_INT 0
34109: PUSH
34110: LD_INT 1
34112: NEG
34113: PUSH
34114: EMPTY
34115: LIST
34116: LIST
34117: PUSH
34118: LD_INT 1
34120: PUSH
34121: LD_INT 0
34123: PUSH
34124: EMPTY
34125: LIST
34126: LIST
34127: PUSH
34128: LD_INT 1
34130: PUSH
34131: LD_INT 1
34133: PUSH
34134: EMPTY
34135: LIST
34136: LIST
34137: PUSH
34138: LD_INT 0
34140: PUSH
34141: LD_INT 1
34143: PUSH
34144: EMPTY
34145: LIST
34146: LIST
34147: PUSH
34148: LD_INT 1
34150: NEG
34151: PUSH
34152: LD_INT 0
34154: PUSH
34155: EMPTY
34156: LIST
34157: LIST
34158: PUSH
34159: LD_INT 1
34161: NEG
34162: PUSH
34163: LD_INT 1
34165: NEG
34166: PUSH
34167: EMPTY
34168: LIST
34169: LIST
34170: PUSH
34171: LD_INT 1
34173: NEG
34174: PUSH
34175: LD_INT 2
34177: NEG
34178: PUSH
34179: EMPTY
34180: LIST
34181: LIST
34182: PUSH
34183: LD_INT 0
34185: PUSH
34186: LD_INT 2
34188: NEG
34189: PUSH
34190: EMPTY
34191: LIST
34192: LIST
34193: PUSH
34194: LD_INT 1
34196: PUSH
34197: LD_INT 1
34199: NEG
34200: PUSH
34201: EMPTY
34202: LIST
34203: LIST
34204: PUSH
34205: LD_INT 2
34207: PUSH
34208: LD_INT 0
34210: PUSH
34211: EMPTY
34212: LIST
34213: LIST
34214: PUSH
34215: LD_INT 2
34217: PUSH
34218: LD_INT 1
34220: PUSH
34221: EMPTY
34222: LIST
34223: LIST
34224: PUSH
34225: EMPTY
34226: LIST
34227: LIST
34228: LIST
34229: LIST
34230: LIST
34231: LIST
34232: LIST
34233: LIST
34234: LIST
34235: LIST
34236: LIST
34237: LIST
34238: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
34239: LD_ADDR_VAR 0 49
34243: PUSH
34244: LD_INT 0
34246: PUSH
34247: LD_INT 0
34249: PUSH
34250: EMPTY
34251: LIST
34252: LIST
34253: PUSH
34254: LD_INT 0
34256: PUSH
34257: LD_INT 1
34259: NEG
34260: PUSH
34261: EMPTY
34262: LIST
34263: LIST
34264: PUSH
34265: LD_INT 1
34267: PUSH
34268: LD_INT 0
34270: PUSH
34271: EMPTY
34272: LIST
34273: LIST
34274: PUSH
34275: LD_INT 1
34277: PUSH
34278: LD_INT 1
34280: PUSH
34281: EMPTY
34282: LIST
34283: LIST
34284: PUSH
34285: LD_INT 0
34287: PUSH
34288: LD_INT 1
34290: PUSH
34291: EMPTY
34292: LIST
34293: LIST
34294: PUSH
34295: LD_INT 1
34297: NEG
34298: PUSH
34299: LD_INT 0
34301: PUSH
34302: EMPTY
34303: LIST
34304: LIST
34305: PUSH
34306: LD_INT 1
34308: NEG
34309: PUSH
34310: LD_INT 1
34312: NEG
34313: PUSH
34314: EMPTY
34315: LIST
34316: LIST
34317: PUSH
34318: LD_INT 1
34320: PUSH
34321: LD_INT 1
34323: NEG
34324: PUSH
34325: EMPTY
34326: LIST
34327: LIST
34328: PUSH
34329: LD_INT 2
34331: PUSH
34332: LD_INT 0
34334: PUSH
34335: EMPTY
34336: LIST
34337: LIST
34338: PUSH
34339: LD_INT 2
34341: PUSH
34342: LD_INT 1
34344: PUSH
34345: EMPTY
34346: LIST
34347: LIST
34348: PUSH
34349: LD_INT 2
34351: PUSH
34352: LD_INT 2
34354: PUSH
34355: EMPTY
34356: LIST
34357: LIST
34358: PUSH
34359: LD_INT 1
34361: PUSH
34362: LD_INT 2
34364: PUSH
34365: EMPTY
34366: LIST
34367: LIST
34368: PUSH
34369: EMPTY
34370: LIST
34371: LIST
34372: LIST
34373: LIST
34374: LIST
34375: LIST
34376: LIST
34377: LIST
34378: LIST
34379: LIST
34380: LIST
34381: LIST
34382: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
34383: LD_ADDR_VAR 0 50
34387: PUSH
34388: LD_INT 0
34390: PUSH
34391: LD_INT 0
34393: PUSH
34394: EMPTY
34395: LIST
34396: LIST
34397: PUSH
34398: LD_INT 0
34400: PUSH
34401: LD_INT 1
34403: NEG
34404: PUSH
34405: EMPTY
34406: LIST
34407: LIST
34408: PUSH
34409: LD_INT 1
34411: PUSH
34412: LD_INT 0
34414: PUSH
34415: EMPTY
34416: LIST
34417: LIST
34418: PUSH
34419: LD_INT 1
34421: PUSH
34422: LD_INT 1
34424: PUSH
34425: EMPTY
34426: LIST
34427: LIST
34428: PUSH
34429: LD_INT 0
34431: PUSH
34432: LD_INT 1
34434: PUSH
34435: EMPTY
34436: LIST
34437: LIST
34438: PUSH
34439: LD_INT 1
34441: NEG
34442: PUSH
34443: LD_INT 0
34445: PUSH
34446: EMPTY
34447: LIST
34448: LIST
34449: PUSH
34450: LD_INT 1
34452: NEG
34453: PUSH
34454: LD_INT 1
34456: NEG
34457: PUSH
34458: EMPTY
34459: LIST
34460: LIST
34461: PUSH
34462: LD_INT 2
34464: PUSH
34465: LD_INT 1
34467: PUSH
34468: EMPTY
34469: LIST
34470: LIST
34471: PUSH
34472: LD_INT 2
34474: PUSH
34475: LD_INT 2
34477: PUSH
34478: EMPTY
34479: LIST
34480: LIST
34481: PUSH
34482: LD_INT 1
34484: PUSH
34485: LD_INT 2
34487: PUSH
34488: EMPTY
34489: LIST
34490: LIST
34491: PUSH
34492: LD_INT 0
34494: PUSH
34495: LD_INT 2
34497: PUSH
34498: EMPTY
34499: LIST
34500: LIST
34501: PUSH
34502: LD_INT 1
34504: NEG
34505: PUSH
34506: LD_INT 1
34508: PUSH
34509: EMPTY
34510: LIST
34511: LIST
34512: PUSH
34513: EMPTY
34514: LIST
34515: LIST
34516: LIST
34517: LIST
34518: LIST
34519: LIST
34520: LIST
34521: LIST
34522: LIST
34523: LIST
34524: LIST
34525: LIST
34526: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
34527: LD_ADDR_VAR 0 51
34531: PUSH
34532: LD_INT 0
34534: PUSH
34535: LD_INT 0
34537: PUSH
34538: EMPTY
34539: LIST
34540: LIST
34541: PUSH
34542: LD_INT 0
34544: PUSH
34545: LD_INT 1
34547: NEG
34548: PUSH
34549: EMPTY
34550: LIST
34551: LIST
34552: PUSH
34553: LD_INT 1
34555: PUSH
34556: LD_INT 0
34558: PUSH
34559: EMPTY
34560: LIST
34561: LIST
34562: PUSH
34563: LD_INT 1
34565: PUSH
34566: LD_INT 1
34568: PUSH
34569: EMPTY
34570: LIST
34571: LIST
34572: PUSH
34573: LD_INT 0
34575: PUSH
34576: LD_INT 1
34578: PUSH
34579: EMPTY
34580: LIST
34581: LIST
34582: PUSH
34583: LD_INT 1
34585: NEG
34586: PUSH
34587: LD_INT 0
34589: PUSH
34590: EMPTY
34591: LIST
34592: LIST
34593: PUSH
34594: LD_INT 1
34596: NEG
34597: PUSH
34598: LD_INT 1
34600: NEG
34601: PUSH
34602: EMPTY
34603: LIST
34604: LIST
34605: PUSH
34606: LD_INT 1
34608: PUSH
34609: LD_INT 2
34611: PUSH
34612: EMPTY
34613: LIST
34614: LIST
34615: PUSH
34616: LD_INT 0
34618: PUSH
34619: LD_INT 2
34621: PUSH
34622: EMPTY
34623: LIST
34624: LIST
34625: PUSH
34626: LD_INT 1
34628: NEG
34629: PUSH
34630: LD_INT 1
34632: PUSH
34633: EMPTY
34634: LIST
34635: LIST
34636: PUSH
34637: LD_INT 2
34639: NEG
34640: PUSH
34641: LD_INT 0
34643: PUSH
34644: EMPTY
34645: LIST
34646: LIST
34647: PUSH
34648: LD_INT 2
34650: NEG
34651: PUSH
34652: LD_INT 1
34654: NEG
34655: PUSH
34656: EMPTY
34657: LIST
34658: LIST
34659: PUSH
34660: EMPTY
34661: LIST
34662: LIST
34663: LIST
34664: LIST
34665: LIST
34666: LIST
34667: LIST
34668: LIST
34669: LIST
34670: LIST
34671: LIST
34672: LIST
34673: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34674: LD_ADDR_VAR 0 52
34678: PUSH
34679: LD_INT 0
34681: PUSH
34682: LD_INT 0
34684: PUSH
34685: EMPTY
34686: LIST
34687: LIST
34688: PUSH
34689: LD_INT 0
34691: PUSH
34692: LD_INT 1
34694: NEG
34695: PUSH
34696: EMPTY
34697: LIST
34698: LIST
34699: PUSH
34700: LD_INT 1
34702: PUSH
34703: LD_INT 0
34705: PUSH
34706: EMPTY
34707: LIST
34708: LIST
34709: PUSH
34710: LD_INT 1
34712: PUSH
34713: LD_INT 1
34715: PUSH
34716: EMPTY
34717: LIST
34718: LIST
34719: PUSH
34720: LD_INT 0
34722: PUSH
34723: LD_INT 1
34725: PUSH
34726: EMPTY
34727: LIST
34728: LIST
34729: PUSH
34730: LD_INT 1
34732: NEG
34733: PUSH
34734: LD_INT 0
34736: PUSH
34737: EMPTY
34738: LIST
34739: LIST
34740: PUSH
34741: LD_INT 1
34743: NEG
34744: PUSH
34745: LD_INT 1
34747: NEG
34748: PUSH
34749: EMPTY
34750: LIST
34751: LIST
34752: PUSH
34753: LD_INT 1
34755: NEG
34756: PUSH
34757: LD_INT 2
34759: NEG
34760: PUSH
34761: EMPTY
34762: LIST
34763: LIST
34764: PUSH
34765: LD_INT 1
34767: NEG
34768: PUSH
34769: LD_INT 1
34771: PUSH
34772: EMPTY
34773: LIST
34774: LIST
34775: PUSH
34776: LD_INT 2
34778: NEG
34779: PUSH
34780: LD_INT 0
34782: PUSH
34783: EMPTY
34784: LIST
34785: LIST
34786: PUSH
34787: LD_INT 2
34789: NEG
34790: PUSH
34791: LD_INT 1
34793: NEG
34794: PUSH
34795: EMPTY
34796: LIST
34797: LIST
34798: PUSH
34799: LD_INT 2
34801: NEG
34802: PUSH
34803: LD_INT 2
34805: NEG
34806: PUSH
34807: EMPTY
34808: LIST
34809: LIST
34810: PUSH
34811: EMPTY
34812: LIST
34813: LIST
34814: LIST
34815: LIST
34816: LIST
34817: LIST
34818: LIST
34819: LIST
34820: LIST
34821: LIST
34822: LIST
34823: LIST
34824: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34825: LD_ADDR_VAR 0 53
34829: PUSH
34830: LD_INT 0
34832: PUSH
34833: LD_INT 0
34835: PUSH
34836: EMPTY
34837: LIST
34838: LIST
34839: PUSH
34840: LD_INT 0
34842: PUSH
34843: LD_INT 1
34845: NEG
34846: PUSH
34847: EMPTY
34848: LIST
34849: LIST
34850: PUSH
34851: LD_INT 1
34853: PUSH
34854: LD_INT 0
34856: PUSH
34857: EMPTY
34858: LIST
34859: LIST
34860: PUSH
34861: LD_INT 1
34863: PUSH
34864: LD_INT 1
34866: PUSH
34867: EMPTY
34868: LIST
34869: LIST
34870: PUSH
34871: LD_INT 0
34873: PUSH
34874: LD_INT 1
34876: PUSH
34877: EMPTY
34878: LIST
34879: LIST
34880: PUSH
34881: LD_INT 1
34883: NEG
34884: PUSH
34885: LD_INT 0
34887: PUSH
34888: EMPTY
34889: LIST
34890: LIST
34891: PUSH
34892: LD_INT 1
34894: NEG
34895: PUSH
34896: LD_INT 1
34898: NEG
34899: PUSH
34900: EMPTY
34901: LIST
34902: LIST
34903: PUSH
34904: LD_INT 1
34906: NEG
34907: PUSH
34908: LD_INT 2
34910: NEG
34911: PUSH
34912: EMPTY
34913: LIST
34914: LIST
34915: PUSH
34916: LD_INT 0
34918: PUSH
34919: LD_INT 2
34921: NEG
34922: PUSH
34923: EMPTY
34924: LIST
34925: LIST
34926: PUSH
34927: LD_INT 1
34929: PUSH
34930: LD_INT 1
34932: NEG
34933: PUSH
34934: EMPTY
34935: LIST
34936: LIST
34937: PUSH
34938: LD_INT 2
34940: PUSH
34941: LD_INT 0
34943: PUSH
34944: EMPTY
34945: LIST
34946: LIST
34947: PUSH
34948: LD_INT 2
34950: PUSH
34951: LD_INT 1
34953: PUSH
34954: EMPTY
34955: LIST
34956: LIST
34957: PUSH
34958: LD_INT 2
34960: PUSH
34961: LD_INT 2
34963: PUSH
34964: EMPTY
34965: LIST
34966: LIST
34967: PUSH
34968: LD_INT 1
34970: PUSH
34971: LD_INT 2
34973: PUSH
34974: EMPTY
34975: LIST
34976: LIST
34977: PUSH
34978: LD_INT 0
34980: PUSH
34981: LD_INT 2
34983: PUSH
34984: EMPTY
34985: LIST
34986: LIST
34987: PUSH
34988: LD_INT 1
34990: NEG
34991: PUSH
34992: LD_INT 1
34994: PUSH
34995: EMPTY
34996: LIST
34997: LIST
34998: PUSH
34999: LD_INT 2
35001: NEG
35002: PUSH
35003: LD_INT 0
35005: PUSH
35006: EMPTY
35007: LIST
35008: LIST
35009: PUSH
35010: LD_INT 2
35012: NEG
35013: PUSH
35014: LD_INT 1
35016: NEG
35017: PUSH
35018: EMPTY
35019: LIST
35020: LIST
35021: PUSH
35022: LD_INT 2
35024: NEG
35025: PUSH
35026: LD_INT 2
35028: NEG
35029: PUSH
35030: EMPTY
35031: LIST
35032: LIST
35033: PUSH
35034: EMPTY
35035: LIST
35036: LIST
35037: LIST
35038: LIST
35039: LIST
35040: LIST
35041: LIST
35042: LIST
35043: LIST
35044: LIST
35045: LIST
35046: LIST
35047: LIST
35048: LIST
35049: LIST
35050: LIST
35051: LIST
35052: LIST
35053: LIST
35054: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35055: LD_ADDR_VAR 0 54
35059: PUSH
35060: LD_INT 0
35062: PUSH
35063: LD_INT 0
35065: PUSH
35066: EMPTY
35067: LIST
35068: LIST
35069: PUSH
35070: LD_INT 0
35072: PUSH
35073: LD_INT 1
35075: NEG
35076: PUSH
35077: EMPTY
35078: LIST
35079: LIST
35080: PUSH
35081: LD_INT 1
35083: PUSH
35084: LD_INT 0
35086: PUSH
35087: EMPTY
35088: LIST
35089: LIST
35090: PUSH
35091: LD_INT 1
35093: PUSH
35094: LD_INT 1
35096: PUSH
35097: EMPTY
35098: LIST
35099: LIST
35100: PUSH
35101: LD_INT 0
35103: PUSH
35104: LD_INT 1
35106: PUSH
35107: EMPTY
35108: LIST
35109: LIST
35110: PUSH
35111: LD_INT 1
35113: NEG
35114: PUSH
35115: LD_INT 0
35117: PUSH
35118: EMPTY
35119: LIST
35120: LIST
35121: PUSH
35122: LD_INT 1
35124: NEG
35125: PUSH
35126: LD_INT 1
35128: NEG
35129: PUSH
35130: EMPTY
35131: LIST
35132: LIST
35133: PUSH
35134: LD_INT 1
35136: NEG
35137: PUSH
35138: LD_INT 2
35140: NEG
35141: PUSH
35142: EMPTY
35143: LIST
35144: LIST
35145: PUSH
35146: LD_INT 0
35148: PUSH
35149: LD_INT 2
35151: NEG
35152: PUSH
35153: EMPTY
35154: LIST
35155: LIST
35156: PUSH
35157: LD_INT 1
35159: PUSH
35160: LD_INT 1
35162: NEG
35163: PUSH
35164: EMPTY
35165: LIST
35166: LIST
35167: PUSH
35168: LD_INT 2
35170: PUSH
35171: LD_INT 0
35173: PUSH
35174: EMPTY
35175: LIST
35176: LIST
35177: PUSH
35178: LD_INT 2
35180: PUSH
35181: LD_INT 1
35183: PUSH
35184: EMPTY
35185: LIST
35186: LIST
35187: PUSH
35188: LD_INT 2
35190: PUSH
35191: LD_INT 2
35193: PUSH
35194: EMPTY
35195: LIST
35196: LIST
35197: PUSH
35198: LD_INT 1
35200: PUSH
35201: LD_INT 2
35203: PUSH
35204: EMPTY
35205: LIST
35206: LIST
35207: PUSH
35208: LD_INT 0
35210: PUSH
35211: LD_INT 2
35213: PUSH
35214: EMPTY
35215: LIST
35216: LIST
35217: PUSH
35218: LD_INT 1
35220: NEG
35221: PUSH
35222: LD_INT 1
35224: PUSH
35225: EMPTY
35226: LIST
35227: LIST
35228: PUSH
35229: LD_INT 2
35231: NEG
35232: PUSH
35233: LD_INT 0
35235: PUSH
35236: EMPTY
35237: LIST
35238: LIST
35239: PUSH
35240: LD_INT 2
35242: NEG
35243: PUSH
35244: LD_INT 1
35246: NEG
35247: PUSH
35248: EMPTY
35249: LIST
35250: LIST
35251: PUSH
35252: LD_INT 2
35254: NEG
35255: PUSH
35256: LD_INT 2
35258: NEG
35259: PUSH
35260: EMPTY
35261: LIST
35262: LIST
35263: PUSH
35264: EMPTY
35265: LIST
35266: LIST
35267: LIST
35268: LIST
35269: LIST
35270: LIST
35271: LIST
35272: LIST
35273: LIST
35274: LIST
35275: LIST
35276: LIST
35277: LIST
35278: LIST
35279: LIST
35280: LIST
35281: LIST
35282: LIST
35283: LIST
35284: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35285: LD_ADDR_VAR 0 55
35289: PUSH
35290: LD_INT 0
35292: PUSH
35293: LD_INT 0
35295: PUSH
35296: EMPTY
35297: LIST
35298: LIST
35299: PUSH
35300: LD_INT 0
35302: PUSH
35303: LD_INT 1
35305: NEG
35306: PUSH
35307: EMPTY
35308: LIST
35309: LIST
35310: PUSH
35311: LD_INT 1
35313: PUSH
35314: LD_INT 0
35316: PUSH
35317: EMPTY
35318: LIST
35319: LIST
35320: PUSH
35321: LD_INT 1
35323: PUSH
35324: LD_INT 1
35326: PUSH
35327: EMPTY
35328: LIST
35329: LIST
35330: PUSH
35331: LD_INT 0
35333: PUSH
35334: LD_INT 1
35336: PUSH
35337: EMPTY
35338: LIST
35339: LIST
35340: PUSH
35341: LD_INT 1
35343: NEG
35344: PUSH
35345: LD_INT 0
35347: PUSH
35348: EMPTY
35349: LIST
35350: LIST
35351: PUSH
35352: LD_INT 1
35354: NEG
35355: PUSH
35356: LD_INT 1
35358: NEG
35359: PUSH
35360: EMPTY
35361: LIST
35362: LIST
35363: PUSH
35364: LD_INT 1
35366: NEG
35367: PUSH
35368: LD_INT 2
35370: NEG
35371: PUSH
35372: EMPTY
35373: LIST
35374: LIST
35375: PUSH
35376: LD_INT 0
35378: PUSH
35379: LD_INT 2
35381: NEG
35382: PUSH
35383: EMPTY
35384: LIST
35385: LIST
35386: PUSH
35387: LD_INT 1
35389: PUSH
35390: LD_INT 1
35392: NEG
35393: PUSH
35394: EMPTY
35395: LIST
35396: LIST
35397: PUSH
35398: LD_INT 2
35400: PUSH
35401: LD_INT 0
35403: PUSH
35404: EMPTY
35405: LIST
35406: LIST
35407: PUSH
35408: LD_INT 2
35410: PUSH
35411: LD_INT 1
35413: PUSH
35414: EMPTY
35415: LIST
35416: LIST
35417: PUSH
35418: LD_INT 2
35420: PUSH
35421: LD_INT 2
35423: PUSH
35424: EMPTY
35425: LIST
35426: LIST
35427: PUSH
35428: LD_INT 1
35430: PUSH
35431: LD_INT 2
35433: PUSH
35434: EMPTY
35435: LIST
35436: LIST
35437: PUSH
35438: LD_INT 0
35440: PUSH
35441: LD_INT 2
35443: PUSH
35444: EMPTY
35445: LIST
35446: LIST
35447: PUSH
35448: LD_INT 1
35450: NEG
35451: PUSH
35452: LD_INT 1
35454: PUSH
35455: EMPTY
35456: LIST
35457: LIST
35458: PUSH
35459: LD_INT 2
35461: NEG
35462: PUSH
35463: LD_INT 0
35465: PUSH
35466: EMPTY
35467: LIST
35468: LIST
35469: PUSH
35470: LD_INT 2
35472: NEG
35473: PUSH
35474: LD_INT 1
35476: NEG
35477: PUSH
35478: EMPTY
35479: LIST
35480: LIST
35481: PUSH
35482: LD_INT 2
35484: NEG
35485: PUSH
35486: LD_INT 2
35488: NEG
35489: PUSH
35490: EMPTY
35491: LIST
35492: LIST
35493: PUSH
35494: EMPTY
35495: LIST
35496: LIST
35497: LIST
35498: LIST
35499: LIST
35500: LIST
35501: LIST
35502: LIST
35503: LIST
35504: LIST
35505: LIST
35506: LIST
35507: LIST
35508: LIST
35509: LIST
35510: LIST
35511: LIST
35512: LIST
35513: LIST
35514: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35515: LD_ADDR_VAR 0 56
35519: PUSH
35520: LD_INT 0
35522: PUSH
35523: LD_INT 0
35525: PUSH
35526: EMPTY
35527: LIST
35528: LIST
35529: PUSH
35530: LD_INT 0
35532: PUSH
35533: LD_INT 1
35535: NEG
35536: PUSH
35537: EMPTY
35538: LIST
35539: LIST
35540: PUSH
35541: LD_INT 1
35543: PUSH
35544: LD_INT 0
35546: PUSH
35547: EMPTY
35548: LIST
35549: LIST
35550: PUSH
35551: LD_INT 1
35553: PUSH
35554: LD_INT 1
35556: PUSH
35557: EMPTY
35558: LIST
35559: LIST
35560: PUSH
35561: LD_INT 0
35563: PUSH
35564: LD_INT 1
35566: PUSH
35567: EMPTY
35568: LIST
35569: LIST
35570: PUSH
35571: LD_INT 1
35573: NEG
35574: PUSH
35575: LD_INT 0
35577: PUSH
35578: EMPTY
35579: LIST
35580: LIST
35581: PUSH
35582: LD_INT 1
35584: NEG
35585: PUSH
35586: LD_INT 1
35588: NEG
35589: PUSH
35590: EMPTY
35591: LIST
35592: LIST
35593: PUSH
35594: LD_INT 1
35596: NEG
35597: PUSH
35598: LD_INT 2
35600: NEG
35601: PUSH
35602: EMPTY
35603: LIST
35604: LIST
35605: PUSH
35606: LD_INT 0
35608: PUSH
35609: LD_INT 2
35611: NEG
35612: PUSH
35613: EMPTY
35614: LIST
35615: LIST
35616: PUSH
35617: LD_INT 1
35619: PUSH
35620: LD_INT 1
35622: NEG
35623: PUSH
35624: EMPTY
35625: LIST
35626: LIST
35627: PUSH
35628: LD_INT 2
35630: PUSH
35631: LD_INT 0
35633: PUSH
35634: EMPTY
35635: LIST
35636: LIST
35637: PUSH
35638: LD_INT 2
35640: PUSH
35641: LD_INT 1
35643: PUSH
35644: EMPTY
35645: LIST
35646: LIST
35647: PUSH
35648: LD_INT 2
35650: PUSH
35651: LD_INT 2
35653: PUSH
35654: EMPTY
35655: LIST
35656: LIST
35657: PUSH
35658: LD_INT 1
35660: PUSH
35661: LD_INT 2
35663: PUSH
35664: EMPTY
35665: LIST
35666: LIST
35667: PUSH
35668: LD_INT 0
35670: PUSH
35671: LD_INT 2
35673: PUSH
35674: EMPTY
35675: LIST
35676: LIST
35677: PUSH
35678: LD_INT 1
35680: NEG
35681: PUSH
35682: LD_INT 1
35684: PUSH
35685: EMPTY
35686: LIST
35687: LIST
35688: PUSH
35689: LD_INT 2
35691: NEG
35692: PUSH
35693: LD_INT 0
35695: PUSH
35696: EMPTY
35697: LIST
35698: LIST
35699: PUSH
35700: LD_INT 2
35702: NEG
35703: PUSH
35704: LD_INT 1
35706: NEG
35707: PUSH
35708: EMPTY
35709: LIST
35710: LIST
35711: PUSH
35712: LD_INT 2
35714: NEG
35715: PUSH
35716: LD_INT 2
35718: NEG
35719: PUSH
35720: EMPTY
35721: LIST
35722: LIST
35723: PUSH
35724: EMPTY
35725: LIST
35726: LIST
35727: LIST
35728: LIST
35729: LIST
35730: LIST
35731: LIST
35732: LIST
35733: LIST
35734: LIST
35735: LIST
35736: LIST
35737: LIST
35738: LIST
35739: LIST
35740: LIST
35741: LIST
35742: LIST
35743: LIST
35744: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35745: LD_ADDR_VAR 0 57
35749: PUSH
35750: LD_INT 0
35752: PUSH
35753: LD_INT 0
35755: PUSH
35756: EMPTY
35757: LIST
35758: LIST
35759: PUSH
35760: LD_INT 0
35762: PUSH
35763: LD_INT 1
35765: NEG
35766: PUSH
35767: EMPTY
35768: LIST
35769: LIST
35770: PUSH
35771: LD_INT 1
35773: PUSH
35774: LD_INT 0
35776: PUSH
35777: EMPTY
35778: LIST
35779: LIST
35780: PUSH
35781: LD_INT 1
35783: PUSH
35784: LD_INT 1
35786: PUSH
35787: EMPTY
35788: LIST
35789: LIST
35790: PUSH
35791: LD_INT 0
35793: PUSH
35794: LD_INT 1
35796: PUSH
35797: EMPTY
35798: LIST
35799: LIST
35800: PUSH
35801: LD_INT 1
35803: NEG
35804: PUSH
35805: LD_INT 0
35807: PUSH
35808: EMPTY
35809: LIST
35810: LIST
35811: PUSH
35812: LD_INT 1
35814: NEG
35815: PUSH
35816: LD_INT 1
35818: NEG
35819: PUSH
35820: EMPTY
35821: LIST
35822: LIST
35823: PUSH
35824: LD_INT 1
35826: NEG
35827: PUSH
35828: LD_INT 2
35830: NEG
35831: PUSH
35832: EMPTY
35833: LIST
35834: LIST
35835: PUSH
35836: LD_INT 0
35838: PUSH
35839: LD_INT 2
35841: NEG
35842: PUSH
35843: EMPTY
35844: LIST
35845: LIST
35846: PUSH
35847: LD_INT 1
35849: PUSH
35850: LD_INT 1
35852: NEG
35853: PUSH
35854: EMPTY
35855: LIST
35856: LIST
35857: PUSH
35858: LD_INT 2
35860: PUSH
35861: LD_INT 0
35863: PUSH
35864: EMPTY
35865: LIST
35866: LIST
35867: PUSH
35868: LD_INT 2
35870: PUSH
35871: LD_INT 1
35873: PUSH
35874: EMPTY
35875: LIST
35876: LIST
35877: PUSH
35878: LD_INT 2
35880: PUSH
35881: LD_INT 2
35883: PUSH
35884: EMPTY
35885: LIST
35886: LIST
35887: PUSH
35888: LD_INT 1
35890: PUSH
35891: LD_INT 2
35893: PUSH
35894: EMPTY
35895: LIST
35896: LIST
35897: PUSH
35898: LD_INT 0
35900: PUSH
35901: LD_INT 2
35903: PUSH
35904: EMPTY
35905: LIST
35906: LIST
35907: PUSH
35908: LD_INT 1
35910: NEG
35911: PUSH
35912: LD_INT 1
35914: PUSH
35915: EMPTY
35916: LIST
35917: LIST
35918: PUSH
35919: LD_INT 2
35921: NEG
35922: PUSH
35923: LD_INT 0
35925: PUSH
35926: EMPTY
35927: LIST
35928: LIST
35929: PUSH
35930: LD_INT 2
35932: NEG
35933: PUSH
35934: LD_INT 1
35936: NEG
35937: PUSH
35938: EMPTY
35939: LIST
35940: LIST
35941: PUSH
35942: LD_INT 2
35944: NEG
35945: PUSH
35946: LD_INT 2
35948: NEG
35949: PUSH
35950: EMPTY
35951: LIST
35952: LIST
35953: PUSH
35954: EMPTY
35955: LIST
35956: LIST
35957: LIST
35958: LIST
35959: LIST
35960: LIST
35961: LIST
35962: LIST
35963: LIST
35964: LIST
35965: LIST
35966: LIST
35967: LIST
35968: LIST
35969: LIST
35970: LIST
35971: LIST
35972: LIST
35973: LIST
35974: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35975: LD_ADDR_VAR 0 58
35979: PUSH
35980: LD_INT 0
35982: PUSH
35983: LD_INT 0
35985: PUSH
35986: EMPTY
35987: LIST
35988: LIST
35989: PUSH
35990: LD_INT 0
35992: PUSH
35993: LD_INT 1
35995: NEG
35996: PUSH
35997: EMPTY
35998: LIST
35999: LIST
36000: PUSH
36001: LD_INT 1
36003: PUSH
36004: LD_INT 0
36006: PUSH
36007: EMPTY
36008: LIST
36009: LIST
36010: PUSH
36011: LD_INT 1
36013: PUSH
36014: LD_INT 1
36016: PUSH
36017: EMPTY
36018: LIST
36019: LIST
36020: PUSH
36021: LD_INT 0
36023: PUSH
36024: LD_INT 1
36026: PUSH
36027: EMPTY
36028: LIST
36029: LIST
36030: PUSH
36031: LD_INT 1
36033: NEG
36034: PUSH
36035: LD_INT 0
36037: PUSH
36038: EMPTY
36039: LIST
36040: LIST
36041: PUSH
36042: LD_INT 1
36044: NEG
36045: PUSH
36046: LD_INT 1
36048: NEG
36049: PUSH
36050: EMPTY
36051: LIST
36052: LIST
36053: PUSH
36054: LD_INT 1
36056: NEG
36057: PUSH
36058: LD_INT 2
36060: NEG
36061: PUSH
36062: EMPTY
36063: LIST
36064: LIST
36065: PUSH
36066: LD_INT 0
36068: PUSH
36069: LD_INT 2
36071: NEG
36072: PUSH
36073: EMPTY
36074: LIST
36075: LIST
36076: PUSH
36077: LD_INT 1
36079: PUSH
36080: LD_INT 1
36082: NEG
36083: PUSH
36084: EMPTY
36085: LIST
36086: LIST
36087: PUSH
36088: LD_INT 2
36090: PUSH
36091: LD_INT 0
36093: PUSH
36094: EMPTY
36095: LIST
36096: LIST
36097: PUSH
36098: LD_INT 2
36100: PUSH
36101: LD_INT 1
36103: PUSH
36104: EMPTY
36105: LIST
36106: LIST
36107: PUSH
36108: LD_INT 2
36110: PUSH
36111: LD_INT 2
36113: PUSH
36114: EMPTY
36115: LIST
36116: LIST
36117: PUSH
36118: LD_INT 1
36120: PUSH
36121: LD_INT 2
36123: PUSH
36124: EMPTY
36125: LIST
36126: LIST
36127: PUSH
36128: LD_INT 0
36130: PUSH
36131: LD_INT 2
36133: PUSH
36134: EMPTY
36135: LIST
36136: LIST
36137: PUSH
36138: LD_INT 1
36140: NEG
36141: PUSH
36142: LD_INT 1
36144: PUSH
36145: EMPTY
36146: LIST
36147: LIST
36148: PUSH
36149: LD_INT 2
36151: NEG
36152: PUSH
36153: LD_INT 0
36155: PUSH
36156: EMPTY
36157: LIST
36158: LIST
36159: PUSH
36160: LD_INT 2
36162: NEG
36163: PUSH
36164: LD_INT 1
36166: NEG
36167: PUSH
36168: EMPTY
36169: LIST
36170: LIST
36171: PUSH
36172: LD_INT 2
36174: NEG
36175: PUSH
36176: LD_INT 2
36178: NEG
36179: PUSH
36180: EMPTY
36181: LIST
36182: LIST
36183: PUSH
36184: EMPTY
36185: LIST
36186: LIST
36187: LIST
36188: LIST
36189: LIST
36190: LIST
36191: LIST
36192: LIST
36193: LIST
36194: LIST
36195: LIST
36196: LIST
36197: LIST
36198: LIST
36199: LIST
36200: LIST
36201: LIST
36202: LIST
36203: LIST
36204: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36205: LD_ADDR_VAR 0 59
36209: PUSH
36210: LD_INT 0
36212: PUSH
36213: LD_INT 0
36215: PUSH
36216: EMPTY
36217: LIST
36218: LIST
36219: PUSH
36220: LD_INT 0
36222: PUSH
36223: LD_INT 1
36225: NEG
36226: PUSH
36227: EMPTY
36228: LIST
36229: LIST
36230: PUSH
36231: LD_INT 1
36233: PUSH
36234: LD_INT 0
36236: PUSH
36237: EMPTY
36238: LIST
36239: LIST
36240: PUSH
36241: LD_INT 1
36243: PUSH
36244: LD_INT 1
36246: PUSH
36247: EMPTY
36248: LIST
36249: LIST
36250: PUSH
36251: LD_INT 0
36253: PUSH
36254: LD_INT 1
36256: PUSH
36257: EMPTY
36258: LIST
36259: LIST
36260: PUSH
36261: LD_INT 1
36263: NEG
36264: PUSH
36265: LD_INT 0
36267: PUSH
36268: EMPTY
36269: LIST
36270: LIST
36271: PUSH
36272: LD_INT 1
36274: NEG
36275: PUSH
36276: LD_INT 1
36278: NEG
36279: PUSH
36280: EMPTY
36281: LIST
36282: LIST
36283: PUSH
36284: EMPTY
36285: LIST
36286: LIST
36287: LIST
36288: LIST
36289: LIST
36290: LIST
36291: LIST
36292: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36293: LD_ADDR_VAR 0 60
36297: PUSH
36298: LD_INT 0
36300: PUSH
36301: LD_INT 0
36303: PUSH
36304: EMPTY
36305: LIST
36306: LIST
36307: PUSH
36308: LD_INT 0
36310: PUSH
36311: LD_INT 1
36313: NEG
36314: PUSH
36315: EMPTY
36316: LIST
36317: LIST
36318: PUSH
36319: LD_INT 1
36321: PUSH
36322: LD_INT 0
36324: PUSH
36325: EMPTY
36326: LIST
36327: LIST
36328: PUSH
36329: LD_INT 1
36331: PUSH
36332: LD_INT 1
36334: PUSH
36335: EMPTY
36336: LIST
36337: LIST
36338: PUSH
36339: LD_INT 0
36341: PUSH
36342: LD_INT 1
36344: PUSH
36345: EMPTY
36346: LIST
36347: LIST
36348: PUSH
36349: LD_INT 1
36351: NEG
36352: PUSH
36353: LD_INT 0
36355: PUSH
36356: EMPTY
36357: LIST
36358: LIST
36359: PUSH
36360: LD_INT 1
36362: NEG
36363: PUSH
36364: LD_INT 1
36366: NEG
36367: PUSH
36368: EMPTY
36369: LIST
36370: LIST
36371: PUSH
36372: EMPTY
36373: LIST
36374: LIST
36375: LIST
36376: LIST
36377: LIST
36378: LIST
36379: LIST
36380: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36381: LD_ADDR_VAR 0 61
36385: PUSH
36386: LD_INT 0
36388: PUSH
36389: LD_INT 0
36391: PUSH
36392: EMPTY
36393: LIST
36394: LIST
36395: PUSH
36396: LD_INT 0
36398: PUSH
36399: LD_INT 1
36401: NEG
36402: PUSH
36403: EMPTY
36404: LIST
36405: LIST
36406: PUSH
36407: LD_INT 1
36409: PUSH
36410: LD_INT 0
36412: PUSH
36413: EMPTY
36414: LIST
36415: LIST
36416: PUSH
36417: LD_INT 1
36419: PUSH
36420: LD_INT 1
36422: PUSH
36423: EMPTY
36424: LIST
36425: LIST
36426: PUSH
36427: LD_INT 0
36429: PUSH
36430: LD_INT 1
36432: PUSH
36433: EMPTY
36434: LIST
36435: LIST
36436: PUSH
36437: LD_INT 1
36439: NEG
36440: PUSH
36441: LD_INT 0
36443: PUSH
36444: EMPTY
36445: LIST
36446: LIST
36447: PUSH
36448: LD_INT 1
36450: NEG
36451: PUSH
36452: LD_INT 1
36454: NEG
36455: PUSH
36456: EMPTY
36457: LIST
36458: LIST
36459: PUSH
36460: EMPTY
36461: LIST
36462: LIST
36463: LIST
36464: LIST
36465: LIST
36466: LIST
36467: LIST
36468: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36469: LD_ADDR_VAR 0 62
36473: PUSH
36474: LD_INT 0
36476: PUSH
36477: LD_INT 0
36479: PUSH
36480: EMPTY
36481: LIST
36482: LIST
36483: PUSH
36484: LD_INT 0
36486: PUSH
36487: LD_INT 1
36489: NEG
36490: PUSH
36491: EMPTY
36492: LIST
36493: LIST
36494: PUSH
36495: LD_INT 1
36497: PUSH
36498: LD_INT 0
36500: PUSH
36501: EMPTY
36502: LIST
36503: LIST
36504: PUSH
36505: LD_INT 1
36507: PUSH
36508: LD_INT 1
36510: PUSH
36511: EMPTY
36512: LIST
36513: LIST
36514: PUSH
36515: LD_INT 0
36517: PUSH
36518: LD_INT 1
36520: PUSH
36521: EMPTY
36522: LIST
36523: LIST
36524: PUSH
36525: LD_INT 1
36527: NEG
36528: PUSH
36529: LD_INT 0
36531: PUSH
36532: EMPTY
36533: LIST
36534: LIST
36535: PUSH
36536: LD_INT 1
36538: NEG
36539: PUSH
36540: LD_INT 1
36542: NEG
36543: PUSH
36544: EMPTY
36545: LIST
36546: LIST
36547: PUSH
36548: EMPTY
36549: LIST
36550: LIST
36551: LIST
36552: LIST
36553: LIST
36554: LIST
36555: LIST
36556: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36557: LD_ADDR_VAR 0 63
36561: PUSH
36562: LD_INT 0
36564: PUSH
36565: LD_INT 0
36567: PUSH
36568: EMPTY
36569: LIST
36570: LIST
36571: PUSH
36572: LD_INT 0
36574: PUSH
36575: LD_INT 1
36577: NEG
36578: PUSH
36579: EMPTY
36580: LIST
36581: LIST
36582: PUSH
36583: LD_INT 1
36585: PUSH
36586: LD_INT 0
36588: PUSH
36589: EMPTY
36590: LIST
36591: LIST
36592: PUSH
36593: LD_INT 1
36595: PUSH
36596: LD_INT 1
36598: PUSH
36599: EMPTY
36600: LIST
36601: LIST
36602: PUSH
36603: LD_INT 0
36605: PUSH
36606: LD_INT 1
36608: PUSH
36609: EMPTY
36610: LIST
36611: LIST
36612: PUSH
36613: LD_INT 1
36615: NEG
36616: PUSH
36617: LD_INT 0
36619: PUSH
36620: EMPTY
36621: LIST
36622: LIST
36623: PUSH
36624: LD_INT 1
36626: NEG
36627: PUSH
36628: LD_INT 1
36630: NEG
36631: PUSH
36632: EMPTY
36633: LIST
36634: LIST
36635: PUSH
36636: EMPTY
36637: LIST
36638: LIST
36639: LIST
36640: LIST
36641: LIST
36642: LIST
36643: LIST
36644: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36645: LD_ADDR_VAR 0 64
36649: PUSH
36650: LD_INT 0
36652: PUSH
36653: LD_INT 0
36655: PUSH
36656: EMPTY
36657: LIST
36658: LIST
36659: PUSH
36660: LD_INT 0
36662: PUSH
36663: LD_INT 1
36665: NEG
36666: PUSH
36667: EMPTY
36668: LIST
36669: LIST
36670: PUSH
36671: LD_INT 1
36673: PUSH
36674: LD_INT 0
36676: PUSH
36677: EMPTY
36678: LIST
36679: LIST
36680: PUSH
36681: LD_INT 1
36683: PUSH
36684: LD_INT 1
36686: PUSH
36687: EMPTY
36688: LIST
36689: LIST
36690: PUSH
36691: LD_INT 0
36693: PUSH
36694: LD_INT 1
36696: PUSH
36697: EMPTY
36698: LIST
36699: LIST
36700: PUSH
36701: LD_INT 1
36703: NEG
36704: PUSH
36705: LD_INT 0
36707: PUSH
36708: EMPTY
36709: LIST
36710: LIST
36711: PUSH
36712: LD_INT 1
36714: NEG
36715: PUSH
36716: LD_INT 1
36718: NEG
36719: PUSH
36720: EMPTY
36721: LIST
36722: LIST
36723: PUSH
36724: EMPTY
36725: LIST
36726: LIST
36727: LIST
36728: LIST
36729: LIST
36730: LIST
36731: LIST
36732: ST_TO_ADDR
// end ; 1 :
36733: GO 42630
36735: LD_INT 1
36737: DOUBLE
36738: EQUAL
36739: IFTRUE 36743
36741: GO 39366
36743: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
36744: LD_ADDR_VAR 0 11
36748: PUSH
36749: LD_INT 1
36751: NEG
36752: PUSH
36753: LD_INT 3
36755: NEG
36756: PUSH
36757: EMPTY
36758: LIST
36759: LIST
36760: PUSH
36761: LD_INT 0
36763: PUSH
36764: LD_INT 3
36766: NEG
36767: PUSH
36768: EMPTY
36769: LIST
36770: LIST
36771: PUSH
36772: LD_INT 1
36774: PUSH
36775: LD_INT 2
36777: NEG
36778: PUSH
36779: EMPTY
36780: LIST
36781: LIST
36782: PUSH
36783: EMPTY
36784: LIST
36785: LIST
36786: LIST
36787: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
36788: LD_ADDR_VAR 0 12
36792: PUSH
36793: LD_INT 2
36795: PUSH
36796: LD_INT 1
36798: NEG
36799: PUSH
36800: EMPTY
36801: LIST
36802: LIST
36803: PUSH
36804: LD_INT 3
36806: PUSH
36807: LD_INT 0
36809: PUSH
36810: EMPTY
36811: LIST
36812: LIST
36813: PUSH
36814: LD_INT 3
36816: PUSH
36817: LD_INT 1
36819: PUSH
36820: EMPTY
36821: LIST
36822: LIST
36823: PUSH
36824: EMPTY
36825: LIST
36826: LIST
36827: LIST
36828: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
36829: LD_ADDR_VAR 0 13
36833: PUSH
36834: LD_INT 3
36836: PUSH
36837: LD_INT 2
36839: PUSH
36840: EMPTY
36841: LIST
36842: LIST
36843: PUSH
36844: LD_INT 3
36846: PUSH
36847: LD_INT 3
36849: PUSH
36850: EMPTY
36851: LIST
36852: LIST
36853: PUSH
36854: LD_INT 2
36856: PUSH
36857: LD_INT 3
36859: PUSH
36860: EMPTY
36861: LIST
36862: LIST
36863: PUSH
36864: EMPTY
36865: LIST
36866: LIST
36867: LIST
36868: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
36869: LD_ADDR_VAR 0 14
36873: PUSH
36874: LD_INT 1
36876: PUSH
36877: LD_INT 3
36879: PUSH
36880: EMPTY
36881: LIST
36882: LIST
36883: PUSH
36884: LD_INT 0
36886: PUSH
36887: LD_INT 3
36889: PUSH
36890: EMPTY
36891: LIST
36892: LIST
36893: PUSH
36894: LD_INT 1
36896: NEG
36897: PUSH
36898: LD_INT 2
36900: PUSH
36901: EMPTY
36902: LIST
36903: LIST
36904: PUSH
36905: EMPTY
36906: LIST
36907: LIST
36908: LIST
36909: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36910: LD_ADDR_VAR 0 15
36914: PUSH
36915: LD_INT 2
36917: NEG
36918: PUSH
36919: LD_INT 1
36921: PUSH
36922: EMPTY
36923: LIST
36924: LIST
36925: PUSH
36926: LD_INT 3
36928: NEG
36929: PUSH
36930: LD_INT 0
36932: PUSH
36933: EMPTY
36934: LIST
36935: LIST
36936: PUSH
36937: LD_INT 3
36939: NEG
36940: PUSH
36941: LD_INT 1
36943: NEG
36944: PUSH
36945: EMPTY
36946: LIST
36947: LIST
36948: PUSH
36949: EMPTY
36950: LIST
36951: LIST
36952: LIST
36953: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36954: LD_ADDR_VAR 0 16
36958: PUSH
36959: LD_INT 2
36961: NEG
36962: PUSH
36963: LD_INT 3
36965: NEG
36966: PUSH
36967: EMPTY
36968: LIST
36969: LIST
36970: PUSH
36971: LD_INT 3
36973: NEG
36974: PUSH
36975: LD_INT 2
36977: NEG
36978: PUSH
36979: EMPTY
36980: LIST
36981: LIST
36982: PUSH
36983: LD_INT 3
36985: NEG
36986: PUSH
36987: LD_INT 3
36989: NEG
36990: PUSH
36991: EMPTY
36992: LIST
36993: LIST
36994: PUSH
36995: EMPTY
36996: LIST
36997: LIST
36998: LIST
36999: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
37000: LD_ADDR_VAR 0 17
37004: PUSH
37005: LD_INT 1
37007: NEG
37008: PUSH
37009: LD_INT 3
37011: NEG
37012: PUSH
37013: EMPTY
37014: LIST
37015: LIST
37016: PUSH
37017: LD_INT 0
37019: PUSH
37020: LD_INT 3
37022: NEG
37023: PUSH
37024: EMPTY
37025: LIST
37026: LIST
37027: PUSH
37028: LD_INT 1
37030: PUSH
37031: LD_INT 2
37033: NEG
37034: PUSH
37035: EMPTY
37036: LIST
37037: LIST
37038: PUSH
37039: EMPTY
37040: LIST
37041: LIST
37042: LIST
37043: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
37044: LD_ADDR_VAR 0 18
37048: PUSH
37049: LD_INT 2
37051: PUSH
37052: LD_INT 1
37054: NEG
37055: PUSH
37056: EMPTY
37057: LIST
37058: LIST
37059: PUSH
37060: LD_INT 3
37062: PUSH
37063: LD_INT 0
37065: PUSH
37066: EMPTY
37067: LIST
37068: LIST
37069: PUSH
37070: LD_INT 3
37072: PUSH
37073: LD_INT 1
37075: PUSH
37076: EMPTY
37077: LIST
37078: LIST
37079: PUSH
37080: EMPTY
37081: LIST
37082: LIST
37083: LIST
37084: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
37085: LD_ADDR_VAR 0 19
37089: PUSH
37090: LD_INT 3
37092: PUSH
37093: LD_INT 2
37095: PUSH
37096: EMPTY
37097: LIST
37098: LIST
37099: PUSH
37100: LD_INT 3
37102: PUSH
37103: LD_INT 3
37105: PUSH
37106: EMPTY
37107: LIST
37108: LIST
37109: PUSH
37110: LD_INT 2
37112: PUSH
37113: LD_INT 3
37115: PUSH
37116: EMPTY
37117: LIST
37118: LIST
37119: PUSH
37120: EMPTY
37121: LIST
37122: LIST
37123: LIST
37124: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37125: LD_ADDR_VAR 0 20
37129: PUSH
37130: LD_INT 1
37132: PUSH
37133: LD_INT 3
37135: PUSH
37136: EMPTY
37137: LIST
37138: LIST
37139: PUSH
37140: LD_INT 0
37142: PUSH
37143: LD_INT 3
37145: PUSH
37146: EMPTY
37147: LIST
37148: LIST
37149: PUSH
37150: LD_INT 1
37152: NEG
37153: PUSH
37154: LD_INT 2
37156: PUSH
37157: EMPTY
37158: LIST
37159: LIST
37160: PUSH
37161: EMPTY
37162: LIST
37163: LIST
37164: LIST
37165: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37166: LD_ADDR_VAR 0 21
37170: PUSH
37171: LD_INT 2
37173: NEG
37174: PUSH
37175: LD_INT 1
37177: PUSH
37178: EMPTY
37179: LIST
37180: LIST
37181: PUSH
37182: LD_INT 3
37184: NEG
37185: PUSH
37186: LD_INT 0
37188: PUSH
37189: EMPTY
37190: LIST
37191: LIST
37192: PUSH
37193: LD_INT 3
37195: NEG
37196: PUSH
37197: LD_INT 1
37199: NEG
37200: PUSH
37201: EMPTY
37202: LIST
37203: LIST
37204: PUSH
37205: EMPTY
37206: LIST
37207: LIST
37208: LIST
37209: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37210: LD_ADDR_VAR 0 22
37214: PUSH
37215: LD_INT 2
37217: NEG
37218: PUSH
37219: LD_INT 3
37221: NEG
37222: PUSH
37223: EMPTY
37224: LIST
37225: LIST
37226: PUSH
37227: LD_INT 3
37229: NEG
37230: PUSH
37231: LD_INT 2
37233: NEG
37234: PUSH
37235: EMPTY
37236: LIST
37237: LIST
37238: PUSH
37239: LD_INT 3
37241: NEG
37242: PUSH
37243: LD_INT 3
37245: NEG
37246: PUSH
37247: EMPTY
37248: LIST
37249: LIST
37250: PUSH
37251: EMPTY
37252: LIST
37253: LIST
37254: LIST
37255: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
37256: LD_ADDR_VAR 0 23
37260: PUSH
37261: LD_INT 0
37263: PUSH
37264: LD_INT 3
37266: NEG
37267: PUSH
37268: EMPTY
37269: LIST
37270: LIST
37271: PUSH
37272: LD_INT 1
37274: NEG
37275: PUSH
37276: LD_INT 4
37278: NEG
37279: PUSH
37280: EMPTY
37281: LIST
37282: LIST
37283: PUSH
37284: LD_INT 1
37286: PUSH
37287: LD_INT 3
37289: NEG
37290: PUSH
37291: EMPTY
37292: LIST
37293: LIST
37294: PUSH
37295: EMPTY
37296: LIST
37297: LIST
37298: LIST
37299: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
37300: LD_ADDR_VAR 0 24
37304: PUSH
37305: LD_INT 3
37307: PUSH
37308: LD_INT 0
37310: PUSH
37311: EMPTY
37312: LIST
37313: LIST
37314: PUSH
37315: LD_INT 3
37317: PUSH
37318: LD_INT 1
37320: NEG
37321: PUSH
37322: EMPTY
37323: LIST
37324: LIST
37325: PUSH
37326: LD_INT 4
37328: PUSH
37329: LD_INT 1
37331: PUSH
37332: EMPTY
37333: LIST
37334: LIST
37335: PUSH
37336: EMPTY
37337: LIST
37338: LIST
37339: LIST
37340: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
37341: LD_ADDR_VAR 0 25
37345: PUSH
37346: LD_INT 3
37348: PUSH
37349: LD_INT 3
37351: PUSH
37352: EMPTY
37353: LIST
37354: LIST
37355: PUSH
37356: LD_INT 4
37358: PUSH
37359: LD_INT 3
37361: PUSH
37362: EMPTY
37363: LIST
37364: LIST
37365: PUSH
37366: LD_INT 3
37368: PUSH
37369: LD_INT 4
37371: PUSH
37372: EMPTY
37373: LIST
37374: LIST
37375: PUSH
37376: EMPTY
37377: LIST
37378: LIST
37379: LIST
37380: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
37381: LD_ADDR_VAR 0 26
37385: PUSH
37386: LD_INT 0
37388: PUSH
37389: LD_INT 3
37391: PUSH
37392: EMPTY
37393: LIST
37394: LIST
37395: PUSH
37396: LD_INT 1
37398: PUSH
37399: LD_INT 4
37401: PUSH
37402: EMPTY
37403: LIST
37404: LIST
37405: PUSH
37406: LD_INT 1
37408: NEG
37409: PUSH
37410: LD_INT 3
37412: PUSH
37413: EMPTY
37414: LIST
37415: LIST
37416: PUSH
37417: EMPTY
37418: LIST
37419: LIST
37420: LIST
37421: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
37422: LD_ADDR_VAR 0 27
37426: PUSH
37427: LD_INT 3
37429: NEG
37430: PUSH
37431: LD_INT 0
37433: PUSH
37434: EMPTY
37435: LIST
37436: LIST
37437: PUSH
37438: LD_INT 3
37440: NEG
37441: PUSH
37442: LD_INT 1
37444: PUSH
37445: EMPTY
37446: LIST
37447: LIST
37448: PUSH
37449: LD_INT 4
37451: NEG
37452: PUSH
37453: LD_INT 1
37455: NEG
37456: PUSH
37457: EMPTY
37458: LIST
37459: LIST
37460: PUSH
37461: EMPTY
37462: LIST
37463: LIST
37464: LIST
37465: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
37466: LD_ADDR_VAR 0 28
37470: PUSH
37471: LD_INT 3
37473: NEG
37474: PUSH
37475: LD_INT 3
37477: NEG
37478: PUSH
37479: EMPTY
37480: LIST
37481: LIST
37482: PUSH
37483: LD_INT 3
37485: NEG
37486: PUSH
37487: LD_INT 4
37489: NEG
37490: PUSH
37491: EMPTY
37492: LIST
37493: LIST
37494: PUSH
37495: LD_INT 4
37497: NEG
37498: PUSH
37499: LD_INT 3
37501: NEG
37502: PUSH
37503: EMPTY
37504: LIST
37505: LIST
37506: PUSH
37507: EMPTY
37508: LIST
37509: LIST
37510: LIST
37511: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
37512: LD_ADDR_VAR 0 29
37516: PUSH
37517: LD_INT 1
37519: NEG
37520: PUSH
37521: LD_INT 3
37523: NEG
37524: PUSH
37525: EMPTY
37526: LIST
37527: LIST
37528: PUSH
37529: LD_INT 0
37531: PUSH
37532: LD_INT 3
37534: NEG
37535: PUSH
37536: EMPTY
37537: LIST
37538: LIST
37539: PUSH
37540: LD_INT 1
37542: PUSH
37543: LD_INT 2
37545: NEG
37546: PUSH
37547: EMPTY
37548: LIST
37549: LIST
37550: PUSH
37551: LD_INT 1
37553: NEG
37554: PUSH
37555: LD_INT 4
37557: NEG
37558: PUSH
37559: EMPTY
37560: LIST
37561: LIST
37562: PUSH
37563: LD_INT 0
37565: PUSH
37566: LD_INT 4
37568: NEG
37569: PUSH
37570: EMPTY
37571: LIST
37572: LIST
37573: PUSH
37574: LD_INT 1
37576: PUSH
37577: LD_INT 3
37579: NEG
37580: PUSH
37581: EMPTY
37582: LIST
37583: LIST
37584: PUSH
37585: LD_INT 1
37587: NEG
37588: PUSH
37589: LD_INT 5
37591: NEG
37592: PUSH
37593: EMPTY
37594: LIST
37595: LIST
37596: PUSH
37597: LD_INT 0
37599: PUSH
37600: LD_INT 5
37602: NEG
37603: PUSH
37604: EMPTY
37605: LIST
37606: LIST
37607: PUSH
37608: LD_INT 1
37610: PUSH
37611: LD_INT 4
37613: NEG
37614: PUSH
37615: EMPTY
37616: LIST
37617: LIST
37618: PUSH
37619: LD_INT 1
37621: NEG
37622: PUSH
37623: LD_INT 6
37625: NEG
37626: PUSH
37627: EMPTY
37628: LIST
37629: LIST
37630: PUSH
37631: LD_INT 0
37633: PUSH
37634: LD_INT 6
37636: NEG
37637: PUSH
37638: EMPTY
37639: LIST
37640: LIST
37641: PUSH
37642: LD_INT 1
37644: PUSH
37645: LD_INT 5
37647: NEG
37648: PUSH
37649: EMPTY
37650: LIST
37651: LIST
37652: PUSH
37653: EMPTY
37654: LIST
37655: LIST
37656: LIST
37657: LIST
37658: LIST
37659: LIST
37660: LIST
37661: LIST
37662: LIST
37663: LIST
37664: LIST
37665: LIST
37666: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
37667: LD_ADDR_VAR 0 30
37671: PUSH
37672: LD_INT 2
37674: PUSH
37675: LD_INT 1
37677: NEG
37678: PUSH
37679: EMPTY
37680: LIST
37681: LIST
37682: PUSH
37683: LD_INT 3
37685: PUSH
37686: LD_INT 0
37688: PUSH
37689: EMPTY
37690: LIST
37691: LIST
37692: PUSH
37693: LD_INT 3
37695: PUSH
37696: LD_INT 1
37698: PUSH
37699: EMPTY
37700: LIST
37701: LIST
37702: PUSH
37703: LD_INT 3
37705: PUSH
37706: LD_INT 1
37708: NEG
37709: PUSH
37710: EMPTY
37711: LIST
37712: LIST
37713: PUSH
37714: LD_INT 4
37716: PUSH
37717: LD_INT 0
37719: PUSH
37720: EMPTY
37721: LIST
37722: LIST
37723: PUSH
37724: LD_INT 4
37726: PUSH
37727: LD_INT 1
37729: PUSH
37730: EMPTY
37731: LIST
37732: LIST
37733: PUSH
37734: LD_INT 4
37736: PUSH
37737: LD_INT 1
37739: NEG
37740: PUSH
37741: EMPTY
37742: LIST
37743: LIST
37744: PUSH
37745: LD_INT 5
37747: PUSH
37748: LD_INT 0
37750: PUSH
37751: EMPTY
37752: LIST
37753: LIST
37754: PUSH
37755: LD_INT 5
37757: PUSH
37758: LD_INT 1
37760: PUSH
37761: EMPTY
37762: LIST
37763: LIST
37764: PUSH
37765: LD_INT 5
37767: PUSH
37768: LD_INT 1
37770: NEG
37771: PUSH
37772: EMPTY
37773: LIST
37774: LIST
37775: PUSH
37776: LD_INT 6
37778: PUSH
37779: LD_INT 0
37781: PUSH
37782: EMPTY
37783: LIST
37784: LIST
37785: PUSH
37786: LD_INT 6
37788: PUSH
37789: LD_INT 1
37791: PUSH
37792: EMPTY
37793: LIST
37794: LIST
37795: PUSH
37796: EMPTY
37797: LIST
37798: LIST
37799: LIST
37800: LIST
37801: LIST
37802: LIST
37803: LIST
37804: LIST
37805: LIST
37806: LIST
37807: LIST
37808: LIST
37809: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
37810: LD_ADDR_VAR 0 31
37814: PUSH
37815: LD_INT 3
37817: PUSH
37818: LD_INT 2
37820: PUSH
37821: EMPTY
37822: LIST
37823: LIST
37824: PUSH
37825: LD_INT 3
37827: PUSH
37828: LD_INT 3
37830: PUSH
37831: EMPTY
37832: LIST
37833: LIST
37834: PUSH
37835: LD_INT 2
37837: PUSH
37838: LD_INT 3
37840: PUSH
37841: EMPTY
37842: LIST
37843: LIST
37844: PUSH
37845: LD_INT 4
37847: PUSH
37848: LD_INT 3
37850: PUSH
37851: EMPTY
37852: LIST
37853: LIST
37854: PUSH
37855: LD_INT 4
37857: PUSH
37858: LD_INT 4
37860: PUSH
37861: EMPTY
37862: LIST
37863: LIST
37864: PUSH
37865: LD_INT 3
37867: PUSH
37868: LD_INT 4
37870: PUSH
37871: EMPTY
37872: LIST
37873: LIST
37874: PUSH
37875: LD_INT 5
37877: PUSH
37878: LD_INT 4
37880: PUSH
37881: EMPTY
37882: LIST
37883: LIST
37884: PUSH
37885: LD_INT 5
37887: PUSH
37888: LD_INT 5
37890: PUSH
37891: EMPTY
37892: LIST
37893: LIST
37894: PUSH
37895: LD_INT 4
37897: PUSH
37898: LD_INT 5
37900: PUSH
37901: EMPTY
37902: LIST
37903: LIST
37904: PUSH
37905: LD_INT 6
37907: PUSH
37908: LD_INT 5
37910: PUSH
37911: EMPTY
37912: LIST
37913: LIST
37914: PUSH
37915: LD_INT 6
37917: PUSH
37918: LD_INT 6
37920: PUSH
37921: EMPTY
37922: LIST
37923: LIST
37924: PUSH
37925: LD_INT 5
37927: PUSH
37928: LD_INT 6
37930: PUSH
37931: EMPTY
37932: LIST
37933: LIST
37934: PUSH
37935: EMPTY
37936: LIST
37937: LIST
37938: LIST
37939: LIST
37940: LIST
37941: LIST
37942: LIST
37943: LIST
37944: LIST
37945: LIST
37946: LIST
37947: LIST
37948: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
37949: LD_ADDR_VAR 0 32
37953: PUSH
37954: LD_INT 1
37956: PUSH
37957: LD_INT 3
37959: PUSH
37960: EMPTY
37961: LIST
37962: LIST
37963: PUSH
37964: LD_INT 0
37966: PUSH
37967: LD_INT 3
37969: PUSH
37970: EMPTY
37971: LIST
37972: LIST
37973: PUSH
37974: LD_INT 1
37976: NEG
37977: PUSH
37978: LD_INT 2
37980: PUSH
37981: EMPTY
37982: LIST
37983: LIST
37984: PUSH
37985: LD_INT 1
37987: PUSH
37988: LD_INT 4
37990: PUSH
37991: EMPTY
37992: LIST
37993: LIST
37994: PUSH
37995: LD_INT 0
37997: PUSH
37998: LD_INT 4
38000: PUSH
38001: EMPTY
38002: LIST
38003: LIST
38004: PUSH
38005: LD_INT 1
38007: NEG
38008: PUSH
38009: LD_INT 3
38011: PUSH
38012: EMPTY
38013: LIST
38014: LIST
38015: PUSH
38016: LD_INT 1
38018: PUSH
38019: LD_INT 5
38021: PUSH
38022: EMPTY
38023: LIST
38024: LIST
38025: PUSH
38026: LD_INT 0
38028: PUSH
38029: LD_INT 5
38031: PUSH
38032: EMPTY
38033: LIST
38034: LIST
38035: PUSH
38036: LD_INT 1
38038: NEG
38039: PUSH
38040: LD_INT 4
38042: PUSH
38043: EMPTY
38044: LIST
38045: LIST
38046: PUSH
38047: LD_INT 1
38049: PUSH
38050: LD_INT 6
38052: PUSH
38053: EMPTY
38054: LIST
38055: LIST
38056: PUSH
38057: LD_INT 0
38059: PUSH
38060: LD_INT 6
38062: PUSH
38063: EMPTY
38064: LIST
38065: LIST
38066: PUSH
38067: LD_INT 1
38069: NEG
38070: PUSH
38071: LD_INT 5
38073: PUSH
38074: EMPTY
38075: LIST
38076: LIST
38077: PUSH
38078: EMPTY
38079: LIST
38080: LIST
38081: LIST
38082: LIST
38083: LIST
38084: LIST
38085: LIST
38086: LIST
38087: LIST
38088: LIST
38089: LIST
38090: LIST
38091: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
38092: LD_ADDR_VAR 0 33
38096: PUSH
38097: LD_INT 2
38099: NEG
38100: PUSH
38101: LD_INT 1
38103: PUSH
38104: EMPTY
38105: LIST
38106: LIST
38107: PUSH
38108: LD_INT 3
38110: NEG
38111: PUSH
38112: LD_INT 0
38114: PUSH
38115: EMPTY
38116: LIST
38117: LIST
38118: PUSH
38119: LD_INT 3
38121: NEG
38122: PUSH
38123: LD_INT 1
38125: NEG
38126: PUSH
38127: EMPTY
38128: LIST
38129: LIST
38130: PUSH
38131: LD_INT 3
38133: NEG
38134: PUSH
38135: LD_INT 1
38137: PUSH
38138: EMPTY
38139: LIST
38140: LIST
38141: PUSH
38142: LD_INT 4
38144: NEG
38145: PUSH
38146: LD_INT 0
38148: PUSH
38149: EMPTY
38150: LIST
38151: LIST
38152: PUSH
38153: LD_INT 4
38155: NEG
38156: PUSH
38157: LD_INT 1
38159: NEG
38160: PUSH
38161: EMPTY
38162: LIST
38163: LIST
38164: PUSH
38165: LD_INT 4
38167: NEG
38168: PUSH
38169: LD_INT 1
38171: PUSH
38172: EMPTY
38173: LIST
38174: LIST
38175: PUSH
38176: LD_INT 5
38178: NEG
38179: PUSH
38180: LD_INT 0
38182: PUSH
38183: EMPTY
38184: LIST
38185: LIST
38186: PUSH
38187: LD_INT 5
38189: NEG
38190: PUSH
38191: LD_INT 1
38193: NEG
38194: PUSH
38195: EMPTY
38196: LIST
38197: LIST
38198: PUSH
38199: LD_INT 5
38201: NEG
38202: PUSH
38203: LD_INT 1
38205: PUSH
38206: EMPTY
38207: LIST
38208: LIST
38209: PUSH
38210: LD_INT 6
38212: NEG
38213: PUSH
38214: LD_INT 0
38216: PUSH
38217: EMPTY
38218: LIST
38219: LIST
38220: PUSH
38221: LD_INT 6
38223: NEG
38224: PUSH
38225: LD_INT 1
38227: NEG
38228: PUSH
38229: EMPTY
38230: LIST
38231: LIST
38232: PUSH
38233: EMPTY
38234: LIST
38235: LIST
38236: LIST
38237: LIST
38238: LIST
38239: LIST
38240: LIST
38241: LIST
38242: LIST
38243: LIST
38244: LIST
38245: LIST
38246: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
38247: LD_ADDR_VAR 0 34
38251: PUSH
38252: LD_INT 2
38254: NEG
38255: PUSH
38256: LD_INT 3
38258: NEG
38259: PUSH
38260: EMPTY
38261: LIST
38262: LIST
38263: PUSH
38264: LD_INT 3
38266: NEG
38267: PUSH
38268: LD_INT 2
38270: NEG
38271: PUSH
38272: EMPTY
38273: LIST
38274: LIST
38275: PUSH
38276: LD_INT 3
38278: NEG
38279: PUSH
38280: LD_INT 3
38282: NEG
38283: PUSH
38284: EMPTY
38285: LIST
38286: LIST
38287: PUSH
38288: LD_INT 3
38290: NEG
38291: PUSH
38292: LD_INT 4
38294: NEG
38295: PUSH
38296: EMPTY
38297: LIST
38298: LIST
38299: PUSH
38300: LD_INT 4
38302: NEG
38303: PUSH
38304: LD_INT 3
38306: NEG
38307: PUSH
38308: EMPTY
38309: LIST
38310: LIST
38311: PUSH
38312: LD_INT 4
38314: NEG
38315: PUSH
38316: LD_INT 4
38318: NEG
38319: PUSH
38320: EMPTY
38321: LIST
38322: LIST
38323: PUSH
38324: LD_INT 4
38326: NEG
38327: PUSH
38328: LD_INT 5
38330: NEG
38331: PUSH
38332: EMPTY
38333: LIST
38334: LIST
38335: PUSH
38336: LD_INT 5
38338: NEG
38339: PUSH
38340: LD_INT 4
38342: NEG
38343: PUSH
38344: EMPTY
38345: LIST
38346: LIST
38347: PUSH
38348: LD_INT 5
38350: NEG
38351: PUSH
38352: LD_INT 5
38354: NEG
38355: PUSH
38356: EMPTY
38357: LIST
38358: LIST
38359: PUSH
38360: LD_INT 5
38362: NEG
38363: PUSH
38364: LD_INT 6
38366: NEG
38367: PUSH
38368: EMPTY
38369: LIST
38370: LIST
38371: PUSH
38372: LD_INT 6
38374: NEG
38375: PUSH
38376: LD_INT 5
38378: NEG
38379: PUSH
38380: EMPTY
38381: LIST
38382: LIST
38383: PUSH
38384: LD_INT 6
38386: NEG
38387: PUSH
38388: LD_INT 6
38390: NEG
38391: PUSH
38392: EMPTY
38393: LIST
38394: LIST
38395: PUSH
38396: EMPTY
38397: LIST
38398: LIST
38399: LIST
38400: LIST
38401: LIST
38402: LIST
38403: LIST
38404: LIST
38405: LIST
38406: LIST
38407: LIST
38408: LIST
38409: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
38410: LD_ADDR_VAR 0 41
38414: PUSH
38415: LD_INT 0
38417: PUSH
38418: LD_INT 2
38420: NEG
38421: PUSH
38422: EMPTY
38423: LIST
38424: LIST
38425: PUSH
38426: LD_INT 1
38428: NEG
38429: PUSH
38430: LD_INT 3
38432: NEG
38433: PUSH
38434: EMPTY
38435: LIST
38436: LIST
38437: PUSH
38438: LD_INT 1
38440: PUSH
38441: LD_INT 2
38443: NEG
38444: PUSH
38445: EMPTY
38446: LIST
38447: LIST
38448: PUSH
38449: EMPTY
38450: LIST
38451: LIST
38452: LIST
38453: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
38454: LD_ADDR_VAR 0 42
38458: PUSH
38459: LD_INT 2
38461: PUSH
38462: LD_INT 0
38464: PUSH
38465: EMPTY
38466: LIST
38467: LIST
38468: PUSH
38469: LD_INT 2
38471: PUSH
38472: LD_INT 1
38474: NEG
38475: PUSH
38476: EMPTY
38477: LIST
38478: LIST
38479: PUSH
38480: LD_INT 3
38482: PUSH
38483: LD_INT 1
38485: PUSH
38486: EMPTY
38487: LIST
38488: LIST
38489: PUSH
38490: EMPTY
38491: LIST
38492: LIST
38493: LIST
38494: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
38495: LD_ADDR_VAR 0 43
38499: PUSH
38500: LD_INT 2
38502: PUSH
38503: LD_INT 2
38505: PUSH
38506: EMPTY
38507: LIST
38508: LIST
38509: PUSH
38510: LD_INT 3
38512: PUSH
38513: LD_INT 2
38515: PUSH
38516: EMPTY
38517: LIST
38518: LIST
38519: PUSH
38520: LD_INT 2
38522: PUSH
38523: LD_INT 3
38525: PUSH
38526: EMPTY
38527: LIST
38528: LIST
38529: PUSH
38530: EMPTY
38531: LIST
38532: LIST
38533: LIST
38534: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
38535: LD_ADDR_VAR 0 44
38539: PUSH
38540: LD_INT 0
38542: PUSH
38543: LD_INT 2
38545: PUSH
38546: EMPTY
38547: LIST
38548: LIST
38549: PUSH
38550: LD_INT 1
38552: PUSH
38553: LD_INT 3
38555: PUSH
38556: EMPTY
38557: LIST
38558: LIST
38559: PUSH
38560: LD_INT 1
38562: NEG
38563: PUSH
38564: LD_INT 2
38566: PUSH
38567: EMPTY
38568: LIST
38569: LIST
38570: PUSH
38571: EMPTY
38572: LIST
38573: LIST
38574: LIST
38575: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38576: LD_ADDR_VAR 0 45
38580: PUSH
38581: LD_INT 2
38583: NEG
38584: PUSH
38585: LD_INT 0
38587: PUSH
38588: EMPTY
38589: LIST
38590: LIST
38591: PUSH
38592: LD_INT 2
38594: NEG
38595: PUSH
38596: LD_INT 1
38598: PUSH
38599: EMPTY
38600: LIST
38601: LIST
38602: PUSH
38603: LD_INT 3
38605: NEG
38606: PUSH
38607: LD_INT 1
38609: NEG
38610: PUSH
38611: EMPTY
38612: LIST
38613: LIST
38614: PUSH
38615: EMPTY
38616: LIST
38617: LIST
38618: LIST
38619: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
38620: LD_ADDR_VAR 0 46
38624: PUSH
38625: LD_INT 2
38627: NEG
38628: PUSH
38629: LD_INT 2
38631: NEG
38632: PUSH
38633: EMPTY
38634: LIST
38635: LIST
38636: PUSH
38637: LD_INT 2
38639: NEG
38640: PUSH
38641: LD_INT 3
38643: NEG
38644: PUSH
38645: EMPTY
38646: LIST
38647: LIST
38648: PUSH
38649: LD_INT 3
38651: NEG
38652: PUSH
38653: LD_INT 2
38655: NEG
38656: PUSH
38657: EMPTY
38658: LIST
38659: LIST
38660: PUSH
38661: EMPTY
38662: LIST
38663: LIST
38664: LIST
38665: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
38666: LD_ADDR_VAR 0 47
38670: PUSH
38671: LD_INT 2
38673: NEG
38674: PUSH
38675: LD_INT 3
38677: NEG
38678: PUSH
38679: EMPTY
38680: LIST
38681: LIST
38682: PUSH
38683: LD_INT 1
38685: NEG
38686: PUSH
38687: LD_INT 3
38689: NEG
38690: PUSH
38691: EMPTY
38692: LIST
38693: LIST
38694: PUSH
38695: EMPTY
38696: LIST
38697: LIST
38698: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
38699: LD_ADDR_VAR 0 48
38703: PUSH
38704: LD_INT 1
38706: PUSH
38707: LD_INT 2
38709: NEG
38710: PUSH
38711: EMPTY
38712: LIST
38713: LIST
38714: PUSH
38715: LD_INT 2
38717: PUSH
38718: LD_INT 1
38720: NEG
38721: PUSH
38722: EMPTY
38723: LIST
38724: LIST
38725: PUSH
38726: EMPTY
38727: LIST
38728: LIST
38729: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
38730: LD_ADDR_VAR 0 49
38734: PUSH
38735: LD_INT 3
38737: PUSH
38738: LD_INT 1
38740: PUSH
38741: EMPTY
38742: LIST
38743: LIST
38744: PUSH
38745: LD_INT 3
38747: PUSH
38748: LD_INT 2
38750: PUSH
38751: EMPTY
38752: LIST
38753: LIST
38754: PUSH
38755: EMPTY
38756: LIST
38757: LIST
38758: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
38759: LD_ADDR_VAR 0 50
38763: PUSH
38764: LD_INT 2
38766: PUSH
38767: LD_INT 3
38769: PUSH
38770: EMPTY
38771: LIST
38772: LIST
38773: PUSH
38774: LD_INT 1
38776: PUSH
38777: LD_INT 3
38779: PUSH
38780: EMPTY
38781: LIST
38782: LIST
38783: PUSH
38784: EMPTY
38785: LIST
38786: LIST
38787: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
38788: LD_ADDR_VAR 0 51
38792: PUSH
38793: LD_INT 1
38795: NEG
38796: PUSH
38797: LD_INT 2
38799: PUSH
38800: EMPTY
38801: LIST
38802: LIST
38803: PUSH
38804: LD_INT 2
38806: NEG
38807: PUSH
38808: LD_INT 1
38810: PUSH
38811: EMPTY
38812: LIST
38813: LIST
38814: PUSH
38815: EMPTY
38816: LIST
38817: LIST
38818: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
38819: LD_ADDR_VAR 0 52
38823: PUSH
38824: LD_INT 3
38826: NEG
38827: PUSH
38828: LD_INT 1
38830: NEG
38831: PUSH
38832: EMPTY
38833: LIST
38834: LIST
38835: PUSH
38836: LD_INT 3
38838: NEG
38839: PUSH
38840: LD_INT 2
38842: NEG
38843: PUSH
38844: EMPTY
38845: LIST
38846: LIST
38847: PUSH
38848: EMPTY
38849: LIST
38850: LIST
38851: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
38852: LD_ADDR_VAR 0 53
38856: PUSH
38857: LD_INT 1
38859: NEG
38860: PUSH
38861: LD_INT 3
38863: NEG
38864: PUSH
38865: EMPTY
38866: LIST
38867: LIST
38868: PUSH
38869: LD_INT 0
38871: PUSH
38872: LD_INT 3
38874: NEG
38875: PUSH
38876: EMPTY
38877: LIST
38878: LIST
38879: PUSH
38880: LD_INT 1
38882: PUSH
38883: LD_INT 2
38885: NEG
38886: PUSH
38887: EMPTY
38888: LIST
38889: LIST
38890: PUSH
38891: EMPTY
38892: LIST
38893: LIST
38894: LIST
38895: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
38896: LD_ADDR_VAR 0 54
38900: PUSH
38901: LD_INT 2
38903: PUSH
38904: LD_INT 1
38906: NEG
38907: PUSH
38908: EMPTY
38909: LIST
38910: LIST
38911: PUSH
38912: LD_INT 3
38914: PUSH
38915: LD_INT 0
38917: PUSH
38918: EMPTY
38919: LIST
38920: LIST
38921: PUSH
38922: LD_INT 3
38924: PUSH
38925: LD_INT 1
38927: PUSH
38928: EMPTY
38929: LIST
38930: LIST
38931: PUSH
38932: EMPTY
38933: LIST
38934: LIST
38935: LIST
38936: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
38937: LD_ADDR_VAR 0 55
38941: PUSH
38942: LD_INT 3
38944: PUSH
38945: LD_INT 2
38947: PUSH
38948: EMPTY
38949: LIST
38950: LIST
38951: PUSH
38952: LD_INT 3
38954: PUSH
38955: LD_INT 3
38957: PUSH
38958: EMPTY
38959: LIST
38960: LIST
38961: PUSH
38962: LD_INT 2
38964: PUSH
38965: LD_INT 3
38967: PUSH
38968: EMPTY
38969: LIST
38970: LIST
38971: PUSH
38972: EMPTY
38973: LIST
38974: LIST
38975: LIST
38976: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
38977: LD_ADDR_VAR 0 56
38981: PUSH
38982: LD_INT 1
38984: PUSH
38985: LD_INT 3
38987: PUSH
38988: EMPTY
38989: LIST
38990: LIST
38991: PUSH
38992: LD_INT 0
38994: PUSH
38995: LD_INT 3
38997: PUSH
38998: EMPTY
38999: LIST
39000: LIST
39001: PUSH
39002: LD_INT 1
39004: NEG
39005: PUSH
39006: LD_INT 2
39008: PUSH
39009: EMPTY
39010: LIST
39011: LIST
39012: PUSH
39013: EMPTY
39014: LIST
39015: LIST
39016: LIST
39017: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39018: LD_ADDR_VAR 0 57
39022: PUSH
39023: LD_INT 2
39025: NEG
39026: PUSH
39027: LD_INT 1
39029: PUSH
39030: EMPTY
39031: LIST
39032: LIST
39033: PUSH
39034: LD_INT 3
39036: NEG
39037: PUSH
39038: LD_INT 0
39040: PUSH
39041: EMPTY
39042: LIST
39043: LIST
39044: PUSH
39045: LD_INT 3
39047: NEG
39048: PUSH
39049: LD_INT 1
39051: NEG
39052: PUSH
39053: EMPTY
39054: LIST
39055: LIST
39056: PUSH
39057: EMPTY
39058: LIST
39059: LIST
39060: LIST
39061: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39062: LD_ADDR_VAR 0 58
39066: PUSH
39067: LD_INT 2
39069: NEG
39070: PUSH
39071: LD_INT 3
39073: NEG
39074: PUSH
39075: EMPTY
39076: LIST
39077: LIST
39078: PUSH
39079: LD_INT 3
39081: NEG
39082: PUSH
39083: LD_INT 2
39085: NEG
39086: PUSH
39087: EMPTY
39088: LIST
39089: LIST
39090: PUSH
39091: LD_INT 3
39093: NEG
39094: PUSH
39095: LD_INT 3
39097: NEG
39098: PUSH
39099: EMPTY
39100: LIST
39101: LIST
39102: PUSH
39103: EMPTY
39104: LIST
39105: LIST
39106: LIST
39107: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
39108: LD_ADDR_VAR 0 59
39112: PUSH
39113: LD_INT 1
39115: NEG
39116: PUSH
39117: LD_INT 2
39119: NEG
39120: PUSH
39121: EMPTY
39122: LIST
39123: LIST
39124: PUSH
39125: LD_INT 0
39127: PUSH
39128: LD_INT 2
39130: NEG
39131: PUSH
39132: EMPTY
39133: LIST
39134: LIST
39135: PUSH
39136: LD_INT 1
39138: PUSH
39139: LD_INT 1
39141: NEG
39142: PUSH
39143: EMPTY
39144: LIST
39145: LIST
39146: PUSH
39147: EMPTY
39148: LIST
39149: LIST
39150: LIST
39151: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
39152: LD_ADDR_VAR 0 60
39156: PUSH
39157: LD_INT 1
39159: PUSH
39160: LD_INT 1
39162: NEG
39163: PUSH
39164: EMPTY
39165: LIST
39166: LIST
39167: PUSH
39168: LD_INT 2
39170: PUSH
39171: LD_INT 0
39173: PUSH
39174: EMPTY
39175: LIST
39176: LIST
39177: PUSH
39178: LD_INT 2
39180: PUSH
39181: LD_INT 1
39183: PUSH
39184: EMPTY
39185: LIST
39186: LIST
39187: PUSH
39188: EMPTY
39189: LIST
39190: LIST
39191: LIST
39192: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
39193: LD_ADDR_VAR 0 61
39197: PUSH
39198: LD_INT 2
39200: PUSH
39201: LD_INT 1
39203: PUSH
39204: EMPTY
39205: LIST
39206: LIST
39207: PUSH
39208: LD_INT 2
39210: PUSH
39211: LD_INT 2
39213: PUSH
39214: EMPTY
39215: LIST
39216: LIST
39217: PUSH
39218: LD_INT 1
39220: PUSH
39221: LD_INT 2
39223: PUSH
39224: EMPTY
39225: LIST
39226: LIST
39227: PUSH
39228: EMPTY
39229: LIST
39230: LIST
39231: LIST
39232: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
39233: LD_ADDR_VAR 0 62
39237: PUSH
39238: LD_INT 1
39240: PUSH
39241: LD_INT 2
39243: PUSH
39244: EMPTY
39245: LIST
39246: LIST
39247: PUSH
39248: LD_INT 0
39250: PUSH
39251: LD_INT 2
39253: PUSH
39254: EMPTY
39255: LIST
39256: LIST
39257: PUSH
39258: LD_INT 1
39260: NEG
39261: PUSH
39262: LD_INT 1
39264: PUSH
39265: EMPTY
39266: LIST
39267: LIST
39268: PUSH
39269: EMPTY
39270: LIST
39271: LIST
39272: LIST
39273: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
39274: LD_ADDR_VAR 0 63
39278: PUSH
39279: LD_INT 1
39281: NEG
39282: PUSH
39283: LD_INT 1
39285: PUSH
39286: EMPTY
39287: LIST
39288: LIST
39289: PUSH
39290: LD_INT 2
39292: NEG
39293: PUSH
39294: LD_INT 0
39296: PUSH
39297: EMPTY
39298: LIST
39299: LIST
39300: PUSH
39301: LD_INT 2
39303: NEG
39304: PUSH
39305: LD_INT 1
39307: NEG
39308: PUSH
39309: EMPTY
39310: LIST
39311: LIST
39312: PUSH
39313: EMPTY
39314: LIST
39315: LIST
39316: LIST
39317: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39318: LD_ADDR_VAR 0 64
39322: PUSH
39323: LD_INT 1
39325: NEG
39326: PUSH
39327: LD_INT 2
39329: NEG
39330: PUSH
39331: EMPTY
39332: LIST
39333: LIST
39334: PUSH
39335: LD_INT 2
39337: NEG
39338: PUSH
39339: LD_INT 1
39341: NEG
39342: PUSH
39343: EMPTY
39344: LIST
39345: LIST
39346: PUSH
39347: LD_INT 2
39349: NEG
39350: PUSH
39351: LD_INT 2
39353: NEG
39354: PUSH
39355: EMPTY
39356: LIST
39357: LIST
39358: PUSH
39359: EMPTY
39360: LIST
39361: LIST
39362: LIST
39363: ST_TO_ADDR
// end ; 2 :
39364: GO 42630
39366: LD_INT 2
39368: DOUBLE
39369: EQUAL
39370: IFTRUE 39374
39372: GO 42629
39374: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
39375: LD_ADDR_VAR 0 29
39379: PUSH
39380: LD_INT 4
39382: PUSH
39383: LD_INT 0
39385: PUSH
39386: EMPTY
39387: LIST
39388: LIST
39389: PUSH
39390: LD_INT 4
39392: PUSH
39393: LD_INT 1
39395: NEG
39396: PUSH
39397: EMPTY
39398: LIST
39399: LIST
39400: PUSH
39401: LD_INT 5
39403: PUSH
39404: LD_INT 0
39406: PUSH
39407: EMPTY
39408: LIST
39409: LIST
39410: PUSH
39411: LD_INT 5
39413: PUSH
39414: LD_INT 1
39416: PUSH
39417: EMPTY
39418: LIST
39419: LIST
39420: PUSH
39421: LD_INT 4
39423: PUSH
39424: LD_INT 1
39426: PUSH
39427: EMPTY
39428: LIST
39429: LIST
39430: PUSH
39431: LD_INT 3
39433: PUSH
39434: LD_INT 0
39436: PUSH
39437: EMPTY
39438: LIST
39439: LIST
39440: PUSH
39441: LD_INT 3
39443: PUSH
39444: LD_INT 1
39446: NEG
39447: PUSH
39448: EMPTY
39449: LIST
39450: LIST
39451: PUSH
39452: LD_INT 3
39454: PUSH
39455: LD_INT 2
39457: NEG
39458: PUSH
39459: EMPTY
39460: LIST
39461: LIST
39462: PUSH
39463: LD_INT 5
39465: PUSH
39466: LD_INT 2
39468: PUSH
39469: EMPTY
39470: LIST
39471: LIST
39472: PUSH
39473: LD_INT 3
39475: PUSH
39476: LD_INT 3
39478: PUSH
39479: EMPTY
39480: LIST
39481: LIST
39482: PUSH
39483: LD_INT 3
39485: PUSH
39486: LD_INT 2
39488: PUSH
39489: EMPTY
39490: LIST
39491: LIST
39492: PUSH
39493: LD_INT 4
39495: PUSH
39496: LD_INT 3
39498: PUSH
39499: EMPTY
39500: LIST
39501: LIST
39502: PUSH
39503: LD_INT 4
39505: PUSH
39506: LD_INT 4
39508: PUSH
39509: EMPTY
39510: LIST
39511: LIST
39512: PUSH
39513: LD_INT 3
39515: PUSH
39516: LD_INT 4
39518: PUSH
39519: EMPTY
39520: LIST
39521: LIST
39522: PUSH
39523: LD_INT 2
39525: PUSH
39526: LD_INT 3
39528: PUSH
39529: EMPTY
39530: LIST
39531: LIST
39532: PUSH
39533: LD_INT 2
39535: PUSH
39536: LD_INT 2
39538: PUSH
39539: EMPTY
39540: LIST
39541: LIST
39542: PUSH
39543: LD_INT 4
39545: PUSH
39546: LD_INT 2
39548: PUSH
39549: EMPTY
39550: LIST
39551: LIST
39552: PUSH
39553: LD_INT 2
39555: PUSH
39556: LD_INT 4
39558: PUSH
39559: EMPTY
39560: LIST
39561: LIST
39562: PUSH
39563: LD_INT 0
39565: PUSH
39566: LD_INT 4
39568: PUSH
39569: EMPTY
39570: LIST
39571: LIST
39572: PUSH
39573: LD_INT 0
39575: PUSH
39576: LD_INT 3
39578: PUSH
39579: EMPTY
39580: LIST
39581: LIST
39582: PUSH
39583: LD_INT 1
39585: PUSH
39586: LD_INT 4
39588: PUSH
39589: EMPTY
39590: LIST
39591: LIST
39592: PUSH
39593: LD_INT 1
39595: PUSH
39596: LD_INT 5
39598: PUSH
39599: EMPTY
39600: LIST
39601: LIST
39602: PUSH
39603: LD_INT 0
39605: PUSH
39606: LD_INT 5
39608: PUSH
39609: EMPTY
39610: LIST
39611: LIST
39612: PUSH
39613: LD_INT 1
39615: NEG
39616: PUSH
39617: LD_INT 4
39619: PUSH
39620: EMPTY
39621: LIST
39622: LIST
39623: PUSH
39624: LD_INT 1
39626: NEG
39627: PUSH
39628: LD_INT 3
39630: PUSH
39631: EMPTY
39632: LIST
39633: LIST
39634: PUSH
39635: LD_INT 2
39637: PUSH
39638: LD_INT 5
39640: PUSH
39641: EMPTY
39642: LIST
39643: LIST
39644: PUSH
39645: LD_INT 2
39647: NEG
39648: PUSH
39649: LD_INT 3
39651: PUSH
39652: EMPTY
39653: LIST
39654: LIST
39655: PUSH
39656: LD_INT 3
39658: NEG
39659: PUSH
39660: LD_INT 0
39662: PUSH
39663: EMPTY
39664: LIST
39665: LIST
39666: PUSH
39667: LD_INT 3
39669: NEG
39670: PUSH
39671: LD_INT 1
39673: NEG
39674: PUSH
39675: EMPTY
39676: LIST
39677: LIST
39678: PUSH
39679: LD_INT 2
39681: NEG
39682: PUSH
39683: LD_INT 0
39685: PUSH
39686: EMPTY
39687: LIST
39688: LIST
39689: PUSH
39690: LD_INT 2
39692: NEG
39693: PUSH
39694: LD_INT 1
39696: PUSH
39697: EMPTY
39698: LIST
39699: LIST
39700: PUSH
39701: LD_INT 3
39703: NEG
39704: PUSH
39705: LD_INT 1
39707: PUSH
39708: EMPTY
39709: LIST
39710: LIST
39711: PUSH
39712: LD_INT 4
39714: NEG
39715: PUSH
39716: LD_INT 0
39718: PUSH
39719: EMPTY
39720: LIST
39721: LIST
39722: PUSH
39723: LD_INT 4
39725: NEG
39726: PUSH
39727: LD_INT 1
39729: NEG
39730: PUSH
39731: EMPTY
39732: LIST
39733: LIST
39734: PUSH
39735: LD_INT 4
39737: NEG
39738: PUSH
39739: LD_INT 2
39741: NEG
39742: PUSH
39743: EMPTY
39744: LIST
39745: LIST
39746: PUSH
39747: LD_INT 2
39749: NEG
39750: PUSH
39751: LD_INT 2
39753: PUSH
39754: EMPTY
39755: LIST
39756: LIST
39757: PUSH
39758: LD_INT 4
39760: NEG
39761: PUSH
39762: LD_INT 4
39764: NEG
39765: PUSH
39766: EMPTY
39767: LIST
39768: LIST
39769: PUSH
39770: LD_INT 4
39772: NEG
39773: PUSH
39774: LD_INT 5
39776: NEG
39777: PUSH
39778: EMPTY
39779: LIST
39780: LIST
39781: PUSH
39782: LD_INT 3
39784: NEG
39785: PUSH
39786: LD_INT 4
39788: NEG
39789: PUSH
39790: EMPTY
39791: LIST
39792: LIST
39793: PUSH
39794: LD_INT 3
39796: NEG
39797: PUSH
39798: LD_INT 3
39800: NEG
39801: PUSH
39802: EMPTY
39803: LIST
39804: LIST
39805: PUSH
39806: LD_INT 4
39808: NEG
39809: PUSH
39810: LD_INT 3
39812: NEG
39813: PUSH
39814: EMPTY
39815: LIST
39816: LIST
39817: PUSH
39818: LD_INT 5
39820: NEG
39821: PUSH
39822: LD_INT 4
39824: NEG
39825: PUSH
39826: EMPTY
39827: LIST
39828: LIST
39829: PUSH
39830: LD_INT 5
39832: NEG
39833: PUSH
39834: LD_INT 5
39836: NEG
39837: PUSH
39838: EMPTY
39839: LIST
39840: LIST
39841: PUSH
39842: LD_INT 3
39844: NEG
39845: PUSH
39846: LD_INT 5
39848: NEG
39849: PUSH
39850: EMPTY
39851: LIST
39852: LIST
39853: PUSH
39854: LD_INT 5
39856: NEG
39857: PUSH
39858: LD_INT 3
39860: NEG
39861: PUSH
39862: EMPTY
39863: LIST
39864: LIST
39865: PUSH
39866: EMPTY
39867: LIST
39868: LIST
39869: LIST
39870: LIST
39871: LIST
39872: LIST
39873: LIST
39874: LIST
39875: LIST
39876: LIST
39877: LIST
39878: LIST
39879: LIST
39880: LIST
39881: LIST
39882: LIST
39883: LIST
39884: LIST
39885: LIST
39886: LIST
39887: LIST
39888: LIST
39889: LIST
39890: LIST
39891: LIST
39892: LIST
39893: LIST
39894: LIST
39895: LIST
39896: LIST
39897: LIST
39898: LIST
39899: LIST
39900: LIST
39901: LIST
39902: LIST
39903: LIST
39904: LIST
39905: LIST
39906: LIST
39907: LIST
39908: LIST
39909: LIST
39910: LIST
39911: LIST
39912: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
39913: LD_ADDR_VAR 0 30
39917: PUSH
39918: LD_INT 4
39920: PUSH
39921: LD_INT 4
39923: PUSH
39924: EMPTY
39925: LIST
39926: LIST
39927: PUSH
39928: LD_INT 4
39930: PUSH
39931: LD_INT 3
39933: PUSH
39934: EMPTY
39935: LIST
39936: LIST
39937: PUSH
39938: LD_INT 5
39940: PUSH
39941: LD_INT 4
39943: PUSH
39944: EMPTY
39945: LIST
39946: LIST
39947: PUSH
39948: LD_INT 5
39950: PUSH
39951: LD_INT 5
39953: PUSH
39954: EMPTY
39955: LIST
39956: LIST
39957: PUSH
39958: LD_INT 4
39960: PUSH
39961: LD_INT 5
39963: PUSH
39964: EMPTY
39965: LIST
39966: LIST
39967: PUSH
39968: LD_INT 3
39970: PUSH
39971: LD_INT 4
39973: PUSH
39974: EMPTY
39975: LIST
39976: LIST
39977: PUSH
39978: LD_INT 3
39980: PUSH
39981: LD_INT 3
39983: PUSH
39984: EMPTY
39985: LIST
39986: LIST
39987: PUSH
39988: LD_INT 5
39990: PUSH
39991: LD_INT 3
39993: PUSH
39994: EMPTY
39995: LIST
39996: LIST
39997: PUSH
39998: LD_INT 3
40000: PUSH
40001: LD_INT 5
40003: PUSH
40004: EMPTY
40005: LIST
40006: LIST
40007: PUSH
40008: LD_INT 0
40010: PUSH
40011: LD_INT 3
40013: PUSH
40014: EMPTY
40015: LIST
40016: LIST
40017: PUSH
40018: LD_INT 0
40020: PUSH
40021: LD_INT 2
40023: PUSH
40024: EMPTY
40025: LIST
40026: LIST
40027: PUSH
40028: LD_INT 1
40030: PUSH
40031: LD_INT 3
40033: PUSH
40034: EMPTY
40035: LIST
40036: LIST
40037: PUSH
40038: LD_INT 1
40040: PUSH
40041: LD_INT 4
40043: PUSH
40044: EMPTY
40045: LIST
40046: LIST
40047: PUSH
40048: LD_INT 0
40050: PUSH
40051: LD_INT 4
40053: PUSH
40054: EMPTY
40055: LIST
40056: LIST
40057: PUSH
40058: LD_INT 1
40060: NEG
40061: PUSH
40062: LD_INT 3
40064: PUSH
40065: EMPTY
40066: LIST
40067: LIST
40068: PUSH
40069: LD_INT 1
40071: NEG
40072: PUSH
40073: LD_INT 2
40075: PUSH
40076: EMPTY
40077: LIST
40078: LIST
40079: PUSH
40080: LD_INT 2
40082: PUSH
40083: LD_INT 4
40085: PUSH
40086: EMPTY
40087: LIST
40088: LIST
40089: PUSH
40090: LD_INT 2
40092: NEG
40093: PUSH
40094: LD_INT 2
40096: PUSH
40097: EMPTY
40098: LIST
40099: LIST
40100: PUSH
40101: LD_INT 4
40103: NEG
40104: PUSH
40105: LD_INT 0
40107: PUSH
40108: EMPTY
40109: LIST
40110: LIST
40111: PUSH
40112: LD_INT 4
40114: NEG
40115: PUSH
40116: LD_INT 1
40118: NEG
40119: PUSH
40120: EMPTY
40121: LIST
40122: LIST
40123: PUSH
40124: LD_INT 3
40126: NEG
40127: PUSH
40128: LD_INT 0
40130: PUSH
40131: EMPTY
40132: LIST
40133: LIST
40134: PUSH
40135: LD_INT 3
40137: NEG
40138: PUSH
40139: LD_INT 1
40141: PUSH
40142: EMPTY
40143: LIST
40144: LIST
40145: PUSH
40146: LD_INT 4
40148: NEG
40149: PUSH
40150: LD_INT 1
40152: PUSH
40153: EMPTY
40154: LIST
40155: LIST
40156: PUSH
40157: LD_INT 5
40159: NEG
40160: PUSH
40161: LD_INT 0
40163: PUSH
40164: EMPTY
40165: LIST
40166: LIST
40167: PUSH
40168: LD_INT 5
40170: NEG
40171: PUSH
40172: LD_INT 1
40174: NEG
40175: PUSH
40176: EMPTY
40177: LIST
40178: LIST
40179: PUSH
40180: LD_INT 5
40182: NEG
40183: PUSH
40184: LD_INT 2
40186: NEG
40187: PUSH
40188: EMPTY
40189: LIST
40190: LIST
40191: PUSH
40192: LD_INT 3
40194: NEG
40195: PUSH
40196: LD_INT 2
40198: PUSH
40199: EMPTY
40200: LIST
40201: LIST
40202: PUSH
40203: LD_INT 3
40205: NEG
40206: PUSH
40207: LD_INT 3
40209: NEG
40210: PUSH
40211: EMPTY
40212: LIST
40213: LIST
40214: PUSH
40215: LD_INT 3
40217: NEG
40218: PUSH
40219: LD_INT 4
40221: NEG
40222: PUSH
40223: EMPTY
40224: LIST
40225: LIST
40226: PUSH
40227: LD_INT 2
40229: NEG
40230: PUSH
40231: LD_INT 3
40233: NEG
40234: PUSH
40235: EMPTY
40236: LIST
40237: LIST
40238: PUSH
40239: LD_INT 2
40241: NEG
40242: PUSH
40243: LD_INT 2
40245: NEG
40246: PUSH
40247: EMPTY
40248: LIST
40249: LIST
40250: PUSH
40251: LD_INT 3
40253: NEG
40254: PUSH
40255: LD_INT 2
40257: NEG
40258: PUSH
40259: EMPTY
40260: LIST
40261: LIST
40262: PUSH
40263: LD_INT 4
40265: NEG
40266: PUSH
40267: LD_INT 3
40269: NEG
40270: PUSH
40271: EMPTY
40272: LIST
40273: LIST
40274: PUSH
40275: LD_INT 4
40277: NEG
40278: PUSH
40279: LD_INT 4
40281: NEG
40282: PUSH
40283: EMPTY
40284: LIST
40285: LIST
40286: PUSH
40287: LD_INT 2
40289: NEG
40290: PUSH
40291: LD_INT 4
40293: NEG
40294: PUSH
40295: EMPTY
40296: LIST
40297: LIST
40298: PUSH
40299: LD_INT 4
40301: NEG
40302: PUSH
40303: LD_INT 2
40305: NEG
40306: PUSH
40307: EMPTY
40308: LIST
40309: LIST
40310: PUSH
40311: LD_INT 0
40313: PUSH
40314: LD_INT 4
40316: NEG
40317: PUSH
40318: EMPTY
40319: LIST
40320: LIST
40321: PUSH
40322: LD_INT 0
40324: PUSH
40325: LD_INT 5
40327: NEG
40328: PUSH
40329: EMPTY
40330: LIST
40331: LIST
40332: PUSH
40333: LD_INT 1
40335: PUSH
40336: LD_INT 4
40338: NEG
40339: PUSH
40340: EMPTY
40341: LIST
40342: LIST
40343: PUSH
40344: LD_INT 1
40346: PUSH
40347: LD_INT 3
40349: NEG
40350: PUSH
40351: EMPTY
40352: LIST
40353: LIST
40354: PUSH
40355: LD_INT 0
40357: PUSH
40358: LD_INT 3
40360: NEG
40361: PUSH
40362: EMPTY
40363: LIST
40364: LIST
40365: PUSH
40366: LD_INT 1
40368: NEG
40369: PUSH
40370: LD_INT 4
40372: NEG
40373: PUSH
40374: EMPTY
40375: LIST
40376: LIST
40377: PUSH
40378: LD_INT 1
40380: NEG
40381: PUSH
40382: LD_INT 5
40384: NEG
40385: PUSH
40386: EMPTY
40387: LIST
40388: LIST
40389: PUSH
40390: LD_INT 2
40392: PUSH
40393: LD_INT 3
40395: NEG
40396: PUSH
40397: EMPTY
40398: LIST
40399: LIST
40400: PUSH
40401: LD_INT 2
40403: NEG
40404: PUSH
40405: LD_INT 5
40407: NEG
40408: PUSH
40409: EMPTY
40410: LIST
40411: LIST
40412: PUSH
40413: EMPTY
40414: LIST
40415: LIST
40416: LIST
40417: LIST
40418: LIST
40419: LIST
40420: LIST
40421: LIST
40422: LIST
40423: LIST
40424: LIST
40425: LIST
40426: LIST
40427: LIST
40428: LIST
40429: LIST
40430: LIST
40431: LIST
40432: LIST
40433: LIST
40434: LIST
40435: LIST
40436: LIST
40437: LIST
40438: LIST
40439: LIST
40440: LIST
40441: LIST
40442: LIST
40443: LIST
40444: LIST
40445: LIST
40446: LIST
40447: LIST
40448: LIST
40449: LIST
40450: LIST
40451: LIST
40452: LIST
40453: LIST
40454: LIST
40455: LIST
40456: LIST
40457: LIST
40458: LIST
40459: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
40460: LD_ADDR_VAR 0 31
40464: PUSH
40465: LD_INT 0
40467: PUSH
40468: LD_INT 4
40470: PUSH
40471: EMPTY
40472: LIST
40473: LIST
40474: PUSH
40475: LD_INT 0
40477: PUSH
40478: LD_INT 3
40480: PUSH
40481: EMPTY
40482: LIST
40483: LIST
40484: PUSH
40485: LD_INT 1
40487: PUSH
40488: LD_INT 4
40490: PUSH
40491: EMPTY
40492: LIST
40493: LIST
40494: PUSH
40495: LD_INT 1
40497: PUSH
40498: LD_INT 5
40500: PUSH
40501: EMPTY
40502: LIST
40503: LIST
40504: PUSH
40505: LD_INT 0
40507: PUSH
40508: LD_INT 5
40510: PUSH
40511: EMPTY
40512: LIST
40513: LIST
40514: PUSH
40515: LD_INT 1
40517: NEG
40518: PUSH
40519: LD_INT 4
40521: PUSH
40522: EMPTY
40523: LIST
40524: LIST
40525: PUSH
40526: LD_INT 1
40528: NEG
40529: PUSH
40530: LD_INT 3
40532: PUSH
40533: EMPTY
40534: LIST
40535: LIST
40536: PUSH
40537: LD_INT 2
40539: PUSH
40540: LD_INT 5
40542: PUSH
40543: EMPTY
40544: LIST
40545: LIST
40546: PUSH
40547: LD_INT 2
40549: NEG
40550: PUSH
40551: LD_INT 3
40553: PUSH
40554: EMPTY
40555: LIST
40556: LIST
40557: PUSH
40558: LD_INT 3
40560: NEG
40561: PUSH
40562: LD_INT 0
40564: PUSH
40565: EMPTY
40566: LIST
40567: LIST
40568: PUSH
40569: LD_INT 3
40571: NEG
40572: PUSH
40573: LD_INT 1
40575: NEG
40576: PUSH
40577: EMPTY
40578: LIST
40579: LIST
40580: PUSH
40581: LD_INT 2
40583: NEG
40584: PUSH
40585: LD_INT 0
40587: PUSH
40588: EMPTY
40589: LIST
40590: LIST
40591: PUSH
40592: LD_INT 2
40594: NEG
40595: PUSH
40596: LD_INT 1
40598: PUSH
40599: EMPTY
40600: LIST
40601: LIST
40602: PUSH
40603: LD_INT 3
40605: NEG
40606: PUSH
40607: LD_INT 1
40609: PUSH
40610: EMPTY
40611: LIST
40612: LIST
40613: PUSH
40614: LD_INT 4
40616: NEG
40617: PUSH
40618: LD_INT 0
40620: PUSH
40621: EMPTY
40622: LIST
40623: LIST
40624: PUSH
40625: LD_INT 4
40627: NEG
40628: PUSH
40629: LD_INT 1
40631: NEG
40632: PUSH
40633: EMPTY
40634: LIST
40635: LIST
40636: PUSH
40637: LD_INT 4
40639: NEG
40640: PUSH
40641: LD_INT 2
40643: NEG
40644: PUSH
40645: EMPTY
40646: LIST
40647: LIST
40648: PUSH
40649: LD_INT 2
40651: NEG
40652: PUSH
40653: LD_INT 2
40655: PUSH
40656: EMPTY
40657: LIST
40658: LIST
40659: PUSH
40660: LD_INT 4
40662: NEG
40663: PUSH
40664: LD_INT 4
40666: NEG
40667: PUSH
40668: EMPTY
40669: LIST
40670: LIST
40671: PUSH
40672: LD_INT 4
40674: NEG
40675: PUSH
40676: LD_INT 5
40678: NEG
40679: PUSH
40680: EMPTY
40681: LIST
40682: LIST
40683: PUSH
40684: LD_INT 3
40686: NEG
40687: PUSH
40688: LD_INT 4
40690: NEG
40691: PUSH
40692: EMPTY
40693: LIST
40694: LIST
40695: PUSH
40696: LD_INT 3
40698: NEG
40699: PUSH
40700: LD_INT 3
40702: NEG
40703: PUSH
40704: EMPTY
40705: LIST
40706: LIST
40707: PUSH
40708: LD_INT 4
40710: NEG
40711: PUSH
40712: LD_INT 3
40714: NEG
40715: PUSH
40716: EMPTY
40717: LIST
40718: LIST
40719: PUSH
40720: LD_INT 5
40722: NEG
40723: PUSH
40724: LD_INT 4
40726: NEG
40727: PUSH
40728: EMPTY
40729: LIST
40730: LIST
40731: PUSH
40732: LD_INT 5
40734: NEG
40735: PUSH
40736: LD_INT 5
40738: NEG
40739: PUSH
40740: EMPTY
40741: LIST
40742: LIST
40743: PUSH
40744: LD_INT 3
40746: NEG
40747: PUSH
40748: LD_INT 5
40750: NEG
40751: PUSH
40752: EMPTY
40753: LIST
40754: LIST
40755: PUSH
40756: LD_INT 5
40758: NEG
40759: PUSH
40760: LD_INT 3
40762: NEG
40763: PUSH
40764: EMPTY
40765: LIST
40766: LIST
40767: PUSH
40768: LD_INT 0
40770: PUSH
40771: LD_INT 3
40773: NEG
40774: PUSH
40775: EMPTY
40776: LIST
40777: LIST
40778: PUSH
40779: LD_INT 0
40781: PUSH
40782: LD_INT 4
40784: NEG
40785: PUSH
40786: EMPTY
40787: LIST
40788: LIST
40789: PUSH
40790: LD_INT 1
40792: PUSH
40793: LD_INT 3
40795: NEG
40796: PUSH
40797: EMPTY
40798: LIST
40799: LIST
40800: PUSH
40801: LD_INT 1
40803: PUSH
40804: LD_INT 2
40806: NEG
40807: PUSH
40808: EMPTY
40809: LIST
40810: LIST
40811: PUSH
40812: LD_INT 0
40814: PUSH
40815: LD_INT 2
40817: NEG
40818: PUSH
40819: EMPTY
40820: LIST
40821: LIST
40822: PUSH
40823: LD_INT 1
40825: NEG
40826: PUSH
40827: LD_INT 3
40829: NEG
40830: PUSH
40831: EMPTY
40832: LIST
40833: LIST
40834: PUSH
40835: LD_INT 1
40837: NEG
40838: PUSH
40839: LD_INT 4
40841: NEG
40842: PUSH
40843: EMPTY
40844: LIST
40845: LIST
40846: PUSH
40847: LD_INT 2
40849: PUSH
40850: LD_INT 2
40852: NEG
40853: PUSH
40854: EMPTY
40855: LIST
40856: LIST
40857: PUSH
40858: LD_INT 2
40860: NEG
40861: PUSH
40862: LD_INT 4
40864: NEG
40865: PUSH
40866: EMPTY
40867: LIST
40868: LIST
40869: PUSH
40870: LD_INT 4
40872: PUSH
40873: LD_INT 0
40875: PUSH
40876: EMPTY
40877: LIST
40878: LIST
40879: PUSH
40880: LD_INT 4
40882: PUSH
40883: LD_INT 1
40885: NEG
40886: PUSH
40887: EMPTY
40888: LIST
40889: LIST
40890: PUSH
40891: LD_INT 5
40893: PUSH
40894: LD_INT 0
40896: PUSH
40897: EMPTY
40898: LIST
40899: LIST
40900: PUSH
40901: LD_INT 5
40903: PUSH
40904: LD_INT 1
40906: PUSH
40907: EMPTY
40908: LIST
40909: LIST
40910: PUSH
40911: LD_INT 4
40913: PUSH
40914: LD_INT 1
40916: PUSH
40917: EMPTY
40918: LIST
40919: LIST
40920: PUSH
40921: LD_INT 3
40923: PUSH
40924: LD_INT 0
40926: PUSH
40927: EMPTY
40928: LIST
40929: LIST
40930: PUSH
40931: LD_INT 3
40933: PUSH
40934: LD_INT 1
40936: NEG
40937: PUSH
40938: EMPTY
40939: LIST
40940: LIST
40941: PUSH
40942: LD_INT 3
40944: PUSH
40945: LD_INT 2
40947: NEG
40948: PUSH
40949: EMPTY
40950: LIST
40951: LIST
40952: PUSH
40953: LD_INT 5
40955: PUSH
40956: LD_INT 2
40958: PUSH
40959: EMPTY
40960: LIST
40961: LIST
40962: PUSH
40963: EMPTY
40964: LIST
40965: LIST
40966: LIST
40967: LIST
40968: LIST
40969: LIST
40970: LIST
40971: LIST
40972: LIST
40973: LIST
40974: LIST
40975: LIST
40976: LIST
40977: LIST
40978: LIST
40979: LIST
40980: LIST
40981: LIST
40982: LIST
40983: LIST
40984: LIST
40985: LIST
40986: LIST
40987: LIST
40988: LIST
40989: LIST
40990: LIST
40991: LIST
40992: LIST
40993: LIST
40994: LIST
40995: LIST
40996: LIST
40997: LIST
40998: LIST
40999: LIST
41000: LIST
41001: LIST
41002: LIST
41003: LIST
41004: LIST
41005: LIST
41006: LIST
41007: LIST
41008: LIST
41009: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
41010: LD_ADDR_VAR 0 32
41014: PUSH
41015: LD_INT 4
41017: NEG
41018: PUSH
41019: LD_INT 0
41021: PUSH
41022: EMPTY
41023: LIST
41024: LIST
41025: PUSH
41026: LD_INT 4
41028: NEG
41029: PUSH
41030: LD_INT 1
41032: NEG
41033: PUSH
41034: EMPTY
41035: LIST
41036: LIST
41037: PUSH
41038: LD_INT 3
41040: NEG
41041: PUSH
41042: LD_INT 0
41044: PUSH
41045: EMPTY
41046: LIST
41047: LIST
41048: PUSH
41049: LD_INT 3
41051: NEG
41052: PUSH
41053: LD_INT 1
41055: PUSH
41056: EMPTY
41057: LIST
41058: LIST
41059: PUSH
41060: LD_INT 4
41062: NEG
41063: PUSH
41064: LD_INT 1
41066: PUSH
41067: EMPTY
41068: LIST
41069: LIST
41070: PUSH
41071: LD_INT 5
41073: NEG
41074: PUSH
41075: LD_INT 0
41077: PUSH
41078: EMPTY
41079: LIST
41080: LIST
41081: PUSH
41082: LD_INT 5
41084: NEG
41085: PUSH
41086: LD_INT 1
41088: NEG
41089: PUSH
41090: EMPTY
41091: LIST
41092: LIST
41093: PUSH
41094: LD_INT 5
41096: NEG
41097: PUSH
41098: LD_INT 2
41100: NEG
41101: PUSH
41102: EMPTY
41103: LIST
41104: LIST
41105: PUSH
41106: LD_INT 3
41108: NEG
41109: PUSH
41110: LD_INT 2
41112: PUSH
41113: EMPTY
41114: LIST
41115: LIST
41116: PUSH
41117: LD_INT 3
41119: NEG
41120: PUSH
41121: LD_INT 3
41123: NEG
41124: PUSH
41125: EMPTY
41126: LIST
41127: LIST
41128: PUSH
41129: LD_INT 3
41131: NEG
41132: PUSH
41133: LD_INT 4
41135: NEG
41136: PUSH
41137: EMPTY
41138: LIST
41139: LIST
41140: PUSH
41141: LD_INT 2
41143: NEG
41144: PUSH
41145: LD_INT 3
41147: NEG
41148: PUSH
41149: EMPTY
41150: LIST
41151: LIST
41152: PUSH
41153: LD_INT 2
41155: NEG
41156: PUSH
41157: LD_INT 2
41159: NEG
41160: PUSH
41161: EMPTY
41162: LIST
41163: LIST
41164: PUSH
41165: LD_INT 3
41167: NEG
41168: PUSH
41169: LD_INT 2
41171: NEG
41172: PUSH
41173: EMPTY
41174: LIST
41175: LIST
41176: PUSH
41177: LD_INT 4
41179: NEG
41180: PUSH
41181: LD_INT 3
41183: NEG
41184: PUSH
41185: EMPTY
41186: LIST
41187: LIST
41188: PUSH
41189: LD_INT 4
41191: NEG
41192: PUSH
41193: LD_INT 4
41195: NEG
41196: PUSH
41197: EMPTY
41198: LIST
41199: LIST
41200: PUSH
41201: LD_INT 2
41203: NEG
41204: PUSH
41205: LD_INT 4
41207: NEG
41208: PUSH
41209: EMPTY
41210: LIST
41211: LIST
41212: PUSH
41213: LD_INT 4
41215: NEG
41216: PUSH
41217: LD_INT 2
41219: NEG
41220: PUSH
41221: EMPTY
41222: LIST
41223: LIST
41224: PUSH
41225: LD_INT 0
41227: PUSH
41228: LD_INT 4
41230: NEG
41231: PUSH
41232: EMPTY
41233: LIST
41234: LIST
41235: PUSH
41236: LD_INT 0
41238: PUSH
41239: LD_INT 5
41241: NEG
41242: PUSH
41243: EMPTY
41244: LIST
41245: LIST
41246: PUSH
41247: LD_INT 1
41249: PUSH
41250: LD_INT 4
41252: NEG
41253: PUSH
41254: EMPTY
41255: LIST
41256: LIST
41257: PUSH
41258: LD_INT 1
41260: PUSH
41261: LD_INT 3
41263: NEG
41264: PUSH
41265: EMPTY
41266: LIST
41267: LIST
41268: PUSH
41269: LD_INT 0
41271: PUSH
41272: LD_INT 3
41274: NEG
41275: PUSH
41276: EMPTY
41277: LIST
41278: LIST
41279: PUSH
41280: LD_INT 1
41282: NEG
41283: PUSH
41284: LD_INT 4
41286: NEG
41287: PUSH
41288: EMPTY
41289: LIST
41290: LIST
41291: PUSH
41292: LD_INT 1
41294: NEG
41295: PUSH
41296: LD_INT 5
41298: NEG
41299: PUSH
41300: EMPTY
41301: LIST
41302: LIST
41303: PUSH
41304: LD_INT 2
41306: PUSH
41307: LD_INT 3
41309: NEG
41310: PUSH
41311: EMPTY
41312: LIST
41313: LIST
41314: PUSH
41315: LD_INT 2
41317: NEG
41318: PUSH
41319: LD_INT 5
41321: NEG
41322: PUSH
41323: EMPTY
41324: LIST
41325: LIST
41326: PUSH
41327: LD_INT 3
41329: PUSH
41330: LD_INT 0
41332: PUSH
41333: EMPTY
41334: LIST
41335: LIST
41336: PUSH
41337: LD_INT 3
41339: PUSH
41340: LD_INT 1
41342: NEG
41343: PUSH
41344: EMPTY
41345: LIST
41346: LIST
41347: PUSH
41348: LD_INT 4
41350: PUSH
41351: LD_INT 0
41353: PUSH
41354: EMPTY
41355: LIST
41356: LIST
41357: PUSH
41358: LD_INT 4
41360: PUSH
41361: LD_INT 1
41363: PUSH
41364: EMPTY
41365: LIST
41366: LIST
41367: PUSH
41368: LD_INT 3
41370: PUSH
41371: LD_INT 1
41373: PUSH
41374: EMPTY
41375: LIST
41376: LIST
41377: PUSH
41378: LD_INT 2
41380: PUSH
41381: LD_INT 0
41383: PUSH
41384: EMPTY
41385: LIST
41386: LIST
41387: PUSH
41388: LD_INT 2
41390: PUSH
41391: LD_INT 1
41393: NEG
41394: PUSH
41395: EMPTY
41396: LIST
41397: LIST
41398: PUSH
41399: LD_INT 2
41401: PUSH
41402: LD_INT 2
41404: NEG
41405: PUSH
41406: EMPTY
41407: LIST
41408: LIST
41409: PUSH
41410: LD_INT 4
41412: PUSH
41413: LD_INT 2
41415: PUSH
41416: EMPTY
41417: LIST
41418: LIST
41419: PUSH
41420: LD_INT 4
41422: PUSH
41423: LD_INT 4
41425: PUSH
41426: EMPTY
41427: LIST
41428: LIST
41429: PUSH
41430: LD_INT 4
41432: PUSH
41433: LD_INT 3
41435: PUSH
41436: EMPTY
41437: LIST
41438: LIST
41439: PUSH
41440: LD_INT 5
41442: PUSH
41443: LD_INT 4
41445: PUSH
41446: EMPTY
41447: LIST
41448: LIST
41449: PUSH
41450: LD_INT 5
41452: PUSH
41453: LD_INT 5
41455: PUSH
41456: EMPTY
41457: LIST
41458: LIST
41459: PUSH
41460: LD_INT 4
41462: PUSH
41463: LD_INT 5
41465: PUSH
41466: EMPTY
41467: LIST
41468: LIST
41469: PUSH
41470: LD_INT 3
41472: PUSH
41473: LD_INT 4
41475: PUSH
41476: EMPTY
41477: LIST
41478: LIST
41479: PUSH
41480: LD_INT 3
41482: PUSH
41483: LD_INT 3
41485: PUSH
41486: EMPTY
41487: LIST
41488: LIST
41489: PUSH
41490: LD_INT 5
41492: PUSH
41493: LD_INT 3
41495: PUSH
41496: EMPTY
41497: LIST
41498: LIST
41499: PUSH
41500: LD_INT 3
41502: PUSH
41503: LD_INT 5
41505: PUSH
41506: EMPTY
41507: LIST
41508: LIST
41509: PUSH
41510: EMPTY
41511: LIST
41512: LIST
41513: LIST
41514: LIST
41515: LIST
41516: LIST
41517: LIST
41518: LIST
41519: LIST
41520: LIST
41521: LIST
41522: LIST
41523: LIST
41524: LIST
41525: LIST
41526: LIST
41527: LIST
41528: LIST
41529: LIST
41530: LIST
41531: LIST
41532: LIST
41533: LIST
41534: LIST
41535: LIST
41536: LIST
41537: LIST
41538: LIST
41539: LIST
41540: LIST
41541: LIST
41542: LIST
41543: LIST
41544: LIST
41545: LIST
41546: LIST
41547: LIST
41548: LIST
41549: LIST
41550: LIST
41551: LIST
41552: LIST
41553: LIST
41554: LIST
41555: LIST
41556: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
41557: LD_ADDR_VAR 0 33
41561: PUSH
41562: LD_INT 4
41564: NEG
41565: PUSH
41566: LD_INT 4
41568: NEG
41569: PUSH
41570: EMPTY
41571: LIST
41572: LIST
41573: PUSH
41574: LD_INT 4
41576: NEG
41577: PUSH
41578: LD_INT 5
41580: NEG
41581: PUSH
41582: EMPTY
41583: LIST
41584: LIST
41585: PUSH
41586: LD_INT 3
41588: NEG
41589: PUSH
41590: LD_INT 4
41592: NEG
41593: PUSH
41594: EMPTY
41595: LIST
41596: LIST
41597: PUSH
41598: LD_INT 3
41600: NEG
41601: PUSH
41602: LD_INT 3
41604: NEG
41605: PUSH
41606: EMPTY
41607: LIST
41608: LIST
41609: PUSH
41610: LD_INT 4
41612: NEG
41613: PUSH
41614: LD_INT 3
41616: NEG
41617: PUSH
41618: EMPTY
41619: LIST
41620: LIST
41621: PUSH
41622: LD_INT 5
41624: NEG
41625: PUSH
41626: LD_INT 4
41628: NEG
41629: PUSH
41630: EMPTY
41631: LIST
41632: LIST
41633: PUSH
41634: LD_INT 5
41636: NEG
41637: PUSH
41638: LD_INT 5
41640: NEG
41641: PUSH
41642: EMPTY
41643: LIST
41644: LIST
41645: PUSH
41646: LD_INT 3
41648: NEG
41649: PUSH
41650: LD_INT 5
41652: NEG
41653: PUSH
41654: EMPTY
41655: LIST
41656: LIST
41657: PUSH
41658: LD_INT 5
41660: NEG
41661: PUSH
41662: LD_INT 3
41664: NEG
41665: PUSH
41666: EMPTY
41667: LIST
41668: LIST
41669: PUSH
41670: LD_INT 0
41672: PUSH
41673: LD_INT 3
41675: NEG
41676: PUSH
41677: EMPTY
41678: LIST
41679: LIST
41680: PUSH
41681: LD_INT 0
41683: PUSH
41684: LD_INT 4
41686: NEG
41687: PUSH
41688: EMPTY
41689: LIST
41690: LIST
41691: PUSH
41692: LD_INT 1
41694: PUSH
41695: LD_INT 3
41697: NEG
41698: PUSH
41699: EMPTY
41700: LIST
41701: LIST
41702: PUSH
41703: LD_INT 1
41705: PUSH
41706: LD_INT 2
41708: NEG
41709: PUSH
41710: EMPTY
41711: LIST
41712: LIST
41713: PUSH
41714: LD_INT 0
41716: PUSH
41717: LD_INT 2
41719: NEG
41720: PUSH
41721: EMPTY
41722: LIST
41723: LIST
41724: PUSH
41725: LD_INT 1
41727: NEG
41728: PUSH
41729: LD_INT 3
41731: NEG
41732: PUSH
41733: EMPTY
41734: LIST
41735: LIST
41736: PUSH
41737: LD_INT 1
41739: NEG
41740: PUSH
41741: LD_INT 4
41743: NEG
41744: PUSH
41745: EMPTY
41746: LIST
41747: LIST
41748: PUSH
41749: LD_INT 2
41751: PUSH
41752: LD_INT 2
41754: NEG
41755: PUSH
41756: EMPTY
41757: LIST
41758: LIST
41759: PUSH
41760: LD_INT 2
41762: NEG
41763: PUSH
41764: LD_INT 4
41766: NEG
41767: PUSH
41768: EMPTY
41769: LIST
41770: LIST
41771: PUSH
41772: LD_INT 4
41774: PUSH
41775: LD_INT 0
41777: PUSH
41778: EMPTY
41779: LIST
41780: LIST
41781: PUSH
41782: LD_INT 4
41784: PUSH
41785: LD_INT 1
41787: NEG
41788: PUSH
41789: EMPTY
41790: LIST
41791: LIST
41792: PUSH
41793: LD_INT 5
41795: PUSH
41796: LD_INT 0
41798: PUSH
41799: EMPTY
41800: LIST
41801: LIST
41802: PUSH
41803: LD_INT 5
41805: PUSH
41806: LD_INT 1
41808: PUSH
41809: EMPTY
41810: LIST
41811: LIST
41812: PUSH
41813: LD_INT 4
41815: PUSH
41816: LD_INT 1
41818: PUSH
41819: EMPTY
41820: LIST
41821: LIST
41822: PUSH
41823: LD_INT 3
41825: PUSH
41826: LD_INT 0
41828: PUSH
41829: EMPTY
41830: LIST
41831: LIST
41832: PUSH
41833: LD_INT 3
41835: PUSH
41836: LD_INT 1
41838: NEG
41839: PUSH
41840: EMPTY
41841: LIST
41842: LIST
41843: PUSH
41844: LD_INT 3
41846: PUSH
41847: LD_INT 2
41849: NEG
41850: PUSH
41851: EMPTY
41852: LIST
41853: LIST
41854: PUSH
41855: LD_INT 5
41857: PUSH
41858: LD_INT 2
41860: PUSH
41861: EMPTY
41862: LIST
41863: LIST
41864: PUSH
41865: LD_INT 3
41867: PUSH
41868: LD_INT 3
41870: PUSH
41871: EMPTY
41872: LIST
41873: LIST
41874: PUSH
41875: LD_INT 3
41877: PUSH
41878: LD_INT 2
41880: PUSH
41881: EMPTY
41882: LIST
41883: LIST
41884: PUSH
41885: LD_INT 4
41887: PUSH
41888: LD_INT 3
41890: PUSH
41891: EMPTY
41892: LIST
41893: LIST
41894: PUSH
41895: LD_INT 4
41897: PUSH
41898: LD_INT 4
41900: PUSH
41901: EMPTY
41902: LIST
41903: LIST
41904: PUSH
41905: LD_INT 3
41907: PUSH
41908: LD_INT 4
41910: PUSH
41911: EMPTY
41912: LIST
41913: LIST
41914: PUSH
41915: LD_INT 2
41917: PUSH
41918: LD_INT 3
41920: PUSH
41921: EMPTY
41922: LIST
41923: LIST
41924: PUSH
41925: LD_INT 2
41927: PUSH
41928: LD_INT 2
41930: PUSH
41931: EMPTY
41932: LIST
41933: LIST
41934: PUSH
41935: LD_INT 4
41937: PUSH
41938: LD_INT 2
41940: PUSH
41941: EMPTY
41942: LIST
41943: LIST
41944: PUSH
41945: LD_INT 2
41947: PUSH
41948: LD_INT 4
41950: PUSH
41951: EMPTY
41952: LIST
41953: LIST
41954: PUSH
41955: LD_INT 0
41957: PUSH
41958: LD_INT 4
41960: PUSH
41961: EMPTY
41962: LIST
41963: LIST
41964: PUSH
41965: LD_INT 0
41967: PUSH
41968: LD_INT 3
41970: PUSH
41971: EMPTY
41972: LIST
41973: LIST
41974: PUSH
41975: LD_INT 1
41977: PUSH
41978: LD_INT 4
41980: PUSH
41981: EMPTY
41982: LIST
41983: LIST
41984: PUSH
41985: LD_INT 1
41987: PUSH
41988: LD_INT 5
41990: PUSH
41991: EMPTY
41992: LIST
41993: LIST
41994: PUSH
41995: LD_INT 0
41997: PUSH
41998: LD_INT 5
42000: PUSH
42001: EMPTY
42002: LIST
42003: LIST
42004: PUSH
42005: LD_INT 1
42007: NEG
42008: PUSH
42009: LD_INT 4
42011: PUSH
42012: EMPTY
42013: LIST
42014: LIST
42015: PUSH
42016: LD_INT 1
42018: NEG
42019: PUSH
42020: LD_INT 3
42022: PUSH
42023: EMPTY
42024: LIST
42025: LIST
42026: PUSH
42027: LD_INT 2
42029: PUSH
42030: LD_INT 5
42032: PUSH
42033: EMPTY
42034: LIST
42035: LIST
42036: PUSH
42037: LD_INT 2
42039: NEG
42040: PUSH
42041: LD_INT 3
42043: PUSH
42044: EMPTY
42045: LIST
42046: LIST
42047: PUSH
42048: EMPTY
42049: LIST
42050: LIST
42051: LIST
42052: LIST
42053: LIST
42054: LIST
42055: LIST
42056: LIST
42057: LIST
42058: LIST
42059: LIST
42060: LIST
42061: LIST
42062: LIST
42063: LIST
42064: LIST
42065: LIST
42066: LIST
42067: LIST
42068: LIST
42069: LIST
42070: LIST
42071: LIST
42072: LIST
42073: LIST
42074: LIST
42075: LIST
42076: LIST
42077: LIST
42078: LIST
42079: LIST
42080: LIST
42081: LIST
42082: LIST
42083: LIST
42084: LIST
42085: LIST
42086: LIST
42087: LIST
42088: LIST
42089: LIST
42090: LIST
42091: LIST
42092: LIST
42093: LIST
42094: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
42095: LD_ADDR_VAR 0 34
42099: PUSH
42100: LD_INT 0
42102: PUSH
42103: LD_INT 4
42105: NEG
42106: PUSH
42107: EMPTY
42108: LIST
42109: LIST
42110: PUSH
42111: LD_INT 0
42113: PUSH
42114: LD_INT 5
42116: NEG
42117: PUSH
42118: EMPTY
42119: LIST
42120: LIST
42121: PUSH
42122: LD_INT 1
42124: PUSH
42125: LD_INT 4
42127: NEG
42128: PUSH
42129: EMPTY
42130: LIST
42131: LIST
42132: PUSH
42133: LD_INT 1
42135: PUSH
42136: LD_INT 3
42138: NEG
42139: PUSH
42140: EMPTY
42141: LIST
42142: LIST
42143: PUSH
42144: LD_INT 0
42146: PUSH
42147: LD_INT 3
42149: NEG
42150: PUSH
42151: EMPTY
42152: LIST
42153: LIST
42154: PUSH
42155: LD_INT 1
42157: NEG
42158: PUSH
42159: LD_INT 4
42161: NEG
42162: PUSH
42163: EMPTY
42164: LIST
42165: LIST
42166: PUSH
42167: LD_INT 1
42169: NEG
42170: PUSH
42171: LD_INT 5
42173: NEG
42174: PUSH
42175: EMPTY
42176: LIST
42177: LIST
42178: PUSH
42179: LD_INT 2
42181: PUSH
42182: LD_INT 3
42184: NEG
42185: PUSH
42186: EMPTY
42187: LIST
42188: LIST
42189: PUSH
42190: LD_INT 2
42192: NEG
42193: PUSH
42194: LD_INT 5
42196: NEG
42197: PUSH
42198: EMPTY
42199: LIST
42200: LIST
42201: PUSH
42202: LD_INT 3
42204: PUSH
42205: LD_INT 0
42207: PUSH
42208: EMPTY
42209: LIST
42210: LIST
42211: PUSH
42212: LD_INT 3
42214: PUSH
42215: LD_INT 1
42217: NEG
42218: PUSH
42219: EMPTY
42220: LIST
42221: LIST
42222: PUSH
42223: LD_INT 4
42225: PUSH
42226: LD_INT 0
42228: PUSH
42229: EMPTY
42230: LIST
42231: LIST
42232: PUSH
42233: LD_INT 4
42235: PUSH
42236: LD_INT 1
42238: PUSH
42239: EMPTY
42240: LIST
42241: LIST
42242: PUSH
42243: LD_INT 3
42245: PUSH
42246: LD_INT 1
42248: PUSH
42249: EMPTY
42250: LIST
42251: LIST
42252: PUSH
42253: LD_INT 2
42255: PUSH
42256: LD_INT 0
42258: PUSH
42259: EMPTY
42260: LIST
42261: LIST
42262: PUSH
42263: LD_INT 2
42265: PUSH
42266: LD_INT 1
42268: NEG
42269: PUSH
42270: EMPTY
42271: LIST
42272: LIST
42273: PUSH
42274: LD_INT 2
42276: PUSH
42277: LD_INT 2
42279: NEG
42280: PUSH
42281: EMPTY
42282: LIST
42283: LIST
42284: PUSH
42285: LD_INT 4
42287: PUSH
42288: LD_INT 2
42290: PUSH
42291: EMPTY
42292: LIST
42293: LIST
42294: PUSH
42295: LD_INT 4
42297: PUSH
42298: LD_INT 4
42300: PUSH
42301: EMPTY
42302: LIST
42303: LIST
42304: PUSH
42305: LD_INT 4
42307: PUSH
42308: LD_INT 3
42310: PUSH
42311: EMPTY
42312: LIST
42313: LIST
42314: PUSH
42315: LD_INT 5
42317: PUSH
42318: LD_INT 4
42320: PUSH
42321: EMPTY
42322: LIST
42323: LIST
42324: PUSH
42325: LD_INT 5
42327: PUSH
42328: LD_INT 5
42330: PUSH
42331: EMPTY
42332: LIST
42333: LIST
42334: PUSH
42335: LD_INT 4
42337: PUSH
42338: LD_INT 5
42340: PUSH
42341: EMPTY
42342: LIST
42343: LIST
42344: PUSH
42345: LD_INT 3
42347: PUSH
42348: LD_INT 4
42350: PUSH
42351: EMPTY
42352: LIST
42353: LIST
42354: PUSH
42355: LD_INT 3
42357: PUSH
42358: LD_INT 3
42360: PUSH
42361: EMPTY
42362: LIST
42363: LIST
42364: PUSH
42365: LD_INT 5
42367: PUSH
42368: LD_INT 3
42370: PUSH
42371: EMPTY
42372: LIST
42373: LIST
42374: PUSH
42375: LD_INT 3
42377: PUSH
42378: LD_INT 5
42380: PUSH
42381: EMPTY
42382: LIST
42383: LIST
42384: PUSH
42385: LD_INT 0
42387: PUSH
42388: LD_INT 3
42390: PUSH
42391: EMPTY
42392: LIST
42393: LIST
42394: PUSH
42395: LD_INT 0
42397: PUSH
42398: LD_INT 2
42400: PUSH
42401: EMPTY
42402: LIST
42403: LIST
42404: PUSH
42405: LD_INT 1
42407: PUSH
42408: LD_INT 3
42410: PUSH
42411: EMPTY
42412: LIST
42413: LIST
42414: PUSH
42415: LD_INT 1
42417: PUSH
42418: LD_INT 4
42420: PUSH
42421: EMPTY
42422: LIST
42423: LIST
42424: PUSH
42425: LD_INT 0
42427: PUSH
42428: LD_INT 4
42430: PUSH
42431: EMPTY
42432: LIST
42433: LIST
42434: PUSH
42435: LD_INT 1
42437: NEG
42438: PUSH
42439: LD_INT 3
42441: PUSH
42442: EMPTY
42443: LIST
42444: LIST
42445: PUSH
42446: LD_INT 1
42448: NEG
42449: PUSH
42450: LD_INT 2
42452: PUSH
42453: EMPTY
42454: LIST
42455: LIST
42456: PUSH
42457: LD_INT 2
42459: PUSH
42460: LD_INT 4
42462: PUSH
42463: EMPTY
42464: LIST
42465: LIST
42466: PUSH
42467: LD_INT 2
42469: NEG
42470: PUSH
42471: LD_INT 2
42473: PUSH
42474: EMPTY
42475: LIST
42476: LIST
42477: PUSH
42478: LD_INT 4
42480: NEG
42481: PUSH
42482: LD_INT 0
42484: PUSH
42485: EMPTY
42486: LIST
42487: LIST
42488: PUSH
42489: LD_INT 4
42491: NEG
42492: PUSH
42493: LD_INT 1
42495: NEG
42496: PUSH
42497: EMPTY
42498: LIST
42499: LIST
42500: PUSH
42501: LD_INT 3
42503: NEG
42504: PUSH
42505: LD_INT 0
42507: PUSH
42508: EMPTY
42509: LIST
42510: LIST
42511: PUSH
42512: LD_INT 3
42514: NEG
42515: PUSH
42516: LD_INT 1
42518: PUSH
42519: EMPTY
42520: LIST
42521: LIST
42522: PUSH
42523: LD_INT 4
42525: NEG
42526: PUSH
42527: LD_INT 1
42529: PUSH
42530: EMPTY
42531: LIST
42532: LIST
42533: PUSH
42534: LD_INT 5
42536: NEG
42537: PUSH
42538: LD_INT 0
42540: PUSH
42541: EMPTY
42542: LIST
42543: LIST
42544: PUSH
42545: LD_INT 5
42547: NEG
42548: PUSH
42549: LD_INT 1
42551: NEG
42552: PUSH
42553: EMPTY
42554: LIST
42555: LIST
42556: PUSH
42557: LD_INT 5
42559: NEG
42560: PUSH
42561: LD_INT 2
42563: NEG
42564: PUSH
42565: EMPTY
42566: LIST
42567: LIST
42568: PUSH
42569: LD_INT 3
42571: NEG
42572: PUSH
42573: LD_INT 2
42575: PUSH
42576: EMPTY
42577: LIST
42578: LIST
42579: PUSH
42580: EMPTY
42581: LIST
42582: LIST
42583: LIST
42584: LIST
42585: LIST
42586: LIST
42587: LIST
42588: LIST
42589: LIST
42590: LIST
42591: LIST
42592: LIST
42593: LIST
42594: LIST
42595: LIST
42596: LIST
42597: LIST
42598: LIST
42599: LIST
42600: LIST
42601: LIST
42602: LIST
42603: LIST
42604: LIST
42605: LIST
42606: LIST
42607: LIST
42608: LIST
42609: LIST
42610: LIST
42611: LIST
42612: LIST
42613: LIST
42614: LIST
42615: LIST
42616: LIST
42617: LIST
42618: LIST
42619: LIST
42620: LIST
42621: LIST
42622: LIST
42623: LIST
42624: LIST
42625: LIST
42626: ST_TO_ADDR
// end ; end ;
42627: GO 42630
42629: POP
// case btype of b_depot , b_warehouse :
42630: LD_VAR 0 1
42634: PUSH
42635: LD_INT 0
42637: DOUBLE
42638: EQUAL
42639: IFTRUE 42649
42641: LD_INT 1
42643: DOUBLE
42644: EQUAL
42645: IFTRUE 42649
42647: GO 42850
42649: POP
// case nation of nation_american :
42650: LD_VAR 0 5
42654: PUSH
42655: LD_INT 1
42657: DOUBLE
42658: EQUAL
42659: IFTRUE 42663
42661: GO 42719
42663: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
42664: LD_ADDR_VAR 0 9
42668: PUSH
42669: LD_VAR 0 11
42673: PUSH
42674: LD_VAR 0 12
42678: PUSH
42679: LD_VAR 0 13
42683: PUSH
42684: LD_VAR 0 14
42688: PUSH
42689: LD_VAR 0 15
42693: PUSH
42694: LD_VAR 0 16
42698: PUSH
42699: EMPTY
42700: LIST
42701: LIST
42702: LIST
42703: LIST
42704: LIST
42705: LIST
42706: PUSH
42707: LD_VAR 0 4
42711: PUSH
42712: LD_INT 1
42714: PLUS
42715: ARRAY
42716: ST_TO_ADDR
42717: GO 42848
42719: LD_INT 2
42721: DOUBLE
42722: EQUAL
42723: IFTRUE 42727
42725: GO 42783
42727: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
42728: LD_ADDR_VAR 0 9
42732: PUSH
42733: LD_VAR 0 17
42737: PUSH
42738: LD_VAR 0 18
42742: PUSH
42743: LD_VAR 0 19
42747: PUSH
42748: LD_VAR 0 20
42752: PUSH
42753: LD_VAR 0 21
42757: PUSH
42758: LD_VAR 0 22
42762: PUSH
42763: EMPTY
42764: LIST
42765: LIST
42766: LIST
42767: LIST
42768: LIST
42769: LIST
42770: PUSH
42771: LD_VAR 0 4
42775: PUSH
42776: LD_INT 1
42778: PLUS
42779: ARRAY
42780: ST_TO_ADDR
42781: GO 42848
42783: LD_INT 3
42785: DOUBLE
42786: EQUAL
42787: IFTRUE 42791
42789: GO 42847
42791: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
42792: LD_ADDR_VAR 0 9
42796: PUSH
42797: LD_VAR 0 23
42801: PUSH
42802: LD_VAR 0 24
42806: PUSH
42807: LD_VAR 0 25
42811: PUSH
42812: LD_VAR 0 26
42816: PUSH
42817: LD_VAR 0 27
42821: PUSH
42822: LD_VAR 0 28
42826: PUSH
42827: EMPTY
42828: LIST
42829: LIST
42830: LIST
42831: LIST
42832: LIST
42833: LIST
42834: PUSH
42835: LD_VAR 0 4
42839: PUSH
42840: LD_INT 1
42842: PLUS
42843: ARRAY
42844: ST_TO_ADDR
42845: GO 42848
42847: POP
42848: GO 43403
42850: LD_INT 2
42852: DOUBLE
42853: EQUAL
42854: IFTRUE 42864
42856: LD_INT 3
42858: DOUBLE
42859: EQUAL
42860: IFTRUE 42864
42862: GO 42920
42864: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
42865: LD_ADDR_VAR 0 9
42869: PUSH
42870: LD_VAR 0 29
42874: PUSH
42875: LD_VAR 0 30
42879: PUSH
42880: LD_VAR 0 31
42884: PUSH
42885: LD_VAR 0 32
42889: PUSH
42890: LD_VAR 0 33
42894: PUSH
42895: LD_VAR 0 34
42899: PUSH
42900: EMPTY
42901: LIST
42902: LIST
42903: LIST
42904: LIST
42905: LIST
42906: LIST
42907: PUSH
42908: LD_VAR 0 4
42912: PUSH
42913: LD_INT 1
42915: PLUS
42916: ARRAY
42917: ST_TO_ADDR
42918: GO 43403
42920: LD_INT 16
42922: DOUBLE
42923: EQUAL
42924: IFTRUE 42982
42926: LD_INT 17
42928: DOUBLE
42929: EQUAL
42930: IFTRUE 42982
42932: LD_INT 18
42934: DOUBLE
42935: EQUAL
42936: IFTRUE 42982
42938: LD_INT 19
42940: DOUBLE
42941: EQUAL
42942: IFTRUE 42982
42944: LD_INT 22
42946: DOUBLE
42947: EQUAL
42948: IFTRUE 42982
42950: LD_INT 20
42952: DOUBLE
42953: EQUAL
42954: IFTRUE 42982
42956: LD_INT 21
42958: DOUBLE
42959: EQUAL
42960: IFTRUE 42982
42962: LD_INT 23
42964: DOUBLE
42965: EQUAL
42966: IFTRUE 42982
42968: LD_INT 24
42970: DOUBLE
42971: EQUAL
42972: IFTRUE 42982
42974: LD_INT 25
42976: DOUBLE
42977: EQUAL
42978: IFTRUE 42982
42980: GO 43038
42982: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
42983: LD_ADDR_VAR 0 9
42987: PUSH
42988: LD_VAR 0 35
42992: PUSH
42993: LD_VAR 0 36
42997: PUSH
42998: LD_VAR 0 37
43002: PUSH
43003: LD_VAR 0 38
43007: PUSH
43008: LD_VAR 0 39
43012: PUSH
43013: LD_VAR 0 40
43017: PUSH
43018: EMPTY
43019: LIST
43020: LIST
43021: LIST
43022: LIST
43023: LIST
43024: LIST
43025: PUSH
43026: LD_VAR 0 4
43030: PUSH
43031: LD_INT 1
43033: PLUS
43034: ARRAY
43035: ST_TO_ADDR
43036: GO 43403
43038: LD_INT 6
43040: DOUBLE
43041: EQUAL
43042: IFTRUE 43094
43044: LD_INT 7
43046: DOUBLE
43047: EQUAL
43048: IFTRUE 43094
43050: LD_INT 8
43052: DOUBLE
43053: EQUAL
43054: IFTRUE 43094
43056: LD_INT 13
43058: DOUBLE
43059: EQUAL
43060: IFTRUE 43094
43062: LD_INT 12
43064: DOUBLE
43065: EQUAL
43066: IFTRUE 43094
43068: LD_INT 15
43070: DOUBLE
43071: EQUAL
43072: IFTRUE 43094
43074: LD_INT 11
43076: DOUBLE
43077: EQUAL
43078: IFTRUE 43094
43080: LD_INT 14
43082: DOUBLE
43083: EQUAL
43084: IFTRUE 43094
43086: LD_INT 10
43088: DOUBLE
43089: EQUAL
43090: IFTRUE 43094
43092: GO 43150
43094: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
43095: LD_ADDR_VAR 0 9
43099: PUSH
43100: LD_VAR 0 41
43104: PUSH
43105: LD_VAR 0 42
43109: PUSH
43110: LD_VAR 0 43
43114: PUSH
43115: LD_VAR 0 44
43119: PUSH
43120: LD_VAR 0 45
43124: PUSH
43125: LD_VAR 0 46
43129: PUSH
43130: EMPTY
43131: LIST
43132: LIST
43133: LIST
43134: LIST
43135: LIST
43136: LIST
43137: PUSH
43138: LD_VAR 0 4
43142: PUSH
43143: LD_INT 1
43145: PLUS
43146: ARRAY
43147: ST_TO_ADDR
43148: GO 43403
43150: LD_INT 36
43152: DOUBLE
43153: EQUAL
43154: IFTRUE 43158
43156: GO 43214
43158: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
43159: LD_ADDR_VAR 0 9
43163: PUSH
43164: LD_VAR 0 47
43168: PUSH
43169: LD_VAR 0 48
43173: PUSH
43174: LD_VAR 0 49
43178: PUSH
43179: LD_VAR 0 50
43183: PUSH
43184: LD_VAR 0 51
43188: PUSH
43189: LD_VAR 0 52
43193: PUSH
43194: EMPTY
43195: LIST
43196: LIST
43197: LIST
43198: LIST
43199: LIST
43200: LIST
43201: PUSH
43202: LD_VAR 0 4
43206: PUSH
43207: LD_INT 1
43209: PLUS
43210: ARRAY
43211: ST_TO_ADDR
43212: GO 43403
43214: LD_INT 4
43216: DOUBLE
43217: EQUAL
43218: IFTRUE 43240
43220: LD_INT 5
43222: DOUBLE
43223: EQUAL
43224: IFTRUE 43240
43226: LD_INT 34
43228: DOUBLE
43229: EQUAL
43230: IFTRUE 43240
43232: LD_INT 37
43234: DOUBLE
43235: EQUAL
43236: IFTRUE 43240
43238: GO 43296
43240: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
43241: LD_ADDR_VAR 0 9
43245: PUSH
43246: LD_VAR 0 53
43250: PUSH
43251: LD_VAR 0 54
43255: PUSH
43256: LD_VAR 0 55
43260: PUSH
43261: LD_VAR 0 56
43265: PUSH
43266: LD_VAR 0 57
43270: PUSH
43271: LD_VAR 0 58
43275: PUSH
43276: EMPTY
43277: LIST
43278: LIST
43279: LIST
43280: LIST
43281: LIST
43282: LIST
43283: PUSH
43284: LD_VAR 0 4
43288: PUSH
43289: LD_INT 1
43291: PLUS
43292: ARRAY
43293: ST_TO_ADDR
43294: GO 43403
43296: LD_INT 31
43298: DOUBLE
43299: EQUAL
43300: IFTRUE 43346
43302: LD_INT 32
43304: DOUBLE
43305: EQUAL
43306: IFTRUE 43346
43308: LD_INT 33
43310: DOUBLE
43311: EQUAL
43312: IFTRUE 43346
43314: LD_INT 27
43316: DOUBLE
43317: EQUAL
43318: IFTRUE 43346
43320: LD_INT 26
43322: DOUBLE
43323: EQUAL
43324: IFTRUE 43346
43326: LD_INT 28
43328: DOUBLE
43329: EQUAL
43330: IFTRUE 43346
43332: LD_INT 29
43334: DOUBLE
43335: EQUAL
43336: IFTRUE 43346
43338: LD_INT 30
43340: DOUBLE
43341: EQUAL
43342: IFTRUE 43346
43344: GO 43402
43346: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
43347: LD_ADDR_VAR 0 9
43351: PUSH
43352: LD_VAR 0 59
43356: PUSH
43357: LD_VAR 0 60
43361: PUSH
43362: LD_VAR 0 61
43366: PUSH
43367: LD_VAR 0 62
43371: PUSH
43372: LD_VAR 0 63
43376: PUSH
43377: LD_VAR 0 64
43381: PUSH
43382: EMPTY
43383: LIST
43384: LIST
43385: LIST
43386: LIST
43387: LIST
43388: LIST
43389: PUSH
43390: LD_VAR 0 4
43394: PUSH
43395: LD_INT 1
43397: PLUS
43398: ARRAY
43399: ST_TO_ADDR
43400: GO 43403
43402: POP
// temp_list2 = [ ] ;
43403: LD_ADDR_VAR 0 10
43407: PUSH
43408: EMPTY
43409: ST_TO_ADDR
// for i in temp_list do
43410: LD_ADDR_VAR 0 8
43414: PUSH
43415: LD_VAR 0 9
43419: PUSH
43420: FOR_IN
43421: IFFALSE 43473
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
43423: LD_ADDR_VAR 0 10
43427: PUSH
43428: LD_VAR 0 10
43432: PUSH
43433: LD_VAR 0 8
43437: PUSH
43438: LD_INT 1
43440: ARRAY
43441: PUSH
43442: LD_VAR 0 2
43446: PLUS
43447: PUSH
43448: LD_VAR 0 8
43452: PUSH
43453: LD_INT 2
43455: ARRAY
43456: PUSH
43457: LD_VAR 0 3
43461: PLUS
43462: PUSH
43463: EMPTY
43464: LIST
43465: LIST
43466: PUSH
43467: EMPTY
43468: LIST
43469: ADD
43470: ST_TO_ADDR
43471: GO 43420
43473: POP
43474: POP
// result = temp_list2 ;
43475: LD_ADDR_VAR 0 7
43479: PUSH
43480: LD_VAR 0 10
43484: ST_TO_ADDR
// end ;
43485: LD_VAR 0 7
43489: RET
// export function EnemyInRange ( unit , dist ) ; begin
43490: LD_INT 0
43492: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
43493: LD_ADDR_VAR 0 3
43497: PUSH
43498: LD_VAR 0 1
43502: PPUSH
43503: CALL_OW 255
43507: PPUSH
43508: LD_VAR 0 1
43512: PPUSH
43513: CALL_OW 250
43517: PPUSH
43518: LD_VAR 0 1
43522: PPUSH
43523: CALL_OW 251
43527: PPUSH
43528: LD_VAR 0 2
43532: PPUSH
43533: CALL 16886 0 4
43537: PUSH
43538: LD_INT 4
43540: ARRAY
43541: ST_TO_ADDR
// end ;
43542: LD_VAR 0 3
43546: RET
// export function PlayerSeeMe ( unit ) ; begin
43547: LD_INT 0
43549: PPUSH
// result := See ( your_side , unit ) ;
43550: LD_ADDR_VAR 0 2
43554: PUSH
43555: LD_OWVAR 2
43559: PPUSH
43560: LD_VAR 0 1
43564: PPUSH
43565: CALL_OW 292
43569: ST_TO_ADDR
// end ;
43570: LD_VAR 0 2
43574: RET
// export function ReverseDir ( unit ) ; begin
43575: LD_INT 0
43577: PPUSH
// if not unit then
43578: LD_VAR 0 1
43582: NOT
43583: IFFALSE 43587
// exit ;
43585: GO 43610
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
43587: LD_ADDR_VAR 0 2
43591: PUSH
43592: LD_VAR 0 1
43596: PPUSH
43597: CALL_OW 254
43601: PUSH
43602: LD_INT 3
43604: PLUS
43605: PUSH
43606: LD_INT 6
43608: MOD
43609: ST_TO_ADDR
// end ;
43610: LD_VAR 0 2
43614: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
43615: LD_INT 0
43617: PPUSH
43618: PPUSH
43619: PPUSH
43620: PPUSH
43621: PPUSH
// if not hexes then
43622: LD_VAR 0 2
43626: NOT
43627: IFFALSE 43631
// exit ;
43629: GO 43779
// dist := 9999 ;
43631: LD_ADDR_VAR 0 5
43635: PUSH
43636: LD_INT 9999
43638: ST_TO_ADDR
// for i = 1 to hexes do
43639: LD_ADDR_VAR 0 4
43643: PUSH
43644: DOUBLE
43645: LD_INT 1
43647: DEC
43648: ST_TO_ADDR
43649: LD_VAR 0 2
43653: PUSH
43654: FOR_TO
43655: IFFALSE 43767
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
43657: LD_VAR 0 1
43661: PPUSH
43662: LD_VAR 0 2
43666: PUSH
43667: LD_VAR 0 4
43671: ARRAY
43672: PUSH
43673: LD_INT 1
43675: ARRAY
43676: PPUSH
43677: LD_VAR 0 2
43681: PUSH
43682: LD_VAR 0 4
43686: ARRAY
43687: PUSH
43688: LD_INT 2
43690: ARRAY
43691: PPUSH
43692: CALL_OW 297
43696: PUSH
43697: LD_VAR 0 5
43701: LESS
43702: IFFALSE 43765
// begin hex := hexes [ i ] ;
43704: LD_ADDR_VAR 0 7
43708: PUSH
43709: LD_VAR 0 2
43713: PUSH
43714: LD_VAR 0 4
43718: ARRAY
43719: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
43720: LD_ADDR_VAR 0 5
43724: PUSH
43725: LD_VAR 0 1
43729: PPUSH
43730: LD_VAR 0 2
43734: PUSH
43735: LD_VAR 0 4
43739: ARRAY
43740: PUSH
43741: LD_INT 1
43743: ARRAY
43744: PPUSH
43745: LD_VAR 0 2
43749: PUSH
43750: LD_VAR 0 4
43754: ARRAY
43755: PUSH
43756: LD_INT 2
43758: ARRAY
43759: PPUSH
43760: CALL_OW 297
43764: ST_TO_ADDR
// end ; end ;
43765: GO 43654
43767: POP
43768: POP
// result := hex ;
43769: LD_ADDR_VAR 0 3
43773: PUSH
43774: LD_VAR 0 7
43778: ST_TO_ADDR
// end ;
43779: LD_VAR 0 3
43783: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
43784: LD_INT 0
43786: PPUSH
43787: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
43788: LD_VAR 0 1
43792: NOT
43793: PUSH
43794: LD_VAR 0 1
43798: PUSH
43799: LD_INT 21
43801: PUSH
43802: LD_INT 2
43804: PUSH
43805: EMPTY
43806: LIST
43807: LIST
43808: PUSH
43809: LD_INT 23
43811: PUSH
43812: LD_INT 2
43814: PUSH
43815: EMPTY
43816: LIST
43817: LIST
43818: PUSH
43819: EMPTY
43820: LIST
43821: LIST
43822: PPUSH
43823: CALL_OW 69
43827: IN
43828: NOT
43829: OR
43830: IFFALSE 43834
// exit ;
43832: GO 43881
// for i = 1 to 3 do
43834: LD_ADDR_VAR 0 3
43838: PUSH
43839: DOUBLE
43840: LD_INT 1
43842: DEC
43843: ST_TO_ADDR
43844: LD_INT 3
43846: PUSH
43847: FOR_TO
43848: IFFALSE 43879
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
43850: LD_VAR 0 1
43854: PPUSH
43855: CALL_OW 250
43859: PPUSH
43860: LD_VAR 0 1
43864: PPUSH
43865: CALL_OW 251
43869: PPUSH
43870: LD_INT 1
43872: PPUSH
43873: CALL_OW 453
43877: GO 43847
43879: POP
43880: POP
// end ;
43881: LD_VAR 0 2
43885: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
43886: LD_INT 0
43888: PPUSH
43889: PPUSH
43890: PPUSH
43891: PPUSH
43892: PPUSH
43893: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
43894: LD_VAR 0 1
43898: NOT
43899: PUSH
43900: LD_VAR 0 2
43904: NOT
43905: OR
43906: PUSH
43907: LD_VAR 0 1
43911: PPUSH
43912: CALL_OW 314
43916: OR
43917: IFFALSE 43921
// exit ;
43919: GO 44362
// x := GetX ( enemy_unit ) ;
43921: LD_ADDR_VAR 0 7
43925: PUSH
43926: LD_VAR 0 2
43930: PPUSH
43931: CALL_OW 250
43935: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
43936: LD_ADDR_VAR 0 8
43940: PUSH
43941: LD_VAR 0 2
43945: PPUSH
43946: CALL_OW 251
43950: ST_TO_ADDR
// if not x or not y then
43951: LD_VAR 0 7
43955: NOT
43956: PUSH
43957: LD_VAR 0 8
43961: NOT
43962: OR
43963: IFFALSE 43967
// exit ;
43965: GO 44362
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
43967: LD_ADDR_VAR 0 6
43971: PUSH
43972: LD_VAR 0 7
43976: PPUSH
43977: LD_INT 0
43979: PPUSH
43980: LD_INT 4
43982: PPUSH
43983: CALL_OW 272
43987: PUSH
43988: LD_VAR 0 8
43992: PPUSH
43993: LD_INT 0
43995: PPUSH
43996: LD_INT 4
43998: PPUSH
43999: CALL_OW 273
44003: PUSH
44004: EMPTY
44005: LIST
44006: LIST
44007: PUSH
44008: LD_VAR 0 7
44012: PPUSH
44013: LD_INT 1
44015: PPUSH
44016: LD_INT 4
44018: PPUSH
44019: CALL_OW 272
44023: PUSH
44024: LD_VAR 0 8
44028: PPUSH
44029: LD_INT 1
44031: PPUSH
44032: LD_INT 4
44034: PPUSH
44035: CALL_OW 273
44039: PUSH
44040: EMPTY
44041: LIST
44042: LIST
44043: PUSH
44044: LD_VAR 0 7
44048: PPUSH
44049: LD_INT 2
44051: PPUSH
44052: LD_INT 4
44054: PPUSH
44055: CALL_OW 272
44059: PUSH
44060: LD_VAR 0 8
44064: PPUSH
44065: LD_INT 2
44067: PPUSH
44068: LD_INT 4
44070: PPUSH
44071: CALL_OW 273
44075: PUSH
44076: EMPTY
44077: LIST
44078: LIST
44079: PUSH
44080: LD_VAR 0 7
44084: PPUSH
44085: LD_INT 3
44087: PPUSH
44088: LD_INT 4
44090: PPUSH
44091: CALL_OW 272
44095: PUSH
44096: LD_VAR 0 8
44100: PPUSH
44101: LD_INT 3
44103: PPUSH
44104: LD_INT 4
44106: PPUSH
44107: CALL_OW 273
44111: PUSH
44112: EMPTY
44113: LIST
44114: LIST
44115: PUSH
44116: LD_VAR 0 7
44120: PPUSH
44121: LD_INT 4
44123: PPUSH
44124: LD_INT 4
44126: PPUSH
44127: CALL_OW 272
44131: PUSH
44132: LD_VAR 0 8
44136: PPUSH
44137: LD_INT 4
44139: PPUSH
44140: LD_INT 4
44142: PPUSH
44143: CALL_OW 273
44147: PUSH
44148: EMPTY
44149: LIST
44150: LIST
44151: PUSH
44152: LD_VAR 0 7
44156: PPUSH
44157: LD_INT 5
44159: PPUSH
44160: LD_INT 4
44162: PPUSH
44163: CALL_OW 272
44167: PUSH
44168: LD_VAR 0 8
44172: PPUSH
44173: LD_INT 5
44175: PPUSH
44176: LD_INT 4
44178: PPUSH
44179: CALL_OW 273
44183: PUSH
44184: EMPTY
44185: LIST
44186: LIST
44187: PUSH
44188: EMPTY
44189: LIST
44190: LIST
44191: LIST
44192: LIST
44193: LIST
44194: LIST
44195: ST_TO_ADDR
// for i = tmp downto 1 do
44196: LD_ADDR_VAR 0 4
44200: PUSH
44201: DOUBLE
44202: LD_VAR 0 6
44206: INC
44207: ST_TO_ADDR
44208: LD_INT 1
44210: PUSH
44211: FOR_DOWNTO
44212: IFFALSE 44313
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
44214: LD_VAR 0 6
44218: PUSH
44219: LD_VAR 0 4
44223: ARRAY
44224: PUSH
44225: LD_INT 1
44227: ARRAY
44228: PPUSH
44229: LD_VAR 0 6
44233: PUSH
44234: LD_VAR 0 4
44238: ARRAY
44239: PUSH
44240: LD_INT 2
44242: ARRAY
44243: PPUSH
44244: CALL_OW 488
44248: NOT
44249: PUSH
44250: LD_VAR 0 6
44254: PUSH
44255: LD_VAR 0 4
44259: ARRAY
44260: PUSH
44261: LD_INT 1
44263: ARRAY
44264: PPUSH
44265: LD_VAR 0 6
44269: PUSH
44270: LD_VAR 0 4
44274: ARRAY
44275: PUSH
44276: LD_INT 2
44278: ARRAY
44279: PPUSH
44280: CALL_OW 428
44284: PUSH
44285: LD_INT 0
44287: NONEQUAL
44288: OR
44289: IFFALSE 44311
// tmp := Delete ( tmp , i ) ;
44291: LD_ADDR_VAR 0 6
44295: PUSH
44296: LD_VAR 0 6
44300: PPUSH
44301: LD_VAR 0 4
44305: PPUSH
44306: CALL_OW 3
44310: ST_TO_ADDR
44311: GO 44211
44313: POP
44314: POP
// j := GetClosestHex ( unit , tmp ) ;
44315: LD_ADDR_VAR 0 5
44319: PUSH
44320: LD_VAR 0 1
44324: PPUSH
44325: LD_VAR 0 6
44329: PPUSH
44330: CALL 43615 0 2
44334: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
44335: LD_VAR 0 1
44339: PPUSH
44340: LD_VAR 0 5
44344: PUSH
44345: LD_INT 1
44347: ARRAY
44348: PPUSH
44349: LD_VAR 0 5
44353: PUSH
44354: LD_INT 2
44356: ARRAY
44357: PPUSH
44358: CALL_OW 111
// end ;
44362: LD_VAR 0 3
44366: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
44367: LD_INT 0
44369: PPUSH
44370: PPUSH
44371: PPUSH
// uc_side = 0 ;
44372: LD_ADDR_OWVAR 20
44376: PUSH
44377: LD_INT 0
44379: ST_TO_ADDR
// uc_nation = 0 ;
44380: LD_ADDR_OWVAR 21
44384: PUSH
44385: LD_INT 0
44387: ST_TO_ADDR
// InitHc_All ( ) ;
44388: CALL_OW 584
// InitVc ;
44392: CALL_OW 20
// if mastodonts then
44396: LD_VAR 0 6
44400: IFFALSE 44467
// for i = 1 to mastodonts do
44402: LD_ADDR_VAR 0 11
44406: PUSH
44407: DOUBLE
44408: LD_INT 1
44410: DEC
44411: ST_TO_ADDR
44412: LD_VAR 0 6
44416: PUSH
44417: FOR_TO
44418: IFFALSE 44465
// begin vc_chassis := 31 ;
44420: LD_ADDR_OWVAR 37
44424: PUSH
44425: LD_INT 31
44427: ST_TO_ADDR
// vc_control := control_rider ;
44428: LD_ADDR_OWVAR 38
44432: PUSH
44433: LD_INT 4
44435: ST_TO_ADDR
// animal := CreateVehicle ;
44436: LD_ADDR_VAR 0 12
44440: PUSH
44441: CALL_OW 45
44445: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44446: LD_VAR 0 12
44450: PPUSH
44451: LD_VAR 0 8
44455: PPUSH
44456: LD_INT 0
44458: PPUSH
44459: CALL 46655 0 3
// end ;
44463: GO 44417
44465: POP
44466: POP
// if horses then
44467: LD_VAR 0 5
44471: IFFALSE 44538
// for i = 1 to horses do
44473: LD_ADDR_VAR 0 11
44477: PUSH
44478: DOUBLE
44479: LD_INT 1
44481: DEC
44482: ST_TO_ADDR
44483: LD_VAR 0 5
44487: PUSH
44488: FOR_TO
44489: IFFALSE 44536
// begin hc_class := 21 ;
44491: LD_ADDR_OWVAR 28
44495: PUSH
44496: LD_INT 21
44498: ST_TO_ADDR
// hc_gallery :=  ;
44499: LD_ADDR_OWVAR 33
44503: PUSH
44504: LD_STRING 
44506: ST_TO_ADDR
// animal := CreateHuman ;
44507: LD_ADDR_VAR 0 12
44511: PUSH
44512: CALL_OW 44
44516: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44517: LD_VAR 0 12
44521: PPUSH
44522: LD_VAR 0 8
44526: PPUSH
44527: LD_INT 0
44529: PPUSH
44530: CALL 46655 0 3
// end ;
44534: GO 44488
44536: POP
44537: POP
// if birds then
44538: LD_VAR 0 1
44542: IFFALSE 44609
// for i = 1 to birds do
44544: LD_ADDR_VAR 0 11
44548: PUSH
44549: DOUBLE
44550: LD_INT 1
44552: DEC
44553: ST_TO_ADDR
44554: LD_VAR 0 1
44558: PUSH
44559: FOR_TO
44560: IFFALSE 44607
// begin hc_class = 18 ;
44562: LD_ADDR_OWVAR 28
44566: PUSH
44567: LD_INT 18
44569: ST_TO_ADDR
// hc_gallery =  ;
44570: LD_ADDR_OWVAR 33
44574: PUSH
44575: LD_STRING 
44577: ST_TO_ADDR
// animal := CreateHuman ;
44578: LD_ADDR_VAR 0 12
44582: PUSH
44583: CALL_OW 44
44587: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44588: LD_VAR 0 12
44592: PPUSH
44593: LD_VAR 0 8
44597: PPUSH
44598: LD_INT 0
44600: PPUSH
44601: CALL 46655 0 3
// end ;
44605: GO 44559
44607: POP
44608: POP
// if tigers then
44609: LD_VAR 0 2
44613: IFFALSE 44697
// for i = 1 to tigers do
44615: LD_ADDR_VAR 0 11
44619: PUSH
44620: DOUBLE
44621: LD_INT 1
44623: DEC
44624: ST_TO_ADDR
44625: LD_VAR 0 2
44629: PUSH
44630: FOR_TO
44631: IFFALSE 44695
// begin hc_class = class_tiger ;
44633: LD_ADDR_OWVAR 28
44637: PUSH
44638: LD_INT 14
44640: ST_TO_ADDR
// hc_gallery =  ;
44641: LD_ADDR_OWVAR 33
44645: PUSH
44646: LD_STRING 
44648: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
44649: LD_ADDR_OWVAR 35
44653: PUSH
44654: LD_INT 7
44656: NEG
44657: PPUSH
44658: LD_INT 7
44660: PPUSH
44661: CALL_OW 12
44665: ST_TO_ADDR
// animal := CreateHuman ;
44666: LD_ADDR_VAR 0 12
44670: PUSH
44671: CALL_OW 44
44675: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44676: LD_VAR 0 12
44680: PPUSH
44681: LD_VAR 0 8
44685: PPUSH
44686: LD_INT 0
44688: PPUSH
44689: CALL 46655 0 3
// end ;
44693: GO 44630
44695: POP
44696: POP
// if apemans then
44697: LD_VAR 0 3
44701: IFFALSE 44824
// for i = 1 to apemans do
44703: LD_ADDR_VAR 0 11
44707: PUSH
44708: DOUBLE
44709: LD_INT 1
44711: DEC
44712: ST_TO_ADDR
44713: LD_VAR 0 3
44717: PUSH
44718: FOR_TO
44719: IFFALSE 44822
// begin hc_class = class_apeman ;
44721: LD_ADDR_OWVAR 28
44725: PUSH
44726: LD_INT 12
44728: ST_TO_ADDR
// hc_gallery =  ;
44729: LD_ADDR_OWVAR 33
44733: PUSH
44734: LD_STRING 
44736: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
44737: LD_ADDR_OWVAR 35
44741: PUSH
44742: LD_INT 2
44744: NEG
44745: PPUSH
44746: LD_INT 2
44748: PPUSH
44749: CALL_OW 12
44753: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
44754: LD_ADDR_OWVAR 31
44758: PUSH
44759: LD_INT 1
44761: PPUSH
44762: LD_INT 3
44764: PPUSH
44765: CALL_OW 12
44769: PUSH
44770: LD_INT 1
44772: PPUSH
44773: LD_INT 3
44775: PPUSH
44776: CALL_OW 12
44780: PUSH
44781: LD_INT 0
44783: PUSH
44784: LD_INT 0
44786: PUSH
44787: EMPTY
44788: LIST
44789: LIST
44790: LIST
44791: LIST
44792: ST_TO_ADDR
// animal := CreateHuman ;
44793: LD_ADDR_VAR 0 12
44797: PUSH
44798: CALL_OW 44
44802: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44803: LD_VAR 0 12
44807: PPUSH
44808: LD_VAR 0 8
44812: PPUSH
44813: LD_INT 0
44815: PPUSH
44816: CALL 46655 0 3
// end ;
44820: GO 44718
44822: POP
44823: POP
// if enchidnas then
44824: LD_VAR 0 4
44828: IFFALSE 44895
// for i = 1 to enchidnas do
44830: LD_ADDR_VAR 0 11
44834: PUSH
44835: DOUBLE
44836: LD_INT 1
44838: DEC
44839: ST_TO_ADDR
44840: LD_VAR 0 4
44844: PUSH
44845: FOR_TO
44846: IFFALSE 44893
// begin hc_class = 13 ;
44848: LD_ADDR_OWVAR 28
44852: PUSH
44853: LD_INT 13
44855: ST_TO_ADDR
// hc_gallery =  ;
44856: LD_ADDR_OWVAR 33
44860: PUSH
44861: LD_STRING 
44863: ST_TO_ADDR
// animal := CreateHuman ;
44864: LD_ADDR_VAR 0 12
44868: PUSH
44869: CALL_OW 44
44873: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44874: LD_VAR 0 12
44878: PPUSH
44879: LD_VAR 0 8
44883: PPUSH
44884: LD_INT 0
44886: PPUSH
44887: CALL 46655 0 3
// end ;
44891: GO 44845
44893: POP
44894: POP
// if fishes then
44895: LD_VAR 0 7
44899: IFFALSE 44966
// for i = 1 to fishes do
44901: LD_ADDR_VAR 0 11
44905: PUSH
44906: DOUBLE
44907: LD_INT 1
44909: DEC
44910: ST_TO_ADDR
44911: LD_VAR 0 7
44915: PUSH
44916: FOR_TO
44917: IFFALSE 44964
// begin hc_class = 20 ;
44919: LD_ADDR_OWVAR 28
44923: PUSH
44924: LD_INT 20
44926: ST_TO_ADDR
// hc_gallery =  ;
44927: LD_ADDR_OWVAR 33
44931: PUSH
44932: LD_STRING 
44934: ST_TO_ADDR
// animal := CreateHuman ;
44935: LD_ADDR_VAR 0 12
44939: PUSH
44940: CALL_OW 44
44944: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
44945: LD_VAR 0 12
44949: PPUSH
44950: LD_VAR 0 9
44954: PPUSH
44955: LD_INT 0
44957: PPUSH
44958: CALL 46655 0 3
// end ;
44962: GO 44916
44964: POP
44965: POP
// end ;
44966: LD_VAR 0 10
44970: RET
// export function WantHeal ( sci , unit ) ; begin
44971: LD_INT 0
44973: PPUSH
// if GetTaskList ( sci ) > 0 then
44974: LD_VAR 0 1
44978: PPUSH
44979: CALL_OW 437
44983: PUSH
44984: LD_INT 0
44986: GREATER
44987: IFFALSE 45057
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
44989: LD_VAR 0 1
44993: PPUSH
44994: CALL_OW 437
44998: PUSH
44999: LD_INT 1
45001: ARRAY
45002: PUSH
45003: LD_INT 1
45005: ARRAY
45006: PUSH
45007: LD_STRING l
45009: EQUAL
45010: PUSH
45011: LD_VAR 0 1
45015: PPUSH
45016: CALL_OW 437
45020: PUSH
45021: LD_INT 1
45023: ARRAY
45024: PUSH
45025: LD_INT 4
45027: ARRAY
45028: PUSH
45029: LD_VAR 0 2
45033: EQUAL
45034: AND
45035: IFFALSE 45047
// result := true else
45037: LD_ADDR_VAR 0 3
45041: PUSH
45042: LD_INT 1
45044: ST_TO_ADDR
45045: GO 45055
// result := false ;
45047: LD_ADDR_VAR 0 3
45051: PUSH
45052: LD_INT 0
45054: ST_TO_ADDR
// end else
45055: GO 45065
// result := false ;
45057: LD_ADDR_VAR 0 3
45061: PUSH
45062: LD_INT 0
45064: ST_TO_ADDR
// end ;
45065: LD_VAR 0 3
45069: RET
// export function HealTarget ( sci ) ; begin
45070: LD_INT 0
45072: PPUSH
// if not sci then
45073: LD_VAR 0 1
45077: NOT
45078: IFFALSE 45082
// exit ;
45080: GO 45147
// result := 0 ;
45082: LD_ADDR_VAR 0 2
45086: PUSH
45087: LD_INT 0
45089: ST_TO_ADDR
// if GetTaskList ( sci ) then
45090: LD_VAR 0 1
45094: PPUSH
45095: CALL_OW 437
45099: IFFALSE 45147
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
45101: LD_VAR 0 1
45105: PPUSH
45106: CALL_OW 437
45110: PUSH
45111: LD_INT 1
45113: ARRAY
45114: PUSH
45115: LD_INT 1
45117: ARRAY
45118: PUSH
45119: LD_STRING l
45121: EQUAL
45122: IFFALSE 45147
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
45124: LD_ADDR_VAR 0 2
45128: PUSH
45129: LD_VAR 0 1
45133: PPUSH
45134: CALL_OW 437
45138: PUSH
45139: LD_INT 1
45141: ARRAY
45142: PUSH
45143: LD_INT 4
45145: ARRAY
45146: ST_TO_ADDR
// end ;
45147: LD_VAR 0 2
45151: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
45152: LD_INT 0
45154: PPUSH
45155: PPUSH
45156: PPUSH
45157: PPUSH
// if not base_units then
45158: LD_VAR 0 1
45162: NOT
45163: IFFALSE 45167
// exit ;
45165: GO 45254
// result := false ;
45167: LD_ADDR_VAR 0 2
45171: PUSH
45172: LD_INT 0
45174: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
45175: LD_ADDR_VAR 0 5
45179: PUSH
45180: LD_VAR 0 1
45184: PPUSH
45185: LD_INT 21
45187: PUSH
45188: LD_INT 3
45190: PUSH
45191: EMPTY
45192: LIST
45193: LIST
45194: PPUSH
45195: CALL_OW 72
45199: ST_TO_ADDR
// if not tmp then
45200: LD_VAR 0 5
45204: NOT
45205: IFFALSE 45209
// exit ;
45207: GO 45254
// for i in tmp do
45209: LD_ADDR_VAR 0 3
45213: PUSH
45214: LD_VAR 0 5
45218: PUSH
45219: FOR_IN
45220: IFFALSE 45252
// begin result := EnemyInRange ( i , 22 ) ;
45222: LD_ADDR_VAR 0 2
45226: PUSH
45227: LD_VAR 0 3
45231: PPUSH
45232: LD_INT 22
45234: PPUSH
45235: CALL 43490 0 2
45239: ST_TO_ADDR
// if result then
45240: LD_VAR 0 2
45244: IFFALSE 45250
// exit ;
45246: POP
45247: POP
45248: GO 45254
// end ;
45250: GO 45219
45252: POP
45253: POP
// end ;
45254: LD_VAR 0 2
45258: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
45259: LD_INT 0
45261: PPUSH
45262: PPUSH
// if not units then
45263: LD_VAR 0 1
45267: NOT
45268: IFFALSE 45272
// exit ;
45270: GO 45342
// result := [ ] ;
45272: LD_ADDR_VAR 0 3
45276: PUSH
45277: EMPTY
45278: ST_TO_ADDR
// for i in units do
45279: LD_ADDR_VAR 0 4
45283: PUSH
45284: LD_VAR 0 1
45288: PUSH
45289: FOR_IN
45290: IFFALSE 45340
// if GetTag ( i ) = tag then
45292: LD_VAR 0 4
45296: PPUSH
45297: CALL_OW 110
45301: PUSH
45302: LD_VAR 0 2
45306: EQUAL
45307: IFFALSE 45338
// result := Replace ( result , result + 1 , i ) ;
45309: LD_ADDR_VAR 0 3
45313: PUSH
45314: LD_VAR 0 3
45318: PPUSH
45319: LD_VAR 0 3
45323: PUSH
45324: LD_INT 1
45326: PLUS
45327: PPUSH
45328: LD_VAR 0 4
45332: PPUSH
45333: CALL_OW 1
45337: ST_TO_ADDR
45338: GO 45289
45340: POP
45341: POP
// end ;
45342: LD_VAR 0 3
45346: RET
// export function IsDriver ( un ) ; begin
45347: LD_INT 0
45349: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
45350: LD_ADDR_VAR 0 2
45354: PUSH
45355: LD_VAR 0 1
45359: PUSH
45360: LD_INT 55
45362: PUSH
45363: EMPTY
45364: LIST
45365: PPUSH
45366: CALL_OW 69
45370: IN
45371: ST_TO_ADDR
// end ;
45372: LD_VAR 0 2
45376: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
45377: LD_INT 0
45379: PPUSH
45380: PPUSH
// list := [ ] ;
45381: LD_ADDR_VAR 0 5
45385: PUSH
45386: EMPTY
45387: ST_TO_ADDR
// case d of 0 :
45388: LD_VAR 0 3
45392: PUSH
45393: LD_INT 0
45395: DOUBLE
45396: EQUAL
45397: IFTRUE 45401
45399: GO 45534
45401: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
45402: LD_ADDR_VAR 0 5
45406: PUSH
45407: LD_VAR 0 1
45411: PUSH
45412: LD_INT 4
45414: MINUS
45415: PUSH
45416: LD_VAR 0 2
45420: PUSH
45421: LD_INT 4
45423: MINUS
45424: PUSH
45425: LD_INT 2
45427: PUSH
45428: EMPTY
45429: LIST
45430: LIST
45431: LIST
45432: PUSH
45433: LD_VAR 0 1
45437: PUSH
45438: LD_INT 3
45440: MINUS
45441: PUSH
45442: LD_VAR 0 2
45446: PUSH
45447: LD_INT 1
45449: PUSH
45450: EMPTY
45451: LIST
45452: LIST
45453: LIST
45454: PUSH
45455: LD_VAR 0 1
45459: PUSH
45460: LD_INT 4
45462: PLUS
45463: PUSH
45464: LD_VAR 0 2
45468: PUSH
45469: LD_INT 4
45471: PUSH
45472: EMPTY
45473: LIST
45474: LIST
45475: LIST
45476: PUSH
45477: LD_VAR 0 1
45481: PUSH
45482: LD_INT 3
45484: PLUS
45485: PUSH
45486: LD_VAR 0 2
45490: PUSH
45491: LD_INT 3
45493: PLUS
45494: PUSH
45495: LD_INT 5
45497: PUSH
45498: EMPTY
45499: LIST
45500: LIST
45501: LIST
45502: PUSH
45503: LD_VAR 0 1
45507: PUSH
45508: LD_VAR 0 2
45512: PUSH
45513: LD_INT 4
45515: PLUS
45516: PUSH
45517: LD_INT 0
45519: PUSH
45520: EMPTY
45521: LIST
45522: LIST
45523: LIST
45524: PUSH
45525: EMPTY
45526: LIST
45527: LIST
45528: LIST
45529: LIST
45530: LIST
45531: ST_TO_ADDR
// end ; 1 :
45532: GO 46232
45534: LD_INT 1
45536: DOUBLE
45537: EQUAL
45538: IFTRUE 45542
45540: GO 45675
45542: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
45543: LD_ADDR_VAR 0 5
45547: PUSH
45548: LD_VAR 0 1
45552: PUSH
45553: LD_VAR 0 2
45557: PUSH
45558: LD_INT 4
45560: MINUS
45561: PUSH
45562: LD_INT 3
45564: PUSH
45565: EMPTY
45566: LIST
45567: LIST
45568: LIST
45569: PUSH
45570: LD_VAR 0 1
45574: PUSH
45575: LD_INT 3
45577: MINUS
45578: PUSH
45579: LD_VAR 0 2
45583: PUSH
45584: LD_INT 3
45586: MINUS
45587: PUSH
45588: LD_INT 2
45590: PUSH
45591: EMPTY
45592: LIST
45593: LIST
45594: LIST
45595: PUSH
45596: LD_VAR 0 1
45600: PUSH
45601: LD_INT 4
45603: MINUS
45604: PUSH
45605: LD_VAR 0 2
45609: PUSH
45610: LD_INT 1
45612: PUSH
45613: EMPTY
45614: LIST
45615: LIST
45616: LIST
45617: PUSH
45618: LD_VAR 0 1
45622: PUSH
45623: LD_VAR 0 2
45627: PUSH
45628: LD_INT 3
45630: PLUS
45631: PUSH
45632: LD_INT 0
45634: PUSH
45635: EMPTY
45636: LIST
45637: LIST
45638: LIST
45639: PUSH
45640: LD_VAR 0 1
45644: PUSH
45645: LD_INT 4
45647: PLUS
45648: PUSH
45649: LD_VAR 0 2
45653: PUSH
45654: LD_INT 4
45656: PLUS
45657: PUSH
45658: LD_INT 5
45660: PUSH
45661: EMPTY
45662: LIST
45663: LIST
45664: LIST
45665: PUSH
45666: EMPTY
45667: LIST
45668: LIST
45669: LIST
45670: LIST
45671: LIST
45672: ST_TO_ADDR
// end ; 2 :
45673: GO 46232
45675: LD_INT 2
45677: DOUBLE
45678: EQUAL
45679: IFTRUE 45683
45681: GO 45812
45683: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
45684: LD_ADDR_VAR 0 5
45688: PUSH
45689: LD_VAR 0 1
45693: PUSH
45694: LD_VAR 0 2
45698: PUSH
45699: LD_INT 3
45701: MINUS
45702: PUSH
45703: LD_INT 3
45705: PUSH
45706: EMPTY
45707: LIST
45708: LIST
45709: LIST
45710: PUSH
45711: LD_VAR 0 1
45715: PUSH
45716: LD_INT 4
45718: PLUS
45719: PUSH
45720: LD_VAR 0 2
45724: PUSH
45725: LD_INT 4
45727: PUSH
45728: EMPTY
45729: LIST
45730: LIST
45731: LIST
45732: PUSH
45733: LD_VAR 0 1
45737: PUSH
45738: LD_VAR 0 2
45742: PUSH
45743: LD_INT 4
45745: PLUS
45746: PUSH
45747: LD_INT 0
45749: PUSH
45750: EMPTY
45751: LIST
45752: LIST
45753: LIST
45754: PUSH
45755: LD_VAR 0 1
45759: PUSH
45760: LD_INT 3
45762: MINUS
45763: PUSH
45764: LD_VAR 0 2
45768: PUSH
45769: LD_INT 1
45771: PUSH
45772: EMPTY
45773: LIST
45774: LIST
45775: LIST
45776: PUSH
45777: LD_VAR 0 1
45781: PUSH
45782: LD_INT 4
45784: MINUS
45785: PUSH
45786: LD_VAR 0 2
45790: PUSH
45791: LD_INT 4
45793: MINUS
45794: PUSH
45795: LD_INT 2
45797: PUSH
45798: EMPTY
45799: LIST
45800: LIST
45801: LIST
45802: PUSH
45803: EMPTY
45804: LIST
45805: LIST
45806: LIST
45807: LIST
45808: LIST
45809: ST_TO_ADDR
// end ; 3 :
45810: GO 46232
45812: LD_INT 3
45814: DOUBLE
45815: EQUAL
45816: IFTRUE 45820
45818: GO 45953
45820: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
45821: LD_ADDR_VAR 0 5
45825: PUSH
45826: LD_VAR 0 1
45830: PUSH
45831: LD_INT 3
45833: PLUS
45834: PUSH
45835: LD_VAR 0 2
45839: PUSH
45840: LD_INT 4
45842: PUSH
45843: EMPTY
45844: LIST
45845: LIST
45846: LIST
45847: PUSH
45848: LD_VAR 0 1
45852: PUSH
45853: LD_INT 4
45855: PLUS
45856: PUSH
45857: LD_VAR 0 2
45861: PUSH
45862: LD_INT 4
45864: PLUS
45865: PUSH
45866: LD_INT 5
45868: PUSH
45869: EMPTY
45870: LIST
45871: LIST
45872: LIST
45873: PUSH
45874: LD_VAR 0 1
45878: PUSH
45879: LD_INT 4
45881: MINUS
45882: PUSH
45883: LD_VAR 0 2
45887: PUSH
45888: LD_INT 1
45890: PUSH
45891: EMPTY
45892: LIST
45893: LIST
45894: LIST
45895: PUSH
45896: LD_VAR 0 1
45900: PUSH
45901: LD_VAR 0 2
45905: PUSH
45906: LD_INT 4
45908: MINUS
45909: PUSH
45910: LD_INT 3
45912: PUSH
45913: EMPTY
45914: LIST
45915: LIST
45916: LIST
45917: PUSH
45918: LD_VAR 0 1
45922: PUSH
45923: LD_INT 3
45925: MINUS
45926: PUSH
45927: LD_VAR 0 2
45931: PUSH
45932: LD_INT 3
45934: MINUS
45935: PUSH
45936: LD_INT 2
45938: PUSH
45939: EMPTY
45940: LIST
45941: LIST
45942: LIST
45943: PUSH
45944: EMPTY
45945: LIST
45946: LIST
45947: LIST
45948: LIST
45949: LIST
45950: ST_TO_ADDR
// end ; 4 :
45951: GO 46232
45953: LD_INT 4
45955: DOUBLE
45956: EQUAL
45957: IFTRUE 45961
45959: GO 46094
45961: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
45962: LD_ADDR_VAR 0 5
45966: PUSH
45967: LD_VAR 0 1
45971: PUSH
45972: LD_VAR 0 2
45976: PUSH
45977: LD_INT 4
45979: PLUS
45980: PUSH
45981: LD_INT 0
45983: PUSH
45984: EMPTY
45985: LIST
45986: LIST
45987: LIST
45988: PUSH
45989: LD_VAR 0 1
45993: PUSH
45994: LD_INT 3
45996: PLUS
45997: PUSH
45998: LD_VAR 0 2
46002: PUSH
46003: LD_INT 3
46005: PLUS
46006: PUSH
46007: LD_INT 5
46009: PUSH
46010: EMPTY
46011: LIST
46012: LIST
46013: LIST
46014: PUSH
46015: LD_VAR 0 1
46019: PUSH
46020: LD_INT 4
46022: PLUS
46023: PUSH
46024: LD_VAR 0 2
46028: PUSH
46029: LD_INT 4
46031: PUSH
46032: EMPTY
46033: LIST
46034: LIST
46035: LIST
46036: PUSH
46037: LD_VAR 0 1
46041: PUSH
46042: LD_VAR 0 2
46046: PUSH
46047: LD_INT 3
46049: MINUS
46050: PUSH
46051: LD_INT 3
46053: PUSH
46054: EMPTY
46055: LIST
46056: LIST
46057: LIST
46058: PUSH
46059: LD_VAR 0 1
46063: PUSH
46064: LD_INT 4
46066: MINUS
46067: PUSH
46068: LD_VAR 0 2
46072: PUSH
46073: LD_INT 4
46075: MINUS
46076: PUSH
46077: LD_INT 2
46079: PUSH
46080: EMPTY
46081: LIST
46082: LIST
46083: LIST
46084: PUSH
46085: EMPTY
46086: LIST
46087: LIST
46088: LIST
46089: LIST
46090: LIST
46091: ST_TO_ADDR
// end ; 5 :
46092: GO 46232
46094: LD_INT 5
46096: DOUBLE
46097: EQUAL
46098: IFTRUE 46102
46100: GO 46231
46102: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
46103: LD_ADDR_VAR 0 5
46107: PUSH
46108: LD_VAR 0 1
46112: PUSH
46113: LD_INT 4
46115: MINUS
46116: PUSH
46117: LD_VAR 0 2
46121: PUSH
46122: LD_INT 1
46124: PUSH
46125: EMPTY
46126: LIST
46127: LIST
46128: LIST
46129: PUSH
46130: LD_VAR 0 1
46134: PUSH
46135: LD_VAR 0 2
46139: PUSH
46140: LD_INT 4
46142: MINUS
46143: PUSH
46144: LD_INT 3
46146: PUSH
46147: EMPTY
46148: LIST
46149: LIST
46150: LIST
46151: PUSH
46152: LD_VAR 0 1
46156: PUSH
46157: LD_INT 4
46159: PLUS
46160: PUSH
46161: LD_VAR 0 2
46165: PUSH
46166: LD_INT 4
46168: PLUS
46169: PUSH
46170: LD_INT 5
46172: PUSH
46173: EMPTY
46174: LIST
46175: LIST
46176: LIST
46177: PUSH
46178: LD_VAR 0 1
46182: PUSH
46183: LD_INT 3
46185: PLUS
46186: PUSH
46187: LD_VAR 0 2
46191: PUSH
46192: LD_INT 4
46194: PUSH
46195: EMPTY
46196: LIST
46197: LIST
46198: LIST
46199: PUSH
46200: LD_VAR 0 1
46204: PUSH
46205: LD_VAR 0 2
46209: PUSH
46210: LD_INT 3
46212: PLUS
46213: PUSH
46214: LD_INT 0
46216: PUSH
46217: EMPTY
46218: LIST
46219: LIST
46220: LIST
46221: PUSH
46222: EMPTY
46223: LIST
46224: LIST
46225: LIST
46226: LIST
46227: LIST
46228: ST_TO_ADDR
// end ; end ;
46229: GO 46232
46231: POP
// result := list ;
46232: LD_ADDR_VAR 0 4
46236: PUSH
46237: LD_VAR 0 5
46241: ST_TO_ADDR
// end ;
46242: LD_VAR 0 4
46246: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
46247: LD_INT 0
46249: PPUSH
46250: PPUSH
46251: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
46252: LD_VAR 0 1
46256: NOT
46257: PUSH
46258: LD_VAR 0 2
46262: PUSH
46263: LD_INT 1
46265: PUSH
46266: LD_INT 2
46268: PUSH
46269: LD_INT 3
46271: PUSH
46272: LD_INT 4
46274: PUSH
46275: EMPTY
46276: LIST
46277: LIST
46278: LIST
46279: LIST
46280: IN
46281: NOT
46282: OR
46283: IFFALSE 46287
// exit ;
46285: GO 46379
// tmp := [ ] ;
46287: LD_ADDR_VAR 0 5
46291: PUSH
46292: EMPTY
46293: ST_TO_ADDR
// for i in units do
46294: LD_ADDR_VAR 0 4
46298: PUSH
46299: LD_VAR 0 1
46303: PUSH
46304: FOR_IN
46305: IFFALSE 46348
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
46307: LD_ADDR_VAR 0 5
46311: PUSH
46312: LD_VAR 0 5
46316: PPUSH
46317: LD_VAR 0 5
46321: PUSH
46322: LD_INT 1
46324: PLUS
46325: PPUSH
46326: LD_VAR 0 4
46330: PPUSH
46331: LD_VAR 0 2
46335: PPUSH
46336: CALL_OW 259
46340: PPUSH
46341: CALL_OW 2
46345: ST_TO_ADDR
46346: GO 46304
46348: POP
46349: POP
// if not tmp then
46350: LD_VAR 0 5
46354: NOT
46355: IFFALSE 46359
// exit ;
46357: GO 46379
// result := SortListByListDesc ( units , tmp ) ;
46359: LD_ADDR_VAR 0 3
46363: PUSH
46364: LD_VAR 0 1
46368: PPUSH
46369: LD_VAR 0 5
46373: PPUSH
46374: CALL_OW 77
46378: ST_TO_ADDR
// end ;
46379: LD_VAR 0 3
46383: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
46384: LD_INT 0
46386: PPUSH
46387: PPUSH
46388: PPUSH
// result := false ;
46389: LD_ADDR_VAR 0 3
46393: PUSH
46394: LD_INT 0
46396: ST_TO_ADDR
// x := GetX ( building ) ;
46397: LD_ADDR_VAR 0 4
46401: PUSH
46402: LD_VAR 0 2
46406: PPUSH
46407: CALL_OW 250
46411: ST_TO_ADDR
// y := GetY ( building ) ;
46412: LD_ADDR_VAR 0 5
46416: PUSH
46417: LD_VAR 0 2
46421: PPUSH
46422: CALL_OW 251
46426: ST_TO_ADDR
// if not building or not x or not y then
46427: LD_VAR 0 2
46431: NOT
46432: PUSH
46433: LD_VAR 0 4
46437: NOT
46438: OR
46439: PUSH
46440: LD_VAR 0 5
46444: NOT
46445: OR
46446: IFFALSE 46450
// exit ;
46448: GO 46542
// if GetTaskList ( unit ) then
46450: LD_VAR 0 1
46454: PPUSH
46455: CALL_OW 437
46459: IFFALSE 46542
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
46461: LD_STRING e
46463: PUSH
46464: LD_VAR 0 1
46468: PPUSH
46469: CALL_OW 437
46473: PUSH
46474: LD_INT 1
46476: ARRAY
46477: PUSH
46478: LD_INT 1
46480: ARRAY
46481: EQUAL
46482: PUSH
46483: LD_VAR 0 4
46487: PUSH
46488: LD_VAR 0 1
46492: PPUSH
46493: CALL_OW 437
46497: PUSH
46498: LD_INT 1
46500: ARRAY
46501: PUSH
46502: LD_INT 2
46504: ARRAY
46505: EQUAL
46506: AND
46507: PUSH
46508: LD_VAR 0 5
46512: PUSH
46513: LD_VAR 0 1
46517: PPUSH
46518: CALL_OW 437
46522: PUSH
46523: LD_INT 1
46525: ARRAY
46526: PUSH
46527: LD_INT 3
46529: ARRAY
46530: EQUAL
46531: AND
46532: IFFALSE 46542
// result := true end ;
46534: LD_ADDR_VAR 0 3
46538: PUSH
46539: LD_INT 1
46541: ST_TO_ADDR
// end ;
46542: LD_VAR 0 3
46546: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
46547: LD_INT 0
46549: PPUSH
// result := false ;
46550: LD_ADDR_VAR 0 4
46554: PUSH
46555: LD_INT 0
46557: ST_TO_ADDR
// if GetTaskList ( unit ) then
46558: LD_VAR 0 1
46562: PPUSH
46563: CALL_OW 437
46567: IFFALSE 46650
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
46569: LD_STRING M
46571: PUSH
46572: LD_VAR 0 1
46576: PPUSH
46577: CALL_OW 437
46581: PUSH
46582: LD_INT 1
46584: ARRAY
46585: PUSH
46586: LD_INT 1
46588: ARRAY
46589: EQUAL
46590: PUSH
46591: LD_VAR 0 2
46595: PUSH
46596: LD_VAR 0 1
46600: PPUSH
46601: CALL_OW 437
46605: PUSH
46606: LD_INT 1
46608: ARRAY
46609: PUSH
46610: LD_INT 2
46612: ARRAY
46613: EQUAL
46614: AND
46615: PUSH
46616: LD_VAR 0 3
46620: PUSH
46621: LD_VAR 0 1
46625: PPUSH
46626: CALL_OW 437
46630: PUSH
46631: LD_INT 1
46633: ARRAY
46634: PUSH
46635: LD_INT 3
46637: ARRAY
46638: EQUAL
46639: AND
46640: IFFALSE 46650
// result := true ;
46642: LD_ADDR_VAR 0 4
46646: PUSH
46647: LD_INT 1
46649: ST_TO_ADDR
// end ; end ;
46650: LD_VAR 0 4
46654: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
46655: LD_INT 0
46657: PPUSH
46658: PPUSH
46659: PPUSH
46660: PPUSH
// if not unit or not area then
46661: LD_VAR 0 1
46665: NOT
46666: PUSH
46667: LD_VAR 0 2
46671: NOT
46672: OR
46673: IFFALSE 46677
// exit ;
46675: GO 46841
// tmp := AreaToList ( area , i ) ;
46677: LD_ADDR_VAR 0 6
46681: PUSH
46682: LD_VAR 0 2
46686: PPUSH
46687: LD_VAR 0 5
46691: PPUSH
46692: CALL_OW 517
46696: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
46697: LD_ADDR_VAR 0 5
46701: PUSH
46702: DOUBLE
46703: LD_INT 1
46705: DEC
46706: ST_TO_ADDR
46707: LD_VAR 0 6
46711: PUSH
46712: LD_INT 1
46714: ARRAY
46715: PUSH
46716: FOR_TO
46717: IFFALSE 46839
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
46719: LD_ADDR_VAR 0 7
46723: PUSH
46724: LD_VAR 0 6
46728: PUSH
46729: LD_INT 1
46731: ARRAY
46732: PUSH
46733: LD_VAR 0 5
46737: ARRAY
46738: PUSH
46739: LD_VAR 0 6
46743: PUSH
46744: LD_INT 2
46746: ARRAY
46747: PUSH
46748: LD_VAR 0 5
46752: ARRAY
46753: PUSH
46754: EMPTY
46755: LIST
46756: LIST
46757: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
46758: LD_VAR 0 7
46762: PUSH
46763: LD_INT 1
46765: ARRAY
46766: PPUSH
46767: LD_VAR 0 7
46771: PUSH
46772: LD_INT 2
46774: ARRAY
46775: PPUSH
46776: CALL_OW 428
46780: PUSH
46781: LD_INT 0
46783: EQUAL
46784: IFFALSE 46837
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
46786: LD_VAR 0 1
46790: PPUSH
46791: LD_VAR 0 7
46795: PUSH
46796: LD_INT 1
46798: ARRAY
46799: PPUSH
46800: LD_VAR 0 7
46804: PUSH
46805: LD_INT 2
46807: ARRAY
46808: PPUSH
46809: LD_VAR 0 3
46813: PPUSH
46814: CALL_OW 48
// result := IsPlaced ( unit ) ;
46818: LD_ADDR_VAR 0 4
46822: PUSH
46823: LD_VAR 0 1
46827: PPUSH
46828: CALL_OW 305
46832: ST_TO_ADDR
// exit ;
46833: POP
46834: POP
46835: GO 46841
// end ; end ;
46837: GO 46716
46839: POP
46840: POP
// end ;
46841: LD_VAR 0 4
46845: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
46846: LD_INT 0
46848: PPUSH
46849: PPUSH
46850: PPUSH
// if not side or side > 8 then
46851: LD_VAR 0 1
46855: NOT
46856: PUSH
46857: LD_VAR 0 1
46861: PUSH
46862: LD_INT 8
46864: GREATER
46865: OR
46866: IFFALSE 46870
// exit ;
46868: GO 47057
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
46870: LD_ADDR_VAR 0 4
46874: PUSH
46875: LD_INT 22
46877: PUSH
46878: LD_VAR 0 1
46882: PUSH
46883: EMPTY
46884: LIST
46885: LIST
46886: PUSH
46887: LD_INT 21
46889: PUSH
46890: LD_INT 3
46892: PUSH
46893: EMPTY
46894: LIST
46895: LIST
46896: PUSH
46897: EMPTY
46898: LIST
46899: LIST
46900: PPUSH
46901: CALL_OW 69
46905: ST_TO_ADDR
// if not tmp then
46906: LD_VAR 0 4
46910: NOT
46911: IFFALSE 46915
// exit ;
46913: GO 47057
// enable_addtolog := true ;
46915: LD_ADDR_OWVAR 81
46919: PUSH
46920: LD_INT 1
46922: ST_TO_ADDR
// AddToLog ( [ ) ;
46923: LD_STRING [
46925: PPUSH
46926: CALL_OW 561
// for i in tmp do
46930: LD_ADDR_VAR 0 3
46934: PUSH
46935: LD_VAR 0 4
46939: PUSH
46940: FOR_IN
46941: IFFALSE 47048
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
46943: LD_STRING [
46945: PUSH
46946: LD_VAR 0 3
46950: PPUSH
46951: CALL_OW 266
46955: STR
46956: PUSH
46957: LD_STRING , 
46959: STR
46960: PUSH
46961: LD_VAR 0 3
46965: PPUSH
46966: CALL_OW 250
46970: STR
46971: PUSH
46972: LD_STRING , 
46974: STR
46975: PUSH
46976: LD_VAR 0 3
46980: PPUSH
46981: CALL_OW 251
46985: STR
46986: PUSH
46987: LD_STRING , 
46989: STR
46990: PUSH
46991: LD_VAR 0 3
46995: PPUSH
46996: CALL_OW 254
47000: STR
47001: PUSH
47002: LD_STRING , 
47004: STR
47005: PUSH
47006: LD_VAR 0 3
47010: PPUSH
47011: LD_INT 1
47013: PPUSH
47014: CALL_OW 268
47018: STR
47019: PUSH
47020: LD_STRING , 
47022: STR
47023: PUSH
47024: LD_VAR 0 3
47028: PPUSH
47029: LD_INT 2
47031: PPUSH
47032: CALL_OW 268
47036: STR
47037: PUSH
47038: LD_STRING ],
47040: STR
47041: PPUSH
47042: CALL_OW 561
// end ;
47046: GO 46940
47048: POP
47049: POP
// AddToLog ( ]; ) ;
47050: LD_STRING ];
47052: PPUSH
47053: CALL_OW 561
// end ;
47057: LD_VAR 0 2
47061: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
47062: LD_INT 0
47064: PPUSH
47065: PPUSH
47066: PPUSH
47067: PPUSH
47068: PPUSH
// if not area or not rate or not max then
47069: LD_VAR 0 1
47073: NOT
47074: PUSH
47075: LD_VAR 0 2
47079: NOT
47080: OR
47081: PUSH
47082: LD_VAR 0 4
47086: NOT
47087: OR
47088: IFFALSE 47092
// exit ;
47090: GO 47284
// while 1 do
47092: LD_INT 1
47094: IFFALSE 47284
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
47096: LD_ADDR_VAR 0 9
47100: PUSH
47101: LD_VAR 0 1
47105: PPUSH
47106: LD_INT 1
47108: PPUSH
47109: CALL_OW 287
47113: PUSH
47114: LD_INT 10
47116: MUL
47117: ST_TO_ADDR
// r := rate / 10 ;
47118: LD_ADDR_VAR 0 7
47122: PUSH
47123: LD_VAR 0 2
47127: PUSH
47128: LD_INT 10
47130: DIVREAL
47131: ST_TO_ADDR
// time := 1 1$00 ;
47132: LD_ADDR_VAR 0 8
47136: PUSH
47137: LD_INT 2100
47139: ST_TO_ADDR
// if amount < min then
47140: LD_VAR 0 9
47144: PUSH
47145: LD_VAR 0 3
47149: LESS
47150: IFFALSE 47168
// r := r * 2 else
47152: LD_ADDR_VAR 0 7
47156: PUSH
47157: LD_VAR 0 7
47161: PUSH
47162: LD_INT 2
47164: MUL
47165: ST_TO_ADDR
47166: GO 47194
// if amount > max then
47168: LD_VAR 0 9
47172: PUSH
47173: LD_VAR 0 4
47177: GREATER
47178: IFFALSE 47194
// r := r / 2 ;
47180: LD_ADDR_VAR 0 7
47184: PUSH
47185: LD_VAR 0 7
47189: PUSH
47190: LD_INT 2
47192: DIVREAL
47193: ST_TO_ADDR
// time := time / r ;
47194: LD_ADDR_VAR 0 8
47198: PUSH
47199: LD_VAR 0 8
47203: PUSH
47204: LD_VAR 0 7
47208: DIVREAL
47209: ST_TO_ADDR
// if time < 0 then
47210: LD_VAR 0 8
47214: PUSH
47215: LD_INT 0
47217: LESS
47218: IFFALSE 47235
// time := time * - 1 ;
47220: LD_ADDR_VAR 0 8
47224: PUSH
47225: LD_VAR 0 8
47229: PUSH
47230: LD_INT 1
47232: NEG
47233: MUL
47234: ST_TO_ADDR
// wait ( time ) ;
47235: LD_VAR 0 8
47239: PPUSH
47240: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
47244: LD_INT 35
47246: PPUSH
47247: LD_INT 875
47249: PPUSH
47250: CALL_OW 12
47254: PPUSH
47255: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
47259: LD_INT 1
47261: PPUSH
47262: LD_INT 5
47264: PPUSH
47265: CALL_OW 12
47269: PPUSH
47270: LD_VAR 0 1
47274: PPUSH
47275: LD_INT 1
47277: PPUSH
47278: CALL_OW 55
// end ;
47282: GO 47092
// end ;
47284: LD_VAR 0 5
47288: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
47289: LD_INT 0
47291: PPUSH
47292: PPUSH
47293: PPUSH
47294: PPUSH
47295: PPUSH
47296: PPUSH
47297: PPUSH
47298: PPUSH
// if not turrets or not factories then
47299: LD_VAR 0 1
47303: NOT
47304: PUSH
47305: LD_VAR 0 2
47309: NOT
47310: OR
47311: IFFALSE 47315
// exit ;
47313: GO 47622
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
47315: LD_ADDR_VAR 0 10
47319: PUSH
47320: LD_INT 5
47322: PUSH
47323: LD_INT 6
47325: PUSH
47326: EMPTY
47327: LIST
47328: LIST
47329: PUSH
47330: LD_INT 2
47332: PUSH
47333: LD_INT 4
47335: PUSH
47336: EMPTY
47337: LIST
47338: LIST
47339: PUSH
47340: LD_INT 3
47342: PUSH
47343: LD_INT 5
47345: PUSH
47346: EMPTY
47347: LIST
47348: LIST
47349: PUSH
47350: EMPTY
47351: LIST
47352: LIST
47353: LIST
47354: PUSH
47355: LD_INT 24
47357: PUSH
47358: LD_INT 25
47360: PUSH
47361: EMPTY
47362: LIST
47363: LIST
47364: PUSH
47365: LD_INT 23
47367: PUSH
47368: LD_INT 27
47370: PUSH
47371: EMPTY
47372: LIST
47373: LIST
47374: PUSH
47375: EMPTY
47376: LIST
47377: LIST
47378: PUSH
47379: LD_INT 42
47381: PUSH
47382: LD_INT 43
47384: PUSH
47385: EMPTY
47386: LIST
47387: LIST
47388: PUSH
47389: LD_INT 44
47391: PUSH
47392: LD_INT 46
47394: PUSH
47395: EMPTY
47396: LIST
47397: LIST
47398: PUSH
47399: LD_INT 45
47401: PUSH
47402: LD_INT 47
47404: PUSH
47405: EMPTY
47406: LIST
47407: LIST
47408: PUSH
47409: EMPTY
47410: LIST
47411: LIST
47412: LIST
47413: PUSH
47414: EMPTY
47415: LIST
47416: LIST
47417: LIST
47418: ST_TO_ADDR
// result := [ ] ;
47419: LD_ADDR_VAR 0 3
47423: PUSH
47424: EMPTY
47425: ST_TO_ADDR
// for i in turrets do
47426: LD_ADDR_VAR 0 4
47430: PUSH
47431: LD_VAR 0 1
47435: PUSH
47436: FOR_IN
47437: IFFALSE 47620
// begin nat := GetNation ( i ) ;
47439: LD_ADDR_VAR 0 7
47443: PUSH
47444: LD_VAR 0 4
47448: PPUSH
47449: CALL_OW 248
47453: ST_TO_ADDR
// weapon := 0 ;
47454: LD_ADDR_VAR 0 8
47458: PUSH
47459: LD_INT 0
47461: ST_TO_ADDR
// if not nat then
47462: LD_VAR 0 7
47466: NOT
47467: IFFALSE 47471
// continue ;
47469: GO 47436
// for j in list [ nat ] do
47471: LD_ADDR_VAR 0 5
47475: PUSH
47476: LD_VAR 0 10
47480: PUSH
47481: LD_VAR 0 7
47485: ARRAY
47486: PUSH
47487: FOR_IN
47488: IFFALSE 47529
// if GetBWeapon ( i ) = j [ 1 ] then
47490: LD_VAR 0 4
47494: PPUSH
47495: CALL_OW 269
47499: PUSH
47500: LD_VAR 0 5
47504: PUSH
47505: LD_INT 1
47507: ARRAY
47508: EQUAL
47509: IFFALSE 47527
// begin weapon := j [ 2 ] ;
47511: LD_ADDR_VAR 0 8
47515: PUSH
47516: LD_VAR 0 5
47520: PUSH
47521: LD_INT 2
47523: ARRAY
47524: ST_TO_ADDR
// break ;
47525: GO 47529
// end ;
47527: GO 47487
47529: POP
47530: POP
// if not weapon then
47531: LD_VAR 0 8
47535: NOT
47536: IFFALSE 47540
// continue ;
47538: GO 47436
// for k in factories do
47540: LD_ADDR_VAR 0 6
47544: PUSH
47545: LD_VAR 0 2
47549: PUSH
47550: FOR_IN
47551: IFFALSE 47616
// begin weapons := AvailableWeaponList ( k ) ;
47553: LD_ADDR_VAR 0 9
47557: PUSH
47558: LD_VAR 0 6
47562: PPUSH
47563: CALL_OW 478
47567: ST_TO_ADDR
// if not weapons then
47568: LD_VAR 0 9
47572: NOT
47573: IFFALSE 47577
// continue ;
47575: GO 47550
// if weapon in weapons then
47577: LD_VAR 0 8
47581: PUSH
47582: LD_VAR 0 9
47586: IN
47587: IFFALSE 47614
// begin result := [ i , weapon ] ;
47589: LD_ADDR_VAR 0 3
47593: PUSH
47594: LD_VAR 0 4
47598: PUSH
47599: LD_VAR 0 8
47603: PUSH
47604: EMPTY
47605: LIST
47606: LIST
47607: ST_TO_ADDR
// exit ;
47608: POP
47609: POP
47610: POP
47611: POP
47612: GO 47622
// end ; end ;
47614: GO 47550
47616: POP
47617: POP
// end ;
47618: GO 47436
47620: POP
47621: POP
// end ;
47622: LD_VAR 0 3
47626: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
47627: LD_INT 0
47629: PPUSH
// if not side or side > 8 then
47630: LD_VAR 0 3
47634: NOT
47635: PUSH
47636: LD_VAR 0 3
47640: PUSH
47641: LD_INT 8
47643: GREATER
47644: OR
47645: IFFALSE 47649
// exit ;
47647: GO 47708
// if not range then
47649: LD_VAR 0 4
47653: NOT
47654: IFFALSE 47665
// range := - 12 ;
47656: LD_ADDR_VAR 0 4
47660: PUSH
47661: LD_INT 12
47663: NEG
47664: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
47665: LD_VAR 0 1
47669: PPUSH
47670: LD_VAR 0 2
47674: PPUSH
47675: LD_VAR 0 3
47679: PPUSH
47680: LD_VAR 0 4
47684: PPUSH
47685: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
47689: LD_VAR 0 1
47693: PPUSH
47694: LD_VAR 0 2
47698: PPUSH
47699: LD_VAR 0 3
47703: PPUSH
47704: CALL_OW 331
// end ;
47708: LD_VAR 0 5
47712: RET
// export function Video ( mode ) ; begin
47713: LD_INT 0
47715: PPUSH
// ingame_video = mode ;
47716: LD_ADDR_OWVAR 52
47720: PUSH
47721: LD_VAR 0 1
47725: ST_TO_ADDR
// interface_hidden = mode ;
47726: LD_ADDR_OWVAR 54
47730: PUSH
47731: LD_VAR 0 1
47735: ST_TO_ADDR
// end ;
47736: LD_VAR 0 2
47740: RET
// export function Join ( array , element ) ; begin
47741: LD_INT 0
47743: PPUSH
// result := Replace ( array , array + 1 , element ) ;
47744: LD_ADDR_VAR 0 3
47748: PUSH
47749: LD_VAR 0 1
47753: PPUSH
47754: LD_VAR 0 1
47758: PUSH
47759: LD_INT 1
47761: PLUS
47762: PPUSH
47763: LD_VAR 0 2
47767: PPUSH
47768: CALL_OW 1
47772: ST_TO_ADDR
// end ;
47773: LD_VAR 0 3
47777: RET
// export function JoinUnion ( array , element ) ; begin
47778: LD_INT 0
47780: PPUSH
// result := array union element ;
47781: LD_ADDR_VAR 0 3
47785: PUSH
47786: LD_VAR 0 1
47790: PUSH
47791: LD_VAR 0 2
47795: UNION
47796: ST_TO_ADDR
// end ;
47797: LD_VAR 0 3
47801: RET
// export function GetBehemoths ( side ) ; begin
47802: LD_INT 0
47804: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
47805: LD_ADDR_VAR 0 2
47809: PUSH
47810: LD_INT 22
47812: PUSH
47813: LD_VAR 0 1
47817: PUSH
47818: EMPTY
47819: LIST
47820: LIST
47821: PUSH
47822: LD_INT 31
47824: PUSH
47825: LD_INT 25
47827: PUSH
47828: EMPTY
47829: LIST
47830: LIST
47831: PUSH
47832: EMPTY
47833: LIST
47834: LIST
47835: PPUSH
47836: CALL_OW 69
47840: ST_TO_ADDR
// end ;
47841: LD_VAR 0 2
47845: RET
// export function Shuffle ( array ) ; var i , index ; begin
47846: LD_INT 0
47848: PPUSH
47849: PPUSH
47850: PPUSH
// result := [ ] ;
47851: LD_ADDR_VAR 0 2
47855: PUSH
47856: EMPTY
47857: ST_TO_ADDR
// if not array then
47858: LD_VAR 0 1
47862: NOT
47863: IFFALSE 47867
// exit ;
47865: GO 47966
// Randomize ;
47867: CALL_OW 10
// for i = array downto 1 do
47871: LD_ADDR_VAR 0 3
47875: PUSH
47876: DOUBLE
47877: LD_VAR 0 1
47881: INC
47882: ST_TO_ADDR
47883: LD_INT 1
47885: PUSH
47886: FOR_DOWNTO
47887: IFFALSE 47964
// begin index := rand ( 1 , array ) ;
47889: LD_ADDR_VAR 0 4
47893: PUSH
47894: LD_INT 1
47896: PPUSH
47897: LD_VAR 0 1
47901: PPUSH
47902: CALL_OW 12
47906: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
47907: LD_ADDR_VAR 0 2
47911: PUSH
47912: LD_VAR 0 2
47916: PPUSH
47917: LD_VAR 0 2
47921: PUSH
47922: LD_INT 1
47924: PLUS
47925: PPUSH
47926: LD_VAR 0 1
47930: PUSH
47931: LD_VAR 0 4
47935: ARRAY
47936: PPUSH
47937: CALL_OW 2
47941: ST_TO_ADDR
// array := Delete ( array , index ) ;
47942: LD_ADDR_VAR 0 1
47946: PUSH
47947: LD_VAR 0 1
47951: PPUSH
47952: LD_VAR 0 4
47956: PPUSH
47957: CALL_OW 3
47961: ST_TO_ADDR
// end ;
47962: GO 47886
47964: POP
47965: POP
// end ;
47966: LD_VAR 0 2
47970: RET
// export function GetBaseMaterials ( base ) ; begin
47971: LD_INT 0
47973: PPUSH
// result := [ 0 , 0 , 0 ] ;
47974: LD_ADDR_VAR 0 2
47978: PUSH
47979: LD_INT 0
47981: PUSH
47982: LD_INT 0
47984: PUSH
47985: LD_INT 0
47987: PUSH
47988: EMPTY
47989: LIST
47990: LIST
47991: LIST
47992: ST_TO_ADDR
// if not base then
47993: LD_VAR 0 1
47997: NOT
47998: IFFALSE 48002
// exit ;
48000: GO 48051
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
48002: LD_ADDR_VAR 0 2
48006: PUSH
48007: LD_VAR 0 1
48011: PPUSH
48012: LD_INT 1
48014: PPUSH
48015: CALL_OW 275
48019: PUSH
48020: LD_VAR 0 1
48024: PPUSH
48025: LD_INT 2
48027: PPUSH
48028: CALL_OW 275
48032: PUSH
48033: LD_VAR 0 1
48037: PPUSH
48038: LD_INT 3
48040: PPUSH
48041: CALL_OW 275
48045: PUSH
48046: EMPTY
48047: LIST
48048: LIST
48049: LIST
48050: ST_TO_ADDR
// end ;
48051: LD_VAR 0 2
48055: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
48056: LD_INT 0
48058: PPUSH
48059: PPUSH
// result := array ;
48060: LD_ADDR_VAR 0 3
48064: PUSH
48065: LD_VAR 0 1
48069: ST_TO_ADDR
// if size > 0 then
48070: LD_VAR 0 2
48074: PUSH
48075: LD_INT 0
48077: GREATER
48078: IFFALSE 48124
// for i := array downto size do
48080: LD_ADDR_VAR 0 4
48084: PUSH
48085: DOUBLE
48086: LD_VAR 0 1
48090: INC
48091: ST_TO_ADDR
48092: LD_VAR 0 2
48096: PUSH
48097: FOR_DOWNTO
48098: IFFALSE 48122
// result := Delete ( result , result ) ;
48100: LD_ADDR_VAR 0 3
48104: PUSH
48105: LD_VAR 0 3
48109: PPUSH
48110: LD_VAR 0 3
48114: PPUSH
48115: CALL_OW 3
48119: ST_TO_ADDR
48120: GO 48097
48122: POP
48123: POP
// end ;
48124: LD_VAR 0 3
48128: RET
// export function ComExit ( unit ) ; var tmp ; begin
48129: LD_INT 0
48131: PPUSH
48132: PPUSH
// if not IsInUnit ( unit ) then
48133: LD_VAR 0 1
48137: PPUSH
48138: CALL_OW 310
48142: NOT
48143: IFFALSE 48147
// exit ;
48145: GO 48207
// tmp := IsInUnit ( unit ) ;
48147: LD_ADDR_VAR 0 3
48151: PUSH
48152: LD_VAR 0 1
48156: PPUSH
48157: CALL_OW 310
48161: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
48162: LD_VAR 0 3
48166: PPUSH
48167: CALL_OW 247
48171: PUSH
48172: LD_INT 2
48174: EQUAL
48175: IFFALSE 48188
// ComExitVehicle ( unit ) else
48177: LD_VAR 0 1
48181: PPUSH
48182: CALL_OW 121
48186: GO 48197
// ComExitBuilding ( unit ) ;
48188: LD_VAR 0 1
48192: PPUSH
48193: CALL_OW 122
// result := tmp ;
48197: LD_ADDR_VAR 0 2
48201: PUSH
48202: LD_VAR 0 3
48206: ST_TO_ADDR
// end ;
48207: LD_VAR 0 2
48211: RET
// export function ComExitAll ( units ) ; var i ; begin
48212: LD_INT 0
48214: PPUSH
48215: PPUSH
// if not units then
48216: LD_VAR 0 1
48220: NOT
48221: IFFALSE 48225
// exit ;
48223: GO 48251
// for i in units do
48225: LD_ADDR_VAR 0 3
48229: PUSH
48230: LD_VAR 0 1
48234: PUSH
48235: FOR_IN
48236: IFFALSE 48249
// ComExit ( i ) ;
48238: LD_VAR 0 3
48242: PPUSH
48243: CALL 48129 0 1
48247: GO 48235
48249: POP
48250: POP
// end ;
48251: LD_VAR 0 2
48255: RET
// export function ResetHc ; begin
48256: LD_INT 0
48258: PPUSH
// InitHc ;
48259: CALL_OW 19
// hc_importance := 0 ;
48263: LD_ADDR_OWVAR 32
48267: PUSH
48268: LD_INT 0
48270: ST_TO_ADDR
// end ;
48271: LD_VAR 0 1
48275: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
48276: LD_INT 0
48278: PPUSH
48279: PPUSH
48280: PPUSH
// _x := ( x1 + x2 ) div 2 ;
48281: LD_ADDR_VAR 0 6
48285: PUSH
48286: LD_VAR 0 1
48290: PUSH
48291: LD_VAR 0 3
48295: PLUS
48296: PUSH
48297: LD_INT 2
48299: DIV
48300: ST_TO_ADDR
// if _x < 0 then
48301: LD_VAR 0 6
48305: PUSH
48306: LD_INT 0
48308: LESS
48309: IFFALSE 48326
// _x := _x * - 1 ;
48311: LD_ADDR_VAR 0 6
48315: PUSH
48316: LD_VAR 0 6
48320: PUSH
48321: LD_INT 1
48323: NEG
48324: MUL
48325: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
48326: LD_ADDR_VAR 0 7
48330: PUSH
48331: LD_VAR 0 2
48335: PUSH
48336: LD_VAR 0 4
48340: PLUS
48341: PUSH
48342: LD_INT 2
48344: DIV
48345: ST_TO_ADDR
// if _y < 0 then
48346: LD_VAR 0 7
48350: PUSH
48351: LD_INT 0
48353: LESS
48354: IFFALSE 48371
// _y := _y * - 1 ;
48356: LD_ADDR_VAR 0 7
48360: PUSH
48361: LD_VAR 0 7
48365: PUSH
48366: LD_INT 1
48368: NEG
48369: MUL
48370: ST_TO_ADDR
// result := [ _x , _y ] ;
48371: LD_ADDR_VAR 0 5
48375: PUSH
48376: LD_VAR 0 6
48380: PUSH
48381: LD_VAR 0 7
48385: PUSH
48386: EMPTY
48387: LIST
48388: LIST
48389: ST_TO_ADDR
// end ;
48390: LD_VAR 0 5
48394: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
48395: LD_INT 0
48397: PPUSH
48398: PPUSH
48399: PPUSH
48400: PPUSH
// task := GetTaskList ( unit ) ;
48401: LD_ADDR_VAR 0 7
48405: PUSH
48406: LD_VAR 0 1
48410: PPUSH
48411: CALL_OW 437
48415: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
48416: LD_VAR 0 7
48420: NOT
48421: PUSH
48422: LD_VAR 0 1
48426: PPUSH
48427: LD_VAR 0 2
48431: PPUSH
48432: CALL_OW 308
48436: NOT
48437: AND
48438: IFFALSE 48442
// exit ;
48440: GO 48560
// if IsInArea ( unit , area ) then
48442: LD_VAR 0 1
48446: PPUSH
48447: LD_VAR 0 2
48451: PPUSH
48452: CALL_OW 308
48456: IFFALSE 48474
// begin ComMoveToArea ( unit , goAway ) ;
48458: LD_VAR 0 1
48462: PPUSH
48463: LD_VAR 0 3
48467: PPUSH
48468: CALL_OW 113
// exit ;
48472: GO 48560
// end ; if task [ 1 ] [ 1 ] <> M then
48474: LD_VAR 0 7
48478: PUSH
48479: LD_INT 1
48481: ARRAY
48482: PUSH
48483: LD_INT 1
48485: ARRAY
48486: PUSH
48487: LD_STRING M
48489: NONEQUAL
48490: IFFALSE 48494
// exit ;
48492: GO 48560
// x := task [ 1 ] [ 2 ] ;
48494: LD_ADDR_VAR 0 5
48498: PUSH
48499: LD_VAR 0 7
48503: PUSH
48504: LD_INT 1
48506: ARRAY
48507: PUSH
48508: LD_INT 2
48510: ARRAY
48511: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
48512: LD_ADDR_VAR 0 6
48516: PUSH
48517: LD_VAR 0 7
48521: PUSH
48522: LD_INT 1
48524: ARRAY
48525: PUSH
48526: LD_INT 3
48528: ARRAY
48529: ST_TO_ADDR
// if InArea ( x , y , area ) then
48530: LD_VAR 0 5
48534: PPUSH
48535: LD_VAR 0 6
48539: PPUSH
48540: LD_VAR 0 2
48544: PPUSH
48545: CALL_OW 309
48549: IFFALSE 48560
// ComStop ( unit ) ;
48551: LD_VAR 0 1
48555: PPUSH
48556: CALL_OW 141
// end ;
48560: LD_VAR 0 4
48564: RET
// export function Abs ( value ) ; begin
48565: LD_INT 0
48567: PPUSH
// result := value ;
48568: LD_ADDR_VAR 0 2
48572: PUSH
48573: LD_VAR 0 1
48577: ST_TO_ADDR
// if value < 0 then
48578: LD_VAR 0 1
48582: PUSH
48583: LD_INT 0
48585: LESS
48586: IFFALSE 48603
// result := value * - 1 ;
48588: LD_ADDR_VAR 0 2
48592: PUSH
48593: LD_VAR 0 1
48597: PUSH
48598: LD_INT 1
48600: NEG
48601: MUL
48602: ST_TO_ADDR
// end ;
48603: LD_VAR 0 2
48607: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
48608: LD_INT 0
48610: PPUSH
48611: PPUSH
48612: PPUSH
48613: PPUSH
48614: PPUSH
48615: PPUSH
48616: PPUSH
48617: PPUSH
// if not unit or not building then
48618: LD_VAR 0 1
48622: NOT
48623: PUSH
48624: LD_VAR 0 2
48628: NOT
48629: OR
48630: IFFALSE 48634
// exit ;
48632: GO 48860
// x := GetX ( building ) ;
48634: LD_ADDR_VAR 0 4
48638: PUSH
48639: LD_VAR 0 2
48643: PPUSH
48644: CALL_OW 250
48648: ST_TO_ADDR
// y := GetY ( building ) ;
48649: LD_ADDR_VAR 0 6
48653: PUSH
48654: LD_VAR 0 2
48658: PPUSH
48659: CALL_OW 251
48663: ST_TO_ADDR
// d := GetDir ( building ) ;
48664: LD_ADDR_VAR 0 8
48668: PUSH
48669: LD_VAR 0 2
48673: PPUSH
48674: CALL_OW 254
48678: ST_TO_ADDR
// r := 4 ;
48679: LD_ADDR_VAR 0 9
48683: PUSH
48684: LD_INT 4
48686: ST_TO_ADDR
// for i := 1 to 5 do
48687: LD_ADDR_VAR 0 10
48691: PUSH
48692: DOUBLE
48693: LD_INT 1
48695: DEC
48696: ST_TO_ADDR
48697: LD_INT 5
48699: PUSH
48700: FOR_TO
48701: IFFALSE 48858
// begin _x := ShiftX ( x , d , r + i ) ;
48703: LD_ADDR_VAR 0 5
48707: PUSH
48708: LD_VAR 0 4
48712: PPUSH
48713: LD_VAR 0 8
48717: PPUSH
48718: LD_VAR 0 9
48722: PUSH
48723: LD_VAR 0 10
48727: PLUS
48728: PPUSH
48729: CALL_OW 272
48733: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
48734: LD_ADDR_VAR 0 7
48738: PUSH
48739: LD_VAR 0 6
48743: PPUSH
48744: LD_VAR 0 8
48748: PPUSH
48749: LD_VAR 0 9
48753: PUSH
48754: LD_VAR 0 10
48758: PLUS
48759: PPUSH
48760: CALL_OW 273
48764: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
48765: LD_VAR 0 5
48769: PPUSH
48770: LD_VAR 0 7
48774: PPUSH
48775: CALL_OW 488
48779: PUSH
48780: LD_VAR 0 5
48784: PPUSH
48785: LD_VAR 0 7
48789: PPUSH
48790: CALL_OW 428
48794: PPUSH
48795: CALL_OW 247
48799: PUSH
48800: LD_INT 3
48802: PUSH
48803: LD_INT 2
48805: PUSH
48806: EMPTY
48807: LIST
48808: LIST
48809: IN
48810: NOT
48811: AND
48812: IFFALSE 48856
// begin ComMoveXY ( unit , _x , _y ) ;
48814: LD_VAR 0 1
48818: PPUSH
48819: LD_VAR 0 5
48823: PPUSH
48824: LD_VAR 0 7
48828: PPUSH
48829: CALL_OW 111
// result := [ _x , _y ] ;
48833: LD_ADDR_VAR 0 3
48837: PUSH
48838: LD_VAR 0 5
48842: PUSH
48843: LD_VAR 0 7
48847: PUSH
48848: EMPTY
48849: LIST
48850: LIST
48851: ST_TO_ADDR
// exit ;
48852: POP
48853: POP
48854: GO 48860
// end ; end ;
48856: GO 48700
48858: POP
48859: POP
// end ;
48860: LD_VAR 0 3
48864: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
48865: LD_INT 0
48867: PPUSH
48868: PPUSH
48869: PPUSH
// result := 0 ;
48870: LD_ADDR_VAR 0 3
48874: PUSH
48875: LD_INT 0
48877: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
48878: LD_VAR 0 1
48882: PUSH
48883: LD_INT 0
48885: LESS
48886: PUSH
48887: LD_VAR 0 1
48891: PUSH
48892: LD_INT 8
48894: GREATER
48895: OR
48896: PUSH
48897: LD_VAR 0 2
48901: PUSH
48902: LD_INT 0
48904: LESS
48905: OR
48906: PUSH
48907: LD_VAR 0 2
48911: PUSH
48912: LD_INT 8
48914: GREATER
48915: OR
48916: IFFALSE 48920
// exit ;
48918: GO 48995
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
48920: LD_ADDR_VAR 0 4
48924: PUSH
48925: LD_INT 22
48927: PUSH
48928: LD_VAR 0 2
48932: PUSH
48933: EMPTY
48934: LIST
48935: LIST
48936: PPUSH
48937: CALL_OW 69
48941: PUSH
48942: FOR_IN
48943: IFFALSE 48993
// begin un := UnitShoot ( i ) ;
48945: LD_ADDR_VAR 0 5
48949: PUSH
48950: LD_VAR 0 4
48954: PPUSH
48955: CALL_OW 504
48959: ST_TO_ADDR
// if GetSide ( un ) = side1 then
48960: LD_VAR 0 5
48964: PPUSH
48965: CALL_OW 255
48969: PUSH
48970: LD_VAR 0 1
48974: EQUAL
48975: IFFALSE 48991
// begin result := un ;
48977: LD_ADDR_VAR 0 3
48981: PUSH
48982: LD_VAR 0 5
48986: ST_TO_ADDR
// exit ;
48987: POP
48988: POP
48989: GO 48995
// end ; end ;
48991: GO 48942
48993: POP
48994: POP
// end ;
48995: LD_VAR 0 3
48999: RET
// export function GetCargoBay ( units ) ; begin
49000: LD_INT 0
49002: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
49003: LD_ADDR_VAR 0 2
49007: PUSH
49008: LD_VAR 0 1
49012: PPUSH
49013: LD_INT 2
49015: PUSH
49016: LD_INT 34
49018: PUSH
49019: LD_INT 12
49021: PUSH
49022: EMPTY
49023: LIST
49024: LIST
49025: PUSH
49026: LD_INT 34
49028: PUSH
49029: LD_INT 51
49031: PUSH
49032: EMPTY
49033: LIST
49034: LIST
49035: PUSH
49036: LD_INT 34
49038: PUSH
49039: LD_INT 32
49041: PUSH
49042: EMPTY
49043: LIST
49044: LIST
49045: PUSH
49046: LD_INT 34
49048: PUSH
49049: LD_EXP 68
49053: PUSH
49054: EMPTY
49055: LIST
49056: LIST
49057: PUSH
49058: EMPTY
49059: LIST
49060: LIST
49061: LIST
49062: LIST
49063: LIST
49064: PPUSH
49065: CALL_OW 72
49069: ST_TO_ADDR
// end ;
49070: LD_VAR 0 2
49074: RET
// export function Negate ( value ) ; begin
49075: LD_INT 0
49077: PPUSH
// result := not value ;
49078: LD_ADDR_VAR 0 2
49082: PUSH
49083: LD_VAR 0 1
49087: NOT
49088: ST_TO_ADDR
// end ;
49089: LD_VAR 0 2
49093: RET
// export function Inc ( value ) ; begin
49094: LD_INT 0
49096: PPUSH
// result := value + 1 ;
49097: LD_ADDR_VAR 0 2
49101: PUSH
49102: LD_VAR 0 1
49106: PUSH
49107: LD_INT 1
49109: PLUS
49110: ST_TO_ADDR
// end ;
49111: LD_VAR 0 2
49115: RET
// export function Dec ( value ) ; begin
49116: LD_INT 0
49118: PPUSH
// result := value - 1 ;
49119: LD_ADDR_VAR 0 2
49123: PUSH
49124: LD_VAR 0 1
49128: PUSH
49129: LD_INT 1
49131: MINUS
49132: ST_TO_ADDR
// end ;
49133: LD_VAR 0 2
49137: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
49138: LD_INT 0
49140: PPUSH
49141: PPUSH
49142: PPUSH
49143: PPUSH
49144: PPUSH
49145: PPUSH
49146: PPUSH
49147: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
49148: LD_VAR 0 1
49152: PPUSH
49153: LD_VAR 0 2
49157: PPUSH
49158: CALL_OW 488
49162: NOT
49163: PUSH
49164: LD_VAR 0 3
49168: PPUSH
49169: LD_VAR 0 4
49173: PPUSH
49174: CALL_OW 488
49178: NOT
49179: OR
49180: IFFALSE 49193
// begin result := - 1 ;
49182: LD_ADDR_VAR 0 5
49186: PUSH
49187: LD_INT 1
49189: NEG
49190: ST_TO_ADDR
// exit ;
49191: GO 49428
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
49193: LD_ADDR_VAR 0 12
49197: PUSH
49198: LD_VAR 0 1
49202: PPUSH
49203: LD_VAR 0 2
49207: PPUSH
49208: LD_VAR 0 3
49212: PPUSH
49213: LD_VAR 0 4
49217: PPUSH
49218: CALL 48276 0 4
49222: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
49223: LD_ADDR_VAR 0 11
49227: PUSH
49228: LD_VAR 0 1
49232: PPUSH
49233: LD_VAR 0 2
49237: PPUSH
49238: LD_VAR 0 12
49242: PUSH
49243: LD_INT 1
49245: ARRAY
49246: PPUSH
49247: LD_VAR 0 12
49251: PUSH
49252: LD_INT 2
49254: ARRAY
49255: PPUSH
49256: CALL_OW 298
49260: ST_TO_ADDR
// distance := 9999 ;
49261: LD_ADDR_VAR 0 10
49265: PUSH
49266: LD_INT 9999
49268: ST_TO_ADDR
// for i := 0 to 5 do
49269: LD_ADDR_VAR 0 6
49273: PUSH
49274: DOUBLE
49275: LD_INT 0
49277: DEC
49278: ST_TO_ADDR
49279: LD_INT 5
49281: PUSH
49282: FOR_TO
49283: IFFALSE 49426
// begin _x := ShiftX ( x1 , i , centerDist ) ;
49285: LD_ADDR_VAR 0 7
49289: PUSH
49290: LD_VAR 0 1
49294: PPUSH
49295: LD_VAR 0 6
49299: PPUSH
49300: LD_VAR 0 11
49304: PPUSH
49305: CALL_OW 272
49309: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
49310: LD_ADDR_VAR 0 8
49314: PUSH
49315: LD_VAR 0 2
49319: PPUSH
49320: LD_VAR 0 6
49324: PPUSH
49325: LD_VAR 0 11
49329: PPUSH
49330: CALL_OW 273
49334: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
49335: LD_VAR 0 7
49339: PPUSH
49340: LD_VAR 0 8
49344: PPUSH
49345: CALL_OW 488
49349: NOT
49350: IFFALSE 49354
// continue ;
49352: GO 49282
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
49354: LD_ADDR_VAR 0 9
49358: PUSH
49359: LD_VAR 0 12
49363: PUSH
49364: LD_INT 1
49366: ARRAY
49367: PPUSH
49368: LD_VAR 0 12
49372: PUSH
49373: LD_INT 2
49375: ARRAY
49376: PPUSH
49377: LD_VAR 0 7
49381: PPUSH
49382: LD_VAR 0 8
49386: PPUSH
49387: CALL_OW 298
49391: ST_TO_ADDR
// if tmp < distance then
49392: LD_VAR 0 9
49396: PUSH
49397: LD_VAR 0 10
49401: LESS
49402: IFFALSE 49424
// begin result := i ;
49404: LD_ADDR_VAR 0 5
49408: PUSH
49409: LD_VAR 0 6
49413: ST_TO_ADDR
// distance := tmp ;
49414: LD_ADDR_VAR 0 10
49418: PUSH
49419: LD_VAR 0 9
49423: ST_TO_ADDR
// end ; end ;
49424: GO 49282
49426: POP
49427: POP
// end ;
49428: LD_VAR 0 5
49432: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
49433: LD_INT 0
49435: PPUSH
49436: PPUSH
// if not driver or not IsInUnit ( driver ) then
49437: LD_VAR 0 1
49441: NOT
49442: PUSH
49443: LD_VAR 0 1
49447: PPUSH
49448: CALL_OW 310
49452: NOT
49453: OR
49454: IFFALSE 49458
// exit ;
49456: GO 49548
// vehicle := IsInUnit ( driver ) ;
49458: LD_ADDR_VAR 0 3
49462: PUSH
49463: LD_VAR 0 1
49467: PPUSH
49468: CALL_OW 310
49472: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
49473: LD_VAR 0 1
49477: PPUSH
49478: LD_STRING \
49480: PUSH
49481: LD_INT 0
49483: PUSH
49484: LD_INT 0
49486: PUSH
49487: LD_INT 0
49489: PUSH
49490: LD_INT 0
49492: PUSH
49493: LD_INT 0
49495: PUSH
49496: LD_INT 0
49498: PUSH
49499: EMPTY
49500: LIST
49501: LIST
49502: LIST
49503: LIST
49504: LIST
49505: LIST
49506: LIST
49507: PUSH
49508: LD_STRING E
49510: PUSH
49511: LD_INT 0
49513: PUSH
49514: LD_INT 0
49516: PUSH
49517: LD_VAR 0 3
49521: PUSH
49522: LD_INT 0
49524: PUSH
49525: LD_INT 0
49527: PUSH
49528: LD_INT 0
49530: PUSH
49531: EMPTY
49532: LIST
49533: LIST
49534: LIST
49535: LIST
49536: LIST
49537: LIST
49538: LIST
49539: PUSH
49540: EMPTY
49541: LIST
49542: LIST
49543: PPUSH
49544: CALL_OW 446
// end ;
49548: LD_VAR 0 2
49552: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
49553: LD_INT 0
49555: PPUSH
49556: PPUSH
// if not driver or not IsInUnit ( driver ) then
49557: LD_VAR 0 1
49561: NOT
49562: PUSH
49563: LD_VAR 0 1
49567: PPUSH
49568: CALL_OW 310
49572: NOT
49573: OR
49574: IFFALSE 49578
// exit ;
49576: GO 49668
// vehicle := IsInUnit ( driver ) ;
49578: LD_ADDR_VAR 0 3
49582: PUSH
49583: LD_VAR 0 1
49587: PPUSH
49588: CALL_OW 310
49592: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
49593: LD_VAR 0 1
49597: PPUSH
49598: LD_STRING \
49600: PUSH
49601: LD_INT 0
49603: PUSH
49604: LD_INT 0
49606: PUSH
49607: LD_INT 0
49609: PUSH
49610: LD_INT 0
49612: PUSH
49613: LD_INT 0
49615: PUSH
49616: LD_INT 0
49618: PUSH
49619: EMPTY
49620: LIST
49621: LIST
49622: LIST
49623: LIST
49624: LIST
49625: LIST
49626: LIST
49627: PUSH
49628: LD_STRING E
49630: PUSH
49631: LD_INT 0
49633: PUSH
49634: LD_INT 0
49636: PUSH
49637: LD_VAR 0 3
49641: PUSH
49642: LD_INT 0
49644: PUSH
49645: LD_INT 0
49647: PUSH
49648: LD_INT 0
49650: PUSH
49651: EMPTY
49652: LIST
49653: LIST
49654: LIST
49655: LIST
49656: LIST
49657: LIST
49658: LIST
49659: PUSH
49660: EMPTY
49661: LIST
49662: LIST
49663: PPUSH
49664: CALL_OW 447
// end ;
49668: LD_VAR 0 2
49672: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
49673: LD_INT 0
49675: PPUSH
49676: PPUSH
49677: PPUSH
// tmp := [ ] ;
49678: LD_ADDR_VAR 0 5
49682: PUSH
49683: EMPTY
49684: ST_TO_ADDR
// for i in units do
49685: LD_ADDR_VAR 0 4
49689: PUSH
49690: LD_VAR 0 1
49694: PUSH
49695: FOR_IN
49696: IFFALSE 49734
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
49698: LD_ADDR_VAR 0 5
49702: PUSH
49703: LD_VAR 0 5
49707: PPUSH
49708: LD_VAR 0 5
49712: PUSH
49713: LD_INT 1
49715: PLUS
49716: PPUSH
49717: LD_VAR 0 4
49721: PPUSH
49722: CALL_OW 256
49726: PPUSH
49727: CALL_OW 2
49731: ST_TO_ADDR
49732: GO 49695
49734: POP
49735: POP
// if not tmp then
49736: LD_VAR 0 5
49740: NOT
49741: IFFALSE 49745
// exit ;
49743: GO 49793
// if asc then
49745: LD_VAR 0 2
49749: IFFALSE 49773
// result := SortListByListAsc ( units , tmp ) else
49751: LD_ADDR_VAR 0 3
49755: PUSH
49756: LD_VAR 0 1
49760: PPUSH
49761: LD_VAR 0 5
49765: PPUSH
49766: CALL_OW 76
49770: ST_TO_ADDR
49771: GO 49793
// result := SortListByListDesc ( units , tmp ) ;
49773: LD_ADDR_VAR 0 3
49777: PUSH
49778: LD_VAR 0 1
49782: PPUSH
49783: LD_VAR 0 5
49787: PPUSH
49788: CALL_OW 77
49792: ST_TO_ADDR
// end ;
49793: LD_VAR 0 3
49797: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
49798: LD_INT 0
49800: PPUSH
49801: PPUSH
// task := GetTaskList ( mech ) ;
49802: LD_ADDR_VAR 0 4
49806: PUSH
49807: LD_VAR 0 1
49811: PPUSH
49812: CALL_OW 437
49816: ST_TO_ADDR
// if not task then
49817: LD_VAR 0 4
49821: NOT
49822: IFFALSE 49826
// exit ;
49824: GO 49868
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
49826: LD_ADDR_VAR 0 3
49830: PUSH
49831: LD_VAR 0 4
49835: PUSH
49836: LD_INT 1
49838: ARRAY
49839: PUSH
49840: LD_INT 1
49842: ARRAY
49843: PUSH
49844: LD_STRING r
49846: EQUAL
49847: PUSH
49848: LD_VAR 0 4
49852: PUSH
49853: LD_INT 1
49855: ARRAY
49856: PUSH
49857: LD_INT 4
49859: ARRAY
49860: PUSH
49861: LD_VAR 0 2
49865: EQUAL
49866: AND
49867: ST_TO_ADDR
// end ;
49868: LD_VAR 0 3
49872: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
49873: LD_INT 0
49875: PPUSH
// SetDir ( unit , d ) ;
49876: LD_VAR 0 1
49880: PPUSH
49881: LD_VAR 0 4
49885: PPUSH
49886: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
49890: LD_VAR 0 1
49894: PPUSH
49895: LD_VAR 0 2
49899: PPUSH
49900: LD_VAR 0 3
49904: PPUSH
49905: LD_VAR 0 5
49909: PPUSH
49910: CALL_OW 48
// end ;
49914: LD_VAR 0 6
49918: RET
// export function ToNaturalNumber ( number ) ; begin
49919: LD_INT 0
49921: PPUSH
// result := number div 1 ;
49922: LD_ADDR_VAR 0 2
49926: PUSH
49927: LD_VAR 0 1
49931: PUSH
49932: LD_INT 1
49934: DIV
49935: ST_TO_ADDR
// if number < 0 then
49936: LD_VAR 0 1
49940: PUSH
49941: LD_INT 0
49943: LESS
49944: IFFALSE 49954
// result := 0 ;
49946: LD_ADDR_VAR 0 2
49950: PUSH
49951: LD_INT 0
49953: ST_TO_ADDR
// end ;
49954: LD_VAR 0 2
49958: RET
// export function SortByClass ( units , class ) ; var un ; begin
49959: LD_INT 0
49961: PPUSH
49962: PPUSH
// if not units or not class then
49963: LD_VAR 0 1
49967: NOT
49968: PUSH
49969: LD_VAR 0 2
49973: NOT
49974: OR
49975: IFFALSE 49979
// exit ;
49977: GO 50074
// result := [ ] ;
49979: LD_ADDR_VAR 0 3
49983: PUSH
49984: EMPTY
49985: ST_TO_ADDR
// for un in units do
49986: LD_ADDR_VAR 0 4
49990: PUSH
49991: LD_VAR 0 1
49995: PUSH
49996: FOR_IN
49997: IFFALSE 50072
// if GetClass ( un ) = class then
49999: LD_VAR 0 4
50003: PPUSH
50004: CALL_OW 257
50008: PUSH
50009: LD_VAR 0 2
50013: EQUAL
50014: IFFALSE 50041
// result := Insert ( result , 1 , un ) else
50016: LD_ADDR_VAR 0 3
50020: PUSH
50021: LD_VAR 0 3
50025: PPUSH
50026: LD_INT 1
50028: PPUSH
50029: LD_VAR 0 4
50033: PPUSH
50034: CALL_OW 2
50038: ST_TO_ADDR
50039: GO 50070
// result := Replace ( result , result + 1 , un ) ;
50041: LD_ADDR_VAR 0 3
50045: PUSH
50046: LD_VAR 0 3
50050: PPUSH
50051: LD_VAR 0 3
50055: PUSH
50056: LD_INT 1
50058: PLUS
50059: PPUSH
50060: LD_VAR 0 4
50064: PPUSH
50065: CALL_OW 1
50069: ST_TO_ADDR
50070: GO 49996
50072: POP
50073: POP
// end ;
50074: LD_VAR 0 3
50078: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
50079: LD_INT 0
50081: PPUSH
50082: PPUSH
50083: PPUSH
50084: PPUSH
50085: PPUSH
50086: PPUSH
50087: PPUSH
// result := [ ] ;
50088: LD_ADDR_VAR 0 4
50092: PUSH
50093: EMPTY
50094: ST_TO_ADDR
// if x - r < 0 then
50095: LD_VAR 0 1
50099: PUSH
50100: LD_VAR 0 3
50104: MINUS
50105: PUSH
50106: LD_INT 0
50108: LESS
50109: IFFALSE 50121
// min_x := 0 else
50111: LD_ADDR_VAR 0 8
50115: PUSH
50116: LD_INT 0
50118: ST_TO_ADDR
50119: GO 50137
// min_x := x - r ;
50121: LD_ADDR_VAR 0 8
50125: PUSH
50126: LD_VAR 0 1
50130: PUSH
50131: LD_VAR 0 3
50135: MINUS
50136: ST_TO_ADDR
// if y - r < 0 then
50137: LD_VAR 0 2
50141: PUSH
50142: LD_VAR 0 3
50146: MINUS
50147: PUSH
50148: LD_INT 0
50150: LESS
50151: IFFALSE 50163
// min_y := 0 else
50153: LD_ADDR_VAR 0 7
50157: PUSH
50158: LD_INT 0
50160: ST_TO_ADDR
50161: GO 50179
// min_y := y - r ;
50163: LD_ADDR_VAR 0 7
50167: PUSH
50168: LD_VAR 0 2
50172: PUSH
50173: LD_VAR 0 3
50177: MINUS
50178: ST_TO_ADDR
// max_x := x + r ;
50179: LD_ADDR_VAR 0 9
50183: PUSH
50184: LD_VAR 0 1
50188: PUSH
50189: LD_VAR 0 3
50193: PLUS
50194: ST_TO_ADDR
// max_y := y + r ;
50195: LD_ADDR_VAR 0 10
50199: PUSH
50200: LD_VAR 0 2
50204: PUSH
50205: LD_VAR 0 3
50209: PLUS
50210: ST_TO_ADDR
// for _x = min_x to max_x do
50211: LD_ADDR_VAR 0 5
50215: PUSH
50216: DOUBLE
50217: LD_VAR 0 8
50221: DEC
50222: ST_TO_ADDR
50223: LD_VAR 0 9
50227: PUSH
50228: FOR_TO
50229: IFFALSE 50330
// for _y = min_y to max_y do
50231: LD_ADDR_VAR 0 6
50235: PUSH
50236: DOUBLE
50237: LD_VAR 0 7
50241: DEC
50242: ST_TO_ADDR
50243: LD_VAR 0 10
50247: PUSH
50248: FOR_TO
50249: IFFALSE 50326
// begin if not ValidHex ( _x , _y ) then
50251: LD_VAR 0 5
50255: PPUSH
50256: LD_VAR 0 6
50260: PPUSH
50261: CALL_OW 488
50265: NOT
50266: IFFALSE 50270
// continue ;
50268: GO 50248
// if GetResourceTypeXY ( _x , _y ) then
50270: LD_VAR 0 5
50274: PPUSH
50275: LD_VAR 0 6
50279: PPUSH
50280: CALL_OW 283
50284: IFFALSE 50324
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
50286: LD_ADDR_VAR 0 4
50290: PUSH
50291: LD_VAR 0 4
50295: PPUSH
50296: LD_VAR 0 4
50300: PUSH
50301: LD_INT 1
50303: PLUS
50304: PPUSH
50305: LD_VAR 0 5
50309: PUSH
50310: LD_VAR 0 6
50314: PUSH
50315: EMPTY
50316: LIST
50317: LIST
50318: PPUSH
50319: CALL_OW 1
50323: ST_TO_ADDR
// end ;
50324: GO 50248
50326: POP
50327: POP
50328: GO 50228
50330: POP
50331: POP
// end ;
50332: LD_VAR 0 4
50336: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
50337: LD_INT 0
50339: PPUSH
50340: PPUSH
50341: PPUSH
50342: PPUSH
50343: PPUSH
50344: PPUSH
50345: PPUSH
50346: PPUSH
// if not units then
50347: LD_VAR 0 1
50351: NOT
50352: IFFALSE 50356
// exit ;
50354: GO 50781
// result := UnitFilter ( units , [ f_ok ] ) ;
50356: LD_ADDR_VAR 0 3
50360: PUSH
50361: LD_VAR 0 1
50365: PPUSH
50366: LD_INT 50
50368: PUSH
50369: EMPTY
50370: LIST
50371: PPUSH
50372: CALL_OW 72
50376: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
50377: LD_ADDR_VAR 0 8
50381: PUSH
50382: LD_VAR 0 1
50386: PUSH
50387: LD_INT 1
50389: ARRAY
50390: PPUSH
50391: CALL_OW 255
50395: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb ] ;
50396: LD_ADDR_VAR 0 10
50400: PUSH
50401: LD_INT 29
50403: PUSH
50404: LD_EXP 71
50408: PUSH
50409: EMPTY
50410: LIST
50411: LIST
50412: ST_TO_ADDR
// if not result then
50413: LD_VAR 0 3
50417: NOT
50418: IFFALSE 50422
// exit ;
50420: GO 50781
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
50422: LD_ADDR_VAR 0 5
50426: PUSH
50427: LD_INT 81
50429: PUSH
50430: LD_VAR 0 8
50434: PUSH
50435: EMPTY
50436: LIST
50437: LIST
50438: PPUSH
50439: CALL_OW 69
50443: ST_TO_ADDR
// for i in result do
50444: LD_ADDR_VAR 0 4
50448: PUSH
50449: LD_VAR 0 3
50453: PUSH
50454: FOR_IN
50455: IFFALSE 50779
// begin tag := GetTag ( i ) + 1 ;
50457: LD_ADDR_VAR 0 9
50461: PUSH
50462: LD_VAR 0 4
50466: PPUSH
50467: CALL_OW 110
50471: PUSH
50472: LD_INT 1
50474: PLUS
50475: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
50476: LD_ADDR_VAR 0 7
50480: PUSH
50481: LD_VAR 0 4
50485: PPUSH
50486: CALL_OW 250
50490: PPUSH
50491: LD_VAR 0 4
50495: PPUSH
50496: CALL_OW 251
50500: PPUSH
50501: LD_INT 6
50503: PPUSH
50504: CALL 50079 0 3
50508: ST_TO_ADDR
// if cr and not GetWeapon ( i ) in ignoreCratesWeapon then
50509: LD_VAR 0 7
50513: PUSH
50514: LD_VAR 0 4
50518: PPUSH
50519: CALL_OW 264
50523: PUSH
50524: LD_VAR 0 10
50528: IN
50529: NOT
50530: AND
50531: IFFALSE 50570
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
50533: LD_VAR 0 4
50537: PPUSH
50538: LD_VAR 0 7
50542: PUSH
50543: LD_INT 1
50545: ARRAY
50546: PUSH
50547: LD_INT 1
50549: ARRAY
50550: PPUSH
50551: LD_VAR 0 7
50555: PUSH
50556: LD_INT 1
50558: ARRAY
50559: PUSH
50560: LD_INT 2
50562: ARRAY
50563: PPUSH
50564: CALL_OW 116
50568: GO 50777
// if path > tag then
50570: LD_VAR 0 2
50574: PUSH
50575: LD_VAR 0 9
50579: GREATER
50580: IFFALSE 50747
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 12 ] ) ;
50582: LD_ADDR_VAR 0 6
50586: PUSH
50587: LD_VAR 0 5
50591: PPUSH
50592: LD_INT 91
50594: PUSH
50595: LD_VAR 0 4
50599: PUSH
50600: LD_INT 12
50602: PUSH
50603: EMPTY
50604: LIST
50605: LIST
50606: LIST
50607: PPUSH
50608: CALL_OW 72
50612: ST_TO_ADDR
// if nearEnemy then
50613: LD_VAR 0 6
50617: IFFALSE 50645
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
50619: LD_VAR 0 4
50623: PPUSH
50624: LD_VAR 0 6
50628: PPUSH
50629: LD_VAR 0 4
50633: PPUSH
50634: CALL_OW 74
50638: PPUSH
50639: CALL_OW 115
50643: GO 50745
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
50645: LD_VAR 0 4
50649: PPUSH
50650: LD_VAR 0 2
50654: PUSH
50655: LD_VAR 0 9
50659: ARRAY
50660: PUSH
50661: LD_INT 1
50663: ARRAY
50664: PPUSH
50665: LD_VAR 0 2
50669: PUSH
50670: LD_VAR 0 9
50674: ARRAY
50675: PUSH
50676: LD_INT 2
50678: ARRAY
50679: PPUSH
50680: CALL_OW 297
50684: PUSH
50685: LD_INT 6
50687: GREATER
50688: IFFALSE 50731
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
50690: LD_VAR 0 4
50694: PPUSH
50695: LD_VAR 0 2
50699: PUSH
50700: LD_VAR 0 9
50704: ARRAY
50705: PUSH
50706: LD_INT 1
50708: ARRAY
50709: PPUSH
50710: LD_VAR 0 2
50714: PUSH
50715: LD_VAR 0 9
50719: ARRAY
50720: PUSH
50721: LD_INT 2
50723: ARRAY
50724: PPUSH
50725: CALL_OW 114
50729: GO 50745
// SetTag ( i , tag ) ;
50731: LD_VAR 0 4
50735: PPUSH
50736: LD_VAR 0 9
50740: PPUSH
50741: CALL_OW 109
// end else
50745: GO 50777
// if enemy then
50747: LD_VAR 0 5
50751: IFFALSE 50777
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
50753: LD_VAR 0 4
50757: PPUSH
50758: LD_VAR 0 5
50762: PPUSH
50763: LD_VAR 0 4
50767: PPUSH
50768: CALL_OW 74
50772: PPUSH
50773: CALL_OW 115
// end ;
50777: GO 50454
50779: POP
50780: POP
// end ;
50781: LD_VAR 0 3
50785: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
50786: LD_INT 0
50788: PPUSH
50789: PPUSH
50790: PPUSH
// if not unit or IsInUnit ( unit ) then
50791: LD_VAR 0 1
50795: NOT
50796: PUSH
50797: LD_VAR 0 1
50801: PPUSH
50802: CALL_OW 310
50806: OR
50807: IFFALSE 50811
// exit ;
50809: GO 50902
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
50811: LD_ADDR_VAR 0 4
50815: PUSH
50816: LD_VAR 0 1
50820: PPUSH
50821: CALL_OW 250
50825: PPUSH
50826: LD_VAR 0 2
50830: PPUSH
50831: LD_INT 1
50833: PPUSH
50834: CALL_OW 272
50838: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
50839: LD_ADDR_VAR 0 5
50843: PUSH
50844: LD_VAR 0 1
50848: PPUSH
50849: CALL_OW 251
50853: PPUSH
50854: LD_VAR 0 2
50858: PPUSH
50859: LD_INT 1
50861: PPUSH
50862: CALL_OW 273
50866: ST_TO_ADDR
// if ValidHex ( x , y ) then
50867: LD_VAR 0 4
50871: PPUSH
50872: LD_VAR 0 5
50876: PPUSH
50877: CALL_OW 488
50881: IFFALSE 50902
// ComTurnXY ( unit , x , y ) ;
50883: LD_VAR 0 1
50887: PPUSH
50888: LD_VAR 0 4
50892: PPUSH
50893: LD_VAR 0 5
50897: PPUSH
50898: CALL_OW 118
// end ;
50902: LD_VAR 0 3
50906: RET
// export function SeeUnits ( side , units ) ; var i ; begin
50907: LD_INT 0
50909: PPUSH
50910: PPUSH
// result := false ;
50911: LD_ADDR_VAR 0 3
50915: PUSH
50916: LD_INT 0
50918: ST_TO_ADDR
// if not units then
50919: LD_VAR 0 2
50923: NOT
50924: IFFALSE 50928
// exit ;
50926: GO 50973
// for i in units do
50928: LD_ADDR_VAR 0 4
50932: PUSH
50933: LD_VAR 0 2
50937: PUSH
50938: FOR_IN
50939: IFFALSE 50971
// if See ( side , i ) then
50941: LD_VAR 0 1
50945: PPUSH
50946: LD_VAR 0 4
50950: PPUSH
50951: CALL_OW 292
50955: IFFALSE 50969
// begin result := true ;
50957: LD_ADDR_VAR 0 3
50961: PUSH
50962: LD_INT 1
50964: ST_TO_ADDR
// exit ;
50965: POP
50966: POP
50967: GO 50973
// end ;
50969: GO 50938
50971: POP
50972: POP
// end ;
50973: LD_VAR 0 3
50977: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
50978: LD_INT 0
50980: PPUSH
50981: PPUSH
50982: PPUSH
50983: PPUSH
// if not unit or not points then
50984: LD_VAR 0 1
50988: NOT
50989: PUSH
50990: LD_VAR 0 2
50994: NOT
50995: OR
50996: IFFALSE 51000
// exit ;
50998: GO 51090
// dist := 99999 ;
51000: LD_ADDR_VAR 0 5
51004: PUSH
51005: LD_INT 99999
51007: ST_TO_ADDR
// for i in points do
51008: LD_ADDR_VAR 0 4
51012: PUSH
51013: LD_VAR 0 2
51017: PUSH
51018: FOR_IN
51019: IFFALSE 51088
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
51021: LD_ADDR_VAR 0 6
51025: PUSH
51026: LD_VAR 0 1
51030: PPUSH
51031: LD_VAR 0 4
51035: PUSH
51036: LD_INT 1
51038: ARRAY
51039: PPUSH
51040: LD_VAR 0 4
51044: PUSH
51045: LD_INT 2
51047: ARRAY
51048: PPUSH
51049: CALL_OW 297
51053: ST_TO_ADDR
// if tmpDist < dist then
51054: LD_VAR 0 6
51058: PUSH
51059: LD_VAR 0 5
51063: LESS
51064: IFFALSE 51086
// begin result := i ;
51066: LD_ADDR_VAR 0 3
51070: PUSH
51071: LD_VAR 0 4
51075: ST_TO_ADDR
// dist := tmpDist ;
51076: LD_ADDR_VAR 0 5
51080: PUSH
51081: LD_VAR 0 6
51085: ST_TO_ADDR
// end ; end ;
51086: GO 51018
51088: POP
51089: POP
// end ; end_of_file
51090: LD_VAR 0 3
51094: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
51095: LD_INT 0
51097: PPUSH
51098: PPUSH
// skirmish := false ;
51099: LD_ADDR_EXP 21
51103: PUSH
51104: LD_INT 0
51106: ST_TO_ADDR
// debug_mc := false ;
51107: LD_ADDR_EXP 22
51111: PUSH
51112: LD_INT 0
51114: ST_TO_ADDR
// mc_bases := [ ] ;
51115: LD_ADDR_EXP 23
51119: PUSH
51120: EMPTY
51121: ST_TO_ADDR
// mc_sides := [ ] ;
51122: LD_ADDR_EXP 49
51126: PUSH
51127: EMPTY
51128: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
51129: LD_ADDR_EXP 24
51133: PUSH
51134: EMPTY
51135: ST_TO_ADDR
// mc_building_repairs := [ ] ;
51136: LD_ADDR_EXP 25
51140: PUSH
51141: EMPTY
51142: ST_TO_ADDR
// mc_need_heal := [ ] ;
51143: LD_ADDR_EXP 26
51147: PUSH
51148: EMPTY
51149: ST_TO_ADDR
// mc_healers := [ ] ;
51150: LD_ADDR_EXP 27
51154: PUSH
51155: EMPTY
51156: ST_TO_ADDR
// mc_build_list := [ ] ;
51157: LD_ADDR_EXP 28
51161: PUSH
51162: EMPTY
51163: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
51164: LD_ADDR_EXP 55
51168: PUSH
51169: EMPTY
51170: ST_TO_ADDR
// mc_builders := [ ] ;
51171: LD_ADDR_EXP 29
51175: PUSH
51176: EMPTY
51177: ST_TO_ADDR
// mc_construct_list := [ ] ;
51178: LD_ADDR_EXP 30
51182: PUSH
51183: EMPTY
51184: ST_TO_ADDR
// mc_turret_list := [ ] ;
51185: LD_ADDR_EXP 31
51189: PUSH
51190: EMPTY
51191: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
51192: LD_ADDR_EXP 32
51196: PUSH
51197: EMPTY
51198: ST_TO_ADDR
// mc_miners := [ ] ;
51199: LD_ADDR_EXP 37
51203: PUSH
51204: EMPTY
51205: ST_TO_ADDR
// mc_mines := [ ] ;
51206: LD_ADDR_EXP 36
51210: PUSH
51211: EMPTY
51212: ST_TO_ADDR
// mc_minefields := [ ] ;
51213: LD_ADDR_EXP 38
51217: PUSH
51218: EMPTY
51219: ST_TO_ADDR
// mc_crates := [ ] ;
51220: LD_ADDR_EXP 39
51224: PUSH
51225: EMPTY
51226: ST_TO_ADDR
// mc_crates_collector := [ ] ;
51227: LD_ADDR_EXP 40
51231: PUSH
51232: EMPTY
51233: ST_TO_ADDR
// mc_crates_area := [ ] ;
51234: LD_ADDR_EXP 41
51238: PUSH
51239: EMPTY
51240: ST_TO_ADDR
// mc_vehicles := [ ] ;
51241: LD_ADDR_EXP 42
51245: PUSH
51246: EMPTY
51247: ST_TO_ADDR
// mc_attack := [ ] ;
51248: LD_ADDR_EXP 43
51252: PUSH
51253: EMPTY
51254: ST_TO_ADDR
// mc_produce := [ ] ;
51255: LD_ADDR_EXP 44
51259: PUSH
51260: EMPTY
51261: ST_TO_ADDR
// mc_defender := [ ] ;
51262: LD_ADDR_EXP 45
51266: PUSH
51267: EMPTY
51268: ST_TO_ADDR
// mc_parking := [ ] ;
51269: LD_ADDR_EXP 47
51273: PUSH
51274: EMPTY
51275: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
51276: LD_ADDR_EXP 33
51280: PUSH
51281: EMPTY
51282: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
51283: LD_ADDR_EXP 35
51287: PUSH
51288: EMPTY
51289: ST_TO_ADDR
// mc_scan := [ ] ;
51290: LD_ADDR_EXP 46
51294: PUSH
51295: EMPTY
51296: ST_TO_ADDR
// mc_scan_area := [ ] ;
51297: LD_ADDR_EXP 48
51301: PUSH
51302: EMPTY
51303: ST_TO_ADDR
// mc_tech := [ ] ;
51304: LD_ADDR_EXP 50
51308: PUSH
51309: EMPTY
51310: ST_TO_ADDR
// mc_class := [ ] ;
51311: LD_ADDR_EXP 64
51315: PUSH
51316: EMPTY
51317: ST_TO_ADDR
// mc_class_case_use := [ ] ;
51318: LD_ADDR_EXP 65
51322: PUSH
51323: EMPTY
51324: ST_TO_ADDR
// mc_is_defending := [ ] ;
51325: LD_ADDR_EXP 66
51329: PUSH
51330: EMPTY
51331: ST_TO_ADDR
// end ;
51332: LD_VAR 0 1
51336: RET
// export function MC_Kill ( base ) ; begin
51337: LD_INT 0
51339: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
51340: LD_ADDR_EXP 23
51344: PUSH
51345: LD_EXP 23
51349: PPUSH
51350: LD_VAR 0 1
51354: PPUSH
51355: EMPTY
51356: PPUSH
51357: CALL_OW 1
51361: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
51362: LD_ADDR_EXP 24
51366: PUSH
51367: LD_EXP 24
51371: PPUSH
51372: LD_VAR 0 1
51376: PPUSH
51377: EMPTY
51378: PPUSH
51379: CALL_OW 1
51383: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
51384: LD_ADDR_EXP 25
51388: PUSH
51389: LD_EXP 25
51393: PPUSH
51394: LD_VAR 0 1
51398: PPUSH
51399: EMPTY
51400: PPUSH
51401: CALL_OW 1
51405: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
51406: LD_ADDR_EXP 26
51410: PUSH
51411: LD_EXP 26
51415: PPUSH
51416: LD_VAR 0 1
51420: PPUSH
51421: EMPTY
51422: PPUSH
51423: CALL_OW 1
51427: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
51428: LD_ADDR_EXP 27
51432: PUSH
51433: LD_EXP 27
51437: PPUSH
51438: LD_VAR 0 1
51442: PPUSH
51443: EMPTY
51444: PPUSH
51445: CALL_OW 1
51449: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
51450: LD_ADDR_EXP 28
51454: PUSH
51455: LD_EXP 28
51459: PPUSH
51460: LD_VAR 0 1
51464: PPUSH
51465: EMPTY
51466: PPUSH
51467: CALL_OW 1
51471: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
51472: LD_ADDR_EXP 29
51476: PUSH
51477: LD_EXP 29
51481: PPUSH
51482: LD_VAR 0 1
51486: PPUSH
51487: EMPTY
51488: PPUSH
51489: CALL_OW 1
51493: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
51494: LD_ADDR_EXP 30
51498: PUSH
51499: LD_EXP 30
51503: PPUSH
51504: LD_VAR 0 1
51508: PPUSH
51509: EMPTY
51510: PPUSH
51511: CALL_OW 1
51515: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
51516: LD_ADDR_EXP 31
51520: PUSH
51521: LD_EXP 31
51525: PPUSH
51526: LD_VAR 0 1
51530: PPUSH
51531: EMPTY
51532: PPUSH
51533: CALL_OW 1
51537: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
51538: LD_ADDR_EXP 32
51542: PUSH
51543: LD_EXP 32
51547: PPUSH
51548: LD_VAR 0 1
51552: PPUSH
51553: EMPTY
51554: PPUSH
51555: CALL_OW 1
51559: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
51560: LD_ADDR_EXP 33
51564: PUSH
51565: LD_EXP 33
51569: PPUSH
51570: LD_VAR 0 1
51574: PPUSH
51575: EMPTY
51576: PPUSH
51577: CALL_OW 1
51581: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
51582: LD_ADDR_EXP 34
51586: PUSH
51587: LD_EXP 34
51591: PPUSH
51592: LD_VAR 0 1
51596: PPUSH
51597: LD_INT 0
51599: PPUSH
51600: CALL_OW 1
51604: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
51605: LD_ADDR_EXP 35
51609: PUSH
51610: LD_EXP 35
51614: PPUSH
51615: LD_VAR 0 1
51619: PPUSH
51620: EMPTY
51621: PPUSH
51622: CALL_OW 1
51626: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
51627: LD_ADDR_EXP 36
51631: PUSH
51632: LD_EXP 36
51636: PPUSH
51637: LD_VAR 0 1
51641: PPUSH
51642: EMPTY
51643: PPUSH
51644: CALL_OW 1
51648: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
51649: LD_ADDR_EXP 37
51653: PUSH
51654: LD_EXP 37
51658: PPUSH
51659: LD_VAR 0 1
51663: PPUSH
51664: EMPTY
51665: PPUSH
51666: CALL_OW 1
51670: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
51671: LD_ADDR_EXP 38
51675: PUSH
51676: LD_EXP 38
51680: PPUSH
51681: LD_VAR 0 1
51685: PPUSH
51686: EMPTY
51687: PPUSH
51688: CALL_OW 1
51692: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
51693: LD_ADDR_EXP 39
51697: PUSH
51698: LD_EXP 39
51702: PPUSH
51703: LD_VAR 0 1
51707: PPUSH
51708: EMPTY
51709: PPUSH
51710: CALL_OW 1
51714: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
51715: LD_ADDR_EXP 40
51719: PUSH
51720: LD_EXP 40
51724: PPUSH
51725: LD_VAR 0 1
51729: PPUSH
51730: EMPTY
51731: PPUSH
51732: CALL_OW 1
51736: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
51737: LD_ADDR_EXP 41
51741: PUSH
51742: LD_EXP 41
51746: PPUSH
51747: LD_VAR 0 1
51751: PPUSH
51752: EMPTY
51753: PPUSH
51754: CALL_OW 1
51758: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
51759: LD_ADDR_EXP 42
51763: PUSH
51764: LD_EXP 42
51768: PPUSH
51769: LD_VAR 0 1
51773: PPUSH
51774: EMPTY
51775: PPUSH
51776: CALL_OW 1
51780: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
51781: LD_ADDR_EXP 43
51785: PUSH
51786: LD_EXP 43
51790: PPUSH
51791: LD_VAR 0 1
51795: PPUSH
51796: EMPTY
51797: PPUSH
51798: CALL_OW 1
51802: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
51803: LD_ADDR_EXP 44
51807: PUSH
51808: LD_EXP 44
51812: PPUSH
51813: LD_VAR 0 1
51817: PPUSH
51818: EMPTY
51819: PPUSH
51820: CALL_OW 1
51824: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
51825: LD_ADDR_EXP 45
51829: PUSH
51830: LD_EXP 45
51834: PPUSH
51835: LD_VAR 0 1
51839: PPUSH
51840: EMPTY
51841: PPUSH
51842: CALL_OW 1
51846: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
51847: LD_ADDR_EXP 46
51851: PUSH
51852: LD_EXP 46
51856: PPUSH
51857: LD_VAR 0 1
51861: PPUSH
51862: EMPTY
51863: PPUSH
51864: CALL_OW 1
51868: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
51869: LD_ADDR_EXP 47
51873: PUSH
51874: LD_EXP 47
51878: PPUSH
51879: LD_VAR 0 1
51883: PPUSH
51884: EMPTY
51885: PPUSH
51886: CALL_OW 1
51890: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
51891: LD_ADDR_EXP 48
51895: PUSH
51896: LD_EXP 48
51900: PPUSH
51901: LD_VAR 0 1
51905: PPUSH
51906: EMPTY
51907: PPUSH
51908: CALL_OW 1
51912: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
51913: LD_ADDR_EXP 50
51917: PUSH
51918: LD_EXP 50
51922: PPUSH
51923: LD_VAR 0 1
51927: PPUSH
51928: EMPTY
51929: PPUSH
51930: CALL_OW 1
51934: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
51935: LD_ADDR_EXP 52
51939: PUSH
51940: LD_EXP 52
51944: PPUSH
51945: LD_VAR 0 1
51949: PPUSH
51950: EMPTY
51951: PPUSH
51952: CALL_OW 1
51956: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
51957: LD_ADDR_EXP 53
51961: PUSH
51962: LD_EXP 53
51966: PPUSH
51967: LD_VAR 0 1
51971: PPUSH
51972: EMPTY
51973: PPUSH
51974: CALL_OW 1
51978: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
51979: LD_ADDR_EXP 54
51983: PUSH
51984: LD_EXP 54
51988: PPUSH
51989: LD_VAR 0 1
51993: PPUSH
51994: EMPTY
51995: PPUSH
51996: CALL_OW 1
52000: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
52001: LD_ADDR_EXP 55
52005: PUSH
52006: LD_EXP 55
52010: PPUSH
52011: LD_VAR 0 1
52015: PPUSH
52016: EMPTY
52017: PPUSH
52018: CALL_OW 1
52022: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
52023: LD_ADDR_EXP 56
52027: PUSH
52028: LD_EXP 56
52032: PPUSH
52033: LD_VAR 0 1
52037: PPUSH
52038: EMPTY
52039: PPUSH
52040: CALL_OW 1
52044: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
52045: LD_ADDR_EXP 57
52049: PUSH
52050: LD_EXP 57
52054: PPUSH
52055: LD_VAR 0 1
52059: PPUSH
52060: EMPTY
52061: PPUSH
52062: CALL_OW 1
52066: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
52067: LD_ADDR_EXP 58
52071: PUSH
52072: LD_EXP 58
52076: PPUSH
52077: LD_VAR 0 1
52081: PPUSH
52082: EMPTY
52083: PPUSH
52084: CALL_OW 1
52088: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
52089: LD_ADDR_EXP 59
52093: PUSH
52094: LD_EXP 59
52098: PPUSH
52099: LD_VAR 0 1
52103: PPUSH
52104: EMPTY
52105: PPUSH
52106: CALL_OW 1
52110: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
52111: LD_ADDR_EXP 60
52115: PUSH
52116: LD_EXP 60
52120: PPUSH
52121: LD_VAR 0 1
52125: PPUSH
52126: EMPTY
52127: PPUSH
52128: CALL_OW 1
52132: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
52133: LD_ADDR_EXP 61
52137: PUSH
52138: LD_EXP 61
52142: PPUSH
52143: LD_VAR 0 1
52147: PPUSH
52148: EMPTY
52149: PPUSH
52150: CALL_OW 1
52154: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
52155: LD_ADDR_EXP 62
52159: PUSH
52160: LD_EXP 62
52164: PPUSH
52165: LD_VAR 0 1
52169: PPUSH
52170: EMPTY
52171: PPUSH
52172: CALL_OW 1
52176: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
52177: LD_ADDR_EXP 63
52181: PUSH
52182: LD_EXP 63
52186: PPUSH
52187: LD_VAR 0 1
52191: PPUSH
52192: EMPTY
52193: PPUSH
52194: CALL_OW 1
52198: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
52199: LD_ADDR_EXP 64
52203: PUSH
52204: LD_EXP 64
52208: PPUSH
52209: LD_VAR 0 1
52213: PPUSH
52214: EMPTY
52215: PPUSH
52216: CALL_OW 1
52220: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
52221: LD_ADDR_EXP 65
52225: PUSH
52226: LD_EXP 65
52230: PPUSH
52231: LD_VAR 0 1
52235: PPUSH
52236: LD_INT 0
52238: PPUSH
52239: CALL_OW 1
52243: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
52244: LD_ADDR_EXP 66
52248: PUSH
52249: LD_EXP 66
52253: PPUSH
52254: LD_VAR 0 1
52258: PPUSH
52259: LD_INT 0
52261: PPUSH
52262: CALL_OW 1
52266: ST_TO_ADDR
// end ;
52267: LD_VAR 0 2
52271: RET
// export function MC_Add ( side , units ) ; var base ; begin
52272: LD_INT 0
52274: PPUSH
52275: PPUSH
// base := mc_bases + 1 ;
52276: LD_ADDR_VAR 0 4
52280: PUSH
52281: LD_EXP 23
52285: PUSH
52286: LD_INT 1
52288: PLUS
52289: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
52290: LD_ADDR_EXP 49
52294: PUSH
52295: LD_EXP 49
52299: PPUSH
52300: LD_VAR 0 4
52304: PPUSH
52305: LD_VAR 0 1
52309: PPUSH
52310: CALL_OW 1
52314: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
52315: LD_ADDR_EXP 23
52319: PUSH
52320: LD_EXP 23
52324: PPUSH
52325: LD_VAR 0 4
52329: PPUSH
52330: LD_VAR 0 2
52334: PPUSH
52335: CALL_OW 1
52339: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
52340: LD_ADDR_EXP 24
52344: PUSH
52345: LD_EXP 24
52349: PPUSH
52350: LD_VAR 0 4
52354: PPUSH
52355: EMPTY
52356: PPUSH
52357: CALL_OW 1
52361: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
52362: LD_ADDR_EXP 25
52366: PUSH
52367: LD_EXP 25
52371: PPUSH
52372: LD_VAR 0 4
52376: PPUSH
52377: EMPTY
52378: PPUSH
52379: CALL_OW 1
52383: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
52384: LD_ADDR_EXP 26
52388: PUSH
52389: LD_EXP 26
52393: PPUSH
52394: LD_VAR 0 4
52398: PPUSH
52399: EMPTY
52400: PPUSH
52401: CALL_OW 1
52405: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
52406: LD_ADDR_EXP 27
52410: PUSH
52411: LD_EXP 27
52415: PPUSH
52416: LD_VAR 0 4
52420: PPUSH
52421: EMPTY
52422: PPUSH
52423: CALL_OW 1
52427: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
52428: LD_ADDR_EXP 28
52432: PUSH
52433: LD_EXP 28
52437: PPUSH
52438: LD_VAR 0 4
52442: PPUSH
52443: EMPTY
52444: PPUSH
52445: CALL_OW 1
52449: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
52450: LD_ADDR_EXP 29
52454: PUSH
52455: LD_EXP 29
52459: PPUSH
52460: LD_VAR 0 4
52464: PPUSH
52465: EMPTY
52466: PPUSH
52467: CALL_OW 1
52471: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
52472: LD_ADDR_EXP 30
52476: PUSH
52477: LD_EXP 30
52481: PPUSH
52482: LD_VAR 0 4
52486: PPUSH
52487: EMPTY
52488: PPUSH
52489: CALL_OW 1
52493: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
52494: LD_ADDR_EXP 31
52498: PUSH
52499: LD_EXP 31
52503: PPUSH
52504: LD_VAR 0 4
52508: PPUSH
52509: EMPTY
52510: PPUSH
52511: CALL_OW 1
52515: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
52516: LD_ADDR_EXP 32
52520: PUSH
52521: LD_EXP 32
52525: PPUSH
52526: LD_VAR 0 4
52530: PPUSH
52531: EMPTY
52532: PPUSH
52533: CALL_OW 1
52537: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
52538: LD_ADDR_EXP 33
52542: PUSH
52543: LD_EXP 33
52547: PPUSH
52548: LD_VAR 0 4
52552: PPUSH
52553: EMPTY
52554: PPUSH
52555: CALL_OW 1
52559: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
52560: LD_ADDR_EXP 34
52564: PUSH
52565: LD_EXP 34
52569: PPUSH
52570: LD_VAR 0 4
52574: PPUSH
52575: LD_INT 0
52577: PPUSH
52578: CALL_OW 1
52582: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
52583: LD_ADDR_EXP 35
52587: PUSH
52588: LD_EXP 35
52592: PPUSH
52593: LD_VAR 0 4
52597: PPUSH
52598: EMPTY
52599: PPUSH
52600: CALL_OW 1
52604: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
52605: LD_ADDR_EXP 36
52609: PUSH
52610: LD_EXP 36
52614: PPUSH
52615: LD_VAR 0 4
52619: PPUSH
52620: EMPTY
52621: PPUSH
52622: CALL_OW 1
52626: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
52627: LD_ADDR_EXP 37
52631: PUSH
52632: LD_EXP 37
52636: PPUSH
52637: LD_VAR 0 4
52641: PPUSH
52642: EMPTY
52643: PPUSH
52644: CALL_OW 1
52648: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
52649: LD_ADDR_EXP 38
52653: PUSH
52654: LD_EXP 38
52658: PPUSH
52659: LD_VAR 0 4
52663: PPUSH
52664: EMPTY
52665: PPUSH
52666: CALL_OW 1
52670: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
52671: LD_ADDR_EXP 39
52675: PUSH
52676: LD_EXP 39
52680: PPUSH
52681: LD_VAR 0 4
52685: PPUSH
52686: EMPTY
52687: PPUSH
52688: CALL_OW 1
52692: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
52693: LD_ADDR_EXP 40
52697: PUSH
52698: LD_EXP 40
52702: PPUSH
52703: LD_VAR 0 4
52707: PPUSH
52708: EMPTY
52709: PPUSH
52710: CALL_OW 1
52714: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
52715: LD_ADDR_EXP 41
52719: PUSH
52720: LD_EXP 41
52724: PPUSH
52725: LD_VAR 0 4
52729: PPUSH
52730: EMPTY
52731: PPUSH
52732: CALL_OW 1
52736: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
52737: LD_ADDR_EXP 42
52741: PUSH
52742: LD_EXP 42
52746: PPUSH
52747: LD_VAR 0 4
52751: PPUSH
52752: EMPTY
52753: PPUSH
52754: CALL_OW 1
52758: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
52759: LD_ADDR_EXP 43
52763: PUSH
52764: LD_EXP 43
52768: PPUSH
52769: LD_VAR 0 4
52773: PPUSH
52774: EMPTY
52775: PPUSH
52776: CALL_OW 1
52780: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
52781: LD_ADDR_EXP 44
52785: PUSH
52786: LD_EXP 44
52790: PPUSH
52791: LD_VAR 0 4
52795: PPUSH
52796: EMPTY
52797: PPUSH
52798: CALL_OW 1
52802: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
52803: LD_ADDR_EXP 45
52807: PUSH
52808: LD_EXP 45
52812: PPUSH
52813: LD_VAR 0 4
52817: PPUSH
52818: EMPTY
52819: PPUSH
52820: CALL_OW 1
52824: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
52825: LD_ADDR_EXP 46
52829: PUSH
52830: LD_EXP 46
52834: PPUSH
52835: LD_VAR 0 4
52839: PPUSH
52840: EMPTY
52841: PPUSH
52842: CALL_OW 1
52846: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
52847: LD_ADDR_EXP 47
52851: PUSH
52852: LD_EXP 47
52856: PPUSH
52857: LD_VAR 0 4
52861: PPUSH
52862: EMPTY
52863: PPUSH
52864: CALL_OW 1
52868: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
52869: LD_ADDR_EXP 48
52873: PUSH
52874: LD_EXP 48
52878: PPUSH
52879: LD_VAR 0 4
52883: PPUSH
52884: EMPTY
52885: PPUSH
52886: CALL_OW 1
52890: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
52891: LD_ADDR_EXP 50
52895: PUSH
52896: LD_EXP 50
52900: PPUSH
52901: LD_VAR 0 4
52905: PPUSH
52906: EMPTY
52907: PPUSH
52908: CALL_OW 1
52912: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
52913: LD_ADDR_EXP 52
52917: PUSH
52918: LD_EXP 52
52922: PPUSH
52923: LD_VAR 0 4
52927: PPUSH
52928: EMPTY
52929: PPUSH
52930: CALL_OW 1
52934: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
52935: LD_ADDR_EXP 53
52939: PUSH
52940: LD_EXP 53
52944: PPUSH
52945: LD_VAR 0 4
52949: PPUSH
52950: EMPTY
52951: PPUSH
52952: CALL_OW 1
52956: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
52957: LD_ADDR_EXP 54
52961: PUSH
52962: LD_EXP 54
52966: PPUSH
52967: LD_VAR 0 4
52971: PPUSH
52972: EMPTY
52973: PPUSH
52974: CALL_OW 1
52978: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
52979: LD_ADDR_EXP 55
52983: PUSH
52984: LD_EXP 55
52988: PPUSH
52989: LD_VAR 0 4
52993: PPUSH
52994: EMPTY
52995: PPUSH
52996: CALL_OW 1
53000: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
53001: LD_ADDR_EXP 56
53005: PUSH
53006: LD_EXP 56
53010: PPUSH
53011: LD_VAR 0 4
53015: PPUSH
53016: EMPTY
53017: PPUSH
53018: CALL_OW 1
53022: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
53023: LD_ADDR_EXP 57
53027: PUSH
53028: LD_EXP 57
53032: PPUSH
53033: LD_VAR 0 4
53037: PPUSH
53038: EMPTY
53039: PPUSH
53040: CALL_OW 1
53044: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
53045: LD_ADDR_EXP 58
53049: PUSH
53050: LD_EXP 58
53054: PPUSH
53055: LD_VAR 0 4
53059: PPUSH
53060: EMPTY
53061: PPUSH
53062: CALL_OW 1
53066: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
53067: LD_ADDR_EXP 59
53071: PUSH
53072: LD_EXP 59
53076: PPUSH
53077: LD_VAR 0 4
53081: PPUSH
53082: EMPTY
53083: PPUSH
53084: CALL_OW 1
53088: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
53089: LD_ADDR_EXP 60
53093: PUSH
53094: LD_EXP 60
53098: PPUSH
53099: LD_VAR 0 4
53103: PPUSH
53104: EMPTY
53105: PPUSH
53106: CALL_OW 1
53110: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
53111: LD_ADDR_EXP 61
53115: PUSH
53116: LD_EXP 61
53120: PPUSH
53121: LD_VAR 0 4
53125: PPUSH
53126: EMPTY
53127: PPUSH
53128: CALL_OW 1
53132: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
53133: LD_ADDR_EXP 62
53137: PUSH
53138: LD_EXP 62
53142: PPUSH
53143: LD_VAR 0 4
53147: PPUSH
53148: EMPTY
53149: PPUSH
53150: CALL_OW 1
53154: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
53155: LD_ADDR_EXP 63
53159: PUSH
53160: LD_EXP 63
53164: PPUSH
53165: LD_VAR 0 4
53169: PPUSH
53170: EMPTY
53171: PPUSH
53172: CALL_OW 1
53176: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
53177: LD_ADDR_EXP 64
53181: PUSH
53182: LD_EXP 64
53186: PPUSH
53187: LD_VAR 0 4
53191: PPUSH
53192: EMPTY
53193: PPUSH
53194: CALL_OW 1
53198: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
53199: LD_ADDR_EXP 65
53203: PUSH
53204: LD_EXP 65
53208: PPUSH
53209: LD_VAR 0 4
53213: PPUSH
53214: LD_INT 0
53216: PPUSH
53217: CALL_OW 1
53221: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
53222: LD_ADDR_EXP 66
53226: PUSH
53227: LD_EXP 66
53231: PPUSH
53232: LD_VAR 0 4
53236: PPUSH
53237: LD_INT 0
53239: PPUSH
53240: CALL_OW 1
53244: ST_TO_ADDR
// result := base ;
53245: LD_ADDR_VAR 0 3
53249: PUSH
53250: LD_VAR 0 4
53254: ST_TO_ADDR
// end ;
53255: LD_VAR 0 3
53259: RET
// export function MC_Start ( ) ; var i ; begin
53260: LD_INT 0
53262: PPUSH
53263: PPUSH
// for i = 1 to mc_bases do
53264: LD_ADDR_VAR 0 2
53268: PUSH
53269: DOUBLE
53270: LD_INT 1
53272: DEC
53273: ST_TO_ADDR
53274: LD_EXP 23
53278: PUSH
53279: FOR_TO
53280: IFFALSE 54380
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
53282: LD_ADDR_EXP 23
53286: PUSH
53287: LD_EXP 23
53291: PPUSH
53292: LD_VAR 0 2
53296: PPUSH
53297: LD_EXP 23
53301: PUSH
53302: LD_VAR 0 2
53306: ARRAY
53307: PUSH
53308: LD_INT 0
53310: DIFF
53311: PPUSH
53312: CALL_OW 1
53316: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
53317: LD_ADDR_EXP 24
53321: PUSH
53322: LD_EXP 24
53326: PPUSH
53327: LD_VAR 0 2
53331: PPUSH
53332: EMPTY
53333: PPUSH
53334: CALL_OW 1
53338: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
53339: LD_ADDR_EXP 25
53343: PUSH
53344: LD_EXP 25
53348: PPUSH
53349: LD_VAR 0 2
53353: PPUSH
53354: EMPTY
53355: PPUSH
53356: CALL_OW 1
53360: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
53361: LD_ADDR_EXP 26
53365: PUSH
53366: LD_EXP 26
53370: PPUSH
53371: LD_VAR 0 2
53375: PPUSH
53376: EMPTY
53377: PPUSH
53378: CALL_OW 1
53382: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
53383: LD_ADDR_EXP 27
53387: PUSH
53388: LD_EXP 27
53392: PPUSH
53393: LD_VAR 0 2
53397: PPUSH
53398: EMPTY
53399: PUSH
53400: EMPTY
53401: PUSH
53402: EMPTY
53403: LIST
53404: LIST
53405: PPUSH
53406: CALL_OW 1
53410: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
53411: LD_ADDR_EXP 28
53415: PUSH
53416: LD_EXP 28
53420: PPUSH
53421: LD_VAR 0 2
53425: PPUSH
53426: EMPTY
53427: PPUSH
53428: CALL_OW 1
53432: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
53433: LD_ADDR_EXP 55
53437: PUSH
53438: LD_EXP 55
53442: PPUSH
53443: LD_VAR 0 2
53447: PPUSH
53448: EMPTY
53449: PPUSH
53450: CALL_OW 1
53454: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
53455: LD_ADDR_EXP 29
53459: PUSH
53460: LD_EXP 29
53464: PPUSH
53465: LD_VAR 0 2
53469: PPUSH
53470: EMPTY
53471: PPUSH
53472: CALL_OW 1
53476: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
53477: LD_ADDR_EXP 30
53481: PUSH
53482: LD_EXP 30
53486: PPUSH
53487: LD_VAR 0 2
53491: PPUSH
53492: EMPTY
53493: PPUSH
53494: CALL_OW 1
53498: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
53499: LD_ADDR_EXP 31
53503: PUSH
53504: LD_EXP 31
53508: PPUSH
53509: LD_VAR 0 2
53513: PPUSH
53514: LD_EXP 23
53518: PUSH
53519: LD_VAR 0 2
53523: ARRAY
53524: PPUSH
53525: LD_INT 2
53527: PUSH
53528: LD_INT 30
53530: PUSH
53531: LD_INT 32
53533: PUSH
53534: EMPTY
53535: LIST
53536: LIST
53537: PUSH
53538: LD_INT 30
53540: PUSH
53541: LD_INT 33
53543: PUSH
53544: EMPTY
53545: LIST
53546: LIST
53547: PUSH
53548: EMPTY
53549: LIST
53550: LIST
53551: LIST
53552: PPUSH
53553: CALL_OW 72
53557: PPUSH
53558: CALL_OW 1
53562: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
53563: LD_ADDR_EXP 32
53567: PUSH
53568: LD_EXP 32
53572: PPUSH
53573: LD_VAR 0 2
53577: PPUSH
53578: LD_EXP 23
53582: PUSH
53583: LD_VAR 0 2
53587: ARRAY
53588: PPUSH
53589: LD_INT 2
53591: PUSH
53592: LD_INT 30
53594: PUSH
53595: LD_INT 32
53597: PUSH
53598: EMPTY
53599: LIST
53600: LIST
53601: PUSH
53602: LD_INT 30
53604: PUSH
53605: LD_INT 31
53607: PUSH
53608: EMPTY
53609: LIST
53610: LIST
53611: PUSH
53612: EMPTY
53613: LIST
53614: LIST
53615: LIST
53616: PUSH
53617: LD_INT 58
53619: PUSH
53620: EMPTY
53621: LIST
53622: PUSH
53623: EMPTY
53624: LIST
53625: LIST
53626: PPUSH
53627: CALL_OW 72
53631: PPUSH
53632: CALL_OW 1
53636: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
53637: LD_ADDR_EXP 33
53641: PUSH
53642: LD_EXP 33
53646: PPUSH
53647: LD_VAR 0 2
53651: PPUSH
53652: EMPTY
53653: PPUSH
53654: CALL_OW 1
53658: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
53659: LD_ADDR_EXP 37
53663: PUSH
53664: LD_EXP 37
53668: PPUSH
53669: LD_VAR 0 2
53673: PPUSH
53674: EMPTY
53675: PPUSH
53676: CALL_OW 1
53680: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
53681: LD_ADDR_EXP 36
53685: PUSH
53686: LD_EXP 36
53690: PPUSH
53691: LD_VAR 0 2
53695: PPUSH
53696: EMPTY
53697: PPUSH
53698: CALL_OW 1
53702: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
53703: LD_ADDR_EXP 38
53707: PUSH
53708: LD_EXP 38
53712: PPUSH
53713: LD_VAR 0 2
53717: PPUSH
53718: EMPTY
53719: PPUSH
53720: CALL_OW 1
53724: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
53725: LD_ADDR_EXP 39
53729: PUSH
53730: LD_EXP 39
53734: PPUSH
53735: LD_VAR 0 2
53739: PPUSH
53740: EMPTY
53741: PPUSH
53742: CALL_OW 1
53746: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
53747: LD_ADDR_EXP 40
53751: PUSH
53752: LD_EXP 40
53756: PPUSH
53757: LD_VAR 0 2
53761: PPUSH
53762: EMPTY
53763: PPUSH
53764: CALL_OW 1
53768: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
53769: LD_ADDR_EXP 41
53773: PUSH
53774: LD_EXP 41
53778: PPUSH
53779: LD_VAR 0 2
53783: PPUSH
53784: EMPTY
53785: PPUSH
53786: CALL_OW 1
53790: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
53791: LD_ADDR_EXP 42
53795: PUSH
53796: LD_EXP 42
53800: PPUSH
53801: LD_VAR 0 2
53805: PPUSH
53806: EMPTY
53807: PPUSH
53808: CALL_OW 1
53812: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
53813: LD_ADDR_EXP 43
53817: PUSH
53818: LD_EXP 43
53822: PPUSH
53823: LD_VAR 0 2
53827: PPUSH
53828: EMPTY
53829: PPUSH
53830: CALL_OW 1
53834: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
53835: LD_ADDR_EXP 44
53839: PUSH
53840: LD_EXP 44
53844: PPUSH
53845: LD_VAR 0 2
53849: PPUSH
53850: EMPTY
53851: PPUSH
53852: CALL_OW 1
53856: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
53857: LD_ADDR_EXP 45
53861: PUSH
53862: LD_EXP 45
53866: PPUSH
53867: LD_VAR 0 2
53871: PPUSH
53872: EMPTY
53873: PPUSH
53874: CALL_OW 1
53878: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
53879: LD_ADDR_EXP 34
53883: PUSH
53884: LD_EXP 34
53888: PPUSH
53889: LD_VAR 0 2
53893: PPUSH
53894: LD_INT 0
53896: PPUSH
53897: CALL_OW 1
53901: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
53902: LD_ADDR_EXP 47
53906: PUSH
53907: LD_EXP 47
53911: PPUSH
53912: LD_VAR 0 2
53916: PPUSH
53917: LD_INT 0
53919: PPUSH
53920: CALL_OW 1
53924: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
53925: LD_ADDR_EXP 35
53929: PUSH
53930: LD_EXP 35
53934: PPUSH
53935: LD_VAR 0 2
53939: PPUSH
53940: EMPTY
53941: PPUSH
53942: CALL_OW 1
53946: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
53947: LD_ADDR_EXP 46
53951: PUSH
53952: LD_EXP 46
53956: PPUSH
53957: LD_VAR 0 2
53961: PPUSH
53962: LD_INT 0
53964: PPUSH
53965: CALL_OW 1
53969: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
53970: LD_ADDR_EXP 48
53974: PUSH
53975: LD_EXP 48
53979: PPUSH
53980: LD_VAR 0 2
53984: PPUSH
53985: EMPTY
53986: PPUSH
53987: CALL_OW 1
53991: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
53992: LD_ADDR_EXP 51
53996: PUSH
53997: LD_EXP 51
54001: PPUSH
54002: LD_VAR 0 2
54006: PPUSH
54007: LD_INT 0
54009: PPUSH
54010: CALL_OW 1
54014: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
54015: LD_ADDR_EXP 52
54019: PUSH
54020: LD_EXP 52
54024: PPUSH
54025: LD_VAR 0 2
54029: PPUSH
54030: EMPTY
54031: PPUSH
54032: CALL_OW 1
54036: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
54037: LD_ADDR_EXP 53
54041: PUSH
54042: LD_EXP 53
54046: PPUSH
54047: LD_VAR 0 2
54051: PPUSH
54052: EMPTY
54053: PPUSH
54054: CALL_OW 1
54058: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
54059: LD_ADDR_EXP 54
54063: PUSH
54064: LD_EXP 54
54068: PPUSH
54069: LD_VAR 0 2
54073: PPUSH
54074: EMPTY
54075: PPUSH
54076: CALL_OW 1
54080: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
54081: LD_ADDR_EXP 56
54085: PUSH
54086: LD_EXP 56
54090: PPUSH
54091: LD_VAR 0 2
54095: PPUSH
54096: LD_EXP 23
54100: PUSH
54101: LD_VAR 0 2
54105: ARRAY
54106: PPUSH
54107: LD_INT 2
54109: PUSH
54110: LD_INT 30
54112: PUSH
54113: LD_INT 6
54115: PUSH
54116: EMPTY
54117: LIST
54118: LIST
54119: PUSH
54120: LD_INT 30
54122: PUSH
54123: LD_INT 7
54125: PUSH
54126: EMPTY
54127: LIST
54128: LIST
54129: PUSH
54130: LD_INT 30
54132: PUSH
54133: LD_INT 8
54135: PUSH
54136: EMPTY
54137: LIST
54138: LIST
54139: PUSH
54140: EMPTY
54141: LIST
54142: LIST
54143: LIST
54144: LIST
54145: PPUSH
54146: CALL_OW 72
54150: PPUSH
54151: CALL_OW 1
54155: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
54156: LD_ADDR_EXP 57
54160: PUSH
54161: LD_EXP 57
54165: PPUSH
54166: LD_VAR 0 2
54170: PPUSH
54171: EMPTY
54172: PPUSH
54173: CALL_OW 1
54177: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
54178: LD_ADDR_EXP 58
54182: PUSH
54183: LD_EXP 58
54187: PPUSH
54188: LD_VAR 0 2
54192: PPUSH
54193: EMPTY
54194: PPUSH
54195: CALL_OW 1
54199: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
54200: LD_ADDR_EXP 59
54204: PUSH
54205: LD_EXP 59
54209: PPUSH
54210: LD_VAR 0 2
54214: PPUSH
54215: EMPTY
54216: PPUSH
54217: CALL_OW 1
54221: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
54222: LD_ADDR_EXP 60
54226: PUSH
54227: LD_EXP 60
54231: PPUSH
54232: LD_VAR 0 2
54236: PPUSH
54237: EMPTY
54238: PPUSH
54239: CALL_OW 1
54243: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54244: LD_ADDR_EXP 61
54248: PUSH
54249: LD_EXP 61
54253: PPUSH
54254: LD_VAR 0 2
54258: PPUSH
54259: EMPTY
54260: PPUSH
54261: CALL_OW 1
54265: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
54266: LD_ADDR_EXP 62
54270: PUSH
54271: LD_EXP 62
54275: PPUSH
54276: LD_VAR 0 2
54280: PPUSH
54281: EMPTY
54282: PPUSH
54283: CALL_OW 1
54287: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
54288: LD_ADDR_EXP 63
54292: PUSH
54293: LD_EXP 63
54297: PPUSH
54298: LD_VAR 0 2
54302: PPUSH
54303: EMPTY
54304: PPUSH
54305: CALL_OW 1
54309: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
54310: LD_ADDR_EXP 64
54314: PUSH
54315: LD_EXP 64
54319: PPUSH
54320: LD_VAR 0 2
54324: PPUSH
54325: EMPTY
54326: PPUSH
54327: CALL_OW 1
54331: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
54332: LD_ADDR_EXP 65
54336: PUSH
54337: LD_EXP 65
54341: PPUSH
54342: LD_VAR 0 2
54346: PPUSH
54347: LD_INT 0
54349: PPUSH
54350: CALL_OW 1
54354: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
54355: LD_ADDR_EXP 66
54359: PUSH
54360: LD_EXP 66
54364: PPUSH
54365: LD_VAR 0 2
54369: PPUSH
54370: LD_INT 0
54372: PPUSH
54373: CALL_OW 1
54377: ST_TO_ADDR
// end ;
54378: GO 53279
54380: POP
54381: POP
// MC_InitSides ( ) ;
54382: CALL 54668 0 0
// MC_InitResearch ( ) ;
54386: CALL 54407 0 0
// CustomInitMacro ( ) ;
54390: CALL 277 0 0
// skirmish := true ;
54394: LD_ADDR_EXP 21
54398: PUSH
54399: LD_INT 1
54401: ST_TO_ADDR
// end ;
54402: LD_VAR 0 1
54406: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
54407: LD_INT 0
54409: PPUSH
54410: PPUSH
54411: PPUSH
54412: PPUSH
54413: PPUSH
54414: PPUSH
// if not mc_bases then
54415: LD_EXP 23
54419: NOT
54420: IFFALSE 54424
// exit ;
54422: GO 54663
// for i = 1 to 8 do
54424: LD_ADDR_VAR 0 2
54428: PUSH
54429: DOUBLE
54430: LD_INT 1
54432: DEC
54433: ST_TO_ADDR
54434: LD_INT 8
54436: PUSH
54437: FOR_TO
54438: IFFALSE 54464
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
54440: LD_ADDR_EXP 50
54444: PUSH
54445: LD_EXP 50
54449: PPUSH
54450: LD_VAR 0 2
54454: PPUSH
54455: EMPTY
54456: PPUSH
54457: CALL_OW 1
54461: ST_TO_ADDR
54462: GO 54437
54464: POP
54465: POP
// tmp := [ ] ;
54466: LD_ADDR_VAR 0 5
54470: PUSH
54471: EMPTY
54472: ST_TO_ADDR
// for i = 1 to mc_sides do
54473: LD_ADDR_VAR 0 2
54477: PUSH
54478: DOUBLE
54479: LD_INT 1
54481: DEC
54482: ST_TO_ADDR
54483: LD_EXP 49
54487: PUSH
54488: FOR_TO
54489: IFFALSE 54547
// if not mc_sides [ i ] in tmp then
54491: LD_EXP 49
54495: PUSH
54496: LD_VAR 0 2
54500: ARRAY
54501: PUSH
54502: LD_VAR 0 5
54506: IN
54507: NOT
54508: IFFALSE 54545
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
54510: LD_ADDR_VAR 0 5
54514: PUSH
54515: LD_VAR 0 5
54519: PPUSH
54520: LD_VAR 0 5
54524: PUSH
54525: LD_INT 1
54527: PLUS
54528: PPUSH
54529: LD_EXP 49
54533: PUSH
54534: LD_VAR 0 2
54538: ARRAY
54539: PPUSH
54540: CALL_OW 2
54544: ST_TO_ADDR
54545: GO 54488
54547: POP
54548: POP
// if not tmp then
54549: LD_VAR 0 5
54553: NOT
54554: IFFALSE 54558
// exit ;
54556: GO 54663
// for j in tmp do
54558: LD_ADDR_VAR 0 3
54562: PUSH
54563: LD_VAR 0 5
54567: PUSH
54568: FOR_IN
54569: IFFALSE 54661
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
54571: LD_ADDR_VAR 0 6
54575: PUSH
54576: LD_INT 22
54578: PUSH
54579: LD_VAR 0 3
54583: PUSH
54584: EMPTY
54585: LIST
54586: LIST
54587: PPUSH
54588: CALL_OW 69
54592: ST_TO_ADDR
// if not un then
54593: LD_VAR 0 6
54597: NOT
54598: IFFALSE 54602
// continue ;
54600: GO 54568
// nation := GetNation ( un [ 1 ] ) ;
54602: LD_ADDR_VAR 0 4
54606: PUSH
54607: LD_VAR 0 6
54611: PUSH
54612: LD_INT 1
54614: ARRAY
54615: PPUSH
54616: CALL_OW 248
54620: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
54621: LD_ADDR_EXP 50
54625: PUSH
54626: LD_EXP 50
54630: PPUSH
54631: LD_VAR 0 3
54635: PPUSH
54636: LD_VAR 0 3
54640: PPUSH
54641: LD_VAR 0 4
54645: PPUSH
54646: LD_INT 1
54648: PPUSH
54649: CALL 11067 0 3
54653: PPUSH
54654: CALL_OW 1
54658: ST_TO_ADDR
// end ;
54659: GO 54568
54661: POP
54662: POP
// end ;
54663: LD_VAR 0 1
54667: RET
// export function MC_InitSides ( ) ; var i ; begin
54668: LD_INT 0
54670: PPUSH
54671: PPUSH
// if not mc_bases then
54672: LD_EXP 23
54676: NOT
54677: IFFALSE 54681
// exit ;
54679: GO 54755
// for i = 1 to mc_bases do
54681: LD_ADDR_VAR 0 2
54685: PUSH
54686: DOUBLE
54687: LD_INT 1
54689: DEC
54690: ST_TO_ADDR
54691: LD_EXP 23
54695: PUSH
54696: FOR_TO
54697: IFFALSE 54753
// if mc_bases [ i ] then
54699: LD_EXP 23
54703: PUSH
54704: LD_VAR 0 2
54708: ARRAY
54709: IFFALSE 54751
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
54711: LD_ADDR_EXP 49
54715: PUSH
54716: LD_EXP 49
54720: PPUSH
54721: LD_VAR 0 2
54725: PPUSH
54726: LD_EXP 23
54730: PUSH
54731: LD_VAR 0 2
54735: ARRAY
54736: PUSH
54737: LD_INT 1
54739: ARRAY
54740: PPUSH
54741: CALL_OW 255
54745: PPUSH
54746: CALL_OW 1
54750: ST_TO_ADDR
54751: GO 54696
54753: POP
54754: POP
// end ;
54755: LD_VAR 0 1
54759: RET
// every 0 0$03 trigger skirmish do
54760: LD_EXP 21
54764: IFFALSE 54918
54766: GO 54768
54768: DISABLE
// begin enable ;
54769: ENABLE
// MC_CheckBuildings ( ) ;
54770: CALL 59416 0 0
// MC_CheckPeopleLife ( ) ;
54774: CALL 59577 0 0
// RaiseSailEvent ( 100 ) ;
54778: LD_INT 100
54780: PPUSH
54781: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
54785: LD_INT 103
54787: PPUSH
54788: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
54792: LD_INT 104
54794: PPUSH
54795: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
54799: LD_INT 105
54801: PPUSH
54802: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
54806: LD_INT 106
54808: PPUSH
54809: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
54813: LD_INT 107
54815: PPUSH
54816: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
54820: LD_INT 108
54822: PPUSH
54823: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
54827: LD_INT 109
54829: PPUSH
54830: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
54834: LD_INT 110
54836: PPUSH
54837: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
54841: LD_INT 111
54843: PPUSH
54844: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
54848: LD_INT 112
54850: PPUSH
54851: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
54855: LD_INT 113
54857: PPUSH
54858: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
54862: LD_INT 120
54864: PPUSH
54865: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
54869: LD_INT 121
54871: PPUSH
54872: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
54876: LD_INT 122
54878: PPUSH
54879: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
54883: LD_INT 123
54885: PPUSH
54886: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
54890: LD_INT 124
54892: PPUSH
54893: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
54897: LD_INT 125
54899: PPUSH
54900: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
54904: LD_INT 126
54906: PPUSH
54907: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
54911: LD_INT 200
54913: PPUSH
54914: CALL_OW 427
// end ;
54918: END
// on SailEvent ( event ) do begin if event < 100 then
54919: LD_VAR 0 1
54923: PUSH
54924: LD_INT 100
54926: LESS
54927: IFFALSE 54938
// CustomEvent ( event ) ;
54929: LD_VAR 0 1
54933: PPUSH
54934: CALL 10241 0 1
// if event = 100 then
54938: LD_VAR 0 1
54942: PUSH
54943: LD_INT 100
54945: EQUAL
54946: IFFALSE 54952
// MC_ClassManager ( ) ;
54948: CALL 55344 0 0
// if event = 101 then
54952: LD_VAR 0 1
54956: PUSH
54957: LD_INT 101
54959: EQUAL
54960: IFFALSE 54966
// MC_RepairBuildings ( ) ;
54962: CALL 60162 0 0
// if event = 102 then
54966: LD_VAR 0 1
54970: PUSH
54971: LD_INT 102
54973: EQUAL
54974: IFFALSE 54980
// MC_Heal ( ) ;
54976: CALL 61069 0 0
// if event = 103 then
54980: LD_VAR 0 1
54984: PUSH
54985: LD_INT 103
54987: EQUAL
54988: IFFALSE 54994
// MC_Build ( ) ;
54990: CALL 61491 0 0
// if event = 104 then
54994: LD_VAR 0 1
54998: PUSH
54999: LD_INT 104
55001: EQUAL
55002: IFFALSE 55008
// MC_TurretWeapon ( ) ;
55004: CALL 63132 0 0
// if event = 105 then
55008: LD_VAR 0 1
55012: PUSH
55013: LD_INT 105
55015: EQUAL
55016: IFFALSE 55022
// MC_BuildUpgrade ( ) ;
55018: CALL 62683 0 0
// if event = 106 then
55022: LD_VAR 0 1
55026: PUSH
55027: LD_INT 106
55029: EQUAL
55030: IFFALSE 55036
// MC_PlantMines ( ) ;
55032: CALL 63562 0 0
// if event = 107 then
55036: LD_VAR 0 1
55040: PUSH
55041: LD_INT 107
55043: EQUAL
55044: IFFALSE 55050
// MC_CollectCrates ( ) ;
55046: CALL 64353 0 0
// if event = 108 then
55050: LD_VAR 0 1
55054: PUSH
55055: LD_INT 108
55057: EQUAL
55058: IFFALSE 55064
// MC_LinkRemoteControl ( ) ;
55060: CALL 66203 0 0
// if event = 109 then
55064: LD_VAR 0 1
55068: PUSH
55069: LD_INT 109
55071: EQUAL
55072: IFFALSE 55078
// MC_ProduceVehicle ( ) ;
55074: CALL 66384 0 0
// if event = 110 then
55078: LD_VAR 0 1
55082: PUSH
55083: LD_INT 110
55085: EQUAL
55086: IFFALSE 55092
// MC_SendAttack ( ) ;
55088: CALL 66850 0 0
// if event = 111 then
55092: LD_VAR 0 1
55096: PUSH
55097: LD_INT 111
55099: EQUAL
55100: IFFALSE 55106
// MC_Defend ( ) ;
55102: CALL 66958 0 0
// if event = 112 then
55106: LD_VAR 0 1
55110: PUSH
55111: LD_INT 112
55113: EQUAL
55114: IFFALSE 55120
// MC_Research ( ) ;
55116: CALL 67838 0 0
// if event = 113 then
55120: LD_VAR 0 1
55124: PUSH
55125: LD_INT 113
55127: EQUAL
55128: IFFALSE 55134
// MC_MinesTrigger ( ) ;
55130: CALL 68952 0 0
// if event = 120 then
55134: LD_VAR 0 1
55138: PUSH
55139: LD_INT 120
55141: EQUAL
55142: IFFALSE 55148
// MC_RepairVehicle ( ) ;
55144: CALL 69051 0 0
// if event = 121 then
55148: LD_VAR 0 1
55152: PUSH
55153: LD_INT 121
55155: EQUAL
55156: IFFALSE 55162
// MC_TameApe ( ) ;
55158: CALL 69792 0 0
// if event = 122 then
55162: LD_VAR 0 1
55166: PUSH
55167: LD_INT 122
55169: EQUAL
55170: IFFALSE 55176
// MC_ChangeApeClass ( ) ;
55172: CALL 70621 0 0
// if event = 123 then
55176: LD_VAR 0 1
55180: PUSH
55181: LD_INT 123
55183: EQUAL
55184: IFFALSE 55190
// MC_Bazooka ( ) ;
55186: CALL 71271 0 0
// if event = 124 then
55190: LD_VAR 0 1
55194: PUSH
55195: LD_INT 124
55197: EQUAL
55198: IFFALSE 55204
// MC_TeleportExit ( ) ;
55200: CALL 71469 0 0
// if event = 125 then
55204: LD_VAR 0 1
55208: PUSH
55209: LD_INT 125
55211: EQUAL
55212: IFFALSE 55218
// MC_Deposits ( ) ;
55214: CALL 72116 0 0
// if event = 126 then
55218: LD_VAR 0 1
55222: PUSH
55223: LD_INT 126
55225: EQUAL
55226: IFFALSE 55232
// MC_RemoteDriver ( ) ;
55228: CALL 72741 0 0
// if event = 200 then
55232: LD_VAR 0 1
55236: PUSH
55237: LD_INT 200
55239: EQUAL
55240: IFFALSE 55246
// MC_Idle ( ) ;
55242: CALL 74690 0 0
// end ;
55246: PPOPN 1
55248: END
// export function MC_Reset ( base , tag ) ; var i ; begin
55249: LD_INT 0
55251: PPUSH
55252: PPUSH
// if not mc_bases [ base ] or not tag then
55253: LD_EXP 23
55257: PUSH
55258: LD_VAR 0 1
55262: ARRAY
55263: NOT
55264: PUSH
55265: LD_VAR 0 2
55269: NOT
55270: OR
55271: IFFALSE 55275
// exit ;
55273: GO 55339
// for i in mc_bases [ base ] union mc_ape [ base ] do
55275: LD_ADDR_VAR 0 4
55279: PUSH
55280: LD_EXP 23
55284: PUSH
55285: LD_VAR 0 1
55289: ARRAY
55290: PUSH
55291: LD_EXP 52
55295: PUSH
55296: LD_VAR 0 1
55300: ARRAY
55301: UNION
55302: PUSH
55303: FOR_IN
55304: IFFALSE 55337
// if GetTag ( i ) = tag then
55306: LD_VAR 0 4
55310: PPUSH
55311: CALL_OW 110
55315: PUSH
55316: LD_VAR 0 2
55320: EQUAL
55321: IFFALSE 55335
// SetTag ( i , 0 ) ;
55323: LD_VAR 0 4
55327: PPUSH
55328: LD_INT 0
55330: PPUSH
55331: CALL_OW 109
55335: GO 55303
55337: POP
55338: POP
// end ;
55339: LD_VAR 0 3
55343: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
55344: LD_INT 0
55346: PPUSH
55347: PPUSH
55348: PPUSH
55349: PPUSH
55350: PPUSH
55351: PPUSH
55352: PPUSH
55353: PPUSH
// if not mc_bases then
55354: LD_EXP 23
55358: NOT
55359: IFFALSE 55363
// exit ;
55361: GO 55821
// for i = 1 to mc_bases do
55363: LD_ADDR_VAR 0 2
55367: PUSH
55368: DOUBLE
55369: LD_INT 1
55371: DEC
55372: ST_TO_ADDR
55373: LD_EXP 23
55377: PUSH
55378: FOR_TO
55379: IFFALSE 55819
// begin tmp := MC_ClassCheckReq ( i ) ;
55381: LD_ADDR_VAR 0 4
55385: PUSH
55386: LD_VAR 0 2
55390: PPUSH
55391: CALL 55826 0 1
55395: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
55396: LD_ADDR_EXP 64
55400: PUSH
55401: LD_EXP 64
55405: PPUSH
55406: LD_VAR 0 2
55410: PPUSH
55411: LD_VAR 0 4
55415: PPUSH
55416: CALL_OW 1
55420: ST_TO_ADDR
// if not tmp then
55421: LD_VAR 0 4
55425: NOT
55426: IFFALSE 55430
// continue ;
55428: GO 55378
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
55430: LD_ADDR_VAR 0 6
55434: PUSH
55435: LD_EXP 23
55439: PUSH
55440: LD_VAR 0 2
55444: ARRAY
55445: PPUSH
55446: LD_INT 2
55448: PUSH
55449: LD_INT 30
55451: PUSH
55452: LD_INT 4
55454: PUSH
55455: EMPTY
55456: LIST
55457: LIST
55458: PUSH
55459: LD_INT 30
55461: PUSH
55462: LD_INT 5
55464: PUSH
55465: EMPTY
55466: LIST
55467: LIST
55468: PUSH
55469: EMPTY
55470: LIST
55471: LIST
55472: LIST
55473: PPUSH
55474: CALL_OW 72
55478: PUSH
55479: LD_EXP 23
55483: PUSH
55484: LD_VAR 0 2
55488: ARRAY
55489: PPUSH
55490: LD_INT 2
55492: PUSH
55493: LD_INT 30
55495: PUSH
55496: LD_INT 0
55498: PUSH
55499: EMPTY
55500: LIST
55501: LIST
55502: PUSH
55503: LD_INT 30
55505: PUSH
55506: LD_INT 1
55508: PUSH
55509: EMPTY
55510: LIST
55511: LIST
55512: PUSH
55513: EMPTY
55514: LIST
55515: LIST
55516: LIST
55517: PPUSH
55518: CALL_OW 72
55522: PUSH
55523: LD_EXP 23
55527: PUSH
55528: LD_VAR 0 2
55532: ARRAY
55533: PPUSH
55534: LD_INT 30
55536: PUSH
55537: LD_INT 3
55539: PUSH
55540: EMPTY
55541: LIST
55542: LIST
55543: PPUSH
55544: CALL_OW 72
55548: PUSH
55549: LD_EXP 23
55553: PUSH
55554: LD_VAR 0 2
55558: ARRAY
55559: PPUSH
55560: LD_INT 2
55562: PUSH
55563: LD_INT 30
55565: PUSH
55566: LD_INT 6
55568: PUSH
55569: EMPTY
55570: LIST
55571: LIST
55572: PUSH
55573: LD_INT 30
55575: PUSH
55576: LD_INT 7
55578: PUSH
55579: EMPTY
55580: LIST
55581: LIST
55582: PUSH
55583: LD_INT 30
55585: PUSH
55586: LD_INT 8
55588: PUSH
55589: EMPTY
55590: LIST
55591: LIST
55592: PUSH
55593: EMPTY
55594: LIST
55595: LIST
55596: LIST
55597: LIST
55598: PPUSH
55599: CALL_OW 72
55603: PUSH
55604: EMPTY
55605: LIST
55606: LIST
55607: LIST
55608: LIST
55609: ST_TO_ADDR
// for j = 1 to 4 do
55610: LD_ADDR_VAR 0 3
55614: PUSH
55615: DOUBLE
55616: LD_INT 1
55618: DEC
55619: ST_TO_ADDR
55620: LD_INT 4
55622: PUSH
55623: FOR_TO
55624: IFFALSE 55815
// begin if not tmp [ j ] then
55626: LD_VAR 0 4
55630: PUSH
55631: LD_VAR 0 3
55635: ARRAY
55636: NOT
55637: IFFALSE 55641
// continue ;
55639: GO 55623
// for p in tmp [ j ] do
55641: LD_ADDR_VAR 0 5
55645: PUSH
55646: LD_VAR 0 4
55650: PUSH
55651: LD_VAR 0 3
55655: ARRAY
55656: PUSH
55657: FOR_IN
55658: IFFALSE 55811
// begin if not b [ j ] then
55660: LD_VAR 0 6
55664: PUSH
55665: LD_VAR 0 3
55669: ARRAY
55670: NOT
55671: IFFALSE 55675
// break ;
55673: GO 55811
// e := 0 ;
55675: LD_ADDR_VAR 0 7
55679: PUSH
55680: LD_INT 0
55682: ST_TO_ADDR
// for k in b [ j ] do
55683: LD_ADDR_VAR 0 8
55687: PUSH
55688: LD_VAR 0 6
55692: PUSH
55693: LD_VAR 0 3
55697: ARRAY
55698: PUSH
55699: FOR_IN
55700: IFFALSE 55727
// if IsNotFull ( k ) then
55702: LD_VAR 0 8
55706: PPUSH
55707: CALL 13220 0 1
55711: IFFALSE 55725
// begin e := k ;
55713: LD_ADDR_VAR 0 7
55717: PUSH
55718: LD_VAR 0 8
55722: ST_TO_ADDR
// break ;
55723: GO 55727
// end ;
55725: GO 55699
55727: POP
55728: POP
// if e and not UnitGoingToBuilding ( p , e ) then
55729: LD_VAR 0 7
55733: PUSH
55734: LD_VAR 0 5
55738: PPUSH
55739: LD_VAR 0 7
55743: PPUSH
55744: CALL 46384 0 2
55748: NOT
55749: AND
55750: IFFALSE 55809
// begin if IsInUnit ( p ) then
55752: LD_VAR 0 5
55756: PPUSH
55757: CALL_OW 310
55761: IFFALSE 55772
// ComExitBuilding ( p ) ;
55763: LD_VAR 0 5
55767: PPUSH
55768: CALL_OW 122
// ComEnterUnit ( p , e ) ;
55772: LD_VAR 0 5
55776: PPUSH
55777: LD_VAR 0 7
55781: PPUSH
55782: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
55786: LD_VAR 0 5
55790: PPUSH
55791: LD_VAR 0 3
55795: PPUSH
55796: CALL_OW 183
// AddComExitBuilding ( p ) ;
55800: LD_VAR 0 5
55804: PPUSH
55805: CALL_OW 182
// end ; end ;
55809: GO 55657
55811: POP
55812: POP
// end ;
55813: GO 55623
55815: POP
55816: POP
// end ;
55817: GO 55378
55819: POP
55820: POP
// end ;
55821: LD_VAR 0 1
55825: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
55826: LD_INT 0
55828: PPUSH
55829: PPUSH
55830: PPUSH
55831: PPUSH
55832: PPUSH
55833: PPUSH
55834: PPUSH
55835: PPUSH
55836: PPUSH
55837: PPUSH
55838: PPUSH
55839: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
55840: LD_VAR 0 1
55844: NOT
55845: PUSH
55846: LD_EXP 23
55850: PUSH
55851: LD_VAR 0 1
55855: ARRAY
55856: NOT
55857: OR
55858: PUSH
55859: LD_EXP 23
55863: PUSH
55864: LD_VAR 0 1
55868: ARRAY
55869: PPUSH
55870: LD_INT 2
55872: PUSH
55873: LD_INT 30
55875: PUSH
55876: LD_INT 0
55878: PUSH
55879: EMPTY
55880: LIST
55881: LIST
55882: PUSH
55883: LD_INT 30
55885: PUSH
55886: LD_INT 1
55888: PUSH
55889: EMPTY
55890: LIST
55891: LIST
55892: PUSH
55893: EMPTY
55894: LIST
55895: LIST
55896: LIST
55897: PPUSH
55898: CALL_OW 72
55902: NOT
55903: OR
55904: IFFALSE 55908
// exit ;
55906: GO 59411
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
55908: LD_ADDR_VAR 0 4
55912: PUSH
55913: LD_EXP 23
55917: PUSH
55918: LD_VAR 0 1
55922: ARRAY
55923: PPUSH
55924: LD_INT 2
55926: PUSH
55927: LD_INT 25
55929: PUSH
55930: LD_INT 1
55932: PUSH
55933: EMPTY
55934: LIST
55935: LIST
55936: PUSH
55937: LD_INT 25
55939: PUSH
55940: LD_INT 2
55942: PUSH
55943: EMPTY
55944: LIST
55945: LIST
55946: PUSH
55947: LD_INT 25
55949: PUSH
55950: LD_INT 3
55952: PUSH
55953: EMPTY
55954: LIST
55955: LIST
55956: PUSH
55957: LD_INT 25
55959: PUSH
55960: LD_INT 4
55962: PUSH
55963: EMPTY
55964: LIST
55965: LIST
55966: PUSH
55967: LD_INT 25
55969: PUSH
55970: LD_INT 5
55972: PUSH
55973: EMPTY
55974: LIST
55975: LIST
55976: PUSH
55977: LD_INT 25
55979: PUSH
55980: LD_INT 8
55982: PUSH
55983: EMPTY
55984: LIST
55985: LIST
55986: PUSH
55987: LD_INT 25
55989: PUSH
55990: LD_INT 9
55992: PUSH
55993: EMPTY
55994: LIST
55995: LIST
55996: PUSH
55997: EMPTY
55998: LIST
55999: LIST
56000: LIST
56001: LIST
56002: LIST
56003: LIST
56004: LIST
56005: LIST
56006: PPUSH
56007: CALL_OW 72
56011: ST_TO_ADDR
// if not tmp then
56012: LD_VAR 0 4
56016: NOT
56017: IFFALSE 56021
// exit ;
56019: GO 59411
// for i in tmp do
56021: LD_ADDR_VAR 0 3
56025: PUSH
56026: LD_VAR 0 4
56030: PUSH
56031: FOR_IN
56032: IFFALSE 56063
// if GetTag ( i ) then
56034: LD_VAR 0 3
56038: PPUSH
56039: CALL_OW 110
56043: IFFALSE 56061
// tmp := tmp diff i ;
56045: LD_ADDR_VAR 0 4
56049: PUSH
56050: LD_VAR 0 4
56054: PUSH
56055: LD_VAR 0 3
56059: DIFF
56060: ST_TO_ADDR
56061: GO 56031
56063: POP
56064: POP
// if not tmp then
56065: LD_VAR 0 4
56069: NOT
56070: IFFALSE 56074
// exit ;
56072: GO 59411
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
56074: LD_ADDR_VAR 0 5
56078: PUSH
56079: LD_EXP 23
56083: PUSH
56084: LD_VAR 0 1
56088: ARRAY
56089: PPUSH
56090: LD_INT 2
56092: PUSH
56093: LD_INT 25
56095: PUSH
56096: LD_INT 1
56098: PUSH
56099: EMPTY
56100: LIST
56101: LIST
56102: PUSH
56103: LD_INT 25
56105: PUSH
56106: LD_INT 5
56108: PUSH
56109: EMPTY
56110: LIST
56111: LIST
56112: PUSH
56113: LD_INT 25
56115: PUSH
56116: LD_INT 8
56118: PUSH
56119: EMPTY
56120: LIST
56121: LIST
56122: PUSH
56123: LD_INT 25
56125: PUSH
56126: LD_INT 9
56128: PUSH
56129: EMPTY
56130: LIST
56131: LIST
56132: PUSH
56133: EMPTY
56134: LIST
56135: LIST
56136: LIST
56137: LIST
56138: LIST
56139: PPUSH
56140: CALL_OW 72
56144: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
56145: LD_ADDR_VAR 0 6
56149: PUSH
56150: LD_EXP 23
56154: PUSH
56155: LD_VAR 0 1
56159: ARRAY
56160: PPUSH
56161: LD_INT 25
56163: PUSH
56164: LD_INT 2
56166: PUSH
56167: EMPTY
56168: LIST
56169: LIST
56170: PPUSH
56171: CALL_OW 72
56175: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
56176: LD_ADDR_VAR 0 7
56180: PUSH
56181: LD_EXP 23
56185: PUSH
56186: LD_VAR 0 1
56190: ARRAY
56191: PPUSH
56192: LD_INT 25
56194: PUSH
56195: LD_INT 3
56197: PUSH
56198: EMPTY
56199: LIST
56200: LIST
56201: PPUSH
56202: CALL_OW 72
56206: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
56207: LD_ADDR_VAR 0 8
56211: PUSH
56212: LD_EXP 23
56216: PUSH
56217: LD_VAR 0 1
56221: ARRAY
56222: PPUSH
56223: LD_INT 25
56225: PUSH
56226: LD_INT 4
56228: PUSH
56229: EMPTY
56230: LIST
56231: LIST
56232: PUSH
56233: LD_INT 24
56235: PUSH
56236: LD_INT 251
56238: PUSH
56239: EMPTY
56240: LIST
56241: LIST
56242: PUSH
56243: EMPTY
56244: LIST
56245: LIST
56246: PPUSH
56247: CALL_OW 72
56251: ST_TO_ADDR
// if mc_is_defending [ base ] then
56252: LD_EXP 66
56256: PUSH
56257: LD_VAR 0 1
56261: ARRAY
56262: IFFALSE 56723
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
56264: LD_ADDR_EXP 65
56268: PUSH
56269: LD_EXP 65
56273: PPUSH
56274: LD_VAR 0 1
56278: PPUSH
56279: LD_INT 4
56281: PPUSH
56282: CALL_OW 1
56286: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
56287: LD_ADDR_VAR 0 12
56291: PUSH
56292: LD_EXP 23
56296: PUSH
56297: LD_VAR 0 1
56301: ARRAY
56302: PPUSH
56303: LD_INT 2
56305: PUSH
56306: LD_INT 30
56308: PUSH
56309: LD_INT 4
56311: PUSH
56312: EMPTY
56313: LIST
56314: LIST
56315: PUSH
56316: LD_INT 30
56318: PUSH
56319: LD_INT 5
56321: PUSH
56322: EMPTY
56323: LIST
56324: LIST
56325: PUSH
56326: EMPTY
56327: LIST
56328: LIST
56329: LIST
56330: PPUSH
56331: CALL_OW 72
56335: ST_TO_ADDR
// if not b then
56336: LD_VAR 0 12
56340: NOT
56341: IFFALSE 56345
// exit ;
56343: GO 59411
// p := [ ] ;
56345: LD_ADDR_VAR 0 11
56349: PUSH
56350: EMPTY
56351: ST_TO_ADDR
// if sci >= 2 then
56352: LD_VAR 0 8
56356: PUSH
56357: LD_INT 2
56359: GREATEREQUAL
56360: IFFALSE 56391
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
56362: LD_ADDR_VAR 0 8
56366: PUSH
56367: LD_VAR 0 8
56371: PUSH
56372: LD_INT 1
56374: ARRAY
56375: PUSH
56376: LD_VAR 0 8
56380: PUSH
56381: LD_INT 2
56383: ARRAY
56384: PUSH
56385: EMPTY
56386: LIST
56387: LIST
56388: ST_TO_ADDR
56389: GO 56452
// if sci = 1 then
56391: LD_VAR 0 8
56395: PUSH
56396: LD_INT 1
56398: EQUAL
56399: IFFALSE 56420
// sci := [ sci [ 1 ] ] else
56401: LD_ADDR_VAR 0 8
56405: PUSH
56406: LD_VAR 0 8
56410: PUSH
56411: LD_INT 1
56413: ARRAY
56414: PUSH
56415: EMPTY
56416: LIST
56417: ST_TO_ADDR
56418: GO 56452
// if sci = 0 then
56420: LD_VAR 0 8
56424: PUSH
56425: LD_INT 0
56427: EQUAL
56428: IFFALSE 56452
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
56430: LD_ADDR_VAR 0 11
56434: PUSH
56435: LD_VAR 0 4
56439: PPUSH
56440: LD_INT 4
56442: PPUSH
56443: CALL 46247 0 2
56447: PUSH
56448: LD_INT 1
56450: ARRAY
56451: ST_TO_ADDR
// if eng > 4 then
56452: LD_VAR 0 6
56456: PUSH
56457: LD_INT 4
56459: GREATER
56460: IFFALSE 56506
// for i = eng downto 4 do
56462: LD_ADDR_VAR 0 3
56466: PUSH
56467: DOUBLE
56468: LD_VAR 0 6
56472: INC
56473: ST_TO_ADDR
56474: LD_INT 4
56476: PUSH
56477: FOR_DOWNTO
56478: IFFALSE 56504
// eng := eng diff eng [ i ] ;
56480: LD_ADDR_VAR 0 6
56484: PUSH
56485: LD_VAR 0 6
56489: PUSH
56490: LD_VAR 0 6
56494: PUSH
56495: LD_VAR 0 3
56499: ARRAY
56500: DIFF
56501: ST_TO_ADDR
56502: GO 56477
56504: POP
56505: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
56506: LD_ADDR_VAR 0 4
56510: PUSH
56511: LD_VAR 0 4
56515: PUSH
56516: LD_VAR 0 5
56520: PUSH
56521: LD_VAR 0 6
56525: UNION
56526: PUSH
56527: LD_VAR 0 7
56531: UNION
56532: PUSH
56533: LD_VAR 0 8
56537: UNION
56538: DIFF
56539: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
56540: LD_ADDR_VAR 0 13
56544: PUSH
56545: LD_EXP 23
56549: PUSH
56550: LD_VAR 0 1
56554: ARRAY
56555: PPUSH
56556: LD_INT 2
56558: PUSH
56559: LD_INT 30
56561: PUSH
56562: LD_INT 32
56564: PUSH
56565: EMPTY
56566: LIST
56567: LIST
56568: PUSH
56569: LD_INT 30
56571: PUSH
56572: LD_INT 31
56574: PUSH
56575: EMPTY
56576: LIST
56577: LIST
56578: PUSH
56579: EMPTY
56580: LIST
56581: LIST
56582: LIST
56583: PPUSH
56584: CALL_OW 72
56588: PUSH
56589: LD_EXP 23
56593: PUSH
56594: LD_VAR 0 1
56598: ARRAY
56599: PPUSH
56600: LD_INT 2
56602: PUSH
56603: LD_INT 30
56605: PUSH
56606: LD_INT 4
56608: PUSH
56609: EMPTY
56610: LIST
56611: LIST
56612: PUSH
56613: LD_INT 30
56615: PUSH
56616: LD_INT 5
56618: PUSH
56619: EMPTY
56620: LIST
56621: LIST
56622: PUSH
56623: EMPTY
56624: LIST
56625: LIST
56626: LIST
56627: PPUSH
56628: CALL_OW 72
56632: PUSH
56633: LD_INT 6
56635: MUL
56636: PLUS
56637: ST_TO_ADDR
// if bcount < tmp then
56638: LD_VAR 0 13
56642: PUSH
56643: LD_VAR 0 4
56647: LESS
56648: IFFALSE 56694
// for i = tmp downto bcount do
56650: LD_ADDR_VAR 0 3
56654: PUSH
56655: DOUBLE
56656: LD_VAR 0 4
56660: INC
56661: ST_TO_ADDR
56662: LD_VAR 0 13
56666: PUSH
56667: FOR_DOWNTO
56668: IFFALSE 56692
// tmp := Delete ( tmp , tmp ) ;
56670: LD_ADDR_VAR 0 4
56674: PUSH
56675: LD_VAR 0 4
56679: PPUSH
56680: LD_VAR 0 4
56684: PPUSH
56685: CALL_OW 3
56689: ST_TO_ADDR
56690: GO 56667
56692: POP
56693: POP
// result := [ tmp , 0 , 0 , p ] ;
56694: LD_ADDR_VAR 0 2
56698: PUSH
56699: LD_VAR 0 4
56703: PUSH
56704: LD_INT 0
56706: PUSH
56707: LD_INT 0
56709: PUSH
56710: LD_VAR 0 11
56714: PUSH
56715: EMPTY
56716: LIST
56717: LIST
56718: LIST
56719: LIST
56720: ST_TO_ADDR
// exit ;
56721: GO 59411
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56723: LD_EXP 23
56727: PUSH
56728: LD_VAR 0 1
56732: ARRAY
56733: PPUSH
56734: LD_INT 2
56736: PUSH
56737: LD_INT 30
56739: PUSH
56740: LD_INT 6
56742: PUSH
56743: EMPTY
56744: LIST
56745: LIST
56746: PUSH
56747: LD_INT 30
56749: PUSH
56750: LD_INT 7
56752: PUSH
56753: EMPTY
56754: LIST
56755: LIST
56756: PUSH
56757: LD_INT 30
56759: PUSH
56760: LD_INT 8
56762: PUSH
56763: EMPTY
56764: LIST
56765: LIST
56766: PUSH
56767: EMPTY
56768: LIST
56769: LIST
56770: LIST
56771: LIST
56772: PPUSH
56773: CALL_OW 72
56777: NOT
56778: PUSH
56779: LD_EXP 23
56783: PUSH
56784: LD_VAR 0 1
56788: ARRAY
56789: PPUSH
56790: LD_INT 30
56792: PUSH
56793: LD_INT 3
56795: PUSH
56796: EMPTY
56797: LIST
56798: LIST
56799: PPUSH
56800: CALL_OW 72
56804: NOT
56805: AND
56806: IFFALSE 56878
// begin if eng = tmp then
56808: LD_VAR 0 6
56812: PUSH
56813: LD_VAR 0 4
56817: EQUAL
56818: IFFALSE 56822
// exit ;
56820: GO 59411
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
56822: LD_ADDR_EXP 65
56826: PUSH
56827: LD_EXP 65
56831: PPUSH
56832: LD_VAR 0 1
56836: PPUSH
56837: LD_INT 1
56839: PPUSH
56840: CALL_OW 1
56844: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
56845: LD_ADDR_VAR 0 2
56849: PUSH
56850: LD_INT 0
56852: PUSH
56853: LD_VAR 0 4
56857: PUSH
56858: LD_VAR 0 6
56862: DIFF
56863: PUSH
56864: LD_INT 0
56866: PUSH
56867: LD_INT 0
56869: PUSH
56870: EMPTY
56871: LIST
56872: LIST
56873: LIST
56874: LIST
56875: ST_TO_ADDR
// exit ;
56876: GO 59411
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56878: LD_EXP 50
56882: PUSH
56883: LD_EXP 49
56887: PUSH
56888: LD_VAR 0 1
56892: ARRAY
56893: ARRAY
56894: PUSH
56895: LD_EXP 23
56899: PUSH
56900: LD_VAR 0 1
56904: ARRAY
56905: PPUSH
56906: LD_INT 2
56908: PUSH
56909: LD_INT 30
56911: PUSH
56912: LD_INT 6
56914: PUSH
56915: EMPTY
56916: LIST
56917: LIST
56918: PUSH
56919: LD_INT 30
56921: PUSH
56922: LD_INT 7
56924: PUSH
56925: EMPTY
56926: LIST
56927: LIST
56928: PUSH
56929: LD_INT 30
56931: PUSH
56932: LD_INT 8
56934: PUSH
56935: EMPTY
56936: LIST
56937: LIST
56938: PUSH
56939: EMPTY
56940: LIST
56941: LIST
56942: LIST
56943: LIST
56944: PPUSH
56945: CALL_OW 72
56949: AND
56950: PUSH
56951: LD_EXP 23
56955: PUSH
56956: LD_VAR 0 1
56960: ARRAY
56961: PPUSH
56962: LD_INT 30
56964: PUSH
56965: LD_INT 3
56967: PUSH
56968: EMPTY
56969: LIST
56970: LIST
56971: PPUSH
56972: CALL_OW 72
56976: NOT
56977: AND
56978: IFFALSE 57192
// begin if sci >= 6 then
56980: LD_VAR 0 8
56984: PUSH
56985: LD_INT 6
56987: GREATEREQUAL
56988: IFFALSE 56992
// exit ;
56990: GO 59411
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
56992: LD_ADDR_EXP 65
56996: PUSH
56997: LD_EXP 65
57001: PPUSH
57002: LD_VAR 0 1
57006: PPUSH
57007: LD_INT 2
57009: PPUSH
57010: CALL_OW 1
57014: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
57015: LD_ADDR_VAR 0 9
57019: PUSH
57020: LD_VAR 0 4
57024: PUSH
57025: LD_VAR 0 8
57029: DIFF
57030: PPUSH
57031: LD_INT 4
57033: PPUSH
57034: CALL 46247 0 2
57038: ST_TO_ADDR
// p := [ ] ;
57039: LD_ADDR_VAR 0 11
57043: PUSH
57044: EMPTY
57045: ST_TO_ADDR
// if sci < 6 and sort > 6 then
57046: LD_VAR 0 8
57050: PUSH
57051: LD_INT 6
57053: LESS
57054: PUSH
57055: LD_VAR 0 9
57059: PUSH
57060: LD_INT 6
57062: GREATER
57063: AND
57064: IFFALSE 57145
// begin for i = 1 to 6 - sci do
57066: LD_ADDR_VAR 0 3
57070: PUSH
57071: DOUBLE
57072: LD_INT 1
57074: DEC
57075: ST_TO_ADDR
57076: LD_INT 6
57078: PUSH
57079: LD_VAR 0 8
57083: MINUS
57084: PUSH
57085: FOR_TO
57086: IFFALSE 57141
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
57088: LD_ADDR_VAR 0 11
57092: PUSH
57093: LD_VAR 0 11
57097: PPUSH
57098: LD_VAR 0 11
57102: PUSH
57103: LD_INT 1
57105: PLUS
57106: PPUSH
57107: LD_VAR 0 9
57111: PUSH
57112: LD_INT 1
57114: ARRAY
57115: PPUSH
57116: CALL_OW 2
57120: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
57121: LD_ADDR_VAR 0 9
57125: PUSH
57126: LD_VAR 0 9
57130: PPUSH
57131: LD_INT 1
57133: PPUSH
57134: CALL_OW 3
57138: ST_TO_ADDR
// end ;
57139: GO 57085
57141: POP
57142: POP
// end else
57143: GO 57165
// if sort then
57145: LD_VAR 0 9
57149: IFFALSE 57165
// p := sort [ 1 ] ;
57151: LD_ADDR_VAR 0 11
57155: PUSH
57156: LD_VAR 0 9
57160: PUSH
57161: LD_INT 1
57163: ARRAY
57164: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
57165: LD_ADDR_VAR 0 2
57169: PUSH
57170: LD_INT 0
57172: PUSH
57173: LD_INT 0
57175: PUSH
57176: LD_INT 0
57178: PUSH
57179: LD_VAR 0 11
57183: PUSH
57184: EMPTY
57185: LIST
57186: LIST
57187: LIST
57188: LIST
57189: ST_TO_ADDR
// exit ;
57190: GO 59411
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
57192: LD_EXP 50
57196: PUSH
57197: LD_EXP 49
57201: PUSH
57202: LD_VAR 0 1
57206: ARRAY
57207: ARRAY
57208: PUSH
57209: LD_EXP 23
57213: PUSH
57214: LD_VAR 0 1
57218: ARRAY
57219: PPUSH
57220: LD_INT 2
57222: PUSH
57223: LD_INT 30
57225: PUSH
57226: LD_INT 6
57228: PUSH
57229: EMPTY
57230: LIST
57231: LIST
57232: PUSH
57233: LD_INT 30
57235: PUSH
57236: LD_INT 7
57238: PUSH
57239: EMPTY
57240: LIST
57241: LIST
57242: PUSH
57243: LD_INT 30
57245: PUSH
57246: LD_INT 8
57248: PUSH
57249: EMPTY
57250: LIST
57251: LIST
57252: PUSH
57253: EMPTY
57254: LIST
57255: LIST
57256: LIST
57257: LIST
57258: PPUSH
57259: CALL_OW 72
57263: AND
57264: PUSH
57265: LD_EXP 23
57269: PUSH
57270: LD_VAR 0 1
57274: ARRAY
57275: PPUSH
57276: LD_INT 30
57278: PUSH
57279: LD_INT 3
57281: PUSH
57282: EMPTY
57283: LIST
57284: LIST
57285: PPUSH
57286: CALL_OW 72
57290: AND
57291: IFFALSE 58025
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
57293: LD_ADDR_EXP 65
57297: PUSH
57298: LD_EXP 65
57302: PPUSH
57303: LD_VAR 0 1
57307: PPUSH
57308: LD_INT 3
57310: PPUSH
57311: CALL_OW 1
57315: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
57316: LD_ADDR_VAR 0 2
57320: PUSH
57321: LD_INT 0
57323: PUSH
57324: LD_INT 0
57326: PUSH
57327: LD_INT 0
57329: PUSH
57330: LD_INT 0
57332: PUSH
57333: EMPTY
57334: LIST
57335: LIST
57336: LIST
57337: LIST
57338: ST_TO_ADDR
// if not eng then
57339: LD_VAR 0 6
57343: NOT
57344: IFFALSE 57407
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
57346: LD_ADDR_VAR 0 11
57350: PUSH
57351: LD_VAR 0 4
57355: PPUSH
57356: LD_INT 2
57358: PPUSH
57359: CALL 46247 0 2
57363: PUSH
57364: LD_INT 1
57366: ARRAY
57367: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
57368: LD_ADDR_VAR 0 2
57372: PUSH
57373: LD_VAR 0 2
57377: PPUSH
57378: LD_INT 2
57380: PPUSH
57381: LD_VAR 0 11
57385: PPUSH
57386: CALL_OW 1
57390: ST_TO_ADDR
// tmp := tmp diff p ;
57391: LD_ADDR_VAR 0 4
57395: PUSH
57396: LD_VAR 0 4
57400: PUSH
57401: LD_VAR 0 11
57405: DIFF
57406: ST_TO_ADDR
// end ; if tmp and sci < 6 then
57407: LD_VAR 0 4
57411: PUSH
57412: LD_VAR 0 8
57416: PUSH
57417: LD_INT 6
57419: LESS
57420: AND
57421: IFFALSE 57609
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
57423: LD_ADDR_VAR 0 9
57427: PUSH
57428: LD_VAR 0 4
57432: PUSH
57433: LD_VAR 0 8
57437: PUSH
57438: LD_VAR 0 7
57442: UNION
57443: DIFF
57444: PPUSH
57445: LD_INT 4
57447: PPUSH
57448: CALL 46247 0 2
57452: ST_TO_ADDR
// p := [ ] ;
57453: LD_ADDR_VAR 0 11
57457: PUSH
57458: EMPTY
57459: ST_TO_ADDR
// if sort then
57460: LD_VAR 0 9
57464: IFFALSE 57580
// for i = 1 to 6 - sci do
57466: LD_ADDR_VAR 0 3
57470: PUSH
57471: DOUBLE
57472: LD_INT 1
57474: DEC
57475: ST_TO_ADDR
57476: LD_INT 6
57478: PUSH
57479: LD_VAR 0 8
57483: MINUS
57484: PUSH
57485: FOR_TO
57486: IFFALSE 57578
// begin if i = sort then
57488: LD_VAR 0 3
57492: PUSH
57493: LD_VAR 0 9
57497: EQUAL
57498: IFFALSE 57502
// break ;
57500: GO 57578
// if GetClass ( i ) = 4 then
57502: LD_VAR 0 3
57506: PPUSH
57507: CALL_OW 257
57511: PUSH
57512: LD_INT 4
57514: EQUAL
57515: IFFALSE 57519
// continue ;
57517: GO 57485
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57519: LD_ADDR_VAR 0 11
57523: PUSH
57524: LD_VAR 0 11
57528: PPUSH
57529: LD_VAR 0 11
57533: PUSH
57534: LD_INT 1
57536: PLUS
57537: PPUSH
57538: LD_VAR 0 9
57542: PUSH
57543: LD_VAR 0 3
57547: ARRAY
57548: PPUSH
57549: CALL_OW 2
57553: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57554: LD_ADDR_VAR 0 4
57558: PUSH
57559: LD_VAR 0 4
57563: PUSH
57564: LD_VAR 0 9
57568: PUSH
57569: LD_VAR 0 3
57573: ARRAY
57574: DIFF
57575: ST_TO_ADDR
// end ;
57576: GO 57485
57578: POP
57579: POP
// if p then
57580: LD_VAR 0 11
57584: IFFALSE 57609
// result := Replace ( result , 4 , p ) ;
57586: LD_ADDR_VAR 0 2
57590: PUSH
57591: LD_VAR 0 2
57595: PPUSH
57596: LD_INT 4
57598: PPUSH
57599: LD_VAR 0 11
57603: PPUSH
57604: CALL_OW 1
57608: ST_TO_ADDR
// end ; if tmp and mech < 6 then
57609: LD_VAR 0 4
57613: PUSH
57614: LD_VAR 0 7
57618: PUSH
57619: LD_INT 6
57621: LESS
57622: AND
57623: IFFALSE 57811
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
57625: LD_ADDR_VAR 0 9
57629: PUSH
57630: LD_VAR 0 4
57634: PUSH
57635: LD_VAR 0 8
57639: PUSH
57640: LD_VAR 0 7
57644: UNION
57645: DIFF
57646: PPUSH
57647: LD_INT 3
57649: PPUSH
57650: CALL 46247 0 2
57654: ST_TO_ADDR
// p := [ ] ;
57655: LD_ADDR_VAR 0 11
57659: PUSH
57660: EMPTY
57661: ST_TO_ADDR
// if sort then
57662: LD_VAR 0 9
57666: IFFALSE 57782
// for i = 1 to 6 - mech do
57668: LD_ADDR_VAR 0 3
57672: PUSH
57673: DOUBLE
57674: LD_INT 1
57676: DEC
57677: ST_TO_ADDR
57678: LD_INT 6
57680: PUSH
57681: LD_VAR 0 7
57685: MINUS
57686: PUSH
57687: FOR_TO
57688: IFFALSE 57780
// begin if i = sort then
57690: LD_VAR 0 3
57694: PUSH
57695: LD_VAR 0 9
57699: EQUAL
57700: IFFALSE 57704
// break ;
57702: GO 57780
// if GetClass ( i ) = 3 then
57704: LD_VAR 0 3
57708: PPUSH
57709: CALL_OW 257
57713: PUSH
57714: LD_INT 3
57716: EQUAL
57717: IFFALSE 57721
// continue ;
57719: GO 57687
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57721: LD_ADDR_VAR 0 11
57725: PUSH
57726: LD_VAR 0 11
57730: PPUSH
57731: LD_VAR 0 11
57735: PUSH
57736: LD_INT 1
57738: PLUS
57739: PPUSH
57740: LD_VAR 0 9
57744: PUSH
57745: LD_VAR 0 3
57749: ARRAY
57750: PPUSH
57751: CALL_OW 2
57755: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57756: LD_ADDR_VAR 0 4
57760: PUSH
57761: LD_VAR 0 4
57765: PUSH
57766: LD_VAR 0 9
57770: PUSH
57771: LD_VAR 0 3
57775: ARRAY
57776: DIFF
57777: ST_TO_ADDR
// end ;
57778: GO 57687
57780: POP
57781: POP
// if p then
57782: LD_VAR 0 11
57786: IFFALSE 57811
// result := Replace ( result , 3 , p ) ;
57788: LD_ADDR_VAR 0 2
57792: PUSH
57793: LD_VAR 0 2
57797: PPUSH
57798: LD_INT 3
57800: PPUSH
57801: LD_VAR 0 11
57805: PPUSH
57806: CALL_OW 1
57810: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
57811: LD_VAR 0 4
57815: PUSH
57816: LD_INT 6
57818: GREATER
57819: PUSH
57820: LD_VAR 0 6
57824: PUSH
57825: LD_INT 6
57827: LESS
57828: AND
57829: IFFALSE 58023
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
57831: LD_ADDR_VAR 0 9
57835: PUSH
57836: LD_VAR 0 4
57840: PUSH
57841: LD_VAR 0 8
57845: PUSH
57846: LD_VAR 0 7
57850: UNION
57851: PUSH
57852: LD_VAR 0 6
57856: UNION
57857: DIFF
57858: PPUSH
57859: LD_INT 2
57861: PPUSH
57862: CALL 46247 0 2
57866: ST_TO_ADDR
// p := [ ] ;
57867: LD_ADDR_VAR 0 11
57871: PUSH
57872: EMPTY
57873: ST_TO_ADDR
// if sort then
57874: LD_VAR 0 9
57878: IFFALSE 57994
// for i = 1 to 6 - eng do
57880: LD_ADDR_VAR 0 3
57884: PUSH
57885: DOUBLE
57886: LD_INT 1
57888: DEC
57889: ST_TO_ADDR
57890: LD_INT 6
57892: PUSH
57893: LD_VAR 0 6
57897: MINUS
57898: PUSH
57899: FOR_TO
57900: IFFALSE 57992
// begin if i = sort then
57902: LD_VAR 0 3
57906: PUSH
57907: LD_VAR 0 9
57911: EQUAL
57912: IFFALSE 57916
// break ;
57914: GO 57992
// if GetClass ( i ) = 2 then
57916: LD_VAR 0 3
57920: PPUSH
57921: CALL_OW 257
57925: PUSH
57926: LD_INT 2
57928: EQUAL
57929: IFFALSE 57933
// continue ;
57931: GO 57899
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57933: LD_ADDR_VAR 0 11
57937: PUSH
57938: LD_VAR 0 11
57942: PPUSH
57943: LD_VAR 0 11
57947: PUSH
57948: LD_INT 1
57950: PLUS
57951: PPUSH
57952: LD_VAR 0 9
57956: PUSH
57957: LD_VAR 0 3
57961: ARRAY
57962: PPUSH
57963: CALL_OW 2
57967: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57968: LD_ADDR_VAR 0 4
57972: PUSH
57973: LD_VAR 0 4
57977: PUSH
57978: LD_VAR 0 9
57982: PUSH
57983: LD_VAR 0 3
57987: ARRAY
57988: DIFF
57989: ST_TO_ADDR
// end ;
57990: GO 57899
57992: POP
57993: POP
// if p then
57994: LD_VAR 0 11
57998: IFFALSE 58023
// result := Replace ( result , 2 , p ) ;
58000: LD_ADDR_VAR 0 2
58004: PUSH
58005: LD_VAR 0 2
58009: PPUSH
58010: LD_INT 2
58012: PPUSH
58013: LD_VAR 0 11
58017: PPUSH
58018: CALL_OW 1
58022: ST_TO_ADDR
// end ; exit ;
58023: GO 59411
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
58025: LD_EXP 50
58029: PUSH
58030: LD_EXP 49
58034: PUSH
58035: LD_VAR 0 1
58039: ARRAY
58040: ARRAY
58041: NOT
58042: PUSH
58043: LD_EXP 23
58047: PUSH
58048: LD_VAR 0 1
58052: ARRAY
58053: PPUSH
58054: LD_INT 30
58056: PUSH
58057: LD_INT 3
58059: PUSH
58060: EMPTY
58061: LIST
58062: LIST
58063: PPUSH
58064: CALL_OW 72
58068: AND
58069: PUSH
58070: LD_EXP 28
58074: PUSH
58075: LD_VAR 0 1
58079: ARRAY
58080: AND
58081: IFFALSE 58689
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
58083: LD_ADDR_EXP 65
58087: PUSH
58088: LD_EXP 65
58092: PPUSH
58093: LD_VAR 0 1
58097: PPUSH
58098: LD_INT 5
58100: PPUSH
58101: CALL_OW 1
58105: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58106: LD_ADDR_VAR 0 2
58110: PUSH
58111: LD_INT 0
58113: PUSH
58114: LD_INT 0
58116: PUSH
58117: LD_INT 0
58119: PUSH
58120: LD_INT 0
58122: PUSH
58123: EMPTY
58124: LIST
58125: LIST
58126: LIST
58127: LIST
58128: ST_TO_ADDR
// if sci > 1 then
58129: LD_VAR 0 8
58133: PUSH
58134: LD_INT 1
58136: GREATER
58137: IFFALSE 58165
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
58139: LD_ADDR_VAR 0 4
58143: PUSH
58144: LD_VAR 0 4
58148: PUSH
58149: LD_VAR 0 8
58153: PUSH
58154: LD_VAR 0 8
58158: PUSH
58159: LD_INT 1
58161: ARRAY
58162: DIFF
58163: DIFF
58164: ST_TO_ADDR
// if tmp and not sci then
58165: LD_VAR 0 4
58169: PUSH
58170: LD_VAR 0 8
58174: NOT
58175: AND
58176: IFFALSE 58245
// begin sort := SortBySkill ( tmp , 4 ) ;
58178: LD_ADDR_VAR 0 9
58182: PUSH
58183: LD_VAR 0 4
58187: PPUSH
58188: LD_INT 4
58190: PPUSH
58191: CALL 46247 0 2
58195: ST_TO_ADDR
// if sort then
58196: LD_VAR 0 9
58200: IFFALSE 58216
// p := sort [ 1 ] ;
58202: LD_ADDR_VAR 0 11
58206: PUSH
58207: LD_VAR 0 9
58211: PUSH
58212: LD_INT 1
58214: ARRAY
58215: ST_TO_ADDR
// if p then
58216: LD_VAR 0 11
58220: IFFALSE 58245
// result := Replace ( result , 4 , p ) ;
58222: LD_ADDR_VAR 0 2
58226: PUSH
58227: LD_VAR 0 2
58231: PPUSH
58232: LD_INT 4
58234: PPUSH
58235: LD_VAR 0 11
58239: PPUSH
58240: CALL_OW 1
58244: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
58245: LD_ADDR_VAR 0 4
58249: PUSH
58250: LD_VAR 0 4
58254: PUSH
58255: LD_VAR 0 7
58259: DIFF
58260: ST_TO_ADDR
// if tmp and mech < 6 then
58261: LD_VAR 0 4
58265: PUSH
58266: LD_VAR 0 7
58270: PUSH
58271: LD_INT 6
58273: LESS
58274: AND
58275: IFFALSE 58463
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
58277: LD_ADDR_VAR 0 9
58281: PUSH
58282: LD_VAR 0 4
58286: PUSH
58287: LD_VAR 0 8
58291: PUSH
58292: LD_VAR 0 7
58296: UNION
58297: DIFF
58298: PPUSH
58299: LD_INT 3
58301: PPUSH
58302: CALL 46247 0 2
58306: ST_TO_ADDR
// p := [ ] ;
58307: LD_ADDR_VAR 0 11
58311: PUSH
58312: EMPTY
58313: ST_TO_ADDR
// if sort then
58314: LD_VAR 0 9
58318: IFFALSE 58434
// for i = 1 to 6 - mech do
58320: LD_ADDR_VAR 0 3
58324: PUSH
58325: DOUBLE
58326: LD_INT 1
58328: DEC
58329: ST_TO_ADDR
58330: LD_INT 6
58332: PUSH
58333: LD_VAR 0 7
58337: MINUS
58338: PUSH
58339: FOR_TO
58340: IFFALSE 58432
// begin if i = sort then
58342: LD_VAR 0 3
58346: PUSH
58347: LD_VAR 0 9
58351: EQUAL
58352: IFFALSE 58356
// break ;
58354: GO 58432
// if GetClass ( i ) = 3 then
58356: LD_VAR 0 3
58360: PPUSH
58361: CALL_OW 257
58365: PUSH
58366: LD_INT 3
58368: EQUAL
58369: IFFALSE 58373
// continue ;
58371: GO 58339
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58373: LD_ADDR_VAR 0 11
58377: PUSH
58378: LD_VAR 0 11
58382: PPUSH
58383: LD_VAR 0 11
58387: PUSH
58388: LD_INT 1
58390: PLUS
58391: PPUSH
58392: LD_VAR 0 9
58396: PUSH
58397: LD_VAR 0 3
58401: ARRAY
58402: PPUSH
58403: CALL_OW 2
58407: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58408: LD_ADDR_VAR 0 4
58412: PUSH
58413: LD_VAR 0 4
58417: PUSH
58418: LD_VAR 0 9
58422: PUSH
58423: LD_VAR 0 3
58427: ARRAY
58428: DIFF
58429: ST_TO_ADDR
// end ;
58430: GO 58339
58432: POP
58433: POP
// if p then
58434: LD_VAR 0 11
58438: IFFALSE 58463
// result := Replace ( result , 3 , p ) ;
58440: LD_ADDR_VAR 0 2
58444: PUSH
58445: LD_VAR 0 2
58449: PPUSH
58450: LD_INT 3
58452: PPUSH
58453: LD_VAR 0 11
58457: PPUSH
58458: CALL_OW 1
58462: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
58463: LD_ADDR_VAR 0 4
58467: PUSH
58468: LD_VAR 0 4
58472: PUSH
58473: LD_VAR 0 6
58477: DIFF
58478: ST_TO_ADDR
// if tmp and eng < 6 then
58479: LD_VAR 0 4
58483: PUSH
58484: LD_VAR 0 6
58488: PUSH
58489: LD_INT 6
58491: LESS
58492: AND
58493: IFFALSE 58687
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
58495: LD_ADDR_VAR 0 9
58499: PUSH
58500: LD_VAR 0 4
58504: PUSH
58505: LD_VAR 0 8
58509: PUSH
58510: LD_VAR 0 7
58514: UNION
58515: PUSH
58516: LD_VAR 0 6
58520: UNION
58521: DIFF
58522: PPUSH
58523: LD_INT 2
58525: PPUSH
58526: CALL 46247 0 2
58530: ST_TO_ADDR
// p := [ ] ;
58531: LD_ADDR_VAR 0 11
58535: PUSH
58536: EMPTY
58537: ST_TO_ADDR
// if sort then
58538: LD_VAR 0 9
58542: IFFALSE 58658
// for i = 1 to 6 - eng do
58544: LD_ADDR_VAR 0 3
58548: PUSH
58549: DOUBLE
58550: LD_INT 1
58552: DEC
58553: ST_TO_ADDR
58554: LD_INT 6
58556: PUSH
58557: LD_VAR 0 6
58561: MINUS
58562: PUSH
58563: FOR_TO
58564: IFFALSE 58656
// begin if i = sort then
58566: LD_VAR 0 3
58570: PUSH
58571: LD_VAR 0 9
58575: EQUAL
58576: IFFALSE 58580
// break ;
58578: GO 58656
// if GetClass ( i ) = 2 then
58580: LD_VAR 0 3
58584: PPUSH
58585: CALL_OW 257
58589: PUSH
58590: LD_INT 2
58592: EQUAL
58593: IFFALSE 58597
// continue ;
58595: GO 58563
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58597: LD_ADDR_VAR 0 11
58601: PUSH
58602: LD_VAR 0 11
58606: PPUSH
58607: LD_VAR 0 11
58611: PUSH
58612: LD_INT 1
58614: PLUS
58615: PPUSH
58616: LD_VAR 0 9
58620: PUSH
58621: LD_VAR 0 3
58625: ARRAY
58626: PPUSH
58627: CALL_OW 2
58631: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58632: LD_ADDR_VAR 0 4
58636: PUSH
58637: LD_VAR 0 4
58641: PUSH
58642: LD_VAR 0 9
58646: PUSH
58647: LD_VAR 0 3
58651: ARRAY
58652: DIFF
58653: ST_TO_ADDR
// end ;
58654: GO 58563
58656: POP
58657: POP
// if p then
58658: LD_VAR 0 11
58662: IFFALSE 58687
// result := Replace ( result , 2 , p ) ;
58664: LD_ADDR_VAR 0 2
58668: PUSH
58669: LD_VAR 0 2
58673: PPUSH
58674: LD_INT 2
58676: PPUSH
58677: LD_VAR 0 11
58681: PPUSH
58682: CALL_OW 1
58686: ST_TO_ADDR
// end ; exit ;
58687: GO 59411
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
58689: LD_EXP 50
58693: PUSH
58694: LD_EXP 49
58698: PUSH
58699: LD_VAR 0 1
58703: ARRAY
58704: ARRAY
58705: NOT
58706: PUSH
58707: LD_EXP 23
58711: PUSH
58712: LD_VAR 0 1
58716: ARRAY
58717: PPUSH
58718: LD_INT 30
58720: PUSH
58721: LD_INT 3
58723: PUSH
58724: EMPTY
58725: LIST
58726: LIST
58727: PPUSH
58728: CALL_OW 72
58732: AND
58733: PUSH
58734: LD_EXP 28
58738: PUSH
58739: LD_VAR 0 1
58743: ARRAY
58744: NOT
58745: AND
58746: IFFALSE 59411
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
58748: LD_ADDR_EXP 65
58752: PUSH
58753: LD_EXP 65
58757: PPUSH
58758: LD_VAR 0 1
58762: PPUSH
58763: LD_INT 6
58765: PPUSH
58766: CALL_OW 1
58770: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58771: LD_ADDR_VAR 0 2
58775: PUSH
58776: LD_INT 0
58778: PUSH
58779: LD_INT 0
58781: PUSH
58782: LD_INT 0
58784: PUSH
58785: LD_INT 0
58787: PUSH
58788: EMPTY
58789: LIST
58790: LIST
58791: LIST
58792: LIST
58793: ST_TO_ADDR
// if sci >= 1 then
58794: LD_VAR 0 8
58798: PUSH
58799: LD_INT 1
58801: GREATEREQUAL
58802: IFFALSE 58824
// tmp := tmp diff sci [ 1 ] ;
58804: LD_ADDR_VAR 0 4
58808: PUSH
58809: LD_VAR 0 4
58813: PUSH
58814: LD_VAR 0 8
58818: PUSH
58819: LD_INT 1
58821: ARRAY
58822: DIFF
58823: ST_TO_ADDR
// if tmp and not sci then
58824: LD_VAR 0 4
58828: PUSH
58829: LD_VAR 0 8
58833: NOT
58834: AND
58835: IFFALSE 58904
// begin sort := SortBySkill ( tmp , 4 ) ;
58837: LD_ADDR_VAR 0 9
58841: PUSH
58842: LD_VAR 0 4
58846: PPUSH
58847: LD_INT 4
58849: PPUSH
58850: CALL 46247 0 2
58854: ST_TO_ADDR
// if sort then
58855: LD_VAR 0 9
58859: IFFALSE 58875
// p := sort [ 1 ] ;
58861: LD_ADDR_VAR 0 11
58865: PUSH
58866: LD_VAR 0 9
58870: PUSH
58871: LD_INT 1
58873: ARRAY
58874: ST_TO_ADDR
// if p then
58875: LD_VAR 0 11
58879: IFFALSE 58904
// result := Replace ( result , 4 , p ) ;
58881: LD_ADDR_VAR 0 2
58885: PUSH
58886: LD_VAR 0 2
58890: PPUSH
58891: LD_INT 4
58893: PPUSH
58894: LD_VAR 0 11
58898: PPUSH
58899: CALL_OW 1
58903: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
58904: LD_ADDR_VAR 0 4
58908: PUSH
58909: LD_VAR 0 4
58913: PUSH
58914: LD_VAR 0 7
58918: DIFF
58919: ST_TO_ADDR
// if tmp and mech < 6 then
58920: LD_VAR 0 4
58924: PUSH
58925: LD_VAR 0 7
58929: PUSH
58930: LD_INT 6
58932: LESS
58933: AND
58934: IFFALSE 59116
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
58936: LD_ADDR_VAR 0 9
58940: PUSH
58941: LD_VAR 0 4
58945: PUSH
58946: LD_VAR 0 7
58950: DIFF
58951: PPUSH
58952: LD_INT 3
58954: PPUSH
58955: CALL 46247 0 2
58959: ST_TO_ADDR
// p := [ ] ;
58960: LD_ADDR_VAR 0 11
58964: PUSH
58965: EMPTY
58966: ST_TO_ADDR
// if sort then
58967: LD_VAR 0 9
58971: IFFALSE 59087
// for i = 1 to 6 - mech do
58973: LD_ADDR_VAR 0 3
58977: PUSH
58978: DOUBLE
58979: LD_INT 1
58981: DEC
58982: ST_TO_ADDR
58983: LD_INT 6
58985: PUSH
58986: LD_VAR 0 7
58990: MINUS
58991: PUSH
58992: FOR_TO
58993: IFFALSE 59085
// begin if i = sort then
58995: LD_VAR 0 3
58999: PUSH
59000: LD_VAR 0 9
59004: EQUAL
59005: IFFALSE 59009
// break ;
59007: GO 59085
// if GetClass ( i ) = 3 then
59009: LD_VAR 0 3
59013: PPUSH
59014: CALL_OW 257
59018: PUSH
59019: LD_INT 3
59021: EQUAL
59022: IFFALSE 59026
// continue ;
59024: GO 58992
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59026: LD_ADDR_VAR 0 11
59030: PUSH
59031: LD_VAR 0 11
59035: PPUSH
59036: LD_VAR 0 11
59040: PUSH
59041: LD_INT 1
59043: PLUS
59044: PPUSH
59045: LD_VAR 0 9
59049: PUSH
59050: LD_VAR 0 3
59054: ARRAY
59055: PPUSH
59056: CALL_OW 2
59060: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59061: LD_ADDR_VAR 0 4
59065: PUSH
59066: LD_VAR 0 4
59070: PUSH
59071: LD_VAR 0 9
59075: PUSH
59076: LD_VAR 0 3
59080: ARRAY
59081: DIFF
59082: ST_TO_ADDR
// end ;
59083: GO 58992
59085: POP
59086: POP
// if p then
59087: LD_VAR 0 11
59091: IFFALSE 59116
// result := Replace ( result , 3 , p ) ;
59093: LD_ADDR_VAR 0 2
59097: PUSH
59098: LD_VAR 0 2
59102: PPUSH
59103: LD_INT 3
59105: PPUSH
59106: LD_VAR 0 11
59110: PPUSH
59111: CALL_OW 1
59115: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
59116: LD_ADDR_VAR 0 4
59120: PUSH
59121: LD_VAR 0 4
59125: PUSH
59126: LD_VAR 0 6
59130: DIFF
59131: ST_TO_ADDR
// if tmp and eng < 4 then
59132: LD_VAR 0 4
59136: PUSH
59137: LD_VAR 0 6
59141: PUSH
59142: LD_INT 4
59144: LESS
59145: AND
59146: IFFALSE 59336
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
59148: LD_ADDR_VAR 0 9
59152: PUSH
59153: LD_VAR 0 4
59157: PUSH
59158: LD_VAR 0 7
59162: PUSH
59163: LD_VAR 0 6
59167: UNION
59168: DIFF
59169: PPUSH
59170: LD_INT 2
59172: PPUSH
59173: CALL 46247 0 2
59177: ST_TO_ADDR
// p := [ ] ;
59178: LD_ADDR_VAR 0 11
59182: PUSH
59183: EMPTY
59184: ST_TO_ADDR
// if sort then
59185: LD_VAR 0 9
59189: IFFALSE 59305
// for i = 1 to 4 - eng do
59191: LD_ADDR_VAR 0 3
59195: PUSH
59196: DOUBLE
59197: LD_INT 1
59199: DEC
59200: ST_TO_ADDR
59201: LD_INT 4
59203: PUSH
59204: LD_VAR 0 6
59208: MINUS
59209: PUSH
59210: FOR_TO
59211: IFFALSE 59303
// begin if i = sort then
59213: LD_VAR 0 3
59217: PUSH
59218: LD_VAR 0 9
59222: EQUAL
59223: IFFALSE 59227
// break ;
59225: GO 59303
// if GetClass ( i ) = 2 then
59227: LD_VAR 0 3
59231: PPUSH
59232: CALL_OW 257
59236: PUSH
59237: LD_INT 2
59239: EQUAL
59240: IFFALSE 59244
// continue ;
59242: GO 59210
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59244: LD_ADDR_VAR 0 11
59248: PUSH
59249: LD_VAR 0 11
59253: PPUSH
59254: LD_VAR 0 11
59258: PUSH
59259: LD_INT 1
59261: PLUS
59262: PPUSH
59263: LD_VAR 0 9
59267: PUSH
59268: LD_VAR 0 3
59272: ARRAY
59273: PPUSH
59274: CALL_OW 2
59278: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59279: LD_ADDR_VAR 0 4
59283: PUSH
59284: LD_VAR 0 4
59288: PUSH
59289: LD_VAR 0 9
59293: PUSH
59294: LD_VAR 0 3
59298: ARRAY
59299: DIFF
59300: ST_TO_ADDR
// end ;
59301: GO 59210
59303: POP
59304: POP
// if p then
59305: LD_VAR 0 11
59309: IFFALSE 59334
// result := Replace ( result , 2 , p ) ;
59311: LD_ADDR_VAR 0 2
59315: PUSH
59316: LD_VAR 0 2
59320: PPUSH
59321: LD_INT 2
59323: PPUSH
59324: LD_VAR 0 11
59328: PPUSH
59329: CALL_OW 1
59333: ST_TO_ADDR
// end else
59334: GO 59380
// for i = eng downto 5 do
59336: LD_ADDR_VAR 0 3
59340: PUSH
59341: DOUBLE
59342: LD_VAR 0 6
59346: INC
59347: ST_TO_ADDR
59348: LD_INT 5
59350: PUSH
59351: FOR_DOWNTO
59352: IFFALSE 59378
// tmp := tmp union eng [ i ] ;
59354: LD_ADDR_VAR 0 4
59358: PUSH
59359: LD_VAR 0 4
59363: PUSH
59364: LD_VAR 0 6
59368: PUSH
59369: LD_VAR 0 3
59373: ARRAY
59374: UNION
59375: ST_TO_ADDR
59376: GO 59351
59378: POP
59379: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
59380: LD_ADDR_VAR 0 2
59384: PUSH
59385: LD_VAR 0 2
59389: PPUSH
59390: LD_INT 1
59392: PPUSH
59393: LD_VAR 0 4
59397: PUSH
59398: LD_VAR 0 5
59402: DIFF
59403: PPUSH
59404: CALL_OW 1
59408: ST_TO_ADDR
// exit ;
59409: GO 59411
// end ; end ;
59411: LD_VAR 0 2
59415: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
59416: LD_INT 0
59418: PPUSH
59419: PPUSH
59420: PPUSH
// if not mc_bases then
59421: LD_EXP 23
59425: NOT
59426: IFFALSE 59430
// exit ;
59428: GO 59572
// for i = 1 to mc_bases do
59430: LD_ADDR_VAR 0 2
59434: PUSH
59435: DOUBLE
59436: LD_INT 1
59438: DEC
59439: ST_TO_ADDR
59440: LD_EXP 23
59444: PUSH
59445: FOR_TO
59446: IFFALSE 59563
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
59448: LD_ADDR_VAR 0 3
59452: PUSH
59453: LD_EXP 23
59457: PUSH
59458: LD_VAR 0 2
59462: ARRAY
59463: PPUSH
59464: LD_INT 21
59466: PUSH
59467: LD_INT 3
59469: PUSH
59470: EMPTY
59471: LIST
59472: LIST
59473: PUSH
59474: LD_INT 3
59476: PUSH
59477: LD_INT 2
59479: PUSH
59480: LD_INT 30
59482: PUSH
59483: LD_INT 29
59485: PUSH
59486: EMPTY
59487: LIST
59488: LIST
59489: PUSH
59490: LD_INT 30
59492: PUSH
59493: LD_INT 30
59495: PUSH
59496: EMPTY
59497: LIST
59498: LIST
59499: PUSH
59500: EMPTY
59501: LIST
59502: LIST
59503: LIST
59504: PUSH
59505: EMPTY
59506: LIST
59507: LIST
59508: PUSH
59509: LD_INT 3
59511: PUSH
59512: LD_INT 24
59514: PUSH
59515: LD_INT 1000
59517: PUSH
59518: EMPTY
59519: LIST
59520: LIST
59521: PUSH
59522: EMPTY
59523: LIST
59524: LIST
59525: PUSH
59526: EMPTY
59527: LIST
59528: LIST
59529: LIST
59530: PPUSH
59531: CALL_OW 72
59535: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
59536: LD_ADDR_EXP 24
59540: PUSH
59541: LD_EXP 24
59545: PPUSH
59546: LD_VAR 0 2
59550: PPUSH
59551: LD_VAR 0 3
59555: PPUSH
59556: CALL_OW 1
59560: ST_TO_ADDR
// end ;
59561: GO 59445
59563: POP
59564: POP
// RaiseSailEvent ( 101 ) ;
59565: LD_INT 101
59567: PPUSH
59568: CALL_OW 427
// end ;
59572: LD_VAR 0 1
59576: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
59577: LD_INT 0
59579: PPUSH
59580: PPUSH
59581: PPUSH
59582: PPUSH
59583: PPUSH
59584: PPUSH
59585: PPUSH
// if not mc_bases then
59586: LD_EXP 23
59590: NOT
59591: IFFALSE 59595
// exit ;
59593: GO 60157
// for i = 1 to mc_bases do
59595: LD_ADDR_VAR 0 2
59599: PUSH
59600: DOUBLE
59601: LD_INT 1
59603: DEC
59604: ST_TO_ADDR
59605: LD_EXP 23
59609: PUSH
59610: FOR_TO
59611: IFFALSE 60148
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
59613: LD_ADDR_VAR 0 5
59617: PUSH
59618: LD_EXP 23
59622: PUSH
59623: LD_VAR 0 2
59627: ARRAY
59628: PUSH
59629: LD_EXP 52
59633: PUSH
59634: LD_VAR 0 2
59638: ARRAY
59639: UNION
59640: PPUSH
59641: LD_INT 21
59643: PUSH
59644: LD_INT 1
59646: PUSH
59647: EMPTY
59648: LIST
59649: LIST
59650: PUSH
59651: LD_INT 1
59653: PUSH
59654: LD_INT 3
59656: PUSH
59657: LD_INT 54
59659: PUSH
59660: EMPTY
59661: LIST
59662: PUSH
59663: EMPTY
59664: LIST
59665: LIST
59666: PUSH
59667: LD_INT 3
59669: PUSH
59670: LD_INT 24
59672: PUSH
59673: LD_INT 1000
59675: PUSH
59676: EMPTY
59677: LIST
59678: LIST
59679: PUSH
59680: EMPTY
59681: LIST
59682: LIST
59683: PUSH
59684: EMPTY
59685: LIST
59686: LIST
59687: LIST
59688: PUSH
59689: EMPTY
59690: LIST
59691: LIST
59692: PPUSH
59693: CALL_OW 72
59697: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
59698: LD_ADDR_VAR 0 6
59702: PUSH
59703: LD_EXP 23
59707: PUSH
59708: LD_VAR 0 2
59712: ARRAY
59713: PPUSH
59714: LD_INT 21
59716: PUSH
59717: LD_INT 1
59719: PUSH
59720: EMPTY
59721: LIST
59722: LIST
59723: PUSH
59724: LD_INT 1
59726: PUSH
59727: LD_INT 3
59729: PUSH
59730: LD_INT 54
59732: PUSH
59733: EMPTY
59734: LIST
59735: PUSH
59736: EMPTY
59737: LIST
59738: LIST
59739: PUSH
59740: LD_INT 3
59742: PUSH
59743: LD_INT 24
59745: PUSH
59746: LD_INT 250
59748: PUSH
59749: EMPTY
59750: LIST
59751: LIST
59752: PUSH
59753: EMPTY
59754: LIST
59755: LIST
59756: PUSH
59757: EMPTY
59758: LIST
59759: LIST
59760: LIST
59761: PUSH
59762: EMPTY
59763: LIST
59764: LIST
59765: PPUSH
59766: CALL_OW 72
59770: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
59771: LD_ADDR_VAR 0 7
59775: PUSH
59776: LD_VAR 0 5
59780: PUSH
59781: LD_VAR 0 6
59785: DIFF
59786: ST_TO_ADDR
// if not need_heal_1 then
59787: LD_VAR 0 6
59791: NOT
59792: IFFALSE 59825
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
59794: LD_ADDR_EXP 26
59798: PUSH
59799: LD_EXP 26
59803: PPUSH
59804: LD_VAR 0 2
59808: PUSH
59809: LD_INT 1
59811: PUSH
59812: EMPTY
59813: LIST
59814: LIST
59815: PPUSH
59816: EMPTY
59817: PPUSH
59818: CALL 15990 0 3
59822: ST_TO_ADDR
59823: GO 59895
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
59825: LD_ADDR_EXP 26
59829: PUSH
59830: LD_EXP 26
59834: PPUSH
59835: LD_VAR 0 2
59839: PUSH
59840: LD_INT 1
59842: PUSH
59843: EMPTY
59844: LIST
59845: LIST
59846: PPUSH
59847: LD_EXP 26
59851: PUSH
59852: LD_VAR 0 2
59856: ARRAY
59857: PUSH
59858: LD_INT 1
59860: ARRAY
59861: PPUSH
59862: LD_INT 3
59864: PUSH
59865: LD_INT 24
59867: PUSH
59868: LD_INT 1000
59870: PUSH
59871: EMPTY
59872: LIST
59873: LIST
59874: PUSH
59875: EMPTY
59876: LIST
59877: LIST
59878: PPUSH
59879: CALL_OW 72
59883: PUSH
59884: LD_VAR 0 6
59888: UNION
59889: PPUSH
59890: CALL 15990 0 3
59894: ST_TO_ADDR
// if not need_heal_2 then
59895: LD_VAR 0 7
59899: NOT
59900: IFFALSE 59933
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
59902: LD_ADDR_EXP 26
59906: PUSH
59907: LD_EXP 26
59911: PPUSH
59912: LD_VAR 0 2
59916: PUSH
59917: LD_INT 2
59919: PUSH
59920: EMPTY
59921: LIST
59922: LIST
59923: PPUSH
59924: EMPTY
59925: PPUSH
59926: CALL 15990 0 3
59930: ST_TO_ADDR
59931: GO 59965
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
59933: LD_ADDR_EXP 26
59937: PUSH
59938: LD_EXP 26
59942: PPUSH
59943: LD_VAR 0 2
59947: PUSH
59948: LD_INT 2
59950: PUSH
59951: EMPTY
59952: LIST
59953: LIST
59954: PPUSH
59955: LD_VAR 0 7
59959: PPUSH
59960: CALL 15990 0 3
59964: ST_TO_ADDR
// if need_heal_2 then
59965: LD_VAR 0 7
59969: IFFALSE 60130
// for j in need_heal_2 do
59971: LD_ADDR_VAR 0 3
59975: PUSH
59976: LD_VAR 0 7
59980: PUSH
59981: FOR_IN
59982: IFFALSE 60128
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
59984: LD_ADDR_VAR 0 5
59988: PUSH
59989: LD_EXP 23
59993: PUSH
59994: LD_VAR 0 2
59998: ARRAY
59999: PPUSH
60000: LD_INT 2
60002: PUSH
60003: LD_INT 30
60005: PUSH
60006: LD_INT 6
60008: PUSH
60009: EMPTY
60010: LIST
60011: LIST
60012: PUSH
60013: LD_INT 30
60015: PUSH
60016: LD_INT 7
60018: PUSH
60019: EMPTY
60020: LIST
60021: LIST
60022: PUSH
60023: LD_INT 30
60025: PUSH
60026: LD_INT 8
60028: PUSH
60029: EMPTY
60030: LIST
60031: LIST
60032: PUSH
60033: LD_INT 30
60035: PUSH
60036: LD_INT 0
60038: PUSH
60039: EMPTY
60040: LIST
60041: LIST
60042: PUSH
60043: LD_INT 30
60045: PUSH
60046: LD_INT 1
60048: PUSH
60049: EMPTY
60050: LIST
60051: LIST
60052: PUSH
60053: EMPTY
60054: LIST
60055: LIST
60056: LIST
60057: LIST
60058: LIST
60059: LIST
60060: PPUSH
60061: CALL_OW 72
60065: ST_TO_ADDR
// if tmp then
60066: LD_VAR 0 5
60070: IFFALSE 60126
// begin k := NearestUnitToUnit ( tmp , j ) ;
60072: LD_ADDR_VAR 0 4
60076: PUSH
60077: LD_VAR 0 5
60081: PPUSH
60082: LD_VAR 0 3
60086: PPUSH
60087: CALL_OW 74
60091: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
60092: LD_VAR 0 3
60096: PPUSH
60097: LD_VAR 0 4
60101: PPUSH
60102: CALL_OW 296
60106: PUSH
60107: LD_INT 5
60109: GREATER
60110: IFFALSE 60126
// ComMoveToNearbyEntrance ( j , k ) ;
60112: LD_VAR 0 3
60116: PPUSH
60117: LD_VAR 0 4
60121: PPUSH
60122: CALL 48608 0 2
// end ; end ;
60126: GO 59981
60128: POP
60129: POP
// if not need_heal_1 and not need_heal_2 then
60130: LD_VAR 0 6
60134: NOT
60135: PUSH
60136: LD_VAR 0 7
60140: NOT
60141: AND
60142: IFFALSE 60146
// continue ;
60144: GO 59610
// end ;
60146: GO 59610
60148: POP
60149: POP
// RaiseSailEvent ( 102 ) ;
60150: LD_INT 102
60152: PPUSH
60153: CALL_OW 427
// end ;
60157: LD_VAR 0 1
60161: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
60162: LD_INT 0
60164: PPUSH
60165: PPUSH
60166: PPUSH
60167: PPUSH
60168: PPUSH
60169: PPUSH
60170: PPUSH
60171: PPUSH
// if not mc_bases then
60172: LD_EXP 23
60176: NOT
60177: IFFALSE 60181
// exit ;
60179: GO 61064
// for i = 1 to mc_bases do
60181: LD_ADDR_VAR 0 2
60185: PUSH
60186: DOUBLE
60187: LD_INT 1
60189: DEC
60190: ST_TO_ADDR
60191: LD_EXP 23
60195: PUSH
60196: FOR_TO
60197: IFFALSE 61062
// begin if not mc_building_need_repair [ i ] then
60199: LD_EXP 24
60203: PUSH
60204: LD_VAR 0 2
60208: ARRAY
60209: NOT
60210: IFFALSE 60397
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
60212: LD_ADDR_VAR 0 6
60216: PUSH
60217: LD_EXP 42
60221: PUSH
60222: LD_VAR 0 2
60226: ARRAY
60227: PPUSH
60228: LD_INT 3
60230: PUSH
60231: LD_INT 24
60233: PUSH
60234: LD_INT 1000
60236: PUSH
60237: EMPTY
60238: LIST
60239: LIST
60240: PUSH
60241: EMPTY
60242: LIST
60243: LIST
60244: PUSH
60245: LD_INT 2
60247: PUSH
60248: LD_INT 34
60250: PUSH
60251: LD_INT 13
60253: PUSH
60254: EMPTY
60255: LIST
60256: LIST
60257: PUSH
60258: LD_INT 34
60260: PUSH
60261: LD_INT 52
60263: PUSH
60264: EMPTY
60265: LIST
60266: LIST
60267: PUSH
60268: LD_INT 34
60270: PUSH
60271: LD_EXP 73
60275: PUSH
60276: EMPTY
60277: LIST
60278: LIST
60279: PUSH
60280: EMPTY
60281: LIST
60282: LIST
60283: LIST
60284: LIST
60285: PUSH
60286: EMPTY
60287: LIST
60288: LIST
60289: PPUSH
60290: CALL_OW 72
60294: ST_TO_ADDR
// if cranes then
60295: LD_VAR 0 6
60299: IFFALSE 60361
// for j in cranes do
60301: LD_ADDR_VAR 0 3
60305: PUSH
60306: LD_VAR 0 6
60310: PUSH
60311: FOR_IN
60312: IFFALSE 60359
// if not IsInArea ( j , mc_parking [ i ] ) then
60314: LD_VAR 0 3
60318: PPUSH
60319: LD_EXP 47
60323: PUSH
60324: LD_VAR 0 2
60328: ARRAY
60329: PPUSH
60330: CALL_OW 308
60334: NOT
60335: IFFALSE 60357
// ComMoveToArea ( j , mc_parking [ i ] ) ;
60337: LD_VAR 0 3
60341: PPUSH
60342: LD_EXP 47
60346: PUSH
60347: LD_VAR 0 2
60351: ARRAY
60352: PPUSH
60353: CALL_OW 113
60357: GO 60311
60359: POP
60360: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
60361: LD_ADDR_EXP 25
60365: PUSH
60366: LD_EXP 25
60370: PPUSH
60371: LD_VAR 0 2
60375: PPUSH
60376: EMPTY
60377: PPUSH
60378: CALL_OW 1
60382: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
60383: LD_VAR 0 2
60387: PPUSH
60388: LD_INT 101
60390: PPUSH
60391: CALL 55249 0 2
// continue ;
60395: GO 60196
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
60397: LD_ADDR_EXP 29
60401: PUSH
60402: LD_EXP 29
60406: PPUSH
60407: LD_VAR 0 2
60411: PPUSH
60412: EMPTY
60413: PPUSH
60414: CALL_OW 1
60418: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
60419: LD_VAR 0 2
60423: PPUSH
60424: LD_INT 103
60426: PPUSH
60427: CALL 55249 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
60431: LD_ADDR_VAR 0 5
60435: PUSH
60436: LD_EXP 23
60440: PUSH
60441: LD_VAR 0 2
60445: ARRAY
60446: PUSH
60447: LD_EXP 52
60451: PUSH
60452: LD_VAR 0 2
60456: ARRAY
60457: UNION
60458: PPUSH
60459: LD_INT 2
60461: PUSH
60462: LD_INT 25
60464: PUSH
60465: LD_INT 2
60467: PUSH
60468: EMPTY
60469: LIST
60470: LIST
60471: PUSH
60472: LD_INT 25
60474: PUSH
60475: LD_INT 16
60477: PUSH
60478: EMPTY
60479: LIST
60480: LIST
60481: PUSH
60482: EMPTY
60483: LIST
60484: LIST
60485: LIST
60486: PUSH
60487: EMPTY
60488: LIST
60489: PPUSH
60490: CALL_OW 72
60494: ST_TO_ADDR
// if mc_need_heal [ i ] then
60495: LD_EXP 26
60499: PUSH
60500: LD_VAR 0 2
60504: ARRAY
60505: IFFALSE 60549
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
60507: LD_ADDR_VAR 0 5
60511: PUSH
60512: LD_VAR 0 5
60516: PUSH
60517: LD_EXP 26
60521: PUSH
60522: LD_VAR 0 2
60526: ARRAY
60527: PUSH
60528: LD_INT 1
60530: ARRAY
60531: PUSH
60532: LD_EXP 26
60536: PUSH
60537: LD_VAR 0 2
60541: ARRAY
60542: PUSH
60543: LD_INT 2
60545: ARRAY
60546: UNION
60547: DIFF
60548: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
60549: LD_ADDR_VAR 0 6
60553: PUSH
60554: LD_EXP 42
60558: PUSH
60559: LD_VAR 0 2
60563: ARRAY
60564: PPUSH
60565: LD_INT 2
60567: PUSH
60568: LD_INT 34
60570: PUSH
60571: LD_INT 13
60573: PUSH
60574: EMPTY
60575: LIST
60576: LIST
60577: PUSH
60578: LD_INT 34
60580: PUSH
60581: LD_INT 52
60583: PUSH
60584: EMPTY
60585: LIST
60586: LIST
60587: PUSH
60588: LD_INT 34
60590: PUSH
60591: LD_EXP 73
60595: PUSH
60596: EMPTY
60597: LIST
60598: LIST
60599: PUSH
60600: EMPTY
60601: LIST
60602: LIST
60603: LIST
60604: LIST
60605: PPUSH
60606: CALL_OW 72
60610: ST_TO_ADDR
// if cranes then
60611: LD_VAR 0 6
60615: IFFALSE 60751
// begin for j in cranes do
60617: LD_ADDR_VAR 0 3
60621: PUSH
60622: LD_VAR 0 6
60626: PUSH
60627: FOR_IN
60628: IFFALSE 60749
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
60630: LD_VAR 0 3
60634: PPUSH
60635: CALL_OW 256
60639: PUSH
60640: LD_INT 1000
60642: EQUAL
60643: PUSH
60644: LD_VAR 0 3
60648: PPUSH
60649: CALL_OW 314
60653: NOT
60654: AND
60655: IFFALSE 60689
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
60657: LD_VAR 0 3
60661: PPUSH
60662: LD_EXP 24
60666: PUSH
60667: LD_VAR 0 2
60671: ARRAY
60672: PPUSH
60673: LD_VAR 0 3
60677: PPUSH
60678: CALL_OW 74
60682: PPUSH
60683: CALL_OW 130
60687: GO 60747
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
60689: LD_VAR 0 3
60693: PPUSH
60694: CALL_OW 256
60698: PUSH
60699: LD_INT 500
60701: LESS
60702: PUSH
60703: LD_VAR 0 3
60707: PPUSH
60708: LD_EXP 47
60712: PUSH
60713: LD_VAR 0 2
60717: ARRAY
60718: PPUSH
60719: CALL_OW 308
60723: NOT
60724: AND
60725: IFFALSE 60747
// ComMoveToArea ( j , mc_parking [ i ] ) ;
60727: LD_VAR 0 3
60731: PPUSH
60732: LD_EXP 47
60736: PUSH
60737: LD_VAR 0 2
60741: ARRAY
60742: PPUSH
60743: CALL_OW 113
// end ;
60747: GO 60627
60749: POP
60750: POP
// end ; if tmp > 3 then
60751: LD_VAR 0 5
60755: PUSH
60756: LD_INT 3
60758: GREATER
60759: IFFALSE 60779
// tmp := ShrinkArray ( tmp , 4 ) ;
60761: LD_ADDR_VAR 0 5
60765: PUSH
60766: LD_VAR 0 5
60770: PPUSH
60771: LD_INT 4
60773: PPUSH
60774: CALL 48056 0 2
60778: ST_TO_ADDR
// if not tmp then
60779: LD_VAR 0 5
60783: NOT
60784: IFFALSE 60788
// continue ;
60786: GO 60196
// for j in tmp do
60788: LD_ADDR_VAR 0 3
60792: PUSH
60793: LD_VAR 0 5
60797: PUSH
60798: FOR_IN
60799: IFFALSE 61058
// begin if IsInUnit ( j ) then
60801: LD_VAR 0 3
60805: PPUSH
60806: CALL_OW 310
60810: IFFALSE 60821
// ComExitBuilding ( j ) ;
60812: LD_VAR 0 3
60816: PPUSH
60817: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
60821: LD_VAR 0 3
60825: PUSH
60826: LD_EXP 25
60830: PUSH
60831: LD_VAR 0 2
60835: ARRAY
60836: IN
60837: NOT
60838: IFFALSE 60896
// begin SetTag ( j , 101 ) ;
60840: LD_VAR 0 3
60844: PPUSH
60845: LD_INT 101
60847: PPUSH
60848: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
60852: LD_ADDR_EXP 25
60856: PUSH
60857: LD_EXP 25
60861: PPUSH
60862: LD_VAR 0 2
60866: PUSH
60867: LD_EXP 25
60871: PUSH
60872: LD_VAR 0 2
60876: ARRAY
60877: PUSH
60878: LD_INT 1
60880: PLUS
60881: PUSH
60882: EMPTY
60883: LIST
60884: LIST
60885: PPUSH
60886: LD_VAR 0 3
60890: PPUSH
60891: CALL 15990 0 3
60895: ST_TO_ADDR
// end ; wait ( 1 ) ;
60896: LD_INT 1
60898: PPUSH
60899: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
60903: LD_ADDR_VAR 0 7
60907: PUSH
60908: LD_EXP 24
60912: PUSH
60913: LD_VAR 0 2
60917: ARRAY
60918: ST_TO_ADDR
// if mc_scan [ i ] then
60919: LD_EXP 46
60923: PUSH
60924: LD_VAR 0 2
60928: ARRAY
60929: IFFALSE 60991
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
60931: LD_ADDR_VAR 0 7
60935: PUSH
60936: LD_EXP 24
60940: PUSH
60941: LD_VAR 0 2
60945: ARRAY
60946: PPUSH
60947: LD_INT 3
60949: PUSH
60950: LD_INT 30
60952: PUSH
60953: LD_INT 32
60955: PUSH
60956: EMPTY
60957: LIST
60958: LIST
60959: PUSH
60960: LD_INT 30
60962: PUSH
60963: LD_INT 33
60965: PUSH
60966: EMPTY
60967: LIST
60968: LIST
60969: PUSH
60970: LD_INT 30
60972: PUSH
60973: LD_INT 31
60975: PUSH
60976: EMPTY
60977: LIST
60978: LIST
60979: PUSH
60980: EMPTY
60981: LIST
60982: LIST
60983: LIST
60984: LIST
60985: PPUSH
60986: CALL_OW 72
60990: ST_TO_ADDR
// if not to_repair_tmp then
60991: LD_VAR 0 7
60995: NOT
60996: IFFALSE 61000
// continue ;
60998: GO 60798
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
61000: LD_ADDR_VAR 0 8
61004: PUSH
61005: LD_VAR 0 7
61009: PPUSH
61010: LD_VAR 0 3
61014: PPUSH
61015: CALL_OW 74
61019: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
61020: LD_VAR 0 8
61024: PPUSH
61025: LD_INT 16
61027: PPUSH
61028: CALL 18589 0 2
61032: PUSH
61033: LD_INT 4
61035: ARRAY
61036: PUSH
61037: LD_INT 10
61039: LESS
61040: IFFALSE 61056
// ComRepairBuilding ( j , to_repair ) ;
61042: LD_VAR 0 3
61046: PPUSH
61047: LD_VAR 0 8
61051: PPUSH
61052: CALL_OW 130
// end ;
61056: GO 60798
61058: POP
61059: POP
// end ;
61060: GO 60196
61062: POP
61063: POP
// end ;
61064: LD_VAR 0 1
61068: RET
// export function MC_Heal ; var i , j , tmp ; begin
61069: LD_INT 0
61071: PPUSH
61072: PPUSH
61073: PPUSH
61074: PPUSH
// if not mc_bases then
61075: LD_EXP 23
61079: NOT
61080: IFFALSE 61084
// exit ;
61082: GO 61486
// for i = 1 to mc_bases do
61084: LD_ADDR_VAR 0 2
61088: PUSH
61089: DOUBLE
61090: LD_INT 1
61092: DEC
61093: ST_TO_ADDR
61094: LD_EXP 23
61098: PUSH
61099: FOR_TO
61100: IFFALSE 61484
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
61102: LD_EXP 26
61106: PUSH
61107: LD_VAR 0 2
61111: ARRAY
61112: PUSH
61113: LD_INT 1
61115: ARRAY
61116: NOT
61117: PUSH
61118: LD_EXP 26
61122: PUSH
61123: LD_VAR 0 2
61127: ARRAY
61128: PUSH
61129: LD_INT 2
61131: ARRAY
61132: NOT
61133: AND
61134: IFFALSE 61172
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
61136: LD_ADDR_EXP 27
61140: PUSH
61141: LD_EXP 27
61145: PPUSH
61146: LD_VAR 0 2
61150: PPUSH
61151: EMPTY
61152: PPUSH
61153: CALL_OW 1
61157: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
61158: LD_VAR 0 2
61162: PPUSH
61163: LD_INT 102
61165: PPUSH
61166: CALL 55249 0 2
// continue ;
61170: GO 61099
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
61172: LD_ADDR_VAR 0 4
61176: PUSH
61177: LD_EXP 23
61181: PUSH
61182: LD_VAR 0 2
61186: ARRAY
61187: PPUSH
61188: LD_INT 25
61190: PUSH
61191: LD_INT 4
61193: PUSH
61194: EMPTY
61195: LIST
61196: LIST
61197: PPUSH
61198: CALL_OW 72
61202: ST_TO_ADDR
// if not tmp then
61203: LD_VAR 0 4
61207: NOT
61208: IFFALSE 61212
// continue ;
61210: GO 61099
// if mc_taming [ i ] then
61212: LD_EXP 54
61216: PUSH
61217: LD_VAR 0 2
61221: ARRAY
61222: IFFALSE 61246
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
61224: LD_ADDR_EXP 54
61228: PUSH
61229: LD_EXP 54
61233: PPUSH
61234: LD_VAR 0 2
61238: PPUSH
61239: EMPTY
61240: PPUSH
61241: CALL_OW 1
61245: ST_TO_ADDR
// for j in tmp do
61246: LD_ADDR_VAR 0 3
61250: PUSH
61251: LD_VAR 0 4
61255: PUSH
61256: FOR_IN
61257: IFFALSE 61480
// begin if IsInUnit ( j ) then
61259: LD_VAR 0 3
61263: PPUSH
61264: CALL_OW 310
61268: IFFALSE 61279
// ComExitBuilding ( j ) ;
61270: LD_VAR 0 3
61274: PPUSH
61275: CALL_OW 122
// if not j in mc_healers [ i ] then
61279: LD_VAR 0 3
61283: PUSH
61284: LD_EXP 27
61288: PUSH
61289: LD_VAR 0 2
61293: ARRAY
61294: IN
61295: NOT
61296: IFFALSE 61342
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
61298: LD_ADDR_EXP 27
61302: PUSH
61303: LD_EXP 27
61307: PPUSH
61308: LD_VAR 0 2
61312: PUSH
61313: LD_EXP 27
61317: PUSH
61318: LD_VAR 0 2
61322: ARRAY
61323: PUSH
61324: LD_INT 1
61326: PLUS
61327: PUSH
61328: EMPTY
61329: LIST
61330: LIST
61331: PPUSH
61332: LD_VAR 0 3
61336: PPUSH
61337: CALL 15990 0 3
61341: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
61342: LD_VAR 0 3
61346: PPUSH
61347: CALL_OW 110
61351: PUSH
61352: LD_INT 102
61354: NONEQUAL
61355: IFFALSE 61369
// SetTag ( j , 102 ) ;
61357: LD_VAR 0 3
61361: PPUSH
61362: LD_INT 102
61364: PPUSH
61365: CALL_OW 109
// Wait ( 3 ) ;
61369: LD_INT 3
61371: PPUSH
61372: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
61376: LD_EXP 26
61380: PUSH
61381: LD_VAR 0 2
61385: ARRAY
61386: PUSH
61387: LD_INT 1
61389: ARRAY
61390: IFFALSE 61422
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
61392: LD_VAR 0 3
61396: PPUSH
61397: LD_EXP 26
61401: PUSH
61402: LD_VAR 0 2
61406: ARRAY
61407: PUSH
61408: LD_INT 1
61410: ARRAY
61411: PUSH
61412: LD_INT 1
61414: ARRAY
61415: PPUSH
61416: CALL_OW 128
61420: GO 61478
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
61422: LD_VAR 0 3
61426: PPUSH
61427: CALL_OW 314
61431: NOT
61432: PUSH
61433: LD_EXP 26
61437: PUSH
61438: LD_VAR 0 2
61442: ARRAY
61443: PUSH
61444: LD_INT 2
61446: ARRAY
61447: AND
61448: IFFALSE 61478
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
61450: LD_VAR 0 3
61454: PPUSH
61455: LD_EXP 26
61459: PUSH
61460: LD_VAR 0 2
61464: ARRAY
61465: PUSH
61466: LD_INT 2
61468: ARRAY
61469: PUSH
61470: LD_INT 1
61472: ARRAY
61473: PPUSH
61474: CALL_OW 128
// end ;
61478: GO 61256
61480: POP
61481: POP
// end ;
61482: GO 61099
61484: POP
61485: POP
// end ;
61486: LD_VAR 0 1
61490: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
61491: LD_INT 0
61493: PPUSH
61494: PPUSH
61495: PPUSH
61496: PPUSH
61497: PPUSH
// if not mc_bases then
61498: LD_EXP 23
61502: NOT
61503: IFFALSE 61507
// exit ;
61505: GO 62678
// for i = 1 to mc_bases do
61507: LD_ADDR_VAR 0 2
61511: PUSH
61512: DOUBLE
61513: LD_INT 1
61515: DEC
61516: ST_TO_ADDR
61517: LD_EXP 23
61521: PUSH
61522: FOR_TO
61523: IFFALSE 62676
// begin if mc_scan [ i ] then
61525: LD_EXP 46
61529: PUSH
61530: LD_VAR 0 2
61534: ARRAY
61535: IFFALSE 61539
// continue ;
61537: GO 61522
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
61539: LD_EXP 28
61543: PUSH
61544: LD_VAR 0 2
61548: ARRAY
61549: NOT
61550: PUSH
61551: LD_EXP 30
61555: PUSH
61556: LD_VAR 0 2
61560: ARRAY
61561: NOT
61562: AND
61563: PUSH
61564: LD_EXP 29
61568: PUSH
61569: LD_VAR 0 2
61573: ARRAY
61574: AND
61575: IFFALSE 61613
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
61577: LD_ADDR_EXP 29
61581: PUSH
61582: LD_EXP 29
61586: PPUSH
61587: LD_VAR 0 2
61591: PPUSH
61592: EMPTY
61593: PPUSH
61594: CALL_OW 1
61598: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
61599: LD_VAR 0 2
61603: PPUSH
61604: LD_INT 103
61606: PPUSH
61607: CALL 55249 0 2
// continue ;
61611: GO 61522
// end ; if mc_construct_list [ i ] then
61613: LD_EXP 30
61617: PUSH
61618: LD_VAR 0 2
61622: ARRAY
61623: IFFALSE 61843
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
61625: LD_ADDR_VAR 0 4
61629: PUSH
61630: LD_EXP 23
61634: PUSH
61635: LD_VAR 0 2
61639: ARRAY
61640: PPUSH
61641: LD_INT 25
61643: PUSH
61644: LD_INT 2
61646: PUSH
61647: EMPTY
61648: LIST
61649: LIST
61650: PPUSH
61651: CALL_OW 72
61655: PUSH
61656: LD_EXP 25
61660: PUSH
61661: LD_VAR 0 2
61665: ARRAY
61666: DIFF
61667: ST_TO_ADDR
// if not tmp then
61668: LD_VAR 0 4
61672: NOT
61673: IFFALSE 61677
// continue ;
61675: GO 61522
// for j in tmp do
61677: LD_ADDR_VAR 0 3
61681: PUSH
61682: LD_VAR 0 4
61686: PUSH
61687: FOR_IN
61688: IFFALSE 61839
// begin if not mc_builders [ i ] then
61690: LD_EXP 29
61694: PUSH
61695: LD_VAR 0 2
61699: ARRAY
61700: NOT
61701: IFFALSE 61759
// begin SetTag ( j , 103 ) ;
61703: LD_VAR 0 3
61707: PPUSH
61708: LD_INT 103
61710: PPUSH
61711: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
61715: LD_ADDR_EXP 29
61719: PUSH
61720: LD_EXP 29
61724: PPUSH
61725: LD_VAR 0 2
61729: PUSH
61730: LD_EXP 29
61734: PUSH
61735: LD_VAR 0 2
61739: ARRAY
61740: PUSH
61741: LD_INT 1
61743: PLUS
61744: PUSH
61745: EMPTY
61746: LIST
61747: LIST
61748: PPUSH
61749: LD_VAR 0 3
61753: PPUSH
61754: CALL 15990 0 3
61758: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
61759: LD_VAR 0 3
61763: PPUSH
61764: CALL_OW 310
61768: IFFALSE 61779
// ComExitBuilding ( j ) ;
61770: LD_VAR 0 3
61774: PPUSH
61775: CALL_OW 122
// wait ( 3 ) ;
61779: LD_INT 3
61781: PPUSH
61782: CALL_OW 67
// if not mc_construct_list [ i ] then
61786: LD_EXP 30
61790: PUSH
61791: LD_VAR 0 2
61795: ARRAY
61796: NOT
61797: IFFALSE 61801
// break ;
61799: GO 61839
// if not HasTask ( j ) then
61801: LD_VAR 0 3
61805: PPUSH
61806: CALL_OW 314
61810: NOT
61811: IFFALSE 61837
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
61813: LD_VAR 0 3
61817: PPUSH
61818: LD_EXP 30
61822: PUSH
61823: LD_VAR 0 2
61827: ARRAY
61828: PUSH
61829: LD_INT 1
61831: ARRAY
61832: PPUSH
61833: CALL 18853 0 2
// end ;
61837: GO 61687
61839: POP
61840: POP
// end else
61841: GO 62674
// if mc_build_list [ i ] then
61843: LD_EXP 28
61847: PUSH
61848: LD_VAR 0 2
61852: ARRAY
61853: IFFALSE 62674
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61855: LD_ADDR_VAR 0 5
61859: PUSH
61860: LD_EXP 23
61864: PUSH
61865: LD_VAR 0 2
61869: ARRAY
61870: PPUSH
61871: LD_INT 2
61873: PUSH
61874: LD_INT 30
61876: PUSH
61877: LD_INT 0
61879: PUSH
61880: EMPTY
61881: LIST
61882: LIST
61883: PUSH
61884: LD_INT 30
61886: PUSH
61887: LD_INT 1
61889: PUSH
61890: EMPTY
61891: LIST
61892: LIST
61893: PUSH
61894: EMPTY
61895: LIST
61896: LIST
61897: LIST
61898: PPUSH
61899: CALL_OW 72
61903: ST_TO_ADDR
// if depot then
61904: LD_VAR 0 5
61908: IFFALSE 61926
// depot := depot [ 1 ] else
61910: LD_ADDR_VAR 0 5
61914: PUSH
61915: LD_VAR 0 5
61919: PUSH
61920: LD_INT 1
61922: ARRAY
61923: ST_TO_ADDR
61924: GO 61934
// depot := 0 ;
61926: LD_ADDR_VAR 0 5
61930: PUSH
61931: LD_INT 0
61933: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
61934: LD_EXP 28
61938: PUSH
61939: LD_VAR 0 2
61943: ARRAY
61944: PUSH
61945: LD_INT 1
61947: ARRAY
61948: PUSH
61949: LD_INT 1
61951: ARRAY
61952: PPUSH
61953: CALL 18677 0 1
61957: PUSH
61958: LD_EXP 23
61962: PUSH
61963: LD_VAR 0 2
61967: ARRAY
61968: PPUSH
61969: LD_INT 2
61971: PUSH
61972: LD_INT 30
61974: PUSH
61975: LD_INT 2
61977: PUSH
61978: EMPTY
61979: LIST
61980: LIST
61981: PUSH
61982: LD_INT 30
61984: PUSH
61985: LD_INT 3
61987: PUSH
61988: EMPTY
61989: LIST
61990: LIST
61991: PUSH
61992: EMPTY
61993: LIST
61994: LIST
61995: LIST
61996: PPUSH
61997: CALL_OW 72
62001: NOT
62002: AND
62003: IFFALSE 62108
// begin for j = 1 to mc_build_list [ i ] do
62005: LD_ADDR_VAR 0 3
62009: PUSH
62010: DOUBLE
62011: LD_INT 1
62013: DEC
62014: ST_TO_ADDR
62015: LD_EXP 28
62019: PUSH
62020: LD_VAR 0 2
62024: ARRAY
62025: PUSH
62026: FOR_TO
62027: IFFALSE 62106
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
62029: LD_EXP 28
62033: PUSH
62034: LD_VAR 0 2
62038: ARRAY
62039: PUSH
62040: LD_VAR 0 3
62044: ARRAY
62045: PUSH
62046: LD_INT 1
62048: ARRAY
62049: PUSH
62050: LD_INT 2
62052: EQUAL
62053: IFFALSE 62104
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
62055: LD_ADDR_EXP 28
62059: PUSH
62060: LD_EXP 28
62064: PPUSH
62065: LD_VAR 0 2
62069: PPUSH
62070: LD_EXP 28
62074: PUSH
62075: LD_VAR 0 2
62079: ARRAY
62080: PPUSH
62081: LD_VAR 0 3
62085: PPUSH
62086: LD_INT 1
62088: PPUSH
62089: LD_INT 0
62091: PPUSH
62092: CALL 15408 0 4
62096: PPUSH
62097: CALL_OW 1
62101: ST_TO_ADDR
// break ;
62102: GO 62106
// end ;
62104: GO 62026
62106: POP
62107: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
62108: LD_EXP 28
62112: PUSH
62113: LD_VAR 0 2
62117: ARRAY
62118: PUSH
62119: LD_INT 1
62121: ARRAY
62122: PUSH
62123: LD_INT 1
62125: ARRAY
62126: PUSH
62127: LD_INT 0
62129: EQUAL
62130: PUSH
62131: LD_VAR 0 5
62135: PUSH
62136: LD_VAR 0 5
62140: PPUSH
62141: LD_EXP 28
62145: PUSH
62146: LD_VAR 0 2
62150: ARRAY
62151: PUSH
62152: LD_INT 1
62154: ARRAY
62155: PUSH
62156: LD_INT 1
62158: ARRAY
62159: PPUSH
62160: LD_EXP 28
62164: PUSH
62165: LD_VAR 0 2
62169: ARRAY
62170: PUSH
62171: LD_INT 1
62173: ARRAY
62174: PUSH
62175: LD_INT 2
62177: ARRAY
62178: PPUSH
62179: LD_EXP 28
62183: PUSH
62184: LD_VAR 0 2
62188: ARRAY
62189: PUSH
62190: LD_INT 1
62192: ARRAY
62193: PUSH
62194: LD_INT 3
62196: ARRAY
62197: PPUSH
62198: LD_EXP 28
62202: PUSH
62203: LD_VAR 0 2
62207: ARRAY
62208: PUSH
62209: LD_INT 1
62211: ARRAY
62212: PUSH
62213: LD_INT 4
62215: ARRAY
62216: PPUSH
62217: CALL 24093 0 5
62221: AND
62222: OR
62223: IFFALSE 62504
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
62225: LD_ADDR_VAR 0 4
62229: PUSH
62230: LD_EXP 23
62234: PUSH
62235: LD_VAR 0 2
62239: ARRAY
62240: PPUSH
62241: LD_INT 25
62243: PUSH
62244: LD_INT 2
62246: PUSH
62247: EMPTY
62248: LIST
62249: LIST
62250: PPUSH
62251: CALL_OW 72
62255: PUSH
62256: LD_EXP 25
62260: PUSH
62261: LD_VAR 0 2
62265: ARRAY
62266: DIFF
62267: ST_TO_ADDR
// if not tmp then
62268: LD_VAR 0 4
62272: NOT
62273: IFFALSE 62277
// continue ;
62275: GO 61522
// for j in tmp do
62277: LD_ADDR_VAR 0 3
62281: PUSH
62282: LD_VAR 0 4
62286: PUSH
62287: FOR_IN
62288: IFFALSE 62500
// begin if not mc_builders [ i ] then
62290: LD_EXP 29
62294: PUSH
62295: LD_VAR 0 2
62299: ARRAY
62300: NOT
62301: IFFALSE 62359
// begin SetTag ( j , 103 ) ;
62303: LD_VAR 0 3
62307: PPUSH
62308: LD_INT 103
62310: PPUSH
62311: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
62315: LD_ADDR_EXP 29
62319: PUSH
62320: LD_EXP 29
62324: PPUSH
62325: LD_VAR 0 2
62329: PUSH
62330: LD_EXP 29
62334: PUSH
62335: LD_VAR 0 2
62339: ARRAY
62340: PUSH
62341: LD_INT 1
62343: PLUS
62344: PUSH
62345: EMPTY
62346: LIST
62347: LIST
62348: PPUSH
62349: LD_VAR 0 3
62353: PPUSH
62354: CALL 15990 0 3
62358: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
62359: LD_VAR 0 3
62363: PPUSH
62364: CALL_OW 310
62368: IFFALSE 62379
// ComExitBuilding ( j ) ;
62370: LD_VAR 0 3
62374: PPUSH
62375: CALL_OW 122
// wait ( 3 ) ;
62379: LD_INT 3
62381: PPUSH
62382: CALL_OW 67
// if not mc_build_list [ i ] then
62386: LD_EXP 28
62390: PUSH
62391: LD_VAR 0 2
62395: ARRAY
62396: NOT
62397: IFFALSE 62401
// break ;
62399: GO 62500
// if not HasTask ( j ) then
62401: LD_VAR 0 3
62405: PPUSH
62406: CALL_OW 314
62410: NOT
62411: IFFALSE 62498
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
62413: LD_VAR 0 3
62417: PPUSH
62418: LD_EXP 28
62422: PUSH
62423: LD_VAR 0 2
62427: ARRAY
62428: PUSH
62429: LD_INT 1
62431: ARRAY
62432: PUSH
62433: LD_INT 1
62435: ARRAY
62436: PPUSH
62437: LD_EXP 28
62441: PUSH
62442: LD_VAR 0 2
62446: ARRAY
62447: PUSH
62448: LD_INT 1
62450: ARRAY
62451: PUSH
62452: LD_INT 2
62454: ARRAY
62455: PPUSH
62456: LD_EXP 28
62460: PUSH
62461: LD_VAR 0 2
62465: ARRAY
62466: PUSH
62467: LD_INT 1
62469: ARRAY
62470: PUSH
62471: LD_INT 3
62473: ARRAY
62474: PPUSH
62475: LD_EXP 28
62479: PUSH
62480: LD_VAR 0 2
62484: ARRAY
62485: PUSH
62486: LD_INT 1
62488: ARRAY
62489: PUSH
62490: LD_INT 4
62492: ARRAY
62493: PPUSH
62494: CALL_OW 145
// end ;
62498: GO 62287
62500: POP
62501: POP
// end else
62502: GO 62674
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
62504: LD_EXP 23
62508: PUSH
62509: LD_VAR 0 2
62513: ARRAY
62514: PPUSH
62515: LD_EXP 28
62519: PUSH
62520: LD_VAR 0 2
62524: ARRAY
62525: PUSH
62526: LD_INT 1
62528: ARRAY
62529: PUSH
62530: LD_INT 1
62532: ARRAY
62533: PPUSH
62534: LD_EXP 28
62538: PUSH
62539: LD_VAR 0 2
62543: ARRAY
62544: PUSH
62545: LD_INT 1
62547: ARRAY
62548: PUSH
62549: LD_INT 2
62551: ARRAY
62552: PPUSH
62553: LD_EXP 28
62557: PUSH
62558: LD_VAR 0 2
62562: ARRAY
62563: PUSH
62564: LD_INT 1
62566: ARRAY
62567: PUSH
62568: LD_INT 3
62570: ARRAY
62571: PPUSH
62572: LD_EXP 28
62576: PUSH
62577: LD_VAR 0 2
62581: ARRAY
62582: PUSH
62583: LD_INT 1
62585: ARRAY
62586: PUSH
62587: LD_INT 4
62589: ARRAY
62590: PPUSH
62591: LD_EXP 23
62595: PUSH
62596: LD_VAR 0 2
62600: ARRAY
62601: PPUSH
62602: LD_INT 21
62604: PUSH
62605: LD_INT 3
62607: PUSH
62608: EMPTY
62609: LIST
62610: LIST
62611: PPUSH
62612: CALL_OW 72
62616: PPUSH
62617: EMPTY
62618: PPUSH
62619: CALL 22843 0 7
62623: NOT
62624: IFFALSE 62674
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
62626: LD_ADDR_EXP 28
62630: PUSH
62631: LD_EXP 28
62635: PPUSH
62636: LD_VAR 0 2
62640: PPUSH
62641: LD_EXP 28
62645: PUSH
62646: LD_VAR 0 2
62650: ARRAY
62651: PPUSH
62652: LD_INT 1
62654: PPUSH
62655: LD_INT 1
62657: NEG
62658: PPUSH
62659: LD_INT 0
62661: PPUSH
62662: CALL 15408 0 4
62666: PPUSH
62667: CALL_OW 1
62671: ST_TO_ADDR
// continue ;
62672: GO 61522
// end ; end ; end ;
62674: GO 61522
62676: POP
62677: POP
// end ;
62678: LD_VAR 0 1
62682: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
62683: LD_INT 0
62685: PPUSH
62686: PPUSH
62687: PPUSH
62688: PPUSH
62689: PPUSH
62690: PPUSH
// if not mc_bases then
62691: LD_EXP 23
62695: NOT
62696: IFFALSE 62700
// exit ;
62698: GO 63127
// for i = 1 to mc_bases do
62700: LD_ADDR_VAR 0 2
62704: PUSH
62705: DOUBLE
62706: LD_INT 1
62708: DEC
62709: ST_TO_ADDR
62710: LD_EXP 23
62714: PUSH
62715: FOR_TO
62716: IFFALSE 63125
// begin tmp := mc_build_upgrade [ i ] ;
62718: LD_ADDR_VAR 0 4
62722: PUSH
62723: LD_EXP 55
62727: PUSH
62728: LD_VAR 0 2
62732: ARRAY
62733: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
62734: LD_ADDR_VAR 0 6
62738: PUSH
62739: LD_EXP 56
62743: PUSH
62744: LD_VAR 0 2
62748: ARRAY
62749: PPUSH
62750: LD_INT 2
62752: PUSH
62753: LD_INT 30
62755: PUSH
62756: LD_INT 6
62758: PUSH
62759: EMPTY
62760: LIST
62761: LIST
62762: PUSH
62763: LD_INT 30
62765: PUSH
62766: LD_INT 7
62768: PUSH
62769: EMPTY
62770: LIST
62771: LIST
62772: PUSH
62773: EMPTY
62774: LIST
62775: LIST
62776: LIST
62777: PPUSH
62778: CALL_OW 72
62782: ST_TO_ADDR
// if not tmp and not lab then
62783: LD_VAR 0 4
62787: NOT
62788: PUSH
62789: LD_VAR 0 6
62793: NOT
62794: AND
62795: IFFALSE 62799
// continue ;
62797: GO 62715
// if tmp then
62799: LD_VAR 0 4
62803: IFFALSE 62923
// for j in tmp do
62805: LD_ADDR_VAR 0 3
62809: PUSH
62810: LD_VAR 0 4
62814: PUSH
62815: FOR_IN
62816: IFFALSE 62921
// begin if UpgradeCost ( j ) then
62818: LD_VAR 0 3
62822: PPUSH
62823: CALL 22503 0 1
62827: IFFALSE 62919
// begin ComUpgrade ( j ) ;
62829: LD_VAR 0 3
62833: PPUSH
62834: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
62838: LD_ADDR_EXP 55
62842: PUSH
62843: LD_EXP 55
62847: PPUSH
62848: LD_VAR 0 2
62852: PPUSH
62853: LD_EXP 55
62857: PUSH
62858: LD_VAR 0 2
62862: ARRAY
62863: PUSH
62864: LD_VAR 0 3
62868: DIFF
62869: PPUSH
62870: CALL_OW 1
62874: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
62875: LD_ADDR_EXP 30
62879: PUSH
62880: LD_EXP 30
62884: PPUSH
62885: LD_VAR 0 2
62889: PUSH
62890: LD_EXP 30
62894: PUSH
62895: LD_VAR 0 2
62899: ARRAY
62900: PUSH
62901: LD_INT 1
62903: PLUS
62904: PUSH
62905: EMPTY
62906: LIST
62907: LIST
62908: PPUSH
62909: LD_VAR 0 3
62913: PPUSH
62914: CALL 15990 0 3
62918: ST_TO_ADDR
// end ; end ;
62919: GO 62815
62921: POP
62922: POP
// if not lab or not mc_lab_upgrade [ i ] then
62923: LD_VAR 0 6
62927: NOT
62928: PUSH
62929: LD_EXP 57
62933: PUSH
62934: LD_VAR 0 2
62938: ARRAY
62939: NOT
62940: OR
62941: IFFALSE 62945
// continue ;
62943: GO 62715
// for j in lab do
62945: LD_ADDR_VAR 0 3
62949: PUSH
62950: LD_VAR 0 6
62954: PUSH
62955: FOR_IN
62956: IFFALSE 63121
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
62958: LD_VAR 0 3
62962: PPUSH
62963: CALL_OW 266
62967: PUSH
62968: LD_INT 6
62970: PUSH
62971: LD_INT 7
62973: PUSH
62974: EMPTY
62975: LIST
62976: LIST
62977: IN
62978: PUSH
62979: LD_VAR 0 3
62983: PPUSH
62984: CALL_OW 461
62988: PUSH
62989: LD_INT 1
62991: NONEQUAL
62992: AND
62993: IFFALSE 63119
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
62995: LD_VAR 0 3
62999: PPUSH
63000: LD_EXP 57
63004: PUSH
63005: LD_VAR 0 2
63009: ARRAY
63010: PUSH
63011: LD_INT 1
63013: ARRAY
63014: PPUSH
63015: CALL 22708 0 2
63019: IFFALSE 63119
// begin ComCancel ( j ) ;
63021: LD_VAR 0 3
63025: PPUSH
63026: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
63030: LD_VAR 0 3
63034: PPUSH
63035: LD_EXP 57
63039: PUSH
63040: LD_VAR 0 2
63044: ARRAY
63045: PUSH
63046: LD_INT 1
63048: ARRAY
63049: PPUSH
63050: CALL_OW 207
// if not j in mc_construct_list [ i ] then
63054: LD_VAR 0 3
63058: PUSH
63059: LD_EXP 30
63063: PUSH
63064: LD_VAR 0 2
63068: ARRAY
63069: IN
63070: NOT
63071: IFFALSE 63117
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
63073: LD_ADDR_EXP 30
63077: PUSH
63078: LD_EXP 30
63082: PPUSH
63083: LD_VAR 0 2
63087: PUSH
63088: LD_EXP 30
63092: PUSH
63093: LD_VAR 0 2
63097: ARRAY
63098: PUSH
63099: LD_INT 1
63101: PLUS
63102: PUSH
63103: EMPTY
63104: LIST
63105: LIST
63106: PPUSH
63107: LD_VAR 0 3
63111: PPUSH
63112: CALL 15990 0 3
63116: ST_TO_ADDR
// break ;
63117: GO 63121
// end ; end ; end ;
63119: GO 62955
63121: POP
63122: POP
// end ;
63123: GO 62715
63125: POP
63126: POP
// end ;
63127: LD_VAR 0 1
63131: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
63132: LD_INT 0
63134: PPUSH
63135: PPUSH
63136: PPUSH
63137: PPUSH
63138: PPUSH
63139: PPUSH
63140: PPUSH
63141: PPUSH
63142: PPUSH
// if not mc_bases then
63143: LD_EXP 23
63147: NOT
63148: IFFALSE 63152
// exit ;
63150: GO 63557
// for i = 1 to mc_bases do
63152: LD_ADDR_VAR 0 2
63156: PUSH
63157: DOUBLE
63158: LD_INT 1
63160: DEC
63161: ST_TO_ADDR
63162: LD_EXP 23
63166: PUSH
63167: FOR_TO
63168: IFFALSE 63555
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
63170: LD_EXP 31
63174: PUSH
63175: LD_VAR 0 2
63179: ARRAY
63180: NOT
63181: PUSH
63182: LD_EXP 23
63186: PUSH
63187: LD_VAR 0 2
63191: ARRAY
63192: PPUSH
63193: LD_INT 30
63195: PUSH
63196: LD_INT 3
63198: PUSH
63199: EMPTY
63200: LIST
63201: LIST
63202: PPUSH
63203: CALL_OW 72
63207: NOT
63208: OR
63209: IFFALSE 63213
// continue ;
63211: GO 63167
// busy := false ;
63213: LD_ADDR_VAR 0 8
63217: PUSH
63218: LD_INT 0
63220: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
63221: LD_ADDR_VAR 0 4
63225: PUSH
63226: LD_EXP 23
63230: PUSH
63231: LD_VAR 0 2
63235: ARRAY
63236: PPUSH
63237: LD_INT 30
63239: PUSH
63240: LD_INT 3
63242: PUSH
63243: EMPTY
63244: LIST
63245: LIST
63246: PPUSH
63247: CALL_OW 72
63251: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
63252: LD_ADDR_VAR 0 6
63256: PUSH
63257: LD_EXP 31
63261: PUSH
63262: LD_VAR 0 2
63266: ARRAY
63267: PPUSH
63268: LD_INT 2
63270: PUSH
63271: LD_INT 30
63273: PUSH
63274: LD_INT 32
63276: PUSH
63277: EMPTY
63278: LIST
63279: LIST
63280: PUSH
63281: LD_INT 30
63283: PUSH
63284: LD_INT 33
63286: PUSH
63287: EMPTY
63288: LIST
63289: LIST
63290: PUSH
63291: EMPTY
63292: LIST
63293: LIST
63294: LIST
63295: PPUSH
63296: CALL_OW 72
63300: ST_TO_ADDR
// if not t then
63301: LD_VAR 0 6
63305: NOT
63306: IFFALSE 63310
// continue ;
63308: GO 63167
// for j in tmp do
63310: LD_ADDR_VAR 0 3
63314: PUSH
63315: LD_VAR 0 4
63319: PUSH
63320: FOR_IN
63321: IFFALSE 63351
// if not BuildingStatus ( j ) = bs_idle then
63323: LD_VAR 0 3
63327: PPUSH
63328: CALL_OW 461
63332: PUSH
63333: LD_INT 2
63335: EQUAL
63336: NOT
63337: IFFALSE 63349
// begin busy := true ;
63339: LD_ADDR_VAR 0 8
63343: PUSH
63344: LD_INT 1
63346: ST_TO_ADDR
// break ;
63347: GO 63351
// end ;
63349: GO 63320
63351: POP
63352: POP
// if busy then
63353: LD_VAR 0 8
63357: IFFALSE 63361
// continue ;
63359: GO 63167
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
63361: LD_ADDR_VAR 0 7
63365: PUSH
63366: LD_VAR 0 6
63370: PPUSH
63371: LD_INT 35
63373: PUSH
63374: LD_INT 0
63376: PUSH
63377: EMPTY
63378: LIST
63379: LIST
63380: PPUSH
63381: CALL_OW 72
63385: ST_TO_ADDR
// if tw then
63386: LD_VAR 0 7
63390: IFFALSE 63467
// begin tw := tw [ 1 ] ;
63392: LD_ADDR_VAR 0 7
63396: PUSH
63397: LD_VAR 0 7
63401: PUSH
63402: LD_INT 1
63404: ARRAY
63405: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
63406: LD_ADDR_VAR 0 9
63410: PUSH
63411: LD_VAR 0 7
63415: PPUSH
63416: LD_EXP 48
63420: PUSH
63421: LD_VAR 0 2
63425: ARRAY
63426: PPUSH
63427: CALL 21000 0 2
63431: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
63432: LD_EXP 62
63436: PUSH
63437: LD_VAR 0 2
63441: ARRAY
63442: IFFALSE 63465
// if not weapon in mc_allowed_tower_weapons [ i ] then
63444: LD_VAR 0 9
63448: PUSH
63449: LD_EXP 62
63453: PUSH
63454: LD_VAR 0 2
63458: ARRAY
63459: IN
63460: NOT
63461: IFFALSE 63465
// continue ;
63463: GO 63167
// end else
63465: GO 63530
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
63467: LD_ADDR_VAR 0 5
63471: PUSH
63472: LD_EXP 31
63476: PUSH
63477: LD_VAR 0 2
63481: ARRAY
63482: PPUSH
63483: LD_VAR 0 4
63487: PPUSH
63488: CALL 47289 0 2
63492: ST_TO_ADDR
// if not tmp2 then
63493: LD_VAR 0 5
63497: NOT
63498: IFFALSE 63502
// continue ;
63500: GO 63167
// tw := tmp2 [ 1 ] ;
63502: LD_ADDR_VAR 0 7
63506: PUSH
63507: LD_VAR 0 5
63511: PUSH
63512: LD_INT 1
63514: ARRAY
63515: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
63516: LD_ADDR_VAR 0 9
63520: PUSH
63521: LD_VAR 0 5
63525: PUSH
63526: LD_INT 2
63528: ARRAY
63529: ST_TO_ADDR
// end ; if not weapon then
63530: LD_VAR 0 9
63534: NOT
63535: IFFALSE 63539
// continue ;
63537: GO 63167
// ComPlaceWeapon ( tw , weapon ) ;
63539: LD_VAR 0 7
63543: PPUSH
63544: LD_VAR 0 9
63548: PPUSH
63549: CALL_OW 148
// end ;
63553: GO 63167
63555: POP
63556: POP
// end ;
63557: LD_VAR 0 1
63561: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
63562: LD_INT 0
63564: PPUSH
63565: PPUSH
63566: PPUSH
63567: PPUSH
63568: PPUSH
63569: PPUSH
63570: PPUSH
// if not mc_bases then
63571: LD_EXP 23
63575: NOT
63576: IFFALSE 63580
// exit ;
63578: GO 64348
// for i = 1 to mc_bases do
63580: LD_ADDR_VAR 0 2
63584: PUSH
63585: DOUBLE
63586: LD_INT 1
63588: DEC
63589: ST_TO_ADDR
63590: LD_EXP 23
63594: PUSH
63595: FOR_TO
63596: IFFALSE 64346
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
63598: LD_EXP 36
63602: PUSH
63603: LD_VAR 0 2
63607: ARRAY
63608: NOT
63609: PUSH
63610: LD_EXP 36
63614: PUSH
63615: LD_VAR 0 2
63619: ARRAY
63620: PUSH
63621: LD_EXP 37
63625: PUSH
63626: LD_VAR 0 2
63630: ARRAY
63631: EQUAL
63632: OR
63633: PUSH
63634: LD_EXP 46
63638: PUSH
63639: LD_VAR 0 2
63643: ARRAY
63644: OR
63645: IFFALSE 63649
// continue ;
63647: GO 63595
// if mc_miners [ i ] then
63649: LD_EXP 37
63653: PUSH
63654: LD_VAR 0 2
63658: ARRAY
63659: IFFALSE 64033
// begin for j = mc_miners [ i ] downto 1 do
63661: LD_ADDR_VAR 0 3
63665: PUSH
63666: DOUBLE
63667: LD_EXP 37
63671: PUSH
63672: LD_VAR 0 2
63676: ARRAY
63677: INC
63678: ST_TO_ADDR
63679: LD_INT 1
63681: PUSH
63682: FOR_DOWNTO
63683: IFFALSE 64031
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
63685: LD_EXP 37
63689: PUSH
63690: LD_VAR 0 2
63694: ARRAY
63695: PUSH
63696: LD_VAR 0 3
63700: ARRAY
63701: PPUSH
63702: CALL_OW 301
63706: PUSH
63707: LD_EXP 37
63711: PUSH
63712: LD_VAR 0 2
63716: ARRAY
63717: PUSH
63718: LD_VAR 0 3
63722: ARRAY
63723: PPUSH
63724: CALL_OW 257
63728: PUSH
63729: LD_INT 1
63731: NONEQUAL
63732: OR
63733: IFFALSE 63796
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
63735: LD_ADDR_VAR 0 5
63739: PUSH
63740: LD_EXP 37
63744: PUSH
63745: LD_VAR 0 2
63749: ARRAY
63750: PUSH
63751: LD_EXP 37
63755: PUSH
63756: LD_VAR 0 2
63760: ARRAY
63761: PUSH
63762: LD_VAR 0 3
63766: ARRAY
63767: DIFF
63768: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
63769: LD_ADDR_EXP 37
63773: PUSH
63774: LD_EXP 37
63778: PPUSH
63779: LD_VAR 0 2
63783: PPUSH
63784: LD_VAR 0 5
63788: PPUSH
63789: CALL_OW 1
63793: ST_TO_ADDR
// continue ;
63794: GO 63682
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
63796: LD_EXP 37
63800: PUSH
63801: LD_VAR 0 2
63805: ARRAY
63806: PUSH
63807: LD_VAR 0 3
63811: ARRAY
63812: PPUSH
63813: CALL_OW 257
63817: PUSH
63818: LD_INT 1
63820: EQUAL
63821: PUSH
63822: LD_EXP 37
63826: PUSH
63827: LD_VAR 0 2
63831: ARRAY
63832: PUSH
63833: LD_VAR 0 3
63837: ARRAY
63838: PPUSH
63839: CALL_OW 459
63843: NOT
63844: AND
63845: PUSH
63846: LD_EXP 37
63850: PUSH
63851: LD_VAR 0 2
63855: ARRAY
63856: PUSH
63857: LD_VAR 0 3
63861: ARRAY
63862: PPUSH
63863: CALL_OW 314
63867: NOT
63868: AND
63869: IFFALSE 64029
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
63871: LD_EXP 37
63875: PUSH
63876: LD_VAR 0 2
63880: ARRAY
63881: PUSH
63882: LD_VAR 0 3
63886: ARRAY
63887: PPUSH
63888: CALL_OW 310
63892: IFFALSE 63915
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
63894: LD_EXP 37
63898: PUSH
63899: LD_VAR 0 2
63903: ARRAY
63904: PUSH
63905: LD_VAR 0 3
63909: ARRAY
63910: PPUSH
63911: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
63915: LD_EXP 37
63919: PUSH
63920: LD_VAR 0 2
63924: ARRAY
63925: PUSH
63926: LD_VAR 0 3
63930: ARRAY
63931: PPUSH
63932: CALL_OW 314
63936: NOT
63937: IFFALSE 64029
// begin r := rand ( 1 , mc_mines [ i ] ) ;
63939: LD_ADDR_VAR 0 7
63943: PUSH
63944: LD_INT 1
63946: PPUSH
63947: LD_EXP 36
63951: PUSH
63952: LD_VAR 0 2
63956: ARRAY
63957: PPUSH
63958: CALL_OW 12
63962: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
63963: LD_EXP 37
63967: PUSH
63968: LD_VAR 0 2
63972: ARRAY
63973: PUSH
63974: LD_VAR 0 3
63978: ARRAY
63979: PPUSH
63980: LD_EXP 36
63984: PUSH
63985: LD_VAR 0 2
63989: ARRAY
63990: PUSH
63991: LD_VAR 0 7
63995: ARRAY
63996: PUSH
63997: LD_INT 1
63999: ARRAY
64000: PPUSH
64001: LD_EXP 36
64005: PUSH
64006: LD_VAR 0 2
64010: ARRAY
64011: PUSH
64012: LD_VAR 0 7
64016: ARRAY
64017: PUSH
64018: LD_INT 2
64020: ARRAY
64021: PPUSH
64022: LD_INT 0
64024: PPUSH
64025: CALL_OW 193
// end ; end ; end ;
64029: GO 63682
64031: POP
64032: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
64033: LD_ADDR_VAR 0 5
64037: PUSH
64038: LD_EXP 23
64042: PUSH
64043: LD_VAR 0 2
64047: ARRAY
64048: PPUSH
64049: LD_INT 2
64051: PUSH
64052: LD_INT 30
64054: PUSH
64055: LD_INT 4
64057: PUSH
64058: EMPTY
64059: LIST
64060: LIST
64061: PUSH
64062: LD_INT 30
64064: PUSH
64065: LD_INT 5
64067: PUSH
64068: EMPTY
64069: LIST
64070: LIST
64071: PUSH
64072: LD_INT 30
64074: PUSH
64075: LD_INT 32
64077: PUSH
64078: EMPTY
64079: LIST
64080: LIST
64081: PUSH
64082: EMPTY
64083: LIST
64084: LIST
64085: LIST
64086: LIST
64087: PPUSH
64088: CALL_OW 72
64092: ST_TO_ADDR
// if not tmp then
64093: LD_VAR 0 5
64097: NOT
64098: IFFALSE 64102
// continue ;
64100: GO 63595
// list := [ ] ;
64102: LD_ADDR_VAR 0 6
64106: PUSH
64107: EMPTY
64108: ST_TO_ADDR
// for j in tmp do
64109: LD_ADDR_VAR 0 3
64113: PUSH
64114: LD_VAR 0 5
64118: PUSH
64119: FOR_IN
64120: IFFALSE 64189
// begin for k in UnitsInside ( j ) do
64122: LD_ADDR_VAR 0 4
64126: PUSH
64127: LD_VAR 0 3
64131: PPUSH
64132: CALL_OW 313
64136: PUSH
64137: FOR_IN
64138: IFFALSE 64185
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
64140: LD_VAR 0 4
64144: PPUSH
64145: CALL_OW 257
64149: PUSH
64150: LD_INT 1
64152: EQUAL
64153: PUSH
64154: LD_VAR 0 4
64158: PPUSH
64159: CALL_OW 459
64163: NOT
64164: AND
64165: IFFALSE 64183
// list := list ^ k ;
64167: LD_ADDR_VAR 0 6
64171: PUSH
64172: LD_VAR 0 6
64176: PUSH
64177: LD_VAR 0 4
64181: ADD
64182: ST_TO_ADDR
64183: GO 64137
64185: POP
64186: POP
// end ;
64187: GO 64119
64189: POP
64190: POP
// list := list diff mc_miners [ i ] ;
64191: LD_ADDR_VAR 0 6
64195: PUSH
64196: LD_VAR 0 6
64200: PUSH
64201: LD_EXP 37
64205: PUSH
64206: LD_VAR 0 2
64210: ARRAY
64211: DIFF
64212: ST_TO_ADDR
// if not list then
64213: LD_VAR 0 6
64217: NOT
64218: IFFALSE 64222
// continue ;
64220: GO 63595
// k := mc_mines [ i ] - mc_miners [ i ] ;
64222: LD_ADDR_VAR 0 4
64226: PUSH
64227: LD_EXP 36
64231: PUSH
64232: LD_VAR 0 2
64236: ARRAY
64237: PUSH
64238: LD_EXP 37
64242: PUSH
64243: LD_VAR 0 2
64247: ARRAY
64248: MINUS
64249: ST_TO_ADDR
// if k > list then
64250: LD_VAR 0 4
64254: PUSH
64255: LD_VAR 0 6
64259: GREATER
64260: IFFALSE 64272
// k := list ;
64262: LD_ADDR_VAR 0 4
64266: PUSH
64267: LD_VAR 0 6
64271: ST_TO_ADDR
// for j = 1 to k do
64272: LD_ADDR_VAR 0 3
64276: PUSH
64277: DOUBLE
64278: LD_INT 1
64280: DEC
64281: ST_TO_ADDR
64282: LD_VAR 0 4
64286: PUSH
64287: FOR_TO
64288: IFFALSE 64342
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
64290: LD_ADDR_EXP 37
64294: PUSH
64295: LD_EXP 37
64299: PPUSH
64300: LD_VAR 0 2
64304: PUSH
64305: LD_EXP 37
64309: PUSH
64310: LD_VAR 0 2
64314: ARRAY
64315: PUSH
64316: LD_INT 1
64318: PLUS
64319: PUSH
64320: EMPTY
64321: LIST
64322: LIST
64323: PPUSH
64324: LD_VAR 0 6
64328: PUSH
64329: LD_VAR 0 3
64333: ARRAY
64334: PPUSH
64335: CALL 15990 0 3
64339: ST_TO_ADDR
64340: GO 64287
64342: POP
64343: POP
// end ;
64344: GO 63595
64346: POP
64347: POP
// end ;
64348: LD_VAR 0 1
64352: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
64353: LD_INT 0
64355: PPUSH
64356: PPUSH
64357: PPUSH
64358: PPUSH
64359: PPUSH
64360: PPUSH
64361: PPUSH
64362: PPUSH
64363: PPUSH
64364: PPUSH
64365: PPUSH
// if not mc_bases then
64366: LD_EXP 23
64370: NOT
64371: IFFALSE 64375
// exit ;
64373: GO 66198
// for i = 1 to mc_bases do
64375: LD_ADDR_VAR 0 2
64379: PUSH
64380: DOUBLE
64381: LD_INT 1
64383: DEC
64384: ST_TO_ADDR
64385: LD_EXP 23
64389: PUSH
64390: FOR_TO
64391: IFFALSE 66196
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
64393: LD_EXP 23
64397: PUSH
64398: LD_VAR 0 2
64402: ARRAY
64403: NOT
64404: PUSH
64405: LD_EXP 30
64409: PUSH
64410: LD_VAR 0 2
64414: ARRAY
64415: OR
64416: IFFALSE 64420
// continue ;
64418: GO 64390
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
64420: LD_EXP 39
64424: PUSH
64425: LD_VAR 0 2
64429: ARRAY
64430: NOT
64431: PUSH
64432: LD_EXP 40
64436: PUSH
64437: LD_VAR 0 2
64441: ARRAY
64442: AND
64443: IFFALSE 64481
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
64445: LD_ADDR_EXP 40
64449: PUSH
64450: LD_EXP 40
64454: PPUSH
64455: LD_VAR 0 2
64459: PPUSH
64460: EMPTY
64461: PPUSH
64462: CALL_OW 1
64466: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
64467: LD_VAR 0 2
64471: PPUSH
64472: LD_INT 107
64474: PPUSH
64475: CALL 55249 0 2
// continue ;
64479: GO 64390
// end ; target := [ ] ;
64481: LD_ADDR_VAR 0 7
64485: PUSH
64486: EMPTY
64487: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
64488: LD_ADDR_VAR 0 6
64492: PUSH
64493: LD_EXP 23
64497: PUSH
64498: LD_VAR 0 2
64502: ARRAY
64503: PUSH
64504: LD_INT 1
64506: ARRAY
64507: PPUSH
64508: CALL_OW 255
64512: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64513: LD_ADDR_VAR 0 9
64517: PUSH
64518: LD_EXP 23
64522: PUSH
64523: LD_VAR 0 2
64527: ARRAY
64528: PPUSH
64529: LD_INT 2
64531: PUSH
64532: LD_INT 30
64534: PUSH
64535: LD_INT 0
64537: PUSH
64538: EMPTY
64539: LIST
64540: LIST
64541: PUSH
64542: LD_INT 30
64544: PUSH
64545: LD_INT 1
64547: PUSH
64548: EMPTY
64549: LIST
64550: LIST
64551: PUSH
64552: EMPTY
64553: LIST
64554: LIST
64555: LIST
64556: PPUSH
64557: CALL_OW 72
64561: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
64562: LD_ADDR_VAR 0 3
64566: PUSH
64567: DOUBLE
64568: LD_EXP 39
64572: PUSH
64573: LD_VAR 0 2
64577: ARRAY
64578: INC
64579: ST_TO_ADDR
64580: LD_INT 1
64582: PUSH
64583: FOR_DOWNTO
64584: IFFALSE 64829
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
64586: LD_EXP 39
64590: PUSH
64591: LD_VAR 0 2
64595: ARRAY
64596: PUSH
64597: LD_VAR 0 3
64601: ARRAY
64602: PUSH
64603: LD_INT 2
64605: ARRAY
64606: PPUSH
64607: LD_EXP 39
64611: PUSH
64612: LD_VAR 0 2
64616: ARRAY
64617: PUSH
64618: LD_VAR 0 3
64622: ARRAY
64623: PUSH
64624: LD_INT 3
64626: ARRAY
64627: PPUSH
64628: CALL_OW 488
64632: PUSH
64633: LD_EXP 39
64637: PUSH
64638: LD_VAR 0 2
64642: ARRAY
64643: PUSH
64644: LD_VAR 0 3
64648: ARRAY
64649: PUSH
64650: LD_INT 2
64652: ARRAY
64653: PPUSH
64654: LD_EXP 39
64658: PUSH
64659: LD_VAR 0 2
64663: ARRAY
64664: PUSH
64665: LD_VAR 0 3
64669: ARRAY
64670: PUSH
64671: LD_INT 3
64673: ARRAY
64674: PPUSH
64675: CALL_OW 284
64679: PUSH
64680: LD_INT 0
64682: EQUAL
64683: AND
64684: IFFALSE 64739
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
64686: LD_ADDR_VAR 0 5
64690: PUSH
64691: LD_EXP 39
64695: PUSH
64696: LD_VAR 0 2
64700: ARRAY
64701: PPUSH
64702: LD_VAR 0 3
64706: PPUSH
64707: CALL_OW 3
64711: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
64712: LD_ADDR_EXP 39
64716: PUSH
64717: LD_EXP 39
64721: PPUSH
64722: LD_VAR 0 2
64726: PPUSH
64727: LD_VAR 0 5
64731: PPUSH
64732: CALL_OW 1
64736: ST_TO_ADDR
// continue ;
64737: GO 64583
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
64739: LD_VAR 0 6
64743: PPUSH
64744: LD_EXP 39
64748: PUSH
64749: LD_VAR 0 2
64753: ARRAY
64754: PUSH
64755: LD_VAR 0 3
64759: ARRAY
64760: PUSH
64761: LD_INT 2
64763: ARRAY
64764: PPUSH
64765: LD_EXP 39
64769: PUSH
64770: LD_VAR 0 2
64774: ARRAY
64775: PUSH
64776: LD_VAR 0 3
64780: ARRAY
64781: PUSH
64782: LD_INT 3
64784: ARRAY
64785: PPUSH
64786: LD_INT 30
64788: PPUSH
64789: CALL 16886 0 4
64793: PUSH
64794: LD_INT 4
64796: ARRAY
64797: PUSH
64798: LD_INT 0
64800: EQUAL
64801: IFFALSE 64827
// begin target := mc_crates [ i ] [ j ] ;
64803: LD_ADDR_VAR 0 7
64807: PUSH
64808: LD_EXP 39
64812: PUSH
64813: LD_VAR 0 2
64817: ARRAY
64818: PUSH
64819: LD_VAR 0 3
64823: ARRAY
64824: ST_TO_ADDR
// break ;
64825: GO 64829
// end ; end ;
64827: GO 64583
64829: POP
64830: POP
// if not target then
64831: LD_VAR 0 7
64835: NOT
64836: IFFALSE 64840
// continue ;
64838: GO 64390
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
64840: LD_ADDR_VAR 0 8
64844: PUSH
64845: LD_EXP 42
64849: PUSH
64850: LD_VAR 0 2
64854: ARRAY
64855: PPUSH
64856: LD_INT 2
64858: PUSH
64859: LD_INT 3
64861: PUSH
64862: LD_INT 58
64864: PUSH
64865: EMPTY
64866: LIST
64867: PUSH
64868: EMPTY
64869: LIST
64870: LIST
64871: PUSH
64872: LD_INT 61
64874: PUSH
64875: EMPTY
64876: LIST
64877: PUSH
64878: LD_INT 33
64880: PUSH
64881: LD_INT 5
64883: PUSH
64884: EMPTY
64885: LIST
64886: LIST
64887: PUSH
64888: LD_INT 33
64890: PUSH
64891: LD_INT 3
64893: PUSH
64894: EMPTY
64895: LIST
64896: LIST
64897: PUSH
64898: EMPTY
64899: LIST
64900: LIST
64901: LIST
64902: LIST
64903: LIST
64904: PUSH
64905: LD_INT 2
64907: PUSH
64908: LD_INT 34
64910: PUSH
64911: LD_INT 32
64913: PUSH
64914: EMPTY
64915: LIST
64916: LIST
64917: PUSH
64918: LD_INT 34
64920: PUSH
64921: LD_INT 51
64923: PUSH
64924: EMPTY
64925: LIST
64926: LIST
64927: PUSH
64928: LD_INT 34
64930: PUSH
64931: LD_INT 12
64933: PUSH
64934: EMPTY
64935: LIST
64936: LIST
64937: PUSH
64938: EMPTY
64939: LIST
64940: LIST
64941: LIST
64942: LIST
64943: PUSH
64944: EMPTY
64945: LIST
64946: LIST
64947: PPUSH
64948: CALL_OW 72
64952: ST_TO_ADDR
// if not cargo then
64953: LD_VAR 0 8
64957: NOT
64958: IFFALSE 65664
// begin if mc_crates_collector [ i ] < 5 then
64960: LD_EXP 40
64964: PUSH
64965: LD_VAR 0 2
64969: ARRAY
64970: PUSH
64971: LD_INT 5
64973: LESS
64974: IFFALSE 65340
// begin if mc_ape [ i ] then
64976: LD_EXP 52
64980: PUSH
64981: LD_VAR 0 2
64985: ARRAY
64986: IFFALSE 65033
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
64988: LD_ADDR_VAR 0 5
64992: PUSH
64993: LD_EXP 52
64997: PUSH
64998: LD_VAR 0 2
65002: ARRAY
65003: PPUSH
65004: LD_INT 25
65006: PUSH
65007: LD_INT 16
65009: PUSH
65010: EMPTY
65011: LIST
65012: LIST
65013: PUSH
65014: LD_INT 24
65016: PUSH
65017: LD_INT 750
65019: PUSH
65020: EMPTY
65021: LIST
65022: LIST
65023: PUSH
65024: EMPTY
65025: LIST
65026: LIST
65027: PPUSH
65028: CALL_OW 72
65032: ST_TO_ADDR
// if not tmp then
65033: LD_VAR 0 5
65037: NOT
65038: IFFALSE 65085
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
65040: LD_ADDR_VAR 0 5
65044: PUSH
65045: LD_EXP 23
65049: PUSH
65050: LD_VAR 0 2
65054: ARRAY
65055: PPUSH
65056: LD_INT 25
65058: PUSH
65059: LD_INT 2
65061: PUSH
65062: EMPTY
65063: LIST
65064: LIST
65065: PUSH
65066: LD_INT 24
65068: PUSH
65069: LD_INT 750
65071: PUSH
65072: EMPTY
65073: LIST
65074: LIST
65075: PUSH
65076: EMPTY
65077: LIST
65078: LIST
65079: PPUSH
65080: CALL_OW 72
65084: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
65085: LD_EXP 52
65089: PUSH
65090: LD_VAR 0 2
65094: ARRAY
65095: PUSH
65096: LD_EXP 23
65100: PUSH
65101: LD_VAR 0 2
65105: ARRAY
65106: PPUSH
65107: LD_INT 25
65109: PUSH
65110: LD_INT 2
65112: PUSH
65113: EMPTY
65114: LIST
65115: LIST
65116: PUSH
65117: LD_INT 24
65119: PUSH
65120: LD_INT 750
65122: PUSH
65123: EMPTY
65124: LIST
65125: LIST
65126: PUSH
65127: EMPTY
65128: LIST
65129: LIST
65130: PPUSH
65131: CALL_OW 72
65135: AND
65136: PUSH
65137: LD_VAR 0 5
65141: PUSH
65142: LD_INT 5
65144: LESS
65145: AND
65146: IFFALSE 65228
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
65148: LD_ADDR_VAR 0 3
65152: PUSH
65153: LD_EXP 23
65157: PUSH
65158: LD_VAR 0 2
65162: ARRAY
65163: PPUSH
65164: LD_INT 25
65166: PUSH
65167: LD_INT 2
65169: PUSH
65170: EMPTY
65171: LIST
65172: LIST
65173: PUSH
65174: LD_INT 24
65176: PUSH
65177: LD_INT 750
65179: PUSH
65180: EMPTY
65181: LIST
65182: LIST
65183: PUSH
65184: EMPTY
65185: LIST
65186: LIST
65187: PPUSH
65188: CALL_OW 72
65192: PUSH
65193: FOR_IN
65194: IFFALSE 65226
// begin tmp := tmp union j ;
65196: LD_ADDR_VAR 0 5
65200: PUSH
65201: LD_VAR 0 5
65205: PUSH
65206: LD_VAR 0 3
65210: UNION
65211: ST_TO_ADDR
// if tmp >= 5 then
65212: LD_VAR 0 5
65216: PUSH
65217: LD_INT 5
65219: GREATEREQUAL
65220: IFFALSE 65224
// break ;
65222: GO 65226
// end ;
65224: GO 65193
65226: POP
65227: POP
// end ; if not tmp then
65228: LD_VAR 0 5
65232: NOT
65233: IFFALSE 65237
// continue ;
65235: GO 64390
// for j in tmp do
65237: LD_ADDR_VAR 0 3
65241: PUSH
65242: LD_VAR 0 5
65246: PUSH
65247: FOR_IN
65248: IFFALSE 65338
// if not GetTag ( j ) then
65250: LD_VAR 0 3
65254: PPUSH
65255: CALL_OW 110
65259: NOT
65260: IFFALSE 65336
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
65262: LD_ADDR_EXP 40
65266: PUSH
65267: LD_EXP 40
65271: PPUSH
65272: LD_VAR 0 2
65276: PUSH
65277: LD_EXP 40
65281: PUSH
65282: LD_VAR 0 2
65286: ARRAY
65287: PUSH
65288: LD_INT 1
65290: PLUS
65291: PUSH
65292: EMPTY
65293: LIST
65294: LIST
65295: PPUSH
65296: LD_VAR 0 3
65300: PPUSH
65301: CALL 15990 0 3
65305: ST_TO_ADDR
// SetTag ( j , 107 ) ;
65306: LD_VAR 0 3
65310: PPUSH
65311: LD_INT 107
65313: PPUSH
65314: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
65318: LD_EXP 40
65322: PUSH
65323: LD_VAR 0 2
65327: ARRAY
65328: PUSH
65329: LD_INT 5
65331: GREATEREQUAL
65332: IFFALSE 65336
// break ;
65334: GO 65338
// end ;
65336: GO 65247
65338: POP
65339: POP
// end ; if mc_crates_collector [ i ] and target then
65340: LD_EXP 40
65344: PUSH
65345: LD_VAR 0 2
65349: ARRAY
65350: PUSH
65351: LD_VAR 0 7
65355: AND
65356: IFFALSE 65662
// begin if mc_crates_collector [ i ] < target [ 1 ] then
65358: LD_EXP 40
65362: PUSH
65363: LD_VAR 0 2
65367: ARRAY
65368: PUSH
65369: LD_VAR 0 7
65373: PUSH
65374: LD_INT 1
65376: ARRAY
65377: LESS
65378: IFFALSE 65398
// tmp := mc_crates_collector [ i ] else
65380: LD_ADDR_VAR 0 5
65384: PUSH
65385: LD_EXP 40
65389: PUSH
65390: LD_VAR 0 2
65394: ARRAY
65395: ST_TO_ADDR
65396: GO 65412
// tmp := target [ 1 ] ;
65398: LD_ADDR_VAR 0 5
65402: PUSH
65403: LD_VAR 0 7
65407: PUSH
65408: LD_INT 1
65410: ARRAY
65411: ST_TO_ADDR
// k := 0 ;
65412: LD_ADDR_VAR 0 4
65416: PUSH
65417: LD_INT 0
65419: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
65420: LD_ADDR_VAR 0 3
65424: PUSH
65425: LD_EXP 40
65429: PUSH
65430: LD_VAR 0 2
65434: ARRAY
65435: PUSH
65436: FOR_IN
65437: IFFALSE 65660
// begin k := k + 1 ;
65439: LD_ADDR_VAR 0 4
65443: PUSH
65444: LD_VAR 0 4
65448: PUSH
65449: LD_INT 1
65451: PLUS
65452: ST_TO_ADDR
// if k > tmp then
65453: LD_VAR 0 4
65457: PUSH
65458: LD_VAR 0 5
65462: GREATER
65463: IFFALSE 65467
// break ;
65465: GO 65660
// if not GetClass ( j ) in [ 2 , 16 ] then
65467: LD_VAR 0 3
65471: PPUSH
65472: CALL_OW 257
65476: PUSH
65477: LD_INT 2
65479: PUSH
65480: LD_INT 16
65482: PUSH
65483: EMPTY
65484: LIST
65485: LIST
65486: IN
65487: NOT
65488: IFFALSE 65541
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
65490: LD_ADDR_EXP 40
65494: PUSH
65495: LD_EXP 40
65499: PPUSH
65500: LD_VAR 0 2
65504: PPUSH
65505: LD_EXP 40
65509: PUSH
65510: LD_VAR 0 2
65514: ARRAY
65515: PUSH
65516: LD_VAR 0 3
65520: DIFF
65521: PPUSH
65522: CALL_OW 1
65526: ST_TO_ADDR
// SetTag ( j , 0 ) ;
65527: LD_VAR 0 3
65531: PPUSH
65532: LD_INT 0
65534: PPUSH
65535: CALL_OW 109
// continue ;
65539: GO 65436
// end ; if IsInUnit ( j ) then
65541: LD_VAR 0 3
65545: PPUSH
65546: CALL_OW 310
65550: IFFALSE 65561
// ComExitBuilding ( j ) ;
65552: LD_VAR 0 3
65556: PPUSH
65557: CALL_OW 122
// wait ( 3 ) ;
65561: LD_INT 3
65563: PPUSH
65564: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
65568: LD_VAR 0 3
65572: PPUSH
65573: CALL_OW 314
65577: PUSH
65578: LD_VAR 0 6
65582: PPUSH
65583: LD_VAR 0 7
65587: PUSH
65588: LD_INT 2
65590: ARRAY
65591: PPUSH
65592: LD_VAR 0 7
65596: PUSH
65597: LD_INT 3
65599: ARRAY
65600: PPUSH
65601: LD_INT 30
65603: PPUSH
65604: CALL 16886 0 4
65608: PUSH
65609: LD_INT 4
65611: ARRAY
65612: AND
65613: IFFALSE 65631
// ComStandNearbyBuilding ( j , depot ) else
65615: LD_VAR 0 3
65619: PPUSH
65620: LD_VAR 0 9
65624: PPUSH
65625: CALL 12568 0 2
65629: GO 65658
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
65631: LD_VAR 0 3
65635: PPUSH
65636: LD_VAR 0 7
65640: PUSH
65641: LD_INT 2
65643: ARRAY
65644: PPUSH
65645: LD_VAR 0 7
65649: PUSH
65650: LD_INT 3
65652: ARRAY
65653: PPUSH
65654: CALL_OW 117
// end ;
65658: GO 65436
65660: POP
65661: POP
// end ; end else
65662: GO 66194
// begin for j in cargo do
65664: LD_ADDR_VAR 0 3
65668: PUSH
65669: LD_VAR 0 8
65673: PUSH
65674: FOR_IN
65675: IFFALSE 66192
// begin if GetTag ( j ) <> 0 then
65677: LD_VAR 0 3
65681: PPUSH
65682: CALL_OW 110
65686: PUSH
65687: LD_INT 0
65689: NONEQUAL
65690: IFFALSE 65694
// continue ;
65692: GO 65674
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
65694: LD_VAR 0 3
65698: PPUSH
65699: CALL_OW 256
65703: PUSH
65704: LD_INT 1000
65706: LESS
65707: PUSH
65708: LD_VAR 0 3
65712: PPUSH
65713: LD_EXP 47
65717: PUSH
65718: LD_VAR 0 2
65722: ARRAY
65723: PPUSH
65724: CALL_OW 308
65728: NOT
65729: AND
65730: IFFALSE 65752
// ComMoveToArea ( j , mc_parking [ i ] ) ;
65732: LD_VAR 0 3
65736: PPUSH
65737: LD_EXP 47
65741: PUSH
65742: LD_VAR 0 2
65746: ARRAY
65747: PPUSH
65748: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
65752: LD_VAR 0 3
65756: PPUSH
65757: CALL_OW 256
65761: PUSH
65762: LD_INT 1000
65764: LESS
65765: PUSH
65766: LD_VAR 0 3
65770: PPUSH
65771: LD_EXP 47
65775: PUSH
65776: LD_VAR 0 2
65780: ARRAY
65781: PPUSH
65782: CALL_OW 308
65786: AND
65787: IFFALSE 65791
// continue ;
65789: GO 65674
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
65791: LD_VAR 0 3
65795: PPUSH
65796: CALL_OW 262
65800: PUSH
65801: LD_INT 2
65803: EQUAL
65804: PUSH
65805: LD_VAR 0 3
65809: PPUSH
65810: CALL_OW 261
65814: PUSH
65815: LD_INT 15
65817: LESS
65818: AND
65819: IFFALSE 65823
// continue ;
65821: GO 65674
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
65823: LD_VAR 0 3
65827: PPUSH
65828: CALL_OW 262
65832: PUSH
65833: LD_INT 1
65835: EQUAL
65836: PUSH
65837: LD_VAR 0 3
65841: PPUSH
65842: CALL_OW 261
65846: PUSH
65847: LD_INT 10
65849: LESS
65850: AND
65851: IFFALSE 66131
// begin if not depot then
65853: LD_VAR 0 9
65857: NOT
65858: IFFALSE 65862
// continue ;
65860: GO 65674
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
65862: LD_VAR 0 3
65866: PPUSH
65867: LD_VAR 0 9
65871: PPUSH
65872: LD_VAR 0 3
65876: PPUSH
65877: CALL_OW 74
65881: PPUSH
65882: CALL_OW 296
65886: PUSH
65887: LD_INT 6
65889: LESS
65890: IFFALSE 65906
// SetFuel ( j , 100 ) else
65892: LD_VAR 0 3
65896: PPUSH
65897: LD_INT 100
65899: PPUSH
65900: CALL_OW 240
65904: GO 66131
// if GetFuel ( j ) = 0 then
65906: LD_VAR 0 3
65910: PPUSH
65911: CALL_OW 261
65915: PUSH
65916: LD_INT 0
65918: EQUAL
65919: IFFALSE 66131
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
65921: LD_ADDR_EXP 42
65925: PUSH
65926: LD_EXP 42
65930: PPUSH
65931: LD_VAR 0 2
65935: PPUSH
65936: LD_EXP 42
65940: PUSH
65941: LD_VAR 0 2
65945: ARRAY
65946: PUSH
65947: LD_VAR 0 3
65951: DIFF
65952: PPUSH
65953: CALL_OW 1
65957: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
65958: LD_VAR 0 3
65962: PPUSH
65963: CALL_OW 263
65967: PUSH
65968: LD_INT 1
65970: EQUAL
65971: IFFALSE 65987
// ComExitVehicle ( IsInUnit ( j ) ) ;
65973: LD_VAR 0 3
65977: PPUSH
65978: CALL_OW 310
65982: PPUSH
65983: CALL_OW 121
// if GetControl ( j ) = control_remote then
65987: LD_VAR 0 3
65991: PPUSH
65992: CALL_OW 263
65996: PUSH
65997: LD_INT 2
65999: EQUAL
66000: IFFALSE 66011
// ComUnlink ( j ) ;
66002: LD_VAR 0 3
66006: PPUSH
66007: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
66011: LD_ADDR_VAR 0 10
66015: PUSH
66016: LD_VAR 0 2
66020: PPUSH
66021: LD_INT 3
66023: PPUSH
66024: CALL 75770 0 2
66028: ST_TO_ADDR
// if fac then
66029: LD_VAR 0 10
66033: IFFALSE 66129
// begin for k in fac do
66035: LD_ADDR_VAR 0 4
66039: PUSH
66040: LD_VAR 0 10
66044: PUSH
66045: FOR_IN
66046: IFFALSE 66127
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
66048: LD_ADDR_VAR 0 11
66052: PUSH
66053: LD_VAR 0 10
66057: PPUSH
66058: LD_VAR 0 3
66062: PPUSH
66063: CALL_OW 265
66067: PPUSH
66068: LD_VAR 0 3
66072: PPUSH
66073: CALL_OW 262
66077: PPUSH
66078: LD_VAR 0 3
66082: PPUSH
66083: CALL_OW 263
66087: PPUSH
66088: LD_VAR 0 3
66092: PPUSH
66093: CALL_OW 264
66097: PPUSH
66098: CALL 13486 0 5
66102: ST_TO_ADDR
// if components then
66103: LD_VAR 0 11
66107: IFFALSE 66125
// begin MC_InsertProduceList ( i , components ) ;
66109: LD_VAR 0 2
66113: PPUSH
66114: LD_VAR 0 11
66118: PPUSH
66119: CALL 75315 0 2
// break ;
66123: GO 66127
// end ; end ;
66125: GO 66045
66127: POP
66128: POP
// end ; continue ;
66129: GO 65674
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
66131: LD_VAR 0 3
66135: PPUSH
66136: LD_INT 1
66138: PPUSH
66139: CALL_OW 289
66143: PUSH
66144: LD_INT 100
66146: LESS
66147: PUSH
66148: LD_VAR 0 3
66152: PPUSH
66153: CALL_OW 314
66157: NOT
66158: AND
66159: IFFALSE 66188
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
66161: LD_VAR 0 3
66165: PPUSH
66166: LD_VAR 0 7
66170: PUSH
66171: LD_INT 2
66173: ARRAY
66174: PPUSH
66175: LD_VAR 0 7
66179: PUSH
66180: LD_INT 3
66182: ARRAY
66183: PPUSH
66184: CALL_OW 117
// break ;
66188: GO 66192
// end ;
66190: GO 65674
66192: POP
66193: POP
// end ; end ;
66194: GO 64390
66196: POP
66197: POP
// end ;
66198: LD_VAR 0 1
66202: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
66203: LD_INT 0
66205: PPUSH
66206: PPUSH
66207: PPUSH
66208: PPUSH
// if not mc_bases then
66209: LD_EXP 23
66213: NOT
66214: IFFALSE 66218
// exit ;
66216: GO 66379
// for i = 1 to mc_bases do
66218: LD_ADDR_VAR 0 2
66222: PUSH
66223: DOUBLE
66224: LD_INT 1
66226: DEC
66227: ST_TO_ADDR
66228: LD_EXP 23
66232: PUSH
66233: FOR_TO
66234: IFFALSE 66377
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
66236: LD_ADDR_VAR 0 4
66240: PUSH
66241: LD_EXP 42
66245: PUSH
66246: LD_VAR 0 2
66250: ARRAY
66251: PUSH
66252: LD_EXP 45
66256: PUSH
66257: LD_VAR 0 2
66261: ARRAY
66262: UNION
66263: PPUSH
66264: LD_INT 33
66266: PUSH
66267: LD_INT 2
66269: PUSH
66270: EMPTY
66271: LIST
66272: LIST
66273: PPUSH
66274: CALL_OW 72
66278: ST_TO_ADDR
// if tmp then
66279: LD_VAR 0 4
66283: IFFALSE 66375
// for j in tmp do
66285: LD_ADDR_VAR 0 3
66289: PUSH
66290: LD_VAR 0 4
66294: PUSH
66295: FOR_IN
66296: IFFALSE 66373
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
66298: LD_VAR 0 3
66302: PPUSH
66303: CALL_OW 312
66307: NOT
66308: PUSH
66309: LD_VAR 0 3
66313: PPUSH
66314: CALL_OW 256
66318: PUSH
66319: LD_INT 250
66321: GREATEREQUAL
66322: AND
66323: IFFALSE 66336
// Connect ( j ) else
66325: LD_VAR 0 3
66329: PPUSH
66330: CALL 18961 0 1
66334: GO 66371
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
66336: LD_VAR 0 3
66340: PPUSH
66341: CALL_OW 256
66345: PUSH
66346: LD_INT 250
66348: LESS
66349: PUSH
66350: LD_VAR 0 3
66354: PPUSH
66355: CALL_OW 312
66359: AND
66360: IFFALSE 66371
// ComUnlink ( j ) ;
66362: LD_VAR 0 3
66366: PPUSH
66367: CALL_OW 136
66371: GO 66295
66373: POP
66374: POP
// end ;
66375: GO 66233
66377: POP
66378: POP
// end ;
66379: LD_VAR 0 1
66383: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
66384: LD_INT 0
66386: PPUSH
66387: PPUSH
66388: PPUSH
66389: PPUSH
66390: PPUSH
// if not mc_bases then
66391: LD_EXP 23
66395: NOT
66396: IFFALSE 66400
// exit ;
66398: GO 66845
// for i = 1 to mc_bases do
66400: LD_ADDR_VAR 0 2
66404: PUSH
66405: DOUBLE
66406: LD_INT 1
66408: DEC
66409: ST_TO_ADDR
66410: LD_EXP 23
66414: PUSH
66415: FOR_TO
66416: IFFALSE 66843
// begin if not mc_produce [ i ] then
66418: LD_EXP 44
66422: PUSH
66423: LD_VAR 0 2
66427: ARRAY
66428: NOT
66429: IFFALSE 66433
// continue ;
66431: GO 66415
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
66433: LD_ADDR_VAR 0 5
66437: PUSH
66438: LD_EXP 23
66442: PUSH
66443: LD_VAR 0 2
66447: ARRAY
66448: PPUSH
66449: LD_INT 30
66451: PUSH
66452: LD_INT 3
66454: PUSH
66455: EMPTY
66456: LIST
66457: LIST
66458: PPUSH
66459: CALL_OW 72
66463: ST_TO_ADDR
// if not fac then
66464: LD_VAR 0 5
66468: NOT
66469: IFFALSE 66473
// continue ;
66471: GO 66415
// for j in fac do
66473: LD_ADDR_VAR 0 3
66477: PUSH
66478: LD_VAR 0 5
66482: PUSH
66483: FOR_IN
66484: IFFALSE 66839
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
66486: LD_VAR 0 3
66490: PPUSH
66491: CALL_OW 461
66495: PUSH
66496: LD_INT 2
66498: NONEQUAL
66499: PUSH
66500: LD_VAR 0 3
66504: PPUSH
66505: LD_INT 15
66507: PPUSH
66508: CALL 18589 0 2
66512: PUSH
66513: LD_INT 4
66515: ARRAY
66516: OR
66517: IFFALSE 66521
// continue ;
66519: GO 66483
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
66521: LD_VAR 0 3
66525: PPUSH
66526: LD_EXP 44
66530: PUSH
66531: LD_VAR 0 2
66535: ARRAY
66536: PUSH
66537: LD_INT 1
66539: ARRAY
66540: PUSH
66541: LD_INT 1
66543: ARRAY
66544: PPUSH
66545: LD_EXP 44
66549: PUSH
66550: LD_VAR 0 2
66554: ARRAY
66555: PUSH
66556: LD_INT 1
66558: ARRAY
66559: PUSH
66560: LD_INT 2
66562: ARRAY
66563: PPUSH
66564: LD_EXP 44
66568: PUSH
66569: LD_VAR 0 2
66573: ARRAY
66574: PUSH
66575: LD_INT 1
66577: ARRAY
66578: PUSH
66579: LD_INT 3
66581: ARRAY
66582: PPUSH
66583: LD_EXP 44
66587: PUSH
66588: LD_VAR 0 2
66592: ARRAY
66593: PUSH
66594: LD_INT 1
66596: ARRAY
66597: PUSH
66598: LD_INT 4
66600: ARRAY
66601: PPUSH
66602: CALL_OW 448
66606: PUSH
66607: LD_VAR 0 3
66611: PPUSH
66612: LD_EXP 44
66616: PUSH
66617: LD_VAR 0 2
66621: ARRAY
66622: PUSH
66623: LD_INT 1
66625: ARRAY
66626: PUSH
66627: LD_INT 1
66629: ARRAY
66630: PUSH
66631: LD_EXP 44
66635: PUSH
66636: LD_VAR 0 2
66640: ARRAY
66641: PUSH
66642: LD_INT 1
66644: ARRAY
66645: PUSH
66646: LD_INT 2
66648: ARRAY
66649: PUSH
66650: LD_EXP 44
66654: PUSH
66655: LD_VAR 0 2
66659: ARRAY
66660: PUSH
66661: LD_INT 1
66663: ARRAY
66664: PUSH
66665: LD_INT 3
66667: ARRAY
66668: PUSH
66669: LD_EXP 44
66673: PUSH
66674: LD_VAR 0 2
66678: ARRAY
66679: PUSH
66680: LD_INT 1
66682: ARRAY
66683: PUSH
66684: LD_INT 4
66686: ARRAY
66687: PUSH
66688: EMPTY
66689: LIST
66690: LIST
66691: LIST
66692: LIST
66693: PPUSH
66694: CALL 22356 0 2
66698: AND
66699: IFFALSE 66837
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
66701: LD_VAR 0 3
66705: PPUSH
66706: LD_EXP 44
66710: PUSH
66711: LD_VAR 0 2
66715: ARRAY
66716: PUSH
66717: LD_INT 1
66719: ARRAY
66720: PUSH
66721: LD_INT 1
66723: ARRAY
66724: PPUSH
66725: LD_EXP 44
66729: PUSH
66730: LD_VAR 0 2
66734: ARRAY
66735: PUSH
66736: LD_INT 1
66738: ARRAY
66739: PUSH
66740: LD_INT 2
66742: ARRAY
66743: PPUSH
66744: LD_EXP 44
66748: PUSH
66749: LD_VAR 0 2
66753: ARRAY
66754: PUSH
66755: LD_INT 1
66757: ARRAY
66758: PUSH
66759: LD_INT 3
66761: ARRAY
66762: PPUSH
66763: LD_EXP 44
66767: PUSH
66768: LD_VAR 0 2
66772: ARRAY
66773: PUSH
66774: LD_INT 1
66776: ARRAY
66777: PUSH
66778: LD_INT 4
66780: ARRAY
66781: PPUSH
66782: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
66786: LD_ADDR_VAR 0 4
66790: PUSH
66791: LD_EXP 44
66795: PUSH
66796: LD_VAR 0 2
66800: ARRAY
66801: PPUSH
66802: LD_INT 1
66804: PPUSH
66805: CALL_OW 3
66809: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
66810: LD_ADDR_EXP 44
66814: PUSH
66815: LD_EXP 44
66819: PPUSH
66820: LD_VAR 0 2
66824: PPUSH
66825: LD_VAR 0 4
66829: PPUSH
66830: CALL_OW 1
66834: ST_TO_ADDR
// break ;
66835: GO 66839
// end ; end ;
66837: GO 66483
66839: POP
66840: POP
// end ;
66841: GO 66415
66843: POP
66844: POP
// end ;
66845: LD_VAR 0 1
66849: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
66850: LD_INT 0
66852: PPUSH
66853: PPUSH
66854: PPUSH
// if not mc_bases then
66855: LD_EXP 23
66859: NOT
66860: IFFALSE 66864
// exit ;
66862: GO 66953
// for i = 1 to mc_bases do
66864: LD_ADDR_VAR 0 2
66868: PUSH
66869: DOUBLE
66870: LD_INT 1
66872: DEC
66873: ST_TO_ADDR
66874: LD_EXP 23
66878: PUSH
66879: FOR_TO
66880: IFFALSE 66951
// begin if mc_attack [ i ] then
66882: LD_EXP 43
66886: PUSH
66887: LD_VAR 0 2
66891: ARRAY
66892: IFFALSE 66949
// begin tmp := mc_attack [ i ] [ 1 ] ;
66894: LD_ADDR_VAR 0 3
66898: PUSH
66899: LD_EXP 43
66903: PUSH
66904: LD_VAR 0 2
66908: ARRAY
66909: PUSH
66910: LD_INT 1
66912: ARRAY
66913: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
66914: LD_ADDR_EXP 43
66918: PUSH
66919: LD_EXP 43
66923: PPUSH
66924: LD_VAR 0 2
66928: PPUSH
66929: EMPTY
66930: PPUSH
66931: CALL_OW 1
66935: ST_TO_ADDR
// Attack ( tmp ) ;
66936: LD_VAR 0 3
66940: PPUSH
66941: CALL 81889 0 1
// exit ;
66945: POP
66946: POP
66947: GO 66953
// end ; end ;
66949: GO 66879
66951: POP
66952: POP
// end ;
66953: LD_VAR 0 1
66957: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
66958: LD_INT 0
66960: PPUSH
66961: PPUSH
66962: PPUSH
66963: PPUSH
66964: PPUSH
66965: PPUSH
66966: PPUSH
// if not mc_bases then
66967: LD_EXP 23
66971: NOT
66972: IFFALSE 66976
// exit ;
66974: GO 67833
// for i = 1 to mc_bases do
66976: LD_ADDR_VAR 0 2
66980: PUSH
66981: DOUBLE
66982: LD_INT 1
66984: DEC
66985: ST_TO_ADDR
66986: LD_EXP 23
66990: PUSH
66991: FOR_TO
66992: IFFALSE 67831
// begin if not mc_bases [ i ] then
66994: LD_EXP 23
66998: PUSH
66999: LD_VAR 0 2
67003: ARRAY
67004: NOT
67005: IFFALSE 67009
// continue ;
67007: GO 66991
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
67009: LD_ADDR_VAR 0 7
67013: PUSH
67014: LD_EXP 23
67018: PUSH
67019: LD_VAR 0 2
67023: ARRAY
67024: PUSH
67025: LD_INT 1
67027: ARRAY
67028: PPUSH
67029: CALL 12790 0 1
67033: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
67034: LD_ADDR_EXP 46
67038: PUSH
67039: LD_EXP 46
67043: PPUSH
67044: LD_VAR 0 2
67048: PPUSH
67049: LD_EXP 23
67053: PUSH
67054: LD_VAR 0 2
67058: ARRAY
67059: PUSH
67060: LD_INT 1
67062: ARRAY
67063: PPUSH
67064: CALL_OW 255
67068: PPUSH
67069: LD_EXP 48
67073: PUSH
67074: LD_VAR 0 2
67078: ARRAY
67079: PPUSH
67080: CALL 12755 0 2
67084: PPUSH
67085: CALL_OW 1
67089: ST_TO_ADDR
// if not mc_scan [ i ] then
67090: LD_EXP 46
67094: PUSH
67095: LD_VAR 0 2
67099: ARRAY
67100: NOT
67101: IFFALSE 67279
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
67103: LD_ADDR_EXP 66
67107: PUSH
67108: LD_EXP 66
67112: PPUSH
67113: LD_VAR 0 2
67117: PPUSH
67118: LD_INT 0
67120: PPUSH
67121: CALL_OW 1
67125: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67126: LD_ADDR_VAR 0 4
67130: PUSH
67131: LD_EXP 23
67135: PUSH
67136: LD_VAR 0 2
67140: ARRAY
67141: PPUSH
67142: LD_INT 2
67144: PUSH
67145: LD_INT 25
67147: PUSH
67148: LD_INT 5
67150: PUSH
67151: EMPTY
67152: LIST
67153: LIST
67154: PUSH
67155: LD_INT 25
67157: PUSH
67158: LD_INT 8
67160: PUSH
67161: EMPTY
67162: LIST
67163: LIST
67164: PUSH
67165: LD_INT 25
67167: PUSH
67168: LD_INT 9
67170: PUSH
67171: EMPTY
67172: LIST
67173: LIST
67174: PUSH
67175: EMPTY
67176: LIST
67177: LIST
67178: LIST
67179: LIST
67180: PPUSH
67181: CALL_OW 72
67185: ST_TO_ADDR
// if not tmp then
67186: LD_VAR 0 4
67190: NOT
67191: IFFALSE 67195
// continue ;
67193: GO 66991
// for j in tmp do
67195: LD_ADDR_VAR 0 3
67199: PUSH
67200: LD_VAR 0 4
67204: PUSH
67205: FOR_IN
67206: IFFALSE 67277
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
67208: LD_VAR 0 3
67212: PPUSH
67213: CALL_OW 310
67217: PPUSH
67218: CALL_OW 266
67222: PUSH
67223: LD_INT 5
67225: EQUAL
67226: PUSH
67227: LD_VAR 0 3
67231: PPUSH
67232: CALL_OW 257
67236: PUSH
67237: LD_INT 1
67239: EQUAL
67240: AND
67241: PUSH
67242: LD_VAR 0 3
67246: PPUSH
67247: CALL_OW 459
67251: NOT
67252: AND
67253: PUSH
67254: LD_VAR 0 7
67258: AND
67259: IFFALSE 67275
// ComChangeProfession ( j , class ) ;
67261: LD_VAR 0 3
67265: PPUSH
67266: LD_VAR 0 7
67270: PPUSH
67271: CALL_OW 123
67275: GO 67205
67277: POP
67278: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
67279: LD_EXP 46
67283: PUSH
67284: LD_VAR 0 2
67288: ARRAY
67289: PUSH
67290: LD_EXP 66
67294: PUSH
67295: LD_VAR 0 2
67299: ARRAY
67300: NOT
67301: AND
67302: PUSH
67303: LD_EXP 45
67307: PUSH
67308: LD_VAR 0 2
67312: ARRAY
67313: NOT
67314: AND
67315: PUSH
67316: LD_EXP 23
67320: PUSH
67321: LD_VAR 0 2
67325: ARRAY
67326: PPUSH
67327: LD_INT 50
67329: PUSH
67330: EMPTY
67331: LIST
67332: PUSH
67333: LD_INT 2
67335: PUSH
67336: LD_INT 30
67338: PUSH
67339: LD_INT 32
67341: PUSH
67342: EMPTY
67343: LIST
67344: LIST
67345: PUSH
67346: LD_INT 30
67348: PUSH
67349: LD_INT 33
67351: PUSH
67352: EMPTY
67353: LIST
67354: LIST
67355: PUSH
67356: LD_INT 30
67358: PUSH
67359: LD_INT 4
67361: PUSH
67362: EMPTY
67363: LIST
67364: LIST
67365: PUSH
67366: LD_INT 30
67368: PUSH
67369: LD_INT 5
67371: PUSH
67372: EMPTY
67373: LIST
67374: LIST
67375: PUSH
67376: EMPTY
67377: LIST
67378: LIST
67379: LIST
67380: LIST
67381: LIST
67382: PUSH
67383: EMPTY
67384: LIST
67385: LIST
67386: PPUSH
67387: CALL_OW 72
67391: PUSH
67392: LD_INT 4
67394: LESS
67395: PUSH
67396: LD_EXP 23
67400: PUSH
67401: LD_VAR 0 2
67405: ARRAY
67406: PPUSH
67407: LD_INT 3
67409: PUSH
67410: LD_INT 24
67412: PUSH
67413: LD_INT 1000
67415: PUSH
67416: EMPTY
67417: LIST
67418: LIST
67419: PUSH
67420: EMPTY
67421: LIST
67422: LIST
67423: PUSH
67424: LD_INT 2
67426: PUSH
67427: LD_INT 30
67429: PUSH
67430: LD_INT 0
67432: PUSH
67433: EMPTY
67434: LIST
67435: LIST
67436: PUSH
67437: LD_INT 30
67439: PUSH
67440: LD_INT 1
67442: PUSH
67443: EMPTY
67444: LIST
67445: LIST
67446: PUSH
67447: EMPTY
67448: LIST
67449: LIST
67450: LIST
67451: PUSH
67452: EMPTY
67453: LIST
67454: LIST
67455: PPUSH
67456: CALL_OW 72
67460: OR
67461: AND
67462: IFFALSE 67713
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
67464: LD_ADDR_EXP 66
67468: PUSH
67469: LD_EXP 66
67473: PPUSH
67474: LD_VAR 0 2
67478: PPUSH
67479: LD_INT 1
67481: PPUSH
67482: CALL_OW 1
67486: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67487: LD_ADDR_VAR 0 4
67491: PUSH
67492: LD_EXP 23
67496: PUSH
67497: LD_VAR 0 2
67501: ARRAY
67502: PPUSH
67503: LD_INT 2
67505: PUSH
67506: LD_INT 25
67508: PUSH
67509: LD_INT 1
67511: PUSH
67512: EMPTY
67513: LIST
67514: LIST
67515: PUSH
67516: LD_INT 25
67518: PUSH
67519: LD_INT 5
67521: PUSH
67522: EMPTY
67523: LIST
67524: LIST
67525: PUSH
67526: LD_INT 25
67528: PUSH
67529: LD_INT 8
67531: PUSH
67532: EMPTY
67533: LIST
67534: LIST
67535: PUSH
67536: LD_INT 25
67538: PUSH
67539: LD_INT 9
67541: PUSH
67542: EMPTY
67543: LIST
67544: LIST
67545: PUSH
67546: EMPTY
67547: LIST
67548: LIST
67549: LIST
67550: LIST
67551: LIST
67552: PPUSH
67553: CALL_OW 72
67557: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
67558: LD_ADDR_VAR 0 4
67562: PUSH
67563: LD_VAR 0 4
67567: PUSH
67568: LD_VAR 0 4
67572: PPUSH
67573: LD_INT 18
67575: PPUSH
67576: CALL 45259 0 2
67580: DIFF
67581: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
67582: LD_VAR 0 4
67586: NOT
67587: PUSH
67588: LD_EXP 23
67592: PUSH
67593: LD_VAR 0 2
67597: ARRAY
67598: PPUSH
67599: LD_INT 2
67601: PUSH
67602: LD_INT 30
67604: PUSH
67605: LD_INT 4
67607: PUSH
67608: EMPTY
67609: LIST
67610: LIST
67611: PUSH
67612: LD_INT 30
67614: PUSH
67615: LD_INT 5
67617: PUSH
67618: EMPTY
67619: LIST
67620: LIST
67621: PUSH
67622: EMPTY
67623: LIST
67624: LIST
67625: LIST
67626: PPUSH
67627: CALL_OW 72
67631: NOT
67632: AND
67633: IFFALSE 67695
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
67635: LD_ADDR_VAR 0 4
67639: PUSH
67640: LD_EXP 23
67644: PUSH
67645: LD_VAR 0 2
67649: ARRAY
67650: PPUSH
67651: LD_INT 2
67653: PUSH
67654: LD_INT 25
67656: PUSH
67657: LD_INT 2
67659: PUSH
67660: EMPTY
67661: LIST
67662: LIST
67663: PUSH
67664: LD_INT 25
67666: PUSH
67667: LD_INT 3
67669: PUSH
67670: EMPTY
67671: LIST
67672: LIST
67673: PUSH
67674: LD_INT 25
67676: PUSH
67677: LD_INT 4
67679: PUSH
67680: EMPTY
67681: LIST
67682: LIST
67683: PUSH
67684: EMPTY
67685: LIST
67686: LIST
67687: LIST
67688: LIST
67689: PPUSH
67690: CALL_OW 72
67694: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
67695: LD_VAR 0 2
67699: PPUSH
67700: LD_VAR 0 4
67704: PPUSH
67705: CALL 86598 0 2
// exit ;
67709: POP
67710: POP
67711: GO 67833
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
67713: LD_EXP 46
67717: PUSH
67718: LD_VAR 0 2
67722: ARRAY
67723: PUSH
67724: LD_EXP 66
67728: PUSH
67729: LD_VAR 0 2
67733: ARRAY
67734: NOT
67735: AND
67736: PUSH
67737: LD_EXP 45
67741: PUSH
67742: LD_VAR 0 2
67746: ARRAY
67747: AND
67748: IFFALSE 67829
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
67750: LD_ADDR_EXP 66
67754: PUSH
67755: LD_EXP 66
67759: PPUSH
67760: LD_VAR 0 2
67764: PPUSH
67765: LD_INT 1
67767: PPUSH
67768: CALL_OW 1
67772: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
67773: LD_ADDR_VAR 0 4
67777: PUSH
67778: LD_EXP 45
67782: PUSH
67783: LD_VAR 0 2
67787: ARRAY
67788: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
67789: LD_ADDR_EXP 45
67793: PUSH
67794: LD_EXP 45
67798: PPUSH
67799: LD_VAR 0 2
67803: PPUSH
67804: EMPTY
67805: PPUSH
67806: CALL_OW 1
67810: ST_TO_ADDR
// Defend ( i , tmp ) ;
67811: LD_VAR 0 2
67815: PPUSH
67816: LD_VAR 0 4
67820: PPUSH
67821: CALL 87194 0 2
// exit ;
67825: POP
67826: POP
67827: GO 67833
// end ; end ;
67829: GO 66991
67831: POP
67832: POP
// end ;
67833: LD_VAR 0 1
67837: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
67838: LD_INT 0
67840: PPUSH
67841: PPUSH
67842: PPUSH
67843: PPUSH
67844: PPUSH
67845: PPUSH
67846: PPUSH
67847: PPUSH
67848: PPUSH
67849: PPUSH
67850: PPUSH
// if not mc_bases then
67851: LD_EXP 23
67855: NOT
67856: IFFALSE 67860
// exit ;
67858: GO 68947
// for i = 1 to mc_bases do
67860: LD_ADDR_VAR 0 2
67864: PUSH
67865: DOUBLE
67866: LD_INT 1
67868: DEC
67869: ST_TO_ADDR
67870: LD_EXP 23
67874: PUSH
67875: FOR_TO
67876: IFFALSE 68945
// begin tmp := mc_lab [ i ] ;
67878: LD_ADDR_VAR 0 6
67882: PUSH
67883: LD_EXP 56
67887: PUSH
67888: LD_VAR 0 2
67892: ARRAY
67893: ST_TO_ADDR
// if not tmp then
67894: LD_VAR 0 6
67898: NOT
67899: IFFALSE 67903
// continue ;
67901: GO 67875
// idle_lab := 0 ;
67903: LD_ADDR_VAR 0 11
67907: PUSH
67908: LD_INT 0
67910: ST_TO_ADDR
// for j in tmp do
67911: LD_ADDR_VAR 0 3
67915: PUSH
67916: LD_VAR 0 6
67920: PUSH
67921: FOR_IN
67922: IFFALSE 68941
// begin researching := false ;
67924: LD_ADDR_VAR 0 10
67928: PUSH
67929: LD_INT 0
67931: ST_TO_ADDR
// side := GetSide ( j ) ;
67932: LD_ADDR_VAR 0 4
67936: PUSH
67937: LD_VAR 0 3
67941: PPUSH
67942: CALL_OW 255
67946: ST_TO_ADDR
// if not mc_tech [ side ] then
67947: LD_EXP 50
67951: PUSH
67952: LD_VAR 0 4
67956: ARRAY
67957: NOT
67958: IFFALSE 67962
// continue ;
67960: GO 67921
// if BuildingStatus ( j ) = bs_idle then
67962: LD_VAR 0 3
67966: PPUSH
67967: CALL_OW 461
67971: PUSH
67972: LD_INT 2
67974: EQUAL
67975: IFFALSE 68163
// begin if idle_lab and UnitsInside ( j ) < 6 then
67977: LD_VAR 0 11
67981: PUSH
67982: LD_VAR 0 3
67986: PPUSH
67987: CALL_OW 313
67991: PUSH
67992: LD_INT 6
67994: LESS
67995: AND
67996: IFFALSE 68067
// begin tmp2 := UnitsInside ( idle_lab ) ;
67998: LD_ADDR_VAR 0 9
68002: PUSH
68003: LD_VAR 0 11
68007: PPUSH
68008: CALL_OW 313
68012: ST_TO_ADDR
// if tmp2 then
68013: LD_VAR 0 9
68017: IFFALSE 68059
// for x in tmp2 do
68019: LD_ADDR_VAR 0 7
68023: PUSH
68024: LD_VAR 0 9
68028: PUSH
68029: FOR_IN
68030: IFFALSE 68057
// begin ComExitBuilding ( x ) ;
68032: LD_VAR 0 7
68036: PPUSH
68037: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
68041: LD_VAR 0 7
68045: PPUSH
68046: LD_VAR 0 3
68050: PPUSH
68051: CALL_OW 180
// end ;
68055: GO 68029
68057: POP
68058: POP
// idle_lab := 0 ;
68059: LD_ADDR_VAR 0 11
68063: PUSH
68064: LD_INT 0
68066: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
68067: LD_ADDR_VAR 0 5
68071: PUSH
68072: LD_EXP 50
68076: PUSH
68077: LD_VAR 0 4
68081: ARRAY
68082: PUSH
68083: FOR_IN
68084: IFFALSE 68144
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
68086: LD_VAR 0 3
68090: PPUSH
68091: LD_VAR 0 5
68095: PPUSH
68096: CALL_OW 430
68100: PUSH
68101: LD_VAR 0 4
68105: PPUSH
68106: LD_VAR 0 5
68110: PPUSH
68111: CALL 11860 0 2
68115: AND
68116: IFFALSE 68142
// begin researching := true ;
68118: LD_ADDR_VAR 0 10
68122: PUSH
68123: LD_INT 1
68125: ST_TO_ADDR
// ComResearch ( j , t ) ;
68126: LD_VAR 0 3
68130: PPUSH
68131: LD_VAR 0 5
68135: PPUSH
68136: CALL_OW 124
// break ;
68140: GO 68144
// end ;
68142: GO 68083
68144: POP
68145: POP
// if not researching then
68146: LD_VAR 0 10
68150: NOT
68151: IFFALSE 68163
// idle_lab := j ;
68153: LD_ADDR_VAR 0 11
68157: PUSH
68158: LD_VAR 0 3
68162: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
68163: LD_VAR 0 3
68167: PPUSH
68168: CALL_OW 461
68172: PUSH
68173: LD_INT 10
68175: EQUAL
68176: IFFALSE 68764
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
68178: LD_EXP 52
68182: PUSH
68183: LD_VAR 0 2
68187: ARRAY
68188: NOT
68189: PUSH
68190: LD_EXP 53
68194: PUSH
68195: LD_VAR 0 2
68199: ARRAY
68200: NOT
68201: AND
68202: PUSH
68203: LD_EXP 50
68207: PUSH
68208: LD_VAR 0 4
68212: ARRAY
68213: PUSH
68214: LD_INT 1
68216: GREATER
68217: AND
68218: IFFALSE 68349
// begin ComCancel ( j ) ;
68220: LD_VAR 0 3
68224: PPUSH
68225: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
68229: LD_ADDR_EXP 50
68233: PUSH
68234: LD_EXP 50
68238: PPUSH
68239: LD_VAR 0 4
68243: PPUSH
68244: LD_EXP 50
68248: PUSH
68249: LD_VAR 0 4
68253: ARRAY
68254: PPUSH
68255: LD_EXP 50
68259: PUSH
68260: LD_VAR 0 4
68264: ARRAY
68265: PUSH
68266: LD_INT 1
68268: MINUS
68269: PPUSH
68270: LD_EXP 50
68274: PUSH
68275: LD_VAR 0 4
68279: ARRAY
68280: PPUSH
68281: LD_INT 0
68283: PPUSH
68284: CALL 15408 0 4
68288: PPUSH
68289: CALL_OW 1
68293: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
68294: LD_ADDR_EXP 50
68298: PUSH
68299: LD_EXP 50
68303: PPUSH
68304: LD_VAR 0 4
68308: PPUSH
68309: LD_EXP 50
68313: PUSH
68314: LD_VAR 0 4
68318: ARRAY
68319: PPUSH
68320: LD_EXP 50
68324: PUSH
68325: LD_VAR 0 4
68329: ARRAY
68330: PPUSH
68331: LD_INT 1
68333: PPUSH
68334: LD_INT 0
68336: PPUSH
68337: CALL 15408 0 4
68341: PPUSH
68342: CALL_OW 1
68346: ST_TO_ADDR
// continue ;
68347: GO 67921
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
68349: LD_EXP 52
68353: PUSH
68354: LD_VAR 0 2
68358: ARRAY
68359: PUSH
68360: LD_EXP 53
68364: PUSH
68365: LD_VAR 0 2
68369: ARRAY
68370: NOT
68371: AND
68372: IFFALSE 68499
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
68374: LD_ADDR_EXP 53
68378: PUSH
68379: LD_EXP 53
68383: PPUSH
68384: LD_VAR 0 2
68388: PUSH
68389: LD_EXP 53
68393: PUSH
68394: LD_VAR 0 2
68398: ARRAY
68399: PUSH
68400: LD_INT 1
68402: PLUS
68403: PUSH
68404: EMPTY
68405: LIST
68406: LIST
68407: PPUSH
68408: LD_EXP 52
68412: PUSH
68413: LD_VAR 0 2
68417: ARRAY
68418: PUSH
68419: LD_INT 1
68421: ARRAY
68422: PPUSH
68423: CALL 15990 0 3
68427: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
68428: LD_EXP 52
68432: PUSH
68433: LD_VAR 0 2
68437: ARRAY
68438: PUSH
68439: LD_INT 1
68441: ARRAY
68442: PPUSH
68443: LD_INT 112
68445: PPUSH
68446: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
68450: LD_ADDR_VAR 0 9
68454: PUSH
68455: LD_EXP 52
68459: PUSH
68460: LD_VAR 0 2
68464: ARRAY
68465: PPUSH
68466: LD_INT 1
68468: PPUSH
68469: CALL_OW 3
68473: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
68474: LD_ADDR_EXP 52
68478: PUSH
68479: LD_EXP 52
68483: PPUSH
68484: LD_VAR 0 2
68488: PPUSH
68489: LD_VAR 0 9
68493: PPUSH
68494: CALL_OW 1
68498: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
68499: LD_EXP 52
68503: PUSH
68504: LD_VAR 0 2
68508: ARRAY
68509: PUSH
68510: LD_EXP 53
68514: PUSH
68515: LD_VAR 0 2
68519: ARRAY
68520: AND
68521: PUSH
68522: LD_EXP 53
68526: PUSH
68527: LD_VAR 0 2
68531: ARRAY
68532: PUSH
68533: LD_INT 1
68535: ARRAY
68536: PPUSH
68537: CALL_OW 310
68541: NOT
68542: AND
68543: PUSH
68544: LD_VAR 0 3
68548: PPUSH
68549: CALL_OW 313
68553: PUSH
68554: LD_INT 6
68556: EQUAL
68557: AND
68558: IFFALSE 68614
// begin tmp2 := UnitsInside ( j ) ;
68560: LD_ADDR_VAR 0 9
68564: PUSH
68565: LD_VAR 0 3
68569: PPUSH
68570: CALL_OW 313
68574: ST_TO_ADDR
// if tmp2 = 6 then
68575: LD_VAR 0 9
68579: PUSH
68580: LD_INT 6
68582: EQUAL
68583: IFFALSE 68614
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
68585: LD_VAR 0 9
68589: PUSH
68590: LD_INT 1
68592: ARRAY
68593: PPUSH
68594: LD_INT 112
68596: PPUSH
68597: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
68601: LD_VAR 0 9
68605: PUSH
68606: LD_INT 1
68608: ARRAY
68609: PPUSH
68610: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
68614: LD_EXP 53
68618: PUSH
68619: LD_VAR 0 2
68623: ARRAY
68624: PUSH
68625: LD_EXP 53
68629: PUSH
68630: LD_VAR 0 2
68634: ARRAY
68635: PUSH
68636: LD_INT 1
68638: ARRAY
68639: PPUSH
68640: CALL_OW 314
68644: NOT
68645: AND
68646: PUSH
68647: LD_EXP 53
68651: PUSH
68652: LD_VAR 0 2
68656: ARRAY
68657: PUSH
68658: LD_INT 1
68660: ARRAY
68661: PPUSH
68662: CALL_OW 310
68666: NOT
68667: AND
68668: IFFALSE 68694
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
68670: LD_EXP 53
68674: PUSH
68675: LD_VAR 0 2
68679: ARRAY
68680: PUSH
68681: LD_INT 1
68683: ARRAY
68684: PPUSH
68685: LD_VAR 0 3
68689: PPUSH
68690: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
68694: LD_EXP 53
68698: PUSH
68699: LD_VAR 0 2
68703: ARRAY
68704: PUSH
68705: LD_INT 1
68707: ARRAY
68708: PPUSH
68709: CALL_OW 310
68713: PUSH
68714: LD_EXP 53
68718: PUSH
68719: LD_VAR 0 2
68723: ARRAY
68724: PUSH
68725: LD_INT 1
68727: ARRAY
68728: PPUSH
68729: CALL_OW 310
68733: PPUSH
68734: CALL_OW 461
68738: PUSH
68739: LD_INT 3
68741: NONEQUAL
68742: AND
68743: IFFALSE 68764
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
68745: LD_EXP 53
68749: PUSH
68750: LD_VAR 0 2
68754: ARRAY
68755: PUSH
68756: LD_INT 1
68758: ARRAY
68759: PPUSH
68760: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
68764: LD_VAR 0 3
68768: PPUSH
68769: CALL_OW 461
68773: PUSH
68774: LD_INT 6
68776: EQUAL
68777: PUSH
68778: LD_VAR 0 6
68782: PUSH
68783: LD_INT 1
68785: GREATER
68786: AND
68787: IFFALSE 68939
// begin sci := [ ] ;
68789: LD_ADDR_VAR 0 8
68793: PUSH
68794: EMPTY
68795: ST_TO_ADDR
// for x in ( tmp diff j ) do
68796: LD_ADDR_VAR 0 7
68800: PUSH
68801: LD_VAR 0 6
68805: PUSH
68806: LD_VAR 0 3
68810: DIFF
68811: PUSH
68812: FOR_IN
68813: IFFALSE 68865
// begin if sci = 6 then
68815: LD_VAR 0 8
68819: PUSH
68820: LD_INT 6
68822: EQUAL
68823: IFFALSE 68827
// break ;
68825: GO 68865
// if BuildingStatus ( x ) = bs_idle then
68827: LD_VAR 0 7
68831: PPUSH
68832: CALL_OW 461
68836: PUSH
68837: LD_INT 2
68839: EQUAL
68840: IFFALSE 68863
// sci := sci ^ UnitsInside ( x ) ;
68842: LD_ADDR_VAR 0 8
68846: PUSH
68847: LD_VAR 0 8
68851: PUSH
68852: LD_VAR 0 7
68856: PPUSH
68857: CALL_OW 313
68861: ADD
68862: ST_TO_ADDR
// end ;
68863: GO 68812
68865: POP
68866: POP
// if not sci then
68867: LD_VAR 0 8
68871: NOT
68872: IFFALSE 68876
// continue ;
68874: GO 67921
// for x in sci do
68876: LD_ADDR_VAR 0 7
68880: PUSH
68881: LD_VAR 0 8
68885: PUSH
68886: FOR_IN
68887: IFFALSE 68937
// if IsInUnit ( x ) and not HasTask ( x ) then
68889: LD_VAR 0 7
68893: PPUSH
68894: CALL_OW 310
68898: PUSH
68899: LD_VAR 0 7
68903: PPUSH
68904: CALL_OW 314
68908: NOT
68909: AND
68910: IFFALSE 68935
// begin ComExitBuilding ( x ) ;
68912: LD_VAR 0 7
68916: PPUSH
68917: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
68921: LD_VAR 0 7
68925: PPUSH
68926: LD_VAR 0 3
68930: PPUSH
68931: CALL_OW 180
// end ;
68935: GO 68886
68937: POP
68938: POP
// end ; end ;
68939: GO 67921
68941: POP
68942: POP
// end ;
68943: GO 67875
68945: POP
68946: POP
// end ;
68947: LD_VAR 0 1
68951: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
68952: LD_INT 0
68954: PPUSH
68955: PPUSH
// if not mc_bases then
68956: LD_EXP 23
68960: NOT
68961: IFFALSE 68965
// exit ;
68963: GO 69046
// for i = 1 to mc_bases do
68965: LD_ADDR_VAR 0 2
68969: PUSH
68970: DOUBLE
68971: LD_INT 1
68973: DEC
68974: ST_TO_ADDR
68975: LD_EXP 23
68979: PUSH
68980: FOR_TO
68981: IFFALSE 69044
// if mc_mines [ i ] and mc_miners [ i ] then
68983: LD_EXP 36
68987: PUSH
68988: LD_VAR 0 2
68992: ARRAY
68993: PUSH
68994: LD_EXP 37
68998: PUSH
68999: LD_VAR 0 2
69003: ARRAY
69004: AND
69005: IFFALSE 69042
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
69007: LD_EXP 37
69011: PUSH
69012: LD_VAR 0 2
69016: ARRAY
69017: PUSH
69018: LD_INT 1
69020: ARRAY
69021: PPUSH
69022: CALL_OW 255
69026: PPUSH
69027: LD_EXP 36
69031: PUSH
69032: LD_VAR 0 2
69036: ARRAY
69037: PPUSH
69038: CALL 12943 0 2
69042: GO 68980
69044: POP
69045: POP
// end ;
69046: LD_VAR 0 1
69050: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
69051: LD_INT 0
69053: PPUSH
69054: PPUSH
69055: PPUSH
69056: PPUSH
69057: PPUSH
69058: PPUSH
69059: PPUSH
69060: PPUSH
// if not mc_bases or not mc_parking then
69061: LD_EXP 23
69065: NOT
69066: PUSH
69067: LD_EXP 47
69071: NOT
69072: OR
69073: IFFALSE 69077
// exit ;
69075: GO 69787
// for i = 1 to mc_bases do
69077: LD_ADDR_VAR 0 2
69081: PUSH
69082: DOUBLE
69083: LD_INT 1
69085: DEC
69086: ST_TO_ADDR
69087: LD_EXP 23
69091: PUSH
69092: FOR_TO
69093: IFFALSE 69785
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
69095: LD_EXP 23
69099: PUSH
69100: LD_VAR 0 2
69104: ARRAY
69105: NOT
69106: PUSH
69107: LD_EXP 47
69111: PUSH
69112: LD_VAR 0 2
69116: ARRAY
69117: NOT
69118: OR
69119: IFFALSE 69123
// continue ;
69121: GO 69092
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
69123: LD_ADDR_VAR 0 5
69127: PUSH
69128: LD_EXP 23
69132: PUSH
69133: LD_VAR 0 2
69137: ARRAY
69138: PUSH
69139: LD_INT 1
69141: ARRAY
69142: PPUSH
69143: CALL_OW 255
69147: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69148: LD_ADDR_VAR 0 6
69152: PUSH
69153: LD_EXP 23
69157: PUSH
69158: LD_VAR 0 2
69162: ARRAY
69163: PPUSH
69164: LD_INT 30
69166: PUSH
69167: LD_INT 3
69169: PUSH
69170: EMPTY
69171: LIST
69172: LIST
69173: PPUSH
69174: CALL_OW 72
69178: ST_TO_ADDR
// if not fac then
69179: LD_VAR 0 6
69183: NOT
69184: IFFALSE 69235
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69186: LD_ADDR_VAR 0 6
69190: PUSH
69191: LD_EXP 23
69195: PUSH
69196: LD_VAR 0 2
69200: ARRAY
69201: PPUSH
69202: LD_INT 2
69204: PUSH
69205: LD_INT 30
69207: PUSH
69208: LD_INT 0
69210: PUSH
69211: EMPTY
69212: LIST
69213: LIST
69214: PUSH
69215: LD_INT 30
69217: PUSH
69218: LD_INT 1
69220: PUSH
69221: EMPTY
69222: LIST
69223: LIST
69224: PUSH
69225: EMPTY
69226: LIST
69227: LIST
69228: LIST
69229: PPUSH
69230: CALL_OW 72
69234: ST_TO_ADDR
// if not fac then
69235: LD_VAR 0 6
69239: NOT
69240: IFFALSE 69244
// continue ;
69242: GO 69092
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69244: LD_ADDR_VAR 0 7
69248: PUSH
69249: LD_EXP 47
69253: PUSH
69254: LD_VAR 0 2
69258: ARRAY
69259: PPUSH
69260: LD_INT 22
69262: PUSH
69263: LD_VAR 0 5
69267: PUSH
69268: EMPTY
69269: LIST
69270: LIST
69271: PUSH
69272: LD_INT 21
69274: PUSH
69275: LD_INT 2
69277: PUSH
69278: EMPTY
69279: LIST
69280: LIST
69281: PUSH
69282: LD_INT 3
69284: PUSH
69285: LD_INT 24
69287: PUSH
69288: LD_INT 1000
69290: PUSH
69291: EMPTY
69292: LIST
69293: LIST
69294: PUSH
69295: EMPTY
69296: LIST
69297: LIST
69298: PUSH
69299: EMPTY
69300: LIST
69301: LIST
69302: LIST
69303: PPUSH
69304: CALL_OW 70
69308: ST_TO_ADDR
// for j in fac do
69309: LD_ADDR_VAR 0 3
69313: PUSH
69314: LD_VAR 0 6
69318: PUSH
69319: FOR_IN
69320: IFFALSE 69401
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69322: LD_ADDR_VAR 0 7
69326: PUSH
69327: LD_VAR 0 7
69331: PUSH
69332: LD_INT 22
69334: PUSH
69335: LD_VAR 0 5
69339: PUSH
69340: EMPTY
69341: LIST
69342: LIST
69343: PUSH
69344: LD_INT 91
69346: PUSH
69347: LD_VAR 0 3
69351: PUSH
69352: LD_INT 15
69354: PUSH
69355: EMPTY
69356: LIST
69357: LIST
69358: LIST
69359: PUSH
69360: LD_INT 21
69362: PUSH
69363: LD_INT 2
69365: PUSH
69366: EMPTY
69367: LIST
69368: LIST
69369: PUSH
69370: LD_INT 3
69372: PUSH
69373: LD_INT 24
69375: PUSH
69376: LD_INT 1000
69378: PUSH
69379: EMPTY
69380: LIST
69381: LIST
69382: PUSH
69383: EMPTY
69384: LIST
69385: LIST
69386: PUSH
69387: EMPTY
69388: LIST
69389: LIST
69390: LIST
69391: LIST
69392: PPUSH
69393: CALL_OW 69
69397: UNION
69398: ST_TO_ADDR
69399: GO 69319
69401: POP
69402: POP
// if not vehs then
69403: LD_VAR 0 7
69407: NOT
69408: IFFALSE 69434
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
69410: LD_ADDR_EXP 35
69414: PUSH
69415: LD_EXP 35
69419: PPUSH
69420: LD_VAR 0 2
69424: PPUSH
69425: EMPTY
69426: PPUSH
69427: CALL_OW 1
69431: ST_TO_ADDR
// continue ;
69432: GO 69092
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69434: LD_ADDR_VAR 0 8
69438: PUSH
69439: LD_EXP 23
69443: PUSH
69444: LD_VAR 0 2
69448: ARRAY
69449: PPUSH
69450: LD_INT 30
69452: PUSH
69453: LD_INT 3
69455: PUSH
69456: EMPTY
69457: LIST
69458: LIST
69459: PPUSH
69460: CALL_OW 72
69464: ST_TO_ADDR
// if tmp then
69465: LD_VAR 0 8
69469: IFFALSE 69572
// begin for j in tmp do
69471: LD_ADDR_VAR 0 3
69475: PUSH
69476: LD_VAR 0 8
69480: PUSH
69481: FOR_IN
69482: IFFALSE 69570
// for k in UnitsInside ( j ) do
69484: LD_ADDR_VAR 0 4
69488: PUSH
69489: LD_VAR 0 3
69493: PPUSH
69494: CALL_OW 313
69498: PUSH
69499: FOR_IN
69500: IFFALSE 69566
// if k then
69502: LD_VAR 0 4
69506: IFFALSE 69564
// if not k in mc_repair_vehicle [ i ] then
69508: LD_VAR 0 4
69512: PUSH
69513: LD_EXP 35
69517: PUSH
69518: LD_VAR 0 2
69522: ARRAY
69523: IN
69524: NOT
69525: IFFALSE 69564
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
69527: LD_ADDR_EXP 35
69531: PUSH
69532: LD_EXP 35
69536: PPUSH
69537: LD_VAR 0 2
69541: PPUSH
69542: LD_EXP 35
69546: PUSH
69547: LD_VAR 0 2
69551: ARRAY
69552: PUSH
69553: LD_VAR 0 4
69557: UNION
69558: PPUSH
69559: CALL_OW 1
69563: ST_TO_ADDR
69564: GO 69499
69566: POP
69567: POP
69568: GO 69481
69570: POP
69571: POP
// end ; if not mc_repair_vehicle [ i ] then
69572: LD_EXP 35
69576: PUSH
69577: LD_VAR 0 2
69581: ARRAY
69582: NOT
69583: IFFALSE 69587
// continue ;
69585: GO 69092
// for j in mc_repair_vehicle [ i ] do
69587: LD_ADDR_VAR 0 3
69591: PUSH
69592: LD_EXP 35
69596: PUSH
69597: LD_VAR 0 2
69601: ARRAY
69602: PUSH
69603: FOR_IN
69604: IFFALSE 69781
// begin if GetClass ( j ) <> 3 then
69606: LD_VAR 0 3
69610: PPUSH
69611: CALL_OW 257
69615: PUSH
69616: LD_INT 3
69618: NONEQUAL
69619: IFFALSE 69660
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
69621: LD_ADDR_EXP 35
69625: PUSH
69626: LD_EXP 35
69630: PPUSH
69631: LD_VAR 0 2
69635: PPUSH
69636: LD_EXP 35
69640: PUSH
69641: LD_VAR 0 2
69645: ARRAY
69646: PUSH
69647: LD_VAR 0 3
69651: DIFF
69652: PPUSH
69653: CALL_OW 1
69657: ST_TO_ADDR
// continue ;
69658: GO 69603
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
69660: LD_VAR 0 3
69664: PPUSH
69665: CALL_OW 311
69669: NOT
69670: PUSH
69671: LD_VAR 0 3
69675: PUSH
69676: LD_EXP 26
69680: PUSH
69681: LD_VAR 0 2
69685: ARRAY
69686: PUSH
69687: LD_INT 1
69689: ARRAY
69690: IN
69691: NOT
69692: AND
69693: PUSH
69694: LD_VAR 0 3
69698: PUSH
69699: LD_EXP 26
69703: PUSH
69704: LD_VAR 0 2
69708: ARRAY
69709: PUSH
69710: LD_INT 2
69712: ARRAY
69713: IN
69714: NOT
69715: AND
69716: IFFALSE 69779
// begin if IsInUnit ( j ) then
69718: LD_VAR 0 3
69722: PPUSH
69723: CALL_OW 310
69727: IFFALSE 69740
// ComExitBuilding ( j ) else
69729: LD_VAR 0 3
69733: PPUSH
69734: CALL_OW 122
69738: GO 69779
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
69740: LD_VAR 0 3
69744: PPUSH
69745: LD_VAR 0 7
69749: PUSH
69750: LD_INT 1
69752: ARRAY
69753: PPUSH
69754: CALL 49798 0 2
69758: NOT
69759: IFFALSE 69779
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
69761: LD_VAR 0 3
69765: PPUSH
69766: LD_VAR 0 7
69770: PUSH
69771: LD_INT 1
69773: ARRAY
69774: PPUSH
69775: CALL_OW 129
// end ; end ;
69779: GO 69603
69781: POP
69782: POP
// end ;
69783: GO 69092
69785: POP
69786: POP
// end ;
69787: LD_VAR 0 1
69791: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
69792: LD_INT 0
69794: PPUSH
69795: PPUSH
69796: PPUSH
69797: PPUSH
69798: PPUSH
69799: PPUSH
69800: PPUSH
69801: PPUSH
69802: PPUSH
69803: PPUSH
69804: PPUSH
// if not mc_bases then
69805: LD_EXP 23
69809: NOT
69810: IFFALSE 69814
// exit ;
69812: GO 70616
// for i = 1 to mc_bases do
69814: LD_ADDR_VAR 0 2
69818: PUSH
69819: DOUBLE
69820: LD_INT 1
69822: DEC
69823: ST_TO_ADDR
69824: LD_EXP 23
69828: PUSH
69829: FOR_TO
69830: IFFALSE 70614
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
69832: LD_EXP 51
69836: PUSH
69837: LD_VAR 0 2
69841: ARRAY
69842: NOT
69843: PUSH
69844: LD_EXP 26
69848: PUSH
69849: LD_VAR 0 2
69853: ARRAY
69854: PUSH
69855: LD_INT 1
69857: ARRAY
69858: OR
69859: PUSH
69860: LD_EXP 26
69864: PUSH
69865: LD_VAR 0 2
69869: ARRAY
69870: PUSH
69871: LD_INT 2
69873: ARRAY
69874: OR
69875: PUSH
69876: LD_EXP 49
69880: PUSH
69881: LD_VAR 0 2
69885: ARRAY
69886: PPUSH
69887: LD_INT 1
69889: PPUSH
69890: CALL_OW 325
69894: NOT
69895: OR
69896: PUSH
69897: LD_EXP 46
69901: PUSH
69902: LD_VAR 0 2
69906: ARRAY
69907: OR
69908: IFFALSE 69912
// continue ;
69910: GO 69829
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
69912: LD_ADDR_VAR 0 8
69916: PUSH
69917: LD_EXP 23
69921: PUSH
69922: LD_VAR 0 2
69926: ARRAY
69927: PPUSH
69928: LD_INT 25
69930: PUSH
69931: LD_INT 4
69933: PUSH
69934: EMPTY
69935: LIST
69936: LIST
69937: PUSH
69938: LD_INT 50
69940: PUSH
69941: EMPTY
69942: LIST
69943: PUSH
69944: LD_INT 3
69946: PUSH
69947: LD_INT 60
69949: PUSH
69950: EMPTY
69951: LIST
69952: PUSH
69953: EMPTY
69954: LIST
69955: LIST
69956: PUSH
69957: EMPTY
69958: LIST
69959: LIST
69960: LIST
69961: PPUSH
69962: CALL_OW 72
69966: PUSH
69967: LD_EXP 27
69971: PUSH
69972: LD_VAR 0 2
69976: ARRAY
69977: DIFF
69978: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69979: LD_ADDR_VAR 0 9
69983: PUSH
69984: LD_EXP 23
69988: PUSH
69989: LD_VAR 0 2
69993: ARRAY
69994: PPUSH
69995: LD_INT 2
69997: PUSH
69998: LD_INT 30
70000: PUSH
70001: LD_INT 0
70003: PUSH
70004: EMPTY
70005: LIST
70006: LIST
70007: PUSH
70008: LD_INT 30
70010: PUSH
70011: LD_INT 1
70013: PUSH
70014: EMPTY
70015: LIST
70016: LIST
70017: PUSH
70018: EMPTY
70019: LIST
70020: LIST
70021: LIST
70022: PPUSH
70023: CALL_OW 72
70027: ST_TO_ADDR
// if not tmp or not dep then
70028: LD_VAR 0 8
70032: NOT
70033: PUSH
70034: LD_VAR 0 9
70038: NOT
70039: OR
70040: IFFALSE 70044
// continue ;
70042: GO 69829
// side := GetSide ( tmp [ 1 ] ) ;
70044: LD_ADDR_VAR 0 11
70048: PUSH
70049: LD_VAR 0 8
70053: PUSH
70054: LD_INT 1
70056: ARRAY
70057: PPUSH
70058: CALL_OW 255
70062: ST_TO_ADDR
// dep := dep [ 1 ] ;
70063: LD_ADDR_VAR 0 9
70067: PUSH
70068: LD_VAR 0 9
70072: PUSH
70073: LD_INT 1
70075: ARRAY
70076: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
70077: LD_ADDR_VAR 0 7
70081: PUSH
70082: LD_EXP 51
70086: PUSH
70087: LD_VAR 0 2
70091: ARRAY
70092: PPUSH
70093: LD_INT 22
70095: PUSH
70096: LD_INT 0
70098: PUSH
70099: EMPTY
70100: LIST
70101: LIST
70102: PUSH
70103: LD_INT 25
70105: PUSH
70106: LD_INT 12
70108: PUSH
70109: EMPTY
70110: LIST
70111: LIST
70112: PUSH
70113: EMPTY
70114: LIST
70115: LIST
70116: PPUSH
70117: CALL_OW 70
70121: PUSH
70122: LD_INT 22
70124: PUSH
70125: LD_INT 0
70127: PUSH
70128: EMPTY
70129: LIST
70130: LIST
70131: PUSH
70132: LD_INT 25
70134: PUSH
70135: LD_INT 12
70137: PUSH
70138: EMPTY
70139: LIST
70140: LIST
70141: PUSH
70142: LD_INT 91
70144: PUSH
70145: LD_VAR 0 9
70149: PUSH
70150: LD_INT 20
70152: PUSH
70153: EMPTY
70154: LIST
70155: LIST
70156: LIST
70157: PUSH
70158: EMPTY
70159: LIST
70160: LIST
70161: LIST
70162: PPUSH
70163: CALL_OW 69
70167: UNION
70168: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
70169: LD_ADDR_VAR 0 10
70173: PUSH
70174: LD_EXP 51
70178: PUSH
70179: LD_VAR 0 2
70183: ARRAY
70184: PPUSH
70185: LD_INT 81
70187: PUSH
70188: LD_VAR 0 11
70192: PUSH
70193: EMPTY
70194: LIST
70195: LIST
70196: PPUSH
70197: CALL_OW 70
70201: ST_TO_ADDR
// if not apes or danger_at_area then
70202: LD_VAR 0 7
70206: NOT
70207: PUSH
70208: LD_VAR 0 10
70212: OR
70213: IFFALSE 70263
// begin if mc_taming [ i ] then
70215: LD_EXP 54
70219: PUSH
70220: LD_VAR 0 2
70224: ARRAY
70225: IFFALSE 70261
// begin MC_Reset ( i , 121 ) ;
70227: LD_VAR 0 2
70231: PPUSH
70232: LD_INT 121
70234: PPUSH
70235: CALL 55249 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
70239: LD_ADDR_EXP 54
70243: PUSH
70244: LD_EXP 54
70248: PPUSH
70249: LD_VAR 0 2
70253: PPUSH
70254: EMPTY
70255: PPUSH
70256: CALL_OW 1
70260: ST_TO_ADDR
// end ; continue ;
70261: GO 69829
// end ; for j in tmp do
70263: LD_ADDR_VAR 0 3
70267: PUSH
70268: LD_VAR 0 8
70272: PUSH
70273: FOR_IN
70274: IFFALSE 70610
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
70276: LD_VAR 0 3
70280: PUSH
70281: LD_EXP 54
70285: PUSH
70286: LD_VAR 0 2
70290: ARRAY
70291: IN
70292: NOT
70293: PUSH
70294: LD_EXP 54
70298: PUSH
70299: LD_VAR 0 2
70303: ARRAY
70304: PUSH
70305: LD_INT 3
70307: LESS
70308: AND
70309: IFFALSE 70367
// begin SetTag ( j , 121 ) ;
70311: LD_VAR 0 3
70315: PPUSH
70316: LD_INT 121
70318: PPUSH
70319: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
70323: LD_ADDR_EXP 54
70327: PUSH
70328: LD_EXP 54
70332: PPUSH
70333: LD_VAR 0 2
70337: PUSH
70338: LD_EXP 54
70342: PUSH
70343: LD_VAR 0 2
70347: ARRAY
70348: PUSH
70349: LD_INT 1
70351: PLUS
70352: PUSH
70353: EMPTY
70354: LIST
70355: LIST
70356: PPUSH
70357: LD_VAR 0 3
70361: PPUSH
70362: CALL 15990 0 3
70366: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
70367: LD_VAR 0 3
70371: PUSH
70372: LD_EXP 54
70376: PUSH
70377: LD_VAR 0 2
70381: ARRAY
70382: IN
70383: IFFALSE 70608
// begin if GetClass ( j ) <> 4 then
70385: LD_VAR 0 3
70389: PPUSH
70390: CALL_OW 257
70394: PUSH
70395: LD_INT 4
70397: NONEQUAL
70398: IFFALSE 70451
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
70400: LD_ADDR_EXP 54
70404: PUSH
70405: LD_EXP 54
70409: PPUSH
70410: LD_VAR 0 2
70414: PPUSH
70415: LD_EXP 54
70419: PUSH
70420: LD_VAR 0 2
70424: ARRAY
70425: PUSH
70426: LD_VAR 0 3
70430: DIFF
70431: PPUSH
70432: CALL_OW 1
70436: ST_TO_ADDR
// SetTag ( j , 0 ) ;
70437: LD_VAR 0 3
70441: PPUSH
70442: LD_INT 0
70444: PPUSH
70445: CALL_OW 109
// continue ;
70449: GO 70273
// end ; if IsInUnit ( j ) then
70451: LD_VAR 0 3
70455: PPUSH
70456: CALL_OW 310
70460: IFFALSE 70471
// ComExitBuilding ( j ) ;
70462: LD_VAR 0 3
70466: PPUSH
70467: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
70471: LD_ADDR_VAR 0 6
70475: PUSH
70476: LD_VAR 0 7
70480: PPUSH
70481: LD_VAR 0 3
70485: PPUSH
70486: CALL_OW 74
70490: ST_TO_ADDR
// if not ape then
70491: LD_VAR 0 6
70495: NOT
70496: IFFALSE 70500
// break ;
70498: GO 70610
// x := GetX ( ape ) ;
70500: LD_ADDR_VAR 0 4
70504: PUSH
70505: LD_VAR 0 6
70509: PPUSH
70510: CALL_OW 250
70514: ST_TO_ADDR
// y := GetY ( ape ) ;
70515: LD_ADDR_VAR 0 5
70519: PUSH
70520: LD_VAR 0 6
70524: PPUSH
70525: CALL_OW 251
70529: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
70530: LD_VAR 0 4
70534: PPUSH
70535: LD_VAR 0 5
70539: PPUSH
70540: CALL_OW 488
70544: NOT
70545: PUSH
70546: LD_VAR 0 11
70550: PPUSH
70551: LD_VAR 0 4
70555: PPUSH
70556: LD_VAR 0 5
70560: PPUSH
70561: LD_INT 20
70563: PPUSH
70564: CALL 16886 0 4
70568: PUSH
70569: LD_INT 4
70571: ARRAY
70572: OR
70573: IFFALSE 70577
// break ;
70575: GO 70610
// if not HasTask ( j ) then
70577: LD_VAR 0 3
70581: PPUSH
70582: CALL_OW 314
70586: NOT
70587: IFFALSE 70608
// ComTameXY ( j , x , y ) ;
70589: LD_VAR 0 3
70593: PPUSH
70594: LD_VAR 0 4
70598: PPUSH
70599: LD_VAR 0 5
70603: PPUSH
70604: CALL_OW 131
// end ; end ;
70608: GO 70273
70610: POP
70611: POP
// end ;
70612: GO 69829
70614: POP
70615: POP
// end ;
70616: LD_VAR 0 1
70620: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
70621: LD_INT 0
70623: PPUSH
70624: PPUSH
70625: PPUSH
70626: PPUSH
70627: PPUSH
70628: PPUSH
70629: PPUSH
70630: PPUSH
// if not mc_bases then
70631: LD_EXP 23
70635: NOT
70636: IFFALSE 70640
// exit ;
70638: GO 71266
// for i = 1 to mc_bases do
70640: LD_ADDR_VAR 0 2
70644: PUSH
70645: DOUBLE
70646: LD_INT 1
70648: DEC
70649: ST_TO_ADDR
70650: LD_EXP 23
70654: PUSH
70655: FOR_TO
70656: IFFALSE 71264
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
70658: LD_EXP 52
70662: PUSH
70663: LD_VAR 0 2
70667: ARRAY
70668: NOT
70669: PUSH
70670: LD_EXP 52
70674: PUSH
70675: LD_VAR 0 2
70679: ARRAY
70680: PPUSH
70681: LD_INT 25
70683: PUSH
70684: LD_INT 12
70686: PUSH
70687: EMPTY
70688: LIST
70689: LIST
70690: PPUSH
70691: CALL_OW 72
70695: NOT
70696: OR
70697: IFFALSE 70701
// continue ;
70699: GO 70655
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
70701: LD_ADDR_VAR 0 5
70705: PUSH
70706: LD_EXP 52
70710: PUSH
70711: LD_VAR 0 2
70715: ARRAY
70716: PUSH
70717: LD_INT 1
70719: ARRAY
70720: PPUSH
70721: CALL_OW 255
70725: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
70726: LD_VAR 0 5
70730: PPUSH
70731: LD_INT 2
70733: PPUSH
70734: CALL_OW 325
70738: IFFALSE 70991
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
70740: LD_ADDR_VAR 0 4
70744: PUSH
70745: LD_EXP 52
70749: PUSH
70750: LD_VAR 0 2
70754: ARRAY
70755: PPUSH
70756: LD_INT 25
70758: PUSH
70759: LD_INT 16
70761: PUSH
70762: EMPTY
70763: LIST
70764: LIST
70765: PPUSH
70766: CALL_OW 72
70770: ST_TO_ADDR
// if tmp < 6 then
70771: LD_VAR 0 4
70775: PUSH
70776: LD_INT 6
70778: LESS
70779: IFFALSE 70991
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70781: LD_ADDR_VAR 0 6
70785: PUSH
70786: LD_EXP 23
70790: PUSH
70791: LD_VAR 0 2
70795: ARRAY
70796: PPUSH
70797: LD_INT 2
70799: PUSH
70800: LD_INT 30
70802: PUSH
70803: LD_INT 0
70805: PUSH
70806: EMPTY
70807: LIST
70808: LIST
70809: PUSH
70810: LD_INT 30
70812: PUSH
70813: LD_INT 1
70815: PUSH
70816: EMPTY
70817: LIST
70818: LIST
70819: PUSH
70820: EMPTY
70821: LIST
70822: LIST
70823: LIST
70824: PPUSH
70825: CALL_OW 72
70829: ST_TO_ADDR
// if depot then
70830: LD_VAR 0 6
70834: IFFALSE 70991
// begin selected := 0 ;
70836: LD_ADDR_VAR 0 7
70840: PUSH
70841: LD_INT 0
70843: ST_TO_ADDR
// for j in depot do
70844: LD_ADDR_VAR 0 3
70848: PUSH
70849: LD_VAR 0 6
70853: PUSH
70854: FOR_IN
70855: IFFALSE 70886
// begin if UnitsInside ( j ) < 6 then
70857: LD_VAR 0 3
70861: PPUSH
70862: CALL_OW 313
70866: PUSH
70867: LD_INT 6
70869: LESS
70870: IFFALSE 70884
// begin selected := j ;
70872: LD_ADDR_VAR 0 7
70876: PUSH
70877: LD_VAR 0 3
70881: ST_TO_ADDR
// break ;
70882: GO 70886
// end ; end ;
70884: GO 70854
70886: POP
70887: POP
// if selected then
70888: LD_VAR 0 7
70892: IFFALSE 70991
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
70894: LD_ADDR_VAR 0 3
70898: PUSH
70899: LD_EXP 52
70903: PUSH
70904: LD_VAR 0 2
70908: ARRAY
70909: PPUSH
70910: LD_INT 25
70912: PUSH
70913: LD_INT 12
70915: PUSH
70916: EMPTY
70917: LIST
70918: LIST
70919: PPUSH
70920: CALL_OW 72
70924: PUSH
70925: FOR_IN
70926: IFFALSE 70989
// if not HasTask ( j ) then
70928: LD_VAR 0 3
70932: PPUSH
70933: CALL_OW 314
70937: NOT
70938: IFFALSE 70987
// begin if not IsInUnit ( j ) then
70940: LD_VAR 0 3
70944: PPUSH
70945: CALL_OW 310
70949: NOT
70950: IFFALSE 70966
// ComEnterUnit ( j , selected ) ;
70952: LD_VAR 0 3
70956: PPUSH
70957: LD_VAR 0 7
70961: PPUSH
70962: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
70966: LD_VAR 0 3
70970: PPUSH
70971: LD_INT 16
70973: PPUSH
70974: CALL_OW 183
// AddComExitBuilding ( j ) ;
70978: LD_VAR 0 3
70982: PPUSH
70983: CALL_OW 182
// end ;
70987: GO 70925
70989: POP
70990: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
70991: LD_VAR 0 5
70995: PPUSH
70996: LD_INT 11
70998: PPUSH
70999: CALL_OW 325
71003: IFFALSE 71262
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
71005: LD_ADDR_VAR 0 4
71009: PUSH
71010: LD_EXP 52
71014: PUSH
71015: LD_VAR 0 2
71019: ARRAY
71020: PPUSH
71021: LD_INT 25
71023: PUSH
71024: LD_INT 16
71026: PUSH
71027: EMPTY
71028: LIST
71029: LIST
71030: PPUSH
71031: CALL_OW 72
71035: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
71036: LD_VAR 0 4
71040: PUSH
71041: LD_INT 6
71043: GREATEREQUAL
71044: PUSH
71045: LD_VAR 0 5
71049: PPUSH
71050: LD_INT 2
71052: PPUSH
71053: CALL_OW 325
71057: NOT
71058: OR
71059: IFFALSE 71262
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
71061: LD_ADDR_VAR 0 8
71065: PUSH
71066: LD_EXP 23
71070: PUSH
71071: LD_VAR 0 2
71075: ARRAY
71076: PPUSH
71077: LD_INT 2
71079: PUSH
71080: LD_INT 30
71082: PUSH
71083: LD_INT 4
71085: PUSH
71086: EMPTY
71087: LIST
71088: LIST
71089: PUSH
71090: LD_INT 30
71092: PUSH
71093: LD_INT 5
71095: PUSH
71096: EMPTY
71097: LIST
71098: LIST
71099: PUSH
71100: EMPTY
71101: LIST
71102: LIST
71103: LIST
71104: PPUSH
71105: CALL_OW 72
71109: ST_TO_ADDR
// if barracks then
71110: LD_VAR 0 8
71114: IFFALSE 71262
// begin selected := 0 ;
71116: LD_ADDR_VAR 0 7
71120: PUSH
71121: LD_INT 0
71123: ST_TO_ADDR
// for j in barracks do
71124: LD_ADDR_VAR 0 3
71128: PUSH
71129: LD_VAR 0 8
71133: PUSH
71134: FOR_IN
71135: IFFALSE 71166
// begin if UnitsInside ( j ) < 6 then
71137: LD_VAR 0 3
71141: PPUSH
71142: CALL_OW 313
71146: PUSH
71147: LD_INT 6
71149: LESS
71150: IFFALSE 71164
// begin selected := j ;
71152: LD_ADDR_VAR 0 7
71156: PUSH
71157: LD_VAR 0 3
71161: ST_TO_ADDR
// break ;
71162: GO 71166
// end ; end ;
71164: GO 71134
71166: POP
71167: POP
// if selected then
71168: LD_VAR 0 7
71172: IFFALSE 71262
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
71174: LD_ADDR_VAR 0 3
71178: PUSH
71179: LD_EXP 52
71183: PUSH
71184: LD_VAR 0 2
71188: ARRAY
71189: PPUSH
71190: LD_INT 25
71192: PUSH
71193: LD_INT 12
71195: PUSH
71196: EMPTY
71197: LIST
71198: LIST
71199: PPUSH
71200: CALL_OW 72
71204: PUSH
71205: FOR_IN
71206: IFFALSE 71260
// if not IsInUnit ( j ) and not HasTask ( j ) then
71208: LD_VAR 0 3
71212: PPUSH
71213: CALL_OW 310
71217: NOT
71218: PUSH
71219: LD_VAR 0 3
71223: PPUSH
71224: CALL_OW 314
71228: NOT
71229: AND
71230: IFFALSE 71258
// begin ComEnterUnit ( j , selected ) ;
71232: LD_VAR 0 3
71236: PPUSH
71237: LD_VAR 0 7
71241: PPUSH
71242: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
71246: LD_VAR 0 3
71250: PPUSH
71251: LD_INT 15
71253: PPUSH
71254: CALL_OW 183
// end ;
71258: GO 71205
71260: POP
71261: POP
// end ; end ; end ; end ; end ;
71262: GO 70655
71264: POP
71265: POP
// end ;
71266: LD_VAR 0 1
71270: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
71271: LD_INT 0
71273: PPUSH
71274: PPUSH
71275: PPUSH
71276: PPUSH
// if not mc_bases then
71277: LD_EXP 23
71281: NOT
71282: IFFALSE 71286
// exit ;
71284: GO 71464
// for i = 1 to mc_bases do
71286: LD_ADDR_VAR 0 2
71290: PUSH
71291: DOUBLE
71292: LD_INT 1
71294: DEC
71295: ST_TO_ADDR
71296: LD_EXP 23
71300: PUSH
71301: FOR_TO
71302: IFFALSE 71462
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
71304: LD_ADDR_VAR 0 4
71308: PUSH
71309: LD_EXP 23
71313: PUSH
71314: LD_VAR 0 2
71318: ARRAY
71319: PPUSH
71320: LD_INT 25
71322: PUSH
71323: LD_INT 9
71325: PUSH
71326: EMPTY
71327: LIST
71328: LIST
71329: PPUSH
71330: CALL_OW 72
71334: ST_TO_ADDR
// if not tmp then
71335: LD_VAR 0 4
71339: NOT
71340: IFFALSE 71344
// continue ;
71342: GO 71301
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
71344: LD_EXP 49
71348: PUSH
71349: LD_VAR 0 2
71353: ARRAY
71354: PPUSH
71355: LD_INT 29
71357: PPUSH
71358: CALL_OW 325
71362: NOT
71363: PUSH
71364: LD_EXP 49
71368: PUSH
71369: LD_VAR 0 2
71373: ARRAY
71374: PPUSH
71375: LD_INT 28
71377: PPUSH
71378: CALL_OW 325
71382: NOT
71383: AND
71384: IFFALSE 71388
// continue ;
71386: GO 71301
// for j in tmp do
71388: LD_ADDR_VAR 0 3
71392: PUSH
71393: LD_VAR 0 4
71397: PUSH
71398: FOR_IN
71399: IFFALSE 71458
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
71401: LD_VAR 0 3
71405: PUSH
71406: LD_EXP 26
71410: PUSH
71411: LD_VAR 0 2
71415: ARRAY
71416: PUSH
71417: LD_INT 1
71419: ARRAY
71420: IN
71421: NOT
71422: PUSH
71423: LD_VAR 0 3
71427: PUSH
71428: LD_EXP 26
71432: PUSH
71433: LD_VAR 0 2
71437: ARRAY
71438: PUSH
71439: LD_INT 2
71441: ARRAY
71442: IN
71443: NOT
71444: AND
71445: IFFALSE 71456
// ComSpaceTimeShoot ( j ) ;
71447: LD_VAR 0 3
71451: PPUSH
71452: CALL 11951 0 1
71456: GO 71398
71458: POP
71459: POP
// end ;
71460: GO 71301
71462: POP
71463: POP
// end ;
71464: LD_VAR 0 1
71468: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
71469: LD_INT 0
71471: PPUSH
71472: PPUSH
71473: PPUSH
71474: PPUSH
71475: PPUSH
71476: PPUSH
71477: PPUSH
71478: PPUSH
71479: PPUSH
// if not mc_bases then
71480: LD_EXP 23
71484: NOT
71485: IFFALSE 71489
// exit ;
71487: GO 72111
// for i = 1 to mc_bases do
71489: LD_ADDR_VAR 0 2
71493: PUSH
71494: DOUBLE
71495: LD_INT 1
71497: DEC
71498: ST_TO_ADDR
71499: LD_EXP 23
71503: PUSH
71504: FOR_TO
71505: IFFALSE 72109
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
71507: LD_EXP 58
71511: PUSH
71512: LD_VAR 0 2
71516: ARRAY
71517: NOT
71518: PUSH
71519: LD_INT 38
71521: PPUSH
71522: LD_EXP 49
71526: PUSH
71527: LD_VAR 0 2
71531: ARRAY
71532: PPUSH
71533: CALL_OW 321
71537: PUSH
71538: LD_INT 2
71540: NONEQUAL
71541: OR
71542: IFFALSE 71546
// continue ;
71544: GO 71504
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
71546: LD_ADDR_VAR 0 8
71550: PUSH
71551: LD_EXP 23
71555: PUSH
71556: LD_VAR 0 2
71560: ARRAY
71561: PPUSH
71562: LD_INT 30
71564: PUSH
71565: LD_INT 34
71567: PUSH
71568: EMPTY
71569: LIST
71570: LIST
71571: PPUSH
71572: CALL_OW 72
71576: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
71577: LD_ADDR_VAR 0 9
71581: PUSH
71582: LD_EXP 23
71586: PUSH
71587: LD_VAR 0 2
71591: ARRAY
71592: PPUSH
71593: LD_INT 25
71595: PUSH
71596: LD_INT 4
71598: PUSH
71599: EMPTY
71600: LIST
71601: LIST
71602: PPUSH
71603: CALL_OW 72
71607: PPUSH
71608: LD_INT 0
71610: PPUSH
71611: CALL 45259 0 2
71615: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
71616: LD_VAR 0 9
71620: NOT
71621: PUSH
71622: LD_VAR 0 8
71626: NOT
71627: OR
71628: PUSH
71629: LD_EXP 23
71633: PUSH
71634: LD_VAR 0 2
71638: ARRAY
71639: PPUSH
71640: LD_INT 124
71642: PPUSH
71643: CALL 45259 0 2
71647: OR
71648: IFFALSE 71652
// continue ;
71650: GO 71504
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
71652: LD_EXP 59
71656: PUSH
71657: LD_VAR 0 2
71661: ARRAY
71662: PUSH
71663: LD_EXP 58
71667: PUSH
71668: LD_VAR 0 2
71672: ARRAY
71673: LESS
71674: PUSH
71675: LD_EXP 59
71679: PUSH
71680: LD_VAR 0 2
71684: ARRAY
71685: PUSH
71686: LD_VAR 0 8
71690: LESS
71691: AND
71692: IFFALSE 72107
// begin tmp := sci [ 1 ] ;
71694: LD_ADDR_VAR 0 7
71698: PUSH
71699: LD_VAR 0 9
71703: PUSH
71704: LD_INT 1
71706: ARRAY
71707: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
71708: LD_VAR 0 7
71712: PPUSH
71713: LD_INT 124
71715: PPUSH
71716: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
71720: LD_ADDR_VAR 0 3
71724: PUSH
71725: DOUBLE
71726: LD_EXP 58
71730: PUSH
71731: LD_VAR 0 2
71735: ARRAY
71736: INC
71737: ST_TO_ADDR
71738: LD_EXP 58
71742: PUSH
71743: LD_VAR 0 2
71747: ARRAY
71748: PUSH
71749: FOR_DOWNTO
71750: IFFALSE 72093
// begin if IsInUnit ( tmp ) then
71752: LD_VAR 0 7
71756: PPUSH
71757: CALL_OW 310
71761: IFFALSE 71772
// ComExitBuilding ( tmp ) ;
71763: LD_VAR 0 7
71767: PPUSH
71768: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
71772: LD_INT 35
71774: PPUSH
71775: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
71779: LD_VAR 0 7
71783: PPUSH
71784: CALL_OW 310
71788: NOT
71789: PUSH
71790: LD_VAR 0 7
71794: PPUSH
71795: CALL_OW 314
71799: NOT
71800: AND
71801: IFFALSE 71772
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
71803: LD_ADDR_VAR 0 6
71807: PUSH
71808: LD_VAR 0 7
71812: PPUSH
71813: CALL_OW 250
71817: PUSH
71818: LD_VAR 0 7
71822: PPUSH
71823: CALL_OW 251
71827: PUSH
71828: EMPTY
71829: LIST
71830: LIST
71831: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
71832: LD_INT 35
71834: PPUSH
71835: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
71839: LD_ADDR_VAR 0 4
71843: PUSH
71844: LD_EXP 58
71848: PUSH
71849: LD_VAR 0 2
71853: ARRAY
71854: PUSH
71855: LD_VAR 0 3
71859: ARRAY
71860: PUSH
71861: LD_INT 1
71863: ARRAY
71864: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
71865: LD_ADDR_VAR 0 5
71869: PUSH
71870: LD_EXP 58
71874: PUSH
71875: LD_VAR 0 2
71879: ARRAY
71880: PUSH
71881: LD_VAR 0 3
71885: ARRAY
71886: PUSH
71887: LD_INT 2
71889: ARRAY
71890: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
71891: LD_VAR 0 7
71895: PPUSH
71896: LD_INT 10
71898: PPUSH
71899: CALL 18589 0 2
71903: PUSH
71904: LD_INT 4
71906: ARRAY
71907: IFFALSE 71945
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
71909: LD_VAR 0 7
71913: PPUSH
71914: LD_VAR 0 6
71918: PUSH
71919: LD_INT 1
71921: ARRAY
71922: PPUSH
71923: LD_VAR 0 6
71927: PUSH
71928: LD_INT 2
71930: ARRAY
71931: PPUSH
71932: CALL_OW 111
// wait ( 0 0$10 ) ;
71936: LD_INT 350
71938: PPUSH
71939: CALL_OW 67
// end else
71943: GO 71971
// begin ComMoveXY ( tmp , x , y ) ;
71945: LD_VAR 0 7
71949: PPUSH
71950: LD_VAR 0 4
71954: PPUSH
71955: LD_VAR 0 5
71959: PPUSH
71960: CALL_OW 111
// wait ( 0 0$3 ) ;
71964: LD_INT 105
71966: PPUSH
71967: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
71971: LD_VAR 0 7
71975: PPUSH
71976: LD_VAR 0 4
71980: PPUSH
71981: LD_VAR 0 5
71985: PPUSH
71986: CALL_OW 307
71990: IFFALSE 71832
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
71992: LD_VAR 0 7
71996: PPUSH
71997: LD_VAR 0 4
72001: PPUSH
72002: LD_VAR 0 5
72006: PPUSH
72007: LD_VAR 0 8
72011: PUSH
72012: LD_VAR 0 3
72016: ARRAY
72017: PPUSH
72018: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
72022: LD_INT 35
72024: PPUSH
72025: CALL_OW 67
// until not HasTask ( tmp ) ;
72029: LD_VAR 0 7
72033: PPUSH
72034: CALL_OW 314
72038: NOT
72039: IFFALSE 72022
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
72041: LD_ADDR_EXP 59
72045: PUSH
72046: LD_EXP 59
72050: PPUSH
72051: LD_VAR 0 2
72055: PUSH
72056: LD_EXP 59
72060: PUSH
72061: LD_VAR 0 2
72065: ARRAY
72066: PUSH
72067: LD_INT 1
72069: PLUS
72070: PUSH
72071: EMPTY
72072: LIST
72073: LIST
72074: PPUSH
72075: LD_VAR 0 8
72079: PUSH
72080: LD_VAR 0 3
72084: ARRAY
72085: PPUSH
72086: CALL 15990 0 3
72090: ST_TO_ADDR
// end ;
72091: GO 71749
72093: POP
72094: POP
// MC_Reset ( i , 124 ) ;
72095: LD_VAR 0 2
72099: PPUSH
72100: LD_INT 124
72102: PPUSH
72103: CALL 55249 0 2
// end ; end ;
72107: GO 71504
72109: POP
72110: POP
// end ;
72111: LD_VAR 0 1
72115: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
72116: LD_INT 0
72118: PPUSH
72119: PPUSH
72120: PPUSH
// if not mc_bases then
72121: LD_EXP 23
72125: NOT
72126: IFFALSE 72130
// exit ;
72128: GO 72736
// for i = 1 to mc_bases do
72130: LD_ADDR_VAR 0 2
72134: PUSH
72135: DOUBLE
72136: LD_INT 1
72138: DEC
72139: ST_TO_ADDR
72140: LD_EXP 23
72144: PUSH
72145: FOR_TO
72146: IFFALSE 72734
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
72148: LD_ADDR_VAR 0 3
72152: PUSH
72153: LD_EXP 23
72157: PUSH
72158: LD_VAR 0 2
72162: ARRAY
72163: PPUSH
72164: LD_INT 25
72166: PUSH
72167: LD_INT 4
72169: PUSH
72170: EMPTY
72171: LIST
72172: LIST
72173: PPUSH
72174: CALL_OW 72
72178: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
72179: LD_VAR 0 3
72183: NOT
72184: PUSH
72185: LD_EXP 60
72189: PUSH
72190: LD_VAR 0 2
72194: ARRAY
72195: NOT
72196: OR
72197: PUSH
72198: LD_EXP 23
72202: PUSH
72203: LD_VAR 0 2
72207: ARRAY
72208: PPUSH
72209: LD_INT 2
72211: PUSH
72212: LD_INT 30
72214: PUSH
72215: LD_INT 0
72217: PUSH
72218: EMPTY
72219: LIST
72220: LIST
72221: PUSH
72222: LD_INT 30
72224: PUSH
72225: LD_INT 1
72227: PUSH
72228: EMPTY
72229: LIST
72230: LIST
72231: PUSH
72232: EMPTY
72233: LIST
72234: LIST
72235: LIST
72236: PPUSH
72237: CALL_OW 72
72241: NOT
72242: OR
72243: IFFALSE 72293
// begin if mc_deposits_finder [ i ] then
72245: LD_EXP 61
72249: PUSH
72250: LD_VAR 0 2
72254: ARRAY
72255: IFFALSE 72291
// begin MC_Reset ( i , 125 ) ;
72257: LD_VAR 0 2
72261: PPUSH
72262: LD_INT 125
72264: PPUSH
72265: CALL 55249 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
72269: LD_ADDR_EXP 61
72273: PUSH
72274: LD_EXP 61
72278: PPUSH
72279: LD_VAR 0 2
72283: PPUSH
72284: EMPTY
72285: PPUSH
72286: CALL_OW 1
72290: ST_TO_ADDR
// end ; continue ;
72291: GO 72145
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
72293: LD_EXP 60
72297: PUSH
72298: LD_VAR 0 2
72302: ARRAY
72303: PUSH
72304: LD_INT 1
72306: ARRAY
72307: PUSH
72308: LD_INT 3
72310: ARRAY
72311: PUSH
72312: LD_INT 1
72314: EQUAL
72315: PUSH
72316: LD_INT 20
72318: PPUSH
72319: LD_EXP 49
72323: PUSH
72324: LD_VAR 0 2
72328: ARRAY
72329: PPUSH
72330: CALL_OW 321
72334: PUSH
72335: LD_INT 2
72337: NONEQUAL
72338: AND
72339: IFFALSE 72389
// begin if mc_deposits_finder [ i ] then
72341: LD_EXP 61
72345: PUSH
72346: LD_VAR 0 2
72350: ARRAY
72351: IFFALSE 72387
// begin MC_Reset ( i , 125 ) ;
72353: LD_VAR 0 2
72357: PPUSH
72358: LD_INT 125
72360: PPUSH
72361: CALL 55249 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
72365: LD_ADDR_EXP 61
72369: PUSH
72370: LD_EXP 61
72374: PPUSH
72375: LD_VAR 0 2
72379: PPUSH
72380: EMPTY
72381: PPUSH
72382: CALL_OW 1
72386: ST_TO_ADDR
// end ; continue ;
72387: GO 72145
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
72389: LD_EXP 60
72393: PUSH
72394: LD_VAR 0 2
72398: ARRAY
72399: PUSH
72400: LD_INT 1
72402: ARRAY
72403: PUSH
72404: LD_INT 1
72406: ARRAY
72407: PPUSH
72408: LD_EXP 60
72412: PUSH
72413: LD_VAR 0 2
72417: ARRAY
72418: PUSH
72419: LD_INT 1
72421: ARRAY
72422: PUSH
72423: LD_INT 2
72425: ARRAY
72426: PPUSH
72427: LD_EXP 49
72431: PUSH
72432: LD_VAR 0 2
72436: ARRAY
72437: PPUSH
72438: CALL_OW 440
72442: IFFALSE 72485
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
72444: LD_ADDR_EXP 60
72448: PUSH
72449: LD_EXP 60
72453: PPUSH
72454: LD_VAR 0 2
72458: PPUSH
72459: LD_EXP 60
72463: PUSH
72464: LD_VAR 0 2
72468: ARRAY
72469: PPUSH
72470: LD_INT 1
72472: PPUSH
72473: CALL_OW 3
72477: PPUSH
72478: CALL_OW 1
72482: ST_TO_ADDR
72483: GO 72732
// begin if not mc_deposits_finder [ i ] then
72485: LD_EXP 61
72489: PUSH
72490: LD_VAR 0 2
72494: ARRAY
72495: NOT
72496: IFFALSE 72548
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
72498: LD_ADDR_EXP 61
72502: PUSH
72503: LD_EXP 61
72507: PPUSH
72508: LD_VAR 0 2
72512: PPUSH
72513: LD_VAR 0 3
72517: PUSH
72518: LD_INT 1
72520: ARRAY
72521: PUSH
72522: EMPTY
72523: LIST
72524: PPUSH
72525: CALL_OW 1
72529: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
72530: LD_VAR 0 3
72534: PUSH
72535: LD_INT 1
72537: ARRAY
72538: PPUSH
72539: LD_INT 125
72541: PPUSH
72542: CALL_OW 109
// end else
72546: GO 72732
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
72548: LD_EXP 61
72552: PUSH
72553: LD_VAR 0 2
72557: ARRAY
72558: PUSH
72559: LD_INT 1
72561: ARRAY
72562: PPUSH
72563: CALL_OW 310
72567: IFFALSE 72590
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
72569: LD_EXP 61
72573: PUSH
72574: LD_VAR 0 2
72578: ARRAY
72579: PUSH
72580: LD_INT 1
72582: ARRAY
72583: PPUSH
72584: CALL_OW 122
72588: GO 72732
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
72590: LD_EXP 61
72594: PUSH
72595: LD_VAR 0 2
72599: ARRAY
72600: PUSH
72601: LD_INT 1
72603: ARRAY
72604: PPUSH
72605: CALL_OW 314
72609: NOT
72610: PUSH
72611: LD_EXP 61
72615: PUSH
72616: LD_VAR 0 2
72620: ARRAY
72621: PUSH
72622: LD_INT 1
72624: ARRAY
72625: PPUSH
72626: LD_EXP 60
72630: PUSH
72631: LD_VAR 0 2
72635: ARRAY
72636: PUSH
72637: LD_INT 1
72639: ARRAY
72640: PUSH
72641: LD_INT 1
72643: ARRAY
72644: PPUSH
72645: LD_EXP 60
72649: PUSH
72650: LD_VAR 0 2
72654: ARRAY
72655: PUSH
72656: LD_INT 1
72658: ARRAY
72659: PUSH
72660: LD_INT 2
72662: ARRAY
72663: PPUSH
72664: CALL_OW 297
72668: PUSH
72669: LD_INT 6
72671: GREATER
72672: AND
72673: IFFALSE 72732
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
72675: LD_EXP 61
72679: PUSH
72680: LD_VAR 0 2
72684: ARRAY
72685: PUSH
72686: LD_INT 1
72688: ARRAY
72689: PPUSH
72690: LD_EXP 60
72694: PUSH
72695: LD_VAR 0 2
72699: ARRAY
72700: PUSH
72701: LD_INT 1
72703: ARRAY
72704: PUSH
72705: LD_INT 1
72707: ARRAY
72708: PPUSH
72709: LD_EXP 60
72713: PUSH
72714: LD_VAR 0 2
72718: ARRAY
72719: PUSH
72720: LD_INT 1
72722: ARRAY
72723: PUSH
72724: LD_INT 2
72726: ARRAY
72727: PPUSH
72728: CALL_OW 111
// end ; end ; end ;
72732: GO 72145
72734: POP
72735: POP
// end ;
72736: LD_VAR 0 1
72740: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
72741: LD_INT 0
72743: PPUSH
72744: PPUSH
72745: PPUSH
72746: PPUSH
72747: PPUSH
72748: PPUSH
72749: PPUSH
72750: PPUSH
72751: PPUSH
72752: PPUSH
72753: PPUSH
// if not mc_bases then
72754: LD_EXP 23
72758: NOT
72759: IFFALSE 72763
// exit ;
72761: GO 73703
// for i = 1 to mc_bases do
72763: LD_ADDR_VAR 0 2
72767: PUSH
72768: DOUBLE
72769: LD_INT 1
72771: DEC
72772: ST_TO_ADDR
72773: LD_EXP 23
72777: PUSH
72778: FOR_TO
72779: IFFALSE 73701
// begin if not mc_bases [ i ] or mc_scan [ i ] then
72781: LD_EXP 23
72785: PUSH
72786: LD_VAR 0 2
72790: ARRAY
72791: NOT
72792: PUSH
72793: LD_EXP 46
72797: PUSH
72798: LD_VAR 0 2
72802: ARRAY
72803: OR
72804: IFFALSE 72808
// continue ;
72806: GO 72778
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
72808: LD_ADDR_VAR 0 7
72812: PUSH
72813: LD_EXP 23
72817: PUSH
72818: LD_VAR 0 2
72822: ARRAY
72823: PUSH
72824: LD_INT 1
72826: ARRAY
72827: PPUSH
72828: CALL_OW 248
72832: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
72833: LD_VAR 0 7
72837: PUSH
72838: LD_INT 3
72840: EQUAL
72841: PUSH
72842: LD_EXP 42
72846: PUSH
72847: LD_VAR 0 2
72851: ARRAY
72852: PUSH
72853: LD_EXP 45
72857: PUSH
72858: LD_VAR 0 2
72862: ARRAY
72863: UNION
72864: PPUSH
72865: LD_INT 33
72867: PUSH
72868: LD_INT 2
72870: PUSH
72871: EMPTY
72872: LIST
72873: LIST
72874: PPUSH
72875: CALL_OW 72
72879: NOT
72880: OR
72881: IFFALSE 72885
// continue ;
72883: GO 72778
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
72885: LD_ADDR_VAR 0 9
72889: PUSH
72890: LD_EXP 23
72894: PUSH
72895: LD_VAR 0 2
72899: ARRAY
72900: PPUSH
72901: LD_INT 30
72903: PUSH
72904: LD_INT 36
72906: PUSH
72907: EMPTY
72908: LIST
72909: LIST
72910: PPUSH
72911: CALL_OW 72
72915: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
72916: LD_ADDR_VAR 0 10
72920: PUSH
72921: LD_EXP 42
72925: PUSH
72926: LD_VAR 0 2
72930: ARRAY
72931: PPUSH
72932: LD_INT 34
72934: PUSH
72935: LD_INT 31
72937: PUSH
72938: EMPTY
72939: LIST
72940: LIST
72941: PPUSH
72942: CALL_OW 72
72946: ST_TO_ADDR
// if not cts and not mcts then
72947: LD_VAR 0 9
72951: NOT
72952: PUSH
72953: LD_VAR 0 10
72957: NOT
72958: AND
72959: IFFALSE 72963
// continue ;
72961: GO 72778
// x := cts ;
72963: LD_ADDR_VAR 0 11
72967: PUSH
72968: LD_VAR 0 9
72972: ST_TO_ADDR
// if not x then
72973: LD_VAR 0 11
72977: NOT
72978: IFFALSE 72990
// x := mcts ;
72980: LD_ADDR_VAR 0 11
72984: PUSH
72985: LD_VAR 0 10
72989: ST_TO_ADDR
// if not x then
72990: LD_VAR 0 11
72994: NOT
72995: IFFALSE 72999
// continue ;
72997: GO 72778
// if mc_remote_driver [ i ] then
72999: LD_EXP 63
73003: PUSH
73004: LD_VAR 0 2
73008: ARRAY
73009: IFFALSE 73396
// for j in mc_remote_driver [ i ] do
73011: LD_ADDR_VAR 0 3
73015: PUSH
73016: LD_EXP 63
73020: PUSH
73021: LD_VAR 0 2
73025: ARRAY
73026: PUSH
73027: FOR_IN
73028: IFFALSE 73394
// begin if GetClass ( j ) <> 3 then
73030: LD_VAR 0 3
73034: PPUSH
73035: CALL_OW 257
73039: PUSH
73040: LD_INT 3
73042: NONEQUAL
73043: IFFALSE 73096
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
73045: LD_ADDR_EXP 63
73049: PUSH
73050: LD_EXP 63
73054: PPUSH
73055: LD_VAR 0 2
73059: PPUSH
73060: LD_EXP 63
73064: PUSH
73065: LD_VAR 0 2
73069: ARRAY
73070: PUSH
73071: LD_VAR 0 3
73075: DIFF
73076: PPUSH
73077: CALL_OW 1
73081: ST_TO_ADDR
// SetTag ( j , 0 ) ;
73082: LD_VAR 0 3
73086: PPUSH
73087: LD_INT 0
73089: PPUSH
73090: CALL_OW 109
// continue ;
73094: GO 73027
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
73096: LD_EXP 42
73100: PUSH
73101: LD_VAR 0 2
73105: ARRAY
73106: PPUSH
73107: LD_INT 34
73109: PUSH
73110: LD_INT 31
73112: PUSH
73113: EMPTY
73114: LIST
73115: LIST
73116: PUSH
73117: LD_INT 58
73119: PUSH
73120: EMPTY
73121: LIST
73122: PUSH
73123: EMPTY
73124: LIST
73125: LIST
73126: PPUSH
73127: CALL_OW 72
73131: PUSH
73132: LD_VAR 0 3
73136: PPUSH
73137: CALL 45347 0 1
73141: NOT
73142: AND
73143: IFFALSE 73214
// begin if IsInUnit ( j ) then
73145: LD_VAR 0 3
73149: PPUSH
73150: CALL_OW 310
73154: IFFALSE 73165
// ComExitBuilding ( j ) ;
73156: LD_VAR 0 3
73160: PPUSH
73161: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
73165: LD_VAR 0 3
73169: PPUSH
73170: LD_EXP 42
73174: PUSH
73175: LD_VAR 0 2
73179: ARRAY
73180: PPUSH
73181: LD_INT 34
73183: PUSH
73184: LD_INT 31
73186: PUSH
73187: EMPTY
73188: LIST
73189: LIST
73190: PUSH
73191: LD_INT 58
73193: PUSH
73194: EMPTY
73195: LIST
73196: PUSH
73197: EMPTY
73198: LIST
73199: LIST
73200: PPUSH
73201: CALL_OW 72
73205: PUSH
73206: LD_INT 1
73208: ARRAY
73209: PPUSH
73210: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
73214: LD_VAR 0 3
73218: PPUSH
73219: CALL_OW 310
73223: NOT
73224: PUSH
73225: LD_VAR 0 3
73229: PPUSH
73230: CALL_OW 310
73234: PPUSH
73235: CALL_OW 266
73239: PUSH
73240: LD_INT 36
73242: NONEQUAL
73243: PUSH
73244: LD_VAR 0 3
73248: PPUSH
73249: CALL 45347 0 1
73253: NOT
73254: AND
73255: OR
73256: IFFALSE 73392
// begin if IsInUnit ( j ) then
73258: LD_VAR 0 3
73262: PPUSH
73263: CALL_OW 310
73267: IFFALSE 73278
// ComExitBuilding ( j ) ;
73269: LD_VAR 0 3
73273: PPUSH
73274: CALL_OW 122
// ct := 0 ;
73278: LD_ADDR_VAR 0 8
73282: PUSH
73283: LD_INT 0
73285: ST_TO_ADDR
// for k in x do
73286: LD_ADDR_VAR 0 4
73290: PUSH
73291: LD_VAR 0 11
73295: PUSH
73296: FOR_IN
73297: IFFALSE 73370
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
73299: LD_VAR 0 4
73303: PPUSH
73304: CALL_OW 264
73308: PUSH
73309: LD_INT 31
73311: EQUAL
73312: PUSH
73313: LD_VAR 0 4
73317: PPUSH
73318: CALL_OW 311
73322: NOT
73323: AND
73324: PUSH
73325: LD_VAR 0 4
73329: PPUSH
73330: CALL_OW 266
73334: PUSH
73335: LD_INT 36
73337: EQUAL
73338: PUSH
73339: LD_VAR 0 4
73343: PPUSH
73344: CALL_OW 313
73348: PUSH
73349: LD_INT 3
73351: LESS
73352: AND
73353: OR
73354: IFFALSE 73368
// begin ct := k ;
73356: LD_ADDR_VAR 0 8
73360: PUSH
73361: LD_VAR 0 4
73365: ST_TO_ADDR
// break ;
73366: GO 73370
// end ;
73368: GO 73296
73370: POP
73371: POP
// if ct then
73372: LD_VAR 0 8
73376: IFFALSE 73392
// ComEnterUnit ( j , ct ) ;
73378: LD_VAR 0 3
73382: PPUSH
73383: LD_VAR 0 8
73387: PPUSH
73388: CALL_OW 120
// end ; end ;
73392: GO 73027
73394: POP
73395: POP
// places := 0 ;
73396: LD_ADDR_VAR 0 5
73400: PUSH
73401: LD_INT 0
73403: ST_TO_ADDR
// for j = 1 to x do
73404: LD_ADDR_VAR 0 3
73408: PUSH
73409: DOUBLE
73410: LD_INT 1
73412: DEC
73413: ST_TO_ADDR
73414: LD_VAR 0 11
73418: PUSH
73419: FOR_TO
73420: IFFALSE 73496
// if GetWeapon ( x [ j ] ) = ar_control_tower then
73422: LD_VAR 0 11
73426: PUSH
73427: LD_VAR 0 3
73431: ARRAY
73432: PPUSH
73433: CALL_OW 264
73437: PUSH
73438: LD_INT 31
73440: EQUAL
73441: IFFALSE 73459
// places := places + 1 else
73443: LD_ADDR_VAR 0 5
73447: PUSH
73448: LD_VAR 0 5
73452: PUSH
73453: LD_INT 1
73455: PLUS
73456: ST_TO_ADDR
73457: GO 73494
// if GetBType ( x [ j ] ) = b_control_tower then
73459: LD_VAR 0 11
73463: PUSH
73464: LD_VAR 0 3
73468: ARRAY
73469: PPUSH
73470: CALL_OW 266
73474: PUSH
73475: LD_INT 36
73477: EQUAL
73478: IFFALSE 73494
// places := places + 3 ;
73480: LD_ADDR_VAR 0 5
73484: PUSH
73485: LD_VAR 0 5
73489: PUSH
73490: LD_INT 3
73492: PLUS
73493: ST_TO_ADDR
73494: GO 73419
73496: POP
73497: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
73498: LD_VAR 0 5
73502: PUSH
73503: LD_INT 0
73505: EQUAL
73506: PUSH
73507: LD_VAR 0 5
73511: PUSH
73512: LD_EXP 63
73516: PUSH
73517: LD_VAR 0 2
73521: ARRAY
73522: LESSEQUAL
73523: OR
73524: IFFALSE 73528
// continue ;
73526: GO 72778
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
73528: LD_ADDR_VAR 0 6
73532: PUSH
73533: LD_EXP 23
73537: PUSH
73538: LD_VAR 0 2
73542: ARRAY
73543: PPUSH
73544: LD_INT 25
73546: PUSH
73547: LD_INT 3
73549: PUSH
73550: EMPTY
73551: LIST
73552: LIST
73553: PPUSH
73554: CALL_OW 72
73558: PUSH
73559: LD_EXP 63
73563: PUSH
73564: LD_VAR 0 2
73568: ARRAY
73569: DIFF
73570: PPUSH
73571: LD_INT 3
73573: PPUSH
73574: CALL 46247 0 2
73578: ST_TO_ADDR
// for j in tmp do
73579: LD_ADDR_VAR 0 3
73583: PUSH
73584: LD_VAR 0 6
73588: PUSH
73589: FOR_IN
73590: IFFALSE 73625
// if GetTag ( j ) > 0 then
73592: LD_VAR 0 3
73596: PPUSH
73597: CALL_OW 110
73601: PUSH
73602: LD_INT 0
73604: GREATER
73605: IFFALSE 73623
// tmp := tmp diff j ;
73607: LD_ADDR_VAR 0 6
73611: PUSH
73612: LD_VAR 0 6
73616: PUSH
73617: LD_VAR 0 3
73621: DIFF
73622: ST_TO_ADDR
73623: GO 73589
73625: POP
73626: POP
// if not tmp then
73627: LD_VAR 0 6
73631: NOT
73632: IFFALSE 73636
// continue ;
73634: GO 72778
// if places then
73636: LD_VAR 0 5
73640: IFFALSE 73699
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
73642: LD_ADDR_EXP 63
73646: PUSH
73647: LD_EXP 63
73651: PPUSH
73652: LD_VAR 0 2
73656: PPUSH
73657: LD_EXP 63
73661: PUSH
73662: LD_VAR 0 2
73666: ARRAY
73667: PUSH
73668: LD_VAR 0 6
73672: PUSH
73673: LD_INT 1
73675: ARRAY
73676: UNION
73677: PPUSH
73678: CALL_OW 1
73682: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
73683: LD_VAR 0 6
73687: PUSH
73688: LD_INT 1
73690: ARRAY
73691: PPUSH
73692: LD_INT 126
73694: PPUSH
73695: CALL_OW 109
// end ; end ;
73699: GO 72778
73701: POP
73702: POP
// end ;
73703: LD_VAR 0 1
73707: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
73708: LD_INT 0
73710: PPUSH
73711: PPUSH
73712: PPUSH
73713: PPUSH
73714: PPUSH
73715: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
73716: LD_VAR 0 1
73720: NOT
73721: PUSH
73722: LD_VAR 0 2
73726: NOT
73727: OR
73728: PUSH
73729: LD_VAR 0 3
73733: NOT
73734: OR
73735: PUSH
73736: LD_VAR 0 4
73740: PUSH
73741: LD_INT 1
73743: PUSH
73744: LD_INT 2
73746: PUSH
73747: LD_INT 3
73749: PUSH
73750: LD_INT 4
73752: PUSH
73753: LD_INT 5
73755: PUSH
73756: LD_INT 8
73758: PUSH
73759: LD_INT 9
73761: PUSH
73762: LD_INT 15
73764: PUSH
73765: LD_INT 16
73767: PUSH
73768: EMPTY
73769: LIST
73770: LIST
73771: LIST
73772: LIST
73773: LIST
73774: LIST
73775: LIST
73776: LIST
73777: LIST
73778: IN
73779: NOT
73780: OR
73781: IFFALSE 73785
// exit ;
73783: GO 74685
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
73785: LD_ADDR_VAR 0 2
73789: PUSH
73790: LD_VAR 0 2
73794: PPUSH
73795: LD_INT 21
73797: PUSH
73798: LD_INT 3
73800: PUSH
73801: EMPTY
73802: LIST
73803: LIST
73804: PUSH
73805: LD_INT 24
73807: PUSH
73808: LD_INT 250
73810: PUSH
73811: EMPTY
73812: LIST
73813: LIST
73814: PUSH
73815: EMPTY
73816: LIST
73817: LIST
73818: PPUSH
73819: CALL_OW 72
73823: ST_TO_ADDR
// case class of 1 , 15 :
73824: LD_VAR 0 4
73828: PUSH
73829: LD_INT 1
73831: DOUBLE
73832: EQUAL
73833: IFTRUE 73843
73835: LD_INT 15
73837: DOUBLE
73838: EQUAL
73839: IFTRUE 73843
73841: GO 73928
73843: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
73844: LD_ADDR_VAR 0 8
73848: PUSH
73849: LD_VAR 0 2
73853: PPUSH
73854: LD_INT 2
73856: PUSH
73857: LD_INT 30
73859: PUSH
73860: LD_INT 32
73862: PUSH
73863: EMPTY
73864: LIST
73865: LIST
73866: PUSH
73867: LD_INT 30
73869: PUSH
73870: LD_INT 31
73872: PUSH
73873: EMPTY
73874: LIST
73875: LIST
73876: PUSH
73877: EMPTY
73878: LIST
73879: LIST
73880: LIST
73881: PPUSH
73882: CALL_OW 72
73886: PUSH
73887: LD_VAR 0 2
73891: PPUSH
73892: LD_INT 2
73894: PUSH
73895: LD_INT 30
73897: PUSH
73898: LD_INT 4
73900: PUSH
73901: EMPTY
73902: LIST
73903: LIST
73904: PUSH
73905: LD_INT 30
73907: PUSH
73908: LD_INT 5
73910: PUSH
73911: EMPTY
73912: LIST
73913: LIST
73914: PUSH
73915: EMPTY
73916: LIST
73917: LIST
73918: LIST
73919: PPUSH
73920: CALL_OW 72
73924: ADD
73925: ST_TO_ADDR
73926: GO 74174
73928: LD_INT 2
73930: DOUBLE
73931: EQUAL
73932: IFTRUE 73942
73934: LD_INT 16
73936: DOUBLE
73937: EQUAL
73938: IFTRUE 73942
73940: GO 73988
73942: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
73943: LD_ADDR_VAR 0 8
73947: PUSH
73948: LD_VAR 0 2
73952: PPUSH
73953: LD_INT 2
73955: PUSH
73956: LD_INT 30
73958: PUSH
73959: LD_INT 0
73961: PUSH
73962: EMPTY
73963: LIST
73964: LIST
73965: PUSH
73966: LD_INT 30
73968: PUSH
73969: LD_INT 1
73971: PUSH
73972: EMPTY
73973: LIST
73974: LIST
73975: PUSH
73976: EMPTY
73977: LIST
73978: LIST
73979: LIST
73980: PPUSH
73981: CALL_OW 72
73985: ST_TO_ADDR
73986: GO 74174
73988: LD_INT 3
73990: DOUBLE
73991: EQUAL
73992: IFTRUE 73996
73994: GO 74042
73996: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
73997: LD_ADDR_VAR 0 8
74001: PUSH
74002: LD_VAR 0 2
74006: PPUSH
74007: LD_INT 2
74009: PUSH
74010: LD_INT 30
74012: PUSH
74013: LD_INT 2
74015: PUSH
74016: EMPTY
74017: LIST
74018: LIST
74019: PUSH
74020: LD_INT 30
74022: PUSH
74023: LD_INT 3
74025: PUSH
74026: EMPTY
74027: LIST
74028: LIST
74029: PUSH
74030: EMPTY
74031: LIST
74032: LIST
74033: LIST
74034: PPUSH
74035: CALL_OW 72
74039: ST_TO_ADDR
74040: GO 74174
74042: LD_INT 4
74044: DOUBLE
74045: EQUAL
74046: IFTRUE 74050
74048: GO 74107
74050: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
74051: LD_ADDR_VAR 0 8
74055: PUSH
74056: LD_VAR 0 2
74060: PPUSH
74061: LD_INT 2
74063: PUSH
74064: LD_INT 30
74066: PUSH
74067: LD_INT 6
74069: PUSH
74070: EMPTY
74071: LIST
74072: LIST
74073: PUSH
74074: LD_INT 30
74076: PUSH
74077: LD_INT 7
74079: PUSH
74080: EMPTY
74081: LIST
74082: LIST
74083: PUSH
74084: LD_INT 30
74086: PUSH
74087: LD_INT 8
74089: PUSH
74090: EMPTY
74091: LIST
74092: LIST
74093: PUSH
74094: EMPTY
74095: LIST
74096: LIST
74097: LIST
74098: LIST
74099: PPUSH
74100: CALL_OW 72
74104: ST_TO_ADDR
74105: GO 74174
74107: LD_INT 5
74109: DOUBLE
74110: EQUAL
74111: IFTRUE 74127
74113: LD_INT 8
74115: DOUBLE
74116: EQUAL
74117: IFTRUE 74127
74119: LD_INT 9
74121: DOUBLE
74122: EQUAL
74123: IFTRUE 74127
74125: GO 74173
74127: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
74128: LD_ADDR_VAR 0 8
74132: PUSH
74133: LD_VAR 0 2
74137: PPUSH
74138: LD_INT 2
74140: PUSH
74141: LD_INT 30
74143: PUSH
74144: LD_INT 4
74146: PUSH
74147: EMPTY
74148: LIST
74149: LIST
74150: PUSH
74151: LD_INT 30
74153: PUSH
74154: LD_INT 5
74156: PUSH
74157: EMPTY
74158: LIST
74159: LIST
74160: PUSH
74161: EMPTY
74162: LIST
74163: LIST
74164: LIST
74165: PPUSH
74166: CALL_OW 72
74170: ST_TO_ADDR
74171: GO 74174
74173: POP
// if not tmp then
74174: LD_VAR 0 8
74178: NOT
74179: IFFALSE 74183
// exit ;
74181: GO 74685
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
74183: LD_VAR 0 4
74187: PUSH
74188: LD_INT 1
74190: PUSH
74191: LD_INT 15
74193: PUSH
74194: EMPTY
74195: LIST
74196: LIST
74197: IN
74198: PUSH
74199: LD_EXP 32
74203: PUSH
74204: LD_VAR 0 1
74208: ARRAY
74209: AND
74210: IFFALSE 74366
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
74212: LD_ADDR_VAR 0 9
74216: PUSH
74217: LD_EXP 32
74221: PUSH
74222: LD_VAR 0 1
74226: ARRAY
74227: PUSH
74228: LD_INT 1
74230: ARRAY
74231: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
74232: LD_VAR 0 9
74236: PUSH
74237: LD_EXP 33
74241: PUSH
74242: LD_VAR 0 1
74246: ARRAY
74247: IN
74248: NOT
74249: IFFALSE 74364
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
74251: LD_ADDR_EXP 33
74255: PUSH
74256: LD_EXP 33
74260: PPUSH
74261: LD_VAR 0 1
74265: PUSH
74266: LD_EXP 33
74270: PUSH
74271: LD_VAR 0 1
74275: ARRAY
74276: PUSH
74277: LD_INT 1
74279: PLUS
74280: PUSH
74281: EMPTY
74282: LIST
74283: LIST
74284: PPUSH
74285: LD_VAR 0 9
74289: PPUSH
74290: CALL 15990 0 3
74294: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
74295: LD_ADDR_EXP 32
74299: PUSH
74300: LD_EXP 32
74304: PPUSH
74305: LD_VAR 0 1
74309: PPUSH
74310: LD_EXP 32
74314: PUSH
74315: LD_VAR 0 1
74319: ARRAY
74320: PUSH
74321: LD_VAR 0 9
74325: DIFF
74326: PPUSH
74327: CALL_OW 1
74331: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
74332: LD_VAR 0 3
74336: PPUSH
74337: LD_EXP 33
74341: PUSH
74342: LD_VAR 0 1
74346: ARRAY
74347: PUSH
74348: LD_EXP 33
74352: PUSH
74353: LD_VAR 0 1
74357: ARRAY
74358: ARRAY
74359: PPUSH
74360: CALL_OW 120
// end ; exit ;
74364: GO 74685
// end ; if tmp > 1 then
74366: LD_VAR 0 8
74370: PUSH
74371: LD_INT 1
74373: GREATER
74374: IFFALSE 74478
// for i = 2 to tmp do
74376: LD_ADDR_VAR 0 6
74380: PUSH
74381: DOUBLE
74382: LD_INT 2
74384: DEC
74385: ST_TO_ADDR
74386: LD_VAR 0 8
74390: PUSH
74391: FOR_TO
74392: IFFALSE 74476
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
74394: LD_VAR 0 8
74398: PUSH
74399: LD_VAR 0 6
74403: ARRAY
74404: PPUSH
74405: CALL_OW 461
74409: PUSH
74410: LD_INT 6
74412: EQUAL
74413: IFFALSE 74474
// begin x := tmp [ i ] ;
74415: LD_ADDR_VAR 0 9
74419: PUSH
74420: LD_VAR 0 8
74424: PUSH
74425: LD_VAR 0 6
74429: ARRAY
74430: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
74431: LD_ADDR_VAR 0 8
74435: PUSH
74436: LD_VAR 0 8
74440: PPUSH
74441: LD_VAR 0 6
74445: PPUSH
74446: CALL_OW 3
74450: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
74451: LD_ADDR_VAR 0 8
74455: PUSH
74456: LD_VAR 0 8
74460: PPUSH
74461: LD_INT 1
74463: PPUSH
74464: LD_VAR 0 9
74468: PPUSH
74469: CALL_OW 2
74473: ST_TO_ADDR
// end ;
74474: GO 74391
74476: POP
74477: POP
// for i in tmp do
74478: LD_ADDR_VAR 0 6
74482: PUSH
74483: LD_VAR 0 8
74487: PUSH
74488: FOR_IN
74489: IFFALSE 74558
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
74491: LD_VAR 0 6
74495: PPUSH
74496: CALL_OW 313
74500: PUSH
74501: LD_INT 6
74503: LESS
74504: PUSH
74505: LD_VAR 0 6
74509: PPUSH
74510: CALL_OW 266
74514: PUSH
74515: LD_INT 31
74517: PUSH
74518: LD_INT 32
74520: PUSH
74521: EMPTY
74522: LIST
74523: LIST
74524: IN
74525: NOT
74526: AND
74527: PUSH
74528: LD_VAR 0 6
74532: PPUSH
74533: CALL_OW 313
74537: PUSH
74538: LD_INT 0
74540: EQUAL
74541: OR
74542: IFFALSE 74556
// begin j := i ;
74544: LD_ADDR_VAR 0 7
74548: PUSH
74549: LD_VAR 0 6
74553: ST_TO_ADDR
// break ;
74554: GO 74558
// end ; end ;
74556: GO 74488
74558: POP
74559: POP
// if j then
74560: LD_VAR 0 7
74564: IFFALSE 74582
// ComEnterUnit ( unit , j ) else
74566: LD_VAR 0 3
74570: PPUSH
74571: LD_VAR 0 7
74575: PPUSH
74576: CALL_OW 120
74580: GO 74685
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74582: LD_ADDR_VAR 0 10
74586: PUSH
74587: LD_VAR 0 2
74591: PPUSH
74592: LD_INT 2
74594: PUSH
74595: LD_INT 30
74597: PUSH
74598: LD_INT 0
74600: PUSH
74601: EMPTY
74602: LIST
74603: LIST
74604: PUSH
74605: LD_INT 30
74607: PUSH
74608: LD_INT 1
74610: PUSH
74611: EMPTY
74612: LIST
74613: LIST
74614: PUSH
74615: EMPTY
74616: LIST
74617: LIST
74618: LIST
74619: PPUSH
74620: CALL_OW 72
74624: ST_TO_ADDR
// if depot then
74625: LD_VAR 0 10
74629: IFFALSE 74685
// begin depot := NearestUnitToUnit ( depot , unit ) ;
74631: LD_ADDR_VAR 0 10
74635: PUSH
74636: LD_VAR 0 10
74640: PPUSH
74641: LD_VAR 0 3
74645: PPUSH
74646: CALL_OW 74
74650: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
74651: LD_VAR 0 3
74655: PPUSH
74656: LD_VAR 0 10
74660: PPUSH
74661: CALL_OW 296
74665: PUSH
74666: LD_INT 10
74668: GREATER
74669: IFFALSE 74685
// ComStandNearbyBuilding ( unit , depot ) ;
74671: LD_VAR 0 3
74675: PPUSH
74676: LD_VAR 0 10
74680: PPUSH
74681: CALL 12568 0 2
// end ; end ; end ;
74685: LD_VAR 0 5
74689: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
74690: LD_INT 0
74692: PPUSH
74693: PPUSH
74694: PPUSH
74695: PPUSH
// if not mc_bases then
74696: LD_EXP 23
74700: NOT
74701: IFFALSE 74705
// exit ;
74703: GO 74944
// for i = 1 to mc_bases do
74705: LD_ADDR_VAR 0 2
74709: PUSH
74710: DOUBLE
74711: LD_INT 1
74713: DEC
74714: ST_TO_ADDR
74715: LD_EXP 23
74719: PUSH
74720: FOR_TO
74721: IFFALSE 74942
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
74723: LD_ADDR_VAR 0 4
74727: PUSH
74728: LD_EXP 23
74732: PUSH
74733: LD_VAR 0 2
74737: ARRAY
74738: PPUSH
74739: LD_INT 21
74741: PUSH
74742: LD_INT 1
74744: PUSH
74745: EMPTY
74746: LIST
74747: LIST
74748: PPUSH
74749: CALL_OW 72
74753: PUSH
74754: LD_EXP 52
74758: PUSH
74759: LD_VAR 0 2
74763: ARRAY
74764: UNION
74765: ST_TO_ADDR
// if not tmp then
74766: LD_VAR 0 4
74770: NOT
74771: IFFALSE 74775
// continue ;
74773: GO 74720
// for j in tmp do
74775: LD_ADDR_VAR 0 3
74779: PUSH
74780: LD_VAR 0 4
74784: PUSH
74785: FOR_IN
74786: IFFALSE 74938
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
74788: LD_VAR 0 3
74792: PPUSH
74793: CALL_OW 110
74797: NOT
74798: PUSH
74799: LD_VAR 0 3
74803: PPUSH
74804: CALL_OW 314
74808: NOT
74809: AND
74810: PUSH
74811: LD_VAR 0 3
74815: PPUSH
74816: CALL_OW 311
74820: NOT
74821: AND
74822: PUSH
74823: LD_VAR 0 3
74827: PPUSH
74828: CALL_OW 310
74832: NOT
74833: AND
74834: PUSH
74835: LD_VAR 0 3
74839: PUSH
74840: LD_EXP 26
74844: PUSH
74845: LD_VAR 0 2
74849: ARRAY
74850: PUSH
74851: LD_INT 1
74853: ARRAY
74854: IN
74855: NOT
74856: AND
74857: PUSH
74858: LD_VAR 0 3
74862: PUSH
74863: LD_EXP 26
74867: PUSH
74868: LD_VAR 0 2
74872: ARRAY
74873: PUSH
74874: LD_INT 2
74876: ARRAY
74877: IN
74878: NOT
74879: AND
74880: PUSH
74881: LD_VAR 0 3
74885: PUSH
74886: LD_EXP 35
74890: PUSH
74891: LD_VAR 0 2
74895: ARRAY
74896: IN
74897: NOT
74898: AND
74899: IFFALSE 74936
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
74901: LD_VAR 0 2
74905: PPUSH
74906: LD_EXP 23
74910: PUSH
74911: LD_VAR 0 2
74915: ARRAY
74916: PPUSH
74917: LD_VAR 0 3
74921: PPUSH
74922: LD_VAR 0 3
74926: PPUSH
74927: CALL_OW 257
74931: PPUSH
74932: CALL 73708 0 4
// end ;
74936: GO 74785
74938: POP
74939: POP
// end ;
74940: GO 74720
74942: POP
74943: POP
// end ;
74944: LD_VAR 0 1
74948: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
74949: LD_INT 0
74951: PPUSH
74952: PPUSH
74953: PPUSH
74954: PPUSH
74955: PPUSH
74956: PPUSH
// if not mc_bases [ base ] then
74957: LD_EXP 23
74961: PUSH
74962: LD_VAR 0 1
74966: ARRAY
74967: NOT
74968: IFFALSE 74972
// exit ;
74970: GO 75154
// tmp := [ ] ;
74972: LD_ADDR_VAR 0 6
74976: PUSH
74977: EMPTY
74978: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
74979: LD_ADDR_VAR 0 7
74983: PUSH
74984: LD_VAR 0 3
74988: PPUSH
74989: LD_INT 0
74991: PPUSH
74992: CALL_OW 517
74996: ST_TO_ADDR
// if not list then
74997: LD_VAR 0 7
75001: NOT
75002: IFFALSE 75006
// exit ;
75004: GO 75154
// for i = 1 to amount do
75006: LD_ADDR_VAR 0 5
75010: PUSH
75011: DOUBLE
75012: LD_INT 1
75014: DEC
75015: ST_TO_ADDR
75016: LD_VAR 0 2
75020: PUSH
75021: FOR_TO
75022: IFFALSE 75102
// begin x := rand ( 1 , list [ 1 ] ) ;
75024: LD_ADDR_VAR 0 8
75028: PUSH
75029: LD_INT 1
75031: PPUSH
75032: LD_VAR 0 7
75036: PUSH
75037: LD_INT 1
75039: ARRAY
75040: PPUSH
75041: CALL_OW 12
75045: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
75046: LD_ADDR_VAR 0 6
75050: PUSH
75051: LD_VAR 0 6
75055: PPUSH
75056: LD_VAR 0 5
75060: PPUSH
75061: LD_VAR 0 7
75065: PUSH
75066: LD_INT 1
75068: ARRAY
75069: PUSH
75070: LD_VAR 0 8
75074: ARRAY
75075: PUSH
75076: LD_VAR 0 7
75080: PUSH
75081: LD_INT 2
75083: ARRAY
75084: PUSH
75085: LD_VAR 0 8
75089: ARRAY
75090: PUSH
75091: EMPTY
75092: LIST
75093: LIST
75094: PPUSH
75095: CALL_OW 1
75099: ST_TO_ADDR
// end ;
75100: GO 75021
75102: POP
75103: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
75104: LD_ADDR_EXP 36
75108: PUSH
75109: LD_EXP 36
75113: PPUSH
75114: LD_VAR 0 1
75118: PPUSH
75119: LD_VAR 0 6
75123: PPUSH
75124: CALL_OW 1
75128: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
75129: LD_ADDR_EXP 38
75133: PUSH
75134: LD_EXP 38
75138: PPUSH
75139: LD_VAR 0 1
75143: PPUSH
75144: LD_VAR 0 3
75148: PPUSH
75149: CALL_OW 1
75153: ST_TO_ADDR
// end ;
75154: LD_VAR 0 4
75158: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
75159: LD_INT 0
75161: PPUSH
// if not mc_bases [ base ] then
75162: LD_EXP 23
75166: PUSH
75167: LD_VAR 0 1
75171: ARRAY
75172: NOT
75173: IFFALSE 75177
// exit ;
75175: GO 75202
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
75177: LD_ADDR_EXP 28
75181: PUSH
75182: LD_EXP 28
75186: PPUSH
75187: LD_VAR 0 1
75191: PPUSH
75192: LD_VAR 0 2
75196: PPUSH
75197: CALL_OW 1
75201: ST_TO_ADDR
// end ;
75202: LD_VAR 0 3
75206: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
75207: LD_INT 0
75209: PPUSH
// if not mc_bases [ base ] then
75210: LD_EXP 23
75214: PUSH
75215: LD_VAR 0 1
75219: ARRAY
75220: NOT
75221: IFFALSE 75225
// exit ;
75223: GO 75262
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
75225: LD_ADDR_EXP 28
75229: PUSH
75230: LD_EXP 28
75234: PPUSH
75235: LD_VAR 0 1
75239: PPUSH
75240: LD_EXP 28
75244: PUSH
75245: LD_VAR 0 1
75249: ARRAY
75250: PUSH
75251: LD_VAR 0 2
75255: UNION
75256: PPUSH
75257: CALL_OW 1
75261: ST_TO_ADDR
// end ;
75262: LD_VAR 0 3
75266: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
75267: LD_INT 0
75269: PPUSH
// if not mc_bases [ base ] then
75270: LD_EXP 23
75274: PUSH
75275: LD_VAR 0 1
75279: ARRAY
75280: NOT
75281: IFFALSE 75285
// exit ;
75283: GO 75310
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
75285: LD_ADDR_EXP 44
75289: PUSH
75290: LD_EXP 44
75294: PPUSH
75295: LD_VAR 0 1
75299: PPUSH
75300: LD_VAR 0 2
75304: PPUSH
75305: CALL_OW 1
75309: ST_TO_ADDR
// end ;
75310: LD_VAR 0 3
75314: RET
// export function MC_InsertProduceList ( base , components ) ; begin
75315: LD_INT 0
75317: PPUSH
// if not mc_bases [ base ] then
75318: LD_EXP 23
75322: PUSH
75323: LD_VAR 0 1
75327: ARRAY
75328: NOT
75329: IFFALSE 75333
// exit ;
75331: GO 75370
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
75333: LD_ADDR_EXP 44
75337: PUSH
75338: LD_EXP 44
75342: PPUSH
75343: LD_VAR 0 1
75347: PPUSH
75348: LD_EXP 44
75352: PUSH
75353: LD_VAR 0 1
75357: ARRAY
75358: PUSH
75359: LD_VAR 0 2
75363: ADD
75364: PPUSH
75365: CALL_OW 1
75369: ST_TO_ADDR
// end ;
75370: LD_VAR 0 3
75374: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
75375: LD_INT 0
75377: PPUSH
// if not mc_bases [ base ] then
75378: LD_EXP 23
75382: PUSH
75383: LD_VAR 0 1
75387: ARRAY
75388: NOT
75389: IFFALSE 75393
// exit ;
75391: GO 75447
// mc_defender := Replace ( mc_defender , base , deflist ) ;
75393: LD_ADDR_EXP 45
75397: PUSH
75398: LD_EXP 45
75402: PPUSH
75403: LD_VAR 0 1
75407: PPUSH
75408: LD_VAR 0 2
75412: PPUSH
75413: CALL_OW 1
75417: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
75418: LD_ADDR_EXP 34
75422: PUSH
75423: LD_EXP 34
75427: PPUSH
75428: LD_VAR 0 1
75432: PPUSH
75433: LD_VAR 0 2
75437: PUSH
75438: LD_INT 0
75440: PLUS
75441: PPUSH
75442: CALL_OW 1
75446: ST_TO_ADDR
// end ;
75447: LD_VAR 0 3
75451: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
75452: LD_INT 0
75454: PPUSH
// if not mc_bases [ base ] then
75455: LD_EXP 23
75459: PUSH
75460: LD_VAR 0 1
75464: ARRAY
75465: NOT
75466: IFFALSE 75470
// exit ;
75468: GO 75495
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
75470: LD_ADDR_EXP 34
75474: PUSH
75475: LD_EXP 34
75479: PPUSH
75480: LD_VAR 0 1
75484: PPUSH
75485: LD_VAR 0 2
75489: PPUSH
75490: CALL_OW 1
75494: ST_TO_ADDR
// end ;
75495: LD_VAR 0 3
75499: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
75500: LD_INT 0
75502: PPUSH
75503: PPUSH
75504: PPUSH
75505: PPUSH
// if not mc_bases [ base ] then
75506: LD_EXP 23
75510: PUSH
75511: LD_VAR 0 1
75515: ARRAY
75516: NOT
75517: IFFALSE 75521
// exit ;
75519: GO 75586
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
75521: LD_ADDR_EXP 43
75525: PUSH
75526: LD_EXP 43
75530: PPUSH
75531: LD_VAR 0 1
75535: PUSH
75536: LD_EXP 43
75540: PUSH
75541: LD_VAR 0 1
75545: ARRAY
75546: PUSH
75547: LD_INT 1
75549: PLUS
75550: PUSH
75551: EMPTY
75552: LIST
75553: LIST
75554: PPUSH
75555: LD_VAR 0 1
75559: PUSH
75560: LD_VAR 0 2
75564: PUSH
75565: LD_VAR 0 3
75569: PUSH
75570: LD_VAR 0 4
75574: PUSH
75575: EMPTY
75576: LIST
75577: LIST
75578: LIST
75579: LIST
75580: PPUSH
75581: CALL 15990 0 3
75585: ST_TO_ADDR
// end ;
75586: LD_VAR 0 5
75590: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
75591: LD_INT 0
75593: PPUSH
// if not mc_bases [ base ] then
75594: LD_EXP 23
75598: PUSH
75599: LD_VAR 0 1
75603: ARRAY
75604: NOT
75605: IFFALSE 75609
// exit ;
75607: GO 75634
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
75609: LD_ADDR_EXP 60
75613: PUSH
75614: LD_EXP 60
75618: PPUSH
75619: LD_VAR 0 1
75623: PPUSH
75624: LD_VAR 0 2
75628: PPUSH
75629: CALL_OW 1
75633: ST_TO_ADDR
// end ;
75634: LD_VAR 0 3
75638: RET
// export function MC_GetMinesField ( base ) ; begin
75639: LD_INT 0
75641: PPUSH
// result := mc_mines [ base ] ;
75642: LD_ADDR_VAR 0 2
75646: PUSH
75647: LD_EXP 36
75651: PUSH
75652: LD_VAR 0 1
75656: ARRAY
75657: ST_TO_ADDR
// end ;
75658: LD_VAR 0 2
75662: RET
// export function MC_GetProduceList ( base ) ; begin
75663: LD_INT 0
75665: PPUSH
// result := mc_produce [ base ] ;
75666: LD_ADDR_VAR 0 2
75670: PUSH
75671: LD_EXP 44
75675: PUSH
75676: LD_VAR 0 1
75680: ARRAY
75681: ST_TO_ADDR
// end ;
75682: LD_VAR 0 2
75686: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
75687: LD_INT 0
75689: PPUSH
75690: PPUSH
// if not mc_bases then
75691: LD_EXP 23
75695: NOT
75696: IFFALSE 75700
// exit ;
75698: GO 75765
// if mc_bases [ base ] then
75700: LD_EXP 23
75704: PUSH
75705: LD_VAR 0 1
75709: ARRAY
75710: IFFALSE 75765
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
75712: LD_ADDR_VAR 0 3
75716: PUSH
75717: LD_EXP 23
75721: PUSH
75722: LD_VAR 0 1
75726: ARRAY
75727: PPUSH
75728: LD_INT 30
75730: PUSH
75731: LD_VAR 0 2
75735: PUSH
75736: EMPTY
75737: LIST
75738: LIST
75739: PPUSH
75740: CALL_OW 72
75744: ST_TO_ADDR
// if result then
75745: LD_VAR 0 3
75749: IFFALSE 75765
// result := result [ 1 ] ;
75751: LD_ADDR_VAR 0 3
75755: PUSH
75756: LD_VAR 0 3
75760: PUSH
75761: LD_INT 1
75763: ARRAY
75764: ST_TO_ADDR
// end ; end ;
75765: LD_VAR 0 3
75769: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
75770: LD_INT 0
75772: PPUSH
75773: PPUSH
// if not mc_bases then
75774: LD_EXP 23
75778: NOT
75779: IFFALSE 75783
// exit ;
75781: GO 75828
// if mc_bases [ base ] then
75783: LD_EXP 23
75787: PUSH
75788: LD_VAR 0 1
75792: ARRAY
75793: IFFALSE 75828
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
75795: LD_ADDR_VAR 0 3
75799: PUSH
75800: LD_EXP 23
75804: PUSH
75805: LD_VAR 0 1
75809: ARRAY
75810: PPUSH
75811: LD_INT 30
75813: PUSH
75814: LD_VAR 0 2
75818: PUSH
75819: EMPTY
75820: LIST
75821: LIST
75822: PPUSH
75823: CALL_OW 72
75827: ST_TO_ADDR
// end ;
75828: LD_VAR 0 3
75832: RET
// export function MC_SetTame ( base , area ) ; begin
75833: LD_INT 0
75835: PPUSH
// if not mc_bases or not base then
75836: LD_EXP 23
75840: NOT
75841: PUSH
75842: LD_VAR 0 1
75846: NOT
75847: OR
75848: IFFALSE 75852
// exit ;
75850: GO 75877
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
75852: LD_ADDR_EXP 51
75856: PUSH
75857: LD_EXP 51
75861: PPUSH
75862: LD_VAR 0 1
75866: PPUSH
75867: LD_VAR 0 2
75871: PPUSH
75872: CALL_OW 1
75876: ST_TO_ADDR
// end ;
75877: LD_VAR 0 3
75881: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
75882: LD_INT 0
75884: PPUSH
75885: PPUSH
// if not mc_bases or not base then
75886: LD_EXP 23
75890: NOT
75891: PUSH
75892: LD_VAR 0 1
75896: NOT
75897: OR
75898: IFFALSE 75902
// exit ;
75900: GO 76004
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
75902: LD_ADDR_VAR 0 4
75906: PUSH
75907: LD_EXP 23
75911: PUSH
75912: LD_VAR 0 1
75916: ARRAY
75917: PPUSH
75918: LD_INT 30
75920: PUSH
75921: LD_VAR 0 2
75925: PUSH
75926: EMPTY
75927: LIST
75928: LIST
75929: PPUSH
75930: CALL_OW 72
75934: ST_TO_ADDR
// if not tmp then
75935: LD_VAR 0 4
75939: NOT
75940: IFFALSE 75944
// exit ;
75942: GO 76004
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
75944: LD_ADDR_EXP 55
75948: PUSH
75949: LD_EXP 55
75953: PPUSH
75954: LD_VAR 0 1
75958: PPUSH
75959: LD_EXP 55
75963: PUSH
75964: LD_VAR 0 1
75968: ARRAY
75969: PPUSH
75970: LD_EXP 55
75974: PUSH
75975: LD_VAR 0 1
75979: ARRAY
75980: PUSH
75981: LD_INT 1
75983: PLUS
75984: PPUSH
75985: LD_VAR 0 4
75989: PUSH
75990: LD_INT 1
75992: ARRAY
75993: PPUSH
75994: CALL_OW 2
75998: PPUSH
75999: CALL_OW 1
76003: ST_TO_ADDR
// end ;
76004: LD_VAR 0 3
76008: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
76009: LD_INT 0
76011: PPUSH
76012: PPUSH
// if not mc_bases or not base or not kinds then
76013: LD_EXP 23
76017: NOT
76018: PUSH
76019: LD_VAR 0 1
76023: NOT
76024: OR
76025: PUSH
76026: LD_VAR 0 2
76030: NOT
76031: OR
76032: IFFALSE 76036
// exit ;
76034: GO 76097
// for i in kinds do
76036: LD_ADDR_VAR 0 4
76040: PUSH
76041: LD_VAR 0 2
76045: PUSH
76046: FOR_IN
76047: IFFALSE 76095
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
76049: LD_ADDR_EXP 57
76053: PUSH
76054: LD_EXP 57
76058: PPUSH
76059: LD_VAR 0 1
76063: PUSH
76064: LD_EXP 57
76068: PUSH
76069: LD_VAR 0 1
76073: ARRAY
76074: PUSH
76075: LD_INT 1
76077: PLUS
76078: PUSH
76079: EMPTY
76080: LIST
76081: LIST
76082: PPUSH
76083: LD_VAR 0 4
76087: PPUSH
76088: CALL 15990 0 3
76092: ST_TO_ADDR
76093: GO 76046
76095: POP
76096: POP
// end ;
76097: LD_VAR 0 3
76101: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
76102: LD_INT 0
76104: PPUSH
// if not mc_bases or not base or not areas then
76105: LD_EXP 23
76109: NOT
76110: PUSH
76111: LD_VAR 0 1
76115: NOT
76116: OR
76117: PUSH
76118: LD_VAR 0 2
76122: NOT
76123: OR
76124: IFFALSE 76128
// exit ;
76126: GO 76153
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
76128: LD_ADDR_EXP 41
76132: PUSH
76133: LD_EXP 41
76137: PPUSH
76138: LD_VAR 0 1
76142: PPUSH
76143: LD_VAR 0 2
76147: PPUSH
76148: CALL_OW 1
76152: ST_TO_ADDR
// end ;
76153: LD_VAR 0 3
76157: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
76158: LD_INT 0
76160: PPUSH
// if not mc_bases or not base or not teleports_exit then
76161: LD_EXP 23
76165: NOT
76166: PUSH
76167: LD_VAR 0 1
76171: NOT
76172: OR
76173: PUSH
76174: LD_VAR 0 2
76178: NOT
76179: OR
76180: IFFALSE 76184
// exit ;
76182: GO 76209
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
76184: LD_ADDR_EXP 58
76188: PUSH
76189: LD_EXP 58
76193: PPUSH
76194: LD_VAR 0 1
76198: PPUSH
76199: LD_VAR 0 2
76203: PPUSH
76204: CALL_OW 1
76208: ST_TO_ADDR
// end ;
76209: LD_VAR 0 3
76213: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
76214: LD_INT 0
76216: PPUSH
76217: PPUSH
76218: PPUSH
// if not mc_bases or not base or not ext_list then
76219: LD_EXP 23
76223: NOT
76224: PUSH
76225: LD_VAR 0 1
76229: NOT
76230: OR
76231: PUSH
76232: LD_VAR 0 5
76236: NOT
76237: OR
76238: IFFALSE 76242
// exit ;
76240: GO 76415
// tmp := GetFacExtXYD ( x , y , d ) ;
76242: LD_ADDR_VAR 0 8
76246: PUSH
76247: LD_VAR 0 2
76251: PPUSH
76252: LD_VAR 0 3
76256: PPUSH
76257: LD_VAR 0 4
76261: PPUSH
76262: CALL 45377 0 3
76266: ST_TO_ADDR
// if not tmp then
76267: LD_VAR 0 8
76271: NOT
76272: IFFALSE 76276
// exit ;
76274: GO 76415
// for i in tmp do
76276: LD_ADDR_VAR 0 7
76280: PUSH
76281: LD_VAR 0 8
76285: PUSH
76286: FOR_IN
76287: IFFALSE 76413
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
76289: LD_ADDR_EXP 28
76293: PUSH
76294: LD_EXP 28
76298: PPUSH
76299: LD_VAR 0 1
76303: PPUSH
76304: LD_EXP 28
76308: PUSH
76309: LD_VAR 0 1
76313: ARRAY
76314: PPUSH
76315: LD_EXP 28
76319: PUSH
76320: LD_VAR 0 1
76324: ARRAY
76325: PUSH
76326: LD_INT 1
76328: PLUS
76329: PPUSH
76330: LD_VAR 0 5
76334: PUSH
76335: LD_INT 1
76337: ARRAY
76338: PUSH
76339: LD_VAR 0 7
76343: PUSH
76344: LD_INT 1
76346: ARRAY
76347: PUSH
76348: LD_VAR 0 7
76352: PUSH
76353: LD_INT 2
76355: ARRAY
76356: PUSH
76357: LD_VAR 0 7
76361: PUSH
76362: LD_INT 3
76364: ARRAY
76365: PUSH
76366: EMPTY
76367: LIST
76368: LIST
76369: LIST
76370: LIST
76371: PPUSH
76372: CALL_OW 2
76376: PPUSH
76377: CALL_OW 1
76381: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
76382: LD_ADDR_VAR 0 5
76386: PUSH
76387: LD_VAR 0 5
76391: PPUSH
76392: LD_INT 1
76394: PPUSH
76395: CALL_OW 3
76399: ST_TO_ADDR
// if not ext_list then
76400: LD_VAR 0 5
76404: NOT
76405: IFFALSE 76411
// exit ;
76407: POP
76408: POP
76409: GO 76415
// end ;
76411: GO 76286
76413: POP
76414: POP
// end ;
76415: LD_VAR 0 6
76419: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
76420: LD_INT 0
76422: PPUSH
// if not mc_bases or not base or not weapon_list then
76423: LD_EXP 23
76427: NOT
76428: PUSH
76429: LD_VAR 0 1
76433: NOT
76434: OR
76435: PUSH
76436: LD_VAR 0 2
76440: NOT
76441: OR
76442: IFFALSE 76446
// exit ;
76444: GO 76471
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
76446: LD_ADDR_EXP 62
76450: PUSH
76451: LD_EXP 62
76455: PPUSH
76456: LD_VAR 0 1
76460: PPUSH
76461: LD_VAR 0 2
76465: PPUSH
76466: CALL_OW 1
76470: ST_TO_ADDR
// end ;
76471: LD_VAR 0 3
76475: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
76476: LD_INT 0
76478: PPUSH
// if not mc_bases or not base or not tech_list then
76479: LD_EXP 23
76483: NOT
76484: PUSH
76485: LD_VAR 0 1
76489: NOT
76490: OR
76491: PUSH
76492: LD_VAR 0 2
76496: NOT
76497: OR
76498: IFFALSE 76502
// exit ;
76500: GO 76527
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
76502: LD_ADDR_EXP 50
76506: PUSH
76507: LD_EXP 50
76511: PPUSH
76512: LD_VAR 0 1
76516: PPUSH
76517: LD_VAR 0 2
76521: PPUSH
76522: CALL_OW 1
76526: ST_TO_ADDR
// end ;
76527: LD_VAR 0 3
76531: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
76532: LD_INT 0
76534: PPUSH
// if not mc_bases or not parking_area or not base then
76535: LD_EXP 23
76539: NOT
76540: PUSH
76541: LD_VAR 0 2
76545: NOT
76546: OR
76547: PUSH
76548: LD_VAR 0 1
76552: NOT
76553: OR
76554: IFFALSE 76558
// exit ;
76556: GO 76583
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
76558: LD_ADDR_EXP 47
76562: PUSH
76563: LD_EXP 47
76567: PPUSH
76568: LD_VAR 0 1
76572: PPUSH
76573: LD_VAR 0 2
76577: PPUSH
76578: CALL_OW 1
76582: ST_TO_ADDR
// end ;
76583: LD_VAR 0 3
76587: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
76588: LD_INT 0
76590: PPUSH
// if not mc_bases or not base or not scan_area then
76591: LD_EXP 23
76595: NOT
76596: PUSH
76597: LD_VAR 0 1
76601: NOT
76602: OR
76603: PUSH
76604: LD_VAR 0 2
76608: NOT
76609: OR
76610: IFFALSE 76614
// exit ;
76612: GO 76639
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
76614: LD_ADDR_EXP 48
76618: PUSH
76619: LD_EXP 48
76623: PPUSH
76624: LD_VAR 0 1
76628: PPUSH
76629: LD_VAR 0 2
76633: PPUSH
76634: CALL_OW 1
76638: ST_TO_ADDR
// end ;
76639: LD_VAR 0 3
76643: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
76644: LD_INT 0
76646: PPUSH
76647: PPUSH
// if not mc_bases or not base then
76648: LD_EXP 23
76652: NOT
76653: PUSH
76654: LD_VAR 0 1
76658: NOT
76659: OR
76660: IFFALSE 76664
// exit ;
76662: GO 76728
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
76664: LD_ADDR_VAR 0 3
76668: PUSH
76669: LD_INT 1
76671: PUSH
76672: LD_INT 2
76674: PUSH
76675: LD_INT 3
76677: PUSH
76678: LD_INT 4
76680: PUSH
76681: LD_INT 11
76683: PUSH
76684: EMPTY
76685: LIST
76686: LIST
76687: LIST
76688: LIST
76689: LIST
76690: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
76691: LD_ADDR_EXP 50
76695: PUSH
76696: LD_EXP 50
76700: PPUSH
76701: LD_VAR 0 1
76705: PPUSH
76706: LD_EXP 50
76710: PUSH
76711: LD_VAR 0 1
76715: ARRAY
76716: PUSH
76717: LD_VAR 0 3
76721: DIFF
76722: PPUSH
76723: CALL_OW 1
76727: ST_TO_ADDR
// end ;
76728: LD_VAR 0 2
76732: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
76733: LD_INT 0
76735: PPUSH
// result := mc_vehicles [ base ] ;
76736: LD_ADDR_VAR 0 3
76740: PUSH
76741: LD_EXP 42
76745: PUSH
76746: LD_VAR 0 1
76750: ARRAY
76751: ST_TO_ADDR
// if onlyCombat then
76752: LD_VAR 0 2
76756: IFFALSE 76934
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
76758: LD_ADDR_VAR 0 3
76762: PUSH
76763: LD_VAR 0 3
76767: PUSH
76768: LD_VAR 0 3
76772: PPUSH
76773: LD_INT 2
76775: PUSH
76776: LD_INT 34
76778: PUSH
76779: LD_INT 12
76781: PUSH
76782: EMPTY
76783: LIST
76784: LIST
76785: PUSH
76786: LD_INT 34
76788: PUSH
76789: LD_INT 51
76791: PUSH
76792: EMPTY
76793: LIST
76794: LIST
76795: PUSH
76796: LD_INT 34
76798: PUSH
76799: LD_EXP 68
76803: PUSH
76804: EMPTY
76805: LIST
76806: LIST
76807: PUSH
76808: LD_INT 34
76810: PUSH
76811: LD_INT 32
76813: PUSH
76814: EMPTY
76815: LIST
76816: LIST
76817: PUSH
76818: LD_INT 34
76820: PUSH
76821: LD_INT 13
76823: PUSH
76824: EMPTY
76825: LIST
76826: LIST
76827: PUSH
76828: LD_INT 34
76830: PUSH
76831: LD_INT 52
76833: PUSH
76834: EMPTY
76835: LIST
76836: LIST
76837: PUSH
76838: LD_INT 34
76840: PUSH
76841: LD_EXP 73
76845: PUSH
76846: EMPTY
76847: LIST
76848: LIST
76849: PUSH
76850: LD_INT 34
76852: PUSH
76853: LD_INT 14
76855: PUSH
76856: EMPTY
76857: LIST
76858: LIST
76859: PUSH
76860: LD_INT 34
76862: PUSH
76863: LD_INT 53
76865: PUSH
76866: EMPTY
76867: LIST
76868: LIST
76869: PUSH
76870: LD_INT 34
76872: PUSH
76873: LD_EXP 67
76877: PUSH
76878: EMPTY
76879: LIST
76880: LIST
76881: PUSH
76882: LD_INT 34
76884: PUSH
76885: LD_INT 31
76887: PUSH
76888: EMPTY
76889: LIST
76890: LIST
76891: PUSH
76892: LD_INT 34
76894: PUSH
76895: LD_INT 48
76897: PUSH
76898: EMPTY
76899: LIST
76900: LIST
76901: PUSH
76902: LD_INT 34
76904: PUSH
76905: LD_INT 8
76907: PUSH
76908: EMPTY
76909: LIST
76910: LIST
76911: PUSH
76912: EMPTY
76913: LIST
76914: LIST
76915: LIST
76916: LIST
76917: LIST
76918: LIST
76919: LIST
76920: LIST
76921: LIST
76922: LIST
76923: LIST
76924: LIST
76925: LIST
76926: LIST
76927: PPUSH
76928: CALL_OW 72
76932: DIFF
76933: ST_TO_ADDR
// end ; end_of_file
76934: LD_VAR 0 3
76938: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
76939: LD_INT 0
76941: PPUSH
76942: PPUSH
76943: PPUSH
// if not mc_bases or not skirmish then
76944: LD_EXP 23
76948: NOT
76949: PUSH
76950: LD_EXP 21
76954: NOT
76955: OR
76956: IFFALSE 76960
// exit ;
76958: GO 77125
// for i = 1 to mc_bases do
76960: LD_ADDR_VAR 0 4
76964: PUSH
76965: DOUBLE
76966: LD_INT 1
76968: DEC
76969: ST_TO_ADDR
76970: LD_EXP 23
76974: PUSH
76975: FOR_TO
76976: IFFALSE 77123
// begin if sci in mc_bases [ i ] then
76978: LD_VAR 0 2
76982: PUSH
76983: LD_EXP 23
76987: PUSH
76988: LD_VAR 0 4
76992: ARRAY
76993: IN
76994: IFFALSE 77121
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
76996: LD_ADDR_EXP 52
77000: PUSH
77001: LD_EXP 52
77005: PPUSH
77006: LD_VAR 0 4
77010: PUSH
77011: LD_EXP 52
77015: PUSH
77016: LD_VAR 0 4
77020: ARRAY
77021: PUSH
77022: LD_INT 1
77024: PLUS
77025: PUSH
77026: EMPTY
77027: LIST
77028: LIST
77029: PPUSH
77030: LD_VAR 0 1
77034: PPUSH
77035: CALL 15990 0 3
77039: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
77040: LD_ADDR_VAR 0 5
77044: PUSH
77045: LD_EXP 23
77049: PUSH
77050: LD_VAR 0 4
77054: ARRAY
77055: PPUSH
77056: LD_INT 2
77058: PUSH
77059: LD_INT 30
77061: PUSH
77062: LD_INT 0
77064: PUSH
77065: EMPTY
77066: LIST
77067: LIST
77068: PUSH
77069: LD_INT 30
77071: PUSH
77072: LD_INT 1
77074: PUSH
77075: EMPTY
77076: LIST
77077: LIST
77078: PUSH
77079: EMPTY
77080: LIST
77081: LIST
77082: LIST
77083: PPUSH
77084: CALL_OW 72
77088: PPUSH
77089: LD_VAR 0 1
77093: PPUSH
77094: CALL_OW 74
77098: ST_TO_ADDR
// if tmp then
77099: LD_VAR 0 5
77103: IFFALSE 77119
// ComStandNearbyBuilding ( ape , tmp ) ;
77105: LD_VAR 0 1
77109: PPUSH
77110: LD_VAR 0 5
77114: PPUSH
77115: CALL 12568 0 2
// break ;
77119: GO 77123
// end ; end ;
77121: GO 76975
77123: POP
77124: POP
// end ;
77125: LD_VAR 0 3
77129: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
77130: LD_INT 0
77132: PPUSH
77133: PPUSH
77134: PPUSH
// if not mc_bases or not skirmish then
77135: LD_EXP 23
77139: NOT
77140: PUSH
77141: LD_EXP 21
77145: NOT
77146: OR
77147: IFFALSE 77151
// exit ;
77149: GO 77240
// for i = 1 to mc_bases do
77151: LD_ADDR_VAR 0 4
77155: PUSH
77156: DOUBLE
77157: LD_INT 1
77159: DEC
77160: ST_TO_ADDR
77161: LD_EXP 23
77165: PUSH
77166: FOR_TO
77167: IFFALSE 77238
// begin if building in mc_busy_turret_list [ i ] then
77169: LD_VAR 0 1
77173: PUSH
77174: LD_EXP 33
77178: PUSH
77179: LD_VAR 0 4
77183: ARRAY
77184: IN
77185: IFFALSE 77236
// begin tmp := mc_busy_turret_list [ i ] diff building ;
77187: LD_ADDR_VAR 0 5
77191: PUSH
77192: LD_EXP 33
77196: PUSH
77197: LD_VAR 0 4
77201: ARRAY
77202: PUSH
77203: LD_VAR 0 1
77207: DIFF
77208: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
77209: LD_ADDR_EXP 33
77213: PUSH
77214: LD_EXP 33
77218: PPUSH
77219: LD_VAR 0 4
77223: PPUSH
77224: LD_VAR 0 5
77228: PPUSH
77229: CALL_OW 1
77233: ST_TO_ADDR
// break ;
77234: GO 77238
// end ; end ;
77236: GO 77166
77238: POP
77239: POP
// end ;
77240: LD_VAR 0 3
77244: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
77245: LD_INT 0
77247: PPUSH
77248: PPUSH
77249: PPUSH
// if not mc_bases or not skirmish then
77250: LD_EXP 23
77254: NOT
77255: PUSH
77256: LD_EXP 21
77260: NOT
77261: OR
77262: IFFALSE 77266
// exit ;
77264: GO 77465
// for i = 1 to mc_bases do
77266: LD_ADDR_VAR 0 5
77270: PUSH
77271: DOUBLE
77272: LD_INT 1
77274: DEC
77275: ST_TO_ADDR
77276: LD_EXP 23
77280: PUSH
77281: FOR_TO
77282: IFFALSE 77463
// if building in mc_bases [ i ] then
77284: LD_VAR 0 1
77288: PUSH
77289: LD_EXP 23
77293: PUSH
77294: LD_VAR 0 5
77298: ARRAY
77299: IN
77300: IFFALSE 77461
// begin tmp := mc_bases [ i ] diff building ;
77302: LD_ADDR_VAR 0 6
77306: PUSH
77307: LD_EXP 23
77311: PUSH
77312: LD_VAR 0 5
77316: ARRAY
77317: PUSH
77318: LD_VAR 0 1
77322: DIFF
77323: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
77324: LD_ADDR_EXP 23
77328: PUSH
77329: LD_EXP 23
77333: PPUSH
77334: LD_VAR 0 5
77338: PPUSH
77339: LD_VAR 0 6
77343: PPUSH
77344: CALL_OW 1
77348: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
77349: LD_VAR 0 1
77353: PUSH
77354: LD_EXP 31
77358: PUSH
77359: LD_VAR 0 5
77363: ARRAY
77364: IN
77365: IFFALSE 77404
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
77367: LD_ADDR_EXP 31
77371: PUSH
77372: LD_EXP 31
77376: PPUSH
77377: LD_VAR 0 5
77381: PPUSH
77382: LD_EXP 31
77386: PUSH
77387: LD_VAR 0 5
77391: ARRAY
77392: PUSH
77393: LD_VAR 0 1
77397: DIFF
77398: PPUSH
77399: CALL_OW 1
77403: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
77404: LD_VAR 0 1
77408: PUSH
77409: LD_EXP 32
77413: PUSH
77414: LD_VAR 0 5
77418: ARRAY
77419: IN
77420: IFFALSE 77459
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
77422: LD_ADDR_EXP 32
77426: PUSH
77427: LD_EXP 32
77431: PPUSH
77432: LD_VAR 0 5
77436: PPUSH
77437: LD_EXP 32
77441: PUSH
77442: LD_VAR 0 5
77446: ARRAY
77447: PUSH
77448: LD_VAR 0 1
77452: DIFF
77453: PPUSH
77454: CALL_OW 1
77458: ST_TO_ADDR
// break ;
77459: GO 77463
// end ;
77461: GO 77281
77463: POP
77464: POP
// end ;
77465: LD_VAR 0 4
77469: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
77470: LD_INT 0
77472: PPUSH
77473: PPUSH
77474: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
77475: LD_EXP 23
77479: NOT
77480: PUSH
77481: LD_EXP 21
77485: NOT
77486: OR
77487: PUSH
77488: LD_VAR 0 3
77492: PUSH
77493: LD_EXP 49
77497: IN
77498: NOT
77499: OR
77500: IFFALSE 77504
// exit ;
77502: GO 77627
// for i = 1 to mc_vehicles do
77504: LD_ADDR_VAR 0 6
77508: PUSH
77509: DOUBLE
77510: LD_INT 1
77512: DEC
77513: ST_TO_ADDR
77514: LD_EXP 42
77518: PUSH
77519: FOR_TO
77520: IFFALSE 77625
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
77522: LD_VAR 0 2
77526: PUSH
77527: LD_EXP 42
77531: PUSH
77532: LD_VAR 0 6
77536: ARRAY
77537: IN
77538: PUSH
77539: LD_VAR 0 1
77543: PUSH
77544: LD_EXP 42
77548: PUSH
77549: LD_VAR 0 6
77553: ARRAY
77554: IN
77555: OR
77556: IFFALSE 77623
// begin tmp := mc_vehicles [ i ] diff old ;
77558: LD_ADDR_VAR 0 7
77562: PUSH
77563: LD_EXP 42
77567: PUSH
77568: LD_VAR 0 6
77572: ARRAY
77573: PUSH
77574: LD_VAR 0 2
77578: DIFF
77579: ST_TO_ADDR
// tmp := tmp diff new ;
77580: LD_ADDR_VAR 0 7
77584: PUSH
77585: LD_VAR 0 7
77589: PUSH
77590: LD_VAR 0 1
77594: DIFF
77595: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
77596: LD_ADDR_EXP 42
77600: PUSH
77601: LD_EXP 42
77605: PPUSH
77606: LD_VAR 0 6
77610: PPUSH
77611: LD_VAR 0 7
77615: PPUSH
77616: CALL_OW 1
77620: ST_TO_ADDR
// break ;
77621: GO 77625
// end ;
77623: GO 77519
77625: POP
77626: POP
// end ;
77627: LD_VAR 0 5
77631: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
77632: LD_INT 0
77634: PPUSH
77635: PPUSH
77636: PPUSH
77637: PPUSH
// if not mc_bases or not skirmish then
77638: LD_EXP 23
77642: NOT
77643: PUSH
77644: LD_EXP 21
77648: NOT
77649: OR
77650: IFFALSE 77654
// exit ;
77652: GO 78046
// side := GetSide ( vehicle ) ;
77654: LD_ADDR_VAR 0 5
77658: PUSH
77659: LD_VAR 0 1
77663: PPUSH
77664: CALL_OW 255
77668: ST_TO_ADDR
// for i = 1 to mc_bases do
77669: LD_ADDR_VAR 0 4
77673: PUSH
77674: DOUBLE
77675: LD_INT 1
77677: DEC
77678: ST_TO_ADDR
77679: LD_EXP 23
77683: PUSH
77684: FOR_TO
77685: IFFALSE 78044
// begin if factory in mc_bases [ i ] then
77687: LD_VAR 0 2
77691: PUSH
77692: LD_EXP 23
77696: PUSH
77697: LD_VAR 0 4
77701: ARRAY
77702: IN
77703: IFFALSE 78042
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
77705: LD_EXP 45
77709: PUSH
77710: LD_VAR 0 4
77714: ARRAY
77715: PUSH
77716: LD_EXP 34
77720: PUSH
77721: LD_VAR 0 4
77725: ARRAY
77726: LESS
77727: PUSH
77728: LD_VAR 0 1
77732: PPUSH
77733: CALL_OW 264
77737: PUSH
77738: LD_INT 31
77740: PUSH
77741: LD_INT 32
77743: PUSH
77744: LD_INT 51
77746: PUSH
77747: LD_EXP 68
77751: PUSH
77752: LD_INT 12
77754: PUSH
77755: LD_INT 30
77757: PUSH
77758: LD_EXP 67
77762: PUSH
77763: LD_INT 11
77765: PUSH
77766: LD_INT 53
77768: PUSH
77769: LD_INT 14
77771: PUSH
77772: LD_EXP 71
77776: PUSH
77777: LD_INT 29
77779: PUSH
77780: LD_EXP 69
77784: PUSH
77785: LD_INT 13
77787: PUSH
77788: LD_INT 52
77790: PUSH
77791: LD_EXP 73
77795: PUSH
77796: LD_INT 48
77798: PUSH
77799: LD_INT 8
77801: PUSH
77802: EMPTY
77803: LIST
77804: LIST
77805: LIST
77806: LIST
77807: LIST
77808: LIST
77809: LIST
77810: LIST
77811: LIST
77812: LIST
77813: LIST
77814: LIST
77815: LIST
77816: LIST
77817: LIST
77818: LIST
77819: LIST
77820: LIST
77821: IN
77822: NOT
77823: AND
77824: IFFALSE 77872
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
77826: LD_ADDR_EXP 45
77830: PUSH
77831: LD_EXP 45
77835: PPUSH
77836: LD_VAR 0 4
77840: PUSH
77841: LD_EXP 45
77845: PUSH
77846: LD_VAR 0 4
77850: ARRAY
77851: PUSH
77852: LD_INT 1
77854: PLUS
77855: PUSH
77856: EMPTY
77857: LIST
77858: LIST
77859: PPUSH
77860: LD_VAR 0 1
77864: PPUSH
77865: CALL 15990 0 3
77869: ST_TO_ADDR
77870: GO 77916
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
77872: LD_ADDR_EXP 42
77876: PUSH
77877: LD_EXP 42
77881: PPUSH
77882: LD_VAR 0 4
77886: PUSH
77887: LD_EXP 42
77891: PUSH
77892: LD_VAR 0 4
77896: ARRAY
77897: PUSH
77898: LD_INT 1
77900: PLUS
77901: PUSH
77902: EMPTY
77903: LIST
77904: LIST
77905: PPUSH
77906: LD_VAR 0 1
77910: PPUSH
77911: CALL 15990 0 3
77915: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
77916: LD_VAR 0 1
77920: PPUSH
77921: CALL_OW 263
77925: PUSH
77926: LD_INT 2
77928: EQUAL
77929: IFFALSE 77958
// begin repeat wait ( 0 0$3 ) ;
77931: LD_INT 105
77933: PPUSH
77934: CALL_OW 67
// Connect ( vehicle ) ;
77938: LD_VAR 0 1
77942: PPUSH
77943: CALL 18961 0 1
// until IsControledBy ( vehicle ) ;
77947: LD_VAR 0 1
77951: PPUSH
77952: CALL_OW 312
77956: IFFALSE 77931
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
77958: LD_VAR 0 1
77962: PPUSH
77963: LD_EXP 47
77967: PUSH
77968: LD_VAR 0 4
77972: ARRAY
77973: PPUSH
77974: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
77978: LD_VAR 0 1
77982: PPUSH
77983: CALL_OW 263
77987: PUSH
77988: LD_INT 1
77990: NONEQUAL
77991: IFFALSE 77995
// break ;
77993: GO 78044
// repeat wait ( 0 0$1 ) ;
77995: LD_INT 35
77997: PPUSH
77998: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
78002: LD_VAR 0 1
78006: PPUSH
78007: LD_EXP 47
78011: PUSH
78012: LD_VAR 0 4
78016: ARRAY
78017: PPUSH
78018: CALL_OW 308
78022: IFFALSE 77995
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
78024: LD_VAR 0 1
78028: PPUSH
78029: CALL_OW 311
78033: PPUSH
78034: CALL_OW 121
// exit ;
78038: POP
78039: POP
78040: GO 78046
// end ; end ;
78042: GO 77684
78044: POP
78045: POP
// end ;
78046: LD_VAR 0 3
78050: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
78051: LD_INT 0
78053: PPUSH
78054: PPUSH
78055: PPUSH
78056: PPUSH
// if not mc_bases or not skirmish then
78057: LD_EXP 23
78061: NOT
78062: PUSH
78063: LD_EXP 21
78067: NOT
78068: OR
78069: IFFALSE 78073
// exit ;
78071: GO 78426
// repeat wait ( 0 0$1 ) ;
78073: LD_INT 35
78075: PPUSH
78076: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
78080: LD_VAR 0 2
78084: PPUSH
78085: LD_VAR 0 3
78089: PPUSH
78090: CALL_OW 284
78094: IFFALSE 78073
// if GetResourceTypeXY ( x , y ) = mat_artefact then
78096: LD_VAR 0 2
78100: PPUSH
78101: LD_VAR 0 3
78105: PPUSH
78106: CALL_OW 283
78110: PUSH
78111: LD_INT 4
78113: EQUAL
78114: IFFALSE 78118
// exit ;
78116: GO 78426
// for i = 1 to mc_bases do
78118: LD_ADDR_VAR 0 7
78122: PUSH
78123: DOUBLE
78124: LD_INT 1
78126: DEC
78127: ST_TO_ADDR
78128: LD_EXP 23
78132: PUSH
78133: FOR_TO
78134: IFFALSE 78424
// begin if mc_crates_area [ i ] then
78136: LD_EXP 41
78140: PUSH
78141: LD_VAR 0 7
78145: ARRAY
78146: IFFALSE 78257
// for j in mc_crates_area [ i ] do
78148: LD_ADDR_VAR 0 8
78152: PUSH
78153: LD_EXP 41
78157: PUSH
78158: LD_VAR 0 7
78162: ARRAY
78163: PUSH
78164: FOR_IN
78165: IFFALSE 78255
// if InArea ( x , y , j ) then
78167: LD_VAR 0 2
78171: PPUSH
78172: LD_VAR 0 3
78176: PPUSH
78177: LD_VAR 0 8
78181: PPUSH
78182: CALL_OW 309
78186: IFFALSE 78253
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
78188: LD_ADDR_EXP 39
78192: PUSH
78193: LD_EXP 39
78197: PPUSH
78198: LD_VAR 0 7
78202: PUSH
78203: LD_EXP 39
78207: PUSH
78208: LD_VAR 0 7
78212: ARRAY
78213: PUSH
78214: LD_INT 1
78216: PLUS
78217: PUSH
78218: EMPTY
78219: LIST
78220: LIST
78221: PPUSH
78222: LD_VAR 0 4
78226: PUSH
78227: LD_VAR 0 2
78231: PUSH
78232: LD_VAR 0 3
78236: PUSH
78237: EMPTY
78238: LIST
78239: LIST
78240: LIST
78241: PPUSH
78242: CALL 15990 0 3
78246: ST_TO_ADDR
// exit ;
78247: POP
78248: POP
78249: POP
78250: POP
78251: GO 78426
// end ;
78253: GO 78164
78255: POP
78256: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78257: LD_ADDR_VAR 0 9
78261: PUSH
78262: LD_EXP 23
78266: PUSH
78267: LD_VAR 0 7
78271: ARRAY
78272: PPUSH
78273: LD_INT 2
78275: PUSH
78276: LD_INT 30
78278: PUSH
78279: LD_INT 0
78281: PUSH
78282: EMPTY
78283: LIST
78284: LIST
78285: PUSH
78286: LD_INT 30
78288: PUSH
78289: LD_INT 1
78291: PUSH
78292: EMPTY
78293: LIST
78294: LIST
78295: PUSH
78296: EMPTY
78297: LIST
78298: LIST
78299: LIST
78300: PPUSH
78301: CALL_OW 72
78305: ST_TO_ADDR
// if not depot then
78306: LD_VAR 0 9
78310: NOT
78311: IFFALSE 78315
// continue ;
78313: GO 78133
// for j in depot do
78315: LD_ADDR_VAR 0 8
78319: PUSH
78320: LD_VAR 0 9
78324: PUSH
78325: FOR_IN
78326: IFFALSE 78420
// if GetDistUnitXY ( j , x , y ) < 30 then
78328: LD_VAR 0 8
78332: PPUSH
78333: LD_VAR 0 2
78337: PPUSH
78338: LD_VAR 0 3
78342: PPUSH
78343: CALL_OW 297
78347: PUSH
78348: LD_INT 30
78350: LESS
78351: IFFALSE 78418
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
78353: LD_ADDR_EXP 39
78357: PUSH
78358: LD_EXP 39
78362: PPUSH
78363: LD_VAR 0 7
78367: PUSH
78368: LD_EXP 39
78372: PUSH
78373: LD_VAR 0 7
78377: ARRAY
78378: PUSH
78379: LD_INT 1
78381: PLUS
78382: PUSH
78383: EMPTY
78384: LIST
78385: LIST
78386: PPUSH
78387: LD_VAR 0 4
78391: PUSH
78392: LD_VAR 0 2
78396: PUSH
78397: LD_VAR 0 3
78401: PUSH
78402: EMPTY
78403: LIST
78404: LIST
78405: LIST
78406: PPUSH
78407: CALL 15990 0 3
78411: ST_TO_ADDR
// exit ;
78412: POP
78413: POP
78414: POP
78415: POP
78416: GO 78426
// end ;
78418: GO 78325
78420: POP
78421: POP
// end ;
78422: GO 78133
78424: POP
78425: POP
// end ;
78426: LD_VAR 0 6
78430: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
78431: LD_INT 0
78433: PPUSH
78434: PPUSH
78435: PPUSH
78436: PPUSH
// if not mc_bases or not skirmish then
78437: LD_EXP 23
78441: NOT
78442: PUSH
78443: LD_EXP 21
78447: NOT
78448: OR
78449: IFFALSE 78453
// exit ;
78451: GO 78730
// side := GetSide ( lab ) ;
78453: LD_ADDR_VAR 0 4
78457: PUSH
78458: LD_VAR 0 2
78462: PPUSH
78463: CALL_OW 255
78467: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
78468: LD_VAR 0 4
78472: PUSH
78473: LD_EXP 49
78477: IN
78478: NOT
78479: PUSH
78480: LD_EXP 50
78484: NOT
78485: OR
78486: PUSH
78487: LD_EXP 23
78491: NOT
78492: OR
78493: IFFALSE 78497
// exit ;
78495: GO 78730
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
78497: LD_ADDR_EXP 50
78501: PUSH
78502: LD_EXP 50
78506: PPUSH
78507: LD_VAR 0 4
78511: PPUSH
78512: LD_EXP 50
78516: PUSH
78517: LD_VAR 0 4
78521: ARRAY
78522: PUSH
78523: LD_VAR 0 1
78527: DIFF
78528: PPUSH
78529: CALL_OW 1
78533: ST_TO_ADDR
// for i = 1 to mc_bases do
78534: LD_ADDR_VAR 0 5
78538: PUSH
78539: DOUBLE
78540: LD_INT 1
78542: DEC
78543: ST_TO_ADDR
78544: LD_EXP 23
78548: PUSH
78549: FOR_TO
78550: IFFALSE 78728
// begin if lab in mc_bases [ i ] then
78552: LD_VAR 0 2
78556: PUSH
78557: LD_EXP 23
78561: PUSH
78562: LD_VAR 0 5
78566: ARRAY
78567: IN
78568: IFFALSE 78726
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
78570: LD_VAR 0 1
78574: PUSH
78575: LD_INT 11
78577: PUSH
78578: LD_INT 4
78580: PUSH
78581: LD_INT 3
78583: PUSH
78584: LD_INT 2
78586: PUSH
78587: EMPTY
78588: LIST
78589: LIST
78590: LIST
78591: LIST
78592: IN
78593: PUSH
78594: LD_EXP 53
78598: PUSH
78599: LD_VAR 0 5
78603: ARRAY
78604: AND
78605: IFFALSE 78726
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
78607: LD_ADDR_VAR 0 6
78611: PUSH
78612: LD_EXP 53
78616: PUSH
78617: LD_VAR 0 5
78621: ARRAY
78622: PUSH
78623: LD_INT 1
78625: ARRAY
78626: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
78627: LD_ADDR_EXP 53
78631: PUSH
78632: LD_EXP 53
78636: PPUSH
78637: LD_VAR 0 5
78641: PPUSH
78642: EMPTY
78643: PPUSH
78644: CALL_OW 1
78648: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
78649: LD_VAR 0 6
78653: PPUSH
78654: LD_INT 0
78656: PPUSH
78657: CALL_OW 109
// ComExitBuilding ( tmp ) ;
78661: LD_VAR 0 6
78665: PPUSH
78666: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
78670: LD_ADDR_EXP 52
78674: PUSH
78675: LD_EXP 52
78679: PPUSH
78680: LD_VAR 0 5
78684: PPUSH
78685: LD_EXP 52
78689: PUSH
78690: LD_VAR 0 5
78694: ARRAY
78695: PPUSH
78696: LD_INT 1
78698: PPUSH
78699: LD_VAR 0 6
78703: PPUSH
78704: CALL_OW 2
78708: PPUSH
78709: CALL_OW 1
78713: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
78714: LD_VAR 0 5
78718: PPUSH
78719: LD_INT 112
78721: PPUSH
78722: CALL 55249 0 2
// end ; end ; end ;
78726: GO 78549
78728: POP
78729: POP
// end ;
78730: LD_VAR 0 3
78734: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
78735: LD_INT 0
78737: PPUSH
78738: PPUSH
78739: PPUSH
78740: PPUSH
78741: PPUSH
78742: PPUSH
78743: PPUSH
78744: PPUSH
// if not mc_bases or not skirmish then
78745: LD_EXP 23
78749: NOT
78750: PUSH
78751: LD_EXP 21
78755: NOT
78756: OR
78757: IFFALSE 78761
// exit ;
78759: GO 80132
// for i = 1 to mc_bases do
78761: LD_ADDR_VAR 0 3
78765: PUSH
78766: DOUBLE
78767: LD_INT 1
78769: DEC
78770: ST_TO_ADDR
78771: LD_EXP 23
78775: PUSH
78776: FOR_TO
78777: IFFALSE 80130
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
78779: LD_VAR 0 1
78783: PUSH
78784: LD_EXP 23
78788: PUSH
78789: LD_VAR 0 3
78793: ARRAY
78794: IN
78795: PUSH
78796: LD_VAR 0 1
78800: PUSH
78801: LD_EXP 30
78805: PUSH
78806: LD_VAR 0 3
78810: ARRAY
78811: IN
78812: OR
78813: PUSH
78814: LD_VAR 0 1
78818: PUSH
78819: LD_EXP 45
78823: PUSH
78824: LD_VAR 0 3
78828: ARRAY
78829: IN
78830: OR
78831: PUSH
78832: LD_VAR 0 1
78836: PUSH
78837: LD_EXP 42
78841: PUSH
78842: LD_VAR 0 3
78846: ARRAY
78847: IN
78848: OR
78849: PUSH
78850: LD_VAR 0 1
78854: PUSH
78855: LD_EXP 52
78859: PUSH
78860: LD_VAR 0 3
78864: ARRAY
78865: IN
78866: OR
78867: PUSH
78868: LD_VAR 0 1
78872: PUSH
78873: LD_EXP 53
78877: PUSH
78878: LD_VAR 0 3
78882: ARRAY
78883: IN
78884: OR
78885: IFFALSE 80128
// begin if un in mc_ape [ i ] then
78887: LD_VAR 0 1
78891: PUSH
78892: LD_EXP 52
78896: PUSH
78897: LD_VAR 0 3
78901: ARRAY
78902: IN
78903: IFFALSE 78942
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
78905: LD_ADDR_EXP 52
78909: PUSH
78910: LD_EXP 52
78914: PPUSH
78915: LD_VAR 0 3
78919: PPUSH
78920: LD_EXP 52
78924: PUSH
78925: LD_VAR 0 3
78929: ARRAY
78930: PUSH
78931: LD_VAR 0 1
78935: DIFF
78936: PPUSH
78937: CALL_OW 1
78941: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
78942: LD_VAR 0 1
78946: PUSH
78947: LD_EXP 53
78951: PUSH
78952: LD_VAR 0 3
78956: ARRAY
78957: IN
78958: IFFALSE 78982
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
78960: LD_ADDR_EXP 53
78964: PUSH
78965: LD_EXP 53
78969: PPUSH
78970: LD_VAR 0 3
78974: PPUSH
78975: EMPTY
78976: PPUSH
78977: CALL_OW 1
78981: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
78982: LD_VAR 0 1
78986: PPUSH
78987: CALL_OW 247
78991: PUSH
78992: LD_INT 2
78994: EQUAL
78995: PUSH
78996: LD_VAR 0 1
79000: PPUSH
79001: CALL_OW 110
79005: PUSH
79006: LD_INT 20
79008: EQUAL
79009: PUSH
79010: LD_VAR 0 1
79014: PUSH
79015: LD_EXP 45
79019: PUSH
79020: LD_VAR 0 3
79024: ARRAY
79025: IN
79026: OR
79027: PUSH
79028: LD_VAR 0 1
79032: PPUSH
79033: CALL_OW 264
79037: PUSH
79038: LD_INT 12
79040: PUSH
79041: LD_INT 51
79043: PUSH
79044: LD_EXP 68
79048: PUSH
79049: LD_INT 32
79051: PUSH
79052: LD_INT 13
79054: PUSH
79055: LD_INT 52
79057: PUSH
79058: LD_INT 31
79060: PUSH
79061: EMPTY
79062: LIST
79063: LIST
79064: LIST
79065: LIST
79066: LIST
79067: LIST
79068: LIST
79069: IN
79070: OR
79071: AND
79072: IFFALSE 79380
// begin if un in mc_defender [ i ] then
79074: LD_VAR 0 1
79078: PUSH
79079: LD_EXP 45
79083: PUSH
79084: LD_VAR 0 3
79088: ARRAY
79089: IN
79090: IFFALSE 79129
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
79092: LD_ADDR_EXP 45
79096: PUSH
79097: LD_EXP 45
79101: PPUSH
79102: LD_VAR 0 3
79106: PPUSH
79107: LD_EXP 45
79111: PUSH
79112: LD_VAR 0 3
79116: ARRAY
79117: PUSH
79118: LD_VAR 0 1
79122: DIFF
79123: PPUSH
79124: CALL_OW 1
79128: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
79129: LD_ADDR_VAR 0 8
79133: PUSH
79134: LD_VAR 0 3
79138: PPUSH
79139: LD_INT 3
79141: PPUSH
79142: CALL 75770 0 2
79146: ST_TO_ADDR
// if fac then
79147: LD_VAR 0 8
79151: IFFALSE 79380
// begin for j in fac do
79153: LD_ADDR_VAR 0 4
79157: PUSH
79158: LD_VAR 0 8
79162: PUSH
79163: FOR_IN
79164: IFFALSE 79378
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
79166: LD_ADDR_VAR 0 9
79170: PUSH
79171: LD_VAR 0 8
79175: PPUSH
79176: LD_VAR 0 1
79180: PPUSH
79181: CALL_OW 265
79185: PPUSH
79186: LD_VAR 0 1
79190: PPUSH
79191: CALL_OW 262
79195: PPUSH
79196: LD_VAR 0 1
79200: PPUSH
79201: CALL_OW 263
79205: PPUSH
79206: LD_VAR 0 1
79210: PPUSH
79211: CALL_OW 264
79215: PPUSH
79216: CALL 13486 0 5
79220: ST_TO_ADDR
// if components then
79221: LD_VAR 0 9
79225: IFFALSE 79376
// begin if GetWeapon ( un ) = ar_control_tower then
79227: LD_VAR 0 1
79231: PPUSH
79232: CALL_OW 264
79236: PUSH
79237: LD_INT 31
79239: EQUAL
79240: IFFALSE 79357
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
79242: LD_VAR 0 1
79246: PPUSH
79247: CALL_OW 311
79251: PPUSH
79252: LD_INT 0
79254: PPUSH
79255: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
79259: LD_ADDR_EXP 63
79263: PUSH
79264: LD_EXP 63
79268: PPUSH
79269: LD_VAR 0 3
79273: PPUSH
79274: LD_EXP 63
79278: PUSH
79279: LD_VAR 0 3
79283: ARRAY
79284: PUSH
79285: LD_VAR 0 1
79289: PPUSH
79290: CALL_OW 311
79294: DIFF
79295: PPUSH
79296: CALL_OW 1
79300: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
79301: LD_ADDR_VAR 0 7
79305: PUSH
79306: LD_EXP 44
79310: PUSH
79311: LD_VAR 0 3
79315: ARRAY
79316: PPUSH
79317: LD_INT 1
79319: PPUSH
79320: LD_VAR 0 9
79324: PPUSH
79325: CALL_OW 2
79329: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
79330: LD_ADDR_EXP 44
79334: PUSH
79335: LD_EXP 44
79339: PPUSH
79340: LD_VAR 0 3
79344: PPUSH
79345: LD_VAR 0 7
79349: PPUSH
79350: CALL_OW 1
79354: ST_TO_ADDR
// end else
79355: GO 79374
// MC_InsertProduceList ( i , [ components ] ) ;
79357: LD_VAR 0 3
79361: PPUSH
79362: LD_VAR 0 9
79366: PUSH
79367: EMPTY
79368: LIST
79369: PPUSH
79370: CALL 75315 0 2
// break ;
79374: GO 79378
// end ; end ;
79376: GO 79163
79378: POP
79379: POP
// end ; end ; if GetType ( un ) = unit_building then
79380: LD_VAR 0 1
79384: PPUSH
79385: CALL_OW 247
79389: PUSH
79390: LD_INT 3
79392: EQUAL
79393: IFFALSE 79796
// begin btype := GetBType ( un ) ;
79395: LD_ADDR_VAR 0 5
79399: PUSH
79400: LD_VAR 0 1
79404: PPUSH
79405: CALL_OW 266
79409: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
79410: LD_VAR 0 5
79414: PUSH
79415: LD_INT 29
79417: PUSH
79418: LD_INT 30
79420: PUSH
79421: EMPTY
79422: LIST
79423: LIST
79424: IN
79425: IFFALSE 79498
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
79427: LD_VAR 0 1
79431: PPUSH
79432: CALL_OW 250
79436: PPUSH
79437: LD_VAR 0 1
79441: PPUSH
79442: CALL_OW 251
79446: PPUSH
79447: LD_VAR 0 1
79451: PPUSH
79452: CALL_OW 255
79456: PPUSH
79457: CALL_OW 440
79461: NOT
79462: IFFALSE 79498
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
79464: LD_VAR 0 1
79468: PPUSH
79469: CALL_OW 250
79473: PPUSH
79474: LD_VAR 0 1
79478: PPUSH
79479: CALL_OW 251
79483: PPUSH
79484: LD_VAR 0 1
79488: PPUSH
79489: CALL_OW 255
79493: PPUSH
79494: CALL_OW 441
// end ; if btype = b_warehouse then
79498: LD_VAR 0 5
79502: PUSH
79503: LD_INT 1
79505: EQUAL
79506: IFFALSE 79524
// begin btype := b_depot ;
79508: LD_ADDR_VAR 0 5
79512: PUSH
79513: LD_INT 0
79515: ST_TO_ADDR
// pos := 1 ;
79516: LD_ADDR_VAR 0 6
79520: PUSH
79521: LD_INT 1
79523: ST_TO_ADDR
// end ; if btype = b_factory then
79524: LD_VAR 0 5
79528: PUSH
79529: LD_INT 3
79531: EQUAL
79532: IFFALSE 79550
// begin btype := b_workshop ;
79534: LD_ADDR_VAR 0 5
79538: PUSH
79539: LD_INT 2
79541: ST_TO_ADDR
// pos := 1 ;
79542: LD_ADDR_VAR 0 6
79546: PUSH
79547: LD_INT 1
79549: ST_TO_ADDR
// end ; if btype = b_barracks then
79550: LD_VAR 0 5
79554: PUSH
79555: LD_INT 5
79557: EQUAL
79558: IFFALSE 79568
// btype := b_armoury ;
79560: LD_ADDR_VAR 0 5
79564: PUSH
79565: LD_INT 4
79567: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
79568: LD_VAR 0 5
79572: PUSH
79573: LD_INT 7
79575: PUSH
79576: LD_INT 8
79578: PUSH
79579: EMPTY
79580: LIST
79581: LIST
79582: IN
79583: IFFALSE 79593
// btype := b_lab ;
79585: LD_ADDR_VAR 0 5
79589: PUSH
79590: LD_INT 6
79592: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
79593: LD_ADDR_EXP 28
79597: PUSH
79598: LD_EXP 28
79602: PPUSH
79603: LD_VAR 0 3
79607: PUSH
79608: LD_EXP 28
79612: PUSH
79613: LD_VAR 0 3
79617: ARRAY
79618: PUSH
79619: LD_INT 1
79621: PLUS
79622: PUSH
79623: EMPTY
79624: LIST
79625: LIST
79626: PPUSH
79627: LD_VAR 0 5
79631: PUSH
79632: LD_VAR 0 1
79636: PPUSH
79637: CALL_OW 250
79641: PUSH
79642: LD_VAR 0 1
79646: PPUSH
79647: CALL_OW 251
79651: PUSH
79652: LD_VAR 0 1
79656: PPUSH
79657: CALL_OW 254
79661: PUSH
79662: EMPTY
79663: LIST
79664: LIST
79665: LIST
79666: LIST
79667: PPUSH
79668: CALL 15990 0 3
79672: ST_TO_ADDR
// if pos = 1 then
79673: LD_VAR 0 6
79677: PUSH
79678: LD_INT 1
79680: EQUAL
79681: IFFALSE 79796
// begin tmp := mc_build_list [ i ] ;
79683: LD_ADDR_VAR 0 7
79687: PUSH
79688: LD_EXP 28
79692: PUSH
79693: LD_VAR 0 3
79697: ARRAY
79698: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
79699: LD_VAR 0 7
79703: PPUSH
79704: LD_INT 2
79706: PUSH
79707: LD_INT 30
79709: PUSH
79710: LD_INT 0
79712: PUSH
79713: EMPTY
79714: LIST
79715: LIST
79716: PUSH
79717: LD_INT 30
79719: PUSH
79720: LD_INT 1
79722: PUSH
79723: EMPTY
79724: LIST
79725: LIST
79726: PUSH
79727: EMPTY
79728: LIST
79729: LIST
79730: LIST
79731: PPUSH
79732: CALL_OW 72
79736: IFFALSE 79746
// pos := 2 ;
79738: LD_ADDR_VAR 0 6
79742: PUSH
79743: LD_INT 2
79745: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
79746: LD_ADDR_VAR 0 7
79750: PUSH
79751: LD_VAR 0 7
79755: PPUSH
79756: LD_VAR 0 6
79760: PPUSH
79761: LD_VAR 0 7
79765: PPUSH
79766: CALL 16316 0 3
79770: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
79771: LD_ADDR_EXP 28
79775: PUSH
79776: LD_EXP 28
79780: PPUSH
79781: LD_VAR 0 3
79785: PPUSH
79786: LD_VAR 0 7
79790: PPUSH
79791: CALL_OW 1
79795: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
79796: LD_VAR 0 1
79800: PUSH
79801: LD_EXP 23
79805: PUSH
79806: LD_VAR 0 3
79810: ARRAY
79811: IN
79812: IFFALSE 79851
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
79814: LD_ADDR_EXP 23
79818: PUSH
79819: LD_EXP 23
79823: PPUSH
79824: LD_VAR 0 3
79828: PPUSH
79829: LD_EXP 23
79833: PUSH
79834: LD_VAR 0 3
79838: ARRAY
79839: PUSH
79840: LD_VAR 0 1
79844: DIFF
79845: PPUSH
79846: CALL_OW 1
79850: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
79851: LD_VAR 0 1
79855: PUSH
79856: LD_EXP 30
79860: PUSH
79861: LD_VAR 0 3
79865: ARRAY
79866: IN
79867: IFFALSE 79906
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
79869: LD_ADDR_EXP 30
79873: PUSH
79874: LD_EXP 30
79878: PPUSH
79879: LD_VAR 0 3
79883: PPUSH
79884: LD_EXP 30
79888: PUSH
79889: LD_VAR 0 3
79893: ARRAY
79894: PUSH
79895: LD_VAR 0 1
79899: DIFF
79900: PPUSH
79901: CALL_OW 1
79905: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
79906: LD_VAR 0 1
79910: PUSH
79911: LD_EXP 42
79915: PUSH
79916: LD_VAR 0 3
79920: ARRAY
79921: IN
79922: IFFALSE 79961
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
79924: LD_ADDR_EXP 42
79928: PUSH
79929: LD_EXP 42
79933: PPUSH
79934: LD_VAR 0 3
79938: PPUSH
79939: LD_EXP 42
79943: PUSH
79944: LD_VAR 0 3
79948: ARRAY
79949: PUSH
79950: LD_VAR 0 1
79954: DIFF
79955: PPUSH
79956: CALL_OW 1
79960: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
79961: LD_VAR 0 1
79965: PUSH
79966: LD_EXP 45
79970: PUSH
79971: LD_VAR 0 3
79975: ARRAY
79976: IN
79977: IFFALSE 80016
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
79979: LD_ADDR_EXP 45
79983: PUSH
79984: LD_EXP 45
79988: PPUSH
79989: LD_VAR 0 3
79993: PPUSH
79994: LD_EXP 45
79998: PUSH
79999: LD_VAR 0 3
80003: ARRAY
80004: PUSH
80005: LD_VAR 0 1
80009: DIFF
80010: PPUSH
80011: CALL_OW 1
80015: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
80016: LD_VAR 0 1
80020: PUSH
80021: LD_EXP 32
80025: PUSH
80026: LD_VAR 0 3
80030: ARRAY
80031: IN
80032: IFFALSE 80071
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
80034: LD_ADDR_EXP 32
80038: PUSH
80039: LD_EXP 32
80043: PPUSH
80044: LD_VAR 0 3
80048: PPUSH
80049: LD_EXP 32
80053: PUSH
80054: LD_VAR 0 3
80058: ARRAY
80059: PUSH
80060: LD_VAR 0 1
80064: DIFF
80065: PPUSH
80066: CALL_OW 1
80070: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
80071: LD_VAR 0 1
80075: PUSH
80076: LD_EXP 31
80080: PUSH
80081: LD_VAR 0 3
80085: ARRAY
80086: IN
80087: IFFALSE 80126
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
80089: LD_ADDR_EXP 31
80093: PUSH
80094: LD_EXP 31
80098: PPUSH
80099: LD_VAR 0 3
80103: PPUSH
80104: LD_EXP 31
80108: PUSH
80109: LD_VAR 0 3
80113: ARRAY
80114: PUSH
80115: LD_VAR 0 1
80119: DIFF
80120: PPUSH
80121: CALL_OW 1
80125: ST_TO_ADDR
// end ; break ;
80126: GO 80130
// end ;
80128: GO 78776
80130: POP
80131: POP
// end ;
80132: LD_VAR 0 2
80136: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
80137: LD_INT 0
80139: PPUSH
80140: PPUSH
80141: PPUSH
// if not mc_bases or not skirmish then
80142: LD_EXP 23
80146: NOT
80147: PUSH
80148: LD_EXP 21
80152: NOT
80153: OR
80154: IFFALSE 80158
// exit ;
80156: GO 80373
// for i = 1 to mc_bases do
80158: LD_ADDR_VAR 0 3
80162: PUSH
80163: DOUBLE
80164: LD_INT 1
80166: DEC
80167: ST_TO_ADDR
80168: LD_EXP 23
80172: PUSH
80173: FOR_TO
80174: IFFALSE 80371
// begin if building in mc_construct_list [ i ] then
80176: LD_VAR 0 1
80180: PUSH
80181: LD_EXP 30
80185: PUSH
80186: LD_VAR 0 3
80190: ARRAY
80191: IN
80192: IFFALSE 80369
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
80194: LD_ADDR_EXP 30
80198: PUSH
80199: LD_EXP 30
80203: PPUSH
80204: LD_VAR 0 3
80208: PPUSH
80209: LD_EXP 30
80213: PUSH
80214: LD_VAR 0 3
80218: ARRAY
80219: PUSH
80220: LD_VAR 0 1
80224: DIFF
80225: PPUSH
80226: CALL_OW 1
80230: ST_TO_ADDR
// if building in mc_lab [ i ] then
80231: LD_VAR 0 1
80235: PUSH
80236: LD_EXP 56
80240: PUSH
80241: LD_VAR 0 3
80245: ARRAY
80246: IN
80247: IFFALSE 80302
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
80249: LD_ADDR_EXP 57
80253: PUSH
80254: LD_EXP 57
80258: PPUSH
80259: LD_VAR 0 3
80263: PPUSH
80264: LD_EXP 57
80268: PUSH
80269: LD_VAR 0 3
80273: ARRAY
80274: PPUSH
80275: LD_INT 1
80277: PPUSH
80278: LD_EXP 57
80282: PUSH
80283: LD_VAR 0 3
80287: ARRAY
80288: PPUSH
80289: LD_INT 0
80291: PPUSH
80292: CALL 15408 0 4
80296: PPUSH
80297: CALL_OW 1
80301: ST_TO_ADDR
// if not building in mc_bases [ i ] then
80302: LD_VAR 0 1
80306: PUSH
80307: LD_EXP 23
80311: PUSH
80312: LD_VAR 0 3
80316: ARRAY
80317: IN
80318: NOT
80319: IFFALSE 80365
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
80321: LD_ADDR_EXP 23
80325: PUSH
80326: LD_EXP 23
80330: PPUSH
80331: LD_VAR 0 3
80335: PUSH
80336: LD_EXP 23
80340: PUSH
80341: LD_VAR 0 3
80345: ARRAY
80346: PUSH
80347: LD_INT 1
80349: PLUS
80350: PUSH
80351: EMPTY
80352: LIST
80353: LIST
80354: PPUSH
80355: LD_VAR 0 1
80359: PPUSH
80360: CALL 15990 0 3
80364: ST_TO_ADDR
// exit ;
80365: POP
80366: POP
80367: GO 80373
// end ; end ;
80369: GO 80173
80371: POP
80372: POP
// end ;
80373: LD_VAR 0 2
80377: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
80378: LD_INT 0
80380: PPUSH
80381: PPUSH
80382: PPUSH
80383: PPUSH
80384: PPUSH
80385: PPUSH
80386: PPUSH
// if not mc_bases or not skirmish then
80387: LD_EXP 23
80391: NOT
80392: PUSH
80393: LD_EXP 21
80397: NOT
80398: OR
80399: IFFALSE 80403
// exit ;
80401: GO 81064
// for i = 1 to mc_bases do
80403: LD_ADDR_VAR 0 3
80407: PUSH
80408: DOUBLE
80409: LD_INT 1
80411: DEC
80412: ST_TO_ADDR
80413: LD_EXP 23
80417: PUSH
80418: FOR_TO
80419: IFFALSE 81062
// begin if building in mc_construct_list [ i ] then
80421: LD_VAR 0 1
80425: PUSH
80426: LD_EXP 30
80430: PUSH
80431: LD_VAR 0 3
80435: ARRAY
80436: IN
80437: IFFALSE 81060
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
80439: LD_ADDR_EXP 30
80443: PUSH
80444: LD_EXP 30
80448: PPUSH
80449: LD_VAR 0 3
80453: PPUSH
80454: LD_EXP 30
80458: PUSH
80459: LD_VAR 0 3
80463: ARRAY
80464: PUSH
80465: LD_VAR 0 1
80469: DIFF
80470: PPUSH
80471: CALL_OW 1
80475: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
80476: LD_ADDR_EXP 23
80480: PUSH
80481: LD_EXP 23
80485: PPUSH
80486: LD_VAR 0 3
80490: PUSH
80491: LD_EXP 23
80495: PUSH
80496: LD_VAR 0 3
80500: ARRAY
80501: PUSH
80502: LD_INT 1
80504: PLUS
80505: PUSH
80506: EMPTY
80507: LIST
80508: LIST
80509: PPUSH
80510: LD_VAR 0 1
80514: PPUSH
80515: CALL 15990 0 3
80519: ST_TO_ADDR
// btype := GetBType ( building ) ;
80520: LD_ADDR_VAR 0 5
80524: PUSH
80525: LD_VAR 0 1
80529: PPUSH
80530: CALL_OW 266
80534: ST_TO_ADDR
// side := GetSide ( building ) ;
80535: LD_ADDR_VAR 0 8
80539: PUSH
80540: LD_VAR 0 1
80544: PPUSH
80545: CALL_OW 255
80549: ST_TO_ADDR
// if btype = b_lab then
80550: LD_VAR 0 5
80554: PUSH
80555: LD_INT 6
80557: EQUAL
80558: IFFALSE 80608
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
80560: LD_ADDR_EXP 56
80564: PUSH
80565: LD_EXP 56
80569: PPUSH
80570: LD_VAR 0 3
80574: PUSH
80575: LD_EXP 56
80579: PUSH
80580: LD_VAR 0 3
80584: ARRAY
80585: PUSH
80586: LD_INT 1
80588: PLUS
80589: PUSH
80590: EMPTY
80591: LIST
80592: LIST
80593: PPUSH
80594: LD_VAR 0 1
80598: PPUSH
80599: CALL 15990 0 3
80603: ST_TO_ADDR
// exit ;
80604: POP
80605: POP
80606: GO 81064
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
80608: LD_VAR 0 5
80612: PUSH
80613: LD_INT 0
80615: PUSH
80616: LD_INT 2
80618: PUSH
80619: LD_INT 4
80621: PUSH
80622: EMPTY
80623: LIST
80624: LIST
80625: LIST
80626: IN
80627: IFFALSE 80751
// begin if btype = b_armoury then
80629: LD_VAR 0 5
80633: PUSH
80634: LD_INT 4
80636: EQUAL
80637: IFFALSE 80647
// btype := b_barracks ;
80639: LD_ADDR_VAR 0 5
80643: PUSH
80644: LD_INT 5
80646: ST_TO_ADDR
// if btype = b_depot then
80647: LD_VAR 0 5
80651: PUSH
80652: LD_INT 0
80654: EQUAL
80655: IFFALSE 80665
// btype := b_warehouse ;
80657: LD_ADDR_VAR 0 5
80661: PUSH
80662: LD_INT 1
80664: ST_TO_ADDR
// if btype = b_workshop then
80665: LD_VAR 0 5
80669: PUSH
80670: LD_INT 2
80672: EQUAL
80673: IFFALSE 80683
// btype := b_factory ;
80675: LD_ADDR_VAR 0 5
80679: PUSH
80680: LD_INT 3
80682: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
80683: LD_VAR 0 5
80687: PPUSH
80688: LD_VAR 0 8
80692: PPUSH
80693: CALL_OW 323
80697: PUSH
80698: LD_INT 1
80700: EQUAL
80701: IFFALSE 80747
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
80703: LD_ADDR_EXP 55
80707: PUSH
80708: LD_EXP 55
80712: PPUSH
80713: LD_VAR 0 3
80717: PUSH
80718: LD_EXP 55
80722: PUSH
80723: LD_VAR 0 3
80727: ARRAY
80728: PUSH
80729: LD_INT 1
80731: PLUS
80732: PUSH
80733: EMPTY
80734: LIST
80735: LIST
80736: PPUSH
80737: LD_VAR 0 1
80741: PPUSH
80742: CALL 15990 0 3
80746: ST_TO_ADDR
// exit ;
80747: POP
80748: POP
80749: GO 81064
// end ; if btype in [ b_bunker , b_turret ] then
80751: LD_VAR 0 5
80755: PUSH
80756: LD_INT 32
80758: PUSH
80759: LD_INT 33
80761: PUSH
80762: EMPTY
80763: LIST
80764: LIST
80765: IN
80766: IFFALSE 81056
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
80768: LD_ADDR_EXP 31
80772: PUSH
80773: LD_EXP 31
80777: PPUSH
80778: LD_VAR 0 3
80782: PUSH
80783: LD_EXP 31
80787: PUSH
80788: LD_VAR 0 3
80792: ARRAY
80793: PUSH
80794: LD_INT 1
80796: PLUS
80797: PUSH
80798: EMPTY
80799: LIST
80800: LIST
80801: PPUSH
80802: LD_VAR 0 1
80806: PPUSH
80807: CALL 15990 0 3
80811: ST_TO_ADDR
// if btype = b_bunker then
80812: LD_VAR 0 5
80816: PUSH
80817: LD_INT 32
80819: EQUAL
80820: IFFALSE 81056
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
80822: LD_ADDR_EXP 32
80826: PUSH
80827: LD_EXP 32
80831: PPUSH
80832: LD_VAR 0 3
80836: PUSH
80837: LD_EXP 32
80841: PUSH
80842: LD_VAR 0 3
80846: ARRAY
80847: PUSH
80848: LD_INT 1
80850: PLUS
80851: PUSH
80852: EMPTY
80853: LIST
80854: LIST
80855: PPUSH
80856: LD_VAR 0 1
80860: PPUSH
80861: CALL 15990 0 3
80865: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
80866: LD_ADDR_VAR 0 6
80870: PUSH
80871: LD_EXP 23
80875: PUSH
80876: LD_VAR 0 3
80880: ARRAY
80881: PPUSH
80882: LD_INT 25
80884: PUSH
80885: LD_INT 1
80887: PUSH
80888: EMPTY
80889: LIST
80890: LIST
80891: PUSH
80892: LD_INT 3
80894: PUSH
80895: LD_INT 54
80897: PUSH
80898: EMPTY
80899: LIST
80900: PUSH
80901: EMPTY
80902: LIST
80903: LIST
80904: PUSH
80905: EMPTY
80906: LIST
80907: LIST
80908: PPUSH
80909: CALL_OW 72
80913: ST_TO_ADDR
// if tmp then
80914: LD_VAR 0 6
80918: IFFALSE 80924
// exit ;
80920: POP
80921: POP
80922: GO 81064
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
80924: LD_ADDR_VAR 0 6
80928: PUSH
80929: LD_EXP 23
80933: PUSH
80934: LD_VAR 0 3
80938: ARRAY
80939: PPUSH
80940: LD_INT 2
80942: PUSH
80943: LD_INT 30
80945: PUSH
80946: LD_INT 4
80948: PUSH
80949: EMPTY
80950: LIST
80951: LIST
80952: PUSH
80953: LD_INT 30
80955: PUSH
80956: LD_INT 5
80958: PUSH
80959: EMPTY
80960: LIST
80961: LIST
80962: PUSH
80963: EMPTY
80964: LIST
80965: LIST
80966: LIST
80967: PPUSH
80968: CALL_OW 72
80972: ST_TO_ADDR
// if not tmp then
80973: LD_VAR 0 6
80977: NOT
80978: IFFALSE 80984
// exit ;
80980: POP
80981: POP
80982: GO 81064
// for j in tmp do
80984: LD_ADDR_VAR 0 4
80988: PUSH
80989: LD_VAR 0 6
80993: PUSH
80994: FOR_IN
80995: IFFALSE 81054
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
80997: LD_ADDR_VAR 0 7
81001: PUSH
81002: LD_VAR 0 4
81006: PPUSH
81007: CALL_OW 313
81011: PPUSH
81012: LD_INT 25
81014: PUSH
81015: LD_INT 1
81017: PUSH
81018: EMPTY
81019: LIST
81020: LIST
81021: PPUSH
81022: CALL_OW 72
81026: ST_TO_ADDR
// if units then
81027: LD_VAR 0 7
81031: IFFALSE 81052
// begin ComExitBuilding ( units [ 1 ] ) ;
81033: LD_VAR 0 7
81037: PUSH
81038: LD_INT 1
81040: ARRAY
81041: PPUSH
81042: CALL_OW 122
// exit ;
81046: POP
81047: POP
81048: POP
81049: POP
81050: GO 81064
// end ; end ;
81052: GO 80994
81054: POP
81055: POP
// end ; end ; exit ;
81056: POP
81057: POP
81058: GO 81064
// end ; end ;
81060: GO 80418
81062: POP
81063: POP
// end ;
81064: LD_VAR 0 2
81068: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
81069: LD_INT 0
81071: PPUSH
81072: PPUSH
81073: PPUSH
81074: PPUSH
81075: PPUSH
81076: PPUSH
81077: PPUSH
// if not mc_bases or not skirmish then
81078: LD_EXP 23
81082: NOT
81083: PUSH
81084: LD_EXP 21
81088: NOT
81089: OR
81090: IFFALSE 81094
// exit ;
81092: GO 81359
// btype := GetBType ( building ) ;
81094: LD_ADDR_VAR 0 6
81098: PUSH
81099: LD_VAR 0 1
81103: PPUSH
81104: CALL_OW 266
81108: ST_TO_ADDR
// x := GetX ( building ) ;
81109: LD_ADDR_VAR 0 7
81113: PUSH
81114: LD_VAR 0 1
81118: PPUSH
81119: CALL_OW 250
81123: ST_TO_ADDR
// y := GetY ( building ) ;
81124: LD_ADDR_VAR 0 8
81128: PUSH
81129: LD_VAR 0 1
81133: PPUSH
81134: CALL_OW 251
81138: ST_TO_ADDR
// d := GetDir ( building ) ;
81139: LD_ADDR_VAR 0 9
81143: PUSH
81144: LD_VAR 0 1
81148: PPUSH
81149: CALL_OW 254
81153: ST_TO_ADDR
// for i = 1 to mc_bases do
81154: LD_ADDR_VAR 0 4
81158: PUSH
81159: DOUBLE
81160: LD_INT 1
81162: DEC
81163: ST_TO_ADDR
81164: LD_EXP 23
81168: PUSH
81169: FOR_TO
81170: IFFALSE 81357
// begin if not mc_build_list [ i ] then
81172: LD_EXP 28
81176: PUSH
81177: LD_VAR 0 4
81181: ARRAY
81182: NOT
81183: IFFALSE 81187
// continue ;
81185: GO 81169
// for j := 1 to mc_build_list [ i ] do
81187: LD_ADDR_VAR 0 5
81191: PUSH
81192: DOUBLE
81193: LD_INT 1
81195: DEC
81196: ST_TO_ADDR
81197: LD_EXP 28
81201: PUSH
81202: LD_VAR 0 4
81206: ARRAY
81207: PUSH
81208: FOR_TO
81209: IFFALSE 81353
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
81211: LD_VAR 0 6
81215: PUSH
81216: LD_VAR 0 7
81220: PUSH
81221: LD_VAR 0 8
81225: PUSH
81226: LD_VAR 0 9
81230: PUSH
81231: EMPTY
81232: LIST
81233: LIST
81234: LIST
81235: LIST
81236: PPUSH
81237: LD_EXP 28
81241: PUSH
81242: LD_VAR 0 4
81246: ARRAY
81247: PUSH
81248: LD_VAR 0 5
81252: ARRAY
81253: PPUSH
81254: CALL 22172 0 2
81258: IFFALSE 81351
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
81260: LD_ADDR_EXP 28
81264: PUSH
81265: LD_EXP 28
81269: PPUSH
81270: LD_VAR 0 4
81274: PPUSH
81275: LD_EXP 28
81279: PUSH
81280: LD_VAR 0 4
81284: ARRAY
81285: PPUSH
81286: LD_VAR 0 5
81290: PPUSH
81291: CALL_OW 3
81295: PPUSH
81296: CALL_OW 1
81300: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
81301: LD_ADDR_EXP 30
81305: PUSH
81306: LD_EXP 30
81310: PPUSH
81311: LD_VAR 0 4
81315: PUSH
81316: LD_EXP 30
81320: PUSH
81321: LD_VAR 0 4
81325: ARRAY
81326: PUSH
81327: LD_INT 1
81329: PLUS
81330: PUSH
81331: EMPTY
81332: LIST
81333: LIST
81334: PPUSH
81335: LD_VAR 0 1
81339: PPUSH
81340: CALL 15990 0 3
81344: ST_TO_ADDR
// exit ;
81345: POP
81346: POP
81347: POP
81348: POP
81349: GO 81359
// end ;
81351: GO 81208
81353: POP
81354: POP
// end ;
81355: GO 81169
81357: POP
81358: POP
// end ;
81359: LD_VAR 0 3
81363: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
81364: LD_INT 0
81366: PPUSH
81367: PPUSH
81368: PPUSH
// if not mc_bases or not skirmish then
81369: LD_EXP 23
81373: NOT
81374: PUSH
81375: LD_EXP 21
81379: NOT
81380: OR
81381: IFFALSE 81385
// exit ;
81383: GO 81575
// for i = 1 to mc_bases do
81385: LD_ADDR_VAR 0 4
81389: PUSH
81390: DOUBLE
81391: LD_INT 1
81393: DEC
81394: ST_TO_ADDR
81395: LD_EXP 23
81399: PUSH
81400: FOR_TO
81401: IFFALSE 81488
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
81403: LD_VAR 0 1
81407: PUSH
81408: LD_EXP 31
81412: PUSH
81413: LD_VAR 0 4
81417: ARRAY
81418: IN
81419: PUSH
81420: LD_VAR 0 1
81424: PUSH
81425: LD_EXP 32
81429: PUSH
81430: LD_VAR 0 4
81434: ARRAY
81435: IN
81436: NOT
81437: AND
81438: IFFALSE 81486
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
81440: LD_ADDR_EXP 32
81444: PUSH
81445: LD_EXP 32
81449: PPUSH
81450: LD_VAR 0 4
81454: PUSH
81455: LD_EXP 32
81459: PUSH
81460: LD_VAR 0 4
81464: ARRAY
81465: PUSH
81466: LD_INT 1
81468: PLUS
81469: PUSH
81470: EMPTY
81471: LIST
81472: LIST
81473: PPUSH
81474: LD_VAR 0 1
81478: PPUSH
81479: CALL 15990 0 3
81483: ST_TO_ADDR
// break ;
81484: GO 81488
// end ; end ;
81486: GO 81400
81488: POP
81489: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
81490: LD_VAR 0 1
81494: PPUSH
81495: CALL_OW 257
81499: PUSH
81500: LD_EXP 49
81504: IN
81505: PUSH
81506: LD_VAR 0 1
81510: PPUSH
81511: CALL_OW 266
81515: PUSH
81516: LD_INT 5
81518: EQUAL
81519: AND
81520: PUSH
81521: LD_VAR 0 2
81525: PPUSH
81526: CALL_OW 110
81530: PUSH
81531: LD_INT 18
81533: NONEQUAL
81534: AND
81535: IFFALSE 81575
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
81537: LD_VAR 0 2
81541: PPUSH
81542: CALL_OW 257
81546: PUSH
81547: LD_INT 5
81549: PUSH
81550: LD_INT 8
81552: PUSH
81553: LD_INT 9
81555: PUSH
81556: EMPTY
81557: LIST
81558: LIST
81559: LIST
81560: IN
81561: IFFALSE 81575
// SetClass ( unit , 1 ) ;
81563: LD_VAR 0 2
81567: PPUSH
81568: LD_INT 1
81570: PPUSH
81571: CALL_OW 336
// end ;
81575: LD_VAR 0 3
81579: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
81580: LD_INT 0
81582: PPUSH
81583: PPUSH
// if not mc_bases or not skirmish then
81584: LD_EXP 23
81588: NOT
81589: PUSH
81590: LD_EXP 21
81594: NOT
81595: OR
81596: IFFALSE 81600
// exit ;
81598: GO 81716
// if GetLives ( abandoned_vehicle ) > 250 then
81600: LD_VAR 0 2
81604: PPUSH
81605: CALL_OW 256
81609: PUSH
81610: LD_INT 250
81612: GREATER
81613: IFFALSE 81617
// exit ;
81615: GO 81716
// for i = 1 to mc_bases do
81617: LD_ADDR_VAR 0 6
81621: PUSH
81622: DOUBLE
81623: LD_INT 1
81625: DEC
81626: ST_TO_ADDR
81627: LD_EXP 23
81631: PUSH
81632: FOR_TO
81633: IFFALSE 81714
// begin if driver in mc_bases [ i ] then
81635: LD_VAR 0 1
81639: PUSH
81640: LD_EXP 23
81644: PUSH
81645: LD_VAR 0 6
81649: ARRAY
81650: IN
81651: IFFALSE 81712
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
81653: LD_VAR 0 1
81657: PPUSH
81658: LD_EXP 23
81662: PUSH
81663: LD_VAR 0 6
81667: ARRAY
81668: PPUSH
81669: LD_INT 2
81671: PUSH
81672: LD_INT 30
81674: PUSH
81675: LD_INT 0
81677: PUSH
81678: EMPTY
81679: LIST
81680: LIST
81681: PUSH
81682: LD_INT 30
81684: PUSH
81685: LD_INT 1
81687: PUSH
81688: EMPTY
81689: LIST
81690: LIST
81691: PUSH
81692: EMPTY
81693: LIST
81694: LIST
81695: LIST
81696: PPUSH
81697: CALL_OW 72
81701: PUSH
81702: LD_INT 1
81704: ARRAY
81705: PPUSH
81706: CALL 48608 0 2
// break ;
81710: GO 81714
// end ; end ;
81712: GO 81632
81714: POP
81715: POP
// end ; end_of_file
81716: LD_VAR 0 5
81720: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
81721: LD_INT 0
81723: PPUSH
// ar_miner := 81 ;
81724: LD_ADDR_EXP 74
81728: PUSH
81729: LD_INT 81
81731: ST_TO_ADDR
// ar_crane := 88 ;
81732: LD_ADDR_EXP 73
81736: PUSH
81737: LD_INT 88
81739: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
81740: LD_ADDR_EXP 68
81744: PUSH
81745: LD_INT 89
81747: ST_TO_ADDR
// us_hack := 99 ;
81748: LD_ADDR_EXP 69
81752: PUSH
81753: LD_INT 99
81755: ST_TO_ADDR
// us_artillery := 97 ;
81756: LD_ADDR_EXP 70
81760: PUSH
81761: LD_INT 97
81763: ST_TO_ADDR
// ar_bio_bomb := 91 ;
81764: LD_ADDR_EXP 71
81768: PUSH
81769: LD_INT 91
81771: ST_TO_ADDR
// ar_mortar := 92 ;
81772: LD_ADDR_EXP 72
81776: PUSH
81777: LD_INT 92
81779: ST_TO_ADDR
// ru_radar := 98 ;
81780: LD_ADDR_EXP 67
81784: PUSH
81785: LD_INT 98
81787: ST_TO_ADDR
// tech_Artillery := 80 ;
81788: LD_ADDR_EXP 75
81792: PUSH
81793: LD_INT 80
81795: ST_TO_ADDR
// tech_RadMat := 81 ;
81796: LD_ADDR_EXP 76
81800: PUSH
81801: LD_INT 81
81803: ST_TO_ADDR
// tech_BasicTools := 82 ;
81804: LD_ADDR_EXP 77
81808: PUSH
81809: LD_INT 82
81811: ST_TO_ADDR
// tech_Cargo := 83 ;
81812: LD_ADDR_EXP 78
81816: PUSH
81817: LD_INT 83
81819: ST_TO_ADDR
// tech_Track := 84 ;
81820: LD_ADDR_EXP 79
81824: PUSH
81825: LD_INT 84
81827: ST_TO_ADDR
// tech_Crane := 85 ;
81828: LD_ADDR_EXP 80
81832: PUSH
81833: LD_INT 85
81835: ST_TO_ADDR
// tech_Bulldozer := 86 ;
81836: LD_ADDR_EXP 81
81840: PUSH
81841: LD_INT 86
81843: ST_TO_ADDR
// tech_Hovercraft := 87 ;
81844: LD_ADDR_EXP 82
81848: PUSH
81849: LD_INT 87
81851: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
81852: LD_ADDR_EXP 83
81856: PUSH
81857: LD_INT 88
81859: ST_TO_ADDR
// class_mastodont := 31 ;
81860: LD_ADDR_EXP 84
81864: PUSH
81865: LD_INT 31
81867: ST_TO_ADDR
// class_horse := 21 ;
81868: LD_ADDR_EXP 85
81872: PUSH
81873: LD_INT 21
81875: ST_TO_ADDR
// end ;
81876: LD_VAR 0 1
81880: RET
// every 1 do
81881: GO 81883
81883: DISABLE
// InitGlobalVariables ; end_of_file
81884: CALL 81721 0 0
81888: END
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
81889: LD_INT 0
81891: PPUSH
81892: PPUSH
81893: PPUSH
81894: PPUSH
81895: PPUSH
81896: PPUSH
81897: PPUSH
81898: PPUSH
81899: PPUSH
81900: PPUSH
81901: PPUSH
81902: PPUSH
81903: PPUSH
81904: PPUSH
81905: PPUSH
81906: PPUSH
81907: PPUSH
81908: PPUSH
81909: PPUSH
81910: PPUSH
81911: PPUSH
81912: PPUSH
81913: PPUSH
81914: PPUSH
81915: PPUSH
81916: PPUSH
81917: PPUSH
81918: PPUSH
81919: PPUSH
81920: PPUSH
81921: PPUSH
81922: PPUSH
81923: PPUSH
81924: PPUSH
// if not list then
81925: LD_VAR 0 1
81929: NOT
81930: IFFALSE 81934
// exit ;
81932: GO 86593
// base := list [ 1 ] ;
81934: LD_ADDR_VAR 0 3
81938: PUSH
81939: LD_VAR 0 1
81943: PUSH
81944: LD_INT 1
81946: ARRAY
81947: ST_TO_ADDR
// group := list [ 2 ] ;
81948: LD_ADDR_VAR 0 4
81952: PUSH
81953: LD_VAR 0 1
81957: PUSH
81958: LD_INT 2
81960: ARRAY
81961: ST_TO_ADDR
// path := list [ 3 ] ;
81962: LD_ADDR_VAR 0 5
81966: PUSH
81967: LD_VAR 0 1
81971: PUSH
81972: LD_INT 3
81974: ARRAY
81975: ST_TO_ADDR
// flags := list [ 4 ] ;
81976: LD_ADDR_VAR 0 6
81980: PUSH
81981: LD_VAR 0 1
81985: PUSH
81986: LD_INT 4
81988: ARRAY
81989: ST_TO_ADDR
// mined := [ ] ;
81990: LD_ADDR_VAR 0 27
81994: PUSH
81995: EMPTY
81996: ST_TO_ADDR
// bombed := [ ] ;
81997: LD_ADDR_VAR 0 28
82001: PUSH
82002: EMPTY
82003: ST_TO_ADDR
// healers := [ ] ;
82004: LD_ADDR_VAR 0 31
82008: PUSH
82009: EMPTY
82010: ST_TO_ADDR
// to_heal := [ ] ;
82011: LD_ADDR_VAR 0 30
82015: PUSH
82016: EMPTY
82017: ST_TO_ADDR
// repairs := [ ] ;
82018: LD_ADDR_VAR 0 33
82022: PUSH
82023: EMPTY
82024: ST_TO_ADDR
// to_repair := [ ] ;
82025: LD_ADDR_VAR 0 32
82029: PUSH
82030: EMPTY
82031: ST_TO_ADDR
// if not group or not path then
82032: LD_VAR 0 4
82036: NOT
82037: PUSH
82038: LD_VAR 0 5
82042: NOT
82043: OR
82044: IFFALSE 82048
// exit ;
82046: GO 86593
// side := GetSide ( group [ 1 ] ) ;
82048: LD_ADDR_VAR 0 35
82052: PUSH
82053: LD_VAR 0 4
82057: PUSH
82058: LD_INT 1
82060: ARRAY
82061: PPUSH
82062: CALL_OW 255
82066: ST_TO_ADDR
// if flags then
82067: LD_VAR 0 6
82071: IFFALSE 82215
// begin f_ignore_area := flags [ 1 ] ;
82073: LD_ADDR_VAR 0 17
82077: PUSH
82078: LD_VAR 0 6
82082: PUSH
82083: LD_INT 1
82085: ARRAY
82086: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
82087: LD_ADDR_VAR 0 18
82091: PUSH
82092: LD_VAR 0 6
82096: PUSH
82097: LD_INT 2
82099: ARRAY
82100: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
82101: LD_ADDR_VAR 0 19
82105: PUSH
82106: LD_VAR 0 6
82110: PUSH
82111: LD_INT 3
82113: ARRAY
82114: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
82115: LD_ADDR_VAR 0 20
82119: PUSH
82120: LD_VAR 0 6
82124: PUSH
82125: LD_INT 4
82127: ARRAY
82128: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
82129: LD_ADDR_VAR 0 21
82133: PUSH
82134: LD_VAR 0 6
82138: PUSH
82139: LD_INT 5
82141: ARRAY
82142: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
82143: LD_ADDR_VAR 0 22
82147: PUSH
82148: LD_VAR 0 6
82152: PUSH
82153: LD_INT 6
82155: ARRAY
82156: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
82157: LD_ADDR_VAR 0 23
82161: PUSH
82162: LD_VAR 0 6
82166: PUSH
82167: LD_INT 7
82169: ARRAY
82170: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
82171: LD_ADDR_VAR 0 24
82175: PUSH
82176: LD_VAR 0 6
82180: PUSH
82181: LD_INT 8
82183: ARRAY
82184: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
82185: LD_ADDR_VAR 0 25
82189: PUSH
82190: LD_VAR 0 6
82194: PUSH
82195: LD_INT 9
82197: ARRAY
82198: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
82199: LD_ADDR_VAR 0 26
82203: PUSH
82204: LD_VAR 0 6
82208: PUSH
82209: LD_INT 10
82211: ARRAY
82212: ST_TO_ADDR
// end else
82213: GO 82295
// begin f_ignore_area := false ;
82215: LD_ADDR_VAR 0 17
82219: PUSH
82220: LD_INT 0
82222: ST_TO_ADDR
// f_capture := false ;
82223: LD_ADDR_VAR 0 18
82227: PUSH
82228: LD_INT 0
82230: ST_TO_ADDR
// f_ignore_civ := false ;
82231: LD_ADDR_VAR 0 19
82235: PUSH
82236: LD_INT 0
82238: ST_TO_ADDR
// f_murder := false ;
82239: LD_ADDR_VAR 0 20
82243: PUSH
82244: LD_INT 0
82246: ST_TO_ADDR
// f_mines := false ;
82247: LD_ADDR_VAR 0 21
82251: PUSH
82252: LD_INT 0
82254: ST_TO_ADDR
// f_repair := false ;
82255: LD_ADDR_VAR 0 22
82259: PUSH
82260: LD_INT 0
82262: ST_TO_ADDR
// f_heal := false ;
82263: LD_ADDR_VAR 0 23
82267: PUSH
82268: LD_INT 0
82270: ST_TO_ADDR
// f_spacetime := false ;
82271: LD_ADDR_VAR 0 24
82275: PUSH
82276: LD_INT 0
82278: ST_TO_ADDR
// f_attack_depot := false ;
82279: LD_ADDR_VAR 0 25
82283: PUSH
82284: LD_INT 0
82286: ST_TO_ADDR
// f_crawl := false ;
82287: LD_ADDR_VAR 0 26
82291: PUSH
82292: LD_INT 0
82294: ST_TO_ADDR
// end ; if f_heal then
82295: LD_VAR 0 23
82299: IFFALSE 82326
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
82301: LD_ADDR_VAR 0 31
82305: PUSH
82306: LD_VAR 0 4
82310: PPUSH
82311: LD_INT 25
82313: PUSH
82314: LD_INT 4
82316: PUSH
82317: EMPTY
82318: LIST
82319: LIST
82320: PPUSH
82321: CALL_OW 72
82325: ST_TO_ADDR
// if f_repair then
82326: LD_VAR 0 22
82330: IFFALSE 82357
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
82332: LD_ADDR_VAR 0 33
82336: PUSH
82337: LD_VAR 0 4
82341: PPUSH
82342: LD_INT 25
82344: PUSH
82345: LD_INT 3
82347: PUSH
82348: EMPTY
82349: LIST
82350: LIST
82351: PPUSH
82352: CALL_OW 72
82356: ST_TO_ADDR
// units_path := [ ] ;
82357: LD_ADDR_VAR 0 16
82361: PUSH
82362: EMPTY
82363: ST_TO_ADDR
// for i = 1 to group do
82364: LD_ADDR_VAR 0 7
82368: PUSH
82369: DOUBLE
82370: LD_INT 1
82372: DEC
82373: ST_TO_ADDR
82374: LD_VAR 0 4
82378: PUSH
82379: FOR_TO
82380: IFFALSE 82409
// units_path := Replace ( units_path , i , path ) ;
82382: LD_ADDR_VAR 0 16
82386: PUSH
82387: LD_VAR 0 16
82391: PPUSH
82392: LD_VAR 0 7
82396: PPUSH
82397: LD_VAR 0 5
82401: PPUSH
82402: CALL_OW 1
82406: ST_TO_ADDR
82407: GO 82379
82409: POP
82410: POP
// repeat for i = group downto 1 do
82411: LD_ADDR_VAR 0 7
82415: PUSH
82416: DOUBLE
82417: LD_VAR 0 4
82421: INC
82422: ST_TO_ADDR
82423: LD_INT 1
82425: PUSH
82426: FOR_DOWNTO
82427: IFFALSE 86549
// begin wait ( 5 ) ;
82429: LD_INT 5
82431: PPUSH
82432: CALL_OW 67
// tmp := [ ] ;
82436: LD_ADDR_VAR 0 14
82440: PUSH
82441: EMPTY
82442: ST_TO_ADDR
// attacking := false ;
82443: LD_ADDR_VAR 0 29
82447: PUSH
82448: LD_INT 0
82450: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
82451: LD_VAR 0 4
82455: PUSH
82456: LD_VAR 0 7
82460: ARRAY
82461: PPUSH
82462: CALL_OW 301
82466: PUSH
82467: LD_VAR 0 4
82471: PUSH
82472: LD_VAR 0 7
82476: ARRAY
82477: NOT
82478: OR
82479: IFFALSE 82588
// begin if GetType ( group [ i ] ) = unit_human then
82481: LD_VAR 0 4
82485: PUSH
82486: LD_VAR 0 7
82490: ARRAY
82491: PPUSH
82492: CALL_OW 247
82496: PUSH
82497: LD_INT 1
82499: EQUAL
82500: IFFALSE 82546
// begin to_heal := to_heal diff group [ i ] ;
82502: LD_ADDR_VAR 0 30
82506: PUSH
82507: LD_VAR 0 30
82511: PUSH
82512: LD_VAR 0 4
82516: PUSH
82517: LD_VAR 0 7
82521: ARRAY
82522: DIFF
82523: ST_TO_ADDR
// healers := healers diff group [ i ] ;
82524: LD_ADDR_VAR 0 31
82528: PUSH
82529: LD_VAR 0 31
82533: PUSH
82534: LD_VAR 0 4
82538: PUSH
82539: LD_VAR 0 7
82543: ARRAY
82544: DIFF
82545: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
82546: LD_ADDR_VAR 0 4
82550: PUSH
82551: LD_VAR 0 4
82555: PPUSH
82556: LD_VAR 0 7
82560: PPUSH
82561: CALL_OW 3
82565: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
82566: LD_ADDR_VAR 0 16
82570: PUSH
82571: LD_VAR 0 16
82575: PPUSH
82576: LD_VAR 0 7
82580: PPUSH
82581: CALL_OW 3
82585: ST_TO_ADDR
// continue ;
82586: GO 82426
// end ; if f_repair then
82588: LD_VAR 0 22
82592: IFFALSE 83081
// begin if GetType ( group [ i ] ) = unit_vehicle then
82594: LD_VAR 0 4
82598: PUSH
82599: LD_VAR 0 7
82603: ARRAY
82604: PPUSH
82605: CALL_OW 247
82609: PUSH
82610: LD_INT 2
82612: EQUAL
82613: IFFALSE 82803
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
82615: LD_VAR 0 4
82619: PUSH
82620: LD_VAR 0 7
82624: ARRAY
82625: PPUSH
82626: CALL_OW 256
82630: PUSH
82631: LD_INT 700
82633: LESS
82634: PUSH
82635: LD_VAR 0 4
82639: PUSH
82640: LD_VAR 0 7
82644: ARRAY
82645: PUSH
82646: LD_VAR 0 32
82650: IN
82651: NOT
82652: AND
82653: IFFALSE 82677
// to_repair := to_repair union group [ i ] ;
82655: LD_ADDR_VAR 0 32
82659: PUSH
82660: LD_VAR 0 32
82664: PUSH
82665: LD_VAR 0 4
82669: PUSH
82670: LD_VAR 0 7
82674: ARRAY
82675: UNION
82676: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
82677: LD_VAR 0 4
82681: PUSH
82682: LD_VAR 0 7
82686: ARRAY
82687: PPUSH
82688: CALL_OW 256
82692: PUSH
82693: LD_INT 1000
82695: EQUAL
82696: PUSH
82697: LD_VAR 0 4
82701: PUSH
82702: LD_VAR 0 7
82706: ARRAY
82707: PUSH
82708: LD_VAR 0 32
82712: IN
82713: AND
82714: IFFALSE 82738
// to_repair := to_repair diff group [ i ] ;
82716: LD_ADDR_VAR 0 32
82720: PUSH
82721: LD_VAR 0 32
82725: PUSH
82726: LD_VAR 0 4
82730: PUSH
82731: LD_VAR 0 7
82735: ARRAY
82736: DIFF
82737: ST_TO_ADDR
// if group [ i ] in to_repair then
82738: LD_VAR 0 4
82742: PUSH
82743: LD_VAR 0 7
82747: ARRAY
82748: PUSH
82749: LD_VAR 0 32
82753: IN
82754: IFFALSE 82801
// begin if not IsInArea ( group [ i ] , f_repair ) then
82756: LD_VAR 0 4
82760: PUSH
82761: LD_VAR 0 7
82765: ARRAY
82766: PPUSH
82767: LD_VAR 0 22
82771: PPUSH
82772: CALL_OW 308
82776: NOT
82777: IFFALSE 82799
// ComMoveToArea ( group [ i ] , f_repair ) ;
82779: LD_VAR 0 4
82783: PUSH
82784: LD_VAR 0 7
82788: ARRAY
82789: PPUSH
82790: LD_VAR 0 22
82794: PPUSH
82795: CALL_OW 113
// continue ;
82799: GO 82426
// end ; end else
82801: GO 83081
// if group [ i ] in repairs then
82803: LD_VAR 0 4
82807: PUSH
82808: LD_VAR 0 7
82812: ARRAY
82813: PUSH
82814: LD_VAR 0 33
82818: IN
82819: IFFALSE 83081
// begin if IsInUnit ( group [ i ] ) then
82821: LD_VAR 0 4
82825: PUSH
82826: LD_VAR 0 7
82830: ARRAY
82831: PPUSH
82832: CALL_OW 310
82836: IFFALSE 82904
// begin z := IsInUnit ( group [ i ] ) ;
82838: LD_ADDR_VAR 0 13
82842: PUSH
82843: LD_VAR 0 4
82847: PUSH
82848: LD_VAR 0 7
82852: ARRAY
82853: PPUSH
82854: CALL_OW 310
82858: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
82859: LD_VAR 0 13
82863: PUSH
82864: LD_VAR 0 32
82868: IN
82869: PUSH
82870: LD_VAR 0 13
82874: PPUSH
82875: LD_VAR 0 22
82879: PPUSH
82880: CALL_OW 308
82884: AND
82885: IFFALSE 82902
// ComExitVehicle ( group [ i ] ) ;
82887: LD_VAR 0 4
82891: PUSH
82892: LD_VAR 0 7
82896: ARRAY
82897: PPUSH
82898: CALL_OW 121
// end else
82902: GO 83081
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
82904: LD_ADDR_VAR 0 13
82908: PUSH
82909: LD_VAR 0 4
82913: PPUSH
82914: LD_INT 95
82916: PUSH
82917: LD_VAR 0 22
82921: PUSH
82922: EMPTY
82923: LIST
82924: LIST
82925: PUSH
82926: LD_INT 58
82928: PUSH
82929: EMPTY
82930: LIST
82931: PUSH
82932: EMPTY
82933: LIST
82934: LIST
82935: PPUSH
82936: CALL_OW 72
82940: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
82941: LD_VAR 0 4
82945: PUSH
82946: LD_VAR 0 7
82950: ARRAY
82951: PPUSH
82952: CALL_OW 314
82956: NOT
82957: IFFALSE 83079
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
82959: LD_ADDR_VAR 0 10
82963: PUSH
82964: LD_VAR 0 13
82968: PPUSH
82969: LD_VAR 0 4
82973: PUSH
82974: LD_VAR 0 7
82978: ARRAY
82979: PPUSH
82980: CALL_OW 74
82984: ST_TO_ADDR
// if not x then
82985: LD_VAR 0 10
82989: NOT
82990: IFFALSE 82994
// continue ;
82992: GO 82426
// if GetLives ( x ) < 1000 then
82994: LD_VAR 0 10
82998: PPUSH
82999: CALL_OW 256
83003: PUSH
83004: LD_INT 1000
83006: LESS
83007: IFFALSE 83031
// ComRepairVehicle ( group [ i ] , x ) else
83009: LD_VAR 0 4
83013: PUSH
83014: LD_VAR 0 7
83018: ARRAY
83019: PPUSH
83020: LD_VAR 0 10
83024: PPUSH
83025: CALL_OW 129
83029: GO 83079
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
83031: LD_VAR 0 23
83035: PUSH
83036: LD_VAR 0 4
83040: PUSH
83041: LD_VAR 0 7
83045: ARRAY
83046: PPUSH
83047: CALL_OW 256
83051: PUSH
83052: LD_INT 1000
83054: LESS
83055: AND
83056: NOT
83057: IFFALSE 83079
// ComEnterUnit ( group [ i ] , x ) ;
83059: LD_VAR 0 4
83063: PUSH
83064: LD_VAR 0 7
83068: ARRAY
83069: PPUSH
83070: LD_VAR 0 10
83074: PPUSH
83075: CALL_OW 120
// end ; continue ;
83079: GO 82426
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
83081: LD_VAR 0 23
83085: PUSH
83086: LD_VAR 0 4
83090: PUSH
83091: LD_VAR 0 7
83095: ARRAY
83096: PPUSH
83097: CALL_OW 247
83101: PUSH
83102: LD_INT 1
83104: EQUAL
83105: AND
83106: IFFALSE 83584
// begin if group [ i ] in healers then
83108: LD_VAR 0 4
83112: PUSH
83113: LD_VAR 0 7
83117: ARRAY
83118: PUSH
83119: LD_VAR 0 31
83123: IN
83124: IFFALSE 83397
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
83126: LD_VAR 0 4
83130: PUSH
83131: LD_VAR 0 7
83135: ARRAY
83136: PPUSH
83137: LD_VAR 0 23
83141: PPUSH
83142: CALL_OW 308
83146: NOT
83147: PUSH
83148: LD_VAR 0 4
83152: PUSH
83153: LD_VAR 0 7
83157: ARRAY
83158: PPUSH
83159: CALL_OW 314
83163: NOT
83164: AND
83165: IFFALSE 83189
// ComMoveToArea ( group [ i ] , f_heal ) else
83167: LD_VAR 0 4
83171: PUSH
83172: LD_VAR 0 7
83176: ARRAY
83177: PPUSH
83178: LD_VAR 0 23
83182: PPUSH
83183: CALL_OW 113
83187: GO 83395
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
83189: LD_VAR 0 4
83193: PUSH
83194: LD_VAR 0 7
83198: ARRAY
83199: PPUSH
83200: CALL 45070 0 1
83204: PPUSH
83205: CALL_OW 256
83209: PUSH
83210: LD_INT 1000
83212: EQUAL
83213: IFFALSE 83232
// ComStop ( group [ i ] ) else
83215: LD_VAR 0 4
83219: PUSH
83220: LD_VAR 0 7
83224: ARRAY
83225: PPUSH
83226: CALL_OW 141
83230: GO 83395
// if not HasTask ( group [ i ] ) and to_heal then
83232: LD_VAR 0 4
83236: PUSH
83237: LD_VAR 0 7
83241: ARRAY
83242: PPUSH
83243: CALL_OW 314
83247: NOT
83248: PUSH
83249: LD_VAR 0 30
83253: AND
83254: IFFALSE 83395
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
83256: LD_ADDR_VAR 0 13
83260: PUSH
83261: LD_VAR 0 30
83265: PPUSH
83266: LD_INT 3
83268: PUSH
83269: LD_INT 54
83271: PUSH
83272: EMPTY
83273: LIST
83274: PUSH
83275: EMPTY
83276: LIST
83277: LIST
83278: PPUSH
83279: CALL_OW 72
83283: PPUSH
83284: LD_VAR 0 4
83288: PUSH
83289: LD_VAR 0 7
83293: ARRAY
83294: PPUSH
83295: CALL_OW 74
83299: ST_TO_ADDR
// if z then
83300: LD_VAR 0 13
83304: IFFALSE 83395
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
83306: LD_INT 91
83308: PUSH
83309: LD_VAR 0 13
83313: PUSH
83314: LD_INT 10
83316: PUSH
83317: EMPTY
83318: LIST
83319: LIST
83320: LIST
83321: PUSH
83322: LD_INT 81
83324: PUSH
83325: LD_VAR 0 13
83329: PPUSH
83330: CALL_OW 255
83334: PUSH
83335: EMPTY
83336: LIST
83337: LIST
83338: PUSH
83339: EMPTY
83340: LIST
83341: LIST
83342: PPUSH
83343: CALL_OW 69
83347: PUSH
83348: LD_INT 0
83350: EQUAL
83351: IFFALSE 83375
// ComHeal ( group [ i ] , z ) else
83353: LD_VAR 0 4
83357: PUSH
83358: LD_VAR 0 7
83362: ARRAY
83363: PPUSH
83364: LD_VAR 0 13
83368: PPUSH
83369: CALL_OW 128
83373: GO 83395
// ComMoveToArea ( group [ i ] , f_heal ) ;
83375: LD_VAR 0 4
83379: PUSH
83380: LD_VAR 0 7
83384: ARRAY
83385: PPUSH
83386: LD_VAR 0 23
83390: PPUSH
83391: CALL_OW 113
// end ; continue ;
83395: GO 82426
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
83397: LD_VAR 0 4
83401: PUSH
83402: LD_VAR 0 7
83406: ARRAY
83407: PPUSH
83408: CALL_OW 256
83412: PUSH
83413: LD_INT 700
83415: LESS
83416: PUSH
83417: LD_VAR 0 4
83421: PUSH
83422: LD_VAR 0 7
83426: ARRAY
83427: PUSH
83428: LD_VAR 0 30
83432: IN
83433: NOT
83434: AND
83435: IFFALSE 83459
// to_heal := to_heal union group [ i ] ;
83437: LD_ADDR_VAR 0 30
83441: PUSH
83442: LD_VAR 0 30
83446: PUSH
83447: LD_VAR 0 4
83451: PUSH
83452: LD_VAR 0 7
83456: ARRAY
83457: UNION
83458: ST_TO_ADDR
// if group [ i ] in to_heal then
83459: LD_VAR 0 4
83463: PUSH
83464: LD_VAR 0 7
83468: ARRAY
83469: PUSH
83470: LD_VAR 0 30
83474: IN
83475: IFFALSE 83584
// begin if GetLives ( group [ i ] ) = 1000 then
83477: LD_VAR 0 4
83481: PUSH
83482: LD_VAR 0 7
83486: ARRAY
83487: PPUSH
83488: CALL_OW 256
83492: PUSH
83493: LD_INT 1000
83495: EQUAL
83496: IFFALSE 83522
// to_heal := to_heal diff group [ i ] else
83498: LD_ADDR_VAR 0 30
83502: PUSH
83503: LD_VAR 0 30
83507: PUSH
83508: LD_VAR 0 4
83512: PUSH
83513: LD_VAR 0 7
83517: ARRAY
83518: DIFF
83519: ST_TO_ADDR
83520: GO 83584
// begin if not IsInArea ( group [ i ] , to_heal ) then
83522: LD_VAR 0 4
83526: PUSH
83527: LD_VAR 0 7
83531: ARRAY
83532: PPUSH
83533: LD_VAR 0 30
83537: PPUSH
83538: CALL_OW 308
83542: NOT
83543: IFFALSE 83567
// ComMoveToArea ( group [ i ] , f_heal ) else
83545: LD_VAR 0 4
83549: PUSH
83550: LD_VAR 0 7
83554: ARRAY
83555: PPUSH
83556: LD_VAR 0 23
83560: PPUSH
83561: CALL_OW 113
83565: GO 83582
// ComHold ( group [ i ] ) ;
83567: LD_VAR 0 4
83571: PUSH
83572: LD_VAR 0 7
83576: ARRAY
83577: PPUSH
83578: CALL_OW 140
// continue ;
83582: GO 82426
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
83584: LD_VAR 0 4
83588: PUSH
83589: LD_VAR 0 7
83593: ARRAY
83594: PPUSH
83595: LD_INT 10
83597: PPUSH
83598: CALL 43490 0 2
83602: NOT
83603: PUSH
83604: LD_VAR 0 16
83608: PUSH
83609: LD_VAR 0 7
83613: ARRAY
83614: PUSH
83615: EMPTY
83616: EQUAL
83617: NOT
83618: AND
83619: IFFALSE 83885
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
83621: LD_VAR 0 4
83625: PUSH
83626: LD_VAR 0 7
83630: ARRAY
83631: PPUSH
83632: CALL_OW 262
83636: PUSH
83637: LD_INT 1
83639: PUSH
83640: LD_INT 2
83642: PUSH
83643: EMPTY
83644: LIST
83645: LIST
83646: IN
83647: IFFALSE 83688
// if GetFuel ( group [ i ] ) < 10 then
83649: LD_VAR 0 4
83653: PUSH
83654: LD_VAR 0 7
83658: ARRAY
83659: PPUSH
83660: CALL_OW 261
83664: PUSH
83665: LD_INT 10
83667: LESS
83668: IFFALSE 83688
// SetFuel ( group [ i ] , 12 ) ;
83670: LD_VAR 0 4
83674: PUSH
83675: LD_VAR 0 7
83679: ARRAY
83680: PPUSH
83681: LD_INT 12
83683: PPUSH
83684: CALL_OW 240
// if units_path [ i ] then
83688: LD_VAR 0 16
83692: PUSH
83693: LD_VAR 0 7
83697: ARRAY
83698: IFFALSE 83883
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
83700: LD_VAR 0 4
83704: PUSH
83705: LD_VAR 0 7
83709: ARRAY
83710: PPUSH
83711: LD_VAR 0 16
83715: PUSH
83716: LD_VAR 0 7
83720: ARRAY
83721: PUSH
83722: LD_INT 1
83724: ARRAY
83725: PUSH
83726: LD_INT 1
83728: ARRAY
83729: PPUSH
83730: LD_VAR 0 16
83734: PUSH
83735: LD_VAR 0 7
83739: ARRAY
83740: PUSH
83741: LD_INT 1
83743: ARRAY
83744: PUSH
83745: LD_INT 2
83747: ARRAY
83748: PPUSH
83749: CALL_OW 297
83753: PUSH
83754: LD_INT 6
83756: GREATER
83757: IFFALSE 83832
// begin if not HasTask ( group [ i ] ) then
83759: LD_VAR 0 4
83763: PUSH
83764: LD_VAR 0 7
83768: ARRAY
83769: PPUSH
83770: CALL_OW 314
83774: NOT
83775: IFFALSE 83830
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
83777: LD_VAR 0 4
83781: PUSH
83782: LD_VAR 0 7
83786: ARRAY
83787: PPUSH
83788: LD_VAR 0 16
83792: PUSH
83793: LD_VAR 0 7
83797: ARRAY
83798: PUSH
83799: LD_INT 1
83801: ARRAY
83802: PUSH
83803: LD_INT 1
83805: ARRAY
83806: PPUSH
83807: LD_VAR 0 16
83811: PUSH
83812: LD_VAR 0 7
83816: ARRAY
83817: PUSH
83818: LD_INT 1
83820: ARRAY
83821: PUSH
83822: LD_INT 2
83824: ARRAY
83825: PPUSH
83826: CALL_OW 114
// end else
83830: GO 83883
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
83832: LD_ADDR_VAR 0 15
83836: PUSH
83837: LD_VAR 0 16
83841: PUSH
83842: LD_VAR 0 7
83846: ARRAY
83847: PPUSH
83848: LD_INT 1
83850: PPUSH
83851: CALL_OW 3
83855: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
83856: LD_ADDR_VAR 0 16
83860: PUSH
83861: LD_VAR 0 16
83865: PPUSH
83866: LD_VAR 0 7
83870: PPUSH
83871: LD_VAR 0 15
83875: PPUSH
83876: CALL_OW 1
83880: ST_TO_ADDR
// continue ;
83881: GO 82426
// end ; end ; end else
83883: GO 86547
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
83885: LD_ADDR_VAR 0 14
83889: PUSH
83890: LD_INT 81
83892: PUSH
83893: LD_VAR 0 4
83897: PUSH
83898: LD_VAR 0 7
83902: ARRAY
83903: PPUSH
83904: CALL_OW 255
83908: PUSH
83909: EMPTY
83910: LIST
83911: LIST
83912: PPUSH
83913: CALL_OW 69
83917: ST_TO_ADDR
// if not tmp then
83918: LD_VAR 0 14
83922: NOT
83923: IFFALSE 83927
// continue ;
83925: GO 82426
// if f_ignore_area then
83927: LD_VAR 0 17
83931: IFFALSE 84019
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
83933: LD_ADDR_VAR 0 15
83937: PUSH
83938: LD_VAR 0 14
83942: PPUSH
83943: LD_INT 3
83945: PUSH
83946: LD_INT 92
83948: PUSH
83949: LD_VAR 0 17
83953: PUSH
83954: LD_INT 1
83956: ARRAY
83957: PUSH
83958: LD_VAR 0 17
83962: PUSH
83963: LD_INT 2
83965: ARRAY
83966: PUSH
83967: LD_VAR 0 17
83971: PUSH
83972: LD_INT 3
83974: ARRAY
83975: PUSH
83976: EMPTY
83977: LIST
83978: LIST
83979: LIST
83980: LIST
83981: PUSH
83982: EMPTY
83983: LIST
83984: LIST
83985: PPUSH
83986: CALL_OW 72
83990: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
83991: LD_VAR 0 14
83995: PUSH
83996: LD_VAR 0 15
84000: DIFF
84001: IFFALSE 84019
// tmp := tmp diff tmp2 ;
84003: LD_ADDR_VAR 0 14
84007: PUSH
84008: LD_VAR 0 14
84012: PUSH
84013: LD_VAR 0 15
84017: DIFF
84018: ST_TO_ADDR
// end ; if not f_murder then
84019: LD_VAR 0 20
84023: NOT
84024: IFFALSE 84082
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
84026: LD_ADDR_VAR 0 15
84030: PUSH
84031: LD_VAR 0 14
84035: PPUSH
84036: LD_INT 3
84038: PUSH
84039: LD_INT 50
84041: PUSH
84042: EMPTY
84043: LIST
84044: PUSH
84045: EMPTY
84046: LIST
84047: LIST
84048: PPUSH
84049: CALL_OW 72
84053: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
84054: LD_VAR 0 14
84058: PUSH
84059: LD_VAR 0 15
84063: DIFF
84064: IFFALSE 84082
// tmp := tmp diff tmp2 ;
84066: LD_ADDR_VAR 0 14
84070: PUSH
84071: LD_VAR 0 14
84075: PUSH
84076: LD_VAR 0 15
84080: DIFF
84081: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
84082: LD_ADDR_VAR 0 14
84086: PUSH
84087: LD_VAR 0 4
84091: PUSH
84092: LD_VAR 0 7
84096: ARRAY
84097: PPUSH
84098: LD_VAR 0 14
84102: PPUSH
84103: LD_INT 1
84105: PPUSH
84106: LD_INT 1
84108: PPUSH
84109: CALL 16425 0 4
84113: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
84114: LD_VAR 0 4
84118: PUSH
84119: LD_VAR 0 7
84123: ARRAY
84124: PPUSH
84125: CALL_OW 257
84129: PUSH
84130: LD_INT 1
84132: EQUAL
84133: IFFALSE 84581
// begin if WantPlant ( group [ i ] ) then
84135: LD_VAR 0 4
84139: PUSH
84140: LD_VAR 0 7
84144: ARRAY
84145: PPUSH
84146: CALL 15926 0 1
84150: IFFALSE 84154
// continue ;
84152: GO 82426
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
84154: LD_VAR 0 18
84158: PUSH
84159: LD_VAR 0 4
84163: PUSH
84164: LD_VAR 0 7
84168: ARRAY
84169: PPUSH
84170: CALL_OW 310
84174: NOT
84175: AND
84176: PUSH
84177: LD_VAR 0 14
84181: PUSH
84182: LD_INT 1
84184: ARRAY
84185: PUSH
84186: LD_VAR 0 14
84190: PPUSH
84191: LD_INT 21
84193: PUSH
84194: LD_INT 2
84196: PUSH
84197: EMPTY
84198: LIST
84199: LIST
84200: PUSH
84201: LD_INT 58
84203: PUSH
84204: EMPTY
84205: LIST
84206: PUSH
84207: EMPTY
84208: LIST
84209: LIST
84210: PPUSH
84211: CALL_OW 72
84215: IN
84216: AND
84217: IFFALSE 84253
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
84219: LD_VAR 0 4
84223: PUSH
84224: LD_VAR 0 7
84228: ARRAY
84229: PPUSH
84230: LD_VAR 0 14
84234: PUSH
84235: LD_INT 1
84237: ARRAY
84238: PPUSH
84239: CALL_OW 120
// attacking := true ;
84243: LD_ADDR_VAR 0 29
84247: PUSH
84248: LD_INT 1
84250: ST_TO_ADDR
// continue ;
84251: GO 82426
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
84253: LD_VAR 0 26
84257: PUSH
84258: LD_VAR 0 4
84262: PUSH
84263: LD_VAR 0 7
84267: ARRAY
84268: PPUSH
84269: CALL_OW 257
84273: PUSH
84274: LD_INT 1
84276: EQUAL
84277: AND
84278: PUSH
84279: LD_VAR 0 4
84283: PUSH
84284: LD_VAR 0 7
84288: ARRAY
84289: PPUSH
84290: CALL_OW 256
84294: PUSH
84295: LD_INT 800
84297: LESS
84298: AND
84299: PUSH
84300: LD_VAR 0 4
84304: PUSH
84305: LD_VAR 0 7
84309: ARRAY
84310: PPUSH
84311: CALL_OW 318
84315: NOT
84316: AND
84317: IFFALSE 84334
// ComCrawl ( group [ i ] ) ;
84319: LD_VAR 0 4
84323: PUSH
84324: LD_VAR 0 7
84328: ARRAY
84329: PPUSH
84330: CALL_OW 137
// if f_mines then
84334: LD_VAR 0 21
84338: IFFALSE 84581
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
84340: LD_VAR 0 14
84344: PUSH
84345: LD_INT 1
84347: ARRAY
84348: PPUSH
84349: CALL_OW 247
84353: PUSH
84354: LD_INT 3
84356: EQUAL
84357: PUSH
84358: LD_VAR 0 14
84362: PUSH
84363: LD_INT 1
84365: ARRAY
84366: PUSH
84367: LD_VAR 0 27
84371: IN
84372: NOT
84373: AND
84374: IFFALSE 84581
// begin x := GetX ( tmp [ 1 ] ) ;
84376: LD_ADDR_VAR 0 10
84380: PUSH
84381: LD_VAR 0 14
84385: PUSH
84386: LD_INT 1
84388: ARRAY
84389: PPUSH
84390: CALL_OW 250
84394: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
84395: LD_ADDR_VAR 0 11
84399: PUSH
84400: LD_VAR 0 14
84404: PUSH
84405: LD_INT 1
84407: ARRAY
84408: PPUSH
84409: CALL_OW 251
84413: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
84414: LD_ADDR_VAR 0 12
84418: PUSH
84419: LD_VAR 0 4
84423: PUSH
84424: LD_VAR 0 7
84428: ARRAY
84429: PPUSH
84430: CALL 43575 0 1
84434: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
84435: LD_VAR 0 4
84439: PUSH
84440: LD_VAR 0 7
84444: ARRAY
84445: PPUSH
84446: LD_VAR 0 10
84450: PPUSH
84451: LD_VAR 0 11
84455: PPUSH
84456: LD_VAR 0 14
84460: PUSH
84461: LD_INT 1
84463: ARRAY
84464: PPUSH
84465: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
84469: LD_VAR 0 4
84473: PUSH
84474: LD_VAR 0 7
84478: ARRAY
84479: PPUSH
84480: LD_VAR 0 10
84484: PPUSH
84485: LD_VAR 0 12
84489: PPUSH
84490: LD_INT 7
84492: PPUSH
84493: CALL_OW 272
84497: PPUSH
84498: LD_VAR 0 11
84502: PPUSH
84503: LD_VAR 0 12
84507: PPUSH
84508: LD_INT 7
84510: PPUSH
84511: CALL_OW 273
84515: PPUSH
84516: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
84520: LD_VAR 0 4
84524: PUSH
84525: LD_VAR 0 7
84529: ARRAY
84530: PPUSH
84531: LD_INT 71
84533: PPUSH
84534: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
84538: LD_ADDR_VAR 0 27
84542: PUSH
84543: LD_VAR 0 27
84547: PPUSH
84548: LD_VAR 0 27
84552: PUSH
84553: LD_INT 1
84555: PLUS
84556: PPUSH
84557: LD_VAR 0 14
84561: PUSH
84562: LD_INT 1
84564: ARRAY
84565: PPUSH
84566: CALL_OW 1
84570: ST_TO_ADDR
// attacking := true ;
84571: LD_ADDR_VAR 0 29
84575: PUSH
84576: LD_INT 1
84578: ST_TO_ADDR
// continue ;
84579: GO 82426
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
84581: LD_VAR 0 4
84585: PUSH
84586: LD_VAR 0 7
84590: ARRAY
84591: PPUSH
84592: CALL_OW 257
84596: PUSH
84597: LD_INT 17
84599: EQUAL
84600: PUSH
84601: LD_VAR 0 4
84605: PUSH
84606: LD_VAR 0 7
84610: ARRAY
84611: PPUSH
84612: CALL_OW 110
84616: PUSH
84617: LD_INT 71
84619: EQUAL
84620: NOT
84621: AND
84622: IFFALSE 84768
// begin attacking := false ;
84624: LD_ADDR_VAR 0 29
84628: PUSH
84629: LD_INT 0
84631: ST_TO_ADDR
// k := 5 ;
84632: LD_ADDR_VAR 0 9
84636: PUSH
84637: LD_INT 5
84639: ST_TO_ADDR
// if tmp < k then
84640: LD_VAR 0 14
84644: PUSH
84645: LD_VAR 0 9
84649: LESS
84650: IFFALSE 84662
// k := tmp ;
84652: LD_ADDR_VAR 0 9
84656: PUSH
84657: LD_VAR 0 14
84661: ST_TO_ADDR
// for j = 1 to k do
84662: LD_ADDR_VAR 0 8
84666: PUSH
84667: DOUBLE
84668: LD_INT 1
84670: DEC
84671: ST_TO_ADDR
84672: LD_VAR 0 9
84676: PUSH
84677: FOR_TO
84678: IFFALSE 84766
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
84680: LD_VAR 0 14
84684: PUSH
84685: LD_VAR 0 8
84689: ARRAY
84690: PUSH
84691: LD_VAR 0 14
84695: PPUSH
84696: LD_INT 58
84698: PUSH
84699: EMPTY
84700: LIST
84701: PPUSH
84702: CALL_OW 72
84706: IN
84707: NOT
84708: IFFALSE 84764
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
84710: LD_VAR 0 4
84714: PUSH
84715: LD_VAR 0 7
84719: ARRAY
84720: PPUSH
84721: LD_VAR 0 14
84725: PUSH
84726: LD_VAR 0 8
84730: ARRAY
84731: PPUSH
84732: CALL_OW 115
// attacking := true ;
84736: LD_ADDR_VAR 0 29
84740: PUSH
84741: LD_INT 1
84743: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
84744: LD_VAR 0 4
84748: PUSH
84749: LD_VAR 0 7
84753: ARRAY
84754: PPUSH
84755: LD_INT 71
84757: PPUSH
84758: CALL_OW 109
// continue ;
84762: GO 84677
// end ; end ;
84764: GO 84677
84766: POP
84767: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
84768: LD_VAR 0 4
84772: PUSH
84773: LD_VAR 0 7
84777: ARRAY
84778: PPUSH
84779: CALL_OW 257
84783: PUSH
84784: LD_INT 8
84786: EQUAL
84787: PUSH
84788: LD_VAR 0 4
84792: PUSH
84793: LD_VAR 0 7
84797: ARRAY
84798: PPUSH
84799: CALL_OW 264
84803: PUSH
84804: LD_INT 28
84806: PUSH
84807: LD_INT 45
84809: PUSH
84810: LD_INT 7
84812: PUSH
84813: LD_INT 47
84815: PUSH
84816: EMPTY
84817: LIST
84818: LIST
84819: LIST
84820: LIST
84821: IN
84822: OR
84823: IFFALSE 85079
// begin attacking := false ;
84825: LD_ADDR_VAR 0 29
84829: PUSH
84830: LD_INT 0
84832: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
84833: LD_VAR 0 14
84837: PUSH
84838: LD_INT 1
84840: ARRAY
84841: PPUSH
84842: CALL_OW 266
84846: PUSH
84847: LD_INT 32
84849: PUSH
84850: LD_INT 31
84852: PUSH
84853: LD_INT 33
84855: PUSH
84856: LD_INT 4
84858: PUSH
84859: LD_INT 5
84861: PUSH
84862: EMPTY
84863: LIST
84864: LIST
84865: LIST
84866: LIST
84867: LIST
84868: IN
84869: IFFALSE 85055
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
84871: LD_ADDR_VAR 0 9
84875: PUSH
84876: LD_VAR 0 14
84880: PUSH
84881: LD_INT 1
84883: ARRAY
84884: PPUSH
84885: CALL_OW 266
84889: PPUSH
84890: LD_VAR 0 14
84894: PUSH
84895: LD_INT 1
84897: ARRAY
84898: PPUSH
84899: CALL_OW 250
84903: PPUSH
84904: LD_VAR 0 14
84908: PUSH
84909: LD_INT 1
84911: ARRAY
84912: PPUSH
84913: CALL_OW 251
84917: PPUSH
84918: LD_VAR 0 14
84922: PUSH
84923: LD_INT 1
84925: ARRAY
84926: PPUSH
84927: CALL_OW 254
84931: PPUSH
84932: LD_VAR 0 14
84936: PUSH
84937: LD_INT 1
84939: ARRAY
84940: PPUSH
84941: CALL_OW 248
84945: PPUSH
84946: LD_INT 0
84948: PPUSH
84949: CALL 24945 0 6
84953: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
84954: LD_ADDR_VAR 0 8
84958: PUSH
84959: LD_VAR 0 4
84963: PUSH
84964: LD_VAR 0 7
84968: ARRAY
84969: PPUSH
84970: LD_VAR 0 9
84974: PPUSH
84975: CALL 43615 0 2
84979: ST_TO_ADDR
// if j then
84980: LD_VAR 0 8
84984: IFFALSE 85053
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
84986: LD_VAR 0 8
84990: PUSH
84991: LD_INT 1
84993: ARRAY
84994: PPUSH
84995: LD_VAR 0 8
84999: PUSH
85000: LD_INT 2
85002: ARRAY
85003: PPUSH
85004: CALL_OW 488
85008: IFFALSE 85053
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
85010: LD_VAR 0 4
85014: PUSH
85015: LD_VAR 0 7
85019: ARRAY
85020: PPUSH
85021: LD_VAR 0 8
85025: PUSH
85026: LD_INT 1
85028: ARRAY
85029: PPUSH
85030: LD_VAR 0 8
85034: PUSH
85035: LD_INT 2
85037: ARRAY
85038: PPUSH
85039: CALL_OW 116
// attacking := true ;
85043: LD_ADDR_VAR 0 29
85047: PUSH
85048: LD_INT 1
85050: ST_TO_ADDR
// continue ;
85051: GO 82426
// end ; end else
85053: GO 85079
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85055: LD_VAR 0 4
85059: PUSH
85060: LD_VAR 0 7
85064: ARRAY
85065: PPUSH
85066: LD_VAR 0 14
85070: PUSH
85071: LD_INT 1
85073: ARRAY
85074: PPUSH
85075: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
85079: LD_VAR 0 4
85083: PUSH
85084: LD_VAR 0 7
85088: ARRAY
85089: PPUSH
85090: CALL_OW 265
85094: PUSH
85095: LD_INT 11
85097: EQUAL
85098: IFFALSE 85376
// begin k := 10 ;
85100: LD_ADDR_VAR 0 9
85104: PUSH
85105: LD_INT 10
85107: ST_TO_ADDR
// x := 0 ;
85108: LD_ADDR_VAR 0 10
85112: PUSH
85113: LD_INT 0
85115: ST_TO_ADDR
// if tmp < k then
85116: LD_VAR 0 14
85120: PUSH
85121: LD_VAR 0 9
85125: LESS
85126: IFFALSE 85138
// k := tmp ;
85128: LD_ADDR_VAR 0 9
85132: PUSH
85133: LD_VAR 0 14
85137: ST_TO_ADDR
// for j = k downto 1 do
85138: LD_ADDR_VAR 0 8
85142: PUSH
85143: DOUBLE
85144: LD_VAR 0 9
85148: INC
85149: ST_TO_ADDR
85150: LD_INT 1
85152: PUSH
85153: FOR_DOWNTO
85154: IFFALSE 85229
// begin if GetType ( tmp [ j ] ) = unit_human then
85156: LD_VAR 0 14
85160: PUSH
85161: LD_VAR 0 8
85165: ARRAY
85166: PPUSH
85167: CALL_OW 247
85171: PUSH
85172: LD_INT 1
85174: EQUAL
85175: IFFALSE 85227
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
85177: LD_VAR 0 4
85181: PUSH
85182: LD_VAR 0 7
85186: ARRAY
85187: PPUSH
85188: LD_VAR 0 14
85192: PUSH
85193: LD_VAR 0 8
85197: ARRAY
85198: PPUSH
85199: CALL 43886 0 2
// x := tmp [ j ] ;
85203: LD_ADDR_VAR 0 10
85207: PUSH
85208: LD_VAR 0 14
85212: PUSH
85213: LD_VAR 0 8
85217: ARRAY
85218: ST_TO_ADDR
// attacking := true ;
85219: LD_ADDR_VAR 0 29
85223: PUSH
85224: LD_INT 1
85226: ST_TO_ADDR
// end ; end ;
85227: GO 85153
85229: POP
85230: POP
// if not x then
85231: LD_VAR 0 10
85235: NOT
85236: IFFALSE 85376
// begin attacking := true ;
85238: LD_ADDR_VAR 0 29
85242: PUSH
85243: LD_INT 1
85245: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
85246: LD_VAR 0 4
85250: PUSH
85251: LD_VAR 0 7
85255: ARRAY
85256: PPUSH
85257: CALL_OW 250
85261: PPUSH
85262: LD_VAR 0 4
85266: PUSH
85267: LD_VAR 0 7
85271: ARRAY
85272: PPUSH
85273: CALL_OW 251
85277: PPUSH
85278: CALL_OW 546
85282: PUSH
85283: LD_INT 2
85285: ARRAY
85286: PUSH
85287: LD_VAR 0 14
85291: PUSH
85292: LD_INT 1
85294: ARRAY
85295: PPUSH
85296: CALL_OW 250
85300: PPUSH
85301: LD_VAR 0 14
85305: PUSH
85306: LD_INT 1
85308: ARRAY
85309: PPUSH
85310: CALL_OW 251
85314: PPUSH
85315: CALL_OW 546
85319: PUSH
85320: LD_INT 2
85322: ARRAY
85323: EQUAL
85324: IFFALSE 85352
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
85326: LD_VAR 0 4
85330: PUSH
85331: LD_VAR 0 7
85335: ARRAY
85336: PPUSH
85337: LD_VAR 0 14
85341: PUSH
85342: LD_INT 1
85344: ARRAY
85345: PPUSH
85346: CALL 43886 0 2
85350: GO 85376
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85352: LD_VAR 0 4
85356: PUSH
85357: LD_VAR 0 7
85361: ARRAY
85362: PPUSH
85363: LD_VAR 0 14
85367: PUSH
85368: LD_INT 1
85370: ARRAY
85371: PPUSH
85372: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
85376: LD_VAR 0 4
85380: PUSH
85381: LD_VAR 0 7
85385: ARRAY
85386: PPUSH
85387: CALL_OW 264
85391: PUSH
85392: LD_INT 29
85394: EQUAL
85395: IFFALSE 85761
// begin if WantsToAttack ( group [ i ] ) in bombed then
85397: LD_VAR 0 4
85401: PUSH
85402: LD_VAR 0 7
85406: ARRAY
85407: PPUSH
85408: CALL_OW 319
85412: PUSH
85413: LD_VAR 0 28
85417: IN
85418: IFFALSE 85422
// continue ;
85420: GO 82426
// k := 8 ;
85422: LD_ADDR_VAR 0 9
85426: PUSH
85427: LD_INT 8
85429: ST_TO_ADDR
// x := 0 ;
85430: LD_ADDR_VAR 0 10
85434: PUSH
85435: LD_INT 0
85437: ST_TO_ADDR
// if tmp < k then
85438: LD_VAR 0 14
85442: PUSH
85443: LD_VAR 0 9
85447: LESS
85448: IFFALSE 85460
// k := tmp ;
85450: LD_ADDR_VAR 0 9
85454: PUSH
85455: LD_VAR 0 14
85459: ST_TO_ADDR
// for j = 1 to k do
85460: LD_ADDR_VAR 0 8
85464: PUSH
85465: DOUBLE
85466: LD_INT 1
85468: DEC
85469: ST_TO_ADDR
85470: LD_VAR 0 9
85474: PUSH
85475: FOR_TO
85476: IFFALSE 85608
// begin if GetType ( tmp [ j ] ) = unit_building then
85478: LD_VAR 0 14
85482: PUSH
85483: LD_VAR 0 8
85487: ARRAY
85488: PPUSH
85489: CALL_OW 247
85493: PUSH
85494: LD_INT 3
85496: EQUAL
85497: IFFALSE 85606
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
85499: LD_VAR 0 14
85503: PUSH
85504: LD_VAR 0 8
85508: ARRAY
85509: PUSH
85510: LD_VAR 0 28
85514: IN
85515: NOT
85516: PUSH
85517: LD_VAR 0 14
85521: PUSH
85522: LD_VAR 0 8
85526: ARRAY
85527: PPUSH
85528: CALL_OW 313
85532: AND
85533: IFFALSE 85606
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
85535: LD_VAR 0 4
85539: PUSH
85540: LD_VAR 0 7
85544: ARRAY
85545: PPUSH
85546: LD_VAR 0 14
85550: PUSH
85551: LD_VAR 0 8
85555: ARRAY
85556: PPUSH
85557: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
85561: LD_ADDR_VAR 0 28
85565: PUSH
85566: LD_VAR 0 28
85570: PPUSH
85571: LD_VAR 0 28
85575: PUSH
85576: LD_INT 1
85578: PLUS
85579: PPUSH
85580: LD_VAR 0 14
85584: PUSH
85585: LD_VAR 0 8
85589: ARRAY
85590: PPUSH
85591: CALL_OW 1
85595: ST_TO_ADDR
// attacking := true ;
85596: LD_ADDR_VAR 0 29
85600: PUSH
85601: LD_INT 1
85603: ST_TO_ADDR
// break ;
85604: GO 85608
// end ; end ;
85606: GO 85475
85608: POP
85609: POP
// if not attacking and f_attack_depot then
85610: LD_VAR 0 29
85614: NOT
85615: PUSH
85616: LD_VAR 0 25
85620: AND
85621: IFFALSE 85716
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
85623: LD_ADDR_VAR 0 13
85627: PUSH
85628: LD_VAR 0 14
85632: PPUSH
85633: LD_INT 2
85635: PUSH
85636: LD_INT 30
85638: PUSH
85639: LD_INT 0
85641: PUSH
85642: EMPTY
85643: LIST
85644: LIST
85645: PUSH
85646: LD_INT 30
85648: PUSH
85649: LD_INT 1
85651: PUSH
85652: EMPTY
85653: LIST
85654: LIST
85655: PUSH
85656: EMPTY
85657: LIST
85658: LIST
85659: LIST
85660: PPUSH
85661: CALL_OW 72
85665: ST_TO_ADDR
// if z then
85666: LD_VAR 0 13
85670: IFFALSE 85716
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
85672: LD_VAR 0 4
85676: PUSH
85677: LD_VAR 0 7
85681: ARRAY
85682: PPUSH
85683: LD_VAR 0 13
85687: PPUSH
85688: LD_VAR 0 4
85692: PUSH
85693: LD_VAR 0 7
85697: ARRAY
85698: PPUSH
85699: CALL_OW 74
85703: PPUSH
85704: CALL_OW 115
// attacking := true ;
85708: LD_ADDR_VAR 0 29
85712: PUSH
85713: LD_INT 1
85715: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
85716: LD_VAR 0 4
85720: PUSH
85721: LD_VAR 0 7
85725: ARRAY
85726: PPUSH
85727: CALL_OW 256
85731: PUSH
85732: LD_INT 500
85734: LESS
85735: IFFALSE 85761
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85737: LD_VAR 0 4
85741: PUSH
85742: LD_VAR 0 7
85746: ARRAY
85747: PPUSH
85748: LD_VAR 0 14
85752: PUSH
85753: LD_INT 1
85755: ARRAY
85756: PPUSH
85757: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
85761: LD_VAR 0 4
85765: PUSH
85766: LD_VAR 0 7
85770: ARRAY
85771: PPUSH
85772: CALL_OW 264
85776: PUSH
85777: LD_INT 49
85779: EQUAL
85780: IFFALSE 85901
// begin if not HasTask ( group [ i ] ) then
85782: LD_VAR 0 4
85786: PUSH
85787: LD_VAR 0 7
85791: ARRAY
85792: PPUSH
85793: CALL_OW 314
85797: NOT
85798: IFFALSE 85901
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
85800: LD_ADDR_VAR 0 9
85804: PUSH
85805: LD_INT 81
85807: PUSH
85808: LD_VAR 0 4
85812: PUSH
85813: LD_VAR 0 7
85817: ARRAY
85818: PPUSH
85819: CALL_OW 255
85823: PUSH
85824: EMPTY
85825: LIST
85826: LIST
85827: PPUSH
85828: CALL_OW 69
85832: PPUSH
85833: LD_VAR 0 4
85837: PUSH
85838: LD_VAR 0 7
85842: ARRAY
85843: PPUSH
85844: CALL_OW 74
85848: ST_TO_ADDR
// if k then
85849: LD_VAR 0 9
85853: IFFALSE 85901
// if GetDistUnits ( group [ i ] , k ) > 10 then
85855: LD_VAR 0 4
85859: PUSH
85860: LD_VAR 0 7
85864: ARRAY
85865: PPUSH
85866: LD_VAR 0 9
85870: PPUSH
85871: CALL_OW 296
85875: PUSH
85876: LD_INT 10
85878: GREATER
85879: IFFALSE 85901
// ComMoveUnit ( group [ i ] , k ) ;
85881: LD_VAR 0 4
85885: PUSH
85886: LD_VAR 0 7
85890: ARRAY
85891: PPUSH
85892: LD_VAR 0 9
85896: PPUSH
85897: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
85901: LD_VAR 0 4
85905: PUSH
85906: LD_VAR 0 7
85910: ARRAY
85911: PPUSH
85912: CALL_OW 256
85916: PUSH
85917: LD_INT 250
85919: LESS
85920: PUSH
85921: LD_VAR 0 4
85925: PUSH
85926: LD_VAR 0 7
85930: ARRAY
85931: PUSH
85932: LD_INT 21
85934: PUSH
85935: LD_INT 2
85937: PUSH
85938: EMPTY
85939: LIST
85940: LIST
85941: PUSH
85942: LD_INT 23
85944: PUSH
85945: LD_INT 2
85947: PUSH
85948: EMPTY
85949: LIST
85950: LIST
85951: PUSH
85952: EMPTY
85953: LIST
85954: LIST
85955: PPUSH
85956: CALL_OW 69
85960: IN
85961: AND
85962: IFFALSE 86087
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
85964: LD_ADDR_VAR 0 9
85968: PUSH
85969: LD_OWVAR 3
85973: PUSH
85974: LD_VAR 0 4
85978: PUSH
85979: LD_VAR 0 7
85983: ARRAY
85984: DIFF
85985: PPUSH
85986: LD_VAR 0 4
85990: PUSH
85991: LD_VAR 0 7
85995: ARRAY
85996: PPUSH
85997: CALL_OW 74
86001: ST_TO_ADDR
// if not k then
86002: LD_VAR 0 9
86006: NOT
86007: IFFALSE 86011
// continue ;
86009: GO 82426
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
86011: LD_VAR 0 9
86015: PUSH
86016: LD_INT 81
86018: PUSH
86019: LD_VAR 0 4
86023: PUSH
86024: LD_VAR 0 7
86028: ARRAY
86029: PPUSH
86030: CALL_OW 255
86034: PUSH
86035: EMPTY
86036: LIST
86037: LIST
86038: PPUSH
86039: CALL_OW 69
86043: IN
86044: PUSH
86045: LD_VAR 0 9
86049: PPUSH
86050: LD_VAR 0 4
86054: PUSH
86055: LD_VAR 0 7
86059: ARRAY
86060: PPUSH
86061: CALL_OW 296
86065: PUSH
86066: LD_INT 5
86068: LESS
86069: AND
86070: IFFALSE 86087
// ComAutodestruct ( group [ i ] ) ;
86072: LD_VAR 0 4
86076: PUSH
86077: LD_VAR 0 7
86081: ARRAY
86082: PPUSH
86083: CALL 43784 0 1
// end ; if f_attack_depot then
86087: LD_VAR 0 25
86091: IFFALSE 86203
// begin k := 6 ;
86093: LD_ADDR_VAR 0 9
86097: PUSH
86098: LD_INT 6
86100: ST_TO_ADDR
// if tmp < k then
86101: LD_VAR 0 14
86105: PUSH
86106: LD_VAR 0 9
86110: LESS
86111: IFFALSE 86123
// k := tmp ;
86113: LD_ADDR_VAR 0 9
86117: PUSH
86118: LD_VAR 0 14
86122: ST_TO_ADDR
// for j = 1 to k do
86123: LD_ADDR_VAR 0 8
86127: PUSH
86128: DOUBLE
86129: LD_INT 1
86131: DEC
86132: ST_TO_ADDR
86133: LD_VAR 0 9
86137: PUSH
86138: FOR_TO
86139: IFFALSE 86201
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
86141: LD_VAR 0 8
86145: PPUSH
86146: CALL_OW 266
86150: PUSH
86151: LD_INT 0
86153: PUSH
86154: LD_INT 1
86156: PUSH
86157: EMPTY
86158: LIST
86159: LIST
86160: IN
86161: IFFALSE 86199
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
86163: LD_VAR 0 4
86167: PUSH
86168: LD_VAR 0 7
86172: ARRAY
86173: PPUSH
86174: LD_VAR 0 14
86178: PUSH
86179: LD_VAR 0 8
86183: ARRAY
86184: PPUSH
86185: CALL_OW 115
// attacking := true ;
86189: LD_ADDR_VAR 0 29
86193: PUSH
86194: LD_INT 1
86196: ST_TO_ADDR
// break ;
86197: GO 86201
// end ;
86199: GO 86138
86201: POP
86202: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
86203: LD_VAR 0 4
86207: PUSH
86208: LD_VAR 0 7
86212: ARRAY
86213: PPUSH
86214: CALL_OW 302
86218: PUSH
86219: LD_VAR 0 29
86223: NOT
86224: AND
86225: IFFALSE 86547
// begin if GetTag ( group [ i ] ) = 71 then
86227: LD_VAR 0 4
86231: PUSH
86232: LD_VAR 0 7
86236: ARRAY
86237: PPUSH
86238: CALL_OW 110
86242: PUSH
86243: LD_INT 71
86245: EQUAL
86246: IFFALSE 86287
// begin if HasTask ( group [ i ] ) then
86248: LD_VAR 0 4
86252: PUSH
86253: LD_VAR 0 7
86257: ARRAY
86258: PPUSH
86259: CALL_OW 314
86263: IFFALSE 86269
// continue else
86265: GO 82426
86267: GO 86287
// SetTag ( group [ i ] , 0 ) ;
86269: LD_VAR 0 4
86273: PUSH
86274: LD_VAR 0 7
86278: ARRAY
86279: PPUSH
86280: LD_INT 0
86282: PPUSH
86283: CALL_OW 109
// end ; k := 8 ;
86287: LD_ADDR_VAR 0 9
86291: PUSH
86292: LD_INT 8
86294: ST_TO_ADDR
// x := 0 ;
86295: LD_ADDR_VAR 0 10
86299: PUSH
86300: LD_INT 0
86302: ST_TO_ADDR
// if tmp < k then
86303: LD_VAR 0 14
86307: PUSH
86308: LD_VAR 0 9
86312: LESS
86313: IFFALSE 86325
// k := tmp ;
86315: LD_ADDR_VAR 0 9
86319: PUSH
86320: LD_VAR 0 14
86324: ST_TO_ADDR
// for j = 1 to k do
86325: LD_ADDR_VAR 0 8
86329: PUSH
86330: DOUBLE
86331: LD_INT 1
86333: DEC
86334: ST_TO_ADDR
86335: LD_VAR 0 9
86339: PUSH
86340: FOR_TO
86341: IFFALSE 86439
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
86343: LD_VAR 0 14
86347: PUSH
86348: LD_VAR 0 8
86352: ARRAY
86353: PPUSH
86354: CALL_OW 247
86358: PUSH
86359: LD_INT 1
86361: EQUAL
86362: PUSH
86363: LD_VAR 0 14
86367: PUSH
86368: LD_VAR 0 8
86372: ARRAY
86373: PPUSH
86374: CALL_OW 256
86378: PUSH
86379: LD_INT 250
86381: LESS
86382: PUSH
86383: LD_VAR 0 20
86387: AND
86388: PUSH
86389: LD_VAR 0 20
86393: NOT
86394: PUSH
86395: LD_VAR 0 14
86399: PUSH
86400: LD_VAR 0 8
86404: ARRAY
86405: PPUSH
86406: CALL_OW 256
86410: PUSH
86411: LD_INT 250
86413: GREATEREQUAL
86414: AND
86415: OR
86416: AND
86417: IFFALSE 86437
// begin x := tmp [ j ] ;
86419: LD_ADDR_VAR 0 10
86423: PUSH
86424: LD_VAR 0 14
86428: PUSH
86429: LD_VAR 0 8
86433: ARRAY
86434: ST_TO_ADDR
// break ;
86435: GO 86439
// end ;
86437: GO 86340
86439: POP
86440: POP
// if x then
86441: LD_VAR 0 10
86445: IFFALSE 86469
// ComAttackUnit ( group [ i ] , x ) else
86447: LD_VAR 0 4
86451: PUSH
86452: LD_VAR 0 7
86456: ARRAY
86457: PPUSH
86458: LD_VAR 0 10
86462: PPUSH
86463: CALL_OW 115
86467: GO 86493
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86469: LD_VAR 0 4
86473: PUSH
86474: LD_VAR 0 7
86478: ARRAY
86479: PPUSH
86480: LD_VAR 0 14
86484: PUSH
86485: LD_INT 1
86487: ARRAY
86488: PPUSH
86489: CALL_OW 115
// if not HasTask ( group [ i ] ) then
86493: LD_VAR 0 4
86497: PUSH
86498: LD_VAR 0 7
86502: ARRAY
86503: PPUSH
86504: CALL_OW 314
86508: NOT
86509: IFFALSE 86547
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
86511: LD_VAR 0 4
86515: PUSH
86516: LD_VAR 0 7
86520: ARRAY
86521: PPUSH
86522: LD_VAR 0 14
86526: PPUSH
86527: LD_VAR 0 4
86531: PUSH
86532: LD_VAR 0 7
86536: ARRAY
86537: PPUSH
86538: CALL_OW 74
86542: PPUSH
86543: CALL_OW 115
// end ; end ; end ;
86547: GO 82426
86549: POP
86550: POP
// wait ( 0 0$2 ) ;
86551: LD_INT 70
86553: PPUSH
86554: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
86558: LD_VAR 0 4
86562: NOT
86563: PUSH
86564: LD_VAR 0 4
86568: PUSH
86569: EMPTY
86570: EQUAL
86571: OR
86572: PUSH
86573: LD_INT 81
86575: PUSH
86576: LD_VAR 0 35
86580: PUSH
86581: EMPTY
86582: LIST
86583: LIST
86584: PPUSH
86585: CALL_OW 69
86589: NOT
86590: OR
86591: IFFALSE 82411
// end ;
86593: LD_VAR 0 2
86597: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
86598: LD_INT 0
86600: PPUSH
86601: PPUSH
86602: PPUSH
86603: PPUSH
86604: PPUSH
86605: PPUSH
// if not base or not mc_bases [ base ] or not solds then
86606: LD_VAR 0 1
86610: NOT
86611: PUSH
86612: LD_EXP 23
86616: PUSH
86617: LD_VAR 0 1
86621: ARRAY
86622: NOT
86623: OR
86624: PUSH
86625: LD_VAR 0 2
86629: NOT
86630: OR
86631: IFFALSE 86635
// exit ;
86633: GO 87189
// side := mc_sides [ base ] ;
86635: LD_ADDR_VAR 0 6
86639: PUSH
86640: LD_EXP 49
86644: PUSH
86645: LD_VAR 0 1
86649: ARRAY
86650: ST_TO_ADDR
// if not side then
86651: LD_VAR 0 6
86655: NOT
86656: IFFALSE 86660
// exit ;
86658: GO 87189
// for i in solds do
86660: LD_ADDR_VAR 0 7
86664: PUSH
86665: LD_VAR 0 2
86669: PUSH
86670: FOR_IN
86671: IFFALSE 86732
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
86673: LD_VAR 0 7
86677: PPUSH
86678: CALL_OW 310
86682: PPUSH
86683: CALL_OW 266
86687: PUSH
86688: LD_INT 32
86690: PUSH
86691: LD_INT 31
86693: PUSH
86694: EMPTY
86695: LIST
86696: LIST
86697: IN
86698: IFFALSE 86718
// solds := solds diff i else
86700: LD_ADDR_VAR 0 2
86704: PUSH
86705: LD_VAR 0 2
86709: PUSH
86710: LD_VAR 0 7
86714: DIFF
86715: ST_TO_ADDR
86716: GO 86730
// SetTag ( i , 18 ) ;
86718: LD_VAR 0 7
86722: PPUSH
86723: LD_INT 18
86725: PPUSH
86726: CALL_OW 109
86730: GO 86670
86732: POP
86733: POP
// if not solds then
86734: LD_VAR 0 2
86738: NOT
86739: IFFALSE 86743
// exit ;
86741: GO 87189
// repeat wait ( 0 0$2 ) ;
86743: LD_INT 70
86745: PPUSH
86746: CALL_OW 67
// enemy := mc_scan [ base ] ;
86750: LD_ADDR_VAR 0 4
86754: PUSH
86755: LD_EXP 46
86759: PUSH
86760: LD_VAR 0 1
86764: ARRAY
86765: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
86766: LD_EXP 23
86770: PUSH
86771: LD_VAR 0 1
86775: ARRAY
86776: NOT
86777: PUSH
86778: LD_EXP 23
86782: PUSH
86783: LD_VAR 0 1
86787: ARRAY
86788: PUSH
86789: EMPTY
86790: EQUAL
86791: OR
86792: IFFALSE 86829
// begin for i in solds do
86794: LD_ADDR_VAR 0 7
86798: PUSH
86799: LD_VAR 0 2
86803: PUSH
86804: FOR_IN
86805: IFFALSE 86818
// ComStop ( i ) ;
86807: LD_VAR 0 7
86811: PPUSH
86812: CALL_OW 141
86816: GO 86804
86818: POP
86819: POP
// solds := [ ] ;
86820: LD_ADDR_VAR 0 2
86824: PUSH
86825: EMPTY
86826: ST_TO_ADDR
// exit ;
86827: GO 87189
// end ; for i in solds do
86829: LD_ADDR_VAR 0 7
86833: PUSH
86834: LD_VAR 0 2
86838: PUSH
86839: FOR_IN
86840: IFFALSE 87161
// begin if IsInUnit ( i ) then
86842: LD_VAR 0 7
86846: PPUSH
86847: CALL_OW 310
86851: IFFALSE 86862
// ComExitBuilding ( i ) ;
86853: LD_VAR 0 7
86857: PPUSH
86858: CALL_OW 122
// if GetLives ( i ) > 500 then
86862: LD_VAR 0 7
86866: PPUSH
86867: CALL_OW 256
86871: PUSH
86872: LD_INT 500
86874: GREATER
86875: IFFALSE 86928
// begin e := NearestUnitToUnit ( enemy , i ) ;
86877: LD_ADDR_VAR 0 5
86881: PUSH
86882: LD_VAR 0 4
86886: PPUSH
86887: LD_VAR 0 7
86891: PPUSH
86892: CALL_OW 74
86896: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
86897: LD_VAR 0 7
86901: PPUSH
86902: LD_VAR 0 5
86906: PPUSH
86907: CALL_OW 250
86911: PPUSH
86912: LD_VAR 0 5
86916: PPUSH
86917: CALL_OW 251
86921: PPUSH
86922: CALL_OW 114
// end else
86926: GO 87159
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
86928: LD_VAR 0 7
86932: PPUSH
86933: LD_EXP 23
86937: PUSH
86938: LD_VAR 0 1
86942: ARRAY
86943: PPUSH
86944: LD_INT 2
86946: PUSH
86947: LD_INT 30
86949: PUSH
86950: LD_INT 0
86952: PUSH
86953: EMPTY
86954: LIST
86955: LIST
86956: PUSH
86957: LD_INT 30
86959: PUSH
86960: LD_INT 1
86962: PUSH
86963: EMPTY
86964: LIST
86965: LIST
86966: PUSH
86967: LD_INT 30
86969: PUSH
86970: LD_INT 6
86972: PUSH
86973: EMPTY
86974: LIST
86975: LIST
86976: PUSH
86977: EMPTY
86978: LIST
86979: LIST
86980: LIST
86981: LIST
86982: PPUSH
86983: CALL_OW 72
86987: PPUSH
86988: LD_VAR 0 7
86992: PPUSH
86993: CALL_OW 74
86997: PPUSH
86998: CALL_OW 296
87002: PUSH
87003: LD_INT 10
87005: GREATER
87006: IFFALSE 87159
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
87008: LD_ADDR_VAR 0 8
87012: PUSH
87013: LD_EXP 23
87017: PUSH
87018: LD_VAR 0 1
87022: ARRAY
87023: PPUSH
87024: LD_INT 2
87026: PUSH
87027: LD_INT 30
87029: PUSH
87030: LD_INT 0
87032: PUSH
87033: EMPTY
87034: LIST
87035: LIST
87036: PUSH
87037: LD_INT 30
87039: PUSH
87040: LD_INT 1
87042: PUSH
87043: EMPTY
87044: LIST
87045: LIST
87046: PUSH
87047: LD_INT 30
87049: PUSH
87050: LD_INT 6
87052: PUSH
87053: EMPTY
87054: LIST
87055: LIST
87056: PUSH
87057: EMPTY
87058: LIST
87059: LIST
87060: LIST
87061: LIST
87062: PPUSH
87063: CALL_OW 72
87067: PPUSH
87068: LD_VAR 0 7
87072: PPUSH
87073: CALL_OW 74
87077: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
87078: LD_VAR 0 7
87082: PPUSH
87083: LD_VAR 0 8
87087: PPUSH
87088: CALL_OW 250
87092: PPUSH
87093: LD_INT 3
87095: PPUSH
87096: LD_INT 5
87098: PPUSH
87099: CALL_OW 272
87103: PPUSH
87104: LD_VAR 0 8
87108: PPUSH
87109: CALL_OW 251
87113: PPUSH
87114: LD_INT 3
87116: PPUSH
87117: LD_INT 5
87119: PPUSH
87120: CALL_OW 273
87124: PPUSH
87125: CALL_OW 111
// SetTag ( i , 0 ) ;
87129: LD_VAR 0 7
87133: PPUSH
87134: LD_INT 0
87136: PPUSH
87137: CALL_OW 109
// solds := solds diff i ;
87141: LD_ADDR_VAR 0 2
87145: PUSH
87146: LD_VAR 0 2
87150: PUSH
87151: LD_VAR 0 7
87155: DIFF
87156: ST_TO_ADDR
// continue ;
87157: GO 86839
// end ; end ;
87159: GO 86839
87161: POP
87162: POP
// until not solds or not enemy ;
87163: LD_VAR 0 2
87167: NOT
87168: PUSH
87169: LD_VAR 0 4
87173: NOT
87174: OR
87175: IFFALSE 86743
// MC_Reset ( base , 18 ) ;
87177: LD_VAR 0 1
87181: PPUSH
87182: LD_INT 18
87184: PPUSH
87185: CALL 55249 0 2
// end ;
87189: LD_VAR 0 3
87193: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
87194: LD_INT 0
87196: PPUSH
87197: PPUSH
87198: PPUSH
87199: PPUSH
87200: PPUSH
87201: PPUSH
87202: PPUSH
87203: PPUSH
87204: PPUSH
87205: PPUSH
87206: PPUSH
87207: PPUSH
87208: PPUSH
87209: PPUSH
87210: PPUSH
87211: PPUSH
87212: PPUSH
87213: PPUSH
87214: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
87215: LD_ADDR_VAR 0 12
87219: PUSH
87220: LD_EXP 23
87224: PUSH
87225: LD_VAR 0 1
87229: ARRAY
87230: PPUSH
87231: LD_INT 25
87233: PUSH
87234: LD_INT 3
87236: PUSH
87237: EMPTY
87238: LIST
87239: LIST
87240: PPUSH
87241: CALL_OW 72
87245: ST_TO_ADDR
// if mc_remote_driver [ base ] then
87246: LD_EXP 63
87250: PUSH
87251: LD_VAR 0 1
87255: ARRAY
87256: IFFALSE 87280
// mechs := mechs diff mc_remote_driver [ base ] ;
87258: LD_ADDR_VAR 0 12
87262: PUSH
87263: LD_VAR 0 12
87267: PUSH
87268: LD_EXP 63
87272: PUSH
87273: LD_VAR 0 1
87277: ARRAY
87278: DIFF
87279: ST_TO_ADDR
// for i in mechs do
87280: LD_ADDR_VAR 0 4
87284: PUSH
87285: LD_VAR 0 12
87289: PUSH
87290: FOR_IN
87291: IFFALSE 87326
// if GetTag ( i ) > 0 then
87293: LD_VAR 0 4
87297: PPUSH
87298: CALL_OW 110
87302: PUSH
87303: LD_INT 0
87305: GREATER
87306: IFFALSE 87324
// mechs := mechs diff i ;
87308: LD_ADDR_VAR 0 12
87312: PUSH
87313: LD_VAR 0 12
87317: PUSH
87318: LD_VAR 0 4
87322: DIFF
87323: ST_TO_ADDR
87324: GO 87290
87326: POP
87327: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
87328: LD_ADDR_VAR 0 8
87332: PUSH
87333: LD_EXP 23
87337: PUSH
87338: LD_VAR 0 1
87342: ARRAY
87343: PPUSH
87344: LD_INT 2
87346: PUSH
87347: LD_INT 25
87349: PUSH
87350: LD_INT 1
87352: PUSH
87353: EMPTY
87354: LIST
87355: LIST
87356: PUSH
87357: LD_INT 25
87359: PUSH
87360: LD_INT 5
87362: PUSH
87363: EMPTY
87364: LIST
87365: LIST
87366: PUSH
87367: LD_INT 25
87369: PUSH
87370: LD_INT 8
87372: PUSH
87373: EMPTY
87374: LIST
87375: LIST
87376: PUSH
87377: LD_INT 25
87379: PUSH
87380: LD_INT 9
87382: PUSH
87383: EMPTY
87384: LIST
87385: LIST
87386: PUSH
87387: EMPTY
87388: LIST
87389: LIST
87390: LIST
87391: LIST
87392: LIST
87393: PPUSH
87394: CALL_OW 72
87398: ST_TO_ADDR
// if not defenders and not solds then
87399: LD_VAR 0 2
87403: NOT
87404: PUSH
87405: LD_VAR 0 8
87409: NOT
87410: AND
87411: IFFALSE 87415
// exit ;
87413: GO 89185
// depot_under_attack := false ;
87415: LD_ADDR_VAR 0 16
87419: PUSH
87420: LD_INT 0
87422: ST_TO_ADDR
// sold_defenders := [ ] ;
87423: LD_ADDR_VAR 0 17
87427: PUSH
87428: EMPTY
87429: ST_TO_ADDR
// if mechs then
87430: LD_VAR 0 12
87434: IFFALSE 87587
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
87436: LD_ADDR_VAR 0 4
87440: PUSH
87441: LD_VAR 0 2
87445: PPUSH
87446: LD_INT 21
87448: PUSH
87449: LD_INT 2
87451: PUSH
87452: EMPTY
87453: LIST
87454: LIST
87455: PPUSH
87456: CALL_OW 72
87460: PUSH
87461: FOR_IN
87462: IFFALSE 87585
// begin if GetTag ( i ) <> 20 then
87464: LD_VAR 0 4
87468: PPUSH
87469: CALL_OW 110
87473: PUSH
87474: LD_INT 20
87476: NONEQUAL
87477: IFFALSE 87491
// SetTag ( i , 20 ) ;
87479: LD_VAR 0 4
87483: PPUSH
87484: LD_INT 20
87486: PPUSH
87487: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
87491: LD_VAR 0 4
87495: PPUSH
87496: CALL_OW 263
87500: PUSH
87501: LD_INT 1
87503: EQUAL
87504: PUSH
87505: LD_VAR 0 4
87509: PPUSH
87510: CALL_OW 311
87514: NOT
87515: AND
87516: IFFALSE 87583
// begin un := mechs [ 1 ] ;
87518: LD_ADDR_VAR 0 10
87522: PUSH
87523: LD_VAR 0 12
87527: PUSH
87528: LD_INT 1
87530: ARRAY
87531: ST_TO_ADDR
// ComExit ( un ) ;
87532: LD_VAR 0 10
87536: PPUSH
87537: CALL 48129 0 1
// AddComEnterUnit ( un , i ) ;
87541: LD_VAR 0 10
87545: PPUSH
87546: LD_VAR 0 4
87550: PPUSH
87551: CALL_OW 180
// SetTag ( un , 19 ) ;
87555: LD_VAR 0 10
87559: PPUSH
87560: LD_INT 19
87562: PPUSH
87563: CALL_OW 109
// mechs := mechs diff un ;
87567: LD_ADDR_VAR 0 12
87571: PUSH
87572: LD_VAR 0 12
87576: PUSH
87577: LD_VAR 0 10
87581: DIFF
87582: ST_TO_ADDR
// end ; end ;
87583: GO 87461
87585: POP
87586: POP
// if solds then
87587: LD_VAR 0 8
87591: IFFALSE 87650
// for i in solds do
87593: LD_ADDR_VAR 0 4
87597: PUSH
87598: LD_VAR 0 8
87602: PUSH
87603: FOR_IN
87604: IFFALSE 87648
// if not GetTag ( i ) then
87606: LD_VAR 0 4
87610: PPUSH
87611: CALL_OW 110
87615: NOT
87616: IFFALSE 87646
// begin defenders := defenders union i ;
87618: LD_ADDR_VAR 0 2
87622: PUSH
87623: LD_VAR 0 2
87627: PUSH
87628: LD_VAR 0 4
87632: UNION
87633: ST_TO_ADDR
// SetTag ( i , 18 ) ;
87634: LD_VAR 0 4
87638: PPUSH
87639: LD_INT 18
87641: PPUSH
87642: CALL_OW 109
// end ;
87646: GO 87603
87648: POP
87649: POP
// repeat wait ( 0 0$2 ) ;
87650: LD_INT 70
87652: PPUSH
87653: CALL_OW 67
// enemy := mc_scan [ base ] ;
87657: LD_ADDR_VAR 0 21
87661: PUSH
87662: LD_EXP 46
87666: PUSH
87667: LD_VAR 0 1
87671: ARRAY
87672: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
87673: LD_EXP 23
87677: PUSH
87678: LD_VAR 0 1
87682: ARRAY
87683: NOT
87684: PUSH
87685: LD_EXP 23
87689: PUSH
87690: LD_VAR 0 1
87694: ARRAY
87695: PUSH
87696: EMPTY
87697: EQUAL
87698: OR
87699: IFFALSE 87736
// begin for i in defenders do
87701: LD_ADDR_VAR 0 4
87705: PUSH
87706: LD_VAR 0 2
87710: PUSH
87711: FOR_IN
87712: IFFALSE 87725
// ComStop ( i ) ;
87714: LD_VAR 0 4
87718: PPUSH
87719: CALL_OW 141
87723: GO 87711
87725: POP
87726: POP
// defenders := [ ] ;
87727: LD_ADDR_VAR 0 2
87731: PUSH
87732: EMPTY
87733: ST_TO_ADDR
// exit ;
87734: GO 89185
// end ; for i in defenders do
87736: LD_ADDR_VAR 0 4
87740: PUSH
87741: LD_VAR 0 2
87745: PUSH
87746: FOR_IN
87747: IFFALSE 88645
// begin e := NearestUnitToUnit ( enemy , i ) ;
87749: LD_ADDR_VAR 0 13
87753: PUSH
87754: LD_VAR 0 21
87758: PPUSH
87759: LD_VAR 0 4
87763: PPUSH
87764: CALL_OW 74
87768: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
87769: LD_ADDR_VAR 0 7
87773: PUSH
87774: LD_EXP 23
87778: PUSH
87779: LD_VAR 0 1
87783: ARRAY
87784: PPUSH
87785: LD_INT 2
87787: PUSH
87788: LD_INT 30
87790: PUSH
87791: LD_INT 0
87793: PUSH
87794: EMPTY
87795: LIST
87796: LIST
87797: PUSH
87798: LD_INT 30
87800: PUSH
87801: LD_INT 1
87803: PUSH
87804: EMPTY
87805: LIST
87806: LIST
87807: PUSH
87808: EMPTY
87809: LIST
87810: LIST
87811: LIST
87812: PPUSH
87813: CALL_OW 72
87817: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
87818: LD_ADDR_VAR 0 16
87822: PUSH
87823: LD_VAR 0 7
87827: NOT
87828: PUSH
87829: LD_VAR 0 7
87833: PPUSH
87834: LD_INT 3
87836: PUSH
87837: LD_INT 24
87839: PUSH
87840: LD_INT 600
87842: PUSH
87843: EMPTY
87844: LIST
87845: LIST
87846: PUSH
87847: EMPTY
87848: LIST
87849: LIST
87850: PPUSH
87851: CALL_OW 72
87855: OR
87856: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
87857: LD_VAR 0 4
87861: PPUSH
87862: CALL_OW 247
87866: PUSH
87867: LD_INT 2
87869: DOUBLE
87870: EQUAL
87871: IFTRUE 87875
87873: GO 88271
87875: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
87876: LD_VAR 0 4
87880: PPUSH
87881: CALL_OW 256
87885: PUSH
87886: LD_INT 1000
87888: EQUAL
87889: PUSH
87890: LD_VAR 0 4
87894: PPUSH
87895: LD_VAR 0 13
87899: PPUSH
87900: CALL_OW 296
87904: PUSH
87905: LD_INT 40
87907: LESS
87908: PUSH
87909: LD_VAR 0 13
87913: PPUSH
87914: LD_EXP 48
87918: PUSH
87919: LD_VAR 0 1
87923: ARRAY
87924: PPUSH
87925: CALL_OW 308
87929: OR
87930: AND
87931: IFFALSE 88053
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
87933: LD_VAR 0 4
87937: PPUSH
87938: CALL_OW 262
87942: PUSH
87943: LD_INT 1
87945: EQUAL
87946: PUSH
87947: LD_VAR 0 4
87951: PPUSH
87952: CALL_OW 261
87956: PUSH
87957: LD_INT 30
87959: LESS
87960: AND
87961: PUSH
87962: LD_VAR 0 7
87966: AND
87967: IFFALSE 88037
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
87969: LD_VAR 0 4
87973: PPUSH
87974: LD_VAR 0 7
87978: PPUSH
87979: LD_VAR 0 4
87983: PPUSH
87984: CALL_OW 74
87988: PPUSH
87989: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
87993: LD_VAR 0 4
87997: PPUSH
87998: LD_VAR 0 7
88002: PPUSH
88003: LD_VAR 0 4
88007: PPUSH
88008: CALL_OW 74
88012: PPUSH
88013: CALL_OW 296
88017: PUSH
88018: LD_INT 6
88020: LESS
88021: IFFALSE 88035
// SetFuel ( i , 100 ) ;
88023: LD_VAR 0 4
88027: PPUSH
88028: LD_INT 100
88030: PPUSH
88031: CALL_OW 240
// end else
88035: GO 88051
// ComAttackUnit ( i , e ) ;
88037: LD_VAR 0 4
88041: PPUSH
88042: LD_VAR 0 13
88046: PPUSH
88047: CALL_OW 115
// end else
88051: GO 88154
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
88053: LD_VAR 0 13
88057: PPUSH
88058: LD_EXP 48
88062: PUSH
88063: LD_VAR 0 1
88067: ARRAY
88068: PPUSH
88069: CALL_OW 308
88073: NOT
88074: PUSH
88075: LD_VAR 0 4
88079: PPUSH
88080: LD_VAR 0 13
88084: PPUSH
88085: CALL_OW 296
88089: PUSH
88090: LD_INT 40
88092: GREATEREQUAL
88093: AND
88094: PUSH
88095: LD_VAR 0 4
88099: PPUSH
88100: CALL_OW 256
88104: PUSH
88105: LD_INT 650
88107: LESSEQUAL
88108: OR
88109: PUSH
88110: LD_VAR 0 4
88114: PPUSH
88115: LD_EXP 47
88119: PUSH
88120: LD_VAR 0 1
88124: ARRAY
88125: PPUSH
88126: CALL_OW 308
88130: NOT
88131: AND
88132: IFFALSE 88154
// ComMoveToArea ( i , mc_parking [ base ] ) ;
88134: LD_VAR 0 4
88138: PPUSH
88139: LD_EXP 47
88143: PUSH
88144: LD_VAR 0 1
88148: ARRAY
88149: PPUSH
88150: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
88154: LD_VAR 0 4
88158: PPUSH
88159: CALL_OW 256
88163: PUSH
88164: LD_INT 1000
88166: LESS
88167: PUSH
88168: LD_VAR 0 4
88172: PPUSH
88173: CALL_OW 263
88177: PUSH
88178: LD_INT 1
88180: EQUAL
88181: AND
88182: PUSH
88183: LD_VAR 0 4
88187: PPUSH
88188: CALL_OW 311
88192: AND
88193: PUSH
88194: LD_VAR 0 4
88198: PPUSH
88199: LD_EXP 47
88203: PUSH
88204: LD_VAR 0 1
88208: ARRAY
88209: PPUSH
88210: CALL_OW 308
88214: AND
88215: IFFALSE 88269
// begin mech := IsDrivenBy ( i ) ;
88217: LD_ADDR_VAR 0 9
88221: PUSH
88222: LD_VAR 0 4
88226: PPUSH
88227: CALL_OW 311
88231: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
88232: LD_VAR 0 9
88236: PPUSH
88237: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
88241: LD_VAR 0 9
88245: PPUSH
88246: LD_VAR 0 4
88250: PPUSH
88251: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
88255: LD_VAR 0 9
88259: PPUSH
88260: LD_VAR 0 4
88264: PPUSH
88265: CALL_OW 180
// end ; end ; unit_human :
88269: GO 88616
88271: LD_INT 1
88273: DOUBLE
88274: EQUAL
88275: IFTRUE 88279
88277: GO 88615
88279: POP
// begin b := IsInUnit ( i ) ;
88280: LD_ADDR_VAR 0 18
88284: PUSH
88285: LD_VAR 0 4
88289: PPUSH
88290: CALL_OW 310
88294: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
88295: LD_ADDR_VAR 0 19
88299: PUSH
88300: LD_VAR 0 18
88304: NOT
88305: PUSH
88306: LD_VAR 0 18
88310: PPUSH
88311: CALL_OW 266
88315: PUSH
88316: LD_INT 32
88318: PUSH
88319: LD_INT 31
88321: PUSH
88322: EMPTY
88323: LIST
88324: LIST
88325: IN
88326: OR
88327: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
88328: LD_VAR 0 18
88332: PPUSH
88333: CALL_OW 266
88337: PUSH
88338: LD_INT 5
88340: EQUAL
88341: PUSH
88342: LD_VAR 0 4
88346: PPUSH
88347: CALL_OW 257
88351: PUSH
88352: LD_INT 1
88354: PUSH
88355: LD_INT 2
88357: PUSH
88358: LD_INT 3
88360: PUSH
88361: LD_INT 4
88363: PUSH
88364: EMPTY
88365: LIST
88366: LIST
88367: LIST
88368: LIST
88369: IN
88370: AND
88371: IFFALSE 88408
// begin class := AllowSpecClass ( i ) ;
88373: LD_ADDR_VAR 0 20
88377: PUSH
88378: LD_VAR 0 4
88382: PPUSH
88383: CALL 12790 0 1
88387: ST_TO_ADDR
// if class then
88388: LD_VAR 0 20
88392: IFFALSE 88408
// ComChangeProfession ( i , class ) ;
88394: LD_VAR 0 4
88398: PPUSH
88399: LD_VAR 0 20
88403: PPUSH
88404: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
88408: LD_VAR 0 16
88412: PUSH
88413: LD_VAR 0 2
88417: PPUSH
88418: LD_INT 21
88420: PUSH
88421: LD_INT 2
88423: PUSH
88424: EMPTY
88425: LIST
88426: LIST
88427: PPUSH
88428: CALL_OW 72
88432: PUSH
88433: LD_INT 1
88435: LESSEQUAL
88436: OR
88437: PUSH
88438: LD_VAR 0 19
88442: AND
88443: PUSH
88444: LD_VAR 0 4
88448: PUSH
88449: LD_VAR 0 17
88453: IN
88454: NOT
88455: AND
88456: IFFALSE 88549
// begin if b then
88458: LD_VAR 0 18
88462: IFFALSE 88511
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
88464: LD_VAR 0 18
88468: PPUSH
88469: LD_VAR 0 21
88473: PPUSH
88474: LD_VAR 0 18
88478: PPUSH
88479: CALL_OW 74
88483: PPUSH
88484: CALL_OW 296
88488: PUSH
88489: LD_INT 10
88491: LESS
88492: PUSH
88493: LD_VAR 0 18
88497: PPUSH
88498: CALL_OW 461
88502: PUSH
88503: LD_INT 7
88505: NONEQUAL
88506: AND
88507: IFFALSE 88511
// continue ;
88509: GO 87746
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
88511: LD_ADDR_VAR 0 17
88515: PUSH
88516: LD_VAR 0 17
88520: PPUSH
88521: LD_VAR 0 17
88525: PUSH
88526: LD_INT 1
88528: PLUS
88529: PPUSH
88530: LD_VAR 0 4
88534: PPUSH
88535: CALL_OW 1
88539: ST_TO_ADDR
// ComExitBuilding ( i ) ;
88540: LD_VAR 0 4
88544: PPUSH
88545: CALL_OW 122
// end ; if sold_defenders then
88549: LD_VAR 0 17
88553: IFFALSE 88613
// if i in sold_defenders then
88555: LD_VAR 0 4
88559: PUSH
88560: LD_VAR 0 17
88564: IN
88565: IFFALSE 88613
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
88567: LD_VAR 0 4
88571: PPUSH
88572: CALL_OW 314
88576: NOT
88577: PUSH
88578: LD_VAR 0 4
88582: PPUSH
88583: LD_VAR 0 13
88587: PPUSH
88588: CALL_OW 296
88592: PUSH
88593: LD_INT 30
88595: LESS
88596: AND
88597: IFFALSE 88613
// ComAttackUnit ( i , e ) ;
88599: LD_VAR 0 4
88603: PPUSH
88604: LD_VAR 0 13
88608: PPUSH
88609: CALL_OW 115
// end ; end ; end ;
88613: GO 88616
88615: POP
// if IsDead ( i ) then
88616: LD_VAR 0 4
88620: PPUSH
88621: CALL_OW 301
88625: IFFALSE 88643
// defenders := defenders diff i ;
88627: LD_ADDR_VAR 0 2
88631: PUSH
88632: LD_VAR 0 2
88636: PUSH
88637: LD_VAR 0 4
88641: DIFF
88642: ST_TO_ADDR
// end ;
88643: GO 87746
88645: POP
88646: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
88647: LD_VAR 0 21
88651: NOT
88652: PUSH
88653: LD_VAR 0 2
88657: NOT
88658: OR
88659: PUSH
88660: LD_EXP 23
88664: PUSH
88665: LD_VAR 0 1
88669: ARRAY
88670: NOT
88671: OR
88672: IFFALSE 87650
// MC_Reset ( base , 18 ) ;
88674: LD_VAR 0 1
88678: PPUSH
88679: LD_INT 18
88681: PPUSH
88682: CALL 55249 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
88686: LD_ADDR_VAR 0 2
88690: PUSH
88691: LD_VAR 0 2
88695: PUSH
88696: LD_VAR 0 2
88700: PPUSH
88701: LD_INT 2
88703: PUSH
88704: LD_INT 25
88706: PUSH
88707: LD_INT 1
88709: PUSH
88710: EMPTY
88711: LIST
88712: LIST
88713: PUSH
88714: LD_INT 25
88716: PUSH
88717: LD_INT 5
88719: PUSH
88720: EMPTY
88721: LIST
88722: LIST
88723: PUSH
88724: LD_INT 25
88726: PUSH
88727: LD_INT 8
88729: PUSH
88730: EMPTY
88731: LIST
88732: LIST
88733: PUSH
88734: LD_INT 25
88736: PUSH
88737: LD_INT 9
88739: PUSH
88740: EMPTY
88741: LIST
88742: LIST
88743: PUSH
88744: EMPTY
88745: LIST
88746: LIST
88747: LIST
88748: LIST
88749: LIST
88750: PPUSH
88751: CALL_OW 72
88755: DIFF
88756: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
88757: LD_VAR 0 21
88761: NOT
88762: PUSH
88763: LD_VAR 0 2
88767: PPUSH
88768: LD_INT 21
88770: PUSH
88771: LD_INT 2
88773: PUSH
88774: EMPTY
88775: LIST
88776: LIST
88777: PPUSH
88778: CALL_OW 72
88782: AND
88783: IFFALSE 89121
// begin tmp := FilterByTag ( defenders , 19 ) ;
88785: LD_ADDR_VAR 0 11
88789: PUSH
88790: LD_VAR 0 2
88794: PPUSH
88795: LD_INT 19
88797: PPUSH
88798: CALL 45259 0 2
88802: ST_TO_ADDR
// if tmp then
88803: LD_VAR 0 11
88807: IFFALSE 88877
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
88809: LD_ADDR_VAR 0 11
88813: PUSH
88814: LD_VAR 0 11
88818: PPUSH
88819: LD_INT 25
88821: PUSH
88822: LD_INT 3
88824: PUSH
88825: EMPTY
88826: LIST
88827: LIST
88828: PPUSH
88829: CALL_OW 72
88833: ST_TO_ADDR
// if tmp then
88834: LD_VAR 0 11
88838: IFFALSE 88877
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
88840: LD_ADDR_EXP 35
88844: PUSH
88845: LD_EXP 35
88849: PPUSH
88850: LD_VAR 0 1
88854: PPUSH
88855: LD_EXP 35
88859: PUSH
88860: LD_VAR 0 1
88864: ARRAY
88865: PUSH
88866: LD_VAR 0 11
88870: UNION
88871: PPUSH
88872: CALL_OW 1
88876: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
88877: LD_VAR 0 1
88881: PPUSH
88882: LD_INT 19
88884: PPUSH
88885: CALL 55249 0 2
// repeat wait ( 0 0$1 ) ;
88889: LD_INT 35
88891: PPUSH
88892: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
88896: LD_EXP 23
88900: PUSH
88901: LD_VAR 0 1
88905: ARRAY
88906: NOT
88907: PUSH
88908: LD_EXP 23
88912: PUSH
88913: LD_VAR 0 1
88917: ARRAY
88918: PUSH
88919: EMPTY
88920: EQUAL
88921: OR
88922: IFFALSE 88959
// begin for i in defenders do
88924: LD_ADDR_VAR 0 4
88928: PUSH
88929: LD_VAR 0 2
88933: PUSH
88934: FOR_IN
88935: IFFALSE 88948
// ComStop ( i ) ;
88937: LD_VAR 0 4
88941: PPUSH
88942: CALL_OW 141
88946: GO 88934
88948: POP
88949: POP
// defenders := [ ] ;
88950: LD_ADDR_VAR 0 2
88954: PUSH
88955: EMPTY
88956: ST_TO_ADDR
// exit ;
88957: GO 89185
// end ; for i in defenders do
88959: LD_ADDR_VAR 0 4
88963: PUSH
88964: LD_VAR 0 2
88968: PUSH
88969: FOR_IN
88970: IFFALSE 89059
// begin if not IsInArea ( i , mc_parking [ base ] ) then
88972: LD_VAR 0 4
88976: PPUSH
88977: LD_EXP 47
88981: PUSH
88982: LD_VAR 0 1
88986: ARRAY
88987: PPUSH
88988: CALL_OW 308
88992: NOT
88993: IFFALSE 89017
// ComMoveToArea ( i , mc_parking [ base ] ) else
88995: LD_VAR 0 4
88999: PPUSH
89000: LD_EXP 47
89004: PUSH
89005: LD_VAR 0 1
89009: ARRAY
89010: PPUSH
89011: CALL_OW 113
89015: GO 89057
// if GetControl ( i ) = control_manual then
89017: LD_VAR 0 4
89021: PPUSH
89022: CALL_OW 263
89026: PUSH
89027: LD_INT 1
89029: EQUAL
89030: IFFALSE 89057
// if IsDrivenBy ( i ) then
89032: LD_VAR 0 4
89036: PPUSH
89037: CALL_OW 311
89041: IFFALSE 89057
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
89043: LD_VAR 0 4
89047: PPUSH
89048: CALL_OW 311
89052: PPUSH
89053: CALL_OW 121
// end ;
89057: GO 88969
89059: POP
89060: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
89061: LD_VAR 0 2
89065: PPUSH
89066: LD_INT 95
89068: PUSH
89069: LD_EXP 47
89073: PUSH
89074: LD_VAR 0 1
89078: ARRAY
89079: PUSH
89080: EMPTY
89081: LIST
89082: LIST
89083: PPUSH
89084: CALL_OW 72
89088: PUSH
89089: LD_VAR 0 2
89093: EQUAL
89094: PUSH
89095: LD_EXP 46
89099: PUSH
89100: LD_VAR 0 1
89104: ARRAY
89105: OR
89106: PUSH
89107: LD_EXP 23
89111: PUSH
89112: LD_VAR 0 1
89116: ARRAY
89117: NOT
89118: OR
89119: IFFALSE 88889
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
89121: LD_ADDR_EXP 45
89125: PUSH
89126: LD_EXP 45
89130: PPUSH
89131: LD_VAR 0 1
89135: PPUSH
89136: LD_VAR 0 2
89140: PPUSH
89141: LD_INT 21
89143: PUSH
89144: LD_INT 2
89146: PUSH
89147: EMPTY
89148: LIST
89149: LIST
89150: PPUSH
89151: CALL_OW 72
89155: PPUSH
89156: CALL_OW 1
89160: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
89161: LD_VAR 0 1
89165: PPUSH
89166: LD_INT 19
89168: PPUSH
89169: CALL 55249 0 2
// MC_Reset ( base , 20 ) ;
89173: LD_VAR 0 1
89177: PPUSH
89178: LD_INT 20
89180: PPUSH
89181: CALL 55249 0 2
// end ; end_of_file
89185: LD_VAR 0 3
89189: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
89190: LD_INT 0
89192: PPUSH
89193: PPUSH
89194: PPUSH
89195: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
89196: LD_VAR 0 1
89200: PPUSH
89201: CALL_OW 264
89205: PUSH
89206: LD_EXP 71
89210: EQUAL
89211: IFFALSE 89283
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
89213: LD_INT 68
89215: PPUSH
89216: LD_VAR 0 1
89220: PPUSH
89221: CALL_OW 255
89225: PPUSH
89226: CALL_OW 321
89230: PUSH
89231: LD_INT 2
89233: EQUAL
89234: IFFALSE 89246
// eff := 70 else
89236: LD_ADDR_VAR 0 4
89240: PUSH
89241: LD_INT 70
89243: ST_TO_ADDR
89244: GO 89254
// eff := 30 ;
89246: LD_ADDR_VAR 0 4
89250: PUSH
89251: LD_INT 30
89253: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
89254: LD_VAR 0 1
89258: PPUSH
89259: CALL_OW 250
89263: PPUSH
89264: LD_VAR 0 1
89268: PPUSH
89269: CALL_OW 251
89273: PPUSH
89274: LD_VAR 0 4
89278: PPUSH
89279: CALL_OW 495
// end ; end ;
89283: LD_VAR 0 2
89287: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
89288: LD_INT 0
89290: PPUSH
// end ;
89291: LD_VAR 0 4
89295: RET
// export function SOS_Command ( cmd ) ; begin
89296: LD_INT 0
89298: PPUSH
// end ;
89299: LD_VAR 0 2
89303: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
89304: LD_INT 0
89306: PPUSH
// end ;
89307: LD_VAR 0 6
89311: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
89312: LD_INT 0
89314: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
89315: LD_VAR 0 1
89319: PUSH
89320: LD_INT 250
89322: EQUAL
89323: PUSH
89324: LD_VAR 0 2
89328: PPUSH
89329: CALL_OW 264
89333: PUSH
89334: LD_EXP 74
89338: EQUAL
89339: AND
89340: IFFALSE 89361
// MinerPlaceMine ( unit , x , y ) ;
89342: LD_VAR 0 2
89346: PPUSH
89347: LD_VAR 0 4
89351: PPUSH
89352: LD_VAR 0 5
89356: PPUSH
89357: CALL 91710 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
89361: LD_VAR 0 1
89365: PUSH
89366: LD_INT 251
89368: EQUAL
89369: PUSH
89370: LD_VAR 0 2
89374: PPUSH
89375: CALL_OW 264
89379: PUSH
89380: LD_EXP 74
89384: EQUAL
89385: AND
89386: IFFALSE 89407
// MinerDetonateMine ( unit , x , y ) ;
89388: LD_VAR 0 2
89392: PPUSH
89393: LD_VAR 0 4
89397: PPUSH
89398: LD_VAR 0 5
89402: PPUSH
89403: CALL 91987 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
89407: LD_VAR 0 1
89411: PUSH
89412: LD_INT 252
89414: EQUAL
89415: PUSH
89416: LD_VAR 0 2
89420: PPUSH
89421: CALL_OW 264
89425: PUSH
89426: LD_EXP 74
89430: EQUAL
89431: AND
89432: IFFALSE 89453
// MinerCreateMinefield ( unit , x , y ) ;
89434: LD_VAR 0 2
89438: PPUSH
89439: LD_VAR 0 4
89443: PPUSH
89444: LD_VAR 0 5
89448: PPUSH
89449: CALL 92404 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
89453: LD_VAR 0 1
89457: PUSH
89458: LD_INT 253
89460: EQUAL
89461: PUSH
89462: LD_VAR 0 2
89466: PPUSH
89467: CALL_OW 257
89471: PUSH
89472: LD_INT 5
89474: EQUAL
89475: AND
89476: IFFALSE 89497
// ComBinocular ( unit , x , y ) ;
89478: LD_VAR 0 2
89482: PPUSH
89483: LD_VAR 0 4
89487: PPUSH
89488: LD_VAR 0 5
89492: PPUSH
89493: CALL 92775 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
89497: LD_VAR 0 1
89501: PUSH
89502: LD_INT 254
89504: EQUAL
89505: PUSH
89506: LD_VAR 0 2
89510: PPUSH
89511: CALL_OW 264
89515: PUSH
89516: LD_EXP 69
89520: EQUAL
89521: AND
89522: PUSH
89523: LD_VAR 0 3
89527: PPUSH
89528: CALL_OW 263
89532: PUSH
89533: LD_INT 3
89535: EQUAL
89536: AND
89537: IFFALSE 89553
// HackDestroyVehicle ( unit , selectedUnit ) ;
89539: LD_VAR 0 2
89543: PPUSH
89544: LD_VAR 0 3
89548: PPUSH
89549: CALL 91070 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
89553: LD_VAR 0 1
89557: PUSH
89558: LD_INT 255
89560: EQUAL
89561: PUSH
89562: LD_VAR 0 2
89566: PPUSH
89567: CALL_OW 264
89571: PUSH
89572: LD_INT 14
89574: PUSH
89575: LD_INT 53
89577: PUSH
89578: EMPTY
89579: LIST
89580: LIST
89581: IN
89582: AND
89583: PUSH
89584: LD_VAR 0 4
89588: PPUSH
89589: LD_VAR 0 5
89593: PPUSH
89594: CALL_OW 488
89598: AND
89599: IFFALSE 89623
// CutTreeXYR ( unit , x , y , 12 ) ;
89601: LD_VAR 0 2
89605: PPUSH
89606: LD_VAR 0 4
89610: PPUSH
89611: LD_VAR 0 5
89615: PPUSH
89616: LD_INT 12
89618: PPUSH
89619: CALL 89636 0 4
// end ;
89623: LD_VAR 0 6
89627: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
89628: LD_INT 0
89630: PPUSH
// end ;
89631: LD_VAR 0 4
89635: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
89636: LD_INT 0
89638: PPUSH
89639: PPUSH
89640: PPUSH
89641: PPUSH
89642: PPUSH
89643: PPUSH
89644: PPUSH
89645: PPUSH
89646: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
89647: LD_VAR 0 1
89651: NOT
89652: PUSH
89653: LD_VAR 0 2
89657: PPUSH
89658: LD_VAR 0 3
89662: PPUSH
89663: CALL_OW 488
89667: NOT
89668: OR
89669: PUSH
89670: LD_VAR 0 4
89674: NOT
89675: OR
89676: IFFALSE 89680
// exit ;
89678: GO 90020
// list := [ ] ;
89680: LD_ADDR_VAR 0 13
89684: PUSH
89685: EMPTY
89686: ST_TO_ADDR
// if x - r < 0 then
89687: LD_VAR 0 2
89691: PUSH
89692: LD_VAR 0 4
89696: MINUS
89697: PUSH
89698: LD_INT 0
89700: LESS
89701: IFFALSE 89713
// min_x := 0 else
89703: LD_ADDR_VAR 0 7
89707: PUSH
89708: LD_INT 0
89710: ST_TO_ADDR
89711: GO 89729
// min_x := x - r ;
89713: LD_ADDR_VAR 0 7
89717: PUSH
89718: LD_VAR 0 2
89722: PUSH
89723: LD_VAR 0 4
89727: MINUS
89728: ST_TO_ADDR
// if y - r < 0 then
89729: LD_VAR 0 3
89733: PUSH
89734: LD_VAR 0 4
89738: MINUS
89739: PUSH
89740: LD_INT 0
89742: LESS
89743: IFFALSE 89755
// min_y := 0 else
89745: LD_ADDR_VAR 0 8
89749: PUSH
89750: LD_INT 0
89752: ST_TO_ADDR
89753: GO 89771
// min_y := y - r ;
89755: LD_ADDR_VAR 0 8
89759: PUSH
89760: LD_VAR 0 3
89764: PUSH
89765: LD_VAR 0 4
89769: MINUS
89770: ST_TO_ADDR
// max_x := x + r ;
89771: LD_ADDR_VAR 0 9
89775: PUSH
89776: LD_VAR 0 2
89780: PUSH
89781: LD_VAR 0 4
89785: PLUS
89786: ST_TO_ADDR
// max_y := y + r ;
89787: LD_ADDR_VAR 0 10
89791: PUSH
89792: LD_VAR 0 3
89796: PUSH
89797: LD_VAR 0 4
89801: PLUS
89802: ST_TO_ADDR
// for _x = min_x to max_x do
89803: LD_ADDR_VAR 0 11
89807: PUSH
89808: DOUBLE
89809: LD_VAR 0 7
89813: DEC
89814: ST_TO_ADDR
89815: LD_VAR 0 9
89819: PUSH
89820: FOR_TO
89821: IFFALSE 89938
// for _y = min_y to max_y do
89823: LD_ADDR_VAR 0 12
89827: PUSH
89828: DOUBLE
89829: LD_VAR 0 8
89833: DEC
89834: ST_TO_ADDR
89835: LD_VAR 0 10
89839: PUSH
89840: FOR_TO
89841: IFFALSE 89934
// begin if not ValidHex ( _x , _y ) then
89843: LD_VAR 0 11
89847: PPUSH
89848: LD_VAR 0 12
89852: PPUSH
89853: CALL_OW 488
89857: NOT
89858: IFFALSE 89862
// continue ;
89860: GO 89840
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
89862: LD_VAR 0 11
89866: PPUSH
89867: LD_VAR 0 12
89871: PPUSH
89872: CALL_OW 351
89876: PUSH
89877: LD_VAR 0 11
89881: PPUSH
89882: LD_VAR 0 12
89886: PPUSH
89887: CALL_OW 554
89891: AND
89892: IFFALSE 89932
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
89894: LD_ADDR_VAR 0 13
89898: PUSH
89899: LD_VAR 0 13
89903: PPUSH
89904: LD_VAR 0 13
89908: PUSH
89909: LD_INT 1
89911: PLUS
89912: PPUSH
89913: LD_VAR 0 11
89917: PUSH
89918: LD_VAR 0 12
89922: PUSH
89923: EMPTY
89924: LIST
89925: LIST
89926: PPUSH
89927: CALL_OW 2
89931: ST_TO_ADDR
// end ;
89932: GO 89840
89934: POP
89935: POP
89936: GO 89820
89938: POP
89939: POP
// if not list then
89940: LD_VAR 0 13
89944: NOT
89945: IFFALSE 89949
// exit ;
89947: GO 90020
// for i in list do
89949: LD_ADDR_VAR 0 6
89953: PUSH
89954: LD_VAR 0 13
89958: PUSH
89959: FOR_IN
89960: IFFALSE 90018
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
89962: LD_VAR 0 1
89966: PPUSH
89967: LD_STRING M
89969: PUSH
89970: LD_VAR 0 6
89974: PUSH
89975: LD_INT 1
89977: ARRAY
89978: PUSH
89979: LD_VAR 0 6
89983: PUSH
89984: LD_INT 2
89986: ARRAY
89987: PUSH
89988: LD_INT 0
89990: PUSH
89991: LD_INT 0
89993: PUSH
89994: LD_INT 0
89996: PUSH
89997: LD_INT 0
89999: PUSH
90000: EMPTY
90001: LIST
90002: LIST
90003: LIST
90004: LIST
90005: LIST
90006: LIST
90007: LIST
90008: PUSH
90009: EMPTY
90010: LIST
90011: PPUSH
90012: CALL_OW 447
90016: GO 89959
90018: POP
90019: POP
// end ;
90020: LD_VAR 0 5
90024: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
90025: LD_EXP 88
90029: NOT
90030: IFFALSE 90080
90032: GO 90034
90034: DISABLE
// begin initHack := true ;
90035: LD_ADDR_EXP 88
90039: PUSH
90040: LD_INT 1
90042: ST_TO_ADDR
// hackTanks := [ ] ;
90043: LD_ADDR_EXP 89
90047: PUSH
90048: EMPTY
90049: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
90050: LD_ADDR_EXP 90
90054: PUSH
90055: EMPTY
90056: ST_TO_ADDR
// hackLimit := 3 ;
90057: LD_ADDR_EXP 91
90061: PUSH
90062: LD_INT 3
90064: ST_TO_ADDR
// hackDist := 12 ;
90065: LD_ADDR_EXP 92
90069: PUSH
90070: LD_INT 12
90072: ST_TO_ADDR
// hackCounter := [ ] ;
90073: LD_ADDR_EXP 93
90077: PUSH
90078: EMPTY
90079: ST_TO_ADDR
// end ;
90080: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
90081: LD_EXP 88
90085: PUSH
90086: LD_INT 34
90088: PUSH
90089: LD_EXP 69
90093: PUSH
90094: EMPTY
90095: LIST
90096: LIST
90097: PPUSH
90098: CALL_OW 69
90102: AND
90103: IFFALSE 90358
90105: GO 90107
90107: DISABLE
90108: LD_INT 0
90110: PPUSH
90111: PPUSH
// begin enable ;
90112: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
90113: LD_ADDR_VAR 0 1
90117: PUSH
90118: LD_INT 34
90120: PUSH
90121: LD_EXP 69
90125: PUSH
90126: EMPTY
90127: LIST
90128: LIST
90129: PPUSH
90130: CALL_OW 69
90134: PUSH
90135: FOR_IN
90136: IFFALSE 90356
// begin if not i in hackTanks then
90138: LD_VAR 0 1
90142: PUSH
90143: LD_EXP 89
90147: IN
90148: NOT
90149: IFFALSE 90232
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
90151: LD_ADDR_EXP 89
90155: PUSH
90156: LD_EXP 89
90160: PPUSH
90161: LD_EXP 89
90165: PUSH
90166: LD_INT 1
90168: PLUS
90169: PPUSH
90170: LD_VAR 0 1
90174: PPUSH
90175: CALL_OW 1
90179: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
90180: LD_ADDR_EXP 90
90184: PUSH
90185: LD_EXP 90
90189: PPUSH
90190: LD_EXP 90
90194: PUSH
90195: LD_INT 1
90197: PLUS
90198: PPUSH
90199: EMPTY
90200: PPUSH
90201: CALL_OW 1
90205: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
90206: LD_ADDR_EXP 93
90210: PUSH
90211: LD_EXP 93
90215: PPUSH
90216: LD_EXP 93
90220: PUSH
90221: LD_INT 1
90223: PLUS
90224: PPUSH
90225: EMPTY
90226: PPUSH
90227: CALL_OW 1
90231: ST_TO_ADDR
// end ; if not IsOk ( i ) then
90232: LD_VAR 0 1
90236: PPUSH
90237: CALL_OW 302
90241: NOT
90242: IFFALSE 90255
// begin HackUnlinkAll ( i ) ;
90244: LD_VAR 0 1
90248: PPUSH
90249: CALL 90361 0 1
// continue ;
90253: GO 90135
// end ; HackCheckCapturedStatus ( i ) ;
90255: LD_VAR 0 1
90259: PPUSH
90260: CALL 90804 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
90264: LD_ADDR_VAR 0 2
90268: PUSH
90269: LD_INT 81
90271: PUSH
90272: LD_VAR 0 1
90276: PPUSH
90277: CALL_OW 255
90281: PUSH
90282: EMPTY
90283: LIST
90284: LIST
90285: PUSH
90286: LD_INT 33
90288: PUSH
90289: LD_INT 3
90291: PUSH
90292: EMPTY
90293: LIST
90294: LIST
90295: PUSH
90296: LD_INT 91
90298: PUSH
90299: LD_VAR 0 1
90303: PUSH
90304: LD_EXP 92
90308: PUSH
90309: EMPTY
90310: LIST
90311: LIST
90312: LIST
90313: PUSH
90314: LD_INT 50
90316: PUSH
90317: EMPTY
90318: LIST
90319: PUSH
90320: EMPTY
90321: LIST
90322: LIST
90323: LIST
90324: LIST
90325: PPUSH
90326: CALL_OW 69
90330: ST_TO_ADDR
// if not tmp then
90331: LD_VAR 0 2
90335: NOT
90336: IFFALSE 90340
// continue ;
90338: GO 90135
// HackLink ( i , tmp ) ;
90340: LD_VAR 0 1
90344: PPUSH
90345: LD_VAR 0 2
90349: PPUSH
90350: CALL 90497 0 2
// end ;
90354: GO 90135
90356: POP
90357: POP
// end ;
90358: PPOPN 2
90360: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
90361: LD_INT 0
90363: PPUSH
90364: PPUSH
90365: PPUSH
// if not hack in hackTanks then
90366: LD_VAR 0 1
90370: PUSH
90371: LD_EXP 89
90375: IN
90376: NOT
90377: IFFALSE 90381
// exit ;
90379: GO 90492
// index := GetElementIndex ( hackTanks , hack ) ;
90381: LD_ADDR_VAR 0 4
90385: PUSH
90386: LD_EXP 89
90390: PPUSH
90391: LD_VAR 0 1
90395: PPUSH
90396: CALL 15775 0 2
90400: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
90401: LD_EXP 90
90405: PUSH
90406: LD_VAR 0 4
90410: ARRAY
90411: IFFALSE 90492
// begin for i in hackTanksCaptured [ index ] do
90413: LD_ADDR_VAR 0 3
90417: PUSH
90418: LD_EXP 90
90422: PUSH
90423: LD_VAR 0 4
90427: ARRAY
90428: PUSH
90429: FOR_IN
90430: IFFALSE 90456
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
90432: LD_VAR 0 3
90436: PUSH
90437: LD_INT 1
90439: ARRAY
90440: PPUSH
90441: LD_VAR 0 3
90445: PUSH
90446: LD_INT 2
90448: ARRAY
90449: PPUSH
90450: CALL_OW 235
90454: GO 90429
90456: POP
90457: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
90458: LD_ADDR_EXP 90
90462: PUSH
90463: LD_EXP 90
90467: PPUSH
90468: LD_VAR 0 4
90472: PPUSH
90473: EMPTY
90474: PPUSH
90475: CALL_OW 1
90479: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
90480: LD_VAR 0 1
90484: PPUSH
90485: LD_INT 0
90487: PPUSH
90488: CALL_OW 505
// end ; end ;
90492: LD_VAR 0 2
90496: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
90497: LD_INT 0
90499: PPUSH
90500: PPUSH
90501: PPUSH
// if not hack in hackTanks or not vehicles then
90502: LD_VAR 0 1
90506: PUSH
90507: LD_EXP 89
90511: IN
90512: NOT
90513: PUSH
90514: LD_VAR 0 2
90518: NOT
90519: OR
90520: IFFALSE 90524
// exit ;
90522: GO 90799
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
90524: LD_ADDR_VAR 0 2
90528: PUSH
90529: LD_VAR 0 1
90533: PPUSH
90534: LD_VAR 0 2
90538: PPUSH
90539: LD_INT 1
90541: PPUSH
90542: LD_INT 1
90544: PPUSH
90545: CALL 16425 0 4
90549: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
90550: LD_ADDR_VAR 0 5
90554: PUSH
90555: LD_EXP 89
90559: PPUSH
90560: LD_VAR 0 1
90564: PPUSH
90565: CALL 15775 0 2
90569: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
90570: LD_EXP 90
90574: PUSH
90575: LD_VAR 0 5
90579: ARRAY
90580: PUSH
90581: LD_EXP 91
90585: LESS
90586: IFFALSE 90775
// begin for i := 1 to vehicles do
90588: LD_ADDR_VAR 0 4
90592: PUSH
90593: DOUBLE
90594: LD_INT 1
90596: DEC
90597: ST_TO_ADDR
90598: LD_VAR 0 2
90602: PUSH
90603: FOR_TO
90604: IFFALSE 90773
// begin if hackTanksCaptured [ index ] = hackLimit then
90606: LD_EXP 90
90610: PUSH
90611: LD_VAR 0 5
90615: ARRAY
90616: PUSH
90617: LD_EXP 91
90621: EQUAL
90622: IFFALSE 90626
// break ;
90624: GO 90773
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
90626: LD_ADDR_EXP 93
90630: PUSH
90631: LD_EXP 93
90635: PPUSH
90636: LD_VAR 0 5
90640: PPUSH
90641: LD_EXP 93
90645: PUSH
90646: LD_VAR 0 5
90650: ARRAY
90651: PUSH
90652: LD_INT 1
90654: PLUS
90655: PPUSH
90656: CALL_OW 1
90660: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
90661: LD_ADDR_EXP 90
90665: PUSH
90666: LD_EXP 90
90670: PPUSH
90671: LD_VAR 0 5
90675: PUSH
90676: LD_EXP 90
90680: PUSH
90681: LD_VAR 0 5
90685: ARRAY
90686: PUSH
90687: LD_INT 1
90689: PLUS
90690: PUSH
90691: EMPTY
90692: LIST
90693: LIST
90694: PPUSH
90695: LD_VAR 0 2
90699: PUSH
90700: LD_VAR 0 4
90704: ARRAY
90705: PUSH
90706: LD_VAR 0 2
90710: PUSH
90711: LD_VAR 0 4
90715: ARRAY
90716: PPUSH
90717: CALL_OW 255
90721: PUSH
90722: EMPTY
90723: LIST
90724: LIST
90725: PPUSH
90726: CALL 15990 0 3
90730: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
90731: LD_VAR 0 2
90735: PUSH
90736: LD_VAR 0 4
90740: ARRAY
90741: PPUSH
90742: LD_VAR 0 1
90746: PPUSH
90747: CALL_OW 255
90751: PPUSH
90752: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
90756: LD_VAR 0 2
90760: PUSH
90761: LD_VAR 0 4
90765: ARRAY
90766: PPUSH
90767: CALL_OW 141
// end ;
90771: GO 90603
90773: POP
90774: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
90775: LD_VAR 0 1
90779: PPUSH
90780: LD_EXP 90
90784: PUSH
90785: LD_VAR 0 5
90789: ARRAY
90790: PUSH
90791: LD_INT 0
90793: PLUS
90794: PPUSH
90795: CALL_OW 505
// end ;
90799: LD_VAR 0 3
90803: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
90804: LD_INT 0
90806: PPUSH
90807: PPUSH
90808: PPUSH
90809: PPUSH
// if not hack in hackTanks then
90810: LD_VAR 0 1
90814: PUSH
90815: LD_EXP 89
90819: IN
90820: NOT
90821: IFFALSE 90825
// exit ;
90823: GO 91065
// index := GetElementIndex ( hackTanks , hack ) ;
90825: LD_ADDR_VAR 0 4
90829: PUSH
90830: LD_EXP 89
90834: PPUSH
90835: LD_VAR 0 1
90839: PPUSH
90840: CALL 15775 0 2
90844: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
90845: LD_ADDR_VAR 0 3
90849: PUSH
90850: DOUBLE
90851: LD_EXP 90
90855: PUSH
90856: LD_VAR 0 4
90860: ARRAY
90861: INC
90862: ST_TO_ADDR
90863: LD_INT 1
90865: PUSH
90866: FOR_DOWNTO
90867: IFFALSE 91039
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
90869: LD_ADDR_VAR 0 5
90873: PUSH
90874: LD_EXP 90
90878: PUSH
90879: LD_VAR 0 4
90883: ARRAY
90884: PUSH
90885: LD_VAR 0 3
90889: ARRAY
90890: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
90891: LD_VAR 0 5
90895: PUSH
90896: LD_INT 1
90898: ARRAY
90899: PPUSH
90900: CALL_OW 302
90904: NOT
90905: PUSH
90906: LD_VAR 0 5
90910: PUSH
90911: LD_INT 1
90913: ARRAY
90914: PPUSH
90915: CALL_OW 255
90919: PUSH
90920: LD_VAR 0 1
90924: PPUSH
90925: CALL_OW 255
90929: NONEQUAL
90930: OR
90931: IFFALSE 91037
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
90933: LD_VAR 0 5
90937: PUSH
90938: LD_INT 1
90940: ARRAY
90941: PPUSH
90942: CALL_OW 305
90946: PUSH
90947: LD_VAR 0 5
90951: PUSH
90952: LD_INT 1
90954: ARRAY
90955: PPUSH
90956: CALL_OW 255
90960: PUSH
90961: LD_VAR 0 1
90965: PPUSH
90966: CALL_OW 255
90970: EQUAL
90971: AND
90972: IFFALSE 90996
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
90974: LD_VAR 0 5
90978: PUSH
90979: LD_INT 1
90981: ARRAY
90982: PPUSH
90983: LD_VAR 0 5
90987: PUSH
90988: LD_INT 2
90990: ARRAY
90991: PPUSH
90992: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
90996: LD_ADDR_EXP 90
91000: PUSH
91001: LD_EXP 90
91005: PPUSH
91006: LD_VAR 0 4
91010: PPUSH
91011: LD_EXP 90
91015: PUSH
91016: LD_VAR 0 4
91020: ARRAY
91021: PPUSH
91022: LD_VAR 0 3
91026: PPUSH
91027: CALL_OW 3
91031: PPUSH
91032: CALL_OW 1
91036: ST_TO_ADDR
// end ; end ;
91037: GO 90866
91039: POP
91040: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
91041: LD_VAR 0 1
91045: PPUSH
91046: LD_EXP 90
91050: PUSH
91051: LD_VAR 0 4
91055: ARRAY
91056: PUSH
91057: LD_INT 0
91059: PLUS
91060: PPUSH
91061: CALL_OW 505
// end ;
91065: LD_VAR 0 2
91069: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
91070: LD_INT 0
91072: PPUSH
91073: PPUSH
91074: PPUSH
91075: PPUSH
// if not hack in hackTanks then
91076: LD_VAR 0 1
91080: PUSH
91081: LD_EXP 89
91085: IN
91086: NOT
91087: IFFALSE 91091
// exit ;
91089: GO 91176
// index := GetElementIndex ( hackTanks , hack ) ;
91091: LD_ADDR_VAR 0 5
91095: PUSH
91096: LD_EXP 89
91100: PPUSH
91101: LD_VAR 0 1
91105: PPUSH
91106: CALL 15775 0 2
91110: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
91111: LD_ADDR_VAR 0 4
91115: PUSH
91116: DOUBLE
91117: LD_INT 1
91119: DEC
91120: ST_TO_ADDR
91121: LD_EXP 90
91125: PUSH
91126: LD_VAR 0 5
91130: ARRAY
91131: PUSH
91132: FOR_TO
91133: IFFALSE 91174
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
91135: LD_EXP 90
91139: PUSH
91140: LD_VAR 0 5
91144: ARRAY
91145: PUSH
91146: LD_VAR 0 4
91150: ARRAY
91151: PUSH
91152: LD_INT 1
91154: ARRAY
91155: PUSH
91156: LD_VAR 0 2
91160: EQUAL
91161: IFFALSE 91172
// KillUnit ( vehicle ) ;
91163: LD_VAR 0 2
91167: PPUSH
91168: CALL_OW 66
91172: GO 91132
91174: POP
91175: POP
// end ;
91176: LD_VAR 0 3
91180: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
91181: LD_EXP 94
91185: NOT
91186: IFFALSE 91221
91188: GO 91190
91190: DISABLE
// begin initMiner := true ;
91191: LD_ADDR_EXP 94
91195: PUSH
91196: LD_INT 1
91198: ST_TO_ADDR
// minersList := [ ] ;
91199: LD_ADDR_EXP 95
91203: PUSH
91204: EMPTY
91205: ST_TO_ADDR
// minerMinesList := [ ] ;
91206: LD_ADDR_EXP 96
91210: PUSH
91211: EMPTY
91212: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
91213: LD_ADDR_EXP 97
91217: PUSH
91218: LD_INT 5
91220: ST_TO_ADDR
// end ;
91221: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
91222: LD_EXP 94
91226: PUSH
91227: LD_INT 34
91229: PUSH
91230: LD_EXP 74
91234: PUSH
91235: EMPTY
91236: LIST
91237: LIST
91238: PPUSH
91239: CALL_OW 69
91243: AND
91244: IFFALSE 91707
91246: GO 91248
91248: DISABLE
91249: LD_INT 0
91251: PPUSH
91252: PPUSH
91253: PPUSH
91254: PPUSH
// begin enable ;
91255: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
91256: LD_ADDR_VAR 0 1
91260: PUSH
91261: LD_INT 34
91263: PUSH
91264: LD_EXP 74
91268: PUSH
91269: EMPTY
91270: LIST
91271: LIST
91272: PPUSH
91273: CALL_OW 69
91277: PUSH
91278: FOR_IN
91279: IFFALSE 91351
// begin if not i in minersList then
91281: LD_VAR 0 1
91285: PUSH
91286: LD_EXP 95
91290: IN
91291: NOT
91292: IFFALSE 91349
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
91294: LD_ADDR_EXP 95
91298: PUSH
91299: LD_EXP 95
91303: PPUSH
91304: LD_EXP 95
91308: PUSH
91309: LD_INT 1
91311: PLUS
91312: PPUSH
91313: LD_VAR 0 1
91317: PPUSH
91318: CALL_OW 1
91322: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
91323: LD_ADDR_EXP 96
91327: PUSH
91328: LD_EXP 96
91332: PPUSH
91333: LD_EXP 96
91337: PUSH
91338: LD_INT 1
91340: PLUS
91341: PPUSH
91342: EMPTY
91343: PPUSH
91344: CALL_OW 1
91348: ST_TO_ADDR
// end end ;
91349: GO 91278
91351: POP
91352: POP
// for i := minerMinesList downto 1 do
91353: LD_ADDR_VAR 0 1
91357: PUSH
91358: DOUBLE
91359: LD_EXP 96
91363: INC
91364: ST_TO_ADDR
91365: LD_INT 1
91367: PUSH
91368: FOR_DOWNTO
91369: IFFALSE 91705
// begin if IsLive ( minersList [ i ] ) then
91371: LD_EXP 95
91375: PUSH
91376: LD_VAR 0 1
91380: ARRAY
91381: PPUSH
91382: CALL_OW 300
91386: IFFALSE 91414
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
91388: LD_EXP 95
91392: PUSH
91393: LD_VAR 0 1
91397: ARRAY
91398: PPUSH
91399: LD_EXP 96
91403: PUSH
91404: LD_VAR 0 1
91408: ARRAY
91409: PPUSH
91410: CALL_OW 505
// if not minerMinesList [ i ] then
91414: LD_EXP 96
91418: PUSH
91419: LD_VAR 0 1
91423: ARRAY
91424: NOT
91425: IFFALSE 91429
// continue ;
91427: GO 91368
// for j := minerMinesList [ i ] downto 1 do
91429: LD_ADDR_VAR 0 2
91433: PUSH
91434: DOUBLE
91435: LD_EXP 96
91439: PUSH
91440: LD_VAR 0 1
91444: ARRAY
91445: INC
91446: ST_TO_ADDR
91447: LD_INT 1
91449: PUSH
91450: FOR_DOWNTO
91451: IFFALSE 91701
// begin side := GetSide ( minersList [ i ] ) ;
91453: LD_ADDR_VAR 0 3
91457: PUSH
91458: LD_EXP 95
91462: PUSH
91463: LD_VAR 0 1
91467: ARRAY
91468: PPUSH
91469: CALL_OW 255
91473: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
91474: LD_ADDR_VAR 0 4
91478: PUSH
91479: LD_EXP 96
91483: PUSH
91484: LD_VAR 0 1
91488: ARRAY
91489: PUSH
91490: LD_VAR 0 2
91494: ARRAY
91495: PUSH
91496: LD_INT 1
91498: ARRAY
91499: PPUSH
91500: LD_EXP 96
91504: PUSH
91505: LD_VAR 0 1
91509: ARRAY
91510: PUSH
91511: LD_VAR 0 2
91515: ARRAY
91516: PUSH
91517: LD_INT 2
91519: ARRAY
91520: PPUSH
91521: CALL_OW 428
91525: ST_TO_ADDR
// if not tmp then
91526: LD_VAR 0 4
91530: NOT
91531: IFFALSE 91535
// continue ;
91533: GO 91450
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
91535: LD_VAR 0 4
91539: PUSH
91540: LD_INT 81
91542: PUSH
91543: LD_VAR 0 3
91547: PUSH
91548: EMPTY
91549: LIST
91550: LIST
91551: PPUSH
91552: CALL_OW 69
91556: IN
91557: PUSH
91558: LD_EXP 96
91562: PUSH
91563: LD_VAR 0 1
91567: ARRAY
91568: PUSH
91569: LD_VAR 0 2
91573: ARRAY
91574: PUSH
91575: LD_INT 1
91577: ARRAY
91578: PPUSH
91579: LD_EXP 96
91583: PUSH
91584: LD_VAR 0 1
91588: ARRAY
91589: PUSH
91590: LD_VAR 0 2
91594: ARRAY
91595: PUSH
91596: LD_INT 2
91598: ARRAY
91599: PPUSH
91600: CALL_OW 458
91604: AND
91605: IFFALSE 91699
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
91607: LD_EXP 96
91611: PUSH
91612: LD_VAR 0 1
91616: ARRAY
91617: PUSH
91618: LD_VAR 0 2
91622: ARRAY
91623: PUSH
91624: LD_INT 1
91626: ARRAY
91627: PPUSH
91628: LD_EXP 96
91632: PUSH
91633: LD_VAR 0 1
91637: ARRAY
91638: PUSH
91639: LD_VAR 0 2
91643: ARRAY
91644: PUSH
91645: LD_INT 2
91647: ARRAY
91648: PPUSH
91649: LD_VAR 0 3
91653: PPUSH
91654: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
91658: LD_ADDR_EXP 96
91662: PUSH
91663: LD_EXP 96
91667: PPUSH
91668: LD_VAR 0 1
91672: PPUSH
91673: LD_EXP 96
91677: PUSH
91678: LD_VAR 0 1
91682: ARRAY
91683: PPUSH
91684: LD_VAR 0 2
91688: PPUSH
91689: CALL_OW 3
91693: PPUSH
91694: CALL_OW 1
91698: ST_TO_ADDR
// end ; end ;
91699: GO 91450
91701: POP
91702: POP
// end ;
91703: GO 91368
91705: POP
91706: POP
// end ;
91707: PPOPN 4
91709: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
91710: LD_INT 0
91712: PPUSH
91713: PPUSH
// result := false ;
91714: LD_ADDR_VAR 0 4
91718: PUSH
91719: LD_INT 0
91721: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
91722: LD_VAR 0 1
91726: PPUSH
91727: CALL_OW 264
91731: PUSH
91732: LD_EXP 74
91736: EQUAL
91737: NOT
91738: IFFALSE 91742
// exit ;
91740: GO 91982
// index := GetElementIndex ( minersList , unit ) ;
91742: LD_ADDR_VAR 0 5
91746: PUSH
91747: LD_EXP 95
91751: PPUSH
91752: LD_VAR 0 1
91756: PPUSH
91757: CALL 15775 0 2
91761: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
91762: LD_EXP 96
91766: PUSH
91767: LD_VAR 0 5
91771: ARRAY
91772: PUSH
91773: LD_EXP 97
91777: GREATEREQUAL
91778: IFFALSE 91782
// exit ;
91780: GO 91982
// ComMoveXY ( unit , x , y ) ;
91782: LD_VAR 0 1
91786: PPUSH
91787: LD_VAR 0 2
91791: PPUSH
91792: LD_VAR 0 3
91796: PPUSH
91797: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
91801: LD_INT 35
91803: PPUSH
91804: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
91808: LD_VAR 0 1
91812: PPUSH
91813: LD_VAR 0 2
91817: PPUSH
91818: LD_VAR 0 3
91822: PPUSH
91823: CALL 46547 0 3
91827: NOT
91828: PUSH
91829: LD_VAR 0 1
91833: PPUSH
91834: CALL_OW 314
91838: AND
91839: IFFALSE 91843
// exit ;
91841: GO 91982
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
91843: LD_VAR 0 2
91847: PPUSH
91848: LD_VAR 0 3
91852: PPUSH
91853: CALL_OW 428
91857: PUSH
91858: LD_VAR 0 1
91862: EQUAL
91863: PUSH
91864: LD_VAR 0 1
91868: PPUSH
91869: CALL_OW 314
91873: NOT
91874: AND
91875: IFFALSE 91801
// PlaySoundXY ( x , y , PlantMine ) ;
91877: LD_VAR 0 2
91881: PPUSH
91882: LD_VAR 0 3
91886: PPUSH
91887: LD_STRING PlantMine
91889: PPUSH
91890: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
91894: LD_VAR 0 2
91898: PPUSH
91899: LD_VAR 0 3
91903: PPUSH
91904: LD_VAR 0 1
91908: PPUSH
91909: CALL_OW 255
91913: PPUSH
91914: LD_INT 0
91916: PPUSH
91917: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
91921: LD_ADDR_EXP 96
91925: PUSH
91926: LD_EXP 96
91930: PPUSH
91931: LD_VAR 0 5
91935: PUSH
91936: LD_EXP 96
91940: PUSH
91941: LD_VAR 0 5
91945: ARRAY
91946: PUSH
91947: LD_INT 1
91949: PLUS
91950: PUSH
91951: EMPTY
91952: LIST
91953: LIST
91954: PPUSH
91955: LD_VAR 0 2
91959: PUSH
91960: LD_VAR 0 3
91964: PUSH
91965: EMPTY
91966: LIST
91967: LIST
91968: PPUSH
91969: CALL 15990 0 3
91973: ST_TO_ADDR
// result := true ;
91974: LD_ADDR_VAR 0 4
91978: PUSH
91979: LD_INT 1
91981: ST_TO_ADDR
// end ;
91982: LD_VAR 0 4
91986: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
91987: LD_INT 0
91989: PPUSH
91990: PPUSH
91991: PPUSH
// if not unit in minersList then
91992: LD_VAR 0 1
91996: PUSH
91997: LD_EXP 95
92001: IN
92002: NOT
92003: IFFALSE 92007
// exit ;
92005: GO 92399
// index := GetElementIndex ( minersList , unit ) ;
92007: LD_ADDR_VAR 0 6
92011: PUSH
92012: LD_EXP 95
92016: PPUSH
92017: LD_VAR 0 1
92021: PPUSH
92022: CALL 15775 0 2
92026: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
92027: LD_ADDR_VAR 0 5
92031: PUSH
92032: DOUBLE
92033: LD_EXP 96
92037: PUSH
92038: LD_VAR 0 6
92042: ARRAY
92043: INC
92044: ST_TO_ADDR
92045: LD_INT 1
92047: PUSH
92048: FOR_DOWNTO
92049: IFFALSE 92210
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
92051: LD_EXP 96
92055: PUSH
92056: LD_VAR 0 6
92060: ARRAY
92061: PUSH
92062: LD_VAR 0 5
92066: ARRAY
92067: PUSH
92068: LD_INT 1
92070: ARRAY
92071: PUSH
92072: LD_VAR 0 2
92076: EQUAL
92077: PUSH
92078: LD_EXP 96
92082: PUSH
92083: LD_VAR 0 6
92087: ARRAY
92088: PUSH
92089: LD_VAR 0 5
92093: ARRAY
92094: PUSH
92095: LD_INT 2
92097: ARRAY
92098: PUSH
92099: LD_VAR 0 3
92103: EQUAL
92104: AND
92105: IFFALSE 92208
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
92107: LD_EXP 96
92111: PUSH
92112: LD_VAR 0 6
92116: ARRAY
92117: PUSH
92118: LD_VAR 0 5
92122: ARRAY
92123: PUSH
92124: LD_INT 1
92126: ARRAY
92127: PPUSH
92128: LD_EXP 96
92132: PUSH
92133: LD_VAR 0 6
92137: ARRAY
92138: PUSH
92139: LD_VAR 0 5
92143: ARRAY
92144: PUSH
92145: LD_INT 2
92147: ARRAY
92148: PPUSH
92149: LD_VAR 0 1
92153: PPUSH
92154: CALL_OW 255
92158: PPUSH
92159: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
92163: LD_ADDR_EXP 96
92167: PUSH
92168: LD_EXP 96
92172: PPUSH
92173: LD_VAR 0 6
92177: PPUSH
92178: LD_EXP 96
92182: PUSH
92183: LD_VAR 0 6
92187: ARRAY
92188: PPUSH
92189: LD_VAR 0 5
92193: PPUSH
92194: CALL_OW 3
92198: PPUSH
92199: CALL_OW 1
92203: ST_TO_ADDR
// exit ;
92204: POP
92205: POP
92206: GO 92399
// end ; end ;
92208: GO 92048
92210: POP
92211: POP
// for i := minerMinesList [ index ] downto 1 do
92212: LD_ADDR_VAR 0 5
92216: PUSH
92217: DOUBLE
92218: LD_EXP 96
92222: PUSH
92223: LD_VAR 0 6
92227: ARRAY
92228: INC
92229: ST_TO_ADDR
92230: LD_INT 1
92232: PUSH
92233: FOR_DOWNTO
92234: IFFALSE 92397
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
92236: LD_EXP 96
92240: PUSH
92241: LD_VAR 0 6
92245: ARRAY
92246: PUSH
92247: LD_VAR 0 5
92251: ARRAY
92252: PUSH
92253: LD_INT 1
92255: ARRAY
92256: PPUSH
92257: LD_EXP 96
92261: PUSH
92262: LD_VAR 0 6
92266: ARRAY
92267: PUSH
92268: LD_VAR 0 5
92272: ARRAY
92273: PUSH
92274: LD_INT 2
92276: ARRAY
92277: PPUSH
92278: LD_VAR 0 2
92282: PPUSH
92283: LD_VAR 0 3
92287: PPUSH
92288: CALL_OW 298
92292: PUSH
92293: LD_INT 6
92295: LESS
92296: IFFALSE 92395
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
92298: LD_EXP 96
92302: PUSH
92303: LD_VAR 0 6
92307: ARRAY
92308: PUSH
92309: LD_VAR 0 5
92313: ARRAY
92314: PUSH
92315: LD_INT 1
92317: ARRAY
92318: PPUSH
92319: LD_EXP 96
92323: PUSH
92324: LD_VAR 0 6
92328: ARRAY
92329: PUSH
92330: LD_VAR 0 5
92334: ARRAY
92335: PUSH
92336: LD_INT 2
92338: ARRAY
92339: PPUSH
92340: LD_VAR 0 1
92344: PPUSH
92345: CALL_OW 255
92349: PPUSH
92350: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
92354: LD_ADDR_EXP 96
92358: PUSH
92359: LD_EXP 96
92363: PPUSH
92364: LD_VAR 0 6
92368: PPUSH
92369: LD_EXP 96
92373: PUSH
92374: LD_VAR 0 6
92378: ARRAY
92379: PPUSH
92380: LD_VAR 0 5
92384: PPUSH
92385: CALL_OW 3
92389: PPUSH
92390: CALL_OW 1
92394: ST_TO_ADDR
// end ; end ;
92395: GO 92233
92397: POP
92398: POP
// end ;
92399: LD_VAR 0 4
92403: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
92404: LD_INT 0
92406: PPUSH
92407: PPUSH
92408: PPUSH
92409: PPUSH
92410: PPUSH
92411: PPUSH
92412: PPUSH
92413: PPUSH
92414: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
92415: LD_VAR 0 1
92419: PPUSH
92420: CALL_OW 264
92424: PUSH
92425: LD_EXP 74
92429: EQUAL
92430: NOT
92431: PUSH
92432: LD_VAR 0 1
92436: PUSH
92437: LD_EXP 95
92441: IN
92442: NOT
92443: OR
92444: IFFALSE 92448
// exit ;
92446: GO 92770
// index := GetElementIndex ( minersList , unit ) ;
92448: LD_ADDR_VAR 0 6
92452: PUSH
92453: LD_EXP 95
92457: PPUSH
92458: LD_VAR 0 1
92462: PPUSH
92463: CALL 15775 0 2
92467: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
92468: LD_ADDR_VAR 0 8
92472: PUSH
92473: LD_EXP 97
92477: PUSH
92478: LD_EXP 96
92482: PUSH
92483: LD_VAR 0 6
92487: ARRAY
92488: MINUS
92489: ST_TO_ADDR
// if not minesFreeAmount then
92490: LD_VAR 0 8
92494: NOT
92495: IFFALSE 92499
// exit ;
92497: GO 92770
// tmp := [ ] ;
92499: LD_ADDR_VAR 0 7
92503: PUSH
92504: EMPTY
92505: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
92506: LD_ADDR_VAR 0 5
92510: PUSH
92511: DOUBLE
92512: LD_INT 1
92514: DEC
92515: ST_TO_ADDR
92516: LD_VAR 0 8
92520: PUSH
92521: FOR_TO
92522: IFFALSE 92717
// begin _d := rand ( 0 , 5 ) ;
92524: LD_ADDR_VAR 0 11
92528: PUSH
92529: LD_INT 0
92531: PPUSH
92532: LD_INT 5
92534: PPUSH
92535: CALL_OW 12
92539: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
92540: LD_ADDR_VAR 0 12
92544: PUSH
92545: LD_INT 2
92547: PPUSH
92548: LD_INT 6
92550: PPUSH
92551: CALL_OW 12
92555: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
92556: LD_ADDR_VAR 0 9
92560: PUSH
92561: LD_VAR 0 2
92565: PPUSH
92566: LD_VAR 0 11
92570: PPUSH
92571: LD_VAR 0 12
92575: PPUSH
92576: CALL_OW 272
92580: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
92581: LD_ADDR_VAR 0 10
92585: PUSH
92586: LD_VAR 0 3
92590: PPUSH
92591: LD_VAR 0 11
92595: PPUSH
92596: LD_VAR 0 12
92600: PPUSH
92601: CALL_OW 273
92605: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
92606: LD_VAR 0 9
92610: PPUSH
92611: LD_VAR 0 10
92615: PPUSH
92616: CALL_OW 488
92620: PUSH
92621: LD_VAR 0 9
92625: PUSH
92626: LD_VAR 0 10
92630: PUSH
92631: EMPTY
92632: LIST
92633: LIST
92634: PUSH
92635: LD_VAR 0 7
92639: IN
92640: NOT
92641: AND
92642: PUSH
92643: LD_VAR 0 9
92647: PPUSH
92648: LD_VAR 0 10
92652: PPUSH
92653: CALL_OW 458
92657: NOT
92658: AND
92659: IFFALSE 92701
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
92661: LD_ADDR_VAR 0 7
92665: PUSH
92666: LD_VAR 0 7
92670: PPUSH
92671: LD_VAR 0 7
92675: PUSH
92676: LD_INT 1
92678: PLUS
92679: PPUSH
92680: LD_VAR 0 9
92684: PUSH
92685: LD_VAR 0 10
92689: PUSH
92690: EMPTY
92691: LIST
92692: LIST
92693: PPUSH
92694: CALL_OW 1
92698: ST_TO_ADDR
92699: GO 92715
// i := i - 1 ;
92701: LD_ADDR_VAR 0 5
92705: PUSH
92706: LD_VAR 0 5
92710: PUSH
92711: LD_INT 1
92713: MINUS
92714: ST_TO_ADDR
// end ;
92715: GO 92521
92717: POP
92718: POP
// for i in tmp do
92719: LD_ADDR_VAR 0 5
92723: PUSH
92724: LD_VAR 0 7
92728: PUSH
92729: FOR_IN
92730: IFFALSE 92768
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
92732: LD_VAR 0 1
92736: PPUSH
92737: LD_VAR 0 5
92741: PUSH
92742: LD_INT 1
92744: ARRAY
92745: PPUSH
92746: LD_VAR 0 5
92750: PUSH
92751: LD_INT 2
92753: ARRAY
92754: PPUSH
92755: CALL 91710 0 3
92759: NOT
92760: IFFALSE 92766
// exit ;
92762: POP
92763: POP
92764: GO 92770
92766: GO 92729
92768: POP
92769: POP
// end ;
92770: LD_VAR 0 4
92774: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
92775: LD_INT 0
92777: PPUSH
92778: PPUSH
92779: PPUSH
92780: PPUSH
92781: PPUSH
92782: PPUSH
92783: PPUSH
// if not GetClass ( unit ) = class_sniper then
92784: LD_VAR 0 1
92788: PPUSH
92789: CALL_OW 257
92793: PUSH
92794: LD_INT 5
92796: EQUAL
92797: NOT
92798: IFFALSE 92802
// exit ;
92800: GO 93190
// dist := 8 ;
92802: LD_ADDR_VAR 0 5
92806: PUSH
92807: LD_INT 8
92809: ST_TO_ADDR
// viewRange := 12 ;
92810: LD_ADDR_VAR 0 7
92814: PUSH
92815: LD_INT 12
92817: ST_TO_ADDR
// side := GetSide ( unit ) ;
92818: LD_ADDR_VAR 0 6
92822: PUSH
92823: LD_VAR 0 1
92827: PPUSH
92828: CALL_OW 255
92832: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
92833: LD_INT 61
92835: PPUSH
92836: LD_VAR 0 6
92840: PPUSH
92841: CALL_OW 321
92845: PUSH
92846: LD_INT 2
92848: EQUAL
92849: IFFALSE 92859
// viewRange := 16 ;
92851: LD_ADDR_VAR 0 7
92855: PUSH
92856: LD_INT 16
92858: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
92859: LD_VAR 0 1
92863: PPUSH
92864: LD_VAR 0 2
92868: PPUSH
92869: LD_VAR 0 3
92873: PPUSH
92874: CALL_OW 297
92878: PUSH
92879: LD_VAR 0 5
92883: GREATER
92884: IFFALSE 92963
// begin ComMoveXY ( unit , x , y ) ;
92886: LD_VAR 0 1
92890: PPUSH
92891: LD_VAR 0 2
92895: PPUSH
92896: LD_VAR 0 3
92900: PPUSH
92901: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
92905: LD_INT 35
92907: PPUSH
92908: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
92912: LD_VAR 0 1
92916: PPUSH
92917: LD_VAR 0 2
92921: PPUSH
92922: LD_VAR 0 3
92926: PPUSH
92927: CALL 46547 0 3
92931: NOT
92932: IFFALSE 92936
// exit ;
92934: GO 93190
// until GetDistUnitXY ( unit , x , y ) < dist ;
92936: LD_VAR 0 1
92940: PPUSH
92941: LD_VAR 0 2
92945: PPUSH
92946: LD_VAR 0 3
92950: PPUSH
92951: CALL_OW 297
92955: PUSH
92956: LD_VAR 0 5
92960: LESS
92961: IFFALSE 92905
// end ; ComTurnXY ( unit , x , y ) ;
92963: LD_VAR 0 1
92967: PPUSH
92968: LD_VAR 0 2
92972: PPUSH
92973: LD_VAR 0 3
92977: PPUSH
92978: CALL_OW 118
// wait ( 5 ) ;
92982: LD_INT 5
92984: PPUSH
92985: CALL_OW 67
// _d := GetDir ( unit ) ;
92989: LD_ADDR_VAR 0 10
92993: PUSH
92994: LD_VAR 0 1
92998: PPUSH
92999: CALL_OW 254
93003: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
93004: LD_ADDR_VAR 0 8
93008: PUSH
93009: LD_VAR 0 1
93013: PPUSH
93014: CALL_OW 250
93018: PPUSH
93019: LD_VAR 0 10
93023: PPUSH
93024: LD_VAR 0 5
93028: PPUSH
93029: CALL_OW 272
93033: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
93034: LD_ADDR_VAR 0 9
93038: PUSH
93039: LD_VAR 0 1
93043: PPUSH
93044: CALL_OW 251
93048: PPUSH
93049: LD_VAR 0 10
93053: PPUSH
93054: LD_VAR 0 5
93058: PPUSH
93059: CALL_OW 273
93063: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
93064: LD_VAR 0 8
93068: PPUSH
93069: LD_VAR 0 9
93073: PPUSH
93074: CALL_OW 488
93078: NOT
93079: IFFALSE 93083
// exit ;
93081: GO 93190
// ComAnimCustom ( unit , 1 ) ;
93083: LD_VAR 0 1
93087: PPUSH
93088: LD_INT 1
93090: PPUSH
93091: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
93095: LD_VAR 0 8
93099: PPUSH
93100: LD_VAR 0 9
93104: PPUSH
93105: LD_VAR 0 6
93109: PPUSH
93110: LD_VAR 0 7
93114: PPUSH
93115: CALL_OW 330
// repeat wait ( 1 ) ;
93119: LD_INT 1
93121: PPUSH
93122: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
93126: LD_VAR 0 1
93130: PPUSH
93131: CALL_OW 316
93135: PUSH
93136: LD_VAR 0 1
93140: PPUSH
93141: CALL_OW 314
93145: OR
93146: PUSH
93147: LD_VAR 0 1
93151: PPUSH
93152: CALL_OW 302
93156: NOT
93157: OR
93158: PUSH
93159: LD_VAR 0 1
93163: PPUSH
93164: CALL_OW 301
93168: OR
93169: IFFALSE 93119
// RemoveSeeing ( _x , _y , side ) ;
93171: LD_VAR 0 8
93175: PPUSH
93176: LD_VAR 0 9
93180: PPUSH
93181: LD_VAR 0 6
93185: PPUSH
93186: CALL_OW 331
// end ; end_of_file end_of_file
93190: LD_VAR 0 4
93194: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
93195: LD_VAR 0 1
93199: PUSH
93200: LD_INT 200
93202: DOUBLE
93203: GREATEREQUAL
93204: IFFALSE 93212
93206: LD_INT 299
93208: DOUBLE
93209: LESSEQUAL
93210: IFTRUE 93214
93212: GO 93246
93214: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
93215: LD_VAR 0 1
93219: PPUSH
93220: LD_VAR 0 2
93224: PPUSH
93225: LD_VAR 0 3
93229: PPUSH
93230: LD_VAR 0 4
93234: PPUSH
93235: LD_VAR 0 5
93239: PPUSH
93240: CALL 89312 0 5
93244: GO 93323
93246: LD_INT 300
93248: DOUBLE
93249: GREATEREQUAL
93250: IFFALSE 93258
93252: LD_INT 399
93254: DOUBLE
93255: LESSEQUAL
93256: IFTRUE 93260
93258: GO 93322
93260: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
93261: LD_VAR 0 1
93265: PPUSH
93266: LD_VAR 0 2
93270: PPUSH
93271: LD_VAR 0 3
93275: PPUSH
93276: LD_VAR 0 4
93280: PPUSH
93281: LD_VAR 0 5
93285: PPUSH
93286: LD_VAR 0 6
93290: PPUSH
93291: LD_VAR 0 7
93295: PPUSH
93296: LD_VAR 0 8
93300: PPUSH
93301: LD_VAR 0 9
93305: PPUSH
93306: LD_VAR 0 10
93310: PPUSH
93311: LD_VAR 0 11
93315: PPUSH
93316: CALL 105185 0 11
93320: GO 93323
93322: POP
// end ;
93323: PPOPN 11
93325: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
93326: LD_VAR 0 1
93330: PPUSH
93331: LD_VAR 0 2
93335: PPUSH
93336: LD_VAR 0 3
93340: PPUSH
93341: LD_VAR 0 4
93345: PPUSH
93346: LD_VAR 0 5
93350: PPUSH
93351: CALL 89304 0 5
// end ; end_of_file
93355: PPOPN 5
93357: END
// every 0 0$1 do
93358: GO 93360
93360: DISABLE
// begin enable ;
93361: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
93362: LD_STRING updateTimer(
93364: PUSH
93365: LD_OWVAR 1
93369: STR
93370: PUSH
93371: LD_STRING );
93373: STR
93374: PPUSH
93375: CALL_OW 559
// end ;
93379: END
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
93380: LD_INT 0
93382: PPUSH
// if p2 = 100 then
93383: LD_VAR 0 2
93387: PUSH
93388: LD_INT 100
93390: EQUAL
93391: IFFALSE 94394
// begin if not StreamModeActive then
93393: LD_EXP 98
93397: NOT
93398: IFFALSE 93408
// StreamModeActive := true ;
93400: LD_ADDR_EXP 98
93404: PUSH
93405: LD_INT 1
93407: ST_TO_ADDR
// if p3 = 0 then
93408: LD_VAR 0 3
93412: PUSH
93413: LD_INT 0
93415: EQUAL
93416: IFFALSE 93422
// InitStreamMode ;
93418: CALL 94554 0 0
// if p3 = 1 then
93422: LD_VAR 0 3
93426: PUSH
93427: LD_INT 1
93429: EQUAL
93430: IFFALSE 93440
// sRocket := true ;
93432: LD_ADDR_EXP 103
93436: PUSH
93437: LD_INT 1
93439: ST_TO_ADDR
// if p3 = 2 then
93440: LD_VAR 0 3
93444: PUSH
93445: LD_INT 2
93447: EQUAL
93448: IFFALSE 93458
// sSpeed := true ;
93450: LD_ADDR_EXP 102
93454: PUSH
93455: LD_INT 1
93457: ST_TO_ADDR
// if p3 = 3 then
93458: LD_VAR 0 3
93462: PUSH
93463: LD_INT 3
93465: EQUAL
93466: IFFALSE 93476
// sEngine := true ;
93468: LD_ADDR_EXP 104
93472: PUSH
93473: LD_INT 1
93475: ST_TO_ADDR
// if p3 = 4 then
93476: LD_VAR 0 3
93480: PUSH
93481: LD_INT 4
93483: EQUAL
93484: IFFALSE 93494
// sSpec := true ;
93486: LD_ADDR_EXP 101
93490: PUSH
93491: LD_INT 1
93493: ST_TO_ADDR
// if p3 = 5 then
93494: LD_VAR 0 3
93498: PUSH
93499: LD_INT 5
93501: EQUAL
93502: IFFALSE 93512
// sLevel := true ;
93504: LD_ADDR_EXP 105
93508: PUSH
93509: LD_INT 1
93511: ST_TO_ADDR
// if p3 = 6 then
93512: LD_VAR 0 3
93516: PUSH
93517: LD_INT 6
93519: EQUAL
93520: IFFALSE 93530
// sArmoury := true ;
93522: LD_ADDR_EXP 106
93526: PUSH
93527: LD_INT 1
93529: ST_TO_ADDR
// if p3 = 7 then
93530: LD_VAR 0 3
93534: PUSH
93535: LD_INT 7
93537: EQUAL
93538: IFFALSE 93548
// sRadar := true ;
93540: LD_ADDR_EXP 107
93544: PUSH
93545: LD_INT 1
93547: ST_TO_ADDR
// if p3 = 8 then
93548: LD_VAR 0 3
93552: PUSH
93553: LD_INT 8
93555: EQUAL
93556: IFFALSE 93566
// sBunker := true ;
93558: LD_ADDR_EXP 108
93562: PUSH
93563: LD_INT 1
93565: ST_TO_ADDR
// if p3 = 9 then
93566: LD_VAR 0 3
93570: PUSH
93571: LD_INT 9
93573: EQUAL
93574: IFFALSE 93584
// sHack := true ;
93576: LD_ADDR_EXP 109
93580: PUSH
93581: LD_INT 1
93583: ST_TO_ADDR
// if p3 = 10 then
93584: LD_VAR 0 3
93588: PUSH
93589: LD_INT 10
93591: EQUAL
93592: IFFALSE 93602
// sFire := true ;
93594: LD_ADDR_EXP 110
93598: PUSH
93599: LD_INT 1
93601: ST_TO_ADDR
// if p3 = 11 then
93602: LD_VAR 0 3
93606: PUSH
93607: LD_INT 11
93609: EQUAL
93610: IFFALSE 93620
// sRefresh := true ;
93612: LD_ADDR_EXP 111
93616: PUSH
93617: LD_INT 1
93619: ST_TO_ADDR
// if p3 = 12 then
93620: LD_VAR 0 3
93624: PUSH
93625: LD_INT 12
93627: EQUAL
93628: IFFALSE 93638
// sExp := true ;
93630: LD_ADDR_EXP 112
93634: PUSH
93635: LD_INT 1
93637: ST_TO_ADDR
// if p3 = 13 then
93638: LD_VAR 0 3
93642: PUSH
93643: LD_INT 13
93645: EQUAL
93646: IFFALSE 93656
// sDepot := true ;
93648: LD_ADDR_EXP 113
93652: PUSH
93653: LD_INT 1
93655: ST_TO_ADDR
// if p3 = 14 then
93656: LD_VAR 0 3
93660: PUSH
93661: LD_INT 14
93663: EQUAL
93664: IFFALSE 93674
// sFlag := true ;
93666: LD_ADDR_EXP 114
93670: PUSH
93671: LD_INT 1
93673: ST_TO_ADDR
// if p3 = 15 then
93674: LD_VAR 0 3
93678: PUSH
93679: LD_INT 15
93681: EQUAL
93682: IFFALSE 93692
// sKamikadze := true ;
93684: LD_ADDR_EXP 122
93688: PUSH
93689: LD_INT 1
93691: ST_TO_ADDR
// if p3 = 16 then
93692: LD_VAR 0 3
93696: PUSH
93697: LD_INT 16
93699: EQUAL
93700: IFFALSE 93710
// sTroll := true ;
93702: LD_ADDR_EXP 123
93706: PUSH
93707: LD_INT 1
93709: ST_TO_ADDR
// if p3 = 17 then
93710: LD_VAR 0 3
93714: PUSH
93715: LD_INT 17
93717: EQUAL
93718: IFFALSE 93728
// sSlow := true ;
93720: LD_ADDR_EXP 124
93724: PUSH
93725: LD_INT 1
93727: ST_TO_ADDR
// if p3 = 18 then
93728: LD_VAR 0 3
93732: PUSH
93733: LD_INT 18
93735: EQUAL
93736: IFFALSE 93746
// sLack := true ;
93738: LD_ADDR_EXP 125
93742: PUSH
93743: LD_INT 1
93745: ST_TO_ADDR
// if p3 = 19 then
93746: LD_VAR 0 3
93750: PUSH
93751: LD_INT 19
93753: EQUAL
93754: IFFALSE 93764
// sTank := true ;
93756: LD_ADDR_EXP 127
93760: PUSH
93761: LD_INT 1
93763: ST_TO_ADDR
// if p3 = 20 then
93764: LD_VAR 0 3
93768: PUSH
93769: LD_INT 20
93771: EQUAL
93772: IFFALSE 93782
// sRemote := true ;
93774: LD_ADDR_EXP 128
93778: PUSH
93779: LD_INT 1
93781: ST_TO_ADDR
// if p3 = 21 then
93782: LD_VAR 0 3
93786: PUSH
93787: LD_INT 21
93789: EQUAL
93790: IFFALSE 93800
// sPowell := true ;
93792: LD_ADDR_EXP 129
93796: PUSH
93797: LD_INT 1
93799: ST_TO_ADDR
// if p3 = 22 then
93800: LD_VAR 0 3
93804: PUSH
93805: LD_INT 22
93807: EQUAL
93808: IFFALSE 93818
// sTeleport := true ;
93810: LD_ADDR_EXP 132
93814: PUSH
93815: LD_INT 1
93817: ST_TO_ADDR
// if p3 = 23 then
93818: LD_VAR 0 3
93822: PUSH
93823: LD_INT 23
93825: EQUAL
93826: IFFALSE 93836
// sOilTower := true ;
93828: LD_ADDR_EXP 134
93832: PUSH
93833: LD_INT 1
93835: ST_TO_ADDR
// if p3 = 24 then
93836: LD_VAR 0 3
93840: PUSH
93841: LD_INT 24
93843: EQUAL
93844: IFFALSE 93854
// sShovel := true ;
93846: LD_ADDR_EXP 135
93850: PUSH
93851: LD_INT 1
93853: ST_TO_ADDR
// if p3 = 25 then
93854: LD_VAR 0 3
93858: PUSH
93859: LD_INT 25
93861: EQUAL
93862: IFFALSE 93872
// sSheik := true ;
93864: LD_ADDR_EXP 136
93868: PUSH
93869: LD_INT 1
93871: ST_TO_ADDR
// if p3 = 26 then
93872: LD_VAR 0 3
93876: PUSH
93877: LD_INT 26
93879: EQUAL
93880: IFFALSE 93890
// sEarthquake := true ;
93882: LD_ADDR_EXP 138
93886: PUSH
93887: LD_INT 1
93889: ST_TO_ADDR
// if p3 = 27 then
93890: LD_VAR 0 3
93894: PUSH
93895: LD_INT 27
93897: EQUAL
93898: IFFALSE 93908
// sAI := true ;
93900: LD_ADDR_EXP 139
93904: PUSH
93905: LD_INT 1
93907: ST_TO_ADDR
// if p3 = 28 then
93908: LD_VAR 0 3
93912: PUSH
93913: LD_INT 28
93915: EQUAL
93916: IFFALSE 93926
// sCargo := true ;
93918: LD_ADDR_EXP 142
93922: PUSH
93923: LD_INT 1
93925: ST_TO_ADDR
// if p3 = 29 then
93926: LD_VAR 0 3
93930: PUSH
93931: LD_INT 29
93933: EQUAL
93934: IFFALSE 93944
// sDLaser := true ;
93936: LD_ADDR_EXP 143
93940: PUSH
93941: LD_INT 1
93943: ST_TO_ADDR
// if p3 = 30 then
93944: LD_VAR 0 3
93948: PUSH
93949: LD_INT 30
93951: EQUAL
93952: IFFALSE 93962
// sExchange := true ;
93954: LD_ADDR_EXP 144
93958: PUSH
93959: LD_INT 1
93961: ST_TO_ADDR
// if p3 = 31 then
93962: LD_VAR 0 3
93966: PUSH
93967: LD_INT 31
93969: EQUAL
93970: IFFALSE 93980
// sFac := true ;
93972: LD_ADDR_EXP 145
93976: PUSH
93977: LD_INT 1
93979: ST_TO_ADDR
// if p3 = 32 then
93980: LD_VAR 0 3
93984: PUSH
93985: LD_INT 32
93987: EQUAL
93988: IFFALSE 93998
// sPower := true ;
93990: LD_ADDR_EXP 146
93994: PUSH
93995: LD_INT 1
93997: ST_TO_ADDR
// if p3 = 33 then
93998: LD_VAR 0 3
94002: PUSH
94003: LD_INT 33
94005: EQUAL
94006: IFFALSE 94016
// sRandom := true ;
94008: LD_ADDR_EXP 147
94012: PUSH
94013: LD_INT 1
94015: ST_TO_ADDR
// if p3 = 34 then
94016: LD_VAR 0 3
94020: PUSH
94021: LD_INT 34
94023: EQUAL
94024: IFFALSE 94034
// sShield := true ;
94026: LD_ADDR_EXP 148
94030: PUSH
94031: LD_INT 1
94033: ST_TO_ADDR
// if p3 = 35 then
94034: LD_VAR 0 3
94038: PUSH
94039: LD_INT 35
94041: EQUAL
94042: IFFALSE 94052
// sTime := true ;
94044: LD_ADDR_EXP 149
94048: PUSH
94049: LD_INT 1
94051: ST_TO_ADDR
// if p3 = 36 then
94052: LD_VAR 0 3
94056: PUSH
94057: LD_INT 36
94059: EQUAL
94060: IFFALSE 94070
// sTools := true ;
94062: LD_ADDR_EXP 150
94066: PUSH
94067: LD_INT 1
94069: ST_TO_ADDR
// if p3 = 101 then
94070: LD_VAR 0 3
94074: PUSH
94075: LD_INT 101
94077: EQUAL
94078: IFFALSE 94088
// sSold := true ;
94080: LD_ADDR_EXP 115
94084: PUSH
94085: LD_INT 1
94087: ST_TO_ADDR
// if p3 = 102 then
94088: LD_VAR 0 3
94092: PUSH
94093: LD_INT 102
94095: EQUAL
94096: IFFALSE 94106
// sDiff := true ;
94098: LD_ADDR_EXP 116
94102: PUSH
94103: LD_INT 1
94105: ST_TO_ADDR
// if p3 = 103 then
94106: LD_VAR 0 3
94110: PUSH
94111: LD_INT 103
94113: EQUAL
94114: IFFALSE 94124
// sFog := true ;
94116: LD_ADDR_EXP 119
94120: PUSH
94121: LD_INT 1
94123: ST_TO_ADDR
// if p3 = 104 then
94124: LD_VAR 0 3
94128: PUSH
94129: LD_INT 104
94131: EQUAL
94132: IFFALSE 94142
// sReset := true ;
94134: LD_ADDR_EXP 120
94138: PUSH
94139: LD_INT 1
94141: ST_TO_ADDR
// if p3 = 105 then
94142: LD_VAR 0 3
94146: PUSH
94147: LD_INT 105
94149: EQUAL
94150: IFFALSE 94160
// sSun := true ;
94152: LD_ADDR_EXP 121
94156: PUSH
94157: LD_INT 1
94159: ST_TO_ADDR
// if p3 = 106 then
94160: LD_VAR 0 3
94164: PUSH
94165: LD_INT 106
94167: EQUAL
94168: IFFALSE 94178
// sTiger := true ;
94170: LD_ADDR_EXP 117
94174: PUSH
94175: LD_INT 1
94177: ST_TO_ADDR
// if p3 = 107 then
94178: LD_VAR 0 3
94182: PUSH
94183: LD_INT 107
94185: EQUAL
94186: IFFALSE 94196
// sBomb := true ;
94188: LD_ADDR_EXP 118
94192: PUSH
94193: LD_INT 1
94195: ST_TO_ADDR
// if p3 = 108 then
94196: LD_VAR 0 3
94200: PUSH
94201: LD_INT 108
94203: EQUAL
94204: IFFALSE 94214
// sWound := true ;
94206: LD_ADDR_EXP 126
94210: PUSH
94211: LD_INT 1
94213: ST_TO_ADDR
// if p3 = 109 then
94214: LD_VAR 0 3
94218: PUSH
94219: LD_INT 109
94221: EQUAL
94222: IFFALSE 94232
// sBetray := true ;
94224: LD_ADDR_EXP 130
94228: PUSH
94229: LD_INT 1
94231: ST_TO_ADDR
// if p3 = 110 then
94232: LD_VAR 0 3
94236: PUSH
94237: LD_INT 110
94239: EQUAL
94240: IFFALSE 94250
// sContamin := true ;
94242: LD_ADDR_EXP 131
94246: PUSH
94247: LD_INT 1
94249: ST_TO_ADDR
// if p3 = 111 then
94250: LD_VAR 0 3
94254: PUSH
94255: LD_INT 111
94257: EQUAL
94258: IFFALSE 94268
// sOil := true ;
94260: LD_ADDR_EXP 133
94264: PUSH
94265: LD_INT 1
94267: ST_TO_ADDR
// if p3 = 112 then
94268: LD_VAR 0 3
94272: PUSH
94273: LD_INT 112
94275: EQUAL
94276: IFFALSE 94286
// sStu := true ;
94278: LD_ADDR_EXP 137
94282: PUSH
94283: LD_INT 1
94285: ST_TO_ADDR
// if p3 = 113 then
94286: LD_VAR 0 3
94290: PUSH
94291: LD_INT 113
94293: EQUAL
94294: IFFALSE 94304
// sBazooka := true ;
94296: LD_ADDR_EXP 140
94300: PUSH
94301: LD_INT 1
94303: ST_TO_ADDR
// if p3 = 114 then
94304: LD_VAR 0 3
94308: PUSH
94309: LD_INT 114
94311: EQUAL
94312: IFFALSE 94322
// sMortar := true ;
94314: LD_ADDR_EXP 141
94318: PUSH
94319: LD_INT 1
94321: ST_TO_ADDR
// if p3 = 115 then
94322: LD_VAR 0 3
94326: PUSH
94327: LD_INT 115
94329: EQUAL
94330: IFFALSE 94340
// sRanger := true ;
94332: LD_ADDR_EXP 151
94336: PUSH
94337: LD_INT 1
94339: ST_TO_ADDR
// if p3 = 116 then
94340: LD_VAR 0 3
94344: PUSH
94345: LD_INT 116
94347: EQUAL
94348: IFFALSE 94358
// sComputer := true ;
94350: LD_ADDR_EXP 152
94354: PUSH
94355: LD_INT 1
94357: ST_TO_ADDR
// if p3 = 117 then
94358: LD_VAR 0 3
94362: PUSH
94363: LD_INT 117
94365: EQUAL
94366: IFFALSE 94376
// s30 := true ;
94368: LD_ADDR_EXP 153
94372: PUSH
94373: LD_INT 1
94375: ST_TO_ADDR
// if p3 = 118 then
94376: LD_VAR 0 3
94380: PUSH
94381: LD_INT 118
94383: EQUAL
94384: IFFALSE 94394
// s60 := true ;
94386: LD_ADDR_EXP 154
94390: PUSH
94391: LD_INT 1
94393: ST_TO_ADDR
// end ; if p2 = 101 then
94394: LD_VAR 0 2
94398: PUSH
94399: LD_INT 101
94401: EQUAL
94402: IFFALSE 94530
// begin case p3 of 1 :
94404: LD_VAR 0 3
94408: PUSH
94409: LD_INT 1
94411: DOUBLE
94412: EQUAL
94413: IFTRUE 94417
94415: GO 94424
94417: POP
// hHackUnlimitedResources ; 2 :
94418: CALL 106126 0 0
94422: GO 94530
94424: LD_INT 2
94426: DOUBLE
94427: EQUAL
94428: IFTRUE 94432
94430: GO 94439
94432: POP
// hHackSetLevel10 ; 3 :
94433: CALL 106259 0 0
94437: GO 94530
94439: LD_INT 3
94441: DOUBLE
94442: EQUAL
94443: IFTRUE 94447
94445: GO 94454
94447: POP
// hHackSetLevel10YourUnits ; 4 :
94448: CALL 106344 0 0
94452: GO 94530
94454: LD_INT 4
94456: DOUBLE
94457: EQUAL
94458: IFTRUE 94462
94460: GO 94469
94462: POP
// hHackInvincible ; 5 :
94463: CALL 106792 0 0
94467: GO 94530
94469: LD_INT 5
94471: DOUBLE
94472: EQUAL
94473: IFTRUE 94477
94475: GO 94484
94477: POP
// hHackInvisible ; 6 :
94478: CALL 106903 0 0
94482: GO 94530
94484: LD_INT 6
94486: DOUBLE
94487: EQUAL
94488: IFTRUE 94492
94490: GO 94499
94492: POP
// hHackChangeYourSide ; 7 :
94493: CALL 106960 0 0
94497: GO 94530
94499: LD_INT 7
94501: DOUBLE
94502: EQUAL
94503: IFTRUE 94507
94505: GO 94514
94507: POP
// hHackChangeUnitSide ; 8 :
94508: CALL 107002 0 0
94512: GO 94530
94514: LD_INT 8
94516: DOUBLE
94517: EQUAL
94518: IFTRUE 94522
94520: GO 94529
94522: POP
// hHackFog ; end ;
94523: CALL 107103 0 0
94527: GO 94530
94529: POP
// end ; end ;
94530: LD_VAR 0 7
94534: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
94535: GO 94537
94537: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
94538: LD_STRING initStreamRollete();
94540: PPUSH
94541: CALL_OW 559
// InitStreamMode ;
94545: CALL 94554 0 0
// DefineStreamItems ( ) ;
94549: CALL 95018 0 0
// end ;
94553: END
// function InitStreamMode ; begin
94554: LD_INT 0
94556: PPUSH
// streamModeActive := false ;
94557: LD_ADDR_EXP 98
94561: PUSH
94562: LD_INT 0
94564: ST_TO_ADDR
// normalCounter := 36 ;
94565: LD_ADDR_EXP 99
94569: PUSH
94570: LD_INT 36
94572: ST_TO_ADDR
// hardcoreCounter := 16 ;
94573: LD_ADDR_EXP 100
94577: PUSH
94578: LD_INT 16
94580: ST_TO_ADDR
// sRocket := false ;
94581: LD_ADDR_EXP 103
94585: PUSH
94586: LD_INT 0
94588: ST_TO_ADDR
// sSpeed := false ;
94589: LD_ADDR_EXP 102
94593: PUSH
94594: LD_INT 0
94596: ST_TO_ADDR
// sEngine := false ;
94597: LD_ADDR_EXP 104
94601: PUSH
94602: LD_INT 0
94604: ST_TO_ADDR
// sSpec := false ;
94605: LD_ADDR_EXP 101
94609: PUSH
94610: LD_INT 0
94612: ST_TO_ADDR
// sLevel := false ;
94613: LD_ADDR_EXP 105
94617: PUSH
94618: LD_INT 0
94620: ST_TO_ADDR
// sArmoury := false ;
94621: LD_ADDR_EXP 106
94625: PUSH
94626: LD_INT 0
94628: ST_TO_ADDR
// sRadar := false ;
94629: LD_ADDR_EXP 107
94633: PUSH
94634: LD_INT 0
94636: ST_TO_ADDR
// sBunker := false ;
94637: LD_ADDR_EXP 108
94641: PUSH
94642: LD_INT 0
94644: ST_TO_ADDR
// sHack := false ;
94645: LD_ADDR_EXP 109
94649: PUSH
94650: LD_INT 0
94652: ST_TO_ADDR
// sFire := false ;
94653: LD_ADDR_EXP 110
94657: PUSH
94658: LD_INT 0
94660: ST_TO_ADDR
// sRefresh := false ;
94661: LD_ADDR_EXP 111
94665: PUSH
94666: LD_INT 0
94668: ST_TO_ADDR
// sExp := false ;
94669: LD_ADDR_EXP 112
94673: PUSH
94674: LD_INT 0
94676: ST_TO_ADDR
// sDepot := false ;
94677: LD_ADDR_EXP 113
94681: PUSH
94682: LD_INT 0
94684: ST_TO_ADDR
// sFlag := false ;
94685: LD_ADDR_EXP 114
94689: PUSH
94690: LD_INT 0
94692: ST_TO_ADDR
// sKamikadze := false ;
94693: LD_ADDR_EXP 122
94697: PUSH
94698: LD_INT 0
94700: ST_TO_ADDR
// sTroll := false ;
94701: LD_ADDR_EXP 123
94705: PUSH
94706: LD_INT 0
94708: ST_TO_ADDR
// sSlow := false ;
94709: LD_ADDR_EXP 124
94713: PUSH
94714: LD_INT 0
94716: ST_TO_ADDR
// sLack := false ;
94717: LD_ADDR_EXP 125
94721: PUSH
94722: LD_INT 0
94724: ST_TO_ADDR
// sTank := false ;
94725: LD_ADDR_EXP 127
94729: PUSH
94730: LD_INT 0
94732: ST_TO_ADDR
// sRemote := false ;
94733: LD_ADDR_EXP 128
94737: PUSH
94738: LD_INT 0
94740: ST_TO_ADDR
// sPowell := false ;
94741: LD_ADDR_EXP 129
94745: PUSH
94746: LD_INT 0
94748: ST_TO_ADDR
// sTeleport := false ;
94749: LD_ADDR_EXP 132
94753: PUSH
94754: LD_INT 0
94756: ST_TO_ADDR
// sOilTower := false ;
94757: LD_ADDR_EXP 134
94761: PUSH
94762: LD_INT 0
94764: ST_TO_ADDR
// sShovel := false ;
94765: LD_ADDR_EXP 135
94769: PUSH
94770: LD_INT 0
94772: ST_TO_ADDR
// sSheik := false ;
94773: LD_ADDR_EXP 136
94777: PUSH
94778: LD_INT 0
94780: ST_TO_ADDR
// sEarthquake := false ;
94781: LD_ADDR_EXP 138
94785: PUSH
94786: LD_INT 0
94788: ST_TO_ADDR
// sAI := false ;
94789: LD_ADDR_EXP 139
94793: PUSH
94794: LD_INT 0
94796: ST_TO_ADDR
// sCargo := false ;
94797: LD_ADDR_EXP 142
94801: PUSH
94802: LD_INT 0
94804: ST_TO_ADDR
// sDLaser := false ;
94805: LD_ADDR_EXP 143
94809: PUSH
94810: LD_INT 0
94812: ST_TO_ADDR
// sExchange := false ;
94813: LD_ADDR_EXP 144
94817: PUSH
94818: LD_INT 0
94820: ST_TO_ADDR
// sFac := false ;
94821: LD_ADDR_EXP 145
94825: PUSH
94826: LD_INT 0
94828: ST_TO_ADDR
// sPower := false ;
94829: LD_ADDR_EXP 146
94833: PUSH
94834: LD_INT 0
94836: ST_TO_ADDR
// sRandom := false ;
94837: LD_ADDR_EXP 147
94841: PUSH
94842: LD_INT 0
94844: ST_TO_ADDR
// sShield := false ;
94845: LD_ADDR_EXP 148
94849: PUSH
94850: LD_INT 0
94852: ST_TO_ADDR
// sTime := false ;
94853: LD_ADDR_EXP 149
94857: PUSH
94858: LD_INT 0
94860: ST_TO_ADDR
// sTools := false ;
94861: LD_ADDR_EXP 150
94865: PUSH
94866: LD_INT 0
94868: ST_TO_ADDR
// sSold := false ;
94869: LD_ADDR_EXP 115
94873: PUSH
94874: LD_INT 0
94876: ST_TO_ADDR
// sDiff := false ;
94877: LD_ADDR_EXP 116
94881: PUSH
94882: LD_INT 0
94884: ST_TO_ADDR
// sFog := false ;
94885: LD_ADDR_EXP 119
94889: PUSH
94890: LD_INT 0
94892: ST_TO_ADDR
// sReset := false ;
94893: LD_ADDR_EXP 120
94897: PUSH
94898: LD_INT 0
94900: ST_TO_ADDR
// sSun := false ;
94901: LD_ADDR_EXP 121
94905: PUSH
94906: LD_INT 0
94908: ST_TO_ADDR
// sTiger := false ;
94909: LD_ADDR_EXP 117
94913: PUSH
94914: LD_INT 0
94916: ST_TO_ADDR
// sBomb := false ;
94917: LD_ADDR_EXP 118
94921: PUSH
94922: LD_INT 0
94924: ST_TO_ADDR
// sWound := false ;
94925: LD_ADDR_EXP 126
94929: PUSH
94930: LD_INT 0
94932: ST_TO_ADDR
// sBetray := false ;
94933: LD_ADDR_EXP 130
94937: PUSH
94938: LD_INT 0
94940: ST_TO_ADDR
// sContamin := false ;
94941: LD_ADDR_EXP 131
94945: PUSH
94946: LD_INT 0
94948: ST_TO_ADDR
// sOil := false ;
94949: LD_ADDR_EXP 133
94953: PUSH
94954: LD_INT 0
94956: ST_TO_ADDR
// sStu := false ;
94957: LD_ADDR_EXP 137
94961: PUSH
94962: LD_INT 0
94964: ST_TO_ADDR
// sBazooka := false ;
94965: LD_ADDR_EXP 140
94969: PUSH
94970: LD_INT 0
94972: ST_TO_ADDR
// sMortar := false ;
94973: LD_ADDR_EXP 141
94977: PUSH
94978: LD_INT 0
94980: ST_TO_ADDR
// sRanger := false ;
94981: LD_ADDR_EXP 151
94985: PUSH
94986: LD_INT 0
94988: ST_TO_ADDR
// sComputer := false ;
94989: LD_ADDR_EXP 152
94993: PUSH
94994: LD_INT 0
94996: ST_TO_ADDR
// s30 := false ;
94997: LD_ADDR_EXP 153
95001: PUSH
95002: LD_INT 0
95004: ST_TO_ADDR
// s60 := false ;
95005: LD_ADDR_EXP 154
95009: PUSH
95010: LD_INT 0
95012: ST_TO_ADDR
// end ;
95013: LD_VAR 0 1
95017: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
95018: LD_INT 0
95020: PPUSH
95021: PPUSH
95022: PPUSH
95023: PPUSH
95024: PPUSH
// result := [ ] ;
95025: LD_ADDR_VAR 0 1
95029: PUSH
95030: EMPTY
95031: ST_TO_ADDR
// if campaign_id = 1 then
95032: LD_OWVAR 69
95036: PUSH
95037: LD_INT 1
95039: EQUAL
95040: IFFALSE 98206
// begin case mission_number of 1 :
95042: LD_OWVAR 70
95046: PUSH
95047: LD_INT 1
95049: DOUBLE
95050: EQUAL
95051: IFTRUE 95055
95053: GO 95131
95055: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
95056: LD_ADDR_VAR 0 1
95060: PUSH
95061: LD_INT 2
95063: PUSH
95064: LD_INT 4
95066: PUSH
95067: LD_INT 11
95069: PUSH
95070: LD_INT 12
95072: PUSH
95073: LD_INT 15
95075: PUSH
95076: LD_INT 16
95078: PUSH
95079: LD_INT 22
95081: PUSH
95082: LD_INT 23
95084: PUSH
95085: LD_INT 26
95087: PUSH
95088: EMPTY
95089: LIST
95090: LIST
95091: LIST
95092: LIST
95093: LIST
95094: LIST
95095: LIST
95096: LIST
95097: LIST
95098: PUSH
95099: LD_INT 101
95101: PUSH
95102: LD_INT 102
95104: PUSH
95105: LD_INT 106
95107: PUSH
95108: LD_INT 116
95110: PUSH
95111: LD_INT 117
95113: PUSH
95114: LD_INT 118
95116: PUSH
95117: EMPTY
95118: LIST
95119: LIST
95120: LIST
95121: LIST
95122: LIST
95123: LIST
95124: PUSH
95125: EMPTY
95126: LIST
95127: LIST
95128: ST_TO_ADDR
95129: GO 98204
95131: LD_INT 2
95133: DOUBLE
95134: EQUAL
95135: IFTRUE 95139
95137: GO 95223
95139: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
95140: LD_ADDR_VAR 0 1
95144: PUSH
95145: LD_INT 2
95147: PUSH
95148: LD_INT 4
95150: PUSH
95151: LD_INT 11
95153: PUSH
95154: LD_INT 12
95156: PUSH
95157: LD_INT 15
95159: PUSH
95160: LD_INT 16
95162: PUSH
95163: LD_INT 22
95165: PUSH
95166: LD_INT 23
95168: PUSH
95169: LD_INT 26
95171: PUSH
95172: EMPTY
95173: LIST
95174: LIST
95175: LIST
95176: LIST
95177: LIST
95178: LIST
95179: LIST
95180: LIST
95181: LIST
95182: PUSH
95183: LD_INT 101
95185: PUSH
95186: LD_INT 102
95188: PUSH
95189: LD_INT 105
95191: PUSH
95192: LD_INT 106
95194: PUSH
95195: LD_INT 108
95197: PUSH
95198: LD_INT 116
95200: PUSH
95201: LD_INT 117
95203: PUSH
95204: LD_INT 118
95206: PUSH
95207: EMPTY
95208: LIST
95209: LIST
95210: LIST
95211: LIST
95212: LIST
95213: LIST
95214: LIST
95215: LIST
95216: PUSH
95217: EMPTY
95218: LIST
95219: LIST
95220: ST_TO_ADDR
95221: GO 98204
95223: LD_INT 3
95225: DOUBLE
95226: EQUAL
95227: IFTRUE 95231
95229: GO 95319
95231: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
95232: LD_ADDR_VAR 0 1
95236: PUSH
95237: LD_INT 2
95239: PUSH
95240: LD_INT 4
95242: PUSH
95243: LD_INT 5
95245: PUSH
95246: LD_INT 11
95248: PUSH
95249: LD_INT 12
95251: PUSH
95252: LD_INT 15
95254: PUSH
95255: LD_INT 16
95257: PUSH
95258: LD_INT 22
95260: PUSH
95261: LD_INT 26
95263: PUSH
95264: LD_INT 36
95266: PUSH
95267: EMPTY
95268: LIST
95269: LIST
95270: LIST
95271: LIST
95272: LIST
95273: LIST
95274: LIST
95275: LIST
95276: LIST
95277: LIST
95278: PUSH
95279: LD_INT 101
95281: PUSH
95282: LD_INT 102
95284: PUSH
95285: LD_INT 105
95287: PUSH
95288: LD_INT 106
95290: PUSH
95291: LD_INT 108
95293: PUSH
95294: LD_INT 116
95296: PUSH
95297: LD_INT 117
95299: PUSH
95300: LD_INT 118
95302: PUSH
95303: EMPTY
95304: LIST
95305: LIST
95306: LIST
95307: LIST
95308: LIST
95309: LIST
95310: LIST
95311: LIST
95312: PUSH
95313: EMPTY
95314: LIST
95315: LIST
95316: ST_TO_ADDR
95317: GO 98204
95319: LD_INT 4
95321: DOUBLE
95322: EQUAL
95323: IFTRUE 95327
95325: GO 95423
95327: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
95328: LD_ADDR_VAR 0 1
95332: PUSH
95333: LD_INT 2
95335: PUSH
95336: LD_INT 4
95338: PUSH
95339: LD_INT 5
95341: PUSH
95342: LD_INT 8
95344: PUSH
95345: LD_INT 11
95347: PUSH
95348: LD_INT 12
95350: PUSH
95351: LD_INT 15
95353: PUSH
95354: LD_INT 16
95356: PUSH
95357: LD_INT 22
95359: PUSH
95360: LD_INT 23
95362: PUSH
95363: LD_INT 26
95365: PUSH
95366: LD_INT 36
95368: PUSH
95369: EMPTY
95370: LIST
95371: LIST
95372: LIST
95373: LIST
95374: LIST
95375: LIST
95376: LIST
95377: LIST
95378: LIST
95379: LIST
95380: LIST
95381: LIST
95382: PUSH
95383: LD_INT 101
95385: PUSH
95386: LD_INT 102
95388: PUSH
95389: LD_INT 105
95391: PUSH
95392: LD_INT 106
95394: PUSH
95395: LD_INT 108
95397: PUSH
95398: LD_INT 116
95400: PUSH
95401: LD_INT 117
95403: PUSH
95404: LD_INT 118
95406: PUSH
95407: EMPTY
95408: LIST
95409: LIST
95410: LIST
95411: LIST
95412: LIST
95413: LIST
95414: LIST
95415: LIST
95416: PUSH
95417: EMPTY
95418: LIST
95419: LIST
95420: ST_TO_ADDR
95421: GO 98204
95423: LD_INT 5
95425: DOUBLE
95426: EQUAL
95427: IFTRUE 95431
95429: GO 95543
95431: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
95432: LD_ADDR_VAR 0 1
95436: PUSH
95437: LD_INT 2
95439: PUSH
95440: LD_INT 4
95442: PUSH
95443: LD_INT 5
95445: PUSH
95446: LD_INT 6
95448: PUSH
95449: LD_INT 8
95451: PUSH
95452: LD_INT 11
95454: PUSH
95455: LD_INT 12
95457: PUSH
95458: LD_INT 15
95460: PUSH
95461: LD_INT 16
95463: PUSH
95464: LD_INT 22
95466: PUSH
95467: LD_INT 23
95469: PUSH
95470: LD_INT 25
95472: PUSH
95473: LD_INT 26
95475: PUSH
95476: LD_INT 36
95478: PUSH
95479: EMPTY
95480: LIST
95481: LIST
95482: LIST
95483: LIST
95484: LIST
95485: LIST
95486: LIST
95487: LIST
95488: LIST
95489: LIST
95490: LIST
95491: LIST
95492: LIST
95493: LIST
95494: PUSH
95495: LD_INT 101
95497: PUSH
95498: LD_INT 102
95500: PUSH
95501: LD_INT 105
95503: PUSH
95504: LD_INT 106
95506: PUSH
95507: LD_INT 108
95509: PUSH
95510: LD_INT 109
95512: PUSH
95513: LD_INT 112
95515: PUSH
95516: LD_INT 116
95518: PUSH
95519: LD_INT 117
95521: PUSH
95522: LD_INT 118
95524: PUSH
95525: EMPTY
95526: LIST
95527: LIST
95528: LIST
95529: LIST
95530: LIST
95531: LIST
95532: LIST
95533: LIST
95534: LIST
95535: LIST
95536: PUSH
95537: EMPTY
95538: LIST
95539: LIST
95540: ST_TO_ADDR
95541: GO 98204
95543: LD_INT 6
95545: DOUBLE
95546: EQUAL
95547: IFTRUE 95551
95549: GO 95683
95551: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
95552: LD_ADDR_VAR 0 1
95556: PUSH
95557: LD_INT 2
95559: PUSH
95560: LD_INT 4
95562: PUSH
95563: LD_INT 5
95565: PUSH
95566: LD_INT 6
95568: PUSH
95569: LD_INT 8
95571: PUSH
95572: LD_INT 11
95574: PUSH
95575: LD_INT 12
95577: PUSH
95578: LD_INT 15
95580: PUSH
95581: LD_INT 16
95583: PUSH
95584: LD_INT 20
95586: PUSH
95587: LD_INT 21
95589: PUSH
95590: LD_INT 22
95592: PUSH
95593: LD_INT 23
95595: PUSH
95596: LD_INT 25
95598: PUSH
95599: LD_INT 26
95601: PUSH
95602: LD_INT 30
95604: PUSH
95605: LD_INT 31
95607: PUSH
95608: LD_INT 32
95610: PUSH
95611: LD_INT 36
95613: PUSH
95614: EMPTY
95615: LIST
95616: LIST
95617: LIST
95618: LIST
95619: LIST
95620: LIST
95621: LIST
95622: LIST
95623: LIST
95624: LIST
95625: LIST
95626: LIST
95627: LIST
95628: LIST
95629: LIST
95630: LIST
95631: LIST
95632: LIST
95633: LIST
95634: PUSH
95635: LD_INT 101
95637: PUSH
95638: LD_INT 102
95640: PUSH
95641: LD_INT 105
95643: PUSH
95644: LD_INT 106
95646: PUSH
95647: LD_INT 108
95649: PUSH
95650: LD_INT 109
95652: PUSH
95653: LD_INT 112
95655: PUSH
95656: LD_INT 116
95658: PUSH
95659: LD_INT 117
95661: PUSH
95662: LD_INT 118
95664: PUSH
95665: EMPTY
95666: LIST
95667: LIST
95668: LIST
95669: LIST
95670: LIST
95671: LIST
95672: LIST
95673: LIST
95674: LIST
95675: LIST
95676: PUSH
95677: EMPTY
95678: LIST
95679: LIST
95680: ST_TO_ADDR
95681: GO 98204
95683: LD_INT 7
95685: DOUBLE
95686: EQUAL
95687: IFTRUE 95691
95689: GO 95803
95691: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
95692: LD_ADDR_VAR 0 1
95696: PUSH
95697: LD_INT 2
95699: PUSH
95700: LD_INT 4
95702: PUSH
95703: LD_INT 5
95705: PUSH
95706: LD_INT 7
95708: PUSH
95709: LD_INT 11
95711: PUSH
95712: LD_INT 12
95714: PUSH
95715: LD_INT 15
95717: PUSH
95718: LD_INT 16
95720: PUSH
95721: LD_INT 20
95723: PUSH
95724: LD_INT 21
95726: PUSH
95727: LD_INT 22
95729: PUSH
95730: LD_INT 23
95732: PUSH
95733: LD_INT 25
95735: PUSH
95736: LD_INT 26
95738: PUSH
95739: EMPTY
95740: LIST
95741: LIST
95742: LIST
95743: LIST
95744: LIST
95745: LIST
95746: LIST
95747: LIST
95748: LIST
95749: LIST
95750: LIST
95751: LIST
95752: LIST
95753: LIST
95754: PUSH
95755: LD_INT 101
95757: PUSH
95758: LD_INT 102
95760: PUSH
95761: LD_INT 103
95763: PUSH
95764: LD_INT 105
95766: PUSH
95767: LD_INT 106
95769: PUSH
95770: LD_INT 108
95772: PUSH
95773: LD_INT 112
95775: PUSH
95776: LD_INT 116
95778: PUSH
95779: LD_INT 117
95781: PUSH
95782: LD_INT 118
95784: PUSH
95785: EMPTY
95786: LIST
95787: LIST
95788: LIST
95789: LIST
95790: LIST
95791: LIST
95792: LIST
95793: LIST
95794: LIST
95795: LIST
95796: PUSH
95797: EMPTY
95798: LIST
95799: LIST
95800: ST_TO_ADDR
95801: GO 98204
95803: LD_INT 8
95805: DOUBLE
95806: EQUAL
95807: IFTRUE 95811
95809: GO 95951
95811: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
95812: LD_ADDR_VAR 0 1
95816: PUSH
95817: LD_INT 2
95819: PUSH
95820: LD_INT 4
95822: PUSH
95823: LD_INT 5
95825: PUSH
95826: LD_INT 6
95828: PUSH
95829: LD_INT 7
95831: PUSH
95832: LD_INT 8
95834: PUSH
95835: LD_INT 11
95837: PUSH
95838: LD_INT 12
95840: PUSH
95841: LD_INT 15
95843: PUSH
95844: LD_INT 16
95846: PUSH
95847: LD_INT 20
95849: PUSH
95850: LD_INT 21
95852: PUSH
95853: LD_INT 22
95855: PUSH
95856: LD_INT 23
95858: PUSH
95859: LD_INT 25
95861: PUSH
95862: LD_INT 26
95864: PUSH
95865: LD_INT 30
95867: PUSH
95868: LD_INT 31
95870: PUSH
95871: LD_INT 32
95873: PUSH
95874: LD_INT 36
95876: PUSH
95877: EMPTY
95878: LIST
95879: LIST
95880: LIST
95881: LIST
95882: LIST
95883: LIST
95884: LIST
95885: LIST
95886: LIST
95887: LIST
95888: LIST
95889: LIST
95890: LIST
95891: LIST
95892: LIST
95893: LIST
95894: LIST
95895: LIST
95896: LIST
95897: LIST
95898: PUSH
95899: LD_INT 101
95901: PUSH
95902: LD_INT 102
95904: PUSH
95905: LD_INT 103
95907: PUSH
95908: LD_INT 105
95910: PUSH
95911: LD_INT 106
95913: PUSH
95914: LD_INT 108
95916: PUSH
95917: LD_INT 109
95919: PUSH
95920: LD_INT 112
95922: PUSH
95923: LD_INT 116
95925: PUSH
95926: LD_INT 117
95928: PUSH
95929: LD_INT 118
95931: PUSH
95932: EMPTY
95933: LIST
95934: LIST
95935: LIST
95936: LIST
95937: LIST
95938: LIST
95939: LIST
95940: LIST
95941: LIST
95942: LIST
95943: LIST
95944: PUSH
95945: EMPTY
95946: LIST
95947: LIST
95948: ST_TO_ADDR
95949: GO 98204
95951: LD_INT 9
95953: DOUBLE
95954: EQUAL
95955: IFTRUE 95959
95957: GO 96107
95959: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
95960: LD_ADDR_VAR 0 1
95964: PUSH
95965: LD_INT 2
95967: PUSH
95968: LD_INT 4
95970: PUSH
95971: LD_INT 5
95973: PUSH
95974: LD_INT 6
95976: PUSH
95977: LD_INT 7
95979: PUSH
95980: LD_INT 8
95982: PUSH
95983: LD_INT 11
95985: PUSH
95986: LD_INT 12
95988: PUSH
95989: LD_INT 15
95991: PUSH
95992: LD_INT 16
95994: PUSH
95995: LD_INT 20
95997: PUSH
95998: LD_INT 21
96000: PUSH
96001: LD_INT 22
96003: PUSH
96004: LD_INT 23
96006: PUSH
96007: LD_INT 25
96009: PUSH
96010: LD_INT 26
96012: PUSH
96013: LD_INT 28
96015: PUSH
96016: LD_INT 30
96018: PUSH
96019: LD_INT 31
96021: PUSH
96022: LD_INT 32
96024: PUSH
96025: LD_INT 36
96027: PUSH
96028: EMPTY
96029: LIST
96030: LIST
96031: LIST
96032: LIST
96033: LIST
96034: LIST
96035: LIST
96036: LIST
96037: LIST
96038: LIST
96039: LIST
96040: LIST
96041: LIST
96042: LIST
96043: LIST
96044: LIST
96045: LIST
96046: LIST
96047: LIST
96048: LIST
96049: LIST
96050: PUSH
96051: LD_INT 101
96053: PUSH
96054: LD_INT 102
96056: PUSH
96057: LD_INT 103
96059: PUSH
96060: LD_INT 105
96062: PUSH
96063: LD_INT 106
96065: PUSH
96066: LD_INT 108
96068: PUSH
96069: LD_INT 109
96071: PUSH
96072: LD_INT 112
96074: PUSH
96075: LD_INT 114
96077: PUSH
96078: LD_INT 116
96080: PUSH
96081: LD_INT 117
96083: PUSH
96084: LD_INT 118
96086: PUSH
96087: EMPTY
96088: LIST
96089: LIST
96090: LIST
96091: LIST
96092: LIST
96093: LIST
96094: LIST
96095: LIST
96096: LIST
96097: LIST
96098: LIST
96099: LIST
96100: PUSH
96101: EMPTY
96102: LIST
96103: LIST
96104: ST_TO_ADDR
96105: GO 98204
96107: LD_INT 10
96109: DOUBLE
96110: EQUAL
96111: IFTRUE 96115
96113: GO 96311
96115: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
96116: LD_ADDR_VAR 0 1
96120: PUSH
96121: LD_INT 2
96123: PUSH
96124: LD_INT 4
96126: PUSH
96127: LD_INT 5
96129: PUSH
96130: LD_INT 6
96132: PUSH
96133: LD_INT 7
96135: PUSH
96136: LD_INT 8
96138: PUSH
96139: LD_INT 9
96141: PUSH
96142: LD_INT 10
96144: PUSH
96145: LD_INT 11
96147: PUSH
96148: LD_INT 12
96150: PUSH
96151: LD_INT 13
96153: PUSH
96154: LD_INT 14
96156: PUSH
96157: LD_INT 15
96159: PUSH
96160: LD_INT 16
96162: PUSH
96163: LD_INT 17
96165: PUSH
96166: LD_INT 18
96168: PUSH
96169: LD_INT 19
96171: PUSH
96172: LD_INT 20
96174: PUSH
96175: LD_INT 21
96177: PUSH
96178: LD_INT 22
96180: PUSH
96181: LD_INT 23
96183: PUSH
96184: LD_INT 24
96186: PUSH
96187: LD_INT 25
96189: PUSH
96190: LD_INT 26
96192: PUSH
96193: LD_INT 28
96195: PUSH
96196: LD_INT 30
96198: PUSH
96199: LD_INT 31
96201: PUSH
96202: LD_INT 32
96204: PUSH
96205: LD_INT 36
96207: PUSH
96208: EMPTY
96209: LIST
96210: LIST
96211: LIST
96212: LIST
96213: LIST
96214: LIST
96215: LIST
96216: LIST
96217: LIST
96218: LIST
96219: LIST
96220: LIST
96221: LIST
96222: LIST
96223: LIST
96224: LIST
96225: LIST
96226: LIST
96227: LIST
96228: LIST
96229: LIST
96230: LIST
96231: LIST
96232: LIST
96233: LIST
96234: LIST
96235: LIST
96236: LIST
96237: LIST
96238: PUSH
96239: LD_INT 101
96241: PUSH
96242: LD_INT 102
96244: PUSH
96245: LD_INT 103
96247: PUSH
96248: LD_INT 104
96250: PUSH
96251: LD_INT 105
96253: PUSH
96254: LD_INT 106
96256: PUSH
96257: LD_INT 107
96259: PUSH
96260: LD_INT 108
96262: PUSH
96263: LD_INT 109
96265: PUSH
96266: LD_INT 110
96268: PUSH
96269: LD_INT 111
96271: PUSH
96272: LD_INT 112
96274: PUSH
96275: LD_INT 114
96277: PUSH
96278: LD_INT 116
96280: PUSH
96281: LD_INT 117
96283: PUSH
96284: LD_INT 118
96286: PUSH
96287: EMPTY
96288: LIST
96289: LIST
96290: LIST
96291: LIST
96292: LIST
96293: LIST
96294: LIST
96295: LIST
96296: LIST
96297: LIST
96298: LIST
96299: LIST
96300: LIST
96301: LIST
96302: LIST
96303: LIST
96304: PUSH
96305: EMPTY
96306: LIST
96307: LIST
96308: ST_TO_ADDR
96309: GO 98204
96311: LD_INT 11
96313: DOUBLE
96314: EQUAL
96315: IFTRUE 96319
96317: GO 96523
96319: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
96320: LD_ADDR_VAR 0 1
96324: PUSH
96325: LD_INT 2
96327: PUSH
96328: LD_INT 3
96330: PUSH
96331: LD_INT 4
96333: PUSH
96334: LD_INT 5
96336: PUSH
96337: LD_INT 6
96339: PUSH
96340: LD_INT 7
96342: PUSH
96343: LD_INT 8
96345: PUSH
96346: LD_INT 9
96348: PUSH
96349: LD_INT 10
96351: PUSH
96352: LD_INT 11
96354: PUSH
96355: LD_INT 12
96357: PUSH
96358: LD_INT 13
96360: PUSH
96361: LD_INT 14
96363: PUSH
96364: LD_INT 15
96366: PUSH
96367: LD_INT 16
96369: PUSH
96370: LD_INT 17
96372: PUSH
96373: LD_INT 18
96375: PUSH
96376: LD_INT 19
96378: PUSH
96379: LD_INT 20
96381: PUSH
96382: LD_INT 21
96384: PUSH
96385: LD_INT 22
96387: PUSH
96388: LD_INT 23
96390: PUSH
96391: LD_INT 24
96393: PUSH
96394: LD_INT 25
96396: PUSH
96397: LD_INT 26
96399: PUSH
96400: LD_INT 28
96402: PUSH
96403: LD_INT 30
96405: PUSH
96406: LD_INT 31
96408: PUSH
96409: LD_INT 32
96411: PUSH
96412: LD_INT 34
96414: PUSH
96415: LD_INT 36
96417: PUSH
96418: EMPTY
96419: LIST
96420: LIST
96421: LIST
96422: LIST
96423: LIST
96424: LIST
96425: LIST
96426: LIST
96427: LIST
96428: LIST
96429: LIST
96430: LIST
96431: LIST
96432: LIST
96433: LIST
96434: LIST
96435: LIST
96436: LIST
96437: LIST
96438: LIST
96439: LIST
96440: LIST
96441: LIST
96442: LIST
96443: LIST
96444: LIST
96445: LIST
96446: LIST
96447: LIST
96448: LIST
96449: LIST
96450: PUSH
96451: LD_INT 101
96453: PUSH
96454: LD_INT 102
96456: PUSH
96457: LD_INT 103
96459: PUSH
96460: LD_INT 104
96462: PUSH
96463: LD_INT 105
96465: PUSH
96466: LD_INT 106
96468: PUSH
96469: LD_INT 107
96471: PUSH
96472: LD_INT 108
96474: PUSH
96475: LD_INT 109
96477: PUSH
96478: LD_INT 110
96480: PUSH
96481: LD_INT 111
96483: PUSH
96484: LD_INT 112
96486: PUSH
96487: LD_INT 114
96489: PUSH
96490: LD_INT 116
96492: PUSH
96493: LD_INT 117
96495: PUSH
96496: LD_INT 118
96498: PUSH
96499: EMPTY
96500: LIST
96501: LIST
96502: LIST
96503: LIST
96504: LIST
96505: LIST
96506: LIST
96507: LIST
96508: LIST
96509: LIST
96510: LIST
96511: LIST
96512: LIST
96513: LIST
96514: LIST
96515: LIST
96516: PUSH
96517: EMPTY
96518: LIST
96519: LIST
96520: ST_TO_ADDR
96521: GO 98204
96523: LD_INT 12
96525: DOUBLE
96526: EQUAL
96527: IFTRUE 96531
96529: GO 96751
96531: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
96532: LD_ADDR_VAR 0 1
96536: PUSH
96537: LD_INT 1
96539: PUSH
96540: LD_INT 2
96542: PUSH
96543: LD_INT 3
96545: PUSH
96546: LD_INT 4
96548: PUSH
96549: LD_INT 5
96551: PUSH
96552: LD_INT 6
96554: PUSH
96555: LD_INT 7
96557: PUSH
96558: LD_INT 8
96560: PUSH
96561: LD_INT 9
96563: PUSH
96564: LD_INT 10
96566: PUSH
96567: LD_INT 11
96569: PUSH
96570: LD_INT 12
96572: PUSH
96573: LD_INT 13
96575: PUSH
96576: LD_INT 14
96578: PUSH
96579: LD_INT 15
96581: PUSH
96582: LD_INT 16
96584: PUSH
96585: LD_INT 17
96587: PUSH
96588: LD_INT 18
96590: PUSH
96591: LD_INT 19
96593: PUSH
96594: LD_INT 20
96596: PUSH
96597: LD_INT 21
96599: PUSH
96600: LD_INT 22
96602: PUSH
96603: LD_INT 23
96605: PUSH
96606: LD_INT 24
96608: PUSH
96609: LD_INT 25
96611: PUSH
96612: LD_INT 26
96614: PUSH
96615: LD_INT 27
96617: PUSH
96618: LD_INT 28
96620: PUSH
96621: LD_INT 30
96623: PUSH
96624: LD_INT 31
96626: PUSH
96627: LD_INT 32
96629: PUSH
96630: LD_INT 33
96632: PUSH
96633: LD_INT 34
96635: PUSH
96636: LD_INT 36
96638: PUSH
96639: EMPTY
96640: LIST
96641: LIST
96642: LIST
96643: LIST
96644: LIST
96645: LIST
96646: LIST
96647: LIST
96648: LIST
96649: LIST
96650: LIST
96651: LIST
96652: LIST
96653: LIST
96654: LIST
96655: LIST
96656: LIST
96657: LIST
96658: LIST
96659: LIST
96660: LIST
96661: LIST
96662: LIST
96663: LIST
96664: LIST
96665: LIST
96666: LIST
96667: LIST
96668: LIST
96669: LIST
96670: LIST
96671: LIST
96672: LIST
96673: LIST
96674: PUSH
96675: LD_INT 101
96677: PUSH
96678: LD_INT 102
96680: PUSH
96681: LD_INT 103
96683: PUSH
96684: LD_INT 104
96686: PUSH
96687: LD_INT 105
96689: PUSH
96690: LD_INT 106
96692: PUSH
96693: LD_INT 107
96695: PUSH
96696: LD_INT 108
96698: PUSH
96699: LD_INT 109
96701: PUSH
96702: LD_INT 110
96704: PUSH
96705: LD_INT 111
96707: PUSH
96708: LD_INT 112
96710: PUSH
96711: LD_INT 113
96713: PUSH
96714: LD_INT 114
96716: PUSH
96717: LD_INT 116
96719: PUSH
96720: LD_INT 117
96722: PUSH
96723: LD_INT 118
96725: PUSH
96726: EMPTY
96727: LIST
96728: LIST
96729: LIST
96730: LIST
96731: LIST
96732: LIST
96733: LIST
96734: LIST
96735: LIST
96736: LIST
96737: LIST
96738: LIST
96739: LIST
96740: LIST
96741: LIST
96742: LIST
96743: LIST
96744: PUSH
96745: EMPTY
96746: LIST
96747: LIST
96748: ST_TO_ADDR
96749: GO 98204
96751: LD_INT 13
96753: DOUBLE
96754: EQUAL
96755: IFTRUE 96759
96757: GO 96967
96759: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
96760: LD_ADDR_VAR 0 1
96764: PUSH
96765: LD_INT 1
96767: PUSH
96768: LD_INT 2
96770: PUSH
96771: LD_INT 3
96773: PUSH
96774: LD_INT 4
96776: PUSH
96777: LD_INT 5
96779: PUSH
96780: LD_INT 8
96782: PUSH
96783: LD_INT 9
96785: PUSH
96786: LD_INT 10
96788: PUSH
96789: LD_INT 11
96791: PUSH
96792: LD_INT 12
96794: PUSH
96795: LD_INT 14
96797: PUSH
96798: LD_INT 15
96800: PUSH
96801: LD_INT 16
96803: PUSH
96804: LD_INT 17
96806: PUSH
96807: LD_INT 18
96809: PUSH
96810: LD_INT 19
96812: PUSH
96813: LD_INT 20
96815: PUSH
96816: LD_INT 21
96818: PUSH
96819: LD_INT 22
96821: PUSH
96822: LD_INT 23
96824: PUSH
96825: LD_INT 24
96827: PUSH
96828: LD_INT 25
96830: PUSH
96831: LD_INT 26
96833: PUSH
96834: LD_INT 27
96836: PUSH
96837: LD_INT 28
96839: PUSH
96840: LD_INT 30
96842: PUSH
96843: LD_INT 31
96845: PUSH
96846: LD_INT 32
96848: PUSH
96849: LD_INT 33
96851: PUSH
96852: LD_INT 34
96854: PUSH
96855: LD_INT 36
96857: PUSH
96858: EMPTY
96859: LIST
96860: LIST
96861: LIST
96862: LIST
96863: LIST
96864: LIST
96865: LIST
96866: LIST
96867: LIST
96868: LIST
96869: LIST
96870: LIST
96871: LIST
96872: LIST
96873: LIST
96874: LIST
96875: LIST
96876: LIST
96877: LIST
96878: LIST
96879: LIST
96880: LIST
96881: LIST
96882: LIST
96883: LIST
96884: LIST
96885: LIST
96886: LIST
96887: LIST
96888: LIST
96889: LIST
96890: PUSH
96891: LD_INT 101
96893: PUSH
96894: LD_INT 102
96896: PUSH
96897: LD_INT 103
96899: PUSH
96900: LD_INT 104
96902: PUSH
96903: LD_INT 105
96905: PUSH
96906: LD_INT 106
96908: PUSH
96909: LD_INT 107
96911: PUSH
96912: LD_INT 108
96914: PUSH
96915: LD_INT 109
96917: PUSH
96918: LD_INT 110
96920: PUSH
96921: LD_INT 111
96923: PUSH
96924: LD_INT 112
96926: PUSH
96927: LD_INT 113
96929: PUSH
96930: LD_INT 114
96932: PUSH
96933: LD_INT 116
96935: PUSH
96936: LD_INT 117
96938: PUSH
96939: LD_INT 118
96941: PUSH
96942: EMPTY
96943: LIST
96944: LIST
96945: LIST
96946: LIST
96947: LIST
96948: LIST
96949: LIST
96950: LIST
96951: LIST
96952: LIST
96953: LIST
96954: LIST
96955: LIST
96956: LIST
96957: LIST
96958: LIST
96959: LIST
96960: PUSH
96961: EMPTY
96962: LIST
96963: LIST
96964: ST_TO_ADDR
96965: GO 98204
96967: LD_INT 14
96969: DOUBLE
96970: EQUAL
96971: IFTRUE 96975
96973: GO 97199
96975: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
96976: LD_ADDR_VAR 0 1
96980: PUSH
96981: LD_INT 1
96983: PUSH
96984: LD_INT 2
96986: PUSH
96987: LD_INT 3
96989: PUSH
96990: LD_INT 4
96992: PUSH
96993: LD_INT 5
96995: PUSH
96996: LD_INT 6
96998: PUSH
96999: LD_INT 7
97001: PUSH
97002: LD_INT 8
97004: PUSH
97005: LD_INT 9
97007: PUSH
97008: LD_INT 10
97010: PUSH
97011: LD_INT 11
97013: PUSH
97014: LD_INT 12
97016: PUSH
97017: LD_INT 13
97019: PUSH
97020: LD_INT 14
97022: PUSH
97023: LD_INT 15
97025: PUSH
97026: LD_INT 16
97028: PUSH
97029: LD_INT 17
97031: PUSH
97032: LD_INT 18
97034: PUSH
97035: LD_INT 19
97037: PUSH
97038: LD_INT 20
97040: PUSH
97041: LD_INT 21
97043: PUSH
97044: LD_INT 22
97046: PUSH
97047: LD_INT 23
97049: PUSH
97050: LD_INT 24
97052: PUSH
97053: LD_INT 25
97055: PUSH
97056: LD_INT 26
97058: PUSH
97059: LD_INT 27
97061: PUSH
97062: LD_INT 28
97064: PUSH
97065: LD_INT 29
97067: PUSH
97068: LD_INT 30
97070: PUSH
97071: LD_INT 31
97073: PUSH
97074: LD_INT 32
97076: PUSH
97077: LD_INT 33
97079: PUSH
97080: LD_INT 34
97082: PUSH
97083: LD_INT 36
97085: PUSH
97086: EMPTY
97087: LIST
97088: LIST
97089: LIST
97090: LIST
97091: LIST
97092: LIST
97093: LIST
97094: LIST
97095: LIST
97096: LIST
97097: LIST
97098: LIST
97099: LIST
97100: LIST
97101: LIST
97102: LIST
97103: LIST
97104: LIST
97105: LIST
97106: LIST
97107: LIST
97108: LIST
97109: LIST
97110: LIST
97111: LIST
97112: LIST
97113: LIST
97114: LIST
97115: LIST
97116: LIST
97117: LIST
97118: LIST
97119: LIST
97120: LIST
97121: LIST
97122: PUSH
97123: LD_INT 101
97125: PUSH
97126: LD_INT 102
97128: PUSH
97129: LD_INT 103
97131: PUSH
97132: LD_INT 104
97134: PUSH
97135: LD_INT 105
97137: PUSH
97138: LD_INT 106
97140: PUSH
97141: LD_INT 107
97143: PUSH
97144: LD_INT 108
97146: PUSH
97147: LD_INT 109
97149: PUSH
97150: LD_INT 110
97152: PUSH
97153: LD_INT 111
97155: PUSH
97156: LD_INT 112
97158: PUSH
97159: LD_INT 113
97161: PUSH
97162: LD_INT 114
97164: PUSH
97165: LD_INT 116
97167: PUSH
97168: LD_INT 117
97170: PUSH
97171: LD_INT 118
97173: PUSH
97174: EMPTY
97175: LIST
97176: LIST
97177: LIST
97178: LIST
97179: LIST
97180: LIST
97181: LIST
97182: LIST
97183: LIST
97184: LIST
97185: LIST
97186: LIST
97187: LIST
97188: LIST
97189: LIST
97190: LIST
97191: LIST
97192: PUSH
97193: EMPTY
97194: LIST
97195: LIST
97196: ST_TO_ADDR
97197: GO 98204
97199: LD_INT 15
97201: DOUBLE
97202: EQUAL
97203: IFTRUE 97207
97205: GO 97431
97207: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
97208: LD_ADDR_VAR 0 1
97212: PUSH
97213: LD_INT 1
97215: PUSH
97216: LD_INT 2
97218: PUSH
97219: LD_INT 3
97221: PUSH
97222: LD_INT 4
97224: PUSH
97225: LD_INT 5
97227: PUSH
97228: LD_INT 6
97230: PUSH
97231: LD_INT 7
97233: PUSH
97234: LD_INT 8
97236: PUSH
97237: LD_INT 9
97239: PUSH
97240: LD_INT 10
97242: PUSH
97243: LD_INT 11
97245: PUSH
97246: LD_INT 12
97248: PUSH
97249: LD_INT 13
97251: PUSH
97252: LD_INT 14
97254: PUSH
97255: LD_INT 15
97257: PUSH
97258: LD_INT 16
97260: PUSH
97261: LD_INT 17
97263: PUSH
97264: LD_INT 18
97266: PUSH
97267: LD_INT 19
97269: PUSH
97270: LD_INT 20
97272: PUSH
97273: LD_INT 21
97275: PUSH
97276: LD_INT 22
97278: PUSH
97279: LD_INT 23
97281: PUSH
97282: LD_INT 24
97284: PUSH
97285: LD_INT 25
97287: PUSH
97288: LD_INT 26
97290: PUSH
97291: LD_INT 27
97293: PUSH
97294: LD_INT 28
97296: PUSH
97297: LD_INT 29
97299: PUSH
97300: LD_INT 30
97302: PUSH
97303: LD_INT 31
97305: PUSH
97306: LD_INT 32
97308: PUSH
97309: LD_INT 33
97311: PUSH
97312: LD_INT 34
97314: PUSH
97315: LD_INT 36
97317: PUSH
97318: EMPTY
97319: LIST
97320: LIST
97321: LIST
97322: LIST
97323: LIST
97324: LIST
97325: LIST
97326: LIST
97327: LIST
97328: LIST
97329: LIST
97330: LIST
97331: LIST
97332: LIST
97333: LIST
97334: LIST
97335: LIST
97336: LIST
97337: LIST
97338: LIST
97339: LIST
97340: LIST
97341: LIST
97342: LIST
97343: LIST
97344: LIST
97345: LIST
97346: LIST
97347: LIST
97348: LIST
97349: LIST
97350: LIST
97351: LIST
97352: LIST
97353: LIST
97354: PUSH
97355: LD_INT 101
97357: PUSH
97358: LD_INT 102
97360: PUSH
97361: LD_INT 103
97363: PUSH
97364: LD_INT 104
97366: PUSH
97367: LD_INT 105
97369: PUSH
97370: LD_INT 106
97372: PUSH
97373: LD_INT 107
97375: PUSH
97376: LD_INT 108
97378: PUSH
97379: LD_INT 109
97381: PUSH
97382: LD_INT 110
97384: PUSH
97385: LD_INT 111
97387: PUSH
97388: LD_INT 112
97390: PUSH
97391: LD_INT 113
97393: PUSH
97394: LD_INT 114
97396: PUSH
97397: LD_INT 116
97399: PUSH
97400: LD_INT 117
97402: PUSH
97403: LD_INT 118
97405: PUSH
97406: EMPTY
97407: LIST
97408: LIST
97409: LIST
97410: LIST
97411: LIST
97412: LIST
97413: LIST
97414: LIST
97415: LIST
97416: LIST
97417: LIST
97418: LIST
97419: LIST
97420: LIST
97421: LIST
97422: LIST
97423: LIST
97424: PUSH
97425: EMPTY
97426: LIST
97427: LIST
97428: ST_TO_ADDR
97429: GO 98204
97431: LD_INT 16
97433: DOUBLE
97434: EQUAL
97435: IFTRUE 97439
97437: GO 97575
97439: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
97440: LD_ADDR_VAR 0 1
97444: PUSH
97445: LD_INT 2
97447: PUSH
97448: LD_INT 4
97450: PUSH
97451: LD_INT 5
97453: PUSH
97454: LD_INT 7
97456: PUSH
97457: LD_INT 11
97459: PUSH
97460: LD_INT 12
97462: PUSH
97463: LD_INT 15
97465: PUSH
97466: LD_INT 16
97468: PUSH
97469: LD_INT 20
97471: PUSH
97472: LD_INT 21
97474: PUSH
97475: LD_INT 22
97477: PUSH
97478: LD_INT 23
97480: PUSH
97481: LD_INT 25
97483: PUSH
97484: LD_INT 26
97486: PUSH
97487: LD_INT 30
97489: PUSH
97490: LD_INT 31
97492: PUSH
97493: LD_INT 32
97495: PUSH
97496: LD_INT 33
97498: PUSH
97499: LD_INT 34
97501: PUSH
97502: EMPTY
97503: LIST
97504: LIST
97505: LIST
97506: LIST
97507: LIST
97508: LIST
97509: LIST
97510: LIST
97511: LIST
97512: LIST
97513: LIST
97514: LIST
97515: LIST
97516: LIST
97517: LIST
97518: LIST
97519: LIST
97520: LIST
97521: LIST
97522: PUSH
97523: LD_INT 101
97525: PUSH
97526: LD_INT 102
97528: PUSH
97529: LD_INT 103
97531: PUSH
97532: LD_INT 106
97534: PUSH
97535: LD_INT 108
97537: PUSH
97538: LD_INT 112
97540: PUSH
97541: LD_INT 113
97543: PUSH
97544: LD_INT 114
97546: PUSH
97547: LD_INT 116
97549: PUSH
97550: LD_INT 117
97552: PUSH
97553: LD_INT 118
97555: PUSH
97556: EMPTY
97557: LIST
97558: LIST
97559: LIST
97560: LIST
97561: LIST
97562: LIST
97563: LIST
97564: LIST
97565: LIST
97566: LIST
97567: LIST
97568: PUSH
97569: EMPTY
97570: LIST
97571: LIST
97572: ST_TO_ADDR
97573: GO 98204
97575: LD_INT 17
97577: DOUBLE
97578: EQUAL
97579: IFTRUE 97583
97581: GO 97807
97583: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
97584: LD_ADDR_VAR 0 1
97588: PUSH
97589: LD_INT 1
97591: PUSH
97592: LD_INT 2
97594: PUSH
97595: LD_INT 3
97597: PUSH
97598: LD_INT 4
97600: PUSH
97601: LD_INT 5
97603: PUSH
97604: LD_INT 6
97606: PUSH
97607: LD_INT 7
97609: PUSH
97610: LD_INT 8
97612: PUSH
97613: LD_INT 9
97615: PUSH
97616: LD_INT 10
97618: PUSH
97619: LD_INT 11
97621: PUSH
97622: LD_INT 12
97624: PUSH
97625: LD_INT 13
97627: PUSH
97628: LD_INT 14
97630: PUSH
97631: LD_INT 15
97633: PUSH
97634: LD_INT 16
97636: PUSH
97637: LD_INT 17
97639: PUSH
97640: LD_INT 18
97642: PUSH
97643: LD_INT 19
97645: PUSH
97646: LD_INT 20
97648: PUSH
97649: LD_INT 21
97651: PUSH
97652: LD_INT 22
97654: PUSH
97655: LD_INT 23
97657: PUSH
97658: LD_INT 24
97660: PUSH
97661: LD_INT 25
97663: PUSH
97664: LD_INT 26
97666: PUSH
97667: LD_INT 27
97669: PUSH
97670: LD_INT 28
97672: PUSH
97673: LD_INT 29
97675: PUSH
97676: LD_INT 30
97678: PUSH
97679: LD_INT 31
97681: PUSH
97682: LD_INT 32
97684: PUSH
97685: LD_INT 33
97687: PUSH
97688: LD_INT 34
97690: PUSH
97691: LD_INT 36
97693: PUSH
97694: EMPTY
97695: LIST
97696: LIST
97697: LIST
97698: LIST
97699: LIST
97700: LIST
97701: LIST
97702: LIST
97703: LIST
97704: LIST
97705: LIST
97706: LIST
97707: LIST
97708: LIST
97709: LIST
97710: LIST
97711: LIST
97712: LIST
97713: LIST
97714: LIST
97715: LIST
97716: LIST
97717: LIST
97718: LIST
97719: LIST
97720: LIST
97721: LIST
97722: LIST
97723: LIST
97724: LIST
97725: LIST
97726: LIST
97727: LIST
97728: LIST
97729: LIST
97730: PUSH
97731: LD_INT 101
97733: PUSH
97734: LD_INT 102
97736: PUSH
97737: LD_INT 103
97739: PUSH
97740: LD_INT 104
97742: PUSH
97743: LD_INT 105
97745: PUSH
97746: LD_INT 106
97748: PUSH
97749: LD_INT 107
97751: PUSH
97752: LD_INT 108
97754: PUSH
97755: LD_INT 109
97757: PUSH
97758: LD_INT 110
97760: PUSH
97761: LD_INT 111
97763: PUSH
97764: LD_INT 112
97766: PUSH
97767: LD_INT 113
97769: PUSH
97770: LD_INT 114
97772: PUSH
97773: LD_INT 116
97775: PUSH
97776: LD_INT 117
97778: PUSH
97779: LD_INT 118
97781: PUSH
97782: EMPTY
97783: LIST
97784: LIST
97785: LIST
97786: LIST
97787: LIST
97788: LIST
97789: LIST
97790: LIST
97791: LIST
97792: LIST
97793: LIST
97794: LIST
97795: LIST
97796: LIST
97797: LIST
97798: LIST
97799: LIST
97800: PUSH
97801: EMPTY
97802: LIST
97803: LIST
97804: ST_TO_ADDR
97805: GO 98204
97807: LD_INT 18
97809: DOUBLE
97810: EQUAL
97811: IFTRUE 97815
97813: GO 97963
97815: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
97816: LD_ADDR_VAR 0 1
97820: PUSH
97821: LD_INT 2
97823: PUSH
97824: LD_INT 4
97826: PUSH
97827: LD_INT 5
97829: PUSH
97830: LD_INT 7
97832: PUSH
97833: LD_INT 11
97835: PUSH
97836: LD_INT 12
97838: PUSH
97839: LD_INT 15
97841: PUSH
97842: LD_INT 16
97844: PUSH
97845: LD_INT 20
97847: PUSH
97848: LD_INT 21
97850: PUSH
97851: LD_INT 22
97853: PUSH
97854: LD_INT 23
97856: PUSH
97857: LD_INT 25
97859: PUSH
97860: LD_INT 26
97862: PUSH
97863: LD_INT 30
97865: PUSH
97866: LD_INT 31
97868: PUSH
97869: LD_INT 32
97871: PUSH
97872: LD_INT 33
97874: PUSH
97875: LD_INT 34
97877: PUSH
97878: LD_INT 35
97880: PUSH
97881: LD_INT 36
97883: PUSH
97884: EMPTY
97885: LIST
97886: LIST
97887: LIST
97888: LIST
97889: LIST
97890: LIST
97891: LIST
97892: LIST
97893: LIST
97894: LIST
97895: LIST
97896: LIST
97897: LIST
97898: LIST
97899: LIST
97900: LIST
97901: LIST
97902: LIST
97903: LIST
97904: LIST
97905: LIST
97906: PUSH
97907: LD_INT 101
97909: PUSH
97910: LD_INT 102
97912: PUSH
97913: LD_INT 103
97915: PUSH
97916: LD_INT 106
97918: PUSH
97919: LD_INT 108
97921: PUSH
97922: LD_INT 112
97924: PUSH
97925: LD_INT 113
97927: PUSH
97928: LD_INT 114
97930: PUSH
97931: LD_INT 115
97933: PUSH
97934: LD_INT 116
97936: PUSH
97937: LD_INT 117
97939: PUSH
97940: LD_INT 118
97942: PUSH
97943: EMPTY
97944: LIST
97945: LIST
97946: LIST
97947: LIST
97948: LIST
97949: LIST
97950: LIST
97951: LIST
97952: LIST
97953: LIST
97954: LIST
97955: LIST
97956: PUSH
97957: EMPTY
97958: LIST
97959: LIST
97960: ST_TO_ADDR
97961: GO 98204
97963: LD_INT 19
97965: DOUBLE
97966: EQUAL
97967: IFTRUE 97971
97969: GO 98203
97971: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
97972: LD_ADDR_VAR 0 1
97976: PUSH
97977: LD_INT 1
97979: PUSH
97980: LD_INT 2
97982: PUSH
97983: LD_INT 3
97985: PUSH
97986: LD_INT 4
97988: PUSH
97989: LD_INT 5
97991: PUSH
97992: LD_INT 6
97994: PUSH
97995: LD_INT 7
97997: PUSH
97998: LD_INT 8
98000: PUSH
98001: LD_INT 9
98003: PUSH
98004: LD_INT 10
98006: PUSH
98007: LD_INT 11
98009: PUSH
98010: LD_INT 12
98012: PUSH
98013: LD_INT 13
98015: PUSH
98016: LD_INT 14
98018: PUSH
98019: LD_INT 15
98021: PUSH
98022: LD_INT 16
98024: PUSH
98025: LD_INT 17
98027: PUSH
98028: LD_INT 18
98030: PUSH
98031: LD_INT 19
98033: PUSH
98034: LD_INT 20
98036: PUSH
98037: LD_INT 21
98039: PUSH
98040: LD_INT 22
98042: PUSH
98043: LD_INT 23
98045: PUSH
98046: LD_INT 24
98048: PUSH
98049: LD_INT 25
98051: PUSH
98052: LD_INT 26
98054: PUSH
98055: LD_INT 27
98057: PUSH
98058: LD_INT 28
98060: PUSH
98061: LD_INT 29
98063: PUSH
98064: LD_INT 30
98066: PUSH
98067: LD_INT 31
98069: PUSH
98070: LD_INT 32
98072: PUSH
98073: LD_INT 33
98075: PUSH
98076: LD_INT 34
98078: PUSH
98079: LD_INT 35
98081: PUSH
98082: LD_INT 36
98084: PUSH
98085: EMPTY
98086: LIST
98087: LIST
98088: LIST
98089: LIST
98090: LIST
98091: LIST
98092: LIST
98093: LIST
98094: LIST
98095: LIST
98096: LIST
98097: LIST
98098: LIST
98099: LIST
98100: LIST
98101: LIST
98102: LIST
98103: LIST
98104: LIST
98105: LIST
98106: LIST
98107: LIST
98108: LIST
98109: LIST
98110: LIST
98111: LIST
98112: LIST
98113: LIST
98114: LIST
98115: LIST
98116: LIST
98117: LIST
98118: LIST
98119: LIST
98120: LIST
98121: LIST
98122: PUSH
98123: LD_INT 101
98125: PUSH
98126: LD_INT 102
98128: PUSH
98129: LD_INT 103
98131: PUSH
98132: LD_INT 104
98134: PUSH
98135: LD_INT 105
98137: PUSH
98138: LD_INT 106
98140: PUSH
98141: LD_INT 107
98143: PUSH
98144: LD_INT 108
98146: PUSH
98147: LD_INT 109
98149: PUSH
98150: LD_INT 110
98152: PUSH
98153: LD_INT 111
98155: PUSH
98156: LD_INT 112
98158: PUSH
98159: LD_INT 113
98161: PUSH
98162: LD_INT 114
98164: PUSH
98165: LD_INT 115
98167: PUSH
98168: LD_INT 116
98170: PUSH
98171: LD_INT 117
98173: PUSH
98174: LD_INT 118
98176: PUSH
98177: EMPTY
98178: LIST
98179: LIST
98180: LIST
98181: LIST
98182: LIST
98183: LIST
98184: LIST
98185: LIST
98186: LIST
98187: LIST
98188: LIST
98189: LIST
98190: LIST
98191: LIST
98192: LIST
98193: LIST
98194: LIST
98195: LIST
98196: PUSH
98197: EMPTY
98198: LIST
98199: LIST
98200: ST_TO_ADDR
98201: GO 98204
98203: POP
// end else
98204: GO 98435
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
98206: LD_ADDR_VAR 0 1
98210: PUSH
98211: LD_INT 1
98213: PUSH
98214: LD_INT 2
98216: PUSH
98217: LD_INT 3
98219: PUSH
98220: LD_INT 4
98222: PUSH
98223: LD_INT 5
98225: PUSH
98226: LD_INT 6
98228: PUSH
98229: LD_INT 7
98231: PUSH
98232: LD_INT 8
98234: PUSH
98235: LD_INT 9
98237: PUSH
98238: LD_INT 10
98240: PUSH
98241: LD_INT 11
98243: PUSH
98244: LD_INT 12
98246: PUSH
98247: LD_INT 13
98249: PUSH
98250: LD_INT 14
98252: PUSH
98253: LD_INT 15
98255: PUSH
98256: LD_INT 16
98258: PUSH
98259: LD_INT 17
98261: PUSH
98262: LD_INT 18
98264: PUSH
98265: LD_INT 19
98267: PUSH
98268: LD_INT 20
98270: PUSH
98271: LD_INT 21
98273: PUSH
98274: LD_INT 22
98276: PUSH
98277: LD_INT 23
98279: PUSH
98280: LD_INT 24
98282: PUSH
98283: LD_INT 25
98285: PUSH
98286: LD_INT 26
98288: PUSH
98289: LD_INT 27
98291: PUSH
98292: LD_INT 28
98294: PUSH
98295: LD_INT 29
98297: PUSH
98298: LD_INT 30
98300: PUSH
98301: LD_INT 31
98303: PUSH
98304: LD_INT 32
98306: PUSH
98307: LD_INT 33
98309: PUSH
98310: LD_INT 34
98312: PUSH
98313: LD_INT 35
98315: PUSH
98316: LD_INT 36
98318: PUSH
98319: EMPTY
98320: LIST
98321: LIST
98322: LIST
98323: LIST
98324: LIST
98325: LIST
98326: LIST
98327: LIST
98328: LIST
98329: LIST
98330: LIST
98331: LIST
98332: LIST
98333: LIST
98334: LIST
98335: LIST
98336: LIST
98337: LIST
98338: LIST
98339: LIST
98340: LIST
98341: LIST
98342: LIST
98343: LIST
98344: LIST
98345: LIST
98346: LIST
98347: LIST
98348: LIST
98349: LIST
98350: LIST
98351: LIST
98352: LIST
98353: LIST
98354: LIST
98355: LIST
98356: PUSH
98357: LD_INT 101
98359: PUSH
98360: LD_INT 102
98362: PUSH
98363: LD_INT 103
98365: PUSH
98366: LD_INT 104
98368: PUSH
98369: LD_INT 105
98371: PUSH
98372: LD_INT 106
98374: PUSH
98375: LD_INT 107
98377: PUSH
98378: LD_INT 108
98380: PUSH
98381: LD_INT 109
98383: PUSH
98384: LD_INT 110
98386: PUSH
98387: LD_INT 111
98389: PUSH
98390: LD_INT 112
98392: PUSH
98393: LD_INT 113
98395: PUSH
98396: LD_INT 114
98398: PUSH
98399: LD_INT 115
98401: PUSH
98402: LD_INT 116
98404: PUSH
98405: LD_INT 117
98407: PUSH
98408: LD_INT 118
98410: PUSH
98411: EMPTY
98412: LIST
98413: LIST
98414: LIST
98415: LIST
98416: LIST
98417: LIST
98418: LIST
98419: LIST
98420: LIST
98421: LIST
98422: LIST
98423: LIST
98424: LIST
98425: LIST
98426: LIST
98427: LIST
98428: LIST
98429: LIST
98430: PUSH
98431: EMPTY
98432: LIST
98433: LIST
98434: ST_TO_ADDR
// if result then
98435: LD_VAR 0 1
98439: IFFALSE 98728
// begin normal :=  ;
98441: LD_ADDR_VAR 0 3
98445: PUSH
98446: LD_STRING 
98448: ST_TO_ADDR
// hardcore :=  ;
98449: LD_ADDR_VAR 0 4
98453: PUSH
98454: LD_STRING 
98456: ST_TO_ADDR
// for i = 1 to normalCounter do
98457: LD_ADDR_VAR 0 5
98461: PUSH
98462: DOUBLE
98463: LD_INT 1
98465: DEC
98466: ST_TO_ADDR
98467: LD_EXP 99
98471: PUSH
98472: FOR_TO
98473: IFFALSE 98574
// begin tmp := 0 ;
98475: LD_ADDR_VAR 0 2
98479: PUSH
98480: LD_STRING 0
98482: ST_TO_ADDR
// if result [ 1 ] then
98483: LD_VAR 0 1
98487: PUSH
98488: LD_INT 1
98490: ARRAY
98491: IFFALSE 98556
// if result [ 1 ] [ 1 ] = i then
98493: LD_VAR 0 1
98497: PUSH
98498: LD_INT 1
98500: ARRAY
98501: PUSH
98502: LD_INT 1
98504: ARRAY
98505: PUSH
98506: LD_VAR 0 5
98510: EQUAL
98511: IFFALSE 98556
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
98513: LD_ADDR_VAR 0 1
98517: PUSH
98518: LD_VAR 0 1
98522: PPUSH
98523: LD_INT 1
98525: PPUSH
98526: LD_VAR 0 1
98530: PUSH
98531: LD_INT 1
98533: ARRAY
98534: PPUSH
98535: LD_INT 1
98537: PPUSH
98538: CALL_OW 3
98542: PPUSH
98543: CALL_OW 1
98547: ST_TO_ADDR
// tmp := 1 ;
98548: LD_ADDR_VAR 0 2
98552: PUSH
98553: LD_STRING 1
98555: ST_TO_ADDR
// end ; normal := normal & tmp ;
98556: LD_ADDR_VAR 0 3
98560: PUSH
98561: LD_VAR 0 3
98565: PUSH
98566: LD_VAR 0 2
98570: STR
98571: ST_TO_ADDR
// end ;
98572: GO 98472
98574: POP
98575: POP
// for i = 1 to hardcoreCounter do
98576: LD_ADDR_VAR 0 5
98580: PUSH
98581: DOUBLE
98582: LD_INT 1
98584: DEC
98585: ST_TO_ADDR
98586: LD_EXP 100
98590: PUSH
98591: FOR_TO
98592: IFFALSE 98697
// begin tmp := 0 ;
98594: LD_ADDR_VAR 0 2
98598: PUSH
98599: LD_STRING 0
98601: ST_TO_ADDR
// if result [ 2 ] then
98602: LD_VAR 0 1
98606: PUSH
98607: LD_INT 2
98609: ARRAY
98610: IFFALSE 98679
// if result [ 2 ] [ 1 ] = 100 + i then
98612: LD_VAR 0 1
98616: PUSH
98617: LD_INT 2
98619: ARRAY
98620: PUSH
98621: LD_INT 1
98623: ARRAY
98624: PUSH
98625: LD_INT 100
98627: PUSH
98628: LD_VAR 0 5
98632: PLUS
98633: EQUAL
98634: IFFALSE 98679
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
98636: LD_ADDR_VAR 0 1
98640: PUSH
98641: LD_VAR 0 1
98645: PPUSH
98646: LD_INT 2
98648: PPUSH
98649: LD_VAR 0 1
98653: PUSH
98654: LD_INT 2
98656: ARRAY
98657: PPUSH
98658: LD_INT 1
98660: PPUSH
98661: CALL_OW 3
98665: PPUSH
98666: CALL_OW 1
98670: ST_TO_ADDR
// tmp := 1 ;
98671: LD_ADDR_VAR 0 2
98675: PUSH
98676: LD_STRING 1
98678: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
98679: LD_ADDR_VAR 0 4
98683: PUSH
98684: LD_VAR 0 4
98688: PUSH
98689: LD_VAR 0 2
98693: STR
98694: ST_TO_ADDR
// end ;
98695: GO 98591
98697: POP
98698: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
98699: LD_STRING getStreamItemsFromMission("
98701: PUSH
98702: LD_VAR 0 3
98706: STR
98707: PUSH
98708: LD_STRING ","
98710: STR
98711: PUSH
98712: LD_VAR 0 4
98716: STR
98717: PUSH
98718: LD_STRING ")
98720: STR
98721: PPUSH
98722: CALL_OW 559
// end else
98726: GO 98735
// ToLua ( getStreamItemsFromMission("","") ) ;
98728: LD_STRING getStreamItemsFromMission("","")
98730: PPUSH
98731: CALL_OW 559
// end ;
98735: LD_VAR 0 1
98739: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
98740: LD_EXP 98
98744: PUSH
98745: LD_EXP 103
98749: AND
98750: IFFALSE 98874
98752: GO 98754
98754: DISABLE
98755: LD_INT 0
98757: PPUSH
98758: PPUSH
// begin enable ;
98759: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
98760: LD_ADDR_VAR 0 2
98764: PUSH
98765: LD_INT 22
98767: PUSH
98768: LD_OWVAR 2
98772: PUSH
98773: EMPTY
98774: LIST
98775: LIST
98776: PUSH
98777: LD_INT 2
98779: PUSH
98780: LD_INT 34
98782: PUSH
98783: LD_INT 7
98785: PUSH
98786: EMPTY
98787: LIST
98788: LIST
98789: PUSH
98790: LD_INT 34
98792: PUSH
98793: LD_INT 45
98795: PUSH
98796: EMPTY
98797: LIST
98798: LIST
98799: PUSH
98800: LD_INT 34
98802: PUSH
98803: LD_INT 28
98805: PUSH
98806: EMPTY
98807: LIST
98808: LIST
98809: PUSH
98810: LD_INT 34
98812: PUSH
98813: LD_INT 47
98815: PUSH
98816: EMPTY
98817: LIST
98818: LIST
98819: PUSH
98820: EMPTY
98821: LIST
98822: LIST
98823: LIST
98824: LIST
98825: LIST
98826: PUSH
98827: EMPTY
98828: LIST
98829: LIST
98830: PPUSH
98831: CALL_OW 69
98835: ST_TO_ADDR
// if not tmp then
98836: LD_VAR 0 2
98840: NOT
98841: IFFALSE 98845
// exit ;
98843: GO 98874
// for i in tmp do
98845: LD_ADDR_VAR 0 1
98849: PUSH
98850: LD_VAR 0 2
98854: PUSH
98855: FOR_IN
98856: IFFALSE 98872
// begin SetLives ( i , 0 ) ;
98858: LD_VAR 0 1
98862: PPUSH
98863: LD_INT 0
98865: PPUSH
98866: CALL_OW 234
// end ;
98870: GO 98855
98872: POP
98873: POP
// end ;
98874: PPOPN 2
98876: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
98877: LD_EXP 98
98881: PUSH
98882: LD_EXP 104
98886: AND
98887: IFFALSE 98971
98889: GO 98891
98891: DISABLE
98892: LD_INT 0
98894: PPUSH
98895: PPUSH
// begin enable ;
98896: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
98897: LD_ADDR_VAR 0 2
98901: PUSH
98902: LD_INT 22
98904: PUSH
98905: LD_OWVAR 2
98909: PUSH
98910: EMPTY
98911: LIST
98912: LIST
98913: PUSH
98914: LD_INT 32
98916: PUSH
98917: LD_INT 3
98919: PUSH
98920: EMPTY
98921: LIST
98922: LIST
98923: PUSH
98924: EMPTY
98925: LIST
98926: LIST
98927: PPUSH
98928: CALL_OW 69
98932: ST_TO_ADDR
// if not tmp then
98933: LD_VAR 0 2
98937: NOT
98938: IFFALSE 98942
// exit ;
98940: GO 98971
// for i in tmp do
98942: LD_ADDR_VAR 0 1
98946: PUSH
98947: LD_VAR 0 2
98951: PUSH
98952: FOR_IN
98953: IFFALSE 98969
// begin SetLives ( i , 0 ) ;
98955: LD_VAR 0 1
98959: PPUSH
98960: LD_INT 0
98962: PPUSH
98963: CALL_OW 234
// end ;
98967: GO 98952
98969: POP
98970: POP
// end ;
98971: PPOPN 2
98973: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
98974: LD_EXP 98
98978: PUSH
98979: LD_EXP 101
98983: AND
98984: IFFALSE 99077
98986: GO 98988
98988: DISABLE
98989: LD_INT 0
98991: PPUSH
// begin enable ;
98992: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
98993: LD_ADDR_VAR 0 1
98997: PUSH
98998: LD_INT 22
99000: PUSH
99001: LD_OWVAR 2
99005: PUSH
99006: EMPTY
99007: LIST
99008: LIST
99009: PUSH
99010: LD_INT 2
99012: PUSH
99013: LD_INT 25
99015: PUSH
99016: LD_INT 5
99018: PUSH
99019: EMPTY
99020: LIST
99021: LIST
99022: PUSH
99023: LD_INT 25
99025: PUSH
99026: LD_INT 9
99028: PUSH
99029: EMPTY
99030: LIST
99031: LIST
99032: PUSH
99033: LD_INT 25
99035: PUSH
99036: LD_INT 8
99038: PUSH
99039: EMPTY
99040: LIST
99041: LIST
99042: PUSH
99043: EMPTY
99044: LIST
99045: LIST
99046: LIST
99047: LIST
99048: PUSH
99049: EMPTY
99050: LIST
99051: LIST
99052: PPUSH
99053: CALL_OW 69
99057: PUSH
99058: FOR_IN
99059: IFFALSE 99075
// begin SetClass ( i , 1 ) ;
99061: LD_VAR 0 1
99065: PPUSH
99066: LD_INT 1
99068: PPUSH
99069: CALL_OW 336
// end ;
99073: GO 99058
99075: POP
99076: POP
// end ;
99077: PPOPN 1
99079: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
99080: LD_EXP 98
99084: PUSH
99085: LD_EXP 102
99089: AND
99090: PUSH
99091: LD_OWVAR 65
99095: PUSH
99096: LD_INT 7
99098: LESS
99099: AND
99100: IFFALSE 99114
99102: GO 99104
99104: DISABLE
// begin enable ;
99105: ENABLE
// game_speed := 7 ;
99106: LD_ADDR_OWVAR 65
99110: PUSH
99111: LD_INT 7
99113: ST_TO_ADDR
// end ;
99114: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
99115: LD_EXP 98
99119: PUSH
99120: LD_EXP 105
99124: AND
99125: IFFALSE 99327
99127: GO 99129
99129: DISABLE
99130: LD_INT 0
99132: PPUSH
99133: PPUSH
99134: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
99135: LD_ADDR_VAR 0 3
99139: PUSH
99140: LD_INT 81
99142: PUSH
99143: LD_OWVAR 2
99147: PUSH
99148: EMPTY
99149: LIST
99150: LIST
99151: PUSH
99152: LD_INT 21
99154: PUSH
99155: LD_INT 1
99157: PUSH
99158: EMPTY
99159: LIST
99160: LIST
99161: PUSH
99162: EMPTY
99163: LIST
99164: LIST
99165: PPUSH
99166: CALL_OW 69
99170: ST_TO_ADDR
// if not tmp then
99171: LD_VAR 0 3
99175: NOT
99176: IFFALSE 99180
// exit ;
99178: GO 99327
// if tmp > 5 then
99180: LD_VAR 0 3
99184: PUSH
99185: LD_INT 5
99187: GREATER
99188: IFFALSE 99200
// k := 5 else
99190: LD_ADDR_VAR 0 2
99194: PUSH
99195: LD_INT 5
99197: ST_TO_ADDR
99198: GO 99210
// k := tmp ;
99200: LD_ADDR_VAR 0 2
99204: PUSH
99205: LD_VAR 0 3
99209: ST_TO_ADDR
// for i := 1 to k do
99210: LD_ADDR_VAR 0 1
99214: PUSH
99215: DOUBLE
99216: LD_INT 1
99218: DEC
99219: ST_TO_ADDR
99220: LD_VAR 0 2
99224: PUSH
99225: FOR_TO
99226: IFFALSE 99325
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
99228: LD_VAR 0 3
99232: PUSH
99233: LD_VAR 0 1
99237: ARRAY
99238: PPUSH
99239: LD_VAR 0 1
99243: PUSH
99244: LD_INT 4
99246: MOD
99247: PUSH
99248: LD_INT 1
99250: PLUS
99251: PPUSH
99252: CALL_OW 259
99256: PUSH
99257: LD_INT 10
99259: LESS
99260: IFFALSE 99323
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
99262: LD_VAR 0 3
99266: PUSH
99267: LD_VAR 0 1
99271: ARRAY
99272: PPUSH
99273: LD_VAR 0 1
99277: PUSH
99278: LD_INT 4
99280: MOD
99281: PUSH
99282: LD_INT 1
99284: PLUS
99285: PPUSH
99286: LD_VAR 0 3
99290: PUSH
99291: LD_VAR 0 1
99295: ARRAY
99296: PPUSH
99297: LD_VAR 0 1
99301: PUSH
99302: LD_INT 4
99304: MOD
99305: PUSH
99306: LD_INT 1
99308: PLUS
99309: PPUSH
99310: CALL_OW 259
99314: PUSH
99315: LD_INT 1
99317: PLUS
99318: PPUSH
99319: CALL_OW 237
99323: GO 99225
99325: POP
99326: POP
// end ;
99327: PPOPN 3
99329: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
99330: LD_EXP 98
99334: PUSH
99335: LD_EXP 106
99339: AND
99340: IFFALSE 99360
99342: GO 99344
99344: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
99345: LD_INT 4
99347: PPUSH
99348: LD_OWVAR 2
99352: PPUSH
99353: LD_INT 0
99355: PPUSH
99356: CALL_OW 324
99360: END
// every 0 0$1 trigger StreamModeActive and sShovel do
99361: LD_EXP 98
99365: PUSH
99366: LD_EXP 135
99370: AND
99371: IFFALSE 99391
99373: GO 99375
99375: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
99376: LD_INT 19
99378: PPUSH
99379: LD_OWVAR 2
99383: PPUSH
99384: LD_INT 0
99386: PPUSH
99387: CALL_OW 324
99391: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
99392: LD_EXP 98
99396: PUSH
99397: LD_EXP 107
99401: AND
99402: IFFALSE 99504
99404: GO 99406
99406: DISABLE
99407: LD_INT 0
99409: PPUSH
99410: PPUSH
// begin enable ;
99411: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
99412: LD_ADDR_VAR 0 2
99416: PUSH
99417: LD_INT 22
99419: PUSH
99420: LD_OWVAR 2
99424: PUSH
99425: EMPTY
99426: LIST
99427: LIST
99428: PUSH
99429: LD_INT 2
99431: PUSH
99432: LD_INT 34
99434: PUSH
99435: LD_INT 11
99437: PUSH
99438: EMPTY
99439: LIST
99440: LIST
99441: PUSH
99442: LD_INT 34
99444: PUSH
99445: LD_INT 30
99447: PUSH
99448: EMPTY
99449: LIST
99450: LIST
99451: PUSH
99452: EMPTY
99453: LIST
99454: LIST
99455: LIST
99456: PUSH
99457: EMPTY
99458: LIST
99459: LIST
99460: PPUSH
99461: CALL_OW 69
99465: ST_TO_ADDR
// if not tmp then
99466: LD_VAR 0 2
99470: NOT
99471: IFFALSE 99475
// exit ;
99473: GO 99504
// for i in tmp do
99475: LD_ADDR_VAR 0 1
99479: PUSH
99480: LD_VAR 0 2
99484: PUSH
99485: FOR_IN
99486: IFFALSE 99502
// begin SetLives ( i , 0 ) ;
99488: LD_VAR 0 1
99492: PPUSH
99493: LD_INT 0
99495: PPUSH
99496: CALL_OW 234
// end ;
99500: GO 99485
99502: POP
99503: POP
// end ;
99504: PPOPN 2
99506: END
// every 0 0$1 trigger StreamModeActive and sBunker do
99507: LD_EXP 98
99511: PUSH
99512: LD_EXP 108
99516: AND
99517: IFFALSE 99537
99519: GO 99521
99521: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
99522: LD_INT 32
99524: PPUSH
99525: LD_OWVAR 2
99529: PPUSH
99530: LD_INT 0
99532: PPUSH
99533: CALL_OW 324
99537: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
99538: LD_EXP 98
99542: PUSH
99543: LD_EXP 109
99547: AND
99548: IFFALSE 99729
99550: GO 99552
99552: DISABLE
99553: LD_INT 0
99555: PPUSH
99556: PPUSH
99557: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
99558: LD_ADDR_VAR 0 2
99562: PUSH
99563: LD_INT 22
99565: PUSH
99566: LD_OWVAR 2
99570: PUSH
99571: EMPTY
99572: LIST
99573: LIST
99574: PUSH
99575: LD_INT 33
99577: PUSH
99578: LD_INT 3
99580: PUSH
99581: EMPTY
99582: LIST
99583: LIST
99584: PUSH
99585: EMPTY
99586: LIST
99587: LIST
99588: PPUSH
99589: CALL_OW 69
99593: ST_TO_ADDR
// if not tmp then
99594: LD_VAR 0 2
99598: NOT
99599: IFFALSE 99603
// exit ;
99601: GO 99729
// side := 0 ;
99603: LD_ADDR_VAR 0 3
99607: PUSH
99608: LD_INT 0
99610: ST_TO_ADDR
// for i := 1 to 8 do
99611: LD_ADDR_VAR 0 1
99615: PUSH
99616: DOUBLE
99617: LD_INT 1
99619: DEC
99620: ST_TO_ADDR
99621: LD_INT 8
99623: PUSH
99624: FOR_TO
99625: IFFALSE 99673
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
99627: LD_OWVAR 2
99631: PUSH
99632: LD_VAR 0 1
99636: NONEQUAL
99637: PUSH
99638: LD_OWVAR 2
99642: PPUSH
99643: LD_VAR 0 1
99647: PPUSH
99648: CALL_OW 81
99652: PUSH
99653: LD_INT 2
99655: EQUAL
99656: AND
99657: IFFALSE 99671
// begin side := i ;
99659: LD_ADDR_VAR 0 3
99663: PUSH
99664: LD_VAR 0 1
99668: ST_TO_ADDR
// break ;
99669: GO 99673
// end ;
99671: GO 99624
99673: POP
99674: POP
// if not side then
99675: LD_VAR 0 3
99679: NOT
99680: IFFALSE 99684
// exit ;
99682: GO 99729
// for i := 1 to tmp do
99684: LD_ADDR_VAR 0 1
99688: PUSH
99689: DOUBLE
99690: LD_INT 1
99692: DEC
99693: ST_TO_ADDR
99694: LD_VAR 0 2
99698: PUSH
99699: FOR_TO
99700: IFFALSE 99727
// if Prob ( 60 ) then
99702: LD_INT 60
99704: PPUSH
99705: CALL_OW 13
99709: IFFALSE 99725
// SetSide ( i , side ) ;
99711: LD_VAR 0 1
99715: PPUSH
99716: LD_VAR 0 3
99720: PPUSH
99721: CALL_OW 235
99725: GO 99699
99727: POP
99728: POP
// end ;
99729: PPOPN 3
99731: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
99732: LD_EXP 98
99736: PUSH
99737: LD_EXP 111
99741: AND
99742: IFFALSE 99861
99744: GO 99746
99746: DISABLE
99747: LD_INT 0
99749: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
99750: LD_ADDR_VAR 0 1
99754: PUSH
99755: LD_INT 22
99757: PUSH
99758: LD_OWVAR 2
99762: PUSH
99763: EMPTY
99764: LIST
99765: LIST
99766: PUSH
99767: LD_INT 21
99769: PUSH
99770: LD_INT 1
99772: PUSH
99773: EMPTY
99774: LIST
99775: LIST
99776: PUSH
99777: LD_INT 3
99779: PUSH
99780: LD_INT 23
99782: PUSH
99783: LD_INT 0
99785: PUSH
99786: EMPTY
99787: LIST
99788: LIST
99789: PUSH
99790: EMPTY
99791: LIST
99792: LIST
99793: PUSH
99794: EMPTY
99795: LIST
99796: LIST
99797: LIST
99798: PPUSH
99799: CALL_OW 69
99803: PUSH
99804: FOR_IN
99805: IFFALSE 99859
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
99807: LD_VAR 0 1
99811: PPUSH
99812: CALL_OW 257
99816: PUSH
99817: LD_INT 1
99819: PUSH
99820: LD_INT 2
99822: PUSH
99823: LD_INT 3
99825: PUSH
99826: LD_INT 4
99828: PUSH
99829: EMPTY
99830: LIST
99831: LIST
99832: LIST
99833: LIST
99834: IN
99835: IFFALSE 99857
// SetClass ( un , rand ( 1 , 4 ) ) ;
99837: LD_VAR 0 1
99841: PPUSH
99842: LD_INT 1
99844: PPUSH
99845: LD_INT 4
99847: PPUSH
99848: CALL_OW 12
99852: PPUSH
99853: CALL_OW 336
99857: GO 99804
99859: POP
99860: POP
// end ;
99861: PPOPN 1
99863: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
99864: LD_EXP 98
99868: PUSH
99869: LD_EXP 110
99873: AND
99874: IFFALSE 99953
99876: GO 99878
99878: DISABLE
99879: LD_INT 0
99881: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
99882: LD_ADDR_VAR 0 1
99886: PUSH
99887: LD_INT 22
99889: PUSH
99890: LD_OWVAR 2
99894: PUSH
99895: EMPTY
99896: LIST
99897: LIST
99898: PUSH
99899: LD_INT 21
99901: PUSH
99902: LD_INT 3
99904: PUSH
99905: EMPTY
99906: LIST
99907: LIST
99908: PUSH
99909: EMPTY
99910: LIST
99911: LIST
99912: PPUSH
99913: CALL_OW 69
99917: ST_TO_ADDR
// if not tmp then
99918: LD_VAR 0 1
99922: NOT
99923: IFFALSE 99927
// exit ;
99925: GO 99953
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
99927: LD_VAR 0 1
99931: PUSH
99932: LD_INT 1
99934: PPUSH
99935: LD_VAR 0 1
99939: PPUSH
99940: CALL_OW 12
99944: ARRAY
99945: PPUSH
99946: LD_INT 100
99948: PPUSH
99949: CALL_OW 234
// end ;
99953: PPOPN 1
99955: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
99956: LD_EXP 98
99960: PUSH
99961: LD_EXP 112
99965: AND
99966: IFFALSE 100064
99968: GO 99970
99970: DISABLE
99971: LD_INT 0
99973: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99974: LD_ADDR_VAR 0 1
99978: PUSH
99979: LD_INT 22
99981: PUSH
99982: LD_OWVAR 2
99986: PUSH
99987: EMPTY
99988: LIST
99989: LIST
99990: PUSH
99991: LD_INT 21
99993: PUSH
99994: LD_INT 1
99996: PUSH
99997: EMPTY
99998: LIST
99999: LIST
100000: PUSH
100001: EMPTY
100002: LIST
100003: LIST
100004: PPUSH
100005: CALL_OW 69
100009: ST_TO_ADDR
// if not tmp then
100010: LD_VAR 0 1
100014: NOT
100015: IFFALSE 100019
// exit ;
100017: GO 100064
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
100019: LD_VAR 0 1
100023: PUSH
100024: LD_INT 1
100026: PPUSH
100027: LD_VAR 0 1
100031: PPUSH
100032: CALL_OW 12
100036: ARRAY
100037: PPUSH
100038: LD_INT 1
100040: PPUSH
100041: LD_INT 4
100043: PPUSH
100044: CALL_OW 12
100048: PPUSH
100049: LD_INT 3000
100051: PPUSH
100052: LD_INT 9000
100054: PPUSH
100055: CALL_OW 12
100059: PPUSH
100060: CALL_OW 492
// end ;
100064: PPOPN 1
100066: END
// every 0 0$1 trigger StreamModeActive and sDepot do
100067: LD_EXP 98
100071: PUSH
100072: LD_EXP 113
100076: AND
100077: IFFALSE 100097
100079: GO 100081
100081: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
100082: LD_INT 1
100084: PPUSH
100085: LD_OWVAR 2
100089: PPUSH
100090: LD_INT 0
100092: PPUSH
100093: CALL_OW 324
100097: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
100098: LD_EXP 98
100102: PUSH
100103: LD_EXP 114
100107: AND
100108: IFFALSE 100191
100110: GO 100112
100112: DISABLE
100113: LD_INT 0
100115: PPUSH
100116: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
100117: LD_ADDR_VAR 0 2
100121: PUSH
100122: LD_INT 22
100124: PUSH
100125: LD_OWVAR 2
100129: PUSH
100130: EMPTY
100131: LIST
100132: LIST
100133: PUSH
100134: LD_INT 21
100136: PUSH
100137: LD_INT 3
100139: PUSH
100140: EMPTY
100141: LIST
100142: LIST
100143: PUSH
100144: EMPTY
100145: LIST
100146: LIST
100147: PPUSH
100148: CALL_OW 69
100152: ST_TO_ADDR
// if not tmp then
100153: LD_VAR 0 2
100157: NOT
100158: IFFALSE 100162
// exit ;
100160: GO 100191
// for i in tmp do
100162: LD_ADDR_VAR 0 1
100166: PUSH
100167: LD_VAR 0 2
100171: PUSH
100172: FOR_IN
100173: IFFALSE 100189
// SetBLevel ( i , 10 ) ;
100175: LD_VAR 0 1
100179: PPUSH
100180: LD_INT 10
100182: PPUSH
100183: CALL_OW 241
100187: GO 100172
100189: POP
100190: POP
// end ;
100191: PPOPN 2
100193: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
100194: LD_EXP 98
100198: PUSH
100199: LD_EXP 115
100203: AND
100204: IFFALSE 100315
100206: GO 100208
100208: DISABLE
100209: LD_INT 0
100211: PPUSH
100212: PPUSH
100213: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100214: LD_ADDR_VAR 0 3
100218: PUSH
100219: LD_INT 22
100221: PUSH
100222: LD_OWVAR 2
100226: PUSH
100227: EMPTY
100228: LIST
100229: LIST
100230: PUSH
100231: LD_INT 25
100233: PUSH
100234: LD_INT 1
100236: PUSH
100237: EMPTY
100238: LIST
100239: LIST
100240: PUSH
100241: EMPTY
100242: LIST
100243: LIST
100244: PPUSH
100245: CALL_OW 69
100249: ST_TO_ADDR
// if not tmp then
100250: LD_VAR 0 3
100254: NOT
100255: IFFALSE 100259
// exit ;
100257: GO 100315
// un := tmp [ rand ( 1 , tmp ) ] ;
100259: LD_ADDR_VAR 0 2
100263: PUSH
100264: LD_VAR 0 3
100268: PUSH
100269: LD_INT 1
100271: PPUSH
100272: LD_VAR 0 3
100276: PPUSH
100277: CALL_OW 12
100281: ARRAY
100282: ST_TO_ADDR
// if Crawls ( un ) then
100283: LD_VAR 0 2
100287: PPUSH
100288: CALL_OW 318
100292: IFFALSE 100303
// ComWalk ( un ) ;
100294: LD_VAR 0 2
100298: PPUSH
100299: CALL_OW 138
// SetClass ( un , class_sniper ) ;
100303: LD_VAR 0 2
100307: PPUSH
100308: LD_INT 5
100310: PPUSH
100311: CALL_OW 336
// end ;
100315: PPOPN 3
100317: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
100318: LD_EXP 98
100322: PUSH
100323: LD_EXP 116
100327: AND
100328: PUSH
100329: LD_OWVAR 67
100333: PUSH
100334: LD_INT 4
100336: LESS
100337: AND
100338: IFFALSE 100357
100340: GO 100342
100342: DISABLE
// begin Difficulty := Difficulty + 1 ;
100343: LD_ADDR_OWVAR 67
100347: PUSH
100348: LD_OWVAR 67
100352: PUSH
100353: LD_INT 1
100355: PLUS
100356: ST_TO_ADDR
// end ;
100357: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
100358: LD_EXP 98
100362: PUSH
100363: LD_EXP 117
100367: AND
100368: IFFALSE 100471
100370: GO 100372
100372: DISABLE
100373: LD_INT 0
100375: PPUSH
// begin for i := 1 to 5 do
100376: LD_ADDR_VAR 0 1
100380: PUSH
100381: DOUBLE
100382: LD_INT 1
100384: DEC
100385: ST_TO_ADDR
100386: LD_INT 5
100388: PUSH
100389: FOR_TO
100390: IFFALSE 100469
// begin uc_nation := nation_nature ;
100392: LD_ADDR_OWVAR 21
100396: PUSH
100397: LD_INT 0
100399: ST_TO_ADDR
// uc_side := 0 ;
100400: LD_ADDR_OWVAR 20
100404: PUSH
100405: LD_INT 0
100407: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
100408: LD_ADDR_OWVAR 29
100412: PUSH
100413: LD_INT 12
100415: PUSH
100416: LD_INT 12
100418: PUSH
100419: EMPTY
100420: LIST
100421: LIST
100422: ST_TO_ADDR
// hc_agressivity := 20 ;
100423: LD_ADDR_OWVAR 35
100427: PUSH
100428: LD_INT 20
100430: ST_TO_ADDR
// hc_class := class_tiger ;
100431: LD_ADDR_OWVAR 28
100435: PUSH
100436: LD_INT 14
100438: ST_TO_ADDR
// hc_gallery :=  ;
100439: LD_ADDR_OWVAR 33
100443: PUSH
100444: LD_STRING 
100446: ST_TO_ADDR
// hc_name :=  ;
100447: LD_ADDR_OWVAR 26
100451: PUSH
100452: LD_STRING 
100454: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
100455: CALL_OW 44
100459: PPUSH
100460: LD_INT 0
100462: PPUSH
100463: CALL_OW 51
// end ;
100467: GO 100389
100469: POP
100470: POP
// end ;
100471: PPOPN 1
100473: END
// every 0 0$1 trigger StreamModeActive and sBomb do
100474: LD_EXP 98
100478: PUSH
100479: LD_EXP 118
100483: AND
100484: IFFALSE 100493
100486: GO 100488
100488: DISABLE
// StreamSibBomb ;
100489: CALL 100494 0 0
100493: END
// export function StreamSibBomb ; var i , x , y ; begin
100494: LD_INT 0
100496: PPUSH
100497: PPUSH
100498: PPUSH
100499: PPUSH
// result := false ;
100500: LD_ADDR_VAR 0 1
100504: PUSH
100505: LD_INT 0
100507: ST_TO_ADDR
// for i := 1 to 16 do
100508: LD_ADDR_VAR 0 2
100512: PUSH
100513: DOUBLE
100514: LD_INT 1
100516: DEC
100517: ST_TO_ADDR
100518: LD_INT 16
100520: PUSH
100521: FOR_TO
100522: IFFALSE 100721
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
100524: LD_ADDR_VAR 0 3
100528: PUSH
100529: LD_INT 10
100531: PUSH
100532: LD_INT 20
100534: PUSH
100535: LD_INT 30
100537: PUSH
100538: LD_INT 40
100540: PUSH
100541: LD_INT 50
100543: PUSH
100544: LD_INT 60
100546: PUSH
100547: LD_INT 70
100549: PUSH
100550: LD_INT 80
100552: PUSH
100553: LD_INT 90
100555: PUSH
100556: LD_INT 100
100558: PUSH
100559: LD_INT 110
100561: PUSH
100562: LD_INT 120
100564: PUSH
100565: LD_INT 130
100567: PUSH
100568: LD_INT 140
100570: PUSH
100571: LD_INT 150
100573: PUSH
100574: EMPTY
100575: LIST
100576: LIST
100577: LIST
100578: LIST
100579: LIST
100580: LIST
100581: LIST
100582: LIST
100583: LIST
100584: LIST
100585: LIST
100586: LIST
100587: LIST
100588: LIST
100589: LIST
100590: PUSH
100591: LD_INT 1
100593: PPUSH
100594: LD_INT 15
100596: PPUSH
100597: CALL_OW 12
100601: ARRAY
100602: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
100603: LD_ADDR_VAR 0 4
100607: PUSH
100608: LD_INT 10
100610: PUSH
100611: LD_INT 20
100613: PUSH
100614: LD_INT 30
100616: PUSH
100617: LD_INT 40
100619: PUSH
100620: LD_INT 50
100622: PUSH
100623: LD_INT 60
100625: PUSH
100626: LD_INT 70
100628: PUSH
100629: LD_INT 80
100631: PUSH
100632: LD_INT 90
100634: PUSH
100635: LD_INT 100
100637: PUSH
100638: LD_INT 110
100640: PUSH
100641: LD_INT 120
100643: PUSH
100644: LD_INT 130
100646: PUSH
100647: LD_INT 140
100649: PUSH
100650: LD_INT 150
100652: PUSH
100653: EMPTY
100654: LIST
100655: LIST
100656: LIST
100657: LIST
100658: LIST
100659: LIST
100660: LIST
100661: LIST
100662: LIST
100663: LIST
100664: LIST
100665: LIST
100666: LIST
100667: LIST
100668: LIST
100669: PUSH
100670: LD_INT 1
100672: PPUSH
100673: LD_INT 15
100675: PPUSH
100676: CALL_OW 12
100680: ARRAY
100681: ST_TO_ADDR
// if ValidHex ( x , y ) then
100682: LD_VAR 0 3
100686: PPUSH
100687: LD_VAR 0 4
100691: PPUSH
100692: CALL_OW 488
100696: IFFALSE 100719
// begin result := [ x , y ] ;
100698: LD_ADDR_VAR 0 1
100702: PUSH
100703: LD_VAR 0 3
100707: PUSH
100708: LD_VAR 0 4
100712: PUSH
100713: EMPTY
100714: LIST
100715: LIST
100716: ST_TO_ADDR
// break ;
100717: GO 100721
// end ; end ;
100719: GO 100521
100721: POP
100722: POP
// if result then
100723: LD_VAR 0 1
100727: IFFALSE 100787
// begin ToLua ( playSibBomb() ) ;
100729: LD_STRING playSibBomb()
100731: PPUSH
100732: CALL_OW 559
// wait ( 0 0$14 ) ;
100736: LD_INT 490
100738: PPUSH
100739: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
100743: LD_VAR 0 1
100747: PUSH
100748: LD_INT 1
100750: ARRAY
100751: PPUSH
100752: LD_VAR 0 1
100756: PUSH
100757: LD_INT 2
100759: ARRAY
100760: PPUSH
100761: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
100765: LD_VAR 0 1
100769: PUSH
100770: LD_INT 1
100772: ARRAY
100773: PPUSH
100774: LD_VAR 0 1
100778: PUSH
100779: LD_INT 2
100781: ARRAY
100782: PPUSH
100783: CALL_OW 429
// end ; end ;
100787: LD_VAR 0 1
100791: RET
// every 0 0$1 trigger StreamModeActive and sReset do
100792: LD_EXP 98
100796: PUSH
100797: LD_EXP 120
100801: AND
100802: IFFALSE 100814
100804: GO 100806
100806: DISABLE
// YouLost (  ) ;
100807: LD_STRING 
100809: PPUSH
100810: CALL_OW 104
100814: END
// every 0 0$1 trigger StreamModeActive and sFog do
100815: LD_EXP 98
100819: PUSH
100820: LD_EXP 119
100824: AND
100825: IFFALSE 100839
100827: GO 100829
100829: DISABLE
// FogOff ( your_side ) ;
100830: LD_OWVAR 2
100834: PPUSH
100835: CALL_OW 344
100839: END
// every 0 0$1 trigger StreamModeActive and sSun do
100840: LD_EXP 98
100844: PUSH
100845: LD_EXP 121
100849: AND
100850: IFFALSE 100878
100852: GO 100854
100854: DISABLE
// begin solar_recharge_percent := 0 ;
100855: LD_ADDR_OWVAR 79
100859: PUSH
100860: LD_INT 0
100862: ST_TO_ADDR
// wait ( 5 5$00 ) ;
100863: LD_INT 10500
100865: PPUSH
100866: CALL_OW 67
// solar_recharge_percent := 100 ;
100870: LD_ADDR_OWVAR 79
100874: PUSH
100875: LD_INT 100
100877: ST_TO_ADDR
// end ;
100878: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
100879: LD_EXP 98
100883: PUSH
100884: LD_EXP 122
100888: AND
100889: IFFALSE 101128
100891: GO 100893
100893: DISABLE
100894: LD_INT 0
100896: PPUSH
100897: PPUSH
100898: PPUSH
// begin tmp := [ ] ;
100899: LD_ADDR_VAR 0 3
100903: PUSH
100904: EMPTY
100905: ST_TO_ADDR
// for i := 1 to 6 do
100906: LD_ADDR_VAR 0 1
100910: PUSH
100911: DOUBLE
100912: LD_INT 1
100914: DEC
100915: ST_TO_ADDR
100916: LD_INT 6
100918: PUSH
100919: FOR_TO
100920: IFFALSE 101025
// begin uc_nation := nation_nature ;
100922: LD_ADDR_OWVAR 21
100926: PUSH
100927: LD_INT 0
100929: ST_TO_ADDR
// uc_side := 0 ;
100930: LD_ADDR_OWVAR 20
100934: PUSH
100935: LD_INT 0
100937: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
100938: LD_ADDR_OWVAR 29
100942: PUSH
100943: LD_INT 12
100945: PUSH
100946: LD_INT 12
100948: PUSH
100949: EMPTY
100950: LIST
100951: LIST
100952: ST_TO_ADDR
// hc_agressivity := 20 ;
100953: LD_ADDR_OWVAR 35
100957: PUSH
100958: LD_INT 20
100960: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
100961: LD_ADDR_OWVAR 28
100965: PUSH
100966: LD_INT 17
100968: ST_TO_ADDR
// hc_gallery :=  ;
100969: LD_ADDR_OWVAR 33
100973: PUSH
100974: LD_STRING 
100976: ST_TO_ADDR
// hc_name :=  ;
100977: LD_ADDR_OWVAR 26
100981: PUSH
100982: LD_STRING 
100984: ST_TO_ADDR
// un := CreateHuman ;
100985: LD_ADDR_VAR 0 2
100989: PUSH
100990: CALL_OW 44
100994: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
100995: LD_VAR 0 2
100999: PPUSH
101000: LD_INT 1
101002: PPUSH
101003: CALL_OW 51
// tmp := tmp ^ un ;
101007: LD_ADDR_VAR 0 3
101011: PUSH
101012: LD_VAR 0 3
101016: PUSH
101017: LD_VAR 0 2
101021: ADD
101022: ST_TO_ADDR
// end ;
101023: GO 100919
101025: POP
101026: POP
// repeat wait ( 0 0$1 ) ;
101027: LD_INT 35
101029: PPUSH
101030: CALL_OW 67
// for un in tmp do
101034: LD_ADDR_VAR 0 2
101038: PUSH
101039: LD_VAR 0 3
101043: PUSH
101044: FOR_IN
101045: IFFALSE 101119
// begin if IsDead ( un ) then
101047: LD_VAR 0 2
101051: PPUSH
101052: CALL_OW 301
101056: IFFALSE 101076
// begin tmp := tmp diff un ;
101058: LD_ADDR_VAR 0 3
101062: PUSH
101063: LD_VAR 0 3
101067: PUSH
101068: LD_VAR 0 2
101072: DIFF
101073: ST_TO_ADDR
// continue ;
101074: GO 101044
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
101076: LD_VAR 0 2
101080: PPUSH
101081: LD_INT 3
101083: PUSH
101084: LD_INT 22
101086: PUSH
101087: LD_INT 0
101089: PUSH
101090: EMPTY
101091: LIST
101092: LIST
101093: PUSH
101094: EMPTY
101095: LIST
101096: LIST
101097: PPUSH
101098: CALL_OW 69
101102: PPUSH
101103: LD_VAR 0 2
101107: PPUSH
101108: CALL_OW 74
101112: PPUSH
101113: CALL_OW 115
// end ;
101117: GO 101044
101119: POP
101120: POP
// until not tmp ;
101121: LD_VAR 0 3
101125: NOT
101126: IFFALSE 101027
// end ;
101128: PPOPN 3
101130: END
// every 0 0$1 trigger StreamModeActive and sTroll do
101131: LD_EXP 98
101135: PUSH
101136: LD_EXP 123
101140: AND
101141: IFFALSE 101195
101143: GO 101145
101145: DISABLE
// begin ToLua ( displayTroll(); ) ;
101146: LD_STRING displayTroll();
101148: PPUSH
101149: CALL_OW 559
// wait ( 3 3$00 ) ;
101153: LD_INT 6300
101155: PPUSH
101156: CALL_OW 67
// ToLua ( hideTroll(); ) ;
101160: LD_STRING hideTroll();
101162: PPUSH
101163: CALL_OW 559
// wait ( 1 1$00 ) ;
101167: LD_INT 2100
101169: PPUSH
101170: CALL_OW 67
// ToLua ( displayTroll(); ) ;
101174: LD_STRING displayTroll();
101176: PPUSH
101177: CALL_OW 559
// wait ( 1 1$00 ) ;
101181: LD_INT 2100
101183: PPUSH
101184: CALL_OW 67
// ToLua ( hideTroll(); ) ;
101188: LD_STRING hideTroll();
101190: PPUSH
101191: CALL_OW 559
// end ;
101195: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
101196: LD_EXP 98
101200: PUSH
101201: LD_EXP 124
101205: AND
101206: IFFALSE 101269
101208: GO 101210
101210: DISABLE
101211: LD_INT 0
101213: PPUSH
// begin p := 0 ;
101214: LD_ADDR_VAR 0 1
101218: PUSH
101219: LD_INT 0
101221: ST_TO_ADDR
// repeat game_speed := 1 ;
101222: LD_ADDR_OWVAR 65
101226: PUSH
101227: LD_INT 1
101229: ST_TO_ADDR
// wait ( 0 0$1 ) ;
101230: LD_INT 35
101232: PPUSH
101233: CALL_OW 67
// p := p + 1 ;
101237: LD_ADDR_VAR 0 1
101241: PUSH
101242: LD_VAR 0 1
101246: PUSH
101247: LD_INT 1
101249: PLUS
101250: ST_TO_ADDR
// until p >= 60 ;
101251: LD_VAR 0 1
101255: PUSH
101256: LD_INT 60
101258: GREATEREQUAL
101259: IFFALSE 101222
// game_speed := 4 ;
101261: LD_ADDR_OWVAR 65
101265: PUSH
101266: LD_INT 4
101268: ST_TO_ADDR
// end ;
101269: PPOPN 1
101271: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
101272: LD_EXP 98
101276: PUSH
101277: LD_EXP 125
101281: AND
101282: IFFALSE 101428
101284: GO 101286
101286: DISABLE
101287: LD_INT 0
101289: PPUSH
101290: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
101291: LD_ADDR_VAR 0 1
101295: PUSH
101296: LD_INT 22
101298: PUSH
101299: LD_OWVAR 2
101303: PUSH
101304: EMPTY
101305: LIST
101306: LIST
101307: PUSH
101308: LD_INT 2
101310: PUSH
101311: LD_INT 30
101313: PUSH
101314: LD_INT 0
101316: PUSH
101317: EMPTY
101318: LIST
101319: LIST
101320: PUSH
101321: LD_INT 30
101323: PUSH
101324: LD_INT 1
101326: PUSH
101327: EMPTY
101328: LIST
101329: LIST
101330: PUSH
101331: EMPTY
101332: LIST
101333: LIST
101334: LIST
101335: PUSH
101336: EMPTY
101337: LIST
101338: LIST
101339: PPUSH
101340: CALL_OW 69
101344: ST_TO_ADDR
// if not depot then
101345: LD_VAR 0 1
101349: NOT
101350: IFFALSE 101354
// exit ;
101352: GO 101428
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
101354: LD_ADDR_VAR 0 2
101358: PUSH
101359: LD_VAR 0 1
101363: PUSH
101364: LD_INT 1
101366: PPUSH
101367: LD_VAR 0 1
101371: PPUSH
101372: CALL_OW 12
101376: ARRAY
101377: PPUSH
101378: CALL_OW 274
101382: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
101383: LD_VAR 0 2
101387: PPUSH
101388: LD_INT 1
101390: PPUSH
101391: LD_INT 0
101393: PPUSH
101394: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
101398: LD_VAR 0 2
101402: PPUSH
101403: LD_INT 2
101405: PPUSH
101406: LD_INT 0
101408: PPUSH
101409: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
101413: LD_VAR 0 2
101417: PPUSH
101418: LD_INT 3
101420: PPUSH
101421: LD_INT 0
101423: PPUSH
101424: CALL_OW 277
// end ;
101428: PPOPN 2
101430: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
101431: LD_EXP 98
101435: PUSH
101436: LD_EXP 126
101440: AND
101441: IFFALSE 101538
101443: GO 101445
101445: DISABLE
101446: LD_INT 0
101448: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
101449: LD_ADDR_VAR 0 1
101453: PUSH
101454: LD_INT 22
101456: PUSH
101457: LD_OWVAR 2
101461: PUSH
101462: EMPTY
101463: LIST
101464: LIST
101465: PUSH
101466: LD_INT 21
101468: PUSH
101469: LD_INT 1
101471: PUSH
101472: EMPTY
101473: LIST
101474: LIST
101475: PUSH
101476: LD_INT 3
101478: PUSH
101479: LD_INT 23
101481: PUSH
101482: LD_INT 0
101484: PUSH
101485: EMPTY
101486: LIST
101487: LIST
101488: PUSH
101489: EMPTY
101490: LIST
101491: LIST
101492: PUSH
101493: EMPTY
101494: LIST
101495: LIST
101496: LIST
101497: PPUSH
101498: CALL_OW 69
101502: ST_TO_ADDR
// if not tmp then
101503: LD_VAR 0 1
101507: NOT
101508: IFFALSE 101512
// exit ;
101510: GO 101538
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
101512: LD_VAR 0 1
101516: PUSH
101517: LD_INT 1
101519: PPUSH
101520: LD_VAR 0 1
101524: PPUSH
101525: CALL_OW 12
101529: ARRAY
101530: PPUSH
101531: LD_INT 200
101533: PPUSH
101534: CALL_OW 234
// end ;
101538: PPOPN 1
101540: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
101541: LD_EXP 98
101545: PUSH
101546: LD_EXP 127
101550: AND
101551: IFFALSE 101630
101553: GO 101555
101555: DISABLE
101556: LD_INT 0
101558: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
101559: LD_ADDR_VAR 0 1
101563: PUSH
101564: LD_INT 22
101566: PUSH
101567: LD_OWVAR 2
101571: PUSH
101572: EMPTY
101573: LIST
101574: LIST
101575: PUSH
101576: LD_INT 21
101578: PUSH
101579: LD_INT 2
101581: PUSH
101582: EMPTY
101583: LIST
101584: LIST
101585: PUSH
101586: EMPTY
101587: LIST
101588: LIST
101589: PPUSH
101590: CALL_OW 69
101594: ST_TO_ADDR
// if not tmp then
101595: LD_VAR 0 1
101599: NOT
101600: IFFALSE 101604
// exit ;
101602: GO 101630
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
101604: LD_VAR 0 1
101608: PUSH
101609: LD_INT 1
101611: PPUSH
101612: LD_VAR 0 1
101616: PPUSH
101617: CALL_OW 12
101621: ARRAY
101622: PPUSH
101623: LD_INT 60
101625: PPUSH
101626: CALL_OW 234
// end ;
101630: PPOPN 1
101632: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
101633: LD_EXP 98
101637: PUSH
101638: LD_EXP 128
101642: AND
101643: IFFALSE 101742
101645: GO 101647
101647: DISABLE
101648: LD_INT 0
101650: PPUSH
101651: PPUSH
// begin enable ;
101652: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
101653: LD_ADDR_VAR 0 1
101657: PUSH
101658: LD_INT 22
101660: PUSH
101661: LD_OWVAR 2
101665: PUSH
101666: EMPTY
101667: LIST
101668: LIST
101669: PUSH
101670: LD_INT 61
101672: PUSH
101673: EMPTY
101674: LIST
101675: PUSH
101676: LD_INT 33
101678: PUSH
101679: LD_INT 2
101681: PUSH
101682: EMPTY
101683: LIST
101684: LIST
101685: PUSH
101686: EMPTY
101687: LIST
101688: LIST
101689: LIST
101690: PPUSH
101691: CALL_OW 69
101695: ST_TO_ADDR
// if not tmp then
101696: LD_VAR 0 1
101700: NOT
101701: IFFALSE 101705
// exit ;
101703: GO 101742
// for i in tmp do
101705: LD_ADDR_VAR 0 2
101709: PUSH
101710: LD_VAR 0 1
101714: PUSH
101715: FOR_IN
101716: IFFALSE 101740
// if IsControledBy ( i ) then
101718: LD_VAR 0 2
101722: PPUSH
101723: CALL_OW 312
101727: IFFALSE 101738
// ComUnlink ( i ) ;
101729: LD_VAR 0 2
101733: PPUSH
101734: CALL_OW 136
101738: GO 101715
101740: POP
101741: POP
// end ;
101742: PPOPN 2
101744: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
101745: LD_EXP 98
101749: PUSH
101750: LD_EXP 129
101754: AND
101755: IFFALSE 101895
101757: GO 101759
101759: DISABLE
101760: LD_INT 0
101762: PPUSH
101763: PPUSH
// begin ToLua ( displayPowell(); ) ;
101764: LD_STRING displayPowell();
101766: PPUSH
101767: CALL_OW 559
// uc_side := 0 ;
101771: LD_ADDR_OWVAR 20
101775: PUSH
101776: LD_INT 0
101778: ST_TO_ADDR
// uc_nation := 2 ;
101779: LD_ADDR_OWVAR 21
101783: PUSH
101784: LD_INT 2
101786: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
101787: LD_ADDR_OWVAR 37
101791: PUSH
101792: LD_INT 14
101794: ST_TO_ADDR
// vc_engine := engine_siberite ;
101795: LD_ADDR_OWVAR 39
101799: PUSH
101800: LD_INT 3
101802: ST_TO_ADDR
// vc_control := control_apeman ;
101803: LD_ADDR_OWVAR 38
101807: PUSH
101808: LD_INT 5
101810: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
101811: LD_ADDR_OWVAR 40
101815: PUSH
101816: LD_INT 29
101818: ST_TO_ADDR
// un := CreateVehicle ;
101819: LD_ADDR_VAR 0 2
101823: PUSH
101824: CALL_OW 45
101828: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101829: LD_VAR 0 2
101833: PPUSH
101834: LD_INT 1
101836: PPUSH
101837: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
101841: LD_INT 35
101843: PPUSH
101844: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
101848: LD_VAR 0 2
101852: PPUSH
101853: LD_INT 22
101855: PUSH
101856: LD_OWVAR 2
101860: PUSH
101861: EMPTY
101862: LIST
101863: LIST
101864: PPUSH
101865: CALL_OW 69
101869: PPUSH
101870: LD_VAR 0 2
101874: PPUSH
101875: CALL_OW 74
101879: PPUSH
101880: CALL_OW 115
// until IsDead ( un ) ;
101884: LD_VAR 0 2
101888: PPUSH
101889: CALL_OW 301
101893: IFFALSE 101841
// end ;
101895: PPOPN 2
101897: END
// every 0 0$1 trigger StreamModeActive and sStu do
101898: LD_EXP 98
101902: PUSH
101903: LD_EXP 137
101907: AND
101908: IFFALSE 101924
101910: GO 101912
101912: DISABLE
// begin ToLua ( displayStucuk(); ) ;
101913: LD_STRING displayStucuk();
101915: PPUSH
101916: CALL_OW 559
// ResetFog ;
101920: CALL_OW 335
// end ;
101924: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
101925: LD_EXP 98
101929: PUSH
101930: LD_EXP 130
101934: AND
101935: IFFALSE 102076
101937: GO 101939
101939: DISABLE
101940: LD_INT 0
101942: PPUSH
101943: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101944: LD_ADDR_VAR 0 2
101948: PUSH
101949: LD_INT 22
101951: PUSH
101952: LD_OWVAR 2
101956: PUSH
101957: EMPTY
101958: LIST
101959: LIST
101960: PUSH
101961: LD_INT 21
101963: PUSH
101964: LD_INT 1
101966: PUSH
101967: EMPTY
101968: LIST
101969: LIST
101970: PUSH
101971: EMPTY
101972: LIST
101973: LIST
101974: PPUSH
101975: CALL_OW 69
101979: ST_TO_ADDR
// if not tmp then
101980: LD_VAR 0 2
101984: NOT
101985: IFFALSE 101989
// exit ;
101987: GO 102076
// un := tmp [ rand ( 1 , tmp ) ] ;
101989: LD_ADDR_VAR 0 1
101993: PUSH
101994: LD_VAR 0 2
101998: PUSH
101999: LD_INT 1
102001: PPUSH
102002: LD_VAR 0 2
102006: PPUSH
102007: CALL_OW 12
102011: ARRAY
102012: ST_TO_ADDR
// SetSide ( un , 0 ) ;
102013: LD_VAR 0 1
102017: PPUSH
102018: LD_INT 0
102020: PPUSH
102021: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
102025: LD_VAR 0 1
102029: PPUSH
102030: LD_OWVAR 3
102034: PUSH
102035: LD_VAR 0 1
102039: DIFF
102040: PPUSH
102041: LD_VAR 0 1
102045: PPUSH
102046: CALL_OW 74
102050: PPUSH
102051: CALL_OW 115
// wait ( 0 0$20 ) ;
102055: LD_INT 700
102057: PPUSH
102058: CALL_OW 67
// SetSide ( un , your_side ) ;
102062: LD_VAR 0 1
102066: PPUSH
102067: LD_OWVAR 2
102071: PPUSH
102072: CALL_OW 235
// end ;
102076: PPOPN 2
102078: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
102079: LD_EXP 98
102083: PUSH
102084: LD_EXP 131
102088: AND
102089: IFFALSE 102195
102091: GO 102093
102093: DISABLE
102094: LD_INT 0
102096: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
102097: LD_ADDR_VAR 0 1
102101: PUSH
102102: LD_INT 22
102104: PUSH
102105: LD_OWVAR 2
102109: PUSH
102110: EMPTY
102111: LIST
102112: LIST
102113: PUSH
102114: LD_INT 2
102116: PUSH
102117: LD_INT 30
102119: PUSH
102120: LD_INT 0
102122: PUSH
102123: EMPTY
102124: LIST
102125: LIST
102126: PUSH
102127: LD_INT 30
102129: PUSH
102130: LD_INT 1
102132: PUSH
102133: EMPTY
102134: LIST
102135: LIST
102136: PUSH
102137: EMPTY
102138: LIST
102139: LIST
102140: LIST
102141: PUSH
102142: EMPTY
102143: LIST
102144: LIST
102145: PPUSH
102146: CALL_OW 69
102150: ST_TO_ADDR
// if not depot then
102151: LD_VAR 0 1
102155: NOT
102156: IFFALSE 102160
// exit ;
102158: GO 102195
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
102160: LD_VAR 0 1
102164: PUSH
102165: LD_INT 1
102167: ARRAY
102168: PPUSH
102169: CALL_OW 250
102173: PPUSH
102174: LD_VAR 0 1
102178: PUSH
102179: LD_INT 1
102181: ARRAY
102182: PPUSH
102183: CALL_OW 251
102187: PPUSH
102188: LD_INT 70
102190: PPUSH
102191: CALL_OW 495
// end ;
102195: PPOPN 1
102197: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
102198: LD_EXP 98
102202: PUSH
102203: LD_EXP 132
102207: AND
102208: IFFALSE 102419
102210: GO 102212
102212: DISABLE
102213: LD_INT 0
102215: PPUSH
102216: PPUSH
102217: PPUSH
102218: PPUSH
102219: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
102220: LD_ADDR_VAR 0 5
102224: PUSH
102225: LD_INT 22
102227: PUSH
102228: LD_OWVAR 2
102232: PUSH
102233: EMPTY
102234: LIST
102235: LIST
102236: PUSH
102237: LD_INT 21
102239: PUSH
102240: LD_INT 1
102242: PUSH
102243: EMPTY
102244: LIST
102245: LIST
102246: PUSH
102247: EMPTY
102248: LIST
102249: LIST
102250: PPUSH
102251: CALL_OW 69
102255: ST_TO_ADDR
// if not tmp then
102256: LD_VAR 0 5
102260: NOT
102261: IFFALSE 102265
// exit ;
102263: GO 102419
// for i in tmp do
102265: LD_ADDR_VAR 0 1
102269: PUSH
102270: LD_VAR 0 5
102274: PUSH
102275: FOR_IN
102276: IFFALSE 102417
// begin d := rand ( 0 , 5 ) ;
102278: LD_ADDR_VAR 0 4
102282: PUSH
102283: LD_INT 0
102285: PPUSH
102286: LD_INT 5
102288: PPUSH
102289: CALL_OW 12
102293: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
102294: LD_ADDR_VAR 0 2
102298: PUSH
102299: LD_VAR 0 1
102303: PPUSH
102304: CALL_OW 250
102308: PPUSH
102309: LD_VAR 0 4
102313: PPUSH
102314: LD_INT 3
102316: PPUSH
102317: LD_INT 12
102319: PPUSH
102320: CALL_OW 12
102324: PPUSH
102325: CALL_OW 272
102329: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
102330: LD_ADDR_VAR 0 3
102334: PUSH
102335: LD_VAR 0 1
102339: PPUSH
102340: CALL_OW 251
102344: PPUSH
102345: LD_VAR 0 4
102349: PPUSH
102350: LD_INT 3
102352: PPUSH
102353: LD_INT 12
102355: PPUSH
102356: CALL_OW 12
102360: PPUSH
102361: CALL_OW 273
102365: ST_TO_ADDR
// if ValidHex ( x , y ) then
102366: LD_VAR 0 2
102370: PPUSH
102371: LD_VAR 0 3
102375: PPUSH
102376: CALL_OW 488
102380: IFFALSE 102415
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
102382: LD_VAR 0 1
102386: PPUSH
102387: LD_VAR 0 2
102391: PPUSH
102392: LD_VAR 0 3
102396: PPUSH
102397: LD_INT 3
102399: PPUSH
102400: LD_INT 6
102402: PPUSH
102403: CALL_OW 12
102407: PPUSH
102408: LD_INT 1
102410: PPUSH
102411: CALL_OW 483
// end ;
102415: GO 102275
102417: POP
102418: POP
// end ;
102419: PPOPN 5
102421: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
102422: LD_EXP 98
102426: PUSH
102427: LD_EXP 133
102431: AND
102432: IFFALSE 102526
102434: GO 102436
102436: DISABLE
102437: LD_INT 0
102439: PPUSH
102440: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
102441: LD_ADDR_VAR 0 2
102445: PUSH
102446: LD_INT 22
102448: PUSH
102449: LD_OWVAR 2
102453: PUSH
102454: EMPTY
102455: LIST
102456: LIST
102457: PUSH
102458: LD_INT 32
102460: PUSH
102461: LD_INT 1
102463: PUSH
102464: EMPTY
102465: LIST
102466: LIST
102467: PUSH
102468: LD_INT 21
102470: PUSH
102471: LD_INT 2
102473: PUSH
102474: EMPTY
102475: LIST
102476: LIST
102477: PUSH
102478: EMPTY
102479: LIST
102480: LIST
102481: LIST
102482: PPUSH
102483: CALL_OW 69
102487: ST_TO_ADDR
// if not tmp then
102488: LD_VAR 0 2
102492: NOT
102493: IFFALSE 102497
// exit ;
102495: GO 102526
// for i in tmp do
102497: LD_ADDR_VAR 0 1
102501: PUSH
102502: LD_VAR 0 2
102506: PUSH
102507: FOR_IN
102508: IFFALSE 102524
// SetFuel ( i , 0 ) ;
102510: LD_VAR 0 1
102514: PPUSH
102515: LD_INT 0
102517: PPUSH
102518: CALL_OW 240
102522: GO 102507
102524: POP
102525: POP
// end ;
102526: PPOPN 2
102528: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
102529: LD_EXP 98
102533: PUSH
102534: LD_EXP 134
102538: AND
102539: IFFALSE 102605
102541: GO 102543
102543: DISABLE
102544: LD_INT 0
102546: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
102547: LD_ADDR_VAR 0 1
102551: PUSH
102552: LD_INT 22
102554: PUSH
102555: LD_OWVAR 2
102559: PUSH
102560: EMPTY
102561: LIST
102562: LIST
102563: PUSH
102564: LD_INT 30
102566: PUSH
102567: LD_INT 29
102569: PUSH
102570: EMPTY
102571: LIST
102572: LIST
102573: PUSH
102574: EMPTY
102575: LIST
102576: LIST
102577: PPUSH
102578: CALL_OW 69
102582: ST_TO_ADDR
// if not tmp then
102583: LD_VAR 0 1
102587: NOT
102588: IFFALSE 102592
// exit ;
102590: GO 102605
// DestroyUnit ( tmp [ 1 ] ) ;
102592: LD_VAR 0 1
102596: PUSH
102597: LD_INT 1
102599: ARRAY
102600: PPUSH
102601: CALL_OW 65
// end ;
102605: PPOPN 1
102607: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
102608: LD_EXP 98
102612: PUSH
102613: LD_EXP 136
102617: AND
102618: IFFALSE 102747
102620: GO 102622
102622: DISABLE
102623: LD_INT 0
102625: PPUSH
// begin uc_side := 0 ;
102626: LD_ADDR_OWVAR 20
102630: PUSH
102631: LD_INT 0
102633: ST_TO_ADDR
// uc_nation := nation_arabian ;
102634: LD_ADDR_OWVAR 21
102638: PUSH
102639: LD_INT 2
102641: ST_TO_ADDR
// hc_gallery :=  ;
102642: LD_ADDR_OWVAR 33
102646: PUSH
102647: LD_STRING 
102649: ST_TO_ADDR
// hc_name :=  ;
102650: LD_ADDR_OWVAR 26
102654: PUSH
102655: LD_STRING 
102657: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
102658: LD_INT 1
102660: PPUSH
102661: LD_INT 11
102663: PPUSH
102664: LD_INT 10
102666: PPUSH
102667: CALL_OW 380
// un := CreateHuman ;
102671: LD_ADDR_VAR 0 1
102675: PUSH
102676: CALL_OW 44
102680: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
102681: LD_VAR 0 1
102685: PPUSH
102686: LD_INT 1
102688: PPUSH
102689: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
102693: LD_INT 35
102695: PPUSH
102696: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
102700: LD_VAR 0 1
102704: PPUSH
102705: LD_INT 22
102707: PUSH
102708: LD_OWVAR 2
102712: PUSH
102713: EMPTY
102714: LIST
102715: LIST
102716: PPUSH
102717: CALL_OW 69
102721: PPUSH
102722: LD_VAR 0 1
102726: PPUSH
102727: CALL_OW 74
102731: PPUSH
102732: CALL_OW 115
// until IsDead ( un ) ;
102736: LD_VAR 0 1
102740: PPUSH
102741: CALL_OW 301
102745: IFFALSE 102693
// end ;
102747: PPOPN 1
102749: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
102750: LD_EXP 98
102754: PUSH
102755: LD_EXP 138
102759: AND
102760: IFFALSE 102772
102762: GO 102764
102764: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
102765: LD_STRING earthquake(getX(game), 0, 32)
102767: PPUSH
102768: CALL_OW 559
102772: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
102773: LD_EXP 98
102777: PUSH
102778: LD_EXP 139
102782: AND
102783: IFFALSE 102874
102785: GO 102787
102787: DISABLE
102788: LD_INT 0
102790: PPUSH
// begin enable ;
102791: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
102792: LD_ADDR_VAR 0 1
102796: PUSH
102797: LD_INT 22
102799: PUSH
102800: LD_OWVAR 2
102804: PUSH
102805: EMPTY
102806: LIST
102807: LIST
102808: PUSH
102809: LD_INT 21
102811: PUSH
102812: LD_INT 2
102814: PUSH
102815: EMPTY
102816: LIST
102817: LIST
102818: PUSH
102819: LD_INT 33
102821: PUSH
102822: LD_INT 3
102824: PUSH
102825: EMPTY
102826: LIST
102827: LIST
102828: PUSH
102829: EMPTY
102830: LIST
102831: LIST
102832: LIST
102833: PPUSH
102834: CALL_OW 69
102838: ST_TO_ADDR
// if not tmp then
102839: LD_VAR 0 1
102843: NOT
102844: IFFALSE 102848
// exit ;
102846: GO 102874
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
102848: LD_VAR 0 1
102852: PUSH
102853: LD_INT 1
102855: PPUSH
102856: LD_VAR 0 1
102860: PPUSH
102861: CALL_OW 12
102865: ARRAY
102866: PPUSH
102867: LD_INT 1
102869: PPUSH
102870: CALL_OW 234
// end ;
102874: PPOPN 1
102876: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
102877: LD_EXP 98
102881: PUSH
102882: LD_EXP 140
102886: AND
102887: IFFALSE 103028
102889: GO 102891
102891: DISABLE
102892: LD_INT 0
102894: PPUSH
102895: PPUSH
102896: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102897: LD_ADDR_VAR 0 3
102901: PUSH
102902: LD_INT 22
102904: PUSH
102905: LD_OWVAR 2
102909: PUSH
102910: EMPTY
102911: LIST
102912: LIST
102913: PUSH
102914: LD_INT 25
102916: PUSH
102917: LD_INT 1
102919: PUSH
102920: EMPTY
102921: LIST
102922: LIST
102923: PUSH
102924: EMPTY
102925: LIST
102926: LIST
102927: PPUSH
102928: CALL_OW 69
102932: ST_TO_ADDR
// if not tmp then
102933: LD_VAR 0 3
102937: NOT
102938: IFFALSE 102942
// exit ;
102940: GO 103028
// un := tmp [ rand ( 1 , tmp ) ] ;
102942: LD_ADDR_VAR 0 2
102946: PUSH
102947: LD_VAR 0 3
102951: PUSH
102952: LD_INT 1
102954: PPUSH
102955: LD_VAR 0 3
102959: PPUSH
102960: CALL_OW 12
102964: ARRAY
102965: ST_TO_ADDR
// if Crawls ( un ) then
102966: LD_VAR 0 2
102970: PPUSH
102971: CALL_OW 318
102975: IFFALSE 102986
// ComWalk ( un ) ;
102977: LD_VAR 0 2
102981: PPUSH
102982: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
102986: LD_VAR 0 2
102990: PPUSH
102991: LD_INT 9
102993: PPUSH
102994: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
102998: LD_INT 28
103000: PPUSH
103001: LD_OWVAR 2
103005: PPUSH
103006: LD_INT 2
103008: PPUSH
103009: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
103013: LD_INT 29
103015: PPUSH
103016: LD_OWVAR 2
103020: PPUSH
103021: LD_INT 2
103023: PPUSH
103024: CALL_OW 322
// end ;
103028: PPOPN 3
103030: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
103031: LD_EXP 98
103035: PUSH
103036: LD_EXP 141
103040: AND
103041: IFFALSE 103152
103043: GO 103045
103045: DISABLE
103046: LD_INT 0
103048: PPUSH
103049: PPUSH
103050: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103051: LD_ADDR_VAR 0 3
103055: PUSH
103056: LD_INT 22
103058: PUSH
103059: LD_OWVAR 2
103063: PUSH
103064: EMPTY
103065: LIST
103066: LIST
103067: PUSH
103068: LD_INT 25
103070: PUSH
103071: LD_INT 1
103073: PUSH
103074: EMPTY
103075: LIST
103076: LIST
103077: PUSH
103078: EMPTY
103079: LIST
103080: LIST
103081: PPUSH
103082: CALL_OW 69
103086: ST_TO_ADDR
// if not tmp then
103087: LD_VAR 0 3
103091: NOT
103092: IFFALSE 103096
// exit ;
103094: GO 103152
// un := tmp [ rand ( 1 , tmp ) ] ;
103096: LD_ADDR_VAR 0 2
103100: PUSH
103101: LD_VAR 0 3
103105: PUSH
103106: LD_INT 1
103108: PPUSH
103109: LD_VAR 0 3
103113: PPUSH
103114: CALL_OW 12
103118: ARRAY
103119: ST_TO_ADDR
// if Crawls ( un ) then
103120: LD_VAR 0 2
103124: PPUSH
103125: CALL_OW 318
103129: IFFALSE 103140
// ComWalk ( un ) ;
103131: LD_VAR 0 2
103135: PPUSH
103136: CALL_OW 138
// SetClass ( un , class_mortar ) ;
103140: LD_VAR 0 2
103144: PPUSH
103145: LD_INT 8
103147: PPUSH
103148: CALL_OW 336
// end ;
103152: PPOPN 3
103154: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
103155: LD_EXP 98
103159: PUSH
103160: LD_EXP 142
103164: AND
103165: IFFALSE 103309
103167: GO 103169
103169: DISABLE
103170: LD_INT 0
103172: PPUSH
103173: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
103174: LD_ADDR_VAR 0 2
103178: PUSH
103179: LD_INT 22
103181: PUSH
103182: LD_OWVAR 2
103186: PUSH
103187: EMPTY
103188: LIST
103189: LIST
103190: PUSH
103191: LD_INT 21
103193: PUSH
103194: LD_INT 2
103196: PUSH
103197: EMPTY
103198: LIST
103199: LIST
103200: PUSH
103201: LD_INT 2
103203: PUSH
103204: LD_INT 34
103206: PUSH
103207: LD_INT 12
103209: PUSH
103210: EMPTY
103211: LIST
103212: LIST
103213: PUSH
103214: LD_INT 34
103216: PUSH
103217: LD_INT 51
103219: PUSH
103220: EMPTY
103221: LIST
103222: LIST
103223: PUSH
103224: LD_INT 34
103226: PUSH
103227: LD_INT 32
103229: PUSH
103230: EMPTY
103231: LIST
103232: LIST
103233: PUSH
103234: EMPTY
103235: LIST
103236: LIST
103237: LIST
103238: LIST
103239: PUSH
103240: EMPTY
103241: LIST
103242: LIST
103243: LIST
103244: PPUSH
103245: CALL_OW 69
103249: ST_TO_ADDR
// if not tmp then
103250: LD_VAR 0 2
103254: NOT
103255: IFFALSE 103259
// exit ;
103257: GO 103309
// for i in tmp do
103259: LD_ADDR_VAR 0 1
103263: PUSH
103264: LD_VAR 0 2
103268: PUSH
103269: FOR_IN
103270: IFFALSE 103307
// if GetCargo ( i , mat_artifact ) = 0 then
103272: LD_VAR 0 1
103276: PPUSH
103277: LD_INT 4
103279: PPUSH
103280: CALL_OW 289
103284: PUSH
103285: LD_INT 0
103287: EQUAL
103288: IFFALSE 103305
// SetCargo ( i , mat_siberit , 100 ) ;
103290: LD_VAR 0 1
103294: PPUSH
103295: LD_INT 3
103297: PPUSH
103298: LD_INT 100
103300: PPUSH
103301: CALL_OW 290
103305: GO 103269
103307: POP
103308: POP
// end ;
103309: PPOPN 2
103311: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
103312: LD_EXP 98
103316: PUSH
103317: LD_EXP 143
103321: AND
103322: IFFALSE 103505
103324: GO 103326
103326: DISABLE
103327: LD_INT 0
103329: PPUSH
103330: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
103331: LD_ADDR_VAR 0 2
103335: PUSH
103336: LD_INT 22
103338: PUSH
103339: LD_OWVAR 2
103343: PUSH
103344: EMPTY
103345: LIST
103346: LIST
103347: PPUSH
103348: CALL_OW 69
103352: ST_TO_ADDR
// if not tmp then
103353: LD_VAR 0 2
103357: NOT
103358: IFFALSE 103362
// exit ;
103360: GO 103505
// for i := 1 to 2 do
103362: LD_ADDR_VAR 0 1
103366: PUSH
103367: DOUBLE
103368: LD_INT 1
103370: DEC
103371: ST_TO_ADDR
103372: LD_INT 2
103374: PUSH
103375: FOR_TO
103376: IFFALSE 103503
// begin uc_side := your_side ;
103378: LD_ADDR_OWVAR 20
103382: PUSH
103383: LD_OWVAR 2
103387: ST_TO_ADDR
// uc_nation := nation_american ;
103388: LD_ADDR_OWVAR 21
103392: PUSH
103393: LD_INT 1
103395: ST_TO_ADDR
// vc_chassis := us_morphling ;
103396: LD_ADDR_OWVAR 37
103400: PUSH
103401: LD_INT 5
103403: ST_TO_ADDR
// vc_engine := engine_siberite ;
103404: LD_ADDR_OWVAR 39
103408: PUSH
103409: LD_INT 3
103411: ST_TO_ADDR
// vc_control := control_computer ;
103412: LD_ADDR_OWVAR 38
103416: PUSH
103417: LD_INT 3
103419: ST_TO_ADDR
// vc_weapon := us_double_laser ;
103420: LD_ADDR_OWVAR 40
103424: PUSH
103425: LD_INT 10
103427: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
103428: LD_VAR 0 2
103432: PUSH
103433: LD_INT 1
103435: ARRAY
103436: PPUSH
103437: CALL_OW 310
103441: NOT
103442: IFFALSE 103489
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
103444: CALL_OW 45
103448: PPUSH
103449: LD_VAR 0 2
103453: PUSH
103454: LD_INT 1
103456: ARRAY
103457: PPUSH
103458: CALL_OW 250
103462: PPUSH
103463: LD_VAR 0 2
103467: PUSH
103468: LD_INT 1
103470: ARRAY
103471: PPUSH
103472: CALL_OW 251
103476: PPUSH
103477: LD_INT 12
103479: PPUSH
103480: LD_INT 1
103482: PPUSH
103483: CALL_OW 50
103487: GO 103501
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
103489: CALL_OW 45
103493: PPUSH
103494: LD_INT 1
103496: PPUSH
103497: CALL_OW 51
// end ;
103501: GO 103375
103503: POP
103504: POP
// end ;
103505: PPOPN 2
103507: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
103508: LD_EXP 98
103512: PUSH
103513: LD_EXP 144
103517: AND
103518: IFFALSE 103740
103520: GO 103522
103522: DISABLE
103523: LD_INT 0
103525: PPUSH
103526: PPUSH
103527: PPUSH
103528: PPUSH
103529: PPUSH
103530: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
103531: LD_ADDR_VAR 0 6
103535: PUSH
103536: LD_INT 22
103538: PUSH
103539: LD_OWVAR 2
103543: PUSH
103544: EMPTY
103545: LIST
103546: LIST
103547: PUSH
103548: LD_INT 21
103550: PUSH
103551: LD_INT 1
103553: PUSH
103554: EMPTY
103555: LIST
103556: LIST
103557: PUSH
103558: LD_INT 3
103560: PUSH
103561: LD_INT 23
103563: PUSH
103564: LD_INT 0
103566: PUSH
103567: EMPTY
103568: LIST
103569: LIST
103570: PUSH
103571: EMPTY
103572: LIST
103573: LIST
103574: PUSH
103575: EMPTY
103576: LIST
103577: LIST
103578: LIST
103579: PPUSH
103580: CALL_OW 69
103584: ST_TO_ADDR
// if not tmp then
103585: LD_VAR 0 6
103589: NOT
103590: IFFALSE 103594
// exit ;
103592: GO 103740
// s1 := rand ( 1 , 4 ) ;
103594: LD_ADDR_VAR 0 2
103598: PUSH
103599: LD_INT 1
103601: PPUSH
103602: LD_INT 4
103604: PPUSH
103605: CALL_OW 12
103609: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
103610: LD_ADDR_VAR 0 4
103614: PUSH
103615: LD_VAR 0 6
103619: PUSH
103620: LD_INT 1
103622: ARRAY
103623: PPUSH
103624: LD_VAR 0 2
103628: PPUSH
103629: CALL_OW 259
103633: ST_TO_ADDR
// if s1 = 1 then
103634: LD_VAR 0 2
103638: PUSH
103639: LD_INT 1
103641: EQUAL
103642: IFFALSE 103662
// s2 := rand ( 2 , 4 ) else
103644: LD_ADDR_VAR 0 3
103648: PUSH
103649: LD_INT 2
103651: PPUSH
103652: LD_INT 4
103654: PPUSH
103655: CALL_OW 12
103659: ST_TO_ADDR
103660: GO 103670
// s2 := 1 ;
103662: LD_ADDR_VAR 0 3
103666: PUSH
103667: LD_INT 1
103669: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
103670: LD_ADDR_VAR 0 5
103674: PUSH
103675: LD_VAR 0 6
103679: PUSH
103680: LD_INT 1
103682: ARRAY
103683: PPUSH
103684: LD_VAR 0 3
103688: PPUSH
103689: CALL_OW 259
103693: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
103694: LD_VAR 0 6
103698: PUSH
103699: LD_INT 1
103701: ARRAY
103702: PPUSH
103703: LD_VAR 0 2
103707: PPUSH
103708: LD_VAR 0 5
103712: PPUSH
103713: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
103717: LD_VAR 0 6
103721: PUSH
103722: LD_INT 1
103724: ARRAY
103725: PPUSH
103726: LD_VAR 0 3
103730: PPUSH
103731: LD_VAR 0 4
103735: PPUSH
103736: CALL_OW 237
// end ;
103740: PPOPN 6
103742: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
103743: LD_EXP 98
103747: PUSH
103748: LD_EXP 145
103752: AND
103753: IFFALSE 103832
103755: GO 103757
103757: DISABLE
103758: LD_INT 0
103760: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
103761: LD_ADDR_VAR 0 1
103765: PUSH
103766: LD_INT 22
103768: PUSH
103769: LD_OWVAR 2
103773: PUSH
103774: EMPTY
103775: LIST
103776: LIST
103777: PUSH
103778: LD_INT 30
103780: PUSH
103781: LD_INT 3
103783: PUSH
103784: EMPTY
103785: LIST
103786: LIST
103787: PUSH
103788: EMPTY
103789: LIST
103790: LIST
103791: PPUSH
103792: CALL_OW 69
103796: ST_TO_ADDR
// if not tmp then
103797: LD_VAR 0 1
103801: NOT
103802: IFFALSE 103806
// exit ;
103804: GO 103832
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
103806: LD_VAR 0 1
103810: PUSH
103811: LD_INT 1
103813: PPUSH
103814: LD_VAR 0 1
103818: PPUSH
103819: CALL_OW 12
103823: ARRAY
103824: PPUSH
103825: LD_INT 1
103827: PPUSH
103828: CALL_OW 234
// end ;
103832: PPOPN 1
103834: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
103835: LD_EXP 98
103839: PUSH
103840: LD_EXP 146
103844: AND
103845: IFFALSE 103957
103847: GO 103849
103849: DISABLE
103850: LD_INT 0
103852: PPUSH
103853: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
103854: LD_ADDR_VAR 0 2
103858: PUSH
103859: LD_INT 22
103861: PUSH
103862: LD_OWVAR 2
103866: PUSH
103867: EMPTY
103868: LIST
103869: LIST
103870: PUSH
103871: LD_INT 2
103873: PUSH
103874: LD_INT 30
103876: PUSH
103877: LD_INT 27
103879: PUSH
103880: EMPTY
103881: LIST
103882: LIST
103883: PUSH
103884: LD_INT 30
103886: PUSH
103887: LD_INT 26
103889: PUSH
103890: EMPTY
103891: LIST
103892: LIST
103893: PUSH
103894: LD_INT 30
103896: PUSH
103897: LD_INT 28
103899: PUSH
103900: EMPTY
103901: LIST
103902: LIST
103903: PUSH
103904: EMPTY
103905: LIST
103906: LIST
103907: LIST
103908: LIST
103909: PUSH
103910: EMPTY
103911: LIST
103912: LIST
103913: PPUSH
103914: CALL_OW 69
103918: ST_TO_ADDR
// if not tmp then
103919: LD_VAR 0 2
103923: NOT
103924: IFFALSE 103928
// exit ;
103926: GO 103957
// for i in tmp do
103928: LD_ADDR_VAR 0 1
103932: PUSH
103933: LD_VAR 0 2
103937: PUSH
103938: FOR_IN
103939: IFFALSE 103955
// SetLives ( i , 1 ) ;
103941: LD_VAR 0 1
103945: PPUSH
103946: LD_INT 1
103948: PPUSH
103949: CALL_OW 234
103953: GO 103938
103955: POP
103956: POP
// end ;
103957: PPOPN 2
103959: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
103960: LD_EXP 98
103964: PUSH
103965: LD_EXP 147
103969: AND
103970: IFFALSE 104257
103972: GO 103974
103974: DISABLE
103975: LD_INT 0
103977: PPUSH
103978: PPUSH
103979: PPUSH
// begin i := rand ( 1 , 7 ) ;
103980: LD_ADDR_VAR 0 1
103984: PUSH
103985: LD_INT 1
103987: PPUSH
103988: LD_INT 7
103990: PPUSH
103991: CALL_OW 12
103995: ST_TO_ADDR
// case i of 1 :
103996: LD_VAR 0 1
104000: PUSH
104001: LD_INT 1
104003: DOUBLE
104004: EQUAL
104005: IFTRUE 104009
104007: GO 104019
104009: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
104010: LD_STRING earthquake(getX(game), 0, 32)
104012: PPUSH
104013: CALL_OW 559
104017: GO 104257
104019: LD_INT 2
104021: DOUBLE
104022: EQUAL
104023: IFTRUE 104027
104025: GO 104041
104027: POP
// begin ToLua ( displayStucuk(); ) ;
104028: LD_STRING displayStucuk();
104030: PPUSH
104031: CALL_OW 559
// ResetFog ;
104035: CALL_OW 335
// end ; 3 :
104039: GO 104257
104041: LD_INT 3
104043: DOUBLE
104044: EQUAL
104045: IFTRUE 104049
104047: GO 104153
104049: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
104050: LD_ADDR_VAR 0 2
104054: PUSH
104055: LD_INT 22
104057: PUSH
104058: LD_OWVAR 2
104062: PUSH
104063: EMPTY
104064: LIST
104065: LIST
104066: PUSH
104067: LD_INT 25
104069: PUSH
104070: LD_INT 1
104072: PUSH
104073: EMPTY
104074: LIST
104075: LIST
104076: PUSH
104077: EMPTY
104078: LIST
104079: LIST
104080: PPUSH
104081: CALL_OW 69
104085: ST_TO_ADDR
// if not tmp then
104086: LD_VAR 0 2
104090: NOT
104091: IFFALSE 104095
// exit ;
104093: GO 104257
// un := tmp [ rand ( 1 , tmp ) ] ;
104095: LD_ADDR_VAR 0 3
104099: PUSH
104100: LD_VAR 0 2
104104: PUSH
104105: LD_INT 1
104107: PPUSH
104108: LD_VAR 0 2
104112: PPUSH
104113: CALL_OW 12
104117: ARRAY
104118: ST_TO_ADDR
// if Crawls ( un ) then
104119: LD_VAR 0 3
104123: PPUSH
104124: CALL_OW 318
104128: IFFALSE 104139
// ComWalk ( un ) ;
104130: LD_VAR 0 3
104134: PPUSH
104135: CALL_OW 138
// SetClass ( un , class_mortar ) ;
104139: LD_VAR 0 3
104143: PPUSH
104144: LD_INT 8
104146: PPUSH
104147: CALL_OW 336
// end ; 4 :
104151: GO 104257
104153: LD_INT 4
104155: DOUBLE
104156: EQUAL
104157: IFTRUE 104161
104159: GO 104235
104161: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
104162: LD_ADDR_VAR 0 2
104166: PUSH
104167: LD_INT 22
104169: PUSH
104170: LD_OWVAR 2
104174: PUSH
104175: EMPTY
104176: LIST
104177: LIST
104178: PUSH
104179: LD_INT 30
104181: PUSH
104182: LD_INT 29
104184: PUSH
104185: EMPTY
104186: LIST
104187: LIST
104188: PUSH
104189: EMPTY
104190: LIST
104191: LIST
104192: PPUSH
104193: CALL_OW 69
104197: ST_TO_ADDR
// if not tmp then
104198: LD_VAR 0 2
104202: NOT
104203: IFFALSE 104207
// exit ;
104205: GO 104257
// CenterNowOnUnits ( tmp [ 1 ] ) ;
104207: LD_VAR 0 2
104211: PUSH
104212: LD_INT 1
104214: ARRAY
104215: PPUSH
104216: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
104220: LD_VAR 0 2
104224: PUSH
104225: LD_INT 1
104227: ARRAY
104228: PPUSH
104229: CALL_OW 65
// end ; 5 .. 7 :
104233: GO 104257
104235: LD_INT 5
104237: DOUBLE
104238: GREATEREQUAL
104239: IFFALSE 104247
104241: LD_INT 7
104243: DOUBLE
104244: LESSEQUAL
104245: IFTRUE 104249
104247: GO 104256
104249: POP
// StreamSibBomb ; end ;
104250: CALL 100494 0 0
104254: GO 104257
104256: POP
// end ;
104257: PPOPN 3
104259: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
104260: LD_EXP 98
104264: PUSH
104265: LD_EXP 148
104269: AND
104270: IFFALSE 104426
104272: GO 104274
104274: DISABLE
104275: LD_INT 0
104277: PPUSH
104278: PPUSH
104279: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
104280: LD_ADDR_VAR 0 2
104284: PUSH
104285: LD_INT 81
104287: PUSH
104288: LD_OWVAR 2
104292: PUSH
104293: EMPTY
104294: LIST
104295: LIST
104296: PUSH
104297: LD_INT 2
104299: PUSH
104300: LD_INT 21
104302: PUSH
104303: LD_INT 1
104305: PUSH
104306: EMPTY
104307: LIST
104308: LIST
104309: PUSH
104310: LD_INT 21
104312: PUSH
104313: LD_INT 2
104315: PUSH
104316: EMPTY
104317: LIST
104318: LIST
104319: PUSH
104320: EMPTY
104321: LIST
104322: LIST
104323: LIST
104324: PUSH
104325: EMPTY
104326: LIST
104327: LIST
104328: PPUSH
104329: CALL_OW 69
104333: ST_TO_ADDR
// if not tmp then
104334: LD_VAR 0 2
104338: NOT
104339: IFFALSE 104343
// exit ;
104341: GO 104426
// p := 0 ;
104343: LD_ADDR_VAR 0 3
104347: PUSH
104348: LD_INT 0
104350: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
104351: LD_INT 35
104353: PPUSH
104354: CALL_OW 67
// p := p + 1 ;
104358: LD_ADDR_VAR 0 3
104362: PUSH
104363: LD_VAR 0 3
104367: PUSH
104368: LD_INT 1
104370: PLUS
104371: ST_TO_ADDR
// for i in tmp do
104372: LD_ADDR_VAR 0 1
104376: PUSH
104377: LD_VAR 0 2
104381: PUSH
104382: FOR_IN
104383: IFFALSE 104414
// if GetLives ( i ) < 1000 then
104385: LD_VAR 0 1
104389: PPUSH
104390: CALL_OW 256
104394: PUSH
104395: LD_INT 1000
104397: LESS
104398: IFFALSE 104412
// SetLives ( i , 1000 ) ;
104400: LD_VAR 0 1
104404: PPUSH
104405: LD_INT 1000
104407: PPUSH
104408: CALL_OW 234
104412: GO 104382
104414: POP
104415: POP
// until p > 20 ;
104416: LD_VAR 0 3
104420: PUSH
104421: LD_INT 20
104423: GREATER
104424: IFFALSE 104351
// end ;
104426: PPOPN 3
104428: END
// every 0 0$1 trigger StreamModeActive and sTime do
104429: LD_EXP 98
104433: PUSH
104434: LD_EXP 149
104438: AND
104439: IFFALSE 104474
104441: GO 104443
104443: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
104444: LD_INT 28
104446: PPUSH
104447: LD_OWVAR 2
104451: PPUSH
104452: LD_INT 2
104454: PPUSH
104455: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
104459: LD_INT 30
104461: PPUSH
104462: LD_OWVAR 2
104466: PPUSH
104467: LD_INT 2
104469: PPUSH
104470: CALL_OW 322
// end ;
104474: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
104475: LD_EXP 98
104479: PUSH
104480: LD_EXP 150
104484: AND
104485: IFFALSE 104606
104487: GO 104489
104489: DISABLE
104490: LD_INT 0
104492: PPUSH
104493: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
104494: LD_ADDR_VAR 0 2
104498: PUSH
104499: LD_INT 22
104501: PUSH
104502: LD_OWVAR 2
104506: PUSH
104507: EMPTY
104508: LIST
104509: LIST
104510: PUSH
104511: LD_INT 21
104513: PUSH
104514: LD_INT 1
104516: PUSH
104517: EMPTY
104518: LIST
104519: LIST
104520: PUSH
104521: LD_INT 3
104523: PUSH
104524: LD_INT 23
104526: PUSH
104527: LD_INT 0
104529: PUSH
104530: EMPTY
104531: LIST
104532: LIST
104533: PUSH
104534: EMPTY
104535: LIST
104536: LIST
104537: PUSH
104538: EMPTY
104539: LIST
104540: LIST
104541: LIST
104542: PPUSH
104543: CALL_OW 69
104547: ST_TO_ADDR
// if not tmp then
104548: LD_VAR 0 2
104552: NOT
104553: IFFALSE 104557
// exit ;
104555: GO 104606
// for i in tmp do
104557: LD_ADDR_VAR 0 1
104561: PUSH
104562: LD_VAR 0 2
104566: PUSH
104567: FOR_IN
104568: IFFALSE 104604
// begin if Crawls ( i ) then
104570: LD_VAR 0 1
104574: PPUSH
104575: CALL_OW 318
104579: IFFALSE 104590
// ComWalk ( i ) ;
104581: LD_VAR 0 1
104585: PPUSH
104586: CALL_OW 138
// SetClass ( i , 2 ) ;
104590: LD_VAR 0 1
104594: PPUSH
104595: LD_INT 2
104597: PPUSH
104598: CALL_OW 336
// end ;
104602: GO 104567
104604: POP
104605: POP
// end ;
104606: PPOPN 2
104608: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
104609: LD_EXP 98
104613: PUSH
104614: LD_EXP 151
104618: AND
104619: IFFALSE 104907
104621: GO 104623
104623: DISABLE
104624: LD_INT 0
104626: PPUSH
104627: PPUSH
104628: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
104629: LD_OWVAR 2
104633: PPUSH
104634: LD_INT 9
104636: PPUSH
104637: LD_INT 1
104639: PPUSH
104640: LD_INT 1
104642: PPUSH
104643: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
104647: LD_INT 9
104649: PPUSH
104650: LD_OWVAR 2
104654: PPUSH
104655: CALL_OW 343
// uc_side := 9 ;
104659: LD_ADDR_OWVAR 20
104663: PUSH
104664: LD_INT 9
104666: ST_TO_ADDR
// uc_nation := 2 ;
104667: LD_ADDR_OWVAR 21
104671: PUSH
104672: LD_INT 2
104674: ST_TO_ADDR
// hc_name := Dark Warrior ;
104675: LD_ADDR_OWVAR 26
104679: PUSH
104680: LD_STRING Dark Warrior
104682: ST_TO_ADDR
// hc_gallery :=  ;
104683: LD_ADDR_OWVAR 33
104687: PUSH
104688: LD_STRING 
104690: ST_TO_ADDR
// hc_noskilllimit := true ;
104691: LD_ADDR_OWVAR 76
104695: PUSH
104696: LD_INT 1
104698: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
104699: LD_ADDR_OWVAR 31
104703: PUSH
104704: LD_INT 30
104706: PUSH
104707: LD_INT 30
104709: PUSH
104710: LD_INT 30
104712: PUSH
104713: LD_INT 30
104715: PUSH
104716: EMPTY
104717: LIST
104718: LIST
104719: LIST
104720: LIST
104721: ST_TO_ADDR
// un := CreateHuman ;
104722: LD_ADDR_VAR 0 3
104726: PUSH
104727: CALL_OW 44
104731: ST_TO_ADDR
// hc_noskilllimit := false ;
104732: LD_ADDR_OWVAR 76
104736: PUSH
104737: LD_INT 0
104739: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
104740: LD_VAR 0 3
104744: PPUSH
104745: LD_INT 1
104747: PPUSH
104748: CALL_OW 51
// ToLua ( playRanger() ) ;
104752: LD_STRING playRanger()
104754: PPUSH
104755: CALL_OW 559
// p := 0 ;
104759: LD_ADDR_VAR 0 2
104763: PUSH
104764: LD_INT 0
104766: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
104767: LD_INT 35
104769: PPUSH
104770: CALL_OW 67
// p := p + 1 ;
104774: LD_ADDR_VAR 0 2
104778: PUSH
104779: LD_VAR 0 2
104783: PUSH
104784: LD_INT 1
104786: PLUS
104787: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
104788: LD_VAR 0 3
104792: PPUSH
104793: CALL_OW 256
104797: PUSH
104798: LD_INT 1000
104800: LESS
104801: IFFALSE 104815
// SetLives ( un , 1000 ) ;
104803: LD_VAR 0 3
104807: PPUSH
104808: LD_INT 1000
104810: PPUSH
104811: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
104815: LD_VAR 0 3
104819: PPUSH
104820: LD_INT 81
104822: PUSH
104823: LD_OWVAR 2
104827: PUSH
104828: EMPTY
104829: LIST
104830: LIST
104831: PUSH
104832: LD_INT 91
104834: PUSH
104835: LD_VAR 0 3
104839: PUSH
104840: LD_INT 30
104842: PUSH
104843: EMPTY
104844: LIST
104845: LIST
104846: LIST
104847: PUSH
104848: EMPTY
104849: LIST
104850: LIST
104851: PPUSH
104852: CALL_OW 69
104856: PPUSH
104857: LD_VAR 0 3
104861: PPUSH
104862: CALL_OW 74
104866: PPUSH
104867: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
104871: LD_VAR 0 2
104875: PUSH
104876: LD_INT 80
104878: GREATER
104879: PUSH
104880: LD_VAR 0 3
104884: PPUSH
104885: CALL_OW 301
104889: OR
104890: IFFALSE 104767
// if un then
104892: LD_VAR 0 3
104896: IFFALSE 104907
// RemoveUnit ( un ) ;
104898: LD_VAR 0 3
104902: PPUSH
104903: CALL_OW 64
// end ;
104907: PPOPN 3
104909: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
104910: LD_EXP 152
104914: IFFALSE 105030
104916: GO 104918
104918: DISABLE
104919: LD_INT 0
104921: PPUSH
104922: PPUSH
104923: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
104924: LD_ADDR_VAR 0 2
104928: PUSH
104929: LD_INT 81
104931: PUSH
104932: LD_OWVAR 2
104936: PUSH
104937: EMPTY
104938: LIST
104939: LIST
104940: PUSH
104941: LD_INT 21
104943: PUSH
104944: LD_INT 1
104946: PUSH
104947: EMPTY
104948: LIST
104949: LIST
104950: PUSH
104951: EMPTY
104952: LIST
104953: LIST
104954: PPUSH
104955: CALL_OW 69
104959: ST_TO_ADDR
// ToLua ( playComputer() ) ;
104960: LD_STRING playComputer()
104962: PPUSH
104963: CALL_OW 559
// if not tmp then
104967: LD_VAR 0 2
104971: NOT
104972: IFFALSE 104976
// exit ;
104974: GO 105030
// for i in tmp do
104976: LD_ADDR_VAR 0 1
104980: PUSH
104981: LD_VAR 0 2
104985: PUSH
104986: FOR_IN
104987: IFFALSE 105028
// for j := 1 to 4 do
104989: LD_ADDR_VAR 0 3
104993: PUSH
104994: DOUBLE
104995: LD_INT 1
104997: DEC
104998: ST_TO_ADDR
104999: LD_INT 4
105001: PUSH
105002: FOR_TO
105003: IFFALSE 105024
// SetSkill ( i , j , 10 ) ;
105005: LD_VAR 0 1
105009: PPUSH
105010: LD_VAR 0 3
105014: PPUSH
105015: LD_INT 10
105017: PPUSH
105018: CALL_OW 237
105022: GO 105002
105024: POP
105025: POP
105026: GO 104986
105028: POP
105029: POP
// end ;
105030: PPOPN 3
105032: END
// every 0 0$1 trigger s30 do var i , tmp ;
105033: LD_EXP 153
105037: IFFALSE 105106
105039: GO 105041
105041: DISABLE
105042: LD_INT 0
105044: PPUSH
105045: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
105046: LD_ADDR_VAR 0 2
105050: PUSH
105051: LD_INT 22
105053: PUSH
105054: LD_OWVAR 2
105058: PUSH
105059: EMPTY
105060: LIST
105061: LIST
105062: PPUSH
105063: CALL_OW 69
105067: ST_TO_ADDR
// if not tmp then
105068: LD_VAR 0 2
105072: NOT
105073: IFFALSE 105077
// exit ;
105075: GO 105106
// for i in tmp do
105077: LD_ADDR_VAR 0 1
105081: PUSH
105082: LD_VAR 0 2
105086: PUSH
105087: FOR_IN
105088: IFFALSE 105104
// SetLives ( i , 300 ) ;
105090: LD_VAR 0 1
105094: PPUSH
105095: LD_INT 300
105097: PPUSH
105098: CALL_OW 234
105102: GO 105087
105104: POP
105105: POP
// end ;
105106: PPOPN 2
105108: END
// every 0 0$1 trigger s60 do var i , tmp ;
105109: LD_EXP 154
105113: IFFALSE 105182
105115: GO 105117
105117: DISABLE
105118: LD_INT 0
105120: PPUSH
105121: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
105122: LD_ADDR_VAR 0 2
105126: PUSH
105127: LD_INT 22
105129: PUSH
105130: LD_OWVAR 2
105134: PUSH
105135: EMPTY
105136: LIST
105137: LIST
105138: PPUSH
105139: CALL_OW 69
105143: ST_TO_ADDR
// if not tmp then
105144: LD_VAR 0 2
105148: NOT
105149: IFFALSE 105153
// exit ;
105151: GO 105182
// for i in tmp do
105153: LD_ADDR_VAR 0 1
105157: PUSH
105158: LD_VAR 0 2
105162: PUSH
105163: FOR_IN
105164: IFFALSE 105180
// SetLives ( i , 600 ) ;
105166: LD_VAR 0 1
105170: PPUSH
105171: LD_INT 600
105173: PPUSH
105174: CALL_OW 234
105178: GO 105163
105180: POP
105181: POP
// end ;
105182: PPOPN 2
105184: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
105185: LD_INT 0
105187: PPUSH
// case cmd of 301 :
105188: LD_VAR 0 1
105192: PUSH
105193: LD_INT 301
105195: DOUBLE
105196: EQUAL
105197: IFTRUE 105201
105199: GO 105233
105201: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
105202: LD_VAR 0 6
105206: PPUSH
105207: LD_VAR 0 7
105211: PPUSH
105212: LD_VAR 0 8
105216: PPUSH
105217: LD_VAR 0 4
105221: PPUSH
105222: LD_VAR 0 5
105226: PPUSH
105227: CALL 106434 0 5
105231: GO 105354
105233: LD_INT 302
105235: DOUBLE
105236: EQUAL
105237: IFTRUE 105241
105239: GO 105278
105241: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
105242: LD_VAR 0 6
105246: PPUSH
105247: LD_VAR 0 7
105251: PPUSH
105252: LD_VAR 0 8
105256: PPUSH
105257: LD_VAR 0 9
105261: PPUSH
105262: LD_VAR 0 4
105266: PPUSH
105267: LD_VAR 0 5
105271: PPUSH
105272: CALL 106525 0 6
105276: GO 105354
105278: LD_INT 303
105280: DOUBLE
105281: EQUAL
105282: IFTRUE 105286
105284: GO 105323
105286: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
105287: LD_VAR 0 6
105291: PPUSH
105292: LD_VAR 0 7
105296: PPUSH
105297: LD_VAR 0 8
105301: PPUSH
105302: LD_VAR 0 9
105306: PPUSH
105307: LD_VAR 0 4
105311: PPUSH
105312: LD_VAR 0 5
105316: PPUSH
105317: CALL 105359 0 6
105321: GO 105354
105323: LD_INT 304
105325: DOUBLE
105326: EQUAL
105327: IFTRUE 105331
105329: GO 105353
105331: POP
// hHackTeleport ( unit , x , y ) ; end ;
105332: LD_VAR 0 2
105336: PPUSH
105337: LD_VAR 0 4
105341: PPUSH
105342: LD_VAR 0 5
105346: PPUSH
105347: CALL 107118 0 3
105351: GO 105354
105353: POP
// end ;
105354: LD_VAR 0 12
105358: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
105359: LD_INT 0
105361: PPUSH
105362: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
105363: LD_VAR 0 1
105367: PUSH
105368: LD_INT 1
105370: LESS
105371: PUSH
105372: LD_VAR 0 1
105376: PUSH
105377: LD_INT 3
105379: GREATER
105380: OR
105381: PUSH
105382: LD_VAR 0 5
105386: PPUSH
105387: LD_VAR 0 6
105391: PPUSH
105392: CALL_OW 428
105396: OR
105397: IFFALSE 105401
// exit ;
105399: GO 106121
// uc_side := your_side ;
105401: LD_ADDR_OWVAR 20
105405: PUSH
105406: LD_OWVAR 2
105410: ST_TO_ADDR
// uc_nation := nation ;
105411: LD_ADDR_OWVAR 21
105415: PUSH
105416: LD_VAR 0 1
105420: ST_TO_ADDR
// bc_level = 1 ;
105421: LD_ADDR_OWVAR 43
105425: PUSH
105426: LD_INT 1
105428: ST_TO_ADDR
// case btype of 1 :
105429: LD_VAR 0 2
105433: PUSH
105434: LD_INT 1
105436: DOUBLE
105437: EQUAL
105438: IFTRUE 105442
105440: GO 105453
105442: POP
// bc_type := b_depot ; 2 :
105443: LD_ADDR_OWVAR 42
105447: PUSH
105448: LD_INT 0
105450: ST_TO_ADDR
105451: GO 106065
105453: LD_INT 2
105455: DOUBLE
105456: EQUAL
105457: IFTRUE 105461
105459: GO 105472
105461: POP
// bc_type := b_warehouse ; 3 :
105462: LD_ADDR_OWVAR 42
105466: PUSH
105467: LD_INT 1
105469: ST_TO_ADDR
105470: GO 106065
105472: LD_INT 3
105474: DOUBLE
105475: EQUAL
105476: IFTRUE 105480
105478: GO 105491
105480: POP
// bc_type := b_lab ; 4 .. 9 :
105481: LD_ADDR_OWVAR 42
105485: PUSH
105486: LD_INT 6
105488: ST_TO_ADDR
105489: GO 106065
105491: LD_INT 4
105493: DOUBLE
105494: GREATEREQUAL
105495: IFFALSE 105503
105497: LD_INT 9
105499: DOUBLE
105500: LESSEQUAL
105501: IFTRUE 105505
105503: GO 105557
105505: POP
// begin bc_type := b_lab_half ;
105506: LD_ADDR_OWVAR 42
105510: PUSH
105511: LD_INT 7
105513: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
105514: LD_ADDR_OWVAR 44
105518: PUSH
105519: LD_INT 10
105521: PUSH
105522: LD_INT 11
105524: PUSH
105525: LD_INT 12
105527: PUSH
105528: LD_INT 15
105530: PUSH
105531: LD_INT 14
105533: PUSH
105534: LD_INT 13
105536: PUSH
105537: EMPTY
105538: LIST
105539: LIST
105540: LIST
105541: LIST
105542: LIST
105543: LIST
105544: PUSH
105545: LD_VAR 0 2
105549: PUSH
105550: LD_INT 3
105552: MINUS
105553: ARRAY
105554: ST_TO_ADDR
// end ; 10 .. 13 :
105555: GO 106065
105557: LD_INT 10
105559: DOUBLE
105560: GREATEREQUAL
105561: IFFALSE 105569
105563: LD_INT 13
105565: DOUBLE
105566: LESSEQUAL
105567: IFTRUE 105571
105569: GO 105648
105571: POP
// begin bc_type := b_lab_full ;
105572: LD_ADDR_OWVAR 42
105576: PUSH
105577: LD_INT 8
105579: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
105580: LD_ADDR_OWVAR 44
105584: PUSH
105585: LD_INT 10
105587: PUSH
105588: LD_INT 12
105590: PUSH
105591: LD_INT 14
105593: PUSH
105594: LD_INT 13
105596: PUSH
105597: EMPTY
105598: LIST
105599: LIST
105600: LIST
105601: LIST
105602: PUSH
105603: LD_VAR 0 2
105607: PUSH
105608: LD_INT 9
105610: MINUS
105611: ARRAY
105612: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
105613: LD_ADDR_OWVAR 45
105617: PUSH
105618: LD_INT 11
105620: PUSH
105621: LD_INT 15
105623: PUSH
105624: LD_INT 12
105626: PUSH
105627: LD_INT 15
105629: PUSH
105630: EMPTY
105631: LIST
105632: LIST
105633: LIST
105634: LIST
105635: PUSH
105636: LD_VAR 0 2
105640: PUSH
105641: LD_INT 9
105643: MINUS
105644: ARRAY
105645: ST_TO_ADDR
// end ; 14 :
105646: GO 106065
105648: LD_INT 14
105650: DOUBLE
105651: EQUAL
105652: IFTRUE 105656
105654: GO 105667
105656: POP
// bc_type := b_workshop ; 15 :
105657: LD_ADDR_OWVAR 42
105661: PUSH
105662: LD_INT 2
105664: ST_TO_ADDR
105665: GO 106065
105667: LD_INT 15
105669: DOUBLE
105670: EQUAL
105671: IFTRUE 105675
105673: GO 105686
105675: POP
// bc_type := b_factory ; 16 :
105676: LD_ADDR_OWVAR 42
105680: PUSH
105681: LD_INT 3
105683: ST_TO_ADDR
105684: GO 106065
105686: LD_INT 16
105688: DOUBLE
105689: EQUAL
105690: IFTRUE 105694
105692: GO 105705
105694: POP
// bc_type := b_ext_gun ; 17 :
105695: LD_ADDR_OWVAR 42
105699: PUSH
105700: LD_INT 17
105702: ST_TO_ADDR
105703: GO 106065
105705: LD_INT 17
105707: DOUBLE
105708: EQUAL
105709: IFTRUE 105713
105711: GO 105741
105713: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
105714: LD_ADDR_OWVAR 42
105718: PUSH
105719: LD_INT 19
105721: PUSH
105722: LD_INT 23
105724: PUSH
105725: LD_INT 19
105727: PUSH
105728: EMPTY
105729: LIST
105730: LIST
105731: LIST
105732: PUSH
105733: LD_VAR 0 1
105737: ARRAY
105738: ST_TO_ADDR
105739: GO 106065
105741: LD_INT 18
105743: DOUBLE
105744: EQUAL
105745: IFTRUE 105749
105747: GO 105760
105749: POP
// bc_type := b_ext_radar ; 19 :
105750: LD_ADDR_OWVAR 42
105754: PUSH
105755: LD_INT 20
105757: ST_TO_ADDR
105758: GO 106065
105760: LD_INT 19
105762: DOUBLE
105763: EQUAL
105764: IFTRUE 105768
105766: GO 105779
105768: POP
// bc_type := b_ext_radio ; 20 :
105769: LD_ADDR_OWVAR 42
105773: PUSH
105774: LD_INT 22
105776: ST_TO_ADDR
105777: GO 106065
105779: LD_INT 20
105781: DOUBLE
105782: EQUAL
105783: IFTRUE 105787
105785: GO 105798
105787: POP
// bc_type := b_ext_siberium ; 21 :
105788: LD_ADDR_OWVAR 42
105792: PUSH
105793: LD_INT 21
105795: ST_TO_ADDR
105796: GO 106065
105798: LD_INT 21
105800: DOUBLE
105801: EQUAL
105802: IFTRUE 105806
105804: GO 105817
105806: POP
// bc_type := b_ext_computer ; 22 :
105807: LD_ADDR_OWVAR 42
105811: PUSH
105812: LD_INT 24
105814: ST_TO_ADDR
105815: GO 106065
105817: LD_INT 22
105819: DOUBLE
105820: EQUAL
105821: IFTRUE 105825
105823: GO 105836
105825: POP
// bc_type := b_ext_track ; 23 :
105826: LD_ADDR_OWVAR 42
105830: PUSH
105831: LD_INT 16
105833: ST_TO_ADDR
105834: GO 106065
105836: LD_INT 23
105838: DOUBLE
105839: EQUAL
105840: IFTRUE 105844
105842: GO 105855
105844: POP
// bc_type := b_ext_laser ; 24 :
105845: LD_ADDR_OWVAR 42
105849: PUSH
105850: LD_INT 25
105852: ST_TO_ADDR
105853: GO 106065
105855: LD_INT 24
105857: DOUBLE
105858: EQUAL
105859: IFTRUE 105863
105861: GO 105874
105863: POP
// bc_type := b_control_tower ; 25 :
105864: LD_ADDR_OWVAR 42
105868: PUSH
105869: LD_INT 36
105871: ST_TO_ADDR
105872: GO 106065
105874: LD_INT 25
105876: DOUBLE
105877: EQUAL
105878: IFTRUE 105882
105880: GO 105893
105882: POP
// bc_type := b_breastwork ; 26 :
105883: LD_ADDR_OWVAR 42
105887: PUSH
105888: LD_INT 31
105890: ST_TO_ADDR
105891: GO 106065
105893: LD_INT 26
105895: DOUBLE
105896: EQUAL
105897: IFTRUE 105901
105899: GO 105912
105901: POP
// bc_type := b_bunker ; 27 :
105902: LD_ADDR_OWVAR 42
105906: PUSH
105907: LD_INT 32
105909: ST_TO_ADDR
105910: GO 106065
105912: LD_INT 27
105914: DOUBLE
105915: EQUAL
105916: IFTRUE 105920
105918: GO 105931
105920: POP
// bc_type := b_turret ; 28 :
105921: LD_ADDR_OWVAR 42
105925: PUSH
105926: LD_INT 33
105928: ST_TO_ADDR
105929: GO 106065
105931: LD_INT 28
105933: DOUBLE
105934: EQUAL
105935: IFTRUE 105939
105937: GO 105950
105939: POP
// bc_type := b_armoury ; 29 :
105940: LD_ADDR_OWVAR 42
105944: PUSH
105945: LD_INT 4
105947: ST_TO_ADDR
105948: GO 106065
105950: LD_INT 29
105952: DOUBLE
105953: EQUAL
105954: IFTRUE 105958
105956: GO 105969
105958: POP
// bc_type := b_barracks ; 30 :
105959: LD_ADDR_OWVAR 42
105963: PUSH
105964: LD_INT 5
105966: ST_TO_ADDR
105967: GO 106065
105969: LD_INT 30
105971: DOUBLE
105972: EQUAL
105973: IFTRUE 105977
105975: GO 105988
105977: POP
// bc_type := b_solar_power ; 31 :
105978: LD_ADDR_OWVAR 42
105982: PUSH
105983: LD_INT 27
105985: ST_TO_ADDR
105986: GO 106065
105988: LD_INT 31
105990: DOUBLE
105991: EQUAL
105992: IFTRUE 105996
105994: GO 106007
105996: POP
// bc_type := b_oil_power ; 32 :
105997: LD_ADDR_OWVAR 42
106001: PUSH
106002: LD_INT 26
106004: ST_TO_ADDR
106005: GO 106065
106007: LD_INT 32
106009: DOUBLE
106010: EQUAL
106011: IFTRUE 106015
106013: GO 106026
106015: POP
// bc_type := b_siberite_power ; 33 :
106016: LD_ADDR_OWVAR 42
106020: PUSH
106021: LD_INT 28
106023: ST_TO_ADDR
106024: GO 106065
106026: LD_INT 33
106028: DOUBLE
106029: EQUAL
106030: IFTRUE 106034
106032: GO 106045
106034: POP
// bc_type := b_oil_mine ; 34 :
106035: LD_ADDR_OWVAR 42
106039: PUSH
106040: LD_INT 29
106042: ST_TO_ADDR
106043: GO 106065
106045: LD_INT 34
106047: DOUBLE
106048: EQUAL
106049: IFTRUE 106053
106051: GO 106064
106053: POP
// bc_type := b_siberite_mine ; end ;
106054: LD_ADDR_OWVAR 42
106058: PUSH
106059: LD_INT 30
106061: ST_TO_ADDR
106062: GO 106065
106064: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
106065: LD_ADDR_VAR 0 8
106069: PUSH
106070: LD_VAR 0 5
106074: PPUSH
106075: LD_VAR 0 6
106079: PPUSH
106080: LD_VAR 0 3
106084: PPUSH
106085: CALL_OW 47
106089: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
106090: LD_OWVAR 42
106094: PUSH
106095: LD_INT 32
106097: PUSH
106098: LD_INT 33
106100: PUSH
106101: EMPTY
106102: LIST
106103: LIST
106104: IN
106105: IFFALSE 106121
// PlaceWeaponTurret ( b , weapon ) ;
106107: LD_VAR 0 8
106111: PPUSH
106112: LD_VAR 0 4
106116: PPUSH
106117: CALL_OW 431
// end ;
106121: LD_VAR 0 7
106125: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
106126: LD_INT 0
106128: PPUSH
106129: PPUSH
106130: PPUSH
106131: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
106132: LD_ADDR_VAR 0 4
106136: PUSH
106137: LD_INT 22
106139: PUSH
106140: LD_OWVAR 2
106144: PUSH
106145: EMPTY
106146: LIST
106147: LIST
106148: PUSH
106149: LD_INT 2
106151: PUSH
106152: LD_INT 30
106154: PUSH
106155: LD_INT 0
106157: PUSH
106158: EMPTY
106159: LIST
106160: LIST
106161: PUSH
106162: LD_INT 30
106164: PUSH
106165: LD_INT 1
106167: PUSH
106168: EMPTY
106169: LIST
106170: LIST
106171: PUSH
106172: EMPTY
106173: LIST
106174: LIST
106175: LIST
106176: PUSH
106177: EMPTY
106178: LIST
106179: LIST
106180: PPUSH
106181: CALL_OW 69
106185: ST_TO_ADDR
// if not tmp then
106186: LD_VAR 0 4
106190: NOT
106191: IFFALSE 106195
// exit ;
106193: GO 106254
// for i in tmp do
106195: LD_ADDR_VAR 0 2
106199: PUSH
106200: LD_VAR 0 4
106204: PUSH
106205: FOR_IN
106206: IFFALSE 106252
// for j = 1 to 3 do
106208: LD_ADDR_VAR 0 3
106212: PUSH
106213: DOUBLE
106214: LD_INT 1
106216: DEC
106217: ST_TO_ADDR
106218: LD_INT 3
106220: PUSH
106221: FOR_TO
106222: IFFALSE 106248
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
106224: LD_VAR 0 2
106228: PPUSH
106229: CALL_OW 274
106233: PPUSH
106234: LD_VAR 0 3
106238: PPUSH
106239: LD_INT 99999
106241: PPUSH
106242: CALL_OW 277
106246: GO 106221
106248: POP
106249: POP
106250: GO 106205
106252: POP
106253: POP
// end ;
106254: LD_VAR 0 1
106258: RET
// export function hHackSetLevel10 ; var i , j ; begin
106259: LD_INT 0
106261: PPUSH
106262: PPUSH
106263: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
106264: LD_ADDR_VAR 0 2
106268: PUSH
106269: LD_INT 21
106271: PUSH
106272: LD_INT 1
106274: PUSH
106275: EMPTY
106276: LIST
106277: LIST
106278: PPUSH
106279: CALL_OW 69
106283: PUSH
106284: FOR_IN
106285: IFFALSE 106337
// if IsSelected ( i ) then
106287: LD_VAR 0 2
106291: PPUSH
106292: CALL_OW 306
106296: IFFALSE 106335
// begin for j := 1 to 4 do
106298: LD_ADDR_VAR 0 3
106302: PUSH
106303: DOUBLE
106304: LD_INT 1
106306: DEC
106307: ST_TO_ADDR
106308: LD_INT 4
106310: PUSH
106311: FOR_TO
106312: IFFALSE 106333
// SetSkill ( i , j , 10 ) ;
106314: LD_VAR 0 2
106318: PPUSH
106319: LD_VAR 0 3
106323: PPUSH
106324: LD_INT 10
106326: PPUSH
106327: CALL_OW 237
106331: GO 106311
106333: POP
106334: POP
// end ;
106335: GO 106284
106337: POP
106338: POP
// end ;
106339: LD_VAR 0 1
106343: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
106344: LD_INT 0
106346: PPUSH
106347: PPUSH
106348: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
106349: LD_ADDR_VAR 0 2
106353: PUSH
106354: LD_INT 22
106356: PUSH
106357: LD_OWVAR 2
106361: PUSH
106362: EMPTY
106363: LIST
106364: LIST
106365: PUSH
106366: LD_INT 21
106368: PUSH
106369: LD_INT 1
106371: PUSH
106372: EMPTY
106373: LIST
106374: LIST
106375: PUSH
106376: EMPTY
106377: LIST
106378: LIST
106379: PPUSH
106380: CALL_OW 69
106384: PUSH
106385: FOR_IN
106386: IFFALSE 106427
// begin for j := 1 to 4 do
106388: LD_ADDR_VAR 0 3
106392: PUSH
106393: DOUBLE
106394: LD_INT 1
106396: DEC
106397: ST_TO_ADDR
106398: LD_INT 4
106400: PUSH
106401: FOR_TO
106402: IFFALSE 106423
// SetSkill ( i , j , 10 ) ;
106404: LD_VAR 0 2
106408: PPUSH
106409: LD_VAR 0 3
106413: PPUSH
106414: LD_INT 10
106416: PPUSH
106417: CALL_OW 237
106421: GO 106401
106423: POP
106424: POP
// end ;
106425: GO 106385
106427: POP
106428: POP
// end ;
106429: LD_VAR 0 1
106433: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
106434: LD_INT 0
106436: PPUSH
// uc_side := your_side ;
106437: LD_ADDR_OWVAR 20
106441: PUSH
106442: LD_OWVAR 2
106446: ST_TO_ADDR
// uc_nation := nation ;
106447: LD_ADDR_OWVAR 21
106451: PUSH
106452: LD_VAR 0 1
106456: ST_TO_ADDR
// InitHc ;
106457: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
106461: LD_INT 0
106463: PPUSH
106464: LD_VAR 0 2
106468: PPUSH
106469: LD_VAR 0 3
106473: PPUSH
106474: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
106478: LD_VAR 0 4
106482: PPUSH
106483: LD_VAR 0 5
106487: PPUSH
106488: CALL_OW 428
106492: PUSH
106493: LD_INT 0
106495: EQUAL
106496: IFFALSE 106520
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
106498: CALL_OW 44
106502: PPUSH
106503: LD_VAR 0 4
106507: PPUSH
106508: LD_VAR 0 5
106512: PPUSH
106513: LD_INT 1
106515: PPUSH
106516: CALL_OW 48
// end ;
106520: LD_VAR 0 6
106524: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
106525: LD_INT 0
106527: PPUSH
106528: PPUSH
// uc_side := your_side ;
106529: LD_ADDR_OWVAR 20
106533: PUSH
106534: LD_OWVAR 2
106538: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
106539: LD_VAR 0 1
106543: PUSH
106544: LD_INT 1
106546: PUSH
106547: LD_INT 2
106549: PUSH
106550: LD_INT 3
106552: PUSH
106553: LD_INT 4
106555: PUSH
106556: LD_INT 5
106558: PUSH
106559: EMPTY
106560: LIST
106561: LIST
106562: LIST
106563: LIST
106564: LIST
106565: IN
106566: IFFALSE 106578
// uc_nation := nation_american else
106568: LD_ADDR_OWVAR 21
106572: PUSH
106573: LD_INT 1
106575: ST_TO_ADDR
106576: GO 106621
// if chassis in [ 11 , 12 , 13 , 14 ] then
106578: LD_VAR 0 1
106582: PUSH
106583: LD_INT 11
106585: PUSH
106586: LD_INT 12
106588: PUSH
106589: LD_INT 13
106591: PUSH
106592: LD_INT 14
106594: PUSH
106595: EMPTY
106596: LIST
106597: LIST
106598: LIST
106599: LIST
106600: IN
106601: IFFALSE 106613
// uc_nation := nation_arabian else
106603: LD_ADDR_OWVAR 21
106607: PUSH
106608: LD_INT 2
106610: ST_TO_ADDR
106611: GO 106621
// uc_nation := nation_russian ;
106613: LD_ADDR_OWVAR 21
106617: PUSH
106618: LD_INT 3
106620: ST_TO_ADDR
// vc_chassis := chassis ;
106621: LD_ADDR_OWVAR 37
106625: PUSH
106626: LD_VAR 0 1
106630: ST_TO_ADDR
// vc_engine := engine ;
106631: LD_ADDR_OWVAR 39
106635: PUSH
106636: LD_VAR 0 2
106640: ST_TO_ADDR
// vc_control := control ;
106641: LD_ADDR_OWVAR 38
106645: PUSH
106646: LD_VAR 0 3
106650: ST_TO_ADDR
// vc_weapon := weapon ;
106651: LD_ADDR_OWVAR 40
106655: PUSH
106656: LD_VAR 0 4
106660: ST_TO_ADDR
// un := CreateVehicle ;
106661: LD_ADDR_VAR 0 8
106665: PUSH
106666: CALL_OW 45
106670: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
106671: LD_VAR 0 8
106675: PPUSH
106676: LD_INT 0
106678: PPUSH
106679: LD_INT 5
106681: PPUSH
106682: CALL_OW 12
106686: PPUSH
106687: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
106691: LD_VAR 0 8
106695: PPUSH
106696: LD_VAR 0 5
106700: PPUSH
106701: LD_VAR 0 6
106705: PPUSH
106706: LD_INT 1
106708: PPUSH
106709: CALL_OW 48
// end ;
106713: LD_VAR 0 7
106717: RET
// export hInvincible ; every 1 do
106718: GO 106720
106720: DISABLE
// hInvincible := [ ] ;
106721: LD_ADDR_EXP 155
106725: PUSH
106726: EMPTY
106727: ST_TO_ADDR
106728: END
// every 10 do var i ;
106729: GO 106731
106731: DISABLE
106732: LD_INT 0
106734: PPUSH
// begin enable ;
106735: ENABLE
// if not hInvincible then
106736: LD_EXP 155
106740: NOT
106741: IFFALSE 106745
// exit ;
106743: GO 106789
// for i in hInvincible do
106745: LD_ADDR_VAR 0 1
106749: PUSH
106750: LD_EXP 155
106754: PUSH
106755: FOR_IN
106756: IFFALSE 106787
// if GetLives ( i ) < 1000 then
106758: LD_VAR 0 1
106762: PPUSH
106763: CALL_OW 256
106767: PUSH
106768: LD_INT 1000
106770: LESS
106771: IFFALSE 106785
// SetLives ( i , 1000 ) ;
106773: LD_VAR 0 1
106777: PPUSH
106778: LD_INT 1000
106780: PPUSH
106781: CALL_OW 234
106785: GO 106755
106787: POP
106788: POP
// end ;
106789: PPOPN 1
106791: END
// export function hHackInvincible ; var i ; begin
106792: LD_INT 0
106794: PPUSH
106795: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
106796: LD_ADDR_VAR 0 2
106800: PUSH
106801: LD_INT 2
106803: PUSH
106804: LD_INT 21
106806: PUSH
106807: LD_INT 1
106809: PUSH
106810: EMPTY
106811: LIST
106812: LIST
106813: PUSH
106814: LD_INT 21
106816: PUSH
106817: LD_INT 2
106819: PUSH
106820: EMPTY
106821: LIST
106822: LIST
106823: PUSH
106824: EMPTY
106825: LIST
106826: LIST
106827: LIST
106828: PPUSH
106829: CALL_OW 69
106833: PUSH
106834: FOR_IN
106835: IFFALSE 106896
// if IsSelected ( i ) then
106837: LD_VAR 0 2
106841: PPUSH
106842: CALL_OW 306
106846: IFFALSE 106894
// begin if i in hInvincible then
106848: LD_VAR 0 2
106852: PUSH
106853: LD_EXP 155
106857: IN
106858: IFFALSE 106878
// hInvincible := hInvincible diff i else
106860: LD_ADDR_EXP 155
106864: PUSH
106865: LD_EXP 155
106869: PUSH
106870: LD_VAR 0 2
106874: DIFF
106875: ST_TO_ADDR
106876: GO 106894
// hInvincible := hInvincible union i ;
106878: LD_ADDR_EXP 155
106882: PUSH
106883: LD_EXP 155
106887: PUSH
106888: LD_VAR 0 2
106892: UNION
106893: ST_TO_ADDR
// end ;
106894: GO 106834
106896: POP
106897: POP
// end ;
106898: LD_VAR 0 1
106902: RET
// export function hHackInvisible ; var i , j ; begin
106903: LD_INT 0
106905: PPUSH
106906: PPUSH
106907: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
106908: LD_ADDR_VAR 0 2
106912: PUSH
106913: LD_INT 21
106915: PUSH
106916: LD_INT 1
106918: PUSH
106919: EMPTY
106920: LIST
106921: LIST
106922: PPUSH
106923: CALL_OW 69
106927: PUSH
106928: FOR_IN
106929: IFFALSE 106953
// if IsSelected ( i ) then
106931: LD_VAR 0 2
106935: PPUSH
106936: CALL_OW 306
106940: IFFALSE 106951
// ComForceInvisible ( i ) ;
106942: LD_VAR 0 2
106946: PPUSH
106947: CALL_OW 496
106951: GO 106928
106953: POP
106954: POP
// end ;
106955: LD_VAR 0 1
106959: RET
// export function hHackChangeYourSide ; begin
106960: LD_INT 0
106962: PPUSH
// if your_side = 8 then
106963: LD_OWVAR 2
106967: PUSH
106968: LD_INT 8
106970: EQUAL
106971: IFFALSE 106983
// your_side := 0 else
106973: LD_ADDR_OWVAR 2
106977: PUSH
106978: LD_INT 0
106980: ST_TO_ADDR
106981: GO 106997
// your_side := your_side + 1 ;
106983: LD_ADDR_OWVAR 2
106987: PUSH
106988: LD_OWVAR 2
106992: PUSH
106993: LD_INT 1
106995: PLUS
106996: ST_TO_ADDR
// end ;
106997: LD_VAR 0 1
107001: RET
// export function hHackChangeUnitSide ; var i , j ; begin
107002: LD_INT 0
107004: PPUSH
107005: PPUSH
107006: PPUSH
// for i in all_units do
107007: LD_ADDR_VAR 0 2
107011: PUSH
107012: LD_OWVAR 3
107016: PUSH
107017: FOR_IN
107018: IFFALSE 107096
// if IsSelected ( i ) then
107020: LD_VAR 0 2
107024: PPUSH
107025: CALL_OW 306
107029: IFFALSE 107094
// begin j := GetSide ( i ) ;
107031: LD_ADDR_VAR 0 3
107035: PUSH
107036: LD_VAR 0 2
107040: PPUSH
107041: CALL_OW 255
107045: ST_TO_ADDR
// if j = 8 then
107046: LD_VAR 0 3
107050: PUSH
107051: LD_INT 8
107053: EQUAL
107054: IFFALSE 107066
// j := 0 else
107056: LD_ADDR_VAR 0 3
107060: PUSH
107061: LD_INT 0
107063: ST_TO_ADDR
107064: GO 107080
// j := j + 1 ;
107066: LD_ADDR_VAR 0 3
107070: PUSH
107071: LD_VAR 0 3
107075: PUSH
107076: LD_INT 1
107078: PLUS
107079: ST_TO_ADDR
// SetSide ( i , j ) ;
107080: LD_VAR 0 2
107084: PPUSH
107085: LD_VAR 0 3
107089: PPUSH
107090: CALL_OW 235
// end ;
107094: GO 107017
107096: POP
107097: POP
// end ;
107098: LD_VAR 0 1
107102: RET
// export function hHackFog ; begin
107103: LD_INT 0
107105: PPUSH
// FogOff ( true ) ;
107106: LD_INT 1
107108: PPUSH
107109: CALL_OW 344
// end ;
107113: LD_VAR 0 1
107117: RET
// export function hHackTeleport ( unit , x , y ) ; begin
107118: LD_INT 0
107120: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
107121: LD_VAR 0 1
107125: PPUSH
107126: LD_VAR 0 2
107130: PPUSH
107131: LD_VAR 0 3
107135: PPUSH
107136: LD_INT 1
107138: PPUSH
107139: LD_INT 1
107141: PPUSH
107142: CALL_OW 483
// CenterOnXY ( x , y ) ;
107146: LD_VAR 0 2
107150: PPUSH
107151: LD_VAR 0 3
107155: PPUSH
107156: CALL_OW 84
// end ; end_of_file
107160: LD_VAR 0 4
107164: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
107165: LD_VAR 0 1
107169: PPUSH
107170: LD_VAR 0 2
107174: PPUSH
107175: LD_VAR 0 3
107179: PPUSH
107180: LD_VAR 0 4
107184: PPUSH
107185: LD_VAR 0 5
107189: PPUSH
107190: LD_VAR 0 6
107194: PPUSH
107195: CALL 93380 0 6
// end ;
107199: PPOPN 6
107201: END
