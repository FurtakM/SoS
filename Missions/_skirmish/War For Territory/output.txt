// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitGlobalVariables ;
  11: CALL 79173 0 0
// InitVariables ;
  15: CALL 214 0 0
// if debug then
  19: LD_EXP 1
  23: IFFALSE 42
// begin FogOff ( 1 ) ;
  25: LD_INT 1
  27: PPUSH
  28: CALL_OW 344
// Difficulty := 2 ;
  32: LD_ADDR_OWVAR 67
  36: PUSH
  37: LD_INT 2
  39: ST_TO_ADDR
// end else
  40: GO 55
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  42: LD_ADDR_OWVAR 67
  46: PUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL_OW 426
  54: ST_TO_ADDR
// ChangeSideFog ( 4 , 1 ) ;
  55: LD_INT 4
  57: PPUSH
  58: LD_INT 1
  60: PPUSH
  61: CALL_OW 343
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , gensher_ape , 0 ) ;
  65: LD_INT 0
  67: PPUSH
  68: LD_INT 0
  70: PPUSH
  71: LD_INT 5
  73: PPUSH
  74: LD_INT 0
  76: PPUSH
  77: LD_INT 0
  79: PPUSH
  80: LD_INT 0
  82: PPUSH
  83: LD_INT 0
  85: PPUSH
  86: LD_INT 7
  88: PPUSH
  89: LD_INT 0
  91: PPUSH
  92: CALL 43361 0 9
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , powell_ape , 0 ) ;
  96: LD_INT 0
  98: PPUSH
  99: LD_INT 0
 101: PPUSH
 102: LD_INT 3
 104: PPUSH
 105: LD_INT 0
 107: PPUSH
 108: LD_INT 0
 110: PPUSH
 111: LD_INT 0
 113: PPUSH
 114: LD_INT 0
 116: PPUSH
 117: LD_INT 4
 119: PPUSH
 120: LD_INT 0
 122: PPUSH
 123: CALL 43361 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , popov_ape , 0 ) ;
 127: LD_INT 0
 129: PPUSH
 130: LD_INT 0
 132: PPUSH
 133: LD_INT 5
 135: PPUSH
 136: LD_INT 0
 138: PPUSH
 139: LD_INT 0
 141: PPUSH
 142: LD_INT 0
 144: PPUSH
 145: LD_INT 0
 147: PPUSH
 148: LD_INT 11
 150: PPUSH
 151: LD_INT 0
 153: PPUSH
 154: CALL 43361 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , sikorski_ape , 0 ) ;
 158: LD_INT 0
 160: PPUSH
 161: LD_INT 0
 163: PPUSH
 164: LD_INT 5
 166: PPUSH
 167: LD_INT 0
 169: PPUSH
 170: LD_INT 0
 172: PPUSH
 173: LD_INT 0
 175: PPUSH
 176: LD_INT 0
 178: PPUSH
 179: LD_INT 14
 181: PPUSH
 182: LD_INT 0
 184: PPUSH
 185: CALL 43361 0 9
// PrepareGensher ;
 189: CALL 2779 0 0
// PreparePopov ;
 193: CALL 5625 0 0
// PreparePowell ;
 197: CALL 593 0 0
// PrepareSikorski ;
 201: CALL 8052 0 0
// MC_Start ( ) ;
 205: CALL 50917 0 0
// Action ;
 209: CALL 8459 0 0
// end ;
 213: END
// export debug , game , staticMines , arDestroyed , ruDestroyed , loseCounter , powellLoseCounter , powellInTrouble , sikorskiInTrouble ; function InitVariables ; begin
 214: LD_INT 0
 216: PPUSH
// debug := 0 ;
 217: LD_ADDR_EXP 1
 221: PUSH
 222: LD_INT 0
 224: ST_TO_ADDR
// game := true ;
 225: LD_ADDR_EXP 2
 229: PUSH
 230: LD_INT 1
 232: ST_TO_ADDR
// staticMines := [ ] ;
 233: LD_ADDR_EXP 3
 237: PUSH
 238: EMPTY
 239: ST_TO_ADDR
// arDestroyed := false ;
 240: LD_ADDR_EXP 4
 244: PUSH
 245: LD_INT 0
 247: ST_TO_ADDR
// ruDestroyed := false ;
 248: LD_ADDR_EXP 5
 252: PUSH
 253: LD_INT 0
 255: ST_TO_ADDR
// powellInTrouble := false ;
 256: LD_ADDR_EXP 8
 260: PUSH
 261: LD_INT 0
 263: ST_TO_ADDR
// sikorskiInTrouble := false ;
 264: LD_ADDR_EXP 9
 268: PUSH
 269: LD_INT 0
 271: ST_TO_ADDR
// end ;
 272: LD_VAR 0 1
 276: RET
// export function CustomInitMacro ; begin
 277: LD_INT 0
 279: PPUSH
// InitMC_Gensher ( ) ;
 280: CALL 3324 0 0
// InitMC_Powell ( ) ;
 284: CALL 815 0 0
// InitMC_Popov ( ) ;
 288: CALL 5984 0 0
// end ;
 292: LD_VAR 0 1
 296: RET
// every 0 0$10 do var cr , time , i ;
 297: GO 299
 299: DISABLE
 300: LD_INT 0
 302: PPUSH
 303: PPUSH
 304: PPUSH
// begin time := 0 0$20 ;
 305: LD_ADDR_VAR 0 2
 309: PUSH
 310: LD_INT 700
 312: ST_TO_ADDR
// repeat wait ( time ) ;
 313: LD_VAR 0 2
 317: PPUSH
 318: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
 322: LD_ADDR_VAR 0 1
 326: PUSH
 327: LD_INT 1
 329: PPUSH
 330: LD_INT 5
 332: PPUSH
 333: CALL_OW 12
 337: ST_TO_ADDR
// for i in [ powell_crates , gensher_crates , popov_crates , sikorski_crates ] do
 338: LD_ADDR_VAR 0 3
 342: PUSH
 343: LD_INT 5
 345: PUSH
 346: LD_INT 8
 348: PUSH
 349: LD_INT 12
 351: PUSH
 352: LD_INT 13
 354: PUSH
 355: EMPTY
 356: LIST
 357: LIST
 358: LIST
 359: LIST
 360: PUSH
 361: FOR_IN
 362: IFFALSE 416
// begin if GetResourceArea ( i , mat_cans ) < 40 then
 364: LD_VAR 0 3
 368: PPUSH
 369: LD_INT 1
 371: PPUSH
 372: CALL_OW 287
 376: PUSH
 377: LD_INT 40
 379: LESS
 380: IFFALSE 399
// CreateCratesArea ( cr , i , true ) ;
 382: LD_VAR 0 1
 386: PPUSH
 387: LD_VAR 0 3
 391: PPUSH
 392: LD_INT 1
 394: PPUSH
 395: CALL_OW 55
// wait ( rand ( 0 0$5 , 0 0$15 ) ) ;
 399: LD_INT 175
 401: PPUSH
 402: LD_INT 525
 404: PPUSH
 405: CALL_OW 12
 409: PPUSH
 410: CALL_OW 67
// end ;
 414: GO 361
 416: POP
 417: POP
// time := time + 0 0$2 ;
 418: LD_ADDR_VAR 0 2
 422: PUSH
 423: LD_VAR 0 2
 427: PUSH
 428: LD_INT 70
 430: PLUS
 431: ST_TO_ADDR
// if time > 0 0$35 then
 432: LD_VAR 0 2
 436: PUSH
 437: LD_INT 1225
 439: GREATER
 440: IFFALSE 450
// time := 0 0$25 ;
 442: LD_ADDR_VAR 0 2
 446: PUSH
 447: LD_INT 875
 449: ST_TO_ADDR
// until not game ;
 450: LD_EXP 2
 454: NOT
 455: IFFALSE 313
// end ;
 457: PPOPN 3
 459: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
 460: LD_INT 3
 462: PUSH
 463: LD_INT 22
 465: PUSH
 466: LD_INT 1
 468: PUSH
 469: EMPTY
 470: LIST
 471: LIST
 472: PUSH
 473: EMPTY
 474: LIST
 475: LIST
 476: PUSH
 477: LD_INT 32
 479: PUSH
 480: LD_INT 1
 482: PUSH
 483: EMPTY
 484: LIST
 485: LIST
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: PPUSH
 491: CALL_OW 69
 495: IFFALSE 590
 497: GO 499
 499: DISABLE
 500: LD_INT 0
 502: PPUSH
 503: PPUSH
// begin enable ;
 504: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
 505: LD_ADDR_VAR 0 2
 509: PUSH
 510: LD_INT 3
 512: PUSH
 513: LD_INT 22
 515: PUSH
 516: LD_INT 1
 518: PUSH
 519: EMPTY
 520: LIST
 521: LIST
 522: PUSH
 523: EMPTY
 524: LIST
 525: LIST
 526: PUSH
 527: LD_INT 32
 529: PUSH
 530: LD_INT 1
 532: PUSH
 533: EMPTY
 534: LIST
 535: LIST
 536: PUSH
 537: EMPTY
 538: LIST
 539: LIST
 540: PPUSH
 541: CALL_OW 69
 545: ST_TO_ADDR
// for i in tmp do
 546: LD_ADDR_VAR 0 1
 550: PUSH
 551: LD_VAR 0 2
 555: PUSH
 556: FOR_IN
 557: IFFALSE 588
// if GetFuel ( i ) < 5 then
 559: LD_VAR 0 1
 563: PPUSH
 564: CALL_OW 261
 568: PUSH
 569: LD_INT 5
 571: LESS
 572: IFFALSE 586
// SetFuel ( i , 5 ) ;
 574: LD_VAR 0 1
 578: PPUSH
 579: LD_INT 5
 581: PPUSH
 582: CALL_OW 240
 586: GO 556
 588: POP
 589: POP
// end ; end_of_file
 590: PPOPN 2
 592: END
// export Powell , powell_side , powellAttackGroup ; export function PreparePowell ; var i , tmp ; begin
 593: LD_INT 0
 595: PPUSH
 596: PPUSH
 597: PPUSH
// powell_side := 4 ;
 598: LD_ADDR_EXP 11
 602: PUSH
 603: LD_INT 4
 605: ST_TO_ADDR
// uc_side := powell_side ;
 606: LD_ADDR_OWVAR 20
 610: PUSH
 611: LD_EXP 11
 615: ST_TO_ADDR
// uc_nation := 1 ;
 616: LD_ADDR_OWVAR 21
 620: PUSH
 621: LD_INT 1
 623: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
 624: LD_ADDR_EXP 10
 628: PUSH
 629: LD_STRING Powell
 631: PPUSH
 632: CALL_OW 25
 636: ST_TO_ADDR
// SetSkill ( Powell , 1 , 7 ) ;
 637: LD_EXP 10
 641: PPUSH
 642: LD_INT 1
 644: PPUSH
 645: LD_INT 7
 647: PPUSH
 648: CALL_OW 237
// SetSkill ( Powell , 2 , 5 ) ;
 652: LD_EXP 10
 656: PPUSH
 657: LD_INT 2
 659: PPUSH
 660: LD_INT 5
 662: PPUSH
 663: CALL_OW 237
// SetSkill ( Powell , 3 , 6 ) ;
 667: LD_EXP 10
 671: PPUSH
 672: LD_INT 3
 674: PPUSH
 675: LD_INT 6
 677: PPUSH
 678: CALL_OW 237
// SetSkill ( Powell , 4 , 4 ) ;
 682: LD_EXP 10
 686: PPUSH
 687: LD_INT 4
 689: PPUSH
 690: LD_INT 4
 692: PPUSH
 693: CALL_OW 237
// PlaceHumanInUnit ( Powell , us_depot ) ;
 697: LD_EXP 10
 701: PPUSH
 702: LD_INT 4
 704: PPUSH
 705: CALL_OW 52
// tmp := PrepareBase ( us_depot , powell_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 5500 , 500 , 0 ] , [ 6 , 6 , 6 , 6 ] ) ;
 709: LD_ADDR_VAR 0 3
 713: PUSH
 714: LD_INT 4
 716: PPUSH
 717: LD_INT 1
 719: PPUSH
 720: LD_STRING 
 722: PPUSH
 723: LD_INT 8
 725: PUSH
 726: LD_INT 7
 728: PUSH
 729: LD_INT 6
 731: PUSH
 732: EMPTY
 733: LIST
 734: LIST
 735: LIST
 736: PUSH
 737: LD_OWVAR 67
 741: ARRAY
 742: PPUSH
 743: LD_INT 5500
 745: PUSH
 746: LD_INT 500
 748: PUSH
 749: LD_INT 0
 751: PUSH
 752: EMPTY
 753: LIST
 754: LIST
 755: LIST
 756: PPUSH
 757: LD_INT 6
 759: PUSH
 760: LD_INT 6
 762: PUSH
 763: LD_INT 6
 765: PUSH
 766: LD_INT 6
 768: PUSH
 769: EMPTY
 770: LIST
 771: LIST
 772: LIST
 773: LIST
 774: PPUSH
 775: CALL 18308 0 6
 779: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , tmp ) ;
 780: LD_ADDR_EXP 23
 784: PUSH
 785: LD_EXP 23
 789: PPUSH
 790: LD_INT 1
 792: PPUSH
 793: LD_VAR 0 3
 797: PPUSH
 798: CALL_OW 1
 802: ST_TO_ADDR
// powellAttackGroup := [ ] ;
 803: LD_ADDR_EXP 12
 807: PUSH
 808: EMPTY
 809: ST_TO_ADDR
// end ;
 810: LD_VAR 0 1
 814: RET
// export function InitMC_Powell ( ) ; begin
 815: LD_INT 0
 817: PPUSH
// MC_SetScanArea ( 1 , powell_base ) ;
 818: LD_INT 1
 820: PPUSH
 821: LD_INT 1
 823: PPUSH
 824: CALL 74040 0 2
// MC_SetParkingArea ( 1 , powell_parking ) ;
 828: LD_INT 1
 830: PPUSH
 831: LD_INT 6
 833: PPUSH
 834: CALL 73984 0 2
// MC_SetDepositsXY ( 1 , [ [ 167 , 102 , 0 ] , [ 173 , 83 , 1 ] , [ 171 , 141 , 0 ] , [ 178 , 148 , 1 ] ] ) ;
 838: LD_INT 1
 840: PPUSH
 841: LD_INT 167
 843: PUSH
 844: LD_INT 102
 846: PUSH
 847: LD_INT 0
 849: PUSH
 850: EMPTY
 851: LIST
 852: LIST
 853: LIST
 854: PUSH
 855: LD_INT 173
 857: PUSH
 858: LD_INT 83
 860: PUSH
 861: LD_INT 1
 863: PUSH
 864: EMPTY
 865: LIST
 866: LIST
 867: LIST
 868: PUSH
 869: LD_INT 171
 871: PUSH
 872: LD_INT 141
 874: PUSH
 875: LD_INT 0
 877: PUSH
 878: EMPTY
 879: LIST
 880: LIST
 881: LIST
 882: PUSH
 883: LD_INT 178
 885: PUSH
 886: LD_INT 148
 888: PUSH
 889: LD_INT 1
 891: PUSH
 892: EMPTY
 893: LIST
 894: LIST
 895: LIST
 896: PUSH
 897: EMPTY
 898: LIST
 899: LIST
 900: LIST
 901: LIST
 902: PPUSH
 903: CALL 73043 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ us_radar , us_heavy_gun , us_rocket_launcher ] ) ;
 907: LD_INT 1
 909: PPUSH
 910: LD_INT 11
 912: PUSH
 913: LD_INT 6
 915: PUSH
 916: LD_INT 7
 918: PUSH
 919: EMPTY
 920: LIST
 921: LIST
 922: LIST
 923: PPUSH
 924: CALL 73872 0 2
// MC_SetCratesArea ( 1 , powell_crates ) ;
 928: LD_INT 1
 930: PPUSH
 931: LD_INT 5
 933: PPUSH
 934: CALL 73554 0 2
// MC_SetTame ( 1 , powell_ape ) ;
 938: LD_INT 1
 940: PPUSH
 941: LD_INT 4
 943: PPUSH
 944: CALL 73285 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 948: LD_INT 1
 950: PPUSH
 951: LD_INT 4
 953: PPUSH
 954: CALL 72904 0 2
// MC_SetProduceList ( 1 , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ] ) ;
 958: LD_INT 1
 960: PPUSH
 961: LD_INT 3
 963: PUSH
 964: LD_INT 1
 966: PUSH
 967: LD_INT 2
 969: PUSH
 970: LD_INT 5
 972: PUSH
 973: EMPTY
 974: LIST
 975: LIST
 976: LIST
 977: LIST
 978: PUSH
 979: LD_INT 4
 981: PUSH
 982: LD_INT 1
 984: PUSH
 985: LD_INT 2
 987: PUSH
 988: LD_INT 6
 990: PUSH
 991: EMPTY
 992: LIST
 993: LIST
 994: LIST
 995: LIST
 996: PUSH
 997: LD_INT 4
 999: PUSH
1000: LD_INT 1
1002: PUSH
1003: LD_INT 2
1005: PUSH
1006: LD_INT 7
1008: PUSH
1009: EMPTY
1010: LIST
1011: LIST
1012: LIST
1013: LIST
1014: PUSH
1015: LD_INT 4
1017: PUSH
1018: LD_INT 1
1020: PUSH
1021: LD_INT 2
1023: PUSH
1024: LD_INT 6
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: LIST
1031: LIST
1032: PUSH
1033: EMPTY
1034: LIST
1035: LIST
1036: LIST
1037: LIST
1038: PPUSH
1039: CALL 72719 0 2
// MC_SetBuildingList ( 1 , [ [ b_armoury , 178 , 117 , 2 ] , [ b_oil_mine , 167 , 102 , 0 ] , [ b_lab , 200 , 111 , 4 ] , [ b_workshop , 201 , 140 , 4 ] , [ b_solar_power , 206 , 124 , 3 ] , [ b_solar_power , 209 , 128 , 3 ] , [ b_solar_power , 211 , 132 , 3 ] , [ b_siberite_mine , 173 , 83 , 3 ] , [ b_lab , 186 , 103 , 2 ] , [ b_turret , 173 , 99 , 2 ] , [ b_bunker , 174 , 102 , 2 ] , [ b_bunker , 178 , 100 , 2 ] , [ b_turret , 174 , 108 , 1 ] , [ b_turret , 182 , 122 , 1 ] , [ b_control_tower , 194 , 124 , 5 ] , [ b_turret , 184 , 141 , 1 ] , [ b_turret , 183 , 131 , 2 ] , [ b_turret , 194 , 146 , 4 ] , [ b_turret , 190 , 142 , 4 ] , [ b_siberite_power , 204 , 133 , 3 ] , [ b_solar_power , 201 , 133 , 3 ] , [ b_siberite_power , 199 , 119 , 5 ] ] ) ;
1043: LD_INT 1
1045: PPUSH
1046: LD_INT 4
1048: PUSH
1049: LD_INT 178
1051: PUSH
1052: LD_INT 117
1054: PUSH
1055: LD_INT 2
1057: PUSH
1058: EMPTY
1059: LIST
1060: LIST
1061: LIST
1062: LIST
1063: PUSH
1064: LD_INT 29
1066: PUSH
1067: LD_INT 167
1069: PUSH
1070: LD_INT 102
1072: PUSH
1073: LD_INT 0
1075: PUSH
1076: EMPTY
1077: LIST
1078: LIST
1079: LIST
1080: LIST
1081: PUSH
1082: LD_INT 6
1084: PUSH
1085: LD_INT 200
1087: PUSH
1088: LD_INT 111
1090: PUSH
1091: LD_INT 4
1093: PUSH
1094: EMPTY
1095: LIST
1096: LIST
1097: LIST
1098: LIST
1099: PUSH
1100: LD_INT 2
1102: PUSH
1103: LD_INT 201
1105: PUSH
1106: LD_INT 140
1108: PUSH
1109: LD_INT 4
1111: PUSH
1112: EMPTY
1113: LIST
1114: LIST
1115: LIST
1116: LIST
1117: PUSH
1118: LD_INT 27
1120: PUSH
1121: LD_INT 206
1123: PUSH
1124: LD_INT 124
1126: PUSH
1127: LD_INT 3
1129: PUSH
1130: EMPTY
1131: LIST
1132: LIST
1133: LIST
1134: LIST
1135: PUSH
1136: LD_INT 27
1138: PUSH
1139: LD_INT 209
1141: PUSH
1142: LD_INT 128
1144: PUSH
1145: LD_INT 3
1147: PUSH
1148: EMPTY
1149: LIST
1150: LIST
1151: LIST
1152: LIST
1153: PUSH
1154: LD_INT 27
1156: PUSH
1157: LD_INT 211
1159: PUSH
1160: LD_INT 132
1162: PUSH
1163: LD_INT 3
1165: PUSH
1166: EMPTY
1167: LIST
1168: LIST
1169: LIST
1170: LIST
1171: PUSH
1172: LD_INT 30
1174: PUSH
1175: LD_INT 173
1177: PUSH
1178: LD_INT 83
1180: PUSH
1181: LD_INT 3
1183: PUSH
1184: EMPTY
1185: LIST
1186: LIST
1187: LIST
1188: LIST
1189: PUSH
1190: LD_INT 6
1192: PUSH
1193: LD_INT 186
1195: PUSH
1196: LD_INT 103
1198: PUSH
1199: LD_INT 2
1201: PUSH
1202: EMPTY
1203: LIST
1204: LIST
1205: LIST
1206: LIST
1207: PUSH
1208: LD_INT 33
1210: PUSH
1211: LD_INT 173
1213: PUSH
1214: LD_INT 99
1216: PUSH
1217: LD_INT 2
1219: PUSH
1220: EMPTY
1221: LIST
1222: LIST
1223: LIST
1224: LIST
1225: PUSH
1226: LD_INT 32
1228: PUSH
1229: LD_INT 174
1231: PUSH
1232: LD_INT 102
1234: PUSH
1235: LD_INT 2
1237: PUSH
1238: EMPTY
1239: LIST
1240: LIST
1241: LIST
1242: LIST
1243: PUSH
1244: LD_INT 32
1246: PUSH
1247: LD_INT 178
1249: PUSH
1250: LD_INT 100
1252: PUSH
1253: LD_INT 2
1255: PUSH
1256: EMPTY
1257: LIST
1258: LIST
1259: LIST
1260: LIST
1261: PUSH
1262: LD_INT 33
1264: PUSH
1265: LD_INT 174
1267: PUSH
1268: LD_INT 108
1270: PUSH
1271: LD_INT 1
1273: PUSH
1274: EMPTY
1275: LIST
1276: LIST
1277: LIST
1278: LIST
1279: PUSH
1280: LD_INT 33
1282: PUSH
1283: LD_INT 182
1285: PUSH
1286: LD_INT 122
1288: PUSH
1289: LD_INT 1
1291: PUSH
1292: EMPTY
1293: LIST
1294: LIST
1295: LIST
1296: LIST
1297: PUSH
1298: LD_INT 36
1300: PUSH
1301: LD_INT 194
1303: PUSH
1304: LD_INT 124
1306: PUSH
1307: LD_INT 5
1309: PUSH
1310: EMPTY
1311: LIST
1312: LIST
1313: LIST
1314: LIST
1315: PUSH
1316: LD_INT 33
1318: PUSH
1319: LD_INT 184
1321: PUSH
1322: LD_INT 141
1324: PUSH
1325: LD_INT 1
1327: PUSH
1328: EMPTY
1329: LIST
1330: LIST
1331: LIST
1332: LIST
1333: PUSH
1334: LD_INT 33
1336: PUSH
1337: LD_INT 183
1339: PUSH
1340: LD_INT 131
1342: PUSH
1343: LD_INT 2
1345: PUSH
1346: EMPTY
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: PUSH
1352: LD_INT 33
1354: PUSH
1355: LD_INT 194
1357: PUSH
1358: LD_INT 146
1360: PUSH
1361: LD_INT 4
1363: PUSH
1364: EMPTY
1365: LIST
1366: LIST
1367: LIST
1368: LIST
1369: PUSH
1370: LD_INT 33
1372: PUSH
1373: LD_INT 190
1375: PUSH
1376: LD_INT 142
1378: PUSH
1379: LD_INT 4
1381: PUSH
1382: EMPTY
1383: LIST
1384: LIST
1385: LIST
1386: LIST
1387: PUSH
1388: LD_INT 28
1390: PUSH
1391: LD_INT 204
1393: PUSH
1394: LD_INT 133
1396: PUSH
1397: LD_INT 3
1399: PUSH
1400: EMPTY
1401: LIST
1402: LIST
1403: LIST
1404: LIST
1405: PUSH
1406: LD_INT 27
1408: PUSH
1409: LD_INT 201
1411: PUSH
1412: LD_INT 133
1414: PUSH
1415: LD_INT 3
1417: PUSH
1418: EMPTY
1419: LIST
1420: LIST
1421: LIST
1422: LIST
1423: PUSH
1424: LD_INT 28
1426: PUSH
1427: LD_INT 199
1429: PUSH
1430: LD_INT 119
1432: PUSH
1433: LD_INT 5
1435: PUSH
1436: EMPTY
1437: LIST
1438: LIST
1439: LIST
1440: LIST
1441: PUSH
1442: EMPTY
1443: LIST
1444: LIST
1445: LIST
1446: LIST
1447: LIST
1448: LIST
1449: LIST
1450: LIST
1451: LIST
1452: LIST
1453: LIST
1454: LIST
1455: LIST
1456: LIST
1457: LIST
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: LIST
1463: LIST
1464: LIST
1465: PPUSH
1466: CALL 72611 0 2
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_opto , b_lab_computer , b_lab_siberium ] ) ;
1470: LD_INT 1
1472: PPUSH
1473: LD_INT 10
1475: PUSH
1476: LD_INT 15
1478: PUSH
1479: LD_INT 12
1481: PUSH
1482: LD_INT 11
1484: PUSH
1485: EMPTY
1486: LIST
1487: LIST
1488: LIST
1489: LIST
1490: PPUSH
1491: CALL 73461 0 2
// MC_SetFactoryExtension ( 1 , 201 , 140 , 4 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1495: LD_INT 1
1497: PPUSH
1498: LD_INT 201
1500: PPUSH
1501: LD_INT 140
1503: PPUSH
1504: LD_INT 4
1506: PPUSH
1507: LD_INT 19
1509: PUSH
1510: LD_INT 16
1512: PUSH
1513: LD_INT 17
1515: PUSH
1516: LD_INT 18
1518: PUSH
1519: LD_INT 22
1521: PUSH
1522: EMPTY
1523: LIST
1524: LIST
1525: LIST
1526: LIST
1527: LIST
1528: PPUSH
1529: CALL 73666 0 5
// MC_SetUpgradeBuilding ( 1 , b_depot ) ;
1533: LD_INT 1
1535: PPUSH
1536: LD_INT 0
1538: PPUSH
1539: CALL 73334 0 2
// end ;
1543: LD_VAR 0 1
1547: RET
// every 8 8$00 + 2 2$00 trigger IsOk ( us_depot ) do var i , base , tmp , attackers , amount ;
1548: LD_INT 4
1550: PPUSH
1551: CALL_OW 302
1555: IFFALSE 2215
1557: GO 1559
1559: DISABLE
1560: LD_INT 0
1562: PPUSH
1563: PPUSH
1564: PPUSH
1565: PPUSH
1566: PPUSH
// begin enable ;
1567: ENABLE
// base := 1 ;
1568: LD_ADDR_VAR 0 2
1572: PUSH
1573: LD_INT 1
1575: ST_TO_ADDR
// tmp := [ [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ] ;
1576: LD_ADDR_VAR 0 3
1580: PUSH
1581: LD_INT 4
1583: PUSH
1584: LD_INT 1
1586: PUSH
1587: LD_INT 2
1589: PUSH
1590: LD_INT 6
1592: PUSH
1593: EMPTY
1594: LIST
1595: LIST
1596: LIST
1597: LIST
1598: PUSH
1599: LD_INT 4
1601: PUSH
1602: LD_INT 1
1604: PUSH
1605: LD_INT 2
1607: PUSH
1608: LD_INT 6
1610: PUSH
1611: EMPTY
1612: LIST
1613: LIST
1614: LIST
1615: LIST
1616: PUSH
1617: LD_INT 3
1619: PUSH
1620: LD_INT 1
1622: PUSH
1623: LD_INT 2
1625: PUSH
1626: LD_INT 7
1628: PUSH
1629: EMPTY
1630: LIST
1631: LIST
1632: LIST
1633: LIST
1634: PUSH
1635: LD_INT 3
1637: PUSH
1638: LD_INT 1
1640: PUSH
1641: LD_INT 2
1643: PUSH
1644: LD_INT 7
1646: PUSH
1647: EMPTY
1648: LIST
1649: LIST
1650: LIST
1651: LIST
1652: PUSH
1653: EMPTY
1654: LIST
1655: LIST
1656: LIST
1657: LIST
1658: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
1659: LD_ADDR_VAR 0 5
1663: PUSH
1664: LD_VAR 0 5
1668: PUSH
1669: LD_OWVAR 1
1673: PUSH
1674: LD_INT 21000
1676: DIV
1677: PLUS
1678: ST_TO_ADDR
// if amount > 8 then
1679: LD_VAR 0 5
1683: PUSH
1684: LD_INT 8
1686: GREATER
1687: IFFALSE 1697
// amount := 8 ;
1689: LD_ADDR_VAR 0 5
1693: PUSH
1694: LD_INT 8
1696: ST_TO_ADDR
// for i = 1 to amount do
1697: LD_ADDR_VAR 0 1
1701: PUSH
1702: DOUBLE
1703: LD_INT 1
1705: DEC
1706: ST_TO_ADDR
1707: LD_VAR 0 5
1711: PUSH
1712: FOR_TO
1713: IFFALSE 1797
// tmp := Insert ( tmp , tmp + 1 , [ [ us_medium_tracked , us_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ us_rocket_launcher , us_double_gun ] [ rand ( 1 , 2 ) ] ] ) ;
1715: LD_ADDR_VAR 0 3
1719: PUSH
1720: LD_VAR 0 3
1724: PPUSH
1725: LD_VAR 0 3
1729: PUSH
1730: LD_INT 1
1732: PLUS
1733: PPUSH
1734: LD_INT 3
1736: PUSH
1737: LD_INT 4
1739: PUSH
1740: EMPTY
1741: LIST
1742: LIST
1743: PUSH
1744: LD_INT 1
1746: PPUSH
1747: LD_INT 2
1749: PPUSH
1750: CALL_OW 12
1754: ARRAY
1755: PUSH
1756: LD_INT 1
1758: PUSH
1759: LD_INT 2
1761: PUSH
1762: LD_INT 7
1764: PUSH
1765: LD_INT 5
1767: PUSH
1768: EMPTY
1769: LIST
1770: LIST
1771: PUSH
1772: LD_INT 1
1774: PPUSH
1775: LD_INT 2
1777: PPUSH
1778: CALL_OW 12
1782: ARRAY
1783: PUSH
1784: EMPTY
1785: LIST
1786: LIST
1787: LIST
1788: LIST
1789: PPUSH
1790: CALL_OW 2
1794: ST_TO_ADDR
1795: GO 1712
1797: POP
1798: POP
// MC_InsertProduceList ( base , tmp ) ;
1799: LD_VAR 0 2
1803: PPUSH
1804: LD_VAR 0 3
1808: PPUSH
1809: CALL 72767 0 2
// repeat wait ( 0 0$1 ) ;
1813: LD_INT 35
1815: PPUSH
1816: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
1820: LD_VAR 0 2
1824: PPUSH
1825: LD_INT 1
1827: PPUSH
1828: CALL 74185 0 2
1832: PUSH
1833: LD_VAR 0 5
1837: GREATEREQUAL
1838: IFFALSE 1813
// wait ( 0 0$30 ) ;
1840: LD_INT 1050
1842: PPUSH
1843: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , us_bulldozer ] ] ) ;
1847: LD_ADDR_VAR 0 4
1851: PUSH
1852: LD_EXP 42
1856: PUSH
1857: LD_VAR 0 2
1861: ARRAY
1862: PUSH
1863: LD_EXP 42
1867: PUSH
1868: LD_VAR 0 2
1872: ARRAY
1873: PPUSH
1874: LD_INT 2
1876: PUSH
1877: LD_INT 34
1879: PUSH
1880: LD_INT 12
1882: PUSH
1883: EMPTY
1884: LIST
1885: LIST
1886: PUSH
1887: LD_INT 34
1889: PUSH
1890: LD_INT 13
1892: PUSH
1893: EMPTY
1894: LIST
1895: LIST
1896: PUSH
1897: LD_INT 34
1899: PUSH
1900: LD_INT 14
1902: PUSH
1903: EMPTY
1904: LIST
1905: LIST
1906: PUSH
1907: EMPTY
1908: LIST
1909: LIST
1910: LIST
1911: LIST
1912: PPUSH
1913: CALL_OW 72
1917: DIFF
1918: ST_TO_ADDR
// if not attackers then
1919: LD_VAR 0 4
1923: NOT
1924: IFFALSE 1928
// exit ;
1926: GO 2215
// DialogPowellsAttack ;
1928: CALL 8590 0 0
// powellAttackGroup := attackers ;
1932: LD_ADDR_EXP 12
1936: PUSH
1937: LD_VAR 0 4
1941: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
1942: LD_ADDR_EXP 42
1946: PUSH
1947: LD_EXP 42
1951: PPUSH
1952: LD_VAR 0 2
1956: PPUSH
1957: LD_EXP 42
1961: PUSH
1962: LD_VAR 0 2
1966: ARRAY
1967: PUSH
1968: LD_VAR 0 4
1972: DIFF
1973: PPUSH
1974: CALL_OW 1
1978: ST_TO_ADDR
// if sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 4 ] ) then
1979: LD_EXP 9
1983: PUSH
1984: LD_INT 16
1986: PPUSH
1987: LD_INT 81
1989: PUSH
1990: LD_INT 4
1992: PUSH
1993: EMPTY
1994: LIST
1995: LIST
1996: PPUSH
1997: CALL_OW 70
2001: AND
2002: IFFALSE 2021
// ComAgressiveMove ( attackers , 135 , 21 ) else
2004: LD_VAR 0 4
2008: PPUSH
2009: LD_INT 135
2011: PPUSH
2012: LD_INT 21
2014: PPUSH
2015: CALL_OW 114
2019: GO 2036
// ComAgressiveMove ( attackers , 146 , 103 ) ;
2021: LD_VAR 0 4
2025: PPUSH
2026: LD_INT 146
2028: PPUSH
2029: LD_INT 103
2031: PPUSH
2032: CALL_OW 114
// wait ( 0 0$5 ) ;
2036: LD_INT 175
2038: PPUSH
2039: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
2043: LD_INT 35
2045: PPUSH
2046: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
2050: LD_VAR 0 4
2054: PPUSH
2055: LD_INT 60
2057: PUSH
2058: EMPTY
2059: LIST
2060: PPUSH
2061: CALL_OW 72
2065: NOT
2066: IFFALSE 2043
// if FilterAllUnits ( [ f_side , 3 ] ) then
2068: LD_INT 22
2070: PUSH
2071: LD_INT 3
2073: PUSH
2074: EMPTY
2075: LIST
2076: LIST
2077: PPUSH
2078: CALL_OW 69
2082: IFFALSE 2101
// ComAgressiveMove ( attackers , 102 , 116 ) else
2084: LD_VAR 0 4
2088: PPUSH
2089: LD_INT 102
2091: PPUSH
2092: LD_INT 116
2094: PPUSH
2095: CALL_OW 114
2099: GO 2116
// ComAgressiveMove ( attackers , 66 , 41 ) ;
2101: LD_VAR 0 4
2105: PPUSH
2106: LD_INT 66
2108: PPUSH
2109: LD_INT 41
2111: PPUSH
2112: CALL_OW 114
// wait ( 0 0$10 ) ;
2116: LD_INT 350
2118: PPUSH
2119: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
2123: LD_INT 35
2125: PPUSH
2126: CALL_OW 67
// for i in attackers do
2130: LD_ADDR_VAR 0 1
2134: PUSH
2135: LD_VAR 0 4
2139: PUSH
2140: FOR_IN
2141: IFFALSE 2191
// if not HasTask ( i ) then
2143: LD_VAR 0 1
2147: PPUSH
2148: CALL_OW 314
2152: NOT
2153: IFFALSE 2189
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) ;
2155: LD_VAR 0 1
2159: PPUSH
2160: LD_INT 81
2162: PUSH
2163: LD_INT 4
2165: PUSH
2166: EMPTY
2167: LIST
2168: LIST
2169: PPUSH
2170: CALL_OW 69
2174: PPUSH
2175: LD_VAR 0 1
2179: PPUSH
2180: CALL_OW 74
2184: PPUSH
2185: CALL_OW 115
2189: GO 2140
2191: POP
2192: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
2193: LD_VAR 0 4
2197: PPUSH
2198: LD_INT 50
2200: PUSH
2201: EMPTY
2202: LIST
2203: PPUSH
2204: CALL_OW 72
2208: NOT
2209: IFFALSE 2123
// DialogPowellsAttackFailed ;
2211: CALL 8855 0 0
// end ;
2215: PPOPN 5
2217: END
// every 0 0$2 do var vehicles , mechs , i ;
2218: GO 2220
2220: DISABLE
2221: LD_INT 0
2223: PPUSH
2224: PPUSH
2225: PPUSH
// begin enable ;
2226: ENABLE
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] , [ f_distxy , 191 , 140 , 10 ] ] ) ;
2227: LD_ADDR_VAR 0 1
2231: PUSH
2232: LD_INT 22
2234: PUSH
2235: LD_INT 1
2237: PUSH
2238: EMPTY
2239: LIST
2240: LIST
2241: PUSH
2242: LD_INT 21
2244: PUSH
2245: LD_INT 2
2247: PUSH
2248: EMPTY
2249: LIST
2250: LIST
2251: PUSH
2252: LD_INT 3
2254: PUSH
2255: LD_INT 24
2257: PUSH
2258: LD_INT 1000
2260: PUSH
2261: EMPTY
2262: LIST
2263: LIST
2264: PUSH
2265: EMPTY
2266: LIST
2267: LIST
2268: PUSH
2269: LD_INT 92
2271: PUSH
2272: LD_INT 191
2274: PUSH
2275: LD_INT 140
2277: PUSH
2278: LD_INT 10
2280: PUSH
2281: EMPTY
2282: LIST
2283: LIST
2284: LIST
2285: LIST
2286: PUSH
2287: EMPTY
2288: LIST
2289: LIST
2290: LIST
2291: LIST
2292: PPUSH
2293: CALL_OW 69
2297: ST_TO_ADDR
// mechs := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 3 ] ] ) ;
2298: LD_ADDR_VAR 0 2
2302: PUSH
2303: LD_INT 22
2305: PUSH
2306: LD_INT 4
2308: PUSH
2309: EMPTY
2310: LIST
2311: LIST
2312: PUSH
2313: LD_INT 25
2315: PUSH
2316: LD_INT 3
2318: PUSH
2319: EMPTY
2320: LIST
2321: LIST
2322: PUSH
2323: EMPTY
2324: LIST
2325: LIST
2326: PPUSH
2327: CALL_OW 69
2331: ST_TO_ADDR
// if not mechs then
2332: LD_VAR 0 2
2336: NOT
2337: IFFALSE 2341
// exit ;
2339: GO 2515
// if mc_remote_driver [ 1 ] then
2341: LD_EXP 63
2345: PUSH
2346: LD_INT 1
2348: ARRAY
2349: IFFALSE 2371
// mechs := mechs diff mc_remote_driver [ 1 ] ;
2351: LD_ADDR_VAR 0 2
2355: PUSH
2356: LD_VAR 0 2
2360: PUSH
2361: LD_EXP 63
2365: PUSH
2366: LD_INT 1
2368: ARRAY
2369: DIFF
2370: ST_TO_ADDR
// if not mechs then
2371: LD_VAR 0 2
2375: NOT
2376: IFFALSE 2380
// exit ;
2378: GO 2515
// if vehicles then
2380: LD_VAR 0 1
2384: IFFALSE 2472
// begin for i in mechs do
2386: LD_ADDR_VAR 0 3
2390: PUSH
2391: LD_VAR 0 2
2395: PUSH
2396: FOR_IN
2397: IFFALSE 2468
// begin if GetTag ( i ) <> 120 then
2399: LD_VAR 0 3
2403: PPUSH
2404: CALL_OW 110
2408: PUSH
2409: LD_INT 120
2411: NONEQUAL
2412: IFFALSE 2426
// SetTag ( i , 120 ) ;
2414: LD_VAR 0 3
2418: PPUSH
2419: LD_INT 120
2421: PPUSH
2422: CALL_OW 109
// if IsInUnit ( i ) then
2426: LD_VAR 0 3
2430: PPUSH
2431: CALL_OW 310
2435: IFFALSE 2448
// ComExitBuilding ( i ) else
2437: LD_VAR 0 3
2441: PPUSH
2442: CALL_OW 122
2446: GO 2466
// ComRepairVehicle ( i , vehicles [ 1 ] ) ;
2448: LD_VAR 0 3
2452: PPUSH
2453: LD_VAR 0 1
2457: PUSH
2458: LD_INT 1
2460: ARRAY
2461: PPUSH
2462: CALL_OW 129
// end ;
2466: GO 2396
2468: POP
2469: POP
// end else
2470: GO 2515
// if FilterByTag ( mechs , 120 ) then
2472: LD_VAR 0 2
2476: PPUSH
2477: LD_INT 120
2479: PPUSH
2480: CALL 44253 0 2
2484: IFFALSE 2515
// begin for i in mechs do
2486: LD_ADDR_VAR 0 3
2490: PUSH
2491: LD_VAR 0 2
2495: PUSH
2496: FOR_IN
2497: IFFALSE 2513
// begin SetTag ( i , 0 ) ;
2499: LD_VAR 0 3
2503: PPUSH
2504: LD_INT 0
2506: PPUSH
2507: CALL_OW 109
// end ;
2511: GO 2496
2513: POP
2514: POP
// end ; end ;
2515: PPOPN 3
2517: END
// every 0 0$2 do var people , sci , i ;
2518: GO 2520
2520: DISABLE
2521: LD_INT 0
2523: PPUSH
2524: PPUSH
2525: PPUSH
// begin enable ;
2526: ENABLE
// people := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] , [ f_distxy , 188 , 112 , 10 ] ] ) ;
2527: LD_ADDR_VAR 0 1
2531: PUSH
2532: LD_INT 22
2534: PUSH
2535: LD_INT 1
2537: PUSH
2538: EMPTY
2539: LIST
2540: LIST
2541: PUSH
2542: LD_INT 21
2544: PUSH
2545: LD_INT 1
2547: PUSH
2548: EMPTY
2549: LIST
2550: LIST
2551: PUSH
2552: LD_INT 3
2554: PUSH
2555: LD_INT 24
2557: PUSH
2558: LD_INT 1000
2560: PUSH
2561: EMPTY
2562: LIST
2563: LIST
2564: PUSH
2565: EMPTY
2566: LIST
2567: LIST
2568: PUSH
2569: LD_INT 92
2571: PUSH
2572: LD_INT 188
2574: PUSH
2575: LD_INT 112
2577: PUSH
2578: LD_INT 10
2580: PUSH
2581: EMPTY
2582: LIST
2583: LIST
2584: LIST
2585: LIST
2586: PUSH
2587: EMPTY
2588: LIST
2589: LIST
2590: LIST
2591: LIST
2592: PPUSH
2593: CALL_OW 69
2597: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 4 ] ] ) ;
2598: LD_ADDR_VAR 0 2
2602: PUSH
2603: LD_INT 22
2605: PUSH
2606: LD_INT 4
2608: PUSH
2609: EMPTY
2610: LIST
2611: LIST
2612: PUSH
2613: LD_INT 25
2615: PUSH
2616: LD_INT 4
2618: PUSH
2619: EMPTY
2620: LIST
2621: LIST
2622: PUSH
2623: EMPTY
2624: LIST
2625: LIST
2626: PPUSH
2627: CALL_OW 69
2631: ST_TO_ADDR
// if not sci then
2632: LD_VAR 0 2
2636: NOT
2637: IFFALSE 2641
// exit ;
2639: GO 2776
// if people then
2641: LD_VAR 0 1
2645: IFFALSE 2733
// begin for i in sci do
2647: LD_ADDR_VAR 0 3
2651: PUSH
2652: LD_VAR 0 2
2656: PUSH
2657: FOR_IN
2658: IFFALSE 2729
// begin if GetTag ( i ) <> 102 then
2660: LD_VAR 0 3
2664: PPUSH
2665: CALL_OW 110
2669: PUSH
2670: LD_INT 102
2672: NONEQUAL
2673: IFFALSE 2687
// SetTag ( i , 102 ) ;
2675: LD_VAR 0 3
2679: PPUSH
2680: LD_INT 102
2682: PPUSH
2683: CALL_OW 109
// if IsInUnit ( i ) then
2687: LD_VAR 0 3
2691: PPUSH
2692: CALL_OW 310
2696: IFFALSE 2709
// ComExitBuilding ( i ) else
2698: LD_VAR 0 3
2702: PPUSH
2703: CALL_OW 122
2707: GO 2727
// ComHeal ( i , people [ 1 ] ) ;
2709: LD_VAR 0 3
2713: PPUSH
2714: LD_VAR 0 1
2718: PUSH
2719: LD_INT 1
2721: ARRAY
2722: PPUSH
2723: CALL_OW 128
// end ;
2727: GO 2657
2729: POP
2730: POP
// end else
2731: GO 2776
// if FilterByTag ( sci , 102 ) then
2733: LD_VAR 0 2
2737: PPUSH
2738: LD_INT 102
2740: PPUSH
2741: CALL 44253 0 2
2745: IFFALSE 2776
// begin for i in sci do
2747: LD_ADDR_VAR 0 3
2751: PUSH
2752: LD_VAR 0 2
2756: PUSH
2757: FOR_IN
2758: IFFALSE 2774
// begin SetTag ( i , 0 ) ;
2760: LD_VAR 0 3
2764: PPUSH
2765: LD_INT 0
2767: PPUSH
2768: CALL_OW 109
// end ;
2772: GO 2757
2774: POP
2775: POP
// end ; end ; end_of_file
2776: PPOPN 3
2778: END
// export Gensher , gensher_side , gensherAttackGroup ; export function PrepareGensher ; var i , tmp , un ; begin
2779: LD_INT 0
2781: PPUSH
2782: PPUSH
2783: PPUSH
2784: PPUSH
// gensher_side := 2 ;
2785: LD_ADDR_EXP 14
2789: PUSH
2790: LD_INT 2
2792: ST_TO_ADDR
// uc_side := gensher_side ;
2793: LD_ADDR_OWVAR 20
2797: PUSH
2798: LD_EXP 14
2802: ST_TO_ADDR
// uc_nation := 2 ;
2803: LD_ADDR_OWVAR 21
2807: PUSH
2808: LD_INT 2
2810: ST_TO_ADDR
// tmp := PrepareBase ( ar_depot , gensher_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 11500 , 1100 , 60 ] , [ 6 , 6 , 6 , 6 ] ) ;
2811: LD_ADDR_VAR 0 3
2815: PUSH
2816: LD_INT 7
2818: PPUSH
2819: LD_INT 2
2821: PPUSH
2822: LD_STRING 
2824: PPUSH
2825: LD_INT 8
2827: PUSH
2828: LD_INT 7
2830: PUSH
2831: LD_INT 6
2833: PUSH
2834: EMPTY
2835: LIST
2836: LIST
2837: LIST
2838: PUSH
2839: LD_OWVAR 67
2843: ARRAY
2844: PPUSH
2845: LD_INT 11500
2847: PUSH
2848: LD_INT 1100
2850: PUSH
2851: LD_INT 60
2853: PUSH
2854: EMPTY
2855: LIST
2856: LIST
2857: LIST
2858: PPUSH
2859: LD_INT 6
2861: PUSH
2862: LD_INT 6
2864: PUSH
2865: LD_INT 6
2867: PUSH
2868: LD_INT 6
2870: PUSH
2871: EMPTY
2872: LIST
2873: LIST
2874: LIST
2875: LIST
2876: PPUSH
2877: CALL 18308 0 6
2881: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp ) ;
2882: LD_ADDR_EXP 23
2886: PUSH
2887: LD_EXP 23
2891: PPUSH
2892: LD_INT 2
2894: PPUSH
2895: LD_VAR 0 3
2899: PPUSH
2900: CALL_OW 1
2904: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] ] ) ;
2905: LD_ADDR_VAR 0 3
2909: PUSH
2910: LD_INT 22
2912: PUSH
2913: LD_INT 2
2915: PUSH
2916: EMPTY
2917: LIST
2918: LIST
2919: PUSH
2920: LD_INT 30
2922: PUSH
2923: LD_INT 31
2925: PUSH
2926: EMPTY
2927: LIST
2928: LIST
2929: PUSH
2930: EMPTY
2931: LIST
2932: LIST
2933: PPUSH
2934: CALL_OW 69
2938: ST_TO_ADDR
// for i in tmp do
2939: LD_ADDR_VAR 0 2
2943: PUSH
2944: LD_VAR 0 3
2948: PUSH
2949: FOR_IN
2950: IFFALSE 3020
// begin PrepareHuman ( false , 1 , [ 4 , 3 , 3 ] [ Difficulty ] ) ;
2952: LD_INT 0
2954: PPUSH
2955: LD_INT 1
2957: PPUSH
2958: LD_INT 4
2960: PUSH
2961: LD_INT 3
2963: PUSH
2964: LD_INT 3
2966: PUSH
2967: EMPTY
2968: LIST
2969: LIST
2970: LIST
2971: PUSH
2972: LD_OWVAR 67
2976: ARRAY
2977: PPUSH
2978: CALL_OW 380
// un := CreateHuman ;
2982: LD_ADDR_VAR 0 4
2986: PUSH
2987: CALL_OW 44
2991: ST_TO_ADDR
// SetDir ( un , 1 ) ;
2992: LD_VAR 0 4
2996: PPUSH
2997: LD_INT 1
2999: PPUSH
3000: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3004: LD_VAR 0 4
3008: PPUSH
3009: LD_VAR 0 2
3013: PPUSH
3014: CALL_OW 52
// end ;
3018: GO 2949
3020: POP
3021: POP
// tmp := AreaToList ( gensher_mines , 0 ) ;
3022: LD_ADDR_VAR 0 3
3026: PUSH
3027: LD_INT 15
3029: PPUSH
3030: LD_INT 0
3032: PPUSH
3033: CALL_OW 517
3037: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
3038: LD_ADDR_VAR 0 2
3042: PUSH
3043: DOUBLE
3044: LD_INT 1
3046: DEC
3047: ST_TO_ADDR
3048: LD_VAR 0 3
3052: PUSH
3053: LD_INT 1
3055: ARRAY
3056: PUSH
3057: FOR_TO
3058: IFFALSE 3160
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
3060: LD_VAR 0 3
3064: PUSH
3065: LD_INT 1
3067: ARRAY
3068: PUSH
3069: LD_VAR 0 2
3073: ARRAY
3074: PPUSH
3075: LD_VAR 0 3
3079: PUSH
3080: LD_INT 2
3082: ARRAY
3083: PUSH
3084: LD_VAR 0 2
3088: ARRAY
3089: PPUSH
3090: LD_INT 2
3092: PPUSH
3093: LD_INT 0
3095: PPUSH
3096: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
3100: LD_ADDR_EXP 3
3104: PUSH
3105: LD_EXP 3
3109: PPUSH
3110: LD_EXP 3
3114: PUSH
3115: LD_INT 1
3117: PLUS
3118: PPUSH
3119: LD_VAR 0 3
3123: PUSH
3124: LD_INT 1
3126: ARRAY
3127: PUSH
3128: LD_VAR 0 2
3132: ARRAY
3133: PUSH
3134: LD_VAR 0 3
3138: PUSH
3139: LD_INT 2
3141: ARRAY
3142: PUSH
3143: LD_VAR 0 2
3147: ARRAY
3148: PUSH
3149: EMPTY
3150: LIST
3151: LIST
3152: PPUSH
3153: CALL_OW 2
3157: ST_TO_ADDR
// end ;
3158: GO 3057
3160: POP
3161: POP
// if Difficulty > 1 then
3162: LD_OWVAR 67
3166: PUSH
3167: LD_INT 1
3169: GREATER
3170: IFFALSE 3312
// begin tmp := AreaToList ( gensher_mines2 , 0 ) ;
3172: LD_ADDR_VAR 0 3
3176: PUSH
3177: LD_INT 19
3179: PPUSH
3180: LD_INT 0
3182: PPUSH
3183: CALL_OW 517
3187: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
3188: LD_ADDR_VAR 0 2
3192: PUSH
3193: DOUBLE
3194: LD_INT 1
3196: DEC
3197: ST_TO_ADDR
3198: LD_VAR 0 3
3202: PUSH
3203: LD_INT 1
3205: ARRAY
3206: PUSH
3207: FOR_TO
3208: IFFALSE 3310
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
3210: LD_VAR 0 3
3214: PUSH
3215: LD_INT 1
3217: ARRAY
3218: PUSH
3219: LD_VAR 0 2
3223: ARRAY
3224: PPUSH
3225: LD_VAR 0 3
3229: PUSH
3230: LD_INT 2
3232: ARRAY
3233: PUSH
3234: LD_VAR 0 2
3238: ARRAY
3239: PPUSH
3240: LD_INT 2
3242: PPUSH
3243: LD_INT 0
3245: PPUSH
3246: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
3250: LD_ADDR_EXP 3
3254: PUSH
3255: LD_EXP 3
3259: PPUSH
3260: LD_EXP 3
3264: PUSH
3265: LD_INT 1
3267: PLUS
3268: PPUSH
3269: LD_VAR 0 3
3273: PUSH
3274: LD_INT 1
3276: ARRAY
3277: PUSH
3278: LD_VAR 0 2
3282: ARRAY
3283: PUSH
3284: LD_VAR 0 3
3288: PUSH
3289: LD_INT 2
3291: ARRAY
3292: PUSH
3293: LD_VAR 0 2
3297: ARRAY
3298: PUSH
3299: EMPTY
3300: LIST
3301: LIST
3302: PPUSH
3303: CALL_OW 2
3307: ST_TO_ADDR
// end ;
3308: GO 3207
3310: POP
3311: POP
// end ; gensherAttackGroup := [ ] ;
3312: LD_ADDR_EXP 15
3316: PUSH
3317: EMPTY
3318: ST_TO_ADDR
// end ;
3319: LD_VAR 0 1
3323: RET
// export function InitMC_Gensher ( ) ; begin
3324: LD_INT 0
3326: PPUSH
// MC_SetScanArea ( 2 , gensher_base ) ;
3327: LD_INT 2
3329: PPUSH
3330: LD_INT 2
3332: PPUSH
3333: CALL 74040 0 2
// MC_SetParkingArea ( 2 , gensher_parking ) ;
3337: LD_INT 2
3339: PPUSH
3340: LD_INT 9
3342: PPUSH
3343: CALL 73984 0 2
// MC_SetDepositsXY ( 2 , [ [ 56 , 23 , 0 ] , [ 52 , 40 , 1 ] ] ) ;
3347: LD_INT 2
3349: PPUSH
3350: LD_INT 56
3352: PUSH
3353: LD_INT 23
3355: PUSH
3356: LD_INT 0
3358: PUSH
3359: EMPTY
3360: LIST
3361: LIST
3362: LIST
3363: PUSH
3364: LD_INT 52
3366: PUSH
3367: LD_INT 40
3369: PUSH
3370: LD_INT 1
3372: PUSH
3373: EMPTY
3374: LIST
3375: LIST
3376: LIST
3377: PUSH
3378: EMPTY
3379: LIST
3380: LIST
3381: PPUSH
3382: CALL 73043 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ar_gun , ar_rocket_launcher ] ) ;
3386: LD_INT 2
3388: PPUSH
3389: LD_INT 27
3391: PUSH
3392: LD_INT 28
3394: PUSH
3395: EMPTY
3396: LIST
3397: LIST
3398: PPUSH
3399: CALL 73872 0 2
// MC_SetCratesArea ( 2 , gensher_crates ) ;
3403: LD_INT 2
3405: PPUSH
3406: LD_INT 8
3408: PPUSH
3409: CALL 73554 0 2
// MC_SetTame ( 2 , gensher_ape ) ;
3413: LD_INT 2
3415: PPUSH
3416: LD_INT 7
3418: PPUSH
3419: CALL 73285 0 2
// MC_SetDefenderLimit ( 2 , 4 ) ;
3423: LD_INT 2
3425: PPUSH
3426: LD_INT 4
3428: PPUSH
3429: CALL 72904 0 2
// MC_SetProduceList ( 2 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ) ;
3433: LD_INT 2
3435: PPUSH
3436: LD_INT 13
3438: PUSH
3439: LD_INT 2
3441: PUSH
3442: LD_INT 1
3444: PUSH
3445: LD_INT 31
3447: PUSH
3448: EMPTY
3449: LIST
3450: LIST
3451: LIST
3452: LIST
3453: PUSH
3454: LD_INT 13
3456: PUSH
3457: LD_INT 2
3459: PUSH
3460: LD_INT 1
3462: PUSH
3463: LD_INT 31
3465: PUSH
3466: EMPTY
3467: LIST
3468: LIST
3469: LIST
3470: LIST
3471: PUSH
3472: LD_INT 14
3474: PUSH
3475: LD_INT 1
3477: PUSH
3478: LD_INT 2
3480: PUSH
3481: LD_INT 27
3483: PUSH
3484: EMPTY
3485: LIST
3486: LIST
3487: LIST
3488: LIST
3489: PUSH
3490: LD_INT 14
3492: PUSH
3493: LD_INT 1
3495: PUSH
3496: LD_INT 2
3498: PUSH
3499: LD_INT 27
3501: PUSH
3502: EMPTY
3503: LIST
3504: LIST
3505: LIST
3506: LIST
3507: PUSH
3508: LD_INT 14
3510: PUSH
3511: LD_INT 1
3513: PUSH
3514: LD_INT 2
3516: PUSH
3517: LD_INT 28
3519: PUSH
3520: EMPTY
3521: LIST
3522: LIST
3523: LIST
3524: LIST
3525: PUSH
3526: LD_INT 14
3528: PUSH
3529: LD_INT 1
3531: PUSH
3532: LD_INT 2
3534: PUSH
3535: LD_INT 26
3537: PUSH
3538: EMPTY
3539: LIST
3540: LIST
3541: LIST
3542: LIST
3543: PUSH
3544: EMPTY
3545: LIST
3546: LIST
3547: LIST
3548: LIST
3549: LIST
3550: LIST
3551: PPUSH
3552: CALL 72719 0 2
// MC_SetBuildingList ( 2 , [ [ b_armoury , 42 , 29 , 5 ] , [ b_armoury , 36 , 40 , 5 ] , [ b_lab , 13 , 18 , 1 ] , [ b_solar_power , 17 , 3 , 0 ] , [ b_oil_mine , 56 , 23 , 0 ] , [ b_workshop , 11 , 7 , 2 ] , [ b_solar_power , 20 , 3 , 0 ] , [ b_solar_power , 23 , 3 , 0 ] , [ b_solar_power , 26 , 3 , 0 ] , [ b_lab , 17 , 27 , 1 ] , [ b_bunker , 27 , 44 , 5 ] , [ b_bunker , 41 , 41 , 5 ] , [ b_bunker , 45 , 24 , 5 ] , [ b_bunker , 48 , 19 , 5 ] , [ b_bunker , 41 , 3 , 4 ] , [ b_armoury , 44 , 9 , 4 ] , [ b_siberite_mine , 52 , 40 , 3 ] ] ) ;
3556: LD_INT 2
3558: PPUSH
3559: LD_INT 4
3561: PUSH
3562: LD_INT 42
3564: PUSH
3565: LD_INT 29
3567: PUSH
3568: LD_INT 5
3570: PUSH
3571: EMPTY
3572: LIST
3573: LIST
3574: LIST
3575: LIST
3576: PUSH
3577: LD_INT 4
3579: PUSH
3580: LD_INT 36
3582: PUSH
3583: LD_INT 40
3585: PUSH
3586: LD_INT 5
3588: PUSH
3589: EMPTY
3590: LIST
3591: LIST
3592: LIST
3593: LIST
3594: PUSH
3595: LD_INT 6
3597: PUSH
3598: LD_INT 13
3600: PUSH
3601: LD_INT 18
3603: PUSH
3604: LD_INT 1
3606: PUSH
3607: EMPTY
3608: LIST
3609: LIST
3610: LIST
3611: LIST
3612: PUSH
3613: LD_INT 27
3615: PUSH
3616: LD_INT 17
3618: PUSH
3619: LD_INT 3
3621: PUSH
3622: LD_INT 0
3624: PUSH
3625: EMPTY
3626: LIST
3627: LIST
3628: LIST
3629: LIST
3630: PUSH
3631: LD_INT 29
3633: PUSH
3634: LD_INT 56
3636: PUSH
3637: LD_INT 23
3639: PUSH
3640: LD_INT 0
3642: PUSH
3643: EMPTY
3644: LIST
3645: LIST
3646: LIST
3647: LIST
3648: PUSH
3649: LD_INT 2
3651: PUSH
3652: LD_INT 11
3654: PUSH
3655: LD_INT 7
3657: PUSH
3658: LD_INT 2
3660: PUSH
3661: EMPTY
3662: LIST
3663: LIST
3664: LIST
3665: LIST
3666: PUSH
3667: LD_INT 27
3669: PUSH
3670: LD_INT 20
3672: PUSH
3673: LD_INT 3
3675: PUSH
3676: LD_INT 0
3678: PUSH
3679: EMPTY
3680: LIST
3681: LIST
3682: LIST
3683: LIST
3684: PUSH
3685: LD_INT 27
3687: PUSH
3688: LD_INT 23
3690: PUSH
3691: LD_INT 3
3693: PUSH
3694: LD_INT 0
3696: PUSH
3697: EMPTY
3698: LIST
3699: LIST
3700: LIST
3701: LIST
3702: PUSH
3703: LD_INT 27
3705: PUSH
3706: LD_INT 26
3708: PUSH
3709: LD_INT 3
3711: PUSH
3712: LD_INT 0
3714: PUSH
3715: EMPTY
3716: LIST
3717: LIST
3718: LIST
3719: LIST
3720: PUSH
3721: LD_INT 6
3723: PUSH
3724: LD_INT 17
3726: PUSH
3727: LD_INT 27
3729: PUSH
3730: LD_INT 1
3732: PUSH
3733: EMPTY
3734: LIST
3735: LIST
3736: LIST
3737: LIST
3738: PUSH
3739: LD_INT 32
3741: PUSH
3742: LD_INT 27
3744: PUSH
3745: LD_INT 44
3747: PUSH
3748: LD_INT 5
3750: PUSH
3751: EMPTY
3752: LIST
3753: LIST
3754: LIST
3755: LIST
3756: PUSH
3757: LD_INT 32
3759: PUSH
3760: LD_INT 41
3762: PUSH
3763: LD_INT 41
3765: PUSH
3766: LD_INT 5
3768: PUSH
3769: EMPTY
3770: LIST
3771: LIST
3772: LIST
3773: LIST
3774: PUSH
3775: LD_INT 32
3777: PUSH
3778: LD_INT 45
3780: PUSH
3781: LD_INT 24
3783: PUSH
3784: LD_INT 5
3786: PUSH
3787: EMPTY
3788: LIST
3789: LIST
3790: LIST
3791: LIST
3792: PUSH
3793: LD_INT 32
3795: PUSH
3796: LD_INT 48
3798: PUSH
3799: LD_INT 19
3801: PUSH
3802: LD_INT 5
3804: PUSH
3805: EMPTY
3806: LIST
3807: LIST
3808: LIST
3809: LIST
3810: PUSH
3811: LD_INT 32
3813: PUSH
3814: LD_INT 41
3816: PUSH
3817: LD_INT 3
3819: PUSH
3820: LD_INT 4
3822: PUSH
3823: EMPTY
3824: LIST
3825: LIST
3826: LIST
3827: LIST
3828: PUSH
3829: LD_INT 4
3831: PUSH
3832: LD_INT 44
3834: PUSH
3835: LD_INT 9
3837: PUSH
3838: LD_INT 4
3840: PUSH
3841: EMPTY
3842: LIST
3843: LIST
3844: LIST
3845: LIST
3846: PUSH
3847: LD_INT 30
3849: PUSH
3850: LD_INT 52
3852: PUSH
3853: LD_INT 40
3855: PUSH
3856: LD_INT 3
3858: PUSH
3859: EMPTY
3860: LIST
3861: LIST
3862: LIST
3863: LIST
3864: PUSH
3865: EMPTY
3866: LIST
3867: LIST
3868: LIST
3869: LIST
3870: LIST
3871: LIST
3872: LIST
3873: LIST
3874: LIST
3875: LIST
3876: LIST
3877: LIST
3878: LIST
3879: LIST
3880: LIST
3881: LIST
3882: LIST
3883: PPUSH
3884: CALL 72611 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_opto , b_lab_biological , b_lab_siberium ] ) ;
3888: LD_INT 2
3890: PPUSH
3891: LD_INT 10
3893: PUSH
3894: LD_INT 15
3896: PUSH
3897: LD_INT 13
3899: PUSH
3900: LD_INT 11
3902: PUSH
3903: EMPTY
3904: LIST
3905: LIST
3906: LIST
3907: LIST
3908: PPUSH
3909: CALL 73461 0 2
// MC_SetFactoryExtension ( 2 , 11 , 7 , 2 , [ b_ext_stitch , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
3913: LD_INT 2
3915: PPUSH
3916: LD_INT 11
3918: PPUSH
3919: LD_INT 7
3921: PPUSH
3922: LD_INT 2
3924: PPUSH
3925: LD_INT 23
3927: PUSH
3928: LD_INT 16
3930: PUSH
3931: LD_INT 17
3933: PUSH
3934: LD_INT 18
3936: PUSH
3937: LD_INT 22
3939: PUSH
3940: EMPTY
3941: LIST
3942: LIST
3943: LIST
3944: LIST
3945: LIST
3946: PPUSH
3947: CALL 73666 0 5
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
3951: LD_INT 2
3953: PPUSH
3954: LD_INT 0
3956: PPUSH
3957: CALL 73334 0 2
// end ;
3961: LD_VAR 0 1
3965: RET
// every 2 trigger staticMines and FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) do var i , j , tmp , x , y ;
3966: LD_EXP 3
3970: PUSH
3971: LD_INT 15
3973: PPUSH
3974: LD_INT 81
3976: PUSH
3977: LD_INT 2
3979: PUSH
3980: EMPTY
3981: LIST
3982: LIST
3983: PPUSH
3984: CALL_OW 70
3988: AND
3989: IFFALSE 4202
3991: GO 3993
3993: DISABLE
3994: LD_INT 0
3996: PPUSH
3997: PPUSH
3998: PPUSH
3999: PPUSH
4000: PPUSH
// begin enable ;
4001: ENABLE
// tmp := FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) ;
4002: LD_ADDR_VAR 0 3
4006: PUSH
4007: LD_INT 15
4009: PPUSH
4010: LD_INT 81
4012: PUSH
4013: LD_INT 2
4015: PUSH
4016: EMPTY
4017: LIST
4018: LIST
4019: PPUSH
4020: CALL_OW 70
4024: ST_TO_ADDR
// if not tmp then
4025: LD_VAR 0 3
4029: NOT
4030: IFFALSE 4034
// exit ;
4032: GO 4202
// for i in tmp do
4034: LD_ADDR_VAR 0 1
4038: PUSH
4039: LD_VAR 0 3
4043: PUSH
4044: FOR_IN
4045: IFFALSE 4200
// begin x := GetX ( i ) ;
4047: LD_ADDR_VAR 0 4
4051: PUSH
4052: LD_VAR 0 1
4056: PPUSH
4057: CALL_OW 250
4061: ST_TO_ADDR
// y := GetY ( i ) ;
4062: LD_ADDR_VAR 0 5
4066: PUSH
4067: LD_VAR 0 1
4071: PPUSH
4072: CALL_OW 251
4076: ST_TO_ADDR
// if MineAtPos ( x , y ) then
4077: LD_VAR 0 4
4081: PPUSH
4082: LD_VAR 0 5
4086: PPUSH
4087: CALL_OW 458
4091: IFFALSE 4198
// begin LaunchMineAtPos ( x , y , 2 ) ;
4093: LD_VAR 0 4
4097: PPUSH
4098: LD_VAR 0 5
4102: PPUSH
4103: LD_INT 2
4105: PPUSH
4106: CALL_OW 456
// for j = 1 to staticMines do
4110: LD_ADDR_VAR 0 2
4114: PUSH
4115: DOUBLE
4116: LD_INT 1
4118: DEC
4119: ST_TO_ADDR
4120: LD_EXP 3
4124: PUSH
4125: FOR_TO
4126: IFFALSE 4196
// if staticMines [ j ] [ 1 ] = x and staticMines [ j ] [ 2 ] = y then
4128: LD_EXP 3
4132: PUSH
4133: LD_VAR 0 2
4137: ARRAY
4138: PUSH
4139: LD_INT 1
4141: ARRAY
4142: PUSH
4143: LD_VAR 0 4
4147: EQUAL
4148: PUSH
4149: LD_EXP 3
4153: PUSH
4154: LD_VAR 0 2
4158: ARRAY
4159: PUSH
4160: LD_INT 2
4162: ARRAY
4163: PUSH
4164: LD_VAR 0 5
4168: EQUAL
4169: AND
4170: IFFALSE 4194
// begin staticMines := Delete ( staticMines , j ) ;
4172: LD_ADDR_EXP 3
4176: PUSH
4177: LD_EXP 3
4181: PPUSH
4182: LD_VAR 0 2
4186: PPUSH
4187: CALL_OW 3
4191: ST_TO_ADDR
// break ;
4192: GO 4196
// end ;
4194: GO 4125
4196: POP
4197: POP
// end ; end ;
4198: GO 4044
4200: POP
4201: POP
// end ;
4202: PPOPN 5
4204: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ar_depot ) and not arDestroyed do var i , base , tmp , attackers , amount ;
4205: LD_INT 7
4207: PPUSH
4208: CALL_OW 302
4212: PUSH
4213: LD_EXP 4
4217: NOT
4218: AND
4219: IFFALSE 4823
4221: GO 4223
4223: DISABLE
4224: LD_INT 0
4226: PPUSH
4227: PPUSH
4228: PPUSH
4229: PPUSH
4230: PPUSH
// begin enable ;
4231: ENABLE
// base := 2 ;
4232: LD_ADDR_VAR 0 2
4236: PUSH
4237: LD_INT 2
4239: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_mortar ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ;
4240: LD_ADDR_VAR 0 3
4244: PUSH
4245: LD_INT 14
4247: PUSH
4248: LD_INT 1
4250: PUSH
4251: LD_INT 2
4253: PUSH
4254: LD_INT 27
4256: PUSH
4257: EMPTY
4258: LIST
4259: LIST
4260: LIST
4261: LIST
4262: PUSH
4263: LD_INT 14
4265: PUSH
4266: LD_INT 1
4268: PUSH
4269: LD_INT 2
4271: PUSH
4272: LD_INT 27
4274: PUSH
4275: EMPTY
4276: LIST
4277: LIST
4278: LIST
4279: LIST
4280: PUSH
4281: LD_INT 14
4283: PUSH
4284: LD_INT 1
4286: PUSH
4287: LD_INT 2
4289: PUSH
4290: LD_EXP 72
4294: PUSH
4295: EMPTY
4296: LIST
4297: LIST
4298: LIST
4299: LIST
4300: PUSH
4301: LD_INT 14
4303: PUSH
4304: LD_INT 1
4306: PUSH
4307: LD_INT 2
4309: PUSH
4310: LD_INT 26
4312: PUSH
4313: EMPTY
4314: LIST
4315: LIST
4316: LIST
4317: LIST
4318: PUSH
4319: EMPTY
4320: LIST
4321: LIST
4322: LIST
4323: LIST
4324: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
4325: LD_ADDR_VAR 0 5
4329: PUSH
4330: LD_VAR 0 5
4334: PUSH
4335: LD_OWVAR 1
4339: PUSH
4340: LD_INT 21000
4342: DIV
4343: PLUS
4344: ST_TO_ADDR
// if amount > 8 then
4345: LD_VAR 0 5
4349: PUSH
4350: LD_INT 8
4352: GREATER
4353: IFFALSE 4363
// amount := 8 ;
4355: LD_ADDR_VAR 0 5
4359: PUSH
4360: LD_INT 8
4362: ST_TO_ADDR
// for i = 1 to amount do
4363: LD_ADDR_VAR 0 1
4367: PUSH
4368: DOUBLE
4369: LD_INT 1
4371: DEC
4372: ST_TO_ADDR
4373: LD_VAR 0 5
4377: PUSH
4378: FOR_TO
4379: IFFALSE 4467
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_half_tracked , ar_medium_trike ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gatling_gun , ar_gun ] [ rand ( 1 , 3 ) ] ] ) ;
4381: LD_ADDR_VAR 0 3
4385: PUSH
4386: LD_VAR 0 3
4390: PPUSH
4391: LD_VAR 0 3
4395: PUSH
4396: LD_INT 1
4398: PLUS
4399: PPUSH
4400: LD_INT 14
4402: PUSH
4403: LD_INT 13
4405: PUSH
4406: EMPTY
4407: LIST
4408: LIST
4409: PUSH
4410: LD_INT 1
4412: PPUSH
4413: LD_INT 2
4415: PPUSH
4416: CALL_OW 12
4420: ARRAY
4421: PUSH
4422: LD_INT 1
4424: PUSH
4425: LD_INT 2
4427: PUSH
4428: LD_INT 28
4430: PUSH
4431: LD_INT 25
4433: PUSH
4434: LD_INT 27
4436: PUSH
4437: EMPTY
4438: LIST
4439: LIST
4440: LIST
4441: PUSH
4442: LD_INT 1
4444: PPUSH
4445: LD_INT 3
4447: PPUSH
4448: CALL_OW 12
4452: ARRAY
4453: PUSH
4454: EMPTY
4455: LIST
4456: LIST
4457: LIST
4458: LIST
4459: PPUSH
4460: CALL_OW 2
4464: ST_TO_ADDR
4465: GO 4378
4467: POP
4468: POP
// MC_InsertProduceList ( base , tmp ) ;
4469: LD_VAR 0 2
4473: PPUSH
4474: LD_VAR 0 3
4478: PPUSH
4479: CALL 72767 0 2
// repeat wait ( 0 0$1 ) ;
4483: LD_INT 35
4485: PPUSH
4486: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
4490: LD_VAR 0 2
4494: PPUSH
4495: LD_INT 1
4497: PPUSH
4498: CALL 74185 0 2
4502: PUSH
4503: LD_VAR 0 5
4507: GREATEREQUAL
4508: IFFALSE 4483
// wait ( 0 0$30 ) ;
4510: LD_INT 1050
4512: PPUSH
4513: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_control_tower ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
4517: LD_ADDR_VAR 0 4
4521: PUSH
4522: LD_EXP 42
4526: PUSH
4527: LD_VAR 0 2
4531: ARRAY
4532: PUSH
4533: LD_EXP 42
4537: PUSH
4538: LD_VAR 0 2
4542: ARRAY
4543: PPUSH
4544: LD_INT 2
4546: PUSH
4547: LD_INT 34
4549: PUSH
4550: LD_INT 31
4552: PUSH
4553: EMPTY
4554: LIST
4555: LIST
4556: PUSH
4557: LD_INT 34
4559: PUSH
4560: LD_INT 32
4562: PUSH
4563: EMPTY
4564: LIST
4565: LIST
4566: PUSH
4567: LD_INT 34
4569: PUSH
4570: LD_EXP 73
4574: PUSH
4575: EMPTY
4576: LIST
4577: LIST
4578: PUSH
4579: EMPTY
4580: LIST
4581: LIST
4582: LIST
4583: LIST
4584: PPUSH
4585: CALL_OW 72
4589: DIFF
4590: ST_TO_ADDR
// if not attackers then
4591: LD_VAR 0 4
4595: NOT
4596: IFFALSE 4600
// exit ;
4598: GO 4823
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
4600: LD_ADDR_EXP 42
4604: PUSH
4605: LD_EXP 42
4609: PPUSH
4610: LD_VAR 0 2
4614: PPUSH
4615: LD_EXP 42
4619: PUSH
4620: LD_VAR 0 2
4624: ARRAY
4625: PUSH
4626: LD_VAR 0 4
4630: DIFF
4631: PPUSH
4632: CALL_OW 1
4636: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
4637: LD_VAR 0 4
4641: PPUSH
4642: LD_INT 107
4644: PPUSH
4645: LD_INT 74
4647: PPUSH
4648: CALL_OW 114
// wait ( 0 0$5 ) ;
4652: LD_INT 175
4654: PPUSH
4655: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
4659: LD_INT 35
4661: PPUSH
4662: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
4666: LD_VAR 0 4
4670: PPUSH
4671: LD_INT 60
4673: PUSH
4674: EMPTY
4675: LIST
4676: PPUSH
4677: CALL_OW 72
4681: NOT
4682: IFFALSE 4659
// if rand ( 0 , 1 ) then
4684: LD_INT 0
4686: PPUSH
4687: LD_INT 1
4689: PPUSH
4690: CALL_OW 12
4694: IFFALSE 4713
// ComAgressiveMove ( attackers , 155 , 108 ) else
4696: LD_VAR 0 4
4700: PPUSH
4701: LD_INT 155
4703: PPUSH
4704: LD_INT 108
4706: PPUSH
4707: CALL_OW 114
4711: GO 4728
// ComAgressiveMove ( attackers , 149 , 55 ) ;
4713: LD_VAR 0 4
4717: PPUSH
4718: LD_INT 149
4720: PPUSH
4721: LD_INT 55
4723: PPUSH
4724: CALL_OW 114
// wait ( 0 0$10 ) ;
4728: LD_INT 350
4730: PPUSH
4731: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
4735: LD_INT 35
4737: PPUSH
4738: CALL_OW 67
// for i in attackers do
4742: LD_ADDR_VAR 0 1
4746: PUSH
4747: LD_VAR 0 4
4751: PUSH
4752: FOR_IN
4753: IFFALSE 4803
// if not HasTask ( i ) then
4755: LD_VAR 0 1
4759: PPUSH
4760: CALL_OW 314
4764: NOT
4765: IFFALSE 4801
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4767: LD_VAR 0 1
4771: PPUSH
4772: LD_INT 81
4774: PUSH
4775: LD_INT 2
4777: PUSH
4778: EMPTY
4779: LIST
4780: LIST
4781: PPUSH
4782: CALL_OW 69
4786: PPUSH
4787: LD_VAR 0 1
4791: PPUSH
4792: CALL_OW 74
4796: PPUSH
4797: CALL_OW 115
4801: GO 4752
4803: POP
4804: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
4805: LD_VAR 0 4
4809: PPUSH
4810: LD_INT 50
4812: PUSH
4813: EMPTY
4814: LIST
4815: PPUSH
4816: CALL_OW 72
4820: NOT
4821: IFFALSE 4735
// end ;
4823: PPOPN 5
4825: END
// every 8 8$00 + 9 9$00 trigger not arDestroyed and tick < 91 91$00 do var i , un , tmp ;
4826: LD_EXP 4
4830: NOT
4831: PUSH
4832: LD_OWVAR 1
4836: PUSH
4837: LD_INT 191100
4839: LESS
4840: AND
4841: IFFALSE 5513
4843: GO 4845
4845: DISABLE
4846: LD_INT 0
4848: PPUSH
4849: PPUSH
4850: PPUSH
// begin enable ;
4851: ENABLE
// tmp := [ ] ;
4852: LD_ADDR_VAR 0 3
4856: PUSH
4857: EMPTY
4858: ST_TO_ADDR
// if tick < 35 35$00 then
4859: LD_OWVAR 1
4863: PUSH
4864: LD_INT 73500
4866: LESS
4867: IFFALSE 5065
// begin for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
4869: LD_ADDR_VAR 0 1
4873: PUSH
4874: DOUBLE
4875: LD_INT 1
4877: DEC
4878: ST_TO_ADDR
4879: LD_INT 4
4881: PUSH
4882: LD_INT 5
4884: PUSH
4885: LD_INT 5
4887: PUSH
4888: EMPTY
4889: LIST
4890: LIST
4891: LIST
4892: PUSH
4893: LD_OWVAR 67
4897: ARRAY
4898: PUSH
4899: FOR_TO
4900: IFFALSE 5061
// begin uc_side := 2 ;
4902: LD_ADDR_OWVAR 20
4906: PUSH
4907: LD_INT 2
4909: ST_TO_ADDR
// uc_nation := 2 ;
4910: LD_ADDR_OWVAR 21
4914: PUSH
4915: LD_INT 2
4917: ST_TO_ADDR
// InitHC_All ( ) ;
4918: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
4922: LD_INT 0
4924: PPUSH
4925: LD_INT 1
4927: PPUSH
4928: LD_INT 5
4930: PUSH
4931: LD_INT 6
4933: PUSH
4934: LD_INT 7
4936: PUSH
4937: EMPTY
4938: LIST
4939: LIST
4940: LIST
4941: PUSH
4942: LD_OWVAR 67
4946: ARRAY
4947: PPUSH
4948: CALL_OW 380
// un := CreateHuman ;
4952: LD_ADDR_VAR 0 2
4956: PUSH
4957: CALL_OW 44
4961: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
4962: LD_VAR 0 2
4966: PPUSH
4967: LD_INT 17
4969: PPUSH
4970: LD_INT 0
4972: PPUSH
4973: CALL_OW 49
// SetClass ( un , [ class_soldier , class_mortar ] [ rand ( 1 , 2 ) ] ) ;
4977: LD_VAR 0 2
4981: PPUSH
4982: LD_INT 1
4984: PUSH
4985: LD_INT 8
4987: PUSH
4988: EMPTY
4989: LIST
4990: LIST
4991: PUSH
4992: LD_INT 1
4994: PPUSH
4995: LD_INT 2
4997: PPUSH
4998: CALL_OW 12
5002: ARRAY
5003: PPUSH
5004: CALL_OW 336
// ComAgressiveMove ( un , 111 , 34 ) ;
5008: LD_VAR 0 2
5012: PPUSH
5013: LD_INT 111
5015: PPUSH
5016: LD_INT 34
5018: PPUSH
5019: CALL_OW 114
// wait ( 0 0$2 ) ;
5023: LD_INT 70
5025: PPUSH
5026: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5030: LD_ADDR_VAR 0 3
5034: PUSH
5035: LD_VAR 0 3
5039: PPUSH
5040: LD_VAR 0 3
5044: PUSH
5045: LD_INT 1
5047: PLUS
5048: PPUSH
5049: LD_VAR 0 2
5053: PPUSH
5054: CALL_OW 1
5058: ST_TO_ADDR
// end ;
5059: GO 4899
5061: POP
5062: POP
// end else
5063: GO 5206
// begin for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
5065: LD_ADDR_VAR 0 1
5069: PUSH
5070: DOUBLE
5071: LD_INT 1
5073: DEC
5074: ST_TO_ADDR
5075: LD_INT 4
5077: PUSH
5078: LD_INT 5
5080: PUSH
5081: LD_INT 5
5083: PUSH
5084: EMPTY
5085: LIST
5086: LIST
5087: LIST
5088: PUSH
5089: LD_OWVAR 67
5093: ARRAY
5094: PUSH
5095: FOR_TO
5096: IFFALSE 5204
// begin uc_side := 2 ;
5098: LD_ADDR_OWVAR 20
5102: PUSH
5103: LD_INT 2
5105: ST_TO_ADDR
// uc_nation := 0 ;
5106: LD_ADDR_OWVAR 21
5110: PUSH
5111: LD_INT 0
5113: ST_TO_ADDR
// InitHC_All ( ) ;
5114: CALL_OW 584
// hc_class := class_apeman_kamikaze ;
5118: LD_ADDR_OWVAR 28
5122: PUSH
5123: LD_INT 17
5125: ST_TO_ADDR
// un := CreateHuman ;
5126: LD_ADDR_VAR 0 2
5130: PUSH
5131: CALL_OW 44
5135: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5136: LD_VAR 0 2
5140: PPUSH
5141: LD_INT 17
5143: PPUSH
5144: LD_INT 0
5146: PPUSH
5147: CALL_OW 49
// ComAgressiveMove ( un , 110 , 33 ) ;
5151: LD_VAR 0 2
5155: PPUSH
5156: LD_INT 110
5158: PPUSH
5159: LD_INT 33
5161: PPUSH
5162: CALL_OW 114
// wait ( 0 0$2 ) ;
5166: LD_INT 70
5168: PPUSH
5169: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5173: LD_ADDR_VAR 0 3
5177: PUSH
5178: LD_VAR 0 3
5182: PPUSH
5183: LD_VAR 0 3
5187: PUSH
5188: LD_INT 1
5190: PLUS
5191: PPUSH
5192: LD_VAR 0 2
5196: PPUSH
5197: CALL_OW 1
5201: ST_TO_ADDR
// end ;
5202: GO 5095
5204: POP
5205: POP
// end ; for i := 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
5206: LD_ADDR_VAR 0 1
5210: PUSH
5211: DOUBLE
5212: LD_INT 1
5214: DEC
5215: ST_TO_ADDR
5216: LD_INT 3
5218: PUSH
5219: LD_INT 4
5221: PUSH
5222: LD_INT 5
5224: PUSH
5225: EMPTY
5226: LIST
5227: LIST
5228: LIST
5229: PUSH
5230: LD_OWVAR 67
5234: ARRAY
5235: PUSH
5236: FOR_TO
5237: IFFALSE 5402
// begin uc_side := 2 ;
5239: LD_ADDR_OWVAR 20
5243: PUSH
5244: LD_INT 2
5246: ST_TO_ADDR
// uc_nation := 2 ;
5247: LD_ADDR_OWVAR 21
5251: PUSH
5252: LD_INT 2
5254: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_selfpropelled_bomb , ar_rocket_launcher , ar_gun ] [ rand ( 1 , 3 ) ] , 90 ) ;
5255: LD_INT 14
5257: PPUSH
5258: LD_INT 3
5260: PPUSH
5261: LD_INT 5
5263: PPUSH
5264: LD_INT 29
5266: PUSH
5267: LD_INT 28
5269: PUSH
5270: LD_INT 27
5272: PUSH
5273: EMPTY
5274: LIST
5275: LIST
5276: LIST
5277: PUSH
5278: LD_INT 1
5280: PPUSH
5281: LD_INT 3
5283: PPUSH
5284: CALL_OW 12
5288: ARRAY
5289: PPUSH
5290: LD_INT 90
5292: PPUSH
5293: CALL 14861 0 5
// un := CreateVehicle ;
5297: LD_ADDR_VAR 0 2
5301: PUSH
5302: CALL_OW 45
5306: ST_TO_ADDR
// SetDir ( un , 2 ) ;
5307: LD_VAR 0 2
5311: PPUSH
5312: LD_INT 2
5314: PPUSH
5315: CALL_OW 233
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5319: LD_VAR 0 2
5323: PPUSH
5324: LD_INT 17
5326: PPUSH
5327: LD_INT 0
5329: PPUSH
5330: CALL_OW 49
// ComMoveXY ( un , 66 , 23 ) ;
5334: LD_VAR 0 2
5338: PPUSH
5339: LD_INT 66
5341: PPUSH
5342: LD_INT 23
5344: PPUSH
5345: CALL_OW 111
// wait ( 0 0$3 ) ;
5349: LD_INT 105
5351: PPUSH
5352: CALL_OW 67
// AddComAgressiveMove ( un , 147 , 103 ) ;
5356: LD_VAR 0 2
5360: PPUSH
5361: LD_INT 147
5363: PPUSH
5364: LD_INT 103
5366: PPUSH
5367: CALL_OW 174
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5371: LD_ADDR_VAR 0 3
5375: PUSH
5376: LD_VAR 0 3
5380: PPUSH
5381: LD_VAR 0 3
5385: PUSH
5386: LD_INT 1
5388: PLUS
5389: PPUSH
5390: LD_VAR 0 2
5394: PPUSH
5395: CALL_OW 1
5399: ST_TO_ADDR
// end ;
5400: GO 5236
5402: POP
5403: POP
// if not tmp then
5404: LD_VAR 0 3
5408: NOT
5409: IFFALSE 5413
// exit ;
5411: GO 5513
// wait ( 0 0$5 ) ;
5413: LD_INT 175
5415: PPUSH
5416: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
5420: LD_INT 70
5422: PPUSH
5423: CALL_OW 67
// for i in tmp do
5427: LD_ADDR_VAR 0 1
5431: PUSH
5432: LD_VAR 0 3
5436: PUSH
5437: FOR_IN
5438: IFFALSE 5504
// begin if not IsOk ( i ) then
5440: LD_VAR 0 1
5444: PPUSH
5445: CALL_OW 302
5449: NOT
5450: IFFALSE 5468
// tmp := tmp diff i ;
5452: LD_ADDR_VAR 0 3
5456: PUSH
5457: LD_VAR 0 3
5461: PUSH
5462: LD_VAR 0 1
5466: DIFF
5467: ST_TO_ADDR
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
5468: LD_VAR 0 1
5472: PPUSH
5473: LD_INT 81
5475: PUSH
5476: LD_INT 2
5478: PUSH
5479: EMPTY
5480: LIST
5481: LIST
5482: PPUSH
5483: CALL_OW 69
5487: PPUSH
5488: LD_VAR 0 1
5492: PPUSH
5493: CALL_OW 74
5497: PPUSH
5498: CALL_OW 115
// end ;
5502: GO 5437
5504: POP
5505: POP
// until not tmp ;
5506: LD_VAR 0 3
5510: NOT
5511: IFFALSE 5420
// end ;
5513: PPOPN 3
5515: END
// every 9 9$00 trigger Difficulty > 1 do var un ;
5516: LD_OWVAR 67
5520: PUSH
5521: LD_INT 1
5523: GREATER
5524: IFFALSE 5622
5526: GO 5528
5528: DISABLE
5529: LD_INT 0
5531: PPUSH
// begin uc_side := 2 ;
5532: LD_ADDR_OWVAR 20
5536: PUSH
5537: LD_INT 2
5539: ST_TO_ADDR
// uc_nation := 2 ;
5540: LD_ADDR_OWVAR 21
5544: PUSH
5545: LD_INT 2
5547: ST_TO_ADDR
// PrepareHuman ( false , 4 , 6 ) ;
5548: LD_INT 0
5550: PPUSH
5551: LD_INT 4
5553: PPUSH
5554: LD_INT 6
5556: PPUSH
5557: CALL_OW 380
// un := CreateHuman ;
5561: LD_ADDR_VAR 0 1
5565: PUSH
5566: CALL_OW 44
5570: ST_TO_ADDR
// PlaceUnitXYD ( un , 88 , 1 , 2 , false ) ;
5571: LD_VAR 0 1
5575: PPUSH
5576: LD_INT 88
5578: PPUSH
5579: LD_INT 1
5581: PPUSH
5582: LD_INT 2
5584: PPUSH
5585: LD_INT 0
5587: PPUSH
5588: CALL 48666 0 5
// ComMoveXY ( un , 130 , 35 ) ;
5592: LD_VAR 0 1
5596: PPUSH
5597: LD_INT 130
5599: PPUSH
5600: LD_INT 35
5602: PPUSH
5603: CALL_OW 111
// AddComContaminate ( un , 132 , 39 ) ;
5607: LD_VAR 0 1
5611: PPUSH
5612: LD_INT 132
5614: PPUSH
5615: LD_INT 39
5617: PPUSH
5618: CALL_OW 218
// end ; end_of_file
5622: PPOPN 1
5624: END
// export Popov , popov_side , extraPopovForces , popovAttackGroup ; export function PreparePopov ; var i , un , tmp ; begin
5625: LD_INT 0
5627: PPUSH
5628: PPUSH
5629: PPUSH
5630: PPUSH
// popov_side := 3 ;
5631: LD_ADDR_EXP 17
5635: PUSH
5636: LD_INT 3
5638: ST_TO_ADDR
// uc_side := popov_side ;
5639: LD_ADDR_OWVAR 20
5643: PUSH
5644: LD_EXP 17
5648: ST_TO_ADDR
// uc_nation := 3 ;
5649: LD_ADDR_OWVAR 21
5653: PUSH
5654: LD_INT 3
5656: ST_TO_ADDR
// tmp := PrepareBase ( ru_depot , popov_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 11500 , 1100 , 60 ] , [ 6 , 6 , 6 , 6 ] ) ;
5657: LD_ADDR_VAR 0 4
5661: PUSH
5662: LD_INT 9
5664: PPUSH
5665: LD_INT 3
5667: PPUSH
5668: LD_STRING 
5670: PPUSH
5671: LD_INT 8
5673: PUSH
5674: LD_INT 7
5676: PUSH
5677: LD_INT 6
5679: PUSH
5680: EMPTY
5681: LIST
5682: LIST
5683: LIST
5684: PUSH
5685: LD_OWVAR 67
5689: ARRAY
5690: PPUSH
5691: LD_INT 11500
5693: PUSH
5694: LD_INT 1100
5696: PUSH
5697: LD_INT 60
5699: PUSH
5700: EMPTY
5701: LIST
5702: LIST
5703: LIST
5704: PPUSH
5705: LD_INT 6
5707: PUSH
5708: LD_INT 6
5710: PUSH
5711: LD_INT 6
5713: PUSH
5714: LD_INT 6
5716: PUSH
5717: EMPTY
5718: LIST
5719: LIST
5720: LIST
5721: LIST
5722: PPUSH
5723: CALL 18308 0 6
5727: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 3 , tmp ) ;
5728: LD_ADDR_EXP 23
5732: PUSH
5733: LD_EXP 23
5737: PPUSH
5738: LD_INT 3
5740: PPUSH
5741: LD_VAR 0 4
5745: PPUSH
5746: CALL_OW 1
5750: ST_TO_ADDR
// extraPopovForces := [ ] ;
5751: LD_ADDR_EXP 18
5755: PUSH
5756: EMPTY
5757: ST_TO_ADDR
// for i := 1 to [ 8 , 9 , 10 ] [ Difficulty ] do
5758: LD_ADDR_VAR 0 2
5762: PUSH
5763: DOUBLE
5764: LD_INT 1
5766: DEC
5767: ST_TO_ADDR
5768: LD_INT 8
5770: PUSH
5771: LD_INT 9
5773: PUSH
5774: LD_INT 10
5776: PUSH
5777: EMPTY
5778: LIST
5779: LIST
5780: LIST
5781: PUSH
5782: LD_OWVAR 67
5786: ARRAY
5787: PUSH
5788: FOR_TO
5789: IFFALSE 5918
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
5791: LD_INT 0
5793: PPUSH
5794: LD_INT 1
5796: PPUSH
5797: LD_INT 4
5799: PUSH
5800: LD_INT 5
5802: PUSH
5803: LD_INT 6
5805: PUSH
5806: EMPTY
5807: LIST
5808: LIST
5809: LIST
5810: PUSH
5811: LD_OWVAR 67
5815: ARRAY
5816: PPUSH
5817: CALL_OW 380
// un := CreateHuman ;
5821: LD_ADDR_VAR 0 3
5825: PUSH
5826: CALL_OW 44
5830: ST_TO_ADDR
// if rand ( 0 , 1 ) then
5831: LD_INT 0
5833: PPUSH
5834: LD_INT 1
5836: PPUSH
5837: CALL_OW 12
5841: IFFALSE 5866
// PlaceUnitXYR ( un , 131 , 110 , 8 , false ) else
5843: LD_VAR 0 3
5847: PPUSH
5848: LD_INT 131
5850: PPUSH
5851: LD_INT 110
5853: PPUSH
5854: LD_INT 8
5856: PPUSH
5857: LD_INT 0
5859: PPUSH
5860: CALL_OW 50
5864: GO 5887
// PlaceUnitXYR ( un , 100 , 99 , 8 , false ) ;
5866: LD_VAR 0 3
5870: PPUSH
5871: LD_INT 100
5873: PPUSH
5874: LD_INT 99
5876: PPUSH
5877: LD_INT 8
5879: PPUSH
5880: LD_INT 0
5882: PPUSH
5883: CALL_OW 50
// extraPopovForces := Replace ( extraPopovForces , extraPopovForces + 1 , un ) ;
5887: LD_ADDR_EXP 18
5891: PUSH
5892: LD_EXP 18
5896: PPUSH
5897: LD_EXP 18
5901: PUSH
5902: LD_INT 1
5904: PLUS
5905: PPUSH
5906: LD_VAR 0 3
5910: PPUSH
5911: CALL_OW 1
5915: ST_TO_ADDR
// end ;
5916: GO 5788
5918: POP
5919: POP
// PrepareSoldier ( false , 6 ) ;
5920: LD_INT 0
5922: PPUSH
5923: LD_INT 6
5925: PPUSH
5926: CALL_OW 381
// un := CreateHuman ;
5930: LD_ADDR_VAR 0 3
5934: PUSH
5935: CALL_OW 44
5939: ST_TO_ADDR
// SetDir ( un , 1 ) ;
5940: LD_VAR 0 3
5944: PPUSH
5945: LD_INT 1
5947: PPUSH
5948: CALL_OW 233
// PlaceHumanInUnit ( un , HexInfo ( 150 , 158 ) ) ;
5952: LD_VAR 0 3
5956: PPUSH
5957: LD_INT 150
5959: PPUSH
5960: LD_INT 158
5962: PPUSH
5963: CALL_OW 428
5967: PPUSH
5968: CALL_OW 52
// popovAttackGroup := [ ] ;
5972: LD_ADDR_EXP 19
5976: PUSH
5977: EMPTY
5978: ST_TO_ADDR
// end ;
5979: LD_VAR 0 1
5983: RET
// export function InitMC_Popov ( ) ; begin
5984: LD_INT 0
5986: PPUSH
// MC_SetScanArea ( 3 , popov_base ) ;
5987: LD_INT 3
5989: PPUSH
5990: LD_INT 3
5992: PPUSH
5993: CALL 74040 0 2
// MC_SetParkingArea ( 3 , popov_parking ) ;
5997: LD_INT 3
5999: PPUSH
6000: LD_INT 10
6002: PPUSH
6003: CALL 73984 0 2
// MC_SetDepositsXY ( 3 , [ [ 86 , 118 , 0 ] , [ 123 , 151 , 1 ] , [ 98 , 121 , 0 ] ] ) ;
6007: LD_INT 3
6009: PPUSH
6010: LD_INT 86
6012: PUSH
6013: LD_INT 118
6015: PUSH
6016: LD_INT 0
6018: PUSH
6019: EMPTY
6020: LIST
6021: LIST
6022: LIST
6023: PUSH
6024: LD_INT 123
6026: PUSH
6027: LD_INT 151
6029: PUSH
6030: LD_INT 1
6032: PUSH
6033: EMPTY
6034: LIST
6035: LIST
6036: LIST
6037: PUSH
6038: LD_INT 98
6040: PUSH
6041: LD_INT 121
6043: PUSH
6044: LD_INT 0
6046: PUSH
6047: EMPTY
6048: LIST
6049: LIST
6050: LIST
6051: PUSH
6052: EMPTY
6053: LIST
6054: LIST
6055: LIST
6056: PPUSH
6057: CALL 73043 0 2
// MC_SetAllowedTurretWeapons ( 3 , [ ru_heavy_gun , ru_rocket_launcher ] ) ;
6061: LD_INT 3
6063: PPUSH
6064: LD_INT 46
6066: PUSH
6067: LD_INT 45
6069: PUSH
6070: EMPTY
6071: LIST
6072: LIST
6073: PPUSH
6074: CALL 73872 0 2
// MC_SetCratesArea ( 3 , popov_crates ) ;
6078: LD_INT 3
6080: PPUSH
6081: LD_INT 12
6083: PPUSH
6084: CALL 73554 0 2
// MC_SetTame ( 3 , popov_ape ) ;
6088: LD_INT 3
6090: PPUSH
6091: LD_INT 11
6093: PPUSH
6094: CALL 73285 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
6098: LD_INT 3
6100: PPUSH
6101: LD_INT 4
6103: PPUSH
6104: CALL 72904 0 2
// MC_SetProduceList ( 3 , [ [ ru_heavy_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] ] ) ;
6108: LD_INT 3
6110: PPUSH
6111: LD_INT 23
6113: PUSH
6114: LD_INT 1
6116: PUSH
6117: LD_INT 3
6119: PUSH
6120: LD_INT 44
6122: PUSH
6123: EMPTY
6124: LIST
6125: LIST
6126: LIST
6127: LIST
6128: PUSH
6129: LD_INT 23
6131: PUSH
6132: LD_INT 1
6134: PUSH
6135: LD_INT 3
6137: PUSH
6138: LD_INT 45
6140: PUSH
6141: EMPTY
6142: LIST
6143: LIST
6144: LIST
6145: LIST
6146: PUSH
6147: LD_INT 21
6149: PUSH
6150: LD_INT 1
6152: PUSH
6153: LD_INT 3
6155: PUSH
6156: LD_INT 44
6158: PUSH
6159: EMPTY
6160: LIST
6161: LIST
6162: LIST
6163: LIST
6164: PUSH
6165: LD_INT 21
6167: PUSH
6168: LD_INT 1
6170: PUSH
6171: LD_INT 3
6173: PUSH
6174: LD_INT 45
6176: PUSH
6177: EMPTY
6178: LIST
6179: LIST
6180: LIST
6181: LIST
6182: PUSH
6183: EMPTY
6184: LIST
6185: LIST
6186: LIST
6187: LIST
6188: PPUSH
6189: CALL 72719 0 2
// MC_SetBuildingList ( 3 , [ [ b_armoury , 103 , 147 , 3 ] , [ b_armoury , 70 , 117 , 3 ] , [ b_lab , 76 , 145 , 1 ] , [ b_oil_power , 87 , 144 , 0 ] , [ b_oil_mine , 86 , 118 , 0 ] , [ b_oil_mine , 98 , 121 , 0 ] , [ b_oil_power , 87 , 147 , 1 ] , [ b_workshop , 94 , 161 , 0 ] , [ b_lab , 81 , 155 , 1 ] , [ b_oil_power , 96 , 152 , 0 ] , [ b_oil_power , 96 , 149 , 3 ] , [ b_bunker , 109 , 142 , 3 ] , [ b_bunker , 112 , 148 , 3 ] , [ b_turret , 120 , 159 , 4 ] , [ b_turret , 122 , 163 , 4 ] , [ b_turret , 123 , 167 , 4 ] , [ b_turret , 59 , 111 , 3 ] , [ b_turret , 65 , 111 , 3 ] , [ b_turret , 76 , 117 , 3 ] , [ b_turret , 80 , 119 , 3 ] , [ b_turret , 87 , 125 , 3 ] , [ b_armoury , 92 , 129 , 3 ] , [ b_siberite_power , 85 , 165 , 0 ] , [ b_siberite_power , 83 , 161 , 4 ] , [ b_siberite_power , 91 , 166 , 3 ] , [ b_siberite_power , 102 , 166 , 2 ] ] ) ;
6193: LD_INT 3
6195: PPUSH
6196: LD_INT 4
6198: PUSH
6199: LD_INT 103
6201: PUSH
6202: LD_INT 147
6204: PUSH
6205: LD_INT 3
6207: PUSH
6208: EMPTY
6209: LIST
6210: LIST
6211: LIST
6212: LIST
6213: PUSH
6214: LD_INT 4
6216: PUSH
6217: LD_INT 70
6219: PUSH
6220: LD_INT 117
6222: PUSH
6223: LD_INT 3
6225: PUSH
6226: EMPTY
6227: LIST
6228: LIST
6229: LIST
6230: LIST
6231: PUSH
6232: LD_INT 6
6234: PUSH
6235: LD_INT 76
6237: PUSH
6238: LD_INT 145
6240: PUSH
6241: LD_INT 1
6243: PUSH
6244: EMPTY
6245: LIST
6246: LIST
6247: LIST
6248: LIST
6249: PUSH
6250: LD_INT 26
6252: PUSH
6253: LD_INT 87
6255: PUSH
6256: LD_INT 144
6258: PUSH
6259: LD_INT 0
6261: PUSH
6262: EMPTY
6263: LIST
6264: LIST
6265: LIST
6266: LIST
6267: PUSH
6268: LD_INT 29
6270: PUSH
6271: LD_INT 86
6273: PUSH
6274: LD_INT 118
6276: PUSH
6277: LD_INT 0
6279: PUSH
6280: EMPTY
6281: LIST
6282: LIST
6283: LIST
6284: LIST
6285: PUSH
6286: LD_INT 29
6288: PUSH
6289: LD_INT 98
6291: PUSH
6292: LD_INT 121
6294: PUSH
6295: LD_INT 0
6297: PUSH
6298: EMPTY
6299: LIST
6300: LIST
6301: LIST
6302: LIST
6303: PUSH
6304: LD_INT 26
6306: PUSH
6307: LD_INT 87
6309: PUSH
6310: LD_INT 147
6312: PUSH
6313: LD_INT 1
6315: PUSH
6316: EMPTY
6317: LIST
6318: LIST
6319: LIST
6320: LIST
6321: PUSH
6322: LD_INT 2
6324: PUSH
6325: LD_INT 94
6327: PUSH
6328: LD_INT 161
6330: PUSH
6331: LD_INT 0
6333: PUSH
6334: EMPTY
6335: LIST
6336: LIST
6337: LIST
6338: LIST
6339: PUSH
6340: LD_INT 6
6342: PUSH
6343: LD_INT 81
6345: PUSH
6346: LD_INT 155
6348: PUSH
6349: LD_INT 1
6351: PUSH
6352: EMPTY
6353: LIST
6354: LIST
6355: LIST
6356: LIST
6357: PUSH
6358: LD_INT 26
6360: PUSH
6361: LD_INT 96
6363: PUSH
6364: LD_INT 152
6366: PUSH
6367: LD_INT 0
6369: PUSH
6370: EMPTY
6371: LIST
6372: LIST
6373: LIST
6374: LIST
6375: PUSH
6376: LD_INT 26
6378: PUSH
6379: LD_INT 96
6381: PUSH
6382: LD_INT 149
6384: PUSH
6385: LD_INT 3
6387: PUSH
6388: EMPTY
6389: LIST
6390: LIST
6391: LIST
6392: LIST
6393: PUSH
6394: LD_INT 32
6396: PUSH
6397: LD_INT 109
6399: PUSH
6400: LD_INT 142
6402: PUSH
6403: LD_INT 3
6405: PUSH
6406: EMPTY
6407: LIST
6408: LIST
6409: LIST
6410: LIST
6411: PUSH
6412: LD_INT 32
6414: PUSH
6415: LD_INT 112
6417: PUSH
6418: LD_INT 148
6420: PUSH
6421: LD_INT 3
6423: PUSH
6424: EMPTY
6425: LIST
6426: LIST
6427: LIST
6428: LIST
6429: PUSH
6430: LD_INT 33
6432: PUSH
6433: LD_INT 120
6435: PUSH
6436: LD_INT 159
6438: PUSH
6439: LD_INT 4
6441: PUSH
6442: EMPTY
6443: LIST
6444: LIST
6445: LIST
6446: LIST
6447: PUSH
6448: LD_INT 33
6450: PUSH
6451: LD_INT 122
6453: PUSH
6454: LD_INT 163
6456: PUSH
6457: LD_INT 4
6459: PUSH
6460: EMPTY
6461: LIST
6462: LIST
6463: LIST
6464: LIST
6465: PUSH
6466: LD_INT 33
6468: PUSH
6469: LD_INT 123
6471: PUSH
6472: LD_INT 167
6474: PUSH
6475: LD_INT 4
6477: PUSH
6478: EMPTY
6479: LIST
6480: LIST
6481: LIST
6482: LIST
6483: PUSH
6484: LD_INT 33
6486: PUSH
6487: LD_INT 59
6489: PUSH
6490: LD_INT 111
6492: PUSH
6493: LD_INT 3
6495: PUSH
6496: EMPTY
6497: LIST
6498: LIST
6499: LIST
6500: LIST
6501: PUSH
6502: LD_INT 33
6504: PUSH
6505: LD_INT 65
6507: PUSH
6508: LD_INT 111
6510: PUSH
6511: LD_INT 3
6513: PUSH
6514: EMPTY
6515: LIST
6516: LIST
6517: LIST
6518: LIST
6519: PUSH
6520: LD_INT 33
6522: PUSH
6523: LD_INT 76
6525: PUSH
6526: LD_INT 117
6528: PUSH
6529: LD_INT 3
6531: PUSH
6532: EMPTY
6533: LIST
6534: LIST
6535: LIST
6536: LIST
6537: PUSH
6538: LD_INT 33
6540: PUSH
6541: LD_INT 80
6543: PUSH
6544: LD_INT 119
6546: PUSH
6547: LD_INT 3
6549: PUSH
6550: EMPTY
6551: LIST
6552: LIST
6553: LIST
6554: LIST
6555: PUSH
6556: LD_INT 33
6558: PUSH
6559: LD_INT 87
6561: PUSH
6562: LD_INT 125
6564: PUSH
6565: LD_INT 3
6567: PUSH
6568: EMPTY
6569: LIST
6570: LIST
6571: LIST
6572: LIST
6573: PUSH
6574: LD_INT 4
6576: PUSH
6577: LD_INT 92
6579: PUSH
6580: LD_INT 129
6582: PUSH
6583: LD_INT 3
6585: PUSH
6586: EMPTY
6587: LIST
6588: LIST
6589: LIST
6590: LIST
6591: PUSH
6592: LD_INT 28
6594: PUSH
6595: LD_INT 85
6597: PUSH
6598: LD_INT 165
6600: PUSH
6601: LD_INT 0
6603: PUSH
6604: EMPTY
6605: LIST
6606: LIST
6607: LIST
6608: LIST
6609: PUSH
6610: LD_INT 28
6612: PUSH
6613: LD_INT 83
6615: PUSH
6616: LD_INT 161
6618: PUSH
6619: LD_INT 4
6621: PUSH
6622: EMPTY
6623: LIST
6624: LIST
6625: LIST
6626: LIST
6627: PUSH
6628: LD_INT 28
6630: PUSH
6631: LD_INT 91
6633: PUSH
6634: LD_INT 166
6636: PUSH
6637: LD_INT 3
6639: PUSH
6640: EMPTY
6641: LIST
6642: LIST
6643: LIST
6644: LIST
6645: PUSH
6646: LD_INT 28
6648: PUSH
6649: LD_INT 102
6651: PUSH
6652: LD_INT 166
6654: PUSH
6655: LD_INT 2
6657: PUSH
6658: EMPTY
6659: LIST
6660: LIST
6661: LIST
6662: LIST
6663: PUSH
6664: EMPTY
6665: LIST
6666: LIST
6667: LIST
6668: LIST
6669: LIST
6670: LIST
6671: LIST
6672: LIST
6673: LIST
6674: LIST
6675: LIST
6676: LIST
6677: LIST
6678: LIST
6679: LIST
6680: LIST
6681: LIST
6682: LIST
6683: LIST
6684: LIST
6685: LIST
6686: LIST
6687: LIST
6688: LIST
6689: LIST
6690: LIST
6691: PPUSH
6692: CALL 72611 0 2
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_siberium ] ) ;
6696: LD_INT 3
6698: PPUSH
6699: LD_INT 10
6701: PUSH
6702: LD_INT 12
6704: PUSH
6705: LD_INT 14
6707: PUSH
6708: LD_INT 11
6710: PUSH
6711: EMPTY
6712: LIST
6713: LIST
6714: LIST
6715: LIST
6716: PPUSH
6717: CALL 73461 0 2
// MC_SetFactoryExtension ( 3 , 94 , 161 , 0 , [ b_ext_noncombat , b_ext_gun , b_ext_rocket , b_ext_computer , b_ext_siberium ] ) ;
6721: LD_INT 3
6723: PPUSH
6724: LD_INT 94
6726: PPUSH
6727: LD_INT 161
6729: PPUSH
6730: LD_INT 0
6732: PPUSH
6733: LD_INT 19
6735: PUSH
6736: LD_INT 17
6738: PUSH
6739: LD_INT 18
6741: PUSH
6742: LD_INT 24
6744: PUSH
6745: LD_INT 21
6747: PUSH
6748: EMPTY
6749: LIST
6750: LIST
6751: LIST
6752: LIST
6753: LIST
6754: PPUSH
6755: CALL 73666 0 5
// MC_SetUpgradeBuilding ( 3 , b_depot ) ;
6759: LD_INT 3
6761: PPUSH
6762: LD_INT 0
6764: PPUSH
6765: CALL 73334 0 2
// MC_InsertProduceList ( 3 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] ] ) ;
6769: LD_INT 3
6771: PPUSH
6772: LD_INT 21
6774: PUSH
6775: LD_INT 1
6777: PUSH
6778: LD_INT 3
6780: PUSH
6781: LD_INT 51
6783: PUSH
6784: EMPTY
6785: LIST
6786: LIST
6787: LIST
6788: LIST
6789: PUSH
6790: EMPTY
6791: LIST
6792: PPUSH
6793: CALL 72767 0 2
// end ;
6797: LD_VAR 0 1
6801: RET
// every 9 9$00 trigger extraPopovForces and not ruDestroyed do
6802: LD_EXP 18
6806: PUSH
6807: LD_EXP 5
6811: NOT
6812: AND
6813: IFFALSE 6873
6815: GO 6817
6817: DISABLE
// begin ComMoveXY ( extraPopovForces , 106 , 137 ) ;
6818: LD_EXP 18
6822: PPUSH
6823: LD_INT 106
6825: PPUSH
6826: LD_INT 137
6828: PPUSH
6829: CALL_OW 111
// mc_bases := Replace ( mc_bases , 3 , mc_bases [ 3 ] union extraPopovForces ) ;
6833: LD_ADDR_EXP 23
6837: PUSH
6838: LD_EXP 23
6842: PPUSH
6843: LD_INT 3
6845: PPUSH
6846: LD_EXP 23
6850: PUSH
6851: LD_INT 3
6853: ARRAY
6854: PUSH
6855: LD_EXP 18
6859: UNION
6860: PPUSH
6861: CALL_OW 1
6865: ST_TO_ADDR
// extraPopovForces := [ ] ;
6866: LD_ADDR_EXP 18
6870: PUSH
6871: EMPTY
6872: ST_TO_ADDR
// end ;
6873: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ru_depot ) and not ruDestroyed do var i , base , tmp , attackers , amount ;
6874: LD_INT 9
6876: PPUSH
6877: CALL_OW 302
6881: PUSH
6882: LD_EXP 5
6886: NOT
6887: AND
6888: IFFALSE 7454
6890: GO 6892
6892: DISABLE
6893: LD_INT 0
6895: PPUSH
6896: PPUSH
6897: PPUSH
6898: PPUSH
6899: PPUSH
// begin enable ;
6900: ENABLE
// base := 3 ;
6901: LD_ADDR_VAR 0 2
6905: PUSH
6906: LD_INT 3
6908: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] ] ;
6909: LD_ADDR_VAR 0 3
6913: PUSH
6914: LD_INT 22
6916: PUSH
6917: LD_INT 1
6919: PUSH
6920: LD_INT 3
6922: PUSH
6923: LD_INT 44
6925: PUSH
6926: EMPTY
6927: LIST
6928: LIST
6929: LIST
6930: LIST
6931: PUSH
6932: LD_INT 24
6934: PUSH
6935: LD_INT 1
6937: PUSH
6938: LD_INT 3
6940: PUSH
6941: LD_INT 46
6943: PUSH
6944: EMPTY
6945: LIST
6946: LIST
6947: LIST
6948: LIST
6949: PUSH
6950: LD_INT 24
6952: PUSH
6953: LD_INT 1
6955: PUSH
6956: LD_INT 3
6958: PUSH
6959: LD_INT 46
6961: PUSH
6962: EMPTY
6963: LIST
6964: LIST
6965: LIST
6966: LIST
6967: PUSH
6968: LD_INT 24
6970: PUSH
6971: LD_INT 1
6973: PUSH
6974: LD_INT 3
6976: PUSH
6977: LD_INT 46
6979: PUSH
6980: EMPTY
6981: LIST
6982: LIST
6983: LIST
6984: LIST
6985: PUSH
6986: EMPTY
6987: LIST
6988: LIST
6989: LIST
6990: LIST
6991: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
6992: LD_ADDR_VAR 0 5
6996: PUSH
6997: LD_VAR 0 5
7001: PUSH
7002: LD_OWVAR 1
7006: PUSH
7007: LD_INT 21000
7009: DIV
7010: PLUS
7011: ST_TO_ADDR
// if amount > 8 then
7012: LD_VAR 0 5
7016: PUSH
7017: LD_INT 8
7019: GREATER
7020: IFFALSE 7030
// amount := 8 ;
7022: LD_ADDR_VAR 0 5
7026: PUSH
7027: LD_INT 8
7029: ST_TO_ADDR
// for i = 1 to amount do
7030: LD_ADDR_VAR 0 1
7034: PUSH
7035: DOUBLE
7036: LD_INT 1
7038: DEC
7039: ST_TO_ADDR
7040: LD_VAR 0 5
7044: PUSH
7045: FOR_TO
7046: IFFALSE 7111
// tmp := Insert ( tmp , tmp + 1 , [ ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
7048: LD_ADDR_VAR 0 3
7052: PUSH
7053: LD_VAR 0 3
7057: PPUSH
7058: LD_VAR 0 3
7062: PUSH
7063: LD_INT 1
7065: PLUS
7066: PPUSH
7067: LD_INT 24
7069: PUSH
7070: LD_INT 1
7072: PUSH
7073: LD_INT 3
7075: PUSH
7076: LD_INT 46
7078: PUSH
7079: LD_INT 45
7081: PUSH
7082: EMPTY
7083: LIST
7084: LIST
7085: PUSH
7086: LD_INT 1
7088: PPUSH
7089: LD_INT 2
7091: PPUSH
7092: CALL_OW 12
7096: ARRAY
7097: PUSH
7098: EMPTY
7099: LIST
7100: LIST
7101: LIST
7102: LIST
7103: PPUSH
7104: CALL_OW 2
7108: ST_TO_ADDR
7109: GO 7045
7111: POP
7112: POP
// MC_InsertProduceList ( base , tmp ) ;
7113: LD_VAR 0 2
7117: PPUSH
7118: LD_VAR 0 3
7122: PPUSH
7123: CALL 72767 0 2
// repeat wait ( 0 0$1 ) ;
7127: LD_INT 35
7129: PPUSH
7130: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
7134: LD_VAR 0 2
7138: PPUSH
7139: LD_INT 1
7141: PPUSH
7142: CALL 74185 0 2
7146: PUSH
7147: LD_VAR 0 5
7151: GREATEREQUAL
7152: IFFALSE 7127
// wait ( 0 0$30 ) ;
7154: LD_INT 1050
7156: PPUSH
7157: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
7161: LD_ADDR_VAR 0 4
7165: PUSH
7166: LD_EXP 42
7170: PUSH
7171: LD_VAR 0 2
7175: ARRAY
7176: PUSH
7177: LD_EXP 42
7181: PUSH
7182: LD_VAR 0 2
7186: ARRAY
7187: PPUSH
7188: LD_INT 2
7190: PUSH
7191: LD_INT 34
7193: PUSH
7194: LD_INT 51
7196: PUSH
7197: EMPTY
7198: LIST
7199: LIST
7200: PUSH
7201: LD_INT 34
7203: PUSH
7204: LD_INT 52
7206: PUSH
7207: EMPTY
7208: LIST
7209: LIST
7210: PUSH
7211: EMPTY
7212: LIST
7213: LIST
7214: LIST
7215: PPUSH
7216: CALL_OW 72
7220: DIFF
7221: ST_TO_ADDR
// if not attackers then
7222: LD_VAR 0 4
7226: NOT
7227: IFFALSE 7231
// exit ;
7229: GO 7454
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
7231: LD_ADDR_EXP 42
7235: PUSH
7236: LD_EXP 42
7240: PPUSH
7241: LD_VAR 0 2
7245: PPUSH
7246: LD_EXP 42
7250: PUSH
7251: LD_VAR 0 2
7255: ARRAY
7256: PUSH
7257: LD_VAR 0 4
7261: DIFF
7262: PPUSH
7263: CALL_OW 1
7267: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
7268: LD_VAR 0 4
7272: PPUSH
7273: LD_INT 107
7275: PPUSH
7276: LD_INT 74
7278: PPUSH
7279: CALL_OW 114
// wait ( 0 0$5 ) ;
7283: LD_INT 175
7285: PPUSH
7286: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
7290: LD_INT 35
7292: PPUSH
7293: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
7297: LD_VAR 0 4
7301: PPUSH
7302: LD_INT 60
7304: PUSH
7305: EMPTY
7306: LIST
7307: PPUSH
7308: CALL_OW 72
7312: NOT
7313: IFFALSE 7290
// if rand ( 0 , 1 ) then
7315: LD_INT 0
7317: PPUSH
7318: LD_INT 1
7320: PPUSH
7321: CALL_OW 12
7325: IFFALSE 7344
// ComAgressiveMove ( attackers , 155 , 108 ) else
7327: LD_VAR 0 4
7331: PPUSH
7332: LD_INT 155
7334: PPUSH
7335: LD_INT 108
7337: PPUSH
7338: CALL_OW 114
7342: GO 7359
// ComAgressiveMove ( attackers , 149 , 55 ) ;
7344: LD_VAR 0 4
7348: PPUSH
7349: LD_INT 149
7351: PPUSH
7352: LD_INT 55
7354: PPUSH
7355: CALL_OW 114
// wait ( 0 0$10 ) ;
7359: LD_INT 350
7361: PPUSH
7362: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
7366: LD_INT 35
7368: PPUSH
7369: CALL_OW 67
// for i in attackers do
7373: LD_ADDR_VAR 0 1
7377: PUSH
7378: LD_VAR 0 4
7382: PUSH
7383: FOR_IN
7384: IFFALSE 7434
// if not HasTask ( i ) then
7386: LD_VAR 0 1
7390: PPUSH
7391: CALL_OW 314
7395: NOT
7396: IFFALSE 7432
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
7398: LD_VAR 0 1
7402: PPUSH
7403: LD_INT 81
7405: PUSH
7406: LD_INT 3
7408: PUSH
7409: EMPTY
7410: LIST
7411: LIST
7412: PPUSH
7413: CALL_OW 69
7417: PPUSH
7418: LD_VAR 0 1
7422: PPUSH
7423: CALL_OW 74
7427: PPUSH
7428: CALL_OW 115
7432: GO 7383
7434: POP
7435: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
7436: LD_VAR 0 4
7440: PPUSH
7441: LD_INT 50
7443: PUSH
7444: EMPTY
7445: LIST
7446: PPUSH
7447: CALL_OW 72
7451: NOT
7452: IFFALSE 7366
// end ;
7454: PPOPN 5
7456: END
// every 12 12$00 + 10 10$00 trigger not ruDestroyed do var i , un , tmp , amount ;
7457: LD_EXP 5
7461: NOT
7462: IFFALSE 8049
7464: GO 7466
7466: DISABLE
7467: LD_INT 0
7469: PPUSH
7470: PPUSH
7471: PPUSH
7472: PPUSH
// begin enable ;
7473: ENABLE
// if Difficulty = 1 and tick < 30 30$00 then
7474: LD_OWVAR 67
7478: PUSH
7479: LD_INT 1
7481: EQUAL
7482: PUSH
7483: LD_OWVAR 1
7487: PUSH
7488: LD_INT 63000
7490: LESS
7491: AND
7492: IFFALSE 7496
// exit ;
7494: GO 8049
// tmp := [ ] ;
7496: LD_ADDR_VAR 0 3
7500: PUSH
7501: EMPTY
7502: ST_TO_ADDR
// if tick < 45 45$00 then
7503: LD_OWVAR 1
7507: PUSH
7508: LD_INT 94500
7510: LESS
7511: IFFALSE 7688
// begin for i := 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
7513: LD_ADDR_VAR 0 1
7517: PUSH
7518: DOUBLE
7519: LD_INT 1
7521: DEC
7522: ST_TO_ADDR
7523: LD_INT 2
7525: PUSH
7526: LD_INT 3
7528: PUSH
7529: LD_INT 4
7531: PUSH
7532: EMPTY
7533: LIST
7534: LIST
7535: LIST
7536: PUSH
7537: LD_OWVAR 67
7541: ARRAY
7542: PUSH
7543: FOR_TO
7544: IFFALSE 7686
// begin uc_side := 3 ;
7546: LD_ADDR_OWVAR 20
7550: PUSH
7551: LD_INT 3
7553: ST_TO_ADDR
// uc_nation := 3 ;
7554: LD_ADDR_OWVAR 21
7558: PUSH
7559: LD_INT 3
7561: ST_TO_ADDR
// InitHC_All ( ) ;
7562: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
7566: LD_INT 0
7568: PPUSH
7569: LD_INT 1
7571: PPUSH
7572: LD_INT 5
7574: PUSH
7575: LD_INT 6
7577: PUSH
7578: LD_INT 7
7580: PUSH
7581: EMPTY
7582: LIST
7583: LIST
7584: LIST
7585: PUSH
7586: LD_OWVAR 67
7590: ARRAY
7591: PPUSH
7592: CALL_OW 380
// un := CreateHuman ;
7596: LD_ADDR_VAR 0 2
7600: PUSH
7601: CALL_OW 44
7605: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
7606: LD_VAR 0 2
7610: PPUSH
7611: LD_INT 18
7613: PPUSH
7614: LD_INT 0
7616: PPUSH
7617: CALL_OW 49
// SetClass ( un , class_bazooker ) ;
7621: LD_VAR 0 2
7625: PPUSH
7626: LD_INT 9
7628: PPUSH
7629: CALL_OW 336
// ComMoveXY ( un , 147 , 161 ) ;
7633: LD_VAR 0 2
7637: PPUSH
7638: LD_INT 147
7640: PPUSH
7641: LD_INT 161
7643: PPUSH
7644: CALL_OW 111
// wait ( 0 0$2 ) ;
7648: LD_INT 70
7650: PPUSH
7651: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
7655: LD_ADDR_VAR 0 3
7659: PUSH
7660: LD_VAR 0 3
7664: PPUSH
7665: LD_VAR 0 3
7669: PUSH
7670: LD_INT 1
7672: PLUS
7673: PPUSH
7674: LD_VAR 0 2
7678: PPUSH
7679: CALL_OW 1
7683: ST_TO_ADDR
// end ;
7684: GO 7543
7686: POP
7687: POP
// end ; amount := [ 3 , 4 , 5 ] [ Difficulty ] + tick div 10 10$00 ;
7688: LD_ADDR_VAR 0 4
7692: PUSH
7693: LD_INT 3
7695: PUSH
7696: LD_INT 4
7698: PUSH
7699: LD_INT 5
7701: PUSH
7702: EMPTY
7703: LIST
7704: LIST
7705: LIST
7706: PUSH
7707: LD_OWVAR 67
7711: ARRAY
7712: PUSH
7713: LD_OWVAR 1
7717: PUSH
7718: LD_INT 21000
7720: DIV
7721: PLUS
7722: ST_TO_ADDR
// if amount > 15 then
7723: LD_VAR 0 4
7727: PUSH
7728: LD_INT 15
7730: GREATER
7731: IFFALSE 7741
// amount := 15 ;
7733: LD_ADDR_VAR 0 4
7737: PUSH
7738: LD_INT 15
7740: ST_TO_ADDR
// for i := 1 to amount do
7741: LD_ADDR_VAR 0 1
7745: PUSH
7746: DOUBLE
7747: LD_INT 1
7749: DEC
7750: ST_TO_ADDR
7751: LD_VAR 0 4
7755: PUSH
7756: FOR_TO
7757: IFFALSE 7903
// begin uc_side := 3 ;
7759: LD_ADDR_OWVAR 20
7763: PUSH
7764: LD_INT 3
7766: ST_TO_ADDR
// uc_nation := 3 ;
7767: LD_ADDR_OWVAR 21
7771: PUSH
7772: LD_INT 3
7774: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 5 ) ] , 90 ) ;
7775: LD_INT 24
7777: PPUSH
7778: LD_INT 1
7780: PPUSH
7781: LD_INT 3
7783: PPUSH
7784: LD_INT 46
7786: PUSH
7787: LD_INT 45
7789: PUSH
7790: LD_INT 44
7792: PUSH
7793: LD_INT 43
7795: PUSH
7796: LD_INT 42
7798: PUSH
7799: EMPTY
7800: LIST
7801: LIST
7802: LIST
7803: LIST
7804: LIST
7805: PUSH
7806: LD_INT 1
7808: PPUSH
7809: LD_INT 5
7811: PPUSH
7812: CALL_OW 12
7816: ARRAY
7817: PPUSH
7818: LD_INT 90
7820: PPUSH
7821: CALL 14861 0 5
// un := CreateVehicle ;
7825: LD_ADDR_VAR 0 2
7829: PUSH
7830: CALL_OW 45
7834: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
7835: LD_VAR 0 2
7839: PPUSH
7840: LD_INT 18
7842: PPUSH
7843: LD_INT 0
7845: PPUSH
7846: CALL_OW 49
// ComMoveXY ( un , 147 , 161 ) ;
7850: LD_VAR 0 2
7854: PPUSH
7855: LD_INT 147
7857: PPUSH
7858: LD_INT 161
7860: PPUSH
7861: CALL_OW 111
// wait ( 0 0$3 ) ;
7865: LD_INT 105
7867: PPUSH
7868: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
7872: LD_ADDR_VAR 0 3
7876: PUSH
7877: LD_VAR 0 3
7881: PPUSH
7882: LD_VAR 0 3
7886: PUSH
7887: LD_INT 1
7889: PLUS
7890: PPUSH
7891: LD_VAR 0 2
7895: PPUSH
7896: CALL_OW 1
7900: ST_TO_ADDR
// end ;
7901: GO 7756
7903: POP
7904: POP
// if not tmp then
7905: LD_VAR 0 3
7909: NOT
7910: IFFALSE 7914
// exit ;
7912: GO 8049
// wait ( 0 0$5 ) ;
7914: LD_INT 175
7916: PPUSH
7917: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
7921: LD_INT 70
7923: PPUSH
7924: CALL_OW 67
// for i in tmp do
7928: LD_ADDR_VAR 0 1
7932: PUSH
7933: LD_VAR 0 3
7937: PUSH
7938: FOR_IN
7939: IFFALSE 8040
// begin if not IsOk ( i ) or IsDead ( i ) then
7941: LD_VAR 0 1
7945: PPUSH
7946: CALL_OW 302
7950: NOT
7951: PUSH
7952: LD_VAR 0 1
7956: PPUSH
7957: CALL_OW 301
7961: OR
7962: IFFALSE 7980
// tmp := tmp diff i ;
7964: LD_ADDR_VAR 0 3
7968: PUSH
7969: LD_VAR 0 3
7973: PUSH
7974: LD_VAR 0 1
7978: DIFF
7979: ST_TO_ADDR
// if GetClass ( i ) = class_bazooker then
7980: LD_VAR 0 1
7984: PPUSH
7985: CALL_OW 257
7989: PUSH
7990: LD_INT 9
7992: EQUAL
7993: IFFALSE 8004
// ComSpaceTimeShoot ( i ) ;
7995: LD_VAR 0 1
7999: PPUSH
8000: CALL 10944 0 1
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8004: LD_VAR 0 1
8008: PPUSH
8009: LD_INT 81
8011: PUSH
8012: LD_INT 3
8014: PUSH
8015: EMPTY
8016: LIST
8017: LIST
8018: PPUSH
8019: CALL_OW 69
8023: PPUSH
8024: LD_VAR 0 1
8028: PPUSH
8029: CALL_OW 74
8033: PPUSH
8034: CALL_OW 115
// end ;
8038: GO 7938
8040: POP
8041: POP
// until not tmp ;
8042: LD_VAR 0 3
8046: NOT
8047: IFFALSE 7921
// end ; end_of_file
8049: PPOPN 4
8051: END
// export Sikorski ; export function PrepareSikorski ; var i , j , un ; begin
8052: LD_INT 0
8054: PPUSH
8055: PPUSH
8056: PPUSH
8057: PPUSH
// uc_side := 1 ;
8058: LD_ADDR_OWVAR 20
8062: PUSH
8063: LD_INT 1
8065: ST_TO_ADDR
// uc_nation := 1 ;
8066: LD_ADDR_OWVAR 21
8070: PUSH
8071: LD_INT 1
8073: ST_TO_ADDR
// hc_importance := 100 ;
8074: LD_ADDR_OWVAR 32
8078: PUSH
8079: LD_INT 100
8081: ST_TO_ADDR
// hc_name := Jeremy Sikorski ;
8082: LD_ADDR_OWVAR 26
8086: PUSH
8087: LD_STRING Jeremy Sikorski
8089: ST_TO_ADDR
// hc_gallery := us ;
8090: LD_ADDR_OWVAR 33
8094: PUSH
8095: LD_STRING us
8097: ST_TO_ADDR
// hc_face_number := 19 ;
8098: LD_ADDR_OWVAR 34
8102: PUSH
8103: LD_INT 19
8105: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , [ 4 , 4 , 3 ] [ Difficulty ] ) ;
8106: LD_INT 1
8108: PPUSH
8109: LD_INT 1
8111: PPUSH
8112: LD_INT 4
8114: PUSH
8115: LD_INT 4
8117: PUSH
8118: LD_INT 3
8120: PUSH
8121: EMPTY
8122: LIST
8123: LIST
8124: LIST
8125: PUSH
8126: LD_OWVAR 67
8130: ARRAY
8131: PPUSH
8132: CALL_OW 380
// hc_attr := [ 10 , 12 ] ;
8136: LD_ADDR_OWVAR 29
8140: PUSH
8141: LD_INT 10
8143: PUSH
8144: LD_INT 12
8146: PUSH
8147: EMPTY
8148: LIST
8149: LIST
8150: ST_TO_ADDR
// Sikorski := CreateHuman ;
8151: LD_ADDR_EXP 20
8155: PUSH
8156: CALL_OW 44
8160: ST_TO_ADDR
// PlaceUnitXYR ( Sikorski , 133 , 19 , 2 , false ) ;
8161: LD_EXP 20
8165: PPUSH
8166: LD_INT 133
8168: PPUSH
8169: LD_INT 19
8171: PPUSH
8172: LD_INT 2
8174: PPUSH
8175: LD_INT 0
8177: PPUSH
8178: CALL_OW 50
// InitHc_All ( ) ;
8182: CALL_OW 584
// for i := 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
8186: LD_ADDR_VAR 0 2
8190: PUSH
8191: DOUBLE
8192: LD_INT 1
8194: DEC
8195: ST_TO_ADDR
8196: LD_INT 4
8198: PUSH
8199: LD_INT 3
8201: PUSH
8202: LD_INT 3
8204: PUSH
8205: EMPTY
8206: LIST
8207: LIST
8208: LIST
8209: PUSH
8210: LD_OWVAR 67
8214: ARRAY
8215: PUSH
8216: FOR_TO
8217: IFFALSE 8333
// for j := 1 to 4 do
8219: LD_ADDR_VAR 0 3
8223: PUSH
8224: DOUBLE
8225: LD_INT 1
8227: DEC
8228: ST_TO_ADDR
8229: LD_INT 4
8231: PUSH
8232: FOR_TO
8233: IFFALSE 8329
// begin PrepareHuman ( false , j , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
8235: LD_INT 0
8237: PPUSH
8238: LD_VAR 0 3
8242: PPUSH
8243: LD_INT 5
8245: PUSH
8246: LD_INT 4
8248: PUSH
8249: LD_INT 3
8251: PUSH
8252: EMPTY
8253: LIST
8254: LIST
8255: LIST
8256: PUSH
8257: LD_OWVAR 67
8261: ARRAY
8262: PPUSH
8263: CALL_OW 380
// un := CreateHuman ;
8267: LD_ADDR_VAR 0 4
8271: PUSH
8272: CALL_OW 44
8276: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
8277: LD_VAR 0 4
8281: PPUSH
8282: LD_INT 0
8284: PPUSH
8285: LD_INT 5
8287: PPUSH
8288: CALL_OW 12
8292: PPUSH
8293: CALL_OW 233
// PlaceUnitXYR ( un , 133 , 19 , 6 , false ) ;
8297: LD_VAR 0 4
8301: PPUSH
8302: LD_INT 133
8304: PPUSH
8305: LD_INT 19
8307: PPUSH
8308: LD_INT 6
8310: PPUSH
8311: LD_INT 0
8313: PPUSH
8314: CALL_OW 50
// ComHold ( un ) ;
8318: LD_VAR 0 4
8322: PPUSH
8323: CALL_OW 140
// end ;
8327: GO 8232
8329: POP
8330: POP
8331: GO 8216
8333: POP
8334: POP
// vc_chassis := us_heavy_tracked ;
8335: LD_ADDR_OWVAR 37
8339: PUSH
8340: LD_INT 4
8342: ST_TO_ADDR
// vc_engine := engine_combustion ;
8343: LD_ADDR_OWVAR 39
8347: PUSH
8348: LD_INT 1
8350: ST_TO_ADDR
// vc_control := control_manual ;
8351: LD_ADDR_OWVAR 38
8355: PUSH
8356: LD_INT 1
8358: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
8359: LD_ADDR_OWVAR 40
8363: PUSH
8364: LD_INT 14
8366: ST_TO_ADDR
// vc_fuel_battery := 60 ;
8367: LD_ADDR_OWVAR 41
8371: PUSH
8372: LD_INT 60
8374: ST_TO_ADDR
// un := CreateVehicle ;
8375: LD_ADDR_VAR 0 4
8379: PUSH
8380: CALL_OW 45
8384: ST_TO_ADDR
// SetDir ( un , 2 ) ;
8385: LD_VAR 0 4
8389: PPUSH
8390: LD_INT 2
8392: PPUSH
8393: CALL_OW 233
// PlaceUnitXY ( un , 128 , 12 , false ) ;
8397: LD_VAR 0 4
8401: PPUSH
8402: LD_INT 128
8404: PPUSH
8405: LD_INT 12
8407: PPUSH
8408: LD_INT 0
8410: PPUSH
8411: CALL_OW 48
// for i := 1 to 3 do
8415: LD_ADDR_VAR 0 2
8419: PUSH
8420: DOUBLE
8421: LD_INT 1
8423: DEC
8424: ST_TO_ADDR
8425: LD_INT 3
8427: PUSH
8428: FOR_TO
8429: IFFALSE 8452
// CreateCratesXYR ( 5 , 133 , 19 , 3 , false ) ;
8431: LD_INT 5
8433: PPUSH
8434: LD_INT 133
8436: PPUSH
8437: LD_INT 19
8439: PPUSH
8440: LD_INT 3
8442: PPUSH
8443: LD_INT 0
8445: PPUSH
8446: CALL_OW 56
8450: GO 8428
8452: POP
8453: POP
// end ; end_of_file
8454: LD_VAR 0 1
8458: RET
// export function Action ; begin
8459: LD_INT 0
8461: PPUSH
// InGameOn ;
8462: CALL_OW 8
// CenterNowOnXY ( 133 , 19 ) ;
8466: LD_INT 133
8468: PPUSH
8469: LD_INT 19
8471: PPUSH
8472: CALL_OW 86
// Say ( Sikorski , WT-DS-1 ) ;
8476: LD_EXP 20
8480: PPUSH
8481: LD_STRING WT-DS-1
8483: PPUSH
8484: CALL_OW 88
// InGameOff ;
8488: CALL_OW 9
// ChangeMissionObjectives ( DestroyEnemy ) ;
8492: LD_STRING DestroyEnemy
8494: PPUSH
8495: CALL_OW 337
// wait ( 0 0$20 ) ;
8499: LD_INT 700
8501: PPUSH
8502: CALL_OW 67
// DialogueOn ;
8506: CALL_OW 6
// PlaceSeeing ( 100 , 37 , 1 , - 30 ) ;
8510: LD_INT 100
8512: PPUSH
8513: LD_INT 37
8515: PPUSH
8516: LD_INT 1
8518: PPUSH
8519: LD_INT 30
8521: NEG
8522: PPUSH
8523: CALL_OW 330
// CenterNowOnXY ( 100 , 37 ) ;
8527: LD_INT 100
8529: PPUSH
8530: LD_INT 37
8532: PPUSH
8533: CALL_OW 86
// SayRadio ( Powell , WT-PL-1 ) ;
8537: LD_EXP 10
8541: PPUSH
8542: LD_STRING WT-PL-1
8544: PPUSH
8545: CALL_OW 94
// Say ( Sikorski , WT-DS-2 ) ;
8549: LD_EXP 20
8553: PPUSH
8554: LD_STRING WT-DS-2
8556: PPUSH
8557: CALL_OW 88
// DialogueOff ;
8561: CALL_OW 7
// wait ( 0 0$2 ) ;
8565: LD_INT 70
8567: PPUSH
8568: CALL_OW 67
// RemoveSeeing ( 100 , 37 , 1 ) ;
8572: LD_INT 100
8574: PPUSH
8575: LD_INT 37
8577: PPUSH
8578: LD_INT 1
8580: PPUSH
8581: CALL_OW 331
// end ;
8585: LD_VAR 0 1
8589: RET
// export function DialogPowellsAttack ; begin
8590: LD_INT 0
8592: PPUSH
// SayRadio ( Powell , WT-PL-8 ) ;
8593: LD_EXP 10
8597: PPUSH
8598: LD_STRING WT-PL-8
8600: PPUSH
8601: CALL_OW 94
// end ;
8605: LD_VAR 0 1
8609: RET
// export function DialogContaminateSib ( x , y ) ; begin
8610: LD_INT 0
8612: PPUSH
// DialogueOn ;
8613: CALL_OW 6
// CenterNowOnXY ( x , y ) ;
8617: LD_VAR 0 1
8621: PPUSH
8622: LD_VAR 0 2
8626: PPUSH
8627: CALL_OW 86
// Say ( Sikorski , WT-DS-3 ) ;
8631: LD_EXP 20
8635: PPUSH
8636: LD_STRING WT-DS-3
8638: PPUSH
8639: CALL_OW 88
// DialogueOff ;
8643: CALL_OW 7
// end ;
8647: LD_VAR 0 3
8651: RET
// every 0 0$3 trigger not powellInTrouble and FilterUnitsInArea ( powell_base , [ f_enemy , 4 ] ) > 3 do
8652: LD_EXP 8
8656: NOT
8657: PUSH
8658: LD_INT 1
8660: PPUSH
8661: LD_INT 81
8663: PUSH
8664: LD_INT 4
8666: PUSH
8667: EMPTY
8668: LIST
8669: LIST
8670: PPUSH
8671: CALL_OW 70
8675: PUSH
8676: LD_INT 3
8678: GREATER
8679: AND
8680: IFFALSE 8752
8682: GO 8684
8684: DISABLE
// begin powellInTrouble := true ;
8685: LD_ADDR_EXP 8
8689: PUSH
8690: LD_INT 1
8692: ST_TO_ADDR
// Say ( Sikorski , WT-DS-6 ) ;
8693: LD_EXP 20
8697: PPUSH
8698: LD_STRING WT-DS-6
8700: PPUSH
8701: CALL_OW 88
// if not FilterUnitsInArea ( powell_base , [ f_side , 1 ] ) then
8705: LD_INT 1
8707: PPUSH
8708: LD_INT 22
8710: PUSH
8711: LD_INT 1
8713: PUSH
8714: EMPTY
8715: LIST
8716: LIST
8717: PPUSH
8718: CALL_OW 70
8722: NOT
8723: IFFALSE 8737
// SayRadio ( Powell , WT-PL-6 ) ;
8725: LD_EXP 10
8729: PPUSH
8730: LD_STRING WT-PL-6
8732: PPUSH
8733: CALL_OW 94
// wait ( 1 1$30 ) ;
8737: LD_INT 3150
8739: PPUSH
8740: CALL_OW 67
// powellInTrouble := false ;
8744: LD_ADDR_EXP 8
8748: PUSH
8749: LD_INT 0
8751: ST_TO_ADDR
// end ;
8752: END
// every 0 0$3 trigger not sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 1 ] ) > 6 do
8753: LD_EXP 9
8757: NOT
8758: PUSH
8759: LD_INT 16
8761: PPUSH
8762: LD_INT 81
8764: PUSH
8765: LD_INT 1
8767: PUSH
8768: EMPTY
8769: LIST
8770: LIST
8771: PPUSH
8772: CALL_OW 70
8776: PUSH
8777: LD_INT 6
8779: GREATER
8780: AND
8781: IFFALSE 8854
8783: GO 8785
8785: DISABLE
// begin sikorskiInTrouble := true ;
8786: LD_ADDR_EXP 9
8790: PUSH
8791: LD_INT 1
8793: ST_TO_ADDR
// Say ( Sikorski , WT-DS-7 ) ;
8794: LD_EXP 20
8798: PPUSH
8799: LD_STRING WT-DS-7
8801: PPUSH
8802: CALL_OW 88
// if not powellAttackGroup then
8806: LD_EXP 12
8810: NOT
8811: IFFALSE 8827
// SayRadio ( Powell , WT-PL-7n ) else
8813: LD_EXP 10
8817: PPUSH
8818: LD_STRING WT-PL-7n
8820: PPUSH
8821: CALL_OW 94
8825: GO 8839
// SayRadio ( Powell , WT-PL-7y ) ;
8827: LD_EXP 10
8831: PPUSH
8832: LD_STRING WT-PL-7y
8834: PPUSH
8835: CALL_OW 94
// wait ( 1 1$30 ) ;
8839: LD_INT 3150
8841: PPUSH
8842: CALL_OW 67
// sikorskiInTrouble := false ;
8846: LD_ADDR_EXP 9
8850: PUSH
8851: LD_INT 0
8853: ST_TO_ADDR
// end ;
8854: END
// export function DialogPowellsAttackFailed ; begin
8855: LD_INT 0
8857: PPUSH
// if not ruDestroyed then
8858: LD_EXP 5
8862: NOT
8863: IFFALSE 8879
// SayRadio ( Powell , WT-PL-9 ) else
8865: LD_EXP 10
8869: PPUSH
8870: LD_STRING WT-PL-9
8872: PPUSH
8873: CALL_OW 94
8877: GO 8891
// SayRadio ( Powell , WT-PL-10 ) ;
8879: LD_EXP 10
8883: PPUSH
8884: LD_STRING WT-PL-10
8886: PPUSH
8887: CALL_OW 94
// end ;
8891: LD_VAR 0 1
8895: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
8896: LD_INT 22
8898: PUSH
8899: LD_INT 2
8901: PUSH
8902: EMPTY
8903: LIST
8904: LIST
8905: PUSH
8906: LD_INT 21
8908: PUSH
8909: LD_INT 1
8911: PUSH
8912: EMPTY
8913: LIST
8914: LIST
8915: PUSH
8916: EMPTY
8917: LIST
8918: LIST
8919: PPUSH
8920: CALL_OW 69
8924: PUSH
8925: LD_INT 0
8927: EQUAL
8928: IFFALSE 8972
8930: GO 8932
8932: DISABLE
// begin arDestroyed := true ;
8933: LD_ADDR_EXP 4
8937: PUSH
8938: LD_INT 1
8940: ST_TO_ADDR
// MC_Kill ( 2 ) ;
8941: LD_INT 2
8943: PPUSH
8944: CALL 48994 0 1
// Say ( Sikorski , WT-DS-4 ) ;
8948: LD_EXP 20
8952: PPUSH
8953: LD_STRING WT-DS-4
8955: PPUSH
8956: CALL_OW 88
// SayRadio ( Powell , WT-PL-4 ) ;
8960: LD_EXP 10
8964: PPUSH
8965: LD_STRING WT-PL-4
8967: PPUSH
8968: CALL_OW 94
// end ;
8972: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
8973: LD_INT 22
8975: PUSH
8976: LD_INT 3
8978: PUSH
8979: EMPTY
8980: LIST
8981: LIST
8982: PUSH
8983: LD_INT 21
8985: PUSH
8986: LD_INT 1
8988: PUSH
8989: EMPTY
8990: LIST
8991: LIST
8992: PUSH
8993: EMPTY
8994: LIST
8995: LIST
8996: PPUSH
8997: CALL_OW 69
9001: PUSH
9002: LD_INT 0
9004: EQUAL
9005: IFFALSE 9049
9007: GO 9009
9009: DISABLE
// begin ruDestroyed := true ;
9010: LD_ADDR_EXP 5
9014: PUSH
9015: LD_INT 1
9017: ST_TO_ADDR
// MC_Kill ( 3 ) ;
9018: LD_INT 3
9020: PPUSH
9021: CALL 48994 0 1
// Say ( Sikorski , WT-DS-5 ) ;
9025: LD_EXP 20
9029: PPUSH
9030: LD_STRING WT-DS-5
9032: PPUSH
9033: CALL_OW 88
// SayRadio ( Powell , WT-PL-5 ) ;
9037: LD_EXP 10
9041: PPUSH
9042: LD_STRING WT-PL-5
9044: PPUSH
9045: CALL_OW 94
// end ;
9049: END
// every 0 0$1 trigger ruDestroyed and arDestroyed do
9050: LD_EXP 5
9054: PUSH
9055: LD_EXP 4
9059: AND
9060: IFFALSE 9233
9062: GO 9064
9064: DISABLE
// begin wait ( 0 0$3 ) ;
9065: LD_INT 105
9067: PPUSH
9068: CALL_OW 67
// if tick >= [ 60 60$00 , 50 50$00 , 45 45$00 ] [ Difficulty ] then
9072: LD_OWVAR 1
9076: PUSH
9077: LD_INT 126000
9079: PUSH
9080: LD_INT 105000
9082: PUSH
9083: LD_INT 94500
9085: PUSH
9086: EMPTY
9087: LIST
9088: LIST
9089: LIST
9090: PUSH
9091: LD_OWVAR 67
9095: ARRAY
9096: GREATEREQUAL
9097: IFFALSE 9112
// AddMedal ( WoT-med-1 , - 1 ) else
9099: LD_STRING WoT-med-1
9101: PPUSH
9102: LD_INT 1
9104: NEG
9105: PPUSH
9106: CALL_OW 101
9110: GO 9122
// AddMedal ( WoT-med-1 , 1 ) ;
9112: LD_STRING WoT-med-1
9114: PPUSH
9115: LD_INT 1
9117: PPUSH
9118: CALL_OW 101
// if loseCounter >= [ 4 , 3 , 2 ] [ Difficulty ] then
9122: LD_EXP 6
9126: PUSH
9127: LD_INT 4
9129: PUSH
9130: LD_INT 3
9132: PUSH
9133: LD_INT 2
9135: PUSH
9136: EMPTY
9137: LIST
9138: LIST
9139: LIST
9140: PUSH
9141: LD_OWVAR 67
9145: ARRAY
9146: GREATEREQUAL
9147: IFFALSE 9162
// AddMedal ( WoT-med-2 , - 1 ) else
9149: LD_STRING WoT-med-2
9151: PPUSH
9152: LD_INT 1
9154: NEG
9155: PPUSH
9156: CALL_OW 101
9160: GO 9172
// AddMedal ( WoT-med-2 , 1 ) ;
9162: LD_STRING WoT-med-2
9164: PPUSH
9165: LD_INT 1
9167: PPUSH
9168: CALL_OW 101
// if powellLoseCounter >= [ 8 , 6 , 5 ] [ Difficulty ] then
9172: LD_EXP 7
9176: PUSH
9177: LD_INT 8
9179: PUSH
9180: LD_INT 6
9182: PUSH
9183: LD_INT 5
9185: PUSH
9186: EMPTY
9187: LIST
9188: LIST
9189: LIST
9190: PUSH
9191: LD_OWVAR 67
9195: ARRAY
9196: GREATEREQUAL
9197: IFFALSE 9212
// AddMedal ( WoT-med-3 , - 1 ) else
9199: LD_STRING WoT-med-3
9201: PPUSH
9202: LD_INT 1
9204: NEG
9205: PPUSH
9206: CALL_OW 101
9210: GO 9222
// AddMedal ( WoT-med-3 , 1 ) ;
9212: LD_STRING WoT-med-3
9214: PPUSH
9215: LD_INT 1
9217: PPUSH
9218: CALL_OW 101
// GiveMedals ( MAIN ) ;
9222: LD_STRING MAIN
9224: PPUSH
9225: CALL_OW 102
// YouWin ;
9229: CALL_OW 103
// end ; end_of_file
9233: END
// export function CustomEvent ( event ) ; begin
9234: LD_INT 0
9236: PPUSH
// end ;
9237: LD_VAR 0 2
9241: RET
// on Command ( com ) do var i , j , temp ;
9242: LD_INT 0
9244: PPUSH
9245: PPUSH
9246: PPUSH
// begin if com = 60 then
9247: LD_VAR 0 1
9251: PUSH
9252: LD_INT 60
9254: EQUAL
9255: IFFALSE 9434
// begin for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_weapon , us_cargo_bay ] ] ] ) do
9257: LD_ADDR_VAR 0 2
9261: PUSH
9262: LD_INT 22
9264: PUSH
9265: LD_INT 1
9267: PUSH
9268: EMPTY
9269: LIST
9270: LIST
9271: PUSH
9272: LD_INT 2
9274: PUSH
9275: LD_INT 21
9277: PUSH
9278: LD_INT 1
9280: PUSH
9281: EMPTY
9282: LIST
9283: LIST
9284: PUSH
9285: LD_INT 34
9287: PUSH
9288: LD_INT 12
9290: PUSH
9291: EMPTY
9292: LIST
9293: LIST
9294: PUSH
9295: EMPTY
9296: LIST
9297: LIST
9298: LIST
9299: PUSH
9300: EMPTY
9301: LIST
9302: LIST
9303: PPUSH
9304: CALL_OW 69
9308: PUSH
9309: FOR_IN
9310: IFFALSE 9432
// begin if GetTaskList ( i ) > 0 then
9312: LD_VAR 0 2
9316: PPUSH
9317: CALL_OW 437
9321: PUSH
9322: LD_INT 0
9324: GREATER
9325: IFFALSE 9430
// for j = 1 to GetTaskList ( i ) do
9327: LD_ADDR_VAR 0 3
9331: PUSH
9332: DOUBLE
9333: LD_INT 1
9335: DEC
9336: ST_TO_ADDR
9337: LD_VAR 0 2
9341: PPUSH
9342: CALL_OW 437
9346: PUSH
9347: FOR_TO
9348: IFFALSE 9428
// begin temp = GetTaskList ( i ) [ j ] [ 4 ] ;
9350: LD_ADDR_VAR 0 4
9354: PUSH
9355: LD_VAR 0 2
9359: PPUSH
9360: CALL_OW 437
9364: PUSH
9365: LD_VAR 0 3
9369: ARRAY
9370: PUSH
9371: LD_INT 4
9373: ARRAY
9374: ST_TO_ADDR
// if GetSide ( temp ) = 4 and GetTaskList ( i ) [ j ] [ 1 ] = < then
9375: LD_VAR 0 4
9379: PPUSH
9380: CALL_OW 255
9384: PUSH
9385: LD_INT 4
9387: EQUAL
9388: PUSH
9389: LD_VAR 0 2
9393: PPUSH
9394: CALL_OW 437
9398: PUSH
9399: LD_VAR 0 3
9403: ARRAY
9404: PUSH
9405: LD_INT 1
9407: ARRAY
9408: PUSH
9409: LD_STRING <
9411: EQUAL
9412: AND
9413: IFFALSE 9426
// SetTaskList ( i , [ ] ) ;
9415: LD_VAR 0 2
9419: PPUSH
9420: EMPTY
9421: PPUSH
9422: CALL_OW 446
// end ;
9426: GO 9347
9428: POP
9429: POP
// end ;
9430: GO 9309
9432: POP
9433: POP
// end ; end ;
9434: PPOPN 4
9436: END
// on SibDepositContaminated ( sci , x , y ) do begin if GetSide ( HexInfo ( x , y ) ) = 1 or ( x = 132 and y = 39 ) then
9437: LD_VAR 0 2
9441: PPUSH
9442: LD_VAR 0 3
9446: PPUSH
9447: CALL_OW 428
9451: PPUSH
9452: CALL_OW 255
9456: PUSH
9457: LD_INT 1
9459: EQUAL
9460: PUSH
9461: LD_VAR 0 2
9465: PUSH
9466: LD_INT 132
9468: EQUAL
9469: PUSH
9470: LD_VAR 0 3
9474: PUSH
9475: LD_INT 39
9477: EQUAL
9478: AND
9479: OR
9480: IFFALSE 9496
// DialogContaminateSib ( x , y ) ;
9482: LD_VAR 0 2
9486: PPUSH
9487: LD_VAR 0 3
9491: PPUSH
9492: CALL 8610 0 2
// end ;
9496: PPOPN 3
9498: END
// on UnitDestroyed ( un ) do begin MCE_UnitDestroyed ( un ) ;
9499: LD_VAR 0 1
9503: PPUSH
9504: CALL 76187 0 1
// if un = Powell then
9508: LD_VAR 0 1
9512: PUSH
9513: LD_EXP 10
9517: EQUAL
9518: IFFALSE 9527
// YouLost ( Powell ) ;
9520: LD_STRING Powell
9522: PPUSH
9523: CALL_OW 104
// if un = Sikorski then
9527: LD_VAR 0 1
9531: PUSH
9532: LD_EXP 20
9536: EQUAL
9537: IFFALSE 9546
// YouLost ( Sikorski ) ;
9539: LD_STRING Sikorski
9541: PPUSH
9542: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) then
9546: LD_VAR 0 1
9550: PUSH
9551: LD_INT 22
9553: PUSH
9554: LD_INT 1
9556: PUSH
9557: EMPTY
9558: LIST
9559: LIST
9560: PUSH
9561: LD_INT 21
9563: PUSH
9564: LD_INT 1
9566: PUSH
9567: EMPTY
9568: LIST
9569: LIST
9570: PUSH
9571: EMPTY
9572: LIST
9573: LIST
9574: PPUSH
9575: CALL_OW 69
9579: IN
9580: IFFALSE 9596
// loseCounter := loseCounter + 1 ;
9582: LD_ADDR_EXP 6
9586: PUSH
9587: LD_EXP 6
9591: PUSH
9592: LD_INT 1
9594: PLUS
9595: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) then
9596: LD_VAR 0 1
9600: PUSH
9601: LD_INT 22
9603: PUSH
9604: LD_INT 4
9606: PUSH
9607: EMPTY
9608: LIST
9609: LIST
9610: PUSH
9611: LD_INT 21
9613: PUSH
9614: LD_INT 1
9616: PUSH
9617: EMPTY
9618: LIST
9619: LIST
9620: PUSH
9621: EMPTY
9622: LIST
9623: LIST
9624: PPUSH
9625: CALL_OW 69
9629: IN
9630: IFFALSE 9646
// powellLoseCounter := powellLoseCounter + 1 ;
9632: LD_ADDR_EXP 7
9636: PUSH
9637: LD_EXP 7
9641: PUSH
9642: LD_INT 1
9644: PLUS
9645: ST_TO_ADDR
// if un in powellAttackGroup then
9646: LD_VAR 0 1
9650: PUSH
9651: LD_EXP 12
9655: IN
9656: IFFALSE 9674
// powellAttackGroup := powellAttackGroup diff un ;
9658: LD_ADDR_EXP 12
9662: PUSH
9663: LD_EXP 12
9667: PUSH
9668: LD_VAR 0 1
9672: DIFF
9673: ST_TO_ADDR
// if un in gensherAttackGroup then
9674: LD_VAR 0 1
9678: PUSH
9679: LD_EXP 15
9683: IN
9684: IFFALSE 9702
// gensherAttackGroup := gensherAttackGroup diff un ;
9686: LD_ADDR_EXP 15
9690: PUSH
9691: LD_EXP 15
9695: PUSH
9696: LD_VAR 0 1
9700: DIFF
9701: ST_TO_ADDR
// if un in popovAttackGroup then
9702: LD_VAR 0 1
9706: PUSH
9707: LD_EXP 19
9711: IN
9712: IFFALSE 9730
// popovAttackGroup := popovAttackGroup diff un ;
9714: LD_ADDR_EXP 19
9718: PUSH
9719: LD_EXP 19
9723: PUSH
9724: LD_VAR 0 1
9728: DIFF
9729: ST_TO_ADDR
// end ;
9730: PPOPN 1
9732: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
9733: LD_VAR 0 1
9737: PPUSH
9738: LD_VAR 0 2
9742: PPUSH
9743: CALL 78521 0 2
// end ;
9747: PPOPN 2
9749: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
9750: LD_VAR 0 1
9754: PPUSH
9755: CALL 77589 0 1
// end ;
9759: PPOPN 1
9761: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
9762: LD_VAR 0 1
9766: PPUSH
9767: CALL 77830 0 1
// end ;
9771: PPOPN 1
9773: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
9774: LD_VAR 0 1
9778: PPUSH
9779: LD_VAR 0 2
9783: PPUSH
9784: CALL 75883 0 2
// end ;
9788: PPOPN 2
9790: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
9791: LD_VAR 0 1
9795: PPUSH
9796: LD_VAR 0 2
9800: PPUSH
9801: LD_VAR 0 3
9805: PPUSH
9806: LD_VAR 0 4
9810: PPUSH
9811: LD_VAR 0 5
9815: PPUSH
9816: CALL 75503 0 5
// end ;
9820: PPOPN 5
9822: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
9823: LD_VAR 0 1
9827: PPUSH
9828: LD_VAR 0 2
9832: PPUSH
9833: CALL 75084 0 2
// end ;
9837: PPOPN 2
9839: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
9840: LD_VAR 0 1
9844: PPUSH
9845: LD_VAR 0 2
9849: PPUSH
9850: LD_VAR 0 3
9854: PPUSH
9855: LD_VAR 0 4
9859: PPUSH
9860: CALL 74922 0 4
// end ;
9864: PPOPN 4
9866: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
9867: LD_VAR 0 1
9871: PPUSH
9872: LD_VAR 0 2
9876: PPUSH
9877: LD_VAR 0 3
9881: PPUSH
9882: CALL 74697 0 3
// end ;
9886: PPOPN 3
9888: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
9889: LD_VAR 0 1
9893: PPUSH
9894: LD_VAR 0 2
9898: PPUSH
9899: CALL 74582 0 2
// end ;
9903: PPOPN 2
9905: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
9906: LD_VAR 0 1
9910: PPUSH
9911: LD_VAR 0 2
9915: PPUSH
9916: CALL 78816 0 2
// end ;
9920: PPOPN 2
9922: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
9923: LD_VAR 0 1
9927: PPUSH
9928: LD_VAR 0 2
9932: PPUSH
9933: LD_VAR 0 3
9937: PPUSH
9938: LD_VAR 0 4
9942: PPUSH
9943: CALL 79032 0 4
// end ;
9947: PPOPN 4
9949: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
9950: LD_VAR 0 1
9954: PPUSH
9955: LD_VAR 0 2
9959: PPUSH
9960: CALL 74391 0 2
// end ;
9964: PPOPN 2
9966: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 then
9967: LD_VAR 0 1
9971: PUSH
9972: LD_INT 1
9974: EQUAL
9975: PUSH
9976: LD_VAR 0 2
9980: PUSH
9981: LD_INT 4
9983: EQUAL
9984: AND
9985: IFFALSE 9994
// YouLost ( FriendlyFire ) ;
9987: LD_STRING FriendlyFire
9989: PPUSH
9990: CALL_OW 104
// end ; end_of_file
9994: PPOPN 2
9996: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
9997: LD_INT 0
9999: PPUSH
10000: PPUSH
// if exist_mode then
10001: LD_VAR 0 2
10005: IFFALSE 10030
// unit := CreateCharacter ( prefix & ident ) else
10007: LD_ADDR_VAR 0 5
10011: PUSH
10012: LD_VAR 0 3
10016: PUSH
10017: LD_VAR 0 1
10021: STR
10022: PPUSH
10023: CALL_OW 34
10027: ST_TO_ADDR
10028: GO 10045
// unit := NewCharacter ( ident ) ;
10030: LD_ADDR_VAR 0 5
10034: PUSH
10035: LD_VAR 0 1
10039: PPUSH
10040: CALL_OW 25
10044: ST_TO_ADDR
// result := unit ;
10045: LD_ADDR_VAR 0 4
10049: PUSH
10050: LD_VAR 0 5
10054: ST_TO_ADDR
// end ;
10055: LD_VAR 0 4
10059: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
10060: LD_INT 0
10062: PPUSH
10063: PPUSH
// if not side or not nation then
10064: LD_VAR 0 1
10068: NOT
10069: PUSH
10070: LD_VAR 0 2
10074: NOT
10075: OR
10076: IFFALSE 10080
// exit ;
10078: GO 10848
// case nation of nation_american :
10080: LD_VAR 0 2
10084: PUSH
10085: LD_INT 1
10087: DOUBLE
10088: EQUAL
10089: IFTRUE 10093
10091: GO 10307
10093: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
10094: LD_ADDR_VAR 0 4
10098: PUSH
10099: LD_INT 35
10101: PUSH
10102: LD_INT 45
10104: PUSH
10105: LD_INT 46
10107: PUSH
10108: LD_INT 47
10110: PUSH
10111: LD_INT 82
10113: PUSH
10114: LD_INT 83
10116: PUSH
10117: LD_INT 84
10119: PUSH
10120: LD_INT 85
10122: PUSH
10123: LD_INT 86
10125: PUSH
10126: LD_INT 1
10128: PUSH
10129: LD_INT 2
10131: PUSH
10132: LD_INT 6
10134: PUSH
10135: LD_INT 15
10137: PUSH
10138: LD_INT 16
10140: PUSH
10141: LD_INT 7
10143: PUSH
10144: LD_INT 12
10146: PUSH
10147: LD_INT 13
10149: PUSH
10150: LD_INT 10
10152: PUSH
10153: LD_INT 14
10155: PUSH
10156: LD_INT 20
10158: PUSH
10159: LD_INT 21
10161: PUSH
10162: LD_INT 22
10164: PUSH
10165: LD_INT 25
10167: PUSH
10168: LD_INT 32
10170: PUSH
10171: LD_INT 27
10173: PUSH
10174: LD_INT 36
10176: PUSH
10177: LD_INT 69
10179: PUSH
10180: LD_INT 39
10182: PUSH
10183: LD_INT 34
10185: PUSH
10186: LD_INT 40
10188: PUSH
10189: LD_INT 48
10191: PUSH
10192: LD_INT 49
10194: PUSH
10195: LD_INT 50
10197: PUSH
10198: LD_INT 51
10200: PUSH
10201: LD_INT 52
10203: PUSH
10204: LD_INT 53
10206: PUSH
10207: LD_INT 54
10209: PUSH
10210: LD_INT 55
10212: PUSH
10213: LD_INT 56
10215: PUSH
10216: LD_INT 57
10218: PUSH
10219: LD_INT 58
10221: PUSH
10222: LD_INT 59
10224: PUSH
10225: LD_INT 60
10227: PUSH
10228: LD_INT 61
10230: PUSH
10231: LD_INT 62
10233: PUSH
10234: LD_INT 80
10236: PUSH
10237: LD_INT 82
10239: PUSH
10240: LD_INT 83
10242: PUSH
10243: LD_INT 84
10245: PUSH
10246: LD_INT 85
10248: PUSH
10249: LD_INT 86
10251: PUSH
10252: EMPTY
10253: LIST
10254: LIST
10255: LIST
10256: LIST
10257: LIST
10258: LIST
10259: LIST
10260: LIST
10261: LIST
10262: LIST
10263: LIST
10264: LIST
10265: LIST
10266: LIST
10267: LIST
10268: LIST
10269: LIST
10270: LIST
10271: LIST
10272: LIST
10273: LIST
10274: LIST
10275: LIST
10276: LIST
10277: LIST
10278: LIST
10279: LIST
10280: LIST
10281: LIST
10282: LIST
10283: LIST
10284: LIST
10285: LIST
10286: LIST
10287: LIST
10288: LIST
10289: LIST
10290: LIST
10291: LIST
10292: LIST
10293: LIST
10294: LIST
10295: LIST
10296: LIST
10297: LIST
10298: LIST
10299: LIST
10300: LIST
10301: LIST
10302: LIST
10303: LIST
10304: ST_TO_ADDR
10305: GO 10772
10307: LD_INT 2
10309: DOUBLE
10310: EQUAL
10311: IFTRUE 10315
10313: GO 10541
10315: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
10316: LD_ADDR_VAR 0 4
10320: PUSH
10321: LD_INT 35
10323: PUSH
10324: LD_INT 45
10326: PUSH
10327: LD_INT 46
10329: PUSH
10330: LD_INT 47
10332: PUSH
10333: LD_INT 82
10335: PUSH
10336: LD_INT 83
10338: PUSH
10339: LD_INT 84
10341: PUSH
10342: LD_INT 85
10344: PUSH
10345: LD_INT 87
10347: PUSH
10348: LD_INT 70
10350: PUSH
10351: LD_INT 1
10353: PUSH
10354: LD_INT 11
10356: PUSH
10357: LD_INT 3
10359: PUSH
10360: LD_INT 4
10362: PUSH
10363: LD_INT 5
10365: PUSH
10366: LD_INT 6
10368: PUSH
10369: LD_INT 15
10371: PUSH
10372: LD_INT 18
10374: PUSH
10375: LD_INT 7
10377: PUSH
10378: LD_INT 17
10380: PUSH
10381: LD_INT 8
10383: PUSH
10384: LD_INT 20
10386: PUSH
10387: LD_INT 21
10389: PUSH
10390: LD_INT 22
10392: PUSH
10393: LD_INT 72
10395: PUSH
10396: LD_INT 26
10398: PUSH
10399: LD_INT 69
10401: PUSH
10402: LD_INT 39
10404: PUSH
10405: LD_INT 40
10407: PUSH
10408: LD_INT 41
10410: PUSH
10411: LD_INT 42
10413: PUSH
10414: LD_INT 43
10416: PUSH
10417: LD_INT 48
10419: PUSH
10420: LD_INT 49
10422: PUSH
10423: LD_INT 50
10425: PUSH
10426: LD_INT 51
10428: PUSH
10429: LD_INT 52
10431: PUSH
10432: LD_INT 53
10434: PUSH
10435: LD_INT 54
10437: PUSH
10438: LD_INT 55
10440: PUSH
10441: LD_INT 56
10443: PUSH
10444: LD_INT 60
10446: PUSH
10447: LD_INT 61
10449: PUSH
10450: LD_INT 62
10452: PUSH
10453: LD_INT 66
10455: PUSH
10456: LD_INT 67
10458: PUSH
10459: LD_INT 68
10461: PUSH
10462: LD_INT 81
10464: PUSH
10465: LD_INT 82
10467: PUSH
10468: LD_INT 83
10470: PUSH
10471: LD_INT 84
10473: PUSH
10474: LD_INT 85
10476: PUSH
10477: LD_INT 87
10479: PUSH
10480: LD_INT 88
10482: PUSH
10483: EMPTY
10484: LIST
10485: LIST
10486: LIST
10487: LIST
10488: LIST
10489: LIST
10490: LIST
10491: LIST
10492: LIST
10493: LIST
10494: LIST
10495: LIST
10496: LIST
10497: LIST
10498: LIST
10499: LIST
10500: LIST
10501: LIST
10502: LIST
10503: LIST
10504: LIST
10505: LIST
10506: LIST
10507: LIST
10508: LIST
10509: LIST
10510: LIST
10511: LIST
10512: LIST
10513: LIST
10514: LIST
10515: LIST
10516: LIST
10517: LIST
10518: LIST
10519: LIST
10520: LIST
10521: LIST
10522: LIST
10523: LIST
10524: LIST
10525: LIST
10526: LIST
10527: LIST
10528: LIST
10529: LIST
10530: LIST
10531: LIST
10532: LIST
10533: LIST
10534: LIST
10535: LIST
10536: LIST
10537: LIST
10538: ST_TO_ADDR
10539: GO 10772
10541: LD_INT 3
10543: DOUBLE
10544: EQUAL
10545: IFTRUE 10549
10547: GO 10771
10549: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
10550: LD_ADDR_VAR 0 4
10554: PUSH
10555: LD_INT 46
10557: PUSH
10558: LD_INT 47
10560: PUSH
10561: LD_INT 1
10563: PUSH
10564: LD_INT 2
10566: PUSH
10567: LD_INT 82
10569: PUSH
10570: LD_INT 83
10572: PUSH
10573: LD_INT 84
10575: PUSH
10576: LD_INT 85
10578: PUSH
10579: LD_INT 86
10581: PUSH
10582: LD_INT 11
10584: PUSH
10585: LD_INT 9
10587: PUSH
10588: LD_INT 20
10590: PUSH
10591: LD_INT 19
10593: PUSH
10594: LD_INT 21
10596: PUSH
10597: LD_INT 24
10599: PUSH
10600: LD_INT 22
10602: PUSH
10603: LD_INT 25
10605: PUSH
10606: LD_INT 28
10608: PUSH
10609: LD_INT 29
10611: PUSH
10612: LD_INT 30
10614: PUSH
10615: LD_INT 31
10617: PUSH
10618: LD_INT 37
10620: PUSH
10621: LD_INT 38
10623: PUSH
10624: LD_INT 32
10626: PUSH
10627: LD_INT 27
10629: PUSH
10630: LD_INT 33
10632: PUSH
10633: LD_INT 69
10635: PUSH
10636: LD_INT 39
10638: PUSH
10639: LD_INT 34
10641: PUSH
10642: LD_INT 40
10644: PUSH
10645: LD_INT 71
10647: PUSH
10648: LD_INT 23
10650: PUSH
10651: LD_INT 44
10653: PUSH
10654: LD_INT 48
10656: PUSH
10657: LD_INT 49
10659: PUSH
10660: LD_INT 50
10662: PUSH
10663: LD_INT 51
10665: PUSH
10666: LD_INT 52
10668: PUSH
10669: LD_INT 53
10671: PUSH
10672: LD_INT 54
10674: PUSH
10675: LD_INT 55
10677: PUSH
10678: LD_INT 56
10680: PUSH
10681: LD_INT 57
10683: PUSH
10684: LD_INT 58
10686: PUSH
10687: LD_INT 59
10689: PUSH
10690: LD_INT 63
10692: PUSH
10693: LD_INT 64
10695: PUSH
10696: LD_INT 65
10698: PUSH
10699: LD_INT 82
10701: PUSH
10702: LD_INT 83
10704: PUSH
10705: LD_INT 84
10707: PUSH
10708: LD_INT 85
10710: PUSH
10711: LD_INT 86
10713: PUSH
10714: EMPTY
10715: LIST
10716: LIST
10717: LIST
10718: LIST
10719: LIST
10720: LIST
10721: LIST
10722: LIST
10723: LIST
10724: LIST
10725: LIST
10726: LIST
10727: LIST
10728: LIST
10729: LIST
10730: LIST
10731: LIST
10732: LIST
10733: LIST
10734: LIST
10735: LIST
10736: LIST
10737: LIST
10738: LIST
10739: LIST
10740: LIST
10741: LIST
10742: LIST
10743: LIST
10744: LIST
10745: LIST
10746: LIST
10747: LIST
10748: LIST
10749: LIST
10750: LIST
10751: LIST
10752: LIST
10753: LIST
10754: LIST
10755: LIST
10756: LIST
10757: LIST
10758: LIST
10759: LIST
10760: LIST
10761: LIST
10762: LIST
10763: LIST
10764: LIST
10765: LIST
10766: LIST
10767: LIST
10768: ST_TO_ADDR
10769: GO 10772
10771: POP
// if state > - 1 and state < 3 then
10772: LD_VAR 0 3
10776: PUSH
10777: LD_INT 1
10779: NEG
10780: GREATER
10781: PUSH
10782: LD_VAR 0 3
10786: PUSH
10787: LD_INT 3
10789: LESS
10790: AND
10791: IFFALSE 10848
// for i in result do
10793: LD_ADDR_VAR 0 5
10797: PUSH
10798: LD_VAR 0 4
10802: PUSH
10803: FOR_IN
10804: IFFALSE 10846
// if GetTech ( i , side ) <> state then
10806: LD_VAR 0 5
10810: PPUSH
10811: LD_VAR 0 1
10815: PPUSH
10816: CALL_OW 321
10820: PUSH
10821: LD_VAR 0 3
10825: NONEQUAL
10826: IFFALSE 10844
// result := result diff i ;
10828: LD_ADDR_VAR 0 4
10832: PUSH
10833: LD_VAR 0 4
10837: PUSH
10838: LD_VAR 0 5
10842: DIFF
10843: ST_TO_ADDR
10844: GO 10803
10846: POP
10847: POP
// end ;
10848: LD_VAR 0 4
10852: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
10853: LD_INT 0
10855: PPUSH
10856: PPUSH
10857: PPUSH
// result := true ;
10858: LD_ADDR_VAR 0 3
10862: PUSH
10863: LD_INT 1
10865: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
10866: LD_ADDR_VAR 0 5
10870: PUSH
10871: LD_VAR 0 2
10875: PPUSH
10876: CALL_OW 480
10880: ST_TO_ADDR
// if not tmp then
10881: LD_VAR 0 5
10885: NOT
10886: IFFALSE 10890
// exit ;
10888: GO 10939
// for i in tmp do
10890: LD_ADDR_VAR 0 4
10894: PUSH
10895: LD_VAR 0 5
10899: PUSH
10900: FOR_IN
10901: IFFALSE 10937
// if GetTech ( i , side ) <> state_researched then
10903: LD_VAR 0 4
10907: PPUSH
10908: LD_VAR 0 1
10912: PPUSH
10913: CALL_OW 321
10917: PUSH
10918: LD_INT 2
10920: NONEQUAL
10921: IFFALSE 10935
// begin result := false ;
10923: LD_ADDR_VAR 0 3
10927: PUSH
10928: LD_INT 0
10930: ST_TO_ADDR
// exit ;
10931: POP
10932: POP
10933: GO 10939
// end ;
10935: GO 10900
10937: POP
10938: POP
// end ;
10939: LD_VAR 0 3
10943: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
10944: LD_INT 0
10946: PPUSH
10947: PPUSH
10948: PPUSH
10949: PPUSH
10950: PPUSH
10951: PPUSH
10952: PPUSH
10953: PPUSH
10954: PPUSH
10955: PPUSH
10956: PPUSH
10957: PPUSH
10958: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
10959: LD_VAR 0 1
10963: NOT
10964: PUSH
10965: LD_VAR 0 1
10969: PPUSH
10970: CALL_OW 257
10974: PUSH
10975: LD_INT 9
10977: NONEQUAL
10978: OR
10979: IFFALSE 10983
// exit ;
10981: GO 11556
// side := GetSide ( unit ) ;
10983: LD_ADDR_VAR 0 9
10987: PUSH
10988: LD_VAR 0 1
10992: PPUSH
10993: CALL_OW 255
10997: ST_TO_ADDR
// tech_space := tech_spacanom ;
10998: LD_ADDR_VAR 0 12
11002: PUSH
11003: LD_INT 29
11005: ST_TO_ADDR
// tech_time := tech_taurad ;
11006: LD_ADDR_VAR 0 13
11010: PUSH
11011: LD_INT 28
11013: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
11014: LD_ADDR_VAR 0 11
11018: PUSH
11019: LD_VAR 0 1
11023: PPUSH
11024: CALL_OW 310
11028: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
11029: LD_VAR 0 11
11033: PPUSH
11034: CALL_OW 247
11038: PUSH
11039: LD_INT 2
11041: EQUAL
11042: IFFALSE 11046
// exit ;
11044: GO 11556
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
11046: LD_ADDR_VAR 0 8
11050: PUSH
11051: LD_INT 81
11053: PUSH
11054: LD_VAR 0 9
11058: PUSH
11059: EMPTY
11060: LIST
11061: LIST
11062: PUSH
11063: LD_INT 3
11065: PUSH
11066: LD_INT 21
11068: PUSH
11069: LD_INT 3
11071: PUSH
11072: EMPTY
11073: LIST
11074: LIST
11075: PUSH
11076: EMPTY
11077: LIST
11078: LIST
11079: PUSH
11080: EMPTY
11081: LIST
11082: LIST
11083: PPUSH
11084: CALL_OW 69
11088: ST_TO_ADDR
// if not tmp then
11089: LD_VAR 0 8
11093: NOT
11094: IFFALSE 11098
// exit ;
11096: GO 11556
// if in_unit then
11098: LD_VAR 0 11
11102: IFFALSE 11126
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
11104: LD_ADDR_VAR 0 10
11108: PUSH
11109: LD_VAR 0 8
11113: PPUSH
11114: LD_VAR 0 11
11118: PPUSH
11119: CALL_OW 74
11123: ST_TO_ADDR
11124: GO 11146
// enemy := NearestUnitToUnit ( tmp , unit ) ;
11126: LD_ADDR_VAR 0 10
11130: PUSH
11131: LD_VAR 0 8
11135: PPUSH
11136: LD_VAR 0 1
11140: PPUSH
11141: CALL_OW 74
11145: ST_TO_ADDR
// if not enemy then
11146: LD_VAR 0 10
11150: NOT
11151: IFFALSE 11155
// exit ;
11153: GO 11556
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
11155: LD_VAR 0 11
11159: PUSH
11160: LD_VAR 0 11
11164: PPUSH
11165: LD_VAR 0 10
11169: PPUSH
11170: CALL_OW 296
11174: PUSH
11175: LD_INT 13
11177: GREATER
11178: AND
11179: PUSH
11180: LD_VAR 0 1
11184: PPUSH
11185: LD_VAR 0 10
11189: PPUSH
11190: CALL_OW 296
11194: PUSH
11195: LD_INT 12
11197: GREATER
11198: OR
11199: IFFALSE 11203
// exit ;
11201: GO 11556
// missile := [ 1 ] ;
11203: LD_ADDR_VAR 0 14
11207: PUSH
11208: LD_INT 1
11210: PUSH
11211: EMPTY
11212: LIST
11213: ST_TO_ADDR
// if Researched ( side , tech_space ) then
11214: LD_VAR 0 9
11218: PPUSH
11219: LD_VAR 0 12
11223: PPUSH
11224: CALL_OW 325
11228: IFFALSE 11257
// missile := Insert ( missile , missile + 1 , 2 ) ;
11230: LD_ADDR_VAR 0 14
11234: PUSH
11235: LD_VAR 0 14
11239: PPUSH
11240: LD_VAR 0 14
11244: PUSH
11245: LD_INT 1
11247: PLUS
11248: PPUSH
11249: LD_INT 2
11251: PPUSH
11252: CALL_OW 2
11256: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
11257: LD_VAR 0 9
11261: PPUSH
11262: LD_VAR 0 13
11266: PPUSH
11267: CALL_OW 325
11271: PUSH
11272: LD_VAR 0 10
11276: PPUSH
11277: CALL_OW 255
11281: PPUSH
11282: LD_VAR 0 13
11286: PPUSH
11287: CALL_OW 325
11291: NOT
11292: AND
11293: IFFALSE 11322
// missile := Insert ( missile , missile + 1 , 3 ) ;
11295: LD_ADDR_VAR 0 14
11299: PUSH
11300: LD_VAR 0 14
11304: PPUSH
11305: LD_VAR 0 14
11309: PUSH
11310: LD_INT 1
11312: PLUS
11313: PPUSH
11314: LD_INT 3
11316: PPUSH
11317: CALL_OW 2
11321: ST_TO_ADDR
// if missile < 2 then
11322: LD_VAR 0 14
11326: PUSH
11327: LD_INT 2
11329: LESS
11330: IFFALSE 11334
// exit ;
11332: GO 11556
// x := GetX ( enemy ) ;
11334: LD_ADDR_VAR 0 4
11338: PUSH
11339: LD_VAR 0 10
11343: PPUSH
11344: CALL_OW 250
11348: ST_TO_ADDR
// y := GetY ( enemy ) ;
11349: LD_ADDR_VAR 0 5
11353: PUSH
11354: LD_VAR 0 10
11358: PPUSH
11359: CALL_OW 251
11363: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
11364: LD_ADDR_VAR 0 6
11368: PUSH
11369: LD_VAR 0 4
11373: PUSH
11374: LD_INT 1
11376: NEG
11377: PPUSH
11378: LD_INT 1
11380: PPUSH
11381: CALL_OW 12
11385: PLUS
11386: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
11387: LD_ADDR_VAR 0 7
11391: PUSH
11392: LD_VAR 0 5
11396: PUSH
11397: LD_INT 1
11399: NEG
11400: PPUSH
11401: LD_INT 1
11403: PPUSH
11404: CALL_OW 12
11408: PLUS
11409: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
11410: LD_VAR 0 6
11414: PPUSH
11415: LD_VAR 0 7
11419: PPUSH
11420: CALL_OW 488
11424: NOT
11425: IFFALSE 11447
// begin _x := x ;
11427: LD_ADDR_VAR 0 6
11431: PUSH
11432: LD_VAR 0 4
11436: ST_TO_ADDR
// _y := y ;
11437: LD_ADDR_VAR 0 7
11441: PUSH
11442: LD_VAR 0 5
11446: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
11447: LD_ADDR_VAR 0 3
11451: PUSH
11452: LD_INT 1
11454: PPUSH
11455: LD_VAR 0 14
11459: PPUSH
11460: CALL_OW 12
11464: ST_TO_ADDR
// case i of 1 :
11465: LD_VAR 0 3
11469: PUSH
11470: LD_INT 1
11472: DOUBLE
11473: EQUAL
11474: IFTRUE 11478
11476: GO 11495
11478: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
11479: LD_VAR 0 1
11483: PPUSH
11484: LD_VAR 0 10
11488: PPUSH
11489: CALL_OW 115
11493: GO 11556
11495: LD_INT 2
11497: DOUBLE
11498: EQUAL
11499: IFTRUE 11503
11501: GO 11525
11503: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
11504: LD_VAR 0 1
11508: PPUSH
11509: LD_VAR 0 6
11513: PPUSH
11514: LD_VAR 0 7
11518: PPUSH
11519: CALL_OW 153
11523: GO 11556
11525: LD_INT 3
11527: DOUBLE
11528: EQUAL
11529: IFTRUE 11533
11531: GO 11555
11533: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
11534: LD_VAR 0 1
11538: PPUSH
11539: LD_VAR 0 6
11543: PPUSH
11544: LD_VAR 0 7
11548: PPUSH
11549: CALL_OW 154
11553: GO 11556
11555: POP
// end ;
11556: LD_VAR 0 2
11560: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
11561: LD_INT 0
11563: PPUSH
11564: PPUSH
11565: PPUSH
11566: PPUSH
11567: PPUSH
11568: PPUSH
// if not unit or not building then
11569: LD_VAR 0 1
11573: NOT
11574: PUSH
11575: LD_VAR 0 2
11579: NOT
11580: OR
11581: IFFALSE 11585
// exit ;
11583: GO 11743
// x := GetX ( building ) ;
11585: LD_ADDR_VAR 0 5
11589: PUSH
11590: LD_VAR 0 2
11594: PPUSH
11595: CALL_OW 250
11599: ST_TO_ADDR
// y := GetY ( building ) ;
11600: LD_ADDR_VAR 0 6
11604: PUSH
11605: LD_VAR 0 2
11609: PPUSH
11610: CALL_OW 251
11614: ST_TO_ADDR
// for i = 0 to 5 do
11615: LD_ADDR_VAR 0 4
11619: PUSH
11620: DOUBLE
11621: LD_INT 0
11623: DEC
11624: ST_TO_ADDR
11625: LD_INT 5
11627: PUSH
11628: FOR_TO
11629: IFFALSE 11741
// begin _x := ShiftX ( x , i , 3 ) ;
11631: LD_ADDR_VAR 0 7
11635: PUSH
11636: LD_VAR 0 5
11640: PPUSH
11641: LD_VAR 0 4
11645: PPUSH
11646: LD_INT 3
11648: PPUSH
11649: CALL_OW 272
11653: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
11654: LD_ADDR_VAR 0 8
11658: PUSH
11659: LD_VAR 0 6
11663: PPUSH
11664: LD_VAR 0 4
11668: PPUSH
11669: LD_INT 3
11671: PPUSH
11672: CALL_OW 273
11676: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
11677: LD_VAR 0 7
11681: PPUSH
11682: LD_VAR 0 8
11686: PPUSH
11687: CALL_OW 488
11691: NOT
11692: IFFALSE 11696
// continue ;
11694: GO 11628
// if HexInfo ( _x , _y ) = 0 then
11696: LD_VAR 0 7
11700: PPUSH
11701: LD_VAR 0 8
11705: PPUSH
11706: CALL_OW 428
11710: PUSH
11711: LD_INT 0
11713: EQUAL
11714: IFFALSE 11739
// begin ComMoveXY ( unit , _x , _y ) ;
11716: LD_VAR 0 1
11720: PPUSH
11721: LD_VAR 0 7
11725: PPUSH
11726: LD_VAR 0 8
11730: PPUSH
11731: CALL_OW 111
// exit ;
11735: POP
11736: POP
11737: GO 11743
// end ; end ;
11739: GO 11628
11741: POP
11742: POP
// end ;
11743: LD_VAR 0 3
11747: RET
// export function ScanBase ( side , base_area ) ; begin
11748: LD_INT 0
11750: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
11751: LD_ADDR_VAR 0 3
11755: PUSH
11756: LD_VAR 0 2
11760: PPUSH
11761: LD_INT 81
11763: PUSH
11764: LD_VAR 0 1
11768: PUSH
11769: EMPTY
11770: LIST
11771: LIST
11772: PPUSH
11773: CALL_OW 70
11777: ST_TO_ADDR
// end ;
11778: LD_VAR 0 3
11782: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
11783: LD_INT 0
11785: PPUSH
11786: PPUSH
11787: PPUSH
11788: PPUSH
// result := false ;
11789: LD_ADDR_VAR 0 2
11793: PUSH
11794: LD_INT 0
11796: ST_TO_ADDR
// side := GetSide ( unit ) ;
11797: LD_ADDR_VAR 0 3
11801: PUSH
11802: LD_VAR 0 1
11806: PPUSH
11807: CALL_OW 255
11811: ST_TO_ADDR
// nat := GetNation ( unit ) ;
11812: LD_ADDR_VAR 0 4
11816: PUSH
11817: LD_VAR 0 1
11821: PPUSH
11822: CALL_OW 248
11826: ST_TO_ADDR
// case nat of 1 :
11827: LD_VAR 0 4
11831: PUSH
11832: LD_INT 1
11834: DOUBLE
11835: EQUAL
11836: IFTRUE 11840
11838: GO 11851
11840: POP
// tech := tech_lassight ; 2 :
11841: LD_ADDR_VAR 0 5
11845: PUSH
11846: LD_INT 12
11848: ST_TO_ADDR
11849: GO 11890
11851: LD_INT 2
11853: DOUBLE
11854: EQUAL
11855: IFTRUE 11859
11857: GO 11870
11859: POP
// tech := tech_mortar ; 3 :
11860: LD_ADDR_VAR 0 5
11864: PUSH
11865: LD_INT 41
11867: ST_TO_ADDR
11868: GO 11890
11870: LD_INT 3
11872: DOUBLE
11873: EQUAL
11874: IFTRUE 11878
11876: GO 11889
11878: POP
// tech := tech_bazooka ; end ;
11879: LD_ADDR_VAR 0 5
11883: PUSH
11884: LD_INT 44
11886: ST_TO_ADDR
11887: GO 11890
11889: POP
// if Researched ( side , tech ) then
11890: LD_VAR 0 3
11894: PPUSH
11895: LD_VAR 0 5
11899: PPUSH
11900: CALL_OW 325
11904: IFFALSE 11931
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
11906: LD_ADDR_VAR 0 2
11910: PUSH
11911: LD_INT 5
11913: PUSH
11914: LD_INT 8
11916: PUSH
11917: LD_INT 9
11919: PUSH
11920: EMPTY
11921: LIST
11922: LIST
11923: LIST
11924: PUSH
11925: LD_VAR 0 4
11929: ARRAY
11930: ST_TO_ADDR
// end ;
11931: LD_VAR 0 2
11935: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
11936: LD_INT 0
11938: PPUSH
11939: PPUSH
11940: PPUSH
// if not mines then
11941: LD_VAR 0 2
11945: NOT
11946: IFFALSE 11950
// exit ;
11948: GO 12094
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
11950: LD_ADDR_VAR 0 5
11954: PUSH
11955: LD_INT 81
11957: PUSH
11958: LD_VAR 0 1
11962: PUSH
11963: EMPTY
11964: LIST
11965: LIST
11966: PUSH
11967: LD_INT 3
11969: PUSH
11970: LD_INT 21
11972: PUSH
11973: LD_INT 3
11975: PUSH
11976: EMPTY
11977: LIST
11978: LIST
11979: PUSH
11980: EMPTY
11981: LIST
11982: LIST
11983: PUSH
11984: EMPTY
11985: LIST
11986: LIST
11987: PPUSH
11988: CALL_OW 69
11992: ST_TO_ADDR
// for i in mines do
11993: LD_ADDR_VAR 0 4
11997: PUSH
11998: LD_VAR 0 2
12002: PUSH
12003: FOR_IN
12004: IFFALSE 12092
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
12006: LD_VAR 0 4
12010: PUSH
12011: LD_INT 1
12013: ARRAY
12014: PPUSH
12015: LD_VAR 0 4
12019: PUSH
12020: LD_INT 2
12022: ARRAY
12023: PPUSH
12024: CALL_OW 458
12028: NOT
12029: IFFALSE 12033
// continue ;
12031: GO 12003
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
12033: LD_VAR 0 4
12037: PUSH
12038: LD_INT 1
12040: ARRAY
12041: PPUSH
12042: LD_VAR 0 4
12046: PUSH
12047: LD_INT 2
12049: ARRAY
12050: PPUSH
12051: CALL_OW 428
12055: PUSH
12056: LD_VAR 0 5
12060: IN
12061: IFFALSE 12090
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
12063: LD_VAR 0 4
12067: PUSH
12068: LD_INT 1
12070: ARRAY
12071: PPUSH
12072: LD_VAR 0 4
12076: PUSH
12077: LD_INT 2
12079: ARRAY
12080: PPUSH
12081: LD_VAR 0 1
12085: PPUSH
12086: CALL_OW 456
// end ;
12090: GO 12003
12092: POP
12093: POP
// end ;
12094: LD_VAR 0 3
12098: RET
// export function Count ( array ) ; var i ; begin
12099: LD_INT 0
12101: PPUSH
12102: PPUSH
// result := 0 ;
12103: LD_ADDR_VAR 0 2
12107: PUSH
12108: LD_INT 0
12110: ST_TO_ADDR
// for i in array do
12111: LD_ADDR_VAR 0 3
12115: PUSH
12116: LD_VAR 0 1
12120: PUSH
12121: FOR_IN
12122: IFFALSE 12146
// if i then
12124: LD_VAR 0 3
12128: IFFALSE 12144
// result := result + 1 ;
12130: LD_ADDR_VAR 0 2
12134: PUSH
12135: LD_VAR 0 2
12139: PUSH
12140: LD_INT 1
12142: PLUS
12143: ST_TO_ADDR
12144: GO 12121
12146: POP
12147: POP
// end ;
12148: LD_VAR 0 2
12152: RET
// export function IsEmpty ( building ) ; begin
12153: LD_INT 0
12155: PPUSH
// if not building then
12156: LD_VAR 0 1
12160: NOT
12161: IFFALSE 12165
// exit ;
12163: GO 12208
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
12165: LD_ADDR_VAR 0 2
12169: PUSH
12170: LD_VAR 0 1
12174: PUSH
12175: LD_INT 22
12177: PUSH
12178: LD_VAR 0 1
12182: PPUSH
12183: CALL_OW 255
12187: PUSH
12188: EMPTY
12189: LIST
12190: LIST
12191: PUSH
12192: LD_INT 58
12194: PUSH
12195: EMPTY
12196: LIST
12197: PUSH
12198: EMPTY
12199: LIST
12200: LIST
12201: PPUSH
12202: CALL_OW 69
12206: IN
12207: ST_TO_ADDR
// end ;
12208: LD_VAR 0 2
12212: RET
// export function IsNotFull ( building ) ; begin
12213: LD_INT 0
12215: PPUSH
// if not building then
12216: LD_VAR 0 1
12220: NOT
12221: IFFALSE 12225
// exit ;
12223: GO 12244
// result := UnitsInside ( building ) < 6 ;
12225: LD_ADDR_VAR 0 2
12229: PUSH
12230: LD_VAR 0 1
12234: PPUSH
12235: CALL_OW 313
12239: PUSH
12240: LD_INT 6
12242: LESS
12243: ST_TO_ADDR
// end ;
12244: LD_VAR 0 2
12248: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
12249: LD_INT 0
12251: PPUSH
12252: PPUSH
12253: PPUSH
12254: PPUSH
// tmp := [ ] ;
12255: LD_ADDR_VAR 0 3
12259: PUSH
12260: EMPTY
12261: ST_TO_ADDR
// list := [ ] ;
12262: LD_ADDR_VAR 0 5
12266: PUSH
12267: EMPTY
12268: ST_TO_ADDR
// for i = 16 to 25 do
12269: LD_ADDR_VAR 0 4
12273: PUSH
12274: DOUBLE
12275: LD_INT 16
12277: DEC
12278: ST_TO_ADDR
12279: LD_INT 25
12281: PUSH
12282: FOR_TO
12283: IFFALSE 12356
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
12285: LD_ADDR_VAR 0 3
12289: PUSH
12290: LD_VAR 0 3
12294: PUSH
12295: LD_INT 22
12297: PUSH
12298: LD_VAR 0 1
12302: PPUSH
12303: CALL_OW 255
12307: PUSH
12308: EMPTY
12309: LIST
12310: LIST
12311: PUSH
12312: LD_INT 91
12314: PUSH
12315: LD_VAR 0 1
12319: PUSH
12320: LD_INT 6
12322: PUSH
12323: EMPTY
12324: LIST
12325: LIST
12326: LIST
12327: PUSH
12328: LD_INT 30
12330: PUSH
12331: LD_VAR 0 4
12335: PUSH
12336: EMPTY
12337: LIST
12338: LIST
12339: PUSH
12340: EMPTY
12341: LIST
12342: LIST
12343: LIST
12344: PUSH
12345: EMPTY
12346: LIST
12347: PPUSH
12348: CALL_OW 69
12352: ADD
12353: ST_TO_ADDR
12354: GO 12282
12356: POP
12357: POP
// for i = 1 to tmp do
12358: LD_ADDR_VAR 0 4
12362: PUSH
12363: DOUBLE
12364: LD_INT 1
12366: DEC
12367: ST_TO_ADDR
12368: LD_VAR 0 3
12372: PUSH
12373: FOR_TO
12374: IFFALSE 12462
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
12376: LD_ADDR_VAR 0 5
12380: PUSH
12381: LD_VAR 0 5
12385: PUSH
12386: LD_VAR 0 3
12390: PUSH
12391: LD_VAR 0 4
12395: ARRAY
12396: PPUSH
12397: CALL_OW 266
12401: PUSH
12402: LD_VAR 0 3
12406: PUSH
12407: LD_VAR 0 4
12411: ARRAY
12412: PPUSH
12413: CALL_OW 250
12417: PUSH
12418: LD_VAR 0 3
12422: PUSH
12423: LD_VAR 0 4
12427: ARRAY
12428: PPUSH
12429: CALL_OW 251
12433: PUSH
12434: LD_VAR 0 3
12438: PUSH
12439: LD_VAR 0 4
12443: ARRAY
12444: PPUSH
12445: CALL_OW 254
12449: PUSH
12450: EMPTY
12451: LIST
12452: LIST
12453: LIST
12454: LIST
12455: PUSH
12456: EMPTY
12457: LIST
12458: ADD
12459: ST_TO_ADDR
12460: GO 12373
12462: POP
12463: POP
// result := list ;
12464: LD_ADDR_VAR 0 2
12468: PUSH
12469: LD_VAR 0 5
12473: ST_TO_ADDR
// end ;
12474: LD_VAR 0 2
12478: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
12479: LD_INT 0
12481: PPUSH
12482: PPUSH
12483: PPUSH
12484: PPUSH
12485: PPUSH
12486: PPUSH
12487: PPUSH
// if not factory then
12488: LD_VAR 0 1
12492: NOT
12493: IFFALSE 12497
// exit ;
12495: GO 13090
// if control = control_apeman then
12497: LD_VAR 0 4
12501: PUSH
12502: LD_INT 5
12504: EQUAL
12505: IFFALSE 12614
// begin tmp := UnitsInside ( factory ) ;
12507: LD_ADDR_VAR 0 8
12511: PUSH
12512: LD_VAR 0 1
12516: PPUSH
12517: CALL_OW 313
12521: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
12522: LD_VAR 0 8
12526: PPUSH
12527: LD_INT 25
12529: PUSH
12530: LD_INT 12
12532: PUSH
12533: EMPTY
12534: LIST
12535: LIST
12536: PPUSH
12537: CALL_OW 72
12541: NOT
12542: IFFALSE 12552
// control := control_manual ;
12544: LD_ADDR_VAR 0 4
12548: PUSH
12549: LD_INT 1
12551: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
12552: LD_ADDR_VAR 0 8
12556: PUSH
12557: LD_VAR 0 1
12561: PPUSH
12562: CALL 12249 0 1
12566: ST_TO_ADDR
// if tmp then
12567: LD_VAR 0 8
12571: IFFALSE 12614
// begin for i in tmp do
12573: LD_ADDR_VAR 0 7
12577: PUSH
12578: LD_VAR 0 8
12582: PUSH
12583: FOR_IN
12584: IFFALSE 12612
// if i [ 1 ] = b_ext_radio then
12586: LD_VAR 0 7
12590: PUSH
12591: LD_INT 1
12593: ARRAY
12594: PUSH
12595: LD_INT 22
12597: EQUAL
12598: IFFALSE 12610
// begin control := control_remote ;
12600: LD_ADDR_VAR 0 4
12604: PUSH
12605: LD_INT 2
12607: ST_TO_ADDR
// break ;
12608: GO 12612
// end ;
12610: GO 12583
12612: POP
12613: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
12614: LD_VAR 0 1
12618: PPUSH
12619: LD_VAR 0 2
12623: PPUSH
12624: LD_VAR 0 3
12628: PPUSH
12629: LD_VAR 0 4
12633: PPUSH
12634: LD_VAR 0 5
12638: PPUSH
12639: CALL_OW 448
12643: IFFALSE 12678
// begin result := [ chassis , engine , control , weapon ] ;
12645: LD_ADDR_VAR 0 6
12649: PUSH
12650: LD_VAR 0 2
12654: PUSH
12655: LD_VAR 0 3
12659: PUSH
12660: LD_VAR 0 4
12664: PUSH
12665: LD_VAR 0 5
12669: PUSH
12670: EMPTY
12671: LIST
12672: LIST
12673: LIST
12674: LIST
12675: ST_TO_ADDR
// exit ;
12676: GO 13090
// end ; _chassis := AvailableChassisList ( factory ) ;
12678: LD_ADDR_VAR 0 9
12682: PUSH
12683: LD_VAR 0 1
12687: PPUSH
12688: CALL_OW 475
12692: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
12693: LD_ADDR_VAR 0 11
12697: PUSH
12698: LD_VAR 0 1
12702: PPUSH
12703: CALL_OW 476
12707: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
12708: LD_ADDR_VAR 0 12
12712: PUSH
12713: LD_VAR 0 1
12717: PPUSH
12718: CALL_OW 477
12722: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
12723: LD_ADDR_VAR 0 10
12727: PUSH
12728: LD_VAR 0 1
12732: PPUSH
12733: CALL_OW 478
12737: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
12738: LD_VAR 0 9
12742: NOT
12743: PUSH
12744: LD_VAR 0 11
12748: NOT
12749: OR
12750: PUSH
12751: LD_VAR 0 12
12755: NOT
12756: OR
12757: PUSH
12758: LD_VAR 0 10
12762: NOT
12763: OR
12764: IFFALSE 12799
// begin result := [ chassis , engine , control , weapon ] ;
12766: LD_ADDR_VAR 0 6
12770: PUSH
12771: LD_VAR 0 2
12775: PUSH
12776: LD_VAR 0 3
12780: PUSH
12781: LD_VAR 0 4
12785: PUSH
12786: LD_VAR 0 5
12790: PUSH
12791: EMPTY
12792: LIST
12793: LIST
12794: LIST
12795: LIST
12796: ST_TO_ADDR
// exit ;
12797: GO 13090
// end ; if not chassis in _chassis then
12799: LD_VAR 0 2
12803: PUSH
12804: LD_VAR 0 9
12808: IN
12809: NOT
12810: IFFALSE 12836
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
12812: LD_ADDR_VAR 0 2
12816: PUSH
12817: LD_VAR 0 9
12821: PUSH
12822: LD_INT 1
12824: PPUSH
12825: LD_VAR 0 9
12829: PPUSH
12830: CALL_OW 12
12834: ARRAY
12835: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
12836: LD_VAR 0 2
12840: PPUSH
12841: LD_VAR 0 3
12845: PPUSH
12846: CALL 13095 0 2
12850: NOT
12851: IFFALSE 12910
// repeat engine := _engine [ 1 ] ;
12853: LD_ADDR_VAR 0 3
12857: PUSH
12858: LD_VAR 0 11
12862: PUSH
12863: LD_INT 1
12865: ARRAY
12866: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
12867: LD_ADDR_VAR 0 11
12871: PUSH
12872: LD_VAR 0 11
12876: PPUSH
12877: LD_INT 1
12879: PPUSH
12880: CALL_OW 3
12884: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
12885: LD_VAR 0 2
12889: PPUSH
12890: LD_VAR 0 3
12894: PPUSH
12895: CALL 13095 0 2
12899: PUSH
12900: LD_VAR 0 11
12904: PUSH
12905: EMPTY
12906: EQUAL
12907: OR
12908: IFFALSE 12853
// if not control in _control then
12910: LD_VAR 0 4
12914: PUSH
12915: LD_VAR 0 12
12919: IN
12920: NOT
12921: IFFALSE 12947
// control := _control [ rand ( 1 , _control ) ] ;
12923: LD_ADDR_VAR 0 4
12927: PUSH
12928: LD_VAR 0 12
12932: PUSH
12933: LD_INT 1
12935: PPUSH
12936: LD_VAR 0 12
12940: PPUSH
12941: CALL_OW 12
12945: ARRAY
12946: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
12947: LD_VAR 0 2
12951: PPUSH
12952: LD_VAR 0 5
12956: PPUSH
12957: CALL 13315 0 2
12961: NOT
12962: IFFALSE 13021
// repeat weapon := _weapon [ 1 ] ;
12964: LD_ADDR_VAR 0 5
12968: PUSH
12969: LD_VAR 0 10
12973: PUSH
12974: LD_INT 1
12976: ARRAY
12977: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
12978: LD_ADDR_VAR 0 10
12982: PUSH
12983: LD_VAR 0 10
12987: PPUSH
12988: LD_INT 1
12990: PPUSH
12991: CALL_OW 3
12995: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
12996: LD_VAR 0 2
13000: PPUSH
13001: LD_VAR 0 5
13005: PPUSH
13006: CALL 13315 0 2
13010: PUSH
13011: LD_VAR 0 10
13015: PUSH
13016: EMPTY
13017: EQUAL
13018: OR
13019: IFFALSE 12964
// result := [ ] ;
13021: LD_ADDR_VAR 0 6
13025: PUSH
13026: EMPTY
13027: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
13028: LD_VAR 0 1
13032: PPUSH
13033: LD_VAR 0 2
13037: PPUSH
13038: LD_VAR 0 3
13042: PPUSH
13043: LD_VAR 0 4
13047: PPUSH
13048: LD_VAR 0 5
13052: PPUSH
13053: CALL_OW 448
13057: IFFALSE 13090
// result := [ chassis , engine , control , weapon ] ;
13059: LD_ADDR_VAR 0 6
13063: PUSH
13064: LD_VAR 0 2
13068: PUSH
13069: LD_VAR 0 3
13073: PUSH
13074: LD_VAR 0 4
13078: PUSH
13079: LD_VAR 0 5
13083: PUSH
13084: EMPTY
13085: LIST
13086: LIST
13087: LIST
13088: LIST
13089: ST_TO_ADDR
// end ;
13090: LD_VAR 0 6
13094: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
13095: LD_INT 0
13097: PPUSH
// if not chassis or not engine then
13098: LD_VAR 0 1
13102: NOT
13103: PUSH
13104: LD_VAR 0 2
13108: NOT
13109: OR
13110: IFFALSE 13114
// exit ;
13112: GO 13310
// case engine of engine_solar :
13114: LD_VAR 0 2
13118: PUSH
13119: LD_INT 2
13121: DOUBLE
13122: EQUAL
13123: IFTRUE 13127
13125: GO 13165
13127: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
13128: LD_ADDR_VAR 0 3
13132: PUSH
13133: LD_INT 11
13135: PUSH
13136: LD_INT 12
13138: PUSH
13139: LD_INT 13
13141: PUSH
13142: LD_INT 14
13144: PUSH
13145: LD_INT 1
13147: PUSH
13148: LD_INT 2
13150: PUSH
13151: LD_INT 3
13153: PUSH
13154: EMPTY
13155: LIST
13156: LIST
13157: LIST
13158: LIST
13159: LIST
13160: LIST
13161: LIST
13162: ST_TO_ADDR
13163: GO 13294
13165: LD_INT 1
13167: DOUBLE
13168: EQUAL
13169: IFTRUE 13173
13171: GO 13235
13173: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
13174: LD_ADDR_VAR 0 3
13178: PUSH
13179: LD_INT 11
13181: PUSH
13182: LD_INT 12
13184: PUSH
13185: LD_INT 13
13187: PUSH
13188: LD_INT 14
13190: PUSH
13191: LD_INT 1
13193: PUSH
13194: LD_INT 2
13196: PUSH
13197: LD_INT 3
13199: PUSH
13200: LD_INT 4
13202: PUSH
13203: LD_INT 5
13205: PUSH
13206: LD_INT 21
13208: PUSH
13209: LD_INT 23
13211: PUSH
13212: LD_INT 22
13214: PUSH
13215: LD_INT 24
13217: PUSH
13218: EMPTY
13219: LIST
13220: LIST
13221: LIST
13222: LIST
13223: LIST
13224: LIST
13225: LIST
13226: LIST
13227: LIST
13228: LIST
13229: LIST
13230: LIST
13231: LIST
13232: ST_TO_ADDR
13233: GO 13294
13235: LD_INT 3
13237: DOUBLE
13238: EQUAL
13239: IFTRUE 13243
13241: GO 13293
13243: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
13244: LD_ADDR_VAR 0 3
13248: PUSH
13249: LD_INT 13
13251: PUSH
13252: LD_INT 14
13254: PUSH
13255: LD_INT 2
13257: PUSH
13258: LD_INT 3
13260: PUSH
13261: LD_INT 4
13263: PUSH
13264: LD_INT 5
13266: PUSH
13267: LD_INT 21
13269: PUSH
13270: LD_INT 22
13272: PUSH
13273: LD_INT 23
13275: PUSH
13276: LD_INT 24
13278: PUSH
13279: EMPTY
13280: LIST
13281: LIST
13282: LIST
13283: LIST
13284: LIST
13285: LIST
13286: LIST
13287: LIST
13288: LIST
13289: LIST
13290: ST_TO_ADDR
13291: GO 13294
13293: POP
// result := ( chassis in result ) ;
13294: LD_ADDR_VAR 0 3
13298: PUSH
13299: LD_VAR 0 1
13303: PUSH
13304: LD_VAR 0 3
13308: IN
13309: ST_TO_ADDR
// end ;
13310: LD_VAR 0 3
13314: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
13315: LD_INT 0
13317: PPUSH
// if not chassis or not weapon then
13318: LD_VAR 0 1
13322: NOT
13323: PUSH
13324: LD_VAR 0 2
13328: NOT
13329: OR
13330: IFFALSE 13334
// exit ;
13332: GO 14396
// case weapon of us_machine_gun :
13334: LD_VAR 0 2
13338: PUSH
13339: LD_INT 2
13341: DOUBLE
13342: EQUAL
13343: IFTRUE 13347
13345: GO 13377
13347: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
13348: LD_ADDR_VAR 0 3
13352: PUSH
13353: LD_INT 1
13355: PUSH
13356: LD_INT 2
13358: PUSH
13359: LD_INT 3
13361: PUSH
13362: LD_INT 4
13364: PUSH
13365: LD_INT 5
13367: PUSH
13368: EMPTY
13369: LIST
13370: LIST
13371: LIST
13372: LIST
13373: LIST
13374: ST_TO_ADDR
13375: GO 14380
13377: LD_INT 3
13379: DOUBLE
13380: EQUAL
13381: IFTRUE 13385
13383: GO 13415
13385: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
13386: LD_ADDR_VAR 0 3
13390: PUSH
13391: LD_INT 1
13393: PUSH
13394: LD_INT 2
13396: PUSH
13397: LD_INT 3
13399: PUSH
13400: LD_INT 4
13402: PUSH
13403: LD_INT 5
13405: PUSH
13406: EMPTY
13407: LIST
13408: LIST
13409: LIST
13410: LIST
13411: LIST
13412: ST_TO_ADDR
13413: GO 14380
13415: LD_INT 11
13417: DOUBLE
13418: EQUAL
13419: IFTRUE 13423
13421: GO 13453
13423: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
13424: LD_ADDR_VAR 0 3
13428: PUSH
13429: LD_INT 1
13431: PUSH
13432: LD_INT 2
13434: PUSH
13435: LD_INT 3
13437: PUSH
13438: LD_INT 4
13440: PUSH
13441: LD_INT 5
13443: PUSH
13444: EMPTY
13445: LIST
13446: LIST
13447: LIST
13448: LIST
13449: LIST
13450: ST_TO_ADDR
13451: GO 14380
13453: LD_INT 4
13455: DOUBLE
13456: EQUAL
13457: IFTRUE 13461
13459: GO 13487
13461: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
13462: LD_ADDR_VAR 0 3
13466: PUSH
13467: LD_INT 2
13469: PUSH
13470: LD_INT 3
13472: PUSH
13473: LD_INT 4
13475: PUSH
13476: LD_INT 5
13478: PUSH
13479: EMPTY
13480: LIST
13481: LIST
13482: LIST
13483: LIST
13484: ST_TO_ADDR
13485: GO 14380
13487: LD_INT 5
13489: DOUBLE
13490: EQUAL
13491: IFTRUE 13495
13493: GO 13521
13495: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
13496: LD_ADDR_VAR 0 3
13500: PUSH
13501: LD_INT 2
13503: PUSH
13504: LD_INT 3
13506: PUSH
13507: LD_INT 4
13509: PUSH
13510: LD_INT 5
13512: PUSH
13513: EMPTY
13514: LIST
13515: LIST
13516: LIST
13517: LIST
13518: ST_TO_ADDR
13519: GO 14380
13521: LD_INT 9
13523: DOUBLE
13524: EQUAL
13525: IFTRUE 13529
13527: GO 13555
13529: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
13530: LD_ADDR_VAR 0 3
13534: PUSH
13535: LD_INT 2
13537: PUSH
13538: LD_INT 3
13540: PUSH
13541: LD_INT 4
13543: PUSH
13544: LD_INT 5
13546: PUSH
13547: EMPTY
13548: LIST
13549: LIST
13550: LIST
13551: LIST
13552: ST_TO_ADDR
13553: GO 14380
13555: LD_INT 7
13557: DOUBLE
13558: EQUAL
13559: IFTRUE 13563
13561: GO 13589
13563: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
13564: LD_ADDR_VAR 0 3
13568: PUSH
13569: LD_INT 2
13571: PUSH
13572: LD_INT 3
13574: PUSH
13575: LD_INT 4
13577: PUSH
13578: LD_INT 5
13580: PUSH
13581: EMPTY
13582: LIST
13583: LIST
13584: LIST
13585: LIST
13586: ST_TO_ADDR
13587: GO 14380
13589: LD_INT 12
13591: DOUBLE
13592: EQUAL
13593: IFTRUE 13597
13595: GO 13623
13597: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
13598: LD_ADDR_VAR 0 3
13602: PUSH
13603: LD_INT 2
13605: PUSH
13606: LD_INT 3
13608: PUSH
13609: LD_INT 4
13611: PUSH
13612: LD_INT 5
13614: PUSH
13615: EMPTY
13616: LIST
13617: LIST
13618: LIST
13619: LIST
13620: ST_TO_ADDR
13621: GO 14380
13623: LD_INT 13
13625: DOUBLE
13626: EQUAL
13627: IFTRUE 13631
13629: GO 13657
13631: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
13632: LD_ADDR_VAR 0 3
13636: PUSH
13637: LD_INT 2
13639: PUSH
13640: LD_INT 3
13642: PUSH
13643: LD_INT 4
13645: PUSH
13646: LD_INT 5
13648: PUSH
13649: EMPTY
13650: LIST
13651: LIST
13652: LIST
13653: LIST
13654: ST_TO_ADDR
13655: GO 14380
13657: LD_INT 14
13659: DOUBLE
13660: EQUAL
13661: IFTRUE 13665
13663: GO 13683
13665: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
13666: LD_ADDR_VAR 0 3
13670: PUSH
13671: LD_INT 4
13673: PUSH
13674: LD_INT 5
13676: PUSH
13677: EMPTY
13678: LIST
13679: LIST
13680: ST_TO_ADDR
13681: GO 14380
13683: LD_INT 6
13685: DOUBLE
13686: EQUAL
13687: IFTRUE 13691
13689: GO 13709
13691: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
13692: LD_ADDR_VAR 0 3
13696: PUSH
13697: LD_INT 4
13699: PUSH
13700: LD_INT 5
13702: PUSH
13703: EMPTY
13704: LIST
13705: LIST
13706: ST_TO_ADDR
13707: GO 14380
13709: LD_INT 10
13711: DOUBLE
13712: EQUAL
13713: IFTRUE 13717
13715: GO 13735
13717: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
13718: LD_ADDR_VAR 0 3
13722: PUSH
13723: LD_INT 4
13725: PUSH
13726: LD_INT 5
13728: PUSH
13729: EMPTY
13730: LIST
13731: LIST
13732: ST_TO_ADDR
13733: GO 14380
13735: LD_INT 22
13737: DOUBLE
13738: EQUAL
13739: IFTRUE 13743
13741: GO 13769
13743: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
13744: LD_ADDR_VAR 0 3
13748: PUSH
13749: LD_INT 11
13751: PUSH
13752: LD_INT 12
13754: PUSH
13755: LD_INT 13
13757: PUSH
13758: LD_INT 14
13760: PUSH
13761: EMPTY
13762: LIST
13763: LIST
13764: LIST
13765: LIST
13766: ST_TO_ADDR
13767: GO 14380
13769: LD_INT 23
13771: DOUBLE
13772: EQUAL
13773: IFTRUE 13777
13775: GO 13803
13777: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
13778: LD_ADDR_VAR 0 3
13782: PUSH
13783: LD_INT 11
13785: PUSH
13786: LD_INT 12
13788: PUSH
13789: LD_INT 13
13791: PUSH
13792: LD_INT 14
13794: PUSH
13795: EMPTY
13796: LIST
13797: LIST
13798: LIST
13799: LIST
13800: ST_TO_ADDR
13801: GO 14380
13803: LD_INT 24
13805: DOUBLE
13806: EQUAL
13807: IFTRUE 13811
13809: GO 13837
13811: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
13812: LD_ADDR_VAR 0 3
13816: PUSH
13817: LD_INT 11
13819: PUSH
13820: LD_INT 12
13822: PUSH
13823: LD_INT 13
13825: PUSH
13826: LD_INT 14
13828: PUSH
13829: EMPTY
13830: LIST
13831: LIST
13832: LIST
13833: LIST
13834: ST_TO_ADDR
13835: GO 14380
13837: LD_INT 30
13839: DOUBLE
13840: EQUAL
13841: IFTRUE 13845
13843: GO 13871
13845: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
13846: LD_ADDR_VAR 0 3
13850: PUSH
13851: LD_INT 11
13853: PUSH
13854: LD_INT 12
13856: PUSH
13857: LD_INT 13
13859: PUSH
13860: LD_INT 14
13862: PUSH
13863: EMPTY
13864: LIST
13865: LIST
13866: LIST
13867: LIST
13868: ST_TO_ADDR
13869: GO 14380
13871: LD_INT 25
13873: DOUBLE
13874: EQUAL
13875: IFTRUE 13879
13877: GO 13897
13879: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
13880: LD_ADDR_VAR 0 3
13884: PUSH
13885: LD_INT 13
13887: PUSH
13888: LD_INT 14
13890: PUSH
13891: EMPTY
13892: LIST
13893: LIST
13894: ST_TO_ADDR
13895: GO 14380
13897: LD_INT 27
13899: DOUBLE
13900: EQUAL
13901: IFTRUE 13905
13903: GO 13923
13905: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
13906: LD_ADDR_VAR 0 3
13910: PUSH
13911: LD_INT 13
13913: PUSH
13914: LD_INT 14
13916: PUSH
13917: EMPTY
13918: LIST
13919: LIST
13920: ST_TO_ADDR
13921: GO 14380
13923: LD_EXP 72
13927: DOUBLE
13928: EQUAL
13929: IFTRUE 13933
13931: GO 13959
13933: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
13934: LD_ADDR_VAR 0 3
13938: PUSH
13939: LD_INT 11
13941: PUSH
13942: LD_INT 12
13944: PUSH
13945: LD_INT 13
13947: PUSH
13948: LD_INT 14
13950: PUSH
13951: EMPTY
13952: LIST
13953: LIST
13954: LIST
13955: LIST
13956: ST_TO_ADDR
13957: GO 14380
13959: LD_INT 28
13961: DOUBLE
13962: EQUAL
13963: IFTRUE 13967
13965: GO 13985
13967: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
13968: LD_ADDR_VAR 0 3
13972: PUSH
13973: LD_INT 13
13975: PUSH
13976: LD_INT 14
13978: PUSH
13979: EMPTY
13980: LIST
13981: LIST
13982: ST_TO_ADDR
13983: GO 14380
13985: LD_INT 29
13987: DOUBLE
13988: EQUAL
13989: IFTRUE 13993
13991: GO 14011
13993: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
13994: LD_ADDR_VAR 0 3
13998: PUSH
13999: LD_INT 13
14001: PUSH
14002: LD_INT 14
14004: PUSH
14005: EMPTY
14006: LIST
14007: LIST
14008: ST_TO_ADDR
14009: GO 14380
14011: LD_INT 31
14013: DOUBLE
14014: EQUAL
14015: IFTRUE 14019
14017: GO 14037
14019: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
14020: LD_ADDR_VAR 0 3
14024: PUSH
14025: LD_INT 13
14027: PUSH
14028: LD_INT 14
14030: PUSH
14031: EMPTY
14032: LIST
14033: LIST
14034: ST_TO_ADDR
14035: GO 14380
14037: LD_INT 26
14039: DOUBLE
14040: EQUAL
14041: IFTRUE 14045
14043: GO 14063
14045: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
14046: LD_ADDR_VAR 0 3
14050: PUSH
14051: LD_INT 13
14053: PUSH
14054: LD_INT 14
14056: PUSH
14057: EMPTY
14058: LIST
14059: LIST
14060: ST_TO_ADDR
14061: GO 14380
14063: LD_INT 42
14065: DOUBLE
14066: EQUAL
14067: IFTRUE 14071
14069: GO 14097
14071: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
14072: LD_ADDR_VAR 0 3
14076: PUSH
14077: LD_INT 21
14079: PUSH
14080: LD_INT 22
14082: PUSH
14083: LD_INT 23
14085: PUSH
14086: LD_INT 24
14088: PUSH
14089: EMPTY
14090: LIST
14091: LIST
14092: LIST
14093: LIST
14094: ST_TO_ADDR
14095: GO 14380
14097: LD_INT 43
14099: DOUBLE
14100: EQUAL
14101: IFTRUE 14105
14103: GO 14131
14105: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
14106: LD_ADDR_VAR 0 3
14110: PUSH
14111: LD_INT 21
14113: PUSH
14114: LD_INT 22
14116: PUSH
14117: LD_INT 23
14119: PUSH
14120: LD_INT 24
14122: PUSH
14123: EMPTY
14124: LIST
14125: LIST
14126: LIST
14127: LIST
14128: ST_TO_ADDR
14129: GO 14380
14131: LD_INT 44
14133: DOUBLE
14134: EQUAL
14135: IFTRUE 14139
14137: GO 14165
14139: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
14140: LD_ADDR_VAR 0 3
14144: PUSH
14145: LD_INT 21
14147: PUSH
14148: LD_INT 22
14150: PUSH
14151: LD_INT 23
14153: PUSH
14154: LD_INT 24
14156: PUSH
14157: EMPTY
14158: LIST
14159: LIST
14160: LIST
14161: LIST
14162: ST_TO_ADDR
14163: GO 14380
14165: LD_INT 45
14167: DOUBLE
14168: EQUAL
14169: IFTRUE 14173
14171: GO 14199
14173: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
14174: LD_ADDR_VAR 0 3
14178: PUSH
14179: LD_INT 21
14181: PUSH
14182: LD_INT 22
14184: PUSH
14185: LD_INT 23
14187: PUSH
14188: LD_INT 24
14190: PUSH
14191: EMPTY
14192: LIST
14193: LIST
14194: LIST
14195: LIST
14196: ST_TO_ADDR
14197: GO 14380
14199: LD_INT 49
14201: DOUBLE
14202: EQUAL
14203: IFTRUE 14207
14205: GO 14233
14207: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
14208: LD_ADDR_VAR 0 3
14212: PUSH
14213: LD_INT 21
14215: PUSH
14216: LD_INT 22
14218: PUSH
14219: LD_INT 23
14221: PUSH
14222: LD_INT 24
14224: PUSH
14225: EMPTY
14226: LIST
14227: LIST
14228: LIST
14229: LIST
14230: ST_TO_ADDR
14231: GO 14380
14233: LD_INT 51
14235: DOUBLE
14236: EQUAL
14237: IFTRUE 14241
14239: GO 14267
14241: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
14242: LD_ADDR_VAR 0 3
14246: PUSH
14247: LD_INT 21
14249: PUSH
14250: LD_INT 22
14252: PUSH
14253: LD_INT 23
14255: PUSH
14256: LD_INT 24
14258: PUSH
14259: EMPTY
14260: LIST
14261: LIST
14262: LIST
14263: LIST
14264: ST_TO_ADDR
14265: GO 14380
14267: LD_INT 52
14269: DOUBLE
14270: EQUAL
14271: IFTRUE 14275
14273: GO 14301
14275: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
14276: LD_ADDR_VAR 0 3
14280: PUSH
14281: LD_INT 21
14283: PUSH
14284: LD_INT 22
14286: PUSH
14287: LD_INT 23
14289: PUSH
14290: LD_INT 24
14292: PUSH
14293: EMPTY
14294: LIST
14295: LIST
14296: LIST
14297: LIST
14298: ST_TO_ADDR
14299: GO 14380
14301: LD_INT 53
14303: DOUBLE
14304: EQUAL
14305: IFTRUE 14309
14307: GO 14327
14309: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
14310: LD_ADDR_VAR 0 3
14314: PUSH
14315: LD_INT 23
14317: PUSH
14318: LD_INT 24
14320: PUSH
14321: EMPTY
14322: LIST
14323: LIST
14324: ST_TO_ADDR
14325: GO 14380
14327: LD_INT 46
14329: DOUBLE
14330: EQUAL
14331: IFTRUE 14335
14333: GO 14353
14335: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
14336: LD_ADDR_VAR 0 3
14340: PUSH
14341: LD_INT 23
14343: PUSH
14344: LD_INT 24
14346: PUSH
14347: EMPTY
14348: LIST
14349: LIST
14350: ST_TO_ADDR
14351: GO 14380
14353: LD_INT 47
14355: DOUBLE
14356: EQUAL
14357: IFTRUE 14361
14359: GO 14379
14361: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
14362: LD_ADDR_VAR 0 3
14366: PUSH
14367: LD_INT 23
14369: PUSH
14370: LD_INT 24
14372: PUSH
14373: EMPTY
14374: LIST
14375: LIST
14376: ST_TO_ADDR
14377: GO 14380
14379: POP
// result := ( chassis in result ) ;
14380: LD_ADDR_VAR 0 3
14384: PUSH
14385: LD_VAR 0 1
14389: PUSH
14390: LD_VAR 0 3
14394: IN
14395: ST_TO_ADDR
// end ;
14396: LD_VAR 0 3
14400: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
14401: LD_INT 0
14403: PPUSH
14404: PPUSH
14405: PPUSH
14406: PPUSH
14407: PPUSH
14408: PPUSH
14409: PPUSH
// result := array ;
14410: LD_ADDR_VAR 0 5
14414: PUSH
14415: LD_VAR 0 1
14419: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
14420: LD_VAR 0 1
14424: NOT
14425: PUSH
14426: LD_VAR 0 2
14430: NOT
14431: OR
14432: PUSH
14433: LD_VAR 0 3
14437: NOT
14438: OR
14439: PUSH
14440: LD_VAR 0 2
14444: PUSH
14445: LD_VAR 0 1
14449: GREATER
14450: OR
14451: PUSH
14452: LD_VAR 0 3
14456: PUSH
14457: LD_VAR 0 1
14461: GREATER
14462: OR
14463: IFFALSE 14467
// exit ;
14465: GO 14763
// if direction then
14467: LD_VAR 0 4
14471: IFFALSE 14535
// begin d := 1 ;
14473: LD_ADDR_VAR 0 9
14477: PUSH
14478: LD_INT 1
14480: ST_TO_ADDR
// if i_from > i_to then
14481: LD_VAR 0 2
14485: PUSH
14486: LD_VAR 0 3
14490: GREATER
14491: IFFALSE 14517
// length := ( array - i_from ) + i_to else
14493: LD_ADDR_VAR 0 11
14497: PUSH
14498: LD_VAR 0 1
14502: PUSH
14503: LD_VAR 0 2
14507: MINUS
14508: PUSH
14509: LD_VAR 0 3
14513: PLUS
14514: ST_TO_ADDR
14515: GO 14533
// length := i_to - i_from ;
14517: LD_ADDR_VAR 0 11
14521: PUSH
14522: LD_VAR 0 3
14526: PUSH
14527: LD_VAR 0 2
14531: MINUS
14532: ST_TO_ADDR
// end else
14533: GO 14596
// begin d := - 1 ;
14535: LD_ADDR_VAR 0 9
14539: PUSH
14540: LD_INT 1
14542: NEG
14543: ST_TO_ADDR
// if i_from > i_to then
14544: LD_VAR 0 2
14548: PUSH
14549: LD_VAR 0 3
14553: GREATER
14554: IFFALSE 14574
// length := i_from - i_to else
14556: LD_ADDR_VAR 0 11
14560: PUSH
14561: LD_VAR 0 2
14565: PUSH
14566: LD_VAR 0 3
14570: MINUS
14571: ST_TO_ADDR
14572: GO 14596
// length := ( array - i_to ) + i_from ;
14574: LD_ADDR_VAR 0 11
14578: PUSH
14579: LD_VAR 0 1
14583: PUSH
14584: LD_VAR 0 3
14588: MINUS
14589: PUSH
14590: LD_VAR 0 2
14594: PLUS
14595: ST_TO_ADDR
// end ; if not length then
14596: LD_VAR 0 11
14600: NOT
14601: IFFALSE 14605
// exit ;
14603: GO 14763
// tmp := array ;
14605: LD_ADDR_VAR 0 10
14609: PUSH
14610: LD_VAR 0 1
14614: ST_TO_ADDR
// for i = 1 to length do
14615: LD_ADDR_VAR 0 6
14619: PUSH
14620: DOUBLE
14621: LD_INT 1
14623: DEC
14624: ST_TO_ADDR
14625: LD_VAR 0 11
14629: PUSH
14630: FOR_TO
14631: IFFALSE 14751
// begin for j = 1 to array do
14633: LD_ADDR_VAR 0 7
14637: PUSH
14638: DOUBLE
14639: LD_INT 1
14641: DEC
14642: ST_TO_ADDR
14643: LD_VAR 0 1
14647: PUSH
14648: FOR_TO
14649: IFFALSE 14737
// begin k := j + d ;
14651: LD_ADDR_VAR 0 8
14655: PUSH
14656: LD_VAR 0 7
14660: PUSH
14661: LD_VAR 0 9
14665: PLUS
14666: ST_TO_ADDR
// if k > array then
14667: LD_VAR 0 8
14671: PUSH
14672: LD_VAR 0 1
14676: GREATER
14677: IFFALSE 14687
// k := 1 ;
14679: LD_ADDR_VAR 0 8
14683: PUSH
14684: LD_INT 1
14686: ST_TO_ADDR
// if not k then
14687: LD_VAR 0 8
14691: NOT
14692: IFFALSE 14704
// k := array ;
14694: LD_ADDR_VAR 0 8
14698: PUSH
14699: LD_VAR 0 1
14703: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
14704: LD_ADDR_VAR 0 10
14708: PUSH
14709: LD_VAR 0 10
14713: PPUSH
14714: LD_VAR 0 8
14718: PPUSH
14719: LD_VAR 0 1
14723: PUSH
14724: LD_VAR 0 7
14728: ARRAY
14729: PPUSH
14730: CALL_OW 1
14734: ST_TO_ADDR
// end ;
14735: GO 14648
14737: POP
14738: POP
// array := tmp ;
14739: LD_ADDR_VAR 0 1
14743: PUSH
14744: LD_VAR 0 10
14748: ST_TO_ADDR
// end ;
14749: GO 14630
14751: POP
14752: POP
// result := array ;
14753: LD_ADDR_VAR 0 5
14757: PUSH
14758: LD_VAR 0 1
14762: ST_TO_ADDR
// end ;
14763: LD_VAR 0 5
14767: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
14768: LD_INT 0
14770: PPUSH
14771: PPUSH
// result := 0 ;
14772: LD_ADDR_VAR 0 3
14776: PUSH
14777: LD_INT 0
14779: ST_TO_ADDR
// if not array or not value in array then
14780: LD_VAR 0 1
14784: NOT
14785: PUSH
14786: LD_VAR 0 2
14790: PUSH
14791: LD_VAR 0 1
14795: IN
14796: NOT
14797: OR
14798: IFFALSE 14802
// exit ;
14800: GO 14856
// for i = 1 to array do
14802: LD_ADDR_VAR 0 4
14806: PUSH
14807: DOUBLE
14808: LD_INT 1
14810: DEC
14811: ST_TO_ADDR
14812: LD_VAR 0 1
14816: PUSH
14817: FOR_TO
14818: IFFALSE 14854
// if value = array [ i ] then
14820: LD_VAR 0 2
14824: PUSH
14825: LD_VAR 0 1
14829: PUSH
14830: LD_VAR 0 4
14834: ARRAY
14835: EQUAL
14836: IFFALSE 14852
// begin result := i ;
14838: LD_ADDR_VAR 0 3
14842: PUSH
14843: LD_VAR 0 4
14847: ST_TO_ADDR
// exit ;
14848: POP
14849: POP
14850: GO 14856
// end ;
14852: GO 14817
14854: POP
14855: POP
// end ;
14856: LD_VAR 0 3
14860: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
14861: LD_INT 0
14863: PPUSH
// vc_chassis := chassis ;
14864: LD_ADDR_OWVAR 37
14868: PUSH
14869: LD_VAR 0 1
14873: ST_TO_ADDR
// vc_engine := engine ;
14874: LD_ADDR_OWVAR 39
14878: PUSH
14879: LD_VAR 0 2
14883: ST_TO_ADDR
// vc_control := control ;
14884: LD_ADDR_OWVAR 38
14888: PUSH
14889: LD_VAR 0 3
14893: ST_TO_ADDR
// vc_weapon := weapon ;
14894: LD_ADDR_OWVAR 40
14898: PUSH
14899: LD_VAR 0 4
14903: ST_TO_ADDR
// vc_fuel_battery := fuel ;
14904: LD_ADDR_OWVAR 41
14908: PUSH
14909: LD_VAR 0 5
14913: ST_TO_ADDR
// end ;
14914: LD_VAR 0 6
14918: RET
// export function WantPlant ( unit ) ; var task ; begin
14919: LD_INT 0
14921: PPUSH
14922: PPUSH
// result := false ;
14923: LD_ADDR_VAR 0 2
14927: PUSH
14928: LD_INT 0
14930: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
14931: LD_ADDR_VAR 0 3
14935: PUSH
14936: LD_VAR 0 1
14940: PPUSH
14941: CALL_OW 437
14945: ST_TO_ADDR
// if task then
14946: LD_VAR 0 3
14950: IFFALSE 14978
// if task [ 1 ] [ 1 ] = p then
14952: LD_VAR 0 3
14956: PUSH
14957: LD_INT 1
14959: ARRAY
14960: PUSH
14961: LD_INT 1
14963: ARRAY
14964: PUSH
14965: LD_STRING p
14967: EQUAL
14968: IFFALSE 14978
// result := true ;
14970: LD_ADDR_VAR 0 2
14974: PUSH
14975: LD_INT 1
14977: ST_TO_ADDR
// end ;
14978: LD_VAR 0 2
14982: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
14983: LD_INT 0
14985: PPUSH
14986: PPUSH
14987: PPUSH
14988: PPUSH
// if pos < 1 then
14989: LD_VAR 0 2
14993: PUSH
14994: LD_INT 1
14996: LESS
14997: IFFALSE 15001
// exit ;
14999: GO 15304
// if pos = 1 then
15001: LD_VAR 0 2
15005: PUSH
15006: LD_INT 1
15008: EQUAL
15009: IFFALSE 15042
// result := Replace ( arr , pos [ 1 ] , value ) else
15011: LD_ADDR_VAR 0 4
15015: PUSH
15016: LD_VAR 0 1
15020: PPUSH
15021: LD_VAR 0 2
15025: PUSH
15026: LD_INT 1
15028: ARRAY
15029: PPUSH
15030: LD_VAR 0 3
15034: PPUSH
15035: CALL_OW 1
15039: ST_TO_ADDR
15040: GO 15304
// begin tmp := arr ;
15042: LD_ADDR_VAR 0 6
15046: PUSH
15047: LD_VAR 0 1
15051: ST_TO_ADDR
// s_arr := [ tmp ] ;
15052: LD_ADDR_VAR 0 7
15056: PUSH
15057: LD_VAR 0 6
15061: PUSH
15062: EMPTY
15063: LIST
15064: ST_TO_ADDR
// for i = 1 to pos - 1 do
15065: LD_ADDR_VAR 0 5
15069: PUSH
15070: DOUBLE
15071: LD_INT 1
15073: DEC
15074: ST_TO_ADDR
15075: LD_VAR 0 2
15079: PUSH
15080: LD_INT 1
15082: MINUS
15083: PUSH
15084: FOR_TO
15085: IFFALSE 15130
// begin tmp := tmp [ pos [ i ] ] ;
15087: LD_ADDR_VAR 0 6
15091: PUSH
15092: LD_VAR 0 6
15096: PUSH
15097: LD_VAR 0 2
15101: PUSH
15102: LD_VAR 0 5
15106: ARRAY
15107: ARRAY
15108: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
15109: LD_ADDR_VAR 0 7
15113: PUSH
15114: LD_VAR 0 7
15118: PUSH
15119: LD_VAR 0 6
15123: PUSH
15124: EMPTY
15125: LIST
15126: ADD
15127: ST_TO_ADDR
// end ;
15128: GO 15084
15130: POP
15131: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
15132: LD_ADDR_VAR 0 6
15136: PUSH
15137: LD_VAR 0 6
15141: PPUSH
15142: LD_VAR 0 2
15146: PUSH
15147: LD_VAR 0 2
15151: ARRAY
15152: PPUSH
15153: LD_VAR 0 3
15157: PPUSH
15158: CALL_OW 1
15162: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
15163: LD_ADDR_VAR 0 7
15167: PUSH
15168: LD_VAR 0 7
15172: PPUSH
15173: LD_VAR 0 7
15177: PPUSH
15178: LD_VAR 0 6
15182: PPUSH
15183: CALL_OW 1
15187: ST_TO_ADDR
// for i = s_arr downto 2 do
15188: LD_ADDR_VAR 0 5
15192: PUSH
15193: DOUBLE
15194: LD_VAR 0 7
15198: INC
15199: ST_TO_ADDR
15200: LD_INT 2
15202: PUSH
15203: FOR_DOWNTO
15204: IFFALSE 15288
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
15206: LD_ADDR_VAR 0 6
15210: PUSH
15211: LD_VAR 0 7
15215: PUSH
15216: LD_VAR 0 5
15220: PUSH
15221: LD_INT 1
15223: MINUS
15224: ARRAY
15225: PPUSH
15226: LD_VAR 0 2
15230: PUSH
15231: LD_VAR 0 5
15235: PUSH
15236: LD_INT 1
15238: MINUS
15239: ARRAY
15240: PPUSH
15241: LD_VAR 0 7
15245: PUSH
15246: LD_VAR 0 5
15250: ARRAY
15251: PPUSH
15252: CALL_OW 1
15256: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
15257: LD_ADDR_VAR 0 7
15261: PUSH
15262: LD_VAR 0 7
15266: PPUSH
15267: LD_VAR 0 5
15271: PUSH
15272: LD_INT 1
15274: MINUS
15275: PPUSH
15276: LD_VAR 0 6
15280: PPUSH
15281: CALL_OW 1
15285: ST_TO_ADDR
// end ;
15286: GO 15203
15288: POP
15289: POP
// result := s_arr [ 1 ] ;
15290: LD_ADDR_VAR 0 4
15294: PUSH
15295: LD_VAR 0 7
15299: PUSH
15300: LD_INT 1
15302: ARRAY
15303: ST_TO_ADDR
// end ; end ;
15304: LD_VAR 0 4
15308: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
15309: LD_INT 0
15311: PPUSH
15312: PPUSH
// if not list then
15313: LD_VAR 0 1
15317: NOT
15318: IFFALSE 15322
// exit ;
15320: GO 15413
// i := list [ pos1 ] ;
15322: LD_ADDR_VAR 0 5
15326: PUSH
15327: LD_VAR 0 1
15331: PUSH
15332: LD_VAR 0 2
15336: ARRAY
15337: ST_TO_ADDR
// if not i then
15338: LD_VAR 0 5
15342: NOT
15343: IFFALSE 15347
// exit ;
15345: GO 15413
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
15347: LD_ADDR_VAR 0 1
15351: PUSH
15352: LD_VAR 0 1
15356: PPUSH
15357: LD_VAR 0 2
15361: PPUSH
15362: LD_VAR 0 1
15366: PUSH
15367: LD_VAR 0 3
15371: ARRAY
15372: PPUSH
15373: CALL_OW 1
15377: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
15378: LD_ADDR_VAR 0 1
15382: PUSH
15383: LD_VAR 0 1
15387: PPUSH
15388: LD_VAR 0 3
15392: PPUSH
15393: LD_VAR 0 5
15397: PPUSH
15398: CALL_OW 1
15402: ST_TO_ADDR
// result := list ;
15403: LD_ADDR_VAR 0 4
15407: PUSH
15408: LD_VAR 0 1
15412: ST_TO_ADDR
// end ;
15413: LD_VAR 0 4
15417: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
15418: LD_INT 0
15420: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
15421: LD_ADDR_VAR 0 5
15425: PUSH
15426: LD_VAR 0 1
15430: PPUSH
15431: CALL_OW 250
15435: PPUSH
15436: LD_VAR 0 1
15440: PPUSH
15441: CALL_OW 251
15445: PPUSH
15446: LD_VAR 0 2
15450: PPUSH
15451: LD_VAR 0 3
15455: PPUSH
15456: LD_VAR 0 4
15460: PPUSH
15461: CALL 15471 0 5
15465: ST_TO_ADDR
// end ;
15466: LD_VAR 0 5
15470: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
15471: LD_INT 0
15473: PPUSH
15474: PPUSH
15475: PPUSH
15476: PPUSH
// if not list then
15477: LD_VAR 0 3
15481: NOT
15482: IFFALSE 15486
// exit ;
15484: GO 15874
// result := [ ] ;
15486: LD_ADDR_VAR 0 6
15490: PUSH
15491: EMPTY
15492: ST_TO_ADDR
// for i in list do
15493: LD_ADDR_VAR 0 7
15497: PUSH
15498: LD_VAR 0 3
15502: PUSH
15503: FOR_IN
15504: IFFALSE 15706
// begin tmp := GetDistUnitXY ( i , x , y ) ;
15506: LD_ADDR_VAR 0 9
15510: PUSH
15511: LD_VAR 0 7
15515: PPUSH
15516: LD_VAR 0 1
15520: PPUSH
15521: LD_VAR 0 2
15525: PPUSH
15526: CALL_OW 297
15530: ST_TO_ADDR
// if not result then
15531: LD_VAR 0 6
15535: NOT
15536: IFFALSE 15562
// result := [ [ i , tmp ] ] else
15538: LD_ADDR_VAR 0 6
15542: PUSH
15543: LD_VAR 0 7
15547: PUSH
15548: LD_VAR 0 9
15552: PUSH
15553: EMPTY
15554: LIST
15555: LIST
15556: PUSH
15557: EMPTY
15558: LIST
15559: ST_TO_ADDR
15560: GO 15704
// begin if result [ result ] [ 2 ] < tmp then
15562: LD_VAR 0 6
15566: PUSH
15567: LD_VAR 0 6
15571: ARRAY
15572: PUSH
15573: LD_INT 2
15575: ARRAY
15576: PUSH
15577: LD_VAR 0 9
15581: LESS
15582: IFFALSE 15624
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
15584: LD_ADDR_VAR 0 6
15588: PUSH
15589: LD_VAR 0 6
15593: PPUSH
15594: LD_VAR 0 6
15598: PUSH
15599: LD_INT 1
15601: PLUS
15602: PPUSH
15603: LD_VAR 0 7
15607: PUSH
15608: LD_VAR 0 9
15612: PUSH
15613: EMPTY
15614: LIST
15615: LIST
15616: PPUSH
15617: CALL_OW 2
15621: ST_TO_ADDR
15622: GO 15704
// for j = 1 to result do
15624: LD_ADDR_VAR 0 8
15628: PUSH
15629: DOUBLE
15630: LD_INT 1
15632: DEC
15633: ST_TO_ADDR
15634: LD_VAR 0 6
15638: PUSH
15639: FOR_TO
15640: IFFALSE 15702
// begin if tmp < result [ j ] [ 2 ] then
15642: LD_VAR 0 9
15646: PUSH
15647: LD_VAR 0 6
15651: PUSH
15652: LD_VAR 0 8
15656: ARRAY
15657: PUSH
15658: LD_INT 2
15660: ARRAY
15661: LESS
15662: IFFALSE 15700
// begin result := Insert ( result , j , [ i , tmp ] ) ;
15664: LD_ADDR_VAR 0 6
15668: PUSH
15669: LD_VAR 0 6
15673: PPUSH
15674: LD_VAR 0 8
15678: PPUSH
15679: LD_VAR 0 7
15683: PUSH
15684: LD_VAR 0 9
15688: PUSH
15689: EMPTY
15690: LIST
15691: LIST
15692: PPUSH
15693: CALL_OW 2
15697: ST_TO_ADDR
// break ;
15698: GO 15702
// end ; end ;
15700: GO 15639
15702: POP
15703: POP
// end ; end ;
15704: GO 15503
15706: POP
15707: POP
// if result and not asc then
15708: LD_VAR 0 6
15712: PUSH
15713: LD_VAR 0 4
15717: NOT
15718: AND
15719: IFFALSE 15794
// begin tmp := result ;
15721: LD_ADDR_VAR 0 9
15725: PUSH
15726: LD_VAR 0 6
15730: ST_TO_ADDR
// for i = tmp downto 1 do
15731: LD_ADDR_VAR 0 7
15735: PUSH
15736: DOUBLE
15737: LD_VAR 0 9
15741: INC
15742: ST_TO_ADDR
15743: LD_INT 1
15745: PUSH
15746: FOR_DOWNTO
15747: IFFALSE 15792
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
15749: LD_ADDR_VAR 0 6
15753: PUSH
15754: LD_VAR 0 6
15758: PPUSH
15759: LD_VAR 0 9
15763: PUSH
15764: LD_VAR 0 7
15768: MINUS
15769: PUSH
15770: LD_INT 1
15772: PLUS
15773: PPUSH
15774: LD_VAR 0 9
15778: PUSH
15779: LD_VAR 0 7
15783: ARRAY
15784: PPUSH
15785: CALL_OW 1
15789: ST_TO_ADDR
15790: GO 15746
15792: POP
15793: POP
// end ; tmp := [ ] ;
15794: LD_ADDR_VAR 0 9
15798: PUSH
15799: EMPTY
15800: ST_TO_ADDR
// if mode then
15801: LD_VAR 0 5
15805: IFFALSE 15874
// begin for i = 1 to result do
15807: LD_ADDR_VAR 0 7
15811: PUSH
15812: DOUBLE
15813: LD_INT 1
15815: DEC
15816: ST_TO_ADDR
15817: LD_VAR 0 6
15821: PUSH
15822: FOR_TO
15823: IFFALSE 15862
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
15825: LD_ADDR_VAR 0 9
15829: PUSH
15830: LD_VAR 0 9
15834: PPUSH
15835: LD_VAR 0 7
15839: PPUSH
15840: LD_VAR 0 6
15844: PUSH
15845: LD_VAR 0 7
15849: ARRAY
15850: PUSH
15851: LD_INT 1
15853: ARRAY
15854: PPUSH
15855: CALL_OW 1
15859: ST_TO_ADDR
15860: GO 15822
15862: POP
15863: POP
// result := tmp ;
15864: LD_ADDR_VAR 0 6
15868: PUSH
15869: LD_VAR 0 9
15873: ST_TO_ADDR
// end ; end ;
15874: LD_VAR 0 6
15878: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
15879: LD_INT 0
15881: PPUSH
15882: PPUSH
15883: PPUSH
15884: PPUSH
15885: PPUSH
15886: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
15887: LD_ADDR_VAR 0 5
15891: PUSH
15892: LD_INT 0
15894: PUSH
15895: LD_INT 0
15897: PUSH
15898: LD_INT 0
15900: PUSH
15901: EMPTY
15902: PUSH
15903: EMPTY
15904: LIST
15905: LIST
15906: LIST
15907: LIST
15908: ST_TO_ADDR
// if not x or not y then
15909: LD_VAR 0 2
15913: NOT
15914: PUSH
15915: LD_VAR 0 3
15919: NOT
15920: OR
15921: IFFALSE 15925
// exit ;
15923: GO 17577
// if not range then
15925: LD_VAR 0 4
15929: NOT
15930: IFFALSE 15940
// range := 10 ;
15932: LD_ADDR_VAR 0 4
15936: PUSH
15937: LD_INT 10
15939: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15940: LD_ADDR_VAR 0 8
15944: PUSH
15945: LD_INT 81
15947: PUSH
15948: LD_VAR 0 1
15952: PUSH
15953: EMPTY
15954: LIST
15955: LIST
15956: PUSH
15957: LD_INT 92
15959: PUSH
15960: LD_VAR 0 2
15964: PUSH
15965: LD_VAR 0 3
15969: PUSH
15970: LD_VAR 0 4
15974: PUSH
15975: EMPTY
15976: LIST
15977: LIST
15978: LIST
15979: LIST
15980: PUSH
15981: LD_INT 3
15983: PUSH
15984: LD_INT 21
15986: PUSH
15987: LD_INT 3
15989: PUSH
15990: EMPTY
15991: LIST
15992: LIST
15993: PUSH
15994: EMPTY
15995: LIST
15996: LIST
15997: PUSH
15998: EMPTY
15999: LIST
16000: LIST
16001: LIST
16002: PPUSH
16003: CALL_OW 69
16007: ST_TO_ADDR
// if not tmp then
16008: LD_VAR 0 8
16012: NOT
16013: IFFALSE 16017
// exit ;
16015: GO 17577
// for i in tmp do
16017: LD_ADDR_VAR 0 6
16021: PUSH
16022: LD_VAR 0 8
16026: PUSH
16027: FOR_IN
16028: IFFALSE 17552
// begin points := [ 0 , 0 , 0 ] ;
16030: LD_ADDR_VAR 0 9
16034: PUSH
16035: LD_INT 0
16037: PUSH
16038: LD_INT 0
16040: PUSH
16041: LD_INT 0
16043: PUSH
16044: EMPTY
16045: LIST
16046: LIST
16047: LIST
16048: ST_TO_ADDR
// bpoints := 1 ;
16049: LD_ADDR_VAR 0 10
16053: PUSH
16054: LD_INT 1
16056: ST_TO_ADDR
// case GetType ( i ) of unit_human :
16057: LD_VAR 0 6
16061: PPUSH
16062: CALL_OW 247
16066: PUSH
16067: LD_INT 1
16069: DOUBLE
16070: EQUAL
16071: IFTRUE 16075
16073: GO 16653
16075: POP
// begin if GetClass ( i ) = 1 then
16076: LD_VAR 0 6
16080: PPUSH
16081: CALL_OW 257
16085: PUSH
16086: LD_INT 1
16088: EQUAL
16089: IFFALSE 16110
// points := [ 10 , 5 , 3 ] ;
16091: LD_ADDR_VAR 0 9
16095: PUSH
16096: LD_INT 10
16098: PUSH
16099: LD_INT 5
16101: PUSH
16102: LD_INT 3
16104: PUSH
16105: EMPTY
16106: LIST
16107: LIST
16108: LIST
16109: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
16110: LD_VAR 0 6
16114: PPUSH
16115: CALL_OW 257
16119: PUSH
16120: LD_INT 2
16122: PUSH
16123: LD_INT 3
16125: PUSH
16126: LD_INT 4
16128: PUSH
16129: EMPTY
16130: LIST
16131: LIST
16132: LIST
16133: IN
16134: IFFALSE 16155
// points := [ 3 , 2 , 1 ] ;
16136: LD_ADDR_VAR 0 9
16140: PUSH
16141: LD_INT 3
16143: PUSH
16144: LD_INT 2
16146: PUSH
16147: LD_INT 1
16149: PUSH
16150: EMPTY
16151: LIST
16152: LIST
16153: LIST
16154: ST_TO_ADDR
// if GetClass ( i ) = 5 then
16155: LD_VAR 0 6
16159: PPUSH
16160: CALL_OW 257
16164: PUSH
16165: LD_INT 5
16167: EQUAL
16168: IFFALSE 16189
// points := [ 130 , 5 , 2 ] ;
16170: LD_ADDR_VAR 0 9
16174: PUSH
16175: LD_INT 130
16177: PUSH
16178: LD_INT 5
16180: PUSH
16181: LD_INT 2
16183: PUSH
16184: EMPTY
16185: LIST
16186: LIST
16187: LIST
16188: ST_TO_ADDR
// if GetClass ( i ) = 8 then
16189: LD_VAR 0 6
16193: PPUSH
16194: CALL_OW 257
16198: PUSH
16199: LD_INT 8
16201: EQUAL
16202: IFFALSE 16223
// points := [ 35 , 35 , 30 ] ;
16204: LD_ADDR_VAR 0 9
16208: PUSH
16209: LD_INT 35
16211: PUSH
16212: LD_INT 35
16214: PUSH
16215: LD_INT 30
16217: PUSH
16218: EMPTY
16219: LIST
16220: LIST
16221: LIST
16222: ST_TO_ADDR
// if GetClass ( i ) = 9 then
16223: LD_VAR 0 6
16227: PPUSH
16228: CALL_OW 257
16232: PUSH
16233: LD_INT 9
16235: EQUAL
16236: IFFALSE 16257
// points := [ 20 , 55 , 40 ] ;
16238: LD_ADDR_VAR 0 9
16242: PUSH
16243: LD_INT 20
16245: PUSH
16246: LD_INT 55
16248: PUSH
16249: LD_INT 40
16251: PUSH
16252: EMPTY
16253: LIST
16254: LIST
16255: LIST
16256: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
16257: LD_VAR 0 6
16261: PPUSH
16262: CALL_OW 257
16266: PUSH
16267: LD_INT 12
16269: PUSH
16270: LD_INT 16
16272: PUSH
16273: EMPTY
16274: LIST
16275: LIST
16276: IN
16277: IFFALSE 16298
// points := [ 5 , 3 , 2 ] ;
16279: LD_ADDR_VAR 0 9
16283: PUSH
16284: LD_INT 5
16286: PUSH
16287: LD_INT 3
16289: PUSH
16290: LD_INT 2
16292: PUSH
16293: EMPTY
16294: LIST
16295: LIST
16296: LIST
16297: ST_TO_ADDR
// if GetClass ( i ) = 17 then
16298: LD_VAR 0 6
16302: PPUSH
16303: CALL_OW 257
16307: PUSH
16308: LD_INT 17
16310: EQUAL
16311: IFFALSE 16332
// points := [ 100 , 50 , 75 ] ;
16313: LD_ADDR_VAR 0 9
16317: PUSH
16318: LD_INT 100
16320: PUSH
16321: LD_INT 50
16323: PUSH
16324: LD_INT 75
16326: PUSH
16327: EMPTY
16328: LIST
16329: LIST
16330: LIST
16331: ST_TO_ADDR
// if GetClass ( i ) = 15 then
16332: LD_VAR 0 6
16336: PPUSH
16337: CALL_OW 257
16341: PUSH
16342: LD_INT 15
16344: EQUAL
16345: IFFALSE 16366
// points := [ 10 , 5 , 3 ] ;
16347: LD_ADDR_VAR 0 9
16351: PUSH
16352: LD_INT 10
16354: PUSH
16355: LD_INT 5
16357: PUSH
16358: LD_INT 3
16360: PUSH
16361: EMPTY
16362: LIST
16363: LIST
16364: LIST
16365: ST_TO_ADDR
// if GetClass ( i ) = 14 then
16366: LD_VAR 0 6
16370: PPUSH
16371: CALL_OW 257
16375: PUSH
16376: LD_INT 14
16378: EQUAL
16379: IFFALSE 16400
// points := [ 10 , 0 , 0 ] ;
16381: LD_ADDR_VAR 0 9
16385: PUSH
16386: LD_INT 10
16388: PUSH
16389: LD_INT 0
16391: PUSH
16392: LD_INT 0
16394: PUSH
16395: EMPTY
16396: LIST
16397: LIST
16398: LIST
16399: ST_TO_ADDR
// if GetClass ( i ) = 11 then
16400: LD_VAR 0 6
16404: PPUSH
16405: CALL_OW 257
16409: PUSH
16410: LD_INT 11
16412: EQUAL
16413: IFFALSE 16434
// points := [ 30 , 10 , 5 ] ;
16415: LD_ADDR_VAR 0 9
16419: PUSH
16420: LD_INT 30
16422: PUSH
16423: LD_INT 10
16425: PUSH
16426: LD_INT 5
16428: PUSH
16429: EMPTY
16430: LIST
16431: LIST
16432: LIST
16433: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
16434: LD_VAR 0 1
16438: PPUSH
16439: LD_INT 5
16441: PPUSH
16442: CALL_OW 321
16446: PUSH
16447: LD_INT 2
16449: EQUAL
16450: IFFALSE 16467
// bpoints := bpoints * 1.8 ;
16452: LD_ADDR_VAR 0 10
16456: PUSH
16457: LD_VAR 0 10
16461: PUSH
16462: LD_REAL  1.80000000000000E+0000
16465: MUL
16466: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
16467: LD_VAR 0 6
16471: PPUSH
16472: CALL_OW 257
16476: PUSH
16477: LD_INT 1
16479: PUSH
16480: LD_INT 2
16482: PUSH
16483: LD_INT 3
16485: PUSH
16486: LD_INT 4
16488: PUSH
16489: EMPTY
16490: LIST
16491: LIST
16492: LIST
16493: LIST
16494: IN
16495: PUSH
16496: LD_VAR 0 1
16500: PPUSH
16501: LD_INT 51
16503: PPUSH
16504: CALL_OW 321
16508: PUSH
16509: LD_INT 2
16511: EQUAL
16512: AND
16513: IFFALSE 16530
// bpoints := bpoints * 1.2 ;
16515: LD_ADDR_VAR 0 10
16519: PUSH
16520: LD_VAR 0 10
16524: PUSH
16525: LD_REAL  1.20000000000000E+0000
16528: MUL
16529: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
16530: LD_VAR 0 6
16534: PPUSH
16535: CALL_OW 257
16539: PUSH
16540: LD_INT 5
16542: PUSH
16543: LD_INT 7
16545: PUSH
16546: LD_INT 9
16548: PUSH
16549: EMPTY
16550: LIST
16551: LIST
16552: LIST
16553: IN
16554: PUSH
16555: LD_VAR 0 1
16559: PPUSH
16560: LD_INT 52
16562: PPUSH
16563: CALL_OW 321
16567: PUSH
16568: LD_INT 2
16570: EQUAL
16571: AND
16572: IFFALSE 16589
// bpoints := bpoints * 1.5 ;
16574: LD_ADDR_VAR 0 10
16578: PUSH
16579: LD_VAR 0 10
16583: PUSH
16584: LD_REAL  1.50000000000000E+0000
16587: MUL
16588: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
16589: LD_VAR 0 1
16593: PPUSH
16594: LD_INT 66
16596: PPUSH
16597: CALL_OW 321
16601: PUSH
16602: LD_INT 2
16604: EQUAL
16605: IFFALSE 16622
// bpoints := bpoints * 1.1 ;
16607: LD_ADDR_VAR 0 10
16611: PUSH
16612: LD_VAR 0 10
16616: PUSH
16617: LD_REAL  1.10000000000000E+0000
16620: MUL
16621: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
16622: LD_ADDR_VAR 0 10
16626: PUSH
16627: LD_VAR 0 10
16631: PUSH
16632: LD_VAR 0 6
16636: PPUSH
16637: LD_INT 1
16639: PPUSH
16640: CALL_OW 259
16644: PUSH
16645: LD_REAL  1.15000000000000E+0000
16648: MUL
16649: MUL
16650: ST_TO_ADDR
// end ; unit_vehicle :
16651: GO 17481
16653: LD_INT 2
16655: DOUBLE
16656: EQUAL
16657: IFTRUE 16661
16659: GO 17469
16661: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
16662: LD_VAR 0 6
16666: PPUSH
16667: CALL_OW 264
16671: PUSH
16672: LD_INT 2
16674: PUSH
16675: LD_INT 42
16677: PUSH
16678: LD_INT 24
16680: PUSH
16681: EMPTY
16682: LIST
16683: LIST
16684: LIST
16685: IN
16686: IFFALSE 16707
// points := [ 25 , 5 , 3 ] ;
16688: LD_ADDR_VAR 0 9
16692: PUSH
16693: LD_INT 25
16695: PUSH
16696: LD_INT 5
16698: PUSH
16699: LD_INT 3
16701: PUSH
16702: EMPTY
16703: LIST
16704: LIST
16705: LIST
16706: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
16707: LD_VAR 0 6
16711: PPUSH
16712: CALL_OW 264
16716: PUSH
16717: LD_INT 4
16719: PUSH
16720: LD_INT 43
16722: PUSH
16723: LD_INT 25
16725: PUSH
16726: EMPTY
16727: LIST
16728: LIST
16729: LIST
16730: IN
16731: IFFALSE 16752
// points := [ 40 , 15 , 5 ] ;
16733: LD_ADDR_VAR 0 9
16737: PUSH
16738: LD_INT 40
16740: PUSH
16741: LD_INT 15
16743: PUSH
16744: LD_INT 5
16746: PUSH
16747: EMPTY
16748: LIST
16749: LIST
16750: LIST
16751: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
16752: LD_VAR 0 6
16756: PPUSH
16757: CALL_OW 264
16761: PUSH
16762: LD_INT 3
16764: PUSH
16765: LD_INT 23
16767: PUSH
16768: EMPTY
16769: LIST
16770: LIST
16771: IN
16772: IFFALSE 16793
// points := [ 7 , 25 , 8 ] ;
16774: LD_ADDR_VAR 0 9
16778: PUSH
16779: LD_INT 7
16781: PUSH
16782: LD_INT 25
16784: PUSH
16785: LD_INT 8
16787: PUSH
16788: EMPTY
16789: LIST
16790: LIST
16791: LIST
16792: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
16793: LD_VAR 0 6
16797: PPUSH
16798: CALL_OW 264
16802: PUSH
16803: LD_INT 5
16805: PUSH
16806: LD_INT 27
16808: PUSH
16809: LD_INT 44
16811: PUSH
16812: EMPTY
16813: LIST
16814: LIST
16815: LIST
16816: IN
16817: IFFALSE 16838
// points := [ 14 , 50 , 16 ] ;
16819: LD_ADDR_VAR 0 9
16823: PUSH
16824: LD_INT 14
16826: PUSH
16827: LD_INT 50
16829: PUSH
16830: LD_INT 16
16832: PUSH
16833: EMPTY
16834: LIST
16835: LIST
16836: LIST
16837: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
16838: LD_VAR 0 6
16842: PPUSH
16843: CALL_OW 264
16847: PUSH
16848: LD_INT 6
16850: PUSH
16851: LD_INT 46
16853: PUSH
16854: EMPTY
16855: LIST
16856: LIST
16857: IN
16858: IFFALSE 16879
// points := [ 32 , 120 , 70 ] ;
16860: LD_ADDR_VAR 0 9
16864: PUSH
16865: LD_INT 32
16867: PUSH
16868: LD_INT 120
16870: PUSH
16871: LD_INT 70
16873: PUSH
16874: EMPTY
16875: LIST
16876: LIST
16877: LIST
16878: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
16879: LD_VAR 0 6
16883: PPUSH
16884: CALL_OW 264
16888: PUSH
16889: LD_INT 7
16891: PUSH
16892: LD_INT 28
16894: PUSH
16895: LD_INT 45
16897: PUSH
16898: LD_EXP 72
16902: PUSH
16903: EMPTY
16904: LIST
16905: LIST
16906: LIST
16907: LIST
16908: IN
16909: IFFALSE 16930
// points := [ 35 , 20 , 45 ] ;
16911: LD_ADDR_VAR 0 9
16915: PUSH
16916: LD_INT 35
16918: PUSH
16919: LD_INT 20
16921: PUSH
16922: LD_INT 45
16924: PUSH
16925: EMPTY
16926: LIST
16927: LIST
16928: LIST
16929: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
16930: LD_VAR 0 6
16934: PPUSH
16935: CALL_OW 264
16939: PUSH
16940: LD_INT 47
16942: PUSH
16943: EMPTY
16944: LIST
16945: IN
16946: IFFALSE 16967
// points := [ 67 , 45 , 75 ] ;
16948: LD_ADDR_VAR 0 9
16952: PUSH
16953: LD_INT 67
16955: PUSH
16956: LD_INT 45
16958: PUSH
16959: LD_INT 75
16961: PUSH
16962: EMPTY
16963: LIST
16964: LIST
16965: LIST
16966: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
16967: LD_VAR 0 6
16971: PPUSH
16972: CALL_OW 264
16976: PUSH
16977: LD_INT 26
16979: PUSH
16980: EMPTY
16981: LIST
16982: IN
16983: IFFALSE 17004
// points := [ 120 , 30 , 80 ] ;
16985: LD_ADDR_VAR 0 9
16989: PUSH
16990: LD_INT 120
16992: PUSH
16993: LD_INT 30
16995: PUSH
16996: LD_INT 80
16998: PUSH
16999: EMPTY
17000: LIST
17001: LIST
17002: LIST
17003: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
17004: LD_VAR 0 6
17008: PPUSH
17009: CALL_OW 264
17013: PUSH
17014: LD_INT 22
17016: PUSH
17017: EMPTY
17018: LIST
17019: IN
17020: IFFALSE 17041
// points := [ 40 , 1 , 1 ] ;
17022: LD_ADDR_VAR 0 9
17026: PUSH
17027: LD_INT 40
17029: PUSH
17030: LD_INT 1
17032: PUSH
17033: LD_INT 1
17035: PUSH
17036: EMPTY
17037: LIST
17038: LIST
17039: LIST
17040: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
17041: LD_VAR 0 6
17045: PPUSH
17046: CALL_OW 264
17050: PUSH
17051: LD_INT 29
17053: PUSH
17054: EMPTY
17055: LIST
17056: IN
17057: IFFALSE 17078
// points := [ 70 , 200 , 400 ] ;
17059: LD_ADDR_VAR 0 9
17063: PUSH
17064: LD_INT 70
17066: PUSH
17067: LD_INT 200
17069: PUSH
17070: LD_INT 400
17072: PUSH
17073: EMPTY
17074: LIST
17075: LIST
17076: LIST
17077: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
17078: LD_VAR 0 6
17082: PPUSH
17083: CALL_OW 264
17087: PUSH
17088: LD_INT 14
17090: PUSH
17091: LD_INT 53
17093: PUSH
17094: EMPTY
17095: LIST
17096: LIST
17097: IN
17098: IFFALSE 17119
// points := [ 40 , 10 , 20 ] ;
17100: LD_ADDR_VAR 0 9
17104: PUSH
17105: LD_INT 40
17107: PUSH
17108: LD_INT 10
17110: PUSH
17111: LD_INT 20
17113: PUSH
17114: EMPTY
17115: LIST
17116: LIST
17117: LIST
17118: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
17119: LD_VAR 0 6
17123: PPUSH
17124: CALL_OW 264
17128: PUSH
17129: LD_INT 9
17131: PUSH
17132: EMPTY
17133: LIST
17134: IN
17135: IFFALSE 17156
// points := [ 5 , 70 , 20 ] ;
17137: LD_ADDR_VAR 0 9
17141: PUSH
17142: LD_INT 5
17144: PUSH
17145: LD_INT 70
17147: PUSH
17148: LD_INT 20
17150: PUSH
17151: EMPTY
17152: LIST
17153: LIST
17154: LIST
17155: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
17156: LD_VAR 0 6
17160: PPUSH
17161: CALL_OW 264
17165: PUSH
17166: LD_INT 10
17168: PUSH
17169: EMPTY
17170: LIST
17171: IN
17172: IFFALSE 17193
// points := [ 35 , 110 , 70 ] ;
17174: LD_ADDR_VAR 0 9
17178: PUSH
17179: LD_INT 35
17181: PUSH
17182: LD_INT 110
17184: PUSH
17185: LD_INT 70
17187: PUSH
17188: EMPTY
17189: LIST
17190: LIST
17191: LIST
17192: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
17193: LD_VAR 0 6
17197: PPUSH
17198: CALL_OW 265
17202: PUSH
17203: LD_INT 25
17205: EQUAL
17206: IFFALSE 17227
// points := [ 80 , 65 , 100 ] ;
17208: LD_ADDR_VAR 0 9
17212: PUSH
17213: LD_INT 80
17215: PUSH
17216: LD_INT 65
17218: PUSH
17219: LD_INT 100
17221: PUSH
17222: EMPTY
17223: LIST
17224: LIST
17225: LIST
17226: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
17227: LD_VAR 0 6
17231: PPUSH
17232: CALL_OW 263
17236: PUSH
17237: LD_INT 1
17239: EQUAL
17240: IFFALSE 17275
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
17242: LD_ADDR_VAR 0 10
17246: PUSH
17247: LD_VAR 0 10
17251: PUSH
17252: LD_VAR 0 6
17256: PPUSH
17257: CALL_OW 311
17261: PPUSH
17262: LD_INT 3
17264: PPUSH
17265: CALL_OW 259
17269: PUSH
17270: LD_INT 4
17272: MUL
17273: MUL
17274: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
17275: LD_VAR 0 6
17279: PPUSH
17280: CALL_OW 263
17284: PUSH
17285: LD_INT 2
17287: EQUAL
17288: IFFALSE 17339
// begin j := IsControledBy ( i ) ;
17290: LD_ADDR_VAR 0 7
17294: PUSH
17295: LD_VAR 0 6
17299: PPUSH
17300: CALL_OW 312
17304: ST_TO_ADDR
// if j then
17305: LD_VAR 0 7
17309: IFFALSE 17339
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
17311: LD_ADDR_VAR 0 10
17315: PUSH
17316: LD_VAR 0 10
17320: PUSH
17321: LD_VAR 0 7
17325: PPUSH
17326: LD_INT 3
17328: PPUSH
17329: CALL_OW 259
17333: PUSH
17334: LD_INT 3
17336: MUL
17337: MUL
17338: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
17339: LD_VAR 0 6
17343: PPUSH
17344: CALL_OW 264
17348: PUSH
17349: LD_INT 5
17351: PUSH
17352: LD_INT 6
17354: PUSH
17355: LD_INT 46
17357: PUSH
17358: LD_INT 44
17360: PUSH
17361: LD_INT 47
17363: PUSH
17364: LD_INT 45
17366: PUSH
17367: LD_INT 28
17369: PUSH
17370: LD_INT 7
17372: PUSH
17373: LD_INT 27
17375: PUSH
17376: LD_INT 29
17378: PUSH
17379: EMPTY
17380: LIST
17381: LIST
17382: LIST
17383: LIST
17384: LIST
17385: LIST
17386: LIST
17387: LIST
17388: LIST
17389: LIST
17390: IN
17391: PUSH
17392: LD_VAR 0 1
17396: PPUSH
17397: LD_INT 52
17399: PPUSH
17400: CALL_OW 321
17404: PUSH
17405: LD_INT 2
17407: EQUAL
17408: AND
17409: IFFALSE 17426
// bpoints := bpoints * 1.2 ;
17411: LD_ADDR_VAR 0 10
17415: PUSH
17416: LD_VAR 0 10
17420: PUSH
17421: LD_REAL  1.20000000000000E+0000
17424: MUL
17425: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
17426: LD_VAR 0 6
17430: PPUSH
17431: CALL_OW 264
17435: PUSH
17436: LD_INT 6
17438: PUSH
17439: LD_INT 46
17441: PUSH
17442: LD_INT 47
17444: PUSH
17445: EMPTY
17446: LIST
17447: LIST
17448: LIST
17449: IN
17450: IFFALSE 17467
// bpoints := bpoints * 1.2 ;
17452: LD_ADDR_VAR 0 10
17456: PUSH
17457: LD_VAR 0 10
17461: PUSH
17462: LD_REAL  1.20000000000000E+0000
17465: MUL
17466: ST_TO_ADDR
// end ; unit_building :
17467: GO 17481
17469: LD_INT 3
17471: DOUBLE
17472: EQUAL
17473: IFTRUE 17477
17475: GO 17480
17477: POP
// ; end ;
17478: GO 17481
17480: POP
// for j = 1 to 3 do
17481: LD_ADDR_VAR 0 7
17485: PUSH
17486: DOUBLE
17487: LD_INT 1
17489: DEC
17490: ST_TO_ADDR
17491: LD_INT 3
17493: PUSH
17494: FOR_TO
17495: IFFALSE 17548
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
17497: LD_ADDR_VAR 0 5
17501: PUSH
17502: LD_VAR 0 5
17506: PPUSH
17507: LD_VAR 0 7
17511: PPUSH
17512: LD_VAR 0 5
17516: PUSH
17517: LD_VAR 0 7
17521: ARRAY
17522: PUSH
17523: LD_VAR 0 9
17527: PUSH
17528: LD_VAR 0 7
17532: ARRAY
17533: PUSH
17534: LD_VAR 0 10
17538: MUL
17539: PLUS
17540: PPUSH
17541: CALL_OW 1
17545: ST_TO_ADDR
17546: GO 17494
17548: POP
17549: POP
// end ;
17550: GO 16027
17552: POP
17553: POP
// result := Replace ( result , 4 , tmp ) ;
17554: LD_ADDR_VAR 0 5
17558: PUSH
17559: LD_VAR 0 5
17563: PPUSH
17564: LD_INT 4
17566: PPUSH
17567: LD_VAR 0 8
17571: PPUSH
17572: CALL_OW 1
17576: ST_TO_ADDR
// end ;
17577: LD_VAR 0 5
17581: RET
// export function DangerAtRange ( unit , range ) ; begin
17582: LD_INT 0
17584: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
17585: LD_ADDR_VAR 0 3
17589: PUSH
17590: LD_VAR 0 1
17594: PPUSH
17595: CALL_OW 255
17599: PPUSH
17600: LD_VAR 0 1
17604: PPUSH
17605: CALL_OW 250
17609: PPUSH
17610: LD_VAR 0 1
17614: PPUSH
17615: CALL_OW 251
17619: PPUSH
17620: LD_VAR 0 2
17624: PPUSH
17625: CALL 15879 0 4
17629: ST_TO_ADDR
// end ;
17630: LD_VAR 0 3
17634: RET
// export function DangerInArea ( side , area ) ; begin
17635: LD_INT 0
17637: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
17638: LD_ADDR_VAR 0 3
17642: PUSH
17643: LD_VAR 0 2
17647: PPUSH
17648: LD_INT 81
17650: PUSH
17651: LD_VAR 0 1
17655: PUSH
17656: EMPTY
17657: LIST
17658: LIST
17659: PPUSH
17660: CALL_OW 70
17664: ST_TO_ADDR
// end ;
17665: LD_VAR 0 3
17669: RET
// export function IsExtension ( b ) ; begin
17670: LD_INT 0
17672: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
17673: LD_ADDR_VAR 0 2
17677: PUSH
17678: LD_VAR 0 1
17682: PUSH
17683: LD_INT 23
17685: PUSH
17686: LD_INT 20
17688: PUSH
17689: LD_INT 22
17691: PUSH
17692: LD_INT 17
17694: PUSH
17695: LD_INT 24
17697: PUSH
17698: LD_INT 21
17700: PUSH
17701: LD_INT 19
17703: PUSH
17704: LD_INT 16
17706: PUSH
17707: LD_INT 25
17709: PUSH
17710: LD_INT 18
17712: PUSH
17713: EMPTY
17714: LIST
17715: LIST
17716: LIST
17717: LIST
17718: LIST
17719: LIST
17720: LIST
17721: LIST
17722: LIST
17723: LIST
17724: IN
17725: ST_TO_ADDR
// end ;
17726: LD_VAR 0 2
17730: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
17731: LD_INT 0
17733: PPUSH
17734: PPUSH
17735: PPUSH
// result := [ ] ;
17736: LD_ADDR_VAR 0 4
17740: PUSH
17741: EMPTY
17742: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
17743: LD_ADDR_VAR 0 5
17747: PUSH
17748: LD_VAR 0 2
17752: PPUSH
17753: LD_INT 21
17755: PUSH
17756: LD_INT 3
17758: PUSH
17759: EMPTY
17760: LIST
17761: LIST
17762: PPUSH
17763: CALL_OW 70
17767: ST_TO_ADDR
// if not tmp then
17768: LD_VAR 0 5
17772: NOT
17773: IFFALSE 17777
// exit ;
17775: GO 17841
// if checkLink then
17777: LD_VAR 0 3
17781: IFFALSE 17831
// begin for i in tmp do
17783: LD_ADDR_VAR 0 6
17787: PUSH
17788: LD_VAR 0 5
17792: PUSH
17793: FOR_IN
17794: IFFALSE 17829
// if GetBase ( i ) <> base then
17796: LD_VAR 0 6
17800: PPUSH
17801: CALL_OW 274
17805: PUSH
17806: LD_VAR 0 1
17810: NONEQUAL
17811: IFFALSE 17827
// ComLinkToBase ( base , i ) ;
17813: LD_VAR 0 1
17817: PPUSH
17818: LD_VAR 0 6
17822: PPUSH
17823: CALL_OW 169
17827: GO 17793
17829: POP
17830: POP
// end ; result := tmp ;
17831: LD_ADDR_VAR 0 4
17835: PUSH
17836: LD_VAR 0 5
17840: ST_TO_ADDR
// end ;
17841: LD_VAR 0 4
17845: RET
// export function ComComplete ( units , b ) ; var i ; begin
17846: LD_INT 0
17848: PPUSH
17849: PPUSH
// if not units then
17850: LD_VAR 0 1
17854: NOT
17855: IFFALSE 17859
// exit ;
17857: GO 17949
// for i in units do
17859: LD_ADDR_VAR 0 4
17863: PUSH
17864: LD_VAR 0 1
17868: PUSH
17869: FOR_IN
17870: IFFALSE 17947
// if BuildingStatus ( b ) = bs_build then
17872: LD_VAR 0 2
17876: PPUSH
17877: CALL_OW 461
17881: PUSH
17882: LD_INT 1
17884: EQUAL
17885: IFFALSE 17945
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
17887: LD_VAR 0 4
17891: PPUSH
17892: LD_STRING h
17894: PUSH
17895: LD_VAR 0 2
17899: PPUSH
17900: CALL_OW 250
17904: PUSH
17905: LD_VAR 0 2
17909: PPUSH
17910: CALL_OW 251
17914: PUSH
17915: LD_VAR 0 2
17919: PUSH
17920: LD_INT 0
17922: PUSH
17923: LD_INT 0
17925: PUSH
17926: LD_INT 0
17928: PUSH
17929: EMPTY
17930: LIST
17931: LIST
17932: LIST
17933: LIST
17934: LIST
17935: LIST
17936: LIST
17937: PUSH
17938: EMPTY
17939: LIST
17940: PPUSH
17941: CALL_OW 446
17945: GO 17869
17947: POP
17948: POP
// end ;
17949: LD_VAR 0 3
17953: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
17954: LD_INT 0
17956: PPUSH
17957: PPUSH
17958: PPUSH
17959: PPUSH
17960: PPUSH
17961: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
17962: LD_VAR 0 1
17966: NOT
17967: PUSH
17968: LD_VAR 0 1
17972: PPUSH
17973: CALL_OW 263
17977: PUSH
17978: LD_INT 2
17980: EQUAL
17981: NOT
17982: OR
17983: IFFALSE 17987
// exit ;
17985: GO 18303
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
17987: LD_ADDR_VAR 0 6
17991: PUSH
17992: LD_INT 22
17994: PUSH
17995: LD_VAR 0 1
17999: PPUSH
18000: CALL_OW 255
18004: PUSH
18005: EMPTY
18006: LIST
18007: LIST
18008: PUSH
18009: LD_INT 2
18011: PUSH
18012: LD_INT 30
18014: PUSH
18015: LD_INT 36
18017: PUSH
18018: EMPTY
18019: LIST
18020: LIST
18021: PUSH
18022: LD_INT 34
18024: PUSH
18025: LD_INT 31
18027: PUSH
18028: EMPTY
18029: LIST
18030: LIST
18031: PUSH
18032: EMPTY
18033: LIST
18034: LIST
18035: LIST
18036: PUSH
18037: EMPTY
18038: LIST
18039: LIST
18040: PPUSH
18041: CALL_OW 69
18045: ST_TO_ADDR
// if not tmp then
18046: LD_VAR 0 6
18050: NOT
18051: IFFALSE 18055
// exit ;
18053: GO 18303
// result := [ ] ;
18055: LD_ADDR_VAR 0 2
18059: PUSH
18060: EMPTY
18061: ST_TO_ADDR
// for i in tmp do
18062: LD_ADDR_VAR 0 3
18066: PUSH
18067: LD_VAR 0 6
18071: PUSH
18072: FOR_IN
18073: IFFALSE 18144
// begin t := UnitsInside ( i ) ;
18075: LD_ADDR_VAR 0 4
18079: PUSH
18080: LD_VAR 0 3
18084: PPUSH
18085: CALL_OW 313
18089: ST_TO_ADDR
// if t then
18090: LD_VAR 0 4
18094: IFFALSE 18142
// for j in t do
18096: LD_ADDR_VAR 0 7
18100: PUSH
18101: LD_VAR 0 4
18105: PUSH
18106: FOR_IN
18107: IFFALSE 18140
// result := Insert ( result , result + 1 , j ) ;
18109: LD_ADDR_VAR 0 2
18113: PUSH
18114: LD_VAR 0 2
18118: PPUSH
18119: LD_VAR 0 2
18123: PUSH
18124: LD_INT 1
18126: PLUS
18127: PPUSH
18128: LD_VAR 0 7
18132: PPUSH
18133: CALL_OW 2
18137: ST_TO_ADDR
18138: GO 18106
18140: POP
18141: POP
// end ;
18142: GO 18072
18144: POP
18145: POP
// if not result then
18146: LD_VAR 0 2
18150: NOT
18151: IFFALSE 18155
// exit ;
18153: GO 18303
// mech := result [ 1 ] ;
18155: LD_ADDR_VAR 0 5
18159: PUSH
18160: LD_VAR 0 2
18164: PUSH
18165: LD_INT 1
18167: ARRAY
18168: ST_TO_ADDR
// if result > 1 then
18169: LD_VAR 0 2
18173: PUSH
18174: LD_INT 1
18176: GREATER
18177: IFFALSE 18289
// for i = 2 to result do
18179: LD_ADDR_VAR 0 3
18183: PUSH
18184: DOUBLE
18185: LD_INT 2
18187: DEC
18188: ST_TO_ADDR
18189: LD_VAR 0 2
18193: PUSH
18194: FOR_TO
18195: IFFALSE 18287
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
18197: LD_ADDR_VAR 0 4
18201: PUSH
18202: LD_VAR 0 2
18206: PUSH
18207: LD_VAR 0 3
18211: ARRAY
18212: PPUSH
18213: LD_INT 3
18215: PPUSH
18216: CALL_OW 259
18220: PUSH
18221: LD_VAR 0 2
18225: PUSH
18226: LD_VAR 0 3
18230: ARRAY
18231: PPUSH
18232: CALL_OW 432
18236: MINUS
18237: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
18238: LD_VAR 0 4
18242: PUSH
18243: LD_VAR 0 5
18247: PPUSH
18248: LD_INT 3
18250: PPUSH
18251: CALL_OW 259
18255: PUSH
18256: LD_VAR 0 5
18260: PPUSH
18261: CALL_OW 432
18265: MINUS
18266: GREATEREQUAL
18267: IFFALSE 18285
// mech := result [ i ] ;
18269: LD_ADDR_VAR 0 5
18273: PUSH
18274: LD_VAR 0 2
18278: PUSH
18279: LD_VAR 0 3
18283: ARRAY
18284: ST_TO_ADDR
// end ;
18285: GO 18194
18287: POP
18288: POP
// ComLinkTo ( vehicle , mech ) ;
18289: LD_VAR 0 1
18293: PPUSH
18294: LD_VAR 0 5
18298: PPUSH
18299: CALL_OW 135
// end ;
18303: LD_VAR 0 2
18307: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
18308: LD_INT 0
18310: PPUSH
18311: PPUSH
18312: PPUSH
18313: PPUSH
18314: PPUSH
18315: PPUSH
18316: PPUSH
18317: PPUSH
18318: PPUSH
18319: PPUSH
18320: PPUSH
18321: PPUSH
18322: PPUSH
// result := [ ] ;
18323: LD_ADDR_VAR 0 7
18327: PUSH
18328: EMPTY
18329: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
18330: LD_VAR 0 1
18334: PPUSH
18335: CALL_OW 266
18339: PUSH
18340: LD_INT 0
18342: PUSH
18343: LD_INT 1
18345: PUSH
18346: EMPTY
18347: LIST
18348: LIST
18349: IN
18350: NOT
18351: IFFALSE 18355
// exit ;
18353: GO 19989
// if name then
18355: LD_VAR 0 3
18359: IFFALSE 18375
// SetBName ( base_dep , name ) ;
18361: LD_VAR 0 1
18365: PPUSH
18366: LD_VAR 0 3
18370: PPUSH
18371: CALL_OW 500
// base := GetBase ( base_dep ) ;
18375: LD_ADDR_VAR 0 15
18379: PUSH
18380: LD_VAR 0 1
18384: PPUSH
18385: CALL_OW 274
18389: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
18390: LD_ADDR_VAR 0 16
18394: PUSH
18395: LD_VAR 0 1
18399: PPUSH
18400: CALL_OW 255
18404: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
18405: LD_ADDR_VAR 0 17
18409: PUSH
18410: LD_VAR 0 1
18414: PPUSH
18415: CALL_OW 248
18419: ST_TO_ADDR
// if sources then
18420: LD_VAR 0 5
18424: IFFALSE 18471
// for i = 1 to 3 do
18426: LD_ADDR_VAR 0 8
18430: PUSH
18431: DOUBLE
18432: LD_INT 1
18434: DEC
18435: ST_TO_ADDR
18436: LD_INT 3
18438: PUSH
18439: FOR_TO
18440: IFFALSE 18469
// AddResourceType ( base , i , sources [ i ] ) ;
18442: LD_VAR 0 15
18446: PPUSH
18447: LD_VAR 0 8
18451: PPUSH
18452: LD_VAR 0 5
18456: PUSH
18457: LD_VAR 0 8
18461: ARRAY
18462: PPUSH
18463: CALL_OW 276
18467: GO 18439
18469: POP
18470: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
18471: LD_ADDR_VAR 0 18
18475: PUSH
18476: LD_VAR 0 15
18480: PPUSH
18481: LD_VAR 0 2
18485: PPUSH
18486: LD_INT 1
18488: PPUSH
18489: CALL 17731 0 3
18493: ST_TO_ADDR
// InitHc ;
18494: CALL_OW 19
// InitUc ;
18498: CALL_OW 18
// uc_side := side ;
18502: LD_ADDR_OWVAR 20
18506: PUSH
18507: LD_VAR 0 16
18511: ST_TO_ADDR
// uc_nation := nation ;
18512: LD_ADDR_OWVAR 21
18516: PUSH
18517: LD_VAR 0 17
18521: ST_TO_ADDR
// if buildings then
18522: LD_VAR 0 18
18526: IFFALSE 19848
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
18528: LD_ADDR_VAR 0 19
18532: PUSH
18533: LD_VAR 0 18
18537: PPUSH
18538: LD_INT 2
18540: PUSH
18541: LD_INT 30
18543: PUSH
18544: LD_INT 29
18546: PUSH
18547: EMPTY
18548: LIST
18549: LIST
18550: PUSH
18551: LD_INT 30
18553: PUSH
18554: LD_INT 30
18556: PUSH
18557: EMPTY
18558: LIST
18559: LIST
18560: PUSH
18561: EMPTY
18562: LIST
18563: LIST
18564: LIST
18565: PPUSH
18566: CALL_OW 72
18570: ST_TO_ADDR
// if tmp then
18571: LD_VAR 0 19
18575: IFFALSE 18623
// for i in tmp do
18577: LD_ADDR_VAR 0 8
18581: PUSH
18582: LD_VAR 0 19
18586: PUSH
18587: FOR_IN
18588: IFFALSE 18621
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
18590: LD_VAR 0 8
18594: PPUSH
18595: CALL_OW 250
18599: PPUSH
18600: LD_VAR 0 8
18604: PPUSH
18605: CALL_OW 251
18609: PPUSH
18610: LD_VAR 0 16
18614: PPUSH
18615: CALL_OW 441
18619: GO 18587
18621: POP
18622: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
18623: LD_VAR 0 18
18627: PPUSH
18628: LD_INT 2
18630: PUSH
18631: LD_INT 30
18633: PUSH
18634: LD_INT 32
18636: PUSH
18637: EMPTY
18638: LIST
18639: LIST
18640: PUSH
18641: LD_INT 30
18643: PUSH
18644: LD_INT 33
18646: PUSH
18647: EMPTY
18648: LIST
18649: LIST
18650: PUSH
18651: EMPTY
18652: LIST
18653: LIST
18654: LIST
18655: PPUSH
18656: CALL_OW 72
18660: IFFALSE 18748
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
18662: LD_ADDR_VAR 0 8
18666: PUSH
18667: LD_VAR 0 18
18671: PPUSH
18672: LD_INT 2
18674: PUSH
18675: LD_INT 30
18677: PUSH
18678: LD_INT 32
18680: PUSH
18681: EMPTY
18682: LIST
18683: LIST
18684: PUSH
18685: LD_INT 30
18687: PUSH
18688: LD_INT 33
18690: PUSH
18691: EMPTY
18692: LIST
18693: LIST
18694: PUSH
18695: EMPTY
18696: LIST
18697: LIST
18698: LIST
18699: PPUSH
18700: CALL_OW 72
18704: PUSH
18705: FOR_IN
18706: IFFALSE 18746
// begin if not GetBWeapon ( i ) then
18708: LD_VAR 0 8
18712: PPUSH
18713: CALL_OW 269
18717: NOT
18718: IFFALSE 18744
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
18720: LD_VAR 0 8
18724: PPUSH
18725: LD_VAR 0 8
18729: PPUSH
18730: LD_VAR 0 2
18734: PPUSH
18735: CALL 19994 0 2
18739: PPUSH
18740: CALL_OW 431
// end ;
18744: GO 18705
18746: POP
18747: POP
// end ; for i = 1 to personel do
18748: LD_ADDR_VAR 0 8
18752: PUSH
18753: DOUBLE
18754: LD_INT 1
18756: DEC
18757: ST_TO_ADDR
18758: LD_VAR 0 6
18762: PUSH
18763: FOR_TO
18764: IFFALSE 19828
// begin if i > 4 then
18766: LD_VAR 0 8
18770: PUSH
18771: LD_INT 4
18773: GREATER
18774: IFFALSE 18778
// break ;
18776: GO 19828
// case i of 1 :
18778: LD_VAR 0 8
18782: PUSH
18783: LD_INT 1
18785: DOUBLE
18786: EQUAL
18787: IFTRUE 18791
18789: GO 18871
18791: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
18792: LD_ADDR_VAR 0 12
18796: PUSH
18797: LD_VAR 0 18
18801: PPUSH
18802: LD_INT 22
18804: PUSH
18805: LD_VAR 0 16
18809: PUSH
18810: EMPTY
18811: LIST
18812: LIST
18813: PUSH
18814: LD_INT 58
18816: PUSH
18817: EMPTY
18818: LIST
18819: PUSH
18820: LD_INT 2
18822: PUSH
18823: LD_INT 30
18825: PUSH
18826: LD_INT 32
18828: PUSH
18829: EMPTY
18830: LIST
18831: LIST
18832: PUSH
18833: LD_INT 30
18835: PUSH
18836: LD_INT 4
18838: PUSH
18839: EMPTY
18840: LIST
18841: LIST
18842: PUSH
18843: LD_INT 30
18845: PUSH
18846: LD_INT 5
18848: PUSH
18849: EMPTY
18850: LIST
18851: LIST
18852: PUSH
18853: EMPTY
18854: LIST
18855: LIST
18856: LIST
18857: LIST
18858: PUSH
18859: EMPTY
18860: LIST
18861: LIST
18862: LIST
18863: PPUSH
18864: CALL_OW 72
18868: ST_TO_ADDR
18869: GO 19093
18871: LD_INT 2
18873: DOUBLE
18874: EQUAL
18875: IFTRUE 18879
18877: GO 18941
18879: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
18880: LD_ADDR_VAR 0 12
18884: PUSH
18885: LD_VAR 0 18
18889: PPUSH
18890: LD_INT 22
18892: PUSH
18893: LD_VAR 0 16
18897: PUSH
18898: EMPTY
18899: LIST
18900: LIST
18901: PUSH
18902: LD_INT 2
18904: PUSH
18905: LD_INT 30
18907: PUSH
18908: LD_INT 0
18910: PUSH
18911: EMPTY
18912: LIST
18913: LIST
18914: PUSH
18915: LD_INT 30
18917: PUSH
18918: LD_INT 1
18920: PUSH
18921: EMPTY
18922: LIST
18923: LIST
18924: PUSH
18925: EMPTY
18926: LIST
18927: LIST
18928: LIST
18929: PUSH
18930: EMPTY
18931: LIST
18932: LIST
18933: PPUSH
18934: CALL_OW 72
18938: ST_TO_ADDR
18939: GO 19093
18941: LD_INT 3
18943: DOUBLE
18944: EQUAL
18945: IFTRUE 18949
18947: GO 19011
18949: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
18950: LD_ADDR_VAR 0 12
18954: PUSH
18955: LD_VAR 0 18
18959: PPUSH
18960: LD_INT 22
18962: PUSH
18963: LD_VAR 0 16
18967: PUSH
18968: EMPTY
18969: LIST
18970: LIST
18971: PUSH
18972: LD_INT 2
18974: PUSH
18975: LD_INT 30
18977: PUSH
18978: LD_INT 2
18980: PUSH
18981: EMPTY
18982: LIST
18983: LIST
18984: PUSH
18985: LD_INT 30
18987: PUSH
18988: LD_INT 3
18990: PUSH
18991: EMPTY
18992: LIST
18993: LIST
18994: PUSH
18995: EMPTY
18996: LIST
18997: LIST
18998: LIST
18999: PUSH
19000: EMPTY
19001: LIST
19002: LIST
19003: PPUSH
19004: CALL_OW 72
19008: ST_TO_ADDR
19009: GO 19093
19011: LD_INT 4
19013: DOUBLE
19014: EQUAL
19015: IFTRUE 19019
19017: GO 19092
19019: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
19020: LD_ADDR_VAR 0 12
19024: PUSH
19025: LD_VAR 0 18
19029: PPUSH
19030: LD_INT 22
19032: PUSH
19033: LD_VAR 0 16
19037: PUSH
19038: EMPTY
19039: LIST
19040: LIST
19041: PUSH
19042: LD_INT 2
19044: PUSH
19045: LD_INT 30
19047: PUSH
19048: LD_INT 6
19050: PUSH
19051: EMPTY
19052: LIST
19053: LIST
19054: PUSH
19055: LD_INT 30
19057: PUSH
19058: LD_INT 7
19060: PUSH
19061: EMPTY
19062: LIST
19063: LIST
19064: PUSH
19065: LD_INT 30
19067: PUSH
19068: LD_INT 8
19070: PUSH
19071: EMPTY
19072: LIST
19073: LIST
19074: PUSH
19075: EMPTY
19076: LIST
19077: LIST
19078: LIST
19079: LIST
19080: PUSH
19081: EMPTY
19082: LIST
19083: LIST
19084: PPUSH
19085: CALL_OW 72
19089: ST_TO_ADDR
19090: GO 19093
19092: POP
// if i = 1 then
19093: LD_VAR 0 8
19097: PUSH
19098: LD_INT 1
19100: EQUAL
19101: IFFALSE 19212
// begin tmp := [ ] ;
19103: LD_ADDR_VAR 0 19
19107: PUSH
19108: EMPTY
19109: ST_TO_ADDR
// for j in f do
19110: LD_ADDR_VAR 0 9
19114: PUSH
19115: LD_VAR 0 12
19119: PUSH
19120: FOR_IN
19121: IFFALSE 19194
// if GetBType ( j ) = b_bunker then
19123: LD_VAR 0 9
19127: PPUSH
19128: CALL_OW 266
19132: PUSH
19133: LD_INT 32
19135: EQUAL
19136: IFFALSE 19163
// tmp := Insert ( tmp , 1 , j ) else
19138: LD_ADDR_VAR 0 19
19142: PUSH
19143: LD_VAR 0 19
19147: PPUSH
19148: LD_INT 1
19150: PPUSH
19151: LD_VAR 0 9
19155: PPUSH
19156: CALL_OW 2
19160: ST_TO_ADDR
19161: GO 19192
// tmp := Insert ( tmp , tmp + 1 , j ) ;
19163: LD_ADDR_VAR 0 19
19167: PUSH
19168: LD_VAR 0 19
19172: PPUSH
19173: LD_VAR 0 19
19177: PUSH
19178: LD_INT 1
19180: PLUS
19181: PPUSH
19182: LD_VAR 0 9
19186: PPUSH
19187: CALL_OW 2
19191: ST_TO_ADDR
19192: GO 19120
19194: POP
19195: POP
// if tmp then
19196: LD_VAR 0 19
19200: IFFALSE 19212
// f := tmp ;
19202: LD_ADDR_VAR 0 12
19206: PUSH
19207: LD_VAR 0 19
19211: ST_TO_ADDR
// end ; x := personel [ i ] ;
19212: LD_ADDR_VAR 0 13
19216: PUSH
19217: LD_VAR 0 6
19221: PUSH
19222: LD_VAR 0 8
19226: ARRAY
19227: ST_TO_ADDR
// if x = - 1 then
19228: LD_VAR 0 13
19232: PUSH
19233: LD_INT 1
19235: NEG
19236: EQUAL
19237: IFFALSE 19446
// begin for j in f do
19239: LD_ADDR_VAR 0 9
19243: PUSH
19244: LD_VAR 0 12
19248: PUSH
19249: FOR_IN
19250: IFFALSE 19442
// repeat InitHc ;
19252: CALL_OW 19
// if GetBType ( j ) = b_barracks then
19256: LD_VAR 0 9
19260: PPUSH
19261: CALL_OW 266
19265: PUSH
19266: LD_INT 5
19268: EQUAL
19269: IFFALSE 19339
// begin if UnitsInside ( j ) < 3 then
19271: LD_VAR 0 9
19275: PPUSH
19276: CALL_OW 313
19280: PUSH
19281: LD_INT 3
19283: LESS
19284: IFFALSE 19320
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
19286: LD_INT 0
19288: PPUSH
19289: LD_INT 5
19291: PUSH
19292: LD_INT 8
19294: PUSH
19295: LD_INT 9
19297: PUSH
19298: EMPTY
19299: LIST
19300: LIST
19301: LIST
19302: PUSH
19303: LD_VAR 0 17
19307: ARRAY
19308: PPUSH
19309: LD_VAR 0 4
19313: PPUSH
19314: CALL_OW 380
19318: GO 19337
// PrepareHuman ( false , i , skill ) ;
19320: LD_INT 0
19322: PPUSH
19323: LD_VAR 0 8
19327: PPUSH
19328: LD_VAR 0 4
19332: PPUSH
19333: CALL_OW 380
// end else
19337: GO 19356
// PrepareHuman ( false , i , skill ) ;
19339: LD_INT 0
19341: PPUSH
19342: LD_VAR 0 8
19346: PPUSH
19347: LD_VAR 0 4
19351: PPUSH
19352: CALL_OW 380
// un := CreateHuman ;
19356: LD_ADDR_VAR 0 14
19360: PUSH
19361: CALL_OW 44
19365: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19366: LD_ADDR_VAR 0 7
19370: PUSH
19371: LD_VAR 0 7
19375: PPUSH
19376: LD_INT 1
19378: PPUSH
19379: LD_VAR 0 14
19383: PPUSH
19384: CALL_OW 2
19388: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
19389: LD_VAR 0 14
19393: PPUSH
19394: LD_VAR 0 9
19398: PPUSH
19399: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
19403: LD_VAR 0 9
19407: PPUSH
19408: CALL_OW 313
19412: PUSH
19413: LD_INT 6
19415: EQUAL
19416: PUSH
19417: LD_VAR 0 9
19421: PPUSH
19422: CALL_OW 266
19426: PUSH
19427: LD_INT 32
19429: PUSH
19430: LD_INT 31
19432: PUSH
19433: EMPTY
19434: LIST
19435: LIST
19436: IN
19437: OR
19438: IFFALSE 19252
19440: GO 19249
19442: POP
19443: POP
// end else
19444: GO 19826
// for j = 1 to x do
19446: LD_ADDR_VAR 0 9
19450: PUSH
19451: DOUBLE
19452: LD_INT 1
19454: DEC
19455: ST_TO_ADDR
19456: LD_VAR 0 13
19460: PUSH
19461: FOR_TO
19462: IFFALSE 19824
// begin InitHc ;
19464: CALL_OW 19
// if not f then
19468: LD_VAR 0 12
19472: NOT
19473: IFFALSE 19562
// begin PrepareHuman ( false , i , skill ) ;
19475: LD_INT 0
19477: PPUSH
19478: LD_VAR 0 8
19482: PPUSH
19483: LD_VAR 0 4
19487: PPUSH
19488: CALL_OW 380
// un := CreateHuman ;
19492: LD_ADDR_VAR 0 14
19496: PUSH
19497: CALL_OW 44
19501: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19502: LD_ADDR_VAR 0 7
19506: PUSH
19507: LD_VAR 0 7
19511: PPUSH
19512: LD_INT 1
19514: PPUSH
19515: LD_VAR 0 14
19519: PPUSH
19520: CALL_OW 2
19524: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
19525: LD_VAR 0 14
19529: PPUSH
19530: LD_VAR 0 1
19534: PPUSH
19535: CALL_OW 250
19539: PPUSH
19540: LD_VAR 0 1
19544: PPUSH
19545: CALL_OW 251
19549: PPUSH
19550: LD_INT 10
19552: PPUSH
19553: LD_INT 0
19555: PPUSH
19556: CALL_OW 50
// continue ;
19560: GO 19461
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
19562: LD_VAR 0 12
19566: PUSH
19567: LD_INT 1
19569: ARRAY
19570: PPUSH
19571: CALL_OW 313
19575: PUSH
19576: LD_VAR 0 12
19580: PUSH
19581: LD_INT 1
19583: ARRAY
19584: PPUSH
19585: CALL_OW 266
19589: PUSH
19590: LD_INT 32
19592: PUSH
19593: LD_INT 31
19595: PUSH
19596: EMPTY
19597: LIST
19598: LIST
19599: IN
19600: AND
19601: PUSH
19602: LD_VAR 0 12
19606: PUSH
19607: LD_INT 1
19609: ARRAY
19610: PPUSH
19611: CALL_OW 313
19615: PUSH
19616: LD_INT 6
19618: EQUAL
19619: OR
19620: IFFALSE 19640
// f := Delete ( f , 1 ) ;
19622: LD_ADDR_VAR 0 12
19626: PUSH
19627: LD_VAR 0 12
19631: PPUSH
19632: LD_INT 1
19634: PPUSH
19635: CALL_OW 3
19639: ST_TO_ADDR
// if not f then
19640: LD_VAR 0 12
19644: NOT
19645: IFFALSE 19663
// begin x := x + 2 ;
19647: LD_ADDR_VAR 0 13
19651: PUSH
19652: LD_VAR 0 13
19656: PUSH
19657: LD_INT 2
19659: PLUS
19660: ST_TO_ADDR
// continue ;
19661: GO 19461
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
19663: LD_VAR 0 12
19667: PUSH
19668: LD_INT 1
19670: ARRAY
19671: PPUSH
19672: CALL_OW 266
19676: PUSH
19677: LD_INT 5
19679: EQUAL
19680: IFFALSE 19754
// begin if UnitsInside ( f [ 1 ] ) < 3 then
19682: LD_VAR 0 12
19686: PUSH
19687: LD_INT 1
19689: ARRAY
19690: PPUSH
19691: CALL_OW 313
19695: PUSH
19696: LD_INT 3
19698: LESS
19699: IFFALSE 19735
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
19701: LD_INT 0
19703: PPUSH
19704: LD_INT 5
19706: PUSH
19707: LD_INT 8
19709: PUSH
19710: LD_INT 9
19712: PUSH
19713: EMPTY
19714: LIST
19715: LIST
19716: LIST
19717: PUSH
19718: LD_VAR 0 17
19722: ARRAY
19723: PPUSH
19724: LD_VAR 0 4
19728: PPUSH
19729: CALL_OW 380
19733: GO 19752
// PrepareHuman ( false , i , skill ) ;
19735: LD_INT 0
19737: PPUSH
19738: LD_VAR 0 8
19742: PPUSH
19743: LD_VAR 0 4
19747: PPUSH
19748: CALL_OW 380
// end else
19752: GO 19771
// PrepareHuman ( false , i , skill ) ;
19754: LD_INT 0
19756: PPUSH
19757: LD_VAR 0 8
19761: PPUSH
19762: LD_VAR 0 4
19766: PPUSH
19767: CALL_OW 380
// un := CreateHuman ;
19771: LD_ADDR_VAR 0 14
19775: PUSH
19776: CALL_OW 44
19780: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19781: LD_ADDR_VAR 0 7
19785: PUSH
19786: LD_VAR 0 7
19790: PPUSH
19791: LD_INT 1
19793: PPUSH
19794: LD_VAR 0 14
19798: PPUSH
19799: CALL_OW 2
19803: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
19804: LD_VAR 0 14
19808: PPUSH
19809: LD_VAR 0 12
19813: PUSH
19814: LD_INT 1
19816: ARRAY
19817: PPUSH
19818: CALL_OW 52
// end ;
19822: GO 19461
19824: POP
19825: POP
// end ;
19826: GO 18763
19828: POP
19829: POP
// result := result ^ buildings ;
19830: LD_ADDR_VAR 0 7
19834: PUSH
19835: LD_VAR 0 7
19839: PUSH
19840: LD_VAR 0 18
19844: ADD
19845: ST_TO_ADDR
// end else
19846: GO 19989
// begin for i = 1 to personel do
19848: LD_ADDR_VAR 0 8
19852: PUSH
19853: DOUBLE
19854: LD_INT 1
19856: DEC
19857: ST_TO_ADDR
19858: LD_VAR 0 6
19862: PUSH
19863: FOR_TO
19864: IFFALSE 19987
// begin if i > 4 then
19866: LD_VAR 0 8
19870: PUSH
19871: LD_INT 4
19873: GREATER
19874: IFFALSE 19878
// break ;
19876: GO 19987
// x := personel [ i ] ;
19878: LD_ADDR_VAR 0 13
19882: PUSH
19883: LD_VAR 0 6
19887: PUSH
19888: LD_VAR 0 8
19892: ARRAY
19893: ST_TO_ADDR
// if x = - 1 then
19894: LD_VAR 0 13
19898: PUSH
19899: LD_INT 1
19901: NEG
19902: EQUAL
19903: IFFALSE 19907
// continue ;
19905: GO 19863
// PrepareHuman ( false , i , skill ) ;
19907: LD_INT 0
19909: PPUSH
19910: LD_VAR 0 8
19914: PPUSH
19915: LD_VAR 0 4
19919: PPUSH
19920: CALL_OW 380
// un := CreateHuman ;
19924: LD_ADDR_VAR 0 14
19928: PUSH
19929: CALL_OW 44
19933: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
19934: LD_VAR 0 14
19938: PPUSH
19939: LD_VAR 0 1
19943: PPUSH
19944: CALL_OW 250
19948: PPUSH
19949: LD_VAR 0 1
19953: PPUSH
19954: CALL_OW 251
19958: PPUSH
19959: LD_INT 10
19961: PPUSH
19962: LD_INT 0
19964: PPUSH
19965: CALL_OW 50
// result := result ^ un ;
19969: LD_ADDR_VAR 0 7
19973: PUSH
19974: LD_VAR 0 7
19978: PUSH
19979: LD_VAR 0 14
19983: ADD
19984: ST_TO_ADDR
// end ;
19985: GO 19863
19987: POP
19988: POP
// end ; end ;
19989: LD_VAR 0 7
19993: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
19994: LD_INT 0
19996: PPUSH
19997: PPUSH
19998: PPUSH
19999: PPUSH
20000: PPUSH
20001: PPUSH
20002: PPUSH
20003: PPUSH
20004: PPUSH
20005: PPUSH
20006: PPUSH
20007: PPUSH
20008: PPUSH
20009: PPUSH
20010: PPUSH
20011: PPUSH
// result := false ;
20012: LD_ADDR_VAR 0 3
20016: PUSH
20017: LD_INT 0
20019: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
20020: LD_VAR 0 1
20024: NOT
20025: PUSH
20026: LD_VAR 0 1
20030: PPUSH
20031: CALL_OW 266
20035: PUSH
20036: LD_INT 32
20038: PUSH
20039: LD_INT 33
20041: PUSH
20042: EMPTY
20043: LIST
20044: LIST
20045: IN
20046: NOT
20047: OR
20048: IFFALSE 20052
// exit ;
20050: GO 21161
// nat := GetNation ( tower ) ;
20052: LD_ADDR_VAR 0 12
20056: PUSH
20057: LD_VAR 0 1
20061: PPUSH
20062: CALL_OW 248
20066: ST_TO_ADDR
// side := GetSide ( tower ) ;
20067: LD_ADDR_VAR 0 16
20071: PUSH
20072: LD_VAR 0 1
20076: PPUSH
20077: CALL_OW 255
20081: ST_TO_ADDR
// x := GetX ( tower ) ;
20082: LD_ADDR_VAR 0 10
20086: PUSH
20087: LD_VAR 0 1
20091: PPUSH
20092: CALL_OW 250
20096: ST_TO_ADDR
// y := GetY ( tower ) ;
20097: LD_ADDR_VAR 0 11
20101: PUSH
20102: LD_VAR 0 1
20106: PPUSH
20107: CALL_OW 251
20111: ST_TO_ADDR
// if not x or not y then
20112: LD_VAR 0 10
20116: NOT
20117: PUSH
20118: LD_VAR 0 11
20122: NOT
20123: OR
20124: IFFALSE 20128
// exit ;
20126: GO 21161
// weapon := 0 ;
20128: LD_ADDR_VAR 0 18
20132: PUSH
20133: LD_INT 0
20135: ST_TO_ADDR
// fac_list := [ ] ;
20136: LD_ADDR_VAR 0 17
20140: PUSH
20141: EMPTY
20142: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
20143: LD_ADDR_VAR 0 6
20147: PUSH
20148: LD_VAR 0 1
20152: PPUSH
20153: CALL_OW 274
20157: PPUSH
20158: LD_VAR 0 2
20162: PPUSH
20163: LD_INT 0
20165: PPUSH
20166: CALL 17731 0 3
20170: PPUSH
20171: LD_INT 30
20173: PUSH
20174: LD_INT 3
20176: PUSH
20177: EMPTY
20178: LIST
20179: LIST
20180: PPUSH
20181: CALL_OW 72
20185: ST_TO_ADDR
// if not factories then
20186: LD_VAR 0 6
20190: NOT
20191: IFFALSE 20195
// exit ;
20193: GO 21161
// for i in factories do
20195: LD_ADDR_VAR 0 8
20199: PUSH
20200: LD_VAR 0 6
20204: PUSH
20205: FOR_IN
20206: IFFALSE 20231
// fac_list := fac_list union AvailableWeaponList ( i ) ;
20208: LD_ADDR_VAR 0 17
20212: PUSH
20213: LD_VAR 0 17
20217: PUSH
20218: LD_VAR 0 8
20222: PPUSH
20223: CALL_OW 478
20227: UNION
20228: ST_TO_ADDR
20229: GO 20205
20231: POP
20232: POP
// if not fac_list then
20233: LD_VAR 0 17
20237: NOT
20238: IFFALSE 20242
// exit ;
20240: GO 21161
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
20242: LD_ADDR_VAR 0 5
20246: PUSH
20247: LD_INT 4
20249: PUSH
20250: LD_INT 5
20252: PUSH
20253: LD_INT 9
20255: PUSH
20256: LD_INT 10
20258: PUSH
20259: LD_INT 6
20261: PUSH
20262: LD_INT 7
20264: PUSH
20265: LD_INT 11
20267: PUSH
20268: EMPTY
20269: LIST
20270: LIST
20271: LIST
20272: LIST
20273: LIST
20274: LIST
20275: LIST
20276: PUSH
20277: LD_INT 27
20279: PUSH
20280: LD_INT 28
20282: PUSH
20283: LD_INT 26
20285: PUSH
20286: LD_INT 30
20288: PUSH
20289: EMPTY
20290: LIST
20291: LIST
20292: LIST
20293: LIST
20294: PUSH
20295: LD_INT 43
20297: PUSH
20298: LD_INT 44
20300: PUSH
20301: LD_INT 46
20303: PUSH
20304: LD_INT 45
20306: PUSH
20307: LD_INT 47
20309: PUSH
20310: LD_INT 49
20312: PUSH
20313: EMPTY
20314: LIST
20315: LIST
20316: LIST
20317: LIST
20318: LIST
20319: LIST
20320: PUSH
20321: EMPTY
20322: LIST
20323: LIST
20324: LIST
20325: PUSH
20326: LD_VAR 0 12
20330: ARRAY
20331: ST_TO_ADDR
// list := list isect fac_list ;
20332: LD_ADDR_VAR 0 5
20336: PUSH
20337: LD_VAR 0 5
20341: PUSH
20342: LD_VAR 0 17
20346: ISECT
20347: ST_TO_ADDR
// if not list then
20348: LD_VAR 0 5
20352: NOT
20353: IFFALSE 20357
// exit ;
20355: GO 21161
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
20357: LD_VAR 0 12
20361: PUSH
20362: LD_INT 3
20364: EQUAL
20365: PUSH
20366: LD_INT 49
20368: PUSH
20369: LD_VAR 0 5
20373: IN
20374: AND
20375: PUSH
20376: LD_INT 31
20378: PPUSH
20379: LD_VAR 0 16
20383: PPUSH
20384: CALL_OW 321
20388: PUSH
20389: LD_INT 2
20391: EQUAL
20392: AND
20393: IFFALSE 20453
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
20395: LD_INT 22
20397: PUSH
20398: LD_VAR 0 16
20402: PUSH
20403: EMPTY
20404: LIST
20405: LIST
20406: PUSH
20407: LD_INT 35
20409: PUSH
20410: LD_INT 49
20412: PUSH
20413: EMPTY
20414: LIST
20415: LIST
20416: PUSH
20417: LD_INT 91
20419: PUSH
20420: LD_VAR 0 1
20424: PUSH
20425: LD_INT 10
20427: PUSH
20428: EMPTY
20429: LIST
20430: LIST
20431: LIST
20432: PUSH
20433: EMPTY
20434: LIST
20435: LIST
20436: LIST
20437: PPUSH
20438: CALL_OW 69
20442: NOT
20443: IFFALSE 20453
// weapon := ru_time_lapser ;
20445: LD_ADDR_VAR 0 18
20449: PUSH
20450: LD_INT 49
20452: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
20453: LD_VAR 0 12
20457: PUSH
20458: LD_INT 1
20460: PUSH
20461: LD_INT 2
20463: PUSH
20464: EMPTY
20465: LIST
20466: LIST
20467: IN
20468: PUSH
20469: LD_INT 11
20471: PUSH
20472: LD_VAR 0 5
20476: IN
20477: PUSH
20478: LD_INT 30
20480: PUSH
20481: LD_VAR 0 5
20485: IN
20486: OR
20487: AND
20488: PUSH
20489: LD_INT 6
20491: PPUSH
20492: LD_VAR 0 16
20496: PPUSH
20497: CALL_OW 321
20501: PUSH
20502: LD_INT 2
20504: EQUAL
20505: AND
20506: IFFALSE 20671
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
20508: LD_INT 22
20510: PUSH
20511: LD_VAR 0 16
20515: PUSH
20516: EMPTY
20517: LIST
20518: LIST
20519: PUSH
20520: LD_INT 2
20522: PUSH
20523: LD_INT 35
20525: PUSH
20526: LD_INT 11
20528: PUSH
20529: EMPTY
20530: LIST
20531: LIST
20532: PUSH
20533: LD_INT 35
20535: PUSH
20536: LD_INT 30
20538: PUSH
20539: EMPTY
20540: LIST
20541: LIST
20542: PUSH
20543: EMPTY
20544: LIST
20545: LIST
20546: LIST
20547: PUSH
20548: LD_INT 91
20550: PUSH
20551: LD_VAR 0 1
20555: PUSH
20556: LD_INT 18
20558: PUSH
20559: EMPTY
20560: LIST
20561: LIST
20562: LIST
20563: PUSH
20564: EMPTY
20565: LIST
20566: LIST
20567: LIST
20568: PPUSH
20569: CALL_OW 69
20573: NOT
20574: PUSH
20575: LD_INT 22
20577: PUSH
20578: LD_VAR 0 16
20582: PUSH
20583: EMPTY
20584: LIST
20585: LIST
20586: PUSH
20587: LD_INT 2
20589: PUSH
20590: LD_INT 30
20592: PUSH
20593: LD_INT 32
20595: PUSH
20596: EMPTY
20597: LIST
20598: LIST
20599: PUSH
20600: LD_INT 30
20602: PUSH
20603: LD_INT 33
20605: PUSH
20606: EMPTY
20607: LIST
20608: LIST
20609: PUSH
20610: EMPTY
20611: LIST
20612: LIST
20613: LIST
20614: PUSH
20615: LD_INT 91
20617: PUSH
20618: LD_VAR 0 1
20622: PUSH
20623: LD_INT 12
20625: PUSH
20626: EMPTY
20627: LIST
20628: LIST
20629: LIST
20630: PUSH
20631: EMPTY
20632: LIST
20633: LIST
20634: LIST
20635: PUSH
20636: EMPTY
20637: LIST
20638: PPUSH
20639: CALL_OW 69
20643: PUSH
20644: LD_INT 2
20646: GREATER
20647: AND
20648: IFFALSE 20671
// weapon := [ us_radar , ar_radar ] [ nat ] ;
20650: LD_ADDR_VAR 0 18
20654: PUSH
20655: LD_INT 11
20657: PUSH
20658: LD_INT 30
20660: PUSH
20661: EMPTY
20662: LIST
20663: LIST
20664: PUSH
20665: LD_VAR 0 12
20669: ARRAY
20670: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
20671: LD_VAR 0 18
20675: NOT
20676: PUSH
20677: LD_INT 40
20679: PPUSH
20680: LD_VAR 0 16
20684: PPUSH
20685: CALL_OW 321
20689: PUSH
20690: LD_INT 2
20692: EQUAL
20693: AND
20694: PUSH
20695: LD_INT 7
20697: PUSH
20698: LD_VAR 0 5
20702: IN
20703: PUSH
20704: LD_INT 28
20706: PUSH
20707: LD_VAR 0 5
20711: IN
20712: OR
20713: PUSH
20714: LD_INT 45
20716: PUSH
20717: LD_VAR 0 5
20721: IN
20722: OR
20723: AND
20724: IFFALSE 20978
// begin hex := GetHexInfo ( x , y ) ;
20726: LD_ADDR_VAR 0 4
20730: PUSH
20731: LD_VAR 0 10
20735: PPUSH
20736: LD_VAR 0 11
20740: PPUSH
20741: CALL_OW 546
20745: ST_TO_ADDR
// if hex [ 1 ] then
20746: LD_VAR 0 4
20750: PUSH
20751: LD_INT 1
20753: ARRAY
20754: IFFALSE 20758
// exit ;
20756: GO 21161
// height := hex [ 2 ] ;
20758: LD_ADDR_VAR 0 15
20762: PUSH
20763: LD_VAR 0 4
20767: PUSH
20768: LD_INT 2
20770: ARRAY
20771: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
20772: LD_ADDR_VAR 0 14
20776: PUSH
20777: LD_INT 0
20779: PUSH
20780: LD_INT 2
20782: PUSH
20783: LD_INT 3
20785: PUSH
20786: LD_INT 5
20788: PUSH
20789: EMPTY
20790: LIST
20791: LIST
20792: LIST
20793: LIST
20794: ST_TO_ADDR
// for i in tmp do
20795: LD_ADDR_VAR 0 8
20799: PUSH
20800: LD_VAR 0 14
20804: PUSH
20805: FOR_IN
20806: IFFALSE 20976
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
20808: LD_ADDR_VAR 0 9
20812: PUSH
20813: LD_VAR 0 10
20817: PPUSH
20818: LD_VAR 0 8
20822: PPUSH
20823: LD_INT 5
20825: PPUSH
20826: CALL_OW 272
20830: PUSH
20831: LD_VAR 0 11
20835: PPUSH
20836: LD_VAR 0 8
20840: PPUSH
20841: LD_INT 5
20843: PPUSH
20844: CALL_OW 273
20848: PUSH
20849: EMPTY
20850: LIST
20851: LIST
20852: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
20853: LD_VAR 0 9
20857: PUSH
20858: LD_INT 1
20860: ARRAY
20861: PPUSH
20862: LD_VAR 0 9
20866: PUSH
20867: LD_INT 2
20869: ARRAY
20870: PPUSH
20871: CALL_OW 488
20875: IFFALSE 20974
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
20877: LD_ADDR_VAR 0 4
20881: PUSH
20882: LD_VAR 0 9
20886: PUSH
20887: LD_INT 1
20889: ARRAY
20890: PPUSH
20891: LD_VAR 0 9
20895: PUSH
20896: LD_INT 2
20898: ARRAY
20899: PPUSH
20900: CALL_OW 546
20904: ST_TO_ADDR
// if hex [ 1 ] then
20905: LD_VAR 0 4
20909: PUSH
20910: LD_INT 1
20912: ARRAY
20913: IFFALSE 20917
// continue ;
20915: GO 20805
// h := hex [ 2 ] ;
20917: LD_ADDR_VAR 0 13
20921: PUSH
20922: LD_VAR 0 4
20926: PUSH
20927: LD_INT 2
20929: ARRAY
20930: ST_TO_ADDR
// if h + 7 < height then
20931: LD_VAR 0 13
20935: PUSH
20936: LD_INT 7
20938: PLUS
20939: PUSH
20940: LD_VAR 0 15
20944: LESS
20945: IFFALSE 20974
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
20947: LD_ADDR_VAR 0 18
20951: PUSH
20952: LD_INT 7
20954: PUSH
20955: LD_INT 28
20957: PUSH
20958: LD_INT 45
20960: PUSH
20961: EMPTY
20962: LIST
20963: LIST
20964: LIST
20965: PUSH
20966: LD_VAR 0 12
20970: ARRAY
20971: ST_TO_ADDR
// break ;
20972: GO 20976
// end ; end ; end ;
20974: GO 20805
20976: POP
20977: POP
// end ; if not weapon then
20978: LD_VAR 0 18
20982: NOT
20983: IFFALSE 21043
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
20985: LD_ADDR_VAR 0 5
20989: PUSH
20990: LD_VAR 0 5
20994: PUSH
20995: LD_INT 11
20997: PUSH
20998: LD_INT 30
21000: PUSH
21001: LD_INT 49
21003: PUSH
21004: EMPTY
21005: LIST
21006: LIST
21007: LIST
21008: DIFF
21009: ST_TO_ADDR
// if not list then
21010: LD_VAR 0 5
21014: NOT
21015: IFFALSE 21019
// exit ;
21017: GO 21161
// weapon := list [ rand ( 1 , list ) ] ;
21019: LD_ADDR_VAR 0 18
21023: PUSH
21024: LD_VAR 0 5
21028: PUSH
21029: LD_INT 1
21031: PPUSH
21032: LD_VAR 0 5
21036: PPUSH
21037: CALL_OW 12
21041: ARRAY
21042: ST_TO_ADDR
// end ; if weapon then
21043: LD_VAR 0 18
21047: IFFALSE 21161
// begin tmp := CostOfWeapon ( weapon ) ;
21049: LD_ADDR_VAR 0 14
21053: PUSH
21054: LD_VAR 0 18
21058: PPUSH
21059: CALL_OW 451
21063: ST_TO_ADDR
// j := GetBase ( tower ) ;
21064: LD_ADDR_VAR 0 9
21068: PUSH
21069: LD_VAR 0 1
21073: PPUSH
21074: CALL_OW 274
21078: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
21079: LD_VAR 0 9
21083: PPUSH
21084: LD_INT 1
21086: PPUSH
21087: CALL_OW 275
21091: PUSH
21092: LD_VAR 0 14
21096: PUSH
21097: LD_INT 1
21099: ARRAY
21100: GREATEREQUAL
21101: PUSH
21102: LD_VAR 0 9
21106: PPUSH
21107: LD_INT 2
21109: PPUSH
21110: CALL_OW 275
21114: PUSH
21115: LD_VAR 0 14
21119: PUSH
21120: LD_INT 2
21122: ARRAY
21123: GREATEREQUAL
21124: AND
21125: PUSH
21126: LD_VAR 0 9
21130: PPUSH
21131: LD_INT 3
21133: PPUSH
21134: CALL_OW 275
21138: PUSH
21139: LD_VAR 0 14
21143: PUSH
21144: LD_INT 3
21146: ARRAY
21147: GREATEREQUAL
21148: AND
21149: IFFALSE 21161
// result := weapon ;
21151: LD_ADDR_VAR 0 3
21155: PUSH
21156: LD_VAR 0 18
21160: ST_TO_ADDR
// end ; end ;
21161: LD_VAR 0 3
21165: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
21166: LD_INT 0
21168: PPUSH
21169: PPUSH
// result := true ;
21170: LD_ADDR_VAR 0 3
21174: PUSH
21175: LD_INT 1
21177: ST_TO_ADDR
// if array1 = array2 then
21178: LD_VAR 0 1
21182: PUSH
21183: LD_VAR 0 2
21187: EQUAL
21188: IFFALSE 21248
// begin for i = 1 to array1 do
21190: LD_ADDR_VAR 0 4
21194: PUSH
21195: DOUBLE
21196: LD_INT 1
21198: DEC
21199: ST_TO_ADDR
21200: LD_VAR 0 1
21204: PUSH
21205: FOR_TO
21206: IFFALSE 21244
// if array1 [ i ] <> array2 [ i ] then
21208: LD_VAR 0 1
21212: PUSH
21213: LD_VAR 0 4
21217: ARRAY
21218: PUSH
21219: LD_VAR 0 2
21223: PUSH
21224: LD_VAR 0 4
21228: ARRAY
21229: NONEQUAL
21230: IFFALSE 21242
// begin result := false ;
21232: LD_ADDR_VAR 0 3
21236: PUSH
21237: LD_INT 0
21239: ST_TO_ADDR
// break ;
21240: GO 21244
// end ;
21242: GO 21205
21244: POP
21245: POP
// end else
21246: GO 21256
// result := false ;
21248: LD_ADDR_VAR 0 3
21252: PUSH
21253: LD_INT 0
21255: ST_TO_ADDR
// end ;
21256: LD_VAR 0 3
21260: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
21261: LD_INT 0
21263: PPUSH
21264: PPUSH
// if not array1 or not array2 then
21265: LD_VAR 0 1
21269: NOT
21270: PUSH
21271: LD_VAR 0 2
21275: NOT
21276: OR
21277: IFFALSE 21281
// exit ;
21279: GO 21345
// result := true ;
21281: LD_ADDR_VAR 0 3
21285: PUSH
21286: LD_INT 1
21288: ST_TO_ADDR
// for i = 1 to array1 do
21289: LD_ADDR_VAR 0 4
21293: PUSH
21294: DOUBLE
21295: LD_INT 1
21297: DEC
21298: ST_TO_ADDR
21299: LD_VAR 0 1
21303: PUSH
21304: FOR_TO
21305: IFFALSE 21343
// if array1 [ i ] <> array2 [ i ] then
21307: LD_VAR 0 1
21311: PUSH
21312: LD_VAR 0 4
21316: ARRAY
21317: PUSH
21318: LD_VAR 0 2
21322: PUSH
21323: LD_VAR 0 4
21327: ARRAY
21328: NONEQUAL
21329: IFFALSE 21341
// begin result := false ;
21331: LD_ADDR_VAR 0 3
21335: PUSH
21336: LD_INT 0
21338: ST_TO_ADDR
// break ;
21339: GO 21343
// end ;
21341: GO 21304
21343: POP
21344: POP
// end ;
21345: LD_VAR 0 3
21349: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
21350: LD_INT 0
21352: PPUSH
21353: PPUSH
21354: PPUSH
// pom := GetBase ( fac ) ;
21355: LD_ADDR_VAR 0 5
21359: PUSH
21360: LD_VAR 0 1
21364: PPUSH
21365: CALL_OW 274
21369: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
21370: LD_ADDR_VAR 0 4
21374: PUSH
21375: LD_VAR 0 2
21379: PUSH
21380: LD_INT 1
21382: ARRAY
21383: PPUSH
21384: LD_VAR 0 2
21388: PUSH
21389: LD_INT 2
21391: ARRAY
21392: PPUSH
21393: LD_VAR 0 2
21397: PUSH
21398: LD_INT 3
21400: ARRAY
21401: PPUSH
21402: LD_VAR 0 2
21406: PUSH
21407: LD_INT 4
21409: ARRAY
21410: PPUSH
21411: CALL_OW 449
21415: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21416: LD_ADDR_VAR 0 3
21420: PUSH
21421: LD_VAR 0 5
21425: PPUSH
21426: LD_INT 1
21428: PPUSH
21429: CALL_OW 275
21433: PUSH
21434: LD_VAR 0 4
21438: PUSH
21439: LD_INT 1
21441: ARRAY
21442: GREATEREQUAL
21443: PUSH
21444: LD_VAR 0 5
21448: PPUSH
21449: LD_INT 2
21451: PPUSH
21452: CALL_OW 275
21456: PUSH
21457: LD_VAR 0 4
21461: PUSH
21462: LD_INT 2
21464: ARRAY
21465: GREATEREQUAL
21466: AND
21467: PUSH
21468: LD_VAR 0 5
21472: PPUSH
21473: LD_INT 3
21475: PPUSH
21476: CALL_OW 275
21480: PUSH
21481: LD_VAR 0 4
21485: PUSH
21486: LD_INT 3
21488: ARRAY
21489: GREATEREQUAL
21490: AND
21491: ST_TO_ADDR
// end ;
21492: LD_VAR 0 3
21496: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
21497: LD_INT 0
21499: PPUSH
21500: PPUSH
21501: PPUSH
21502: PPUSH
// pom := GetBase ( building ) ;
21503: LD_ADDR_VAR 0 3
21507: PUSH
21508: LD_VAR 0 1
21512: PPUSH
21513: CALL_OW 274
21517: ST_TO_ADDR
// if not pom then
21518: LD_VAR 0 3
21522: NOT
21523: IFFALSE 21527
// exit ;
21525: GO 21697
// btype := GetBType ( building ) ;
21527: LD_ADDR_VAR 0 5
21531: PUSH
21532: LD_VAR 0 1
21536: PPUSH
21537: CALL_OW 266
21541: ST_TO_ADDR
// if btype = b_armoury then
21542: LD_VAR 0 5
21546: PUSH
21547: LD_INT 4
21549: EQUAL
21550: IFFALSE 21560
// btype := b_barracks ;
21552: LD_ADDR_VAR 0 5
21556: PUSH
21557: LD_INT 5
21559: ST_TO_ADDR
// if btype = b_depot then
21560: LD_VAR 0 5
21564: PUSH
21565: LD_INT 0
21567: EQUAL
21568: IFFALSE 21578
// btype := b_warehouse ;
21570: LD_ADDR_VAR 0 5
21574: PUSH
21575: LD_INT 1
21577: ST_TO_ADDR
// if btype = b_workshop then
21578: LD_VAR 0 5
21582: PUSH
21583: LD_INT 2
21585: EQUAL
21586: IFFALSE 21596
// btype := b_factory ;
21588: LD_ADDR_VAR 0 5
21592: PUSH
21593: LD_INT 3
21595: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
21596: LD_ADDR_VAR 0 4
21600: PUSH
21601: LD_VAR 0 5
21605: PPUSH
21606: LD_VAR 0 1
21610: PPUSH
21611: CALL_OW 248
21615: PPUSH
21616: CALL_OW 450
21620: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21621: LD_ADDR_VAR 0 2
21625: PUSH
21626: LD_VAR 0 3
21630: PPUSH
21631: LD_INT 1
21633: PPUSH
21634: CALL_OW 275
21638: PUSH
21639: LD_VAR 0 4
21643: PUSH
21644: LD_INT 1
21646: ARRAY
21647: GREATEREQUAL
21648: PUSH
21649: LD_VAR 0 3
21653: PPUSH
21654: LD_INT 2
21656: PPUSH
21657: CALL_OW 275
21661: PUSH
21662: LD_VAR 0 4
21666: PUSH
21667: LD_INT 2
21669: ARRAY
21670: GREATEREQUAL
21671: AND
21672: PUSH
21673: LD_VAR 0 3
21677: PPUSH
21678: LD_INT 3
21680: PPUSH
21681: CALL_OW 275
21685: PUSH
21686: LD_VAR 0 4
21690: PUSH
21691: LD_INT 3
21693: ARRAY
21694: GREATEREQUAL
21695: AND
21696: ST_TO_ADDR
// end ;
21697: LD_VAR 0 2
21701: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
21702: LD_INT 0
21704: PPUSH
21705: PPUSH
21706: PPUSH
// pom := GetBase ( building ) ;
21707: LD_ADDR_VAR 0 4
21711: PUSH
21712: LD_VAR 0 1
21716: PPUSH
21717: CALL_OW 274
21721: ST_TO_ADDR
// if not pom then
21722: LD_VAR 0 4
21726: NOT
21727: IFFALSE 21731
// exit ;
21729: GO 21832
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
21731: LD_ADDR_VAR 0 5
21735: PUSH
21736: LD_VAR 0 2
21740: PPUSH
21741: LD_VAR 0 1
21745: PPUSH
21746: CALL_OW 248
21750: PPUSH
21751: CALL_OW 450
21755: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21756: LD_ADDR_VAR 0 3
21760: PUSH
21761: LD_VAR 0 4
21765: PPUSH
21766: LD_INT 1
21768: PPUSH
21769: CALL_OW 275
21773: PUSH
21774: LD_VAR 0 5
21778: PUSH
21779: LD_INT 1
21781: ARRAY
21782: GREATEREQUAL
21783: PUSH
21784: LD_VAR 0 4
21788: PPUSH
21789: LD_INT 2
21791: PPUSH
21792: CALL_OW 275
21796: PUSH
21797: LD_VAR 0 5
21801: PUSH
21802: LD_INT 2
21804: ARRAY
21805: GREATEREQUAL
21806: AND
21807: PUSH
21808: LD_VAR 0 4
21812: PPUSH
21813: LD_INT 3
21815: PPUSH
21816: CALL_OW 275
21820: PUSH
21821: LD_VAR 0 5
21825: PUSH
21826: LD_INT 3
21828: ARRAY
21829: GREATEREQUAL
21830: AND
21831: ST_TO_ADDR
// end ;
21832: LD_VAR 0 3
21836: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
21837: LD_INT 0
21839: PPUSH
21840: PPUSH
21841: PPUSH
21842: PPUSH
21843: PPUSH
21844: PPUSH
21845: PPUSH
21846: PPUSH
21847: PPUSH
21848: PPUSH
21849: PPUSH
// result := false ;
21850: LD_ADDR_VAR 0 8
21854: PUSH
21855: LD_INT 0
21857: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
21858: LD_VAR 0 5
21862: NOT
21863: PUSH
21864: LD_VAR 0 1
21868: NOT
21869: OR
21870: PUSH
21871: LD_VAR 0 2
21875: NOT
21876: OR
21877: PUSH
21878: LD_VAR 0 3
21882: NOT
21883: OR
21884: IFFALSE 21888
// exit ;
21886: GO 22702
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
21888: LD_ADDR_VAR 0 14
21892: PUSH
21893: LD_VAR 0 1
21897: PPUSH
21898: LD_VAR 0 2
21902: PPUSH
21903: LD_VAR 0 3
21907: PPUSH
21908: LD_VAR 0 4
21912: PPUSH
21913: LD_VAR 0 5
21917: PUSH
21918: LD_INT 1
21920: ARRAY
21921: PPUSH
21922: CALL_OW 248
21926: PPUSH
21927: LD_INT 0
21929: PPUSH
21930: CALL 23939 0 6
21934: ST_TO_ADDR
// if not hexes then
21935: LD_VAR 0 14
21939: NOT
21940: IFFALSE 21944
// exit ;
21942: GO 22702
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
21944: LD_ADDR_VAR 0 17
21948: PUSH
21949: LD_VAR 0 5
21953: PPUSH
21954: LD_INT 22
21956: PUSH
21957: LD_VAR 0 13
21961: PPUSH
21962: CALL_OW 255
21966: PUSH
21967: EMPTY
21968: LIST
21969: LIST
21970: PUSH
21971: LD_INT 2
21973: PUSH
21974: LD_INT 30
21976: PUSH
21977: LD_INT 0
21979: PUSH
21980: EMPTY
21981: LIST
21982: LIST
21983: PUSH
21984: LD_INT 30
21986: PUSH
21987: LD_INT 1
21989: PUSH
21990: EMPTY
21991: LIST
21992: LIST
21993: PUSH
21994: EMPTY
21995: LIST
21996: LIST
21997: LIST
21998: PUSH
21999: EMPTY
22000: LIST
22001: LIST
22002: PPUSH
22003: CALL_OW 72
22007: ST_TO_ADDR
// for i = 1 to hexes do
22008: LD_ADDR_VAR 0 9
22012: PUSH
22013: DOUBLE
22014: LD_INT 1
22016: DEC
22017: ST_TO_ADDR
22018: LD_VAR 0 14
22022: PUSH
22023: FOR_TO
22024: IFFALSE 22700
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
22026: LD_ADDR_VAR 0 13
22030: PUSH
22031: LD_VAR 0 14
22035: PUSH
22036: LD_VAR 0 9
22040: ARRAY
22041: PUSH
22042: LD_INT 1
22044: ARRAY
22045: PPUSH
22046: LD_VAR 0 14
22050: PUSH
22051: LD_VAR 0 9
22055: ARRAY
22056: PUSH
22057: LD_INT 2
22059: ARRAY
22060: PPUSH
22061: CALL_OW 428
22065: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
22066: LD_VAR 0 14
22070: PUSH
22071: LD_VAR 0 9
22075: ARRAY
22076: PUSH
22077: LD_INT 1
22079: ARRAY
22080: PPUSH
22081: LD_VAR 0 14
22085: PUSH
22086: LD_VAR 0 9
22090: ARRAY
22091: PUSH
22092: LD_INT 2
22094: ARRAY
22095: PPUSH
22096: CALL_OW 351
22100: PUSH
22101: LD_VAR 0 14
22105: PUSH
22106: LD_VAR 0 9
22110: ARRAY
22111: PUSH
22112: LD_INT 1
22114: ARRAY
22115: PPUSH
22116: LD_VAR 0 14
22120: PUSH
22121: LD_VAR 0 9
22125: ARRAY
22126: PUSH
22127: LD_INT 2
22129: ARRAY
22130: PPUSH
22131: CALL_OW 488
22135: NOT
22136: OR
22137: PUSH
22138: LD_VAR 0 13
22142: PPUSH
22143: CALL_OW 247
22147: PUSH
22148: LD_INT 3
22150: EQUAL
22151: OR
22152: IFFALSE 22158
// exit ;
22154: POP
22155: POP
22156: GO 22702
// if not tmp then
22158: LD_VAR 0 13
22162: NOT
22163: IFFALSE 22167
// continue ;
22165: GO 22023
// result := true ;
22167: LD_ADDR_VAR 0 8
22171: PUSH
22172: LD_INT 1
22174: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
22175: LD_VAR 0 6
22179: PUSH
22180: LD_VAR 0 13
22184: PPUSH
22185: CALL_OW 247
22189: PUSH
22190: LD_INT 2
22192: EQUAL
22193: AND
22194: PUSH
22195: LD_VAR 0 13
22199: PPUSH
22200: CALL_OW 263
22204: PUSH
22205: LD_INT 1
22207: EQUAL
22208: AND
22209: IFFALSE 22373
// begin if IsDrivenBy ( tmp ) then
22211: LD_VAR 0 13
22215: PPUSH
22216: CALL_OW 311
22220: IFFALSE 22224
// continue ;
22222: GO 22023
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
22224: LD_VAR 0 6
22228: PPUSH
22229: LD_INT 3
22231: PUSH
22232: LD_INT 60
22234: PUSH
22235: EMPTY
22236: LIST
22237: PUSH
22238: EMPTY
22239: LIST
22240: LIST
22241: PUSH
22242: LD_INT 3
22244: PUSH
22245: LD_INT 55
22247: PUSH
22248: EMPTY
22249: LIST
22250: PUSH
22251: EMPTY
22252: LIST
22253: LIST
22254: PUSH
22255: EMPTY
22256: LIST
22257: LIST
22258: PPUSH
22259: CALL_OW 72
22263: IFFALSE 22371
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
22265: LD_ADDR_VAR 0 18
22269: PUSH
22270: LD_VAR 0 6
22274: PPUSH
22275: LD_INT 3
22277: PUSH
22278: LD_INT 60
22280: PUSH
22281: EMPTY
22282: LIST
22283: PUSH
22284: EMPTY
22285: LIST
22286: LIST
22287: PUSH
22288: LD_INT 3
22290: PUSH
22291: LD_INT 55
22293: PUSH
22294: EMPTY
22295: LIST
22296: PUSH
22297: EMPTY
22298: LIST
22299: LIST
22300: PUSH
22301: EMPTY
22302: LIST
22303: LIST
22304: PPUSH
22305: CALL_OW 72
22309: PUSH
22310: LD_INT 1
22312: ARRAY
22313: ST_TO_ADDR
// if IsInUnit ( driver ) then
22314: LD_VAR 0 18
22318: PPUSH
22319: CALL_OW 310
22323: IFFALSE 22334
// ComExit ( driver ) ;
22325: LD_VAR 0 18
22329: PPUSH
22330: CALL 47123 0 1
// AddComEnterUnit ( driver , tmp ) ;
22334: LD_VAR 0 18
22338: PPUSH
22339: LD_VAR 0 13
22343: PPUSH
22344: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
22348: LD_VAR 0 18
22352: PPUSH
22353: LD_VAR 0 7
22357: PPUSH
22358: CALL_OW 173
// AddComExitVehicle ( driver ) ;
22362: LD_VAR 0 18
22366: PPUSH
22367: CALL_OW 181
// end ; continue ;
22371: GO 22023
// end ; if not cleaners or not tmp in cleaners then
22373: LD_VAR 0 6
22377: NOT
22378: PUSH
22379: LD_VAR 0 13
22383: PUSH
22384: LD_VAR 0 6
22388: IN
22389: NOT
22390: OR
22391: IFFALSE 22698
// begin if dep then
22393: LD_VAR 0 17
22397: IFFALSE 22533
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
22399: LD_ADDR_VAR 0 16
22403: PUSH
22404: LD_VAR 0 17
22408: PUSH
22409: LD_INT 1
22411: ARRAY
22412: PPUSH
22413: CALL_OW 250
22417: PPUSH
22418: LD_VAR 0 17
22422: PUSH
22423: LD_INT 1
22425: ARRAY
22426: PPUSH
22427: CALL_OW 254
22431: PPUSH
22432: LD_INT 5
22434: PPUSH
22435: CALL_OW 272
22439: PUSH
22440: LD_VAR 0 17
22444: PUSH
22445: LD_INT 1
22447: ARRAY
22448: PPUSH
22449: CALL_OW 251
22453: PPUSH
22454: LD_VAR 0 17
22458: PUSH
22459: LD_INT 1
22461: ARRAY
22462: PPUSH
22463: CALL_OW 254
22467: PPUSH
22468: LD_INT 5
22470: PPUSH
22471: CALL_OW 273
22475: PUSH
22476: EMPTY
22477: LIST
22478: LIST
22479: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
22480: LD_VAR 0 16
22484: PUSH
22485: LD_INT 1
22487: ARRAY
22488: PPUSH
22489: LD_VAR 0 16
22493: PUSH
22494: LD_INT 2
22496: ARRAY
22497: PPUSH
22498: CALL_OW 488
22502: IFFALSE 22533
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
22504: LD_VAR 0 13
22508: PPUSH
22509: LD_VAR 0 16
22513: PUSH
22514: LD_INT 1
22516: ARRAY
22517: PPUSH
22518: LD_VAR 0 16
22522: PUSH
22523: LD_INT 2
22525: ARRAY
22526: PPUSH
22527: CALL_OW 111
// continue ;
22531: GO 22023
// end ; end ; r := GetDir ( tmp ) ;
22533: LD_ADDR_VAR 0 15
22537: PUSH
22538: LD_VAR 0 13
22542: PPUSH
22543: CALL_OW 254
22547: ST_TO_ADDR
// if r = 5 then
22548: LD_VAR 0 15
22552: PUSH
22553: LD_INT 5
22555: EQUAL
22556: IFFALSE 22566
// r := 0 ;
22558: LD_ADDR_VAR 0 15
22562: PUSH
22563: LD_INT 0
22565: ST_TO_ADDR
// for j = r to 5 do
22566: LD_ADDR_VAR 0 10
22570: PUSH
22571: DOUBLE
22572: LD_VAR 0 15
22576: DEC
22577: ST_TO_ADDR
22578: LD_INT 5
22580: PUSH
22581: FOR_TO
22582: IFFALSE 22696
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
22584: LD_ADDR_VAR 0 11
22588: PUSH
22589: LD_VAR 0 13
22593: PPUSH
22594: CALL_OW 250
22598: PPUSH
22599: LD_VAR 0 10
22603: PPUSH
22604: LD_INT 2
22606: PPUSH
22607: CALL_OW 272
22611: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
22612: LD_ADDR_VAR 0 12
22616: PUSH
22617: LD_VAR 0 13
22621: PPUSH
22622: CALL_OW 251
22626: PPUSH
22627: LD_VAR 0 10
22631: PPUSH
22632: LD_INT 2
22634: PPUSH
22635: CALL_OW 273
22639: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
22640: LD_VAR 0 11
22644: PPUSH
22645: LD_VAR 0 12
22649: PPUSH
22650: CALL_OW 488
22654: PUSH
22655: LD_VAR 0 11
22659: PPUSH
22660: LD_VAR 0 12
22664: PPUSH
22665: CALL_OW 428
22669: NOT
22670: AND
22671: IFFALSE 22694
// begin ComMoveXY ( tmp , _x , _y ) ;
22673: LD_VAR 0 13
22677: PPUSH
22678: LD_VAR 0 11
22682: PPUSH
22683: LD_VAR 0 12
22687: PPUSH
22688: CALL_OW 111
// break ;
22692: GO 22696
// end ; end ;
22694: GO 22581
22696: POP
22697: POP
// end ; end ;
22698: GO 22023
22700: POP
22701: POP
// end ;
22702: LD_VAR 0 8
22706: RET
// export function BuildingTechInvented ( side , btype ) ; begin
22707: LD_INT 0
22709: PPUSH
// result := true ;
22710: LD_ADDR_VAR 0 3
22714: PUSH
22715: LD_INT 1
22717: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
22718: LD_VAR 0 2
22722: PUSH
22723: LD_INT 24
22725: DOUBLE
22726: EQUAL
22727: IFTRUE 22737
22729: LD_INT 33
22731: DOUBLE
22732: EQUAL
22733: IFTRUE 22737
22735: GO 22762
22737: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
22738: LD_ADDR_VAR 0 3
22742: PUSH
22743: LD_INT 32
22745: PPUSH
22746: LD_VAR 0 1
22750: PPUSH
22751: CALL_OW 321
22755: PUSH
22756: LD_INT 2
22758: EQUAL
22759: ST_TO_ADDR
22760: GO 23082
22762: LD_INT 20
22764: DOUBLE
22765: EQUAL
22766: IFTRUE 22770
22768: GO 22795
22770: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
22771: LD_ADDR_VAR 0 3
22775: PUSH
22776: LD_INT 6
22778: PPUSH
22779: LD_VAR 0 1
22783: PPUSH
22784: CALL_OW 321
22788: PUSH
22789: LD_INT 2
22791: EQUAL
22792: ST_TO_ADDR
22793: GO 23082
22795: LD_INT 22
22797: DOUBLE
22798: EQUAL
22799: IFTRUE 22809
22801: LD_INT 36
22803: DOUBLE
22804: EQUAL
22805: IFTRUE 22809
22807: GO 22834
22809: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
22810: LD_ADDR_VAR 0 3
22814: PUSH
22815: LD_INT 15
22817: PPUSH
22818: LD_VAR 0 1
22822: PPUSH
22823: CALL_OW 321
22827: PUSH
22828: LD_INT 2
22830: EQUAL
22831: ST_TO_ADDR
22832: GO 23082
22834: LD_INT 30
22836: DOUBLE
22837: EQUAL
22838: IFTRUE 22842
22840: GO 22867
22842: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
22843: LD_ADDR_VAR 0 3
22847: PUSH
22848: LD_INT 20
22850: PPUSH
22851: LD_VAR 0 1
22855: PPUSH
22856: CALL_OW 321
22860: PUSH
22861: LD_INT 2
22863: EQUAL
22864: ST_TO_ADDR
22865: GO 23082
22867: LD_INT 28
22869: DOUBLE
22870: EQUAL
22871: IFTRUE 22881
22873: LD_INT 21
22875: DOUBLE
22876: EQUAL
22877: IFTRUE 22881
22879: GO 22906
22881: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
22882: LD_ADDR_VAR 0 3
22886: PUSH
22887: LD_INT 21
22889: PPUSH
22890: LD_VAR 0 1
22894: PPUSH
22895: CALL_OW 321
22899: PUSH
22900: LD_INT 2
22902: EQUAL
22903: ST_TO_ADDR
22904: GO 23082
22906: LD_INT 16
22908: DOUBLE
22909: EQUAL
22910: IFTRUE 22914
22912: GO 22941
22914: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
22915: LD_ADDR_VAR 0 3
22919: PUSH
22920: LD_EXP 79
22924: PPUSH
22925: LD_VAR 0 1
22929: PPUSH
22930: CALL_OW 321
22934: PUSH
22935: LD_INT 2
22937: EQUAL
22938: ST_TO_ADDR
22939: GO 23082
22941: LD_INT 19
22943: DOUBLE
22944: EQUAL
22945: IFTRUE 22955
22947: LD_INT 23
22949: DOUBLE
22950: EQUAL
22951: IFTRUE 22955
22953: GO 22982
22955: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
22956: LD_ADDR_VAR 0 3
22960: PUSH
22961: LD_EXP 78
22965: PPUSH
22966: LD_VAR 0 1
22970: PPUSH
22971: CALL_OW 321
22975: PUSH
22976: LD_INT 2
22978: EQUAL
22979: ST_TO_ADDR
22980: GO 23082
22982: LD_INT 17
22984: DOUBLE
22985: EQUAL
22986: IFTRUE 22990
22988: GO 23015
22990: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
22991: LD_ADDR_VAR 0 3
22995: PUSH
22996: LD_INT 39
22998: PPUSH
22999: LD_VAR 0 1
23003: PPUSH
23004: CALL_OW 321
23008: PUSH
23009: LD_INT 2
23011: EQUAL
23012: ST_TO_ADDR
23013: GO 23082
23015: LD_INT 18
23017: DOUBLE
23018: EQUAL
23019: IFTRUE 23023
23021: GO 23048
23023: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
23024: LD_ADDR_VAR 0 3
23028: PUSH
23029: LD_INT 40
23031: PPUSH
23032: LD_VAR 0 1
23036: PPUSH
23037: CALL_OW 321
23041: PUSH
23042: LD_INT 2
23044: EQUAL
23045: ST_TO_ADDR
23046: GO 23082
23048: LD_INT 27
23050: DOUBLE
23051: EQUAL
23052: IFTRUE 23056
23054: GO 23081
23056: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
23057: LD_ADDR_VAR 0 3
23061: PUSH
23062: LD_INT 35
23064: PPUSH
23065: LD_VAR 0 1
23069: PPUSH
23070: CALL_OW 321
23074: PUSH
23075: LD_INT 2
23077: EQUAL
23078: ST_TO_ADDR
23079: GO 23082
23081: POP
// end ;
23082: LD_VAR 0 3
23086: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
23087: LD_INT 0
23089: PPUSH
23090: PPUSH
23091: PPUSH
23092: PPUSH
23093: PPUSH
23094: PPUSH
23095: PPUSH
23096: PPUSH
23097: PPUSH
23098: PPUSH
23099: PPUSH
// result := false ;
23100: LD_ADDR_VAR 0 6
23104: PUSH
23105: LD_INT 0
23107: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
23108: LD_VAR 0 1
23112: NOT
23113: PUSH
23114: LD_VAR 0 1
23118: PPUSH
23119: CALL_OW 266
23123: PUSH
23124: LD_INT 0
23126: PUSH
23127: LD_INT 1
23129: PUSH
23130: EMPTY
23131: LIST
23132: LIST
23133: IN
23134: NOT
23135: OR
23136: PUSH
23137: LD_VAR 0 2
23141: NOT
23142: OR
23143: PUSH
23144: LD_VAR 0 5
23148: PUSH
23149: LD_INT 0
23151: PUSH
23152: LD_INT 1
23154: PUSH
23155: LD_INT 2
23157: PUSH
23158: LD_INT 3
23160: PUSH
23161: LD_INT 4
23163: PUSH
23164: LD_INT 5
23166: PUSH
23167: EMPTY
23168: LIST
23169: LIST
23170: LIST
23171: LIST
23172: LIST
23173: LIST
23174: IN
23175: NOT
23176: OR
23177: PUSH
23178: LD_VAR 0 3
23182: PPUSH
23183: LD_VAR 0 4
23187: PPUSH
23188: CALL_OW 488
23192: NOT
23193: OR
23194: IFFALSE 23198
// exit ;
23196: GO 23934
// side := GetSide ( depot ) ;
23198: LD_ADDR_VAR 0 9
23202: PUSH
23203: LD_VAR 0 1
23207: PPUSH
23208: CALL_OW 255
23212: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
23213: LD_VAR 0 9
23217: PPUSH
23218: LD_VAR 0 2
23222: PPUSH
23223: CALL 22707 0 2
23227: NOT
23228: IFFALSE 23232
// exit ;
23230: GO 23934
// pom := GetBase ( depot ) ;
23232: LD_ADDR_VAR 0 10
23236: PUSH
23237: LD_VAR 0 1
23241: PPUSH
23242: CALL_OW 274
23246: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
23247: LD_ADDR_VAR 0 11
23251: PUSH
23252: LD_VAR 0 2
23256: PPUSH
23257: LD_VAR 0 1
23261: PPUSH
23262: CALL_OW 248
23266: PPUSH
23267: CALL_OW 450
23271: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
23272: LD_VAR 0 10
23276: PPUSH
23277: LD_INT 1
23279: PPUSH
23280: CALL_OW 275
23284: PUSH
23285: LD_VAR 0 11
23289: PUSH
23290: LD_INT 1
23292: ARRAY
23293: GREATEREQUAL
23294: PUSH
23295: LD_VAR 0 10
23299: PPUSH
23300: LD_INT 2
23302: PPUSH
23303: CALL_OW 275
23307: PUSH
23308: LD_VAR 0 11
23312: PUSH
23313: LD_INT 2
23315: ARRAY
23316: GREATEREQUAL
23317: AND
23318: PUSH
23319: LD_VAR 0 10
23323: PPUSH
23324: LD_INT 3
23326: PPUSH
23327: CALL_OW 275
23331: PUSH
23332: LD_VAR 0 11
23336: PUSH
23337: LD_INT 3
23339: ARRAY
23340: GREATEREQUAL
23341: AND
23342: NOT
23343: IFFALSE 23347
// exit ;
23345: GO 23934
// if GetBType ( depot ) = b_depot then
23347: LD_VAR 0 1
23351: PPUSH
23352: CALL_OW 266
23356: PUSH
23357: LD_INT 0
23359: EQUAL
23360: IFFALSE 23372
// dist := 28 else
23362: LD_ADDR_VAR 0 14
23366: PUSH
23367: LD_INT 28
23369: ST_TO_ADDR
23370: GO 23380
// dist := 36 ;
23372: LD_ADDR_VAR 0 14
23376: PUSH
23377: LD_INT 36
23379: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
23380: LD_VAR 0 1
23384: PPUSH
23385: LD_VAR 0 3
23389: PPUSH
23390: LD_VAR 0 4
23394: PPUSH
23395: CALL_OW 297
23399: PUSH
23400: LD_VAR 0 14
23404: GREATER
23405: IFFALSE 23409
// exit ;
23407: GO 23934
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
23409: LD_ADDR_VAR 0 12
23413: PUSH
23414: LD_VAR 0 2
23418: PPUSH
23419: LD_VAR 0 3
23423: PPUSH
23424: LD_VAR 0 4
23428: PPUSH
23429: LD_VAR 0 5
23433: PPUSH
23434: LD_VAR 0 1
23438: PPUSH
23439: CALL_OW 248
23443: PPUSH
23444: LD_INT 0
23446: PPUSH
23447: CALL 23939 0 6
23451: ST_TO_ADDR
// if not hexes then
23452: LD_VAR 0 12
23456: NOT
23457: IFFALSE 23461
// exit ;
23459: GO 23934
// hex := GetHexInfo ( x , y ) ;
23461: LD_ADDR_VAR 0 15
23465: PUSH
23466: LD_VAR 0 3
23470: PPUSH
23471: LD_VAR 0 4
23475: PPUSH
23476: CALL_OW 546
23480: ST_TO_ADDR
// if hex [ 1 ] then
23481: LD_VAR 0 15
23485: PUSH
23486: LD_INT 1
23488: ARRAY
23489: IFFALSE 23493
// exit ;
23491: GO 23934
// height := hex [ 2 ] ;
23493: LD_ADDR_VAR 0 13
23497: PUSH
23498: LD_VAR 0 15
23502: PUSH
23503: LD_INT 2
23505: ARRAY
23506: ST_TO_ADDR
// for i = 1 to hexes do
23507: LD_ADDR_VAR 0 7
23511: PUSH
23512: DOUBLE
23513: LD_INT 1
23515: DEC
23516: ST_TO_ADDR
23517: LD_VAR 0 12
23521: PUSH
23522: FOR_TO
23523: IFFALSE 23853
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
23525: LD_VAR 0 12
23529: PUSH
23530: LD_VAR 0 7
23534: ARRAY
23535: PUSH
23536: LD_INT 1
23538: ARRAY
23539: PPUSH
23540: LD_VAR 0 12
23544: PUSH
23545: LD_VAR 0 7
23549: ARRAY
23550: PUSH
23551: LD_INT 2
23553: ARRAY
23554: PPUSH
23555: CALL_OW 488
23559: NOT
23560: PUSH
23561: LD_VAR 0 12
23565: PUSH
23566: LD_VAR 0 7
23570: ARRAY
23571: PUSH
23572: LD_INT 1
23574: ARRAY
23575: PPUSH
23576: LD_VAR 0 12
23580: PUSH
23581: LD_VAR 0 7
23585: ARRAY
23586: PUSH
23587: LD_INT 2
23589: ARRAY
23590: PPUSH
23591: CALL_OW 428
23595: PUSH
23596: LD_INT 0
23598: GREATER
23599: OR
23600: PUSH
23601: LD_VAR 0 12
23605: PUSH
23606: LD_VAR 0 7
23610: ARRAY
23611: PUSH
23612: LD_INT 1
23614: ARRAY
23615: PPUSH
23616: LD_VAR 0 12
23620: PUSH
23621: LD_VAR 0 7
23625: ARRAY
23626: PUSH
23627: LD_INT 2
23629: ARRAY
23630: PPUSH
23631: CALL_OW 351
23635: OR
23636: IFFALSE 23642
// exit ;
23638: POP
23639: POP
23640: GO 23934
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
23642: LD_ADDR_VAR 0 8
23646: PUSH
23647: LD_VAR 0 12
23651: PUSH
23652: LD_VAR 0 7
23656: ARRAY
23657: PUSH
23658: LD_INT 1
23660: ARRAY
23661: PPUSH
23662: LD_VAR 0 12
23666: PUSH
23667: LD_VAR 0 7
23671: ARRAY
23672: PUSH
23673: LD_INT 2
23675: ARRAY
23676: PPUSH
23677: CALL_OW 546
23681: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
23682: LD_VAR 0 8
23686: PUSH
23687: LD_INT 1
23689: ARRAY
23690: PUSH
23691: LD_VAR 0 8
23695: PUSH
23696: LD_INT 2
23698: ARRAY
23699: PUSH
23700: LD_VAR 0 13
23704: PUSH
23705: LD_INT 2
23707: PLUS
23708: GREATER
23709: OR
23710: PUSH
23711: LD_VAR 0 8
23715: PUSH
23716: LD_INT 2
23718: ARRAY
23719: PUSH
23720: LD_VAR 0 13
23724: PUSH
23725: LD_INT 2
23727: MINUS
23728: LESS
23729: OR
23730: PUSH
23731: LD_VAR 0 8
23735: PUSH
23736: LD_INT 3
23738: ARRAY
23739: PUSH
23740: LD_INT 0
23742: PUSH
23743: LD_INT 8
23745: PUSH
23746: LD_INT 9
23748: PUSH
23749: LD_INT 10
23751: PUSH
23752: LD_INT 11
23754: PUSH
23755: LD_INT 12
23757: PUSH
23758: LD_INT 13
23760: PUSH
23761: LD_INT 16
23763: PUSH
23764: LD_INT 17
23766: PUSH
23767: LD_INT 18
23769: PUSH
23770: LD_INT 19
23772: PUSH
23773: LD_INT 20
23775: PUSH
23776: LD_INT 21
23778: PUSH
23779: EMPTY
23780: LIST
23781: LIST
23782: LIST
23783: LIST
23784: LIST
23785: LIST
23786: LIST
23787: LIST
23788: LIST
23789: LIST
23790: LIST
23791: LIST
23792: LIST
23793: IN
23794: NOT
23795: OR
23796: PUSH
23797: LD_VAR 0 8
23801: PUSH
23802: LD_INT 5
23804: ARRAY
23805: NOT
23806: OR
23807: PUSH
23808: LD_VAR 0 8
23812: PUSH
23813: LD_INT 6
23815: ARRAY
23816: PUSH
23817: LD_INT 1
23819: PUSH
23820: LD_INT 2
23822: PUSH
23823: LD_INT 7
23825: PUSH
23826: LD_INT 9
23828: PUSH
23829: LD_INT 10
23831: PUSH
23832: LD_INT 11
23834: PUSH
23835: EMPTY
23836: LIST
23837: LIST
23838: LIST
23839: LIST
23840: LIST
23841: LIST
23842: IN
23843: NOT
23844: OR
23845: IFFALSE 23851
// exit ;
23847: POP
23848: POP
23849: GO 23934
// end ;
23851: GO 23522
23853: POP
23854: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
23855: LD_VAR 0 9
23859: PPUSH
23860: LD_VAR 0 3
23864: PPUSH
23865: LD_VAR 0 4
23869: PPUSH
23870: LD_INT 20
23872: PPUSH
23873: CALL 15879 0 4
23877: PUSH
23878: LD_INT 4
23880: ARRAY
23881: IFFALSE 23885
// exit ;
23883: GO 23934
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
23885: LD_VAR 0 2
23889: PUSH
23890: LD_INT 29
23892: PUSH
23893: LD_INT 30
23895: PUSH
23896: EMPTY
23897: LIST
23898: LIST
23899: IN
23900: PUSH
23901: LD_VAR 0 3
23905: PPUSH
23906: LD_VAR 0 4
23910: PPUSH
23911: LD_VAR 0 9
23915: PPUSH
23916: CALL_OW 440
23920: NOT
23921: AND
23922: IFFALSE 23926
// exit ;
23924: GO 23934
// result := true ;
23926: LD_ADDR_VAR 0 6
23930: PUSH
23931: LD_INT 1
23933: ST_TO_ADDR
// end ;
23934: LD_VAR 0 6
23938: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
23939: LD_INT 0
23941: PPUSH
23942: PPUSH
23943: PPUSH
23944: PPUSH
23945: PPUSH
23946: PPUSH
23947: PPUSH
23948: PPUSH
23949: PPUSH
23950: PPUSH
23951: PPUSH
23952: PPUSH
23953: PPUSH
23954: PPUSH
23955: PPUSH
23956: PPUSH
23957: PPUSH
23958: PPUSH
23959: PPUSH
23960: PPUSH
23961: PPUSH
23962: PPUSH
23963: PPUSH
23964: PPUSH
23965: PPUSH
23966: PPUSH
23967: PPUSH
23968: PPUSH
23969: PPUSH
23970: PPUSH
23971: PPUSH
23972: PPUSH
23973: PPUSH
23974: PPUSH
23975: PPUSH
23976: PPUSH
23977: PPUSH
23978: PPUSH
23979: PPUSH
23980: PPUSH
23981: PPUSH
23982: PPUSH
23983: PPUSH
23984: PPUSH
23985: PPUSH
23986: PPUSH
23987: PPUSH
23988: PPUSH
23989: PPUSH
23990: PPUSH
23991: PPUSH
23992: PPUSH
23993: PPUSH
23994: PPUSH
23995: PPUSH
23996: PPUSH
23997: PPUSH
23998: PPUSH
// result = [ ] ;
23999: LD_ADDR_VAR 0 7
24003: PUSH
24004: EMPTY
24005: ST_TO_ADDR
// temp_list = [ ] ;
24006: LD_ADDR_VAR 0 9
24010: PUSH
24011: EMPTY
24012: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
24013: LD_VAR 0 4
24017: PUSH
24018: LD_INT 0
24020: PUSH
24021: LD_INT 1
24023: PUSH
24024: LD_INT 2
24026: PUSH
24027: LD_INT 3
24029: PUSH
24030: LD_INT 4
24032: PUSH
24033: LD_INT 5
24035: PUSH
24036: EMPTY
24037: LIST
24038: LIST
24039: LIST
24040: LIST
24041: LIST
24042: LIST
24043: IN
24044: NOT
24045: PUSH
24046: LD_VAR 0 1
24050: PUSH
24051: LD_INT 0
24053: PUSH
24054: LD_INT 1
24056: PUSH
24057: EMPTY
24058: LIST
24059: LIST
24060: IN
24061: PUSH
24062: LD_VAR 0 5
24066: PUSH
24067: LD_INT 1
24069: PUSH
24070: LD_INT 2
24072: PUSH
24073: LD_INT 3
24075: PUSH
24076: EMPTY
24077: LIST
24078: LIST
24079: LIST
24080: IN
24081: NOT
24082: AND
24083: OR
24084: IFFALSE 24088
// exit ;
24086: GO 42479
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
24088: LD_VAR 0 1
24092: PUSH
24093: LD_INT 6
24095: PUSH
24096: LD_INT 7
24098: PUSH
24099: LD_INT 8
24101: PUSH
24102: LD_INT 13
24104: PUSH
24105: LD_INT 12
24107: PUSH
24108: LD_INT 15
24110: PUSH
24111: LD_INT 11
24113: PUSH
24114: LD_INT 14
24116: PUSH
24117: LD_INT 10
24119: PUSH
24120: EMPTY
24121: LIST
24122: LIST
24123: LIST
24124: LIST
24125: LIST
24126: LIST
24127: LIST
24128: LIST
24129: LIST
24130: IN
24131: IFFALSE 24141
// btype = b_lab ;
24133: LD_ADDR_VAR 0 1
24137: PUSH
24138: LD_INT 6
24140: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
24141: LD_VAR 0 6
24145: PUSH
24146: LD_INT 0
24148: PUSH
24149: LD_INT 1
24151: PUSH
24152: LD_INT 2
24154: PUSH
24155: EMPTY
24156: LIST
24157: LIST
24158: LIST
24159: IN
24160: NOT
24161: PUSH
24162: LD_VAR 0 1
24166: PUSH
24167: LD_INT 0
24169: PUSH
24170: LD_INT 1
24172: PUSH
24173: LD_INT 2
24175: PUSH
24176: LD_INT 3
24178: PUSH
24179: LD_INT 6
24181: PUSH
24182: LD_INT 36
24184: PUSH
24185: LD_INT 4
24187: PUSH
24188: LD_INT 5
24190: PUSH
24191: LD_INT 31
24193: PUSH
24194: LD_INT 32
24196: PUSH
24197: LD_INT 33
24199: PUSH
24200: EMPTY
24201: LIST
24202: LIST
24203: LIST
24204: LIST
24205: LIST
24206: LIST
24207: LIST
24208: LIST
24209: LIST
24210: LIST
24211: LIST
24212: IN
24213: NOT
24214: PUSH
24215: LD_VAR 0 6
24219: PUSH
24220: LD_INT 1
24222: EQUAL
24223: AND
24224: OR
24225: PUSH
24226: LD_VAR 0 1
24230: PUSH
24231: LD_INT 2
24233: PUSH
24234: LD_INT 3
24236: PUSH
24237: EMPTY
24238: LIST
24239: LIST
24240: IN
24241: NOT
24242: PUSH
24243: LD_VAR 0 6
24247: PUSH
24248: LD_INT 2
24250: EQUAL
24251: AND
24252: OR
24253: IFFALSE 24263
// mode = 0 ;
24255: LD_ADDR_VAR 0 6
24259: PUSH
24260: LD_INT 0
24262: ST_TO_ADDR
// case mode of 0 :
24263: LD_VAR 0 6
24267: PUSH
24268: LD_INT 0
24270: DOUBLE
24271: EQUAL
24272: IFTRUE 24276
24274: GO 35729
24276: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
24277: LD_ADDR_VAR 0 11
24281: PUSH
24282: LD_INT 0
24284: PUSH
24285: LD_INT 0
24287: PUSH
24288: EMPTY
24289: LIST
24290: LIST
24291: PUSH
24292: LD_INT 0
24294: PUSH
24295: LD_INT 1
24297: NEG
24298: PUSH
24299: EMPTY
24300: LIST
24301: LIST
24302: PUSH
24303: LD_INT 1
24305: PUSH
24306: LD_INT 0
24308: PUSH
24309: EMPTY
24310: LIST
24311: LIST
24312: PUSH
24313: LD_INT 1
24315: PUSH
24316: LD_INT 1
24318: PUSH
24319: EMPTY
24320: LIST
24321: LIST
24322: PUSH
24323: LD_INT 0
24325: PUSH
24326: LD_INT 1
24328: PUSH
24329: EMPTY
24330: LIST
24331: LIST
24332: PUSH
24333: LD_INT 1
24335: NEG
24336: PUSH
24337: LD_INT 0
24339: PUSH
24340: EMPTY
24341: LIST
24342: LIST
24343: PUSH
24344: LD_INT 1
24346: NEG
24347: PUSH
24348: LD_INT 1
24350: NEG
24351: PUSH
24352: EMPTY
24353: LIST
24354: LIST
24355: PUSH
24356: LD_INT 1
24358: NEG
24359: PUSH
24360: LD_INT 2
24362: NEG
24363: PUSH
24364: EMPTY
24365: LIST
24366: LIST
24367: PUSH
24368: LD_INT 0
24370: PUSH
24371: LD_INT 2
24373: NEG
24374: PUSH
24375: EMPTY
24376: LIST
24377: LIST
24378: PUSH
24379: LD_INT 1
24381: PUSH
24382: LD_INT 1
24384: NEG
24385: PUSH
24386: EMPTY
24387: LIST
24388: LIST
24389: PUSH
24390: LD_INT 1
24392: PUSH
24393: LD_INT 2
24395: PUSH
24396: EMPTY
24397: LIST
24398: LIST
24399: PUSH
24400: LD_INT 0
24402: PUSH
24403: LD_INT 2
24405: PUSH
24406: EMPTY
24407: LIST
24408: LIST
24409: PUSH
24410: LD_INT 1
24412: NEG
24413: PUSH
24414: LD_INT 1
24416: PUSH
24417: EMPTY
24418: LIST
24419: LIST
24420: PUSH
24421: LD_INT 1
24423: PUSH
24424: LD_INT 3
24426: PUSH
24427: EMPTY
24428: LIST
24429: LIST
24430: PUSH
24431: LD_INT 0
24433: PUSH
24434: LD_INT 3
24436: PUSH
24437: EMPTY
24438: LIST
24439: LIST
24440: PUSH
24441: LD_INT 1
24443: NEG
24444: PUSH
24445: LD_INT 2
24447: PUSH
24448: EMPTY
24449: LIST
24450: LIST
24451: PUSH
24452: EMPTY
24453: LIST
24454: LIST
24455: LIST
24456: LIST
24457: LIST
24458: LIST
24459: LIST
24460: LIST
24461: LIST
24462: LIST
24463: LIST
24464: LIST
24465: LIST
24466: LIST
24467: LIST
24468: LIST
24469: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
24470: LD_ADDR_VAR 0 12
24474: PUSH
24475: LD_INT 0
24477: PUSH
24478: LD_INT 0
24480: PUSH
24481: EMPTY
24482: LIST
24483: LIST
24484: PUSH
24485: LD_INT 0
24487: PUSH
24488: LD_INT 1
24490: NEG
24491: PUSH
24492: EMPTY
24493: LIST
24494: LIST
24495: PUSH
24496: LD_INT 1
24498: PUSH
24499: LD_INT 0
24501: PUSH
24502: EMPTY
24503: LIST
24504: LIST
24505: PUSH
24506: LD_INT 1
24508: PUSH
24509: LD_INT 1
24511: PUSH
24512: EMPTY
24513: LIST
24514: LIST
24515: PUSH
24516: LD_INT 0
24518: PUSH
24519: LD_INT 1
24521: PUSH
24522: EMPTY
24523: LIST
24524: LIST
24525: PUSH
24526: LD_INT 1
24528: NEG
24529: PUSH
24530: LD_INT 0
24532: PUSH
24533: EMPTY
24534: LIST
24535: LIST
24536: PUSH
24537: LD_INT 1
24539: NEG
24540: PUSH
24541: LD_INT 1
24543: NEG
24544: PUSH
24545: EMPTY
24546: LIST
24547: LIST
24548: PUSH
24549: LD_INT 1
24551: PUSH
24552: LD_INT 1
24554: NEG
24555: PUSH
24556: EMPTY
24557: LIST
24558: LIST
24559: PUSH
24560: LD_INT 2
24562: PUSH
24563: LD_INT 0
24565: PUSH
24566: EMPTY
24567: LIST
24568: LIST
24569: PUSH
24570: LD_INT 2
24572: PUSH
24573: LD_INT 1
24575: PUSH
24576: EMPTY
24577: LIST
24578: LIST
24579: PUSH
24580: LD_INT 1
24582: NEG
24583: PUSH
24584: LD_INT 1
24586: PUSH
24587: EMPTY
24588: LIST
24589: LIST
24590: PUSH
24591: LD_INT 2
24593: NEG
24594: PUSH
24595: LD_INT 0
24597: PUSH
24598: EMPTY
24599: LIST
24600: LIST
24601: PUSH
24602: LD_INT 2
24604: NEG
24605: PUSH
24606: LD_INT 1
24608: NEG
24609: PUSH
24610: EMPTY
24611: LIST
24612: LIST
24613: PUSH
24614: LD_INT 2
24616: NEG
24617: PUSH
24618: LD_INT 1
24620: PUSH
24621: EMPTY
24622: LIST
24623: LIST
24624: PUSH
24625: LD_INT 3
24627: NEG
24628: PUSH
24629: LD_INT 0
24631: PUSH
24632: EMPTY
24633: LIST
24634: LIST
24635: PUSH
24636: LD_INT 3
24638: NEG
24639: PUSH
24640: LD_INT 1
24642: NEG
24643: PUSH
24644: EMPTY
24645: LIST
24646: LIST
24647: PUSH
24648: EMPTY
24649: LIST
24650: LIST
24651: LIST
24652: LIST
24653: LIST
24654: LIST
24655: LIST
24656: LIST
24657: LIST
24658: LIST
24659: LIST
24660: LIST
24661: LIST
24662: LIST
24663: LIST
24664: LIST
24665: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
24666: LD_ADDR_VAR 0 13
24670: PUSH
24671: LD_INT 0
24673: PUSH
24674: LD_INT 0
24676: PUSH
24677: EMPTY
24678: LIST
24679: LIST
24680: PUSH
24681: LD_INT 0
24683: PUSH
24684: LD_INT 1
24686: NEG
24687: PUSH
24688: EMPTY
24689: LIST
24690: LIST
24691: PUSH
24692: LD_INT 1
24694: PUSH
24695: LD_INT 0
24697: PUSH
24698: EMPTY
24699: LIST
24700: LIST
24701: PUSH
24702: LD_INT 1
24704: PUSH
24705: LD_INT 1
24707: PUSH
24708: EMPTY
24709: LIST
24710: LIST
24711: PUSH
24712: LD_INT 0
24714: PUSH
24715: LD_INT 1
24717: PUSH
24718: EMPTY
24719: LIST
24720: LIST
24721: PUSH
24722: LD_INT 1
24724: NEG
24725: PUSH
24726: LD_INT 0
24728: PUSH
24729: EMPTY
24730: LIST
24731: LIST
24732: PUSH
24733: LD_INT 1
24735: NEG
24736: PUSH
24737: LD_INT 1
24739: NEG
24740: PUSH
24741: EMPTY
24742: LIST
24743: LIST
24744: PUSH
24745: LD_INT 1
24747: NEG
24748: PUSH
24749: LD_INT 2
24751: NEG
24752: PUSH
24753: EMPTY
24754: LIST
24755: LIST
24756: PUSH
24757: LD_INT 2
24759: PUSH
24760: LD_INT 1
24762: PUSH
24763: EMPTY
24764: LIST
24765: LIST
24766: PUSH
24767: LD_INT 2
24769: PUSH
24770: LD_INT 2
24772: PUSH
24773: EMPTY
24774: LIST
24775: LIST
24776: PUSH
24777: LD_INT 1
24779: PUSH
24780: LD_INT 2
24782: PUSH
24783: EMPTY
24784: LIST
24785: LIST
24786: PUSH
24787: LD_INT 2
24789: NEG
24790: PUSH
24791: LD_INT 1
24793: NEG
24794: PUSH
24795: EMPTY
24796: LIST
24797: LIST
24798: PUSH
24799: LD_INT 2
24801: NEG
24802: PUSH
24803: LD_INT 2
24805: NEG
24806: PUSH
24807: EMPTY
24808: LIST
24809: LIST
24810: PUSH
24811: LD_INT 2
24813: NEG
24814: PUSH
24815: LD_INT 3
24817: NEG
24818: PUSH
24819: EMPTY
24820: LIST
24821: LIST
24822: PUSH
24823: LD_INT 3
24825: NEG
24826: PUSH
24827: LD_INT 2
24829: NEG
24830: PUSH
24831: EMPTY
24832: LIST
24833: LIST
24834: PUSH
24835: LD_INT 3
24837: NEG
24838: PUSH
24839: LD_INT 3
24841: NEG
24842: PUSH
24843: EMPTY
24844: LIST
24845: LIST
24846: PUSH
24847: EMPTY
24848: LIST
24849: LIST
24850: LIST
24851: LIST
24852: LIST
24853: LIST
24854: LIST
24855: LIST
24856: LIST
24857: LIST
24858: LIST
24859: LIST
24860: LIST
24861: LIST
24862: LIST
24863: LIST
24864: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
24865: LD_ADDR_VAR 0 14
24869: PUSH
24870: LD_INT 0
24872: PUSH
24873: LD_INT 0
24875: PUSH
24876: EMPTY
24877: LIST
24878: LIST
24879: PUSH
24880: LD_INT 0
24882: PUSH
24883: LD_INT 1
24885: NEG
24886: PUSH
24887: EMPTY
24888: LIST
24889: LIST
24890: PUSH
24891: LD_INT 1
24893: PUSH
24894: LD_INT 0
24896: PUSH
24897: EMPTY
24898: LIST
24899: LIST
24900: PUSH
24901: LD_INT 1
24903: PUSH
24904: LD_INT 1
24906: PUSH
24907: EMPTY
24908: LIST
24909: LIST
24910: PUSH
24911: LD_INT 0
24913: PUSH
24914: LD_INT 1
24916: PUSH
24917: EMPTY
24918: LIST
24919: LIST
24920: PUSH
24921: LD_INT 1
24923: NEG
24924: PUSH
24925: LD_INT 0
24927: PUSH
24928: EMPTY
24929: LIST
24930: LIST
24931: PUSH
24932: LD_INT 1
24934: NEG
24935: PUSH
24936: LD_INT 1
24938: NEG
24939: PUSH
24940: EMPTY
24941: LIST
24942: LIST
24943: PUSH
24944: LD_INT 1
24946: NEG
24947: PUSH
24948: LD_INT 2
24950: NEG
24951: PUSH
24952: EMPTY
24953: LIST
24954: LIST
24955: PUSH
24956: LD_INT 0
24958: PUSH
24959: LD_INT 2
24961: NEG
24962: PUSH
24963: EMPTY
24964: LIST
24965: LIST
24966: PUSH
24967: LD_INT 1
24969: PUSH
24970: LD_INT 1
24972: NEG
24973: PUSH
24974: EMPTY
24975: LIST
24976: LIST
24977: PUSH
24978: LD_INT 1
24980: PUSH
24981: LD_INT 2
24983: PUSH
24984: EMPTY
24985: LIST
24986: LIST
24987: PUSH
24988: LD_INT 0
24990: PUSH
24991: LD_INT 2
24993: PUSH
24994: EMPTY
24995: LIST
24996: LIST
24997: PUSH
24998: LD_INT 1
25000: NEG
25001: PUSH
25002: LD_INT 1
25004: PUSH
25005: EMPTY
25006: LIST
25007: LIST
25008: PUSH
25009: LD_INT 1
25011: NEG
25012: PUSH
25013: LD_INT 3
25015: NEG
25016: PUSH
25017: EMPTY
25018: LIST
25019: LIST
25020: PUSH
25021: LD_INT 0
25023: PUSH
25024: LD_INT 3
25026: NEG
25027: PUSH
25028: EMPTY
25029: LIST
25030: LIST
25031: PUSH
25032: LD_INT 1
25034: PUSH
25035: LD_INT 2
25037: NEG
25038: PUSH
25039: EMPTY
25040: LIST
25041: LIST
25042: PUSH
25043: EMPTY
25044: LIST
25045: LIST
25046: LIST
25047: LIST
25048: LIST
25049: LIST
25050: LIST
25051: LIST
25052: LIST
25053: LIST
25054: LIST
25055: LIST
25056: LIST
25057: LIST
25058: LIST
25059: LIST
25060: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
25061: LD_ADDR_VAR 0 15
25065: PUSH
25066: LD_INT 0
25068: PUSH
25069: LD_INT 0
25071: PUSH
25072: EMPTY
25073: LIST
25074: LIST
25075: PUSH
25076: LD_INT 0
25078: PUSH
25079: LD_INT 1
25081: NEG
25082: PUSH
25083: EMPTY
25084: LIST
25085: LIST
25086: PUSH
25087: LD_INT 1
25089: PUSH
25090: LD_INT 0
25092: PUSH
25093: EMPTY
25094: LIST
25095: LIST
25096: PUSH
25097: LD_INT 1
25099: PUSH
25100: LD_INT 1
25102: PUSH
25103: EMPTY
25104: LIST
25105: LIST
25106: PUSH
25107: LD_INT 0
25109: PUSH
25110: LD_INT 1
25112: PUSH
25113: EMPTY
25114: LIST
25115: LIST
25116: PUSH
25117: LD_INT 1
25119: NEG
25120: PUSH
25121: LD_INT 0
25123: PUSH
25124: EMPTY
25125: LIST
25126: LIST
25127: PUSH
25128: LD_INT 1
25130: NEG
25131: PUSH
25132: LD_INT 1
25134: NEG
25135: PUSH
25136: EMPTY
25137: LIST
25138: LIST
25139: PUSH
25140: LD_INT 1
25142: PUSH
25143: LD_INT 1
25145: NEG
25146: PUSH
25147: EMPTY
25148: LIST
25149: LIST
25150: PUSH
25151: LD_INT 2
25153: PUSH
25154: LD_INT 0
25156: PUSH
25157: EMPTY
25158: LIST
25159: LIST
25160: PUSH
25161: LD_INT 2
25163: PUSH
25164: LD_INT 1
25166: PUSH
25167: EMPTY
25168: LIST
25169: LIST
25170: PUSH
25171: LD_INT 1
25173: NEG
25174: PUSH
25175: LD_INT 1
25177: PUSH
25178: EMPTY
25179: LIST
25180: LIST
25181: PUSH
25182: LD_INT 2
25184: NEG
25185: PUSH
25186: LD_INT 0
25188: PUSH
25189: EMPTY
25190: LIST
25191: LIST
25192: PUSH
25193: LD_INT 2
25195: NEG
25196: PUSH
25197: LD_INT 1
25199: NEG
25200: PUSH
25201: EMPTY
25202: LIST
25203: LIST
25204: PUSH
25205: LD_INT 2
25207: PUSH
25208: LD_INT 1
25210: NEG
25211: PUSH
25212: EMPTY
25213: LIST
25214: LIST
25215: PUSH
25216: LD_INT 3
25218: PUSH
25219: LD_INT 0
25221: PUSH
25222: EMPTY
25223: LIST
25224: LIST
25225: PUSH
25226: LD_INT 3
25228: PUSH
25229: LD_INT 1
25231: PUSH
25232: EMPTY
25233: LIST
25234: LIST
25235: PUSH
25236: EMPTY
25237: LIST
25238: LIST
25239: LIST
25240: LIST
25241: LIST
25242: LIST
25243: LIST
25244: LIST
25245: LIST
25246: LIST
25247: LIST
25248: LIST
25249: LIST
25250: LIST
25251: LIST
25252: LIST
25253: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
25254: LD_ADDR_VAR 0 16
25258: PUSH
25259: LD_INT 0
25261: PUSH
25262: LD_INT 0
25264: PUSH
25265: EMPTY
25266: LIST
25267: LIST
25268: PUSH
25269: LD_INT 0
25271: PUSH
25272: LD_INT 1
25274: NEG
25275: PUSH
25276: EMPTY
25277: LIST
25278: LIST
25279: PUSH
25280: LD_INT 1
25282: PUSH
25283: LD_INT 0
25285: PUSH
25286: EMPTY
25287: LIST
25288: LIST
25289: PUSH
25290: LD_INT 1
25292: PUSH
25293: LD_INT 1
25295: PUSH
25296: EMPTY
25297: LIST
25298: LIST
25299: PUSH
25300: LD_INT 0
25302: PUSH
25303: LD_INT 1
25305: PUSH
25306: EMPTY
25307: LIST
25308: LIST
25309: PUSH
25310: LD_INT 1
25312: NEG
25313: PUSH
25314: LD_INT 0
25316: PUSH
25317: EMPTY
25318: LIST
25319: LIST
25320: PUSH
25321: LD_INT 1
25323: NEG
25324: PUSH
25325: LD_INT 1
25327: NEG
25328: PUSH
25329: EMPTY
25330: LIST
25331: LIST
25332: PUSH
25333: LD_INT 1
25335: NEG
25336: PUSH
25337: LD_INT 2
25339: NEG
25340: PUSH
25341: EMPTY
25342: LIST
25343: LIST
25344: PUSH
25345: LD_INT 2
25347: PUSH
25348: LD_INT 1
25350: PUSH
25351: EMPTY
25352: LIST
25353: LIST
25354: PUSH
25355: LD_INT 2
25357: PUSH
25358: LD_INT 2
25360: PUSH
25361: EMPTY
25362: LIST
25363: LIST
25364: PUSH
25365: LD_INT 1
25367: PUSH
25368: LD_INT 2
25370: PUSH
25371: EMPTY
25372: LIST
25373: LIST
25374: PUSH
25375: LD_INT 2
25377: NEG
25378: PUSH
25379: LD_INT 1
25381: NEG
25382: PUSH
25383: EMPTY
25384: LIST
25385: LIST
25386: PUSH
25387: LD_INT 2
25389: NEG
25390: PUSH
25391: LD_INT 2
25393: NEG
25394: PUSH
25395: EMPTY
25396: LIST
25397: LIST
25398: PUSH
25399: LD_INT 3
25401: PUSH
25402: LD_INT 2
25404: PUSH
25405: EMPTY
25406: LIST
25407: LIST
25408: PUSH
25409: LD_INT 3
25411: PUSH
25412: LD_INT 3
25414: PUSH
25415: EMPTY
25416: LIST
25417: LIST
25418: PUSH
25419: LD_INT 2
25421: PUSH
25422: LD_INT 3
25424: PUSH
25425: EMPTY
25426: LIST
25427: LIST
25428: PUSH
25429: EMPTY
25430: LIST
25431: LIST
25432: LIST
25433: LIST
25434: LIST
25435: LIST
25436: LIST
25437: LIST
25438: LIST
25439: LIST
25440: LIST
25441: LIST
25442: LIST
25443: LIST
25444: LIST
25445: LIST
25446: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25447: LD_ADDR_VAR 0 17
25451: PUSH
25452: LD_INT 0
25454: PUSH
25455: LD_INT 0
25457: PUSH
25458: EMPTY
25459: LIST
25460: LIST
25461: PUSH
25462: LD_INT 0
25464: PUSH
25465: LD_INT 1
25467: NEG
25468: PUSH
25469: EMPTY
25470: LIST
25471: LIST
25472: PUSH
25473: LD_INT 1
25475: PUSH
25476: LD_INT 0
25478: PUSH
25479: EMPTY
25480: LIST
25481: LIST
25482: PUSH
25483: LD_INT 1
25485: PUSH
25486: LD_INT 1
25488: PUSH
25489: EMPTY
25490: LIST
25491: LIST
25492: PUSH
25493: LD_INT 0
25495: PUSH
25496: LD_INT 1
25498: PUSH
25499: EMPTY
25500: LIST
25501: LIST
25502: PUSH
25503: LD_INT 1
25505: NEG
25506: PUSH
25507: LD_INT 0
25509: PUSH
25510: EMPTY
25511: LIST
25512: LIST
25513: PUSH
25514: LD_INT 1
25516: NEG
25517: PUSH
25518: LD_INT 1
25520: NEG
25521: PUSH
25522: EMPTY
25523: LIST
25524: LIST
25525: PUSH
25526: LD_INT 1
25528: NEG
25529: PUSH
25530: LD_INT 2
25532: NEG
25533: PUSH
25534: EMPTY
25535: LIST
25536: LIST
25537: PUSH
25538: LD_INT 0
25540: PUSH
25541: LD_INT 2
25543: NEG
25544: PUSH
25545: EMPTY
25546: LIST
25547: LIST
25548: PUSH
25549: LD_INT 1
25551: PUSH
25552: LD_INT 1
25554: NEG
25555: PUSH
25556: EMPTY
25557: LIST
25558: LIST
25559: PUSH
25560: LD_INT 2
25562: PUSH
25563: LD_INT 0
25565: PUSH
25566: EMPTY
25567: LIST
25568: LIST
25569: PUSH
25570: LD_INT 2
25572: PUSH
25573: LD_INT 1
25575: PUSH
25576: EMPTY
25577: LIST
25578: LIST
25579: PUSH
25580: LD_INT 2
25582: PUSH
25583: LD_INT 2
25585: PUSH
25586: EMPTY
25587: LIST
25588: LIST
25589: PUSH
25590: LD_INT 1
25592: PUSH
25593: LD_INT 2
25595: PUSH
25596: EMPTY
25597: LIST
25598: LIST
25599: PUSH
25600: LD_INT 0
25602: PUSH
25603: LD_INT 2
25605: PUSH
25606: EMPTY
25607: LIST
25608: LIST
25609: PUSH
25610: LD_INT 1
25612: NEG
25613: PUSH
25614: LD_INT 1
25616: PUSH
25617: EMPTY
25618: LIST
25619: LIST
25620: PUSH
25621: LD_INT 2
25623: NEG
25624: PUSH
25625: LD_INT 0
25627: PUSH
25628: EMPTY
25629: LIST
25630: LIST
25631: PUSH
25632: LD_INT 2
25634: NEG
25635: PUSH
25636: LD_INT 1
25638: NEG
25639: PUSH
25640: EMPTY
25641: LIST
25642: LIST
25643: PUSH
25644: LD_INT 2
25646: NEG
25647: PUSH
25648: LD_INT 2
25650: NEG
25651: PUSH
25652: EMPTY
25653: LIST
25654: LIST
25655: PUSH
25656: EMPTY
25657: LIST
25658: LIST
25659: LIST
25660: LIST
25661: LIST
25662: LIST
25663: LIST
25664: LIST
25665: LIST
25666: LIST
25667: LIST
25668: LIST
25669: LIST
25670: LIST
25671: LIST
25672: LIST
25673: LIST
25674: LIST
25675: LIST
25676: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25677: LD_ADDR_VAR 0 18
25681: PUSH
25682: LD_INT 0
25684: PUSH
25685: LD_INT 0
25687: PUSH
25688: EMPTY
25689: LIST
25690: LIST
25691: PUSH
25692: LD_INT 0
25694: PUSH
25695: LD_INT 1
25697: NEG
25698: PUSH
25699: EMPTY
25700: LIST
25701: LIST
25702: PUSH
25703: LD_INT 1
25705: PUSH
25706: LD_INT 0
25708: PUSH
25709: EMPTY
25710: LIST
25711: LIST
25712: PUSH
25713: LD_INT 1
25715: PUSH
25716: LD_INT 1
25718: PUSH
25719: EMPTY
25720: LIST
25721: LIST
25722: PUSH
25723: LD_INT 0
25725: PUSH
25726: LD_INT 1
25728: PUSH
25729: EMPTY
25730: LIST
25731: LIST
25732: PUSH
25733: LD_INT 1
25735: NEG
25736: PUSH
25737: LD_INT 0
25739: PUSH
25740: EMPTY
25741: LIST
25742: LIST
25743: PUSH
25744: LD_INT 1
25746: NEG
25747: PUSH
25748: LD_INT 1
25750: NEG
25751: PUSH
25752: EMPTY
25753: LIST
25754: LIST
25755: PUSH
25756: LD_INT 1
25758: NEG
25759: PUSH
25760: LD_INT 2
25762: NEG
25763: PUSH
25764: EMPTY
25765: LIST
25766: LIST
25767: PUSH
25768: LD_INT 0
25770: PUSH
25771: LD_INT 2
25773: NEG
25774: PUSH
25775: EMPTY
25776: LIST
25777: LIST
25778: PUSH
25779: LD_INT 1
25781: PUSH
25782: LD_INT 1
25784: NEG
25785: PUSH
25786: EMPTY
25787: LIST
25788: LIST
25789: PUSH
25790: LD_INT 2
25792: PUSH
25793: LD_INT 0
25795: PUSH
25796: EMPTY
25797: LIST
25798: LIST
25799: PUSH
25800: LD_INT 2
25802: PUSH
25803: LD_INT 1
25805: PUSH
25806: EMPTY
25807: LIST
25808: LIST
25809: PUSH
25810: LD_INT 2
25812: PUSH
25813: LD_INT 2
25815: PUSH
25816: EMPTY
25817: LIST
25818: LIST
25819: PUSH
25820: LD_INT 1
25822: PUSH
25823: LD_INT 2
25825: PUSH
25826: EMPTY
25827: LIST
25828: LIST
25829: PUSH
25830: LD_INT 0
25832: PUSH
25833: LD_INT 2
25835: PUSH
25836: EMPTY
25837: LIST
25838: LIST
25839: PUSH
25840: LD_INT 1
25842: NEG
25843: PUSH
25844: LD_INT 1
25846: PUSH
25847: EMPTY
25848: LIST
25849: LIST
25850: PUSH
25851: LD_INT 2
25853: NEG
25854: PUSH
25855: LD_INT 0
25857: PUSH
25858: EMPTY
25859: LIST
25860: LIST
25861: PUSH
25862: LD_INT 2
25864: NEG
25865: PUSH
25866: LD_INT 1
25868: NEG
25869: PUSH
25870: EMPTY
25871: LIST
25872: LIST
25873: PUSH
25874: LD_INT 2
25876: NEG
25877: PUSH
25878: LD_INT 2
25880: NEG
25881: PUSH
25882: EMPTY
25883: LIST
25884: LIST
25885: PUSH
25886: EMPTY
25887: LIST
25888: LIST
25889: LIST
25890: LIST
25891: LIST
25892: LIST
25893: LIST
25894: LIST
25895: LIST
25896: LIST
25897: LIST
25898: LIST
25899: LIST
25900: LIST
25901: LIST
25902: LIST
25903: LIST
25904: LIST
25905: LIST
25906: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25907: LD_ADDR_VAR 0 19
25911: PUSH
25912: LD_INT 0
25914: PUSH
25915: LD_INT 0
25917: PUSH
25918: EMPTY
25919: LIST
25920: LIST
25921: PUSH
25922: LD_INT 0
25924: PUSH
25925: LD_INT 1
25927: NEG
25928: PUSH
25929: EMPTY
25930: LIST
25931: LIST
25932: PUSH
25933: LD_INT 1
25935: PUSH
25936: LD_INT 0
25938: PUSH
25939: EMPTY
25940: LIST
25941: LIST
25942: PUSH
25943: LD_INT 1
25945: PUSH
25946: LD_INT 1
25948: PUSH
25949: EMPTY
25950: LIST
25951: LIST
25952: PUSH
25953: LD_INT 0
25955: PUSH
25956: LD_INT 1
25958: PUSH
25959: EMPTY
25960: LIST
25961: LIST
25962: PUSH
25963: LD_INT 1
25965: NEG
25966: PUSH
25967: LD_INT 0
25969: PUSH
25970: EMPTY
25971: LIST
25972: LIST
25973: PUSH
25974: LD_INT 1
25976: NEG
25977: PUSH
25978: LD_INT 1
25980: NEG
25981: PUSH
25982: EMPTY
25983: LIST
25984: LIST
25985: PUSH
25986: LD_INT 1
25988: NEG
25989: PUSH
25990: LD_INT 2
25992: NEG
25993: PUSH
25994: EMPTY
25995: LIST
25996: LIST
25997: PUSH
25998: LD_INT 0
26000: PUSH
26001: LD_INT 2
26003: NEG
26004: PUSH
26005: EMPTY
26006: LIST
26007: LIST
26008: PUSH
26009: LD_INT 1
26011: PUSH
26012: LD_INT 1
26014: NEG
26015: PUSH
26016: EMPTY
26017: LIST
26018: LIST
26019: PUSH
26020: LD_INT 2
26022: PUSH
26023: LD_INT 0
26025: PUSH
26026: EMPTY
26027: LIST
26028: LIST
26029: PUSH
26030: LD_INT 2
26032: PUSH
26033: LD_INT 1
26035: PUSH
26036: EMPTY
26037: LIST
26038: LIST
26039: PUSH
26040: LD_INT 2
26042: PUSH
26043: LD_INT 2
26045: PUSH
26046: EMPTY
26047: LIST
26048: LIST
26049: PUSH
26050: LD_INT 1
26052: PUSH
26053: LD_INT 2
26055: PUSH
26056: EMPTY
26057: LIST
26058: LIST
26059: PUSH
26060: LD_INT 0
26062: PUSH
26063: LD_INT 2
26065: PUSH
26066: EMPTY
26067: LIST
26068: LIST
26069: PUSH
26070: LD_INT 1
26072: NEG
26073: PUSH
26074: LD_INT 1
26076: PUSH
26077: EMPTY
26078: LIST
26079: LIST
26080: PUSH
26081: LD_INT 2
26083: NEG
26084: PUSH
26085: LD_INT 0
26087: PUSH
26088: EMPTY
26089: LIST
26090: LIST
26091: PUSH
26092: LD_INT 2
26094: NEG
26095: PUSH
26096: LD_INT 1
26098: NEG
26099: PUSH
26100: EMPTY
26101: LIST
26102: LIST
26103: PUSH
26104: LD_INT 2
26106: NEG
26107: PUSH
26108: LD_INT 2
26110: NEG
26111: PUSH
26112: EMPTY
26113: LIST
26114: LIST
26115: PUSH
26116: EMPTY
26117: LIST
26118: LIST
26119: LIST
26120: LIST
26121: LIST
26122: LIST
26123: LIST
26124: LIST
26125: LIST
26126: LIST
26127: LIST
26128: LIST
26129: LIST
26130: LIST
26131: LIST
26132: LIST
26133: LIST
26134: LIST
26135: LIST
26136: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26137: LD_ADDR_VAR 0 20
26141: PUSH
26142: LD_INT 0
26144: PUSH
26145: LD_INT 0
26147: PUSH
26148: EMPTY
26149: LIST
26150: LIST
26151: PUSH
26152: LD_INT 0
26154: PUSH
26155: LD_INT 1
26157: NEG
26158: PUSH
26159: EMPTY
26160: LIST
26161: LIST
26162: PUSH
26163: LD_INT 1
26165: PUSH
26166: LD_INT 0
26168: PUSH
26169: EMPTY
26170: LIST
26171: LIST
26172: PUSH
26173: LD_INT 1
26175: PUSH
26176: LD_INT 1
26178: PUSH
26179: EMPTY
26180: LIST
26181: LIST
26182: PUSH
26183: LD_INT 0
26185: PUSH
26186: LD_INT 1
26188: PUSH
26189: EMPTY
26190: LIST
26191: LIST
26192: PUSH
26193: LD_INT 1
26195: NEG
26196: PUSH
26197: LD_INT 0
26199: PUSH
26200: EMPTY
26201: LIST
26202: LIST
26203: PUSH
26204: LD_INT 1
26206: NEG
26207: PUSH
26208: LD_INT 1
26210: NEG
26211: PUSH
26212: EMPTY
26213: LIST
26214: LIST
26215: PUSH
26216: LD_INT 1
26218: NEG
26219: PUSH
26220: LD_INT 2
26222: NEG
26223: PUSH
26224: EMPTY
26225: LIST
26226: LIST
26227: PUSH
26228: LD_INT 0
26230: PUSH
26231: LD_INT 2
26233: NEG
26234: PUSH
26235: EMPTY
26236: LIST
26237: LIST
26238: PUSH
26239: LD_INT 1
26241: PUSH
26242: LD_INT 1
26244: NEG
26245: PUSH
26246: EMPTY
26247: LIST
26248: LIST
26249: PUSH
26250: LD_INT 2
26252: PUSH
26253: LD_INT 0
26255: PUSH
26256: EMPTY
26257: LIST
26258: LIST
26259: PUSH
26260: LD_INT 2
26262: PUSH
26263: LD_INT 1
26265: PUSH
26266: EMPTY
26267: LIST
26268: LIST
26269: PUSH
26270: LD_INT 2
26272: PUSH
26273: LD_INT 2
26275: PUSH
26276: EMPTY
26277: LIST
26278: LIST
26279: PUSH
26280: LD_INT 1
26282: PUSH
26283: LD_INT 2
26285: PUSH
26286: EMPTY
26287: LIST
26288: LIST
26289: PUSH
26290: LD_INT 0
26292: PUSH
26293: LD_INT 2
26295: PUSH
26296: EMPTY
26297: LIST
26298: LIST
26299: PUSH
26300: LD_INT 1
26302: NEG
26303: PUSH
26304: LD_INT 1
26306: PUSH
26307: EMPTY
26308: LIST
26309: LIST
26310: PUSH
26311: LD_INT 2
26313: NEG
26314: PUSH
26315: LD_INT 0
26317: PUSH
26318: EMPTY
26319: LIST
26320: LIST
26321: PUSH
26322: LD_INT 2
26324: NEG
26325: PUSH
26326: LD_INT 1
26328: NEG
26329: PUSH
26330: EMPTY
26331: LIST
26332: LIST
26333: PUSH
26334: LD_INT 2
26336: NEG
26337: PUSH
26338: LD_INT 2
26340: NEG
26341: PUSH
26342: EMPTY
26343: LIST
26344: LIST
26345: PUSH
26346: EMPTY
26347: LIST
26348: LIST
26349: LIST
26350: LIST
26351: LIST
26352: LIST
26353: LIST
26354: LIST
26355: LIST
26356: LIST
26357: LIST
26358: LIST
26359: LIST
26360: LIST
26361: LIST
26362: LIST
26363: LIST
26364: LIST
26365: LIST
26366: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26367: LD_ADDR_VAR 0 21
26371: PUSH
26372: LD_INT 0
26374: PUSH
26375: LD_INT 0
26377: PUSH
26378: EMPTY
26379: LIST
26380: LIST
26381: PUSH
26382: LD_INT 0
26384: PUSH
26385: LD_INT 1
26387: NEG
26388: PUSH
26389: EMPTY
26390: LIST
26391: LIST
26392: PUSH
26393: LD_INT 1
26395: PUSH
26396: LD_INT 0
26398: PUSH
26399: EMPTY
26400: LIST
26401: LIST
26402: PUSH
26403: LD_INT 1
26405: PUSH
26406: LD_INT 1
26408: PUSH
26409: EMPTY
26410: LIST
26411: LIST
26412: PUSH
26413: LD_INT 0
26415: PUSH
26416: LD_INT 1
26418: PUSH
26419: EMPTY
26420: LIST
26421: LIST
26422: PUSH
26423: LD_INT 1
26425: NEG
26426: PUSH
26427: LD_INT 0
26429: PUSH
26430: EMPTY
26431: LIST
26432: LIST
26433: PUSH
26434: LD_INT 1
26436: NEG
26437: PUSH
26438: LD_INT 1
26440: NEG
26441: PUSH
26442: EMPTY
26443: LIST
26444: LIST
26445: PUSH
26446: LD_INT 1
26448: NEG
26449: PUSH
26450: LD_INT 2
26452: NEG
26453: PUSH
26454: EMPTY
26455: LIST
26456: LIST
26457: PUSH
26458: LD_INT 0
26460: PUSH
26461: LD_INT 2
26463: NEG
26464: PUSH
26465: EMPTY
26466: LIST
26467: LIST
26468: PUSH
26469: LD_INT 1
26471: PUSH
26472: LD_INT 1
26474: NEG
26475: PUSH
26476: EMPTY
26477: LIST
26478: LIST
26479: PUSH
26480: LD_INT 2
26482: PUSH
26483: LD_INT 0
26485: PUSH
26486: EMPTY
26487: LIST
26488: LIST
26489: PUSH
26490: LD_INT 2
26492: PUSH
26493: LD_INT 1
26495: PUSH
26496: EMPTY
26497: LIST
26498: LIST
26499: PUSH
26500: LD_INT 2
26502: PUSH
26503: LD_INT 2
26505: PUSH
26506: EMPTY
26507: LIST
26508: LIST
26509: PUSH
26510: LD_INT 1
26512: PUSH
26513: LD_INT 2
26515: PUSH
26516: EMPTY
26517: LIST
26518: LIST
26519: PUSH
26520: LD_INT 0
26522: PUSH
26523: LD_INT 2
26525: PUSH
26526: EMPTY
26527: LIST
26528: LIST
26529: PUSH
26530: LD_INT 1
26532: NEG
26533: PUSH
26534: LD_INT 1
26536: PUSH
26537: EMPTY
26538: LIST
26539: LIST
26540: PUSH
26541: LD_INT 2
26543: NEG
26544: PUSH
26545: LD_INT 0
26547: PUSH
26548: EMPTY
26549: LIST
26550: LIST
26551: PUSH
26552: LD_INT 2
26554: NEG
26555: PUSH
26556: LD_INT 1
26558: NEG
26559: PUSH
26560: EMPTY
26561: LIST
26562: LIST
26563: PUSH
26564: LD_INT 2
26566: NEG
26567: PUSH
26568: LD_INT 2
26570: NEG
26571: PUSH
26572: EMPTY
26573: LIST
26574: LIST
26575: PUSH
26576: EMPTY
26577: LIST
26578: LIST
26579: LIST
26580: LIST
26581: LIST
26582: LIST
26583: LIST
26584: LIST
26585: LIST
26586: LIST
26587: LIST
26588: LIST
26589: LIST
26590: LIST
26591: LIST
26592: LIST
26593: LIST
26594: LIST
26595: LIST
26596: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26597: LD_ADDR_VAR 0 22
26601: PUSH
26602: LD_INT 0
26604: PUSH
26605: LD_INT 0
26607: PUSH
26608: EMPTY
26609: LIST
26610: LIST
26611: PUSH
26612: LD_INT 0
26614: PUSH
26615: LD_INT 1
26617: NEG
26618: PUSH
26619: EMPTY
26620: LIST
26621: LIST
26622: PUSH
26623: LD_INT 1
26625: PUSH
26626: LD_INT 0
26628: PUSH
26629: EMPTY
26630: LIST
26631: LIST
26632: PUSH
26633: LD_INT 1
26635: PUSH
26636: LD_INT 1
26638: PUSH
26639: EMPTY
26640: LIST
26641: LIST
26642: PUSH
26643: LD_INT 0
26645: PUSH
26646: LD_INT 1
26648: PUSH
26649: EMPTY
26650: LIST
26651: LIST
26652: PUSH
26653: LD_INT 1
26655: NEG
26656: PUSH
26657: LD_INT 0
26659: PUSH
26660: EMPTY
26661: LIST
26662: LIST
26663: PUSH
26664: LD_INT 1
26666: NEG
26667: PUSH
26668: LD_INT 1
26670: NEG
26671: PUSH
26672: EMPTY
26673: LIST
26674: LIST
26675: PUSH
26676: LD_INT 1
26678: NEG
26679: PUSH
26680: LD_INT 2
26682: NEG
26683: PUSH
26684: EMPTY
26685: LIST
26686: LIST
26687: PUSH
26688: LD_INT 0
26690: PUSH
26691: LD_INT 2
26693: NEG
26694: PUSH
26695: EMPTY
26696: LIST
26697: LIST
26698: PUSH
26699: LD_INT 1
26701: PUSH
26702: LD_INT 1
26704: NEG
26705: PUSH
26706: EMPTY
26707: LIST
26708: LIST
26709: PUSH
26710: LD_INT 2
26712: PUSH
26713: LD_INT 0
26715: PUSH
26716: EMPTY
26717: LIST
26718: LIST
26719: PUSH
26720: LD_INT 2
26722: PUSH
26723: LD_INT 1
26725: PUSH
26726: EMPTY
26727: LIST
26728: LIST
26729: PUSH
26730: LD_INT 2
26732: PUSH
26733: LD_INT 2
26735: PUSH
26736: EMPTY
26737: LIST
26738: LIST
26739: PUSH
26740: LD_INT 1
26742: PUSH
26743: LD_INT 2
26745: PUSH
26746: EMPTY
26747: LIST
26748: LIST
26749: PUSH
26750: LD_INT 0
26752: PUSH
26753: LD_INT 2
26755: PUSH
26756: EMPTY
26757: LIST
26758: LIST
26759: PUSH
26760: LD_INT 1
26762: NEG
26763: PUSH
26764: LD_INT 1
26766: PUSH
26767: EMPTY
26768: LIST
26769: LIST
26770: PUSH
26771: LD_INT 2
26773: NEG
26774: PUSH
26775: LD_INT 0
26777: PUSH
26778: EMPTY
26779: LIST
26780: LIST
26781: PUSH
26782: LD_INT 2
26784: NEG
26785: PUSH
26786: LD_INT 1
26788: NEG
26789: PUSH
26790: EMPTY
26791: LIST
26792: LIST
26793: PUSH
26794: LD_INT 2
26796: NEG
26797: PUSH
26798: LD_INT 2
26800: NEG
26801: PUSH
26802: EMPTY
26803: LIST
26804: LIST
26805: PUSH
26806: EMPTY
26807: LIST
26808: LIST
26809: LIST
26810: LIST
26811: LIST
26812: LIST
26813: LIST
26814: LIST
26815: LIST
26816: LIST
26817: LIST
26818: LIST
26819: LIST
26820: LIST
26821: LIST
26822: LIST
26823: LIST
26824: LIST
26825: LIST
26826: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
26827: LD_ADDR_VAR 0 23
26831: PUSH
26832: LD_INT 0
26834: PUSH
26835: LD_INT 0
26837: PUSH
26838: EMPTY
26839: LIST
26840: LIST
26841: PUSH
26842: LD_INT 0
26844: PUSH
26845: LD_INT 1
26847: NEG
26848: PUSH
26849: EMPTY
26850: LIST
26851: LIST
26852: PUSH
26853: LD_INT 1
26855: PUSH
26856: LD_INT 0
26858: PUSH
26859: EMPTY
26860: LIST
26861: LIST
26862: PUSH
26863: LD_INT 1
26865: PUSH
26866: LD_INT 1
26868: PUSH
26869: EMPTY
26870: LIST
26871: LIST
26872: PUSH
26873: LD_INT 0
26875: PUSH
26876: LD_INT 1
26878: PUSH
26879: EMPTY
26880: LIST
26881: LIST
26882: PUSH
26883: LD_INT 1
26885: NEG
26886: PUSH
26887: LD_INT 0
26889: PUSH
26890: EMPTY
26891: LIST
26892: LIST
26893: PUSH
26894: LD_INT 1
26896: NEG
26897: PUSH
26898: LD_INT 1
26900: NEG
26901: PUSH
26902: EMPTY
26903: LIST
26904: LIST
26905: PUSH
26906: LD_INT 1
26908: NEG
26909: PUSH
26910: LD_INT 2
26912: NEG
26913: PUSH
26914: EMPTY
26915: LIST
26916: LIST
26917: PUSH
26918: LD_INT 0
26920: PUSH
26921: LD_INT 2
26923: NEG
26924: PUSH
26925: EMPTY
26926: LIST
26927: LIST
26928: PUSH
26929: LD_INT 1
26931: PUSH
26932: LD_INT 1
26934: NEG
26935: PUSH
26936: EMPTY
26937: LIST
26938: LIST
26939: PUSH
26940: LD_INT 2
26942: PUSH
26943: LD_INT 0
26945: PUSH
26946: EMPTY
26947: LIST
26948: LIST
26949: PUSH
26950: LD_INT 2
26952: PUSH
26953: LD_INT 1
26955: PUSH
26956: EMPTY
26957: LIST
26958: LIST
26959: PUSH
26960: LD_INT 2
26962: PUSH
26963: LD_INT 2
26965: PUSH
26966: EMPTY
26967: LIST
26968: LIST
26969: PUSH
26970: LD_INT 1
26972: PUSH
26973: LD_INT 2
26975: PUSH
26976: EMPTY
26977: LIST
26978: LIST
26979: PUSH
26980: LD_INT 0
26982: PUSH
26983: LD_INT 2
26985: PUSH
26986: EMPTY
26987: LIST
26988: LIST
26989: PUSH
26990: LD_INT 1
26992: NEG
26993: PUSH
26994: LD_INT 1
26996: PUSH
26997: EMPTY
26998: LIST
26999: LIST
27000: PUSH
27001: LD_INT 2
27003: NEG
27004: PUSH
27005: LD_INT 0
27007: PUSH
27008: EMPTY
27009: LIST
27010: LIST
27011: PUSH
27012: LD_INT 2
27014: NEG
27015: PUSH
27016: LD_INT 1
27018: NEG
27019: PUSH
27020: EMPTY
27021: LIST
27022: LIST
27023: PUSH
27024: LD_INT 2
27026: NEG
27027: PUSH
27028: LD_INT 2
27030: NEG
27031: PUSH
27032: EMPTY
27033: LIST
27034: LIST
27035: PUSH
27036: LD_INT 2
27038: NEG
27039: PUSH
27040: LD_INT 3
27042: NEG
27043: PUSH
27044: EMPTY
27045: LIST
27046: LIST
27047: PUSH
27048: LD_INT 1
27050: NEG
27051: PUSH
27052: LD_INT 3
27054: NEG
27055: PUSH
27056: EMPTY
27057: LIST
27058: LIST
27059: PUSH
27060: LD_INT 1
27062: PUSH
27063: LD_INT 2
27065: NEG
27066: PUSH
27067: EMPTY
27068: LIST
27069: LIST
27070: PUSH
27071: LD_INT 2
27073: PUSH
27074: LD_INT 1
27076: NEG
27077: PUSH
27078: EMPTY
27079: LIST
27080: LIST
27081: PUSH
27082: EMPTY
27083: LIST
27084: LIST
27085: LIST
27086: LIST
27087: LIST
27088: LIST
27089: LIST
27090: LIST
27091: LIST
27092: LIST
27093: LIST
27094: LIST
27095: LIST
27096: LIST
27097: LIST
27098: LIST
27099: LIST
27100: LIST
27101: LIST
27102: LIST
27103: LIST
27104: LIST
27105: LIST
27106: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
27107: LD_ADDR_VAR 0 24
27111: PUSH
27112: LD_INT 0
27114: PUSH
27115: LD_INT 0
27117: PUSH
27118: EMPTY
27119: LIST
27120: LIST
27121: PUSH
27122: LD_INT 0
27124: PUSH
27125: LD_INT 1
27127: NEG
27128: PUSH
27129: EMPTY
27130: LIST
27131: LIST
27132: PUSH
27133: LD_INT 1
27135: PUSH
27136: LD_INT 0
27138: PUSH
27139: EMPTY
27140: LIST
27141: LIST
27142: PUSH
27143: LD_INT 1
27145: PUSH
27146: LD_INT 1
27148: PUSH
27149: EMPTY
27150: LIST
27151: LIST
27152: PUSH
27153: LD_INT 0
27155: PUSH
27156: LD_INT 1
27158: PUSH
27159: EMPTY
27160: LIST
27161: LIST
27162: PUSH
27163: LD_INT 1
27165: NEG
27166: PUSH
27167: LD_INT 0
27169: PUSH
27170: EMPTY
27171: LIST
27172: LIST
27173: PUSH
27174: LD_INT 1
27176: NEG
27177: PUSH
27178: LD_INT 1
27180: NEG
27181: PUSH
27182: EMPTY
27183: LIST
27184: LIST
27185: PUSH
27186: LD_INT 1
27188: NEG
27189: PUSH
27190: LD_INT 2
27192: NEG
27193: PUSH
27194: EMPTY
27195: LIST
27196: LIST
27197: PUSH
27198: LD_INT 0
27200: PUSH
27201: LD_INT 2
27203: NEG
27204: PUSH
27205: EMPTY
27206: LIST
27207: LIST
27208: PUSH
27209: LD_INT 1
27211: PUSH
27212: LD_INT 1
27214: NEG
27215: PUSH
27216: EMPTY
27217: LIST
27218: LIST
27219: PUSH
27220: LD_INT 2
27222: PUSH
27223: LD_INT 0
27225: PUSH
27226: EMPTY
27227: LIST
27228: LIST
27229: PUSH
27230: LD_INT 2
27232: PUSH
27233: LD_INT 1
27235: PUSH
27236: EMPTY
27237: LIST
27238: LIST
27239: PUSH
27240: LD_INT 2
27242: PUSH
27243: LD_INT 2
27245: PUSH
27246: EMPTY
27247: LIST
27248: LIST
27249: PUSH
27250: LD_INT 1
27252: PUSH
27253: LD_INT 2
27255: PUSH
27256: EMPTY
27257: LIST
27258: LIST
27259: PUSH
27260: LD_INT 0
27262: PUSH
27263: LD_INT 2
27265: PUSH
27266: EMPTY
27267: LIST
27268: LIST
27269: PUSH
27270: LD_INT 1
27272: NEG
27273: PUSH
27274: LD_INT 1
27276: PUSH
27277: EMPTY
27278: LIST
27279: LIST
27280: PUSH
27281: LD_INT 2
27283: NEG
27284: PUSH
27285: LD_INT 0
27287: PUSH
27288: EMPTY
27289: LIST
27290: LIST
27291: PUSH
27292: LD_INT 2
27294: NEG
27295: PUSH
27296: LD_INT 1
27298: NEG
27299: PUSH
27300: EMPTY
27301: LIST
27302: LIST
27303: PUSH
27304: LD_INT 2
27306: NEG
27307: PUSH
27308: LD_INT 2
27310: NEG
27311: PUSH
27312: EMPTY
27313: LIST
27314: LIST
27315: PUSH
27316: LD_INT 1
27318: PUSH
27319: LD_INT 2
27321: NEG
27322: PUSH
27323: EMPTY
27324: LIST
27325: LIST
27326: PUSH
27327: LD_INT 2
27329: PUSH
27330: LD_INT 1
27332: NEG
27333: PUSH
27334: EMPTY
27335: LIST
27336: LIST
27337: PUSH
27338: LD_INT 3
27340: PUSH
27341: LD_INT 1
27343: PUSH
27344: EMPTY
27345: LIST
27346: LIST
27347: PUSH
27348: LD_INT 3
27350: PUSH
27351: LD_INT 2
27353: PUSH
27354: EMPTY
27355: LIST
27356: LIST
27357: PUSH
27358: EMPTY
27359: LIST
27360: LIST
27361: LIST
27362: LIST
27363: LIST
27364: LIST
27365: LIST
27366: LIST
27367: LIST
27368: LIST
27369: LIST
27370: LIST
27371: LIST
27372: LIST
27373: LIST
27374: LIST
27375: LIST
27376: LIST
27377: LIST
27378: LIST
27379: LIST
27380: LIST
27381: LIST
27382: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
27383: LD_ADDR_VAR 0 25
27387: PUSH
27388: LD_INT 0
27390: PUSH
27391: LD_INT 0
27393: PUSH
27394: EMPTY
27395: LIST
27396: LIST
27397: PUSH
27398: LD_INT 0
27400: PUSH
27401: LD_INT 1
27403: NEG
27404: PUSH
27405: EMPTY
27406: LIST
27407: LIST
27408: PUSH
27409: LD_INT 1
27411: PUSH
27412: LD_INT 0
27414: PUSH
27415: EMPTY
27416: LIST
27417: LIST
27418: PUSH
27419: LD_INT 1
27421: PUSH
27422: LD_INT 1
27424: PUSH
27425: EMPTY
27426: LIST
27427: LIST
27428: PUSH
27429: LD_INT 0
27431: PUSH
27432: LD_INT 1
27434: PUSH
27435: EMPTY
27436: LIST
27437: LIST
27438: PUSH
27439: LD_INT 1
27441: NEG
27442: PUSH
27443: LD_INT 0
27445: PUSH
27446: EMPTY
27447: LIST
27448: LIST
27449: PUSH
27450: LD_INT 1
27452: NEG
27453: PUSH
27454: LD_INT 1
27456: NEG
27457: PUSH
27458: EMPTY
27459: LIST
27460: LIST
27461: PUSH
27462: LD_INT 1
27464: NEG
27465: PUSH
27466: LD_INT 2
27468: NEG
27469: PUSH
27470: EMPTY
27471: LIST
27472: LIST
27473: PUSH
27474: LD_INT 0
27476: PUSH
27477: LD_INT 2
27479: NEG
27480: PUSH
27481: EMPTY
27482: LIST
27483: LIST
27484: PUSH
27485: LD_INT 1
27487: PUSH
27488: LD_INT 1
27490: NEG
27491: PUSH
27492: EMPTY
27493: LIST
27494: LIST
27495: PUSH
27496: LD_INT 2
27498: PUSH
27499: LD_INT 0
27501: PUSH
27502: EMPTY
27503: LIST
27504: LIST
27505: PUSH
27506: LD_INT 2
27508: PUSH
27509: LD_INT 1
27511: PUSH
27512: EMPTY
27513: LIST
27514: LIST
27515: PUSH
27516: LD_INT 2
27518: PUSH
27519: LD_INT 2
27521: PUSH
27522: EMPTY
27523: LIST
27524: LIST
27525: PUSH
27526: LD_INT 1
27528: PUSH
27529: LD_INT 2
27531: PUSH
27532: EMPTY
27533: LIST
27534: LIST
27535: PUSH
27536: LD_INT 0
27538: PUSH
27539: LD_INT 2
27541: PUSH
27542: EMPTY
27543: LIST
27544: LIST
27545: PUSH
27546: LD_INT 1
27548: NEG
27549: PUSH
27550: LD_INT 1
27552: PUSH
27553: EMPTY
27554: LIST
27555: LIST
27556: PUSH
27557: LD_INT 2
27559: NEG
27560: PUSH
27561: LD_INT 0
27563: PUSH
27564: EMPTY
27565: LIST
27566: LIST
27567: PUSH
27568: LD_INT 2
27570: NEG
27571: PUSH
27572: LD_INT 1
27574: NEG
27575: PUSH
27576: EMPTY
27577: LIST
27578: LIST
27579: PUSH
27580: LD_INT 2
27582: NEG
27583: PUSH
27584: LD_INT 2
27586: NEG
27587: PUSH
27588: EMPTY
27589: LIST
27590: LIST
27591: PUSH
27592: LD_INT 3
27594: PUSH
27595: LD_INT 1
27597: PUSH
27598: EMPTY
27599: LIST
27600: LIST
27601: PUSH
27602: LD_INT 3
27604: PUSH
27605: LD_INT 2
27607: PUSH
27608: EMPTY
27609: LIST
27610: LIST
27611: PUSH
27612: LD_INT 2
27614: PUSH
27615: LD_INT 3
27617: PUSH
27618: EMPTY
27619: LIST
27620: LIST
27621: PUSH
27622: LD_INT 1
27624: PUSH
27625: LD_INT 3
27627: PUSH
27628: EMPTY
27629: LIST
27630: LIST
27631: PUSH
27632: EMPTY
27633: LIST
27634: LIST
27635: LIST
27636: LIST
27637: LIST
27638: LIST
27639: LIST
27640: LIST
27641: LIST
27642: LIST
27643: LIST
27644: LIST
27645: LIST
27646: LIST
27647: LIST
27648: LIST
27649: LIST
27650: LIST
27651: LIST
27652: LIST
27653: LIST
27654: LIST
27655: LIST
27656: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
27657: LD_ADDR_VAR 0 26
27661: PUSH
27662: LD_INT 0
27664: PUSH
27665: LD_INT 0
27667: PUSH
27668: EMPTY
27669: LIST
27670: LIST
27671: PUSH
27672: LD_INT 0
27674: PUSH
27675: LD_INT 1
27677: NEG
27678: PUSH
27679: EMPTY
27680: LIST
27681: LIST
27682: PUSH
27683: LD_INT 1
27685: PUSH
27686: LD_INT 0
27688: PUSH
27689: EMPTY
27690: LIST
27691: LIST
27692: PUSH
27693: LD_INT 1
27695: PUSH
27696: LD_INT 1
27698: PUSH
27699: EMPTY
27700: LIST
27701: LIST
27702: PUSH
27703: LD_INT 0
27705: PUSH
27706: LD_INT 1
27708: PUSH
27709: EMPTY
27710: LIST
27711: LIST
27712: PUSH
27713: LD_INT 1
27715: NEG
27716: PUSH
27717: LD_INT 0
27719: PUSH
27720: EMPTY
27721: LIST
27722: LIST
27723: PUSH
27724: LD_INT 1
27726: NEG
27727: PUSH
27728: LD_INT 1
27730: NEG
27731: PUSH
27732: EMPTY
27733: LIST
27734: LIST
27735: PUSH
27736: LD_INT 1
27738: NEG
27739: PUSH
27740: LD_INT 2
27742: NEG
27743: PUSH
27744: EMPTY
27745: LIST
27746: LIST
27747: PUSH
27748: LD_INT 0
27750: PUSH
27751: LD_INT 2
27753: NEG
27754: PUSH
27755: EMPTY
27756: LIST
27757: LIST
27758: PUSH
27759: LD_INT 1
27761: PUSH
27762: LD_INT 1
27764: NEG
27765: PUSH
27766: EMPTY
27767: LIST
27768: LIST
27769: PUSH
27770: LD_INT 2
27772: PUSH
27773: LD_INT 0
27775: PUSH
27776: EMPTY
27777: LIST
27778: LIST
27779: PUSH
27780: LD_INT 2
27782: PUSH
27783: LD_INT 1
27785: PUSH
27786: EMPTY
27787: LIST
27788: LIST
27789: PUSH
27790: LD_INT 2
27792: PUSH
27793: LD_INT 2
27795: PUSH
27796: EMPTY
27797: LIST
27798: LIST
27799: PUSH
27800: LD_INT 1
27802: PUSH
27803: LD_INT 2
27805: PUSH
27806: EMPTY
27807: LIST
27808: LIST
27809: PUSH
27810: LD_INT 0
27812: PUSH
27813: LD_INT 2
27815: PUSH
27816: EMPTY
27817: LIST
27818: LIST
27819: PUSH
27820: LD_INT 1
27822: NEG
27823: PUSH
27824: LD_INT 1
27826: PUSH
27827: EMPTY
27828: LIST
27829: LIST
27830: PUSH
27831: LD_INT 2
27833: NEG
27834: PUSH
27835: LD_INT 0
27837: PUSH
27838: EMPTY
27839: LIST
27840: LIST
27841: PUSH
27842: LD_INT 2
27844: NEG
27845: PUSH
27846: LD_INT 1
27848: NEG
27849: PUSH
27850: EMPTY
27851: LIST
27852: LIST
27853: PUSH
27854: LD_INT 2
27856: NEG
27857: PUSH
27858: LD_INT 2
27860: NEG
27861: PUSH
27862: EMPTY
27863: LIST
27864: LIST
27865: PUSH
27866: LD_INT 2
27868: PUSH
27869: LD_INT 3
27871: PUSH
27872: EMPTY
27873: LIST
27874: LIST
27875: PUSH
27876: LD_INT 1
27878: PUSH
27879: LD_INT 3
27881: PUSH
27882: EMPTY
27883: LIST
27884: LIST
27885: PUSH
27886: LD_INT 1
27888: NEG
27889: PUSH
27890: LD_INT 2
27892: PUSH
27893: EMPTY
27894: LIST
27895: LIST
27896: PUSH
27897: LD_INT 2
27899: NEG
27900: PUSH
27901: LD_INT 1
27903: PUSH
27904: EMPTY
27905: LIST
27906: LIST
27907: PUSH
27908: EMPTY
27909: LIST
27910: LIST
27911: LIST
27912: LIST
27913: LIST
27914: LIST
27915: LIST
27916: LIST
27917: LIST
27918: LIST
27919: LIST
27920: LIST
27921: LIST
27922: LIST
27923: LIST
27924: LIST
27925: LIST
27926: LIST
27927: LIST
27928: LIST
27929: LIST
27930: LIST
27931: LIST
27932: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
27933: LD_ADDR_VAR 0 27
27937: PUSH
27938: LD_INT 0
27940: PUSH
27941: LD_INT 0
27943: PUSH
27944: EMPTY
27945: LIST
27946: LIST
27947: PUSH
27948: LD_INT 0
27950: PUSH
27951: LD_INT 1
27953: NEG
27954: PUSH
27955: EMPTY
27956: LIST
27957: LIST
27958: PUSH
27959: LD_INT 1
27961: PUSH
27962: LD_INT 0
27964: PUSH
27965: EMPTY
27966: LIST
27967: LIST
27968: PUSH
27969: LD_INT 1
27971: PUSH
27972: LD_INT 1
27974: PUSH
27975: EMPTY
27976: LIST
27977: LIST
27978: PUSH
27979: LD_INT 0
27981: PUSH
27982: LD_INT 1
27984: PUSH
27985: EMPTY
27986: LIST
27987: LIST
27988: PUSH
27989: LD_INT 1
27991: NEG
27992: PUSH
27993: LD_INT 0
27995: PUSH
27996: EMPTY
27997: LIST
27998: LIST
27999: PUSH
28000: LD_INT 1
28002: NEG
28003: PUSH
28004: LD_INT 1
28006: NEG
28007: PUSH
28008: EMPTY
28009: LIST
28010: LIST
28011: PUSH
28012: LD_INT 1
28014: NEG
28015: PUSH
28016: LD_INT 2
28018: NEG
28019: PUSH
28020: EMPTY
28021: LIST
28022: LIST
28023: PUSH
28024: LD_INT 0
28026: PUSH
28027: LD_INT 2
28029: NEG
28030: PUSH
28031: EMPTY
28032: LIST
28033: LIST
28034: PUSH
28035: LD_INT 1
28037: PUSH
28038: LD_INT 1
28040: NEG
28041: PUSH
28042: EMPTY
28043: LIST
28044: LIST
28045: PUSH
28046: LD_INT 2
28048: PUSH
28049: LD_INT 0
28051: PUSH
28052: EMPTY
28053: LIST
28054: LIST
28055: PUSH
28056: LD_INT 2
28058: PUSH
28059: LD_INT 1
28061: PUSH
28062: EMPTY
28063: LIST
28064: LIST
28065: PUSH
28066: LD_INT 2
28068: PUSH
28069: LD_INT 2
28071: PUSH
28072: EMPTY
28073: LIST
28074: LIST
28075: PUSH
28076: LD_INT 1
28078: PUSH
28079: LD_INT 2
28081: PUSH
28082: EMPTY
28083: LIST
28084: LIST
28085: PUSH
28086: LD_INT 0
28088: PUSH
28089: LD_INT 2
28091: PUSH
28092: EMPTY
28093: LIST
28094: LIST
28095: PUSH
28096: LD_INT 1
28098: NEG
28099: PUSH
28100: LD_INT 1
28102: PUSH
28103: EMPTY
28104: LIST
28105: LIST
28106: PUSH
28107: LD_INT 2
28109: NEG
28110: PUSH
28111: LD_INT 0
28113: PUSH
28114: EMPTY
28115: LIST
28116: LIST
28117: PUSH
28118: LD_INT 2
28120: NEG
28121: PUSH
28122: LD_INT 1
28124: NEG
28125: PUSH
28126: EMPTY
28127: LIST
28128: LIST
28129: PUSH
28130: LD_INT 2
28132: NEG
28133: PUSH
28134: LD_INT 2
28136: NEG
28137: PUSH
28138: EMPTY
28139: LIST
28140: LIST
28141: PUSH
28142: LD_INT 1
28144: NEG
28145: PUSH
28146: LD_INT 2
28148: PUSH
28149: EMPTY
28150: LIST
28151: LIST
28152: PUSH
28153: LD_INT 2
28155: NEG
28156: PUSH
28157: LD_INT 1
28159: PUSH
28160: EMPTY
28161: LIST
28162: LIST
28163: PUSH
28164: LD_INT 3
28166: NEG
28167: PUSH
28168: LD_INT 1
28170: NEG
28171: PUSH
28172: EMPTY
28173: LIST
28174: LIST
28175: PUSH
28176: LD_INT 3
28178: NEG
28179: PUSH
28180: LD_INT 2
28182: NEG
28183: PUSH
28184: EMPTY
28185: LIST
28186: LIST
28187: PUSH
28188: EMPTY
28189: LIST
28190: LIST
28191: LIST
28192: LIST
28193: LIST
28194: LIST
28195: LIST
28196: LIST
28197: LIST
28198: LIST
28199: LIST
28200: LIST
28201: LIST
28202: LIST
28203: LIST
28204: LIST
28205: LIST
28206: LIST
28207: LIST
28208: LIST
28209: LIST
28210: LIST
28211: LIST
28212: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
28213: LD_ADDR_VAR 0 28
28217: PUSH
28218: LD_INT 0
28220: PUSH
28221: LD_INT 0
28223: PUSH
28224: EMPTY
28225: LIST
28226: LIST
28227: PUSH
28228: LD_INT 0
28230: PUSH
28231: LD_INT 1
28233: NEG
28234: PUSH
28235: EMPTY
28236: LIST
28237: LIST
28238: PUSH
28239: LD_INT 1
28241: PUSH
28242: LD_INT 0
28244: PUSH
28245: EMPTY
28246: LIST
28247: LIST
28248: PUSH
28249: LD_INT 1
28251: PUSH
28252: LD_INT 1
28254: PUSH
28255: EMPTY
28256: LIST
28257: LIST
28258: PUSH
28259: LD_INT 0
28261: PUSH
28262: LD_INT 1
28264: PUSH
28265: EMPTY
28266: LIST
28267: LIST
28268: PUSH
28269: LD_INT 1
28271: NEG
28272: PUSH
28273: LD_INT 0
28275: PUSH
28276: EMPTY
28277: LIST
28278: LIST
28279: PUSH
28280: LD_INT 1
28282: NEG
28283: PUSH
28284: LD_INT 1
28286: NEG
28287: PUSH
28288: EMPTY
28289: LIST
28290: LIST
28291: PUSH
28292: LD_INT 1
28294: NEG
28295: PUSH
28296: LD_INT 2
28298: NEG
28299: PUSH
28300: EMPTY
28301: LIST
28302: LIST
28303: PUSH
28304: LD_INT 0
28306: PUSH
28307: LD_INT 2
28309: NEG
28310: PUSH
28311: EMPTY
28312: LIST
28313: LIST
28314: PUSH
28315: LD_INT 1
28317: PUSH
28318: LD_INT 1
28320: NEG
28321: PUSH
28322: EMPTY
28323: LIST
28324: LIST
28325: PUSH
28326: LD_INT 2
28328: PUSH
28329: LD_INT 0
28331: PUSH
28332: EMPTY
28333: LIST
28334: LIST
28335: PUSH
28336: LD_INT 2
28338: PUSH
28339: LD_INT 1
28341: PUSH
28342: EMPTY
28343: LIST
28344: LIST
28345: PUSH
28346: LD_INT 2
28348: PUSH
28349: LD_INT 2
28351: PUSH
28352: EMPTY
28353: LIST
28354: LIST
28355: PUSH
28356: LD_INT 1
28358: PUSH
28359: LD_INT 2
28361: PUSH
28362: EMPTY
28363: LIST
28364: LIST
28365: PUSH
28366: LD_INT 0
28368: PUSH
28369: LD_INT 2
28371: PUSH
28372: EMPTY
28373: LIST
28374: LIST
28375: PUSH
28376: LD_INT 1
28378: NEG
28379: PUSH
28380: LD_INT 1
28382: PUSH
28383: EMPTY
28384: LIST
28385: LIST
28386: PUSH
28387: LD_INT 2
28389: NEG
28390: PUSH
28391: LD_INT 0
28393: PUSH
28394: EMPTY
28395: LIST
28396: LIST
28397: PUSH
28398: LD_INT 2
28400: NEG
28401: PUSH
28402: LD_INT 1
28404: NEG
28405: PUSH
28406: EMPTY
28407: LIST
28408: LIST
28409: PUSH
28410: LD_INT 2
28412: NEG
28413: PUSH
28414: LD_INT 2
28416: NEG
28417: PUSH
28418: EMPTY
28419: LIST
28420: LIST
28421: PUSH
28422: LD_INT 2
28424: NEG
28425: PUSH
28426: LD_INT 3
28428: NEG
28429: PUSH
28430: EMPTY
28431: LIST
28432: LIST
28433: PUSH
28434: LD_INT 1
28436: NEG
28437: PUSH
28438: LD_INT 3
28440: NEG
28441: PUSH
28442: EMPTY
28443: LIST
28444: LIST
28445: PUSH
28446: LD_INT 3
28448: NEG
28449: PUSH
28450: LD_INT 1
28452: NEG
28453: PUSH
28454: EMPTY
28455: LIST
28456: LIST
28457: PUSH
28458: LD_INT 3
28460: NEG
28461: PUSH
28462: LD_INT 2
28464: NEG
28465: PUSH
28466: EMPTY
28467: LIST
28468: LIST
28469: PUSH
28470: EMPTY
28471: LIST
28472: LIST
28473: LIST
28474: LIST
28475: LIST
28476: LIST
28477: LIST
28478: LIST
28479: LIST
28480: LIST
28481: LIST
28482: LIST
28483: LIST
28484: LIST
28485: LIST
28486: LIST
28487: LIST
28488: LIST
28489: LIST
28490: LIST
28491: LIST
28492: LIST
28493: LIST
28494: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
28495: LD_ADDR_VAR 0 29
28499: PUSH
28500: LD_INT 0
28502: PUSH
28503: LD_INT 0
28505: PUSH
28506: EMPTY
28507: LIST
28508: LIST
28509: PUSH
28510: LD_INT 0
28512: PUSH
28513: LD_INT 1
28515: NEG
28516: PUSH
28517: EMPTY
28518: LIST
28519: LIST
28520: PUSH
28521: LD_INT 1
28523: PUSH
28524: LD_INT 0
28526: PUSH
28527: EMPTY
28528: LIST
28529: LIST
28530: PUSH
28531: LD_INT 1
28533: PUSH
28534: LD_INT 1
28536: PUSH
28537: EMPTY
28538: LIST
28539: LIST
28540: PUSH
28541: LD_INT 0
28543: PUSH
28544: LD_INT 1
28546: PUSH
28547: EMPTY
28548: LIST
28549: LIST
28550: PUSH
28551: LD_INT 1
28553: NEG
28554: PUSH
28555: LD_INT 0
28557: PUSH
28558: EMPTY
28559: LIST
28560: LIST
28561: PUSH
28562: LD_INT 1
28564: NEG
28565: PUSH
28566: LD_INT 1
28568: NEG
28569: PUSH
28570: EMPTY
28571: LIST
28572: LIST
28573: PUSH
28574: LD_INT 1
28576: NEG
28577: PUSH
28578: LD_INT 2
28580: NEG
28581: PUSH
28582: EMPTY
28583: LIST
28584: LIST
28585: PUSH
28586: LD_INT 0
28588: PUSH
28589: LD_INT 2
28591: NEG
28592: PUSH
28593: EMPTY
28594: LIST
28595: LIST
28596: PUSH
28597: LD_INT 1
28599: PUSH
28600: LD_INT 1
28602: NEG
28603: PUSH
28604: EMPTY
28605: LIST
28606: LIST
28607: PUSH
28608: LD_INT 2
28610: PUSH
28611: LD_INT 0
28613: PUSH
28614: EMPTY
28615: LIST
28616: LIST
28617: PUSH
28618: LD_INT 2
28620: PUSH
28621: LD_INT 1
28623: PUSH
28624: EMPTY
28625: LIST
28626: LIST
28627: PUSH
28628: LD_INT 1
28630: PUSH
28631: LD_INT 2
28633: PUSH
28634: EMPTY
28635: LIST
28636: LIST
28637: PUSH
28638: LD_INT 0
28640: PUSH
28641: LD_INT 2
28643: PUSH
28644: EMPTY
28645: LIST
28646: LIST
28647: PUSH
28648: LD_INT 1
28650: NEG
28651: PUSH
28652: LD_INT 1
28654: PUSH
28655: EMPTY
28656: LIST
28657: LIST
28658: PUSH
28659: LD_INT 2
28661: NEG
28662: PUSH
28663: LD_INT 1
28665: NEG
28666: PUSH
28667: EMPTY
28668: LIST
28669: LIST
28670: PUSH
28671: LD_INT 2
28673: NEG
28674: PUSH
28675: LD_INT 2
28677: NEG
28678: PUSH
28679: EMPTY
28680: LIST
28681: LIST
28682: PUSH
28683: LD_INT 2
28685: NEG
28686: PUSH
28687: LD_INT 3
28689: NEG
28690: PUSH
28691: EMPTY
28692: LIST
28693: LIST
28694: PUSH
28695: LD_INT 2
28697: PUSH
28698: LD_INT 1
28700: NEG
28701: PUSH
28702: EMPTY
28703: LIST
28704: LIST
28705: PUSH
28706: LD_INT 3
28708: PUSH
28709: LD_INT 1
28711: PUSH
28712: EMPTY
28713: LIST
28714: LIST
28715: PUSH
28716: LD_INT 1
28718: PUSH
28719: LD_INT 3
28721: PUSH
28722: EMPTY
28723: LIST
28724: LIST
28725: PUSH
28726: LD_INT 1
28728: NEG
28729: PUSH
28730: LD_INT 2
28732: PUSH
28733: EMPTY
28734: LIST
28735: LIST
28736: PUSH
28737: LD_INT 3
28739: NEG
28740: PUSH
28741: LD_INT 2
28743: NEG
28744: PUSH
28745: EMPTY
28746: LIST
28747: LIST
28748: PUSH
28749: EMPTY
28750: LIST
28751: LIST
28752: LIST
28753: LIST
28754: LIST
28755: LIST
28756: LIST
28757: LIST
28758: LIST
28759: LIST
28760: LIST
28761: LIST
28762: LIST
28763: LIST
28764: LIST
28765: LIST
28766: LIST
28767: LIST
28768: LIST
28769: LIST
28770: LIST
28771: LIST
28772: LIST
28773: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
28774: LD_ADDR_VAR 0 30
28778: PUSH
28779: LD_INT 0
28781: PUSH
28782: LD_INT 0
28784: PUSH
28785: EMPTY
28786: LIST
28787: LIST
28788: PUSH
28789: LD_INT 0
28791: PUSH
28792: LD_INT 1
28794: NEG
28795: PUSH
28796: EMPTY
28797: LIST
28798: LIST
28799: PUSH
28800: LD_INT 1
28802: PUSH
28803: LD_INT 0
28805: PUSH
28806: EMPTY
28807: LIST
28808: LIST
28809: PUSH
28810: LD_INT 1
28812: PUSH
28813: LD_INT 1
28815: PUSH
28816: EMPTY
28817: LIST
28818: LIST
28819: PUSH
28820: LD_INT 0
28822: PUSH
28823: LD_INT 1
28825: PUSH
28826: EMPTY
28827: LIST
28828: LIST
28829: PUSH
28830: LD_INT 1
28832: NEG
28833: PUSH
28834: LD_INT 0
28836: PUSH
28837: EMPTY
28838: LIST
28839: LIST
28840: PUSH
28841: LD_INT 1
28843: NEG
28844: PUSH
28845: LD_INT 1
28847: NEG
28848: PUSH
28849: EMPTY
28850: LIST
28851: LIST
28852: PUSH
28853: LD_INT 1
28855: NEG
28856: PUSH
28857: LD_INT 2
28859: NEG
28860: PUSH
28861: EMPTY
28862: LIST
28863: LIST
28864: PUSH
28865: LD_INT 0
28867: PUSH
28868: LD_INT 2
28870: NEG
28871: PUSH
28872: EMPTY
28873: LIST
28874: LIST
28875: PUSH
28876: LD_INT 1
28878: PUSH
28879: LD_INT 1
28881: NEG
28882: PUSH
28883: EMPTY
28884: LIST
28885: LIST
28886: PUSH
28887: LD_INT 2
28889: PUSH
28890: LD_INT 0
28892: PUSH
28893: EMPTY
28894: LIST
28895: LIST
28896: PUSH
28897: LD_INT 2
28899: PUSH
28900: LD_INT 1
28902: PUSH
28903: EMPTY
28904: LIST
28905: LIST
28906: PUSH
28907: LD_INT 2
28909: PUSH
28910: LD_INT 2
28912: PUSH
28913: EMPTY
28914: LIST
28915: LIST
28916: PUSH
28917: LD_INT 1
28919: PUSH
28920: LD_INT 2
28922: PUSH
28923: EMPTY
28924: LIST
28925: LIST
28926: PUSH
28927: LD_INT 1
28929: NEG
28930: PUSH
28931: LD_INT 1
28933: PUSH
28934: EMPTY
28935: LIST
28936: LIST
28937: PUSH
28938: LD_INT 2
28940: NEG
28941: PUSH
28942: LD_INT 0
28944: PUSH
28945: EMPTY
28946: LIST
28947: LIST
28948: PUSH
28949: LD_INT 2
28951: NEG
28952: PUSH
28953: LD_INT 1
28955: NEG
28956: PUSH
28957: EMPTY
28958: LIST
28959: LIST
28960: PUSH
28961: LD_INT 1
28963: NEG
28964: PUSH
28965: LD_INT 3
28967: NEG
28968: PUSH
28969: EMPTY
28970: LIST
28971: LIST
28972: PUSH
28973: LD_INT 1
28975: PUSH
28976: LD_INT 2
28978: NEG
28979: PUSH
28980: EMPTY
28981: LIST
28982: LIST
28983: PUSH
28984: LD_INT 3
28986: PUSH
28987: LD_INT 2
28989: PUSH
28990: EMPTY
28991: LIST
28992: LIST
28993: PUSH
28994: LD_INT 2
28996: PUSH
28997: LD_INT 3
28999: PUSH
29000: EMPTY
29001: LIST
29002: LIST
29003: PUSH
29004: LD_INT 2
29006: NEG
29007: PUSH
29008: LD_INT 1
29010: PUSH
29011: EMPTY
29012: LIST
29013: LIST
29014: PUSH
29015: LD_INT 3
29017: NEG
29018: PUSH
29019: LD_INT 1
29021: NEG
29022: PUSH
29023: EMPTY
29024: LIST
29025: LIST
29026: PUSH
29027: EMPTY
29028: LIST
29029: LIST
29030: LIST
29031: LIST
29032: LIST
29033: LIST
29034: LIST
29035: LIST
29036: LIST
29037: LIST
29038: LIST
29039: LIST
29040: LIST
29041: LIST
29042: LIST
29043: LIST
29044: LIST
29045: LIST
29046: LIST
29047: LIST
29048: LIST
29049: LIST
29050: LIST
29051: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
29052: LD_ADDR_VAR 0 31
29056: PUSH
29057: LD_INT 0
29059: PUSH
29060: LD_INT 0
29062: PUSH
29063: EMPTY
29064: LIST
29065: LIST
29066: PUSH
29067: LD_INT 0
29069: PUSH
29070: LD_INT 1
29072: NEG
29073: PUSH
29074: EMPTY
29075: LIST
29076: LIST
29077: PUSH
29078: LD_INT 1
29080: PUSH
29081: LD_INT 0
29083: PUSH
29084: EMPTY
29085: LIST
29086: LIST
29087: PUSH
29088: LD_INT 1
29090: PUSH
29091: LD_INT 1
29093: PUSH
29094: EMPTY
29095: LIST
29096: LIST
29097: PUSH
29098: LD_INT 0
29100: PUSH
29101: LD_INT 1
29103: PUSH
29104: EMPTY
29105: LIST
29106: LIST
29107: PUSH
29108: LD_INT 1
29110: NEG
29111: PUSH
29112: LD_INT 0
29114: PUSH
29115: EMPTY
29116: LIST
29117: LIST
29118: PUSH
29119: LD_INT 1
29121: NEG
29122: PUSH
29123: LD_INT 1
29125: NEG
29126: PUSH
29127: EMPTY
29128: LIST
29129: LIST
29130: PUSH
29131: LD_INT 1
29133: NEG
29134: PUSH
29135: LD_INT 2
29137: NEG
29138: PUSH
29139: EMPTY
29140: LIST
29141: LIST
29142: PUSH
29143: LD_INT 1
29145: PUSH
29146: LD_INT 1
29148: NEG
29149: PUSH
29150: EMPTY
29151: LIST
29152: LIST
29153: PUSH
29154: LD_INT 2
29156: PUSH
29157: LD_INT 0
29159: PUSH
29160: EMPTY
29161: LIST
29162: LIST
29163: PUSH
29164: LD_INT 2
29166: PUSH
29167: LD_INT 1
29169: PUSH
29170: EMPTY
29171: LIST
29172: LIST
29173: PUSH
29174: LD_INT 2
29176: PUSH
29177: LD_INT 2
29179: PUSH
29180: EMPTY
29181: LIST
29182: LIST
29183: PUSH
29184: LD_INT 1
29186: PUSH
29187: LD_INT 2
29189: PUSH
29190: EMPTY
29191: LIST
29192: LIST
29193: PUSH
29194: LD_INT 0
29196: PUSH
29197: LD_INT 2
29199: PUSH
29200: EMPTY
29201: LIST
29202: LIST
29203: PUSH
29204: LD_INT 1
29206: NEG
29207: PUSH
29208: LD_INT 1
29210: PUSH
29211: EMPTY
29212: LIST
29213: LIST
29214: PUSH
29215: LD_INT 2
29217: NEG
29218: PUSH
29219: LD_INT 1
29221: NEG
29222: PUSH
29223: EMPTY
29224: LIST
29225: LIST
29226: PUSH
29227: LD_INT 2
29229: NEG
29230: PUSH
29231: LD_INT 2
29233: NEG
29234: PUSH
29235: EMPTY
29236: LIST
29237: LIST
29238: PUSH
29239: LD_INT 2
29241: NEG
29242: PUSH
29243: LD_INT 3
29245: NEG
29246: PUSH
29247: EMPTY
29248: LIST
29249: LIST
29250: PUSH
29251: LD_INT 2
29253: PUSH
29254: LD_INT 1
29256: NEG
29257: PUSH
29258: EMPTY
29259: LIST
29260: LIST
29261: PUSH
29262: LD_INT 3
29264: PUSH
29265: LD_INT 1
29267: PUSH
29268: EMPTY
29269: LIST
29270: LIST
29271: PUSH
29272: LD_INT 1
29274: PUSH
29275: LD_INT 3
29277: PUSH
29278: EMPTY
29279: LIST
29280: LIST
29281: PUSH
29282: LD_INT 1
29284: NEG
29285: PUSH
29286: LD_INT 2
29288: PUSH
29289: EMPTY
29290: LIST
29291: LIST
29292: PUSH
29293: LD_INT 3
29295: NEG
29296: PUSH
29297: LD_INT 2
29299: NEG
29300: PUSH
29301: EMPTY
29302: LIST
29303: LIST
29304: PUSH
29305: EMPTY
29306: LIST
29307: LIST
29308: LIST
29309: LIST
29310: LIST
29311: LIST
29312: LIST
29313: LIST
29314: LIST
29315: LIST
29316: LIST
29317: LIST
29318: LIST
29319: LIST
29320: LIST
29321: LIST
29322: LIST
29323: LIST
29324: LIST
29325: LIST
29326: LIST
29327: LIST
29328: LIST
29329: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
29330: LD_ADDR_VAR 0 32
29334: PUSH
29335: LD_INT 0
29337: PUSH
29338: LD_INT 0
29340: PUSH
29341: EMPTY
29342: LIST
29343: LIST
29344: PUSH
29345: LD_INT 0
29347: PUSH
29348: LD_INT 1
29350: NEG
29351: PUSH
29352: EMPTY
29353: LIST
29354: LIST
29355: PUSH
29356: LD_INT 1
29358: PUSH
29359: LD_INT 0
29361: PUSH
29362: EMPTY
29363: LIST
29364: LIST
29365: PUSH
29366: LD_INT 1
29368: PUSH
29369: LD_INT 1
29371: PUSH
29372: EMPTY
29373: LIST
29374: LIST
29375: PUSH
29376: LD_INT 0
29378: PUSH
29379: LD_INT 1
29381: PUSH
29382: EMPTY
29383: LIST
29384: LIST
29385: PUSH
29386: LD_INT 1
29388: NEG
29389: PUSH
29390: LD_INT 0
29392: PUSH
29393: EMPTY
29394: LIST
29395: LIST
29396: PUSH
29397: LD_INT 1
29399: NEG
29400: PUSH
29401: LD_INT 1
29403: NEG
29404: PUSH
29405: EMPTY
29406: LIST
29407: LIST
29408: PUSH
29409: LD_INT 1
29411: NEG
29412: PUSH
29413: LD_INT 2
29415: NEG
29416: PUSH
29417: EMPTY
29418: LIST
29419: LIST
29420: PUSH
29421: LD_INT 0
29423: PUSH
29424: LD_INT 2
29426: NEG
29427: PUSH
29428: EMPTY
29429: LIST
29430: LIST
29431: PUSH
29432: LD_INT 1
29434: PUSH
29435: LD_INT 1
29437: NEG
29438: PUSH
29439: EMPTY
29440: LIST
29441: LIST
29442: PUSH
29443: LD_INT 2
29445: PUSH
29446: LD_INT 1
29448: PUSH
29449: EMPTY
29450: LIST
29451: LIST
29452: PUSH
29453: LD_INT 2
29455: PUSH
29456: LD_INT 2
29458: PUSH
29459: EMPTY
29460: LIST
29461: LIST
29462: PUSH
29463: LD_INT 1
29465: PUSH
29466: LD_INT 2
29468: PUSH
29469: EMPTY
29470: LIST
29471: LIST
29472: PUSH
29473: LD_INT 0
29475: PUSH
29476: LD_INT 2
29478: PUSH
29479: EMPTY
29480: LIST
29481: LIST
29482: PUSH
29483: LD_INT 1
29485: NEG
29486: PUSH
29487: LD_INT 1
29489: PUSH
29490: EMPTY
29491: LIST
29492: LIST
29493: PUSH
29494: LD_INT 2
29496: NEG
29497: PUSH
29498: LD_INT 0
29500: PUSH
29501: EMPTY
29502: LIST
29503: LIST
29504: PUSH
29505: LD_INT 2
29507: NEG
29508: PUSH
29509: LD_INT 1
29511: NEG
29512: PUSH
29513: EMPTY
29514: LIST
29515: LIST
29516: PUSH
29517: LD_INT 1
29519: NEG
29520: PUSH
29521: LD_INT 3
29523: NEG
29524: PUSH
29525: EMPTY
29526: LIST
29527: LIST
29528: PUSH
29529: LD_INT 1
29531: PUSH
29532: LD_INT 2
29534: NEG
29535: PUSH
29536: EMPTY
29537: LIST
29538: LIST
29539: PUSH
29540: LD_INT 3
29542: PUSH
29543: LD_INT 2
29545: PUSH
29546: EMPTY
29547: LIST
29548: LIST
29549: PUSH
29550: LD_INT 2
29552: PUSH
29553: LD_INT 3
29555: PUSH
29556: EMPTY
29557: LIST
29558: LIST
29559: PUSH
29560: LD_INT 2
29562: NEG
29563: PUSH
29564: LD_INT 1
29566: PUSH
29567: EMPTY
29568: LIST
29569: LIST
29570: PUSH
29571: LD_INT 3
29573: NEG
29574: PUSH
29575: LD_INT 1
29577: NEG
29578: PUSH
29579: EMPTY
29580: LIST
29581: LIST
29582: PUSH
29583: EMPTY
29584: LIST
29585: LIST
29586: LIST
29587: LIST
29588: LIST
29589: LIST
29590: LIST
29591: LIST
29592: LIST
29593: LIST
29594: LIST
29595: LIST
29596: LIST
29597: LIST
29598: LIST
29599: LIST
29600: LIST
29601: LIST
29602: LIST
29603: LIST
29604: LIST
29605: LIST
29606: LIST
29607: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
29608: LD_ADDR_VAR 0 33
29612: PUSH
29613: LD_INT 0
29615: PUSH
29616: LD_INT 0
29618: PUSH
29619: EMPTY
29620: LIST
29621: LIST
29622: PUSH
29623: LD_INT 0
29625: PUSH
29626: LD_INT 1
29628: NEG
29629: PUSH
29630: EMPTY
29631: LIST
29632: LIST
29633: PUSH
29634: LD_INT 1
29636: PUSH
29637: LD_INT 0
29639: PUSH
29640: EMPTY
29641: LIST
29642: LIST
29643: PUSH
29644: LD_INT 1
29646: PUSH
29647: LD_INT 1
29649: PUSH
29650: EMPTY
29651: LIST
29652: LIST
29653: PUSH
29654: LD_INT 0
29656: PUSH
29657: LD_INT 1
29659: PUSH
29660: EMPTY
29661: LIST
29662: LIST
29663: PUSH
29664: LD_INT 1
29666: NEG
29667: PUSH
29668: LD_INT 0
29670: PUSH
29671: EMPTY
29672: LIST
29673: LIST
29674: PUSH
29675: LD_INT 1
29677: NEG
29678: PUSH
29679: LD_INT 1
29681: NEG
29682: PUSH
29683: EMPTY
29684: LIST
29685: LIST
29686: PUSH
29687: LD_INT 1
29689: NEG
29690: PUSH
29691: LD_INT 2
29693: NEG
29694: PUSH
29695: EMPTY
29696: LIST
29697: LIST
29698: PUSH
29699: LD_INT 1
29701: PUSH
29702: LD_INT 1
29704: NEG
29705: PUSH
29706: EMPTY
29707: LIST
29708: LIST
29709: PUSH
29710: LD_INT 2
29712: PUSH
29713: LD_INT 0
29715: PUSH
29716: EMPTY
29717: LIST
29718: LIST
29719: PUSH
29720: LD_INT 2
29722: PUSH
29723: LD_INT 1
29725: PUSH
29726: EMPTY
29727: LIST
29728: LIST
29729: PUSH
29730: LD_INT 1
29732: PUSH
29733: LD_INT 2
29735: PUSH
29736: EMPTY
29737: LIST
29738: LIST
29739: PUSH
29740: LD_INT 0
29742: PUSH
29743: LD_INT 2
29745: PUSH
29746: EMPTY
29747: LIST
29748: LIST
29749: PUSH
29750: LD_INT 1
29752: NEG
29753: PUSH
29754: LD_INT 1
29756: PUSH
29757: EMPTY
29758: LIST
29759: LIST
29760: PUSH
29761: LD_INT 2
29763: NEG
29764: PUSH
29765: LD_INT 0
29767: PUSH
29768: EMPTY
29769: LIST
29770: LIST
29771: PUSH
29772: LD_INT 2
29774: NEG
29775: PUSH
29776: LD_INT 1
29778: NEG
29779: PUSH
29780: EMPTY
29781: LIST
29782: LIST
29783: PUSH
29784: LD_INT 2
29786: NEG
29787: PUSH
29788: LD_INT 2
29790: NEG
29791: PUSH
29792: EMPTY
29793: LIST
29794: LIST
29795: PUSH
29796: LD_INT 2
29798: NEG
29799: PUSH
29800: LD_INT 3
29802: NEG
29803: PUSH
29804: EMPTY
29805: LIST
29806: LIST
29807: PUSH
29808: LD_INT 2
29810: PUSH
29811: LD_INT 1
29813: NEG
29814: PUSH
29815: EMPTY
29816: LIST
29817: LIST
29818: PUSH
29819: LD_INT 3
29821: PUSH
29822: LD_INT 1
29824: PUSH
29825: EMPTY
29826: LIST
29827: LIST
29828: PUSH
29829: LD_INT 1
29831: PUSH
29832: LD_INT 3
29834: PUSH
29835: EMPTY
29836: LIST
29837: LIST
29838: PUSH
29839: LD_INT 1
29841: NEG
29842: PUSH
29843: LD_INT 2
29845: PUSH
29846: EMPTY
29847: LIST
29848: LIST
29849: PUSH
29850: LD_INT 3
29852: NEG
29853: PUSH
29854: LD_INT 2
29856: NEG
29857: PUSH
29858: EMPTY
29859: LIST
29860: LIST
29861: PUSH
29862: EMPTY
29863: LIST
29864: LIST
29865: LIST
29866: LIST
29867: LIST
29868: LIST
29869: LIST
29870: LIST
29871: LIST
29872: LIST
29873: LIST
29874: LIST
29875: LIST
29876: LIST
29877: LIST
29878: LIST
29879: LIST
29880: LIST
29881: LIST
29882: LIST
29883: LIST
29884: LIST
29885: LIST
29886: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
29887: LD_ADDR_VAR 0 34
29891: PUSH
29892: LD_INT 0
29894: PUSH
29895: LD_INT 0
29897: PUSH
29898: EMPTY
29899: LIST
29900: LIST
29901: PUSH
29902: LD_INT 0
29904: PUSH
29905: LD_INT 1
29907: NEG
29908: PUSH
29909: EMPTY
29910: LIST
29911: LIST
29912: PUSH
29913: LD_INT 1
29915: PUSH
29916: LD_INT 0
29918: PUSH
29919: EMPTY
29920: LIST
29921: LIST
29922: PUSH
29923: LD_INT 1
29925: PUSH
29926: LD_INT 1
29928: PUSH
29929: EMPTY
29930: LIST
29931: LIST
29932: PUSH
29933: LD_INT 0
29935: PUSH
29936: LD_INT 1
29938: PUSH
29939: EMPTY
29940: LIST
29941: LIST
29942: PUSH
29943: LD_INT 1
29945: NEG
29946: PUSH
29947: LD_INT 0
29949: PUSH
29950: EMPTY
29951: LIST
29952: LIST
29953: PUSH
29954: LD_INT 1
29956: NEG
29957: PUSH
29958: LD_INT 1
29960: NEG
29961: PUSH
29962: EMPTY
29963: LIST
29964: LIST
29965: PUSH
29966: LD_INT 1
29968: NEG
29969: PUSH
29970: LD_INT 2
29972: NEG
29973: PUSH
29974: EMPTY
29975: LIST
29976: LIST
29977: PUSH
29978: LD_INT 0
29980: PUSH
29981: LD_INT 2
29983: NEG
29984: PUSH
29985: EMPTY
29986: LIST
29987: LIST
29988: PUSH
29989: LD_INT 1
29991: PUSH
29992: LD_INT 1
29994: NEG
29995: PUSH
29996: EMPTY
29997: LIST
29998: LIST
29999: PUSH
30000: LD_INT 2
30002: PUSH
30003: LD_INT 1
30005: PUSH
30006: EMPTY
30007: LIST
30008: LIST
30009: PUSH
30010: LD_INT 2
30012: PUSH
30013: LD_INT 2
30015: PUSH
30016: EMPTY
30017: LIST
30018: LIST
30019: PUSH
30020: LD_INT 1
30022: PUSH
30023: LD_INT 2
30025: PUSH
30026: EMPTY
30027: LIST
30028: LIST
30029: PUSH
30030: LD_INT 1
30032: NEG
30033: PUSH
30034: LD_INT 1
30036: PUSH
30037: EMPTY
30038: LIST
30039: LIST
30040: PUSH
30041: LD_INT 2
30043: NEG
30044: PUSH
30045: LD_INT 0
30047: PUSH
30048: EMPTY
30049: LIST
30050: LIST
30051: PUSH
30052: LD_INT 2
30054: NEG
30055: PUSH
30056: LD_INT 1
30058: NEG
30059: PUSH
30060: EMPTY
30061: LIST
30062: LIST
30063: PUSH
30064: LD_INT 2
30066: NEG
30067: PUSH
30068: LD_INT 2
30070: NEG
30071: PUSH
30072: EMPTY
30073: LIST
30074: LIST
30075: PUSH
30076: LD_INT 1
30078: NEG
30079: PUSH
30080: LD_INT 3
30082: NEG
30083: PUSH
30084: EMPTY
30085: LIST
30086: LIST
30087: PUSH
30088: LD_INT 1
30090: PUSH
30091: LD_INT 2
30093: NEG
30094: PUSH
30095: EMPTY
30096: LIST
30097: LIST
30098: PUSH
30099: LD_INT 3
30101: PUSH
30102: LD_INT 2
30104: PUSH
30105: EMPTY
30106: LIST
30107: LIST
30108: PUSH
30109: LD_INT 2
30111: PUSH
30112: LD_INT 3
30114: PUSH
30115: EMPTY
30116: LIST
30117: LIST
30118: PUSH
30119: LD_INT 2
30121: NEG
30122: PUSH
30123: LD_INT 1
30125: PUSH
30126: EMPTY
30127: LIST
30128: LIST
30129: PUSH
30130: LD_INT 3
30132: NEG
30133: PUSH
30134: LD_INT 1
30136: NEG
30137: PUSH
30138: EMPTY
30139: LIST
30140: LIST
30141: PUSH
30142: EMPTY
30143: LIST
30144: LIST
30145: LIST
30146: LIST
30147: LIST
30148: LIST
30149: LIST
30150: LIST
30151: LIST
30152: LIST
30153: LIST
30154: LIST
30155: LIST
30156: LIST
30157: LIST
30158: LIST
30159: LIST
30160: LIST
30161: LIST
30162: LIST
30163: LIST
30164: LIST
30165: LIST
30166: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
30167: LD_ADDR_VAR 0 35
30171: PUSH
30172: LD_INT 0
30174: PUSH
30175: LD_INT 0
30177: PUSH
30178: EMPTY
30179: LIST
30180: LIST
30181: PUSH
30182: LD_INT 0
30184: PUSH
30185: LD_INT 1
30187: NEG
30188: PUSH
30189: EMPTY
30190: LIST
30191: LIST
30192: PUSH
30193: LD_INT 1
30195: PUSH
30196: LD_INT 0
30198: PUSH
30199: EMPTY
30200: LIST
30201: LIST
30202: PUSH
30203: LD_INT 1
30205: PUSH
30206: LD_INT 1
30208: PUSH
30209: EMPTY
30210: LIST
30211: LIST
30212: PUSH
30213: LD_INT 0
30215: PUSH
30216: LD_INT 1
30218: PUSH
30219: EMPTY
30220: LIST
30221: LIST
30222: PUSH
30223: LD_INT 1
30225: NEG
30226: PUSH
30227: LD_INT 0
30229: PUSH
30230: EMPTY
30231: LIST
30232: LIST
30233: PUSH
30234: LD_INT 1
30236: NEG
30237: PUSH
30238: LD_INT 1
30240: NEG
30241: PUSH
30242: EMPTY
30243: LIST
30244: LIST
30245: PUSH
30246: LD_INT 2
30248: PUSH
30249: LD_INT 1
30251: PUSH
30252: EMPTY
30253: LIST
30254: LIST
30255: PUSH
30256: LD_INT 2
30258: NEG
30259: PUSH
30260: LD_INT 1
30262: NEG
30263: PUSH
30264: EMPTY
30265: LIST
30266: LIST
30267: PUSH
30268: EMPTY
30269: LIST
30270: LIST
30271: LIST
30272: LIST
30273: LIST
30274: LIST
30275: LIST
30276: LIST
30277: LIST
30278: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
30279: LD_ADDR_VAR 0 36
30283: PUSH
30284: LD_INT 0
30286: PUSH
30287: LD_INT 0
30289: PUSH
30290: EMPTY
30291: LIST
30292: LIST
30293: PUSH
30294: LD_INT 0
30296: PUSH
30297: LD_INT 1
30299: NEG
30300: PUSH
30301: EMPTY
30302: LIST
30303: LIST
30304: PUSH
30305: LD_INT 1
30307: PUSH
30308: LD_INT 0
30310: PUSH
30311: EMPTY
30312: LIST
30313: LIST
30314: PUSH
30315: LD_INT 1
30317: PUSH
30318: LD_INT 1
30320: PUSH
30321: EMPTY
30322: LIST
30323: LIST
30324: PUSH
30325: LD_INT 0
30327: PUSH
30328: LD_INT 1
30330: PUSH
30331: EMPTY
30332: LIST
30333: LIST
30334: PUSH
30335: LD_INT 1
30337: NEG
30338: PUSH
30339: LD_INT 0
30341: PUSH
30342: EMPTY
30343: LIST
30344: LIST
30345: PUSH
30346: LD_INT 1
30348: NEG
30349: PUSH
30350: LD_INT 1
30352: NEG
30353: PUSH
30354: EMPTY
30355: LIST
30356: LIST
30357: PUSH
30358: LD_INT 1
30360: NEG
30361: PUSH
30362: LD_INT 2
30364: NEG
30365: PUSH
30366: EMPTY
30367: LIST
30368: LIST
30369: PUSH
30370: LD_INT 1
30372: PUSH
30373: LD_INT 2
30375: PUSH
30376: EMPTY
30377: LIST
30378: LIST
30379: PUSH
30380: EMPTY
30381: LIST
30382: LIST
30383: LIST
30384: LIST
30385: LIST
30386: LIST
30387: LIST
30388: LIST
30389: LIST
30390: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
30391: LD_ADDR_VAR 0 37
30395: PUSH
30396: LD_INT 0
30398: PUSH
30399: LD_INT 0
30401: PUSH
30402: EMPTY
30403: LIST
30404: LIST
30405: PUSH
30406: LD_INT 0
30408: PUSH
30409: LD_INT 1
30411: NEG
30412: PUSH
30413: EMPTY
30414: LIST
30415: LIST
30416: PUSH
30417: LD_INT 1
30419: PUSH
30420: LD_INT 0
30422: PUSH
30423: EMPTY
30424: LIST
30425: LIST
30426: PUSH
30427: LD_INT 1
30429: PUSH
30430: LD_INT 1
30432: PUSH
30433: EMPTY
30434: LIST
30435: LIST
30436: PUSH
30437: LD_INT 0
30439: PUSH
30440: LD_INT 1
30442: PUSH
30443: EMPTY
30444: LIST
30445: LIST
30446: PUSH
30447: LD_INT 1
30449: NEG
30450: PUSH
30451: LD_INT 0
30453: PUSH
30454: EMPTY
30455: LIST
30456: LIST
30457: PUSH
30458: LD_INT 1
30460: NEG
30461: PUSH
30462: LD_INT 1
30464: NEG
30465: PUSH
30466: EMPTY
30467: LIST
30468: LIST
30469: PUSH
30470: LD_INT 1
30472: PUSH
30473: LD_INT 1
30475: NEG
30476: PUSH
30477: EMPTY
30478: LIST
30479: LIST
30480: PUSH
30481: LD_INT 1
30483: NEG
30484: PUSH
30485: LD_INT 1
30487: PUSH
30488: EMPTY
30489: LIST
30490: LIST
30491: PUSH
30492: EMPTY
30493: LIST
30494: LIST
30495: LIST
30496: LIST
30497: LIST
30498: LIST
30499: LIST
30500: LIST
30501: LIST
30502: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
30503: LD_ADDR_VAR 0 38
30507: PUSH
30508: LD_INT 0
30510: PUSH
30511: LD_INT 0
30513: PUSH
30514: EMPTY
30515: LIST
30516: LIST
30517: PUSH
30518: LD_INT 0
30520: PUSH
30521: LD_INT 1
30523: NEG
30524: PUSH
30525: EMPTY
30526: LIST
30527: LIST
30528: PUSH
30529: LD_INT 1
30531: PUSH
30532: LD_INT 0
30534: PUSH
30535: EMPTY
30536: LIST
30537: LIST
30538: PUSH
30539: LD_INT 1
30541: PUSH
30542: LD_INT 1
30544: PUSH
30545: EMPTY
30546: LIST
30547: LIST
30548: PUSH
30549: LD_INT 0
30551: PUSH
30552: LD_INT 1
30554: PUSH
30555: EMPTY
30556: LIST
30557: LIST
30558: PUSH
30559: LD_INT 1
30561: NEG
30562: PUSH
30563: LD_INT 0
30565: PUSH
30566: EMPTY
30567: LIST
30568: LIST
30569: PUSH
30570: LD_INT 1
30572: NEG
30573: PUSH
30574: LD_INT 1
30576: NEG
30577: PUSH
30578: EMPTY
30579: LIST
30580: LIST
30581: PUSH
30582: LD_INT 2
30584: PUSH
30585: LD_INT 1
30587: PUSH
30588: EMPTY
30589: LIST
30590: LIST
30591: PUSH
30592: LD_INT 2
30594: NEG
30595: PUSH
30596: LD_INT 1
30598: NEG
30599: PUSH
30600: EMPTY
30601: LIST
30602: LIST
30603: PUSH
30604: EMPTY
30605: LIST
30606: LIST
30607: LIST
30608: LIST
30609: LIST
30610: LIST
30611: LIST
30612: LIST
30613: LIST
30614: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
30615: LD_ADDR_VAR 0 39
30619: PUSH
30620: LD_INT 0
30622: PUSH
30623: LD_INT 0
30625: PUSH
30626: EMPTY
30627: LIST
30628: LIST
30629: PUSH
30630: LD_INT 0
30632: PUSH
30633: LD_INT 1
30635: NEG
30636: PUSH
30637: EMPTY
30638: LIST
30639: LIST
30640: PUSH
30641: LD_INT 1
30643: PUSH
30644: LD_INT 0
30646: PUSH
30647: EMPTY
30648: LIST
30649: LIST
30650: PUSH
30651: LD_INT 1
30653: PUSH
30654: LD_INT 1
30656: PUSH
30657: EMPTY
30658: LIST
30659: LIST
30660: PUSH
30661: LD_INT 0
30663: PUSH
30664: LD_INT 1
30666: PUSH
30667: EMPTY
30668: LIST
30669: LIST
30670: PUSH
30671: LD_INT 1
30673: NEG
30674: PUSH
30675: LD_INT 0
30677: PUSH
30678: EMPTY
30679: LIST
30680: LIST
30681: PUSH
30682: LD_INT 1
30684: NEG
30685: PUSH
30686: LD_INT 1
30688: NEG
30689: PUSH
30690: EMPTY
30691: LIST
30692: LIST
30693: PUSH
30694: LD_INT 1
30696: NEG
30697: PUSH
30698: LD_INT 2
30700: NEG
30701: PUSH
30702: EMPTY
30703: LIST
30704: LIST
30705: PUSH
30706: LD_INT 1
30708: PUSH
30709: LD_INT 2
30711: PUSH
30712: EMPTY
30713: LIST
30714: LIST
30715: PUSH
30716: EMPTY
30717: LIST
30718: LIST
30719: LIST
30720: LIST
30721: LIST
30722: LIST
30723: LIST
30724: LIST
30725: LIST
30726: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
30727: LD_ADDR_VAR 0 40
30731: PUSH
30732: LD_INT 0
30734: PUSH
30735: LD_INT 0
30737: PUSH
30738: EMPTY
30739: LIST
30740: LIST
30741: PUSH
30742: LD_INT 0
30744: PUSH
30745: LD_INT 1
30747: NEG
30748: PUSH
30749: EMPTY
30750: LIST
30751: LIST
30752: PUSH
30753: LD_INT 1
30755: PUSH
30756: LD_INT 0
30758: PUSH
30759: EMPTY
30760: LIST
30761: LIST
30762: PUSH
30763: LD_INT 1
30765: PUSH
30766: LD_INT 1
30768: PUSH
30769: EMPTY
30770: LIST
30771: LIST
30772: PUSH
30773: LD_INT 0
30775: PUSH
30776: LD_INT 1
30778: PUSH
30779: EMPTY
30780: LIST
30781: LIST
30782: PUSH
30783: LD_INT 1
30785: NEG
30786: PUSH
30787: LD_INT 0
30789: PUSH
30790: EMPTY
30791: LIST
30792: LIST
30793: PUSH
30794: LD_INT 1
30796: NEG
30797: PUSH
30798: LD_INT 1
30800: NEG
30801: PUSH
30802: EMPTY
30803: LIST
30804: LIST
30805: PUSH
30806: LD_INT 1
30808: PUSH
30809: LD_INT 1
30811: NEG
30812: PUSH
30813: EMPTY
30814: LIST
30815: LIST
30816: PUSH
30817: LD_INT 1
30819: NEG
30820: PUSH
30821: LD_INT 1
30823: PUSH
30824: EMPTY
30825: LIST
30826: LIST
30827: PUSH
30828: EMPTY
30829: LIST
30830: LIST
30831: LIST
30832: LIST
30833: LIST
30834: LIST
30835: LIST
30836: LIST
30837: LIST
30838: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30839: LD_ADDR_VAR 0 41
30843: PUSH
30844: LD_INT 0
30846: PUSH
30847: LD_INT 0
30849: PUSH
30850: EMPTY
30851: LIST
30852: LIST
30853: PUSH
30854: LD_INT 0
30856: PUSH
30857: LD_INT 1
30859: NEG
30860: PUSH
30861: EMPTY
30862: LIST
30863: LIST
30864: PUSH
30865: LD_INT 1
30867: PUSH
30868: LD_INT 0
30870: PUSH
30871: EMPTY
30872: LIST
30873: LIST
30874: PUSH
30875: LD_INT 1
30877: PUSH
30878: LD_INT 1
30880: PUSH
30881: EMPTY
30882: LIST
30883: LIST
30884: PUSH
30885: LD_INT 0
30887: PUSH
30888: LD_INT 1
30890: PUSH
30891: EMPTY
30892: LIST
30893: LIST
30894: PUSH
30895: LD_INT 1
30897: NEG
30898: PUSH
30899: LD_INT 0
30901: PUSH
30902: EMPTY
30903: LIST
30904: LIST
30905: PUSH
30906: LD_INT 1
30908: NEG
30909: PUSH
30910: LD_INT 1
30912: NEG
30913: PUSH
30914: EMPTY
30915: LIST
30916: LIST
30917: PUSH
30918: LD_INT 1
30920: NEG
30921: PUSH
30922: LD_INT 2
30924: NEG
30925: PUSH
30926: EMPTY
30927: LIST
30928: LIST
30929: PUSH
30930: LD_INT 1
30932: PUSH
30933: LD_INT 1
30935: NEG
30936: PUSH
30937: EMPTY
30938: LIST
30939: LIST
30940: PUSH
30941: LD_INT 2
30943: PUSH
30944: LD_INT 0
30946: PUSH
30947: EMPTY
30948: LIST
30949: LIST
30950: PUSH
30951: LD_INT 2
30953: PUSH
30954: LD_INT 1
30956: PUSH
30957: EMPTY
30958: LIST
30959: LIST
30960: PUSH
30961: LD_INT 2
30963: PUSH
30964: LD_INT 2
30966: PUSH
30967: EMPTY
30968: LIST
30969: LIST
30970: PUSH
30971: LD_INT 1
30973: PUSH
30974: LD_INT 2
30976: PUSH
30977: EMPTY
30978: LIST
30979: LIST
30980: PUSH
30981: LD_INT 1
30983: NEG
30984: PUSH
30985: LD_INT 1
30987: PUSH
30988: EMPTY
30989: LIST
30990: LIST
30991: PUSH
30992: LD_INT 2
30994: NEG
30995: PUSH
30996: LD_INT 0
30998: PUSH
30999: EMPTY
31000: LIST
31001: LIST
31002: PUSH
31003: LD_INT 2
31005: NEG
31006: PUSH
31007: LD_INT 1
31009: NEG
31010: PUSH
31011: EMPTY
31012: LIST
31013: LIST
31014: PUSH
31015: LD_INT 2
31017: NEG
31018: PUSH
31019: LD_INT 2
31021: NEG
31022: PUSH
31023: EMPTY
31024: LIST
31025: LIST
31026: PUSH
31027: LD_INT 2
31029: NEG
31030: PUSH
31031: LD_INT 3
31033: NEG
31034: PUSH
31035: EMPTY
31036: LIST
31037: LIST
31038: PUSH
31039: LD_INT 2
31041: PUSH
31042: LD_INT 1
31044: NEG
31045: PUSH
31046: EMPTY
31047: LIST
31048: LIST
31049: PUSH
31050: LD_INT 3
31052: PUSH
31053: LD_INT 0
31055: PUSH
31056: EMPTY
31057: LIST
31058: LIST
31059: PUSH
31060: LD_INT 3
31062: PUSH
31063: LD_INT 1
31065: PUSH
31066: EMPTY
31067: LIST
31068: LIST
31069: PUSH
31070: LD_INT 3
31072: PUSH
31073: LD_INT 2
31075: PUSH
31076: EMPTY
31077: LIST
31078: LIST
31079: PUSH
31080: LD_INT 3
31082: PUSH
31083: LD_INT 3
31085: PUSH
31086: EMPTY
31087: LIST
31088: LIST
31089: PUSH
31090: LD_INT 2
31092: PUSH
31093: LD_INT 3
31095: PUSH
31096: EMPTY
31097: LIST
31098: LIST
31099: PUSH
31100: LD_INT 2
31102: NEG
31103: PUSH
31104: LD_INT 1
31106: PUSH
31107: EMPTY
31108: LIST
31109: LIST
31110: PUSH
31111: LD_INT 3
31113: NEG
31114: PUSH
31115: LD_INT 0
31117: PUSH
31118: EMPTY
31119: LIST
31120: LIST
31121: PUSH
31122: LD_INT 3
31124: NEG
31125: PUSH
31126: LD_INT 1
31128: NEG
31129: PUSH
31130: EMPTY
31131: LIST
31132: LIST
31133: PUSH
31134: LD_INT 3
31136: NEG
31137: PUSH
31138: LD_INT 2
31140: NEG
31141: PUSH
31142: EMPTY
31143: LIST
31144: LIST
31145: PUSH
31146: LD_INT 3
31148: NEG
31149: PUSH
31150: LD_INT 3
31152: NEG
31153: PUSH
31154: EMPTY
31155: LIST
31156: LIST
31157: PUSH
31158: EMPTY
31159: LIST
31160: LIST
31161: LIST
31162: LIST
31163: LIST
31164: LIST
31165: LIST
31166: LIST
31167: LIST
31168: LIST
31169: LIST
31170: LIST
31171: LIST
31172: LIST
31173: LIST
31174: LIST
31175: LIST
31176: LIST
31177: LIST
31178: LIST
31179: LIST
31180: LIST
31181: LIST
31182: LIST
31183: LIST
31184: LIST
31185: LIST
31186: LIST
31187: LIST
31188: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31189: LD_ADDR_VAR 0 42
31193: PUSH
31194: LD_INT 0
31196: PUSH
31197: LD_INT 0
31199: PUSH
31200: EMPTY
31201: LIST
31202: LIST
31203: PUSH
31204: LD_INT 0
31206: PUSH
31207: LD_INT 1
31209: NEG
31210: PUSH
31211: EMPTY
31212: LIST
31213: LIST
31214: PUSH
31215: LD_INT 1
31217: PUSH
31218: LD_INT 0
31220: PUSH
31221: EMPTY
31222: LIST
31223: LIST
31224: PUSH
31225: LD_INT 1
31227: PUSH
31228: LD_INT 1
31230: PUSH
31231: EMPTY
31232: LIST
31233: LIST
31234: PUSH
31235: LD_INT 0
31237: PUSH
31238: LD_INT 1
31240: PUSH
31241: EMPTY
31242: LIST
31243: LIST
31244: PUSH
31245: LD_INT 1
31247: NEG
31248: PUSH
31249: LD_INT 0
31251: PUSH
31252: EMPTY
31253: LIST
31254: LIST
31255: PUSH
31256: LD_INT 1
31258: NEG
31259: PUSH
31260: LD_INT 1
31262: NEG
31263: PUSH
31264: EMPTY
31265: LIST
31266: LIST
31267: PUSH
31268: LD_INT 1
31270: NEG
31271: PUSH
31272: LD_INT 2
31274: NEG
31275: PUSH
31276: EMPTY
31277: LIST
31278: LIST
31279: PUSH
31280: LD_INT 0
31282: PUSH
31283: LD_INT 2
31285: NEG
31286: PUSH
31287: EMPTY
31288: LIST
31289: LIST
31290: PUSH
31291: LD_INT 1
31293: PUSH
31294: LD_INT 1
31296: NEG
31297: PUSH
31298: EMPTY
31299: LIST
31300: LIST
31301: PUSH
31302: LD_INT 2
31304: PUSH
31305: LD_INT 1
31307: PUSH
31308: EMPTY
31309: LIST
31310: LIST
31311: PUSH
31312: LD_INT 2
31314: PUSH
31315: LD_INT 2
31317: PUSH
31318: EMPTY
31319: LIST
31320: LIST
31321: PUSH
31322: LD_INT 1
31324: PUSH
31325: LD_INT 2
31327: PUSH
31328: EMPTY
31329: LIST
31330: LIST
31331: PUSH
31332: LD_INT 0
31334: PUSH
31335: LD_INT 2
31337: PUSH
31338: EMPTY
31339: LIST
31340: LIST
31341: PUSH
31342: LD_INT 1
31344: NEG
31345: PUSH
31346: LD_INT 1
31348: PUSH
31349: EMPTY
31350: LIST
31351: LIST
31352: PUSH
31353: LD_INT 2
31355: NEG
31356: PUSH
31357: LD_INT 1
31359: NEG
31360: PUSH
31361: EMPTY
31362: LIST
31363: LIST
31364: PUSH
31365: LD_INT 2
31367: NEG
31368: PUSH
31369: LD_INT 2
31371: NEG
31372: PUSH
31373: EMPTY
31374: LIST
31375: LIST
31376: PUSH
31377: LD_INT 2
31379: NEG
31380: PUSH
31381: LD_INT 3
31383: NEG
31384: PUSH
31385: EMPTY
31386: LIST
31387: LIST
31388: PUSH
31389: LD_INT 1
31391: NEG
31392: PUSH
31393: LD_INT 3
31395: NEG
31396: PUSH
31397: EMPTY
31398: LIST
31399: LIST
31400: PUSH
31401: LD_INT 0
31403: PUSH
31404: LD_INT 3
31406: NEG
31407: PUSH
31408: EMPTY
31409: LIST
31410: LIST
31411: PUSH
31412: LD_INT 1
31414: PUSH
31415: LD_INT 2
31417: NEG
31418: PUSH
31419: EMPTY
31420: LIST
31421: LIST
31422: PUSH
31423: LD_INT 3
31425: PUSH
31426: LD_INT 2
31428: PUSH
31429: EMPTY
31430: LIST
31431: LIST
31432: PUSH
31433: LD_INT 3
31435: PUSH
31436: LD_INT 3
31438: PUSH
31439: EMPTY
31440: LIST
31441: LIST
31442: PUSH
31443: LD_INT 2
31445: PUSH
31446: LD_INT 3
31448: PUSH
31449: EMPTY
31450: LIST
31451: LIST
31452: PUSH
31453: LD_INT 1
31455: PUSH
31456: LD_INT 3
31458: PUSH
31459: EMPTY
31460: LIST
31461: LIST
31462: PUSH
31463: LD_INT 0
31465: PUSH
31466: LD_INT 3
31468: PUSH
31469: EMPTY
31470: LIST
31471: LIST
31472: PUSH
31473: LD_INT 1
31475: NEG
31476: PUSH
31477: LD_INT 2
31479: PUSH
31480: EMPTY
31481: LIST
31482: LIST
31483: PUSH
31484: LD_INT 3
31486: NEG
31487: PUSH
31488: LD_INT 2
31490: NEG
31491: PUSH
31492: EMPTY
31493: LIST
31494: LIST
31495: PUSH
31496: LD_INT 3
31498: NEG
31499: PUSH
31500: LD_INT 3
31502: NEG
31503: PUSH
31504: EMPTY
31505: LIST
31506: LIST
31507: PUSH
31508: EMPTY
31509: LIST
31510: LIST
31511: LIST
31512: LIST
31513: LIST
31514: LIST
31515: LIST
31516: LIST
31517: LIST
31518: LIST
31519: LIST
31520: LIST
31521: LIST
31522: LIST
31523: LIST
31524: LIST
31525: LIST
31526: LIST
31527: LIST
31528: LIST
31529: LIST
31530: LIST
31531: LIST
31532: LIST
31533: LIST
31534: LIST
31535: LIST
31536: LIST
31537: LIST
31538: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
31539: LD_ADDR_VAR 0 43
31543: PUSH
31544: LD_INT 0
31546: PUSH
31547: LD_INT 0
31549: PUSH
31550: EMPTY
31551: LIST
31552: LIST
31553: PUSH
31554: LD_INT 0
31556: PUSH
31557: LD_INT 1
31559: NEG
31560: PUSH
31561: EMPTY
31562: LIST
31563: LIST
31564: PUSH
31565: LD_INT 1
31567: PUSH
31568: LD_INT 0
31570: PUSH
31571: EMPTY
31572: LIST
31573: LIST
31574: PUSH
31575: LD_INT 1
31577: PUSH
31578: LD_INT 1
31580: PUSH
31581: EMPTY
31582: LIST
31583: LIST
31584: PUSH
31585: LD_INT 0
31587: PUSH
31588: LD_INT 1
31590: PUSH
31591: EMPTY
31592: LIST
31593: LIST
31594: PUSH
31595: LD_INT 1
31597: NEG
31598: PUSH
31599: LD_INT 0
31601: PUSH
31602: EMPTY
31603: LIST
31604: LIST
31605: PUSH
31606: LD_INT 1
31608: NEG
31609: PUSH
31610: LD_INT 1
31612: NEG
31613: PUSH
31614: EMPTY
31615: LIST
31616: LIST
31617: PUSH
31618: LD_INT 1
31620: NEG
31621: PUSH
31622: LD_INT 2
31624: NEG
31625: PUSH
31626: EMPTY
31627: LIST
31628: LIST
31629: PUSH
31630: LD_INT 0
31632: PUSH
31633: LD_INT 2
31635: NEG
31636: PUSH
31637: EMPTY
31638: LIST
31639: LIST
31640: PUSH
31641: LD_INT 1
31643: PUSH
31644: LD_INT 1
31646: NEG
31647: PUSH
31648: EMPTY
31649: LIST
31650: LIST
31651: PUSH
31652: LD_INT 2
31654: PUSH
31655: LD_INT 0
31657: PUSH
31658: EMPTY
31659: LIST
31660: LIST
31661: PUSH
31662: LD_INT 2
31664: PUSH
31665: LD_INT 1
31667: PUSH
31668: EMPTY
31669: LIST
31670: LIST
31671: PUSH
31672: LD_INT 1
31674: PUSH
31675: LD_INT 2
31677: PUSH
31678: EMPTY
31679: LIST
31680: LIST
31681: PUSH
31682: LD_INT 0
31684: PUSH
31685: LD_INT 2
31687: PUSH
31688: EMPTY
31689: LIST
31690: LIST
31691: PUSH
31692: LD_INT 1
31694: NEG
31695: PUSH
31696: LD_INT 1
31698: PUSH
31699: EMPTY
31700: LIST
31701: LIST
31702: PUSH
31703: LD_INT 2
31705: NEG
31706: PUSH
31707: LD_INT 0
31709: PUSH
31710: EMPTY
31711: LIST
31712: LIST
31713: PUSH
31714: LD_INT 2
31716: NEG
31717: PUSH
31718: LD_INT 1
31720: NEG
31721: PUSH
31722: EMPTY
31723: LIST
31724: LIST
31725: PUSH
31726: LD_INT 1
31728: NEG
31729: PUSH
31730: LD_INT 3
31732: NEG
31733: PUSH
31734: EMPTY
31735: LIST
31736: LIST
31737: PUSH
31738: LD_INT 0
31740: PUSH
31741: LD_INT 3
31743: NEG
31744: PUSH
31745: EMPTY
31746: LIST
31747: LIST
31748: PUSH
31749: LD_INT 1
31751: PUSH
31752: LD_INT 2
31754: NEG
31755: PUSH
31756: EMPTY
31757: LIST
31758: LIST
31759: PUSH
31760: LD_INT 2
31762: PUSH
31763: LD_INT 1
31765: NEG
31766: PUSH
31767: EMPTY
31768: LIST
31769: LIST
31770: PUSH
31771: LD_INT 3
31773: PUSH
31774: LD_INT 0
31776: PUSH
31777: EMPTY
31778: LIST
31779: LIST
31780: PUSH
31781: LD_INT 3
31783: PUSH
31784: LD_INT 1
31786: PUSH
31787: EMPTY
31788: LIST
31789: LIST
31790: PUSH
31791: LD_INT 1
31793: PUSH
31794: LD_INT 3
31796: PUSH
31797: EMPTY
31798: LIST
31799: LIST
31800: PUSH
31801: LD_INT 0
31803: PUSH
31804: LD_INT 3
31806: PUSH
31807: EMPTY
31808: LIST
31809: LIST
31810: PUSH
31811: LD_INT 1
31813: NEG
31814: PUSH
31815: LD_INT 2
31817: PUSH
31818: EMPTY
31819: LIST
31820: LIST
31821: PUSH
31822: LD_INT 2
31824: NEG
31825: PUSH
31826: LD_INT 1
31828: PUSH
31829: EMPTY
31830: LIST
31831: LIST
31832: PUSH
31833: LD_INT 3
31835: NEG
31836: PUSH
31837: LD_INT 0
31839: PUSH
31840: EMPTY
31841: LIST
31842: LIST
31843: PUSH
31844: LD_INT 3
31846: NEG
31847: PUSH
31848: LD_INT 1
31850: NEG
31851: PUSH
31852: EMPTY
31853: LIST
31854: LIST
31855: PUSH
31856: EMPTY
31857: LIST
31858: LIST
31859: LIST
31860: LIST
31861: LIST
31862: LIST
31863: LIST
31864: LIST
31865: LIST
31866: LIST
31867: LIST
31868: LIST
31869: LIST
31870: LIST
31871: LIST
31872: LIST
31873: LIST
31874: LIST
31875: LIST
31876: LIST
31877: LIST
31878: LIST
31879: LIST
31880: LIST
31881: LIST
31882: LIST
31883: LIST
31884: LIST
31885: LIST
31886: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31887: LD_ADDR_VAR 0 44
31891: PUSH
31892: LD_INT 0
31894: PUSH
31895: LD_INT 0
31897: PUSH
31898: EMPTY
31899: LIST
31900: LIST
31901: PUSH
31902: LD_INT 0
31904: PUSH
31905: LD_INT 1
31907: NEG
31908: PUSH
31909: EMPTY
31910: LIST
31911: LIST
31912: PUSH
31913: LD_INT 1
31915: PUSH
31916: LD_INT 0
31918: PUSH
31919: EMPTY
31920: LIST
31921: LIST
31922: PUSH
31923: LD_INT 1
31925: PUSH
31926: LD_INT 1
31928: PUSH
31929: EMPTY
31930: LIST
31931: LIST
31932: PUSH
31933: LD_INT 0
31935: PUSH
31936: LD_INT 1
31938: PUSH
31939: EMPTY
31940: LIST
31941: LIST
31942: PUSH
31943: LD_INT 1
31945: NEG
31946: PUSH
31947: LD_INT 0
31949: PUSH
31950: EMPTY
31951: LIST
31952: LIST
31953: PUSH
31954: LD_INT 1
31956: NEG
31957: PUSH
31958: LD_INT 1
31960: NEG
31961: PUSH
31962: EMPTY
31963: LIST
31964: LIST
31965: PUSH
31966: LD_INT 1
31968: NEG
31969: PUSH
31970: LD_INT 2
31972: NEG
31973: PUSH
31974: EMPTY
31975: LIST
31976: LIST
31977: PUSH
31978: LD_INT 1
31980: PUSH
31981: LD_INT 1
31983: NEG
31984: PUSH
31985: EMPTY
31986: LIST
31987: LIST
31988: PUSH
31989: LD_INT 2
31991: PUSH
31992: LD_INT 0
31994: PUSH
31995: EMPTY
31996: LIST
31997: LIST
31998: PUSH
31999: LD_INT 2
32001: PUSH
32002: LD_INT 1
32004: PUSH
32005: EMPTY
32006: LIST
32007: LIST
32008: PUSH
32009: LD_INT 2
32011: PUSH
32012: LD_INT 2
32014: PUSH
32015: EMPTY
32016: LIST
32017: LIST
32018: PUSH
32019: LD_INT 1
32021: PUSH
32022: LD_INT 2
32024: PUSH
32025: EMPTY
32026: LIST
32027: LIST
32028: PUSH
32029: LD_INT 1
32031: NEG
32032: PUSH
32033: LD_INT 1
32035: PUSH
32036: EMPTY
32037: LIST
32038: LIST
32039: PUSH
32040: LD_INT 2
32042: NEG
32043: PUSH
32044: LD_INT 0
32046: PUSH
32047: EMPTY
32048: LIST
32049: LIST
32050: PUSH
32051: LD_INT 2
32053: NEG
32054: PUSH
32055: LD_INT 1
32057: NEG
32058: PUSH
32059: EMPTY
32060: LIST
32061: LIST
32062: PUSH
32063: LD_INT 2
32065: NEG
32066: PUSH
32067: LD_INT 2
32069: NEG
32070: PUSH
32071: EMPTY
32072: LIST
32073: LIST
32074: PUSH
32075: LD_INT 2
32077: NEG
32078: PUSH
32079: LD_INT 3
32081: NEG
32082: PUSH
32083: EMPTY
32084: LIST
32085: LIST
32086: PUSH
32087: LD_INT 2
32089: PUSH
32090: LD_INT 1
32092: NEG
32093: PUSH
32094: EMPTY
32095: LIST
32096: LIST
32097: PUSH
32098: LD_INT 3
32100: PUSH
32101: LD_INT 0
32103: PUSH
32104: EMPTY
32105: LIST
32106: LIST
32107: PUSH
32108: LD_INT 3
32110: PUSH
32111: LD_INT 1
32113: PUSH
32114: EMPTY
32115: LIST
32116: LIST
32117: PUSH
32118: LD_INT 3
32120: PUSH
32121: LD_INT 2
32123: PUSH
32124: EMPTY
32125: LIST
32126: LIST
32127: PUSH
32128: LD_INT 3
32130: PUSH
32131: LD_INT 3
32133: PUSH
32134: EMPTY
32135: LIST
32136: LIST
32137: PUSH
32138: LD_INT 2
32140: PUSH
32141: LD_INT 3
32143: PUSH
32144: EMPTY
32145: LIST
32146: LIST
32147: PUSH
32148: LD_INT 2
32150: NEG
32151: PUSH
32152: LD_INT 1
32154: PUSH
32155: EMPTY
32156: LIST
32157: LIST
32158: PUSH
32159: LD_INT 3
32161: NEG
32162: PUSH
32163: LD_INT 0
32165: PUSH
32166: EMPTY
32167: LIST
32168: LIST
32169: PUSH
32170: LD_INT 3
32172: NEG
32173: PUSH
32174: LD_INT 1
32176: NEG
32177: PUSH
32178: EMPTY
32179: LIST
32180: LIST
32181: PUSH
32182: LD_INT 3
32184: NEG
32185: PUSH
32186: LD_INT 2
32188: NEG
32189: PUSH
32190: EMPTY
32191: LIST
32192: LIST
32193: PUSH
32194: LD_INT 3
32196: NEG
32197: PUSH
32198: LD_INT 3
32200: NEG
32201: PUSH
32202: EMPTY
32203: LIST
32204: LIST
32205: PUSH
32206: EMPTY
32207: LIST
32208: LIST
32209: LIST
32210: LIST
32211: LIST
32212: LIST
32213: LIST
32214: LIST
32215: LIST
32216: LIST
32217: LIST
32218: LIST
32219: LIST
32220: LIST
32221: LIST
32222: LIST
32223: LIST
32224: LIST
32225: LIST
32226: LIST
32227: LIST
32228: LIST
32229: LIST
32230: LIST
32231: LIST
32232: LIST
32233: LIST
32234: LIST
32235: LIST
32236: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32237: LD_ADDR_VAR 0 45
32241: PUSH
32242: LD_INT 0
32244: PUSH
32245: LD_INT 0
32247: PUSH
32248: EMPTY
32249: LIST
32250: LIST
32251: PUSH
32252: LD_INT 0
32254: PUSH
32255: LD_INT 1
32257: NEG
32258: PUSH
32259: EMPTY
32260: LIST
32261: LIST
32262: PUSH
32263: LD_INT 1
32265: PUSH
32266: LD_INT 0
32268: PUSH
32269: EMPTY
32270: LIST
32271: LIST
32272: PUSH
32273: LD_INT 1
32275: PUSH
32276: LD_INT 1
32278: PUSH
32279: EMPTY
32280: LIST
32281: LIST
32282: PUSH
32283: LD_INT 0
32285: PUSH
32286: LD_INT 1
32288: PUSH
32289: EMPTY
32290: LIST
32291: LIST
32292: PUSH
32293: LD_INT 1
32295: NEG
32296: PUSH
32297: LD_INT 0
32299: PUSH
32300: EMPTY
32301: LIST
32302: LIST
32303: PUSH
32304: LD_INT 1
32306: NEG
32307: PUSH
32308: LD_INT 1
32310: NEG
32311: PUSH
32312: EMPTY
32313: LIST
32314: LIST
32315: PUSH
32316: LD_INT 1
32318: NEG
32319: PUSH
32320: LD_INT 2
32322: NEG
32323: PUSH
32324: EMPTY
32325: LIST
32326: LIST
32327: PUSH
32328: LD_INT 0
32330: PUSH
32331: LD_INT 2
32333: NEG
32334: PUSH
32335: EMPTY
32336: LIST
32337: LIST
32338: PUSH
32339: LD_INT 1
32341: PUSH
32342: LD_INT 1
32344: NEG
32345: PUSH
32346: EMPTY
32347: LIST
32348: LIST
32349: PUSH
32350: LD_INT 2
32352: PUSH
32353: LD_INT 1
32355: PUSH
32356: EMPTY
32357: LIST
32358: LIST
32359: PUSH
32360: LD_INT 2
32362: PUSH
32363: LD_INT 2
32365: PUSH
32366: EMPTY
32367: LIST
32368: LIST
32369: PUSH
32370: LD_INT 1
32372: PUSH
32373: LD_INT 2
32375: PUSH
32376: EMPTY
32377: LIST
32378: LIST
32379: PUSH
32380: LD_INT 0
32382: PUSH
32383: LD_INT 2
32385: PUSH
32386: EMPTY
32387: LIST
32388: LIST
32389: PUSH
32390: LD_INT 1
32392: NEG
32393: PUSH
32394: LD_INT 1
32396: PUSH
32397: EMPTY
32398: LIST
32399: LIST
32400: PUSH
32401: LD_INT 2
32403: NEG
32404: PUSH
32405: LD_INT 1
32407: NEG
32408: PUSH
32409: EMPTY
32410: LIST
32411: LIST
32412: PUSH
32413: LD_INT 2
32415: NEG
32416: PUSH
32417: LD_INT 2
32419: NEG
32420: PUSH
32421: EMPTY
32422: LIST
32423: LIST
32424: PUSH
32425: LD_INT 2
32427: NEG
32428: PUSH
32429: LD_INT 3
32431: NEG
32432: PUSH
32433: EMPTY
32434: LIST
32435: LIST
32436: PUSH
32437: LD_INT 1
32439: NEG
32440: PUSH
32441: LD_INT 3
32443: NEG
32444: PUSH
32445: EMPTY
32446: LIST
32447: LIST
32448: PUSH
32449: LD_INT 0
32451: PUSH
32452: LD_INT 3
32454: NEG
32455: PUSH
32456: EMPTY
32457: LIST
32458: LIST
32459: PUSH
32460: LD_INT 1
32462: PUSH
32463: LD_INT 2
32465: NEG
32466: PUSH
32467: EMPTY
32468: LIST
32469: LIST
32470: PUSH
32471: LD_INT 3
32473: PUSH
32474: LD_INT 2
32476: PUSH
32477: EMPTY
32478: LIST
32479: LIST
32480: PUSH
32481: LD_INT 3
32483: PUSH
32484: LD_INT 3
32486: PUSH
32487: EMPTY
32488: LIST
32489: LIST
32490: PUSH
32491: LD_INT 2
32493: PUSH
32494: LD_INT 3
32496: PUSH
32497: EMPTY
32498: LIST
32499: LIST
32500: PUSH
32501: LD_INT 1
32503: PUSH
32504: LD_INT 3
32506: PUSH
32507: EMPTY
32508: LIST
32509: LIST
32510: PUSH
32511: LD_INT 0
32513: PUSH
32514: LD_INT 3
32516: PUSH
32517: EMPTY
32518: LIST
32519: LIST
32520: PUSH
32521: LD_INT 1
32523: NEG
32524: PUSH
32525: LD_INT 2
32527: PUSH
32528: EMPTY
32529: LIST
32530: LIST
32531: PUSH
32532: LD_INT 3
32534: NEG
32535: PUSH
32536: LD_INT 2
32538: NEG
32539: PUSH
32540: EMPTY
32541: LIST
32542: LIST
32543: PUSH
32544: LD_INT 3
32546: NEG
32547: PUSH
32548: LD_INT 3
32550: NEG
32551: PUSH
32552: EMPTY
32553: LIST
32554: LIST
32555: PUSH
32556: EMPTY
32557: LIST
32558: LIST
32559: LIST
32560: LIST
32561: LIST
32562: LIST
32563: LIST
32564: LIST
32565: LIST
32566: LIST
32567: LIST
32568: LIST
32569: LIST
32570: LIST
32571: LIST
32572: LIST
32573: LIST
32574: LIST
32575: LIST
32576: LIST
32577: LIST
32578: LIST
32579: LIST
32580: LIST
32581: LIST
32582: LIST
32583: LIST
32584: LIST
32585: LIST
32586: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
32587: LD_ADDR_VAR 0 46
32591: PUSH
32592: LD_INT 0
32594: PUSH
32595: LD_INT 0
32597: PUSH
32598: EMPTY
32599: LIST
32600: LIST
32601: PUSH
32602: LD_INT 0
32604: PUSH
32605: LD_INT 1
32607: NEG
32608: PUSH
32609: EMPTY
32610: LIST
32611: LIST
32612: PUSH
32613: LD_INT 1
32615: PUSH
32616: LD_INT 0
32618: PUSH
32619: EMPTY
32620: LIST
32621: LIST
32622: PUSH
32623: LD_INT 1
32625: PUSH
32626: LD_INT 1
32628: PUSH
32629: EMPTY
32630: LIST
32631: LIST
32632: PUSH
32633: LD_INT 0
32635: PUSH
32636: LD_INT 1
32638: PUSH
32639: EMPTY
32640: LIST
32641: LIST
32642: PUSH
32643: LD_INT 1
32645: NEG
32646: PUSH
32647: LD_INT 0
32649: PUSH
32650: EMPTY
32651: LIST
32652: LIST
32653: PUSH
32654: LD_INT 1
32656: NEG
32657: PUSH
32658: LD_INT 1
32660: NEG
32661: PUSH
32662: EMPTY
32663: LIST
32664: LIST
32665: PUSH
32666: LD_INT 1
32668: NEG
32669: PUSH
32670: LD_INT 2
32672: NEG
32673: PUSH
32674: EMPTY
32675: LIST
32676: LIST
32677: PUSH
32678: LD_INT 0
32680: PUSH
32681: LD_INT 2
32683: NEG
32684: PUSH
32685: EMPTY
32686: LIST
32687: LIST
32688: PUSH
32689: LD_INT 1
32691: PUSH
32692: LD_INT 1
32694: NEG
32695: PUSH
32696: EMPTY
32697: LIST
32698: LIST
32699: PUSH
32700: LD_INT 2
32702: PUSH
32703: LD_INT 0
32705: PUSH
32706: EMPTY
32707: LIST
32708: LIST
32709: PUSH
32710: LD_INT 2
32712: PUSH
32713: LD_INT 1
32715: PUSH
32716: EMPTY
32717: LIST
32718: LIST
32719: PUSH
32720: LD_INT 1
32722: PUSH
32723: LD_INT 2
32725: PUSH
32726: EMPTY
32727: LIST
32728: LIST
32729: PUSH
32730: LD_INT 0
32732: PUSH
32733: LD_INT 2
32735: PUSH
32736: EMPTY
32737: LIST
32738: LIST
32739: PUSH
32740: LD_INT 1
32742: NEG
32743: PUSH
32744: LD_INT 1
32746: PUSH
32747: EMPTY
32748: LIST
32749: LIST
32750: PUSH
32751: LD_INT 2
32753: NEG
32754: PUSH
32755: LD_INT 0
32757: PUSH
32758: EMPTY
32759: LIST
32760: LIST
32761: PUSH
32762: LD_INT 2
32764: NEG
32765: PUSH
32766: LD_INT 1
32768: NEG
32769: PUSH
32770: EMPTY
32771: LIST
32772: LIST
32773: PUSH
32774: LD_INT 1
32776: NEG
32777: PUSH
32778: LD_INT 3
32780: NEG
32781: PUSH
32782: EMPTY
32783: LIST
32784: LIST
32785: PUSH
32786: LD_INT 0
32788: PUSH
32789: LD_INT 3
32791: NEG
32792: PUSH
32793: EMPTY
32794: LIST
32795: LIST
32796: PUSH
32797: LD_INT 1
32799: PUSH
32800: LD_INT 2
32802: NEG
32803: PUSH
32804: EMPTY
32805: LIST
32806: LIST
32807: PUSH
32808: LD_INT 2
32810: PUSH
32811: LD_INT 1
32813: NEG
32814: PUSH
32815: EMPTY
32816: LIST
32817: LIST
32818: PUSH
32819: LD_INT 3
32821: PUSH
32822: LD_INT 0
32824: PUSH
32825: EMPTY
32826: LIST
32827: LIST
32828: PUSH
32829: LD_INT 3
32831: PUSH
32832: LD_INT 1
32834: PUSH
32835: EMPTY
32836: LIST
32837: LIST
32838: PUSH
32839: LD_INT 1
32841: PUSH
32842: LD_INT 3
32844: PUSH
32845: EMPTY
32846: LIST
32847: LIST
32848: PUSH
32849: LD_INT 0
32851: PUSH
32852: LD_INT 3
32854: PUSH
32855: EMPTY
32856: LIST
32857: LIST
32858: PUSH
32859: LD_INT 1
32861: NEG
32862: PUSH
32863: LD_INT 2
32865: PUSH
32866: EMPTY
32867: LIST
32868: LIST
32869: PUSH
32870: LD_INT 2
32872: NEG
32873: PUSH
32874: LD_INT 1
32876: PUSH
32877: EMPTY
32878: LIST
32879: LIST
32880: PUSH
32881: LD_INT 3
32883: NEG
32884: PUSH
32885: LD_INT 0
32887: PUSH
32888: EMPTY
32889: LIST
32890: LIST
32891: PUSH
32892: LD_INT 3
32894: NEG
32895: PUSH
32896: LD_INT 1
32898: NEG
32899: PUSH
32900: EMPTY
32901: LIST
32902: LIST
32903: PUSH
32904: EMPTY
32905: LIST
32906: LIST
32907: LIST
32908: LIST
32909: LIST
32910: LIST
32911: LIST
32912: LIST
32913: LIST
32914: LIST
32915: LIST
32916: LIST
32917: LIST
32918: LIST
32919: LIST
32920: LIST
32921: LIST
32922: LIST
32923: LIST
32924: LIST
32925: LIST
32926: LIST
32927: LIST
32928: LIST
32929: LIST
32930: LIST
32931: LIST
32932: LIST
32933: LIST
32934: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32935: LD_ADDR_VAR 0 47
32939: PUSH
32940: LD_INT 0
32942: PUSH
32943: LD_INT 0
32945: PUSH
32946: EMPTY
32947: LIST
32948: LIST
32949: PUSH
32950: LD_INT 0
32952: PUSH
32953: LD_INT 1
32955: NEG
32956: PUSH
32957: EMPTY
32958: LIST
32959: LIST
32960: PUSH
32961: LD_INT 1
32963: PUSH
32964: LD_INT 0
32966: PUSH
32967: EMPTY
32968: LIST
32969: LIST
32970: PUSH
32971: LD_INT 1
32973: PUSH
32974: LD_INT 1
32976: PUSH
32977: EMPTY
32978: LIST
32979: LIST
32980: PUSH
32981: LD_INT 0
32983: PUSH
32984: LD_INT 1
32986: PUSH
32987: EMPTY
32988: LIST
32989: LIST
32990: PUSH
32991: LD_INT 1
32993: NEG
32994: PUSH
32995: LD_INT 0
32997: PUSH
32998: EMPTY
32999: LIST
33000: LIST
33001: PUSH
33002: LD_INT 1
33004: NEG
33005: PUSH
33006: LD_INT 1
33008: NEG
33009: PUSH
33010: EMPTY
33011: LIST
33012: LIST
33013: PUSH
33014: LD_INT 1
33016: NEG
33017: PUSH
33018: LD_INT 2
33020: NEG
33021: PUSH
33022: EMPTY
33023: LIST
33024: LIST
33025: PUSH
33026: LD_INT 0
33028: PUSH
33029: LD_INT 2
33031: NEG
33032: PUSH
33033: EMPTY
33034: LIST
33035: LIST
33036: PUSH
33037: LD_INT 1
33039: PUSH
33040: LD_INT 1
33042: NEG
33043: PUSH
33044: EMPTY
33045: LIST
33046: LIST
33047: PUSH
33048: LD_INT 2
33050: NEG
33051: PUSH
33052: LD_INT 1
33054: NEG
33055: PUSH
33056: EMPTY
33057: LIST
33058: LIST
33059: PUSH
33060: LD_INT 2
33062: NEG
33063: PUSH
33064: LD_INT 2
33066: NEG
33067: PUSH
33068: EMPTY
33069: LIST
33070: LIST
33071: PUSH
33072: EMPTY
33073: LIST
33074: LIST
33075: LIST
33076: LIST
33077: LIST
33078: LIST
33079: LIST
33080: LIST
33081: LIST
33082: LIST
33083: LIST
33084: LIST
33085: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
33086: LD_ADDR_VAR 0 48
33090: PUSH
33091: LD_INT 0
33093: PUSH
33094: LD_INT 0
33096: PUSH
33097: EMPTY
33098: LIST
33099: LIST
33100: PUSH
33101: LD_INT 0
33103: PUSH
33104: LD_INT 1
33106: NEG
33107: PUSH
33108: EMPTY
33109: LIST
33110: LIST
33111: PUSH
33112: LD_INT 1
33114: PUSH
33115: LD_INT 0
33117: PUSH
33118: EMPTY
33119: LIST
33120: LIST
33121: PUSH
33122: LD_INT 1
33124: PUSH
33125: LD_INT 1
33127: PUSH
33128: EMPTY
33129: LIST
33130: LIST
33131: PUSH
33132: LD_INT 0
33134: PUSH
33135: LD_INT 1
33137: PUSH
33138: EMPTY
33139: LIST
33140: LIST
33141: PUSH
33142: LD_INT 1
33144: NEG
33145: PUSH
33146: LD_INT 0
33148: PUSH
33149: EMPTY
33150: LIST
33151: LIST
33152: PUSH
33153: LD_INT 1
33155: NEG
33156: PUSH
33157: LD_INT 1
33159: NEG
33160: PUSH
33161: EMPTY
33162: LIST
33163: LIST
33164: PUSH
33165: LD_INT 1
33167: NEG
33168: PUSH
33169: LD_INT 2
33171: NEG
33172: PUSH
33173: EMPTY
33174: LIST
33175: LIST
33176: PUSH
33177: LD_INT 0
33179: PUSH
33180: LD_INT 2
33182: NEG
33183: PUSH
33184: EMPTY
33185: LIST
33186: LIST
33187: PUSH
33188: LD_INT 1
33190: PUSH
33191: LD_INT 1
33193: NEG
33194: PUSH
33195: EMPTY
33196: LIST
33197: LIST
33198: PUSH
33199: LD_INT 2
33201: PUSH
33202: LD_INT 0
33204: PUSH
33205: EMPTY
33206: LIST
33207: LIST
33208: PUSH
33209: LD_INT 2
33211: PUSH
33212: LD_INT 1
33214: PUSH
33215: EMPTY
33216: LIST
33217: LIST
33218: PUSH
33219: EMPTY
33220: LIST
33221: LIST
33222: LIST
33223: LIST
33224: LIST
33225: LIST
33226: LIST
33227: LIST
33228: LIST
33229: LIST
33230: LIST
33231: LIST
33232: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
33233: LD_ADDR_VAR 0 49
33237: PUSH
33238: LD_INT 0
33240: PUSH
33241: LD_INT 0
33243: PUSH
33244: EMPTY
33245: LIST
33246: LIST
33247: PUSH
33248: LD_INT 0
33250: PUSH
33251: LD_INT 1
33253: NEG
33254: PUSH
33255: EMPTY
33256: LIST
33257: LIST
33258: PUSH
33259: LD_INT 1
33261: PUSH
33262: LD_INT 0
33264: PUSH
33265: EMPTY
33266: LIST
33267: LIST
33268: PUSH
33269: LD_INT 1
33271: PUSH
33272: LD_INT 1
33274: PUSH
33275: EMPTY
33276: LIST
33277: LIST
33278: PUSH
33279: LD_INT 0
33281: PUSH
33282: LD_INT 1
33284: PUSH
33285: EMPTY
33286: LIST
33287: LIST
33288: PUSH
33289: LD_INT 1
33291: NEG
33292: PUSH
33293: LD_INT 0
33295: PUSH
33296: EMPTY
33297: LIST
33298: LIST
33299: PUSH
33300: LD_INT 1
33302: NEG
33303: PUSH
33304: LD_INT 1
33306: NEG
33307: PUSH
33308: EMPTY
33309: LIST
33310: LIST
33311: PUSH
33312: LD_INT 1
33314: PUSH
33315: LD_INT 1
33317: NEG
33318: PUSH
33319: EMPTY
33320: LIST
33321: LIST
33322: PUSH
33323: LD_INT 2
33325: PUSH
33326: LD_INT 0
33328: PUSH
33329: EMPTY
33330: LIST
33331: LIST
33332: PUSH
33333: LD_INT 2
33335: PUSH
33336: LD_INT 1
33338: PUSH
33339: EMPTY
33340: LIST
33341: LIST
33342: PUSH
33343: LD_INT 2
33345: PUSH
33346: LD_INT 2
33348: PUSH
33349: EMPTY
33350: LIST
33351: LIST
33352: PUSH
33353: LD_INT 1
33355: PUSH
33356: LD_INT 2
33358: PUSH
33359: EMPTY
33360: LIST
33361: LIST
33362: PUSH
33363: EMPTY
33364: LIST
33365: LIST
33366: LIST
33367: LIST
33368: LIST
33369: LIST
33370: LIST
33371: LIST
33372: LIST
33373: LIST
33374: LIST
33375: LIST
33376: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
33377: LD_ADDR_VAR 0 50
33381: PUSH
33382: LD_INT 0
33384: PUSH
33385: LD_INT 0
33387: PUSH
33388: EMPTY
33389: LIST
33390: LIST
33391: PUSH
33392: LD_INT 0
33394: PUSH
33395: LD_INT 1
33397: NEG
33398: PUSH
33399: EMPTY
33400: LIST
33401: LIST
33402: PUSH
33403: LD_INT 1
33405: PUSH
33406: LD_INT 0
33408: PUSH
33409: EMPTY
33410: LIST
33411: LIST
33412: PUSH
33413: LD_INT 1
33415: PUSH
33416: LD_INT 1
33418: PUSH
33419: EMPTY
33420: LIST
33421: LIST
33422: PUSH
33423: LD_INT 0
33425: PUSH
33426: LD_INT 1
33428: PUSH
33429: EMPTY
33430: LIST
33431: LIST
33432: PUSH
33433: LD_INT 1
33435: NEG
33436: PUSH
33437: LD_INT 0
33439: PUSH
33440: EMPTY
33441: LIST
33442: LIST
33443: PUSH
33444: LD_INT 1
33446: NEG
33447: PUSH
33448: LD_INT 1
33450: NEG
33451: PUSH
33452: EMPTY
33453: LIST
33454: LIST
33455: PUSH
33456: LD_INT 2
33458: PUSH
33459: LD_INT 1
33461: PUSH
33462: EMPTY
33463: LIST
33464: LIST
33465: PUSH
33466: LD_INT 2
33468: PUSH
33469: LD_INT 2
33471: PUSH
33472: EMPTY
33473: LIST
33474: LIST
33475: PUSH
33476: LD_INT 1
33478: PUSH
33479: LD_INT 2
33481: PUSH
33482: EMPTY
33483: LIST
33484: LIST
33485: PUSH
33486: LD_INT 0
33488: PUSH
33489: LD_INT 2
33491: PUSH
33492: EMPTY
33493: LIST
33494: LIST
33495: PUSH
33496: LD_INT 1
33498: NEG
33499: PUSH
33500: LD_INT 1
33502: PUSH
33503: EMPTY
33504: LIST
33505: LIST
33506: PUSH
33507: EMPTY
33508: LIST
33509: LIST
33510: LIST
33511: LIST
33512: LIST
33513: LIST
33514: LIST
33515: LIST
33516: LIST
33517: LIST
33518: LIST
33519: LIST
33520: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
33521: LD_ADDR_VAR 0 51
33525: PUSH
33526: LD_INT 0
33528: PUSH
33529: LD_INT 0
33531: PUSH
33532: EMPTY
33533: LIST
33534: LIST
33535: PUSH
33536: LD_INT 0
33538: PUSH
33539: LD_INT 1
33541: NEG
33542: PUSH
33543: EMPTY
33544: LIST
33545: LIST
33546: PUSH
33547: LD_INT 1
33549: PUSH
33550: LD_INT 0
33552: PUSH
33553: EMPTY
33554: LIST
33555: LIST
33556: PUSH
33557: LD_INT 1
33559: PUSH
33560: LD_INT 1
33562: PUSH
33563: EMPTY
33564: LIST
33565: LIST
33566: PUSH
33567: LD_INT 0
33569: PUSH
33570: LD_INT 1
33572: PUSH
33573: EMPTY
33574: LIST
33575: LIST
33576: PUSH
33577: LD_INT 1
33579: NEG
33580: PUSH
33581: LD_INT 0
33583: PUSH
33584: EMPTY
33585: LIST
33586: LIST
33587: PUSH
33588: LD_INT 1
33590: NEG
33591: PUSH
33592: LD_INT 1
33594: NEG
33595: PUSH
33596: EMPTY
33597: LIST
33598: LIST
33599: PUSH
33600: LD_INT 1
33602: PUSH
33603: LD_INT 2
33605: PUSH
33606: EMPTY
33607: LIST
33608: LIST
33609: PUSH
33610: LD_INT 0
33612: PUSH
33613: LD_INT 2
33615: PUSH
33616: EMPTY
33617: LIST
33618: LIST
33619: PUSH
33620: LD_INT 1
33622: NEG
33623: PUSH
33624: LD_INT 1
33626: PUSH
33627: EMPTY
33628: LIST
33629: LIST
33630: PUSH
33631: LD_INT 2
33633: NEG
33634: PUSH
33635: LD_INT 0
33637: PUSH
33638: EMPTY
33639: LIST
33640: LIST
33641: PUSH
33642: LD_INT 2
33644: NEG
33645: PUSH
33646: LD_INT 1
33648: NEG
33649: PUSH
33650: EMPTY
33651: LIST
33652: LIST
33653: PUSH
33654: EMPTY
33655: LIST
33656: LIST
33657: LIST
33658: LIST
33659: LIST
33660: LIST
33661: LIST
33662: LIST
33663: LIST
33664: LIST
33665: LIST
33666: LIST
33667: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33668: LD_ADDR_VAR 0 52
33672: PUSH
33673: LD_INT 0
33675: PUSH
33676: LD_INT 0
33678: PUSH
33679: EMPTY
33680: LIST
33681: LIST
33682: PUSH
33683: LD_INT 0
33685: PUSH
33686: LD_INT 1
33688: NEG
33689: PUSH
33690: EMPTY
33691: LIST
33692: LIST
33693: PUSH
33694: LD_INT 1
33696: PUSH
33697: LD_INT 0
33699: PUSH
33700: EMPTY
33701: LIST
33702: LIST
33703: PUSH
33704: LD_INT 1
33706: PUSH
33707: LD_INT 1
33709: PUSH
33710: EMPTY
33711: LIST
33712: LIST
33713: PUSH
33714: LD_INT 0
33716: PUSH
33717: LD_INT 1
33719: PUSH
33720: EMPTY
33721: LIST
33722: LIST
33723: PUSH
33724: LD_INT 1
33726: NEG
33727: PUSH
33728: LD_INT 0
33730: PUSH
33731: EMPTY
33732: LIST
33733: LIST
33734: PUSH
33735: LD_INT 1
33737: NEG
33738: PUSH
33739: LD_INT 1
33741: NEG
33742: PUSH
33743: EMPTY
33744: LIST
33745: LIST
33746: PUSH
33747: LD_INT 1
33749: NEG
33750: PUSH
33751: LD_INT 2
33753: NEG
33754: PUSH
33755: EMPTY
33756: LIST
33757: LIST
33758: PUSH
33759: LD_INT 1
33761: NEG
33762: PUSH
33763: LD_INT 1
33765: PUSH
33766: EMPTY
33767: LIST
33768: LIST
33769: PUSH
33770: LD_INT 2
33772: NEG
33773: PUSH
33774: LD_INT 0
33776: PUSH
33777: EMPTY
33778: LIST
33779: LIST
33780: PUSH
33781: LD_INT 2
33783: NEG
33784: PUSH
33785: LD_INT 1
33787: NEG
33788: PUSH
33789: EMPTY
33790: LIST
33791: LIST
33792: PUSH
33793: LD_INT 2
33795: NEG
33796: PUSH
33797: LD_INT 2
33799: NEG
33800: PUSH
33801: EMPTY
33802: LIST
33803: LIST
33804: PUSH
33805: EMPTY
33806: LIST
33807: LIST
33808: LIST
33809: LIST
33810: LIST
33811: LIST
33812: LIST
33813: LIST
33814: LIST
33815: LIST
33816: LIST
33817: LIST
33818: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33819: LD_ADDR_VAR 0 53
33823: PUSH
33824: LD_INT 0
33826: PUSH
33827: LD_INT 0
33829: PUSH
33830: EMPTY
33831: LIST
33832: LIST
33833: PUSH
33834: LD_INT 0
33836: PUSH
33837: LD_INT 1
33839: NEG
33840: PUSH
33841: EMPTY
33842: LIST
33843: LIST
33844: PUSH
33845: LD_INT 1
33847: PUSH
33848: LD_INT 0
33850: PUSH
33851: EMPTY
33852: LIST
33853: LIST
33854: PUSH
33855: LD_INT 1
33857: PUSH
33858: LD_INT 1
33860: PUSH
33861: EMPTY
33862: LIST
33863: LIST
33864: PUSH
33865: LD_INT 0
33867: PUSH
33868: LD_INT 1
33870: PUSH
33871: EMPTY
33872: LIST
33873: LIST
33874: PUSH
33875: LD_INT 1
33877: NEG
33878: PUSH
33879: LD_INT 0
33881: PUSH
33882: EMPTY
33883: LIST
33884: LIST
33885: PUSH
33886: LD_INT 1
33888: NEG
33889: PUSH
33890: LD_INT 1
33892: NEG
33893: PUSH
33894: EMPTY
33895: LIST
33896: LIST
33897: PUSH
33898: LD_INT 1
33900: NEG
33901: PUSH
33902: LD_INT 2
33904: NEG
33905: PUSH
33906: EMPTY
33907: LIST
33908: LIST
33909: PUSH
33910: LD_INT 0
33912: PUSH
33913: LD_INT 2
33915: NEG
33916: PUSH
33917: EMPTY
33918: LIST
33919: LIST
33920: PUSH
33921: LD_INT 1
33923: PUSH
33924: LD_INT 1
33926: NEG
33927: PUSH
33928: EMPTY
33929: LIST
33930: LIST
33931: PUSH
33932: LD_INT 2
33934: PUSH
33935: LD_INT 0
33937: PUSH
33938: EMPTY
33939: LIST
33940: LIST
33941: PUSH
33942: LD_INT 2
33944: PUSH
33945: LD_INT 1
33947: PUSH
33948: EMPTY
33949: LIST
33950: LIST
33951: PUSH
33952: LD_INT 2
33954: PUSH
33955: LD_INT 2
33957: PUSH
33958: EMPTY
33959: LIST
33960: LIST
33961: PUSH
33962: LD_INT 1
33964: PUSH
33965: LD_INT 2
33967: PUSH
33968: EMPTY
33969: LIST
33970: LIST
33971: PUSH
33972: LD_INT 0
33974: PUSH
33975: LD_INT 2
33977: PUSH
33978: EMPTY
33979: LIST
33980: LIST
33981: PUSH
33982: LD_INT 1
33984: NEG
33985: PUSH
33986: LD_INT 1
33988: PUSH
33989: EMPTY
33990: LIST
33991: LIST
33992: PUSH
33993: LD_INT 2
33995: NEG
33996: PUSH
33997: LD_INT 0
33999: PUSH
34000: EMPTY
34001: LIST
34002: LIST
34003: PUSH
34004: LD_INT 2
34006: NEG
34007: PUSH
34008: LD_INT 1
34010: NEG
34011: PUSH
34012: EMPTY
34013: LIST
34014: LIST
34015: PUSH
34016: LD_INT 2
34018: NEG
34019: PUSH
34020: LD_INT 2
34022: NEG
34023: PUSH
34024: EMPTY
34025: LIST
34026: LIST
34027: PUSH
34028: EMPTY
34029: LIST
34030: LIST
34031: LIST
34032: LIST
34033: LIST
34034: LIST
34035: LIST
34036: LIST
34037: LIST
34038: LIST
34039: LIST
34040: LIST
34041: LIST
34042: LIST
34043: LIST
34044: LIST
34045: LIST
34046: LIST
34047: LIST
34048: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34049: LD_ADDR_VAR 0 54
34053: PUSH
34054: LD_INT 0
34056: PUSH
34057: LD_INT 0
34059: PUSH
34060: EMPTY
34061: LIST
34062: LIST
34063: PUSH
34064: LD_INT 0
34066: PUSH
34067: LD_INT 1
34069: NEG
34070: PUSH
34071: EMPTY
34072: LIST
34073: LIST
34074: PUSH
34075: LD_INT 1
34077: PUSH
34078: LD_INT 0
34080: PUSH
34081: EMPTY
34082: LIST
34083: LIST
34084: PUSH
34085: LD_INT 1
34087: PUSH
34088: LD_INT 1
34090: PUSH
34091: EMPTY
34092: LIST
34093: LIST
34094: PUSH
34095: LD_INT 0
34097: PUSH
34098: LD_INT 1
34100: PUSH
34101: EMPTY
34102: LIST
34103: LIST
34104: PUSH
34105: LD_INT 1
34107: NEG
34108: PUSH
34109: LD_INT 0
34111: PUSH
34112: EMPTY
34113: LIST
34114: LIST
34115: PUSH
34116: LD_INT 1
34118: NEG
34119: PUSH
34120: LD_INT 1
34122: NEG
34123: PUSH
34124: EMPTY
34125: LIST
34126: LIST
34127: PUSH
34128: LD_INT 1
34130: NEG
34131: PUSH
34132: LD_INT 2
34134: NEG
34135: PUSH
34136: EMPTY
34137: LIST
34138: LIST
34139: PUSH
34140: LD_INT 0
34142: PUSH
34143: LD_INT 2
34145: NEG
34146: PUSH
34147: EMPTY
34148: LIST
34149: LIST
34150: PUSH
34151: LD_INT 1
34153: PUSH
34154: LD_INT 1
34156: NEG
34157: PUSH
34158: EMPTY
34159: LIST
34160: LIST
34161: PUSH
34162: LD_INT 2
34164: PUSH
34165: LD_INT 0
34167: PUSH
34168: EMPTY
34169: LIST
34170: LIST
34171: PUSH
34172: LD_INT 2
34174: PUSH
34175: LD_INT 1
34177: PUSH
34178: EMPTY
34179: LIST
34180: LIST
34181: PUSH
34182: LD_INT 2
34184: PUSH
34185: LD_INT 2
34187: PUSH
34188: EMPTY
34189: LIST
34190: LIST
34191: PUSH
34192: LD_INT 1
34194: PUSH
34195: LD_INT 2
34197: PUSH
34198: EMPTY
34199: LIST
34200: LIST
34201: PUSH
34202: LD_INT 0
34204: PUSH
34205: LD_INT 2
34207: PUSH
34208: EMPTY
34209: LIST
34210: LIST
34211: PUSH
34212: LD_INT 1
34214: NEG
34215: PUSH
34216: LD_INT 1
34218: PUSH
34219: EMPTY
34220: LIST
34221: LIST
34222: PUSH
34223: LD_INT 2
34225: NEG
34226: PUSH
34227: LD_INT 0
34229: PUSH
34230: EMPTY
34231: LIST
34232: LIST
34233: PUSH
34234: LD_INT 2
34236: NEG
34237: PUSH
34238: LD_INT 1
34240: NEG
34241: PUSH
34242: EMPTY
34243: LIST
34244: LIST
34245: PUSH
34246: LD_INT 2
34248: NEG
34249: PUSH
34250: LD_INT 2
34252: NEG
34253: PUSH
34254: EMPTY
34255: LIST
34256: LIST
34257: PUSH
34258: EMPTY
34259: LIST
34260: LIST
34261: LIST
34262: LIST
34263: LIST
34264: LIST
34265: LIST
34266: LIST
34267: LIST
34268: LIST
34269: LIST
34270: LIST
34271: LIST
34272: LIST
34273: LIST
34274: LIST
34275: LIST
34276: LIST
34277: LIST
34278: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34279: LD_ADDR_VAR 0 55
34283: PUSH
34284: LD_INT 0
34286: PUSH
34287: LD_INT 0
34289: PUSH
34290: EMPTY
34291: LIST
34292: LIST
34293: PUSH
34294: LD_INT 0
34296: PUSH
34297: LD_INT 1
34299: NEG
34300: PUSH
34301: EMPTY
34302: LIST
34303: LIST
34304: PUSH
34305: LD_INT 1
34307: PUSH
34308: LD_INT 0
34310: PUSH
34311: EMPTY
34312: LIST
34313: LIST
34314: PUSH
34315: LD_INT 1
34317: PUSH
34318: LD_INT 1
34320: PUSH
34321: EMPTY
34322: LIST
34323: LIST
34324: PUSH
34325: LD_INT 0
34327: PUSH
34328: LD_INT 1
34330: PUSH
34331: EMPTY
34332: LIST
34333: LIST
34334: PUSH
34335: LD_INT 1
34337: NEG
34338: PUSH
34339: LD_INT 0
34341: PUSH
34342: EMPTY
34343: LIST
34344: LIST
34345: PUSH
34346: LD_INT 1
34348: NEG
34349: PUSH
34350: LD_INT 1
34352: NEG
34353: PUSH
34354: EMPTY
34355: LIST
34356: LIST
34357: PUSH
34358: LD_INT 1
34360: NEG
34361: PUSH
34362: LD_INT 2
34364: NEG
34365: PUSH
34366: EMPTY
34367: LIST
34368: LIST
34369: PUSH
34370: LD_INT 0
34372: PUSH
34373: LD_INT 2
34375: NEG
34376: PUSH
34377: EMPTY
34378: LIST
34379: LIST
34380: PUSH
34381: LD_INT 1
34383: PUSH
34384: LD_INT 1
34386: NEG
34387: PUSH
34388: EMPTY
34389: LIST
34390: LIST
34391: PUSH
34392: LD_INT 2
34394: PUSH
34395: LD_INT 0
34397: PUSH
34398: EMPTY
34399: LIST
34400: LIST
34401: PUSH
34402: LD_INT 2
34404: PUSH
34405: LD_INT 1
34407: PUSH
34408: EMPTY
34409: LIST
34410: LIST
34411: PUSH
34412: LD_INT 2
34414: PUSH
34415: LD_INT 2
34417: PUSH
34418: EMPTY
34419: LIST
34420: LIST
34421: PUSH
34422: LD_INT 1
34424: PUSH
34425: LD_INT 2
34427: PUSH
34428: EMPTY
34429: LIST
34430: LIST
34431: PUSH
34432: LD_INT 0
34434: PUSH
34435: LD_INT 2
34437: PUSH
34438: EMPTY
34439: LIST
34440: LIST
34441: PUSH
34442: LD_INT 1
34444: NEG
34445: PUSH
34446: LD_INT 1
34448: PUSH
34449: EMPTY
34450: LIST
34451: LIST
34452: PUSH
34453: LD_INT 2
34455: NEG
34456: PUSH
34457: LD_INT 0
34459: PUSH
34460: EMPTY
34461: LIST
34462: LIST
34463: PUSH
34464: LD_INT 2
34466: NEG
34467: PUSH
34468: LD_INT 1
34470: NEG
34471: PUSH
34472: EMPTY
34473: LIST
34474: LIST
34475: PUSH
34476: LD_INT 2
34478: NEG
34479: PUSH
34480: LD_INT 2
34482: NEG
34483: PUSH
34484: EMPTY
34485: LIST
34486: LIST
34487: PUSH
34488: EMPTY
34489: LIST
34490: LIST
34491: LIST
34492: LIST
34493: LIST
34494: LIST
34495: LIST
34496: LIST
34497: LIST
34498: LIST
34499: LIST
34500: LIST
34501: LIST
34502: LIST
34503: LIST
34504: LIST
34505: LIST
34506: LIST
34507: LIST
34508: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34509: LD_ADDR_VAR 0 56
34513: PUSH
34514: LD_INT 0
34516: PUSH
34517: LD_INT 0
34519: PUSH
34520: EMPTY
34521: LIST
34522: LIST
34523: PUSH
34524: LD_INT 0
34526: PUSH
34527: LD_INT 1
34529: NEG
34530: PUSH
34531: EMPTY
34532: LIST
34533: LIST
34534: PUSH
34535: LD_INT 1
34537: PUSH
34538: LD_INT 0
34540: PUSH
34541: EMPTY
34542: LIST
34543: LIST
34544: PUSH
34545: LD_INT 1
34547: PUSH
34548: LD_INT 1
34550: PUSH
34551: EMPTY
34552: LIST
34553: LIST
34554: PUSH
34555: LD_INT 0
34557: PUSH
34558: LD_INT 1
34560: PUSH
34561: EMPTY
34562: LIST
34563: LIST
34564: PUSH
34565: LD_INT 1
34567: NEG
34568: PUSH
34569: LD_INT 0
34571: PUSH
34572: EMPTY
34573: LIST
34574: LIST
34575: PUSH
34576: LD_INT 1
34578: NEG
34579: PUSH
34580: LD_INT 1
34582: NEG
34583: PUSH
34584: EMPTY
34585: LIST
34586: LIST
34587: PUSH
34588: LD_INT 1
34590: NEG
34591: PUSH
34592: LD_INT 2
34594: NEG
34595: PUSH
34596: EMPTY
34597: LIST
34598: LIST
34599: PUSH
34600: LD_INT 0
34602: PUSH
34603: LD_INT 2
34605: NEG
34606: PUSH
34607: EMPTY
34608: LIST
34609: LIST
34610: PUSH
34611: LD_INT 1
34613: PUSH
34614: LD_INT 1
34616: NEG
34617: PUSH
34618: EMPTY
34619: LIST
34620: LIST
34621: PUSH
34622: LD_INT 2
34624: PUSH
34625: LD_INT 0
34627: PUSH
34628: EMPTY
34629: LIST
34630: LIST
34631: PUSH
34632: LD_INT 2
34634: PUSH
34635: LD_INT 1
34637: PUSH
34638: EMPTY
34639: LIST
34640: LIST
34641: PUSH
34642: LD_INT 2
34644: PUSH
34645: LD_INT 2
34647: PUSH
34648: EMPTY
34649: LIST
34650: LIST
34651: PUSH
34652: LD_INT 1
34654: PUSH
34655: LD_INT 2
34657: PUSH
34658: EMPTY
34659: LIST
34660: LIST
34661: PUSH
34662: LD_INT 0
34664: PUSH
34665: LD_INT 2
34667: PUSH
34668: EMPTY
34669: LIST
34670: LIST
34671: PUSH
34672: LD_INT 1
34674: NEG
34675: PUSH
34676: LD_INT 1
34678: PUSH
34679: EMPTY
34680: LIST
34681: LIST
34682: PUSH
34683: LD_INT 2
34685: NEG
34686: PUSH
34687: LD_INT 0
34689: PUSH
34690: EMPTY
34691: LIST
34692: LIST
34693: PUSH
34694: LD_INT 2
34696: NEG
34697: PUSH
34698: LD_INT 1
34700: NEG
34701: PUSH
34702: EMPTY
34703: LIST
34704: LIST
34705: PUSH
34706: LD_INT 2
34708: NEG
34709: PUSH
34710: LD_INT 2
34712: NEG
34713: PUSH
34714: EMPTY
34715: LIST
34716: LIST
34717: PUSH
34718: EMPTY
34719: LIST
34720: LIST
34721: LIST
34722: LIST
34723: LIST
34724: LIST
34725: LIST
34726: LIST
34727: LIST
34728: LIST
34729: LIST
34730: LIST
34731: LIST
34732: LIST
34733: LIST
34734: LIST
34735: LIST
34736: LIST
34737: LIST
34738: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34739: LD_ADDR_VAR 0 57
34743: PUSH
34744: LD_INT 0
34746: PUSH
34747: LD_INT 0
34749: PUSH
34750: EMPTY
34751: LIST
34752: LIST
34753: PUSH
34754: LD_INT 0
34756: PUSH
34757: LD_INT 1
34759: NEG
34760: PUSH
34761: EMPTY
34762: LIST
34763: LIST
34764: PUSH
34765: LD_INT 1
34767: PUSH
34768: LD_INT 0
34770: PUSH
34771: EMPTY
34772: LIST
34773: LIST
34774: PUSH
34775: LD_INT 1
34777: PUSH
34778: LD_INT 1
34780: PUSH
34781: EMPTY
34782: LIST
34783: LIST
34784: PUSH
34785: LD_INT 0
34787: PUSH
34788: LD_INT 1
34790: PUSH
34791: EMPTY
34792: LIST
34793: LIST
34794: PUSH
34795: LD_INT 1
34797: NEG
34798: PUSH
34799: LD_INT 0
34801: PUSH
34802: EMPTY
34803: LIST
34804: LIST
34805: PUSH
34806: LD_INT 1
34808: NEG
34809: PUSH
34810: LD_INT 1
34812: NEG
34813: PUSH
34814: EMPTY
34815: LIST
34816: LIST
34817: PUSH
34818: LD_INT 1
34820: NEG
34821: PUSH
34822: LD_INT 2
34824: NEG
34825: PUSH
34826: EMPTY
34827: LIST
34828: LIST
34829: PUSH
34830: LD_INT 0
34832: PUSH
34833: LD_INT 2
34835: NEG
34836: PUSH
34837: EMPTY
34838: LIST
34839: LIST
34840: PUSH
34841: LD_INT 1
34843: PUSH
34844: LD_INT 1
34846: NEG
34847: PUSH
34848: EMPTY
34849: LIST
34850: LIST
34851: PUSH
34852: LD_INT 2
34854: PUSH
34855: LD_INT 0
34857: PUSH
34858: EMPTY
34859: LIST
34860: LIST
34861: PUSH
34862: LD_INT 2
34864: PUSH
34865: LD_INT 1
34867: PUSH
34868: EMPTY
34869: LIST
34870: LIST
34871: PUSH
34872: LD_INT 2
34874: PUSH
34875: LD_INT 2
34877: PUSH
34878: EMPTY
34879: LIST
34880: LIST
34881: PUSH
34882: LD_INT 1
34884: PUSH
34885: LD_INT 2
34887: PUSH
34888: EMPTY
34889: LIST
34890: LIST
34891: PUSH
34892: LD_INT 0
34894: PUSH
34895: LD_INT 2
34897: PUSH
34898: EMPTY
34899: LIST
34900: LIST
34901: PUSH
34902: LD_INT 1
34904: NEG
34905: PUSH
34906: LD_INT 1
34908: PUSH
34909: EMPTY
34910: LIST
34911: LIST
34912: PUSH
34913: LD_INT 2
34915: NEG
34916: PUSH
34917: LD_INT 0
34919: PUSH
34920: EMPTY
34921: LIST
34922: LIST
34923: PUSH
34924: LD_INT 2
34926: NEG
34927: PUSH
34928: LD_INT 1
34930: NEG
34931: PUSH
34932: EMPTY
34933: LIST
34934: LIST
34935: PUSH
34936: LD_INT 2
34938: NEG
34939: PUSH
34940: LD_INT 2
34942: NEG
34943: PUSH
34944: EMPTY
34945: LIST
34946: LIST
34947: PUSH
34948: EMPTY
34949: LIST
34950: LIST
34951: LIST
34952: LIST
34953: LIST
34954: LIST
34955: LIST
34956: LIST
34957: LIST
34958: LIST
34959: LIST
34960: LIST
34961: LIST
34962: LIST
34963: LIST
34964: LIST
34965: LIST
34966: LIST
34967: LIST
34968: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34969: LD_ADDR_VAR 0 58
34973: PUSH
34974: LD_INT 0
34976: PUSH
34977: LD_INT 0
34979: PUSH
34980: EMPTY
34981: LIST
34982: LIST
34983: PUSH
34984: LD_INT 0
34986: PUSH
34987: LD_INT 1
34989: NEG
34990: PUSH
34991: EMPTY
34992: LIST
34993: LIST
34994: PUSH
34995: LD_INT 1
34997: PUSH
34998: LD_INT 0
35000: PUSH
35001: EMPTY
35002: LIST
35003: LIST
35004: PUSH
35005: LD_INT 1
35007: PUSH
35008: LD_INT 1
35010: PUSH
35011: EMPTY
35012: LIST
35013: LIST
35014: PUSH
35015: LD_INT 0
35017: PUSH
35018: LD_INT 1
35020: PUSH
35021: EMPTY
35022: LIST
35023: LIST
35024: PUSH
35025: LD_INT 1
35027: NEG
35028: PUSH
35029: LD_INT 0
35031: PUSH
35032: EMPTY
35033: LIST
35034: LIST
35035: PUSH
35036: LD_INT 1
35038: NEG
35039: PUSH
35040: LD_INT 1
35042: NEG
35043: PUSH
35044: EMPTY
35045: LIST
35046: LIST
35047: PUSH
35048: LD_INT 1
35050: NEG
35051: PUSH
35052: LD_INT 2
35054: NEG
35055: PUSH
35056: EMPTY
35057: LIST
35058: LIST
35059: PUSH
35060: LD_INT 0
35062: PUSH
35063: LD_INT 2
35065: NEG
35066: PUSH
35067: EMPTY
35068: LIST
35069: LIST
35070: PUSH
35071: LD_INT 1
35073: PUSH
35074: LD_INT 1
35076: NEG
35077: PUSH
35078: EMPTY
35079: LIST
35080: LIST
35081: PUSH
35082: LD_INT 2
35084: PUSH
35085: LD_INT 0
35087: PUSH
35088: EMPTY
35089: LIST
35090: LIST
35091: PUSH
35092: LD_INT 2
35094: PUSH
35095: LD_INT 1
35097: PUSH
35098: EMPTY
35099: LIST
35100: LIST
35101: PUSH
35102: LD_INT 2
35104: PUSH
35105: LD_INT 2
35107: PUSH
35108: EMPTY
35109: LIST
35110: LIST
35111: PUSH
35112: LD_INT 1
35114: PUSH
35115: LD_INT 2
35117: PUSH
35118: EMPTY
35119: LIST
35120: LIST
35121: PUSH
35122: LD_INT 0
35124: PUSH
35125: LD_INT 2
35127: PUSH
35128: EMPTY
35129: LIST
35130: LIST
35131: PUSH
35132: LD_INT 1
35134: NEG
35135: PUSH
35136: LD_INT 1
35138: PUSH
35139: EMPTY
35140: LIST
35141: LIST
35142: PUSH
35143: LD_INT 2
35145: NEG
35146: PUSH
35147: LD_INT 0
35149: PUSH
35150: EMPTY
35151: LIST
35152: LIST
35153: PUSH
35154: LD_INT 2
35156: NEG
35157: PUSH
35158: LD_INT 1
35160: NEG
35161: PUSH
35162: EMPTY
35163: LIST
35164: LIST
35165: PUSH
35166: LD_INT 2
35168: NEG
35169: PUSH
35170: LD_INT 2
35172: NEG
35173: PUSH
35174: EMPTY
35175: LIST
35176: LIST
35177: PUSH
35178: EMPTY
35179: LIST
35180: LIST
35181: LIST
35182: LIST
35183: LIST
35184: LIST
35185: LIST
35186: LIST
35187: LIST
35188: LIST
35189: LIST
35190: LIST
35191: LIST
35192: LIST
35193: LIST
35194: LIST
35195: LIST
35196: LIST
35197: LIST
35198: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35199: LD_ADDR_VAR 0 59
35203: PUSH
35204: LD_INT 0
35206: PUSH
35207: LD_INT 0
35209: PUSH
35210: EMPTY
35211: LIST
35212: LIST
35213: PUSH
35214: LD_INT 0
35216: PUSH
35217: LD_INT 1
35219: NEG
35220: PUSH
35221: EMPTY
35222: LIST
35223: LIST
35224: PUSH
35225: LD_INT 1
35227: PUSH
35228: LD_INT 0
35230: PUSH
35231: EMPTY
35232: LIST
35233: LIST
35234: PUSH
35235: LD_INT 1
35237: PUSH
35238: LD_INT 1
35240: PUSH
35241: EMPTY
35242: LIST
35243: LIST
35244: PUSH
35245: LD_INT 0
35247: PUSH
35248: LD_INT 1
35250: PUSH
35251: EMPTY
35252: LIST
35253: LIST
35254: PUSH
35255: LD_INT 1
35257: NEG
35258: PUSH
35259: LD_INT 0
35261: PUSH
35262: EMPTY
35263: LIST
35264: LIST
35265: PUSH
35266: LD_INT 1
35268: NEG
35269: PUSH
35270: LD_INT 1
35272: NEG
35273: PUSH
35274: EMPTY
35275: LIST
35276: LIST
35277: PUSH
35278: EMPTY
35279: LIST
35280: LIST
35281: LIST
35282: LIST
35283: LIST
35284: LIST
35285: LIST
35286: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35287: LD_ADDR_VAR 0 60
35291: PUSH
35292: LD_INT 0
35294: PUSH
35295: LD_INT 0
35297: PUSH
35298: EMPTY
35299: LIST
35300: LIST
35301: PUSH
35302: LD_INT 0
35304: PUSH
35305: LD_INT 1
35307: NEG
35308: PUSH
35309: EMPTY
35310: LIST
35311: LIST
35312: PUSH
35313: LD_INT 1
35315: PUSH
35316: LD_INT 0
35318: PUSH
35319: EMPTY
35320: LIST
35321: LIST
35322: PUSH
35323: LD_INT 1
35325: PUSH
35326: LD_INT 1
35328: PUSH
35329: EMPTY
35330: LIST
35331: LIST
35332: PUSH
35333: LD_INT 0
35335: PUSH
35336: LD_INT 1
35338: PUSH
35339: EMPTY
35340: LIST
35341: LIST
35342: PUSH
35343: LD_INT 1
35345: NEG
35346: PUSH
35347: LD_INT 0
35349: PUSH
35350: EMPTY
35351: LIST
35352: LIST
35353: PUSH
35354: LD_INT 1
35356: NEG
35357: PUSH
35358: LD_INT 1
35360: NEG
35361: PUSH
35362: EMPTY
35363: LIST
35364: LIST
35365: PUSH
35366: EMPTY
35367: LIST
35368: LIST
35369: LIST
35370: LIST
35371: LIST
35372: LIST
35373: LIST
35374: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35375: LD_ADDR_VAR 0 61
35379: PUSH
35380: LD_INT 0
35382: PUSH
35383: LD_INT 0
35385: PUSH
35386: EMPTY
35387: LIST
35388: LIST
35389: PUSH
35390: LD_INT 0
35392: PUSH
35393: LD_INT 1
35395: NEG
35396: PUSH
35397: EMPTY
35398: LIST
35399: LIST
35400: PUSH
35401: LD_INT 1
35403: PUSH
35404: LD_INT 0
35406: PUSH
35407: EMPTY
35408: LIST
35409: LIST
35410: PUSH
35411: LD_INT 1
35413: PUSH
35414: LD_INT 1
35416: PUSH
35417: EMPTY
35418: LIST
35419: LIST
35420: PUSH
35421: LD_INT 0
35423: PUSH
35424: LD_INT 1
35426: PUSH
35427: EMPTY
35428: LIST
35429: LIST
35430: PUSH
35431: LD_INT 1
35433: NEG
35434: PUSH
35435: LD_INT 0
35437: PUSH
35438: EMPTY
35439: LIST
35440: LIST
35441: PUSH
35442: LD_INT 1
35444: NEG
35445: PUSH
35446: LD_INT 1
35448: NEG
35449: PUSH
35450: EMPTY
35451: LIST
35452: LIST
35453: PUSH
35454: EMPTY
35455: LIST
35456: LIST
35457: LIST
35458: LIST
35459: LIST
35460: LIST
35461: LIST
35462: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35463: LD_ADDR_VAR 0 62
35467: PUSH
35468: LD_INT 0
35470: PUSH
35471: LD_INT 0
35473: PUSH
35474: EMPTY
35475: LIST
35476: LIST
35477: PUSH
35478: LD_INT 0
35480: PUSH
35481: LD_INT 1
35483: NEG
35484: PUSH
35485: EMPTY
35486: LIST
35487: LIST
35488: PUSH
35489: LD_INT 1
35491: PUSH
35492: LD_INT 0
35494: PUSH
35495: EMPTY
35496: LIST
35497: LIST
35498: PUSH
35499: LD_INT 1
35501: PUSH
35502: LD_INT 1
35504: PUSH
35505: EMPTY
35506: LIST
35507: LIST
35508: PUSH
35509: LD_INT 0
35511: PUSH
35512: LD_INT 1
35514: PUSH
35515: EMPTY
35516: LIST
35517: LIST
35518: PUSH
35519: LD_INT 1
35521: NEG
35522: PUSH
35523: LD_INT 0
35525: PUSH
35526: EMPTY
35527: LIST
35528: LIST
35529: PUSH
35530: LD_INT 1
35532: NEG
35533: PUSH
35534: LD_INT 1
35536: NEG
35537: PUSH
35538: EMPTY
35539: LIST
35540: LIST
35541: PUSH
35542: EMPTY
35543: LIST
35544: LIST
35545: LIST
35546: LIST
35547: LIST
35548: LIST
35549: LIST
35550: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35551: LD_ADDR_VAR 0 63
35555: PUSH
35556: LD_INT 0
35558: PUSH
35559: LD_INT 0
35561: PUSH
35562: EMPTY
35563: LIST
35564: LIST
35565: PUSH
35566: LD_INT 0
35568: PUSH
35569: LD_INT 1
35571: NEG
35572: PUSH
35573: EMPTY
35574: LIST
35575: LIST
35576: PUSH
35577: LD_INT 1
35579: PUSH
35580: LD_INT 0
35582: PUSH
35583: EMPTY
35584: LIST
35585: LIST
35586: PUSH
35587: LD_INT 1
35589: PUSH
35590: LD_INT 1
35592: PUSH
35593: EMPTY
35594: LIST
35595: LIST
35596: PUSH
35597: LD_INT 0
35599: PUSH
35600: LD_INT 1
35602: PUSH
35603: EMPTY
35604: LIST
35605: LIST
35606: PUSH
35607: LD_INT 1
35609: NEG
35610: PUSH
35611: LD_INT 0
35613: PUSH
35614: EMPTY
35615: LIST
35616: LIST
35617: PUSH
35618: LD_INT 1
35620: NEG
35621: PUSH
35622: LD_INT 1
35624: NEG
35625: PUSH
35626: EMPTY
35627: LIST
35628: LIST
35629: PUSH
35630: EMPTY
35631: LIST
35632: LIST
35633: LIST
35634: LIST
35635: LIST
35636: LIST
35637: LIST
35638: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35639: LD_ADDR_VAR 0 64
35643: PUSH
35644: LD_INT 0
35646: PUSH
35647: LD_INT 0
35649: PUSH
35650: EMPTY
35651: LIST
35652: LIST
35653: PUSH
35654: LD_INT 0
35656: PUSH
35657: LD_INT 1
35659: NEG
35660: PUSH
35661: EMPTY
35662: LIST
35663: LIST
35664: PUSH
35665: LD_INT 1
35667: PUSH
35668: LD_INT 0
35670: PUSH
35671: EMPTY
35672: LIST
35673: LIST
35674: PUSH
35675: LD_INT 1
35677: PUSH
35678: LD_INT 1
35680: PUSH
35681: EMPTY
35682: LIST
35683: LIST
35684: PUSH
35685: LD_INT 0
35687: PUSH
35688: LD_INT 1
35690: PUSH
35691: EMPTY
35692: LIST
35693: LIST
35694: PUSH
35695: LD_INT 1
35697: NEG
35698: PUSH
35699: LD_INT 0
35701: PUSH
35702: EMPTY
35703: LIST
35704: LIST
35705: PUSH
35706: LD_INT 1
35708: NEG
35709: PUSH
35710: LD_INT 1
35712: NEG
35713: PUSH
35714: EMPTY
35715: LIST
35716: LIST
35717: PUSH
35718: EMPTY
35719: LIST
35720: LIST
35721: LIST
35722: LIST
35723: LIST
35724: LIST
35725: LIST
35726: ST_TO_ADDR
// end ; 1 :
35727: GO 41624
35729: LD_INT 1
35731: DOUBLE
35732: EQUAL
35733: IFTRUE 35737
35735: GO 38360
35737: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
35738: LD_ADDR_VAR 0 11
35742: PUSH
35743: LD_INT 1
35745: NEG
35746: PUSH
35747: LD_INT 3
35749: NEG
35750: PUSH
35751: EMPTY
35752: LIST
35753: LIST
35754: PUSH
35755: LD_INT 0
35757: PUSH
35758: LD_INT 3
35760: NEG
35761: PUSH
35762: EMPTY
35763: LIST
35764: LIST
35765: PUSH
35766: LD_INT 1
35768: PUSH
35769: LD_INT 2
35771: NEG
35772: PUSH
35773: EMPTY
35774: LIST
35775: LIST
35776: PUSH
35777: EMPTY
35778: LIST
35779: LIST
35780: LIST
35781: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
35782: LD_ADDR_VAR 0 12
35786: PUSH
35787: LD_INT 2
35789: PUSH
35790: LD_INT 1
35792: NEG
35793: PUSH
35794: EMPTY
35795: LIST
35796: LIST
35797: PUSH
35798: LD_INT 3
35800: PUSH
35801: LD_INT 0
35803: PUSH
35804: EMPTY
35805: LIST
35806: LIST
35807: PUSH
35808: LD_INT 3
35810: PUSH
35811: LD_INT 1
35813: PUSH
35814: EMPTY
35815: LIST
35816: LIST
35817: PUSH
35818: EMPTY
35819: LIST
35820: LIST
35821: LIST
35822: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
35823: LD_ADDR_VAR 0 13
35827: PUSH
35828: LD_INT 3
35830: PUSH
35831: LD_INT 2
35833: PUSH
35834: EMPTY
35835: LIST
35836: LIST
35837: PUSH
35838: LD_INT 3
35840: PUSH
35841: LD_INT 3
35843: PUSH
35844: EMPTY
35845: LIST
35846: LIST
35847: PUSH
35848: LD_INT 2
35850: PUSH
35851: LD_INT 3
35853: PUSH
35854: EMPTY
35855: LIST
35856: LIST
35857: PUSH
35858: EMPTY
35859: LIST
35860: LIST
35861: LIST
35862: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
35863: LD_ADDR_VAR 0 14
35867: PUSH
35868: LD_INT 1
35870: PUSH
35871: LD_INT 3
35873: PUSH
35874: EMPTY
35875: LIST
35876: LIST
35877: PUSH
35878: LD_INT 0
35880: PUSH
35881: LD_INT 3
35883: PUSH
35884: EMPTY
35885: LIST
35886: LIST
35887: PUSH
35888: LD_INT 1
35890: NEG
35891: PUSH
35892: LD_INT 2
35894: PUSH
35895: EMPTY
35896: LIST
35897: LIST
35898: PUSH
35899: EMPTY
35900: LIST
35901: LIST
35902: LIST
35903: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35904: LD_ADDR_VAR 0 15
35908: PUSH
35909: LD_INT 2
35911: NEG
35912: PUSH
35913: LD_INT 1
35915: PUSH
35916: EMPTY
35917: LIST
35918: LIST
35919: PUSH
35920: LD_INT 3
35922: NEG
35923: PUSH
35924: LD_INT 0
35926: PUSH
35927: EMPTY
35928: LIST
35929: LIST
35930: PUSH
35931: LD_INT 3
35933: NEG
35934: PUSH
35935: LD_INT 1
35937: NEG
35938: PUSH
35939: EMPTY
35940: LIST
35941: LIST
35942: PUSH
35943: EMPTY
35944: LIST
35945: LIST
35946: LIST
35947: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35948: LD_ADDR_VAR 0 16
35952: PUSH
35953: LD_INT 2
35955: NEG
35956: PUSH
35957: LD_INT 3
35959: NEG
35960: PUSH
35961: EMPTY
35962: LIST
35963: LIST
35964: PUSH
35965: LD_INT 3
35967: NEG
35968: PUSH
35969: LD_INT 2
35971: NEG
35972: PUSH
35973: EMPTY
35974: LIST
35975: LIST
35976: PUSH
35977: LD_INT 3
35979: NEG
35980: PUSH
35981: LD_INT 3
35983: NEG
35984: PUSH
35985: EMPTY
35986: LIST
35987: LIST
35988: PUSH
35989: EMPTY
35990: LIST
35991: LIST
35992: LIST
35993: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
35994: LD_ADDR_VAR 0 17
35998: PUSH
35999: LD_INT 1
36001: NEG
36002: PUSH
36003: LD_INT 3
36005: NEG
36006: PUSH
36007: EMPTY
36008: LIST
36009: LIST
36010: PUSH
36011: LD_INT 0
36013: PUSH
36014: LD_INT 3
36016: NEG
36017: PUSH
36018: EMPTY
36019: LIST
36020: LIST
36021: PUSH
36022: LD_INT 1
36024: PUSH
36025: LD_INT 2
36027: NEG
36028: PUSH
36029: EMPTY
36030: LIST
36031: LIST
36032: PUSH
36033: EMPTY
36034: LIST
36035: LIST
36036: LIST
36037: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
36038: LD_ADDR_VAR 0 18
36042: PUSH
36043: LD_INT 2
36045: PUSH
36046: LD_INT 1
36048: NEG
36049: PUSH
36050: EMPTY
36051: LIST
36052: LIST
36053: PUSH
36054: LD_INT 3
36056: PUSH
36057: LD_INT 0
36059: PUSH
36060: EMPTY
36061: LIST
36062: LIST
36063: PUSH
36064: LD_INT 3
36066: PUSH
36067: LD_INT 1
36069: PUSH
36070: EMPTY
36071: LIST
36072: LIST
36073: PUSH
36074: EMPTY
36075: LIST
36076: LIST
36077: LIST
36078: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
36079: LD_ADDR_VAR 0 19
36083: PUSH
36084: LD_INT 3
36086: PUSH
36087: LD_INT 2
36089: PUSH
36090: EMPTY
36091: LIST
36092: LIST
36093: PUSH
36094: LD_INT 3
36096: PUSH
36097: LD_INT 3
36099: PUSH
36100: EMPTY
36101: LIST
36102: LIST
36103: PUSH
36104: LD_INT 2
36106: PUSH
36107: LD_INT 3
36109: PUSH
36110: EMPTY
36111: LIST
36112: LIST
36113: PUSH
36114: EMPTY
36115: LIST
36116: LIST
36117: LIST
36118: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
36119: LD_ADDR_VAR 0 20
36123: PUSH
36124: LD_INT 1
36126: PUSH
36127: LD_INT 3
36129: PUSH
36130: EMPTY
36131: LIST
36132: LIST
36133: PUSH
36134: LD_INT 0
36136: PUSH
36137: LD_INT 3
36139: PUSH
36140: EMPTY
36141: LIST
36142: LIST
36143: PUSH
36144: LD_INT 1
36146: NEG
36147: PUSH
36148: LD_INT 2
36150: PUSH
36151: EMPTY
36152: LIST
36153: LIST
36154: PUSH
36155: EMPTY
36156: LIST
36157: LIST
36158: LIST
36159: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36160: LD_ADDR_VAR 0 21
36164: PUSH
36165: LD_INT 2
36167: NEG
36168: PUSH
36169: LD_INT 1
36171: PUSH
36172: EMPTY
36173: LIST
36174: LIST
36175: PUSH
36176: LD_INT 3
36178: NEG
36179: PUSH
36180: LD_INT 0
36182: PUSH
36183: EMPTY
36184: LIST
36185: LIST
36186: PUSH
36187: LD_INT 3
36189: NEG
36190: PUSH
36191: LD_INT 1
36193: NEG
36194: PUSH
36195: EMPTY
36196: LIST
36197: LIST
36198: PUSH
36199: EMPTY
36200: LIST
36201: LIST
36202: LIST
36203: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36204: LD_ADDR_VAR 0 22
36208: PUSH
36209: LD_INT 2
36211: NEG
36212: PUSH
36213: LD_INT 3
36215: NEG
36216: PUSH
36217: EMPTY
36218: LIST
36219: LIST
36220: PUSH
36221: LD_INT 3
36223: NEG
36224: PUSH
36225: LD_INT 2
36227: NEG
36228: PUSH
36229: EMPTY
36230: LIST
36231: LIST
36232: PUSH
36233: LD_INT 3
36235: NEG
36236: PUSH
36237: LD_INT 3
36239: NEG
36240: PUSH
36241: EMPTY
36242: LIST
36243: LIST
36244: PUSH
36245: EMPTY
36246: LIST
36247: LIST
36248: LIST
36249: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
36250: LD_ADDR_VAR 0 23
36254: PUSH
36255: LD_INT 0
36257: PUSH
36258: LD_INT 3
36260: NEG
36261: PUSH
36262: EMPTY
36263: LIST
36264: LIST
36265: PUSH
36266: LD_INT 1
36268: NEG
36269: PUSH
36270: LD_INT 4
36272: NEG
36273: PUSH
36274: EMPTY
36275: LIST
36276: LIST
36277: PUSH
36278: LD_INT 1
36280: PUSH
36281: LD_INT 3
36283: NEG
36284: PUSH
36285: EMPTY
36286: LIST
36287: LIST
36288: PUSH
36289: EMPTY
36290: LIST
36291: LIST
36292: LIST
36293: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
36294: LD_ADDR_VAR 0 24
36298: PUSH
36299: LD_INT 3
36301: PUSH
36302: LD_INT 0
36304: PUSH
36305: EMPTY
36306: LIST
36307: LIST
36308: PUSH
36309: LD_INT 3
36311: PUSH
36312: LD_INT 1
36314: NEG
36315: PUSH
36316: EMPTY
36317: LIST
36318: LIST
36319: PUSH
36320: LD_INT 4
36322: PUSH
36323: LD_INT 1
36325: PUSH
36326: EMPTY
36327: LIST
36328: LIST
36329: PUSH
36330: EMPTY
36331: LIST
36332: LIST
36333: LIST
36334: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
36335: LD_ADDR_VAR 0 25
36339: PUSH
36340: LD_INT 3
36342: PUSH
36343: LD_INT 3
36345: PUSH
36346: EMPTY
36347: LIST
36348: LIST
36349: PUSH
36350: LD_INT 4
36352: PUSH
36353: LD_INT 3
36355: PUSH
36356: EMPTY
36357: LIST
36358: LIST
36359: PUSH
36360: LD_INT 3
36362: PUSH
36363: LD_INT 4
36365: PUSH
36366: EMPTY
36367: LIST
36368: LIST
36369: PUSH
36370: EMPTY
36371: LIST
36372: LIST
36373: LIST
36374: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
36375: LD_ADDR_VAR 0 26
36379: PUSH
36380: LD_INT 0
36382: PUSH
36383: LD_INT 3
36385: PUSH
36386: EMPTY
36387: LIST
36388: LIST
36389: PUSH
36390: LD_INT 1
36392: PUSH
36393: LD_INT 4
36395: PUSH
36396: EMPTY
36397: LIST
36398: LIST
36399: PUSH
36400: LD_INT 1
36402: NEG
36403: PUSH
36404: LD_INT 3
36406: PUSH
36407: EMPTY
36408: LIST
36409: LIST
36410: PUSH
36411: EMPTY
36412: LIST
36413: LIST
36414: LIST
36415: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
36416: LD_ADDR_VAR 0 27
36420: PUSH
36421: LD_INT 3
36423: NEG
36424: PUSH
36425: LD_INT 0
36427: PUSH
36428: EMPTY
36429: LIST
36430: LIST
36431: PUSH
36432: LD_INT 3
36434: NEG
36435: PUSH
36436: LD_INT 1
36438: PUSH
36439: EMPTY
36440: LIST
36441: LIST
36442: PUSH
36443: LD_INT 4
36445: NEG
36446: PUSH
36447: LD_INT 1
36449: NEG
36450: PUSH
36451: EMPTY
36452: LIST
36453: LIST
36454: PUSH
36455: EMPTY
36456: LIST
36457: LIST
36458: LIST
36459: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
36460: LD_ADDR_VAR 0 28
36464: PUSH
36465: LD_INT 3
36467: NEG
36468: PUSH
36469: LD_INT 3
36471: NEG
36472: PUSH
36473: EMPTY
36474: LIST
36475: LIST
36476: PUSH
36477: LD_INT 3
36479: NEG
36480: PUSH
36481: LD_INT 4
36483: NEG
36484: PUSH
36485: EMPTY
36486: LIST
36487: LIST
36488: PUSH
36489: LD_INT 4
36491: NEG
36492: PUSH
36493: LD_INT 3
36495: NEG
36496: PUSH
36497: EMPTY
36498: LIST
36499: LIST
36500: PUSH
36501: EMPTY
36502: LIST
36503: LIST
36504: LIST
36505: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
36506: LD_ADDR_VAR 0 29
36510: PUSH
36511: LD_INT 1
36513: NEG
36514: PUSH
36515: LD_INT 3
36517: NEG
36518: PUSH
36519: EMPTY
36520: LIST
36521: LIST
36522: PUSH
36523: LD_INT 0
36525: PUSH
36526: LD_INT 3
36528: NEG
36529: PUSH
36530: EMPTY
36531: LIST
36532: LIST
36533: PUSH
36534: LD_INT 1
36536: PUSH
36537: LD_INT 2
36539: NEG
36540: PUSH
36541: EMPTY
36542: LIST
36543: LIST
36544: PUSH
36545: LD_INT 1
36547: NEG
36548: PUSH
36549: LD_INT 4
36551: NEG
36552: PUSH
36553: EMPTY
36554: LIST
36555: LIST
36556: PUSH
36557: LD_INT 0
36559: PUSH
36560: LD_INT 4
36562: NEG
36563: PUSH
36564: EMPTY
36565: LIST
36566: LIST
36567: PUSH
36568: LD_INT 1
36570: PUSH
36571: LD_INT 3
36573: NEG
36574: PUSH
36575: EMPTY
36576: LIST
36577: LIST
36578: PUSH
36579: LD_INT 1
36581: NEG
36582: PUSH
36583: LD_INT 5
36585: NEG
36586: PUSH
36587: EMPTY
36588: LIST
36589: LIST
36590: PUSH
36591: LD_INT 0
36593: PUSH
36594: LD_INT 5
36596: NEG
36597: PUSH
36598: EMPTY
36599: LIST
36600: LIST
36601: PUSH
36602: LD_INT 1
36604: PUSH
36605: LD_INT 4
36607: NEG
36608: PUSH
36609: EMPTY
36610: LIST
36611: LIST
36612: PUSH
36613: LD_INT 1
36615: NEG
36616: PUSH
36617: LD_INT 6
36619: NEG
36620: PUSH
36621: EMPTY
36622: LIST
36623: LIST
36624: PUSH
36625: LD_INT 0
36627: PUSH
36628: LD_INT 6
36630: NEG
36631: PUSH
36632: EMPTY
36633: LIST
36634: LIST
36635: PUSH
36636: LD_INT 1
36638: PUSH
36639: LD_INT 5
36641: NEG
36642: PUSH
36643: EMPTY
36644: LIST
36645: LIST
36646: PUSH
36647: EMPTY
36648: LIST
36649: LIST
36650: LIST
36651: LIST
36652: LIST
36653: LIST
36654: LIST
36655: LIST
36656: LIST
36657: LIST
36658: LIST
36659: LIST
36660: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
36661: LD_ADDR_VAR 0 30
36665: PUSH
36666: LD_INT 2
36668: PUSH
36669: LD_INT 1
36671: NEG
36672: PUSH
36673: EMPTY
36674: LIST
36675: LIST
36676: PUSH
36677: LD_INT 3
36679: PUSH
36680: LD_INT 0
36682: PUSH
36683: EMPTY
36684: LIST
36685: LIST
36686: PUSH
36687: LD_INT 3
36689: PUSH
36690: LD_INT 1
36692: PUSH
36693: EMPTY
36694: LIST
36695: LIST
36696: PUSH
36697: LD_INT 3
36699: PUSH
36700: LD_INT 1
36702: NEG
36703: PUSH
36704: EMPTY
36705: LIST
36706: LIST
36707: PUSH
36708: LD_INT 4
36710: PUSH
36711: LD_INT 0
36713: PUSH
36714: EMPTY
36715: LIST
36716: LIST
36717: PUSH
36718: LD_INT 4
36720: PUSH
36721: LD_INT 1
36723: PUSH
36724: EMPTY
36725: LIST
36726: LIST
36727: PUSH
36728: LD_INT 4
36730: PUSH
36731: LD_INT 1
36733: NEG
36734: PUSH
36735: EMPTY
36736: LIST
36737: LIST
36738: PUSH
36739: LD_INT 5
36741: PUSH
36742: LD_INT 0
36744: PUSH
36745: EMPTY
36746: LIST
36747: LIST
36748: PUSH
36749: LD_INT 5
36751: PUSH
36752: LD_INT 1
36754: PUSH
36755: EMPTY
36756: LIST
36757: LIST
36758: PUSH
36759: LD_INT 5
36761: PUSH
36762: LD_INT 1
36764: NEG
36765: PUSH
36766: EMPTY
36767: LIST
36768: LIST
36769: PUSH
36770: LD_INT 6
36772: PUSH
36773: LD_INT 0
36775: PUSH
36776: EMPTY
36777: LIST
36778: LIST
36779: PUSH
36780: LD_INT 6
36782: PUSH
36783: LD_INT 1
36785: PUSH
36786: EMPTY
36787: LIST
36788: LIST
36789: PUSH
36790: EMPTY
36791: LIST
36792: LIST
36793: LIST
36794: LIST
36795: LIST
36796: LIST
36797: LIST
36798: LIST
36799: LIST
36800: LIST
36801: LIST
36802: LIST
36803: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
36804: LD_ADDR_VAR 0 31
36808: PUSH
36809: LD_INT 3
36811: PUSH
36812: LD_INT 2
36814: PUSH
36815: EMPTY
36816: LIST
36817: LIST
36818: PUSH
36819: LD_INT 3
36821: PUSH
36822: LD_INT 3
36824: PUSH
36825: EMPTY
36826: LIST
36827: LIST
36828: PUSH
36829: LD_INT 2
36831: PUSH
36832: LD_INT 3
36834: PUSH
36835: EMPTY
36836: LIST
36837: LIST
36838: PUSH
36839: LD_INT 4
36841: PUSH
36842: LD_INT 3
36844: PUSH
36845: EMPTY
36846: LIST
36847: LIST
36848: PUSH
36849: LD_INT 4
36851: PUSH
36852: LD_INT 4
36854: PUSH
36855: EMPTY
36856: LIST
36857: LIST
36858: PUSH
36859: LD_INT 3
36861: PUSH
36862: LD_INT 4
36864: PUSH
36865: EMPTY
36866: LIST
36867: LIST
36868: PUSH
36869: LD_INT 5
36871: PUSH
36872: LD_INT 4
36874: PUSH
36875: EMPTY
36876: LIST
36877: LIST
36878: PUSH
36879: LD_INT 5
36881: PUSH
36882: LD_INT 5
36884: PUSH
36885: EMPTY
36886: LIST
36887: LIST
36888: PUSH
36889: LD_INT 4
36891: PUSH
36892: LD_INT 5
36894: PUSH
36895: EMPTY
36896: LIST
36897: LIST
36898: PUSH
36899: LD_INT 6
36901: PUSH
36902: LD_INT 5
36904: PUSH
36905: EMPTY
36906: LIST
36907: LIST
36908: PUSH
36909: LD_INT 6
36911: PUSH
36912: LD_INT 6
36914: PUSH
36915: EMPTY
36916: LIST
36917: LIST
36918: PUSH
36919: LD_INT 5
36921: PUSH
36922: LD_INT 6
36924: PUSH
36925: EMPTY
36926: LIST
36927: LIST
36928: PUSH
36929: EMPTY
36930: LIST
36931: LIST
36932: LIST
36933: LIST
36934: LIST
36935: LIST
36936: LIST
36937: LIST
36938: LIST
36939: LIST
36940: LIST
36941: LIST
36942: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
36943: LD_ADDR_VAR 0 32
36947: PUSH
36948: LD_INT 1
36950: PUSH
36951: LD_INT 3
36953: PUSH
36954: EMPTY
36955: LIST
36956: LIST
36957: PUSH
36958: LD_INT 0
36960: PUSH
36961: LD_INT 3
36963: PUSH
36964: EMPTY
36965: LIST
36966: LIST
36967: PUSH
36968: LD_INT 1
36970: NEG
36971: PUSH
36972: LD_INT 2
36974: PUSH
36975: EMPTY
36976: LIST
36977: LIST
36978: PUSH
36979: LD_INT 1
36981: PUSH
36982: LD_INT 4
36984: PUSH
36985: EMPTY
36986: LIST
36987: LIST
36988: PUSH
36989: LD_INT 0
36991: PUSH
36992: LD_INT 4
36994: PUSH
36995: EMPTY
36996: LIST
36997: LIST
36998: PUSH
36999: LD_INT 1
37001: NEG
37002: PUSH
37003: LD_INT 3
37005: PUSH
37006: EMPTY
37007: LIST
37008: LIST
37009: PUSH
37010: LD_INT 1
37012: PUSH
37013: LD_INT 5
37015: PUSH
37016: EMPTY
37017: LIST
37018: LIST
37019: PUSH
37020: LD_INT 0
37022: PUSH
37023: LD_INT 5
37025: PUSH
37026: EMPTY
37027: LIST
37028: LIST
37029: PUSH
37030: LD_INT 1
37032: NEG
37033: PUSH
37034: LD_INT 4
37036: PUSH
37037: EMPTY
37038: LIST
37039: LIST
37040: PUSH
37041: LD_INT 1
37043: PUSH
37044: LD_INT 6
37046: PUSH
37047: EMPTY
37048: LIST
37049: LIST
37050: PUSH
37051: LD_INT 0
37053: PUSH
37054: LD_INT 6
37056: PUSH
37057: EMPTY
37058: LIST
37059: LIST
37060: PUSH
37061: LD_INT 1
37063: NEG
37064: PUSH
37065: LD_INT 5
37067: PUSH
37068: EMPTY
37069: LIST
37070: LIST
37071: PUSH
37072: EMPTY
37073: LIST
37074: LIST
37075: LIST
37076: LIST
37077: LIST
37078: LIST
37079: LIST
37080: LIST
37081: LIST
37082: LIST
37083: LIST
37084: LIST
37085: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
37086: LD_ADDR_VAR 0 33
37090: PUSH
37091: LD_INT 2
37093: NEG
37094: PUSH
37095: LD_INT 1
37097: PUSH
37098: EMPTY
37099: LIST
37100: LIST
37101: PUSH
37102: LD_INT 3
37104: NEG
37105: PUSH
37106: LD_INT 0
37108: PUSH
37109: EMPTY
37110: LIST
37111: LIST
37112: PUSH
37113: LD_INT 3
37115: NEG
37116: PUSH
37117: LD_INT 1
37119: NEG
37120: PUSH
37121: EMPTY
37122: LIST
37123: LIST
37124: PUSH
37125: LD_INT 3
37127: NEG
37128: PUSH
37129: LD_INT 1
37131: PUSH
37132: EMPTY
37133: LIST
37134: LIST
37135: PUSH
37136: LD_INT 4
37138: NEG
37139: PUSH
37140: LD_INT 0
37142: PUSH
37143: EMPTY
37144: LIST
37145: LIST
37146: PUSH
37147: LD_INT 4
37149: NEG
37150: PUSH
37151: LD_INT 1
37153: NEG
37154: PUSH
37155: EMPTY
37156: LIST
37157: LIST
37158: PUSH
37159: LD_INT 4
37161: NEG
37162: PUSH
37163: LD_INT 1
37165: PUSH
37166: EMPTY
37167: LIST
37168: LIST
37169: PUSH
37170: LD_INT 5
37172: NEG
37173: PUSH
37174: LD_INT 0
37176: PUSH
37177: EMPTY
37178: LIST
37179: LIST
37180: PUSH
37181: LD_INT 5
37183: NEG
37184: PUSH
37185: LD_INT 1
37187: NEG
37188: PUSH
37189: EMPTY
37190: LIST
37191: LIST
37192: PUSH
37193: LD_INT 5
37195: NEG
37196: PUSH
37197: LD_INT 1
37199: PUSH
37200: EMPTY
37201: LIST
37202: LIST
37203: PUSH
37204: LD_INT 6
37206: NEG
37207: PUSH
37208: LD_INT 0
37210: PUSH
37211: EMPTY
37212: LIST
37213: LIST
37214: PUSH
37215: LD_INT 6
37217: NEG
37218: PUSH
37219: LD_INT 1
37221: NEG
37222: PUSH
37223: EMPTY
37224: LIST
37225: LIST
37226: PUSH
37227: EMPTY
37228: LIST
37229: LIST
37230: LIST
37231: LIST
37232: LIST
37233: LIST
37234: LIST
37235: LIST
37236: LIST
37237: LIST
37238: LIST
37239: LIST
37240: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
37241: LD_ADDR_VAR 0 34
37245: PUSH
37246: LD_INT 2
37248: NEG
37249: PUSH
37250: LD_INT 3
37252: NEG
37253: PUSH
37254: EMPTY
37255: LIST
37256: LIST
37257: PUSH
37258: LD_INT 3
37260: NEG
37261: PUSH
37262: LD_INT 2
37264: NEG
37265: PUSH
37266: EMPTY
37267: LIST
37268: LIST
37269: PUSH
37270: LD_INT 3
37272: NEG
37273: PUSH
37274: LD_INT 3
37276: NEG
37277: PUSH
37278: EMPTY
37279: LIST
37280: LIST
37281: PUSH
37282: LD_INT 3
37284: NEG
37285: PUSH
37286: LD_INT 4
37288: NEG
37289: PUSH
37290: EMPTY
37291: LIST
37292: LIST
37293: PUSH
37294: LD_INT 4
37296: NEG
37297: PUSH
37298: LD_INT 3
37300: NEG
37301: PUSH
37302: EMPTY
37303: LIST
37304: LIST
37305: PUSH
37306: LD_INT 4
37308: NEG
37309: PUSH
37310: LD_INT 4
37312: NEG
37313: PUSH
37314: EMPTY
37315: LIST
37316: LIST
37317: PUSH
37318: LD_INT 4
37320: NEG
37321: PUSH
37322: LD_INT 5
37324: NEG
37325: PUSH
37326: EMPTY
37327: LIST
37328: LIST
37329: PUSH
37330: LD_INT 5
37332: NEG
37333: PUSH
37334: LD_INT 4
37336: NEG
37337: PUSH
37338: EMPTY
37339: LIST
37340: LIST
37341: PUSH
37342: LD_INT 5
37344: NEG
37345: PUSH
37346: LD_INT 5
37348: NEG
37349: PUSH
37350: EMPTY
37351: LIST
37352: LIST
37353: PUSH
37354: LD_INT 5
37356: NEG
37357: PUSH
37358: LD_INT 6
37360: NEG
37361: PUSH
37362: EMPTY
37363: LIST
37364: LIST
37365: PUSH
37366: LD_INT 6
37368: NEG
37369: PUSH
37370: LD_INT 5
37372: NEG
37373: PUSH
37374: EMPTY
37375: LIST
37376: LIST
37377: PUSH
37378: LD_INT 6
37380: NEG
37381: PUSH
37382: LD_INT 6
37384: NEG
37385: PUSH
37386: EMPTY
37387: LIST
37388: LIST
37389: PUSH
37390: EMPTY
37391: LIST
37392: LIST
37393: LIST
37394: LIST
37395: LIST
37396: LIST
37397: LIST
37398: LIST
37399: LIST
37400: LIST
37401: LIST
37402: LIST
37403: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
37404: LD_ADDR_VAR 0 41
37408: PUSH
37409: LD_INT 0
37411: PUSH
37412: LD_INT 2
37414: NEG
37415: PUSH
37416: EMPTY
37417: LIST
37418: LIST
37419: PUSH
37420: LD_INT 1
37422: NEG
37423: PUSH
37424: LD_INT 3
37426: NEG
37427: PUSH
37428: EMPTY
37429: LIST
37430: LIST
37431: PUSH
37432: LD_INT 1
37434: PUSH
37435: LD_INT 2
37437: NEG
37438: PUSH
37439: EMPTY
37440: LIST
37441: LIST
37442: PUSH
37443: EMPTY
37444: LIST
37445: LIST
37446: LIST
37447: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
37448: LD_ADDR_VAR 0 42
37452: PUSH
37453: LD_INT 2
37455: PUSH
37456: LD_INT 0
37458: PUSH
37459: EMPTY
37460: LIST
37461: LIST
37462: PUSH
37463: LD_INT 2
37465: PUSH
37466: LD_INT 1
37468: NEG
37469: PUSH
37470: EMPTY
37471: LIST
37472: LIST
37473: PUSH
37474: LD_INT 3
37476: PUSH
37477: LD_INT 1
37479: PUSH
37480: EMPTY
37481: LIST
37482: LIST
37483: PUSH
37484: EMPTY
37485: LIST
37486: LIST
37487: LIST
37488: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
37489: LD_ADDR_VAR 0 43
37493: PUSH
37494: LD_INT 2
37496: PUSH
37497: LD_INT 2
37499: PUSH
37500: EMPTY
37501: LIST
37502: LIST
37503: PUSH
37504: LD_INT 3
37506: PUSH
37507: LD_INT 2
37509: PUSH
37510: EMPTY
37511: LIST
37512: LIST
37513: PUSH
37514: LD_INT 2
37516: PUSH
37517: LD_INT 3
37519: PUSH
37520: EMPTY
37521: LIST
37522: LIST
37523: PUSH
37524: EMPTY
37525: LIST
37526: LIST
37527: LIST
37528: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
37529: LD_ADDR_VAR 0 44
37533: PUSH
37534: LD_INT 0
37536: PUSH
37537: LD_INT 2
37539: PUSH
37540: EMPTY
37541: LIST
37542: LIST
37543: PUSH
37544: LD_INT 1
37546: PUSH
37547: LD_INT 3
37549: PUSH
37550: EMPTY
37551: LIST
37552: LIST
37553: PUSH
37554: LD_INT 1
37556: NEG
37557: PUSH
37558: LD_INT 2
37560: PUSH
37561: EMPTY
37562: LIST
37563: LIST
37564: PUSH
37565: EMPTY
37566: LIST
37567: LIST
37568: LIST
37569: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
37570: LD_ADDR_VAR 0 45
37574: PUSH
37575: LD_INT 2
37577: NEG
37578: PUSH
37579: LD_INT 0
37581: PUSH
37582: EMPTY
37583: LIST
37584: LIST
37585: PUSH
37586: LD_INT 2
37588: NEG
37589: PUSH
37590: LD_INT 1
37592: PUSH
37593: EMPTY
37594: LIST
37595: LIST
37596: PUSH
37597: LD_INT 3
37599: NEG
37600: PUSH
37601: LD_INT 1
37603: NEG
37604: PUSH
37605: EMPTY
37606: LIST
37607: LIST
37608: PUSH
37609: EMPTY
37610: LIST
37611: LIST
37612: LIST
37613: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
37614: LD_ADDR_VAR 0 46
37618: PUSH
37619: LD_INT 2
37621: NEG
37622: PUSH
37623: LD_INT 2
37625: NEG
37626: PUSH
37627: EMPTY
37628: LIST
37629: LIST
37630: PUSH
37631: LD_INT 2
37633: NEG
37634: PUSH
37635: LD_INT 3
37637: NEG
37638: PUSH
37639: EMPTY
37640: LIST
37641: LIST
37642: PUSH
37643: LD_INT 3
37645: NEG
37646: PUSH
37647: LD_INT 2
37649: NEG
37650: PUSH
37651: EMPTY
37652: LIST
37653: LIST
37654: PUSH
37655: EMPTY
37656: LIST
37657: LIST
37658: LIST
37659: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
37660: LD_ADDR_VAR 0 47
37664: PUSH
37665: LD_INT 2
37667: NEG
37668: PUSH
37669: LD_INT 3
37671: NEG
37672: PUSH
37673: EMPTY
37674: LIST
37675: LIST
37676: PUSH
37677: LD_INT 1
37679: NEG
37680: PUSH
37681: LD_INT 3
37683: NEG
37684: PUSH
37685: EMPTY
37686: LIST
37687: LIST
37688: PUSH
37689: EMPTY
37690: LIST
37691: LIST
37692: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
37693: LD_ADDR_VAR 0 48
37697: PUSH
37698: LD_INT 1
37700: PUSH
37701: LD_INT 2
37703: NEG
37704: PUSH
37705: EMPTY
37706: LIST
37707: LIST
37708: PUSH
37709: LD_INT 2
37711: PUSH
37712: LD_INT 1
37714: NEG
37715: PUSH
37716: EMPTY
37717: LIST
37718: LIST
37719: PUSH
37720: EMPTY
37721: LIST
37722: LIST
37723: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
37724: LD_ADDR_VAR 0 49
37728: PUSH
37729: LD_INT 3
37731: PUSH
37732: LD_INT 1
37734: PUSH
37735: EMPTY
37736: LIST
37737: LIST
37738: PUSH
37739: LD_INT 3
37741: PUSH
37742: LD_INT 2
37744: PUSH
37745: EMPTY
37746: LIST
37747: LIST
37748: PUSH
37749: EMPTY
37750: LIST
37751: LIST
37752: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
37753: LD_ADDR_VAR 0 50
37757: PUSH
37758: LD_INT 2
37760: PUSH
37761: LD_INT 3
37763: PUSH
37764: EMPTY
37765: LIST
37766: LIST
37767: PUSH
37768: LD_INT 1
37770: PUSH
37771: LD_INT 3
37773: PUSH
37774: EMPTY
37775: LIST
37776: LIST
37777: PUSH
37778: EMPTY
37779: LIST
37780: LIST
37781: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
37782: LD_ADDR_VAR 0 51
37786: PUSH
37787: LD_INT 1
37789: NEG
37790: PUSH
37791: LD_INT 2
37793: PUSH
37794: EMPTY
37795: LIST
37796: LIST
37797: PUSH
37798: LD_INT 2
37800: NEG
37801: PUSH
37802: LD_INT 1
37804: PUSH
37805: EMPTY
37806: LIST
37807: LIST
37808: PUSH
37809: EMPTY
37810: LIST
37811: LIST
37812: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
37813: LD_ADDR_VAR 0 52
37817: PUSH
37818: LD_INT 3
37820: NEG
37821: PUSH
37822: LD_INT 1
37824: NEG
37825: PUSH
37826: EMPTY
37827: LIST
37828: LIST
37829: PUSH
37830: LD_INT 3
37832: NEG
37833: PUSH
37834: LD_INT 2
37836: NEG
37837: PUSH
37838: EMPTY
37839: LIST
37840: LIST
37841: PUSH
37842: EMPTY
37843: LIST
37844: LIST
37845: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
37846: LD_ADDR_VAR 0 53
37850: PUSH
37851: LD_INT 1
37853: NEG
37854: PUSH
37855: LD_INT 3
37857: NEG
37858: PUSH
37859: EMPTY
37860: LIST
37861: LIST
37862: PUSH
37863: LD_INT 0
37865: PUSH
37866: LD_INT 3
37868: NEG
37869: PUSH
37870: EMPTY
37871: LIST
37872: LIST
37873: PUSH
37874: LD_INT 1
37876: PUSH
37877: LD_INT 2
37879: NEG
37880: PUSH
37881: EMPTY
37882: LIST
37883: LIST
37884: PUSH
37885: EMPTY
37886: LIST
37887: LIST
37888: LIST
37889: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
37890: LD_ADDR_VAR 0 54
37894: PUSH
37895: LD_INT 2
37897: PUSH
37898: LD_INT 1
37900: NEG
37901: PUSH
37902: EMPTY
37903: LIST
37904: LIST
37905: PUSH
37906: LD_INT 3
37908: PUSH
37909: LD_INT 0
37911: PUSH
37912: EMPTY
37913: LIST
37914: LIST
37915: PUSH
37916: LD_INT 3
37918: PUSH
37919: LD_INT 1
37921: PUSH
37922: EMPTY
37923: LIST
37924: LIST
37925: PUSH
37926: EMPTY
37927: LIST
37928: LIST
37929: LIST
37930: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
37931: LD_ADDR_VAR 0 55
37935: PUSH
37936: LD_INT 3
37938: PUSH
37939: LD_INT 2
37941: PUSH
37942: EMPTY
37943: LIST
37944: LIST
37945: PUSH
37946: LD_INT 3
37948: PUSH
37949: LD_INT 3
37951: PUSH
37952: EMPTY
37953: LIST
37954: LIST
37955: PUSH
37956: LD_INT 2
37958: PUSH
37959: LD_INT 3
37961: PUSH
37962: EMPTY
37963: LIST
37964: LIST
37965: PUSH
37966: EMPTY
37967: LIST
37968: LIST
37969: LIST
37970: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37971: LD_ADDR_VAR 0 56
37975: PUSH
37976: LD_INT 1
37978: PUSH
37979: LD_INT 3
37981: PUSH
37982: EMPTY
37983: LIST
37984: LIST
37985: PUSH
37986: LD_INT 0
37988: PUSH
37989: LD_INT 3
37991: PUSH
37992: EMPTY
37993: LIST
37994: LIST
37995: PUSH
37996: LD_INT 1
37998: NEG
37999: PUSH
38000: LD_INT 2
38002: PUSH
38003: EMPTY
38004: LIST
38005: LIST
38006: PUSH
38007: EMPTY
38008: LIST
38009: LIST
38010: LIST
38011: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
38012: LD_ADDR_VAR 0 57
38016: PUSH
38017: LD_INT 2
38019: NEG
38020: PUSH
38021: LD_INT 1
38023: PUSH
38024: EMPTY
38025: LIST
38026: LIST
38027: PUSH
38028: LD_INT 3
38030: NEG
38031: PUSH
38032: LD_INT 0
38034: PUSH
38035: EMPTY
38036: LIST
38037: LIST
38038: PUSH
38039: LD_INT 3
38041: NEG
38042: PUSH
38043: LD_INT 1
38045: NEG
38046: PUSH
38047: EMPTY
38048: LIST
38049: LIST
38050: PUSH
38051: EMPTY
38052: LIST
38053: LIST
38054: LIST
38055: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38056: LD_ADDR_VAR 0 58
38060: PUSH
38061: LD_INT 2
38063: NEG
38064: PUSH
38065: LD_INT 3
38067: NEG
38068: PUSH
38069: EMPTY
38070: LIST
38071: LIST
38072: PUSH
38073: LD_INT 3
38075: NEG
38076: PUSH
38077: LD_INT 2
38079: NEG
38080: PUSH
38081: EMPTY
38082: LIST
38083: LIST
38084: PUSH
38085: LD_INT 3
38087: NEG
38088: PUSH
38089: LD_INT 3
38091: NEG
38092: PUSH
38093: EMPTY
38094: LIST
38095: LIST
38096: PUSH
38097: EMPTY
38098: LIST
38099: LIST
38100: LIST
38101: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
38102: LD_ADDR_VAR 0 59
38106: PUSH
38107: LD_INT 1
38109: NEG
38110: PUSH
38111: LD_INT 2
38113: NEG
38114: PUSH
38115: EMPTY
38116: LIST
38117: LIST
38118: PUSH
38119: LD_INT 0
38121: PUSH
38122: LD_INT 2
38124: NEG
38125: PUSH
38126: EMPTY
38127: LIST
38128: LIST
38129: PUSH
38130: LD_INT 1
38132: PUSH
38133: LD_INT 1
38135: NEG
38136: PUSH
38137: EMPTY
38138: LIST
38139: LIST
38140: PUSH
38141: EMPTY
38142: LIST
38143: LIST
38144: LIST
38145: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
38146: LD_ADDR_VAR 0 60
38150: PUSH
38151: LD_INT 1
38153: PUSH
38154: LD_INT 1
38156: NEG
38157: PUSH
38158: EMPTY
38159: LIST
38160: LIST
38161: PUSH
38162: LD_INT 2
38164: PUSH
38165: LD_INT 0
38167: PUSH
38168: EMPTY
38169: LIST
38170: LIST
38171: PUSH
38172: LD_INT 2
38174: PUSH
38175: LD_INT 1
38177: PUSH
38178: EMPTY
38179: LIST
38180: LIST
38181: PUSH
38182: EMPTY
38183: LIST
38184: LIST
38185: LIST
38186: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38187: LD_ADDR_VAR 0 61
38191: PUSH
38192: LD_INT 2
38194: PUSH
38195: LD_INT 1
38197: PUSH
38198: EMPTY
38199: LIST
38200: LIST
38201: PUSH
38202: LD_INT 2
38204: PUSH
38205: LD_INT 2
38207: PUSH
38208: EMPTY
38209: LIST
38210: LIST
38211: PUSH
38212: LD_INT 1
38214: PUSH
38215: LD_INT 2
38217: PUSH
38218: EMPTY
38219: LIST
38220: LIST
38221: PUSH
38222: EMPTY
38223: LIST
38224: LIST
38225: LIST
38226: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38227: LD_ADDR_VAR 0 62
38231: PUSH
38232: LD_INT 1
38234: PUSH
38235: LD_INT 2
38237: PUSH
38238: EMPTY
38239: LIST
38240: LIST
38241: PUSH
38242: LD_INT 0
38244: PUSH
38245: LD_INT 2
38247: PUSH
38248: EMPTY
38249: LIST
38250: LIST
38251: PUSH
38252: LD_INT 1
38254: NEG
38255: PUSH
38256: LD_INT 1
38258: PUSH
38259: EMPTY
38260: LIST
38261: LIST
38262: PUSH
38263: EMPTY
38264: LIST
38265: LIST
38266: LIST
38267: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38268: LD_ADDR_VAR 0 63
38272: PUSH
38273: LD_INT 1
38275: NEG
38276: PUSH
38277: LD_INT 1
38279: PUSH
38280: EMPTY
38281: LIST
38282: LIST
38283: PUSH
38284: LD_INT 2
38286: NEG
38287: PUSH
38288: LD_INT 0
38290: PUSH
38291: EMPTY
38292: LIST
38293: LIST
38294: PUSH
38295: LD_INT 2
38297: NEG
38298: PUSH
38299: LD_INT 1
38301: NEG
38302: PUSH
38303: EMPTY
38304: LIST
38305: LIST
38306: PUSH
38307: EMPTY
38308: LIST
38309: LIST
38310: LIST
38311: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38312: LD_ADDR_VAR 0 64
38316: PUSH
38317: LD_INT 1
38319: NEG
38320: PUSH
38321: LD_INT 2
38323: NEG
38324: PUSH
38325: EMPTY
38326: LIST
38327: LIST
38328: PUSH
38329: LD_INT 2
38331: NEG
38332: PUSH
38333: LD_INT 1
38335: NEG
38336: PUSH
38337: EMPTY
38338: LIST
38339: LIST
38340: PUSH
38341: LD_INT 2
38343: NEG
38344: PUSH
38345: LD_INT 2
38347: NEG
38348: PUSH
38349: EMPTY
38350: LIST
38351: LIST
38352: PUSH
38353: EMPTY
38354: LIST
38355: LIST
38356: LIST
38357: ST_TO_ADDR
// end ; 2 :
38358: GO 41624
38360: LD_INT 2
38362: DOUBLE
38363: EQUAL
38364: IFTRUE 38368
38366: GO 41623
38368: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
38369: LD_ADDR_VAR 0 29
38373: PUSH
38374: LD_INT 4
38376: PUSH
38377: LD_INT 0
38379: PUSH
38380: EMPTY
38381: LIST
38382: LIST
38383: PUSH
38384: LD_INT 4
38386: PUSH
38387: LD_INT 1
38389: NEG
38390: PUSH
38391: EMPTY
38392: LIST
38393: LIST
38394: PUSH
38395: LD_INT 5
38397: PUSH
38398: LD_INT 0
38400: PUSH
38401: EMPTY
38402: LIST
38403: LIST
38404: PUSH
38405: LD_INT 5
38407: PUSH
38408: LD_INT 1
38410: PUSH
38411: EMPTY
38412: LIST
38413: LIST
38414: PUSH
38415: LD_INT 4
38417: PUSH
38418: LD_INT 1
38420: PUSH
38421: EMPTY
38422: LIST
38423: LIST
38424: PUSH
38425: LD_INT 3
38427: PUSH
38428: LD_INT 0
38430: PUSH
38431: EMPTY
38432: LIST
38433: LIST
38434: PUSH
38435: LD_INT 3
38437: PUSH
38438: LD_INT 1
38440: NEG
38441: PUSH
38442: EMPTY
38443: LIST
38444: LIST
38445: PUSH
38446: LD_INT 3
38448: PUSH
38449: LD_INT 2
38451: NEG
38452: PUSH
38453: EMPTY
38454: LIST
38455: LIST
38456: PUSH
38457: LD_INT 5
38459: PUSH
38460: LD_INT 2
38462: PUSH
38463: EMPTY
38464: LIST
38465: LIST
38466: PUSH
38467: LD_INT 3
38469: PUSH
38470: LD_INT 3
38472: PUSH
38473: EMPTY
38474: LIST
38475: LIST
38476: PUSH
38477: LD_INT 3
38479: PUSH
38480: LD_INT 2
38482: PUSH
38483: EMPTY
38484: LIST
38485: LIST
38486: PUSH
38487: LD_INT 4
38489: PUSH
38490: LD_INT 3
38492: PUSH
38493: EMPTY
38494: LIST
38495: LIST
38496: PUSH
38497: LD_INT 4
38499: PUSH
38500: LD_INT 4
38502: PUSH
38503: EMPTY
38504: LIST
38505: LIST
38506: PUSH
38507: LD_INT 3
38509: PUSH
38510: LD_INT 4
38512: PUSH
38513: EMPTY
38514: LIST
38515: LIST
38516: PUSH
38517: LD_INT 2
38519: PUSH
38520: LD_INT 3
38522: PUSH
38523: EMPTY
38524: LIST
38525: LIST
38526: PUSH
38527: LD_INT 2
38529: PUSH
38530: LD_INT 2
38532: PUSH
38533: EMPTY
38534: LIST
38535: LIST
38536: PUSH
38537: LD_INT 4
38539: PUSH
38540: LD_INT 2
38542: PUSH
38543: EMPTY
38544: LIST
38545: LIST
38546: PUSH
38547: LD_INT 2
38549: PUSH
38550: LD_INT 4
38552: PUSH
38553: EMPTY
38554: LIST
38555: LIST
38556: PUSH
38557: LD_INT 0
38559: PUSH
38560: LD_INT 4
38562: PUSH
38563: EMPTY
38564: LIST
38565: LIST
38566: PUSH
38567: LD_INT 0
38569: PUSH
38570: LD_INT 3
38572: PUSH
38573: EMPTY
38574: LIST
38575: LIST
38576: PUSH
38577: LD_INT 1
38579: PUSH
38580: LD_INT 4
38582: PUSH
38583: EMPTY
38584: LIST
38585: LIST
38586: PUSH
38587: LD_INT 1
38589: PUSH
38590: LD_INT 5
38592: PUSH
38593: EMPTY
38594: LIST
38595: LIST
38596: PUSH
38597: LD_INT 0
38599: PUSH
38600: LD_INT 5
38602: PUSH
38603: EMPTY
38604: LIST
38605: LIST
38606: PUSH
38607: LD_INT 1
38609: NEG
38610: PUSH
38611: LD_INT 4
38613: PUSH
38614: EMPTY
38615: LIST
38616: LIST
38617: PUSH
38618: LD_INT 1
38620: NEG
38621: PUSH
38622: LD_INT 3
38624: PUSH
38625: EMPTY
38626: LIST
38627: LIST
38628: PUSH
38629: LD_INT 2
38631: PUSH
38632: LD_INT 5
38634: PUSH
38635: EMPTY
38636: LIST
38637: LIST
38638: PUSH
38639: LD_INT 2
38641: NEG
38642: PUSH
38643: LD_INT 3
38645: PUSH
38646: EMPTY
38647: LIST
38648: LIST
38649: PUSH
38650: LD_INT 3
38652: NEG
38653: PUSH
38654: LD_INT 0
38656: PUSH
38657: EMPTY
38658: LIST
38659: LIST
38660: PUSH
38661: LD_INT 3
38663: NEG
38664: PUSH
38665: LD_INT 1
38667: NEG
38668: PUSH
38669: EMPTY
38670: LIST
38671: LIST
38672: PUSH
38673: LD_INT 2
38675: NEG
38676: PUSH
38677: LD_INT 0
38679: PUSH
38680: EMPTY
38681: LIST
38682: LIST
38683: PUSH
38684: LD_INT 2
38686: NEG
38687: PUSH
38688: LD_INT 1
38690: PUSH
38691: EMPTY
38692: LIST
38693: LIST
38694: PUSH
38695: LD_INT 3
38697: NEG
38698: PUSH
38699: LD_INT 1
38701: PUSH
38702: EMPTY
38703: LIST
38704: LIST
38705: PUSH
38706: LD_INT 4
38708: NEG
38709: PUSH
38710: LD_INT 0
38712: PUSH
38713: EMPTY
38714: LIST
38715: LIST
38716: PUSH
38717: LD_INT 4
38719: NEG
38720: PUSH
38721: LD_INT 1
38723: NEG
38724: PUSH
38725: EMPTY
38726: LIST
38727: LIST
38728: PUSH
38729: LD_INT 4
38731: NEG
38732: PUSH
38733: LD_INT 2
38735: NEG
38736: PUSH
38737: EMPTY
38738: LIST
38739: LIST
38740: PUSH
38741: LD_INT 2
38743: NEG
38744: PUSH
38745: LD_INT 2
38747: PUSH
38748: EMPTY
38749: LIST
38750: LIST
38751: PUSH
38752: LD_INT 4
38754: NEG
38755: PUSH
38756: LD_INT 4
38758: NEG
38759: PUSH
38760: EMPTY
38761: LIST
38762: LIST
38763: PUSH
38764: LD_INT 4
38766: NEG
38767: PUSH
38768: LD_INT 5
38770: NEG
38771: PUSH
38772: EMPTY
38773: LIST
38774: LIST
38775: PUSH
38776: LD_INT 3
38778: NEG
38779: PUSH
38780: LD_INT 4
38782: NEG
38783: PUSH
38784: EMPTY
38785: LIST
38786: LIST
38787: PUSH
38788: LD_INT 3
38790: NEG
38791: PUSH
38792: LD_INT 3
38794: NEG
38795: PUSH
38796: EMPTY
38797: LIST
38798: LIST
38799: PUSH
38800: LD_INT 4
38802: NEG
38803: PUSH
38804: LD_INT 3
38806: NEG
38807: PUSH
38808: EMPTY
38809: LIST
38810: LIST
38811: PUSH
38812: LD_INT 5
38814: NEG
38815: PUSH
38816: LD_INT 4
38818: NEG
38819: PUSH
38820: EMPTY
38821: LIST
38822: LIST
38823: PUSH
38824: LD_INT 5
38826: NEG
38827: PUSH
38828: LD_INT 5
38830: NEG
38831: PUSH
38832: EMPTY
38833: LIST
38834: LIST
38835: PUSH
38836: LD_INT 3
38838: NEG
38839: PUSH
38840: LD_INT 5
38842: NEG
38843: PUSH
38844: EMPTY
38845: LIST
38846: LIST
38847: PUSH
38848: LD_INT 5
38850: NEG
38851: PUSH
38852: LD_INT 3
38854: NEG
38855: PUSH
38856: EMPTY
38857: LIST
38858: LIST
38859: PUSH
38860: EMPTY
38861: LIST
38862: LIST
38863: LIST
38864: LIST
38865: LIST
38866: LIST
38867: LIST
38868: LIST
38869: LIST
38870: LIST
38871: LIST
38872: LIST
38873: LIST
38874: LIST
38875: LIST
38876: LIST
38877: LIST
38878: LIST
38879: LIST
38880: LIST
38881: LIST
38882: LIST
38883: LIST
38884: LIST
38885: LIST
38886: LIST
38887: LIST
38888: LIST
38889: LIST
38890: LIST
38891: LIST
38892: LIST
38893: LIST
38894: LIST
38895: LIST
38896: LIST
38897: LIST
38898: LIST
38899: LIST
38900: LIST
38901: LIST
38902: LIST
38903: LIST
38904: LIST
38905: LIST
38906: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
38907: LD_ADDR_VAR 0 30
38911: PUSH
38912: LD_INT 4
38914: PUSH
38915: LD_INT 4
38917: PUSH
38918: EMPTY
38919: LIST
38920: LIST
38921: PUSH
38922: LD_INT 4
38924: PUSH
38925: LD_INT 3
38927: PUSH
38928: EMPTY
38929: LIST
38930: LIST
38931: PUSH
38932: LD_INT 5
38934: PUSH
38935: LD_INT 4
38937: PUSH
38938: EMPTY
38939: LIST
38940: LIST
38941: PUSH
38942: LD_INT 5
38944: PUSH
38945: LD_INT 5
38947: PUSH
38948: EMPTY
38949: LIST
38950: LIST
38951: PUSH
38952: LD_INT 4
38954: PUSH
38955: LD_INT 5
38957: PUSH
38958: EMPTY
38959: LIST
38960: LIST
38961: PUSH
38962: LD_INT 3
38964: PUSH
38965: LD_INT 4
38967: PUSH
38968: EMPTY
38969: LIST
38970: LIST
38971: PUSH
38972: LD_INT 3
38974: PUSH
38975: LD_INT 3
38977: PUSH
38978: EMPTY
38979: LIST
38980: LIST
38981: PUSH
38982: LD_INT 5
38984: PUSH
38985: LD_INT 3
38987: PUSH
38988: EMPTY
38989: LIST
38990: LIST
38991: PUSH
38992: LD_INT 3
38994: PUSH
38995: LD_INT 5
38997: PUSH
38998: EMPTY
38999: LIST
39000: LIST
39001: PUSH
39002: LD_INT 0
39004: PUSH
39005: LD_INT 3
39007: PUSH
39008: EMPTY
39009: LIST
39010: LIST
39011: PUSH
39012: LD_INT 0
39014: PUSH
39015: LD_INT 2
39017: PUSH
39018: EMPTY
39019: LIST
39020: LIST
39021: PUSH
39022: LD_INT 1
39024: PUSH
39025: LD_INT 3
39027: PUSH
39028: EMPTY
39029: LIST
39030: LIST
39031: PUSH
39032: LD_INT 1
39034: PUSH
39035: LD_INT 4
39037: PUSH
39038: EMPTY
39039: LIST
39040: LIST
39041: PUSH
39042: LD_INT 0
39044: PUSH
39045: LD_INT 4
39047: PUSH
39048: EMPTY
39049: LIST
39050: LIST
39051: PUSH
39052: LD_INT 1
39054: NEG
39055: PUSH
39056: LD_INT 3
39058: PUSH
39059: EMPTY
39060: LIST
39061: LIST
39062: PUSH
39063: LD_INT 1
39065: NEG
39066: PUSH
39067: LD_INT 2
39069: PUSH
39070: EMPTY
39071: LIST
39072: LIST
39073: PUSH
39074: LD_INT 2
39076: PUSH
39077: LD_INT 4
39079: PUSH
39080: EMPTY
39081: LIST
39082: LIST
39083: PUSH
39084: LD_INT 2
39086: NEG
39087: PUSH
39088: LD_INT 2
39090: PUSH
39091: EMPTY
39092: LIST
39093: LIST
39094: PUSH
39095: LD_INT 4
39097: NEG
39098: PUSH
39099: LD_INT 0
39101: PUSH
39102: EMPTY
39103: LIST
39104: LIST
39105: PUSH
39106: LD_INT 4
39108: NEG
39109: PUSH
39110: LD_INT 1
39112: NEG
39113: PUSH
39114: EMPTY
39115: LIST
39116: LIST
39117: PUSH
39118: LD_INT 3
39120: NEG
39121: PUSH
39122: LD_INT 0
39124: PUSH
39125: EMPTY
39126: LIST
39127: LIST
39128: PUSH
39129: LD_INT 3
39131: NEG
39132: PUSH
39133: LD_INT 1
39135: PUSH
39136: EMPTY
39137: LIST
39138: LIST
39139: PUSH
39140: LD_INT 4
39142: NEG
39143: PUSH
39144: LD_INT 1
39146: PUSH
39147: EMPTY
39148: LIST
39149: LIST
39150: PUSH
39151: LD_INT 5
39153: NEG
39154: PUSH
39155: LD_INT 0
39157: PUSH
39158: EMPTY
39159: LIST
39160: LIST
39161: PUSH
39162: LD_INT 5
39164: NEG
39165: PUSH
39166: LD_INT 1
39168: NEG
39169: PUSH
39170: EMPTY
39171: LIST
39172: LIST
39173: PUSH
39174: LD_INT 5
39176: NEG
39177: PUSH
39178: LD_INT 2
39180: NEG
39181: PUSH
39182: EMPTY
39183: LIST
39184: LIST
39185: PUSH
39186: LD_INT 3
39188: NEG
39189: PUSH
39190: LD_INT 2
39192: PUSH
39193: EMPTY
39194: LIST
39195: LIST
39196: PUSH
39197: LD_INT 3
39199: NEG
39200: PUSH
39201: LD_INT 3
39203: NEG
39204: PUSH
39205: EMPTY
39206: LIST
39207: LIST
39208: PUSH
39209: LD_INT 3
39211: NEG
39212: PUSH
39213: LD_INT 4
39215: NEG
39216: PUSH
39217: EMPTY
39218: LIST
39219: LIST
39220: PUSH
39221: LD_INT 2
39223: NEG
39224: PUSH
39225: LD_INT 3
39227: NEG
39228: PUSH
39229: EMPTY
39230: LIST
39231: LIST
39232: PUSH
39233: LD_INT 2
39235: NEG
39236: PUSH
39237: LD_INT 2
39239: NEG
39240: PUSH
39241: EMPTY
39242: LIST
39243: LIST
39244: PUSH
39245: LD_INT 3
39247: NEG
39248: PUSH
39249: LD_INT 2
39251: NEG
39252: PUSH
39253: EMPTY
39254: LIST
39255: LIST
39256: PUSH
39257: LD_INT 4
39259: NEG
39260: PUSH
39261: LD_INT 3
39263: NEG
39264: PUSH
39265: EMPTY
39266: LIST
39267: LIST
39268: PUSH
39269: LD_INT 4
39271: NEG
39272: PUSH
39273: LD_INT 4
39275: NEG
39276: PUSH
39277: EMPTY
39278: LIST
39279: LIST
39280: PUSH
39281: LD_INT 2
39283: NEG
39284: PUSH
39285: LD_INT 4
39287: NEG
39288: PUSH
39289: EMPTY
39290: LIST
39291: LIST
39292: PUSH
39293: LD_INT 4
39295: NEG
39296: PUSH
39297: LD_INT 2
39299: NEG
39300: PUSH
39301: EMPTY
39302: LIST
39303: LIST
39304: PUSH
39305: LD_INT 0
39307: PUSH
39308: LD_INT 4
39310: NEG
39311: PUSH
39312: EMPTY
39313: LIST
39314: LIST
39315: PUSH
39316: LD_INT 0
39318: PUSH
39319: LD_INT 5
39321: NEG
39322: PUSH
39323: EMPTY
39324: LIST
39325: LIST
39326: PUSH
39327: LD_INT 1
39329: PUSH
39330: LD_INT 4
39332: NEG
39333: PUSH
39334: EMPTY
39335: LIST
39336: LIST
39337: PUSH
39338: LD_INT 1
39340: PUSH
39341: LD_INT 3
39343: NEG
39344: PUSH
39345: EMPTY
39346: LIST
39347: LIST
39348: PUSH
39349: LD_INT 0
39351: PUSH
39352: LD_INT 3
39354: NEG
39355: PUSH
39356: EMPTY
39357: LIST
39358: LIST
39359: PUSH
39360: LD_INT 1
39362: NEG
39363: PUSH
39364: LD_INT 4
39366: NEG
39367: PUSH
39368: EMPTY
39369: LIST
39370: LIST
39371: PUSH
39372: LD_INT 1
39374: NEG
39375: PUSH
39376: LD_INT 5
39378: NEG
39379: PUSH
39380: EMPTY
39381: LIST
39382: LIST
39383: PUSH
39384: LD_INT 2
39386: PUSH
39387: LD_INT 3
39389: NEG
39390: PUSH
39391: EMPTY
39392: LIST
39393: LIST
39394: PUSH
39395: LD_INT 2
39397: NEG
39398: PUSH
39399: LD_INT 5
39401: NEG
39402: PUSH
39403: EMPTY
39404: LIST
39405: LIST
39406: PUSH
39407: EMPTY
39408: LIST
39409: LIST
39410: LIST
39411: LIST
39412: LIST
39413: LIST
39414: LIST
39415: LIST
39416: LIST
39417: LIST
39418: LIST
39419: LIST
39420: LIST
39421: LIST
39422: LIST
39423: LIST
39424: LIST
39425: LIST
39426: LIST
39427: LIST
39428: LIST
39429: LIST
39430: LIST
39431: LIST
39432: LIST
39433: LIST
39434: LIST
39435: LIST
39436: LIST
39437: LIST
39438: LIST
39439: LIST
39440: LIST
39441: LIST
39442: LIST
39443: LIST
39444: LIST
39445: LIST
39446: LIST
39447: LIST
39448: LIST
39449: LIST
39450: LIST
39451: LIST
39452: LIST
39453: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
39454: LD_ADDR_VAR 0 31
39458: PUSH
39459: LD_INT 0
39461: PUSH
39462: LD_INT 4
39464: PUSH
39465: EMPTY
39466: LIST
39467: LIST
39468: PUSH
39469: LD_INT 0
39471: PUSH
39472: LD_INT 3
39474: PUSH
39475: EMPTY
39476: LIST
39477: LIST
39478: PUSH
39479: LD_INT 1
39481: PUSH
39482: LD_INT 4
39484: PUSH
39485: EMPTY
39486: LIST
39487: LIST
39488: PUSH
39489: LD_INT 1
39491: PUSH
39492: LD_INT 5
39494: PUSH
39495: EMPTY
39496: LIST
39497: LIST
39498: PUSH
39499: LD_INT 0
39501: PUSH
39502: LD_INT 5
39504: PUSH
39505: EMPTY
39506: LIST
39507: LIST
39508: PUSH
39509: LD_INT 1
39511: NEG
39512: PUSH
39513: LD_INT 4
39515: PUSH
39516: EMPTY
39517: LIST
39518: LIST
39519: PUSH
39520: LD_INT 1
39522: NEG
39523: PUSH
39524: LD_INT 3
39526: PUSH
39527: EMPTY
39528: LIST
39529: LIST
39530: PUSH
39531: LD_INT 2
39533: PUSH
39534: LD_INT 5
39536: PUSH
39537: EMPTY
39538: LIST
39539: LIST
39540: PUSH
39541: LD_INT 2
39543: NEG
39544: PUSH
39545: LD_INT 3
39547: PUSH
39548: EMPTY
39549: LIST
39550: LIST
39551: PUSH
39552: LD_INT 3
39554: NEG
39555: PUSH
39556: LD_INT 0
39558: PUSH
39559: EMPTY
39560: LIST
39561: LIST
39562: PUSH
39563: LD_INT 3
39565: NEG
39566: PUSH
39567: LD_INT 1
39569: NEG
39570: PUSH
39571: EMPTY
39572: LIST
39573: LIST
39574: PUSH
39575: LD_INT 2
39577: NEG
39578: PUSH
39579: LD_INT 0
39581: PUSH
39582: EMPTY
39583: LIST
39584: LIST
39585: PUSH
39586: LD_INT 2
39588: NEG
39589: PUSH
39590: LD_INT 1
39592: PUSH
39593: EMPTY
39594: LIST
39595: LIST
39596: PUSH
39597: LD_INT 3
39599: NEG
39600: PUSH
39601: LD_INT 1
39603: PUSH
39604: EMPTY
39605: LIST
39606: LIST
39607: PUSH
39608: LD_INT 4
39610: NEG
39611: PUSH
39612: LD_INT 0
39614: PUSH
39615: EMPTY
39616: LIST
39617: LIST
39618: PUSH
39619: LD_INT 4
39621: NEG
39622: PUSH
39623: LD_INT 1
39625: NEG
39626: PUSH
39627: EMPTY
39628: LIST
39629: LIST
39630: PUSH
39631: LD_INT 4
39633: NEG
39634: PUSH
39635: LD_INT 2
39637: NEG
39638: PUSH
39639: EMPTY
39640: LIST
39641: LIST
39642: PUSH
39643: LD_INT 2
39645: NEG
39646: PUSH
39647: LD_INT 2
39649: PUSH
39650: EMPTY
39651: LIST
39652: LIST
39653: PUSH
39654: LD_INT 4
39656: NEG
39657: PUSH
39658: LD_INT 4
39660: NEG
39661: PUSH
39662: EMPTY
39663: LIST
39664: LIST
39665: PUSH
39666: LD_INT 4
39668: NEG
39669: PUSH
39670: LD_INT 5
39672: NEG
39673: PUSH
39674: EMPTY
39675: LIST
39676: LIST
39677: PUSH
39678: LD_INT 3
39680: NEG
39681: PUSH
39682: LD_INT 4
39684: NEG
39685: PUSH
39686: EMPTY
39687: LIST
39688: LIST
39689: PUSH
39690: LD_INT 3
39692: NEG
39693: PUSH
39694: LD_INT 3
39696: NEG
39697: PUSH
39698: EMPTY
39699: LIST
39700: LIST
39701: PUSH
39702: LD_INT 4
39704: NEG
39705: PUSH
39706: LD_INT 3
39708: NEG
39709: PUSH
39710: EMPTY
39711: LIST
39712: LIST
39713: PUSH
39714: LD_INT 5
39716: NEG
39717: PUSH
39718: LD_INT 4
39720: NEG
39721: PUSH
39722: EMPTY
39723: LIST
39724: LIST
39725: PUSH
39726: LD_INT 5
39728: NEG
39729: PUSH
39730: LD_INT 5
39732: NEG
39733: PUSH
39734: EMPTY
39735: LIST
39736: LIST
39737: PUSH
39738: LD_INT 3
39740: NEG
39741: PUSH
39742: LD_INT 5
39744: NEG
39745: PUSH
39746: EMPTY
39747: LIST
39748: LIST
39749: PUSH
39750: LD_INT 5
39752: NEG
39753: PUSH
39754: LD_INT 3
39756: NEG
39757: PUSH
39758: EMPTY
39759: LIST
39760: LIST
39761: PUSH
39762: LD_INT 0
39764: PUSH
39765: LD_INT 3
39767: NEG
39768: PUSH
39769: EMPTY
39770: LIST
39771: LIST
39772: PUSH
39773: LD_INT 0
39775: PUSH
39776: LD_INT 4
39778: NEG
39779: PUSH
39780: EMPTY
39781: LIST
39782: LIST
39783: PUSH
39784: LD_INT 1
39786: PUSH
39787: LD_INT 3
39789: NEG
39790: PUSH
39791: EMPTY
39792: LIST
39793: LIST
39794: PUSH
39795: LD_INT 1
39797: PUSH
39798: LD_INT 2
39800: NEG
39801: PUSH
39802: EMPTY
39803: LIST
39804: LIST
39805: PUSH
39806: LD_INT 0
39808: PUSH
39809: LD_INT 2
39811: NEG
39812: PUSH
39813: EMPTY
39814: LIST
39815: LIST
39816: PUSH
39817: LD_INT 1
39819: NEG
39820: PUSH
39821: LD_INT 3
39823: NEG
39824: PUSH
39825: EMPTY
39826: LIST
39827: LIST
39828: PUSH
39829: LD_INT 1
39831: NEG
39832: PUSH
39833: LD_INT 4
39835: NEG
39836: PUSH
39837: EMPTY
39838: LIST
39839: LIST
39840: PUSH
39841: LD_INT 2
39843: PUSH
39844: LD_INT 2
39846: NEG
39847: PUSH
39848: EMPTY
39849: LIST
39850: LIST
39851: PUSH
39852: LD_INT 2
39854: NEG
39855: PUSH
39856: LD_INT 4
39858: NEG
39859: PUSH
39860: EMPTY
39861: LIST
39862: LIST
39863: PUSH
39864: LD_INT 4
39866: PUSH
39867: LD_INT 0
39869: PUSH
39870: EMPTY
39871: LIST
39872: LIST
39873: PUSH
39874: LD_INT 4
39876: PUSH
39877: LD_INT 1
39879: NEG
39880: PUSH
39881: EMPTY
39882: LIST
39883: LIST
39884: PUSH
39885: LD_INT 5
39887: PUSH
39888: LD_INT 0
39890: PUSH
39891: EMPTY
39892: LIST
39893: LIST
39894: PUSH
39895: LD_INT 5
39897: PUSH
39898: LD_INT 1
39900: PUSH
39901: EMPTY
39902: LIST
39903: LIST
39904: PUSH
39905: LD_INT 4
39907: PUSH
39908: LD_INT 1
39910: PUSH
39911: EMPTY
39912: LIST
39913: LIST
39914: PUSH
39915: LD_INT 3
39917: PUSH
39918: LD_INT 0
39920: PUSH
39921: EMPTY
39922: LIST
39923: LIST
39924: PUSH
39925: LD_INT 3
39927: PUSH
39928: LD_INT 1
39930: NEG
39931: PUSH
39932: EMPTY
39933: LIST
39934: LIST
39935: PUSH
39936: LD_INT 3
39938: PUSH
39939: LD_INT 2
39941: NEG
39942: PUSH
39943: EMPTY
39944: LIST
39945: LIST
39946: PUSH
39947: LD_INT 5
39949: PUSH
39950: LD_INT 2
39952: PUSH
39953: EMPTY
39954: LIST
39955: LIST
39956: PUSH
39957: EMPTY
39958: LIST
39959: LIST
39960: LIST
39961: LIST
39962: LIST
39963: LIST
39964: LIST
39965: LIST
39966: LIST
39967: LIST
39968: LIST
39969: LIST
39970: LIST
39971: LIST
39972: LIST
39973: LIST
39974: LIST
39975: LIST
39976: LIST
39977: LIST
39978: LIST
39979: LIST
39980: LIST
39981: LIST
39982: LIST
39983: LIST
39984: LIST
39985: LIST
39986: LIST
39987: LIST
39988: LIST
39989: LIST
39990: LIST
39991: LIST
39992: LIST
39993: LIST
39994: LIST
39995: LIST
39996: LIST
39997: LIST
39998: LIST
39999: LIST
40000: LIST
40001: LIST
40002: LIST
40003: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
40004: LD_ADDR_VAR 0 32
40008: PUSH
40009: LD_INT 4
40011: NEG
40012: PUSH
40013: LD_INT 0
40015: PUSH
40016: EMPTY
40017: LIST
40018: LIST
40019: PUSH
40020: LD_INT 4
40022: NEG
40023: PUSH
40024: LD_INT 1
40026: NEG
40027: PUSH
40028: EMPTY
40029: LIST
40030: LIST
40031: PUSH
40032: LD_INT 3
40034: NEG
40035: PUSH
40036: LD_INT 0
40038: PUSH
40039: EMPTY
40040: LIST
40041: LIST
40042: PUSH
40043: LD_INT 3
40045: NEG
40046: PUSH
40047: LD_INT 1
40049: PUSH
40050: EMPTY
40051: LIST
40052: LIST
40053: PUSH
40054: LD_INT 4
40056: NEG
40057: PUSH
40058: LD_INT 1
40060: PUSH
40061: EMPTY
40062: LIST
40063: LIST
40064: PUSH
40065: LD_INT 5
40067: NEG
40068: PUSH
40069: LD_INT 0
40071: PUSH
40072: EMPTY
40073: LIST
40074: LIST
40075: PUSH
40076: LD_INT 5
40078: NEG
40079: PUSH
40080: LD_INT 1
40082: NEG
40083: PUSH
40084: EMPTY
40085: LIST
40086: LIST
40087: PUSH
40088: LD_INT 5
40090: NEG
40091: PUSH
40092: LD_INT 2
40094: NEG
40095: PUSH
40096: EMPTY
40097: LIST
40098: LIST
40099: PUSH
40100: LD_INT 3
40102: NEG
40103: PUSH
40104: LD_INT 2
40106: PUSH
40107: EMPTY
40108: LIST
40109: LIST
40110: PUSH
40111: LD_INT 3
40113: NEG
40114: PUSH
40115: LD_INT 3
40117: NEG
40118: PUSH
40119: EMPTY
40120: LIST
40121: LIST
40122: PUSH
40123: LD_INT 3
40125: NEG
40126: PUSH
40127: LD_INT 4
40129: NEG
40130: PUSH
40131: EMPTY
40132: LIST
40133: LIST
40134: PUSH
40135: LD_INT 2
40137: NEG
40138: PUSH
40139: LD_INT 3
40141: NEG
40142: PUSH
40143: EMPTY
40144: LIST
40145: LIST
40146: PUSH
40147: LD_INT 2
40149: NEG
40150: PUSH
40151: LD_INT 2
40153: NEG
40154: PUSH
40155: EMPTY
40156: LIST
40157: LIST
40158: PUSH
40159: LD_INT 3
40161: NEG
40162: PUSH
40163: LD_INT 2
40165: NEG
40166: PUSH
40167: EMPTY
40168: LIST
40169: LIST
40170: PUSH
40171: LD_INT 4
40173: NEG
40174: PUSH
40175: LD_INT 3
40177: NEG
40178: PUSH
40179: EMPTY
40180: LIST
40181: LIST
40182: PUSH
40183: LD_INT 4
40185: NEG
40186: PUSH
40187: LD_INT 4
40189: NEG
40190: PUSH
40191: EMPTY
40192: LIST
40193: LIST
40194: PUSH
40195: LD_INT 2
40197: NEG
40198: PUSH
40199: LD_INT 4
40201: NEG
40202: PUSH
40203: EMPTY
40204: LIST
40205: LIST
40206: PUSH
40207: LD_INT 4
40209: NEG
40210: PUSH
40211: LD_INT 2
40213: NEG
40214: PUSH
40215: EMPTY
40216: LIST
40217: LIST
40218: PUSH
40219: LD_INT 0
40221: PUSH
40222: LD_INT 4
40224: NEG
40225: PUSH
40226: EMPTY
40227: LIST
40228: LIST
40229: PUSH
40230: LD_INT 0
40232: PUSH
40233: LD_INT 5
40235: NEG
40236: PUSH
40237: EMPTY
40238: LIST
40239: LIST
40240: PUSH
40241: LD_INT 1
40243: PUSH
40244: LD_INT 4
40246: NEG
40247: PUSH
40248: EMPTY
40249: LIST
40250: LIST
40251: PUSH
40252: LD_INT 1
40254: PUSH
40255: LD_INT 3
40257: NEG
40258: PUSH
40259: EMPTY
40260: LIST
40261: LIST
40262: PUSH
40263: LD_INT 0
40265: PUSH
40266: LD_INT 3
40268: NEG
40269: PUSH
40270: EMPTY
40271: LIST
40272: LIST
40273: PUSH
40274: LD_INT 1
40276: NEG
40277: PUSH
40278: LD_INT 4
40280: NEG
40281: PUSH
40282: EMPTY
40283: LIST
40284: LIST
40285: PUSH
40286: LD_INT 1
40288: NEG
40289: PUSH
40290: LD_INT 5
40292: NEG
40293: PUSH
40294: EMPTY
40295: LIST
40296: LIST
40297: PUSH
40298: LD_INT 2
40300: PUSH
40301: LD_INT 3
40303: NEG
40304: PUSH
40305: EMPTY
40306: LIST
40307: LIST
40308: PUSH
40309: LD_INT 2
40311: NEG
40312: PUSH
40313: LD_INT 5
40315: NEG
40316: PUSH
40317: EMPTY
40318: LIST
40319: LIST
40320: PUSH
40321: LD_INT 3
40323: PUSH
40324: LD_INT 0
40326: PUSH
40327: EMPTY
40328: LIST
40329: LIST
40330: PUSH
40331: LD_INT 3
40333: PUSH
40334: LD_INT 1
40336: NEG
40337: PUSH
40338: EMPTY
40339: LIST
40340: LIST
40341: PUSH
40342: LD_INT 4
40344: PUSH
40345: LD_INT 0
40347: PUSH
40348: EMPTY
40349: LIST
40350: LIST
40351: PUSH
40352: LD_INT 4
40354: PUSH
40355: LD_INT 1
40357: PUSH
40358: EMPTY
40359: LIST
40360: LIST
40361: PUSH
40362: LD_INT 3
40364: PUSH
40365: LD_INT 1
40367: PUSH
40368: EMPTY
40369: LIST
40370: LIST
40371: PUSH
40372: LD_INT 2
40374: PUSH
40375: LD_INT 0
40377: PUSH
40378: EMPTY
40379: LIST
40380: LIST
40381: PUSH
40382: LD_INT 2
40384: PUSH
40385: LD_INT 1
40387: NEG
40388: PUSH
40389: EMPTY
40390: LIST
40391: LIST
40392: PUSH
40393: LD_INT 2
40395: PUSH
40396: LD_INT 2
40398: NEG
40399: PUSH
40400: EMPTY
40401: LIST
40402: LIST
40403: PUSH
40404: LD_INT 4
40406: PUSH
40407: LD_INT 2
40409: PUSH
40410: EMPTY
40411: LIST
40412: LIST
40413: PUSH
40414: LD_INT 4
40416: PUSH
40417: LD_INT 4
40419: PUSH
40420: EMPTY
40421: LIST
40422: LIST
40423: PUSH
40424: LD_INT 4
40426: PUSH
40427: LD_INT 3
40429: PUSH
40430: EMPTY
40431: LIST
40432: LIST
40433: PUSH
40434: LD_INT 5
40436: PUSH
40437: LD_INT 4
40439: PUSH
40440: EMPTY
40441: LIST
40442: LIST
40443: PUSH
40444: LD_INT 5
40446: PUSH
40447: LD_INT 5
40449: PUSH
40450: EMPTY
40451: LIST
40452: LIST
40453: PUSH
40454: LD_INT 4
40456: PUSH
40457: LD_INT 5
40459: PUSH
40460: EMPTY
40461: LIST
40462: LIST
40463: PUSH
40464: LD_INT 3
40466: PUSH
40467: LD_INT 4
40469: PUSH
40470: EMPTY
40471: LIST
40472: LIST
40473: PUSH
40474: LD_INT 3
40476: PUSH
40477: LD_INT 3
40479: PUSH
40480: EMPTY
40481: LIST
40482: LIST
40483: PUSH
40484: LD_INT 5
40486: PUSH
40487: LD_INT 3
40489: PUSH
40490: EMPTY
40491: LIST
40492: LIST
40493: PUSH
40494: LD_INT 3
40496: PUSH
40497: LD_INT 5
40499: PUSH
40500: EMPTY
40501: LIST
40502: LIST
40503: PUSH
40504: EMPTY
40505: LIST
40506: LIST
40507: LIST
40508: LIST
40509: LIST
40510: LIST
40511: LIST
40512: LIST
40513: LIST
40514: LIST
40515: LIST
40516: LIST
40517: LIST
40518: LIST
40519: LIST
40520: LIST
40521: LIST
40522: LIST
40523: LIST
40524: LIST
40525: LIST
40526: LIST
40527: LIST
40528: LIST
40529: LIST
40530: LIST
40531: LIST
40532: LIST
40533: LIST
40534: LIST
40535: LIST
40536: LIST
40537: LIST
40538: LIST
40539: LIST
40540: LIST
40541: LIST
40542: LIST
40543: LIST
40544: LIST
40545: LIST
40546: LIST
40547: LIST
40548: LIST
40549: LIST
40550: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
40551: LD_ADDR_VAR 0 33
40555: PUSH
40556: LD_INT 4
40558: NEG
40559: PUSH
40560: LD_INT 4
40562: NEG
40563: PUSH
40564: EMPTY
40565: LIST
40566: LIST
40567: PUSH
40568: LD_INT 4
40570: NEG
40571: PUSH
40572: LD_INT 5
40574: NEG
40575: PUSH
40576: EMPTY
40577: LIST
40578: LIST
40579: PUSH
40580: LD_INT 3
40582: NEG
40583: PUSH
40584: LD_INT 4
40586: NEG
40587: PUSH
40588: EMPTY
40589: LIST
40590: LIST
40591: PUSH
40592: LD_INT 3
40594: NEG
40595: PUSH
40596: LD_INT 3
40598: NEG
40599: PUSH
40600: EMPTY
40601: LIST
40602: LIST
40603: PUSH
40604: LD_INT 4
40606: NEG
40607: PUSH
40608: LD_INT 3
40610: NEG
40611: PUSH
40612: EMPTY
40613: LIST
40614: LIST
40615: PUSH
40616: LD_INT 5
40618: NEG
40619: PUSH
40620: LD_INT 4
40622: NEG
40623: PUSH
40624: EMPTY
40625: LIST
40626: LIST
40627: PUSH
40628: LD_INT 5
40630: NEG
40631: PUSH
40632: LD_INT 5
40634: NEG
40635: PUSH
40636: EMPTY
40637: LIST
40638: LIST
40639: PUSH
40640: LD_INT 3
40642: NEG
40643: PUSH
40644: LD_INT 5
40646: NEG
40647: PUSH
40648: EMPTY
40649: LIST
40650: LIST
40651: PUSH
40652: LD_INT 5
40654: NEG
40655: PUSH
40656: LD_INT 3
40658: NEG
40659: PUSH
40660: EMPTY
40661: LIST
40662: LIST
40663: PUSH
40664: LD_INT 0
40666: PUSH
40667: LD_INT 3
40669: NEG
40670: PUSH
40671: EMPTY
40672: LIST
40673: LIST
40674: PUSH
40675: LD_INT 0
40677: PUSH
40678: LD_INT 4
40680: NEG
40681: PUSH
40682: EMPTY
40683: LIST
40684: LIST
40685: PUSH
40686: LD_INT 1
40688: PUSH
40689: LD_INT 3
40691: NEG
40692: PUSH
40693: EMPTY
40694: LIST
40695: LIST
40696: PUSH
40697: LD_INT 1
40699: PUSH
40700: LD_INT 2
40702: NEG
40703: PUSH
40704: EMPTY
40705: LIST
40706: LIST
40707: PUSH
40708: LD_INT 0
40710: PUSH
40711: LD_INT 2
40713: NEG
40714: PUSH
40715: EMPTY
40716: LIST
40717: LIST
40718: PUSH
40719: LD_INT 1
40721: NEG
40722: PUSH
40723: LD_INT 3
40725: NEG
40726: PUSH
40727: EMPTY
40728: LIST
40729: LIST
40730: PUSH
40731: LD_INT 1
40733: NEG
40734: PUSH
40735: LD_INT 4
40737: NEG
40738: PUSH
40739: EMPTY
40740: LIST
40741: LIST
40742: PUSH
40743: LD_INT 2
40745: PUSH
40746: LD_INT 2
40748: NEG
40749: PUSH
40750: EMPTY
40751: LIST
40752: LIST
40753: PUSH
40754: LD_INT 2
40756: NEG
40757: PUSH
40758: LD_INT 4
40760: NEG
40761: PUSH
40762: EMPTY
40763: LIST
40764: LIST
40765: PUSH
40766: LD_INT 4
40768: PUSH
40769: LD_INT 0
40771: PUSH
40772: EMPTY
40773: LIST
40774: LIST
40775: PUSH
40776: LD_INT 4
40778: PUSH
40779: LD_INT 1
40781: NEG
40782: PUSH
40783: EMPTY
40784: LIST
40785: LIST
40786: PUSH
40787: LD_INT 5
40789: PUSH
40790: LD_INT 0
40792: PUSH
40793: EMPTY
40794: LIST
40795: LIST
40796: PUSH
40797: LD_INT 5
40799: PUSH
40800: LD_INT 1
40802: PUSH
40803: EMPTY
40804: LIST
40805: LIST
40806: PUSH
40807: LD_INT 4
40809: PUSH
40810: LD_INT 1
40812: PUSH
40813: EMPTY
40814: LIST
40815: LIST
40816: PUSH
40817: LD_INT 3
40819: PUSH
40820: LD_INT 0
40822: PUSH
40823: EMPTY
40824: LIST
40825: LIST
40826: PUSH
40827: LD_INT 3
40829: PUSH
40830: LD_INT 1
40832: NEG
40833: PUSH
40834: EMPTY
40835: LIST
40836: LIST
40837: PUSH
40838: LD_INT 3
40840: PUSH
40841: LD_INT 2
40843: NEG
40844: PUSH
40845: EMPTY
40846: LIST
40847: LIST
40848: PUSH
40849: LD_INT 5
40851: PUSH
40852: LD_INT 2
40854: PUSH
40855: EMPTY
40856: LIST
40857: LIST
40858: PUSH
40859: LD_INT 3
40861: PUSH
40862: LD_INT 3
40864: PUSH
40865: EMPTY
40866: LIST
40867: LIST
40868: PUSH
40869: LD_INT 3
40871: PUSH
40872: LD_INT 2
40874: PUSH
40875: EMPTY
40876: LIST
40877: LIST
40878: PUSH
40879: LD_INT 4
40881: PUSH
40882: LD_INT 3
40884: PUSH
40885: EMPTY
40886: LIST
40887: LIST
40888: PUSH
40889: LD_INT 4
40891: PUSH
40892: LD_INT 4
40894: PUSH
40895: EMPTY
40896: LIST
40897: LIST
40898: PUSH
40899: LD_INT 3
40901: PUSH
40902: LD_INT 4
40904: PUSH
40905: EMPTY
40906: LIST
40907: LIST
40908: PUSH
40909: LD_INT 2
40911: PUSH
40912: LD_INT 3
40914: PUSH
40915: EMPTY
40916: LIST
40917: LIST
40918: PUSH
40919: LD_INT 2
40921: PUSH
40922: LD_INT 2
40924: PUSH
40925: EMPTY
40926: LIST
40927: LIST
40928: PUSH
40929: LD_INT 4
40931: PUSH
40932: LD_INT 2
40934: PUSH
40935: EMPTY
40936: LIST
40937: LIST
40938: PUSH
40939: LD_INT 2
40941: PUSH
40942: LD_INT 4
40944: PUSH
40945: EMPTY
40946: LIST
40947: LIST
40948: PUSH
40949: LD_INT 0
40951: PUSH
40952: LD_INT 4
40954: PUSH
40955: EMPTY
40956: LIST
40957: LIST
40958: PUSH
40959: LD_INT 0
40961: PUSH
40962: LD_INT 3
40964: PUSH
40965: EMPTY
40966: LIST
40967: LIST
40968: PUSH
40969: LD_INT 1
40971: PUSH
40972: LD_INT 4
40974: PUSH
40975: EMPTY
40976: LIST
40977: LIST
40978: PUSH
40979: LD_INT 1
40981: PUSH
40982: LD_INT 5
40984: PUSH
40985: EMPTY
40986: LIST
40987: LIST
40988: PUSH
40989: LD_INT 0
40991: PUSH
40992: LD_INT 5
40994: PUSH
40995: EMPTY
40996: LIST
40997: LIST
40998: PUSH
40999: LD_INT 1
41001: NEG
41002: PUSH
41003: LD_INT 4
41005: PUSH
41006: EMPTY
41007: LIST
41008: LIST
41009: PUSH
41010: LD_INT 1
41012: NEG
41013: PUSH
41014: LD_INT 3
41016: PUSH
41017: EMPTY
41018: LIST
41019: LIST
41020: PUSH
41021: LD_INT 2
41023: PUSH
41024: LD_INT 5
41026: PUSH
41027: EMPTY
41028: LIST
41029: LIST
41030: PUSH
41031: LD_INT 2
41033: NEG
41034: PUSH
41035: LD_INT 3
41037: PUSH
41038: EMPTY
41039: LIST
41040: LIST
41041: PUSH
41042: EMPTY
41043: LIST
41044: LIST
41045: LIST
41046: LIST
41047: LIST
41048: LIST
41049: LIST
41050: LIST
41051: LIST
41052: LIST
41053: LIST
41054: LIST
41055: LIST
41056: LIST
41057: LIST
41058: LIST
41059: LIST
41060: LIST
41061: LIST
41062: LIST
41063: LIST
41064: LIST
41065: LIST
41066: LIST
41067: LIST
41068: LIST
41069: LIST
41070: LIST
41071: LIST
41072: LIST
41073: LIST
41074: LIST
41075: LIST
41076: LIST
41077: LIST
41078: LIST
41079: LIST
41080: LIST
41081: LIST
41082: LIST
41083: LIST
41084: LIST
41085: LIST
41086: LIST
41087: LIST
41088: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
41089: LD_ADDR_VAR 0 34
41093: PUSH
41094: LD_INT 0
41096: PUSH
41097: LD_INT 4
41099: NEG
41100: PUSH
41101: EMPTY
41102: LIST
41103: LIST
41104: PUSH
41105: LD_INT 0
41107: PUSH
41108: LD_INT 5
41110: NEG
41111: PUSH
41112: EMPTY
41113: LIST
41114: LIST
41115: PUSH
41116: LD_INT 1
41118: PUSH
41119: LD_INT 4
41121: NEG
41122: PUSH
41123: EMPTY
41124: LIST
41125: LIST
41126: PUSH
41127: LD_INT 1
41129: PUSH
41130: LD_INT 3
41132: NEG
41133: PUSH
41134: EMPTY
41135: LIST
41136: LIST
41137: PUSH
41138: LD_INT 0
41140: PUSH
41141: LD_INT 3
41143: NEG
41144: PUSH
41145: EMPTY
41146: LIST
41147: LIST
41148: PUSH
41149: LD_INT 1
41151: NEG
41152: PUSH
41153: LD_INT 4
41155: NEG
41156: PUSH
41157: EMPTY
41158: LIST
41159: LIST
41160: PUSH
41161: LD_INT 1
41163: NEG
41164: PUSH
41165: LD_INT 5
41167: NEG
41168: PUSH
41169: EMPTY
41170: LIST
41171: LIST
41172: PUSH
41173: LD_INT 2
41175: PUSH
41176: LD_INT 3
41178: NEG
41179: PUSH
41180: EMPTY
41181: LIST
41182: LIST
41183: PUSH
41184: LD_INT 2
41186: NEG
41187: PUSH
41188: LD_INT 5
41190: NEG
41191: PUSH
41192: EMPTY
41193: LIST
41194: LIST
41195: PUSH
41196: LD_INT 3
41198: PUSH
41199: LD_INT 0
41201: PUSH
41202: EMPTY
41203: LIST
41204: LIST
41205: PUSH
41206: LD_INT 3
41208: PUSH
41209: LD_INT 1
41211: NEG
41212: PUSH
41213: EMPTY
41214: LIST
41215: LIST
41216: PUSH
41217: LD_INT 4
41219: PUSH
41220: LD_INT 0
41222: PUSH
41223: EMPTY
41224: LIST
41225: LIST
41226: PUSH
41227: LD_INT 4
41229: PUSH
41230: LD_INT 1
41232: PUSH
41233: EMPTY
41234: LIST
41235: LIST
41236: PUSH
41237: LD_INT 3
41239: PUSH
41240: LD_INT 1
41242: PUSH
41243: EMPTY
41244: LIST
41245: LIST
41246: PUSH
41247: LD_INT 2
41249: PUSH
41250: LD_INT 0
41252: PUSH
41253: EMPTY
41254: LIST
41255: LIST
41256: PUSH
41257: LD_INT 2
41259: PUSH
41260: LD_INT 1
41262: NEG
41263: PUSH
41264: EMPTY
41265: LIST
41266: LIST
41267: PUSH
41268: LD_INT 2
41270: PUSH
41271: LD_INT 2
41273: NEG
41274: PUSH
41275: EMPTY
41276: LIST
41277: LIST
41278: PUSH
41279: LD_INT 4
41281: PUSH
41282: LD_INT 2
41284: PUSH
41285: EMPTY
41286: LIST
41287: LIST
41288: PUSH
41289: LD_INT 4
41291: PUSH
41292: LD_INT 4
41294: PUSH
41295: EMPTY
41296: LIST
41297: LIST
41298: PUSH
41299: LD_INT 4
41301: PUSH
41302: LD_INT 3
41304: PUSH
41305: EMPTY
41306: LIST
41307: LIST
41308: PUSH
41309: LD_INT 5
41311: PUSH
41312: LD_INT 4
41314: PUSH
41315: EMPTY
41316: LIST
41317: LIST
41318: PUSH
41319: LD_INT 5
41321: PUSH
41322: LD_INT 5
41324: PUSH
41325: EMPTY
41326: LIST
41327: LIST
41328: PUSH
41329: LD_INT 4
41331: PUSH
41332: LD_INT 5
41334: PUSH
41335: EMPTY
41336: LIST
41337: LIST
41338: PUSH
41339: LD_INT 3
41341: PUSH
41342: LD_INT 4
41344: PUSH
41345: EMPTY
41346: LIST
41347: LIST
41348: PUSH
41349: LD_INT 3
41351: PUSH
41352: LD_INT 3
41354: PUSH
41355: EMPTY
41356: LIST
41357: LIST
41358: PUSH
41359: LD_INT 5
41361: PUSH
41362: LD_INT 3
41364: PUSH
41365: EMPTY
41366: LIST
41367: LIST
41368: PUSH
41369: LD_INT 3
41371: PUSH
41372: LD_INT 5
41374: PUSH
41375: EMPTY
41376: LIST
41377: LIST
41378: PUSH
41379: LD_INT 0
41381: PUSH
41382: LD_INT 3
41384: PUSH
41385: EMPTY
41386: LIST
41387: LIST
41388: PUSH
41389: LD_INT 0
41391: PUSH
41392: LD_INT 2
41394: PUSH
41395: EMPTY
41396: LIST
41397: LIST
41398: PUSH
41399: LD_INT 1
41401: PUSH
41402: LD_INT 3
41404: PUSH
41405: EMPTY
41406: LIST
41407: LIST
41408: PUSH
41409: LD_INT 1
41411: PUSH
41412: LD_INT 4
41414: PUSH
41415: EMPTY
41416: LIST
41417: LIST
41418: PUSH
41419: LD_INT 0
41421: PUSH
41422: LD_INT 4
41424: PUSH
41425: EMPTY
41426: LIST
41427: LIST
41428: PUSH
41429: LD_INT 1
41431: NEG
41432: PUSH
41433: LD_INT 3
41435: PUSH
41436: EMPTY
41437: LIST
41438: LIST
41439: PUSH
41440: LD_INT 1
41442: NEG
41443: PUSH
41444: LD_INT 2
41446: PUSH
41447: EMPTY
41448: LIST
41449: LIST
41450: PUSH
41451: LD_INT 2
41453: PUSH
41454: LD_INT 4
41456: PUSH
41457: EMPTY
41458: LIST
41459: LIST
41460: PUSH
41461: LD_INT 2
41463: NEG
41464: PUSH
41465: LD_INT 2
41467: PUSH
41468: EMPTY
41469: LIST
41470: LIST
41471: PUSH
41472: LD_INT 4
41474: NEG
41475: PUSH
41476: LD_INT 0
41478: PUSH
41479: EMPTY
41480: LIST
41481: LIST
41482: PUSH
41483: LD_INT 4
41485: NEG
41486: PUSH
41487: LD_INT 1
41489: NEG
41490: PUSH
41491: EMPTY
41492: LIST
41493: LIST
41494: PUSH
41495: LD_INT 3
41497: NEG
41498: PUSH
41499: LD_INT 0
41501: PUSH
41502: EMPTY
41503: LIST
41504: LIST
41505: PUSH
41506: LD_INT 3
41508: NEG
41509: PUSH
41510: LD_INT 1
41512: PUSH
41513: EMPTY
41514: LIST
41515: LIST
41516: PUSH
41517: LD_INT 4
41519: NEG
41520: PUSH
41521: LD_INT 1
41523: PUSH
41524: EMPTY
41525: LIST
41526: LIST
41527: PUSH
41528: LD_INT 5
41530: NEG
41531: PUSH
41532: LD_INT 0
41534: PUSH
41535: EMPTY
41536: LIST
41537: LIST
41538: PUSH
41539: LD_INT 5
41541: NEG
41542: PUSH
41543: LD_INT 1
41545: NEG
41546: PUSH
41547: EMPTY
41548: LIST
41549: LIST
41550: PUSH
41551: LD_INT 5
41553: NEG
41554: PUSH
41555: LD_INT 2
41557: NEG
41558: PUSH
41559: EMPTY
41560: LIST
41561: LIST
41562: PUSH
41563: LD_INT 3
41565: NEG
41566: PUSH
41567: LD_INT 2
41569: PUSH
41570: EMPTY
41571: LIST
41572: LIST
41573: PUSH
41574: EMPTY
41575: LIST
41576: LIST
41577: LIST
41578: LIST
41579: LIST
41580: LIST
41581: LIST
41582: LIST
41583: LIST
41584: LIST
41585: LIST
41586: LIST
41587: LIST
41588: LIST
41589: LIST
41590: LIST
41591: LIST
41592: LIST
41593: LIST
41594: LIST
41595: LIST
41596: LIST
41597: LIST
41598: LIST
41599: LIST
41600: LIST
41601: LIST
41602: LIST
41603: LIST
41604: LIST
41605: LIST
41606: LIST
41607: LIST
41608: LIST
41609: LIST
41610: LIST
41611: LIST
41612: LIST
41613: LIST
41614: LIST
41615: LIST
41616: LIST
41617: LIST
41618: LIST
41619: LIST
41620: ST_TO_ADDR
// end ; end ;
41621: GO 41624
41623: POP
// case btype of b_depot , b_warehouse :
41624: LD_VAR 0 1
41628: PUSH
41629: LD_INT 0
41631: DOUBLE
41632: EQUAL
41633: IFTRUE 41643
41635: LD_INT 1
41637: DOUBLE
41638: EQUAL
41639: IFTRUE 41643
41641: GO 41844
41643: POP
// case nation of nation_american :
41644: LD_VAR 0 5
41648: PUSH
41649: LD_INT 1
41651: DOUBLE
41652: EQUAL
41653: IFTRUE 41657
41655: GO 41713
41657: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
41658: LD_ADDR_VAR 0 9
41662: PUSH
41663: LD_VAR 0 11
41667: PUSH
41668: LD_VAR 0 12
41672: PUSH
41673: LD_VAR 0 13
41677: PUSH
41678: LD_VAR 0 14
41682: PUSH
41683: LD_VAR 0 15
41687: PUSH
41688: LD_VAR 0 16
41692: PUSH
41693: EMPTY
41694: LIST
41695: LIST
41696: LIST
41697: LIST
41698: LIST
41699: LIST
41700: PUSH
41701: LD_VAR 0 4
41705: PUSH
41706: LD_INT 1
41708: PLUS
41709: ARRAY
41710: ST_TO_ADDR
41711: GO 41842
41713: LD_INT 2
41715: DOUBLE
41716: EQUAL
41717: IFTRUE 41721
41719: GO 41777
41721: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
41722: LD_ADDR_VAR 0 9
41726: PUSH
41727: LD_VAR 0 17
41731: PUSH
41732: LD_VAR 0 18
41736: PUSH
41737: LD_VAR 0 19
41741: PUSH
41742: LD_VAR 0 20
41746: PUSH
41747: LD_VAR 0 21
41751: PUSH
41752: LD_VAR 0 22
41756: PUSH
41757: EMPTY
41758: LIST
41759: LIST
41760: LIST
41761: LIST
41762: LIST
41763: LIST
41764: PUSH
41765: LD_VAR 0 4
41769: PUSH
41770: LD_INT 1
41772: PLUS
41773: ARRAY
41774: ST_TO_ADDR
41775: GO 41842
41777: LD_INT 3
41779: DOUBLE
41780: EQUAL
41781: IFTRUE 41785
41783: GO 41841
41785: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
41786: LD_ADDR_VAR 0 9
41790: PUSH
41791: LD_VAR 0 23
41795: PUSH
41796: LD_VAR 0 24
41800: PUSH
41801: LD_VAR 0 25
41805: PUSH
41806: LD_VAR 0 26
41810: PUSH
41811: LD_VAR 0 27
41815: PUSH
41816: LD_VAR 0 28
41820: PUSH
41821: EMPTY
41822: LIST
41823: LIST
41824: LIST
41825: LIST
41826: LIST
41827: LIST
41828: PUSH
41829: LD_VAR 0 4
41833: PUSH
41834: LD_INT 1
41836: PLUS
41837: ARRAY
41838: ST_TO_ADDR
41839: GO 41842
41841: POP
41842: GO 42397
41844: LD_INT 2
41846: DOUBLE
41847: EQUAL
41848: IFTRUE 41858
41850: LD_INT 3
41852: DOUBLE
41853: EQUAL
41854: IFTRUE 41858
41856: GO 41914
41858: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
41859: LD_ADDR_VAR 0 9
41863: PUSH
41864: LD_VAR 0 29
41868: PUSH
41869: LD_VAR 0 30
41873: PUSH
41874: LD_VAR 0 31
41878: PUSH
41879: LD_VAR 0 32
41883: PUSH
41884: LD_VAR 0 33
41888: PUSH
41889: LD_VAR 0 34
41893: PUSH
41894: EMPTY
41895: LIST
41896: LIST
41897: LIST
41898: LIST
41899: LIST
41900: LIST
41901: PUSH
41902: LD_VAR 0 4
41906: PUSH
41907: LD_INT 1
41909: PLUS
41910: ARRAY
41911: ST_TO_ADDR
41912: GO 42397
41914: LD_INT 16
41916: DOUBLE
41917: EQUAL
41918: IFTRUE 41976
41920: LD_INT 17
41922: DOUBLE
41923: EQUAL
41924: IFTRUE 41976
41926: LD_INT 18
41928: DOUBLE
41929: EQUAL
41930: IFTRUE 41976
41932: LD_INT 19
41934: DOUBLE
41935: EQUAL
41936: IFTRUE 41976
41938: LD_INT 22
41940: DOUBLE
41941: EQUAL
41942: IFTRUE 41976
41944: LD_INT 20
41946: DOUBLE
41947: EQUAL
41948: IFTRUE 41976
41950: LD_INT 21
41952: DOUBLE
41953: EQUAL
41954: IFTRUE 41976
41956: LD_INT 23
41958: DOUBLE
41959: EQUAL
41960: IFTRUE 41976
41962: LD_INT 24
41964: DOUBLE
41965: EQUAL
41966: IFTRUE 41976
41968: LD_INT 25
41970: DOUBLE
41971: EQUAL
41972: IFTRUE 41976
41974: GO 42032
41976: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
41977: LD_ADDR_VAR 0 9
41981: PUSH
41982: LD_VAR 0 35
41986: PUSH
41987: LD_VAR 0 36
41991: PUSH
41992: LD_VAR 0 37
41996: PUSH
41997: LD_VAR 0 38
42001: PUSH
42002: LD_VAR 0 39
42006: PUSH
42007: LD_VAR 0 40
42011: PUSH
42012: EMPTY
42013: LIST
42014: LIST
42015: LIST
42016: LIST
42017: LIST
42018: LIST
42019: PUSH
42020: LD_VAR 0 4
42024: PUSH
42025: LD_INT 1
42027: PLUS
42028: ARRAY
42029: ST_TO_ADDR
42030: GO 42397
42032: LD_INT 6
42034: DOUBLE
42035: EQUAL
42036: IFTRUE 42088
42038: LD_INT 7
42040: DOUBLE
42041: EQUAL
42042: IFTRUE 42088
42044: LD_INT 8
42046: DOUBLE
42047: EQUAL
42048: IFTRUE 42088
42050: LD_INT 13
42052: DOUBLE
42053: EQUAL
42054: IFTRUE 42088
42056: LD_INT 12
42058: DOUBLE
42059: EQUAL
42060: IFTRUE 42088
42062: LD_INT 15
42064: DOUBLE
42065: EQUAL
42066: IFTRUE 42088
42068: LD_INT 11
42070: DOUBLE
42071: EQUAL
42072: IFTRUE 42088
42074: LD_INT 14
42076: DOUBLE
42077: EQUAL
42078: IFTRUE 42088
42080: LD_INT 10
42082: DOUBLE
42083: EQUAL
42084: IFTRUE 42088
42086: GO 42144
42088: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
42089: LD_ADDR_VAR 0 9
42093: PUSH
42094: LD_VAR 0 41
42098: PUSH
42099: LD_VAR 0 42
42103: PUSH
42104: LD_VAR 0 43
42108: PUSH
42109: LD_VAR 0 44
42113: PUSH
42114: LD_VAR 0 45
42118: PUSH
42119: LD_VAR 0 46
42123: PUSH
42124: EMPTY
42125: LIST
42126: LIST
42127: LIST
42128: LIST
42129: LIST
42130: LIST
42131: PUSH
42132: LD_VAR 0 4
42136: PUSH
42137: LD_INT 1
42139: PLUS
42140: ARRAY
42141: ST_TO_ADDR
42142: GO 42397
42144: LD_INT 36
42146: DOUBLE
42147: EQUAL
42148: IFTRUE 42152
42150: GO 42208
42152: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
42153: LD_ADDR_VAR 0 9
42157: PUSH
42158: LD_VAR 0 47
42162: PUSH
42163: LD_VAR 0 48
42167: PUSH
42168: LD_VAR 0 49
42172: PUSH
42173: LD_VAR 0 50
42177: PUSH
42178: LD_VAR 0 51
42182: PUSH
42183: LD_VAR 0 52
42187: PUSH
42188: EMPTY
42189: LIST
42190: LIST
42191: LIST
42192: LIST
42193: LIST
42194: LIST
42195: PUSH
42196: LD_VAR 0 4
42200: PUSH
42201: LD_INT 1
42203: PLUS
42204: ARRAY
42205: ST_TO_ADDR
42206: GO 42397
42208: LD_INT 4
42210: DOUBLE
42211: EQUAL
42212: IFTRUE 42234
42214: LD_INT 5
42216: DOUBLE
42217: EQUAL
42218: IFTRUE 42234
42220: LD_INT 34
42222: DOUBLE
42223: EQUAL
42224: IFTRUE 42234
42226: LD_INT 37
42228: DOUBLE
42229: EQUAL
42230: IFTRUE 42234
42232: GO 42290
42234: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
42235: LD_ADDR_VAR 0 9
42239: PUSH
42240: LD_VAR 0 53
42244: PUSH
42245: LD_VAR 0 54
42249: PUSH
42250: LD_VAR 0 55
42254: PUSH
42255: LD_VAR 0 56
42259: PUSH
42260: LD_VAR 0 57
42264: PUSH
42265: LD_VAR 0 58
42269: PUSH
42270: EMPTY
42271: LIST
42272: LIST
42273: LIST
42274: LIST
42275: LIST
42276: LIST
42277: PUSH
42278: LD_VAR 0 4
42282: PUSH
42283: LD_INT 1
42285: PLUS
42286: ARRAY
42287: ST_TO_ADDR
42288: GO 42397
42290: LD_INT 31
42292: DOUBLE
42293: EQUAL
42294: IFTRUE 42340
42296: LD_INT 32
42298: DOUBLE
42299: EQUAL
42300: IFTRUE 42340
42302: LD_INT 33
42304: DOUBLE
42305: EQUAL
42306: IFTRUE 42340
42308: LD_INT 27
42310: DOUBLE
42311: EQUAL
42312: IFTRUE 42340
42314: LD_INT 26
42316: DOUBLE
42317: EQUAL
42318: IFTRUE 42340
42320: LD_INT 28
42322: DOUBLE
42323: EQUAL
42324: IFTRUE 42340
42326: LD_INT 29
42328: DOUBLE
42329: EQUAL
42330: IFTRUE 42340
42332: LD_INT 30
42334: DOUBLE
42335: EQUAL
42336: IFTRUE 42340
42338: GO 42396
42340: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
42341: LD_ADDR_VAR 0 9
42345: PUSH
42346: LD_VAR 0 59
42350: PUSH
42351: LD_VAR 0 60
42355: PUSH
42356: LD_VAR 0 61
42360: PUSH
42361: LD_VAR 0 62
42365: PUSH
42366: LD_VAR 0 63
42370: PUSH
42371: LD_VAR 0 64
42375: PUSH
42376: EMPTY
42377: LIST
42378: LIST
42379: LIST
42380: LIST
42381: LIST
42382: LIST
42383: PUSH
42384: LD_VAR 0 4
42388: PUSH
42389: LD_INT 1
42391: PLUS
42392: ARRAY
42393: ST_TO_ADDR
42394: GO 42397
42396: POP
// temp_list2 = [ ] ;
42397: LD_ADDR_VAR 0 10
42401: PUSH
42402: EMPTY
42403: ST_TO_ADDR
// for i in temp_list do
42404: LD_ADDR_VAR 0 8
42408: PUSH
42409: LD_VAR 0 9
42413: PUSH
42414: FOR_IN
42415: IFFALSE 42467
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
42417: LD_ADDR_VAR 0 10
42421: PUSH
42422: LD_VAR 0 10
42426: PUSH
42427: LD_VAR 0 8
42431: PUSH
42432: LD_INT 1
42434: ARRAY
42435: PUSH
42436: LD_VAR 0 2
42440: PLUS
42441: PUSH
42442: LD_VAR 0 8
42446: PUSH
42447: LD_INT 2
42449: ARRAY
42450: PUSH
42451: LD_VAR 0 3
42455: PLUS
42456: PUSH
42457: EMPTY
42458: LIST
42459: LIST
42460: PUSH
42461: EMPTY
42462: LIST
42463: ADD
42464: ST_TO_ADDR
42465: GO 42414
42467: POP
42468: POP
// result = temp_list2 ;
42469: LD_ADDR_VAR 0 7
42473: PUSH
42474: LD_VAR 0 10
42478: ST_TO_ADDR
// end ;
42479: LD_VAR 0 7
42483: RET
// export function EnemyInRange ( unit , dist ) ; begin
42484: LD_INT 0
42486: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
42487: LD_ADDR_VAR 0 3
42491: PUSH
42492: LD_VAR 0 1
42496: PPUSH
42497: CALL_OW 255
42501: PPUSH
42502: LD_VAR 0 1
42506: PPUSH
42507: CALL_OW 250
42511: PPUSH
42512: LD_VAR 0 1
42516: PPUSH
42517: CALL_OW 251
42521: PPUSH
42522: LD_VAR 0 2
42526: PPUSH
42527: CALL 15879 0 4
42531: PUSH
42532: LD_INT 4
42534: ARRAY
42535: ST_TO_ADDR
// end ;
42536: LD_VAR 0 3
42540: RET
// export function PlayerSeeMe ( unit ) ; begin
42541: LD_INT 0
42543: PPUSH
// result := See ( your_side , unit ) ;
42544: LD_ADDR_VAR 0 2
42548: PUSH
42549: LD_OWVAR 2
42553: PPUSH
42554: LD_VAR 0 1
42558: PPUSH
42559: CALL_OW 292
42563: ST_TO_ADDR
// end ;
42564: LD_VAR 0 2
42568: RET
// export function ReverseDir ( unit ) ; begin
42569: LD_INT 0
42571: PPUSH
// if not unit then
42572: LD_VAR 0 1
42576: NOT
42577: IFFALSE 42581
// exit ;
42579: GO 42604
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
42581: LD_ADDR_VAR 0 2
42585: PUSH
42586: LD_VAR 0 1
42590: PPUSH
42591: CALL_OW 254
42595: PUSH
42596: LD_INT 3
42598: PLUS
42599: PUSH
42600: LD_INT 6
42602: MOD
42603: ST_TO_ADDR
// end ;
42604: LD_VAR 0 2
42608: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
42609: LD_INT 0
42611: PPUSH
42612: PPUSH
42613: PPUSH
42614: PPUSH
42615: PPUSH
// if not hexes then
42616: LD_VAR 0 2
42620: NOT
42621: IFFALSE 42625
// exit ;
42623: GO 42773
// dist := 9999 ;
42625: LD_ADDR_VAR 0 5
42629: PUSH
42630: LD_INT 9999
42632: ST_TO_ADDR
// for i = 1 to hexes do
42633: LD_ADDR_VAR 0 4
42637: PUSH
42638: DOUBLE
42639: LD_INT 1
42641: DEC
42642: ST_TO_ADDR
42643: LD_VAR 0 2
42647: PUSH
42648: FOR_TO
42649: IFFALSE 42761
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
42651: LD_VAR 0 1
42655: PPUSH
42656: LD_VAR 0 2
42660: PUSH
42661: LD_VAR 0 4
42665: ARRAY
42666: PUSH
42667: LD_INT 1
42669: ARRAY
42670: PPUSH
42671: LD_VAR 0 2
42675: PUSH
42676: LD_VAR 0 4
42680: ARRAY
42681: PUSH
42682: LD_INT 2
42684: ARRAY
42685: PPUSH
42686: CALL_OW 297
42690: PUSH
42691: LD_VAR 0 5
42695: LESS
42696: IFFALSE 42759
// begin hex := hexes [ i ] ;
42698: LD_ADDR_VAR 0 7
42702: PUSH
42703: LD_VAR 0 2
42707: PUSH
42708: LD_VAR 0 4
42712: ARRAY
42713: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
42714: LD_ADDR_VAR 0 5
42718: PUSH
42719: LD_VAR 0 1
42723: PPUSH
42724: LD_VAR 0 2
42728: PUSH
42729: LD_VAR 0 4
42733: ARRAY
42734: PUSH
42735: LD_INT 1
42737: ARRAY
42738: PPUSH
42739: LD_VAR 0 2
42743: PUSH
42744: LD_VAR 0 4
42748: ARRAY
42749: PUSH
42750: LD_INT 2
42752: ARRAY
42753: PPUSH
42754: CALL_OW 297
42758: ST_TO_ADDR
// end ; end ;
42759: GO 42648
42761: POP
42762: POP
// result := hex ;
42763: LD_ADDR_VAR 0 3
42767: PUSH
42768: LD_VAR 0 7
42772: ST_TO_ADDR
// end ;
42773: LD_VAR 0 3
42777: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
42778: LD_INT 0
42780: PPUSH
42781: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
42782: LD_VAR 0 1
42786: NOT
42787: PUSH
42788: LD_VAR 0 1
42792: PUSH
42793: LD_INT 21
42795: PUSH
42796: LD_INT 2
42798: PUSH
42799: EMPTY
42800: LIST
42801: LIST
42802: PUSH
42803: LD_INT 23
42805: PUSH
42806: LD_INT 2
42808: PUSH
42809: EMPTY
42810: LIST
42811: LIST
42812: PUSH
42813: EMPTY
42814: LIST
42815: LIST
42816: PPUSH
42817: CALL_OW 69
42821: IN
42822: NOT
42823: OR
42824: IFFALSE 42828
// exit ;
42826: GO 42875
// for i = 1 to 3 do
42828: LD_ADDR_VAR 0 3
42832: PUSH
42833: DOUBLE
42834: LD_INT 1
42836: DEC
42837: ST_TO_ADDR
42838: LD_INT 3
42840: PUSH
42841: FOR_TO
42842: IFFALSE 42873
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
42844: LD_VAR 0 1
42848: PPUSH
42849: CALL_OW 250
42853: PPUSH
42854: LD_VAR 0 1
42858: PPUSH
42859: CALL_OW 251
42863: PPUSH
42864: LD_INT 1
42866: PPUSH
42867: CALL_OW 453
42871: GO 42841
42873: POP
42874: POP
// end ;
42875: LD_VAR 0 2
42879: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
42880: LD_INT 0
42882: PPUSH
42883: PPUSH
42884: PPUSH
42885: PPUSH
42886: PPUSH
42887: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
42888: LD_VAR 0 1
42892: NOT
42893: PUSH
42894: LD_VAR 0 2
42898: NOT
42899: OR
42900: PUSH
42901: LD_VAR 0 1
42905: PPUSH
42906: CALL_OW 314
42910: OR
42911: IFFALSE 42915
// exit ;
42913: GO 43356
// x := GetX ( enemy_unit ) ;
42915: LD_ADDR_VAR 0 7
42919: PUSH
42920: LD_VAR 0 2
42924: PPUSH
42925: CALL_OW 250
42929: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
42930: LD_ADDR_VAR 0 8
42934: PUSH
42935: LD_VAR 0 2
42939: PPUSH
42940: CALL_OW 251
42944: ST_TO_ADDR
// if not x or not y then
42945: LD_VAR 0 7
42949: NOT
42950: PUSH
42951: LD_VAR 0 8
42955: NOT
42956: OR
42957: IFFALSE 42961
// exit ;
42959: GO 43356
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
42961: LD_ADDR_VAR 0 6
42965: PUSH
42966: LD_VAR 0 7
42970: PPUSH
42971: LD_INT 0
42973: PPUSH
42974: LD_INT 4
42976: PPUSH
42977: CALL_OW 272
42981: PUSH
42982: LD_VAR 0 8
42986: PPUSH
42987: LD_INT 0
42989: PPUSH
42990: LD_INT 4
42992: PPUSH
42993: CALL_OW 273
42997: PUSH
42998: EMPTY
42999: LIST
43000: LIST
43001: PUSH
43002: LD_VAR 0 7
43006: PPUSH
43007: LD_INT 1
43009: PPUSH
43010: LD_INT 4
43012: PPUSH
43013: CALL_OW 272
43017: PUSH
43018: LD_VAR 0 8
43022: PPUSH
43023: LD_INT 1
43025: PPUSH
43026: LD_INT 4
43028: PPUSH
43029: CALL_OW 273
43033: PUSH
43034: EMPTY
43035: LIST
43036: LIST
43037: PUSH
43038: LD_VAR 0 7
43042: PPUSH
43043: LD_INT 2
43045: PPUSH
43046: LD_INT 4
43048: PPUSH
43049: CALL_OW 272
43053: PUSH
43054: LD_VAR 0 8
43058: PPUSH
43059: LD_INT 2
43061: PPUSH
43062: LD_INT 4
43064: PPUSH
43065: CALL_OW 273
43069: PUSH
43070: EMPTY
43071: LIST
43072: LIST
43073: PUSH
43074: LD_VAR 0 7
43078: PPUSH
43079: LD_INT 3
43081: PPUSH
43082: LD_INT 4
43084: PPUSH
43085: CALL_OW 272
43089: PUSH
43090: LD_VAR 0 8
43094: PPUSH
43095: LD_INT 3
43097: PPUSH
43098: LD_INT 4
43100: PPUSH
43101: CALL_OW 273
43105: PUSH
43106: EMPTY
43107: LIST
43108: LIST
43109: PUSH
43110: LD_VAR 0 7
43114: PPUSH
43115: LD_INT 4
43117: PPUSH
43118: LD_INT 4
43120: PPUSH
43121: CALL_OW 272
43125: PUSH
43126: LD_VAR 0 8
43130: PPUSH
43131: LD_INT 4
43133: PPUSH
43134: LD_INT 4
43136: PPUSH
43137: CALL_OW 273
43141: PUSH
43142: EMPTY
43143: LIST
43144: LIST
43145: PUSH
43146: LD_VAR 0 7
43150: PPUSH
43151: LD_INT 5
43153: PPUSH
43154: LD_INT 4
43156: PPUSH
43157: CALL_OW 272
43161: PUSH
43162: LD_VAR 0 8
43166: PPUSH
43167: LD_INT 5
43169: PPUSH
43170: LD_INT 4
43172: PPUSH
43173: CALL_OW 273
43177: PUSH
43178: EMPTY
43179: LIST
43180: LIST
43181: PUSH
43182: EMPTY
43183: LIST
43184: LIST
43185: LIST
43186: LIST
43187: LIST
43188: LIST
43189: ST_TO_ADDR
// for i = tmp downto 1 do
43190: LD_ADDR_VAR 0 4
43194: PUSH
43195: DOUBLE
43196: LD_VAR 0 6
43200: INC
43201: ST_TO_ADDR
43202: LD_INT 1
43204: PUSH
43205: FOR_DOWNTO
43206: IFFALSE 43307
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
43208: LD_VAR 0 6
43212: PUSH
43213: LD_VAR 0 4
43217: ARRAY
43218: PUSH
43219: LD_INT 1
43221: ARRAY
43222: PPUSH
43223: LD_VAR 0 6
43227: PUSH
43228: LD_VAR 0 4
43232: ARRAY
43233: PUSH
43234: LD_INT 2
43236: ARRAY
43237: PPUSH
43238: CALL_OW 488
43242: NOT
43243: PUSH
43244: LD_VAR 0 6
43248: PUSH
43249: LD_VAR 0 4
43253: ARRAY
43254: PUSH
43255: LD_INT 1
43257: ARRAY
43258: PPUSH
43259: LD_VAR 0 6
43263: PUSH
43264: LD_VAR 0 4
43268: ARRAY
43269: PUSH
43270: LD_INT 2
43272: ARRAY
43273: PPUSH
43274: CALL_OW 428
43278: PUSH
43279: LD_INT 0
43281: NONEQUAL
43282: OR
43283: IFFALSE 43305
// tmp := Delete ( tmp , i ) ;
43285: LD_ADDR_VAR 0 6
43289: PUSH
43290: LD_VAR 0 6
43294: PPUSH
43295: LD_VAR 0 4
43299: PPUSH
43300: CALL_OW 3
43304: ST_TO_ADDR
43305: GO 43205
43307: POP
43308: POP
// j := GetClosestHex ( unit , tmp ) ;
43309: LD_ADDR_VAR 0 5
43313: PUSH
43314: LD_VAR 0 1
43318: PPUSH
43319: LD_VAR 0 6
43323: PPUSH
43324: CALL 42609 0 2
43328: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
43329: LD_VAR 0 1
43333: PPUSH
43334: LD_VAR 0 5
43338: PUSH
43339: LD_INT 1
43341: ARRAY
43342: PPUSH
43343: LD_VAR 0 5
43347: PUSH
43348: LD_INT 2
43350: ARRAY
43351: PPUSH
43352: CALL_OW 111
// end ;
43356: LD_VAR 0 3
43360: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
43361: LD_INT 0
43363: PPUSH
43364: PPUSH
43365: PPUSH
// uc_side = 0 ;
43366: LD_ADDR_OWVAR 20
43370: PUSH
43371: LD_INT 0
43373: ST_TO_ADDR
// uc_nation = 0 ;
43374: LD_ADDR_OWVAR 21
43378: PUSH
43379: LD_INT 0
43381: ST_TO_ADDR
// InitHc_All ( ) ;
43382: CALL_OW 584
// InitVc ;
43386: CALL_OW 20
// if mastodonts then
43390: LD_VAR 0 6
43394: IFFALSE 43461
// for i = 1 to mastodonts do
43396: LD_ADDR_VAR 0 11
43400: PUSH
43401: DOUBLE
43402: LD_INT 1
43404: DEC
43405: ST_TO_ADDR
43406: LD_VAR 0 6
43410: PUSH
43411: FOR_TO
43412: IFFALSE 43459
// begin vc_chassis := 31 ;
43414: LD_ADDR_OWVAR 37
43418: PUSH
43419: LD_INT 31
43421: ST_TO_ADDR
// vc_control := control_rider ;
43422: LD_ADDR_OWVAR 38
43426: PUSH
43427: LD_INT 4
43429: ST_TO_ADDR
// animal := CreateVehicle ;
43430: LD_ADDR_VAR 0 12
43434: PUSH
43435: CALL_OW 45
43439: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
43440: LD_VAR 0 12
43444: PPUSH
43445: LD_VAR 0 8
43449: PPUSH
43450: LD_INT 0
43452: PPUSH
43453: CALL 45649 0 3
// end ;
43457: GO 43411
43459: POP
43460: POP
// if horses then
43461: LD_VAR 0 5
43465: IFFALSE 43532
// for i = 1 to horses do
43467: LD_ADDR_VAR 0 11
43471: PUSH
43472: DOUBLE
43473: LD_INT 1
43475: DEC
43476: ST_TO_ADDR
43477: LD_VAR 0 5
43481: PUSH
43482: FOR_TO
43483: IFFALSE 43530
// begin hc_class := 21 ;
43485: LD_ADDR_OWVAR 28
43489: PUSH
43490: LD_INT 21
43492: ST_TO_ADDR
// hc_gallery :=  ;
43493: LD_ADDR_OWVAR 33
43497: PUSH
43498: LD_STRING 
43500: ST_TO_ADDR
// animal := CreateHuman ;
43501: LD_ADDR_VAR 0 12
43505: PUSH
43506: CALL_OW 44
43510: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
43511: LD_VAR 0 12
43515: PPUSH
43516: LD_VAR 0 8
43520: PPUSH
43521: LD_INT 0
43523: PPUSH
43524: CALL 45649 0 3
// end ;
43528: GO 43482
43530: POP
43531: POP
// if birds then
43532: LD_VAR 0 1
43536: IFFALSE 43603
// for i = 1 to birds do
43538: LD_ADDR_VAR 0 11
43542: PUSH
43543: DOUBLE
43544: LD_INT 1
43546: DEC
43547: ST_TO_ADDR
43548: LD_VAR 0 1
43552: PUSH
43553: FOR_TO
43554: IFFALSE 43601
// begin hc_class = 18 ;
43556: LD_ADDR_OWVAR 28
43560: PUSH
43561: LD_INT 18
43563: ST_TO_ADDR
// hc_gallery =  ;
43564: LD_ADDR_OWVAR 33
43568: PUSH
43569: LD_STRING 
43571: ST_TO_ADDR
// animal := CreateHuman ;
43572: LD_ADDR_VAR 0 12
43576: PUSH
43577: CALL_OW 44
43581: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
43582: LD_VAR 0 12
43586: PPUSH
43587: LD_VAR 0 8
43591: PPUSH
43592: LD_INT 0
43594: PPUSH
43595: CALL 45649 0 3
// end ;
43599: GO 43553
43601: POP
43602: POP
// if tigers then
43603: LD_VAR 0 2
43607: IFFALSE 43691
// for i = 1 to tigers do
43609: LD_ADDR_VAR 0 11
43613: PUSH
43614: DOUBLE
43615: LD_INT 1
43617: DEC
43618: ST_TO_ADDR
43619: LD_VAR 0 2
43623: PUSH
43624: FOR_TO
43625: IFFALSE 43689
// begin hc_class = class_tiger ;
43627: LD_ADDR_OWVAR 28
43631: PUSH
43632: LD_INT 14
43634: ST_TO_ADDR
// hc_gallery =  ;
43635: LD_ADDR_OWVAR 33
43639: PUSH
43640: LD_STRING 
43642: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
43643: LD_ADDR_OWVAR 35
43647: PUSH
43648: LD_INT 7
43650: NEG
43651: PPUSH
43652: LD_INT 7
43654: PPUSH
43655: CALL_OW 12
43659: ST_TO_ADDR
// animal := CreateHuman ;
43660: LD_ADDR_VAR 0 12
43664: PUSH
43665: CALL_OW 44
43669: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
43670: LD_VAR 0 12
43674: PPUSH
43675: LD_VAR 0 8
43679: PPUSH
43680: LD_INT 0
43682: PPUSH
43683: CALL 45649 0 3
// end ;
43687: GO 43624
43689: POP
43690: POP
// if apemans then
43691: LD_VAR 0 3
43695: IFFALSE 43818
// for i = 1 to apemans do
43697: LD_ADDR_VAR 0 11
43701: PUSH
43702: DOUBLE
43703: LD_INT 1
43705: DEC
43706: ST_TO_ADDR
43707: LD_VAR 0 3
43711: PUSH
43712: FOR_TO
43713: IFFALSE 43816
// begin hc_class = class_apeman ;
43715: LD_ADDR_OWVAR 28
43719: PUSH
43720: LD_INT 12
43722: ST_TO_ADDR
// hc_gallery =  ;
43723: LD_ADDR_OWVAR 33
43727: PUSH
43728: LD_STRING 
43730: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
43731: LD_ADDR_OWVAR 35
43735: PUSH
43736: LD_INT 2
43738: NEG
43739: PPUSH
43740: LD_INT 2
43742: PPUSH
43743: CALL_OW 12
43747: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
43748: LD_ADDR_OWVAR 31
43752: PUSH
43753: LD_INT 1
43755: PPUSH
43756: LD_INT 3
43758: PPUSH
43759: CALL_OW 12
43763: PUSH
43764: LD_INT 1
43766: PPUSH
43767: LD_INT 3
43769: PPUSH
43770: CALL_OW 12
43774: PUSH
43775: LD_INT 0
43777: PUSH
43778: LD_INT 0
43780: PUSH
43781: EMPTY
43782: LIST
43783: LIST
43784: LIST
43785: LIST
43786: ST_TO_ADDR
// animal := CreateHuman ;
43787: LD_ADDR_VAR 0 12
43791: PUSH
43792: CALL_OW 44
43796: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
43797: LD_VAR 0 12
43801: PPUSH
43802: LD_VAR 0 8
43806: PPUSH
43807: LD_INT 0
43809: PPUSH
43810: CALL 45649 0 3
// end ;
43814: GO 43712
43816: POP
43817: POP
// if enchidnas then
43818: LD_VAR 0 4
43822: IFFALSE 43889
// for i = 1 to enchidnas do
43824: LD_ADDR_VAR 0 11
43828: PUSH
43829: DOUBLE
43830: LD_INT 1
43832: DEC
43833: ST_TO_ADDR
43834: LD_VAR 0 4
43838: PUSH
43839: FOR_TO
43840: IFFALSE 43887
// begin hc_class = 13 ;
43842: LD_ADDR_OWVAR 28
43846: PUSH
43847: LD_INT 13
43849: ST_TO_ADDR
// hc_gallery =  ;
43850: LD_ADDR_OWVAR 33
43854: PUSH
43855: LD_STRING 
43857: ST_TO_ADDR
// animal := CreateHuman ;
43858: LD_ADDR_VAR 0 12
43862: PUSH
43863: CALL_OW 44
43867: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
43868: LD_VAR 0 12
43872: PPUSH
43873: LD_VAR 0 8
43877: PPUSH
43878: LD_INT 0
43880: PPUSH
43881: CALL 45649 0 3
// end ;
43885: GO 43839
43887: POP
43888: POP
// if fishes then
43889: LD_VAR 0 7
43893: IFFALSE 43960
// for i = 1 to fishes do
43895: LD_ADDR_VAR 0 11
43899: PUSH
43900: DOUBLE
43901: LD_INT 1
43903: DEC
43904: ST_TO_ADDR
43905: LD_VAR 0 7
43909: PUSH
43910: FOR_TO
43911: IFFALSE 43958
// begin hc_class = 20 ;
43913: LD_ADDR_OWVAR 28
43917: PUSH
43918: LD_INT 20
43920: ST_TO_ADDR
// hc_gallery =  ;
43921: LD_ADDR_OWVAR 33
43925: PUSH
43926: LD_STRING 
43928: ST_TO_ADDR
// animal := CreateHuman ;
43929: LD_ADDR_VAR 0 12
43933: PUSH
43934: CALL_OW 44
43938: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
43939: LD_VAR 0 12
43943: PPUSH
43944: LD_VAR 0 9
43948: PPUSH
43949: LD_INT 0
43951: PPUSH
43952: CALL 45649 0 3
// end ;
43956: GO 43910
43958: POP
43959: POP
// end ;
43960: LD_VAR 0 10
43964: RET
// export function WantHeal ( sci , unit ) ; begin
43965: LD_INT 0
43967: PPUSH
// if GetTaskList ( sci ) > 0 then
43968: LD_VAR 0 1
43972: PPUSH
43973: CALL_OW 437
43977: PUSH
43978: LD_INT 0
43980: GREATER
43981: IFFALSE 44051
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
43983: LD_VAR 0 1
43987: PPUSH
43988: CALL_OW 437
43992: PUSH
43993: LD_INT 1
43995: ARRAY
43996: PUSH
43997: LD_INT 1
43999: ARRAY
44000: PUSH
44001: LD_STRING l
44003: EQUAL
44004: PUSH
44005: LD_VAR 0 1
44009: PPUSH
44010: CALL_OW 437
44014: PUSH
44015: LD_INT 1
44017: ARRAY
44018: PUSH
44019: LD_INT 4
44021: ARRAY
44022: PUSH
44023: LD_VAR 0 2
44027: EQUAL
44028: AND
44029: IFFALSE 44041
// result := true else
44031: LD_ADDR_VAR 0 3
44035: PUSH
44036: LD_INT 1
44038: ST_TO_ADDR
44039: GO 44049
// result := false ;
44041: LD_ADDR_VAR 0 3
44045: PUSH
44046: LD_INT 0
44048: ST_TO_ADDR
// end else
44049: GO 44059
// result := false ;
44051: LD_ADDR_VAR 0 3
44055: PUSH
44056: LD_INT 0
44058: ST_TO_ADDR
// end ;
44059: LD_VAR 0 3
44063: RET
// export function HealTarget ( sci ) ; begin
44064: LD_INT 0
44066: PPUSH
// if not sci then
44067: LD_VAR 0 1
44071: NOT
44072: IFFALSE 44076
// exit ;
44074: GO 44141
// result := 0 ;
44076: LD_ADDR_VAR 0 2
44080: PUSH
44081: LD_INT 0
44083: ST_TO_ADDR
// if GetTaskList ( sci ) then
44084: LD_VAR 0 1
44088: PPUSH
44089: CALL_OW 437
44093: IFFALSE 44141
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
44095: LD_VAR 0 1
44099: PPUSH
44100: CALL_OW 437
44104: PUSH
44105: LD_INT 1
44107: ARRAY
44108: PUSH
44109: LD_INT 1
44111: ARRAY
44112: PUSH
44113: LD_STRING l
44115: EQUAL
44116: IFFALSE 44141
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
44118: LD_ADDR_VAR 0 2
44122: PUSH
44123: LD_VAR 0 1
44127: PPUSH
44128: CALL_OW 437
44132: PUSH
44133: LD_INT 1
44135: ARRAY
44136: PUSH
44137: LD_INT 4
44139: ARRAY
44140: ST_TO_ADDR
// end ;
44141: LD_VAR 0 2
44145: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
44146: LD_INT 0
44148: PPUSH
44149: PPUSH
44150: PPUSH
44151: PPUSH
// if not base_units then
44152: LD_VAR 0 1
44156: NOT
44157: IFFALSE 44161
// exit ;
44159: GO 44248
// result := false ;
44161: LD_ADDR_VAR 0 2
44165: PUSH
44166: LD_INT 0
44168: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
44169: LD_ADDR_VAR 0 5
44173: PUSH
44174: LD_VAR 0 1
44178: PPUSH
44179: LD_INT 21
44181: PUSH
44182: LD_INT 3
44184: PUSH
44185: EMPTY
44186: LIST
44187: LIST
44188: PPUSH
44189: CALL_OW 72
44193: ST_TO_ADDR
// if not tmp then
44194: LD_VAR 0 5
44198: NOT
44199: IFFALSE 44203
// exit ;
44201: GO 44248
// for i in tmp do
44203: LD_ADDR_VAR 0 3
44207: PUSH
44208: LD_VAR 0 5
44212: PUSH
44213: FOR_IN
44214: IFFALSE 44246
// begin result := EnemyInRange ( i , 22 ) ;
44216: LD_ADDR_VAR 0 2
44220: PUSH
44221: LD_VAR 0 3
44225: PPUSH
44226: LD_INT 22
44228: PPUSH
44229: CALL 42484 0 2
44233: ST_TO_ADDR
// if result then
44234: LD_VAR 0 2
44238: IFFALSE 44244
// exit ;
44240: POP
44241: POP
44242: GO 44248
// end ;
44244: GO 44213
44246: POP
44247: POP
// end ;
44248: LD_VAR 0 2
44252: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
44253: LD_INT 0
44255: PPUSH
44256: PPUSH
// if not units then
44257: LD_VAR 0 1
44261: NOT
44262: IFFALSE 44266
// exit ;
44264: GO 44336
// result := [ ] ;
44266: LD_ADDR_VAR 0 3
44270: PUSH
44271: EMPTY
44272: ST_TO_ADDR
// for i in units do
44273: LD_ADDR_VAR 0 4
44277: PUSH
44278: LD_VAR 0 1
44282: PUSH
44283: FOR_IN
44284: IFFALSE 44334
// if GetTag ( i ) = tag then
44286: LD_VAR 0 4
44290: PPUSH
44291: CALL_OW 110
44295: PUSH
44296: LD_VAR 0 2
44300: EQUAL
44301: IFFALSE 44332
// result := Insert ( result , result + 1 , i ) ;
44303: LD_ADDR_VAR 0 3
44307: PUSH
44308: LD_VAR 0 3
44312: PPUSH
44313: LD_VAR 0 3
44317: PUSH
44318: LD_INT 1
44320: PLUS
44321: PPUSH
44322: LD_VAR 0 4
44326: PPUSH
44327: CALL_OW 2
44331: ST_TO_ADDR
44332: GO 44283
44334: POP
44335: POP
// end ;
44336: LD_VAR 0 3
44340: RET
// export function IsDriver ( un ) ; begin
44341: LD_INT 0
44343: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
44344: LD_ADDR_VAR 0 2
44348: PUSH
44349: LD_VAR 0 1
44353: PUSH
44354: LD_INT 55
44356: PUSH
44357: EMPTY
44358: LIST
44359: PPUSH
44360: CALL_OW 69
44364: IN
44365: ST_TO_ADDR
// end ;
44366: LD_VAR 0 2
44370: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
44371: LD_INT 0
44373: PPUSH
44374: PPUSH
// list := [ ] ;
44375: LD_ADDR_VAR 0 5
44379: PUSH
44380: EMPTY
44381: ST_TO_ADDR
// case d of 0 :
44382: LD_VAR 0 3
44386: PUSH
44387: LD_INT 0
44389: DOUBLE
44390: EQUAL
44391: IFTRUE 44395
44393: GO 44528
44395: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
44396: LD_ADDR_VAR 0 5
44400: PUSH
44401: LD_VAR 0 1
44405: PUSH
44406: LD_INT 4
44408: MINUS
44409: PUSH
44410: LD_VAR 0 2
44414: PUSH
44415: LD_INT 4
44417: MINUS
44418: PUSH
44419: LD_INT 2
44421: PUSH
44422: EMPTY
44423: LIST
44424: LIST
44425: LIST
44426: PUSH
44427: LD_VAR 0 1
44431: PUSH
44432: LD_INT 3
44434: MINUS
44435: PUSH
44436: LD_VAR 0 2
44440: PUSH
44441: LD_INT 1
44443: PUSH
44444: EMPTY
44445: LIST
44446: LIST
44447: LIST
44448: PUSH
44449: LD_VAR 0 1
44453: PUSH
44454: LD_INT 4
44456: PLUS
44457: PUSH
44458: LD_VAR 0 2
44462: PUSH
44463: LD_INT 4
44465: PUSH
44466: EMPTY
44467: LIST
44468: LIST
44469: LIST
44470: PUSH
44471: LD_VAR 0 1
44475: PUSH
44476: LD_INT 3
44478: PLUS
44479: PUSH
44480: LD_VAR 0 2
44484: PUSH
44485: LD_INT 3
44487: PLUS
44488: PUSH
44489: LD_INT 5
44491: PUSH
44492: EMPTY
44493: LIST
44494: LIST
44495: LIST
44496: PUSH
44497: LD_VAR 0 1
44501: PUSH
44502: LD_VAR 0 2
44506: PUSH
44507: LD_INT 4
44509: PLUS
44510: PUSH
44511: LD_INT 0
44513: PUSH
44514: EMPTY
44515: LIST
44516: LIST
44517: LIST
44518: PUSH
44519: EMPTY
44520: LIST
44521: LIST
44522: LIST
44523: LIST
44524: LIST
44525: ST_TO_ADDR
// end ; 1 :
44526: GO 45226
44528: LD_INT 1
44530: DOUBLE
44531: EQUAL
44532: IFTRUE 44536
44534: GO 44669
44536: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
44537: LD_ADDR_VAR 0 5
44541: PUSH
44542: LD_VAR 0 1
44546: PUSH
44547: LD_VAR 0 2
44551: PUSH
44552: LD_INT 4
44554: MINUS
44555: PUSH
44556: LD_INT 3
44558: PUSH
44559: EMPTY
44560: LIST
44561: LIST
44562: LIST
44563: PUSH
44564: LD_VAR 0 1
44568: PUSH
44569: LD_INT 3
44571: MINUS
44572: PUSH
44573: LD_VAR 0 2
44577: PUSH
44578: LD_INT 3
44580: MINUS
44581: PUSH
44582: LD_INT 2
44584: PUSH
44585: EMPTY
44586: LIST
44587: LIST
44588: LIST
44589: PUSH
44590: LD_VAR 0 1
44594: PUSH
44595: LD_INT 4
44597: MINUS
44598: PUSH
44599: LD_VAR 0 2
44603: PUSH
44604: LD_INT 1
44606: PUSH
44607: EMPTY
44608: LIST
44609: LIST
44610: LIST
44611: PUSH
44612: LD_VAR 0 1
44616: PUSH
44617: LD_VAR 0 2
44621: PUSH
44622: LD_INT 3
44624: PLUS
44625: PUSH
44626: LD_INT 0
44628: PUSH
44629: EMPTY
44630: LIST
44631: LIST
44632: LIST
44633: PUSH
44634: LD_VAR 0 1
44638: PUSH
44639: LD_INT 4
44641: PLUS
44642: PUSH
44643: LD_VAR 0 2
44647: PUSH
44648: LD_INT 4
44650: PLUS
44651: PUSH
44652: LD_INT 5
44654: PUSH
44655: EMPTY
44656: LIST
44657: LIST
44658: LIST
44659: PUSH
44660: EMPTY
44661: LIST
44662: LIST
44663: LIST
44664: LIST
44665: LIST
44666: ST_TO_ADDR
// end ; 2 :
44667: GO 45226
44669: LD_INT 2
44671: DOUBLE
44672: EQUAL
44673: IFTRUE 44677
44675: GO 44806
44677: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
44678: LD_ADDR_VAR 0 5
44682: PUSH
44683: LD_VAR 0 1
44687: PUSH
44688: LD_VAR 0 2
44692: PUSH
44693: LD_INT 3
44695: MINUS
44696: PUSH
44697: LD_INT 3
44699: PUSH
44700: EMPTY
44701: LIST
44702: LIST
44703: LIST
44704: PUSH
44705: LD_VAR 0 1
44709: PUSH
44710: LD_INT 4
44712: PLUS
44713: PUSH
44714: LD_VAR 0 2
44718: PUSH
44719: LD_INT 4
44721: PUSH
44722: EMPTY
44723: LIST
44724: LIST
44725: LIST
44726: PUSH
44727: LD_VAR 0 1
44731: PUSH
44732: LD_VAR 0 2
44736: PUSH
44737: LD_INT 4
44739: PLUS
44740: PUSH
44741: LD_INT 0
44743: PUSH
44744: EMPTY
44745: LIST
44746: LIST
44747: LIST
44748: PUSH
44749: LD_VAR 0 1
44753: PUSH
44754: LD_INT 3
44756: MINUS
44757: PUSH
44758: LD_VAR 0 2
44762: PUSH
44763: LD_INT 1
44765: PUSH
44766: EMPTY
44767: LIST
44768: LIST
44769: LIST
44770: PUSH
44771: LD_VAR 0 1
44775: PUSH
44776: LD_INT 4
44778: MINUS
44779: PUSH
44780: LD_VAR 0 2
44784: PUSH
44785: LD_INT 4
44787: MINUS
44788: PUSH
44789: LD_INT 2
44791: PUSH
44792: EMPTY
44793: LIST
44794: LIST
44795: LIST
44796: PUSH
44797: EMPTY
44798: LIST
44799: LIST
44800: LIST
44801: LIST
44802: LIST
44803: ST_TO_ADDR
// end ; 3 :
44804: GO 45226
44806: LD_INT 3
44808: DOUBLE
44809: EQUAL
44810: IFTRUE 44814
44812: GO 44947
44814: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
44815: LD_ADDR_VAR 0 5
44819: PUSH
44820: LD_VAR 0 1
44824: PUSH
44825: LD_INT 3
44827: PLUS
44828: PUSH
44829: LD_VAR 0 2
44833: PUSH
44834: LD_INT 4
44836: PUSH
44837: EMPTY
44838: LIST
44839: LIST
44840: LIST
44841: PUSH
44842: LD_VAR 0 1
44846: PUSH
44847: LD_INT 4
44849: PLUS
44850: PUSH
44851: LD_VAR 0 2
44855: PUSH
44856: LD_INT 4
44858: PLUS
44859: PUSH
44860: LD_INT 5
44862: PUSH
44863: EMPTY
44864: LIST
44865: LIST
44866: LIST
44867: PUSH
44868: LD_VAR 0 1
44872: PUSH
44873: LD_INT 4
44875: MINUS
44876: PUSH
44877: LD_VAR 0 2
44881: PUSH
44882: LD_INT 1
44884: PUSH
44885: EMPTY
44886: LIST
44887: LIST
44888: LIST
44889: PUSH
44890: LD_VAR 0 1
44894: PUSH
44895: LD_VAR 0 2
44899: PUSH
44900: LD_INT 4
44902: MINUS
44903: PUSH
44904: LD_INT 3
44906: PUSH
44907: EMPTY
44908: LIST
44909: LIST
44910: LIST
44911: PUSH
44912: LD_VAR 0 1
44916: PUSH
44917: LD_INT 3
44919: MINUS
44920: PUSH
44921: LD_VAR 0 2
44925: PUSH
44926: LD_INT 3
44928: MINUS
44929: PUSH
44930: LD_INT 2
44932: PUSH
44933: EMPTY
44934: LIST
44935: LIST
44936: LIST
44937: PUSH
44938: EMPTY
44939: LIST
44940: LIST
44941: LIST
44942: LIST
44943: LIST
44944: ST_TO_ADDR
// end ; 4 :
44945: GO 45226
44947: LD_INT 4
44949: DOUBLE
44950: EQUAL
44951: IFTRUE 44955
44953: GO 45088
44955: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
44956: LD_ADDR_VAR 0 5
44960: PUSH
44961: LD_VAR 0 1
44965: PUSH
44966: LD_VAR 0 2
44970: PUSH
44971: LD_INT 4
44973: PLUS
44974: PUSH
44975: LD_INT 0
44977: PUSH
44978: EMPTY
44979: LIST
44980: LIST
44981: LIST
44982: PUSH
44983: LD_VAR 0 1
44987: PUSH
44988: LD_INT 3
44990: PLUS
44991: PUSH
44992: LD_VAR 0 2
44996: PUSH
44997: LD_INT 3
44999: PLUS
45000: PUSH
45001: LD_INT 5
45003: PUSH
45004: EMPTY
45005: LIST
45006: LIST
45007: LIST
45008: PUSH
45009: LD_VAR 0 1
45013: PUSH
45014: LD_INT 4
45016: PLUS
45017: PUSH
45018: LD_VAR 0 2
45022: PUSH
45023: LD_INT 4
45025: PUSH
45026: EMPTY
45027: LIST
45028: LIST
45029: LIST
45030: PUSH
45031: LD_VAR 0 1
45035: PUSH
45036: LD_VAR 0 2
45040: PUSH
45041: LD_INT 3
45043: MINUS
45044: PUSH
45045: LD_INT 3
45047: PUSH
45048: EMPTY
45049: LIST
45050: LIST
45051: LIST
45052: PUSH
45053: LD_VAR 0 1
45057: PUSH
45058: LD_INT 4
45060: MINUS
45061: PUSH
45062: LD_VAR 0 2
45066: PUSH
45067: LD_INT 4
45069: MINUS
45070: PUSH
45071: LD_INT 2
45073: PUSH
45074: EMPTY
45075: LIST
45076: LIST
45077: LIST
45078: PUSH
45079: EMPTY
45080: LIST
45081: LIST
45082: LIST
45083: LIST
45084: LIST
45085: ST_TO_ADDR
// end ; 5 :
45086: GO 45226
45088: LD_INT 5
45090: DOUBLE
45091: EQUAL
45092: IFTRUE 45096
45094: GO 45225
45096: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
45097: LD_ADDR_VAR 0 5
45101: PUSH
45102: LD_VAR 0 1
45106: PUSH
45107: LD_INT 4
45109: MINUS
45110: PUSH
45111: LD_VAR 0 2
45115: PUSH
45116: LD_INT 1
45118: PUSH
45119: EMPTY
45120: LIST
45121: LIST
45122: LIST
45123: PUSH
45124: LD_VAR 0 1
45128: PUSH
45129: LD_VAR 0 2
45133: PUSH
45134: LD_INT 4
45136: MINUS
45137: PUSH
45138: LD_INT 3
45140: PUSH
45141: EMPTY
45142: LIST
45143: LIST
45144: LIST
45145: PUSH
45146: LD_VAR 0 1
45150: PUSH
45151: LD_INT 4
45153: PLUS
45154: PUSH
45155: LD_VAR 0 2
45159: PUSH
45160: LD_INT 4
45162: PLUS
45163: PUSH
45164: LD_INT 5
45166: PUSH
45167: EMPTY
45168: LIST
45169: LIST
45170: LIST
45171: PUSH
45172: LD_VAR 0 1
45176: PUSH
45177: LD_INT 3
45179: PLUS
45180: PUSH
45181: LD_VAR 0 2
45185: PUSH
45186: LD_INT 4
45188: PUSH
45189: EMPTY
45190: LIST
45191: LIST
45192: LIST
45193: PUSH
45194: LD_VAR 0 1
45198: PUSH
45199: LD_VAR 0 2
45203: PUSH
45204: LD_INT 3
45206: PLUS
45207: PUSH
45208: LD_INT 0
45210: PUSH
45211: EMPTY
45212: LIST
45213: LIST
45214: LIST
45215: PUSH
45216: EMPTY
45217: LIST
45218: LIST
45219: LIST
45220: LIST
45221: LIST
45222: ST_TO_ADDR
// end ; end ;
45223: GO 45226
45225: POP
// result := list ;
45226: LD_ADDR_VAR 0 4
45230: PUSH
45231: LD_VAR 0 5
45235: ST_TO_ADDR
// end ;
45236: LD_VAR 0 4
45240: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
45241: LD_INT 0
45243: PPUSH
45244: PPUSH
45245: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
45246: LD_VAR 0 1
45250: NOT
45251: PUSH
45252: LD_VAR 0 2
45256: PUSH
45257: LD_INT 1
45259: PUSH
45260: LD_INT 2
45262: PUSH
45263: LD_INT 3
45265: PUSH
45266: LD_INT 4
45268: PUSH
45269: EMPTY
45270: LIST
45271: LIST
45272: LIST
45273: LIST
45274: IN
45275: NOT
45276: OR
45277: IFFALSE 45281
// exit ;
45279: GO 45373
// tmp := [ ] ;
45281: LD_ADDR_VAR 0 5
45285: PUSH
45286: EMPTY
45287: ST_TO_ADDR
// for i in units do
45288: LD_ADDR_VAR 0 4
45292: PUSH
45293: LD_VAR 0 1
45297: PUSH
45298: FOR_IN
45299: IFFALSE 45342
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
45301: LD_ADDR_VAR 0 5
45305: PUSH
45306: LD_VAR 0 5
45310: PPUSH
45311: LD_VAR 0 5
45315: PUSH
45316: LD_INT 1
45318: PLUS
45319: PPUSH
45320: LD_VAR 0 4
45324: PPUSH
45325: LD_VAR 0 2
45329: PPUSH
45330: CALL_OW 259
45334: PPUSH
45335: CALL_OW 2
45339: ST_TO_ADDR
45340: GO 45298
45342: POP
45343: POP
// if not tmp then
45344: LD_VAR 0 5
45348: NOT
45349: IFFALSE 45353
// exit ;
45351: GO 45373
// result := SortListByListDesc ( units , tmp ) ;
45353: LD_ADDR_VAR 0 3
45357: PUSH
45358: LD_VAR 0 1
45362: PPUSH
45363: LD_VAR 0 5
45367: PPUSH
45368: CALL_OW 77
45372: ST_TO_ADDR
// end ;
45373: LD_VAR 0 3
45377: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
45378: LD_INT 0
45380: PPUSH
45381: PPUSH
45382: PPUSH
// result := false ;
45383: LD_ADDR_VAR 0 3
45387: PUSH
45388: LD_INT 0
45390: ST_TO_ADDR
// x := GetX ( building ) ;
45391: LD_ADDR_VAR 0 4
45395: PUSH
45396: LD_VAR 0 2
45400: PPUSH
45401: CALL_OW 250
45405: ST_TO_ADDR
// y := GetY ( building ) ;
45406: LD_ADDR_VAR 0 5
45410: PUSH
45411: LD_VAR 0 2
45415: PPUSH
45416: CALL_OW 251
45420: ST_TO_ADDR
// if not building or not x or not y then
45421: LD_VAR 0 2
45425: NOT
45426: PUSH
45427: LD_VAR 0 4
45431: NOT
45432: OR
45433: PUSH
45434: LD_VAR 0 5
45438: NOT
45439: OR
45440: IFFALSE 45444
// exit ;
45442: GO 45536
// if GetTaskList ( unit ) then
45444: LD_VAR 0 1
45448: PPUSH
45449: CALL_OW 437
45453: IFFALSE 45536
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
45455: LD_STRING e
45457: PUSH
45458: LD_VAR 0 1
45462: PPUSH
45463: CALL_OW 437
45467: PUSH
45468: LD_INT 1
45470: ARRAY
45471: PUSH
45472: LD_INT 1
45474: ARRAY
45475: EQUAL
45476: PUSH
45477: LD_VAR 0 4
45481: PUSH
45482: LD_VAR 0 1
45486: PPUSH
45487: CALL_OW 437
45491: PUSH
45492: LD_INT 1
45494: ARRAY
45495: PUSH
45496: LD_INT 2
45498: ARRAY
45499: EQUAL
45500: AND
45501: PUSH
45502: LD_VAR 0 5
45506: PUSH
45507: LD_VAR 0 1
45511: PPUSH
45512: CALL_OW 437
45516: PUSH
45517: LD_INT 1
45519: ARRAY
45520: PUSH
45521: LD_INT 3
45523: ARRAY
45524: EQUAL
45525: AND
45526: IFFALSE 45536
// result := true end ;
45528: LD_ADDR_VAR 0 3
45532: PUSH
45533: LD_INT 1
45535: ST_TO_ADDR
// end ;
45536: LD_VAR 0 3
45540: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
45541: LD_INT 0
45543: PPUSH
// result := false ;
45544: LD_ADDR_VAR 0 4
45548: PUSH
45549: LD_INT 0
45551: ST_TO_ADDR
// if GetTaskList ( unit ) then
45552: LD_VAR 0 1
45556: PPUSH
45557: CALL_OW 437
45561: IFFALSE 45644
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
45563: LD_STRING M
45565: PUSH
45566: LD_VAR 0 1
45570: PPUSH
45571: CALL_OW 437
45575: PUSH
45576: LD_INT 1
45578: ARRAY
45579: PUSH
45580: LD_INT 1
45582: ARRAY
45583: EQUAL
45584: PUSH
45585: LD_VAR 0 2
45589: PUSH
45590: LD_VAR 0 1
45594: PPUSH
45595: CALL_OW 437
45599: PUSH
45600: LD_INT 1
45602: ARRAY
45603: PUSH
45604: LD_INT 2
45606: ARRAY
45607: EQUAL
45608: AND
45609: PUSH
45610: LD_VAR 0 3
45614: PUSH
45615: LD_VAR 0 1
45619: PPUSH
45620: CALL_OW 437
45624: PUSH
45625: LD_INT 1
45627: ARRAY
45628: PUSH
45629: LD_INT 3
45631: ARRAY
45632: EQUAL
45633: AND
45634: IFFALSE 45644
// result := true ;
45636: LD_ADDR_VAR 0 4
45640: PUSH
45641: LD_INT 1
45643: ST_TO_ADDR
// end ; end ;
45644: LD_VAR 0 4
45648: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
45649: LD_INT 0
45651: PPUSH
45652: PPUSH
45653: PPUSH
45654: PPUSH
// if not unit or not area then
45655: LD_VAR 0 1
45659: NOT
45660: PUSH
45661: LD_VAR 0 2
45665: NOT
45666: OR
45667: IFFALSE 45671
// exit ;
45669: GO 45835
// tmp := AreaToList ( area , i ) ;
45671: LD_ADDR_VAR 0 6
45675: PUSH
45676: LD_VAR 0 2
45680: PPUSH
45681: LD_VAR 0 5
45685: PPUSH
45686: CALL_OW 517
45690: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
45691: LD_ADDR_VAR 0 5
45695: PUSH
45696: DOUBLE
45697: LD_INT 1
45699: DEC
45700: ST_TO_ADDR
45701: LD_VAR 0 6
45705: PUSH
45706: LD_INT 1
45708: ARRAY
45709: PUSH
45710: FOR_TO
45711: IFFALSE 45833
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
45713: LD_ADDR_VAR 0 7
45717: PUSH
45718: LD_VAR 0 6
45722: PUSH
45723: LD_INT 1
45725: ARRAY
45726: PUSH
45727: LD_VAR 0 5
45731: ARRAY
45732: PUSH
45733: LD_VAR 0 6
45737: PUSH
45738: LD_INT 2
45740: ARRAY
45741: PUSH
45742: LD_VAR 0 5
45746: ARRAY
45747: PUSH
45748: EMPTY
45749: LIST
45750: LIST
45751: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
45752: LD_VAR 0 7
45756: PUSH
45757: LD_INT 1
45759: ARRAY
45760: PPUSH
45761: LD_VAR 0 7
45765: PUSH
45766: LD_INT 2
45768: ARRAY
45769: PPUSH
45770: CALL_OW 428
45774: PUSH
45775: LD_INT 0
45777: EQUAL
45778: IFFALSE 45831
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
45780: LD_VAR 0 1
45784: PPUSH
45785: LD_VAR 0 7
45789: PUSH
45790: LD_INT 1
45792: ARRAY
45793: PPUSH
45794: LD_VAR 0 7
45798: PUSH
45799: LD_INT 2
45801: ARRAY
45802: PPUSH
45803: LD_VAR 0 3
45807: PPUSH
45808: CALL_OW 48
// result := IsPlaced ( unit ) ;
45812: LD_ADDR_VAR 0 4
45816: PUSH
45817: LD_VAR 0 1
45821: PPUSH
45822: CALL_OW 305
45826: ST_TO_ADDR
// exit ;
45827: POP
45828: POP
45829: GO 45835
// end ; end ;
45831: GO 45710
45833: POP
45834: POP
// end ;
45835: LD_VAR 0 4
45839: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
45840: LD_INT 0
45842: PPUSH
45843: PPUSH
45844: PPUSH
// if not side or side > 8 then
45845: LD_VAR 0 1
45849: NOT
45850: PUSH
45851: LD_VAR 0 1
45855: PUSH
45856: LD_INT 8
45858: GREATER
45859: OR
45860: IFFALSE 45864
// exit ;
45862: GO 46051
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
45864: LD_ADDR_VAR 0 4
45868: PUSH
45869: LD_INT 22
45871: PUSH
45872: LD_VAR 0 1
45876: PUSH
45877: EMPTY
45878: LIST
45879: LIST
45880: PUSH
45881: LD_INT 21
45883: PUSH
45884: LD_INT 3
45886: PUSH
45887: EMPTY
45888: LIST
45889: LIST
45890: PUSH
45891: EMPTY
45892: LIST
45893: LIST
45894: PPUSH
45895: CALL_OW 69
45899: ST_TO_ADDR
// if not tmp then
45900: LD_VAR 0 4
45904: NOT
45905: IFFALSE 45909
// exit ;
45907: GO 46051
// enable_addtolog := true ;
45909: LD_ADDR_OWVAR 81
45913: PUSH
45914: LD_INT 1
45916: ST_TO_ADDR
// AddToLog ( [ ) ;
45917: LD_STRING [
45919: PPUSH
45920: CALL_OW 561
// for i in tmp do
45924: LD_ADDR_VAR 0 3
45928: PUSH
45929: LD_VAR 0 4
45933: PUSH
45934: FOR_IN
45935: IFFALSE 46042
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
45937: LD_STRING [
45939: PUSH
45940: LD_VAR 0 3
45944: PPUSH
45945: CALL_OW 266
45949: STR
45950: PUSH
45951: LD_STRING , 
45953: STR
45954: PUSH
45955: LD_VAR 0 3
45959: PPUSH
45960: CALL_OW 250
45964: STR
45965: PUSH
45966: LD_STRING , 
45968: STR
45969: PUSH
45970: LD_VAR 0 3
45974: PPUSH
45975: CALL_OW 251
45979: STR
45980: PUSH
45981: LD_STRING , 
45983: STR
45984: PUSH
45985: LD_VAR 0 3
45989: PPUSH
45990: CALL_OW 254
45994: STR
45995: PUSH
45996: LD_STRING , 
45998: STR
45999: PUSH
46000: LD_VAR 0 3
46004: PPUSH
46005: LD_INT 1
46007: PPUSH
46008: CALL_OW 268
46012: STR
46013: PUSH
46014: LD_STRING , 
46016: STR
46017: PUSH
46018: LD_VAR 0 3
46022: PPUSH
46023: LD_INT 2
46025: PPUSH
46026: CALL_OW 268
46030: STR
46031: PUSH
46032: LD_STRING ],
46034: STR
46035: PPUSH
46036: CALL_OW 561
// end ;
46040: GO 45934
46042: POP
46043: POP
// AddToLog ( ]; ) ;
46044: LD_STRING ];
46046: PPUSH
46047: CALL_OW 561
// end ;
46051: LD_VAR 0 2
46055: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
46056: LD_INT 0
46058: PPUSH
46059: PPUSH
46060: PPUSH
46061: PPUSH
46062: PPUSH
// if not area or not rate or not max then
46063: LD_VAR 0 1
46067: NOT
46068: PUSH
46069: LD_VAR 0 2
46073: NOT
46074: OR
46075: PUSH
46076: LD_VAR 0 4
46080: NOT
46081: OR
46082: IFFALSE 46086
// exit ;
46084: GO 46278
// while 1 do
46086: LD_INT 1
46088: IFFALSE 46278
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
46090: LD_ADDR_VAR 0 9
46094: PUSH
46095: LD_VAR 0 1
46099: PPUSH
46100: LD_INT 1
46102: PPUSH
46103: CALL_OW 287
46107: PUSH
46108: LD_INT 10
46110: MUL
46111: ST_TO_ADDR
// r := rate / 10 ;
46112: LD_ADDR_VAR 0 7
46116: PUSH
46117: LD_VAR 0 2
46121: PUSH
46122: LD_INT 10
46124: DIVREAL
46125: ST_TO_ADDR
// time := 1 1$00 ;
46126: LD_ADDR_VAR 0 8
46130: PUSH
46131: LD_INT 2100
46133: ST_TO_ADDR
// if amount < min then
46134: LD_VAR 0 9
46138: PUSH
46139: LD_VAR 0 3
46143: LESS
46144: IFFALSE 46162
// r := r * 2 else
46146: LD_ADDR_VAR 0 7
46150: PUSH
46151: LD_VAR 0 7
46155: PUSH
46156: LD_INT 2
46158: MUL
46159: ST_TO_ADDR
46160: GO 46188
// if amount > max then
46162: LD_VAR 0 9
46166: PUSH
46167: LD_VAR 0 4
46171: GREATER
46172: IFFALSE 46188
// r := r / 2 ;
46174: LD_ADDR_VAR 0 7
46178: PUSH
46179: LD_VAR 0 7
46183: PUSH
46184: LD_INT 2
46186: DIVREAL
46187: ST_TO_ADDR
// time := time / r ;
46188: LD_ADDR_VAR 0 8
46192: PUSH
46193: LD_VAR 0 8
46197: PUSH
46198: LD_VAR 0 7
46202: DIVREAL
46203: ST_TO_ADDR
// if time < 0 then
46204: LD_VAR 0 8
46208: PUSH
46209: LD_INT 0
46211: LESS
46212: IFFALSE 46229
// time := time * - 1 ;
46214: LD_ADDR_VAR 0 8
46218: PUSH
46219: LD_VAR 0 8
46223: PUSH
46224: LD_INT 1
46226: NEG
46227: MUL
46228: ST_TO_ADDR
// wait ( time ) ;
46229: LD_VAR 0 8
46233: PPUSH
46234: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
46238: LD_INT 35
46240: PPUSH
46241: LD_INT 875
46243: PPUSH
46244: CALL_OW 12
46248: PPUSH
46249: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
46253: LD_INT 1
46255: PPUSH
46256: LD_INT 5
46258: PPUSH
46259: CALL_OW 12
46263: PPUSH
46264: LD_VAR 0 1
46268: PPUSH
46269: LD_INT 1
46271: PPUSH
46272: CALL_OW 55
// end ;
46276: GO 46086
// end ;
46278: LD_VAR 0 5
46282: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
46283: LD_INT 0
46285: PPUSH
46286: PPUSH
46287: PPUSH
46288: PPUSH
46289: PPUSH
46290: PPUSH
46291: PPUSH
46292: PPUSH
// if not turrets or not factories then
46293: LD_VAR 0 1
46297: NOT
46298: PUSH
46299: LD_VAR 0 2
46303: NOT
46304: OR
46305: IFFALSE 46309
// exit ;
46307: GO 46616
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
46309: LD_ADDR_VAR 0 10
46313: PUSH
46314: LD_INT 5
46316: PUSH
46317: LD_INT 6
46319: PUSH
46320: EMPTY
46321: LIST
46322: LIST
46323: PUSH
46324: LD_INT 2
46326: PUSH
46327: LD_INT 4
46329: PUSH
46330: EMPTY
46331: LIST
46332: LIST
46333: PUSH
46334: LD_INT 3
46336: PUSH
46337: LD_INT 5
46339: PUSH
46340: EMPTY
46341: LIST
46342: LIST
46343: PUSH
46344: EMPTY
46345: LIST
46346: LIST
46347: LIST
46348: PUSH
46349: LD_INT 24
46351: PUSH
46352: LD_INT 25
46354: PUSH
46355: EMPTY
46356: LIST
46357: LIST
46358: PUSH
46359: LD_INT 23
46361: PUSH
46362: LD_INT 27
46364: PUSH
46365: EMPTY
46366: LIST
46367: LIST
46368: PUSH
46369: EMPTY
46370: LIST
46371: LIST
46372: PUSH
46373: LD_INT 42
46375: PUSH
46376: LD_INT 43
46378: PUSH
46379: EMPTY
46380: LIST
46381: LIST
46382: PUSH
46383: LD_INT 44
46385: PUSH
46386: LD_INT 46
46388: PUSH
46389: EMPTY
46390: LIST
46391: LIST
46392: PUSH
46393: LD_INT 45
46395: PUSH
46396: LD_INT 47
46398: PUSH
46399: EMPTY
46400: LIST
46401: LIST
46402: PUSH
46403: EMPTY
46404: LIST
46405: LIST
46406: LIST
46407: PUSH
46408: EMPTY
46409: LIST
46410: LIST
46411: LIST
46412: ST_TO_ADDR
// result := [ ] ;
46413: LD_ADDR_VAR 0 3
46417: PUSH
46418: EMPTY
46419: ST_TO_ADDR
// for i in turrets do
46420: LD_ADDR_VAR 0 4
46424: PUSH
46425: LD_VAR 0 1
46429: PUSH
46430: FOR_IN
46431: IFFALSE 46614
// begin nat := GetNation ( i ) ;
46433: LD_ADDR_VAR 0 7
46437: PUSH
46438: LD_VAR 0 4
46442: PPUSH
46443: CALL_OW 248
46447: ST_TO_ADDR
// weapon := 0 ;
46448: LD_ADDR_VAR 0 8
46452: PUSH
46453: LD_INT 0
46455: ST_TO_ADDR
// if not nat then
46456: LD_VAR 0 7
46460: NOT
46461: IFFALSE 46465
// continue ;
46463: GO 46430
// for j in list [ nat ] do
46465: LD_ADDR_VAR 0 5
46469: PUSH
46470: LD_VAR 0 10
46474: PUSH
46475: LD_VAR 0 7
46479: ARRAY
46480: PUSH
46481: FOR_IN
46482: IFFALSE 46523
// if GetBWeapon ( i ) = j [ 1 ] then
46484: LD_VAR 0 4
46488: PPUSH
46489: CALL_OW 269
46493: PUSH
46494: LD_VAR 0 5
46498: PUSH
46499: LD_INT 1
46501: ARRAY
46502: EQUAL
46503: IFFALSE 46521
// begin weapon := j [ 2 ] ;
46505: LD_ADDR_VAR 0 8
46509: PUSH
46510: LD_VAR 0 5
46514: PUSH
46515: LD_INT 2
46517: ARRAY
46518: ST_TO_ADDR
// break ;
46519: GO 46523
// end ;
46521: GO 46481
46523: POP
46524: POP
// if not weapon then
46525: LD_VAR 0 8
46529: NOT
46530: IFFALSE 46534
// continue ;
46532: GO 46430
// for k in factories do
46534: LD_ADDR_VAR 0 6
46538: PUSH
46539: LD_VAR 0 2
46543: PUSH
46544: FOR_IN
46545: IFFALSE 46610
// begin weapons := AvailableWeaponList ( k ) ;
46547: LD_ADDR_VAR 0 9
46551: PUSH
46552: LD_VAR 0 6
46556: PPUSH
46557: CALL_OW 478
46561: ST_TO_ADDR
// if not weapons then
46562: LD_VAR 0 9
46566: NOT
46567: IFFALSE 46571
// continue ;
46569: GO 46544
// if weapon in weapons then
46571: LD_VAR 0 8
46575: PUSH
46576: LD_VAR 0 9
46580: IN
46581: IFFALSE 46608
// begin result := [ i , weapon ] ;
46583: LD_ADDR_VAR 0 3
46587: PUSH
46588: LD_VAR 0 4
46592: PUSH
46593: LD_VAR 0 8
46597: PUSH
46598: EMPTY
46599: LIST
46600: LIST
46601: ST_TO_ADDR
// exit ;
46602: POP
46603: POP
46604: POP
46605: POP
46606: GO 46616
// end ; end ;
46608: GO 46544
46610: POP
46611: POP
// end ;
46612: GO 46430
46614: POP
46615: POP
// end ;
46616: LD_VAR 0 3
46620: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
46621: LD_INT 0
46623: PPUSH
// if not side or side > 8 then
46624: LD_VAR 0 3
46628: NOT
46629: PUSH
46630: LD_VAR 0 3
46634: PUSH
46635: LD_INT 8
46637: GREATER
46638: OR
46639: IFFALSE 46643
// exit ;
46641: GO 46702
// if not range then
46643: LD_VAR 0 4
46647: NOT
46648: IFFALSE 46659
// range := - 12 ;
46650: LD_ADDR_VAR 0 4
46654: PUSH
46655: LD_INT 12
46657: NEG
46658: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
46659: LD_VAR 0 1
46663: PPUSH
46664: LD_VAR 0 2
46668: PPUSH
46669: LD_VAR 0 3
46673: PPUSH
46674: LD_VAR 0 4
46678: PPUSH
46679: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
46683: LD_VAR 0 1
46687: PPUSH
46688: LD_VAR 0 2
46692: PPUSH
46693: LD_VAR 0 3
46697: PPUSH
46698: CALL_OW 331
// end ;
46702: LD_VAR 0 5
46706: RET
// export function Video ( mode ) ; begin
46707: LD_INT 0
46709: PPUSH
// ingame_video = mode ;
46710: LD_ADDR_OWVAR 52
46714: PUSH
46715: LD_VAR 0 1
46719: ST_TO_ADDR
// interface_hidden = mode ;
46720: LD_ADDR_OWVAR 54
46724: PUSH
46725: LD_VAR 0 1
46729: ST_TO_ADDR
// end ;
46730: LD_VAR 0 2
46734: RET
// export function Join ( array , element ) ; begin
46735: LD_INT 0
46737: PPUSH
// result := Replace ( array , array + 1 , element ) ;
46738: LD_ADDR_VAR 0 3
46742: PUSH
46743: LD_VAR 0 1
46747: PPUSH
46748: LD_VAR 0 1
46752: PUSH
46753: LD_INT 1
46755: PLUS
46756: PPUSH
46757: LD_VAR 0 2
46761: PPUSH
46762: CALL_OW 1
46766: ST_TO_ADDR
// end ;
46767: LD_VAR 0 3
46771: RET
// export function JoinUnion ( array , element ) ; begin
46772: LD_INT 0
46774: PPUSH
// result := array union element ;
46775: LD_ADDR_VAR 0 3
46779: PUSH
46780: LD_VAR 0 1
46784: PUSH
46785: LD_VAR 0 2
46789: UNION
46790: ST_TO_ADDR
// end ;
46791: LD_VAR 0 3
46795: RET
// export function GetBehemoths ( side ) ; begin
46796: LD_INT 0
46798: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
46799: LD_ADDR_VAR 0 2
46803: PUSH
46804: LD_INT 22
46806: PUSH
46807: LD_VAR 0 1
46811: PUSH
46812: EMPTY
46813: LIST
46814: LIST
46815: PUSH
46816: LD_INT 31
46818: PUSH
46819: LD_INT 25
46821: PUSH
46822: EMPTY
46823: LIST
46824: LIST
46825: PUSH
46826: EMPTY
46827: LIST
46828: LIST
46829: PPUSH
46830: CALL_OW 69
46834: ST_TO_ADDR
// end ;
46835: LD_VAR 0 2
46839: RET
// export function Shuffle ( array ) ; var i , index ; begin
46840: LD_INT 0
46842: PPUSH
46843: PPUSH
46844: PPUSH
// result := [ ] ;
46845: LD_ADDR_VAR 0 2
46849: PUSH
46850: EMPTY
46851: ST_TO_ADDR
// if not array then
46852: LD_VAR 0 1
46856: NOT
46857: IFFALSE 46861
// exit ;
46859: GO 46960
// Randomize ;
46861: CALL_OW 10
// for i = array downto 1 do
46865: LD_ADDR_VAR 0 3
46869: PUSH
46870: DOUBLE
46871: LD_VAR 0 1
46875: INC
46876: ST_TO_ADDR
46877: LD_INT 1
46879: PUSH
46880: FOR_DOWNTO
46881: IFFALSE 46958
// begin index := rand ( 1 , array ) ;
46883: LD_ADDR_VAR 0 4
46887: PUSH
46888: LD_INT 1
46890: PPUSH
46891: LD_VAR 0 1
46895: PPUSH
46896: CALL_OW 12
46900: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
46901: LD_ADDR_VAR 0 2
46905: PUSH
46906: LD_VAR 0 2
46910: PPUSH
46911: LD_VAR 0 2
46915: PUSH
46916: LD_INT 1
46918: PLUS
46919: PPUSH
46920: LD_VAR 0 1
46924: PUSH
46925: LD_VAR 0 4
46929: ARRAY
46930: PPUSH
46931: CALL_OW 2
46935: ST_TO_ADDR
// array := Delete ( array , index ) ;
46936: LD_ADDR_VAR 0 1
46940: PUSH
46941: LD_VAR 0 1
46945: PPUSH
46946: LD_VAR 0 4
46950: PPUSH
46951: CALL_OW 3
46955: ST_TO_ADDR
// end ;
46956: GO 46880
46958: POP
46959: POP
// end ;
46960: LD_VAR 0 2
46964: RET
// export function GetBaseMaterials ( base ) ; begin
46965: LD_INT 0
46967: PPUSH
// result := [ 0 , 0 , 0 ] ;
46968: LD_ADDR_VAR 0 2
46972: PUSH
46973: LD_INT 0
46975: PUSH
46976: LD_INT 0
46978: PUSH
46979: LD_INT 0
46981: PUSH
46982: EMPTY
46983: LIST
46984: LIST
46985: LIST
46986: ST_TO_ADDR
// if not base then
46987: LD_VAR 0 1
46991: NOT
46992: IFFALSE 46996
// exit ;
46994: GO 47045
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
46996: LD_ADDR_VAR 0 2
47000: PUSH
47001: LD_VAR 0 1
47005: PPUSH
47006: LD_INT 1
47008: PPUSH
47009: CALL_OW 275
47013: PUSH
47014: LD_VAR 0 1
47018: PPUSH
47019: LD_INT 2
47021: PPUSH
47022: CALL_OW 275
47026: PUSH
47027: LD_VAR 0 1
47031: PPUSH
47032: LD_INT 3
47034: PPUSH
47035: CALL_OW 275
47039: PUSH
47040: EMPTY
47041: LIST
47042: LIST
47043: LIST
47044: ST_TO_ADDR
// end ;
47045: LD_VAR 0 2
47049: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
47050: LD_INT 0
47052: PPUSH
47053: PPUSH
// result := array ;
47054: LD_ADDR_VAR 0 3
47058: PUSH
47059: LD_VAR 0 1
47063: ST_TO_ADDR
// if size > 0 then
47064: LD_VAR 0 2
47068: PUSH
47069: LD_INT 0
47071: GREATER
47072: IFFALSE 47118
// for i := array downto size do
47074: LD_ADDR_VAR 0 4
47078: PUSH
47079: DOUBLE
47080: LD_VAR 0 1
47084: INC
47085: ST_TO_ADDR
47086: LD_VAR 0 2
47090: PUSH
47091: FOR_DOWNTO
47092: IFFALSE 47116
// result := Delete ( result , result ) ;
47094: LD_ADDR_VAR 0 3
47098: PUSH
47099: LD_VAR 0 3
47103: PPUSH
47104: LD_VAR 0 3
47108: PPUSH
47109: CALL_OW 3
47113: ST_TO_ADDR
47114: GO 47091
47116: POP
47117: POP
// end ;
47118: LD_VAR 0 3
47122: RET
// export function ComExit ( unit ) ; var tmp ; begin
47123: LD_INT 0
47125: PPUSH
47126: PPUSH
// if not IsInUnit ( unit ) then
47127: LD_VAR 0 1
47131: PPUSH
47132: CALL_OW 310
47136: NOT
47137: IFFALSE 47141
// exit ;
47139: GO 47201
// tmp := IsInUnit ( unit ) ;
47141: LD_ADDR_VAR 0 3
47145: PUSH
47146: LD_VAR 0 1
47150: PPUSH
47151: CALL_OW 310
47155: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
47156: LD_VAR 0 3
47160: PPUSH
47161: CALL_OW 247
47165: PUSH
47166: LD_INT 2
47168: EQUAL
47169: IFFALSE 47182
// ComExitVehicle ( unit ) else
47171: LD_VAR 0 1
47175: PPUSH
47176: CALL_OW 121
47180: GO 47191
// ComExitBuilding ( unit ) ;
47182: LD_VAR 0 1
47186: PPUSH
47187: CALL_OW 122
// result := tmp ;
47191: LD_ADDR_VAR 0 2
47195: PUSH
47196: LD_VAR 0 3
47200: ST_TO_ADDR
// end ;
47201: LD_VAR 0 2
47205: RET
// export function ComExitAll ( units ) ; var i ; begin
47206: LD_INT 0
47208: PPUSH
47209: PPUSH
// if not units then
47210: LD_VAR 0 1
47214: NOT
47215: IFFALSE 47219
// exit ;
47217: GO 47245
// for i in units do
47219: LD_ADDR_VAR 0 3
47223: PUSH
47224: LD_VAR 0 1
47228: PUSH
47229: FOR_IN
47230: IFFALSE 47243
// ComExit ( i ) ;
47232: LD_VAR 0 3
47236: PPUSH
47237: CALL 47123 0 1
47241: GO 47229
47243: POP
47244: POP
// end ;
47245: LD_VAR 0 2
47249: RET
// export function ResetHc ; begin
47250: LD_INT 0
47252: PPUSH
// InitHc ;
47253: CALL_OW 19
// hc_importance := 0 ;
47257: LD_ADDR_OWVAR 32
47261: PUSH
47262: LD_INT 0
47264: ST_TO_ADDR
// end ;
47265: LD_VAR 0 1
47269: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
47270: LD_INT 0
47272: PPUSH
47273: PPUSH
47274: PPUSH
// _x := ( x1 + x2 ) div 2 ;
47275: LD_ADDR_VAR 0 6
47279: PUSH
47280: LD_VAR 0 1
47284: PUSH
47285: LD_VAR 0 3
47289: PLUS
47290: PUSH
47291: LD_INT 2
47293: DIV
47294: ST_TO_ADDR
// if _x < 0 then
47295: LD_VAR 0 6
47299: PUSH
47300: LD_INT 0
47302: LESS
47303: IFFALSE 47320
// _x := _x * - 1 ;
47305: LD_ADDR_VAR 0 6
47309: PUSH
47310: LD_VAR 0 6
47314: PUSH
47315: LD_INT 1
47317: NEG
47318: MUL
47319: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
47320: LD_ADDR_VAR 0 7
47324: PUSH
47325: LD_VAR 0 2
47329: PUSH
47330: LD_VAR 0 4
47334: PLUS
47335: PUSH
47336: LD_INT 2
47338: DIV
47339: ST_TO_ADDR
// if _y < 0 then
47340: LD_VAR 0 7
47344: PUSH
47345: LD_INT 0
47347: LESS
47348: IFFALSE 47365
// _y := _y * - 1 ;
47350: LD_ADDR_VAR 0 7
47354: PUSH
47355: LD_VAR 0 7
47359: PUSH
47360: LD_INT 1
47362: NEG
47363: MUL
47364: ST_TO_ADDR
// result := [ _x , _y ] ;
47365: LD_ADDR_VAR 0 5
47369: PUSH
47370: LD_VAR 0 6
47374: PUSH
47375: LD_VAR 0 7
47379: PUSH
47380: EMPTY
47381: LIST
47382: LIST
47383: ST_TO_ADDR
// end ;
47384: LD_VAR 0 5
47388: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
47389: LD_INT 0
47391: PPUSH
47392: PPUSH
47393: PPUSH
47394: PPUSH
// task := GetTaskList ( unit ) ;
47395: LD_ADDR_VAR 0 7
47399: PUSH
47400: LD_VAR 0 1
47404: PPUSH
47405: CALL_OW 437
47409: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
47410: LD_VAR 0 7
47414: NOT
47415: PUSH
47416: LD_VAR 0 1
47420: PPUSH
47421: LD_VAR 0 2
47425: PPUSH
47426: CALL_OW 308
47430: NOT
47431: AND
47432: IFFALSE 47436
// exit ;
47434: GO 47554
// if IsInArea ( unit , area ) then
47436: LD_VAR 0 1
47440: PPUSH
47441: LD_VAR 0 2
47445: PPUSH
47446: CALL_OW 308
47450: IFFALSE 47468
// begin ComMoveToArea ( unit , goAway ) ;
47452: LD_VAR 0 1
47456: PPUSH
47457: LD_VAR 0 3
47461: PPUSH
47462: CALL_OW 113
// exit ;
47466: GO 47554
// end ; if task [ 1 ] [ 1 ] <> M then
47468: LD_VAR 0 7
47472: PUSH
47473: LD_INT 1
47475: ARRAY
47476: PUSH
47477: LD_INT 1
47479: ARRAY
47480: PUSH
47481: LD_STRING M
47483: NONEQUAL
47484: IFFALSE 47488
// exit ;
47486: GO 47554
// x := task [ 1 ] [ 2 ] ;
47488: LD_ADDR_VAR 0 5
47492: PUSH
47493: LD_VAR 0 7
47497: PUSH
47498: LD_INT 1
47500: ARRAY
47501: PUSH
47502: LD_INT 2
47504: ARRAY
47505: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
47506: LD_ADDR_VAR 0 6
47510: PUSH
47511: LD_VAR 0 7
47515: PUSH
47516: LD_INT 1
47518: ARRAY
47519: PUSH
47520: LD_INT 3
47522: ARRAY
47523: ST_TO_ADDR
// if InArea ( x , y , area ) then
47524: LD_VAR 0 5
47528: PPUSH
47529: LD_VAR 0 6
47533: PPUSH
47534: LD_VAR 0 2
47538: PPUSH
47539: CALL_OW 309
47543: IFFALSE 47554
// ComStop ( unit ) ;
47545: LD_VAR 0 1
47549: PPUSH
47550: CALL_OW 141
// end ;
47554: LD_VAR 0 4
47558: RET
// export function Abs ( value ) ; begin
47559: LD_INT 0
47561: PPUSH
// result := value ;
47562: LD_ADDR_VAR 0 2
47566: PUSH
47567: LD_VAR 0 1
47571: ST_TO_ADDR
// if value < 0 then
47572: LD_VAR 0 1
47576: PUSH
47577: LD_INT 0
47579: LESS
47580: IFFALSE 47597
// result := value * - 1 ;
47582: LD_ADDR_VAR 0 2
47586: PUSH
47587: LD_VAR 0 1
47591: PUSH
47592: LD_INT 1
47594: NEG
47595: MUL
47596: ST_TO_ADDR
// end ;
47597: LD_VAR 0 2
47601: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
47602: LD_INT 0
47604: PPUSH
47605: PPUSH
47606: PPUSH
47607: PPUSH
47608: PPUSH
47609: PPUSH
47610: PPUSH
47611: PPUSH
// if not unit or not building then
47612: LD_VAR 0 1
47616: NOT
47617: PUSH
47618: LD_VAR 0 2
47622: NOT
47623: OR
47624: IFFALSE 47628
// exit ;
47626: GO 47854
// x := GetX ( building ) ;
47628: LD_ADDR_VAR 0 4
47632: PUSH
47633: LD_VAR 0 2
47637: PPUSH
47638: CALL_OW 250
47642: ST_TO_ADDR
// y := GetY ( building ) ;
47643: LD_ADDR_VAR 0 6
47647: PUSH
47648: LD_VAR 0 2
47652: PPUSH
47653: CALL_OW 251
47657: ST_TO_ADDR
// d := GetDir ( building ) ;
47658: LD_ADDR_VAR 0 8
47662: PUSH
47663: LD_VAR 0 2
47667: PPUSH
47668: CALL_OW 254
47672: ST_TO_ADDR
// r := 4 ;
47673: LD_ADDR_VAR 0 9
47677: PUSH
47678: LD_INT 4
47680: ST_TO_ADDR
// for i := 1 to 5 do
47681: LD_ADDR_VAR 0 10
47685: PUSH
47686: DOUBLE
47687: LD_INT 1
47689: DEC
47690: ST_TO_ADDR
47691: LD_INT 5
47693: PUSH
47694: FOR_TO
47695: IFFALSE 47852
// begin _x := ShiftX ( x , d , r + i ) ;
47697: LD_ADDR_VAR 0 5
47701: PUSH
47702: LD_VAR 0 4
47706: PPUSH
47707: LD_VAR 0 8
47711: PPUSH
47712: LD_VAR 0 9
47716: PUSH
47717: LD_VAR 0 10
47721: PLUS
47722: PPUSH
47723: CALL_OW 272
47727: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
47728: LD_ADDR_VAR 0 7
47732: PUSH
47733: LD_VAR 0 6
47737: PPUSH
47738: LD_VAR 0 8
47742: PPUSH
47743: LD_VAR 0 9
47747: PUSH
47748: LD_VAR 0 10
47752: PLUS
47753: PPUSH
47754: CALL_OW 273
47758: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
47759: LD_VAR 0 5
47763: PPUSH
47764: LD_VAR 0 7
47768: PPUSH
47769: CALL_OW 488
47773: PUSH
47774: LD_VAR 0 5
47778: PPUSH
47779: LD_VAR 0 7
47783: PPUSH
47784: CALL_OW 428
47788: PPUSH
47789: CALL_OW 247
47793: PUSH
47794: LD_INT 3
47796: PUSH
47797: LD_INT 2
47799: PUSH
47800: EMPTY
47801: LIST
47802: LIST
47803: IN
47804: NOT
47805: AND
47806: IFFALSE 47850
// begin ComMoveXY ( unit , _x , _y ) ;
47808: LD_VAR 0 1
47812: PPUSH
47813: LD_VAR 0 5
47817: PPUSH
47818: LD_VAR 0 7
47822: PPUSH
47823: CALL_OW 111
// result := [ _x , _y ] ;
47827: LD_ADDR_VAR 0 3
47831: PUSH
47832: LD_VAR 0 5
47836: PUSH
47837: LD_VAR 0 7
47841: PUSH
47842: EMPTY
47843: LIST
47844: LIST
47845: ST_TO_ADDR
// exit ;
47846: POP
47847: POP
47848: GO 47854
// end ; end ;
47850: GO 47694
47852: POP
47853: POP
// end ;
47854: LD_VAR 0 3
47858: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
47859: LD_INT 0
47861: PPUSH
47862: PPUSH
47863: PPUSH
// result := 0 ;
47864: LD_ADDR_VAR 0 3
47868: PUSH
47869: LD_INT 0
47871: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
47872: LD_VAR 0 1
47876: PUSH
47877: LD_INT 0
47879: LESS
47880: PUSH
47881: LD_VAR 0 1
47885: PUSH
47886: LD_INT 8
47888: GREATER
47889: OR
47890: PUSH
47891: LD_VAR 0 2
47895: PUSH
47896: LD_INT 0
47898: LESS
47899: OR
47900: PUSH
47901: LD_VAR 0 2
47905: PUSH
47906: LD_INT 8
47908: GREATER
47909: OR
47910: IFFALSE 47914
// exit ;
47912: GO 47989
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
47914: LD_ADDR_VAR 0 4
47918: PUSH
47919: LD_INT 22
47921: PUSH
47922: LD_VAR 0 2
47926: PUSH
47927: EMPTY
47928: LIST
47929: LIST
47930: PPUSH
47931: CALL_OW 69
47935: PUSH
47936: FOR_IN
47937: IFFALSE 47987
// begin un := UnitShoot ( i ) ;
47939: LD_ADDR_VAR 0 5
47943: PUSH
47944: LD_VAR 0 4
47948: PPUSH
47949: CALL_OW 504
47953: ST_TO_ADDR
// if GetSide ( un ) = side1 then
47954: LD_VAR 0 5
47958: PPUSH
47959: CALL_OW 255
47963: PUSH
47964: LD_VAR 0 1
47968: EQUAL
47969: IFFALSE 47985
// begin result := un ;
47971: LD_ADDR_VAR 0 3
47975: PUSH
47976: LD_VAR 0 5
47980: ST_TO_ADDR
// exit ;
47981: POP
47982: POP
47983: GO 47989
// end ; end ;
47985: GO 47936
47987: POP
47988: POP
// end ;
47989: LD_VAR 0 3
47993: RET
// export function GetCargoBay ( units ) ; begin
47994: LD_INT 0
47996: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
47997: LD_ADDR_VAR 0 2
48001: PUSH
48002: LD_VAR 0 1
48006: PPUSH
48007: LD_INT 2
48009: PUSH
48010: LD_INT 34
48012: PUSH
48013: LD_INT 12
48015: PUSH
48016: EMPTY
48017: LIST
48018: LIST
48019: PUSH
48020: LD_INT 34
48022: PUSH
48023: LD_INT 51
48025: PUSH
48026: EMPTY
48027: LIST
48028: LIST
48029: PUSH
48030: LD_INT 34
48032: PUSH
48033: LD_INT 32
48035: PUSH
48036: EMPTY
48037: LIST
48038: LIST
48039: PUSH
48040: LD_INT 34
48042: PUSH
48043: LD_EXP 68
48047: PUSH
48048: EMPTY
48049: LIST
48050: LIST
48051: PUSH
48052: EMPTY
48053: LIST
48054: LIST
48055: LIST
48056: LIST
48057: LIST
48058: PPUSH
48059: CALL_OW 72
48063: ST_TO_ADDR
// end ;
48064: LD_VAR 0 2
48068: RET
// export function Negate ( value ) ; begin
48069: LD_INT 0
48071: PPUSH
// result := not value ;
48072: LD_ADDR_VAR 0 2
48076: PUSH
48077: LD_VAR 0 1
48081: NOT
48082: ST_TO_ADDR
// end ;
48083: LD_VAR 0 2
48087: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; begin
48088: LD_INT 0
48090: PPUSH
// if x1 = x2 then
48091: LD_VAR 0 1
48095: PUSH
48096: LD_VAR 0 3
48100: EQUAL
48101: IFFALSE 48135
// begin if y1 > y2 then
48103: LD_VAR 0 2
48107: PUSH
48108: LD_VAR 0 4
48112: GREATER
48113: IFFALSE 48125
// result := 0 else
48115: LD_ADDR_VAR 0 5
48119: PUSH
48120: LD_INT 0
48122: ST_TO_ADDR
48123: GO 48133
// result := 3 ;
48125: LD_ADDR_VAR 0 5
48129: PUSH
48130: LD_INT 3
48132: ST_TO_ADDR
// exit ;
48133: GO 48221
// end ; if y1 = y2 then
48135: LD_VAR 0 2
48139: PUSH
48140: LD_VAR 0 4
48144: EQUAL
48145: IFFALSE 48179
// begin if x1 > x2 then
48147: LD_VAR 0 1
48151: PUSH
48152: LD_VAR 0 3
48156: GREATER
48157: IFFALSE 48169
// result := 1 else
48159: LD_ADDR_VAR 0 5
48163: PUSH
48164: LD_INT 1
48166: ST_TO_ADDR
48167: GO 48177
// result := 4 ;
48169: LD_ADDR_VAR 0 5
48173: PUSH
48174: LD_INT 4
48176: ST_TO_ADDR
// exit ;
48177: GO 48221
// end ; if x1 > x2 and y1 > y2 then
48179: LD_VAR 0 1
48183: PUSH
48184: LD_VAR 0 3
48188: GREATER
48189: PUSH
48190: LD_VAR 0 2
48194: PUSH
48195: LD_VAR 0 4
48199: GREATER
48200: AND
48201: IFFALSE 48213
// result := 2 else
48203: LD_ADDR_VAR 0 5
48207: PUSH
48208: LD_INT 2
48210: ST_TO_ADDR
48211: GO 48221
// result := 5 ;
48213: LD_ADDR_VAR 0 5
48217: PUSH
48218: LD_INT 5
48220: ST_TO_ADDR
// end ;
48221: LD_VAR 0 5
48225: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
48226: LD_INT 0
48228: PPUSH
48229: PPUSH
// if not driver or not IsInUnit ( driver ) then
48230: LD_VAR 0 1
48234: NOT
48235: PUSH
48236: LD_VAR 0 1
48240: PPUSH
48241: CALL_OW 310
48245: NOT
48246: OR
48247: IFFALSE 48251
// exit ;
48249: GO 48341
// vehicle := IsInUnit ( driver ) ;
48251: LD_ADDR_VAR 0 3
48255: PUSH
48256: LD_VAR 0 1
48260: PPUSH
48261: CALL_OW 310
48265: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
48266: LD_VAR 0 1
48270: PPUSH
48271: LD_STRING \
48273: PUSH
48274: LD_INT 0
48276: PUSH
48277: LD_INT 0
48279: PUSH
48280: LD_INT 0
48282: PUSH
48283: LD_INT 0
48285: PUSH
48286: LD_INT 0
48288: PUSH
48289: LD_INT 0
48291: PUSH
48292: EMPTY
48293: LIST
48294: LIST
48295: LIST
48296: LIST
48297: LIST
48298: LIST
48299: LIST
48300: PUSH
48301: LD_STRING E
48303: PUSH
48304: LD_INT 0
48306: PUSH
48307: LD_INT 0
48309: PUSH
48310: LD_VAR 0 3
48314: PUSH
48315: LD_INT 0
48317: PUSH
48318: LD_INT 0
48320: PUSH
48321: LD_INT 0
48323: PUSH
48324: EMPTY
48325: LIST
48326: LIST
48327: LIST
48328: LIST
48329: LIST
48330: LIST
48331: LIST
48332: PUSH
48333: EMPTY
48334: LIST
48335: LIST
48336: PPUSH
48337: CALL_OW 446
// end ;
48341: LD_VAR 0 2
48345: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
48346: LD_INT 0
48348: PPUSH
48349: PPUSH
// if not driver or not IsInUnit ( driver ) then
48350: LD_VAR 0 1
48354: NOT
48355: PUSH
48356: LD_VAR 0 1
48360: PPUSH
48361: CALL_OW 310
48365: NOT
48366: OR
48367: IFFALSE 48371
// exit ;
48369: GO 48461
// vehicle := IsInUnit ( driver ) ;
48371: LD_ADDR_VAR 0 3
48375: PUSH
48376: LD_VAR 0 1
48380: PPUSH
48381: CALL_OW 310
48385: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
48386: LD_VAR 0 1
48390: PPUSH
48391: LD_STRING \
48393: PUSH
48394: LD_INT 0
48396: PUSH
48397: LD_INT 0
48399: PUSH
48400: LD_INT 0
48402: PUSH
48403: LD_INT 0
48405: PUSH
48406: LD_INT 0
48408: PUSH
48409: LD_INT 0
48411: PUSH
48412: EMPTY
48413: LIST
48414: LIST
48415: LIST
48416: LIST
48417: LIST
48418: LIST
48419: LIST
48420: PUSH
48421: LD_STRING E
48423: PUSH
48424: LD_INT 0
48426: PUSH
48427: LD_INT 0
48429: PUSH
48430: LD_VAR 0 3
48434: PUSH
48435: LD_INT 0
48437: PUSH
48438: LD_INT 0
48440: PUSH
48441: LD_INT 0
48443: PUSH
48444: EMPTY
48445: LIST
48446: LIST
48447: LIST
48448: LIST
48449: LIST
48450: LIST
48451: LIST
48452: PUSH
48453: EMPTY
48454: LIST
48455: LIST
48456: PPUSH
48457: CALL_OW 447
// end ;
48461: LD_VAR 0 2
48465: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
48466: LD_INT 0
48468: PPUSH
48469: PPUSH
48470: PPUSH
// tmp := [ ] ;
48471: LD_ADDR_VAR 0 5
48475: PUSH
48476: EMPTY
48477: ST_TO_ADDR
// for i in units do
48478: LD_ADDR_VAR 0 4
48482: PUSH
48483: LD_VAR 0 1
48487: PUSH
48488: FOR_IN
48489: IFFALSE 48527
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
48491: LD_ADDR_VAR 0 5
48495: PUSH
48496: LD_VAR 0 5
48500: PPUSH
48501: LD_VAR 0 5
48505: PUSH
48506: LD_INT 1
48508: PLUS
48509: PPUSH
48510: LD_VAR 0 4
48514: PPUSH
48515: CALL_OW 256
48519: PPUSH
48520: CALL_OW 2
48524: ST_TO_ADDR
48525: GO 48488
48527: POP
48528: POP
// if not tmp then
48529: LD_VAR 0 5
48533: NOT
48534: IFFALSE 48538
// exit ;
48536: GO 48586
// if asc then
48538: LD_VAR 0 2
48542: IFFALSE 48566
// result := SortListByListAsc ( units , tmp ) else
48544: LD_ADDR_VAR 0 3
48548: PUSH
48549: LD_VAR 0 1
48553: PPUSH
48554: LD_VAR 0 5
48558: PPUSH
48559: CALL_OW 76
48563: ST_TO_ADDR
48564: GO 48586
// result := SortListByListDesc ( units , tmp ) ;
48566: LD_ADDR_VAR 0 3
48570: PUSH
48571: LD_VAR 0 1
48575: PPUSH
48576: LD_VAR 0 5
48580: PPUSH
48581: CALL_OW 77
48585: ST_TO_ADDR
// end ;
48586: LD_VAR 0 3
48590: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
48591: LD_INT 0
48593: PPUSH
48594: PPUSH
// task := GetTaskList ( mech ) ;
48595: LD_ADDR_VAR 0 4
48599: PUSH
48600: LD_VAR 0 1
48604: PPUSH
48605: CALL_OW 437
48609: ST_TO_ADDR
// if not task then
48610: LD_VAR 0 4
48614: NOT
48615: IFFALSE 48619
// exit ;
48617: GO 48661
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
48619: LD_ADDR_VAR 0 3
48623: PUSH
48624: LD_VAR 0 4
48628: PUSH
48629: LD_INT 1
48631: ARRAY
48632: PUSH
48633: LD_INT 1
48635: ARRAY
48636: PUSH
48637: LD_STRING r
48639: EQUAL
48640: PUSH
48641: LD_VAR 0 4
48645: PUSH
48646: LD_INT 1
48648: ARRAY
48649: PUSH
48650: LD_INT 4
48652: ARRAY
48653: PUSH
48654: LD_VAR 0 2
48658: EQUAL
48659: AND
48660: ST_TO_ADDR
// end ;
48661: LD_VAR 0 3
48665: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
48666: LD_INT 0
48668: PPUSH
// SetDir ( unit , d ) ;
48669: LD_VAR 0 1
48673: PPUSH
48674: LD_VAR 0 4
48678: PPUSH
48679: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
48683: LD_VAR 0 1
48687: PPUSH
48688: LD_VAR 0 2
48692: PPUSH
48693: LD_VAR 0 3
48697: PPUSH
48698: LD_VAR 0 5
48702: PPUSH
48703: CALL_OW 48
// end ;
48707: LD_VAR 0 6
48711: RET
// export function ToNaturalNumber ( number ) ; begin
48712: LD_INT 0
48714: PPUSH
// result := number div 1 ;
48715: LD_ADDR_VAR 0 2
48719: PUSH
48720: LD_VAR 0 1
48724: PUSH
48725: LD_INT 1
48727: DIV
48728: ST_TO_ADDR
// if number < 0 then
48729: LD_VAR 0 1
48733: PUSH
48734: LD_INT 0
48736: LESS
48737: IFFALSE 48747
// result := 0 ;
48739: LD_ADDR_VAR 0 2
48743: PUSH
48744: LD_INT 0
48746: ST_TO_ADDR
// end ; end_of_file
48747: LD_VAR 0 2
48751: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
48752: LD_INT 0
48754: PPUSH
48755: PPUSH
// skirmish := false ;
48756: LD_ADDR_EXP 21
48760: PUSH
48761: LD_INT 0
48763: ST_TO_ADDR
// debug_mc := false ;
48764: LD_ADDR_EXP 22
48768: PUSH
48769: LD_INT 0
48771: ST_TO_ADDR
// mc_bases := [ ] ;
48772: LD_ADDR_EXP 23
48776: PUSH
48777: EMPTY
48778: ST_TO_ADDR
// mc_sides := [ ] ;
48779: LD_ADDR_EXP 49
48783: PUSH
48784: EMPTY
48785: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
48786: LD_ADDR_EXP 24
48790: PUSH
48791: EMPTY
48792: ST_TO_ADDR
// mc_building_repairs := [ ] ;
48793: LD_ADDR_EXP 25
48797: PUSH
48798: EMPTY
48799: ST_TO_ADDR
// mc_need_heal := [ ] ;
48800: LD_ADDR_EXP 26
48804: PUSH
48805: EMPTY
48806: ST_TO_ADDR
// mc_healers := [ ] ;
48807: LD_ADDR_EXP 27
48811: PUSH
48812: EMPTY
48813: ST_TO_ADDR
// mc_build_list := [ ] ;
48814: LD_ADDR_EXP 28
48818: PUSH
48819: EMPTY
48820: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
48821: LD_ADDR_EXP 55
48825: PUSH
48826: EMPTY
48827: ST_TO_ADDR
// mc_builders := [ ] ;
48828: LD_ADDR_EXP 29
48832: PUSH
48833: EMPTY
48834: ST_TO_ADDR
// mc_construct_list := [ ] ;
48835: LD_ADDR_EXP 30
48839: PUSH
48840: EMPTY
48841: ST_TO_ADDR
// mc_turret_list := [ ] ;
48842: LD_ADDR_EXP 31
48846: PUSH
48847: EMPTY
48848: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
48849: LD_ADDR_EXP 32
48853: PUSH
48854: EMPTY
48855: ST_TO_ADDR
// mc_miners := [ ] ;
48856: LD_ADDR_EXP 37
48860: PUSH
48861: EMPTY
48862: ST_TO_ADDR
// mc_mines := [ ] ;
48863: LD_ADDR_EXP 36
48867: PUSH
48868: EMPTY
48869: ST_TO_ADDR
// mc_minefields := [ ] ;
48870: LD_ADDR_EXP 38
48874: PUSH
48875: EMPTY
48876: ST_TO_ADDR
// mc_crates := [ ] ;
48877: LD_ADDR_EXP 39
48881: PUSH
48882: EMPTY
48883: ST_TO_ADDR
// mc_crates_collector := [ ] ;
48884: LD_ADDR_EXP 40
48888: PUSH
48889: EMPTY
48890: ST_TO_ADDR
// mc_crates_area := [ ] ;
48891: LD_ADDR_EXP 41
48895: PUSH
48896: EMPTY
48897: ST_TO_ADDR
// mc_vehicles := [ ] ;
48898: LD_ADDR_EXP 42
48902: PUSH
48903: EMPTY
48904: ST_TO_ADDR
// mc_attack := [ ] ;
48905: LD_ADDR_EXP 43
48909: PUSH
48910: EMPTY
48911: ST_TO_ADDR
// mc_produce := [ ] ;
48912: LD_ADDR_EXP 44
48916: PUSH
48917: EMPTY
48918: ST_TO_ADDR
// mc_defender := [ ] ;
48919: LD_ADDR_EXP 45
48923: PUSH
48924: EMPTY
48925: ST_TO_ADDR
// mc_parking := [ ] ;
48926: LD_ADDR_EXP 47
48930: PUSH
48931: EMPTY
48932: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
48933: LD_ADDR_EXP 33
48937: PUSH
48938: EMPTY
48939: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
48940: LD_ADDR_EXP 35
48944: PUSH
48945: EMPTY
48946: ST_TO_ADDR
// mc_scan := [ ] ;
48947: LD_ADDR_EXP 46
48951: PUSH
48952: EMPTY
48953: ST_TO_ADDR
// mc_scan_area := [ ] ;
48954: LD_ADDR_EXP 48
48958: PUSH
48959: EMPTY
48960: ST_TO_ADDR
// mc_tech := [ ] ;
48961: LD_ADDR_EXP 50
48965: PUSH
48966: EMPTY
48967: ST_TO_ADDR
// mc_class := [ ] ;
48968: LD_ADDR_EXP 64
48972: PUSH
48973: EMPTY
48974: ST_TO_ADDR
// mc_class_case_use := [ ] ;
48975: LD_ADDR_EXP 65
48979: PUSH
48980: EMPTY
48981: ST_TO_ADDR
// mc_is_defending := [ ] ;
48982: LD_ADDR_EXP 66
48986: PUSH
48987: EMPTY
48988: ST_TO_ADDR
// end ;
48989: LD_VAR 0 1
48993: RET
// export function MC_Kill ( base ) ; begin
48994: LD_INT 0
48996: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
48997: LD_ADDR_EXP 23
49001: PUSH
49002: LD_EXP 23
49006: PPUSH
49007: LD_VAR 0 1
49011: PPUSH
49012: EMPTY
49013: PPUSH
49014: CALL_OW 1
49018: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
49019: LD_ADDR_EXP 24
49023: PUSH
49024: LD_EXP 24
49028: PPUSH
49029: LD_VAR 0 1
49033: PPUSH
49034: EMPTY
49035: PPUSH
49036: CALL_OW 1
49040: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
49041: LD_ADDR_EXP 25
49045: PUSH
49046: LD_EXP 25
49050: PPUSH
49051: LD_VAR 0 1
49055: PPUSH
49056: EMPTY
49057: PPUSH
49058: CALL_OW 1
49062: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
49063: LD_ADDR_EXP 26
49067: PUSH
49068: LD_EXP 26
49072: PPUSH
49073: LD_VAR 0 1
49077: PPUSH
49078: EMPTY
49079: PPUSH
49080: CALL_OW 1
49084: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
49085: LD_ADDR_EXP 27
49089: PUSH
49090: LD_EXP 27
49094: PPUSH
49095: LD_VAR 0 1
49099: PPUSH
49100: EMPTY
49101: PPUSH
49102: CALL_OW 1
49106: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
49107: LD_ADDR_EXP 28
49111: PUSH
49112: LD_EXP 28
49116: PPUSH
49117: LD_VAR 0 1
49121: PPUSH
49122: EMPTY
49123: PPUSH
49124: CALL_OW 1
49128: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
49129: LD_ADDR_EXP 29
49133: PUSH
49134: LD_EXP 29
49138: PPUSH
49139: LD_VAR 0 1
49143: PPUSH
49144: EMPTY
49145: PPUSH
49146: CALL_OW 1
49150: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
49151: LD_ADDR_EXP 30
49155: PUSH
49156: LD_EXP 30
49160: PPUSH
49161: LD_VAR 0 1
49165: PPUSH
49166: EMPTY
49167: PPUSH
49168: CALL_OW 1
49172: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
49173: LD_ADDR_EXP 31
49177: PUSH
49178: LD_EXP 31
49182: PPUSH
49183: LD_VAR 0 1
49187: PPUSH
49188: EMPTY
49189: PPUSH
49190: CALL_OW 1
49194: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
49195: LD_ADDR_EXP 32
49199: PUSH
49200: LD_EXP 32
49204: PPUSH
49205: LD_VAR 0 1
49209: PPUSH
49210: EMPTY
49211: PPUSH
49212: CALL_OW 1
49216: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
49217: LD_ADDR_EXP 33
49221: PUSH
49222: LD_EXP 33
49226: PPUSH
49227: LD_VAR 0 1
49231: PPUSH
49232: EMPTY
49233: PPUSH
49234: CALL_OW 1
49238: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
49239: LD_ADDR_EXP 34
49243: PUSH
49244: LD_EXP 34
49248: PPUSH
49249: LD_VAR 0 1
49253: PPUSH
49254: LD_INT 0
49256: PPUSH
49257: CALL_OW 1
49261: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
49262: LD_ADDR_EXP 35
49266: PUSH
49267: LD_EXP 35
49271: PPUSH
49272: LD_VAR 0 1
49276: PPUSH
49277: EMPTY
49278: PPUSH
49279: CALL_OW 1
49283: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
49284: LD_ADDR_EXP 36
49288: PUSH
49289: LD_EXP 36
49293: PPUSH
49294: LD_VAR 0 1
49298: PPUSH
49299: EMPTY
49300: PPUSH
49301: CALL_OW 1
49305: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
49306: LD_ADDR_EXP 37
49310: PUSH
49311: LD_EXP 37
49315: PPUSH
49316: LD_VAR 0 1
49320: PPUSH
49321: EMPTY
49322: PPUSH
49323: CALL_OW 1
49327: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
49328: LD_ADDR_EXP 38
49332: PUSH
49333: LD_EXP 38
49337: PPUSH
49338: LD_VAR 0 1
49342: PPUSH
49343: EMPTY
49344: PPUSH
49345: CALL_OW 1
49349: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
49350: LD_ADDR_EXP 39
49354: PUSH
49355: LD_EXP 39
49359: PPUSH
49360: LD_VAR 0 1
49364: PPUSH
49365: EMPTY
49366: PPUSH
49367: CALL_OW 1
49371: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
49372: LD_ADDR_EXP 40
49376: PUSH
49377: LD_EXP 40
49381: PPUSH
49382: LD_VAR 0 1
49386: PPUSH
49387: EMPTY
49388: PPUSH
49389: CALL_OW 1
49393: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
49394: LD_ADDR_EXP 41
49398: PUSH
49399: LD_EXP 41
49403: PPUSH
49404: LD_VAR 0 1
49408: PPUSH
49409: EMPTY
49410: PPUSH
49411: CALL_OW 1
49415: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
49416: LD_ADDR_EXP 42
49420: PUSH
49421: LD_EXP 42
49425: PPUSH
49426: LD_VAR 0 1
49430: PPUSH
49431: EMPTY
49432: PPUSH
49433: CALL_OW 1
49437: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
49438: LD_ADDR_EXP 43
49442: PUSH
49443: LD_EXP 43
49447: PPUSH
49448: LD_VAR 0 1
49452: PPUSH
49453: EMPTY
49454: PPUSH
49455: CALL_OW 1
49459: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
49460: LD_ADDR_EXP 44
49464: PUSH
49465: LD_EXP 44
49469: PPUSH
49470: LD_VAR 0 1
49474: PPUSH
49475: EMPTY
49476: PPUSH
49477: CALL_OW 1
49481: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
49482: LD_ADDR_EXP 45
49486: PUSH
49487: LD_EXP 45
49491: PPUSH
49492: LD_VAR 0 1
49496: PPUSH
49497: EMPTY
49498: PPUSH
49499: CALL_OW 1
49503: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
49504: LD_ADDR_EXP 46
49508: PUSH
49509: LD_EXP 46
49513: PPUSH
49514: LD_VAR 0 1
49518: PPUSH
49519: EMPTY
49520: PPUSH
49521: CALL_OW 1
49525: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
49526: LD_ADDR_EXP 47
49530: PUSH
49531: LD_EXP 47
49535: PPUSH
49536: LD_VAR 0 1
49540: PPUSH
49541: EMPTY
49542: PPUSH
49543: CALL_OW 1
49547: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
49548: LD_ADDR_EXP 48
49552: PUSH
49553: LD_EXP 48
49557: PPUSH
49558: LD_VAR 0 1
49562: PPUSH
49563: EMPTY
49564: PPUSH
49565: CALL_OW 1
49569: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
49570: LD_ADDR_EXP 50
49574: PUSH
49575: LD_EXP 50
49579: PPUSH
49580: LD_VAR 0 1
49584: PPUSH
49585: EMPTY
49586: PPUSH
49587: CALL_OW 1
49591: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
49592: LD_ADDR_EXP 52
49596: PUSH
49597: LD_EXP 52
49601: PPUSH
49602: LD_VAR 0 1
49606: PPUSH
49607: EMPTY
49608: PPUSH
49609: CALL_OW 1
49613: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
49614: LD_ADDR_EXP 53
49618: PUSH
49619: LD_EXP 53
49623: PPUSH
49624: LD_VAR 0 1
49628: PPUSH
49629: EMPTY
49630: PPUSH
49631: CALL_OW 1
49635: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
49636: LD_ADDR_EXP 54
49640: PUSH
49641: LD_EXP 54
49645: PPUSH
49646: LD_VAR 0 1
49650: PPUSH
49651: EMPTY
49652: PPUSH
49653: CALL_OW 1
49657: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
49658: LD_ADDR_EXP 55
49662: PUSH
49663: LD_EXP 55
49667: PPUSH
49668: LD_VAR 0 1
49672: PPUSH
49673: EMPTY
49674: PPUSH
49675: CALL_OW 1
49679: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
49680: LD_ADDR_EXP 56
49684: PUSH
49685: LD_EXP 56
49689: PPUSH
49690: LD_VAR 0 1
49694: PPUSH
49695: EMPTY
49696: PPUSH
49697: CALL_OW 1
49701: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
49702: LD_ADDR_EXP 57
49706: PUSH
49707: LD_EXP 57
49711: PPUSH
49712: LD_VAR 0 1
49716: PPUSH
49717: EMPTY
49718: PPUSH
49719: CALL_OW 1
49723: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
49724: LD_ADDR_EXP 58
49728: PUSH
49729: LD_EXP 58
49733: PPUSH
49734: LD_VAR 0 1
49738: PPUSH
49739: EMPTY
49740: PPUSH
49741: CALL_OW 1
49745: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
49746: LD_ADDR_EXP 59
49750: PUSH
49751: LD_EXP 59
49755: PPUSH
49756: LD_VAR 0 1
49760: PPUSH
49761: EMPTY
49762: PPUSH
49763: CALL_OW 1
49767: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
49768: LD_ADDR_EXP 60
49772: PUSH
49773: LD_EXP 60
49777: PPUSH
49778: LD_VAR 0 1
49782: PPUSH
49783: EMPTY
49784: PPUSH
49785: CALL_OW 1
49789: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
49790: LD_ADDR_EXP 61
49794: PUSH
49795: LD_EXP 61
49799: PPUSH
49800: LD_VAR 0 1
49804: PPUSH
49805: EMPTY
49806: PPUSH
49807: CALL_OW 1
49811: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
49812: LD_ADDR_EXP 62
49816: PUSH
49817: LD_EXP 62
49821: PPUSH
49822: LD_VAR 0 1
49826: PPUSH
49827: EMPTY
49828: PPUSH
49829: CALL_OW 1
49833: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
49834: LD_ADDR_EXP 63
49838: PUSH
49839: LD_EXP 63
49843: PPUSH
49844: LD_VAR 0 1
49848: PPUSH
49849: EMPTY
49850: PPUSH
49851: CALL_OW 1
49855: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
49856: LD_ADDR_EXP 64
49860: PUSH
49861: LD_EXP 64
49865: PPUSH
49866: LD_VAR 0 1
49870: PPUSH
49871: EMPTY
49872: PPUSH
49873: CALL_OW 1
49877: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
49878: LD_ADDR_EXP 65
49882: PUSH
49883: LD_EXP 65
49887: PPUSH
49888: LD_VAR 0 1
49892: PPUSH
49893: LD_INT 0
49895: PPUSH
49896: CALL_OW 1
49900: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
49901: LD_ADDR_EXP 66
49905: PUSH
49906: LD_EXP 66
49910: PPUSH
49911: LD_VAR 0 1
49915: PPUSH
49916: LD_INT 0
49918: PPUSH
49919: CALL_OW 1
49923: ST_TO_ADDR
// end ;
49924: LD_VAR 0 2
49928: RET
// export function MC_Add ( side , units ) ; var base ; begin
49929: LD_INT 0
49931: PPUSH
49932: PPUSH
// base := mc_bases + 1 ;
49933: LD_ADDR_VAR 0 4
49937: PUSH
49938: LD_EXP 23
49942: PUSH
49943: LD_INT 1
49945: PLUS
49946: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
49947: LD_ADDR_EXP 49
49951: PUSH
49952: LD_EXP 49
49956: PPUSH
49957: LD_VAR 0 4
49961: PPUSH
49962: LD_VAR 0 1
49966: PPUSH
49967: CALL_OW 1
49971: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
49972: LD_ADDR_EXP 23
49976: PUSH
49977: LD_EXP 23
49981: PPUSH
49982: LD_VAR 0 4
49986: PPUSH
49987: LD_VAR 0 2
49991: PPUSH
49992: CALL_OW 1
49996: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
49997: LD_ADDR_EXP 24
50001: PUSH
50002: LD_EXP 24
50006: PPUSH
50007: LD_VAR 0 4
50011: PPUSH
50012: EMPTY
50013: PPUSH
50014: CALL_OW 1
50018: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
50019: LD_ADDR_EXP 25
50023: PUSH
50024: LD_EXP 25
50028: PPUSH
50029: LD_VAR 0 4
50033: PPUSH
50034: EMPTY
50035: PPUSH
50036: CALL_OW 1
50040: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
50041: LD_ADDR_EXP 26
50045: PUSH
50046: LD_EXP 26
50050: PPUSH
50051: LD_VAR 0 4
50055: PPUSH
50056: EMPTY
50057: PPUSH
50058: CALL_OW 1
50062: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
50063: LD_ADDR_EXP 27
50067: PUSH
50068: LD_EXP 27
50072: PPUSH
50073: LD_VAR 0 4
50077: PPUSH
50078: EMPTY
50079: PPUSH
50080: CALL_OW 1
50084: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
50085: LD_ADDR_EXP 28
50089: PUSH
50090: LD_EXP 28
50094: PPUSH
50095: LD_VAR 0 4
50099: PPUSH
50100: EMPTY
50101: PPUSH
50102: CALL_OW 1
50106: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
50107: LD_ADDR_EXP 29
50111: PUSH
50112: LD_EXP 29
50116: PPUSH
50117: LD_VAR 0 4
50121: PPUSH
50122: EMPTY
50123: PPUSH
50124: CALL_OW 1
50128: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
50129: LD_ADDR_EXP 30
50133: PUSH
50134: LD_EXP 30
50138: PPUSH
50139: LD_VAR 0 4
50143: PPUSH
50144: EMPTY
50145: PPUSH
50146: CALL_OW 1
50150: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
50151: LD_ADDR_EXP 31
50155: PUSH
50156: LD_EXP 31
50160: PPUSH
50161: LD_VAR 0 4
50165: PPUSH
50166: EMPTY
50167: PPUSH
50168: CALL_OW 1
50172: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
50173: LD_ADDR_EXP 32
50177: PUSH
50178: LD_EXP 32
50182: PPUSH
50183: LD_VAR 0 4
50187: PPUSH
50188: EMPTY
50189: PPUSH
50190: CALL_OW 1
50194: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
50195: LD_ADDR_EXP 33
50199: PUSH
50200: LD_EXP 33
50204: PPUSH
50205: LD_VAR 0 4
50209: PPUSH
50210: EMPTY
50211: PPUSH
50212: CALL_OW 1
50216: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
50217: LD_ADDR_EXP 34
50221: PUSH
50222: LD_EXP 34
50226: PPUSH
50227: LD_VAR 0 4
50231: PPUSH
50232: LD_INT 0
50234: PPUSH
50235: CALL_OW 1
50239: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
50240: LD_ADDR_EXP 35
50244: PUSH
50245: LD_EXP 35
50249: PPUSH
50250: LD_VAR 0 4
50254: PPUSH
50255: EMPTY
50256: PPUSH
50257: CALL_OW 1
50261: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
50262: LD_ADDR_EXP 36
50266: PUSH
50267: LD_EXP 36
50271: PPUSH
50272: LD_VAR 0 4
50276: PPUSH
50277: EMPTY
50278: PPUSH
50279: CALL_OW 1
50283: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
50284: LD_ADDR_EXP 37
50288: PUSH
50289: LD_EXP 37
50293: PPUSH
50294: LD_VAR 0 4
50298: PPUSH
50299: EMPTY
50300: PPUSH
50301: CALL_OW 1
50305: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
50306: LD_ADDR_EXP 38
50310: PUSH
50311: LD_EXP 38
50315: PPUSH
50316: LD_VAR 0 4
50320: PPUSH
50321: EMPTY
50322: PPUSH
50323: CALL_OW 1
50327: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
50328: LD_ADDR_EXP 39
50332: PUSH
50333: LD_EXP 39
50337: PPUSH
50338: LD_VAR 0 4
50342: PPUSH
50343: EMPTY
50344: PPUSH
50345: CALL_OW 1
50349: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
50350: LD_ADDR_EXP 40
50354: PUSH
50355: LD_EXP 40
50359: PPUSH
50360: LD_VAR 0 4
50364: PPUSH
50365: EMPTY
50366: PPUSH
50367: CALL_OW 1
50371: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
50372: LD_ADDR_EXP 41
50376: PUSH
50377: LD_EXP 41
50381: PPUSH
50382: LD_VAR 0 4
50386: PPUSH
50387: EMPTY
50388: PPUSH
50389: CALL_OW 1
50393: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
50394: LD_ADDR_EXP 42
50398: PUSH
50399: LD_EXP 42
50403: PPUSH
50404: LD_VAR 0 4
50408: PPUSH
50409: EMPTY
50410: PPUSH
50411: CALL_OW 1
50415: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
50416: LD_ADDR_EXP 43
50420: PUSH
50421: LD_EXP 43
50425: PPUSH
50426: LD_VAR 0 4
50430: PPUSH
50431: EMPTY
50432: PPUSH
50433: CALL_OW 1
50437: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
50438: LD_ADDR_EXP 44
50442: PUSH
50443: LD_EXP 44
50447: PPUSH
50448: LD_VAR 0 4
50452: PPUSH
50453: EMPTY
50454: PPUSH
50455: CALL_OW 1
50459: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
50460: LD_ADDR_EXP 45
50464: PUSH
50465: LD_EXP 45
50469: PPUSH
50470: LD_VAR 0 4
50474: PPUSH
50475: EMPTY
50476: PPUSH
50477: CALL_OW 1
50481: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
50482: LD_ADDR_EXP 46
50486: PUSH
50487: LD_EXP 46
50491: PPUSH
50492: LD_VAR 0 4
50496: PPUSH
50497: EMPTY
50498: PPUSH
50499: CALL_OW 1
50503: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
50504: LD_ADDR_EXP 47
50508: PUSH
50509: LD_EXP 47
50513: PPUSH
50514: LD_VAR 0 4
50518: PPUSH
50519: EMPTY
50520: PPUSH
50521: CALL_OW 1
50525: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
50526: LD_ADDR_EXP 48
50530: PUSH
50531: LD_EXP 48
50535: PPUSH
50536: LD_VAR 0 4
50540: PPUSH
50541: EMPTY
50542: PPUSH
50543: CALL_OW 1
50547: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
50548: LD_ADDR_EXP 50
50552: PUSH
50553: LD_EXP 50
50557: PPUSH
50558: LD_VAR 0 4
50562: PPUSH
50563: EMPTY
50564: PPUSH
50565: CALL_OW 1
50569: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
50570: LD_ADDR_EXP 52
50574: PUSH
50575: LD_EXP 52
50579: PPUSH
50580: LD_VAR 0 4
50584: PPUSH
50585: EMPTY
50586: PPUSH
50587: CALL_OW 1
50591: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
50592: LD_ADDR_EXP 53
50596: PUSH
50597: LD_EXP 53
50601: PPUSH
50602: LD_VAR 0 4
50606: PPUSH
50607: EMPTY
50608: PPUSH
50609: CALL_OW 1
50613: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
50614: LD_ADDR_EXP 54
50618: PUSH
50619: LD_EXP 54
50623: PPUSH
50624: LD_VAR 0 4
50628: PPUSH
50629: EMPTY
50630: PPUSH
50631: CALL_OW 1
50635: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
50636: LD_ADDR_EXP 55
50640: PUSH
50641: LD_EXP 55
50645: PPUSH
50646: LD_VAR 0 4
50650: PPUSH
50651: EMPTY
50652: PPUSH
50653: CALL_OW 1
50657: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
50658: LD_ADDR_EXP 56
50662: PUSH
50663: LD_EXP 56
50667: PPUSH
50668: LD_VAR 0 4
50672: PPUSH
50673: EMPTY
50674: PPUSH
50675: CALL_OW 1
50679: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
50680: LD_ADDR_EXP 57
50684: PUSH
50685: LD_EXP 57
50689: PPUSH
50690: LD_VAR 0 4
50694: PPUSH
50695: EMPTY
50696: PPUSH
50697: CALL_OW 1
50701: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
50702: LD_ADDR_EXP 58
50706: PUSH
50707: LD_EXP 58
50711: PPUSH
50712: LD_VAR 0 4
50716: PPUSH
50717: EMPTY
50718: PPUSH
50719: CALL_OW 1
50723: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
50724: LD_ADDR_EXP 59
50728: PUSH
50729: LD_EXP 59
50733: PPUSH
50734: LD_VAR 0 4
50738: PPUSH
50739: EMPTY
50740: PPUSH
50741: CALL_OW 1
50745: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
50746: LD_ADDR_EXP 60
50750: PUSH
50751: LD_EXP 60
50755: PPUSH
50756: LD_VAR 0 4
50760: PPUSH
50761: EMPTY
50762: PPUSH
50763: CALL_OW 1
50767: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
50768: LD_ADDR_EXP 61
50772: PUSH
50773: LD_EXP 61
50777: PPUSH
50778: LD_VAR 0 4
50782: PPUSH
50783: EMPTY
50784: PPUSH
50785: CALL_OW 1
50789: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
50790: LD_ADDR_EXP 62
50794: PUSH
50795: LD_EXP 62
50799: PPUSH
50800: LD_VAR 0 4
50804: PPUSH
50805: EMPTY
50806: PPUSH
50807: CALL_OW 1
50811: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
50812: LD_ADDR_EXP 63
50816: PUSH
50817: LD_EXP 63
50821: PPUSH
50822: LD_VAR 0 4
50826: PPUSH
50827: EMPTY
50828: PPUSH
50829: CALL_OW 1
50833: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
50834: LD_ADDR_EXP 64
50838: PUSH
50839: LD_EXP 64
50843: PPUSH
50844: LD_VAR 0 4
50848: PPUSH
50849: EMPTY
50850: PPUSH
50851: CALL_OW 1
50855: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
50856: LD_ADDR_EXP 65
50860: PUSH
50861: LD_EXP 65
50865: PPUSH
50866: LD_VAR 0 4
50870: PPUSH
50871: LD_INT 0
50873: PPUSH
50874: CALL_OW 1
50878: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
50879: LD_ADDR_EXP 66
50883: PUSH
50884: LD_EXP 66
50888: PPUSH
50889: LD_VAR 0 4
50893: PPUSH
50894: LD_INT 0
50896: PPUSH
50897: CALL_OW 1
50901: ST_TO_ADDR
// result := base ;
50902: LD_ADDR_VAR 0 3
50906: PUSH
50907: LD_VAR 0 4
50911: ST_TO_ADDR
// end ;
50912: LD_VAR 0 3
50916: RET
// export function MC_Start ( ) ; var i ; begin
50917: LD_INT 0
50919: PPUSH
50920: PPUSH
// for i = 1 to mc_bases do
50921: LD_ADDR_VAR 0 2
50925: PUSH
50926: DOUBLE
50927: LD_INT 1
50929: DEC
50930: ST_TO_ADDR
50931: LD_EXP 23
50935: PUSH
50936: FOR_TO
50937: IFFALSE 52037
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
50939: LD_ADDR_EXP 23
50943: PUSH
50944: LD_EXP 23
50948: PPUSH
50949: LD_VAR 0 2
50953: PPUSH
50954: LD_EXP 23
50958: PUSH
50959: LD_VAR 0 2
50963: ARRAY
50964: PUSH
50965: LD_INT 0
50967: DIFF
50968: PPUSH
50969: CALL_OW 1
50973: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
50974: LD_ADDR_EXP 24
50978: PUSH
50979: LD_EXP 24
50983: PPUSH
50984: LD_VAR 0 2
50988: PPUSH
50989: EMPTY
50990: PPUSH
50991: CALL_OW 1
50995: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
50996: LD_ADDR_EXP 25
51000: PUSH
51001: LD_EXP 25
51005: PPUSH
51006: LD_VAR 0 2
51010: PPUSH
51011: EMPTY
51012: PPUSH
51013: CALL_OW 1
51017: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
51018: LD_ADDR_EXP 26
51022: PUSH
51023: LD_EXP 26
51027: PPUSH
51028: LD_VAR 0 2
51032: PPUSH
51033: EMPTY
51034: PPUSH
51035: CALL_OW 1
51039: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
51040: LD_ADDR_EXP 27
51044: PUSH
51045: LD_EXP 27
51049: PPUSH
51050: LD_VAR 0 2
51054: PPUSH
51055: EMPTY
51056: PUSH
51057: EMPTY
51058: PUSH
51059: EMPTY
51060: LIST
51061: LIST
51062: PPUSH
51063: CALL_OW 1
51067: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
51068: LD_ADDR_EXP 28
51072: PUSH
51073: LD_EXP 28
51077: PPUSH
51078: LD_VAR 0 2
51082: PPUSH
51083: EMPTY
51084: PPUSH
51085: CALL_OW 1
51089: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
51090: LD_ADDR_EXP 55
51094: PUSH
51095: LD_EXP 55
51099: PPUSH
51100: LD_VAR 0 2
51104: PPUSH
51105: EMPTY
51106: PPUSH
51107: CALL_OW 1
51111: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
51112: LD_ADDR_EXP 29
51116: PUSH
51117: LD_EXP 29
51121: PPUSH
51122: LD_VAR 0 2
51126: PPUSH
51127: EMPTY
51128: PPUSH
51129: CALL_OW 1
51133: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
51134: LD_ADDR_EXP 30
51138: PUSH
51139: LD_EXP 30
51143: PPUSH
51144: LD_VAR 0 2
51148: PPUSH
51149: EMPTY
51150: PPUSH
51151: CALL_OW 1
51155: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
51156: LD_ADDR_EXP 31
51160: PUSH
51161: LD_EXP 31
51165: PPUSH
51166: LD_VAR 0 2
51170: PPUSH
51171: LD_EXP 23
51175: PUSH
51176: LD_VAR 0 2
51180: ARRAY
51181: PPUSH
51182: LD_INT 2
51184: PUSH
51185: LD_INT 30
51187: PUSH
51188: LD_INT 32
51190: PUSH
51191: EMPTY
51192: LIST
51193: LIST
51194: PUSH
51195: LD_INT 30
51197: PUSH
51198: LD_INT 33
51200: PUSH
51201: EMPTY
51202: LIST
51203: LIST
51204: PUSH
51205: EMPTY
51206: LIST
51207: LIST
51208: LIST
51209: PPUSH
51210: CALL_OW 72
51214: PPUSH
51215: CALL_OW 1
51219: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
51220: LD_ADDR_EXP 32
51224: PUSH
51225: LD_EXP 32
51229: PPUSH
51230: LD_VAR 0 2
51234: PPUSH
51235: LD_EXP 23
51239: PUSH
51240: LD_VAR 0 2
51244: ARRAY
51245: PPUSH
51246: LD_INT 2
51248: PUSH
51249: LD_INT 30
51251: PUSH
51252: LD_INT 32
51254: PUSH
51255: EMPTY
51256: LIST
51257: LIST
51258: PUSH
51259: LD_INT 30
51261: PUSH
51262: LD_INT 31
51264: PUSH
51265: EMPTY
51266: LIST
51267: LIST
51268: PUSH
51269: EMPTY
51270: LIST
51271: LIST
51272: LIST
51273: PUSH
51274: LD_INT 58
51276: PUSH
51277: EMPTY
51278: LIST
51279: PUSH
51280: EMPTY
51281: LIST
51282: LIST
51283: PPUSH
51284: CALL_OW 72
51288: PPUSH
51289: CALL_OW 1
51293: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
51294: LD_ADDR_EXP 33
51298: PUSH
51299: LD_EXP 33
51303: PPUSH
51304: LD_VAR 0 2
51308: PPUSH
51309: EMPTY
51310: PPUSH
51311: CALL_OW 1
51315: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
51316: LD_ADDR_EXP 37
51320: PUSH
51321: LD_EXP 37
51325: PPUSH
51326: LD_VAR 0 2
51330: PPUSH
51331: EMPTY
51332: PPUSH
51333: CALL_OW 1
51337: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
51338: LD_ADDR_EXP 36
51342: PUSH
51343: LD_EXP 36
51347: PPUSH
51348: LD_VAR 0 2
51352: PPUSH
51353: EMPTY
51354: PPUSH
51355: CALL_OW 1
51359: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
51360: LD_ADDR_EXP 38
51364: PUSH
51365: LD_EXP 38
51369: PPUSH
51370: LD_VAR 0 2
51374: PPUSH
51375: EMPTY
51376: PPUSH
51377: CALL_OW 1
51381: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
51382: LD_ADDR_EXP 39
51386: PUSH
51387: LD_EXP 39
51391: PPUSH
51392: LD_VAR 0 2
51396: PPUSH
51397: EMPTY
51398: PPUSH
51399: CALL_OW 1
51403: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
51404: LD_ADDR_EXP 40
51408: PUSH
51409: LD_EXP 40
51413: PPUSH
51414: LD_VAR 0 2
51418: PPUSH
51419: EMPTY
51420: PPUSH
51421: CALL_OW 1
51425: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
51426: LD_ADDR_EXP 41
51430: PUSH
51431: LD_EXP 41
51435: PPUSH
51436: LD_VAR 0 2
51440: PPUSH
51441: EMPTY
51442: PPUSH
51443: CALL_OW 1
51447: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
51448: LD_ADDR_EXP 42
51452: PUSH
51453: LD_EXP 42
51457: PPUSH
51458: LD_VAR 0 2
51462: PPUSH
51463: EMPTY
51464: PPUSH
51465: CALL_OW 1
51469: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
51470: LD_ADDR_EXP 43
51474: PUSH
51475: LD_EXP 43
51479: PPUSH
51480: LD_VAR 0 2
51484: PPUSH
51485: EMPTY
51486: PPUSH
51487: CALL_OW 1
51491: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
51492: LD_ADDR_EXP 44
51496: PUSH
51497: LD_EXP 44
51501: PPUSH
51502: LD_VAR 0 2
51506: PPUSH
51507: EMPTY
51508: PPUSH
51509: CALL_OW 1
51513: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
51514: LD_ADDR_EXP 45
51518: PUSH
51519: LD_EXP 45
51523: PPUSH
51524: LD_VAR 0 2
51528: PPUSH
51529: EMPTY
51530: PPUSH
51531: CALL_OW 1
51535: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
51536: LD_ADDR_EXP 34
51540: PUSH
51541: LD_EXP 34
51545: PPUSH
51546: LD_VAR 0 2
51550: PPUSH
51551: LD_INT 0
51553: PPUSH
51554: CALL_OW 1
51558: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
51559: LD_ADDR_EXP 47
51563: PUSH
51564: LD_EXP 47
51568: PPUSH
51569: LD_VAR 0 2
51573: PPUSH
51574: LD_INT 0
51576: PPUSH
51577: CALL_OW 1
51581: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
51582: LD_ADDR_EXP 35
51586: PUSH
51587: LD_EXP 35
51591: PPUSH
51592: LD_VAR 0 2
51596: PPUSH
51597: EMPTY
51598: PPUSH
51599: CALL_OW 1
51603: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
51604: LD_ADDR_EXP 46
51608: PUSH
51609: LD_EXP 46
51613: PPUSH
51614: LD_VAR 0 2
51618: PPUSH
51619: LD_INT 0
51621: PPUSH
51622: CALL_OW 1
51626: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
51627: LD_ADDR_EXP 48
51631: PUSH
51632: LD_EXP 48
51636: PPUSH
51637: LD_VAR 0 2
51641: PPUSH
51642: EMPTY
51643: PPUSH
51644: CALL_OW 1
51648: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
51649: LD_ADDR_EXP 51
51653: PUSH
51654: LD_EXP 51
51658: PPUSH
51659: LD_VAR 0 2
51663: PPUSH
51664: LD_INT 0
51666: PPUSH
51667: CALL_OW 1
51671: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
51672: LD_ADDR_EXP 52
51676: PUSH
51677: LD_EXP 52
51681: PPUSH
51682: LD_VAR 0 2
51686: PPUSH
51687: EMPTY
51688: PPUSH
51689: CALL_OW 1
51693: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
51694: LD_ADDR_EXP 53
51698: PUSH
51699: LD_EXP 53
51703: PPUSH
51704: LD_VAR 0 2
51708: PPUSH
51709: EMPTY
51710: PPUSH
51711: CALL_OW 1
51715: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
51716: LD_ADDR_EXP 54
51720: PUSH
51721: LD_EXP 54
51725: PPUSH
51726: LD_VAR 0 2
51730: PPUSH
51731: EMPTY
51732: PPUSH
51733: CALL_OW 1
51737: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
51738: LD_ADDR_EXP 56
51742: PUSH
51743: LD_EXP 56
51747: PPUSH
51748: LD_VAR 0 2
51752: PPUSH
51753: LD_EXP 23
51757: PUSH
51758: LD_VAR 0 2
51762: ARRAY
51763: PPUSH
51764: LD_INT 2
51766: PUSH
51767: LD_INT 30
51769: PUSH
51770: LD_INT 6
51772: PUSH
51773: EMPTY
51774: LIST
51775: LIST
51776: PUSH
51777: LD_INT 30
51779: PUSH
51780: LD_INT 7
51782: PUSH
51783: EMPTY
51784: LIST
51785: LIST
51786: PUSH
51787: LD_INT 30
51789: PUSH
51790: LD_INT 8
51792: PUSH
51793: EMPTY
51794: LIST
51795: LIST
51796: PUSH
51797: EMPTY
51798: LIST
51799: LIST
51800: LIST
51801: LIST
51802: PPUSH
51803: CALL_OW 72
51807: PPUSH
51808: CALL_OW 1
51812: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
51813: LD_ADDR_EXP 57
51817: PUSH
51818: LD_EXP 57
51822: PPUSH
51823: LD_VAR 0 2
51827: PPUSH
51828: EMPTY
51829: PPUSH
51830: CALL_OW 1
51834: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
51835: LD_ADDR_EXP 58
51839: PUSH
51840: LD_EXP 58
51844: PPUSH
51845: LD_VAR 0 2
51849: PPUSH
51850: EMPTY
51851: PPUSH
51852: CALL_OW 1
51856: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
51857: LD_ADDR_EXP 59
51861: PUSH
51862: LD_EXP 59
51866: PPUSH
51867: LD_VAR 0 2
51871: PPUSH
51872: EMPTY
51873: PPUSH
51874: CALL_OW 1
51878: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
51879: LD_ADDR_EXP 60
51883: PUSH
51884: LD_EXP 60
51888: PPUSH
51889: LD_VAR 0 2
51893: PPUSH
51894: EMPTY
51895: PPUSH
51896: CALL_OW 1
51900: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
51901: LD_ADDR_EXP 61
51905: PUSH
51906: LD_EXP 61
51910: PPUSH
51911: LD_VAR 0 2
51915: PPUSH
51916: EMPTY
51917: PPUSH
51918: CALL_OW 1
51922: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
51923: LD_ADDR_EXP 62
51927: PUSH
51928: LD_EXP 62
51932: PPUSH
51933: LD_VAR 0 2
51937: PPUSH
51938: EMPTY
51939: PPUSH
51940: CALL_OW 1
51944: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
51945: LD_ADDR_EXP 63
51949: PUSH
51950: LD_EXP 63
51954: PPUSH
51955: LD_VAR 0 2
51959: PPUSH
51960: EMPTY
51961: PPUSH
51962: CALL_OW 1
51966: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
51967: LD_ADDR_EXP 64
51971: PUSH
51972: LD_EXP 64
51976: PPUSH
51977: LD_VAR 0 2
51981: PPUSH
51982: EMPTY
51983: PPUSH
51984: CALL_OW 1
51988: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
51989: LD_ADDR_EXP 65
51993: PUSH
51994: LD_EXP 65
51998: PPUSH
51999: LD_VAR 0 2
52003: PPUSH
52004: LD_INT 0
52006: PPUSH
52007: CALL_OW 1
52011: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
52012: LD_ADDR_EXP 66
52016: PUSH
52017: LD_EXP 66
52021: PPUSH
52022: LD_VAR 0 2
52026: PPUSH
52027: LD_INT 0
52029: PPUSH
52030: CALL_OW 1
52034: ST_TO_ADDR
// end ;
52035: GO 50936
52037: POP
52038: POP
// MC_InitSides ( ) ;
52039: CALL 52325 0 0
// MC_InitResearch ( ) ;
52043: CALL 52064 0 0
// CustomInitMacro ( ) ;
52047: CALL 277 0 0
// skirmish := true ;
52051: LD_ADDR_EXP 21
52055: PUSH
52056: LD_INT 1
52058: ST_TO_ADDR
// end ;
52059: LD_VAR 0 1
52063: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
52064: LD_INT 0
52066: PPUSH
52067: PPUSH
52068: PPUSH
52069: PPUSH
52070: PPUSH
52071: PPUSH
// if not mc_bases then
52072: LD_EXP 23
52076: NOT
52077: IFFALSE 52081
// exit ;
52079: GO 52320
// for i = 1 to 8 do
52081: LD_ADDR_VAR 0 2
52085: PUSH
52086: DOUBLE
52087: LD_INT 1
52089: DEC
52090: ST_TO_ADDR
52091: LD_INT 8
52093: PUSH
52094: FOR_TO
52095: IFFALSE 52121
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
52097: LD_ADDR_EXP 50
52101: PUSH
52102: LD_EXP 50
52106: PPUSH
52107: LD_VAR 0 2
52111: PPUSH
52112: EMPTY
52113: PPUSH
52114: CALL_OW 1
52118: ST_TO_ADDR
52119: GO 52094
52121: POP
52122: POP
// tmp := [ ] ;
52123: LD_ADDR_VAR 0 5
52127: PUSH
52128: EMPTY
52129: ST_TO_ADDR
// for i = 1 to mc_sides do
52130: LD_ADDR_VAR 0 2
52134: PUSH
52135: DOUBLE
52136: LD_INT 1
52138: DEC
52139: ST_TO_ADDR
52140: LD_EXP 49
52144: PUSH
52145: FOR_TO
52146: IFFALSE 52204
// if not mc_sides [ i ] in tmp then
52148: LD_EXP 49
52152: PUSH
52153: LD_VAR 0 2
52157: ARRAY
52158: PUSH
52159: LD_VAR 0 5
52163: IN
52164: NOT
52165: IFFALSE 52202
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
52167: LD_ADDR_VAR 0 5
52171: PUSH
52172: LD_VAR 0 5
52176: PPUSH
52177: LD_VAR 0 5
52181: PUSH
52182: LD_INT 1
52184: PLUS
52185: PPUSH
52186: LD_EXP 49
52190: PUSH
52191: LD_VAR 0 2
52195: ARRAY
52196: PPUSH
52197: CALL_OW 2
52201: ST_TO_ADDR
52202: GO 52145
52204: POP
52205: POP
// if not tmp then
52206: LD_VAR 0 5
52210: NOT
52211: IFFALSE 52215
// exit ;
52213: GO 52320
// for j in tmp do
52215: LD_ADDR_VAR 0 3
52219: PUSH
52220: LD_VAR 0 5
52224: PUSH
52225: FOR_IN
52226: IFFALSE 52318
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
52228: LD_ADDR_VAR 0 6
52232: PUSH
52233: LD_INT 22
52235: PUSH
52236: LD_VAR 0 3
52240: PUSH
52241: EMPTY
52242: LIST
52243: LIST
52244: PPUSH
52245: CALL_OW 69
52249: ST_TO_ADDR
// if not un then
52250: LD_VAR 0 6
52254: NOT
52255: IFFALSE 52259
// continue ;
52257: GO 52225
// nation := GetNation ( un [ 1 ] ) ;
52259: LD_ADDR_VAR 0 4
52263: PUSH
52264: LD_VAR 0 6
52268: PUSH
52269: LD_INT 1
52271: ARRAY
52272: PPUSH
52273: CALL_OW 248
52277: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
52278: LD_ADDR_EXP 50
52282: PUSH
52283: LD_EXP 50
52287: PPUSH
52288: LD_VAR 0 3
52292: PPUSH
52293: LD_VAR 0 3
52297: PPUSH
52298: LD_VAR 0 4
52302: PPUSH
52303: LD_INT 1
52305: PPUSH
52306: CALL 10060 0 3
52310: PPUSH
52311: CALL_OW 1
52315: ST_TO_ADDR
// end ;
52316: GO 52225
52318: POP
52319: POP
// end ;
52320: LD_VAR 0 1
52324: RET
// export function MC_InitSides ( ) ; var i ; begin
52325: LD_INT 0
52327: PPUSH
52328: PPUSH
// if not mc_bases then
52329: LD_EXP 23
52333: NOT
52334: IFFALSE 52338
// exit ;
52336: GO 52412
// for i = 1 to mc_bases do
52338: LD_ADDR_VAR 0 2
52342: PUSH
52343: DOUBLE
52344: LD_INT 1
52346: DEC
52347: ST_TO_ADDR
52348: LD_EXP 23
52352: PUSH
52353: FOR_TO
52354: IFFALSE 52410
// if mc_bases [ i ] then
52356: LD_EXP 23
52360: PUSH
52361: LD_VAR 0 2
52365: ARRAY
52366: IFFALSE 52408
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
52368: LD_ADDR_EXP 49
52372: PUSH
52373: LD_EXP 49
52377: PPUSH
52378: LD_VAR 0 2
52382: PPUSH
52383: LD_EXP 23
52387: PUSH
52388: LD_VAR 0 2
52392: ARRAY
52393: PUSH
52394: LD_INT 1
52396: ARRAY
52397: PPUSH
52398: CALL_OW 255
52402: PPUSH
52403: CALL_OW 1
52407: ST_TO_ADDR
52408: GO 52353
52410: POP
52411: POP
// end ;
52412: LD_VAR 0 1
52416: RET
// every 0 0$03 trigger skirmish do
52417: LD_EXP 21
52421: IFFALSE 52575
52423: GO 52425
52425: DISABLE
// begin enable ;
52426: ENABLE
// MC_CheckBuildings ( ) ;
52427: CALL 57073 0 0
// MC_CheckPeopleLife ( ) ;
52431: CALL 57198 0 0
// RaiseSailEvent ( 100 ) ;
52435: LD_INT 100
52437: PPUSH
52438: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
52442: LD_INT 103
52444: PPUSH
52445: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
52449: LD_INT 104
52451: PPUSH
52452: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
52456: LD_INT 105
52458: PPUSH
52459: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
52463: LD_INT 106
52465: PPUSH
52466: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
52470: LD_INT 107
52472: PPUSH
52473: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
52477: LD_INT 108
52479: PPUSH
52480: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
52484: LD_INT 109
52486: PPUSH
52487: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
52491: LD_INT 110
52493: PPUSH
52494: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
52498: LD_INT 111
52500: PPUSH
52501: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
52505: LD_INT 112
52507: PPUSH
52508: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
52512: LD_INT 113
52514: PPUSH
52515: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
52519: LD_INT 120
52521: PPUSH
52522: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
52526: LD_INT 121
52528: PPUSH
52529: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
52533: LD_INT 122
52535: PPUSH
52536: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
52540: LD_INT 123
52542: PPUSH
52543: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
52547: LD_INT 124
52549: PPUSH
52550: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
52554: LD_INT 125
52556: PPUSH
52557: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
52561: LD_INT 126
52563: PPUSH
52564: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
52568: LD_INT 200
52570: PPUSH
52571: CALL_OW 427
// end ;
52575: END
// on SailEvent ( event ) do begin if event < 100 then
52576: LD_VAR 0 1
52580: PUSH
52581: LD_INT 100
52583: LESS
52584: IFFALSE 52595
// CustomEvent ( event ) ;
52586: LD_VAR 0 1
52590: PPUSH
52591: CALL 9234 0 1
// if event = 100 then
52595: LD_VAR 0 1
52599: PUSH
52600: LD_INT 100
52602: EQUAL
52603: IFFALSE 52609
// MC_ClassManager ( ) ;
52605: CALL 53001 0 0
// if event = 101 then
52609: LD_VAR 0 1
52613: PUSH
52614: LD_INT 101
52616: EQUAL
52617: IFFALSE 52623
// MC_RepairBuildings ( ) ;
52619: CALL 57783 0 0
// if event = 102 then
52623: LD_VAR 0 1
52627: PUSH
52628: LD_INT 102
52630: EQUAL
52631: IFFALSE 52637
// MC_Heal ( ) ;
52633: CALL 58668 0 0
// if event = 103 then
52637: LD_VAR 0 1
52641: PUSH
52642: LD_INT 103
52644: EQUAL
52645: IFFALSE 52651
// MC_Build ( ) ;
52647: CALL 59090 0 0
// if event = 104 then
52651: LD_VAR 0 1
52655: PUSH
52656: LD_INT 104
52658: EQUAL
52659: IFFALSE 52665
// MC_TurretWeapon ( ) ;
52661: CALL 60731 0 0
// if event = 105 then
52665: LD_VAR 0 1
52669: PUSH
52670: LD_INT 105
52672: EQUAL
52673: IFFALSE 52679
// MC_BuildUpgrade ( ) ;
52675: CALL 60282 0 0
// if event = 106 then
52679: LD_VAR 0 1
52683: PUSH
52684: LD_INT 106
52686: EQUAL
52687: IFFALSE 52693
// MC_PlantMines ( ) ;
52689: CALL 61161 0 0
// if event = 107 then
52693: LD_VAR 0 1
52697: PUSH
52698: LD_INT 107
52700: EQUAL
52701: IFFALSE 52707
// MC_CollectCrates ( ) ;
52703: CALL 61952 0 0
// if event = 108 then
52707: LD_VAR 0 1
52711: PUSH
52712: LD_INT 108
52714: EQUAL
52715: IFFALSE 52721
// MC_LinkRemoteControl ( ) ;
52717: CALL 63802 0 0
// if event = 109 then
52721: LD_VAR 0 1
52725: PUSH
52726: LD_INT 109
52728: EQUAL
52729: IFFALSE 52735
// MC_ProduceVehicle ( ) ;
52731: CALL 63983 0 0
// if event = 110 then
52735: LD_VAR 0 1
52739: PUSH
52740: LD_INT 110
52742: EQUAL
52743: IFFALSE 52749
// MC_SendAttack ( ) ;
52745: CALL 64449 0 0
// if event = 111 then
52749: LD_VAR 0 1
52753: PUSH
52754: LD_INT 111
52756: EQUAL
52757: IFFALSE 52763
// MC_Defend ( ) ;
52759: CALL 64557 0 0
// if event = 112 then
52763: LD_VAR 0 1
52767: PUSH
52768: LD_INT 112
52770: EQUAL
52771: IFFALSE 52777
// MC_Research ( ) ;
52773: CALL 65290 0 0
// if event = 113 then
52777: LD_VAR 0 1
52781: PUSH
52782: LD_INT 113
52784: EQUAL
52785: IFFALSE 52791
// MC_MinesTrigger ( ) ;
52787: CALL 66404 0 0
// if event = 120 then
52791: LD_VAR 0 1
52795: PUSH
52796: LD_INT 120
52798: EQUAL
52799: IFFALSE 52805
// MC_RepairVehicle ( ) ;
52801: CALL 66503 0 0
// if event = 121 then
52805: LD_VAR 0 1
52809: PUSH
52810: LD_INT 121
52812: EQUAL
52813: IFFALSE 52819
// MC_TameApe ( ) ;
52815: CALL 67244 0 0
// if event = 122 then
52819: LD_VAR 0 1
52823: PUSH
52824: LD_INT 122
52826: EQUAL
52827: IFFALSE 52833
// MC_ChangeApeClass ( ) ;
52829: CALL 68073 0 0
// if event = 123 then
52833: LD_VAR 0 1
52837: PUSH
52838: LD_INT 123
52840: EQUAL
52841: IFFALSE 52847
// MC_Bazooka ( ) ;
52843: CALL 68723 0 0
// if event = 124 then
52847: LD_VAR 0 1
52851: PUSH
52852: LD_INT 124
52854: EQUAL
52855: IFFALSE 52861
// MC_TeleportExit ( ) ;
52857: CALL 68921 0 0
// if event = 125 then
52861: LD_VAR 0 1
52865: PUSH
52866: LD_INT 125
52868: EQUAL
52869: IFFALSE 52875
// MC_Deposits ( ) ;
52871: CALL 69568 0 0
// if event = 126 then
52875: LD_VAR 0 1
52879: PUSH
52880: LD_INT 126
52882: EQUAL
52883: IFFALSE 52889
// MC_RemoteDriver ( ) ;
52885: CALL 70193 0 0
// if event = 200 then
52889: LD_VAR 0 1
52893: PUSH
52894: LD_INT 200
52896: EQUAL
52897: IFFALSE 52903
// MC_Idle ( ) ;
52899: CALL 72142 0 0
// end ;
52903: PPOPN 1
52905: END
// export function MC_Reset ( base , tag ) ; var i ; begin
52906: LD_INT 0
52908: PPUSH
52909: PPUSH
// if not mc_bases [ base ] or not tag then
52910: LD_EXP 23
52914: PUSH
52915: LD_VAR 0 1
52919: ARRAY
52920: NOT
52921: PUSH
52922: LD_VAR 0 2
52926: NOT
52927: OR
52928: IFFALSE 52932
// exit ;
52930: GO 52996
// for i in mc_bases [ base ] union mc_ape [ base ] do
52932: LD_ADDR_VAR 0 4
52936: PUSH
52937: LD_EXP 23
52941: PUSH
52942: LD_VAR 0 1
52946: ARRAY
52947: PUSH
52948: LD_EXP 52
52952: PUSH
52953: LD_VAR 0 1
52957: ARRAY
52958: UNION
52959: PUSH
52960: FOR_IN
52961: IFFALSE 52994
// if GetTag ( i ) = tag then
52963: LD_VAR 0 4
52967: PPUSH
52968: CALL_OW 110
52972: PUSH
52973: LD_VAR 0 2
52977: EQUAL
52978: IFFALSE 52992
// SetTag ( i , 0 ) ;
52980: LD_VAR 0 4
52984: PPUSH
52985: LD_INT 0
52987: PPUSH
52988: CALL_OW 109
52992: GO 52960
52994: POP
52995: POP
// end ;
52996: LD_VAR 0 3
53000: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
53001: LD_INT 0
53003: PPUSH
53004: PPUSH
53005: PPUSH
53006: PPUSH
53007: PPUSH
53008: PPUSH
53009: PPUSH
53010: PPUSH
// if not mc_bases then
53011: LD_EXP 23
53015: NOT
53016: IFFALSE 53020
// exit ;
53018: GO 53478
// for i = 1 to mc_bases do
53020: LD_ADDR_VAR 0 2
53024: PUSH
53025: DOUBLE
53026: LD_INT 1
53028: DEC
53029: ST_TO_ADDR
53030: LD_EXP 23
53034: PUSH
53035: FOR_TO
53036: IFFALSE 53476
// begin tmp := MC_ClassCheckReq ( i ) ;
53038: LD_ADDR_VAR 0 4
53042: PUSH
53043: LD_VAR 0 2
53047: PPUSH
53048: CALL 53483 0 1
53052: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
53053: LD_ADDR_EXP 64
53057: PUSH
53058: LD_EXP 64
53062: PPUSH
53063: LD_VAR 0 2
53067: PPUSH
53068: LD_VAR 0 4
53072: PPUSH
53073: CALL_OW 1
53077: ST_TO_ADDR
// if not tmp then
53078: LD_VAR 0 4
53082: NOT
53083: IFFALSE 53087
// continue ;
53085: GO 53035
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
53087: LD_ADDR_VAR 0 6
53091: PUSH
53092: LD_EXP 23
53096: PUSH
53097: LD_VAR 0 2
53101: ARRAY
53102: PPUSH
53103: LD_INT 2
53105: PUSH
53106: LD_INT 30
53108: PUSH
53109: LD_INT 4
53111: PUSH
53112: EMPTY
53113: LIST
53114: LIST
53115: PUSH
53116: LD_INT 30
53118: PUSH
53119: LD_INT 5
53121: PUSH
53122: EMPTY
53123: LIST
53124: LIST
53125: PUSH
53126: EMPTY
53127: LIST
53128: LIST
53129: LIST
53130: PPUSH
53131: CALL_OW 72
53135: PUSH
53136: LD_EXP 23
53140: PUSH
53141: LD_VAR 0 2
53145: ARRAY
53146: PPUSH
53147: LD_INT 2
53149: PUSH
53150: LD_INT 30
53152: PUSH
53153: LD_INT 0
53155: PUSH
53156: EMPTY
53157: LIST
53158: LIST
53159: PUSH
53160: LD_INT 30
53162: PUSH
53163: LD_INT 1
53165: PUSH
53166: EMPTY
53167: LIST
53168: LIST
53169: PUSH
53170: EMPTY
53171: LIST
53172: LIST
53173: LIST
53174: PPUSH
53175: CALL_OW 72
53179: PUSH
53180: LD_EXP 23
53184: PUSH
53185: LD_VAR 0 2
53189: ARRAY
53190: PPUSH
53191: LD_INT 30
53193: PUSH
53194: LD_INT 3
53196: PUSH
53197: EMPTY
53198: LIST
53199: LIST
53200: PPUSH
53201: CALL_OW 72
53205: PUSH
53206: LD_EXP 23
53210: PUSH
53211: LD_VAR 0 2
53215: ARRAY
53216: PPUSH
53217: LD_INT 2
53219: PUSH
53220: LD_INT 30
53222: PUSH
53223: LD_INT 6
53225: PUSH
53226: EMPTY
53227: LIST
53228: LIST
53229: PUSH
53230: LD_INT 30
53232: PUSH
53233: LD_INT 7
53235: PUSH
53236: EMPTY
53237: LIST
53238: LIST
53239: PUSH
53240: LD_INT 30
53242: PUSH
53243: LD_INT 8
53245: PUSH
53246: EMPTY
53247: LIST
53248: LIST
53249: PUSH
53250: EMPTY
53251: LIST
53252: LIST
53253: LIST
53254: LIST
53255: PPUSH
53256: CALL_OW 72
53260: PUSH
53261: EMPTY
53262: LIST
53263: LIST
53264: LIST
53265: LIST
53266: ST_TO_ADDR
// for j = 1 to 4 do
53267: LD_ADDR_VAR 0 3
53271: PUSH
53272: DOUBLE
53273: LD_INT 1
53275: DEC
53276: ST_TO_ADDR
53277: LD_INT 4
53279: PUSH
53280: FOR_TO
53281: IFFALSE 53472
// begin if not tmp [ j ] then
53283: LD_VAR 0 4
53287: PUSH
53288: LD_VAR 0 3
53292: ARRAY
53293: NOT
53294: IFFALSE 53298
// continue ;
53296: GO 53280
// for p in tmp [ j ] do
53298: LD_ADDR_VAR 0 5
53302: PUSH
53303: LD_VAR 0 4
53307: PUSH
53308: LD_VAR 0 3
53312: ARRAY
53313: PUSH
53314: FOR_IN
53315: IFFALSE 53468
// begin if not b [ j ] then
53317: LD_VAR 0 6
53321: PUSH
53322: LD_VAR 0 3
53326: ARRAY
53327: NOT
53328: IFFALSE 53332
// break ;
53330: GO 53468
// e := 0 ;
53332: LD_ADDR_VAR 0 7
53336: PUSH
53337: LD_INT 0
53339: ST_TO_ADDR
// for k in b [ j ] do
53340: LD_ADDR_VAR 0 8
53344: PUSH
53345: LD_VAR 0 6
53349: PUSH
53350: LD_VAR 0 3
53354: ARRAY
53355: PUSH
53356: FOR_IN
53357: IFFALSE 53384
// if IsNotFull ( k ) then
53359: LD_VAR 0 8
53363: PPUSH
53364: CALL 12213 0 1
53368: IFFALSE 53382
// begin e := k ;
53370: LD_ADDR_VAR 0 7
53374: PUSH
53375: LD_VAR 0 8
53379: ST_TO_ADDR
// break ;
53380: GO 53384
// end ;
53382: GO 53356
53384: POP
53385: POP
// if e and not UnitGoingToBuilding ( p , e ) then
53386: LD_VAR 0 7
53390: PUSH
53391: LD_VAR 0 5
53395: PPUSH
53396: LD_VAR 0 7
53400: PPUSH
53401: CALL 45378 0 2
53405: NOT
53406: AND
53407: IFFALSE 53466
// begin if IsInUnit ( p ) then
53409: LD_VAR 0 5
53413: PPUSH
53414: CALL_OW 310
53418: IFFALSE 53429
// ComExitBuilding ( p ) ;
53420: LD_VAR 0 5
53424: PPUSH
53425: CALL_OW 122
// ComEnterUnit ( p , e ) ;
53429: LD_VAR 0 5
53433: PPUSH
53434: LD_VAR 0 7
53438: PPUSH
53439: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
53443: LD_VAR 0 5
53447: PPUSH
53448: LD_VAR 0 3
53452: PPUSH
53453: CALL_OW 183
// AddComExitBuilding ( p ) ;
53457: LD_VAR 0 5
53461: PPUSH
53462: CALL_OW 182
// end ; end ;
53466: GO 53314
53468: POP
53469: POP
// end ;
53470: GO 53280
53472: POP
53473: POP
// end ;
53474: GO 53035
53476: POP
53477: POP
// end ;
53478: LD_VAR 0 1
53482: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
53483: LD_INT 0
53485: PPUSH
53486: PPUSH
53487: PPUSH
53488: PPUSH
53489: PPUSH
53490: PPUSH
53491: PPUSH
53492: PPUSH
53493: PPUSH
53494: PPUSH
53495: PPUSH
53496: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
53497: LD_VAR 0 1
53501: NOT
53502: PUSH
53503: LD_EXP 23
53507: PUSH
53508: LD_VAR 0 1
53512: ARRAY
53513: NOT
53514: OR
53515: PUSH
53516: LD_EXP 23
53520: PUSH
53521: LD_VAR 0 1
53525: ARRAY
53526: PPUSH
53527: LD_INT 2
53529: PUSH
53530: LD_INT 30
53532: PUSH
53533: LD_INT 0
53535: PUSH
53536: EMPTY
53537: LIST
53538: LIST
53539: PUSH
53540: LD_INT 30
53542: PUSH
53543: LD_INT 1
53545: PUSH
53546: EMPTY
53547: LIST
53548: LIST
53549: PUSH
53550: EMPTY
53551: LIST
53552: LIST
53553: LIST
53554: PPUSH
53555: CALL_OW 72
53559: NOT
53560: OR
53561: IFFALSE 53565
// exit ;
53563: GO 57068
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
53565: LD_ADDR_VAR 0 4
53569: PUSH
53570: LD_EXP 23
53574: PUSH
53575: LD_VAR 0 1
53579: ARRAY
53580: PPUSH
53581: LD_INT 2
53583: PUSH
53584: LD_INT 25
53586: PUSH
53587: LD_INT 1
53589: PUSH
53590: EMPTY
53591: LIST
53592: LIST
53593: PUSH
53594: LD_INT 25
53596: PUSH
53597: LD_INT 2
53599: PUSH
53600: EMPTY
53601: LIST
53602: LIST
53603: PUSH
53604: LD_INT 25
53606: PUSH
53607: LD_INT 3
53609: PUSH
53610: EMPTY
53611: LIST
53612: LIST
53613: PUSH
53614: LD_INT 25
53616: PUSH
53617: LD_INT 4
53619: PUSH
53620: EMPTY
53621: LIST
53622: LIST
53623: PUSH
53624: LD_INT 25
53626: PUSH
53627: LD_INT 5
53629: PUSH
53630: EMPTY
53631: LIST
53632: LIST
53633: PUSH
53634: LD_INT 25
53636: PUSH
53637: LD_INT 8
53639: PUSH
53640: EMPTY
53641: LIST
53642: LIST
53643: PUSH
53644: LD_INT 25
53646: PUSH
53647: LD_INT 9
53649: PUSH
53650: EMPTY
53651: LIST
53652: LIST
53653: PUSH
53654: EMPTY
53655: LIST
53656: LIST
53657: LIST
53658: LIST
53659: LIST
53660: LIST
53661: LIST
53662: LIST
53663: PPUSH
53664: CALL_OW 72
53668: ST_TO_ADDR
// if not tmp then
53669: LD_VAR 0 4
53673: NOT
53674: IFFALSE 53678
// exit ;
53676: GO 57068
// for i in tmp do
53678: LD_ADDR_VAR 0 3
53682: PUSH
53683: LD_VAR 0 4
53687: PUSH
53688: FOR_IN
53689: IFFALSE 53720
// if GetTag ( i ) then
53691: LD_VAR 0 3
53695: PPUSH
53696: CALL_OW 110
53700: IFFALSE 53718
// tmp := tmp diff i ;
53702: LD_ADDR_VAR 0 4
53706: PUSH
53707: LD_VAR 0 4
53711: PUSH
53712: LD_VAR 0 3
53716: DIFF
53717: ST_TO_ADDR
53718: GO 53688
53720: POP
53721: POP
// if not tmp then
53722: LD_VAR 0 4
53726: NOT
53727: IFFALSE 53731
// exit ;
53729: GO 57068
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
53731: LD_ADDR_VAR 0 5
53735: PUSH
53736: LD_EXP 23
53740: PUSH
53741: LD_VAR 0 1
53745: ARRAY
53746: PPUSH
53747: LD_INT 2
53749: PUSH
53750: LD_INT 25
53752: PUSH
53753: LD_INT 1
53755: PUSH
53756: EMPTY
53757: LIST
53758: LIST
53759: PUSH
53760: LD_INT 25
53762: PUSH
53763: LD_INT 5
53765: PUSH
53766: EMPTY
53767: LIST
53768: LIST
53769: PUSH
53770: LD_INT 25
53772: PUSH
53773: LD_INT 8
53775: PUSH
53776: EMPTY
53777: LIST
53778: LIST
53779: PUSH
53780: LD_INT 25
53782: PUSH
53783: LD_INT 9
53785: PUSH
53786: EMPTY
53787: LIST
53788: LIST
53789: PUSH
53790: EMPTY
53791: LIST
53792: LIST
53793: LIST
53794: LIST
53795: LIST
53796: PPUSH
53797: CALL_OW 72
53801: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
53802: LD_ADDR_VAR 0 6
53806: PUSH
53807: LD_EXP 23
53811: PUSH
53812: LD_VAR 0 1
53816: ARRAY
53817: PPUSH
53818: LD_INT 25
53820: PUSH
53821: LD_INT 2
53823: PUSH
53824: EMPTY
53825: LIST
53826: LIST
53827: PPUSH
53828: CALL_OW 72
53832: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
53833: LD_ADDR_VAR 0 7
53837: PUSH
53838: LD_EXP 23
53842: PUSH
53843: LD_VAR 0 1
53847: ARRAY
53848: PPUSH
53849: LD_INT 25
53851: PUSH
53852: LD_INT 3
53854: PUSH
53855: EMPTY
53856: LIST
53857: LIST
53858: PPUSH
53859: CALL_OW 72
53863: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
53864: LD_ADDR_VAR 0 8
53868: PUSH
53869: LD_EXP 23
53873: PUSH
53874: LD_VAR 0 1
53878: ARRAY
53879: PPUSH
53880: LD_INT 25
53882: PUSH
53883: LD_INT 4
53885: PUSH
53886: EMPTY
53887: LIST
53888: LIST
53889: PUSH
53890: LD_INT 24
53892: PUSH
53893: LD_INT 251
53895: PUSH
53896: EMPTY
53897: LIST
53898: LIST
53899: PUSH
53900: EMPTY
53901: LIST
53902: LIST
53903: PPUSH
53904: CALL_OW 72
53908: ST_TO_ADDR
// if mc_is_defending [ base ] then
53909: LD_EXP 66
53913: PUSH
53914: LD_VAR 0 1
53918: ARRAY
53919: IFFALSE 54380
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
53921: LD_ADDR_EXP 65
53925: PUSH
53926: LD_EXP 65
53930: PPUSH
53931: LD_VAR 0 1
53935: PPUSH
53936: LD_INT 4
53938: PPUSH
53939: CALL_OW 1
53943: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
53944: LD_ADDR_VAR 0 12
53948: PUSH
53949: LD_EXP 23
53953: PUSH
53954: LD_VAR 0 1
53958: ARRAY
53959: PPUSH
53960: LD_INT 2
53962: PUSH
53963: LD_INT 30
53965: PUSH
53966: LD_INT 4
53968: PUSH
53969: EMPTY
53970: LIST
53971: LIST
53972: PUSH
53973: LD_INT 30
53975: PUSH
53976: LD_INT 5
53978: PUSH
53979: EMPTY
53980: LIST
53981: LIST
53982: PUSH
53983: EMPTY
53984: LIST
53985: LIST
53986: LIST
53987: PPUSH
53988: CALL_OW 72
53992: ST_TO_ADDR
// if not b then
53993: LD_VAR 0 12
53997: NOT
53998: IFFALSE 54002
// exit ;
54000: GO 57068
// p := [ ] ;
54002: LD_ADDR_VAR 0 11
54006: PUSH
54007: EMPTY
54008: ST_TO_ADDR
// if sci >= 2 then
54009: LD_VAR 0 8
54013: PUSH
54014: LD_INT 2
54016: GREATEREQUAL
54017: IFFALSE 54048
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
54019: LD_ADDR_VAR 0 8
54023: PUSH
54024: LD_VAR 0 8
54028: PUSH
54029: LD_INT 1
54031: ARRAY
54032: PUSH
54033: LD_VAR 0 8
54037: PUSH
54038: LD_INT 2
54040: ARRAY
54041: PUSH
54042: EMPTY
54043: LIST
54044: LIST
54045: ST_TO_ADDR
54046: GO 54109
// if sci = 1 then
54048: LD_VAR 0 8
54052: PUSH
54053: LD_INT 1
54055: EQUAL
54056: IFFALSE 54077
// sci := [ sci [ 1 ] ] else
54058: LD_ADDR_VAR 0 8
54062: PUSH
54063: LD_VAR 0 8
54067: PUSH
54068: LD_INT 1
54070: ARRAY
54071: PUSH
54072: EMPTY
54073: LIST
54074: ST_TO_ADDR
54075: GO 54109
// if sci = 0 then
54077: LD_VAR 0 8
54081: PUSH
54082: LD_INT 0
54084: EQUAL
54085: IFFALSE 54109
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
54087: LD_ADDR_VAR 0 11
54091: PUSH
54092: LD_VAR 0 4
54096: PPUSH
54097: LD_INT 4
54099: PPUSH
54100: CALL 45241 0 2
54104: PUSH
54105: LD_INT 1
54107: ARRAY
54108: ST_TO_ADDR
// if eng > 4 then
54109: LD_VAR 0 6
54113: PUSH
54114: LD_INT 4
54116: GREATER
54117: IFFALSE 54163
// for i = eng downto 4 do
54119: LD_ADDR_VAR 0 3
54123: PUSH
54124: DOUBLE
54125: LD_VAR 0 6
54129: INC
54130: ST_TO_ADDR
54131: LD_INT 4
54133: PUSH
54134: FOR_DOWNTO
54135: IFFALSE 54161
// eng := eng diff eng [ i ] ;
54137: LD_ADDR_VAR 0 6
54141: PUSH
54142: LD_VAR 0 6
54146: PUSH
54147: LD_VAR 0 6
54151: PUSH
54152: LD_VAR 0 3
54156: ARRAY
54157: DIFF
54158: ST_TO_ADDR
54159: GO 54134
54161: POP
54162: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
54163: LD_ADDR_VAR 0 4
54167: PUSH
54168: LD_VAR 0 4
54172: PUSH
54173: LD_VAR 0 5
54177: PUSH
54178: LD_VAR 0 6
54182: UNION
54183: PUSH
54184: LD_VAR 0 7
54188: UNION
54189: PUSH
54190: LD_VAR 0 8
54194: UNION
54195: DIFF
54196: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
54197: LD_ADDR_VAR 0 13
54201: PUSH
54202: LD_EXP 23
54206: PUSH
54207: LD_VAR 0 1
54211: ARRAY
54212: PPUSH
54213: LD_INT 2
54215: PUSH
54216: LD_INT 30
54218: PUSH
54219: LD_INT 32
54221: PUSH
54222: EMPTY
54223: LIST
54224: LIST
54225: PUSH
54226: LD_INT 30
54228: PUSH
54229: LD_INT 31
54231: PUSH
54232: EMPTY
54233: LIST
54234: LIST
54235: PUSH
54236: EMPTY
54237: LIST
54238: LIST
54239: LIST
54240: PPUSH
54241: CALL_OW 72
54245: PUSH
54246: LD_EXP 23
54250: PUSH
54251: LD_VAR 0 1
54255: ARRAY
54256: PPUSH
54257: LD_INT 2
54259: PUSH
54260: LD_INT 30
54262: PUSH
54263: LD_INT 4
54265: PUSH
54266: EMPTY
54267: LIST
54268: LIST
54269: PUSH
54270: LD_INT 30
54272: PUSH
54273: LD_INT 5
54275: PUSH
54276: EMPTY
54277: LIST
54278: LIST
54279: PUSH
54280: EMPTY
54281: LIST
54282: LIST
54283: LIST
54284: PPUSH
54285: CALL_OW 72
54289: PUSH
54290: LD_INT 6
54292: MUL
54293: PLUS
54294: ST_TO_ADDR
// if bcount < tmp then
54295: LD_VAR 0 13
54299: PUSH
54300: LD_VAR 0 4
54304: LESS
54305: IFFALSE 54351
// for i = tmp downto bcount do
54307: LD_ADDR_VAR 0 3
54311: PUSH
54312: DOUBLE
54313: LD_VAR 0 4
54317: INC
54318: ST_TO_ADDR
54319: LD_VAR 0 13
54323: PUSH
54324: FOR_DOWNTO
54325: IFFALSE 54349
// tmp := Delete ( tmp , tmp ) ;
54327: LD_ADDR_VAR 0 4
54331: PUSH
54332: LD_VAR 0 4
54336: PPUSH
54337: LD_VAR 0 4
54341: PPUSH
54342: CALL_OW 3
54346: ST_TO_ADDR
54347: GO 54324
54349: POP
54350: POP
// result := [ tmp , 0 , 0 , p ] ;
54351: LD_ADDR_VAR 0 2
54355: PUSH
54356: LD_VAR 0 4
54360: PUSH
54361: LD_INT 0
54363: PUSH
54364: LD_INT 0
54366: PUSH
54367: LD_VAR 0 11
54371: PUSH
54372: EMPTY
54373: LIST
54374: LIST
54375: LIST
54376: LIST
54377: ST_TO_ADDR
// exit ;
54378: GO 57068
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
54380: LD_EXP 23
54384: PUSH
54385: LD_VAR 0 1
54389: ARRAY
54390: PPUSH
54391: LD_INT 2
54393: PUSH
54394: LD_INT 30
54396: PUSH
54397: LD_INT 6
54399: PUSH
54400: EMPTY
54401: LIST
54402: LIST
54403: PUSH
54404: LD_INT 30
54406: PUSH
54407: LD_INT 7
54409: PUSH
54410: EMPTY
54411: LIST
54412: LIST
54413: PUSH
54414: LD_INT 30
54416: PUSH
54417: LD_INT 8
54419: PUSH
54420: EMPTY
54421: LIST
54422: LIST
54423: PUSH
54424: EMPTY
54425: LIST
54426: LIST
54427: LIST
54428: LIST
54429: PPUSH
54430: CALL_OW 72
54434: NOT
54435: PUSH
54436: LD_EXP 23
54440: PUSH
54441: LD_VAR 0 1
54445: ARRAY
54446: PPUSH
54447: LD_INT 30
54449: PUSH
54450: LD_INT 3
54452: PUSH
54453: EMPTY
54454: LIST
54455: LIST
54456: PPUSH
54457: CALL_OW 72
54461: NOT
54462: AND
54463: IFFALSE 54535
// begin if eng = tmp then
54465: LD_VAR 0 6
54469: PUSH
54470: LD_VAR 0 4
54474: EQUAL
54475: IFFALSE 54479
// exit ;
54477: GO 57068
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
54479: LD_ADDR_EXP 65
54483: PUSH
54484: LD_EXP 65
54488: PPUSH
54489: LD_VAR 0 1
54493: PPUSH
54494: LD_INT 1
54496: PPUSH
54497: CALL_OW 1
54501: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
54502: LD_ADDR_VAR 0 2
54506: PUSH
54507: LD_INT 0
54509: PUSH
54510: LD_VAR 0 4
54514: PUSH
54515: LD_VAR 0 6
54519: DIFF
54520: PUSH
54521: LD_INT 0
54523: PUSH
54524: LD_INT 0
54526: PUSH
54527: EMPTY
54528: LIST
54529: LIST
54530: LIST
54531: LIST
54532: ST_TO_ADDR
// exit ;
54533: GO 57068
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
54535: LD_EXP 50
54539: PUSH
54540: LD_EXP 49
54544: PUSH
54545: LD_VAR 0 1
54549: ARRAY
54550: ARRAY
54551: PUSH
54552: LD_EXP 23
54556: PUSH
54557: LD_VAR 0 1
54561: ARRAY
54562: PPUSH
54563: LD_INT 2
54565: PUSH
54566: LD_INT 30
54568: PUSH
54569: LD_INT 6
54571: PUSH
54572: EMPTY
54573: LIST
54574: LIST
54575: PUSH
54576: LD_INT 30
54578: PUSH
54579: LD_INT 7
54581: PUSH
54582: EMPTY
54583: LIST
54584: LIST
54585: PUSH
54586: LD_INT 30
54588: PUSH
54589: LD_INT 8
54591: PUSH
54592: EMPTY
54593: LIST
54594: LIST
54595: PUSH
54596: EMPTY
54597: LIST
54598: LIST
54599: LIST
54600: LIST
54601: PPUSH
54602: CALL_OW 72
54606: AND
54607: PUSH
54608: LD_EXP 23
54612: PUSH
54613: LD_VAR 0 1
54617: ARRAY
54618: PPUSH
54619: LD_INT 30
54621: PUSH
54622: LD_INT 3
54624: PUSH
54625: EMPTY
54626: LIST
54627: LIST
54628: PPUSH
54629: CALL_OW 72
54633: NOT
54634: AND
54635: IFFALSE 54849
// begin if sci >= 6 then
54637: LD_VAR 0 8
54641: PUSH
54642: LD_INT 6
54644: GREATEREQUAL
54645: IFFALSE 54649
// exit ;
54647: GO 57068
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
54649: LD_ADDR_EXP 65
54653: PUSH
54654: LD_EXP 65
54658: PPUSH
54659: LD_VAR 0 1
54663: PPUSH
54664: LD_INT 2
54666: PPUSH
54667: CALL_OW 1
54671: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
54672: LD_ADDR_VAR 0 9
54676: PUSH
54677: LD_VAR 0 4
54681: PUSH
54682: LD_VAR 0 8
54686: DIFF
54687: PPUSH
54688: LD_INT 4
54690: PPUSH
54691: CALL 45241 0 2
54695: ST_TO_ADDR
// p := [ ] ;
54696: LD_ADDR_VAR 0 11
54700: PUSH
54701: EMPTY
54702: ST_TO_ADDR
// if sci < 6 and sort > 6 then
54703: LD_VAR 0 8
54707: PUSH
54708: LD_INT 6
54710: LESS
54711: PUSH
54712: LD_VAR 0 9
54716: PUSH
54717: LD_INT 6
54719: GREATER
54720: AND
54721: IFFALSE 54802
// begin for i = 1 to 6 - sci do
54723: LD_ADDR_VAR 0 3
54727: PUSH
54728: DOUBLE
54729: LD_INT 1
54731: DEC
54732: ST_TO_ADDR
54733: LD_INT 6
54735: PUSH
54736: LD_VAR 0 8
54740: MINUS
54741: PUSH
54742: FOR_TO
54743: IFFALSE 54798
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
54745: LD_ADDR_VAR 0 11
54749: PUSH
54750: LD_VAR 0 11
54754: PPUSH
54755: LD_VAR 0 11
54759: PUSH
54760: LD_INT 1
54762: PLUS
54763: PPUSH
54764: LD_VAR 0 9
54768: PUSH
54769: LD_INT 1
54771: ARRAY
54772: PPUSH
54773: CALL_OW 2
54777: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
54778: LD_ADDR_VAR 0 9
54782: PUSH
54783: LD_VAR 0 9
54787: PPUSH
54788: LD_INT 1
54790: PPUSH
54791: CALL_OW 3
54795: ST_TO_ADDR
// end ;
54796: GO 54742
54798: POP
54799: POP
// end else
54800: GO 54822
// if sort then
54802: LD_VAR 0 9
54806: IFFALSE 54822
// p := sort [ 1 ] ;
54808: LD_ADDR_VAR 0 11
54812: PUSH
54813: LD_VAR 0 9
54817: PUSH
54818: LD_INT 1
54820: ARRAY
54821: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
54822: LD_ADDR_VAR 0 2
54826: PUSH
54827: LD_INT 0
54829: PUSH
54830: LD_INT 0
54832: PUSH
54833: LD_INT 0
54835: PUSH
54836: LD_VAR 0 11
54840: PUSH
54841: EMPTY
54842: LIST
54843: LIST
54844: LIST
54845: LIST
54846: ST_TO_ADDR
// exit ;
54847: GO 57068
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
54849: LD_EXP 50
54853: PUSH
54854: LD_EXP 49
54858: PUSH
54859: LD_VAR 0 1
54863: ARRAY
54864: ARRAY
54865: PUSH
54866: LD_EXP 23
54870: PUSH
54871: LD_VAR 0 1
54875: ARRAY
54876: PPUSH
54877: LD_INT 2
54879: PUSH
54880: LD_INT 30
54882: PUSH
54883: LD_INT 6
54885: PUSH
54886: EMPTY
54887: LIST
54888: LIST
54889: PUSH
54890: LD_INT 30
54892: PUSH
54893: LD_INT 7
54895: PUSH
54896: EMPTY
54897: LIST
54898: LIST
54899: PUSH
54900: LD_INT 30
54902: PUSH
54903: LD_INT 8
54905: PUSH
54906: EMPTY
54907: LIST
54908: LIST
54909: PUSH
54910: EMPTY
54911: LIST
54912: LIST
54913: LIST
54914: LIST
54915: PPUSH
54916: CALL_OW 72
54920: AND
54921: PUSH
54922: LD_EXP 23
54926: PUSH
54927: LD_VAR 0 1
54931: ARRAY
54932: PPUSH
54933: LD_INT 30
54935: PUSH
54936: LD_INT 3
54938: PUSH
54939: EMPTY
54940: LIST
54941: LIST
54942: PPUSH
54943: CALL_OW 72
54947: AND
54948: IFFALSE 55682
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
54950: LD_ADDR_EXP 65
54954: PUSH
54955: LD_EXP 65
54959: PPUSH
54960: LD_VAR 0 1
54964: PPUSH
54965: LD_INT 3
54967: PPUSH
54968: CALL_OW 1
54972: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
54973: LD_ADDR_VAR 0 2
54977: PUSH
54978: LD_INT 0
54980: PUSH
54981: LD_INT 0
54983: PUSH
54984: LD_INT 0
54986: PUSH
54987: LD_INT 0
54989: PUSH
54990: EMPTY
54991: LIST
54992: LIST
54993: LIST
54994: LIST
54995: ST_TO_ADDR
// if not eng then
54996: LD_VAR 0 6
55000: NOT
55001: IFFALSE 55064
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
55003: LD_ADDR_VAR 0 11
55007: PUSH
55008: LD_VAR 0 4
55012: PPUSH
55013: LD_INT 2
55015: PPUSH
55016: CALL 45241 0 2
55020: PUSH
55021: LD_INT 1
55023: ARRAY
55024: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
55025: LD_ADDR_VAR 0 2
55029: PUSH
55030: LD_VAR 0 2
55034: PPUSH
55035: LD_INT 2
55037: PPUSH
55038: LD_VAR 0 11
55042: PPUSH
55043: CALL_OW 1
55047: ST_TO_ADDR
// tmp := tmp diff p ;
55048: LD_ADDR_VAR 0 4
55052: PUSH
55053: LD_VAR 0 4
55057: PUSH
55058: LD_VAR 0 11
55062: DIFF
55063: ST_TO_ADDR
// end ; if tmp and sci < 6 then
55064: LD_VAR 0 4
55068: PUSH
55069: LD_VAR 0 8
55073: PUSH
55074: LD_INT 6
55076: LESS
55077: AND
55078: IFFALSE 55266
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
55080: LD_ADDR_VAR 0 9
55084: PUSH
55085: LD_VAR 0 4
55089: PUSH
55090: LD_VAR 0 8
55094: PUSH
55095: LD_VAR 0 7
55099: UNION
55100: DIFF
55101: PPUSH
55102: LD_INT 4
55104: PPUSH
55105: CALL 45241 0 2
55109: ST_TO_ADDR
// p := [ ] ;
55110: LD_ADDR_VAR 0 11
55114: PUSH
55115: EMPTY
55116: ST_TO_ADDR
// if sort then
55117: LD_VAR 0 9
55121: IFFALSE 55237
// for i = 1 to 6 - sci do
55123: LD_ADDR_VAR 0 3
55127: PUSH
55128: DOUBLE
55129: LD_INT 1
55131: DEC
55132: ST_TO_ADDR
55133: LD_INT 6
55135: PUSH
55136: LD_VAR 0 8
55140: MINUS
55141: PUSH
55142: FOR_TO
55143: IFFALSE 55235
// begin if i = sort then
55145: LD_VAR 0 3
55149: PUSH
55150: LD_VAR 0 9
55154: EQUAL
55155: IFFALSE 55159
// break ;
55157: GO 55235
// if GetClass ( i ) = 4 then
55159: LD_VAR 0 3
55163: PPUSH
55164: CALL_OW 257
55168: PUSH
55169: LD_INT 4
55171: EQUAL
55172: IFFALSE 55176
// continue ;
55174: GO 55142
// p := Insert ( p , p + 1 , sort [ i ] ) ;
55176: LD_ADDR_VAR 0 11
55180: PUSH
55181: LD_VAR 0 11
55185: PPUSH
55186: LD_VAR 0 11
55190: PUSH
55191: LD_INT 1
55193: PLUS
55194: PPUSH
55195: LD_VAR 0 9
55199: PUSH
55200: LD_VAR 0 3
55204: ARRAY
55205: PPUSH
55206: CALL_OW 2
55210: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
55211: LD_ADDR_VAR 0 4
55215: PUSH
55216: LD_VAR 0 4
55220: PUSH
55221: LD_VAR 0 9
55225: PUSH
55226: LD_VAR 0 3
55230: ARRAY
55231: DIFF
55232: ST_TO_ADDR
// end ;
55233: GO 55142
55235: POP
55236: POP
// if p then
55237: LD_VAR 0 11
55241: IFFALSE 55266
// result := Replace ( result , 4 , p ) ;
55243: LD_ADDR_VAR 0 2
55247: PUSH
55248: LD_VAR 0 2
55252: PPUSH
55253: LD_INT 4
55255: PPUSH
55256: LD_VAR 0 11
55260: PPUSH
55261: CALL_OW 1
55265: ST_TO_ADDR
// end ; if tmp and mech < 6 then
55266: LD_VAR 0 4
55270: PUSH
55271: LD_VAR 0 7
55275: PUSH
55276: LD_INT 6
55278: LESS
55279: AND
55280: IFFALSE 55468
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
55282: LD_ADDR_VAR 0 9
55286: PUSH
55287: LD_VAR 0 4
55291: PUSH
55292: LD_VAR 0 8
55296: PUSH
55297: LD_VAR 0 7
55301: UNION
55302: DIFF
55303: PPUSH
55304: LD_INT 3
55306: PPUSH
55307: CALL 45241 0 2
55311: ST_TO_ADDR
// p := [ ] ;
55312: LD_ADDR_VAR 0 11
55316: PUSH
55317: EMPTY
55318: ST_TO_ADDR
// if sort then
55319: LD_VAR 0 9
55323: IFFALSE 55439
// for i = 1 to 6 - mech do
55325: LD_ADDR_VAR 0 3
55329: PUSH
55330: DOUBLE
55331: LD_INT 1
55333: DEC
55334: ST_TO_ADDR
55335: LD_INT 6
55337: PUSH
55338: LD_VAR 0 7
55342: MINUS
55343: PUSH
55344: FOR_TO
55345: IFFALSE 55437
// begin if i = sort then
55347: LD_VAR 0 3
55351: PUSH
55352: LD_VAR 0 9
55356: EQUAL
55357: IFFALSE 55361
// break ;
55359: GO 55437
// if GetClass ( i ) = 3 then
55361: LD_VAR 0 3
55365: PPUSH
55366: CALL_OW 257
55370: PUSH
55371: LD_INT 3
55373: EQUAL
55374: IFFALSE 55378
// continue ;
55376: GO 55344
// p := Insert ( p , p + 1 , sort [ i ] ) ;
55378: LD_ADDR_VAR 0 11
55382: PUSH
55383: LD_VAR 0 11
55387: PPUSH
55388: LD_VAR 0 11
55392: PUSH
55393: LD_INT 1
55395: PLUS
55396: PPUSH
55397: LD_VAR 0 9
55401: PUSH
55402: LD_VAR 0 3
55406: ARRAY
55407: PPUSH
55408: CALL_OW 2
55412: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
55413: LD_ADDR_VAR 0 4
55417: PUSH
55418: LD_VAR 0 4
55422: PUSH
55423: LD_VAR 0 9
55427: PUSH
55428: LD_VAR 0 3
55432: ARRAY
55433: DIFF
55434: ST_TO_ADDR
// end ;
55435: GO 55344
55437: POP
55438: POP
// if p then
55439: LD_VAR 0 11
55443: IFFALSE 55468
// result := Replace ( result , 3 , p ) ;
55445: LD_ADDR_VAR 0 2
55449: PUSH
55450: LD_VAR 0 2
55454: PPUSH
55455: LD_INT 3
55457: PPUSH
55458: LD_VAR 0 11
55462: PPUSH
55463: CALL_OW 1
55467: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
55468: LD_VAR 0 4
55472: PUSH
55473: LD_INT 6
55475: GREATER
55476: PUSH
55477: LD_VAR 0 6
55481: PUSH
55482: LD_INT 6
55484: LESS
55485: AND
55486: IFFALSE 55680
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
55488: LD_ADDR_VAR 0 9
55492: PUSH
55493: LD_VAR 0 4
55497: PUSH
55498: LD_VAR 0 8
55502: PUSH
55503: LD_VAR 0 7
55507: UNION
55508: PUSH
55509: LD_VAR 0 6
55513: UNION
55514: DIFF
55515: PPUSH
55516: LD_INT 2
55518: PPUSH
55519: CALL 45241 0 2
55523: ST_TO_ADDR
// p := [ ] ;
55524: LD_ADDR_VAR 0 11
55528: PUSH
55529: EMPTY
55530: ST_TO_ADDR
// if sort then
55531: LD_VAR 0 9
55535: IFFALSE 55651
// for i = 1 to 6 - eng do
55537: LD_ADDR_VAR 0 3
55541: PUSH
55542: DOUBLE
55543: LD_INT 1
55545: DEC
55546: ST_TO_ADDR
55547: LD_INT 6
55549: PUSH
55550: LD_VAR 0 6
55554: MINUS
55555: PUSH
55556: FOR_TO
55557: IFFALSE 55649
// begin if i = sort then
55559: LD_VAR 0 3
55563: PUSH
55564: LD_VAR 0 9
55568: EQUAL
55569: IFFALSE 55573
// break ;
55571: GO 55649
// if GetClass ( i ) = 2 then
55573: LD_VAR 0 3
55577: PPUSH
55578: CALL_OW 257
55582: PUSH
55583: LD_INT 2
55585: EQUAL
55586: IFFALSE 55590
// continue ;
55588: GO 55556
// p := Insert ( p , p + 1 , sort [ i ] ) ;
55590: LD_ADDR_VAR 0 11
55594: PUSH
55595: LD_VAR 0 11
55599: PPUSH
55600: LD_VAR 0 11
55604: PUSH
55605: LD_INT 1
55607: PLUS
55608: PPUSH
55609: LD_VAR 0 9
55613: PUSH
55614: LD_VAR 0 3
55618: ARRAY
55619: PPUSH
55620: CALL_OW 2
55624: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
55625: LD_ADDR_VAR 0 4
55629: PUSH
55630: LD_VAR 0 4
55634: PUSH
55635: LD_VAR 0 9
55639: PUSH
55640: LD_VAR 0 3
55644: ARRAY
55645: DIFF
55646: ST_TO_ADDR
// end ;
55647: GO 55556
55649: POP
55650: POP
// if p then
55651: LD_VAR 0 11
55655: IFFALSE 55680
// result := Replace ( result , 2 , p ) ;
55657: LD_ADDR_VAR 0 2
55661: PUSH
55662: LD_VAR 0 2
55666: PPUSH
55667: LD_INT 2
55669: PPUSH
55670: LD_VAR 0 11
55674: PPUSH
55675: CALL_OW 1
55679: ST_TO_ADDR
// end ; exit ;
55680: GO 57068
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
55682: LD_EXP 50
55686: PUSH
55687: LD_EXP 49
55691: PUSH
55692: LD_VAR 0 1
55696: ARRAY
55697: ARRAY
55698: NOT
55699: PUSH
55700: LD_EXP 23
55704: PUSH
55705: LD_VAR 0 1
55709: ARRAY
55710: PPUSH
55711: LD_INT 30
55713: PUSH
55714: LD_INT 3
55716: PUSH
55717: EMPTY
55718: LIST
55719: LIST
55720: PPUSH
55721: CALL_OW 72
55725: AND
55726: PUSH
55727: LD_EXP 28
55731: PUSH
55732: LD_VAR 0 1
55736: ARRAY
55737: AND
55738: IFFALSE 56346
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
55740: LD_ADDR_EXP 65
55744: PUSH
55745: LD_EXP 65
55749: PPUSH
55750: LD_VAR 0 1
55754: PPUSH
55755: LD_INT 5
55757: PPUSH
55758: CALL_OW 1
55762: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
55763: LD_ADDR_VAR 0 2
55767: PUSH
55768: LD_INT 0
55770: PUSH
55771: LD_INT 0
55773: PUSH
55774: LD_INT 0
55776: PUSH
55777: LD_INT 0
55779: PUSH
55780: EMPTY
55781: LIST
55782: LIST
55783: LIST
55784: LIST
55785: ST_TO_ADDR
// if sci > 1 then
55786: LD_VAR 0 8
55790: PUSH
55791: LD_INT 1
55793: GREATER
55794: IFFALSE 55822
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
55796: LD_ADDR_VAR 0 4
55800: PUSH
55801: LD_VAR 0 4
55805: PUSH
55806: LD_VAR 0 8
55810: PUSH
55811: LD_VAR 0 8
55815: PUSH
55816: LD_INT 1
55818: ARRAY
55819: DIFF
55820: DIFF
55821: ST_TO_ADDR
// if tmp and not sci then
55822: LD_VAR 0 4
55826: PUSH
55827: LD_VAR 0 8
55831: NOT
55832: AND
55833: IFFALSE 55902
// begin sort := SortBySkill ( tmp , 4 ) ;
55835: LD_ADDR_VAR 0 9
55839: PUSH
55840: LD_VAR 0 4
55844: PPUSH
55845: LD_INT 4
55847: PPUSH
55848: CALL 45241 0 2
55852: ST_TO_ADDR
// if sort then
55853: LD_VAR 0 9
55857: IFFALSE 55873
// p := sort [ 1 ] ;
55859: LD_ADDR_VAR 0 11
55863: PUSH
55864: LD_VAR 0 9
55868: PUSH
55869: LD_INT 1
55871: ARRAY
55872: ST_TO_ADDR
// if p then
55873: LD_VAR 0 11
55877: IFFALSE 55902
// result := Replace ( result , 4 , p ) ;
55879: LD_ADDR_VAR 0 2
55883: PUSH
55884: LD_VAR 0 2
55888: PPUSH
55889: LD_INT 4
55891: PPUSH
55892: LD_VAR 0 11
55896: PPUSH
55897: CALL_OW 1
55901: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
55902: LD_ADDR_VAR 0 4
55906: PUSH
55907: LD_VAR 0 4
55911: PUSH
55912: LD_VAR 0 7
55916: DIFF
55917: ST_TO_ADDR
// if tmp and mech < 6 then
55918: LD_VAR 0 4
55922: PUSH
55923: LD_VAR 0 7
55927: PUSH
55928: LD_INT 6
55930: LESS
55931: AND
55932: IFFALSE 56120
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
55934: LD_ADDR_VAR 0 9
55938: PUSH
55939: LD_VAR 0 4
55943: PUSH
55944: LD_VAR 0 8
55948: PUSH
55949: LD_VAR 0 7
55953: UNION
55954: DIFF
55955: PPUSH
55956: LD_INT 3
55958: PPUSH
55959: CALL 45241 0 2
55963: ST_TO_ADDR
// p := [ ] ;
55964: LD_ADDR_VAR 0 11
55968: PUSH
55969: EMPTY
55970: ST_TO_ADDR
// if sort then
55971: LD_VAR 0 9
55975: IFFALSE 56091
// for i = 1 to 6 - mech do
55977: LD_ADDR_VAR 0 3
55981: PUSH
55982: DOUBLE
55983: LD_INT 1
55985: DEC
55986: ST_TO_ADDR
55987: LD_INT 6
55989: PUSH
55990: LD_VAR 0 7
55994: MINUS
55995: PUSH
55996: FOR_TO
55997: IFFALSE 56089
// begin if i = sort then
55999: LD_VAR 0 3
56003: PUSH
56004: LD_VAR 0 9
56008: EQUAL
56009: IFFALSE 56013
// break ;
56011: GO 56089
// if GetClass ( i ) = 3 then
56013: LD_VAR 0 3
56017: PPUSH
56018: CALL_OW 257
56022: PUSH
56023: LD_INT 3
56025: EQUAL
56026: IFFALSE 56030
// continue ;
56028: GO 55996
// p := Insert ( p , p + 1 , sort [ i ] ) ;
56030: LD_ADDR_VAR 0 11
56034: PUSH
56035: LD_VAR 0 11
56039: PPUSH
56040: LD_VAR 0 11
56044: PUSH
56045: LD_INT 1
56047: PLUS
56048: PPUSH
56049: LD_VAR 0 9
56053: PUSH
56054: LD_VAR 0 3
56058: ARRAY
56059: PPUSH
56060: CALL_OW 2
56064: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
56065: LD_ADDR_VAR 0 4
56069: PUSH
56070: LD_VAR 0 4
56074: PUSH
56075: LD_VAR 0 9
56079: PUSH
56080: LD_VAR 0 3
56084: ARRAY
56085: DIFF
56086: ST_TO_ADDR
// end ;
56087: GO 55996
56089: POP
56090: POP
// if p then
56091: LD_VAR 0 11
56095: IFFALSE 56120
// result := Replace ( result , 3 , p ) ;
56097: LD_ADDR_VAR 0 2
56101: PUSH
56102: LD_VAR 0 2
56106: PPUSH
56107: LD_INT 3
56109: PPUSH
56110: LD_VAR 0 11
56114: PPUSH
56115: CALL_OW 1
56119: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
56120: LD_ADDR_VAR 0 4
56124: PUSH
56125: LD_VAR 0 4
56129: PUSH
56130: LD_VAR 0 6
56134: DIFF
56135: ST_TO_ADDR
// if tmp and eng < 6 then
56136: LD_VAR 0 4
56140: PUSH
56141: LD_VAR 0 6
56145: PUSH
56146: LD_INT 6
56148: LESS
56149: AND
56150: IFFALSE 56344
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
56152: LD_ADDR_VAR 0 9
56156: PUSH
56157: LD_VAR 0 4
56161: PUSH
56162: LD_VAR 0 8
56166: PUSH
56167: LD_VAR 0 7
56171: UNION
56172: PUSH
56173: LD_VAR 0 6
56177: UNION
56178: DIFF
56179: PPUSH
56180: LD_INT 2
56182: PPUSH
56183: CALL 45241 0 2
56187: ST_TO_ADDR
// p := [ ] ;
56188: LD_ADDR_VAR 0 11
56192: PUSH
56193: EMPTY
56194: ST_TO_ADDR
// if sort then
56195: LD_VAR 0 9
56199: IFFALSE 56315
// for i = 1 to 6 - eng do
56201: LD_ADDR_VAR 0 3
56205: PUSH
56206: DOUBLE
56207: LD_INT 1
56209: DEC
56210: ST_TO_ADDR
56211: LD_INT 6
56213: PUSH
56214: LD_VAR 0 6
56218: MINUS
56219: PUSH
56220: FOR_TO
56221: IFFALSE 56313
// begin if i = sort then
56223: LD_VAR 0 3
56227: PUSH
56228: LD_VAR 0 9
56232: EQUAL
56233: IFFALSE 56237
// break ;
56235: GO 56313
// if GetClass ( i ) = 2 then
56237: LD_VAR 0 3
56241: PPUSH
56242: CALL_OW 257
56246: PUSH
56247: LD_INT 2
56249: EQUAL
56250: IFFALSE 56254
// continue ;
56252: GO 56220
// p := Insert ( p , p + 1 , sort [ i ] ) ;
56254: LD_ADDR_VAR 0 11
56258: PUSH
56259: LD_VAR 0 11
56263: PPUSH
56264: LD_VAR 0 11
56268: PUSH
56269: LD_INT 1
56271: PLUS
56272: PPUSH
56273: LD_VAR 0 9
56277: PUSH
56278: LD_VAR 0 3
56282: ARRAY
56283: PPUSH
56284: CALL_OW 2
56288: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
56289: LD_ADDR_VAR 0 4
56293: PUSH
56294: LD_VAR 0 4
56298: PUSH
56299: LD_VAR 0 9
56303: PUSH
56304: LD_VAR 0 3
56308: ARRAY
56309: DIFF
56310: ST_TO_ADDR
// end ;
56311: GO 56220
56313: POP
56314: POP
// if p then
56315: LD_VAR 0 11
56319: IFFALSE 56344
// result := Replace ( result , 2 , p ) ;
56321: LD_ADDR_VAR 0 2
56325: PUSH
56326: LD_VAR 0 2
56330: PPUSH
56331: LD_INT 2
56333: PPUSH
56334: LD_VAR 0 11
56338: PPUSH
56339: CALL_OW 1
56343: ST_TO_ADDR
// end ; exit ;
56344: GO 57068
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
56346: LD_EXP 50
56350: PUSH
56351: LD_EXP 49
56355: PUSH
56356: LD_VAR 0 1
56360: ARRAY
56361: ARRAY
56362: NOT
56363: PUSH
56364: LD_EXP 23
56368: PUSH
56369: LD_VAR 0 1
56373: ARRAY
56374: PPUSH
56375: LD_INT 30
56377: PUSH
56378: LD_INT 3
56380: PUSH
56381: EMPTY
56382: LIST
56383: LIST
56384: PPUSH
56385: CALL_OW 72
56389: AND
56390: PUSH
56391: LD_EXP 28
56395: PUSH
56396: LD_VAR 0 1
56400: ARRAY
56401: NOT
56402: AND
56403: IFFALSE 57068
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
56405: LD_ADDR_EXP 65
56409: PUSH
56410: LD_EXP 65
56414: PPUSH
56415: LD_VAR 0 1
56419: PPUSH
56420: LD_INT 6
56422: PPUSH
56423: CALL_OW 1
56427: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
56428: LD_ADDR_VAR 0 2
56432: PUSH
56433: LD_INT 0
56435: PUSH
56436: LD_INT 0
56438: PUSH
56439: LD_INT 0
56441: PUSH
56442: LD_INT 0
56444: PUSH
56445: EMPTY
56446: LIST
56447: LIST
56448: LIST
56449: LIST
56450: ST_TO_ADDR
// if sci >= 1 then
56451: LD_VAR 0 8
56455: PUSH
56456: LD_INT 1
56458: GREATEREQUAL
56459: IFFALSE 56481
// tmp := tmp diff sci [ 1 ] ;
56461: LD_ADDR_VAR 0 4
56465: PUSH
56466: LD_VAR 0 4
56470: PUSH
56471: LD_VAR 0 8
56475: PUSH
56476: LD_INT 1
56478: ARRAY
56479: DIFF
56480: ST_TO_ADDR
// if tmp and not sci then
56481: LD_VAR 0 4
56485: PUSH
56486: LD_VAR 0 8
56490: NOT
56491: AND
56492: IFFALSE 56561
// begin sort := SortBySkill ( tmp , 4 ) ;
56494: LD_ADDR_VAR 0 9
56498: PUSH
56499: LD_VAR 0 4
56503: PPUSH
56504: LD_INT 4
56506: PPUSH
56507: CALL 45241 0 2
56511: ST_TO_ADDR
// if sort then
56512: LD_VAR 0 9
56516: IFFALSE 56532
// p := sort [ 1 ] ;
56518: LD_ADDR_VAR 0 11
56522: PUSH
56523: LD_VAR 0 9
56527: PUSH
56528: LD_INT 1
56530: ARRAY
56531: ST_TO_ADDR
// if p then
56532: LD_VAR 0 11
56536: IFFALSE 56561
// result := Replace ( result , 4 , p ) ;
56538: LD_ADDR_VAR 0 2
56542: PUSH
56543: LD_VAR 0 2
56547: PPUSH
56548: LD_INT 4
56550: PPUSH
56551: LD_VAR 0 11
56555: PPUSH
56556: CALL_OW 1
56560: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
56561: LD_ADDR_VAR 0 4
56565: PUSH
56566: LD_VAR 0 4
56570: PUSH
56571: LD_VAR 0 7
56575: DIFF
56576: ST_TO_ADDR
// if tmp and mech < 6 then
56577: LD_VAR 0 4
56581: PUSH
56582: LD_VAR 0 7
56586: PUSH
56587: LD_INT 6
56589: LESS
56590: AND
56591: IFFALSE 56773
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
56593: LD_ADDR_VAR 0 9
56597: PUSH
56598: LD_VAR 0 4
56602: PUSH
56603: LD_VAR 0 7
56607: DIFF
56608: PPUSH
56609: LD_INT 3
56611: PPUSH
56612: CALL 45241 0 2
56616: ST_TO_ADDR
// p := [ ] ;
56617: LD_ADDR_VAR 0 11
56621: PUSH
56622: EMPTY
56623: ST_TO_ADDR
// if sort then
56624: LD_VAR 0 9
56628: IFFALSE 56744
// for i = 1 to 6 - mech do
56630: LD_ADDR_VAR 0 3
56634: PUSH
56635: DOUBLE
56636: LD_INT 1
56638: DEC
56639: ST_TO_ADDR
56640: LD_INT 6
56642: PUSH
56643: LD_VAR 0 7
56647: MINUS
56648: PUSH
56649: FOR_TO
56650: IFFALSE 56742
// begin if i = sort then
56652: LD_VAR 0 3
56656: PUSH
56657: LD_VAR 0 9
56661: EQUAL
56662: IFFALSE 56666
// break ;
56664: GO 56742
// if GetClass ( i ) = 3 then
56666: LD_VAR 0 3
56670: PPUSH
56671: CALL_OW 257
56675: PUSH
56676: LD_INT 3
56678: EQUAL
56679: IFFALSE 56683
// continue ;
56681: GO 56649
// p := Insert ( p , p + 1 , sort [ i ] ) ;
56683: LD_ADDR_VAR 0 11
56687: PUSH
56688: LD_VAR 0 11
56692: PPUSH
56693: LD_VAR 0 11
56697: PUSH
56698: LD_INT 1
56700: PLUS
56701: PPUSH
56702: LD_VAR 0 9
56706: PUSH
56707: LD_VAR 0 3
56711: ARRAY
56712: PPUSH
56713: CALL_OW 2
56717: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
56718: LD_ADDR_VAR 0 4
56722: PUSH
56723: LD_VAR 0 4
56727: PUSH
56728: LD_VAR 0 9
56732: PUSH
56733: LD_VAR 0 3
56737: ARRAY
56738: DIFF
56739: ST_TO_ADDR
// end ;
56740: GO 56649
56742: POP
56743: POP
// if p then
56744: LD_VAR 0 11
56748: IFFALSE 56773
// result := Replace ( result , 3 , p ) ;
56750: LD_ADDR_VAR 0 2
56754: PUSH
56755: LD_VAR 0 2
56759: PPUSH
56760: LD_INT 3
56762: PPUSH
56763: LD_VAR 0 11
56767: PPUSH
56768: CALL_OW 1
56772: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
56773: LD_ADDR_VAR 0 4
56777: PUSH
56778: LD_VAR 0 4
56782: PUSH
56783: LD_VAR 0 6
56787: DIFF
56788: ST_TO_ADDR
// if tmp and eng < 4 then
56789: LD_VAR 0 4
56793: PUSH
56794: LD_VAR 0 6
56798: PUSH
56799: LD_INT 4
56801: LESS
56802: AND
56803: IFFALSE 56993
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
56805: LD_ADDR_VAR 0 9
56809: PUSH
56810: LD_VAR 0 4
56814: PUSH
56815: LD_VAR 0 7
56819: PUSH
56820: LD_VAR 0 6
56824: UNION
56825: DIFF
56826: PPUSH
56827: LD_INT 2
56829: PPUSH
56830: CALL 45241 0 2
56834: ST_TO_ADDR
// p := [ ] ;
56835: LD_ADDR_VAR 0 11
56839: PUSH
56840: EMPTY
56841: ST_TO_ADDR
// if sort then
56842: LD_VAR 0 9
56846: IFFALSE 56962
// for i = 1 to 4 - eng do
56848: LD_ADDR_VAR 0 3
56852: PUSH
56853: DOUBLE
56854: LD_INT 1
56856: DEC
56857: ST_TO_ADDR
56858: LD_INT 4
56860: PUSH
56861: LD_VAR 0 6
56865: MINUS
56866: PUSH
56867: FOR_TO
56868: IFFALSE 56960
// begin if i = sort then
56870: LD_VAR 0 3
56874: PUSH
56875: LD_VAR 0 9
56879: EQUAL
56880: IFFALSE 56884
// break ;
56882: GO 56960
// if GetClass ( i ) = 2 then
56884: LD_VAR 0 3
56888: PPUSH
56889: CALL_OW 257
56893: PUSH
56894: LD_INT 2
56896: EQUAL
56897: IFFALSE 56901
// continue ;
56899: GO 56867
// p := Insert ( p , p + 1 , sort [ i ] ) ;
56901: LD_ADDR_VAR 0 11
56905: PUSH
56906: LD_VAR 0 11
56910: PPUSH
56911: LD_VAR 0 11
56915: PUSH
56916: LD_INT 1
56918: PLUS
56919: PPUSH
56920: LD_VAR 0 9
56924: PUSH
56925: LD_VAR 0 3
56929: ARRAY
56930: PPUSH
56931: CALL_OW 2
56935: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
56936: LD_ADDR_VAR 0 4
56940: PUSH
56941: LD_VAR 0 4
56945: PUSH
56946: LD_VAR 0 9
56950: PUSH
56951: LD_VAR 0 3
56955: ARRAY
56956: DIFF
56957: ST_TO_ADDR
// end ;
56958: GO 56867
56960: POP
56961: POP
// if p then
56962: LD_VAR 0 11
56966: IFFALSE 56991
// result := Replace ( result , 2 , p ) ;
56968: LD_ADDR_VAR 0 2
56972: PUSH
56973: LD_VAR 0 2
56977: PPUSH
56978: LD_INT 2
56980: PPUSH
56981: LD_VAR 0 11
56985: PPUSH
56986: CALL_OW 1
56990: ST_TO_ADDR
// end else
56991: GO 57037
// for i = eng downto 5 do
56993: LD_ADDR_VAR 0 3
56997: PUSH
56998: DOUBLE
56999: LD_VAR 0 6
57003: INC
57004: ST_TO_ADDR
57005: LD_INT 5
57007: PUSH
57008: FOR_DOWNTO
57009: IFFALSE 57035
// tmp := tmp union eng [ i ] ;
57011: LD_ADDR_VAR 0 4
57015: PUSH
57016: LD_VAR 0 4
57020: PUSH
57021: LD_VAR 0 6
57025: PUSH
57026: LD_VAR 0 3
57030: ARRAY
57031: UNION
57032: ST_TO_ADDR
57033: GO 57008
57035: POP
57036: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
57037: LD_ADDR_VAR 0 2
57041: PUSH
57042: LD_VAR 0 2
57046: PPUSH
57047: LD_INT 1
57049: PPUSH
57050: LD_VAR 0 4
57054: PUSH
57055: LD_VAR 0 5
57059: DIFF
57060: PPUSH
57061: CALL_OW 1
57065: ST_TO_ADDR
// exit ;
57066: GO 57068
// end ; end ;
57068: LD_VAR 0 2
57072: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
57073: LD_INT 0
57075: PPUSH
57076: PPUSH
57077: PPUSH
// if not mc_bases then
57078: LD_EXP 23
57082: NOT
57083: IFFALSE 57087
// exit ;
57085: GO 57193
// for i = 1 to mc_bases do
57087: LD_ADDR_VAR 0 2
57091: PUSH
57092: DOUBLE
57093: LD_INT 1
57095: DEC
57096: ST_TO_ADDR
57097: LD_EXP 23
57101: PUSH
57102: FOR_TO
57103: IFFALSE 57184
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
57105: LD_ADDR_VAR 0 3
57109: PUSH
57110: LD_EXP 23
57114: PUSH
57115: LD_VAR 0 2
57119: ARRAY
57120: PPUSH
57121: LD_INT 21
57123: PUSH
57124: LD_INT 3
57126: PUSH
57127: EMPTY
57128: LIST
57129: LIST
57130: PUSH
57131: LD_INT 3
57133: PUSH
57134: LD_INT 24
57136: PUSH
57137: LD_INT 1000
57139: PUSH
57140: EMPTY
57141: LIST
57142: LIST
57143: PUSH
57144: EMPTY
57145: LIST
57146: LIST
57147: PUSH
57148: EMPTY
57149: LIST
57150: LIST
57151: PPUSH
57152: CALL_OW 72
57156: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
57157: LD_ADDR_EXP 24
57161: PUSH
57162: LD_EXP 24
57166: PPUSH
57167: LD_VAR 0 2
57171: PPUSH
57172: LD_VAR 0 3
57176: PPUSH
57177: CALL_OW 1
57181: ST_TO_ADDR
// end ;
57182: GO 57102
57184: POP
57185: POP
// RaiseSailEvent ( 101 ) ;
57186: LD_INT 101
57188: PPUSH
57189: CALL_OW 427
// end ;
57193: LD_VAR 0 1
57197: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
57198: LD_INT 0
57200: PPUSH
57201: PPUSH
57202: PPUSH
57203: PPUSH
57204: PPUSH
57205: PPUSH
57206: PPUSH
// if not mc_bases then
57207: LD_EXP 23
57211: NOT
57212: IFFALSE 57216
// exit ;
57214: GO 57778
// for i = 1 to mc_bases do
57216: LD_ADDR_VAR 0 2
57220: PUSH
57221: DOUBLE
57222: LD_INT 1
57224: DEC
57225: ST_TO_ADDR
57226: LD_EXP 23
57230: PUSH
57231: FOR_TO
57232: IFFALSE 57769
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
57234: LD_ADDR_VAR 0 5
57238: PUSH
57239: LD_EXP 23
57243: PUSH
57244: LD_VAR 0 2
57248: ARRAY
57249: PUSH
57250: LD_EXP 52
57254: PUSH
57255: LD_VAR 0 2
57259: ARRAY
57260: UNION
57261: PPUSH
57262: LD_INT 21
57264: PUSH
57265: LD_INT 1
57267: PUSH
57268: EMPTY
57269: LIST
57270: LIST
57271: PUSH
57272: LD_INT 1
57274: PUSH
57275: LD_INT 3
57277: PUSH
57278: LD_INT 54
57280: PUSH
57281: EMPTY
57282: LIST
57283: PUSH
57284: EMPTY
57285: LIST
57286: LIST
57287: PUSH
57288: LD_INT 3
57290: PUSH
57291: LD_INT 24
57293: PUSH
57294: LD_INT 1000
57296: PUSH
57297: EMPTY
57298: LIST
57299: LIST
57300: PUSH
57301: EMPTY
57302: LIST
57303: LIST
57304: PUSH
57305: EMPTY
57306: LIST
57307: LIST
57308: LIST
57309: PUSH
57310: EMPTY
57311: LIST
57312: LIST
57313: PPUSH
57314: CALL_OW 72
57318: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
57319: LD_ADDR_VAR 0 6
57323: PUSH
57324: LD_EXP 23
57328: PUSH
57329: LD_VAR 0 2
57333: ARRAY
57334: PPUSH
57335: LD_INT 21
57337: PUSH
57338: LD_INT 1
57340: PUSH
57341: EMPTY
57342: LIST
57343: LIST
57344: PUSH
57345: LD_INT 1
57347: PUSH
57348: LD_INT 3
57350: PUSH
57351: LD_INT 54
57353: PUSH
57354: EMPTY
57355: LIST
57356: PUSH
57357: EMPTY
57358: LIST
57359: LIST
57360: PUSH
57361: LD_INT 3
57363: PUSH
57364: LD_INT 24
57366: PUSH
57367: LD_INT 250
57369: PUSH
57370: EMPTY
57371: LIST
57372: LIST
57373: PUSH
57374: EMPTY
57375: LIST
57376: LIST
57377: PUSH
57378: EMPTY
57379: LIST
57380: LIST
57381: LIST
57382: PUSH
57383: EMPTY
57384: LIST
57385: LIST
57386: PPUSH
57387: CALL_OW 72
57391: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
57392: LD_ADDR_VAR 0 7
57396: PUSH
57397: LD_VAR 0 5
57401: PUSH
57402: LD_VAR 0 6
57406: DIFF
57407: ST_TO_ADDR
// if not need_heal_1 then
57408: LD_VAR 0 6
57412: NOT
57413: IFFALSE 57446
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
57415: LD_ADDR_EXP 26
57419: PUSH
57420: LD_EXP 26
57424: PPUSH
57425: LD_VAR 0 2
57429: PUSH
57430: LD_INT 1
57432: PUSH
57433: EMPTY
57434: LIST
57435: LIST
57436: PPUSH
57437: EMPTY
57438: PPUSH
57439: CALL 14983 0 3
57443: ST_TO_ADDR
57444: GO 57516
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
57446: LD_ADDR_EXP 26
57450: PUSH
57451: LD_EXP 26
57455: PPUSH
57456: LD_VAR 0 2
57460: PUSH
57461: LD_INT 1
57463: PUSH
57464: EMPTY
57465: LIST
57466: LIST
57467: PPUSH
57468: LD_EXP 26
57472: PUSH
57473: LD_VAR 0 2
57477: ARRAY
57478: PUSH
57479: LD_INT 1
57481: ARRAY
57482: PPUSH
57483: LD_INT 3
57485: PUSH
57486: LD_INT 24
57488: PUSH
57489: LD_INT 1000
57491: PUSH
57492: EMPTY
57493: LIST
57494: LIST
57495: PUSH
57496: EMPTY
57497: LIST
57498: LIST
57499: PPUSH
57500: CALL_OW 72
57504: PUSH
57505: LD_VAR 0 6
57509: UNION
57510: PPUSH
57511: CALL 14983 0 3
57515: ST_TO_ADDR
// if not need_heal_2 then
57516: LD_VAR 0 7
57520: NOT
57521: IFFALSE 57554
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
57523: LD_ADDR_EXP 26
57527: PUSH
57528: LD_EXP 26
57532: PPUSH
57533: LD_VAR 0 2
57537: PUSH
57538: LD_INT 2
57540: PUSH
57541: EMPTY
57542: LIST
57543: LIST
57544: PPUSH
57545: EMPTY
57546: PPUSH
57547: CALL 14983 0 3
57551: ST_TO_ADDR
57552: GO 57586
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
57554: LD_ADDR_EXP 26
57558: PUSH
57559: LD_EXP 26
57563: PPUSH
57564: LD_VAR 0 2
57568: PUSH
57569: LD_INT 2
57571: PUSH
57572: EMPTY
57573: LIST
57574: LIST
57575: PPUSH
57576: LD_VAR 0 7
57580: PPUSH
57581: CALL 14983 0 3
57585: ST_TO_ADDR
// if need_heal_2 then
57586: LD_VAR 0 7
57590: IFFALSE 57751
// for j in need_heal_2 do
57592: LD_ADDR_VAR 0 3
57596: PUSH
57597: LD_VAR 0 7
57601: PUSH
57602: FOR_IN
57603: IFFALSE 57749
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57605: LD_ADDR_VAR 0 5
57609: PUSH
57610: LD_EXP 23
57614: PUSH
57615: LD_VAR 0 2
57619: ARRAY
57620: PPUSH
57621: LD_INT 2
57623: PUSH
57624: LD_INT 30
57626: PUSH
57627: LD_INT 6
57629: PUSH
57630: EMPTY
57631: LIST
57632: LIST
57633: PUSH
57634: LD_INT 30
57636: PUSH
57637: LD_INT 7
57639: PUSH
57640: EMPTY
57641: LIST
57642: LIST
57643: PUSH
57644: LD_INT 30
57646: PUSH
57647: LD_INT 8
57649: PUSH
57650: EMPTY
57651: LIST
57652: LIST
57653: PUSH
57654: LD_INT 30
57656: PUSH
57657: LD_INT 0
57659: PUSH
57660: EMPTY
57661: LIST
57662: LIST
57663: PUSH
57664: LD_INT 30
57666: PUSH
57667: LD_INT 1
57669: PUSH
57670: EMPTY
57671: LIST
57672: LIST
57673: PUSH
57674: EMPTY
57675: LIST
57676: LIST
57677: LIST
57678: LIST
57679: LIST
57680: LIST
57681: PPUSH
57682: CALL_OW 72
57686: ST_TO_ADDR
// if tmp then
57687: LD_VAR 0 5
57691: IFFALSE 57747
// begin k := NearestUnitToUnit ( tmp , j ) ;
57693: LD_ADDR_VAR 0 4
57697: PUSH
57698: LD_VAR 0 5
57702: PPUSH
57703: LD_VAR 0 3
57707: PPUSH
57708: CALL_OW 74
57712: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
57713: LD_VAR 0 3
57717: PPUSH
57718: LD_VAR 0 4
57722: PPUSH
57723: CALL_OW 296
57727: PUSH
57728: LD_INT 5
57730: GREATER
57731: IFFALSE 57747
// ComMoveToNearbyEntrance ( j , k ) ;
57733: LD_VAR 0 3
57737: PPUSH
57738: LD_VAR 0 4
57742: PPUSH
57743: CALL 47602 0 2
// end ; end ;
57747: GO 57602
57749: POP
57750: POP
// if not need_heal_1 and not need_heal_2 then
57751: LD_VAR 0 6
57755: NOT
57756: PUSH
57757: LD_VAR 0 7
57761: NOT
57762: AND
57763: IFFALSE 57767
// continue ;
57765: GO 57231
// end ;
57767: GO 57231
57769: POP
57770: POP
// RaiseSailEvent ( 102 ) ;
57771: LD_INT 102
57773: PPUSH
57774: CALL_OW 427
// end ;
57778: LD_VAR 0 1
57782: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
57783: LD_INT 0
57785: PPUSH
57786: PPUSH
57787: PPUSH
57788: PPUSH
57789: PPUSH
57790: PPUSH
57791: PPUSH
57792: PPUSH
// if not mc_bases then
57793: LD_EXP 23
57797: NOT
57798: IFFALSE 57802
// exit ;
57800: GO 58663
// for i = 1 to mc_bases do
57802: LD_ADDR_VAR 0 2
57806: PUSH
57807: DOUBLE
57808: LD_INT 1
57810: DEC
57811: ST_TO_ADDR
57812: LD_EXP 23
57816: PUSH
57817: FOR_TO
57818: IFFALSE 58661
// begin if not mc_building_need_repair [ i ] then
57820: LD_EXP 24
57824: PUSH
57825: LD_VAR 0 2
57829: ARRAY
57830: NOT
57831: IFFALSE 58018
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
57833: LD_ADDR_VAR 0 6
57837: PUSH
57838: LD_EXP 42
57842: PUSH
57843: LD_VAR 0 2
57847: ARRAY
57848: PPUSH
57849: LD_INT 3
57851: PUSH
57852: LD_INT 24
57854: PUSH
57855: LD_INT 1000
57857: PUSH
57858: EMPTY
57859: LIST
57860: LIST
57861: PUSH
57862: EMPTY
57863: LIST
57864: LIST
57865: PUSH
57866: LD_INT 2
57868: PUSH
57869: LD_INT 34
57871: PUSH
57872: LD_INT 13
57874: PUSH
57875: EMPTY
57876: LIST
57877: LIST
57878: PUSH
57879: LD_INT 34
57881: PUSH
57882: LD_INT 52
57884: PUSH
57885: EMPTY
57886: LIST
57887: LIST
57888: PUSH
57889: LD_INT 34
57891: PUSH
57892: LD_EXP 73
57896: PUSH
57897: EMPTY
57898: LIST
57899: LIST
57900: PUSH
57901: EMPTY
57902: LIST
57903: LIST
57904: LIST
57905: LIST
57906: PUSH
57907: EMPTY
57908: LIST
57909: LIST
57910: PPUSH
57911: CALL_OW 72
57915: ST_TO_ADDR
// if cranes then
57916: LD_VAR 0 6
57920: IFFALSE 57982
// for j in cranes do
57922: LD_ADDR_VAR 0 3
57926: PUSH
57927: LD_VAR 0 6
57931: PUSH
57932: FOR_IN
57933: IFFALSE 57980
// if not IsInArea ( j , mc_parking [ i ] ) then
57935: LD_VAR 0 3
57939: PPUSH
57940: LD_EXP 47
57944: PUSH
57945: LD_VAR 0 2
57949: ARRAY
57950: PPUSH
57951: CALL_OW 308
57955: NOT
57956: IFFALSE 57978
// ComMoveToArea ( j , mc_parking [ i ] ) ;
57958: LD_VAR 0 3
57962: PPUSH
57963: LD_EXP 47
57967: PUSH
57968: LD_VAR 0 2
57972: ARRAY
57973: PPUSH
57974: CALL_OW 113
57978: GO 57932
57980: POP
57981: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
57982: LD_ADDR_EXP 25
57986: PUSH
57987: LD_EXP 25
57991: PPUSH
57992: LD_VAR 0 2
57996: PPUSH
57997: EMPTY
57998: PPUSH
57999: CALL_OW 1
58003: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
58004: LD_VAR 0 2
58008: PPUSH
58009: LD_INT 101
58011: PPUSH
58012: CALL 52906 0 2
// continue ;
58016: GO 57817
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
58018: LD_ADDR_EXP 29
58022: PUSH
58023: LD_EXP 29
58027: PPUSH
58028: LD_VAR 0 2
58032: PPUSH
58033: EMPTY
58034: PPUSH
58035: CALL_OW 1
58039: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
58040: LD_VAR 0 2
58044: PPUSH
58045: LD_INT 103
58047: PPUSH
58048: CALL 52906 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
58052: LD_ADDR_VAR 0 5
58056: PUSH
58057: LD_EXP 23
58061: PUSH
58062: LD_VAR 0 2
58066: ARRAY
58067: PUSH
58068: LD_EXP 52
58072: PUSH
58073: LD_VAR 0 2
58077: ARRAY
58078: UNION
58079: PPUSH
58080: LD_INT 2
58082: PUSH
58083: LD_INT 25
58085: PUSH
58086: LD_INT 2
58088: PUSH
58089: EMPTY
58090: LIST
58091: LIST
58092: PUSH
58093: LD_INT 25
58095: PUSH
58096: LD_INT 16
58098: PUSH
58099: EMPTY
58100: LIST
58101: LIST
58102: PUSH
58103: EMPTY
58104: LIST
58105: LIST
58106: LIST
58107: PUSH
58108: EMPTY
58109: LIST
58110: PPUSH
58111: CALL_OW 72
58115: PUSH
58116: LD_EXP 26
58120: PUSH
58121: LD_VAR 0 2
58125: ARRAY
58126: PUSH
58127: LD_INT 1
58129: ARRAY
58130: PUSH
58131: LD_EXP 26
58135: PUSH
58136: LD_VAR 0 2
58140: ARRAY
58141: PUSH
58142: LD_INT 2
58144: ARRAY
58145: UNION
58146: DIFF
58147: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
58148: LD_ADDR_VAR 0 6
58152: PUSH
58153: LD_EXP 42
58157: PUSH
58158: LD_VAR 0 2
58162: ARRAY
58163: PPUSH
58164: LD_INT 2
58166: PUSH
58167: LD_INT 34
58169: PUSH
58170: LD_INT 13
58172: PUSH
58173: EMPTY
58174: LIST
58175: LIST
58176: PUSH
58177: LD_INT 34
58179: PUSH
58180: LD_INT 52
58182: PUSH
58183: EMPTY
58184: LIST
58185: LIST
58186: PUSH
58187: LD_INT 34
58189: PUSH
58190: LD_EXP 73
58194: PUSH
58195: EMPTY
58196: LIST
58197: LIST
58198: PUSH
58199: EMPTY
58200: LIST
58201: LIST
58202: LIST
58203: LIST
58204: PPUSH
58205: CALL_OW 72
58209: ST_TO_ADDR
// if cranes then
58210: LD_VAR 0 6
58214: IFFALSE 58350
// begin for j in cranes do
58216: LD_ADDR_VAR 0 3
58220: PUSH
58221: LD_VAR 0 6
58225: PUSH
58226: FOR_IN
58227: IFFALSE 58348
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
58229: LD_VAR 0 3
58233: PPUSH
58234: CALL_OW 256
58238: PUSH
58239: LD_INT 1000
58241: EQUAL
58242: PUSH
58243: LD_VAR 0 3
58247: PPUSH
58248: CALL_OW 314
58252: NOT
58253: AND
58254: IFFALSE 58288
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
58256: LD_VAR 0 3
58260: PPUSH
58261: LD_EXP 24
58265: PUSH
58266: LD_VAR 0 2
58270: ARRAY
58271: PPUSH
58272: LD_VAR 0 3
58276: PPUSH
58277: CALL_OW 74
58281: PPUSH
58282: CALL_OW 130
58286: GO 58346
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
58288: LD_VAR 0 3
58292: PPUSH
58293: CALL_OW 256
58297: PUSH
58298: LD_INT 500
58300: LESS
58301: PUSH
58302: LD_VAR 0 3
58306: PPUSH
58307: LD_EXP 47
58311: PUSH
58312: LD_VAR 0 2
58316: ARRAY
58317: PPUSH
58318: CALL_OW 308
58322: NOT
58323: AND
58324: IFFALSE 58346
// ComMoveToArea ( j , mc_parking [ i ] ) ;
58326: LD_VAR 0 3
58330: PPUSH
58331: LD_EXP 47
58335: PUSH
58336: LD_VAR 0 2
58340: ARRAY
58341: PPUSH
58342: CALL_OW 113
// end ;
58346: GO 58226
58348: POP
58349: POP
// end ; if tmp > 3 then
58350: LD_VAR 0 5
58354: PUSH
58355: LD_INT 3
58357: GREATER
58358: IFFALSE 58378
// tmp := ShrinkArray ( tmp , 4 ) ;
58360: LD_ADDR_VAR 0 5
58364: PUSH
58365: LD_VAR 0 5
58369: PPUSH
58370: LD_INT 4
58372: PPUSH
58373: CALL 47050 0 2
58377: ST_TO_ADDR
// if not tmp then
58378: LD_VAR 0 5
58382: NOT
58383: IFFALSE 58387
// continue ;
58385: GO 57817
// for j in tmp do
58387: LD_ADDR_VAR 0 3
58391: PUSH
58392: LD_VAR 0 5
58396: PUSH
58397: FOR_IN
58398: IFFALSE 58657
// begin if IsInUnit ( j ) then
58400: LD_VAR 0 3
58404: PPUSH
58405: CALL_OW 310
58409: IFFALSE 58420
// ComExitBuilding ( j ) ;
58411: LD_VAR 0 3
58415: PPUSH
58416: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
58420: LD_VAR 0 3
58424: PUSH
58425: LD_EXP 25
58429: PUSH
58430: LD_VAR 0 2
58434: ARRAY
58435: IN
58436: NOT
58437: IFFALSE 58495
// begin SetTag ( j , 101 ) ;
58439: LD_VAR 0 3
58443: PPUSH
58444: LD_INT 101
58446: PPUSH
58447: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
58451: LD_ADDR_EXP 25
58455: PUSH
58456: LD_EXP 25
58460: PPUSH
58461: LD_VAR 0 2
58465: PUSH
58466: LD_EXP 25
58470: PUSH
58471: LD_VAR 0 2
58475: ARRAY
58476: PUSH
58477: LD_INT 1
58479: PLUS
58480: PUSH
58481: EMPTY
58482: LIST
58483: LIST
58484: PPUSH
58485: LD_VAR 0 3
58489: PPUSH
58490: CALL 14983 0 3
58494: ST_TO_ADDR
// end ; wait ( 1 ) ;
58495: LD_INT 1
58497: PPUSH
58498: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
58502: LD_ADDR_VAR 0 7
58506: PUSH
58507: LD_EXP 24
58511: PUSH
58512: LD_VAR 0 2
58516: ARRAY
58517: ST_TO_ADDR
// if mc_scan [ i ] then
58518: LD_EXP 46
58522: PUSH
58523: LD_VAR 0 2
58527: ARRAY
58528: IFFALSE 58590
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
58530: LD_ADDR_VAR 0 7
58534: PUSH
58535: LD_EXP 24
58539: PUSH
58540: LD_VAR 0 2
58544: ARRAY
58545: PPUSH
58546: LD_INT 3
58548: PUSH
58549: LD_INT 30
58551: PUSH
58552: LD_INT 32
58554: PUSH
58555: EMPTY
58556: LIST
58557: LIST
58558: PUSH
58559: LD_INT 30
58561: PUSH
58562: LD_INT 33
58564: PUSH
58565: EMPTY
58566: LIST
58567: LIST
58568: PUSH
58569: LD_INT 30
58571: PUSH
58572: LD_INT 31
58574: PUSH
58575: EMPTY
58576: LIST
58577: LIST
58578: PUSH
58579: EMPTY
58580: LIST
58581: LIST
58582: LIST
58583: LIST
58584: PPUSH
58585: CALL_OW 72
58589: ST_TO_ADDR
// if not to_repair_tmp then
58590: LD_VAR 0 7
58594: NOT
58595: IFFALSE 58599
// continue ;
58597: GO 58397
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
58599: LD_ADDR_VAR 0 8
58603: PUSH
58604: LD_VAR 0 7
58608: PPUSH
58609: LD_VAR 0 3
58613: PPUSH
58614: CALL_OW 74
58618: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
58619: LD_VAR 0 8
58623: PPUSH
58624: LD_INT 16
58626: PPUSH
58627: CALL 17582 0 2
58631: PUSH
58632: LD_INT 4
58634: ARRAY
58635: PUSH
58636: LD_INT 10
58638: LESS
58639: IFFALSE 58655
// ComRepairBuilding ( j , to_repair ) ;
58641: LD_VAR 0 3
58645: PPUSH
58646: LD_VAR 0 8
58650: PPUSH
58651: CALL_OW 130
// end ;
58655: GO 58397
58657: POP
58658: POP
// end ;
58659: GO 57817
58661: POP
58662: POP
// end ;
58663: LD_VAR 0 1
58667: RET
// export function MC_Heal ; var i , j , tmp ; begin
58668: LD_INT 0
58670: PPUSH
58671: PPUSH
58672: PPUSH
58673: PPUSH
// if not mc_bases then
58674: LD_EXP 23
58678: NOT
58679: IFFALSE 58683
// exit ;
58681: GO 59085
// for i = 1 to mc_bases do
58683: LD_ADDR_VAR 0 2
58687: PUSH
58688: DOUBLE
58689: LD_INT 1
58691: DEC
58692: ST_TO_ADDR
58693: LD_EXP 23
58697: PUSH
58698: FOR_TO
58699: IFFALSE 59083
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
58701: LD_EXP 26
58705: PUSH
58706: LD_VAR 0 2
58710: ARRAY
58711: PUSH
58712: LD_INT 1
58714: ARRAY
58715: NOT
58716: PUSH
58717: LD_EXP 26
58721: PUSH
58722: LD_VAR 0 2
58726: ARRAY
58727: PUSH
58728: LD_INT 2
58730: ARRAY
58731: NOT
58732: AND
58733: IFFALSE 58771
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
58735: LD_ADDR_EXP 27
58739: PUSH
58740: LD_EXP 27
58744: PPUSH
58745: LD_VAR 0 2
58749: PPUSH
58750: EMPTY
58751: PPUSH
58752: CALL_OW 1
58756: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
58757: LD_VAR 0 2
58761: PPUSH
58762: LD_INT 102
58764: PPUSH
58765: CALL 52906 0 2
// continue ;
58769: GO 58698
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
58771: LD_ADDR_VAR 0 4
58775: PUSH
58776: LD_EXP 23
58780: PUSH
58781: LD_VAR 0 2
58785: ARRAY
58786: PPUSH
58787: LD_INT 25
58789: PUSH
58790: LD_INT 4
58792: PUSH
58793: EMPTY
58794: LIST
58795: LIST
58796: PPUSH
58797: CALL_OW 72
58801: ST_TO_ADDR
// if not tmp then
58802: LD_VAR 0 4
58806: NOT
58807: IFFALSE 58811
// continue ;
58809: GO 58698
// if mc_taming [ i ] then
58811: LD_EXP 54
58815: PUSH
58816: LD_VAR 0 2
58820: ARRAY
58821: IFFALSE 58845
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
58823: LD_ADDR_EXP 54
58827: PUSH
58828: LD_EXP 54
58832: PPUSH
58833: LD_VAR 0 2
58837: PPUSH
58838: EMPTY
58839: PPUSH
58840: CALL_OW 1
58844: ST_TO_ADDR
// for j in tmp do
58845: LD_ADDR_VAR 0 3
58849: PUSH
58850: LD_VAR 0 4
58854: PUSH
58855: FOR_IN
58856: IFFALSE 59079
// begin if IsInUnit ( j ) then
58858: LD_VAR 0 3
58862: PPUSH
58863: CALL_OW 310
58867: IFFALSE 58878
// ComExitBuilding ( j ) ;
58869: LD_VAR 0 3
58873: PPUSH
58874: CALL_OW 122
// if not j in mc_healers [ i ] then
58878: LD_VAR 0 3
58882: PUSH
58883: LD_EXP 27
58887: PUSH
58888: LD_VAR 0 2
58892: ARRAY
58893: IN
58894: NOT
58895: IFFALSE 58941
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
58897: LD_ADDR_EXP 27
58901: PUSH
58902: LD_EXP 27
58906: PPUSH
58907: LD_VAR 0 2
58911: PUSH
58912: LD_EXP 27
58916: PUSH
58917: LD_VAR 0 2
58921: ARRAY
58922: PUSH
58923: LD_INT 1
58925: PLUS
58926: PUSH
58927: EMPTY
58928: LIST
58929: LIST
58930: PPUSH
58931: LD_VAR 0 3
58935: PPUSH
58936: CALL 14983 0 3
58940: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
58941: LD_VAR 0 3
58945: PPUSH
58946: CALL_OW 110
58950: PUSH
58951: LD_INT 102
58953: NONEQUAL
58954: IFFALSE 58968
// SetTag ( j , 102 ) ;
58956: LD_VAR 0 3
58960: PPUSH
58961: LD_INT 102
58963: PPUSH
58964: CALL_OW 109
// Wait ( 3 ) ;
58968: LD_INT 3
58970: PPUSH
58971: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
58975: LD_EXP 26
58979: PUSH
58980: LD_VAR 0 2
58984: ARRAY
58985: PUSH
58986: LD_INT 1
58988: ARRAY
58989: IFFALSE 59021
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
58991: LD_VAR 0 3
58995: PPUSH
58996: LD_EXP 26
59000: PUSH
59001: LD_VAR 0 2
59005: ARRAY
59006: PUSH
59007: LD_INT 1
59009: ARRAY
59010: PUSH
59011: LD_INT 1
59013: ARRAY
59014: PPUSH
59015: CALL_OW 128
59019: GO 59077
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
59021: LD_VAR 0 3
59025: PPUSH
59026: CALL_OW 314
59030: NOT
59031: PUSH
59032: LD_EXP 26
59036: PUSH
59037: LD_VAR 0 2
59041: ARRAY
59042: PUSH
59043: LD_INT 2
59045: ARRAY
59046: AND
59047: IFFALSE 59077
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
59049: LD_VAR 0 3
59053: PPUSH
59054: LD_EXP 26
59058: PUSH
59059: LD_VAR 0 2
59063: ARRAY
59064: PUSH
59065: LD_INT 2
59067: ARRAY
59068: PUSH
59069: LD_INT 1
59071: ARRAY
59072: PPUSH
59073: CALL_OW 128
// end ;
59077: GO 58855
59079: POP
59080: POP
// end ;
59081: GO 58698
59083: POP
59084: POP
// end ;
59085: LD_VAR 0 1
59089: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
59090: LD_INT 0
59092: PPUSH
59093: PPUSH
59094: PPUSH
59095: PPUSH
59096: PPUSH
// if not mc_bases then
59097: LD_EXP 23
59101: NOT
59102: IFFALSE 59106
// exit ;
59104: GO 60277
// for i = 1 to mc_bases do
59106: LD_ADDR_VAR 0 2
59110: PUSH
59111: DOUBLE
59112: LD_INT 1
59114: DEC
59115: ST_TO_ADDR
59116: LD_EXP 23
59120: PUSH
59121: FOR_TO
59122: IFFALSE 60275
// begin if mc_scan [ i ] then
59124: LD_EXP 46
59128: PUSH
59129: LD_VAR 0 2
59133: ARRAY
59134: IFFALSE 59138
// continue ;
59136: GO 59121
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
59138: LD_EXP 28
59142: PUSH
59143: LD_VAR 0 2
59147: ARRAY
59148: NOT
59149: PUSH
59150: LD_EXP 30
59154: PUSH
59155: LD_VAR 0 2
59159: ARRAY
59160: NOT
59161: AND
59162: PUSH
59163: LD_EXP 29
59167: PUSH
59168: LD_VAR 0 2
59172: ARRAY
59173: AND
59174: IFFALSE 59212
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
59176: LD_ADDR_EXP 29
59180: PUSH
59181: LD_EXP 29
59185: PPUSH
59186: LD_VAR 0 2
59190: PPUSH
59191: EMPTY
59192: PPUSH
59193: CALL_OW 1
59197: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
59198: LD_VAR 0 2
59202: PPUSH
59203: LD_INT 103
59205: PPUSH
59206: CALL 52906 0 2
// continue ;
59210: GO 59121
// end ; if mc_construct_list [ i ] then
59212: LD_EXP 30
59216: PUSH
59217: LD_VAR 0 2
59221: ARRAY
59222: IFFALSE 59442
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
59224: LD_ADDR_VAR 0 4
59228: PUSH
59229: LD_EXP 23
59233: PUSH
59234: LD_VAR 0 2
59238: ARRAY
59239: PPUSH
59240: LD_INT 25
59242: PUSH
59243: LD_INT 2
59245: PUSH
59246: EMPTY
59247: LIST
59248: LIST
59249: PPUSH
59250: CALL_OW 72
59254: PUSH
59255: LD_EXP 25
59259: PUSH
59260: LD_VAR 0 2
59264: ARRAY
59265: DIFF
59266: ST_TO_ADDR
// if not tmp then
59267: LD_VAR 0 4
59271: NOT
59272: IFFALSE 59276
// continue ;
59274: GO 59121
// for j in tmp do
59276: LD_ADDR_VAR 0 3
59280: PUSH
59281: LD_VAR 0 4
59285: PUSH
59286: FOR_IN
59287: IFFALSE 59438
// begin if not mc_builders [ i ] then
59289: LD_EXP 29
59293: PUSH
59294: LD_VAR 0 2
59298: ARRAY
59299: NOT
59300: IFFALSE 59358
// begin SetTag ( j , 103 ) ;
59302: LD_VAR 0 3
59306: PPUSH
59307: LD_INT 103
59309: PPUSH
59310: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
59314: LD_ADDR_EXP 29
59318: PUSH
59319: LD_EXP 29
59323: PPUSH
59324: LD_VAR 0 2
59328: PUSH
59329: LD_EXP 29
59333: PUSH
59334: LD_VAR 0 2
59338: ARRAY
59339: PUSH
59340: LD_INT 1
59342: PLUS
59343: PUSH
59344: EMPTY
59345: LIST
59346: LIST
59347: PPUSH
59348: LD_VAR 0 3
59352: PPUSH
59353: CALL 14983 0 3
59357: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
59358: LD_VAR 0 3
59362: PPUSH
59363: CALL_OW 310
59367: IFFALSE 59378
// ComExitBuilding ( j ) ;
59369: LD_VAR 0 3
59373: PPUSH
59374: CALL_OW 122
// wait ( 3 ) ;
59378: LD_INT 3
59380: PPUSH
59381: CALL_OW 67
// if not mc_construct_list [ i ] then
59385: LD_EXP 30
59389: PUSH
59390: LD_VAR 0 2
59394: ARRAY
59395: NOT
59396: IFFALSE 59400
// break ;
59398: GO 59438
// if not HasTask ( j ) then
59400: LD_VAR 0 3
59404: PPUSH
59405: CALL_OW 314
59409: NOT
59410: IFFALSE 59436
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
59412: LD_VAR 0 3
59416: PPUSH
59417: LD_EXP 30
59421: PUSH
59422: LD_VAR 0 2
59426: ARRAY
59427: PUSH
59428: LD_INT 1
59430: ARRAY
59431: PPUSH
59432: CALL 17846 0 2
// end ;
59436: GO 59286
59438: POP
59439: POP
// end else
59440: GO 60273
// if mc_build_list [ i ] then
59442: LD_EXP 28
59446: PUSH
59447: LD_VAR 0 2
59451: ARRAY
59452: IFFALSE 60273
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
59454: LD_ADDR_VAR 0 5
59458: PUSH
59459: LD_EXP 23
59463: PUSH
59464: LD_VAR 0 2
59468: ARRAY
59469: PPUSH
59470: LD_INT 2
59472: PUSH
59473: LD_INT 30
59475: PUSH
59476: LD_INT 0
59478: PUSH
59479: EMPTY
59480: LIST
59481: LIST
59482: PUSH
59483: LD_INT 30
59485: PUSH
59486: LD_INT 1
59488: PUSH
59489: EMPTY
59490: LIST
59491: LIST
59492: PUSH
59493: EMPTY
59494: LIST
59495: LIST
59496: LIST
59497: PPUSH
59498: CALL_OW 72
59502: ST_TO_ADDR
// if depot then
59503: LD_VAR 0 5
59507: IFFALSE 59525
// depot := depot [ 1 ] else
59509: LD_ADDR_VAR 0 5
59513: PUSH
59514: LD_VAR 0 5
59518: PUSH
59519: LD_INT 1
59521: ARRAY
59522: ST_TO_ADDR
59523: GO 59533
// depot := 0 ;
59525: LD_ADDR_VAR 0 5
59529: PUSH
59530: LD_INT 0
59532: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
59533: LD_EXP 28
59537: PUSH
59538: LD_VAR 0 2
59542: ARRAY
59543: PUSH
59544: LD_INT 1
59546: ARRAY
59547: PUSH
59548: LD_INT 1
59550: ARRAY
59551: PPUSH
59552: CALL 17670 0 1
59556: PUSH
59557: LD_EXP 23
59561: PUSH
59562: LD_VAR 0 2
59566: ARRAY
59567: PPUSH
59568: LD_INT 2
59570: PUSH
59571: LD_INT 30
59573: PUSH
59574: LD_INT 2
59576: PUSH
59577: EMPTY
59578: LIST
59579: LIST
59580: PUSH
59581: LD_INT 30
59583: PUSH
59584: LD_INT 3
59586: PUSH
59587: EMPTY
59588: LIST
59589: LIST
59590: PUSH
59591: EMPTY
59592: LIST
59593: LIST
59594: LIST
59595: PPUSH
59596: CALL_OW 72
59600: NOT
59601: AND
59602: IFFALSE 59707
// begin for j = 1 to mc_build_list [ i ] do
59604: LD_ADDR_VAR 0 3
59608: PUSH
59609: DOUBLE
59610: LD_INT 1
59612: DEC
59613: ST_TO_ADDR
59614: LD_EXP 28
59618: PUSH
59619: LD_VAR 0 2
59623: ARRAY
59624: PUSH
59625: FOR_TO
59626: IFFALSE 59705
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
59628: LD_EXP 28
59632: PUSH
59633: LD_VAR 0 2
59637: ARRAY
59638: PUSH
59639: LD_VAR 0 3
59643: ARRAY
59644: PUSH
59645: LD_INT 1
59647: ARRAY
59648: PUSH
59649: LD_INT 2
59651: EQUAL
59652: IFFALSE 59703
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
59654: LD_ADDR_EXP 28
59658: PUSH
59659: LD_EXP 28
59663: PPUSH
59664: LD_VAR 0 2
59668: PPUSH
59669: LD_EXP 28
59673: PUSH
59674: LD_VAR 0 2
59678: ARRAY
59679: PPUSH
59680: LD_VAR 0 3
59684: PPUSH
59685: LD_INT 1
59687: PPUSH
59688: LD_INT 0
59690: PPUSH
59691: CALL 14401 0 4
59695: PPUSH
59696: CALL_OW 1
59700: ST_TO_ADDR
// break ;
59701: GO 59705
// end ;
59703: GO 59625
59705: POP
59706: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
59707: LD_EXP 28
59711: PUSH
59712: LD_VAR 0 2
59716: ARRAY
59717: PUSH
59718: LD_INT 1
59720: ARRAY
59721: PUSH
59722: LD_INT 1
59724: ARRAY
59725: PUSH
59726: LD_INT 0
59728: EQUAL
59729: PUSH
59730: LD_VAR 0 5
59734: PUSH
59735: LD_VAR 0 5
59739: PPUSH
59740: LD_EXP 28
59744: PUSH
59745: LD_VAR 0 2
59749: ARRAY
59750: PUSH
59751: LD_INT 1
59753: ARRAY
59754: PUSH
59755: LD_INT 1
59757: ARRAY
59758: PPUSH
59759: LD_EXP 28
59763: PUSH
59764: LD_VAR 0 2
59768: ARRAY
59769: PUSH
59770: LD_INT 1
59772: ARRAY
59773: PUSH
59774: LD_INT 2
59776: ARRAY
59777: PPUSH
59778: LD_EXP 28
59782: PUSH
59783: LD_VAR 0 2
59787: ARRAY
59788: PUSH
59789: LD_INT 1
59791: ARRAY
59792: PUSH
59793: LD_INT 3
59795: ARRAY
59796: PPUSH
59797: LD_EXP 28
59801: PUSH
59802: LD_VAR 0 2
59806: ARRAY
59807: PUSH
59808: LD_INT 1
59810: ARRAY
59811: PUSH
59812: LD_INT 4
59814: ARRAY
59815: PPUSH
59816: CALL 23087 0 5
59820: AND
59821: OR
59822: IFFALSE 60103
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
59824: LD_ADDR_VAR 0 4
59828: PUSH
59829: LD_EXP 23
59833: PUSH
59834: LD_VAR 0 2
59838: ARRAY
59839: PPUSH
59840: LD_INT 25
59842: PUSH
59843: LD_INT 2
59845: PUSH
59846: EMPTY
59847: LIST
59848: LIST
59849: PPUSH
59850: CALL_OW 72
59854: PUSH
59855: LD_EXP 25
59859: PUSH
59860: LD_VAR 0 2
59864: ARRAY
59865: DIFF
59866: ST_TO_ADDR
// if not tmp then
59867: LD_VAR 0 4
59871: NOT
59872: IFFALSE 59876
// continue ;
59874: GO 59121
// for j in tmp do
59876: LD_ADDR_VAR 0 3
59880: PUSH
59881: LD_VAR 0 4
59885: PUSH
59886: FOR_IN
59887: IFFALSE 60099
// begin if not mc_builders [ i ] then
59889: LD_EXP 29
59893: PUSH
59894: LD_VAR 0 2
59898: ARRAY
59899: NOT
59900: IFFALSE 59958
// begin SetTag ( j , 103 ) ;
59902: LD_VAR 0 3
59906: PPUSH
59907: LD_INT 103
59909: PPUSH
59910: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
59914: LD_ADDR_EXP 29
59918: PUSH
59919: LD_EXP 29
59923: PPUSH
59924: LD_VAR 0 2
59928: PUSH
59929: LD_EXP 29
59933: PUSH
59934: LD_VAR 0 2
59938: ARRAY
59939: PUSH
59940: LD_INT 1
59942: PLUS
59943: PUSH
59944: EMPTY
59945: LIST
59946: LIST
59947: PPUSH
59948: LD_VAR 0 3
59952: PPUSH
59953: CALL 14983 0 3
59957: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
59958: LD_VAR 0 3
59962: PPUSH
59963: CALL_OW 310
59967: IFFALSE 59978
// ComExitBuilding ( j ) ;
59969: LD_VAR 0 3
59973: PPUSH
59974: CALL_OW 122
// wait ( 3 ) ;
59978: LD_INT 3
59980: PPUSH
59981: CALL_OW 67
// if not mc_build_list [ i ] then
59985: LD_EXP 28
59989: PUSH
59990: LD_VAR 0 2
59994: ARRAY
59995: NOT
59996: IFFALSE 60000
// break ;
59998: GO 60099
// if not HasTask ( j ) then
60000: LD_VAR 0 3
60004: PPUSH
60005: CALL_OW 314
60009: NOT
60010: IFFALSE 60097
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
60012: LD_VAR 0 3
60016: PPUSH
60017: LD_EXP 28
60021: PUSH
60022: LD_VAR 0 2
60026: ARRAY
60027: PUSH
60028: LD_INT 1
60030: ARRAY
60031: PUSH
60032: LD_INT 1
60034: ARRAY
60035: PPUSH
60036: LD_EXP 28
60040: PUSH
60041: LD_VAR 0 2
60045: ARRAY
60046: PUSH
60047: LD_INT 1
60049: ARRAY
60050: PUSH
60051: LD_INT 2
60053: ARRAY
60054: PPUSH
60055: LD_EXP 28
60059: PUSH
60060: LD_VAR 0 2
60064: ARRAY
60065: PUSH
60066: LD_INT 1
60068: ARRAY
60069: PUSH
60070: LD_INT 3
60072: ARRAY
60073: PPUSH
60074: LD_EXP 28
60078: PUSH
60079: LD_VAR 0 2
60083: ARRAY
60084: PUSH
60085: LD_INT 1
60087: ARRAY
60088: PUSH
60089: LD_INT 4
60091: ARRAY
60092: PPUSH
60093: CALL_OW 145
// end ;
60097: GO 59886
60099: POP
60100: POP
// end else
60101: GO 60273
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
60103: LD_EXP 23
60107: PUSH
60108: LD_VAR 0 2
60112: ARRAY
60113: PPUSH
60114: LD_EXP 28
60118: PUSH
60119: LD_VAR 0 2
60123: ARRAY
60124: PUSH
60125: LD_INT 1
60127: ARRAY
60128: PUSH
60129: LD_INT 1
60131: ARRAY
60132: PPUSH
60133: LD_EXP 28
60137: PUSH
60138: LD_VAR 0 2
60142: ARRAY
60143: PUSH
60144: LD_INT 1
60146: ARRAY
60147: PUSH
60148: LD_INT 2
60150: ARRAY
60151: PPUSH
60152: LD_EXP 28
60156: PUSH
60157: LD_VAR 0 2
60161: ARRAY
60162: PUSH
60163: LD_INT 1
60165: ARRAY
60166: PUSH
60167: LD_INT 3
60169: ARRAY
60170: PPUSH
60171: LD_EXP 28
60175: PUSH
60176: LD_VAR 0 2
60180: ARRAY
60181: PUSH
60182: LD_INT 1
60184: ARRAY
60185: PUSH
60186: LD_INT 4
60188: ARRAY
60189: PPUSH
60190: LD_EXP 23
60194: PUSH
60195: LD_VAR 0 2
60199: ARRAY
60200: PPUSH
60201: LD_INT 21
60203: PUSH
60204: LD_INT 3
60206: PUSH
60207: EMPTY
60208: LIST
60209: LIST
60210: PPUSH
60211: CALL_OW 72
60215: PPUSH
60216: EMPTY
60217: PPUSH
60218: CALL 21837 0 7
60222: NOT
60223: IFFALSE 60273
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
60225: LD_ADDR_EXP 28
60229: PUSH
60230: LD_EXP 28
60234: PPUSH
60235: LD_VAR 0 2
60239: PPUSH
60240: LD_EXP 28
60244: PUSH
60245: LD_VAR 0 2
60249: ARRAY
60250: PPUSH
60251: LD_INT 1
60253: PPUSH
60254: LD_INT 1
60256: NEG
60257: PPUSH
60258: LD_INT 0
60260: PPUSH
60261: CALL 14401 0 4
60265: PPUSH
60266: CALL_OW 1
60270: ST_TO_ADDR
// continue ;
60271: GO 59121
// end ; end ; end ;
60273: GO 59121
60275: POP
60276: POP
// end ;
60277: LD_VAR 0 1
60281: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
60282: LD_INT 0
60284: PPUSH
60285: PPUSH
60286: PPUSH
60287: PPUSH
60288: PPUSH
60289: PPUSH
// if not mc_bases then
60290: LD_EXP 23
60294: NOT
60295: IFFALSE 60299
// exit ;
60297: GO 60726
// for i = 1 to mc_bases do
60299: LD_ADDR_VAR 0 2
60303: PUSH
60304: DOUBLE
60305: LD_INT 1
60307: DEC
60308: ST_TO_ADDR
60309: LD_EXP 23
60313: PUSH
60314: FOR_TO
60315: IFFALSE 60724
// begin tmp := mc_build_upgrade [ i ] ;
60317: LD_ADDR_VAR 0 4
60321: PUSH
60322: LD_EXP 55
60326: PUSH
60327: LD_VAR 0 2
60331: ARRAY
60332: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
60333: LD_ADDR_VAR 0 6
60337: PUSH
60338: LD_EXP 56
60342: PUSH
60343: LD_VAR 0 2
60347: ARRAY
60348: PPUSH
60349: LD_INT 2
60351: PUSH
60352: LD_INT 30
60354: PUSH
60355: LD_INT 6
60357: PUSH
60358: EMPTY
60359: LIST
60360: LIST
60361: PUSH
60362: LD_INT 30
60364: PUSH
60365: LD_INT 7
60367: PUSH
60368: EMPTY
60369: LIST
60370: LIST
60371: PUSH
60372: EMPTY
60373: LIST
60374: LIST
60375: LIST
60376: PPUSH
60377: CALL_OW 72
60381: ST_TO_ADDR
// if not tmp and not lab then
60382: LD_VAR 0 4
60386: NOT
60387: PUSH
60388: LD_VAR 0 6
60392: NOT
60393: AND
60394: IFFALSE 60398
// continue ;
60396: GO 60314
// if tmp then
60398: LD_VAR 0 4
60402: IFFALSE 60522
// for j in tmp do
60404: LD_ADDR_VAR 0 3
60408: PUSH
60409: LD_VAR 0 4
60413: PUSH
60414: FOR_IN
60415: IFFALSE 60520
// begin if UpgradeCost ( j ) then
60417: LD_VAR 0 3
60421: PPUSH
60422: CALL 21497 0 1
60426: IFFALSE 60518
// begin ComUpgrade ( j ) ;
60428: LD_VAR 0 3
60432: PPUSH
60433: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
60437: LD_ADDR_EXP 55
60441: PUSH
60442: LD_EXP 55
60446: PPUSH
60447: LD_VAR 0 2
60451: PPUSH
60452: LD_EXP 55
60456: PUSH
60457: LD_VAR 0 2
60461: ARRAY
60462: PUSH
60463: LD_VAR 0 3
60467: DIFF
60468: PPUSH
60469: CALL_OW 1
60473: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
60474: LD_ADDR_EXP 30
60478: PUSH
60479: LD_EXP 30
60483: PPUSH
60484: LD_VAR 0 2
60488: PUSH
60489: LD_EXP 30
60493: PUSH
60494: LD_VAR 0 2
60498: ARRAY
60499: PUSH
60500: LD_INT 1
60502: PLUS
60503: PUSH
60504: EMPTY
60505: LIST
60506: LIST
60507: PPUSH
60508: LD_VAR 0 3
60512: PPUSH
60513: CALL 14983 0 3
60517: ST_TO_ADDR
// end ; end ;
60518: GO 60414
60520: POP
60521: POP
// if not lab or not mc_lab_upgrade [ i ] then
60522: LD_VAR 0 6
60526: NOT
60527: PUSH
60528: LD_EXP 57
60532: PUSH
60533: LD_VAR 0 2
60537: ARRAY
60538: NOT
60539: OR
60540: IFFALSE 60544
// continue ;
60542: GO 60314
// for j in lab do
60544: LD_ADDR_VAR 0 3
60548: PUSH
60549: LD_VAR 0 6
60553: PUSH
60554: FOR_IN
60555: IFFALSE 60720
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
60557: LD_VAR 0 3
60561: PPUSH
60562: CALL_OW 266
60566: PUSH
60567: LD_INT 6
60569: PUSH
60570: LD_INT 7
60572: PUSH
60573: EMPTY
60574: LIST
60575: LIST
60576: IN
60577: PUSH
60578: LD_VAR 0 3
60582: PPUSH
60583: CALL_OW 461
60587: PUSH
60588: LD_INT 1
60590: NONEQUAL
60591: AND
60592: IFFALSE 60718
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
60594: LD_VAR 0 3
60598: PPUSH
60599: LD_EXP 57
60603: PUSH
60604: LD_VAR 0 2
60608: ARRAY
60609: PUSH
60610: LD_INT 1
60612: ARRAY
60613: PPUSH
60614: CALL 21702 0 2
60618: IFFALSE 60718
// begin ComCancel ( j ) ;
60620: LD_VAR 0 3
60624: PPUSH
60625: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
60629: LD_VAR 0 3
60633: PPUSH
60634: LD_EXP 57
60638: PUSH
60639: LD_VAR 0 2
60643: ARRAY
60644: PUSH
60645: LD_INT 1
60647: ARRAY
60648: PPUSH
60649: CALL_OW 207
// if not j in mc_construct_list [ i ] then
60653: LD_VAR 0 3
60657: PUSH
60658: LD_EXP 30
60662: PUSH
60663: LD_VAR 0 2
60667: ARRAY
60668: IN
60669: NOT
60670: IFFALSE 60716
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
60672: LD_ADDR_EXP 30
60676: PUSH
60677: LD_EXP 30
60681: PPUSH
60682: LD_VAR 0 2
60686: PUSH
60687: LD_EXP 30
60691: PUSH
60692: LD_VAR 0 2
60696: ARRAY
60697: PUSH
60698: LD_INT 1
60700: PLUS
60701: PUSH
60702: EMPTY
60703: LIST
60704: LIST
60705: PPUSH
60706: LD_VAR 0 3
60710: PPUSH
60711: CALL 14983 0 3
60715: ST_TO_ADDR
// break ;
60716: GO 60720
// end ; end ; end ;
60718: GO 60554
60720: POP
60721: POP
// end ;
60722: GO 60314
60724: POP
60725: POP
// end ;
60726: LD_VAR 0 1
60730: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
60731: LD_INT 0
60733: PPUSH
60734: PPUSH
60735: PPUSH
60736: PPUSH
60737: PPUSH
60738: PPUSH
60739: PPUSH
60740: PPUSH
60741: PPUSH
// if not mc_bases then
60742: LD_EXP 23
60746: NOT
60747: IFFALSE 60751
// exit ;
60749: GO 61156
// for i = 1 to mc_bases do
60751: LD_ADDR_VAR 0 2
60755: PUSH
60756: DOUBLE
60757: LD_INT 1
60759: DEC
60760: ST_TO_ADDR
60761: LD_EXP 23
60765: PUSH
60766: FOR_TO
60767: IFFALSE 61154
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
60769: LD_EXP 31
60773: PUSH
60774: LD_VAR 0 2
60778: ARRAY
60779: NOT
60780: PUSH
60781: LD_EXP 23
60785: PUSH
60786: LD_VAR 0 2
60790: ARRAY
60791: PPUSH
60792: LD_INT 30
60794: PUSH
60795: LD_INT 3
60797: PUSH
60798: EMPTY
60799: LIST
60800: LIST
60801: PPUSH
60802: CALL_OW 72
60806: NOT
60807: OR
60808: IFFALSE 60812
// continue ;
60810: GO 60766
// busy := false ;
60812: LD_ADDR_VAR 0 8
60816: PUSH
60817: LD_INT 0
60819: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
60820: LD_ADDR_VAR 0 4
60824: PUSH
60825: LD_EXP 23
60829: PUSH
60830: LD_VAR 0 2
60834: ARRAY
60835: PPUSH
60836: LD_INT 30
60838: PUSH
60839: LD_INT 3
60841: PUSH
60842: EMPTY
60843: LIST
60844: LIST
60845: PPUSH
60846: CALL_OW 72
60850: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
60851: LD_ADDR_VAR 0 6
60855: PUSH
60856: LD_EXP 31
60860: PUSH
60861: LD_VAR 0 2
60865: ARRAY
60866: PPUSH
60867: LD_INT 2
60869: PUSH
60870: LD_INT 30
60872: PUSH
60873: LD_INT 32
60875: PUSH
60876: EMPTY
60877: LIST
60878: LIST
60879: PUSH
60880: LD_INT 30
60882: PUSH
60883: LD_INT 33
60885: PUSH
60886: EMPTY
60887: LIST
60888: LIST
60889: PUSH
60890: EMPTY
60891: LIST
60892: LIST
60893: LIST
60894: PPUSH
60895: CALL_OW 72
60899: ST_TO_ADDR
// if not t then
60900: LD_VAR 0 6
60904: NOT
60905: IFFALSE 60909
// continue ;
60907: GO 60766
// for j in tmp do
60909: LD_ADDR_VAR 0 3
60913: PUSH
60914: LD_VAR 0 4
60918: PUSH
60919: FOR_IN
60920: IFFALSE 60950
// if not BuildingStatus ( j ) = bs_idle then
60922: LD_VAR 0 3
60926: PPUSH
60927: CALL_OW 461
60931: PUSH
60932: LD_INT 2
60934: EQUAL
60935: NOT
60936: IFFALSE 60948
// begin busy := true ;
60938: LD_ADDR_VAR 0 8
60942: PUSH
60943: LD_INT 1
60945: ST_TO_ADDR
// break ;
60946: GO 60950
// end ;
60948: GO 60919
60950: POP
60951: POP
// if busy then
60952: LD_VAR 0 8
60956: IFFALSE 60960
// continue ;
60958: GO 60766
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
60960: LD_ADDR_VAR 0 7
60964: PUSH
60965: LD_VAR 0 6
60969: PPUSH
60970: LD_INT 35
60972: PUSH
60973: LD_INT 0
60975: PUSH
60976: EMPTY
60977: LIST
60978: LIST
60979: PPUSH
60980: CALL_OW 72
60984: ST_TO_ADDR
// if tw then
60985: LD_VAR 0 7
60989: IFFALSE 61066
// begin tw := tw [ 1 ] ;
60991: LD_ADDR_VAR 0 7
60995: PUSH
60996: LD_VAR 0 7
61000: PUSH
61001: LD_INT 1
61003: ARRAY
61004: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
61005: LD_ADDR_VAR 0 9
61009: PUSH
61010: LD_VAR 0 7
61014: PPUSH
61015: LD_EXP 48
61019: PUSH
61020: LD_VAR 0 2
61024: ARRAY
61025: PPUSH
61026: CALL 19994 0 2
61030: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
61031: LD_EXP 62
61035: PUSH
61036: LD_VAR 0 2
61040: ARRAY
61041: IFFALSE 61064
// if not weapon in mc_allowed_tower_weapons [ i ] then
61043: LD_VAR 0 9
61047: PUSH
61048: LD_EXP 62
61052: PUSH
61053: LD_VAR 0 2
61057: ARRAY
61058: IN
61059: NOT
61060: IFFALSE 61064
// continue ;
61062: GO 60766
// end else
61064: GO 61129
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
61066: LD_ADDR_VAR 0 5
61070: PUSH
61071: LD_EXP 31
61075: PUSH
61076: LD_VAR 0 2
61080: ARRAY
61081: PPUSH
61082: LD_VAR 0 4
61086: PPUSH
61087: CALL 46283 0 2
61091: ST_TO_ADDR
// if not tmp2 then
61092: LD_VAR 0 5
61096: NOT
61097: IFFALSE 61101
// continue ;
61099: GO 60766
// tw := tmp2 [ 1 ] ;
61101: LD_ADDR_VAR 0 7
61105: PUSH
61106: LD_VAR 0 5
61110: PUSH
61111: LD_INT 1
61113: ARRAY
61114: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
61115: LD_ADDR_VAR 0 9
61119: PUSH
61120: LD_VAR 0 5
61124: PUSH
61125: LD_INT 2
61127: ARRAY
61128: ST_TO_ADDR
// end ; if not weapon then
61129: LD_VAR 0 9
61133: NOT
61134: IFFALSE 61138
// continue ;
61136: GO 60766
// ComPlaceWeapon ( tw , weapon ) ;
61138: LD_VAR 0 7
61142: PPUSH
61143: LD_VAR 0 9
61147: PPUSH
61148: CALL_OW 148
// end ;
61152: GO 60766
61154: POP
61155: POP
// end ;
61156: LD_VAR 0 1
61160: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
61161: LD_INT 0
61163: PPUSH
61164: PPUSH
61165: PPUSH
61166: PPUSH
61167: PPUSH
61168: PPUSH
61169: PPUSH
// if not mc_bases then
61170: LD_EXP 23
61174: NOT
61175: IFFALSE 61179
// exit ;
61177: GO 61947
// for i = 1 to mc_bases do
61179: LD_ADDR_VAR 0 2
61183: PUSH
61184: DOUBLE
61185: LD_INT 1
61187: DEC
61188: ST_TO_ADDR
61189: LD_EXP 23
61193: PUSH
61194: FOR_TO
61195: IFFALSE 61945
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
61197: LD_EXP 36
61201: PUSH
61202: LD_VAR 0 2
61206: ARRAY
61207: NOT
61208: PUSH
61209: LD_EXP 36
61213: PUSH
61214: LD_VAR 0 2
61218: ARRAY
61219: PUSH
61220: LD_EXP 37
61224: PUSH
61225: LD_VAR 0 2
61229: ARRAY
61230: EQUAL
61231: OR
61232: PUSH
61233: LD_EXP 46
61237: PUSH
61238: LD_VAR 0 2
61242: ARRAY
61243: OR
61244: IFFALSE 61248
// continue ;
61246: GO 61194
// if mc_miners [ i ] then
61248: LD_EXP 37
61252: PUSH
61253: LD_VAR 0 2
61257: ARRAY
61258: IFFALSE 61632
// begin for j = mc_miners [ i ] downto 1 do
61260: LD_ADDR_VAR 0 3
61264: PUSH
61265: DOUBLE
61266: LD_EXP 37
61270: PUSH
61271: LD_VAR 0 2
61275: ARRAY
61276: INC
61277: ST_TO_ADDR
61278: LD_INT 1
61280: PUSH
61281: FOR_DOWNTO
61282: IFFALSE 61630
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
61284: LD_EXP 37
61288: PUSH
61289: LD_VAR 0 2
61293: ARRAY
61294: PUSH
61295: LD_VAR 0 3
61299: ARRAY
61300: PPUSH
61301: CALL_OW 301
61305: PUSH
61306: LD_EXP 37
61310: PUSH
61311: LD_VAR 0 2
61315: ARRAY
61316: PUSH
61317: LD_VAR 0 3
61321: ARRAY
61322: PPUSH
61323: CALL_OW 257
61327: PUSH
61328: LD_INT 1
61330: NONEQUAL
61331: OR
61332: IFFALSE 61395
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
61334: LD_ADDR_VAR 0 5
61338: PUSH
61339: LD_EXP 37
61343: PUSH
61344: LD_VAR 0 2
61348: ARRAY
61349: PUSH
61350: LD_EXP 37
61354: PUSH
61355: LD_VAR 0 2
61359: ARRAY
61360: PUSH
61361: LD_VAR 0 3
61365: ARRAY
61366: DIFF
61367: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
61368: LD_ADDR_EXP 37
61372: PUSH
61373: LD_EXP 37
61377: PPUSH
61378: LD_VAR 0 2
61382: PPUSH
61383: LD_VAR 0 5
61387: PPUSH
61388: CALL_OW 1
61392: ST_TO_ADDR
// continue ;
61393: GO 61281
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
61395: LD_EXP 37
61399: PUSH
61400: LD_VAR 0 2
61404: ARRAY
61405: PUSH
61406: LD_VAR 0 3
61410: ARRAY
61411: PPUSH
61412: CALL_OW 257
61416: PUSH
61417: LD_INT 1
61419: EQUAL
61420: PUSH
61421: LD_EXP 37
61425: PUSH
61426: LD_VAR 0 2
61430: ARRAY
61431: PUSH
61432: LD_VAR 0 3
61436: ARRAY
61437: PPUSH
61438: CALL_OW 459
61442: NOT
61443: AND
61444: PUSH
61445: LD_EXP 37
61449: PUSH
61450: LD_VAR 0 2
61454: ARRAY
61455: PUSH
61456: LD_VAR 0 3
61460: ARRAY
61461: PPUSH
61462: CALL_OW 314
61466: NOT
61467: AND
61468: IFFALSE 61628
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
61470: LD_EXP 37
61474: PUSH
61475: LD_VAR 0 2
61479: ARRAY
61480: PUSH
61481: LD_VAR 0 3
61485: ARRAY
61486: PPUSH
61487: CALL_OW 310
61491: IFFALSE 61514
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
61493: LD_EXP 37
61497: PUSH
61498: LD_VAR 0 2
61502: ARRAY
61503: PUSH
61504: LD_VAR 0 3
61508: ARRAY
61509: PPUSH
61510: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
61514: LD_EXP 37
61518: PUSH
61519: LD_VAR 0 2
61523: ARRAY
61524: PUSH
61525: LD_VAR 0 3
61529: ARRAY
61530: PPUSH
61531: CALL_OW 314
61535: NOT
61536: IFFALSE 61628
// begin r := rand ( 1 , mc_mines [ i ] ) ;
61538: LD_ADDR_VAR 0 7
61542: PUSH
61543: LD_INT 1
61545: PPUSH
61546: LD_EXP 36
61550: PUSH
61551: LD_VAR 0 2
61555: ARRAY
61556: PPUSH
61557: CALL_OW 12
61561: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
61562: LD_EXP 37
61566: PUSH
61567: LD_VAR 0 2
61571: ARRAY
61572: PUSH
61573: LD_VAR 0 3
61577: ARRAY
61578: PPUSH
61579: LD_EXP 36
61583: PUSH
61584: LD_VAR 0 2
61588: ARRAY
61589: PUSH
61590: LD_VAR 0 7
61594: ARRAY
61595: PUSH
61596: LD_INT 1
61598: ARRAY
61599: PPUSH
61600: LD_EXP 36
61604: PUSH
61605: LD_VAR 0 2
61609: ARRAY
61610: PUSH
61611: LD_VAR 0 7
61615: ARRAY
61616: PUSH
61617: LD_INT 2
61619: ARRAY
61620: PPUSH
61621: LD_INT 0
61623: PPUSH
61624: CALL_OW 193
// end ; end ; end ;
61628: GO 61281
61630: POP
61631: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
61632: LD_ADDR_VAR 0 5
61636: PUSH
61637: LD_EXP 23
61641: PUSH
61642: LD_VAR 0 2
61646: ARRAY
61647: PPUSH
61648: LD_INT 2
61650: PUSH
61651: LD_INT 30
61653: PUSH
61654: LD_INT 4
61656: PUSH
61657: EMPTY
61658: LIST
61659: LIST
61660: PUSH
61661: LD_INT 30
61663: PUSH
61664: LD_INT 5
61666: PUSH
61667: EMPTY
61668: LIST
61669: LIST
61670: PUSH
61671: LD_INT 30
61673: PUSH
61674: LD_INT 32
61676: PUSH
61677: EMPTY
61678: LIST
61679: LIST
61680: PUSH
61681: EMPTY
61682: LIST
61683: LIST
61684: LIST
61685: LIST
61686: PPUSH
61687: CALL_OW 72
61691: ST_TO_ADDR
// if not tmp then
61692: LD_VAR 0 5
61696: NOT
61697: IFFALSE 61701
// continue ;
61699: GO 61194
// list := [ ] ;
61701: LD_ADDR_VAR 0 6
61705: PUSH
61706: EMPTY
61707: ST_TO_ADDR
// for j in tmp do
61708: LD_ADDR_VAR 0 3
61712: PUSH
61713: LD_VAR 0 5
61717: PUSH
61718: FOR_IN
61719: IFFALSE 61788
// begin for k in UnitsInside ( j ) do
61721: LD_ADDR_VAR 0 4
61725: PUSH
61726: LD_VAR 0 3
61730: PPUSH
61731: CALL_OW 313
61735: PUSH
61736: FOR_IN
61737: IFFALSE 61784
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
61739: LD_VAR 0 4
61743: PPUSH
61744: CALL_OW 257
61748: PUSH
61749: LD_INT 1
61751: EQUAL
61752: PUSH
61753: LD_VAR 0 4
61757: PPUSH
61758: CALL_OW 459
61762: NOT
61763: AND
61764: IFFALSE 61782
// list := list ^ k ;
61766: LD_ADDR_VAR 0 6
61770: PUSH
61771: LD_VAR 0 6
61775: PUSH
61776: LD_VAR 0 4
61780: ADD
61781: ST_TO_ADDR
61782: GO 61736
61784: POP
61785: POP
// end ;
61786: GO 61718
61788: POP
61789: POP
// list := list diff mc_miners [ i ] ;
61790: LD_ADDR_VAR 0 6
61794: PUSH
61795: LD_VAR 0 6
61799: PUSH
61800: LD_EXP 37
61804: PUSH
61805: LD_VAR 0 2
61809: ARRAY
61810: DIFF
61811: ST_TO_ADDR
// if not list then
61812: LD_VAR 0 6
61816: NOT
61817: IFFALSE 61821
// continue ;
61819: GO 61194
// k := mc_mines [ i ] - mc_miners [ i ] ;
61821: LD_ADDR_VAR 0 4
61825: PUSH
61826: LD_EXP 36
61830: PUSH
61831: LD_VAR 0 2
61835: ARRAY
61836: PUSH
61837: LD_EXP 37
61841: PUSH
61842: LD_VAR 0 2
61846: ARRAY
61847: MINUS
61848: ST_TO_ADDR
// if k > list then
61849: LD_VAR 0 4
61853: PUSH
61854: LD_VAR 0 6
61858: GREATER
61859: IFFALSE 61871
// k := list ;
61861: LD_ADDR_VAR 0 4
61865: PUSH
61866: LD_VAR 0 6
61870: ST_TO_ADDR
// for j = 1 to k do
61871: LD_ADDR_VAR 0 3
61875: PUSH
61876: DOUBLE
61877: LD_INT 1
61879: DEC
61880: ST_TO_ADDR
61881: LD_VAR 0 4
61885: PUSH
61886: FOR_TO
61887: IFFALSE 61941
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
61889: LD_ADDR_EXP 37
61893: PUSH
61894: LD_EXP 37
61898: PPUSH
61899: LD_VAR 0 2
61903: PUSH
61904: LD_EXP 37
61908: PUSH
61909: LD_VAR 0 2
61913: ARRAY
61914: PUSH
61915: LD_INT 1
61917: PLUS
61918: PUSH
61919: EMPTY
61920: LIST
61921: LIST
61922: PPUSH
61923: LD_VAR 0 6
61927: PUSH
61928: LD_VAR 0 3
61932: ARRAY
61933: PPUSH
61934: CALL 14983 0 3
61938: ST_TO_ADDR
61939: GO 61886
61941: POP
61942: POP
// end ;
61943: GO 61194
61945: POP
61946: POP
// end ;
61947: LD_VAR 0 1
61951: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
61952: LD_INT 0
61954: PPUSH
61955: PPUSH
61956: PPUSH
61957: PPUSH
61958: PPUSH
61959: PPUSH
61960: PPUSH
61961: PPUSH
61962: PPUSH
61963: PPUSH
61964: PPUSH
// if not mc_bases then
61965: LD_EXP 23
61969: NOT
61970: IFFALSE 61974
// exit ;
61972: GO 63797
// for i = 1 to mc_bases do
61974: LD_ADDR_VAR 0 2
61978: PUSH
61979: DOUBLE
61980: LD_INT 1
61982: DEC
61983: ST_TO_ADDR
61984: LD_EXP 23
61988: PUSH
61989: FOR_TO
61990: IFFALSE 63795
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
61992: LD_EXP 23
61996: PUSH
61997: LD_VAR 0 2
62001: ARRAY
62002: NOT
62003: PUSH
62004: LD_EXP 30
62008: PUSH
62009: LD_VAR 0 2
62013: ARRAY
62014: OR
62015: IFFALSE 62019
// continue ;
62017: GO 61989
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
62019: LD_EXP 39
62023: PUSH
62024: LD_VAR 0 2
62028: ARRAY
62029: NOT
62030: PUSH
62031: LD_EXP 40
62035: PUSH
62036: LD_VAR 0 2
62040: ARRAY
62041: AND
62042: IFFALSE 62080
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
62044: LD_ADDR_EXP 40
62048: PUSH
62049: LD_EXP 40
62053: PPUSH
62054: LD_VAR 0 2
62058: PPUSH
62059: EMPTY
62060: PPUSH
62061: CALL_OW 1
62065: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
62066: LD_VAR 0 2
62070: PPUSH
62071: LD_INT 107
62073: PPUSH
62074: CALL 52906 0 2
// continue ;
62078: GO 61989
// end ; target := [ ] ;
62080: LD_ADDR_VAR 0 7
62084: PUSH
62085: EMPTY
62086: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
62087: LD_ADDR_VAR 0 6
62091: PUSH
62092: LD_EXP 23
62096: PUSH
62097: LD_VAR 0 2
62101: ARRAY
62102: PUSH
62103: LD_INT 1
62105: ARRAY
62106: PPUSH
62107: CALL_OW 255
62111: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
62112: LD_ADDR_VAR 0 9
62116: PUSH
62117: LD_EXP 23
62121: PUSH
62122: LD_VAR 0 2
62126: ARRAY
62127: PPUSH
62128: LD_INT 2
62130: PUSH
62131: LD_INT 30
62133: PUSH
62134: LD_INT 0
62136: PUSH
62137: EMPTY
62138: LIST
62139: LIST
62140: PUSH
62141: LD_INT 30
62143: PUSH
62144: LD_INT 1
62146: PUSH
62147: EMPTY
62148: LIST
62149: LIST
62150: PUSH
62151: EMPTY
62152: LIST
62153: LIST
62154: LIST
62155: PPUSH
62156: CALL_OW 72
62160: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
62161: LD_ADDR_VAR 0 3
62165: PUSH
62166: DOUBLE
62167: LD_EXP 39
62171: PUSH
62172: LD_VAR 0 2
62176: ARRAY
62177: INC
62178: ST_TO_ADDR
62179: LD_INT 1
62181: PUSH
62182: FOR_DOWNTO
62183: IFFALSE 62428
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
62185: LD_EXP 39
62189: PUSH
62190: LD_VAR 0 2
62194: ARRAY
62195: PUSH
62196: LD_VAR 0 3
62200: ARRAY
62201: PUSH
62202: LD_INT 2
62204: ARRAY
62205: PPUSH
62206: LD_EXP 39
62210: PUSH
62211: LD_VAR 0 2
62215: ARRAY
62216: PUSH
62217: LD_VAR 0 3
62221: ARRAY
62222: PUSH
62223: LD_INT 3
62225: ARRAY
62226: PPUSH
62227: CALL_OW 488
62231: PUSH
62232: LD_EXP 39
62236: PUSH
62237: LD_VAR 0 2
62241: ARRAY
62242: PUSH
62243: LD_VAR 0 3
62247: ARRAY
62248: PUSH
62249: LD_INT 2
62251: ARRAY
62252: PPUSH
62253: LD_EXP 39
62257: PUSH
62258: LD_VAR 0 2
62262: ARRAY
62263: PUSH
62264: LD_VAR 0 3
62268: ARRAY
62269: PUSH
62270: LD_INT 3
62272: ARRAY
62273: PPUSH
62274: CALL_OW 284
62278: PUSH
62279: LD_INT 0
62281: EQUAL
62282: AND
62283: IFFALSE 62338
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
62285: LD_ADDR_VAR 0 5
62289: PUSH
62290: LD_EXP 39
62294: PUSH
62295: LD_VAR 0 2
62299: ARRAY
62300: PPUSH
62301: LD_VAR 0 3
62305: PPUSH
62306: CALL_OW 3
62310: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
62311: LD_ADDR_EXP 39
62315: PUSH
62316: LD_EXP 39
62320: PPUSH
62321: LD_VAR 0 2
62325: PPUSH
62326: LD_VAR 0 5
62330: PPUSH
62331: CALL_OW 1
62335: ST_TO_ADDR
// continue ;
62336: GO 62182
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
62338: LD_VAR 0 6
62342: PPUSH
62343: LD_EXP 39
62347: PUSH
62348: LD_VAR 0 2
62352: ARRAY
62353: PUSH
62354: LD_VAR 0 3
62358: ARRAY
62359: PUSH
62360: LD_INT 2
62362: ARRAY
62363: PPUSH
62364: LD_EXP 39
62368: PUSH
62369: LD_VAR 0 2
62373: ARRAY
62374: PUSH
62375: LD_VAR 0 3
62379: ARRAY
62380: PUSH
62381: LD_INT 3
62383: ARRAY
62384: PPUSH
62385: LD_INT 30
62387: PPUSH
62388: CALL 15879 0 4
62392: PUSH
62393: LD_INT 4
62395: ARRAY
62396: PUSH
62397: LD_INT 0
62399: EQUAL
62400: IFFALSE 62426
// begin target := mc_crates [ i ] [ j ] ;
62402: LD_ADDR_VAR 0 7
62406: PUSH
62407: LD_EXP 39
62411: PUSH
62412: LD_VAR 0 2
62416: ARRAY
62417: PUSH
62418: LD_VAR 0 3
62422: ARRAY
62423: ST_TO_ADDR
// break ;
62424: GO 62428
// end ; end ;
62426: GO 62182
62428: POP
62429: POP
// if not target then
62430: LD_VAR 0 7
62434: NOT
62435: IFFALSE 62439
// continue ;
62437: GO 61989
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
62439: LD_ADDR_VAR 0 8
62443: PUSH
62444: LD_EXP 42
62448: PUSH
62449: LD_VAR 0 2
62453: ARRAY
62454: PPUSH
62455: LD_INT 2
62457: PUSH
62458: LD_INT 3
62460: PUSH
62461: LD_INT 58
62463: PUSH
62464: EMPTY
62465: LIST
62466: PUSH
62467: EMPTY
62468: LIST
62469: LIST
62470: PUSH
62471: LD_INT 61
62473: PUSH
62474: EMPTY
62475: LIST
62476: PUSH
62477: LD_INT 33
62479: PUSH
62480: LD_INT 5
62482: PUSH
62483: EMPTY
62484: LIST
62485: LIST
62486: PUSH
62487: LD_INT 33
62489: PUSH
62490: LD_INT 3
62492: PUSH
62493: EMPTY
62494: LIST
62495: LIST
62496: PUSH
62497: EMPTY
62498: LIST
62499: LIST
62500: LIST
62501: LIST
62502: LIST
62503: PUSH
62504: LD_INT 2
62506: PUSH
62507: LD_INT 34
62509: PUSH
62510: LD_INT 32
62512: PUSH
62513: EMPTY
62514: LIST
62515: LIST
62516: PUSH
62517: LD_INT 34
62519: PUSH
62520: LD_INT 51
62522: PUSH
62523: EMPTY
62524: LIST
62525: LIST
62526: PUSH
62527: LD_INT 34
62529: PUSH
62530: LD_INT 12
62532: PUSH
62533: EMPTY
62534: LIST
62535: LIST
62536: PUSH
62537: EMPTY
62538: LIST
62539: LIST
62540: LIST
62541: LIST
62542: PUSH
62543: EMPTY
62544: LIST
62545: LIST
62546: PPUSH
62547: CALL_OW 72
62551: ST_TO_ADDR
// if not cargo then
62552: LD_VAR 0 8
62556: NOT
62557: IFFALSE 63263
// begin if mc_crates_collector [ i ] < 5 then
62559: LD_EXP 40
62563: PUSH
62564: LD_VAR 0 2
62568: ARRAY
62569: PUSH
62570: LD_INT 5
62572: LESS
62573: IFFALSE 62939
// begin if mc_ape [ i ] then
62575: LD_EXP 52
62579: PUSH
62580: LD_VAR 0 2
62584: ARRAY
62585: IFFALSE 62632
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
62587: LD_ADDR_VAR 0 5
62591: PUSH
62592: LD_EXP 52
62596: PUSH
62597: LD_VAR 0 2
62601: ARRAY
62602: PPUSH
62603: LD_INT 25
62605: PUSH
62606: LD_INT 16
62608: PUSH
62609: EMPTY
62610: LIST
62611: LIST
62612: PUSH
62613: LD_INT 24
62615: PUSH
62616: LD_INT 750
62618: PUSH
62619: EMPTY
62620: LIST
62621: LIST
62622: PUSH
62623: EMPTY
62624: LIST
62625: LIST
62626: PPUSH
62627: CALL_OW 72
62631: ST_TO_ADDR
// if not tmp then
62632: LD_VAR 0 5
62636: NOT
62637: IFFALSE 62684
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
62639: LD_ADDR_VAR 0 5
62643: PUSH
62644: LD_EXP 23
62648: PUSH
62649: LD_VAR 0 2
62653: ARRAY
62654: PPUSH
62655: LD_INT 25
62657: PUSH
62658: LD_INT 2
62660: PUSH
62661: EMPTY
62662: LIST
62663: LIST
62664: PUSH
62665: LD_INT 24
62667: PUSH
62668: LD_INT 750
62670: PUSH
62671: EMPTY
62672: LIST
62673: LIST
62674: PUSH
62675: EMPTY
62676: LIST
62677: LIST
62678: PPUSH
62679: CALL_OW 72
62683: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
62684: LD_EXP 52
62688: PUSH
62689: LD_VAR 0 2
62693: ARRAY
62694: PUSH
62695: LD_EXP 23
62699: PUSH
62700: LD_VAR 0 2
62704: ARRAY
62705: PPUSH
62706: LD_INT 25
62708: PUSH
62709: LD_INT 2
62711: PUSH
62712: EMPTY
62713: LIST
62714: LIST
62715: PUSH
62716: LD_INT 24
62718: PUSH
62719: LD_INT 750
62721: PUSH
62722: EMPTY
62723: LIST
62724: LIST
62725: PUSH
62726: EMPTY
62727: LIST
62728: LIST
62729: PPUSH
62730: CALL_OW 72
62734: AND
62735: PUSH
62736: LD_VAR 0 5
62740: PUSH
62741: LD_INT 5
62743: LESS
62744: AND
62745: IFFALSE 62827
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
62747: LD_ADDR_VAR 0 3
62751: PUSH
62752: LD_EXP 23
62756: PUSH
62757: LD_VAR 0 2
62761: ARRAY
62762: PPUSH
62763: LD_INT 25
62765: PUSH
62766: LD_INT 2
62768: PUSH
62769: EMPTY
62770: LIST
62771: LIST
62772: PUSH
62773: LD_INT 24
62775: PUSH
62776: LD_INT 750
62778: PUSH
62779: EMPTY
62780: LIST
62781: LIST
62782: PUSH
62783: EMPTY
62784: LIST
62785: LIST
62786: PPUSH
62787: CALL_OW 72
62791: PUSH
62792: FOR_IN
62793: IFFALSE 62825
// begin tmp := tmp union j ;
62795: LD_ADDR_VAR 0 5
62799: PUSH
62800: LD_VAR 0 5
62804: PUSH
62805: LD_VAR 0 3
62809: UNION
62810: ST_TO_ADDR
// if tmp >= 5 then
62811: LD_VAR 0 5
62815: PUSH
62816: LD_INT 5
62818: GREATEREQUAL
62819: IFFALSE 62823
// break ;
62821: GO 62825
// end ;
62823: GO 62792
62825: POP
62826: POP
// end ; if not tmp then
62827: LD_VAR 0 5
62831: NOT
62832: IFFALSE 62836
// continue ;
62834: GO 61989
// for j in tmp do
62836: LD_ADDR_VAR 0 3
62840: PUSH
62841: LD_VAR 0 5
62845: PUSH
62846: FOR_IN
62847: IFFALSE 62937
// if not GetTag ( j ) then
62849: LD_VAR 0 3
62853: PPUSH
62854: CALL_OW 110
62858: NOT
62859: IFFALSE 62935
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
62861: LD_ADDR_EXP 40
62865: PUSH
62866: LD_EXP 40
62870: PPUSH
62871: LD_VAR 0 2
62875: PUSH
62876: LD_EXP 40
62880: PUSH
62881: LD_VAR 0 2
62885: ARRAY
62886: PUSH
62887: LD_INT 1
62889: PLUS
62890: PUSH
62891: EMPTY
62892: LIST
62893: LIST
62894: PPUSH
62895: LD_VAR 0 3
62899: PPUSH
62900: CALL 14983 0 3
62904: ST_TO_ADDR
// SetTag ( j , 107 ) ;
62905: LD_VAR 0 3
62909: PPUSH
62910: LD_INT 107
62912: PPUSH
62913: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
62917: LD_EXP 40
62921: PUSH
62922: LD_VAR 0 2
62926: ARRAY
62927: PUSH
62928: LD_INT 5
62930: GREATEREQUAL
62931: IFFALSE 62935
// break ;
62933: GO 62937
// end ;
62935: GO 62846
62937: POP
62938: POP
// end ; if mc_crates_collector [ i ] and target then
62939: LD_EXP 40
62943: PUSH
62944: LD_VAR 0 2
62948: ARRAY
62949: PUSH
62950: LD_VAR 0 7
62954: AND
62955: IFFALSE 63261
// begin if mc_crates_collector [ i ] < target [ 1 ] then
62957: LD_EXP 40
62961: PUSH
62962: LD_VAR 0 2
62966: ARRAY
62967: PUSH
62968: LD_VAR 0 7
62972: PUSH
62973: LD_INT 1
62975: ARRAY
62976: LESS
62977: IFFALSE 62997
// tmp := mc_crates_collector [ i ] else
62979: LD_ADDR_VAR 0 5
62983: PUSH
62984: LD_EXP 40
62988: PUSH
62989: LD_VAR 0 2
62993: ARRAY
62994: ST_TO_ADDR
62995: GO 63011
// tmp := target [ 1 ] ;
62997: LD_ADDR_VAR 0 5
63001: PUSH
63002: LD_VAR 0 7
63006: PUSH
63007: LD_INT 1
63009: ARRAY
63010: ST_TO_ADDR
// k := 0 ;
63011: LD_ADDR_VAR 0 4
63015: PUSH
63016: LD_INT 0
63018: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
63019: LD_ADDR_VAR 0 3
63023: PUSH
63024: LD_EXP 40
63028: PUSH
63029: LD_VAR 0 2
63033: ARRAY
63034: PUSH
63035: FOR_IN
63036: IFFALSE 63259
// begin k := k + 1 ;
63038: LD_ADDR_VAR 0 4
63042: PUSH
63043: LD_VAR 0 4
63047: PUSH
63048: LD_INT 1
63050: PLUS
63051: ST_TO_ADDR
// if k > tmp then
63052: LD_VAR 0 4
63056: PUSH
63057: LD_VAR 0 5
63061: GREATER
63062: IFFALSE 63066
// break ;
63064: GO 63259
// if not GetClass ( j ) in [ 2 , 16 ] then
63066: LD_VAR 0 3
63070: PPUSH
63071: CALL_OW 257
63075: PUSH
63076: LD_INT 2
63078: PUSH
63079: LD_INT 16
63081: PUSH
63082: EMPTY
63083: LIST
63084: LIST
63085: IN
63086: NOT
63087: IFFALSE 63140
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
63089: LD_ADDR_EXP 40
63093: PUSH
63094: LD_EXP 40
63098: PPUSH
63099: LD_VAR 0 2
63103: PPUSH
63104: LD_EXP 40
63108: PUSH
63109: LD_VAR 0 2
63113: ARRAY
63114: PUSH
63115: LD_VAR 0 3
63119: DIFF
63120: PPUSH
63121: CALL_OW 1
63125: ST_TO_ADDR
// SetTag ( j , 0 ) ;
63126: LD_VAR 0 3
63130: PPUSH
63131: LD_INT 0
63133: PPUSH
63134: CALL_OW 109
// continue ;
63138: GO 63035
// end ; if IsInUnit ( j ) then
63140: LD_VAR 0 3
63144: PPUSH
63145: CALL_OW 310
63149: IFFALSE 63160
// ComExitBuilding ( j ) ;
63151: LD_VAR 0 3
63155: PPUSH
63156: CALL_OW 122
// wait ( 3 ) ;
63160: LD_INT 3
63162: PPUSH
63163: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
63167: LD_VAR 0 3
63171: PPUSH
63172: CALL_OW 314
63176: PUSH
63177: LD_VAR 0 6
63181: PPUSH
63182: LD_VAR 0 7
63186: PUSH
63187: LD_INT 2
63189: ARRAY
63190: PPUSH
63191: LD_VAR 0 7
63195: PUSH
63196: LD_INT 3
63198: ARRAY
63199: PPUSH
63200: LD_INT 30
63202: PPUSH
63203: CALL 15879 0 4
63207: PUSH
63208: LD_INT 4
63210: ARRAY
63211: AND
63212: IFFALSE 63230
// ComStandNearbyBuilding ( j , depot ) else
63214: LD_VAR 0 3
63218: PPUSH
63219: LD_VAR 0 9
63223: PPUSH
63224: CALL 11561 0 2
63228: GO 63257
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
63230: LD_VAR 0 3
63234: PPUSH
63235: LD_VAR 0 7
63239: PUSH
63240: LD_INT 2
63242: ARRAY
63243: PPUSH
63244: LD_VAR 0 7
63248: PUSH
63249: LD_INT 3
63251: ARRAY
63252: PPUSH
63253: CALL_OW 117
// end ;
63257: GO 63035
63259: POP
63260: POP
// end ; end else
63261: GO 63793
// begin for j in cargo do
63263: LD_ADDR_VAR 0 3
63267: PUSH
63268: LD_VAR 0 8
63272: PUSH
63273: FOR_IN
63274: IFFALSE 63791
// begin if GetTag ( j ) <> 0 then
63276: LD_VAR 0 3
63280: PPUSH
63281: CALL_OW 110
63285: PUSH
63286: LD_INT 0
63288: NONEQUAL
63289: IFFALSE 63293
// continue ;
63291: GO 63273
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
63293: LD_VAR 0 3
63297: PPUSH
63298: CALL_OW 256
63302: PUSH
63303: LD_INT 1000
63305: LESS
63306: PUSH
63307: LD_VAR 0 3
63311: PPUSH
63312: LD_EXP 47
63316: PUSH
63317: LD_VAR 0 2
63321: ARRAY
63322: PPUSH
63323: CALL_OW 308
63327: NOT
63328: AND
63329: IFFALSE 63351
// ComMoveToArea ( j , mc_parking [ i ] ) ;
63331: LD_VAR 0 3
63335: PPUSH
63336: LD_EXP 47
63340: PUSH
63341: LD_VAR 0 2
63345: ARRAY
63346: PPUSH
63347: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
63351: LD_VAR 0 3
63355: PPUSH
63356: CALL_OW 256
63360: PUSH
63361: LD_INT 1000
63363: LESS
63364: PUSH
63365: LD_VAR 0 3
63369: PPUSH
63370: LD_EXP 47
63374: PUSH
63375: LD_VAR 0 2
63379: ARRAY
63380: PPUSH
63381: CALL_OW 308
63385: AND
63386: IFFALSE 63390
// continue ;
63388: GO 63273
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
63390: LD_VAR 0 3
63394: PPUSH
63395: CALL_OW 262
63399: PUSH
63400: LD_INT 2
63402: EQUAL
63403: PUSH
63404: LD_VAR 0 3
63408: PPUSH
63409: CALL_OW 261
63413: PUSH
63414: LD_INT 15
63416: LESS
63417: AND
63418: IFFALSE 63422
// continue ;
63420: GO 63273
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
63422: LD_VAR 0 3
63426: PPUSH
63427: CALL_OW 262
63431: PUSH
63432: LD_INT 1
63434: EQUAL
63435: PUSH
63436: LD_VAR 0 3
63440: PPUSH
63441: CALL_OW 261
63445: PUSH
63446: LD_INT 10
63448: LESS
63449: AND
63450: IFFALSE 63730
// begin if not depot then
63452: LD_VAR 0 9
63456: NOT
63457: IFFALSE 63461
// continue ;
63459: GO 63273
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
63461: LD_VAR 0 3
63465: PPUSH
63466: LD_VAR 0 9
63470: PPUSH
63471: LD_VAR 0 3
63475: PPUSH
63476: CALL_OW 74
63480: PPUSH
63481: CALL_OW 296
63485: PUSH
63486: LD_INT 6
63488: LESS
63489: IFFALSE 63505
// SetFuel ( j , 100 ) else
63491: LD_VAR 0 3
63495: PPUSH
63496: LD_INT 100
63498: PPUSH
63499: CALL_OW 240
63503: GO 63730
// if GetFuel ( j ) = 0 then
63505: LD_VAR 0 3
63509: PPUSH
63510: CALL_OW 261
63514: PUSH
63515: LD_INT 0
63517: EQUAL
63518: IFFALSE 63730
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
63520: LD_ADDR_EXP 42
63524: PUSH
63525: LD_EXP 42
63529: PPUSH
63530: LD_VAR 0 2
63534: PPUSH
63535: LD_EXP 42
63539: PUSH
63540: LD_VAR 0 2
63544: ARRAY
63545: PUSH
63546: LD_VAR 0 3
63550: DIFF
63551: PPUSH
63552: CALL_OW 1
63556: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
63557: LD_VAR 0 3
63561: PPUSH
63562: CALL_OW 263
63566: PUSH
63567: LD_INT 1
63569: EQUAL
63570: IFFALSE 63586
// ComExitVehicle ( IsInUnit ( j ) ) ;
63572: LD_VAR 0 3
63576: PPUSH
63577: CALL_OW 310
63581: PPUSH
63582: CALL_OW 121
// if GetControl ( j ) = control_remote then
63586: LD_VAR 0 3
63590: PPUSH
63591: CALL_OW 263
63595: PUSH
63596: LD_INT 2
63598: EQUAL
63599: IFFALSE 63610
// ComUnlink ( j ) ;
63601: LD_VAR 0 3
63605: PPUSH
63606: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
63610: LD_ADDR_VAR 0 10
63614: PUSH
63615: LD_VAR 0 2
63619: PPUSH
63620: LD_INT 3
63622: PPUSH
63623: CALL 73222 0 2
63627: ST_TO_ADDR
// if fac then
63628: LD_VAR 0 10
63632: IFFALSE 63728
// begin for k in fac do
63634: LD_ADDR_VAR 0 4
63638: PUSH
63639: LD_VAR 0 10
63643: PUSH
63644: FOR_IN
63645: IFFALSE 63726
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
63647: LD_ADDR_VAR 0 11
63651: PUSH
63652: LD_VAR 0 10
63656: PPUSH
63657: LD_VAR 0 3
63661: PPUSH
63662: CALL_OW 265
63666: PPUSH
63667: LD_VAR 0 3
63671: PPUSH
63672: CALL_OW 262
63676: PPUSH
63677: LD_VAR 0 3
63681: PPUSH
63682: CALL_OW 263
63686: PPUSH
63687: LD_VAR 0 3
63691: PPUSH
63692: CALL_OW 264
63696: PPUSH
63697: CALL 12479 0 5
63701: ST_TO_ADDR
// if components then
63702: LD_VAR 0 11
63706: IFFALSE 63724
// begin MC_InsertProduceList ( i , components ) ;
63708: LD_VAR 0 2
63712: PPUSH
63713: LD_VAR 0 11
63717: PPUSH
63718: CALL 72767 0 2
// break ;
63722: GO 63726
// end ; end ;
63724: GO 63644
63726: POP
63727: POP
// end ; continue ;
63728: GO 63273
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
63730: LD_VAR 0 3
63734: PPUSH
63735: LD_INT 1
63737: PPUSH
63738: CALL_OW 289
63742: PUSH
63743: LD_INT 100
63745: LESS
63746: PUSH
63747: LD_VAR 0 3
63751: PPUSH
63752: CALL_OW 314
63756: NOT
63757: AND
63758: IFFALSE 63787
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
63760: LD_VAR 0 3
63764: PPUSH
63765: LD_VAR 0 7
63769: PUSH
63770: LD_INT 2
63772: ARRAY
63773: PPUSH
63774: LD_VAR 0 7
63778: PUSH
63779: LD_INT 3
63781: ARRAY
63782: PPUSH
63783: CALL_OW 117
// break ;
63787: GO 63791
// end ;
63789: GO 63273
63791: POP
63792: POP
// end ; end ;
63793: GO 61989
63795: POP
63796: POP
// end ;
63797: LD_VAR 0 1
63801: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
63802: LD_INT 0
63804: PPUSH
63805: PPUSH
63806: PPUSH
63807: PPUSH
// if not mc_bases then
63808: LD_EXP 23
63812: NOT
63813: IFFALSE 63817
// exit ;
63815: GO 63978
// for i = 1 to mc_bases do
63817: LD_ADDR_VAR 0 2
63821: PUSH
63822: DOUBLE
63823: LD_INT 1
63825: DEC
63826: ST_TO_ADDR
63827: LD_EXP 23
63831: PUSH
63832: FOR_TO
63833: IFFALSE 63976
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
63835: LD_ADDR_VAR 0 4
63839: PUSH
63840: LD_EXP 42
63844: PUSH
63845: LD_VAR 0 2
63849: ARRAY
63850: PUSH
63851: LD_EXP 45
63855: PUSH
63856: LD_VAR 0 2
63860: ARRAY
63861: UNION
63862: PPUSH
63863: LD_INT 33
63865: PUSH
63866: LD_INT 2
63868: PUSH
63869: EMPTY
63870: LIST
63871: LIST
63872: PPUSH
63873: CALL_OW 72
63877: ST_TO_ADDR
// if tmp then
63878: LD_VAR 0 4
63882: IFFALSE 63974
// for j in tmp do
63884: LD_ADDR_VAR 0 3
63888: PUSH
63889: LD_VAR 0 4
63893: PUSH
63894: FOR_IN
63895: IFFALSE 63972
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
63897: LD_VAR 0 3
63901: PPUSH
63902: CALL_OW 312
63906: NOT
63907: PUSH
63908: LD_VAR 0 3
63912: PPUSH
63913: CALL_OW 256
63917: PUSH
63918: LD_INT 250
63920: GREATEREQUAL
63921: AND
63922: IFFALSE 63935
// Connect ( j ) else
63924: LD_VAR 0 3
63928: PPUSH
63929: CALL 17954 0 1
63933: GO 63970
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
63935: LD_VAR 0 3
63939: PPUSH
63940: CALL_OW 256
63944: PUSH
63945: LD_INT 250
63947: LESS
63948: PUSH
63949: LD_VAR 0 3
63953: PPUSH
63954: CALL_OW 312
63958: AND
63959: IFFALSE 63970
// ComUnlink ( j ) ;
63961: LD_VAR 0 3
63965: PPUSH
63966: CALL_OW 136
63970: GO 63894
63972: POP
63973: POP
// end ;
63974: GO 63832
63976: POP
63977: POP
// end ;
63978: LD_VAR 0 1
63982: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
63983: LD_INT 0
63985: PPUSH
63986: PPUSH
63987: PPUSH
63988: PPUSH
63989: PPUSH
// if not mc_bases then
63990: LD_EXP 23
63994: NOT
63995: IFFALSE 63999
// exit ;
63997: GO 64444
// for i = 1 to mc_bases do
63999: LD_ADDR_VAR 0 2
64003: PUSH
64004: DOUBLE
64005: LD_INT 1
64007: DEC
64008: ST_TO_ADDR
64009: LD_EXP 23
64013: PUSH
64014: FOR_TO
64015: IFFALSE 64442
// begin if not mc_produce [ i ] then
64017: LD_EXP 44
64021: PUSH
64022: LD_VAR 0 2
64026: ARRAY
64027: NOT
64028: IFFALSE 64032
// continue ;
64030: GO 64014
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
64032: LD_ADDR_VAR 0 5
64036: PUSH
64037: LD_EXP 23
64041: PUSH
64042: LD_VAR 0 2
64046: ARRAY
64047: PPUSH
64048: LD_INT 30
64050: PUSH
64051: LD_INT 3
64053: PUSH
64054: EMPTY
64055: LIST
64056: LIST
64057: PPUSH
64058: CALL_OW 72
64062: ST_TO_ADDR
// if not fac then
64063: LD_VAR 0 5
64067: NOT
64068: IFFALSE 64072
// continue ;
64070: GO 64014
// for j in fac do
64072: LD_ADDR_VAR 0 3
64076: PUSH
64077: LD_VAR 0 5
64081: PUSH
64082: FOR_IN
64083: IFFALSE 64438
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
64085: LD_VAR 0 3
64089: PPUSH
64090: CALL_OW 461
64094: PUSH
64095: LD_INT 2
64097: NONEQUAL
64098: PUSH
64099: LD_VAR 0 3
64103: PPUSH
64104: LD_INT 15
64106: PPUSH
64107: CALL 17582 0 2
64111: PUSH
64112: LD_INT 4
64114: ARRAY
64115: OR
64116: IFFALSE 64120
// continue ;
64118: GO 64082
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
64120: LD_VAR 0 3
64124: PPUSH
64125: LD_EXP 44
64129: PUSH
64130: LD_VAR 0 2
64134: ARRAY
64135: PUSH
64136: LD_INT 1
64138: ARRAY
64139: PUSH
64140: LD_INT 1
64142: ARRAY
64143: PPUSH
64144: LD_EXP 44
64148: PUSH
64149: LD_VAR 0 2
64153: ARRAY
64154: PUSH
64155: LD_INT 1
64157: ARRAY
64158: PUSH
64159: LD_INT 2
64161: ARRAY
64162: PPUSH
64163: LD_EXP 44
64167: PUSH
64168: LD_VAR 0 2
64172: ARRAY
64173: PUSH
64174: LD_INT 1
64176: ARRAY
64177: PUSH
64178: LD_INT 3
64180: ARRAY
64181: PPUSH
64182: LD_EXP 44
64186: PUSH
64187: LD_VAR 0 2
64191: ARRAY
64192: PUSH
64193: LD_INT 1
64195: ARRAY
64196: PUSH
64197: LD_INT 4
64199: ARRAY
64200: PPUSH
64201: CALL_OW 448
64205: PUSH
64206: LD_VAR 0 3
64210: PPUSH
64211: LD_EXP 44
64215: PUSH
64216: LD_VAR 0 2
64220: ARRAY
64221: PUSH
64222: LD_INT 1
64224: ARRAY
64225: PUSH
64226: LD_INT 1
64228: ARRAY
64229: PUSH
64230: LD_EXP 44
64234: PUSH
64235: LD_VAR 0 2
64239: ARRAY
64240: PUSH
64241: LD_INT 1
64243: ARRAY
64244: PUSH
64245: LD_INT 2
64247: ARRAY
64248: PUSH
64249: LD_EXP 44
64253: PUSH
64254: LD_VAR 0 2
64258: ARRAY
64259: PUSH
64260: LD_INT 1
64262: ARRAY
64263: PUSH
64264: LD_INT 3
64266: ARRAY
64267: PUSH
64268: LD_EXP 44
64272: PUSH
64273: LD_VAR 0 2
64277: ARRAY
64278: PUSH
64279: LD_INT 1
64281: ARRAY
64282: PUSH
64283: LD_INT 4
64285: ARRAY
64286: PUSH
64287: EMPTY
64288: LIST
64289: LIST
64290: LIST
64291: LIST
64292: PPUSH
64293: CALL 21350 0 2
64297: AND
64298: IFFALSE 64436
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
64300: LD_VAR 0 3
64304: PPUSH
64305: LD_EXP 44
64309: PUSH
64310: LD_VAR 0 2
64314: ARRAY
64315: PUSH
64316: LD_INT 1
64318: ARRAY
64319: PUSH
64320: LD_INT 1
64322: ARRAY
64323: PPUSH
64324: LD_EXP 44
64328: PUSH
64329: LD_VAR 0 2
64333: ARRAY
64334: PUSH
64335: LD_INT 1
64337: ARRAY
64338: PUSH
64339: LD_INT 2
64341: ARRAY
64342: PPUSH
64343: LD_EXP 44
64347: PUSH
64348: LD_VAR 0 2
64352: ARRAY
64353: PUSH
64354: LD_INT 1
64356: ARRAY
64357: PUSH
64358: LD_INT 3
64360: ARRAY
64361: PPUSH
64362: LD_EXP 44
64366: PUSH
64367: LD_VAR 0 2
64371: ARRAY
64372: PUSH
64373: LD_INT 1
64375: ARRAY
64376: PUSH
64377: LD_INT 4
64379: ARRAY
64380: PPUSH
64381: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
64385: LD_ADDR_VAR 0 4
64389: PUSH
64390: LD_EXP 44
64394: PUSH
64395: LD_VAR 0 2
64399: ARRAY
64400: PPUSH
64401: LD_INT 1
64403: PPUSH
64404: CALL_OW 3
64408: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
64409: LD_ADDR_EXP 44
64413: PUSH
64414: LD_EXP 44
64418: PPUSH
64419: LD_VAR 0 2
64423: PPUSH
64424: LD_VAR 0 4
64428: PPUSH
64429: CALL_OW 1
64433: ST_TO_ADDR
// break ;
64434: GO 64438
// end ; end ;
64436: GO 64082
64438: POP
64439: POP
// end ;
64440: GO 64014
64442: POP
64443: POP
// end ;
64444: LD_VAR 0 1
64448: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
64449: LD_INT 0
64451: PPUSH
64452: PPUSH
64453: PPUSH
// if not mc_bases then
64454: LD_EXP 23
64458: NOT
64459: IFFALSE 64463
// exit ;
64461: GO 64552
// for i = 1 to mc_bases do
64463: LD_ADDR_VAR 0 2
64467: PUSH
64468: DOUBLE
64469: LD_INT 1
64471: DEC
64472: ST_TO_ADDR
64473: LD_EXP 23
64477: PUSH
64478: FOR_TO
64479: IFFALSE 64550
// begin if mc_attack [ i ] then
64481: LD_EXP 43
64485: PUSH
64486: LD_VAR 0 2
64490: ARRAY
64491: IFFALSE 64548
// begin tmp := mc_attack [ i ] [ 1 ] ;
64493: LD_ADDR_VAR 0 3
64497: PUSH
64498: LD_EXP 43
64502: PUSH
64503: LD_VAR 0 2
64507: ARRAY
64508: PUSH
64509: LD_INT 1
64511: ARRAY
64512: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
64513: LD_ADDR_EXP 43
64517: PUSH
64518: LD_EXP 43
64522: PPUSH
64523: LD_VAR 0 2
64527: PPUSH
64528: EMPTY
64529: PPUSH
64530: CALL_OW 1
64534: ST_TO_ADDR
// Attack ( tmp ) ;
64535: LD_VAR 0 3
64539: PPUSH
64540: CALL 79341 0 1
// exit ;
64544: POP
64545: POP
64546: GO 64552
// end ; end ;
64548: GO 64478
64550: POP
64551: POP
// end ;
64552: LD_VAR 0 1
64556: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
64557: LD_INT 0
64559: PPUSH
64560: PPUSH
64561: PPUSH
64562: PPUSH
64563: PPUSH
64564: PPUSH
64565: PPUSH
// if not mc_bases then
64566: LD_EXP 23
64570: NOT
64571: IFFALSE 64575
// exit ;
64573: GO 65285
// for i = 1 to mc_bases do
64575: LD_ADDR_VAR 0 2
64579: PUSH
64580: DOUBLE
64581: LD_INT 1
64583: DEC
64584: ST_TO_ADDR
64585: LD_EXP 23
64589: PUSH
64590: FOR_TO
64591: IFFALSE 65283
// begin if not mc_bases [ i ] then
64593: LD_EXP 23
64597: PUSH
64598: LD_VAR 0 2
64602: ARRAY
64603: NOT
64604: IFFALSE 64608
// continue ;
64606: GO 64590
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
64608: LD_ADDR_VAR 0 7
64612: PUSH
64613: LD_EXP 23
64617: PUSH
64618: LD_VAR 0 2
64622: ARRAY
64623: PUSH
64624: LD_INT 1
64626: ARRAY
64627: PPUSH
64628: CALL 11783 0 1
64632: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
64633: LD_ADDR_EXP 46
64637: PUSH
64638: LD_EXP 46
64642: PPUSH
64643: LD_VAR 0 2
64647: PPUSH
64648: LD_EXP 23
64652: PUSH
64653: LD_VAR 0 2
64657: ARRAY
64658: PUSH
64659: LD_INT 1
64661: ARRAY
64662: PPUSH
64663: CALL_OW 255
64667: PPUSH
64668: LD_EXP 48
64672: PUSH
64673: LD_VAR 0 2
64677: ARRAY
64678: PPUSH
64679: CALL 11748 0 2
64683: PPUSH
64684: CALL_OW 1
64688: ST_TO_ADDR
// if not mc_scan [ i ] then
64689: LD_EXP 46
64693: PUSH
64694: LD_VAR 0 2
64698: ARRAY
64699: NOT
64700: IFFALSE 64878
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
64702: LD_ADDR_EXP 66
64706: PUSH
64707: LD_EXP 66
64711: PPUSH
64712: LD_VAR 0 2
64716: PPUSH
64717: LD_INT 0
64719: PPUSH
64720: CALL_OW 1
64724: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
64725: LD_ADDR_VAR 0 4
64729: PUSH
64730: LD_EXP 23
64734: PUSH
64735: LD_VAR 0 2
64739: ARRAY
64740: PPUSH
64741: LD_INT 2
64743: PUSH
64744: LD_INT 25
64746: PUSH
64747: LD_INT 5
64749: PUSH
64750: EMPTY
64751: LIST
64752: LIST
64753: PUSH
64754: LD_INT 25
64756: PUSH
64757: LD_INT 8
64759: PUSH
64760: EMPTY
64761: LIST
64762: LIST
64763: PUSH
64764: LD_INT 25
64766: PUSH
64767: LD_INT 9
64769: PUSH
64770: EMPTY
64771: LIST
64772: LIST
64773: PUSH
64774: EMPTY
64775: LIST
64776: LIST
64777: LIST
64778: LIST
64779: PPUSH
64780: CALL_OW 72
64784: ST_TO_ADDR
// if not tmp then
64785: LD_VAR 0 4
64789: NOT
64790: IFFALSE 64794
// continue ;
64792: GO 64590
// for j in tmp do
64794: LD_ADDR_VAR 0 3
64798: PUSH
64799: LD_VAR 0 4
64803: PUSH
64804: FOR_IN
64805: IFFALSE 64876
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
64807: LD_VAR 0 3
64811: PPUSH
64812: CALL_OW 310
64816: PPUSH
64817: CALL_OW 266
64821: PUSH
64822: LD_INT 5
64824: EQUAL
64825: PUSH
64826: LD_VAR 0 3
64830: PPUSH
64831: CALL_OW 257
64835: PUSH
64836: LD_INT 1
64838: EQUAL
64839: AND
64840: PUSH
64841: LD_VAR 0 3
64845: PPUSH
64846: CALL_OW 459
64850: NOT
64851: AND
64852: PUSH
64853: LD_VAR 0 7
64857: AND
64858: IFFALSE 64874
// ComChangeProfession ( j , class ) ;
64860: LD_VAR 0 3
64864: PPUSH
64865: LD_VAR 0 7
64869: PPUSH
64870: CALL_OW 123
64874: GO 64804
64876: POP
64877: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] then
64878: LD_EXP 46
64882: PUSH
64883: LD_VAR 0 2
64887: ARRAY
64888: PUSH
64889: LD_EXP 66
64893: PUSH
64894: LD_VAR 0 2
64898: ARRAY
64899: NOT
64900: AND
64901: PUSH
64902: LD_EXP 45
64906: PUSH
64907: LD_VAR 0 2
64911: ARRAY
64912: NOT
64913: AND
64914: IFFALSE 65165
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
64916: LD_ADDR_EXP 66
64920: PUSH
64921: LD_EXP 66
64925: PPUSH
64926: LD_VAR 0 2
64930: PPUSH
64931: LD_INT 1
64933: PPUSH
64934: CALL_OW 1
64938: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
64939: LD_ADDR_VAR 0 4
64943: PUSH
64944: LD_EXP 23
64948: PUSH
64949: LD_VAR 0 2
64953: ARRAY
64954: PPUSH
64955: LD_INT 2
64957: PUSH
64958: LD_INT 25
64960: PUSH
64961: LD_INT 1
64963: PUSH
64964: EMPTY
64965: LIST
64966: LIST
64967: PUSH
64968: LD_INT 25
64970: PUSH
64971: LD_INT 5
64973: PUSH
64974: EMPTY
64975: LIST
64976: LIST
64977: PUSH
64978: LD_INT 25
64980: PUSH
64981: LD_INT 8
64983: PUSH
64984: EMPTY
64985: LIST
64986: LIST
64987: PUSH
64988: LD_INT 25
64990: PUSH
64991: LD_INT 9
64993: PUSH
64994: EMPTY
64995: LIST
64996: LIST
64997: PUSH
64998: EMPTY
64999: LIST
65000: LIST
65001: LIST
65002: LIST
65003: LIST
65004: PPUSH
65005: CALL_OW 72
65009: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
65010: LD_ADDR_VAR 0 4
65014: PUSH
65015: LD_VAR 0 4
65019: PUSH
65020: LD_VAR 0 4
65024: PPUSH
65025: LD_INT 18
65027: PPUSH
65028: CALL 44253 0 2
65032: DIFF
65033: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
65034: LD_VAR 0 4
65038: NOT
65039: PUSH
65040: LD_EXP 23
65044: PUSH
65045: LD_VAR 0 2
65049: ARRAY
65050: PPUSH
65051: LD_INT 2
65053: PUSH
65054: LD_INT 30
65056: PUSH
65057: LD_INT 4
65059: PUSH
65060: EMPTY
65061: LIST
65062: LIST
65063: PUSH
65064: LD_INT 30
65066: PUSH
65067: LD_INT 5
65069: PUSH
65070: EMPTY
65071: LIST
65072: LIST
65073: PUSH
65074: EMPTY
65075: LIST
65076: LIST
65077: LIST
65078: PPUSH
65079: CALL_OW 72
65083: NOT
65084: AND
65085: IFFALSE 65147
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
65087: LD_ADDR_VAR 0 4
65091: PUSH
65092: LD_EXP 23
65096: PUSH
65097: LD_VAR 0 2
65101: ARRAY
65102: PPUSH
65103: LD_INT 2
65105: PUSH
65106: LD_INT 25
65108: PUSH
65109: LD_INT 2
65111: PUSH
65112: EMPTY
65113: LIST
65114: LIST
65115: PUSH
65116: LD_INT 25
65118: PUSH
65119: LD_INT 3
65121: PUSH
65122: EMPTY
65123: LIST
65124: LIST
65125: PUSH
65126: LD_INT 25
65128: PUSH
65129: LD_INT 4
65131: PUSH
65132: EMPTY
65133: LIST
65134: LIST
65135: PUSH
65136: EMPTY
65137: LIST
65138: LIST
65139: LIST
65140: LIST
65141: PPUSH
65142: CALL_OW 72
65146: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
65147: LD_VAR 0 2
65151: PPUSH
65152: LD_VAR 0 4
65156: PPUSH
65157: CALL 84050 0 2
// exit ;
65161: POP
65162: POP
65163: GO 65285
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
65165: LD_EXP 46
65169: PUSH
65170: LD_VAR 0 2
65174: ARRAY
65175: PUSH
65176: LD_EXP 66
65180: PUSH
65181: LD_VAR 0 2
65185: ARRAY
65186: NOT
65187: AND
65188: PUSH
65189: LD_EXP 45
65193: PUSH
65194: LD_VAR 0 2
65198: ARRAY
65199: AND
65200: IFFALSE 65281
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
65202: LD_ADDR_EXP 66
65206: PUSH
65207: LD_EXP 66
65211: PPUSH
65212: LD_VAR 0 2
65216: PPUSH
65217: LD_INT 1
65219: PPUSH
65220: CALL_OW 1
65224: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
65225: LD_ADDR_VAR 0 4
65229: PUSH
65230: LD_EXP 45
65234: PUSH
65235: LD_VAR 0 2
65239: ARRAY
65240: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
65241: LD_ADDR_EXP 45
65245: PUSH
65246: LD_EXP 45
65250: PPUSH
65251: LD_VAR 0 2
65255: PPUSH
65256: EMPTY
65257: PPUSH
65258: CALL_OW 1
65262: ST_TO_ADDR
// Defend ( i , tmp ) ;
65263: LD_VAR 0 2
65267: PPUSH
65268: LD_VAR 0 4
65272: PPUSH
65273: CALL 84620 0 2
// exit ;
65277: POP
65278: POP
65279: GO 65285
// end ; end ;
65281: GO 64590
65283: POP
65284: POP
// end ;
65285: LD_VAR 0 1
65289: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
65290: LD_INT 0
65292: PPUSH
65293: PPUSH
65294: PPUSH
65295: PPUSH
65296: PPUSH
65297: PPUSH
65298: PPUSH
65299: PPUSH
65300: PPUSH
65301: PPUSH
65302: PPUSH
// if not mc_bases then
65303: LD_EXP 23
65307: NOT
65308: IFFALSE 65312
// exit ;
65310: GO 66399
// for i = 1 to mc_bases do
65312: LD_ADDR_VAR 0 2
65316: PUSH
65317: DOUBLE
65318: LD_INT 1
65320: DEC
65321: ST_TO_ADDR
65322: LD_EXP 23
65326: PUSH
65327: FOR_TO
65328: IFFALSE 66397
// begin tmp := mc_lab [ i ] ;
65330: LD_ADDR_VAR 0 6
65334: PUSH
65335: LD_EXP 56
65339: PUSH
65340: LD_VAR 0 2
65344: ARRAY
65345: ST_TO_ADDR
// if not tmp then
65346: LD_VAR 0 6
65350: NOT
65351: IFFALSE 65355
// continue ;
65353: GO 65327
// idle_lab := 0 ;
65355: LD_ADDR_VAR 0 11
65359: PUSH
65360: LD_INT 0
65362: ST_TO_ADDR
// for j in tmp do
65363: LD_ADDR_VAR 0 3
65367: PUSH
65368: LD_VAR 0 6
65372: PUSH
65373: FOR_IN
65374: IFFALSE 66393
// begin researching := false ;
65376: LD_ADDR_VAR 0 10
65380: PUSH
65381: LD_INT 0
65383: ST_TO_ADDR
// side := GetSide ( j ) ;
65384: LD_ADDR_VAR 0 4
65388: PUSH
65389: LD_VAR 0 3
65393: PPUSH
65394: CALL_OW 255
65398: ST_TO_ADDR
// if not mc_tech [ side ] then
65399: LD_EXP 50
65403: PUSH
65404: LD_VAR 0 4
65408: ARRAY
65409: NOT
65410: IFFALSE 65414
// continue ;
65412: GO 65373
// if BuildingStatus ( j ) = bs_idle then
65414: LD_VAR 0 3
65418: PPUSH
65419: CALL_OW 461
65423: PUSH
65424: LD_INT 2
65426: EQUAL
65427: IFFALSE 65615
// begin if idle_lab and UnitsInside ( j ) < 6 then
65429: LD_VAR 0 11
65433: PUSH
65434: LD_VAR 0 3
65438: PPUSH
65439: CALL_OW 313
65443: PUSH
65444: LD_INT 6
65446: LESS
65447: AND
65448: IFFALSE 65519
// begin tmp2 := UnitsInside ( idle_lab ) ;
65450: LD_ADDR_VAR 0 9
65454: PUSH
65455: LD_VAR 0 11
65459: PPUSH
65460: CALL_OW 313
65464: ST_TO_ADDR
// if tmp2 then
65465: LD_VAR 0 9
65469: IFFALSE 65511
// for x in tmp2 do
65471: LD_ADDR_VAR 0 7
65475: PUSH
65476: LD_VAR 0 9
65480: PUSH
65481: FOR_IN
65482: IFFALSE 65509
// begin ComExitBuilding ( x ) ;
65484: LD_VAR 0 7
65488: PPUSH
65489: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
65493: LD_VAR 0 7
65497: PPUSH
65498: LD_VAR 0 3
65502: PPUSH
65503: CALL_OW 180
// end ;
65507: GO 65481
65509: POP
65510: POP
// idle_lab := 0 ;
65511: LD_ADDR_VAR 0 11
65515: PUSH
65516: LD_INT 0
65518: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
65519: LD_ADDR_VAR 0 5
65523: PUSH
65524: LD_EXP 50
65528: PUSH
65529: LD_VAR 0 4
65533: ARRAY
65534: PUSH
65535: FOR_IN
65536: IFFALSE 65596
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
65538: LD_VAR 0 3
65542: PPUSH
65543: LD_VAR 0 5
65547: PPUSH
65548: CALL_OW 430
65552: PUSH
65553: LD_VAR 0 4
65557: PPUSH
65558: LD_VAR 0 5
65562: PPUSH
65563: CALL 10853 0 2
65567: AND
65568: IFFALSE 65594
// begin researching := true ;
65570: LD_ADDR_VAR 0 10
65574: PUSH
65575: LD_INT 1
65577: ST_TO_ADDR
// ComResearch ( j , t ) ;
65578: LD_VAR 0 3
65582: PPUSH
65583: LD_VAR 0 5
65587: PPUSH
65588: CALL_OW 124
// break ;
65592: GO 65596
// end ;
65594: GO 65535
65596: POP
65597: POP
// if not researching then
65598: LD_VAR 0 10
65602: NOT
65603: IFFALSE 65615
// idle_lab := j ;
65605: LD_ADDR_VAR 0 11
65609: PUSH
65610: LD_VAR 0 3
65614: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
65615: LD_VAR 0 3
65619: PPUSH
65620: CALL_OW 461
65624: PUSH
65625: LD_INT 10
65627: EQUAL
65628: IFFALSE 66216
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
65630: LD_EXP 52
65634: PUSH
65635: LD_VAR 0 2
65639: ARRAY
65640: NOT
65641: PUSH
65642: LD_EXP 53
65646: PUSH
65647: LD_VAR 0 2
65651: ARRAY
65652: NOT
65653: AND
65654: PUSH
65655: LD_EXP 50
65659: PUSH
65660: LD_VAR 0 4
65664: ARRAY
65665: PUSH
65666: LD_INT 1
65668: GREATER
65669: AND
65670: IFFALSE 65801
// begin ComCancel ( j ) ;
65672: LD_VAR 0 3
65676: PPUSH
65677: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
65681: LD_ADDR_EXP 50
65685: PUSH
65686: LD_EXP 50
65690: PPUSH
65691: LD_VAR 0 4
65695: PPUSH
65696: LD_EXP 50
65700: PUSH
65701: LD_VAR 0 4
65705: ARRAY
65706: PPUSH
65707: LD_EXP 50
65711: PUSH
65712: LD_VAR 0 4
65716: ARRAY
65717: PUSH
65718: LD_INT 1
65720: MINUS
65721: PPUSH
65722: LD_EXP 50
65726: PUSH
65727: LD_VAR 0 4
65731: ARRAY
65732: PPUSH
65733: LD_INT 0
65735: PPUSH
65736: CALL 14401 0 4
65740: PPUSH
65741: CALL_OW 1
65745: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
65746: LD_ADDR_EXP 50
65750: PUSH
65751: LD_EXP 50
65755: PPUSH
65756: LD_VAR 0 4
65760: PPUSH
65761: LD_EXP 50
65765: PUSH
65766: LD_VAR 0 4
65770: ARRAY
65771: PPUSH
65772: LD_EXP 50
65776: PUSH
65777: LD_VAR 0 4
65781: ARRAY
65782: PPUSH
65783: LD_INT 1
65785: PPUSH
65786: LD_INT 0
65788: PPUSH
65789: CALL 14401 0 4
65793: PPUSH
65794: CALL_OW 1
65798: ST_TO_ADDR
// continue ;
65799: GO 65373
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
65801: LD_EXP 52
65805: PUSH
65806: LD_VAR 0 2
65810: ARRAY
65811: PUSH
65812: LD_EXP 53
65816: PUSH
65817: LD_VAR 0 2
65821: ARRAY
65822: NOT
65823: AND
65824: IFFALSE 65951
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
65826: LD_ADDR_EXP 53
65830: PUSH
65831: LD_EXP 53
65835: PPUSH
65836: LD_VAR 0 2
65840: PUSH
65841: LD_EXP 53
65845: PUSH
65846: LD_VAR 0 2
65850: ARRAY
65851: PUSH
65852: LD_INT 1
65854: PLUS
65855: PUSH
65856: EMPTY
65857: LIST
65858: LIST
65859: PPUSH
65860: LD_EXP 52
65864: PUSH
65865: LD_VAR 0 2
65869: ARRAY
65870: PUSH
65871: LD_INT 1
65873: ARRAY
65874: PPUSH
65875: CALL 14983 0 3
65879: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
65880: LD_EXP 52
65884: PUSH
65885: LD_VAR 0 2
65889: ARRAY
65890: PUSH
65891: LD_INT 1
65893: ARRAY
65894: PPUSH
65895: LD_INT 112
65897: PPUSH
65898: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
65902: LD_ADDR_VAR 0 9
65906: PUSH
65907: LD_EXP 52
65911: PUSH
65912: LD_VAR 0 2
65916: ARRAY
65917: PPUSH
65918: LD_INT 1
65920: PPUSH
65921: CALL_OW 3
65925: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
65926: LD_ADDR_EXP 52
65930: PUSH
65931: LD_EXP 52
65935: PPUSH
65936: LD_VAR 0 2
65940: PPUSH
65941: LD_VAR 0 9
65945: PPUSH
65946: CALL_OW 1
65950: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
65951: LD_EXP 52
65955: PUSH
65956: LD_VAR 0 2
65960: ARRAY
65961: PUSH
65962: LD_EXP 53
65966: PUSH
65967: LD_VAR 0 2
65971: ARRAY
65972: AND
65973: PUSH
65974: LD_EXP 53
65978: PUSH
65979: LD_VAR 0 2
65983: ARRAY
65984: PUSH
65985: LD_INT 1
65987: ARRAY
65988: PPUSH
65989: CALL_OW 310
65993: NOT
65994: AND
65995: PUSH
65996: LD_VAR 0 3
66000: PPUSH
66001: CALL_OW 313
66005: PUSH
66006: LD_INT 6
66008: EQUAL
66009: AND
66010: IFFALSE 66066
// begin tmp2 := UnitsInside ( j ) ;
66012: LD_ADDR_VAR 0 9
66016: PUSH
66017: LD_VAR 0 3
66021: PPUSH
66022: CALL_OW 313
66026: ST_TO_ADDR
// if tmp2 = 6 then
66027: LD_VAR 0 9
66031: PUSH
66032: LD_INT 6
66034: EQUAL
66035: IFFALSE 66066
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
66037: LD_VAR 0 9
66041: PUSH
66042: LD_INT 1
66044: ARRAY
66045: PPUSH
66046: LD_INT 112
66048: PPUSH
66049: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
66053: LD_VAR 0 9
66057: PUSH
66058: LD_INT 1
66060: ARRAY
66061: PPUSH
66062: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
66066: LD_EXP 53
66070: PUSH
66071: LD_VAR 0 2
66075: ARRAY
66076: PUSH
66077: LD_EXP 53
66081: PUSH
66082: LD_VAR 0 2
66086: ARRAY
66087: PUSH
66088: LD_INT 1
66090: ARRAY
66091: PPUSH
66092: CALL_OW 314
66096: NOT
66097: AND
66098: PUSH
66099: LD_EXP 53
66103: PUSH
66104: LD_VAR 0 2
66108: ARRAY
66109: PUSH
66110: LD_INT 1
66112: ARRAY
66113: PPUSH
66114: CALL_OW 310
66118: NOT
66119: AND
66120: IFFALSE 66146
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
66122: LD_EXP 53
66126: PUSH
66127: LD_VAR 0 2
66131: ARRAY
66132: PUSH
66133: LD_INT 1
66135: ARRAY
66136: PPUSH
66137: LD_VAR 0 3
66141: PPUSH
66142: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
66146: LD_EXP 53
66150: PUSH
66151: LD_VAR 0 2
66155: ARRAY
66156: PUSH
66157: LD_INT 1
66159: ARRAY
66160: PPUSH
66161: CALL_OW 310
66165: PUSH
66166: LD_EXP 53
66170: PUSH
66171: LD_VAR 0 2
66175: ARRAY
66176: PUSH
66177: LD_INT 1
66179: ARRAY
66180: PPUSH
66181: CALL_OW 310
66185: PPUSH
66186: CALL_OW 461
66190: PUSH
66191: LD_INT 3
66193: NONEQUAL
66194: AND
66195: IFFALSE 66216
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
66197: LD_EXP 53
66201: PUSH
66202: LD_VAR 0 2
66206: ARRAY
66207: PUSH
66208: LD_INT 1
66210: ARRAY
66211: PPUSH
66212: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
66216: LD_VAR 0 3
66220: PPUSH
66221: CALL_OW 461
66225: PUSH
66226: LD_INT 6
66228: EQUAL
66229: PUSH
66230: LD_VAR 0 6
66234: PUSH
66235: LD_INT 1
66237: GREATER
66238: AND
66239: IFFALSE 66391
// begin sci := [ ] ;
66241: LD_ADDR_VAR 0 8
66245: PUSH
66246: EMPTY
66247: ST_TO_ADDR
// for x in ( tmp diff j ) do
66248: LD_ADDR_VAR 0 7
66252: PUSH
66253: LD_VAR 0 6
66257: PUSH
66258: LD_VAR 0 3
66262: DIFF
66263: PUSH
66264: FOR_IN
66265: IFFALSE 66317
// begin if sci = 6 then
66267: LD_VAR 0 8
66271: PUSH
66272: LD_INT 6
66274: EQUAL
66275: IFFALSE 66279
// break ;
66277: GO 66317
// if BuildingStatus ( x ) = bs_idle then
66279: LD_VAR 0 7
66283: PPUSH
66284: CALL_OW 461
66288: PUSH
66289: LD_INT 2
66291: EQUAL
66292: IFFALSE 66315
// sci := sci ^ UnitsInside ( x ) ;
66294: LD_ADDR_VAR 0 8
66298: PUSH
66299: LD_VAR 0 8
66303: PUSH
66304: LD_VAR 0 7
66308: PPUSH
66309: CALL_OW 313
66313: ADD
66314: ST_TO_ADDR
// end ;
66315: GO 66264
66317: POP
66318: POP
// if not sci then
66319: LD_VAR 0 8
66323: NOT
66324: IFFALSE 66328
// continue ;
66326: GO 65373
// for x in sci do
66328: LD_ADDR_VAR 0 7
66332: PUSH
66333: LD_VAR 0 8
66337: PUSH
66338: FOR_IN
66339: IFFALSE 66389
// if IsInUnit ( x ) and not HasTask ( x ) then
66341: LD_VAR 0 7
66345: PPUSH
66346: CALL_OW 310
66350: PUSH
66351: LD_VAR 0 7
66355: PPUSH
66356: CALL_OW 314
66360: NOT
66361: AND
66362: IFFALSE 66387
// begin ComExitBuilding ( x ) ;
66364: LD_VAR 0 7
66368: PPUSH
66369: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
66373: LD_VAR 0 7
66377: PPUSH
66378: LD_VAR 0 3
66382: PPUSH
66383: CALL_OW 180
// end ;
66387: GO 66338
66389: POP
66390: POP
// end ; end ;
66391: GO 65373
66393: POP
66394: POP
// end ;
66395: GO 65327
66397: POP
66398: POP
// end ;
66399: LD_VAR 0 1
66403: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
66404: LD_INT 0
66406: PPUSH
66407: PPUSH
// if not mc_bases then
66408: LD_EXP 23
66412: NOT
66413: IFFALSE 66417
// exit ;
66415: GO 66498
// for i = 1 to mc_bases do
66417: LD_ADDR_VAR 0 2
66421: PUSH
66422: DOUBLE
66423: LD_INT 1
66425: DEC
66426: ST_TO_ADDR
66427: LD_EXP 23
66431: PUSH
66432: FOR_TO
66433: IFFALSE 66496
// if mc_mines [ i ] and mc_miners [ i ] then
66435: LD_EXP 36
66439: PUSH
66440: LD_VAR 0 2
66444: ARRAY
66445: PUSH
66446: LD_EXP 37
66450: PUSH
66451: LD_VAR 0 2
66455: ARRAY
66456: AND
66457: IFFALSE 66494
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
66459: LD_EXP 37
66463: PUSH
66464: LD_VAR 0 2
66468: ARRAY
66469: PUSH
66470: LD_INT 1
66472: ARRAY
66473: PPUSH
66474: CALL_OW 255
66478: PPUSH
66479: LD_EXP 36
66483: PUSH
66484: LD_VAR 0 2
66488: ARRAY
66489: PPUSH
66490: CALL 11936 0 2
66494: GO 66432
66496: POP
66497: POP
// end ;
66498: LD_VAR 0 1
66502: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
66503: LD_INT 0
66505: PPUSH
66506: PPUSH
66507: PPUSH
66508: PPUSH
66509: PPUSH
66510: PPUSH
66511: PPUSH
66512: PPUSH
// if not mc_bases or not mc_parking then
66513: LD_EXP 23
66517: NOT
66518: PUSH
66519: LD_EXP 47
66523: NOT
66524: OR
66525: IFFALSE 66529
// exit ;
66527: GO 67239
// for i = 1 to mc_bases do
66529: LD_ADDR_VAR 0 2
66533: PUSH
66534: DOUBLE
66535: LD_INT 1
66537: DEC
66538: ST_TO_ADDR
66539: LD_EXP 23
66543: PUSH
66544: FOR_TO
66545: IFFALSE 67237
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
66547: LD_EXP 23
66551: PUSH
66552: LD_VAR 0 2
66556: ARRAY
66557: NOT
66558: PUSH
66559: LD_EXP 47
66563: PUSH
66564: LD_VAR 0 2
66568: ARRAY
66569: NOT
66570: OR
66571: IFFALSE 66575
// continue ;
66573: GO 66544
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
66575: LD_ADDR_VAR 0 5
66579: PUSH
66580: LD_EXP 23
66584: PUSH
66585: LD_VAR 0 2
66589: ARRAY
66590: PUSH
66591: LD_INT 1
66593: ARRAY
66594: PPUSH
66595: CALL_OW 255
66599: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
66600: LD_ADDR_VAR 0 6
66604: PUSH
66605: LD_EXP 23
66609: PUSH
66610: LD_VAR 0 2
66614: ARRAY
66615: PPUSH
66616: LD_INT 30
66618: PUSH
66619: LD_INT 3
66621: PUSH
66622: EMPTY
66623: LIST
66624: LIST
66625: PPUSH
66626: CALL_OW 72
66630: ST_TO_ADDR
// if not fac then
66631: LD_VAR 0 6
66635: NOT
66636: IFFALSE 66687
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
66638: LD_ADDR_VAR 0 6
66642: PUSH
66643: LD_EXP 23
66647: PUSH
66648: LD_VAR 0 2
66652: ARRAY
66653: PPUSH
66654: LD_INT 2
66656: PUSH
66657: LD_INT 30
66659: PUSH
66660: LD_INT 0
66662: PUSH
66663: EMPTY
66664: LIST
66665: LIST
66666: PUSH
66667: LD_INT 30
66669: PUSH
66670: LD_INT 1
66672: PUSH
66673: EMPTY
66674: LIST
66675: LIST
66676: PUSH
66677: EMPTY
66678: LIST
66679: LIST
66680: LIST
66681: PPUSH
66682: CALL_OW 72
66686: ST_TO_ADDR
// if not fac then
66687: LD_VAR 0 6
66691: NOT
66692: IFFALSE 66696
// continue ;
66694: GO 66544
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
66696: LD_ADDR_VAR 0 7
66700: PUSH
66701: LD_EXP 47
66705: PUSH
66706: LD_VAR 0 2
66710: ARRAY
66711: PPUSH
66712: LD_INT 22
66714: PUSH
66715: LD_VAR 0 5
66719: PUSH
66720: EMPTY
66721: LIST
66722: LIST
66723: PUSH
66724: LD_INT 21
66726: PUSH
66727: LD_INT 2
66729: PUSH
66730: EMPTY
66731: LIST
66732: LIST
66733: PUSH
66734: LD_INT 3
66736: PUSH
66737: LD_INT 24
66739: PUSH
66740: LD_INT 1000
66742: PUSH
66743: EMPTY
66744: LIST
66745: LIST
66746: PUSH
66747: EMPTY
66748: LIST
66749: LIST
66750: PUSH
66751: EMPTY
66752: LIST
66753: LIST
66754: LIST
66755: PPUSH
66756: CALL_OW 70
66760: ST_TO_ADDR
// for j in fac do
66761: LD_ADDR_VAR 0 3
66765: PUSH
66766: LD_VAR 0 6
66770: PUSH
66771: FOR_IN
66772: IFFALSE 66853
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
66774: LD_ADDR_VAR 0 7
66778: PUSH
66779: LD_VAR 0 7
66783: PUSH
66784: LD_INT 22
66786: PUSH
66787: LD_VAR 0 5
66791: PUSH
66792: EMPTY
66793: LIST
66794: LIST
66795: PUSH
66796: LD_INT 91
66798: PUSH
66799: LD_VAR 0 3
66803: PUSH
66804: LD_INT 15
66806: PUSH
66807: EMPTY
66808: LIST
66809: LIST
66810: LIST
66811: PUSH
66812: LD_INT 21
66814: PUSH
66815: LD_INT 2
66817: PUSH
66818: EMPTY
66819: LIST
66820: LIST
66821: PUSH
66822: LD_INT 3
66824: PUSH
66825: LD_INT 24
66827: PUSH
66828: LD_INT 1000
66830: PUSH
66831: EMPTY
66832: LIST
66833: LIST
66834: PUSH
66835: EMPTY
66836: LIST
66837: LIST
66838: PUSH
66839: EMPTY
66840: LIST
66841: LIST
66842: LIST
66843: LIST
66844: PPUSH
66845: CALL_OW 69
66849: UNION
66850: ST_TO_ADDR
66851: GO 66771
66853: POP
66854: POP
// if not vehs then
66855: LD_VAR 0 7
66859: NOT
66860: IFFALSE 66886
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
66862: LD_ADDR_EXP 35
66866: PUSH
66867: LD_EXP 35
66871: PPUSH
66872: LD_VAR 0 2
66876: PPUSH
66877: EMPTY
66878: PPUSH
66879: CALL_OW 1
66883: ST_TO_ADDR
// continue ;
66884: GO 66544
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
66886: LD_ADDR_VAR 0 8
66890: PUSH
66891: LD_EXP 23
66895: PUSH
66896: LD_VAR 0 2
66900: ARRAY
66901: PPUSH
66902: LD_INT 30
66904: PUSH
66905: LD_INT 3
66907: PUSH
66908: EMPTY
66909: LIST
66910: LIST
66911: PPUSH
66912: CALL_OW 72
66916: ST_TO_ADDR
// if tmp then
66917: LD_VAR 0 8
66921: IFFALSE 67024
// begin for j in tmp do
66923: LD_ADDR_VAR 0 3
66927: PUSH
66928: LD_VAR 0 8
66932: PUSH
66933: FOR_IN
66934: IFFALSE 67022
// for k in UnitsInside ( j ) do
66936: LD_ADDR_VAR 0 4
66940: PUSH
66941: LD_VAR 0 3
66945: PPUSH
66946: CALL_OW 313
66950: PUSH
66951: FOR_IN
66952: IFFALSE 67018
// if k then
66954: LD_VAR 0 4
66958: IFFALSE 67016
// if not k in mc_repair_vehicle [ i ] then
66960: LD_VAR 0 4
66964: PUSH
66965: LD_EXP 35
66969: PUSH
66970: LD_VAR 0 2
66974: ARRAY
66975: IN
66976: NOT
66977: IFFALSE 67016
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
66979: LD_ADDR_EXP 35
66983: PUSH
66984: LD_EXP 35
66988: PPUSH
66989: LD_VAR 0 2
66993: PPUSH
66994: LD_EXP 35
66998: PUSH
66999: LD_VAR 0 2
67003: ARRAY
67004: PUSH
67005: LD_VAR 0 4
67009: UNION
67010: PPUSH
67011: CALL_OW 1
67015: ST_TO_ADDR
67016: GO 66951
67018: POP
67019: POP
67020: GO 66933
67022: POP
67023: POP
// end ; if not mc_repair_vehicle [ i ] then
67024: LD_EXP 35
67028: PUSH
67029: LD_VAR 0 2
67033: ARRAY
67034: NOT
67035: IFFALSE 67039
// continue ;
67037: GO 66544
// for j in mc_repair_vehicle [ i ] do
67039: LD_ADDR_VAR 0 3
67043: PUSH
67044: LD_EXP 35
67048: PUSH
67049: LD_VAR 0 2
67053: ARRAY
67054: PUSH
67055: FOR_IN
67056: IFFALSE 67233
// begin if GetClass ( j ) <> 3 then
67058: LD_VAR 0 3
67062: PPUSH
67063: CALL_OW 257
67067: PUSH
67068: LD_INT 3
67070: NONEQUAL
67071: IFFALSE 67112
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
67073: LD_ADDR_EXP 35
67077: PUSH
67078: LD_EXP 35
67082: PPUSH
67083: LD_VAR 0 2
67087: PPUSH
67088: LD_EXP 35
67092: PUSH
67093: LD_VAR 0 2
67097: ARRAY
67098: PUSH
67099: LD_VAR 0 3
67103: DIFF
67104: PPUSH
67105: CALL_OW 1
67109: ST_TO_ADDR
// continue ;
67110: GO 67055
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
67112: LD_VAR 0 3
67116: PPUSH
67117: CALL_OW 311
67121: NOT
67122: PUSH
67123: LD_VAR 0 3
67127: PUSH
67128: LD_EXP 26
67132: PUSH
67133: LD_VAR 0 2
67137: ARRAY
67138: PUSH
67139: LD_INT 1
67141: ARRAY
67142: IN
67143: NOT
67144: AND
67145: PUSH
67146: LD_VAR 0 3
67150: PUSH
67151: LD_EXP 26
67155: PUSH
67156: LD_VAR 0 2
67160: ARRAY
67161: PUSH
67162: LD_INT 2
67164: ARRAY
67165: IN
67166: NOT
67167: AND
67168: IFFALSE 67231
// begin if IsInUnit ( j ) then
67170: LD_VAR 0 3
67174: PPUSH
67175: CALL_OW 310
67179: IFFALSE 67192
// ComExitBuilding ( j ) else
67181: LD_VAR 0 3
67185: PPUSH
67186: CALL_OW 122
67190: GO 67231
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
67192: LD_VAR 0 3
67196: PPUSH
67197: LD_VAR 0 7
67201: PUSH
67202: LD_INT 1
67204: ARRAY
67205: PPUSH
67206: CALL 48591 0 2
67210: NOT
67211: IFFALSE 67231
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
67213: LD_VAR 0 3
67217: PPUSH
67218: LD_VAR 0 7
67222: PUSH
67223: LD_INT 1
67225: ARRAY
67226: PPUSH
67227: CALL_OW 129
// end ; end ;
67231: GO 67055
67233: POP
67234: POP
// end ;
67235: GO 66544
67237: POP
67238: POP
// end ;
67239: LD_VAR 0 1
67243: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
67244: LD_INT 0
67246: PPUSH
67247: PPUSH
67248: PPUSH
67249: PPUSH
67250: PPUSH
67251: PPUSH
67252: PPUSH
67253: PPUSH
67254: PPUSH
67255: PPUSH
67256: PPUSH
// if not mc_bases then
67257: LD_EXP 23
67261: NOT
67262: IFFALSE 67266
// exit ;
67264: GO 68068
// for i = 1 to mc_bases do
67266: LD_ADDR_VAR 0 2
67270: PUSH
67271: DOUBLE
67272: LD_INT 1
67274: DEC
67275: ST_TO_ADDR
67276: LD_EXP 23
67280: PUSH
67281: FOR_TO
67282: IFFALSE 68066
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
67284: LD_EXP 51
67288: PUSH
67289: LD_VAR 0 2
67293: ARRAY
67294: NOT
67295: PUSH
67296: LD_EXP 26
67300: PUSH
67301: LD_VAR 0 2
67305: ARRAY
67306: PUSH
67307: LD_INT 1
67309: ARRAY
67310: OR
67311: PUSH
67312: LD_EXP 26
67316: PUSH
67317: LD_VAR 0 2
67321: ARRAY
67322: PUSH
67323: LD_INT 2
67325: ARRAY
67326: OR
67327: PUSH
67328: LD_EXP 49
67332: PUSH
67333: LD_VAR 0 2
67337: ARRAY
67338: PPUSH
67339: LD_INT 1
67341: PPUSH
67342: CALL_OW 325
67346: NOT
67347: OR
67348: PUSH
67349: LD_EXP 46
67353: PUSH
67354: LD_VAR 0 2
67358: ARRAY
67359: OR
67360: IFFALSE 67364
// continue ;
67362: GO 67281
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
67364: LD_ADDR_VAR 0 8
67368: PUSH
67369: LD_EXP 23
67373: PUSH
67374: LD_VAR 0 2
67378: ARRAY
67379: PPUSH
67380: LD_INT 25
67382: PUSH
67383: LD_INT 4
67385: PUSH
67386: EMPTY
67387: LIST
67388: LIST
67389: PUSH
67390: LD_INT 50
67392: PUSH
67393: EMPTY
67394: LIST
67395: PUSH
67396: LD_INT 3
67398: PUSH
67399: LD_INT 60
67401: PUSH
67402: EMPTY
67403: LIST
67404: PUSH
67405: EMPTY
67406: LIST
67407: LIST
67408: PUSH
67409: EMPTY
67410: LIST
67411: LIST
67412: LIST
67413: PPUSH
67414: CALL_OW 72
67418: PUSH
67419: LD_EXP 27
67423: PUSH
67424: LD_VAR 0 2
67428: ARRAY
67429: DIFF
67430: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67431: LD_ADDR_VAR 0 9
67435: PUSH
67436: LD_EXP 23
67440: PUSH
67441: LD_VAR 0 2
67445: ARRAY
67446: PPUSH
67447: LD_INT 2
67449: PUSH
67450: LD_INT 30
67452: PUSH
67453: LD_INT 0
67455: PUSH
67456: EMPTY
67457: LIST
67458: LIST
67459: PUSH
67460: LD_INT 30
67462: PUSH
67463: LD_INT 1
67465: PUSH
67466: EMPTY
67467: LIST
67468: LIST
67469: PUSH
67470: EMPTY
67471: LIST
67472: LIST
67473: LIST
67474: PPUSH
67475: CALL_OW 72
67479: ST_TO_ADDR
// if not tmp or not dep then
67480: LD_VAR 0 8
67484: NOT
67485: PUSH
67486: LD_VAR 0 9
67490: NOT
67491: OR
67492: IFFALSE 67496
// continue ;
67494: GO 67281
// side := GetSide ( tmp [ 1 ] ) ;
67496: LD_ADDR_VAR 0 11
67500: PUSH
67501: LD_VAR 0 8
67505: PUSH
67506: LD_INT 1
67508: ARRAY
67509: PPUSH
67510: CALL_OW 255
67514: ST_TO_ADDR
// dep := dep [ 1 ] ;
67515: LD_ADDR_VAR 0 9
67519: PUSH
67520: LD_VAR 0 9
67524: PUSH
67525: LD_INT 1
67527: ARRAY
67528: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
67529: LD_ADDR_VAR 0 7
67533: PUSH
67534: LD_EXP 51
67538: PUSH
67539: LD_VAR 0 2
67543: ARRAY
67544: PPUSH
67545: LD_INT 22
67547: PUSH
67548: LD_INT 0
67550: PUSH
67551: EMPTY
67552: LIST
67553: LIST
67554: PUSH
67555: LD_INT 25
67557: PUSH
67558: LD_INT 12
67560: PUSH
67561: EMPTY
67562: LIST
67563: LIST
67564: PUSH
67565: EMPTY
67566: LIST
67567: LIST
67568: PPUSH
67569: CALL_OW 70
67573: PUSH
67574: LD_INT 22
67576: PUSH
67577: LD_INT 0
67579: PUSH
67580: EMPTY
67581: LIST
67582: LIST
67583: PUSH
67584: LD_INT 25
67586: PUSH
67587: LD_INT 12
67589: PUSH
67590: EMPTY
67591: LIST
67592: LIST
67593: PUSH
67594: LD_INT 91
67596: PUSH
67597: LD_VAR 0 9
67601: PUSH
67602: LD_INT 20
67604: PUSH
67605: EMPTY
67606: LIST
67607: LIST
67608: LIST
67609: PUSH
67610: EMPTY
67611: LIST
67612: LIST
67613: LIST
67614: PPUSH
67615: CALL_OW 69
67619: UNION
67620: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
67621: LD_ADDR_VAR 0 10
67625: PUSH
67626: LD_EXP 51
67630: PUSH
67631: LD_VAR 0 2
67635: ARRAY
67636: PPUSH
67637: LD_INT 81
67639: PUSH
67640: LD_VAR 0 11
67644: PUSH
67645: EMPTY
67646: LIST
67647: LIST
67648: PPUSH
67649: CALL_OW 70
67653: ST_TO_ADDR
// if not apes or danger_at_area then
67654: LD_VAR 0 7
67658: NOT
67659: PUSH
67660: LD_VAR 0 10
67664: OR
67665: IFFALSE 67715
// begin if mc_taming [ i ] then
67667: LD_EXP 54
67671: PUSH
67672: LD_VAR 0 2
67676: ARRAY
67677: IFFALSE 67713
// begin MC_Reset ( i , 121 ) ;
67679: LD_VAR 0 2
67683: PPUSH
67684: LD_INT 121
67686: PPUSH
67687: CALL 52906 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
67691: LD_ADDR_EXP 54
67695: PUSH
67696: LD_EXP 54
67700: PPUSH
67701: LD_VAR 0 2
67705: PPUSH
67706: EMPTY
67707: PPUSH
67708: CALL_OW 1
67712: ST_TO_ADDR
// end ; continue ;
67713: GO 67281
// end ; for j in tmp do
67715: LD_ADDR_VAR 0 3
67719: PUSH
67720: LD_VAR 0 8
67724: PUSH
67725: FOR_IN
67726: IFFALSE 68062
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
67728: LD_VAR 0 3
67732: PUSH
67733: LD_EXP 54
67737: PUSH
67738: LD_VAR 0 2
67742: ARRAY
67743: IN
67744: NOT
67745: PUSH
67746: LD_EXP 54
67750: PUSH
67751: LD_VAR 0 2
67755: ARRAY
67756: PUSH
67757: LD_INT 3
67759: LESS
67760: AND
67761: IFFALSE 67819
// begin SetTag ( j , 121 ) ;
67763: LD_VAR 0 3
67767: PPUSH
67768: LD_INT 121
67770: PPUSH
67771: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
67775: LD_ADDR_EXP 54
67779: PUSH
67780: LD_EXP 54
67784: PPUSH
67785: LD_VAR 0 2
67789: PUSH
67790: LD_EXP 54
67794: PUSH
67795: LD_VAR 0 2
67799: ARRAY
67800: PUSH
67801: LD_INT 1
67803: PLUS
67804: PUSH
67805: EMPTY
67806: LIST
67807: LIST
67808: PPUSH
67809: LD_VAR 0 3
67813: PPUSH
67814: CALL 14983 0 3
67818: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
67819: LD_VAR 0 3
67823: PUSH
67824: LD_EXP 54
67828: PUSH
67829: LD_VAR 0 2
67833: ARRAY
67834: IN
67835: IFFALSE 68060
// begin if GetClass ( j ) <> 4 then
67837: LD_VAR 0 3
67841: PPUSH
67842: CALL_OW 257
67846: PUSH
67847: LD_INT 4
67849: NONEQUAL
67850: IFFALSE 67903
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
67852: LD_ADDR_EXP 54
67856: PUSH
67857: LD_EXP 54
67861: PPUSH
67862: LD_VAR 0 2
67866: PPUSH
67867: LD_EXP 54
67871: PUSH
67872: LD_VAR 0 2
67876: ARRAY
67877: PUSH
67878: LD_VAR 0 3
67882: DIFF
67883: PPUSH
67884: CALL_OW 1
67888: ST_TO_ADDR
// SetTag ( j , 0 ) ;
67889: LD_VAR 0 3
67893: PPUSH
67894: LD_INT 0
67896: PPUSH
67897: CALL_OW 109
// continue ;
67901: GO 67725
// end ; if IsInUnit ( j ) then
67903: LD_VAR 0 3
67907: PPUSH
67908: CALL_OW 310
67912: IFFALSE 67923
// ComExitBuilding ( j ) ;
67914: LD_VAR 0 3
67918: PPUSH
67919: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
67923: LD_ADDR_VAR 0 6
67927: PUSH
67928: LD_VAR 0 7
67932: PPUSH
67933: LD_VAR 0 3
67937: PPUSH
67938: CALL_OW 74
67942: ST_TO_ADDR
// if not ape then
67943: LD_VAR 0 6
67947: NOT
67948: IFFALSE 67952
// break ;
67950: GO 68062
// x := GetX ( ape ) ;
67952: LD_ADDR_VAR 0 4
67956: PUSH
67957: LD_VAR 0 6
67961: PPUSH
67962: CALL_OW 250
67966: ST_TO_ADDR
// y := GetY ( ape ) ;
67967: LD_ADDR_VAR 0 5
67971: PUSH
67972: LD_VAR 0 6
67976: PPUSH
67977: CALL_OW 251
67981: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
67982: LD_VAR 0 4
67986: PPUSH
67987: LD_VAR 0 5
67991: PPUSH
67992: CALL_OW 488
67996: NOT
67997: PUSH
67998: LD_VAR 0 11
68002: PPUSH
68003: LD_VAR 0 4
68007: PPUSH
68008: LD_VAR 0 5
68012: PPUSH
68013: LD_INT 20
68015: PPUSH
68016: CALL 15879 0 4
68020: PUSH
68021: LD_INT 4
68023: ARRAY
68024: OR
68025: IFFALSE 68029
// break ;
68027: GO 68062
// if not HasTask ( j ) then
68029: LD_VAR 0 3
68033: PPUSH
68034: CALL_OW 314
68038: NOT
68039: IFFALSE 68060
// ComTameXY ( j , x , y ) ;
68041: LD_VAR 0 3
68045: PPUSH
68046: LD_VAR 0 4
68050: PPUSH
68051: LD_VAR 0 5
68055: PPUSH
68056: CALL_OW 131
// end ; end ;
68060: GO 67725
68062: POP
68063: POP
// end ;
68064: GO 67281
68066: POP
68067: POP
// end ;
68068: LD_VAR 0 1
68072: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
68073: LD_INT 0
68075: PPUSH
68076: PPUSH
68077: PPUSH
68078: PPUSH
68079: PPUSH
68080: PPUSH
68081: PPUSH
68082: PPUSH
// if not mc_bases then
68083: LD_EXP 23
68087: NOT
68088: IFFALSE 68092
// exit ;
68090: GO 68718
// for i = 1 to mc_bases do
68092: LD_ADDR_VAR 0 2
68096: PUSH
68097: DOUBLE
68098: LD_INT 1
68100: DEC
68101: ST_TO_ADDR
68102: LD_EXP 23
68106: PUSH
68107: FOR_TO
68108: IFFALSE 68716
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
68110: LD_EXP 52
68114: PUSH
68115: LD_VAR 0 2
68119: ARRAY
68120: NOT
68121: PUSH
68122: LD_EXP 52
68126: PUSH
68127: LD_VAR 0 2
68131: ARRAY
68132: PPUSH
68133: LD_INT 25
68135: PUSH
68136: LD_INT 12
68138: PUSH
68139: EMPTY
68140: LIST
68141: LIST
68142: PPUSH
68143: CALL_OW 72
68147: NOT
68148: OR
68149: IFFALSE 68153
// continue ;
68151: GO 68107
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
68153: LD_ADDR_VAR 0 5
68157: PUSH
68158: LD_EXP 52
68162: PUSH
68163: LD_VAR 0 2
68167: ARRAY
68168: PUSH
68169: LD_INT 1
68171: ARRAY
68172: PPUSH
68173: CALL_OW 255
68177: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
68178: LD_VAR 0 5
68182: PPUSH
68183: LD_INT 2
68185: PPUSH
68186: CALL_OW 325
68190: IFFALSE 68443
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
68192: LD_ADDR_VAR 0 4
68196: PUSH
68197: LD_EXP 52
68201: PUSH
68202: LD_VAR 0 2
68206: ARRAY
68207: PPUSH
68208: LD_INT 25
68210: PUSH
68211: LD_INT 16
68213: PUSH
68214: EMPTY
68215: LIST
68216: LIST
68217: PPUSH
68218: CALL_OW 72
68222: ST_TO_ADDR
// if tmp < 6 then
68223: LD_VAR 0 4
68227: PUSH
68228: LD_INT 6
68230: LESS
68231: IFFALSE 68443
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68233: LD_ADDR_VAR 0 6
68237: PUSH
68238: LD_EXP 23
68242: PUSH
68243: LD_VAR 0 2
68247: ARRAY
68248: PPUSH
68249: LD_INT 2
68251: PUSH
68252: LD_INT 30
68254: PUSH
68255: LD_INT 0
68257: PUSH
68258: EMPTY
68259: LIST
68260: LIST
68261: PUSH
68262: LD_INT 30
68264: PUSH
68265: LD_INT 1
68267: PUSH
68268: EMPTY
68269: LIST
68270: LIST
68271: PUSH
68272: EMPTY
68273: LIST
68274: LIST
68275: LIST
68276: PPUSH
68277: CALL_OW 72
68281: ST_TO_ADDR
// if depot then
68282: LD_VAR 0 6
68286: IFFALSE 68443
// begin selected := 0 ;
68288: LD_ADDR_VAR 0 7
68292: PUSH
68293: LD_INT 0
68295: ST_TO_ADDR
// for j in depot do
68296: LD_ADDR_VAR 0 3
68300: PUSH
68301: LD_VAR 0 6
68305: PUSH
68306: FOR_IN
68307: IFFALSE 68338
// begin if UnitsInside ( j ) < 6 then
68309: LD_VAR 0 3
68313: PPUSH
68314: CALL_OW 313
68318: PUSH
68319: LD_INT 6
68321: LESS
68322: IFFALSE 68336
// begin selected := j ;
68324: LD_ADDR_VAR 0 7
68328: PUSH
68329: LD_VAR 0 3
68333: ST_TO_ADDR
// break ;
68334: GO 68338
// end ; end ;
68336: GO 68306
68338: POP
68339: POP
// if selected then
68340: LD_VAR 0 7
68344: IFFALSE 68443
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
68346: LD_ADDR_VAR 0 3
68350: PUSH
68351: LD_EXP 52
68355: PUSH
68356: LD_VAR 0 2
68360: ARRAY
68361: PPUSH
68362: LD_INT 25
68364: PUSH
68365: LD_INT 12
68367: PUSH
68368: EMPTY
68369: LIST
68370: LIST
68371: PPUSH
68372: CALL_OW 72
68376: PUSH
68377: FOR_IN
68378: IFFALSE 68441
// if not HasTask ( j ) then
68380: LD_VAR 0 3
68384: PPUSH
68385: CALL_OW 314
68389: NOT
68390: IFFALSE 68439
// begin if not IsInUnit ( j ) then
68392: LD_VAR 0 3
68396: PPUSH
68397: CALL_OW 310
68401: NOT
68402: IFFALSE 68418
// ComEnterUnit ( j , selected ) ;
68404: LD_VAR 0 3
68408: PPUSH
68409: LD_VAR 0 7
68413: PPUSH
68414: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
68418: LD_VAR 0 3
68422: PPUSH
68423: LD_INT 16
68425: PPUSH
68426: CALL_OW 183
// AddComExitBuilding ( j ) ;
68430: LD_VAR 0 3
68434: PPUSH
68435: CALL_OW 182
// end ;
68439: GO 68377
68441: POP
68442: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
68443: LD_VAR 0 5
68447: PPUSH
68448: LD_INT 11
68450: PPUSH
68451: CALL_OW 325
68455: IFFALSE 68714
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
68457: LD_ADDR_VAR 0 4
68461: PUSH
68462: LD_EXP 52
68466: PUSH
68467: LD_VAR 0 2
68471: ARRAY
68472: PPUSH
68473: LD_INT 25
68475: PUSH
68476: LD_INT 16
68478: PUSH
68479: EMPTY
68480: LIST
68481: LIST
68482: PPUSH
68483: CALL_OW 72
68487: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
68488: LD_VAR 0 4
68492: PUSH
68493: LD_INT 6
68495: GREATEREQUAL
68496: PUSH
68497: LD_VAR 0 5
68501: PPUSH
68502: LD_INT 2
68504: PPUSH
68505: CALL_OW 325
68509: NOT
68510: OR
68511: IFFALSE 68714
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
68513: LD_ADDR_VAR 0 8
68517: PUSH
68518: LD_EXP 23
68522: PUSH
68523: LD_VAR 0 2
68527: ARRAY
68528: PPUSH
68529: LD_INT 2
68531: PUSH
68532: LD_INT 30
68534: PUSH
68535: LD_INT 4
68537: PUSH
68538: EMPTY
68539: LIST
68540: LIST
68541: PUSH
68542: LD_INT 30
68544: PUSH
68545: LD_INT 5
68547: PUSH
68548: EMPTY
68549: LIST
68550: LIST
68551: PUSH
68552: EMPTY
68553: LIST
68554: LIST
68555: LIST
68556: PPUSH
68557: CALL_OW 72
68561: ST_TO_ADDR
// if barracks then
68562: LD_VAR 0 8
68566: IFFALSE 68714
// begin selected := 0 ;
68568: LD_ADDR_VAR 0 7
68572: PUSH
68573: LD_INT 0
68575: ST_TO_ADDR
// for j in barracks do
68576: LD_ADDR_VAR 0 3
68580: PUSH
68581: LD_VAR 0 8
68585: PUSH
68586: FOR_IN
68587: IFFALSE 68618
// begin if UnitsInside ( j ) < 6 then
68589: LD_VAR 0 3
68593: PPUSH
68594: CALL_OW 313
68598: PUSH
68599: LD_INT 6
68601: LESS
68602: IFFALSE 68616
// begin selected := j ;
68604: LD_ADDR_VAR 0 7
68608: PUSH
68609: LD_VAR 0 3
68613: ST_TO_ADDR
// break ;
68614: GO 68618
// end ; end ;
68616: GO 68586
68618: POP
68619: POP
// if selected then
68620: LD_VAR 0 7
68624: IFFALSE 68714
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
68626: LD_ADDR_VAR 0 3
68630: PUSH
68631: LD_EXP 52
68635: PUSH
68636: LD_VAR 0 2
68640: ARRAY
68641: PPUSH
68642: LD_INT 25
68644: PUSH
68645: LD_INT 12
68647: PUSH
68648: EMPTY
68649: LIST
68650: LIST
68651: PPUSH
68652: CALL_OW 72
68656: PUSH
68657: FOR_IN
68658: IFFALSE 68712
// if not IsInUnit ( j ) and not HasTask ( j ) then
68660: LD_VAR 0 3
68664: PPUSH
68665: CALL_OW 310
68669: NOT
68670: PUSH
68671: LD_VAR 0 3
68675: PPUSH
68676: CALL_OW 314
68680: NOT
68681: AND
68682: IFFALSE 68710
// begin ComEnterUnit ( j , selected ) ;
68684: LD_VAR 0 3
68688: PPUSH
68689: LD_VAR 0 7
68693: PPUSH
68694: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
68698: LD_VAR 0 3
68702: PPUSH
68703: LD_INT 15
68705: PPUSH
68706: CALL_OW 183
// end ;
68710: GO 68657
68712: POP
68713: POP
// end ; end ; end ; end ; end ;
68714: GO 68107
68716: POP
68717: POP
// end ;
68718: LD_VAR 0 1
68722: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
68723: LD_INT 0
68725: PPUSH
68726: PPUSH
68727: PPUSH
68728: PPUSH
// if not mc_bases then
68729: LD_EXP 23
68733: NOT
68734: IFFALSE 68738
// exit ;
68736: GO 68916
// for i = 1 to mc_bases do
68738: LD_ADDR_VAR 0 2
68742: PUSH
68743: DOUBLE
68744: LD_INT 1
68746: DEC
68747: ST_TO_ADDR
68748: LD_EXP 23
68752: PUSH
68753: FOR_TO
68754: IFFALSE 68914
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
68756: LD_ADDR_VAR 0 4
68760: PUSH
68761: LD_EXP 23
68765: PUSH
68766: LD_VAR 0 2
68770: ARRAY
68771: PPUSH
68772: LD_INT 25
68774: PUSH
68775: LD_INT 9
68777: PUSH
68778: EMPTY
68779: LIST
68780: LIST
68781: PPUSH
68782: CALL_OW 72
68786: ST_TO_ADDR
// if not tmp then
68787: LD_VAR 0 4
68791: NOT
68792: IFFALSE 68796
// continue ;
68794: GO 68753
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
68796: LD_EXP 49
68800: PUSH
68801: LD_VAR 0 2
68805: ARRAY
68806: PPUSH
68807: LD_INT 29
68809: PPUSH
68810: CALL_OW 325
68814: NOT
68815: PUSH
68816: LD_EXP 49
68820: PUSH
68821: LD_VAR 0 2
68825: ARRAY
68826: PPUSH
68827: LD_INT 28
68829: PPUSH
68830: CALL_OW 325
68834: NOT
68835: AND
68836: IFFALSE 68840
// continue ;
68838: GO 68753
// for j in tmp do
68840: LD_ADDR_VAR 0 3
68844: PUSH
68845: LD_VAR 0 4
68849: PUSH
68850: FOR_IN
68851: IFFALSE 68910
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
68853: LD_VAR 0 3
68857: PUSH
68858: LD_EXP 26
68862: PUSH
68863: LD_VAR 0 2
68867: ARRAY
68868: PUSH
68869: LD_INT 1
68871: ARRAY
68872: IN
68873: NOT
68874: PUSH
68875: LD_VAR 0 3
68879: PUSH
68880: LD_EXP 26
68884: PUSH
68885: LD_VAR 0 2
68889: ARRAY
68890: PUSH
68891: LD_INT 2
68893: ARRAY
68894: IN
68895: NOT
68896: AND
68897: IFFALSE 68908
// ComSpaceTimeShoot ( j ) ;
68899: LD_VAR 0 3
68903: PPUSH
68904: CALL 10944 0 1
68908: GO 68850
68910: POP
68911: POP
// end ;
68912: GO 68753
68914: POP
68915: POP
// end ;
68916: LD_VAR 0 1
68920: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
68921: LD_INT 0
68923: PPUSH
68924: PPUSH
68925: PPUSH
68926: PPUSH
68927: PPUSH
68928: PPUSH
68929: PPUSH
68930: PPUSH
68931: PPUSH
// if not mc_bases then
68932: LD_EXP 23
68936: NOT
68937: IFFALSE 68941
// exit ;
68939: GO 69563
// for i = 1 to mc_bases do
68941: LD_ADDR_VAR 0 2
68945: PUSH
68946: DOUBLE
68947: LD_INT 1
68949: DEC
68950: ST_TO_ADDR
68951: LD_EXP 23
68955: PUSH
68956: FOR_TO
68957: IFFALSE 69561
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
68959: LD_EXP 58
68963: PUSH
68964: LD_VAR 0 2
68968: ARRAY
68969: NOT
68970: PUSH
68971: LD_INT 38
68973: PPUSH
68974: LD_EXP 49
68978: PUSH
68979: LD_VAR 0 2
68983: ARRAY
68984: PPUSH
68985: CALL_OW 321
68989: PUSH
68990: LD_INT 2
68992: NONEQUAL
68993: OR
68994: IFFALSE 68998
// continue ;
68996: GO 68956
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
68998: LD_ADDR_VAR 0 8
69002: PUSH
69003: LD_EXP 23
69007: PUSH
69008: LD_VAR 0 2
69012: ARRAY
69013: PPUSH
69014: LD_INT 30
69016: PUSH
69017: LD_INT 34
69019: PUSH
69020: EMPTY
69021: LIST
69022: LIST
69023: PPUSH
69024: CALL_OW 72
69028: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
69029: LD_ADDR_VAR 0 9
69033: PUSH
69034: LD_EXP 23
69038: PUSH
69039: LD_VAR 0 2
69043: ARRAY
69044: PPUSH
69045: LD_INT 25
69047: PUSH
69048: LD_INT 4
69050: PUSH
69051: EMPTY
69052: LIST
69053: LIST
69054: PPUSH
69055: CALL_OW 72
69059: PPUSH
69060: LD_INT 0
69062: PPUSH
69063: CALL 44253 0 2
69067: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
69068: LD_VAR 0 9
69072: NOT
69073: PUSH
69074: LD_VAR 0 8
69078: NOT
69079: OR
69080: PUSH
69081: LD_EXP 23
69085: PUSH
69086: LD_VAR 0 2
69090: ARRAY
69091: PPUSH
69092: LD_INT 124
69094: PPUSH
69095: CALL 44253 0 2
69099: OR
69100: IFFALSE 69104
// continue ;
69102: GO 68956
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
69104: LD_EXP 59
69108: PUSH
69109: LD_VAR 0 2
69113: ARRAY
69114: PUSH
69115: LD_EXP 58
69119: PUSH
69120: LD_VAR 0 2
69124: ARRAY
69125: LESS
69126: PUSH
69127: LD_EXP 59
69131: PUSH
69132: LD_VAR 0 2
69136: ARRAY
69137: PUSH
69138: LD_VAR 0 8
69142: LESS
69143: AND
69144: IFFALSE 69559
// begin tmp := sci [ 1 ] ;
69146: LD_ADDR_VAR 0 7
69150: PUSH
69151: LD_VAR 0 9
69155: PUSH
69156: LD_INT 1
69158: ARRAY
69159: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
69160: LD_VAR 0 7
69164: PPUSH
69165: LD_INT 124
69167: PPUSH
69168: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
69172: LD_ADDR_VAR 0 3
69176: PUSH
69177: DOUBLE
69178: LD_EXP 58
69182: PUSH
69183: LD_VAR 0 2
69187: ARRAY
69188: INC
69189: ST_TO_ADDR
69190: LD_EXP 58
69194: PUSH
69195: LD_VAR 0 2
69199: ARRAY
69200: PUSH
69201: FOR_DOWNTO
69202: IFFALSE 69545
// begin if IsInUnit ( tmp ) then
69204: LD_VAR 0 7
69208: PPUSH
69209: CALL_OW 310
69213: IFFALSE 69224
// ComExitBuilding ( tmp ) ;
69215: LD_VAR 0 7
69219: PPUSH
69220: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
69224: LD_INT 35
69226: PPUSH
69227: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
69231: LD_VAR 0 7
69235: PPUSH
69236: CALL_OW 310
69240: NOT
69241: PUSH
69242: LD_VAR 0 7
69246: PPUSH
69247: CALL_OW 314
69251: NOT
69252: AND
69253: IFFALSE 69224
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
69255: LD_ADDR_VAR 0 6
69259: PUSH
69260: LD_VAR 0 7
69264: PPUSH
69265: CALL_OW 250
69269: PUSH
69270: LD_VAR 0 7
69274: PPUSH
69275: CALL_OW 251
69279: PUSH
69280: EMPTY
69281: LIST
69282: LIST
69283: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
69284: LD_INT 35
69286: PPUSH
69287: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
69291: LD_ADDR_VAR 0 4
69295: PUSH
69296: LD_EXP 58
69300: PUSH
69301: LD_VAR 0 2
69305: ARRAY
69306: PUSH
69307: LD_VAR 0 3
69311: ARRAY
69312: PUSH
69313: LD_INT 1
69315: ARRAY
69316: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
69317: LD_ADDR_VAR 0 5
69321: PUSH
69322: LD_EXP 58
69326: PUSH
69327: LD_VAR 0 2
69331: ARRAY
69332: PUSH
69333: LD_VAR 0 3
69337: ARRAY
69338: PUSH
69339: LD_INT 2
69341: ARRAY
69342: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
69343: LD_VAR 0 7
69347: PPUSH
69348: LD_INT 10
69350: PPUSH
69351: CALL 17582 0 2
69355: PUSH
69356: LD_INT 4
69358: ARRAY
69359: IFFALSE 69397
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
69361: LD_VAR 0 7
69365: PPUSH
69366: LD_VAR 0 6
69370: PUSH
69371: LD_INT 1
69373: ARRAY
69374: PPUSH
69375: LD_VAR 0 6
69379: PUSH
69380: LD_INT 2
69382: ARRAY
69383: PPUSH
69384: CALL_OW 111
// wait ( 0 0$10 ) ;
69388: LD_INT 350
69390: PPUSH
69391: CALL_OW 67
// end else
69395: GO 69423
// begin ComMoveXY ( tmp , x , y ) ;
69397: LD_VAR 0 7
69401: PPUSH
69402: LD_VAR 0 4
69406: PPUSH
69407: LD_VAR 0 5
69411: PPUSH
69412: CALL_OW 111
// wait ( 0 0$3 ) ;
69416: LD_INT 105
69418: PPUSH
69419: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
69423: LD_VAR 0 7
69427: PPUSH
69428: LD_VAR 0 4
69432: PPUSH
69433: LD_VAR 0 5
69437: PPUSH
69438: CALL_OW 307
69442: IFFALSE 69284
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
69444: LD_VAR 0 7
69448: PPUSH
69449: LD_VAR 0 4
69453: PPUSH
69454: LD_VAR 0 5
69458: PPUSH
69459: LD_VAR 0 8
69463: PUSH
69464: LD_VAR 0 3
69468: ARRAY
69469: PPUSH
69470: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
69474: LD_INT 35
69476: PPUSH
69477: CALL_OW 67
// until not HasTask ( tmp ) ;
69481: LD_VAR 0 7
69485: PPUSH
69486: CALL_OW 314
69490: NOT
69491: IFFALSE 69474
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
69493: LD_ADDR_EXP 59
69497: PUSH
69498: LD_EXP 59
69502: PPUSH
69503: LD_VAR 0 2
69507: PUSH
69508: LD_EXP 59
69512: PUSH
69513: LD_VAR 0 2
69517: ARRAY
69518: PUSH
69519: LD_INT 1
69521: PLUS
69522: PUSH
69523: EMPTY
69524: LIST
69525: LIST
69526: PPUSH
69527: LD_VAR 0 8
69531: PUSH
69532: LD_VAR 0 3
69536: ARRAY
69537: PPUSH
69538: CALL 14983 0 3
69542: ST_TO_ADDR
// end ;
69543: GO 69201
69545: POP
69546: POP
// MC_Reset ( i , 124 ) ;
69547: LD_VAR 0 2
69551: PPUSH
69552: LD_INT 124
69554: PPUSH
69555: CALL 52906 0 2
// end ; end ;
69559: GO 68956
69561: POP
69562: POP
// end ;
69563: LD_VAR 0 1
69567: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
69568: LD_INT 0
69570: PPUSH
69571: PPUSH
69572: PPUSH
// if not mc_bases then
69573: LD_EXP 23
69577: NOT
69578: IFFALSE 69582
// exit ;
69580: GO 70188
// for i = 1 to mc_bases do
69582: LD_ADDR_VAR 0 2
69586: PUSH
69587: DOUBLE
69588: LD_INT 1
69590: DEC
69591: ST_TO_ADDR
69592: LD_EXP 23
69596: PUSH
69597: FOR_TO
69598: IFFALSE 70186
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
69600: LD_ADDR_VAR 0 3
69604: PUSH
69605: LD_EXP 23
69609: PUSH
69610: LD_VAR 0 2
69614: ARRAY
69615: PPUSH
69616: LD_INT 25
69618: PUSH
69619: LD_INT 4
69621: PUSH
69622: EMPTY
69623: LIST
69624: LIST
69625: PPUSH
69626: CALL_OW 72
69630: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
69631: LD_VAR 0 3
69635: NOT
69636: PUSH
69637: LD_EXP 60
69641: PUSH
69642: LD_VAR 0 2
69646: ARRAY
69647: NOT
69648: OR
69649: PUSH
69650: LD_EXP 23
69654: PUSH
69655: LD_VAR 0 2
69659: ARRAY
69660: PPUSH
69661: LD_INT 2
69663: PUSH
69664: LD_INT 30
69666: PUSH
69667: LD_INT 0
69669: PUSH
69670: EMPTY
69671: LIST
69672: LIST
69673: PUSH
69674: LD_INT 30
69676: PUSH
69677: LD_INT 1
69679: PUSH
69680: EMPTY
69681: LIST
69682: LIST
69683: PUSH
69684: EMPTY
69685: LIST
69686: LIST
69687: LIST
69688: PPUSH
69689: CALL_OW 72
69693: NOT
69694: OR
69695: IFFALSE 69745
// begin if mc_deposits_finder [ i ] then
69697: LD_EXP 61
69701: PUSH
69702: LD_VAR 0 2
69706: ARRAY
69707: IFFALSE 69743
// begin MC_Reset ( i , 125 ) ;
69709: LD_VAR 0 2
69713: PPUSH
69714: LD_INT 125
69716: PPUSH
69717: CALL 52906 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
69721: LD_ADDR_EXP 61
69725: PUSH
69726: LD_EXP 61
69730: PPUSH
69731: LD_VAR 0 2
69735: PPUSH
69736: EMPTY
69737: PPUSH
69738: CALL_OW 1
69742: ST_TO_ADDR
// end ; continue ;
69743: GO 69597
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
69745: LD_EXP 60
69749: PUSH
69750: LD_VAR 0 2
69754: ARRAY
69755: PUSH
69756: LD_INT 1
69758: ARRAY
69759: PUSH
69760: LD_INT 3
69762: ARRAY
69763: PUSH
69764: LD_INT 1
69766: EQUAL
69767: PUSH
69768: LD_INT 20
69770: PPUSH
69771: LD_EXP 49
69775: PUSH
69776: LD_VAR 0 2
69780: ARRAY
69781: PPUSH
69782: CALL_OW 321
69786: PUSH
69787: LD_INT 2
69789: NONEQUAL
69790: AND
69791: IFFALSE 69841
// begin if mc_deposits_finder [ i ] then
69793: LD_EXP 61
69797: PUSH
69798: LD_VAR 0 2
69802: ARRAY
69803: IFFALSE 69839
// begin MC_Reset ( i , 125 ) ;
69805: LD_VAR 0 2
69809: PPUSH
69810: LD_INT 125
69812: PPUSH
69813: CALL 52906 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
69817: LD_ADDR_EXP 61
69821: PUSH
69822: LD_EXP 61
69826: PPUSH
69827: LD_VAR 0 2
69831: PPUSH
69832: EMPTY
69833: PPUSH
69834: CALL_OW 1
69838: ST_TO_ADDR
// end ; continue ;
69839: GO 69597
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
69841: LD_EXP 60
69845: PUSH
69846: LD_VAR 0 2
69850: ARRAY
69851: PUSH
69852: LD_INT 1
69854: ARRAY
69855: PUSH
69856: LD_INT 1
69858: ARRAY
69859: PPUSH
69860: LD_EXP 60
69864: PUSH
69865: LD_VAR 0 2
69869: ARRAY
69870: PUSH
69871: LD_INT 1
69873: ARRAY
69874: PUSH
69875: LD_INT 2
69877: ARRAY
69878: PPUSH
69879: LD_EXP 49
69883: PUSH
69884: LD_VAR 0 2
69888: ARRAY
69889: PPUSH
69890: CALL_OW 440
69894: IFFALSE 69937
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
69896: LD_ADDR_EXP 60
69900: PUSH
69901: LD_EXP 60
69905: PPUSH
69906: LD_VAR 0 2
69910: PPUSH
69911: LD_EXP 60
69915: PUSH
69916: LD_VAR 0 2
69920: ARRAY
69921: PPUSH
69922: LD_INT 1
69924: PPUSH
69925: CALL_OW 3
69929: PPUSH
69930: CALL_OW 1
69934: ST_TO_ADDR
69935: GO 70184
// begin if not mc_deposits_finder [ i ] then
69937: LD_EXP 61
69941: PUSH
69942: LD_VAR 0 2
69946: ARRAY
69947: NOT
69948: IFFALSE 70000
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
69950: LD_ADDR_EXP 61
69954: PUSH
69955: LD_EXP 61
69959: PPUSH
69960: LD_VAR 0 2
69964: PPUSH
69965: LD_VAR 0 3
69969: PUSH
69970: LD_INT 1
69972: ARRAY
69973: PUSH
69974: EMPTY
69975: LIST
69976: PPUSH
69977: CALL_OW 1
69981: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
69982: LD_VAR 0 3
69986: PUSH
69987: LD_INT 1
69989: ARRAY
69990: PPUSH
69991: LD_INT 125
69993: PPUSH
69994: CALL_OW 109
// end else
69998: GO 70184
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
70000: LD_EXP 61
70004: PUSH
70005: LD_VAR 0 2
70009: ARRAY
70010: PUSH
70011: LD_INT 1
70013: ARRAY
70014: PPUSH
70015: CALL_OW 310
70019: IFFALSE 70042
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
70021: LD_EXP 61
70025: PUSH
70026: LD_VAR 0 2
70030: ARRAY
70031: PUSH
70032: LD_INT 1
70034: ARRAY
70035: PPUSH
70036: CALL_OW 122
70040: GO 70184
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
70042: LD_EXP 61
70046: PUSH
70047: LD_VAR 0 2
70051: ARRAY
70052: PUSH
70053: LD_INT 1
70055: ARRAY
70056: PPUSH
70057: CALL_OW 314
70061: NOT
70062: PUSH
70063: LD_EXP 61
70067: PUSH
70068: LD_VAR 0 2
70072: ARRAY
70073: PUSH
70074: LD_INT 1
70076: ARRAY
70077: PPUSH
70078: LD_EXP 60
70082: PUSH
70083: LD_VAR 0 2
70087: ARRAY
70088: PUSH
70089: LD_INT 1
70091: ARRAY
70092: PUSH
70093: LD_INT 1
70095: ARRAY
70096: PPUSH
70097: LD_EXP 60
70101: PUSH
70102: LD_VAR 0 2
70106: ARRAY
70107: PUSH
70108: LD_INT 1
70110: ARRAY
70111: PUSH
70112: LD_INT 2
70114: ARRAY
70115: PPUSH
70116: CALL_OW 297
70120: PUSH
70121: LD_INT 6
70123: GREATER
70124: AND
70125: IFFALSE 70184
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
70127: LD_EXP 61
70131: PUSH
70132: LD_VAR 0 2
70136: ARRAY
70137: PUSH
70138: LD_INT 1
70140: ARRAY
70141: PPUSH
70142: LD_EXP 60
70146: PUSH
70147: LD_VAR 0 2
70151: ARRAY
70152: PUSH
70153: LD_INT 1
70155: ARRAY
70156: PUSH
70157: LD_INT 1
70159: ARRAY
70160: PPUSH
70161: LD_EXP 60
70165: PUSH
70166: LD_VAR 0 2
70170: ARRAY
70171: PUSH
70172: LD_INT 1
70174: ARRAY
70175: PUSH
70176: LD_INT 2
70178: ARRAY
70179: PPUSH
70180: CALL_OW 111
// end ; end ; end ;
70184: GO 69597
70186: POP
70187: POP
// end ;
70188: LD_VAR 0 1
70192: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
70193: LD_INT 0
70195: PPUSH
70196: PPUSH
70197: PPUSH
70198: PPUSH
70199: PPUSH
70200: PPUSH
70201: PPUSH
70202: PPUSH
70203: PPUSH
70204: PPUSH
70205: PPUSH
// if not mc_bases then
70206: LD_EXP 23
70210: NOT
70211: IFFALSE 70215
// exit ;
70213: GO 71155
// for i = 1 to mc_bases do
70215: LD_ADDR_VAR 0 2
70219: PUSH
70220: DOUBLE
70221: LD_INT 1
70223: DEC
70224: ST_TO_ADDR
70225: LD_EXP 23
70229: PUSH
70230: FOR_TO
70231: IFFALSE 71153
// begin if not mc_bases [ i ] or mc_scan [ i ] then
70233: LD_EXP 23
70237: PUSH
70238: LD_VAR 0 2
70242: ARRAY
70243: NOT
70244: PUSH
70245: LD_EXP 46
70249: PUSH
70250: LD_VAR 0 2
70254: ARRAY
70255: OR
70256: IFFALSE 70260
// continue ;
70258: GO 70230
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
70260: LD_ADDR_VAR 0 7
70264: PUSH
70265: LD_EXP 23
70269: PUSH
70270: LD_VAR 0 2
70274: ARRAY
70275: PUSH
70276: LD_INT 1
70278: ARRAY
70279: PPUSH
70280: CALL_OW 248
70284: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
70285: LD_VAR 0 7
70289: PUSH
70290: LD_INT 3
70292: EQUAL
70293: PUSH
70294: LD_EXP 42
70298: PUSH
70299: LD_VAR 0 2
70303: ARRAY
70304: PUSH
70305: LD_EXP 45
70309: PUSH
70310: LD_VAR 0 2
70314: ARRAY
70315: UNION
70316: PPUSH
70317: LD_INT 33
70319: PUSH
70320: LD_INT 2
70322: PUSH
70323: EMPTY
70324: LIST
70325: LIST
70326: PPUSH
70327: CALL_OW 72
70331: NOT
70332: OR
70333: IFFALSE 70337
// continue ;
70335: GO 70230
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
70337: LD_ADDR_VAR 0 9
70341: PUSH
70342: LD_EXP 23
70346: PUSH
70347: LD_VAR 0 2
70351: ARRAY
70352: PPUSH
70353: LD_INT 30
70355: PUSH
70356: LD_INT 36
70358: PUSH
70359: EMPTY
70360: LIST
70361: LIST
70362: PPUSH
70363: CALL_OW 72
70367: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
70368: LD_ADDR_VAR 0 10
70372: PUSH
70373: LD_EXP 42
70377: PUSH
70378: LD_VAR 0 2
70382: ARRAY
70383: PPUSH
70384: LD_INT 34
70386: PUSH
70387: LD_INT 31
70389: PUSH
70390: EMPTY
70391: LIST
70392: LIST
70393: PPUSH
70394: CALL_OW 72
70398: ST_TO_ADDR
// if not cts and not mcts then
70399: LD_VAR 0 9
70403: NOT
70404: PUSH
70405: LD_VAR 0 10
70409: NOT
70410: AND
70411: IFFALSE 70415
// continue ;
70413: GO 70230
// x := cts ;
70415: LD_ADDR_VAR 0 11
70419: PUSH
70420: LD_VAR 0 9
70424: ST_TO_ADDR
// if not x then
70425: LD_VAR 0 11
70429: NOT
70430: IFFALSE 70442
// x := mcts ;
70432: LD_ADDR_VAR 0 11
70436: PUSH
70437: LD_VAR 0 10
70441: ST_TO_ADDR
// if not x then
70442: LD_VAR 0 11
70446: NOT
70447: IFFALSE 70451
// continue ;
70449: GO 70230
// if mc_remote_driver [ i ] then
70451: LD_EXP 63
70455: PUSH
70456: LD_VAR 0 2
70460: ARRAY
70461: IFFALSE 70848
// for j in mc_remote_driver [ i ] do
70463: LD_ADDR_VAR 0 3
70467: PUSH
70468: LD_EXP 63
70472: PUSH
70473: LD_VAR 0 2
70477: ARRAY
70478: PUSH
70479: FOR_IN
70480: IFFALSE 70846
// begin if GetClass ( j ) <> 3 then
70482: LD_VAR 0 3
70486: PPUSH
70487: CALL_OW 257
70491: PUSH
70492: LD_INT 3
70494: NONEQUAL
70495: IFFALSE 70548
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
70497: LD_ADDR_EXP 63
70501: PUSH
70502: LD_EXP 63
70506: PPUSH
70507: LD_VAR 0 2
70511: PPUSH
70512: LD_EXP 63
70516: PUSH
70517: LD_VAR 0 2
70521: ARRAY
70522: PUSH
70523: LD_VAR 0 3
70527: DIFF
70528: PPUSH
70529: CALL_OW 1
70533: ST_TO_ADDR
// SetTag ( j , 0 ) ;
70534: LD_VAR 0 3
70538: PPUSH
70539: LD_INT 0
70541: PPUSH
70542: CALL_OW 109
// continue ;
70546: GO 70479
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
70548: LD_EXP 42
70552: PUSH
70553: LD_VAR 0 2
70557: ARRAY
70558: PPUSH
70559: LD_INT 34
70561: PUSH
70562: LD_INT 31
70564: PUSH
70565: EMPTY
70566: LIST
70567: LIST
70568: PUSH
70569: LD_INT 58
70571: PUSH
70572: EMPTY
70573: LIST
70574: PUSH
70575: EMPTY
70576: LIST
70577: LIST
70578: PPUSH
70579: CALL_OW 72
70583: PUSH
70584: LD_VAR 0 3
70588: PPUSH
70589: CALL 44341 0 1
70593: NOT
70594: AND
70595: IFFALSE 70666
// begin if IsInUnit ( j ) then
70597: LD_VAR 0 3
70601: PPUSH
70602: CALL_OW 310
70606: IFFALSE 70617
// ComExitBuilding ( j ) ;
70608: LD_VAR 0 3
70612: PPUSH
70613: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
70617: LD_VAR 0 3
70621: PPUSH
70622: LD_EXP 42
70626: PUSH
70627: LD_VAR 0 2
70631: ARRAY
70632: PPUSH
70633: LD_INT 34
70635: PUSH
70636: LD_INT 31
70638: PUSH
70639: EMPTY
70640: LIST
70641: LIST
70642: PUSH
70643: LD_INT 58
70645: PUSH
70646: EMPTY
70647: LIST
70648: PUSH
70649: EMPTY
70650: LIST
70651: LIST
70652: PPUSH
70653: CALL_OW 72
70657: PUSH
70658: LD_INT 1
70660: ARRAY
70661: PPUSH
70662: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
70666: LD_VAR 0 3
70670: PPUSH
70671: CALL_OW 310
70675: NOT
70676: PUSH
70677: LD_VAR 0 3
70681: PPUSH
70682: CALL_OW 310
70686: PPUSH
70687: CALL_OW 266
70691: PUSH
70692: LD_INT 36
70694: NONEQUAL
70695: PUSH
70696: LD_VAR 0 3
70700: PPUSH
70701: CALL 44341 0 1
70705: NOT
70706: AND
70707: OR
70708: IFFALSE 70844
// begin if IsInUnit ( j ) then
70710: LD_VAR 0 3
70714: PPUSH
70715: CALL_OW 310
70719: IFFALSE 70730
// ComExitBuilding ( j ) ;
70721: LD_VAR 0 3
70725: PPUSH
70726: CALL_OW 122
// ct := 0 ;
70730: LD_ADDR_VAR 0 8
70734: PUSH
70735: LD_INT 0
70737: ST_TO_ADDR
// for k in x do
70738: LD_ADDR_VAR 0 4
70742: PUSH
70743: LD_VAR 0 11
70747: PUSH
70748: FOR_IN
70749: IFFALSE 70822
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
70751: LD_VAR 0 4
70755: PPUSH
70756: CALL_OW 264
70760: PUSH
70761: LD_INT 31
70763: EQUAL
70764: PUSH
70765: LD_VAR 0 4
70769: PPUSH
70770: CALL_OW 311
70774: NOT
70775: AND
70776: PUSH
70777: LD_VAR 0 4
70781: PPUSH
70782: CALL_OW 266
70786: PUSH
70787: LD_INT 36
70789: EQUAL
70790: PUSH
70791: LD_VAR 0 4
70795: PPUSH
70796: CALL_OW 313
70800: PUSH
70801: LD_INT 3
70803: LESS
70804: AND
70805: OR
70806: IFFALSE 70820
// begin ct := k ;
70808: LD_ADDR_VAR 0 8
70812: PUSH
70813: LD_VAR 0 4
70817: ST_TO_ADDR
// break ;
70818: GO 70822
// end ;
70820: GO 70748
70822: POP
70823: POP
// if ct then
70824: LD_VAR 0 8
70828: IFFALSE 70844
// ComEnterUnit ( j , ct ) ;
70830: LD_VAR 0 3
70834: PPUSH
70835: LD_VAR 0 8
70839: PPUSH
70840: CALL_OW 120
// end ; end ;
70844: GO 70479
70846: POP
70847: POP
// places := 0 ;
70848: LD_ADDR_VAR 0 5
70852: PUSH
70853: LD_INT 0
70855: ST_TO_ADDR
// for j = 1 to x do
70856: LD_ADDR_VAR 0 3
70860: PUSH
70861: DOUBLE
70862: LD_INT 1
70864: DEC
70865: ST_TO_ADDR
70866: LD_VAR 0 11
70870: PUSH
70871: FOR_TO
70872: IFFALSE 70948
// if GetWeapon ( x [ j ] ) = ar_control_tower then
70874: LD_VAR 0 11
70878: PUSH
70879: LD_VAR 0 3
70883: ARRAY
70884: PPUSH
70885: CALL_OW 264
70889: PUSH
70890: LD_INT 31
70892: EQUAL
70893: IFFALSE 70911
// places := places + 1 else
70895: LD_ADDR_VAR 0 5
70899: PUSH
70900: LD_VAR 0 5
70904: PUSH
70905: LD_INT 1
70907: PLUS
70908: ST_TO_ADDR
70909: GO 70946
// if GetBType ( x [ j ] ) = b_control_tower then
70911: LD_VAR 0 11
70915: PUSH
70916: LD_VAR 0 3
70920: ARRAY
70921: PPUSH
70922: CALL_OW 266
70926: PUSH
70927: LD_INT 36
70929: EQUAL
70930: IFFALSE 70946
// places := places + 3 ;
70932: LD_ADDR_VAR 0 5
70936: PUSH
70937: LD_VAR 0 5
70941: PUSH
70942: LD_INT 3
70944: PLUS
70945: ST_TO_ADDR
70946: GO 70871
70948: POP
70949: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
70950: LD_VAR 0 5
70954: PUSH
70955: LD_INT 0
70957: EQUAL
70958: PUSH
70959: LD_VAR 0 5
70963: PUSH
70964: LD_EXP 63
70968: PUSH
70969: LD_VAR 0 2
70973: ARRAY
70974: LESSEQUAL
70975: OR
70976: IFFALSE 70980
// continue ;
70978: GO 70230
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
70980: LD_ADDR_VAR 0 6
70984: PUSH
70985: LD_EXP 23
70989: PUSH
70990: LD_VAR 0 2
70994: ARRAY
70995: PPUSH
70996: LD_INT 25
70998: PUSH
70999: LD_INT 3
71001: PUSH
71002: EMPTY
71003: LIST
71004: LIST
71005: PPUSH
71006: CALL_OW 72
71010: PUSH
71011: LD_EXP 63
71015: PUSH
71016: LD_VAR 0 2
71020: ARRAY
71021: DIFF
71022: PPUSH
71023: LD_INT 3
71025: PPUSH
71026: CALL 45241 0 2
71030: ST_TO_ADDR
// for j in tmp do
71031: LD_ADDR_VAR 0 3
71035: PUSH
71036: LD_VAR 0 6
71040: PUSH
71041: FOR_IN
71042: IFFALSE 71077
// if GetTag ( j ) > 0 then
71044: LD_VAR 0 3
71048: PPUSH
71049: CALL_OW 110
71053: PUSH
71054: LD_INT 0
71056: GREATER
71057: IFFALSE 71075
// tmp := tmp diff j ;
71059: LD_ADDR_VAR 0 6
71063: PUSH
71064: LD_VAR 0 6
71068: PUSH
71069: LD_VAR 0 3
71073: DIFF
71074: ST_TO_ADDR
71075: GO 71041
71077: POP
71078: POP
// if not tmp then
71079: LD_VAR 0 6
71083: NOT
71084: IFFALSE 71088
// continue ;
71086: GO 70230
// if places then
71088: LD_VAR 0 5
71092: IFFALSE 71151
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
71094: LD_ADDR_EXP 63
71098: PUSH
71099: LD_EXP 63
71103: PPUSH
71104: LD_VAR 0 2
71108: PPUSH
71109: LD_EXP 63
71113: PUSH
71114: LD_VAR 0 2
71118: ARRAY
71119: PUSH
71120: LD_VAR 0 6
71124: PUSH
71125: LD_INT 1
71127: ARRAY
71128: UNION
71129: PPUSH
71130: CALL_OW 1
71134: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
71135: LD_VAR 0 6
71139: PUSH
71140: LD_INT 1
71142: ARRAY
71143: PPUSH
71144: LD_INT 126
71146: PPUSH
71147: CALL_OW 109
// end ; end ;
71151: GO 70230
71153: POP
71154: POP
// end ;
71155: LD_VAR 0 1
71159: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
71160: LD_INT 0
71162: PPUSH
71163: PPUSH
71164: PPUSH
71165: PPUSH
71166: PPUSH
71167: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
71168: LD_VAR 0 1
71172: NOT
71173: PUSH
71174: LD_VAR 0 2
71178: NOT
71179: OR
71180: PUSH
71181: LD_VAR 0 3
71185: NOT
71186: OR
71187: PUSH
71188: LD_VAR 0 4
71192: PUSH
71193: LD_INT 1
71195: PUSH
71196: LD_INT 2
71198: PUSH
71199: LD_INT 3
71201: PUSH
71202: LD_INT 4
71204: PUSH
71205: LD_INT 5
71207: PUSH
71208: LD_INT 8
71210: PUSH
71211: LD_INT 9
71213: PUSH
71214: LD_INT 15
71216: PUSH
71217: LD_INT 16
71219: PUSH
71220: EMPTY
71221: LIST
71222: LIST
71223: LIST
71224: LIST
71225: LIST
71226: LIST
71227: LIST
71228: LIST
71229: LIST
71230: IN
71231: NOT
71232: OR
71233: IFFALSE 71237
// exit ;
71235: GO 72137
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
71237: LD_ADDR_VAR 0 2
71241: PUSH
71242: LD_VAR 0 2
71246: PPUSH
71247: LD_INT 21
71249: PUSH
71250: LD_INT 3
71252: PUSH
71253: EMPTY
71254: LIST
71255: LIST
71256: PUSH
71257: LD_INT 24
71259: PUSH
71260: LD_INT 250
71262: PUSH
71263: EMPTY
71264: LIST
71265: LIST
71266: PUSH
71267: EMPTY
71268: LIST
71269: LIST
71270: PPUSH
71271: CALL_OW 72
71275: ST_TO_ADDR
// case class of 1 , 15 :
71276: LD_VAR 0 4
71280: PUSH
71281: LD_INT 1
71283: DOUBLE
71284: EQUAL
71285: IFTRUE 71295
71287: LD_INT 15
71289: DOUBLE
71290: EQUAL
71291: IFTRUE 71295
71293: GO 71380
71295: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
71296: LD_ADDR_VAR 0 8
71300: PUSH
71301: LD_VAR 0 2
71305: PPUSH
71306: LD_INT 2
71308: PUSH
71309: LD_INT 30
71311: PUSH
71312: LD_INT 32
71314: PUSH
71315: EMPTY
71316: LIST
71317: LIST
71318: PUSH
71319: LD_INT 30
71321: PUSH
71322: LD_INT 31
71324: PUSH
71325: EMPTY
71326: LIST
71327: LIST
71328: PUSH
71329: EMPTY
71330: LIST
71331: LIST
71332: LIST
71333: PPUSH
71334: CALL_OW 72
71338: PUSH
71339: LD_VAR 0 2
71343: PPUSH
71344: LD_INT 2
71346: PUSH
71347: LD_INT 30
71349: PUSH
71350: LD_INT 4
71352: PUSH
71353: EMPTY
71354: LIST
71355: LIST
71356: PUSH
71357: LD_INT 30
71359: PUSH
71360: LD_INT 5
71362: PUSH
71363: EMPTY
71364: LIST
71365: LIST
71366: PUSH
71367: EMPTY
71368: LIST
71369: LIST
71370: LIST
71371: PPUSH
71372: CALL_OW 72
71376: ADD
71377: ST_TO_ADDR
71378: GO 71626
71380: LD_INT 2
71382: DOUBLE
71383: EQUAL
71384: IFTRUE 71394
71386: LD_INT 16
71388: DOUBLE
71389: EQUAL
71390: IFTRUE 71394
71392: GO 71440
71394: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
71395: LD_ADDR_VAR 0 8
71399: PUSH
71400: LD_VAR 0 2
71404: PPUSH
71405: LD_INT 2
71407: PUSH
71408: LD_INT 30
71410: PUSH
71411: LD_INT 0
71413: PUSH
71414: EMPTY
71415: LIST
71416: LIST
71417: PUSH
71418: LD_INT 30
71420: PUSH
71421: LD_INT 1
71423: PUSH
71424: EMPTY
71425: LIST
71426: LIST
71427: PUSH
71428: EMPTY
71429: LIST
71430: LIST
71431: LIST
71432: PPUSH
71433: CALL_OW 72
71437: ST_TO_ADDR
71438: GO 71626
71440: LD_INT 3
71442: DOUBLE
71443: EQUAL
71444: IFTRUE 71448
71446: GO 71494
71448: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
71449: LD_ADDR_VAR 0 8
71453: PUSH
71454: LD_VAR 0 2
71458: PPUSH
71459: LD_INT 2
71461: PUSH
71462: LD_INT 30
71464: PUSH
71465: LD_INT 2
71467: PUSH
71468: EMPTY
71469: LIST
71470: LIST
71471: PUSH
71472: LD_INT 30
71474: PUSH
71475: LD_INT 3
71477: PUSH
71478: EMPTY
71479: LIST
71480: LIST
71481: PUSH
71482: EMPTY
71483: LIST
71484: LIST
71485: LIST
71486: PPUSH
71487: CALL_OW 72
71491: ST_TO_ADDR
71492: GO 71626
71494: LD_INT 4
71496: DOUBLE
71497: EQUAL
71498: IFTRUE 71502
71500: GO 71559
71502: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
71503: LD_ADDR_VAR 0 8
71507: PUSH
71508: LD_VAR 0 2
71512: PPUSH
71513: LD_INT 2
71515: PUSH
71516: LD_INT 30
71518: PUSH
71519: LD_INT 6
71521: PUSH
71522: EMPTY
71523: LIST
71524: LIST
71525: PUSH
71526: LD_INT 30
71528: PUSH
71529: LD_INT 7
71531: PUSH
71532: EMPTY
71533: LIST
71534: LIST
71535: PUSH
71536: LD_INT 30
71538: PUSH
71539: LD_INT 8
71541: PUSH
71542: EMPTY
71543: LIST
71544: LIST
71545: PUSH
71546: EMPTY
71547: LIST
71548: LIST
71549: LIST
71550: LIST
71551: PPUSH
71552: CALL_OW 72
71556: ST_TO_ADDR
71557: GO 71626
71559: LD_INT 5
71561: DOUBLE
71562: EQUAL
71563: IFTRUE 71579
71565: LD_INT 8
71567: DOUBLE
71568: EQUAL
71569: IFTRUE 71579
71571: LD_INT 9
71573: DOUBLE
71574: EQUAL
71575: IFTRUE 71579
71577: GO 71625
71579: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
71580: LD_ADDR_VAR 0 8
71584: PUSH
71585: LD_VAR 0 2
71589: PPUSH
71590: LD_INT 2
71592: PUSH
71593: LD_INT 30
71595: PUSH
71596: LD_INT 4
71598: PUSH
71599: EMPTY
71600: LIST
71601: LIST
71602: PUSH
71603: LD_INT 30
71605: PUSH
71606: LD_INT 5
71608: PUSH
71609: EMPTY
71610: LIST
71611: LIST
71612: PUSH
71613: EMPTY
71614: LIST
71615: LIST
71616: LIST
71617: PPUSH
71618: CALL_OW 72
71622: ST_TO_ADDR
71623: GO 71626
71625: POP
// if not tmp then
71626: LD_VAR 0 8
71630: NOT
71631: IFFALSE 71635
// exit ;
71633: GO 72137
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
71635: LD_VAR 0 4
71639: PUSH
71640: LD_INT 1
71642: PUSH
71643: LD_INT 15
71645: PUSH
71646: EMPTY
71647: LIST
71648: LIST
71649: IN
71650: PUSH
71651: LD_EXP 32
71655: PUSH
71656: LD_VAR 0 1
71660: ARRAY
71661: AND
71662: IFFALSE 71818
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
71664: LD_ADDR_VAR 0 9
71668: PUSH
71669: LD_EXP 32
71673: PUSH
71674: LD_VAR 0 1
71678: ARRAY
71679: PUSH
71680: LD_INT 1
71682: ARRAY
71683: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
71684: LD_VAR 0 9
71688: PUSH
71689: LD_EXP 33
71693: PUSH
71694: LD_VAR 0 1
71698: ARRAY
71699: IN
71700: NOT
71701: IFFALSE 71816
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
71703: LD_ADDR_EXP 33
71707: PUSH
71708: LD_EXP 33
71712: PPUSH
71713: LD_VAR 0 1
71717: PUSH
71718: LD_EXP 33
71722: PUSH
71723: LD_VAR 0 1
71727: ARRAY
71728: PUSH
71729: LD_INT 1
71731: PLUS
71732: PUSH
71733: EMPTY
71734: LIST
71735: LIST
71736: PPUSH
71737: LD_VAR 0 9
71741: PPUSH
71742: CALL 14983 0 3
71746: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
71747: LD_ADDR_EXP 32
71751: PUSH
71752: LD_EXP 32
71756: PPUSH
71757: LD_VAR 0 1
71761: PPUSH
71762: LD_EXP 32
71766: PUSH
71767: LD_VAR 0 1
71771: ARRAY
71772: PUSH
71773: LD_VAR 0 9
71777: DIFF
71778: PPUSH
71779: CALL_OW 1
71783: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
71784: LD_VAR 0 3
71788: PPUSH
71789: LD_EXP 33
71793: PUSH
71794: LD_VAR 0 1
71798: ARRAY
71799: PUSH
71800: LD_EXP 33
71804: PUSH
71805: LD_VAR 0 1
71809: ARRAY
71810: ARRAY
71811: PPUSH
71812: CALL_OW 120
// end ; exit ;
71816: GO 72137
// end ; if tmp > 1 then
71818: LD_VAR 0 8
71822: PUSH
71823: LD_INT 1
71825: GREATER
71826: IFFALSE 71930
// for i = 2 to tmp do
71828: LD_ADDR_VAR 0 6
71832: PUSH
71833: DOUBLE
71834: LD_INT 2
71836: DEC
71837: ST_TO_ADDR
71838: LD_VAR 0 8
71842: PUSH
71843: FOR_TO
71844: IFFALSE 71928
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
71846: LD_VAR 0 8
71850: PUSH
71851: LD_VAR 0 6
71855: ARRAY
71856: PPUSH
71857: CALL_OW 461
71861: PUSH
71862: LD_INT 6
71864: EQUAL
71865: IFFALSE 71926
// begin x := tmp [ i ] ;
71867: LD_ADDR_VAR 0 9
71871: PUSH
71872: LD_VAR 0 8
71876: PUSH
71877: LD_VAR 0 6
71881: ARRAY
71882: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
71883: LD_ADDR_VAR 0 8
71887: PUSH
71888: LD_VAR 0 8
71892: PPUSH
71893: LD_VAR 0 6
71897: PPUSH
71898: CALL_OW 3
71902: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
71903: LD_ADDR_VAR 0 8
71907: PUSH
71908: LD_VAR 0 8
71912: PPUSH
71913: LD_INT 1
71915: PPUSH
71916: LD_VAR 0 9
71920: PPUSH
71921: CALL_OW 2
71925: ST_TO_ADDR
// end ;
71926: GO 71843
71928: POP
71929: POP
// for i in tmp do
71930: LD_ADDR_VAR 0 6
71934: PUSH
71935: LD_VAR 0 8
71939: PUSH
71940: FOR_IN
71941: IFFALSE 72010
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
71943: LD_VAR 0 6
71947: PPUSH
71948: CALL_OW 313
71952: PUSH
71953: LD_INT 6
71955: LESS
71956: PUSH
71957: LD_VAR 0 6
71961: PPUSH
71962: CALL_OW 266
71966: PUSH
71967: LD_INT 31
71969: PUSH
71970: LD_INT 32
71972: PUSH
71973: EMPTY
71974: LIST
71975: LIST
71976: IN
71977: NOT
71978: AND
71979: PUSH
71980: LD_VAR 0 6
71984: PPUSH
71985: CALL_OW 313
71989: PUSH
71990: LD_INT 0
71992: EQUAL
71993: OR
71994: IFFALSE 72008
// begin j := i ;
71996: LD_ADDR_VAR 0 7
72000: PUSH
72001: LD_VAR 0 6
72005: ST_TO_ADDR
// break ;
72006: GO 72010
// end ; end ;
72008: GO 71940
72010: POP
72011: POP
// if j then
72012: LD_VAR 0 7
72016: IFFALSE 72034
// ComEnterUnit ( unit , j ) else
72018: LD_VAR 0 3
72022: PPUSH
72023: LD_VAR 0 7
72027: PPUSH
72028: CALL_OW 120
72032: GO 72137
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72034: LD_ADDR_VAR 0 10
72038: PUSH
72039: LD_VAR 0 2
72043: PPUSH
72044: LD_INT 2
72046: PUSH
72047: LD_INT 30
72049: PUSH
72050: LD_INT 0
72052: PUSH
72053: EMPTY
72054: LIST
72055: LIST
72056: PUSH
72057: LD_INT 30
72059: PUSH
72060: LD_INT 1
72062: PUSH
72063: EMPTY
72064: LIST
72065: LIST
72066: PUSH
72067: EMPTY
72068: LIST
72069: LIST
72070: LIST
72071: PPUSH
72072: CALL_OW 72
72076: ST_TO_ADDR
// if depot then
72077: LD_VAR 0 10
72081: IFFALSE 72137
// begin depot := NearestUnitToUnit ( depot , unit ) ;
72083: LD_ADDR_VAR 0 10
72087: PUSH
72088: LD_VAR 0 10
72092: PPUSH
72093: LD_VAR 0 3
72097: PPUSH
72098: CALL_OW 74
72102: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
72103: LD_VAR 0 3
72107: PPUSH
72108: LD_VAR 0 10
72112: PPUSH
72113: CALL_OW 296
72117: PUSH
72118: LD_INT 10
72120: GREATER
72121: IFFALSE 72137
// ComStandNearbyBuilding ( unit , depot ) ;
72123: LD_VAR 0 3
72127: PPUSH
72128: LD_VAR 0 10
72132: PPUSH
72133: CALL 11561 0 2
// end ; end ; end ;
72137: LD_VAR 0 5
72141: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
72142: LD_INT 0
72144: PPUSH
72145: PPUSH
72146: PPUSH
72147: PPUSH
// if not mc_bases then
72148: LD_EXP 23
72152: NOT
72153: IFFALSE 72157
// exit ;
72155: GO 72396
// for i = 1 to mc_bases do
72157: LD_ADDR_VAR 0 2
72161: PUSH
72162: DOUBLE
72163: LD_INT 1
72165: DEC
72166: ST_TO_ADDR
72167: LD_EXP 23
72171: PUSH
72172: FOR_TO
72173: IFFALSE 72394
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
72175: LD_ADDR_VAR 0 4
72179: PUSH
72180: LD_EXP 23
72184: PUSH
72185: LD_VAR 0 2
72189: ARRAY
72190: PPUSH
72191: LD_INT 21
72193: PUSH
72194: LD_INT 1
72196: PUSH
72197: EMPTY
72198: LIST
72199: LIST
72200: PPUSH
72201: CALL_OW 72
72205: PUSH
72206: LD_EXP 52
72210: PUSH
72211: LD_VAR 0 2
72215: ARRAY
72216: UNION
72217: ST_TO_ADDR
// if not tmp then
72218: LD_VAR 0 4
72222: NOT
72223: IFFALSE 72227
// continue ;
72225: GO 72172
// for j in tmp do
72227: LD_ADDR_VAR 0 3
72231: PUSH
72232: LD_VAR 0 4
72236: PUSH
72237: FOR_IN
72238: IFFALSE 72390
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
72240: LD_VAR 0 3
72244: PPUSH
72245: CALL_OW 110
72249: NOT
72250: PUSH
72251: LD_VAR 0 3
72255: PPUSH
72256: CALL_OW 314
72260: NOT
72261: AND
72262: PUSH
72263: LD_VAR 0 3
72267: PPUSH
72268: CALL_OW 311
72272: NOT
72273: AND
72274: PUSH
72275: LD_VAR 0 3
72279: PPUSH
72280: CALL_OW 310
72284: NOT
72285: AND
72286: PUSH
72287: LD_VAR 0 3
72291: PUSH
72292: LD_EXP 26
72296: PUSH
72297: LD_VAR 0 2
72301: ARRAY
72302: PUSH
72303: LD_INT 1
72305: ARRAY
72306: IN
72307: NOT
72308: AND
72309: PUSH
72310: LD_VAR 0 3
72314: PUSH
72315: LD_EXP 26
72319: PUSH
72320: LD_VAR 0 2
72324: ARRAY
72325: PUSH
72326: LD_INT 2
72328: ARRAY
72329: IN
72330: NOT
72331: AND
72332: PUSH
72333: LD_VAR 0 3
72337: PUSH
72338: LD_EXP 35
72342: PUSH
72343: LD_VAR 0 2
72347: ARRAY
72348: IN
72349: NOT
72350: AND
72351: IFFALSE 72388
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
72353: LD_VAR 0 2
72357: PPUSH
72358: LD_EXP 23
72362: PUSH
72363: LD_VAR 0 2
72367: ARRAY
72368: PPUSH
72369: LD_VAR 0 3
72373: PPUSH
72374: LD_VAR 0 3
72378: PPUSH
72379: CALL_OW 257
72383: PPUSH
72384: CALL 71160 0 4
// end ;
72388: GO 72237
72390: POP
72391: POP
// end ;
72392: GO 72172
72394: POP
72395: POP
// end ;
72396: LD_VAR 0 1
72400: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
72401: LD_INT 0
72403: PPUSH
72404: PPUSH
72405: PPUSH
72406: PPUSH
72407: PPUSH
72408: PPUSH
// if not mc_bases [ base ] then
72409: LD_EXP 23
72413: PUSH
72414: LD_VAR 0 1
72418: ARRAY
72419: NOT
72420: IFFALSE 72424
// exit ;
72422: GO 72606
// tmp := [ ] ;
72424: LD_ADDR_VAR 0 6
72428: PUSH
72429: EMPTY
72430: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
72431: LD_ADDR_VAR 0 7
72435: PUSH
72436: LD_VAR 0 3
72440: PPUSH
72441: LD_INT 0
72443: PPUSH
72444: CALL_OW 517
72448: ST_TO_ADDR
// if not list then
72449: LD_VAR 0 7
72453: NOT
72454: IFFALSE 72458
// exit ;
72456: GO 72606
// for i = 1 to amount do
72458: LD_ADDR_VAR 0 5
72462: PUSH
72463: DOUBLE
72464: LD_INT 1
72466: DEC
72467: ST_TO_ADDR
72468: LD_VAR 0 2
72472: PUSH
72473: FOR_TO
72474: IFFALSE 72554
// begin x := rand ( 1 , list [ 1 ] ) ;
72476: LD_ADDR_VAR 0 8
72480: PUSH
72481: LD_INT 1
72483: PPUSH
72484: LD_VAR 0 7
72488: PUSH
72489: LD_INT 1
72491: ARRAY
72492: PPUSH
72493: CALL_OW 12
72497: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
72498: LD_ADDR_VAR 0 6
72502: PUSH
72503: LD_VAR 0 6
72507: PPUSH
72508: LD_VAR 0 5
72512: PPUSH
72513: LD_VAR 0 7
72517: PUSH
72518: LD_INT 1
72520: ARRAY
72521: PUSH
72522: LD_VAR 0 8
72526: ARRAY
72527: PUSH
72528: LD_VAR 0 7
72532: PUSH
72533: LD_INT 2
72535: ARRAY
72536: PUSH
72537: LD_VAR 0 8
72541: ARRAY
72542: PUSH
72543: EMPTY
72544: LIST
72545: LIST
72546: PPUSH
72547: CALL_OW 1
72551: ST_TO_ADDR
// end ;
72552: GO 72473
72554: POP
72555: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
72556: LD_ADDR_EXP 36
72560: PUSH
72561: LD_EXP 36
72565: PPUSH
72566: LD_VAR 0 1
72570: PPUSH
72571: LD_VAR 0 6
72575: PPUSH
72576: CALL_OW 1
72580: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
72581: LD_ADDR_EXP 38
72585: PUSH
72586: LD_EXP 38
72590: PPUSH
72591: LD_VAR 0 1
72595: PPUSH
72596: LD_VAR 0 3
72600: PPUSH
72601: CALL_OW 1
72605: ST_TO_ADDR
// end ;
72606: LD_VAR 0 4
72610: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
72611: LD_INT 0
72613: PPUSH
// if not mc_bases [ base ] then
72614: LD_EXP 23
72618: PUSH
72619: LD_VAR 0 1
72623: ARRAY
72624: NOT
72625: IFFALSE 72629
// exit ;
72627: GO 72654
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
72629: LD_ADDR_EXP 28
72633: PUSH
72634: LD_EXP 28
72638: PPUSH
72639: LD_VAR 0 1
72643: PPUSH
72644: LD_VAR 0 2
72648: PPUSH
72649: CALL_OW 1
72653: ST_TO_ADDR
// end ;
72654: LD_VAR 0 3
72658: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
72659: LD_INT 0
72661: PPUSH
// if not mc_bases [ base ] then
72662: LD_EXP 23
72666: PUSH
72667: LD_VAR 0 1
72671: ARRAY
72672: NOT
72673: IFFALSE 72677
// exit ;
72675: GO 72714
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
72677: LD_ADDR_EXP 28
72681: PUSH
72682: LD_EXP 28
72686: PPUSH
72687: LD_VAR 0 1
72691: PPUSH
72692: LD_EXP 28
72696: PUSH
72697: LD_VAR 0 1
72701: ARRAY
72702: PUSH
72703: LD_VAR 0 2
72707: UNION
72708: PPUSH
72709: CALL_OW 1
72713: ST_TO_ADDR
// end ;
72714: LD_VAR 0 3
72718: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
72719: LD_INT 0
72721: PPUSH
// if not mc_bases [ base ] then
72722: LD_EXP 23
72726: PUSH
72727: LD_VAR 0 1
72731: ARRAY
72732: NOT
72733: IFFALSE 72737
// exit ;
72735: GO 72762
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
72737: LD_ADDR_EXP 44
72741: PUSH
72742: LD_EXP 44
72746: PPUSH
72747: LD_VAR 0 1
72751: PPUSH
72752: LD_VAR 0 2
72756: PPUSH
72757: CALL_OW 1
72761: ST_TO_ADDR
// end ;
72762: LD_VAR 0 3
72766: RET
// export function MC_InsertProduceList ( base , components ) ; begin
72767: LD_INT 0
72769: PPUSH
// if not mc_bases [ base ] then
72770: LD_EXP 23
72774: PUSH
72775: LD_VAR 0 1
72779: ARRAY
72780: NOT
72781: IFFALSE 72785
// exit ;
72783: GO 72822
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
72785: LD_ADDR_EXP 44
72789: PUSH
72790: LD_EXP 44
72794: PPUSH
72795: LD_VAR 0 1
72799: PPUSH
72800: LD_EXP 44
72804: PUSH
72805: LD_VAR 0 1
72809: ARRAY
72810: PUSH
72811: LD_VAR 0 2
72815: ADD
72816: PPUSH
72817: CALL_OW 1
72821: ST_TO_ADDR
// end ;
72822: LD_VAR 0 3
72826: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
72827: LD_INT 0
72829: PPUSH
// if not mc_bases [ base ] then
72830: LD_EXP 23
72834: PUSH
72835: LD_VAR 0 1
72839: ARRAY
72840: NOT
72841: IFFALSE 72845
// exit ;
72843: GO 72899
// mc_defender := Replace ( mc_defender , base , deflist ) ;
72845: LD_ADDR_EXP 45
72849: PUSH
72850: LD_EXP 45
72854: PPUSH
72855: LD_VAR 0 1
72859: PPUSH
72860: LD_VAR 0 2
72864: PPUSH
72865: CALL_OW 1
72869: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
72870: LD_ADDR_EXP 34
72874: PUSH
72875: LD_EXP 34
72879: PPUSH
72880: LD_VAR 0 1
72884: PPUSH
72885: LD_VAR 0 2
72889: PUSH
72890: LD_INT 0
72892: PLUS
72893: PPUSH
72894: CALL_OW 1
72898: ST_TO_ADDR
// end ;
72899: LD_VAR 0 3
72903: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
72904: LD_INT 0
72906: PPUSH
// if not mc_bases [ base ] then
72907: LD_EXP 23
72911: PUSH
72912: LD_VAR 0 1
72916: ARRAY
72917: NOT
72918: IFFALSE 72922
// exit ;
72920: GO 72947
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
72922: LD_ADDR_EXP 34
72926: PUSH
72927: LD_EXP 34
72931: PPUSH
72932: LD_VAR 0 1
72936: PPUSH
72937: LD_VAR 0 2
72941: PPUSH
72942: CALL_OW 1
72946: ST_TO_ADDR
// end ;
72947: LD_VAR 0 3
72951: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
72952: LD_INT 0
72954: PPUSH
72955: PPUSH
72956: PPUSH
72957: PPUSH
// if not mc_bases [ base ] then
72958: LD_EXP 23
72962: PUSH
72963: LD_VAR 0 1
72967: ARRAY
72968: NOT
72969: IFFALSE 72973
// exit ;
72971: GO 73038
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
72973: LD_ADDR_EXP 43
72977: PUSH
72978: LD_EXP 43
72982: PPUSH
72983: LD_VAR 0 1
72987: PUSH
72988: LD_EXP 43
72992: PUSH
72993: LD_VAR 0 1
72997: ARRAY
72998: PUSH
72999: LD_INT 1
73001: PLUS
73002: PUSH
73003: EMPTY
73004: LIST
73005: LIST
73006: PPUSH
73007: LD_VAR 0 1
73011: PUSH
73012: LD_VAR 0 2
73016: PUSH
73017: LD_VAR 0 3
73021: PUSH
73022: LD_VAR 0 4
73026: PUSH
73027: EMPTY
73028: LIST
73029: LIST
73030: LIST
73031: LIST
73032: PPUSH
73033: CALL 14983 0 3
73037: ST_TO_ADDR
// end ;
73038: LD_VAR 0 5
73042: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
73043: LD_INT 0
73045: PPUSH
// if not mc_bases [ base ] then
73046: LD_EXP 23
73050: PUSH
73051: LD_VAR 0 1
73055: ARRAY
73056: NOT
73057: IFFALSE 73061
// exit ;
73059: GO 73086
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
73061: LD_ADDR_EXP 60
73065: PUSH
73066: LD_EXP 60
73070: PPUSH
73071: LD_VAR 0 1
73075: PPUSH
73076: LD_VAR 0 2
73080: PPUSH
73081: CALL_OW 1
73085: ST_TO_ADDR
// end ;
73086: LD_VAR 0 3
73090: RET
// export function MC_GetMinesField ( base ) ; begin
73091: LD_INT 0
73093: PPUSH
// result := mc_mines [ base ] ;
73094: LD_ADDR_VAR 0 2
73098: PUSH
73099: LD_EXP 36
73103: PUSH
73104: LD_VAR 0 1
73108: ARRAY
73109: ST_TO_ADDR
// end ;
73110: LD_VAR 0 2
73114: RET
// export function MC_GetProduceList ( base ) ; begin
73115: LD_INT 0
73117: PPUSH
// result := mc_produce [ base ] ;
73118: LD_ADDR_VAR 0 2
73122: PUSH
73123: LD_EXP 44
73127: PUSH
73128: LD_VAR 0 1
73132: ARRAY
73133: ST_TO_ADDR
// end ;
73134: LD_VAR 0 2
73138: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
73139: LD_INT 0
73141: PPUSH
73142: PPUSH
// if not mc_bases then
73143: LD_EXP 23
73147: NOT
73148: IFFALSE 73152
// exit ;
73150: GO 73217
// if mc_bases [ base ] then
73152: LD_EXP 23
73156: PUSH
73157: LD_VAR 0 1
73161: ARRAY
73162: IFFALSE 73217
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
73164: LD_ADDR_VAR 0 3
73168: PUSH
73169: LD_EXP 23
73173: PUSH
73174: LD_VAR 0 1
73178: ARRAY
73179: PPUSH
73180: LD_INT 30
73182: PUSH
73183: LD_VAR 0 2
73187: PUSH
73188: EMPTY
73189: LIST
73190: LIST
73191: PPUSH
73192: CALL_OW 72
73196: ST_TO_ADDR
// if result then
73197: LD_VAR 0 3
73201: IFFALSE 73217
// result := result [ 1 ] ;
73203: LD_ADDR_VAR 0 3
73207: PUSH
73208: LD_VAR 0 3
73212: PUSH
73213: LD_INT 1
73215: ARRAY
73216: ST_TO_ADDR
// end ; end ;
73217: LD_VAR 0 3
73221: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
73222: LD_INT 0
73224: PPUSH
73225: PPUSH
// if not mc_bases then
73226: LD_EXP 23
73230: NOT
73231: IFFALSE 73235
// exit ;
73233: GO 73280
// if mc_bases [ base ] then
73235: LD_EXP 23
73239: PUSH
73240: LD_VAR 0 1
73244: ARRAY
73245: IFFALSE 73280
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
73247: LD_ADDR_VAR 0 3
73251: PUSH
73252: LD_EXP 23
73256: PUSH
73257: LD_VAR 0 1
73261: ARRAY
73262: PPUSH
73263: LD_INT 30
73265: PUSH
73266: LD_VAR 0 2
73270: PUSH
73271: EMPTY
73272: LIST
73273: LIST
73274: PPUSH
73275: CALL_OW 72
73279: ST_TO_ADDR
// end ;
73280: LD_VAR 0 3
73284: RET
// export function MC_SetTame ( base , area ) ; begin
73285: LD_INT 0
73287: PPUSH
// if not mc_bases or not base then
73288: LD_EXP 23
73292: NOT
73293: PUSH
73294: LD_VAR 0 1
73298: NOT
73299: OR
73300: IFFALSE 73304
// exit ;
73302: GO 73329
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
73304: LD_ADDR_EXP 51
73308: PUSH
73309: LD_EXP 51
73313: PPUSH
73314: LD_VAR 0 1
73318: PPUSH
73319: LD_VAR 0 2
73323: PPUSH
73324: CALL_OW 1
73328: ST_TO_ADDR
// end ;
73329: LD_VAR 0 3
73333: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
73334: LD_INT 0
73336: PPUSH
73337: PPUSH
// if not mc_bases or not base then
73338: LD_EXP 23
73342: NOT
73343: PUSH
73344: LD_VAR 0 1
73348: NOT
73349: OR
73350: IFFALSE 73354
// exit ;
73352: GO 73456
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
73354: LD_ADDR_VAR 0 4
73358: PUSH
73359: LD_EXP 23
73363: PUSH
73364: LD_VAR 0 1
73368: ARRAY
73369: PPUSH
73370: LD_INT 30
73372: PUSH
73373: LD_VAR 0 2
73377: PUSH
73378: EMPTY
73379: LIST
73380: LIST
73381: PPUSH
73382: CALL_OW 72
73386: ST_TO_ADDR
// if not tmp then
73387: LD_VAR 0 4
73391: NOT
73392: IFFALSE 73396
// exit ;
73394: GO 73456
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
73396: LD_ADDR_EXP 55
73400: PUSH
73401: LD_EXP 55
73405: PPUSH
73406: LD_VAR 0 1
73410: PPUSH
73411: LD_EXP 55
73415: PUSH
73416: LD_VAR 0 1
73420: ARRAY
73421: PPUSH
73422: LD_EXP 55
73426: PUSH
73427: LD_VAR 0 1
73431: ARRAY
73432: PUSH
73433: LD_INT 1
73435: PLUS
73436: PPUSH
73437: LD_VAR 0 4
73441: PUSH
73442: LD_INT 1
73444: ARRAY
73445: PPUSH
73446: CALL_OW 2
73450: PPUSH
73451: CALL_OW 1
73455: ST_TO_ADDR
// end ;
73456: LD_VAR 0 3
73460: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
73461: LD_INT 0
73463: PPUSH
73464: PPUSH
// if not mc_bases or not base or not kinds then
73465: LD_EXP 23
73469: NOT
73470: PUSH
73471: LD_VAR 0 1
73475: NOT
73476: OR
73477: PUSH
73478: LD_VAR 0 2
73482: NOT
73483: OR
73484: IFFALSE 73488
// exit ;
73486: GO 73549
// for i in kinds do
73488: LD_ADDR_VAR 0 4
73492: PUSH
73493: LD_VAR 0 2
73497: PUSH
73498: FOR_IN
73499: IFFALSE 73547
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
73501: LD_ADDR_EXP 57
73505: PUSH
73506: LD_EXP 57
73510: PPUSH
73511: LD_VAR 0 1
73515: PUSH
73516: LD_EXP 57
73520: PUSH
73521: LD_VAR 0 1
73525: ARRAY
73526: PUSH
73527: LD_INT 1
73529: PLUS
73530: PUSH
73531: EMPTY
73532: LIST
73533: LIST
73534: PPUSH
73535: LD_VAR 0 4
73539: PPUSH
73540: CALL 14983 0 3
73544: ST_TO_ADDR
73545: GO 73498
73547: POP
73548: POP
// end ;
73549: LD_VAR 0 3
73553: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
73554: LD_INT 0
73556: PPUSH
// if not mc_bases or not base or not areas then
73557: LD_EXP 23
73561: NOT
73562: PUSH
73563: LD_VAR 0 1
73567: NOT
73568: OR
73569: PUSH
73570: LD_VAR 0 2
73574: NOT
73575: OR
73576: IFFALSE 73580
// exit ;
73578: GO 73605
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
73580: LD_ADDR_EXP 41
73584: PUSH
73585: LD_EXP 41
73589: PPUSH
73590: LD_VAR 0 1
73594: PPUSH
73595: LD_VAR 0 2
73599: PPUSH
73600: CALL_OW 1
73604: ST_TO_ADDR
// end ;
73605: LD_VAR 0 3
73609: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
73610: LD_INT 0
73612: PPUSH
// if not mc_bases or not base or not teleports_exit then
73613: LD_EXP 23
73617: NOT
73618: PUSH
73619: LD_VAR 0 1
73623: NOT
73624: OR
73625: PUSH
73626: LD_VAR 0 2
73630: NOT
73631: OR
73632: IFFALSE 73636
// exit ;
73634: GO 73661
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
73636: LD_ADDR_EXP 58
73640: PUSH
73641: LD_EXP 58
73645: PPUSH
73646: LD_VAR 0 1
73650: PPUSH
73651: LD_VAR 0 2
73655: PPUSH
73656: CALL_OW 1
73660: ST_TO_ADDR
// end ;
73661: LD_VAR 0 3
73665: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
73666: LD_INT 0
73668: PPUSH
73669: PPUSH
73670: PPUSH
// if not mc_bases or not base or not ext_list then
73671: LD_EXP 23
73675: NOT
73676: PUSH
73677: LD_VAR 0 1
73681: NOT
73682: OR
73683: PUSH
73684: LD_VAR 0 5
73688: NOT
73689: OR
73690: IFFALSE 73694
// exit ;
73692: GO 73867
// tmp := GetFacExtXYD ( x , y , d ) ;
73694: LD_ADDR_VAR 0 8
73698: PUSH
73699: LD_VAR 0 2
73703: PPUSH
73704: LD_VAR 0 3
73708: PPUSH
73709: LD_VAR 0 4
73713: PPUSH
73714: CALL 44371 0 3
73718: ST_TO_ADDR
// if not tmp then
73719: LD_VAR 0 8
73723: NOT
73724: IFFALSE 73728
// exit ;
73726: GO 73867
// for i in tmp do
73728: LD_ADDR_VAR 0 7
73732: PUSH
73733: LD_VAR 0 8
73737: PUSH
73738: FOR_IN
73739: IFFALSE 73865
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
73741: LD_ADDR_EXP 28
73745: PUSH
73746: LD_EXP 28
73750: PPUSH
73751: LD_VAR 0 1
73755: PPUSH
73756: LD_EXP 28
73760: PUSH
73761: LD_VAR 0 1
73765: ARRAY
73766: PPUSH
73767: LD_EXP 28
73771: PUSH
73772: LD_VAR 0 1
73776: ARRAY
73777: PUSH
73778: LD_INT 1
73780: PLUS
73781: PPUSH
73782: LD_VAR 0 5
73786: PUSH
73787: LD_INT 1
73789: ARRAY
73790: PUSH
73791: LD_VAR 0 7
73795: PUSH
73796: LD_INT 1
73798: ARRAY
73799: PUSH
73800: LD_VAR 0 7
73804: PUSH
73805: LD_INT 2
73807: ARRAY
73808: PUSH
73809: LD_VAR 0 7
73813: PUSH
73814: LD_INT 3
73816: ARRAY
73817: PUSH
73818: EMPTY
73819: LIST
73820: LIST
73821: LIST
73822: LIST
73823: PPUSH
73824: CALL_OW 2
73828: PPUSH
73829: CALL_OW 1
73833: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
73834: LD_ADDR_VAR 0 5
73838: PUSH
73839: LD_VAR 0 5
73843: PPUSH
73844: LD_INT 1
73846: PPUSH
73847: CALL_OW 3
73851: ST_TO_ADDR
// if not ext_list then
73852: LD_VAR 0 5
73856: NOT
73857: IFFALSE 73863
// exit ;
73859: POP
73860: POP
73861: GO 73867
// end ;
73863: GO 73738
73865: POP
73866: POP
// end ;
73867: LD_VAR 0 6
73871: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
73872: LD_INT 0
73874: PPUSH
// if not mc_bases or not base or not weapon_list then
73875: LD_EXP 23
73879: NOT
73880: PUSH
73881: LD_VAR 0 1
73885: NOT
73886: OR
73887: PUSH
73888: LD_VAR 0 2
73892: NOT
73893: OR
73894: IFFALSE 73898
// exit ;
73896: GO 73923
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
73898: LD_ADDR_EXP 62
73902: PUSH
73903: LD_EXP 62
73907: PPUSH
73908: LD_VAR 0 1
73912: PPUSH
73913: LD_VAR 0 2
73917: PPUSH
73918: CALL_OW 1
73922: ST_TO_ADDR
// end ;
73923: LD_VAR 0 3
73927: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
73928: LD_INT 0
73930: PPUSH
// if not mc_bases or not base or not tech_list then
73931: LD_EXP 23
73935: NOT
73936: PUSH
73937: LD_VAR 0 1
73941: NOT
73942: OR
73943: PUSH
73944: LD_VAR 0 2
73948: NOT
73949: OR
73950: IFFALSE 73954
// exit ;
73952: GO 73979
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
73954: LD_ADDR_EXP 50
73958: PUSH
73959: LD_EXP 50
73963: PPUSH
73964: LD_VAR 0 1
73968: PPUSH
73969: LD_VAR 0 2
73973: PPUSH
73974: CALL_OW 1
73978: ST_TO_ADDR
// end ;
73979: LD_VAR 0 3
73983: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
73984: LD_INT 0
73986: PPUSH
// if not mc_bases or not parking_area or not base then
73987: LD_EXP 23
73991: NOT
73992: PUSH
73993: LD_VAR 0 2
73997: NOT
73998: OR
73999: PUSH
74000: LD_VAR 0 1
74004: NOT
74005: OR
74006: IFFALSE 74010
// exit ;
74008: GO 74035
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
74010: LD_ADDR_EXP 47
74014: PUSH
74015: LD_EXP 47
74019: PPUSH
74020: LD_VAR 0 1
74024: PPUSH
74025: LD_VAR 0 2
74029: PPUSH
74030: CALL_OW 1
74034: ST_TO_ADDR
// end ;
74035: LD_VAR 0 3
74039: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
74040: LD_INT 0
74042: PPUSH
// if not mc_bases or not base or not scan_area then
74043: LD_EXP 23
74047: NOT
74048: PUSH
74049: LD_VAR 0 1
74053: NOT
74054: OR
74055: PUSH
74056: LD_VAR 0 2
74060: NOT
74061: OR
74062: IFFALSE 74066
// exit ;
74064: GO 74091
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
74066: LD_ADDR_EXP 48
74070: PUSH
74071: LD_EXP 48
74075: PPUSH
74076: LD_VAR 0 1
74080: PPUSH
74081: LD_VAR 0 2
74085: PPUSH
74086: CALL_OW 1
74090: ST_TO_ADDR
// end ;
74091: LD_VAR 0 3
74095: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
74096: LD_INT 0
74098: PPUSH
74099: PPUSH
// if not mc_bases or not base then
74100: LD_EXP 23
74104: NOT
74105: PUSH
74106: LD_VAR 0 1
74110: NOT
74111: OR
74112: IFFALSE 74116
// exit ;
74114: GO 74180
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
74116: LD_ADDR_VAR 0 3
74120: PUSH
74121: LD_INT 1
74123: PUSH
74124: LD_INT 2
74126: PUSH
74127: LD_INT 3
74129: PUSH
74130: LD_INT 4
74132: PUSH
74133: LD_INT 11
74135: PUSH
74136: EMPTY
74137: LIST
74138: LIST
74139: LIST
74140: LIST
74141: LIST
74142: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
74143: LD_ADDR_EXP 50
74147: PUSH
74148: LD_EXP 50
74152: PPUSH
74153: LD_VAR 0 1
74157: PPUSH
74158: LD_EXP 50
74162: PUSH
74163: LD_VAR 0 1
74167: ARRAY
74168: PUSH
74169: LD_VAR 0 3
74173: DIFF
74174: PPUSH
74175: CALL_OW 1
74179: ST_TO_ADDR
// end ;
74180: LD_VAR 0 2
74184: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
74185: LD_INT 0
74187: PPUSH
// result := mc_vehicles [ base ] ;
74188: LD_ADDR_VAR 0 3
74192: PUSH
74193: LD_EXP 42
74197: PUSH
74198: LD_VAR 0 1
74202: ARRAY
74203: ST_TO_ADDR
// if onlyCombat then
74204: LD_VAR 0 2
74208: IFFALSE 74386
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
74210: LD_ADDR_VAR 0 3
74214: PUSH
74215: LD_VAR 0 3
74219: PUSH
74220: LD_VAR 0 3
74224: PPUSH
74225: LD_INT 2
74227: PUSH
74228: LD_INT 34
74230: PUSH
74231: LD_INT 12
74233: PUSH
74234: EMPTY
74235: LIST
74236: LIST
74237: PUSH
74238: LD_INT 34
74240: PUSH
74241: LD_INT 51
74243: PUSH
74244: EMPTY
74245: LIST
74246: LIST
74247: PUSH
74248: LD_INT 34
74250: PUSH
74251: LD_EXP 68
74255: PUSH
74256: EMPTY
74257: LIST
74258: LIST
74259: PUSH
74260: LD_INT 34
74262: PUSH
74263: LD_INT 32
74265: PUSH
74266: EMPTY
74267: LIST
74268: LIST
74269: PUSH
74270: LD_INT 34
74272: PUSH
74273: LD_INT 13
74275: PUSH
74276: EMPTY
74277: LIST
74278: LIST
74279: PUSH
74280: LD_INT 34
74282: PUSH
74283: LD_INT 52
74285: PUSH
74286: EMPTY
74287: LIST
74288: LIST
74289: PUSH
74290: LD_INT 34
74292: PUSH
74293: LD_EXP 73
74297: PUSH
74298: EMPTY
74299: LIST
74300: LIST
74301: PUSH
74302: LD_INT 34
74304: PUSH
74305: LD_INT 14
74307: PUSH
74308: EMPTY
74309: LIST
74310: LIST
74311: PUSH
74312: LD_INT 34
74314: PUSH
74315: LD_INT 53
74317: PUSH
74318: EMPTY
74319: LIST
74320: LIST
74321: PUSH
74322: LD_INT 34
74324: PUSH
74325: LD_EXP 67
74329: PUSH
74330: EMPTY
74331: LIST
74332: LIST
74333: PUSH
74334: LD_INT 34
74336: PUSH
74337: LD_INT 31
74339: PUSH
74340: EMPTY
74341: LIST
74342: LIST
74343: PUSH
74344: LD_INT 34
74346: PUSH
74347: LD_INT 48
74349: PUSH
74350: EMPTY
74351: LIST
74352: LIST
74353: PUSH
74354: LD_INT 34
74356: PUSH
74357: LD_INT 8
74359: PUSH
74360: EMPTY
74361: LIST
74362: LIST
74363: PUSH
74364: EMPTY
74365: LIST
74366: LIST
74367: LIST
74368: LIST
74369: LIST
74370: LIST
74371: LIST
74372: LIST
74373: LIST
74374: LIST
74375: LIST
74376: LIST
74377: LIST
74378: LIST
74379: PPUSH
74380: CALL_OW 72
74384: DIFF
74385: ST_TO_ADDR
// end ; end_of_file
74386: LD_VAR 0 3
74390: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
74391: LD_INT 0
74393: PPUSH
74394: PPUSH
74395: PPUSH
// if not mc_bases or not skirmish then
74396: LD_EXP 23
74400: NOT
74401: PUSH
74402: LD_EXP 21
74406: NOT
74407: OR
74408: IFFALSE 74412
// exit ;
74410: GO 74577
// for i = 1 to mc_bases do
74412: LD_ADDR_VAR 0 4
74416: PUSH
74417: DOUBLE
74418: LD_INT 1
74420: DEC
74421: ST_TO_ADDR
74422: LD_EXP 23
74426: PUSH
74427: FOR_TO
74428: IFFALSE 74575
// begin if sci in mc_bases [ i ] then
74430: LD_VAR 0 2
74434: PUSH
74435: LD_EXP 23
74439: PUSH
74440: LD_VAR 0 4
74444: ARRAY
74445: IN
74446: IFFALSE 74573
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
74448: LD_ADDR_EXP 52
74452: PUSH
74453: LD_EXP 52
74457: PPUSH
74458: LD_VAR 0 4
74462: PUSH
74463: LD_EXP 52
74467: PUSH
74468: LD_VAR 0 4
74472: ARRAY
74473: PUSH
74474: LD_INT 1
74476: PLUS
74477: PUSH
74478: EMPTY
74479: LIST
74480: LIST
74481: PPUSH
74482: LD_VAR 0 1
74486: PPUSH
74487: CALL 14983 0 3
74491: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
74492: LD_ADDR_VAR 0 5
74496: PUSH
74497: LD_EXP 23
74501: PUSH
74502: LD_VAR 0 4
74506: ARRAY
74507: PPUSH
74508: LD_INT 2
74510: PUSH
74511: LD_INT 30
74513: PUSH
74514: LD_INT 0
74516: PUSH
74517: EMPTY
74518: LIST
74519: LIST
74520: PUSH
74521: LD_INT 30
74523: PUSH
74524: LD_INT 1
74526: PUSH
74527: EMPTY
74528: LIST
74529: LIST
74530: PUSH
74531: EMPTY
74532: LIST
74533: LIST
74534: LIST
74535: PPUSH
74536: CALL_OW 72
74540: PPUSH
74541: LD_VAR 0 1
74545: PPUSH
74546: CALL_OW 74
74550: ST_TO_ADDR
// if tmp then
74551: LD_VAR 0 5
74555: IFFALSE 74571
// ComStandNearbyBuilding ( ape , tmp ) ;
74557: LD_VAR 0 1
74561: PPUSH
74562: LD_VAR 0 5
74566: PPUSH
74567: CALL 11561 0 2
// break ;
74571: GO 74575
// end ; end ;
74573: GO 74427
74575: POP
74576: POP
// end ;
74577: LD_VAR 0 3
74581: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
74582: LD_INT 0
74584: PPUSH
74585: PPUSH
74586: PPUSH
// if not mc_bases or not skirmish then
74587: LD_EXP 23
74591: NOT
74592: PUSH
74593: LD_EXP 21
74597: NOT
74598: OR
74599: IFFALSE 74603
// exit ;
74601: GO 74692
// for i = 1 to mc_bases do
74603: LD_ADDR_VAR 0 4
74607: PUSH
74608: DOUBLE
74609: LD_INT 1
74611: DEC
74612: ST_TO_ADDR
74613: LD_EXP 23
74617: PUSH
74618: FOR_TO
74619: IFFALSE 74690
// begin if building in mc_busy_turret_list [ i ] then
74621: LD_VAR 0 1
74625: PUSH
74626: LD_EXP 33
74630: PUSH
74631: LD_VAR 0 4
74635: ARRAY
74636: IN
74637: IFFALSE 74688
// begin tmp := mc_busy_turret_list [ i ] diff building ;
74639: LD_ADDR_VAR 0 5
74643: PUSH
74644: LD_EXP 33
74648: PUSH
74649: LD_VAR 0 4
74653: ARRAY
74654: PUSH
74655: LD_VAR 0 1
74659: DIFF
74660: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
74661: LD_ADDR_EXP 33
74665: PUSH
74666: LD_EXP 33
74670: PPUSH
74671: LD_VAR 0 4
74675: PPUSH
74676: LD_VAR 0 5
74680: PPUSH
74681: CALL_OW 1
74685: ST_TO_ADDR
// break ;
74686: GO 74690
// end ; end ;
74688: GO 74618
74690: POP
74691: POP
// end ;
74692: LD_VAR 0 3
74696: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
74697: LD_INT 0
74699: PPUSH
74700: PPUSH
74701: PPUSH
// if not mc_bases or not skirmish then
74702: LD_EXP 23
74706: NOT
74707: PUSH
74708: LD_EXP 21
74712: NOT
74713: OR
74714: IFFALSE 74718
// exit ;
74716: GO 74917
// for i = 1 to mc_bases do
74718: LD_ADDR_VAR 0 5
74722: PUSH
74723: DOUBLE
74724: LD_INT 1
74726: DEC
74727: ST_TO_ADDR
74728: LD_EXP 23
74732: PUSH
74733: FOR_TO
74734: IFFALSE 74915
// if building in mc_bases [ i ] then
74736: LD_VAR 0 1
74740: PUSH
74741: LD_EXP 23
74745: PUSH
74746: LD_VAR 0 5
74750: ARRAY
74751: IN
74752: IFFALSE 74913
// begin tmp := mc_bases [ i ] diff building ;
74754: LD_ADDR_VAR 0 6
74758: PUSH
74759: LD_EXP 23
74763: PUSH
74764: LD_VAR 0 5
74768: ARRAY
74769: PUSH
74770: LD_VAR 0 1
74774: DIFF
74775: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
74776: LD_ADDR_EXP 23
74780: PUSH
74781: LD_EXP 23
74785: PPUSH
74786: LD_VAR 0 5
74790: PPUSH
74791: LD_VAR 0 6
74795: PPUSH
74796: CALL_OW 1
74800: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
74801: LD_VAR 0 1
74805: PUSH
74806: LD_EXP 31
74810: PUSH
74811: LD_VAR 0 5
74815: ARRAY
74816: IN
74817: IFFALSE 74856
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
74819: LD_ADDR_EXP 31
74823: PUSH
74824: LD_EXP 31
74828: PPUSH
74829: LD_VAR 0 5
74833: PPUSH
74834: LD_EXP 31
74838: PUSH
74839: LD_VAR 0 5
74843: ARRAY
74844: PUSH
74845: LD_VAR 0 1
74849: DIFF
74850: PPUSH
74851: CALL_OW 1
74855: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
74856: LD_VAR 0 1
74860: PUSH
74861: LD_EXP 32
74865: PUSH
74866: LD_VAR 0 5
74870: ARRAY
74871: IN
74872: IFFALSE 74911
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
74874: LD_ADDR_EXP 32
74878: PUSH
74879: LD_EXP 32
74883: PPUSH
74884: LD_VAR 0 5
74888: PPUSH
74889: LD_EXP 32
74893: PUSH
74894: LD_VAR 0 5
74898: ARRAY
74899: PUSH
74900: LD_VAR 0 1
74904: DIFF
74905: PPUSH
74906: CALL_OW 1
74910: ST_TO_ADDR
// break ;
74911: GO 74915
// end ;
74913: GO 74733
74915: POP
74916: POP
// end ;
74917: LD_VAR 0 4
74921: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
74922: LD_INT 0
74924: PPUSH
74925: PPUSH
74926: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
74927: LD_EXP 23
74931: NOT
74932: PUSH
74933: LD_EXP 21
74937: NOT
74938: OR
74939: PUSH
74940: LD_VAR 0 3
74944: PUSH
74945: LD_EXP 49
74949: IN
74950: NOT
74951: OR
74952: IFFALSE 74956
// exit ;
74954: GO 75079
// for i = 1 to mc_vehicles do
74956: LD_ADDR_VAR 0 6
74960: PUSH
74961: DOUBLE
74962: LD_INT 1
74964: DEC
74965: ST_TO_ADDR
74966: LD_EXP 42
74970: PUSH
74971: FOR_TO
74972: IFFALSE 75077
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
74974: LD_VAR 0 2
74978: PUSH
74979: LD_EXP 42
74983: PUSH
74984: LD_VAR 0 6
74988: ARRAY
74989: IN
74990: PUSH
74991: LD_VAR 0 1
74995: PUSH
74996: LD_EXP 42
75000: PUSH
75001: LD_VAR 0 6
75005: ARRAY
75006: IN
75007: OR
75008: IFFALSE 75075
// begin tmp := mc_vehicles [ i ] diff old ;
75010: LD_ADDR_VAR 0 7
75014: PUSH
75015: LD_EXP 42
75019: PUSH
75020: LD_VAR 0 6
75024: ARRAY
75025: PUSH
75026: LD_VAR 0 2
75030: DIFF
75031: ST_TO_ADDR
// tmp := tmp diff new ;
75032: LD_ADDR_VAR 0 7
75036: PUSH
75037: LD_VAR 0 7
75041: PUSH
75042: LD_VAR 0 1
75046: DIFF
75047: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
75048: LD_ADDR_EXP 42
75052: PUSH
75053: LD_EXP 42
75057: PPUSH
75058: LD_VAR 0 6
75062: PPUSH
75063: LD_VAR 0 7
75067: PPUSH
75068: CALL_OW 1
75072: ST_TO_ADDR
// break ;
75073: GO 75077
// end ;
75075: GO 74971
75077: POP
75078: POP
// end ;
75079: LD_VAR 0 5
75083: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
75084: LD_INT 0
75086: PPUSH
75087: PPUSH
75088: PPUSH
75089: PPUSH
// if not mc_bases or not skirmish then
75090: LD_EXP 23
75094: NOT
75095: PUSH
75096: LD_EXP 21
75100: NOT
75101: OR
75102: IFFALSE 75106
// exit ;
75104: GO 75498
// side := GetSide ( vehicle ) ;
75106: LD_ADDR_VAR 0 5
75110: PUSH
75111: LD_VAR 0 1
75115: PPUSH
75116: CALL_OW 255
75120: ST_TO_ADDR
// for i = 1 to mc_bases do
75121: LD_ADDR_VAR 0 4
75125: PUSH
75126: DOUBLE
75127: LD_INT 1
75129: DEC
75130: ST_TO_ADDR
75131: LD_EXP 23
75135: PUSH
75136: FOR_TO
75137: IFFALSE 75496
// begin if factory in mc_bases [ i ] then
75139: LD_VAR 0 2
75143: PUSH
75144: LD_EXP 23
75148: PUSH
75149: LD_VAR 0 4
75153: ARRAY
75154: IN
75155: IFFALSE 75494
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
75157: LD_EXP 45
75161: PUSH
75162: LD_VAR 0 4
75166: ARRAY
75167: PUSH
75168: LD_EXP 34
75172: PUSH
75173: LD_VAR 0 4
75177: ARRAY
75178: LESS
75179: PUSH
75180: LD_VAR 0 1
75184: PPUSH
75185: CALL_OW 264
75189: PUSH
75190: LD_INT 31
75192: PUSH
75193: LD_INT 32
75195: PUSH
75196: LD_INT 51
75198: PUSH
75199: LD_EXP 68
75203: PUSH
75204: LD_INT 12
75206: PUSH
75207: LD_INT 30
75209: PUSH
75210: LD_EXP 67
75214: PUSH
75215: LD_INT 11
75217: PUSH
75218: LD_INT 53
75220: PUSH
75221: LD_INT 14
75223: PUSH
75224: LD_EXP 71
75228: PUSH
75229: LD_INT 29
75231: PUSH
75232: LD_EXP 69
75236: PUSH
75237: LD_INT 13
75239: PUSH
75240: LD_INT 52
75242: PUSH
75243: LD_EXP 73
75247: PUSH
75248: LD_INT 48
75250: PUSH
75251: LD_INT 8
75253: PUSH
75254: EMPTY
75255: LIST
75256: LIST
75257: LIST
75258: LIST
75259: LIST
75260: LIST
75261: LIST
75262: LIST
75263: LIST
75264: LIST
75265: LIST
75266: LIST
75267: LIST
75268: LIST
75269: LIST
75270: LIST
75271: LIST
75272: LIST
75273: IN
75274: NOT
75275: AND
75276: IFFALSE 75324
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
75278: LD_ADDR_EXP 45
75282: PUSH
75283: LD_EXP 45
75287: PPUSH
75288: LD_VAR 0 4
75292: PUSH
75293: LD_EXP 45
75297: PUSH
75298: LD_VAR 0 4
75302: ARRAY
75303: PUSH
75304: LD_INT 1
75306: PLUS
75307: PUSH
75308: EMPTY
75309: LIST
75310: LIST
75311: PPUSH
75312: LD_VAR 0 1
75316: PPUSH
75317: CALL 14983 0 3
75321: ST_TO_ADDR
75322: GO 75368
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
75324: LD_ADDR_EXP 42
75328: PUSH
75329: LD_EXP 42
75333: PPUSH
75334: LD_VAR 0 4
75338: PUSH
75339: LD_EXP 42
75343: PUSH
75344: LD_VAR 0 4
75348: ARRAY
75349: PUSH
75350: LD_INT 1
75352: PLUS
75353: PUSH
75354: EMPTY
75355: LIST
75356: LIST
75357: PPUSH
75358: LD_VAR 0 1
75362: PPUSH
75363: CALL 14983 0 3
75367: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
75368: LD_VAR 0 1
75372: PPUSH
75373: CALL_OW 263
75377: PUSH
75378: LD_INT 2
75380: EQUAL
75381: IFFALSE 75410
// begin repeat Connect ( vehicle ) ;
75383: LD_VAR 0 1
75387: PPUSH
75388: CALL 17954 0 1
// wait ( 0 0$1 ) ;
75392: LD_INT 35
75394: PPUSH
75395: CALL_OW 67
// until IsControledBy ( vehicle ) ;
75399: LD_VAR 0 1
75403: PPUSH
75404: CALL_OW 312
75408: IFFALSE 75383
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
75410: LD_VAR 0 1
75414: PPUSH
75415: LD_EXP 47
75419: PUSH
75420: LD_VAR 0 4
75424: ARRAY
75425: PPUSH
75426: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
75430: LD_VAR 0 1
75434: PPUSH
75435: CALL_OW 263
75439: PUSH
75440: LD_INT 1
75442: NONEQUAL
75443: IFFALSE 75447
// break ;
75445: GO 75496
// repeat wait ( 0 0$1 ) ;
75447: LD_INT 35
75449: PPUSH
75450: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
75454: LD_VAR 0 1
75458: PPUSH
75459: LD_EXP 47
75463: PUSH
75464: LD_VAR 0 4
75468: ARRAY
75469: PPUSH
75470: CALL_OW 308
75474: IFFALSE 75447
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
75476: LD_VAR 0 1
75480: PPUSH
75481: CALL_OW 311
75485: PPUSH
75486: CALL_OW 121
// exit ;
75490: POP
75491: POP
75492: GO 75498
// end ; end ;
75494: GO 75136
75496: POP
75497: POP
// end ;
75498: LD_VAR 0 3
75502: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
75503: LD_INT 0
75505: PPUSH
75506: PPUSH
75507: PPUSH
75508: PPUSH
// if not mc_bases or not skirmish then
75509: LD_EXP 23
75513: NOT
75514: PUSH
75515: LD_EXP 21
75519: NOT
75520: OR
75521: IFFALSE 75525
// exit ;
75523: GO 75878
// repeat wait ( 0 0$1 ) ;
75525: LD_INT 35
75527: PPUSH
75528: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
75532: LD_VAR 0 2
75536: PPUSH
75537: LD_VAR 0 3
75541: PPUSH
75542: CALL_OW 284
75546: IFFALSE 75525
// if GetResourceTypeXY ( x , y ) = mat_artefact then
75548: LD_VAR 0 2
75552: PPUSH
75553: LD_VAR 0 3
75557: PPUSH
75558: CALL_OW 283
75562: PUSH
75563: LD_INT 4
75565: EQUAL
75566: IFFALSE 75570
// exit ;
75568: GO 75878
// for i = 1 to mc_bases do
75570: LD_ADDR_VAR 0 7
75574: PUSH
75575: DOUBLE
75576: LD_INT 1
75578: DEC
75579: ST_TO_ADDR
75580: LD_EXP 23
75584: PUSH
75585: FOR_TO
75586: IFFALSE 75876
// begin if mc_crates_area [ i ] then
75588: LD_EXP 41
75592: PUSH
75593: LD_VAR 0 7
75597: ARRAY
75598: IFFALSE 75709
// for j in mc_crates_area [ i ] do
75600: LD_ADDR_VAR 0 8
75604: PUSH
75605: LD_EXP 41
75609: PUSH
75610: LD_VAR 0 7
75614: ARRAY
75615: PUSH
75616: FOR_IN
75617: IFFALSE 75707
// if InArea ( x , y , j ) then
75619: LD_VAR 0 2
75623: PPUSH
75624: LD_VAR 0 3
75628: PPUSH
75629: LD_VAR 0 8
75633: PPUSH
75634: CALL_OW 309
75638: IFFALSE 75705
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
75640: LD_ADDR_EXP 39
75644: PUSH
75645: LD_EXP 39
75649: PPUSH
75650: LD_VAR 0 7
75654: PUSH
75655: LD_EXP 39
75659: PUSH
75660: LD_VAR 0 7
75664: ARRAY
75665: PUSH
75666: LD_INT 1
75668: PLUS
75669: PUSH
75670: EMPTY
75671: LIST
75672: LIST
75673: PPUSH
75674: LD_VAR 0 4
75678: PUSH
75679: LD_VAR 0 2
75683: PUSH
75684: LD_VAR 0 3
75688: PUSH
75689: EMPTY
75690: LIST
75691: LIST
75692: LIST
75693: PPUSH
75694: CALL 14983 0 3
75698: ST_TO_ADDR
// exit ;
75699: POP
75700: POP
75701: POP
75702: POP
75703: GO 75878
// end ;
75705: GO 75616
75707: POP
75708: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75709: LD_ADDR_VAR 0 9
75713: PUSH
75714: LD_EXP 23
75718: PUSH
75719: LD_VAR 0 7
75723: ARRAY
75724: PPUSH
75725: LD_INT 2
75727: PUSH
75728: LD_INT 30
75730: PUSH
75731: LD_INT 0
75733: PUSH
75734: EMPTY
75735: LIST
75736: LIST
75737: PUSH
75738: LD_INT 30
75740: PUSH
75741: LD_INT 1
75743: PUSH
75744: EMPTY
75745: LIST
75746: LIST
75747: PUSH
75748: EMPTY
75749: LIST
75750: LIST
75751: LIST
75752: PPUSH
75753: CALL_OW 72
75757: ST_TO_ADDR
// if not depot then
75758: LD_VAR 0 9
75762: NOT
75763: IFFALSE 75767
// continue ;
75765: GO 75585
// for j in depot do
75767: LD_ADDR_VAR 0 8
75771: PUSH
75772: LD_VAR 0 9
75776: PUSH
75777: FOR_IN
75778: IFFALSE 75872
// if GetDistUnitXY ( j , x , y ) < 30 then
75780: LD_VAR 0 8
75784: PPUSH
75785: LD_VAR 0 2
75789: PPUSH
75790: LD_VAR 0 3
75794: PPUSH
75795: CALL_OW 297
75799: PUSH
75800: LD_INT 30
75802: LESS
75803: IFFALSE 75870
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
75805: LD_ADDR_EXP 39
75809: PUSH
75810: LD_EXP 39
75814: PPUSH
75815: LD_VAR 0 7
75819: PUSH
75820: LD_EXP 39
75824: PUSH
75825: LD_VAR 0 7
75829: ARRAY
75830: PUSH
75831: LD_INT 1
75833: PLUS
75834: PUSH
75835: EMPTY
75836: LIST
75837: LIST
75838: PPUSH
75839: LD_VAR 0 4
75843: PUSH
75844: LD_VAR 0 2
75848: PUSH
75849: LD_VAR 0 3
75853: PUSH
75854: EMPTY
75855: LIST
75856: LIST
75857: LIST
75858: PPUSH
75859: CALL 14983 0 3
75863: ST_TO_ADDR
// exit ;
75864: POP
75865: POP
75866: POP
75867: POP
75868: GO 75878
// end ;
75870: GO 75777
75872: POP
75873: POP
// end ;
75874: GO 75585
75876: POP
75877: POP
// end ;
75878: LD_VAR 0 6
75882: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
75883: LD_INT 0
75885: PPUSH
75886: PPUSH
75887: PPUSH
75888: PPUSH
// if not mc_bases or not skirmish then
75889: LD_EXP 23
75893: NOT
75894: PUSH
75895: LD_EXP 21
75899: NOT
75900: OR
75901: IFFALSE 75905
// exit ;
75903: GO 76182
// side := GetSide ( lab ) ;
75905: LD_ADDR_VAR 0 4
75909: PUSH
75910: LD_VAR 0 2
75914: PPUSH
75915: CALL_OW 255
75919: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
75920: LD_VAR 0 4
75924: PUSH
75925: LD_EXP 49
75929: IN
75930: NOT
75931: PUSH
75932: LD_EXP 50
75936: NOT
75937: OR
75938: PUSH
75939: LD_EXP 23
75943: NOT
75944: OR
75945: IFFALSE 75949
// exit ;
75947: GO 76182
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
75949: LD_ADDR_EXP 50
75953: PUSH
75954: LD_EXP 50
75958: PPUSH
75959: LD_VAR 0 4
75963: PPUSH
75964: LD_EXP 50
75968: PUSH
75969: LD_VAR 0 4
75973: ARRAY
75974: PUSH
75975: LD_VAR 0 1
75979: DIFF
75980: PPUSH
75981: CALL_OW 1
75985: ST_TO_ADDR
// for i = 1 to mc_bases do
75986: LD_ADDR_VAR 0 5
75990: PUSH
75991: DOUBLE
75992: LD_INT 1
75994: DEC
75995: ST_TO_ADDR
75996: LD_EXP 23
76000: PUSH
76001: FOR_TO
76002: IFFALSE 76180
// begin if lab in mc_bases [ i ] then
76004: LD_VAR 0 2
76008: PUSH
76009: LD_EXP 23
76013: PUSH
76014: LD_VAR 0 5
76018: ARRAY
76019: IN
76020: IFFALSE 76178
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
76022: LD_VAR 0 1
76026: PUSH
76027: LD_INT 11
76029: PUSH
76030: LD_INT 4
76032: PUSH
76033: LD_INT 3
76035: PUSH
76036: LD_INT 2
76038: PUSH
76039: EMPTY
76040: LIST
76041: LIST
76042: LIST
76043: LIST
76044: IN
76045: PUSH
76046: LD_EXP 53
76050: PUSH
76051: LD_VAR 0 5
76055: ARRAY
76056: AND
76057: IFFALSE 76178
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
76059: LD_ADDR_VAR 0 6
76063: PUSH
76064: LD_EXP 53
76068: PUSH
76069: LD_VAR 0 5
76073: ARRAY
76074: PUSH
76075: LD_INT 1
76077: ARRAY
76078: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
76079: LD_ADDR_EXP 53
76083: PUSH
76084: LD_EXP 53
76088: PPUSH
76089: LD_VAR 0 5
76093: PPUSH
76094: EMPTY
76095: PPUSH
76096: CALL_OW 1
76100: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
76101: LD_VAR 0 6
76105: PPUSH
76106: LD_INT 0
76108: PPUSH
76109: CALL_OW 109
// ComExitBuilding ( tmp ) ;
76113: LD_VAR 0 6
76117: PPUSH
76118: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
76122: LD_ADDR_EXP 52
76126: PUSH
76127: LD_EXP 52
76131: PPUSH
76132: LD_VAR 0 5
76136: PPUSH
76137: LD_EXP 52
76141: PUSH
76142: LD_VAR 0 5
76146: ARRAY
76147: PPUSH
76148: LD_INT 1
76150: PPUSH
76151: LD_VAR 0 6
76155: PPUSH
76156: CALL_OW 2
76160: PPUSH
76161: CALL_OW 1
76165: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
76166: LD_VAR 0 5
76170: PPUSH
76171: LD_INT 112
76173: PPUSH
76174: CALL 52906 0 2
// end ; end ; end ;
76178: GO 76001
76180: POP
76181: POP
// end ;
76182: LD_VAR 0 3
76186: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
76187: LD_INT 0
76189: PPUSH
76190: PPUSH
76191: PPUSH
76192: PPUSH
76193: PPUSH
76194: PPUSH
76195: PPUSH
76196: PPUSH
// if not mc_bases or not skirmish then
76197: LD_EXP 23
76201: NOT
76202: PUSH
76203: LD_EXP 21
76207: NOT
76208: OR
76209: IFFALSE 76213
// exit ;
76211: GO 77584
// for i = 1 to mc_bases do
76213: LD_ADDR_VAR 0 3
76217: PUSH
76218: DOUBLE
76219: LD_INT 1
76221: DEC
76222: ST_TO_ADDR
76223: LD_EXP 23
76227: PUSH
76228: FOR_TO
76229: IFFALSE 77582
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
76231: LD_VAR 0 1
76235: PUSH
76236: LD_EXP 23
76240: PUSH
76241: LD_VAR 0 3
76245: ARRAY
76246: IN
76247: PUSH
76248: LD_VAR 0 1
76252: PUSH
76253: LD_EXP 30
76257: PUSH
76258: LD_VAR 0 3
76262: ARRAY
76263: IN
76264: OR
76265: PUSH
76266: LD_VAR 0 1
76270: PUSH
76271: LD_EXP 45
76275: PUSH
76276: LD_VAR 0 3
76280: ARRAY
76281: IN
76282: OR
76283: PUSH
76284: LD_VAR 0 1
76288: PUSH
76289: LD_EXP 42
76293: PUSH
76294: LD_VAR 0 3
76298: ARRAY
76299: IN
76300: OR
76301: PUSH
76302: LD_VAR 0 1
76306: PUSH
76307: LD_EXP 52
76311: PUSH
76312: LD_VAR 0 3
76316: ARRAY
76317: IN
76318: OR
76319: PUSH
76320: LD_VAR 0 1
76324: PUSH
76325: LD_EXP 53
76329: PUSH
76330: LD_VAR 0 3
76334: ARRAY
76335: IN
76336: OR
76337: IFFALSE 77580
// begin if un in mc_ape [ i ] then
76339: LD_VAR 0 1
76343: PUSH
76344: LD_EXP 52
76348: PUSH
76349: LD_VAR 0 3
76353: ARRAY
76354: IN
76355: IFFALSE 76394
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
76357: LD_ADDR_EXP 52
76361: PUSH
76362: LD_EXP 52
76366: PPUSH
76367: LD_VAR 0 3
76371: PPUSH
76372: LD_EXP 52
76376: PUSH
76377: LD_VAR 0 3
76381: ARRAY
76382: PUSH
76383: LD_VAR 0 1
76387: DIFF
76388: PPUSH
76389: CALL_OW 1
76393: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
76394: LD_VAR 0 1
76398: PUSH
76399: LD_EXP 53
76403: PUSH
76404: LD_VAR 0 3
76408: ARRAY
76409: IN
76410: IFFALSE 76434
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
76412: LD_ADDR_EXP 53
76416: PUSH
76417: LD_EXP 53
76421: PPUSH
76422: LD_VAR 0 3
76426: PPUSH
76427: EMPTY
76428: PPUSH
76429: CALL_OW 1
76433: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
76434: LD_VAR 0 1
76438: PPUSH
76439: CALL_OW 247
76443: PUSH
76444: LD_INT 2
76446: EQUAL
76447: PUSH
76448: LD_VAR 0 1
76452: PPUSH
76453: CALL_OW 110
76457: PUSH
76458: LD_INT 20
76460: EQUAL
76461: PUSH
76462: LD_VAR 0 1
76466: PUSH
76467: LD_EXP 45
76471: PUSH
76472: LD_VAR 0 3
76476: ARRAY
76477: IN
76478: OR
76479: PUSH
76480: LD_VAR 0 1
76484: PPUSH
76485: CALL_OW 264
76489: PUSH
76490: LD_INT 12
76492: PUSH
76493: LD_INT 51
76495: PUSH
76496: LD_EXP 68
76500: PUSH
76501: LD_INT 32
76503: PUSH
76504: LD_INT 13
76506: PUSH
76507: LD_INT 52
76509: PUSH
76510: LD_INT 31
76512: PUSH
76513: EMPTY
76514: LIST
76515: LIST
76516: LIST
76517: LIST
76518: LIST
76519: LIST
76520: LIST
76521: IN
76522: OR
76523: AND
76524: IFFALSE 76832
// begin if un in mc_defender [ i ] then
76526: LD_VAR 0 1
76530: PUSH
76531: LD_EXP 45
76535: PUSH
76536: LD_VAR 0 3
76540: ARRAY
76541: IN
76542: IFFALSE 76581
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
76544: LD_ADDR_EXP 45
76548: PUSH
76549: LD_EXP 45
76553: PPUSH
76554: LD_VAR 0 3
76558: PPUSH
76559: LD_EXP 45
76563: PUSH
76564: LD_VAR 0 3
76568: ARRAY
76569: PUSH
76570: LD_VAR 0 1
76574: DIFF
76575: PPUSH
76576: CALL_OW 1
76580: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
76581: LD_ADDR_VAR 0 8
76585: PUSH
76586: LD_VAR 0 3
76590: PPUSH
76591: LD_INT 3
76593: PPUSH
76594: CALL 73222 0 2
76598: ST_TO_ADDR
// if fac then
76599: LD_VAR 0 8
76603: IFFALSE 76832
// begin for j in fac do
76605: LD_ADDR_VAR 0 4
76609: PUSH
76610: LD_VAR 0 8
76614: PUSH
76615: FOR_IN
76616: IFFALSE 76830
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
76618: LD_ADDR_VAR 0 9
76622: PUSH
76623: LD_VAR 0 8
76627: PPUSH
76628: LD_VAR 0 1
76632: PPUSH
76633: CALL_OW 265
76637: PPUSH
76638: LD_VAR 0 1
76642: PPUSH
76643: CALL_OW 262
76647: PPUSH
76648: LD_VAR 0 1
76652: PPUSH
76653: CALL_OW 263
76657: PPUSH
76658: LD_VAR 0 1
76662: PPUSH
76663: CALL_OW 264
76667: PPUSH
76668: CALL 12479 0 5
76672: ST_TO_ADDR
// if components then
76673: LD_VAR 0 9
76677: IFFALSE 76828
// begin if GetWeapon ( un ) = ar_control_tower then
76679: LD_VAR 0 1
76683: PPUSH
76684: CALL_OW 264
76688: PUSH
76689: LD_INT 31
76691: EQUAL
76692: IFFALSE 76809
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
76694: LD_VAR 0 1
76698: PPUSH
76699: CALL_OW 311
76703: PPUSH
76704: LD_INT 0
76706: PPUSH
76707: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
76711: LD_ADDR_EXP 63
76715: PUSH
76716: LD_EXP 63
76720: PPUSH
76721: LD_VAR 0 3
76725: PPUSH
76726: LD_EXP 63
76730: PUSH
76731: LD_VAR 0 3
76735: ARRAY
76736: PUSH
76737: LD_VAR 0 1
76741: PPUSH
76742: CALL_OW 311
76746: DIFF
76747: PPUSH
76748: CALL_OW 1
76752: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
76753: LD_ADDR_VAR 0 7
76757: PUSH
76758: LD_EXP 44
76762: PUSH
76763: LD_VAR 0 3
76767: ARRAY
76768: PPUSH
76769: LD_INT 1
76771: PPUSH
76772: LD_VAR 0 9
76776: PPUSH
76777: CALL_OW 2
76781: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
76782: LD_ADDR_EXP 44
76786: PUSH
76787: LD_EXP 44
76791: PPUSH
76792: LD_VAR 0 3
76796: PPUSH
76797: LD_VAR 0 7
76801: PPUSH
76802: CALL_OW 1
76806: ST_TO_ADDR
// end else
76807: GO 76826
// MC_InsertProduceList ( i , [ components ] ) ;
76809: LD_VAR 0 3
76813: PPUSH
76814: LD_VAR 0 9
76818: PUSH
76819: EMPTY
76820: LIST
76821: PPUSH
76822: CALL 72767 0 2
// break ;
76826: GO 76830
// end ; end ;
76828: GO 76615
76830: POP
76831: POP
// end ; end ; if GetType ( un ) = unit_building then
76832: LD_VAR 0 1
76836: PPUSH
76837: CALL_OW 247
76841: PUSH
76842: LD_INT 3
76844: EQUAL
76845: IFFALSE 77248
// begin btype := GetBType ( un ) ;
76847: LD_ADDR_VAR 0 5
76851: PUSH
76852: LD_VAR 0 1
76856: PPUSH
76857: CALL_OW 266
76861: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
76862: LD_VAR 0 5
76866: PUSH
76867: LD_INT 29
76869: PUSH
76870: LD_INT 30
76872: PUSH
76873: EMPTY
76874: LIST
76875: LIST
76876: IN
76877: IFFALSE 76950
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
76879: LD_VAR 0 1
76883: PPUSH
76884: CALL_OW 250
76888: PPUSH
76889: LD_VAR 0 1
76893: PPUSH
76894: CALL_OW 251
76898: PPUSH
76899: LD_VAR 0 1
76903: PPUSH
76904: CALL_OW 255
76908: PPUSH
76909: CALL_OW 440
76913: NOT
76914: IFFALSE 76950
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
76916: LD_VAR 0 1
76920: PPUSH
76921: CALL_OW 250
76925: PPUSH
76926: LD_VAR 0 1
76930: PPUSH
76931: CALL_OW 251
76935: PPUSH
76936: LD_VAR 0 1
76940: PPUSH
76941: CALL_OW 255
76945: PPUSH
76946: CALL_OW 441
// end ; if btype = b_warehouse then
76950: LD_VAR 0 5
76954: PUSH
76955: LD_INT 1
76957: EQUAL
76958: IFFALSE 76976
// begin btype := b_depot ;
76960: LD_ADDR_VAR 0 5
76964: PUSH
76965: LD_INT 0
76967: ST_TO_ADDR
// pos := 1 ;
76968: LD_ADDR_VAR 0 6
76972: PUSH
76973: LD_INT 1
76975: ST_TO_ADDR
// end ; if btype = b_factory then
76976: LD_VAR 0 5
76980: PUSH
76981: LD_INT 3
76983: EQUAL
76984: IFFALSE 77002
// begin btype := b_workshop ;
76986: LD_ADDR_VAR 0 5
76990: PUSH
76991: LD_INT 2
76993: ST_TO_ADDR
// pos := 1 ;
76994: LD_ADDR_VAR 0 6
76998: PUSH
76999: LD_INT 1
77001: ST_TO_ADDR
// end ; if btype = b_barracks then
77002: LD_VAR 0 5
77006: PUSH
77007: LD_INT 5
77009: EQUAL
77010: IFFALSE 77020
// btype := b_armoury ;
77012: LD_ADDR_VAR 0 5
77016: PUSH
77017: LD_INT 4
77019: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
77020: LD_VAR 0 5
77024: PUSH
77025: LD_INT 7
77027: PUSH
77028: LD_INT 8
77030: PUSH
77031: EMPTY
77032: LIST
77033: LIST
77034: IN
77035: IFFALSE 77045
// btype := b_lab ;
77037: LD_ADDR_VAR 0 5
77041: PUSH
77042: LD_INT 6
77044: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
77045: LD_ADDR_EXP 28
77049: PUSH
77050: LD_EXP 28
77054: PPUSH
77055: LD_VAR 0 3
77059: PUSH
77060: LD_EXP 28
77064: PUSH
77065: LD_VAR 0 3
77069: ARRAY
77070: PUSH
77071: LD_INT 1
77073: PLUS
77074: PUSH
77075: EMPTY
77076: LIST
77077: LIST
77078: PPUSH
77079: LD_VAR 0 5
77083: PUSH
77084: LD_VAR 0 1
77088: PPUSH
77089: CALL_OW 250
77093: PUSH
77094: LD_VAR 0 1
77098: PPUSH
77099: CALL_OW 251
77103: PUSH
77104: LD_VAR 0 1
77108: PPUSH
77109: CALL_OW 254
77113: PUSH
77114: EMPTY
77115: LIST
77116: LIST
77117: LIST
77118: LIST
77119: PPUSH
77120: CALL 14983 0 3
77124: ST_TO_ADDR
// if pos = 1 then
77125: LD_VAR 0 6
77129: PUSH
77130: LD_INT 1
77132: EQUAL
77133: IFFALSE 77248
// begin tmp := mc_build_list [ i ] ;
77135: LD_ADDR_VAR 0 7
77139: PUSH
77140: LD_EXP 28
77144: PUSH
77145: LD_VAR 0 3
77149: ARRAY
77150: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
77151: LD_VAR 0 7
77155: PPUSH
77156: LD_INT 2
77158: PUSH
77159: LD_INT 30
77161: PUSH
77162: LD_INT 0
77164: PUSH
77165: EMPTY
77166: LIST
77167: LIST
77168: PUSH
77169: LD_INT 30
77171: PUSH
77172: LD_INT 1
77174: PUSH
77175: EMPTY
77176: LIST
77177: LIST
77178: PUSH
77179: EMPTY
77180: LIST
77181: LIST
77182: LIST
77183: PPUSH
77184: CALL_OW 72
77188: IFFALSE 77198
// pos := 2 ;
77190: LD_ADDR_VAR 0 6
77194: PUSH
77195: LD_INT 2
77197: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
77198: LD_ADDR_VAR 0 7
77202: PUSH
77203: LD_VAR 0 7
77207: PPUSH
77208: LD_VAR 0 6
77212: PPUSH
77213: LD_VAR 0 7
77217: PPUSH
77218: CALL 15309 0 3
77222: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
77223: LD_ADDR_EXP 28
77227: PUSH
77228: LD_EXP 28
77232: PPUSH
77233: LD_VAR 0 3
77237: PPUSH
77238: LD_VAR 0 7
77242: PPUSH
77243: CALL_OW 1
77247: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
77248: LD_VAR 0 1
77252: PUSH
77253: LD_EXP 23
77257: PUSH
77258: LD_VAR 0 3
77262: ARRAY
77263: IN
77264: IFFALSE 77303
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
77266: LD_ADDR_EXP 23
77270: PUSH
77271: LD_EXP 23
77275: PPUSH
77276: LD_VAR 0 3
77280: PPUSH
77281: LD_EXP 23
77285: PUSH
77286: LD_VAR 0 3
77290: ARRAY
77291: PUSH
77292: LD_VAR 0 1
77296: DIFF
77297: PPUSH
77298: CALL_OW 1
77302: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
77303: LD_VAR 0 1
77307: PUSH
77308: LD_EXP 30
77312: PUSH
77313: LD_VAR 0 3
77317: ARRAY
77318: IN
77319: IFFALSE 77358
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
77321: LD_ADDR_EXP 30
77325: PUSH
77326: LD_EXP 30
77330: PPUSH
77331: LD_VAR 0 3
77335: PPUSH
77336: LD_EXP 30
77340: PUSH
77341: LD_VAR 0 3
77345: ARRAY
77346: PUSH
77347: LD_VAR 0 1
77351: DIFF
77352: PPUSH
77353: CALL_OW 1
77357: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
77358: LD_VAR 0 1
77362: PUSH
77363: LD_EXP 42
77367: PUSH
77368: LD_VAR 0 3
77372: ARRAY
77373: IN
77374: IFFALSE 77413
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
77376: LD_ADDR_EXP 42
77380: PUSH
77381: LD_EXP 42
77385: PPUSH
77386: LD_VAR 0 3
77390: PPUSH
77391: LD_EXP 42
77395: PUSH
77396: LD_VAR 0 3
77400: ARRAY
77401: PUSH
77402: LD_VAR 0 1
77406: DIFF
77407: PPUSH
77408: CALL_OW 1
77412: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
77413: LD_VAR 0 1
77417: PUSH
77418: LD_EXP 45
77422: PUSH
77423: LD_VAR 0 3
77427: ARRAY
77428: IN
77429: IFFALSE 77468
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
77431: LD_ADDR_EXP 45
77435: PUSH
77436: LD_EXP 45
77440: PPUSH
77441: LD_VAR 0 3
77445: PPUSH
77446: LD_EXP 45
77450: PUSH
77451: LD_VAR 0 3
77455: ARRAY
77456: PUSH
77457: LD_VAR 0 1
77461: DIFF
77462: PPUSH
77463: CALL_OW 1
77467: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
77468: LD_VAR 0 1
77472: PUSH
77473: LD_EXP 32
77477: PUSH
77478: LD_VAR 0 3
77482: ARRAY
77483: IN
77484: IFFALSE 77523
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
77486: LD_ADDR_EXP 32
77490: PUSH
77491: LD_EXP 32
77495: PPUSH
77496: LD_VAR 0 3
77500: PPUSH
77501: LD_EXP 32
77505: PUSH
77506: LD_VAR 0 3
77510: ARRAY
77511: PUSH
77512: LD_VAR 0 1
77516: DIFF
77517: PPUSH
77518: CALL_OW 1
77522: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
77523: LD_VAR 0 1
77527: PUSH
77528: LD_EXP 31
77532: PUSH
77533: LD_VAR 0 3
77537: ARRAY
77538: IN
77539: IFFALSE 77578
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
77541: LD_ADDR_EXP 31
77545: PUSH
77546: LD_EXP 31
77550: PPUSH
77551: LD_VAR 0 3
77555: PPUSH
77556: LD_EXP 31
77560: PUSH
77561: LD_VAR 0 3
77565: ARRAY
77566: PUSH
77567: LD_VAR 0 1
77571: DIFF
77572: PPUSH
77573: CALL_OW 1
77577: ST_TO_ADDR
// end ; break ;
77578: GO 77582
// end ;
77580: GO 76228
77582: POP
77583: POP
// end ;
77584: LD_VAR 0 2
77588: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
77589: LD_INT 0
77591: PPUSH
77592: PPUSH
77593: PPUSH
// if not mc_bases or not skirmish then
77594: LD_EXP 23
77598: NOT
77599: PUSH
77600: LD_EXP 21
77604: NOT
77605: OR
77606: IFFALSE 77610
// exit ;
77608: GO 77825
// for i = 1 to mc_bases do
77610: LD_ADDR_VAR 0 3
77614: PUSH
77615: DOUBLE
77616: LD_INT 1
77618: DEC
77619: ST_TO_ADDR
77620: LD_EXP 23
77624: PUSH
77625: FOR_TO
77626: IFFALSE 77823
// begin if building in mc_construct_list [ i ] then
77628: LD_VAR 0 1
77632: PUSH
77633: LD_EXP 30
77637: PUSH
77638: LD_VAR 0 3
77642: ARRAY
77643: IN
77644: IFFALSE 77821
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
77646: LD_ADDR_EXP 30
77650: PUSH
77651: LD_EXP 30
77655: PPUSH
77656: LD_VAR 0 3
77660: PPUSH
77661: LD_EXP 30
77665: PUSH
77666: LD_VAR 0 3
77670: ARRAY
77671: PUSH
77672: LD_VAR 0 1
77676: DIFF
77677: PPUSH
77678: CALL_OW 1
77682: ST_TO_ADDR
// if building in mc_lab [ i ] then
77683: LD_VAR 0 1
77687: PUSH
77688: LD_EXP 56
77692: PUSH
77693: LD_VAR 0 3
77697: ARRAY
77698: IN
77699: IFFALSE 77754
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
77701: LD_ADDR_EXP 57
77705: PUSH
77706: LD_EXP 57
77710: PPUSH
77711: LD_VAR 0 3
77715: PPUSH
77716: LD_EXP 57
77720: PUSH
77721: LD_VAR 0 3
77725: ARRAY
77726: PPUSH
77727: LD_INT 1
77729: PPUSH
77730: LD_EXP 57
77734: PUSH
77735: LD_VAR 0 3
77739: ARRAY
77740: PPUSH
77741: LD_INT 0
77743: PPUSH
77744: CALL 14401 0 4
77748: PPUSH
77749: CALL_OW 1
77753: ST_TO_ADDR
// if not building in mc_bases [ i ] then
77754: LD_VAR 0 1
77758: PUSH
77759: LD_EXP 23
77763: PUSH
77764: LD_VAR 0 3
77768: ARRAY
77769: IN
77770: NOT
77771: IFFALSE 77817
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
77773: LD_ADDR_EXP 23
77777: PUSH
77778: LD_EXP 23
77782: PPUSH
77783: LD_VAR 0 3
77787: PUSH
77788: LD_EXP 23
77792: PUSH
77793: LD_VAR 0 3
77797: ARRAY
77798: PUSH
77799: LD_INT 1
77801: PLUS
77802: PUSH
77803: EMPTY
77804: LIST
77805: LIST
77806: PPUSH
77807: LD_VAR 0 1
77811: PPUSH
77812: CALL 14983 0 3
77816: ST_TO_ADDR
// exit ;
77817: POP
77818: POP
77819: GO 77825
// end ; end ;
77821: GO 77625
77823: POP
77824: POP
// end ;
77825: LD_VAR 0 2
77829: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
77830: LD_INT 0
77832: PPUSH
77833: PPUSH
77834: PPUSH
77835: PPUSH
77836: PPUSH
77837: PPUSH
77838: PPUSH
// if not mc_bases or not skirmish then
77839: LD_EXP 23
77843: NOT
77844: PUSH
77845: LD_EXP 21
77849: NOT
77850: OR
77851: IFFALSE 77855
// exit ;
77853: GO 78516
// for i = 1 to mc_bases do
77855: LD_ADDR_VAR 0 3
77859: PUSH
77860: DOUBLE
77861: LD_INT 1
77863: DEC
77864: ST_TO_ADDR
77865: LD_EXP 23
77869: PUSH
77870: FOR_TO
77871: IFFALSE 78514
// begin if building in mc_construct_list [ i ] then
77873: LD_VAR 0 1
77877: PUSH
77878: LD_EXP 30
77882: PUSH
77883: LD_VAR 0 3
77887: ARRAY
77888: IN
77889: IFFALSE 78512
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
77891: LD_ADDR_EXP 30
77895: PUSH
77896: LD_EXP 30
77900: PPUSH
77901: LD_VAR 0 3
77905: PPUSH
77906: LD_EXP 30
77910: PUSH
77911: LD_VAR 0 3
77915: ARRAY
77916: PUSH
77917: LD_VAR 0 1
77921: DIFF
77922: PPUSH
77923: CALL_OW 1
77927: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
77928: LD_ADDR_EXP 23
77932: PUSH
77933: LD_EXP 23
77937: PPUSH
77938: LD_VAR 0 3
77942: PUSH
77943: LD_EXP 23
77947: PUSH
77948: LD_VAR 0 3
77952: ARRAY
77953: PUSH
77954: LD_INT 1
77956: PLUS
77957: PUSH
77958: EMPTY
77959: LIST
77960: LIST
77961: PPUSH
77962: LD_VAR 0 1
77966: PPUSH
77967: CALL 14983 0 3
77971: ST_TO_ADDR
// btype := GetBType ( building ) ;
77972: LD_ADDR_VAR 0 5
77976: PUSH
77977: LD_VAR 0 1
77981: PPUSH
77982: CALL_OW 266
77986: ST_TO_ADDR
// side := GetSide ( building ) ;
77987: LD_ADDR_VAR 0 8
77991: PUSH
77992: LD_VAR 0 1
77996: PPUSH
77997: CALL_OW 255
78001: ST_TO_ADDR
// if btype = b_lab then
78002: LD_VAR 0 5
78006: PUSH
78007: LD_INT 6
78009: EQUAL
78010: IFFALSE 78060
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
78012: LD_ADDR_EXP 56
78016: PUSH
78017: LD_EXP 56
78021: PPUSH
78022: LD_VAR 0 3
78026: PUSH
78027: LD_EXP 56
78031: PUSH
78032: LD_VAR 0 3
78036: ARRAY
78037: PUSH
78038: LD_INT 1
78040: PLUS
78041: PUSH
78042: EMPTY
78043: LIST
78044: LIST
78045: PPUSH
78046: LD_VAR 0 1
78050: PPUSH
78051: CALL 14983 0 3
78055: ST_TO_ADDR
// exit ;
78056: POP
78057: POP
78058: GO 78516
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
78060: LD_VAR 0 5
78064: PUSH
78065: LD_INT 0
78067: PUSH
78068: LD_INT 2
78070: PUSH
78071: LD_INT 4
78073: PUSH
78074: EMPTY
78075: LIST
78076: LIST
78077: LIST
78078: IN
78079: IFFALSE 78203
// begin if btype = b_armoury then
78081: LD_VAR 0 5
78085: PUSH
78086: LD_INT 4
78088: EQUAL
78089: IFFALSE 78099
// btype := b_barracks ;
78091: LD_ADDR_VAR 0 5
78095: PUSH
78096: LD_INT 5
78098: ST_TO_ADDR
// if btype = b_depot then
78099: LD_VAR 0 5
78103: PUSH
78104: LD_INT 0
78106: EQUAL
78107: IFFALSE 78117
// btype := b_warehouse ;
78109: LD_ADDR_VAR 0 5
78113: PUSH
78114: LD_INT 1
78116: ST_TO_ADDR
// if btype = b_workshop then
78117: LD_VAR 0 5
78121: PUSH
78122: LD_INT 2
78124: EQUAL
78125: IFFALSE 78135
// btype := b_factory ;
78127: LD_ADDR_VAR 0 5
78131: PUSH
78132: LD_INT 3
78134: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
78135: LD_VAR 0 5
78139: PPUSH
78140: LD_VAR 0 8
78144: PPUSH
78145: CALL_OW 323
78149: PUSH
78150: LD_INT 1
78152: EQUAL
78153: IFFALSE 78199
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
78155: LD_ADDR_EXP 55
78159: PUSH
78160: LD_EXP 55
78164: PPUSH
78165: LD_VAR 0 3
78169: PUSH
78170: LD_EXP 55
78174: PUSH
78175: LD_VAR 0 3
78179: ARRAY
78180: PUSH
78181: LD_INT 1
78183: PLUS
78184: PUSH
78185: EMPTY
78186: LIST
78187: LIST
78188: PPUSH
78189: LD_VAR 0 1
78193: PPUSH
78194: CALL 14983 0 3
78198: ST_TO_ADDR
// exit ;
78199: POP
78200: POP
78201: GO 78516
// end ; if btype in [ b_bunker , b_turret ] then
78203: LD_VAR 0 5
78207: PUSH
78208: LD_INT 32
78210: PUSH
78211: LD_INT 33
78213: PUSH
78214: EMPTY
78215: LIST
78216: LIST
78217: IN
78218: IFFALSE 78508
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
78220: LD_ADDR_EXP 31
78224: PUSH
78225: LD_EXP 31
78229: PPUSH
78230: LD_VAR 0 3
78234: PUSH
78235: LD_EXP 31
78239: PUSH
78240: LD_VAR 0 3
78244: ARRAY
78245: PUSH
78246: LD_INT 1
78248: PLUS
78249: PUSH
78250: EMPTY
78251: LIST
78252: LIST
78253: PPUSH
78254: LD_VAR 0 1
78258: PPUSH
78259: CALL 14983 0 3
78263: ST_TO_ADDR
// if btype = b_bunker then
78264: LD_VAR 0 5
78268: PUSH
78269: LD_INT 32
78271: EQUAL
78272: IFFALSE 78508
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
78274: LD_ADDR_EXP 32
78278: PUSH
78279: LD_EXP 32
78283: PPUSH
78284: LD_VAR 0 3
78288: PUSH
78289: LD_EXP 32
78293: PUSH
78294: LD_VAR 0 3
78298: ARRAY
78299: PUSH
78300: LD_INT 1
78302: PLUS
78303: PUSH
78304: EMPTY
78305: LIST
78306: LIST
78307: PPUSH
78308: LD_VAR 0 1
78312: PPUSH
78313: CALL 14983 0 3
78317: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
78318: LD_ADDR_VAR 0 6
78322: PUSH
78323: LD_EXP 23
78327: PUSH
78328: LD_VAR 0 3
78332: ARRAY
78333: PPUSH
78334: LD_INT 25
78336: PUSH
78337: LD_INT 1
78339: PUSH
78340: EMPTY
78341: LIST
78342: LIST
78343: PUSH
78344: LD_INT 3
78346: PUSH
78347: LD_INT 54
78349: PUSH
78350: EMPTY
78351: LIST
78352: PUSH
78353: EMPTY
78354: LIST
78355: LIST
78356: PUSH
78357: EMPTY
78358: LIST
78359: LIST
78360: PPUSH
78361: CALL_OW 72
78365: ST_TO_ADDR
// if tmp then
78366: LD_VAR 0 6
78370: IFFALSE 78376
// exit ;
78372: POP
78373: POP
78374: GO 78516
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
78376: LD_ADDR_VAR 0 6
78380: PUSH
78381: LD_EXP 23
78385: PUSH
78386: LD_VAR 0 3
78390: ARRAY
78391: PPUSH
78392: LD_INT 2
78394: PUSH
78395: LD_INT 30
78397: PUSH
78398: LD_INT 4
78400: PUSH
78401: EMPTY
78402: LIST
78403: LIST
78404: PUSH
78405: LD_INT 30
78407: PUSH
78408: LD_INT 5
78410: PUSH
78411: EMPTY
78412: LIST
78413: LIST
78414: PUSH
78415: EMPTY
78416: LIST
78417: LIST
78418: LIST
78419: PPUSH
78420: CALL_OW 72
78424: ST_TO_ADDR
// if not tmp then
78425: LD_VAR 0 6
78429: NOT
78430: IFFALSE 78436
// exit ;
78432: POP
78433: POP
78434: GO 78516
// for j in tmp do
78436: LD_ADDR_VAR 0 4
78440: PUSH
78441: LD_VAR 0 6
78445: PUSH
78446: FOR_IN
78447: IFFALSE 78506
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
78449: LD_ADDR_VAR 0 7
78453: PUSH
78454: LD_VAR 0 4
78458: PPUSH
78459: CALL_OW 313
78463: PPUSH
78464: LD_INT 25
78466: PUSH
78467: LD_INT 1
78469: PUSH
78470: EMPTY
78471: LIST
78472: LIST
78473: PPUSH
78474: CALL_OW 72
78478: ST_TO_ADDR
// if units then
78479: LD_VAR 0 7
78483: IFFALSE 78504
// begin ComExitBuilding ( units [ 1 ] ) ;
78485: LD_VAR 0 7
78489: PUSH
78490: LD_INT 1
78492: ARRAY
78493: PPUSH
78494: CALL_OW 122
// exit ;
78498: POP
78499: POP
78500: POP
78501: POP
78502: GO 78516
// end ; end ;
78504: GO 78446
78506: POP
78507: POP
// end ; end ; exit ;
78508: POP
78509: POP
78510: GO 78516
// end ; end ;
78512: GO 77870
78514: POP
78515: POP
// end ;
78516: LD_VAR 0 2
78520: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
78521: LD_INT 0
78523: PPUSH
78524: PPUSH
78525: PPUSH
78526: PPUSH
78527: PPUSH
78528: PPUSH
78529: PPUSH
// if not mc_bases or not skirmish then
78530: LD_EXP 23
78534: NOT
78535: PUSH
78536: LD_EXP 21
78540: NOT
78541: OR
78542: IFFALSE 78546
// exit ;
78544: GO 78811
// btype := GetBType ( building ) ;
78546: LD_ADDR_VAR 0 6
78550: PUSH
78551: LD_VAR 0 1
78555: PPUSH
78556: CALL_OW 266
78560: ST_TO_ADDR
// x := GetX ( building ) ;
78561: LD_ADDR_VAR 0 7
78565: PUSH
78566: LD_VAR 0 1
78570: PPUSH
78571: CALL_OW 250
78575: ST_TO_ADDR
// y := GetY ( building ) ;
78576: LD_ADDR_VAR 0 8
78580: PUSH
78581: LD_VAR 0 1
78585: PPUSH
78586: CALL_OW 251
78590: ST_TO_ADDR
// d := GetDir ( building ) ;
78591: LD_ADDR_VAR 0 9
78595: PUSH
78596: LD_VAR 0 1
78600: PPUSH
78601: CALL_OW 254
78605: ST_TO_ADDR
// for i = 1 to mc_bases do
78606: LD_ADDR_VAR 0 4
78610: PUSH
78611: DOUBLE
78612: LD_INT 1
78614: DEC
78615: ST_TO_ADDR
78616: LD_EXP 23
78620: PUSH
78621: FOR_TO
78622: IFFALSE 78809
// begin if not mc_build_list [ i ] then
78624: LD_EXP 28
78628: PUSH
78629: LD_VAR 0 4
78633: ARRAY
78634: NOT
78635: IFFALSE 78639
// continue ;
78637: GO 78621
// for j := 1 to mc_build_list [ i ] do
78639: LD_ADDR_VAR 0 5
78643: PUSH
78644: DOUBLE
78645: LD_INT 1
78647: DEC
78648: ST_TO_ADDR
78649: LD_EXP 28
78653: PUSH
78654: LD_VAR 0 4
78658: ARRAY
78659: PUSH
78660: FOR_TO
78661: IFFALSE 78805
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
78663: LD_VAR 0 6
78667: PUSH
78668: LD_VAR 0 7
78672: PUSH
78673: LD_VAR 0 8
78677: PUSH
78678: LD_VAR 0 9
78682: PUSH
78683: EMPTY
78684: LIST
78685: LIST
78686: LIST
78687: LIST
78688: PPUSH
78689: LD_EXP 28
78693: PUSH
78694: LD_VAR 0 4
78698: ARRAY
78699: PUSH
78700: LD_VAR 0 5
78704: ARRAY
78705: PPUSH
78706: CALL 21166 0 2
78710: IFFALSE 78803
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
78712: LD_ADDR_EXP 28
78716: PUSH
78717: LD_EXP 28
78721: PPUSH
78722: LD_VAR 0 4
78726: PPUSH
78727: LD_EXP 28
78731: PUSH
78732: LD_VAR 0 4
78736: ARRAY
78737: PPUSH
78738: LD_VAR 0 5
78742: PPUSH
78743: CALL_OW 3
78747: PPUSH
78748: CALL_OW 1
78752: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
78753: LD_ADDR_EXP 30
78757: PUSH
78758: LD_EXP 30
78762: PPUSH
78763: LD_VAR 0 4
78767: PUSH
78768: LD_EXP 30
78772: PUSH
78773: LD_VAR 0 4
78777: ARRAY
78778: PUSH
78779: LD_INT 1
78781: PLUS
78782: PUSH
78783: EMPTY
78784: LIST
78785: LIST
78786: PPUSH
78787: LD_VAR 0 1
78791: PPUSH
78792: CALL 14983 0 3
78796: ST_TO_ADDR
// exit ;
78797: POP
78798: POP
78799: POP
78800: POP
78801: GO 78811
// end ;
78803: GO 78660
78805: POP
78806: POP
// end ;
78807: GO 78621
78809: POP
78810: POP
// end ;
78811: LD_VAR 0 3
78815: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
78816: LD_INT 0
78818: PPUSH
78819: PPUSH
78820: PPUSH
// if not mc_bases or not skirmish then
78821: LD_EXP 23
78825: NOT
78826: PUSH
78827: LD_EXP 21
78831: NOT
78832: OR
78833: IFFALSE 78837
// exit ;
78835: GO 79027
// for i = 1 to mc_bases do
78837: LD_ADDR_VAR 0 4
78841: PUSH
78842: DOUBLE
78843: LD_INT 1
78845: DEC
78846: ST_TO_ADDR
78847: LD_EXP 23
78851: PUSH
78852: FOR_TO
78853: IFFALSE 78940
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
78855: LD_VAR 0 1
78859: PUSH
78860: LD_EXP 31
78864: PUSH
78865: LD_VAR 0 4
78869: ARRAY
78870: IN
78871: PUSH
78872: LD_VAR 0 1
78876: PUSH
78877: LD_EXP 32
78881: PUSH
78882: LD_VAR 0 4
78886: ARRAY
78887: IN
78888: NOT
78889: AND
78890: IFFALSE 78938
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
78892: LD_ADDR_EXP 32
78896: PUSH
78897: LD_EXP 32
78901: PPUSH
78902: LD_VAR 0 4
78906: PUSH
78907: LD_EXP 32
78911: PUSH
78912: LD_VAR 0 4
78916: ARRAY
78917: PUSH
78918: LD_INT 1
78920: PLUS
78921: PUSH
78922: EMPTY
78923: LIST
78924: LIST
78925: PPUSH
78926: LD_VAR 0 1
78930: PPUSH
78931: CALL 14983 0 3
78935: ST_TO_ADDR
// break ;
78936: GO 78940
// end ; end ;
78938: GO 78852
78940: POP
78941: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
78942: LD_VAR 0 1
78946: PPUSH
78947: CALL_OW 257
78951: PUSH
78952: LD_EXP 49
78956: IN
78957: PUSH
78958: LD_VAR 0 1
78962: PPUSH
78963: CALL_OW 266
78967: PUSH
78968: LD_INT 5
78970: EQUAL
78971: AND
78972: PUSH
78973: LD_VAR 0 2
78977: PPUSH
78978: CALL_OW 110
78982: PUSH
78983: LD_INT 18
78985: NONEQUAL
78986: AND
78987: IFFALSE 79027
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
78989: LD_VAR 0 2
78993: PPUSH
78994: CALL_OW 257
78998: PUSH
78999: LD_INT 5
79001: PUSH
79002: LD_INT 8
79004: PUSH
79005: LD_INT 9
79007: PUSH
79008: EMPTY
79009: LIST
79010: LIST
79011: LIST
79012: IN
79013: IFFALSE 79027
// SetClass ( unit , 1 ) ;
79015: LD_VAR 0 2
79019: PPUSH
79020: LD_INT 1
79022: PPUSH
79023: CALL_OW 336
// end ;
79027: LD_VAR 0 3
79031: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
79032: LD_INT 0
79034: PPUSH
79035: PPUSH
// if not mc_bases or not skirmish then
79036: LD_EXP 23
79040: NOT
79041: PUSH
79042: LD_EXP 21
79046: NOT
79047: OR
79048: IFFALSE 79052
// exit ;
79050: GO 79168
// if GetLives ( abandoned_vehicle ) > 250 then
79052: LD_VAR 0 2
79056: PPUSH
79057: CALL_OW 256
79061: PUSH
79062: LD_INT 250
79064: GREATER
79065: IFFALSE 79069
// exit ;
79067: GO 79168
// for i = 1 to mc_bases do
79069: LD_ADDR_VAR 0 6
79073: PUSH
79074: DOUBLE
79075: LD_INT 1
79077: DEC
79078: ST_TO_ADDR
79079: LD_EXP 23
79083: PUSH
79084: FOR_TO
79085: IFFALSE 79166
// begin if driver in mc_bases [ i ] then
79087: LD_VAR 0 1
79091: PUSH
79092: LD_EXP 23
79096: PUSH
79097: LD_VAR 0 6
79101: ARRAY
79102: IN
79103: IFFALSE 79164
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
79105: LD_VAR 0 1
79109: PPUSH
79110: LD_EXP 23
79114: PUSH
79115: LD_VAR 0 6
79119: ARRAY
79120: PPUSH
79121: LD_INT 2
79123: PUSH
79124: LD_INT 30
79126: PUSH
79127: LD_INT 0
79129: PUSH
79130: EMPTY
79131: LIST
79132: LIST
79133: PUSH
79134: LD_INT 30
79136: PUSH
79137: LD_INT 1
79139: PUSH
79140: EMPTY
79141: LIST
79142: LIST
79143: PUSH
79144: EMPTY
79145: LIST
79146: LIST
79147: LIST
79148: PPUSH
79149: CALL_OW 72
79153: PUSH
79154: LD_INT 1
79156: ARRAY
79157: PPUSH
79158: CALL 47602 0 2
// break ;
79162: GO 79166
// end ; end ;
79164: GO 79084
79166: POP
79167: POP
// end ; end_of_file
79168: LD_VAR 0 5
79172: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
79173: LD_INT 0
79175: PPUSH
// ar_miner := 81 ;
79176: LD_ADDR_EXP 74
79180: PUSH
79181: LD_INT 81
79183: ST_TO_ADDR
// ar_crane := 88 ;
79184: LD_ADDR_EXP 73
79188: PUSH
79189: LD_INT 88
79191: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
79192: LD_ADDR_EXP 68
79196: PUSH
79197: LD_INT 89
79199: ST_TO_ADDR
// us_hack := 99 ;
79200: LD_ADDR_EXP 69
79204: PUSH
79205: LD_INT 99
79207: ST_TO_ADDR
// us_artillery := 97 ;
79208: LD_ADDR_EXP 70
79212: PUSH
79213: LD_INT 97
79215: ST_TO_ADDR
// ar_bio_bomb := 91 ;
79216: LD_ADDR_EXP 71
79220: PUSH
79221: LD_INT 91
79223: ST_TO_ADDR
// ar_mortar := 92 ;
79224: LD_ADDR_EXP 72
79228: PUSH
79229: LD_INT 92
79231: ST_TO_ADDR
// ru_radar := 98 ;
79232: LD_ADDR_EXP 67
79236: PUSH
79237: LD_INT 98
79239: ST_TO_ADDR
// tech_Artillery := 80 ;
79240: LD_ADDR_EXP 75
79244: PUSH
79245: LD_INT 80
79247: ST_TO_ADDR
// tech_RadMat := 81 ;
79248: LD_ADDR_EXP 76
79252: PUSH
79253: LD_INT 81
79255: ST_TO_ADDR
// tech_BasicTools := 82 ;
79256: LD_ADDR_EXP 77
79260: PUSH
79261: LD_INT 82
79263: ST_TO_ADDR
// tech_Cargo := 83 ;
79264: LD_ADDR_EXP 78
79268: PUSH
79269: LD_INT 83
79271: ST_TO_ADDR
// tech_Track := 84 ;
79272: LD_ADDR_EXP 79
79276: PUSH
79277: LD_INT 84
79279: ST_TO_ADDR
// tech_Crane := 85 ;
79280: LD_ADDR_EXP 80
79284: PUSH
79285: LD_INT 85
79287: ST_TO_ADDR
// tech_Bulldozer := 86 ;
79288: LD_ADDR_EXP 81
79292: PUSH
79293: LD_INT 86
79295: ST_TO_ADDR
// tech_Hovercraft := 87 ;
79296: LD_ADDR_EXP 82
79300: PUSH
79301: LD_INT 87
79303: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
79304: LD_ADDR_EXP 83
79308: PUSH
79309: LD_INT 88
79311: ST_TO_ADDR
// class_mastodont := 31 ;
79312: LD_ADDR_EXP 84
79316: PUSH
79317: LD_INT 31
79319: ST_TO_ADDR
// class_horse := 21 ;
79320: LD_ADDR_EXP 85
79324: PUSH
79325: LD_INT 21
79327: ST_TO_ADDR
// end ;
79328: LD_VAR 0 1
79332: RET
// every 1 do
79333: GO 79335
79335: DISABLE
// InitGlobalVariables ; end_of_file
79336: CALL 79173 0 0
79340: END
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
79341: LD_INT 0
79343: PPUSH
79344: PPUSH
79345: PPUSH
79346: PPUSH
79347: PPUSH
79348: PPUSH
79349: PPUSH
79350: PPUSH
79351: PPUSH
79352: PPUSH
79353: PPUSH
79354: PPUSH
79355: PPUSH
79356: PPUSH
79357: PPUSH
79358: PPUSH
79359: PPUSH
79360: PPUSH
79361: PPUSH
79362: PPUSH
79363: PPUSH
79364: PPUSH
79365: PPUSH
79366: PPUSH
79367: PPUSH
79368: PPUSH
79369: PPUSH
79370: PPUSH
79371: PPUSH
79372: PPUSH
79373: PPUSH
79374: PPUSH
79375: PPUSH
79376: PPUSH
// if not list then
79377: LD_VAR 0 1
79381: NOT
79382: IFFALSE 79386
// exit ;
79384: GO 84045
// base := list [ 1 ] ;
79386: LD_ADDR_VAR 0 3
79390: PUSH
79391: LD_VAR 0 1
79395: PUSH
79396: LD_INT 1
79398: ARRAY
79399: ST_TO_ADDR
// group := list [ 2 ] ;
79400: LD_ADDR_VAR 0 4
79404: PUSH
79405: LD_VAR 0 1
79409: PUSH
79410: LD_INT 2
79412: ARRAY
79413: ST_TO_ADDR
// path := list [ 3 ] ;
79414: LD_ADDR_VAR 0 5
79418: PUSH
79419: LD_VAR 0 1
79423: PUSH
79424: LD_INT 3
79426: ARRAY
79427: ST_TO_ADDR
// flags := list [ 4 ] ;
79428: LD_ADDR_VAR 0 6
79432: PUSH
79433: LD_VAR 0 1
79437: PUSH
79438: LD_INT 4
79440: ARRAY
79441: ST_TO_ADDR
// mined := [ ] ;
79442: LD_ADDR_VAR 0 27
79446: PUSH
79447: EMPTY
79448: ST_TO_ADDR
// bombed := [ ] ;
79449: LD_ADDR_VAR 0 28
79453: PUSH
79454: EMPTY
79455: ST_TO_ADDR
// healers := [ ] ;
79456: LD_ADDR_VAR 0 31
79460: PUSH
79461: EMPTY
79462: ST_TO_ADDR
// to_heal := [ ] ;
79463: LD_ADDR_VAR 0 30
79467: PUSH
79468: EMPTY
79469: ST_TO_ADDR
// repairs := [ ] ;
79470: LD_ADDR_VAR 0 33
79474: PUSH
79475: EMPTY
79476: ST_TO_ADDR
// to_repair := [ ] ;
79477: LD_ADDR_VAR 0 32
79481: PUSH
79482: EMPTY
79483: ST_TO_ADDR
// if not group or not path then
79484: LD_VAR 0 4
79488: NOT
79489: PUSH
79490: LD_VAR 0 5
79494: NOT
79495: OR
79496: IFFALSE 79500
// exit ;
79498: GO 84045
// side := GetSide ( group [ 1 ] ) ;
79500: LD_ADDR_VAR 0 35
79504: PUSH
79505: LD_VAR 0 4
79509: PUSH
79510: LD_INT 1
79512: ARRAY
79513: PPUSH
79514: CALL_OW 255
79518: ST_TO_ADDR
// if flags then
79519: LD_VAR 0 6
79523: IFFALSE 79667
// begin f_ignore_area := flags [ 1 ] ;
79525: LD_ADDR_VAR 0 17
79529: PUSH
79530: LD_VAR 0 6
79534: PUSH
79535: LD_INT 1
79537: ARRAY
79538: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
79539: LD_ADDR_VAR 0 18
79543: PUSH
79544: LD_VAR 0 6
79548: PUSH
79549: LD_INT 2
79551: ARRAY
79552: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
79553: LD_ADDR_VAR 0 19
79557: PUSH
79558: LD_VAR 0 6
79562: PUSH
79563: LD_INT 3
79565: ARRAY
79566: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
79567: LD_ADDR_VAR 0 20
79571: PUSH
79572: LD_VAR 0 6
79576: PUSH
79577: LD_INT 4
79579: ARRAY
79580: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
79581: LD_ADDR_VAR 0 21
79585: PUSH
79586: LD_VAR 0 6
79590: PUSH
79591: LD_INT 5
79593: ARRAY
79594: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
79595: LD_ADDR_VAR 0 22
79599: PUSH
79600: LD_VAR 0 6
79604: PUSH
79605: LD_INT 6
79607: ARRAY
79608: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
79609: LD_ADDR_VAR 0 23
79613: PUSH
79614: LD_VAR 0 6
79618: PUSH
79619: LD_INT 7
79621: ARRAY
79622: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
79623: LD_ADDR_VAR 0 24
79627: PUSH
79628: LD_VAR 0 6
79632: PUSH
79633: LD_INT 8
79635: ARRAY
79636: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
79637: LD_ADDR_VAR 0 25
79641: PUSH
79642: LD_VAR 0 6
79646: PUSH
79647: LD_INT 9
79649: ARRAY
79650: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
79651: LD_ADDR_VAR 0 26
79655: PUSH
79656: LD_VAR 0 6
79660: PUSH
79661: LD_INT 10
79663: ARRAY
79664: ST_TO_ADDR
// end else
79665: GO 79747
// begin f_ignore_area := false ;
79667: LD_ADDR_VAR 0 17
79671: PUSH
79672: LD_INT 0
79674: ST_TO_ADDR
// f_capture := false ;
79675: LD_ADDR_VAR 0 18
79679: PUSH
79680: LD_INT 0
79682: ST_TO_ADDR
// f_ignore_civ := false ;
79683: LD_ADDR_VAR 0 19
79687: PUSH
79688: LD_INT 0
79690: ST_TO_ADDR
// f_murder := false ;
79691: LD_ADDR_VAR 0 20
79695: PUSH
79696: LD_INT 0
79698: ST_TO_ADDR
// f_mines := false ;
79699: LD_ADDR_VAR 0 21
79703: PUSH
79704: LD_INT 0
79706: ST_TO_ADDR
// f_repair := false ;
79707: LD_ADDR_VAR 0 22
79711: PUSH
79712: LD_INT 0
79714: ST_TO_ADDR
// f_heal := false ;
79715: LD_ADDR_VAR 0 23
79719: PUSH
79720: LD_INT 0
79722: ST_TO_ADDR
// f_spacetime := false ;
79723: LD_ADDR_VAR 0 24
79727: PUSH
79728: LD_INT 0
79730: ST_TO_ADDR
// f_attack_depot := false ;
79731: LD_ADDR_VAR 0 25
79735: PUSH
79736: LD_INT 0
79738: ST_TO_ADDR
// f_crawl := false ;
79739: LD_ADDR_VAR 0 26
79743: PUSH
79744: LD_INT 0
79746: ST_TO_ADDR
// end ; if f_heal then
79747: LD_VAR 0 23
79751: IFFALSE 79778
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
79753: LD_ADDR_VAR 0 31
79757: PUSH
79758: LD_VAR 0 4
79762: PPUSH
79763: LD_INT 25
79765: PUSH
79766: LD_INT 4
79768: PUSH
79769: EMPTY
79770: LIST
79771: LIST
79772: PPUSH
79773: CALL_OW 72
79777: ST_TO_ADDR
// if f_repair then
79778: LD_VAR 0 22
79782: IFFALSE 79809
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
79784: LD_ADDR_VAR 0 33
79788: PUSH
79789: LD_VAR 0 4
79793: PPUSH
79794: LD_INT 25
79796: PUSH
79797: LD_INT 3
79799: PUSH
79800: EMPTY
79801: LIST
79802: LIST
79803: PPUSH
79804: CALL_OW 72
79808: ST_TO_ADDR
// units_path := [ ] ;
79809: LD_ADDR_VAR 0 16
79813: PUSH
79814: EMPTY
79815: ST_TO_ADDR
// for i = 1 to group do
79816: LD_ADDR_VAR 0 7
79820: PUSH
79821: DOUBLE
79822: LD_INT 1
79824: DEC
79825: ST_TO_ADDR
79826: LD_VAR 0 4
79830: PUSH
79831: FOR_TO
79832: IFFALSE 79861
// units_path := Replace ( units_path , i , path ) ;
79834: LD_ADDR_VAR 0 16
79838: PUSH
79839: LD_VAR 0 16
79843: PPUSH
79844: LD_VAR 0 7
79848: PPUSH
79849: LD_VAR 0 5
79853: PPUSH
79854: CALL_OW 1
79858: ST_TO_ADDR
79859: GO 79831
79861: POP
79862: POP
// repeat for i = group downto 1 do
79863: LD_ADDR_VAR 0 7
79867: PUSH
79868: DOUBLE
79869: LD_VAR 0 4
79873: INC
79874: ST_TO_ADDR
79875: LD_INT 1
79877: PUSH
79878: FOR_DOWNTO
79879: IFFALSE 84001
// begin wait ( 5 ) ;
79881: LD_INT 5
79883: PPUSH
79884: CALL_OW 67
// tmp := [ ] ;
79888: LD_ADDR_VAR 0 14
79892: PUSH
79893: EMPTY
79894: ST_TO_ADDR
// attacking := false ;
79895: LD_ADDR_VAR 0 29
79899: PUSH
79900: LD_INT 0
79902: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
79903: LD_VAR 0 4
79907: PUSH
79908: LD_VAR 0 7
79912: ARRAY
79913: PPUSH
79914: CALL_OW 301
79918: PUSH
79919: LD_VAR 0 4
79923: PUSH
79924: LD_VAR 0 7
79928: ARRAY
79929: NOT
79930: OR
79931: IFFALSE 80040
// begin if GetType ( group [ i ] ) = unit_human then
79933: LD_VAR 0 4
79937: PUSH
79938: LD_VAR 0 7
79942: ARRAY
79943: PPUSH
79944: CALL_OW 247
79948: PUSH
79949: LD_INT 1
79951: EQUAL
79952: IFFALSE 79998
// begin to_heal := to_heal diff group [ i ] ;
79954: LD_ADDR_VAR 0 30
79958: PUSH
79959: LD_VAR 0 30
79963: PUSH
79964: LD_VAR 0 4
79968: PUSH
79969: LD_VAR 0 7
79973: ARRAY
79974: DIFF
79975: ST_TO_ADDR
// healers := healers diff group [ i ] ;
79976: LD_ADDR_VAR 0 31
79980: PUSH
79981: LD_VAR 0 31
79985: PUSH
79986: LD_VAR 0 4
79990: PUSH
79991: LD_VAR 0 7
79995: ARRAY
79996: DIFF
79997: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
79998: LD_ADDR_VAR 0 4
80002: PUSH
80003: LD_VAR 0 4
80007: PPUSH
80008: LD_VAR 0 7
80012: PPUSH
80013: CALL_OW 3
80017: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
80018: LD_ADDR_VAR 0 16
80022: PUSH
80023: LD_VAR 0 16
80027: PPUSH
80028: LD_VAR 0 7
80032: PPUSH
80033: CALL_OW 3
80037: ST_TO_ADDR
// continue ;
80038: GO 79878
// end ; if f_repair then
80040: LD_VAR 0 22
80044: IFFALSE 80533
// begin if GetType ( group [ i ] ) = unit_vehicle then
80046: LD_VAR 0 4
80050: PUSH
80051: LD_VAR 0 7
80055: ARRAY
80056: PPUSH
80057: CALL_OW 247
80061: PUSH
80062: LD_INT 2
80064: EQUAL
80065: IFFALSE 80255
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
80067: LD_VAR 0 4
80071: PUSH
80072: LD_VAR 0 7
80076: ARRAY
80077: PPUSH
80078: CALL_OW 256
80082: PUSH
80083: LD_INT 700
80085: LESS
80086: PUSH
80087: LD_VAR 0 4
80091: PUSH
80092: LD_VAR 0 7
80096: ARRAY
80097: PUSH
80098: LD_VAR 0 32
80102: IN
80103: NOT
80104: AND
80105: IFFALSE 80129
// to_repair := to_repair union group [ i ] ;
80107: LD_ADDR_VAR 0 32
80111: PUSH
80112: LD_VAR 0 32
80116: PUSH
80117: LD_VAR 0 4
80121: PUSH
80122: LD_VAR 0 7
80126: ARRAY
80127: UNION
80128: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
80129: LD_VAR 0 4
80133: PUSH
80134: LD_VAR 0 7
80138: ARRAY
80139: PPUSH
80140: CALL_OW 256
80144: PUSH
80145: LD_INT 1000
80147: EQUAL
80148: PUSH
80149: LD_VAR 0 4
80153: PUSH
80154: LD_VAR 0 7
80158: ARRAY
80159: PUSH
80160: LD_VAR 0 32
80164: IN
80165: AND
80166: IFFALSE 80190
// to_repair := to_repair diff group [ i ] ;
80168: LD_ADDR_VAR 0 32
80172: PUSH
80173: LD_VAR 0 32
80177: PUSH
80178: LD_VAR 0 4
80182: PUSH
80183: LD_VAR 0 7
80187: ARRAY
80188: DIFF
80189: ST_TO_ADDR
// if group [ i ] in to_repair then
80190: LD_VAR 0 4
80194: PUSH
80195: LD_VAR 0 7
80199: ARRAY
80200: PUSH
80201: LD_VAR 0 32
80205: IN
80206: IFFALSE 80253
// begin if not IsInArea ( group [ i ] , f_repair ) then
80208: LD_VAR 0 4
80212: PUSH
80213: LD_VAR 0 7
80217: ARRAY
80218: PPUSH
80219: LD_VAR 0 22
80223: PPUSH
80224: CALL_OW 308
80228: NOT
80229: IFFALSE 80251
// ComMoveToArea ( group [ i ] , f_repair ) ;
80231: LD_VAR 0 4
80235: PUSH
80236: LD_VAR 0 7
80240: ARRAY
80241: PPUSH
80242: LD_VAR 0 22
80246: PPUSH
80247: CALL_OW 113
// continue ;
80251: GO 79878
// end ; end else
80253: GO 80533
// if group [ i ] in repairs then
80255: LD_VAR 0 4
80259: PUSH
80260: LD_VAR 0 7
80264: ARRAY
80265: PUSH
80266: LD_VAR 0 33
80270: IN
80271: IFFALSE 80533
// begin if IsInUnit ( group [ i ] ) then
80273: LD_VAR 0 4
80277: PUSH
80278: LD_VAR 0 7
80282: ARRAY
80283: PPUSH
80284: CALL_OW 310
80288: IFFALSE 80356
// begin z := IsInUnit ( group [ i ] ) ;
80290: LD_ADDR_VAR 0 13
80294: PUSH
80295: LD_VAR 0 4
80299: PUSH
80300: LD_VAR 0 7
80304: ARRAY
80305: PPUSH
80306: CALL_OW 310
80310: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
80311: LD_VAR 0 13
80315: PUSH
80316: LD_VAR 0 32
80320: IN
80321: PUSH
80322: LD_VAR 0 13
80326: PPUSH
80327: LD_VAR 0 22
80331: PPUSH
80332: CALL_OW 308
80336: AND
80337: IFFALSE 80354
// ComExitVehicle ( group [ i ] ) ;
80339: LD_VAR 0 4
80343: PUSH
80344: LD_VAR 0 7
80348: ARRAY
80349: PPUSH
80350: CALL_OW 121
// end else
80354: GO 80533
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
80356: LD_ADDR_VAR 0 13
80360: PUSH
80361: LD_VAR 0 4
80365: PPUSH
80366: LD_INT 95
80368: PUSH
80369: LD_VAR 0 22
80373: PUSH
80374: EMPTY
80375: LIST
80376: LIST
80377: PUSH
80378: LD_INT 58
80380: PUSH
80381: EMPTY
80382: LIST
80383: PUSH
80384: EMPTY
80385: LIST
80386: LIST
80387: PPUSH
80388: CALL_OW 72
80392: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
80393: LD_VAR 0 4
80397: PUSH
80398: LD_VAR 0 7
80402: ARRAY
80403: PPUSH
80404: CALL_OW 314
80408: NOT
80409: IFFALSE 80531
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
80411: LD_ADDR_VAR 0 10
80415: PUSH
80416: LD_VAR 0 13
80420: PPUSH
80421: LD_VAR 0 4
80425: PUSH
80426: LD_VAR 0 7
80430: ARRAY
80431: PPUSH
80432: CALL_OW 74
80436: ST_TO_ADDR
// if not x then
80437: LD_VAR 0 10
80441: NOT
80442: IFFALSE 80446
// continue ;
80444: GO 79878
// if GetLives ( x ) < 1000 then
80446: LD_VAR 0 10
80450: PPUSH
80451: CALL_OW 256
80455: PUSH
80456: LD_INT 1000
80458: LESS
80459: IFFALSE 80483
// ComRepairVehicle ( group [ i ] , x ) else
80461: LD_VAR 0 4
80465: PUSH
80466: LD_VAR 0 7
80470: ARRAY
80471: PPUSH
80472: LD_VAR 0 10
80476: PPUSH
80477: CALL_OW 129
80481: GO 80531
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
80483: LD_VAR 0 23
80487: PUSH
80488: LD_VAR 0 4
80492: PUSH
80493: LD_VAR 0 7
80497: ARRAY
80498: PPUSH
80499: CALL_OW 256
80503: PUSH
80504: LD_INT 1000
80506: LESS
80507: AND
80508: NOT
80509: IFFALSE 80531
// ComEnterUnit ( group [ i ] , x ) ;
80511: LD_VAR 0 4
80515: PUSH
80516: LD_VAR 0 7
80520: ARRAY
80521: PPUSH
80522: LD_VAR 0 10
80526: PPUSH
80527: CALL_OW 120
// end ; continue ;
80531: GO 79878
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
80533: LD_VAR 0 23
80537: PUSH
80538: LD_VAR 0 4
80542: PUSH
80543: LD_VAR 0 7
80547: ARRAY
80548: PPUSH
80549: CALL_OW 247
80553: PUSH
80554: LD_INT 1
80556: EQUAL
80557: AND
80558: IFFALSE 81036
// begin if group [ i ] in healers then
80560: LD_VAR 0 4
80564: PUSH
80565: LD_VAR 0 7
80569: ARRAY
80570: PUSH
80571: LD_VAR 0 31
80575: IN
80576: IFFALSE 80849
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
80578: LD_VAR 0 4
80582: PUSH
80583: LD_VAR 0 7
80587: ARRAY
80588: PPUSH
80589: LD_VAR 0 23
80593: PPUSH
80594: CALL_OW 308
80598: NOT
80599: PUSH
80600: LD_VAR 0 4
80604: PUSH
80605: LD_VAR 0 7
80609: ARRAY
80610: PPUSH
80611: CALL_OW 314
80615: NOT
80616: AND
80617: IFFALSE 80641
// ComMoveToArea ( group [ i ] , f_heal ) else
80619: LD_VAR 0 4
80623: PUSH
80624: LD_VAR 0 7
80628: ARRAY
80629: PPUSH
80630: LD_VAR 0 23
80634: PPUSH
80635: CALL_OW 113
80639: GO 80847
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
80641: LD_VAR 0 4
80645: PUSH
80646: LD_VAR 0 7
80650: ARRAY
80651: PPUSH
80652: CALL 44064 0 1
80656: PPUSH
80657: CALL_OW 256
80661: PUSH
80662: LD_INT 1000
80664: EQUAL
80665: IFFALSE 80684
// ComStop ( group [ i ] ) else
80667: LD_VAR 0 4
80671: PUSH
80672: LD_VAR 0 7
80676: ARRAY
80677: PPUSH
80678: CALL_OW 141
80682: GO 80847
// if not HasTask ( group [ i ] ) and to_heal then
80684: LD_VAR 0 4
80688: PUSH
80689: LD_VAR 0 7
80693: ARRAY
80694: PPUSH
80695: CALL_OW 314
80699: NOT
80700: PUSH
80701: LD_VAR 0 30
80705: AND
80706: IFFALSE 80847
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
80708: LD_ADDR_VAR 0 13
80712: PUSH
80713: LD_VAR 0 30
80717: PPUSH
80718: LD_INT 3
80720: PUSH
80721: LD_INT 54
80723: PUSH
80724: EMPTY
80725: LIST
80726: PUSH
80727: EMPTY
80728: LIST
80729: LIST
80730: PPUSH
80731: CALL_OW 72
80735: PPUSH
80736: LD_VAR 0 4
80740: PUSH
80741: LD_VAR 0 7
80745: ARRAY
80746: PPUSH
80747: CALL_OW 74
80751: ST_TO_ADDR
// if z then
80752: LD_VAR 0 13
80756: IFFALSE 80847
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
80758: LD_INT 91
80760: PUSH
80761: LD_VAR 0 13
80765: PUSH
80766: LD_INT 10
80768: PUSH
80769: EMPTY
80770: LIST
80771: LIST
80772: LIST
80773: PUSH
80774: LD_INT 81
80776: PUSH
80777: LD_VAR 0 13
80781: PPUSH
80782: CALL_OW 255
80786: PUSH
80787: EMPTY
80788: LIST
80789: LIST
80790: PUSH
80791: EMPTY
80792: LIST
80793: LIST
80794: PPUSH
80795: CALL_OW 69
80799: PUSH
80800: LD_INT 0
80802: EQUAL
80803: IFFALSE 80827
// ComHeal ( group [ i ] , z ) else
80805: LD_VAR 0 4
80809: PUSH
80810: LD_VAR 0 7
80814: ARRAY
80815: PPUSH
80816: LD_VAR 0 13
80820: PPUSH
80821: CALL_OW 128
80825: GO 80847
// ComMoveToArea ( group [ i ] , f_heal ) ;
80827: LD_VAR 0 4
80831: PUSH
80832: LD_VAR 0 7
80836: ARRAY
80837: PPUSH
80838: LD_VAR 0 23
80842: PPUSH
80843: CALL_OW 113
// end ; continue ;
80847: GO 79878
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
80849: LD_VAR 0 4
80853: PUSH
80854: LD_VAR 0 7
80858: ARRAY
80859: PPUSH
80860: CALL_OW 256
80864: PUSH
80865: LD_INT 700
80867: LESS
80868: PUSH
80869: LD_VAR 0 4
80873: PUSH
80874: LD_VAR 0 7
80878: ARRAY
80879: PUSH
80880: LD_VAR 0 30
80884: IN
80885: NOT
80886: AND
80887: IFFALSE 80911
// to_heal := to_heal union group [ i ] ;
80889: LD_ADDR_VAR 0 30
80893: PUSH
80894: LD_VAR 0 30
80898: PUSH
80899: LD_VAR 0 4
80903: PUSH
80904: LD_VAR 0 7
80908: ARRAY
80909: UNION
80910: ST_TO_ADDR
// if group [ i ] in to_heal then
80911: LD_VAR 0 4
80915: PUSH
80916: LD_VAR 0 7
80920: ARRAY
80921: PUSH
80922: LD_VAR 0 30
80926: IN
80927: IFFALSE 81036
// begin if GetLives ( group [ i ] ) = 1000 then
80929: LD_VAR 0 4
80933: PUSH
80934: LD_VAR 0 7
80938: ARRAY
80939: PPUSH
80940: CALL_OW 256
80944: PUSH
80945: LD_INT 1000
80947: EQUAL
80948: IFFALSE 80974
// to_heal := to_heal diff group [ i ] else
80950: LD_ADDR_VAR 0 30
80954: PUSH
80955: LD_VAR 0 30
80959: PUSH
80960: LD_VAR 0 4
80964: PUSH
80965: LD_VAR 0 7
80969: ARRAY
80970: DIFF
80971: ST_TO_ADDR
80972: GO 81036
// begin if not IsInArea ( group [ i ] , to_heal ) then
80974: LD_VAR 0 4
80978: PUSH
80979: LD_VAR 0 7
80983: ARRAY
80984: PPUSH
80985: LD_VAR 0 30
80989: PPUSH
80990: CALL_OW 308
80994: NOT
80995: IFFALSE 81019
// ComMoveToArea ( group [ i ] , f_heal ) else
80997: LD_VAR 0 4
81001: PUSH
81002: LD_VAR 0 7
81006: ARRAY
81007: PPUSH
81008: LD_VAR 0 23
81012: PPUSH
81013: CALL_OW 113
81017: GO 81034
// ComHold ( group [ i ] ) ;
81019: LD_VAR 0 4
81023: PUSH
81024: LD_VAR 0 7
81028: ARRAY
81029: PPUSH
81030: CALL_OW 140
// continue ;
81034: GO 79878
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
81036: LD_VAR 0 4
81040: PUSH
81041: LD_VAR 0 7
81045: ARRAY
81046: PPUSH
81047: LD_INT 10
81049: PPUSH
81050: CALL 42484 0 2
81054: NOT
81055: PUSH
81056: LD_VAR 0 16
81060: PUSH
81061: LD_VAR 0 7
81065: ARRAY
81066: PUSH
81067: EMPTY
81068: EQUAL
81069: NOT
81070: AND
81071: IFFALSE 81337
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
81073: LD_VAR 0 4
81077: PUSH
81078: LD_VAR 0 7
81082: ARRAY
81083: PPUSH
81084: CALL_OW 262
81088: PUSH
81089: LD_INT 1
81091: PUSH
81092: LD_INT 2
81094: PUSH
81095: EMPTY
81096: LIST
81097: LIST
81098: IN
81099: IFFALSE 81140
// if GetFuel ( group [ i ] ) < 10 then
81101: LD_VAR 0 4
81105: PUSH
81106: LD_VAR 0 7
81110: ARRAY
81111: PPUSH
81112: CALL_OW 261
81116: PUSH
81117: LD_INT 10
81119: LESS
81120: IFFALSE 81140
// SetFuel ( group [ i ] , 12 ) ;
81122: LD_VAR 0 4
81126: PUSH
81127: LD_VAR 0 7
81131: ARRAY
81132: PPUSH
81133: LD_INT 12
81135: PPUSH
81136: CALL_OW 240
// if units_path [ i ] then
81140: LD_VAR 0 16
81144: PUSH
81145: LD_VAR 0 7
81149: ARRAY
81150: IFFALSE 81335
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
81152: LD_VAR 0 4
81156: PUSH
81157: LD_VAR 0 7
81161: ARRAY
81162: PPUSH
81163: LD_VAR 0 16
81167: PUSH
81168: LD_VAR 0 7
81172: ARRAY
81173: PUSH
81174: LD_INT 1
81176: ARRAY
81177: PUSH
81178: LD_INT 1
81180: ARRAY
81181: PPUSH
81182: LD_VAR 0 16
81186: PUSH
81187: LD_VAR 0 7
81191: ARRAY
81192: PUSH
81193: LD_INT 1
81195: ARRAY
81196: PUSH
81197: LD_INT 2
81199: ARRAY
81200: PPUSH
81201: CALL_OW 297
81205: PUSH
81206: LD_INT 6
81208: GREATER
81209: IFFALSE 81284
// begin if not HasTask ( group [ i ] ) then
81211: LD_VAR 0 4
81215: PUSH
81216: LD_VAR 0 7
81220: ARRAY
81221: PPUSH
81222: CALL_OW 314
81226: NOT
81227: IFFALSE 81282
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
81229: LD_VAR 0 4
81233: PUSH
81234: LD_VAR 0 7
81238: ARRAY
81239: PPUSH
81240: LD_VAR 0 16
81244: PUSH
81245: LD_VAR 0 7
81249: ARRAY
81250: PUSH
81251: LD_INT 1
81253: ARRAY
81254: PUSH
81255: LD_INT 1
81257: ARRAY
81258: PPUSH
81259: LD_VAR 0 16
81263: PUSH
81264: LD_VAR 0 7
81268: ARRAY
81269: PUSH
81270: LD_INT 1
81272: ARRAY
81273: PUSH
81274: LD_INT 2
81276: ARRAY
81277: PPUSH
81278: CALL_OW 114
// end else
81282: GO 81335
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
81284: LD_ADDR_VAR 0 15
81288: PUSH
81289: LD_VAR 0 16
81293: PUSH
81294: LD_VAR 0 7
81298: ARRAY
81299: PPUSH
81300: LD_INT 1
81302: PPUSH
81303: CALL_OW 3
81307: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
81308: LD_ADDR_VAR 0 16
81312: PUSH
81313: LD_VAR 0 16
81317: PPUSH
81318: LD_VAR 0 7
81322: PPUSH
81323: LD_VAR 0 15
81327: PPUSH
81328: CALL_OW 1
81332: ST_TO_ADDR
// continue ;
81333: GO 79878
// end ; end ; end else
81335: GO 83999
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
81337: LD_ADDR_VAR 0 14
81341: PUSH
81342: LD_INT 81
81344: PUSH
81345: LD_VAR 0 4
81349: PUSH
81350: LD_VAR 0 7
81354: ARRAY
81355: PPUSH
81356: CALL_OW 255
81360: PUSH
81361: EMPTY
81362: LIST
81363: LIST
81364: PPUSH
81365: CALL_OW 69
81369: ST_TO_ADDR
// if not tmp then
81370: LD_VAR 0 14
81374: NOT
81375: IFFALSE 81379
// continue ;
81377: GO 79878
// if f_ignore_area then
81379: LD_VAR 0 17
81383: IFFALSE 81471
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
81385: LD_ADDR_VAR 0 15
81389: PUSH
81390: LD_VAR 0 14
81394: PPUSH
81395: LD_INT 3
81397: PUSH
81398: LD_INT 92
81400: PUSH
81401: LD_VAR 0 17
81405: PUSH
81406: LD_INT 1
81408: ARRAY
81409: PUSH
81410: LD_VAR 0 17
81414: PUSH
81415: LD_INT 2
81417: ARRAY
81418: PUSH
81419: LD_VAR 0 17
81423: PUSH
81424: LD_INT 3
81426: ARRAY
81427: PUSH
81428: EMPTY
81429: LIST
81430: LIST
81431: LIST
81432: LIST
81433: PUSH
81434: EMPTY
81435: LIST
81436: LIST
81437: PPUSH
81438: CALL_OW 72
81442: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
81443: LD_VAR 0 14
81447: PUSH
81448: LD_VAR 0 15
81452: DIFF
81453: IFFALSE 81471
// tmp := tmp diff tmp2 ;
81455: LD_ADDR_VAR 0 14
81459: PUSH
81460: LD_VAR 0 14
81464: PUSH
81465: LD_VAR 0 15
81469: DIFF
81470: ST_TO_ADDR
// end ; if not f_murder then
81471: LD_VAR 0 20
81475: NOT
81476: IFFALSE 81534
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
81478: LD_ADDR_VAR 0 15
81482: PUSH
81483: LD_VAR 0 14
81487: PPUSH
81488: LD_INT 3
81490: PUSH
81491: LD_INT 50
81493: PUSH
81494: EMPTY
81495: LIST
81496: PUSH
81497: EMPTY
81498: LIST
81499: LIST
81500: PPUSH
81501: CALL_OW 72
81505: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
81506: LD_VAR 0 14
81510: PUSH
81511: LD_VAR 0 15
81515: DIFF
81516: IFFALSE 81534
// tmp := tmp diff tmp2 ;
81518: LD_ADDR_VAR 0 14
81522: PUSH
81523: LD_VAR 0 14
81527: PUSH
81528: LD_VAR 0 15
81532: DIFF
81533: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
81534: LD_ADDR_VAR 0 14
81538: PUSH
81539: LD_VAR 0 4
81543: PUSH
81544: LD_VAR 0 7
81548: ARRAY
81549: PPUSH
81550: LD_VAR 0 14
81554: PPUSH
81555: LD_INT 1
81557: PPUSH
81558: LD_INT 1
81560: PPUSH
81561: CALL 15418 0 4
81565: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
81566: LD_VAR 0 4
81570: PUSH
81571: LD_VAR 0 7
81575: ARRAY
81576: PPUSH
81577: CALL_OW 257
81581: PUSH
81582: LD_INT 1
81584: EQUAL
81585: IFFALSE 82033
// begin if WantPlant ( group [ i ] ) then
81587: LD_VAR 0 4
81591: PUSH
81592: LD_VAR 0 7
81596: ARRAY
81597: PPUSH
81598: CALL 14919 0 1
81602: IFFALSE 81606
// continue ;
81604: GO 79878
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
81606: LD_VAR 0 18
81610: PUSH
81611: LD_VAR 0 4
81615: PUSH
81616: LD_VAR 0 7
81620: ARRAY
81621: PPUSH
81622: CALL_OW 310
81626: NOT
81627: AND
81628: PUSH
81629: LD_VAR 0 14
81633: PUSH
81634: LD_INT 1
81636: ARRAY
81637: PUSH
81638: LD_VAR 0 14
81642: PPUSH
81643: LD_INT 21
81645: PUSH
81646: LD_INT 2
81648: PUSH
81649: EMPTY
81650: LIST
81651: LIST
81652: PUSH
81653: LD_INT 58
81655: PUSH
81656: EMPTY
81657: LIST
81658: PUSH
81659: EMPTY
81660: LIST
81661: LIST
81662: PPUSH
81663: CALL_OW 72
81667: IN
81668: AND
81669: IFFALSE 81705
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
81671: LD_VAR 0 4
81675: PUSH
81676: LD_VAR 0 7
81680: ARRAY
81681: PPUSH
81682: LD_VAR 0 14
81686: PUSH
81687: LD_INT 1
81689: ARRAY
81690: PPUSH
81691: CALL_OW 120
// attacking := true ;
81695: LD_ADDR_VAR 0 29
81699: PUSH
81700: LD_INT 1
81702: ST_TO_ADDR
// continue ;
81703: GO 79878
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
81705: LD_VAR 0 26
81709: PUSH
81710: LD_VAR 0 4
81714: PUSH
81715: LD_VAR 0 7
81719: ARRAY
81720: PPUSH
81721: CALL_OW 257
81725: PUSH
81726: LD_INT 1
81728: EQUAL
81729: AND
81730: PUSH
81731: LD_VAR 0 4
81735: PUSH
81736: LD_VAR 0 7
81740: ARRAY
81741: PPUSH
81742: CALL_OW 256
81746: PUSH
81747: LD_INT 800
81749: LESS
81750: AND
81751: PUSH
81752: LD_VAR 0 4
81756: PUSH
81757: LD_VAR 0 7
81761: ARRAY
81762: PPUSH
81763: CALL_OW 318
81767: NOT
81768: AND
81769: IFFALSE 81786
// ComCrawl ( group [ i ] ) ;
81771: LD_VAR 0 4
81775: PUSH
81776: LD_VAR 0 7
81780: ARRAY
81781: PPUSH
81782: CALL_OW 137
// if f_mines then
81786: LD_VAR 0 21
81790: IFFALSE 82033
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
81792: LD_VAR 0 14
81796: PUSH
81797: LD_INT 1
81799: ARRAY
81800: PPUSH
81801: CALL_OW 247
81805: PUSH
81806: LD_INT 3
81808: EQUAL
81809: PUSH
81810: LD_VAR 0 14
81814: PUSH
81815: LD_INT 1
81817: ARRAY
81818: PUSH
81819: LD_VAR 0 27
81823: IN
81824: NOT
81825: AND
81826: IFFALSE 82033
// begin x := GetX ( tmp [ 1 ] ) ;
81828: LD_ADDR_VAR 0 10
81832: PUSH
81833: LD_VAR 0 14
81837: PUSH
81838: LD_INT 1
81840: ARRAY
81841: PPUSH
81842: CALL_OW 250
81846: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
81847: LD_ADDR_VAR 0 11
81851: PUSH
81852: LD_VAR 0 14
81856: PUSH
81857: LD_INT 1
81859: ARRAY
81860: PPUSH
81861: CALL_OW 251
81865: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
81866: LD_ADDR_VAR 0 12
81870: PUSH
81871: LD_VAR 0 4
81875: PUSH
81876: LD_VAR 0 7
81880: ARRAY
81881: PPUSH
81882: CALL 42569 0 1
81886: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
81887: LD_VAR 0 4
81891: PUSH
81892: LD_VAR 0 7
81896: ARRAY
81897: PPUSH
81898: LD_VAR 0 10
81902: PPUSH
81903: LD_VAR 0 11
81907: PPUSH
81908: LD_VAR 0 14
81912: PUSH
81913: LD_INT 1
81915: ARRAY
81916: PPUSH
81917: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
81921: LD_VAR 0 4
81925: PUSH
81926: LD_VAR 0 7
81930: ARRAY
81931: PPUSH
81932: LD_VAR 0 10
81936: PPUSH
81937: LD_VAR 0 12
81941: PPUSH
81942: LD_INT 7
81944: PPUSH
81945: CALL_OW 272
81949: PPUSH
81950: LD_VAR 0 11
81954: PPUSH
81955: LD_VAR 0 12
81959: PPUSH
81960: LD_INT 7
81962: PPUSH
81963: CALL_OW 273
81967: PPUSH
81968: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
81972: LD_VAR 0 4
81976: PUSH
81977: LD_VAR 0 7
81981: ARRAY
81982: PPUSH
81983: LD_INT 71
81985: PPUSH
81986: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
81990: LD_ADDR_VAR 0 27
81994: PUSH
81995: LD_VAR 0 27
81999: PPUSH
82000: LD_VAR 0 27
82004: PUSH
82005: LD_INT 1
82007: PLUS
82008: PPUSH
82009: LD_VAR 0 14
82013: PUSH
82014: LD_INT 1
82016: ARRAY
82017: PPUSH
82018: CALL_OW 1
82022: ST_TO_ADDR
// attacking := true ;
82023: LD_ADDR_VAR 0 29
82027: PUSH
82028: LD_INT 1
82030: ST_TO_ADDR
// continue ;
82031: GO 79878
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
82033: LD_VAR 0 4
82037: PUSH
82038: LD_VAR 0 7
82042: ARRAY
82043: PPUSH
82044: CALL_OW 257
82048: PUSH
82049: LD_INT 17
82051: EQUAL
82052: PUSH
82053: LD_VAR 0 4
82057: PUSH
82058: LD_VAR 0 7
82062: ARRAY
82063: PPUSH
82064: CALL_OW 110
82068: PUSH
82069: LD_INT 71
82071: EQUAL
82072: NOT
82073: AND
82074: IFFALSE 82220
// begin attacking := false ;
82076: LD_ADDR_VAR 0 29
82080: PUSH
82081: LD_INT 0
82083: ST_TO_ADDR
// k := 5 ;
82084: LD_ADDR_VAR 0 9
82088: PUSH
82089: LD_INT 5
82091: ST_TO_ADDR
// if tmp < k then
82092: LD_VAR 0 14
82096: PUSH
82097: LD_VAR 0 9
82101: LESS
82102: IFFALSE 82114
// k := tmp ;
82104: LD_ADDR_VAR 0 9
82108: PUSH
82109: LD_VAR 0 14
82113: ST_TO_ADDR
// for j = 1 to k do
82114: LD_ADDR_VAR 0 8
82118: PUSH
82119: DOUBLE
82120: LD_INT 1
82122: DEC
82123: ST_TO_ADDR
82124: LD_VAR 0 9
82128: PUSH
82129: FOR_TO
82130: IFFALSE 82218
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
82132: LD_VAR 0 14
82136: PUSH
82137: LD_VAR 0 8
82141: ARRAY
82142: PUSH
82143: LD_VAR 0 14
82147: PPUSH
82148: LD_INT 58
82150: PUSH
82151: EMPTY
82152: LIST
82153: PPUSH
82154: CALL_OW 72
82158: IN
82159: NOT
82160: IFFALSE 82216
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
82162: LD_VAR 0 4
82166: PUSH
82167: LD_VAR 0 7
82171: ARRAY
82172: PPUSH
82173: LD_VAR 0 14
82177: PUSH
82178: LD_VAR 0 8
82182: ARRAY
82183: PPUSH
82184: CALL_OW 115
// attacking := true ;
82188: LD_ADDR_VAR 0 29
82192: PUSH
82193: LD_INT 1
82195: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
82196: LD_VAR 0 4
82200: PUSH
82201: LD_VAR 0 7
82205: ARRAY
82206: PPUSH
82207: LD_INT 71
82209: PPUSH
82210: CALL_OW 109
// continue ;
82214: GO 82129
// end ; end ;
82216: GO 82129
82218: POP
82219: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
82220: LD_VAR 0 4
82224: PUSH
82225: LD_VAR 0 7
82229: ARRAY
82230: PPUSH
82231: CALL_OW 257
82235: PUSH
82236: LD_INT 8
82238: EQUAL
82239: PUSH
82240: LD_VAR 0 4
82244: PUSH
82245: LD_VAR 0 7
82249: ARRAY
82250: PPUSH
82251: CALL_OW 264
82255: PUSH
82256: LD_INT 28
82258: PUSH
82259: LD_INT 45
82261: PUSH
82262: LD_INT 7
82264: PUSH
82265: LD_INT 47
82267: PUSH
82268: EMPTY
82269: LIST
82270: LIST
82271: LIST
82272: LIST
82273: IN
82274: OR
82275: IFFALSE 82531
// begin attacking := false ;
82277: LD_ADDR_VAR 0 29
82281: PUSH
82282: LD_INT 0
82284: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
82285: LD_VAR 0 14
82289: PUSH
82290: LD_INT 1
82292: ARRAY
82293: PPUSH
82294: CALL_OW 266
82298: PUSH
82299: LD_INT 32
82301: PUSH
82302: LD_INT 31
82304: PUSH
82305: LD_INT 33
82307: PUSH
82308: LD_INT 4
82310: PUSH
82311: LD_INT 5
82313: PUSH
82314: EMPTY
82315: LIST
82316: LIST
82317: LIST
82318: LIST
82319: LIST
82320: IN
82321: IFFALSE 82507
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
82323: LD_ADDR_VAR 0 9
82327: PUSH
82328: LD_VAR 0 14
82332: PUSH
82333: LD_INT 1
82335: ARRAY
82336: PPUSH
82337: CALL_OW 266
82341: PPUSH
82342: LD_VAR 0 14
82346: PUSH
82347: LD_INT 1
82349: ARRAY
82350: PPUSH
82351: CALL_OW 250
82355: PPUSH
82356: LD_VAR 0 14
82360: PUSH
82361: LD_INT 1
82363: ARRAY
82364: PPUSH
82365: CALL_OW 251
82369: PPUSH
82370: LD_VAR 0 14
82374: PUSH
82375: LD_INT 1
82377: ARRAY
82378: PPUSH
82379: CALL_OW 254
82383: PPUSH
82384: LD_VAR 0 14
82388: PUSH
82389: LD_INT 1
82391: ARRAY
82392: PPUSH
82393: CALL_OW 248
82397: PPUSH
82398: LD_INT 0
82400: PPUSH
82401: CALL 23939 0 6
82405: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
82406: LD_ADDR_VAR 0 8
82410: PUSH
82411: LD_VAR 0 4
82415: PUSH
82416: LD_VAR 0 7
82420: ARRAY
82421: PPUSH
82422: LD_VAR 0 9
82426: PPUSH
82427: CALL 42609 0 2
82431: ST_TO_ADDR
// if j then
82432: LD_VAR 0 8
82436: IFFALSE 82505
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
82438: LD_VAR 0 8
82442: PUSH
82443: LD_INT 1
82445: ARRAY
82446: PPUSH
82447: LD_VAR 0 8
82451: PUSH
82452: LD_INT 2
82454: ARRAY
82455: PPUSH
82456: CALL_OW 488
82460: IFFALSE 82505
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
82462: LD_VAR 0 4
82466: PUSH
82467: LD_VAR 0 7
82471: ARRAY
82472: PPUSH
82473: LD_VAR 0 8
82477: PUSH
82478: LD_INT 1
82480: ARRAY
82481: PPUSH
82482: LD_VAR 0 8
82486: PUSH
82487: LD_INT 2
82489: ARRAY
82490: PPUSH
82491: CALL_OW 116
// attacking := true ;
82495: LD_ADDR_VAR 0 29
82499: PUSH
82500: LD_INT 1
82502: ST_TO_ADDR
// continue ;
82503: GO 79878
// end ; end else
82505: GO 82531
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
82507: LD_VAR 0 4
82511: PUSH
82512: LD_VAR 0 7
82516: ARRAY
82517: PPUSH
82518: LD_VAR 0 14
82522: PUSH
82523: LD_INT 1
82525: ARRAY
82526: PPUSH
82527: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
82531: LD_VAR 0 4
82535: PUSH
82536: LD_VAR 0 7
82540: ARRAY
82541: PPUSH
82542: CALL_OW 265
82546: PUSH
82547: LD_INT 11
82549: EQUAL
82550: IFFALSE 82828
// begin k := 10 ;
82552: LD_ADDR_VAR 0 9
82556: PUSH
82557: LD_INT 10
82559: ST_TO_ADDR
// x := 0 ;
82560: LD_ADDR_VAR 0 10
82564: PUSH
82565: LD_INT 0
82567: ST_TO_ADDR
// if tmp < k then
82568: LD_VAR 0 14
82572: PUSH
82573: LD_VAR 0 9
82577: LESS
82578: IFFALSE 82590
// k := tmp ;
82580: LD_ADDR_VAR 0 9
82584: PUSH
82585: LD_VAR 0 14
82589: ST_TO_ADDR
// for j = k downto 1 do
82590: LD_ADDR_VAR 0 8
82594: PUSH
82595: DOUBLE
82596: LD_VAR 0 9
82600: INC
82601: ST_TO_ADDR
82602: LD_INT 1
82604: PUSH
82605: FOR_DOWNTO
82606: IFFALSE 82681
// begin if GetType ( tmp [ j ] ) = unit_human then
82608: LD_VAR 0 14
82612: PUSH
82613: LD_VAR 0 8
82617: ARRAY
82618: PPUSH
82619: CALL_OW 247
82623: PUSH
82624: LD_INT 1
82626: EQUAL
82627: IFFALSE 82679
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
82629: LD_VAR 0 4
82633: PUSH
82634: LD_VAR 0 7
82638: ARRAY
82639: PPUSH
82640: LD_VAR 0 14
82644: PUSH
82645: LD_VAR 0 8
82649: ARRAY
82650: PPUSH
82651: CALL 42880 0 2
// x := tmp [ j ] ;
82655: LD_ADDR_VAR 0 10
82659: PUSH
82660: LD_VAR 0 14
82664: PUSH
82665: LD_VAR 0 8
82669: ARRAY
82670: ST_TO_ADDR
// attacking := true ;
82671: LD_ADDR_VAR 0 29
82675: PUSH
82676: LD_INT 1
82678: ST_TO_ADDR
// end ; end ;
82679: GO 82605
82681: POP
82682: POP
// if not x then
82683: LD_VAR 0 10
82687: NOT
82688: IFFALSE 82828
// begin attacking := true ;
82690: LD_ADDR_VAR 0 29
82694: PUSH
82695: LD_INT 1
82697: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
82698: LD_VAR 0 4
82702: PUSH
82703: LD_VAR 0 7
82707: ARRAY
82708: PPUSH
82709: CALL_OW 250
82713: PPUSH
82714: LD_VAR 0 4
82718: PUSH
82719: LD_VAR 0 7
82723: ARRAY
82724: PPUSH
82725: CALL_OW 251
82729: PPUSH
82730: CALL_OW 546
82734: PUSH
82735: LD_INT 2
82737: ARRAY
82738: PUSH
82739: LD_VAR 0 14
82743: PUSH
82744: LD_INT 1
82746: ARRAY
82747: PPUSH
82748: CALL_OW 250
82752: PPUSH
82753: LD_VAR 0 14
82757: PUSH
82758: LD_INT 1
82760: ARRAY
82761: PPUSH
82762: CALL_OW 251
82766: PPUSH
82767: CALL_OW 546
82771: PUSH
82772: LD_INT 2
82774: ARRAY
82775: EQUAL
82776: IFFALSE 82804
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
82778: LD_VAR 0 4
82782: PUSH
82783: LD_VAR 0 7
82787: ARRAY
82788: PPUSH
82789: LD_VAR 0 14
82793: PUSH
82794: LD_INT 1
82796: ARRAY
82797: PPUSH
82798: CALL 42880 0 2
82802: GO 82828
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
82804: LD_VAR 0 4
82808: PUSH
82809: LD_VAR 0 7
82813: ARRAY
82814: PPUSH
82815: LD_VAR 0 14
82819: PUSH
82820: LD_INT 1
82822: ARRAY
82823: PPUSH
82824: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
82828: LD_VAR 0 4
82832: PUSH
82833: LD_VAR 0 7
82837: ARRAY
82838: PPUSH
82839: CALL_OW 264
82843: PUSH
82844: LD_INT 29
82846: EQUAL
82847: IFFALSE 83213
// begin if WantsToAttack ( group [ i ] ) in bombed then
82849: LD_VAR 0 4
82853: PUSH
82854: LD_VAR 0 7
82858: ARRAY
82859: PPUSH
82860: CALL_OW 319
82864: PUSH
82865: LD_VAR 0 28
82869: IN
82870: IFFALSE 82874
// continue ;
82872: GO 79878
// k := 8 ;
82874: LD_ADDR_VAR 0 9
82878: PUSH
82879: LD_INT 8
82881: ST_TO_ADDR
// x := 0 ;
82882: LD_ADDR_VAR 0 10
82886: PUSH
82887: LD_INT 0
82889: ST_TO_ADDR
// if tmp < k then
82890: LD_VAR 0 14
82894: PUSH
82895: LD_VAR 0 9
82899: LESS
82900: IFFALSE 82912
// k := tmp ;
82902: LD_ADDR_VAR 0 9
82906: PUSH
82907: LD_VAR 0 14
82911: ST_TO_ADDR
// for j = 1 to k do
82912: LD_ADDR_VAR 0 8
82916: PUSH
82917: DOUBLE
82918: LD_INT 1
82920: DEC
82921: ST_TO_ADDR
82922: LD_VAR 0 9
82926: PUSH
82927: FOR_TO
82928: IFFALSE 83060
// begin if GetType ( tmp [ j ] ) = unit_building then
82930: LD_VAR 0 14
82934: PUSH
82935: LD_VAR 0 8
82939: ARRAY
82940: PPUSH
82941: CALL_OW 247
82945: PUSH
82946: LD_INT 3
82948: EQUAL
82949: IFFALSE 83058
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
82951: LD_VAR 0 14
82955: PUSH
82956: LD_VAR 0 8
82960: ARRAY
82961: PUSH
82962: LD_VAR 0 28
82966: IN
82967: NOT
82968: PUSH
82969: LD_VAR 0 14
82973: PUSH
82974: LD_VAR 0 8
82978: ARRAY
82979: PPUSH
82980: CALL_OW 313
82984: AND
82985: IFFALSE 83058
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
82987: LD_VAR 0 4
82991: PUSH
82992: LD_VAR 0 7
82996: ARRAY
82997: PPUSH
82998: LD_VAR 0 14
83002: PUSH
83003: LD_VAR 0 8
83007: ARRAY
83008: PPUSH
83009: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
83013: LD_ADDR_VAR 0 28
83017: PUSH
83018: LD_VAR 0 28
83022: PPUSH
83023: LD_VAR 0 28
83027: PUSH
83028: LD_INT 1
83030: PLUS
83031: PPUSH
83032: LD_VAR 0 14
83036: PUSH
83037: LD_VAR 0 8
83041: ARRAY
83042: PPUSH
83043: CALL_OW 1
83047: ST_TO_ADDR
// attacking := true ;
83048: LD_ADDR_VAR 0 29
83052: PUSH
83053: LD_INT 1
83055: ST_TO_ADDR
// break ;
83056: GO 83060
// end ; end ;
83058: GO 82927
83060: POP
83061: POP
// if not attacking and f_attack_depot then
83062: LD_VAR 0 29
83066: NOT
83067: PUSH
83068: LD_VAR 0 25
83072: AND
83073: IFFALSE 83168
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
83075: LD_ADDR_VAR 0 13
83079: PUSH
83080: LD_VAR 0 14
83084: PPUSH
83085: LD_INT 2
83087: PUSH
83088: LD_INT 30
83090: PUSH
83091: LD_INT 0
83093: PUSH
83094: EMPTY
83095: LIST
83096: LIST
83097: PUSH
83098: LD_INT 30
83100: PUSH
83101: LD_INT 1
83103: PUSH
83104: EMPTY
83105: LIST
83106: LIST
83107: PUSH
83108: EMPTY
83109: LIST
83110: LIST
83111: LIST
83112: PPUSH
83113: CALL_OW 72
83117: ST_TO_ADDR
// if z then
83118: LD_VAR 0 13
83122: IFFALSE 83168
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
83124: LD_VAR 0 4
83128: PUSH
83129: LD_VAR 0 7
83133: ARRAY
83134: PPUSH
83135: LD_VAR 0 13
83139: PPUSH
83140: LD_VAR 0 4
83144: PUSH
83145: LD_VAR 0 7
83149: ARRAY
83150: PPUSH
83151: CALL_OW 74
83155: PPUSH
83156: CALL_OW 115
// attacking := true ;
83160: LD_ADDR_VAR 0 29
83164: PUSH
83165: LD_INT 1
83167: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
83168: LD_VAR 0 4
83172: PUSH
83173: LD_VAR 0 7
83177: ARRAY
83178: PPUSH
83179: CALL_OW 256
83183: PUSH
83184: LD_INT 500
83186: LESS
83187: IFFALSE 83213
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
83189: LD_VAR 0 4
83193: PUSH
83194: LD_VAR 0 7
83198: ARRAY
83199: PPUSH
83200: LD_VAR 0 14
83204: PUSH
83205: LD_INT 1
83207: ARRAY
83208: PPUSH
83209: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
83213: LD_VAR 0 4
83217: PUSH
83218: LD_VAR 0 7
83222: ARRAY
83223: PPUSH
83224: CALL_OW 264
83228: PUSH
83229: LD_INT 49
83231: EQUAL
83232: IFFALSE 83353
// begin if not HasTask ( group [ i ] ) then
83234: LD_VAR 0 4
83238: PUSH
83239: LD_VAR 0 7
83243: ARRAY
83244: PPUSH
83245: CALL_OW 314
83249: NOT
83250: IFFALSE 83353
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
83252: LD_ADDR_VAR 0 9
83256: PUSH
83257: LD_INT 81
83259: PUSH
83260: LD_VAR 0 4
83264: PUSH
83265: LD_VAR 0 7
83269: ARRAY
83270: PPUSH
83271: CALL_OW 255
83275: PUSH
83276: EMPTY
83277: LIST
83278: LIST
83279: PPUSH
83280: CALL_OW 69
83284: PPUSH
83285: LD_VAR 0 4
83289: PUSH
83290: LD_VAR 0 7
83294: ARRAY
83295: PPUSH
83296: CALL_OW 74
83300: ST_TO_ADDR
// if k then
83301: LD_VAR 0 9
83305: IFFALSE 83353
// if GetDistUnits ( group [ i ] , k ) > 10 then
83307: LD_VAR 0 4
83311: PUSH
83312: LD_VAR 0 7
83316: ARRAY
83317: PPUSH
83318: LD_VAR 0 9
83322: PPUSH
83323: CALL_OW 296
83327: PUSH
83328: LD_INT 10
83330: GREATER
83331: IFFALSE 83353
// ComMoveUnit ( group [ i ] , k ) ;
83333: LD_VAR 0 4
83337: PUSH
83338: LD_VAR 0 7
83342: ARRAY
83343: PPUSH
83344: LD_VAR 0 9
83348: PPUSH
83349: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
83353: LD_VAR 0 4
83357: PUSH
83358: LD_VAR 0 7
83362: ARRAY
83363: PPUSH
83364: CALL_OW 256
83368: PUSH
83369: LD_INT 250
83371: LESS
83372: PUSH
83373: LD_VAR 0 4
83377: PUSH
83378: LD_VAR 0 7
83382: ARRAY
83383: PUSH
83384: LD_INT 21
83386: PUSH
83387: LD_INT 2
83389: PUSH
83390: EMPTY
83391: LIST
83392: LIST
83393: PUSH
83394: LD_INT 23
83396: PUSH
83397: LD_INT 2
83399: PUSH
83400: EMPTY
83401: LIST
83402: LIST
83403: PUSH
83404: EMPTY
83405: LIST
83406: LIST
83407: PPUSH
83408: CALL_OW 69
83412: IN
83413: AND
83414: IFFALSE 83539
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
83416: LD_ADDR_VAR 0 9
83420: PUSH
83421: LD_OWVAR 3
83425: PUSH
83426: LD_VAR 0 4
83430: PUSH
83431: LD_VAR 0 7
83435: ARRAY
83436: DIFF
83437: PPUSH
83438: LD_VAR 0 4
83442: PUSH
83443: LD_VAR 0 7
83447: ARRAY
83448: PPUSH
83449: CALL_OW 74
83453: ST_TO_ADDR
// if not k then
83454: LD_VAR 0 9
83458: NOT
83459: IFFALSE 83463
// continue ;
83461: GO 79878
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
83463: LD_VAR 0 9
83467: PUSH
83468: LD_INT 81
83470: PUSH
83471: LD_VAR 0 4
83475: PUSH
83476: LD_VAR 0 7
83480: ARRAY
83481: PPUSH
83482: CALL_OW 255
83486: PUSH
83487: EMPTY
83488: LIST
83489: LIST
83490: PPUSH
83491: CALL_OW 69
83495: IN
83496: PUSH
83497: LD_VAR 0 9
83501: PPUSH
83502: LD_VAR 0 4
83506: PUSH
83507: LD_VAR 0 7
83511: ARRAY
83512: PPUSH
83513: CALL_OW 296
83517: PUSH
83518: LD_INT 5
83520: LESS
83521: AND
83522: IFFALSE 83539
// ComAutodestruct ( group [ i ] ) ;
83524: LD_VAR 0 4
83528: PUSH
83529: LD_VAR 0 7
83533: ARRAY
83534: PPUSH
83535: CALL 42778 0 1
// end ; if f_attack_depot then
83539: LD_VAR 0 25
83543: IFFALSE 83655
// begin k := 6 ;
83545: LD_ADDR_VAR 0 9
83549: PUSH
83550: LD_INT 6
83552: ST_TO_ADDR
// if tmp < k then
83553: LD_VAR 0 14
83557: PUSH
83558: LD_VAR 0 9
83562: LESS
83563: IFFALSE 83575
// k := tmp ;
83565: LD_ADDR_VAR 0 9
83569: PUSH
83570: LD_VAR 0 14
83574: ST_TO_ADDR
// for j = 1 to k do
83575: LD_ADDR_VAR 0 8
83579: PUSH
83580: DOUBLE
83581: LD_INT 1
83583: DEC
83584: ST_TO_ADDR
83585: LD_VAR 0 9
83589: PUSH
83590: FOR_TO
83591: IFFALSE 83653
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
83593: LD_VAR 0 8
83597: PPUSH
83598: CALL_OW 266
83602: PUSH
83603: LD_INT 0
83605: PUSH
83606: LD_INT 1
83608: PUSH
83609: EMPTY
83610: LIST
83611: LIST
83612: IN
83613: IFFALSE 83651
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
83615: LD_VAR 0 4
83619: PUSH
83620: LD_VAR 0 7
83624: ARRAY
83625: PPUSH
83626: LD_VAR 0 14
83630: PUSH
83631: LD_VAR 0 8
83635: ARRAY
83636: PPUSH
83637: CALL_OW 115
// attacking := true ;
83641: LD_ADDR_VAR 0 29
83645: PUSH
83646: LD_INT 1
83648: ST_TO_ADDR
// break ;
83649: GO 83653
// end ;
83651: GO 83590
83653: POP
83654: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
83655: LD_VAR 0 4
83659: PUSH
83660: LD_VAR 0 7
83664: ARRAY
83665: PPUSH
83666: CALL_OW 302
83670: PUSH
83671: LD_VAR 0 29
83675: NOT
83676: AND
83677: IFFALSE 83999
// begin if GetTag ( group [ i ] ) = 71 then
83679: LD_VAR 0 4
83683: PUSH
83684: LD_VAR 0 7
83688: ARRAY
83689: PPUSH
83690: CALL_OW 110
83694: PUSH
83695: LD_INT 71
83697: EQUAL
83698: IFFALSE 83739
// begin if HasTask ( group [ i ] ) then
83700: LD_VAR 0 4
83704: PUSH
83705: LD_VAR 0 7
83709: ARRAY
83710: PPUSH
83711: CALL_OW 314
83715: IFFALSE 83721
// continue else
83717: GO 79878
83719: GO 83739
// SetTag ( group [ i ] , 0 ) ;
83721: LD_VAR 0 4
83725: PUSH
83726: LD_VAR 0 7
83730: ARRAY
83731: PPUSH
83732: LD_INT 0
83734: PPUSH
83735: CALL_OW 109
// end ; k := 8 ;
83739: LD_ADDR_VAR 0 9
83743: PUSH
83744: LD_INT 8
83746: ST_TO_ADDR
// x := 0 ;
83747: LD_ADDR_VAR 0 10
83751: PUSH
83752: LD_INT 0
83754: ST_TO_ADDR
// if tmp < k then
83755: LD_VAR 0 14
83759: PUSH
83760: LD_VAR 0 9
83764: LESS
83765: IFFALSE 83777
// k := tmp ;
83767: LD_ADDR_VAR 0 9
83771: PUSH
83772: LD_VAR 0 14
83776: ST_TO_ADDR
// for j = 1 to k do
83777: LD_ADDR_VAR 0 8
83781: PUSH
83782: DOUBLE
83783: LD_INT 1
83785: DEC
83786: ST_TO_ADDR
83787: LD_VAR 0 9
83791: PUSH
83792: FOR_TO
83793: IFFALSE 83891
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
83795: LD_VAR 0 14
83799: PUSH
83800: LD_VAR 0 8
83804: ARRAY
83805: PPUSH
83806: CALL_OW 247
83810: PUSH
83811: LD_INT 1
83813: EQUAL
83814: PUSH
83815: LD_VAR 0 14
83819: PUSH
83820: LD_VAR 0 8
83824: ARRAY
83825: PPUSH
83826: CALL_OW 256
83830: PUSH
83831: LD_INT 250
83833: LESS
83834: PUSH
83835: LD_VAR 0 20
83839: AND
83840: PUSH
83841: LD_VAR 0 20
83845: NOT
83846: PUSH
83847: LD_VAR 0 14
83851: PUSH
83852: LD_VAR 0 8
83856: ARRAY
83857: PPUSH
83858: CALL_OW 256
83862: PUSH
83863: LD_INT 250
83865: GREATEREQUAL
83866: AND
83867: OR
83868: AND
83869: IFFALSE 83889
// begin x := tmp [ j ] ;
83871: LD_ADDR_VAR 0 10
83875: PUSH
83876: LD_VAR 0 14
83880: PUSH
83881: LD_VAR 0 8
83885: ARRAY
83886: ST_TO_ADDR
// break ;
83887: GO 83891
// end ;
83889: GO 83792
83891: POP
83892: POP
// if x then
83893: LD_VAR 0 10
83897: IFFALSE 83921
// ComAttackUnit ( group [ i ] , x ) else
83899: LD_VAR 0 4
83903: PUSH
83904: LD_VAR 0 7
83908: ARRAY
83909: PPUSH
83910: LD_VAR 0 10
83914: PPUSH
83915: CALL_OW 115
83919: GO 83945
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
83921: LD_VAR 0 4
83925: PUSH
83926: LD_VAR 0 7
83930: ARRAY
83931: PPUSH
83932: LD_VAR 0 14
83936: PUSH
83937: LD_INT 1
83939: ARRAY
83940: PPUSH
83941: CALL_OW 115
// if not HasTask ( group [ i ] ) then
83945: LD_VAR 0 4
83949: PUSH
83950: LD_VAR 0 7
83954: ARRAY
83955: PPUSH
83956: CALL_OW 314
83960: NOT
83961: IFFALSE 83999
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
83963: LD_VAR 0 4
83967: PUSH
83968: LD_VAR 0 7
83972: ARRAY
83973: PPUSH
83974: LD_VAR 0 14
83978: PPUSH
83979: LD_VAR 0 4
83983: PUSH
83984: LD_VAR 0 7
83988: ARRAY
83989: PPUSH
83990: CALL_OW 74
83994: PPUSH
83995: CALL_OW 115
// end ; end ; end ;
83999: GO 79878
84001: POP
84002: POP
// wait ( 0 0$2 ) ;
84003: LD_INT 70
84005: PPUSH
84006: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
84010: LD_VAR 0 4
84014: NOT
84015: PUSH
84016: LD_VAR 0 4
84020: PUSH
84021: EMPTY
84022: EQUAL
84023: OR
84024: PUSH
84025: LD_INT 81
84027: PUSH
84028: LD_VAR 0 35
84032: PUSH
84033: EMPTY
84034: LIST
84035: LIST
84036: PPUSH
84037: CALL_OW 69
84041: NOT
84042: OR
84043: IFFALSE 79863
// end ;
84045: LD_VAR 0 2
84049: RET
// export function BasicDefend ( base , solds ) ; var enemy , side , i , hex ; begin
84050: LD_INT 0
84052: PPUSH
84053: PPUSH
84054: PPUSH
84055: PPUSH
84056: PPUSH
// if not base or not mc_bases [ base ] or not solds then
84057: LD_VAR 0 1
84061: NOT
84062: PUSH
84063: LD_EXP 23
84067: PUSH
84068: LD_VAR 0 1
84072: ARRAY
84073: NOT
84074: OR
84075: PUSH
84076: LD_VAR 0 2
84080: NOT
84081: OR
84082: IFFALSE 84086
// exit ;
84084: GO 84615
// side := mc_sides [ base ] ;
84086: LD_ADDR_VAR 0 5
84090: PUSH
84091: LD_EXP 49
84095: PUSH
84096: LD_VAR 0 1
84100: ARRAY
84101: ST_TO_ADDR
// if not side then
84102: LD_VAR 0 5
84106: NOT
84107: IFFALSE 84111
// exit ;
84109: GO 84615
// for i in solds do
84111: LD_ADDR_VAR 0 6
84115: PUSH
84116: LD_VAR 0 2
84120: PUSH
84121: FOR_IN
84122: IFFALSE 84183
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
84124: LD_VAR 0 6
84128: PPUSH
84129: CALL_OW 310
84133: PPUSH
84134: CALL_OW 266
84138: PUSH
84139: LD_INT 32
84141: PUSH
84142: LD_INT 31
84144: PUSH
84145: EMPTY
84146: LIST
84147: LIST
84148: IN
84149: IFFALSE 84169
// solds := solds diff i else
84151: LD_ADDR_VAR 0 2
84155: PUSH
84156: LD_VAR 0 2
84160: PUSH
84161: LD_VAR 0 6
84165: DIFF
84166: ST_TO_ADDR
84167: GO 84181
// SetTag ( i , 18 ) ;
84169: LD_VAR 0 6
84173: PPUSH
84174: LD_INT 18
84176: PPUSH
84177: CALL_OW 109
84181: GO 84121
84183: POP
84184: POP
// if not solds then
84185: LD_VAR 0 2
84189: NOT
84190: IFFALSE 84194
// exit ;
84192: GO 84615
// repeat wait ( 0 0$2 ) ;
84194: LD_INT 70
84196: PPUSH
84197: CALL_OW 67
// enemy := mc_scan [ base ] ;
84201: LD_ADDR_VAR 0 4
84205: PUSH
84206: LD_EXP 46
84210: PUSH
84211: LD_VAR 0 1
84215: ARRAY
84216: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
84217: LD_EXP 23
84221: PUSH
84222: LD_VAR 0 1
84226: ARRAY
84227: NOT
84228: PUSH
84229: LD_EXP 23
84233: PUSH
84234: LD_VAR 0 1
84238: ARRAY
84239: PUSH
84240: EMPTY
84241: EQUAL
84242: OR
84243: IFFALSE 84280
// begin for i in solds do
84245: LD_ADDR_VAR 0 6
84249: PUSH
84250: LD_VAR 0 2
84254: PUSH
84255: FOR_IN
84256: IFFALSE 84269
// ComStop ( i ) ;
84258: LD_VAR 0 6
84262: PPUSH
84263: CALL_OW 141
84267: GO 84255
84269: POP
84270: POP
// solds := [ ] ;
84271: LD_ADDR_VAR 0 2
84275: PUSH
84276: EMPTY
84277: ST_TO_ADDR
// exit ;
84278: GO 84615
// end ; for i in solds do
84280: LD_ADDR_VAR 0 6
84284: PUSH
84285: LD_VAR 0 2
84289: PUSH
84290: FOR_IN
84291: IFFALSE 84587
// begin if IsInUnit ( i ) then
84293: LD_VAR 0 6
84297: PPUSH
84298: CALL_OW 310
84302: IFFALSE 84313
// ComExitBuilding ( i ) ;
84304: LD_VAR 0 6
84308: PPUSH
84309: CALL_OW 122
// if GetLives ( i ) > 333 then
84313: LD_VAR 0 6
84317: PPUSH
84318: CALL_OW 256
84322: PUSH
84323: LD_INT 333
84325: GREATER
84326: IFFALSE 84354
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
84328: LD_VAR 0 6
84332: PPUSH
84333: LD_VAR 0 4
84337: PPUSH
84338: LD_VAR 0 6
84342: PPUSH
84343: CALL_OW 74
84347: PPUSH
84348: CALL_OW 115
84352: GO 84585
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
84354: LD_VAR 0 6
84358: PPUSH
84359: LD_EXP 23
84363: PUSH
84364: LD_VAR 0 1
84368: ARRAY
84369: PPUSH
84370: LD_INT 2
84372: PUSH
84373: LD_INT 30
84375: PUSH
84376: LD_INT 0
84378: PUSH
84379: EMPTY
84380: LIST
84381: LIST
84382: PUSH
84383: LD_INT 30
84385: PUSH
84386: LD_INT 1
84388: PUSH
84389: EMPTY
84390: LIST
84391: LIST
84392: PUSH
84393: LD_INT 30
84395: PUSH
84396: LD_INT 6
84398: PUSH
84399: EMPTY
84400: LIST
84401: LIST
84402: PUSH
84403: EMPTY
84404: LIST
84405: LIST
84406: LIST
84407: LIST
84408: PPUSH
84409: CALL_OW 72
84413: PPUSH
84414: LD_VAR 0 6
84418: PPUSH
84419: CALL_OW 74
84423: PPUSH
84424: CALL_OW 296
84428: PUSH
84429: LD_INT 10
84431: GREATER
84432: IFFALSE 84585
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
84434: LD_ADDR_VAR 0 7
84438: PUSH
84439: LD_EXP 23
84443: PUSH
84444: LD_VAR 0 1
84448: ARRAY
84449: PPUSH
84450: LD_INT 2
84452: PUSH
84453: LD_INT 30
84455: PUSH
84456: LD_INT 0
84458: PUSH
84459: EMPTY
84460: LIST
84461: LIST
84462: PUSH
84463: LD_INT 30
84465: PUSH
84466: LD_INT 1
84468: PUSH
84469: EMPTY
84470: LIST
84471: LIST
84472: PUSH
84473: LD_INT 30
84475: PUSH
84476: LD_INT 6
84478: PUSH
84479: EMPTY
84480: LIST
84481: LIST
84482: PUSH
84483: EMPTY
84484: LIST
84485: LIST
84486: LIST
84487: LIST
84488: PPUSH
84489: CALL_OW 72
84493: PPUSH
84494: LD_VAR 0 6
84498: PPUSH
84499: CALL_OW 74
84503: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
84504: LD_VAR 0 6
84508: PPUSH
84509: LD_VAR 0 7
84513: PPUSH
84514: CALL_OW 250
84518: PPUSH
84519: LD_INT 3
84521: PPUSH
84522: LD_INT 5
84524: PPUSH
84525: CALL_OW 272
84529: PPUSH
84530: LD_VAR 0 7
84534: PPUSH
84535: CALL_OW 251
84539: PPUSH
84540: LD_INT 3
84542: PPUSH
84543: LD_INT 5
84545: PPUSH
84546: CALL_OW 273
84550: PPUSH
84551: CALL_OW 111
// SetTag ( i , 0 ) ;
84555: LD_VAR 0 6
84559: PPUSH
84560: LD_INT 0
84562: PPUSH
84563: CALL_OW 109
// solds := solds diff i ;
84567: LD_ADDR_VAR 0 2
84571: PUSH
84572: LD_VAR 0 2
84576: PUSH
84577: LD_VAR 0 6
84581: DIFF
84582: ST_TO_ADDR
// continue ;
84583: GO 84290
// end ; end ;
84585: GO 84290
84587: POP
84588: POP
// until not solds or not enemy ;
84589: LD_VAR 0 2
84593: NOT
84594: PUSH
84595: LD_VAR 0 4
84599: NOT
84600: OR
84601: IFFALSE 84194
// MC_Reset ( base , 18 ) ;
84603: LD_VAR 0 1
84607: PPUSH
84608: LD_INT 18
84610: PPUSH
84611: CALL 52906 0 2
// end ;
84615: LD_VAR 0 3
84619: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
84620: LD_INT 0
84622: PPUSH
84623: PPUSH
84624: PPUSH
84625: PPUSH
84626: PPUSH
84627: PPUSH
84628: PPUSH
84629: PPUSH
84630: PPUSH
84631: PPUSH
84632: PPUSH
84633: PPUSH
84634: PPUSH
84635: PPUSH
84636: PPUSH
84637: PPUSH
84638: PPUSH
84639: PPUSH
84640: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
84641: LD_ADDR_VAR 0 12
84645: PUSH
84646: LD_EXP 23
84650: PUSH
84651: LD_VAR 0 1
84655: ARRAY
84656: PPUSH
84657: LD_INT 25
84659: PUSH
84660: LD_INT 3
84662: PUSH
84663: EMPTY
84664: LIST
84665: LIST
84666: PPUSH
84667: CALL_OW 72
84671: ST_TO_ADDR
// if mc_remote_driver [ base ] then
84672: LD_EXP 63
84676: PUSH
84677: LD_VAR 0 1
84681: ARRAY
84682: IFFALSE 84706
// mechs := mechs diff mc_remote_driver [ base ] ;
84684: LD_ADDR_VAR 0 12
84688: PUSH
84689: LD_VAR 0 12
84693: PUSH
84694: LD_EXP 63
84698: PUSH
84699: LD_VAR 0 1
84703: ARRAY
84704: DIFF
84705: ST_TO_ADDR
// for i in mechs do
84706: LD_ADDR_VAR 0 4
84710: PUSH
84711: LD_VAR 0 12
84715: PUSH
84716: FOR_IN
84717: IFFALSE 84752
// if GetTag ( i ) > 0 then
84719: LD_VAR 0 4
84723: PPUSH
84724: CALL_OW 110
84728: PUSH
84729: LD_INT 0
84731: GREATER
84732: IFFALSE 84750
// mechs := mechs diff i ;
84734: LD_ADDR_VAR 0 12
84738: PUSH
84739: LD_VAR 0 12
84743: PUSH
84744: LD_VAR 0 4
84748: DIFF
84749: ST_TO_ADDR
84750: GO 84716
84752: POP
84753: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
84754: LD_ADDR_VAR 0 8
84758: PUSH
84759: LD_EXP 23
84763: PUSH
84764: LD_VAR 0 1
84768: ARRAY
84769: PPUSH
84770: LD_INT 2
84772: PUSH
84773: LD_INT 25
84775: PUSH
84776: LD_INT 1
84778: PUSH
84779: EMPTY
84780: LIST
84781: LIST
84782: PUSH
84783: LD_INT 25
84785: PUSH
84786: LD_INT 5
84788: PUSH
84789: EMPTY
84790: LIST
84791: LIST
84792: PUSH
84793: LD_INT 25
84795: PUSH
84796: LD_INT 8
84798: PUSH
84799: EMPTY
84800: LIST
84801: LIST
84802: PUSH
84803: LD_INT 25
84805: PUSH
84806: LD_INT 9
84808: PUSH
84809: EMPTY
84810: LIST
84811: LIST
84812: PUSH
84813: EMPTY
84814: LIST
84815: LIST
84816: LIST
84817: LIST
84818: LIST
84819: PPUSH
84820: CALL_OW 72
84824: ST_TO_ADDR
// if not defenders and not solds then
84825: LD_VAR 0 2
84829: NOT
84830: PUSH
84831: LD_VAR 0 8
84835: NOT
84836: AND
84837: IFFALSE 84841
// exit ;
84839: GO 86611
// depot_under_attack := false ;
84841: LD_ADDR_VAR 0 16
84845: PUSH
84846: LD_INT 0
84848: ST_TO_ADDR
// sold_defenders := [ ] ;
84849: LD_ADDR_VAR 0 17
84853: PUSH
84854: EMPTY
84855: ST_TO_ADDR
// if mechs then
84856: LD_VAR 0 12
84860: IFFALSE 85013
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
84862: LD_ADDR_VAR 0 4
84866: PUSH
84867: LD_VAR 0 2
84871: PPUSH
84872: LD_INT 21
84874: PUSH
84875: LD_INT 2
84877: PUSH
84878: EMPTY
84879: LIST
84880: LIST
84881: PPUSH
84882: CALL_OW 72
84886: PUSH
84887: FOR_IN
84888: IFFALSE 85011
// begin if GetTag ( i ) <> 20 then
84890: LD_VAR 0 4
84894: PPUSH
84895: CALL_OW 110
84899: PUSH
84900: LD_INT 20
84902: NONEQUAL
84903: IFFALSE 84917
// SetTag ( i , 20 ) ;
84905: LD_VAR 0 4
84909: PPUSH
84910: LD_INT 20
84912: PPUSH
84913: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
84917: LD_VAR 0 4
84921: PPUSH
84922: CALL_OW 263
84926: PUSH
84927: LD_INT 1
84929: EQUAL
84930: PUSH
84931: LD_VAR 0 4
84935: PPUSH
84936: CALL_OW 311
84940: NOT
84941: AND
84942: IFFALSE 85009
// begin un := mechs [ 1 ] ;
84944: LD_ADDR_VAR 0 10
84948: PUSH
84949: LD_VAR 0 12
84953: PUSH
84954: LD_INT 1
84956: ARRAY
84957: ST_TO_ADDR
// ComExit ( un ) ;
84958: LD_VAR 0 10
84962: PPUSH
84963: CALL 47123 0 1
// AddComEnterUnit ( un , i ) ;
84967: LD_VAR 0 10
84971: PPUSH
84972: LD_VAR 0 4
84976: PPUSH
84977: CALL_OW 180
// SetTag ( un , 19 ) ;
84981: LD_VAR 0 10
84985: PPUSH
84986: LD_INT 19
84988: PPUSH
84989: CALL_OW 109
// mechs := mechs diff un ;
84993: LD_ADDR_VAR 0 12
84997: PUSH
84998: LD_VAR 0 12
85002: PUSH
85003: LD_VAR 0 10
85007: DIFF
85008: ST_TO_ADDR
// end ; end ;
85009: GO 84887
85011: POP
85012: POP
// if solds then
85013: LD_VAR 0 8
85017: IFFALSE 85076
// for i in solds do
85019: LD_ADDR_VAR 0 4
85023: PUSH
85024: LD_VAR 0 8
85028: PUSH
85029: FOR_IN
85030: IFFALSE 85074
// if not GetTag ( i ) then
85032: LD_VAR 0 4
85036: PPUSH
85037: CALL_OW 110
85041: NOT
85042: IFFALSE 85072
// begin defenders := defenders union i ;
85044: LD_ADDR_VAR 0 2
85048: PUSH
85049: LD_VAR 0 2
85053: PUSH
85054: LD_VAR 0 4
85058: UNION
85059: ST_TO_ADDR
// SetTag ( i , 18 ) ;
85060: LD_VAR 0 4
85064: PPUSH
85065: LD_INT 18
85067: PPUSH
85068: CALL_OW 109
// end ;
85072: GO 85029
85074: POP
85075: POP
// repeat wait ( 0 0$2 ) ;
85076: LD_INT 70
85078: PPUSH
85079: CALL_OW 67
// enemy := mc_scan [ base ] ;
85083: LD_ADDR_VAR 0 21
85087: PUSH
85088: LD_EXP 46
85092: PUSH
85093: LD_VAR 0 1
85097: ARRAY
85098: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
85099: LD_EXP 23
85103: PUSH
85104: LD_VAR 0 1
85108: ARRAY
85109: NOT
85110: PUSH
85111: LD_EXP 23
85115: PUSH
85116: LD_VAR 0 1
85120: ARRAY
85121: PUSH
85122: EMPTY
85123: EQUAL
85124: OR
85125: IFFALSE 85162
// begin for i in defenders do
85127: LD_ADDR_VAR 0 4
85131: PUSH
85132: LD_VAR 0 2
85136: PUSH
85137: FOR_IN
85138: IFFALSE 85151
// ComStop ( i ) ;
85140: LD_VAR 0 4
85144: PPUSH
85145: CALL_OW 141
85149: GO 85137
85151: POP
85152: POP
// defenders := [ ] ;
85153: LD_ADDR_VAR 0 2
85157: PUSH
85158: EMPTY
85159: ST_TO_ADDR
// exit ;
85160: GO 86611
// end ; for i in defenders do
85162: LD_ADDR_VAR 0 4
85166: PUSH
85167: LD_VAR 0 2
85171: PUSH
85172: FOR_IN
85173: IFFALSE 86071
// begin e := NearestUnitToUnit ( enemy , i ) ;
85175: LD_ADDR_VAR 0 13
85179: PUSH
85180: LD_VAR 0 21
85184: PPUSH
85185: LD_VAR 0 4
85189: PPUSH
85190: CALL_OW 74
85194: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
85195: LD_ADDR_VAR 0 7
85199: PUSH
85200: LD_EXP 23
85204: PUSH
85205: LD_VAR 0 1
85209: ARRAY
85210: PPUSH
85211: LD_INT 2
85213: PUSH
85214: LD_INT 30
85216: PUSH
85217: LD_INT 0
85219: PUSH
85220: EMPTY
85221: LIST
85222: LIST
85223: PUSH
85224: LD_INT 30
85226: PUSH
85227: LD_INT 1
85229: PUSH
85230: EMPTY
85231: LIST
85232: LIST
85233: PUSH
85234: EMPTY
85235: LIST
85236: LIST
85237: LIST
85238: PPUSH
85239: CALL_OW 72
85243: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
85244: LD_ADDR_VAR 0 16
85248: PUSH
85249: LD_VAR 0 7
85253: NOT
85254: PUSH
85255: LD_VAR 0 7
85259: PPUSH
85260: LD_INT 3
85262: PUSH
85263: LD_INT 24
85265: PUSH
85266: LD_INT 600
85268: PUSH
85269: EMPTY
85270: LIST
85271: LIST
85272: PUSH
85273: EMPTY
85274: LIST
85275: LIST
85276: PPUSH
85277: CALL_OW 72
85281: OR
85282: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
85283: LD_VAR 0 4
85287: PPUSH
85288: CALL_OW 247
85292: PUSH
85293: LD_INT 2
85295: DOUBLE
85296: EQUAL
85297: IFTRUE 85301
85299: GO 85697
85301: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
85302: LD_VAR 0 4
85306: PPUSH
85307: CALL_OW 256
85311: PUSH
85312: LD_INT 1000
85314: EQUAL
85315: PUSH
85316: LD_VAR 0 4
85320: PPUSH
85321: LD_VAR 0 13
85325: PPUSH
85326: CALL_OW 296
85330: PUSH
85331: LD_INT 40
85333: LESS
85334: PUSH
85335: LD_VAR 0 13
85339: PPUSH
85340: LD_EXP 48
85344: PUSH
85345: LD_VAR 0 1
85349: ARRAY
85350: PPUSH
85351: CALL_OW 308
85355: OR
85356: AND
85357: IFFALSE 85479
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
85359: LD_VAR 0 4
85363: PPUSH
85364: CALL_OW 262
85368: PUSH
85369: LD_INT 1
85371: EQUAL
85372: PUSH
85373: LD_VAR 0 4
85377: PPUSH
85378: CALL_OW 261
85382: PUSH
85383: LD_INT 30
85385: LESS
85386: AND
85387: PUSH
85388: LD_VAR 0 7
85392: AND
85393: IFFALSE 85463
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
85395: LD_VAR 0 4
85399: PPUSH
85400: LD_VAR 0 7
85404: PPUSH
85405: LD_VAR 0 4
85409: PPUSH
85410: CALL_OW 74
85414: PPUSH
85415: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
85419: LD_VAR 0 4
85423: PPUSH
85424: LD_VAR 0 7
85428: PPUSH
85429: LD_VAR 0 4
85433: PPUSH
85434: CALL_OW 74
85438: PPUSH
85439: CALL_OW 296
85443: PUSH
85444: LD_INT 6
85446: LESS
85447: IFFALSE 85461
// SetFuel ( i , 100 ) ;
85449: LD_VAR 0 4
85453: PPUSH
85454: LD_INT 100
85456: PPUSH
85457: CALL_OW 240
// end else
85461: GO 85477
// ComAttackUnit ( i , e ) ;
85463: LD_VAR 0 4
85467: PPUSH
85468: LD_VAR 0 13
85472: PPUSH
85473: CALL_OW 115
// end else
85477: GO 85580
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
85479: LD_VAR 0 13
85483: PPUSH
85484: LD_EXP 48
85488: PUSH
85489: LD_VAR 0 1
85493: ARRAY
85494: PPUSH
85495: CALL_OW 308
85499: NOT
85500: PUSH
85501: LD_VAR 0 4
85505: PPUSH
85506: LD_VAR 0 13
85510: PPUSH
85511: CALL_OW 296
85515: PUSH
85516: LD_INT 40
85518: GREATEREQUAL
85519: AND
85520: PUSH
85521: LD_VAR 0 4
85525: PPUSH
85526: CALL_OW 256
85530: PUSH
85531: LD_INT 650
85533: LESSEQUAL
85534: OR
85535: PUSH
85536: LD_VAR 0 4
85540: PPUSH
85541: LD_EXP 47
85545: PUSH
85546: LD_VAR 0 1
85550: ARRAY
85551: PPUSH
85552: CALL_OW 308
85556: NOT
85557: AND
85558: IFFALSE 85580
// ComMoveToArea ( i , mc_parking [ base ] ) ;
85560: LD_VAR 0 4
85564: PPUSH
85565: LD_EXP 47
85569: PUSH
85570: LD_VAR 0 1
85574: ARRAY
85575: PPUSH
85576: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
85580: LD_VAR 0 4
85584: PPUSH
85585: CALL_OW 256
85589: PUSH
85590: LD_INT 1000
85592: LESS
85593: PUSH
85594: LD_VAR 0 4
85598: PPUSH
85599: CALL_OW 263
85603: PUSH
85604: LD_INT 1
85606: EQUAL
85607: AND
85608: PUSH
85609: LD_VAR 0 4
85613: PPUSH
85614: CALL_OW 311
85618: AND
85619: PUSH
85620: LD_VAR 0 4
85624: PPUSH
85625: LD_EXP 47
85629: PUSH
85630: LD_VAR 0 1
85634: ARRAY
85635: PPUSH
85636: CALL_OW 308
85640: AND
85641: IFFALSE 85695
// begin mech := IsDrivenBy ( i ) ;
85643: LD_ADDR_VAR 0 9
85647: PUSH
85648: LD_VAR 0 4
85652: PPUSH
85653: CALL_OW 311
85657: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
85658: LD_VAR 0 9
85662: PPUSH
85663: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
85667: LD_VAR 0 9
85671: PPUSH
85672: LD_VAR 0 4
85676: PPUSH
85677: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
85681: LD_VAR 0 9
85685: PPUSH
85686: LD_VAR 0 4
85690: PPUSH
85691: CALL_OW 180
// end ; end ; unit_human :
85695: GO 86042
85697: LD_INT 1
85699: DOUBLE
85700: EQUAL
85701: IFTRUE 85705
85703: GO 86041
85705: POP
// begin b := IsInUnit ( i ) ;
85706: LD_ADDR_VAR 0 18
85710: PUSH
85711: LD_VAR 0 4
85715: PPUSH
85716: CALL_OW 310
85720: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
85721: LD_ADDR_VAR 0 19
85725: PUSH
85726: LD_VAR 0 18
85730: NOT
85731: PUSH
85732: LD_VAR 0 18
85736: PPUSH
85737: CALL_OW 266
85741: PUSH
85742: LD_INT 32
85744: PUSH
85745: LD_INT 31
85747: PUSH
85748: EMPTY
85749: LIST
85750: LIST
85751: IN
85752: OR
85753: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
85754: LD_VAR 0 18
85758: PPUSH
85759: CALL_OW 266
85763: PUSH
85764: LD_INT 5
85766: EQUAL
85767: PUSH
85768: LD_VAR 0 4
85772: PPUSH
85773: CALL_OW 257
85777: PUSH
85778: LD_INT 1
85780: PUSH
85781: LD_INT 2
85783: PUSH
85784: LD_INT 3
85786: PUSH
85787: LD_INT 4
85789: PUSH
85790: EMPTY
85791: LIST
85792: LIST
85793: LIST
85794: LIST
85795: IN
85796: AND
85797: IFFALSE 85834
// begin class := AllowSpecClass ( i ) ;
85799: LD_ADDR_VAR 0 20
85803: PUSH
85804: LD_VAR 0 4
85808: PPUSH
85809: CALL 11783 0 1
85813: ST_TO_ADDR
// if class then
85814: LD_VAR 0 20
85818: IFFALSE 85834
// ComChangeProfession ( i , class ) ;
85820: LD_VAR 0 4
85824: PPUSH
85825: LD_VAR 0 20
85829: PPUSH
85830: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
85834: LD_VAR 0 16
85838: PUSH
85839: LD_VAR 0 2
85843: PPUSH
85844: LD_INT 21
85846: PUSH
85847: LD_INT 2
85849: PUSH
85850: EMPTY
85851: LIST
85852: LIST
85853: PPUSH
85854: CALL_OW 72
85858: PUSH
85859: LD_INT 1
85861: LESSEQUAL
85862: OR
85863: PUSH
85864: LD_VAR 0 19
85868: AND
85869: PUSH
85870: LD_VAR 0 4
85874: PUSH
85875: LD_VAR 0 17
85879: IN
85880: NOT
85881: AND
85882: IFFALSE 85975
// begin if b then
85884: LD_VAR 0 18
85888: IFFALSE 85937
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
85890: LD_VAR 0 18
85894: PPUSH
85895: LD_VAR 0 21
85899: PPUSH
85900: LD_VAR 0 18
85904: PPUSH
85905: CALL_OW 74
85909: PPUSH
85910: CALL_OW 296
85914: PUSH
85915: LD_INT 10
85917: LESS
85918: PUSH
85919: LD_VAR 0 18
85923: PPUSH
85924: CALL_OW 461
85928: PUSH
85929: LD_INT 7
85931: NONEQUAL
85932: AND
85933: IFFALSE 85937
// continue ;
85935: GO 85172
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
85937: LD_ADDR_VAR 0 17
85941: PUSH
85942: LD_VAR 0 17
85946: PPUSH
85947: LD_VAR 0 17
85951: PUSH
85952: LD_INT 1
85954: PLUS
85955: PPUSH
85956: LD_VAR 0 4
85960: PPUSH
85961: CALL_OW 1
85965: ST_TO_ADDR
// ComExitBuilding ( i ) ;
85966: LD_VAR 0 4
85970: PPUSH
85971: CALL_OW 122
// end ; if sold_defenders then
85975: LD_VAR 0 17
85979: IFFALSE 86039
// if i in sold_defenders then
85981: LD_VAR 0 4
85985: PUSH
85986: LD_VAR 0 17
85990: IN
85991: IFFALSE 86039
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
85993: LD_VAR 0 4
85997: PPUSH
85998: CALL_OW 314
86002: NOT
86003: PUSH
86004: LD_VAR 0 4
86008: PPUSH
86009: LD_VAR 0 13
86013: PPUSH
86014: CALL_OW 296
86018: PUSH
86019: LD_INT 30
86021: LESS
86022: AND
86023: IFFALSE 86039
// ComAttackUnit ( i , e ) ;
86025: LD_VAR 0 4
86029: PPUSH
86030: LD_VAR 0 13
86034: PPUSH
86035: CALL_OW 115
// end ; end ; end ;
86039: GO 86042
86041: POP
// if IsDead ( i ) then
86042: LD_VAR 0 4
86046: PPUSH
86047: CALL_OW 301
86051: IFFALSE 86069
// defenders := defenders diff i ;
86053: LD_ADDR_VAR 0 2
86057: PUSH
86058: LD_VAR 0 2
86062: PUSH
86063: LD_VAR 0 4
86067: DIFF
86068: ST_TO_ADDR
// end ;
86069: GO 85172
86071: POP
86072: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
86073: LD_VAR 0 21
86077: NOT
86078: PUSH
86079: LD_VAR 0 2
86083: NOT
86084: OR
86085: PUSH
86086: LD_EXP 23
86090: PUSH
86091: LD_VAR 0 1
86095: ARRAY
86096: NOT
86097: OR
86098: IFFALSE 85076
// MC_Reset ( base , 18 ) ;
86100: LD_VAR 0 1
86104: PPUSH
86105: LD_INT 18
86107: PPUSH
86108: CALL 52906 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
86112: LD_ADDR_VAR 0 2
86116: PUSH
86117: LD_VAR 0 2
86121: PUSH
86122: LD_VAR 0 2
86126: PPUSH
86127: LD_INT 2
86129: PUSH
86130: LD_INT 25
86132: PUSH
86133: LD_INT 1
86135: PUSH
86136: EMPTY
86137: LIST
86138: LIST
86139: PUSH
86140: LD_INT 25
86142: PUSH
86143: LD_INT 5
86145: PUSH
86146: EMPTY
86147: LIST
86148: LIST
86149: PUSH
86150: LD_INT 25
86152: PUSH
86153: LD_INT 8
86155: PUSH
86156: EMPTY
86157: LIST
86158: LIST
86159: PUSH
86160: LD_INT 25
86162: PUSH
86163: LD_INT 9
86165: PUSH
86166: EMPTY
86167: LIST
86168: LIST
86169: PUSH
86170: EMPTY
86171: LIST
86172: LIST
86173: LIST
86174: LIST
86175: LIST
86176: PPUSH
86177: CALL_OW 72
86181: DIFF
86182: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
86183: LD_VAR 0 21
86187: NOT
86188: PUSH
86189: LD_VAR 0 2
86193: PPUSH
86194: LD_INT 21
86196: PUSH
86197: LD_INT 2
86199: PUSH
86200: EMPTY
86201: LIST
86202: LIST
86203: PPUSH
86204: CALL_OW 72
86208: AND
86209: IFFALSE 86547
// begin tmp := FilterByTag ( defenders , 19 ) ;
86211: LD_ADDR_VAR 0 11
86215: PUSH
86216: LD_VAR 0 2
86220: PPUSH
86221: LD_INT 19
86223: PPUSH
86224: CALL 44253 0 2
86228: ST_TO_ADDR
// if tmp then
86229: LD_VAR 0 11
86233: IFFALSE 86303
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
86235: LD_ADDR_VAR 0 11
86239: PUSH
86240: LD_VAR 0 11
86244: PPUSH
86245: LD_INT 25
86247: PUSH
86248: LD_INT 3
86250: PUSH
86251: EMPTY
86252: LIST
86253: LIST
86254: PPUSH
86255: CALL_OW 72
86259: ST_TO_ADDR
// if tmp then
86260: LD_VAR 0 11
86264: IFFALSE 86303
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
86266: LD_ADDR_EXP 35
86270: PUSH
86271: LD_EXP 35
86275: PPUSH
86276: LD_VAR 0 1
86280: PPUSH
86281: LD_EXP 35
86285: PUSH
86286: LD_VAR 0 1
86290: ARRAY
86291: PUSH
86292: LD_VAR 0 11
86296: UNION
86297: PPUSH
86298: CALL_OW 1
86302: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
86303: LD_VAR 0 1
86307: PPUSH
86308: LD_INT 19
86310: PPUSH
86311: CALL 52906 0 2
// repeat wait ( 0 0$1 ) ;
86315: LD_INT 35
86317: PPUSH
86318: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
86322: LD_EXP 23
86326: PUSH
86327: LD_VAR 0 1
86331: ARRAY
86332: NOT
86333: PUSH
86334: LD_EXP 23
86338: PUSH
86339: LD_VAR 0 1
86343: ARRAY
86344: PUSH
86345: EMPTY
86346: EQUAL
86347: OR
86348: IFFALSE 86385
// begin for i in defenders do
86350: LD_ADDR_VAR 0 4
86354: PUSH
86355: LD_VAR 0 2
86359: PUSH
86360: FOR_IN
86361: IFFALSE 86374
// ComStop ( i ) ;
86363: LD_VAR 0 4
86367: PPUSH
86368: CALL_OW 141
86372: GO 86360
86374: POP
86375: POP
// defenders := [ ] ;
86376: LD_ADDR_VAR 0 2
86380: PUSH
86381: EMPTY
86382: ST_TO_ADDR
// exit ;
86383: GO 86611
// end ; for i in defenders do
86385: LD_ADDR_VAR 0 4
86389: PUSH
86390: LD_VAR 0 2
86394: PUSH
86395: FOR_IN
86396: IFFALSE 86485
// begin if not IsInArea ( i , mc_parking [ base ] ) then
86398: LD_VAR 0 4
86402: PPUSH
86403: LD_EXP 47
86407: PUSH
86408: LD_VAR 0 1
86412: ARRAY
86413: PPUSH
86414: CALL_OW 308
86418: NOT
86419: IFFALSE 86443
// ComMoveToArea ( i , mc_parking [ base ] ) else
86421: LD_VAR 0 4
86425: PPUSH
86426: LD_EXP 47
86430: PUSH
86431: LD_VAR 0 1
86435: ARRAY
86436: PPUSH
86437: CALL_OW 113
86441: GO 86483
// if GetControl ( i ) = control_manual then
86443: LD_VAR 0 4
86447: PPUSH
86448: CALL_OW 263
86452: PUSH
86453: LD_INT 1
86455: EQUAL
86456: IFFALSE 86483
// if IsDrivenBy ( i ) then
86458: LD_VAR 0 4
86462: PPUSH
86463: CALL_OW 311
86467: IFFALSE 86483
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
86469: LD_VAR 0 4
86473: PPUSH
86474: CALL_OW 311
86478: PPUSH
86479: CALL_OW 121
// end ;
86483: GO 86395
86485: POP
86486: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
86487: LD_VAR 0 2
86491: PPUSH
86492: LD_INT 95
86494: PUSH
86495: LD_EXP 47
86499: PUSH
86500: LD_VAR 0 1
86504: ARRAY
86505: PUSH
86506: EMPTY
86507: LIST
86508: LIST
86509: PPUSH
86510: CALL_OW 72
86514: PUSH
86515: LD_VAR 0 2
86519: EQUAL
86520: PUSH
86521: LD_EXP 46
86525: PUSH
86526: LD_VAR 0 1
86530: ARRAY
86531: OR
86532: PUSH
86533: LD_EXP 23
86537: PUSH
86538: LD_VAR 0 1
86542: ARRAY
86543: NOT
86544: OR
86545: IFFALSE 86315
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
86547: LD_ADDR_EXP 45
86551: PUSH
86552: LD_EXP 45
86556: PPUSH
86557: LD_VAR 0 1
86561: PPUSH
86562: LD_VAR 0 2
86566: PPUSH
86567: LD_INT 21
86569: PUSH
86570: LD_INT 2
86572: PUSH
86573: EMPTY
86574: LIST
86575: LIST
86576: PPUSH
86577: CALL_OW 72
86581: PPUSH
86582: CALL_OW 1
86586: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
86587: LD_VAR 0 1
86591: PPUSH
86592: LD_INT 19
86594: PPUSH
86595: CALL 52906 0 2
// MC_Reset ( base , 20 ) ;
86599: LD_VAR 0 1
86603: PPUSH
86604: LD_INT 20
86606: PPUSH
86607: CALL 52906 0 2
// end ; end_of_file
86611: LD_VAR 0 3
86615: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
86616: LD_INT 0
86618: PPUSH
86619: PPUSH
86620: PPUSH
86621: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
86622: LD_VAR 0 1
86626: PPUSH
86627: CALL_OW 264
86631: PUSH
86632: LD_EXP 71
86636: EQUAL
86637: IFFALSE 86709
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
86639: LD_INT 68
86641: PPUSH
86642: LD_VAR 0 1
86646: PPUSH
86647: CALL_OW 255
86651: PPUSH
86652: CALL_OW 321
86656: PUSH
86657: LD_INT 2
86659: EQUAL
86660: IFFALSE 86672
// eff := 70 else
86662: LD_ADDR_VAR 0 4
86666: PUSH
86667: LD_INT 70
86669: ST_TO_ADDR
86670: GO 86680
// eff := 30 ;
86672: LD_ADDR_VAR 0 4
86676: PUSH
86677: LD_INT 30
86679: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
86680: LD_VAR 0 1
86684: PPUSH
86685: CALL_OW 250
86689: PPUSH
86690: LD_VAR 0 1
86694: PPUSH
86695: CALL_OW 251
86699: PPUSH
86700: LD_VAR 0 4
86704: PPUSH
86705: CALL_OW 495
// end ; end ;
86709: LD_VAR 0 2
86713: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
86714: LD_INT 0
86716: PPUSH
// end ;
86717: LD_VAR 0 4
86721: RET
// export function SOS_Command ( cmd ) ; begin
86722: LD_INT 0
86724: PPUSH
// end ;
86725: LD_VAR 0 2
86729: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
86730: LD_INT 0
86732: PPUSH
// if cmd = 121 then
86733: LD_VAR 0 1
86737: PUSH
86738: LD_INT 121
86740: EQUAL
86741: IFFALSE 86743
// end ;
86743: LD_VAR 0 6
86747: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
86748: LD_INT 0
86750: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
86751: LD_VAR 0 1
86755: PUSH
86756: LD_INT 250
86758: EQUAL
86759: PUSH
86760: LD_VAR 0 2
86764: PPUSH
86765: CALL_OW 264
86769: PUSH
86770: LD_EXP 74
86774: EQUAL
86775: AND
86776: IFFALSE 86797
// MinerPlaceMine ( unit , x , y ) ;
86778: LD_VAR 0 2
86782: PPUSH
86783: LD_VAR 0 4
86787: PPUSH
86788: LD_VAR 0 5
86792: PPUSH
86793: CALL 89146 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
86797: LD_VAR 0 1
86801: PUSH
86802: LD_INT 251
86804: EQUAL
86805: PUSH
86806: LD_VAR 0 2
86810: PPUSH
86811: CALL_OW 264
86815: PUSH
86816: LD_EXP 74
86820: EQUAL
86821: AND
86822: IFFALSE 86843
// MinerDetonateMine ( unit , x , y ) ;
86824: LD_VAR 0 2
86828: PPUSH
86829: LD_VAR 0 4
86833: PPUSH
86834: LD_VAR 0 5
86838: PPUSH
86839: CALL 89423 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
86843: LD_VAR 0 1
86847: PUSH
86848: LD_INT 252
86850: EQUAL
86851: PUSH
86852: LD_VAR 0 2
86856: PPUSH
86857: CALL_OW 264
86861: PUSH
86862: LD_EXP 74
86866: EQUAL
86867: AND
86868: IFFALSE 86889
// MinerCreateMinefield ( unit , x , y ) ;
86870: LD_VAR 0 2
86874: PPUSH
86875: LD_VAR 0 4
86879: PPUSH
86880: LD_VAR 0 5
86884: PPUSH
86885: CALL 89840 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
86889: LD_VAR 0 1
86893: PUSH
86894: LD_INT 253
86896: EQUAL
86897: PUSH
86898: LD_VAR 0 2
86902: PPUSH
86903: CALL_OW 257
86907: PUSH
86908: LD_INT 5
86910: EQUAL
86911: AND
86912: IFFALSE 86933
// ComBinocular ( unit , x , y ) ;
86914: LD_VAR 0 2
86918: PPUSH
86919: LD_VAR 0 4
86923: PPUSH
86924: LD_VAR 0 5
86928: PPUSH
86929: CALL 90211 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
86933: LD_VAR 0 1
86937: PUSH
86938: LD_INT 254
86940: EQUAL
86941: PUSH
86942: LD_VAR 0 2
86946: PPUSH
86947: CALL_OW 264
86951: PUSH
86952: LD_EXP 69
86956: EQUAL
86957: AND
86958: PUSH
86959: LD_VAR 0 3
86963: PPUSH
86964: CALL_OW 263
86968: PUSH
86969: LD_INT 3
86971: EQUAL
86972: AND
86973: IFFALSE 86989
// HackDestroyVehicle ( unit , selectedUnit ) ;
86975: LD_VAR 0 2
86979: PPUSH
86980: LD_VAR 0 3
86984: PPUSH
86985: CALL 88506 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
86989: LD_VAR 0 1
86993: PUSH
86994: LD_INT 255
86996: EQUAL
86997: PUSH
86998: LD_VAR 0 2
87002: PPUSH
87003: CALL_OW 264
87007: PUSH
87008: LD_INT 14
87010: PUSH
87011: LD_INT 53
87013: PUSH
87014: EMPTY
87015: LIST
87016: LIST
87017: IN
87018: AND
87019: PUSH
87020: LD_VAR 0 4
87024: PPUSH
87025: LD_VAR 0 5
87029: PPUSH
87030: CALL_OW 488
87034: AND
87035: IFFALSE 87059
// CutTreeXYR ( unit , x , y , 12 ) ;
87037: LD_VAR 0 2
87041: PPUSH
87042: LD_VAR 0 4
87046: PPUSH
87047: LD_VAR 0 5
87051: PPUSH
87052: LD_INT 12
87054: PPUSH
87055: CALL 87072 0 4
// end ;
87059: LD_VAR 0 6
87063: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
87064: LD_INT 0
87066: PPUSH
// end ;
87067: LD_VAR 0 4
87071: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
87072: LD_INT 0
87074: PPUSH
87075: PPUSH
87076: PPUSH
87077: PPUSH
87078: PPUSH
87079: PPUSH
87080: PPUSH
87081: PPUSH
87082: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
87083: LD_VAR 0 1
87087: NOT
87088: PUSH
87089: LD_VAR 0 2
87093: PPUSH
87094: LD_VAR 0 3
87098: PPUSH
87099: CALL_OW 488
87103: NOT
87104: OR
87105: PUSH
87106: LD_VAR 0 4
87110: NOT
87111: OR
87112: IFFALSE 87116
// exit ;
87114: GO 87456
// list := [ ] ;
87116: LD_ADDR_VAR 0 13
87120: PUSH
87121: EMPTY
87122: ST_TO_ADDR
// if x - r < 0 then
87123: LD_VAR 0 2
87127: PUSH
87128: LD_VAR 0 4
87132: MINUS
87133: PUSH
87134: LD_INT 0
87136: LESS
87137: IFFALSE 87149
// min_x := 0 else
87139: LD_ADDR_VAR 0 7
87143: PUSH
87144: LD_INT 0
87146: ST_TO_ADDR
87147: GO 87165
// min_x := x - r ;
87149: LD_ADDR_VAR 0 7
87153: PUSH
87154: LD_VAR 0 2
87158: PUSH
87159: LD_VAR 0 4
87163: MINUS
87164: ST_TO_ADDR
// if y - r < 0 then
87165: LD_VAR 0 3
87169: PUSH
87170: LD_VAR 0 4
87174: MINUS
87175: PUSH
87176: LD_INT 0
87178: LESS
87179: IFFALSE 87191
// min_y := 0 else
87181: LD_ADDR_VAR 0 8
87185: PUSH
87186: LD_INT 0
87188: ST_TO_ADDR
87189: GO 87207
// min_y := y - r ;
87191: LD_ADDR_VAR 0 8
87195: PUSH
87196: LD_VAR 0 3
87200: PUSH
87201: LD_VAR 0 4
87205: MINUS
87206: ST_TO_ADDR
// max_x := x + r ;
87207: LD_ADDR_VAR 0 9
87211: PUSH
87212: LD_VAR 0 2
87216: PUSH
87217: LD_VAR 0 4
87221: PLUS
87222: ST_TO_ADDR
// max_y := y + r ;
87223: LD_ADDR_VAR 0 10
87227: PUSH
87228: LD_VAR 0 3
87232: PUSH
87233: LD_VAR 0 4
87237: PLUS
87238: ST_TO_ADDR
// for _x = min_x to max_x do
87239: LD_ADDR_VAR 0 11
87243: PUSH
87244: DOUBLE
87245: LD_VAR 0 7
87249: DEC
87250: ST_TO_ADDR
87251: LD_VAR 0 9
87255: PUSH
87256: FOR_TO
87257: IFFALSE 87374
// for _y = min_y to max_y do
87259: LD_ADDR_VAR 0 12
87263: PUSH
87264: DOUBLE
87265: LD_VAR 0 8
87269: DEC
87270: ST_TO_ADDR
87271: LD_VAR 0 10
87275: PUSH
87276: FOR_TO
87277: IFFALSE 87370
// begin if not ValidHex ( _x , _y ) then
87279: LD_VAR 0 11
87283: PPUSH
87284: LD_VAR 0 12
87288: PPUSH
87289: CALL_OW 488
87293: NOT
87294: IFFALSE 87298
// continue ;
87296: GO 87276
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
87298: LD_VAR 0 11
87302: PPUSH
87303: LD_VAR 0 12
87307: PPUSH
87308: CALL_OW 351
87312: PUSH
87313: LD_VAR 0 11
87317: PPUSH
87318: LD_VAR 0 12
87322: PPUSH
87323: CALL_OW 554
87327: AND
87328: IFFALSE 87368
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
87330: LD_ADDR_VAR 0 13
87334: PUSH
87335: LD_VAR 0 13
87339: PPUSH
87340: LD_VAR 0 13
87344: PUSH
87345: LD_INT 1
87347: PLUS
87348: PPUSH
87349: LD_VAR 0 11
87353: PUSH
87354: LD_VAR 0 12
87358: PUSH
87359: EMPTY
87360: LIST
87361: LIST
87362: PPUSH
87363: CALL_OW 2
87367: ST_TO_ADDR
// end ;
87368: GO 87276
87370: POP
87371: POP
87372: GO 87256
87374: POP
87375: POP
// if not list then
87376: LD_VAR 0 13
87380: NOT
87381: IFFALSE 87385
// exit ;
87383: GO 87456
// for i in list do
87385: LD_ADDR_VAR 0 6
87389: PUSH
87390: LD_VAR 0 13
87394: PUSH
87395: FOR_IN
87396: IFFALSE 87454
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
87398: LD_VAR 0 1
87402: PPUSH
87403: LD_STRING M
87405: PUSH
87406: LD_VAR 0 6
87410: PUSH
87411: LD_INT 1
87413: ARRAY
87414: PUSH
87415: LD_VAR 0 6
87419: PUSH
87420: LD_INT 2
87422: ARRAY
87423: PUSH
87424: LD_INT 0
87426: PUSH
87427: LD_INT 0
87429: PUSH
87430: LD_INT 0
87432: PUSH
87433: LD_INT 0
87435: PUSH
87436: EMPTY
87437: LIST
87438: LIST
87439: LIST
87440: LIST
87441: LIST
87442: LIST
87443: LIST
87444: PUSH
87445: EMPTY
87446: LIST
87447: PPUSH
87448: CALL_OW 447
87452: GO 87395
87454: POP
87455: POP
// end ;
87456: LD_VAR 0 5
87460: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
87461: LD_EXP 88
87465: NOT
87466: IFFALSE 87516
87468: GO 87470
87470: DISABLE
// begin initHack := true ;
87471: LD_ADDR_EXP 88
87475: PUSH
87476: LD_INT 1
87478: ST_TO_ADDR
// hackTanks := [ ] ;
87479: LD_ADDR_EXP 89
87483: PUSH
87484: EMPTY
87485: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
87486: LD_ADDR_EXP 90
87490: PUSH
87491: EMPTY
87492: ST_TO_ADDR
// hackLimit := 3 ;
87493: LD_ADDR_EXP 91
87497: PUSH
87498: LD_INT 3
87500: ST_TO_ADDR
// hackDist := 12 ;
87501: LD_ADDR_EXP 92
87505: PUSH
87506: LD_INT 12
87508: ST_TO_ADDR
// hackCounter := [ ] ;
87509: LD_ADDR_EXP 93
87513: PUSH
87514: EMPTY
87515: ST_TO_ADDR
// end ;
87516: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
87517: LD_EXP 88
87521: PUSH
87522: LD_INT 34
87524: PUSH
87525: LD_EXP 69
87529: PUSH
87530: EMPTY
87531: LIST
87532: LIST
87533: PPUSH
87534: CALL_OW 69
87538: AND
87539: IFFALSE 87794
87541: GO 87543
87543: DISABLE
87544: LD_INT 0
87546: PPUSH
87547: PPUSH
// begin enable ;
87548: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
87549: LD_ADDR_VAR 0 1
87553: PUSH
87554: LD_INT 34
87556: PUSH
87557: LD_EXP 69
87561: PUSH
87562: EMPTY
87563: LIST
87564: LIST
87565: PPUSH
87566: CALL_OW 69
87570: PUSH
87571: FOR_IN
87572: IFFALSE 87792
// begin if not i in hackTanks then
87574: LD_VAR 0 1
87578: PUSH
87579: LD_EXP 89
87583: IN
87584: NOT
87585: IFFALSE 87668
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
87587: LD_ADDR_EXP 89
87591: PUSH
87592: LD_EXP 89
87596: PPUSH
87597: LD_EXP 89
87601: PUSH
87602: LD_INT 1
87604: PLUS
87605: PPUSH
87606: LD_VAR 0 1
87610: PPUSH
87611: CALL_OW 1
87615: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
87616: LD_ADDR_EXP 90
87620: PUSH
87621: LD_EXP 90
87625: PPUSH
87626: LD_EXP 90
87630: PUSH
87631: LD_INT 1
87633: PLUS
87634: PPUSH
87635: EMPTY
87636: PPUSH
87637: CALL_OW 1
87641: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
87642: LD_ADDR_EXP 93
87646: PUSH
87647: LD_EXP 93
87651: PPUSH
87652: LD_EXP 93
87656: PUSH
87657: LD_INT 1
87659: PLUS
87660: PPUSH
87661: EMPTY
87662: PPUSH
87663: CALL_OW 1
87667: ST_TO_ADDR
// end ; if not IsOk ( i ) then
87668: LD_VAR 0 1
87672: PPUSH
87673: CALL_OW 302
87677: NOT
87678: IFFALSE 87691
// begin HackUnlinkAll ( i ) ;
87680: LD_VAR 0 1
87684: PPUSH
87685: CALL 87797 0 1
// continue ;
87689: GO 87571
// end ; HackCheckCapturedStatus ( i ) ;
87691: LD_VAR 0 1
87695: PPUSH
87696: CALL 88240 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
87700: LD_ADDR_VAR 0 2
87704: PUSH
87705: LD_INT 81
87707: PUSH
87708: LD_VAR 0 1
87712: PPUSH
87713: CALL_OW 255
87717: PUSH
87718: EMPTY
87719: LIST
87720: LIST
87721: PUSH
87722: LD_INT 33
87724: PUSH
87725: LD_INT 3
87727: PUSH
87728: EMPTY
87729: LIST
87730: LIST
87731: PUSH
87732: LD_INT 91
87734: PUSH
87735: LD_VAR 0 1
87739: PUSH
87740: LD_EXP 92
87744: PUSH
87745: EMPTY
87746: LIST
87747: LIST
87748: LIST
87749: PUSH
87750: LD_INT 50
87752: PUSH
87753: EMPTY
87754: LIST
87755: PUSH
87756: EMPTY
87757: LIST
87758: LIST
87759: LIST
87760: LIST
87761: PPUSH
87762: CALL_OW 69
87766: ST_TO_ADDR
// if not tmp then
87767: LD_VAR 0 2
87771: NOT
87772: IFFALSE 87776
// continue ;
87774: GO 87571
// HackLink ( i , tmp ) ;
87776: LD_VAR 0 1
87780: PPUSH
87781: LD_VAR 0 2
87785: PPUSH
87786: CALL 87933 0 2
// end ;
87790: GO 87571
87792: POP
87793: POP
// end ;
87794: PPOPN 2
87796: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
87797: LD_INT 0
87799: PPUSH
87800: PPUSH
87801: PPUSH
// if not hack in hackTanks then
87802: LD_VAR 0 1
87806: PUSH
87807: LD_EXP 89
87811: IN
87812: NOT
87813: IFFALSE 87817
// exit ;
87815: GO 87928
// index := GetElementIndex ( hackTanks , hack ) ;
87817: LD_ADDR_VAR 0 4
87821: PUSH
87822: LD_EXP 89
87826: PPUSH
87827: LD_VAR 0 1
87831: PPUSH
87832: CALL 14768 0 2
87836: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
87837: LD_EXP 90
87841: PUSH
87842: LD_VAR 0 4
87846: ARRAY
87847: IFFALSE 87928
// begin for i in hackTanksCaptured [ index ] do
87849: LD_ADDR_VAR 0 3
87853: PUSH
87854: LD_EXP 90
87858: PUSH
87859: LD_VAR 0 4
87863: ARRAY
87864: PUSH
87865: FOR_IN
87866: IFFALSE 87892
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
87868: LD_VAR 0 3
87872: PUSH
87873: LD_INT 1
87875: ARRAY
87876: PPUSH
87877: LD_VAR 0 3
87881: PUSH
87882: LD_INT 2
87884: ARRAY
87885: PPUSH
87886: CALL_OW 235
87890: GO 87865
87892: POP
87893: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
87894: LD_ADDR_EXP 90
87898: PUSH
87899: LD_EXP 90
87903: PPUSH
87904: LD_VAR 0 4
87908: PPUSH
87909: EMPTY
87910: PPUSH
87911: CALL_OW 1
87915: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
87916: LD_VAR 0 1
87920: PPUSH
87921: LD_INT 0
87923: PPUSH
87924: CALL_OW 505
// end ; end ;
87928: LD_VAR 0 2
87932: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
87933: LD_INT 0
87935: PPUSH
87936: PPUSH
87937: PPUSH
// if not hack in hackTanks or not vehicles then
87938: LD_VAR 0 1
87942: PUSH
87943: LD_EXP 89
87947: IN
87948: NOT
87949: PUSH
87950: LD_VAR 0 2
87954: NOT
87955: OR
87956: IFFALSE 87960
// exit ;
87958: GO 88235
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
87960: LD_ADDR_VAR 0 2
87964: PUSH
87965: LD_VAR 0 1
87969: PPUSH
87970: LD_VAR 0 2
87974: PPUSH
87975: LD_INT 1
87977: PPUSH
87978: LD_INT 1
87980: PPUSH
87981: CALL 15418 0 4
87985: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
87986: LD_ADDR_VAR 0 5
87990: PUSH
87991: LD_EXP 89
87995: PPUSH
87996: LD_VAR 0 1
88000: PPUSH
88001: CALL 14768 0 2
88005: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
88006: LD_EXP 90
88010: PUSH
88011: LD_VAR 0 5
88015: ARRAY
88016: PUSH
88017: LD_EXP 91
88021: LESS
88022: IFFALSE 88211
// begin for i := 1 to vehicles do
88024: LD_ADDR_VAR 0 4
88028: PUSH
88029: DOUBLE
88030: LD_INT 1
88032: DEC
88033: ST_TO_ADDR
88034: LD_VAR 0 2
88038: PUSH
88039: FOR_TO
88040: IFFALSE 88209
// begin if hackTanksCaptured [ index ] = hackLimit then
88042: LD_EXP 90
88046: PUSH
88047: LD_VAR 0 5
88051: ARRAY
88052: PUSH
88053: LD_EXP 91
88057: EQUAL
88058: IFFALSE 88062
// break ;
88060: GO 88209
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
88062: LD_ADDR_EXP 93
88066: PUSH
88067: LD_EXP 93
88071: PPUSH
88072: LD_VAR 0 5
88076: PPUSH
88077: LD_EXP 93
88081: PUSH
88082: LD_VAR 0 5
88086: ARRAY
88087: PUSH
88088: LD_INT 1
88090: PLUS
88091: PPUSH
88092: CALL_OW 1
88096: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
88097: LD_ADDR_EXP 90
88101: PUSH
88102: LD_EXP 90
88106: PPUSH
88107: LD_VAR 0 5
88111: PUSH
88112: LD_EXP 90
88116: PUSH
88117: LD_VAR 0 5
88121: ARRAY
88122: PUSH
88123: LD_INT 1
88125: PLUS
88126: PUSH
88127: EMPTY
88128: LIST
88129: LIST
88130: PPUSH
88131: LD_VAR 0 2
88135: PUSH
88136: LD_VAR 0 4
88140: ARRAY
88141: PUSH
88142: LD_VAR 0 2
88146: PUSH
88147: LD_VAR 0 4
88151: ARRAY
88152: PPUSH
88153: CALL_OW 255
88157: PUSH
88158: EMPTY
88159: LIST
88160: LIST
88161: PPUSH
88162: CALL 14983 0 3
88166: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
88167: LD_VAR 0 2
88171: PUSH
88172: LD_VAR 0 4
88176: ARRAY
88177: PPUSH
88178: LD_VAR 0 1
88182: PPUSH
88183: CALL_OW 255
88187: PPUSH
88188: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
88192: LD_VAR 0 2
88196: PUSH
88197: LD_VAR 0 4
88201: ARRAY
88202: PPUSH
88203: CALL_OW 141
// end ;
88207: GO 88039
88209: POP
88210: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
88211: LD_VAR 0 1
88215: PPUSH
88216: LD_EXP 90
88220: PUSH
88221: LD_VAR 0 5
88225: ARRAY
88226: PUSH
88227: LD_INT 0
88229: PLUS
88230: PPUSH
88231: CALL_OW 505
// end ;
88235: LD_VAR 0 3
88239: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
88240: LD_INT 0
88242: PPUSH
88243: PPUSH
88244: PPUSH
88245: PPUSH
// if not hack in hackTanks then
88246: LD_VAR 0 1
88250: PUSH
88251: LD_EXP 89
88255: IN
88256: NOT
88257: IFFALSE 88261
// exit ;
88259: GO 88501
// index := GetElementIndex ( hackTanks , hack ) ;
88261: LD_ADDR_VAR 0 4
88265: PUSH
88266: LD_EXP 89
88270: PPUSH
88271: LD_VAR 0 1
88275: PPUSH
88276: CALL 14768 0 2
88280: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
88281: LD_ADDR_VAR 0 3
88285: PUSH
88286: DOUBLE
88287: LD_EXP 90
88291: PUSH
88292: LD_VAR 0 4
88296: ARRAY
88297: INC
88298: ST_TO_ADDR
88299: LD_INT 1
88301: PUSH
88302: FOR_DOWNTO
88303: IFFALSE 88475
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
88305: LD_ADDR_VAR 0 5
88309: PUSH
88310: LD_EXP 90
88314: PUSH
88315: LD_VAR 0 4
88319: ARRAY
88320: PUSH
88321: LD_VAR 0 3
88325: ARRAY
88326: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
88327: LD_VAR 0 5
88331: PUSH
88332: LD_INT 1
88334: ARRAY
88335: PPUSH
88336: CALL_OW 302
88340: NOT
88341: PUSH
88342: LD_VAR 0 5
88346: PUSH
88347: LD_INT 1
88349: ARRAY
88350: PPUSH
88351: CALL_OW 255
88355: PUSH
88356: LD_VAR 0 1
88360: PPUSH
88361: CALL_OW 255
88365: NONEQUAL
88366: OR
88367: IFFALSE 88473
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
88369: LD_VAR 0 5
88373: PUSH
88374: LD_INT 1
88376: ARRAY
88377: PPUSH
88378: CALL_OW 305
88382: PUSH
88383: LD_VAR 0 5
88387: PUSH
88388: LD_INT 1
88390: ARRAY
88391: PPUSH
88392: CALL_OW 255
88396: PUSH
88397: LD_VAR 0 1
88401: PPUSH
88402: CALL_OW 255
88406: EQUAL
88407: AND
88408: IFFALSE 88432
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
88410: LD_VAR 0 5
88414: PUSH
88415: LD_INT 1
88417: ARRAY
88418: PPUSH
88419: LD_VAR 0 5
88423: PUSH
88424: LD_INT 2
88426: ARRAY
88427: PPUSH
88428: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
88432: LD_ADDR_EXP 90
88436: PUSH
88437: LD_EXP 90
88441: PPUSH
88442: LD_VAR 0 4
88446: PPUSH
88447: LD_EXP 90
88451: PUSH
88452: LD_VAR 0 4
88456: ARRAY
88457: PPUSH
88458: LD_VAR 0 3
88462: PPUSH
88463: CALL_OW 3
88467: PPUSH
88468: CALL_OW 1
88472: ST_TO_ADDR
// end ; end ;
88473: GO 88302
88475: POP
88476: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
88477: LD_VAR 0 1
88481: PPUSH
88482: LD_EXP 90
88486: PUSH
88487: LD_VAR 0 4
88491: ARRAY
88492: PUSH
88493: LD_INT 0
88495: PLUS
88496: PPUSH
88497: CALL_OW 505
// end ;
88501: LD_VAR 0 2
88505: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
88506: LD_INT 0
88508: PPUSH
88509: PPUSH
88510: PPUSH
88511: PPUSH
// if not hack in hackTanks then
88512: LD_VAR 0 1
88516: PUSH
88517: LD_EXP 89
88521: IN
88522: NOT
88523: IFFALSE 88527
// exit ;
88525: GO 88612
// index := GetElementIndex ( hackTanks , hack ) ;
88527: LD_ADDR_VAR 0 5
88531: PUSH
88532: LD_EXP 89
88536: PPUSH
88537: LD_VAR 0 1
88541: PPUSH
88542: CALL 14768 0 2
88546: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
88547: LD_ADDR_VAR 0 4
88551: PUSH
88552: DOUBLE
88553: LD_INT 1
88555: DEC
88556: ST_TO_ADDR
88557: LD_EXP 90
88561: PUSH
88562: LD_VAR 0 5
88566: ARRAY
88567: PUSH
88568: FOR_TO
88569: IFFALSE 88610
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
88571: LD_EXP 90
88575: PUSH
88576: LD_VAR 0 5
88580: ARRAY
88581: PUSH
88582: LD_VAR 0 4
88586: ARRAY
88587: PUSH
88588: LD_INT 1
88590: ARRAY
88591: PUSH
88592: LD_VAR 0 2
88596: EQUAL
88597: IFFALSE 88608
// KillUnit ( vehicle ) ;
88599: LD_VAR 0 2
88603: PPUSH
88604: CALL_OW 66
88608: GO 88568
88610: POP
88611: POP
// end ;
88612: LD_VAR 0 3
88616: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
88617: LD_EXP 94
88621: NOT
88622: IFFALSE 88657
88624: GO 88626
88626: DISABLE
// begin initMiner := true ;
88627: LD_ADDR_EXP 94
88631: PUSH
88632: LD_INT 1
88634: ST_TO_ADDR
// minersList := [ ] ;
88635: LD_ADDR_EXP 95
88639: PUSH
88640: EMPTY
88641: ST_TO_ADDR
// minerMinesList := [ ] ;
88642: LD_ADDR_EXP 96
88646: PUSH
88647: EMPTY
88648: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
88649: LD_ADDR_EXP 97
88653: PUSH
88654: LD_INT 5
88656: ST_TO_ADDR
// end ;
88657: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
88658: LD_EXP 94
88662: PUSH
88663: LD_INT 34
88665: PUSH
88666: LD_EXP 74
88670: PUSH
88671: EMPTY
88672: LIST
88673: LIST
88674: PPUSH
88675: CALL_OW 69
88679: AND
88680: IFFALSE 89143
88682: GO 88684
88684: DISABLE
88685: LD_INT 0
88687: PPUSH
88688: PPUSH
88689: PPUSH
88690: PPUSH
// begin enable ;
88691: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
88692: LD_ADDR_VAR 0 1
88696: PUSH
88697: LD_INT 34
88699: PUSH
88700: LD_EXP 74
88704: PUSH
88705: EMPTY
88706: LIST
88707: LIST
88708: PPUSH
88709: CALL_OW 69
88713: PUSH
88714: FOR_IN
88715: IFFALSE 88787
// begin if not i in minersList then
88717: LD_VAR 0 1
88721: PUSH
88722: LD_EXP 95
88726: IN
88727: NOT
88728: IFFALSE 88785
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
88730: LD_ADDR_EXP 95
88734: PUSH
88735: LD_EXP 95
88739: PPUSH
88740: LD_EXP 95
88744: PUSH
88745: LD_INT 1
88747: PLUS
88748: PPUSH
88749: LD_VAR 0 1
88753: PPUSH
88754: CALL_OW 1
88758: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
88759: LD_ADDR_EXP 96
88763: PUSH
88764: LD_EXP 96
88768: PPUSH
88769: LD_EXP 96
88773: PUSH
88774: LD_INT 1
88776: PLUS
88777: PPUSH
88778: EMPTY
88779: PPUSH
88780: CALL_OW 1
88784: ST_TO_ADDR
// end end ;
88785: GO 88714
88787: POP
88788: POP
// for i := minerMinesList downto 1 do
88789: LD_ADDR_VAR 0 1
88793: PUSH
88794: DOUBLE
88795: LD_EXP 96
88799: INC
88800: ST_TO_ADDR
88801: LD_INT 1
88803: PUSH
88804: FOR_DOWNTO
88805: IFFALSE 89141
// begin if IsLive ( minersList [ i ] ) then
88807: LD_EXP 95
88811: PUSH
88812: LD_VAR 0 1
88816: ARRAY
88817: PPUSH
88818: CALL_OW 300
88822: IFFALSE 88850
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
88824: LD_EXP 95
88828: PUSH
88829: LD_VAR 0 1
88833: ARRAY
88834: PPUSH
88835: LD_EXP 96
88839: PUSH
88840: LD_VAR 0 1
88844: ARRAY
88845: PPUSH
88846: CALL_OW 505
// if not minerMinesList [ i ] then
88850: LD_EXP 96
88854: PUSH
88855: LD_VAR 0 1
88859: ARRAY
88860: NOT
88861: IFFALSE 88865
// continue ;
88863: GO 88804
// for j := minerMinesList [ i ] downto 1 do
88865: LD_ADDR_VAR 0 2
88869: PUSH
88870: DOUBLE
88871: LD_EXP 96
88875: PUSH
88876: LD_VAR 0 1
88880: ARRAY
88881: INC
88882: ST_TO_ADDR
88883: LD_INT 1
88885: PUSH
88886: FOR_DOWNTO
88887: IFFALSE 89137
// begin side := GetSide ( minersList [ i ] ) ;
88889: LD_ADDR_VAR 0 3
88893: PUSH
88894: LD_EXP 95
88898: PUSH
88899: LD_VAR 0 1
88903: ARRAY
88904: PPUSH
88905: CALL_OW 255
88909: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
88910: LD_ADDR_VAR 0 4
88914: PUSH
88915: LD_EXP 96
88919: PUSH
88920: LD_VAR 0 1
88924: ARRAY
88925: PUSH
88926: LD_VAR 0 2
88930: ARRAY
88931: PUSH
88932: LD_INT 1
88934: ARRAY
88935: PPUSH
88936: LD_EXP 96
88940: PUSH
88941: LD_VAR 0 1
88945: ARRAY
88946: PUSH
88947: LD_VAR 0 2
88951: ARRAY
88952: PUSH
88953: LD_INT 2
88955: ARRAY
88956: PPUSH
88957: CALL_OW 428
88961: ST_TO_ADDR
// if not tmp then
88962: LD_VAR 0 4
88966: NOT
88967: IFFALSE 88971
// continue ;
88969: GO 88886
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
88971: LD_VAR 0 4
88975: PUSH
88976: LD_INT 81
88978: PUSH
88979: LD_VAR 0 3
88983: PUSH
88984: EMPTY
88985: LIST
88986: LIST
88987: PPUSH
88988: CALL_OW 69
88992: IN
88993: PUSH
88994: LD_EXP 96
88998: PUSH
88999: LD_VAR 0 1
89003: ARRAY
89004: PUSH
89005: LD_VAR 0 2
89009: ARRAY
89010: PUSH
89011: LD_INT 1
89013: ARRAY
89014: PPUSH
89015: LD_EXP 96
89019: PUSH
89020: LD_VAR 0 1
89024: ARRAY
89025: PUSH
89026: LD_VAR 0 2
89030: ARRAY
89031: PUSH
89032: LD_INT 2
89034: ARRAY
89035: PPUSH
89036: CALL_OW 458
89040: AND
89041: IFFALSE 89135
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
89043: LD_EXP 96
89047: PUSH
89048: LD_VAR 0 1
89052: ARRAY
89053: PUSH
89054: LD_VAR 0 2
89058: ARRAY
89059: PUSH
89060: LD_INT 1
89062: ARRAY
89063: PPUSH
89064: LD_EXP 96
89068: PUSH
89069: LD_VAR 0 1
89073: ARRAY
89074: PUSH
89075: LD_VAR 0 2
89079: ARRAY
89080: PUSH
89081: LD_INT 2
89083: ARRAY
89084: PPUSH
89085: LD_VAR 0 3
89089: PPUSH
89090: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
89094: LD_ADDR_EXP 96
89098: PUSH
89099: LD_EXP 96
89103: PPUSH
89104: LD_VAR 0 1
89108: PPUSH
89109: LD_EXP 96
89113: PUSH
89114: LD_VAR 0 1
89118: ARRAY
89119: PPUSH
89120: LD_VAR 0 2
89124: PPUSH
89125: CALL_OW 3
89129: PPUSH
89130: CALL_OW 1
89134: ST_TO_ADDR
// end ; end ;
89135: GO 88886
89137: POP
89138: POP
// end ;
89139: GO 88804
89141: POP
89142: POP
// end ;
89143: PPOPN 4
89145: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
89146: LD_INT 0
89148: PPUSH
89149: PPUSH
// result := false ;
89150: LD_ADDR_VAR 0 4
89154: PUSH
89155: LD_INT 0
89157: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
89158: LD_VAR 0 1
89162: PPUSH
89163: CALL_OW 264
89167: PUSH
89168: LD_EXP 74
89172: EQUAL
89173: NOT
89174: IFFALSE 89178
// exit ;
89176: GO 89418
// index := GetElementIndex ( minersList , unit ) ;
89178: LD_ADDR_VAR 0 5
89182: PUSH
89183: LD_EXP 95
89187: PPUSH
89188: LD_VAR 0 1
89192: PPUSH
89193: CALL 14768 0 2
89197: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
89198: LD_EXP 96
89202: PUSH
89203: LD_VAR 0 5
89207: ARRAY
89208: PUSH
89209: LD_EXP 97
89213: GREATEREQUAL
89214: IFFALSE 89218
// exit ;
89216: GO 89418
// ComMoveXY ( unit , x , y ) ;
89218: LD_VAR 0 1
89222: PPUSH
89223: LD_VAR 0 2
89227: PPUSH
89228: LD_VAR 0 3
89232: PPUSH
89233: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
89237: LD_INT 35
89239: PPUSH
89240: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
89244: LD_VAR 0 1
89248: PPUSH
89249: LD_VAR 0 2
89253: PPUSH
89254: LD_VAR 0 3
89258: PPUSH
89259: CALL 45541 0 3
89263: NOT
89264: PUSH
89265: LD_VAR 0 1
89269: PPUSH
89270: CALL_OW 314
89274: AND
89275: IFFALSE 89279
// exit ;
89277: GO 89418
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
89279: LD_VAR 0 2
89283: PPUSH
89284: LD_VAR 0 3
89288: PPUSH
89289: CALL_OW 428
89293: PUSH
89294: LD_VAR 0 1
89298: EQUAL
89299: PUSH
89300: LD_VAR 0 1
89304: PPUSH
89305: CALL_OW 314
89309: NOT
89310: AND
89311: IFFALSE 89237
// PlaySoundXY ( x , y , PlantMine ) ;
89313: LD_VAR 0 2
89317: PPUSH
89318: LD_VAR 0 3
89322: PPUSH
89323: LD_STRING PlantMine
89325: PPUSH
89326: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
89330: LD_VAR 0 2
89334: PPUSH
89335: LD_VAR 0 3
89339: PPUSH
89340: LD_VAR 0 1
89344: PPUSH
89345: CALL_OW 255
89349: PPUSH
89350: LD_INT 0
89352: PPUSH
89353: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
89357: LD_ADDR_EXP 96
89361: PUSH
89362: LD_EXP 96
89366: PPUSH
89367: LD_VAR 0 5
89371: PUSH
89372: LD_EXP 96
89376: PUSH
89377: LD_VAR 0 5
89381: ARRAY
89382: PUSH
89383: LD_INT 1
89385: PLUS
89386: PUSH
89387: EMPTY
89388: LIST
89389: LIST
89390: PPUSH
89391: LD_VAR 0 2
89395: PUSH
89396: LD_VAR 0 3
89400: PUSH
89401: EMPTY
89402: LIST
89403: LIST
89404: PPUSH
89405: CALL 14983 0 3
89409: ST_TO_ADDR
// result := true ;
89410: LD_ADDR_VAR 0 4
89414: PUSH
89415: LD_INT 1
89417: ST_TO_ADDR
// end ;
89418: LD_VAR 0 4
89422: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
89423: LD_INT 0
89425: PPUSH
89426: PPUSH
89427: PPUSH
// if not unit in minersList then
89428: LD_VAR 0 1
89432: PUSH
89433: LD_EXP 95
89437: IN
89438: NOT
89439: IFFALSE 89443
// exit ;
89441: GO 89835
// index := GetElementIndex ( minersList , unit ) ;
89443: LD_ADDR_VAR 0 6
89447: PUSH
89448: LD_EXP 95
89452: PPUSH
89453: LD_VAR 0 1
89457: PPUSH
89458: CALL 14768 0 2
89462: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
89463: LD_ADDR_VAR 0 5
89467: PUSH
89468: DOUBLE
89469: LD_EXP 96
89473: PUSH
89474: LD_VAR 0 6
89478: ARRAY
89479: INC
89480: ST_TO_ADDR
89481: LD_INT 1
89483: PUSH
89484: FOR_DOWNTO
89485: IFFALSE 89646
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
89487: LD_EXP 96
89491: PUSH
89492: LD_VAR 0 6
89496: ARRAY
89497: PUSH
89498: LD_VAR 0 5
89502: ARRAY
89503: PUSH
89504: LD_INT 1
89506: ARRAY
89507: PUSH
89508: LD_VAR 0 2
89512: EQUAL
89513: PUSH
89514: LD_EXP 96
89518: PUSH
89519: LD_VAR 0 6
89523: ARRAY
89524: PUSH
89525: LD_VAR 0 5
89529: ARRAY
89530: PUSH
89531: LD_INT 2
89533: ARRAY
89534: PUSH
89535: LD_VAR 0 3
89539: EQUAL
89540: AND
89541: IFFALSE 89644
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
89543: LD_EXP 96
89547: PUSH
89548: LD_VAR 0 6
89552: ARRAY
89553: PUSH
89554: LD_VAR 0 5
89558: ARRAY
89559: PUSH
89560: LD_INT 1
89562: ARRAY
89563: PPUSH
89564: LD_EXP 96
89568: PUSH
89569: LD_VAR 0 6
89573: ARRAY
89574: PUSH
89575: LD_VAR 0 5
89579: ARRAY
89580: PUSH
89581: LD_INT 2
89583: ARRAY
89584: PPUSH
89585: LD_VAR 0 1
89589: PPUSH
89590: CALL_OW 255
89594: PPUSH
89595: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
89599: LD_ADDR_EXP 96
89603: PUSH
89604: LD_EXP 96
89608: PPUSH
89609: LD_VAR 0 6
89613: PPUSH
89614: LD_EXP 96
89618: PUSH
89619: LD_VAR 0 6
89623: ARRAY
89624: PPUSH
89625: LD_VAR 0 5
89629: PPUSH
89630: CALL_OW 3
89634: PPUSH
89635: CALL_OW 1
89639: ST_TO_ADDR
// exit ;
89640: POP
89641: POP
89642: GO 89835
// end ; end ;
89644: GO 89484
89646: POP
89647: POP
// for i := minerMinesList [ index ] downto 1 do
89648: LD_ADDR_VAR 0 5
89652: PUSH
89653: DOUBLE
89654: LD_EXP 96
89658: PUSH
89659: LD_VAR 0 6
89663: ARRAY
89664: INC
89665: ST_TO_ADDR
89666: LD_INT 1
89668: PUSH
89669: FOR_DOWNTO
89670: IFFALSE 89833
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
89672: LD_EXP 96
89676: PUSH
89677: LD_VAR 0 6
89681: ARRAY
89682: PUSH
89683: LD_VAR 0 5
89687: ARRAY
89688: PUSH
89689: LD_INT 1
89691: ARRAY
89692: PPUSH
89693: LD_EXP 96
89697: PUSH
89698: LD_VAR 0 6
89702: ARRAY
89703: PUSH
89704: LD_VAR 0 5
89708: ARRAY
89709: PUSH
89710: LD_INT 2
89712: ARRAY
89713: PPUSH
89714: LD_VAR 0 2
89718: PPUSH
89719: LD_VAR 0 3
89723: PPUSH
89724: CALL_OW 298
89728: PUSH
89729: LD_INT 6
89731: LESS
89732: IFFALSE 89831
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
89734: LD_EXP 96
89738: PUSH
89739: LD_VAR 0 6
89743: ARRAY
89744: PUSH
89745: LD_VAR 0 5
89749: ARRAY
89750: PUSH
89751: LD_INT 1
89753: ARRAY
89754: PPUSH
89755: LD_EXP 96
89759: PUSH
89760: LD_VAR 0 6
89764: ARRAY
89765: PUSH
89766: LD_VAR 0 5
89770: ARRAY
89771: PUSH
89772: LD_INT 2
89774: ARRAY
89775: PPUSH
89776: LD_VAR 0 1
89780: PPUSH
89781: CALL_OW 255
89785: PPUSH
89786: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
89790: LD_ADDR_EXP 96
89794: PUSH
89795: LD_EXP 96
89799: PPUSH
89800: LD_VAR 0 6
89804: PPUSH
89805: LD_EXP 96
89809: PUSH
89810: LD_VAR 0 6
89814: ARRAY
89815: PPUSH
89816: LD_VAR 0 5
89820: PPUSH
89821: CALL_OW 3
89825: PPUSH
89826: CALL_OW 1
89830: ST_TO_ADDR
// end ; end ;
89831: GO 89669
89833: POP
89834: POP
// end ;
89835: LD_VAR 0 4
89839: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
89840: LD_INT 0
89842: PPUSH
89843: PPUSH
89844: PPUSH
89845: PPUSH
89846: PPUSH
89847: PPUSH
89848: PPUSH
89849: PPUSH
89850: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
89851: LD_VAR 0 1
89855: PPUSH
89856: CALL_OW 264
89860: PUSH
89861: LD_EXP 74
89865: EQUAL
89866: NOT
89867: PUSH
89868: LD_VAR 0 1
89872: PUSH
89873: LD_EXP 95
89877: IN
89878: NOT
89879: OR
89880: IFFALSE 89884
// exit ;
89882: GO 90206
// index := GetElementIndex ( minersList , unit ) ;
89884: LD_ADDR_VAR 0 6
89888: PUSH
89889: LD_EXP 95
89893: PPUSH
89894: LD_VAR 0 1
89898: PPUSH
89899: CALL 14768 0 2
89903: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
89904: LD_ADDR_VAR 0 8
89908: PUSH
89909: LD_EXP 97
89913: PUSH
89914: LD_EXP 96
89918: PUSH
89919: LD_VAR 0 6
89923: ARRAY
89924: MINUS
89925: ST_TO_ADDR
// if not minesFreeAmount then
89926: LD_VAR 0 8
89930: NOT
89931: IFFALSE 89935
// exit ;
89933: GO 90206
// tmp := [ ] ;
89935: LD_ADDR_VAR 0 7
89939: PUSH
89940: EMPTY
89941: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
89942: LD_ADDR_VAR 0 5
89946: PUSH
89947: DOUBLE
89948: LD_INT 1
89950: DEC
89951: ST_TO_ADDR
89952: LD_VAR 0 8
89956: PUSH
89957: FOR_TO
89958: IFFALSE 90153
// begin _d := rand ( 0 , 5 ) ;
89960: LD_ADDR_VAR 0 11
89964: PUSH
89965: LD_INT 0
89967: PPUSH
89968: LD_INT 5
89970: PPUSH
89971: CALL_OW 12
89975: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
89976: LD_ADDR_VAR 0 12
89980: PUSH
89981: LD_INT 2
89983: PPUSH
89984: LD_INT 6
89986: PPUSH
89987: CALL_OW 12
89991: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
89992: LD_ADDR_VAR 0 9
89996: PUSH
89997: LD_VAR 0 2
90001: PPUSH
90002: LD_VAR 0 11
90006: PPUSH
90007: LD_VAR 0 12
90011: PPUSH
90012: CALL_OW 272
90016: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
90017: LD_ADDR_VAR 0 10
90021: PUSH
90022: LD_VAR 0 3
90026: PPUSH
90027: LD_VAR 0 11
90031: PPUSH
90032: LD_VAR 0 12
90036: PPUSH
90037: CALL_OW 273
90041: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
90042: LD_VAR 0 9
90046: PPUSH
90047: LD_VAR 0 10
90051: PPUSH
90052: CALL_OW 488
90056: PUSH
90057: LD_VAR 0 9
90061: PUSH
90062: LD_VAR 0 10
90066: PUSH
90067: EMPTY
90068: LIST
90069: LIST
90070: PUSH
90071: LD_VAR 0 7
90075: IN
90076: NOT
90077: AND
90078: PUSH
90079: LD_VAR 0 9
90083: PPUSH
90084: LD_VAR 0 10
90088: PPUSH
90089: CALL_OW 458
90093: NOT
90094: AND
90095: IFFALSE 90137
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
90097: LD_ADDR_VAR 0 7
90101: PUSH
90102: LD_VAR 0 7
90106: PPUSH
90107: LD_VAR 0 7
90111: PUSH
90112: LD_INT 1
90114: PLUS
90115: PPUSH
90116: LD_VAR 0 9
90120: PUSH
90121: LD_VAR 0 10
90125: PUSH
90126: EMPTY
90127: LIST
90128: LIST
90129: PPUSH
90130: CALL_OW 1
90134: ST_TO_ADDR
90135: GO 90151
// i := i - 1 ;
90137: LD_ADDR_VAR 0 5
90141: PUSH
90142: LD_VAR 0 5
90146: PUSH
90147: LD_INT 1
90149: MINUS
90150: ST_TO_ADDR
// end ;
90151: GO 89957
90153: POP
90154: POP
// for i in tmp do
90155: LD_ADDR_VAR 0 5
90159: PUSH
90160: LD_VAR 0 7
90164: PUSH
90165: FOR_IN
90166: IFFALSE 90204
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
90168: LD_VAR 0 1
90172: PPUSH
90173: LD_VAR 0 5
90177: PUSH
90178: LD_INT 1
90180: ARRAY
90181: PPUSH
90182: LD_VAR 0 5
90186: PUSH
90187: LD_INT 2
90189: ARRAY
90190: PPUSH
90191: CALL 89146 0 3
90195: NOT
90196: IFFALSE 90202
// exit ;
90198: POP
90199: POP
90200: GO 90206
90202: GO 90165
90204: POP
90205: POP
// end ;
90206: LD_VAR 0 4
90210: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
90211: LD_INT 0
90213: PPUSH
90214: PPUSH
90215: PPUSH
90216: PPUSH
90217: PPUSH
90218: PPUSH
90219: PPUSH
// if not GetClass ( unit ) = class_sniper then
90220: LD_VAR 0 1
90224: PPUSH
90225: CALL_OW 257
90229: PUSH
90230: LD_INT 5
90232: EQUAL
90233: NOT
90234: IFFALSE 90238
// exit ;
90236: GO 90626
// dist := 8 ;
90238: LD_ADDR_VAR 0 5
90242: PUSH
90243: LD_INT 8
90245: ST_TO_ADDR
// viewRange := 12 ;
90246: LD_ADDR_VAR 0 7
90250: PUSH
90251: LD_INT 12
90253: ST_TO_ADDR
// side := GetSide ( unit ) ;
90254: LD_ADDR_VAR 0 6
90258: PUSH
90259: LD_VAR 0 1
90263: PPUSH
90264: CALL_OW 255
90268: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
90269: LD_INT 61
90271: PPUSH
90272: LD_VAR 0 6
90276: PPUSH
90277: CALL_OW 321
90281: PUSH
90282: LD_INT 2
90284: EQUAL
90285: IFFALSE 90295
// viewRange := 16 ;
90287: LD_ADDR_VAR 0 7
90291: PUSH
90292: LD_INT 16
90294: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
90295: LD_VAR 0 1
90299: PPUSH
90300: LD_VAR 0 2
90304: PPUSH
90305: LD_VAR 0 3
90309: PPUSH
90310: CALL_OW 297
90314: PUSH
90315: LD_VAR 0 5
90319: GREATER
90320: IFFALSE 90399
// begin ComMoveXY ( unit , x , y ) ;
90322: LD_VAR 0 1
90326: PPUSH
90327: LD_VAR 0 2
90331: PPUSH
90332: LD_VAR 0 3
90336: PPUSH
90337: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
90341: LD_INT 35
90343: PPUSH
90344: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
90348: LD_VAR 0 1
90352: PPUSH
90353: LD_VAR 0 2
90357: PPUSH
90358: LD_VAR 0 3
90362: PPUSH
90363: CALL 45541 0 3
90367: NOT
90368: IFFALSE 90372
// exit ;
90370: GO 90626
// until GetDistUnitXY ( unit , x , y ) < dist ;
90372: LD_VAR 0 1
90376: PPUSH
90377: LD_VAR 0 2
90381: PPUSH
90382: LD_VAR 0 3
90386: PPUSH
90387: CALL_OW 297
90391: PUSH
90392: LD_VAR 0 5
90396: LESS
90397: IFFALSE 90341
// end ; ComTurnXY ( unit , x , y ) ;
90399: LD_VAR 0 1
90403: PPUSH
90404: LD_VAR 0 2
90408: PPUSH
90409: LD_VAR 0 3
90413: PPUSH
90414: CALL_OW 118
// wait ( 5 ) ;
90418: LD_INT 5
90420: PPUSH
90421: CALL_OW 67
// _d := GetDir ( unit ) ;
90425: LD_ADDR_VAR 0 10
90429: PUSH
90430: LD_VAR 0 1
90434: PPUSH
90435: CALL_OW 254
90439: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
90440: LD_ADDR_VAR 0 8
90444: PUSH
90445: LD_VAR 0 1
90449: PPUSH
90450: CALL_OW 250
90454: PPUSH
90455: LD_VAR 0 10
90459: PPUSH
90460: LD_VAR 0 5
90464: PPUSH
90465: CALL_OW 272
90469: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
90470: LD_ADDR_VAR 0 9
90474: PUSH
90475: LD_VAR 0 1
90479: PPUSH
90480: CALL_OW 251
90484: PPUSH
90485: LD_VAR 0 10
90489: PPUSH
90490: LD_VAR 0 5
90494: PPUSH
90495: CALL_OW 273
90499: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
90500: LD_VAR 0 8
90504: PPUSH
90505: LD_VAR 0 9
90509: PPUSH
90510: CALL_OW 488
90514: NOT
90515: IFFALSE 90519
// exit ;
90517: GO 90626
// ComAnimCustom ( unit , 1 ) ;
90519: LD_VAR 0 1
90523: PPUSH
90524: LD_INT 1
90526: PPUSH
90527: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
90531: LD_VAR 0 8
90535: PPUSH
90536: LD_VAR 0 9
90540: PPUSH
90541: LD_VAR 0 6
90545: PPUSH
90546: LD_VAR 0 7
90550: PPUSH
90551: CALL_OW 330
// repeat wait ( 1 ) ;
90555: LD_INT 1
90557: PPUSH
90558: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
90562: LD_VAR 0 1
90566: PPUSH
90567: CALL_OW 316
90571: PUSH
90572: LD_VAR 0 1
90576: PPUSH
90577: CALL_OW 314
90581: OR
90582: PUSH
90583: LD_VAR 0 1
90587: PPUSH
90588: CALL_OW 302
90592: NOT
90593: OR
90594: PUSH
90595: LD_VAR 0 1
90599: PPUSH
90600: CALL_OW 301
90604: OR
90605: IFFALSE 90555
// RemoveSeeing ( _x , _y , side ) ;
90607: LD_VAR 0 8
90611: PPUSH
90612: LD_VAR 0 9
90616: PPUSH
90617: LD_VAR 0 6
90621: PPUSH
90622: CALL_OW 331
// end ; end_of_file end_of_file
90626: LD_VAR 0 4
90630: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
90631: LD_VAR 0 1
90635: PUSH
90636: LD_INT 200
90638: DOUBLE
90639: GREATEREQUAL
90640: IFFALSE 90648
90642: LD_INT 299
90644: DOUBLE
90645: LESSEQUAL
90646: IFTRUE 90650
90648: GO 90682
90650: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
90651: LD_VAR 0 1
90655: PPUSH
90656: LD_VAR 0 2
90660: PPUSH
90661: LD_VAR 0 3
90665: PPUSH
90666: LD_VAR 0 4
90670: PPUSH
90671: LD_VAR 0 5
90675: PPUSH
90676: CALL 86748 0 5
90680: GO 90759
90682: LD_INT 300
90684: DOUBLE
90685: GREATEREQUAL
90686: IFFALSE 90694
90688: LD_INT 399
90690: DOUBLE
90691: LESSEQUAL
90692: IFTRUE 90696
90694: GO 90758
90696: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
90697: LD_VAR 0 1
90701: PPUSH
90702: LD_VAR 0 2
90706: PPUSH
90707: LD_VAR 0 3
90711: PPUSH
90712: LD_VAR 0 4
90716: PPUSH
90717: LD_VAR 0 5
90721: PPUSH
90722: LD_VAR 0 6
90726: PPUSH
90727: LD_VAR 0 7
90731: PPUSH
90732: LD_VAR 0 8
90736: PPUSH
90737: LD_VAR 0 9
90741: PPUSH
90742: LD_VAR 0 10
90746: PPUSH
90747: LD_VAR 0 11
90751: PPUSH
90752: CALL 101986 0 11
90756: GO 90759
90758: POP
// end ;
90759: PPOPN 11
90761: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
90762: LD_VAR 0 1
90766: PPUSH
90767: LD_VAR 0 2
90771: PPUSH
90772: LD_VAR 0 3
90776: PPUSH
90777: LD_VAR 0 4
90781: PPUSH
90782: LD_VAR 0 5
90786: PPUSH
90787: CALL 86730 0 5
// end ; end_of_file
90791: PPOPN 5
90793: END
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
90794: LD_INT 0
90796: PPUSH
// if p2 = 100 then
90797: LD_VAR 0 2
90801: PUSH
90802: LD_INT 100
90804: EQUAL
90805: IFFALSE 91754
// begin if not StreamModeActive then
90807: LD_EXP 98
90811: NOT
90812: IFFALSE 90822
// StreamModeActive := true ;
90814: LD_ADDR_EXP 98
90818: PUSH
90819: LD_INT 1
90821: ST_TO_ADDR
// if p3 = 0 then
90822: LD_VAR 0 3
90826: PUSH
90827: LD_INT 0
90829: EQUAL
90830: IFFALSE 90836
// InitStreamMode ;
90832: CALL 91914 0 0
// if p3 = 1 then
90836: LD_VAR 0 3
90840: PUSH
90841: LD_INT 1
90843: EQUAL
90844: IFFALSE 90854
// sRocket := true ;
90846: LD_ADDR_EXP 103
90850: PUSH
90851: LD_INT 1
90853: ST_TO_ADDR
// if p3 = 2 then
90854: LD_VAR 0 3
90858: PUSH
90859: LD_INT 2
90861: EQUAL
90862: IFFALSE 90872
// sSpeed := true ;
90864: LD_ADDR_EXP 102
90868: PUSH
90869: LD_INT 1
90871: ST_TO_ADDR
// if p3 = 3 then
90872: LD_VAR 0 3
90876: PUSH
90877: LD_INT 3
90879: EQUAL
90880: IFFALSE 90890
// sEngine := true ;
90882: LD_ADDR_EXP 104
90886: PUSH
90887: LD_INT 1
90889: ST_TO_ADDR
// if p3 = 4 then
90890: LD_VAR 0 3
90894: PUSH
90895: LD_INT 4
90897: EQUAL
90898: IFFALSE 90908
// sSpec := true ;
90900: LD_ADDR_EXP 101
90904: PUSH
90905: LD_INT 1
90907: ST_TO_ADDR
// if p3 = 5 then
90908: LD_VAR 0 3
90912: PUSH
90913: LD_INT 5
90915: EQUAL
90916: IFFALSE 90926
// sLevel := true ;
90918: LD_ADDR_EXP 105
90922: PUSH
90923: LD_INT 1
90925: ST_TO_ADDR
// if p3 = 6 then
90926: LD_VAR 0 3
90930: PUSH
90931: LD_INT 6
90933: EQUAL
90934: IFFALSE 90944
// sArmoury := true ;
90936: LD_ADDR_EXP 106
90940: PUSH
90941: LD_INT 1
90943: ST_TO_ADDR
// if p3 = 7 then
90944: LD_VAR 0 3
90948: PUSH
90949: LD_INT 7
90951: EQUAL
90952: IFFALSE 90962
// sRadar := true ;
90954: LD_ADDR_EXP 107
90958: PUSH
90959: LD_INT 1
90961: ST_TO_ADDR
// if p3 = 8 then
90962: LD_VAR 0 3
90966: PUSH
90967: LD_INT 8
90969: EQUAL
90970: IFFALSE 90980
// sBunker := true ;
90972: LD_ADDR_EXP 108
90976: PUSH
90977: LD_INT 1
90979: ST_TO_ADDR
// if p3 = 9 then
90980: LD_VAR 0 3
90984: PUSH
90985: LD_INT 9
90987: EQUAL
90988: IFFALSE 90998
// sHack := true ;
90990: LD_ADDR_EXP 109
90994: PUSH
90995: LD_INT 1
90997: ST_TO_ADDR
// if p3 = 10 then
90998: LD_VAR 0 3
91002: PUSH
91003: LD_INT 10
91005: EQUAL
91006: IFFALSE 91016
// sFire := true ;
91008: LD_ADDR_EXP 110
91012: PUSH
91013: LD_INT 1
91015: ST_TO_ADDR
// if p3 = 11 then
91016: LD_VAR 0 3
91020: PUSH
91021: LD_INT 11
91023: EQUAL
91024: IFFALSE 91034
// sRefresh := true ;
91026: LD_ADDR_EXP 111
91030: PUSH
91031: LD_INT 1
91033: ST_TO_ADDR
// if p3 = 12 then
91034: LD_VAR 0 3
91038: PUSH
91039: LD_INT 12
91041: EQUAL
91042: IFFALSE 91052
// sExp := true ;
91044: LD_ADDR_EXP 112
91048: PUSH
91049: LD_INT 1
91051: ST_TO_ADDR
// if p3 = 13 then
91052: LD_VAR 0 3
91056: PUSH
91057: LD_INT 13
91059: EQUAL
91060: IFFALSE 91070
// sDepot := true ;
91062: LD_ADDR_EXP 113
91066: PUSH
91067: LD_INT 1
91069: ST_TO_ADDR
// if p3 = 14 then
91070: LD_VAR 0 3
91074: PUSH
91075: LD_INT 14
91077: EQUAL
91078: IFFALSE 91088
// sFlag := true ;
91080: LD_ADDR_EXP 114
91084: PUSH
91085: LD_INT 1
91087: ST_TO_ADDR
// if p3 = 15 then
91088: LD_VAR 0 3
91092: PUSH
91093: LD_INT 15
91095: EQUAL
91096: IFFALSE 91106
// sKamikadze := true ;
91098: LD_ADDR_EXP 122
91102: PUSH
91103: LD_INT 1
91105: ST_TO_ADDR
// if p3 = 16 then
91106: LD_VAR 0 3
91110: PUSH
91111: LD_INT 16
91113: EQUAL
91114: IFFALSE 91124
// sTroll := true ;
91116: LD_ADDR_EXP 123
91120: PUSH
91121: LD_INT 1
91123: ST_TO_ADDR
// if p3 = 17 then
91124: LD_VAR 0 3
91128: PUSH
91129: LD_INT 17
91131: EQUAL
91132: IFFALSE 91142
// sSlow := true ;
91134: LD_ADDR_EXP 124
91138: PUSH
91139: LD_INT 1
91141: ST_TO_ADDR
// if p3 = 18 then
91142: LD_VAR 0 3
91146: PUSH
91147: LD_INT 18
91149: EQUAL
91150: IFFALSE 91160
// sLack := true ;
91152: LD_ADDR_EXP 125
91156: PUSH
91157: LD_INT 1
91159: ST_TO_ADDR
// if p3 = 19 then
91160: LD_VAR 0 3
91164: PUSH
91165: LD_INT 19
91167: EQUAL
91168: IFFALSE 91178
// sTank := true ;
91170: LD_ADDR_EXP 127
91174: PUSH
91175: LD_INT 1
91177: ST_TO_ADDR
// if p3 = 20 then
91178: LD_VAR 0 3
91182: PUSH
91183: LD_INT 20
91185: EQUAL
91186: IFFALSE 91196
// sRemote := true ;
91188: LD_ADDR_EXP 128
91192: PUSH
91193: LD_INT 1
91195: ST_TO_ADDR
// if p3 = 21 then
91196: LD_VAR 0 3
91200: PUSH
91201: LD_INT 21
91203: EQUAL
91204: IFFALSE 91214
// sPowell := true ;
91206: LD_ADDR_EXP 129
91210: PUSH
91211: LD_INT 1
91213: ST_TO_ADDR
// if p3 = 22 then
91214: LD_VAR 0 3
91218: PUSH
91219: LD_INT 22
91221: EQUAL
91222: IFFALSE 91232
// sTeleport := true ;
91224: LD_ADDR_EXP 132
91228: PUSH
91229: LD_INT 1
91231: ST_TO_ADDR
// if p3 = 23 then
91232: LD_VAR 0 3
91236: PUSH
91237: LD_INT 23
91239: EQUAL
91240: IFFALSE 91250
// sOilTower := true ;
91242: LD_ADDR_EXP 134
91246: PUSH
91247: LD_INT 1
91249: ST_TO_ADDR
// if p3 = 24 then
91250: LD_VAR 0 3
91254: PUSH
91255: LD_INT 24
91257: EQUAL
91258: IFFALSE 91268
// sShovel := true ;
91260: LD_ADDR_EXP 135
91264: PUSH
91265: LD_INT 1
91267: ST_TO_ADDR
// if p3 = 25 then
91268: LD_VAR 0 3
91272: PUSH
91273: LD_INT 25
91275: EQUAL
91276: IFFALSE 91286
// sSheik := true ;
91278: LD_ADDR_EXP 136
91282: PUSH
91283: LD_INT 1
91285: ST_TO_ADDR
// if p3 = 26 then
91286: LD_VAR 0 3
91290: PUSH
91291: LD_INT 26
91293: EQUAL
91294: IFFALSE 91304
// sEarthquake := true ;
91296: LD_ADDR_EXP 138
91300: PUSH
91301: LD_INT 1
91303: ST_TO_ADDR
// if p3 = 27 then
91304: LD_VAR 0 3
91308: PUSH
91309: LD_INT 27
91311: EQUAL
91312: IFFALSE 91322
// sAI := true ;
91314: LD_ADDR_EXP 139
91318: PUSH
91319: LD_INT 1
91321: ST_TO_ADDR
// if p3 = 28 then
91322: LD_VAR 0 3
91326: PUSH
91327: LD_INT 28
91329: EQUAL
91330: IFFALSE 91340
// sCargo := true ;
91332: LD_ADDR_EXP 142
91336: PUSH
91337: LD_INT 1
91339: ST_TO_ADDR
// if p3 = 29 then
91340: LD_VAR 0 3
91344: PUSH
91345: LD_INT 29
91347: EQUAL
91348: IFFALSE 91358
// sDLaser := true ;
91350: LD_ADDR_EXP 143
91354: PUSH
91355: LD_INT 1
91357: ST_TO_ADDR
// if p3 = 30 then
91358: LD_VAR 0 3
91362: PUSH
91363: LD_INT 30
91365: EQUAL
91366: IFFALSE 91376
// sExchange := true ;
91368: LD_ADDR_EXP 144
91372: PUSH
91373: LD_INT 1
91375: ST_TO_ADDR
// if p3 = 31 then
91376: LD_VAR 0 3
91380: PUSH
91381: LD_INT 31
91383: EQUAL
91384: IFFALSE 91394
// sFac := true ;
91386: LD_ADDR_EXP 145
91390: PUSH
91391: LD_INT 1
91393: ST_TO_ADDR
// if p3 = 32 then
91394: LD_VAR 0 3
91398: PUSH
91399: LD_INT 32
91401: EQUAL
91402: IFFALSE 91412
// sPower := true ;
91404: LD_ADDR_EXP 146
91408: PUSH
91409: LD_INT 1
91411: ST_TO_ADDR
// if p3 = 33 then
91412: LD_VAR 0 3
91416: PUSH
91417: LD_INT 33
91419: EQUAL
91420: IFFALSE 91430
// sRandom := true ;
91422: LD_ADDR_EXP 147
91426: PUSH
91427: LD_INT 1
91429: ST_TO_ADDR
// if p3 = 34 then
91430: LD_VAR 0 3
91434: PUSH
91435: LD_INT 34
91437: EQUAL
91438: IFFALSE 91448
// sShield := true ;
91440: LD_ADDR_EXP 148
91444: PUSH
91445: LD_INT 1
91447: ST_TO_ADDR
// if p3 = 35 then
91448: LD_VAR 0 3
91452: PUSH
91453: LD_INT 35
91455: EQUAL
91456: IFFALSE 91466
// sTime := true ;
91458: LD_ADDR_EXP 149
91462: PUSH
91463: LD_INT 1
91465: ST_TO_ADDR
// if p3 = 36 then
91466: LD_VAR 0 3
91470: PUSH
91471: LD_INT 36
91473: EQUAL
91474: IFFALSE 91484
// sTools := true ;
91476: LD_ADDR_EXP 150
91480: PUSH
91481: LD_INT 1
91483: ST_TO_ADDR
// if p3 = 101 then
91484: LD_VAR 0 3
91488: PUSH
91489: LD_INT 101
91491: EQUAL
91492: IFFALSE 91502
// sSold := true ;
91494: LD_ADDR_EXP 115
91498: PUSH
91499: LD_INT 1
91501: ST_TO_ADDR
// if p3 = 102 then
91502: LD_VAR 0 3
91506: PUSH
91507: LD_INT 102
91509: EQUAL
91510: IFFALSE 91520
// sDiff := true ;
91512: LD_ADDR_EXP 116
91516: PUSH
91517: LD_INT 1
91519: ST_TO_ADDR
// if p3 = 103 then
91520: LD_VAR 0 3
91524: PUSH
91525: LD_INT 103
91527: EQUAL
91528: IFFALSE 91538
// sFog := true ;
91530: LD_ADDR_EXP 119
91534: PUSH
91535: LD_INT 1
91537: ST_TO_ADDR
// if p3 = 104 then
91538: LD_VAR 0 3
91542: PUSH
91543: LD_INT 104
91545: EQUAL
91546: IFFALSE 91556
// sReset := true ;
91548: LD_ADDR_EXP 120
91552: PUSH
91553: LD_INT 1
91555: ST_TO_ADDR
// if p3 = 105 then
91556: LD_VAR 0 3
91560: PUSH
91561: LD_INT 105
91563: EQUAL
91564: IFFALSE 91574
// sSun := true ;
91566: LD_ADDR_EXP 121
91570: PUSH
91571: LD_INT 1
91573: ST_TO_ADDR
// if p3 = 106 then
91574: LD_VAR 0 3
91578: PUSH
91579: LD_INT 106
91581: EQUAL
91582: IFFALSE 91592
// sTiger := true ;
91584: LD_ADDR_EXP 117
91588: PUSH
91589: LD_INT 1
91591: ST_TO_ADDR
// if p3 = 107 then
91592: LD_VAR 0 3
91596: PUSH
91597: LD_INT 107
91599: EQUAL
91600: IFFALSE 91610
// sBomb := true ;
91602: LD_ADDR_EXP 118
91606: PUSH
91607: LD_INT 1
91609: ST_TO_ADDR
// if p3 = 108 then
91610: LD_VAR 0 3
91614: PUSH
91615: LD_INT 108
91617: EQUAL
91618: IFFALSE 91628
// sWound := true ;
91620: LD_ADDR_EXP 126
91624: PUSH
91625: LD_INT 1
91627: ST_TO_ADDR
// if p3 = 109 then
91628: LD_VAR 0 3
91632: PUSH
91633: LD_INT 109
91635: EQUAL
91636: IFFALSE 91646
// sBetray := true ;
91638: LD_ADDR_EXP 130
91642: PUSH
91643: LD_INT 1
91645: ST_TO_ADDR
// if p3 = 110 then
91646: LD_VAR 0 3
91650: PUSH
91651: LD_INT 110
91653: EQUAL
91654: IFFALSE 91664
// sContamin := true ;
91656: LD_ADDR_EXP 131
91660: PUSH
91661: LD_INT 1
91663: ST_TO_ADDR
// if p3 = 111 then
91664: LD_VAR 0 3
91668: PUSH
91669: LD_INT 111
91671: EQUAL
91672: IFFALSE 91682
// sOil := true ;
91674: LD_ADDR_EXP 133
91678: PUSH
91679: LD_INT 1
91681: ST_TO_ADDR
// if p3 = 112 then
91682: LD_VAR 0 3
91686: PUSH
91687: LD_INT 112
91689: EQUAL
91690: IFFALSE 91700
// sStu := true ;
91692: LD_ADDR_EXP 137
91696: PUSH
91697: LD_INT 1
91699: ST_TO_ADDR
// if p3 = 113 then
91700: LD_VAR 0 3
91704: PUSH
91705: LD_INT 113
91707: EQUAL
91708: IFFALSE 91718
// sBazooka := true ;
91710: LD_ADDR_EXP 140
91714: PUSH
91715: LD_INT 1
91717: ST_TO_ADDR
// if p3 = 114 then
91718: LD_VAR 0 3
91722: PUSH
91723: LD_INT 114
91725: EQUAL
91726: IFFALSE 91736
// sMortar := true ;
91728: LD_ADDR_EXP 141
91732: PUSH
91733: LD_INT 1
91735: ST_TO_ADDR
// if p3 = 115 then
91736: LD_VAR 0 3
91740: PUSH
91741: LD_INT 115
91743: EQUAL
91744: IFFALSE 91754
// sRanger := true ;
91746: LD_ADDR_EXP 151
91750: PUSH
91751: LD_INT 1
91753: ST_TO_ADDR
// end ; if p2 = 101 then
91754: LD_VAR 0 2
91758: PUSH
91759: LD_INT 101
91761: EQUAL
91762: IFFALSE 91890
// begin case p3 of 1 :
91764: LD_VAR 0 3
91768: PUSH
91769: LD_INT 1
91771: DOUBLE
91772: EQUAL
91773: IFTRUE 91777
91775: GO 91784
91777: POP
// hHackUnlimitedResources ; 2 :
91778: CALL 102927 0 0
91782: GO 91890
91784: LD_INT 2
91786: DOUBLE
91787: EQUAL
91788: IFTRUE 91792
91790: GO 91799
91792: POP
// hHackSetLevel10 ; 3 :
91793: CALL 103060 0 0
91797: GO 91890
91799: LD_INT 3
91801: DOUBLE
91802: EQUAL
91803: IFTRUE 91807
91805: GO 91814
91807: POP
// hHackSetLevel10YourUnits ; 4 :
91808: CALL 103145 0 0
91812: GO 91890
91814: LD_INT 4
91816: DOUBLE
91817: EQUAL
91818: IFTRUE 91822
91820: GO 91829
91822: POP
// hHackInvincible ; 5 :
91823: CALL 103593 0 0
91827: GO 91890
91829: LD_INT 5
91831: DOUBLE
91832: EQUAL
91833: IFTRUE 91837
91835: GO 91844
91837: POP
// hHackInvisible ; 6 :
91838: CALL 103704 0 0
91842: GO 91890
91844: LD_INT 6
91846: DOUBLE
91847: EQUAL
91848: IFTRUE 91852
91850: GO 91859
91852: POP
// hHackChangeYourSide ; 7 :
91853: CALL 103761 0 0
91857: GO 91890
91859: LD_INT 7
91861: DOUBLE
91862: EQUAL
91863: IFTRUE 91867
91865: GO 91874
91867: POP
// hHackChangeUnitSide ; 8 :
91868: CALL 103803 0 0
91872: GO 91890
91874: LD_INT 8
91876: DOUBLE
91877: EQUAL
91878: IFTRUE 91882
91880: GO 91889
91882: POP
// hHackFog ; end ;
91883: CALL 103904 0 0
91887: GO 91890
91889: POP
// end ; end ;
91890: LD_VAR 0 7
91894: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
91895: GO 91897
91897: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
91898: LD_STRING initStreamRollete();
91900: PPUSH
91901: CALL_OW 559
// InitStreamMode ;
91905: CALL 91914 0 0
// DefineStreamItems ( ) ;
91909: CALL 92354 0 0
// end ;
91913: END
// function InitStreamMode ; begin
91914: LD_INT 0
91916: PPUSH
// streamModeActive := false ;
91917: LD_ADDR_EXP 98
91921: PUSH
91922: LD_INT 0
91924: ST_TO_ADDR
// normalCounter := 36 ;
91925: LD_ADDR_EXP 99
91929: PUSH
91930: LD_INT 36
91932: ST_TO_ADDR
// hardcoreCounter := 16 ;
91933: LD_ADDR_EXP 100
91937: PUSH
91938: LD_INT 16
91940: ST_TO_ADDR
// sRocket := false ;
91941: LD_ADDR_EXP 103
91945: PUSH
91946: LD_INT 0
91948: ST_TO_ADDR
// sSpeed := false ;
91949: LD_ADDR_EXP 102
91953: PUSH
91954: LD_INT 0
91956: ST_TO_ADDR
// sEngine := false ;
91957: LD_ADDR_EXP 104
91961: PUSH
91962: LD_INT 0
91964: ST_TO_ADDR
// sSpec := false ;
91965: LD_ADDR_EXP 101
91969: PUSH
91970: LD_INT 0
91972: ST_TO_ADDR
// sLevel := false ;
91973: LD_ADDR_EXP 105
91977: PUSH
91978: LD_INT 0
91980: ST_TO_ADDR
// sArmoury := false ;
91981: LD_ADDR_EXP 106
91985: PUSH
91986: LD_INT 0
91988: ST_TO_ADDR
// sRadar := false ;
91989: LD_ADDR_EXP 107
91993: PUSH
91994: LD_INT 0
91996: ST_TO_ADDR
// sBunker := false ;
91997: LD_ADDR_EXP 108
92001: PUSH
92002: LD_INT 0
92004: ST_TO_ADDR
// sHack := false ;
92005: LD_ADDR_EXP 109
92009: PUSH
92010: LD_INT 0
92012: ST_TO_ADDR
// sFire := false ;
92013: LD_ADDR_EXP 110
92017: PUSH
92018: LD_INT 0
92020: ST_TO_ADDR
// sRefresh := false ;
92021: LD_ADDR_EXP 111
92025: PUSH
92026: LD_INT 0
92028: ST_TO_ADDR
// sExp := false ;
92029: LD_ADDR_EXP 112
92033: PUSH
92034: LD_INT 0
92036: ST_TO_ADDR
// sDepot := false ;
92037: LD_ADDR_EXP 113
92041: PUSH
92042: LD_INT 0
92044: ST_TO_ADDR
// sFlag := false ;
92045: LD_ADDR_EXP 114
92049: PUSH
92050: LD_INT 0
92052: ST_TO_ADDR
// sKamikadze := false ;
92053: LD_ADDR_EXP 122
92057: PUSH
92058: LD_INT 0
92060: ST_TO_ADDR
// sTroll := false ;
92061: LD_ADDR_EXP 123
92065: PUSH
92066: LD_INT 0
92068: ST_TO_ADDR
// sSlow := false ;
92069: LD_ADDR_EXP 124
92073: PUSH
92074: LD_INT 0
92076: ST_TO_ADDR
// sLack := false ;
92077: LD_ADDR_EXP 125
92081: PUSH
92082: LD_INT 0
92084: ST_TO_ADDR
// sTank := false ;
92085: LD_ADDR_EXP 127
92089: PUSH
92090: LD_INT 0
92092: ST_TO_ADDR
// sRemote := false ;
92093: LD_ADDR_EXP 128
92097: PUSH
92098: LD_INT 0
92100: ST_TO_ADDR
// sPowell := false ;
92101: LD_ADDR_EXP 129
92105: PUSH
92106: LD_INT 0
92108: ST_TO_ADDR
// sTeleport := false ;
92109: LD_ADDR_EXP 132
92113: PUSH
92114: LD_INT 0
92116: ST_TO_ADDR
// sOilTower := false ;
92117: LD_ADDR_EXP 134
92121: PUSH
92122: LD_INT 0
92124: ST_TO_ADDR
// sShovel := false ;
92125: LD_ADDR_EXP 135
92129: PUSH
92130: LD_INT 0
92132: ST_TO_ADDR
// sSheik := false ;
92133: LD_ADDR_EXP 136
92137: PUSH
92138: LD_INT 0
92140: ST_TO_ADDR
// sEarthquake := false ;
92141: LD_ADDR_EXP 138
92145: PUSH
92146: LD_INT 0
92148: ST_TO_ADDR
// sAI := false ;
92149: LD_ADDR_EXP 139
92153: PUSH
92154: LD_INT 0
92156: ST_TO_ADDR
// sCargo := false ;
92157: LD_ADDR_EXP 142
92161: PUSH
92162: LD_INT 0
92164: ST_TO_ADDR
// sDLaser := false ;
92165: LD_ADDR_EXP 143
92169: PUSH
92170: LD_INT 0
92172: ST_TO_ADDR
// sExchange := false ;
92173: LD_ADDR_EXP 144
92177: PUSH
92178: LD_INT 0
92180: ST_TO_ADDR
// sFac := false ;
92181: LD_ADDR_EXP 145
92185: PUSH
92186: LD_INT 0
92188: ST_TO_ADDR
// sPower := false ;
92189: LD_ADDR_EXP 146
92193: PUSH
92194: LD_INT 0
92196: ST_TO_ADDR
// sRandom := false ;
92197: LD_ADDR_EXP 147
92201: PUSH
92202: LD_INT 0
92204: ST_TO_ADDR
// sShield := false ;
92205: LD_ADDR_EXP 148
92209: PUSH
92210: LD_INT 0
92212: ST_TO_ADDR
// sTime := false ;
92213: LD_ADDR_EXP 149
92217: PUSH
92218: LD_INT 0
92220: ST_TO_ADDR
// sTools := false ;
92221: LD_ADDR_EXP 150
92225: PUSH
92226: LD_INT 0
92228: ST_TO_ADDR
// sSold := false ;
92229: LD_ADDR_EXP 115
92233: PUSH
92234: LD_INT 0
92236: ST_TO_ADDR
// sDiff := false ;
92237: LD_ADDR_EXP 116
92241: PUSH
92242: LD_INT 0
92244: ST_TO_ADDR
// sFog := false ;
92245: LD_ADDR_EXP 119
92249: PUSH
92250: LD_INT 0
92252: ST_TO_ADDR
// sReset := false ;
92253: LD_ADDR_EXP 120
92257: PUSH
92258: LD_INT 0
92260: ST_TO_ADDR
// sSun := false ;
92261: LD_ADDR_EXP 121
92265: PUSH
92266: LD_INT 0
92268: ST_TO_ADDR
// sTiger := false ;
92269: LD_ADDR_EXP 117
92273: PUSH
92274: LD_INT 0
92276: ST_TO_ADDR
// sBomb := false ;
92277: LD_ADDR_EXP 118
92281: PUSH
92282: LD_INT 0
92284: ST_TO_ADDR
// sWound := false ;
92285: LD_ADDR_EXP 126
92289: PUSH
92290: LD_INT 0
92292: ST_TO_ADDR
// sBetray := false ;
92293: LD_ADDR_EXP 130
92297: PUSH
92298: LD_INT 0
92300: ST_TO_ADDR
// sContamin := false ;
92301: LD_ADDR_EXP 131
92305: PUSH
92306: LD_INT 0
92308: ST_TO_ADDR
// sOil := false ;
92309: LD_ADDR_EXP 133
92313: PUSH
92314: LD_INT 0
92316: ST_TO_ADDR
// sStu := false ;
92317: LD_ADDR_EXP 137
92321: PUSH
92322: LD_INT 0
92324: ST_TO_ADDR
// sBazooka := false ;
92325: LD_ADDR_EXP 140
92329: PUSH
92330: LD_INT 0
92332: ST_TO_ADDR
// sMortar := false ;
92333: LD_ADDR_EXP 141
92337: PUSH
92338: LD_INT 0
92340: ST_TO_ADDR
// sRanger := false ;
92341: LD_ADDR_EXP 151
92345: PUSH
92346: LD_INT 0
92348: ST_TO_ADDR
// end ;
92349: LD_VAR 0 1
92353: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
92354: LD_INT 0
92356: PPUSH
92357: PPUSH
92358: PPUSH
92359: PPUSH
92360: PPUSH
// result := [ ] ;
92361: LD_ADDR_VAR 0 1
92365: PUSH
92366: EMPTY
92367: ST_TO_ADDR
// if campaign_id = 1 then
92368: LD_OWVAR 69
92372: PUSH
92373: LD_INT 1
92375: EQUAL
92376: IFFALSE 95314
// begin case mission_number of 1 :
92378: LD_OWVAR 70
92382: PUSH
92383: LD_INT 1
92385: DOUBLE
92386: EQUAL
92387: IFTRUE 92391
92389: GO 92455
92391: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
92392: LD_ADDR_VAR 0 1
92396: PUSH
92397: LD_INT 2
92399: PUSH
92400: LD_INT 4
92402: PUSH
92403: LD_INT 11
92405: PUSH
92406: LD_INT 12
92408: PUSH
92409: LD_INT 15
92411: PUSH
92412: LD_INT 16
92414: PUSH
92415: LD_INT 22
92417: PUSH
92418: LD_INT 23
92420: PUSH
92421: LD_INT 26
92423: PUSH
92424: EMPTY
92425: LIST
92426: LIST
92427: LIST
92428: LIST
92429: LIST
92430: LIST
92431: LIST
92432: LIST
92433: LIST
92434: PUSH
92435: LD_INT 101
92437: PUSH
92438: LD_INT 102
92440: PUSH
92441: LD_INT 106
92443: PUSH
92444: EMPTY
92445: LIST
92446: LIST
92447: LIST
92448: PUSH
92449: EMPTY
92450: LIST
92451: LIST
92452: ST_TO_ADDR
92453: GO 95312
92455: LD_INT 2
92457: DOUBLE
92458: EQUAL
92459: IFTRUE 92463
92461: GO 92535
92463: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
92464: LD_ADDR_VAR 0 1
92468: PUSH
92469: LD_INT 2
92471: PUSH
92472: LD_INT 4
92474: PUSH
92475: LD_INT 11
92477: PUSH
92478: LD_INT 12
92480: PUSH
92481: LD_INT 15
92483: PUSH
92484: LD_INT 16
92486: PUSH
92487: LD_INT 22
92489: PUSH
92490: LD_INT 23
92492: PUSH
92493: LD_INT 26
92495: PUSH
92496: EMPTY
92497: LIST
92498: LIST
92499: LIST
92500: LIST
92501: LIST
92502: LIST
92503: LIST
92504: LIST
92505: LIST
92506: PUSH
92507: LD_INT 101
92509: PUSH
92510: LD_INT 102
92512: PUSH
92513: LD_INT 105
92515: PUSH
92516: LD_INT 106
92518: PUSH
92519: LD_INT 108
92521: PUSH
92522: EMPTY
92523: LIST
92524: LIST
92525: LIST
92526: LIST
92527: LIST
92528: PUSH
92529: EMPTY
92530: LIST
92531: LIST
92532: ST_TO_ADDR
92533: GO 95312
92535: LD_INT 3
92537: DOUBLE
92538: EQUAL
92539: IFTRUE 92543
92541: GO 92619
92543: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
92544: LD_ADDR_VAR 0 1
92548: PUSH
92549: LD_INT 2
92551: PUSH
92552: LD_INT 4
92554: PUSH
92555: LD_INT 5
92557: PUSH
92558: LD_INT 11
92560: PUSH
92561: LD_INT 12
92563: PUSH
92564: LD_INT 15
92566: PUSH
92567: LD_INT 16
92569: PUSH
92570: LD_INT 22
92572: PUSH
92573: LD_INT 26
92575: PUSH
92576: LD_INT 36
92578: PUSH
92579: EMPTY
92580: LIST
92581: LIST
92582: LIST
92583: LIST
92584: LIST
92585: LIST
92586: LIST
92587: LIST
92588: LIST
92589: LIST
92590: PUSH
92591: LD_INT 101
92593: PUSH
92594: LD_INT 102
92596: PUSH
92597: LD_INT 105
92599: PUSH
92600: LD_INT 106
92602: PUSH
92603: LD_INT 108
92605: PUSH
92606: EMPTY
92607: LIST
92608: LIST
92609: LIST
92610: LIST
92611: LIST
92612: PUSH
92613: EMPTY
92614: LIST
92615: LIST
92616: ST_TO_ADDR
92617: GO 95312
92619: LD_INT 4
92621: DOUBLE
92622: EQUAL
92623: IFTRUE 92627
92625: GO 92711
92627: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
92628: LD_ADDR_VAR 0 1
92632: PUSH
92633: LD_INT 2
92635: PUSH
92636: LD_INT 4
92638: PUSH
92639: LD_INT 5
92641: PUSH
92642: LD_INT 8
92644: PUSH
92645: LD_INT 11
92647: PUSH
92648: LD_INT 12
92650: PUSH
92651: LD_INT 15
92653: PUSH
92654: LD_INT 16
92656: PUSH
92657: LD_INT 22
92659: PUSH
92660: LD_INT 23
92662: PUSH
92663: LD_INT 26
92665: PUSH
92666: LD_INT 36
92668: PUSH
92669: EMPTY
92670: LIST
92671: LIST
92672: LIST
92673: LIST
92674: LIST
92675: LIST
92676: LIST
92677: LIST
92678: LIST
92679: LIST
92680: LIST
92681: LIST
92682: PUSH
92683: LD_INT 101
92685: PUSH
92686: LD_INT 102
92688: PUSH
92689: LD_INT 105
92691: PUSH
92692: LD_INT 106
92694: PUSH
92695: LD_INT 108
92697: PUSH
92698: EMPTY
92699: LIST
92700: LIST
92701: LIST
92702: LIST
92703: LIST
92704: PUSH
92705: EMPTY
92706: LIST
92707: LIST
92708: ST_TO_ADDR
92709: GO 95312
92711: LD_INT 5
92713: DOUBLE
92714: EQUAL
92715: IFTRUE 92719
92717: GO 92819
92719: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
92720: LD_ADDR_VAR 0 1
92724: PUSH
92725: LD_INT 2
92727: PUSH
92728: LD_INT 4
92730: PUSH
92731: LD_INT 5
92733: PUSH
92734: LD_INT 6
92736: PUSH
92737: LD_INT 8
92739: PUSH
92740: LD_INT 11
92742: PUSH
92743: LD_INT 12
92745: PUSH
92746: LD_INT 15
92748: PUSH
92749: LD_INT 16
92751: PUSH
92752: LD_INT 22
92754: PUSH
92755: LD_INT 23
92757: PUSH
92758: LD_INT 25
92760: PUSH
92761: LD_INT 26
92763: PUSH
92764: LD_INT 36
92766: PUSH
92767: EMPTY
92768: LIST
92769: LIST
92770: LIST
92771: LIST
92772: LIST
92773: LIST
92774: LIST
92775: LIST
92776: LIST
92777: LIST
92778: LIST
92779: LIST
92780: LIST
92781: LIST
92782: PUSH
92783: LD_INT 101
92785: PUSH
92786: LD_INT 102
92788: PUSH
92789: LD_INT 105
92791: PUSH
92792: LD_INT 106
92794: PUSH
92795: LD_INT 108
92797: PUSH
92798: LD_INT 109
92800: PUSH
92801: LD_INT 112
92803: PUSH
92804: EMPTY
92805: LIST
92806: LIST
92807: LIST
92808: LIST
92809: LIST
92810: LIST
92811: LIST
92812: PUSH
92813: EMPTY
92814: LIST
92815: LIST
92816: ST_TO_ADDR
92817: GO 95312
92819: LD_INT 6
92821: DOUBLE
92822: EQUAL
92823: IFTRUE 92827
92825: GO 92947
92827: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
92828: LD_ADDR_VAR 0 1
92832: PUSH
92833: LD_INT 2
92835: PUSH
92836: LD_INT 4
92838: PUSH
92839: LD_INT 5
92841: PUSH
92842: LD_INT 6
92844: PUSH
92845: LD_INT 8
92847: PUSH
92848: LD_INT 11
92850: PUSH
92851: LD_INT 12
92853: PUSH
92854: LD_INT 15
92856: PUSH
92857: LD_INT 16
92859: PUSH
92860: LD_INT 20
92862: PUSH
92863: LD_INT 21
92865: PUSH
92866: LD_INT 22
92868: PUSH
92869: LD_INT 23
92871: PUSH
92872: LD_INT 25
92874: PUSH
92875: LD_INT 26
92877: PUSH
92878: LD_INT 30
92880: PUSH
92881: LD_INT 31
92883: PUSH
92884: LD_INT 32
92886: PUSH
92887: LD_INT 36
92889: PUSH
92890: EMPTY
92891: LIST
92892: LIST
92893: LIST
92894: LIST
92895: LIST
92896: LIST
92897: LIST
92898: LIST
92899: LIST
92900: LIST
92901: LIST
92902: LIST
92903: LIST
92904: LIST
92905: LIST
92906: LIST
92907: LIST
92908: LIST
92909: LIST
92910: PUSH
92911: LD_INT 101
92913: PUSH
92914: LD_INT 102
92916: PUSH
92917: LD_INT 105
92919: PUSH
92920: LD_INT 106
92922: PUSH
92923: LD_INT 108
92925: PUSH
92926: LD_INT 109
92928: PUSH
92929: LD_INT 112
92931: PUSH
92932: EMPTY
92933: LIST
92934: LIST
92935: LIST
92936: LIST
92937: LIST
92938: LIST
92939: LIST
92940: PUSH
92941: EMPTY
92942: LIST
92943: LIST
92944: ST_TO_ADDR
92945: GO 95312
92947: LD_INT 7
92949: DOUBLE
92950: EQUAL
92951: IFTRUE 92955
92953: GO 93055
92955: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
92956: LD_ADDR_VAR 0 1
92960: PUSH
92961: LD_INT 2
92963: PUSH
92964: LD_INT 4
92966: PUSH
92967: LD_INT 5
92969: PUSH
92970: LD_INT 7
92972: PUSH
92973: LD_INT 11
92975: PUSH
92976: LD_INT 12
92978: PUSH
92979: LD_INT 15
92981: PUSH
92982: LD_INT 16
92984: PUSH
92985: LD_INT 20
92987: PUSH
92988: LD_INT 21
92990: PUSH
92991: LD_INT 22
92993: PUSH
92994: LD_INT 23
92996: PUSH
92997: LD_INT 25
92999: PUSH
93000: LD_INT 26
93002: PUSH
93003: EMPTY
93004: LIST
93005: LIST
93006: LIST
93007: LIST
93008: LIST
93009: LIST
93010: LIST
93011: LIST
93012: LIST
93013: LIST
93014: LIST
93015: LIST
93016: LIST
93017: LIST
93018: PUSH
93019: LD_INT 101
93021: PUSH
93022: LD_INT 102
93024: PUSH
93025: LD_INT 103
93027: PUSH
93028: LD_INT 105
93030: PUSH
93031: LD_INT 106
93033: PUSH
93034: LD_INT 108
93036: PUSH
93037: LD_INT 112
93039: PUSH
93040: EMPTY
93041: LIST
93042: LIST
93043: LIST
93044: LIST
93045: LIST
93046: LIST
93047: LIST
93048: PUSH
93049: EMPTY
93050: LIST
93051: LIST
93052: ST_TO_ADDR
93053: GO 95312
93055: LD_INT 8
93057: DOUBLE
93058: EQUAL
93059: IFTRUE 93063
93061: GO 93191
93063: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
93064: LD_ADDR_VAR 0 1
93068: PUSH
93069: LD_INT 2
93071: PUSH
93072: LD_INT 4
93074: PUSH
93075: LD_INT 5
93077: PUSH
93078: LD_INT 6
93080: PUSH
93081: LD_INT 7
93083: PUSH
93084: LD_INT 8
93086: PUSH
93087: LD_INT 11
93089: PUSH
93090: LD_INT 12
93092: PUSH
93093: LD_INT 15
93095: PUSH
93096: LD_INT 16
93098: PUSH
93099: LD_INT 20
93101: PUSH
93102: LD_INT 21
93104: PUSH
93105: LD_INT 22
93107: PUSH
93108: LD_INT 23
93110: PUSH
93111: LD_INT 25
93113: PUSH
93114: LD_INT 26
93116: PUSH
93117: LD_INT 30
93119: PUSH
93120: LD_INT 31
93122: PUSH
93123: LD_INT 32
93125: PUSH
93126: LD_INT 36
93128: PUSH
93129: EMPTY
93130: LIST
93131: LIST
93132: LIST
93133: LIST
93134: LIST
93135: LIST
93136: LIST
93137: LIST
93138: LIST
93139: LIST
93140: LIST
93141: LIST
93142: LIST
93143: LIST
93144: LIST
93145: LIST
93146: LIST
93147: LIST
93148: LIST
93149: LIST
93150: PUSH
93151: LD_INT 101
93153: PUSH
93154: LD_INT 102
93156: PUSH
93157: LD_INT 103
93159: PUSH
93160: LD_INT 105
93162: PUSH
93163: LD_INT 106
93165: PUSH
93166: LD_INT 108
93168: PUSH
93169: LD_INT 109
93171: PUSH
93172: LD_INT 112
93174: PUSH
93175: EMPTY
93176: LIST
93177: LIST
93178: LIST
93179: LIST
93180: LIST
93181: LIST
93182: LIST
93183: LIST
93184: PUSH
93185: EMPTY
93186: LIST
93187: LIST
93188: ST_TO_ADDR
93189: GO 95312
93191: LD_INT 9
93193: DOUBLE
93194: EQUAL
93195: IFTRUE 93199
93197: GO 93335
93199: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
93200: LD_ADDR_VAR 0 1
93204: PUSH
93205: LD_INT 2
93207: PUSH
93208: LD_INT 4
93210: PUSH
93211: LD_INT 5
93213: PUSH
93214: LD_INT 6
93216: PUSH
93217: LD_INT 7
93219: PUSH
93220: LD_INT 8
93222: PUSH
93223: LD_INT 11
93225: PUSH
93226: LD_INT 12
93228: PUSH
93229: LD_INT 15
93231: PUSH
93232: LD_INT 16
93234: PUSH
93235: LD_INT 20
93237: PUSH
93238: LD_INT 21
93240: PUSH
93241: LD_INT 22
93243: PUSH
93244: LD_INT 23
93246: PUSH
93247: LD_INT 25
93249: PUSH
93250: LD_INT 26
93252: PUSH
93253: LD_INT 28
93255: PUSH
93256: LD_INT 30
93258: PUSH
93259: LD_INT 31
93261: PUSH
93262: LD_INT 32
93264: PUSH
93265: LD_INT 36
93267: PUSH
93268: EMPTY
93269: LIST
93270: LIST
93271: LIST
93272: LIST
93273: LIST
93274: LIST
93275: LIST
93276: LIST
93277: LIST
93278: LIST
93279: LIST
93280: LIST
93281: LIST
93282: LIST
93283: LIST
93284: LIST
93285: LIST
93286: LIST
93287: LIST
93288: LIST
93289: LIST
93290: PUSH
93291: LD_INT 101
93293: PUSH
93294: LD_INT 102
93296: PUSH
93297: LD_INT 103
93299: PUSH
93300: LD_INT 105
93302: PUSH
93303: LD_INT 106
93305: PUSH
93306: LD_INT 108
93308: PUSH
93309: LD_INT 109
93311: PUSH
93312: LD_INT 112
93314: PUSH
93315: LD_INT 114
93317: PUSH
93318: EMPTY
93319: LIST
93320: LIST
93321: LIST
93322: LIST
93323: LIST
93324: LIST
93325: LIST
93326: LIST
93327: LIST
93328: PUSH
93329: EMPTY
93330: LIST
93331: LIST
93332: ST_TO_ADDR
93333: GO 95312
93335: LD_INT 10
93337: DOUBLE
93338: EQUAL
93339: IFTRUE 93343
93341: GO 93527
93343: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
93344: LD_ADDR_VAR 0 1
93348: PUSH
93349: LD_INT 2
93351: PUSH
93352: LD_INT 4
93354: PUSH
93355: LD_INT 5
93357: PUSH
93358: LD_INT 6
93360: PUSH
93361: LD_INT 7
93363: PUSH
93364: LD_INT 8
93366: PUSH
93367: LD_INT 9
93369: PUSH
93370: LD_INT 10
93372: PUSH
93373: LD_INT 11
93375: PUSH
93376: LD_INT 12
93378: PUSH
93379: LD_INT 13
93381: PUSH
93382: LD_INT 14
93384: PUSH
93385: LD_INT 15
93387: PUSH
93388: LD_INT 16
93390: PUSH
93391: LD_INT 17
93393: PUSH
93394: LD_INT 18
93396: PUSH
93397: LD_INT 19
93399: PUSH
93400: LD_INT 20
93402: PUSH
93403: LD_INT 21
93405: PUSH
93406: LD_INT 22
93408: PUSH
93409: LD_INT 23
93411: PUSH
93412: LD_INT 24
93414: PUSH
93415: LD_INT 25
93417: PUSH
93418: LD_INT 26
93420: PUSH
93421: LD_INT 28
93423: PUSH
93424: LD_INT 30
93426: PUSH
93427: LD_INT 31
93429: PUSH
93430: LD_INT 32
93432: PUSH
93433: LD_INT 36
93435: PUSH
93436: EMPTY
93437: LIST
93438: LIST
93439: LIST
93440: LIST
93441: LIST
93442: LIST
93443: LIST
93444: LIST
93445: LIST
93446: LIST
93447: LIST
93448: LIST
93449: LIST
93450: LIST
93451: LIST
93452: LIST
93453: LIST
93454: LIST
93455: LIST
93456: LIST
93457: LIST
93458: LIST
93459: LIST
93460: LIST
93461: LIST
93462: LIST
93463: LIST
93464: LIST
93465: LIST
93466: PUSH
93467: LD_INT 101
93469: PUSH
93470: LD_INT 102
93472: PUSH
93473: LD_INT 103
93475: PUSH
93476: LD_INT 104
93478: PUSH
93479: LD_INT 105
93481: PUSH
93482: LD_INT 106
93484: PUSH
93485: LD_INT 107
93487: PUSH
93488: LD_INT 108
93490: PUSH
93491: LD_INT 109
93493: PUSH
93494: LD_INT 110
93496: PUSH
93497: LD_INT 111
93499: PUSH
93500: LD_INT 112
93502: PUSH
93503: LD_INT 114
93505: PUSH
93506: EMPTY
93507: LIST
93508: LIST
93509: LIST
93510: LIST
93511: LIST
93512: LIST
93513: LIST
93514: LIST
93515: LIST
93516: LIST
93517: LIST
93518: LIST
93519: LIST
93520: PUSH
93521: EMPTY
93522: LIST
93523: LIST
93524: ST_TO_ADDR
93525: GO 95312
93527: LD_INT 11
93529: DOUBLE
93530: EQUAL
93531: IFTRUE 93535
93533: GO 93727
93535: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
93536: LD_ADDR_VAR 0 1
93540: PUSH
93541: LD_INT 2
93543: PUSH
93544: LD_INT 3
93546: PUSH
93547: LD_INT 4
93549: PUSH
93550: LD_INT 5
93552: PUSH
93553: LD_INT 6
93555: PUSH
93556: LD_INT 7
93558: PUSH
93559: LD_INT 8
93561: PUSH
93562: LD_INT 9
93564: PUSH
93565: LD_INT 10
93567: PUSH
93568: LD_INT 11
93570: PUSH
93571: LD_INT 12
93573: PUSH
93574: LD_INT 13
93576: PUSH
93577: LD_INT 14
93579: PUSH
93580: LD_INT 15
93582: PUSH
93583: LD_INT 16
93585: PUSH
93586: LD_INT 17
93588: PUSH
93589: LD_INT 18
93591: PUSH
93592: LD_INT 19
93594: PUSH
93595: LD_INT 20
93597: PUSH
93598: LD_INT 21
93600: PUSH
93601: LD_INT 22
93603: PUSH
93604: LD_INT 23
93606: PUSH
93607: LD_INT 24
93609: PUSH
93610: LD_INT 25
93612: PUSH
93613: LD_INT 26
93615: PUSH
93616: LD_INT 28
93618: PUSH
93619: LD_INT 30
93621: PUSH
93622: LD_INT 31
93624: PUSH
93625: LD_INT 32
93627: PUSH
93628: LD_INT 34
93630: PUSH
93631: LD_INT 36
93633: PUSH
93634: EMPTY
93635: LIST
93636: LIST
93637: LIST
93638: LIST
93639: LIST
93640: LIST
93641: LIST
93642: LIST
93643: LIST
93644: LIST
93645: LIST
93646: LIST
93647: LIST
93648: LIST
93649: LIST
93650: LIST
93651: LIST
93652: LIST
93653: LIST
93654: LIST
93655: LIST
93656: LIST
93657: LIST
93658: LIST
93659: LIST
93660: LIST
93661: LIST
93662: LIST
93663: LIST
93664: LIST
93665: LIST
93666: PUSH
93667: LD_INT 101
93669: PUSH
93670: LD_INT 102
93672: PUSH
93673: LD_INT 103
93675: PUSH
93676: LD_INT 104
93678: PUSH
93679: LD_INT 105
93681: PUSH
93682: LD_INT 106
93684: PUSH
93685: LD_INT 107
93687: PUSH
93688: LD_INT 108
93690: PUSH
93691: LD_INT 109
93693: PUSH
93694: LD_INT 110
93696: PUSH
93697: LD_INT 111
93699: PUSH
93700: LD_INT 112
93702: PUSH
93703: LD_INT 114
93705: PUSH
93706: EMPTY
93707: LIST
93708: LIST
93709: LIST
93710: LIST
93711: LIST
93712: LIST
93713: LIST
93714: LIST
93715: LIST
93716: LIST
93717: LIST
93718: LIST
93719: LIST
93720: PUSH
93721: EMPTY
93722: LIST
93723: LIST
93724: ST_TO_ADDR
93725: GO 95312
93727: LD_INT 12
93729: DOUBLE
93730: EQUAL
93731: IFTRUE 93735
93733: GO 93943
93735: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
93736: LD_ADDR_VAR 0 1
93740: PUSH
93741: LD_INT 1
93743: PUSH
93744: LD_INT 2
93746: PUSH
93747: LD_INT 3
93749: PUSH
93750: LD_INT 4
93752: PUSH
93753: LD_INT 5
93755: PUSH
93756: LD_INT 6
93758: PUSH
93759: LD_INT 7
93761: PUSH
93762: LD_INT 8
93764: PUSH
93765: LD_INT 9
93767: PUSH
93768: LD_INT 10
93770: PUSH
93771: LD_INT 11
93773: PUSH
93774: LD_INT 12
93776: PUSH
93777: LD_INT 13
93779: PUSH
93780: LD_INT 14
93782: PUSH
93783: LD_INT 15
93785: PUSH
93786: LD_INT 16
93788: PUSH
93789: LD_INT 17
93791: PUSH
93792: LD_INT 18
93794: PUSH
93795: LD_INT 19
93797: PUSH
93798: LD_INT 20
93800: PUSH
93801: LD_INT 21
93803: PUSH
93804: LD_INT 22
93806: PUSH
93807: LD_INT 23
93809: PUSH
93810: LD_INT 24
93812: PUSH
93813: LD_INT 25
93815: PUSH
93816: LD_INT 26
93818: PUSH
93819: LD_INT 27
93821: PUSH
93822: LD_INT 28
93824: PUSH
93825: LD_INT 30
93827: PUSH
93828: LD_INT 31
93830: PUSH
93831: LD_INT 32
93833: PUSH
93834: LD_INT 33
93836: PUSH
93837: LD_INT 34
93839: PUSH
93840: LD_INT 36
93842: PUSH
93843: EMPTY
93844: LIST
93845: LIST
93846: LIST
93847: LIST
93848: LIST
93849: LIST
93850: LIST
93851: LIST
93852: LIST
93853: LIST
93854: LIST
93855: LIST
93856: LIST
93857: LIST
93858: LIST
93859: LIST
93860: LIST
93861: LIST
93862: LIST
93863: LIST
93864: LIST
93865: LIST
93866: LIST
93867: LIST
93868: LIST
93869: LIST
93870: LIST
93871: LIST
93872: LIST
93873: LIST
93874: LIST
93875: LIST
93876: LIST
93877: LIST
93878: PUSH
93879: LD_INT 101
93881: PUSH
93882: LD_INT 102
93884: PUSH
93885: LD_INT 103
93887: PUSH
93888: LD_INT 104
93890: PUSH
93891: LD_INT 105
93893: PUSH
93894: LD_INT 106
93896: PUSH
93897: LD_INT 107
93899: PUSH
93900: LD_INT 108
93902: PUSH
93903: LD_INT 109
93905: PUSH
93906: LD_INT 110
93908: PUSH
93909: LD_INT 111
93911: PUSH
93912: LD_INT 112
93914: PUSH
93915: LD_INT 113
93917: PUSH
93918: LD_INT 114
93920: PUSH
93921: EMPTY
93922: LIST
93923: LIST
93924: LIST
93925: LIST
93926: LIST
93927: LIST
93928: LIST
93929: LIST
93930: LIST
93931: LIST
93932: LIST
93933: LIST
93934: LIST
93935: LIST
93936: PUSH
93937: EMPTY
93938: LIST
93939: LIST
93940: ST_TO_ADDR
93941: GO 95312
93943: LD_INT 13
93945: DOUBLE
93946: EQUAL
93947: IFTRUE 93951
93949: GO 94147
93951: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
93952: LD_ADDR_VAR 0 1
93956: PUSH
93957: LD_INT 1
93959: PUSH
93960: LD_INT 2
93962: PUSH
93963: LD_INT 3
93965: PUSH
93966: LD_INT 4
93968: PUSH
93969: LD_INT 5
93971: PUSH
93972: LD_INT 8
93974: PUSH
93975: LD_INT 9
93977: PUSH
93978: LD_INT 10
93980: PUSH
93981: LD_INT 11
93983: PUSH
93984: LD_INT 12
93986: PUSH
93987: LD_INT 14
93989: PUSH
93990: LD_INT 15
93992: PUSH
93993: LD_INT 16
93995: PUSH
93996: LD_INT 17
93998: PUSH
93999: LD_INT 18
94001: PUSH
94002: LD_INT 19
94004: PUSH
94005: LD_INT 20
94007: PUSH
94008: LD_INT 21
94010: PUSH
94011: LD_INT 22
94013: PUSH
94014: LD_INT 23
94016: PUSH
94017: LD_INT 24
94019: PUSH
94020: LD_INT 25
94022: PUSH
94023: LD_INT 26
94025: PUSH
94026: LD_INT 27
94028: PUSH
94029: LD_INT 28
94031: PUSH
94032: LD_INT 30
94034: PUSH
94035: LD_INT 31
94037: PUSH
94038: LD_INT 32
94040: PUSH
94041: LD_INT 33
94043: PUSH
94044: LD_INT 34
94046: PUSH
94047: LD_INT 36
94049: PUSH
94050: EMPTY
94051: LIST
94052: LIST
94053: LIST
94054: LIST
94055: LIST
94056: LIST
94057: LIST
94058: LIST
94059: LIST
94060: LIST
94061: LIST
94062: LIST
94063: LIST
94064: LIST
94065: LIST
94066: LIST
94067: LIST
94068: LIST
94069: LIST
94070: LIST
94071: LIST
94072: LIST
94073: LIST
94074: LIST
94075: LIST
94076: LIST
94077: LIST
94078: LIST
94079: LIST
94080: LIST
94081: LIST
94082: PUSH
94083: LD_INT 101
94085: PUSH
94086: LD_INT 102
94088: PUSH
94089: LD_INT 103
94091: PUSH
94092: LD_INT 104
94094: PUSH
94095: LD_INT 105
94097: PUSH
94098: LD_INT 106
94100: PUSH
94101: LD_INT 107
94103: PUSH
94104: LD_INT 108
94106: PUSH
94107: LD_INT 109
94109: PUSH
94110: LD_INT 110
94112: PUSH
94113: LD_INT 111
94115: PUSH
94116: LD_INT 112
94118: PUSH
94119: LD_INT 113
94121: PUSH
94122: LD_INT 114
94124: PUSH
94125: EMPTY
94126: LIST
94127: LIST
94128: LIST
94129: LIST
94130: LIST
94131: LIST
94132: LIST
94133: LIST
94134: LIST
94135: LIST
94136: LIST
94137: LIST
94138: LIST
94139: LIST
94140: PUSH
94141: EMPTY
94142: LIST
94143: LIST
94144: ST_TO_ADDR
94145: GO 95312
94147: LD_INT 14
94149: DOUBLE
94150: EQUAL
94151: IFTRUE 94155
94153: GO 94367
94155: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
94156: LD_ADDR_VAR 0 1
94160: PUSH
94161: LD_INT 1
94163: PUSH
94164: LD_INT 2
94166: PUSH
94167: LD_INT 3
94169: PUSH
94170: LD_INT 4
94172: PUSH
94173: LD_INT 5
94175: PUSH
94176: LD_INT 6
94178: PUSH
94179: LD_INT 7
94181: PUSH
94182: LD_INT 8
94184: PUSH
94185: LD_INT 9
94187: PUSH
94188: LD_INT 10
94190: PUSH
94191: LD_INT 11
94193: PUSH
94194: LD_INT 12
94196: PUSH
94197: LD_INT 13
94199: PUSH
94200: LD_INT 14
94202: PUSH
94203: LD_INT 15
94205: PUSH
94206: LD_INT 16
94208: PUSH
94209: LD_INT 17
94211: PUSH
94212: LD_INT 18
94214: PUSH
94215: LD_INT 19
94217: PUSH
94218: LD_INT 20
94220: PUSH
94221: LD_INT 21
94223: PUSH
94224: LD_INT 22
94226: PUSH
94227: LD_INT 23
94229: PUSH
94230: LD_INT 24
94232: PUSH
94233: LD_INT 25
94235: PUSH
94236: LD_INT 26
94238: PUSH
94239: LD_INT 27
94241: PUSH
94242: LD_INT 28
94244: PUSH
94245: LD_INT 29
94247: PUSH
94248: LD_INT 30
94250: PUSH
94251: LD_INT 31
94253: PUSH
94254: LD_INT 32
94256: PUSH
94257: LD_INT 33
94259: PUSH
94260: LD_INT 34
94262: PUSH
94263: LD_INT 36
94265: PUSH
94266: EMPTY
94267: LIST
94268: LIST
94269: LIST
94270: LIST
94271: LIST
94272: LIST
94273: LIST
94274: LIST
94275: LIST
94276: LIST
94277: LIST
94278: LIST
94279: LIST
94280: LIST
94281: LIST
94282: LIST
94283: LIST
94284: LIST
94285: LIST
94286: LIST
94287: LIST
94288: LIST
94289: LIST
94290: LIST
94291: LIST
94292: LIST
94293: LIST
94294: LIST
94295: LIST
94296: LIST
94297: LIST
94298: LIST
94299: LIST
94300: LIST
94301: LIST
94302: PUSH
94303: LD_INT 101
94305: PUSH
94306: LD_INT 102
94308: PUSH
94309: LD_INT 103
94311: PUSH
94312: LD_INT 104
94314: PUSH
94315: LD_INT 105
94317: PUSH
94318: LD_INT 106
94320: PUSH
94321: LD_INT 107
94323: PUSH
94324: LD_INT 108
94326: PUSH
94327: LD_INT 109
94329: PUSH
94330: LD_INT 110
94332: PUSH
94333: LD_INT 111
94335: PUSH
94336: LD_INT 112
94338: PUSH
94339: LD_INT 113
94341: PUSH
94342: LD_INT 114
94344: PUSH
94345: EMPTY
94346: LIST
94347: LIST
94348: LIST
94349: LIST
94350: LIST
94351: LIST
94352: LIST
94353: LIST
94354: LIST
94355: LIST
94356: LIST
94357: LIST
94358: LIST
94359: LIST
94360: PUSH
94361: EMPTY
94362: LIST
94363: LIST
94364: ST_TO_ADDR
94365: GO 95312
94367: LD_INT 15
94369: DOUBLE
94370: EQUAL
94371: IFTRUE 94375
94373: GO 94587
94375: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
94376: LD_ADDR_VAR 0 1
94380: PUSH
94381: LD_INT 1
94383: PUSH
94384: LD_INT 2
94386: PUSH
94387: LD_INT 3
94389: PUSH
94390: LD_INT 4
94392: PUSH
94393: LD_INT 5
94395: PUSH
94396: LD_INT 6
94398: PUSH
94399: LD_INT 7
94401: PUSH
94402: LD_INT 8
94404: PUSH
94405: LD_INT 9
94407: PUSH
94408: LD_INT 10
94410: PUSH
94411: LD_INT 11
94413: PUSH
94414: LD_INT 12
94416: PUSH
94417: LD_INT 13
94419: PUSH
94420: LD_INT 14
94422: PUSH
94423: LD_INT 15
94425: PUSH
94426: LD_INT 16
94428: PUSH
94429: LD_INT 17
94431: PUSH
94432: LD_INT 18
94434: PUSH
94435: LD_INT 19
94437: PUSH
94438: LD_INT 20
94440: PUSH
94441: LD_INT 21
94443: PUSH
94444: LD_INT 22
94446: PUSH
94447: LD_INT 23
94449: PUSH
94450: LD_INT 24
94452: PUSH
94453: LD_INT 25
94455: PUSH
94456: LD_INT 26
94458: PUSH
94459: LD_INT 27
94461: PUSH
94462: LD_INT 28
94464: PUSH
94465: LD_INT 29
94467: PUSH
94468: LD_INT 30
94470: PUSH
94471: LD_INT 31
94473: PUSH
94474: LD_INT 32
94476: PUSH
94477: LD_INT 33
94479: PUSH
94480: LD_INT 34
94482: PUSH
94483: LD_INT 36
94485: PUSH
94486: EMPTY
94487: LIST
94488: LIST
94489: LIST
94490: LIST
94491: LIST
94492: LIST
94493: LIST
94494: LIST
94495: LIST
94496: LIST
94497: LIST
94498: LIST
94499: LIST
94500: LIST
94501: LIST
94502: LIST
94503: LIST
94504: LIST
94505: LIST
94506: LIST
94507: LIST
94508: LIST
94509: LIST
94510: LIST
94511: LIST
94512: LIST
94513: LIST
94514: LIST
94515: LIST
94516: LIST
94517: LIST
94518: LIST
94519: LIST
94520: LIST
94521: LIST
94522: PUSH
94523: LD_INT 101
94525: PUSH
94526: LD_INT 102
94528: PUSH
94529: LD_INT 103
94531: PUSH
94532: LD_INT 104
94534: PUSH
94535: LD_INT 105
94537: PUSH
94538: LD_INT 106
94540: PUSH
94541: LD_INT 107
94543: PUSH
94544: LD_INT 108
94546: PUSH
94547: LD_INT 109
94549: PUSH
94550: LD_INT 110
94552: PUSH
94553: LD_INT 111
94555: PUSH
94556: LD_INT 112
94558: PUSH
94559: LD_INT 113
94561: PUSH
94562: LD_INT 114
94564: PUSH
94565: EMPTY
94566: LIST
94567: LIST
94568: LIST
94569: LIST
94570: LIST
94571: LIST
94572: LIST
94573: LIST
94574: LIST
94575: LIST
94576: LIST
94577: LIST
94578: LIST
94579: LIST
94580: PUSH
94581: EMPTY
94582: LIST
94583: LIST
94584: ST_TO_ADDR
94585: GO 95312
94587: LD_INT 16
94589: DOUBLE
94590: EQUAL
94591: IFTRUE 94595
94593: GO 94719
94595: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
94596: LD_ADDR_VAR 0 1
94600: PUSH
94601: LD_INT 2
94603: PUSH
94604: LD_INT 4
94606: PUSH
94607: LD_INT 5
94609: PUSH
94610: LD_INT 7
94612: PUSH
94613: LD_INT 11
94615: PUSH
94616: LD_INT 12
94618: PUSH
94619: LD_INT 15
94621: PUSH
94622: LD_INT 16
94624: PUSH
94625: LD_INT 20
94627: PUSH
94628: LD_INT 21
94630: PUSH
94631: LD_INT 22
94633: PUSH
94634: LD_INT 23
94636: PUSH
94637: LD_INT 25
94639: PUSH
94640: LD_INT 26
94642: PUSH
94643: LD_INT 30
94645: PUSH
94646: LD_INT 31
94648: PUSH
94649: LD_INT 32
94651: PUSH
94652: LD_INT 33
94654: PUSH
94655: LD_INT 34
94657: PUSH
94658: EMPTY
94659: LIST
94660: LIST
94661: LIST
94662: LIST
94663: LIST
94664: LIST
94665: LIST
94666: LIST
94667: LIST
94668: LIST
94669: LIST
94670: LIST
94671: LIST
94672: LIST
94673: LIST
94674: LIST
94675: LIST
94676: LIST
94677: LIST
94678: PUSH
94679: LD_INT 101
94681: PUSH
94682: LD_INT 102
94684: PUSH
94685: LD_INT 103
94687: PUSH
94688: LD_INT 106
94690: PUSH
94691: LD_INT 108
94693: PUSH
94694: LD_INT 112
94696: PUSH
94697: LD_INT 113
94699: PUSH
94700: LD_INT 114
94702: PUSH
94703: EMPTY
94704: LIST
94705: LIST
94706: LIST
94707: LIST
94708: LIST
94709: LIST
94710: LIST
94711: LIST
94712: PUSH
94713: EMPTY
94714: LIST
94715: LIST
94716: ST_TO_ADDR
94717: GO 95312
94719: LD_INT 17
94721: DOUBLE
94722: EQUAL
94723: IFTRUE 94727
94725: GO 94939
94727: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
94728: LD_ADDR_VAR 0 1
94732: PUSH
94733: LD_INT 1
94735: PUSH
94736: LD_INT 2
94738: PUSH
94739: LD_INT 3
94741: PUSH
94742: LD_INT 4
94744: PUSH
94745: LD_INT 5
94747: PUSH
94748: LD_INT 6
94750: PUSH
94751: LD_INT 7
94753: PUSH
94754: LD_INT 8
94756: PUSH
94757: LD_INT 9
94759: PUSH
94760: LD_INT 10
94762: PUSH
94763: LD_INT 11
94765: PUSH
94766: LD_INT 12
94768: PUSH
94769: LD_INT 13
94771: PUSH
94772: LD_INT 14
94774: PUSH
94775: LD_INT 15
94777: PUSH
94778: LD_INT 16
94780: PUSH
94781: LD_INT 17
94783: PUSH
94784: LD_INT 18
94786: PUSH
94787: LD_INT 19
94789: PUSH
94790: LD_INT 20
94792: PUSH
94793: LD_INT 21
94795: PUSH
94796: LD_INT 22
94798: PUSH
94799: LD_INT 23
94801: PUSH
94802: LD_INT 24
94804: PUSH
94805: LD_INT 25
94807: PUSH
94808: LD_INT 26
94810: PUSH
94811: LD_INT 27
94813: PUSH
94814: LD_INT 28
94816: PUSH
94817: LD_INT 29
94819: PUSH
94820: LD_INT 30
94822: PUSH
94823: LD_INT 31
94825: PUSH
94826: LD_INT 32
94828: PUSH
94829: LD_INT 33
94831: PUSH
94832: LD_INT 34
94834: PUSH
94835: LD_INT 36
94837: PUSH
94838: EMPTY
94839: LIST
94840: LIST
94841: LIST
94842: LIST
94843: LIST
94844: LIST
94845: LIST
94846: LIST
94847: LIST
94848: LIST
94849: LIST
94850: LIST
94851: LIST
94852: LIST
94853: LIST
94854: LIST
94855: LIST
94856: LIST
94857: LIST
94858: LIST
94859: LIST
94860: LIST
94861: LIST
94862: LIST
94863: LIST
94864: LIST
94865: LIST
94866: LIST
94867: LIST
94868: LIST
94869: LIST
94870: LIST
94871: LIST
94872: LIST
94873: LIST
94874: PUSH
94875: LD_INT 101
94877: PUSH
94878: LD_INT 102
94880: PUSH
94881: LD_INT 103
94883: PUSH
94884: LD_INT 104
94886: PUSH
94887: LD_INT 105
94889: PUSH
94890: LD_INT 106
94892: PUSH
94893: LD_INT 107
94895: PUSH
94896: LD_INT 108
94898: PUSH
94899: LD_INT 109
94901: PUSH
94902: LD_INT 110
94904: PUSH
94905: LD_INT 111
94907: PUSH
94908: LD_INT 112
94910: PUSH
94911: LD_INT 113
94913: PUSH
94914: LD_INT 114
94916: PUSH
94917: EMPTY
94918: LIST
94919: LIST
94920: LIST
94921: LIST
94922: LIST
94923: LIST
94924: LIST
94925: LIST
94926: LIST
94927: LIST
94928: LIST
94929: LIST
94930: LIST
94931: LIST
94932: PUSH
94933: EMPTY
94934: LIST
94935: LIST
94936: ST_TO_ADDR
94937: GO 95312
94939: LD_INT 18
94941: DOUBLE
94942: EQUAL
94943: IFTRUE 94947
94945: GO 95083
94947: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
94948: LD_ADDR_VAR 0 1
94952: PUSH
94953: LD_INT 2
94955: PUSH
94956: LD_INT 4
94958: PUSH
94959: LD_INT 5
94961: PUSH
94962: LD_INT 7
94964: PUSH
94965: LD_INT 11
94967: PUSH
94968: LD_INT 12
94970: PUSH
94971: LD_INT 15
94973: PUSH
94974: LD_INT 16
94976: PUSH
94977: LD_INT 20
94979: PUSH
94980: LD_INT 21
94982: PUSH
94983: LD_INT 22
94985: PUSH
94986: LD_INT 23
94988: PUSH
94989: LD_INT 25
94991: PUSH
94992: LD_INT 26
94994: PUSH
94995: LD_INT 30
94997: PUSH
94998: LD_INT 31
95000: PUSH
95001: LD_INT 32
95003: PUSH
95004: LD_INT 33
95006: PUSH
95007: LD_INT 34
95009: PUSH
95010: LD_INT 35
95012: PUSH
95013: LD_INT 36
95015: PUSH
95016: EMPTY
95017: LIST
95018: LIST
95019: LIST
95020: LIST
95021: LIST
95022: LIST
95023: LIST
95024: LIST
95025: LIST
95026: LIST
95027: LIST
95028: LIST
95029: LIST
95030: LIST
95031: LIST
95032: LIST
95033: LIST
95034: LIST
95035: LIST
95036: LIST
95037: LIST
95038: PUSH
95039: LD_INT 101
95041: PUSH
95042: LD_INT 102
95044: PUSH
95045: LD_INT 103
95047: PUSH
95048: LD_INT 106
95050: PUSH
95051: LD_INT 108
95053: PUSH
95054: LD_INT 112
95056: PUSH
95057: LD_INT 113
95059: PUSH
95060: LD_INT 114
95062: PUSH
95063: LD_INT 115
95065: PUSH
95066: EMPTY
95067: LIST
95068: LIST
95069: LIST
95070: LIST
95071: LIST
95072: LIST
95073: LIST
95074: LIST
95075: LIST
95076: PUSH
95077: EMPTY
95078: LIST
95079: LIST
95080: ST_TO_ADDR
95081: GO 95312
95083: LD_INT 19
95085: DOUBLE
95086: EQUAL
95087: IFTRUE 95091
95089: GO 95311
95091: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
95092: LD_ADDR_VAR 0 1
95096: PUSH
95097: LD_INT 1
95099: PUSH
95100: LD_INT 2
95102: PUSH
95103: LD_INT 3
95105: PUSH
95106: LD_INT 4
95108: PUSH
95109: LD_INT 5
95111: PUSH
95112: LD_INT 6
95114: PUSH
95115: LD_INT 7
95117: PUSH
95118: LD_INT 8
95120: PUSH
95121: LD_INT 9
95123: PUSH
95124: LD_INT 10
95126: PUSH
95127: LD_INT 11
95129: PUSH
95130: LD_INT 12
95132: PUSH
95133: LD_INT 13
95135: PUSH
95136: LD_INT 14
95138: PUSH
95139: LD_INT 15
95141: PUSH
95142: LD_INT 16
95144: PUSH
95145: LD_INT 17
95147: PUSH
95148: LD_INT 18
95150: PUSH
95151: LD_INT 19
95153: PUSH
95154: LD_INT 20
95156: PUSH
95157: LD_INT 21
95159: PUSH
95160: LD_INT 22
95162: PUSH
95163: LD_INT 23
95165: PUSH
95166: LD_INT 24
95168: PUSH
95169: LD_INT 25
95171: PUSH
95172: LD_INT 26
95174: PUSH
95175: LD_INT 27
95177: PUSH
95178: LD_INT 28
95180: PUSH
95181: LD_INT 29
95183: PUSH
95184: LD_INT 30
95186: PUSH
95187: LD_INT 31
95189: PUSH
95190: LD_INT 32
95192: PUSH
95193: LD_INT 33
95195: PUSH
95196: LD_INT 34
95198: PUSH
95199: LD_INT 35
95201: PUSH
95202: LD_INT 36
95204: PUSH
95205: EMPTY
95206: LIST
95207: LIST
95208: LIST
95209: LIST
95210: LIST
95211: LIST
95212: LIST
95213: LIST
95214: LIST
95215: LIST
95216: LIST
95217: LIST
95218: LIST
95219: LIST
95220: LIST
95221: LIST
95222: LIST
95223: LIST
95224: LIST
95225: LIST
95226: LIST
95227: LIST
95228: LIST
95229: LIST
95230: LIST
95231: LIST
95232: LIST
95233: LIST
95234: LIST
95235: LIST
95236: LIST
95237: LIST
95238: LIST
95239: LIST
95240: LIST
95241: LIST
95242: PUSH
95243: LD_INT 101
95245: PUSH
95246: LD_INT 102
95248: PUSH
95249: LD_INT 103
95251: PUSH
95252: LD_INT 104
95254: PUSH
95255: LD_INT 105
95257: PUSH
95258: LD_INT 106
95260: PUSH
95261: LD_INT 107
95263: PUSH
95264: LD_INT 108
95266: PUSH
95267: LD_INT 109
95269: PUSH
95270: LD_INT 110
95272: PUSH
95273: LD_INT 111
95275: PUSH
95276: LD_INT 112
95278: PUSH
95279: LD_INT 113
95281: PUSH
95282: LD_INT 114
95284: PUSH
95285: LD_INT 115
95287: PUSH
95288: EMPTY
95289: LIST
95290: LIST
95291: LIST
95292: LIST
95293: LIST
95294: LIST
95295: LIST
95296: LIST
95297: LIST
95298: LIST
95299: LIST
95300: LIST
95301: LIST
95302: LIST
95303: LIST
95304: PUSH
95305: EMPTY
95306: LIST
95307: LIST
95308: ST_TO_ADDR
95309: GO 95312
95311: POP
// end else
95312: GO 95531
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
95314: LD_ADDR_VAR 0 1
95318: PUSH
95319: LD_INT 1
95321: PUSH
95322: LD_INT 2
95324: PUSH
95325: LD_INT 3
95327: PUSH
95328: LD_INT 4
95330: PUSH
95331: LD_INT 5
95333: PUSH
95334: LD_INT 6
95336: PUSH
95337: LD_INT 7
95339: PUSH
95340: LD_INT 8
95342: PUSH
95343: LD_INT 9
95345: PUSH
95346: LD_INT 10
95348: PUSH
95349: LD_INT 11
95351: PUSH
95352: LD_INT 12
95354: PUSH
95355: LD_INT 13
95357: PUSH
95358: LD_INT 14
95360: PUSH
95361: LD_INT 15
95363: PUSH
95364: LD_INT 16
95366: PUSH
95367: LD_INT 17
95369: PUSH
95370: LD_INT 18
95372: PUSH
95373: LD_INT 19
95375: PUSH
95376: LD_INT 20
95378: PUSH
95379: LD_INT 21
95381: PUSH
95382: LD_INT 22
95384: PUSH
95385: LD_INT 23
95387: PUSH
95388: LD_INT 24
95390: PUSH
95391: LD_INT 25
95393: PUSH
95394: LD_INT 26
95396: PUSH
95397: LD_INT 27
95399: PUSH
95400: LD_INT 28
95402: PUSH
95403: LD_INT 29
95405: PUSH
95406: LD_INT 30
95408: PUSH
95409: LD_INT 31
95411: PUSH
95412: LD_INT 32
95414: PUSH
95415: LD_INT 33
95417: PUSH
95418: LD_INT 34
95420: PUSH
95421: LD_INT 35
95423: PUSH
95424: LD_INT 36
95426: PUSH
95427: EMPTY
95428: LIST
95429: LIST
95430: LIST
95431: LIST
95432: LIST
95433: LIST
95434: LIST
95435: LIST
95436: LIST
95437: LIST
95438: LIST
95439: LIST
95440: LIST
95441: LIST
95442: LIST
95443: LIST
95444: LIST
95445: LIST
95446: LIST
95447: LIST
95448: LIST
95449: LIST
95450: LIST
95451: LIST
95452: LIST
95453: LIST
95454: LIST
95455: LIST
95456: LIST
95457: LIST
95458: LIST
95459: LIST
95460: LIST
95461: LIST
95462: LIST
95463: LIST
95464: PUSH
95465: LD_INT 101
95467: PUSH
95468: LD_INT 102
95470: PUSH
95471: LD_INT 103
95473: PUSH
95474: LD_INT 104
95476: PUSH
95477: LD_INT 105
95479: PUSH
95480: LD_INT 106
95482: PUSH
95483: LD_INT 107
95485: PUSH
95486: LD_INT 108
95488: PUSH
95489: LD_INT 109
95491: PUSH
95492: LD_INT 110
95494: PUSH
95495: LD_INT 111
95497: PUSH
95498: LD_INT 112
95500: PUSH
95501: LD_INT 113
95503: PUSH
95504: LD_INT 114
95506: PUSH
95507: LD_INT 115
95509: PUSH
95510: EMPTY
95511: LIST
95512: LIST
95513: LIST
95514: LIST
95515: LIST
95516: LIST
95517: LIST
95518: LIST
95519: LIST
95520: LIST
95521: LIST
95522: LIST
95523: LIST
95524: LIST
95525: LIST
95526: PUSH
95527: EMPTY
95528: LIST
95529: LIST
95530: ST_TO_ADDR
// if result then
95531: LD_VAR 0 1
95535: IFFALSE 95824
// begin normal :=  ;
95537: LD_ADDR_VAR 0 3
95541: PUSH
95542: LD_STRING 
95544: ST_TO_ADDR
// hardcore :=  ;
95545: LD_ADDR_VAR 0 4
95549: PUSH
95550: LD_STRING 
95552: ST_TO_ADDR
// for i = 1 to normalCounter do
95553: LD_ADDR_VAR 0 5
95557: PUSH
95558: DOUBLE
95559: LD_INT 1
95561: DEC
95562: ST_TO_ADDR
95563: LD_EXP 99
95567: PUSH
95568: FOR_TO
95569: IFFALSE 95670
// begin tmp := 0 ;
95571: LD_ADDR_VAR 0 2
95575: PUSH
95576: LD_STRING 0
95578: ST_TO_ADDR
// if result [ 1 ] then
95579: LD_VAR 0 1
95583: PUSH
95584: LD_INT 1
95586: ARRAY
95587: IFFALSE 95652
// if result [ 1 ] [ 1 ] = i then
95589: LD_VAR 0 1
95593: PUSH
95594: LD_INT 1
95596: ARRAY
95597: PUSH
95598: LD_INT 1
95600: ARRAY
95601: PUSH
95602: LD_VAR 0 5
95606: EQUAL
95607: IFFALSE 95652
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
95609: LD_ADDR_VAR 0 1
95613: PUSH
95614: LD_VAR 0 1
95618: PPUSH
95619: LD_INT 1
95621: PPUSH
95622: LD_VAR 0 1
95626: PUSH
95627: LD_INT 1
95629: ARRAY
95630: PPUSH
95631: LD_INT 1
95633: PPUSH
95634: CALL_OW 3
95638: PPUSH
95639: CALL_OW 1
95643: ST_TO_ADDR
// tmp := 1 ;
95644: LD_ADDR_VAR 0 2
95648: PUSH
95649: LD_STRING 1
95651: ST_TO_ADDR
// end ; normal := normal & tmp ;
95652: LD_ADDR_VAR 0 3
95656: PUSH
95657: LD_VAR 0 3
95661: PUSH
95662: LD_VAR 0 2
95666: STR
95667: ST_TO_ADDR
// end ;
95668: GO 95568
95670: POP
95671: POP
// for i = 1 to hardcoreCounter do
95672: LD_ADDR_VAR 0 5
95676: PUSH
95677: DOUBLE
95678: LD_INT 1
95680: DEC
95681: ST_TO_ADDR
95682: LD_EXP 100
95686: PUSH
95687: FOR_TO
95688: IFFALSE 95793
// begin tmp := 0 ;
95690: LD_ADDR_VAR 0 2
95694: PUSH
95695: LD_STRING 0
95697: ST_TO_ADDR
// if result [ 2 ] then
95698: LD_VAR 0 1
95702: PUSH
95703: LD_INT 2
95705: ARRAY
95706: IFFALSE 95775
// if result [ 2 ] [ 1 ] = 100 + i then
95708: LD_VAR 0 1
95712: PUSH
95713: LD_INT 2
95715: ARRAY
95716: PUSH
95717: LD_INT 1
95719: ARRAY
95720: PUSH
95721: LD_INT 100
95723: PUSH
95724: LD_VAR 0 5
95728: PLUS
95729: EQUAL
95730: IFFALSE 95775
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
95732: LD_ADDR_VAR 0 1
95736: PUSH
95737: LD_VAR 0 1
95741: PPUSH
95742: LD_INT 2
95744: PPUSH
95745: LD_VAR 0 1
95749: PUSH
95750: LD_INT 2
95752: ARRAY
95753: PPUSH
95754: LD_INT 1
95756: PPUSH
95757: CALL_OW 3
95761: PPUSH
95762: CALL_OW 1
95766: ST_TO_ADDR
// tmp := 1 ;
95767: LD_ADDR_VAR 0 2
95771: PUSH
95772: LD_STRING 1
95774: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
95775: LD_ADDR_VAR 0 4
95779: PUSH
95780: LD_VAR 0 4
95784: PUSH
95785: LD_VAR 0 2
95789: STR
95790: ST_TO_ADDR
// end ;
95791: GO 95687
95793: POP
95794: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
95795: LD_STRING getStreamItemsFromMission("
95797: PUSH
95798: LD_VAR 0 3
95802: STR
95803: PUSH
95804: LD_STRING ","
95806: STR
95807: PUSH
95808: LD_VAR 0 4
95812: STR
95813: PUSH
95814: LD_STRING ")
95816: STR
95817: PPUSH
95818: CALL_OW 559
// end else
95822: GO 95831
// ToLua ( getStreamItemsFromMission("","") ) ;
95824: LD_STRING getStreamItemsFromMission("","")
95826: PPUSH
95827: CALL_OW 559
// end ;
95831: LD_VAR 0 1
95835: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
95836: LD_EXP 98
95840: PUSH
95841: LD_EXP 103
95845: AND
95846: IFFALSE 95970
95848: GO 95850
95850: DISABLE
95851: LD_INT 0
95853: PPUSH
95854: PPUSH
// begin enable ;
95855: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
95856: LD_ADDR_VAR 0 2
95860: PUSH
95861: LD_INT 22
95863: PUSH
95864: LD_OWVAR 2
95868: PUSH
95869: EMPTY
95870: LIST
95871: LIST
95872: PUSH
95873: LD_INT 2
95875: PUSH
95876: LD_INT 34
95878: PUSH
95879: LD_INT 7
95881: PUSH
95882: EMPTY
95883: LIST
95884: LIST
95885: PUSH
95886: LD_INT 34
95888: PUSH
95889: LD_INT 45
95891: PUSH
95892: EMPTY
95893: LIST
95894: LIST
95895: PUSH
95896: LD_INT 34
95898: PUSH
95899: LD_INT 28
95901: PUSH
95902: EMPTY
95903: LIST
95904: LIST
95905: PUSH
95906: LD_INT 34
95908: PUSH
95909: LD_INT 47
95911: PUSH
95912: EMPTY
95913: LIST
95914: LIST
95915: PUSH
95916: EMPTY
95917: LIST
95918: LIST
95919: LIST
95920: LIST
95921: LIST
95922: PUSH
95923: EMPTY
95924: LIST
95925: LIST
95926: PPUSH
95927: CALL_OW 69
95931: ST_TO_ADDR
// if not tmp then
95932: LD_VAR 0 2
95936: NOT
95937: IFFALSE 95941
// exit ;
95939: GO 95970
// for i in tmp do
95941: LD_ADDR_VAR 0 1
95945: PUSH
95946: LD_VAR 0 2
95950: PUSH
95951: FOR_IN
95952: IFFALSE 95968
// begin SetLives ( i , 0 ) ;
95954: LD_VAR 0 1
95958: PPUSH
95959: LD_INT 0
95961: PPUSH
95962: CALL_OW 234
// end ;
95966: GO 95951
95968: POP
95969: POP
// end ;
95970: PPOPN 2
95972: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
95973: LD_EXP 98
95977: PUSH
95978: LD_EXP 104
95982: AND
95983: IFFALSE 96067
95985: GO 95987
95987: DISABLE
95988: LD_INT 0
95990: PPUSH
95991: PPUSH
// begin enable ;
95992: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
95993: LD_ADDR_VAR 0 2
95997: PUSH
95998: LD_INT 22
96000: PUSH
96001: LD_OWVAR 2
96005: PUSH
96006: EMPTY
96007: LIST
96008: LIST
96009: PUSH
96010: LD_INT 32
96012: PUSH
96013: LD_INT 3
96015: PUSH
96016: EMPTY
96017: LIST
96018: LIST
96019: PUSH
96020: EMPTY
96021: LIST
96022: LIST
96023: PPUSH
96024: CALL_OW 69
96028: ST_TO_ADDR
// if not tmp then
96029: LD_VAR 0 2
96033: NOT
96034: IFFALSE 96038
// exit ;
96036: GO 96067
// for i in tmp do
96038: LD_ADDR_VAR 0 1
96042: PUSH
96043: LD_VAR 0 2
96047: PUSH
96048: FOR_IN
96049: IFFALSE 96065
// begin SetLives ( i , 0 ) ;
96051: LD_VAR 0 1
96055: PPUSH
96056: LD_INT 0
96058: PPUSH
96059: CALL_OW 234
// end ;
96063: GO 96048
96065: POP
96066: POP
// end ;
96067: PPOPN 2
96069: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
96070: LD_EXP 98
96074: PUSH
96075: LD_EXP 101
96079: AND
96080: IFFALSE 96173
96082: GO 96084
96084: DISABLE
96085: LD_INT 0
96087: PPUSH
// begin enable ;
96088: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
96089: LD_ADDR_VAR 0 1
96093: PUSH
96094: LD_INT 22
96096: PUSH
96097: LD_OWVAR 2
96101: PUSH
96102: EMPTY
96103: LIST
96104: LIST
96105: PUSH
96106: LD_INT 2
96108: PUSH
96109: LD_INT 25
96111: PUSH
96112: LD_INT 5
96114: PUSH
96115: EMPTY
96116: LIST
96117: LIST
96118: PUSH
96119: LD_INT 25
96121: PUSH
96122: LD_INT 9
96124: PUSH
96125: EMPTY
96126: LIST
96127: LIST
96128: PUSH
96129: LD_INT 25
96131: PUSH
96132: LD_INT 8
96134: PUSH
96135: EMPTY
96136: LIST
96137: LIST
96138: PUSH
96139: EMPTY
96140: LIST
96141: LIST
96142: LIST
96143: LIST
96144: PUSH
96145: EMPTY
96146: LIST
96147: LIST
96148: PPUSH
96149: CALL_OW 69
96153: PUSH
96154: FOR_IN
96155: IFFALSE 96171
// begin SetClass ( i , 1 ) ;
96157: LD_VAR 0 1
96161: PPUSH
96162: LD_INT 1
96164: PPUSH
96165: CALL_OW 336
// end ;
96169: GO 96154
96171: POP
96172: POP
// end ;
96173: PPOPN 1
96175: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
96176: LD_EXP 98
96180: PUSH
96181: LD_EXP 102
96185: AND
96186: PUSH
96187: LD_OWVAR 65
96191: PUSH
96192: LD_INT 7
96194: LESS
96195: AND
96196: IFFALSE 96210
96198: GO 96200
96200: DISABLE
// begin enable ;
96201: ENABLE
// game_speed := 7 ;
96202: LD_ADDR_OWVAR 65
96206: PUSH
96207: LD_INT 7
96209: ST_TO_ADDR
// end ;
96210: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
96211: LD_EXP 98
96215: PUSH
96216: LD_EXP 105
96220: AND
96221: IFFALSE 96423
96223: GO 96225
96225: DISABLE
96226: LD_INT 0
96228: PPUSH
96229: PPUSH
96230: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
96231: LD_ADDR_VAR 0 3
96235: PUSH
96236: LD_INT 81
96238: PUSH
96239: LD_OWVAR 2
96243: PUSH
96244: EMPTY
96245: LIST
96246: LIST
96247: PUSH
96248: LD_INT 21
96250: PUSH
96251: LD_INT 1
96253: PUSH
96254: EMPTY
96255: LIST
96256: LIST
96257: PUSH
96258: EMPTY
96259: LIST
96260: LIST
96261: PPUSH
96262: CALL_OW 69
96266: ST_TO_ADDR
// if not tmp then
96267: LD_VAR 0 3
96271: NOT
96272: IFFALSE 96276
// exit ;
96274: GO 96423
// if tmp > 5 then
96276: LD_VAR 0 3
96280: PUSH
96281: LD_INT 5
96283: GREATER
96284: IFFALSE 96296
// k := 5 else
96286: LD_ADDR_VAR 0 2
96290: PUSH
96291: LD_INT 5
96293: ST_TO_ADDR
96294: GO 96306
// k := tmp ;
96296: LD_ADDR_VAR 0 2
96300: PUSH
96301: LD_VAR 0 3
96305: ST_TO_ADDR
// for i := 1 to k do
96306: LD_ADDR_VAR 0 1
96310: PUSH
96311: DOUBLE
96312: LD_INT 1
96314: DEC
96315: ST_TO_ADDR
96316: LD_VAR 0 2
96320: PUSH
96321: FOR_TO
96322: IFFALSE 96421
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
96324: LD_VAR 0 3
96328: PUSH
96329: LD_VAR 0 1
96333: ARRAY
96334: PPUSH
96335: LD_VAR 0 1
96339: PUSH
96340: LD_INT 4
96342: MOD
96343: PUSH
96344: LD_INT 1
96346: PLUS
96347: PPUSH
96348: CALL_OW 259
96352: PUSH
96353: LD_INT 10
96355: LESS
96356: IFFALSE 96419
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
96358: LD_VAR 0 3
96362: PUSH
96363: LD_VAR 0 1
96367: ARRAY
96368: PPUSH
96369: LD_VAR 0 1
96373: PUSH
96374: LD_INT 4
96376: MOD
96377: PUSH
96378: LD_INT 1
96380: PLUS
96381: PPUSH
96382: LD_VAR 0 3
96386: PUSH
96387: LD_VAR 0 1
96391: ARRAY
96392: PPUSH
96393: LD_VAR 0 1
96397: PUSH
96398: LD_INT 4
96400: MOD
96401: PUSH
96402: LD_INT 1
96404: PLUS
96405: PPUSH
96406: CALL_OW 259
96410: PUSH
96411: LD_INT 1
96413: PLUS
96414: PPUSH
96415: CALL_OW 237
96419: GO 96321
96421: POP
96422: POP
// end ;
96423: PPOPN 3
96425: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
96426: LD_EXP 98
96430: PUSH
96431: LD_EXP 106
96435: AND
96436: IFFALSE 96456
96438: GO 96440
96440: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
96441: LD_INT 4
96443: PPUSH
96444: LD_OWVAR 2
96448: PPUSH
96449: LD_INT 0
96451: PPUSH
96452: CALL_OW 324
96456: END
// every 0 0$1 trigger StreamModeActive and sShovel do
96457: LD_EXP 98
96461: PUSH
96462: LD_EXP 135
96466: AND
96467: IFFALSE 96487
96469: GO 96471
96471: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
96472: LD_INT 19
96474: PPUSH
96475: LD_OWVAR 2
96479: PPUSH
96480: LD_INT 0
96482: PPUSH
96483: CALL_OW 324
96487: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
96488: LD_EXP 98
96492: PUSH
96493: LD_EXP 107
96497: AND
96498: IFFALSE 96600
96500: GO 96502
96502: DISABLE
96503: LD_INT 0
96505: PPUSH
96506: PPUSH
// begin enable ;
96507: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
96508: LD_ADDR_VAR 0 2
96512: PUSH
96513: LD_INT 22
96515: PUSH
96516: LD_OWVAR 2
96520: PUSH
96521: EMPTY
96522: LIST
96523: LIST
96524: PUSH
96525: LD_INT 2
96527: PUSH
96528: LD_INT 34
96530: PUSH
96531: LD_INT 11
96533: PUSH
96534: EMPTY
96535: LIST
96536: LIST
96537: PUSH
96538: LD_INT 34
96540: PUSH
96541: LD_INT 30
96543: PUSH
96544: EMPTY
96545: LIST
96546: LIST
96547: PUSH
96548: EMPTY
96549: LIST
96550: LIST
96551: LIST
96552: PUSH
96553: EMPTY
96554: LIST
96555: LIST
96556: PPUSH
96557: CALL_OW 69
96561: ST_TO_ADDR
// if not tmp then
96562: LD_VAR 0 2
96566: NOT
96567: IFFALSE 96571
// exit ;
96569: GO 96600
// for i in tmp do
96571: LD_ADDR_VAR 0 1
96575: PUSH
96576: LD_VAR 0 2
96580: PUSH
96581: FOR_IN
96582: IFFALSE 96598
// begin SetLives ( i , 0 ) ;
96584: LD_VAR 0 1
96588: PPUSH
96589: LD_INT 0
96591: PPUSH
96592: CALL_OW 234
// end ;
96596: GO 96581
96598: POP
96599: POP
// end ;
96600: PPOPN 2
96602: END
// every 0 0$1 trigger StreamModeActive and sBunker do
96603: LD_EXP 98
96607: PUSH
96608: LD_EXP 108
96612: AND
96613: IFFALSE 96633
96615: GO 96617
96617: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
96618: LD_INT 32
96620: PPUSH
96621: LD_OWVAR 2
96625: PPUSH
96626: LD_INT 0
96628: PPUSH
96629: CALL_OW 324
96633: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
96634: LD_EXP 98
96638: PUSH
96639: LD_EXP 109
96643: AND
96644: IFFALSE 96825
96646: GO 96648
96648: DISABLE
96649: LD_INT 0
96651: PPUSH
96652: PPUSH
96653: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
96654: LD_ADDR_VAR 0 2
96658: PUSH
96659: LD_INT 22
96661: PUSH
96662: LD_OWVAR 2
96666: PUSH
96667: EMPTY
96668: LIST
96669: LIST
96670: PUSH
96671: LD_INT 33
96673: PUSH
96674: LD_INT 3
96676: PUSH
96677: EMPTY
96678: LIST
96679: LIST
96680: PUSH
96681: EMPTY
96682: LIST
96683: LIST
96684: PPUSH
96685: CALL_OW 69
96689: ST_TO_ADDR
// if not tmp then
96690: LD_VAR 0 2
96694: NOT
96695: IFFALSE 96699
// exit ;
96697: GO 96825
// side := 0 ;
96699: LD_ADDR_VAR 0 3
96703: PUSH
96704: LD_INT 0
96706: ST_TO_ADDR
// for i := 1 to 8 do
96707: LD_ADDR_VAR 0 1
96711: PUSH
96712: DOUBLE
96713: LD_INT 1
96715: DEC
96716: ST_TO_ADDR
96717: LD_INT 8
96719: PUSH
96720: FOR_TO
96721: IFFALSE 96769
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
96723: LD_OWVAR 2
96727: PUSH
96728: LD_VAR 0 1
96732: NONEQUAL
96733: PUSH
96734: LD_OWVAR 2
96738: PPUSH
96739: LD_VAR 0 1
96743: PPUSH
96744: CALL_OW 81
96748: PUSH
96749: LD_INT 2
96751: EQUAL
96752: AND
96753: IFFALSE 96767
// begin side := i ;
96755: LD_ADDR_VAR 0 3
96759: PUSH
96760: LD_VAR 0 1
96764: ST_TO_ADDR
// break ;
96765: GO 96769
// end ;
96767: GO 96720
96769: POP
96770: POP
// if not side then
96771: LD_VAR 0 3
96775: NOT
96776: IFFALSE 96780
// exit ;
96778: GO 96825
// for i := 1 to tmp do
96780: LD_ADDR_VAR 0 1
96784: PUSH
96785: DOUBLE
96786: LD_INT 1
96788: DEC
96789: ST_TO_ADDR
96790: LD_VAR 0 2
96794: PUSH
96795: FOR_TO
96796: IFFALSE 96823
// if Prob ( 60 ) then
96798: LD_INT 60
96800: PPUSH
96801: CALL_OW 13
96805: IFFALSE 96821
// SetSide ( i , side ) ;
96807: LD_VAR 0 1
96811: PPUSH
96812: LD_VAR 0 3
96816: PPUSH
96817: CALL_OW 235
96821: GO 96795
96823: POP
96824: POP
// end ;
96825: PPOPN 3
96827: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
96828: LD_EXP 98
96832: PUSH
96833: LD_EXP 111
96837: AND
96838: IFFALSE 96957
96840: GO 96842
96842: DISABLE
96843: LD_INT 0
96845: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
96846: LD_ADDR_VAR 0 1
96850: PUSH
96851: LD_INT 22
96853: PUSH
96854: LD_OWVAR 2
96858: PUSH
96859: EMPTY
96860: LIST
96861: LIST
96862: PUSH
96863: LD_INT 21
96865: PUSH
96866: LD_INT 1
96868: PUSH
96869: EMPTY
96870: LIST
96871: LIST
96872: PUSH
96873: LD_INT 3
96875: PUSH
96876: LD_INT 23
96878: PUSH
96879: LD_INT 0
96881: PUSH
96882: EMPTY
96883: LIST
96884: LIST
96885: PUSH
96886: EMPTY
96887: LIST
96888: LIST
96889: PUSH
96890: EMPTY
96891: LIST
96892: LIST
96893: LIST
96894: PPUSH
96895: CALL_OW 69
96899: PUSH
96900: FOR_IN
96901: IFFALSE 96955
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
96903: LD_VAR 0 1
96907: PPUSH
96908: CALL_OW 257
96912: PUSH
96913: LD_INT 1
96915: PUSH
96916: LD_INT 2
96918: PUSH
96919: LD_INT 3
96921: PUSH
96922: LD_INT 4
96924: PUSH
96925: EMPTY
96926: LIST
96927: LIST
96928: LIST
96929: LIST
96930: IN
96931: IFFALSE 96953
// SetClass ( un , rand ( 1 , 4 ) ) ;
96933: LD_VAR 0 1
96937: PPUSH
96938: LD_INT 1
96940: PPUSH
96941: LD_INT 4
96943: PPUSH
96944: CALL_OW 12
96948: PPUSH
96949: CALL_OW 336
96953: GO 96900
96955: POP
96956: POP
// end ;
96957: PPOPN 1
96959: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
96960: LD_EXP 98
96964: PUSH
96965: LD_EXP 110
96969: AND
96970: IFFALSE 97049
96972: GO 96974
96974: DISABLE
96975: LD_INT 0
96977: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
96978: LD_ADDR_VAR 0 1
96982: PUSH
96983: LD_INT 22
96985: PUSH
96986: LD_OWVAR 2
96990: PUSH
96991: EMPTY
96992: LIST
96993: LIST
96994: PUSH
96995: LD_INT 21
96997: PUSH
96998: LD_INT 3
97000: PUSH
97001: EMPTY
97002: LIST
97003: LIST
97004: PUSH
97005: EMPTY
97006: LIST
97007: LIST
97008: PPUSH
97009: CALL_OW 69
97013: ST_TO_ADDR
// if not tmp then
97014: LD_VAR 0 1
97018: NOT
97019: IFFALSE 97023
// exit ;
97021: GO 97049
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
97023: LD_VAR 0 1
97027: PUSH
97028: LD_INT 1
97030: PPUSH
97031: LD_VAR 0 1
97035: PPUSH
97036: CALL_OW 12
97040: ARRAY
97041: PPUSH
97042: LD_INT 100
97044: PPUSH
97045: CALL_OW 234
// end ;
97049: PPOPN 1
97051: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
97052: LD_EXP 98
97056: PUSH
97057: LD_EXP 112
97061: AND
97062: IFFALSE 97160
97064: GO 97066
97066: DISABLE
97067: LD_INT 0
97069: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
97070: LD_ADDR_VAR 0 1
97074: PUSH
97075: LD_INT 22
97077: PUSH
97078: LD_OWVAR 2
97082: PUSH
97083: EMPTY
97084: LIST
97085: LIST
97086: PUSH
97087: LD_INT 21
97089: PUSH
97090: LD_INT 1
97092: PUSH
97093: EMPTY
97094: LIST
97095: LIST
97096: PUSH
97097: EMPTY
97098: LIST
97099: LIST
97100: PPUSH
97101: CALL_OW 69
97105: ST_TO_ADDR
// if not tmp then
97106: LD_VAR 0 1
97110: NOT
97111: IFFALSE 97115
// exit ;
97113: GO 97160
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
97115: LD_VAR 0 1
97119: PUSH
97120: LD_INT 1
97122: PPUSH
97123: LD_VAR 0 1
97127: PPUSH
97128: CALL_OW 12
97132: ARRAY
97133: PPUSH
97134: LD_INT 1
97136: PPUSH
97137: LD_INT 4
97139: PPUSH
97140: CALL_OW 12
97144: PPUSH
97145: LD_INT 3000
97147: PPUSH
97148: LD_INT 9000
97150: PPUSH
97151: CALL_OW 12
97155: PPUSH
97156: CALL_OW 492
// end ;
97160: PPOPN 1
97162: END
// every 0 0$1 trigger StreamModeActive and sDepot do
97163: LD_EXP 98
97167: PUSH
97168: LD_EXP 113
97172: AND
97173: IFFALSE 97193
97175: GO 97177
97177: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
97178: LD_INT 1
97180: PPUSH
97181: LD_OWVAR 2
97185: PPUSH
97186: LD_INT 0
97188: PPUSH
97189: CALL_OW 324
97193: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
97194: LD_EXP 98
97198: PUSH
97199: LD_EXP 114
97203: AND
97204: IFFALSE 97287
97206: GO 97208
97208: DISABLE
97209: LD_INT 0
97211: PPUSH
97212: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
97213: LD_ADDR_VAR 0 2
97217: PUSH
97218: LD_INT 22
97220: PUSH
97221: LD_OWVAR 2
97225: PUSH
97226: EMPTY
97227: LIST
97228: LIST
97229: PUSH
97230: LD_INT 21
97232: PUSH
97233: LD_INT 3
97235: PUSH
97236: EMPTY
97237: LIST
97238: LIST
97239: PUSH
97240: EMPTY
97241: LIST
97242: LIST
97243: PPUSH
97244: CALL_OW 69
97248: ST_TO_ADDR
// if not tmp then
97249: LD_VAR 0 2
97253: NOT
97254: IFFALSE 97258
// exit ;
97256: GO 97287
// for i in tmp do
97258: LD_ADDR_VAR 0 1
97262: PUSH
97263: LD_VAR 0 2
97267: PUSH
97268: FOR_IN
97269: IFFALSE 97285
// SetBLevel ( i , 10 ) ;
97271: LD_VAR 0 1
97275: PPUSH
97276: LD_INT 10
97278: PPUSH
97279: CALL_OW 241
97283: GO 97268
97285: POP
97286: POP
// end ;
97287: PPOPN 2
97289: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
97290: LD_EXP 98
97294: PUSH
97295: LD_EXP 115
97299: AND
97300: IFFALSE 97411
97302: GO 97304
97304: DISABLE
97305: LD_INT 0
97307: PPUSH
97308: PPUSH
97309: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97310: LD_ADDR_VAR 0 3
97314: PUSH
97315: LD_INT 22
97317: PUSH
97318: LD_OWVAR 2
97322: PUSH
97323: EMPTY
97324: LIST
97325: LIST
97326: PUSH
97327: LD_INT 25
97329: PUSH
97330: LD_INT 1
97332: PUSH
97333: EMPTY
97334: LIST
97335: LIST
97336: PUSH
97337: EMPTY
97338: LIST
97339: LIST
97340: PPUSH
97341: CALL_OW 69
97345: ST_TO_ADDR
// if not tmp then
97346: LD_VAR 0 3
97350: NOT
97351: IFFALSE 97355
// exit ;
97353: GO 97411
// un := tmp [ rand ( 1 , tmp ) ] ;
97355: LD_ADDR_VAR 0 2
97359: PUSH
97360: LD_VAR 0 3
97364: PUSH
97365: LD_INT 1
97367: PPUSH
97368: LD_VAR 0 3
97372: PPUSH
97373: CALL_OW 12
97377: ARRAY
97378: ST_TO_ADDR
// if Crawls ( un ) then
97379: LD_VAR 0 2
97383: PPUSH
97384: CALL_OW 318
97388: IFFALSE 97399
// ComWalk ( un ) ;
97390: LD_VAR 0 2
97394: PPUSH
97395: CALL_OW 138
// SetClass ( un , class_sniper ) ;
97399: LD_VAR 0 2
97403: PPUSH
97404: LD_INT 5
97406: PPUSH
97407: CALL_OW 336
// end ;
97411: PPOPN 3
97413: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
97414: LD_EXP 98
97418: PUSH
97419: LD_EXP 116
97423: AND
97424: PUSH
97425: LD_OWVAR 67
97429: PUSH
97430: LD_INT 3
97432: LESS
97433: AND
97434: IFFALSE 97453
97436: GO 97438
97438: DISABLE
// Difficulty := Difficulty + 1 ;
97439: LD_ADDR_OWVAR 67
97443: PUSH
97444: LD_OWVAR 67
97448: PUSH
97449: LD_INT 1
97451: PLUS
97452: ST_TO_ADDR
97453: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
97454: LD_EXP 98
97458: PUSH
97459: LD_EXP 117
97463: AND
97464: IFFALSE 97567
97466: GO 97468
97468: DISABLE
97469: LD_INT 0
97471: PPUSH
// begin for i := 1 to 5 do
97472: LD_ADDR_VAR 0 1
97476: PUSH
97477: DOUBLE
97478: LD_INT 1
97480: DEC
97481: ST_TO_ADDR
97482: LD_INT 5
97484: PUSH
97485: FOR_TO
97486: IFFALSE 97565
// begin uc_nation := nation_nature ;
97488: LD_ADDR_OWVAR 21
97492: PUSH
97493: LD_INT 0
97495: ST_TO_ADDR
// uc_side := 0 ;
97496: LD_ADDR_OWVAR 20
97500: PUSH
97501: LD_INT 0
97503: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
97504: LD_ADDR_OWVAR 29
97508: PUSH
97509: LD_INT 12
97511: PUSH
97512: LD_INT 12
97514: PUSH
97515: EMPTY
97516: LIST
97517: LIST
97518: ST_TO_ADDR
// hc_agressivity := 20 ;
97519: LD_ADDR_OWVAR 35
97523: PUSH
97524: LD_INT 20
97526: ST_TO_ADDR
// hc_class := class_tiger ;
97527: LD_ADDR_OWVAR 28
97531: PUSH
97532: LD_INT 14
97534: ST_TO_ADDR
// hc_gallery :=  ;
97535: LD_ADDR_OWVAR 33
97539: PUSH
97540: LD_STRING 
97542: ST_TO_ADDR
// hc_name :=  ;
97543: LD_ADDR_OWVAR 26
97547: PUSH
97548: LD_STRING 
97550: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
97551: CALL_OW 44
97555: PPUSH
97556: LD_INT 0
97558: PPUSH
97559: CALL_OW 51
// end ;
97563: GO 97485
97565: POP
97566: POP
// end ;
97567: PPOPN 1
97569: END
// every 0 0$1 trigger StreamModeActive and sBomb do
97570: LD_EXP 98
97574: PUSH
97575: LD_EXP 118
97579: AND
97580: IFFALSE 97589
97582: GO 97584
97584: DISABLE
// StreamSibBomb ;
97585: CALL 97590 0 0
97589: END
// export function StreamSibBomb ; var i , x , y ; begin
97590: LD_INT 0
97592: PPUSH
97593: PPUSH
97594: PPUSH
97595: PPUSH
// result := false ;
97596: LD_ADDR_VAR 0 1
97600: PUSH
97601: LD_INT 0
97603: ST_TO_ADDR
// for i := 1 to 16 do
97604: LD_ADDR_VAR 0 2
97608: PUSH
97609: DOUBLE
97610: LD_INT 1
97612: DEC
97613: ST_TO_ADDR
97614: LD_INT 16
97616: PUSH
97617: FOR_TO
97618: IFFALSE 97817
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
97620: LD_ADDR_VAR 0 3
97624: PUSH
97625: LD_INT 10
97627: PUSH
97628: LD_INT 20
97630: PUSH
97631: LD_INT 30
97633: PUSH
97634: LD_INT 40
97636: PUSH
97637: LD_INT 50
97639: PUSH
97640: LD_INT 60
97642: PUSH
97643: LD_INT 70
97645: PUSH
97646: LD_INT 80
97648: PUSH
97649: LD_INT 90
97651: PUSH
97652: LD_INT 100
97654: PUSH
97655: LD_INT 110
97657: PUSH
97658: LD_INT 120
97660: PUSH
97661: LD_INT 130
97663: PUSH
97664: LD_INT 140
97666: PUSH
97667: LD_INT 150
97669: PUSH
97670: EMPTY
97671: LIST
97672: LIST
97673: LIST
97674: LIST
97675: LIST
97676: LIST
97677: LIST
97678: LIST
97679: LIST
97680: LIST
97681: LIST
97682: LIST
97683: LIST
97684: LIST
97685: LIST
97686: PUSH
97687: LD_INT 1
97689: PPUSH
97690: LD_INT 15
97692: PPUSH
97693: CALL_OW 12
97697: ARRAY
97698: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
97699: LD_ADDR_VAR 0 4
97703: PUSH
97704: LD_INT 10
97706: PUSH
97707: LD_INT 20
97709: PUSH
97710: LD_INT 30
97712: PUSH
97713: LD_INT 40
97715: PUSH
97716: LD_INT 50
97718: PUSH
97719: LD_INT 60
97721: PUSH
97722: LD_INT 70
97724: PUSH
97725: LD_INT 80
97727: PUSH
97728: LD_INT 90
97730: PUSH
97731: LD_INT 100
97733: PUSH
97734: LD_INT 110
97736: PUSH
97737: LD_INT 120
97739: PUSH
97740: LD_INT 130
97742: PUSH
97743: LD_INT 140
97745: PUSH
97746: LD_INT 150
97748: PUSH
97749: EMPTY
97750: LIST
97751: LIST
97752: LIST
97753: LIST
97754: LIST
97755: LIST
97756: LIST
97757: LIST
97758: LIST
97759: LIST
97760: LIST
97761: LIST
97762: LIST
97763: LIST
97764: LIST
97765: PUSH
97766: LD_INT 1
97768: PPUSH
97769: LD_INT 15
97771: PPUSH
97772: CALL_OW 12
97776: ARRAY
97777: ST_TO_ADDR
// if ValidHex ( x , y ) then
97778: LD_VAR 0 3
97782: PPUSH
97783: LD_VAR 0 4
97787: PPUSH
97788: CALL_OW 488
97792: IFFALSE 97815
// begin result := [ x , y ] ;
97794: LD_ADDR_VAR 0 1
97798: PUSH
97799: LD_VAR 0 3
97803: PUSH
97804: LD_VAR 0 4
97808: PUSH
97809: EMPTY
97810: LIST
97811: LIST
97812: ST_TO_ADDR
// break ;
97813: GO 97817
// end ; end ;
97815: GO 97617
97817: POP
97818: POP
// if result then
97819: LD_VAR 0 1
97823: IFFALSE 97883
// begin ToLua ( playSibBomb() ) ;
97825: LD_STRING playSibBomb()
97827: PPUSH
97828: CALL_OW 559
// wait ( 0 0$14 ) ;
97832: LD_INT 490
97834: PPUSH
97835: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
97839: LD_VAR 0 1
97843: PUSH
97844: LD_INT 1
97846: ARRAY
97847: PPUSH
97848: LD_VAR 0 1
97852: PUSH
97853: LD_INT 2
97855: ARRAY
97856: PPUSH
97857: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
97861: LD_VAR 0 1
97865: PUSH
97866: LD_INT 1
97868: ARRAY
97869: PPUSH
97870: LD_VAR 0 1
97874: PUSH
97875: LD_INT 2
97877: ARRAY
97878: PPUSH
97879: CALL_OW 429
// end ; end ;
97883: LD_VAR 0 1
97887: RET
// every 0 0$1 trigger StreamModeActive and sReset do
97888: LD_EXP 98
97892: PUSH
97893: LD_EXP 120
97897: AND
97898: IFFALSE 97910
97900: GO 97902
97902: DISABLE
// YouLost (  ) ;
97903: LD_STRING 
97905: PPUSH
97906: CALL_OW 104
97910: END
// every 0 0$1 trigger StreamModeActive and sFog do
97911: LD_EXP 98
97915: PUSH
97916: LD_EXP 119
97920: AND
97921: IFFALSE 97935
97923: GO 97925
97925: DISABLE
// FogOff ( your_side ) ;
97926: LD_OWVAR 2
97930: PPUSH
97931: CALL_OW 344
97935: END
// every 0 0$1 trigger StreamModeActive and sSun do
97936: LD_EXP 98
97940: PUSH
97941: LD_EXP 121
97945: AND
97946: IFFALSE 97974
97948: GO 97950
97950: DISABLE
// begin solar_recharge_percent := 0 ;
97951: LD_ADDR_OWVAR 79
97955: PUSH
97956: LD_INT 0
97958: ST_TO_ADDR
// wait ( 5 5$00 ) ;
97959: LD_INT 10500
97961: PPUSH
97962: CALL_OW 67
// solar_recharge_percent := 100 ;
97966: LD_ADDR_OWVAR 79
97970: PUSH
97971: LD_INT 100
97973: ST_TO_ADDR
// end ;
97974: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
97975: LD_EXP 98
97979: PUSH
97980: LD_EXP 122
97984: AND
97985: IFFALSE 98224
97987: GO 97989
97989: DISABLE
97990: LD_INT 0
97992: PPUSH
97993: PPUSH
97994: PPUSH
// begin tmp := [ ] ;
97995: LD_ADDR_VAR 0 3
97999: PUSH
98000: EMPTY
98001: ST_TO_ADDR
// for i := 1 to 6 do
98002: LD_ADDR_VAR 0 1
98006: PUSH
98007: DOUBLE
98008: LD_INT 1
98010: DEC
98011: ST_TO_ADDR
98012: LD_INT 6
98014: PUSH
98015: FOR_TO
98016: IFFALSE 98121
// begin uc_nation := nation_nature ;
98018: LD_ADDR_OWVAR 21
98022: PUSH
98023: LD_INT 0
98025: ST_TO_ADDR
// uc_side := 0 ;
98026: LD_ADDR_OWVAR 20
98030: PUSH
98031: LD_INT 0
98033: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
98034: LD_ADDR_OWVAR 29
98038: PUSH
98039: LD_INT 12
98041: PUSH
98042: LD_INT 12
98044: PUSH
98045: EMPTY
98046: LIST
98047: LIST
98048: ST_TO_ADDR
// hc_agressivity := 20 ;
98049: LD_ADDR_OWVAR 35
98053: PUSH
98054: LD_INT 20
98056: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
98057: LD_ADDR_OWVAR 28
98061: PUSH
98062: LD_INT 17
98064: ST_TO_ADDR
// hc_gallery :=  ;
98065: LD_ADDR_OWVAR 33
98069: PUSH
98070: LD_STRING 
98072: ST_TO_ADDR
// hc_name :=  ;
98073: LD_ADDR_OWVAR 26
98077: PUSH
98078: LD_STRING 
98080: ST_TO_ADDR
// un := CreateHuman ;
98081: LD_ADDR_VAR 0 2
98085: PUSH
98086: CALL_OW 44
98090: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
98091: LD_VAR 0 2
98095: PPUSH
98096: LD_INT 1
98098: PPUSH
98099: CALL_OW 51
// tmp := tmp ^ un ;
98103: LD_ADDR_VAR 0 3
98107: PUSH
98108: LD_VAR 0 3
98112: PUSH
98113: LD_VAR 0 2
98117: ADD
98118: ST_TO_ADDR
// end ;
98119: GO 98015
98121: POP
98122: POP
// repeat wait ( 0 0$1 ) ;
98123: LD_INT 35
98125: PPUSH
98126: CALL_OW 67
// for un in tmp do
98130: LD_ADDR_VAR 0 2
98134: PUSH
98135: LD_VAR 0 3
98139: PUSH
98140: FOR_IN
98141: IFFALSE 98215
// begin if IsDead ( un ) then
98143: LD_VAR 0 2
98147: PPUSH
98148: CALL_OW 301
98152: IFFALSE 98172
// begin tmp := tmp diff un ;
98154: LD_ADDR_VAR 0 3
98158: PUSH
98159: LD_VAR 0 3
98163: PUSH
98164: LD_VAR 0 2
98168: DIFF
98169: ST_TO_ADDR
// continue ;
98170: GO 98140
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
98172: LD_VAR 0 2
98176: PPUSH
98177: LD_INT 3
98179: PUSH
98180: LD_INT 22
98182: PUSH
98183: LD_INT 0
98185: PUSH
98186: EMPTY
98187: LIST
98188: LIST
98189: PUSH
98190: EMPTY
98191: LIST
98192: LIST
98193: PPUSH
98194: CALL_OW 69
98198: PPUSH
98199: LD_VAR 0 2
98203: PPUSH
98204: CALL_OW 74
98208: PPUSH
98209: CALL_OW 115
// end ;
98213: GO 98140
98215: POP
98216: POP
// until not tmp ;
98217: LD_VAR 0 3
98221: NOT
98222: IFFALSE 98123
// end ;
98224: PPOPN 3
98226: END
// every 0 0$1 trigger StreamModeActive and sTroll do
98227: LD_EXP 98
98231: PUSH
98232: LD_EXP 123
98236: AND
98237: IFFALSE 98291
98239: GO 98241
98241: DISABLE
// begin ToLua ( displayTroll(); ) ;
98242: LD_STRING displayTroll();
98244: PPUSH
98245: CALL_OW 559
// wait ( 3 3$00 ) ;
98249: LD_INT 6300
98251: PPUSH
98252: CALL_OW 67
// ToLua ( hideTroll(); ) ;
98256: LD_STRING hideTroll();
98258: PPUSH
98259: CALL_OW 559
// wait ( 1 1$00 ) ;
98263: LD_INT 2100
98265: PPUSH
98266: CALL_OW 67
// ToLua ( displayTroll(); ) ;
98270: LD_STRING displayTroll();
98272: PPUSH
98273: CALL_OW 559
// wait ( 1 1$00 ) ;
98277: LD_INT 2100
98279: PPUSH
98280: CALL_OW 67
// ToLua ( hideTroll(); ) ;
98284: LD_STRING hideTroll();
98286: PPUSH
98287: CALL_OW 559
// end ;
98291: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
98292: LD_EXP 98
98296: PUSH
98297: LD_EXP 124
98301: AND
98302: IFFALSE 98365
98304: GO 98306
98306: DISABLE
98307: LD_INT 0
98309: PPUSH
// begin p := 0 ;
98310: LD_ADDR_VAR 0 1
98314: PUSH
98315: LD_INT 0
98317: ST_TO_ADDR
// repeat game_speed := 1 ;
98318: LD_ADDR_OWVAR 65
98322: PUSH
98323: LD_INT 1
98325: ST_TO_ADDR
// wait ( 0 0$1 ) ;
98326: LD_INT 35
98328: PPUSH
98329: CALL_OW 67
// p := p + 1 ;
98333: LD_ADDR_VAR 0 1
98337: PUSH
98338: LD_VAR 0 1
98342: PUSH
98343: LD_INT 1
98345: PLUS
98346: ST_TO_ADDR
// until p >= 60 ;
98347: LD_VAR 0 1
98351: PUSH
98352: LD_INT 60
98354: GREATEREQUAL
98355: IFFALSE 98318
// game_speed := 4 ;
98357: LD_ADDR_OWVAR 65
98361: PUSH
98362: LD_INT 4
98364: ST_TO_ADDR
// end ;
98365: PPOPN 1
98367: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
98368: LD_EXP 98
98372: PUSH
98373: LD_EXP 125
98377: AND
98378: IFFALSE 98524
98380: GO 98382
98382: DISABLE
98383: LD_INT 0
98385: PPUSH
98386: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
98387: LD_ADDR_VAR 0 1
98391: PUSH
98392: LD_INT 22
98394: PUSH
98395: LD_OWVAR 2
98399: PUSH
98400: EMPTY
98401: LIST
98402: LIST
98403: PUSH
98404: LD_INT 2
98406: PUSH
98407: LD_INT 30
98409: PUSH
98410: LD_INT 0
98412: PUSH
98413: EMPTY
98414: LIST
98415: LIST
98416: PUSH
98417: LD_INT 30
98419: PUSH
98420: LD_INT 1
98422: PUSH
98423: EMPTY
98424: LIST
98425: LIST
98426: PUSH
98427: EMPTY
98428: LIST
98429: LIST
98430: LIST
98431: PUSH
98432: EMPTY
98433: LIST
98434: LIST
98435: PPUSH
98436: CALL_OW 69
98440: ST_TO_ADDR
// if not depot then
98441: LD_VAR 0 1
98445: NOT
98446: IFFALSE 98450
// exit ;
98448: GO 98524
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
98450: LD_ADDR_VAR 0 2
98454: PUSH
98455: LD_VAR 0 1
98459: PUSH
98460: LD_INT 1
98462: PPUSH
98463: LD_VAR 0 1
98467: PPUSH
98468: CALL_OW 12
98472: ARRAY
98473: PPUSH
98474: CALL_OW 274
98478: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
98479: LD_VAR 0 2
98483: PPUSH
98484: LD_INT 1
98486: PPUSH
98487: LD_INT 0
98489: PPUSH
98490: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
98494: LD_VAR 0 2
98498: PPUSH
98499: LD_INT 2
98501: PPUSH
98502: LD_INT 0
98504: PPUSH
98505: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
98509: LD_VAR 0 2
98513: PPUSH
98514: LD_INT 3
98516: PPUSH
98517: LD_INT 0
98519: PPUSH
98520: CALL_OW 277
// end ;
98524: PPOPN 2
98526: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
98527: LD_EXP 98
98531: PUSH
98532: LD_EXP 126
98536: AND
98537: IFFALSE 98634
98539: GO 98541
98541: DISABLE
98542: LD_INT 0
98544: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
98545: LD_ADDR_VAR 0 1
98549: PUSH
98550: LD_INT 22
98552: PUSH
98553: LD_OWVAR 2
98557: PUSH
98558: EMPTY
98559: LIST
98560: LIST
98561: PUSH
98562: LD_INT 21
98564: PUSH
98565: LD_INT 1
98567: PUSH
98568: EMPTY
98569: LIST
98570: LIST
98571: PUSH
98572: LD_INT 3
98574: PUSH
98575: LD_INT 23
98577: PUSH
98578: LD_INT 0
98580: PUSH
98581: EMPTY
98582: LIST
98583: LIST
98584: PUSH
98585: EMPTY
98586: LIST
98587: LIST
98588: PUSH
98589: EMPTY
98590: LIST
98591: LIST
98592: LIST
98593: PPUSH
98594: CALL_OW 69
98598: ST_TO_ADDR
// if not tmp then
98599: LD_VAR 0 1
98603: NOT
98604: IFFALSE 98608
// exit ;
98606: GO 98634
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
98608: LD_VAR 0 1
98612: PUSH
98613: LD_INT 1
98615: PPUSH
98616: LD_VAR 0 1
98620: PPUSH
98621: CALL_OW 12
98625: ARRAY
98626: PPUSH
98627: LD_INT 200
98629: PPUSH
98630: CALL_OW 234
// end ;
98634: PPOPN 1
98636: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
98637: LD_EXP 98
98641: PUSH
98642: LD_EXP 127
98646: AND
98647: IFFALSE 98726
98649: GO 98651
98651: DISABLE
98652: LD_INT 0
98654: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
98655: LD_ADDR_VAR 0 1
98659: PUSH
98660: LD_INT 22
98662: PUSH
98663: LD_OWVAR 2
98667: PUSH
98668: EMPTY
98669: LIST
98670: LIST
98671: PUSH
98672: LD_INT 21
98674: PUSH
98675: LD_INT 2
98677: PUSH
98678: EMPTY
98679: LIST
98680: LIST
98681: PUSH
98682: EMPTY
98683: LIST
98684: LIST
98685: PPUSH
98686: CALL_OW 69
98690: ST_TO_ADDR
// if not tmp then
98691: LD_VAR 0 1
98695: NOT
98696: IFFALSE 98700
// exit ;
98698: GO 98726
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
98700: LD_VAR 0 1
98704: PUSH
98705: LD_INT 1
98707: PPUSH
98708: LD_VAR 0 1
98712: PPUSH
98713: CALL_OW 12
98717: ARRAY
98718: PPUSH
98719: LD_INT 60
98721: PPUSH
98722: CALL_OW 234
// end ;
98726: PPOPN 1
98728: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
98729: LD_EXP 98
98733: PUSH
98734: LD_EXP 128
98738: AND
98739: IFFALSE 98838
98741: GO 98743
98743: DISABLE
98744: LD_INT 0
98746: PPUSH
98747: PPUSH
// begin enable ;
98748: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
98749: LD_ADDR_VAR 0 1
98753: PUSH
98754: LD_INT 22
98756: PUSH
98757: LD_OWVAR 2
98761: PUSH
98762: EMPTY
98763: LIST
98764: LIST
98765: PUSH
98766: LD_INT 61
98768: PUSH
98769: EMPTY
98770: LIST
98771: PUSH
98772: LD_INT 33
98774: PUSH
98775: LD_INT 2
98777: PUSH
98778: EMPTY
98779: LIST
98780: LIST
98781: PUSH
98782: EMPTY
98783: LIST
98784: LIST
98785: LIST
98786: PPUSH
98787: CALL_OW 69
98791: ST_TO_ADDR
// if not tmp then
98792: LD_VAR 0 1
98796: NOT
98797: IFFALSE 98801
// exit ;
98799: GO 98838
// for i in tmp do
98801: LD_ADDR_VAR 0 2
98805: PUSH
98806: LD_VAR 0 1
98810: PUSH
98811: FOR_IN
98812: IFFALSE 98836
// if IsControledBy ( i ) then
98814: LD_VAR 0 2
98818: PPUSH
98819: CALL_OW 312
98823: IFFALSE 98834
// ComUnlink ( i ) ;
98825: LD_VAR 0 2
98829: PPUSH
98830: CALL_OW 136
98834: GO 98811
98836: POP
98837: POP
// end ;
98838: PPOPN 2
98840: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
98841: LD_EXP 98
98845: PUSH
98846: LD_EXP 129
98850: AND
98851: IFFALSE 98991
98853: GO 98855
98855: DISABLE
98856: LD_INT 0
98858: PPUSH
98859: PPUSH
// begin ToLua ( displayPowell(); ) ;
98860: LD_STRING displayPowell();
98862: PPUSH
98863: CALL_OW 559
// uc_side := 0 ;
98867: LD_ADDR_OWVAR 20
98871: PUSH
98872: LD_INT 0
98874: ST_TO_ADDR
// uc_nation := 2 ;
98875: LD_ADDR_OWVAR 21
98879: PUSH
98880: LD_INT 2
98882: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
98883: LD_ADDR_OWVAR 37
98887: PUSH
98888: LD_INT 14
98890: ST_TO_ADDR
// vc_engine := engine_siberite ;
98891: LD_ADDR_OWVAR 39
98895: PUSH
98896: LD_INT 3
98898: ST_TO_ADDR
// vc_control := control_apeman ;
98899: LD_ADDR_OWVAR 38
98903: PUSH
98904: LD_INT 5
98906: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
98907: LD_ADDR_OWVAR 40
98911: PUSH
98912: LD_INT 29
98914: ST_TO_ADDR
// un := CreateVehicle ;
98915: LD_ADDR_VAR 0 2
98919: PUSH
98920: CALL_OW 45
98924: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
98925: LD_VAR 0 2
98929: PPUSH
98930: LD_INT 1
98932: PPUSH
98933: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
98937: LD_INT 35
98939: PPUSH
98940: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
98944: LD_VAR 0 2
98948: PPUSH
98949: LD_INT 22
98951: PUSH
98952: LD_OWVAR 2
98956: PUSH
98957: EMPTY
98958: LIST
98959: LIST
98960: PPUSH
98961: CALL_OW 69
98965: PPUSH
98966: LD_VAR 0 2
98970: PPUSH
98971: CALL_OW 74
98975: PPUSH
98976: CALL_OW 115
// until IsDead ( un ) ;
98980: LD_VAR 0 2
98984: PPUSH
98985: CALL_OW 301
98989: IFFALSE 98937
// end ;
98991: PPOPN 2
98993: END
// every 0 0$1 trigger StreamModeActive and sStu do
98994: LD_EXP 98
98998: PUSH
98999: LD_EXP 137
99003: AND
99004: IFFALSE 99020
99006: GO 99008
99008: DISABLE
// begin ToLua ( displayStucuk(); ) ;
99009: LD_STRING displayStucuk();
99011: PPUSH
99012: CALL_OW 559
// ResetFog ;
99016: CALL_OW 335
// end ;
99020: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
99021: LD_EXP 98
99025: PUSH
99026: LD_EXP 130
99030: AND
99031: IFFALSE 99172
99033: GO 99035
99035: DISABLE
99036: LD_INT 0
99038: PPUSH
99039: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99040: LD_ADDR_VAR 0 2
99044: PUSH
99045: LD_INT 22
99047: PUSH
99048: LD_OWVAR 2
99052: PUSH
99053: EMPTY
99054: LIST
99055: LIST
99056: PUSH
99057: LD_INT 21
99059: PUSH
99060: LD_INT 1
99062: PUSH
99063: EMPTY
99064: LIST
99065: LIST
99066: PUSH
99067: EMPTY
99068: LIST
99069: LIST
99070: PPUSH
99071: CALL_OW 69
99075: ST_TO_ADDR
// if not tmp then
99076: LD_VAR 0 2
99080: NOT
99081: IFFALSE 99085
// exit ;
99083: GO 99172
// un := tmp [ rand ( 1 , tmp ) ] ;
99085: LD_ADDR_VAR 0 1
99089: PUSH
99090: LD_VAR 0 2
99094: PUSH
99095: LD_INT 1
99097: PPUSH
99098: LD_VAR 0 2
99102: PPUSH
99103: CALL_OW 12
99107: ARRAY
99108: ST_TO_ADDR
// SetSide ( un , 0 ) ;
99109: LD_VAR 0 1
99113: PPUSH
99114: LD_INT 0
99116: PPUSH
99117: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
99121: LD_VAR 0 1
99125: PPUSH
99126: LD_OWVAR 3
99130: PUSH
99131: LD_VAR 0 1
99135: DIFF
99136: PPUSH
99137: LD_VAR 0 1
99141: PPUSH
99142: CALL_OW 74
99146: PPUSH
99147: CALL_OW 115
// wait ( 0 0$20 ) ;
99151: LD_INT 700
99153: PPUSH
99154: CALL_OW 67
// SetSide ( un , your_side ) ;
99158: LD_VAR 0 1
99162: PPUSH
99163: LD_OWVAR 2
99167: PPUSH
99168: CALL_OW 235
// end ;
99172: PPOPN 2
99174: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
99175: LD_EXP 98
99179: PUSH
99180: LD_EXP 131
99184: AND
99185: IFFALSE 99291
99187: GO 99189
99189: DISABLE
99190: LD_INT 0
99192: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
99193: LD_ADDR_VAR 0 1
99197: PUSH
99198: LD_INT 22
99200: PUSH
99201: LD_OWVAR 2
99205: PUSH
99206: EMPTY
99207: LIST
99208: LIST
99209: PUSH
99210: LD_INT 2
99212: PUSH
99213: LD_INT 30
99215: PUSH
99216: LD_INT 0
99218: PUSH
99219: EMPTY
99220: LIST
99221: LIST
99222: PUSH
99223: LD_INT 30
99225: PUSH
99226: LD_INT 1
99228: PUSH
99229: EMPTY
99230: LIST
99231: LIST
99232: PUSH
99233: EMPTY
99234: LIST
99235: LIST
99236: LIST
99237: PUSH
99238: EMPTY
99239: LIST
99240: LIST
99241: PPUSH
99242: CALL_OW 69
99246: ST_TO_ADDR
// if not depot then
99247: LD_VAR 0 1
99251: NOT
99252: IFFALSE 99256
// exit ;
99254: GO 99291
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
99256: LD_VAR 0 1
99260: PUSH
99261: LD_INT 1
99263: ARRAY
99264: PPUSH
99265: CALL_OW 250
99269: PPUSH
99270: LD_VAR 0 1
99274: PUSH
99275: LD_INT 1
99277: ARRAY
99278: PPUSH
99279: CALL_OW 251
99283: PPUSH
99284: LD_INT 70
99286: PPUSH
99287: CALL_OW 495
// end ;
99291: PPOPN 1
99293: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
99294: LD_EXP 98
99298: PUSH
99299: LD_EXP 132
99303: AND
99304: IFFALSE 99515
99306: GO 99308
99308: DISABLE
99309: LD_INT 0
99311: PPUSH
99312: PPUSH
99313: PPUSH
99314: PPUSH
99315: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99316: LD_ADDR_VAR 0 5
99320: PUSH
99321: LD_INT 22
99323: PUSH
99324: LD_OWVAR 2
99328: PUSH
99329: EMPTY
99330: LIST
99331: LIST
99332: PUSH
99333: LD_INT 21
99335: PUSH
99336: LD_INT 1
99338: PUSH
99339: EMPTY
99340: LIST
99341: LIST
99342: PUSH
99343: EMPTY
99344: LIST
99345: LIST
99346: PPUSH
99347: CALL_OW 69
99351: ST_TO_ADDR
// if not tmp then
99352: LD_VAR 0 5
99356: NOT
99357: IFFALSE 99361
// exit ;
99359: GO 99515
// for i in tmp do
99361: LD_ADDR_VAR 0 1
99365: PUSH
99366: LD_VAR 0 5
99370: PUSH
99371: FOR_IN
99372: IFFALSE 99513
// begin d := rand ( 0 , 5 ) ;
99374: LD_ADDR_VAR 0 4
99378: PUSH
99379: LD_INT 0
99381: PPUSH
99382: LD_INT 5
99384: PPUSH
99385: CALL_OW 12
99389: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
99390: LD_ADDR_VAR 0 2
99394: PUSH
99395: LD_VAR 0 1
99399: PPUSH
99400: CALL_OW 250
99404: PPUSH
99405: LD_VAR 0 4
99409: PPUSH
99410: LD_INT 3
99412: PPUSH
99413: LD_INT 12
99415: PPUSH
99416: CALL_OW 12
99420: PPUSH
99421: CALL_OW 272
99425: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
99426: LD_ADDR_VAR 0 3
99430: PUSH
99431: LD_VAR 0 1
99435: PPUSH
99436: CALL_OW 251
99440: PPUSH
99441: LD_VAR 0 4
99445: PPUSH
99446: LD_INT 3
99448: PPUSH
99449: LD_INT 12
99451: PPUSH
99452: CALL_OW 12
99456: PPUSH
99457: CALL_OW 273
99461: ST_TO_ADDR
// if ValidHex ( x , y ) then
99462: LD_VAR 0 2
99466: PPUSH
99467: LD_VAR 0 3
99471: PPUSH
99472: CALL_OW 488
99476: IFFALSE 99511
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
99478: LD_VAR 0 1
99482: PPUSH
99483: LD_VAR 0 2
99487: PPUSH
99488: LD_VAR 0 3
99492: PPUSH
99493: LD_INT 3
99495: PPUSH
99496: LD_INT 6
99498: PPUSH
99499: CALL_OW 12
99503: PPUSH
99504: LD_INT 1
99506: PPUSH
99507: CALL_OW 483
// end ;
99511: GO 99371
99513: POP
99514: POP
// end ;
99515: PPOPN 5
99517: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
99518: LD_EXP 98
99522: PUSH
99523: LD_EXP 133
99527: AND
99528: IFFALSE 99622
99530: GO 99532
99532: DISABLE
99533: LD_INT 0
99535: PPUSH
99536: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
99537: LD_ADDR_VAR 0 2
99541: PUSH
99542: LD_INT 22
99544: PUSH
99545: LD_OWVAR 2
99549: PUSH
99550: EMPTY
99551: LIST
99552: LIST
99553: PUSH
99554: LD_INT 32
99556: PUSH
99557: LD_INT 1
99559: PUSH
99560: EMPTY
99561: LIST
99562: LIST
99563: PUSH
99564: LD_INT 21
99566: PUSH
99567: LD_INT 2
99569: PUSH
99570: EMPTY
99571: LIST
99572: LIST
99573: PUSH
99574: EMPTY
99575: LIST
99576: LIST
99577: LIST
99578: PPUSH
99579: CALL_OW 69
99583: ST_TO_ADDR
// if not tmp then
99584: LD_VAR 0 2
99588: NOT
99589: IFFALSE 99593
// exit ;
99591: GO 99622
// for i in tmp do
99593: LD_ADDR_VAR 0 1
99597: PUSH
99598: LD_VAR 0 2
99602: PUSH
99603: FOR_IN
99604: IFFALSE 99620
// SetFuel ( i , 0 ) ;
99606: LD_VAR 0 1
99610: PPUSH
99611: LD_INT 0
99613: PPUSH
99614: CALL_OW 240
99618: GO 99603
99620: POP
99621: POP
// end ;
99622: PPOPN 2
99624: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
99625: LD_EXP 98
99629: PUSH
99630: LD_EXP 134
99634: AND
99635: IFFALSE 99701
99637: GO 99639
99639: DISABLE
99640: LD_INT 0
99642: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
99643: LD_ADDR_VAR 0 1
99647: PUSH
99648: LD_INT 22
99650: PUSH
99651: LD_OWVAR 2
99655: PUSH
99656: EMPTY
99657: LIST
99658: LIST
99659: PUSH
99660: LD_INT 30
99662: PUSH
99663: LD_INT 29
99665: PUSH
99666: EMPTY
99667: LIST
99668: LIST
99669: PUSH
99670: EMPTY
99671: LIST
99672: LIST
99673: PPUSH
99674: CALL_OW 69
99678: ST_TO_ADDR
// if not tmp then
99679: LD_VAR 0 1
99683: NOT
99684: IFFALSE 99688
// exit ;
99686: GO 99701
// DestroyUnit ( tmp [ 1 ] ) ;
99688: LD_VAR 0 1
99692: PUSH
99693: LD_INT 1
99695: ARRAY
99696: PPUSH
99697: CALL_OW 65
// end ;
99701: PPOPN 1
99703: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
99704: LD_EXP 98
99708: PUSH
99709: LD_EXP 136
99713: AND
99714: IFFALSE 99843
99716: GO 99718
99718: DISABLE
99719: LD_INT 0
99721: PPUSH
// begin uc_side := 0 ;
99722: LD_ADDR_OWVAR 20
99726: PUSH
99727: LD_INT 0
99729: ST_TO_ADDR
// uc_nation := nation_arabian ;
99730: LD_ADDR_OWVAR 21
99734: PUSH
99735: LD_INT 2
99737: ST_TO_ADDR
// hc_gallery :=  ;
99738: LD_ADDR_OWVAR 33
99742: PUSH
99743: LD_STRING 
99745: ST_TO_ADDR
// hc_name :=  ;
99746: LD_ADDR_OWVAR 26
99750: PUSH
99751: LD_STRING 
99753: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
99754: LD_INT 1
99756: PPUSH
99757: LD_INT 11
99759: PPUSH
99760: LD_INT 10
99762: PPUSH
99763: CALL_OW 380
// un := CreateHuman ;
99767: LD_ADDR_VAR 0 1
99771: PUSH
99772: CALL_OW 44
99776: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99777: LD_VAR 0 1
99781: PPUSH
99782: LD_INT 1
99784: PPUSH
99785: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
99789: LD_INT 35
99791: PPUSH
99792: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
99796: LD_VAR 0 1
99800: PPUSH
99801: LD_INT 22
99803: PUSH
99804: LD_OWVAR 2
99808: PUSH
99809: EMPTY
99810: LIST
99811: LIST
99812: PPUSH
99813: CALL_OW 69
99817: PPUSH
99818: LD_VAR 0 1
99822: PPUSH
99823: CALL_OW 74
99827: PPUSH
99828: CALL_OW 115
// until IsDead ( un ) ;
99832: LD_VAR 0 1
99836: PPUSH
99837: CALL_OW 301
99841: IFFALSE 99789
// end ;
99843: PPOPN 1
99845: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
99846: LD_EXP 98
99850: PUSH
99851: LD_EXP 138
99855: AND
99856: IFFALSE 99868
99858: GO 99860
99860: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
99861: LD_STRING earthquake(getX(game), 0, 32)
99863: PPUSH
99864: CALL_OW 559
99868: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
99869: LD_EXP 98
99873: PUSH
99874: LD_EXP 139
99878: AND
99879: IFFALSE 99970
99881: GO 99883
99883: DISABLE
99884: LD_INT 0
99886: PPUSH
// begin enable ;
99887: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
99888: LD_ADDR_VAR 0 1
99892: PUSH
99893: LD_INT 22
99895: PUSH
99896: LD_OWVAR 2
99900: PUSH
99901: EMPTY
99902: LIST
99903: LIST
99904: PUSH
99905: LD_INT 21
99907: PUSH
99908: LD_INT 2
99910: PUSH
99911: EMPTY
99912: LIST
99913: LIST
99914: PUSH
99915: LD_INT 33
99917: PUSH
99918: LD_INT 3
99920: PUSH
99921: EMPTY
99922: LIST
99923: LIST
99924: PUSH
99925: EMPTY
99926: LIST
99927: LIST
99928: LIST
99929: PPUSH
99930: CALL_OW 69
99934: ST_TO_ADDR
// if not tmp then
99935: LD_VAR 0 1
99939: NOT
99940: IFFALSE 99944
// exit ;
99942: GO 99970
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
99944: LD_VAR 0 1
99948: PUSH
99949: LD_INT 1
99951: PPUSH
99952: LD_VAR 0 1
99956: PPUSH
99957: CALL_OW 12
99961: ARRAY
99962: PPUSH
99963: LD_INT 1
99965: PPUSH
99966: CALL_OW 234
// end ;
99970: PPOPN 1
99972: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
99973: LD_EXP 98
99977: PUSH
99978: LD_EXP 140
99982: AND
99983: IFFALSE 100124
99985: GO 99987
99987: DISABLE
99988: LD_INT 0
99990: PPUSH
99991: PPUSH
99992: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99993: LD_ADDR_VAR 0 3
99997: PUSH
99998: LD_INT 22
100000: PUSH
100001: LD_OWVAR 2
100005: PUSH
100006: EMPTY
100007: LIST
100008: LIST
100009: PUSH
100010: LD_INT 25
100012: PUSH
100013: LD_INT 1
100015: PUSH
100016: EMPTY
100017: LIST
100018: LIST
100019: PUSH
100020: EMPTY
100021: LIST
100022: LIST
100023: PPUSH
100024: CALL_OW 69
100028: ST_TO_ADDR
// if not tmp then
100029: LD_VAR 0 3
100033: NOT
100034: IFFALSE 100038
// exit ;
100036: GO 100124
// un := tmp [ rand ( 1 , tmp ) ] ;
100038: LD_ADDR_VAR 0 2
100042: PUSH
100043: LD_VAR 0 3
100047: PUSH
100048: LD_INT 1
100050: PPUSH
100051: LD_VAR 0 3
100055: PPUSH
100056: CALL_OW 12
100060: ARRAY
100061: ST_TO_ADDR
// if Crawls ( un ) then
100062: LD_VAR 0 2
100066: PPUSH
100067: CALL_OW 318
100071: IFFALSE 100082
// ComWalk ( un ) ;
100073: LD_VAR 0 2
100077: PPUSH
100078: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
100082: LD_VAR 0 2
100086: PPUSH
100087: LD_INT 9
100089: PPUSH
100090: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
100094: LD_INT 28
100096: PPUSH
100097: LD_OWVAR 2
100101: PPUSH
100102: LD_INT 2
100104: PPUSH
100105: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
100109: LD_INT 29
100111: PPUSH
100112: LD_OWVAR 2
100116: PPUSH
100117: LD_INT 2
100119: PPUSH
100120: CALL_OW 322
// end ;
100124: PPOPN 3
100126: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
100127: LD_EXP 98
100131: PUSH
100132: LD_EXP 141
100136: AND
100137: IFFALSE 100248
100139: GO 100141
100141: DISABLE
100142: LD_INT 0
100144: PPUSH
100145: PPUSH
100146: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100147: LD_ADDR_VAR 0 3
100151: PUSH
100152: LD_INT 22
100154: PUSH
100155: LD_OWVAR 2
100159: PUSH
100160: EMPTY
100161: LIST
100162: LIST
100163: PUSH
100164: LD_INT 25
100166: PUSH
100167: LD_INT 1
100169: PUSH
100170: EMPTY
100171: LIST
100172: LIST
100173: PUSH
100174: EMPTY
100175: LIST
100176: LIST
100177: PPUSH
100178: CALL_OW 69
100182: ST_TO_ADDR
// if not tmp then
100183: LD_VAR 0 3
100187: NOT
100188: IFFALSE 100192
// exit ;
100190: GO 100248
// un := tmp [ rand ( 1 , tmp ) ] ;
100192: LD_ADDR_VAR 0 2
100196: PUSH
100197: LD_VAR 0 3
100201: PUSH
100202: LD_INT 1
100204: PPUSH
100205: LD_VAR 0 3
100209: PPUSH
100210: CALL_OW 12
100214: ARRAY
100215: ST_TO_ADDR
// if Crawls ( un ) then
100216: LD_VAR 0 2
100220: PPUSH
100221: CALL_OW 318
100225: IFFALSE 100236
// ComWalk ( un ) ;
100227: LD_VAR 0 2
100231: PPUSH
100232: CALL_OW 138
// SetClass ( un , class_mortar ) ;
100236: LD_VAR 0 2
100240: PPUSH
100241: LD_INT 8
100243: PPUSH
100244: CALL_OW 336
// end ;
100248: PPOPN 3
100250: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
100251: LD_EXP 98
100255: PUSH
100256: LD_EXP 142
100260: AND
100261: IFFALSE 100405
100263: GO 100265
100265: DISABLE
100266: LD_INT 0
100268: PPUSH
100269: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
100270: LD_ADDR_VAR 0 2
100274: PUSH
100275: LD_INT 22
100277: PUSH
100278: LD_OWVAR 2
100282: PUSH
100283: EMPTY
100284: LIST
100285: LIST
100286: PUSH
100287: LD_INT 21
100289: PUSH
100290: LD_INT 2
100292: PUSH
100293: EMPTY
100294: LIST
100295: LIST
100296: PUSH
100297: LD_INT 2
100299: PUSH
100300: LD_INT 34
100302: PUSH
100303: LD_INT 12
100305: PUSH
100306: EMPTY
100307: LIST
100308: LIST
100309: PUSH
100310: LD_INT 34
100312: PUSH
100313: LD_INT 51
100315: PUSH
100316: EMPTY
100317: LIST
100318: LIST
100319: PUSH
100320: LD_INT 34
100322: PUSH
100323: LD_INT 32
100325: PUSH
100326: EMPTY
100327: LIST
100328: LIST
100329: PUSH
100330: EMPTY
100331: LIST
100332: LIST
100333: LIST
100334: LIST
100335: PUSH
100336: EMPTY
100337: LIST
100338: LIST
100339: LIST
100340: PPUSH
100341: CALL_OW 69
100345: ST_TO_ADDR
// if not tmp then
100346: LD_VAR 0 2
100350: NOT
100351: IFFALSE 100355
// exit ;
100353: GO 100405
// for i in tmp do
100355: LD_ADDR_VAR 0 1
100359: PUSH
100360: LD_VAR 0 2
100364: PUSH
100365: FOR_IN
100366: IFFALSE 100403
// if GetCargo ( i , mat_artifact ) = 0 then
100368: LD_VAR 0 1
100372: PPUSH
100373: LD_INT 4
100375: PPUSH
100376: CALL_OW 289
100380: PUSH
100381: LD_INT 0
100383: EQUAL
100384: IFFALSE 100401
// SetCargo ( i , mat_siberit , 100 ) ;
100386: LD_VAR 0 1
100390: PPUSH
100391: LD_INT 3
100393: PPUSH
100394: LD_INT 100
100396: PPUSH
100397: CALL_OW 290
100401: GO 100365
100403: POP
100404: POP
// end ;
100405: PPOPN 2
100407: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
100408: LD_EXP 98
100412: PUSH
100413: LD_EXP 143
100417: AND
100418: IFFALSE 100601
100420: GO 100422
100422: DISABLE
100423: LD_INT 0
100425: PPUSH
100426: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
100427: LD_ADDR_VAR 0 2
100431: PUSH
100432: LD_INT 22
100434: PUSH
100435: LD_OWVAR 2
100439: PUSH
100440: EMPTY
100441: LIST
100442: LIST
100443: PPUSH
100444: CALL_OW 69
100448: ST_TO_ADDR
// if not tmp then
100449: LD_VAR 0 2
100453: NOT
100454: IFFALSE 100458
// exit ;
100456: GO 100601
// for i := 1 to 2 do
100458: LD_ADDR_VAR 0 1
100462: PUSH
100463: DOUBLE
100464: LD_INT 1
100466: DEC
100467: ST_TO_ADDR
100468: LD_INT 2
100470: PUSH
100471: FOR_TO
100472: IFFALSE 100599
// begin uc_side := your_side ;
100474: LD_ADDR_OWVAR 20
100478: PUSH
100479: LD_OWVAR 2
100483: ST_TO_ADDR
// uc_nation := nation_american ;
100484: LD_ADDR_OWVAR 21
100488: PUSH
100489: LD_INT 1
100491: ST_TO_ADDR
// vc_chassis := us_morphling ;
100492: LD_ADDR_OWVAR 37
100496: PUSH
100497: LD_INT 5
100499: ST_TO_ADDR
// vc_engine := engine_siberite ;
100500: LD_ADDR_OWVAR 39
100504: PUSH
100505: LD_INT 3
100507: ST_TO_ADDR
// vc_control := control_computer ;
100508: LD_ADDR_OWVAR 38
100512: PUSH
100513: LD_INT 3
100515: ST_TO_ADDR
// vc_weapon := us_double_laser ;
100516: LD_ADDR_OWVAR 40
100520: PUSH
100521: LD_INT 10
100523: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
100524: LD_VAR 0 2
100528: PUSH
100529: LD_INT 1
100531: ARRAY
100532: PPUSH
100533: CALL_OW 310
100537: NOT
100538: IFFALSE 100585
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
100540: CALL_OW 45
100544: PPUSH
100545: LD_VAR 0 2
100549: PUSH
100550: LD_INT 1
100552: ARRAY
100553: PPUSH
100554: CALL_OW 250
100558: PPUSH
100559: LD_VAR 0 2
100563: PUSH
100564: LD_INT 1
100566: ARRAY
100567: PPUSH
100568: CALL_OW 251
100572: PPUSH
100573: LD_INT 12
100575: PPUSH
100576: LD_INT 1
100578: PPUSH
100579: CALL_OW 50
100583: GO 100597
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
100585: CALL_OW 45
100589: PPUSH
100590: LD_INT 1
100592: PPUSH
100593: CALL_OW 51
// end ;
100597: GO 100471
100599: POP
100600: POP
// end ;
100601: PPOPN 2
100603: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
100604: LD_EXP 98
100608: PUSH
100609: LD_EXP 144
100613: AND
100614: IFFALSE 100836
100616: GO 100618
100618: DISABLE
100619: LD_INT 0
100621: PPUSH
100622: PPUSH
100623: PPUSH
100624: PPUSH
100625: PPUSH
100626: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100627: LD_ADDR_VAR 0 6
100631: PUSH
100632: LD_INT 22
100634: PUSH
100635: LD_OWVAR 2
100639: PUSH
100640: EMPTY
100641: LIST
100642: LIST
100643: PUSH
100644: LD_INT 21
100646: PUSH
100647: LD_INT 1
100649: PUSH
100650: EMPTY
100651: LIST
100652: LIST
100653: PUSH
100654: LD_INT 3
100656: PUSH
100657: LD_INT 23
100659: PUSH
100660: LD_INT 0
100662: PUSH
100663: EMPTY
100664: LIST
100665: LIST
100666: PUSH
100667: EMPTY
100668: LIST
100669: LIST
100670: PUSH
100671: EMPTY
100672: LIST
100673: LIST
100674: LIST
100675: PPUSH
100676: CALL_OW 69
100680: ST_TO_ADDR
// if not tmp then
100681: LD_VAR 0 6
100685: NOT
100686: IFFALSE 100690
// exit ;
100688: GO 100836
// s1 := rand ( 1 , 4 ) ;
100690: LD_ADDR_VAR 0 2
100694: PUSH
100695: LD_INT 1
100697: PPUSH
100698: LD_INT 4
100700: PPUSH
100701: CALL_OW 12
100705: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
100706: LD_ADDR_VAR 0 4
100710: PUSH
100711: LD_VAR 0 6
100715: PUSH
100716: LD_INT 1
100718: ARRAY
100719: PPUSH
100720: LD_VAR 0 2
100724: PPUSH
100725: CALL_OW 259
100729: ST_TO_ADDR
// if s1 = 1 then
100730: LD_VAR 0 2
100734: PUSH
100735: LD_INT 1
100737: EQUAL
100738: IFFALSE 100758
// s2 := rand ( 2 , 4 ) else
100740: LD_ADDR_VAR 0 3
100744: PUSH
100745: LD_INT 2
100747: PPUSH
100748: LD_INT 4
100750: PPUSH
100751: CALL_OW 12
100755: ST_TO_ADDR
100756: GO 100766
// s2 := 1 ;
100758: LD_ADDR_VAR 0 3
100762: PUSH
100763: LD_INT 1
100765: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
100766: LD_ADDR_VAR 0 5
100770: PUSH
100771: LD_VAR 0 6
100775: PUSH
100776: LD_INT 1
100778: ARRAY
100779: PPUSH
100780: LD_VAR 0 3
100784: PPUSH
100785: CALL_OW 259
100789: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
100790: LD_VAR 0 6
100794: PUSH
100795: LD_INT 1
100797: ARRAY
100798: PPUSH
100799: LD_VAR 0 2
100803: PPUSH
100804: LD_VAR 0 5
100808: PPUSH
100809: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
100813: LD_VAR 0 6
100817: PUSH
100818: LD_INT 1
100820: ARRAY
100821: PPUSH
100822: LD_VAR 0 3
100826: PPUSH
100827: LD_VAR 0 4
100831: PPUSH
100832: CALL_OW 237
// end ;
100836: PPOPN 6
100838: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
100839: LD_EXP 98
100843: PUSH
100844: LD_EXP 145
100848: AND
100849: IFFALSE 100928
100851: GO 100853
100853: DISABLE
100854: LD_INT 0
100856: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
100857: LD_ADDR_VAR 0 1
100861: PUSH
100862: LD_INT 22
100864: PUSH
100865: LD_OWVAR 2
100869: PUSH
100870: EMPTY
100871: LIST
100872: LIST
100873: PUSH
100874: LD_INT 30
100876: PUSH
100877: LD_INT 3
100879: PUSH
100880: EMPTY
100881: LIST
100882: LIST
100883: PUSH
100884: EMPTY
100885: LIST
100886: LIST
100887: PPUSH
100888: CALL_OW 69
100892: ST_TO_ADDR
// if not tmp then
100893: LD_VAR 0 1
100897: NOT
100898: IFFALSE 100902
// exit ;
100900: GO 100928
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
100902: LD_VAR 0 1
100906: PUSH
100907: LD_INT 1
100909: PPUSH
100910: LD_VAR 0 1
100914: PPUSH
100915: CALL_OW 12
100919: ARRAY
100920: PPUSH
100921: LD_INT 1
100923: PPUSH
100924: CALL_OW 234
// end ;
100928: PPOPN 1
100930: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
100931: LD_EXP 98
100935: PUSH
100936: LD_EXP 146
100940: AND
100941: IFFALSE 101053
100943: GO 100945
100945: DISABLE
100946: LD_INT 0
100948: PPUSH
100949: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
100950: LD_ADDR_VAR 0 2
100954: PUSH
100955: LD_INT 22
100957: PUSH
100958: LD_OWVAR 2
100962: PUSH
100963: EMPTY
100964: LIST
100965: LIST
100966: PUSH
100967: LD_INT 2
100969: PUSH
100970: LD_INT 30
100972: PUSH
100973: LD_INT 27
100975: PUSH
100976: EMPTY
100977: LIST
100978: LIST
100979: PUSH
100980: LD_INT 30
100982: PUSH
100983: LD_INT 26
100985: PUSH
100986: EMPTY
100987: LIST
100988: LIST
100989: PUSH
100990: LD_INT 30
100992: PUSH
100993: LD_INT 28
100995: PUSH
100996: EMPTY
100997: LIST
100998: LIST
100999: PUSH
101000: EMPTY
101001: LIST
101002: LIST
101003: LIST
101004: LIST
101005: PUSH
101006: EMPTY
101007: LIST
101008: LIST
101009: PPUSH
101010: CALL_OW 69
101014: ST_TO_ADDR
// if not tmp then
101015: LD_VAR 0 2
101019: NOT
101020: IFFALSE 101024
// exit ;
101022: GO 101053
// for i in tmp do
101024: LD_ADDR_VAR 0 1
101028: PUSH
101029: LD_VAR 0 2
101033: PUSH
101034: FOR_IN
101035: IFFALSE 101051
// SetLives ( i , 1 ) ;
101037: LD_VAR 0 1
101041: PPUSH
101042: LD_INT 1
101044: PPUSH
101045: CALL_OW 234
101049: GO 101034
101051: POP
101052: POP
// end ;
101053: PPOPN 2
101055: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
101056: LD_EXP 98
101060: PUSH
101061: LD_EXP 147
101065: AND
101066: IFFALSE 101340
101068: GO 101070
101070: DISABLE
101071: LD_INT 0
101073: PPUSH
101074: PPUSH
101075: PPUSH
// begin i := rand ( 1 , 7 ) ;
101076: LD_ADDR_VAR 0 1
101080: PUSH
101081: LD_INT 1
101083: PPUSH
101084: LD_INT 7
101086: PPUSH
101087: CALL_OW 12
101091: ST_TO_ADDR
// case i of 1 :
101092: LD_VAR 0 1
101096: PUSH
101097: LD_INT 1
101099: DOUBLE
101100: EQUAL
101101: IFTRUE 101105
101103: GO 101115
101105: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
101106: LD_STRING earthquake(getX(game), 0, 32)
101108: PPUSH
101109: CALL_OW 559
101113: GO 101340
101115: LD_INT 2
101117: DOUBLE
101118: EQUAL
101119: IFTRUE 101123
101121: GO 101137
101123: POP
// begin ToLua ( displayStucuk(); ) ;
101124: LD_STRING displayStucuk();
101126: PPUSH
101127: CALL_OW 559
// ResetFog ;
101131: CALL_OW 335
// end ; 3 :
101135: GO 101340
101137: LD_INT 3
101139: DOUBLE
101140: EQUAL
101141: IFTRUE 101145
101143: GO 101249
101145: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101146: LD_ADDR_VAR 0 2
101150: PUSH
101151: LD_INT 22
101153: PUSH
101154: LD_OWVAR 2
101158: PUSH
101159: EMPTY
101160: LIST
101161: LIST
101162: PUSH
101163: LD_INT 25
101165: PUSH
101166: LD_INT 1
101168: PUSH
101169: EMPTY
101170: LIST
101171: LIST
101172: PUSH
101173: EMPTY
101174: LIST
101175: LIST
101176: PPUSH
101177: CALL_OW 69
101181: ST_TO_ADDR
// if not tmp then
101182: LD_VAR 0 2
101186: NOT
101187: IFFALSE 101191
// exit ;
101189: GO 101340
// un := tmp [ rand ( 1 , tmp ) ] ;
101191: LD_ADDR_VAR 0 3
101195: PUSH
101196: LD_VAR 0 2
101200: PUSH
101201: LD_INT 1
101203: PPUSH
101204: LD_VAR 0 2
101208: PPUSH
101209: CALL_OW 12
101213: ARRAY
101214: ST_TO_ADDR
// if Crawls ( un ) then
101215: LD_VAR 0 3
101219: PPUSH
101220: CALL_OW 318
101224: IFFALSE 101235
// ComWalk ( un ) ;
101226: LD_VAR 0 3
101230: PPUSH
101231: CALL_OW 138
// SetClass ( un , class_mortar ) ;
101235: LD_VAR 0 3
101239: PPUSH
101240: LD_INT 8
101242: PPUSH
101243: CALL_OW 336
// end ; 4 :
101247: GO 101340
101249: LD_INT 4
101251: DOUBLE
101252: EQUAL
101253: IFTRUE 101257
101255: GO 101318
101257: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
101258: LD_ADDR_VAR 0 2
101262: PUSH
101263: LD_INT 22
101265: PUSH
101266: LD_OWVAR 2
101270: PUSH
101271: EMPTY
101272: LIST
101273: LIST
101274: PUSH
101275: LD_INT 30
101277: PUSH
101278: LD_INT 29
101280: PUSH
101281: EMPTY
101282: LIST
101283: LIST
101284: PUSH
101285: EMPTY
101286: LIST
101287: LIST
101288: PPUSH
101289: CALL_OW 69
101293: ST_TO_ADDR
// if not tmp then
101294: LD_VAR 0 2
101298: NOT
101299: IFFALSE 101303
// exit ;
101301: GO 101340
// DestroyUnit ( tmp [ 1 ] ) ;
101303: LD_VAR 0 2
101307: PUSH
101308: LD_INT 1
101310: ARRAY
101311: PPUSH
101312: CALL_OW 65
// end ; 5 .. 7 :
101316: GO 101340
101318: LD_INT 5
101320: DOUBLE
101321: GREATEREQUAL
101322: IFFALSE 101330
101324: LD_INT 7
101326: DOUBLE
101327: LESSEQUAL
101328: IFTRUE 101332
101330: GO 101339
101332: POP
// StreamSibBomb ; end ;
101333: CALL 97590 0 0
101337: GO 101340
101339: POP
// end ;
101340: PPOPN 3
101342: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
101343: LD_EXP 98
101347: PUSH
101348: LD_EXP 148
101352: AND
101353: IFFALSE 101509
101355: GO 101357
101357: DISABLE
101358: LD_INT 0
101360: PPUSH
101361: PPUSH
101362: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
101363: LD_ADDR_VAR 0 2
101367: PUSH
101368: LD_INT 81
101370: PUSH
101371: LD_OWVAR 2
101375: PUSH
101376: EMPTY
101377: LIST
101378: LIST
101379: PUSH
101380: LD_INT 2
101382: PUSH
101383: LD_INT 21
101385: PUSH
101386: LD_INT 1
101388: PUSH
101389: EMPTY
101390: LIST
101391: LIST
101392: PUSH
101393: LD_INT 21
101395: PUSH
101396: LD_INT 2
101398: PUSH
101399: EMPTY
101400: LIST
101401: LIST
101402: PUSH
101403: EMPTY
101404: LIST
101405: LIST
101406: LIST
101407: PUSH
101408: EMPTY
101409: LIST
101410: LIST
101411: PPUSH
101412: CALL_OW 69
101416: ST_TO_ADDR
// if not tmp then
101417: LD_VAR 0 2
101421: NOT
101422: IFFALSE 101426
// exit ;
101424: GO 101509
// p := 0 ;
101426: LD_ADDR_VAR 0 3
101430: PUSH
101431: LD_INT 0
101433: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
101434: LD_INT 35
101436: PPUSH
101437: CALL_OW 67
// p := p + 1 ;
101441: LD_ADDR_VAR 0 3
101445: PUSH
101446: LD_VAR 0 3
101450: PUSH
101451: LD_INT 1
101453: PLUS
101454: ST_TO_ADDR
// for i in tmp do
101455: LD_ADDR_VAR 0 1
101459: PUSH
101460: LD_VAR 0 2
101464: PUSH
101465: FOR_IN
101466: IFFALSE 101497
// if GetLives ( i ) < 1000 then
101468: LD_VAR 0 1
101472: PPUSH
101473: CALL_OW 256
101477: PUSH
101478: LD_INT 1000
101480: LESS
101481: IFFALSE 101495
// SetLives ( i , 1000 ) ;
101483: LD_VAR 0 1
101487: PPUSH
101488: LD_INT 1000
101490: PPUSH
101491: CALL_OW 234
101495: GO 101465
101497: POP
101498: POP
// until p > 20 ;
101499: LD_VAR 0 3
101503: PUSH
101504: LD_INT 20
101506: GREATER
101507: IFFALSE 101434
// end ;
101509: PPOPN 3
101511: END
// every 0 0$1 trigger StreamModeActive and sTime do
101512: LD_EXP 98
101516: PUSH
101517: LD_EXP 149
101521: AND
101522: IFFALSE 101557
101524: GO 101526
101526: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
101527: LD_INT 28
101529: PPUSH
101530: LD_OWVAR 2
101534: PPUSH
101535: LD_INT 2
101537: PPUSH
101538: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
101542: LD_INT 30
101544: PPUSH
101545: LD_OWVAR 2
101549: PPUSH
101550: LD_INT 2
101552: PPUSH
101553: CALL_OW 322
// end ;
101557: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
101558: LD_EXP 98
101562: PUSH
101563: LD_EXP 150
101567: AND
101568: IFFALSE 101689
101570: GO 101572
101572: DISABLE
101573: LD_INT 0
101575: PPUSH
101576: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
101577: LD_ADDR_VAR 0 2
101581: PUSH
101582: LD_INT 22
101584: PUSH
101585: LD_OWVAR 2
101589: PUSH
101590: EMPTY
101591: LIST
101592: LIST
101593: PUSH
101594: LD_INT 21
101596: PUSH
101597: LD_INT 1
101599: PUSH
101600: EMPTY
101601: LIST
101602: LIST
101603: PUSH
101604: LD_INT 3
101606: PUSH
101607: LD_INT 23
101609: PUSH
101610: LD_INT 0
101612: PUSH
101613: EMPTY
101614: LIST
101615: LIST
101616: PUSH
101617: EMPTY
101618: LIST
101619: LIST
101620: PUSH
101621: EMPTY
101622: LIST
101623: LIST
101624: LIST
101625: PPUSH
101626: CALL_OW 69
101630: ST_TO_ADDR
// if not tmp then
101631: LD_VAR 0 2
101635: NOT
101636: IFFALSE 101640
// exit ;
101638: GO 101689
// for i in tmp do
101640: LD_ADDR_VAR 0 1
101644: PUSH
101645: LD_VAR 0 2
101649: PUSH
101650: FOR_IN
101651: IFFALSE 101687
// begin if Crawls ( i ) then
101653: LD_VAR 0 1
101657: PPUSH
101658: CALL_OW 318
101662: IFFALSE 101673
// ComWalk ( i ) ;
101664: LD_VAR 0 1
101668: PPUSH
101669: CALL_OW 138
// SetClass ( i , 2 ) ;
101673: LD_VAR 0 1
101677: PPUSH
101678: LD_INT 2
101680: PPUSH
101681: CALL_OW 336
// end ;
101685: GO 101650
101687: POP
101688: POP
// end ;
101689: PPOPN 2
101691: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
101692: LD_EXP 98
101696: PUSH
101697: LD_EXP 151
101701: AND
101702: IFFALSE 101983
101704: GO 101706
101706: DISABLE
101707: LD_INT 0
101709: PPUSH
101710: PPUSH
101711: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
101712: LD_OWVAR 2
101716: PPUSH
101717: LD_INT 9
101719: PPUSH
101720: LD_INT 1
101722: PPUSH
101723: LD_INT 1
101725: PPUSH
101726: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
101730: LD_INT 9
101732: PPUSH
101733: LD_OWVAR 2
101737: PPUSH
101738: CALL_OW 343
// uc_side := 9 ;
101742: LD_ADDR_OWVAR 20
101746: PUSH
101747: LD_INT 9
101749: ST_TO_ADDR
// uc_nation := 2 ;
101750: LD_ADDR_OWVAR 21
101754: PUSH
101755: LD_INT 2
101757: ST_TO_ADDR
// hc_name := Dark Warrior ;
101758: LD_ADDR_OWVAR 26
101762: PUSH
101763: LD_STRING Dark Warrior
101765: ST_TO_ADDR
// hc_gallery :=  ;
101766: LD_ADDR_OWVAR 33
101770: PUSH
101771: LD_STRING 
101773: ST_TO_ADDR
// hc_noskilllimit := true ;
101774: LD_ADDR_OWVAR 76
101778: PUSH
101779: LD_INT 1
101781: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
101782: LD_ADDR_OWVAR 31
101786: PUSH
101787: LD_INT 30
101789: PUSH
101790: LD_INT 30
101792: PUSH
101793: LD_INT 30
101795: PUSH
101796: LD_INT 30
101798: PUSH
101799: EMPTY
101800: LIST
101801: LIST
101802: LIST
101803: LIST
101804: ST_TO_ADDR
// un := CreateHuman ;
101805: LD_ADDR_VAR 0 3
101809: PUSH
101810: CALL_OW 44
101814: ST_TO_ADDR
// hc_noskilllimit := false ;
101815: LD_ADDR_OWVAR 76
101819: PUSH
101820: LD_INT 0
101822: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101823: LD_VAR 0 3
101827: PPUSH
101828: LD_INT 1
101830: PPUSH
101831: CALL_OW 51
// p := 0 ;
101835: LD_ADDR_VAR 0 2
101839: PUSH
101840: LD_INT 0
101842: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
101843: LD_INT 35
101845: PPUSH
101846: CALL_OW 67
// p := p + 1 ;
101850: LD_ADDR_VAR 0 2
101854: PUSH
101855: LD_VAR 0 2
101859: PUSH
101860: LD_INT 1
101862: PLUS
101863: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
101864: LD_VAR 0 3
101868: PPUSH
101869: CALL_OW 256
101873: PUSH
101874: LD_INT 1000
101876: LESS
101877: IFFALSE 101891
// SetLives ( un , 1000 ) ;
101879: LD_VAR 0 3
101883: PPUSH
101884: LD_INT 1000
101886: PPUSH
101887: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
101891: LD_VAR 0 3
101895: PPUSH
101896: LD_INT 81
101898: PUSH
101899: LD_OWVAR 2
101903: PUSH
101904: EMPTY
101905: LIST
101906: LIST
101907: PUSH
101908: LD_INT 91
101910: PUSH
101911: LD_VAR 0 3
101915: PUSH
101916: LD_INT 30
101918: PUSH
101919: EMPTY
101920: LIST
101921: LIST
101922: LIST
101923: PUSH
101924: EMPTY
101925: LIST
101926: LIST
101927: PPUSH
101928: CALL_OW 69
101932: PPUSH
101933: LD_VAR 0 3
101937: PPUSH
101938: CALL_OW 74
101942: PPUSH
101943: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
101947: LD_VAR 0 2
101951: PUSH
101952: LD_INT 60
101954: GREATER
101955: PUSH
101956: LD_VAR 0 3
101960: PPUSH
101961: CALL_OW 301
101965: OR
101966: IFFALSE 101843
// if un then
101968: LD_VAR 0 3
101972: IFFALSE 101983
// RemoveUnit ( un ) ;
101974: LD_VAR 0 3
101978: PPUSH
101979: CALL_OW 64
// end ;
101983: PPOPN 3
101985: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
101986: LD_INT 0
101988: PPUSH
// case cmd of 301 :
101989: LD_VAR 0 1
101993: PUSH
101994: LD_INT 301
101996: DOUBLE
101997: EQUAL
101998: IFTRUE 102002
102000: GO 102034
102002: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
102003: LD_VAR 0 6
102007: PPUSH
102008: LD_VAR 0 7
102012: PPUSH
102013: LD_VAR 0 8
102017: PPUSH
102018: LD_VAR 0 4
102022: PPUSH
102023: LD_VAR 0 5
102027: PPUSH
102028: CALL 103235 0 5
102032: GO 102155
102034: LD_INT 302
102036: DOUBLE
102037: EQUAL
102038: IFTRUE 102042
102040: GO 102079
102042: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
102043: LD_VAR 0 6
102047: PPUSH
102048: LD_VAR 0 7
102052: PPUSH
102053: LD_VAR 0 8
102057: PPUSH
102058: LD_VAR 0 9
102062: PPUSH
102063: LD_VAR 0 4
102067: PPUSH
102068: LD_VAR 0 5
102072: PPUSH
102073: CALL 103326 0 6
102077: GO 102155
102079: LD_INT 303
102081: DOUBLE
102082: EQUAL
102083: IFTRUE 102087
102085: GO 102124
102087: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
102088: LD_VAR 0 6
102092: PPUSH
102093: LD_VAR 0 7
102097: PPUSH
102098: LD_VAR 0 8
102102: PPUSH
102103: LD_VAR 0 9
102107: PPUSH
102108: LD_VAR 0 4
102112: PPUSH
102113: LD_VAR 0 5
102117: PPUSH
102118: CALL 102160 0 6
102122: GO 102155
102124: LD_INT 304
102126: DOUBLE
102127: EQUAL
102128: IFTRUE 102132
102130: GO 102154
102132: POP
// hHackTeleport ( unit , x , y ) ; end ;
102133: LD_VAR 0 2
102137: PPUSH
102138: LD_VAR 0 4
102142: PPUSH
102143: LD_VAR 0 5
102147: PPUSH
102148: CALL 103919 0 3
102152: GO 102155
102154: POP
// end ;
102155: LD_VAR 0 12
102159: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
102160: LD_INT 0
102162: PPUSH
102163: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
102164: LD_VAR 0 1
102168: PUSH
102169: LD_INT 1
102171: LESS
102172: PUSH
102173: LD_VAR 0 1
102177: PUSH
102178: LD_INT 3
102180: GREATER
102181: OR
102182: PUSH
102183: LD_VAR 0 5
102187: PPUSH
102188: LD_VAR 0 6
102192: PPUSH
102193: CALL_OW 428
102197: OR
102198: IFFALSE 102202
// exit ;
102200: GO 102922
// uc_side := your_side ;
102202: LD_ADDR_OWVAR 20
102206: PUSH
102207: LD_OWVAR 2
102211: ST_TO_ADDR
// uc_nation := nation ;
102212: LD_ADDR_OWVAR 21
102216: PUSH
102217: LD_VAR 0 1
102221: ST_TO_ADDR
// bc_level = 1 ;
102222: LD_ADDR_OWVAR 43
102226: PUSH
102227: LD_INT 1
102229: ST_TO_ADDR
// case btype of 1 :
102230: LD_VAR 0 2
102234: PUSH
102235: LD_INT 1
102237: DOUBLE
102238: EQUAL
102239: IFTRUE 102243
102241: GO 102254
102243: POP
// bc_type := b_depot ; 2 :
102244: LD_ADDR_OWVAR 42
102248: PUSH
102249: LD_INT 0
102251: ST_TO_ADDR
102252: GO 102866
102254: LD_INT 2
102256: DOUBLE
102257: EQUAL
102258: IFTRUE 102262
102260: GO 102273
102262: POP
// bc_type := b_warehouse ; 3 :
102263: LD_ADDR_OWVAR 42
102267: PUSH
102268: LD_INT 1
102270: ST_TO_ADDR
102271: GO 102866
102273: LD_INT 3
102275: DOUBLE
102276: EQUAL
102277: IFTRUE 102281
102279: GO 102292
102281: POP
// bc_type := b_lab ; 4 .. 9 :
102282: LD_ADDR_OWVAR 42
102286: PUSH
102287: LD_INT 6
102289: ST_TO_ADDR
102290: GO 102866
102292: LD_INT 4
102294: DOUBLE
102295: GREATEREQUAL
102296: IFFALSE 102304
102298: LD_INT 9
102300: DOUBLE
102301: LESSEQUAL
102302: IFTRUE 102306
102304: GO 102358
102306: POP
// begin bc_type := b_lab_half ;
102307: LD_ADDR_OWVAR 42
102311: PUSH
102312: LD_INT 7
102314: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
102315: LD_ADDR_OWVAR 44
102319: PUSH
102320: LD_INT 10
102322: PUSH
102323: LD_INT 11
102325: PUSH
102326: LD_INT 12
102328: PUSH
102329: LD_INT 15
102331: PUSH
102332: LD_INT 14
102334: PUSH
102335: LD_INT 13
102337: PUSH
102338: EMPTY
102339: LIST
102340: LIST
102341: LIST
102342: LIST
102343: LIST
102344: LIST
102345: PUSH
102346: LD_VAR 0 2
102350: PUSH
102351: LD_INT 3
102353: MINUS
102354: ARRAY
102355: ST_TO_ADDR
// end ; 10 .. 13 :
102356: GO 102866
102358: LD_INT 10
102360: DOUBLE
102361: GREATEREQUAL
102362: IFFALSE 102370
102364: LD_INT 13
102366: DOUBLE
102367: LESSEQUAL
102368: IFTRUE 102372
102370: GO 102449
102372: POP
// begin bc_type := b_lab_full ;
102373: LD_ADDR_OWVAR 42
102377: PUSH
102378: LD_INT 8
102380: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
102381: LD_ADDR_OWVAR 44
102385: PUSH
102386: LD_INT 10
102388: PUSH
102389: LD_INT 12
102391: PUSH
102392: LD_INT 14
102394: PUSH
102395: LD_INT 13
102397: PUSH
102398: EMPTY
102399: LIST
102400: LIST
102401: LIST
102402: LIST
102403: PUSH
102404: LD_VAR 0 2
102408: PUSH
102409: LD_INT 9
102411: MINUS
102412: ARRAY
102413: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
102414: LD_ADDR_OWVAR 45
102418: PUSH
102419: LD_INT 11
102421: PUSH
102422: LD_INT 15
102424: PUSH
102425: LD_INT 12
102427: PUSH
102428: LD_INT 15
102430: PUSH
102431: EMPTY
102432: LIST
102433: LIST
102434: LIST
102435: LIST
102436: PUSH
102437: LD_VAR 0 2
102441: PUSH
102442: LD_INT 9
102444: MINUS
102445: ARRAY
102446: ST_TO_ADDR
// end ; 14 :
102447: GO 102866
102449: LD_INT 14
102451: DOUBLE
102452: EQUAL
102453: IFTRUE 102457
102455: GO 102468
102457: POP
// bc_type := b_workshop ; 15 :
102458: LD_ADDR_OWVAR 42
102462: PUSH
102463: LD_INT 2
102465: ST_TO_ADDR
102466: GO 102866
102468: LD_INT 15
102470: DOUBLE
102471: EQUAL
102472: IFTRUE 102476
102474: GO 102487
102476: POP
// bc_type := b_factory ; 16 :
102477: LD_ADDR_OWVAR 42
102481: PUSH
102482: LD_INT 3
102484: ST_TO_ADDR
102485: GO 102866
102487: LD_INT 16
102489: DOUBLE
102490: EQUAL
102491: IFTRUE 102495
102493: GO 102506
102495: POP
// bc_type := b_ext_gun ; 17 :
102496: LD_ADDR_OWVAR 42
102500: PUSH
102501: LD_INT 17
102503: ST_TO_ADDR
102504: GO 102866
102506: LD_INT 17
102508: DOUBLE
102509: EQUAL
102510: IFTRUE 102514
102512: GO 102542
102514: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
102515: LD_ADDR_OWVAR 42
102519: PUSH
102520: LD_INT 19
102522: PUSH
102523: LD_INT 23
102525: PUSH
102526: LD_INT 19
102528: PUSH
102529: EMPTY
102530: LIST
102531: LIST
102532: LIST
102533: PUSH
102534: LD_VAR 0 1
102538: ARRAY
102539: ST_TO_ADDR
102540: GO 102866
102542: LD_INT 18
102544: DOUBLE
102545: EQUAL
102546: IFTRUE 102550
102548: GO 102561
102550: POP
// bc_type := b_ext_radar ; 19 :
102551: LD_ADDR_OWVAR 42
102555: PUSH
102556: LD_INT 20
102558: ST_TO_ADDR
102559: GO 102866
102561: LD_INT 19
102563: DOUBLE
102564: EQUAL
102565: IFTRUE 102569
102567: GO 102580
102569: POP
// bc_type := b_ext_radio ; 20 :
102570: LD_ADDR_OWVAR 42
102574: PUSH
102575: LD_INT 22
102577: ST_TO_ADDR
102578: GO 102866
102580: LD_INT 20
102582: DOUBLE
102583: EQUAL
102584: IFTRUE 102588
102586: GO 102599
102588: POP
// bc_type := b_ext_siberium ; 21 :
102589: LD_ADDR_OWVAR 42
102593: PUSH
102594: LD_INT 21
102596: ST_TO_ADDR
102597: GO 102866
102599: LD_INT 21
102601: DOUBLE
102602: EQUAL
102603: IFTRUE 102607
102605: GO 102618
102607: POP
// bc_type := b_ext_computer ; 22 :
102608: LD_ADDR_OWVAR 42
102612: PUSH
102613: LD_INT 24
102615: ST_TO_ADDR
102616: GO 102866
102618: LD_INT 22
102620: DOUBLE
102621: EQUAL
102622: IFTRUE 102626
102624: GO 102637
102626: POP
// bc_type := b_ext_track ; 23 :
102627: LD_ADDR_OWVAR 42
102631: PUSH
102632: LD_INT 16
102634: ST_TO_ADDR
102635: GO 102866
102637: LD_INT 23
102639: DOUBLE
102640: EQUAL
102641: IFTRUE 102645
102643: GO 102656
102645: POP
// bc_type := b_ext_laser ; 24 :
102646: LD_ADDR_OWVAR 42
102650: PUSH
102651: LD_INT 25
102653: ST_TO_ADDR
102654: GO 102866
102656: LD_INT 24
102658: DOUBLE
102659: EQUAL
102660: IFTRUE 102664
102662: GO 102675
102664: POP
// bc_type := b_control_tower ; 25 :
102665: LD_ADDR_OWVAR 42
102669: PUSH
102670: LD_INT 36
102672: ST_TO_ADDR
102673: GO 102866
102675: LD_INT 25
102677: DOUBLE
102678: EQUAL
102679: IFTRUE 102683
102681: GO 102694
102683: POP
// bc_type := b_breastwork ; 26 :
102684: LD_ADDR_OWVAR 42
102688: PUSH
102689: LD_INT 31
102691: ST_TO_ADDR
102692: GO 102866
102694: LD_INT 26
102696: DOUBLE
102697: EQUAL
102698: IFTRUE 102702
102700: GO 102713
102702: POP
// bc_type := b_bunker ; 27 :
102703: LD_ADDR_OWVAR 42
102707: PUSH
102708: LD_INT 32
102710: ST_TO_ADDR
102711: GO 102866
102713: LD_INT 27
102715: DOUBLE
102716: EQUAL
102717: IFTRUE 102721
102719: GO 102732
102721: POP
// bc_type := b_turret ; 28 :
102722: LD_ADDR_OWVAR 42
102726: PUSH
102727: LD_INT 33
102729: ST_TO_ADDR
102730: GO 102866
102732: LD_INT 28
102734: DOUBLE
102735: EQUAL
102736: IFTRUE 102740
102738: GO 102751
102740: POP
// bc_type := b_armoury ; 29 :
102741: LD_ADDR_OWVAR 42
102745: PUSH
102746: LD_INT 4
102748: ST_TO_ADDR
102749: GO 102866
102751: LD_INT 29
102753: DOUBLE
102754: EQUAL
102755: IFTRUE 102759
102757: GO 102770
102759: POP
// bc_type := b_barracks ; 30 :
102760: LD_ADDR_OWVAR 42
102764: PUSH
102765: LD_INT 5
102767: ST_TO_ADDR
102768: GO 102866
102770: LD_INT 30
102772: DOUBLE
102773: EQUAL
102774: IFTRUE 102778
102776: GO 102789
102778: POP
// bc_type := b_solar_power ; 31 :
102779: LD_ADDR_OWVAR 42
102783: PUSH
102784: LD_INT 27
102786: ST_TO_ADDR
102787: GO 102866
102789: LD_INT 31
102791: DOUBLE
102792: EQUAL
102793: IFTRUE 102797
102795: GO 102808
102797: POP
// bc_type := b_oil_power ; 32 :
102798: LD_ADDR_OWVAR 42
102802: PUSH
102803: LD_INT 26
102805: ST_TO_ADDR
102806: GO 102866
102808: LD_INT 32
102810: DOUBLE
102811: EQUAL
102812: IFTRUE 102816
102814: GO 102827
102816: POP
// bc_type := b_siberite_power ; 33 :
102817: LD_ADDR_OWVAR 42
102821: PUSH
102822: LD_INT 28
102824: ST_TO_ADDR
102825: GO 102866
102827: LD_INT 33
102829: DOUBLE
102830: EQUAL
102831: IFTRUE 102835
102833: GO 102846
102835: POP
// bc_type := b_oil_mine ; 34 :
102836: LD_ADDR_OWVAR 42
102840: PUSH
102841: LD_INT 29
102843: ST_TO_ADDR
102844: GO 102866
102846: LD_INT 34
102848: DOUBLE
102849: EQUAL
102850: IFTRUE 102854
102852: GO 102865
102854: POP
// bc_type := b_siberite_mine ; end ;
102855: LD_ADDR_OWVAR 42
102859: PUSH
102860: LD_INT 30
102862: ST_TO_ADDR
102863: GO 102866
102865: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
102866: LD_ADDR_VAR 0 8
102870: PUSH
102871: LD_VAR 0 5
102875: PPUSH
102876: LD_VAR 0 6
102880: PPUSH
102881: LD_VAR 0 3
102885: PPUSH
102886: CALL_OW 47
102890: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
102891: LD_OWVAR 42
102895: PUSH
102896: LD_INT 32
102898: PUSH
102899: LD_INT 33
102901: PUSH
102902: EMPTY
102903: LIST
102904: LIST
102905: IN
102906: IFFALSE 102922
// PlaceWeaponTurret ( b , weapon ) ;
102908: LD_VAR 0 8
102912: PPUSH
102913: LD_VAR 0 4
102917: PPUSH
102918: CALL_OW 431
// end ;
102922: LD_VAR 0 7
102926: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
102927: LD_INT 0
102929: PPUSH
102930: PPUSH
102931: PPUSH
102932: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
102933: LD_ADDR_VAR 0 4
102937: PUSH
102938: LD_INT 22
102940: PUSH
102941: LD_OWVAR 2
102945: PUSH
102946: EMPTY
102947: LIST
102948: LIST
102949: PUSH
102950: LD_INT 2
102952: PUSH
102953: LD_INT 30
102955: PUSH
102956: LD_INT 0
102958: PUSH
102959: EMPTY
102960: LIST
102961: LIST
102962: PUSH
102963: LD_INT 30
102965: PUSH
102966: LD_INT 1
102968: PUSH
102969: EMPTY
102970: LIST
102971: LIST
102972: PUSH
102973: EMPTY
102974: LIST
102975: LIST
102976: LIST
102977: PUSH
102978: EMPTY
102979: LIST
102980: LIST
102981: PPUSH
102982: CALL_OW 69
102986: ST_TO_ADDR
// if not tmp then
102987: LD_VAR 0 4
102991: NOT
102992: IFFALSE 102996
// exit ;
102994: GO 103055
// for i in tmp do
102996: LD_ADDR_VAR 0 2
103000: PUSH
103001: LD_VAR 0 4
103005: PUSH
103006: FOR_IN
103007: IFFALSE 103053
// for j = 1 to 3 do
103009: LD_ADDR_VAR 0 3
103013: PUSH
103014: DOUBLE
103015: LD_INT 1
103017: DEC
103018: ST_TO_ADDR
103019: LD_INT 3
103021: PUSH
103022: FOR_TO
103023: IFFALSE 103049
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
103025: LD_VAR 0 2
103029: PPUSH
103030: CALL_OW 274
103034: PPUSH
103035: LD_VAR 0 3
103039: PPUSH
103040: LD_INT 99999
103042: PPUSH
103043: CALL_OW 277
103047: GO 103022
103049: POP
103050: POP
103051: GO 103006
103053: POP
103054: POP
// end ;
103055: LD_VAR 0 1
103059: RET
// export function hHackSetLevel10 ; var i , j ; begin
103060: LD_INT 0
103062: PPUSH
103063: PPUSH
103064: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
103065: LD_ADDR_VAR 0 2
103069: PUSH
103070: LD_INT 21
103072: PUSH
103073: LD_INT 1
103075: PUSH
103076: EMPTY
103077: LIST
103078: LIST
103079: PPUSH
103080: CALL_OW 69
103084: PUSH
103085: FOR_IN
103086: IFFALSE 103138
// if IsSelected ( i ) then
103088: LD_VAR 0 2
103092: PPUSH
103093: CALL_OW 306
103097: IFFALSE 103136
// begin for j := 1 to 4 do
103099: LD_ADDR_VAR 0 3
103103: PUSH
103104: DOUBLE
103105: LD_INT 1
103107: DEC
103108: ST_TO_ADDR
103109: LD_INT 4
103111: PUSH
103112: FOR_TO
103113: IFFALSE 103134
// SetSkill ( i , j , 10 ) ;
103115: LD_VAR 0 2
103119: PPUSH
103120: LD_VAR 0 3
103124: PPUSH
103125: LD_INT 10
103127: PPUSH
103128: CALL_OW 237
103132: GO 103112
103134: POP
103135: POP
// end ;
103136: GO 103085
103138: POP
103139: POP
// end ;
103140: LD_VAR 0 1
103144: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
103145: LD_INT 0
103147: PPUSH
103148: PPUSH
103149: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
103150: LD_ADDR_VAR 0 2
103154: PUSH
103155: LD_INT 22
103157: PUSH
103158: LD_OWVAR 2
103162: PUSH
103163: EMPTY
103164: LIST
103165: LIST
103166: PUSH
103167: LD_INT 21
103169: PUSH
103170: LD_INT 1
103172: PUSH
103173: EMPTY
103174: LIST
103175: LIST
103176: PUSH
103177: EMPTY
103178: LIST
103179: LIST
103180: PPUSH
103181: CALL_OW 69
103185: PUSH
103186: FOR_IN
103187: IFFALSE 103228
// begin for j := 1 to 4 do
103189: LD_ADDR_VAR 0 3
103193: PUSH
103194: DOUBLE
103195: LD_INT 1
103197: DEC
103198: ST_TO_ADDR
103199: LD_INT 4
103201: PUSH
103202: FOR_TO
103203: IFFALSE 103224
// SetSkill ( i , j , 10 ) ;
103205: LD_VAR 0 2
103209: PPUSH
103210: LD_VAR 0 3
103214: PPUSH
103215: LD_INT 10
103217: PPUSH
103218: CALL_OW 237
103222: GO 103202
103224: POP
103225: POP
// end ;
103226: GO 103186
103228: POP
103229: POP
// end ;
103230: LD_VAR 0 1
103234: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
103235: LD_INT 0
103237: PPUSH
// uc_side := your_side ;
103238: LD_ADDR_OWVAR 20
103242: PUSH
103243: LD_OWVAR 2
103247: ST_TO_ADDR
// uc_nation := nation ;
103248: LD_ADDR_OWVAR 21
103252: PUSH
103253: LD_VAR 0 1
103257: ST_TO_ADDR
// InitHc ;
103258: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
103262: LD_INT 0
103264: PPUSH
103265: LD_VAR 0 2
103269: PPUSH
103270: LD_VAR 0 3
103274: PPUSH
103275: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
103279: LD_VAR 0 4
103283: PPUSH
103284: LD_VAR 0 5
103288: PPUSH
103289: CALL_OW 428
103293: PUSH
103294: LD_INT 0
103296: EQUAL
103297: IFFALSE 103321
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
103299: CALL_OW 44
103303: PPUSH
103304: LD_VAR 0 4
103308: PPUSH
103309: LD_VAR 0 5
103313: PPUSH
103314: LD_INT 1
103316: PPUSH
103317: CALL_OW 48
// end ;
103321: LD_VAR 0 6
103325: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
103326: LD_INT 0
103328: PPUSH
103329: PPUSH
// uc_side := your_side ;
103330: LD_ADDR_OWVAR 20
103334: PUSH
103335: LD_OWVAR 2
103339: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
103340: LD_VAR 0 1
103344: PUSH
103345: LD_INT 1
103347: PUSH
103348: LD_INT 2
103350: PUSH
103351: LD_INT 3
103353: PUSH
103354: LD_INT 4
103356: PUSH
103357: LD_INT 5
103359: PUSH
103360: EMPTY
103361: LIST
103362: LIST
103363: LIST
103364: LIST
103365: LIST
103366: IN
103367: IFFALSE 103379
// uc_nation := nation_american else
103369: LD_ADDR_OWVAR 21
103373: PUSH
103374: LD_INT 1
103376: ST_TO_ADDR
103377: GO 103422
// if chassis in [ 11 , 12 , 13 , 14 ] then
103379: LD_VAR 0 1
103383: PUSH
103384: LD_INT 11
103386: PUSH
103387: LD_INT 12
103389: PUSH
103390: LD_INT 13
103392: PUSH
103393: LD_INT 14
103395: PUSH
103396: EMPTY
103397: LIST
103398: LIST
103399: LIST
103400: LIST
103401: IN
103402: IFFALSE 103414
// uc_nation := nation_arabian else
103404: LD_ADDR_OWVAR 21
103408: PUSH
103409: LD_INT 2
103411: ST_TO_ADDR
103412: GO 103422
// uc_nation := nation_russian ;
103414: LD_ADDR_OWVAR 21
103418: PUSH
103419: LD_INT 3
103421: ST_TO_ADDR
// vc_chassis := chassis ;
103422: LD_ADDR_OWVAR 37
103426: PUSH
103427: LD_VAR 0 1
103431: ST_TO_ADDR
// vc_engine := engine ;
103432: LD_ADDR_OWVAR 39
103436: PUSH
103437: LD_VAR 0 2
103441: ST_TO_ADDR
// vc_control := control ;
103442: LD_ADDR_OWVAR 38
103446: PUSH
103447: LD_VAR 0 3
103451: ST_TO_ADDR
// vc_weapon := weapon ;
103452: LD_ADDR_OWVAR 40
103456: PUSH
103457: LD_VAR 0 4
103461: ST_TO_ADDR
// un := CreateVehicle ;
103462: LD_ADDR_VAR 0 8
103466: PUSH
103467: CALL_OW 45
103471: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
103472: LD_VAR 0 8
103476: PPUSH
103477: LD_INT 0
103479: PPUSH
103480: LD_INT 5
103482: PPUSH
103483: CALL_OW 12
103487: PPUSH
103488: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
103492: LD_VAR 0 8
103496: PPUSH
103497: LD_VAR 0 5
103501: PPUSH
103502: LD_VAR 0 6
103506: PPUSH
103507: LD_INT 1
103509: PPUSH
103510: CALL_OW 48
// end ;
103514: LD_VAR 0 7
103518: RET
// export hInvincible ; every 1 do
103519: GO 103521
103521: DISABLE
// hInvincible := [ ] ;
103522: LD_ADDR_EXP 152
103526: PUSH
103527: EMPTY
103528: ST_TO_ADDR
103529: END
// every 10 do var i ;
103530: GO 103532
103532: DISABLE
103533: LD_INT 0
103535: PPUSH
// begin enable ;
103536: ENABLE
// if not hInvincible then
103537: LD_EXP 152
103541: NOT
103542: IFFALSE 103546
// exit ;
103544: GO 103590
// for i in hInvincible do
103546: LD_ADDR_VAR 0 1
103550: PUSH
103551: LD_EXP 152
103555: PUSH
103556: FOR_IN
103557: IFFALSE 103588
// if GetLives ( i ) < 1000 then
103559: LD_VAR 0 1
103563: PPUSH
103564: CALL_OW 256
103568: PUSH
103569: LD_INT 1000
103571: LESS
103572: IFFALSE 103586
// SetLives ( i , 1000 ) ;
103574: LD_VAR 0 1
103578: PPUSH
103579: LD_INT 1000
103581: PPUSH
103582: CALL_OW 234
103586: GO 103556
103588: POP
103589: POP
// end ;
103590: PPOPN 1
103592: END
// export function hHackInvincible ; var i ; begin
103593: LD_INT 0
103595: PPUSH
103596: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
103597: LD_ADDR_VAR 0 2
103601: PUSH
103602: LD_INT 2
103604: PUSH
103605: LD_INT 21
103607: PUSH
103608: LD_INT 1
103610: PUSH
103611: EMPTY
103612: LIST
103613: LIST
103614: PUSH
103615: LD_INT 21
103617: PUSH
103618: LD_INT 2
103620: PUSH
103621: EMPTY
103622: LIST
103623: LIST
103624: PUSH
103625: EMPTY
103626: LIST
103627: LIST
103628: LIST
103629: PPUSH
103630: CALL_OW 69
103634: PUSH
103635: FOR_IN
103636: IFFALSE 103697
// if IsSelected ( i ) then
103638: LD_VAR 0 2
103642: PPUSH
103643: CALL_OW 306
103647: IFFALSE 103695
// begin if i in hInvincible then
103649: LD_VAR 0 2
103653: PUSH
103654: LD_EXP 152
103658: IN
103659: IFFALSE 103679
// hInvincible := hInvincible diff i else
103661: LD_ADDR_EXP 152
103665: PUSH
103666: LD_EXP 152
103670: PUSH
103671: LD_VAR 0 2
103675: DIFF
103676: ST_TO_ADDR
103677: GO 103695
// hInvincible := hInvincible union i ;
103679: LD_ADDR_EXP 152
103683: PUSH
103684: LD_EXP 152
103688: PUSH
103689: LD_VAR 0 2
103693: UNION
103694: ST_TO_ADDR
// end ;
103695: GO 103635
103697: POP
103698: POP
// end ;
103699: LD_VAR 0 1
103703: RET
// export function hHackInvisible ; var i , j ; begin
103704: LD_INT 0
103706: PPUSH
103707: PPUSH
103708: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
103709: LD_ADDR_VAR 0 2
103713: PUSH
103714: LD_INT 21
103716: PUSH
103717: LD_INT 1
103719: PUSH
103720: EMPTY
103721: LIST
103722: LIST
103723: PPUSH
103724: CALL_OW 69
103728: PUSH
103729: FOR_IN
103730: IFFALSE 103754
// if IsSelected ( i ) then
103732: LD_VAR 0 2
103736: PPUSH
103737: CALL_OW 306
103741: IFFALSE 103752
// ComForceInvisible ( i ) ;
103743: LD_VAR 0 2
103747: PPUSH
103748: CALL_OW 496
103752: GO 103729
103754: POP
103755: POP
// end ;
103756: LD_VAR 0 1
103760: RET
// export function hHackChangeYourSide ; begin
103761: LD_INT 0
103763: PPUSH
// if your_side = 8 then
103764: LD_OWVAR 2
103768: PUSH
103769: LD_INT 8
103771: EQUAL
103772: IFFALSE 103784
// your_side := 0 else
103774: LD_ADDR_OWVAR 2
103778: PUSH
103779: LD_INT 0
103781: ST_TO_ADDR
103782: GO 103798
// your_side := your_side + 1 ;
103784: LD_ADDR_OWVAR 2
103788: PUSH
103789: LD_OWVAR 2
103793: PUSH
103794: LD_INT 1
103796: PLUS
103797: ST_TO_ADDR
// end ;
103798: LD_VAR 0 1
103802: RET
// export function hHackChangeUnitSide ; var i , j ; begin
103803: LD_INT 0
103805: PPUSH
103806: PPUSH
103807: PPUSH
// for i in all_units do
103808: LD_ADDR_VAR 0 2
103812: PUSH
103813: LD_OWVAR 3
103817: PUSH
103818: FOR_IN
103819: IFFALSE 103897
// if IsSelected ( i ) then
103821: LD_VAR 0 2
103825: PPUSH
103826: CALL_OW 306
103830: IFFALSE 103895
// begin j := GetSide ( i ) ;
103832: LD_ADDR_VAR 0 3
103836: PUSH
103837: LD_VAR 0 2
103841: PPUSH
103842: CALL_OW 255
103846: ST_TO_ADDR
// if j = 8 then
103847: LD_VAR 0 3
103851: PUSH
103852: LD_INT 8
103854: EQUAL
103855: IFFALSE 103867
// j := 0 else
103857: LD_ADDR_VAR 0 3
103861: PUSH
103862: LD_INT 0
103864: ST_TO_ADDR
103865: GO 103881
// j := j + 1 ;
103867: LD_ADDR_VAR 0 3
103871: PUSH
103872: LD_VAR 0 3
103876: PUSH
103877: LD_INT 1
103879: PLUS
103880: ST_TO_ADDR
// SetSide ( i , j ) ;
103881: LD_VAR 0 2
103885: PPUSH
103886: LD_VAR 0 3
103890: PPUSH
103891: CALL_OW 235
// end ;
103895: GO 103818
103897: POP
103898: POP
// end ;
103899: LD_VAR 0 1
103903: RET
// export function hHackFog ; begin
103904: LD_INT 0
103906: PPUSH
// FogOff ( true ) ;
103907: LD_INT 1
103909: PPUSH
103910: CALL_OW 344
// end ;
103914: LD_VAR 0 1
103918: RET
// export function hHackTeleport ( unit , x , y ) ; begin
103919: LD_INT 0
103921: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
103922: LD_VAR 0 1
103926: PPUSH
103927: LD_VAR 0 2
103931: PPUSH
103932: LD_VAR 0 3
103936: PPUSH
103937: LD_INT 1
103939: PPUSH
103940: LD_INT 1
103942: PPUSH
103943: CALL_OW 483
// CenterOnXY ( x , y ) ;
103947: LD_VAR 0 2
103951: PPUSH
103952: LD_VAR 0 3
103956: PPUSH
103957: CALL_OW 84
// end ; end_of_file
103961: LD_VAR 0 4
103965: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
103966: LD_VAR 0 1
103970: PPUSH
103971: LD_VAR 0 2
103975: PPUSH
103976: LD_VAR 0 3
103980: PPUSH
103981: LD_VAR 0 4
103985: PPUSH
103986: LD_VAR 0 5
103990: PPUSH
103991: LD_VAR 0 6
103995: PPUSH
103996: CALL 90794 0 6
// end ;
104000: PPOPN 6
104002: END
